// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Pecu
//# unitInfo: Requires: Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Expected_Await_encode = "Expected `Await encode",
    cst_lib_pecu_ml = "lib/pecu.ml",
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib = global_data.Stdlib,
    Stdlib_Format = global_data.Stdlib__Format,
    _g_ = [0, cst_lib_pecu_ml, 662, 9],
    _f_ = [0, cst_lib_pecu_ml, 531, 11],
    _e_ = [0, 748194550, 32],
    _d_ = [0, cst_lib_pecu_ml, 323, 13],
    _c_ = [0, cst_lib_pecu_ml, 26, 11],
    _b_ =
      [0,
       [11,
        "Invalid bounds (off: ",
        [4, 0, 0, 0, [11, ", len: ", [4, 0, 0, 0, [12, 41, 0]]]]],
       "Invalid bounds (off: %d, len: %d)"],
    _a_ = [0, [11, cst_Expected_Await_encode, 0], cst_Expected_Await_encode];
   function invalid_arg(fmt){
    function _ad_(s){return caml_call1(Stdlib[1], s);}
    return caml_call2(Stdlib_Format[147], _ad_, fmt);
   }
   function invalid_encode(param){return invalid_arg(_a_);}
   function invalid_bounds(off, len){
    return caml_call2(invalid_arg(_b_), off, len);
   }
   function malformed(source, off, pos, len){
    return [0,
            659980059,
            caml_call3(Stdlib_Bytes[8], source, off + pos | 0, len)];
   }
   function unsafe_byte(source, off, pos){
    return runtime.caml_bytes_unsafe_get(source, off + pos | 0);
   }
   function unsafe_set_chr(source, off, chr){
    runtime.caml_bytes_unsafe_set(source, off, chr);
    return;
   }
   function r_chr(chr){return [0, 3355149, chr];}
   function i_rem(decoder){return (decoder[5] - decoder[4] | 0) + 1 | 0;}
   function end_of_input(decoder){
    decoder[2] = Stdlib_Bytes[3];
    decoder[3] = 0;
    decoder[4] = 0;
    decoder[5] = Stdlib[20];
    return 0;
   }
   function src(decoder, source, off, len){
    if
     (0 <= off && 0 <= len && caml_ml_bytes_length(source) >= (off + len | 0))
     return 0 === len
             ? end_of_input(decoder)
             : (decoder
                [2]
               = source,
               decoder[3] = off,
               decoder[4] = 0,
               decoder[5] = len - 1 | 0,
               0);
    return invalid_bounds(off, len);
   }
   function refill(k, decoder){
    var match = decoder[1];
    if(typeof match === "number"){decoder[15] = k; return 1006505782;}
    if(438511779 <= match[1]){
     var
      ic = match[2],
      len =
        caml_call4
         (Stdlib[84], ic, decoder[2], 0, caml_ml_bytes_length(decoder[2]));
     src(decoder, decoder[2], 0, len);
     return caml_call1(k, decoder);
    }
    end_of_input(decoder);
    return caml_call1(k, decoder);
   }
   function reset(decoder){decoder[13] = 0; return;}
   function ret(k, v, byte_count, decoder){
    decoder[15] = k;
    decoder[12] = decoder[12] + byte_count | 0;
    decoder[13] = decoder[13] + byte_count | 0;
    if(78 < decoder[13]) decoder[11] = 1;
    return caml_call2(decoder[14], decoder, v);
   }
   function malformed_line(source, off, len, decoder){
    caml_call2(Stdlib_Buffer[21], decoder[6], decoder[7]);
    caml_call4(Stdlib_Buffer[19], decoder[6], source, off, len);
    var line = caml_call1(Stdlib_Buffer[2], decoder[6]);
    caml_call1(Stdlib_Buffer[8], decoder[7]);
    caml_call1(Stdlib_Buffer[8], decoder[6]);
    return [0, 659980059, line];
   }
   function t_need(decoder, need){decoder[9] = 0; decoder[10] = need; return;}
   function t_fill(k, decoder){
    function blit(decoder, len){
     caml_blit_bytes
      (decoder[2], decoder[3] + decoder[4] | 0, decoder[8], decoder[9], len);
     decoder[4] = decoder[4] + len | 0;
     decoder[9] = decoder[9] + len | 0;
     return;
    }
    var rem = i_rem(decoder);
    if(0 > rem) return caml_call1(k, decoder);
    var need = decoder[10] - decoder[9] | 0;
    return rem < need
            ? (blit
               (decoder, rem),
              refill(function(_ac_){return t_fill(k, _ac_);}, decoder))
            : (blit(decoder, need), caml_call1(k, decoder));
   }
   function t_decode_quoted_printable(decoder){
    if(decoder[9] < decoder[10]){
     var _$_ = decoder[9];
     return ret
             (decode_quoted_printable,
              malformed_line(decoder[8], 0, decoder[9], decoder),
              _$_,
              decoder);
    }
    var
     len = decoder[9],
     source = decoder[8],
     _aa_ = decoder[9],
     a = unsafe_byte(source, 0, 1),
     b = unsafe_byte(source, 0, 2),
     off = 0;
    function of_hex(chr){
     if(58 <= chr){
      if(5 >= chr - 65 >>> 0) return (chr - 65 | 0) + 10 | 0;
     }
     else if(48 <= chr) return chr - 48 | 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
    a:
    {
     b:
     if(61 === unsafe_byte(source, off, 0)){
      var switcher = a - 48 | 0;
      if(22 < switcher >>> 0){
       if(-35 === switcher && 10 === b){var _ab_ = -207855799; break a;}
      }
      else if(6 < switcher - 10 >>> 0){
       if(58 <= b){if(5 < b - 65 >>> 0) break b;} else if(48 > b) break b;
       var
        ___ = of_hex(b),
        _ab_ = [0, 914392213, (of_hex(a) * 16 | 0) + ___ | 0];
       break a;
      }
     }
     var _ab_ = malformed(source, off, 0, len);
    }
    return ret(decode_quoted_printable, _ab_, _aa_, decoder);
   }
   function t_decode_line_break(decoder){
    if(decoder[9] < decoder[10]){
     var _X_ = decoder[9];
     return ret
             (decode_quoted_printable,
              malformed_line(decoder[8], 0, decoder[9], decoder),
              _X_,
              decoder);
    }
    var
     len = decoder[9],
     source = decoder[8],
     _Y_ = decoder[9],
     str = caml_call3(Stdlib_Bytes[8], source, 0, len),
     off = 0,
     _Z_ =
       runtime.caml_string_notequal(str, "\r\n")
        ? malformed(source, off, 0, len)
        : -879233260;
    return ret(decode_quoted_printable, _Z_, _Y_, decoder);
   }
   function decode_quoted_printable(decoder){
    var rem = i_rem(decoder);
    if(0 >= rem){
     if(0 <= rem) return refill(decode_quoted_printable, decoder);
     var _V_ = 0, _W_ = 3455931;
     return ret(function(decoder){return 3455931;}, _W_, _V_, decoder);
    }
    var wsp = unsafe_byte(decoder[2], decoder[3], decoder[4]);
    a:
    {
     if(32 <= wsp){
      var switcher = wsp - 33 | 0;
      if(93 >= switcher >>> 0)
       return 28 === switcher
               ? (t_need
                  (decoder, 3),
                 t_fill(t_decode_quoted_printable, decoder))
               : (caml_call2
                  (Stdlib_Buffer[21], decoder[6], decoder[7]),
                 caml_call1(Stdlib_Buffer[8], decoder[7]),
                 decoder[4] = decoder[4] + 1 | 0,
                 ret(decode_quoted_printable, r_chr(wsp), 1, decoder));
      if(0 <= switcher) break a;
     }
     else if(9 !== wsp){
      if(13 !== wsp) break a;
      t_need(decoder, 2);
      return t_fill(t_decode_line_break, decoder);
     }
     decoder[4] = decoder[4] + 1 | 0;
     return ret(decode_quoted_printable, [0, 4352180, wsp], 1, decoder);
    }
    var j = decoder[4];
    decoder[4] = decoder[4] + 1 | 0;
    return ret
            (decode_quoted_printable,
             malformed(decoder[2], decoder[3], j, 1),
             1,
             decoder);
   }
   function pp_quoted_printable(decoder, v){
    if(typeof v === "number"){
     if(-207855799 === v){
      caml_call2(Stdlib_Buffer[21], decoder[6], decoder[7]);
      var data = caml_call1(Stdlib_Buffer[2], decoder[6]);
      caml_call1(Stdlib_Buffer[8], decoder[7]);
      caml_call1(Stdlib_Buffer[8], decoder[6]);
      reset(decoder);
      return [0, 758940234, data];
     }
     if(3455931 <= v){
      caml_call2(Stdlib_Buffer[21], decoder[6], decoder[7]);
      var data$0 = caml_call1(Stdlib_Buffer[2], decoder[6]);
      caml_call1(Stdlib_Buffer[8], decoder[7]);
      caml_call1(Stdlib_Buffer[8], decoder[6]);
      return [0, 758940234, data$0];
     }
     var line = caml_call1(Stdlib_Buffer[2], decoder[6]);
     caml_call1(Stdlib_Buffer[8], decoder[7]);
     caml_call1(Stdlib_Buffer[8], decoder[6]);
     reset(decoder);
     return [0, 848053268, line];
    }
    var _U_ = v[1];
    if(659980059 <= _U_){
     if(914392213 > _U_) return v;
     var byte$0 = v[2];
     caml_call2(Stdlib_Buffer[21], decoder[6], decoder[7]);
     caml_call1(Stdlib_Buffer[8], decoder[7]);
     caml_call2(Stdlib_Buffer[12], decoder[6], byte$0);
     return caml_call1(decoder[15], decoder);
    }
    if(4352180 <= _U_){
     var wsp = v[2];
     caml_call2(Stdlib_Buffer[12], decoder[7], wsp);
     return caml_call1(decoder[15], decoder);
    }
    var chr = v[2];
    caml_call2(Stdlib_Buffer[21], decoder[6], decoder[7]);
    caml_call1(Stdlib_Buffer[8], decoder[7]);
    caml_call2(Stdlib_Buffer[12], decoder[6], chr);
    return caml_call1(decoder[15], decoder);
   }
   function decoder(src){
    if(typeof src === "number")
     var i_len = 0, i_pos = 1, i_off = 0, i = Stdlib_Bytes[3];
    else if(438511779 <= src[1])
     var i_len = 0, i_pos = 1, i_off = 0, i = caml_create_bytes(65536);
    else
     var
      s = src[2],
      i_len$0 = caml_ml_string_length(s) - 1 | 0,
      i$0 = caml_call1(Stdlib_Bytes[45], s),
      i_len = i_len$0,
      i_pos = 0,
      i_off = 0,
      i = i$0;
    var _T_ = caml_call1(Stdlib_Buffer[1], 80);
    return [0,
            src,
            i,
            i_off,
            i_pos,
            i_len,
            caml_call1(Stdlib_Buffer[1], 80),
            _T_,
            caml_create_bytes(3),
            0,
            0,
            0,
            0,
            0,
            pp_quoted_printable,
            decode_quoted_printable];
   }
   function decode(decoder){return caml_call1(decoder[15], decoder);}
   function decoder_byte_count(decoder){return decoder[12];}
   function decoder_src(decoder){return decoder[1];}
   function decoder_dangerous(decoder){return decoder[11];}
   var r_wsp = 4352180;
   function i_rem$0(decoder){return (decoder[5] - decoder[4] | 0) + 1 | 0;}
   function end_of_input$0(decoder){
    decoder[2] = Stdlib_Bytes[3];
    decoder[3] = 0;
    decoder[4] = 0;
    decoder[5] = Stdlib[20];
    return 0;
   }
   function src$0(decoder, source, off, len){
    if
     (0 <= off && 0 <= len && caml_ml_bytes_length(source) >= (off + len | 0))
     return 0 === len
             ? end_of_input$0(decoder)
             : (decoder
                [2]
               = source,
               decoder[3] = off,
               decoder[4] = 0,
               decoder[5] = len - 1 | 0,
               0);
    return invalid_bounds(off, len);
   }
   function refill$0(k, decoder){
    var match = decoder[1];
    if(typeof match === "number"){decoder[11] = k; return 1006505782;}
    if(438511779 <= match[1]){
     var
      ic = match[2],
      len =
        caml_call4
         (Stdlib[84], ic, decoder[2], 0, caml_ml_bytes_length(decoder[2]));
     src$0(decoder, decoder[2], 0, len);
     return caml_call1(k, decoder);
    }
    end_of_input$0(decoder);
    return caml_call1(k, decoder);
   }
   function ret$0(k, v, byte_count, decoder){
    decoder[11] = k;
    decoder[9] = decoder[9] + byte_count | 0;
    return caml_call2(decoder[10], decoder, v);
   }
   function t_fill$0(k, decoder){
    function blit(decoder, len){
     caml_blit_bytes
      (decoder[2], decoder[3] + decoder[4] | 0, decoder[6], decoder[7], len);
     decoder[4] = decoder[4] + len | 0;
     decoder[7] = decoder[7] + len | 0;
     return;
    }
    var rem = i_rem$0(decoder);
    if(0 > rem) return caml_call1(k, decoder);
    var need = decoder[8] - decoder[7] | 0;
    return rem < need
            ? (blit
               (decoder, rem),
              refill$0(function(_S_){return t_fill$0(k, _S_);}, decoder))
            : (blit(decoder, need), caml_call1(k, decoder));
   }
   function t_decode_inline_quoted_printab(decoder){
    if(decoder[7] < decoder[8]){
     var _P_ = decoder[7];
     return ret$0
             (decode_inline_quoted_printable,
              malformed(decoder[6], 0, 0, decoder[7]),
              _P_,
              decoder);
    }
    var
     len = decoder[7],
     source = decoder[6],
     _Q_ = decoder[7],
     a = unsafe_byte(source, 0, 1),
     b = unsafe_byte(source, 0, 2),
     off = 0;
    function of_hex(chr){
     if(65 <= chr){
      if(97 <= chr){
       if(103 > chr) return (chr - 97 | 0) + 10 | 0;
      }
      else if(71 > chr) return (chr - 65 | 0) + 10 | 0;
     }
     else if(9 >= chr - 48 >>> 0) return chr - 48 | 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    a:
    {
     b:
     if(61 === unsafe_byte(source, off, 0)){
      var _M_ = a - 48 | 0;
      if(22 < _M_ >>> 0){
       if(5 < _M_ - 49 >>> 0) break b;
      }
      else if(6 >= _M_ - 10 >>> 0) break b;
      var _N_ = b - 48 | 0;
      if(22 < _N_ >>> 0){
       if(5 < _N_ - 49 >>> 0) break b;
      }
      else if(6 >= _N_ - 10 >>> 0) break b;
      var
       _O_ = of_hex(b),
       _R_ = [0, 914392213, (of_hex(a) * 16 | 0) + _O_ | 0];
      break a;
     }
     var _R_ = malformed(source, off, 0, len);
    }
    return ret$0(decode_inline_quoted_printable, _R_, _Q_, decoder);
   }
   function decode_inline_quoted_printable(decoder){
    var rem = i_rem$0(decoder);
    if(0 >= rem){
     if(0 <= rem) return refill$0(decode_inline_quoted_printable, decoder);
     var _K_ = 0, _L_ = 3455931;
     return ret$0(function(decoder){return 3455931;}, _L_, _K_, decoder);
    }
    var chr = unsafe_byte(decoder[2], decoder[3], decoder[4]);
    a:
    {
     if(62 <= chr){
      if(95 === chr){
       decoder[4] = decoder[4] + 1 | 0;
       return ret$0(decode_inline_quoted_printable, r_wsp, 1, decoder);
      }
      if(127 > chr) break a;
     }
     else if(33 <= chr){
      if(61 > chr) break a;
      decoder[7] = 0;
      decoder[8] = 3;
      return t_fill$0(t_decode_inline_quoted_printab, decoder);
     }
     var j = decoder[4];
     decoder[4] = decoder[4] + 1 | 0;
     return ret$0
             (decode_inline_quoted_printable,
              malformed(decoder[2], decoder[3], j, 1),
              1,
              decoder);
    }
    decoder[4] = decoder[4] + 1 | 0;
    return ret$0(decode_inline_quoted_printable, r_chr(chr), 1, decoder);
   }
   function pp_inline_quoted_printable(decoder, v){
    if(typeof v === "number") return 4352180 <= v ? _e_ : 3455931;
    var _J_ = v[1];
    if(659980059 === _J_) return v;
    if(914392213 <= _J_){var byte$0 = v[2]; return [0, 748194550, byte$0];}
    var chr = v[2];
    return [0, 748194550, chr];
   }
   function decoder$0(src){
    if(typeof src === "number")
     var i_len = 0, i_pos = 1, i_off = 0, i = Stdlib_Bytes[3];
    else if(438511779 <= src[1])
     var i_len = 0, i_pos = 1, i_off = 0, i = caml_create_bytes(65536);
    else
     var
      s = src[2],
      i_len$0 = caml_ml_string_length(s) - 1 | 0,
      i$0 = caml_call1(Stdlib_Bytes[45], s),
      i_len = i_len$0,
      i_pos = 0,
      i_off = 0,
      i = i$0;
    return [0,
            src,
            i,
            i_off,
            i_pos,
            i_len,
            caml_create_bytes(3),
            0,
            0,
            0,
            pp_inline_quoted_printable,
            decode_inline_quoted_printable];
   }
   function decode$0(decoder){return caml_call1(decoder[11], decoder);}
   function decoder_byte_count$0(decoder){return decoder[9];}
   function decoder_src$0(decoder){return decoder[1];}
   function o_rem(encoder){return (encoder[5] - encoder[4] | 0) + 1 | 0;}
   function dst(encoder, source, off, len){
    var _G_ = off < 0 ? 1 : 0;
    if(_G_)
     var _H_ = _G_;
    else
     var
      _I_ = len < 0 ? 1 : 0,
      _H_ = _I_ || (caml_ml_bytes_length(source) < (off + len | 0) ? 1 : 0);
    if(_H_) invalid_bounds(off, len);
    encoder[2] = source;
    encoder[3] = off;
    encoder[4] = 0;
    encoder[5] = len - 1 | 0;
    return 0;
   }
   function flush(k, encoder){
    var match = encoder[1];
    if(typeof match === "number"){
     encoder[9] =
      function(encoder, param){
       if(typeof param === "number" && 1006505782 <= param)
        return caml_call1(k, encoder);
       return invalid_encode(0);
      };
     return 939392865;
    }
    if(438511779 <= match[1]){
     var oc = match[2];
     caml_call4(Stdlib[68], oc, encoder[2], encoder[3], encoder[4]);
     encoder[4] = 0;
     return caml_call1(k, encoder);
    }
    var b = match[2], o = caml_call1(Stdlib_Bytes[44], encoder[2]);
    caml_call4(Stdlib_Buffer[18], b, o, encoder[3], encoder[4]);
    encoder[4] = 0;
    return caml_call1(k, encoder);
   }
   function t_flush(k, encoder){
    function blit(encoder, len){
     caml_blit_bytes(encoder[6], encoder[7], encoder[2], encoder[4], len);
     encoder[4] = encoder[4] + len | 0;
     encoder[7] = encoder[7] + len | 0;
     return;
    }
    var rem = o_rem(encoder), len = (encoder[8] - encoder[7] | 0) + 1 | 0;
    return rem < len
            ? (blit
               (encoder, rem),
              flush(function(_F_){return t_flush(k, _F_);}, encoder))
            : (blit(encoder, len), caml_call1(k, encoder));
   }
   function to_hex(code){
    if(10 > code) return caml_call1(Stdlib_Char[1], 48 + code | 0);
    if(16 <= code)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    return caml_call1(Stdlib_Char[1], (65 + code | 0) - 10 | 0);
   }
   function encode_quoted_printable(encoder, v){
    function k(encoder){encoder[9] = encode_quoted_printable; return 17724;}
    if(typeof v === "number")
     return 1006505782 <= v ? k(encoder) : flush(k, encoder);
    var chr = v[2], rem = o_rem(encoder);
    if(1 > rem)
     return flush
             (function(encoder){return encode_quoted_printable(encoder, v);},
              encoder);
    var switcher = chr - 33 | 0;
    if(93 < switcher >>> 0){
     if(-1 === switcher){
      unsafe_set_chr(encoder[2], encoder[3] + encoder[4] | 0, 95);
      encoder[4] = encoder[4] + 1 | 0;
      return k(encoder);
     }
    }
    else if(28 !== switcher){
     unsafe_set_chr(encoder[2], encoder[3] + encoder[4] | 0, chr);
     encoder[4] = encoder[4] + 1 | 0;
     return k(encoder);
    }
    var hi = to_hex(chr / 16 | 0), lo = to_hex(chr % 16 | 0);
    if(3 <= rem){
     var j = encoder[4];
     encoder[4] = encoder[4] + 3 | 0;
     var
      j$0 = encoder[3] + j | 0,
      s = encoder[2],
      k$0 = k,
      j$1 = j$0,
      s$0 = s;
    }
    else{
     encoder[7] = 0;
     encoder[8] = 3;
     var
      _D_ = function(_E_){return t_flush(k, _E_);},
      k$0 = _D_,
      j$1 = 0,
      s$0 = encoder[6];
    }
    unsafe_set_chr(s$0, j$1, 61);
    unsafe_set_chr(s$0, j$1 + 1 | 0, hi);
    unsafe_set_chr(s$0, j$1 + 2 | 0, lo);
    return k$0(encoder);
   }
   function encoder(dst){
    if(typeof dst === "number")
     var o_len = 0, o_pos = 0, o_off = 1, o = Stdlib_Bytes[3];
    else
     var
      o$0 = caml_create_bytes(65536),
      o_len = 65535,
      o_pos = 0,
      o_off = 0,
      o = o$0;
    return [0,
            dst,
            o,
            o_off,
            o_pos,
            o_len,
            caml_create_bytes(3),
            1,
            0,
            encode_quoted_printable];
   }
   function encode(encoder, v){return caml_call2(encoder[9], encoder, v);}
   function encoder_dst(encoder){return encoder[1];}
   function o_rem$0(encoder){return (encoder[5] - encoder[4] | 0) + 1 | 0;}
   function dst$0(encoder, source, off, len){
    var _A_ = off < 0 ? 1 : 0;
    if(_A_)
     var _B_ = _A_;
    else
     var
      _C_ = len < 0 ? 1 : 0,
      _B_ = _C_ || (caml_ml_bytes_length(source) < (off + len | 0) ? 1 : 0);
    if(_B_) invalid_bounds(off, len);
    encoder[2] = source;
    encoder[3] = off;
    encoder[4] = 0;
    encoder[5] = len - 1 | 0;
    return 0;
   }
   function flush$0(k, encoder){
    var match = encoder[1];
    if(typeof match === "number"){
     encoder[10] =
      function(encoder, param){
       if(typeof param === "number" && 1006505782 <= param)
        return caml_call1(k, encoder);
       return invalid_encode(0);
      };
     return 939392865;
    }
    if(438511779 <= match[1]){
     var oc = match[2];
     caml_call4(Stdlib[68], oc, encoder[2], encoder[3], encoder[4]);
     encoder[4] = 0;
     return caml_call1(k, encoder);
    }
    var b = match[2], o = caml_call1(Stdlib_Bytes[44], encoder[2]);
    caml_call4(Stdlib_Buffer[18], b, o, encoder[3], encoder[4]);
    encoder[4] = 0;
    return caml_call1(k, encoder);
   }
   function t_range(encoder, len){encoder[7] = 0; encoder[8] = len; return;}
   function t_flush$0(k, encoder){
    function blit(encoder, len){
     caml_blit_bytes(encoder[6], encoder[7], encoder[2], encoder[4], len);
     encoder[4] = encoder[4] + len | 0;
     encoder[7] = encoder[7] + len | 0;
     return;
    }
    var rem = o_rem$0(encoder), len = (encoder[8] - encoder[7] | 0) + 1 | 0;
    return rem < len
            ? (blit
               (encoder, rem),
              flush$0(function(_z_){return t_flush$0(k, _z_);}, encoder))
            : (blit(encoder, len), caml_call1(k, encoder));
   }
   function to_hex$0(code){
    if(10 > code) return caml_call1(Stdlib_Char[1], 48 + code | 0);
    if(16 <= code)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    return caml_call1(Stdlib_Char[1], (65 + code | 0) - 10 | 0);
   }
   function encode_quoted_printable$0(encoder, v){
    function k(col_count, encoder){
     encoder[9] = encoder[9] + col_count | 0;
     encoder[10] = encode_quoted_printable$0;
     return 17724;
    }
    if(typeof v === "number"){
     if(3455931 === v){
      var _j_ = 0;
      return flush$0(function(_y_){return k(_j_, _y_);}, encoder);
     }
     if(1006505782 <= v) return k(0, encoder);
     var rem = o_rem$0(encoder);
     if(2 <= rem){
      var j = encoder[4];
      encoder[4] = encoder[4] + 2 | 0;
      var
       _k_ = 2,
       k$0 = function(_v_){return k(_k_, _v_);},
       j$0 = encoder[3] + j | 0,
       s = encoder[2],
       k$1 = k$0,
       j$1 = j$0,
       s$0 = s;
     }
     else{
      t_range(encoder, 2);
      var
       _l_ = 2,
       _m_ = function(_x_){return k(_l_, _x_);},
       _n_ = function(_w_){return t_flush$0(_m_, _w_);},
       k$1 = _n_,
       j$1 = 0,
       s$0 = encoder[6];
     }
     unsafe_set_chr(s$0, j$1, 13);
     unsafe_set_chr(s$0, j$1 + 1 | 0, 10);
     encoder[9] = 0;
     return flush$0(k$1, encoder);
    }
    var unsafe_chr = v[2], rem$0 = o_rem$0(encoder);
    if(1 > rem$0)
     return flush$0
             (function(encoder){return encode_quoted_printable$0(encoder, v);},
              encoder);
    if(75 === encoder[9])
     return encode_soft_line_break
             (function(encoder){return encode_quoted_printable$0(encoder, v);},
              encoder);
    var switcher = unsafe_chr - 33 | 0;
    if(93 >= switcher >>> 0 && 28 !== switcher){
     unsafe_set_chr(encoder[2], encoder[3] + encoder[4] | 0, unsafe_chr);
     encoder[4] = encoder[4] + 1 | 0;
     return k(1, encoder);
    }
    if(73 <= encoder[9])
     return encode_soft_line_break
             (function(encoder){return encode_quoted_printable$0(encoder, v);},
              encoder);
    var
     hi = to_hex$0(unsafe_chr / 16 | 0),
     lo = to_hex$0(unsafe_chr % 16 | 0);
    if(3 <= rem$0){
     var j$2 = encoder[4];
     encoder[4] = encoder[4] + 3 | 0;
     var
      _o_ = 3,
      k$2 = function(_s_){return k(_o_, _s_);},
      j$3 = encoder[3] + j$2 | 0,
      s$1 = encoder[2],
      k$3 = k$2,
      j$4 = j$3,
      s$2 = s$1;
    }
    else{
     t_range(encoder, 3);
     var
      _p_ = 3,
      _q_ = function(_u_){return k(_p_, _u_);},
      _r_ = function(_t_){return t_flush$0(_q_, _t_);},
      k$3 = _r_,
      j$4 = 0,
      s$2 = encoder[6];
    }
    unsafe_set_chr(s$2, j$4, 61);
    unsafe_set_chr(s$2, j$4 + 1 | 0, hi);
    unsafe_set_chr(s$2, j$4 + 2 | 0, lo);
    return k$3(encoder);
   }
   function encode_soft_line_break(k, encoder){
    var rem = o_rem$0(encoder);
    if(3 <= rem){
     var j = encoder[4];
     encoder[4] = encoder[4] + 3 | 0;
     var
      j$0 = encoder[3] + j | 0,
      s = encoder[2],
      k$0 = k,
      j$1 = j$0,
      s$0 = s;
    }
    else{
     t_range(encoder, 3);
     var
      _h_ = function(_i_){return t_flush$0(k, _i_);},
      k$0 = _h_,
      j$1 = 0,
      s$0 = encoder[6];
    }
    unsafe_set_chr(s$0, j$1, 61);
    unsafe_set_chr(s$0, j$1 + 1 | 0, 13);
    unsafe_set_chr(s$0, j$1 + 2 | 0, 10);
    encoder[9] = 0;
    return flush$0(k$0, encoder);
   }
   function encoder$0(dst){
    if(typeof dst === "number")
     var o_len = 0, o_pos = 0, o_off = 1, o = Stdlib_Bytes[3];
    else
     var
      o$0 = caml_create_bytes(65536),
      o_len = 65535,
      o_pos = 0,
      o_off = 0,
      o = o$0;
    return [0,
            dst,
            o,
            o_off,
            o_pos,
            o_len,
            caml_create_bytes(3),
            1,
            0,
            0,
            encode_quoted_printable$0];
   }
   function encode$0(encoder, v){return caml_call2(encoder[10], encoder, v);}
   function encoder_dst$0(encoder){return encoder[1];}
   var
    Pecu =
      [0,
       src,
       decoder,
       decode,
       decoder_byte_count,
       decoder_src,
       decoder_dangerous,
       encoder$0,
       encode$0,
       encoder_dst$0,
       dst$0,
       o_rem$0,
       [0,
        src$0,
        decoder$0,
        decode$0,
        decoder_byte_count$0,
        decoder_src$0,
        encoder,
        encode,
        encoder_dst,
        dst,
        o_rem]];
   runtime.caml_register_global(14, Pecu, "Pecu");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwZWN1LmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJpbnZhbGlkX2FyZyIsImZtdCIsInMiLCJpbnZhbGlkX2VuY29kZSIsImludmFsaWRfYm91bmRzIiwib2ZmIiwibGVuIiwibWFsZm9ybWVkIiwic291cmNlIiwicG9zIiwidW5zYWZlX2J5dGUiLCJ1bnNhZmVfc2V0X2NociIsImNociIsInJfY2hyIiwiaV9yZW0iLCJkZWNvZGVyIiwiZW5kX29mX2lucHV0Iiwic3JjIiwicmVmaWxsIiwiayIsImljIiwicmVzZXQiLCJyZXQiLCJ2IiwiYnl0ZV9jb3VudCIsIm1hbGZvcm1lZF9saW5lIiwibGluZSIsInRfbmVlZCIsIm5lZWQiLCJ0X2ZpbGwiLCJibGl0IiwicmVtIiwidF9kZWNvZGVfcXVvdGVkX3ByaW50YWJsZSIsImRlY29kZV9xdW90ZWRfcHJpbnRhYmxlIiwiYSIsImIiLCJvZl9oZXgiLCJ0X2RlY29kZV9saW5lX2JyZWFrIiwic3RyIiwid3NwIiwiaiIsInBwX3F1b3RlZF9wcmludGFibGUiLCJkYXRhIiwiZGF0YSQwIiwiYnl0ZSQwIiwiaV9sZW4iLCJpX3BvcyIsImlfb2ZmIiwiaSIsImlfbGVuJDAiLCJpJDAiLCJkZWNvZGUiLCJkZWNvZGVyX2J5dGVfY291bnQiLCJkZWNvZGVyX3NyYyIsImRlY29kZXJfZGFuZ2Vyb3VzIiwicl93c3AiLCJpX3JlbSQwIiwiZW5kX29mX2lucHV0JDAiLCJzcmMkMCIsInJlZmlsbCQwIiwicmV0JDAiLCJ0X2ZpbGwkMCIsInRfZGVjb2RlX2lubGluZV9xdW90ZWRfcHJpbnRhYiIsImRlY29kZV9pbmxpbmVfcXVvdGVkX3ByaW50YWJsZSIsInBwX2lubGluZV9xdW90ZWRfcHJpbnRhYmxlIiwiZGVjb2RlciQwIiwiZGVjb2RlJDAiLCJkZWNvZGVyX2J5dGVfY291bnQkMCIsImRlY29kZXJfc3JjJDAiLCJvX3JlbSIsImVuY29kZXIiLCJkc3QiLCJmbHVzaCIsIm9jIiwibyIsInRfZmx1c2giLCJ0b19oZXgiLCJjb2RlIiwiZW5jb2RlX3F1b3RlZF9wcmludGFibGUiLCJoaSIsImxvIiwiaiQwIiwiayQwIiwiaiQxIiwicyQwIiwib19sZW4iLCJvX3BvcyIsIm9fb2ZmIiwibyQwIiwiZW5jb2RlIiwiZW5jb2Rlcl9kc3QiLCJvX3JlbSQwIiwiZHN0JDAiLCJmbHVzaCQwIiwidF9yYW5nZSIsInRfZmx1c2gkMCIsInRvX2hleCQwIiwiZW5jb2RlX3F1b3RlZF9wcmludGFibGUkMCIsImNvbF9jb3VudCIsImskMSIsInVuc2FmZV9jaHIiLCJyZW0kMCIsImVuY29kZV9zb2Z0X2xpbmVfYnJlYWsiLCJqJDIiLCJrJDIiLCJqJDMiLCJzJDEiLCJrJDMiLCJqJDQiLCJzJDIiLCJlbmNvZGVyJDAiLCJlbmNvZGUkMCIsImVuY29kZXJfZHN0JDAiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9wZWN1L3BlY3UubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBQ0lBLFlBQVlDO2tCQUEyQkMsR0FBSyxPQUFBLHNCQUFMQSxHQUFrQjtJQUF2QyxPQUFBLHFDQUFORDtHQUFrRDtZQUM5REUsc0JBQW9CLE9BRHBCSCxpQkFDd0Q7WUFFeERJLGVBQWVDLEtBQUlDO0lBQ3JCLE9BQUEsV0FKRU4sa0JBR2VLLEtBQUlDO0dBQ2tDO1lBRXJEQyxVQUFVQyxRQUFPSCxLQUFJSSxLQUFJSDtJQUMzQjs7WUFBVyw0QkFEQ0UsUUFBT0gsTUFBSUksU0FBSUg7R0FDeUI7WUFFbERJLFlBQVlGLFFBQU9ILEtBQUlJO0lBQU0scUNBQWpCRCxRQUFPSCxNQUFJSTtHQUF5QztZQUdoRUUsZUFBZUgsUUFBT0gsS0FBSU87SUFBTSw4QkFBakJKLFFBQU9ILEtBQUlPOztHQUFxQztZQWdDL0RDLE1BQU1ELEtBQU0sb0JBQU5BLEtBQWM7WUFpRXBCRSxNQUFNQyxTQUFVLFFBQVZB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QztNQUFIYixJQUFBYztJQU1KO1lBUFVqQjtZQUNORztZQUFHYTtZQUFPRDtZQUFPRDtZQVdoQjs7OztZQXpGQ1k7R0E2RndCO1lBRTVCYyxTQUFPekMsU0FBUS9DLEdBQUksT0FBQSxXQUFaK0MsYUFBQUEsU0FBUS9DLEdBQXVCO1lBQ3RDeUYsY0FBWTFDLFNBQVUsT0FBVkEsV0FBcUI7Ozs7T0Fqb0JqQ3JEO09BMEpBRjtPQXlCQW9DO09BQ0FDO09BQ0FDO09BQ0FDO09Bd2JBd0Q7T0FrQkFDO09BQ0FDO09BcEpBcEI7T0FGQUQ7O1FBalFFakM7UUF1RkFPO1FBcUJBQztRQUNBQztRQUNBQztRQTRHQUU7UUFpQkFtQjtRQUNBQztRQTVHQW5CO1FBRkFGOzs7RSIsInNvdXJjZXNDb250ZW50IjpbImxldCBpb19idWZmZXJfc2l6ZSA9IDY1NTM2XG5sZXQgaW52YWxpZF9hcmcgZm10ID0gRm9ybWF0LmtzcHJpbnRmIChmdW4gcyAtPiBpbnZhbGlkX2FyZyBzKSBmbXRcbmxldCBpbnZhbGlkX2VuY29kZSAoKSA9IGludmFsaWRfYXJnIFwiRXhwZWN0ZWQgYEF3YWl0IGVuY29kZVwiXG5cbmxldCBpbnZhbGlkX2JvdW5kcyBvZmYgbGVuID1cbiAgaW52YWxpZF9hcmcgXCJJbnZhbGlkIGJvdW5kcyAob2ZmOiAlZCwgbGVuOiAlZClcIiBvZmYgbGVuXG5cbmxldCBtYWxmb3JtZWQgc291cmNlIG9mZiBwb3MgbGVuID1cbiAgYE1hbGZvcm1lZCAoQnl0ZXMuc3ViX3N0cmluZyBzb3VyY2UgKG9mZiArIHBvcykgbGVuKVxuXG5sZXQgdW5zYWZlX2J5dGUgc291cmNlIG9mZiBwb3MgPSBCeXRlcy51bnNhZmVfZ2V0IHNvdXJjZSAob2ZmICsgcG9zKVxubGV0IHVuc2FmZV9ibGl0ID0gQnl0ZXMudW5zYWZlX2JsaXRcbmxldCB1bnNhZmVfY2hyID0gQ2hhci51bnNhZmVfY2hyXG5sZXQgdW5zYWZlX3NldF9jaHIgc291cmNlIG9mZiBjaHIgPSBCeXRlcy51bnNhZmVfc2V0IHNvdXJjZSBvZmYgY2hyXG5cbigqIEJhc2UgY2hhcmFjdGVyIGRlY29kZXJzLiBUaGV5IGFzc3VtZSBlbm91Z2ggZGF0YS4gKilcblxubGV0IHJfcmVwciBzb3VyY2Ugb2ZmIGxlbiA9XG4gICgqIGFzc2VydCAoMCA8PSBqICYmIDAgPD0gbCAmJiBqICsgbCA8PSBTdHJpbmcubGVuZ3RoIHMpOyAqKVxuICAoKiBhc3NlcnQgKGwgPSAzKTsgKilcbiAgbGV0IGEgPSB1bnNhZmVfYnl0ZSBzb3VyY2Ugb2ZmIDEgaW5cbiAgbGV0IGIgPSB1bnNhZmVfYnl0ZSBzb3VyY2Ugb2ZmIDIgaW5cbiAgbGV0IG9mX2hleCA9IGZ1bmN0aW9uXG4gICAgfCAnMCcgLi4gJzknIGFzIGNociAtPiBDaGFyLmNvZGUgY2hyIC0gQ2hhci5jb2RlICcwJ1xuICAgIHwgJ0EnIC4uICdGJyBhcyBjaHIgLT4gQ2hhci5jb2RlIGNociAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgaW5cbiAgKCogKEdlbmVyYWwgOGJpdCByZXByZXNlbnRhdGlvbikgQW55IG9jdGV0LCBleGNlcHQgYSBDUiBvciBMRiB0aGF0IGlzIHBhcnQgb2ZcbiAgICAgYSBDUkxGIGxpbmUgYnJlYWsgb2YgdGhlIGNhbm9uaWNhbCAoc3RhbmRhcmQpIGZvcm0gb2YgdGhlIGRhdGEgYmVpbmdcbiAgICAgZW5jb2RlZCwgbWF5IGJlIHJlcHJlc2VudGVkIGJ5IGFuIFwiPVwiIGZvbGxvd2VkIGJ5IGEgdHdvIGRpZ2l0IGhleGFkZWNpbWFsXG4gICAgIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvY3RldCdzIHZhbHVlLiBUaGUgZGlnaXRzIG9mIHRoZSBoZXhhZGVjaW1hbFxuICAgICBhbHBoYWJldCwgZm9yIHRoaXMgcHVycG9zZSwgYXJlIFwiMDEyMzQ1Njc4OUFCQ0RFRlwiLiBVcHBlcmNhc2UgbGV0dGVycyBtdXN0XG4gICAgIGJlIHVzZWQ7IGxvd2VyY2FzZSBsZXR0ZXJzIGFyZSBub3QgYWxsb3dlZC4gVGh1cywgZm9yIGV4YW1wbGUsIHRoZSBkZWNpbWFsXG4gICAgIHZhbHVlIDEyIChVUy1BU0NJSSBmb3JtIGZlZWQpIGNhbiBiZSByZXByZXNlbnRlZCBieSBcIj0wQ1wiLCBhbmQgdGhlIGRlY2ltYWxcbiAgICAgdmFsdWUgNjEgKFVTLSBBU0NJSSBFUVVBTCBTSUdOKSBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgXCI9M0RcIi4gVGhpcyBydWxlXG4gICAgIG11c3QgYmUgZm9sbG93ZWQgZXhjZXB0IHdoZW4gdGhlIGZvbGxvd2luZyBydWxlcyBhbGxvdyBhbiBhbHRlcm5hdGl2ZVxuICAgICBlbmNvZGluZy5cblxuICAgICBTZWUgUkZDMjA0NSDCpyA2LjcuICopXG4gIG1hdGNoICh1bnNhZmVfYnl0ZSBzb3VyY2Ugb2ZmIDAsIGEsIGIpIHdpdGhcbiAgfCAnPScsICgnMCcgLi4gJzknIHwgJ0EnIC4uICdGJyksICgnMCcgLi4gJzknIHwgJ0EnIC4uICdGJykgLT5cbiAgICAgIGBSZXByICgob2ZfaGV4IGEgKiAxNikgKyBvZl9oZXggYilcbiAgfCAnPScsICdcXHInLCAnXFxuJyAtPiBgU29mdF9saW5lX2JyZWFrXG4gIHwgX2UsIF9hLCBfYiAtPiBtYWxmb3JtZWQgc291cmNlIG9mZiAwIGxlblxuXG5sZXQgcl9jaHIgY2hyID0gYENociBjaHJcbmxldCByX3dzcCB3c3AgPSBgV3NwIHdzcFxuXG5sZXQgcl9saW5lX2JyZWFrIHNvdXJjZSBvZmYgbGVuID1cbiAgKCogYXNzZXJ0ICgwIDw9IGogJiYgMCA8PSBsICYmIGogKyBsIDw9IFN0cmluZy5sZW5ndGggcyk7ICopXG4gICgqIGFzc2VydCAobCA9IDIpOyAqKVxuICBtYXRjaCBCeXRlcy5zdWJfc3RyaW5nIHNvdXJjZSBvZmYgbGVuIHdpdGhcbiAgfCBcIlxcclxcblwiIC0+IGBMaW5lX2JyZWFrXG4gIHwgX3N0ciAtPlxuICAgIG1hbGZvcm1lZCBzb3VyY2Ugb2ZmIDAgbGVuXG5cbnR5cGUgc3JjID0gW2BDaGFubmVsIG9mIGluX2NoYW5uZWwgfCBgU3RyaW5nIG9mIHN0cmluZyB8IGBNYW51YWxdXG5cbnR5cGUgZGVjb2RlID1cbiAgW2BBd2FpdCB8IGBFbmQgfCBgTWFsZm9ybWVkIG9mIHN0cmluZyB8IGBMaW5lIG9mIHN0cmluZyB8IGBEYXRhIG9mIHN0cmluZ11cblxudHlwZSBpbnB1dCA9XG4gIFsgYE1hbGZvcm1lZCBvZiBzdHJpbmdcbiAgfCBgU29mdF9saW5lX2JyZWFrXG4gIHwgYExpbmVfYnJlYWtcbiAgfCBgV3NwIG9mIGNoYXJcbiAgfCBgUmVwciBvZiBpbnRcbiAgfCBgQ2hyIG9mIGNoYXJcbiAgfCBgRW5kIF1cblxuKCogW3F1b3RlZC1wcmludGFibGVdIGhhcyB0d28ga2luZCB0byBicmVhayBhIGxpbmUgYnV0IG9ubHkgb25lIGlzIHJlbGV2YW50OlxuICAgW2BMaW5lX2JyZWFrXS4gW2BTb2Z0X2xpbmVfYnJlYWtdIG11c3QgYmUgdXNlZCBpZiBsb25nZXIgbGluZXMgYXJlIHRvIGJlXG4gICBlbmNvZGVkIHdpdGggdGhlIHF1b3RlZC1wcmludGFibGUgZW5jb2RpbmcuXG5cbiAgIFRoaXMgcHJvdmlkZXMgYSBtZWNoYW5pc20gd2l0aCB3aGljaCBsb25nIGxpbmVzIGFyZSBlbmNvZGVkIGluIHN1Y2ggYSB3YXkgYXNcbiAgIHRvIGJlIHJlc3RvcmVkIGJ5IHRoZSB1c2VyIGFnZW50LiBUaGUgNzYgY2hhcmFjdGVyIGxpbWl0IGRvZXMgbm90IGNvdW50IHRoZVxuICAgdHJhaWxpbmcgQ1JMRiwgYnV0IGNvdW50cyBhbGwgb3RoZXIgY2hhcmFjdGVycywgaW5jbHVkaW5nIGFueSBlcXVhbCBzaWducy5cblxuICAgW2BXc3BdIG11c3Qgbm90IGJlIHJlcHJlc2VudGVkIGF0IHRoZSBlbmQgb2YgdGhlIGVuY29kZWQgbGluZS4gV2Uga2VlcCBhXG4gICBkaWZmZXJlbnQgYnVmZmVyIHRvIHN0b3JlIHRoZW0gYW5kIGRlY2lkZSBpZiB0aGV5IGFyZSBmb2xsb3dlZCBieSBhXG4gICBwcmludGFibGUgY2hhcmFjdGVyIChsaWtlIFwiPVwiKSwgd2UgZGVjb2RlZCB0aGVtIGFzIHByaW50YWJsZSB3aGl0ZXNwYWNlcy5cblxuICAgW2BSZXByXSBpcyBhIGRlY29kZWQgOCBiaXRzIHZhbHVlLlxuXG4gICBbYENocl0gaXMgb25seSBhIHByaW50YWJsZSBjaGFyYWN0ZXIuICopXG5cbnR5cGUgZGVjb2RlciA9XG4gIHsgc3JjOiBzcmNcbiAgOyBtdXRhYmxlIGk6IEJ5dGVzLnRcbiAgOyBtdXRhYmxlIGlfb2ZmOiBpbnRcbiAgOyBtdXRhYmxlIGlfcG9zOiBpbnRcbiAgOyBtdXRhYmxlIGlfbGVuOiBpbnRcbiAgOyB0OiBCdWZmZXIudFxuICA7IHc6IEJ1ZmZlci50XG4gIDsgaDogQnl0ZXMudFxuICA7IG11dGFibGUgaF9sZW46IGludFxuICA7IG11dGFibGUgaF9uZWVkOiBpbnRcbiAgOyBtdXRhYmxlIHVuc2FmZTogYm9vbFxuICA7IG11dGFibGUgYnl0ZV9jb3VudDogaW50XG4gIDsgbXV0YWJsZSBsaW1pdF9jb3VudDogaW50XG4gIDsgbXV0YWJsZSBwcDogZGVjb2RlciAtPiBpbnB1dCAtPiBkZWNvZGVcbiAgOyBtdXRhYmxlIGs6IGRlY29kZXIgLT4gZGVjb2RlIH1cblxuKCogT24gZGVjb2RlcyB0aGF0IG92ZXJsYXAgdHdvIChvciBtb3JlKSBbZC5pXSBidWZmZXJzLCB3ZSB1c2UgW3RfZmlsbF0gdG8gY29weVxuICAgdGhlIGlucHV0IGRhdGEgdG8gW2QudF0gYW5kIGRlY29kZSBmcm9tIHRoZXJlLiBJZiB0aGUgW2QuaV0gYnVmZmVycyBhcmUgbm90XG4gICB0b28gc21hbGwgdGhpcyBpcyBmYXN0ZXIgdGhhbiBjb250aW51YXRpb24gYmFzZWQgYnl0ZSBwZXIgYnl0ZSB3cml0ZXMuXG5cbiAgIEVuZCBvZiBpbnB1dCBpcyBzZ25hbGVkIGJ5IFtkLmlfcG9zID0gMF0gYW5kIFtkLmlfbGVuID0gbWluX2ludF0gd2hpY2hcbiAgIGltcGxpZXMgdGhhdCBbaV9yZW0gZCA8IDBdIGlzIFt0cnVlXS4gKilcblxubGV0IGlfcmVtIGRlY29kZXIgPSBkZWNvZGVyLmlfbGVuIC0gZGVjb2Rlci5pX3BvcyArIDFcblxubGV0IGVuZF9vZl9pbnB1dCBkZWNvZGVyID1cbiAgZGVjb2Rlci5pIDwtIEJ5dGVzLmVtcHR5IDtcbiAgZGVjb2Rlci5pX29mZiA8LSAwIDtcbiAgZGVjb2Rlci5pX3BvcyA8LSAwIDtcbiAgZGVjb2Rlci5pX2xlbiA8LSBtaW5faW50XG5cbmxldCBzcmMgZGVjb2RlciBzb3VyY2Ugb2ZmIGxlbiA9XG4gIGlmIG9mZiA8IDAgfHwgbGVuIDwgMCB8fCBvZmYgKyBsZW4gPiBCeXRlcy5sZW5ndGggc291cmNlIHRoZW5cbiAgICBpbnZhbGlkX2JvdW5kcyBvZmYgbGVuXG4gIGVsc2UgaWYgbGVuID0gMCB0aGVuIGVuZF9vZl9pbnB1dCBkZWNvZGVyXG4gIGVsc2UgKFxuICAgIGRlY29kZXIuaSA8LSBzb3VyY2UgO1xuICAgIGRlY29kZXIuaV9vZmYgPC0gb2ZmIDtcbiAgICBkZWNvZGVyLmlfcG9zIDwtIDAgO1xuICAgIGRlY29kZXIuaV9sZW4gPC0gbGVuIC0gMSApXG5cbmxldCByZWZpbGwgayBkZWNvZGVyID1cbiAgbWF0Y2ggZGVjb2Rlci5zcmMgd2l0aFxuICB8IGBNYW51YWwgLT5cbiAgICAgIGRlY29kZXIuayA8LSBrIDtcbiAgICAgIGBBd2FpdFxuICB8IGBTdHJpbmcgXyAtPiBlbmRfb2ZfaW5wdXQgZGVjb2RlciA7IGsgZGVjb2RlclxuICB8IGBDaGFubmVsIGljIC0+XG4gICAgICBsZXQgbGVuID0gaW5wdXQgaWMgZGVjb2Rlci5pIDAgKEJ5dGVzLmxlbmd0aCBkZWNvZGVyLmkpIGluXG4gICAgICBzcmMgZGVjb2RlciBkZWNvZGVyLmkgMCBsZW4gO1xuICAgICAgayBkZWNvZGVyXG5cbmxldCBkYW5nZXJvdXMgZGVjb2RlciB2ID0gZGVjb2Rlci51bnNhZmUgPC0gdlxubGV0IHJlc2V0IGRlY29kZXIgPSBkZWNvZGVyLmxpbWl0X2NvdW50IDwtIDBcblxubGV0IHJldCBrIHYgYnl0ZV9jb3VudCBkZWNvZGVyID1cbiAgZGVjb2Rlci5rIDwtIGsgO1xuICBkZWNvZGVyLmJ5dGVfY291bnQgPC0gZGVjb2Rlci5ieXRlX2NvdW50ICsgYnl0ZV9jb3VudCA7XG4gIGRlY29kZXIubGltaXRfY291bnQgPC0gZGVjb2Rlci5saW1pdF9jb3VudCArIGJ5dGVfY291bnQgO1xuICBpZiBkZWNvZGVyLmxpbWl0X2NvdW50ID4gNzggdGhlbiBkYW5nZXJvdXMgZGVjb2RlciB0cnVlIDtcbiAgZGVjb2Rlci5wcCBkZWNvZGVyIHZcblxubGV0IG1hbGZvcm1lZF9saW5lIHNvdXJjZSBvZmYgbGVuIGRlY29kZXIgPVxuICBCdWZmZXIuYWRkX2J1ZmZlciBkZWNvZGVyLnQgZGVjb2Rlci53IDtcbiAgQnVmZmVyLmFkZF9zdWJieXRlcyBkZWNvZGVyLnQgc291cmNlIG9mZiBsZW4gO1xuICBsZXQgbGluZSA9IEJ1ZmZlci5jb250ZW50cyBkZWNvZGVyLnQgaW5cbiAgQnVmZmVyLmNsZWFyIGRlY29kZXIudyA7IEJ1ZmZlci5jbGVhciBkZWNvZGVyLnQgOyBgTWFsZm9ybWVkIGxpbmVcblxubGV0IHRfbmVlZCBkZWNvZGVyIG5lZWQgPVxuICBkZWNvZGVyLmhfbGVuIDwtIDAgO1xuICBkZWNvZGVyLmhfbmVlZCA8LSBuZWVkXG5cbmxldCByZWMgdF9maWxsIGsgZGVjb2RlciA9XG4gIGxldCBibGl0IGRlY29kZXIgbGVuID1cbiAgICB1bnNhZmVfYmxpdCBkZWNvZGVyLmlcbiAgICAgIChkZWNvZGVyLmlfb2ZmICsgZGVjb2Rlci5pX3BvcylcbiAgICAgIGRlY29kZXIuaCBkZWNvZGVyLmhfbGVuIGxlbiA7XG4gICAgZGVjb2Rlci5pX3BvcyA8LSBkZWNvZGVyLmlfcG9zICsgbGVuIDtcbiAgICBkZWNvZGVyLmhfbGVuIDwtIGRlY29kZXIuaF9sZW4gKyBsZW5cbiAgaW5cbiAgbGV0IHJlbSA9IGlfcmVtIGRlY29kZXIgaW5cbiAgaWYgcmVtIDwgMCAoKiBlbmQgb2YgaW5wdXQgKikgdGhlbiBrIGRlY29kZXJcbiAgZWxzZVxuICAgIGxldCBuZWVkID0gZGVjb2Rlci5oX25lZWQgLSBkZWNvZGVyLmhfbGVuIGluXG4gICAgaWYgcmVtIDwgbmVlZCB0aGVuIChcbiAgICAgIGJsaXQgZGVjb2RlciByZW0gO1xuICAgICAgcmVmaWxsICh0X2ZpbGwgaykgZGVjb2RlciApXG4gICAgZWxzZSAoIGJsaXQgZGVjb2RlciBuZWVkIDsgayBkZWNvZGVyIClcblxubGV0IHJlYyB0X2RlY29kZV9xdW90ZWRfcHJpbnRhYmxlIGRlY29kZXIgPVxuICBpZiBkZWNvZGVyLmhfbGVuIDwgZGVjb2Rlci5oX25lZWQgdGhlblxuICAgIHJldCBkZWNvZGVfcXVvdGVkX3ByaW50YWJsZVxuICAgICAgKG1hbGZvcm1lZF9saW5lIGRlY29kZXIuaCAwIGRlY29kZXIuaF9sZW4gZGVjb2RlcilcbiAgICAgIGRlY29kZXIuaF9sZW4gZGVjb2RlclxuICBlbHNlXG4gICAgcmV0IGRlY29kZV9xdW90ZWRfcHJpbnRhYmxlXG4gICAgICAocl9yZXByIGRlY29kZXIuaCAwIGRlY29kZXIuaF9sZW4pXG4gICAgICBkZWNvZGVyLmhfbGVuIGRlY29kZXJcblxuYW5kIHRfZGVjb2RlX2xpbmVfYnJlYWsgZGVjb2RlciA9XG4gIGlmIGRlY29kZXIuaF9sZW4gPCBkZWNvZGVyLmhfbmVlZCB0aGVuXG4gICAgcmV0IGRlY29kZV9xdW90ZWRfcHJpbnRhYmxlXG4gICAgICAobWFsZm9ybWVkX2xpbmUgZGVjb2Rlci5oIDAgZGVjb2Rlci5oX2xlbiBkZWNvZGVyKVxuICAgICAgZGVjb2Rlci5oX2xlbiBkZWNvZGVyXG4gIGVsc2VcbiAgICByZXQgZGVjb2RlX3F1b3RlZF9wcmludGFibGVcbiAgICAgIChyX2xpbmVfYnJlYWsgZGVjb2Rlci5oIDAgZGVjb2Rlci5oX2xlbilcbiAgICAgIGRlY29kZXIuaF9sZW4gZGVjb2RlclxuXG5hbmQgZGVjb2RlX3F1b3RlZF9wcmludGFibGUgZGVjb2RlciA9XG4gIGxldCByZW0gPSBpX3JlbSBkZWNvZGVyIGluXG4gIGlmIHJlbSA8PSAwIHRoZW5cbiAgICBpZiByZW0gPCAwIHRoZW4gcmV0IChmdW4gX2RlY29kZXIgLT4gYEVuZCkgYEVuZCAwIGRlY29kZXJcbiAgICBlbHNlIHJlZmlsbCBkZWNvZGVfcXVvdGVkX3ByaW50YWJsZSBkZWNvZGVyXG4gIGVsc2VcbiAgICBtYXRjaCB1bnNhZmVfYnl0ZSBkZWNvZGVyLmkgZGVjb2Rlci5pX29mZiBkZWNvZGVyLmlfcG9zIHdpdGhcbiAgICB8ICgnXFwwMDknIHwgJ1xcMDMyJykgYXMgd3NwIC0+XG4gICAgICAgICgqIEhUIHwgU1BBQ0UgKilcbiAgICAgICAgZGVjb2Rlci5pX3BvcyA8LSBkZWNvZGVyLmlfcG9zICsgMSA7XG4gICAgICAgIHJldCBkZWNvZGVfcXVvdGVkX3ByaW50YWJsZSAocl93c3Agd3NwKSAxIGRlY29kZXJcbiAgICB8ICdcXDAxMycgLT5cbiAgICAgICAgKCogQ1IgKilcbiAgICAgICAgKCogVE9ETzogb3B0aW1pemUgaXQhICopXG4gICAgICAgIHRfbmVlZCBkZWNvZGVyIDIgO1xuICAgICAgICB0X2ZpbGwgdF9kZWNvZGVfbGluZV9icmVhayBkZWNvZGVyXG4gICAgfCAnPScgLT5cbiAgICAgICAgKCogVE9ETzogb3B0aW1pemUgaXQhICopXG4gICAgICAgIHRfbmVlZCBkZWNvZGVyIDMgO1xuICAgICAgICB0X2ZpbGwgdF9kZWNvZGVfcXVvdGVkX3ByaW50YWJsZSBkZWNvZGVyXG4gICAgfCAoJ1xcMDMzJyAuLiAnXFwwNjAnIHwgJ1xcMDYyJyAuLiAnXFwxMjYnKSBhcyBjaHIgLT5cbiAgICAgICAgQnVmZmVyLmFkZF9idWZmZXIgZGVjb2Rlci50IGRlY29kZXIudyA7XG4gICAgICAgIEJ1ZmZlci5jbGVhciBkZWNvZGVyLncgO1xuICAgICAgICBkZWNvZGVyLmlfcG9zIDwtIGRlY29kZXIuaV9wb3MgKyAxIDtcbiAgICAgICAgcmV0IGRlY29kZV9xdW90ZWRfcHJpbnRhYmxlIChyX2NociBjaHIpIDEgZGVjb2RlclxuICAgIHwgX2NociAtPlxuICAgICAgICAoKiBYWFgoZGlub3NhdXJlKTogSWYgY2hhcmFjdGVycyBvdGhlciB0aGFuIEhULCBDUiwgTEYgb3Igb2N0ZXRzIHdpdGhcbiAgICAgICAgICAgZGVjaW1hbCB2YWx1ZXMgZ3JlYXRlciB0aGFuIDEyNiBmb3VuZCBpbiBpbmNvbWluZyBxdW90ZWQtcHJpbnRhYmxlXG4gICAgICAgICAgIGRhdGEgYnkgYSBkZWNvZGVyLCBhIHJvYnVzdCBpbXBsZW1lbnRhdGlvbiBtaWdodCBleGNsdWRlIHRoZW0gZnJvbVxuICAgICAgICAgICB0aGUgZGVjb2RlZCBkYXRhIGFuZCB3YXJuIHRoZSB1c2VyIHRoYXQgaWxsZWdhbCBjaGFyYWN0ZXJzIHdlcmVcbiAgICAgICAgICAgZGlzY292ZXJlZC4gU2VlIFJGQzIwNDUgwqcgNi43LiAqKVxuICAgICAgICBsZXQgaiA9IGRlY29kZXIuaV9wb3MgaW5cbiAgICAgICAgZGVjb2Rlci5pX3BvcyA8LSBkZWNvZGVyLmlfcG9zICsgMSA7XG4gICAgICAgIHJldCBkZWNvZGVfcXVvdGVkX3ByaW50YWJsZVxuICAgICAgICAgIChtYWxmb3JtZWQgZGVjb2Rlci5pIGRlY29kZXIuaV9vZmYgaiAxKVxuICAgICAgICAgIDEgZGVjb2RlclxuXG5sZXQgZl9maWxsX2J5dGUgYnl0ZSBkZWNvZGVyID1cbiAgQnVmZmVyLmFkZF9jaGFyIGRlY29kZXIudCAodW5zYWZlX2NociBieXRlKSA7XG4gIGRlY29kZXIuayBkZWNvZGVyXG5cbmxldCBmX2ZpbGxfY2hyIGNociBkZWNvZGVyID1cbiAgQnVmZmVyLmFkZF9jaGFyIGRlY29kZXIudCBjaHIgO1xuICBkZWNvZGVyLmsgZGVjb2RlclxuXG5sZXQgcHBfcXVvdGVkX3ByaW50YWJsZSBkZWNvZGVyID0gZnVuY3Rpb25cbiAgfCBgU29mdF9saW5lX2JyZWFrIC0+XG4gICAgICBCdWZmZXIuYWRkX2J1ZmZlciBkZWNvZGVyLnQgZGVjb2Rlci53IDtcbiAgICAgIGxldCBkYXRhID0gQnVmZmVyLmNvbnRlbnRzIGRlY29kZXIudCBpblxuICAgICAgQnVmZmVyLmNsZWFyIGRlY29kZXIudyA7XG4gICAgICBCdWZmZXIuY2xlYXIgZGVjb2Rlci50IDtcbiAgICAgIHJlc2V0IGRlY29kZXIgO1xuICAgICAgYERhdGEgZGF0YVxuICB8IGBMaW5lX2JyZWFrIC0+XG4gICAgICBsZXQgbGluZSA9IEJ1ZmZlci5jb250ZW50cyBkZWNvZGVyLnQgaW5cbiAgICAgIEJ1ZmZlci5jbGVhciBkZWNvZGVyLncgO1xuICAgICAgQnVmZmVyLmNsZWFyIGRlY29kZXIudCA7XG4gICAgICByZXNldCBkZWNvZGVyIDtcbiAgICAgIGBMaW5lIGxpbmVcbiAgfCBgRW5kIC0+XG4gICAgICBCdWZmZXIuYWRkX2J1ZmZlciBkZWNvZGVyLnQgZGVjb2Rlci53IDtcbiAgICAgIGxldCBkYXRhID0gQnVmZmVyLmNvbnRlbnRzIGRlY29kZXIudCBpblxuICAgICAgQnVmZmVyLmNsZWFyIGRlY29kZXIudyA7IEJ1ZmZlci5jbGVhciBkZWNvZGVyLnQgOyBgRGF0YSBkYXRhXG4gIHwgYFdzcCB3c3AgLT5cbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBkZWNvZGVyLncgd3NwIDtcbiAgICAgIGRlY29kZXIuayBkZWNvZGVyXG4gIHwgYFJlcHIgYnl0ZSAtPlxuICAgICAgQnVmZmVyLmFkZF9idWZmZXIgZGVjb2Rlci50IGRlY29kZXIudyA7XG4gICAgICBCdWZmZXIuY2xlYXIgZGVjb2Rlci53IDtcbiAgICAgIGZfZmlsbF9ieXRlIGJ5dGUgZGVjb2RlclxuICB8IGBDaHIgY2hyIC0+XG4gICAgICBCdWZmZXIuYWRkX2J1ZmZlciBkZWNvZGVyLnQgZGVjb2Rlci53IDtcbiAgICAgIEJ1ZmZlci5jbGVhciBkZWNvZGVyLncgO1xuICAgICAgZl9maWxsX2NociBjaHIgZGVjb2RlclxuICB8IGBNYWxmb3JtZWQgXyBhcyB2IC0+IHZcblxubGV0IGRlY29kZXIgc3JjID1cbiAgbGV0IHBwID0gcHBfcXVvdGVkX3ByaW50YWJsZSBpblxuICBsZXQgayA9IGRlY29kZV9xdW90ZWRfcHJpbnRhYmxlIGluXG4gIGxldCBpLCBpX29mZiwgaV9wb3MsIGlfbGVuID1cbiAgICBtYXRjaCBzcmMgd2l0aFxuICAgIHwgYE1hbnVhbCAtPiAoQnl0ZXMuZW1wdHksIDAsIDEsIDApXG4gICAgfCBgQ2hhbm5lbCBfIC0+IChCeXRlcy5jcmVhdGUgaW9fYnVmZmVyX3NpemUsIDAsIDEsIDApXG4gICAgfCBgU3RyaW5nIHMgLT4gKEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgcywgMCwgMCwgU3RyaW5nLmxlbmd0aCBzIC0gMSlcbiAgaW5cbiAgeyBzcmNcbiAgOyBpX29mZlxuICA7IGlfcG9zXG4gIDsgaV9sZW5cbiAgOyBpXG4gIDsgdD0gQnVmZmVyLmNyZWF0ZSA4MFxuICA7IHc9IEJ1ZmZlci5jcmVhdGUgODBcbiAgOyBoPSBCeXRlcy5jcmVhdGUgM1xuICA7IGhfbmVlZD0gMFxuICA7IGhfbGVuPSAwXG4gIDsgdW5zYWZlPSBmYWxzZVxuICA7IGxpbWl0X2NvdW50PSAwXG4gIDsgYnl0ZV9jb3VudD0gMFxuICA7IHBwXG4gIDsgayB9XG5cbmxldCBkZWNvZGUgZGVjb2RlciA9IGRlY29kZXIuayBkZWNvZGVyXG5sZXQgZGVjb2Rlcl9ieXRlX2NvdW50IGRlY29kZXIgPSBkZWNvZGVyLmJ5dGVfY291bnRcbmxldCBkZWNvZGVyX3NyYyBkZWNvZGVyID0gZGVjb2Rlci5zcmNcbmxldCBkZWNvZGVyX2Rhbmdlcm91cyBkZWNvZGVyID0gZGVjb2Rlci51bnNhZmVcblxubW9kdWxlIElubGluZSA9IHN0cnVjdFxuICAoKiBYWFgoZGlub3NhdXJlKTogSSB3YW50IHN0cnVjdHVyYWwgdHlwaW5nIGFuZCByb3cgcG9seW1vcGhpc20gb24gcmVjb3JkLFxuICAgICBwbGVhc2UuICopXG5cbiAgdHlwZSB1bnNhZmVfY2hhciA9IGNoYXJcbiAgdHlwZSBkZWNvZGUgPSBbYEF3YWl0IHwgYEVuZCB8IGBNYWxmb3JtZWQgb2Ygc3RyaW5nIHwgYENoYXIgb2YgdW5zYWZlX2NoYXJdXG5cbiAgdHlwZSBpbnB1dCA9XG4gICAgW2BNYWxmb3JtZWQgb2Ygc3RyaW5nIHwgYFdzcCB8IGBDaHIgb2YgY2hhciB8IGBSZXByIG9mIGludCB8IGBFbmRdXG5cbiAgbGV0IHJfcmVwciBzb3VyY2Ugb2ZmIGxlbiA9XG4gICAgKCogYXNzZXJ0ICgwIDw9IGogJiYgMCA8PSBsICYmIGogKyBsIDw9IFN0cmluZy5sZW5ndGggcyk7ICopXG4gICAgKCogYXNzZXJ0IChsID0gMyk7ICopXG4gICAgbGV0IGEgPSB1bnNhZmVfYnl0ZSBzb3VyY2Ugb2ZmIDEgaW5cbiAgICBsZXQgYiA9IHVuc2FmZV9ieXRlIHNvdXJjZSBvZmYgMiBpblxuICAgIGxldCBvZl9oZXggPSBmdW5jdGlvblxuICAgICAgfCAnMCcgLi4gJzknIGFzIGNociAtPiBDaGFyLmNvZGUgY2hyIC0gQ2hhci5jb2RlICcwJ1xuICAgICAgfCAnQScgLi4gJ0YnIGFzIGNociAtPiBDaGFyLmNvZGUgY2hyIC0gQ2hhci5jb2RlICdBJyArIDEwXG4gICAgICB8ICdhJyAuLiAnZicgYXMgY2hyIC0+IENoYXIuY29kZSBjaHIgLSBDaGFyLmNvZGUgJ2EnICsgMTBcbiAgICAgICgqIFJGQyAyMDQ3IHNheXM6IHVwcGVyY2FzZSBTSE9VTEQgYmUgdXNlZCBmb3IgaGV4YWRlY2ltYWwgZGlnaXRzLiAqKVxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgIGluXG4gICAgbWF0Y2ggKHVuc2FmZV9ieXRlIHNvdXJjZSBvZmYgMCwgYSwgYikgd2l0aFxuICAgIHwgJz0nLCAoJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnKSwgKCcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJykgLT5cbiAgICAgICAgYFJlcHIgKChvZl9oZXggYSAqIDE2KSArIG9mX2hleCBiKVxuICAgIHwgX2UsIF9hLCBfYiAtPiBtYWxmb3JtZWQgc291cmNlIG9mZiAwIGxlblxuXG4gIGxldCByX3dzcCA9IGBXc3BcblxuICB0eXBlIGRlY29kZXIgPVxuICAgIHsgc3JjOiBzcmNcbiAgICA7IG11dGFibGUgaTogQnl0ZXMudFxuICAgIDsgbXV0YWJsZSBpX29mZjogaW50XG4gICAgOyBtdXRhYmxlIGlfcG9zOiBpbnRcbiAgICA7IG11dGFibGUgaV9sZW46IGludFxuICAgIDsgaDogQnl0ZXMudFxuICAgIDsgbXV0YWJsZSBoX2xlbjogaW50XG4gICAgOyBtdXRhYmxlIGhfbmVlZDogaW50XG4gICAgOyBtdXRhYmxlIGJ5dGVfY291bnQ6IGludFxuICAgIDsgbXV0YWJsZSBwcDogZGVjb2RlciAtPiBpbnB1dCAtPiBkZWNvZGVcbiAgICA7IG11dGFibGUgazogZGVjb2RlciAtPiBkZWNvZGUgfVxuXG4gIGxldCBpX3JlbSBkZWNvZGVyID0gZGVjb2Rlci5pX2xlbiAtIGRlY29kZXIuaV9wb3MgKyAxXG5cbiAgbGV0IGVuZF9vZl9pbnB1dCBkZWNvZGVyID1cbiAgICBkZWNvZGVyLmkgPC0gQnl0ZXMuZW1wdHkgO1xuICAgIGRlY29kZXIuaV9vZmYgPC0gMCA7XG4gICAgZGVjb2Rlci5pX3BvcyA8LSAwIDtcbiAgICBkZWNvZGVyLmlfbGVuIDwtIG1pbl9pbnRcblxuICBsZXQgc3JjIGRlY29kZXIgc291cmNlIG9mZiBsZW4gPVxuICAgIGlmIG9mZiA8IDAgfHwgbGVuIDwgMCB8fCBvZmYgKyBsZW4gPiBCeXRlcy5sZW5ndGggc291cmNlIHRoZW5cbiAgICAgIGludmFsaWRfYm91bmRzIG9mZiBsZW5cbiAgICBlbHNlIGlmIGxlbiA9IDAgdGhlbiBlbmRfb2ZfaW5wdXQgZGVjb2RlclxuICAgIGVsc2UgKFxuICAgICAgZGVjb2Rlci5pIDwtIHNvdXJjZSA7XG4gICAgICBkZWNvZGVyLmlfb2ZmIDwtIG9mZiA7XG4gICAgICBkZWNvZGVyLmlfcG9zIDwtIDAgO1xuICAgICAgZGVjb2Rlci5pX2xlbiA8LSBsZW4gLSAxIClcblxuICBsZXQgcmVmaWxsIGsgZGVjb2RlciA9XG4gICAgbWF0Y2ggZGVjb2Rlci5zcmMgd2l0aFxuICAgIHwgYE1hbnVhbCAtPlxuICAgICAgICBkZWNvZGVyLmsgPC0gayA7XG4gICAgICAgIGBBd2FpdFxuICAgIHwgYFN0cmluZyBfIC0+IGVuZF9vZl9pbnB1dCBkZWNvZGVyIDsgayBkZWNvZGVyXG4gICAgfCBgQ2hhbm5lbCBpYyAtPlxuICAgICAgICBsZXQgbGVuID0gaW5wdXQgaWMgZGVjb2Rlci5pIDAgKEJ5dGVzLmxlbmd0aCBkZWNvZGVyLmkpIGluXG4gICAgICAgIHNyYyBkZWNvZGVyIGRlY29kZXIuaSAwIGxlbiA7XG4gICAgICAgIGsgZGVjb2RlclxuXG4gIGxldCByZXQgayB2IGJ5dGVfY291bnQgZGVjb2RlciA9XG4gICAgZGVjb2Rlci5rIDwtIGsgO1xuICAgIGRlY29kZXIuYnl0ZV9jb3VudCA8LSBkZWNvZGVyLmJ5dGVfY291bnQgKyBieXRlX2NvdW50IDtcbiAgICBkZWNvZGVyLnBwIGRlY29kZXIgdlxuXG4gIGxldCB0X25lZWQgZGVjb2RlciBuZWVkID1cbiAgICBkZWNvZGVyLmhfbGVuIDwtIDAgO1xuICAgIGRlY29kZXIuaF9uZWVkIDwtIG5lZWRcblxuICBsZXQgcmVjIHRfZmlsbCBrIGRlY29kZXIgPVxuICAgIGxldCBibGl0IGRlY29kZXIgbGVuID1cbiAgICAgIHVuc2FmZV9ibGl0IGRlY29kZXIuaVxuICAgICAgICAoZGVjb2Rlci5pX29mZiArIGRlY29kZXIuaV9wb3MpXG4gICAgICAgIGRlY29kZXIuaCBkZWNvZGVyLmhfbGVuIGxlbiA7XG4gICAgICBkZWNvZGVyLmlfcG9zIDwtIGRlY29kZXIuaV9wb3MgKyBsZW4gO1xuICAgICAgZGVjb2Rlci5oX2xlbiA8LSBkZWNvZGVyLmhfbGVuICsgbGVuXG4gICAgaW5cbiAgICBsZXQgcmVtID0gaV9yZW0gZGVjb2RlciBpblxuICAgIGlmIHJlbSA8IDAgKCogZW5kIG9mIGlucHV0ICopIHRoZW4gayBkZWNvZGVyXG4gICAgZWxzZVxuICAgICAgbGV0IG5lZWQgPSBkZWNvZGVyLmhfbmVlZCAtIGRlY29kZXIuaF9sZW4gaW5cbiAgICAgIGlmIHJlbSA8IG5lZWQgdGhlbiAoXG4gICAgICAgIGJsaXQgZGVjb2RlciByZW0gO1xuICAgICAgICByZWZpbGwgKHRfZmlsbCBrKSBkZWNvZGVyIClcbiAgICAgIGVsc2UgKCBibGl0IGRlY29kZXIgbmVlZCA7IGsgZGVjb2RlciApXG5cbiAgbGV0IHJlYyB0X2RlY29kZV9pbmxpbmVfcXVvdGVkX3ByaW50YWJsZSBkZWNvZGVyID1cbiAgICBpZiBkZWNvZGVyLmhfbGVuIDwgZGVjb2Rlci5oX25lZWQgdGhlblxuICAgICAgcmV0IGRlY29kZV9pbmxpbmVfcXVvdGVkX3ByaW50YWJsZVxuICAgICAgICAobWFsZm9ybWVkIGRlY29kZXIuaCAwIDAgZGVjb2Rlci5oX2xlbilcbiAgICAgICAgZGVjb2Rlci5oX2xlbiBkZWNvZGVyICgqIFhYWChkaW5vc2F1cmUpOiBtYWxmb3JtZWQgbGluZT8gKilcbiAgICBlbHNlXG4gICAgICByZXQgZGVjb2RlX2lubGluZV9xdW90ZWRfcHJpbnRhYmxlXG4gICAgICAgIChyX3JlcHIgZGVjb2Rlci5oIDAgZGVjb2Rlci5oX2xlbilcbiAgICAgICAgZGVjb2Rlci5oX2xlbiBkZWNvZGVyXG5cbiAgYW5kIGRlY29kZV9pbmxpbmVfcXVvdGVkX3ByaW50YWJsZSBkZWNvZGVyID1cbiAgICBsZXQgcmVtID0gaV9yZW0gZGVjb2RlciBpblxuICAgIGlmIHJlbSA8PSAwIHRoZW5cbiAgICAgIGlmIHJlbSA8IDAgdGhlbiByZXQgKGZ1biBfZGVjb2RlciAtPiBgRW5kKSBgRW5kIDAgZGVjb2RlclxuICAgICAgZWxzZSByZWZpbGwgZGVjb2RlX2lubGluZV9xdW90ZWRfcHJpbnRhYmxlIGRlY29kZXJcbiAgICBlbHNlXG4gICAgICBtYXRjaCB1bnNhZmVfYnl0ZSBkZWNvZGVyLmkgZGVjb2Rlci5pX29mZiBkZWNvZGVyLmlfcG9zIHdpdGhcbiAgICAgIHwgJ18nIC0+XG4gICAgICAgICAgZGVjb2Rlci5pX3BvcyA8LSBkZWNvZGVyLmlfcG9zICsgMSA7XG4gICAgICAgICAgcmV0IGRlY29kZV9pbmxpbmVfcXVvdGVkX3ByaW50YWJsZSByX3dzcCAxIGRlY29kZXJcbiAgICAgIHwgJz0nIC0+XG4gICAgICAgICAgdF9uZWVkIGRlY29kZXIgMyA7XG4gICAgICAgICAgdF9maWxsIHRfZGVjb2RlX2lubGluZV9xdW90ZWRfcHJpbnRhYmxlIGRlY29kZXJcbiAgICAgIHwgKCdcXDAzMycgLi4gJ1xcMDYwJyB8ICdcXDA2MicgLi4gJ1xcMTI2JykgYXMgY2hyIC0+XG4gICAgICAgICAgZGVjb2Rlci5pX3BvcyA8LSBkZWNvZGVyLmlfcG9zICsgMSA7XG4gICAgICAgICAgcmV0IGRlY29kZV9pbmxpbmVfcXVvdGVkX3ByaW50YWJsZSAocl9jaHIgY2hyKSAxIGRlY29kZXJcbiAgICAgIHwgXyAtPlxuICAgICAgICAgIGxldCBqID0gZGVjb2Rlci5pX3BvcyBpblxuICAgICAgICAgIGRlY29kZXIuaV9wb3MgPC0gZGVjb2Rlci5pX3BvcyArIDEgO1xuICAgICAgICAgIHJldCBkZWNvZGVfaW5saW5lX3F1b3RlZF9wcmludGFibGVcbiAgICAgICAgICAgIChtYWxmb3JtZWQgZGVjb2Rlci5pIGRlY29kZXIuaV9vZmYgaiAxKVxuICAgICAgICAgICAgMSBkZWNvZGVyXG5cbiAgbGV0IHBwX2lubGluZV9xdW90ZWRfcHJpbnRhYmxlIF9kZWNvZGVyID0gZnVuY3Rpb25cbiAgICB8IGBXc3AgLT4gYENoYXIgJyAnXG4gICAgfCBgQ2hyIGNociAtPiBgQ2hhciBjaHJcbiAgICB8IGBSZXByIGJ5dGUgLT4gYENoYXIgKHVuc2FmZV9jaHIgYnl0ZSlcbiAgICB8IGBFbmQgLT4gYEVuZFxuICAgIHwgYE1hbGZvcm1lZCBfIGFzIHYgLT4gdlxuXG4gIGxldCBkZWNvZGVyIHNyYyA9XG4gICAgbGV0IHBwID0gcHBfaW5saW5lX3F1b3RlZF9wcmludGFibGUgaW5cbiAgICBsZXQgayA9IGRlY29kZV9pbmxpbmVfcXVvdGVkX3ByaW50YWJsZSBpblxuICAgIGxldCBpLCBpX29mZiwgaV9wb3MsIGlfbGVuID1cbiAgICAgIG1hdGNoIHNyYyB3aXRoXG4gICAgICB8IGBNYW51YWwgLT4gKEJ5dGVzLmVtcHR5LCAwLCAxLCAwKVxuICAgICAgfCBgQ2hhbm5lbCBfIC0+IChCeXRlcy5jcmVhdGUgaW9fYnVmZmVyX3NpemUsIDAsIDEsIDApXG4gICAgICB8IGBTdHJpbmcgcyAtPiAoQnl0ZXMudW5zYWZlX29mX3N0cmluZyBzLCAwLCAwLCBTdHJpbmcubGVuZ3RoIHMgLSAxKVxuICAgIGluXG4gICAgeyBzcmNcbiAgICA7IGlfb2ZmXG4gICAgOyBpX3Bvc1xuICAgIDsgaV9sZW5cbiAgICA7IGlcbiAgICA7IGg9IEJ5dGVzLmNyZWF0ZSAzXG4gICAgOyBoX25lZWQ9IDBcbiAgICA7IGhfbGVuPSAwXG4gICAgOyBieXRlX2NvdW50PSAwXG4gICAgOyBwcFxuICAgIDsgayB9XG5cbiAgbGV0IGRlY29kZSBkZWNvZGVyID0gZGVjb2Rlci5rIGRlY29kZXJcbiAgbGV0IGRlY29kZXJfYnl0ZV9jb3VudCBkZWNvZGVyID0gZGVjb2Rlci5ieXRlX2NvdW50XG4gIGxldCBkZWNvZGVyX3NyYyBkZWNvZGVyID0gZGVjb2Rlci5zcmNcblxuICB0eXBlIGRzdCA9IFtgQ2hhbm5lbCBvZiBvdXRfY2hhbm5lbCB8IGBCdWZmZXIgb2YgQnVmZmVyLnQgfCBgTWFudWFsXVxuICB0eXBlIGVuY29kZSA9IFtgQXdhaXQgfCBgRW5kIHwgYENoYXIgb2YgdW5zYWZlX2NoYXJdXG5cbiAgdHlwZSBlbmNvZGVyID1cbiAgICB7IGRzdDogZHN0XG4gICAgOyBtdXRhYmxlIG86IEJ5dGVzLnRcbiAgICA7IG11dGFibGUgb19vZmY6IGludFxuICAgIDsgbXV0YWJsZSBvX3BvczogaW50XG4gICAgOyBtdXRhYmxlIG9fbGVuOiBpbnRcbiAgICA7IHQ6IEJ5dGVzLnRcbiAgICA7IG11dGFibGUgdF9wb3M6IGludFxuICAgIDsgbXV0YWJsZSB0X2xlbjogaW50XG4gICAgOyBtdXRhYmxlIGs6IGVuY29kZXIgLT4gZW5jb2RlIC0+IFtgT2sgfCBgUGFydGlhbF0gfVxuXG4gIGxldCBvX3JlbSBlbmNvZGVyID0gZW5jb2Rlci5vX2xlbiAtIGVuY29kZXIub19wb3MgKyAxXG5cbiAgbGV0IGRzdCBlbmNvZGVyIHNvdXJjZSBvZmYgbGVuID1cbiAgICBpZiBvZmYgPCAwIHx8IGxlbiA8IDAgfHwgb2ZmICsgbGVuID4gQnl0ZXMubGVuZ3RoIHNvdXJjZVxuICAgIHRoZW4gaW52YWxpZF9ib3VuZHMgb2ZmIGxlbiA7XG4gICAgZW5jb2Rlci5vIDwtIHNvdXJjZSA7XG4gICAgZW5jb2Rlci5vX29mZiA8LSBvZmYgO1xuICAgIGVuY29kZXIub19wb3MgPC0gMCA7XG4gICAgZW5jb2Rlci5vX2xlbiA8LSBsZW4gLSAxXG5cbiAgbGV0IGRzdF9yZW0gPSBvX3JlbVxuXG4gIGxldCBwYXJ0aWFsIGsgZW5jb2RlciA9IGZ1bmN0aW9uXG4gICAgfCBgQXdhaXQgLT4gayBlbmNvZGVyXG4gICAgfCBgQ2hhciBfIHwgYEVuZCAtPiBpbnZhbGlkX2VuY29kZSAoKVxuXG4gIGxldCBmbHVzaCBrIGVuY29kZXIgPVxuICAgIG1hdGNoIGVuY29kZXIuZHN0IHdpdGhcbiAgICB8IGBNYW51YWwgLT5cbiAgICAgIGVuY29kZXIuayA8LSBwYXJ0aWFsIGsgO1xuICAgICAgYFBhcnRpYWxcbiAgICB8IGBDaGFubmVsIG9jIC0+XG4gICAgICBvdXRwdXQgb2MgZW5jb2Rlci5vIGVuY29kZXIub19vZmYgZW5jb2Rlci5vX3BvcyA7XG4gICAgICBlbmNvZGVyLm9fcG9zIDwtIDAgO1xuICAgICAgayBlbmNvZGVyXG4gICAgfCBgQnVmZmVyIGIgLT5cbiAgICAgIGxldCBvID0gQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBlbmNvZGVyLm8gaW5cbiAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIgbyBlbmNvZGVyLm9fb2ZmIGVuY29kZXIub19wb3MgO1xuICAgICAgZW5jb2Rlci5vX3BvcyA8LSAwIDtcbiAgICAgIGsgZW5jb2RlclxuXG4gIGxldCB0X3JhbmdlIGVuY29kZXIgbGVuID1cbiAgICBlbmNvZGVyLnRfcG9zIDwtIDAgO1xuICAgIGVuY29kZXIudF9sZW4gPC0gbGVuXG5cbiAgbGV0IHJlYyB0X2ZsdXNoIGsgZW5jb2RlciA9XG4gICAgbGV0IGJsaXQgZW5jb2RlciBsZW4gPVxuICAgICAgdW5zYWZlX2JsaXQgZW5jb2Rlci50IGVuY29kZXIudF9wb3MgZW5jb2Rlci5vIGVuY29kZXIub19wb3MgbGVuIDtcbiAgICAgIGVuY29kZXIub19wb3MgPC0gZW5jb2Rlci5vX3BvcyArIGxlbiA7XG4gICAgICBlbmNvZGVyLnRfcG9zIDwtIGVuY29kZXIudF9wb3MgKyBsZW5cbiAgICBpblxuICAgIGxldCByZW0gPSBvX3JlbSBlbmNvZGVyIGluXG4gICAgbGV0IGxlbiA9IGVuY29kZXIudF9sZW4gLSBlbmNvZGVyLnRfcG9zICsgMSBpblxuICAgIGlmIHJlbSA8IGxlbiB0aGVuIChcbiAgICAgIGJsaXQgZW5jb2RlciByZW0gO1xuICAgICAgZmx1c2ggKHRfZmx1c2ggaykgZW5jb2RlciApXG4gICAgZWxzZSAoIGJsaXQgZW5jb2RlciBsZW4gOyBrIGVuY29kZXIgKVxuXG4gIGxldCB0b19oZXggY29kZSA9XG4gICAgbWF0Y2ggQ2hhci51bnNhZmVfY2hyIGNvZGUgd2l0aFxuICAgIHwgJ1xcMDAwJyAuLiAnXFwwMDknIC0+IENoYXIuY2hyIChDaGFyLmNvZGUgJzAnICsgY29kZSlcbiAgICB8ICdcXDAxMCcgLi4gJ1xcMDE1JyAtPiBDaGFyLmNociAoQ2hhci5jb2RlICdBJyArIGNvZGUgLSAxMClcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgbGV0IHJlYyBlbmNvZGVfcXVvdGVkX3ByaW50YWJsZSBlbmNvZGVyIHYgPVxuICAgIGxldCBrIGVuY29kZXIgPVxuICAgICAgZW5jb2Rlci5rIDwtIGVuY29kZV9xdW90ZWRfcHJpbnRhYmxlIDtcbiAgICAgIGBPa1xuICAgIGluXG4gICAgbWF0Y2ggdiB3aXRoXG4gICAgfCBgQXdhaXQgLT4gayBlbmNvZGVyXG4gICAgfCBgRW5kIC0+IGZsdXNoIGsgZW5jb2RlclxuICAgIHwgYENoYXIgY2hyIC0+XG4gICAgICBsZXQgcmVtID0gb19yZW0gZW5jb2RlciBpblxuICAgICAgaWYgcmVtIDwgMSB0aGVuXG4gICAgICAgIGZsdXNoIChmdW4gZW5jb2RlciAtPiBlbmNvZGVfcXVvdGVkX3ByaW50YWJsZSBlbmNvZGVyIHYpIGVuY29kZXJcbiAgICAgIGVsc2UgbWF0Y2ggY2hyIHdpdGhcbiAgICAgICAgfCAnICcgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0X2NociBlbmNvZGVyLm8gKGVuY29kZXIub19vZmYgKyBlbmNvZGVyLm9fcG9zKSAnXycgO1xuICAgICAgICAgIGVuY29kZXIub19wb3MgPC0gZW5jb2Rlci5vX3BvcyArIDEgO1xuICAgICAgICAgIGsgZW5jb2RlclxuICAgICAgICB8ICdcXDAzMycgLi4gJ1xcMDYwJyB8ICdcXDA2MicgLi4gJ1xcMTI2JyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXRfY2hyIGVuY29kZXIubyAoZW5jb2Rlci5vX29mZiArIGVuY29kZXIub19wb3MpIGNociA7XG4gICAgICAgICAgZW5jb2Rlci5vX3BvcyA8LSBlbmNvZGVyLm9fcG9zICsgMSA7XG4gICAgICAgICAgayBlbmNvZGVyXG4gICAgICAgIHwgdW5zYWZlX2NociAtPlxuICAgICAgICAgIGxldCBoaSA9IHRvX2hleCAoQ2hhci5jb2RlIHVuc2FmZV9jaHIgLyAxNikgaW5cbiAgICAgICAgICBsZXQgbG8gPSB0b19oZXggKENoYXIuY29kZSB1bnNhZmVfY2hyIG1vZCAxNikgaW5cbiAgICAgICAgICBsZXQgcywgaiwgayA9XG4gICAgICAgICAgICBpZiByZW0gPCAzIHRoZW4gKFxuICAgICAgICAgICAgICB0X3JhbmdlIGVuY29kZXIgMyA7XG4gICAgICAgICAgICAgIChlbmNvZGVyLnQsIDAsIHRfZmx1c2ggaykgKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgaiA9IGVuY29kZXIub19wb3MgaW5cbiAgICAgICAgICAgICAgZW5jb2Rlci5vX3BvcyA8LSBlbmNvZGVyLm9fcG9zICsgMyA7XG4gICAgICAgICAgICAgIChlbmNvZGVyLm8sIGVuY29kZXIub19vZmYgKyBqLCBrKVxuICAgICAgICAgIGluXG4gICAgICAgICAgdW5zYWZlX3NldF9jaHIgcyBqICc9JyA7XG4gICAgICAgICAgdW5zYWZlX3NldF9jaHIgcyAoaiArIDEpIGhpIDtcbiAgICAgICAgICB1bnNhZmVfc2V0X2NociBzIChqICsgMikgbG8gO1xuICAgICAgICAgIGsgZW5jb2RlclxuXG4gIGxldCBlbmNvZGVyIGRzdCA9XG4gICAgbGV0IG8sIG9fb2ZmLCBvX3Bvcywgb19sZW4gPVxuICAgICAgbWF0Y2ggZHN0IHdpdGhcbiAgICAgIHwgYE1hbnVhbCAtPiAoQnl0ZXMuZW1wdHksIDEsIDAsIDApXG4gICAgICB8IGBCdWZmZXIgXyB8IGBDaGFubmVsIF8gLT5cbiAgICAgICAgKEJ5dGVzLmNyZWF0ZSBpb19idWZmZXJfc2l6ZSwgMCwgMCwgaW9fYnVmZmVyX3NpemUgLSAxKVxuICAgIGluXG4gICAgeyBkc3RcbiAgICA7IG9fb2ZmXG4gICAgOyBvX3Bvc1xuICAgIDsgb19sZW5cbiAgICA7IG9cbiAgICA7IHQ9IEJ5dGVzLmNyZWF0ZSAzXG4gICAgOyB0X3Bvcz0gMVxuICAgIDsgdF9sZW49IDBcbiAgICA7IGs9IGVuY29kZV9xdW90ZWRfcHJpbnRhYmxlIH1cblxuICBsZXQgZW5jb2RlIGVuY29kZXIgdiA9IGVuY29kZXIuayBlbmNvZGVyIHZcbiAgbGV0IGVuY29kZXJfZHN0IGVuY29kZXIgPSBlbmNvZGVyLmRzdFxuZW5kXG5cbigqIEVuY29kZSAqKVxuXG50eXBlIHVuc2FmZV9jaGFyID0gY2hhclxudHlwZSBkc3QgPSBbYENoYW5uZWwgb2Ygb3V0X2NoYW5uZWwgfCBgQnVmZmVyIG9mIEJ1ZmZlci50IHwgYE1hbnVhbF1cbnR5cGUgZW5jb2RlID0gW2BBd2FpdCB8IGBFbmQgfCBgQ2hhciBvZiB1bnNhZmVfY2hhciB8IGBMaW5lX2JyZWFrXVxuXG50eXBlIGVuY29kZXIgPVxuICB7IGRzdDogZHN0XG4gIDsgbXV0YWJsZSBvOiBCeXRlcy50XG4gIDsgbXV0YWJsZSBvX29mZjogaW50XG4gIDsgbXV0YWJsZSBvX3BvczogaW50XG4gIDsgbXV0YWJsZSBvX2xlbjogaW50XG4gIDsgdDogQnl0ZXMudFxuICA7IG11dGFibGUgdF9wb3M6IGludFxuICA7IG11dGFibGUgdF9sZW46IGludFxuICA7IG11dGFibGUgY19jb2w6IGludFxuICA7IG11dGFibGUgazogZW5jb2RlciAtPiBlbmNvZGUgLT4gW2BPayB8IGBQYXJ0aWFsXSB9XG5cbmxldCBvX3JlbSBlbmNvZGVyID0gZW5jb2Rlci5vX2xlbiAtIGVuY29kZXIub19wb3MgKyAxXG5cbmxldCBkc3QgZW5jb2RlciBzb3VyY2Ugb2ZmIGxlbiA9XG4gIGlmIG9mZiA8IDAgfHwgbGVuIDwgMCB8fCBvZmYgKyBsZW4gPiBCeXRlcy5sZW5ndGggc291cmNlIHRoZW5cbiAgICBpbnZhbGlkX2JvdW5kcyBvZmYgbGVuIDtcbiAgZW5jb2Rlci5vIDwtIHNvdXJjZSA7XG4gIGVuY29kZXIub19vZmYgPC0gb2ZmIDtcbiAgZW5jb2Rlci5vX3BvcyA8LSAwIDtcbiAgZW5jb2Rlci5vX2xlbiA8LSBsZW4gLSAxXG5cbmxldCBkc3RfcmVtID0gb19yZW1cblxubGV0IHBhcnRpYWwgayBlbmNvZGVyID0gZnVuY3Rpb25cbiAgfCBgQXdhaXQgLT4gayBlbmNvZGVyXG4gIHwgYENoYXIgXyB8IGBMaW5lX2JyZWFrIHwgYEVuZCAtPiBpbnZhbGlkX2VuY29kZSAoKVxuXG5sZXQgZmx1c2ggayBlbmNvZGVyID1cbiAgbWF0Y2ggZW5jb2Rlci5kc3Qgd2l0aFxuICB8IGBNYW51YWwgLT5cbiAgICAgIGVuY29kZXIuayA8LSBwYXJ0aWFsIGsgO1xuICAgICAgYFBhcnRpYWxcbiAgfCBgQ2hhbm5lbCBvYyAtPlxuICAgICAgb3V0cHV0IG9jIGVuY29kZXIubyBlbmNvZGVyLm9fb2ZmIGVuY29kZXIub19wb3MgO1xuICAgICAgZW5jb2Rlci5vX3BvcyA8LSAwIDtcbiAgICAgIGsgZW5jb2RlclxuICB8IGBCdWZmZXIgYiAtPlxuICAgICAgbGV0IG8gPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGVuY29kZXIubyBpblxuICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYiBvIGVuY29kZXIub19vZmYgZW5jb2Rlci5vX3BvcyA7XG4gICAgICBlbmNvZGVyLm9fcG9zIDwtIDAgO1xuICAgICAgayBlbmNvZGVyXG5cbmxldCB0X3JhbmdlIGVuY29kZXIgbGVuID1cbiAgZW5jb2Rlci50X3BvcyA8LSAwIDtcbiAgZW5jb2Rlci50X2xlbiA8LSBsZW5cblxubGV0IHJlYyB0X2ZsdXNoIGsgZW5jb2RlciA9XG4gIGxldCBibGl0IGVuY29kZXIgbGVuID1cbiAgICB1bnNhZmVfYmxpdCBlbmNvZGVyLnQgZW5jb2Rlci50X3BvcyBlbmNvZGVyLm8gZW5jb2Rlci5vX3BvcyBsZW4gO1xuICAgIGVuY29kZXIub19wb3MgPC0gZW5jb2Rlci5vX3BvcyArIGxlbiA7XG4gICAgZW5jb2Rlci50X3BvcyA8LSBlbmNvZGVyLnRfcG9zICsgbGVuXG4gIGluXG4gIGxldCByZW0gPSBvX3JlbSBlbmNvZGVyIGluXG4gIGxldCBsZW4gPSBlbmNvZGVyLnRfbGVuIC0gZW5jb2Rlci50X3BvcyArIDEgaW5cbiAgaWYgcmVtIDwgbGVuIHRoZW4gKFxuICAgIGJsaXQgZW5jb2RlciByZW0gO1xuICAgIGZsdXNoICh0X2ZsdXNoIGspIGVuY29kZXIgKVxuICBlbHNlICggYmxpdCBlbmNvZGVyIGxlbiA7IGsgZW5jb2RlciApXG5cbmxldCB0b19oZXggY29kZSA9XG4gIG1hdGNoIENoYXIudW5zYWZlX2NociBjb2RlIHdpdGhcbiAgfCAnXFwwMDAnIC4uICdcXDAwOScgLT4gQ2hhci5jaHIgKENoYXIuY29kZSAnMCcgKyBjb2RlKVxuICB8ICdcXDAxMCcgLi4gJ1xcMDE1JyAtPiBDaGFyLmNociAoQ2hhci5jb2RlICdBJyArIGNvZGUgLSAxMClcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVjIGVuY29kZV9xdW90ZWRfcHJpbnRhYmxlIGVuY29kZXIgdiA9XG4gIGxldCBrIGNvbF9jb3VudCBlbmNvZGVyID1cbiAgICBlbmNvZGVyLmNfY29sIDwtIGVuY29kZXIuY19jb2wgKyBjb2xfY291bnQgO1xuICAgIGVuY29kZXIuayA8LSBlbmNvZGVfcXVvdGVkX3ByaW50YWJsZSA7XG4gICAgYE9rXG4gIGluXG4gIG1hdGNoIHYgd2l0aFxuICB8IGBBd2FpdCAtPiBrIDAgZW5jb2RlclxuICB8IGBFbmQgLT4gZmx1c2ggKGsgMCkgZW5jb2RlclxuICB8IGBMaW5lX2JyZWFrIC0+XG4gICAgICBsZXQgcmVtID0gb19yZW0gZW5jb2RlciBpblxuICAgICAgbGV0IHMsIGosIGsgPVxuICAgICAgICBpZiByZW0gPCAyIHRoZW4gKFxuICAgICAgICAgIHRfcmFuZ2UgZW5jb2RlciAyIDtcbiAgICAgICAgICAoZW5jb2Rlci50LCAwLCB0X2ZsdXNoIChrIDIpKSApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgaiA9IGVuY29kZXIub19wb3MgaW5cbiAgICAgICAgICBlbmNvZGVyLm9fcG9zIDwtIGVuY29kZXIub19wb3MgKyAyIDtcbiAgICAgICAgICAoZW5jb2Rlci5vLCBlbmNvZGVyLm9fb2ZmICsgaiwgayAyKVxuICAgICAgaW5cbiAgICAgIHVuc2FmZV9zZXRfY2hyIHMgaiAnXFxyJyA7XG4gICAgICB1bnNhZmVfc2V0X2NociBzIChqICsgMSkgJ1xcbicgO1xuICAgICAgZW5jb2Rlci5jX2NvbCA8LSAwIDtcbiAgICAgIGZsdXNoIGsgZW5jb2RlclxuICB8IGBDaGFyIGNociAtPiAoXG4gICAgICBsZXQgcmVtID0gb19yZW0gZW5jb2RlciBpblxuICAgICAgaWYgcmVtIDwgMSB0aGVuXG4gICAgICAgIGZsdXNoIChmdW4gZW5jb2RlciAtPiBlbmNvZGVfcXVvdGVkX3ByaW50YWJsZSBlbmNvZGVyIHYpIGVuY29kZXJcbiAgICAgIGVsc2UgaWYgZW5jb2Rlci5jX2NvbCA9IDc1IHRoZW5cbiAgICAgICAgZW5jb2RlX3NvZnRfbGluZV9icmVha1xuICAgICAgICAgIChmdW4gZW5jb2RlciAtPiBlbmNvZGVfcXVvdGVkX3ByaW50YWJsZSBlbmNvZGVyIHYpXG4gICAgICAgICAgZW5jb2RlclxuICAgICAgZWxzZVxuICAgICAgICBtYXRjaCBjaHIgd2l0aFxuICAgICAgICB8ICdcXDAzMycgLi4gJ1xcMDYwJyB8ICdcXDA2MicgLi4gJ1xcMTI2JyAtPlxuICAgICAgICAgICAgdW5zYWZlX3NldF9jaHIgZW5jb2Rlci5vIChlbmNvZGVyLm9fb2ZmICsgZW5jb2Rlci5vX3BvcykgY2hyIDtcbiAgICAgICAgICAgIGVuY29kZXIub19wb3MgPC0gZW5jb2Rlci5vX3BvcyArIDEgO1xuICAgICAgICAgICAgayAxIGVuY29kZXJcbiAgICAgICAgfCB1bnNhZmVfY2hyIC0+XG4gICAgICAgICAgICBpZiBlbmNvZGVyLmNfY29sIDwgNzMgdGhlbiAoXG4gICAgICAgICAgICAgIGxldCBoaSA9IHRvX2hleCAoQ2hhci5jb2RlIHVuc2FmZV9jaHIgLyAxNikgaW5cbiAgICAgICAgICAgICAgbGV0IGxvID0gdG9faGV4IChDaGFyLmNvZGUgdW5zYWZlX2NociBtb2QgMTYpIGluXG4gICAgICAgICAgICAgIGxldCBzLCBqLCBrID1cbiAgICAgICAgICAgICAgICBpZiByZW0gPCAzIHRoZW4gKFxuICAgICAgICAgICAgICAgICAgdF9yYW5nZSBlbmNvZGVyIDMgO1xuICAgICAgICAgICAgICAgICAgKGVuY29kZXIudCwgMCwgdF9mbHVzaCAoayAzKSkgKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIGxldCBqID0gZW5jb2Rlci5vX3BvcyBpblxuICAgICAgICAgICAgICAgICAgZW5jb2Rlci5vX3BvcyA8LSBlbmNvZGVyLm9fcG9zICsgMyA7XG4gICAgICAgICAgICAgICAgICAoZW5jb2Rlci5vLCBlbmNvZGVyLm9fb2ZmICsgaiwgayAzKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICB1bnNhZmVfc2V0X2NociBzIGogJz0nIDtcbiAgICAgICAgICAgICAgdW5zYWZlX3NldF9jaHIgcyAoaiArIDEpIGhpIDtcbiAgICAgICAgICAgICAgdW5zYWZlX3NldF9jaHIgcyAoaiArIDIpIGxvIDtcbiAgICAgICAgICAgICAgayBlbmNvZGVyIClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZW5jb2RlX3NvZnRfbGluZV9icmVha1xuICAgICAgICAgICAgICAgIChmdW4gZW5jb2RlciAtPiBlbmNvZGVfcXVvdGVkX3ByaW50YWJsZSBlbmNvZGVyIHYpXG4gICAgICAgICAgICAgICAgZW5jb2RlciApXG5cbmFuZCBlbmNvZGVfc29mdF9saW5lX2JyZWFrIGsgZW5jb2RlciA9XG4gIGxldCByZW0gPSBvX3JlbSBlbmNvZGVyIGluXG4gIGxldCBzLCBqLCBrID1cbiAgICBpZiByZW0gPCAzIHRoZW4gKFxuICAgICAgdF9yYW5nZSBlbmNvZGVyIDMgO1xuICAgICAgKGVuY29kZXIudCwgMCwgdF9mbHVzaCBrKSApXG4gICAgZWxzZVxuICAgICAgbGV0IGogPSBlbmNvZGVyLm9fcG9zIGluXG4gICAgICBlbmNvZGVyLm9fcG9zIDwtIGVuY29kZXIub19wb3MgKyAzIDtcbiAgICAgIChlbmNvZGVyLm8sIGVuY29kZXIub19vZmYgKyBqLCBrKVxuICBpblxuICB1bnNhZmVfc2V0X2NociBzIGogJz0nIDtcbiAgdW5zYWZlX3NldF9jaHIgcyAoaiArIDEpICdcXHInIDtcbiAgdW5zYWZlX3NldF9jaHIgcyAoaiArIDIpICdcXG4nIDtcbiAgZW5jb2Rlci5jX2NvbCA8LSAwIDtcbiAgZmx1c2ggayBlbmNvZGVyXG5cbmxldCBlbmNvZGVyIGRzdCA9XG4gIGxldCBvLCBvX29mZiwgb19wb3MsIG9fbGVuID1cbiAgICBtYXRjaCBkc3Qgd2l0aFxuICAgIHwgYE1hbnVhbCAtPiAoQnl0ZXMuZW1wdHksIDEsIDAsIDApXG4gICAgfCBgQnVmZmVyIF8gfCBgQ2hhbm5lbCBfIC0+XG4gICAgICAgIChCeXRlcy5jcmVhdGUgaW9fYnVmZmVyX3NpemUsIDAsIDAsIGlvX2J1ZmZlcl9zaXplIC0gMSlcbiAgaW5cbiAgeyBkc3RcbiAgOyBvX29mZlxuICA7IG9fcG9zXG4gIDsgb19sZW5cbiAgOyBvXG4gIDsgdD0gQnl0ZXMuY3JlYXRlIDNcbiAgOyB0X3Bvcz0gMVxuICA7IHRfbGVuPSAwXG4gIDsgY19jb2w9IDBcbiAgOyBrPSBlbmNvZGVfcXVvdGVkX3ByaW50YWJsZSB9XG5cbmxldCBlbmNvZGUgZW5jb2RlciB2ID0gZW5jb2Rlci5rIGVuY29kZXIgdlxubGV0IGVuY29kZXJfZHN0IGVuY29kZXIgPSBlbmNvZGVyLmRzdFxuIl19
