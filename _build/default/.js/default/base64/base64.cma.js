// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Base64__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base64 = [0];
   runtime.caml_register_global(0, Base64, "Base64__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base64__Unsafe
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base64_Unsafe = [0];
   runtime.caml_register_global(0, Base64_Unsafe, "Base64__Unsafe");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base64
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Invalid_bounds = "Invalid bounds",
    cst_Malformed_input = "Malformed input",
    cst_Too_much_input = "Too much input",
    cst_Wrong_padding = "Wrong padding",
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get16 = runtime.caml_string_get16,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys,
    _e_ = [0, [11, cst_Invalid_bounds, 0], cst_Invalid_bounds],
    _f_ = [0, [11, cst_Wrong_padding, 0], cst_Wrong_padding],
    _g_ = [0, [11, cst_Malformed_input, 0], cst_Malformed_input],
    _h_ = [0, [11, cst_Too_much_input, 0], cst_Too_much_input],
    _c_ = [0, "src/base64.ml", 157, 15],
    _b_ = [0, [11, cst_Invalid_bounds, 0], cst_Invalid_bounds],
    cst_Length_of_alphabet_must_be = "Length of alphabet must be 64",
    cst_Alphabet_can_not_contain_p =
      "Alphabet can not contain padding character",
    cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ$0 =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    cst_Base64_Out_of_bounds = "Base64.Out_of_bounds",
    cst_Base64_Too_much_input = "Base64.Too_much_input";
   function symbol(x, y){
    if(y < 1) throw caml_maybe_attach_backtrace(Stdlib[13], 1);
    return 0 < x ? 1 + runtime.caml_div(x - 1 | 0, y) | 0 : 0;
   }
   function unsafe_set_uint8(t, off, v){
    runtime.caml_bytes_unsafe_set(t, off, caml_call1(Stdlib_Char[1], v));
    return;
   }
   function make_alphabet(alphabet){
    if(64 !== caml_ml_string_length(alphabet))
     caml_call1(Stdlib[1], cst_Length_of_alphabet_must_be);
    if(caml_call2(Stdlib_String[15], alphabet, 61))
     caml_call1(Stdlib[1], cst_Alphabet_can_not_contain_p);
    function _C_(i){return runtime.caml_string_get(alphabet, i);}
    var
     emap = caml_call2(Stdlib_Array[1], caml_ml_string_length(alphabet), _C_),
     dmap = runtime.caml_make_vect(256, -1);
    function _D_(idx, chr){
     caml_check_bound(dmap, chr)[1 + chr] = idx;
     return 0;
    }
    caml_call2(Stdlib_String[31], _D_, alphabet);
    return [0, emap, dmap];
   }
   function length_alphabet(param){
    var emap = param[1];
    return emap.length - 1;
   }
   function alphabet(param){
    var emap = param[1];
    function _A_(i){
     var _B_ = caml_check_bound(emap, i)[1 + i];
     return caml_call1(Stdlib_Char[1], _B_);
    }
    return caml_call2(Stdlib_String[2], emap.length - 1, _A_);
   }
   var
    default_alphabet = make_alphabet(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ),
    uri_safe_alphabet = make_alphabet(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ$0),
    unsafe_set_be_uint16 =
      Stdlib_Sys[11]
       ? caml_bytes_set16
       : function
        (t, off, v){
         caml_bytes_set16(t, off, runtime.caml_bswap16(v));
         return;
        },
    Out_of_bounds = [248, cst_Base64_Out_of_bounds, caml_fresh_oo_id(0)],
    Too_much_input = [248, cst_Base64_Too_much_input, caml_fresh_oo_id(0)];
   function get_uint8(t, off){
    var
     _y_ = off < 0 ? 1 : 0,
     _z_ = _y_ || (caml_ml_string_length(t) <= off ? 1 : 0);
    if(_z_) throw caml_maybe_attach_backtrace(Out_of_bounds, 1);
    return caml_string_unsafe_get(t, off);
   }
   var padding = 61;
   function error_msgf(fmt){
    function _x_(err){return [1, [0, 3854881, err]];}
    return caml_call2(Stdlib_Format[147], _x_, fmt);
   }
   function _a_(pad, param, opt, len, input){
    var emap = param[1];
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_ml_string_length(input) - off | 0;
    if
     (0 <= len$1
      && 0 <= off && (caml_ml_string_length(input) - len$1 | 0) >= off){
     var
      n = symbol(len$1, 3) * 4 | 0,
      res = caml_create_bytes(n),
      emap$0 = function(i){return emap[1 + i];},
      emit =
        function(b1, b2, b3, i){
         var _v_ = emap$0((b1 << 4 | b2 >>> 4 | 0) & 63);
         unsafe_set_be_uint16(res, i, emap$0((b1 >>> 2 | 0) & 63) << 8 | _v_);
         var _w_ = emap$0(b3 & 63);
         return unsafe_set_be_uint16
                 (res,
                  i + 2 | 0,
                  emap$0((b2 << 2 | b3 >>> 6 | 0) & 63) << 8 | _w_);
        };
     a:
     b:
     {
      c:
      {
       var j = 0, i = 0;
       for(;;){
        if(i === len$1) break b;
        if(i === (len$1 - 1 | 0)) break c;
        if(i === (len$1 - 2 | 0)) break;
        emit
         (caml_string_unsafe_get(input, off + i | 0),
          caml_string_unsafe_get(input, (off + i | 0) + 1 | 0),
          caml_string_unsafe_get(input, (off + i | 0) + 2 | 0),
          j);
        var i$0 = i + 3 | 0, j$0 = j + 4 | 0, j = j$0, i = i$0;
       }
       emit
        (caml_string_unsafe_get(input, off + i | 0),
         caml_string_unsafe_get(input, (off + i | 0) + 1 | 0),
         0,
         j);
       break a;
      }
      emit(caml_string_unsafe_get(input, off + i | 0), 0, 0, j);
      break a;
     }
     var pad_to_write = (3 - (len$1 % 3 | 0) | 0) % 3 | 0;
     if(! pad)
      return [0,
              [0, caml_call1(Stdlib_Bytes[44], res), 0, n - pad_to_write | 0]];
     var i$1 = pad_to_write;
     for(;;){
      if(0 === i$1) return [0, [0, caml_call1(Stdlib_Bytes[44], res), 0, n]];
      unsafe_set_uint8(res, n - i$1 | 0, padding);
      var i$2 = i$1 - 1 | 0, i$1 = i$2;
     }
    }
    return error_msgf(_b_);
   }
   function encode(opt, _u_, off, len, input){
    if(opt) var sth = opt[1], pad = sth; else var pad = 1;
    if(_u_)
     var sth$0 = _u_[1], alphabet = sth$0;
    else
     var alphabet = default_alphabet;
    var err = _a_(pad, alphabet, off, len, input);
    if(0 !== err[0]) return err;
    var match = err[1], len$0 = match[3], off$0 = match[2], res = match[1];
    return [0, caml_call3(Stdlib_String[16], res, off$0, len$0)];
   }
   function encode_string(pad, alphabet, input){
    var match = encode(pad, alphabet, 0, 0, input);
    if(0 !== match[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var res = match[1];
    return res;
   }
   function encode_sub(opt, _t_, off, len, input){
    if(opt) var sth = opt[1], pad = sth; else var pad = 1;
    if(_t_)
     var sth$0 = _t_[1], alphabet = sth$0;
    else
     var alphabet = default_alphabet;
    return _a_(pad, alphabet, off, len, input);
   }
   function encode_exn(pad, alphabet, off, len, input){
    var match = encode(pad, alphabet, off, len, input);
    if(0 === match[0]){var v = match[1]; return v;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   function _d_(opt, param){
    if(opt)
     var sth = opt[1], invalid_pad_overflow = sth;
    else
     var invalid_pad_overflow = 1;
    var dmap = param[2];
    return function(opt, len, input){
     if(opt) var sth = opt[1], off = sth; else var off = 0;
     if(len)
      var len$0 = len[1], len$1 = len$0;
     else
      var len$1 = caml_ml_string_length(input) - off | 0;
     if
      (0 <= len$1
       && 0 <= off && (caml_ml_string_length(input) - len$1 | 0) >= off){
      var
       n = symbol(len$1, 4) * 4 | 0,
       n$0 = symbol(n, 4) * 3 | 0,
       res = caml_create_bytes(n$0),
       get_uint8_or_padding =
         invalid_pad_overflow
          ? function
           (t, i){
            if(len$1 <= i)
             throw caml_maybe_attach_backtrace(Out_of_bounds, 1);
            return get_uint8(t, off + i | 0);
           }
          : function
           (t, i){
            try{
             var _r_ = i < len$1 ? get_uint8(t, off + i | 0) : padding;
             return _r_;
            }
            catch(_s_){
             var _q_ = caml_wrap_exception(_s_);
             if(_q_ === Out_of_bounds) return padding;
             throw caml_maybe_attach_backtrace(_q_, 0);
            }
           },
       dmap$0 =
         function(i){
          var x = dmap[1 + i];
          if(x === -1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          return x;
         },
       only_padding =
         function(pad, idx){
          var pad$0 = [0, pad + 3 | 0], idx$0 = [0, idx];
          for(;;){
           if((idx$0[1] + 4 | 0) >= len$1) break;
           var
            _o_ =
              15677 !== caml_string_get16(input, off + idx$0[1] | 0) ? 1 : 0,
            _p_ =
              _o_
              ||
               (15677
                 !== caml_string_get16(input, (off + idx$0[1] | 0) + 2 | 0)
                 ? 1
                 : 0);
           if(_p_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           idx$0[1] = idx$0[1] + 4 | 0;
           pad$0[1] = pad$0[1] + 3 | 0;
          }
          for(;;){
           if(idx$0[1] >= len$1) return pad$0[1];
           if(caml_string_unsafe_get(input, off + idx$0[1] | 0) !== 61)
            throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           idx$0[1]++;
          }
         };
      try{
       a:
       {
        b:
        {
         var off$1 = 0, i = 0;
         for(;;){
          if(i === n){var pad$4 = 0; break a;}
          var x$0 = get_uint8_or_padding(input, i + 3 | 0);
          c:
          try{var pad$3 = 0, _l_ = dmap$0(x$0), pad = pad$3, d = _l_;}
          catch(exn$0){
           var exn = caml_wrap_exception(exn$0);
           if(exn === Stdlib[8] && x$0 === 61){var pad = 1, d = 0; break c;}
           throw caml_maybe_attach_backtrace(exn, 0);
          }
          var x$1 = get_uint8_or_padding(input, i + 2 | 0);
          c:
          try{var _k_ = dmap$0(x$1), pad$0 = pad, c = _k_;}
          catch(exn){
           var exn$0 = caml_wrap_exception(exn);
           if(exn$0 === Stdlib[8] && x$1 === 61 && 1 === pad){var pad$0 = 2, c = 0; break c;}
           throw caml_maybe_attach_backtrace(exn$0, 0);
          }
          var x$2 = get_uint8_or_padding(input, i + 1 | 0);
          c:
          try{var _j_ = dmap$0(x$2), pad$1 = pad$0, b = _j_;}
          catch(exn){
           var exn$1 = caml_wrap_exception(exn);
           if(exn$1 === Stdlib[8] && x$2 === 61 && 2 === pad$0){var pad$1 = 3, b = 0; break c;}
           throw caml_maybe_attach_backtrace(exn$1, 0);
          }
          var x$3 = get_uint8_or_padding(input, i);
          c:
          try{var _i_ = dmap$0(x$3), pad$2 = pad$1, a = _i_;}
          catch(exn){
           var exn$2 = caml_wrap_exception(exn);
           if(exn$2 === Stdlib[8] && x$3 === 61 && 3 === pad$1){var pad$2 = 4, a = 0; break c;}
           throw caml_maybe_attach_backtrace(exn$2, 0);
          }
          var x = a << 18 | b << 12 | c << 6 | d, v = x >>> 8 | 0;
          c:
          if(0 <= off$1 && caml_ml_bytes_length(res) >= (off$1 + 1 | 0)){
           if(0 <= off$1 && caml_ml_bytes_length(res) >= (off$1 + 2 | 0)){unsafe_set_be_uint16(res, off$1, v); break c;}
           unsafe_set_uint8(res, off$1, v >>> 8 | 0);
           break c;
          }
          var v$0 = x & 255, off$0 = off$1 + 2 | 0;
          c:
          if(0 <= off$0 && caml_ml_bytes_length(res) > off$0){unsafe_set_uint8(res, off$0, v$0); break c;}
          if((i + 4 | 0) === n) break b;
          if(0 !== pad$2) break;
          var i$0 = i + 4 | 0, j = off$1 + 3 | 0, off$1 = j, i = i$0;
         }
         if(4 === pad$2){var pad$4 = only_padding(3, i + 4 | 0); break a;}
         if(1 === invalid_pad_overflow)
          throw caml_maybe_attach_backtrace(Too_much_input, 1);
         var pad$4 = only_padding(pad$2, i + 4 | 0);
         break a;
        }
        var pad$4 = 0 === pad$2 ? 0 : 4 === pad$2 ? 3 : pad$2;
       }
      }
      catch(_n_){
       var _m_ = caml_wrap_exception(_n_);
       if(_m_ === Out_of_bounds) return error_msgf(_f_);
       if(_m_ === Stdlib[8]) return error_msgf(_g_);
       if(_m_ === Too_much_input) return error_msgf(_h_);
       throw caml_maybe_attach_backtrace(_m_, 0);
      }
      return 0 === pad$4
              ? [0, [0, caml_call1(Stdlib_Bytes[44], res), 0, n$0]]
              : [0,
                [0, caml_call1(Stdlib_Bytes[44], res), 0, n$0 - pad$4 | 0]];
     }
     return error_msgf(_e_);};
   }
   function decode(pad, opt, off, len, input){
    if(opt)
     var sth = opt[1], alphabet = sth;
    else
     var alphabet = default_alphabet;
    var err = _d_(pad, alphabet)(off, len, input);
    if(0 !== err[0]) return err;
    var match = err[1], len$0 = match[3], off$0 = match[2], res = match[1];
    return [0, caml_call3(Stdlib_String[16], res, off$0, len$0)];
   }
   function decode_sub(pad, opt, off, len, input){
    if(opt)
     var sth = opt[1], alphabet = sth;
    else
     var alphabet = default_alphabet;
    return _d_(pad, alphabet)(off, len, input);
   }
   function decode_exn(pad, alphabet, off, len, input){
    var match = decode(pad, alphabet, off, len, input);
    if(0 === match[0]){var res = match[1]; return res;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   var
    Base64 =
      [0,
       default_alphabet,
       uri_safe_alphabet,
       make_alphabet,
       length_alphabet,
       alphabet,
       decode_exn,
       decode_sub,
       decode,
       encode,
       encode_string,
       encode_sub,
       encode_exn];
   runtime.caml_register_global(20, Base64, "Base64");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlNjQuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInN5bWJvbCIsIngiLCJ5IiwidW5zYWZlX3NldF91aW50OCIsInQiLCJvZmYiLCJ2IiwibWFrZV9hbHBoYWJldCIsImFscGhhYmV0IiwiaSIsImVtYXAiLCJkbWFwIiwiaWR4IiwiY2hyIiwibGVuZ3RoX2FscGhhYmV0IiwiZGVmYXVsdF9hbHBoYWJldCIsInVyaV9zYWZlX2FscGhhYmV0IiwidW5zYWZlX3NldF9iZV91aW50MTYiLCJnZXRfdWludDgiLCJwYWRkaW5nIiwiZXJyb3JfbXNnZiIsImZtdCIsImVyciIsInBhZCIsIm9wdCIsImxlbiIsImlucHV0Iiwic3RoIiwibGVuJDAiLCJsZW4kMSIsIm4iLCJyZXMiLCJlbWFwJDAiLCJlbWl0IiwiYjEiLCJiMiIsImIzIiwiaiIsImkkMCIsImokMCIsInBhZF90b193cml0ZSIsImkkMSIsImVuY29kZSIsInN0aCQwIiwib2ZmJDAiLCJlbmNvZGVfc3RyaW5nIiwiZW5jb2RlX3N1YiIsImVuY29kZV9leG4iLCJpbnZhbGlkX3BhZF9vdmVyZmxvdyIsIm4kMCIsImdldF91aW50OF9vcl9wYWRkaW5nIiwiZG1hcCQwIiwib25seV9wYWRkaW5nIiwicGFkJDAiLCJpZHgkMCIsIm9mZiQxIiwicGFkJDQiLCJ4JDAiLCJkIiwieCQxIiwiYyIsIngkMiIsInBhZCQxIiwiYiIsIngkMyIsInBhZCQyIiwiYSIsInYkMCIsImRlY29kZSIsImRlY29kZV9zdWIiLCJkZWNvZGVfZXhuIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZTY0L2Jhc2U2NC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUF5QklBLE9BQU9DLEdBQUVDO0lBQ1gsR0FE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QUFXRyxNQUFYSCxRQUFBaEIsV0FBV21COztTQUFYbkIsV0FoUGxCTztJQWlQRixXQURjUSxLQUFNZixVQUE4QkgsS0FBS29CLEtBQUlDO0dBQ25CO1lBRXRDNEMsV0FBWS9DLEtBQUtmLFVBQVVILEtBQUtvQixLQUFJQztJQUNoQyxZQVRKMEMsT0FRWTdDLEtBQUtmLFVBQVVILEtBQUtvQixLQUFJQzsyQkFFakNLLGdCQUFPLE9BQVBBO1FBQ1NUO0lBQVEsT0FBQSxzQkFBUkE7R0FBdUI7Ozs7T0F0UG5DUDtPQUlBQztPQXBCQVQ7T0FXQU87T0FFQU47T0FzUEE4RDtPQUhBRDtPQUxBRDtPQXJKQTFCO09BS0FHO09BS0FDO09BR0FDOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBDaXRyaXggU3lzdGVtcyBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgVGhvbWFzIEdhemFnbmFpcmUgPHRob21hc0BnYXphZ25haXJlLmNvbT5cbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE2IEFuaWwgTWFkaGF2YXBlZGR5IDxhbmlsQHJlY29pbC5vcmc+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRGF2aWQgS2Fsb3BlciBNZXLFoWluamFrXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggUm9tYWluIENhbGFzY2liZXR0YSA8cm9tYWluLmNhbGFzY2liZXR0YUBnbWFpbC5jb20+XG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKilcblxudHlwZSBhbHBoYWJldCA9IHsgZW1hcCA6IGludCBhcnJheTsgZG1hcCA6IGludCBhcnJheSB9XG5cbnR5cGUgc3ViID0gc3RyaW5nICogaW50ICogaW50XG5cbmxldCAoIC8vICkgeCB5ID1cbiAgaWYgeSA8IDEgdGhlbiByYWlzZSBEaXZpc2lvbl9ieV96ZXJvIDtcbiAgaWYgeCA+IDAgdGhlbiAxICsgKCh4IC0gMSkgLyB5KSBlbHNlIDBcbiAgW0BAaW5saW5lXVxuXG5sZXQgdW5zYWZlX2dldF91aW50OCB0IG9mZiA9IENoYXIuY29kZSAoU3RyaW5nLnVuc2FmZV9nZXQgdCBvZmYpXG5cbmxldCB1bnNhZmVfc2V0X3VpbnQ4IHQgb2ZmIHYgPSBCeXRlcy51bnNhZmVfc2V0IHQgb2ZmIChDaGFyLmNociB2KVxuXG5sZXQgdW5zYWZlX3NldF91aW50MTYgPSBVbnNhZmUudW5zYWZlX3NldF91aW50MTZcblxuZXh0ZXJuYWwgdW5zYWZlX2dldF91aW50MTYgOiBzdHJpbmcgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfc3RyaW5nX2dldDE2dVwiXG4gIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCIgW0BAbm9hbGxvY11cblxubGV0IG5vbmUgPSAtMVxuXG4oKiBXZSBtb3N0bHkgd2FudCB0byBoYXZlIGFuIG9wdGlvbmFsIGFycmF5IGZvciBbZG1hcF0gKGUuZy4gW2ludCBvcHRpb25cbiAgIGFycmF5XSkuIFNvIHdlIGNvbnNpZGVyIHRoZSBbbm9uZV0gdmFsdWUgYXMgWy0xXS4gKilcblxubGV0IG1ha2VfYWxwaGFiZXQgYWxwaGFiZXQgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGFscGhhYmV0IDw+IDY0XG4gIHRoZW4gaW52YWxpZF9hcmcgXCJMZW5ndGggb2YgYWxwaGFiZXQgbXVzdCBiZSA2NFwiIDtcbiAgaWYgU3RyaW5nLmNvbnRhaW5zIGFscGhhYmV0ICc9J1xuICB0aGVuIGludmFsaWRfYXJnIFwiQWxwaGFiZXQgY2FuIG5vdCBjb250YWluIHBhZGRpbmcgY2hhcmFjdGVyXCIgO1xuICBsZXQgZW1hcCA9XG4gICAgQXJyYXkuaW5pdCAoU3RyaW5nLmxlbmd0aCBhbHBoYWJldCkgKGZ1biBpIC0+IENoYXIuY29kZSBhbHBoYWJldC5baV0pIGluXG4gIGxldCBkbWFwID0gQXJyYXkubWFrZSAyNTYgbm9uZSBpblxuICBTdHJpbmcuaXRlcmkgKGZ1biBpZHggY2hyIC0+IGRtYXAuKENoYXIuY29kZSBjaHIpIDwtIGlkeCkgYWxwaGFiZXQgO1xuICB7IGVtYXA7IGRtYXAgfVxuXG5sZXQgbGVuZ3RoX2FscGhhYmV0IHsgZW1hcDsgXyB9ID0gQXJyYXkubGVuZ3RoIGVtYXBcblxubGV0IGFscGhhYmV0IHsgZW1hcDsgXyB9ID1cbiAgU3RyaW5nLmluaXQgKEFycmF5Lmxlbmd0aCBlbWFwKSAoZnVuIGkgLT4gQ2hhci5jaHIgZW1hcC4oaSkpXG5cbmxldCBkZWZhdWx0X2FscGhhYmV0ID1cbiAgbWFrZV9hbHBoYWJldFxuICAgIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiXG5cbmxldCB1cmlfc2FmZV9hbHBoYWJldCA9XG4gIG1ha2VfYWxwaGFiZXRcbiAgICBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV9cIlxuXG5sZXQgdW5zYWZlX3NldF9iZV91aW50MTYgPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIGZ1biB0IG9mZiB2IC0+IHVuc2FmZV9zZXRfdWludDE2IHQgb2ZmIHZcbiAgZWxzZSBmdW4gdCBvZmYgdiAtPiB1bnNhZmVfc2V0X3VpbnQxNiB0IG9mZiAoc3dhcDE2IHYpXG5cbigqIFdlIG1ha2UgdGhpcyBleGNlcHRpb24gdG8gZW5zdXJlIHRvIGtlZXAgYSBjb250cm9sIGFib3V0IHdoaWNoIGV4Y2VwdGlvbiB3ZVxuICAgY2FuIHJhaXNlIGFuZCBhdm9pZCBhcHBlYXJhbmNlIG9mIHVua25vd24gZXhjZXB0aW9ucyBsaWtlIGFuIGV4LW5paGlsb1xuICAgbWFnaWMgcmFiYml0IChvciBtYWdpYyBtb25leT8pLiAqKVxuZXhjZXB0aW9uIE91dF9vZl9ib3VuZHNcblxuZXhjZXB0aW9uIFRvb19tdWNoX2lucHV0XG5cbmxldCBnZXRfdWludDggdCBvZmYgPVxuICBpZiBvZmYgPCAwIHx8IG9mZiA+PSBTdHJpbmcubGVuZ3RoIHQgdGhlbiByYWlzZSBPdXRfb2ZfYm91bmRzIDtcbiAgdW5zYWZlX2dldF91aW50OCB0IG9mZlxuXG5sZXQgcGFkZGluZyA9IGludF9vZl9jaGFyICc9J1xuXG5sZXQgZXJyb3JfbXNnZiBmbXQgPSBGb3JtYXQua3NwcmludGYgKGZ1biBlcnIgLT4gRXJyb3IgKGBNc2cgZXJyKSkgZm10XG5cbmxldCBlbmNvZGVfc3ViIHBhZCB7IGVtYXA7IF8gfSA/KG9mZiA9IDApID9sZW4gaW5wdXQgPVxuICBsZXQgbGVuID1cbiAgICBtYXRjaCBsZW4gd2l0aCBTb21lIGxlbiAtPiBsZW4gfCBOb25lIC0+IFN0cmluZy5sZW5ndGggaW5wdXQgLSBvZmYgaW5cblxuICBpZiBsZW4gPCAwIHx8IG9mZiA8IDAgfHwgb2ZmID4gU3RyaW5nLmxlbmd0aCBpbnB1dCAtIGxlblxuICB0aGVuIGVycm9yX21zZ2YgXCJJbnZhbGlkIGJvdW5kc1wiXG4gIGVsc2VcbiAgICBsZXQgbiA9IGxlbiBpblxuICAgIGxldCBuJyA9IG4gLy8gMyAqIDQgaW5cbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIG4nIGluXG5cbiAgICBsZXQgZW1hcCBpID0gQXJyYXkudW5zYWZlX2dldCBlbWFwIGkgaW5cblxuICAgIGxldCBlbWl0IGIxIGIyIGIzIGkgPVxuICAgICAgdW5zYWZlX3NldF9iZV91aW50MTYgcmVzIGlcbiAgICAgICAgKChlbWFwICgoYjEgbHNyIDIpIGxhbmQgMHgzZikgbHNsIDgpXG4gICAgICAgIGxvciBlbWFwICgoYjEgbHNsIDQpIGxvciAoYjIgbHNyIDQpIGxhbmQgMHgzZikpIDtcbiAgICAgIHVuc2FmZV9zZXRfYmVfdWludDE2IHJlcyAoaSArIDIpXG4gICAgICAgICgoZW1hcCAoKGIyIGxzbCAyKSBsb3IgKGIzIGxzciA2KSBsYW5kIDB4M2YpIGxzbCA4KVxuICAgICAgICBsb3IgZW1hcCAoYjMgbGFuZCAweDNmKSkgaW5cblxuICAgIGxldCByZWMgZW5jIGogaSA9XG4gICAgICBpZiBpID0gblxuICAgICAgdGhlbiAoKVxuICAgICAgZWxzZSBpZiBpID0gbiAtIDFcbiAgICAgIHRoZW4gZW1pdCAodW5zYWZlX2dldF91aW50OCBpbnB1dCAob2ZmICsgaSkpIDAgMCBqXG4gICAgICBlbHNlIGlmIGkgPSBuIC0gMlxuICAgICAgdGhlblxuICAgICAgICBlbWl0XG4gICAgICAgICAgKHVuc2FmZV9nZXRfdWludDggaW5wdXQgKG9mZiArIGkpKVxuICAgICAgICAgICh1bnNhZmVfZ2V0X3VpbnQ4IGlucHV0IChvZmYgKyBpICsgMSkpXG4gICAgICAgICAgMCBqXG4gICAgICBlbHNlIChcbiAgICAgICAgZW1pdFxuICAgICAgICAgICh1bnNhZmVfZ2V0X3VpbnQ4IGlucHV0IChvZmYgKyBpKSlcbiAgICAgICAgICAodW5zYWZlX2dldF91aW50OCBpbnB1dCAob2ZmICsgaSArIDEpKVxuICAgICAgICAgICh1bnNhZmVfZ2V0X3VpbnQ4IGlucHV0IChvZmYgKyBpICsgMikpXG4gICAgICAgICAgaiA7XG4gICAgICAgIGVuYyAoaiArIDQpIChpICsgMykpIGluXG5cbiAgICBsZXQgcmVjIHVuc2FmZV9maXggPSBmdW5jdGlvblxuICAgICAgfCAwIC0+ICgpXG4gICAgICB8IGkgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0X3VpbnQ4IHJlcyAobicgLSBpKSBwYWRkaW5nIDtcbiAgICAgICAgICB1bnNhZmVfZml4IChpIC0gMSkgaW5cblxuICAgIGVuYyAwIDAgO1xuXG4gICAgbGV0IHBhZF90b193cml0ZSA9ICgzIC0gKG4gbW9kIDMpKSBtb2QgMyBpblxuXG4gICAgaWYgcGFkXG4gICAgdGhlbiAoXG4gICAgICB1bnNhZmVfZml4IHBhZF90b193cml0ZSA7XG4gICAgICBPayAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXMsIDAsIG4nKSlcbiAgICBlbHNlIE9rIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlcywgMCwgbicgLSBwYWRfdG9fd3JpdGUpXG5cbigqIFtwYWQgPSBmYWxzZV0sIHdlIGRvbid0IHdhbnQgdG8gd3JpdGUgdGhlbS4gKilcblxubGV0IGVuY29kZSA/KHBhZCA9IHRydWUpID8oYWxwaGFiZXQgPSBkZWZhdWx0X2FscGhhYmV0KSA/b2ZmID9sZW4gaW5wdXQgPVxuICBtYXRjaCBlbmNvZGVfc3ViIHBhZCBhbHBoYWJldCA/b2ZmID9sZW4gaW5wdXQgd2l0aFxuICB8IE9rIChyZXMsIG9mZiwgbGVuKSAtPiBPayAoU3RyaW5nLnN1YiByZXMgb2ZmIGxlbilcbiAgfCBFcnJvciBfIGFzIGVyciAtPiBlcnJcblxubGV0IGVuY29kZV9zdHJpbmcgP3BhZCA/YWxwaGFiZXQgaW5wdXQgPVxuICBtYXRjaCBlbmNvZGUgP3BhZCA/YWxwaGFiZXQgaW5wdXQgd2l0aFxuICB8IE9rIHJlcyAtPiByZXNcbiAgfCBFcnJvciBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgZW5jb2RlX3N1YiA/KHBhZCA9IHRydWUpID8oYWxwaGFiZXQgPSBkZWZhdWx0X2FscGhhYmV0KSA/b2ZmID9sZW4gaW5wdXQgPVxuICBlbmNvZGVfc3ViIHBhZCBhbHBoYWJldCA/b2ZmID9sZW4gaW5wdXRcblxubGV0IGVuY29kZV9leG4gP3BhZCA/YWxwaGFiZXQgP29mZiA/bGVuIGlucHV0ID1cbiAgbWF0Y2ggZW5jb2RlID9wYWQgP2FscGhhYmV0ID9vZmYgP2xlbiBpbnB1dCB3aXRoXG4gIHwgT2sgdiAtPiB2XG4gIHwgRXJyb3IgKGBNc2cgZXJyKSAtPiBpbnZhbGlkX2FyZyBlcnJcblxubGV0IGRlY29kZV9zdWIgPyhwYWQgPSB0cnVlKSB7IGRtYXA7IF8gfSA/KG9mZiA9IDApID9sZW4gaW5wdXQgPVxuICBsZXQgbGVuID1cbiAgICBtYXRjaCBsZW4gd2l0aCBTb21lIGxlbiAtPiBsZW4gfCBOb25lIC0+IFN0cmluZy5sZW5ndGggaW5wdXQgLSBvZmYgaW5cblxuICBpZiBsZW4gPCAwIHx8IG9mZiA8IDAgfHwgb2ZmID4gU3RyaW5nLmxlbmd0aCBpbnB1dCAtIGxlblxuICB0aGVuIGVycm9yX21zZ2YgXCJJbnZhbGlkIGJvdW5kc1wiXG4gIGVsc2VcbiAgICBsZXQgbiA9IGxlbiAvLyA0ICogNCBpblxuICAgIGxldCBuJyA9IG4gLy8gNCAqIDMgaW5cbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIG4nIGluXG4gICAgbGV0IGludmFsaWRfcGFkX292ZXJmbG93ID0gcGFkIGluXG5cbiAgICBsZXQgZ2V0X3VpbnQ4X29yX3BhZGRpbmcgPVxuICAgICAgaWYgcGFkXG4gICAgICB0aGVuIChmdW4gdCBpIC0+XG4gICAgICAgIGlmIGkgPj0gbGVuIHRoZW4gcmFpc2UgT3V0X29mX2JvdW5kcyA7XG4gICAgICAgIGdldF91aW50OCB0IChvZmYgKyBpKSlcbiAgICAgIGVsc2VcbiAgICAgICAgZnVuIHQgaSAtPlxuICAgICAgICB0cnkgaWYgaSA8IGxlbiB0aGVuIGdldF91aW50OCB0IChvZmYgKyBpKSBlbHNlIHBhZGRpbmdcbiAgICAgICAgd2l0aCBPdXRfb2ZfYm91bmRzIC0+IHBhZGRpbmcgaW5cblxuICAgIGxldCBzZXRfYmVfdWludDE2IHQgb2ZmIHYgPVxuICAgICAgKCogY2FuIG5vdCB3cml0ZSAyIGJ5dGVzLiAqKVxuICAgICAgaWYgb2ZmIDwgMCB8fCBvZmYgKyAxID4gQnl0ZXMubGVuZ3RoIHRcbiAgICAgIHRoZW4gKCkgKCogY2FuIG5vdCB3cml0ZSAxIGJ5dGUgYnV0IGNhbiB3cml0ZSAxIGJ5dGUgKilcbiAgICAgIGVsc2UgaWYgb2ZmIDwgMCB8fCBvZmYgKyAyID4gQnl0ZXMubGVuZ3RoIHRcbiAgICAgIHRoZW4gdW5zYWZlX3NldF91aW50OCB0IG9mZiAodiBsc3IgOCkgKCogY2FuIHdyaXRlIDIgYnl0ZXMuICopXG4gICAgICBlbHNlIHVuc2FmZV9zZXRfYmVfdWludDE2IHQgb2ZmIHYgaW5cblxuICAgIGxldCBzZXRfdWludDggdCBvZmYgdiA9XG4gICAgICBpZiBvZmYgPCAwIHx8IG9mZiA+PSBCeXRlcy5sZW5ndGggdCB0aGVuICgpIGVsc2UgdW5zYWZlX3NldF91aW50OCB0IG9mZiB2XG4gICAgaW5cblxuICAgIGxldCBlbWl0IGEgYiBjIGQgaiA9XG4gICAgICBsZXQgeCA9IChhIGxzbCAxOCkgbG9yIChiIGxzbCAxMikgbG9yIChjIGxzbCA2KSBsb3IgZCBpblxuICAgICAgc2V0X2JlX3VpbnQxNiByZXMgaiAoeCBsc3IgOCkgO1xuICAgICAgc2V0X3VpbnQ4IHJlcyAoaiArIDIpICh4IGxhbmQgMHhmZikgaW5cblxuICAgIGxldCBkbWFwIGkgPVxuICAgICAgbGV0IHggPSBBcnJheS51bnNhZmVfZ2V0IGRtYXAgaSBpblxuICAgICAgaWYgeCA9IG5vbmUgdGhlbiByYWlzZSBOb3RfZm91bmQgO1xuICAgICAgeCBpblxuXG4gICAgbGV0IG9ubHlfcGFkZGluZyBwYWQgaWR4ID1cbiAgICAgICgqIGJlY2F1c2Ugd2Ugcm91bmQgbGVuZ3RoIG9mIFtyZXNdIHRvIHRoZSB1cHBlciBib3VuZCBvZiBob3cgbWFueVxuICAgICAgICAgY2hhcmFjdGVycyB3ZSBzaG91bGQgaGF2ZSBmcm9tIFtpbnB1dF0sIHdlIGdvdCBhdCB0aGlzIHN0YWdlIG9ubHkgcGFkZGluZ1xuICAgICAgICAgY2hhcmFjdGVycyBhbmQgd2UgbmVlZCB0byBkZWxldGUgdGhlbSwgc28gZm9yIGVhY2ggWz09PT1dLCB3ZSBkZWxldGUgM1xuICAgICAgICAgYnl0ZXMuICopXG4gICAgICBsZXQgcGFkID0gcmVmIChwYWQgKyAzKSBpblxuICAgICAgbGV0IGlkeCA9IHJlZiBpZHggaW5cblxuICAgICAgd2hpbGUgIWlkeCArIDQgPCBsZW4gZG9cbiAgICAgICAgKCogdXNlIFt1bnNhZmVfZ2V0X3VpbnQxNl0gaW5zdGVhZCBbdW5zYWZlX2dldF91aW50MzJdIHRvIGF2b2lkIGFsbG9jYXRpb25cbiAgICAgICAgICAgb2YgW2ludDMyXS4gT2YgY291cnNlLCBbM2QzZDNkM2RdIGlzIFs9PT09XS4gKilcbiAgICAgICAgaWYgdW5zYWZlX2dldF91aW50MTYgaW5wdXQgKG9mZiArICFpZHgpIDw+IDB4M2QzZFxuICAgICAgICAgICB8fCB1bnNhZmVfZ2V0X3VpbnQxNiBpbnB1dCAob2ZmICsgIWlkeCArIDIpIDw+IDB4M2QzZFxuICAgICAgICB0aGVuIHJhaXNlIE5vdF9mb3VuZCA7XG5cbiAgICAgICAgKCogV2UgZ290IHNvbWV0aGluZyBiYWQsIHNob3VsZCBiZSBhIHZhbGlkIGNoYXJhY3RlciBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgW2FscGhhYmV0XSBidXQgb3V0c2lkZSB0aGUgc2NvcGUuICopXG4gICAgICAgIGlkeCA6PSAhaWR4ICsgNCA7XG4gICAgICAgIHBhZCA6PSAhcGFkICsgM1xuICAgICAgZG9uZSA7XG4gICAgICB3aGlsZSAhaWR4IDwgbGVuIGRvXG4gICAgICAgIGlmIHVuc2FmZV9nZXRfdWludDggaW5wdXQgKG9mZiArICFpZHgpIDw+IHBhZGRpbmcgdGhlbiByYWlzZSBOb3RfZm91bmQgO1xuXG4gICAgICAgIGluY3IgaWR4XG4gICAgICBkb25lIDtcbiAgICAgICFwYWQgaW5cblxuICAgIGxldCByZWMgZGVjIGogaSA9XG4gICAgICBpZiBpID0gblxuICAgICAgdGhlbiAwXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBkLCBwYWQgPVxuICAgICAgICAgIGxldCB4ID0gZ2V0X3VpbnQ4X29yX3BhZGRpbmcgaW5wdXQgKGkgKyAzKSBpblxuICAgICAgICAgIHRyeSAoZG1hcCB4LCAwKSB3aXRoIE5vdF9mb3VuZCB3aGVuIHggPSBwYWRkaW5nIC0+ICgwLCAxKSBpblxuICAgICAgICAoKiBbTm90X2ZvdW5kXSBpZmYgW3gg4oiJIGFscGhhYmV0IGFuZCB4IDw+ICc9J10gY2FuIGxlYWsuICopXG4gICAgICAgIGxldCBjLCBwYWQgPVxuICAgICAgICAgIGxldCB4ID0gZ2V0X3VpbnQ4X29yX3BhZGRpbmcgaW5wdXQgKGkgKyAyKSBpblxuICAgICAgICAgIHRyeSAoZG1hcCB4LCBwYWQpXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgd2hlbiB4ID0gcGFkZGluZyAmJiBwYWQgPSAxIC0+ICgwLCAyKSBpblxuICAgICAgICAoKiBbTm90X2ZvdW5kXSBpZmYgW3gg4oiJIGFscGhhYmV0IGFuZCB4IDw+ICc9J10gY2FuIGxlYWsuICopXG4gICAgICAgIGxldCBiLCBwYWQgPVxuICAgICAgICAgIGxldCB4ID0gZ2V0X3VpbnQ4X29yX3BhZGRpbmcgaW5wdXQgKGkgKyAxKSBpblxuICAgICAgICAgIHRyeSAoZG1hcCB4LCBwYWQpXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgd2hlbiB4ID0gcGFkZGluZyAmJiBwYWQgPSAyIC0+ICgwLCAzKSBpblxuICAgICAgICAoKiBbTm90X2ZvdW5kXSBpZmYgW3gg4oiJIGFscGhhYmV0IGFuZCB4IDw+ICc9J10gY2FuIGxlYWsuICopXG4gICAgICAgIGxldCBhLCBwYWQgPVxuICAgICAgICAgIGxldCB4ID0gZ2V0X3VpbnQ4X29yX3BhZGRpbmcgaW5wdXQgaSBpblxuICAgICAgICAgIHRyeSAoZG1hcCB4LCBwYWQpXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgd2hlbiB4ID0gcGFkZGluZyAmJiBwYWQgPSAzIC0+ICgwLCA0KSBpblxuXG4gICAgICAgICgqIFtOb3RfZm91bmRdIGlmZiBbeCDiiIkgYWxwaGFiZXQgYW5kIHggPD4gJz0nXSBjYW4gbGVhay4gKilcbiAgICAgICAgZW1pdCBhIGIgYyBkIGogO1xuXG4gICAgICAgIGlmIGkgKyA0ID0gbiAoKiBlbmQgb2YgaW5wdXQgaW4gYW55d2F5ICopXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgICAgIHwgMCAtPiAwXG4gICAgICAgICAgfCA0IC0+XG4gICAgICAgICAgICAgICgqIGFzc2VydCAoaW52YWxpZF9wYWRfb3ZlcmZsb3cgPSBmYWxzZSkgOyAqKVxuICAgICAgICAgICAgICAzXG4gICAgICAgICAgKCogW2dldF91aW50OF0gbGllcyBhbmQgaWYgd2UgZ2V0IFs0XSwgdGhhdCBtZWFuIHdlIGdvdCBvbmUgb3IgbW9yZSAoYXRcbiAgICAgICAgICAgICBtb3N0IDQpIHBhZGRpbmcgY2hhcmFjdGVyLiBJbiB0aGlzIHNpdHVhdGlvbiwgYmVjYXVzZSB3ZSByb3VuZCBsZW5ndGhcbiAgICAgICAgICAgICBvZiBbcmVzXSAoc2VlIFtuIC8vIDRdKSwgd2UgbmVlZCB0byBkZWxldGUgMyBieXRlcy4gKilcbiAgICAgICAgICB8IHBhZCAtPiBwYWRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICAgICAgfCAwIC0+IGRlYyAoaiArIDMpIChpICsgNClcbiAgICAgICAgICB8IDQgLT5cbiAgICAgICAgICAgICAgKCogYXNzZXJ0IChpbnZhbGlkX3BhZF9vdmVyZmxvdyA9IGZhbHNlKSA7ICopXG4gICAgICAgICAgICAgIG9ubHlfcGFkZGluZyAzIChpICsgNClcbiAgICAgICAgICAoKiBTYW1lIHNpdHVhdGlvbiB0aGFuIGFib3ZlIGJ1dCB3ZSBzaG91bGQgZ2V0IG9ubHkgbW9yZSBwYWRkaW5nXG4gICAgICAgICAgICAgY2hhcmFjdGVycyB0aGVuLiAqKVxuICAgICAgICAgIHwgcGFkIC0+XG4gICAgICAgICAgICAgIGlmIGludmFsaWRfcGFkX292ZXJmbG93ID0gdHJ1ZSB0aGVuIHJhaXNlIFRvb19tdWNoX2lucHV0IDtcbiAgICAgICAgICAgICAgb25seV9wYWRkaW5nIHBhZCAoaSArIDQpIGluXG5cbiAgICBtYXRjaCBkZWMgMCAwIHdpdGhcbiAgICB8IDAgLT4gT2sgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzLCAwLCBuJylcbiAgICB8IHBhZCAtPiBPayAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXMsIDAsIG4nIC0gcGFkKVxuICAgIHwgZXhjZXB0aW9uIE91dF9vZl9ib3VuZHMgLT5cbiAgICAgICAgZXJyb3JfbXNnZiBcIldyb25nIHBhZGRpbmdcIlxuICAgICAgICAoKiBhcHBlYXIgb25seSB3aGVuIFtwYWQgPSB0cnVlXSBhbmQgd2hlbiBsZW5ndGggb2YgaW5wdXQgaXMgbm90IGEgbXVsdGlwbGUgb2YgNC4gKilcbiAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgICAgKCogYXBwZWFyIHdoZW4gb25lIGNoYXJhY3RlciBvZiBbaW5wdXRdIOKIiSBbYWxwaGFiZXRdIGFuZCB0aGlzIGNoYXJhY3RlciA8PiAnPScgKilcbiAgICAgICAgZXJyb3JfbXNnZiBcIk1hbGZvcm1lZCBpbnB1dFwiXG4gICAgfCBleGNlcHRpb24gVG9vX211Y2hfaW5wdXQgLT4gZXJyb3JfbXNnZiBcIlRvbyBtdWNoIGlucHV0XCJcblxubGV0IGRlY29kZSA/cGFkID8oYWxwaGFiZXQgPSBkZWZhdWx0X2FscGhhYmV0KSA/b2ZmID9sZW4gaW5wdXQgPVxuICBtYXRjaCBkZWNvZGVfc3ViID9wYWQgYWxwaGFiZXQgP29mZiA/bGVuIGlucHV0IHdpdGhcbiAgfCBPayAocmVzLCBvZmYsIGxlbikgLT4gT2sgKFN0cmluZy5zdWIgcmVzIG9mZiBsZW4pXG4gIHwgRXJyb3IgXyBhcyBlcnIgLT4gZXJyXG5cbmxldCBkZWNvZGVfc3ViID9wYWQgPyhhbHBoYWJldCA9IGRlZmF1bHRfYWxwaGFiZXQpID9vZmYgP2xlbiBpbnB1dCA9XG4gIGRlY29kZV9zdWIgP3BhZCBhbHBoYWJldCA/b2ZmID9sZW4gaW5wdXRcblxubGV0IGRlY29kZV9leG4gP3BhZCA/YWxwaGFiZXQgP29mZiA/bGVuIGlucHV0ID1cbiAgbWF0Y2ggZGVjb2RlID9wYWQgP2FscGhhYmV0ID9vZmYgP2xlbiBpbnB1dCB3aXRoXG4gIHwgT2sgcmVzIC0+IHJlc1xuICB8IEVycm9yIChgTXNnIGVycikgLT4gaW52YWxpZF9hcmcgZXJyXG4iXX0=
