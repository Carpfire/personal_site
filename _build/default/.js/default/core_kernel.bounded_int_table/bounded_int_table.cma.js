// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Bounded_int_table
//# unitInfo: Requires: Bin_prot__Common, Bin_prot__Shape, Bin_shape, Core, Core__Array, Core__Binable, Core__Int, Core__List, Core__Or_error, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_conv_record
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Bounded_int_table$0 = "Bounded_int_table",
    cst = "_",
    cst_alist$1 = "alist",
    cst_bounded_int_table$0 = "bounded_int_table",
    cst_bounded_int_table_src_boun$5 =
      "bounded_int_table/src/bounded_int_table.ml",
    cst_bounded_int_table_src_boun$6 =
      "bounded_int_table/src/bounded_int_table.ml.Serialized.t",
    cst_data$3 = "data",
    cst_key$1 = "key",
    cst_num_keys$1 = "num_keys",
    cst_t$3 = "t",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_032 = cst_bounded_int_table_src_boun$6,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Core_List = global_data.Core__List,
    Core_Or_error = global_data.Core__Or_error,
    Core_Int = global_data.Core__Int,
    Core_Binable = global_data.Core__Binable,
    Core = global_data.Core,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Bin_prot_Common = global_data.Bin_prot__Common,
    Assert_failure = global_data.Assert_failure,
    Core_Array = global_data.Core__Array,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Bounded_int_table$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_bounded_int_table$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_bounded_int_table_src_boun$5);
   caml_call2
    (Ppx_inline_test_lib[6], cst_bounded_int_table$0, "bounded_int_table.ml");
   var
    cst_t$2 = cst_t$3,
    cst_data$1 = cst_data$3,
    cst_bounded_int_table_src_boun$3 =
      "bounded_int_table/src/bounded_int_table.ml:320:31",
    cst_data$2 = cst_data$3,
    cst_t$1 = cst_t$3,
    cst_bounded_int_table_src_boun$4 =
      "bounded_int_table/src/bounded_int_table.ml:320:8",
    _S_ = [0, cst],
    cst_Bounded_int_table_remove_b = "Bounded_int_table.remove bug",
    _T_ = [0, cst_bounded_int_table_src_boun$5, 253, 7014, 7031],
    cst_Bounded_int_table_add_exn_ =
      "Bounded_int_table.add_exn of key whose index is already present",
    _R_ = [0, cst_bounded_int_table_src_boun$5, 233, 6465, 6477],
    _P_ = [0, cst],
    cst_Bounded_int_table_find_exn =
      "Bounded_int_table.find_exn got unknown key",
    _Q_ = [0, cst_bounded_int_table_src_boun$5, 184, 5252, 5264],
    _N_ = [0, "Should_be_between_0_and"],
    cst_key_s_index_out_of_range = "key's index out of range",
    _O_ = [0, cst_bounded_int_table_src_boun$5, 166, 4816, 4828],
    _L_ = [0, cst_alist$1],
    _M_ = [0, cst_num_keys$1],
    cst_alist$0 = cst_alist$1,
    cst_num_keys$0 = cst_num_keys$1,
    cst_bounded_int_table_src_boun$2 = cst_bounded_int_table_src_boun$6,
    cst_t$0 = cst_t$3,
    _x_ = [0, cst_bounded_int_table_src_boun$5, 135, 14],
    _w_ = [0, cst_bounded_int_table_src_boun$5, 120, 16],
    cst_num_keys_must_be_nonnegati = "num_keys must be nonnegative",
    _v_ = [0, cst_bounded_int_table_src_boun$5, 88, 2872, 2895],
    _j_ = [0, cst],
    _o_ = [0, cst_bounded_int_table_src_boun$5, 60, 28],
    _p_ = [0, cst_bounded_int_table_src_boun$5, 61, 13],
    _n_ = [0, cst_bounded_int_table_src_boun$5, 53, 8],
    _l_ = [0, cst_bounded_int_table_src_boun$5, 56, 26],
    _m_ = [0, cst_bounded_int_table_src_boun$5, 55, 19],
    _u_ = [0, cst_bounded_int_table_src_boun$5, 45, 4],
    _t_ = [0, cst_bounded_int_table_src_boun$5, 46, 4],
    _s_ = [0, cst_bounded_int_table_src_boun$5, 47, 4],
    _r_ = [0, cst_bounded_int_table_src_boun$5, 70, 4],
    _q_ = [0, cst_bounded_int_table_src_boun$5, 71, 4],
    cst_invariant_failed = "invariant failed",
    _k_ = [0, cst_bounded_int_table_src_boun$5, 76, 2577, 2589],
    _d_ = [0, "defined_entries"],
    _e_ = [0, "entries_by_key"],
    _f_ = [0, "length"],
    _g_ = [0, "key_to_int"],
    _h_ = [0, "sexp_of_key"],
    _i_ = [0, cst_num_keys$1],
    _a_ = [0, "defined_entries_index"],
    _b_ = [0, cst_data$3],
    _c_ = [0, cst_key$1],
    cst_data = cst_data$3,
    cst_bounded_int_table_src_boun =
      "bounded_int_table/src/bounded_int_table.ml:146:22",
    cst_key = cst_key$1,
    cst_bounded_int_table_src_boun$0 =
      "bounded_int_table/src/bounded_int_table.ml:146:15",
    cst_alist = cst_alist$1,
    cst_num_keys = cst_num_keys$1,
    cst_data$0 = cst_data$3,
    cst_key$0 = cst_key$1,
    cst_t = cst_t$3,
    cst_bounded_int_table_src_boun$1 =
      "bounded_int_table/src/bounded_int_table.ml:144:2",
    cst_bounded_int_table = cst_bounded_int_table$0,
    cst_Bounded_int_table = cst_Bounded_int_table$0;
   function sexp_of_t(of_key_001, of_data_002, param){
    var
     key_004 = param[1],
     data_006 = param[2],
     defined_entries_index_008 = param[3],
     arg_009 = caml_call1(Core[389], defined_entries_index_008),
     bnds_003 = [0, [1, [0, _a_, [0, arg_009, 0]]], 0],
     arg_007 = caml_call1(of_data_002, data_006),
     bnds_003$0 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_003],
     arg_005 = caml_call1(of_key_001, key_004),
     bnds_003$1 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_003$0];
    return [1, bnds_003$1];
   }
   function length(r){return r[4];}
   function num_keys(r){return r[1];}
   function sexp_of_t_detailed(of_key_010, of_data_011, param){
    var
     sexp_of_key_015 = param[2],
     num_keys_013 = param[1],
     length_019 = param[4],
     defined_entries_023 = param[6],
     entries_by_key_021 = param[5],
     bnds_012 = 0;
    function _be_(_bo_){return sexp_of_t(of_key_010, of_data_011, _bo_);}
    var
     _bf_ = caml_call1(Core[515], _be_),
     arg_024 = caml_call2(Core[301], _bf_, defined_entries_023),
     bnds_012$0 = [0, [1, [0, _d_, [0, arg_024, 0]]], bnds_012];
    function _bg_(_bn_){return sexp_of_t(of_key_010, of_data_011, _bn_);}
    var
     _bh_ = caml_call1(Core[515], _bg_),
     arg_022 = caml_call2(Core[301], _bh_, entries_by_key_021),
     bnds_012$1 = [0, [1, [0, _e_, [0, arg_022, 0]]], bnds_012$0],
     arg_020 = caml_call1(Core[389], length_019),
     bnds_012$2 = [0, [1, [0, _f_, [0, arg_020, 0]]], bnds_012$1];
    function _bi_(_bm_){return 0;}
    var
     arg_018 = caml_call1(Sexplib0_Sexp_conv[24], _bi_),
     bnds_012$3 = [0, [1, [0, _g_, [0, arg_018, 0]]], bnds_012$2];
    function _bj_(param){
     function _bk_(_bl_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _bk_);
    }
    var
     arg_016 = caml_call2(Core[515], _bj_, sexp_of_key_015),
     bnds_012$4 = [0, [1, [0, _h_, [0, arg_016, 0]]], bnds_012$3],
     arg_014 = caml_call1(Core[389], num_keys_013),
     bnds_012$5 = [0, [1, [0, _i_, [0, arg_014, 0]]], bnds_012$4];
    return [1, bnds_012$5];
   }
   function sexp_of_key(t){
    var match = t[2];
    if(! match)
     return function(key){
      var _bd_ = caml_call1(t[3], key);
      return caml_call1(Core_Int[77], _bd_);};
    var f = match[1];
    return f;
   }
   function invariant(invariant_key, invariant_data, t){
    try{
     var num_keys = t[1];
     if(! caml_call2(Core[90], num_keys, t[5].length - 1))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
     if(! caml_call2(Core[90], num_keys, t[6].length - 1))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
     if(caml_call2(Core[89], 0, t[4]) && caml_call2(Core[89], t[4], num_keys)){
      var
       _a4_ =
         function(i, param){
          if(! param) return 0;
          var entry = param[1];
          caml_call1(invariant_key, entry[1]);
          caml_call1(invariant_data, entry[2]);
          var _bb_ = caml_call1(t[3], entry[1]);
          if(! caml_call2(Core[90], i, _bb_))
           throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
          var _bc_ = entry[3], match = caml_check_bound(t[6], _bc_)[1 + _bc_];
          if(! match)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
          var entry$0 = match[1];
          if(entry === entry$0) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
         };
      caml_call2(Core_Array[50], t[5], _a4_);
      var
       _a5_ =
         function(i, entry_opt){
          if(caml_call2(Core[92], i, t[4])){
           if(entry_opt){
            var entry = entry_opt[1];
            if(caml_call2(Core[90], i, entry[3])) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
           }
          }
          else if(! entry_opt) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
         };
      caml_call2(Core_Array[50], t[6], _a5_);
      var
       get_entries =
         function(array){
          var a = caml_call1(Core_Array[90], array);
          function _a__(entry$0, entry){
           var
            _a$_ = caml_call1(t[3], entry[1]),
            _ba_ = caml_call1(t[3], entry$0[1]);
           return caml_call2(Core_Int[88], _ba_, _a$_);
          }
          caml_call4(Core_Array[81], 0, 0, a, _a__);
          return a;
         },
       entries = get_entries(t[5]),
       entries$0 = get_entries(t[6]);
      if(! caml_call2(Core[90], t[4], entries.length - 1))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
      var _a6_ = function(_a9_, _a8_){return _a9_ === _a8_ ? 1 : 0;};
      if(! caml_call3(Core_Array[120], _a6_, entries, entries$0))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
      var _a7_ = 0;
      return _a7_;
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      sexp_of_key$0 = sexp_of_key(t),
      _a3_ =
        function(param){
         var
          arg1_026 = param[2],
          arg0_025 = param[1],
          res0_027 = caml_call1(Core[625], arg0_025),
          res1_028 =
            sexp_of_t_detailed
             (sexp_of_key$0, function(param){return _j_;}, arg1_026);
         return [1, [0, res0_027, [0, res1_028, 0]]];
        };
     return caml_call5
             (Core[247], 0, _k_, cst_invariant_failed, [0, exn, t], _a3_);
    }
   }
   var debug = [0, 0];
   function check_invariant(t){
    var _aZ_ = debug[1];
    if(! _aZ_) return _aZ_;
    function _a0_(_a2_){return 0;}
    return invariant(function(_a1_){return 0;}, _a0_, t);
   }
   function is_empty(t){return caml_call2(Core[90], t[4], 0);}
   function create(sexp_of_key, num_keys, key_to_int, param){
    if(caml_call2(Core[92], num_keys, 0))
     caml_call5
      (Core[247], 0, _v_, cst_num_keys_must_be_nonnegati, num_keys, Core[389]);
    var
     _aY_ = caml_call2(Core_Array[63], num_keys, 0),
     t =
       [0,
        num_keys,
        sexp_of_key,
        key_to_int,
        0,
        caml_call2(Core_Array[63], num_keys, 0),
        _aY_];
    check_invariant(t);
    return t;
   }
   function fold(t, init, f){
    var i = 0, ac = init;
    for(;;){
     if(caml_call2(Core[90], i, t[4])) return ac;
     var match = caml_check_bound(t[6], i)[1 + i];
     if(! match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
     var
      entry = match[1],
      ac$0 = caml_call3(f, entry[1], entry[2], ac),
      i$0 = i + 1 | 0,
      i = i$0,
      ac = ac$0;
    }
   }
   function iteri(t, f){
    return fold
            (t,
             0,
             function(key, data, param){return caml_call2(f, key, data);});
   }
   function iter(t, f){
    return iteri(t, function(param, data){return caml_call1(f, data);});
   }
   function iter_keys(t, f){
    return iteri(t, function(key, param){return caml_call1(f, key);});
   }
   function map_entries(t, f){
    return fold
            (t,
             0,
             function(key, data, ac){
              return [0, caml_call2(f, key, data), ac];
             });
   }
   function to_alist(t){
    return map_entries(t, function(key, data){return [0, key, data];});
   }
   function clear(t){
    var _aV_ = t[4] - 1 | 0, _aU_ = 0;
    if(_aV_ >= 0){
     var i = _aU_;
     for(;;){
      var match = caml_check_bound(t[6], i)[1 + i];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
      var entry = match[1];
      caml_check_bound(t[6], i)[1 + i] = 0;
      var _aW_ = caml_call1(t[3], entry[1]);
      caml_check_bound(t[5], _aW_)[1 + _aW_] = 0;
      var _aX_ = i + 1 | 0;
      if(_aV_ === i) break;
      var i = _aX_;
     }
    }
    t[4] = 0;
    return 0;
   }
   var
    _y_ = caml_call1(Bin_shape[3][1], cst_data),
    _z_ = caml_call1(Bin_shape[4][1], cst_bounded_int_table_src_boun),
    _A_ = [0, caml_call2(Bin_prot_Shape[11], _z_, _y_), 0],
    _B_ = caml_call1(Bin_shape[3][1], cst_key),
    _C_ = caml_call1(Bin_shape[4][1], cst_bounded_int_table_src_boun$0),
    _D_ = [0, caml_call2(Bin_prot_Shape[11], _C_, _B_), _A_],
    _E_ = caml_call1(Bin_prot_Shape[3], _D_),
    _F_ = [0, [0, cst_alist, caml_call1(Core[456], _E_)], 0],
    _G_ =
      caml_call1(Bin_prot_Shape[4], [0, [0, cst_num_keys, Core[372]], _F_]),
    _H_ = [0, caml_call1(Bin_shape[3][1], cst_data$0), 0],
    _I_ = [0, caml_call1(Bin_shape[3][1], cst_key$0), _H_],
    _J_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), _I_, _G_], 0],
    _K_ = caml_call1(Bin_shape[4][1], cst_bounded_int_table_src_boun$1),
    group = caml_call2(Bin_prot_Shape[2], _K_, _J_);
   function to_serialized(t){var _aT_ = to_alist(t); return [0, t[1], _aT_];}
   function sexp_of_t$0(sexp_of_key, sexp_of_data, t){
    var
     param = to_serialized(t),
     alist_044 = param[2],
     num_keys_042 = param[1],
     bnds_041 = 0;
    function _aS_(param){
     var
      arg1_047 = param[2],
      arg0_046 = param[1],
      res0_048 = caml_call1(sexp_of_key, arg0_046),
      res1_049 = caml_call1(sexp_of_data, arg1_047);
     return [1, [0, res0_048, [0, res1_049, 0]]];
    }
    var
     arg_045 = caml_call2(Core[472], _aS_, alist_044),
     bnds_041$0 = [0, [1, [0, _L_, [0, arg_045, 0]]], bnds_041],
     arg_043 = caml_call1(Core[389], num_keys_042),
     bnds_041$1 = [0, [1, [0, _M_, [0, arg_043, 0]]], bnds_041$0];
    return [1, bnds_041$1];
   }
   function keys(t){return map_entries(t, function(key, param){return key;});}
   function data(t){
    return map_entries(t, function(param, data){return data;});
   }
   function entry_opt(t, key){
    var index = caml_call1(t[3], key);
    try{var _aQ_ = caml_check_bound(t[5], index)[1 + index]; return _aQ_;}
    catch(_aR_){
     var
      sexp_of_key$0 = sexp_of_key(t),
      _aP_ =
        function(param){
         var
          arg2_053 = param[3],
          arg1_052 = param[2],
          arg0_051 = param[1],
          res0_054 = caml_call1(sexp_of_key$0, arg0_051),
          res1_055 = caml_call1(Core[389], arg1_052),
          v_050 = arg2_053[2],
          res2_056 = [1, [0, _N_, [0, caml_call1(Core[389], v_050), 0]]];
         return [1, [0, res0_054, [0, res1_055, [0, res2_056, 0]]]];
        };
     return caml_call5
             (Core[247],
              0,
              _O_,
              cst_key_s_index_out_of_range,
              [0, key, index, [0, -958795519, t[1] - 1 | 0]],
              _aP_);
    }
   }
   function find(t, key){
    var match = entry_opt(t, key);
    if(! match) return 0;
    var e = match[1];
    return [0, e[2]];
   }
   function find_exn(t, key){
    var match = entry_opt(t, key);
    if(match){var entry = match[1]; return entry[2];}
    var sexp_of_key$0 = sexp_of_key(t);
    function _aO_(param){
     var
      arg1_058 = param[2],
      arg0_057 = param[1],
      res0_059 = caml_call1(sexp_of_key$0, arg0_057),
      res1_060 =
        sexp_of_t$0(sexp_of_key$0, function(param){return _P_;}, arg1_058);
     return [1, [0, res0_059, [0, res1_060, 0]]];
    }
    return caml_call5
            (Core[247],
             0,
             _Q_,
             cst_Bounded_int_table_find_exn,
             [0, key, t],
             _aO_);
   }
   function mem(t, key){
    var _aN_ = entry_opt(t, key);
    return caml_call1(Core[253], _aN_);
   }
   function add_assuming_not_there(t, key, data){
    var
     defined_entries_index = t[4],
     entry_opt = [0, [0, key, data, defined_entries_index]],
     _aM_ = caml_call1(t[3], key);
    caml_check_bound(t[5], _aM_)[1 + _aM_] = entry_opt;
    caml_check_bound(t[6], defined_entries_index)[1 + defined_entries_index] = entry_opt;
    t[4] = t[4] + 1 | 0;
    return check_invariant(t);
   }
   function find_or_add(t, key, default$0){
    var match = entry_opt(t, key);
    if(match){var e = match[1]; return e[2];}
    var data = caml_call1(default$0, 0);
    add_assuming_not_there(t, key, data);
    return data;
   }
   function set(t, key, data){
    var match = entry_opt(t, key);
    if(! match) return add_assuming_not_there(t, key, data);
    var entry = match[1];
    entry[1] = key;
    entry[2] = data;
    return 0;
   }
   function add(t, key, data){
    var match = entry_opt(t, key);
    if(match){var entry = match[1]; return [0, -1024851605, entry[2]];}
    add_assuming_not_there(t, key, data);
    return 17724;
   }
   function add_exn(t, key, data){
    if(typeof add(t, key, data) === "number") return 0;
    var sexp_of_key$0 = sexp_of_key(t);
    function _aK_(param){
     var
      arg1_062 = param[2],
      arg0_061 = param[1],
      res0_063 = caml_call1(sexp_of_key$0, arg0_061),
      res1_064 = caml_call1(Core[389], arg1_062);
     return [1, [0, res0_063, [0, res1_064, 0]]];
    }
    var _aL_ = [0, key, caml_call1(t[3], key)];
    return caml_call5
            (Core[247], 0, _R_, cst_Bounded_int_table_add_exn_, _aL_, _aK_);
   }
   function remove(t, key){
    var match = entry_opt(t, key);
    if(match){
     var entry = match[1];
     t[4] = t[4] - 1 | 0;
     var _aI_ = caml_call1(t[3], key);
     caml_check_bound(t[5], _aI_)[1 + _aI_] = 0;
     var hole = entry[3], last = t[4];
     if(caml_call2(Core[92], hole, last)){
      var entry_to_put_in_hole_opt = caml_check_bound(t[6], last)[1 + last];
      if(entry_to_put_in_hole_opt){
       var entry_to_put_in_hole = entry_to_put_in_hole_opt[1];
       caml_check_bound(t[6], hole)[1 + hole] = entry_to_put_in_hole_opt;
       entry_to_put_in_hole[3] = hole;
      }
      else{
       var
        sexp_of_key$0 = sexp_of_key(t),
        _aJ_ =
          function(param){
           var
            arg2_067 = param[3],
            arg1_066 = param[2],
            arg0_065 = param[1],
            res0_068 = caml_call1(sexp_of_key$0, arg0_065),
            res1_069 = caml_call1(Core[389], arg1_066),
            res2_070 =
              sexp_of_t_detailed
               (sexp_of_key$0, function(param){return _S_;}, arg2_067);
           return [1, [0, res0_068, [0, res1_069, [0, res2_070, 0]]]];
          };
       caml_call5
        (Core[247],
         0,
         _T_,
         cst_Bounded_int_table_remove_b,
         [0, key, last, t],
         _aJ_);
      }
     }
     caml_check_bound(t[6], last)[1 + last] = 0;
    }
    return check_invariant(t);
   }
   function existsi(t, f){
    function _aG_(r){
     iteri
      (t,
       function(key, data){
        var _aH_ = caml_call2(f, key, data);
        return _aH_ ? caml_call1(r, 1) : _aH_;
       });
     return 0;
    }
    return caml_call1(Core[268], _aG_);
   }
   function exists(t, f){
    return existsi(t, function(param, data){return caml_call1(f, data);});
   }
   function for_alli(t, f){
    return 1
           -
            existsi
             (t, function(key, data){return 1 - caml_call2(f, key, data);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, data){return caml_call1(f, data);});
   }
   function equal(key_equal, data_equal, t1, t2){
    var _aE_ = caml_call2(Core[90], t1[4], t2[4]);
    return _aE_
            ? for_alli
              (t1,
               function(key, data){
                var match = entry_opt(t2, key);
                if(! match) return 0;
                var
                 entry = match[1],
                 _aF_ = caml_call2(key_equal, key, entry[1]);
                return _aF_ ? caml_call2(data_equal, data, entry[2]) : _aF_;
               })
            : _aE_;
   }
   function filter_mapi(t, f){
    var
     key_to_int = t[3],
     sexp_of_key = t[2],
     num_keys = t[1],
     result = create(sexp_of_key, num_keys, key_to_int, 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(! match) return 0;
       var data$0 = match[1];
       return add_exn(result, key, data$0);
      });
    return result;
   }
   function ignore_key(f, param, data){return caml_call1(f, data);}
   function filter_map(t, f){
    return filter_mapi
            (t, function(_aC_, _aD_){return ignore_key(f, _aC_, _aD_);});
   }
   function filteri(t, f){
    return filter_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : 0;
             });
   }
   function filter(t, f){
    return filteri(t, function(_aA_, _aB_){return ignore_key(f, _aA_, _aB_);});
   }
   function filter_keys(t, f){
    return filteri(t, function(key, _az_){return caml_call1(f, key);});
   }
   function mapi(t, f){
    return filter_mapi
            (t, function(key, data){return [0, caml_call2(f, key, data)];});
   }
   function map(t, f){
    return mapi(t, function(_ax_, _ay_){return ignore_key(f, _ax_, _ay_);});
   }
   caml_call1(Ppx_inline_test_lib[7], cst_bounded_int_table);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Bounded_int_table);
   var
    Bounded_int_table =
      [0,
       sexp_of_t$0,
       invariant,
       equal,
       create,
       num_keys,
       is_empty,
       keys,
       data,
       find,
       find_exn,
       find_or_add,
       fold,
       iter_keys,
       iter,
       iteri,
       filter_mapi,
       filter_map,
       filter_keys,
       filter,
       filteri,
       mapi,
       map,
       for_alli,
       existsi,
       for_all,
       exists,
       length,
       mem,
       remove,
       set,
       add,
       add_exn,
       to_alist,
       clear,
       function(Key){
        function create$0(num_keys){
         return create([0, Key[10]], num_keys, Key[11], 0);
        }
        function of_alist_exn(alist){
         function _au_(max, param){
          var key = param[1], _aw_ = caml_call1(Key[11], key);
          return caml_call2(Core_Int[90], max, _aw_);
         }
         var
          max_key = caml_call3(Core_List[20], alist, -1, _au_),
          t = create$0(max_key + 1 | 0);
         function _av_(param){
          var data = param[2], key = param[1];
          return add_exn(t, key, data);
         }
         caml_call2(Core_List[19], alist, _av_);
         return t;
        }
        function of_alist(alist){
         function _at_(param){return of_alist_exn(alist);}
         return caml_call2(Core_Or_error[37], 0, _at_);
        }
        function sexp_of_t(sexp_of_data){
         var _ar_ = Key[10];
         return function(_as_){return sexp_of_t$0(_ar_, sexp_of_data, _as_);};
        }
        function of_serialized(param){
         var alist = param[2], num_keys = param[1], t = create$0(num_keys);
         function _aq_(param){
          var data = param[2], key = param[1];
          return add_exn(t, key, data);
         }
         caml_call2(Core_List[19], alist, _aq_);
         return t;
        }
        function t_of_sexp(data_of_sexp, x_038){
         var of_key_029 = Key[9];
         function _ai_(param){
          var alist = param[2][1], num_keys = param[1];
          return [0, num_keys, alist];
         }
         var _aj_ = 0;
         function _ak_(param){
          return caml_string_notequal(param, cst_alist$1)
                  ? caml_string_notequal(param, cst_num_keys$1) ? -1 : 0
                  : 1;
         }
         var _al_ = 0;
         function _am_(sexp_037){
          if(1 === sexp_037[0]){
           var _ao_ = sexp_037[1];
           if(_ao_){
            var _ap_ = _ao_[2];
            if(_ap_ && ! _ap_[2]){
             var
              arg1_034 = _ap_[1],
              arg0_033 = _ao_[1],
              res0_035 = caml_call1(of_key_029, arg0_033),
              res1_036 = caml_call1(data_of_sexp, arg1_034);
             return [0, res0_035, res1_036];
            }
           }
          }
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4], error_source_032, 2, sexp_037);
         }
         var _an_ = [0, cst_alist$0, 1, caml_call1(Core[473], _am_), _al_];
         return of_serialized
                 (caml_call6
                   (Sexplib0_Sexp_conv_record[3],
                    error_source_032,
                    [0, cst_num_keys$0, 1, Core[390], _an_],
                    _ak_,
                    _aj_,
                    _ai_,
                    x_038));
        }
        var
         _X_ = caml_call1(Bin_shape[3][1], cst_data$1),
         _Y_ = caml_call1(Bin_shape[4][1], cst_bounded_int_table_src_boun$3),
         data = caml_call2(Bin_prot_Shape[11], _Y_, _X_),
         key = Key[5],
         _U_ = caml_call1(Bin_shape[2][1], cst_t$0),
         _V_ =
           caml_call1
            (caml_call2(Bin_prot_Shape[10], group, _U_),
             [0, key, [0, data, 0]]),
         _Z_ = [0, caml_call1(Bin_shape[3][1], cst_data$2), 0],
         ___ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$1), _Z_, _V_], 0],
         _$_ = caml_call1(Bin_shape[4][1], cst_bounded_int_table_src_boun$4),
         group$0 = caml_call2(Bin_prot_Shape[2], _$_, ___),
         _W_ = [0, to_serialized, of_serialized];
        function bin_shape_t(data){
         var _ah_ = caml_call1(Bin_shape[2][1], cst_t$2);
         return caml_call1
                 (caml_call2(Bin_prot_Shape[10], group$0, _ah_), [0, data, 0]);
        }
        function bin_size_t(size_of_data, v){
         var
          size_of_key = Key[1],
          v2 = v[2],
          v1 = v[1],
          _ac_ = caml_call1(Core[373], v1),
          size = caml_call2(Bin_prot_Common[23], 0, _ac_);
         function _ad_(param){
          var
           v2 = param[2],
           v1 = param[1],
           _af_ = caml_call1(size_of_key, v1),
           size = caml_call2(Bin_prot_Common[23], 0, _af_),
           _ag_ = caml_call1(size_of_data, v2);
          return caml_call2(Bin_prot_Common[23], size, _ag_);
         }
         var _ae_ = caml_call2(Core[457], _ad_, v2);
         return caml_call2(Bin_prot_Common[23], size, _ae_);
        }
        function bin_write_t(write_data, buf, pos$0, v){
         var
          write_key = Key[2],
          v2 = v[2],
          v1 = v[1],
          pos = caml_call3(Core[375], buf, pos$0, v1);
         function _ab_(buf, pos, param){
          var
           v2 = param[2],
           v1 = param[1],
           pos$0 = caml_call3(write_key, buf, pos, v1);
          return caml_call3(write_data, buf, pos$0, v2);
         }
         return caml_call4(Core[459], _ab_, buf, pos, v2);
        }
        function bin_read_t(of_data, buf, pos_ref, vint){
         return caml_call2
                 (Bin_prot_Common[19],
                  cst_bounded_int_table_src_boun$2,
                  pos_ref[1]);
        }
        function bin_read_t$0(of_data, buf, pos_ref){
         var
          of_key = Key[3],
          v_num_keys = caml_call2(Core[378], buf, pos_ref);
         function _aa_(buf, pos_ref){
          var
           v1 = caml_call2(of_key, buf, pos_ref),
           v2 = caml_call2(of_data, buf, pos_ref);
          return [0, v1, v2];
         }
         var v_alist = caml_call2(caml_call1(Core[462], _aa_), buf, pos_ref);
         return [0, v_num_keys, v_alist];
        }
        var
         include =
           caml_call1
            (caml_call1
              (Core_Binable[7],
               [0,
                bin_shape_t,
                bin_size_t,
                bin_write_t,
                bin_read_t$0,
                bin_read_t]),
             _W_),
         bin_shape_t$0 = include[1],
         bin_size_t$0 = include[2],
         bin_write_t$0 = include[3],
         bin_read_t$1 = include[4],
         bin_read_t$2 = include[5],
         bin_writer_t = include[6],
         bin_reader_t = include[7],
         bin_t = include[8];
        return [0,
                bin_shape_t$0,
                bin_size_t$0,
                bin_write_t$0,
                bin_read_t$1,
                bin_read_t$2,
                bin_writer_t,
                bin_reader_t,
                bin_t,
                t_of_sexp,
                sexp_of_t,
                create$0,
                of_alist,
                of_alist_exn];
       },
       debug];
   runtime.caml_register_global
    (86, Bounded_int_table, cst_Bounded_int_table$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJib3VuZGVkX2ludF90YWJsZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZXJyb3Jfc291cmNlXzAzMiIsInNleHBfb2ZfdCIsIm9mX2tleV8wMDEiLCJvZl9kYXRhXzAwMiIsImtleV8wMDQiLCJkYXRhXzAwNiIsImRlZmluZWRfZW50cmllc19pbmRleF8wMDgiLCJhcmdfMDA5IiwiYm5kc18wMDMiLCJhcmdfMDA3IiwiYm5kc18wMDMkMCIsImFyZ18wMDUiLCJibmRzXzAwMyQxIiwibGVuZ3RoIiwiciIsIm51bV9rZXlzIiwic2V4cF9vZl90X2RldGFpbGVkIiwib2Zfa2V5XzAxMCIsIm9mX2RhdGFfMDExIiwic2V4cF9vZl9rZXlfMDE1IiwibnVtX2tleXNfMDEzIiwibGVuZ3RoXzAxOSIsImRlZmluZWRfZW50cmllc18wMjMiLCJlbnRyaWVzX2J5X2tleV8wMjEiLCJibmRzXzAxMiIsImFyZ18wMjQiLCJibmRzXzAxMiQwIiwiYXJnXzAyMiIsImJuZHNfMDEyJDEiLCJhcmdfMDIwIiwiYm5kc18wMTIkMiIsImFyZ18wMTgiLCJibmRzXzAxMiQzIiwiYXJnXzAxNiIsImJuZHNfMDEyJDQiLCJhcmdfMDE0IiwiYm5kc18wMTIkNSIsInNleHBfb2Zfa2V5IiwidCIsImtleSIsImYiLCJpbnZhcmlhbnQiLCJpbnZhcmlhbnRfa2V5IiwiaW52YXJpYW50X2RhdGEiLCJpIiwiZW50cnkiLCJlbnRyeSQwIiwiZW50cnlfb3B0IiwiZ2V0X2VudHJpZXMiLCJhcnJheSIsImEiLCJlbnRyaWVzIiwiZW50cmllcyQwIiwiZXhuJDAiLCJleG4iLCJzZXhwX29mX2tleSQwIiwiYXJnMV8wMjYiLCJhcmcwXzAyNSIsInJlczBfMDI3IiwicmVzMV8wMjgiLCJkZWJ1ZyIsImNoZWNrX2ludmFyaWFudCIsImlzX2VtcHR5IiwiY3JlYXRlIiwia2V5X3RvX2ludCIsImZvbGQiLCJpbml0IiwiYWMiLCJhYyQwIiwiaSQwIiwiaXRlcmkiLCJkYXRhIiwiaXRlciIsIml0ZXJfa2V5cyIsIm1hcF9lbnRyaWVzIiwidG9fYWxpc3QiLCJjbGVhciIsImdyb3VwIiwidG9fc2VyaWFsaXplZCIsInNleHBfb2ZfdCQwIiwic2V4cF9vZl9kYXRhIiwiYWxpc3RfMDQ0IiwibnVtX2tleXNfMDQyIiwiYm5kc18wNDEiLCJhcmcxXzA0NyIsImFyZzBfMDQ2IiwicmVzMF8wNDgiLCJyZXMxXzA0OSIsImFyZ18wNDUiLCJibmRzXzA0MSQwIiwiYXJnXzA0MyIsImJuZHNfMDQxJDEiLCJrZXlzIiwiaW5kZXgiLCJhcmcyXzA1MyIsImFyZzFfMDUyIiwiYXJnMF8wNTEiLCJyZXMwXzA1NCIsInJlczFfMDU1Iiwidl8wNTAiLCJyZXMyXzA1NiIsImZpbmQiLCJlIiwiZmluZF9leG4iLCJhcmcxXzA1OCIsImFyZzBfMDU3IiwicmVzMF8wNTkiLCJyZXMxXzA2MCIsIm1lbSIsImFkZF9hc3N1bWluZ19ub3RfdGhlcmUiLCJkZWZpbmVkX2VudHJpZXNfaW5kZXgiLCJmaW5kX29yX2FkZCIsImRlZmF1bHQkMCIsInNldCIsImFkZCIsImFkZF9leG4iLCJhcmcxXzA2MiIsImFyZzBfMDYxIiwicmVzMF8wNjMiLCJyZXMxXzA2NCIsInJlbW92ZSIsImhvbGUiLCJsYXN0IiwiZW50cnlfdG9fcHV0X2luX2hvbGVfb3B0IiwiZW50cnlfdG9fcHV0X2luX2hvbGUiLCJhcmcyXzA2NyIsImFyZzFfMDY2IiwiYXJnMF8wNjUiLCJyZXMwXzA2OCIsInJlczFfMDY5IiwicmVzMl8wNzAiLCJleGlzdHNpIiwiZXhpc3RzIiwiZm9yX2FsbGkiLCJmb3JfYWxsIiwiZXF1YWwiLCJrZXlfZXF1YWwiLCJkYXRhX2VxdWFsIiwidDEiLCJ0MiIsImZpbHRlcl9tYXBpIiwicmVzdWx0IiwiZGF0YSQwIiwiaWdub3JlX2tleSIsImZpbHRlcl9tYXAiLCJmaWx0ZXJpIiwiZmlsdGVyIiwiZmlsdGVyX2tleXMiLCJtYXBpIiwibWFwIiwiY3JlYXRlJDAiLCJvZl9hbGlzdF9leG4iLCJhbGlzdCIsIm1heCIsIm1heF9rZXkiLCJvZl9hbGlzdCIsIm9mX3NlcmlhbGl6ZWQiLCJ0X29mX3NleHAiLCJkYXRhX29mX3NleHAiLCJ4XzAzOCIsIm9mX2tleV8wMjkiLCJzZXhwXzAzNyIsImFyZzFfMDM0IiwiYXJnMF8wMzMiLCJyZXMwXzAzNSIsInJlczFfMDM2IiwiZ3JvdXAkMCIsImJpbl9zaGFwZV90IiwiYmluX3NpemVfdCIsInNpemVfb2ZfZGF0YSIsInYiLCJzaXplX29mX2tleSIsInYyIiwidjEiLCJzaXplIiwiYmluX3dyaXRlX3QiLCJ3cml0ZV9kYXRhIiwiYnVmIiwicG9zJDAiLCJ3cml0ZV9rZXkiLCJwb3MiLCJiaW5fcmVhZF90Iiwib2ZfZGF0YSIsInBvc19yZWYiLCJ2aW50IiwiYmluX3JlYWRfdCQwIiwib2Zfa2V5Iiwidl9udW1fa2V5cyIsInZfYWxpc3QiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlX2tlcm5lbC9ib3VuZGVkX2ludF90YWJsZS9ib3VuZGVkX2ludF90YWJsZS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQStJRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQTVJQUMsVUFBTUMsWUFBTUM7SUFBWjtLQUVZQztLQUNBQztLQUVBQztLQUFBQyxVQUFBLHNCQUFBRDtLQUxaRSxnQ0FLWUQ7S0FGQUUsVUFBQSxXQUhBTixhQUdBRTtLQUhaSyxrQ0FHWUQsZUFIWkQ7S0FFWUcsVUFBQSxXQUZOVCxZQUVNRTtLQUZaUSxrQ0FFWUQsZUFGWkQ7SUFBQSxXQUFBRTtHQU9xQztZQVEzQkMsT0FBQUMsR0FBQSxPQUFBQSxLQUFNO1lBSmRDLFNBQUFELEdBQUEsT0FBQUEsS0FBUTtZQURaRSxtQkFBTUMsWUFB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QVNWLElBQUFEOztTQUFULElBQUFnQixVQUFBLHdDQThLRVgsS0FBQU07U0FoTE4sV0FDSUksWUFDQUM7UUE4S2dFOzs7Ozs7O2dCQUFuRHJCO2dCQUFYQztnQkFBQU87Z0JBQUFVO2dCQUFBSjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkFQRnhCO2dCQVJBNUo7Z0JBZEFxSjtnQkFhQUs7Z0JBVEFKOztPQXJORjNGOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBDb3JlXG5cbm1vZHVsZSBFbnRyeSA9IHN0cnVjdFxuICB0eXBlICgna2V5LCAnZGF0YSkgdCA9XG4gICAgeyAoKiB0aGUgaW50IGlzIGZpeGVkLCBidXQgdGhlICdrZXkgY2FuIGNoYW5nZSAqKVxuICAgICAgbXV0YWJsZSBrZXkgOiAna2V5XG4gICAgOyBtdXRhYmxlIGRhdGEgOiAnZGF0YVxuICAgICAgICAoKiBUaGUgaW5kZXggaW4gW2RlZmluZWRfZW50cmllc10gd2hlcmUgdGhpcyBbRW50cnkudF0gaXMgcGxhY2VkLiAqKVxuICAgIDsgbXV0YWJsZSBkZWZpbmVkX2VudHJpZXNfaW5kZXggOiBpbnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycywgc2V4cF9vZl1cbmVuZFxuXG50eXBlICgna2V5LCAnZGF0YSkgdF9kZXRhaWxlZCA9XG4gIHsgbnVtX2tleXMgOiBpbnRcbiAgOyBzZXhwX29mX2tleSA6ICgna2V5IC0+IFNleHAudCkgb3B0aW9uXG4gIDsga2V5X3RvX2ludCA6ICdrZXkgLT4gaW50XG4gICAgICAoKiBUaGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHRhYmxlLCBub3QgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXlzIGJlbG93LiAqKVxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gICAgICAoKiBbKGtleSwgZGF0YSldIGlzIGluIHRoZSB0YWJsZSBpZmZcbiAgICAge1tcbiAgICAgICBlbnRyaWVzX2J5X2tleS4oIGtleV90b19pbnQga2V5ICkgPSBTb21lIHsga2V5OyBkYXRhOyBfIH1cbiAgICAgXX1cbiAgKilcbiAgOyBlbnRyaWVzX2J5X2tleSA6ICgna2V5LCAnZGF0YSkgRW50cnkudCBvcHRpb24gYXJyYXlcbiAgICAgICgqIFRoZSBmaXJzdCBbbGVuZ3RoXSBlbGVtZW50cyBvZiBbZGVmaW5lZF9lbnRyaWVzXSBob2xkIHRoZSBkYXRhIGluIHRoZSB0YWJsZS4gIFRoaXMgaXNcbiAgICAgYW4gb3B0aW1pemF0aW9uIGZvciBmb2xkLCB0byBrZWVwIHVzIGZyb20gd2FzdGluZyBpdGVyYXRpb25zIHdoZW4gdGhlIGFycmF5IGlzXG4gICAgIHNwYXJzZS4gKilcbiAgOyBkZWZpbmVkX2VudHJpZXMgOiAoJ2tleSwgJ2RhdGEpIEVudHJ5LnQgb3B0aW9uIGFycmF5XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycywgc2V4cF9vZl1cblxudHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdF9kZXRhaWxlZFxudHlwZSAoJ2EsICdiKSB0YWJsZSA9ICgnYSwgJ2IpIHRcblxubGV0IHNleHBfb2Zfa2V5IHQgPVxuICBtYXRjaCB0LnNleHBfb2Zfa2V5IHdpdGhcbiAgfCBTb21lIGYgLT4gZlxuICB8IE5vbmUgLT4gZnVuIGtleSAtPiBJbnQuc2V4cF9vZl90ICh0LmtleV90b19pbnQga2V5KVxuOztcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfa2V5IGludmFyaWFudF9kYXRhIHQgPVxuICB0cnlcbiAgICBsZXQgbnVtX2tleXMgPSB0Lm51bV9rZXlzIGluXG4gICAgYXNzZXJ0IChudW1fa2V5cyA9IEFycmF5Lmxlbmd0aCB0LmVudHJpZXNfYnlfa2V5KTtcbiAgICBhc3NlcnQgKG51bV9rZXlzID0gQXJyYXkubGVuZ3RoIHQuZGVmaW5lZF9lbnRyaWVzKTtcbiAgICBhc3NlcnQgKDAgPD0gdC5sZW5ndGggJiYgdC5sZW5ndGggPD0gbnVtX2tleXMpO1xuICAgIEFycmF5Lml0ZXJpIHQuZW50cmllc19ieV9rZXkgfmY6KGZ1biBpIC0+IGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBlbnRyeSAtPlxuICAgICAgICBpbnZhcmlhbnRfa2V5IGVudHJ5LkVudHJ5LmtleTtcbiAgICAgICAgaW52YXJpYW50X2RhdGEgZW50cnkuZGF0YTtcbiAgICAgICAgYXNzZXJ0IChpID0gdC5rZXlfdG9faW50IGVudHJ5LmtleSk7XG4gICAgICAgIChtYXRjaCB0LmRlZmluZWRfZW50cmllcy4oZW50cnkuZGVmaW5lZF9lbnRyaWVzX2luZGV4KSB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICB8IFNvbWUgZW50cnknIC0+IGFzc2VydCAocGh5c19lcXVhbCBlbnRyeSBlbnRyeScpKSk7XG4gICAgQXJyYXkuaXRlcmkgdC5kZWZpbmVkX2VudHJpZXMgfmY6KGZ1biBpIGVudHJ5X29wdCAtPlxuICAgICAgbWF0Y2ggaSA8IHQubGVuZ3RoLCBlbnRyeV9vcHQgd2l0aFxuICAgICAgfCBmYWxzZSwgTm9uZSAtPiAoKVxuICAgICAgfCB0cnVlLCBTb21lIGVudHJ5IC0+IGFzc2VydCAoaSA9IGVudHJ5LkVudHJ5LmRlZmluZWRfZW50cmllc19pbmRleClcbiAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpO1xuICAgIGxldCBnZXRfZW50cmllcyBhcnJheSA9XG4gICAgICBsZXQgYSA9IEFycmF5LmZpbHRlcl9vcHQgYXJyYXkgaW5cbiAgICAgIEFycmF5LnNvcnQgYSB+Y29tcGFyZTooZnVuIGVudHJ5IGVudHJ5JyAtPlxuICAgICAgICBJbnQuY29tcGFyZSAodC5rZXlfdG9faW50IGVudHJ5LkVudHJ5LmtleSkgKHQua2V5X3RvX2ludCBlbnRyeScua2V5KSk7XG4gICAgICBhXG4gICAgaW5cbiAgICBsZXQgZW50cmllcyA9IGdldF9lbnRyaWVzIHQuZW50cmllc19ieV9rZXkgaW5cbiAgICBsZXQgZW50cmllcycgPSBnZXRfZW50cmllcyB0LmRlZmluZWRfZW50cmllcyBpblxuICAgIGFzc2VydCAodC5sZW5ndGggPSBBcnJheS5sZW5ndGggZW50cmllcyk7XG4gICAgYXNzZXJ0IChBcnJheS5lcXVhbCBwaHlzX2VxdWFsIGVudHJpZXMgZW50cmllcycpXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICBsZXQgc2V4cF9vZl9rZXkgPSBzZXhwX29mX2tleSB0IGluXG4gICAgZmFpbHdpdGhzXG4gICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICBcImludmFyaWFudCBmYWlsZWRcIlxuICAgICAgKGV4biwgdClcbiAgICAgIFslc2V4cF9vZjogZXhuICogKGtleSwgXykgdF9kZXRhaWxlZF1cbjs7XG5cbmxldCBkZWJ1ZyA9IHJlZiBmYWxzZVxubGV0IGNoZWNrX2ludmFyaWFudCB0ID0gaWYgIWRlYnVnIHRoZW4gaW52YXJpYW50IGlnbm9yZSBpZ25vcmUgdFxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IGNyZWF0ZSA/c2V4cF9vZl9rZXkgfm51bV9rZXlzIH5rZXlfdG9faW50ICgpID1cbiAgaWYgbnVtX2tleXMgPCAwXG4gIHRoZW4gZmFpbHdpdGhzIH5oZXJlOlslaGVyZV0gXCJudW1fa2V5cyBtdXN0IGJlIG5vbm5lZ2F0aXZlXCIgbnVtX2tleXMgWyVzZXhwX29mOiBpbnRdO1xuICBsZXQgdCA9XG4gICAgeyBudW1fa2V5c1xuICAgIDsgc2V4cF9vZl9rZXlcbiAgICA7IGtleV90b19pbnRcbiAgICA7IGxlbmd0aCA9IDBcbiAgICA7IGVudHJpZXNfYnlfa2V5ID0gQXJyYXkuY3JlYXRlIH5sZW46bnVtX2tleXMgTm9uZVxuICAgIDsgZGVmaW5lZF9lbnRyaWVzID0gQXJyYXkuY3JlYXRlIH5sZW46bnVtX2tleXMgTm9uZVxuICAgIH1cbiAgaW5cbiAgY2hlY2tfaW52YXJpYW50IHQ7XG4gIHRcbjs7XG5cbmxldCBjcmVhdGVfbGlrZVxuICB7IG51bV9rZXlzXG4gIDsgc2V4cF9vZl9rZXlcbiAgOyBrZXlfdG9faW50XG4gIDsgbGVuZ3RoID0gX1xuICA7IGVudHJpZXNfYnlfa2V5ID0gX1xuICA7IGRlZmluZWRfZW50cmllcyA9IF9cbiAgfVxuICA9XG4gIGNyZWF0ZSB+bnVtX2tleXMgP3NleHBfb2Zfa2V5IH5rZXlfdG9faW50ICgpXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgYWMgPVxuICAgIGlmIGkgPSB0Lmxlbmd0aFxuICAgIHRoZW4gYWNcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIHQuZGVmaW5lZF9lbnRyaWVzLihpKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IFNvbWUgZW50cnkgLT4gbG9vcCAoaSArIDEpIChmIH5rZXk6ZW50cnkua2V5IH5kYXRhOmVudHJ5LmRhdGEgYWMpKVxuICBpblxuICBsb29wIDAgaW5pdFxuOztcblxubGV0IGl0ZXJpIHQgfmYgPSBmb2xkIHQgfmluaXQ6KCkgfmY6KGZ1biB+a2V5IH5kYXRhICgpIC0+IGYgfmtleSB+ZGF0YSlcbmxldCBpdGVyIHQgfmYgPSBpdGVyaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBpdGVyX2tleXMgdCB+ZiA9IGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpXG5sZXQgbWFwX2VudHJpZXMgdCB+ZiA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWMgLT4gZiB+a2V5IH5kYXRhIDo6IGFjKVxubGV0IHRvX2FsaXN0IHQgPSBtYXBfZW50cmllcyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBrZXksIGRhdGEpXG5cbmxldCBjbGVhciB0ID1cbiAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgIG1hdGNoIHQuZGVmaW5lZF9lbnRyaWVzLihpKSB3aXRoXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgU29tZSBlbnRyeSAtPlxuICAgICAgdC5kZWZpbmVkX2VudHJpZXMuKGkpIDwtIE5vbmU7XG4gICAgICB0LmVudHJpZXNfYnlfa2V5Lih0LmtleV90b19pbnQgZW50cnkua2V5KSA8LSBOb25lXG4gIGRvbmU7XG4gIHQubGVuZ3RoIDwtIDBcbjs7XG5cbm1vZHVsZSBTZXJpYWxpemVkID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdkYXRhKSB0ID1cbiAgICB7IG51bV9rZXlzIDogaW50XG4gICAgOyBhbGlzdCA6ICgna2V5ICogJ2RhdGEpIGxpc3RcbiAgICB9XG4gIFtAQGRlcml2aW5nIGJpbl9pbywgc2V4cF1cbmVuZFxuXG5sZXQgdG9fc2VyaWFsaXplZCB0ID0geyBTZXJpYWxpemVkLm51bV9rZXlzID0gdC5udW1fa2V5czsgYWxpc3QgPSB0b19hbGlzdCB0IH1cblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX2RhdGEgdCA9XG4gIFNlcmlhbGl6ZWQuc2V4cF9vZl90IHNleHBfb2Zfa2V5IHNleHBfb2ZfZGF0YSAodG9fc2VyaWFsaXplZCB0KVxuOztcblxubGV0IGtleXMgdCA9IG1hcF9lbnRyaWVzIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4ga2V5KVxubGV0IGRhdGEgdCA9IG1hcF9lbnRyaWVzIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZGF0YSlcblxubGV0IGVudHJ5X29wdCB0IGtleSA9XG4gIGxldCBpbmRleCA9IHQua2V5X3RvX2ludCBrZXkgaW5cbiAgdHJ5IHQuZW50cmllc19ieV9rZXkuKGluZGV4KSB3aXRoXG4gIHwgXyAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5IHQgaW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwia2V5J3MgaW5kZXggb3V0IG9mIHJhbmdlXCJcbiAgICAgIChrZXksIGluZGV4LCBgU2hvdWxkX2JlX2JldHdlZW5fMF9hbmQgKHQubnVtX2tleXMgLSAxKSlcbiAgICAgIFslc2V4cF9vZjoga2V5ICogaW50ICogWyBgU2hvdWxkX2JlX2JldHdlZW5fMF9hbmQgb2YgaW50IF1dXG47O1xuXG5sZXQgZmluZCB0IGtleSA9XG4gIG1hdGNoIGVudHJ5X29wdCB0IGtleSB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBlIC0+IFNvbWUgKEVudHJ5LmRhdGEgZSlcbjs7XG5cbmxldCBmaW5kX2V4biB0IGtleSA9XG4gIG1hdGNoIGVudHJ5X29wdCB0IGtleSB3aXRoXG4gIHwgU29tZSBlbnRyeSAtPiBFbnRyeS5kYXRhIGVudHJ5XG4gIHwgTm9uZSAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5IHQgaW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiQm91bmRlZF9pbnRfdGFibGUuZmluZF9leG4gZ290IHVua25vd24ga2V5XCJcbiAgICAgIChrZXksIHQpXG4gICAgICBbJXNleHBfb2Y6IGtleSAqIChrZXksIF8pIHRdXG47O1xuXG5sZXQgbWVtIHQga2V5ID0gaXNfc29tZSAoZW50cnlfb3B0IHQga2V5KVxuXG5sZXQgYWRkX2Fzc3VtaW5nX25vdF90aGVyZSB0IH5rZXkgfmRhdGEgPVxuICBsZXQgZGVmaW5lZF9lbnRyaWVzX2luZGV4ID0gdC5sZW5ndGggaW5cbiAgbGV0IGVudHJ5X29wdCA9IFNvbWUgeyBFbnRyeS5rZXk7IGRhdGE7IGRlZmluZWRfZW50cmllc19pbmRleCB9IGluXG4gIHQuZW50cmllc19ieV9rZXkuKHQua2V5X3RvX2ludCBrZXkpIDwtIGVudHJ5X29wdDtcbiAgdC5kZWZpbmVkX2VudHJpZXMuKGRlZmluZWRfZW50cmllc19pbmRleCkgPC0gZW50cnlfb3B0O1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDE7XG4gIGNoZWNrX2ludmFyaWFudCB0XG47O1xuXG5sZXQgZmluZF9vcl9hZGQgdCBrZXkgfmRlZmF1bHQgPVxuICBtYXRjaCBlbnRyeV9vcHQgdCBrZXkgd2l0aFxuICB8IFNvbWUgZSAtPiBFbnRyeS5kYXRhIGVcbiAgfCBOb25lIC0+XG4gICAgbGV0IGRhdGEgPSBkZWZhdWx0ICgpIGluXG4gICAgYWRkX2Fzc3VtaW5nX25vdF90aGVyZSB0IH5rZXkgfmRhdGE7XG4gICAgZGF0YVxuOztcblxubGV0IHNldCB0IH5rZXkgfmRhdGEgPVxuICBtYXRjaCBlbnRyeV9vcHQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gYWRkX2Fzc3VtaW5nX25vdF90aGVyZSB0IH5rZXkgfmRhdGFcbiAgfCBTb21lIGVudHJ5IC0+XG4gICAgZW50cnkua2V5IDwtIGtleTtcbiAgICAoKiB3ZSB1cGRhdGUgdGhlIGtleSBiZWNhdXNlIHdlIHdhbnQgdGhlIGxhdGVzdCBrZXkgaW4gdGhlIHRhYmxlICopXG4gICAgZW50cnkuZGF0YSA8LSBkYXRhXG47O1xuXG5sZXQgYWRkIHQgfmtleSB+ZGF0YSA9XG4gIG1hdGNoIGVudHJ5X29wdCB0IGtleSB3aXRoXG4gIHwgU29tZSBlbnRyeSAtPiBgRHVwbGljYXRlIGVudHJ5LkVudHJ5LmRhdGFcbiAgfCBOb25lIC0+XG4gICAgYWRkX2Fzc3VtaW5nX25vdF90aGVyZSB0IH5rZXkgfmRhdGE7XG4gICAgYE9rXG47O1xuXG5sZXQgYWRkX2V4biB0IH5rZXkgfmRhdGEgPVxuICBtYXRjaCBhZGQgdCB+a2V5IH5kYXRhIHdpdGhcbiAgfCBgT2sgLT4gKClcbiAgfCBgRHVwbGljYXRlIF8gLT5cbiAgICBsZXQgc2V4cF9vZl9rZXkgPSBzZXhwX29mX2tleSB0IGluXG4gICAgZmFpbHdpdGhzXG4gICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICBcIkJvdW5kZWRfaW50X3RhYmxlLmFkZF9leG4gb2Yga2V5IHdob3NlIGluZGV4IGlzIGFscmVhZHkgcHJlc2VudFwiXG4gICAgICAoa2V5LCB0LmtleV90b19pbnQga2V5KVxuICAgICAgWyVzZXhwX29mOiBrZXkgKiBpbnRdXG47O1xuXG5sZXQgcmVtb3ZlIHQga2V5ID1cbiAgKG1hdGNoIGVudHJ5X29wdCB0IGtleSB3aXRoXG4gICB8IE5vbmUgLT4gKClcbiAgIHwgU29tZSBlbnRyeSAtPlxuICAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gICAgIHQuZW50cmllc19ieV9rZXkuKHQua2V5X3RvX2ludCBrZXkpIDwtIE5vbmU7XG4gICAgIGxldCBob2xlID0gZW50cnkuZGVmaW5lZF9lbnRyaWVzX2luZGV4IGluXG4gICAgIGxldCBsYXN0ID0gdC5sZW5ndGggaW5cbiAgICAgaWYgaG9sZSA8IGxhc3RcbiAgICAgdGhlbiAoXG4gICAgICAgbWF0Y2ggdC5kZWZpbmVkX2VudHJpZXMuKGxhc3QpIHdpdGhcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5IHQgaW5cbiAgICAgICAgIGZhaWx3aXRoc1xuICAgICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgICAgIFwiQm91bmRlZF9pbnRfdGFibGUucmVtb3ZlIGJ1Z1wiXG4gICAgICAgICAgIChrZXksIGxhc3QsIHQpXG4gICAgICAgICAgIFslc2V4cF9vZjoga2V5ICogaW50ICogKGtleSwgXykgdF9kZXRhaWxlZF1cbiAgICAgICB8IFNvbWUgZW50cnlfdG9fcHV0X2luX2hvbGUgYXMgZW50cnlfdG9fcHV0X2luX2hvbGVfb3B0IC0+XG4gICAgICAgICB0LmRlZmluZWRfZW50cmllcy4oaG9sZSkgPC0gZW50cnlfdG9fcHV0X2luX2hvbGVfb3B0O1xuICAgICAgICAgZW50cnlfdG9fcHV0X2luX2hvbGUuZGVmaW5lZF9lbnRyaWVzX2luZGV4IDwtIGhvbGUpO1xuICAgICB0LmRlZmluZWRfZW50cmllcy4obGFzdCkgPC0gTm9uZSk7XG4gIGNoZWNrX2ludmFyaWFudCB0XG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpXG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxubGV0IGZvcl9hbGxpIHQgfmYgPSBub3QgKGV4aXN0c2kgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gbm90IChmIH5rZXkgfmRhdGEpKSlcbmxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IGVxdWFsIGtleV9lcXVhbCBkYXRhX2VxdWFsIHQxIHQyID1cbiAgbGVuZ3RoIHQxID0gbGVuZ3RoIHQyXG4gICYmIGZvcl9hbGxpIHQxIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgIG1hdGNoIGVudHJ5X29wdCB0MiBrZXkgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgIHwgU29tZSBlbnRyeSAtPiBrZXlfZXF1YWwga2V5IGVudHJ5LkVudHJ5LmtleSAmJiBkYXRhX2VxdWFsIGRhdGEgZW50cnkuRW50cnkuZGF0YSlcbjs7XG5cbm1vZHVsZSBXaXRoX2tleSAoS2V5IDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZyBiaW5faW8sIHNleHBdXG5cbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG5lbmQpID1cbnN0cnVjdFxuICB0eXBlICdkYXRhIHQgPSAoS2V5LnQsICdkYXRhKSB0YWJsZVxuICB0eXBlICdkYXRhIHRhYmxlID0gJ2RhdGEgdFxuXG4gIGxldCBjcmVhdGUgfm51bV9rZXlzID1cbiAgICBjcmVhdGUgfnNleHBfb2Zfa2V5OktleS5zZXhwX29mX3Qgfm51bV9rZXlzIH5rZXlfdG9faW50OktleS50b19pbnQgKClcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZXhuIGFsaXN0ID1cbiAgICBsZXQgbWF4X2tleSA9XG4gICAgICBMaXN0LmZvbGQgYWxpc3QgfmluaXQ6KC0xKSB+ZjooZnVuIG1heCAoa2V5LCBfKSAtPiBJbnQubWF4IG1heCAoS2V5LnRvX2ludCBrZXkpKVxuICAgIGluXG4gICAgbGV0IHQgPSBjcmVhdGUgfm51bV9rZXlzOihtYXhfa2V5ICsgMSkgaW5cbiAgICBMaXN0Lml0ZXIgYWxpc3QgfmY6KGZ1biAoa2V5LCBkYXRhKSAtPiBhZGRfZXhuIHQgfmtleSB+ZGF0YSk7XG4gICAgdFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdCBhbGlzdCA9IE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gb2ZfYWxpc3RfZXhuIGFsaXN0KVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZGF0YSA9IHNleHBfb2ZfdCBLZXkuc2V4cF9vZl90IHNleHBfb2ZfZGF0YVxuXG4gIGxldCBvZl9zZXJpYWxpemVkIHsgU2VyaWFsaXplZC5udW1fa2V5czsgYWxpc3QgfSA9XG4gICAgbGV0IHQgPSBjcmVhdGUgfm51bV9rZXlzIGluXG4gICAgTGlzdC5pdGVyIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT4gYWRkX2V4biB0IH5rZXkgfmRhdGEpO1xuICAgIHRcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIGRhdGFfb2Zfc2V4cCBzZXhwID1cbiAgICBvZl9zZXJpYWxpemVkIChTZXJpYWxpemVkLnRfb2Zfc2V4cCBLZXkudF9vZl9zZXhwIGRhdGFfb2Zfc2V4cCBzZXhwKVxuICA7O1xuXG4gIGluY2x1ZGVcbiAgICBCaW5hYmxlLk9mX2JpbmFibGUxX3dpdGhvdXRfdXVpZCBbQGFsZXJ0IFwiLWxlZ2FjeVwiXVxuICAgICAgKHN0cnVjdFxuICAgICAgICB0eXBlICdkYXRhIHQgPSAoS2V5LnQsICdkYXRhKSBTZXJpYWxpemVkLnQgW0BAZGVyaXZpbmcgYmluX2lvXVxuICAgICAgZW5kKVxuICAgICAgKHN0cnVjdFxuICAgICAgICB0eXBlICdkYXRhIHQgPSAnZGF0YSB0YWJsZVxuXG4gICAgICAgIGxldCB0b19iaW5hYmxlID0gdG9fc2VyaWFsaXplZFxuICAgICAgICBsZXQgb2ZfYmluYWJsZSA9IG9mX3NlcmlhbGl6ZWRcbiAgICAgIGVuZClcbmVuZFxuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCByZXN1bHQgPSBjcmVhdGVfbGlrZSB0IGluXG4gIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgZGF0YSAtPiBhZGRfZXhuIHJlc3VsdCB+a2V5IH5kYXRhKTtcbiAgcmVzdWx0XG47O1xuXG5sZXQgaWdub3JlX2tleSBmIH5rZXk6XyB+ZGF0YSA9IGYgZGF0YVxubGV0IGlnbm9yZV9kYXRhIGYgfmtleSB+ZGF0YTpfID0gZiBrZXlcbmxldCBmaWx0ZXJfbWFwIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihpZ25vcmVfa2V5IGYpXG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBTb21lIGRhdGEgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyaSB0IH5mOihpZ25vcmVfa2V5IGYpXG5sZXQgZmlsdGVyX2tleXMgdCB+ZiA9IGZpbHRlcmkgdCB+ZjooaWdub3JlX2RhdGEgZilcbmxldCBtYXBpIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBTb21lIChmIH5rZXkgfmRhdGEpKVxubGV0IG1hcCB0IH5mID0gbWFwaSB0IH5mOihpZ25vcmVfa2V5IGYpXG4iXX0=
