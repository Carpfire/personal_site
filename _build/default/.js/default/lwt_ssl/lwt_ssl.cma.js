// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Lwt_ssl
//# unitInfo: Requires: Lwt, Lwt_bytes, Lwt_io, Lwt_unix, Ssl, Unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Unix = global_data.Unix,
    Ssl = global_data.Ssl,
    Lwt_unix = global_data.Lwt_unix,
    Lwt_io = global_data.Lwt_io,
    Lwt = global_data.Lwt,
    Lwt_bytes = global_data.Lwt_bytes;
   function ssl_socket(param){
    var kind = param[2];
    if(! kind) return 0;
    var socket = kind[1];
    return [0, socket];
   }
   function ssl_socket_of_uninitialized_so(param){var socket = param[2]; return socket;
   }
   function is_ssl(s){return s[2] ? 1 : 0;}
   function wrap_call(f, param){
    try{var _O_ = caml_call1(f, 0); return _O_;}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     if(e[1] === Ssl[12] || e[1] === Ssl[13] || e[1] === Ssl[14])
      var err = e[2];
     else{
      if(e[1] !== Ssl[15]) throw caml_maybe_attach_backtrace(e, 0);
      var err = e[2];
     }
     if(2 === err) throw caml_maybe_attach_backtrace(Lwt_unix[146], 1);
     if(3 === err) throw caml_maybe_attach_backtrace(Lwt_unix[147], 1);
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function repeat_call(fd, f){
    function _G_(blocking){
     try{var _K_ = wrap_call(f, 0), _L_ = caml_call1(Lwt[4], _K_); return _L_;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      if(e === Lwt_unix[146]){
       var _I_ = function(_N_){return wrap_call(f, _N_);};
       return caml_call3(Lwt_unix[150], 0, fd, _I_);
      }
      if(e !== Lwt_unix[147]) return caml_call1(Lwt[5], e);
      var _J_ = function(_M_){return wrap_call(f, _M_);};
      return caml_call3(Lwt_unix[150], 1, fd, _J_);
     }
    }
    var _H_ = caml_call1(Lwt_unix[12], fd);
    return caml_call2(Lwt[33][1], _H_, _G_);
   }
   function plain(fd){return [0, fd, 0];}
   function embed_socket(fd, context){
    var _F_ = caml_call1(Lwt_unix[10], fd);
    return [0, fd, [0, caml_call2(Ssl[61], _F_, context)]];
   }
   function embed_uninitialized_socket(fd, context){
    var _E_ = caml_call1(Lwt_unix[10], fd);
    return [0, fd, caml_call2(Ssl[61], _E_, context)];
   }
   function ssl_accept(fd, ctx){
    var
     _B_ = caml_call1(Lwt_unix[10], fd),
     socket = caml_call2(Ssl[61], _B_, ctx);
    function _C_(param){return caml_call1(Lwt[4], [0, fd, [0, socket]]);}
    var
     _D_ =
       repeat_call(fd, function(param){return caml_call1(Ssl[71], socket);});
    return caml_call2(Lwt[6], _D_, _C_);
   }
   function ssl_connect(fd, ctx){
    var
     _y_ = caml_call1(Lwt_unix[10], fd),
     socket = caml_call2(Ssl[61], _y_, ctx);
    function _z_(param){return caml_call1(Lwt[4], [0, fd, [0, socket]]);}
    var
     _A_ =
       repeat_call(fd, function(param){return caml_call1(Ssl[70], socket);});
    return caml_call2(Lwt[6], _A_, _z_);
   }
   function ssl_accept_handshake(param){
    var socket = param[2], fd = param[1];
    function _w_(param){return caml_call1(Lwt[4], [0, fd, [0, socket]]);}
    var
     _x_ =
       repeat_call(fd, function(param){return caml_call1(Ssl[71], socket);});
    return caml_call2(Lwt[6], _x_, _w_);
   }
   function ssl_perform_handshake(param){
    var socket = param[2], fd = param[1];
    function _u_(param){return caml_call1(Lwt[4], [0, fd, [0, socket]]);}
    var
     _v_ =
       repeat_call(fd, function(param){return caml_call1(Ssl[70], socket);});
    return caml_call2(Lwt[6], _v_, _u_);
   }
   function read(param, buf, pos, len){
    var s = param[2], fd = param[1];
    if(! s) return caml_call4(Lwt_unix[26], fd, buf, pos, len);
    var s$0 = s[1];
    return 0 === len
            ? caml_call1(Lwt[4], 0)
            : repeat_call
              (fd,
               function(param){
                try{
                 var _s_ = caml_call4(Ssl[78], s$0, buf, pos, len);
                 return _s_;
                }
                catch(_t_){
                 var _r_ = caml_wrap_exception(_t_);
                 if(_r_[1] === Ssl[14] && 6 === _r_[2]) return 0;
                 throw caml_maybe_attach_backtrace(_r_, 0);
                }
               });
   }
   function read_bytes(param, buf, pos, len){
    var s = param[2], fd = param[1];
    if(! s) return caml_call4(Lwt_bytes[23], fd, buf, pos, len);
    var s$0 = s[1];
    return 0 === len
            ? caml_call1(Lwt[4], 0)
            : repeat_call
              (fd,
               function(param){
                try{
                 var _p_ = caml_call4(Ssl[79], s$0, buf, pos, len);
                 return _p_;
                }
                catch(_q_){
                 var _o_ = caml_wrap_exception(_q_);
                 if(_o_[1] === Ssl[14] && 6 === _o_[2]) return 0;
                 throw caml_maybe_attach_backtrace(_o_, 0);
                }
               });
   }
   function write(param, buf, pos, len){
    var s = param[2], fd = param[1];
    if(! s) return caml_call4(Lwt_unix[28], fd, buf, pos, len);
    var s$0 = s[1];
    return 0 === len
            ? caml_call1(Lwt[4], 0)
            : repeat_call
              (fd,
               function(param){
                return caml_call4(Ssl[80], s$0, buf, pos, len);
               });
   }
   function write_bytes(param, buf, pos, len){
    var s = param[2], fd = param[1];
    if(! s) return caml_call4(Lwt_bytes[24], fd, buf, pos, len);
    var s$0 = s[1];
    return 0 === len
            ? caml_call1(Lwt[4], 0)
            : repeat_call
              (fd,
               function(param){
                return caml_call4(Ssl[82], s$0, buf, pos, len);
               });
   }
   function wait_read(param){
    var s = param[2], fd = param[1];
    return s ? caml_call1(Lwt[57], 0) : caml_call1(Lwt_unix[37], fd);
   }
   function wait_write(param){
    var s = param[2], fd = param[1];
    return s ? caml_call1(Lwt[57], 0) : caml_call1(Lwt_unix[38], fd);
   }
   function ssl_shutdown(param){
    var s = param[2], fd = param[1];
    if(! s) return Lwt[36];
    var s$0 = s[1];
    return repeat_call(fd, function(param){return caml_call1(Ssl[76], s$0);});
   }
   function shutdown(param, cmd){
    var fd = param[1];
    return caml_call2(Lwt_unix[99], fd, cmd);
   }
   function close_notify(s){
    var match = s[2], fd = s[1];
    if(match){
     var s$0 = match[1];
     return repeat_call(fd, function(param){return caml_call1(Ssl[74], s$0);});
    }
    shutdown(s, 1);
    return Lwt[39];
   }
   function close(param){
    var fd = param[1];
    return caml_call1(Lwt_unix[25], fd);
   }
   function abort(param){
    var fd = param[1];
    return caml_call1(Lwt_unix[14], fd);
   }
   function shutdown_and_close(s){
    function _k_(param){
     function _m_(param){return close(s);}
     var _n_ = caml_call3(Lwt[64], shutdown, s, 2);
     return caml_call2(Lwt[33][1], _n_, _m_);
    }
    var _l_ = ssl_shutdown(s);
    return caml_call2(Lwt[33][1], _l_, _k_);
   }
   function out_channel_of_descr(buffer, s){
    function _g_(buf, pos, len){return write_bytes(s, buf, pos, len);}
    var
     _h_ = Lwt_io[3],
     _i_ = 0,
     _j_ = [0, function(param){return shutdown_and_close(s);}];
    return caml_call5(Lwt_io[11], buffer, _j_, _i_, _h_, _g_);
   }
   function in_channel_of_descr(buffer, s){
    function _c_(buf, pos, len){return read_bytes(s, buf, pos, len);}
    var
     _d_ = Lwt_io[2],
     _e_ = 0,
     _f_ = [0, function(param){return shutdown_and_close(s);}];
    return caml_call5(Lwt_io[11], buffer, _f_, _e_, _d_, _c_);
   }
   function get_fd(param){var fd = param[1]; return fd;}
   function get_unix_fd(param){
    var socket = param[2], fd = param[1];
    if(! socket) return caml_call1(Lwt_unix[10], fd);
    var socket$0 = socket[1];
    return caml_call1(Ssl[69], socket$0);
   }
   function getsockname(s){
    var _b_ = get_unix_fd(s);
    return caml_call1(Unix[141], _b_);
   }
   function getpeername(s){
    var _a_ = get_unix_fd(s);
    return caml_call1(Unix[142], _a_);
   }
   var
    Lwt_ssl =
      [0,
       ssl_socket,
       ssl_socket_of_uninitialized_so,
       is_ssl,
       ssl_accept,
       ssl_connect,
       plain,
       embed_socket,
       embed_uninitialized_socket,
       ssl_perform_handshake,
       ssl_accept_handshake,
       read,
       write,
       read_bytes,
       write_bytes,
       wait_read,
       wait_write,
       shutdown,
       close,
       in_channel_of_descr,
       out_channel_of_descr,
       close_notify,
       ssl_shutdown,
       abort,
       get_fd,
       get_unix_fd,
       getsockname,
       getpeername];
   runtime.caml_register_global(6, Lwt_ssl, "Lwt_ssl");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJsd3Rfc3NsLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJzc2xfc29ja2V0Iiwia2luZCIsInNvY2tldCIsInNzbF9zb2NrZXRfb2ZfdW5pbml0aWFsaXplZF9zbyIsImlzX3NzbCIsInMiLCJ3cmFwX2NhbGwiLCJmIiwiZSQwIiwiZSIsImVyciIsInJlcGVhdF9jYWxsIiwiZmQiLCJibG9ja2luZyIsInBsYWluIiwiZW1iZWRfc29ja2V0IiwiY29udGV4dCIsImVtYmVkX3VuaW5pdGlhbGl6ZWRfc29ja2V0Iiwic3NsX2FjY2VwdCIsImN0eCIsInNzbF9jb25uZWN0Iiwic3NsX2FjY2VwdF9oYW5kc2hha2UiLCJzc2xfcGVyZm9ybV9oYW5kc2hha2UiLCJyZWFkIiwiYnVmIiwicG9zIiwibGVuIiwicyQwIiwicmVhZF9ieXRlcyIsIndyaXRlIiwid3JpdGVfYnl0ZXMiLCJ3YWl0X3JlYWQiLCJ3YWl0X3dyaXRlIiwic3NsX3NodXRkb3duIiwic2h1dGRvd24iLCJjbWQiLCJjbG9zZV9ub3RpZnkiLCJjbG9zZSIsImFib3J0Iiwic2h1dGRvd25fYW5kX2Nsb3NlIiwib3V0X2NoYW5uZWxfb2ZfZGVzY3IiLCJidWZmZXIiLCJpbl9jaGFubmVsX29mX2Rlc2NyIiwiZ2V0X2ZkIiwiZ2V0X3VuaXhfZmQiLCJzb2NrZXQkMCIsImdldHNvY2tuYW1lIiwiZ2V0cGVlcm5hbWUiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3Rfc3NsL2x3dF9zc2wubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7O1lBZ0NJQTtRQUFpQkM7SUFDbkIsS0FEbUJBLE1BRVI7UUFDTEMsU0FIYUQ7SUFHSCxXQUFWQzs7WUFFSkMsMENBQXlDRCxtQkFBVSxPQUFWQTs7WUFFekNFLE9BQU9DLEdBQ1QsT0FEU0EsYUFHTTtZQUViQyxVQUFVQztJ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aEJsQmEsbUJBWTRCbEMsR0FJVTtJQUN0QyxPQUFBLHVCQUxxQm9DO0dBS3dCO1lBRTdDRSxrQkFBUS9CLGVBQWUsT0FBZkE7WUFFUmdDO1FBQWdCMUMsbUJBQUhVO0lBQ2YsS0FEa0JWLFFBRVAsT0FBQSx5QkFGSVU7UUFHVGlDLFdBSFkzQztJQUdGLE9BQUEsb0JBQVYyQzs7WUFFSkMsWUFBWXpDO0lBQ0csVUFOZnVDLFlBS1l2QztJQUNHLE9BQUE7R0FBZTtZQUU5QjBDLFlBQVkxQztJQUNHLFVBVGZ1QyxZQVFZdkM7SUFDRyxPQUFBO0dBQWU7Ozs7T0FuTDlCTDtPQUtBRztPQUVBQztPQXVDQWM7T0FNQUU7T0FYQU47T0FFQUM7T0FDQUU7T0FtQkFLO09BTEFEO09BVUFFO09BOEJBTTtPQWZBRDtPQTJCQUU7T0FXQUM7T0FLQUM7T0FVQUU7T0FTQUc7T0FnQkFLO09BUEFGO09BaEJBSjtPQVBBSDtPQWdCQUs7T0FxQkFLO09BRUFDO09BS0FFO09BR0FDOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIE9DYW1sIHByb21pc2UgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9sd3RcbiAqIENvcHlyaWdodCAoQykgMjAwNS0yMDA4IErDqXLDtG1lIFZvdWlsbG9uXG4gKiBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3RcbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXNcbiAqIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9ucztcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXJcbiAqIHZlcnNpb24uIFNlZSBDT1BZSU5HIGZpbGUgZm9yIGRldGFpbHMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dFxuICogV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAqIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BXG4gKiAwMjExMS0xMzA3LCBVU0EuXG4gKilcblxub3BlbiBMd3QuSW5maXhcblxudHlwZSB0ID1cbiAgICBQbGFpblxuICB8IFNTTCBvZiBTc2wuc29ja2V0XG5cbnR5cGUgc29ja2V0ID0gTHd0X3VuaXguZmlsZV9kZXNjciAqIHRcblxudHlwZSB1bmluaXRpYWxpemVkX3NvY2tldCA9IEx3dF91bml4LmZpbGVfZGVzY3IgKiBTc2wuc29ja2V0XG5cbmxldCBzc2xfc29ja2V0IChfZmQsIGtpbmQpID1cbiAgbWF0Y2gga2luZCB3aXRoXG4gIHwgUGxhaW4gLT4gTm9uZVxuICB8IFNTTCBzb2NrZXQgLT4gU29tZSBzb2NrZXRcblxubGV0IHNzbF9zb2NrZXRfb2ZfdW5pbml0aWFsaXplZF9zb2NrZXQgKF9mZCwgc29ja2V0KSA9IHNvY2tldFxuXG5sZXQgaXNfc3NsIHMgPVxuICBtYXRjaCBzbmQgcyB3aXRoXG4gICAgUGxhaW4gLT4gZmFsc2VcbiAgfCBTU0wgXyAtPiB0cnVlXG5cbmxldCB3cmFwX2NhbGwgZiAoKSA9XG4gIHRyeVxuICAgIGYgKClcbiAgd2l0aFxuICAgIChTc2wuQ29ubmVjdGlvbl9lcnJvciBlcnIgfCBTc2wuQWNjZXB0X2Vycm9yIGVyciB8XG4gICAgIFNzbC5SZWFkX2Vycm9yIGVyciB8IFNzbC5Xcml0ZV9lcnJvciBlcnIpIGFzIGUgLT5cbiAgICAobWF0Y2ggZXJyIHdpdGhcbiAgICAgICBTc2wuRXJyb3Jfd2FudF9yZWFkIC0+XG4gICAgICAgcmFpc2UgTHd0X3VuaXguUmV0cnlfcmVhZFxuICAgICB8IFNzbC5FcnJvcl93YW50X3dyaXRlIC0+XG4gICAgICAgcmFpc2UgTHd0X3VuaXguUmV0cnlfd3JpdGVcbiAgICAgfCBfIC0+XG4gICAgICAgcmFpc2UgZSkgW0BvY2FtbC53YXJuaW5nIFwiLTRcIl1cblxubGV0IHJlcGVhdF9jYWxsIGZkIGYgPVxuICAoKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2lzc3Vlcy81MzAuICopXG4gIEx3dF91bml4LmJsb2NraW5nIGZkID4+PSBmdW4gX2Jsb2NraW5nIC0+XG4gIHRyeVxuICAgIEx3dC5yZXR1cm4gKHdyYXBfY2FsbCBmICgpKVxuICB3aXRoXG4gICAgTHd0X3VuaXguUmV0cnlfcmVhZCAtPlxuICAgIEx3dF91bml4LnJlZ2lzdGVyX2FjdGlvbiBMd3RfdW5peC5SZWFkIGZkICh3cmFwX2NhbGwgZilcbiAgfCBMd3RfdW5peC5SZXRyeV93cml0ZSAtPlxuICAgIEx3dF91bml4LnJlZ2lzdGVyX2FjdGlvbiBMd3RfdW5peC5Xcml0ZSBmZCAod3JhcF9jYWxsIGYpXG4gIHwgZSAtPlxuICAgIEx3dC5mYWlsIGVcblxuKCoqKiopXG5cbmxldCBwbGFpbiBmZCA9IChmZCwgUGxhaW4pXG5cbmxldCBlbWJlZF9zb2NrZXQgZmQgY29udGV4dCA9IChmZCwgU1NMKFNzbC5lbWJlZF9zb2NrZXQgKEx3dF91bml4LnVuaXhfZmlsZV9kZXNjciBmZCkgY29udGV4dCkpXG5sZXQgZW1iZWRfdW5pbml0aWFsaXplZF9zb2NrZXQgZmQgY29udGV4dCA9IChmZCwgU3NsLmVtYmVkX3NvY2tldCAoTHd0X3VuaXgudW5peF9maWxlX2Rlc2NyIGZkKSBjb250ZXh0KVxuXG5sZXQgc3NsX2FjY2VwdCBmZCBjdHggPVxuICBsZXQgc29ja2V0ID0gU3NsLmVtYmVkX3NvY2tldCAoTHd0X3VuaXgudW5peF9maWxlX2Rlc2NyIGZkKSBjdHggaW5cbiAgTHd0LmJpbmRcbiAgICAocmVwZWF0X2NhbGwgZmQgKGZ1biAoKSAtPiBTc2wuYWNjZXB0IHNvY2tldCkpIChmdW4gKCkgLT5cbiAgICAgIEx3dC5yZXR1cm4gKGZkLCBTU0wgc29ja2V0KSlcblxubGV0IHNzbF9jb25uZWN0IGZkIGN0eCA9XG4gIGxldCBzb2NrZXQgPSBTc2wuZW1iZWRfc29ja2V0IChMd3RfdW5peC51bml4X2ZpbGVfZGVzY3IgZmQpIGN0eCBpblxuICBMd3QuYmluZFxuICAgIChyZXBlYXRfY2FsbCBmZCAoZnVuICgpIC0+IFNzbC5jb25uZWN0IHNvY2tldCkpIChmdW4gKCkgLT5cbiAgICAgIEx3dC5yZXR1cm4gKGZkLCBTU0wgc29ja2V0KSlcblxubGV0IHNzbF9hY2NlcHRfaGFuZHNoYWtlIChmZCwgc29ja2V0KSA9XG4gIEx3dC5iaW5kXG4gICAgKHJlcGVhdF9jYWxsIGZkIChmdW4gKCkgLT4gU3NsLmFjY2VwdCBzb2NrZXQpKSAoZnVuICgpIC0+XG4gICAgICBMd3QucmV0dXJuIChmZCwgU1NMIHNvY2tldCkpXG5cbmxldCBzc2xfcGVyZm9ybV9oYW5kc2hha2UgKGZkLCBzb2NrZXQpID1cbiAgTHd0LmJpbmRcbiAgICAocmVwZWF0X2NhbGwgZmQgKGZ1biAoKSAtPiBTc2wuY29ubmVjdCBzb2NrZXQpKSAoZnVuICgpIC0+XG4gICAgICBMd3QucmV0dXJuIChmZCwgU1NMIHNvY2tldCkpXG5cbmxldCByZWFkIChmZCwgcykgYnVmIHBvcyBsZW4gPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBQbGFpbiAtPlxuICAgIEx3dF91bml4LnJlYWQgZmQgYnVmIHBvcyBsZW5cbiAgfCBTU0wgcyAtPlxuICAgIGlmIGxlbiA9IDAgdGhlblxuICAgICAgTHd0LnJldHVybiAwXG4gICAgZWxzZVxuICAgICAgcmVwZWF0X2NhbGwgZmRcbiAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICBTc2wucmVhZCBzIGJ1ZiBwb3MgbGVuXG4gICAgICAgICAgIHdpdGggU3NsLlJlYWRfZXJyb3IgU3NsLkVycm9yX3plcm9fcmV0dXJuIC0+XG4gICAgICAgICAgICAgMClcblxubGV0IHJlYWRfYnl0ZXMgKGZkLCBzKSBidWYgcG9zIGxlbiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFBsYWluIC0+XG4gICAgTHd0X2J5dGVzLnJlYWQgZmQgYnVmIHBvcyBsZW5cbiAgfCBTU0wgcyAtPlxuICAgIGlmIGxlbiA9IDAgdGhlblxuICAgICAgTHd0LnJldHVybiAwXG4gICAgZWxzZVxuICAgICAgcmVwZWF0X2NhbGwgZmRcbiAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICBTc2wucmVhZF9pbnRvX2JpZ2FycmF5IHMgYnVmIHBvcyBsZW5cbiAgICAgICAgICAgd2l0aCBTc2wuUmVhZF9lcnJvciBTc2wuRXJyb3JfemVyb19yZXR1cm4gLT5cbiAgICAgICAgICAgICAwKVxuXG5sZXQgd3JpdGUgKGZkLCBzKSBidWYgcG9zIGxlbiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFBsYWluIC0+XG4gICAgTHd0X3VuaXgud3JpdGUgZmQgYnVmIHBvcyBsZW5cbiAgfCBTU0wgcyAtPlxuICAgIGlmIGxlbiA9IDAgdGhlblxuICAgICAgTHd0LnJldHVybiAwXG4gICAgZWxzZVxuICAgICAgcmVwZWF0X2NhbGwgZmRcbiAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICBTc2wud3JpdGUgcyBidWYgcG9zIGxlbilcblxubGV0IHdyaXRlX2J5dGVzIChmZCwgcykgYnVmIHBvcyBsZW4gPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBQbGFpbiAtPlxuICAgIEx3dF9ieXRlcy53cml0ZSBmZCBidWYgcG9zIGxlblxuICB8IFNTTCBzIC0+XG4gICAgaWYgbGVuID0gMCB0aGVuXG4gICAgICBMd3QucmV0dXJuIDBcbiAgICBlbHNlXG4gICAgICByZXBlYXRfY2FsbCBmZFxuICAgICAgICAoZnVuICgpIC0+IFNzbC53cml0ZV9iaWdhcnJheSBzIGJ1ZiBwb3MgbGVuKVxuXG5sZXQgd2FpdF9yZWFkIChmZCwgcykgPVxuICBtYXRjaCBzIHdpdGhcbiAgICBQbGFpbiAtPiBMd3RfdW5peC53YWl0X3JlYWQgZmRcbiAgfCBTU0wgXyAtPiBMd3QucGF1c2UgKClcblxubGV0IHdhaXRfd3JpdGUgKGZkLCBzKSA9XG4gIG1hdGNoIHMgd2l0aFxuICAgIFBsYWluIC0+IEx3dF91bml4LndhaXRfd3JpdGUgZmRcbiAgfCBTU0wgXyAtPiBMd3QucGF1c2UgKClcblxubGV0IHNzbF9zaHV0ZG93biAoZmQsIHMpID1cbiAgbWF0Y2ggcyB3aXRoXG4gICAgUGxhaW4gLT4gTHd0LnJldHVybl91bml0XG4gIHwgU1NMIHMgLT4gcmVwZWF0X2NhbGwgZmQgKGZ1biAoKSAtPiBTc2wuc2h1dGRvd24gcylcblxubGV0IHNodXRkb3duIChmZCwgXykgY21kID0gTHd0X3VuaXguc2h1dGRvd24gZmQgY21kXG5cbmxldCBjbG9zZV9ub3RpZnkgPSBmdW5jdGlvblxuICB8IChfLCBQbGFpbikgYXMgcyAtPlxuICAgICAgc2h1dGRvd24gcyBVbml4LlNIVVRET1dOX1NFTkQ7XG4gICAgICBMd3QucmV0dXJuX3RydWVcbiAgfCAoZmQsIFNTTCBzKSAtPlxuICAgICAgcmVwZWF0X2NhbGwgZmQgKGZ1biAoKSAtPiBTc2wuY2xvc2Vfbm90aWZ5IHMpXG5cbmxldCBjbG9zZSAoZmQsIF8pID0gTHd0X3VuaXguY2xvc2UgZmRcblxubGV0IGFib3J0IChmZCwgXykgPSBMd3RfdW5peC5hYm9ydCBmZFxuXG5sZXQgc2h1dGRvd25fYW5kX2Nsb3NlIHMgPVxuICBzc2xfc2h1dGRvd24gcyA+Pj0gZnVuICgpIC0+XG4gIEx3dC53cmFwMiBzaHV0ZG93biBzIFVuaXguU0hVVERPV05fQUxMID4+PSBmdW4gKCkgLT5cbiAgY2xvc2Ugc1xuXG5sZXQgb3V0X2NoYW5uZWxfb2ZfZGVzY3IgP2J1ZmZlciBzID1cbiAgTHd0X2lvLm1ha2VcbiAgICA/YnVmZmVyXG4gICAgfm1vZGU6THd0X2lvLm91dHB1dFxuICAgIH5jbG9zZTooZnVuICgpIC0+IHNodXRkb3duX2FuZF9jbG9zZSBzKVxuICAgIChmdW4gYnVmIHBvcyBsZW4gLT4gd3JpdGVfYnl0ZXMgcyBidWYgcG9zIGxlbilcblxubGV0IGluX2NoYW5uZWxfb2ZfZGVzY3IgP2J1ZmZlciBzID1cbiAgTHd0X2lvLm1ha2VcbiAgICA/YnVmZmVyXG4gICAgfm1vZGU6THd0X2lvLmlucHV0XG4gICAgfmNsb3NlOihmdW4gKCkgLT4gc2h1dGRvd25fYW5kX2Nsb3NlIHMpXG4gICAgKGZ1biBidWYgcG9zIGxlbiAtPiByZWFkX2J5dGVzIHMgYnVmIHBvcyBsZW4pXG5cbmxldCBnZXRfZmQgKGZkLCBfc29ja2V0KSA9IGZkXG5cbmxldCBnZXRfdW5peF9mZCAoZmQsc29ja2V0KSA9XG4gIG1hdGNoIHNvY2tldCB3aXRoXG4gIHwgUGxhaW4gLT4gTHd0X3VuaXgudW5peF9maWxlX2Rlc2NyIGZkXG4gIHwgU1NMIHNvY2tldCAtPiAoU3NsLmZpbGVfZGVzY3Jfb2Zfc29ja2V0IHNvY2tldClcblxubGV0IGdldHNvY2tuYW1lIHMgPVxuICBVbml4LmdldHNvY2tuYW1lIChnZXRfdW5peF9mZCBzKVxuXG5sZXQgZ2V0cGVlcm5hbWUgcyA9XG4gIFVuaXguZ2V0cGVlcm5hbWUgKGdldF91bml4X2ZkIHMpXG4iXX0=
