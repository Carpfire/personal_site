// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Thread_safe_queue__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Thread_safe_queue = [0],
    Thread_safe_queue$0 = [0, Thread_safe_queue];
   runtime.caml_register_global(0, Thread_safe_queue$0, "Thread_safe_queue__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Thread_safe_queue__Import
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Thread_safe_queue_Import = "Thread_safe_queue__Import",
    cst_thread_safe_queue = "thread_safe_queue";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Thread_safe_queue_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_thread_safe_queue);
   caml_call1(Ppx_expect_runtime[1][1], "thread_safe_queue/src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_thread_safe_queue, "import.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_thread_safe_queue);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Thread_safe_queue_Import);
   var Thread_safe_queue_Import = [0];
   runtime.caml_register_global
    (11, Thread_safe_queue_Import, cst_Thread_safe_queue_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Thread_safe_queue
//# unitInfo: Requires: Base__Invariant, Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Uopt
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Thread_safe_queue$0 = "Thread_safe_queue",
    cst = "_",
    cst_back$0 = "back",
    cst_front$0 = "front",
    cst_length$0 = "length",
    cst_thread_safe_queue$0 = "thread_safe_queue",
    cst_thread_safe_queue_src_thre =
      "thread_safe_queue/src/thread_safe_queue.ml",
    cst_unused_elts$0 = "unused_elts",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Uopt = global_data.Uopt,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Thread_safe_queue$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_thread_safe_queue$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_thread_safe_queue_src_thre);
   caml_call2
    (Ppx_inline_test_lib[6], cst_thread_safe_queue$0, "thread_safe_queue.ml");
   var
    _v_ = [0, cst],
    cst_Thread_safe_queue_dequeue_ =
      "Thread_safe_queue.dequeue_exn of empty queue",
    _w_ = [0, cst_thread_safe_queue_src_thre, 108, 3926, 3944],
    _t_ = [0, cst],
    _s_ = [0, cst_thread_safe_queue_src_thre, 43, 36],
    _q_ = [0, cst_thread_safe_queue_src_thre, 52, 13],
    _r_ = [0, cst_thread_safe_queue_src_thre, 54, 11],
    _p_ = [0, cst_thread_safe_queue_src_thre, 55, 32],
    _o_ = [0, cst_thread_safe_queue_src_thre, 62, 13],
    _u_ = [0, cst_thread_safe_queue_src_thre, 40, 1566, 1588],
    _k_ = [0, cst_unused_elts$0],
    _l_ = [0, cst_back$0],
    _m_ = [0, cst_front$0],
    _n_ = [0, cst_length$0],
    _a_ = [0, "next"],
    _b_ = [0, "value"],
    cst_unused_elts = cst_unused_elts$0,
    cst_back = cst_back$0,
    cst_front = cst_front$0,
    cst_length = cst_length$0,
    cst_thread_safe_queue = cst_thread_safe_queue$0,
    cst_Thread_safe_queue = cst_Thread_safe_queue$0;
   function sexp_of_t(of_a_001, param){
    var
     value_003 = param[1],
     next_005 = param[2],
     arg_006 = caml_call1(Sexplib0_Sexp_conv[23], next_005),
     bnds_002 = [0, [1, [0, _a_, [0, arg_006, 0]]], 0],
     arg_004 = caml_call2(Uopt[2], of_a_001, value_003),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_004, 0]]], bnds_002];
    return [1, bnds_002$0];
   }
   function create(param){return [0, Uopt[5], Uopt[5]];}
   function unused_elts(r){return r[4];}
   function set_unused_elts(r, v){r[4] = v; return 0;}
   function back(r){return r[3];}
   function set_back(r, v){r[3] = v; return 0;}
   function front(r){return r[2];}
   function set_front(r, v){r[2] = v; return 0;}
   function length(r){return r[1];}
   function set_length(r, v){r[1] = v; return 0;}
   function _c_(r, v){return [0, r[1], r[2], r[3], v];}
   var
    _d_ = [0, set_unused_elts],
    unused_elts$0 =
      [0, function(param){return 0;}, cst_unused_elts, _d_, unused_elts, _c_];
   function _e_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _f_ = [0, set_back],
    back$0 = [0, function(param){return 0;}, cst_back, _f_, back, _e_];
   function _g_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _h_ = [0, set_front],
    front$0 = [0, function(param){return 0;}, cst_front, _h_, front, _g_];
   function _i_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _j_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _j_, length, _i_];
   function sexp_of_t$0(of_a_007, param){
    var
     length_009 = param[1],
     front_011 = param[2],
     back_013 = param[3],
     unused_elts_015 = param[4],
     bnds_008 = 0;
    function _C_(_D_){return sexp_of_t(of_a_007, _D_);}
    var
     arg_016 = caml_call2(Uopt[2], _C_, unused_elts_015),
     bnds_008$0 = [0, [1, [0, _k_, [0, arg_016, 0]]], bnds_008],
     arg_014 = sexp_of_t(of_a_007, back_013),
     bnds_008$1 = [0, [1, [0, _l_, [0, arg_014, 0]]], bnds_008$0],
     arg_012 = sexp_of_t(of_a_007, front_011),
     bnds_008$2 = [0, [1, [0, _m_, [0, arg_012, 0]]], bnds_008$1],
     arg_010 = caml_call1(Core[389], length_009),
     bnds_008$3 = [0, [1, [0, _n_, [0, arg_010, 0]]], bnds_008$2];
    return [1, bnds_008$3];
   }
   function invariant(invariant_a, t){
    function _A_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      unused_elts_fun =
        check
         (function(unused_elts){
           var r = [0, unused_elts];
           for(;;){
            if(! caml_call1(Uopt[8], r[1])) return 0;
            var elt = caml_call1(Uopt[9], r[1]);
            r[1] = elt[2];
            if(! caml_call1(Uopt[7], elt[1]))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
           }
          }),
      back_fun =
        check
         (function(back){
           if(caml_call1(Uopt[7], back[1])) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
          }),
      front_fun =
        check
         (function(front){
           var i = [0, t[1]], r = [0, front];
           for(;;){
            if(! caml_call2(Core[91], i[1], 0)){
             if(r[1] === t[3]) return 0;
             throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
            }
            i[1] += -1;
            var elt = r[1];
            r[1] = caml_call1(Uopt[9], elt[2]);
            if(! caml_call1(Uopt[8], elt[1]))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
           }
          }),
      length_fun =
        check
         (function(length){
           if(caml_call2(Core[88], length, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
          });
     caml_call1(length_fun, length$0);
     caml_call1(front_fun, front$0);
     caml_call1(back_fun, back$0);
     return caml_call1(unused_elts_fun, unused_elts$0);
    }
    function _B_(x_017){
     return sexp_of_t$0(function(param){return _t_;}, x_017);
    }
    return caml_call4(Base_Invariant[1], _u_, t, _B_, _A_);
   }
   function create$0(param){
    var elt = create(0);
    return [0, 0, elt, elt, Uopt[5]];
   }
   function enqueue(t, a){
    if(caml_call1(Uopt[8], t[4])){
     var elt = caml_call1(Uopt[12], t[4]);
     t[4] = elt[2];
     var new_back = elt;
    }
    else
     var new_back = create(0);
    t[1] = t[1] + 1 | 0;
    var _y_ = caml_call1(Uopt[6], a);
    t[3][1] = _y_;
    var _z_ = caml_call1(Uopt[6], new_back);
    t[3][2] = _z_;
    t[3] = new_back;
    return 0;
   }
   function dequeue_exn(t){
    if(caml_call2(Core[90], t[1], 0)){
     var
      _x_ =
        function(x_018){
         return sexp_of_t$0(function(param){return _v_;}, x_018);
        };
     caml_call5(Core[247], 0, _w_, cst_Thread_safe_queue_dequeue_, t, _x_);
    }
    var elt = t[2], a = elt[1];
    t[2] = caml_call1(Uopt[12], elt[2]);
    t[1] = t[1] - 1 | 0;
    elt[1] = Uopt[5];
    elt[2] = t[4];
    t[4] = caml_call1(Uopt[6], elt);
    return caml_call1(Uopt[12], a);
   }
   function clear_internal_pool(t){t[4] = Uopt[5]; return 0;}
   caml_call1(Ppx_inline_test_lib[7], cst_thread_safe_queue);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Thread_safe_queue);
   var
    Thread_safe_queue =
      [0,
       sexp_of_t$0,
       invariant,
       create$0,
       length,
       enqueue,
       dequeue_exn,
       clear_internal_pool,
       [0, [0, Uopt[2], Uopt[5], Uopt[6], Uopt[7], Uopt[8]]]];
   runtime.caml_register_global
    (36, Thread_safe_queue, cst_Thread_safe_queue$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aHJlYWRfc2FmZV9xdWV1ZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90Iiwib2ZfYV8wMDEiLCJ2YWx1ZV8wMDMiLCJuZXh0XzAwNSIsImFyZ18wMDYiLCJibmRzXzAwMiIsImFyZ18wMDQiLCJibmRzXzAwMiQwIiwiY3JlYXRlIiwidW51c2VkX2VsdHMiLCJyIiwic2V0X3VudXNlZF9lbHRzIiwidiIsImJhY2siLCJzZXRfYmFjayIsImZyb250Iiwic2V0X2Zyb250IiwibGVuZ3RoIiwic2V0X2xlbmd0aCIsInVudXNlZF9lbHRzJDAiLCJiYWNrJDAiLCJmcm9udCQwIiwibGVuZ3RoJDAiLCJzZXhwX29mX3QkMCIsIm9mX2FfMDA3IiwibGVuZ3RoXzAwOSIsImZyb250XzAxMSIsImJhY2tfMDEzIiwidW51c2VkX2VsdHNfMDE1IiwiYm5kc18wMDgiLCJhcmdfMDE2IiwiYm5kc18wMDgkMCIsImFyZ18wMTQiLCJibmRzXzAwOCQxIiwiYXJnXzAxMiIsImJuZHNfMDA4JDIiLCJhcmdfMDEwIiwiYm5kc18wMDgkMyIsImludmFyaWFudCIsImludmFyaWFudF9hIiwidCIsImNoZWNrIiwiZiIsInVudXNlZF9lbHRzX2Z1biIsImVsdCIsImJhY2tfZnVuIiwiZnJvbnRfZnVuIiwiaSIsImxlbmd0aF9mdW4iLCJ4XzAxNyIsImNyZWF0ZSQwIiwiZW5xdWV1ZSIsImEiLCJuZXdfYmFjayIsImRlcXVldWVfZXhuIiwieF8wMTgiLCJjbGVhcl9pbnRlcm5hbF9wb29sIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY29yZV9rZXJuZWwvdGhyZWFkX3NhZmVfcXVldWUvdGhyZWFkX3NhZmVfcXVldWVfXy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NvcmVfa2VybmVsL3RocmVhZF9zYWZlX3F1ZXVlL3RocmVhZF9zYWZlX3F1ZXVl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WUFHZFU7SUFDUSxJQUFOTixNQTNDQXBDO0lBNENKLGNBRElvQyxLQUFBQTtHQUM0RDtZQWtCWk8sUUFBa0JYLEdBQVVZO0lBQ2hGLEdBWEcsb0JBVW1FWjtLQVIxRCxJQUFOSSxNQUFNLHFCQVEwREo7S0FBQUEsT0FSaEVJO1NBU0ZTLFdBVEVUOzs7U0FTRlMsV0EvREE3QztJQThEa0VnQyxPQUFBQTtJQUl0RCxVQUFBLG9CQUpnRVk7SUFBVlo7SUFLdkQsVUFBQSxvQkFKWGE7SUFEa0ViO0lBQUFBLE9BQ2xFYTs7R0FLYztZQW1Ca0NDLFlBQVlkO0lBRWhFLEdBQUcscUJBRjZEQTs7O2lCQUhvQmU7UyxPQWpGdEZoQyw0QixjQWlGc0ZnQzs7bUVBR3BCZjs7SUFJaEUsSUFqQnlFSSxNQWFUSixNQUk1RFksSUFqQnFFUjtJQWFUSixPQUtyRCxxQkFsQjhESTtJQWFUSixPQUFBQTtJQWJTSTtJQUFBQSxTQWFUSjtJQUFBQSxPQVQvQyxvQkFKd0RJO0lBcUJ6RSxPQUFBLHFCQUpJUTtHQUtlO1lBR2pCSSxvQkFBb0JoQixHQUFBQSx5QkFBOEI7Ozs7Ozs7O09BaEd0RGpCO09BWUllO09BMkJBWTtPQXRDUWpDO09BMEQwQ2tDO09BeUJBRztPQVlsREU7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBUaHJlYWRfc2FmZV9xdWV1ZS5JbXBvcnQgKilcbm1vZHVsZSBJbXBvcnQgPSBUaHJlYWRfc2FmZV9xdWV1ZV9fSW1wb3J0XG5cbm1vZHVsZSBUaHJlYWRfc2FmZV9xdWV1ZV9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCIoKiBUaGlzIG1vZHVsZSBleHBsb2l0cyB0aGUgZmFjdCB0aGF0IE9DYW1sIGRvZXMgbm90IHBlcmZvcm0gY29udGV4dC1zd2l0Y2hlcyB1bmRlclxuICAgY2VydGFpbiBjb25kaXRpb25zLiAgSXQgY2FuIHRoZXJlZm9yZSBhdm9pZCB1c2luZyBtdXRleGVzLlxuXG4gICBHaXZlbiB0aGUgc2VtYW50aWNzIG9mIHRoZSBjdXJyZW50IE9DYW1sIHJ1bnRpbWUgKGFuZCBmb3IgdGhlIGZvcmVzZWVhYmxlIGZ1dHVyZSksIGNvZGVcbiAgIHNlY3Rpb25zIGRvY3VtZW50ZWQgYXMgYXRvbWljIGJlbG93IHdpbGwgbmV2ZXIgY29udGFpbiBhIGNvbnRleHQtc3dpdGNoLiAgVGhlIGRlY2lkaW5nXG4gICBjcml0ZXJpb24gaXMgd2hldGhlciB0aGV5IGNvbnRhaW4gYWxsb2NhdGlvbnMgb3IgY2FsbHMgdG8gZXh0ZXJuYWwvYnVpbHRpbiBmdW5jdGlvbnMuXG4gICBJZiB0aGVyZSBpcyBub25lLCBhIGNvbnRleHQtc3dpdGNoIGNhbm5vdCBoYXBwZW4uICBBc3NpZ25tZW50cyB3aXRob3V0IGFsbG9jYXRpb25zLFxuICAgZmllbGQgYWNjZXNzLCBwYXR0ZXJuLW1hdGNoaW5nLCBldGMuLCBkbyBub3QgdHJpZ2dlciBjb250ZXh0LXN3aXRjaGVzLlxuXG4gICBDb2RlIHJldmlld2VycyBzaG91bGQgdGhlcmVmb3JlIG1ha2Ugc3VyZSB0aGF0IHRoZSBzZWN0aW9ucyBkb2N1bWVudGVkIGFzIGF0b21pYyBiZWxvd1xuICAgZG8gbm90IHZpb2xhdGUgdGhlIGFib3ZlIGFzc3VtcHRpb25zLiAgSXQgaXMgcHJ1ZGVudCB0byBkaXNhc3NlbWJsZSB0aGUgLm8gZmlsZSAodXNpbmdcbiAgIFtvYmpkdW1wIC1kcl0pIGFuZCBleGFtaW5lIGl0LiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEVsdCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgbXV0YWJsZSB2YWx1ZSA6ICdhIFVvcHQudFxuICAgIDsgbXV0YWJsZSBuZXh0IDogKCdhIHQgVW9wdC50W0BzZXhwLm9wYXF1ZV0pXG4gICAgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBjcmVhdGUgKCkgPSB7IHZhbHVlID0gVW9wdC5ub25lOyBuZXh0ID0gVW9wdC5ub25lIH1cbmVuZFxuXG50eXBlICdhIHQgPVxuICB7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gICAgICAoKiBbZnJvbnRdIHRvIFtiYWNrXSBoYXMgW2xlbmd0aCArIDFdIGxpbmtlZCBlbGVtZW50cywgd2hlcmUgdGhlIGZpcnN0IFtsZW5ndGhdIGhvbGQgdGhlXG4gICAgIHZhbHVlcyBpbiB0aGUgcXVldWUsIGFuZCB0aGUgbGFzdCBpcyBbYmFja10sIGhvbGRpbmcgbm8gdmFsdWUuICopXG4gIDsgbXV0YWJsZSBmcm9udCA6ICdhIEVsdC50XG4gIDsgbXV0YWJsZSBiYWNrIDogJ2EgRWx0LnRcbiAgICAgICgqIFt1bnVzZWRfZWx0c10gaXMgc2luZ2x5IGxpbmtlZCB2aWEgW25leHRdLCBhbmQgZW5kcyB3aXRoIFtzZW50aW5lbF0uICBBbGwgZWx0cyBpblxuICAgICBbdW51c2VkX2VsdHNdIGhhdmUgW1VvcHQuaXNfbm9uZSBlbHQudmFsdWVdLiAqKVxuICA7IG11dGFibGUgdW51c2VkX2VsdHMgOiAnYSBFbHQudCBVb3B0LnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBfaW52YXJpYW50X2EgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5sZW5ndGg6KGNoZWNrIChmdW4gbGVuZ3RoIC0+IGFzc2VydCAobGVuZ3RoID49IDApKSlcbiAgICAgIH5mcm9udDpcbiAgICAgICAgKGNoZWNrIChmdW4gZnJvbnQgLT5cbiAgICAgICAgICAgbGV0IGkgPSByZWYgdC5sZW5ndGggaW5cbiAgICAgICAgICAgbGV0IHIgPSByZWYgZnJvbnQgaW5cbiAgICAgICAgICAgd2hpbGUgIWkgPiAwIGRvXG4gICAgICAgICAgICAgZGVjciBpO1xuICAgICAgICAgICAgIGxldCBlbHQgPSAhciBpblxuICAgICAgICAgICAgIHIgOj0gVW9wdC52YWx1ZV9leG4gZWx0LkVsdC5uZXh0O1xuICAgICAgICAgICAgIGFzc2VydCAoVW9wdC5pc19zb21lIGVsdC52YWx1ZSlcbiAgICAgICAgICAgZG9uZTtcbiAgICAgICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsICFyIHQuYmFjaykpKVxuICAgICAgfmJhY2s6KGNoZWNrIChmdW4gYmFjayAtPiBhc3NlcnQgKFVvcHQuaXNfbm9uZSBiYWNrLkVsdC52YWx1ZSkpKVxuICAgICAgfnVudXNlZF9lbHRzOlxuICAgICAgICAoY2hlY2sgKGZ1biB1bnVzZWRfZWx0cyAtPlxuICAgICAgICAgICBsZXQgciA9IHJlZiB1bnVzZWRfZWx0cyBpblxuICAgICAgICAgICB3aGlsZSBVb3B0LmlzX3NvbWUgIXIgZG9cbiAgICAgICAgICAgICBsZXQgZWx0ID0gVW9wdC52YWx1ZV9leG4gIXIgaW5cbiAgICAgICAgICAgICByIDo9IGVsdC5FbHQubmV4dDtcbiAgICAgICAgICAgICBhc3NlcnQgKFVvcHQuaXNfbm9uZSBlbHQudmFsdWUpXG4gICAgICAgICAgIGRvbmUpKSlcbjs7XG5cbmxldCBjcmVhdGUgKCkgPVxuICBsZXQgZWx0ID0gRWx0LmNyZWF0ZSAoKSBpblxuICB7IGZyb250ID0gZWx0OyBiYWNrID0gZWx0OyBsZW5ndGggPSAwOyB1bnVzZWRfZWx0cyA9IFVvcHQubm9uZSB9XG47O1xuXG4oKiBUaGlzIGRvZXNuJ3QgYWN0dWFsbHkgbmVlZCB0aGUgYXR0cmlidXRlcyB0byBlbnN1cmUgYXRvbWljIHNlbWFudGljcyxcbiAgIGJ1dCBpZiBpdCB3ZXJlIHVzZWQgaW4gbW9yZSBwbGFjZXMgKG9yIGV4cG9zZWQgaW4gdGhlIC5tbGkpIGl0IGNvdWxkXG4gICB3ZWxsIGRvLCBzbyB3ZSBwdXQgdGhlIGF0dHJpYnV0ZSBvbiBub3cuICopXG5sZXRbQGlubGluZSBuZXZlcl0gW0BzcGVjaWFsaXNlIG5ldmVyXSBbQGxvY2FsIG5ldmVyXSBnZXRfdW51c2VkX2VsdCB0ID1cbiAgKCogQkVHSU4gQVRPTUlDIFNFQ1RJT04gKilcbiAgaWYgVW9wdC5pc19zb21lIHQudW51c2VkX2VsdHNcbiAgdGhlbiAoXG4gICAgbGV0IGVsdCA9IFVvcHQudW5zYWZlX3ZhbHVlIHQudW51c2VkX2VsdHMgaW5cbiAgICB0LnVudXNlZF9lbHRzIDwtIGVsdC5uZXh0O1xuICAgIGVsdCAoKiBFTkQgQVRPTUlDIFNFQ1RJT04gKikpXG4gIGVsc2UgRWx0LmNyZWF0ZSAoKVxuOztcblxuKCogTWFya2VkIHdpdGggYXR0cmlidXRlcyBzbyBhbnkgYWxsb2NhdGlvbiBhdCB0aGUgY2FsbCBzaXRlIGNhbm5vdCBiZSBzdW5rIGRvd24gaW50byB0aGVcbiAgIGF0b21pYyBzZWN0aW9uICh0aGVyZSBleGlzdHMgbm8gYmFycmllciBpbiBPQ2FtbCByaWdodCBub3cgdG8gcHJldmVudCB0aGlzKSAqKVxubGV0W0BpbmxpbmUgbmV2ZXJdIFtAc3BlY2lhbGlzZSBuZXZlcl0gW0Bsb2NhbCBuZXZlcl0gZW5xdWV1ZSAodHlwZSBhKSAodCA6IGEgdCkgKGEgOiBhKSA9XG4gIGxldCBuZXdfYmFjayA9IGdldF91bnVzZWRfZWx0IHQgaW5cbiAgKCogQkVHSU4gQVRPTUlDIFNFQ1RJT04gKilcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxO1xuICB0LmJhY2sudmFsdWUgPC0gVW9wdC5zb21lIGE7XG4gIHQuYmFjay5uZXh0IDwtIFVvcHQuc29tZSBuZXdfYmFjaztcbiAgdC5iYWNrIDwtIG5ld19iYWNrXG47O1xuXG4oKiBFTkQgQVRPTUlDIFNFQ1RJT04gKilcblxuKCogU2FtZSBjb21tZW50IGFib3V0IFtAaW5saW5lIG5ldmVyXVtAc3BlY2lhbGlzZSBuZXZlcl1bQGxvY2FsIG5ldmVyXSBhcyBmb3IgW2dldF91bnVzZWRfZWx0XSwgYWJvdmUuICopXG5sZXRbQGlubGluZSBuZXZlcl0gW0BzcGVjaWFsaXNlIG5ldmVyXSBbQGxvY2FsIG5ldmVyXSByZXR1cm5fdW51c2VkX2VsdCB0IChlbHQgOiBfIEVsdC50KSA9XG4gICgqIEJFR0lOIEFUT01JQyBTRUNUSU9OICopXG4gIGVsdC52YWx1ZSA8LSBVb3B0Lm5vbmU7XG4gIGVsdC5uZXh0IDwtIHQudW51c2VkX2VsdHM7XG4gIHQudW51c2VkX2VsdHMgPC0gVW9wdC5zb21lIGVsdDtcbiAgKCogRU5EIEFUT01JQyBTRUNUSU9OICopXG4gICgpXG47O1xuXG5sZXRbQGlubGluZSBuZXZlcl0gW0BzcGVjaWFsaXNlIG5ldmVyXSBbQGxvY2FsIG5ldmVyXSByYWlzZV9kZXF1ZXVlX2VtcHR5IHQgPVxuICBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcIlRocmVhZF9zYWZlX3F1ZXVlLmRlcXVldWVfZXhuIG9mIGVtcHR5IHF1ZXVlXCIgdCBbJXNleHBfb2Y6IF8gdF1cbjs7XG5cbmxldFtAaW5saW5lIG5ldmVyXSBbQHNwZWNpYWxpc2UgbmV2ZXJdIFtAbG9jYWwgbmV2ZXJdIGRlcXVldWVfZXhuIHQgPVxuICAoKiBCRUdJTiBBVE9NSUMgU0VDVElPTiAqKVxuICBpZiB0Lmxlbmd0aCA9IDAgdGhlbiByYWlzZV9kZXF1ZXVlX2VtcHR5IHQ7XG4gIGxldCBlbHQgPSB0LmZyb250IGluXG4gIGxldCBhID0gZWx0LnZhbHVlIGluXG4gIHQuZnJvbnQgPC0gVW9wdC51bnNhZmVfdmFsdWUgZWx0Lm5leHQ7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMTtcbiAgKCogRU5EIEFUT01JQyBTRUNUSU9OICopXG4gIHJldHVybl91bnVzZWRfZWx0IHQgZWx0O1xuICBVb3B0LnVuc2FmZV92YWx1ZSBhXG47O1xuXG5sZXQgY2xlYXJfaW50ZXJuYWxfcG9vbCB0ID0gdC51bnVzZWRfZWx0cyA8LSBVb3B0Lm5vbmVcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFVvcHQgPSBVb3B0XG5lbmRcbiJdfQ==
