// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Overlap__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Overlap = [0];
   runtime.caml_register_global(0, Overlap, "Overlap__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Overlap__Overlap_stubs
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Overlap_Overlap_stubs = [0];
   runtime.caml_register_global
    (0, Overlap_Overlap_stubs, "Overlap__Overlap_stubs");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Overlap
//# unitInfo: Requires: Overlap__Overlap_stubs, Stdlib, Stdlib__Array, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_overlap_ml = "lib/overlap.ml",
    caml_ba_dim = runtime.caml_ba_dim,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_num_dims = runtime.caml_ba_num_dims,
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mod = runtime.caml_mod;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    c_nth_dims = caml_ba_dim,
    _d_ = [0, cst_lib_overlap_ml, 72, 14],
    _c_ = [0, cst_lib_overlap_ml, 67, 14],
    _b_ = [0, cst_lib_overlap_ml, 62, 14],
    _a_ = [0, cst_lib_overlap_ml, 57, 14],
    cst_Bigarray_Genarray_overlap = "Bigarray.Genarray.overlap";
   function fortran_nth_dims(a, i){
    return caml_ba_dim(a, (caml_ba_num_dims(a) - i | 0) - 1 | 0);
   }
   function genarray(a, b){
    var
     nth_dim = runtime.caml_ba_layout(a) ? fortran_nth_dims : c_nth_dims,
     _o_ = caml_ba_num_dims(b);
    if(caml_ba_num_dims(a) !== _o_)
     caml_call1(Stdlib[1], cst_Bigarray_Genarray_overlap);
    var
     src_a = runtime.overlap_bytecode_caml_ba_ptr(a),
     src_b = runtime.overlap_bytecode_caml_ba_ptr(b),
     len_a = caml_call1(Stdlib_Bigarray[17][3], a),
     len_b = caml_call1(Stdlib_Bigarray[17][3], b),
     _p_ = caml_call2(Stdlib[17], src_a, src_b),
     _q_ =
       caml_call2(Stdlib[16], src_a + len_a | 0, src_b + len_b | 0) - _p_ | 0,
     len = caml_call2(Stdlib[17], 0, _q_),
     _r_ = caml_ba_kind(a),
     len$0 = caml_div(len, caml_call1(Stdlib_Bigarray[14], _r_));
    if
     (caml_greaterequal(src_a, src_b)
      && caml_lessthan(src_a, src_b + len_b | 0)){
     var
      _s_ = caml_ba_kind(a),
      offset =
        [0, caml_div(src_a - src_b | 0, caml_call1(Stdlib_Bigarray[14], _s_))],
      points = caml_make_vect(caml_ba_num_dims(b), 0),
      _t_ = caml_ba_num_dims(b) - 1 | 0;
     if(_t_ >= 0){
      var i = _t_;
      for(;;){
       var _u_ = nth_dim(b, i), _v_ = caml_mod(offset[1], _u_);
       caml_check_bound(points, i)[1 + i] = _v_;
       var _w_ = nth_dim(b, i);
       offset[1] = caml_div(offset[1], _w_);
       var _x_ = i - 1 | 0;
       if(0 === i) break;
       var i = _x_;
      }
     }
     return [0, [0, len$0, caml_make_vect(caml_ba_num_dims(a), 0), points]];
    }
    if
     (caml_greaterequal(src_b, src_a)
      && caml_lessthan(src_b, src_a + len_a | 0)){
     var
      _y_ = caml_ba_kind(b),
      offset$0 =
        [0, caml_div(src_b - src_a | 0, caml_call1(Stdlib_Bigarray[14], _y_))],
      points$0 = caml_make_vect(caml_ba_num_dims(a), 0),
      _z_ = caml_ba_num_dims(a) - 1 | 0;
     if(_z_ >= 0){
      var i$0 = _z_;
      for(;;){
       var _A_ = nth_dim(a, i$0), _B_ = caml_mod(offset$0[1], _A_);
       caml_check_bound(points$0, i$0)[1 + i$0] = _B_;
       var _C_ = nth_dim(a, i$0);
       offset$0[1] = caml_div(offset$0[1], _C_);
       var _D_ = i$0 - 1 | 0;
       if(0 === i$0) break;
       var i$0 = _D_;
      }
     }
     return [0, [0, len$0, points$0, caml_make_vect(caml_ba_num_dims(b), 0)]];
    }
    return 0;
   }
   function array0(a, b){
    var match = genarray(a, b);
    if(! match) return 0;
    var _n_ = match[1];
    if(1 === _n_[1] && ! (_n_[2].length - 1)){
     var len = _n_[3].length - 1;
     if(! len) return 1;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function array1(a, b){
    var match = genarray(a, b);
    if(! match) return 0;
    var _k_ = match[1], _l_ = _k_[2];
    if(1 === _l_.length - 1){
     var x = _l_[1], match$0 = _k_[3], len = match$0.length - 1, _m_ = _k_[1];
     if(1 === len){var y = match$0[1]; return [0, [0, _m_, x, y]];}
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function array2(a, b){
    var match = genarray(a, b);
    if(! match) return 0;
    var _h_ = match[1], _i_ = _h_[2];
    if(2 === _i_.length - 1){
     var
      x = _i_[1],
      y = _i_[2],
      match$0 = _h_[3],
      len = match$0.length - 1,
      _j_ = _h_[1];
     if(2 === len){
      var a$0 = match$0[1], b$0 = match$0[2];
      return [0, [0, _j_, [0, x, y], [0, a$0, b$0]]];
     }
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function array3(a, b){
    var match = genarray(a, b);
    if(! match) return 0;
    var _e_ = match[1], _f_ = _e_[2];
    if(3 === _f_.length - 1){
     var
      x = _f_[1],
      y = _f_[2],
      z = _f_[3],
      match$0 = _e_[3],
      len = match$0.length - 1,
      _g_ = _e_[1];
     if(3 === len){
      var a$0 = match$0[1], b$0 = match$0[2], c = match$0[3];
      return [0, [0, _g_, [0, x, y, z], [0, a$0, b$0, c]]];
     }
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
   }
   var Overlap = [0, genarray, array0, array1, array2, array3];
   runtime.caml_register_global(9, Overlap, "Overlap");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJvdmVybGFwLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJjX250aF9kaW1zIiwiZm9ydHJhbl9udGhfZGltcyIsImEiLCJpIiwiZ2VuYXJyYXkiLCJiIiwibnRoX2RpbSIsInNyY19hIiwic3JjX2IiLCJsZW5fYSIsImxlbl9iIiwibGVuIiwibGVuJDAiLCJvZmZzZXQiLCJwb2ludHMiLCJvZmZzZXQkMCIsInBvaW50cyQwIiwiaSQwIiwiYXJyYXkwIiwiYXJyYXkxIiwieCIsInkiLCJhcnJheTIiLCJhJDAiLCJiJDAiLCJhcnJheTMiLCJ6IiwiYyJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2JpZ2FycmF5LW92ZXJsYXAvb3ZlcmxhcC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7O0lBR0lBOzs7Ozs7WUFDQUMsaUJBQWlCQyxHQUFFQztJQUFJLE9BQUEsWUFBTkQsSUFBMEIsaUJBQTFCQSxLQUFFQztHQUFvRDtZQUV2RUMsU0FLSUYsR0FBRUc7SUFDUjtLQUFJQyxVQUFnQix1QkFEZEosS0FQSkQsbUJBREFEO0tBWTBCLE1BQUEsaUJBSnBCSztPQUlMLGlCQUpHSDtLQUtEO0lBRU87S0FBUkssUUFBUSxxQ0FQTkw7S0FRRk0sUUFBUSxxQ0FSSkg7S0FTSkksUUFBeUIsbUNBVHZCUDtLQVVGUSxRQUF5QixtQ0FWckJMO0tBZXdDLE1BQUEsdUJBUjVDRSxPQUNBQztLQU9LO09BQUMsdUJBUk5ELFFBRUFFLFdBREFELFFBRUFFO0tBTUFDLE1BREY7S0FFaUMsTUFBQSxhQWpCN0JUO0tBaUJGVSxpQkFEQUQsS0FDWTtJQUVLO01BQWxCLGtCQVpDSixPQUNBQztTQVdpQixjQVpqQkQsT0FDQUMsUUFFQUU7S0FZcUM7TUFBQSxNQUFBLGFBdEJuQ1I7TUFxQkFXO3FCQWRGTixRQUNBQyxXQWNrQjtNQUNoQk0sU0FBUyxlQUFXLGlCQXZCbEJUO01Bd0JFLE1BQUEsaUJBeEJGQTs7VUF3Qk5GOztPQUU0QixJQUFBLE1BekIxQkcsUUFESUQsR0F3Qk5GLG1CQUhJVTtPQUtGLGlCQUhFQyxRQUNKWCxPQUFBQTtPQUdzQixVQTFCcEJHLFFBRElELEdBd0JORjtPQUhJVSxxQkFBQUE7T0FHSSxVQUFSVjtnQkFBQUE7V0FBQUE7OztLQUtBLGVBWkVTLE9BWVMsZUFBVyxpQkE3QmxCVixRQXVCQVk7O0lBT3dCO01BQWxCLGtCQXRCUk4sT0FEQUQ7U0F1QjBCLGNBdEIxQkMsT0FEQUQsUUFFQUU7S0F3QnFDO01BQUEsTUFBQSxhQWpDakNKO01BZ0NGVTtxQkF4QkZQLFFBREFELFdBMEJrQjtNQUNoQlMsV0FBUyxlQUFXLGlCQWxDcEJkO01BbUNJLE1BQUEsaUJBbkNKQTs7VUFtQ0plOztPQUU0QixJQUFBLE1BcEMxQlgsUUFERUosR0FtQ0plLHFCQUhJRjtPQUtGLGlCQUhFQyxVQUNKQyxTQUFBQTtPQUdzQixVQXJDcEJYLFFBREVKLEdBbUNKZTtPQUhJRix1QkFBQUE7T0FHSSxVQUFSRTtnQkFBQUE7V0FBQUE7OztLQUtBLGVBdkJFTCxPQWlCRUksVUFNZSxlQUFXLGlCQXhDeEJYOztJQXlDQztHQUFJO1lBRVhhLE9BQU9oQixHQUFFRztJQUFVLFlBaERuQkQsU0FnRE9GLEdBQUVHO2dCQUdEOzs7O2VBRmdCOztJQUNkLE1BQUE7R0FDRztZQUViYyxPQUFPakIsR0FBRUc7SUFBVSxZQXJEbkJELFNBcURPRixHQUFFRztnQkFHRDs7O1NBRk1lO3VCQUFTQyxnQkFBUyxvQkFBbEJELEdBQVNDOztJQUNiLE1BQUE7R0FDRTtZQUVaQyxPQUFPcEIsR0FBRUc7SUFBVSxZQTFEbkJELFNBMERPRixHQUFFRztnQkFHRDs7OztNQUZNZTtNQUFHQzs7Ozs7VUFBVUUsa0JBQUdDO01BQVUsd0JBQTFCSixHQUFHQyxRQUFVRSxLQUFHQzs7O0lBQ3BCLE1BQUE7R0FDRTtZQUVaQyxPQUFPdkIsR0FBRUc7SUFBVSxZQS9EbkJELFNBK0RPRixHQUFFRztnQkFHRDs7OztNQUZNZTtNQUFHQztNQUFHSzs7Ozs7VUFBVUgsa0JBQUdDLGtCQUFHRztNQUFVLHdCQUFoQ1AsR0FBR0MsR0FBR0ssUUFBVUgsS0FBR0MsS0FBR0c7OztJQUMxQixNQUFBO0dBQ0U7cUJBbEVadkIsVUFnREFjLFFBS0FDLFFBS0FHLFFBS0FHOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4gT3ZlcmxhcF9zdHVic1xub3BlbiBCaWdhcnJheVxuXG5sZXQgY19udGhfZGltcyBhIGkgPSBHZW5hcnJheS5udGhfZGltIGEgaVxubGV0IGZvcnRyYW5fbnRoX2RpbXMgYSBpID0gR2VuYXJyYXkubnRoX2RpbSBhIChHZW5hcnJheS5udW1fZGltcyBhIC0gaSAtIDEpXG5cbmxldCBnZW5hcnJheVxuICA6IHR5cGUgYy5cbiAgICAoJ2EsICdiLCBjKSBHZW5hcnJheS50IC0+XG4gICAgKCdhLCAnYiwgYykgR2VuYXJyYXkudCAtPlxuICAgIChpbnQgKiBpbnQgYXJyYXkgKiBpbnQgYXJyYXkpIG9wdGlvblxuICA9IGZ1biBhIGIgLT5cbiAgbGV0IG50aF9kaW0gPSBtYXRjaCBHZW5hcnJheS5sYXlvdXQgYSAoKiA9IGxheW91dCBiICopIHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfbnRoX2RpbXNcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5fbnRoX2RpbXMgaW5cbiAgaWYgKEdlbmFycmF5Lm51bV9kaW1zIGEpIDw+IChHZW5hcnJheS5udW1fZGltcyBiKVxuICB0aGVuIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuR2VuYXJyYXkub3ZlcmxhcFwiIDtcblxuICBsZXQgc3JjX2EgPSBwdHIgYSBpblxuICBsZXQgc3JjX2IgPSBwdHIgYiBpblxuICBsZXQgbGVuX2EgPSBOYXRpdmVpbnQub2ZfaW50IChHZW5hcnJheS5zaXplX2luX2J5dGVzIGEpIGluXG4gIGxldCBsZW5fYiA9IE5hdGl2ZWludC5vZl9pbnQgKEdlbmFycmF5LnNpemVfaW5fYnl0ZXMgYikgaW5cblxuICBsZXQgbGVuID1cbiAgICBsZXQgKCArICkgPSBOYXRpdmVpbnQuYWRkIGluXG4gICAgbGV0ICggLSApID0gTmF0aXZlaW50LnN1YiBpblxuICAgIG1heCAwbiAobWluIChzcmNfYSArIGxlbl9hKSAoc3JjX2IgKyBsZW5fYikgLSBtYXggc3JjX2Egc3JjX2IpIGluXG4gIGxldCBsZW4gPSBOYXRpdmVpbnQudG9faW50IGxlbiBpblxuICBsZXQgbGVuID0gbGVuIC8ga2luZF9zaXplX2luX2J5dGVzIChHZW5hcnJheS5raW5kIGEpIGluXG5cbiAgaWYgc3JjX2EgPj0gc3JjX2IgJiYgc3JjX2EgPCBOYXRpdmVpbnQuYWRkIHNyY19iIGxlbl9iXG4gIHRoZW4gYmVnaW5cbiAgICBsZXQgb2Zmc2V0ID0gcmVmICgoTmF0aXZlaW50LnRvX2ludCAoTmF0aXZlaW50LnN1YiBzcmNfYSBzcmNfYikpXG4gICAgICAgICAgICAgICAgICAgICAgLyBraW5kX3NpemVfaW5fYnl0ZXMgKEdlbmFycmF5LmtpbmQgYSkpIGluXG4gICAgbGV0IHBvaW50cyA9IEFycmF5Lm1ha2UgKEdlbmFycmF5Lm51bV9kaW1zIGIpIDAgaW5cbiAgICBmb3IgaSA9IEdlbmFycmF5Lm51bV9kaW1zIGIgLSAxIGRvd250byAwXG4gICAgZG9cbiAgICAgIHBvaW50cy4oaSkgPC0gIW9mZnNldCBtb2QgKG50aF9kaW0gYiBpKTtcbiAgICAgIG9mZnNldCA6PSAhb2Zmc2V0IC8gKG50aF9kaW0gYiBpKTtcbiAgICBkb25lIDtcbiAgICBTb21lIChsZW4sIEFycmF5Lm1ha2UgKEdlbmFycmF5Lm51bV9kaW1zIGEpIDAsIHBvaW50cylcbiAgZW5kIGVsc2UgaWYgc3JjX2IgPj0gc3JjX2EgJiYgc3JjX2IgPCBOYXRpdmVpbnQuYWRkIHNyY19hIGxlbl9hXG4gIHRoZW4gYmVnaW5cbiAgICBsZXQgb2Zmc2V0ID0gcmVmICgoTmF0aXZlaW50LnRvX2ludCAoTmF0aXZlaW50LnN1YiBzcmNfYiBzcmNfYSkpXG4gICAgICAgICAgICAgICAgICAgICAgLyBraW5kX3NpemVfaW5fYnl0ZXMgKEdlbmFycmF5LmtpbmQgYikpIGluXG4gICAgbGV0IHBvaW50cyA9IEFycmF5Lm1ha2UgKEdlbmFycmF5Lm51bV9kaW1zIGEpIDAgaW5cbiAgICBmb3IgaSA9IEdlbmFycmF5Lm51bV9kaW1zIGEgLSAxIGRvd250byAwXG4gICAgZG9cbiAgICAgIHBvaW50cy4oaSkgPC0gIW9mZnNldCBtb2QgKG50aF9kaW0gYSBpKTtcbiAgICAgIG9mZnNldCA6PSAhb2Zmc2V0IC8gKG50aF9kaW0gYSBpKTtcbiAgICBkb25lIDtcbiAgICBTb21lIChsZW4sIHBvaW50cywgQXJyYXkubWFrZSAoR2VuYXJyYXkubnVtX2RpbXMgYikgMClcbiAgZW5kIGVsc2UgTm9uZVxuXG5sZXQgYXJyYXkwIGEgYiA9IG1hdGNoIGdlbmFycmF5IChnZW5hcnJheV9vZl9hcnJheTAgYSkgKGdlbmFycmF5X29mX2FycmF5MCBiKSB3aXRoXG4gIHwgU29tZSAoMSwgW3x8XSwgW3x8XSkgLT4gdHJ1ZVxuICB8IFNvbWUgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBOb25lIC0+IGZhbHNlXG5cbmxldCBhcnJheTEgYSBiID0gbWF0Y2ggZ2VuYXJyYXkgKGdlbmFycmF5X29mX2FycmF5MSBhKSAoZ2VuYXJyYXlfb2ZfYXJyYXkxIGIpIHdpdGhcbiAgfCBTb21lIChsZW4sIFt8IHggfF0sIFt8IHkgfF0pIC0+IFNvbWUgKGxlbiwgeCwgeSlcbiAgfCBTb21lIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgTm9uZSAtPiBOb25lXG5cbmxldCBhcnJheTIgYSBiID0gbWF0Y2ggZ2VuYXJyYXkgKGdlbmFycmF5X29mX2FycmF5MiBhKSAoZ2VuYXJyYXlfb2ZfYXJyYXkyIGIpIHdpdGhcbiAgfCBTb21lIChsZW4sIFt8IHg7IHk7IHxdLCBbfCBhOyBiOyB8XSkgLT4gU29tZSAobGVuLCAoeCwgeSksIChhLCBiKSlcbiAgfCBTb21lIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgTm9uZSAtPiBOb25lXG5cbmxldCBhcnJheTMgYSBiID0gbWF0Y2ggZ2VuYXJyYXkgKGdlbmFycmF5X29mX2FycmF5MyBhKSAoZ2VuYXJyYXlfb2ZfYXJyYXkzIGIpIHdpdGhcbiAgfCBTb21lIChsZW4sIFt8IHg7IHk7IHo7IHxdLCBbfCBhOyBiOyBjOyB8XSkgLT4gU29tZSAobGVuLCAoeCwgeSwgeiksIChhLCBiLCBjKSlcbiAgfCBTb21lIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgTm9uZSAtPiBOb25lXG4iXX0=
