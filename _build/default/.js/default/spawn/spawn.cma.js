// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Spawn
//# unitInfo: Requires: Stdlib, Stdlib__Buffer, Stdlib__Filename, Stdlib__ListLabels, Stdlib__Printf, Stdlib__StringLabels, Stdlib__Sys, Unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = " ",
    cst = "\0\0",
    Unix = global_data.Unix,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    is_osx = runtime.spawn_is_osx(0),
    Working_dir = [0];
   a:
   {
    var
     _e_ = [0, 1],
     _d_ =
       [0,
        [11,
         "Spawn.spawn: NUL bytes are not allowed in any of the arguments but found one in ",
         [3, 0, 0]],
        "Spawn.spawn: NUL bytes are not allowed in any of the arguments but found one in %S"],
     cst_Spawn_spawn_cwd_Fd_is_not_ =
       "Spawn.spawn: [cwd=Fd _] is not supported on Windows",
     cst_bad_pid = "bad pid: ",
     cst_bad_pid_0_hint_use_Pgid_ne =
       "bad pid: 0 (hint: use [Pgid.new_process_group])",
     _c_ =
       [0,
        [11,
         "Spawn.Env.of_list: NUL bytes are not allowed in the environment but found one in ",
         [3, 0, 0]],
        "Spawn.Env.of_list: NUL bytes are not allowed in the environment but found one in %S"];
    try{runtime.caml_sys_getenv("SPAWN_USE_FORK");}
    catch(_E_){
     var _a_ = caml_wrap_exception(_E_);
     if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
     var _b_ = is_osx ? 0 : 1, default$0 = _b_;
     break a;
    }
    var default$0 = 0;
   }
   var Unix_backend = [0, default$0];
   function no_null(s){
    var _D_ = caml_call2(Stdlib_StringLabels[15], s, 0);
    return _D_ ? caml_call3(Stdlib_Printf[10], Stdlib[1], _c_, s) : _D_;
   }
   function of_list(env){
    if(0 === env) return cst;
    var _A_ = 1;
    function _B_(acc, s){
     return (acc + runtime.caml_ml_string_length(s) | 0) + 1 | 0;
    }
    var
     len = caml_call3(Stdlib_ListLabels[26], _B_, _A_, env),
     buf = caml_call1(Stdlib_Buffer[1], len);
    function _C_(s){
     no_null(s);
     caml_call2(Stdlib_Buffer[16], buf, s);
     return caml_call2(Stdlib_Buffer[12], buf, 0);
    }
    caml_call2(Stdlib_ListLabels[18], _C_, env);
    caml_call2(Stdlib_Buffer[12], buf, 0);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var Env_win32 = [0, of_list];
   function of_list$0(l){
    caml_call2(Stdlib_ListLabels[18], no_null, l);
    return l;
   }
   var
    Env_unix = [0, of_list$0],
    Env = Stdlib_Sys[7] ? Env_win32 : Env_unix,
    new_process_group = 0;
   function of_pid(t){
    if(0 === t)
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_bad_pid_0_hint_use_Pgid_ne], 1);
    if(0 <= t) return t;
    var
     _y_ = caml_call1(Stdlib[33], t),
     _z_ = caml_call2(Stdlib[28], cst_bad_pid, _y_);
    throw caml_maybe_attach_backtrace([0, Stdlib[6], _z_], 1);
   }
   var Pgid = [0, new_process_group, of_pid];
   function maybe_quote(f){
    if
     (!
      caml_call2(Stdlib_StringLabels[15], f, 32)
      &&
       !
       caml_call2(Stdlib_StringLabels[15], f, 34)
       &&
        !
        caml_call2(Stdlib_StringLabels[15], f, 9)
        && ! runtime.caml_string_equal(f, ""))
     return f;
    return caml_call1(Stdlib_Filename[21], f);
   }
   function spawn_windows
   (env, cwd, prog, argv, stdin, stdout, stderr, param, _w_, _v_){
    if(typeof cwd === "number")
     var cwd$0 = 0;
    else if(0 === cwd[0])
     var p$0 = cwd[1], cwd$0 = [0, p$0];
    else
     var cwd$0 = caml_call1(Stdlib[1], cst_Spawn_spawn_cwd_Fd_is_not_);
    var
     _x_ = caml_call2(Stdlib_ListLabels[20], maybe_quote, argv),
     cmdline = caml_call2(Stdlib_StringLabels[7], cst$0, _x_);
    a:
    {
     if(caml_call1(Stdlib_Filename[5], prog) && cwd$0){
      var p = cwd$0[1], prog$0 = caml_call2(Stdlib_Filename[4], p, prog);
      break a;
     }
     var prog$0 = prog;
    }
    return runtime.spawn_windows_byte
            (env, cwd$0, prog$0, cmdline, stdin, stdout, stderr);
   }
   function no_null$0(s){
    var _u_ = caml_call2(Stdlib_StringLabels[15], s, 0);
    return _u_ ? caml_call3(Stdlib_Printf[10], Stdlib[1], _d_, s) : _u_;
   }
   function spawn
   (env, opt, prog, argv, _j_, _i_, _h_, _g_, setpgid, sigprocmask, param){
    if(opt) var sth = opt[1], cwd = sth; else var cwd = 0;
    if(_j_) var sth$0 = _j_[1], stdin = sth$0; else var stdin = Unix[21];
    if(_i_) var sth$1 = _i_[1], stdout = sth$1; else var stdout = Unix[22];
    if(_h_) var sth$2 = _h_[1], stderr = sth$2; else var stderr = Unix[23];
    if(_g_)
     var sth$3 = _g_[1], unix_backend = sth$3;
    else
     var unix_backend = Unix_backend[1];
    a:
    if(typeof cwd !== "number" && 0 === cwd[0]){var s = cwd[1]; no_null$0(s); break a;}
    no_null$0(prog);
    caml_call2(Stdlib_ListLabels[18], no_null$0, argv);
    var
     backend =
       Stdlib_Sys[7]
        ? spawn_windows
        : function
         (_t_, _s_, _r_, _q_, _p_, _o_, _n_, _m_, _l_, _k_){
          return runtime.spawn_unix_byte
                  (_t_, _s_, _r_, _q_, _p_, _o_, _n_, _m_, _l_, _k_);
         },
     use_vfork = unix_backend ? 1 : 0;
    return backend
            (env,
             cwd,
             prog,
             argv,
             stdin,
             stdout,
             stderr,
             use_vfork,
             setpgid,
             sigprocmask);
   }
   var
    safe_pipe =
      Stdlib_Sys[7]
       ? function(param){return caml_call2(Unix[70], _e_, 0);}
       : function(_f_){return runtime.spawn_pipe(_f_);},
    Spawn = [0, Working_dir, Unix_backend, Env, Pgid, spawn, safe_pipe];
   runtime.caml_register_global(18, Spawn, "Spawn");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzcGF3bi5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiaXNfb3N4IiwiZGVmYXVsdCQwIiwibm9fbnVsbCIsInMiLCJvZl9saXN0IiwiZW52IiwiYWNjIiwibGVuIiwiYnVmIiwib2ZfbGlzdCQwIiwibCIsIm5ld19wcm9jZXNzX2dyb3VwIiwib2ZfcGlkIiwidCIsIm1heWJlX3F1b3RlIiwiZiIsInNwYXduX3dpbmRvd3MiLCJjd2QiLCJwcm9nIiwiYXJndiIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwiY3dkJDAiLCJwJDAiLCJjbWRsaW5lIiwicCIsInByb2ckMCIsIm5vX251bGwkMCIsInNwYXduIiwib3B0Iiwic2V0cGdpZCIsInNpZ3Byb2NtYXNrIiwic3RoIiwic3RoJDAiLCJzdGgkMSIsInN0aCQyIiwic3RoJDMiLCJ1bml4X2JhY2tlbmQiLCJiYWNrZW5kIiwidXNlX3Zmb3JrIiwic2FmZV9waXBlIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvc3Bhd24vc3Bhd24ubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHQUlhOzs7Ozs7Ozs7Ozs7SUFBVEEsU0FBUztJQUVROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBYVg7Ozs7ZUFmTkEsZ0JBY0VDOzs7UUFBQUE7O0dBTGdCLHVCQUtoQkE7WUFnQkZDLFFBQVFDO0lBQ1AsVUFBQSxvQ0FET0E7SUFDUCxhQUVELDhDQUhRQTtHQU9MO1lBWURDLFFBQVFDO0lBQ1YsU0FEVUEsS0FFTDs7aUJBRTBDQyxLQUFJSDtLQUFLLFFBQVRHLG9DQUFJSDtJQUE4QjtJQUFyRTtLQUFOSSxNQUFNLDRDQUpGRjtLQUtKRyxNQUFNLDZCQURORDtpQkFFa0JKO0tBekJ4QkQsUUF5QndCQztLQUVwQiw4QkFIRUssS0FDa0JMO0tBRXBCLE9BQUEsOEJBSEVLO0lBSXdCO0lBSDVCLHVDQU5RSDtJQVVSLDhCQUxJRztJQUtKLE9BQUEsNkJBTElBO0dBTWdCO0dBZEQsb0JBR25CSjtZQWtCQUssVUFBUUM7SUFDVixrQ0F0Q0FSLFNBcUNVUTtJQUNWLE9BRFVBO0dBRVQ7R0FMbUI7SUFBQSxlQUdsQkQ7O0lBV0FFO1lBRUFDLE9BRUFDO0lBRlMsU0FFVEE7S0FESyxNQUFBOztZQUNMQSxHQUFpRixPQUFqRkE7SUFBMEQ7S0FBQSxNQUFBLHVCQUExREE7S0FBMkMsTUFBQTtJQUF4QixNQUFBO0dBQStEO0dBUDFFLGVBR1JGLG1CQUVBQztZQStCRkUsWUFBWUM7SUFDZDs7TUFBRyxvQ0FEV0E7OztPQUNjLG9DQURkQTs7O1FBQ3dDLG9DQUR4Q0E7YUFDa0UsMEJBRGxFQTtLQUdULE9BSFNBO0lBRVQsT0FBQSxnQ0FGU0E7R0FHUjtZQUdKQztJQUNEWCxLQUNBWSxLQUNBQyxNQUNBQyxNQUNBQyxPQUNBQyxRQUNBQztJQUtELFVBVkNMO1NBVUdNO2tCQVZITjtTQVlRTyxNQVpSUCxRQVVHTSxZQUVLQzs7U0FGTEQsUUFHUTtJQUdnQjtLQUFBLE1BQUEsa0NBeEIxQlQsYUFVREs7S0FjR00sVUFBVTs7O1FBRU4sK0JBakJQUCxTQVNHSztVQVNXRyxJQVRYSCxVQU9BSSxTQUVnQiwrQkFBTEQsR0FsQmRSOzs7U0FnQkdTLFNBaEJIVDs7SUFxQkQsT0FBQTthQXZCQ2IsS0FXR2tCLE9BT0FJLFFBREFGLFNBYkhMLE9BQ0FDLFFBQ0FDO0dBaUI0RDtZQUczRE0sVUFBUXpCO0lBQ1AsVUFBQSxvQ0FET0E7SUFDUCxhQUVELDhDQUhRQTtHQU1MO1lBR0gwQjtJQUNEeEIsS0FDQ3lCLEtBQ0RaLE1BQ0FDLDBCQUtBWSxTQUNBQztJLEdBUkNGLFNBQU1HLE1BQU5ILFFBQUFiLE1BQU1nQixjQUFOaEI7SUFXRixZQVJVaUIsZ0JBQVJkLFFBQVFjLGdCQUFSZDtJQVFGLFlBUFdlLGdCQUFUZCxTQUFTYyxnQkFBVGQ7SUFPRixZQU5XZSxnQkFBVGQsU0FBU2MsZ0JBQVRkO0lBTUY7U0FMaUJlLGdCQUFmQyxlQUFlRDs7U0FBZkM7O2NBTkFyQiwwQkFBQUEsWUFZTWQsSUFaTmMsUUFYQVcsVUF1Qk16QjtJQXZCTnlCLFVBWURWO0lBY0Qsa0NBMUJFVSxXQWFEVDtJQWVEO0tBRElvQjs7VUF0REZ2Qjs7O1U7OztLQXVERXdCLFlBWEZGO0lBZ0JGLE9BTklDO2FBakJIbEM7YUFDQ1k7YUFDREM7YUFDQUM7YUFDQ0M7YUFDQUM7YUFDQUM7YUFZRWtCO2FBVkhUO2FBQ0FDOzs7SUFtQkNTOzt5QkFBd0MsT0FBQSw2QkFBMEI7dUI7c0RBN0JsRVosT0E2QkFZOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4gU3RkTGFiZWxzXG5cbmV4dGVybmFsIGlzX29zeCA6IHVuaXQgLT4gYm9vbCA9IFwic3Bhd25faXNfb3N4XCIgW0BAbm9hbGxvY11cblxubGV0IGlzX29zeCA9IGlzX29zeCAoKVxuXG5tb2R1bGUgV29ya2luZ19kaXIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IFBhdGggb2Ygc3RyaW5nXG4gICAgfCBGZCBvZiBVbml4LmZpbGVfZGVzY3JcbiAgICB8IEluaGVyaXRcbmVuZFxuXG5tb2R1bGUgVW5peF9iYWNrZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBGb3JrXG4gICAgfCBWZm9ya1xuXG4gIGxldCBkZWZhdWx0ID1cbiAgICBtYXRjaCBTeXMuZ2V0ZW52IFwiU1BBV05fVVNFX0ZPUktcIiB3aXRoXG4gICAgfCBfIC0+IEZvcmtcbiAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgICgqIFdlIG9ic2VydmVkIGlzc3VlcyBpbiB0aGUgcGFzdCB3aGVuIHVzaW5nIFt2Zm9ya10gb24gT1NYLiBNb3JlXG4gICAgICAgICBwcmVjaXNlbHksIGl0IHNlZW1zIHRoYXQgW2NoZGlyXS9bZmNoZGlyXSBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50XG4gICAgICAgICBhZnRlciBhIHZmb3JrLiBXZSB0cmllZCB3b3JraW5nIGFyb3VuZCB0aGlzIGJ5IG5vdCBkb2luZyB0aGUgZGlyZWN0b3J5XG4gICAgICAgICBjaGFuZ2UgaW4gdGhlIHN1Yi1wcm9jZXNzIHdoZW4gdXNpbmcgW3Zmb3JrXSBvbiBPU1gsIGFuZCBpbnN0ZWFkIGRvaW5nXG4gICAgICAgICBpdCBpbiB0aGUgcGFyZW50IHZpYSBbcHRocmVhZF9jaGRpcl0vW3B0aHJlYWRfZmNoZGlyXS4gVGhpcyB3YXNcbiAgICAgICAgIHVuc3VjY2Vzc2Z1bC5cblxuICAgICAgICAgSW4gdGhlIGVuZCB3ZSBkZWNpZGVkIG5vdCB0byBkZWZhdWx0IHRvIFt2Zm9ya10gb24gT1NYLiAqKVxuICAgICAgaWYgaXNfb3N4IHRoZW4gRm9yayBlbHNlIFZmb3JrXG4gIDs7XG5lbmRcblxubGV0IG5vX251bGwgcyA9XG4gIGlmIFN0cmluZy5jb250YWlucyBzICdcXDAwMCdcbiAgdGhlblxuICAgIFByaW50Zi5rc3ByaW50ZlxuICAgICAgaW52YWxpZF9hcmdcbiAgICAgIFwiU3Bhd24uRW52Lm9mX2xpc3Q6IE5VTCBieXRlcyBhcmUgbm90IGFsbG93ZWQgaW4gdGhlIGVudmlyb25tZW50IGJ1dCBmb3VuZCBvbmUgaW4gXFxcbiAgICAgICAlU1wiXG4gICAgICBzXG47O1xuXG5tb2R1bGUgdHlwZSBFbnYgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIG9mX2xpc3QgOiBzdHJpbmcgbGlzdCAtPiB0XG5lbmRcblxubW9kdWxlIEVudl93aW4zMiA6IEVudiA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmdcblxuICBsZXQgb2ZfbGlzdCBlbnYgPVxuICAgIGlmIGVudiA9IFtdXG4gICAgdGhlbiBcIlxcMDAwXFwwMDBcIlxuICAgIGVsc2UgKFxuICAgICAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IGVudiB+aW5pdDoxIH5mOihmdW4gYWNjIHMgLT4gYWNjICsgU3RyaW5nLmxlbmd0aCBzICsgMSkgaW5cbiAgICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgICAgTGlzdC5pdGVyIGVudiB+ZjooZnVuIHMgLT5cbiAgICAgICAgbm9fbnVsbCBzO1xuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgcztcbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFwwMDAnKTtcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcMDAwJztcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBidWYpXG4gIDs7XG5lbmRcblxubW9kdWxlIEVudl91bml4IDogRW52ID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZyBsaXN0XG5cbiAgbGV0IG9mX2xpc3QgbCA9XG4gICAgTGlzdC5pdGVyIGwgfmY6bm9fbnVsbDtcbiAgICBsXG4gIDs7XG5lbmRcblxubW9kdWxlIEVudiA6IEVudiA9ICh2YWwgaWYgU3lzLndpbjMyIHRoZW4gKG1vZHVsZSBFbnZfd2luMzIpIGVsc2UgKG1vZHVsZSBFbnZfdW5peCkgOiBFbnYpXG5cbm1vZHVsZSBQZ2lkID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCBuZXdfcHJvY2Vzc19ncm91cCA9IDBcblxuICBsZXQgb2ZfcGlkID0gZnVuY3Rpb25cbiAgICB8IDAgLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJiYWQgcGlkOiAwIChoaW50OiB1c2UgW1BnaWQubmV3X3Byb2Nlc3NfZ3JvdXBdKVwiKVxuICAgIHwgdCAtPiBpZiB0IDwgMCB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChcImJhZCBwaWQ6IFwiIF4gc3RyaW5nX29mX2ludCB0KSkgZWxzZSB0XG4gIDs7XG5lbmRcblxuZXh0ZXJuYWwgc3Bhd25fdW5peFxuICA6ICBlbnY6RW52LnQgb3B0aW9uXG4gIC0+IGN3ZDpXb3JraW5nX2Rpci50XG4gIC0+IHByb2c6c3RyaW5nXG4gIC0+IGFyZ3Y6c3RyaW5nIGxpc3RcbiAgLT4gc3RkaW46VW5peC5maWxlX2Rlc2NyXG4gIC0+IHN0ZG91dDpVbml4LmZpbGVfZGVzY3JcbiAgLT4gc3RkZXJyOlVuaXguZmlsZV9kZXNjclxuICAtPiB1c2VfdmZvcms6Ym9vbFxuICAtPiBzZXRwZ2lkOmludCBvcHRpb25cbiAgLT4gc2lncHJvY21hc2s6KFVuaXguc2lncHJvY21hc2tfY29tbWFuZCAqIGludCBsaXN0KSBvcHRpb25cbiAgLT4gaW50XG4gID0gXCJzcGF3bl91bml4X2J5dGVcIiBcInNwYXduX3VuaXhcIlxuXG5leHRlcm5hbCBzcGF3bl93aW5kb3dzXG4gIDogIGVudjpFbnYudCBvcHRpb25cbiAgLT4gY3dkOnN0cmluZyBvcHRpb25cbiAgLT4gcHJvZzpzdHJpbmdcbiAgLT4gY21kbGluZTpzdHJpbmdcbiAgLT4gc3RkaW46VW5peC5maWxlX2Rlc2NyXG4gIC0+IHN0ZG91dDpVbml4LmZpbGVfZGVzY3JcbiAgLT4gc3RkZXJyOlVuaXguZmlsZV9kZXNjclxuICAtPiBpbnRcbiAgPSBcInNwYXduX3dpbmRvd3NfYnl0ZVwiIFwic3Bhd25fd2luZG93c1wiXG5cbmxldCBtYXliZV9xdW90ZSBmID1cbiAgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJyAnIHx8IFN0cmluZy5jb250YWlucyBmICdcXFwiJyB8fCBTdHJpbmcuY29udGFpbnMgZiAnXFx0JyB8fCBmID0gXCJcIlxuICB0aGVuIEZpbGVuYW1lLnF1b3RlIGZcbiAgZWxzZSBmXG47O1xuXG5sZXQgc3Bhd25fd2luZG93c1xuICB+ZW52XG4gIH5jd2RcbiAgfnByb2dcbiAgfmFyZ3ZcbiAgfnN0ZGluXG4gIH5zdGRvdXRcbiAgfnN0ZGVyclxuICB+dXNlX3Zmb3JrOl9cbiAgfnNldHBnaWQ6X1xuICB+c2lncHJvY21hc2s6X1xuICA9XG4gIGxldCBjd2QgPVxuICAgIG1hdGNoIChjd2QgOiBXb3JraW5nX2Rpci50KSB3aXRoXG4gICAgfCBQYXRoIHAgLT4gU29tZSBwXG4gICAgfCBGZCBfIC0+IGludmFsaWRfYXJnIFwiU3Bhd24uc3Bhd246IFtjd2Q9RmQgX10gaXMgbm90IHN1cHBvcnRlZCBvbiBXaW5kb3dzXCJcbiAgICB8IEluaGVyaXQgLT4gTm9uZVxuICBpblxuICBsZXQgY21kbGluZSA9IFN0cmluZy5jb25jYXQgKExpc3QubWFwIGFyZ3YgfmY6bWF5YmVfcXVvdGUpIH5zZXA6XCIgXCIgaW5cbiAgbGV0IHByb2cgPVxuICAgIG1hdGNoIEZpbGVuYW1lLmlzX3JlbGF0aXZlIHByb2csIGN3ZCB3aXRoXG4gICAgfCB0cnVlLCBTb21lIHAgLT4gRmlsZW5hbWUuY29uY2F0IHAgcHJvZ1xuICAgIHwgXyAtPiBwcm9nXG4gIGluXG4gIHNwYXduX3dpbmRvd3MgfmVudiB+Y3dkIH5wcm9nIH5jbWRsaW5lIH5zdGRpbiB+c3Rkb3V0IH5zdGRlcnJcbjs7XG5cbmxldCBub19udWxsIHMgPVxuICBpZiBTdHJpbmcuY29udGFpbnMgcyAnXFwwMDAnXG4gIHRoZW5cbiAgICBQcmludGYua3NwcmludGZcbiAgICAgIGludmFsaWRfYXJnXG4gICAgICBcIlNwYXduLnNwYXduOiBOVUwgYnl0ZXMgYXJlIG5vdCBhbGxvd2VkIGluIGFueSBvZiB0aGUgYXJndW1lbnRzIGJ1dCBmb3VuZCBvbmUgaW4gJVNcIlxuICAgICAgc1xuOztcblxubGV0IHNwYXduXG4gID9lbnZcbiAgPyhjd2QgPSBXb3JraW5nX2Rpci5Jbmhlcml0KVxuICB+cHJvZ1xuICB+YXJndlxuICA/KHN0ZGluID0gVW5peC5zdGRpbilcbiAgPyhzdGRvdXQgPSBVbml4LnN0ZG91dClcbiAgPyhzdGRlcnIgPSBVbml4LnN0ZGVycilcbiAgPyh1bml4X2JhY2tlbmQgPSBVbml4X2JhY2tlbmQuZGVmYXVsdClcbiAgP3NldHBnaWRcbiAgP3NpZ3Byb2NtYXNrXG4gICgpXG4gID1cbiAgKG1hdGNoIGN3ZCB3aXRoXG4gICB8IFBhdGggcyAtPiBub19udWxsIHNcbiAgIHwgRmQgXyB8IEluaGVyaXQgLT4gKCkpO1xuICBub19udWxsIHByb2c7XG4gIExpc3QuaXRlciBhcmd2IH5mOm5vX251bGw7XG4gIGxldCBiYWNrZW5kID0gaWYgU3lzLndpbjMyIHRoZW4gc3Bhd25fd2luZG93cyBlbHNlIHNwYXduX3VuaXggaW5cbiAgbGV0IHVzZV92Zm9yayA9XG4gICAgbWF0Y2ggdW5peF9iYWNrZW5kIHdpdGhcbiAgICB8IFZmb3JrIC0+IHRydWVcbiAgICB8IEZvcmsgLT4gZmFsc2VcbiAgaW5cbiAgYmFja2VuZCB+ZW52IH5jd2QgfnByb2cgfmFyZ3YgfnN0ZGluIH5zdGRvdXQgfnN0ZGVyciB+dXNlX3Zmb3JrIH5zZXRwZ2lkIH5zaWdwcm9jbWFza1xuOztcblxuZXh0ZXJuYWwgc2FmZV9waXBlIDogdW5pdCAtPiBVbml4LmZpbGVfZGVzY3IgKiBVbml4LmZpbGVfZGVzY3IgPSBcInNwYXduX3BpcGVcIlxuXG5sZXQgc2FmZV9waXBlID0gaWYgU3lzLndpbjMyIHRoZW4gZnVuICgpIC0+IFVuaXgucGlwZSB+Y2xvZXhlYzp0cnVlICgpIGVsc2Ugc2FmZV9waXBlXG4iXX0=
