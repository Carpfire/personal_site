// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Thread
//# unitInfo: Requires: Stdlib, Stdlib__Callback, Stdlib__Printexc, Stdlib__Printf, Stdlib__Sys, Unix
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Thread = "Thread ",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Unix = global_data.Unix,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Callback = global_data.Stdlib__Callback,
    _a_ =
      [0,
       [11,
        cst_Thread,
        [4,
         0,
         0,
         0,
         [11, " killed on uncaught exception ", [2, 0, [12, 10, 0]]]]],
       "Thread %d killed on uncaught exception %s\n"],
    _b_ =
      [0,
       [11,
        cst_Thread,
        [4,
         0,
         0,
         0,
         [11, " uncaught exception handler raised ", [2, 0, [12, 10, 0]]]]],
       "Thread %d uncaught exception handler raised %s\n"],
    cst_Thread_Exit = "Thread.Exit",
    cst_Thread_at_shutdown = "Thread.at_shutdown";
   function default_uncaught_exception_han(_v_){
    return runtime.caml_thread_uncaught_exception(_v_);
   }
   var uncaught_exception_handler = [0, default_uncaught_exception_han];
   function set_uncaught_exception_handler(fn){
    uncaught_exception_handler[1] = fn;
    return 0;
   }
   var Exit = [248, cst_Thread_Exit, runtime.caml_fresh_oo_id(0)];
   function create(fn, arg){
    return runtime.caml_thread_new
            (function(param){
              try{caml_call1(fn, arg); var _u_ = 0; return _u_;}
              catch(exn$1){
               var exn = caml_wrap_exception(exn$1);
               if(exn === Exit) return 0;
               var raw_backtrace = caml_call1(Stdlib_Printexc[12], 0);
               caml_call1(Stdlib[63], Stdlib[39]);
               caml_call1(Stdlib[63], Stdlib[40]);
               try{
                var _t_ = caml_call1(uncaught_exception_handler[1], exn);
                return _t_;
               }
               catch(exn$1){
                var exn$0 = caml_wrap_exception(exn$1);
                if(exn$0 === Exit) return 0;
                var
                 _p_ = caml_call1(Stdlib_Printexc[1], exn),
                 _q_ = runtime.caml_thread_id(runtime.caml_thread_self(0));
                caml_call3(Stdlib_Printf[3], _a_, _q_, _p_);
                caml_call2(Stdlib_Printexc[13], Stdlib[40], raw_backtrace);
                var
                 _r_ = caml_call1(Stdlib_Printexc[1], exn$0),
                 _s_ = runtime.caml_thread_id(runtime.caml_thread_self(0));
                caml_call3(Stdlib_Printf[3], _b_, _s_, _r_);
                caml_call1(Stdlib_Printexc[5], Stdlib[39]);
                return caml_call1(Stdlib[63], Stdlib[40]);
               }
              }
             });
   }
   function exit(param){throw caml_maybe_attach_backtrace(Exit, 1);}
   function preempt(signal){return runtime.caml_thread_yield(0);}
   var
    preempt_signal =
      runtime.caml_string_notequal(Stdlib_Sys[4], "Win32")
       ? Stdlib_Sys[35]
       : Stdlib_Sys[26];
   runtime.caml_thread_initialize(0);
   caml_call2(Stdlib_Sys[15], preempt_signal, [0, preempt]);
   function _c_(param){
    runtime.caml_thread_cleanup(0);
    return caml_call2(Stdlib_Sys[15], preempt_signal, 0);
   }
   caml_call2(Stdlib_Callback[1], cst_Thread_at_shutdown, _c_);
   var delay = Unix[107];
   function wait_timed_read(fd, d){
    return caml_call4(Unix[93], [0, fd, 0], 0, 0, d)[1] ? 1 : 0;
   }
   function wait_timed_write(fd, d){
    return caml_call4(Unix[93], 0, [0, fd, 0], 0, d)[2] ? 1 : 0;
   }
   var select = Unix[93];
   function wait_pid(p){return caml_call2(Unix[15], 0, p);}
   function _d_(_o_){return runtime.caml_wait_signal(_o_);}
   function _e_(_n_, _m_){return runtime.caml_thread_sigmask(_n_, _m_);}
   function _f_(_l_){return runtime.caml_thread_yield(_l_);}
   function _g_(_k_){return runtime.caml_thread_join(_k_);}
   function _h_(_j_){return runtime.caml_thread_id(_j_);}
   var
    Thread =
      [0,
       create,
       function(_i_){return runtime.caml_thread_self(_i_);},
       _h_,
       Exit,
       exit,
       delay,
       _g_,
       _f_,
       wait_timed_read,
       wait_timed_write,
       select,
       wait_pid,
       _e_,
       _d_,
       default_uncaught_exception_han,
       set_uncaught_exception_handler];
   runtime.caml_register_global(11, Thread, "Thread");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Event
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Condition, Stdlib__List, Stdlib__Mutex, Stdlib__Queue, Stdlib__Random
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Condition = global_data.Stdlib__Condition,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Mutex = global_data.Stdlib__Mutex,
    Stdlib_Random = global_data.Stdlib__Random,
    cst_Event_receive = "Event.receive",
    cst_Event_choose = "Event.choose";
   function new_channel(param){
    var _M_ = caml_call1(Stdlib_Queue[2], 0);
    return [0, caml_call1(Stdlib_Queue[2], 0), _M_];
   }
   var masterlock = caml_call1(Stdlib_Mutex[1], 0);
   function do_aborts(abort_env, genev, performed){
    var _I_ = 0 !== abort_env ? 1 : 0;
    if(! _I_) return _I_;
    if(0 <= performed){
     var
      ids_done = caml_check_bound(genev, performed)[1 + performed][2],
      _J_ =
        function(param){
         var
          f = param[2],
          id = param[1],
          _L_ = 1 - caml_call2(Stdlib_List[37], id, ids_done);
         return _L_ ? caml_call1(f, 0) : _L_;
        };
     return caml_call2(Stdlib_List[18], _J_, abort_env);
    }
    function _K_(param){var f = param[2]; return caml_call1(f, 0);}
    return caml_call2(Stdlib_List[18], _K_, abort_env);
   }
   function scramble_array(a){
    var len = a.length - 1;
    if(0 === len) caml_call1(Stdlib[1], cst_Event_choose);
    var _G_ = len - 1 | 0;
    if(_G_ >= 1){
     var i = _G_;
     for(;;){
      var
       j = caml_call1(Stdlib_Random[5], i + 1 | 0),
       temp = caml_check_bound(a, i)[1 + i];
      a[1 + i] = caml_check_bound(a, j)[1 + j];
      a[1 + j] = temp;
      var _H_ = i - 1 | 0;
      if(1 === i) break;
      var i = _H_;
     }
    }
    return a;
   }
   var count = [0, 0];
   function flatten_event(abort_list, accu, accu_abort, ev){
    var abort_list$0 = abort_list, accu_abort$0 = accu_abort, ev$0 = ev;
    for(;;)
     switch(ev$0[0]){
       case 0:
        var bev = ev$0[1];
        return [0, [0, [0, bev, abort_list$0], accu], accu_abort$0];
       case 1:
        var
         evl = ev$0[1],
         accu$0 = accu,
         accu_abort$1 = accu_abort$0,
         param = evl;
        for(;;){
         if(! param) return [0, accu$0, accu_abort$1];
         var
          l = param[2],
          ev$1 = param[1],
          match = flatten_event(abort_list$0, accu$0, accu_abort$1, ev$1),
          accu_abort$2 = match[2],
          accu$1 = match[1],
          accu$0 = accu$1,
          accu_abort$1 = accu_abort$2,
          param = l;
        }
        break;
       case 2:
        var fn = ev$0[2], ev$2 = ev$0[1];
        count[1]++;
        var
         id = count[1],
         accu_abort$3 = [0, [0, id, fn], accu_abort$0],
         abort_list$1 = [0, id, abort_list$0],
         abort_list$0 = abort_list$1,
         accu_abort$0 = accu_abort$3,
         ev$0 = ev$2;
        break;
       default: var fn$0 = ev$0[1], ev$3 = caml_call1(fn$0, 0), ev$0 = ev$3;
     }
   }
   function sync(ev){
    var
     match = flatten_event(0, 0, 0, ev),
     abort_env = match[2],
     evl = match[1],
     genev = scramble_array(caml_call1(Stdlib_Array[10], evl)),
     performed = [0, -1],
     condition = caml_call1(Stdlib_Condition[1], 0),
     bev =
       caml_make_vect
        (genev.length - 1,
         caml_call3(caml_check_bound(genev, 0)[1][1], performed, condition, 0)),
     _x_ = genev.length - 1 - 1 | 0,
     _w_ = 1;
    if(_x_ >= 1){
     var i$2 = _w_;
     for(;;){
      var
       _E_ =
         caml_call3
          (caml_check_bound(genev, i$2)[1 + i$2][1],
           performed,
           condition,
           i$2);
      caml_check_bound(bev, i$2)[1 + i$2] = _E_;
      var _F_ = i$2 + 1 | 0;
      if(_x_ === i$2) break;
      var i$2 = _F_;
     }
    }
    caml_call1(Stdlib_Mutex[2], masterlock);
    a:
    {
     b:
     {
      var i = 0;
      for(;;){
       if(bev.length - 1 <= i) break b;
       var _y_ = caml_call1(caml_check_bound(bev, i)[1 + i][1], 0);
       if(_y_) break;
       var i$0 = i + 1 | 0, i = i$0;
      }
      var _z_ = _y_;
      break a;
     }
     var _z_ = 0;
    }
    if(1 - _z_){
     var _B_ = bev.length - 1 - 1 | 0, _A_ = 0;
     if(_B_ >= 0){
      var i$1 = _A_;
      for(;;){
       caml_call1(caml_check_bound(bev, i$1)[1 + i$1][2], 0);
       var _D_ = i$1 + 1 | 0;
       if(_B_ === i$1) break;
       var i$1 = _D_;
      }
     }
     caml_call2(Stdlib_Condition[2], condition, masterlock);
     for(;;){
      if(0 <= performed[1]) break;
      caml_call2(Stdlib_Condition[2], condition, masterlock);
     }
    }
    caml_call1(Stdlib_Mutex[4], masterlock);
    if(0 === abort_env){
     var _C_ = performed[1];
     return caml_call1(caml_check_bound(bev, _C_)[1 + _C_][3], 0);
    }
    var
     num = performed[1],
     result = caml_call1(caml_check_bound(bev, num)[1 + num][3], 0);
    do_aborts(abort_env, genev, num);
    return result;
   }
   function poll(ev){
    var
     match = flatten_event(0, 0, 0, ev),
     abort_env = match[2],
     evl = match[1],
     genev = scramble_array(caml_call1(Stdlib_Array[10], evl)),
     performed = [0, -1],
     condition = caml_call1(Stdlib_Condition[1], 0),
     bev =
       caml_make_vect
        (genev.length - 1,
         caml_call3(caml_check_bound(genev, 0)[1][1], performed, condition, 0)),
     _r_ = genev.length - 1 - 1 | 0,
     _q_ = 1;
    if(_r_ >= 1){
     var i$1 = _q_;
     for(;;){
      var
       _u_ =
         caml_call3
          (caml_check_bound(genev, i$1)[1 + i$1][1],
           performed,
           condition,
           i$1);
      caml_check_bound(bev, i$1)[1 + i$1] = _u_;
      var _v_ = i$1 + 1 | 0;
      if(_r_ === i$1) break;
      var i$1 = _v_;
     }
    }
    caml_call1(Stdlib_Mutex[2], masterlock);
    var i = 0;
    for(;;){
     if(bev.length - 1 <= i)
      var ready = 0;
     else{
      var _s_ = caml_call1(caml_check_bound(bev, i)[1 + i][1], 0);
      if(! _s_){var i$0 = i + 1 | 0, i = i$0; continue;}
      var ready = _s_;
     }
     if(ready){
      caml_call1(Stdlib_Mutex[4], masterlock);
      var
       _t_ = performed[1],
       result = [0, caml_call1(caml_check_bound(bev, _t_)[1 + _t_][3], 0)];
      do_aborts(abort_env, genev, performed[1]);
      return result;
     }
     performed[1] = 0;
     caml_call1(Stdlib_Mutex[4], masterlock);
     do_aborts(abort_env, genev, -1);
     return 0;
    }
   }
   function cleanup_queue(q){
    var q$0 = caml_call1(Stdlib_Queue[2], 0);
    function _o_(c){
     var _p_ = -1 === c[1][1] ? 1 : 0;
     return _p_ ? caml_call2(Stdlib_Queue[3], c, q$0) : _p_;
    }
    caml_call2(Stdlib_Queue[15], _o_, q);
    return q$0;
   }
   function always(data){
    return [0,
            function(performed, condition, evnum){
             function _m_(param){return data;}
             function _n_(param){return 0;}
             return [0,
                     function(param){performed[1] = evnum; return 1;},
                     _n_,
                     _m_];
            }];
   }
   function send(channel, data){
    return [0,
            function(performed, condition, evnum){
             var wcomm = [0, performed, condition, [0, data], evnum];
             function _h_(param){return 0;}
             function _i_(param){
              channel[1] = cleanup_queue(channel[1]);
              return caml_call2(Stdlib_Queue[3], wcomm, channel[1]);
             }
             return [0,
                     function(param){
                      try{
                       for(;;){
                        var rcomm = caml_call1(Stdlib_Queue[5], channel[2]);
                        if(0 > rcomm[1][1]){
                         rcomm[3] = wcomm[3];
                         performed[1] = evnum;
                         rcomm[1][1] = rcomm[4];
                         caml_call1(Stdlib_Condition[3], rcomm[2]);
                         var _k_ = 1;
                         return _k_;
                        }
                       }
                      }
                      catch(_l_){
                       var _j_ = caml_wrap_exception(_l_);
                       if(_j_ === Stdlib_Queue[1]) return 0;
                       throw caml_maybe_attach_backtrace(_j_, 0);
                      }
                     },
                     _i_,
                     _h_];
            }];
   }
   function receive(channel){
    return [0,
            function(performed, condition, evnum){
             var rcomm = [0, performed, condition, 0, evnum];
             function _c_(param){
              var match = rcomm[3];
              if(! match) return caml_call1(Stdlib[1], cst_Event_receive);
              var res = match[1];
              return res;
             }
             function _d_(param){
              channel[2] = cleanup_queue(channel[2]);
              return caml_call2(Stdlib_Queue[3], rcomm, channel[2]);
             }
             return [0,
                     function(param){
                      try{
                       for(;;){
                        var wcomm = caml_call1(Stdlib_Queue[5], channel[1]);
                        if(0 > wcomm[1][1]){
                         rcomm[3] = wcomm[3];
                         performed[1] = evnum;
                         wcomm[1][1] = wcomm[4];
                         caml_call1(Stdlib_Condition[3], wcomm[2]);
                         var _f_ = 1;
                         return _f_;
                        }
                       }
                      }
                      catch(_g_){
                       var _e_ = caml_wrap_exception(_g_);
                       if(_e_ === Stdlib_Queue[1]) return 0;
                       throw caml_maybe_attach_backtrace(_e_, 0);
                      }
                     },
                     _d_,
                     _c_];
            }];
   }
   function choose(evl){return [1, evl];}
   function wrap_abort(ev, fn){return [2, ev, fn];}
   function guard(fn){return [3, fn];}
   function wrap(ev, fn){
    switch(ev[0]){
      case 0:
       var genev = ev[1];
       return [0,
               function(performed, condition, evnum){
                var bev = caml_call3(genev, performed, condition, evnum);
                function _b_(param){
                 return caml_call1(fn, caml_call1(bev[3], 0));
                }
                return [0, bev[1], bev[2], _b_];
               }];
      case 1:
       var evl = ev[1], _a_ = function(ev){return wrap(ev, fn);};
       return [1, caml_call2(Stdlib_List[20], _a_, evl)];
      case 2:
       var f = ev[2], ev$0 = ev[1]; return [2, wrap(ev$0, fn), f];
      default:
       var gu = ev[1];
       return [3, function(param){return wrap(caml_call1(gu, 0), fn);}];
    }
   }
   function select(evl){return sync([1, evl]);}
   var
    Event =
      [0,
       new_channel,
       send,
       receive,
       always,
       choose,
       wrap,
       wrap_abort,
       guard,
       sync,
       select,
       poll];
   runtime.caml_register_global(9, Event, "Event");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aHJlYWRzLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6W10sInNvdXJjZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0k7O0c7O0k7O0c7Rzs7SSxPOztjLEkscUIsYTs7O2dDO2Usb0I7ZTtlO2U7Z0IsVTtnQjs7OzttQztnQjtpQixNO2lCLE0sdUI7Z0I7Z0I7Z0I7aUIsTTtpQixNLHVCO2dCO2dCO2dCLE87OzthO0c7d0IsTSxxQzs0QixPLDZCOzs7Ozs7RztHOztJO0ksTztHO0c7Rzs7SSxPO0c7O0ksTztHOzt3QixPLDJCO3FCOzBCO3FCO3FCO3FCOzs7OztxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7O0ksVTtJLFc7RztHLGlCOztJOzs7SztNOzs7Uzs7O1UsVTtzQjtRO0ssTzs7d0Isa0IsTyxpQjtJLE87Rzs7STtrQjtJOzs7O007TyxJO087TTtNO007Ozs7O0k7RztHOztJO0k7Ozs7UTs7Ozs7Ozs7cUI7Uzs7O1U7Ozs7Ozs7Ozs7O1E7O1M7Uzs7Ozs7Z0Isb0IsTzs7Rzs7STtLOzs7Syx1QjtLO0ssWTtLO087O1M7O0s7Ozs7TTs7Uzs7Ozs7TTtNOzs7OztJOzs7Ozs7TTs7TyxVO087Ozs7Ozs7OztLLGtDOzs7O087Tzs7Ozs7SztLOztNOzs7STs7O0ssTzs7STs7SyxTO0k7STtHOztJO0s7OztLLHVCO0s7SyxZO0s7Tzs7Uzs7Szs7OztNOztTOzs7OztNO007Ozs7O0k7O0k7Ozs7TSxVO007OztLO007TTs7TyxhO007TTs7O0s7SztLOztHOztJLFU7O0s7a0I7STtJO0k7Rzs7STs7aUMsWTtpQyxTO2E7cUMsc0IsUzs7O1k7Rzs7STs7YTthLG9CLFM7O2M7YyxPO2E7YTs7c0I7dUI7d0IsWTs7Ozs7O3lCO3lCOzs7Ozs7bUQ7OztxQjs7O1k7Rzs7STs7YTthO2M7MEIsTzs7YzthOztjO2MsTzthO2E7O3NCO3VCO3dCLFk7Ozs7Ozt5Qjt5Qjs7Ozs7O21EOzs7cUI7OztZO0c7d0IsZ0I7K0IsbUI7c0IsZTs7STs7O087O2dCLFU7O2lCLE8sZTtnQjtnQjtlOzsyQyxvQjtPLFc7O29DOzs7TywyQixZLHVCOztHO3dCLHNCOzs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOltdfQ==
