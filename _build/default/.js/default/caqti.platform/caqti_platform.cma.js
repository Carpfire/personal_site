// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Caqti_platform
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Caqti_platform = [0];
   runtime.caml_register_global(0, Caqti_platform, "Caqti_platform");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__Switch
//# unitInfo: Requires: Lwt_dllist, Stdlib, Stdlib__Option
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_dllist = global_data.Lwt_dllist,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib = global_data.Stdlib,
    cst_Tried_to_release_eternal_s = "Tried to release eternal switch.",
    cst_Caqti_platform_Switch_Make = "Caqti_platform.Switch.Make(Fiber).Off";
   function Make(Fiber){
    var
     Off = [248, cst_Caqti_platform_Switch_Make, runtime.caml_fresh_oo_id(0)],
     eternal = 0;
    function create(param){return [0, [0, caml_call1(Lwt_dllist[4], 0)]];}
    function release(param){
     if(! param) return caml_call1(Stdlib[2], cst_Tried_to_release_eternal_s);
     var match = param[1];
     if(! match) return caml_call1(Fiber[1], 0);
     var tasks = match[1];
     function loop(param$0){
      if(caml_call1(Lwt_dllist[5], tasks)){
       param[1] = 0;
       return caml_call1(Fiber[1], 0);
      }
      var _c_ = caml_call2(Lwt_dllist[10], tasks, 0);
      return caml_call2(Fiber[2][1], _c_, loop);
     }
     return loop(0);
    }
    function run(f){
     var sw = create(0);
     function _a_(param){return release(sw);}
     function _b_(param){return caml_call1(f, sw);}
     return caml_call2(Fiber[3], _b_, _a_);
    }
    function check(param){
     if(param && ! param[1]) throw caml_maybe_attach_backtrace(Off, 1);
     return 0;
    }
    function on_release_cancellable(sw, f){
     if(! sw) return 0;
     var match = sw[1];
     if(! match) throw caml_maybe_attach_backtrace(Off, 1);
     var tasks = match[1];
     return [0, caml_call2(Lwt_dllist[7], f, tasks)];
    }
    function remove_hook(hook){
     return caml_call2(Stdlib_Option[9], Lwt_dllist[3], hook);
    }
    return [0,
            Off,
            eternal,
            create,
            release,
            run,
            check,
            on_release_cancellable,
            remove_hook];
   }
   var Caqti_platform_Switch = [0, Make];
   runtime.caml_register_global
    (5, Caqti_platform_Switch, "Caqti_platform__Switch");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__System_sig
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Caqti_platform_System_sig = [0];
   runtime.caml_register_global
    (0, Caqti_platform_System_sig, "Caqti_platform__System_sig");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__Stream
//# unitInfo: Requires: Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, 0];
   function Make(Fiber){
    function symbol(res_future, f){
     function _r_(r){
      if(0 !== r[0]) return caml_call1(Fiber[2], r);
      var a = r[1];
      return caml_call1(f, a);
     }
     return caml_call2(Fiber[1][1], res_future, _r_);
    }
    function fold(f, t, state){
     function _p_(param){
      if(typeof param === "number") return caml_call1(Fiber[2], [0, state]);
      if(0 === param[0]){
       var err = param[1];
       return caml_call1(Fiber[2], [1, err]);
      }
      var t = param[2], a = param[1];
      return fold(f, t, caml_call2(f, a, state));
     }
     var _q_ = caml_call1(t, 0);
     return caml_call2(Fiber[1][1], _q_, _p_);
    }
    function fold_s(f, t, state){
     function _l_(param){
      if(typeof param === "number") return caml_call1(Fiber[2], [0, state]);
      if(0 === param[0]){
       var err = param[1];
       return caml_call1(Fiber[2], [1, [0, 48080384, err]]);
      }
      var t = param[2], a = param[1];
      function _n_(_o_){return fold_s(f, t, _o_);}
      return symbol(caml_call2(f, a, state), _n_);
     }
     var _m_ = caml_call1(t, 0);
     return caml_call2(Fiber[1][1], _m_, _l_);
    }
    function iter_s(f, t){
     function _i_(param){
      if(typeof param === "number") return caml_call1(Fiber[2], _a_);
      if(0 === param[0]){
       var err = param[1];
       return caml_call1(Fiber[2], [1, [0, 48080384, err]]);
      }
      var t = param[2], a = param[1];
      function _k_(param){return iter_s(f, t);}
      return symbol(caml_call1(f, a), _k_);
     }
     var _j_ = caml_call1(t, 0);
     return caml_call2(Fiber[1][1], _j_, _i_);
    }
    function to_rev_list(t){return fold(Stdlib_List[5], t, 0);}
    function to_list(t){
     var f = Stdlib_List[10], res_future = to_rev_list(t);
     function _g_(r){
      if(0 !== r[0]) return caml_call1(Fiber[2], r);
      var a = r[1], _h_ = [0, caml_call1(f, a)];
      return caml_call1(Fiber[2], _h_);
     }
     return caml_call2(Fiber[1][1], res_future, _g_);
    }
    function of_list(l, param){
     if(! l) return caml_call1(Fiber[2], 0);
     var
      tl = l[2],
      hd = l[1],
      _e_ = [1, hd, function(_f_){return of_list(tl, _f_);}];
     return caml_call1(Fiber[2], _e_);
    }
    function map_result(f, xs, param){
     function _b_(r){
      if(typeof r !== "number" && 1 === r[0]){
       var xs = r[2], x = r[1], match = caml_call1(f, x);
       if(0 === match[0]){
        var y = match[1];
        return [1, y, function(_d_){return map_result(f, xs, _d_);}];
       }
       var e = match[1];
       return [0, e];
      }
      return r;
     }
     var _c_ = caml_call1(xs, 0);
     return caml_call2(Fiber[1][2], _c_, _b_);
    }
    return [0,
            fold,
            fold_s,
            iter_s,
            to_rev_list,
            to_list,
            of_list,
            map_result];
   }
   var Caqti_platform_Stream = [0, Make];
   runtime.caml_register_global
    (2, Caqti_platform_Stream, "Caqti_platform__Stream");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__List_ext
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var _a_ = [0, 0];
   function fold(f, param){
    if(! param) return function(_c_){return _c_;};
    var xs = param[2], x = param[1];
    return function(acc){
     var _b_ = caml_call1(caml_call1(f, x), acc);
     return fold(f, xs)(_b_);};
   }
   function iteri_r(f, xs){
    var i = 0, param = xs;
    for(;;){
     if(! param) return _a_;
     var xs$0 = param[2], x = param[1], r = caml_call2(f, i, x);
     if(0 !== r[0]) return r;
     var i$0 = i + 1 | 0, i = i$0, param = xs$0;
    }
   }
   var Caqti_platform_List_ext = [0, fold, iteri_r];
   runtime.caml_register_global
    (1, Caqti_platform_List_ext, "Caqti_platform__List_ext");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__Request_utils
//# unitInfo: Requires: Caqti_error, Caqti_platform__List_ext, Caqti_query, Caqti_type, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_caqti_lib_platform_request = "caqti/lib-platform/request_utils.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Caqti_type = global_data.Caqti_type,
    Caqti_error = global_data.Caqti_error,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    Caqti_query = global_data.Caqti_query,
    Caqti_platform_List_ext = global_data.Caqti_platform__List_ext,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib = global_data.Stdlib,
    _e_ = [0, cst_caqti_lib_platform_request, 74, 24],
    _c_ = [0, cst_caqti_lib_platform_request, 61, 24],
    _d_ = [0, 0, 0],
    _b_ = [0, cst_caqti_lib_platform_request, 44, 24],
    _a_ = [0, cst_caqti_lib_platform_request, 32, 24];
   function no_env(param){throw caml_maybe_attach_backtrace(Stdlib[8], 1);}
   function linear_param_length(opt, templ){
    if(opt) var sth = opt[1], env = sth; else var env = no_env;
    var templ$0 = caml_call3(Caqti_query[18], 0, env, templ);
    function loop(param){
     switch(param[0]){
       case 0:
        return function(_L_){return _L_;};
       case 1:
        return function(_K_){return _K_ + 1 | 0;};
       case 2:
        return function(_J_){return _J_ + 1 | 0;};
       case 3:
        return function(_I_){return _I_ + 1 | 0;};
       case 4:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
       default:
        var frags = param[1];
        return caml_call2(Caqti_platform_List_ext[1], loop, frags);
     }
    }
    return caml_call1(loop(templ$0), 0);
   }
   function linear_param_order(opt, templ$0){
    if(opt) var sth = opt[1], env = sth; else var env = no_env;
    var
     templ$1 = caml_call3(Caqti_query[18], 0, env, templ$0),
     templ = caml_call3(Caqti_query[18], 0, no_env, templ$1);
    function loop(param){
     switch(param[0]){
       case 0:
        return function(_H_){return _H_;};
       case 1:
        return function(_G_){return _G_;};
       case 2:
        return function(_F_){return _F_;};
       case 3:
        var n = param[1]; return caml_call1(Stdlib[17], n + 1 | 0);
       case 4:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
       default:
        var frags = param[1];
        return caml_call2(Caqti_platform_List_ext[1], loop, frags);
     }
    }
    var a = runtime.caml_make_vect(caml_call1(loop(templ), 0), 0);
    function loop$0(param){
     switch(param[0]){
       case 0:
        return function(_E_){return _E_;};
       case 1:
        var v = param[2], t = param[1];
        return function(param){
         var params = param[2], j = param[1];
         return [0, j + 1 | 0, [0, [0, j, t, v], params]];};
       case 2:
        var s = param[1];
        return function(param){
         var params = param[2], j = param[1];
         return [0, j + 1 | 0, [0, [0, j, 6, s], params]];};
       case 3:
        var i = param[1];
        return function(param){
         var params = param[2], j = param[1];
         a[1 + i] = [0, j, runtime.caml_check_bound(a, i)[1 + i]];
         return [0, j + 1 | 0, params];};
       case 4:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       default:
        var frags = param[1];
        return caml_call2(Caqti_platform_List_ext[1], loop$0, frags);
     }
    }
    var
     params = caml_call1(loop$0(templ$1), _d_)[2],
     _D_ = caml_call1(Stdlib_List[10], params);
    return [0, caml_call1(Stdlib_Array[9], a), _D_];
   }
   function linear_query_string(opt, templ){
    if(opt) var sth = opt[1], env = sth; else var env = no_env;
    var
     templ$0 = caml_call3(Caqti_query[18], 0, env, templ),
     buf = caml_call1(Stdlib_Buffer[1], 64);
    function loop(param){
     switch(param[0]){
       case 0:
        var s = param[1]; return caml_call2(Stdlib_Buffer[16], buf, s);
       case 4:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
       case 5:
        var frags = param[1]; return caml_call2(Stdlib_List[18], loop, frags);
       default: return caml_call2(Stdlib_Buffer[12], buf, 63);
     }
    }
    loop(templ$0);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function raise_encode_missing(uri, field_type, param){
    var _C_ = caml_call3(Caqti_error[10], uri, field_type, 0);
    throw caml_maybe_attach_backtrace([0, Caqti_error[23], _C_], 1);
   }
   function raise_encode_rejected(uri, typ, msg){
    var _B_ = caml_call3(Caqti_error[11], uri, typ, msg);
    throw caml_maybe_attach_backtrace([0, Caqti_error[23], _B_], 1);
   }
   function raise_encode_failed(uri, typ, msg){
    var _A_ = caml_call3(Caqti_error[12], uri, typ, msg);
    throw caml_maybe_attach_backtrace([0, Caqti_error[23], _A_], 1);
   }
   function raise_decode_missing(uri, field_type, param){
    var _z_ = caml_call3(Caqti_error[14], uri, field_type, 0);
    throw caml_maybe_attach_backtrace([0, Caqti_error[23], _z_], 1);
   }
   function raise_decode_rejected(uri, typ, msg){
    var _y_ = caml_call3(Caqti_error[15], uri, typ, msg);
    throw caml_maybe_attach_backtrace([0, Caqti_error[23], _y_], 1);
   }
   function raise_response_failed(uri, query, msg){
    var _x_ = caml_call3(Caqti_error[16], uri, query, msg);
    throw caml_maybe_attach_backtrace([0, Caqti_error[23], _x_], 1);
   }
   function raise_response_rejected(uri, query, msg){
    var _w_ = caml_call3(Caqti_error[17], uri, query, msg);
    throw caml_maybe_attach_backtrace([0, Caqti_error[23], _w_], 1);
   }
   function encode_null_param(uri, f){
    return function(param){
     switch(param[0]){
       case 0:
        var ft = param[1]; return caml_call2(f[2], uri, ft);
       case 1:
        var t = param[1]; return encode_null_param(uri, f)(t);
       case 2:
        var
         ts = param[3],
         loop =
           function(param){
            if(! param) return function(_v_){return _v_;};
            var
             ts = param[3],
             t = param[1],
             g = loop(ts),
             f$0 = encode_null_param(uri, f)(t);
            return function(x){return g(caml_call1(f$0, x));};
           };
        return loop(ts);
       default: var t$0 = param[2]; return encode_null_param(uri, f)(t$0);
     }};
   }
   function encode_param(uri, f){
    return function(typ){
     switch(typ[0]){
       case 0:
        var ft = typ[1]; return caml_call2(f[1], uri, ft);
       case 1:
        var t = typ[1];
        return function(param){
         if(! param) return encode_null_param(uri, f)(t);
         var x = param[1];
         return caml_call1(encode_param(uri, f)(t), x);};
       case 2:
        var
         ts = typ[3],
         loop =
           function(param){
            if(! param) return function(param, acc){return acc;};
            var
             ts = param[3],
             p = param[2],
             t = param[1],
             encode_t = encode_param(uri, f)(t),
             encode_ts = loop(ts);
            return function(x, acc){
             var _s_ = caml_call2(encode_t, caml_call1(p, x), acc);
             return caml_call1
                     (function(_t_){var _u_ = _t_; return encode_ts(x, _u_);},
                      _s_);};
           };
        try{var _r_ = loop(ts); return _r_;}
        catch(exn$0){
         var exn = caml_wrap_exception(exn$0);
         if(exn[1] !== Caqti_type[1])
          throw caml_maybe_attach_backtrace(exn, 0);
         var msg$0 = exn[2], msg = [0, Caqti_error[4], msg$0];
         return raise_encode_rejected(uri, typ, msg);
        }
       default: var t$0 = typ[2]; return encode_param(uri, f)(t$0);
     }};
   }
   function reject_decode(uri, typ, msg){
    var msg$0 = [0, Caqti_error[4], msg];
    return raise_decode_rejected(uri, typ, msg$0);
   }
   function decode_row(uri, f){
    return function(typ){
     switch(typ[0]){
       case 0:
        var ft = typ[1]; return caml_call2(f[1], uri, ft);
       case 1:
        var t = typ[1], decode_t = decode_row(uri, f)(t);
        return function(acc){
         var
          _q_ = caml_call1(Caqti_type[5], t),
          match = caml_call2(f[2], _q_, acc);
         if(match){var acc$0 = match[1]; return [0, 0, acc$0];}
         var
          match$0 = caml_call1(decode_t, acc),
          acc$1 = match$0[2],
          x = match$0[1];
         return [0, [0, x], acc$1];};
       case 2:
        var _f_ = typ[3], intro = typ[2];
        if(! _f_) return function(acc){return [0, intro, acc];};
        var _g_ = _f_[3];
        if(_g_){
         var _h_ = _g_[3], t2 = _g_[1], t1 = _f_[1];
         if(! _h_){
          var
           decode_t1$1 = decode_row(uri, f)(t1),
           decode_t2$1 = decode_row(uri, f)(t2);
          return function(acc){
           var
            match = caml_call1(decode_t1$1, acc),
            acc$0 = match[2],
            x1 = match[1],
            match$0 = caml_call1(decode_t2$1, acc$0),
            acc$1 = match$0[2],
            x2 = match$0[1];
           try{var _p_ = [0, caml_call2(intro, x1, x2), acc$1]; return _p_;}
           catch(exn$0){
            var exn = caml_wrap_exception(exn$0);
            if(exn[1] !== Caqti_type[1])
             throw caml_maybe_attach_backtrace(exn, 0);
            var msg = exn[2];
            return reject_decode(uri, typ, msg);
           }};
         }
         var _i_ = _h_[3], t3 = _h_[1];
         if(! _i_){
          var
           decode_t1$0 = decode_row(uri, f)(t1),
           decode_t2$0 = decode_row(uri, f)(t2),
           decode_t3$0 = decode_row(uri, f)(t3);
          return function(acc){
           var
            match = caml_call1(decode_t1$0, acc),
            acc$0 = match[2],
            x1 = match[1],
            match$0 = caml_call1(decode_t2$0, acc$0),
            acc$1 = match$0[2],
            x2 = match$0[1],
            match$1 = caml_call1(decode_t3$0, acc$1),
            acc$2 = match$1[2],
            x3 = match$1[1];
           try{
            var _o_ = [0, caml_call3(intro, x1, x2, x3), acc$2];
            return _o_;
           }
           catch(exn$0){
            var exn = caml_wrap_exception(exn$0);
            if(exn[1] !== Caqti_type[1])
             throw caml_maybe_attach_backtrace(exn, 0);
            var msg = exn[2];
            return reject_decode(uri, typ, msg);
           }};
         }
         if(! _i_[3]){
          var
           t4 = _i_[1],
           decode_t1 = decode_row(uri, f)(t1),
           decode_t2 = decode_row(uri, f)(t2),
           decode_t3 = decode_row(uri, f)(t3),
           decode_t4 = decode_row(uri, f)(t4);
          return function(acc){
           var
            match = caml_call1(decode_t1, acc),
            acc$0 = match[2],
            x1 = match[1],
            match$0 = caml_call1(decode_t2, acc$0),
            acc$1 = match$0[2],
            x2 = match$0[1],
            match$1 = caml_call1(decode_t3, acc$1),
            acc$2 = match$1[2],
            x3 = match$1[1],
            match$2 = caml_call1(decode_t4, acc$2),
            acc$3 = match$2[2],
            x4 = match$2[1];
           try{
            var _n_ = [0, caml_call4(intro, x1, x2, x3, x4), acc$3];
            return _n_;
           }
           catch(exn$0){
            var exn = caml_wrap_exception(exn$0);
            if(exn[1] !== Caqti_type[1])
             throw caml_maybe_attach_backtrace(exn, 0);
            var msg = exn[2];
            return reject_decode(uri, typ, msg);
           }};
         }
        }
        var
         ts = typ[3],
         intro$0 = typ[2],
         loop =
           function(param){
            if(! param) return function(intro, acc){return [0, intro, acc];};
            var
             ts = param[3],
             t = param[1],
             decode_t = decode_row(uri, f)(t),
             decode_ts = loop(ts);
            return function(intro, acc){
             var
              match = caml_call1(decode_t, acc),
              acc$0 = match[2],
              x = match[1];
             return decode_ts(caml_call1(intro, x), acc$0);};
           };
        try{
         var
          _k_ = loop(ts),
          _j_ = function(_l_){var _m_ = _l_; return _k_(intro$0, _m_);};
         return _j_;
        }
        catch(exn$0){
         var exn = caml_wrap_exception(exn$0);
         if(exn[1] !== Caqti_type[1])
          throw caml_maybe_attach_backtrace(exn, 0);
         var msg = exn[2];
         return reject_decode(uri, typ, msg);
        }
       default: var t0 = typ[2]; return decode_row(uri, f)(t0);
     }};
   }
   var
    Caqti_platform_Request_utils =
      [0,
       linear_param_length,
       linear_param_order,
       linear_query_string,
       raise_encode_missing,
       raise_encode_rejected,
       raise_encode_failed,
       raise_decode_missing,
       raise_decode_rejected,
       raise_response_failed,
       raise_response_rejected,
       encode_param,
       decode_row];
   runtime.caml_register_global
    (14, Caqti_platform_Request_utils, "Caqti_platform__Request_utils");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__Heap
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    cst_Caqti_heap_pop_e_Empty_hea = "Caqti_heap.pop_e: Empty heap.";
   function Make(Elt){
    var empty = 0;
    function is_empty(h){return 0 === h ? 1 : 0;}
    function card(param){if(! param) return 0; var n = param[1]; return n;}
    function push(e, param){
     if(! param) return [0, 1, e, 0, 0];
     var hR = param[4], hL = param[3], e$0 = param[2], n = param[1];
     if(0 <= caml_call2(Elt[1], e, e$0))
      var e_max = e, e_min = e$0;
     else
      var e_max = e$0, e_min = e;
     var _a_ = card(hR);
     return card(hL) < _a_
             ? [0, n + 1 | 0, e_min, push(e_max, hL), hR]
             : [0, n + 1 | 0, e_min, hL, push(e_max, hR)];
    }
    function merge(hL, hR){
     if(hL){
      if(hR){
       var
        hD = hR[4],
        hC = hR[3],
        eR = hR[2],
        nR = hR[1],
        hB = hL[4],
        hA = hL[3],
        eL = hL[2],
        nL = hL[1];
       return 0 <= caml_call2(Elt[1], eL, eR)
               ? [0, nL + nR | 0, eR, hL, merge(hC, hD)]
               : [0, nL + nR | 0, eL, merge(hA, hB), hR];
      }
      var h = hL;
     }
     else
      var h = hR;
     return h;
    }
    function pop_e(param){
     if(! param) return caml_call1(Stdlib[1], cst_Caqti_heap_pop_e_Empty_hea);
     var hR = param[4], hL = param[3], e = param[2];
     return [0, e, merge(hL, hR)];
    }
    return [0, empty, is_empty, card, push, merge, pop_e];
   }
   var Caqti_platform_Heap = [0, Make];
   runtime.caml_register_global
    (2, Caqti_platform_Heap, "Caqti_platform__Heap");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__Pool
//# unitInfo: Requires: Caqti_platform__Heap, Caqti_pool_config, Logs, Mtime, Mtime_clock, Stdlib, Stdlib__Float, Stdlib__Option, Stdlib__Queue, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Cannot_schedule_pool_expir =
      "Cannot schedule pool expiration check due to Mtime overflow.",
    cst_Dropped_pooled_connection_ =
      "Dropped pooled connection due to invalidation.",
    cst_Will_not_repool_connection =
      "Will not repool connection due to invalidation.",
    cst_caqti_lib_platform_pool_ml = "caqti/lib-platform/pool.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Queue = global_data.Stdlib__Queue,
    Mtime = global_data.Mtime,
    Stdlib_Option = global_data.Stdlib__Option,
    Logs = global_data.Logs,
    Mtime_clock = global_data.Mtime_clock,
    Caqti_pool_config = global_data.Caqti_pool_config,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Float = global_data.Stdlib__Float,
    Caqti_platform_Heap = global_data.Caqti_platform__Heap,
    Stdlib = global_data.Stdlib,
    _f_ =
      [0,
       [11, cst_Dropped_pooled_connection_, 0],
       cst_Dropped_pooled_connection_],
    _g_ =
      [0,
       [11, cst_Cannot_schedule_pool_expir, 0],
       cst_Cannot_schedule_pool_expir],
    _h_ =
      [0,
       [11, cst_Will_not_repool_connection, 0],
       cst_Will_not_repool_connection],
    _b_ = [0, 100],
    _e_ = [0, cst_caqti_lib_platform_pool_ml, 124, 4],
    _d_ = [0, cst_caqti_lib_platform_pool_ml, 125, 4],
    _c_ = [0, cst_caqti_lib_platform_pool_ml, 126, 4],
    cst_Caqti_platform_Pool = "Caqti_platform.Pool";
   try{
    var
     _j_ =
       runtime.caml_int_of_string
        (runtime.caml_sys_getenv("CAQTI_POOL_MAX_SIZE")),
     default_max_size = _j_;
   }
   catch(_ag_){
    var _a_ = caml_wrap_exception(_ag_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    var default_max_size = 8;
   }
   var default_log_src = caml_call2(Logs[7][1], 0, cst_Caqti_platform_Pool);
   function Make(System, Alarm){
    function symbol(m, f){
     function _af_(param){
      if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
      var e = param[1];
      return caml_call1(System[1][2], [1, e]);
     }
     return caml_call2(System[1][1][1], m, _af_);
    }
    function wake(param){
     var semaphore = param[2];
     return caml_call1(System[4][2], semaphore);
    }
    function compare(param, _ae_){
     var pB = _ae_[1], pA = param[1];
     return caml_call2(Stdlib_Float[21], pB, pA);
    }
    var
     Task = [0, wake, compare],
     Taskq = caml_call1(Caqti_platform_Heap[1], [0, Task[2]]);
    function create(opt, _Z_, _Y_, _X_, sw, stdenv, create, free){
     if(opt)
      var sth = opt[1], config = sth;
     else
      var config = Caqti_pool_config[2];
     if(_Z_)
      var sth$0 = _Z_[1], check = sth$0;
     else
      var check = function(param, f){return caml_call1(f, 1);};
     if(_Y_)
      var sth$1 = _Y_[1], validate = sth$1;
     else
      var validate = function(param){return caml_call1(System[1][2], 1);};
     if(_X_)
      var sth$2 = _X_[1], log_src = sth$2;
     else
      var log_src = default_log_src;
     var
      ___ =
        caml_call1
         (caml_call1(Caqti_pool_config[5], Caqti_pool_config[8]), config),
      max_size = caml_call2(Stdlib_Option[3], ___, default_max_size),
      _$_ =
        caml_call1
         (caml_call1(Caqti_pool_config[5], Caqti_pool_config[9]), config),
      max_idle_size = caml_call2(Stdlib_Option[3], _$_, max_size),
      _aa_ =
        caml_call1
         (caml_call1(Caqti_pool_config[5], Caqti_pool_config[10]), config),
      max_idle_age = caml_call2(Stdlib_Option[3], _aa_, 0),
      _ab_ =
        caml_call1
         (caml_call1(Caqti_pool_config[5], Caqti_pool_config[11]), config),
      max_use_count = caml_call2(Stdlib_Option[3], _ab_, _b_);
     if(0 >= max_size)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     if(max_idle_size > max_size)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     function _ac_(n){return 0 < n ? 1 : 0;}
     if(! caml_call3(Stdlib_Option[8], 1, _ac_, max_use_count))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var _ad_ = Taskq[1];
     return [0,
             stdenv,
             sw,
             create,
             free,
             check,
             validate,
             log_src,
             max_idle_size,
             max_idle_age,
             max_size,
             max_use_count,
             0,
             caml_call1(Stdlib_Queue[2], 0),
             _ad_,
             0];
    }
    function size(param){var cur_size = param[12]; return cur_size;}
    function wait(priority, pool){
     var semaphore = caml_call1(System[4][1], 0);
     pool[14] = caml_call2(Taskq[4], [0, priority, semaphore], pool[14]);
     return caml_call1(System[4][3], semaphore);
    }
    function schedule(pool){
     var _W_ = 1 - caml_call1(Taskq[2], pool[14]);
     if(! _W_) return _W_;
     var
      match = caml_call1(Taskq[6], pool[14]),
      taskq = match[2],
      task = match[1];
     pool[14] = taskq;
     return Task[1].call(null, task);
    }
    function realloc(pool){
     function on_error(param){
      pool[12] = pool[12] - 1 | 0;
      return schedule(pool);
     }
     function _S_(param){on_error(0); return caml_call1(System[1][2], 0);}
     function _T_(param){
      function _U_(param){
       if(0 === param[0]){
        var resource = param[1];
        return [0, [0, resource, 0, caml_call1(Mtime_clock[2], 0)]];
       }
       var err = param[1];
       on_error(0);
       return [1, err];
      }
      var _V_ = caml_call1(pool[3], 0);
      return caml_call2(System[1][1][2], _V_, _U_);
     }
     return caml_call2(System[1][5], _T_, _S_);
    }
    function acquire(priority, pool){
     if(! caml_call1(Stdlib_Queue[13], pool[13])){
      var
       entry = caml_call1(Stdlib_Queue[5], pool[13]),
       _N_ =
         function(ok){
          if(ok) return caml_call1(System[1][2], [0, entry]);
          function _P_(param){return realloc(pool);}
          function _Q_(f){return caml_call3(f, 0, 0, _f_);}
          var _R_ = caml_call2(System[5][2], [0, pool[7]], _Q_);
          return caml_call2(System[1][1][1], _R_, _P_);
         },
       _O_ = caml_call1(pool[6], entry[1]);
      return caml_call2(System[1][1][1], _O_, _N_);
     }
     if(pool[12] < pool[10]){
      pool[12] = pool[12] + 1 | 0;
      return realloc(pool);
     }
     function _L_(param){return acquire(priority, pool);}
     var _M_ = wait(priority, pool);
     return caml_call2(System[1][1][1], _M_, _L_);
    }
    function can_reuse(pool, entry){
     var _I_ = pool[12] <= pool[8] ? 1 : 0;
     if(! _I_) return _I_;
     var _J_ = pool[11];
     function _K_(n){return entry[2] < n ? 1 : 0;}
     return caml_call3(Stdlib_Option[8], 1, _K_, _J_);
    }
    function dispose_expiring(pool){
     var _D_ = pool[9], match = pool[15];
     if(! _D_){
      if(! match) return 0;
      var alarm = match[1];
      caml_call1(Alarm[2], alarm);
      pool[15] = 0;
      return 0;
     }
     var max_idle_age = _D_[1];
     if(match) return 0;
     var now = caml_call1(Mtime_clock[2], 0);
     for(;;){
      var match$0 = caml_call1(Stdlib_Queue[9], pool[13]);
      if(! match$0) return 0;
      var
       entry = match$0[1],
       match$1 = caml_call2(Mtime[11], entry[3], max_idle_age);
      if(! match$1){
       var _H_ = function(f){return caml_call3(f, 0, 0, _g_);};
       return caml_call2(Logs[12], [0, pool[7]], _H_);
      }
      var expiry = match$1[1];
      if(0 > caml_call2(Mtime[7], now, expiry)){
       var
        _F_ = function(param){pool[15] = 0; return dispose_expiring(pool);},
        _G_ = caml_call4(Alarm[1], pool[2], pool[1], expiry, _F_);
       pool[15] = caml_call1(Stdlib_Option[2], _G_);
       return 0;
      }
      var entry$0 = caml_call1(Stdlib_Queue[5], pool[13]);
      pool[12] = pool[12] - 1 | 0;
      var
       _E_ =
         function(entry){
           return function(param){return caml_call1(pool[4], entry[1]);};
          }
          (entry$0);
      caml_call2(System[3], pool[2], _E_);
     }
    }
    function release(pool, entry){
     if(can_reuse(pool, entry)){
      var
       _z_ =
         function(ok){
          if(ok){
           entry[3] = caml_call1(Mtime_clock[2], 0);
           caml_call2(Stdlib_Queue[3], entry, pool[13]);
           dispose_expiring(pool);
          }
          else{
           var _C_ = function(f){return caml_call3(f, 0, 0, _h_);};
           caml_call2(Logs[12], [0, pool[7]], _C_);
           pool[12] = pool[12] - 1 | 0;
          }
          return schedule(pool);
         };
      caml_call2(pool[5], entry[1], _z_);
      return caml_call1(System[1][2], 0);
     }
     pool[12] = pool[12] - 1 | 0;
     function _A_(param){return schedule(pool);}
     var _B_ = caml_call1(pool[4], entry[1]);
     return caml_call2(System[1][1][2], _B_, _A_);
    }
    function use(opt, f, pool){
     if(opt) var sth = opt[1], priority = sth; else var priority = 0.;
     function _w_(entry){
      function _x_(param){
       entry[2] = entry[2] + 1 | 0;
       return release(pool, entry);
      }
      function _y_(param){return caml_call1(f, entry[1]);}
      return caml_call2(System[1][4], _y_, _x_);
     }
     return symbol(acquire(priority, pool), _w_);
    }
    function drain(pool){
     if(0 === pool[12]){
      var
       _s_ = pool[15],
       _t_ =
         function(alarm){caml_call1(Alarm[2], alarm); pool[15] = 0; return 0;};
      caml_call1(caml_call1(Stdlib_Option[9], _t_), _s_);
      return caml_call1(System[1][2], 0);
     }
     function _u_(param){return drain(pool);}
     var match = caml_call1(Stdlib_Queue[6], pool[13]);
     if(match){
      var entry = match[1];
      pool[12] = pool[12] - 1 | 0;
      var _v_ = caml_call1(pool[4], entry[1]);
     }
     else
      var _v_ = wait(0., pool);
     return caml_call2(System[1][1][1], _v_, _u_);
    }
    return [0, , , , create, size, , , , , , , , use, drain];
   }
   function schedule(param, _r_, _q_, _p_){return 0;}
   function unschedule(param){return 0;}
   var No_alarm = [0, schedule, unschedule];
   function _i_(_n_){
    var _o_ = Make(_n_, No_alarm);
    return [0, _o_[5], _o_[13], _o_[14], _o_[4]];
   }
   var
    Caqti_platform_Pool =
      [0,
       function(_l_, _k_){
        var _m_ = Make(_l_, _k_);
        return [0, _m_[5], _m_[13], _m_[14], _m_[4]];
       },
       _i_];
   runtime.caml_register_global
    (21, Caqti_platform_Pool, "Caqti_platform__Pool");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__Logging
//# unitInfo: Requires: Logs
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Logs = global_data.Logs,
    default_log_src = caml_call2(Logs[7][1], 0, "caqti"),
    request_log_src = caml_call2(Logs[7][1], 0, "caqti.request"),
    Caqti_platform_Logging = [0, default_log_src, request_log_src];
   runtime.caml_register_global
    (3, Caqti_platform_Logging, "Caqti_platform__Logging");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__Driver_loader
//# unitInfo: Requires: Stdlib__Hashtbl
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    drivers = caml_call2(Stdlib_Hashtbl[1], 0, 5);
   function register(scheme, p){
    return caml_call3(Stdlib_Hashtbl[5], drivers, scheme, p);
   }
   function Make(System){
    var provides_unix = 0;
    function find_and_apply(scheme){
     var match = caml_call2(Stdlib_Hashtbl[7], drivers, scheme);
     if(! match) return 0;
     var F = match[1];
     return [0, caml_call1(F, System)];
    }
    return [0, provides_unix, find_and_apply];
   }
   var Caqti_platform_Driver_loader = [0, register, Make];
   runtime.caml_register_global
    (1, Caqti_platform_Driver_loader, "Caqti_platform__Driver_loader");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__Conv
//# unitInfo: Requires: Ptime, Stdlib, Stdlib__Buffer, Stdlib__Format, Stdlib__Printf, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Caqti_platform_datetuple_o$1 = "Caqti_platform.datetuple_of_iso8601",
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ptime = global_data.Ptime,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_String = global_data.Stdlib__String,
    _c_ =
      [0,
       [11, "Cannot parse date ", [3, 0, [12, 46, 0]]],
       "Cannot parse date %S."],
    _d_ =
      [0,
       [11, "Date ", [2, 0, [11, " is out of range.", 0]]],
       "Date %s is out of range."],
    cst_00 = ":00",
    cst_Z = "Z",
    _b_ = [0, [11, " in value ", [3, 0, [12, 46, 0]]], " in value %S."],
    _a_ =
      [0,
       [4,
        0,
        [0, 2, 4],
        0,
        [12, 45, [4, 0, [0, 2, 2], 0, [12, 45, [4, 0, [0, 2, 2], 0, 0]]]]],
       "%04d-%02d-%02d"],
    cst_Caqti_platform_datetuple_o = cst_Caqti_platform_datetuple_o$1,
    cst_Caqti_platform_datetuple_o$0 = cst_Caqti_platform_datetuple_o$1;
   function datetuple_of_iso8601(s){
    if
     (10 === caml_ml_string_length(s)
      && 45 === caml_string_get(s, 4) && 45 === caml_string_get(s, 7))
     try{
      var
       _j_ = caml_int_of_string(caml_call3(Stdlib_String[16], s, 8, 2)),
       _k_ = caml_int_of_string(caml_call3(Stdlib_String[16], s, 5, 2)),
       _l_ =
         [0,
          caml_int_of_string(caml_call3(Stdlib_String[16], s, 0, 4)),
          _k_,
          _j_];
      return _l_;
     }
     catch(_m_){
      var _i_ = caml_wrap_exception(_m_);
      if(_i_[1] === Stdlib[7])
       return caml_call1(Stdlib[2], cst_Caqti_platform_datetuple_o);
      throw caml_maybe_attach_backtrace(_i_, 0);
     }
    return caml_call1(Stdlib[2], cst_Caqti_platform_datetuple_o$0);
   }
   function iso8601_of_datetuple(param){
    var d = param[3], m = param[2], y = param[1];
    return caml_call4(Stdlib_Printf[4], _a_, y, m, d);
   }
   function ptime_of_rfc3339_utc(s){
    var n = caml_ml_string_length(s);
    a:
    if(13 <= n && ! (90 === caml_string_get(s, n - 1 | 0))){
     if
      (43 !== caml_string_get(s, n - 3 | 0)
       && 45 !== caml_string_get(s, n - 3 | 0)){
      if
       (43 !== caml_string_get(s, n - 6 | 0)
        && 45 !== caml_string_get(s, n - 6 | 0)){
       var input = caml_call2(Stdlib[28], s, cst_Z);
       break a;
      }
      var input = s;
      break a;
     }
     var input = caml_call2(Stdlib[28], s, cst_00);
    }
    else
     var input = s;
    var _h_ = caml_call4(Ptime[31], 0, 0, 0, input);
    if(0 === _h_[0]){var t = _h_[1][1]; return [0, t];}
    var
     err = _h_[1][2][2],
     buf = caml_call1(Stdlib_Buffer[1], 64),
     ppf = caml_call1(Stdlib_Format[114], buf);
    caml_call2(Ptime[28], ppf, err);
    caml_call3(Stdlib_Format[137], ppf, _b_, input);
    caml_call2(Stdlib_Format[38], ppf, 0);
    return [1, caml_call1(Stdlib_Buffer[2], buf)];
   }
   function pdate_of_iso8601(s){
    try{
     var _f_ = datetuple_of_iso8601(s), val = caml_call2(Ptime[22], 0, _f_);
    }
    catch(_g_){
     var _e_ = caml_wrap_exception(_g_);
     if(_e_[1] === Stdlib[7])
      return [1, caml_call2(Stdlib_Printf[4], _c_, s)];
     throw caml_maybe_attach_backtrace(_e_, 0);
    }
    if(! val) return [1, caml_call2(Stdlib_Printf[4], _d_, s)];
    var pdate = val[1];
    return [0, pdate];
   }
   function iso8601_of_pdate(x){
    return iso8601_of_datetuple(caml_call2(Ptime[23], 0, x));
   }
   var
    Caqti_platform_Conv =
      [0,
       datetuple_of_iso8601,
       iso8601_of_datetuple,
       ptime_of_rfc3339_utc,
       pdate_of_iso8601,
       iso8601_of_pdate];
   runtime.caml_register_global
    (14, Caqti_platform_Conv, "Caqti_platform__Conv");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__Connector
//# unitInfo: Requires: Caqti_connect_config, Caqti_driver_info, Caqti_error, Caqti_pool_config, Stdlib, Stdlib__Gc, Stdlib__Hashtbl, Stdlib__Printf, Uri
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_A_suitable_driver_for_the_ = "A suitable driver for the URI-scheme ",
    cst_Your_entry_point_provides_ =
      "Your entry point provides both the networking and unix components.",
    cst_Your_entry_point_provides_$0 =
      "Your entry point provides the networking but not the unix component, which is required by drivers based on C bindings.",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    msg = "Missing URI scheme.",
    Stdlib = global_data.Stdlib,
    Caqti_connect_config = global_data.Caqti_connect_config,
    Caqti_pool_config = global_data.Caqti_pool_config,
    Caqti_driver_info = global_data.Caqti_driver_info,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Uri = global_data.Uri,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Caqti_error = global_data.Caqti_error,
    Stdlib_Printf = global_data.Stdlib__Printf,
    dynload_library = [0, 0],
    cst_Caqti_connect_Make_connect = "Caqti_connect.Make.connect_pool",
    _b_ =
      [0,
       [11, cst_Your_entry_point_provides_, 0],
       cst_Your_entry_point_provides_],
    _e_ =
      [0,
       [11, cst_Your_entry_point_provides_$0, 0],
       cst_Your_entry_point_provides_$0],
    _c_ =
      [0,
       [11,
        cst_A_suitable_driver_for_the_,
        [2, 0, [11, " was not found. ", 0]]],
       "A suitable driver for the URI-scheme %s was not found. "],
    _d_ =
      [0,
       [11,
        cst_A_suitable_driver_for_the_,
        [2,
         0,
         [11, " was not found after linking in ", [2, 0, [11, ". ", 0]]]]],
       "A suitable driver for the URI-scheme %s was not found after linking in %s. "],
    cst_caqti_driver = "caqti-driver-",
    cst_caqti_driver_postgresql = "caqti-driver-postgresql",
    _a_ =
      [0,
       [11,
        "Neither ",
        [2,
         0,
         [11, " nor a dynamic loader is linked into the application.", 0]]],
       "Neither %s nor a dynamic loader is linked into the application."];
   function define_loader(load){dynload_library[1] = [0, load]; return 0;}
   function load_library(lib){
    var match = dynload_library[1];
    if(! match) return [1, caml_call2(Stdlib_Printf[4], _a_, lib)];
    var load = match[1];
    return caml_call1(load, lib);
   }
   function set_tweaks_version(param){
    if(! param) return function(_y_){return _y_;};
    var x = param[1];
    return caml_call1
            (caml_call1(Caqti_connect_config[3], Caqti_connect_config[5]), x);
   }
   var
    Caqti_platform_Connector =
      [0,
       define_loader,
       load_library,
       function(System, Pool, Loader){
        function symbol(m, f){
         function _x_(r){
          if(0 !== r[0]) return caml_call1(System[1][2], r);
          var x = r[1];
          return caml_call1(f, x);
         }
         return caml_call2(System[1][1][1], m, _x_);
        }
        function symbol$0(m, f){
         function _w_(r){
          if(0 !== r[0]) return r;
          var x = r[1];
          return [0, caml_call1(f, x)];
         }
         return caml_call2(System[1][1][2], m, _w_);
        }
        var
         drivers = caml_call2(Stdlib_Hashtbl[1], 0, 11),
         message_cont = Loader[1] ? _b_ : _e_,
         _f_ = caml_call2(Stdlib[98], _c_, message_cont),
         message_static = caml_call1(Stdlib_Printf[4], _f_),
         _g_ = caml_call2(Stdlib[98], _d_, message_cont),
         message_dynamic = caml_call1(Stdlib_Printf[4], _g_);
        function load_driver(uri){
         var match$3 = caml_call1(Uri[29], uri);
         if(! match$3)
          return [1,
                  caml_call2(Caqti_error[6], uri, [0, Caqti_error[4], msg])];
         var scheme = match$3[1];
         try{
          var _u_ = [0, caml_call2(Stdlib_Hashtbl[6], drivers, scheme)];
          return _u_;
         }
         catch(_v_){
          var _t_ = caml_wrap_exception(_v_);
          if(_t_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_t_, 0);
          var match = caml_call1(Loader[2], scheme);
          if(match)
           var driver = match[1], r = [0, driver];
          else{
           var match$0 = dynload_library[1];
           if(match$0){
            var load = match$0[1];
            a:
            {
             if
              (caml_string_notequal(scheme, "postgres")
               && caml_string_notequal(scheme, "postgresql")){
              var
               driver_lib = caml_call2(Stdlib[28], cst_caqti_driver, scheme);
              break a;
             }
             var driver_lib = cst_caqti_driver_postgresql;
            }
            var match$1 = caml_call1(load, driver_lib);
            if(0 === match$1[0]){
             var match$2 = caml_call1(Loader[2], scheme);
             if(match$2)
              var driver$0 = match$2[1], r = [0, driver$0];
             else
              var
               msg$0 = caml_call2(message_dynamic, scheme, driver_lib),
               r =
                 [1,
                  caml_call2(Caqti_error[7], uri, [0, Caqti_error[4], msg$0])];
            }
            else
             var
              msg$1 = match$1[1],
              r =
                [1,
                 caml_call2(Caqti_error[7], uri, [0, Caqti_error[4], msg$1])];
           }
           else
            var
             msg$2 = caml_call1(message_static, scheme),
             r =
               [1,
                caml_call2(Caqti_error[7], uri, [0, Caqti_error[4], msg$2])];
          }
          if(0 !== r[0]) return r;
          var driver$1 = r[1];
          caml_call3(Stdlib_Hashtbl[5], drivers, scheme, driver$1);
          return [0, driver$1];
         }
        }
        function connect(env, opt, tweaks_version, sw, stdenv, uri){
         if(opt)
          var sth = opt[1], config = sth;
         else
          var config = Caqti_connect_config[1];
         var
          config$0 = caml_call1(set_tweaks_version(tweaks_version), config);
         caml_call1(System[2][2], sw);
         var match = load_driver(uri);
         if(0 === match[0]){
          var
           driver = match[1],
           _s_ =
             function(conn){
              var
               driver_info = conn[1],
               driver_connection = conn[2],
               Response = conn[3],
               call = conn[4],
               set_statement_timeout = conn[5],
               start = conn[6],
               commit = conn[7],
               rollback = conn[8],
               deallocate = conn[9],
               disconnect = conn[10],
               validate = conn[11],
               check = conn[12],
               exec = conn[13],
               exec_with_affected_count = conn[14],
               find = conn[15],
               find_opt = conn[16],
               fold = conn[17],
               fold_s = conn[18],
               iter_s = conn[19],
               collect_list = conn[20],
               rev_collect_list = conn[21],
               with_transaction = conn[22],
               populate = conn[23],
               hook = caml_call2(System[2][3], sw, disconnect);
              function disconnect$0(param){
               caml_call1(System[2][4], hook);
               return caml_call1(disconnect, 0);
              }
              return [0,
                      driver_info,
                      driver_connection,
                      Response,
                      call,
                      set_statement_timeout,
                      start,
                      commit,
                      rollback,
                      deallocate,
                      disconnect$0,
                      validate,
                      check,
                      exec,
                      exec_with_affected_count,
                      find,
                      find_opt,
                      fold,
                      fold_s,
                      iter_s,
                      collect_list,
                      rev_collect_list,
                      with_transaction,
                      populate];
             };
          return symbol$0
                  (caml_call5(driver[2], sw, stdenv, env, config$0, uri), _s_);
         }
         var err = match[1];
         return caml_call1(System[1][2], [1, err]);
        }
        function with_connection(env, config, tweaks_version, stdenv, uri, f){
         function _r_(sw){
          return symbol
                  (connect(env, config, tweaks_version, sw, stdenv, uri), f);
         }
         return caml_call1(System[2][1], _r_);
        }
        function connect_pool
        (pool_config, post_connect, env, opt, tweaks_version, sw, stdenv, uri){
         if(opt)
          var sth = opt[1], config = sth;
         else
          var config = Caqti_connect_config[1];
         if(pool_config)
          var pool_config$0 = pool_config[1], pool_config$1 = pool_config$0;
         else
          var pool_config$1 = caml_call1(Caqti_pool_config[3], 0);
         var
          config$0 = caml_call1(set_tweaks_version(tweaks_version), config);
         caml_call1(System[2][2], sw);
         function check_arg(cond){
          var _q_ = 1 - cond;
          return _q_
                  ? caml_call1(Stdlib[1], cst_Caqti_connect_Make_connect)
                  : _q_;
         }
         var
          match =
            caml_call1
             (caml_call1(Caqti_pool_config[5], Caqti_pool_config[8]),
              pool_config$1),
          match$0 =
            caml_call1
             (caml_call1(Caqti_pool_config[5], Caqti_pool_config[9]),
              pool_config$1);
         if(match){
          var max_size = match[1];
          if(match$0){
           var max_idle_size = match$0[1];
           check_arg(0 <= max_size ? 1 : 0);
           var
            _h_ = 0 <= max_idle_size ? 1 : 0,
            _i_ = _h_ ? max_idle_size <= max_size ? 1 : 0 : _h_;
           check_arg(_i_);
          }
          else
           check_arg(0 <= max_size ? 1 : 0);
         }
         else if(match$0) check_arg(0);
         var match$1 = load_driver(uri);
         if(0 !== match$1[0]){var err = match$1[1]; return [1, err];}
         var driver = match$1[1];
         if(post_connect)
          var
           post_connect$0 = post_connect[1],
           connect =
             function(param){
              function _o_(conn){
               function _p_(param){return conn;}
               return symbol$0(caml_call1(post_connect$0, conn), _p_);
              }
              return symbol
                      (caml_call5(driver[2], sw, stdenv, env, config$0, uri), _o_);
             };
         else
          var
           connect =
             function(param){
              return caml_call5(driver[2], sw, stdenv, env, config$0, uri);
             };
         function disconnect(Db){return caml_call1(Db[10], 0);}
         function validate(Db){return caml_call1(Db[11], 0);}
         function check(Db){return Db[12];}
         var
          di = driver[1],
          match$2 = caml_call1(Caqti_driver_info[7], di),
          match$3 = caml_call1(Caqti_driver_info[6], di),
          match$4 =
            caml_call1
             (caml_call1(Caqti_pool_config[5], Caqti_pool_config[9]),
              pool_config$1);
         a:
         if(match$2)
          var
           pool_config$2 =
             match$3
              ? pool_config$1
              : caml_call1
                (caml_call1
                  (caml_call1(Caqti_pool_config[6], Caqti_pool_config[9]), 0),
                 pool_config$1);
         else if(match$3){
          if(match$4 && 0 === match$4[1]){
           var
            _l_ =
              caml_call1
               (caml_call1
                 (caml_call1(Caqti_pool_config[6], Caqti_pool_config[8]), 1),
                pool_config$1),
            pool_config$2 =
              caml_call1
               (caml_call1
                 (caml_call1(Caqti_pool_config[6], Caqti_pool_config[9]), 0),
                _l_);
           break a;
          }
          var
           _m_ =
             caml_call1
              (caml_call1
                (caml_call1(Caqti_pool_config[6], Caqti_pool_config[8]), 1),
               pool_config$1),
           pool_config$2 =
             caml_call1
              (caml_call1
                (caml_call1(Caqti_pool_config[6], Caqti_pool_config[9]), 1),
               _m_);
         }
         else
          var
           _n_ =
             caml_call1
              (caml_call1
                (caml_call1(Caqti_pool_config[6], Caqti_pool_config[8]), 1),
               pool_config$1),
           pool_config$2 =
             caml_call1
              (caml_call1
                (caml_call1(Caqti_pool_config[6], Caqti_pool_config[9]), 0),
               _n_);
         var
          pool =
            caml_call8
             (Pool[4],
              [0, pool_config$2],
              [0, check],
              [0, validate],
              0,
              sw,
              stdenv,
              connect,
              disconnect);
         function _j_(param){return caml_call1(Pool[3], pool);}
         var hook = caml_call2(System[2][3], sw, _j_);
         function _k_(param){return caml_call1(System[2][4], hook);}
         caml_call2(Stdlib_Gc[3], _k_, pool);
         return [0, pool];
        }
        return [0, connect, with_connection, connect_pool];
       }];
   runtime.caml_register_global
    (20, Caqti_platform_Connector, "Caqti_platform__Connector");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_platform__Connection_utils
//# unitInfo: Requires: Caqti_mult, Caqti_query, Caqti_request, Caqti_type, Stdlib, Stdlib__List, Stdlib__Printf, Stdlib__Result, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = ", ";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Caqti_query = global_data.Caqti_query,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Caqti_mult = global_data.Caqti_mult,
    Caqti_type = global_data.Caqti_type,
    Caqti_request = global_data.Caqti_request,
    Stdlib_Result = global_data.Stdlib__Result,
    Stdlib = global_data.Stdlib,
    _a_ = [0, [0, ")"], 0],
    _b_ =
      [0,
       [11, "INSERT INTO ", [2, 0, [11, " (", [2, 0, [11, ") VALUES (", 0]]]]],
       "INSERT INTO %s (%s) VALUES ("],
    cst_detected = " detected.",
    cst_Invalid_concurrent_usage_o = "Invalid concurrent usage of ";
   function Make_helpers(System){
    function assert_single_use(what, in_use, f){
     if(in_use[1]){
      var
       _H_ = caml_call2(Stdlib[28], what, cst_detected),
       _I_ = caml_call2(Stdlib[28], cst_Invalid_concurrent_usage_o, _H_);
      caml_call1(Stdlib[2], _I_);
     }
     in_use[1] = 1;
     function _J_(param){in_use[1] = 0; return caml_call1(System[1][2], 0);}
     function _K_(param){
      function _L_(res){in_use[1] = 0; return res;}
      var _M_ = caml_call1(f, 0);
      return caml_call2(System[1][1][2], _M_, _L_);
     }
     return caml_call2(System[1][5], _K_, _J_);
    }
    return [0, assert_single_use];
   }
   function _c_(System, C){
    function symbol(m, f){
     function _G_(r){
      if(0 !== r[0]) return caml_call1(System[1][2], r);
      var x = r[1];
      return caml_call1(f, x);
     }
     return caml_call2(System[1][1][1], m, _G_);
    }
    function populate(table, columns, row_type, data){
     var columns_tuple = caml_call2(Stdlib_String[7], cst, columns);
     function _v_(i, param){return [3, i];}
     var
      _w_ = caml_call2(Stdlib_List[21], _v_, columns),
      _x_ = [0, caml_call2(Caqti_query[1], cst$0, _w_), _a_],
      q =
        [5,
         [0,
          [0, caml_call3(Stdlib_Printf[4], _b_, table, columns_tuple)],
          _x_]];
     function _y_(param){return q;}
     var
      request =
        caml_call5
         (Caqti_request[1], 0, row_type, Caqti_type[30], Caqti_mult[1], _y_);
     function _z_(param){
      function _A_(res){
       function _D_(param){
        if(0 === res[0]) return caml_call1(C[5], 0);
        var err = res[1];
        if(typeof err !== "number" && 48080384 === err[1]){
         var
          err$0 = err[2],
          _F_ =
            function(param){
             return caml_call1(System[1][2], [1, [0, 48080384, err$0]]);
            };
         return symbol(caml_call1(C[6], 0), _F_);
        }
        return caml_call1(System[1][2], [1, err]);
       }
       var _E_ = caml_call1(C[7], request);
       return caml_call2(System[1][1][1], _E_, _D_);
      }
      var
       _B_ = caml_call2(C[2], C[1][3], request),
       _C_ = caml_call2(System[6][3], _B_, data);
      return caml_call2(System[1][1][1], _C_, _A_);
     }
     return symbol(caml_call1(C[4], 0), _z_);
    }
    return [0, populate];
   }
   var
    Caqti_platform_Connection_util =
      [0,
       Make_helpers,
       function(System, C){
        var Response = C[1];
        function exec(q, p){return caml_call3(C[2], Response[3], q, p);}
        function find(q, p){return caml_call3(C[2], Response[4], q, p);}
        function find_opt(q, p){return caml_call3(C[2], Response[5], q, p);}
        function fold(q, f, p, acc){
         function _u_(resp){return caml_call3(Response[6], f, resp, acc);}
         return caml_call3(C[2], _u_, q, p);
        }
        function fold_s(q, f, p, acc){
         function _t_(resp){return caml_call3(Response[7], f, resp, acc);}
         return caml_call3(C[2], _t_, q, p);
        }
        function iter_s(q, f, p){
         function _s_(resp){return caml_call2(Response[8], f, resp);}
         return caml_call3(C[2], _s_, q, p);
        }
        function collect_list(q, p){
         function f(resp){
          var
           _q_ = caml_call1(Stdlib_Result[8], Stdlib_List[10]),
           _r_ = caml_call3(Response[6], Stdlib_List[5], resp, 0);
          return caml_call2(System[1][1][2], _r_, _q_);
         }
         return caml_call3(C[2], f, q, p);
        }
        function rev_collect_list(q, p){
         function f(resp){
          return caml_call3(Response[6], Stdlib_List[5], resp, 0);
         }
         return caml_call3(C[2], f, q, p);
        }
        function exec_with_affected_count(q, p){
         function f(response){
          function _o_(execResult){
           if(0 === execResult[0]) return caml_call1(Response[2], response);
           var x = execResult[1];
           return caml_call1(System[1][2], [1, x]);
          }
          var _p_ = caml_call1(Response[3], response);
          return caml_call2(System[1][1][1], _p_, _o_);
         }
         return caml_call3(C[2], f, q, p);
        }
        function with_transaction(f){
         var m = caml_call1(C[4], 0);
         function _d_(r){
          if(0 !== r[0]) return caml_call1(System[1][2], r);
          function _e_(param){
           function _l_(_n_){return 0;}
           var _m_ = caml_call1(C[6], 0);
           return caml_call2(System[1][1][2], _m_, _l_);
          }
          function _f_(param){
           function _g_(r){
            if(0 === r[0]){
             var
              y = r[1],
              m = caml_call1(C[5], 0),
              _i_ = function(r){return 0 === r[0] ? [0, y] : r;};
             return caml_call2(System[1][1][2], m, _i_);
            }
            function _j_(param){return r;}
            var _k_ = caml_call1(C[6], 0);
            return caml_call2(System[1][1][2], _k_, _j_);
           }
           var _h_ = caml_call1(f, 0);
           return caml_call2(System[1][1][1], _h_, _g_);
          }
          return caml_call2(System[1][5], _f_, _e_);
         }
         return caml_call2(System[1][1][1], m, _d_);
        }
        return [0,
                exec,
                exec_with_affected_count,
                find,
                find_opt,
                fold,
                fold_s,
                iter_s,
                collect_list,
                rev_collect_list,
                with_transaction];
       },
       _c_];
   runtime.caml_register_global
    (15, Caqti_platform_Connection_util, "Caqti_platform__Connection_utils");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJjYXF0aV9wbGF0Zm9ybS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZXRlcm5hbCIsImNyZWF0ZSIsInJlbGVhc2UiLCJwYXJhbSIsInRhc2tzIiwibG9vcCIsInJ1biIsImYiLCJzdyIsImNoZWNrIiwib25fcmVsZWFzZV9jYW5jZWxsYWJsZSIsInJlbW92ZV9ob29rIiwiaG9vayIsInN5bWJvbCIsInJlc19mdXR1cmUiLCJyIiwiYSIsImZvbGQiLCJ0Iiwic3RhdGUiLCJlcnIiLCJmb2xkX3MiLCJpdGVyX3MiLCJ0b19yZXZfbGlzdCIsInRvX2xpc3QiLCJvZl9saXN0IiwibCIsInRsIiwiaGQiLCJtYXBfcmVzdWx0IiwieHMiLCJ4IiwieSIsImUiLCJhY2MiLCJpdGVyaV9yIiwiaSIsInhzJDAiLCJub19lbnYiLCJsaW5lYXJfcGFyYW1fbGVuZ3RoIiwib3B0IiwidGVtcGwiLCJzdGgiLCJlbnYiLCJ0ZW1wbCQwIiwiZnJhZ3MiLCJsaW5lYXJfcGFyYW1fb3JkZXIiLCJ0ZW1wbCQxIiwibiIsImxvb3AkMCIsInYiLCJwYXJhbXMiLCJqIiwicyIsImxpbmVhcl9xdWVyeV9zdHJpbmciLCJidWYiLCJyYWlzZV9lbmNvZGVfbWlzc2luZyIsInVyaSIsImZpZWxkX3R5cGUiLCJyYWlzZV9lbmNvZGVfcmVqZWN0ZWQiLCJ0eXAiLCJtc2ciLCJyYWlzZV9lbmNvZGVfZmFpbGVkIiwicmFpc2VfZGVjb2RlX21pc3NpbmciLCJyYWlzZV9kZWNvZGVfcmVqZWN0ZWQiLCJyYWlzZV9yZXNwb25zZV9mYWlsZWQiLCJxdWVyeSIsInJhaXNlX3Jlc3BvbnNlX3JlamVjdGVkIiwiZW5jb2RlX251bGxfcGFyYW0iLCJmdCIsInRzIiwiZyIsImYkMCIsInQkMCIsImVuY29kZV9wYXJhbSIsInAiLCJlbmNvZGVfdCIsImVuY29kZV90cyIsIm1zZyQwIiwicmVqZWN0X2RlY29kZSIsImRlY29kZV9yb3ciLCJkZWNvZGVfdCIsImFjYyQwIiwiYWNjJDEiLCJpbnRybyIsInQyIiwidDEiLCJkZWNvZGVfdDEkMSIsImRlY29kZV90MiQxIiwieDEiLCJ4MiIsInQzIiwiZGVjb2RlX3QxJDAiLCJkZWNvZGVfdDIkMCIsImRlY29kZV90MyQwIiwiYWNjJDIiLCJ4MyIsInQ0IiwiZGVjb2RlX3QxIiwiZGVjb2RlX3QyIiwiZGVjb2RlX3QzIiwiZGVjb2RlX3Q0IiwiYWNjJDMiLCJ4NCIsImludHJvJDAiLCJkZWNvZGVfdHMiLCJ0MCIsImVtcHR5IiwiaXNfZW1wdHkiLCJoIiwiY2FyZCIsInB1c2giLCJoUiIsImhMIiwiZSQwIiwiZV9tYXgiLCJlX21pbiIsIm1lcmdlIiwiaEQiLCJoQyIsImVSIiwiblIiLCJoQiIsImhBIiwiZUwiLCJuTCIsInBvcF9lIiwiZGVmYXVsdF9tYXhfc2l6ZSIsImRlZmF1bHRfbG9nX3NyYyIsIm0iLCJ3YWtlIiwic2VtYXBob3JlIiwiY29tcGFyZSIsInBCIiwicEEiLCJzdGRlbnYiLCJmcmVlIiwiY29uZmlnIiwic3RoJDAiLCJzdGgkMSIsInZhbGlkYXRlIiwic3RoJDIiLCJsb2dfc3JjIiwibWF4X3NpemUiLCJtYXhfaWRsZV9zaXplIiwibWF4X2lkbGVfYWdlIiwibWF4X3VzZV9jb3VudCIsInNpemUiLCJjdXJfc2l6ZSIsIndhaXQiLCJwcmlvcml0eSIsInBvb2wiLCJzY2hlZHVsZSIsInRhc2txIiwidGFzayIsInJlYWxsb2MiLCJvbl9lcnJvciIsInJlc291cmNlIiwiYWNxdWlyZSIsImVudHJ5Iiwib2siLCJjYW5fcmV1c2UiLCJkaXNwb3NlX2V4cGlyaW5nIiwiYWxhcm0iLCJub3ciLCJleHBpcnkiLCJlbnRyeSQwIiwidXNlIiwiZHJhaW4iLCJ1bnNjaGVkdWxlIiwicmVxdWVzdF9sb2dfc3JjIiwiZHJpdmVycyIsInJlZ2lzdGVyIiwic2NoZW1lIiwicHJvdmlkZXNfdW5peCIsImZpbmRfYW5kX2FwcGx5IiwiRiIsImRhdGV0dXBsZV9vZl9pc284NjAxIiwiaXNvODYwMV9vZl9kYXRldHVwbGUiLCJkIiwicHRpbWVfb2ZfcmZjMzMzOV91dGMiLCJpbnB1dCIsInBwZiIsInBkYXRlX29mX2lzbzg2MDEiLCJwZGF0ZSIsImlzbzg2MDFfb2ZfcGRhdGUiLCJkeW5sb2FkX2xpYnJhcnkiLCJkZWZpbmVfbG9hZGVyIiwibG9hZCIsImxvYWRfbGlicmFyeSIsImxpYiIsInNldF90d2Vha3NfdmVyc2lvbiIsInN5bWJvbCQwIiwibWVzc2FnZV9jb250IiwibWVzc2FnZV9zdGF0aWMiLCJtZXNzYWdlX2R5bmFtaWMiLCJsb2FkX2RyaXZlciIsImRyaXZlciIsImRyaXZlcl9saWIiLCJkcml2ZXIkMCIsIm1zZyQxIiwibXNnJDIiLCJkcml2ZXIkMSIsImNvbm5lY3QiLCJ0d2Vha3NfdmVyc2lvbiIsImNvbmZpZyQwIiwiY29ubiIsImRyaXZlcl9pbmZvIiwiZHJpdmVyX2Nvbm5lY3Rpb24iLCJjYWxsIiwic2V0X3N0YXRlbWVudF90aW1lb3V0Iiwic3RhcnQiLCJjb21taXQiLCJyb2xsYmFjayIsImRlYWxsb2NhdGUiLCJkaXNjb25uZWN0IiwiZXhlYyIsImV4ZWNfd2l0aF9hZmZlY3RlZF9jb3VudCIsImZpbmQiLCJmaW5kX29wdCIsImNvbGxlY3RfbGlzdCIsInJldl9jb2xsZWN0X2xpc3QiLCJ3aXRoX3RyYW5zYWN0aW9uIiwicG9wdWxhdGUiLCJkaXNjb25uZWN0JDAiLCJ3aXRoX2Nvbm5lY3Rpb24iLCJjb25uZWN0X3Bvb2wiLCJwb29sX2NvbmZpZyIsInBvc3RfY29ubmVjdCIsInBvb2xfY29uZmlnJDAiLCJwb29sX2NvbmZpZyQxIiwiY2hlY2tfYXJnIiwiY29uZCIsInBvc3RfY29ubmVjdCQwIiwiRGIiLCJkaSIsInBvb2xfY29uZmlnJDIiLCJhc3NlcnRfc2luZ2xlX3VzZSIsIndoYXQiLCJpbl91c2UiLCJyZXMiLCJ0YWJsZSIsImNvbHVtbnMiLCJyb3dfdHlwZSIsImRhdGEiLCJjb2x1bW5zX3R1cGxlIiwicSIsInJlcXVlc3QiLCJlcnIkMCIsInJlc3AiLCJyZXNwb25zZSIsImV4ZWNSZXN1bHQiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jYXF0aS9wbGF0Zm9ybS9zd2l0Y2gubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jYXF0aS9wbGF0Zm9ybS9zdHJlYW0ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jYXF0aS9wbGF0Zm9ybS9saXN0X2V4dC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NhcXRpL3BsYXRmb3JtL3JlcXVlc3RfdXRpbHMubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jYXF0aS9wbGF0Zm9ybS9oZWFwLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY2FxdGkvcGxhdGZvcm0vcG9vbC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NhcXRpL3BsYXRmb3JtL2xvZ2dpbmcubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jYXF0aS9wbGF0Zm9ybS9kcml2ZXJfbG9hZGVyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY2FxdGkvcGxhdGZvcm0vY29udi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NhcXRpL3BsYXRmb3JtL2Nvbm5lY3Rvci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NhcXRpL3BsYXRmb3JtL2Nvbm5lY3Rpb25fdXRpbHMubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7OztJQXdERTtLQUFBO0tBRUlBO2FBQ0FDLGNBQVksZUFB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K0JBLGVBQS9CLE9BQUEsd0JBRElEO2VBSUkzTixJQUh1QjROO1dBR0wsT0FBQSw2QkFBbEI1TjtVQUEyQjtVQUhuQyxVQUFBLHdCQURJMk47VUFDdUIsT0FBQTtTQUdRO1NBQ3JDLE9BQUEsaUJBTEluUCxHQUR1QitPLEdBQUUzSztRQU1oQjtpQkFFWG1KLGlCQUFpQnZOO1NBQ25CLElBekJTMEgsSUF5QlQ7c0JBekI0Q2xIO1VBQXZCLFNBQXVCQSxNQUFnQixPQUFBLHlCQUFoQkE7O1dBK0IvQixrQjtXQUFBLFVBQUE7V0FBa0IsT0FBQTtVQUFNOzt3QkFEOUJBO1lBRk0sU0FFTkE7YUFEUTtjQUFMaUIsSUFDSGpCO2NBN0JFa0gsSUE0Qk07NkJBNUJrQ2xILEdBQTVCLGFBQTRCQSxXQTRCdkNpQixLQTVCdUNqQixFQUFpQjthQUE3QyxPQUFBLDRCQUFaa0g7O2dDQTZCeUMsT0FBM0NsSCxFQUE0QztZQUE1QixVQUFBO1lBQWtCLE9BQUE7V0FBVztXQUZoRCxVQUFBLFdBSmVSO1dBSU4sT0FBQTtVQUV1QztVQUNsRCxPQUFBO1NBL0J3RTtTQUFyRCxPQUFBLDRCQUFaMEg7UUErQjZCOztnQkE1QnBDdUY7Z0JBYUFDO2dCQVpBQztnQkFDQUM7Z0JBQ0ExTTtnQkFDQUk7Z0JBQ0FDO2dCQUNBc007Z0JBR0FDO2dCQVlBQzs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBDb3B5cmlnaHQgKEMpIDIwMjMgIFBldHRlciBBLiBVcmtlZGFsIDxwYXVya2VkYWxAZ21haWwuY29tPlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyXG4gKiBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLCB3aXRoIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbi5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFuZCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24gYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuICBJZiBub3QsIHNlZVxuICogPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+IGFuZCA8aHR0cHM6Ly9zcGR4Lm9yZz4sIHJlc3BlY3RpdmVseS5cbiAqKVxuXG5tb2R1bGUgdHlwZSBGSUJFUiA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuICBtb2R1bGUgSW5maXggOiBzaWdcbiAgICB2YWwgKD4+PSkgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG4gIGVuZFxuICB2YWwgZmluYWxseSA6ICh1bml0IC0+ICdhIHQpIC0+ICh1bml0IC0+IHVuaXQgdCkgLT4gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSBmaWJlclxuICB0eXBlIHRcbiAgdHlwZSBob29rXG5cbiAgZXhjZXB0aW9uIE9mZlxuXG4gIHZhbCBldGVybmFsIDogdFxuICB2YWwgY3JlYXRlIDogdW5pdCAtPiB0XG4gIHZhbCByZWxlYXNlIDogdCAtPiB1bml0IGZpYmVyXG4gIHZhbCBydW4gOiAodCAtPiAnYSBmaWJlcikgLT4gJ2EgZmliZXJcbiAgdmFsIGNoZWNrIDogdCAtPiB1bml0XG4gIHZhbCBvbl9yZWxlYXNlX2NhbmNlbGxhYmxlIDogdCAtPiAodW5pdCAtPiB1bml0IGZpYmVyKSAtPiBob29rXG4gIHZhbCByZW1vdmVfaG9vayA6IGhvb2sgLT4gdW5pdFxuZW5kXG5cbm1vZHVsZSBNYWtlIChGaWJlciA6IEZJQkVSKSA9IHN0cnVjdFxuICBvcGVuIEZpYmVyLkluZml4XG5cbiAgdHlwZSBzdGF0ZSA9XG4gICAgfCBPbiBvZiAodW5pdCAtPiB1bml0IEZpYmVyLnQpIEx3dF9kbGxpc3QudFxuICAgIHwgT2ZmXG5cbiAgdHlwZSB0ID1cbiAgICB8IEV0ZXJuYWxcbiAgICB8IEVwaGVtZXJhbCBvZiB7bXV0YWJsZSBzdGF0ZTogc3RhdGV9XG5cbiAgdHlwZSBob29rID0gKHVuaXQgLT4gdW5pdCBGaWJlci50KSBMd3RfZGxsaXN0Lm5vZGUgb3B0aW9uXG5cbiAgZXhjZXB0aW9uIE9mZlxuXG4gIGxldCBldGVybmFsID0gRXRlcm5hbFxuICBsZXQgY3JlYXRlICgpID0gRXBoZW1lcmFsIHtzdGF0ZSA9IE9uIChMd3RfZGxsaXN0LmNyZWF0ZSAoKSl9XG5cbiAgbGV0IHJlbGVhc2UgPSBmdW5jdGlvblxuICAgfCBFdGVybmFsIC0+IGZhaWx3aXRoIFwiVHJpZWQgdG8gcmVsZWFzZSBldGVybmFsIHN3aXRjaC5cIlxuICAgfCBFcGhlbWVyYWwge3N0YXRlID0gT2ZmfSAtPiBGaWJlci5yZXR1cm4gKClcbiAgIHwgRXBoZW1lcmFsICh7c3RhdGUgPSBPbiB0YXNrc30gYXMgYXJnKSAtPlxuICAgICAgbGV0IHJlYyBsb29wICgpID1cbiAgICAgICAgaWYgTHd0X2RsbGlzdC5pc19lbXB0eSB0YXNrcyB0aGVuIEZpYmVyLnJldHVybiAoYXJnLnN0YXRlIDwtIE9mZikgZWxzZVxuICAgICAgICBMd3RfZGxsaXN0LnRha2VfbCB0YXNrcyAoKSA+Pj0gbG9vcFxuICAgICAgaW5cbiAgICAgIGxvb3AgKClcblxuICBsZXQgcnVuIGYgPVxuICAgIGxldCBzdyA9IGNyZWF0ZSAoKSBpblxuICAgIEZpYmVyLmZpbmFsbHkgKGZ1biAoKSAtPiBmIHN3KSAoZnVuICgpIC0+IHJlbGVhc2Ugc3cpXG5cbiAgbGV0IGNoZWNrID0gZnVuY3Rpb25cbiAgIHwgRXBoZW1lcmFsIHtzdGF0ZSA9IE9uIF99IHwgRXRlcm5hbCAtPiAoKVxuICAgfCBFcGhlbWVyYWwge3N0YXRlID0gT2ZmfSAtPiByYWlzZSBPZmZcblxuICBsZXQgb25fcmVsZWFzZV9jYW5jZWxsYWJsZSBzdyBmID1cbiAgICAobWF0Y2ggc3cgd2l0aFxuICAgICB8IEV0ZXJuYWwgLT4gTm9uZVxuICAgICB8IEVwaGVtZXJhbCB7c3RhdGUgPSBPbiB0YXNrc30gLT4gU29tZSAoTHd0X2RsbGlzdC5hZGRfbCBmIHRhc2tzKVxuICAgICB8IEVwaGVtZXJhbCB7c3RhdGUgPSBPZmZ9IC0+IHJhaXNlIE9mZilcblxuICBsZXQgcmVtb3ZlX2hvb2sgaG9vayA9IE9wdGlvbi5pdGVyIEx3dF9kbGxpc3QucmVtb3ZlIGhvb2tcbmVuZFxuIiwiKCogQ29weXJpZ2h0IChDKSAyMDE4LS0yMDE5ICBQZXR0ZXIgQS4gVXJrZWRhbCA8cGF1cmtlZGFsQGdtYWlsLmNvbT5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91clxuICogb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbiwgd2l0aCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbmQgdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LiAgSWYgbm90LCBzZWVcbiAqIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPiBhbmQgPGh0dHBzOi8vc3BkeC5vcmc+LCByZXNwZWN0aXZlbHkuXG4gKilcblxub3BlbiBDYXF0aV9zdHJlYW1fc2lnXG5cbm1vZHVsZSB0eXBlIEZJQkVSID0gc2lnXG4gIHR5cGUgKydhIHRcblxuICBtb2R1bGUgSW5maXggOiBzaWdcbiAgICB2YWwgKD4+PSkgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG4gICAgdmFsICg+fD0pIDogJ2EgdCAtPiAoJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgZW5kXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcbmVuZFxuXG5tb2R1bGUgTWFrZShGaWJlciA6IEZJQkVSKSA6IFMgd2l0aCB0eXBlICdhIGZpYmVyIDo9ICdhIEZpYmVyLnQgPSBzdHJ1Y3RcbiAgb3BlbiBGaWJlci5JbmZpeFxuXG4gIGxldCAoPj49PykgcmVzX2Z1dHVyZSBmID1cbiAgICByZXNfZnV0dXJlID4+PSBmdW5jdGlvblxuICAgIHwgT2sgYSAtPiBmIGFcbiAgICB8IEVycm9yIF8gYXMgciAtPiBGaWJlci5yZXR1cm4gclxuXG4gIGxldCAoPnw9PykgcmVzX2Z1dHVyZSBmID1cbiAgICByZXNfZnV0dXJlID4+PSBmdW5jdGlvblxuICAgIHwgT2sgYSAtPiBGaWJlci5yZXR1cm4gQEAgT2sgKGYgYSlcbiAgICB8IEVycm9yIF8gYXMgciAtPiBGaWJlci5yZXR1cm4gclxuXG4gIHR5cGUgKCdhLCAnZXJyKSB0ID0gdW5pdCAtPiAoJ2EsICdlcnIpIG5vZGUgRmliZXIudFxuICBhbmQgKCdhLCAnZXJyKSBub2RlID1cbiAgICB8IE5pbFxuICAgIHwgRXJyb3Igb2YgJ2VyclxuICAgIHwgQ29ucyBvZiAnYSAqICgnYSwgJ2VycikgdFxuXG4gIGxldCByZWMgZm9sZCB+ZiB0IHN0YXRlID1cbiAgICB0ICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEZpYmVyLnJldHVybiAoT2sgc3RhdGUpXG4gICAgfCBFcnJvciBlcnIgLT4gRmliZXIucmV0dXJuIChFcnJvciBlcnIgOiAoJ2EsICdlcnIpIHJlc3VsdClcbiAgICB8IENvbnMgKGEsIHQnKSAtPiBmb2xkIH5mIHQnIChmIGEgc3RhdGUpXG5cbiAgbGV0IHJlYyBmb2xkX3MgfmYgdCBzdGF0ZSA9XG4gICAgdCAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBGaWJlci5yZXR1cm4gKE9rIHN0YXRlKVxuICAgIHwgRXJyb3IgZXJyIC0+IEZpYmVyLnJldHVybiAoRXJyb3IgKGBDb25nZXN0ZWQgZXJyKSA6ICgnYSwgJ2VycikgcmVzdWx0KVxuICAgIHwgQ29ucyAoYSwgdCcpIC0+IGYgYSBzdGF0ZSA+Pj0/IGZvbGRfcyB+ZiB0J1xuXG4gIGxldCByZWMgaXRlcl9zIH5mIHQgPVxuICAgIHQgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gRmliZXIucmV0dXJuIChPayAoKSlcbiAgICB8IEVycm9yIGVyciAtPiBGaWJlci5yZXR1cm4gKEVycm9yIChgQ29uZ2VzdGVkIGVycikgOiAoJ2EsICdlcnIpIHJlc3VsdClcbiAgICB8IENvbnMgKGEsIHQnKSAtPiBmIGEgPj49PyBmdW4gKCkgLT4gaXRlcl9zIH5mIHQnXG5cbiAgbGV0IHRvX3Jldl9saXN0IHQgPSBmb2xkIH5mOkxpc3QuY29ucyB0IFtdXG5cbiAgbGV0IHRvX2xpc3QgdCA9IHRvX3Jldl9saXN0IHQgPnw9PyBMaXN0LnJldlxuXG4gIGxldCByZWMgb2ZfbGlzdCBsID1cbiAgICBmdW4gKCkgLT4gbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBGaWJlci5yZXR1cm4gTmlsXG4gICAgfCBoZDo6dGwgLT4gRmliZXIucmV0dXJuIChDb25zIChoZCwgKG9mX2xpc3QgdGwpKSlcblxuICBsZXQgcmVjIG1hcF9yZXN1bHQgfmYgeHMgKCkgPVxuICAgIHhzICgpID58PSBmdW5jdGlvblxuICAgICB8IENvbnMgKHgsIHhzJykgLT5cbiAgICAgICAgKG1hdGNoIGYgeCB3aXRoXG4gICAgICAgICB8IFJlc3VsdC5PayB5IC0+IENvbnMgKHksIG1hcF9yZXN1bHQgfmYgeHMnKVxuICAgICAgICAgfCBSZXN1bHQuRXJyb3IgZSAtPiBFcnJvciBlKVxuICAgICB8IE5pbCB8IEVycm9yIF8gYXMgciAtPiByXG5lbmRcbiIsIigqIENvcHlyaWdodCAoQykgMjAxOS0tMjAyMiAgUGV0dGVyIEEuIFVya2VkYWwgPHBhdXJrZWRhbEBnbWFpbC5jb20+XG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXJcbiAqIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24sIHdpdGggdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYW5kIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbiBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeS4gIElmIG5vdCwgc2VlXG4gKiA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4gYW5kIDxodHRwczovL3NwZHgub3JnPiwgcmVzcGVjdGl2ZWx5LlxuICopXG5cbmxldCByZWMgZm9sZCBmID0gZnVuY3Rpb25cbiB8IFtdIC0+IEZ1bi5pZFxuIHwgeCA6OiB4cyAtPiBmdW4gYWNjIC0+IGFjYyB8PiBmIHggfD4gZm9sZCBmIHhzXG5cbmxldCBpdGVyaV9yIGYgeHMgPVxuICBsZXQgcmVjIGxvb3AgaSA9IGZ1bmN0aW9uXG4gICB8IFtdIC0+IE9rICgpXG4gICB8IHggOjogeHMgLT5cbiAgICAgIChtYXRjaCBmIGkgeCB3aXRoIE9rICgpIC0+IGxvb3AgKGkgKyAxKSB4cyB8IEVycm9yIF8gYXMgciAtPiByKVxuICBpblxuICBsb29wIDAgeHNcbiIsIigqIENvcHlyaWdodCAoQykgMjAxNy0tMjAyMyAgUGV0dGVyIEEuIFVya2VkYWwgPHBhdXJrZWRhbEBnbWFpbC5jb20+XG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXJcbiAqIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24sIHdpdGggdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYW5kIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbiBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeS4gIElmIG5vdCwgc2VlXG4gKiA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4gYW5kIDxodHRwczovL3NwZHgub3JnPiwgcmVzcGVjdGl2ZWx5LlxuICopXG5cbmxldCAoJT4pIGYgZyB4ID0gZyAoZiB4KVxuXG5sZXQgbm9fZW52IF8gPSByYWlzZSBOb3RfZm91bmRcblxudHlwZSBsaW5lYXJfcGFyYW0gPVxuICBMaW5lYXJfcGFyYW0gOiBpbnQgKiAnYSBDYXF0aV90eXBlLkZpZWxkLnQgKiAnYSAtPiBsaW5lYXJfcGFyYW1cblxubGV0IGxpbmVhcl9wYXJhbV9sZW5ndGggPyhlbnYgPSBub19lbnYpIHRlbXBsID1cbiAgbGV0IHRlbXBsID0gQ2FxdGlfcXVlcnkuZXhwYW5kIGVudiB0ZW1wbCBpblxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgfCBDYXF0aV9xdWVyeS5MIF8gLT4gRnVuLmlkXG4gICB8IENhcXRpX3F1ZXJ5LlYgKF8sIF8pIC0+IHN1Y2NcbiAgIHwgQ2FxdGlfcXVlcnkuUSBfIC0+IHN1Y2NcbiAgIHwgQ2FxdGlfcXVlcnkuUCBfIC0+IHN1Y2NcbiAgIHwgQ2FxdGlfcXVlcnkuRSBfIC0+IGFzc2VydCBmYWxzZVxuICAgfCBDYXF0aV9xdWVyeS5TIGZyYWdzIC0+IExpc3RfZXh0LmZvbGQgbG9vcCBmcmFnc1xuICBpblxuICBsb29wIHRlbXBsIDBcblxubGV0IG5vbmxpbmVhcl9wYXJhbV9sZW5ndGggPyhlbnYgPSBub19lbnYpIHRlbXBsID1cbiAgbGV0IHRlbXBsID0gQ2FxdGlfcXVlcnkuZXhwYW5kIGVudiB0ZW1wbCBpblxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgfCBDYXF0aV9xdWVyeS5MIF8gLT4gRnVuLmlkXG4gICB8IENhcXRpX3F1ZXJ5LlYgXyAtPiBGdW4uaWRcbiAgIHwgQ2FxdGlfcXVlcnkuUSBfIC0+IEZ1bi5pZFxuICAgfCBDYXF0aV9xdWVyeS5QIG4gLT4gbWF4IChuICsgMSlcbiAgIHwgQ2FxdGlfcXVlcnkuRSBfIC0+IGFzc2VydCBmYWxzZVxuICAgfCBDYXF0aV9xdWVyeS5TIGZyYWdzIC0+IExpc3RfZXh0LmZvbGQgbG9vcCBmcmFnc1xuICBpblxuICBsb29wIHRlbXBsIDBcblxubGV0IGxpbmVhcl9wYXJhbV9vcmRlciA/KGVudiA9IG5vX2VudikgdGVtcGwgPVxuICBsZXQgdGVtcGwgPSBDYXF0aV9xdWVyeS5leHBhbmQgZW52IHRlbXBsIGluXG4gIGxldCBhID0gQXJyYXkubWFrZSAobm9ubGluZWFyX3BhcmFtX2xlbmd0aCB0ZW1wbCkgW10gaW5cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgIHwgQ2FxdGlfcXVlcnkuTCBfIC0+IEZ1bi5pZFxuICAgfCBDYXF0aV9xdWVyeS5WICh0LCB2KSAtPlxuICAgICAgZnVuIChqLCBwYXJhbXMpIC0+XG4gICAgICAgIChqICsgMSwgTGluZWFyX3BhcmFtIChqLCB0LCB2KSA6OiBwYXJhbXMpXG4gICB8IENhcXRpX3F1ZXJ5LlEgcyAtPlxuICAgICAgZnVuIChqLCBwYXJhbXMpIC0+XG4gICAgICAgIChqICsgMSwgTGluZWFyX3BhcmFtIChqLCBDYXF0aV90eXBlLkZpZWxkLlN0cmluZywgcykgOjogcGFyYW1zKVxuICAgfCBDYXF0aV9xdWVyeS5QIGkgLT4gZnVuIChqLCBwYXJhbXMpIC0+IGEuKGkpIDwtIGogOjogYS4oaSk7IChqICsgMSwgcGFyYW1zKVxuICAgfCBDYXF0aV9xdWVyeS5FIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICB8IENhcXRpX3F1ZXJ5LlMgZnJhZ3MgLT4gTGlzdF9leHQuZm9sZCBsb29wIGZyYWdzXG4gIGluXG4gIGxldCBfLCBwYXJhbXMgPSBsb29wIHRlbXBsICgwLCBbXSkgaW5cbiAgKEFycmF5LnRvX2xpc3QgYSwgTGlzdC5yZXYgcGFyYW1zKVxuXG5sZXQgbGluZWFyX3F1ZXJ5X3N0cmluZyA/KGVudiA9IG5vX2VudikgdGVtcGwgPVxuICBsZXQgdGVtcGwgPSBDYXF0aV9xdWVyeS5leHBhbmQgZW52IHRlbXBsIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDY0IGluXG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICB8IENhcXRpX3F1ZXJ5LkwgcyAtPiBCdWZmZXIuYWRkX3N0cmluZyBidWYgc1xuICAgfCBDYXF0aV9xdWVyeS5RIF8gfCBDYXF0aV9xdWVyeS5WIF8gfCBDYXF0aV9xdWVyeS5QIF8gLT5cbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJz8nXG4gICB8IENhcXRpX3F1ZXJ5LkUgXyAtPiBhc3NlcnQgZmFsc2VcbiAgIHwgQ2FxdGlfcXVlcnkuUyBmcmFncyAtPiBMaXN0Lml0ZXIgbG9vcCBmcmFnc1xuICBpblxuICBsb29wIHRlbXBsO1xuICBCdWZmZXIuY29udGVudHMgYnVmXG5cbmxldCByYWlzZV9lbmNvZGVfbWlzc2luZyB+dXJpIH5maWVsZF90eXBlICgpID1cbiAgcmFpc2UgKENhcXRpX2Vycm9yLkV4biAoQ2FxdGlfZXJyb3IuZW5jb2RlX21pc3NpbmcgfnVyaSB+ZmllbGRfdHlwZSAoKSkpXG5sZXQgcmFpc2VfZW5jb2RlX3JlamVjdGVkIH51cmkgfnR5cCBtc2cgPVxuICByYWlzZSAoQ2FxdGlfZXJyb3IuRXhuIChDYXF0aV9lcnJvci5lbmNvZGVfcmVqZWN0ZWQgfnVyaSB+dHlwIG1zZykpXG5sZXQgcmFpc2VfZW5jb2RlX2ZhaWxlZCB+dXJpIH50eXAgbXNnID1cbiAgcmFpc2UgKENhcXRpX2Vycm9yLkV4biAoQ2FxdGlfZXJyb3IuZW5jb2RlX2ZhaWxlZCB+dXJpIH50eXAgbXNnKSlcbmxldCByYWlzZV9kZWNvZGVfbWlzc2luZyB+dXJpIH5maWVsZF90eXBlICgpID1cbiAgcmFpc2UgKENhcXRpX2Vycm9yLkV4biAoQ2FxdGlfZXJyb3IuZGVjb2RlX21pc3NpbmcgfnVyaSB+ZmllbGRfdHlwZSAoKSkpXG5sZXQgcmFpc2VfZGVjb2RlX3JlamVjdGVkIH51cmkgfnR5cCBtc2cgPVxuICByYWlzZSAoQ2FxdGlfZXJyb3IuRXhuIChDYXF0aV9lcnJvci5kZWNvZGVfcmVqZWN0ZWQgfnVyaSB+dHlwIG1zZykpXG5sZXQgcmFpc2VfcmVzcG9uc2VfZmFpbGVkIH51cmkgfnF1ZXJ5IG1zZyA9XG4gIHJhaXNlIChDYXF0aV9lcnJvci5FeG4gKENhcXRpX2Vycm9yLnJlc3BvbnNlX2ZhaWxlZCB+dXJpIH5xdWVyeSBtc2cpKVxubGV0IHJhaXNlX3Jlc3BvbnNlX3JlamVjdGVkIH51cmkgfnF1ZXJ5IG1zZyA9XG4gIHJhaXNlIChDYXF0aV9lcnJvci5FeG4gKENhcXRpX2Vycm9yLnJlc3BvbnNlX3JlamVjdGVkIH51cmkgfnF1ZXJ5IG1zZykpXG5cbnR5cGUgJ2EgZmllbGRfZW5jb2RlciA9IHtcbiAgd3JpdGVfdmFsdWU6ICdiLiB1cmk6IFVyaS50IC0+ICdiIENhcXRpX3R5cGUuRmllbGQudCAtPiAnYiAtPiAnYSAtPiAnYTtcbiAgd3JpdGVfbnVsbDogJ2IuIHVyaTogVXJpLnQgLT4gJ2IgQ2FxdGlfdHlwZS5GaWVsZC50IC0+ICdhIC0+ICdhO1xufVxuY29uc3RyYWludCAnZSA9IFs+IGBFbmNvZGVfcmVqZWN0ZWQgb2YgQ2FxdGlfZXJyb3IuY29kaW5nX2Vycm9yXVxuXG5sZXQgcmVjIGVuY29kZV9udWxsX3BhcmFtIDogdHlwZSBhLiB1cmk6IF8gLT4gXyAtPiBhIENhcXRpX3R5cGUudCAtPiBfID1cbiAgZnVuIH51cmkgZiAtPlxuICBsZXQgb3BlbiBDYXF0aV90eXBlIGluXG4gIChmdW5jdGlvblxuICAgfCBGaWVsZCBmdCAtPiBmLndyaXRlX251bGwgfnVyaSBmdFxuICAgfCBPcHRpb24gdCAtPiBlbmNvZGVfbnVsbF9wYXJhbSB+dXJpIGYgdFxuICAgfCBQcm9kdWN0IChfLCBfLCB0cykgLT5cbiAgICAgIGxldCByZWMgbG9vcCA6IHR5cGUgYSBpLiAoYSwgaSkgcHJvZHVjdCAtPiBfID0gZnVuY3Rpb25cbiAgICAgICB8IFByb2pfZW5kIC0+IEZ1bi5pZFxuICAgICAgIHwgUHJvaiAodCwgXywgdHMpIC0+IGVuY29kZV9udWxsX3BhcmFtIH51cmkgZiB0ICU+IGxvb3AgdHNcbiAgICAgIGluXG4gICAgICBsb29wIHRzXG4gICB8IEFubm90IChfLCB0KSAtPiBlbmNvZGVfbnVsbF9wYXJhbSB+dXJpIGYgdClcblxubGV0IHJlamVjdF9lbmNvZGUgfnVyaSB+dHlwIG1zZyA9XG4gIGxldCBtc2cgPSBDYXF0aV9lcnJvci5Nc2cgbXNnIGluXG4gIHJhaXNlX2VuY29kZV9yZWplY3RlZCB+dXJpIH50eXAgbXNnXG5cbmxldCByZWMgZW5jb2RlX3BhcmFtXG4gICAgOiB0eXBlIGEuIHVyaTogXyAtPiBfIC0+IGEgQ2FxdGlfdHlwZS50IC0+IGEgLT4gJ2IgLT4gJ2IgPVxuICBmdW4gfnVyaSBmIC0+XG4gIGxldCBvcGVuIENhcXRpX3R5cGUgaW5cbiAgKGZ1bmN0aW9uXG4gICB8IEZpZWxkIGZ0IC0+IGYud3JpdGVfdmFsdWUgfnVyaSBmdFxuICAgfCBPcHRpb24gdCAtPlxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgfCBOb25lIC0+IGVuY29kZV9udWxsX3BhcmFtIH51cmkgZiB0XG4gICAgICAgfCBTb21lIHggLT4gZW5jb2RlX3BhcmFtIH51cmkgZiB0IHgpXG4gICB8IFByb2R1Y3QgKF8sIF8sIHRzKSBhcyB0eXAgLT5cbiAgICAgIGxldCByZWMgbG9vcCA6IHR5cGUgaS4gKGEsIGkpIHByb2R1Y3QgLT4gXyA9IGZ1bmN0aW9uXG4gICAgICAgfCBQcm9qX2VuZCAtPiBmdW4gXyBhY2MgLT4gYWNjXG4gICAgICAgfCBQcm9qICh0LCBwLCB0cykgLT5cbiAgICAgICAgICBsZXQgZW5jb2RlX3QgPSBlbmNvZGVfcGFyYW0gfnVyaSBmIHQgaW5cbiAgICAgICAgICBsZXQgZW5jb2RlX3RzID0gbG9vcCB0cyBpblxuICAgICAgICAgIGZ1biB4IGFjYyAtPiBlbmNvZGVfdCAocCB4KSBhY2MgfD4gZW5jb2RlX3RzIHhcbiAgICAgIGluXG4gICAgICAodHJ5IGxvb3AgdHMgd2l0aFxuICAgICAgIHwgQ2FxdGlfdHlwZS5SZWplY3QgbXNnIC0+IHJlamVjdF9lbmNvZGUgfnVyaSB+dHlwIG1zZylcbiAgIHwgQW5ub3QgKF8sIHQpIC0+IGVuY29kZV9wYXJhbSB+dXJpIGYgdClcblxudHlwZSAnYSBmaWVsZF9kZWNvZGVyID0ge1xuICByZWFkX3ZhbHVlOiAnYi4gdXJpOiBVcmkudCAtPiAnYiBDYXF0aV90eXBlLkZpZWxkLnQgLT4gJ2EgLT4gJ2IgKiAnYTtcbiAgc2tpcF9udWxsOiBpbnQgLT4gJ2EgLT4gJ2Egb3B0aW9uO1xufVxuY29uc3RyYWludCAnZSA9IFs+IGBEZWNvZGVfcmVqZWN0ZWQgb2YgQ2FxdGlfZXJyb3IuY29kaW5nX2Vycm9yXVxuXG5sZXQgcmVqZWN0X2RlY29kZSB+dXJpIH50eXAgbXNnID1cbiAgbGV0IG1zZyA9IENhcXRpX2Vycm9yLk1zZyBtc2cgaW5cbiAgcmFpc2VfZGVjb2RlX3JlamVjdGVkIH51cmkgfnR5cCBtc2dcblxubGV0IHJlYyBkZWNvZGVfcm93XG4gICAgOiB0eXBlIGEuIHVyaTogXyAtPiBfIC0+IGEgQ2FxdGlfdHlwZS50IC0+IF8gLT4gYSAqIF8gPVxuICBmdW4gfnVyaSBmIC0+XG4gIGxldCBvcGVuIENhcXRpX3R5cGUgaW5cbiAgKGZ1bmN0aW9uXG4gICB8IEZpZWxkIGZ0IC0+XG4gICAgICBmLnJlYWRfdmFsdWUgfnVyaSBmdFxuICAgfCBPcHRpb24gdCAtPlxuICAgICAgbGV0IGRlY29kZV90ID0gZGVjb2RlX3JvdyB+dXJpIGYgdCBpblxuICAgICAgZnVuIGFjYyAtPlxuICAgICAgICAobWF0Y2ggZi5za2lwX251bGwgKENhcXRpX3R5cGUubGVuZ3RoIHQpIGFjYyB3aXRoXG4gICAgICAgICB8IFNvbWUgYWNjIC0+IChOb25lLCBhY2MpXG4gICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgIGxldCB4LCBhY2MgPSBkZWNvZGVfdCBhY2MgaW5cbiAgICAgICAgICAgIChTb21lIHgsIGFjYykpXG4gICB8IFByb2R1Y3QgKF8sIGludHJvLCBQcm9qX2VuZCkgLT5cbiAgICAgIGZ1biBhY2MgLT4gKGludHJvLCBhY2MpXG4gICB8IFByb2R1Y3QgKF8sIGludHJvLCBQcm9qICh0MSwgXywgUHJvaiAodDIsIF8sIFByb2pfZW5kKSkpXG4gICAgICAgIGFzIHR5cCAtPiAoKiBvcHRpbWl6YXRpb24gKilcbiAgICAgIGxldCBkZWNvZGVfdDEgPSBkZWNvZGVfcm93IH51cmkgZiB0MSBpblxuICAgICAgbGV0IGRlY29kZV90MiA9IGRlY29kZV9yb3cgfnVyaSBmIHQyIGluXG4gICAgICBmdW4gYWNjIC0+XG4gICAgICAgIGxldCB4MSwgYWNjID0gZGVjb2RlX3QxIGFjYyBpblxuICAgICAgICBsZXQgeDIsIGFjYyA9IGRlY29kZV90MiBhY2MgaW5cbiAgICAgICAgKHRyeSAoaW50cm8geDEgeDIsIGFjYykgd2l0aFxuICAgICAgICAgfCBDYXF0aV90eXBlLlJlamVjdCBtc2cgLT4gcmVqZWN0X2RlY29kZSB+dXJpIH50eXAgbXNnKVxuICAgfCBQcm9kdWN0IChfLCBpbnRybywgUHJvaiAodDEsIF8sIFByb2ogKHQyLCBfLCBQcm9qICh0MywgXywgUHJval9lbmQpKSkpXG4gICAgICAgIGFzIHR5cCAtPiAoKiBvcHRpbWl6YXRpb24gKilcbiAgICAgIGxldCBkZWNvZGVfdDEgPSBkZWNvZGVfcm93IH51cmkgZiB0MSBpblxuICAgICAgbGV0IGRlY29kZV90MiA9IGRlY29kZV9yb3cgfnVyaSBmIHQyIGluXG4gICAgICBsZXQgZGVjb2RlX3QzID0gZGVjb2RlX3JvdyB+dXJpIGYgdDMgaW5cbiAgICAgIGZ1biBhY2MgLT5cbiAgICAgICAgbGV0IHgxLCBhY2MgPSBkZWNvZGVfdDEgYWNjIGluXG4gICAgICAgIGxldCB4MiwgYWNjID0gZGVjb2RlX3QyIGFjYyBpblxuICAgICAgICBsZXQgeDMsIGFjYyA9IGRlY29kZV90MyBhY2MgaW5cbiAgICAgICAgKHRyeSAoaW50cm8geDEgeDIgeDMsIGFjYykgd2l0aFxuICAgICAgICAgfCBDYXF0aV90eXBlLlJlamVjdCBtc2cgLT4gcmVqZWN0X2RlY29kZSB+dXJpIH50eXAgbXNnKVxuICAgfCBQcm9kdWN0IChfLCBpbnRybyxcbiAgICAgICAgUHJvaiAodDEsIF8sIFByb2ogKHQyLCBfLCBQcm9qICh0MywgXywgUHJvaiAodDQsIF8sIFByb2pfZW5kKSkpKSlcbiAgICAgICAgYXMgdHlwIC0+ICgqIG9wdGltaXphdGlvbiAqKVxuICAgICAgbGV0IGRlY29kZV90MSA9IGRlY29kZV9yb3cgfnVyaSBmIHQxIGluXG4gICAgICBsZXQgZGVjb2RlX3QyID0gZGVjb2RlX3JvdyB+dXJpIGYgdDIgaW5cbiAgICAgIGxldCBkZWNvZGVfdDMgPSBkZWNvZGVfcm93IH51cmkgZiB0MyBpblxuICAgICAgbGV0IGRlY29kZV90NCA9IGRlY29kZV9yb3cgfnVyaSBmIHQ0IGluXG4gICAgICBmdW4gYWNjIC0+XG4gICAgICAgIGxldCB4MSwgYWNjID0gZGVjb2RlX3QxIGFjYyBpblxuICAgICAgICBsZXQgeDIsIGFjYyA9IGRlY29kZV90MiBhY2MgaW5cbiAgICAgICAgbGV0IHgzLCBhY2MgPSBkZWNvZGVfdDMgYWNjIGluXG4gICAgICAgIGxldCB4NCwgYWNjID0gZGVjb2RlX3Q0IGFjYyBpblxuICAgICAgICAodHJ5IChpbnRybyB4MSB4MiB4MyB4NCwgYWNjKSB3aXRoXG4gICAgICAgICB8IENhcXRpX3R5cGUuUmVqZWN0IG1zZyAtPiByZWplY3RfZGVjb2RlIH51cmkgfnR5cCBtc2cpXG4gICB8IFByb2R1Y3QgKF8sIGludHJvLCB0cykgYXMgdHlwIC0+XG4gICAgICBsZXQgcmVjIGxvb3AgOiB0eXBlIGEgaS4gKGEsIGkpIHByb2R1Y3QgLT4gaSAtPiBfIC0+IGEgKiBfID1cbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICB8IFByb2pfZW5kIC0+XG4gICAgICAgICAgICBmdW4gaW50cm8gYWNjIC0+IChpbnRybywgYWNjKVxuICAgICAgICAgfCBQcm9qICh0LCBfLCB0cykgLT5cbiAgICAgICAgICAgIGxldCBkZWNvZGVfdCA9IGRlY29kZV9yb3cgfnVyaSBmIHQgaW5cbiAgICAgICAgICAgIGxldCBkZWNvZGVfdHMgPSBsb29wIHRzIGluXG4gICAgICAgICAgICBmdW4gaW50cm8gYWNjIC0+XG4gICAgICAgICAgICAgIGxldCB4LCBhY2MgPSBkZWNvZGVfdCBhY2MgaW5cbiAgICAgICAgICAgICAgZGVjb2RlX3RzIChpbnRybyB4KSBhY2MpXG4gICAgICBpblxuICAgICAgKHRyeSBsb29wIHRzIGludHJvIHdpdGhcbiAgICAgICB8IENhcXRpX3R5cGUuUmVqZWN0IG1zZyAtPiByZWplY3RfZGVjb2RlIH51cmkgfnR5cCBtc2cpXG4gICB8IEFubm90IChfLCB0MCkgLT5cbiAgICAgIGRlY29kZV9yb3cgfnVyaSBmIHQwKVxuIiwiKCogQ29weXJpZ2h0IChDKSAyMDE0LS0yMDE2ICBQZXR0ZXIgQS4gVXJrZWRhbCA8cGF1cmtlZGFsQGdtYWlsLmNvbT5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91clxuICogb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbiwgd2l0aCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbmQgdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LiAgSWYgbm90LCBzZWVcbiAqIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPiBhbmQgPGh0dHBzOi8vc3BkeC5vcmc+LCByZXNwZWN0aXZlbHkuXG4gKilcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIGVsdFxuICB0eXBlIHRcblxuICB2YWwgZW1wdHkgOiB0XG4gIHZhbCBpc19lbXB0eSA6IHQgLT4gYm9vbFxuICB2YWwgY2FyZCA6IHQgLT4gaW50XG4gIHZhbCBwdXNoIDogZWx0IC0+IHQgLT4gdFxuICB2YWwgbWVyZ2UgOiB0IC0+IHQgLT4gdFxuICB2YWwgcG9wX2UgOiB0IC0+IGVsdCAqIHRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoRWx0IDogU2V0Lk9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuXG4gIHR5cGUgZWx0ID0gRWx0LnRcbiAgdHlwZSB0ID0gTyB8IFkgb2YgaW50ICogZWx0ICogdCAqIHRcblxuICBsZXQgZW1wdHkgPSBPXG5cbiAgbGV0IGlzX2VtcHR5IGggPSBoID0gT1xuXG4gIGxldCBjYXJkID0gZnVuY3Rpb25cbiAgICB8IE8gLT4gMFxuICAgIHwgWSAobiwgXywgXywgXykgLT4gblxuXG4gIGxldCByZWMgcHVzaCBlJyA9IGZ1bmN0aW9uXG4gICAgfCBPIC0+IFkgKDEsIGUnLCBPLCBPKVxuICAgIHwgWSAobiwgZSwgaEwsIGhSKSAtPlxuICAgICAgbGV0IGVfbWluLCBlX21heCA9IGlmIEVsdC5jb21wYXJlIGUnIGUgPCAwIHRoZW4gZScsIGUgZWxzZSBlLCBlJyBpblxuICAgICAgaWYgY2FyZCBoTCA8IGNhcmQgaFIgdGhlbiBZIChuICsgMSwgZV9taW4sIHB1c2ggZV9tYXggaEwsIGhSKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBZIChuICsgMSwgZV9taW4sIGhMLCBwdXNoIGVfbWF4IGhSKVxuXG4gIGxldCByZWMgbWVyZ2UgaEwgaFIgPVxuICAgIG1hdGNoIGhMLCBoUiB3aXRoXG4gICAgfCBPLCBoIHwgaCwgTyAtPiBoXG4gICAgfCBZIChuTCwgZUwsIGhBLCBoQiksIFkgKG5SLCBlUiwgaEMsIGhEKSAtPlxuICAgICAgaWYgRWx0LmNvbXBhcmUgZUwgZVIgPCAwIHRoZW4gWSAobkwgKyBuUiwgZUwsIG1lcmdlIGhBIGhCLCBoUilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFkgKG5MICsgblIsIGVSLCBoTCwgbWVyZ2UgaEMgaEQpXG5cbiAgbGV0IHBvcF9lID0gZnVuY3Rpb25cbiAgICB8IE8gLT4gaW52YWxpZF9hcmcgXCJDYXF0aV9oZWFwLnBvcF9lOiBFbXB0eSBoZWFwLlwiXG4gICAgfCBZIChfLCBlLCBoTCwgaFIpIC0+IGUsIG1lcmdlIGhMIGhSXG5cbmVuZFxuIiwiKCogQ29weXJpZ2h0IChDKSAyMDE0LS0yMDI0ICBQZXR0ZXIgQS4gVXJrZWRhbCA8cGF1cmtlZGFsQGdtYWlsLmNvbT5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91clxuICogb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbiwgd2l0aCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbmQgdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LiAgSWYgbm90LCBzZWVcbiAqIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPiBhbmQgPGh0dHBzOi8vc3BkeC5vcmc+LCByZXNwZWN0aXZlbHkuXG4gKilcblxubW9kdWxlIENvbmZpZyA9IENhcXRpX3Bvb2xfY29uZmlnXG5cbmxldCBkZWZhdWx0X21heF9zaXplID1cbiAgdHJ5IGludF9vZl9zdHJpbmcgKFN5cy5nZXRlbnYgXCJDQVFUSV9QT09MX01BWF9TSVpFXCIpIHdpdGggTm90X2ZvdW5kIC0+IDhcblxubGV0IGRlZmF1bHRfbG9nX3NyYyA9IExvZ3MuU3JjLmNyZWF0ZSBcIkNhcXRpX3BsYXRmb3JtLlBvb2xcIlxuXG5tb2R1bGUgdHlwZSBBTEFSTSA9IHNpZ1xuICB0eXBlIHN3aXRjaFxuICB0eXBlIHN0ZGVudlxuXG4gIHR5cGUgdFxuXG4gIHZhbCBzY2hlZHVsZSA6XG4gICAgc3c6IHN3aXRjaCAtPlxuICAgIHN0ZGVudjogc3RkZW52IC0+XG4gICAgTXRpbWUudCAtPiAodW5pdCAtPiB1bml0KSAtPiB0XG5cbiAgdmFsIHVuc2NoZWR1bGUgOiB0IC0+IHVuaXRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgc3dpdGNoXG4gIHR5cGUgc3RkZW52XG5cbiAgaW5jbHVkZSBDYXF0aV9wb29sX3NpZy5TXG5cbiAgdmFsIGNyZWF0ZSA6XG4gICAgP2NvbmZpZzogQ2FxdGlfcG9vbF9jb25maWcudCAtPlxuICAgID9jaGVjazogKCdhIC0+IChib29sIC0+IHVuaXQpIC0+IHVuaXQpIC0+XG4gICAgP3ZhbGlkYXRlOiAoJ2EgLT4gYm9vbCBmaWJlcikgLT5cbiAgICA/bG9nX3NyYzogTG9ncy5TcmMudCAtPlxuICAgIHN3OiBzd2l0Y2ggLT5cbiAgICBzdGRlbnY6IHN0ZGVudiAtPlxuICAgICh1bml0IC0+ICgnYSwgJ2UpIHJlc3VsdCBmaWJlcikgLT4gKCdhIC0+IHVuaXQgZmliZXIpIC0+XG4gICAgKCdhLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSBNYWtlXG4gIChTeXN0ZW0gOiBTeXN0ZW1fc2lnLkNPUkUpXG4gIChBbGFybSA6IEFMQVJNXG4gICAgd2l0aCB0eXBlIHN0ZGVudiA6PSBTeXN0ZW0uc3RkZW52XG4gICAgIGFuZCB0eXBlIHN3aXRjaCA6PSBTeXN0ZW0uU3dpdGNoLnQpID1cbnN0cnVjdFxuICBvcGVuIFN5c3RlbVxuICBvcGVuIFN5c3RlbS5GaWJlci5JbmZpeFxuXG4gIGxldCAoPj49PykgbSBmID1cbiAgICBtID4+PSBmdW5jdGlvbiBPayB4IC0+IGYgeCB8IEVycm9yIGUgLT4gRmliZXIucmV0dXJuIChFcnJvciBlKVxuXG4gIG1vZHVsZSBUYXNrID0gc3RydWN0XG4gICAgdHlwZSB0ID0ge3ByaW9yaXR5OiBmbG9hdDsgc2VtYXBob3JlOiBTZW1hcGhvcmUudH1cbiAgICBsZXQgd2FrZSB7c2VtYXBob3JlOyBffSA9IFNlbWFwaG9yZS5yZWxlYXNlIHNlbWFwaG9yZVxuICAgIGxldCBjb21wYXJlIHtwcmlvcml0eSA9IHBBOyBffSB7cHJpb3JpdHkgPSBwQjsgX30gPSBGbG9hdC5jb21wYXJlIHBCIHBBXG4gIGVuZFxuXG4gIG1vZHVsZSBUYXNrcSA9IEhlYXAuTWFrZSAoVGFzaylcblxuICB0eXBlICdhIGVudHJ5ID0ge1xuICAgIHJlc291cmNlOiAnYTtcbiAgICBtdXRhYmxlIHVzZWRfY291bnQ6IGludDtcbiAgICBtdXRhYmxlIHVzZWRfbGF0ZXN0OiBNdGltZS50O1xuICB9XG5cbiAgdHlwZSAoJ2EsICsnZSkgdCA9IHtcbiAgICBzdGRlbnY6IHN0ZGVudjtcbiAgICBzd2l0Y2g6IFN3aXRjaC50O1xuICAgIGNyZWF0ZTogdW5pdCAtPiAoJ2EsICdlKSByZXN1bHQgRmliZXIudDtcbiAgICBmcmVlOiAnYSAtPiB1bml0IEZpYmVyLnQ7XG4gICAgY2hlY2s6ICdhIC0+IChib29sIC0+IHVuaXQpIC0+IHVuaXQ7XG4gICAgdmFsaWRhdGU6ICdhIC0+IGJvb2wgRmliZXIudDtcbiAgICBsb2dfc3JjOiBMb2dzLlNyYy50O1xuICAgIG1heF9pZGxlX3NpemU6IGludDtcbiAgICBtYXhfaWRsZV9hZ2U6IE10aW1lLlNwYW4udCBvcHRpb247XG4gICAgbWF4X3NpemU6IGludDtcbiAgICBtYXhfdXNlX2NvdW50OiBpbnQgb3B0aW9uO1xuICAgIG11dGFibGUgY3VyX3NpemU6IGludDtcbiAgICBxdWV1ZTogJ2EgZW50cnkgUXVldWUudDtcbiAgICBtdXRhYmxlIHdhaXRpbmc6IFRhc2txLnQ7XG4gICAgbXV0YWJsZSBhbGFybTogQWxhcm0udCBvcHRpb247XG4gIH1cblxuKCpcbiAgbGV0IGNvbmZpZ3VyZSBjIHBvb2wgPVxuICAgIE9wdGlvbi5pdGVyIChmdW4geCAtPiBwb29sLm1heF9zaXplIDwtIHgpIENvbmZpZy4oZ2V0IG1heF9zaXplIGMpO1xuICAgIE9wdGlvbi5pdGVyIChmdW4geCAtPiBwb29sLm1heF9pZGxlX3NpemUgPC0geCkgQ29uZmlnLihnZXQgbWF4X2lkbGVfc2l6ZSBjKTtcbiAgICBPcHRpb24uaXRlciAoZnVuIHggLT4gcG9vbC5tYXhfaWRsZV9hZ2UgPC0geCkgQ29uZmlnLihnZXQgbWF4X2lkbGVfYWdlIGMpO1xuICAgIE9wdGlvbi5pdGVyIChmdW4geCAtPiBwb29sLm1heF91c2VfY291bnQgPC0geCkgQ29uZmlnLihnZXQgbWF4X3VzZV9jb3VudCBjKVxuKilcblxuICBsZXQgY3JlYXRlXG4gICAgICAgID8oY29uZmlnID0gQ2FxdGlfcG9vbF9jb25maWcuZGVmYXVsdClcbiAgICAgICAgPyhjaGVjayA9IGZ1biBfIGYgLT4gZiB0cnVlKVxuICAgICAgICA/KHZhbGlkYXRlID0gZnVuIF8gLT4gRmliZXIucmV0dXJuIHRydWUpXG4gICAgICAgID8obG9nX3NyYyA9IGRlZmF1bHRfbG9nX3NyYylcbiAgICAgICAgfnN3XG4gICAgICAgIH5zdGRlbnZcbiAgICAgICAgY3JlYXRlIGZyZWUgPVxuICAgIGxldCBtYXhfc2l6ZSA9XG4gICAgICBDb25maWcuKGdldCBtYXhfc2l6ZSkgY29uZmlnIHw+IE9wdGlvbi52YWx1ZSB+ZGVmYXVsdDpkZWZhdWx0X21heF9zaXplIGluXG4gICAgbGV0IG1heF9pZGxlX3NpemUgPVxuICAgICAgQ29uZmlnLihnZXQgbWF4X2lkbGVfc2l6ZSkgY29uZmlnIHw+IE9wdGlvbi52YWx1ZSB+ZGVmYXVsdDptYXhfc2l6ZSBpblxuICAgIGxldCBtYXhfaWRsZV9hZ2UgPVxuICAgICAgQ29uZmlnLihnZXQgbWF4X2lkbGVfYWdlKSBjb25maWcgfD4gT3B0aW9uLnZhbHVlIH5kZWZhdWx0Ok5vbmUgaW5cbiAgICBsZXQgbWF4X3VzZV9jb3VudCA9XG4gICAgICBDb25maWcuKGdldCBtYXhfdXNlX2NvdW50KSBjb25maWcgfD4gT3B0aW9uLnZhbHVlIH5kZWZhdWx0OihTb21lIDEwMCkgaW5cbiAgICBhc3NlcnQgKG1heF9zaXplID4gMCk7XG4gICAgYXNzZXJ0IChtYXhfc2l6ZSA+PSBtYXhfaWRsZV9zaXplKTtcbiAgICBhc3NlcnQgKE9wdGlvbi5mb2xkIH5ub25lOnRydWUgfnNvbWU6KGZ1biBuIC0+IG4gPiAwKSBtYXhfdXNlX2NvdW50KTtcbiAgICB7XG4gICAgICBzdGRlbnY7IHN3aXRjaCA9IHN3O1xuICAgICAgY3JlYXRlOyBmcmVlOyBjaGVjazsgdmFsaWRhdGU7IGxvZ19zcmM7XG4gICAgICBtYXhfaWRsZV9zaXplOyBtYXhfc2l6ZTsgbWF4X3VzZV9jb3VudDsgbWF4X2lkbGVfYWdlO1xuICAgICAgY3VyX3NpemUgPSAwO1xuICAgICAgcXVldWUgPSBRdWV1ZS5jcmVhdGUgKCk7XG4gICAgICB3YWl0aW5nID0gVGFza3EuZW1wdHk7XG4gICAgICBhbGFybSA9IE5vbmU7XG4gICAgfVxuXG4gIGxldCBzaXplIHtjdXJfc2l6ZTsgX30gPSBjdXJfc2l6ZVxuXG4gIGxldCB3YWl0IH5wcmlvcml0eSBwb29sID1cbiAgICBsZXQgc2VtYXBob3JlID0gU2VtYXBob3JlLmNyZWF0ZSAoKSBpblxuICAgIHBvb2wud2FpdGluZyA8LSBUYXNrcS5wdXNoIFRhc2suKHtwcmlvcml0eTsgc2VtYXBob3JlfSkgcG9vbC53YWl0aW5nO1xuICAgIFNlbWFwaG9yZS5hY3F1aXJlIHNlbWFwaG9yZVxuXG4gIGxldCBzY2hlZHVsZSBwb29sID1cbiAgICBpZiBub3QgKFRhc2txLmlzX2VtcHR5IHBvb2wud2FpdGluZykgdGhlbiBiZWdpblxuICAgICAgbGV0IHRhc2ssIHRhc2txID0gVGFza3EucG9wX2UgcG9vbC53YWl0aW5nIGluXG4gICAgICBwb29sLndhaXRpbmcgPC0gdGFza3E7XG4gICAgICBUYXNrLndha2UgdGFza1xuICAgIGVuZFxuXG4gIGxldCByZWFsbG9jIHBvb2wgPVxuICAgIGxldCBvbl9lcnJvciAoKSA9XG4gICAgICBwb29sLmN1cl9zaXplIDwtIHBvb2wuY3VyX3NpemUgLSAxO1xuICAgICAgc2NoZWR1bGUgcG9vbFxuICAgIGluXG4gICAgRmliZXIuY2xlYW51cFxuICAgICAgKGZ1biAoKSAtPlxuICAgICAgICBwb29sLmNyZWF0ZSAoKSA+fD1cbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICB8IE9rIHJlc291cmNlIC0+XG4gICAgICAgICAgICBPayB7cmVzb3VyY2U7IHVzZWRfY291bnQgPSAwOyB1c2VkX2xhdGVzdCA9IE10aW1lX2Nsb2NrLm5vdyAoKX1cbiAgICAgICAgIHwgRXJyb3IgZXJyIC0+IG9uX2Vycm9yICgpOyBFcnJvciBlcnIpKVxuICAgICAgKGZ1biAoKSAtPiBvbl9lcnJvciAoKTsgRmliZXIucmV0dXJuICgpKVxuXG4gIGxldCByZWMgYWNxdWlyZSB+cHJpb3JpdHkgcG9vbCA9XG4gICAgaWYgUXVldWUuaXNfZW1wdHkgcG9vbC5xdWV1ZSB0aGVuIGJlZ2luXG4gICAgICBpZiBwb29sLmN1cl9zaXplIDwgcG9vbC5tYXhfc2l6ZSB0aGVuXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgcG9vbC5jdXJfc2l6ZSA8LSBwb29sLmN1cl9zaXplICsgMTtcbiAgICAgICAgICByZWFsbG9jIHBvb2xcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIHdhaXQgfnByaW9yaXR5IHBvb2wgPj49IGZ1biAoKSAtPlxuICAgICAgICBhY3F1aXJlIH5wcmlvcml0eSBwb29sXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIGxldCBlbnRyeSA9IFF1ZXVlLnRha2UgcG9vbC5xdWV1ZSBpblxuICAgICAgcG9vbC52YWxpZGF0ZSBlbnRyeS5yZXNvdXJjZSA+Pj0gZnVuIG9rIC0+XG4gICAgICBpZiBvayB0aGVuXG4gICAgICAgIEZpYmVyLnJldHVybiAoT2sgZW50cnkpXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIExvZy53YXJuIH5zcmM6cG9vbC5sb2dfc3JjIChmdW4gZiAtPlxuICAgICAgICAgIGYgXCJEcm9wcGVkIHBvb2xlZCBjb25uZWN0aW9uIGR1ZSB0byBpbnZhbGlkYXRpb24uXCIpID4+PSBmdW4gKCkgLT5cbiAgICAgICAgcmVhbGxvYyBwb29sXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBsZXQgY2FuX3JldXNlIHBvb2wgZW50cnkgPVxuICAgIHBvb2wuY3VyX3NpemUgPD0gcG9vbC5tYXhfaWRsZV9zaXplXG4gICAgICYmIE9wdGlvbi5mb2xkIH5ub25lOnRydWUgfnNvbWU6KGZ1biBuIC0+IGVudHJ5LnVzZWRfY291bnQgPCBuKVxuICAgICAgICAgIHBvb2wubWF4X3VzZV9jb3VudFxuXG4gIGxldCByZWMgZGlzcG9zZV9leHBpcmluZyBwb29sID1cbiAgICAobWF0Y2ggcG9vbC5tYXhfaWRsZV9hZ2UsIHBvb2wuYWxhcm0gd2l0aFxuICAgICB8IE5vbmUsIE5vbmUgLT4gKClcbiAgICAgfCBTb21lIF8sIFNvbWUgXyAtPiAoKVxuICAgICB8IE5vbmUsIFNvbWUgYWxhcm0gLT5cbiAgICAgICAgQWxhcm0udW5zY2hlZHVsZSBhbGFybTtcbiAgICAgICAgcG9vbC5hbGFybSA8LSBOb25lXG4gICAgIHwgU29tZSBtYXhfaWRsZV9hZ2UsIE5vbmUgLT5cbiAgICAgICAgbGV0IG5vdyA9IE10aW1lX2Nsb2NrLm5vdyAoKSBpblxuICAgICAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgICAgIChtYXRjaCBRdWV1ZS5wZWVrX29wdCBwb29sLnF1ZXVlIHdpdGhcbiAgICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgIHwgU29tZSBlbnRyeSAtPlxuICAgICAgICAgICAgICAobWF0Y2ggTXRpbWUuYWRkX3NwYW4gZW50cnkudXNlZF9sYXRlc3QgbWF4X2lkbGVfYWdlIHdpdGhcbiAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgTG9ncy53YXJuIH5zcmM6cG9vbC5sb2dfc3JjIChmdW4gZiAtPiBmXG4gICAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNjaGVkdWxlIHBvb2wgZXhwaXJhdGlvbiBjaGVjayBkdWUgdG8gXFxcbiAgICAgICAgICAgICAgICAgICAgIE10aW1lIG92ZXJmbG93LlwiKVxuICAgICAgICAgICAgICAgfCBTb21lIGV4cGlyeSAtPlxuICAgICAgICAgICAgICAgICAgaWYgTXRpbWUuY29tcGFyZSBub3cgZXhwaXJ5ID49IDAgdGhlblxuICAgICAgICAgICAgICAgICAgICBiZWdpblxuICAgICAgICAgICAgICAgICAgICAgIGxldCBlbnRyeSA9IFF1ZXVlLnRha2UgcG9vbC5xdWV1ZSBpblxuICAgICAgICAgICAgICAgICAgICAgIHBvb2wuY3VyX3NpemUgPC0gcG9vbC5jdXJfc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgYXN5bmMgfnN3OnBvb2wuc3dpdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuICgpIC0+IHBvb2wuZnJlZSBlbnRyeS5yZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgbG9vcCAoKVxuICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcG9vbC5hbGFybSA8LSBPcHRpb24uc29tZSBAQFxuICAgICAgICAgICAgICAgICAgICAgIEFsYXJtLnNjaGVkdWxlXG4gICAgICAgICAgICAgICAgICAgICAgICB+c3c6cG9vbC5zd2l0Y2ggfnN0ZGVudjpwb29sLnN0ZGVudiBleHBpcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luIGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICBwb29sLmFsYXJtIDwtIE5vbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VfZXhwaXJpbmcgcG9vbFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kKSlcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCAoKSlcblxuICBsZXQgcmVsZWFzZSBwb29sIGVudHJ5ID1cbiAgICBpZiBub3QgKGNhbl9yZXVzZSBwb29sIGVudHJ5KSB0aGVuIGJlZ2luXG4gICAgICBwb29sLmN1cl9zaXplIDwtIHBvb2wuY3VyX3NpemUgLSAxO1xuICAgICAgcG9vbC5mcmVlIGVudHJ5LnJlc291cmNlID58PSBmdW4gKCkgLT5cbiAgICAgIHNjaGVkdWxlIHBvb2xcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgcG9vbC5jaGVjayBlbnRyeS5yZXNvdXJjZSBiZWdpbiBmdW4gb2sgLT5cbiAgICAgICAgaWYgb2sgdGhlblxuICAgICAgICAgIGJlZ2luXG4gICAgICAgICAgICBlbnRyeS51c2VkX2xhdGVzdCA8LSBNdGltZV9jbG9jay5ub3cgKCk7XG4gICAgICAgICAgICBRdWV1ZS5hZGQgZW50cnkgcG9vbC5xdWV1ZTtcbiAgICAgICAgICAgIGRpc3Bvc2VfZXhwaXJpbmcgcG9vbFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmVnaW5cbiAgICAgICAgICAgIExvZ3Mud2FybiB+c3JjOnBvb2wubG9nX3NyYyAoZnVuIGYgLT5cbiAgICAgICAgICAgICAgZiBcIldpbGwgbm90IHJlcG9vbCBjb25uZWN0aW9uIGR1ZSB0byBpbnZhbGlkYXRpb24uXCIpO1xuICAgICAgICAgICAgcG9vbC5jdXJfc2l6ZSA8LSBwb29sLmN1cl9zaXplIC0gMVxuICAgICAgICAgIGVuZDtcbiAgICAgICAgc2NoZWR1bGUgcG9vbFxuICAgICAgZW5kO1xuICAgICAgRmliZXIucmV0dXJuICgpXG4gICAgZW5kXG5cbiAgbGV0IHVzZSA/KHByaW9yaXR5ID0gMC4wKSBmIHBvb2wgPVxuICAgIGFjcXVpcmUgfnByaW9yaXR5IHBvb2wgPj49PyBmdW4gZW50cnkgLT5cbiAgICBGaWJlci5maW5hbGx5XG4gICAgICAoZnVuICgpIC0+IGYgZW50cnkucmVzb3VyY2UpXG4gICAgICAoZnVuICgpIC0+IGVudHJ5LnVzZWRfY291bnQgPC0gZW50cnkudXNlZF9jb3VudCArIDE7IHJlbGVhc2UgcG9vbCBlbnRyeSlcblxuICBsZXQgcmVjIGRyYWluIHBvb2wgPVxuICAgIGlmIHBvb2wuY3VyX3NpemUgPSAwIHRoZW5cbiAgICAgIGJlZ2luXG4gICAgICAgIHBvb2wuYWxhcm0gfD4gT3B0aW9uLml0ZXIgYmVnaW4gZnVuIGFsYXJtIC0+XG4gICAgICAgICAgQWxhcm0udW5zY2hlZHVsZSBhbGFybTtcbiAgICAgICAgICBwb29sLmFsYXJtIDwtIE5vbmVcbiAgICAgICAgZW5kO1xuICAgICAgRmliZXIucmV0dXJuICgpXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAobWF0Y2ggUXVldWUudGFrZV9vcHQgcG9vbC5xdWV1ZSB3aXRoXG4gICAgICAgfCBOb25lIC0+IHdhaXQgfnByaW9yaXR5OjAuMCBwb29sXG4gICAgICAgfCBTb21lIGVudHJ5IC0+XG4gICAgICAgICAgcG9vbC5jdXJfc2l6ZSA8LSBwb29sLmN1cl9zaXplIC0gMTtcbiAgICAgICAgICBwb29sLmZyZWUgZW50cnkucmVzb3VyY2UpID4+PSBmdW4gKCkgLT5cbiAgICAgIGRyYWluIHBvb2xcblxuZW5kXG5cbm1vZHVsZSBOb19hbGFybSA9IHN0cnVjdFxuICB0eXBlIHQgPSB1bml0XG4gIGxldCBzY2hlZHVsZSB+c3c6XyB+c3RkZW52Ol8gXyBfID0gKClcbiAgbGV0IHVuc2NoZWR1bGUgXyA9ICgpXG5lbmRcblxubW9kdWxlIE1ha2Vfd2l0aG91dF9hbGFybSAoU3lzdGVtIDogU3lzdGVtX3NpZy5DT1JFKSA9IE1ha2UgKFN5c3RlbSkgKE5vX2FsYXJtKVxuIiwiKCogQ29weXJpZ2h0IChDKSAyMDE5LS0yMDIxICBQZXR0ZXIgQS4gVXJrZWRhbCA8cGF1cmtlZGFsQGdtYWlsLmNvbT5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91clxuICogb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbiwgd2l0aCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbmQgdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LiAgSWYgbm90LCBzZWVcbiAqIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPiBhbmQgPGh0dHBzOi8vc3BkeC5vcmc+LCByZXNwZWN0aXZlbHkuXG4gKilcblxubGV0IGRlZmF1bHRfbG9nX3NyYyA9IExvZ3MuU3JjLmNyZWF0ZSBcImNhcXRpXCJcblxubGV0IHJlcXVlc3RfbG9nX3NyYyA9IExvZ3MuU3JjLmNyZWF0ZSBcImNhcXRpLnJlcXVlc3RcIlxuIiwiKCogQ29weXJpZ2h0IChDKSAyMDIyLS0yMDI0ICBQZXR0ZXIgQS4gVXJrZWRhbCA8cGF1cmtlZGFsQGdtYWlsLmNvbT5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91clxuICogb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbiwgd2l0aCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbmQgdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LiAgSWYgbm90LCBzZWVcbiAqIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPiBhbmQgPGh0dHBzOi8vc3BkeC5vcmc+LCByZXNwZWN0aXZlbHkuXG4gKilcblxubW9kdWxlIHR5cGUgRFJJVkVSID0gc2lnXG4gIHR5cGUgKydhIGZpYmVyXG4gIHR5cGUgKCsnYSwgKydlcnIpIHN0cmVhbVxuICB0eXBlIHN3aXRjaFxuICB0eXBlIHN0ZGVudlxuXG4gIG1vZHVsZSB0eXBlIENPTk5FQ1RJT04gPSBDYXF0aV9jb25uZWN0aW9uX3NpZy5TXG4gICAgd2l0aCB0eXBlICdhIGZpYmVyIDo9ICdhIGZpYmVyXG4gICAgIGFuZCB0eXBlICgnYSwgJ2Vycikgc3RyZWFtIDo9ICgnYSwgJ2Vycikgc3RyZWFtXG5cbiAgdmFsIGRyaXZlcl9pbmZvIDogQ2FxdGlfZHJpdmVyX2luZm8udFxuXG4gIHZhbCBjb25uZWN0IDpcbiAgICBzdzogc3dpdGNoIC0+XG4gICAgc3RkZW52OiBzdGRlbnYgLT5cbiAgICA/ZW52OiAoQ2FxdGlfZHJpdmVyX2luZm8udCAtPiBzdHJpbmcgLT4gQ2FxdGlfcXVlcnkudCkgLT5cbiAgICBjb25maWc6IENhcXRpX2Nvbm5lY3RfY29uZmlnLnQgLT5cbiAgICBVcmkudCAtPlxuICAgICgobW9kdWxlIENPTk5FQ1RJT04pLCBbPiBDYXF0aV9lcnJvci5jb25uZWN0XSkgcmVzdWx0IGZpYmVyXG5lbmRcblxubW9kdWxlIHR5cGUgRFJJVkVSX0ZVTkNUT1IgPVxuICBmdW5jdG9yIChTeXN0ZW0gOiBTeXN0ZW1fc2lnLlMpIC0+XG4gIERSSVZFUlxuICAgIHdpdGggdHlwZSAnYSBmaWJlciA6PSAnYSBTeXN0ZW0uRmliZXIudFxuICAgICBhbmQgdHlwZSAoJ2EsICdlcnIpIHN0cmVhbSA6PSAoJ2EsICdlcnIpIFN5c3RlbS5TdHJlYW0udFxuICAgICBhbmQgdHlwZSBzd2l0Y2ggOj0gU3lzdGVtLlN3aXRjaC50XG4gICAgIGFuZCB0eXBlIHN0ZGVudiA6PSBTeXN0ZW0uc3RkZW52XG5cbmxldCBkcml2ZXJzID0gSGFzaHRibC5jcmVhdGUgNVxubGV0IHJlZ2lzdGVyIHNjaGVtZSBwID0gSGFzaHRibC5hZGQgZHJpdmVycyBzY2hlbWUgcFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgKydhIGZpYmVyXG4gIHR5cGUgKCsnYSwgKydlKSBzdHJlYW1cbiAgdHlwZSBzd2l0Y2hcbiAgdHlwZSBzdGRlbnZcblxuICBtb2R1bGUgdHlwZSBDT05ORUNUSU9OID0gQ2FxdGlfY29ubmVjdGlvbl9zaWcuU1xuICAgIHdpdGggdHlwZSAnYSBmaWJlciA6PSAnYSBmaWJlclxuICAgICBhbmQgdHlwZSAoJ2EsICdlKSBzdHJlYW0gOj0gKCdhLCAnZSkgc3RyZWFtXG5cbiAgbW9kdWxlIHR5cGUgRFJJVkVSID0gRFJJVkVSXG4gICAgd2l0aCB0eXBlICdhIGZpYmVyIDo9ICdhIGZpYmVyXG4gICAgIGFuZCB0eXBlICgnYSwgJ2UpIHN0cmVhbSA6PSAoJ2EsICdlKSBzdHJlYW1cbiAgICAgYW5kIHR5cGUgc3dpdGNoIDo9IHN3aXRjaFxuICAgICBhbmQgdHlwZSBzdGRlbnYgOj0gc3RkZW52XG5cbiAgdmFsIHByb3ZpZGVzX3VuaXggOiBib29sXG5cbiAgdmFsIGZpbmRfYW5kX2FwcGx5IDogc3RyaW5nIC0+IChtb2R1bGUgRFJJVkVSKSBvcHRpb25cbmVuZFxuXG5tb2R1bGUgTWFrZSAoU3lzdGVtIDogU3lzdGVtX3NpZy5TKSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBEUklWRVIgPSBEUklWRVJcbiAgICB3aXRoIHR5cGUgJ2EgZmliZXIgOj0gJ2EgU3lzdGVtLkZpYmVyLnRcbiAgICAgYW5kIHR5cGUgKCdhLCAnZSkgc3RyZWFtIDo9ICgnYSwgJ2UpIFN5c3RlbS5TdHJlYW0udFxuICAgICBhbmQgdHlwZSBzd2l0Y2ggOj0gU3lzdGVtLlN3aXRjaC50XG4gICAgIGFuZCB0eXBlIHN0ZGVudiA6PSBTeXN0ZW0uc3RkZW52XG5cbiAgbW9kdWxlIHR5cGUgQ09OTkVDVElPTiA9IENhcXRpX2Nvbm5lY3Rpb25fc2lnLlNcbiAgICB3aXRoIHR5cGUgJ2EgZmliZXIgOj0gJ2EgU3lzdGVtLkZpYmVyLnRcbiAgICAgYW5kIHR5cGUgKCdhLCAnZSkgc3RyZWFtIDo9ICgnYSwgJ2UpIFN5c3RlbS5TdHJlYW0udFxuXG4gIGxldCBwcm92aWRlc191bml4ID0gZmFsc2VcblxuICBsZXQgZmluZF9hbmRfYXBwbHkgc2NoZW1lID1cbiAgICAobWF0Y2ggSGFzaHRibC5maW5kX29wdCBkcml2ZXJzIHNjaGVtZSB3aXRoXG4gICAgIHwgTm9uZSAtPiBOb25lXG4gICAgIHwgU29tZSAobW9kdWxlIEYgOiBEUklWRVJfRlVOQ1RPUikgLT5cbiAgICAgICAgU29tZSAobW9kdWxlIEYgKFN5c3RlbSkgOiBEUklWRVIpKVxuZW5kXG4iLCIoKiBDb3B5cmlnaHQgKEMpIDIwMTktLTIwMjIgIFBldHRlciBBLiBVcmtlZGFsIDxwYXVya2VkYWxAZ21haWwuY29tPlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyXG4gKiBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLCB3aXRoIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbi5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFuZCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24gYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuICBJZiBub3QsIHNlZVxuICogPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+IGFuZCA8aHR0cHM6Ly9zcGR4Lm9yZz4sIHJlc3BlY3RpdmVseS5cbiAqKVxuXG5vcGVuIFByaW50ZlxuXG5sZXQgZGF0ZXR1cGxlX29mX2lzbzg2MDEgcyA9XG4gIGlmIFN0cmluZy5sZW5ndGggcyA9IDEwICYmIHMuWzRdID0gJy0nICYmIHMuWzddID0gJy0nIHRoZW5cbiAgICB0cnlcbiAgICAgIChpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHMgMCA0KSxcbiAgICAgICBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHMgNSAyKSxcbiAgICAgICBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHMgOCAyKSlcbiAgICB3aXRoIEZhaWx1cmUgXyAtPlxuICAgICAgZmFpbHdpdGggXCJDYXF0aV9wbGF0Zm9ybS5kYXRldHVwbGVfb2ZfaXNvODYwMVwiXG4gIGVsc2VcbiAgICBmYWlsd2l0aCBcIkNhcXRpX3BsYXRmb3JtLmRhdGV0dXBsZV9vZl9pc284NjAxXCJcblxubGV0IGlzbzg2MDFfb2ZfZGF0ZXR1cGxlICh5LCBtLCBkKSA9XG4gIHNwcmludGYgXCIlMDRkLSUwMmQtJTAyZFwiIHkgbSBkXG5cbmxldCBzdHJpbmdfb2ZfcmZjMzMzOV9lcnJvciB+aW5wdXQgZXJyID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgbGV0IHBwZiA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICBQdGltZS5wcF9yZmMzMzM5X2Vycm9yIHBwZiBlcnI7XG4gIEZvcm1hdC5mcHJpbnRmIHBwZiBcIiBpbiB2YWx1ZSAlUy5cIiBpbnB1dDtcbiAgRm9ybWF0LnBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG5sZXQgcHRpbWVfb2ZfcmZjMzMzOV91dGMgcyA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBzJyA9XG4gICAgaWYgbiA8IDEzIHRoZW4gcyBlbHNlXG4gICAgaWYgcy5bbiAtIDFdID0gJ1onIHRoZW4gcyBlbHNlXG4gICAgaWYgcy5bbiAtIDNdID0gJysnIHx8IHMuW24gLSAzXSA9ICctJyB0aGVuIHMgXiBcIjowMFwiIGVsc2VcbiAgICBpZiBzLltuIC0gNl0gPSAnKycgfHwgcy5bbiAtIDZdID0gJy0nIHRoZW4gcyBlbHNlXG4gICAgcyBeIFwiWlwiXG4gIGluXG4gIChtYXRjaCBQdGltZS5vZl9yZmMzMzM5IHMnIHdpdGhcbiAgIHwgT2sgKHQsIF8sIF8pIC0+IE9rIHRcbiAgIHwgRXJyb3IgKGBSRkMzMzM5IChfLCBlcnIpKSAtPlxuICAgICAgRXJyb3IgKHN0cmluZ19vZl9yZmMzMzM5X2Vycm9yIH5pbnB1dDpzJyBlcnIpKVxuXG5sZXQgcGRhdGVfb2ZfaXNvODYwMSBzID1cbiAgKG1hdGNoIFB0aW1lLm9mX2RhdGUgKGRhdGV0dXBsZV9vZl9pc284NjAxIHMpIHdpdGhcbiAgIHwgZXhjZXB0aW9uIEZhaWx1cmUgXyAtPlxuICAgICAgRXJyb3IgKHNwcmludGYgXCJDYW5ub3QgcGFyc2UgZGF0ZSAlUy5cIiBzKVxuICAgfCBOb25lIC0+XG4gICAgICBFcnJvciAoc3ByaW50ZiBcIkRhdGUgJXMgaXMgb3V0IG9mIHJhbmdlLlwiIHMpXG4gICB8IFNvbWUgcGRhdGUgLT4gT2sgcGRhdGUpXG5cbmxldCBpc284NjAxX29mX3BkYXRlIHggPSBpc284NjAxX29mX2RhdGV0dXBsZSAoUHRpbWUudG9fZGF0ZSB4KVxuIiwiKCogQ29weXJpZ2h0IChDKSAyMDE0LS0yMDI0ICBQZXR0ZXIgQS4gVXJrZWRhbCA8cGF1cmtlZGFsQGdtYWlsLmNvbT5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91clxuICogb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbiwgd2l0aCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbmQgdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LiAgSWYgbm90LCBzZWVcbiAqIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPiBhbmQgPGh0dHBzOi8vc3BkeC5vcmc+LCByZXNwZWN0aXZlbHkuXG4gKilcblxubGV0IGR5bmxvYWRfbGlicmFyeSA9IHJlZiBOb25lXG5cbmxldCBkZWZpbmVfbG9hZGVyIGxvYWQgPSBkeW5sb2FkX2xpYnJhcnkgOj0gU29tZSBsb2FkXG5cbmxldCBsb2FkX2xpYnJhcnkgbGliID1cbiAgKG1hdGNoICFkeW5sb2FkX2xpYnJhcnkgd2l0aFxuICAgfCBTb21lIGxvYWQgLT4gbG9hZCBsaWJcbiAgIHwgTm9uZSAtPlxuICAgICAgRXJyb3IgKFByaW50Zi5zcHJpbnRmIFwiXFxcbiAgICAgICAgTmVpdGhlciAlcyBub3IgYSBkeW5hbWljIGxvYWRlciBpcyBsaW5rZWQgaW50byB0aGUgYXBwbGljYXRpb24uXCIgbGliKSlcblxubGV0IGxpYnJhcnlfbmFtZV9vZl9zY2hlbWUgPSBmdW5jdGlvblxuIHwgXCJwb3N0Z3Jlc1wiIHwgXCJwb3N0Z3Jlc3FsXCIgLT4gXCJjYXF0aS1kcml2ZXItcG9zdGdyZXNxbFwiXG4gfCBzIC0+IFwiY2FxdGktZHJpdmVyLVwiIF4gc1xuXG5sZXQgc2V0X3R3ZWFrc192ZXJzaW9uID0gZnVuY3Rpb25cbiB8IE5vbmUgLT4gRnVuLmlkXG4gfCBTb21lIHggLT4gQ2FxdGlfY29ubmVjdF9jb25maWcuKHNldCB0d2Vha3NfdmVyc2lvbikgeFxuXG5tb2R1bGUgTWFrZVxuICAoU3lzdGVtIDogU3lzdGVtX3NpZy5TKVxuICAoUG9vbCA6IFBvb2wuU1xuICAgIHdpdGggdHlwZSAnYSBmaWJlciA6PSAnYSBTeXN0ZW0uRmliZXIudFxuICAgICBhbmQgdHlwZSBzd2l0Y2ggOj0gU3lzdGVtLlN3aXRjaC50XG4gICAgIGFuZCB0eXBlIHN0ZGVudiA6PSBTeXN0ZW0uc3RkZW52KVxuICAoTG9hZGVyIDogRHJpdmVyX2xvYWRlci5TXG4gICAgd2l0aCB0eXBlICdhIGZpYmVyIDo9ICdhIFN5c3RlbS5GaWJlci50XG4gICAgIGFuZCB0eXBlIHN3aXRjaCA6PSBTeXN0ZW0uU3dpdGNoLnRcbiAgICAgYW5kIHR5cGUgc3RkZW52IDo9IFN5c3RlbS5zdGRlbnZcbiAgICAgYW5kIHR5cGUgKCdhLCAnZSkgc3RyZWFtIDo9ICgnYSwgJ2UpIFN5c3RlbS5TdHJlYW0udCkgPVxuc3RydWN0XG4gIG9wZW4gU3lzdGVtXG4gIG9wZW4gU3lzdGVtLkZpYmVyLkluZml4XG5cbiAgbW9kdWxlIHR5cGUgQ09OTkVDVElPTiA9IENhcXRpX2Nvbm5lY3Rpb25fc2lnLlNcbiAgICB3aXRoIHR5cGUgJ2EgZmliZXIgOj0gJ2EgRmliZXIudFxuICAgICBhbmQgdHlwZSAoJ2EsICdlcnIpIHN0cmVhbSA6PSAoJ2EsICdlcnIpIFN0cmVhbS50XG5cbiAgdHlwZSBjb25uZWN0aW9uID0gKG1vZHVsZSBDT05ORUNUSU9OKVxuXG4gIGxldCAoPj49PykgbSBmID0gbSA+Pj0gZnVuY3Rpb24gT2sgeCAtPiBmIHggfCBFcnJvciBfIGFzIHIgLT4gRmliZXIucmV0dXJuIHJcbiAgbGV0ICg+fD0/KSBtIGYgPSBtID58PSBmdW5jdGlvbiBPayB4IC0+IChPayAoZiB4KSkgfCBFcnJvciBfIGFzIHIgLT4gclxuICBsZXQgKGxldCs/KSA9ICg+fD0/KVxuXG4gIG1vZHVsZSB0eXBlIERSSVZFUiA9IERyaXZlcl9sb2FkZXIuRFJJVkVSXG4gICAgd2l0aCB0eXBlICdhIGZpYmVyIDo9ICdhIEZpYmVyLnRcbiAgICAgYW5kIHR5cGUgKCdhLCAnZXJyKSBzdHJlYW0gOj0gKCdhLCAnZXJyKSBTdHJlYW0udFxuICAgICBhbmQgdHlwZSBzd2l0Y2ggOj0gU3lzdGVtLlN3aXRjaC50XG4gICAgIGFuZCB0eXBlIHN0ZGVudiA6PSBTeXN0ZW0uc3RkZW52XG5cbiAgbGV0IGRyaXZlcnMgOiAoc3RyaW5nLCAobW9kdWxlIERSSVZFUikpIEhhc2h0YmwudCA9IEhhc2h0YmwuY3JlYXRlIDExXG5cbiAgbGV0IG1lc3NhZ2VfY29udCA6IChfLCBfLCBfLCBfKSBmb3JtYXQ0ID1cbiAgICBpZiBMb2FkZXIucHJvdmlkZXNfdW5peCB0aGVuXG4gICAgICBcIllvdXIgZW50cnkgcG9pbnQgcHJvdmlkZXMgYm90aCB0aGUgbmV0d29ya2luZyBhbmQgdW5peCBjb21wb25lbnRzLlwiXG4gICAgZWxzZVxuICAgICAgXCJZb3VyIGVudHJ5IHBvaW50IHByb3ZpZGVzIHRoZSBuZXR3b3JraW5nIGJ1dCBub3QgdGhlIHVuaXggY29tcG9uZW50LCBcXFxuICAgICAgIHdoaWNoIGlzIHJlcXVpcmVkIGJ5IGRyaXZlcnMgYmFzZWQgb24gQyBiaW5kaW5ncy5cIlxuXG4gIGxldCBtZXNzYWdlX3N0YXRpYyA9IFByaW50Zi5zcHJpbnRmXG4gICAgKFwiQSBzdWl0YWJsZSBkcml2ZXIgZm9yIHRoZSBVUkktc2NoZW1lICVzIHdhcyBub3QgZm91bmQuIFwiIF5eIG1lc3NhZ2VfY29udClcblxuICBsZXQgbWVzc2FnZV9keW5hbWljID0gUHJpbnRmLnNwcmludGZcbiAgICAoXCJBIHN1aXRhYmxlIGRyaXZlciBmb3IgdGhlIFVSSS1zY2hlbWUgJXMgd2FzIG5vdCBmb3VuZCBcXFxuICAgICAgYWZ0ZXIgbGlua2luZyBpbiAlcy4gXCIgXl4gbWVzc2FnZV9jb250KVxuXG4gIGxldCBsb2FkX2RyaXZlcicgfnVyaSBzY2hlbWUgPVxuICAgIChtYXRjaCBMb2FkZXIuZmluZF9hbmRfYXBwbHkgc2NoZW1lIHdpdGhcbiAgICAgfCBTb21lIGRyaXZlciAtPiBPayBkcml2ZXJcbiAgICAgfCBOb25lIC0+XG4gICAgICAgIChtYXRjaCAhZHlubG9hZF9saWJyYXJ5IHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgbGV0IG1zZyA9IG1lc3NhZ2Vfc3RhdGljIHNjaGVtZSBpblxuICAgICAgICAgICAgRXJyb3IgKENhcXRpX2Vycm9yLmxvYWRfZmFpbGVkIH51cmkgKENhcXRpX2Vycm9yLk1zZyBtc2cpKVxuICAgICAgICAgfCBTb21lIGxvYWQgLT5cbiAgICAgICAgICAgIGxldCBkcml2ZXJfbGliID0gbGlicmFyeV9uYW1lX29mX3NjaGVtZSBzY2hlbWUgaW5cbiAgICAgICAgICAgIChtYXRjaCBsb2FkIGRyaXZlcl9saWIgd2l0aFxuICAgICAgICAgICAgIHwgT2sgKCkgLT5cbiAgICAgICAgICAgICAgICAobWF0Y2ggTG9hZGVyLmZpbmRfYW5kX2FwcGx5IHNjaGVtZSB3aXRoXG4gICAgICAgICAgICAgICAgIHwgU29tZSBkcml2ZXIgLT4gT2sgZHJpdmVyXG4gICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgbXNnID0gbWVzc2FnZV9keW5hbWljIHNjaGVtZSBkcml2ZXJfbGliIGluXG4gICAgICAgICAgICAgICAgICAgIEVycm9yIChDYXF0aV9lcnJvci5sb2FkX2ZhaWxlZCB+dXJpIChDYXF0aV9lcnJvci5Nc2cgbXNnKSkpXG4gICAgICAgICAgICAgfCBFcnJvciBtc2cgLT5cbiAgICAgICAgICAgICAgICBFcnJvciAoQ2FxdGlfZXJyb3IubG9hZF9mYWlsZWQgfnVyaSAoQ2FxdGlfZXJyb3IuTXNnIG1zZykpKSkpXG5cbiAgbGV0IGxvYWRfZHJpdmVyIHVyaSA9XG4gICAgKG1hdGNoIFVyaS5zY2hlbWUgdXJpIHdpdGhcbiAgICAgfCBOb25lIC0+XG4gICAgICAgIGxldCBtc2cgPSBcIk1pc3NpbmcgVVJJIHNjaGVtZS5cIiBpblxuICAgICAgICBFcnJvciAoQ2FxdGlfZXJyb3IubG9hZF9yZWplY3RlZCB+dXJpIChDYXF0aV9lcnJvci5Nc2cgbXNnKSlcbiAgICAgfCBTb21lIHNjaGVtZSAtPlxuICAgICAgICAodHJ5IE9rIChIYXNodGJsLmZpbmQgZHJpdmVycyBzY2hlbWUpIHdpdGhcbiAgICAgICAgIHwgTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICAobWF0Y2ggbG9hZF9kcml2ZXInIH51cmkgc2NoZW1lIHdpdGhcbiAgICAgICAgICAgICB8IE9rIGRyaXZlciAtPlxuICAgICAgICAgICAgICAgIEhhc2h0YmwuYWRkIGRyaXZlcnMgc2NoZW1lIGRyaXZlcjtcbiAgICAgICAgICAgICAgICBPayBkcml2ZXJcbiAgICAgICAgICAgICB8IEVycm9yIF8gYXMgciAtPiByKSkpXG5cbiAgbGV0IGNvbm5lY3RcbiAgICAgICAgP2VudiA/KGNvbmZpZyA9IENhcXRpX2Nvbm5lY3RfY29uZmlnLmRlZmF1bHQpXG4gICAgICAgID90d2Vha3NfdmVyc2lvbiB+c3cgfnN0ZGVudiB1cmlcbiAgICAgIDogKChtb2R1bGUgQ09OTkVDVElPTiksIF8pIHJlc3VsdCBGaWJlci50ID1cbiAgICBsZXQgY29uZmlnID0gc2V0X3R3ZWFrc192ZXJzaW9uIHR3ZWFrc192ZXJzaW9uIGNvbmZpZyBpblxuICAgIFN3aXRjaC5jaGVjayBzdztcbiAgICAobWF0Y2ggbG9hZF9kcml2ZXIgdXJpIHdpdGhcbiAgICAgfCBPayBkcml2ZXIgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBEcml2ZXIgPSAodmFsIGRyaXZlcikgaW5cbiAgICAgICAgbGV0Kz8gY29ubiA9IERyaXZlci5jb25uZWN0IH5zdyB+c3RkZW52ID9lbnYgfmNvbmZpZyB1cmkgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb25uID0gKHZhbCBjb25uIDogQ09OTkVDVElPTikgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb25uJyA9IHN0cnVjdFxuICAgICAgICAgIGluY2x1ZGUgQ29ublxuICAgICAgICAgIGxldCBkaXNjb25uZWN0ID1cbiAgICAgICAgICAgIGxldCBob29rID0gU3dpdGNoLm9uX3JlbGVhc2VfY2FuY2VsbGFibGUgc3cgZGlzY29ubmVjdCBpblxuICAgICAgICAgICAgZnVuICgpIC0+IFN3aXRjaC5yZW1vdmVfaG9vayBob29rOyBkaXNjb25uZWN0ICgpXG4gICAgICAgIGVuZCBpblxuICAgICAgICAobW9kdWxlIENvbm4nIDogQ09OTkVDVElPTilcbiAgICAgfCBFcnJvciBlcnIgLT5cbiAgICAgICAgRmliZXIucmV0dXJuIChFcnJvciBlcnIpKVxuXG4gIGxldCB3aXRoX2Nvbm5lY3Rpb25cbiAgICAgICAgP2VudiA/Y29uZmlnID90d2Vha3NfdmVyc2lvbiB+c3RkZW52IHVyaSBmID1cbiAgICBTd2l0Y2gucnVuIGJlZ2luIGZ1biBzdyAtPlxuICAgICAgY29ubmVjdCB+c3cgfnN0ZGVudiA/ZW52ID9jb25maWcgP3R3ZWFrc192ZXJzaW9uIHVyaSA+Pj0/IGZcbiAgICBlbmRcblxuICBsZXQgY29ubmVjdF9wb29sXG4gICAgICAgID9wb29sX2NvbmZpZyA/cG9zdF9jb25uZWN0ID9lbnZcbiAgICAgICAgPyhjb25maWcgPSBDYXF0aV9jb25uZWN0X2NvbmZpZy5kZWZhdWx0KVxuICAgICAgICA/dHdlYWtzX3ZlcnNpb24gfnN3IH5zdGRlbnYgdXJpID1cbiAgICBsZXQgcG9vbF9jb25maWcgPVxuICAgICAgKG1hdGNoIHBvb2xfY29uZmlnIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gQ2FxdGlfcG9vbF9jb25maWcuZGVmYXVsdF9mcm9tX2VudiAoKVxuICAgICAgIHwgU29tZSBwb29sX2NvbmZpZyAtPiBwb29sX2NvbmZpZylcbiAgICBpblxuICAgIGxldCBjb25maWcgPSBzZXRfdHdlYWtzX3ZlcnNpb24gdHdlYWtzX3ZlcnNpb24gY29uZmlnIGluXG4gICAgU3dpdGNoLmNoZWNrIHN3O1xuICAgIGxldCBjaGVja19hcmcgY29uZCA9XG4gICAgICBpZiBub3QgY29uZCB0aGVuIGludmFsaWRfYXJnIFwiQ2FxdGlfY29ubmVjdC5NYWtlLmNvbm5lY3RfcG9vbFwiXG4gICAgaW5cbiAgICAobWF0Y2ggQ2FxdGlfcG9vbF9jb25maWcuKGdldCBtYXhfc2l6ZSkgcG9vbF9jb25maWcsXG4gICAgICAgICAgIENhcXRpX3Bvb2xfY29uZmlnLihnZXQgbWF4X2lkbGVfc2l6ZSkgcG9vbF9jb25maWcgd2l0aFxuICAgICB8IE5vbmUsIE5vbmUgLT4gKClcbiAgICAgfCBTb21lIG1heF9zaXplLCBOb25lIC0+IGNoZWNrX2FyZyAobWF4X3NpemUgPj0gMClcbiAgICAgfCBOb25lLCBTb21lIF8gLT4gY2hlY2tfYXJnIGZhbHNlXG4gICAgIHwgU29tZSBtYXhfc2l6ZSwgU29tZSBtYXhfaWRsZV9zaXplIC0+XG4gICAgICAgIGNoZWNrX2FyZyAobWF4X3NpemUgPj0gMCk7XG4gICAgICAgIGNoZWNrX2FyZyAoMCA8PSBtYXhfaWRsZV9zaXplICYmIG1heF9pZGxlX3NpemUgPD0gbWF4X3NpemUpKTtcbiAgICAobWF0Y2ggbG9hZF9kcml2ZXIgdXJpIHdpdGhcbiAgICAgfCBPayBkcml2ZXIgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBEcml2ZXIgPSAodmFsIGRyaXZlcikgaW5cbiAgICAgICAgbGV0IGNvbm5lY3QgPVxuICAgICAgICAgIChtYXRjaCBwb3N0X2Nvbm5lY3Qgd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgKERyaXZlci5jb25uZWN0IH5zdyB+c3RkZW52ID9lbnYgfmNvbmZpZyB1cmlcbiAgICAgICAgICAgICAgICAgICAgOj4gKGNvbm5lY3Rpb24sIF8pIHJlc3VsdCBGaWJlci50KVxuICAgICAgICAgICB8IFNvbWUgcG9zdF9jb25uZWN0IC0+XG4gICAgICAgICAgICAgIGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgIChEcml2ZXIuY29ubmVjdCB+c3cgfnN0ZGVudiA/ZW52IH5jb25maWcgdXJpXG4gICAgICAgICAgICAgICAgICAgIDo+IChjb25uZWN0aW9uLCBfKSByZXN1bHQgRmliZXIudClcbiAgICAgICAgICAgICAgICAgID4+PT8gZnVuIGNvbm4gLT4gcG9zdF9jb25uZWN0IGNvbm5cbiAgICAgICAgICAgICAgICAgID58PT8gZnVuICgpIC0+IGNvbm4pXG4gICAgICAgIGluXG4gICAgICAgIGxldCBkaXNjb25uZWN0IChtb2R1bGUgRGIgOiBDT05ORUNUSU9OKSA9IERiLmRpc2Nvbm5lY3QgKCkgaW5cbiAgICAgICAgbGV0IHZhbGlkYXRlIChtb2R1bGUgRGIgOiBDT05ORUNUSU9OKSA9IERiLnZhbGlkYXRlICgpIGluXG4gICAgICAgIGxldCBjaGVjayAobW9kdWxlIERiIDogQ09OTkVDVElPTikgPSBEYi5jaGVjayBpblxuICAgICAgICBsZXQgZGkgPSBEcml2ZXIuZHJpdmVyX2luZm8gaW5cbiAgICAgICAgbGV0IHBvb2xfY29uZmlnID1cbiAgICAgICAgICAobWF0Y2ggQ2FxdGlfZHJpdmVyX2luZm8uY2FuX2NvbmN1ciBkaSxcbiAgICAgICAgICAgICAgICAgQ2FxdGlfZHJpdmVyX2luZm8uY2FuX3Bvb2wgZGksXG4gICAgICAgICAgICAgICAgIENhcXRpX3Bvb2xfY29uZmlnLihnZXQgbWF4X2lkbGVfc2l6ZSkgcG9vbF9jb25maWcgd2l0aFxuICAgICAgICAgICB8IHRydWUsIHRydWUsIF8gLT5cbiAgICAgICAgICAgICAgcG9vbF9jb25maWdcbiAgICAgICAgICAgfCB0cnVlLCBmYWxzZSwgXyAtPlxuICAgICAgICAgICAgICBwb29sX2NvbmZpZyB8PiBDYXF0aV9wb29sX2NvbmZpZy4oc2V0IG1heF9pZGxlX3NpemUpIDBcbiAgICAgICAgICAgfCBmYWxzZSwgdHJ1ZSwgU29tZSAwIC0+XG4gICAgICAgICAgICAgIHBvb2xfY29uZmlnXG4gICAgICAgICAgICAgICAgfD4gQ2FxdGlfcG9vbF9jb25maWcuKHNldCBtYXhfc2l6ZSkgMVxuICAgICAgICAgICAgICAgIHw+IENhcXRpX3Bvb2xfY29uZmlnLihzZXQgbWF4X2lkbGVfc2l6ZSkgMFxuICAgICAgICAgICB8IGZhbHNlLCB0cnVlLCBfIC0+XG4gICAgICAgICAgICAgIHBvb2xfY29uZmlnXG4gICAgICAgICAgICAgICAgfD4gQ2FxdGlfcG9vbF9jb25maWcuKHNldCBtYXhfc2l6ZSkgMVxuICAgICAgICAgICAgICAgIHw+IENhcXRpX3Bvb2xfY29uZmlnLihzZXQgbWF4X2lkbGVfc2l6ZSkgMVxuICAgICAgICAgICB8IGZhbHNlLCBmYWxzZSwgXyAtPlxuICAgICAgICAgICAgICBwb29sX2NvbmZpZ1xuICAgICAgICAgICAgICAgIHw+IENhcXRpX3Bvb2xfY29uZmlnLihzZXQgbWF4X3NpemUpIDFcbiAgICAgICAgICAgICAgICB8PiBDYXF0aV9wb29sX2NvbmZpZy4oc2V0IG1heF9pZGxlX3NpemUpIDApXG4gICAgICAgIGluXG4gICAgICAgIGxldCBwb29sID1cbiAgICAgICAgICBQb29sLmNyZWF0ZVxuICAgICAgICAgICAgfmNvbmZpZzpwb29sX2NvbmZpZyB+dmFsaWRhdGUgfmNoZWNrIH5zdyB+c3RkZW52IGNvbm5lY3QgZGlzY29ubmVjdFxuICAgICAgICBpblxuICAgICAgICBsZXQgaG9vayA9XG4gICAgICAgICAgU3dpdGNoLm9uX3JlbGVhc2VfY2FuY2VsbGFibGUgc3cgKGZ1biAoKSAtPiBQb29sLmRyYWluIHBvb2wpXG4gICAgICAgIGluXG4gICAgICAgIEdjLmZpbmFsaXNlIChmdW4gXyAtPiBTd2l0Y2gucmVtb3ZlX2hvb2sgaG9vaykgcG9vbDtcbiAgICAgICAgT2sgcG9vbFxuICAgICB8IEVycm9yIGVyciAtPlxuICAgICAgICBFcnJvciBlcnIpXG5lbmRcbiIsIigqIENvcHlyaWdodCAoQykgMjAxOS0tMjAyMCAgUGV0dGVyIEEuIFVya2VkYWwgPHBhdXJrZWRhbEBnbWFpbC5jb20+XG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXJcbiAqIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24sIHdpdGggdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYW5kIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbiBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeS4gIElmIG5vdCwgc2VlXG4gKiA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4gYW5kIDxodHRwczovL3NwZHgub3JnPiwgcmVzcGVjdGl2ZWx5LlxuICopXG5cbm9wZW4gUHJpbnRmXG5cbm1vZHVsZSBNYWtlX2hlbHBlcnNcbiAgKFN5c3RlbSA6IFN5c3RlbV9zaWcuUykgPVxuc3RydWN0XG4gIG9wZW4gU3lzdGVtXG4gIG9wZW4gU3lzdGVtLkZpYmVyLkluZml4XG5cbiAgbGV0IGFzc2VydF9zaW5nbGVfdXNlIH53aGF0IGluX3VzZSBmID1cbiAgICBpZiAhaW5fdXNlIHRoZW5cbiAgICAgIGZhaWx3aXRoIChcIkludmFsaWQgY29uY3VycmVudCB1c2FnZSBvZiBcIiBeIHdoYXQgXiBcIiBkZXRlY3RlZC5cIik7XG4gICAgaW5fdXNlIDo9IHRydWU7XG4gICAgRmliZXIuY2xlYW51cFxuICAgICAgKGZ1biAoKSAtPiBmICgpID58PSBmdW4gcmVzIC0+IGluX3VzZSA6PSBmYWxzZTsgcmVzKVxuICAgICAgKGZ1biAoKSAtPiBpbl91c2UgOj0gZmFsc2U7IEZpYmVyLnJldHVybiAoKSlcbmVuZFxuXG5tb2R1bGUgTWFrZV9jb252ZW5pZW5jZVxuICAoU3lzdGVtIDogU3lzdGVtX3NpZy5TKVxuICAoQyA6IENhcXRpX2Nvbm5lY3Rpb25fc2lnLkJhc2VcbiAgICAgICAgd2l0aCB0eXBlICdhIGZpYmVyIDo9ICdhIFN5c3RlbS5GaWJlci50XG4gICAgICAgICBhbmQgdHlwZSAoJ2EsICdlcnIpIHN0cmVhbSA6PSAoJ2EsICdlcnIpIFN5c3RlbS5TdHJlYW0udCkgPVxuc3RydWN0XG4gIG9wZW4gU3lzdGVtXG4gIG9wZW4gU3lzdGVtLkZpYmVyLkluZml4XG4gIG1vZHVsZSBSZXNwb25zZSA9IEMuUmVzcG9uc2VcbiAgbGV0ICg+Pj0/KSBtIGYgPSBtID4+PSBmdW5jdGlvbiBPayB4IC0+IGYgeCB8IEVycm9yIF8gYXMgciAtPiBGaWJlci5yZXR1cm4gclxuICBsZXQgKD58PT8pIG0gZiA9IG0gPnw9IGZ1bmN0aW9uIE9rIHIgLT4gT2sgKGYgcikgfCBFcnJvciBfIGFzIHIgLT4gclxuXG4gIGxldCBleGVjIHEgcCA9IEMuY2FsbCB+ZjpSZXNwb25zZS5leGVjIHEgcFxuICBsZXQgZmluZCBxIHAgPSBDLmNhbGwgfmY6UmVzcG9uc2UuZmluZCBxIHBcbiAgbGV0IGZpbmRfb3B0IHEgcCA9IEMuY2FsbCB+ZjpSZXNwb25zZS5maW5kX29wdCBxIHBcbiAgbGV0IGZvbGQgcSBmIHAgYWNjID0gQy5jYWxsIH5mOihmdW4gcmVzcCAtPiBSZXNwb25zZS5mb2xkIGYgcmVzcCBhY2MpIHEgcFxuICBsZXQgZm9sZF9zIHEgZiBwIGFjYyA9IEMuY2FsbCB+ZjooZnVuIHJlc3AgLT4gUmVzcG9uc2UuZm9sZF9zIGYgcmVzcCBhY2MpIHEgcFxuICBsZXQgaXRlcl9zIHEgZiBwID0gQy5jYWxsIH5mOihmdW4gcmVzcCAtPiBSZXNwb25zZS5pdGVyX3MgZiByZXNwKSBxIHBcbiAgbGV0IGNvbGxlY3RfbGlzdCBxIHAgPVxuICAgIGxldCBmIHJlc3AgPSBSZXNwb25zZS5mb2xkIExpc3QuY29ucyByZXNwIFtdID58PSBSZXN1bHQubWFwIExpc3QucmV2IGluXG4gICAgQy5jYWxsIH5mIHEgcFxuICBsZXQgcmV2X2NvbGxlY3RfbGlzdCBxIHAgPVxuICAgIGxldCBmIHJlc3AgPSBSZXNwb25zZS5mb2xkIExpc3QuY29ucyByZXNwIFtdIGluXG4gICAgQy5jYWxsIH5mIHEgcFxuXG4gIGxldCBleGVjX3dpdGhfYWZmZWN0ZWRfY291bnQgcSBwID1cbiAgICBsZXQgZiByZXNwb25zZSA9XG4gICAgICBSZXNwb25zZS5leGVjIHJlc3BvbnNlID4+PSBmdW4gZXhlY1Jlc3VsdCAtPlxuICAgICAgbWF0Y2ggZXhlY1Jlc3VsdCB3aXRoXG4gICAgICB8IE9rICgpIC0+IFJlc3BvbnNlLmFmZmVjdGVkX2NvdW50IHJlc3BvbnNlXG4gICAgICB8IEVycm9yIHggLT4gRmliZXIucmV0dXJuIChFcnJvciB4KSBpblxuICAgIEMuY2FsbCB+ZiBxIHBcblxuICBsZXQgd2l0aF90cmFuc2FjdGlvbiBmID1cbiAgICBDLnN0YXJ0ICgpID4+PT8gZnVuICgpIC0+XG4gICAgRmliZXIuY2xlYW51cFxuICAgICAgKGZ1biAoKSAtPlxuICAgICAgICBmICgpID4+PSAoZnVuY3Rpb25cbiAgICAgICAgIHwgT2sgeSAtPiBDLmNvbW1pdCAoKSA+fD0/IGZ1biAoKSAtPiB5XG4gICAgICAgICB8IEVycm9yIF8gYXMgciAtPiBDLnJvbGxiYWNrICgpID58PSBmdW4gXyAtPiByKSlcbiAgICAgIChmdW4gKCkgLT4gQy5yb2xsYmFjayAoKSA+fD0gaWdub3JlKVxuZW5kXG5cbm1vZHVsZSBNYWtlX3BvcHVsYXRlXG4gIChTeXN0ZW0gOiBTeXN0ZW1fc2lnLlMpXG4gIChDIDogQ2FxdGlfY29ubmVjdGlvbl9zaWcuQmFzZVxuICAgICAgICB3aXRoIHR5cGUgJ2EgZmliZXIgOj0gJ2EgU3lzdGVtLkZpYmVyLnRcbiAgICAgICAgIGFuZCB0eXBlICgnYSwgJ2UpIHN0cmVhbSA6PSAoJ2EsICdlKSBTeXN0ZW0uU3RyZWFtLnQpID1cbnN0cnVjdFxuICBvcGVuIFN5c3RlbVxuICBvcGVuIFN5c3RlbS5GaWJlci5JbmZpeFxuICBsZXQgKD4+PT8pIG0gZiA9IG0gPj49IGZ1bmN0aW9uIE9rIHggLT4gZiB4IHwgRXJyb3IgXyBhcyByIC0+IEZpYmVyLnJldHVybiByXG5cbiAgbGV0IHBvcHVsYXRlIH50YWJsZSB+Y29sdW1ucyByb3dfdHlwZSBkYXRhID1cblxuICAgIGxldCByZXF1ZXN0ID1cbiAgICAgIGxldCBjb2x1bW5zX3R1cGxlID0gU3RyaW5nLmNvbmNhdCBcIiwgXCIgY29sdW1ucyBpblxuICAgICAgbGV0IHEgPVxuICAgICAgICBsZXQgb3BlbiBDYXF0aV9xdWVyeSBpblxuICAgICAgICBTW0woc3ByaW50ZiBcIklOU0VSVCBJTlRPICVzICglcykgVkFMVUVTIChcIiB0YWJsZSBjb2x1bW5zX3R1cGxlKTtcbiAgICAgICAgICBjb25jYXQgXCIsIFwiIChMaXN0Lm1hcGkgKGZ1biBpIF8gLT4gUCBpKSBjb2x1bW5zKTsgTFwiKVwiXVxuICAgICAgaW5cbiAgICAgIENhcXRpX3JlcXVlc3QuY3JlYXRlIHJvd190eXBlIENhcXRpX3R5cGUudW5pdCBDYXF0aV9tdWx0Lnplcm8gKGZ1biBfIC0+IHEpXG4gICAgaW5cblxuICAgIEMuc3RhcnQgKCkgPj49PyBmdW4gKCkgLT5cbiAgICBTdHJlYW0uaXRlcl9zIH5mOihDLmNhbGwgfmY6Qy5SZXNwb25zZS5leGVjIHJlcXVlc3QpIGRhdGEgPj49IGZ1biByZXMgLT5cbiAgICBDLmRlYWxsb2NhdGUgcmVxdWVzdCA+Pj0gZnVuIF8gLT5cbiAgICAobWF0Y2ggcmVzIHdpdGhcbiAgICAgfCBPayAoKSAtPlxuICAgICAgICBDLmNvbW1pdCAoKVxuICAgICB8IEVycm9yIChgQ29uZ2VzdGVkIGVycikgLT5cbiAgICAgICAgQy5yb2xsYmFjayAoKSA+Pj0/IGZ1biAoKSAtPlxuICAgICAgICBGaWJlci5yZXR1cm4gKEVycm9yIChgQ29uZ2VzdGVkIGVycikpXG4gICAgIHwgRXJyb3IgZXJyIC0+XG4gICAgICAgIEZpYmVyLnJldHVybiAoRXJyb3IgZXJyKSlcbmVuZFxuIl19
