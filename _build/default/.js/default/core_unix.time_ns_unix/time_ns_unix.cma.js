// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Time_ns_unix__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Time_ns_unix = [0],
    Time_ns_unix$0 = [0, Time_ns_unix];
   runtime.caml_register_global(0, Time_ns_unix$0, "Time_ns_unix__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Time_ns_unix__Time_ns_unix_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Time_ns_unix_Time_ns_unix_ = "Time_ns_unix__Time_ns_unix_intf",
    cst_time_ns_unix = "time_ns_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Time_ns_unix_Time_ns_unix_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_time_ns_unix);
   caml_call1
    (Ppx_expect_runtime[1][1], "time_ns_unix/src/time_ns_unix_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_time_ns_unix, "time_ns_unix_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_time_ns_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Time_ns_unix_Time_ns_unix_);
   var Time_ns_unix_Time_ns_unix_intf = [0];
   runtime.caml_register_global
    (11, Time_ns_unix_Time_ns_unix_intf, cst_Time_ns_unix_Time_ns_unix_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Time_ns_unix
//# unitInfo: Requires: Base__Exn, Base__Hash, Base__Pretty_printer, Base_quickcheck__Shrinker, Bin_prot__Common, Bin_prot__Shape, Bin_shape, CamlinternalLazy, Core, Core__Binable, Core__Bool, Core__Command_internal, Core__Comparable, Core__Comparator, Core__Date, Core__Day_of_week, Core__Identifiable, Core__List, Core__Month, Core__Option, Core__Quickcheck, Core__Sexpable, Core__String, Core__Time_ns, Core__Time_ns_intf, Core_unix, Diffable__Atomic, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stable_witness, Time_float_unix, Timezone, Typerep_lib__Make_typename
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = " ",
    cst_Time_ns_unix$0 = "Time_ns_unix",
    cst_ofday$1 = "ofday",
    cst_t$23 = "t",
    cst_time_ns_unix$0 = "time_ns_unix",
    cst_zone$1 = "zone",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    error_source_013 =
      "time_ns_unix/src/time_ns_unix.ml.Ofday.Zoned.sexp_repr",
    module_name = "Time_ns_unix.Ofday.Zoned",
    error_source_029 =
      "time_ns_unix/src/time_ns_unix.ml.Ofday.Zoned.Stable.V1.sexp_repr",
    name = "time_ns_unix/src/time_ns_unix.ml.Ofday.Option.t",
    module_name$0 = "Time_ns_unix.Ofday.Option",
    t_sexp_grammar$0 =
      [4,
       [0,
        4,
        [0, [2, [0, 4, [0, 4, 0]]], [0, [2, [0, 4, [0, 4, [0, 4, 0]]]], 0]]]],
    module_name$1 = "Time_ns_unix.Option",
    module_name$2 = cst_Time_ns_unix$0,
    Core_Time_ns = global_data.Core__Time_ns,
    Time_float_unix = global_data.Time_float_unix,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Core_Date = global_data.Core__Date,
    Base_Exn = global_data.Base__Exn,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Timezone = global_data.Timezone,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Bin_prot_Common = global_data.Bin_prot__Common,
    Core_String = global_data.Core__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Hash = global_data.Base__Hash,
    Core_unix = global_data.Core_unix,
    Core_Month = global_data.Core__Month,
    Core_Day_of_week = global_data.Core__Day_of_week,
    Assert_failure = global_data.Assert_failure,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Command_internal = global_data.Core__Command_internal,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Bin_shape = global_data.Bin_shape,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Stable_witness = global_data.Stable_witness,
    Core_Binable = global_data.Core__Binable,
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename,
    Core_Quickcheck = global_data.Core__Quickcheck,
    Core_Option = global_data.Core__Option,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    Core_Comparator = global_data.Core__Comparator,
    Diffable_Atomic = global_data.Diffable__Atomic,
    Core_Sexpable = global_data.Core__Sexpable,
    Core_Identifiable = global_data.Core__Identifiable,
    Core_Comparable = global_data.Core__Comparable,
    Core_Time_ns_intf = global_data.Core__Time_ns_intf;
   caml_call1(Ppx_module_timer_runtime[4], cst_Time_ns_unix$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_time_ns_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "time_ns_unix/src/time_ns_unix.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_time_ns_unix$0, "time_ns_unix.ml");
   var
    Ofday = Core_Time_ns[2],
    hash_fold_t = Core_Time_ns[3],
    hash = Core_Time_ns[4],
    typerep_of_t = Core_Time_ns[5],
    typename_of_t = Core_Time_ns[6],
    bin_size_t = Core_Time_ns[7],
    bin_write_t = Core_Time_ns[8],
    bin_read_t = Core_Time_ns[9],
    bin_read_t$0 = Core_Time_ns[10],
    bin_shape_t = Core_Time_ns[11],
    equal = Core_Time_ns[21],
    compare = Core_Time_ns[22],
    Alternate_sexp = Core_Time_ns[25],
    quickcheck_generator = Core_Time_ns[27],
    quickcheck_observer = Core_Time_ns[28],
    quickcheck_shrinker = Core_Time_ns[29],
    gen_incl = Core_Time_ns[30],
    gen_uniform_incl = Core_Time_ns[31],
    is_earlier = Core_Time_ns[32],
    is_later = Core_Time_ns[33],
    of_date_ofday = Core_Time_ns[34],
    of_date_ofday_precise = Core_Time_ns[35],
    to_date_ofday = Core_Time_ns[36],
    to_date_ofday_precise = Core_Time_ns[37],
    to_date = Core_Time_ns[38],
    to_ofday = Core_Time_ns[39],
    reset_date_cache = Core_Time_ns[40],
    convert = Core_Time_ns[41],
    utc_offset = Core_Time_ns[42],
    to_filename_string = Core_Time_ns[43],
    of_filename_string = Core_Time_ns[44],
    to_string_abs = Core_Time_ns[45],
    to_string_abs_trimmed = Core_Time_ns[46],
    to_string_abs_parts = Core_Time_ns[47],
    to_string_trimmed = Core_Time_ns[48],
    to_sec_string = Core_Time_ns[49],
    to_sec_string_with_zone = Core_Time_ns[50],
    of_localized_string = Core_Time_ns[51],
    of_string_gen = Core_Time_ns[52],
    to_string_iso8601_basic = Core_Time_ns[53],
    occurrence = Core_Time_ns[54],
    of_string_with_utc_offset = Core_Time_ns[56],
    to_string_utc = Core_Time_ns[58],
    epoch = Core_Time_ns[59],
    min_value_representable = Core_Time_ns[60],
    max_value_representable = Core_Time_ns[61],
    min_value_for_1us_rounding = Core_Time_ns[62],
    max_value_for_1us_rounding = Core_Time_ns[63],
    min_value = Core_Time_ns[64],
    max_value = Core_Time_ns[65],
    now = Core_Time_ns[66],
    add = Core_Time_ns[67],
    add_saturating = Core_Time_ns[68],
    sub_saturating = Core_Time_ns[69],
    sub = Core_Time_ns[70],
    next = Core_Time_ns[71],
    prev = Core_Time_ns[72],
    diff = Core_Time_ns[73],
    abs_diff = Core_Time_ns[74],
    to_span_since_epoch = Core_Time_ns[75],
    of_span_since_epoch = Core_Time_ns[76],
    to_int63_ns_since_epoch = Core_Time_ns[77],
    of_int63_ns_since_epoch = Core_Time_ns[78],
    to_int_ns_since_epoch = Core_Time_ns[79],
    of_int_ns_since_epoch = Core_Time_ns[80],
    next_multiple = Core_Time_ns[81],
    prev_multiple = Core_Time_ns[82],
    round_up_to_us = Core_Time_ns[83],
    round_up_to_ms = Core_Time_ns[84],
    round_up_to_sec = Core_Time_ns[85],
    round_down_to_us = Core_Time_ns[86],
    round_down_to_ms = Core_Time_ns[87],
    round_down_to_sec = Core_Time_ns[88],
    random = Core_Time_ns[89],
    of_time = Core_Time_ns[90],
    to_time = Core_Time_ns[91],
    to_time_float_round_nearest = Core_Time_ns[92],
    to_time_float_round_nearest_mi = Core_Time_ns[93],
    of_time_float_round_nearest = Core_Time_ns[94],
    of_time_float_round_nearest_mi = Core_Time_ns[95],
    Utc = Core_Time_ns[96],
    O = Core_Time_ns[97],
    cst_Time_t_of_sexp = "Time.t_of_sexp",
    _L_ = [0, [11, "Time.t_of_sexp: ", [2, 0, 0]], "Time.t_of_sexp: %s"],
    cst_Time_ns_unix_Ofday_Option_ =
      "Time_ns_unix.Ofday.Option.value_exn none",
    cst_time_ns_unix_src_time_ns_u$5 =
      "time_ns_unix/src/time_ns_unix.ml:252:29",
    cst_time_ns_unix_src_time_ns_u$3 =
      "time_ns_unix/src/time_ns_unix.ml.Ofday.Zoned.Stable.V1.Bin_repr.t",
    _h_ =
      [0,
       [11, "Ofday.Zoned.of_string ", [2, 0, 0]],
       "Ofday.Zoned.of_string %s"],
    cst_time_ns_unix_src_time_ns_u$0 =
      "time_ns_unix/src/time_ns_unix.ml.Ofday.Zoned.t",
    _b_ = [0, "time_ns_unix/src/time_ns_unix.ml.Time_string_not_absolute"],
    _c_ = [0, "_none_", 0, -1],
    cst_Time_ns_unix_Time_string_n = "Time_ns_unix.Time_string_not_absolute",
    cst_zone = cst_zone$1,
    cst_ofday = cst_ofday$1,
    cst_t = cst_t$23,
    cst_time_ns_unix_src_time_ns_u = "time_ns_unix/src/time_ns_unix.ml:143:4",
    cst_t$0 = cst_t$23,
    cst_t$1 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$1 =
      "time_ns_unix/src/time_ns_unix.ml:176:6",
    cst_t$2 = cst_t$23,
    cst_zone$0 = cst_zone$1,
    cst_ofday$0 = cst_ofday$1,
    cst_t$3 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$2 =
      "time_ns_unix/src/time_ns_unix.ml:191:10",
    cst_t$4 = cst_t$23,
    cst_t$5 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$4 =
      "time_ns_unix/src/time_ns_unix.ml:227:4",
    cst_t$6 = cst_t$23,
    cst_t$7 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$6 =
      "time_ns_unix/src/time_ns_unix.ml:300:10",
    cst_t$8 = cst_t$23,
    cst_t$9 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$7 =
      "time_ns_unix/src/time_ns_unix.ml:313:10",
    cst_t$10 = cst_t$23,
    cst_t$11 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$8 =
      "time_ns_unix/src/time_ns_unix.ml:322:6",
    cst_t$12 = cst_t$23,
    cst_t$13 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$9 =
      "time_ns_unix/src/time_ns_unix.ml:334:6",
    cst_t$14 = cst_t$23,
    cst_t$15 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$10 =
      "time_ns_unix/src/time_ns_unix.ml:389:2",
    cst_t$16 = cst_t$23,
    cst_t$17 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$11 =
      "time_ns_unix/src/time_ns_unix.ml:397:6",
    cst_t$18 = cst_t$23,
    cst_t$19 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$12 =
      "time_ns_unix/src/time_ns_unix.ml:445:4",
    cst_t$20 = cst_t$23,
    cst_t$21 = cst_t$23,
    cst_time_ns_unix_src_time_ns_u$13 =
      "time_ns_unix/src/time_ns_unix.ml:458:4",
    cst_t$22 = cst_t$23,
    cst_time_ns_unix = cst_time_ns_unix$0,
    cst_Time_ns_unix = cst_Time_ns_unix$0;
   function pause_for(t){
    var
     _a$_ = caml_call2(Core_Time_ns[1][105], Core_Time_ns[1][74], 100.),
     t$0 = caml_call2(Core_Time_ns[1][23], t, _a$_),
     _a9_ = caml_call1(Core_Time_ns[1][89], t$0),
     _a__ = caml_call1(Core_unix[155], _a9_),
     time_remaining = caml_call1(Core_Time_ns[1][82], _a__);
    return caml_call2
             (Core_Time_ns[1][18], time_remaining, Core_Time_ns[1][76])
            ? [0, -577460522, time_remaining]
            : 17724;
   }
   function pause(span){
    var span$0 = span;
    for(;;){
     var match = pause_for(span$0);
     if(typeof match === "number") return 0;
     var span$1 = match[2], span$0 = span$1;
    }
   }
   function pause_forever(param){for(;;) pause(Core_Time_ns[1][74]);}
   function to_string(t){
    var _a6_ = Time_float_unix[2][71], _a7_ = caml_obj_tag(_a6_);
    a:
    if(250 === _a7_)
     var _a8_ = _a6_[1];
    else{
     if(246 !== _a7_ && 244 !== _a7_){var _a8_ = _a6_; break a;}
     var _a8_ = caml_call1(CamlinternalLazy[2], _a6_);
    }
    return caml_call2(to_string_abs, t, _a8_);
   }
   var
    Time_string_not_absolute =
      [248, cst_Time_ns_unix_Time_string_n, runtime.caml_fresh_oo_id(0)];
   function _a_(param){
    if(param[1] !== Time_string_not_absolute)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var arg0_001 = param[2], res0_002 = caml_call1(Core[558], arg0_001);
    return [1, [0, _b_, [0, res0_002, 0]]];
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Time_string_not_absolute, _a_);
   function of_string_gen$0(if_no_timezone, s){
    function default_zone(param){
     if(typeof if_no_timezone !== "number"){
      var zone = if_no_timezone[2];
      return zone;
     }
     if(781116926 <= if_no_timezone)
      throw caml_maybe_attach_backtrace([0, Time_string_not_absolute, s], 0);
     var _a4_ = Time_float_unix[2][71], _a5_ = caml_obj_tag(_a4_);
     if(250 === _a5_) return _a4_[1];
     if(246 !== _a5_ && 244 !== _a5_) return _a4_;
     return caml_call1(CamlinternalLazy[2], _a4_);
    }
    return caml_call3(of_string_gen, default_zone, Time_float_unix[2][70], s);
   }
   function of_string_abs(s){return of_string_gen$0(781116926, s);}
   function of_string(s){return of_string_gen$0(203307339, s);}
   var
    arg_type = caml_call3(Core_Command_internal[19][1], 0, 0, of_string_abs);
   function format(t, s, zone){
    var
     match = caml_call2(to_date_ofday, t, zone),
     ofday = match[2],
     date = match[1],
     parts = caml_call1(Ofday[59], ofday),
     _aV_ = caml_call1(Core_Date[54], date),
     _aW_ = caml_call3(Core_Date[48], _aV_, 0, 1),
     _aX_ = caml_call2(Core_Date[64], date, _aW_),
     _aY_ = caml_call1(Core_Date[55], date),
     _aZ_ = caml_call1(Core_Day_of_week[52], _aY_),
     _a0_ = caml_call1(Core_Date[54], date) - 1900 | 0,
     _a1_ = caml_call1(Core_Date[53], date),
     _a2_ = caml_call1(Core_Month[85], _a1_) - 1 | 0,
     _a3_ = caml_call1(Core_Date[52], date);
    return caml_call2
            (Core_unix[151],
             [0,
              parts[4],
              parts[3],
              parts[2],
              _a3_,
              _a2_,
              _a0_,
              _aZ_,
              _aX_,
              0],
             s);
   }
   function parse(allow_trailing_input, s, fmt, zone){
    var
     tm = caml_call3(Core_unix[152], allow_trailing_input, fmt, s),
     tm_year = tm[6],
     tm_mon = tm[5],
     tm_mday = tm[4],
     tm_hour = tm[3],
     tm_min = tm[2],
     tm_sec = tm[1],
     _aU_ = caml_call1(Core_Month[84], tm_mon + 1 | 0),
     date = caml_call3(Core_Date[48], tm_year + 1900 | 0, _aU_, tm_mday),
     ofday =
       caml_call7
        (Ofday[58], [0, tm_hour], [0, tm_min], [0, tm_sec], 0, 0, 0, 0);
    return caml_call3(of_date_ofday, zone, date, ofday);
   }
   var
    include = Core_Time_ns[2],
    bin_size_t$0 = include[1],
    bin_write_t$0 = include[2],
    bin_read_t$1 = include[3],
    bin_read_t$2 = include[4],
    bin_shape_t$0 = include[5],
    bin_writer_t = include[6],
    bin_reader_t = include[7],
    bin_t = include[8],
    ofday_of_sexp = include[9],
    sexp_of_ofday = include[10],
    t_sexp_grammar = include[11],
    typerep_of_t$0 = include[12],
    typename_of_t$0 = include[13],
    symbol = include[14],
    symbol$0 = include[15],
    symbol$1 = include[16],
    symbol$2 = include[17],
    symbol$3 = include[18],
    symbol$4 = include[19],
    equal$0 = include[20],
    compare_ofday = include[21],
    min = include[22],
    max = include[23],
    ascending = include[24],
    descending = include[25],
    between = include[26],
    clamp_exn = include[27],
    clamp = include[28],
    validate_lbound = include[29],
    validate_ubound = include[30],
    validate_bound = include[31],
    comparator = include[33],
    hash_fold_t$0 = include[36],
    hash$0 = include[37],
    hashable = include[38],
    pp = include[43],
    symbol$5 = include[44],
    symbol$6 = include[45],
    symbol$7 = include[46],
    symbol$8 = include[47],
    symbol$9 = include[48],
    symbol$10 = include[49],
    robustly_compare = include[50],
    quickcheck_generator$0 = include[51],
    quickcheck_observer$0 = include[52],
    quickcheck_shrinker$0 = include[53],
    gen_incl$0 = include[54],
    gen_uniform_incl$0 = include[55],
    of_string$0 = include[56],
    to_string$0 = include[57],
    create = include[58],
    to_parts = include[59],
    start_of_day = include[60],
    start_of_next_day = include[61],
    to_span_since_start_of_day = include[62],
    of_span_since_start_of_day_exn = include[63],
    of_span_since_start_of_day = include[64],
    span_since_start_of_day_is_val = include[65],
    of_span_since_start_of_day_unc = include[66],
    add$0 = include[67],
    sub$0 = include[68],
    next$0 = include[69],
    prev$0 = include[70],
    diff$0 = include[71],
    small_diff = include[72],
    to_string_trimmed$0 = include[73],
    to_sec_string$0 = include[74],
    of_string_iso8601_extended = include[75],
    to_millisecond_string = include[76],
    to_millisec_string = include[77],
    approximate_end_of_day = include[78],
    add_exn = include[79],
    sub_exn = include[80],
    every = include[81],
    to_microsecond_string = include[82],
    arg_type$0 = caml_call3(Core_Command_internal[19][1], 0, 0, of_string$0);
   function of_ofday_float_round_nearest_m(core){
    var _aT_ = caml_call1(Time_float_unix[3][63], core);
    return caml_call1
            (of_span_since_start_of_day_exn,
             caml_call1(Core_Time_ns[1][147], _aT_));
   }
   function of_ofday_float_round_nearest(core){
    var _aS_ = caml_call1(Time_float_unix[3][63], core);
    return caml_call1
            (of_span_since_start_of_day_exn,
             caml_call1(Core_Time_ns[1][146], _aS_));
   }
   function to_ofday_float_round_nearest_m(t){
    var
     _aQ_ = caml_call1(to_span_since_start_of_day, t),
     _aR_ = caml_call1(Core_Time_ns[1][145], _aQ_);
    return caml_call1(Time_float_unix[3][64], _aR_);
   }
   function to_ofday_float_round_nearest(t){
    var
     _aO_ = caml_call1(to_span_since_start_of_day, t),
     _aP_ = caml_call1(Core_Time_ns[1][144], _aO_);
    return caml_call1(Time_float_unix[3][64], _aP_);
   }
   function now$0(zone){
    var time = caml_call1(Core_Time_ns[66], 0);
    return caml_call2(to_ofday, time, zone);
   }
   var
    _d_ =
      caml_call1
       (Bin_prot_Shape[4],
        [0,
         [0, cst_ofday, Core_Time_ns[2][5]],
         [0, [0, cst_zone, Time_float_unix[2][31]], 0]]),
    _e_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, _d_], 0],
    _f_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u),
    group = caml_call2(Bin_prot_Shape[2], _f_, _e_),
    _g_ = caml_call1(Bin_shape[2][1], cst_t$0),
    bin_shape_t$1 = caml_call1(caml_call2(Bin_prot_Shape[10], group, _g_), 0);
   function bin_size_t$1(param){
    var
     v2 = param[2],
     v1 = param[1],
     _aM_ = caml_call1(Core_Time_ns[2][1], v1),
     size = caml_call2(Bin_prot_Common[23], 0, _aM_),
     _aN_ = caml_call1(Time_float_unix[2][27], v2);
    return caml_call2(Bin_prot_Common[23], size, _aN_);
   }
   function bin_write_t$1(buf, pos, param){
    var
     v2 = param[2],
     v1 = param[1],
     pos$0 = caml_call3(Core_Time_ns[2][2], buf, pos, v1);
    return caml_call3(Time_float_unix[2][28], buf, pos$0, v2);
   }
   var bin_writer_t$0 = [0, bin_size_t$1, bin_write_t$1];
   function bin_read_t$3(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_time_ns_unix_src_time_ns_u$0,
             pos_ref[1]);
   }
   function bin_read_t$4(buf, pos_ref){
    var
     v_ofday = caml_call2(Core_Time_ns[2][3], buf, pos_ref),
     v_zone = caml_call2(Time_float_unix[2][29], buf, pos_ref);
    return [0, v_ofday, v_zone];
   }
   var
    bin_reader_t$0 = [0, bin_read_t$4, bin_read_t$3],
    bin_t$0 = [0, bin_shape_t$1, bin_writer_t$0, bin_reader_t$0];
   function zone(r){return r[2];}
   function ofday(r){return r[1];}
   function compare$0(a_003, b_004){
    if(a_003 === b_004) return 0;
    var n = caml_call2(Core_Time_ns[2][21], a_003[1], b_004[1]);
    return 0 === n
            ? caml_call2(Time_float_unix[2][47], a_003[2], b_004[2])
            : n;
   }
   function equal$1(a_005, b_006){
    if(a_005 === b_006) return 1;
    var _aL_ = caml_call2(Core_Time_ns[2][20], a_005[1], b_006[1]);
    return _aL_
            ? caml_call2(Time_float_unix[2][46], a_005[2], b_006[2])
            : _aL_;
   }
   function hash_fold_t$1(hsv, arg){
    var hsv$0 = caml_call2(Core_Time_ns[2][36], hsv, arg[1]);
    return caml_call2(Time_float_unix[2][62], hsv$0, arg[2]);
   }
   function hash$1(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _aK_ = hash_fold_t$1(hsv, arg);
    return caml_call1(Base_Hash[9], _aK_);
   }
   function sexp_of_t(t){
    var
     arg1_015 = t[2],
     arg0_014 = t[1],
     res0_016 = caml_call1(Core_Time_ns[2][10], arg0_014),
     res1_017 = caml_call1(Time_float_unix[2][36], arg1_015);
    return [1, [0, res0_016, [0, res1_017, 0]]];
   }
   function t_of_sexp(sexp_012){
    a:
    {
     if(1 === sexp_012[0]){
      var _aI_ = sexp_012[1];
      if(_aI_){
       var _aJ_ = _aI_[2];
       if(_aJ_ && ! _aJ_[2]){
        var
         arg1_009 = _aJ_[1],
         arg0_008 = _aI_[1],
         res0_010 = caml_call1(Core_Time_ns[2][9], arg0_008),
         res1_011 = caml_call1(Time_float_unix[2][35], arg1_009),
         match = [0, res0_010, res1_011];
        break a;
       }
      }
     }
     var
      match =
        caml_call3(Sexplib0_Sexp_conv_error[4], error_source_013, 2, sexp_012);
    }
    var zone = match[2], ofday = match[1];
    return [0, ofday, zone];
   }
   function to_time_ns(t, date){
    return caml_call3(of_date_ofday, t[2], date, t[1]);
   }
   function create$0(ofday, zone){return [0, ofday, zone];}
   function create_local(ofday){
    var _aF_ = Time_float_unix[2][71], _aG_ = caml_obj_tag(_aF_);
    a:
    if(250 === _aG_)
     var _aH_ = _aF_[1];
    else{
     if(246 !== _aG_ && 244 !== _aG_){var _aH_ = _aF_; break a;}
     var _aH_ = caml_call1(CamlinternalLazy[2], _aF_);
    }
    return [0, ofday, _aH_];
   }
   function of_string$1(string){
    var match = caml_call2(Core_String[78], string, 32);
    if(match){
     var _aD_ = match[2];
     if(_aD_ && ! _aD_[2]){
      var
       zone = _aD_[1],
       ofday = match[1],
       _aE_ = caml_call1(Time_float_unix[2][37], zone);
      return [0, caml_call1(Core_Time_ns[2][56], ofday), _aE_];
     }
    }
    return caml_call3(Core[246], _h_, string, 0);
   }
   function to_string$1(t){
    var
     _aB_ = [0, cst, [0, caml_call1(Time_float_unix[2][38], t[2]), 0]],
     _aC_ = [0, caml_call1(Core_Time_ns[2][57], t[1]), _aB_];
    return caml_call2(Core_String[46], 0, _aC_);
   }
   var
    arg_type$1 = caml_call3(Core_Command_internal[19][1], 0, 0, of_string$1),
    _i_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$1), 0, bin_shape_t$1], 0],
    _j_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$1),
    group$0 = caml_call2(Bin_prot_Shape[2], _j_, _i_),
    _k_ = caml_call1(Bin_shape[2][1], cst_t$2),
    bin_shape_t$2 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$0, _k_), 0),
    bin_writer_t$1 = [0, bin_size_t$1, bin_write_t$1],
    bin_reader_t$1 = [0, bin_read_t$4, bin_read_t$3],
    bin_t$1 = [0, bin_shape_t$2, bin_writer_t$1, bin_reader_t$1];
   function hash$2(x){return hash$1(x);}
   var
    include$0 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string$1]),
    pp$0 = include$0[1],
    _l_ =
      caml_call1
       (Bin_prot_Shape[4],
        [0,
         [0, cst_ofday$0, Core_Time_ns[98][5][1][10]],
         [0, [0, cst_zone$0, Timezone[70][1][5]], 0]]),
    _m_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$3), 0, _l_], 0],
    _n_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$2),
    group$1 = caml_call2(Bin_prot_Shape[2], _n_, _m_),
    _o_ = caml_call1(Bin_shape[2][1], cst_t$4),
    bin_shape_t$3 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$1, _o_), 0);
   function bin_size_t$2(param){
    var
     v2 = param[2],
     v1 = param[1],
     _az_ = caml_call1(Core_Time_ns[98][5][1][6], v1),
     size = caml_call2(Bin_prot_Common[23], 0, _az_),
     _aA_ = caml_call1(Timezone[70][1][1], v2);
    return caml_call2(Bin_prot_Common[23], size, _aA_);
   }
   function bin_write_t$2(buf, pos, param){
    var
     v2 = param[2],
     v1 = param[1],
     pos$0 = caml_call3(Core_Time_ns[98][5][1][7], buf, pos, v1);
    return caml_call3(Timezone[70][1][2], buf, pos$0, v2);
   }
   function bin_read_t$5(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_time_ns_unix_src_time_ns_u$3,
             pos_ref[1]);
   }
   function bin_read_t$6(buf, pos_ref){
    var
     v_ofday = caml_call2(Core_Time_ns[98][5][1][8], buf, pos_ref),
     v_zone = caml_call2(Timezone[70][1][3], buf, pos_ref);
    return [0, v_ofday, v_zone];
   }
   var stable_witness = Stable_witness[6];
   function to_binable(t){return [0, t[1], t[2]];}
   function of_binable(repr){return [0, repr[1], repr[2]];}
   var
    include$1 =
      caml_call1
       (caml_call1
         (Core_Binable[6],
          [0,
           bin_shape_t$3,
           bin_size_t$2,
           bin_write_t$2,
           bin_read_t$6,
           bin_read_t$5]),
        [0, to_binable, of_binable]),
    bin_size_t$3 = include$1[1],
    bin_write_t$3 = include$1[2],
    bin_read_t$7 = include$1[3],
    bin_read_t$8 = include$1[4],
    bin_shape_t$4 = include$1[5],
    bin_writer_t$2 = include$1[6],
    bin_reader_t$2 = include$1[7],
    bin_t$2 = include$1[8];
   function hash$3(x){return hash$1(x);}
   function sexp_of_t$0(t){
    var
     arg1_031 = t[2],
     arg0_030 = t[1],
     res0_032 = caml_call1(Core_Time_ns[98][5][1][16], arg0_030),
     res1_033 = caml_call1(Timezone[70][1][14], arg1_031);
    return [1, [0, res0_032, [0, res1_033, 0]]];
   }
   function t_of_sexp$0(sexp_028){
    a:
    {
     if(1 === sexp_028[0]){
      var _ax_ = sexp_028[1];
      if(_ax_){
       var _ay_ = _ax_[2];
       if(_ay_ && ! _ay_[2]){
        var
         arg1_025 = _ay_[1],
         arg0_024 = _ax_[1],
         res0_026 = caml_call1(Core_Time_ns[98][5][1][15], arg0_024),
         res1_027 = caml_call1(Timezone[70][1][13], arg1_025),
         match = [0, res0_026, res1_027];
        break a;
       }
      }
     }
     var
      match =
        caml_call3(Sexplib0_Sexp_conv_error[4], error_source_029, 2, sexp_028);
    }
    var zone = match[2], ofday = match[1];
    return [0, ofday, zone];
   }
   var
    _p_ = Core_Time_ns[1][156][18],
    _q_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$5), 0, _p_], 0],
    _r_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$4),
    group$2 = caml_call2(Bin_prot_Shape[2], _r_, _q_),
    _s_ = caml_call1(Bin_shape[2][1], cst_t$6),
    bin_shape_t$5 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$2, _s_), 0),
    bin_size_t$4 = Core_Time_ns[1][156][14],
    bin_write_t$4 = Core_Time_ns[1][156][15],
    bin_read_t$9 = Core_Time_ns[1][156][17],
    bin_read_t$10 = Core_Time_ns[1][156][16],
    compare$1 = Core_Time_ns[1][156][34],
    equal$2 = Core_Time_ns[1][156][33],
    hash_fold_t$2 = Core_Time_ns[1][156][49],
    func = Core_Time_ns[1][156][50],
    Typename_of_t = caml_call1(Typerep_lib_Make_typename[1], [0, name]),
    typename_of_t$1 = Typename_of_t[2],
    name_of_t = Typename_of_t[1],
    typerep_of_t$1 = [9, [0, name_of_t, [0, Core_Time_ns[1][156][1]]]],
    none = Core_Time_ns[1][156][3];
   function some(t){
    var _aw_ = caml_call1(to_span_since_start_of_day, t);
    return caml_call1(Core_Time_ns[1][156][4], _aw_);
   }
   var is_none = Core_Time_ns[1][156][6], is_some = Core_Time_ns[1][156][7];
   function some_is_representable(t){
    var _av_ = caml_call1(to_span_since_start_of_day, t);
    return caml_call1(Core_Time_ns[1][156][5], _av_);
   }
   function value(t, default$0){
    var
     _au_ =
       caml_call1
        (of_span_since_start_of_day_unc,
         caml_call1(Core_Time_ns[1][156][10], t));
    return runtime.caml_csel_value(caml_call1(is_none, t), default$0, _au_);
   }
   function of_span_since_start_of_day$0(span){
    return caml_call1(span_since_start_of_day_is_val, span)
            ? caml_call1(Core_Time_ns[1][156][4], span)
            : none;
   }
   function value_exn(t){
    if(caml_call1(is_some, t))
     return caml_call1
             (of_span_since_start_of_day_unc,
              caml_call1(Core_Time_ns[1][156][10], t));
    var
     _as_ =
       [0,
        caml_call1(Sexplib0_Sexp_conv[7], cst_Time_ns_unix_Ofday_Option_),
        0],
     _at_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_time_ns_unix_src_time_ns_u$5),
         _as_]];
    return caml_call1(Core[261], _at_);
   }
   function unchecked_value(t){
    return caml_call1
            (of_span_since_start_of_day_unc,
             caml_call1(Core_Time_ns[1][156][10], t));
   }
   function of_option(param){
    if(! param) return none;
    var t = param[1];
    return some(t);
   }
   function to_option(t){
    return caml_call1(is_none, t) ? 0 : [0, value_exn(t)];
   }
   var
    _t_ =
      caml_call2
       (Core_Quickcheck[1][60], Core_Time_ns[2][51], some_is_representable),
    _u_ = caml_call1(Core_Option[64], _t_),
    quickcheck_generator$1 =
      caml_call2(Core_Quickcheck[1][10], _u_, of_option),
    _v_ =
      caml_call2
       (Base_quickcheck_Shrinker[32],
        Core_Time_ns[2][53],
        some_is_representable),
    _w_ = caml_call1(Core_Option[66], _v_),
    quickcheck_shrinker$1 =
      caml_call3(Core_Quickcheck[3][6], _w_, of_option, to_option),
    quickcheck_observer$1 = Core_Time_ns[1][156][57],
    Optional_syntax = [0, is_none, unchecked_value],
    Optional_syntax$0 = [0, Optional_syntax],
    _x_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$7), 0, bin_shape_t$5], 0],
    _y_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$6),
    group$3 = caml_call2(Bin_prot_Shape[2], _y_, _x_),
    _z_ = caml_call1(Bin_shape[2][1], cst_t$8),
    bin_shape_t$6 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$3, _z_), 0),
    bin_writer_t$3 = [0, bin_size_t$4, bin_write_t$4],
    bin_reader_t$3 = [0, bin_read_t$10, bin_read_t$9],
    bin_t$3 = [0, bin_shape_t$6, bin_writer_t$3, bin_reader_t$3],
    stable_witness$0 = Stable_witness[6];
   function sexp_of_t$1(t){
    var x_045 = to_option(t);
    return caml_call2(Core[515], Core_Time_ns[98][5][1][16], x_045);
   }
   function t_of_sexp$1(x_046){
    return of_option(caml_call2(Core[516], Core_Time_ns[98][5][1][15], x_046));
   }
   function to_int63(t){
    return caml_call1(Core_Time_ns[1][156][59][1][14], t);
   }
   function of_int63_exn(t){
    return caml_call1(Core_Time_ns[1][156][59][1][15], t);
   }
   var
    include$2 =
      caml_call1(Core_Comparator[13][1][2], [0, compare$1, sexp_of_t$1]),
    comparator$0 = include$2[1],
    _A_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$9), 0, bin_shape_t$6], 0],
    _B_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$7),
    group$4 = caml_call2(Bin_prot_Shape[2], _B_, _A_),
    _C_ = caml_call1(Bin_shape[2][1], cst_t$10),
    bin_shape_t$7 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$4, _C_), 0),
    bin_writer_t$4 = [0, bin_size_t$4, bin_write_t$4],
    bin_reader_t$4 = [0, bin_read_t$10, bin_read_t$9],
    bin_t$4 = [0, bin_shape_t$7, bin_writer_t$4, bin_reader_t$4],
    include$3 =
      caml_call1
       (Diffable_Atomic[3],
        [0,
         equal$2,
         t_of_sexp$1,
         sexp_of_t$1,
         bin_size_t$4,
         bin_write_t$4,
         bin_read_t$10,
         bin_read_t$9,
         bin_shape_t$7,
         bin_writer_t$4,
         bin_reader_t$4,
         bin_t$4]),
    Diff = include$3[1],
    _D_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$11), 0, bin_shape_t$5], 0],
    _E_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$8),
    group$5 = caml_call2(Bin_prot_Shape[2], _E_, _D_),
    _F_ = caml_call1(Bin_shape[2][1], cst_t$12),
    bin_shape_t$8 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$5, _F_), 0),
    bin_writer_t$5 = [0, bin_size_t$4, bin_write_t$4],
    bin_reader_t$5 = [0, bin_read_t$10, bin_read_t$9],
    bin_t$5 = [0, bin_shape_t$8, bin_writer_t$5, bin_reader_t$5];
   function hash$4(x){return caml_call1(func, x);}
   var
    include$4 = caml_call1(Core_Sexpable[1], [0, t_of_sexp$1, sexp_of_t$1]),
    of_string$2 = include$4[1],
    to_string$2 = include$4[2],
    _G_ =
      caml_call1
       (Core_Identifiable[2],
        [0,
         bin_size_t$4,
         bin_write_t$4,
         bin_read_t$10,
         bin_read_t$9,
         bin_shape_t$8,
         bin_writer_t$5,
         bin_reader_t$5,
         bin_t$5,
         compare$1,
         hash_fold_t$2,
         hash$4,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$2,
         to_string$2,
         module_name$0]),
    bin_size_t$5 = _G_[1],
    bin_write_t$5 = _G_[2],
    bin_read_t$11 = _G_[3],
    bin_read_t$12 = _G_[4],
    bin_shape_t$9 = _G_[5],
    bin_writer_t$6 = _G_[6],
    bin_reader_t$6 = _G_[7],
    bin_t$6 = _G_[8],
    t_of_sexp$2 = _G_[9],
    sexp_of_t$2 = _G_[10],
    of_string$3 = _G_[11],
    to_string$3 = _G_[12],
    pp$1 = _G_[13],
    ascending$0 = _G_[24],
    descending$0 = _G_[25],
    between$0 = _G_[26],
    clamp_exn$0 = _G_[27],
    clamp$0 = _G_[28],
    validate_lbound$0 = _G_[29],
    validate_ubound$0 = _G_[30],
    validate_bound$0 = _G_[31],
    Replace_polymorphic_compare = _G_[32],
    comparator$1 = _G_[33],
    Map = _G_[34],
    Set = _G_[35],
    hash_fold_t$3 = _G_[36],
    hash$5 = _G_[37],
    hashable$0 = _G_[38],
    Table = _G_[39],
    Hash_set = _G_[40],
    Hash_queue = _G_[41],
    _H_ = Core_Time_ns[1][156],
    max$0 = _H_[36],
    min$0 = _H_[35],
    compare$2 = _H_[34],
    equal$3 = _H_[33],
    symbol$11 = _H_[32],
    symbol$12 = _H_[31],
    symbol$13 = _H_[30],
    symbol$14 = _H_[29],
    symbol$15 = _H_[28],
    symbol$16 = _H_[27],
    _I_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$13), 0, bin_shape_t$9], 0],
    _J_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$9),
    group$6 = caml_call2(Bin_prot_Shape[2], _J_, _I_),
    _K_ = caml_call1(Bin_shape[2][1], cst_t$14),
    bin_shape_t$10 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$6, _K_), 0),
    bin_writer_t$7 = [0, bin_size_t$5, bin_write_t$5],
    bin_reader_t$7 = [0, bin_read_t$11, bin_read_t$12],
    bin_t$7 = [0, bin_shape_t$10, bin_writer_t$7, bin_reader_t$7],
    include$5 =
      caml_call1
       (Diffable_Atomic[3],
        [0,
         equal$3,
         t_of_sexp$2,
         sexp_of_t$2,
         bin_size_t$5,
         bin_write_t$5,
         bin_read_t$11,
         bin_read_t$12,
         bin_shape_t$10,
         bin_writer_t$7,
         bin_reader_t$7,
         bin_t$7]),
    Diff$0 = include$5[1],
    get_sexp_zone = Time_float_unix[91],
    set_sexp_zone = Time_float_unix[92];
   function t_of_sexp_gen(if_no_timezone, sexp){
    try{
     a:
     if(0 === sexp[0])
      var
       datetime = sexp[1],
       _ah_ = of_string_gen$0(if_no_timezone, datetime);
     else{
      var _ai_ = sexp[1];
      b:
      if(_ai_){
       var _aj_ = _ai_[1];
       if(0 === _aj_[0]){
        var _ak_ = _ai_[2];
        if(_ak_){
         var _al_ = _ak_[1], date = _aj_[1];
         if(0 === _al_[0]){
          var _am_ = _ak_[2], ofday = _al_[1];
          if(_am_){
           var _an_ = _am_[1];
           if(0 !== _an_[0]) break b;
           if(_am_[2]) break b;
           var
            tz = _an_[1],
            _ao_ = caml_call1(of_string$0, ofday),
            _ap_ = caml_call1(Core_Date[22], date),
            _aq_ =
              caml_call3
               (of_date_ofday,
                caml_call1(Time_float_unix[2][70], tz),
                _ap_,
                _ao_);
          }
          else
           var
            _ar_ = caml_call2(Core[18], cst$0, ofday),
            _aq_ =
              of_string_gen$0
               (if_no_timezone, caml_call2(Core[18], date, _ar_));
          var _ah_ = _aq_;
          break a;
         }
        }
       }
      }
      var _ah_ = caml_call2(Core[154], cst_Time_t_of_sexp, sexp);
     }
     return _ah_;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     if(e[1] === Core[153]) throw caml_maybe_attach_backtrace(e, 0);
     var
      _af_ = caml_call1(Base_Exn[10], e),
      _ag_ = caml_call2(Core[265], _L_, _af_);
     return caml_call2(Core[154], _ag_, sexp);
    }
   }
   function t_of_sexp$3(sexp){
    return t_of_sexp_gen([0, 514999069, caml_call1(get_sexp_zone, 0)], sexp);
   }
   function t_of_sexp_abs(sexp){return t_of_sexp_gen(781116926, sexp);}
   function sexp_of_t_abs(t, zone){
    function _ad_(s){return [0, s];}
    var _ae_ = caml_call2(Core_Time_ns[47], t, zone);
    return [1, caml_call2(Core_List[51], _ae_, _ad_)];
   }
   function sexp_of_t$3(t){
    return sexp_of_t_abs(t, caml_call1(get_sexp_zone, 0));
   }
   function of_date_ofday_zoned(date, ofday_zoned){return to_time_ns(ofday_zoned, date);
   }
   function to_date_ofday_zoned(t, zone){
    var
     match = caml_call2(to_date_ofday, t, zone),
     ofday = match[2],
     date = match[1];
    return [0, date, [0, ofday, zone]];
   }
   function to_ofday_zoned(t, zone){
    var ofday = caml_call2(to_ofday, t, zone);
    return [0, ofday, zone];
   }
   var
    _M_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$15), 0, bin_shape_t], 0],
    _N_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$10),
    group$7 = caml_call2(Bin_prot_Shape[2], _N_, _M_),
    _O_ = caml_call1(Bin_shape[2][1], cst_t$16),
    bin_shape_t$11 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$7, _O_), 0),
    bin_writer_t$8 = [0, bin_size_t, bin_write_t],
    bin_reader_t$8 = [0, bin_read_t, bin_read_t$0],
    bin_t$8 = [0, bin_shape_t$11, bin_writer_t$8, bin_reader_t$8],
    include$6 =
      caml_call1
       (Diffable_Atomic[3],
        [0,
         equal,
         t_of_sexp$3,
         sexp_of_t$3,
         bin_size_t,
         bin_write_t,
         bin_read_t,
         bin_read_t$0,
         bin_shape_t$11,
         bin_writer_t$8,
         bin_reader_t$8,
         bin_t$8]),
    Diff$1 = include$6[1],
    _P_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$17), 0, bin_shape_t], 0],
    _Q_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$11),
    group$8 = caml_call2(Bin_prot_Shape[2], _Q_, _P_),
    _R_ = caml_call1(Bin_shape[2][1], cst_t$18),
    bin_shape_t$12 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$8, _R_), 0),
    bin_writer_t$9 = [0, bin_size_t, bin_write_t],
    bin_reader_t$9 = [0, bin_read_t, bin_read_t$0],
    bin_t$9 = [0, bin_shape_t$12, bin_writer_t$9, bin_reader_t$9];
   function hash$6(x){return caml_call1(hash, x);}
   var stable_witness$1 = Stable_witness[6];
   function of_int63_exn$0(t){
    return caml_call1
            (of_span_since_epoch, caml_call1(Core_Time_ns[1][137], t));
   }
   function to_int63$0(t){return caml_call1(to_int63_ns_since_epoch, t);}
   var
    Comparator =
      caml_call1(Core_Comparator[13][1][2], [0, compare, sexp_of_t$3]),
    comparator$2 = Comparator[1],
    _S_ =
      caml_call1
       (Core_Comparable[26][1][2][1],
        [0,
         stable_witness$1,
         bin_size_t,
         bin_write_t,
         bin_read_t,
         bin_read_t$0,
         bin_shape_t$12,
         bin_writer_t$9,
         bin_reader_t$9,
         bin_t$9,
         compare,
         t_of_sexp$3,
         sexp_of_t$3,
         comparator$2]),
    Map$0 = _S_[1],
    Set$0 = _S_[2],
    include$7 =
      caml_call1
       (Diffable_Atomic[3],
        [0,
         equal,
         t_of_sexp$3,
         sexp_of_t$3,
         bin_size_t,
         bin_write_t,
         bin_read_t,
         bin_read_t$0,
         bin_shape_t$12,
         bin_writer_t$9,
         bin_reader_t$9,
         bin_t$9]),
    Diff$2 = include$7[1],
    include$8 = Core_Time_ns[26],
    bin_size_t$6 = include$8[1],
    bin_write_t$6 = include$8[2],
    bin_read_t$13 = include$8[3],
    bin_read_t$14 = include$8[4],
    bin_shape_t$13 = include$8[5],
    hash_fold_t$4 = include$8[9],
    hash$7 = include$8[10],
    typerep_of_t$2 = include$8[11],
    typename_of_t$2 = include$8[12],
    none$0 = include$8[13],
    some$0 = include$8[14],
    some_is_representable$0 = include$8[15],
    is_none$0 = include$8[16],
    is_some$0 = include$8[17],
    value$0 = include$8[18],
    value_exn$0 = include$8[19],
    unchecked_value$0 = include$8[20],
    to_option$0 = include$8[21],
    of_option$0 = include$8[22],
    Optional_syntax$1 = include$8[23],
    quickcheck_generator$2 = include$8[24],
    quickcheck_observer$2 = include$8[25],
    quickcheck_shrinker$2 = include$8[26],
    Stable = include$8[27],
    compare$3 = include$8[36],
    include$9 = Stable[1],
    compare$4 = include$9[1],
    bin_size_t$7 = include$9[2],
    bin_write_t$7 = include$9[3],
    bin_read_t$15 = include$9[4],
    bin_read_t$16 = include$9[5],
    bin_shape_t$14 = include$9[6],
    bin_writer_t$10 = include$9[7],
    bin_reader_t$10 = include$9[8],
    bin_t$10 = include$9[9],
    stable_witness$2 = include$9[10],
    to_int63$1 = include$9[11],
    of_int63_exn$1 = include$9[12];
   function sexp_of_t$4(t){
    var x_065 = caml_call1(to_option$0, t);
    return caml_call2(Core[515], sexp_of_t$3, x_065);
   }
   function t_of_sexp$4(x_066){
    return caml_call1(of_option$0, caml_call2(Core[516], t_of_sexp$3, x_066));
   }
   var
    comparator$3 =
      caml_call1(Core_Comparator[13][1][2], [0, compare$4, sexp_of_t$4])[1];
   function equal$4(x_067, x_068){
    return 0 === caml_call2(compare$4, x_067, x_068) ? 1 : 0;
   }
   var
    include$10 =
      caml_call1
       (Diffable_Atomic[3],
        [0,
         equal$4,
         t_of_sexp$4,
         sexp_of_t$4,
         bin_size_t$7,
         bin_write_t$7,
         bin_read_t$15,
         bin_read_t$16,
         bin_shape_t$14,
         bin_writer_t$10,
         bin_reader_t$10,
         bin_t$10]),
    Diff$3 = include$10[1],
    _T_ =
      [0, [0, caml_call1(Bin_shape[2][1], cst_t$19), 0, bin_shape_t$13], 0],
    _U_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$12),
    group$9 = caml_call2(Bin_prot_Shape[2], _U_, _T_),
    _V_ = caml_call1(Bin_shape[2][1], cst_t$20),
    bin_shape_t$15 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$9, _V_), 0),
    bin_writer_t$11 = [0, bin_size_t$6, bin_write_t$6],
    bin_reader_t$11 = [0, bin_read_t$13, bin_read_t$14],
    bin_t$11 = [0, bin_shape_t$15, bin_writer_t$11, bin_reader_t$11];
   function hash$8(x){return caml_call1(hash$7, x);}
   var
    include$11 = caml_call1(Core_Sexpable[1], [0, t_of_sexp$4, sexp_of_t$4]),
    of_string$4 = include$11[1],
    to_string$4 = include$11[2],
    _W_ =
      caml_call1
       (Core_Identifiable[2],
        [0,
         bin_size_t$6,
         bin_write_t$6,
         bin_read_t$13,
         bin_read_t$14,
         bin_shape_t$15,
         bin_writer_t$11,
         bin_reader_t$11,
         bin_t$11,
         compare$3,
         hash_fold_t$4,
         hash$8,
         t_of_sexp$4,
         sexp_of_t$4,
         of_string$4,
         to_string$4,
         module_name$1]),
    bin_size_t$8 = _W_[1],
    bin_write_t$8 = _W_[2],
    bin_read_t$17 = _W_[3],
    bin_read_t$18 = _W_[4],
    bin_shape_t$16 = _W_[5],
    bin_writer_t$12 = _W_[6],
    bin_reader_t$12 = _W_[7],
    bin_t$12 = _W_[8],
    t_of_sexp$5 = _W_[9],
    sexp_of_t$5 = _W_[10],
    of_string$5 = _W_[11],
    to_string$5 = _W_[12],
    pp$2 = _W_[13],
    ascending$1 = _W_[24],
    descending$1 = _W_[25],
    between$1 = _W_[26],
    clamp_exn$1 = _W_[27],
    clamp$1 = _W_[28],
    validate_lbound$1 = _W_[29],
    validate_ubound$1 = _W_[30],
    validate_bound$1 = _W_[31],
    Replace_polymorphic_compare$0 = _W_[32],
    comparator$4 = _W_[33],
    Map$1 = _W_[34],
    Set$1 = _W_[35],
    hash_fold_t$5 = _W_[36],
    hash$9 = _W_[37],
    hashable$1 = _W_[38],
    Table$0 = _W_[39],
    Hash_set$0 = _W_[40],
    Hash_queue$0 = _W_[41],
    _X_ = Core_Time_ns[26],
    max$1 = _X_[38],
    min$1 = _X_[37],
    compare$5 = _X_[36],
    equal$5 = _X_[35],
    symbol$17 = _X_[34],
    symbol$18 = _X_[33],
    symbol$19 = _X_[32],
    symbol$20 = _X_[31],
    symbol$21 = _X_[30],
    symbol$22 = _X_[29],
    _Y_ =
      [0, [0, caml_call1(Bin_shape[2][1], cst_t$21), 0, bin_shape_t$16], 0],
    _Z_ = caml_call1(Bin_shape[4][1], cst_time_ns_unix_src_time_ns_u$13),
    group$10 = caml_call2(Bin_prot_Shape[2], _Z_, _Y_),
    ___ = caml_call1(Bin_shape[2][1], cst_t$22),
    bin_shape_t$17 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$10, ___), 0),
    bin_writer_t$13 = [0, bin_size_t$8, bin_write_t$8],
    bin_reader_t$13 = [0, bin_read_t$17, bin_read_t$18],
    bin_t$13 = [0, bin_shape_t$17, bin_writer_t$13, bin_reader_t$13],
    include$12 =
      caml_call1
       (Diffable_Atomic[3],
        [0,
         equal$5,
         t_of_sexp$5,
         sexp_of_t$5,
         bin_size_t$8,
         bin_write_t$8,
         bin_read_t$17,
         bin_read_t$18,
         bin_shape_t$17,
         bin_writer_t$13,
         bin_reader_t$13,
         bin_t$13]),
    Diff$4 = include$12[1];
   function to_string_fix_proto(zone, t){
    var _ac_ = caml_call1(to_time_float_round_nearest_mi, t);
    return caml_call2(Time_float_unix[104], zone, _ac_);
   }
   function of_string_fix_proto(zone, s){
    return caml_call1
            (of_time_float_round_nearest_mi,
             caml_call2(Time_float_unix[105], zone, s));
   }
   var
    _$_ =
      caml_call1
       (Core_Identifiable[5],
        [0,
         bin_size_t,
         bin_write_t,
         bin_read_t,
         bin_read_t$0,
         bin_shape_t$12,
         bin_writer_t$9,
         bin_reader_t$9,
         bin_t$9,
         compare,
         hash_fold_t,
         hash$6,
         t_of_sexp$3,
         sexp_of_t$3,
         comparator$2,
         of_string,
         to_string,
         module_name$2]),
    bin_size_t$9 = _$_[1],
    bin_write_t$9 = _$_[2],
    bin_read_t$19 = _$_[3],
    bin_read_t$20 = _$_[4],
    bin_shape_t$18 = _$_[5],
    bin_writer_t$14 = _$_[6],
    bin_reader_t$14 = _$_[7],
    bin_t$14 = _$_[8],
    t_of_sexp$6 = _$_[9],
    sexp_of_t$6 = _$_[10],
    of_string$6 = _$_[11],
    to_string$6 = _$_[12],
    pp$3 = _$_[13],
    ascending$2 = _$_[24],
    descending$2 = _$_[25],
    between$2 = _$_[26],
    clamp_exn$2 = _$_[27],
    clamp$2 = _$_[28],
    validate_lbound$2 = _$_[29],
    validate_ubound$2 = _$_[30],
    validate_bound$2 = _$_[31],
    Replace_polymorphic_compare$1 = _$_[32],
    comparator$5 = _$_[33],
    Map$2 = _$_[34],
    Set$2 = _$_[35],
    hash_fold_t$6 = _$_[36],
    hash$10 = _$_[37],
    hashable$2 = _$_[38],
    Table$1 = _$_[39],
    Hash_set$1 = _$_[40],
    Hash_queue$1 = _$_[41],
    max$2 = Core_Time_ns[24],
    min$2 = Core_Time_ns[23],
    compare$6 = Core_Time_ns[22],
    equal$6 = Core_Time_ns[21],
    symbol$23 = Core_Time_ns[20],
    symbol$24 = Core_Time_ns[19],
    symbol$25 = Core_Time_ns[18],
    symbol$26 = Core_Time_ns[17],
    symbol$27 = Core_Time_ns[16],
    symbol$28 = Core_Time_ns[15],
    include$13 = Core_Time_ns[1][157],
    V1 = include$13[1],
    V2 = include$13[2],
    include$14 = Core_Time_ns[98][5],
    V1$0 = include$14[1];
   caml_call1(Ppx_inline_test_lib[7], cst_time_ns_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Time_ns_unix);
   var
    _aa_ = Core_Time_ns[98][3][1],
    _ab_ = Core_Time_ns[1],
    Time_ns_unix =
      [0,
       typerep_of_t,
       typename_of_t,
       Alternate_sexp,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       to_string_iso8601_basic,
       occurrence,
       of_string_with_utc_offset,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       round_up_to_us,
       round_up_to_ms,
       round_up_to_sec,
       round_down_to_us,
       round_down_to_ms,
       round_down_to_sec,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       Utc,
       O,
       [0,
        _ab_[1],
        _ab_[2],
        _ab_[3],
        _ab_[4],
        _ab_[5],
        _ab_[6],
        _ab_[7],
        _ab_[8],
        _ab_[9],
        _ab_[10],
        _ab_[11],
        _ab_[12],
        _ab_[13],
        _ab_[14],
        _ab_[15],
        _ab_[16],
        _ab_[17],
        _ab_[18],
        _ab_[19],
        _ab_[20],
        _ab_[21],
        _ab_[22],
        _ab_[23],
        _ab_[24],
        _ab_[25],
        _ab_[26],
        _ab_[27],
        _ab_[28],
        _ab_[29],
        _ab_[30],
        _ab_[31],
        _ab_[32],
        _ab_[33],
        _ab_[34],
        _ab_[35],
        _ab_[36],
        _ab_[37],
        _ab_[38],
        _ab_[39],
        _ab_[40],
        _ab_[41],
        _ab_[42],
        _ab_[43],
        _ab_[44],
        _ab_[45],
        _ab_[46],
        _ab_[47],
        _ab_[48],
        _ab_[49],
        _ab_[50],
        _ab_[51],
        _ab_[52],
        _ab_[53],
        _ab_[54],
        _ab_[55],
        _ab_[56],
        _ab_[57],
        _ab_[58],
        _ab_[59],
        _ab_[60],
        _ab_[61],
        _ab_[62],
        _ab_[63],
        _ab_[64],
        _ab_[65],
        _ab_[66],
        _ab_[67],
        _ab_[68],
        _ab_[69],
        _ab_[70],
        _ab_[71],
        _ab_[72],
        _ab_[73],
        _ab_[74],
        _ab_[75],
        _ab_[76],
        _ab_[77],
        _ab_[78],
        _ab_[79],
        _ab_[80],
        _ab_[81],
        _ab_[82],
        _ab_[83],
        _ab_[84],
        _ab_[85],
        _ab_[86],
        _ab_[87],
        _ab_[88],
        _ab_[89],
        _ab_[90],
        _ab_[91],
        _ab_[92],
        _ab_[93],
        _ab_[94],
        _ab_[95],
        _ab_[96],
        _ab_[97],
        _ab_[98],
        _ab_[99],
        _ab_[100],
        _ab_[101],
        _ab_[102],
        _ab_[103],
        _ab_[104],
        _ab_[105],
        _ab_[106],
        _ab_[107],
        _ab_[108],
        _ab_[109],
        _ab_[110],
        _ab_[111],
        _ab_[112],
        _ab_[113],
        _ab_[114],
        _ab_[115],
        _ab_[116],
        _ab_[117],
        _ab_[118],
        _ab_[119],
        _ab_[120],
        _ab_[121],
        _ab_[122],
        _ab_[123],
        _ab_[124],
        _ab_[125],
        _ab_[126],
        _ab_[127],
        _ab_[128],
        _ab_[129],
        _ab_[130],
        _ab_[131],
        _ab_[132],
        _ab_[133],
        _ab_[134],
        _ab_[135],
        _ab_[136],
        _ab_[137],
        _ab_[138],
        _ab_[139],
        _ab_[140],
        _ab_[141],
        _ab_[142],
        _ab_[143],
        _ab_[144],
        _ab_[145],
        _ab_[146],
        _ab_[147],
        Core_Time_ns_intf[1],
        _ab_[148],
        _ab_[149],
        _ab_[150],
        _ab_[151],
        _ab_[152],
        _ab_[153],
        _ab_[154],
        _ab_[155],
        _ab_[156],
        _ab_[157]],
       arg_type,
       [0,
        typerep_of_t$2,
        typename_of_t$2,
        none$0,
        some$0,
        some_is_representable$0,
        is_none$0,
        is_some$0,
        value$0,
        value_exn$0,
        unchecked_value$0,
        to_option$0,
        of_option$0,
        Optional_syntax$1,
        bin_size_t$8,
        bin_write_t$8,
        bin_read_t$17,
        bin_read_t$18,
        bin_shape_t$16,
        bin_writer_t$12,
        bin_reader_t$12,
        bin_t$12,
        t_of_sexp$5,
        sexp_of_t$5,
        of_string$5,
        to_string$5,
        pp$2,
        symbol$22,
        symbol$21,
        symbol$20,
        symbol$19,
        symbol$18,
        symbol$17,
        equal$5,
        compare$5,
        min$1,
        max$1,
        ascending$1,
        descending$1,
        between$1,
        clamp_exn$1,
        clamp$1,
        validate_lbound$1,
        validate_ubound$1,
        validate_bound$1,
        Replace_polymorphic_compare$0,
        comparator$4,
        Map$1,
        Set$1,
        hash_fold_t$5,
        hash$9,
        hashable$1,
        Table$0,
        Hash_set$0,
        Hash_queue$0,
        quickcheck_generator$2,
        quickcheck_observer$2,
        quickcheck_shrinker$2,
        Diff$4,
        [0,
         [0,
          stable_witness$2,
          bin_size_t$7,
          bin_write_t$7,
          bin_read_t$15,
          bin_read_t$16,
          bin_shape_t$14,
          bin_writer_t$10,
          bin_reader_t$10,
          bin_t$10,
          compare$4,
          t_of_sexp$4,
          sexp_of_t$4,
          comparator$3,
          to_int63$1,
          of_int63_exn$1,
          Diff$3]]],
       [0,
        bin_size_t$0,
        bin_write_t$0,
        bin_read_t$1,
        bin_read_t$2,
        bin_shape_t$0,
        bin_writer_t,
        bin_reader_t,
        bin_t,
        ofday_of_sexp,
        sexp_of_ofday,
        t_sexp_grammar,
        typerep_of_t$0,
        typename_of_t$0,
        symbol,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        equal$0,
        compare_ofday,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        validate_lbound,
        validate_ubound,
        validate_bound,
        comparator,
        hash_fold_t$0,
        hash$0,
        hashable,
        pp,
        symbol$5,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        robustly_compare,
        quickcheck_generator$0,
        quickcheck_observer$0,
        quickcheck_shrinker$0,
        gen_incl$0,
        gen_uniform_incl$0,
        of_string$0,
        to_string$0,
        create,
        to_parts,
        start_of_day,
        start_of_next_day,
        to_span_since_start_of_day,
        of_span_since_start_of_day_exn,
        of_span_since_start_of_day,
        span_since_start_of_day_is_val,
        of_span_since_start_of_day_unc,
        add$0,
        sub$0,
        next$0,
        prev$0,
        diff$0,
        small_diff,
        to_string_trimmed$0,
        to_sec_string$0,
        of_string_iso8601_extended,
        to_millisecond_string,
        to_millisec_string,
        approximate_end_of_day,
        add_exn,
        sub_exn,
        every,
        to_microsecond_string,
        arg_type$0,
        now$0,
        to_ofday_float_round_nearest_m,
        of_ofday_float_round_nearest_m,
        to_ofday_float_round_nearest,
        to_ofday_float_round_nearest_m,
        of_ofday_float_round_nearest,
        of_ofday_float_round_nearest_m,
        [0,
         bin_size_t$1,
         bin_write_t$1,
         bin_read_t$4,
         bin_read_t$3,
         bin_shape_t$1,
         bin_writer_t$0,
         bin_reader_t$0,
         bin_t$0,
         t_of_sexp,
         sexp_of_t,
         hash_fold_t$1,
         hash$1,
         pp$0,
         of_string$1,
         to_string$1,
         arg_type$1,
         create$0,
         create_local,
         ofday,
         zone,
         to_time_ns,
         [0,
          bin_size_t$1,
          bin_write_t$1,
          bin_read_t$4,
          bin_read_t$3,
          bin_shape_t$2,
          bin_writer_t$1,
          bin_reader_t$1,
          bin_t$1,
          t_of_sexp,
          sexp_of_t,
          compare$0,
          equal$1,
          hash_fold_t$1,
          hash$2],
         [0,
          [0,
           hash_fold_t$1,
           hash$3,
           stable_witness,
           bin_size_t$3,
           bin_write_t$3,
           bin_read_t$7,
           bin_read_t$8,
           bin_shape_t$4,
           bin_writer_t$2,
           bin_reader_t$2,
           bin_t$2,
           compare$0,
           t_of_sexp$0,
           sexp_of_t$0]]],
        [0,
         typerep_of_t$1,
         typename_of_t$1,
         none,
         some,
         some_is_representable,
         is_none,
         is_some,
         value,
         value_exn,
         unchecked_value,
         to_option,
         of_option,
         Optional_syntax$0,
         bin_size_t$5,
         bin_write_t$5,
         bin_read_t$11,
         bin_read_t$12,
         bin_shape_t$9,
         bin_writer_t$6,
         bin_reader_t$6,
         bin_t$6,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$3,
         to_string$3,
         pp$1,
         symbol$16,
         symbol$15,
         symbol$14,
         symbol$13,
         symbol$12,
         symbol$11,
         equal$3,
         compare$2,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         validate_lbound$0,
         validate_ubound$0,
         validate_bound$0,
         Replace_polymorphic_compare,
         comparator$1,
         Map,
         Set,
         hash_fold_t$3,
         hash$5,
         hashable$0,
         Table,
         Hash_set,
         Hash_queue,
         quickcheck_generator$1,
         quickcheck_observer$1,
         quickcheck_shrinker$1,
         Diff$0,
         [0,
          [0,
           stable_witness$0,
           bin_size_t$4,
           bin_write_t$4,
           bin_read_t$10,
           bin_read_t$9,
           bin_shape_t$6,
           bin_writer_t$3,
           bin_reader_t$3,
           bin_t$3,
           compare$1,
           t_of_sexp$1,
           sexp_of_t$1,
           comparator$0,
           to_int63,
           of_int63_exn,
           Diff]],
         of_span_since_start_of_day$0]],
       bin_size_t$9,
       bin_write_t$9,
       bin_read_t$19,
       bin_read_t$20,
       bin_shape_t$18,
       bin_writer_t$14,
       bin_reader_t$14,
       bin_t$14,
       t_of_sexp$6,
       sexp_of_t$6,
       of_string$6,
       to_string$6,
       pp$3,
       symbol$28,
       symbol$27,
       symbol$26,
       symbol$25,
       symbol$24,
       symbol$23,
       equal$6,
       compare$6,
       min$2,
       max$2,
       ascending$2,
       descending$2,
       between$2,
       clamp_exn$2,
       clamp$2,
       validate_lbound$2,
       validate_ubound$2,
       validate_bound$2,
       Replace_polymorphic_compare$1,
       comparator$5,
       Map$2,
       Set$2,
       hash_fold_t$6,
       hash$10,
       hashable$2,
       Table$1,
       Hash_set$1,
       Hash_queue$1,
       Diff$1,
       t_sexp_grammar$0,
       Time_float_unix[2],
       get_sexp_zone,
       set_sexp_zone,
       t_of_sexp_abs,
       sexp_of_t_abs,
       of_date_ofday_zoned,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       of_string_fix_proto,
       of_string_abs,
       of_string_gen$0,
       pause,
       pause_for,
       pause_forever,
       format,
       parse,
       [0,
        [0,
         equal,
         hash_fold_t,
         hash$6,
         stable_witness$1,
         bin_size_t,
         bin_write_t,
         bin_read_t,
         bin_read_t$0,
         bin_shape_t$12,
         bin_writer_t$9,
         bin_reader_t$9,
         bin_t$9,
         compare,
         t_of_sexp$3,
         sexp_of_t$3,
         comparator$2,
         to_int63$0,
         of_int63_exn$0,
         Map$0,
         Set$0,
         Diff$2],
        [0,
         [0,
          _aa_[1],
          _aa_[2],
          _aa_[3],
          _aa_[4],
          _aa_[5],
          _aa_[6],
          _aa_[7],
          _aa_[8],
          _aa_[9],
          _aa_[13],
          _aa_[14],
          _aa_[20]]],
        [0,
         [0,
          stable_witness$2,
          bin_size_t$7,
          bin_write_t$7,
          bin_read_t$15,
          bin_read_t$16,
          bin_shape_t$14,
          bin_writer_t$10,
          bin_reader_t$10,
          bin_t$10,
          compare$4,
          t_of_sexp$4,
          sexp_of_t$4,
          comparator$3,
          to_int63$1,
          of_int63_exn$1,
          Diff$3]],
        [0, V1, V2, Core_Time_ns[1][156][59]],
        [0,
         V1$0,
         [0,
          [0,
           hash_fold_t$1,
           hash$3,
           stable_witness,
           bin_size_t$3,
           bin_write_t$3,
           bin_read_t$7,
           bin_read_t$8,
           bin_shape_t$4,
           bin_writer_t$2,
           bin_reader_t$2,
           bin_t$2,
           compare$0,
           t_of_sexp$0,
           sexp_of_t$0]],
         [0,
          [0,
           stable_witness$0,
           bin_size_t$4,
           bin_write_t$4,
           bin_read_t$10,
           bin_read_t$9,
           bin_shape_t$6,
           bin_writer_t$3,
           bin_reader_t$3,
           bin_t$3,
           compare$1,
           t_of_sexp$1,
           sexp_of_t$1,
           comparator$0,
           to_int63,
           of_int63_exn,
           Diff]]]]];
   runtime.caml_register_global(105, Time_ns_unix, cst_Time_ns_unix$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aW1lX25zX3VuaXguY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVycm9yX3NvdXJjZV8wMTMiLCJtb2R1bGVfbmFtZSIsImVycm9yX3NvdXJjZV8wMjkiLCJuYW1lIiwibW9kdWxlX25hbWUkMCIsInRfc2V4cF9ncmFtbWFyJDAiLCJtb2R1bGVfbmFtZSQxIiwibW9kdWxlX25hbWUkMiIsImhhc2hfZm9sZF90IiwiYmluX3NpemVfdCIsImJpbl93cml0ZV90IiwiYmluX3JlYWRfdCIsImJpbl9yZWFkX3QkMCIsImVxdWFsIiwiY29tcGFyZSIsInBhdXNlX2ZvciIsInQiLCJ0JDAiLCJ0aW1lX3JlbWFpbmluZyIsInBhdXNlIiwic3BhbiIsInNwYW4kMCIsInNwYW4kMSIsInBhdXNlX2ZvcmV2ZXIiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmdfZ2VuJDAiLCJpZl9ub190aW1lem9uZSIsInMiLCJkZWZhdWx0X3pvbmUiLCJ6b25lIiwib2Zfc3RyaW5nX2FicyIsIm9mX3N0cmluZyIsImFyZ190eXBlIiwiZm9ybWF0Iiwib2ZkYXkiLCJkYXRlIiwicGFydHMiLCJwYXJzZSIsImFsbG93X3RyYWlsaW5nX2lucHV0IiwiZm10IiwidG0iLCJ0bV95ZWFyIiwidG1fbW9uIiwidG1fbWRheSIsInRtX2hvdXIiLCJ0bV9taW4iLCJ0bV9zZWMiLCJvZmRheV9vZl9zZXhwIiwic2V4cF9vZl9vZmRheSIsImNvbXBhcmVfb2ZkYXkiLCJhcmdfdHlwZSQwIiwib2Zfb2ZkYXlfZmxvYXRfcm91bmRfbmVhcmVzdF9tIiwiY29yZSIsIm9mX29mZGF5X2Zsb2F0X3JvdW5kX25lYXJlc3QiLCJ0b19vZmRheV9mbG9hdF9yb3VuZF9uZWFyZXN0X20iLCJ0b19vZmRheV9mbG9hdF9yb3VuZF9uZWFyZXN0Iiwibm93JDAiLCJ0aW1lIiwiZ3JvdXAiLCJiaW5fc2hhcGVfdCQxIiwiYmluX3NpemVfdCQxIiwidjIiLCJ2MSIsInNpemUiLCJiaW5fd3JpdGVfdCQxIiwiYnVmIiwicG9zIiwicG9zJDAiLCJiaW5fd3JpdGVyX3QkMCIsImJpbl9yZWFkX3QkMyIsInBvc19yZWYiLCJ2aW50IiwiYmluX3JlYWRfdCQ0Iiwidl9vZmRheSIsInZfem9uZSIsImJpbl9yZWFkZXJfdCQwIiwiYmluX3QkMCIsInIiLCJjb21wYXJlJDAiLCJhXzAwMyIsImJfMDA0IiwibiIsImVxdWFsJDEiLCJhXzAwNSIsImJfMDA2IiwiaGFzaF9mb2xkX3QkMSIsImhzdiIsImFyZyIsImhzdiQwIiwiaGFzaCQxIiwic2V4cF9vZl90IiwiYXJnMV8wMTUiLCJhcmcwXzAxNCIsInJlczBfMDE2IiwicmVzMV8wMTciLCJ0X29mX3NleHAiLCJzZXhwXzAxMiIsImFyZzFfMDA5IiwiYXJnMF8wMDgiLCJyZXMwXzAxMCIsInJlczFfMDExIiwidG9fdGltZV9ucyIsImNyZWF0ZSQwIiwiY3JlYXRlX2xvY2FsIiwib2Zfc3RyaW5nJDEiLCJzdHJpbmciLCJ0b19zdHJpbmckMSIsImFyZ190eXBlJDEiLCJncm91cCQwIiwiYmluX3NoYXBlX3QkMiIsImJpbl93cml0ZXJfdCQxIiwiYmluX3JlYWRlcl90JDEiLCJiaW5fdCQxIiwiaGFzaCQyIiwieCIsImdyb3VwJDEiLCJiaW5fc2hhcGVfdCQzIiwiYmluX3NpemVfdCQyIiwiYmluX3dyaXRlX3QkMiIsImJpbl9yZWFkX3QkNSIsImJpbl9yZWFkX3QkNiIsInN0YWJsZV93aXRuZXNzIiwidG9fYmluYWJsZSIsIm9mX2JpbmFibGUiLCJyZXByIiwiaGFzaCQzIiwic2V4cF9vZl90JDAiLCJhcmcxXzAzMSIsImFyZzBfMDMwIiwicmVzMF8wMzIiLCJyZXMxXzAzMyIsInRfb2Zfc2V4cCQwIiwic2V4cF8wMjgiLCJhcmcxXzAyNSIsImFyZzBfMDI0IiwicmVzMF8wMjYiLCJyZXMxXzAyNyIsImdyb3VwJDIiLCJiaW5fc2hhcGVfdCQ1IiwiYmluX3NpemVfdCQ0IiwiYmluX3dyaXRlX3QkNCIsImJpbl9yZWFkX3QkOSIsImJpbl9yZWFkX3QkMTAiLCJjb21wYXJlJDEiLCJlcXVhbCQyIiwiaGFzaF9mb2xkX3QkMiIsImZ1bmMiLCJ0eXBlbmFtZV9vZl90JDEiLCJuYW1lX29mX3QiLCJ0eXBlcmVwX29mX3QkMSIsIm5vbmUiLCJzb21lIiwiaXNfbm9uZSIsImlzX3NvbWUiLCJzb21lX2lzX3JlcHJlc2VudGFibGUiLCJ2YWx1ZSIsImRlZmF1bHQkMCIsIm9mX3NwYW5fc2luY2Vfc3RhcnRfb2ZfZGF5JDAiLCJ2YWx1ZV9leG4iLCJ1bmNoZWNrZWRfdmFsdWUiLCJvZl9vcHRpb24iLCJ0b19vcHRpb24iLCJxdWlja2NoZWNrX2dlbmVyYXRvciQxIiwicXVpY2tjaGVja19zaHJpbmtlciQxIiwicXVpY2tjaGVja19vYnNlcnZlciQxIiwiZ3JvdXAkMyIsImJpbl9zaGFwZV90JDYiLCJiaW5fd3JpdGVyX3QkMyIsImJpbl9yZWFkZXJfdCQzIiwiYmluX3QkMyIsInN0YWJsZV93aXRuZXNzJDAiLCJzZXhwX29mX3QkMSIsInhfMDQ1IiwidF9vZl9zZXhwJDEiLCJ4XzA0NiIsInRvX2ludDYzIiwib2ZfaW50NjNfZXhuIiwiZ3JvdXAkNCIsImJpbl9zaGFwZV90JDciLCJiaW5fd3JpdGVyX3QkNCIsImJpbl9yZWFkZXJfdCQ0IiwiYmluX3QkNCIsImdyb3VwJDUiLCJiaW5fc2hhcGVfdCQ4IiwiYmluX3dyaXRlcl90JDUiLCJiaW5fcmVhZGVyX3QkNSIsImJpbl90JDUiLCJoYXNoJDQiLCJiaW5fc2l6ZV90JDUiLCJiaW5fd3JpdGVfdCQ1IiwiYmluX3JlYWRfdCQxMSIsImJpbl9yZWFkX3QkMTIiLCJ0X29mX3NleHAkMiIsInNleHBfb2ZfdCQyIiwibWF4JDAiLCJtaW4kMCIsImNvbXBhcmUkMiIsImVxdWFsJDMiLCJzeW1ib2wkMTEiLCJzeW1ib2wkMTIiLCJzeW1ib2wkMTMiLCJzeW1ib2wkMTQiLCJzeW1ib2wkMTUiLCJzeW1ib2wkMTYiLCJncm91cCQ2IiwiYmluX3NoYXBlX3QkMTAiLCJiaW5fd3JpdGVyX3QkNyIsImJpbl9yZWFkZXJfdCQ3IiwiYmluX3QkNyIsImdldF9zZXhwX3pvbmUiLCJzZXRfc2V4cF96b25lIiwidF9vZl9zZXhwX2dlbiIsInNleHAiLCJkYXRldGltZSIsInR6IiwiZSQwIiwiZSIsInRfb2Zfc2V4cCQzIiwidF9vZl9zZXhwX2FicyIsInNleHBfb2ZfdF9hYnMiLCJzZXhwX29mX3QkMyIsIm9mX2RhdGVfb2ZkYXlfem9uZWQiLCJvZmRheV96b25lZCIsInRvX2RhdGVfb2ZkYXlfem9uZWQiLCJ0b19vZmRheV96b25lZCIsImdyb3VwJDciLCJiaW5fc2hhcGVfdCQxMSIsImJpbl93cml0ZXJfdCQ4IiwiYmluX3JlYWRlcl90JDgiLCJiaW5fdCQ4IiwiZ3JvdXAkOCIsImJpbl9zaGFwZV90JDEyIiwiYmluX3dyaXRlcl90JDkiLCJiaW5fcmVhZGVyX3QkOSIsImJpbl90JDkiLCJoYXNoJDYiLCJzdGFibGVfd2l0bmVzcyQxIiwib2ZfaW50NjNfZXhuJDAiLCJ0b19pbnQ2MyQwIiwiYmluX3NpemVfdCQ2IiwiYmluX3dyaXRlX3QkNiIsImJpbl9yZWFkX3QkMTMiLCJiaW5fcmVhZF90JDE0IiwiaGFzaF9mb2xkX3QkNCIsImNvbXBhcmUkMyIsInNleHBfb2ZfdCQ0IiwieF8wNjUiLCJ0X29mX3NleHAkNCIsInhfMDY2IiwiZXF1YWwkNCIsInhfMDY3IiwieF8wNjgiLCJncm91cCQ5IiwiYmluX3NoYXBlX3QkMTUiLCJiaW5fd3JpdGVyX3QkMTEiLCJiaW5fcmVhZGVyX3QkMTEiLCJiaW5fdCQxMSIsImhhc2gkOCIsImJpbl9zaXplX3QkOCIsImJpbl93cml0ZV90JDgiLCJiaW5fcmVhZF90JDE3IiwiYmluX3JlYWRfdCQxOCIsInRfb2Zfc2V4cCQ1Iiwic2V4cF9vZl90JDUiLCJtYXgkMSIsIm1pbiQxIiwiY29tcGFyZSQ1IiwiZXF1YWwkNSIsInN5bWJvbCQxNyIsInN5bWJvbCQxOCIsInN5bWJvbCQxOSIsInN5bWJvbCQyMCIsInN5bWJvbCQyMSIsInN5bWJvbCQyMiIsImdyb3VwJDEwIiwiYmluX3NoYXBlX3QkMTciLCJiaW5fd3JpdGVyX3QkMTMiLCJiaW5fcmVhZGVyX3QkMTMiLCJiaW5fdCQxMyIsInRvX3N0cmluZ19maXhfcHJvdG8iLCJvZl9zdHJpbmdfZml4X3Byb3RvIiwibWF4JDIiLCJtaW4kMiIsImNvbXBhcmUkNiIsImVxdWFsJDYiLCJzeW1ib2wkMjMiLCJzeW1ib2wkMjQiLCJzeW1ib2wkMjUiLCJzeW1ib2wkMjYiLCJzeW1ib2wkMjciLCJzeW1ib2wkMjgiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlX3VuaXgvdGltZV9uc191bml4L3RpbWVfbnNfdW5peF9fLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY29yZV91bml4L3RpbWVfbnNfdW5peC90aW1lX25zX3VuaXgubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FLd0I7O0lBQUE7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7O0lDK0lwQkE7O0lBa0NNQztJQTZCRkM7O0lBZUpDO0lBaUdNQztJQXFDTkM7Ozs7O0lBc0ZJQztJQTRCRkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTlFQUM7Ozs7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7O0lBQUFDO0lBQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFsWUZDLFVBQVVDO0lBQ1o7S0FJd0IsT0FBQTtLQVBaQyxNQU9BLGdDQUxBRDtLQUZnQyxPQUFBLGdDQUFoQ0M7S0FBZ0IsT0FBQTtLQUd4QkMsaUJBSHdCO0lBU3pCLE9BQUE7bUNBTkNBOzhCQUFBQTs7R0FNMEU7WUFJeEVDLE1BQU1DO0lBQ1osSUFEWUMsU0FBQUQ7SUFDWjtLQUFNLFlBWkpMLFVBV1VNO21DQUdIO1NBSEdDLG1CQUFBRCxTQUFBQzs7R0FHRDtZQU1MQyxxQkFDTixRQVZNSiwyQkFXVTtZQTJiREssVUF4YkhSO0lBQUk7Ozs7Ozs7O0lBQXNCLE9BQUEsMEJBQTFCQTtHQUFpRDtHQUUvRDs7OztJOzs7Ozs7WUFFSVMsZ0JBQWVDLGdCQUFlQzthQUM1QkM7S0FDRixVQUZlRjtVQUtDRyxPQUxESDtNQUtTLE9BQVJHOztxQkFMREg7TUFHSixNQUFBLDBEQUhtQkM7Ozs7O0lBS0Y7SUFFOUIsT0FBQSwwQkFOSUMsc0NBRDRCRDtHQU9zQjtZQUdwREcsY0FBY0gsR0FBSSxPQVZsQkYsMkJBVWNFLEdBQXlDO1lBMGFyREksVUF6YVFKLEdBQUksT0FYZEYsMkJBV1VFLEdBQTBDO0dBQ3pDO0lBQVhLLFdBQVcsK0NBRlhGO1lBc0JBRyxPQUFRakIsR0FBT1csR0FBR0U7SUFBTztLQWpCVCxRQUFBLDBCQWlCUmIsR0FBVWE7S0FqQlZLO0tBQU5DO0tBQ0FDLFFBQVEsc0JBREZGO0tBYXFDLE9BQUEsMEJBYjNDQztLQWF1QixPQUFBO0tBQWYsT0FBQSwwQkFiUkE7S0FZMkIsT0FBQSwwQkFaM0JBO0tBWVEsT0FBQTtLQVZBLE9BQUEsMEJBRlJBO0tBR29CLE9BQUEsMEJBSHBCQTtLQUdPLE9BQUE7S0FDQyxPQUFBLDBCQUpSQTtJQWlCdUIsT0FBQTs7O2NBaEJ2QkM7Y0FBQUE7Y0FBQUE7Ozs7Ozs7YUFnQmFUO0dBQXlDO1lBMEJ4RFUsTUFBT0Msc0JBQXFCWCxHQUFHWSxLQUFLVjtJQUN0QztLQXpCUVcsS0F5QlIsMkJBRFNGLHNCQUF3QkMsS0FBSFo7S0FyQnZCYyxVQUhDRDtLQUlERSxTQUpDRjtLQUtERyxVQUxDSDtLQU1ESSxVQU5DSjtLQU9ESyxTQVBDTDtLQVFETSxTQVJDTjtLQWtCaUMsT0FBQSwyQkFkbENFO0tBYUhQLE9BQ0YsMEJBZktNLDBCQUVBRTtLQWVIVDtPQUFRO3dCQWRMVSxjQUNBQyxhQUNBQztJQWFQLE9BQUEsMEJBR3NDakIsTUFQbENNLE1BR0FEO0dBS3FEO0dBUzFDOzs7Ozs7Ozs7O0lBc0hiYTtJQUFBQzs7Ozs7Ozs7Ozs7SUFBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF0SEVDLGFBQVc7WUFFWEMsK0JBQXlDQztJQUd0QyxXQUFBLG1DQUhzQ0E7SUFFekMsT0FBQTs7YUFBQTtHQUNnRDtZQUdoREMsNkJBQTZCRDtJQUVLLFdBQUEsbUNBRkxBO0lBRTdCLE9BQUE7O2FBQUE7R0FBK0U7WUFLL0VFLCtCQUF5Q3RDO0lBQzNDO0tBQ2dELE9BQUEsdUNBRkxBO0tBRXpDLE9BQUE7SUFBQSxPQUFBO0dBQTZFO1lBRzdFdUMsNkJBQTZCdkM7SUFDL0I7S0FDb0MsT0FBQSx1Q0FGTEE7S0FFN0IsT0FBQTtJQUFBLE9BQUE7R0FBaUU7WUFHakV3QyxNQUFLM0I7SUFBZSxJQVpaNEIsT0FZWTtJQVpDLE9BQUEscUJBQWJBLE1BWUg1QjtHQUFxQztHQVV2QztJQUFBO01BQUE7Ozs7O0lBQUwsY0FBSztJQUFMLE1BQUE7SUFBQTZCLFFBQUE7SUFBQSxNQUFBO0lBQUtDLGdCQUFMLFdBQUEsK0JBQUFEO1lBaUNFRTtJQWpDRjtLQUFBQztLQUFBQztLQUFBLE9BQUEsK0JBQUFBO0tBQUFDLE9BQUE7S0FBQSxPQUFBLG1DQUFBRjtJQUFBLE9BQUEsZ0NBQUFFO0dBSTBEO1lBNkJ4REMsY0FqQ0ZDLEtBQUFDO0lBQUE7S0FBQUw7S0FBQUM7S0FBQUssUUFBQSwrQkFBQUYsS0FBQUMsS0FBQUo7SUFBQSxPQUFBLG1DQUFBRyxLQUFBRSxPQUFBTjtHQUkwRDtHQUoxRCxJQUFBTyxxQkFpQ0VSLGNBQUFJO1lBQUFLLGFBakNGSixLQUFBSyxTQUFBQztJQUFBOzs7YUFBQUQ7R0FJMEQ7WUE2QnhERSxhQWpDRlAsS0FBQUs7SUFBQTtLQUNJRyxVQUFBLCtCQURKUixLQUFBSztLQUVJSSxTQUFBLG1DQUZKVCxLQUFBSztJQUFBLFdBQ0lHLFNBQ0FDO0dBRXNEO0dBSjFEO0lBQUFDLHFCQWlDRUgsY0FBQUg7SUFqQ0ZPLGNBQUtqQixlQUFMUyxnQkFBQU87WUFFSTlDLEtBQUFnRCxHQUFBLE9BQUFBLEtBQUk7WUFESjNDLE1BQUEyQyxHQUFBLE9BQUFBLEtBQUs7WUE0Q0RDLFVBN0NSQyxPQUFBQztJQUNZLEdBRFpELFVBQUFDLE9BQ1k7SUFBQSxJQUFBQyxJQUFBLGdDQURaRixVQUFBQztpQkFDWUM7aURBRFpGLFVBQUFDO2NBQ1lDO0dBQWU7WUFnQ3pCQyxRQWpDRkMsT0FBQUM7SUFDWSxHQURaRCxVQUFBQyxPQUNZO0lBQUEsV0FBQSxnQ0FEWkQsVUFBQUM7SUFDWTtpREFEWkQsVUFBQUM7O0dBQzJCO1lBZ0V2QkMsY0FqRUpDLEtBQUFDO1FBQUFDLHdDQUFBRixLQUFBQzs4Q0FBQUMsT0FBQUQ7O0dBQUEsU0FBQUUsT0FBQUY7SUFBQSxJQUFBRCw4Q0FpRUlELGNBakVKQyxLQUFBQzs7R0FJMEQ7WUE2QnhERyxVQXpCWTFFO0lBQUk7S0FGRDJFLFdBRUgzRTtLQUZHNEUsV0FFSDVFO0tBRkc2RSwyQ0FBQUQ7S0FBQUUsOENBQUFIO21CQUFBRSxjQUFBQztHQUV3QztZQXlCdkRDLFVBdkJZQztJQUNaOztjQURZQTtpQkFBQUE7Ozs7UUFKRztTQUFBQztTQUFBQztTQUFBQyxXQUFBLCtCQUFBRDtTQUFBRSxXQUFBLG1DQUFBSDtxQkFBQUUsVUFBQUM7Ozs7Ozs7UUFBQSx3Q0FBakJwRyxxQkFJY2dHOztRQUNEbkUsaUJBQVBLO0lBQ0osV0FESUEsT0FBT0w7R0FDSTtZQUdid0UsV0FBV3JGLEdBQUVtQjtJQUFPLE9BQWtDLDBCQUEzQ25CLE1BQUVtQixNQUFGbkI7R0FBb0Q7WUFDL0RzRixTQUFPcEUsT0FBTUwsTUFBTyxXQUFiSyxPQUFNTCxNQUFzQjtZQUNuQzBFLGFBQWFyRTtJQUFROzs7Ozs7OztJQUFhLFdBQXJCQTtHQUE0QztZQUV6RHNFLFlBQVVDO0lBQ04sWUFBQSw0QkFETUE7Ozs7TUFHc0M7T0FEdkM1RTtPQUFQSztPQUM4QyxPQUFBLG1DQUR2Q0w7TUFDVCxXQUFVLGdDQURSSzs7O0lBRUcsT0FBQSwyQkFKS3VFO0dBSXlDO1lBR25EQyxZQUFXMUY7SUFDYjt5QkFBc0QsbUNBRHpDQTtLQUNDLFdBQUUsZ0NBREhBO0lBQ0MsT0FBQTtHQUErRDtHQUdoRTtJQUFYMkYsYUFBVywrQ0FYWEg7SUFjRixjQUFZLHlDQWpDVDdDO0lBaUNILE1BQUE7SUFBQWlELFVBQUE7SUFBQSxNQUFBO0lBQVlDO01BQVosV0FBQSwrQkFBQUQ7SUFBQUUscUJBQUFsRCxjQUFBSTtJQUFBK0MscUJBQUF2QyxjQUFBSDtJQUFBMkMsY0FBWUgsZUFBWkMsZ0JBQUFDO0dBQUEsU0FBQUUsT0FBQUMsR0FBQSxPQWpDRnpCLE9BaUNFeUIsR0FBaUU7R0FlakQ7OzZDQVJaakgsYUFkRnlHOztJQXNCYztNQUFBOzs7OztJQUFaLGNBQVk7SUFBWixNQUFBO0lBQUFTLFVBQUE7SUFBQSxNQUFBO0lBQVlDO01BQVosV0FBQSwrQkFBQUQ7WUFBQUU7SUFBQTtLQUFBeEQ7S0FBQUM7S0FBQSxPQUFBLHNDQUFBQTtLQUFBQyxPQUFBO0tBQUEsT0FBQSwrQkFBQUY7SUFBQSxPQUFBLGdDQUFBRTtHQUltQztZQUpuQ3VELGNBQUFyRCxLQUFBQztJQUFBO0tBQUFMO0tBQUFDO0tBQUFLLFFBQUEsc0NBQUFGLEtBQUFDLEtBQUFKO0lBQUEsT0FBQSwrQkFBQUcsS0FBQUUsT0FBQU47R0FJbUM7WUFKbkMwRCxhQUFBdEQsS0FBQUssU0FBQUM7SUFBQTs7O2FBQUFEO0dBSW1DO1lBSm5Da0QsYUFBQXZELEtBQUFLO0lBQUE7S0FDSUcsVUFBQSxzQ0FESlIsS0FBQUs7S0FFSUksU0FBQSwrQkFGSlQsS0FBQUs7SUFBQSxXQUNJRyxTQUNBQztHQUUrQjtPQWVqQytDO1lBTk1DLFdBQVcxRyxHQUFpQixXQUFqQkEsTUFBQUEsTUFBbUQ7WUFDOUQyRyxXQUFZQyxNQUFxQixXQUFyQkEsU0FBQUEsU0FBZ0Q7Ozs7Ozs7V0FkeERSO1dBQVpDO1dBQUFDO1dBQUFFO1dBQUFEO1lBYVFHLFlBQ0FDOzs7Ozs7Ozs7R0FHVixTQUFBRSxPQUFBWCxHQUFBLE9BakVKekIsT0FpRUl5QixHQUFtQztZQU8vQlksWUFBVTlHO0lBQUk7S0FIRCtHLFdBR0gvRztLQUhHZ0gsV0FHSGhIO0tBSEdpSCxrREFBQUQ7S0FBQUUsMkNBQUFIO21CQUFBRSxjQUFBQztHQUd3QztZQUVyREMsWUFBVUM7SUFDWjs7Y0FEWUE7aUJBQUFBOzs7O1FBTEc7U0FBQUM7U0FBQUM7U0FBQUMsV0FBQSx1Q0FBQUQ7U0FBQUUsV0FBQSxnQ0FBQUg7cUJBQUFFLFVBQUFDOzs7Ozs7O1FBQUEsd0NBQWpCdEkscUJBS2NrSTs7UUFDRHZHLGlCQUFQSztJQUNKLFdBRElBLE9BQU9MO0dBQ007R0FRdkI7O0lBQUEsY0FBSztJQUFMLE1BQUE7SUFBQTRHLFVBQUE7SUFBQSxNQUFBO0lBQUtDO01BQUwsV0FBQSwrQkFBQUQ7SUFzRk1FO0lBQUFDO0lBQUFDO0lBQUFDO0lBYkFDO0lBYUFDO0lBU0pDO0lBL0ZGQztpRUFBQS9JO0lBQUFnSjtJQUFBQztJQUFBQyx5QkFBQUQ7SUFFSUU7WUFDQUMsS0FBS3ZJO0lBQXFCLFdBQUEsdUNBQXJCQTtJQUFxQixPQUFBO0dBQThCO09BQ3hEd0ksbUNBQ0FDO1lBRUFDLHNCQUFzQjFJO0lBQ1UsV0FBQSx1Q0FEVkE7SUFDVSxPQUFBO0dBQThCO1lBRzlEMkksTUFBTTNJLEdBQUc0STtJQUlUOztPQUFBOztTQUFzQyxxQ0FKaEM1STtJQUNSLE9BQUEsd0JBQ0UsV0FUQXdJLFNBT014SSxJQUFHNEk7R0FJNkQ7WUFHdEVDLDZCQUEyQnpJO0lBQzdCLE9BQUcsMkNBRDBCQTtjQUNpQixvQ0FEakJBO2NBaEIzQmtJO0dBaUIyRTtZQUczRVEsVUFBVTlJO0lBQ1osR0FBRyxXQWxCRHlJLFNBaUJVekk7S0FFOEIsT0FBQTs7Y0FBQSxxQ0FGOUJBOzs7Ozs7Ozs7Ozs7R0FHOEQ7WUFHeEUrSSxnQkFBZ0IvSTtJQUNsQixPQUFxQzs7YUFBQSxxQ0FEbkJBO0dBQ2tEO1lBR2xFZ0o7SUFBWSxtQkE5QlpWO1FBZ0NLdEk7SUFBSyxPQS9CVnVJLEtBK0JLdkk7R0FBVztZQUdoQmlKLFVBQVVqSjtJQUFJLE9BQUcsV0FqQ2pCd0ksU0FpQ1V4SSxhQWZWOEksVUFlVTlJO0dBQWtEO0dBU3pEO0lBQUE7TUFBQTtxREF2Q0gwSTtJQXNDQSxNQUFBO0lBSEFRO01BQ0Ysd0NBWEVGO0lBd0JHO01BQUE7OztRQWpESE47SUFnREEsTUFBQTtJQUpBUztNQUNGLHVDQXBCRUgsV0FLQUM7SUF3QkFHO0lBR3VCLHNCQTVEdkJaLFNBd0JBTztJQW1DcUI7SUFVbkIsY0FBWSx5Q0F6RWJyQjtJQXlFQyxNQUFBO0lBQUEyQixVQUFBO0lBQUEsTUFBQTtJQUFZQztNQUFaLFdBQUEsK0JBQUFEO0lBQUFFLHFCQWFBNUIsY0FBQUM7SUFiQTRCLHFCQWFBMUIsZUFBQUQ7SUFiQTRCLGNBQVlILGVBQVpDLGdCQUFBQztJQUVJRTtZQXlCTkMsWUF4QmdCM0o7SUFBaUQsSUFBbEM0SixRQXZDL0JYLFVBdUNnQmpKOzZEQUFlNEo7R0FBK0M7WUF3QjlFQyxZQXZCMENDO0lBQXRCLE9BN0NwQmQsNERBNkMwQ2M7R0FBb0M7WUFDeEVDLFNBQVMvSjtJQUFJLE9BQUEsNENBQUpBO0dBQW9DO1lBQzdDZ0ssYUFBYWhLO0lBQUksT0FBQSw0Q0FBSkE7R0FBd0M7R0FPekQ7O2dEQWJBK0gsV0EyQkY0Qjs7SUFkRSxjQUFZLHlDQWJBTDtJQWFaLE1BQUE7SUFBQVcsVUFBQTtJQUFBLE1BQUE7SUFBWUM7TUFBWixXQUFBLCtCQUFBRDtJQUFBRSxxQkFBQXhDLGNBQUFDO0lBQUF3QyxxQkFBQXRDLGVBQUFEO0lBQUF3QyxjQUFZSCxlQUFaQyxnQkFBQUM7Ozs7O1NBQUFwQztTQWNGNkI7U0FBQUY7U0FkRWhDO1NBQUFDO1NBQUFFO1NBQUFEO1NBQVlxQztTQUFaQztTQUFBQztTQUFBQzs7SUFTSixjQUFZLDBDQS9GVDNDO0lBK0ZILE1BQUE7SUFBQTRDLFVBQUE7SUFBQSxNQUFBO0lBQVlDO01BQVosV0FBQSwrQkFBQUQ7SUFBQUUscUJBVEk3QyxjQUFBQztJQVNKNkMscUJBVEkzQyxlQUFBRDtJQVNKNkMsY0FBWUgsZUFBWkMsZ0JBQUFDO0dBQUEsU0FBQUUsT0EvRkZ6RSxHQStGRSxPQS9GRixXQUFBZ0MsTUFBQWhDLEdBK0Y0RDtHQVkxRDtpREFQRTJELGFBQUFGOzs7Ozs7O1NBZEVoQztTQUFBQztTQUFBRTtTQUFBRDtTQVNRMEM7U0FBWkM7U0FBQUM7U0FBQUM7U0F0QkkzQztTQXNCSkU7U0FBQTBDO1NBS0VkO1NBQUFGOzs7U0FIRXZLO0lBVUp3TDtJQUFBQztJQUFBQztJQUFBQzs7Ozs7SUFBQUM7SUFBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBSHFCQztJQUFBQztJQUFBQztJQUdyQkM7SUFIcUJDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBR3JCLGNBQVk7SUFBWixNQUFBO0lBQUFDLFVBQUE7SUFBQSxNQUFBO0lBQVlDO01BQVosV0FBQSwrQkFBQUQ7SUFBQUUscUJBQUFsQixjQUFBQztJQUFBa0IscUJBQUFqQixlQUFBQztJQUFBaUIsY0FBWUgsZ0JBQVpDLGdCQUFBQzs7Ozs7U0FBQVY7U0FBQUw7U0FBQUM7U0FBQUw7U0FBQUM7U0FBQUM7U0FBQUM7U0FBWWM7U0FBWkM7U0FBQUM7U0FBQUM7O0lBS0ZDO0lBQ0FDO1lBRUFDLGNBQWV6TCxnQkFBZTBMO0lBQ2hDOztjQURnQ0E7O09BU2xCQyxXQVRrQkQ7Y0E5UzlCM0wsZ0JBOFNlQyxnQkFTSDJMOztpQkFUa0JEOzs7Ozs7OzZCQU9Oakw7OzhCQUFnQkQ7Ozs7O1dBSHVCO1lBRE5vTDtZQUNNLE9BQUEsd0JBR3ZCcEw7WUFIQyxPQUFBLDBCQUdqQkM7O2NBSHRCOztnQkFBb0IsbUNBRG1DbUw7Ozs7O1dBS2pCO1lBQUEsT0FBQSw0QkFEQXBMOztjQXJUeENUO2dCQThTZUMsZ0JBUWlCLHFCQURSUzs7Ozs7OztpQkFHakIsMENBVnVCaUw7O0tBU047O1VBSXhCRztTQUFBQyx3QkFBQUQ7UUFBQUMsb0JBRHdCLE1BQUEsNEJBQ3hCQTtLQUFpRDtNQUFBLE9BQUEseUJBQWpEQTtNQUFtQixPQUFBO0tBQWQsT0FBQSw0QkFieUJKOztHQWEwQztZQTBDdEVLLFlBdkNRTDtJQUFPLE9BaEJqQkQsNkJBZ0JtRSxXQW5CbkVGLG9CQW1CVUc7R0FBNEU7WUFDdEZNLGNBQWNOLE1BQU8sT0FqQnJCRCx5QkFpQmNDLE1BQStDO1lBWTdETyxjQUFjM00sR0FBR2E7SUFDbkIsY0FBa0VGLEdBQUssV0FBTEEsR0FBZ0I7SUFBOUQsV0FBQSw2QkFESlgsR0FBR2E7SUFDbkIsV0FBVTtHQUEwRTtZQXlCaEYrTCxZQXRCUTVNO0lBQUksT0FKZDJNLGNBSVUzTSxHQUF3QixXQXBDbENpTTtHQW9Dc0Q7WUFDdERZLG9CQUFvQjFMLE1BQUsyTCxhQUFjLE9BMU5uQ3pILFdBME5xQnlILGFBQUwzTDtHQUEwRDtZQUU5RTRMLG9CQUFvQi9NLEdBQUdhO0lBQ3pCO0tBQWtCLFFBQUEsMEJBREliLEdBQUdhO0tBQ2ZLO0tBQU5DO0lBQ0osV0FESUEsVUFBTUQsT0FEZUw7R0FFVTtZQUdqQ21NLGVBQWVoTixHQUFHYTtJQUNSLElBQVJLLFFBQVEscUJBREtsQixHQUFHYTtJQUVwQixXQURJSyxPQURnQkw7R0FFUztHQUk3QjtJQUFBLGNBQVk7SUFBWixNQUFBO0lBQUFvTSxVQUFBO0lBQUEsTUFBQTtJQUFZQztNQUFaLFdBQUEsK0JBQUFEO0lBQUFFLHFCQVFJMU4sWUFBQUM7SUFSSjBOLHFCQVFJek4sWUFBQUM7SUFSSnlOLGNBQVlILGdCQUFaQyxnQkFBQUM7Ozs7O1NBUUl2TjtTQUFBNE07U0FBQUc7U0FBQW5OO1NBQUFDO1NBQUFDO1NBQUFDO1NBUlFzTjtTQUFaQztTQUFBQztTQUFBQzs7SUFRSSxjQUFZO0lBQVosTUFBQTtJQUFBQyxVQUFBO0lBQUEsTUFBQTtJQUFZQztNQUFaLFdBQUEsK0JBQUFEO0lBQUFFLHFCQUFBL04sWUFBQUM7SUFBQStOLHFCQUFBOU4sWUFBQUM7SUFBQThOLGNBQVlILGdCQUFaQyxnQkFBQUM7R0FBQSxTQUFBRSxPQUFBekgsR0FBQSxPQUFBLGlCQUFBQSxHQUFpRTtPQUU3RDBIO1lBQ0FDLGVBQWE3TjtJQUFJLE9BQW9CO2tDQUFBLGlDQUF4QkE7R0FBNEM7WUFDekQ4TixXQUFTOU4sR0FBSSxPQUFBLG9DQUFKQSxHQUE2Qjs7O2dEQUoxQ0YsU0FBQThNOzs7Ozs7U0FFSWdCO1NBRkpuTztTQUFBQztTQUFBQztTQUFBQztTQUFZMk47U0FBWkM7U0FBQUM7U0FBQUM7U0FBQTVOO1NBQUEyTTtTQUFBRzs7Ozs7Ozs7U0FBQS9NO1NBQUE0TTtTQUFBRztTQUFBbk47U0FBQUM7U0FBQUM7U0FBQUM7U0FBWTJOO1NBQVpDO1NBQUFDO1NBQUFDOzs7SUFnREZLO0lBQUFDO0lBQUFDO0lBQUFDOztJQUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUFBQzs7Ozs7Ozs7Ozs7Ozs7WUFLRUMsWUF4QmdCck87SUFBb0MsSUFBckJzTyxRQUFxQix3QkFBcEN0TztpQ0E3QmhCNE0sYUE2QitCMEI7R0FBa0M7WUF3QmpFQyxZQXZCMENDO0lBQXRCLE9BQVUsOENBOUI5Qi9CLGFBOEIwQytCO0dBQXVCOzs7MkRBdUJqRUg7WUFkTUksUUFBeUJDLE9BQUFDO0ksYUFBQSxzQkFBQUQsT0FBQUM7O0dBU2pDOzs7OztTQVRRRjtTQWNORjtTQUFBRjs7Ozs7Ozs7OztJQUxGO2NBQVk7SUFBWixNQUFBO0lBQUFPLFVBQUE7SUFBQSxNQUFBO0lBQVlDO01BQVosV0FBQSwrQkFBQUQ7SUFBQUUsc0JBQUFmLGNBQUFDO0lBQUFlLHNCQUFBZCxlQUFBQztJQUFBYyxlQUFZSCxnQkFBWkMsaUJBQUFDO0dBQUEsU0FBQUUsT0FBQS9JLEdBQUEsT0FBQSxtQkFBQUEsR0FBMEQ7R0FhMUQ7a0RBUkVxSSxhQUFBRjs7Ozs7OztTQUxGTjtTQUFBQztTQUFBQztTQUFBQztTQUFZVztTQUFaQztTQUFBQztTQUFBQztTQUFBWjtTQUFBRDtTQUFBYztTQUtFVjtTQUFBRjs7O1NBSEUvTztJQVdKNFA7SUFBQUM7SUFBQUM7SUFBQUM7Ozs7O0lBQUFDO0lBQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUh3QkM7SUFBQUM7SUFBQUM7SUFHeEJDO0lBSHdCQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUd4QjtjQUFZO0lBQVosTUFBQTtJQUFBQyxXQUFBO0lBQUEsTUFBQTtJQUFZQztNQUFaLFdBQUEsK0JBQUFEO0lBQUFFLHNCQUFBbEIsY0FBQUM7SUFBQWtCLHNCQUFBakIsZUFBQUM7SUFBQWlCLGVBQVlILGdCQUFaQyxpQkFBQUM7Ozs7O1NBQUFWO1NBQUFMO1NBQUFDO1NBQUFMO1NBQUFDO1NBQUFDO1NBQUFDO1NBQVljO1NBQVpDO1NBQUFDO1NBQUFDOztZQU1BQyxvQkFBb0IxUCxNQUFLYjtJQUNHLFdBQUEsMkNBREhBO0lBQ0csT0FBQSxpQ0FEUmE7R0FDbUQ7WUFHdkUyUCxvQkFBb0IzUCxNQUFLRjtJQUMzQixPQUF3Qzs7YUFBQSxpQ0FEbEJFLE1BQUtGO0dBQzhDOzs7Ozs7U0F4RXJFbEI7U0FBQUM7U0FBQUM7U0FBQUM7U0FBWTJOO1NBQVpDO1NBQUFDO1NBQUFDO1NBQUE1TjtTQUFBTjtTQUFBbU87U0FBQWxCO1NBQUFHOztTQStFQTdMO1NBQVdQO1NBRFhqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFLa0JrUjtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E1YXBCbFE7Ozs7Ozs7Ozs7Ozs7OztRQXNaQWtPO1FBQUFDO1FBQUFDO1FBQUFDOzs7OztRQUFBQztRQUFBQzs7OztRQUh3QlU7UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFHeEJEO1FBSHdCRDtRQUFBRDtRQUFBRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUFMdEJqQjtVQUFBRjs7Ozs7Ozs7Ozs7Ozs7UUFoT0Z0TTtRQUFBQzs7Ozs7Ozs7Ozs7UUFBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUF0SEVDO1FBeUJBTTtRQVZBRjtRQWJBSDtRQWtCQUk7UUFMQUQ7UUFQQUQ7UUFOQUY7O1NBa0VBUztTQUFBSTtTQUFBUTtTQUFBSDtTQWpDR1Y7U0FBTFM7U0FBQU87U0FBQUM7U0FpQ0VtQjtTQUFBTDtTQWdDRUw7U0FqRUpJOztTQW1CSWU7U0FPQUU7U0FJQUM7U0FkQUw7U0FDQUM7U0FoQkFyRTtTQUNBTDtTQWFBd0U7O1VBa0JGekM7VUFBQUk7VUFBQVE7VUFBQUg7VUFBWXdDO1VBQVpDO1VBQUFDO1VBQUFDO1VBQUFqQjtVQUFBTDtVQVlNWjtVQVpOSTtVQWdDRUc7VUFoQ0Y0Qjs7O1dBZ0NFNUI7V0FBQXdDO1dBRUlKOzs7Ozs7Ozs7V0F0QkEzQztXQTZCQXFEO1dBRkFMOztTQVlSdUI7U0FBQUY7U0FFSUc7U0FDQUM7U0FJQUc7U0FIQUY7U0FDQUM7U0FNQUU7U0FXQUc7U0FNQUM7U0FTQUU7U0FMQUQ7O1NBMkVGNEI7U0FBQUM7U0FBQUM7U0FBQUM7Ozs7O1NBQUFDO1NBQUFDOzs7O1NBSHFCVTtTQUFBRDtTQUFBRDtTQUFBRDtTQUFBRDtTQUFBRDtTQUdyQkQ7U0FIcUJEO1NBQUFEO1NBQUFEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBOURuQmhDO1NBbUJBRTtTQVZBRDs7OztXQXdCTU87V0FXSi9CO1dBQUFDO1dBQUFFO1dBQUFEO1dBYll5QjtXQUFaQztXQUFBQztXQUFBQztXQUFBMUI7V0EyQkY4QjtXQUFBRjs7V0F0Qk1JO1dBQ0FDOztTQTdETm5COzs7Ozs7Ozs7Ozs7OztPQTJPZ0JxSTtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F2SHBCcFI7O09BdEJBNE07T0FDQUM7T0FtQkFRO09BWUFDO09BS0FFO09BRUFFO09BS0FDO09BaUZBdUQ7T0FJQUM7T0FsYUExUDtPQVZBTDtPQWxCSU47T0FYSko7T0FvQklRO09BeUNKVTtPQTBCQUk7OztTQTJTRXhCO1NBQUFMO1NBQUFtTztTQUVJQztTQUZKbk87U0FBQUM7U0FBQUM7U0FBQUM7U0FBWTJOO1NBQVpDO1NBQUFDO1NBQUFDO1NBQUE1TjtTQUFBMk07U0FBQUc7O1NBSUlrQjtTQURBRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VBa0RKVTtVQUFBRjs7Ozs7Ozs7OztXQWxQRWhLO1dBQUF3QztXQUVJSjs7Ozs7Ozs7O1dBdEJBM0M7V0E2QkFxRDtXQUZBTDs7O1dBdUZFNEM7V0FXSi9CO1dBQUFDO1dBQUFFO1dBQUFEO1dBYll5QjtXQUFaQztXQUFBQztXQUFBQztXQUFBMUI7V0EyQkY4QjtXQUFBRjs7V0F0Qk1JO1dBQ0FDOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBUaW1lX25zX3VuaXguVGltZV9uc191bml4X2ludGYgKilcbm1vZHVsZSBUaW1lX25zX3VuaXhfaW50ZiA9IFRpbWVfbnNfdW5peF9fVGltZV9uc191bml4X2ludGZcblxubW9kdWxlIFRpbWVfbnNfdW5peF9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbnQuUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5tb2R1bGUgVW5peCA9IENvcmVfdW5peFxubW9kdWxlIFRpbWUgPSBUaW1lX2Zsb2F0X3VuaXhcbmluY2x1ZGUgVGltZV9uc1xubW9kdWxlIFpvbmUgPSBUaW1lLlpvbmVcbm1vZHVsZSBTcGFuID0gVGltZV9ucy5TcGFuXG5cbmxldCBuYW5vc2xlZXAgdCA9IFNwYW4ub2Zfc2VjIChVbml4Lm5hbm9zbGVlcCAoU3Bhbi50b19zZWMgdCkpXG5cbmxldCBwYXVzZV9mb3IgdCA9XG4gIGxldCB0aW1lX3JlbWFpbmluZyA9XG4gICAgKCogSWYgdG9vIGxhcmdlIGEgZmxvYXQgaXMgcGFzc2VkIGluIChTcGFuLm1heF92YWx1ZSBmb3IgaW5zdGFuY2UpIHRoZW4gbmFub3NsZWVwXG4gICAgICAgd2lsbCByZXR1cm4gaW1tZWRpYXRlbHksIGxlYWRpbmcgdG8gYW4gaW5maW5pdGUgYW5kIGV4cGVuc2l2ZSBzZWxlY3QgbG9vcC4gIFRoaXNcbiAgICAgICBpcyBoYW5kbGVkIGJ5IHBhdXNpbmcgZm9yIG5vIGxvbmdlciB0aGFuIDEwMCBkYXlzLiAqKVxuICAgIG5hbm9zbGVlcCAoU3Bhbi5taW4gdCAoU3Bhbi5zY2FsZSBTcGFuLmRheSAxMDAuKSlcbiAgaW5cbiAgaWYgU3Bhbi4oID4gKSB0aW1lX3JlbWFpbmluZyBTcGFuLnplcm8gdGhlbiBgUmVtYWluaW5nIHRpbWVfcmVtYWluaW5nIGVsc2UgYE9rXG47O1xuXG4oKiogUGF1c2UgYW5kIGRvbid0IGFsbG93IGV2ZW50cyB0byBpbnRlcnJ1cHQuICopXG5sZXQgcmVjIHBhdXNlIHNwYW4gPVxuICBtYXRjaCBwYXVzZV9mb3Igc3BhbiB3aXRoXG4gIHwgYFJlbWFpbmluZyBzcGFuIC0+IHBhdXNlIHNwYW5cbiAgfCBgT2sgLT4gKClcbjs7XG5cbigqKiBQYXVzZSBidXQgYWxsb3cgZXZlbnRzIHRvIGludGVycnVwdC4gKilcbmxldCBpbnRlcnJ1cHRpYmxlX3BhdXNlID0gcGF1c2VfZm9yXG5cbmxldCByZWMgcGF1c2VfZm9yZXZlciAoKSA9XG4gIHBhdXNlIFNwYW4uZGF5O1xuICBwYXVzZV9mb3JldmVyICgpXG47O1xuXG5sZXQgdG9fc3RyaW5nIHQgPSB0b19zdHJpbmdfYWJzIHQgfnpvbmU6KExhenkuZm9yY2UgWm9uZS5sb2NhbClcblxuZXhjZXB0aW9uIFRpbWVfc3RyaW5nX25vdF9hYnNvbHV0ZSBvZiBzdHJpbmcgW0BAZGVyaXZpbmcgc2V4cF1cblxubGV0IG9mX3N0cmluZ19nZW4gfmlmX25vX3RpbWV6b25lIHMgPVxuICBsZXQgZGVmYXVsdF96b25lICgpID1cbiAgICBtYXRjaCBpZl9ub190aW1lem9uZSB3aXRoXG4gICAgfCBgRmFpbCAtPiByYWlzZSAoVGltZV9zdHJpbmdfbm90X2Fic29sdXRlIHMpXG4gICAgfCBgTG9jYWwgLT4gTGF6eS5mb3JjZSBab25lLmxvY2FsXG4gICAgfCBgVXNlX3RoaXNfb25lIHpvbmUgLT4gem9uZVxuICBpblxuICBvZl9zdHJpbmdfZ2VuIH5kZWZhdWx0X3pvbmUgfmZpbmRfem9uZTpab25lLmZpbmRfZXhuIHNcbjs7XG5cbmxldCBvZl9zdHJpbmdfYWJzIHMgPSBvZl9zdHJpbmdfZ2VuIH5pZl9ub190aW1lem9uZTpgRmFpbCBzXG5sZXQgb2Zfc3RyaW5nIHMgPSBvZl9zdHJpbmdfZ2VuIH5pZl9ub190aW1lem9uZTpgTG9jYWwgc1xubGV0IGFyZ190eXBlID0gQ29yZS5Db21tYW5kLkFyZ190eXBlLmNyZWF0ZSBvZl9zdHJpbmdfYWJzXG5cbmxldCB0b190bSB0IH56b25lIDogVW5peC50bSA9XG4gIGxldCBkYXRlLCBvZmRheSA9IHRvX2RhdGVfb2ZkYXkgdCB+em9uZSBpblxuICBsZXQgcGFydHMgPSBPZmRheS50b19wYXJ0cyBvZmRheSBpblxuICB7IHRtX3llYXIgPSBEYXRlLnllYXIgZGF0ZSAtIDE5MDBcbiAgOyB0bV9tb24gPSBNb250aC50b19pbnQgKERhdGUubW9udGggZGF0ZSkgLSAxXG4gIDsgdG1fbWRheSA9IERhdGUuZGF5IGRhdGVcbiAgOyB0bV9ob3VyID0gcGFydHMuaHJcbiAgOyB0bV9taW4gPSBwYXJ0cy5taW5cbiAgOyB0bV9zZWMgPSBwYXJ0cy5zZWNcbiAgOyB0bV9pc2RzdCA9XG4gICAgICAoKiBXZSBkb24ndCBrZWVwIHRyYWNrIG9mIFwiRFNUIG9yIG5vdFwiLCBzbyB3ZSB1c2UgYSBkdW1teSB2YWx1ZS4gU2VlIGNhdmVhdCBpblxuICAgICAgICAgaW50ZXJmYWNlIGFib3V0IHRpbWUgem9uZXMgYW5kIERTVC4gKilcbiAgICAgIGZhbHNlXG4gIDsgdG1fd2RheSA9IERheV9vZl93ZWVrLnRvX2ludCAoRGF0ZS5kYXlfb2Zfd2VlayBkYXRlKVxuICA7IHRtX3lkYXkgPSBEYXRlLmRpZmYgZGF0ZSAoRGF0ZS5jcmVhdGVfZXhuIH55OihEYXRlLnllYXIgZGF0ZSkgfm06SmFuIH5kOjEpXG4gIH1cbjs7XG5cbmxldCBmb3JtYXQgKHQgOiB0KSBzIH56b25lID0gVW5peC5zdHJmdGltZSAodG9fdG0gdCB+em9uZSkgc1xuXG5sZXQgb2ZfdG0gdG0gfnpvbmUgPVxuICAoKiBFeHBsaWNpdGx5IGlnbm9yaW5nIGlzZHN0LCB3ZGF5LCB5ZGF5ICh0aGV5IGFyZSByZWR1bmRhbnQgd2l0aCB0aGUgb3RoZXIgZmllbGRzXG4gICAgIGFuZCB0aGUgW3pvbmVdIGFyZ3VtZW50KSAqKVxuICBsZXQgKHsgdG1feWVhclxuICAgICAgIDsgdG1fbW9uXG4gICAgICAgOyB0bV9tZGF5XG4gICAgICAgOyB0bV9ob3VyXG4gICAgICAgOyB0bV9taW5cbiAgICAgICA7IHRtX3NlY1xuICAgICAgIDsgdG1faXNkc3QgPSBfXG4gICAgICAgOyB0bV93ZGF5ID0gX1xuICAgICAgIDsgdG1feWRheSA9IF9cbiAgICAgICB9XG4gICAgICAgIDogVW5peC50bSlcbiAgICA9XG4gICAgdG1cbiAgaW5cbiAgbGV0IGRhdGUgPVxuICAgIERhdGUuY3JlYXRlX2V4biB+eToodG1feWVhciArIDE5MDApIH5tOihNb250aC5vZl9pbnRfZXhuICh0bV9tb24gKyAxKSkgfmQ6dG1fbWRheVxuICBpblxuICBsZXQgb2ZkYXkgPSBPZmRheS5jcmVhdGUgfmhyOnRtX2hvdXIgfm1pbjp0bV9taW4gfnNlYzp0bV9zZWMgKCkgaW5cbiAgb2ZfZGF0ZV9vZmRheSB+em9uZSBkYXRlIG9mZGF5XG47O1xuXG5sZXQgcGFyc2UgP2FsbG93X3RyYWlsaW5nX2lucHV0IHMgfmZtdCB+em9uZSA9XG4gIFVuaXguc3RycHRpbWUgP2FsbG93X3RyYWlsaW5nX2lucHV0IH5mbXQgcyB8PiBvZl90bSB+em9uZVxuOztcblxuKCogRG9lcyBub3QgcmVwcmVzZW50IGV4dHJhIGhvdXJzIGR1ZSB0byBEU1QgKGRheWxpZ2h0IHNhdmluZyB0aW1lKSAoYmVjYXVzZSBEU1QgbWFrZXNcbiAgIGFkanVzdG1lbnRzIGluIHRlcm1zIG9mIHdhbGwgY2xvY2sgdGltZSkgb3IgbGVhcCBzZWNvbmRzICh3aGljaCBhcmVuJ3QgcmVwcmVzZW50ZWQgaW5cbiAgIFVuaXggbGluZWFyIHRpbWUpLiAgU2VlIHshT2ZkYXl9LiAqKVxubW9kdWxlIE9mZGF5ID0gc3RydWN0XG4gIGluY2x1ZGUgVGltZV9ucy5PZmRheVxuXG4gIGxldCBhcmdfdHlwZSA9IENvcmUuQ29tbWFuZC5BcmdfdHlwZS5jcmVhdGUgb2Zfc3RyaW5nXG5cbiAgbGV0IG9mX29mZGF5X2Zsb2F0X3JvdW5kX25lYXJlc3RfbWljcm9zZWNvbmQgY29yZSA9XG4gICAgb2Zfc3Bhbl9zaW5jZV9zdGFydF9vZl9kYXlfZXhuXG4gICAgICAoU3Bhbi5vZl9zcGFuX2Zsb2F0X3JvdW5kX25lYXJlc3RfbWljcm9zZWNvbmRcbiAgICAgICAgIChUaW1lLk9mZGF5LnRvX3NwYW5fc2luY2Vfc3RhcnRfb2ZfZGF5IGNvcmUpKVxuICA7O1xuXG4gIGxldCBvZl9vZmRheV9mbG9hdF9yb3VuZF9uZWFyZXN0IGNvcmUgPVxuICAgIG9mX3NwYW5fc2luY2Vfc3RhcnRfb2ZfZGF5X2V4blxuICAgICAgKFNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0IChUaW1lLk9mZGF5LnRvX3NwYW5fc2luY2Vfc3RhcnRfb2ZfZGF5IGNvcmUpKVxuICA7O1xuXG4gIGxldCBvZl90aW1lIHRpbWUgfnpvbmUgPSB0b19vZmRheSB0aW1lIH56b25lXG5cbiAgbGV0IHRvX29mZGF5X2Zsb2F0X3JvdW5kX25lYXJlc3RfbWljcm9zZWNvbmQgdCA9XG4gICAgVGltZS5PZmRheS5vZl9zcGFuX3NpbmNlX3N0YXJ0X29mX2RheV9leG5cbiAgICAgIChTcGFuLnRvX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdF9taWNyb3NlY29uZCAodG9fc3Bhbl9zaW5jZV9zdGFydF9vZl9kYXkgdCkpXG4gIDs7XG5cbiAgbGV0IHRvX29mZGF5X2Zsb2F0X3JvdW5kX25lYXJlc3QgdCA9XG4gICAgVGltZS5PZmRheS5vZl9zcGFuX3NpbmNlX3N0YXJ0X29mX2RheV9leG5cbiAgICAgIChTcGFuLnRvX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCAodG9fc3Bhbl9zaW5jZV9zdGFydF9vZl9kYXkgdCkpXG4gIDs7XG5cbiAgbGV0IG5vdyB+em9uZSA9IG9mX3RpbWUgKFRpbWVfbnMubm93ICgpKSB+em9uZVxuXG4gICgqIExlZ2FjeSBjb252ZXJzaW9ucyB0aGF0IHJvdW5kIHRvIHRoZSBuZWFyZXN0IG1pY3Jvc2Vjb25kICopXG4gIGxldCB0b19vZmRheSA9IHRvX29mZGF5X2Zsb2F0X3JvdW5kX25lYXJlc3RfbWljcm9zZWNvbmRcbiAgbGV0IG9mX29mZGF5ID0gb2Zfb2ZkYXlfZmxvYXRfcm91bmRfbmVhcmVzdF9taWNyb3NlY29uZFxuXG4gICgqIFRoaXMgbW9kdWxlIGlzIGluIFtUaW1lX25zX3VuaXhdIGluc3RlYWQgb2YgW0NvcmVdIGJlY2F1c2UgdG8gc2V4cCBhIFtab25lLnRdLCB3ZVxuICAgICBuZWVkIHRvIHJlYWQgYSB0aW1lIHpvbmUgZGF0YWJhc2UgdG8gd29yayBvdXQgRFNUIHRyYW5zaXRpb25zLiBXZSBkbyBub3QgaGF2ZSBhXG4gICAgIHBvcnRhYmxlIHdheSB0byBkbyB0aGF0LCBhbmQgY3VycmVudGx5IG9ubHkgc3VwcG9ydCB0aGUgb3BlcmF0aW9uIG9uIFVuaXguICopXG4gIG1vZHVsZSBab25lZCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB7IG9mZGF5IDogVGltZV9ucy5PZmRheS50XG4gICAgICA7IHpvbmUgOiBab25lLnRcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBiaW5faW8sIGZpZWxkcyB+Z2V0dGVycywgY29tcGFyZSwgZXF1YWwsIGhhc2hdXG5cbiAgICB0eXBlIHNleHBfcmVwciA9IFRpbWVfbnMuT2ZkYXkudCAqIFpvbmUudCBbQEBkZXJpdmluZyBzZXhwXVxuXG4gICAgbGV0IHNleHBfb2ZfdCB0ID0gWyVzZXhwX29mOiBzZXhwX3JlcHJdICh0Lm9mZGF5LCB0LnpvbmUpXG5cbiAgICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgICAgbGV0IG9mZGF5LCB6b25lID0gWyVvZl9zZXhwOiBzZXhwX3JlcHJdIHNleHAgaW5cbiAgICAgIHsgb2ZkYXk7IHpvbmUgfVxuICAgIDs7XG5cbiAgICBsZXQgdG9fdGltZV9ucyB0IGRhdGUgPSBvZl9kYXRlX29mZGF5IH56b25lOih6b25lIHQpIGRhdGUgKG9mZGF5IHQpXG4gICAgbGV0IGNyZWF0ZSBvZmRheSB6b25lID0geyBvZmRheTsgem9uZSB9XG4gICAgbGV0IGNyZWF0ZV9sb2NhbCBvZmRheSA9IGNyZWF0ZSBvZmRheSAoTGF6eS5mb3JjZSBab25lLmxvY2FsKVxuXG4gICAgbGV0IG9mX3N0cmluZyBzdHJpbmcgOiB0ID1cbiAgICAgIG1hdGNoIFN0cmluZy5zcGxpdCBzdHJpbmcgfm9uOicgJyB3aXRoXG4gICAgICB8IFsgb2ZkYXk7IHpvbmUgXSAtPlxuICAgICAgICB7IG9mZGF5ID0gVGltZV9ucy5PZmRheS5vZl9zdHJpbmcgb2ZkYXk7IHpvbmUgPSBab25lLm9mX3N0cmluZyB6b25lIH1cbiAgICAgIHwgXyAtPiBmYWlsd2l0aGYgXCJPZmRheS5ab25lZC5vZl9zdHJpbmcgJXNcIiBzdHJpbmcgKClcbiAgICA7O1xuXG4gICAgbGV0IHRvX3N0cmluZyAodCA6IHQpIDogc3RyaW5nID1cbiAgICAgIFN0cmluZy5jb25jYXQgWyBUaW1lX25zLk9mZGF5LnRvX3N0cmluZyB0Lm9mZGF5OyBcIiBcIjsgWm9uZS50b19zdHJpbmcgdC56b25lIF1cbiAgICA7O1xuXG4gICAgbGV0IGFyZ190eXBlID0gQ29yZS5Db21tYW5kLkFyZ190eXBlLmNyZWF0ZSBvZl9zdHJpbmdcblxuICAgIG1vZHVsZSBXaXRoX25vbmNocm9ub2xvZ2ljYWxfY29tcGFyZSA9IHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgYmluX2lvLCBjb21wYXJlLCBlcXVhbCwgc2V4cCwgaGFzaF1cbiAgICBlbmRcblxuICAgIGluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgICAgbGV0IG1vZHVsZV9uYW1lID0gXCJUaW1lX25zX3VuaXguT2ZkYXkuWm9uZWRcIlxuICAgIGVuZClcblxuICAgIG1vZHVsZSBTdGFibGUgPSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBWMSA9IHN0cnVjdFxuICAgICAgICBsZXQgY29tcGFyZSA9IFdpdGhfbm9uY2hyb25vbG9naWNhbF9jb21wYXJlLmNvbXBhcmVcblxuICAgICAgICBtb2R1bGUgQmluX3JlcHIgPSBzdHJ1Y3RcbiAgICAgICAgICB0eXBlIG5vbnJlYyB0ID0gdCA9XG4gICAgICAgICAgICB7IG9mZGF5IDogVGltZV9ucy5TdGFibGUuT2ZkYXkuVjEudFxuICAgICAgICAgICAgOyB6b25lIDogVGltZXpvbmUuU3RhYmxlLlYxLnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBbQEBkZXJpdmluZyBiaW5faW8sIHN0YWJsZV93aXRuZXNzXVxuICAgICAgICBlbmRcblxuICAgICAgICBpbmNsdWRlXG4gICAgICAgICAgQmluYWJsZS5PZl9iaW5hYmxlX3dpdGhvdXRfdXVpZCBbQGFsZXJ0IFwiLWxlZ2FjeVwiXVxuICAgICAgICAgICAgKEJpbl9yZXByKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICAgICAgICAgIGxldCB0b19iaW5hYmxlIHQgOiBCaW5fcmVwci50ID0geyBvZmRheSA9IG9mZGF5IHQ7IHpvbmUgPSB6b25lIHQgfVxuICAgICAgICAgICAgICBsZXQgb2ZfYmluYWJsZSAocmVwciA6IEJpbl9yZXByLnQpID0gY3JlYXRlIHJlcHIub2ZkYXkgcmVwci56b25lXG4gICAgICAgICAgICBlbmQpXG5cbiAgICAgICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgaGFzaF1cblxuICAgICAgICBsZXQgc3RhYmxlX3dpdG5lc3MgOiB0IFN0YWJsZV93aXRuZXNzLnQgPSBCaW5fcmVwci5zdGFibGVfd2l0bmVzc1xuXG4gICAgICAgIHR5cGUgc2V4cF9yZXByID0gVGltZV9ucy5TdGFibGUuT2ZkYXkuVjEudCAqIFRpbWV6b25lLlN0YWJsZS5WMS50XG4gICAgICAgIFtAQGRlcml2aW5nIHNleHBdXG5cbiAgICAgICAgbGV0IHNleHBfb2ZfdCB0ID0gWyVzZXhwX29mOiBzZXhwX3JlcHJdIChvZmRheSB0LCB6b25lIHQpXG5cbiAgICAgICAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICAgICAgICBsZXQgb2ZkYXksIHpvbmUgPSBbJW9mX3NleHA6IHNleHBfcmVwcl0gc2V4cCBpblxuICAgICAgICAgIGNyZWF0ZSBvZmRheSB6b25lXG4gICAgICAgIDs7XG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIE9wdGlvbiA9IHN0cnVjdFxuICAgIHR5cGUgb2ZkYXkgPSB0IFtAQGRlcml2aW5nIHNleHAsIGNvbXBhcmVdXG4gICAgdHlwZSB0ID0gU3Bhbi5PcHRpb24udCBbQEBkZXJpdmluZyBiaW5faW8sIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCB0eXBlcmVwXVxuXG4gICAgbGV0IG5vbmUgPSBTcGFuLk9wdGlvbi5ub25lXG4gICAgbGV0IHNvbWUgdCA9IFNwYW4uT3B0aW9uLnNvbWUgKHRvX3NwYW5fc2luY2Vfc3RhcnRfb2ZfZGF5IHQpXG4gICAgbGV0IGlzX25vbmUgPSBTcGFuLk9wdGlvbi5pc19ub25lXG4gICAgbGV0IGlzX3NvbWUgPSBTcGFuLk9wdGlvbi5pc19zb21lXG5cbiAgICBsZXQgc29tZV9pc19yZXByZXNlbnRhYmxlIHQgPVxuICAgICAgU3Bhbi5PcHRpb24uc29tZV9pc19yZXByZXNlbnRhYmxlICh0b19zcGFuX3NpbmNlX3N0YXJ0X29mX2RheSB0KVxuICAgIDs7XG5cbiAgICBsZXQgdmFsdWUgdCB+ZGVmYXVsdCA9XG4gICAgICBCb29sLnNlbGVjdFxuICAgICAgICAoaXNfbm9uZSB0KVxuICAgICAgICBkZWZhdWx0XG4gICAgICAgIChvZl9zcGFuX3NpbmNlX3N0YXJ0X29mX2RheV91bmNoZWNrZWQgKFNwYW4uT3B0aW9uLnVuY2hlY2tlZF92YWx1ZSB0KSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3NwYW5fc2luY2Vfc3RhcnRfb2ZfZGF5IHNwYW4gPVxuICAgICAgaWYgc3Bhbl9zaW5jZV9zdGFydF9vZl9kYXlfaXNfdmFsaWQgc3BhbiB0aGVuIFNwYW4uT3B0aW9uLnNvbWUgc3BhbiBlbHNlIG5vbmVcbiAgICA7O1xuXG4gICAgbGV0IHZhbHVlX2V4biB0ID1cbiAgICAgIGlmIGlzX3NvbWUgdFxuICAgICAgdGhlbiBvZl9zcGFuX3NpbmNlX3N0YXJ0X29mX2RheV91bmNoZWNrZWQgKFNwYW4uT3B0aW9uLnVuY2hlY2tlZF92YWx1ZSB0KVxuICAgICAgZWxzZSByYWlzZV9zIFslbWVzc2FnZSBbJWhlcmVdIFwiVGltZV9uc191bml4Lk9mZGF5Lk9wdGlvbi52YWx1ZV9leG4gbm9uZVwiXVxuICAgIDs7XG5cbiAgICBsZXQgdW5jaGVja2VkX3ZhbHVlIHQgPVxuICAgICAgb2Zfc3Bhbl9zaW5jZV9zdGFydF9vZl9kYXlfdW5jaGVja2VkIChTcGFuLk9wdGlvbi51bmNoZWNrZWRfdmFsdWUgdClcbiAgICA7O1xuXG4gICAgbGV0IG9mX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gbm9uZVxuICAgICAgfCBTb21lIHQgLT4gc29tZSB0XG4gICAgOztcblxuICAgIGxldCB0b19vcHRpb24gdCA9IGlmIGlzX25vbmUgdCB0aGVuIE5vbmUgZWxzZSBTb21lICh2YWx1ZV9leG4gdClcblxuICAgICgqIENhbid0IHVzZSB0aGUgcXVpY2tjaGVjayBnZW5lcmF0b3IgYW5kIHNocmlua2VyIGluaGVyaXRlZCBmcm9tIFtTcGFuLk9wdGlvbl1cbiAgICAgICBiZWNhdXNlIHRoZXkgbWF5IHByb2R1Y2Ugc3BhbnMgd2hvc2UgcmVwcmVzZW50YXRpb24gaXMgbGFyZ2VyIHRoYW5cbiAgICAgICBbc3RhcnRfb2ZfbmV4dF9kYXldICopXG4gICAgbGV0IHF1aWNrY2hlY2tfZ2VuZXJhdG9yIDogdCBRdWlja2NoZWNrLkdlbmVyYXRvci50ID1cbiAgICAgIFF1aWNrY2hlY2suR2VuZXJhdG9yLm1hcFxuICAgICAgICB+ZjpvZl9vcHRpb25cbiAgICAgICAgKENvcmUuT3B0aW9uLnF1aWNrY2hlY2tfZ2VuZXJhdG9yXG4gICAgICAgICAgIChRdWlja2NoZWNrLkdlbmVyYXRvci5maWx0ZXJcbiAgICAgICAgICAgICAgfmY6c29tZV9pc19yZXByZXNlbnRhYmxlXG4gICAgICAgICAgICAgIFRpbWVfbnMuT2ZkYXkucXVpY2tjaGVja19nZW5lcmF0b3IpKVxuICAgIDs7XG5cbiAgICBsZXQgcXVpY2tjaGVja19zaHJpbmtlciA6IHQgUXVpY2tjaGVjay5TaHJpbmtlci50ID1cbiAgICAgIFF1aWNrY2hlY2suU2hyaW5rZXIubWFwXG4gICAgICAgIH5mOm9mX29wdGlvblxuICAgICAgICB+Zl9pbnZlcnNlOnRvX29wdGlvblxuICAgICAgICAoQ29yZS5PcHRpb24ucXVpY2tjaGVja19zaHJpbmtlclxuICAgICAgICAgICAoQmFzZV9xdWlja2NoZWNrLlNocmlua2VyLmZpbHRlclxuICAgICAgICAgICAgICB+Zjpzb21lX2lzX3JlcHJlc2VudGFibGVcbiAgICAgICAgICAgICAgVGltZV9ucy5PZmRheS5xdWlja2NoZWNrX3Nocmlua2VyKSlcbiAgICA7O1xuXG4gICAgbGV0IHF1aWNrY2hlY2tfb2JzZXJ2ZXIgPSBTcGFuLk9wdGlvbi5xdWlja2NoZWNrX29ic2VydmVyXG5cbiAgICBtb2R1bGUgT3B0aW9uYWxfc3ludGF4ID0gc3RydWN0XG4gICAgICBtb2R1bGUgT3B0aW9uYWxfc3ludGF4ID0gc3RydWN0XG4gICAgICAgIGxldCBpc19ub25lID0gaXNfbm9uZVxuICAgICAgICBsZXQgdW5zYWZlX3ZhbHVlID0gdW5jaGVja2VkX3ZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG1vZHVsZSBTdGFibGUgPSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBWMSA9IHN0cnVjdFxuICAgICAgICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgICAgICAgIHR5cGUgbm9ucmVjIHQgPSB0IFtAQGRlcml2aW5nIGNvbXBhcmUsIGVxdWFsLCBiaW5faW9dXG5cbiAgICAgICAgICBsZXQgc3RhYmxlX3dpdG5lc3MgOiB0IFN0YWJsZV93aXRuZXNzLnQgPSBTdGFibGVfd2l0bmVzcy5hc3NlcnRfc3RhYmxlXG4gICAgICAgICAgbGV0IHNleHBfb2ZfdCB0ID0gWyVzZXhwX29mOiBUaW1lX25zLlN0YWJsZS5PZmRheS5WMS50IG9wdGlvbl0gKHRvX29wdGlvbiB0KVxuICAgICAgICAgIGxldCB0X29mX3NleHAgcyA9IG9mX29wdGlvbiAoWyVvZl9zZXhwOiBUaW1lX25zLlN0YWJsZS5PZmRheS5WMS50IG9wdGlvbl0gcylcbiAgICAgICAgICBsZXQgdG9faW50NjMgdCA9IFNwYW4uT3B0aW9uLlN0YWJsZS5WMS50b19pbnQ2MyB0XG4gICAgICAgICAgbGV0IG9mX2ludDYzX2V4biB0ID0gU3Bhbi5PcHRpb24uU3RhYmxlLlYxLm9mX2ludDYzX2V4biB0XG4gICAgICAgIGVuZFxuXG4gICAgICAgIGluY2x1ZGUgVFxuICAgICAgICBpbmNsdWRlIENvbXBhcmF0b3IuU3RhYmxlLlYxLk1ha2UgKFQpXG5cbiAgICAgICAgaW5jbHVkZSBEaWZmYWJsZS5BdG9taWMuTWFrZSAoc3RydWN0XG4gICAgICAgICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgc2V4cCwgYmluX2lvLCBlcXVhbF1cbiAgICAgICAgZW5kKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBsZXQgc2V4cF9vZl90ID0gU3RhYmxlLlYxLnNleHBfb2ZfdFxuICAgIGxldCB0X29mX3NleHAgPSBTdGFibGUuVjEudF9vZl9zZXhwXG5cbiAgICBpbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0IFtAQGRlcml2aW5nIHNleHAsIGNvbXBhcmUsIGJpbl9pbywgaGFzaF1cblxuICAgICAgbGV0IG1vZHVsZV9uYW1lID0gXCJUaW1lX25zX3VuaXguT2ZkYXkuT3B0aW9uXCJcblxuICAgICAgaW5jbHVkZSBTZXhwYWJsZS5Ub19zdHJpbmdhYmxlIChzdHJ1Y3RcbiAgICAgICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgc2V4cF1cbiAgICAgIGVuZClcbiAgICBlbmQpXG5cbiAgICBpbmNsdWRlIChTcGFuLk9wdGlvbiA6IENvcmUuQ29tcGFyaXNvbnMuUyB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gICAgaW5jbHVkZSBEaWZmYWJsZS5BdG9taWMuTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdCBbQEBkZXJpdmluZyBzZXhwLCBiaW5faW8sIGVxdWFsXVxuICAgIGVuZClcbiAgZW5kXG5lbmRcblxubGV0IGdldF9zZXhwX3pvbmUgPSBUaW1lLmdldF9zZXhwX3pvbmVcbmxldCBzZXRfc2V4cF96b25lID0gVGltZS5zZXRfc2V4cF96b25lXG5cbmxldCB0X29mX3NleHBfZ2VuIH5pZl9ub190aW1lem9uZSBzZXhwID1cbiAgdHJ5XG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkxpc3QgWyBTZXhwLkF0b20gZGF0ZTsgU2V4cC5BdG9tIG9mZGF5OyBTZXhwLkF0b20gdHogXSAtPlxuICAgICAgb2ZfZGF0ZV9vZmRheSB+em9uZTooWm9uZS5maW5kX2V4biB0eikgKERhdGUub2Zfc3RyaW5nIGRhdGUpIChPZmRheS5vZl9zdHJpbmcgb2ZkYXkpXG4gICAgKCogVGhpcyBpcyBhY3R1YWxseSB3aGVyZSB0aGUgb3V0cHV0IG9mIFtzZXhwX29mX3RdIGlzIGhhbmRsZWQsIHNpbmNlIHRoYXQncyBlLmcuXG4gICAgICAgKDIwMTUtMDctMDYgMDk6MDk6NDQuNzg3OTg4KzAxOjAwKS4gKilcbiAgICB8IFNleHAuTGlzdCBbIFNleHAuQXRvbSBkYXRlOyBTZXhwLkF0b20gb2ZkYXlfYW5kX3Bvc3NpYmx5X3pvbmUgXSAtPlxuICAgICAgb2Zfc3RyaW5nX2dlbiB+aWZfbm9fdGltZXpvbmUgKGRhdGUgXiBcIiBcIiBeIG9mZGF5X2FuZF9wb3NzaWJseV96b25lKVxuICAgIHwgU2V4cC5BdG9tIGRhdGV0aW1lIC0+IG9mX3N0cmluZ19nZW4gfmlmX25vX3RpbWV6b25lIGRhdGV0aW1lXG4gICAgfCBfIC0+IG9mX3NleHBfZXJyb3IgXCJUaW1lLnRfb2Zfc2V4cFwiIHNleHBcbiAgd2l0aFxuICB8IE9mX3NleHBfZXJyb3IgXyBhcyBlIC0+IHJhaXNlIGVcbiAgfCBlIC0+IG9mX3NleHBfZXJyb3IgKHNwcmludGYgXCJUaW1lLnRfb2Zfc2V4cDogJXNcIiAoRXhuLnRvX3N0cmluZyBlKSkgc2V4cFxuOztcblxubGV0IHRfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwX2dlbiBzZXhwIH5pZl9ub190aW1lem9uZTooYFVzZV90aGlzX29uZSAoZ2V0X3NleHBfem9uZSAoKSkpXG5sZXQgdF9vZl9zZXhwX2FicyBzZXhwID0gdF9vZl9zZXhwX2dlbiBzZXhwIH5pZl9ub190aW1lem9uZTpgRmFpbFxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIuU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPVxuICAgICAgVW5pb25cbiAgICAgICAgWyBTdHJpbmdcbiAgICAgICAgOyBMaXN0IChDb25zIChTdHJpbmcsIENvbnMgKFN0cmluZywgRW1wdHkpKSlcbiAgICAgICAgOyBMaXN0IChDb25zIChTdHJpbmcsIENvbnMgKFN0cmluZywgQ29ucyAoU3RyaW5nLCBFbXB0eSkpKSlcbiAgICAgICAgXVxuICB9XG47O1xuXG5sZXQgc2V4cF9vZl90X2FicyB0IH56b25lID1cbiAgU2V4cC5MaXN0IChMaXN0Lm1hcCAoVGltZV9ucy50b19zdHJpbmdfYWJzX3BhcnRzIH56b25lIHQpIH5mOihmdW4gcyAtPiBTZXhwLkF0b20gcykpXG47O1xuXG5sZXQgc2V4cF9vZl90IHQgPSBzZXhwX29mX3RfYWJzIH56b25lOihnZXRfc2V4cF96b25lICgpKSB0XG5sZXQgb2ZfZGF0ZV9vZmRheV96b25lZCBkYXRlIG9mZGF5X3pvbmVkID0gT2ZkYXkuWm9uZWQudG9fdGltZV9ucyBvZmRheV96b25lZCBkYXRlXG5cbmxldCB0b19kYXRlX29mZGF5X3pvbmVkIHQgfnpvbmUgPVxuICBsZXQgZGF0ZSwgb2ZkYXkgPSB0b19kYXRlX29mZGF5IHQgfnpvbmUgaW5cbiAgZGF0ZSwgT2ZkYXkuWm9uZWQuY3JlYXRlIG9mZGF5IHpvbmVcbjs7XG5cbmxldCB0b19vZmRheV96b25lZCB0IH56b25lID1cbiAgbGV0IG9mZGF5ID0gdG9fb2ZkYXkgdCB+em9uZSBpblxuICBPZmRheS5ab25lZC5jcmVhdGUgb2ZkYXkgem9uZVxuOztcblxuaW5jbHVkZSBEaWZmYWJsZS5BdG9taWMuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0IFtAQGRlcml2aW5nIGJpbl9pbywgZXF1YWwsIHNleHBdXG5lbmQpXG5cbm1vZHVsZSBTdGFibGUwID0gc3RydWN0XG4gIG1vZHVsZSBWMSA9IHN0cnVjdFxuICAgIG1vZHVsZSBUMCA9IHN0cnVjdFxuICAgICAgKCogV2UgdXNlIHRoZSB1bnN0YWJsZSBzZXJpYWxpemF0aW9uIGhlcmUsIGFuZCByZWx5IG9uIGNvbXByZWhlbnNpdmUgdGVzdHMgb2YgdGhlXG4gICAgICAgICBzdGFibGUgY29udmVyc2lvbiB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgY2hhbmdlIGl0LiAqKVxuICAgICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgYmluX2lvLCBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cF1cblxuICAgICAgbGV0IHN0YWJsZV93aXRuZXNzIDogdCBTdGFibGVfd2l0bmVzcy50ID0gU3RhYmxlX3dpdG5lc3MuYXNzZXJ0X3N0YWJsZVxuICAgICAgbGV0IG9mX2ludDYzX2V4biB0ID0gb2Zfc3Bhbl9zaW5jZV9lcG9jaCAoU3Bhbi5vZl9pbnQ2M19ucyB0KVxuICAgICAgbGV0IHRvX2ludDYzIHQgPSB0b19pbnQ2M19uc19zaW5jZV9lcG9jaCB0XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBUMFxuICAgICAgbW9kdWxlIENvbXBhcmF0b3IgPSBDb21wYXJhdG9yLlN0YWJsZS5WMS5NYWtlIChUMClcbiAgICAgIGluY2x1ZGUgQ29tcGFyYXRvclxuICAgIGVuZFxuXG4gICAgaW5jbHVkZSBUXG4gICAgaW5jbHVkZSBDb21wYXJhYmxlLlN0YWJsZS5WMS5XaXRoX3N0YWJsZV93aXRuZXNzLk1ha2UgKFQpXG4gICAgaW5jbHVkZSBEaWZmYWJsZS5BdG9taWMuTWFrZSAoVClcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBTdGFibGUwLlYxLkNvbXBhcmF0b3JcblxubW9kdWxlIE9wdGlvbiA9IHN0cnVjdFxuICBpbmNsdWRlIFRpbWVfbnMuT3B0aW9uXG5cbiAgbW9kdWxlIFN0YWJsZSA9IHN0cnVjdFxuICAgIG1vZHVsZSBWMSA9IHN0cnVjdFxuICAgICAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICAgICAgaW5jbHVkZSBTdGFibGUuVjFcblxuICAgICAgICBsZXQgc2V4cF9vZl90IHQgPSBbJXNleHBfb2Y6IFN0YWJsZTAuVjEudCBvcHRpb25dICh0b19vcHRpb24gdClcbiAgICAgICAgbGV0IHRfb2Zfc2V4cCBzID0gb2Zfb3B0aW9uIChbJW9mX3NleHA6IFN0YWJsZTAuVjEudCBvcHRpb25dIHMpXG4gICAgICBlbmRcblxuICAgICAgaW5jbHVkZSBUXG4gICAgICBpbmNsdWRlIENvbXBhcmF0b3IuU3RhYmxlLlYxLk1ha2UgKFQpXG5cbiAgICAgIGluY2x1ZGUgRGlmZmFibGUuQXRvbWljLk1ha2UgKHN0cnVjdFxuICAgICAgICBpbmNsdWRlIFRcblxuICAgICAgICBsZXQgZXF1YWwgPSBbJWNvbXBhcmUuZXF1YWw6IHRdXG4gICAgICBlbmQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGxldCBzZXhwX29mX3QgPSBTdGFibGUuVjEuc2V4cF9vZl90XG4gIGxldCB0X29mX3NleHAgPSBTdGFibGUuVjEudF9vZl9zZXhwXG5cbiAgaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgc2V4cCwgY29tcGFyZSwgYmluX2lvLCBoYXNoXVxuXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJUaW1lX25zX3VuaXguT3B0aW9uXCJcblxuICAgIGluY2x1ZGUgU2V4cGFibGUuVG9fc3RyaW5nYWJsZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdCBbQEBkZXJpdmluZyBzZXhwXVxuICAgIGVuZClcbiAgZW5kKVxuXG4gICgqIGJyaW5nIGJhY2sgdGhlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiBvZiBjb21wYXJpc29uIG9wZXJhdG9ycyAqKVxuICBpbmNsdWRlIChUaW1lX25zLk9wdGlvbiA6IENvcmUuQ29tcGFyaXNvbnMuUyB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGluY2x1ZGUgRGlmZmFibGUuQXRvbWljLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0IFtAQGRlcml2aW5nIGJpbl9pbywgZXF1YWwsIHNleHBdXG4gIGVuZClcbmVuZFxuXG4oKiBOb3RlOiBUaGlzIGlzIEZJWCBzdGFuZGFyZCBtaWxsaXNlY29uZCBwcmVjaXNpb24uIFlvdSBzaG91bGQgdXNlXG4gICBbWmVyby5UaW1lX25zX3dpdGhfZmFzdF9hY2N1cmF0ZV90b19vZl9zdHJpbmddIGlmIHlvdSBuZWVkIG5hbm9zZWNvbmQgcHJlY2lzaW9uLiAqKVxubGV0IHRvX3N0cmluZ19maXhfcHJvdG8gem9uZSB0ID1cbiAgVGltZS50b19zdHJpbmdfZml4X3Byb3RvIHpvbmUgKHRvX3RpbWVfZmxvYXRfcm91bmRfbmVhcmVzdF9taWNyb3NlY29uZCB0KVxuOztcblxubGV0IG9mX3N0cmluZ19maXhfcHJvdG8gem9uZSBzID1cbiAgb2ZfdGltZV9mbG9hdF9yb3VuZF9uZWFyZXN0X21pY3Jvc2Vjb25kIChUaW1lLm9mX3N0cmluZ19maXhfcHJvdG8gem9uZSBzKVxuOztcblxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZV91c2luZ19jb21wYXJhdG9yIChzdHJ1Y3RcbiAgaW5jbHVkZSBTdGFibGUwLlYxXG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJUaW1lX25zX3VuaXhcIlxuICBsZXQgb2Zfc3RyaW5nLCB0b19zdHJpbmcgPSBvZl9zdHJpbmcsIHRvX3N0cmluZ1xuZW5kKVxuXG4oKiBicmluZyBiYWNrIHRoZSBlZmZpY2llbnQgaW1wbGVtZW50YXRpb24gb2YgY29tcGFyaXNvbiBvcGVyYXRvcnMgKilcbmluY2x1ZGUgKENvcmUuVGltZV9ucyA6IENvcmUuQ29tcGFyaXNvbnMuUyB3aXRoIHR5cGUgdCA6PSB0KVxuXG5tb2R1bGUgU3RhYmxlID0gc3RydWN0XG4gIG1vZHVsZSBPcHRpb24gPSBPcHRpb24uU3RhYmxlXG5cbiAgbW9kdWxlIFNwYW4gPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFNwYW4uU3RhYmxlXG4gICAgbW9kdWxlIE9wdGlvbiA9IFNwYW4uT3B0aW9uLlN0YWJsZVxuICBlbmRcblxuICBtb2R1bGUgT2ZkYXkgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRpbWVfbnMuU3RhYmxlLk9mZGF5XG4gICAgbW9kdWxlIFpvbmVkID0gT2ZkYXkuWm9uZWQuU3RhYmxlXG4gICAgbW9kdWxlIE9wdGlvbiA9IE9mZGF5Lk9wdGlvbi5TdGFibGVcbiAgZW5kXG5cbiAgbW9kdWxlIFpvbmUgPSBUaW1lem9uZS5TdGFibGVcbiAgaW5jbHVkZSBTdGFibGUwXG4gIG1vZHVsZSBBbHRlcm5hdGVfc2V4cCA9IENvcmUuVGltZV9ucy5TdGFibGUuQWx0ZXJuYXRlX3NleHBcbmVuZFxuXG4oKlxuICAgRHJvcHBpbmcgVGltZSBpbiBmYXZvciBvZiBUaW1lX25zIGlzIHBvc3NpYmxlIGFuZCBoYXMgYmVlbiBkaXNjdXNzZWQsIGJ1dCB3ZSBoYXZlXG4gICBjaG9zZW4gbm90IHRvIGRvIHNvIGF0IHRoaXMgdGltZSBmb3IgYSBmZXcgcmVhc29uczpcblxuICAgLSBJdCdzIGEgbG90IG9mIHdvcmsuICBBbGwgZnVuY3Rpb25zIG92ZXIgVGltZSwgaW5jbHVkaW5nIHRoZSByZWxhdGVkXG4gICAgIG1vZHVsZXMgRGF0ZSwgT2ZkYXksIFpvbmUsIFNwYW4sIFNjaGVkdWxlIGhhdmUgdG8gYmUgY29udmVydGVkIHRvIFRpbWVfbnNcbiAgICAgc3BhY2UuICBUaGlzIGlzIGxhcmdlbHkgbWVjaGFuaWNhbCwgYnV0IHdpbGwgY3JlYXRlIGEgbG90IG9mIGNodXJuIHdpdGhpblxuICAgICB0aGUgbW9kdWxlcyBhbmQgcG9zc2libHkgZXh0ZXJuYWxseSB3aGVyZSB0aGUgZmxvYXRpbmVzcyBvZiB0aGUgVGltZSB3b3JsZFxuICAgICBsZWFrcyBvdXQuXG5cbiAgIC0gSXQncyBvZiBsaW1pdGVkIHV0aWxpdHkgY29tcGFyZWQgdG8gb3RoZXIgdGhpbmdzIHdlIGNvdWxkIGJlIHdvcmtpbmcgb24uXG4gICAgIFRpbWUgbWF0aCB3b3VsZCBiZSBlYXNpZXIgdG8gdW5kZXJzdGFuZCBhbmQgc29tZXdoYXQgZmFzdGVyLCBidXQgdmVyeSBmZXdcbiAgICAgbW9kdWxlcy9wcm9ncmFtcyB3b3VsZCBiZW5lZml0IGZyb20gZmFzdGVyIHRpbWUgbWF0aC4gIFRob3NlIHRoYXQgZG8gY2FuXG4gICAgIHVzZSBUaW1lX25zIGFscmVhZHkgZm9yIHRoZSBtb3N0IHBhcnQuXG5cbiAgIC0gSGF2aW5nIFRpbWVfbnMgYW5kIGEgY29udmVyc2lvbiBmdW5jdGlvbiBhbHJlYWR5IGdpdmVzIHRoZSBidWxrIG9mIHRoZVxuICAgICB2YWx1ZSB0byBwcm9ncmFtcyB0aGF0IHdhbnQgYSBmYXN0LCBub24tYWxsb2NhdGluZyB2ZXJzaW9uIG9mIFtUaW1lLm5vd10uXG4gICAgIEluZGVlZCwgbWFueSByZW1haW5pbmcgdW5jb252ZXJ0ZWQgZnVuY3Rpb25zXG5cbiAgIC0gV2UgYXJlbid0IGNlcnRhaW4gYWJvdXQgaG93IHRoZSBib3VuZGFyaWVzIGFyb3VuZCBUaW1lX25zIHdpbGwgYWZmZWN0IHRoZVxuICAgICBleHRlcm5hbCB2aWFiaWxpdHkgb2YgQ29yZS4gIEludGVybmFsbHkgd2UgZG9uJ3QgdGhpbmsgYmVpbmcgbGltaXRlZCB0b1xuICAgICBhIHNtYWxsZXIgdGltZSByYW5nZSBpcyBhbiBpc3N1ZSwgYW5kIHJlYWxseSBmYXIgb2ZmIHRpbWVzIGFyZSBiZXR0ZXJcbiAgICAgcmVwcmVzZW50ZWQgYXMgKERhdGUudCAqIE9mZGF5LnQpLCBidXQgaXQgaXMgc3RpbGwgYSByZXN0cmljdGlvbi4gIFRoaXNcbiAgICAgcHVzaGJhY2sgaXMgcHJvYmFibHkgbWluaW1hbCBhbmQsIGlmIHdlIGNvdWxkIGdldCBvdmVyIHRoZSB3b3JrIGNvbmNlcm5zLFxuICAgICBjb3VsZCBiZSBlbGltaW5hdGVkLlxuXG4gICAtIENvbnZlcnRpbmcgYmV0d2VlbiBUaW1lIGFuZCBUaW1lX25zIHdoZW4geW91IHVzZSBsaWJyYXJpZXMgYmFzZWQgb24gZGlmZmVyZW50IG9uZXNcbiAgICAgaXNuJ3Qgc28gYmFkLiAoPylcbiopXG4iXX0=
