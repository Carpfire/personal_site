// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Lwt_sequence
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Empty = [248, "Lwt_sequence.Empty", runtime.caml_fresh_oo_id(0)];
   function get(node){return node[3];}
   function set(node, data){node[3] = data; return 0;}
   function remove(node){
    var
     _k_ = node[4],
     _l_ =
       _k_
        ? (node[4] = 0, node[1][2] = node[2], node[2][1] = node[1], 0)
        : _k_;
    return _l_;
   }
   function create(param){
    var seq = [];
    runtime.caml_update_dummy(seq, [0, seq, seq]);
    return seq;
   }
   function clear(seq){seq[1] = seq; seq[2] = seq; return 0;}
   function is_empty(seq){return seq[2] === seq ? 1 : 0;}
   function length(seq){
    var curr$1 = seq[2], curr = curr$1, len = 0;
    for(;;){
     if(curr === seq) return len;
     var len$0 = len + 1 | 0, curr$0 = curr[2], curr = curr$0, len = len$0;
    }
   }
   function add_l(data, seq){
    var node = [0, seq, seq[2], data, 1];
    seq[2][1] = node;
    seq[2] = node;
    return node;
   }
   function add_r(data, seq){
    var node = [0, seq[1], seq, data, 1];
    seq[1][2] = node;
    seq[1] = node;
    return node;
   }
   function take_l(seq){
    if(is_empty(seq)) throw caml_maybe_attach_backtrace(Empty, 1);
    var node = seq[2];
    remove(node);
    return node[3];
   }
   function take_r(seq){
    if(is_empty(seq)) throw caml_maybe_attach_backtrace(Empty, 1);
    var node = seq[1];
    remove(node);
    return node[3];
   }
   function take_opt_l(seq){
    if(is_empty(seq)) return 0;
    var node = seq[2];
    remove(node);
    return [0, node[3]];
   }
   function take_opt_r(seq){
    if(is_empty(seq)) return 0;
    var node = seq[1];
    remove(node);
    return [0, node[3]];
   }
   function transfer_l(s1, s2){
    s2[2][1] = s1[1];
    s1[1][2] = s2[2];
    s2[2] = s1[2];
    s1[2][1] = s2;
    s1[1] = s1;
    s1[2] = s1;
    return 0;
   }
   function transfer_r(s1, s2){
    s2[1][2] = s1[2];
    s1[2][1] = s2[1];
    s2[1] = s1[1];
    s1[1][2] = s2;
    s1[1] = s1;
    s1[2] = s1;
    return 0;
   }
   function iter_l(f, seq){
    var curr$1 = seq[2], curr = curr$1;
    for(;;){
     var _j_ = curr !== seq ? 1 : 0;
     if(! _j_) return _j_;
     if(curr[4]) caml_call1(f, curr[3]);
     var curr$0 = curr[2], curr = curr$0;
    }
   }
   function iter_r(f, seq){
    var curr$1 = seq[1], curr = curr$1;
    for(;;){
     var _i_ = curr !== seq ? 1 : 0;
     if(! _i_) return _i_;
     if(curr[4]) caml_call1(f, curr[3]);
     var curr$0 = curr[1], curr = curr$0;
    }
   }
   function iter_node_l(f, seq){
    var curr$1 = seq[2], curr = curr$1;
    for(;;){
     var _h_ = curr !== seq ? 1 : 0;
     if(! _h_) return _h_;
     if(curr[4]) caml_call1(f, curr);
     var curr$0 = curr[2], curr = curr$0;
    }
   }
   function iter_node_r(f, seq){
    var curr$1 = seq[1], curr = curr$1;
    for(;;){
     var _g_ = curr !== seq ? 1 : 0;
     if(! _g_) return _g_;
     if(curr[4]) caml_call1(f, curr);
     var curr$0 = curr[1], curr = curr$0;
    }
   }
   function fold_l(f, seq, acc){
    var curr$2 = seq[2], curr = curr$2, acc$0 = acc;
    for(;;){
     if(curr === seq) return acc$0;
     if(curr[4])
      var
       acc$1 = caml_call2(f, curr[3], acc$0),
       curr$0 = curr[2],
       curr = curr$0,
       acc$0 = acc$1;
     else
      var curr$1 = curr[2], curr = curr$1;
    }
   }
   function fold_r(f, seq, acc){
    var curr$2 = seq[1], curr = curr$2, acc$0 = acc;
    for(;;){
     if(curr === seq) return acc$0;
     if(curr[4])
      var
       acc$1 = caml_call2(f, curr[3], acc$0),
       curr$0 = curr[1],
       curr = curr$0,
       acc$0 = acc$1;
     else
      var curr$1 = curr[1], curr = curr$1;
    }
   }
   function find_node_l(f, seq){
    var curr$2 = seq[2], curr = curr$2;
    for(;;){
     if(curr === seq) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(curr[4]){
      if(caml_call1(f, curr[3])) return curr;
      var curr$0 = curr[2], curr = curr$0;
     }
     else
      var curr$1 = curr[2], curr = curr$1;
    }
   }
   function find_node_r(f, seq){
    var curr$2 = seq[1], curr = curr$2;
    for(;;){
     if(curr === seq) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(curr[4]){
      if(caml_call1(f, curr[3])) return curr;
      var curr$0 = curr[1], curr = curr$0;
     }
     else
      var curr$1 = curr[1], curr = curr$1;
    }
   }
   function find_node_opt_l(f, seq){
    try{var _e_ = [0, find_node_l(f, seq)]; return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function find_node_opt_r(f, seq){
    try{var _b_ = [0, find_node_r(f, seq)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var
    Lwt_sequence =
      [0,
       get,
       set,
       remove,
       create,
       clear,
       is_empty,
       length,
       add_l,
       add_r,
       Empty,
       take_l,
       take_r,
       take_opt_l,
       take_opt_r,
       transfer_l,
       transfer_r,
       iter_l,
       iter_r,
       iter_node_l,
       iter_node_r,
       fold_l,
       fold_r,
       find_node_opt_l,
       find_node_opt_r,
       find_node_l,
       find_node_r];
   runtime.caml_register_global(2, Lwt_sequence, "Lwt_sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt
//# unitInfo: Requires: CamlinternalLazy, Lwt_sequence, Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Map, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Lwt = "Lwt.",
    cst_Lwt_s = "Lwt.%s",
    cst_src_core_lwt_ml = "src/core/lwt.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Map = global_data.Stdlib__Map,
    compare = runtime.caml_compare,
    Storage_map = caml_call1(Stdlib_Map[1], [0, compare]),
    _O_ = [0, cst_src_core_lwt_ml, 2709, 6],
    _P_ = [0, cst_src_core_lwt_ml, 2729, 6],
    _U_ = [0, 0],
    _V_ = [0, 0],
    cst_Lwt_nchoose_split_would_re =
      "Lwt.nchoose_split [] would return a promise that is pending forever",
    _T_ = [0, 0],
    cst_Lwt_npick_would_return_a_p =
      "Lwt.npick [] would return a promise that is pending forever",
    _S_ = [0, 0],
    cst_Lwt_nchoose_would_return_a =
      "Lwt.nchoose [] would return a promise that is pending forever",
    _R_ = [0, 0],
    cst_Lwt_pick_would_return_a_pr =
      "Lwt.pick [] would return a promise that is pending forever",
    _Q_ = [0, 0],
    cst_Lwt_choose_would_return_a_ =
      "Lwt.choose [] would return a promise that is pending forever",
    _N_ = [0, cst_src_core_lwt_ml, 2670, 24],
    _M_ = [0, cst_src_core_lwt_ml, 2651, 13],
    _L_ = [0, 0],
    _K_ = [0, 0],
    _I_ = [0, 1],
    _J_ = [0, 1],
    _G_ = [0, 1],
    _H_ = [0, 1],
    _F_ = [0, 1],
    _E_ = [0, 1],
    _C_ = [0, 0],
    _D_ = [0, 1],
    _A_ = [0, 1],
    _B_ = [0, 1],
    _y_ = [0, 1],
    _z_ = [0, 1],
    _w_ = [0, 0],
    _x_ = [0, 1],
    _u_ = [0, 0],
    _v_ = [0, 1],
    _r_ = [0, 0],
    _s_ = [0, 0],
    _t_ = [0, 1],
    _p_ = [0, 0],
    _q_ = [0, 1],
    _n_ = [0, 0],
    _o_ = [0, 1],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _k_ = [0, 0],
    _j_ = [0, 0],
    _i_ = [0, 0],
    cst_wakeup_later_exn = "wakeup_later_exn",
    cst_wakeup_later = "wakeup_later",
    cst_wakeup_later_result = "wakeup_later_result",
    _f_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _g_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _h_ = [0, 1],
    cst_wakeup_exn = "wakeup_exn",
    cst_wakeup = "wakeup",
    cst_wakeup_result = "wakeup_result",
    _c_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _d_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _e_ = [0, 0],
    cst_Fatal_error_exception = "Fatal error: exception ",
    _a_ = [0, cst_src_core_lwt_ml, 980, 23],
    _b_ = [0, cst_src_core_lwt_ml, 981, 22],
    cst_Lwt_Resolution_loop_Cancel = "Lwt.Resolution_loop.Canceled";
   function state_of_result(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var exn = param[1];
    return [1, exn];
   }
   function underlying(p){
    var match = p[1];
    switch(match[0]){
      case 0:
       return p;
      case 1:
       return p;
      case 2:
       return p;
      default:
       var p$0 = match[1], p$1 = underlying(p$0);
       if(1 - (p$1 === p$0 ? 1 : 0)) p[1] = [3, p$1];
       return p$1;
    }
   }
   function set_promise_state(p, state){p[1] = state; return p;}
   function handle_all(param){return 1;}
   function handle_all_except_runtime(param){
    return param === Stdlib[9] ? 0 : param === Stdlib[10] ? 0 : 1;
   }
   var v = [0, handle_all];
   function set(f){v[1] = f; return 0;}
   function run(e){return caml_call1(v[1], e);}
   var next_key_id = [0, 0];
   function new_key(param){
    var id = next_key_id[1];
    next_key_id[1] = id + 1 | 0;
    return [0, id, 0];
   }
   var current_storage = [0, Storage_map[1]];
   function get(key){
    if(! caml_call2(Storage_map[32], key[1], current_storage[1])) return 0;
    var refresh = caml_call2(Storage_map[17], key[1], current_storage[1]);
    caml_call1(refresh, 0);
    var value = key[2];
    key[2] = 0;
    return value;
   }
   function with_value(key, value, f){
    if(value)
     var
      refresh = function(param){key[2] = value; return 0;},
      new_storage =
        caml_call3(Storage_map[2], key[1], refresh, current_storage[1]);
    else
     var new_storage = caml_call2(Storage_map[6], key[1], current_storage[1]);
    var saved_storage = current_storage[1];
    current_storage[1] = new_storage;
    try{
     var result = caml_call1(f, 0);
     current_storage[1] = saved_storage;
     return result;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     current_storage[1] = saved_storage;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function concat_regular_callbacks(l1, l2){
    return typeof l1 === "number"
            ? l2
            : typeof l2 === "number" ? l1 : [0, l1, l2];
   }
   function clean_up_callback_cells(callbacks){
    if(typeof callbacks !== "number")
     switch(callbacks[0]){
       case 0:
        var
         l2 = callbacks[2],
         l1 = callbacks[1],
         l1$0 = clean_up_callback_cells(l1),
         l2$0 = clean_up_callback_cells(l2);
        return concat_regular_callbacks(l1$0, l2$0);
       case 2:
        if(! callbacks[1][1]) return 0; break;
     }
    return callbacks;
   }
   function clear_explicitly_removable_cal(cell, ps){
    cell[1] = 0;
    function _bo_(p){
     var match = underlying(p)[1];
     switch(match[0]){
       case 1:
        return 0;
       case 2:
        var callbacks = match[1], _bp_ = callbacks[1];
        if(typeof _bp_ !== "number" && 2 === _bp_[0]){callbacks[1] = 0; return 0;}
        var cleanups_deferred = callbacks[4] + 1 | 0;
        return 42 < cleanups_deferred
                ? (callbacks
                   [4]
                  = 0,
                  callbacks[1] = clean_up_callback_cells(callbacks[1]),
                  0)
                : (callbacks[4] = cleanups_deferred, 0);
       default: return 0;
     }
    }
    return caml_call1(caml_call1(Stdlib_List[18], _bo_), ps);
   }
   function add_regular_callback_list_node(callbacks, node){
    var
     existing = callbacks[1],
     node$0 = typeof existing === "number" ? node : [0, node, existing];
    callbacks[1] = node$0;
    return 0;
   }
   function add_implicitly_removed_callbac(callbacks, f){
    return add_regular_callback_list_node(callbacks, [1, f]);
   }
   function add_explicitly_removable_callb(ps, f){
    var
     cell = [],
     self_removing_callback_wrapper =
       function _bn_(_bm_){return _bn_.fun(_bm_);};
    caml_update_dummy(cell, [0, [0, self_removing_callback_wrapper]]);
    caml_update_dummy
     (self_removing_callback_wrapper,
      function(result){
       clear_explicitly_removable_cal(cell, ps);
       return caml_call1(f, result);
      });
    var node = [2, cell];
    function _bl_(p){
     var match = underlying(p)[1];
     switch(match[0]){
       case 1:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
       case 2:
        var callbacks = match[1];
        return add_regular_callback_list_node(callbacks, node);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     }
    }
    caml_call1(caml_call1(Stdlib_List[18], _bl_), ps);
    return cell;
   }
   function add_explicitly_removable_callb$0(ps, f){add_explicitly_removable_callb(ps, f); return;
   }
   function add_cancel_callback(callbacks, f){
    var
     node = [1, current_storage[1], f],
     node$0 =
       typeof callbacks[2] === "number" ? node : [0, node, callbacks[2]];
    callbacks[2] = node$0;
    return 0;
   }
   var
    async_exception_hook =
      [0,
       function(exn){
        caml_call1(Stdlib[49], cst_Fatal_error_exception);
        var _bk_ = caml_call1(Stdlib_Printexc[1], exn);
        caml_call1(Stdlib[49], _bk_);
        caml_call1(Stdlib[48], 10);
        caml_call1(Stdlib_Printexc[5], Stdlib[40]);
        caml_call1(Stdlib[63], Stdlib[40]);
        return caml_call1(Stdlib[99], 2);
       }];
   function handle_with_async_exception_ho(f, v){
    try{var _bj_ = caml_call1(f, v); return _bj_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return caml_call1(async_exception_hook[1], exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    Canceled =
      [248, cst_Lwt_Resolution_loop_Cancel, runtime.caml_fresh_oo_id(0)];
   function run_callbacks(callbacks, result){
    if(1 === result[0])
     var _bi_ = result[1] === Canceled ? 1 : 0, is_canceled = _bi_;
    else
     var is_canceled = 0;
    if(is_canceled){
     var
      fs = callbacks[2],
      iter_callback_list$2 =
        function(counter, fs, rest){
         var fs$0 = fs, rest$0 = rest;
         for(;;){
          if(typeof fs$0 === "number"){
           if(counter >= 50)
            return caml_trampoline_return(iter_list$0, [0, rest$0]);
           var counter$0 = counter + 1 | 0;
           return iter_list$0(counter$0, rest$0);
          }
          switch(fs$0[0]){
            case 0:
             var
              fs$1 = fs$0[2],
              fs$2 = fs$0[1],
              rest$1 = [0, fs$1, rest$0],
              fs$0 = fs$2,
              rest$0 = rest$1;
             break;
            case 1:
             var f = fs$0[2], storage = fs$0[1];
             current_storage[1] = storage;
             handle_with_async_exception_ho(f, 0);
             if(counter >= 50)
              return caml_trampoline_return(iter_list$0, [0, rest$0]);
             var counter$1 = counter + 1 | 0;
             return iter_list$0(counter$1, rest$0);
            default:
             var node = fs$0[1];
             caml_call1(Lwt_sequence[3], node);
             if(counter >= 50)
              return caml_trampoline_return(iter_list$0, [0, rest$0]);
             var counter$2 = counter + 1 | 0;
             return iter_list$0(counter$2, rest$0);
          }
         }
        },
      iter_list$0 =
        function(counter, rest){
         if(! rest) return;
         var rest$0 = rest[2], fs = rest[1];
         if(counter >= 50)
          return caml_trampoline_return(iter_callback_list$2, [0, fs, rest$0]);
         var counter$0 = counter + 1 | 0;
         return iter_callback_list$2(counter$0, fs, rest$0);
        },
      iter_callback_list =
        function(fs, rest){
         return caml_trampoline(iter_callback_list$2(0, fs, rest));
        };
     iter_callback_list(fs, 0);
    }
    var fs$0 = callbacks[1];
    function iter_callback_list$1(counter, fs, rest){
     var fs$0 = fs, rest$0 = rest;
     for(;;){
      if(typeof fs$0 === "number"){
       if(counter >= 50)
        return caml_trampoline_return(iter_list, [0, rest$0]);
       var counter$0 = counter + 1 | 0;
       return iter_list(counter$0, rest$0);
      }
      switch(fs$0[0]){
        case 0:
         var
          fs$1 = fs$0[2],
          fs$2 = fs$0[1],
          rest$1 = [0, fs$1, rest$0],
          fs$0 = fs$2,
          rest$0 = rest$1;
         break;
        case 1:
         var f = fs$0[1];
         caml_call1(f, result);
         if(counter >= 50)
          return caml_trampoline_return(iter_list, [0, rest$0]);
         var counter$1 = counter + 1 | 0;
         return iter_list(counter$1, rest$0);
        default:
         var match = fs$0[1][1];
         if(match){
          var f$0 = match[1];
          caml_call1(f$0, result);
          if(counter >= 50)
           return caml_trampoline_return(iter_list, [0, rest$0]);
          var counter$2 = counter + 1 | 0;
          return iter_list(counter$2, rest$0);
         }
         if(counter >= 50)
          return caml_trampoline_return(iter_list, [0, rest$0]);
         var counter$3 = counter + 1 | 0;
         return iter_list(counter$3, rest$0);
      }
     }
    }
    function iter_list(counter, rest){
     if(! rest) return 0;
     var rest$0 = rest[2], fs = rest[1];
     if(counter >= 50)
      return caml_trampoline_return(iter_callback_list$1, [0, fs, rest$0]);
     var counter$0 = counter + 1 | 0;
     return iter_callback_list$1(counter$0, fs, rest$0);
    }
    function iter_callback_list$0(fs, rest){
     return caml_trampoline(iter_callback_list$1(0, fs, rest));
    }
    return iter_callback_list$0(fs$0, 0);
   }
   var
    current_callback_nesting_depth = [0, 0],
    deferred_callbacks = caml_call1(Stdlib_Queue[2], 0),
    default_maximum_callback_nesti = 42;
   function leave_resolution_loop(storage_snapshot){
    if(1 === current_callback_nesting_depth[1])
     for(;;){
      if(caml_call1(Stdlib_Queue[13], deferred_callbacks)) break;
      var
       match = caml_call1(Stdlib_Queue[7], deferred_callbacks),
       result = match[2],
       callbacks = match[1];
      run_callbacks(callbacks, result);
     }
    current_callback_nesting_depth[1] =
     current_callback_nesting_depth[1] - 1 | 0;
    current_storage[1] = storage_snapshot;
    return 0;
   }
   function run_in_resolution_loop(f){
    current_callback_nesting_depth[1] =
     current_callback_nesting_depth[1] + 1 | 0;
    var storage_snapshot = current_storage[1], result = caml_call1(f, 0);
    leave_resolution_loop(storage_snapshot);
    return result;
   }
   function abandon_wakeups(param){
    var _bh_ = 0 !== current_callback_nesting_depth[1] ? 1 : 0;
    return _bh_ ? leave_resolution_loop(Storage_map[1]) : _bh_;
   }
   function run_callbacks_or_defer_them(opt, _bg_, callbacks, result){
    if(opt)
     var sth = opt[1], allow_deferring = sth;
    else
     var allow_deferring = 1;
    if(_bg_)
     var sth$0 = _bg_[1], maximum_callback_nesting_depth = sth$0;
    else
     var maximum_callback_nesting_depth = default_maximum_callback_nesti;
    var
     should_defer =
       allow_deferring
        ? maximum_callback_nesting_depth
          <= current_callback_nesting_depth[1]
          ? 1
          : 0
        : allow_deferring;
    return should_defer
            ? caml_call2
              (Stdlib_Queue[4], [0, callbacks, result], deferred_callbacks)
            : run_in_resolution_loop
              (function(param){return run_callbacks(callbacks, result);});
   }
   function resolve
   (allow_deferring, maximum_callback_nesting_depth, p, result){
    var callbacks = p[1][1];
    set_promise_state(p, result);
    run_callbacks_or_defer_them
     (allow_deferring, maximum_callback_nesting_depth, callbacks, result);
    return;
   }
   function run_callback_or_defer_it(opt, f, if_deferred){
    if(opt)
     var sth = opt[1], run_immediately_and_ensure_tai = sth;
    else
     var run_immediately_and_ensure_tai = 0;
    if(run_immediately_and_ensure_tai) return caml_call1(f, 0);
    var should_defer = 42 <= current_callback_nesting_depth[1] ? 1 : 0;
    if(! should_defer)
     return run_in_resolution_loop(function(param){return caml_call1(f, 0);});
    var
     match = caml_call1(if_deferred, 0),
     deferred_result = match[3],
     deferred_callback = match[2],
     immediate_result = match[1],
     deferred_record = [0, [1, deferred_callback], 0, 0, 0];
    caml_call2
     (Stdlib_Queue[4],
      [0, deferred_record, deferred_result],
      deferred_callbacks);
    return immediate_result;
   }
   function wakeup_general(api_function_name, r, result){
    var p = underlying(r), _bf_ = p[1];
    switch(_bf_[0]){
      case 1:
       return _bf_[1] === Canceled
               ? 0
               : caml_call3
                 (Stdlib_Printf[10], Stdlib[1], _d_, api_function_name);
      case 2:
       var result$0 = state_of_result(result);
       resolve(_e_, 0, p, result$0);
       return 0;
      default:
       return caml_call3(Stdlib_Printf[10], Stdlib[1], _c_, api_function_name);
    }
   }
   function wakeup_result(r, result){
    return wakeup_general(cst_wakeup_result, r, result);
   }
   function wakeup(r, v){return wakeup_general(cst_wakeup, r, [0, v]);}
   function wakeup_exn(r, exn){
    return wakeup_general(cst_wakeup_exn, r, [1, exn]);
   }
   function wakeup_later_general(api_function_name, r, result){
    var p = underlying(r), _be_ = p[1];
    switch(_be_[0]){
      case 1:
       return _be_[1] === Canceled
               ? 0
               : caml_call3
                 (Stdlib_Printf[10], Stdlib[1], _g_, api_function_name);
      case 2:
       var result$0 = state_of_result(result);
       resolve(0, _h_, p, result$0);
       return 0;
      default:
       return caml_call3(Stdlib_Printf[10], Stdlib[1], _f_, api_function_name);
    }
   }
   function wakeup_later_result(r, result){
    return wakeup_later_general(cst_wakeup_later_result, r, result);
   }
   function wakeup_later(r, v){
    return wakeup_later_general(cst_wakeup_later, r, [0, v]);
   }
   function wakeup_later_exn(r, exn){
    return wakeup_later_general(cst_wakeup_later_exn, r, [1, exn]);
   }
   function cancel(p){
    var canceled_result = [1, Canceled];
    function cancel_and_collect_callbacks(callbacks_accumulator, p){
     var p$0 = p;
     for(;;){
      var p$1 = underlying(p$0), match = p$1[1];
      switch(match[0]){
        case 1:
         return callbacks_accumulator;
        case 2:
         var callbacks = match[1], match$0 = callbacks[3];
         if(typeof match$0 === "number")
          return 0 === match$0
                  ? callbacks_accumulator
                  : (set_promise_state
                     (p$1, canceled_result),
                    [0, callbacks, callbacks_accumulator]);
         if(0 !== match$0[0]){
          var ps = match$0[1];
          return caml_call3
                  (Stdlib_List[26],
                   cancel_and_collect_callbacks,
                   callbacks_accumulator,
                   ps);
         }
         var p$2 = match$0[1], p$0 = p$2;
         break;
        default: return callbacks_accumulator;
      }
     }
    }
    var callbacks = cancel_and_collect_callbacks(0, p);
    function _bd_(param){
     return run_callbacks_or_defer_them(_i_, 0, param, canceled_result);
    }
    return caml_call1(caml_call1(Stdlib_List[18], _bd_), callbacks);
   }
   function return$0(v){return [0, [0, v]];}
   function of_result(result){return [0, state_of_result(result)];}
   function fail(exn){return [0, [1, exn]];}
   var return_unit = return$0(0), return_none = return$0(0);
   function return_some(x){return return$0([0, x]);}
   var
    return_nil = return$0(0),
    return_true = return$0(1),
    return_false = return$0(0);
   function return_ok(x){return return$0([0, x]);}
   function return_error(x){return return$0([1, x]);}
   function fail_with(msg){return [0, [1, [0, Stdlib[7], msg]]];}
   function fail_invalid_arg(msg){return [0, [1, [0, Stdlib[6], msg]]];}
   function new_pending(how_to_cancel){
    var state = [2, [0, 0, 0, how_to_cancel, 0]];
    return [0, state];
   }
   function wait(param){var p = new_pending(0); return [0, p, p];}
   function task(param){var p = new_pending(1); return [0, p, p];}
   function add_task_r(sequence){
    var
     p = new_pending(1),
     node = caml_call2(Lwt_sequence[9], p, sequence),
     callbacks = p[1][1];
    callbacks[2] = [2, node];
    return p;
   }
   function add_task_l(sequence){
    var
     p = new_pending(1),
     node = caml_call2(Lwt_sequence[8], p, sequence),
     callbacks = p[1][1];
    callbacks[2] = [2, node];
    return p;
   }
   function protected$0(p_internal){
    switch(underlying(p_internal)[1][0]){
      case 1:
       return p_internal;
      case 2:
       var
        p = new_pending(1),
        callback =
          function(p_result){
           var p$0 = underlying(p);
           resolve(_j_, 0, p$0, p_result);
           return 0;
          },
        ps = [0, p_internal, 0],
        cell = add_explicitly_removable_callb(ps, callback),
        remove_the_callback =
          function(param){return clear_explicitly_removable_cal(cell, ps);},
        p_callbacks = p[1][1];
       add_cancel_callback(p_callbacks, remove_the_callback);
       return p;
      default: return p_internal;
    }
   }
   function no_cancel(p_internal){
    var match = underlying(p_internal)[1];
    switch(match[0]){
      case 1:
       return p_internal;
      case 2:
       var
        p_callbacks = match[1],
        p = new_pending(0),
        callback =
          function(p_result){
           var p$0 = underlying(p);
           resolve(_k_, 0, p$0, p_result);
           return 0;
          };
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p;
      default: return p_internal;
    }
   }
   function make_into_proxy(outer_promise, user_provided_promise){
    var p = underlying(user_provided_promise);
    if(p === outer_promise) return p;
    var match = p[1];
    switch(match[0]){
      case 1:
       return resolve(_m_, 0, outer_promise, p[1]);
      case 2:
       var
        p_callbacks = match[1],
        outer_callbacks = outer_promise[1][1],
        regular_callbacks =
          concat_regular_callbacks(outer_callbacks[1], p_callbacks[1]),
        cleanups_deferred = outer_callbacks[4] + p_callbacks[4] | 0;
       if(42 < cleanups_deferred)
        var
         cleanups_deferred$0 = 0,
         regular_callbacks$0 = clean_up_callback_cells(regular_callbacks);
       else
        var
         cleanups_deferred$0 = cleanups_deferred,
         regular_callbacks$0 = regular_callbacks;
       var
        l2 = p_callbacks[2],
        l1 = outer_callbacks[2],
        cancel_callbacks =
          typeof l1 === "number"
           ? l2
           : typeof l2 === "number" ? l1 : [0, l1, l2];
       outer_callbacks[1] = regular_callbacks$0;
       outer_callbacks[2] = cancel_callbacks;
       outer_callbacks[4] = cleanups_deferred$0;
       outer_callbacks[3] = p_callbacks[3];
       set_promise_state(p, [3, outer_promise]);
       return outer_promise;
      default: return resolve(_l_, 0, outer_promise, p[1]);
    }
   }
   function symbol_bind(p, f){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var p$2 = underlying(p);
       resolve(_n_, 0, p$2, p_result);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _bc_ = caml_call1(f, v), p$0 = _bc_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(exn);
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var result = p$0[1];
    switch(result[0]){
      case 1:
       return [0, result];
      case 2:
       var
        p_callbacks = result[1],
        match = create_result_promise_and_call(0),
        callback = match[2],
        p$1 = match[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var
        v = result[1],
        _bb_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_o_, function(param){return caml_call1(f, v);}, _bb_);
    }
   }
   function backtrace_bind(add_loc, p, f){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1], p$2 = underlying(p);
       resolve(_p_, 0, p$2, [1, caml_call1(add_loc, exn$0)]);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _ba_ = caml_call1(f, v), p$0 = _ba_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(caml_call1(add_loc, exn));
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; return [0, [1, caml_call1(add_loc, exn)]];
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var
        v = match[1],
        _a$_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_q_, function(param){return caml_call1(f, v);}, _a$_);
    }
   }
   function symbol(f, p){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var p$1 = underlying(p);
       resolve(_s_, 0, p$1, p_result);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _a__ = [0, caml_call1(f, v)], p_result$0 = _a__;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p_result$0 = [1, exn];
      }
      var p$0 = underlying(p);
      resolve(_r_, 0, p$0, p_result$0);
      return 0;
     }
     return [0, p, callback];
    }
    var result = p$0[1];
    switch(result[0]){
      case 1:
       return [0, result];
      case 2:
       var
        p_callbacks = result[1],
        match = create_result_promise_and_call(0),
        callback = match[2],
        p$1 = match[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var
        v = result[1],
        _a7_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_t_,
                function(param){
                 try{var _a9_ = [0, caml_call1(f, v)], _a8_ = _a9_;}
                 catch(exn$0){
                  var exn = caml_wrap_exception(exn$0);
                  if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
                  var _a8_ = [1, exn];
                 }
                 return [0, _a8_];
                },
                _a7_);
    }
   }
   function catch$0(f, h){
    try{var _a5_ = caml_call1(f, 0), p = _a5_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 !== p_result[0]){
       var p$0 = underlying(p);
       resolve(_u_, 0, p$0, p_result);
       return 0;
      }
      var exn = p_result[1];
      current_storage[1] = saved_storage;
      try{var _a6_ = caml_call1(h, exn), p$1 = _a6_;}
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(! run(exn$0)) throw caml_maybe_attach_backtrace(exn$0, 0);
       var p$1 = fail(exn$0);
      }
      var p$2 = underlying(p);
      make_into_proxy(p$2, p$1);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn$0 = match[1],
        _a4_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_v_, function(param){return caml_call1(h, exn$0);}, _a4_);
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default: return p$0;
    }
   }
   function backtrace_catch(add_loc, f, h){
    try{var _a2_ = caml_call1(f, 0), p = _a2_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 !== p_result[0]){
       var p$0 = underlying(p);
       resolve(_w_, 0, p$0, p_result);
       return 0;
      }
      var exn = p_result[1];
      current_storage[1] = saved_storage;
      try{var _a3_ = caml_call1(h, exn), p$1 = _a3_;}
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(! run(exn$0)) throw caml_maybe_attach_backtrace(exn$0, 0);
       var p$1 = fail(caml_call1(add_loc, exn$0));
      }
      var p$2 = underlying(p);
      make_into_proxy(p$2, p$1);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn$0 = match[1],
        _a1_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_x_,
                function(param){
                 return caml_call1(h, caml_call1(add_loc, exn$0));
                },
                _a1_);
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default: return p$0;
    }
   }
   function try_bind(f$0, f, h){
    try{var _aY_ = caml_call1(f$0, 0), p = _aY_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1];
       current_storage[1] = saved_storage;
       try{var _a0_ = caml_call1(h, exn$0), p$2 = _a0_;}
       catch(exn){
        var exn$1 = caml_wrap_exception(exn);
        if(! run(exn$1)) throw caml_maybe_attach_backtrace(exn$1, 0);
        var p$2 = fail(exn$1);
       }
       var p$3 = underlying(p);
       make_into_proxy(p$3, p$2);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aZ_ = caml_call1(f, v), p$0 = _aZ_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(exn);
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn$0 = match[1],
        _aX_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_z_, function(param){return caml_call1(h, exn$0);}, _aX_);
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var
        v = match[1],
        _aW_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_y_, function(param){return caml_call1(f, v);}, _aW_);
    }
   }
   function backtrace_try_bind(add_loc, f$0, f, h){
    try{var _aT_ = caml_call1(f$0, 0), p = _aT_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1];
       current_storage[1] = saved_storage;
       try{var _aV_ = caml_call1(h, exn$0), p$2 = _aV_;}
       catch(exn){
        var exn$1 = caml_wrap_exception(exn);
        if(! run(exn$1)) throw caml_maybe_attach_backtrace(exn$1, 0);
        var p$2 = fail(caml_call1(add_loc, exn$1));
       }
       var p$3 = underlying(p);
       make_into_proxy(p$3, p$2);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aU_ = caml_call1(f, v), p$0 = _aU_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(caml_call1(add_loc, exn));
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn$0 = match[1],
        _aS_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_B_,
                function(param){
                 return caml_call1(h, caml_call1(add_loc, exn$0));
                },
                _aS_);
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var
        v = match[1],
        _aR_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_A_, function(param){return caml_call1(f, v);}, _aR_);
    }
   }
   function finalize(f$0, f){
    function _aO_(e){
     function _aQ_(param){return fail(e);}
     return symbol_bind(caml_call1(f, 0), _aQ_);
    }
    return try_bind
            (f$0,
             function(x){
              function _aP_(param){return return$0(x);}
              return symbol_bind(caml_call1(f, 0), _aP_);
             },
             _aO_);
   }
   function backtrace_finalize(add_loc, f$0, f){
    function _aL_(e){
     function _aN_(param){return fail(caml_call1(add_loc, e));}
     return symbol_bind(caml_call1(f, 0), _aN_);
    }
    return backtrace_try_bind
            (add_loc,
             f$0,
             function(x){
              function _aM_(param){return return$0(x);}
              return symbol_bind(caml_call1(f, 0), _aM_);
             },
             _aL_);
   }
   function on_cancel(p, f){
    var p$0 = underlying(p), match = p$0[1];
    switch(match[0]){
      case 1:
       if(match[1] !== Canceled) return 0;
       var
        _aK_ =
          function(param){
           return [0,
                   0,
                   function(param){
                    return handle_with_async_exception_ho(f, 0);
                   },
                   _C_];
          };
       return run_callback_or_defer_it
               (_D_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                _aK_);
      case 2:
       var callbacks = match[1]; return add_cancel_callback(callbacks, f);
      default: return 0;
    }
   }
   function on_success(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 === result[0]) return 0;
      var v = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, v);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       return 0;
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var
        v = match[1],
        _aJ_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_E_,
                function(param){return handle_with_async_exception_ho(f, v);},
                _aJ_);
    }
   }
   function on_failure(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 !== result[0]) return 0;
      var exn = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, exn);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn = match[1],
        _aI_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_F_,
                function(param){
                 return handle_with_async_exception_ho(f, exn);
                },
                _aI_);
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function on_termination(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, 0);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        _aH_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_H_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                _aH_);
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var
        _aG_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_G_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                _aG_);
    }
   }
   function on_any(p, f, g){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 === result[0]){
       var exn = result[1];
       current_storage[1] = saved_storage;
       return handle_with_async_exception_ho(g, exn);
      }
      var v = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, v);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn = match[1],
        _aF_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_J_,
                function(param){
                 return handle_with_async_exception_ho(g, exn);
                },
                _aF_);
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var
        v = match[1],
        _aE_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_I_,
                function(param){return handle_with_async_exception_ho(f, v);},
                _aE_);
    }
   }
   function wrap_in_cancelable(p_internal){
    var p_underlying = underlying(p_internal);
    switch(p_underlying[1][0]){
      case 1:
       return p_internal;
      case 2:
       var match = task(0), r = match[2], p = match[1];
       on_cancel(p, function(param){return cancel(p_internal);});
       var _aB_ = function(_aD_){return wakeup_exn(r, _aD_);};
       on_any(p_internal, function(_aC_){return wakeup(r, _aC_);}, _aB_);
       return p;
      default: return p_internal;
    }
   }
   function dont_wait(f, h){
    try{var _aA_ = caml_call1(f, 0), p = _aA_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1]; return caml_call1(h, exn$0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(h, exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function async(f){
    try{var _az_ = caml_call1(f, 0), p = _az_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return caml_call1(async_exception_hook[1], exn$0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(async_exception_hook[1], exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function ignore_result(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; throw caml_maybe_attach_backtrace(exn, 0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(async_exception_hook[1], exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function join(ps){
    var
     p = new_pending([1, ps]),
     number_pending_in_ps = [0, 0],
     join_result = [0, _K_];
    function callback(new_result){
     if(1 === new_result[0] && 1 !== join_result[1][0])
      join_result[1] = new_result;
     number_pending_in_ps[1] = number_pending_in_ps[1] - 1 | 0;
     var _aw_ = 0 === number_pending_in_ps[1] ? 1 : 0;
     if(_aw_){
      var p$0 = underlying(p), _ax_ = join_result[1];
      resolve(_L_, 0, underlying(p$0), _ax_);
      var _ay_ = 0;
     }
     else
      var _ay_ = _aw_;
     return _ay_;
    }
    var ps$0 = ps;
    for(;;){
     if(! ps$0)
      return 0 === number_pending_in_ps[1] ? [0, join_result[1]] : p;
     var ps$1 = ps$0[2], p$0 = ps$0[1], p_result = underlying(p$0)[1];
     switch(p_result[0]){
       case 1:
        if(1 !== join_result[1][0]) join_result[1] = p_result;
        var ps$0 = ps$1;
        break;
       case 2:
        var p_callbacks = p_result[1];
        number_pending_in_ps[1] = number_pending_in_ps[1] + 1 | 0;
        add_implicitly_removed_callbac(p_callbacks, callback);
        var ps$0 = ps$1;
        break;
       default: var ps$0 = ps$1;
     }
    }
   }
   function both(p1, p2){
    var
     pair = [0, 0, 0],
     p1$0 =
       symbol_bind(p1, function(v){pair[1] = [0, v]; return return_unit;}),
     p2$0 =
       symbol_bind(p2, function(v){pair[2] = [0, v]; return return_unit;}),
     _au_ = join([0, p1$0, [0, p2$0, 0]]);
    return symbol
            (function(param){
              var _av_ = pair[1], match = pair[2];
              if(_av_ && match){
               var v2 = match[1], v1 = _av_[1];
               return [0, v1, v2];
              }
              throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
             },
             _au_);
   }
   function all(ps){
    if(! ps) return return_nil;
    var _aq_ = ps[2], x = ps[1];
    if(! _aq_) return symbol(function(y){return [0, y, 0];}, x);
    if(_aq_[2]){
     var
      vs = runtime.caml_make_vect(caml_call1(Stdlib_List[1], ps), 0),
      _ar_ =
        function(index, p){
         return symbol_bind
                 (p,
                  function(v){
                   runtime.caml_check_bound(vs, index)[1 + index] = [0, v];
                   return return_unit;
                  });
        },
      _as_ = join(caml_call1(caml_call1(Stdlib_List[21], _ar_), ps));
     return symbol
             (function(param){
               var i$1 = vs.length - 1 - 1 | 0, i = i$1, acc = 0;
               for(;;){
                if(0 > i) return acc;
                var match = vs[1 + i];
                if(! match)
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _N_], 1);
                var
                 x = match[1],
                 acc$0 = [0, x, acc],
                 i$0 = i - 1 | 0,
                 i = i$0,
                 acc = acc$0;
               }
              },
              _as_);
    }
    var y = _aq_[1], _at_ = both(x, y);
    return symbol
            (function(param){
              var y = param[2], x = param[1];
              return [0, x, [0, y, 0]];
             },
             _at_);
   }
   function count_resolved_promises_in(ps){
    var total$1 = 0, ps$2 = ps;
    a:
    for(;;){
     if(! ps$2) return [0, total$1];
     var ps$3 = ps$2[2], p$0 = ps$2[1];
     switch(underlying(p$0)[1][0]){
       case 1:
        break a;
       case 2:
        var ps$2 = ps$3; break;
       default: var total$2 = total$1 + 1 | 0, total$1 = total$2, ps$2 = ps$3;
     }
    }
    var
     rejected$1 = [0, p$0, 0],
     total = 1,
     rejected = rejected$1,
     ps$0 = ps$3;
    for(;;){
     if(! ps$0) return [1, [0, total, rejected]];
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        var
         rejected$0 = [0, p, rejected],
         total$0 = total + 1 | 0,
         total = total$0,
         rejected = rejected$0,
         ps$0 = ps$1;
        break;
       case 2:
        var ps$0 = ps$1; break;
       default: var ps$0 = ps$1;
     }
    }
   }
   function nth_resolved(ps, n){
    var ps$0 = ps, n$0 = n;
    for(;;){
     if(! ps$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        if(0 >= n$0) return p;
        var n$2 = n$0 - 1 | 0, ps$0 = ps$1, n$0 = n$2;
        break;
       case 2:
        var ps$0 = ps$1; break;
       default:
        if(0 >= n$0) return p; var n$1 = n$0 - 1 | 0, ps$0 = ps$1, n$0 = n$1;
     }
    }
   }
   function nth_resolved_and_cancel_pendin(ps, n){
    var ps$0 = ps, n$0 = n;
    for(;;){
     if(! ps$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        if(0 >= n$0){caml_call2(Stdlib_List[18], cancel, ps$1); return p;}
        var n$2 = n$0 - 1 | 0, ps$0 = ps$1, n$0 = n$2;
        break;
       case 2:
        cancel(p); var ps$0 = ps$1; break;
       default:
        if(0 >= n$0){caml_call2(Stdlib_List[18], cancel, ps$1); return p;}
        var n$1 = n$0 - 1 | 0, ps$0 = ps$1, n$0 = n$1;
     }
    }
   }
   var
    prng =
      [246, function(_ap_){return caml_call1(Stdlib_Random[15][1], [0]);}];
   function choose(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_choose_would_return_a_);
    var match = count_resolved_promises_in(ps);
    if(0 === match[0]){
     var n = match[1];
     if(0 === n){
      var
       p = new_pending([1, ps]),
       callback =
         function(result){
          var p$0 = underlying(p);
          resolve(_Q_, 0, p$0, result);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      return p;
     }
     if(1 === n) return nth_resolved(ps, 0);
     var _al_ = caml_obj_tag(prng);
     a:
     if(250 === _al_)
      var _am_ = prng[1];
     else{
      if(246 !== _al_ && 244 !== _al_){var _am_ = prng; break a;}
      var _am_ = caml_call1(CamlinternalLazy[2], prng);
     }
     return nth_resolved(ps, caml_call2(Stdlib_Random[15][5], _am_, n));
    }
    var
     match$0 = match[1],
     ps$0 = match$0[2],
     n$0 = match$0[1],
     _an_ = caml_obj_tag(prng);
    a:
    if(250 === _an_)
     var _ao_ = prng[1];
    else{
     if(246 !== _an_ && 244 !== _an_){var _ao_ = prng; break a;}
     var _ao_ = caml_call1(CamlinternalLazy[2], prng);
    }
    return nth_resolved(ps$0, caml_call2(Stdlib_Random[15][5], _ao_, n$0));
   }
   function pick(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_pick_would_return_a_pr);
    var match = count_resolved_promises_in(ps);
    if(0 === match[0]){
     var n = match[1];
     if(0 === n){
      var
       p = new_pending([1, ps]),
       callback =
         function(result){
          caml_call2(Stdlib_List[18], cancel, ps);
          var p$0 = underlying(p);
          resolve(_R_, 0, p$0, result);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      return p;
     }
     if(1 === n) return nth_resolved_and_cancel_pendin(ps, 0);
     var _ah_ = caml_obj_tag(prng);
     a:
     if(250 === _ah_)
      var _ai_ = prng[1];
     else{
      if(246 !== _ah_ && 244 !== _ah_){var _ai_ = prng; break a;}
      var _ai_ = caml_call1(CamlinternalLazy[2], prng);
     }
     return nth_resolved_and_cancel_pendin
             (ps, caml_call2(Stdlib_Random[15][5], _ai_, n));
    }
    var match$0 = match[1], qs = match$0[2], n$0 = match$0[1];
    caml_call2(Stdlib_List[18], cancel, ps);
    var _aj_ = caml_obj_tag(prng);
    a:
    if(250 === _aj_)
     var _ak_ = prng[1];
    else{
     if(246 !== _aj_ && 244 !== _aj_){var _ak_ = prng; break a;}
     var _ak_ = caml_call1(CamlinternalLazy[2], prng);
    }
    return nth_resolved(qs, caml_call2(Stdlib_Random[15][5], _ak_, n$0));
   }
   function collect_fulfilled_promises_aft(results, ps){
    var results$0 = results, ps$0 = ps;
    for(;;){
     if(! ps$0) return [0, caml_call1(Stdlib_List[10], results$0)];
     var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
     switch(result[0]){
       case 1:
        return result;
       case 2:
        var ps$0 = ps$1; break;
       default:
        var
         v = result[1],
         results$1 = [0, v, results$0],
         results$0 = results$1,
         ps$0 = ps$1;
     }
    }
   }
   function nchoose(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_nchoose_would_return_a);
    var ps$2 = ps;
    a:
    for(;;){
     if(! ps$2){
      var
       p$1 = new_pending([1, ps]),
       callback =
         function(result){
          var
           p = underlying(p$1),
           result$0 = collect_fulfilled_promises_aft(0, ps);
          resolve(_S_, 0, p, result$0);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      return p$1;
     }
     var ps$3 = ps$2[2], p$0 = ps$2[1], result$0 = underlying(p$0)[1];
     switch(result$0[0]){
       case 1:
        return [0, result$0];
       case 2:
        var ps$2 = ps$3; break;
       default: break a;
     }
    }
    var v$0 = result$0[1], acc$1 = [0, v$0, 0], acc = acc$1, ps$0 = ps$3;
    for(;;){
     if(! ps$0) return return$0(caml_call1(Stdlib_List[10], acc));
     var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
     switch(result[0]){
       case 1:
        return [0, result];
       case 2:
        var ps$0 = ps$1; break;
       default:
        var v = result[1], acc$0 = [0, v, acc], acc = acc$0, ps$0 = ps$1;
     }
    }
   }
   function npick(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_npick_would_return_a_p);
    var ps$2 = ps;
    a:
    for(;;){
     if(! ps$2){
      var
       p$1 = new_pending([1, ps]),
       callback =
         function(result){
          var
           p = underlying(p$1),
           result$0 = collect_fulfilled_promises_aft(0, ps);
          caml_call2(Stdlib_List[18], cancel, ps);
          resolve(_T_, 0, p, result$0);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      return p$1;
     }
     var ps$3 = ps$2[2], p$0 = ps$2[1], result$0 = underlying(p$0)[1];
     switch(result$0[0]){
       case 1:
        caml_call2(Stdlib_List[18], cancel, ps); return [0, result$0];
       case 2:
        var ps$2 = ps$3; break;
       default: break a;
     }
    }
    var v$0 = result$0[1], acc$1 = [0, v$0, 0], acc = acc$1, ps$0 = ps$3;
    for(;;){
     if(! ps$0){
      caml_call2(Stdlib_List[18], cancel, ps);
      return return$0(caml_call1(Stdlib_List[10], acc));
     }
     var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
     switch(result[0]){
       case 1:
        caml_call2(Stdlib_List[18], cancel, ps); return [0, result];
       case 2:
        var ps$0 = ps$1; break;
       default:
        var v = result[1], acc$0 = [0, v, acc], acc = acc$0, ps$0 = ps$1;
     }
    }
   }
   function nchoose_split(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_nchoose_split_would_re);
    var pending_acc = 0, ps$2 = ps;
    a:
    for(;;){
     if(! ps$2){
      var
       p = new_pending([1, ps]),
       callback =
         function(result$0){
          var
           to_resolve = underlying(p),
           fulfilled = 0,
           pending = 0,
           ps$0 = ps;
          for(;;){
           if(ps$0){
            var
             ps$1 = ps$0[2],
             p_internal = ps$0[1],
             result = underlying(p_internal)[1];
            switch(result[0]){
              case 1:
               resolve(_U_, 0, to_resolve, result); break;
              case 2:
               var
                pending$0 = [0, p_internal, pending],
                pending = pending$0,
                ps$0 = ps$1;
               continue;
              default:
               var
                v = result[1],
                fulfilled$0 = [0, v, fulfilled],
                fulfilled = fulfilled$0,
                ps$0 = ps$1;
               continue;
            }
           }
           else{
            var _ag_ = caml_call1(Stdlib_List[10], pending);
            resolve
             (_V_,
              0,
              to_resolve,
              [0, [0, caml_call1(Stdlib_List[10], fulfilled), _ag_]]);
           }
           return 0;
          }
         };
      add_explicitly_removable_callb$0(ps, callback);
      return p;
     }
     var
      ps$3 = ps$2[2],
      p_internal$0 = ps$2[1],
      result$0 = underlying(p_internal$0)[1];
     switch(result$0[0]){
       case 1:
        return [0, result$0];
       case 2:
        var
         pending_acc$0 = [0, p_internal$0, pending_acc],
         pending_acc = pending_acc$0,
         ps$2 = ps$3;
        break;
       default: break a;
     }
    }
    var
     v$0 = result$0[1],
     results$1 = [0, v$0, 0],
     results = results$1,
     pending = pending_acc,
     ps$0 = ps$3;
    for(;;){
     if(! ps$0)
      return return$0([0, caml_call1(Stdlib_List[10], results), pending]);
     var
      ps$1 = ps$0[2],
      p_internal = ps$0[1],
      result = underlying(p_internal)[1];
     switch(result[0]){
       case 1:
        return [0, result];
       case 2:
        var
         pending$0 = [0, p_internal, pending],
         pending = pending$0,
         ps$0 = ps$1;
        break;
       default:
        var
         v = result[1],
         results$0 = [0, v, results],
         results = results$0,
         ps$0 = ps$1;
     }
    }
   }
   function state(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; return [1, exn];
      case 2:
       return 0;
      default: var v = match[1]; return [0, v];
    }
   }
   function debug_state_is(expected_state, p){
    return return$0(runtime.caml_equal(state(p), expected_state));
   }
   function is_sleeping(p){
    switch(underlying(p)[1][0]){
      case 1:
       return 0;
      case 2:
       return 1;
      default: return 0;
    }
   }
   function poll(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var e = match[1]; throw caml_maybe_attach_backtrace(e, 0);
      case 2:
       return 0;
      default: var v = match[1]; return [0, v];
    }
   }
   function apply(f, x){
    try{var _af_ = caml_call1(f, x); return _af_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap(f){
    try{var _ae_ = return$0(caml_call1(f, 0)); return _ae_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap1(f, x1){
    try{var _ad_ = return$0(caml_call1(f, x1)); return _ad_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap2(f, x1, x2){
    try{var _ac_ = return$0(caml_call2(f, x1, x2)); return _ac_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap3(f, x1, x2, x3){
    try{var _ab_ = return$0(caml_call3(f, x1, x2, x3)); return _ab_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap4(f, x1, x2, x3, x4){
    try{var _aa_ = return$0(caml_call4(f, x1, x2, x3, x4)); return _aa_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap5(f, x1, x2, x3, x4, x5){
    try{var _$_ = return$0(caml_call5(f, x1, x2, x3, x4, x5)); return _$_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap6(f, x1, x2, x3, x4, x5, x6){
    try{var ___ = return$0(caml_call6(f, x1, x2, x3, x4, x5, x6)); return ___;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap7(f, x1, x2, x3, x4, x5, x6, x7){
    try{
     var _Z_ = return$0(caml_call7(f, x1, x2, x3, x4, x5, x6, x7));
     return _Z_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    pause_hook = [0, function(_Y_){return;}],
    paused = caml_call1(Lwt_sequence[4], 0),
    _W_ = [0, 0];
   function pause(param){
    var p = add_task_r(paused);
    _W_[1]++;
    caml_call1(pause_hook[1], _W_[1]);
    return p;
   }
   function wakeup_paused(param){
    if(caml_call1(Lwt_sequence[6], paused)){_W_[1] = 0; return 0;}
    var tmp = caml_call1(Lwt_sequence[4], 0);
    caml_call2(Lwt_sequence[16], paused, tmp);
    _W_[1] = 0;
    function _X_(r){return wakeup(r, 0);}
    return caml_call2(Lwt_sequence[17], _X_, tmp);
   }
   function register_pause_notifier(f){pause_hook[1] = f; return 0;}
   function abandon_paused(param){
    caml_call1(Lwt_sequence[5], paused);
    _W_[1] = 0;
    return 0;
   }
   function paused_count(param){return _W_[1];}
   function map(t, f){return symbol(f, t);}
   function bind(t, f){return symbol_bind(t, f);}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, map, bind, both, Open_on_rhs],
    Let_syntax$0 = [0, Let_syntax];
   function symbol$0(f, p){return symbol_bind(p, f);}
   function symbol$1(p, f){return symbol(f, p);}
   function symbol$2(p$0, p){return join([0, p$0, [0, p, 0]]);}
   function symbol$3(p$0, p){return choose([0, p$0, [0, p, 0]]);}
   var Let_syntax$1 = Let_syntax$0[1];
   function let$0(x, f){return symbol(f, x);}
   var
    Syntax = [0, symbol_bind, both, let$0, both],
    Lwt =
      [0,
       wait,
       wakeup_later,
       wakeup_later_exn,
       return$0,
       fail,
       symbol_bind,
       catch$0,
       finalize,
       try_bind,
       dont_wait,
       async,
       async_exception_hook,
       both,
       join,
       all,
       pick,
       choose,
       npick,
       nchoose,
       nchoose_split,
       Canceled,
       task,
       cancel,
       on_cancel,
       protected$0,
       no_cancel,
       wrap_in_cancelable,
       symbol,
       on_success,
       on_failure,
       on_termination,
       on_any,
       [0,
        symbol_bind,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$0,
        symbol,
        Let_syntax$1],
       Let_syntax$0,
       Syntax,
       return_unit,
       return_none,
       return_nil,
       return_true,
       return_false,
       return_some,
       return_ok,
       return_error,
       fail_with,
       fail_invalid_arg,
       of_result,
       wakeup_later_result,
       state,
       new_key,
       get,
       with_value,
       wakeup,
       wakeup_exn,
       wakeup_result,
       add_task_r,
       add_task_l,
       pause,
       wakeup_paused,
       paused_count,
       register_pause_notifier,
       abandon_paused,
       wrap,
       wrap1,
       wrap2,
       wrap3,
       wrap4,
       wrap5,
       wrap6,
       wrap7,
       symbol_bind,
       symbol$1,
       symbol$3,
       symbol$2,
       symbol$0,
       symbol,
       is_sleeping,
       ignore_result,
       [0, handle_all, handle_all_except_runtime, set, run],
       poll,
       apply,
       backtrace_bind,
       backtrace_catch,
       backtrace_finalize,
       backtrace_try_bind,
       abandon_wakeups,
       debug_state_is];
   runtime.caml_register_global(71, Lwt, "Lwt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_switch
//# unitInfo: Requires: Lwt, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Off = [248, "Lwt_switch.Off", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, [0, [0, 0]]];}
   function is_on(switch$0){return switch$0[1] ? 1 : 0;}
   function check(param){
    if(param && ! param[1][1]) throw caml_maybe_attach_backtrace(Off, 1);
    return 0;
   }
   function add_hook(switch$0, hook){
    if(! switch$0) return 0;
    var match = switch$0[1][1];
    if(! match) throw caml_maybe_attach_backtrace(Off, 1);
    var os = match[1];
    os[1] = [0, hook, os[1]];
    return 0;
   }
   function add_hook_or_exec(switch$0, hook){
    if(! switch$0) return Lwt[36];
    var match = switch$0[1][1];
    if(! match) return caml_call1(hook, 0);
    var os = match[1];
    os[1] = [0, hook, os[1]];
    return Lwt[36];
   }
   function turn_off(switch$0){
    var _c_ = switch$0[1];
    if(! _c_) return Lwt[36];
    var hooks = _c_[1][1];
    switch$0[1] = 0;
    function _d_(hook){return caml_call2(Lwt[80], hook, 0);}
    var _e_ = caml_call2(Stdlib_List[20], _d_, hooks);
    return caml_call1(Lwt[14], _e_);
   }
   function with_switch(fn){
    var switch$0 = create(0);
    function _a_(param){return turn_off(switch$0);}
    function _b_(param){return caml_call1(fn, switch$0);}
    return caml_call2(Lwt[8], _b_, _a_);
   }
   var
    Lwt_switch =
      [0,
       create,
       with_switch,
       is_on,
       turn_off,
       Off,
       check,
       add_hook,
       add_hook_or_exec];
   runtime.caml_register_global(3, Lwt_switch, "Lwt_switch");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_seq
//# unitInfo: Requires: Lwt, Stdlib, Stdlib__List, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    return_nil = caml_call1(Lwt[4], 0),
    _h_ =
      [0,
       [11,
        "Lwt_seq.iter_n: max_concurrency must be > 0, ",
        [4, 0, 0, 0, [11, " given", 0]]],
       "Lwt_seq.iter_n: max_concurrency must be > 0, %d given"];
   function empty(param){return return_nil;}
   function return$0(x, param){return caml_call1(Lwt[4], [0, x, empty]);}
   function return_lwt(x, param){
    function _bw_(x){return [0, x, empty];}
    return caml_call2(Lwt[35][3], x, _bw_);
   }
   function cons(x, t, param){return caml_call1(Lwt[4], [0, x, t]);}
   function cons_lwt(x, t, param){
    function _bv_(x){return [0, x, t];}
    return caml_call2(Lwt[35][3], x, _bv_);
   }
   function _a_(seq1, seq2, param){
    function _br_(param){
     if(! param) return caml_call1(seq2, 0);
     var
      next = param[2],
      x = param[1],
      _bt_ = [0, x, function(_bu_){return _a_(next, seq2, _bu_);}];
     return caml_call1(Lwt[4], _bt_);
    }
    var _bs_ = caml_call1(seq1, 0);
    return caml_call2(Lwt[33][1], _bs_, _br_);
   }
   function append(seq1, seq2, param){
    function _bn_(param){
     if(! param) return caml_call1(seq2, 0);
     var
      next = param[2],
      x = param[1],
      _bp_ = [0, x, function(_bq_){return _a_(next, seq2, _bq_);}];
     return caml_call1(Lwt[4], _bp_);
    }
    var _bo_ = caml_call2(Lwt[80], seq1, 0);
    return caml_call2(Lwt[33][1], _bo_, _bn_);
   }
   function _b_(f, seq, param){
    function _bk_(param){
     if(! param) return 0;
     var next = param[2], x = param[1], x$0 = caml_call1(f, x);
     return [0, x$0, function(_bm_){return _b_(f, next, _bm_);}];
    }
    var _bl_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][2], _bl_, _bk_);
   }
   function map(f, seq, param){
    function _bh_(param){
     if(! param) return 0;
     var next = param[2], x = param[1], x$0 = caml_call1(f, x);
     return [0, x$0, function(_bj_){return _b_(f, next, _bj_);}];
    }
    var _bi_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][2], _bi_, _bh_);
   }
   function _c_(f, seq, param){
    function _bc_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _be_(x){
      return [0, x, function(_bg_){return _c_(f, next, _bg_);}];
     }
     var _bf_ = caml_call1(f, x);
     return caml_call2(Lwt[35][3], _bf_, _be_);
    }
    var _bd_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _bd_, _bc_);
   }
   function map_s(f, seq, param){
    function _a9_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _a$_(x){
      return [0, x, function(_bb_){return _c_(f, next, _bb_);}];
     }
     var _ba_ = caml_call1(f, x);
     return caml_call2(Lwt[35][3], _ba_, _a$_);
    }
    var _a__ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _a__, _a9_);
   }
   function _d_(f, seq, param){
    function _a5_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1], x$0 = caml_call1(f, x);
     if(! x$0) return _d_(f, next, 0);
     var
      y = x$0[1],
      _a7_ = [0, y, function(_a8_){return _d_(f, next, _a8_);}];
     return caml_call1(Lwt[4], _a7_);
    }
    var _a6_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _a6_, _a5_);
   }
   function filter_map(f, seq, param){
    function _a1_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1], x$0 = caml_call1(f, x);
     if(! x$0) return _d_(f, next, 0);
     var
      y = x$0[1],
      _a3_ = [0, y, function(_a4_){return _d_(f, next, _a4_);}];
     return caml_call1(Lwt[4], _a3_);
    }
    var _a2_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _a2_, _a1_);
   }
   function _e_(f, seq, param){
    function _aV_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _aX_(x){
      if(! x) return _e_(f, next, 0);
      var y = x[1], _aZ_ = [0, y, function(_a0_){return _e_(f, next, _a0_);}];
      return caml_call1(Lwt[4], _aZ_);
     }
     var _aY_ = caml_call1(f, x);
     return caml_call2(Lwt[35][1], _aY_, _aX_);
    }
    var _aW_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _aW_, _aV_);
   }
   function filter_map_s(f, seq, param){
    function _aP_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _aR_(x){
      if(! x) return _e_(f, next, 0);
      var y = x[1], _aT_ = [0, y, function(_aU_){return _e_(f, next, _aU_);}];
      return caml_call1(Lwt[4], _aT_);
     }
     var _aS_ = caml_call1(f, x);
     return caml_call2(Lwt[35][1], _aS_, _aR_);
    }
    var _aQ_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _aQ_, _aP_);
   }
   function _f_(f, seq, param){
    function _aL_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1], ok = caml_call1(f, x);
     if(! ok) return _f_(f, next, 0);
     var _aN_ = [0, x, function(_aO_){return _f_(f, next, _aO_);}];
     return caml_call1(Lwt[4], _aN_);
    }
    var _aM_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _aM_, _aL_);
   }
   function filter(f, seq, param){
    function _aH_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1], ok = caml_call1(f, x);
     if(! ok) return _f_(f, next, 0);
     var _aJ_ = [0, x, function(_aK_){return _f_(f, next, _aK_);}];
     return caml_call1(Lwt[4], _aJ_);
    }
    var _aI_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _aI_, _aH_);
   }
   function _g_(f, seq, param){
    function _aB_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _aD_(ok){
      if(! ok) return _g_(f, next, 0);
      var _aF_ = [0, x, function(_aG_){return _g_(f, next, _aG_);}];
      return caml_call1(Lwt[4], _aF_);
     }
     var _aE_ = caml_call1(f, x);
     return caml_call2(Lwt[35][1], _aE_, _aD_);
    }
    var _aC_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _aC_, _aB_);
   }
   function filter_s(f, seq, param){
    function _av_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _ax_(ok){
      if(! ok) return _g_(f, next, 0);
      var _az_ = [0, x, function(_aA_){return _g_(f, next, _aA_);}];
      return caml_call1(Lwt[4], _az_);
     }
     var _ay_ = caml_call1(f, x);
     return caml_call2(Lwt[35][1], _ay_, _ax_);
    }
    var _aw_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _aw_, _av_);
   }
   function flat_map_app(f, seq, tail, param){
    function _ap_(param){
     if(param){
      var
       next = param[2],
       x = param[1],
       _at_ =
         [0, x, function(_au_){return flat_map_app(f, next, tail, _au_);}];
      return caml_call1(Lwt[4], _at_);
     }
     function _ar_(param){
      if(! param) return return_nil;
      var next = param[2], x = param[1];
      return flat_map_app(f, caml_call1(f, x), next, 0);
     }
     var _as_ = caml_call1(tail, 0);
     return caml_call2(Lwt[33][1], _as_, _ar_);
    }
    var _aq_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _aq_, _ap_);
   }
   function flat_map(f, seq, param){
    function _an_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     return flat_map_app(f, caml_call1(f, x), next, 0);
    }
    var _ao_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _ao_, _an_);
   }
   function fold_left(f, acc, seq){
    function aux(f, acc, seq){
     function _al_(param){
      if(! param) return caml_call1(Lwt[4], acc);
      var next = param[2], x = param[1], acc$0 = caml_call2(f, acc, x);
      return aux(f, acc$0, next);
     }
     var _am_ = caml_call1(seq, 0);
     return caml_call2(Lwt[33][1], _am_, _al_);
    }
    function _aj_(param){
     if(! param) return caml_call1(Lwt[4], acc);
     var next = param[2], x = param[1], acc$0 = caml_call2(f, acc, x);
     return aux(f, acc$0, next);
    }
    var _ak_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _ak_, _aj_);
   }
   function fold_left_s(f, acc, seq){
    function aux(f, acc, seq){
     function _af_(param){
      if(! param) return caml_call1(Lwt[4], acc);
      var next = param[2], x = param[1];
      function _ah_(acc){return aux(f, acc, next);}
      var _ai_ = caml_call2(f, acc, x);
      return caml_call2(Lwt[35][1], _ai_, _ah_);
     }
     var _ag_ = caml_call1(seq, 0);
     return caml_call2(Lwt[33][1], _ag_, _af_);
    }
    function _ab_(param){
     if(! param) return caml_call1(Lwt[4], acc);
     var next = param[2], x = param[1];
     function _ad_(acc){return aux(f, acc, next);}
     var _ae_ = caml_call2(f, acc, x);
     return caml_call2(Lwt[35][1], _ae_, _ad_);
    }
    var _ac_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _ac_, _ab_);
   }
   function iter(f, seq){
    function aux(seq){
     function _$_(param){
      if(! param) return Lwt[36];
      var next = param[2], x = param[1];
      caml_call1(f, x);
      return aux(next);
     }
     var _aa_ = caml_call1(seq, 0);
     return caml_call2(Lwt[33][1], _aa_, _$_);
    }
    function _Z_(param){
     if(! param) return Lwt[36];
     var next = param[2], x = param[1];
     caml_call1(f, x);
     return aux(next);
    }
    var ___ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], ___, _Z_);
   }
   function iter_s(f, seq){
    function aux(seq){
     function _V_(param){
      if(! param) return Lwt[36];
      var next = param[2], x = param[1];
      function _X_(param){return aux(next);}
      var _Y_ = caml_call1(f, x);
      return caml_call2(Lwt[35][1], _Y_, _X_);
     }
     var _W_ = caml_call1(seq, 0);
     return caml_call2(Lwt[33][1], _W_, _V_);
    }
    function _R_(param){
     if(! param) return Lwt[36];
     var next = param[2], x = param[1];
     function _T_(param){return aux(next);}
     var _U_ = caml_call1(f, x);
     return caml_call2(Lwt[35][1], _U_, _T_);
    }
    var _S_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _S_, _R_);
   }
   function iter_p(f, seq){
    function aux(acc, seq){
     function _P_(param){
      if(! param) return caml_call1(Lwt[14], acc);
      var next = param[2], x = param[1], p = caml_call1(f, x);
      return aux([0, p, acc], next);
     }
     var _Q_ = caml_call1(seq, 0);
     return caml_call2(Lwt[33][1], _Q_, _P_);
    }
    var acc = 0;
    function _N_(param){
     if(! param) return caml_call1(Lwt[14], acc);
     var next = param[2], x = param[1], p = caml_call1(f, x);
     return aux([0, p, acc], next);
    }
    var _O_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _O_, _N_);
   }
   function iter_n(opt, f, seq){
    if(opt)
     var sth = opt[1], max_concurrency = sth;
    else
     var max_concurrency = 1;
    if(max_concurrency <= 0){
     var message = caml_call2(Stdlib_Printf[4], _h_, max_concurrency);
     caml_call1(Stdlib[1], message);
    }
    function loop(running, available, seq){
     function _G_(param){
      var available = param[2], running = param[1];
      function _L_(param){
       if(! param) return caml_call1(Lwt[14], running);
       var seq = param[2], elt = param[1];
       return loop([0, caml_call1(f, elt), running], available - 1 | 0, seq);
      }
      var _M_ = caml_call1(seq, 0);
      return caml_call2(Lwt[33][1], _M_, _L_);
     }
     if(0 < available)
      var _H_ = caml_call1(Lwt[4], [0, running, available]);
     else
      var
       _I_ =
         function(param){
          var
           running = param[2],
           complete = param[1],
           _K_ =
             [0,
              running,
              available + caml_call1(Stdlib_List[1], complete) | 0];
          return caml_call1(Lwt[4], _K_);
         },
       _J_ = caml_call1(Lwt[20], running),
       _H_ = caml_call2(Lwt[33][1], _J_, _I_);
     return caml_call2(Lwt[33][1], _H_, _G_);
    }
    return loop
            (0,
             max_concurrency,
             function(param){return caml_call2(Lwt[80], seq, 0);});
   }
   function unfold(f, u, param){
    try{var val = caml_call1(f, u);}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0);
     if(caml_call1(Lwt[78][4], exc))
      throw caml_maybe_attach_backtrace(exc, 0);
     throw caml_maybe_attach_backtrace(exc, 0);
    }
    if(! val) return return_nil;
    var
     match = val[1],
     u$0 = match[2],
     x = match[1],
     _E_ = [0, x, function(_F_){return unfold(f, u$0, _F_);}];
    return caml_call1(Lwt[4], _E_);
   }
   function _i_(f, u, param){
    function _A_(x){
     if(! x) return return_nil;
     var
      match = x[1],
      u = match[2],
      x$0 = match[1],
      _C_ = [0, x$0, function(_D_){return _i_(f, u, _D_);}];
     return caml_call1(Lwt[4], _C_);
    }
    var _B_ = caml_call1(f, u);
    return caml_call2(Lwt[35][1], _B_, _A_);
   }
   function unfold_lwt(f, u, param){
    function _w_(x){
     if(! x) return return_nil;
     var
      match = x[1],
      u = match[2],
      x$0 = match[1],
      _y_ = [0, x$0, function(_z_){return _i_(f, u, _z_);}];
     return caml_call1(Lwt[4], _y_);
    }
    var _x_ = caml_call2(Lwt[80], f, u);
    return caml_call2(Lwt[35][1], _x_, _w_);
   }
   function of_list(l, param){
    if(l)
     var
      t = l[2],
      h = l[1],
      _u_ = [0, h, function(_v_){return of_list(t, _v_);}];
    else
     var _u_ = 0;
    return caml_call1(Lwt[4], _u_);
   }
   function to_list(seq){
    function aux(f, seq){
     function _r_(param){
      if(param){
       var t = param[2], h = param[1];
       return aux(function(x){return caml_call1(f, [0, h, x]);}, t);
      }
      var _t_ = caml_call1(f, 0);
      return caml_call1(Lwt[4], _t_);
     }
     var _s_ = caml_call1(seq, 0);
     return caml_call2(Lwt[6], _s_, _r_);
    }
    var _q_ = caml_call1(Lwt[80], seq);
    return aux(function(x){return x;}, _q_);
   }
   function of_seq(seq, param){
    try{var val = caml_call1(seq, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(caml_call1(Lwt[78][4], exn))
      throw caml_maybe_attach_backtrace(exn, 0);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    if(! val) return return_nil;
    var
     next = val[2],
     x = val[1],
     _o_ = [0, x, function(_p_){return of_seq(next, _p_);}];
    return caml_call1(Lwt[4], _o_);
   }
   function _j_(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return return_nil;
    var next = match[2], x = match[1];
    function _m_(x){
     function next$0(_n_){return _j_(next, _n_);}
     return [0, x, next$0];
    }
    return caml_call2(Lwt[35][3], x, _m_);
   }
   function of_seq_lwt(seq, param){
    try{var val = caml_call1(seq, 0);}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0);
     if(caml_call1(Lwt[78][4], exc))
      throw caml_maybe_attach_backtrace(exc, 0);
     throw caml_maybe_attach_backtrace(exc, 0);
    }
    if(! val) return return_nil;
    var next = val[2], x = val[1];
    function _k_(x){
     function next$0(_l_){return _j_(next, _l_);}
     return [0, x, next$0];
    }
    return caml_call2(Lwt[35][3], x, _k_);
   }
   var
    Lwt_seq =
      [0,
       empty,
       return$0,
       return_lwt,
       cons,
       cons_lwt,
       append,
       map,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       flat_map,
       fold_left,
       fold_left_s,
       iter,
       iter_s,
       iter_p,
       iter_n,
       unfold,
       unfold_lwt,
       to_list,
       of_list,
       of_seq,
       of_seq_lwt];
   runtime.caml_register_global(5, Lwt_seq, "Lwt_seq");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_stream
//# unitInfo: Requires: CamlinternalOO, Lwt, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__List, Stdlib__Printf, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$6 = "",
    cst_blocked = "blocked",
    cst_close = "close",
    cst_closed = "closed",
    cst_count = "count",
    cst_push = "push",
    cst_resize = "resize",
    cst_set_reference = "set_reference",
    cst_size = "size",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$3 = "    ",
    cst$4 = "   ",
    cst$5 = " |",
    cst = cst$6,
    cst$0 = cst$6,
    cst$1 = cst$6,
    cst$2 = cst$6,
    shared =
      [0,
       cst_size,
       cst_set_reference,
       cst_resize,
       cst_push,
       cst_count,
       cst_closed,
       cst_close,
       cst_blocked],
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    CamlinternalOO = global_data.CamlinternalOO,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Array = global_data.Stdlib__Array,
    Closed = [248, "Lwt_stream.Closed", caml_fresh_oo_id(0)],
    Full = [248, "Lwt_stream.Full", caml_fresh_oo_id(0)],
    Empty = [248, "Lwt_stream.Empty", caml_fresh_oo_id(0)],
    _f_ = [0, [4, 6, [0, 2, 2], 0, [12, 32, 0]], "%02x "],
    _e_ = [0, [4, 6, [0, 2, 8], 0, [11, "|  ", 0]], "%08x|  "],
    cst_Lwt_stream_parse = "Lwt_stream.parse",
    _d_ =
      [0,
       [11,
        "Lwt_stream.iter_n: max_concurrency must be > 0, ",
        [4, 0, 0, 0, [11, " given", 0]]],
       "Lwt_stream.iter_n: max_concurrency must be > 0, %d given"],
    cst_Lwt_stream_create_bounded = "Lwt_stream.create_bounded",
    cst_Lwt_stream_bounded_push_re = "Lwt_stream.bounded_push#resize",
    cst_Lwt_stream_clone = "Lwt_stream.clone",
    _a_ =
      [0,
       cst_blocked,
       cst_close,
       cst_push,
       cst_count,
       cst_size,
       cst_set_reference,
       cst_resize,
       cst_closed],
    _b_ = [0, cst_closed];
   function new_node(param){
    var node = [];
    runtime.caml_update_dummy(node, [0, node, 0]);
    return node;
   }
   function clone(s){
    if(3 === s[1][0]) caml_call1(Stdlib[1], cst_Lwt_stream_clone);
    return [0, s[1], s[2], s[3], s[4], s[5]];
   }
   function from_source(source){
    var
     node = new_node(0),
     match = caml_call1(Lwt[1], 0),
     close = match[2],
     closed = match[1];
    return [0, source, close, closed, node, [0, node]];
   }
   function from(f){return from_source([0, [0, f, Lwt[36]]]);}
   function from_direct(f){return from_source([1, f]);}
   function closed(s){return s[3];}
   function is_closed(s){return 1 - caml_call1(Lwt[76], s[3]);}
   function enqueue(e, last){
    var node = last[1], new_last = new_node(0);
    node[2] = e;
    node[1] = new_last;
    last[1] = new_last;
    return;
   }
   function enqueue$0(e, s){return enqueue(e, s[5]);}
   function create_with_reference(param){
    var
     match = caml_call1(Lwt[1], 0),
     push_signal_resolver = match[2],
     push_signal = match[1],
     push_signal_resolver$0 = [0, push_signal_resolver],
     source = [0, push_signal, 0, 0],
     t = from_source([2, source]),
     close = t[2],
     closed = t[3],
     last = t[5];
    function push(x){
     if(1 - caml_call1(Lwt[76], closed))
      throw caml_maybe_attach_backtrace(Closed, 1);
     enqueue(x, last);
     if(source[2]){
      source[2] = 0;
      var
       old_push_signal_resolver = push_signal_resolver$0[1],
       match = caml_call1(Lwt[1], 0),
       new_push_signal_resolver = match[2],
       new_waiter = match[1];
      source[1] = new_waiter;
      push_signal_resolver$0[1] = new_push_signal_resolver;
      caml_call2(Lwt[2], old_push_signal_resolver, 0);
     }
     var _b3_ = 0 === x ? 1 : 0;
     return _b3_ ? caml_call2(Lwt[52], close, 0) : _b3_;
    }
    return [0, t, push, function(x){source[3] = x; return 0;}];
   }
   function return$0(a){
    var match = create_with_reference(0), push = match[2], stream = match[1];
    caml_call1(push, [0, a]);
    caml_call1(push, 0);
    return stream;
   }
   function return_lwt(a){
    var match = create_with_reference(0), push = match[2], source = match[1];
    function _b0_(exc){return caml_call1(push, 0);}
    function _b1_(param){
     function _b2_(x){
      caml_call1(push, [0, x]);
      caml_call1(push, 0);
      return Lwt[36];
     }
     return caml_call2(Lwt[6], a, _b2_);
    }
    caml_call2(Lwt[10], _b1_, _b0_);
    return source;
   }
   function of_seq(s){
    var s$0 = [0, s];
    function get(param){
     var match = caml_call1(s$0[1], 0);
     if(! match) return 0;
     var s = match[2], elt = match[1];
     s$0[1] = s;
     return [0, elt];
    }
    return from_direct(get);
   }
   function of_lwt_seq(s){
    var s$0 = [0, s];
    function get(param){
     function _bY_(param){
      if(! param) return 0;
      var s = param[2], elt = param[1];
      s$0[1] = s;
      return [0, elt];
     }
     var _bZ_ = caml_call1(s$0[1], 0);
     return caml_call2(Lwt[33][2], _bZ_, _bY_);
    }
    return from(get);
   }
   function create(param){
    var match = create_with_reference(0), push = match[2], source = match[1];
    return [0, source, push];
   }
   function of_iter(iter, i){
    var match = create(0), push = match[2], stream = match[1];
    caml_call2(iter, function(x){return caml_call1(push, [0, x]);}, i);
    caml_call1(push, 0);
    return stream;
   }
   function of_list(l){return of_iter(Stdlib_List[18], l);}
   function of_array(a){return of_iter(Stdlib_Array[11], a);}
   function of_string(s){return of_iter(Stdlib_String[30], s);}
   function notify_pusher(info, last){
    enqueue(info[5], last);
    info[5] = 0;
    var
     old_wakener = info[7],
     match = caml_call1(Lwt[22], 0),
     wakener = match[2],
     waiter = match[1];
    info[6] = waiter;
    info[7] = wakener;
    return caml_call2(Lwt[2], old_wakener, 0);
   }
   function _c_(_bp_){
    var
     _bq_ = caml_call2(CamlinternalOO[3], _bp_, cst),
     _br_ = caml_call2(CamlinternalOO[3], _bp_, cst$0),
     _bs_ = caml_call2(CamlinternalOO[3], _bp_, cst$1),
     _bt_ = caml_call2(CamlinternalOO[3], _bp_, cst$2),
     _bu_ = caml_call3(CamlinternalOO[4], _bp_, shared, _b_),
     _bD_ = _bu_[9],
     _bv_ = _bu_[1],
     _bw_ = _bu_[2],
     _bx_ = _bu_[3],
     _by_ = _bu_[4],
     _bz_ = _bu_[5],
     _bA_ = _bu_[6],
     _bB_ = _bu_[7],
     _bC_ = _bu_[8];
    function _bE_(self_1, x){self_1[1 + _bq_][8] = x; return 0;}
    function _bF_(self_1){return self_1[1 + _bD_];}
    function _bG_(self_1){return 0 !== self_1[1 + _bq_][5] ? 1 : 0;}
    function _bH_(self_1){return self_1[1 + _bq_][4];}
    function _bI_(self_1){
     var _bX_ = 1 - self_1[1 + _bD_];
     if(! _bX_) return _bX_;
     self_1[1 + _bD_] = 1;
     var node = self_1[1 + _bs_][1], new_last = new_node(0);
     node[2] = 0;
     node[1] = new_last;
     self_1[1 + _bs_][1] = new_last;
     if(0 !== self_1[1 + _bq_][5]){
      self_1[1 + _bq_][5] = 0;
      caml_call2(Lwt[3], self_1[1 + _bq_][7], Closed);
     }
     if(self_1[1 + _bq_][2]){
      self_1[1 + _bq_][2] = 0;
      var old_wakener = self_1[1 + _br_][1];
      caml_call2(Lwt[2], old_wakener, 0);
     }
     return caml_call2(Lwt[52], self_1[1 + _bt_], 0);
    }
    function _bJ_(self_1, x){
     if(self_1[1 + _bD_]) return caml_call1(Lwt[5], Closed);
     if(0 !== self_1[1 + _bq_][5]) return caml_call1(Lwt[5], Full);
     if(self_1[1 + _bq_][3] <= self_1[1 + _bq_][4]){
      self_1[1 + _bq_][5] = [0, x];
      var
       _bV_ =
         function(exn){
          if(exn !== Lwt[21]) throw caml_maybe_attach_backtrace(exn, 0);
          self_1[1 + _bq_][5] = 0;
          var
           match = caml_call1(Lwt[22], 0),
           wakener = match[2],
           waiter = match[1];
          self_1[1 + _bq_][6] = waiter;
          self_1[1 + _bq_][7] = wakener;
          throw caml_maybe_attach_backtrace(exn, 0);
         },
       _bW_ = function(param){return self_1[1 + _bq_][6];};
      return caml_call2(Lwt[7], _bW_, _bV_);
     }
     enqueue([0, x], self_1[1 + _bs_]);
     self_1[1 + _bq_][4] = self_1[1 + _bq_][4] + 1 | 0;
     if(self_1[1 + _bq_][2]){
      self_1[1 + _bq_][2] = 0;
      var
       old_wakener = self_1[1 + _br_][1],
       match = caml_call1(Lwt[1], 0),
       new_wakener = match[2],
       new_waiter = match[1];
      self_1[1 + _bq_][1] = new_waiter;
      self_1[1 + _br_][1] = new_wakener;
      caml_call2(Lwt[2], old_wakener, 0);
     }
     return Lwt[36];
    }
    function _bK_(self_1, size){
     if(size < 0) caml_call1(Stdlib[1], cst_Lwt_stream_bounded_push_re);
     self_1[1 + _bq_][3] = size;
     var
      _bT_ = self_1[1 + _bq_][4] < self_1[1 + _bq_][3] ? 1 : 0,
      _bU_ = _bT_ ? 0 !== self_1[1 + _bq_][5] ? 1 : 0 : _bT_;
     return _bU_
             ? (self_1
                 [1 + _bq_]
                [4]
               = self_1[1 + _bq_][4] + 1 | 0,
               notify_pusher(self_1[1 + _bq_], self_1[1 + _bs_]))
             : _bU_;
    }
    var
     _bL_ =
       [0,
        _bv_,
        function(self_1){return self_1[1 + _bq_][3];},
        _bx_,
        _bK_,
        _by_,
        _bJ_,
        _bB_,
        _bI_,
        _bz_,
        _bH_,
        _bC_,
        _bG_,
        _bA_,
        _bF_,
        _bw_,
        _bE_];
    caml_call2(CamlinternalOO[11], _bp_, _bL_);
    return function(_bR_, _bQ_, _bP_, _bO_, _bN_, _bM_){
     var _bS_ = caml_call2(CamlinternalOO[24], _bQ_, _bp_);
     _bS_[1 + _bt_] = _bM_;
     _bS_[1 + _bs_] = _bN_;
     _bS_[1 + _br_] = _bO_;
     _bS_[1 + _bq_] = _bP_;
     _bS_[1 + _bD_] = 0;
     return _bS_;};
   }
   var bounded_push_impl = caml_call2(CamlinternalOO[19], _a_, _c_);
   function create_bounded(size){
    if(size < 0) caml_call1(Stdlib[1], cst_Lwt_stream_create_bounded);
    var
     match = caml_call1(Lwt[1], 0),
     wakener = match[2],
     waiter = match[1],
     match$0 = caml_call1(Lwt[22], 0),
     push_wakener = match$0[2],
     push_waiter = match$0[1],
     wakener_cell = [0, wakener],
     info = [0, waiter, 0, size, 0, 0, push_waiter, push_wakener, 0],
     t = from_source([3, info]);
    return [0,
            t,
            caml_call5
             (bounded_push_impl[1], 0, info, wakener_cell, t[5], t[2])];
   }
   function feed(s){
    var match = s[1];
    switch(match[0]){
      case 0:
       var from = match[1];
       if(caml_call1(Lwt[76], from[2])) return caml_call1(Lwt[25], from[2]);
       var
        _bk_ = function(_bo_){throw caml_maybe_attach_backtrace(_bo_, 0);},
        _bl_ =
          function(param){
           function _bm_(x){
            enqueue$0(x, s);
            if(0 === x) caml_call2(Lwt[52], s[2], 0);
            return Lwt[36];
           }
           var _bn_ = caml_call1(from[1], 0);
           return caml_call2(Lwt[33][1], _bn_, _bm_);
          },
        thread = caml_call2(Lwt[7], _bl_, _bk_);
       from[2] = thread;
       return caml_call1(Lwt[25], thread);
      case 1:
       var f = match[1], x = caml_call1(f, 0);
       enqueue$0(x, s);
       if(0 === x) caml_call2(Lwt[52], s[2], 0);
       return Lwt[36];
      case 2:
       var push = match[1]; push[2] = 1; return caml_call1(Lwt[25], push[1]);
      default:
       var push$0 = match[1];
       push$0[2] = 1;
       return caml_call1(Lwt[25], push$0[1]);
    }
   }
   function consume(s, node){
    var _bj_ = node === s[4] ? 1 : 0;
    if(! _bj_) return _bj_;
    s[4] = node[1];
    var match = s[1];
    if(3 !== match[0]) return;
    var info = match[1];
    if(0 !== info[5]) return notify_pusher(info, s[5]);
    info[4] = info[4] - 1 | 0;
    return;
   }
   function peek_rec(s, node){
    if(node !== s[5][1]) return caml_call1(Lwt[4], node[2]);
    function _bh_(param){return peek_rec(s, node);}
    var _bi_ = feed(s);
    return caml_call2(Lwt[33][1], _bi_, _bh_);
   }
   function peek(s){return peek_rec(s, s[4]);}
   function npeek_rec(node, acc, n, s){
    var node$0 = node, acc$0 = acc, n$0 = n;
    for(;;){
     if(0 >= n$0){
      var _bg_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _bg_);
     }
     if(node$0 === s[5][1]){
      var
       _bd_ = function(param){return npeek_rec(node$0, acc$0, n$0, s);},
       _be_ = feed(s);
      return caml_call2(Lwt[33][1], _be_, _bd_);
     }
     var match = node$0[2];
     if(! match){
      var _bf_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _bf_);
     }
     var
      x = match[1],
      n$1 = n$0 - 1 | 0,
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1],
      node$0 = node$1,
      acc$0 = acc$1,
      n$0 = n$1;
    }
   }
   function npeek(n, s){return npeek_rec(s[4], 0, n, s);}
   function get_rec(s, node){
    if(node === s[5][1]){
     var _bb_ = function(param){return get_rec(s, node);}, _bc_ = feed(s);
     return caml_call2(Lwt[33][1], _bc_, _bb_);
    }
    if(0 !== node[2]) consume(s, node);
    return caml_call1(Lwt[4], node[2]);
   }
   function get(s){return get_rec(s, s[4]);}
   function get_exn_rec(s, node){
    if(node === s[5][1]){
     var
      _a__ = function(exn){return caml_call1(Lwt[4], [0, [1, exn]]);},
      _a$_ = function(param){return get_exn_rec(s, node);},
      _ba_ = function(param){return feed(s);};
     return caml_call3(Lwt[9], _ba_, _a$_, _a__);
    }
    var match = node[2];
    if(! match) return Lwt[37];
    var value = match[1];
    consume(s, node);
    return caml_call1(Lwt[4], [0, [0, value]]);
   }
   function wrap_exn(s){
    return from(function(param){return get_exn_rec(s, s[4]);});
   }
   function nget_rec(node, acc, n, s){
    var node$0 = node, acc$0 = acc, n$0 = n;
    for(;;){
     if(0 >= n$0){
      var _a9_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _a9_);
     }
     if(node$0 === s[5][1]){
      var
       _a6_ = function(param){return nget_rec(node$0, acc$0, n$0, s);},
       _a7_ = feed(s);
      return caml_call2(Lwt[33][1], _a7_, _a6_);
     }
     var match = s[4][2];
     if(! match){
      var _a8_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _a8_);
     }
     var x = match[1];
     consume(s, node$0);
     var
      n$1 = n$0 - 1 | 0,
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1],
      node$0 = node$1,
      acc$0 = acc$1,
      n$0 = n$1;
    }
   }
   function nget(n, s){return nget_rec(s[4], 0, n, s);}
   function get_while_rec(node, acc, f, s){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _a2_ = function(param){return get_while_rec(node$0, acc$0, f, s);},
       _a3_ = feed(s);
      return caml_call2(Lwt[33][1], _a3_, _a2_);
     }
     var match = node$0[2];
     if(! match){
      var _a5_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _a5_);
     }
     var x = match[1], test = caml_call1(f, x);
     if(! test){
      var _a4_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _a4_);
     }
     consume(s, node$0);
     var
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1],
      node$0 = node$1,
      acc$0 = acc$1;
    }
   }
   function get_while(f, s){return get_while_rec(s[4], 0, f, s);}
   function get_while_s_rec(node, acc, f, s){
    if(node === s[5][1]){
     var
      _aW_ = function(param){return get_while_s_rec(node, acc, f, s);},
      _aX_ = feed(s);
     return caml_call2(Lwt[33][1], _aX_, _aW_);
    }
    var match = node[2];
    if(match){
     var
      x = match[1],
      _aY_ =
        function(param){
         if(param){
          consume(s, node);
          return get_while_s_rec(node[1], [0, x, acc], f, s);
         }
         var _a1_ = caml_call1(Stdlib_List[10], acc);
         return caml_call1(Lwt[4], _a1_);
        },
      _aZ_ = caml_call1(f, x);
     return caml_call2(Lwt[33][1], _aZ_, _aY_);
    }
    var _a0_ = caml_call1(Stdlib_List[10], acc);
    return caml_call1(Lwt[4], _a0_);
   }
   function get_while_s(f, s){return get_while_s_rec(s[4], 0, f, s);}
   function next_rec(s, node){
    if(node === s[5][1]){
     var _aU_ = function(param){return next_rec(s, node);}, _aV_ = feed(s);
     return caml_call2(Lwt[33][1], _aV_, _aU_);
    }
    var match = node[2];
    if(! match) return caml_call1(Lwt[5], Empty);
    var x = match[1];
    consume(s, node);
    return caml_call1(Lwt[4], x);
   }
   function next(s){return next_rec(s, s[4]);}
   function last_new_rec(node, x, s){
    var node$0 = node, x$0 = x;
    for(;;)
     if(node$0 === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Lwt[4], x$0);
      if(0 !== match[0]){var exn = match[1]; return caml_call1(Lwt[5], exn);}
     }
     else{
      var match$0 = node$0[2];
      if(! match$0) return caml_call1(Lwt[4], x$0);
      var x$1 = match$0[1];
      consume(s, node$0);
      var node$1 = node$0[1], node$0 = node$1, x$0 = x$1;
     }
   }
   function last_new(s){
    var node = s[4];
    if(node !== s[5][1]){
     var match$0 = node[2];
     if(! match$0) return caml_call1(Lwt[5], Empty);
     var x$0 = match$0[1];
     consume(s, node);
     return last_new_rec(node[1], x$0, s);
    }
    var thread = next(s), match = caml_call1(Lwt[48], thread);
    if(typeof match !== "number" && 0 === match[0]){
     var x = match[1];
     return last_new_rec(node, x, s);
    }
    return thread;
   }
   function to_list_rec(node, acc, s){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _aR_ = function(param){return to_list_rec(node$0, acc$0, s);},
       _aS_ = feed(s);
      return caml_call2(Lwt[33][1], _aS_, _aR_);
     }
     var match = node$0[2];
     if(! match){
      var _aT_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _aT_);
     }
     var x = match[1];
     consume(s, node$0);
     var
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1],
      node$0 = node$1,
      acc$0 = acc$1;
    }
   }
   function to_list(s){return to_list_rec(s[4], 0, s);}
   function to_string_rec(node, buf, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _aO_ = function(param){return to_string_rec(node$0, buf, s);},
       _aP_ = feed(s);
      return caml_call2(Lwt[33][1], _aP_, _aO_);
     }
     var match = node$0[2];
     if(! match){
      var _aQ_ = caml_call1(Stdlib_Buffer[2], buf);
      return caml_call1(Lwt[4], _aQ_);
     }
     var x = match[1];
     consume(s, node$0);
     caml_call2(Stdlib_Buffer[12], buf, x);
     var node$1 = node$0[1], node$0 = node$1;
    }
   }
   function to_string(s){
    var _aN_ = caml_call1(Stdlib_Buffer[1], 128);
    return to_string_rec(s[4], _aN_, s);
   }
   function junk(s){
    var node = s[4];
    if(node === s[5][1]){
     var
      _aL_ =
        function(param){if(0 !== node[2]) consume(s, node); return Lwt[36];},
      _aM_ = feed(s);
     return caml_call2(Lwt[33][1], _aM_, _aL_);
    }
    if(0 !== node[2]) consume(s, node);
    return Lwt[36];
   }
   function njunk_rec(node, n, s){
    var node$0 = node, n$0 = n;
    for(;;){
     if(0 >= n$0) return Lwt[36];
     if(node$0 === s[5][1]){
      var
       _aJ_ = function(param){return njunk_rec(node$0, n$0, s);},
       _aK_ = feed(s);
      return caml_call2(Lwt[33][1], _aK_, _aJ_);
     }
     if(! node$0[2]) return Lwt[36];
     consume(s, node$0);
     var n$1 = n$0 - 1 | 0, node$1 = node$0[1], node$0 = node$1, n$0 = n$1;
    }
   }
   function njunk(n, s){return njunk_rec(s[4], n, s);}
   function junk_while_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _aH_ = function(param){return junk_while_rec(node$0, f, s);},
       _aI_ = feed(s);
      return caml_call2(Lwt[33][1], _aI_, _aH_);
     }
     var match = node$0[2];
     if(! match) return Lwt[36];
     var x = match[1], test = caml_call1(f, x);
     if(! test) return Lwt[36];
     consume(s, node$0);
     var node$1 = node$0[1], node$0 = node$1;
    }
   }
   function junk_while(f, s){return junk_while_rec(s[4], f, s);}
   function junk_while_s_rec(node, f, s){
    if(node === s[5][1]){
     var
      _aD_ = function(param){return junk_while_s_rec(node, f, s);},
      _aE_ = feed(s);
     return caml_call2(Lwt[33][1], _aE_, _aD_);
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    function _aF_(param){
     return param
             ? (consume(s, node), junk_while_s_rec(node[1], f, s))
             : Lwt[36];
    }
    var _aG_ = caml_call1(f, x);
    return caml_call2(Lwt[33][1], _aG_, _aF_);
   }
   function junk_while_s(f, s){return junk_while_s_rec(s[4], f, s);}
   function junk_available(s){
    var node$1 = s[4], node = node$1;
    for(;;)
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      if(! node[2]) return 0;
      consume(s, node);
      var node$0 = node[1], node = node$0;
     }
   }
   function junk_old(s){
    var _aC_ = junk_available(s);
    return caml_call1(Lwt[4], _aC_);
   }
   function get_available(s){
    var node$1 = s[4], node = node$1, acc = 0;
    for(;;)
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Stdlib_List[10], acc);
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      var match$0 = node[2];
      if(! match$0) return caml_call1(Stdlib_List[10], acc);
      var x = match$0[1];
      consume(s, node);
      var acc$0 = [0, x, acc], node$0 = node[1], node = node$0, acc = acc$0;
     }
   }
   function get_available_up_to(n$1, s){
    var node$1 = s[4], node = node$1, acc = 0, n = n$1;
    for(;;){
     if(0 >= n) return caml_call1(Stdlib_List[10], acc);
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Stdlib_List[10], acc);
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      var match$0 = s[4][2];
      if(! match$0) return caml_call1(Stdlib_List[10], acc);
      var x = match$0[1];
      consume(s, node);
      var
       n$0 = n - 1 | 0,
       acc$0 = [0, x, acc],
       node$0 = node[1],
       node = node$0,
       acc = acc$0,
       n = n$0;
     }
    }
   }
   function is_empty(s){
    if(s[4] !== s[5][1]) return caml_call1(Lwt[4], 0 === s[4][2] ? 1 : 0);
    function _aA_(param){return is_empty(s);}
    var _aB_ = feed(s);
    return caml_call2(Lwt[33][1], _aB_, _aA_);
   }
   function map(f, s){
    return from
            (function(param){
              function _ay_(param){
               if(! param) return 0;
               var x = param[1], x$0 = caml_call1(f, x);
               return [0, x$0];
              }
              var _az_ = get(s);
              return caml_call2(Lwt[33][2], _az_, _ay_);
             });
   }
   function map_s(f, s){
    return from
            (function(param){
              function _au_(param){
               if(! param) return Lwt[37];
               var x = param[1];
               function _aw_(x){return [0, x];}
               var _ax_ = caml_call1(f, x);
               return caml_call2(Lwt[33][2], _ax_, _aw_);
              }
              var _av_ = get(s);
              return caml_call2(Lwt[33][1], _av_, _au_);
             });
   }
   function filter(f, s){
    function next(param){
     var t = get(s);
     function _at_(param){
      if(! param) return Lwt[37];
      var x = param[1], test = caml_call1(f, x);
      return test ? t : next(0);
     }
     return caml_call2(Lwt[33][1], t, _at_);
    }
    return from(next);
   }
   function filter_s(f, s){
    function next(param){
     var t = get(s);
     function _aq_(param){
      if(! param) return t;
      var x = param[1];
      function _ar_(param){return param ? t : next(0);}
      var _as_ = caml_call1(f, x);
      return caml_call2(Lwt[33][1], _as_, _ar_);
     }
     return caml_call2(Lwt[33][1], t, _aq_);
    }
    return from(next);
   }
   function filter_map(f, s){
    function next(param){
     function _ao_(param){
      if(! param) return Lwt[37];
      var x = param[1], x$0 = caml_call1(f, x);
      return x$0 ? caml_call1(Lwt[4], x$0) : next(0);
     }
     var _ap_ = get(s);
     return caml_call2(Lwt[33][1], _ap_, _ao_);
    }
    return from(next);
   }
   function filter_map_s(f, s){
    function next(param){
     function _al_(param){
      if(! param) return Lwt[37];
      var x = param[1], t = caml_call1(f, x);
      function _an_(param){return param ? t : next(0);}
      return caml_call2(Lwt[33][1], t, _an_);
     }
     var _am_ = get(s);
     return caml_call2(Lwt[33][1], _am_, _al_);
    }
    return from(next);
   }
   function map_list(f, s){
    var pendings = [0, 0];
    function next(param){
     var match = pendings[1];
     if(match){
      var l = match[2], x = match[1];
      pendings[1] = l;
      return caml_call1(Lwt[4], [0, x]);
     }
     function _aj_(param){
      if(! param) return Lwt[37];
      var x = param[1], l = caml_call1(f, x);
      pendings[1] = l;
      return next(0);
     }
     var _ak_ = get(s);
     return caml_call2(Lwt[33][1], _ak_, _aj_);
    }
    return from(next);
   }
   function map_list_s(f, s){
    var pendings = [0, 0];
    function next(param){
     var match = pendings[1];
     if(match){
      var l = match[2], x = match[1];
      pendings[1] = l;
      return caml_call1(Lwt[4], [0, x]);
     }
     function _af_(param){
      if(! param) return Lwt[37];
      var x = param[1];
      function _ah_(l){pendings[1] = l; return next(0);}
      var _ai_ = caml_call1(f, x);
      return caml_call2(Lwt[33][1], _ai_, _ah_);
     }
     var _ag_ = get(s);
     return caml_call2(Lwt[33][1], _ag_, _af_);
    }
    return from(next);
   }
   function flatten(s){return map_list(function(l){return l;}, s);}
   function fold_rec(node, f, s, acc){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _ad_ = function(param){return fold_rec(node$0, f, s, acc$0);},
       _ae_ = feed(s);
      return caml_call2(Lwt[33][1], _ae_, _ad_);
     }
     var match = node$0[2];
     if(! match) return caml_call1(Lwt[4], acc$0);
     var x = match[1];
     consume(s, node$0);
     var
      acc$1 = caml_call2(f, x, acc$0),
      node$1 = node$0[1],
      node$0 = node$1,
      acc$0 = acc$1;
    }
   }
   function fold(f, s, acc){return fold_rec(s[4], f, s, acc);}
   function fold_s_rec(node, f, s, acc){
    if(node === s[5][1]){
     var
      _$_ = function(param){return fold_s_rec(node, f, s, acc);},
      _aa_ = feed(s);
     return caml_call2(Lwt[33][1], _aa_, _$_);
    }
    var match = node[2];
    if(! match) return caml_call1(Lwt[4], acc);
    var x = match[1];
    consume(s, node);
    function _ab_(acc){return fold_s_rec(node[1], f, s, acc);}
    var _ac_ = caml_call2(f, x, acc);
    return caml_call2(Lwt[33][1], _ac_, _ab_);
   }
   function fold_s(f, s, acc){return fold_s_rec(s[4], f, s, acc);}
   function iter_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _Z_ = function(param){return iter_rec(node$0, f, s);},
       ___ = feed(s);
      return caml_call2(Lwt[33][1], ___, _Z_);
     }
     var match = node$0[2];
     if(! match) return Lwt[36];
     var x = match[1];
     consume(s, node$0);
     caml_call1(f, x);
     var node$1 = node$0[1], node$0 = node$1;
    }
   }
   function iter(f, s){return iter_rec(s[4], f, s);}
   function iter_s_rec(node, f, s){
    if(node === s[5][1]){
     var _V_ = function(param){return iter_s_rec(node, f, s);}, _W_ = feed(s);
     return caml_call2(Lwt[33][1], _W_, _V_);
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    consume(s, node);
    function _X_(param){return iter_s_rec(node[1], f, s);}
    var _Y_ = caml_call1(f, x);
    return caml_call2(Lwt[33][1], _Y_, _X_);
   }
   function iter_s(f, s){return iter_s_rec(s[4], f, s);}
   function iter_p_rec(node, f, s){
    if(node === s[5][1]){
     var _S_ = function(param){return iter_p_rec(node, f, s);}, _T_ = feed(s);
     return caml_call2(Lwt[33][1], _T_, _S_);
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    consume(s, node);
    var res = caml_call1(f, x), rest = iter_p_rec(node[1], f, s);
    function _U_(param){return rest;}
    return caml_call2(Lwt[33][1], res, _U_);
   }
   function iter_p(f, s){return iter_p_rec(s[4], f, s);}
   function iter_n(opt, f, stream){
    if(opt)
     var sth = opt[1], max_concurrency = sth;
    else
     var max_concurrency = 1;
    if(max_concurrency <= 0){
     var message = caml_call2(Stdlib_Printf[4], _d_, max_concurrency);
     caml_call1(Stdlib[1], message);
    }
    function loop(running, available){
     function _L_(param){
      var available = param[2], running = param[1];
      function _Q_(param){
       if(! param) return caml_call1(Lwt[14], running);
       var elt = param[1];
       return loop([0, caml_call1(f, elt), running], available - 1 | 0);
      }
      var _R_ = get(stream);
      return caml_call2(Lwt[33][1], _R_, _Q_);
     }
     if(0 < available)
      var _M_ = caml_call1(Lwt[4], [0, running, available]);
     else
      var
       _N_ =
         function(param){
          var
           running = param[2],
           complete = param[1],
           _P_ =
             [0,
              running,
              available + caml_call1(Stdlib_List[1], complete) | 0];
          return caml_call1(Lwt[4], _P_);
         },
       _O_ = caml_call1(Lwt[20], running),
       _M_ = caml_call2(Lwt[33][1], _O_, _N_);
     return caml_call2(Lwt[33][1], _M_, _L_);
    }
    return loop(0, max_concurrency);
   }
   function find_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _J_ = function(param){return find_rec(node$0, f, s);},
       _K_ = feed(s);
      return caml_call2(Lwt[33][1], _K_, _J_);
     }
     var opt = node$0[2];
     if(! opt) return Lwt[37];
     var x = opt[1];
     consume(s, node$0);
     var test = caml_call1(f, x);
     if(test) return caml_call1(Lwt[4], opt);
     var node$1 = node$0[1], node$0 = node$1;
    }
   }
   function find(f, s){return find_rec(s[4], f, s);}
   function find_s_rec(node, f, s){
    if(node === s[5][1]){
     var _F_ = function(param){return find_s_rec(node, f, s);}, _G_ = feed(s);
     return caml_call2(Lwt[33][1], _G_, _F_);
    }
    var opt = node[2];
    if(! opt) return Lwt[37];
    var x = opt[1];
    consume(s, node);
    function _H_(param){
     return param ? caml_call1(Lwt[4], opt) : find_s_rec(node[1], f, s);
    }
    var _I_ = caml_call1(f, x);
    return caml_call2(Lwt[33][1], _I_, _H_);
   }
   function find_s(f, s){return find_s_rec(s[4], f, s);}
   function find_map_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _D_ = function(param){return find_map_rec(node$0, f, s);},
       _E_ = feed(s);
      return caml_call2(Lwt[33][1], _E_, _D_);
     }
     var match = node$0[2];
     if(! match) return Lwt[37];
     var x = match[1];
     consume(s, node$0);
     var x$0 = caml_call1(f, x);
     if(0 !== x$0) return caml_call1(Lwt[4], x$0);
     var node$1 = node$0[1], node$0 = node$1;
    }
   }
   function find_map(f, s){return find_map_rec(s[4], f, s);}
   function find_map_s_rec(node, f, s){
    if(node === s[5][1]){
     var
      _A_ = function(param){return find_map_s_rec(node, f, s);},
      _B_ = feed(s);
     return caml_call2(Lwt[33][1], _B_, _A_);
    }
    var match = node[2];
    if(! match) return Lwt[37];
    var x = match[1];
    consume(s, node);
    var t = caml_call1(f, x);
    function _C_(param){return param ? t : find_map_s_rec(node[1], f, s);}
    return caml_call2(Lwt[33][1], t, _C_);
   }
   function find_map_s(f, s){return find_map_s_rec(s[4], f, s);}
   function combine(s1, s2){
    function next(param){
     var t1 = get(s1), t2 = get(s2);
     function _y_(n1){
      function _z_(n2){
       if(n1 && n2){
        var x2 = n2[1], x1 = n1[1];
        return caml_call1(Lwt[4], [0, [0, x1, x2]]);
       }
       return Lwt[37];
      }
      return caml_call2(Lwt[33][1], t2, _z_);
     }
     return caml_call2(Lwt[33][1], t1, _y_);
    }
    return from(next);
   }
   function append(s1, s2){
    var current_s = [0, s1];
    function next(param){
     var t = get(current_s[1]);
     function _x_(param){
      return param
              ? t
              : current_s[1] === s2 ? Lwt[37] : (current_s[1] = s2, next(0));
     }
     return caml_call2(Lwt[33][1], t, _x_);
    }
    return from(next);
   }
   function concat(s_top){
    var current_s = [0, from(function(param){return Lwt[37];})];
    function next(param){
     var t = get(current_s[1]);
     function _u_(param){
      if(param) return t;
      function _v_(param){
       if(! param) return Lwt[37];
       var s = param[1];
       current_s[1] = s;
       return next(0);
      }
      var _w_ = get(s_top);
      return caml_call2(Lwt[33][1], _w_, _v_);
     }
     return caml_call2(Lwt[33][1], t, _u_);
    }
    return from(next);
   }
   function choose(streams){
    function source(s){
     function _s_(x){return [0, s, x];}
     var _t_ = get(s);
     return [0, s, caml_call2(Lwt[33][2], _t_, _s_)];
    }
    var streams$0 = [0, caml_call2(Stdlib_List[20], source, streams)];
    function next(param){
     var l = streams$0[1];
     if(! l) return Lwt[37];
     function _n_(param){
      var x = param[2], s = param[1], l$0 = caml_call2(Stdlib_List[56], s, l);
      return x
              ? (streams$0[1] = [0, source(s), l$0], caml_call1(Lwt[4], x))
              : (streams$0[1] = l$0, next(0));
     }
     function _o_(_r_){return _r_[2];}
     var
      _p_ = caml_call2(Stdlib_List[20], _o_, l),
      _q_ = caml_call1(Lwt[17], _p_);
     return caml_call2(Lwt[33][1], _q_, _n_);
    }
    return from(next);
   }
   function parse(s, f){
    if(3 === s[1][0]) caml_call1(Stdlib[1], cst_Lwt_stream_parse);
    var node = s[4];
    function _l_(exn){s[4] = node; throw caml_maybe_attach_backtrace(exn, 0);}
    function _m_(param){return caml_call1(f, s);}
    return caml_call2(Lwt[7], _m_, _l_);
   }
   function hexdump(stream){
    var buf = caml_call1(Stdlib_Buffer[1], 80), num = [0, 0];
    return from
            (function(param){
              function _g_(l){
               if(! l) return Lwt[37];
               caml_call1(Stdlib_Buffer[8], buf);
               caml_call3(Stdlib_Printf[5], buf, _e_, num[1]);
               num[1] = num[1] + 16 | 0;
               var pos = 0, param = l;
               for(;;){
                if(! param) break;
                var l$0 = param[2], x = param[1];
                if(8 === pos) caml_call2(Stdlib_Buffer[12], buf, 32);
                caml_call3(Stdlib_Printf[5], buf, _f_, x);
                var pos$0 = pos + 1 | 0, pos = pos$0, param = l$0;
               }
               var pos$1 = pos;
               for(;;){
                if(pos$1 >= 16){
                 caml_call2(Stdlib_Buffer[16], buf, cst$5);
                 var
                  _i_ =
                    function(ch){
                     a:
                     {
                      if(32 <= ch && 126 >= ch){var _k_ = ch; break a;}
                      var _k_ = 46;
                     }
                     return caml_call2(Stdlib_Buffer[12], buf, _k_);
                    };
                 caml_call2(Stdlib_List[18], _i_, l);
                 caml_call2(Stdlib_Buffer[12], buf, 124);
                 var _j_ = [0, caml_call1(Stdlib_Buffer[2], buf)];
                 return caml_call1(Lwt[4], _j_);
                }
                if(8 === pos$1)
                 caml_call2(Stdlib_Buffer[16], buf, cst$3);
                else
                 caml_call2(Stdlib_Buffer[16], buf, cst$4);
                var pos$2 = pos$1 + 1 | 0, pos$1 = pos$2;
               }
              }
              var _h_ = nget(16, stream);
              return caml_call2(Lwt[33][1], _h_, _g_);
             });
   }
   var
    Lwt_stream =
      [0,
       from,
       from_direct,
       Closed,
       create,
       create_with_reference,
       Full,
       create_bounded,
       return$0,
       return_lwt,
       of_seq,
       of_lwt_seq,
       of_list,
       of_array,
       of_string,
       clone,
       to_list,
       to_string,
       Empty,
       peek,
       npeek,
       get,
       nget,
       get_while,
       get_while_s,
       next,
       last_new,
       junk,
       njunk,
       junk_while,
       junk_while_s,
       junk_available,
       get_available,
       get_available_up_to,
       is_empty,
       is_closed,
       closed,
       junk_old,
       choose,
       map,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       map_list,
       map_list_s,
       fold,
       fold_s,
       iter,
       iter_p,
       iter_s,
       iter_n,
       find,
       find_s,
       find_map,
       find_map_s,
       combine,
       append,
       concat,
       flatten,
       wrap_exn,
       parse,
       hexdump];
   runtime.caml_register_global(28, Lwt_stream, "Lwt_stream");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_result
//# unitInfo: Requires: Lwt
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, "src/core/lwt_result.ml", 84, 14];
   function return$0(x){return caml_call1(Lwt[4], [0, x]);}
   function fail(e){return caml_call1(Lwt[4], [1, e]);}
   var lift = Lwt[4];
   function ok(x){
    function _r_(y){return [0, y];}
    return caml_call2(Lwt[28], _r_, x);
   }
   function error(x){
    function _q_(y){return [1, y];}
    return caml_call2(Lwt[28], _q_, x);
   }
   function map(f, e){
    function _p_(param){
     if(0 === param[0]){var x = param[1]; return [0, caml_call1(f, x)];}
     var e = param[1];
     return [1, e];
    }
    return caml_call2(Lwt[28], _p_, e);
   }
   function map_error(f, e){
    function _o_(param){
     if(0 === param[0]){var x = param[1]; return [0, x];}
     var e = param[1];
     return [1, caml_call1(f, e)];
    }
    return caml_call2(Lwt[28], _o_, e);
   }
   function map_err(f, e){return map_error(f, e);}
   function catch$0(e){
    function _n_(param){return ok(caml_call1(e, 0));}
    return caml_call2(Lwt[7], _n_, fail);
   }
   function get_exn(e){
    function _m_(param){
     if(0 === param[0]){var x = param[1]; return caml_call1(Lwt[4], x);}
     var e = param[1];
     return caml_call1(Lwt[5], e);
    }
    return caml_call2(Lwt[6], e, _m_);
   }
   function symbol_bind(e, f){
    function _l_(param){
     if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
     var e = param[1];
     return caml_call1(Lwt[4], [1, e]);
    }
    return caml_call2(Lwt[6], e, _l_);
   }
   function bind_error(e, f){
    function _k_(param){
     if(0 === param[0]){var x = param[1]; return caml_call1(Lwt[4], [0, x]);}
     var e = param[1];
     return caml_call1(f, e);
    }
    return caml_call2(Lwt[6], e, _k_);
   }
   function bind_lwt(e, f){
    function _j_(param){
     if(0 === param[0]){var x = param[1]; return ok(caml_call1(f, x));}
     var e = param[1];
     return fail(e);
    }
    return caml_call2(Lwt[6], e, _j_);
   }
   function bind_result(e, f){
    function _i_(param){
     if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
     var e = param[1];
     return [1, e];
    }
    return caml_call2(Lwt[28], _i_, e);
   }
   function bind_lwt_error(e, f){
    function _g_(param){
     if(0 === param[0]){var x = param[1]; return return$0(x);}
     var e = param[1], _h_ = caml_call1(f, e);
     return caml_call2(Lwt[6], _h_, fail);
    }
    return caml_call2(Lwt[6], e, _g_);
   }
   function bind_lwt_err(e, f){return bind_lwt_error(e, f);}
   function both(a, b){
    var s = [0, 0];
    function set_once(e){return s[1] ? 0 : (s[1] = [0, e], 0);}
    var
     b$0 = map_error(set_once, b),
     a$0 = map_error(set_once, a),
     _d_ = caml_call2(Lwt[13], a$0, b$0);
    function _e_(param){
     var _f_ = param[1];
     if(0 === _f_[0]){
      var match = param[2], x = _f_[1];
      if(0 === match[0]){var y = match[1]; return [0, [0, x, y]];}
     }
     var param$0 = s[1];
     if(! param$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var e = param$0[1];
     return [1, e];
    }
    return caml_call2(Lwt[28], _e_, _d_);
   }
   function iter(f, r){
    function _c_(param){
     if(0 !== param[0]) return Lwt[36];
     var x = param[1];
     return caml_call1(f, x);
    }
    return caml_call2(Lwt[6], r, _c_);
   }
   function iter_error(f, r){
    function _b_(param){
     if(0 === param[0]) return Lwt[36];
     var e = param[1];
     return caml_call1(f, e);
    }
    return caml_call2(Lwt[6], r, _b_);
   }
   function symbol(e, f){return map(f, e);}
   function map$0(t, f){return map(f, t);}
   function bind(t, f){return symbol_bind(t, f);}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, map$0, bind, both, Open_on_rhs],
    Let_syntax$0 = [0, Let_syntax];
   function let$0(x, f){return map(f, x);}
   var
    Syntax = [0, symbol_bind, both, let$0, both],
    Lwt_result =
      [0,
       return$0,
       fail,
       lift,
       ok,
       error,
       catch$0,
       get_exn,
       map,
       map_error,
       symbol_bind,
       bind_error,
       bind_lwt,
       bind_lwt_error,
       bind_result,
       both,
       iter,
       iter_error,
       [0, symbol, symbol_bind],
       Let_syntax$0,
       Syntax,
       symbol,
       symbol_bind,
       map_err,
       bind_lwt_err];
   runtime.caml_register_global(3, Lwt_result, "Lwt_result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_pqueue
//# unitInfo: Requires: Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, "src/core/lwt_pqueue.ml", 81, 15];
   function Make(Ord){
    function link(t1, t2){
     var
      c2 = t2[3],
      r2 = t2[2],
      x2 = t2[1],
      c1 = t1[3],
      r1 = t1[2],
      x1 = t1[1],
      c = caml_call2(Ord[1], x1, x2);
     return 0 < c
             ? [0, x2, r2 + 1 | 0, [0, t1, c2]]
             : [0, x1, r1 + 1 | 0, [0, t2, c1]];
    }
    function ins(t, ts){
     var t$0 = t, ts$0 = ts;
     for(;;){
      if(! ts$0) return [0, t$0, 0];
      var t$1 = ts$0[1];
      if(t$0[2] < t$1[2]) return [0, t$0, ts$0];
      var ts$1 = ts$0[2], t$2 = link(t$0, t$1), t$0 = t$2, ts$0 = ts$1;
     }
    }
    var empty = 0;
    function is_empty(ts){return 0 === ts ? 1 : 0;}
    function add(x, ts){return ins([0, x, 0, 0], ts);}
    function union(ts$0, ts){
     if(! ts$0) return ts;
     if(! ts) return ts$0;
     var ts2 = ts[2], t2 = ts[1], ts1 = ts$0[2], t1 = ts$0[1];
     if(t1[2] < t2[2]) return [0, t1, union(ts1, [0, t2, ts2])];
     if(t2[2] < t1[2]) return [0, t2, union([0, t1, ts1], ts2)];
     var _e_ = union(ts1, ts2);
     return ins(link(t1, t2), _e_);
    }
    function find_min(param){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var t = param[1];
     if(! param[2]) return t[1];
     var ts = param[2], x = find_min(ts), c = caml_call2(Ord[1], t[1], x);
     return 0 <= c ? x : t[1];
    }
    function lookup_min(param){
     if(! param) return 0;
     var t = param[1];
     if(! param[2]) return [0, t[1]];
     var ts = param[2], result = lookup_min(ts);
     if(! result) return 0;
     var x = result[1], c = caml_call2(Ord[1], t[1], x);
     return 0 <= c ? result : [0, t[1]];
    }
    function get_min(param){
     if(! param)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var t = param[1];
     if(! param[2]) return [0, t, 0];
     var
      ts = param[2],
      match = get_min(ts),
      ts$0 = match[2],
      t$0 = match[1],
      c = caml_call2(Ord[1], t[1], t$0[1]);
     return 0 <= c ? [0, t$0, [0, t, ts$0]] : [0, t, ts];
    }
    function remove_min(ts){
     if(! ts) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var _d_ = get_min(ts), ts$0 = _d_[2], c = _d_[1][3];
     return union(caml_call1(Stdlib_List[10], c), ts$0);
    }
    function size(l){
     var _b_ = 0;
     function _c_(s, t){var tl = t[3]; return s + (1 + size(tl) | 0) | 0;}
     return caml_call3(Stdlib_List[26], _c_, _b_, l);
    }
    return [0,
            empty,
            is_empty,
            add,
            union,
            find_min,
            lookup_min,
            remove_min,
            size];
   }
   var Lwt_pqueue = [0, Make];
   runtime.caml_register_global(4, Lwt_pqueue, "Lwt_pqueue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_list
//# unitInfo: Requires: Lwt, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List;
   function tail_recursive_map(f, l){
    var _an_ = caml_call2(Stdlib_List[22], f, l);
    return caml_call1(Stdlib_List[10], _an_);
   }
   function tail_recursive_mapi_rev(f, l){
    var acc = 0, i = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      tl = param[2],
      hd = param[1],
      i$0 = i + 1 | 0,
      acc$0 = [0, caml_call2(f, i, hd), acc],
      acc = acc$0,
      i = i$0,
      param = tl;
    }
   }
   function iter_s(f, l){
    if(! l) return Lwt[36];
    var l$0 = l[2], x = l[1];
    function _al_(param){return iter_s(f, l$0);}
    var _am_ = caml_call2(Lwt[80], f, x);
    return caml_call2(Lwt[33][1], _am_, _al_);
   }
   function iter_p(f, l){
    var
     _ak_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[22], _ak_, l);
    return caml_call1(Lwt[14], ts);
   }
   function _a_(i, f, l){
    if(! l) return Lwt[36];
    var l$0 = l[2], x = l[1];
    function _ah_(param){return _a_(i + 1 | 0, f, l$0);}
    var _ai_ = caml_call1(f, i), _aj_ = caml_call2(Lwt[80], _ai_, x);
    return caml_call2(Lwt[33][1], _aj_, _ah_);
   }
   function iteri_s(f, l){return _a_(0, f, l);}
   function iteri_p(f, l){
    function f$0(i){
     var _ag_ = caml_call1(f, i);
     return caml_call1(Lwt[80], _ag_);
    }
    var ts = tail_recursive_mapi_rev(f$0, l);
    return caml_call1(Lwt[14], ts);
   }
   function map_s(f, l){
    function inner(acc, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       _ad_ = function(r){return inner([0, r, acc], tl);},
       _ae_ = caml_call2(Lwt[80], f, hd);
      return caml_call2(Lwt[33][1], _ae_, _ad_);
     }
     var _af_ = caml_call1(Stdlib_List[10], acc);
     return caml_call1(Lwt[4], _af_);
    }
    return inner(0, l);
   }
   function collect_rev(acc, param){
    if(! param) return caml_call1(Lwt[4], acc);
    var ts = param[2], t = param[1];
    function _ac_(i){return collect_rev([0, i, acc], ts);}
    return caml_call2(Lwt[33][1], t, _ac_);
   }
   function map_p(f, l){
    var
     _ab_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[22], _ab_, l);
    return collect_rev(0, ts);
   }
   function filter_map_s(f, l){
    function inner(acc, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       ___ =
         function(param){
          if(! param) return inner(acc, tl);
          var v = param[1];
          return inner([0, v, acc], tl);
         },
       _$_ = caml_call2(Lwt[80], f, hd);
      return caml_call2(Lwt[33][1], _$_, ___);
     }
     var _aa_ = caml_call1(Stdlib_List[10], acc);
     return caml_call1(Lwt[4], _aa_);
    }
    return inner(0, l);
   }
   function filter_map_p(f, l){
    function collect_optional_rev(acc, param){
     if(! param) return caml_call1(Lwt[4], acc);
     var ts = param[2], t = param[1];
     function _Z_(param){
      if(! param) return collect_optional_rev(acc, ts);
      var v = param[1];
      return collect_optional_rev([0, v, acc], ts);
     }
     return caml_call2(Lwt[33][1], t, _Z_);
    }
    var
     _Y_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[22], _Y_, l);
    return collect_optional_rev(0, ts);
   }
   function mapi_s(f, l){
    function inner(acc, i, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       _U_ = function(v){return inner([0, v, acc], i + 1 | 0, tl);},
       _V_ = caml_call1(f, i),
       _W_ = caml_call2(Lwt[80], _V_, hd);
      return caml_call2(Lwt[33][1], _W_, _U_);
     }
     var _X_ = caml_call1(Stdlib_List[10], acc);
     return caml_call1(Lwt[4], _X_);
    }
    return inner(0, 0, l);
   }
   function mapi_p(f, l){
    function f$0(i){
     var _T_ = caml_call1(f, i);
     return caml_call1(Lwt[80], _T_);
    }
    var ts = tail_recursive_mapi_rev(f$0, l);
    return collect_rev(0, ts);
   }
   function rev_map_append_s(acc, f, l){
    if(! l) return caml_call1(Lwt[4], acc);
    var l$0 = l[2], x = l[1];
    function _R_(x){return rev_map_append_s([0, x, acc], f, l$0);}
    var _S_ = caml_call2(Lwt[80], f, x);
    return caml_call2(Lwt[33][1], _S_, _R_);
   }
   function rev_map_s(f, l){return rev_map_append_s(0, f, l);}
   function rev_map_p(f, l$1){
    var acc$1 = Lwt[38], acc = acc$1, l = l$1;
    for(;;){
     if(! l) return acc;
     var
      l$0 = l[2],
      x = l[1],
      _O_ =
        function(acc){
          return function(x){
           function _Q_(l){return [0, x, l];}
           return caml_call2(Lwt[33][2], acc, _Q_);};
         }
         (acc),
      _P_ = caml_call2(Lwt[80], f, x),
      acc$0 = caml_call2(Lwt[33][1], _P_, _O_),
      acc = acc$0,
      l = l$0;
    }
   }
   function fold_left_s(f, acc, l){
    if(! l) return caml_call1(Lwt[4], acc);
    var l$0 = l[2], x = l[1];
    function _L_(acc){return fold_left_s(f, acc, l$0);}
    var _M_ = caml_call1(f, acc), _N_ = caml_call2(Lwt[80], _M_, x);
    return caml_call2(Lwt[33][1], _N_, _L_);
   }
   function fold_right_s(f, l, acc){
    function inner(f, a, param){
     if(! param) return caml_call1(Lwt[4], a);
     var tl = param[2], hd = param[1];
     function _I_(a){return inner(f, a, tl);}
     var _J_ = caml_call1(f, hd), _K_ = caml_call2(Lwt[80], _J_, a);
     return caml_call2(Lwt[33][1], _K_, _I_);
    }
    return inner(f, acc, caml_call1(Stdlib_List[10], l));
   }
   function for_all_s(f, l){
    if(! l) return Lwt[39];
    var l$0 = l[2], x = l[1];
    function _G_(param){return param ? for_all_s(f, l$0) : Lwt[40];}
    var _H_ = caml_call2(Lwt[80], f, x);
    return caml_call2(Lwt[33][1], _H_, _G_);
   }
   function for_all_p(f, l){
    function _C_(bl){
     function _E_(x){return x;}
     var _F_ = caml_call2(Stdlib_List[33], _E_, bl);
     return caml_call1(Lwt[4], _F_);
    }
    var _D_ = map_p(f, l);
    return caml_call2(Lwt[33][1], _D_, _C_);
   }
   function exists_s(f, l){
    if(! l) return Lwt[40];
    var l$0 = l[2], x = l[1];
    function _A_(param){return param ? Lwt[39] : exists_s(f, l$0);}
    var _B_ = caml_call2(Lwt[80], f, x);
    return caml_call2(Lwt[33][1], _B_, _A_);
   }
   function exists_p(f, l){
    function _w_(bl){
     function _y_(x){return x;}
     var _z_ = caml_call2(Stdlib_List[34], _y_, bl);
     return caml_call1(Lwt[4], _z_);
    }
    var _x_ = map_p(f, l);
    return caml_call2(Lwt[33][1], _x_, _w_);
   }
   function find_s(f, l){
    if(! l) return caml_call1(Lwt[5], Stdlib[8]);
    var l$0 = l[2], x = l[1];
    function _u_(param){
     return param ? caml_call1(Lwt[4], x) : find_s(f, l$0);
    }
    var _v_ = caml_call2(Lwt[80], f, x);
    return caml_call2(Lwt[33][1], _v_, _u_);
   }
   function optionalize(f, x){
    function _s_(b){return b ? caml_call1(Lwt[4], [0, x]) : Lwt[37];}
    var _t_ = caml_call1(f, x);
    return caml_call2(Lwt[33][1], _t_, _s_);
   }
   function filter_s(f, l){
    return filter_map_s(function(_r_){return optionalize(f, _r_);}, l);
   }
   function filter_p(f, l){
    return filter_map_p(function(_q_){return optionalize(f, _q_);}, l);
   }
   function partition_s(f, l){
    function inner(acc1, acc2, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       _m_ =
         function(b){
          return b
                  ? inner([0, hd, acc1], acc2, tl)
                  : inner(acc1, [0, hd, acc2], tl);
         },
       _n_ = caml_call2(Lwt[80], f, hd);
      return caml_call2(Lwt[33][1], _n_, _m_);
     }
     var
      _o_ = caml_call1(Stdlib_List[10], acc2),
      _p_ = [0, caml_call1(Stdlib_List[10], acc1), _o_];
     return caml_call1(Lwt[4], _p_);
    }
    return inner(0, 0, l);
   }
   function partition_p(f, l){
    function g(x){
     function _k_(b){return caml_call1(Lwt[4], [0, b, x]);}
     var _l_ = caml_call2(Lwt[80], f, x);
     return caml_call2(Lwt[33][1], _l_, _k_);
    }
    function _b_(tl){
     function _d_(_j_){return _j_[1];}
     var
      _e_ = caml_call2(Stdlib_List[44], _d_, tl),
      group1 = tail_recursive_map(function(_i_){return _i_[2];}, _e_);
     function _f_(x){return 1 - x[1];}
     var
      _g_ = caml_call2(Stdlib_List[44], _f_, tl),
      group2 = tail_recursive_map(function(_h_){return _h_[2];}, _g_);
     return caml_call1(Lwt[4], [0, group1, group2]);
    }
    var _c_ = map_p(g, l);
    return caml_call2(Lwt[33][1], _c_, _b_);
   }
   var
    Lwt_list =
      [0,
       iter_s,
       iter_p,
       iteri_s,
       iteri_p,
       map_s,
       map_p,
       mapi_s,
       mapi_p,
       rev_map_s,
       rev_map_p,
       fold_left_s,
       fold_right_s,
       for_all_s,
       for_all_p,
       exists_s,
       exists_p,
       find_s,
       filter_s,
       filter_p,
       filter_map_s,
       filter_map_p,
       partition_s,
       partition_p];
   runtime.caml_register_global(3, Lwt_list, "Lwt_list");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_pool
//# unitInfo: Requires: Lwt, Lwt_list, Lwt_sequence, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Lwt_list = global_data.Lwt_list,
    Lwt = global_data.Lwt;
   function create(m, opt, _H_, _G_, create){
    if(opt)
     var sth = opt[1], validate = sth;
    else
     var validate = function(param){return Lwt[39];};
    if(_H_)
     var sth$0 = _H_[1], check = sth$0;
    else
     var check = function(param, f){return caml_call1(f, 1);};
    if(_G_)
     var sth$1 = _G_[1], dispose = sth$1;
    else
     var dispose = function(param){return Lwt[36];};
    var _I_ = caml_call1(Lwt_sequence[4], 0);
    return [0,
            create,
            check,
            validate,
            dispose,
            [0, [0, 0]],
            m,
            0,
            caml_call1(Stdlib_Queue[2], 0),
            _I_];
   }
   function create_member(p){
    function _E_(exn){p[7] = p[7] - 1 | 0; return caml_call1(Lwt[5], exn);}
    function _F_(param){p[7] = p[7] + 1 | 0; return caml_call1(p[1], 0);}
    return caml_call2(Lwt[7], _F_, _E_);
   }
   function release(p, c){
    var match = caml_call1(Lwt_sequence[13], p[9]);
    if(! match) return caml_call2(Stdlib_Queue[4], c, p[8]);
    var wakener = match[1];
    return caml_call2(Lwt[2], wakener, c);
   }
   function dispose(p, c){
    function _C_(param){p[7] = p[7] - 1 | 0; return Lwt[36];}
    var _D_ = caml_call1(p[4], c);
    return caml_call2(Lwt[33][1], _D_, _C_);
   }
   function validate_and_return(p, c){
    function _s_(e){
     function _x_(param){
      var match = caml_call1(Lwt_sequence[13], p[9]);
      if(match){
       var
        wakener = match[1],
        _z_ = function(exn){return caml_call2(Lwt[3], wakener, exn);},
        _A_ = function(c){return caml_call2(Lwt[2], wakener, c);},
        _B_ = caml_call2(Lwt[80], p[1], 0);
       caml_call3(Lwt[32], _B_, _A_, _z_);
      }
      throw caml_maybe_attach_backtrace(e, 0);
     }
     var _y_ = dispose(p, c);
     return caml_call2(Lwt[33][1], _y_, _x_);
    }
    function _t_(param){
     if(param) return caml_call1(Lwt[4], c);
     function _v_(param){return create_member(p);}
     var _w_ = dispose(p, c);
     return caml_call2(Lwt[33][1], _w_, _v_);
    }
    function _u_(param){return caml_call1(p[3], c);}
    return caml_call3(Lwt[9], _u_, _t_, _s_);
   }
   function use(p, f){
    function _h_(c){
     var cleared = p[5][1];
     function _k_(e){
      function _q_(param){return caml_call1(Lwt[5], e);}
      var cleared$0 = cleared[1], ok = [0, 0];
      function _p_(result){ok[1] = result; return 0;}
      caml_call2(p[2], c, _p_);
      a:
      {
       if(! cleared$0 && ok[1]){release(p, c); var _r_ = Lwt[36]; break a;}
       var _r_ = dispose(p, c);
      }
      return caml_call2(Lwt[33][1], _r_, _q_);
     }
     function _l_(param){return caml_call1(f, c);}
     var promise = caml_call2(Lwt[7], _l_, _k_);
     function _m_(param){
      if(cleared[1]){
       var _n_ = function(param){return promise;}, _o_ = dispose(p, c);
       return caml_call2(Lwt[33][1], _o_, _n_);
      }
      release(p, c);
      return promise;
     }
     return caml_call2(Lwt[33][1], promise, _m_);
    }
    if(caml_call1(Stdlib_Queue[13], p[8]))
     if(p[7] < p[6])
      var _i_ = create_member(p);
     else
      var
       _f_ = function(_j_){return validate_and_return(p, _j_);},
       _g_ = caml_call1(Lwt[55], p[9]),
       _i_ = caml_call2(Lwt[33][1], _g_, _f_);
    else
     var
      c = caml_call1(Stdlib_Queue[5], p[8]),
      _i_ = validate_and_return(p, c);
    return caml_call2(Lwt[33][1], _i_, _h_);
   }
   function clear(p){
    var _a_ = p[8], _b_ = 0;
    function _c_(l, element){return [0, element, l];}
    var elements = caml_call3(Stdlib_Queue[16], _c_, _b_, _a_);
    caml_call1(Stdlib_Queue[11], p[8]);
    var old_cleared = p[5][1];
    old_cleared[1] = 1;
    p[5][1] = [0, 0];
    function _d_(_e_){return dispose(p, _e_);}
    return caml_call2(Lwt_list[1], _d_, elements);
   }
   function wait_queue_length(p){return caml_call1(Lwt_sequence[7], p[9]);}
   var Lwt_pool = [0, create, use, clear, wait_queue_length];
   runtime.caml_register_global(4, Lwt_pool, "Lwt_pool");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_mvar
//# unitInfo: Requires: Lwt, Lwt_sequence
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence;
   function create_empty(param){
    var _c_ = caml_call1(Lwt_sequence[4], 0);
    return [0, 0, caml_call1(Lwt_sequence[4], 0), _c_];
   }
   function create(v){
    var _b_ = caml_call1(Lwt_sequence[4], 0);
    return [0, [0, v], caml_call1(Lwt_sequence[4], 0), _b_];
   }
   function put(mvar, v){
    if(mvar[1]){
     var
      match = caml_call1(Lwt[22], 0),
      w = match[2],
      res = match[1],
      node = caml_call2(Lwt_sequence[9], [0, v, w], mvar[2]),
      _a_ = function(param){return caml_call1(Lwt_sequence[3], node);};
     caml_call2(Lwt[24], res, _a_);
     return res;
    }
    var match$0 = caml_call1(Lwt_sequence[13], mvar[3]);
    if(match$0){
     var w$0 = match$0[1];
     caml_call2(Lwt[2], w$0, v);
    }
    else
     mvar[1] = [0, v];
    return Lwt[36];
   }
   function take_available(mvar){
    var match$1 = mvar[1];
    if(! match$1) return 0;
    var v$0 = match$1[1], match = caml_call1(Lwt_sequence[13], mvar[2]);
    if(match){
     var match$0 = match[1], w = match$0[2], v = match$0[1];
     mvar[1] = [0, v];
     caml_call2(Lwt[2], w, 0);
    }
    else
     mvar[1] = 0;
    return [0, v$0];
   }
   function take(mvar){
    var match = take_available(mvar);
    if(! match) return caml_call1(Lwt[55], mvar[3]);
    var v = match[1];
    return caml_call1(Lwt[4], v);
   }
   function is_empty(mvar){return mvar[1] ? 0 : 1;}
   var
    Lwt_mvar = [0, create, create_empty, put, take, take_available, is_empty];
   runtime.caml_register_global(2, Lwt_mvar, "Lwt_mvar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_mutex
//# unitInfo: Requires: Lwt, Lwt_sequence
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Lwt = global_data.Lwt;
   function create(param){return [0, 0, caml_call1(Lwt_sequence[4], 0)];}
   function lock(m){
    return m[1] ? caml_call1(Lwt[55], m[2]) : (m[1] = 1, Lwt[36]);
   }
   function unlock(m){
    var _d_ = m[1];
    if(! _d_) return _d_;
    if(caml_call1(Lwt_sequence[6], m[2])){m[1] = 0; return 0;}
    var _e_ = caml_call1(Lwt_sequence[11], m[2]);
    return caml_call2(Lwt[2], _e_, 0);
   }
   function with_lock(m, f){
    function _a_(param){
     function _c_(param){unlock(m); return Lwt[36];}
     return caml_call2(Lwt[8], f, _c_);
    }
    var _b_ = lock(m);
    return caml_call2(Lwt[33][1], _b_, _a_);
   }
   function is_locked(m){return m[1];}
   function is_empty(m){return caml_call1(Lwt_sequence[6], m[2]);}
   var Lwt_mutex = [0, create, lock, unlock, is_locked, is_empty, with_lock];
   runtime.caml_register_global(2, Lwt_mutex, "Lwt_mutex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_condition
//# unitInfo: Requires: Lwt, Lwt_mutex, Lwt_sequence, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_List = global_data.Stdlib__List,
    Lwt_mutex = global_data.Lwt_mutex,
    create = Lwt_sequence[4];
   function wait(mutex, cvar){
    var waiter = caml_call1(Lwt[55], cvar);
    if(mutex){var m = mutex[1]; caml_call1(Lwt_mutex[3], m);}
    function _k_(param){
     if(! mutex) return Lwt[36];
     var m = mutex[1];
     return caml_call1(Lwt_mutex[2], m);
    }
    function _l_(param){return waiter;}
    return caml_call2(Lwt[8], _l_, _k_);
   }
   function signal(cvar, arg){
    try{
     var
      _h_ = caml_call1(Lwt_sequence[11], cvar),
      _i_ = caml_call2(Lwt[2], _h_, arg);
     return _i_;
    }
    catch(_j_){
     var _g_ = caml_wrap_exception(_j_);
     if(_g_ === Lwt_sequence[10]) return 0;
     throw caml_maybe_attach_backtrace(_g_, 0);
    }
   }
   function broadcast(cvar, arg){
    var _d_ = 0;
    function _e_(x, l){return [0, x, l];}
    var wakeners = caml_call3(Lwt_sequence[22], _e_, cvar, _d_);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], cvar);
    function _f_(wakener){return caml_call2(Lwt[2], wakener, arg);}
    return caml_call2(Stdlib_List[18], _f_, wakeners);
   }
   function broadcast_exn(cvar, exn){
    var _a_ = 0;
    function _b_(x, l){return [0, x, l];}
    var wakeners = caml_call3(Lwt_sequence[22], _b_, cvar, _a_);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], cvar);
    function _c_(wakener){return caml_call2(Lwt[3], wakener, exn);}
    return caml_call2(Stdlib_List[18], _c_, wakeners);
   }
   var Lwt_condition = [0, create, wait, signal, broadcast, broadcast_exn];
   runtime.caml_register_global(4, Lwt_condition, "Lwt_condition");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJsd3QuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImdldCIsIm5vZGUiLCJzZXQiLCJkYXRhIiwicmVtb3ZlIiwiY3JlYXRlIiwic2VxIiwiY2xlYXIiLCJpc19lbXB0eSIsImxlbmd0aCIsImN1cnIkMSIsImN1cnIiLCJsZW4iLCJsZW4kMCIsImN1cnIkMCIsImFkZF9sIiwiYWRkX3IiLCJ0YWtlX2wiLCJ0YWtlX3IiLCJ0YWtlX29wdF9sIiwidGFrZV9vcHRfciIsInRyYW5zZmVyX2wiLCJzMSIsInMyIiwidHJhbnNmZXJfciIsIml0ZXJfbCIsImYiLCJpdGVyX3IiLCJpdGVyX25vZGVfbCIsIml0ZXJfbm9kZV9yIiwiZm9sZF9sIiwiYWNjIiwiY3VyciQyIiwiYWNjJDAiLCJhY2MkMSIsImZvbGRfciIsImZpbmRfbm9kZV9sIiwiZmluZF9ub2RlX3IiLCJmaW5kX25vZGVfb3B0X2wiLCJmaW5kX25vZGVfb3B0X3IiLCJjb21wYXJlIiwic3RhdGVfb2ZfcmVzdWx0IiwieCIsImV4biIsInVuZGVybHlpbmciLCJwIiwicCQwIiwicCQxIiwic2V0X3Byb21pc2Vfc3RhdGUiLCJzdGF0ZSIsImhhbmRsZV9hbGwiLCJoYW5kbGVfYWxsX2V4Y2VwdF9ydW50aW1lIiwidiIsInJ1biIsImUiLCJuZXh0X2tleV9pZCIsIm5ld19rZXkiLCJpZCIsImN1cnJlbnRfc3RvcmFnZSIsImtleSIsInJlZnJlc2giLCJ2YWx1ZSIsIndpdGhfdmFsdWUiLCJuZXdfc3RvcmFnZSIsInNhdmVkX3N0b3JhZ2UiLCJyZXN1bHQiLCJleG4kMCIsImNvbmNhdF9yZWd1bGFyX2NhbGxiYWNrcyIsImwxIiwibDIiLCJjbGVhbl91cF9jYWxsYmFja19jZWxscyIsImNhbGxiYWNrcyIsImwxJDAiLCJsMiQwIiwiY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsIiwiY2VsbCIsInBzIiwiY2xlYW51cHNfZGVmZXJyZWQiLCJhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGUiLCJleGlzdGluZyIsIm5vZGUkMCIsImFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhYyIsImFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYiIsInNlbGZfcmVtb3ZpbmdfY2FsbGJhY2tfd3JhcHBlciIsImFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYiQwIiwiYWRkX2NhbmNlbF9jYWxsYmFjayIsImFzeW5jX2V4Y2VwdGlvbl9ob29rIiwiaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvIiwicnVuX2NhbGxiYWNrcyIsImlzX2NhbmNlbGVkIiwiZnMiLCJpdGVyX2NhbGxiYWNrX2xpc3QkMiIsInJlc3QiLCJmcyQwIiwicmVzdCQwIiwiaXRlcl9saXN0JDAiLCJmcyQxIiwiZnMkMiIsInJlc3QkMSIsInN0b3JhZ2UiLCJpdGVyX2NhbGxiYWNrX2xpc3QiLCJpdGVyX2NhbGxiYWNrX2xpc3QkMSIsIml0ZXJfbGlzdCIsImYkMCIsIml0ZXJfY2FsbGJhY2tfbGlzdCQwIiwiY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIiwiZGVmZXJyZWRfY2FsbGJhY2tzIiwiZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpIiwibGVhdmVfcmVzb2x1dGlvbl9sb29wIiwic3RvcmFnZV9zbmFwc2hvdCIsInJ1bl9pbl9yZXNvbHV0aW9uX2xvb3AiLCJhYmFuZG9uX3dha2V1cHMiLCJydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW0iLCJvcHQiLCJzdGgiLCJhbGxvd19kZWZlcnJpbmciLCJzdGgkMCIsIm1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCIsInNob3VsZF9kZWZlciIsInJlc29sdmUiLCJydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXQiLCJpZl9kZWZlcnJlZCIsInJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaSIsImRlZmVycmVkX3Jlc3VsdCIsImRlZmVycmVkX2NhbGxiYWNrIiwiaW1tZWRpYXRlX3Jlc3VsdCIsImRlZmVycmVkX3JlY29yZCIsIndha2V1cF9nZW5lcmFsIiwiYXBpX2Z1bmN0aW9uX25hbWUiLCJyIiwicmVzdWx0JDAiLCJ3YWtldXBfcmVzdWx0Iiwid2FrZXVwIiwid2FrZXVwX2V4biIsIndha2V1cF9sYXRlcl9nZW5lcmFsIiwid2FrZXVwX2xhdGVyX3Jlc3VsdCIsIndha2V1cF9sYXRlciIsIndha2V1cF9sYXRlcl9leG4iLCJjYW5jZWwiLCJjYW5jZWxlZF9yZXN1bHQiLCJjYW5jZWxfYW5kX2NvbGxlY3RfY2FsbGJhY2tzIiwiY2FsbGJhY2tzX2FjY3VtdWxhdG9yIiwicCQyIiwicGFyYW0iLCJyZXR1cm4kMCIsIm9mX3Jlc3VsdCIsImZhaWwiLCJyZXR1cm5fdW5pdCIsInJldHVybl9ub25lIiwicmV0dXJuX3NvbWUiLCJyZXR1cm5fbmlsIiwicmV0dXJuX3RydWUiLCJyZXR1cm5fZmFsc2UiLCJyZXR1cm5fb2siLCJyZXR1cm5fZXJyb3IiLCJmYWlsX3dpdGgiLCJtc2ciLCJmYWlsX2ludmFsaWRfYXJnIiwibmV3X3BlbmRpbmciLCJob3dfdG9fY2FuY2VsIiwid2FpdCIsInRhc2siLCJhZGRfdGFza19yIiwic2VxdWVuY2UiLCJhZGRfdGFza19sIiwicHJvdGVjdGVkJDAiLCJwX2ludGVybmFsIiwiY2FsbGJhY2siLCJwX3Jlc3VsdCIsInJlbW92ZV90aGVfY2FsbGJhY2siLCJwX2NhbGxiYWNrcyIsIm5vX2NhbmNlbCIsIm1ha2VfaW50b19wcm94eSIsIm91dGVyX3Byb21pc2UiLCJ1c2VyX3Byb3ZpZGVkX3Byb21pc2UiLCJvdXRlcl9jYWxsYmFja3MiLCJyZWd1bGFyX2NhbGxiYWNrcyIsImNsZWFudXBzX2RlZmVycmVkJDAiLCJyZWd1bGFyX2NhbGxiYWNrcyQwIiwiY2FuY2VsX2NhbGxiYWNrcyIsInN5bWJvbF9iaW5kIiwiY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsIiwiYmFja3RyYWNlX2JpbmQiLCJhZGRfbG9jIiwic3ltYm9sIiwicF9yZXN1bHQkMCIsImNhdGNoJDAiLCJoIiwiYmFja3RyYWNlX2NhdGNoIiwidHJ5X2JpbmQiLCJleG4kMSIsInAkMyIsImJhY2t0cmFjZV90cnlfYmluZCIsImZpbmFsaXplIiwiYmFja3RyYWNlX2ZpbmFsaXplIiwib25fY2FuY2VsIiwib25fc3VjY2VzcyIsImNhbGxiYWNrX2lmX2RlZmVycmVkIiwib25fZmFpbHVyZSIsIm9uX3Rlcm1pbmF0aW9uIiwib25fYW55IiwiZyIsIndyYXBfaW5fY2FuY2VsYWJsZSIsInBfdW5kZXJseWluZyIsImRvbnRfd2FpdCIsImFzeW5jIiwiaWdub3JlX3Jlc3VsdCIsImpvaW4iLCJudW1iZXJfcGVuZGluZ19pbl9wcyIsImpvaW5fcmVzdWx0IiwibmV3X3Jlc3VsdCIsInBzJDAiLCJwcyQxIiwiYm90aCIsInAxIiwicDIiLCJwYWlyIiwicDEkMCIsInAyJDAiLCJ2MiIsInYxIiwiYWxsIiwieSIsInZzIiwiaW5kZXgiLCJpJDEiLCJpIiwiaSQwIiwiY291bnRfcmVzb2x2ZWRfcHJvbWlzZXNfaW4iLCJ0b3RhbCQxIiwicHMkMiIsInBzJDMiLCJ0b3RhbCQyIiwicmVqZWN0ZWQkMSIsInRvdGFsIiwicmVqZWN0ZWQiLCJyZWplY3RlZCQwIiwidG90YWwkMCIsIm50aF9yZXNvbHZlZCIsIm4iLCJuJDAiLCJuJDIiLCJuJDEiLCJudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW4iLCJwcm5nIiwiY2hvb3NlIiwicGljayIsInFzIiwiY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0IiwicmVzdWx0cyIsInJlc3VsdHMkMCIsInJlc3VsdHMkMSIsIm5jaG9vc2UiLCJ2JDAiLCJucGljayIsIm5jaG9vc2Vfc3BsaXQiLCJwZW5kaW5nX2FjYyIsInRvX3Jlc29sdmUiLCJmdWxmaWxsZWQiLCJwZW5kaW5nIiwicGVuZGluZyQwIiwiZnVsZmlsbGVkJDAiLCJwX2ludGVybmFsJDAiLCJwZW5kaW5nX2FjYyQwIiwiZGVidWdfc3RhdGVfaXMiLCJleHBlY3RlZF9zdGF0ZSIsImlzX3NsZWVwaW5nIiwicG9sbCIsImFwcGx5Iiwid3JhcCIsIndyYXAxIiwieDEiLCJ3cmFwMiIsIngyIiwid3JhcDMiLCJ4MyIsIndyYXA0IiwieDQiLCJ3cmFwNSIsIng1Iiwid3JhcDYiLCJ4NiIsIndyYXA3IiwieDciLCJwYXVzZV9ob29rIiwicGF1c2VkIiwicGF1c2UiLCJ3YWtldXBfcGF1c2VkIiwidG1wIiwicmVnaXN0ZXJfcGF1c2Vfbm90aWZpZXIiLCJhYmFuZG9uX3BhdXNlZCIsInBhdXNlZF9jb3VudCIsIm1hcCIsInQiLCJiaW5kIiwic3ltYm9sJDAiLCJzeW1ib2wkMSIsInN5bWJvbCQyIiwic3ltYm9sJDMiLCJsZXQkMCIsImlzX29uIiwic3dpdGNoJDAiLCJjaGVjayIsImFkZF9ob29rIiwiaG9vayIsIm9zIiwiYWRkX2hvb2tfb3JfZXhlYyIsInR1cm5fb2ZmIiwiaG9va3MiLCJ3aXRoX3N3aXRjaCIsImZuIiwiZW1wdHkiLCJyZXR1cm5fbHd0IiwiY29ucyIsImNvbnNfbHd0Iiwic2VxMSIsInNlcTIiLCJuZXh0IiwiYXBwZW5kIiwieCQwIiwibWFwX3MiLCJmaWx0ZXJfbWFwIiwiZmlsdGVyX21hcF9zIiwib2siLCJmaWx0ZXIiLCJmaWx0ZXJfcyIsImZsYXRfbWFwX2FwcCIsInRhaWwiLCJmbGF0X21hcCIsImZvbGRfbGVmdCIsImF1eCIsImZvbGRfbGVmdF9zIiwiaXRlciIsIml0ZXJfcyIsIml0ZXJfcCIsIml0ZXJfbiIsIm1heF9jb25jdXJyZW5jeSIsIm1lc3NhZ2UiLCJsb29wIiwicnVubmluZyIsImF2YWlsYWJsZSIsImVsdCIsImNvbXBsZXRlIiwidW5mb2xkIiwidSIsImV4YyQwIiwiZXhjIiwidSQwIiwidW5mb2xkX2x3dCIsIm9mX2xpc3QiLCJsIiwidG9fbGlzdCIsIm9mX3NlcSIsIm5leHQkMCIsIm9mX3NlcV9sd3QiLCJuZXdfbm9kZSIsImNsb25lIiwicyIsImZyb21fc291cmNlIiwic291cmNlIiwiY2xvc2UiLCJjbG9zZWQiLCJmcm9tIiwiZnJvbV9kaXJlY3QiLCJpc19jbG9zZWQiLCJlbnF1ZXVlIiwibGFzdCIsIm5ld19sYXN0IiwiZW5xdWV1ZSQwIiwiY3JlYXRlX3dpdGhfcmVmZXJlbmNlIiwicHVzaF9zaWduYWxfcmVzb2x2ZXIiLCJwdXNoX3NpZ25hbCIsInB1c2hfc2lnbmFsX3Jlc29sdmVyJDAiLCJwdXNoIiwib2xkX3B1c2hfc2lnbmFsX3Jlc29sdmVyIiwibmV3X3B1c2hfc2lnbmFsX3Jlc29sdmVyIiwibmV3X3dhaXRlciIsImEiLCJzdHJlYW0iLCJzJDAiLCJvZl9sd3Rfc2VxIiwib2ZfaXRlciIsIm9mX2FycmF5Iiwib2Zfc3RyaW5nIiwibm90aWZ5X3B1c2hlciIsImluZm8iLCJvbGRfd2FrZW5lciIsIndha2VuZXIiLCJ3YWl0ZXIiLCJzZWxmXzEiLCJuZXdfd2FrZW5lciIsInNpemUiLCJjcmVhdGVfYm91bmRlZCIsInB1c2hfd2FrZW5lciIsInB1c2hfd2FpdGVyIiwid2FrZW5lcl9jZWxsIiwiZmVlZCIsInRocmVhZCIsInB1c2gkMCIsImNvbnN1bWUiLCJwZWVrX3JlYyIsInBlZWsiLCJucGVla19yZWMiLCJub2RlJDEiLCJucGVlayIsImdldF9yZWMiLCJnZXRfZXhuX3JlYyIsIndyYXBfZXhuIiwibmdldF9yZWMiLCJuZ2V0IiwiZ2V0X3doaWxlX3JlYyIsInRlc3QiLCJnZXRfd2hpbGUiLCJnZXRfd2hpbGVfc19yZWMiLCJnZXRfd2hpbGVfcyIsIm5leHRfcmVjIiwibGFzdF9uZXdfcmVjIiwieCQxIiwibGFzdF9uZXciLCJ0b19saXN0X3JlYyIsInRvX3N0cmluZ19yZWMiLCJidWYiLCJ0b19zdHJpbmciLCJqdW5rIiwibmp1bmtfcmVjIiwibmp1bmsiLCJqdW5rX3doaWxlX3JlYyIsImp1bmtfd2hpbGUiLCJqdW5rX3doaWxlX3NfcmVjIiwianVua193aGlsZV9zIiwianVua19hdmFpbGFibGUiLCJqdW5rX29sZCIsImdldF9hdmFpbGFibGUiLCJnZXRfYXZhaWxhYmxlX3VwX3RvIiwibWFwX2xpc3QiLCJwZW5kaW5ncyIsIm1hcF9saXN0X3MiLCJmbGF0dGVuIiwiZm9sZF9yZWMiLCJmb2xkIiwiZm9sZF9zX3JlYyIsImZvbGRfcyIsIml0ZXJfcmVjIiwiaXRlcl9zX3JlYyIsIml0ZXJfcF9yZWMiLCJyZXMiLCJmaW5kX3JlYyIsImZpbmQiLCJmaW5kX3NfcmVjIiwiZmluZF9zIiwiZmluZF9tYXBfcmVjIiwiZmluZF9tYXAiLCJmaW5kX21hcF9zX3JlYyIsImZpbmRfbWFwX3MiLCJjb21iaW5lIiwidDEiLCJ0MiIsIm4xIiwibjIiLCJjdXJyZW50X3MiLCJjb25jYXQiLCJzX3RvcCIsInN0cmVhbXMiLCJzdHJlYW1zJDAiLCJsJDAiLCJwYXJzZSIsImhleGR1bXAiLCJudW0iLCJwb3MiLCJwb3MkMSIsImNoIiwicG9zJDIiLCJsaWZ0IiwiZXJyb3IiLCJtYXBfZXJyb3IiLCJtYXBfZXJyIiwiZ2V0X2V4biIsImJpbmRfZXJyb3IiLCJiaW5kX2x3dCIsImJpbmRfcmVzdWx0IiwiYmluZF9sd3RfZXJyb3IiLCJiaW5kX2x3dF9lcnIiLCJiIiwic2V0X29uY2UiLCJiJDAiLCJhJDAiLCJpdGVyX2Vycm9yIiwibWFwJDAiLCJsaW5rIiwiYzIiLCJyMiIsImMxIiwicjEiLCJjIiwiaW5zIiwidCQwIiwidHMkMCIsInQkMSIsInRzJDEiLCJ0cyIsImFkZCIsInVuaW9uIiwidHMyIiwidHMxIiwiZmluZF9taW4iLCJsb29rdXBfbWluIiwiZ2V0X21pbiIsInJlbW92ZV9taW4iLCJ0bCIsInRhaWxfcmVjdXJzaXZlX21hcCIsInRhaWxfcmVjdXJzaXZlX21hcGlfcmV2IiwiaGQiLCJpdGVyaV9zIiwiaXRlcmlfcCIsImlubmVyIiwiY29sbGVjdF9yZXYiLCJtYXBfcCIsImZpbHRlcl9tYXBfcCIsImNvbGxlY3Rfb3B0aW9uYWxfcmV2IiwibWFwaV9zIiwibWFwaV9wIiwicmV2X21hcF9hcHBlbmRfcyIsInJldl9tYXBfcyIsInJldl9tYXBfcCIsImwkMSIsImZvbGRfcmlnaHRfcyIsImZvcl9hbGxfcyIsImZvcl9hbGxfcCIsImJsIiwiZXhpc3RzX3MiLCJleGlzdHNfcCIsIm9wdGlvbmFsaXplIiwiZmlsdGVyX3AiLCJwYXJ0aXRpb25fcyIsImFjYzEiLCJhY2MyIiwicGFydGl0aW9uX3AiLCJncm91cDEiLCJncm91cDIiLCJtIiwidmFsaWRhdGUiLCJzdGgkMSIsImRpc3Bvc2UiLCJjcmVhdGVfbWVtYmVyIiwicmVsZWFzZSIsInZhbGlkYXRlX2FuZF9yZXR1cm4iLCJ1c2UiLCJjbGVhcmVkIiwiY2xlYXJlZCQwIiwicHJvbWlzZSIsImVsZW1lbnQiLCJlbGVtZW50cyIsIm9sZF9jbGVhcmVkIiwid2FpdF9xdWV1ZV9sZW5ndGgiLCJjcmVhdGVfZW1wdHkiLCJwdXQiLCJtdmFyIiwidyIsInckMCIsInRha2VfYXZhaWxhYmxlIiwidGFrZSIsImxvY2siLCJ1bmxvY2siLCJ3aXRoX2xvY2siLCJpc19sb2NrZWQiLCJtdXRleCIsImN2YXIiLCJzaWduYWwiLCJhcmciLCJicm9hZGNhc3QiLCJ3YWtlbmVycyIsImJyb2FkY2FzdF9leG4iXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3QvbHd0X3NlcXVlbmNlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbHd0L2x3dC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2x3dC9sd3Rfc3dpdGNoLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbHd0L2x3dF9zZXEubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3QvbHd0X3N0cmVhbS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2x3dC9sd3RfcmVzdWx0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbHd0L2x3dF9wcXVldWUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3QvbHd0X2xpc3QubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3QvbHd0X3Bvb2wubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3QvbHd0X212YXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3QvbHd0X211dGV4Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbHd0L2x3dF9jb25kaXRpb24ubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHQUtBOzs7SUFBQTtZQXFCSUEsSUFBSUMsTUFDTixPQURNQSxRQUNRO1lBRVpDLElBQUlELE1BQUtFLE1BQUxGLFVBQUtFLGVBQ1c7WUFFcEJDLE9BQU9IO0lBQ1Q7V0FEU0E7OztXQUFBQSxhQUFBQSxhQUFBQSxTQUFBQSxhQUFBQTs7O0dBTU47WUFNREk7SUFDRixJQUFRQzs4QkFBQUEsU0FBQUEsS0FBQUE7SUFDUixPQURRQTtHQUNMO1lBRURDLE1BQU1ELEtBQUFBLFNBQUFBLEtBQUFBLFNBQUFBLGNBRU87WUFFYkUsU0FBU0YsS0FBTSxPQUFOQSxXQUFBQSxZQUFxQjtZQUU5QkcsT0FBT0g7SUFDVCxJQUFhSSxTQURKSixRQUNJSyxPQUFBRCxRQUFLRTtJQUNoQjtRQURXRCxTQURKTCxLQUdMLE9BRmNNO0tBSWlCLElBSmpCQyxRQUFBRCxhQUFMRSxTQUFBSCxTQUFBQSxPQUFBRyxRQUFLRixNQUFBQzs7R0FNSDtZQUViRSxNQUFNWixNQUFLRztJQUNGLElBQVBMLFdBRFNLLEtBQUFBLFFBQUxIO0lBQUtHLFlBQ1RMO0lBRFNLLFNBQ1RMO0lBR0osT0FISUE7R0FHQTtZQUVGZSxNQUFNYixNQUFLRztJQUNGLElBQVBMLFdBRFNLLFFBQUFBLEtBQUxIO0lBQUtHLFlBQ1RMO0lBRFNLLFNB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LE9BQUE7R0FDeUM7WUFFbER5QixVQUFVekIsR0FBSSxPQUFKQSxLQUFZO1lBQ3RCbmhCLFNBQVNtaEIsR0FBSSxtQ0FBSkEsTUFBbUM7dUJBekI1Q3RoQixRQUVBNGlCLE1BUUFDLFFBY0FFLFdBQ0E1aUIsVUFMQTJpQjs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7OztJQ0NBOWlCO1lBRUEySixLQUFNcVosT0FBTUM7SUFDRCxJQUFUbEwsU0FBUyxvQkFEQ2tMO0lBRWQsR0FGUUQsV0FJQzFCLElBSkQwQixVQUlNLHlCQUFMMUI7SUFHVDtLQUdLLEtBVkcwQixPQVlPO1NBREgxQixJQVhKMEI7S0FXUyxPQUFBLHlCQUFMMUI7SUFDa0I7d0JBSmpCLE9BUFR2SixPQU9lO0lBQ2pCLE9BQUE7R0FHNkI7WUFFN0JtTCxPQUFPRCxNQUFLRTtJQUNkO0tBQ21CO01BQUEsTUFBQSw2QkFGVkY7TUFFUCxNQUFBLHdCQUZZRTtLQUVaOzs7O2tDQUVBOzs7R0FBRTtZQUVGQyxVQUFVSCxNQUFLRTtJQUNqQjtpQkFBd0M5Z0IsR0FBRW9ULEdBQUssV0FBUHBULEdBQUVvVCxHQUFXO0lBQXRDLElBQVg0TixXQUFXLGtDQURISjtJQUVaLDhDQUZZQTtpQkFHR25MLFNBQVcsMEJBQVhBLFNBSEVxTCxLQUdxQztJQUR0RCxPQUFBLGlDQURJRTtHQUU0RDtZQUU5REMsY0FBY0wsTUFBSzNnQjtJQUNyQjtpQkFBd0NELEdBQUVvVCxHQUFLLFdBQVBwVCxHQUFFb1QsR0FBVztJQUF0QyxJQUFYNE4sV0FBVyxrQ0FEQ0o7SUFFaEIsOENBRmdCQTtpQkFHRG5MLFNBQVcsMEJBQVhBLFNBSE14VixLQUdxQztJQUQxRCxPQUFBLGlDQURJK2dCO0dBRWdFOzJCQTlCbEVyakIsUUFFQTJKLE1BY0F1WixRQU1BRSxXQUtBRTs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIHQgPSB7XG4gIG11dGFibGUgcHJldiA6ICdhIHQ7XG4gIG11dGFibGUgbmV4dCA6ICdhIHQ7XG59XG5cbnR5cGUgJ2Egbm9kZSA9IHtcbiAgbm9kZV9wcmV2IDogJ2EgdDtcbiAgbm9kZV9uZXh0IDogJ2EgdDtcbiAgbXV0YWJsZSBub2RlX2RhdGEgOiAnYTtcbiAgbXV0YWJsZSBub2RlX2FjdGl2ZSA6IGJvb2w7XG59XG5cbmV4dGVybmFsIHNlcV9vZl9ub2RlIDogJ2Egbm9kZSAtPiAnYSB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgbm9kZV9vZl9zZXEgOiAnYSB0IC0+ICdhIG5vZGUgPSBcIiVpZGVudGl0eVwiXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgT3BlcmF0aW9ucyBvbiBub2RlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxubGV0IGdldCBub2RlID1cbiAgbm9kZS5ub2RlX2RhdGFcblxubGV0IHNldCBub2RlIGRhdGEgPVxuICBub2RlLm5vZGVfZGF0YSA8LSBkYXRhXG5cbmxldCByZW1vdmUgbm9kZSA9XG4gIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlbiBiZWdpblxuICAgIG5vZGUubm9kZV9hY3RpdmUgPC0gZmFsc2U7XG4gICAgbGV0IHNlcSA9IHNlcV9vZl9ub2RlIG5vZGUgaW5cbiAgICBzZXEucHJldi5uZXh0IDwtIHNlcS5uZXh0O1xuICAgIHNlcS5uZXh0LnByZXYgPC0gc2VxLnByZXZcbiAgZW5kXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgT3BlcmF0aW9ucyBvbiBzZXF1ZW5jZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCByZWMgc2VxID0geyBwcmV2ID0gc2VxOyBuZXh0ID0gc2VxIH0gaW5cbiAgc2VxXG5cbmxldCBjbGVhciBzZXEgPVxuICBzZXEucHJldiA8LSBzZXE7XG4gIHNlcS5uZXh0IDwtIHNlcVxuXG5sZXQgaXNfZW1wdHkgc2VxID0gc2VxLm5leHQgPT0gc2VxXG5cbmxldCBsZW5ndGggc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgbGVuID1cbiAgICBpZiBjdXJyID09IHNlcSB0aGVuXG4gICAgICBsZW5cbiAgICBlbHNlXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW4gbG9vcCBub2RlLm5vZGVfbmV4dCAobGVuICsgMSlcbiAgaW5cbiAgbG9vcCBzZXEubmV4dCAwXG5cbmxldCBhZGRfbCBkYXRhIHNlcSA9XG4gIGxldCBub2RlID0geyBub2RlX3ByZXYgPSBzZXE7IG5vZGVfbmV4dCA9IHNlcS5uZXh0OyBub2RlX2RhdGEgPSBkYXRhOyBub2RlX2FjdGl2ZSA9IHRydWUgfSBpblxuICBzZXEubmV4dC5wcmV2IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIHNlcS5uZXh0IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIG5vZGVcblxubGV0IGFkZF9yIGRhdGEgc2VxID1cbiAgbGV0IG5vZGUgPSB7IG5vZGVfcHJldiA9IHNlcS5wcmV2OyBub2RlX25leHQgPSBzZXE7IG5vZGVfZGF0YSA9IGRhdGE7IG5vZGVfYWN0aXZlID0gdHJ1ZSB9IGluXG4gIHNlcS5wcmV2Lm5leHQgPC0gc2VxX29mX25vZGUgbm9kZTtcbiAgc2VxLnByZXYgPC0gc2VxX29mX25vZGUgbm9kZTtcbiAgbm9kZVxuXG5sZXQgdGFrZV9sIHNlcSA9XG4gIGlmIGlzX2VtcHR5IHNlcSB0aGVuXG4gICAgcmFpc2UgRW1wdHlcbiAgZWxzZSBiZWdpblxuICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgc2VxLm5leHQgaW5cbiAgICByZW1vdmUgbm9kZTtcbiAgICBub2RlLm5vZGVfZGF0YVxuICBlbmRcblxubGV0IHRha2VfciBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIHJhaXNlIEVtcHR5XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIHNlcS5wcmV2IGluXG4gICAgcmVtb3ZlIG5vZGU7XG4gICAgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0YWtlX29wdF9sIHNlcSA9XG4gIGlmIGlzX2VtcHR5IHNlcSB0aGVuXG4gICAgTm9uZVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBzZXEubmV4dCBpblxuICAgIHJlbW92ZSBub2RlO1xuICAgIFNvbWUgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0YWtlX29wdF9yIHNlcSA9XG4gIGlmIGlzX2VtcHR5IHNlcSB0aGVuXG4gICAgTm9uZVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBzZXEucHJldiBpblxuICAgIHJlbW92ZSBub2RlO1xuICAgIFNvbWUgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0cmFuc2Zlcl9sIHMxIHMyID1cbiAgczIubmV4dC5wcmV2IDwtIHMxLnByZXY7XG4gIHMxLnByZXYubmV4dCA8LSBzMi5uZXh0O1xuICBzMi5uZXh0IDwtIHMxLm5leHQ7XG4gIHMxLm5leHQucHJldiA8LSBzMjtcbiAgczEucHJldiA8LSBzMTtcbiAgczEubmV4dCA8LSBzMVxuXG5sZXQgdHJhbnNmZXJfciBzMSBzMiA9XG4gIHMyLnByZXYubmV4dCA8LSBzMS5uZXh0O1xuICBzMS5uZXh0LnByZXYgPC0gczIucHJldjtcbiAgczIucHJldiA8LSBzMS5wcmV2O1xuICBzMS5wcmV2Lm5leHQgPC0gczI7XG4gIHMxLnByZXYgPC0gczE7XG4gIHMxLm5leHQgPC0gczFcblxubGV0IGl0ZXJfbCBmIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyID1cbiAgICBpZiBjdXJyICE9IHNlcSB0aGVuIGJlZ2luXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlbiBmIG5vZGUubm9kZV9kYXRhO1xuICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dFxuICAgIGVuZFxuICBpblxuICBsb29wIHNlcS5uZXh0XG5cbmxldCBpdGVyX3IgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlLm5vZGVfZGF0YTtcbiAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXZcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBzZXEucHJldlxuXG5sZXQgaXRlcl9ub2RlX2wgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlO1xuICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dFxuICAgIGVuZFxuICBpblxuICBsb29wIHNlcS5uZXh0XG5cbmxldCBpdGVyX25vZGVfciBmIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyID1cbiAgICBpZiBjdXJyICE9IHNlcSB0aGVuIGJlZ2luXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlbiBmIG5vZGU7XG4gICAgICBsb29wIG5vZGUubm9kZV9wcmV2XG4gICAgZW5kXG4gIGluXG4gIGxvb3Agc2VxLnByZXZcblxubGV0IGZvbGRfbCBmIHNlcSBhY2MgPVxuICBsZXQgcmVjIGxvb3AgY3VyciBhY2MgPVxuICAgIGlmIGN1cnIgPT0gc2VxIHRoZW5cbiAgICAgIGFjY1xuICAgIGVsc2VcbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX25leHQgKGYgbm9kZS5ub2RlX2RhdGEgYWNjKVxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0IGFjY1xuICBpblxuICBsb29wIHNlcS5uZXh0IGFjY1xuXG5sZXQgZm9sZF9yIGYgc2VxIGFjYyA9XG4gIGxldCByZWMgbG9vcCBjdXJyIGFjYyA9XG4gICAgaWYgY3VyciA9PSBzZXEgdGhlblxuICAgICAgYWNjXG4gICAgZWxzZVxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW5cbiAgICAgICAgbG9vcCBub2RlLm5vZGVfcHJldiAoZiBub2RlLm5vZGVfZGF0YSBhY2MpXG4gICAgICBlbHNlXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXYgYWNjXG4gIGluXG4gIGxvb3Agc2VxLnByZXYgYWNjXG5cbmxldCBmaW5kX25vZGVfbCBmIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyID1cbiAgICBpZiBjdXJyICE9IHNlcSB0aGVuXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlblxuICAgICAgICBpZiBmIG5vZGUubm9kZV9kYXRhIHRoZW5cbiAgICAgICAgICBub2RlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0XG4gICAgICBlbHNlXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX25leHRcbiAgICBlbHNlXG4gICAgICByYWlzZSBOb3RfZm91bmRcbiAgaW5cbiAgbG9vcCBzZXEubmV4dFxuXG5sZXQgZmluZF9ub2RlX3IgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW5cbiAgICAgICAgaWYgZiBub2RlLm5vZGVfZGF0YSB0aGVuXG4gICAgICAgICAgbm9kZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbG9vcCBub2RlLm5vZGVfcHJldlxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9wcmV2XG4gICAgZWxzZVxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIGluXG4gIGxvb3Agc2VxLnByZXZcblxubGV0IGZpbmRfbm9kZV9vcHRfbCBmIHNlcSA9XG4gIHRyeSBTb21lIChmaW5kX25vZGVfbCBmIHNlcSkgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuXG5sZXQgZmluZF9ub2RlX29wdF9yIGYgc2VxID1cbiAgdHJ5IFNvbWUgKGZpbmRfbm9kZV9yIGYgc2VxKSB3aXRoIE5vdF9mb3VuZCAtPiBOb25lXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFJlYWRpbmcgZ3VpZGVcblxuICAgV2VsY29tZSB0byB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEx3dCBjb3JlISBUaGlzIGlzIGEgYmlnIGZpbGUsIGJ1dCB3ZVxuICAgaG9wZSB0aGF0IHJlYWRpbmcgaXQgKHBhcnRzIGF0IGEgdGltZSEpIHdpbGwgbm90IGJlIHNjYXJ5IDopIEhlcmUgaXMgd2h5OlxuXG5cbiAgICogU2VjdGlvbmluZ1xuXG4gICBUaGUgY29kZSBpcyBicm9rZW4gdXAgaW50byBzZWN0aW9ucywgZWFjaCBvbmUgb2Ygd2hpY2ggaXMgYW4gaW50ZXJuYWwgbW9kdWxlLlxuICAgTW9zdCBvZiB0aGUgbW9kdWxlcyBoYXZlIGEgc2lnbmF0dXJlLCB3aGljaCBzZXJ2ZXMgYXMgYSBuZWF0IHRhYmxlIG9mXG4gICBjb250ZW50cy5cblxuICAgSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgcmVhZCB0aGlzIGZpbGUgd2l0aCBjb2RlIGZvbGRpbmcgZW5hYmxlZC4gSWYgeW91XG4gICBmb2xkIGFsbCB0aGUgbW9kdWxlcywgeW91IGNhbiB2aXN1YWxpemUgdGhlIGxvZ2ljYWwgc3RydWN0dXJlIG9mIEx3dCBxdWl0ZVxuICAgZWFzaWx5LiBZb3UgY2FuIHRoZW4gZXhwYW5kIG1vZHVsZXMgYXMgbmVlZGVkLCBkZXBlbmRpbmcgb24gd2hhdCBwYXJ0IG9mIHRoZVxuICAgaW1wbGVtZW50YXRpb24geW91IGFyZSBpbnRlcmVzdGVkIGluLiBXaXRob3V0IGNvZGUgZm9sZGluZywgeW91IGZhY2UgYW5cbiAgIGludGltaWRhdGluZyB3YWxsIG9mIGNvZGUgOiggWW91IGNhbiBzdGlsbCB2aXN1YWxseSBwYXJzZSB0aGUgZmlsZSwgaG93ZXZlcixcbiAgIGJlY2F1c2UgdGhlcmUgYXJlIHBsZW50eSBvZiBibGFuayBsaW5lcyB0byBoZWxwIHNlY3Rpb24gdGhpbmdzIG9mZi4gWW91IGNhblxuICAgYWxzbyB2aWV3IHRoaXMgZmlsZSBmb2xkZWQgb25saW5lOlxuXG4gICAgIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2FhbnRyb24vOWZhYjBiZGVhZDk4YTYwZmNjZjA2ZTAxODkxODY4NjNcbiAgICAgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYWFudHJvbi85N2I1ODUyMGQ1YmI0ODU4Y2NhYzZmNTQ3MDBhMjRkN1xuXG4gICBUaGUgc2lnbmF0dXJlcyBhcmUgdW51c3VhbDogYmlnIGNvbW1lbnRzIGFyZSBhYnNlbnQuIFRoZXkgYXJlIG1vdmVkIGludG8gdGhlXG4gICBtb2R1bGVzLCBzbyB0aGF0IHRoZXkgYXJlIGhpZGRlbiBieSBjb2RlIGZvbGRpbmcgd2hlbiB5b3UgKHRoZSByZWFkZXIhKSBhcmVcbiAgIG5vdCBpbnRlcmVzdGVkIGluIHRob3NlIG1vZHVsZXMuXG5cblxuICAgKiBEb2N1bWVudGF0aW9uXG5cbiAgIFRoZSBkb2N1bWVudGF0aW9uIGJlZ2lucyB3aXRoIGFuIG92ZXJ2aWV3IG9mIG1ham9yIGNvbmNlcHRzIGFuZCBjb21wb25lbnRzLlxuICAgVGhpcyBvdmVydmlldyBwdXRzIGV2ZXJ5dGhpbmcgaW50byBjb250ZXh0LiBZb3UgZG9uJ3QgaGF2ZSB0byByZWFkIHRoZSB3aG9sZVxuICAgdGhpbmcuIFRoZSBvdmVydmlldyBiZWdpbnMgd2l0aCBiYXNpYyBjb25jZXB0cywgbW92ZXMgb24gdG8gYWR2YW5jZWQgb25lcyxcbiAgIGFuZCB0aGVuIGdldHMgaW50byB0aGUgdHJ1bHkgZXNvdGVyaWMuIFlvdSBjYW4gcmVhZCBhYm91dCBlYWNoIGNvbmNlcHQgb24gYW5cbiAgIGFzLW5lZWRlZCBiYXNpcy4gSG93ZXZlciwgb25jZSB5b3UgaGF2ZSByZWFkIHRoZSB3aG9sZSBvdmVydmlldywgeW91IHdpbGwgYmVcbiAgIGF3YXJlIG9mICpldmVyeXRoaW5nKiB0aGF0IGlzIG5lZWRlZCB0byB1bmRlcnN0YW5kLCBhbmQgd29yayB3aXRoLCB0aGUgY29yZVxuICAgb2YgTHd0LlxuXG4gICBMaXR0ZXJlZCBpbiB0aGUgY29kZSBhcmUgYWRkaXRpb25hbCBjb21tZW50cywgdGhhdCBnbyBpbi1kZXB0aCBvbiB2YXJpb3VzXG4gICBsb2NhbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLCBvcHBvcnR1bml0aWVzLCByZWdyZXRzLCBhbmQgdGhlIGxpa2UuXG5cbiAgIFRoZSBzZWN0aW9ucyAobW9kdWxlcykgb2YgdGhlIGNvZGUgY29ycmVzcG9uZCBjbG9zZWx5IHRvIHNlY3Rpb25zIG9mIHRoZVxuICAgb3ZlcnZpZXcuXG5cblxuICAgKiBXaGl0ZXNwYWNlXG5cbiAgIFRoZSB0b3RhbCBsaW5lIGNvdW50IG9mIHRoaXMgZmlsZSBtYXkgc2VlbSBmcmlnaHRlbmluZywgYnV0IG9uZSB0aGlyZCBvZiBpdFxuICAgaXMgd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGJvdGggdGhlcmUgdG8gaGVscCB5b3UgcmVhZCB0aGUgcmVtYWluaW5nIHR3b1xuICAgdGhpcmRzIVxuXG4gICBBbHNvLCB3aXRoaW4gdGhvc2UgdHdvIHRoaXJkcywgdGhlcmUgYXJlIGxhcmdlIGdyb3VwcyBvZiBmdW5jdGlvbnMgdGhhdCBhcmVcbiAgIHJlcGV0aXRpdmUgYW5kIGZvcm11bGFpYywgc28gdGhlcmUgaXMgbXVjaCBsZXNzIGNvbmNlcHR1YWxseS11bmlxdWUgY29kZSBpblxuICAgTHd0IHRoYW4geW91IG1pZ2h0IHRoaW5rIGF0IGZpcnN0LlxuXG5cbiAgICogUGxlYXNlIGVkaXQgdGhlIGNvZGUgYW5kIHRoZSBkb2NzIVxuXG4gICBUaGlzIGNvZGUgaXMgbWVhbnQgdG8gYmUgcmVhZGFibGUsIGFuZCB0byBiZSBlZGl0ZWQuIElmIHlvdSBhcmUgcmVhZGluZ1xuICAgc29tZXRoaW5nLCBhbmQgdGhpbmsgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRvIGV4cHJlc3MgaXQsIHBsZWFzZSBnbyBhaGVhZCBhbmRcbiAgIG9wZW4gYSBwdWxsIHJlcXVlc3QgdG8gdGhlIEx3dCByZXBvc2l0b3J5IGF0XG5cbiAgICAgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0XG5cbiAgIEV2ZW4gaWYgeW91ciBwdWxsIHJlcXVlc3Qgc29tZWhvdyBkb2Vzbid0IGdldCBtZXJnZWQsIHlvdSB3aWxsIGhhdmUgZWR1Y2F0ZWRcbiAgIHRoZSBtYWludGFpbmVycywgbm90IHRvIG1lbnRpb24gb3RoZXIgY29udHJpYnV0b3JzLCBhbmQgdXNlcnMuIFRoaXMgaXMgdHJ1ZVxuICAgZXZlbiBpZiB0aGUgY2hhbmdlIGlzIHRyaXZpYWwgLS0gc29tZXRpbWVzLCBtYWludGFpbmVycyBqdXN0IG5lZWQgdG8gYmVcbiAgIGVkdWNhdGVkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSB0aGV5IHNlZSB0aGUgd2lzZG9tIG9mIGl0IDovXG5cbiAgIExpa2V3aXNlLCBpZiB5b3Ugd291bGQgbGlrZSB0byBtYWtlIGEgY29kZSBjb250cmlidXRpb24gdG8gdGhlIEx3dCBjb3JlLCBpdFxuICAgaXMgcXVpdGUgd2VsY29tZSwgYW5kIHdlIGhvcGUgdGhhdCB0aGlzIGNvZGUgaXMgcmVhZGFibGUgZW5vdWdoIGZvciB5b3UgdG8gYmVcbiAgIGFibGUgdG8gbWFrZSBpdCFcblxuXG4gICBFbmpveSEgKilcblxuXG5cbigqIE92ZXJ2aWV3XG5cbiAgIEluIHRoaXMgZmlsZSwgdGhlcmUgaXMgYSBcIm1vZGVsXCIgZnVuY3Rpb24gLS0gW0x3dC5iaW5kXSAtLSB3aGljaCBwdWxsc1xuICAgdG9nZXRoZXIgbWFueSAodGhvdWdoIG5vdCBhbGwpIG9mIHRoZSBjb25jZXB0cyBhbmQgaGVscGVycyBkaXNjdXNzZWQgaW4gdGhpc1xuICAgb3ZlcnZpZXcuIFRvIGZpbmQgaXQsIHNlYXJjaCBmb3IgXCJsZXQgYmluZCxcIiBhbmQgeW91IGNhbiBleGFtaW5lIGl0IHdoaWxlXG4gICByZWFkaW5nIHRoZSBvdmVydmlldy4gVGhlIGF1dGhvcnMgb2YgdGhpcyBmaWxlIGludGVuZCB0byBwdXQgZXh0cmEgZWZmb3J0XG4gICBpbnRvIHdyaXRpbmcgbmljZSBjb21tZW50cyBpbnNpZGUgW0x3dC5iaW5kXSA6KVxuXG5cbiAgIDAuIE1haW4gbWVjaGFuaXNtIGFuZCB0d28gYXNwZWN0c1xuXG4gICBUaGUgTHd0IGludGVyZmFjZSAoW2x3dC5tbGldKSBwcm92aWRlcyBvbmUgbWFpbiBtZWNoYW5pc20sIHByb21pc2VzLCBhbmQgdHdvXG4gICBcImFzcGVjdHMsXCIgd2hpY2ggYXJlICpub3QqIG5lY2Vzc2FyeSB0byB1bmRlcnN0YW5kIHRoZSBtYWluIG1lY2hhbmlzbVxuICAgcHJvbWlzZXMsIGJ1dCB0aGV5IGFyZSBzdGlsbCB0aGVyZTpcblxuICAgLSBwcm9taXNlIGNhbmNlbGxhdGlvblxuICAgLSBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2VcblxuICAgSWYgeW91IGFyZSBub3QgaW50ZXJlc3RlZCBpbiBjYW5jZWxsYXRpb24gb3Igc3RvcmFnZSwgeW91IGNhbiBpZ25vcmUgdGhlc2VcbiAgIHR3byBjb21wbGljYXRpb25zLCBhbmQgc3RpbGwgZ2V0IGEgcHJldHR5IGdvb2QgdW5kZXJzdGFuZGluZyBvZiB0aGUgY29kZS4gVG9cbiAgIGhlbHAsIGFsbCBpZGVudGlmaWVycyByZWxhdGVkIHRvIGNhbmNlbGxhdGlvbiBjb250YWluIHRoZSBzdHJpbmcgXCJjYW5jZWwsXCJcbiAgIGFuZCBhbGwgaWRlbnRpZmllcnMgcmVsYXRlZCB0byBzdG9yYWdlIGNvbnRhaW4gXCJzdG9yYWdlLlwiXG5cblxuICAgMS4gUHJvbWlzZXNcblxuICAgQSBwcm9taXNlIGlzIGEgY2VsbCB0aGF0IGNhbiBiZSBpbiBvbmUgb2YgdHdvIHN0YXRlczogXCJyZXNvbHZlZFwiIG9yXG4gICBcInBlbmRpbmcuXCJcblxuICAgLSBSZXNvbHZlZCBwcm9taXNlc1xuXG4gICAgIEEgcmVzb2x2ZWQgcHJvbWlzZSBpcyBlaXRoZXIgXCJmdWxmaWxsZWRcIiB3aXRoIGEgdmFsdWUsIG9yIFwicmVqZWN0ZWRcIiB3aXRoXG4gICAgIGFuIGV4Y2VwdGlvbi4gVGhlIHN0YXRlIG9mIGEgcmVzb2x2ZWQgcHJvbWlzZSB3aWxsIG5ldmVyIGNoYW5nZSBhZ2FpbjogYVxuICAgICByZXNvbHZlZCBwcm9taXNlIGlzIGltbXV0YWJsZS4gQSByZXNvbHZlZCBwcm9taXNlIGlzIGJhc2ljYWxseSBlcXVpdmFsZW50XG4gICAgIHRvIGFuIFsoJ2EsIGV4bikgU3RkbGliLnJlc3VsdF0uIFJlc29sdmVkIHByb21pc2VzIGFyZSBwcm9kdWNlZCBpbiB0d29cbiAgICAgd2F5czpcblxuICAgICAtIFtMd3QucmV0dXJuXSwgW0x3dC5mYWlsXSwgYW5kIHJlbGF0ZWQgZnVuY3Rpb25zLCBwcm9kdWNlIFwidHJpdmlhbFwiXG4gICAgICAgcHJvbWlzZXMgdGhhdCBhcmUgcmVzb2x2ZWQgZnJvbSB0aGUgc3RhcnQuXG4gICAgIC0gVGhlIG90aGVyIHdheSBpcyB0byByZXNvbHZlIGEgcHJvbWlzZSB0aGF0IHN0YXJ0ZWQgb3V0IHBlbmRpbmcuXG5cbiAgICAgTm90ZSB0aGF0IHJlamVjdGVkIHByb21pc2VzIGhhdmUgbm90aGluZyB0byBkbyB3aXRoIHVuaGFuZGxlZCBleGNlcHRpb25zLlxuXG4gICAtIFBlbmRpbmcgcHJvbWlzZXNcblxuICAgICAuLi5hcmUgdGhvc2UgdGhhdCBtYXkgYmVjb21lIHJlc29sdmVkIGluIHRoZSBmdXR1cmUuIEVhY2ggcGVuZGluZyBwcm9taXNlXG4gICAgIGNhcnJpZXMgYSBsaXN0IG9mIGNhbGxiYWNrcy4gVGhlc2UgY2FsbGJhY2tzIGFyZSBhZGRlZCBieSBmdW5jdGlvbnMgbGlrZVxuICAgICBbTHd0LmJpbmRdLCBhbmQgY2FsbGVkIGJ5IEx3dCBpZi93aGVuIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkLiBUaGVzZVxuICAgICBjYWxsYmFja3MgdHlwaWNhbGx5IGVuZCB1cCByZXNvbHZpbmcgYWRkaXRpb25hbCBwcm9taXNlczsgc2VlIHNlY3Rpb25cbiAgICAgXCJSZXNvbHV0aW9uIGxvb3BcIiBiZWxvdy5cblxuICAgICBQZW5kaW5nIHByb21pc2VzIGFyZSBwcm9kdWNlZCBpbiB0aHJlZSB3YXlzLCBhY2NvcmRpbmcgdG8gaG93IHRoZXkgY2FuIGJlXG4gICAgIHJlc29sdmVkOlxuXG4gICAgIC0gSW5pdGlhbCBwcm9taXNlc1xuXG4gICAgICAgLi4uYXJlIGNyZWF0ZWQgYnkgW0x3dC53YWl0XSBhbmQgW0x3dC50YXNrXS4gVGhlIHVzZXIgb2YgTHd0IHJlc29sdmVzXG4gICAgICAgdGhlc2UgcHJvbWlzZXMgbWFudWFsbHksIHRocm91Z2ggdGhlIHJlc29sdmVycyByZXR1cm5lZCBieSB0aG9zZVxuICAgICAgIGZ1bmN0aW9ucy5cblxuICAgICAtIFNlcXVlbnRpYWwgY29tcG9zaXRpb25cblxuICAgICAgIEZvciBleGFtcGxlLCBbTHd0LmJpbmRdLiBUaGVzZSBwcm9taXNlcyBvbmx5IGFyZSBvbmx5IHJlc29sdmVkIHdoZW4gdGhlXG4gICAgICAgcHJlY2VkaW5nIHNlcXVlbmNlIG9mIHByb21pc2VzIHJlc29sdmVzLiBUaGUgdXNlciBjYW5ub3QgcmVzb2x2ZSB0aGVzZVxuICAgICAgIHByb21pc2VzIGRpcmVjdGx5IChidXQgc2VlIHRoZSBzZWN0aW9uIG9uIGNhbmNlbGxhdGlvbiBiZWxvdykuXG5cbiAgICAgLSBDb25jdXJyZW50IGNvbXBvc2l0aW9uXG5cbiAgICAgICBGb3IgZXhhbXBsZSwgW0x3dC5qb2luXSBvciBbTHd0LmNob29zZV0uIFRoZXNlIHByb21pc2VzIGFyZSBvbmx5IHJlc29sdmVkXG4gICAgICAgd2hlbiBhbGwgb3Igb25lIG9mIGEgc2V0IG9mIFwicHJlY2VkaW5nXCIgcHJvbWlzZXMgcmVzb2x2ZS4gVGhlIHVzZXIgY2Fubm90XG4gICAgICAgcmVzb2x2ZSB0aGVzZSBwcm9taXNlcyBkaXJlY3RseSAoYnV0IHNlZSB0aGUgc2VjdGlvbiBvbiBjYW5jZWxsYXRpb25cbiAgICAgICBiZWxvdykuXG5cblxuICAgMi4gUmVzb2x2ZXJzXG5cbiAgIFJlc29sdmVycyBhcmUgZ2l2ZW4gdG8gdGhlIHVzZXIgYnkgW0x3dC53YWl0XSBhbmQgW0x3dC50YXNrXSwgYW5kIGNhbiBiZSB1c2VkXG4gICBieSB0aGUgdXNlciB0byByZXNvbHZlIHRoZSBjb3JyZXNwb25kaW5nIHByb21pc2VzLiBOb3RlIHRoYXQgdGhpcyBtZWFucyB0aGVcbiAgIHVzZXIgb25seSBldmVyIGdldHMgcmVzb2x2ZXJzIGZvciBpbml0aWFsIHByb21pc2VzLlxuXG4gICBJbnRlcm5hbGx5LCByZXNvbHZlcnMgYXJlIHRoZSBleGFjdCBzYW1lIG9iamVjdHMgYXMgdGhlIHByb21pc2VzIHRoZXlcbiAgIHJlc29sdmUsIGV2ZW4gdGhvdWdoIHRoZSByZXNvbHZlciBpcyBleHBvc2VkIGFzIGEgcmVmZXJlbmNlIG9mIGEgZGlmZmVyZW50XG4gICB0eXBlIGJ5IFtsd3QubWxpXS4gRm9yIGRldGFpbHMgb24gd2h5LCBzZWUgc2VjdGlvbiBcIlR5cGUgc3lzdGVtIGFidXNlXCIgYmVsb3cuXG5cblxuICAgMy4gQ2FsbGJhY2tzXG5cbiAgIC4uLmFyZSBhdHRhY2hlZCBieSBMd3QgdG8gcGVuZGluZyBwcm9taXNlcywgYW5kIGFyZSBydW4gYnkgTHd0IGlmL3doZW4gdGhvc2VcbiAgIHByb21pc2VzIGFyZSByZXNvbHZlZC4gVGhlc2UgY2FsbGJhY2tzIGFyZSBub3QgZGlyZWN0bHkgZXhwb3NlZCB0aHJvdWdoXG4gICBbbHd0Lm1saV0gLS0gdGhleSBhcmUgYSBsb3ctbGV2ZWwgbWVjaGFuaXNtLiBGb3IgZXhhbXBsZSwgdG8gaW1wbGVtZW50XG4gICBbTHd0LmJpbmQgcCBmXSwgTHd0IGF0dGFjaGVzIGEgY2FsbGJhY2sgdG8gW3BdIHRoYXQgZG9lcyBzb21lIGludGVybmFsIEx3dFxuICAgYm9vay1rZWVwaW5nLCBhbmQgdGhlbiBjYWxscyBbZl0gaWYgW3BdIGlzIGZ1bGZpbGxlZCwgYW5kIGRvZXMgc29tZXRoaW5nIGVsc2VcbiAgIGlmIFtwXSBpcyByZWplY3RlZC5cblxuICAgQ2FsbGJhY2tzIGNvbWUgaW4gdHdvIGZsYXZvcnM6IHJlZ3VsYXIgY2FsbGJhY2tzIGFuZCBjYW5jZWwgY2FsbGJhY2tzLiBUaGVcbiAgIG9ubHkgbWF0ZXJpYWwgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGVtIGFyZSB0aGF0OlxuXG4gICAtIHJlZ3VsYXIgY2FsbGJhY2tzIGFyZSBhbHdheXMgY2FsbGVkIHdoZW4gYSBwcm9taXNlIGlzIHJlc29sdmVkLCBidXQgY2FuY2VsXG4gICAgIGNhbGxiYWNrcyBhcmUgY2FsbGVkLCBpbiBhZGRpdGlvbiwgb25seSBpZiB0aGUgcHJvbWlzZSBpcyBjYW5jZWxlZCwgYW5kXG4gICAtIGFsbCBjYW5jZWwgY2FsbGJhY2tzIG9mIGEgcHJvbWlzZSBhcmUgY2FsbGVkIGJlZm9yZSBhbnkgcmVndWxhciBjYWxsYmFja1xuICAgICBpcyBjYWxsZWQuXG5cbiAgIENhbmNlbGxhdGlvbiBpcyBhIHNwZWNpYWwgY2FzZSBvZiByZXNvbHV0aW9uLCBpbiBwYXJ0aWN1bGFyLCBhIHNwZWNpYWwgY2FzZVxuICAgb2YgcmVqZWN0aW9uLCBidXQgc2VlIHRoZSBzZWN0aW9uIG9uIGNhbmNlbGxhdGlvbiBsYXRlciBiZWxvdy5cblxuXG4gICA0LiBSZXNvbHV0aW9uIGxvb3BcblxuICAgUmVzb2x2aW5nIGEgcGVuZGluZyBwcm9taXNlIHRyaWdnZXJzIGl0cyBjYWxsYmFja3MsIGFuZCB0aG9zZSBtaWdodCByZXNvbHZlXG4gICBtb3JlIHBlbmRpbmcgcHJvbWlzZXMsIHRyaWdnZXJpbmcgbW9yZSBjYWxsYmFja3MsIGV0Yy4gVGhpcyBiZWhhdmlvciBpcyB0aGVcbiAgICpyZXNvbHV0aW9uIGxvb3AqLiBMd3QgaGFzIHNvbWUgbWFjaGluZXJ5IHRvIGF2b2lkIHN0YWNrIG92ZXJmbG93IGFuZCBvdGhlclxuICAgdW5mb3J0dW5hdGUgc2l0dWF0aW9ucyBkdXJpbmcgdGhpcyBsb29wLlxuXG4gICBUaGlzIGNoYWluaW5nIG9mIHByb21pc2UgcmVzb2x1dGlvbnMgdGhyb3VnaCBjYWxsYmFja3MgY2FuIGJlIHNlZW4gYXMgYSBraW5kXG4gICBvZiBwcm9taXNlIGRlcGVuZGVuY3kgZ3JhcGgsIGluIHdoaWNoIHRoZSBub2RlcyBhcmUgcGVuZGluZyBwcm9taXNlcywgYW5kIHRoZVxuICAgZWRnZXMgYXJlIGNhbGxiYWNrcy4gRHVyaW5nIHRoZSByZXNvbHV0aW9uIGxvb3AsIEx3dCBzdGFydHMgYXQgc29tZSBpbml0aWFsXG4gICBwcm9taXNlIHRoYXQgaXMgZ2V0dGluZyByZXNvbHZlZCBieSB0aGUgdXNlciwgYW5kIHJlY3Vyc2l2ZWx5IHJlc29sdmVzIGFsbFxuICAgZGVwZW5kZW50IHByb21pc2VzLiBUaGUgZ3JhcGggaXMgbW9kaWZpZWQ6IHJlc29sdmVkIHByb21pc2VzIGFyZSBubyBsb25nZXJcbiAgIHBlbmRpbmcsIHNvIHRoZXkgYXJlIG5vIGxvbmdlciBwYXJ0IG9mIHRoZSBncmFwaC5cblxuICAgU29tZSBvZiB0aGVzZSBkZXBlbmRlbmNpZXMgYXJlIGV4cGxpY2l0IHRvIEx3dCwgZS5nLiB0aGUgY2FsbGJhY2tzIHJlZ2lzdGVyZWRcbiAgIGJ5IFtMd3QuYmluZF0uIE90aGVycyBhcmUgbm90IHZpc2libGUgdG8gTHd0LCBiZWNhdXNlIHRoZSB1c2VyIGNhbiBhbHdheXNcbiAgIHJlZ2lzdGVyIGEgY2FsbGJhY2sgdXNpbmcgYSBmdW5jdGlvbiBsaWtlIFtMd3Qub25fc3VjY2Vzc10sIGFuZCB1c2UgdGhhdFxuICAgY2FsbGJhY2sgdG8gcmVzb2x2ZSBhbm90aGVyIGluaXRpYWwgcHJvbWlzZS4gQWxsIHRoZSBleHBsaWNpdCBkZXBlbmRlbmNpZXNcbiAgIGFyZSBjcmVhdGVkIGJ5IEx3dCdzIG93biBzZXF1ZW50aWFsIGFuZCBjb25jdXJyZW50IGNvbXBvc2l0aW9uIGZ1bmN0aW9uc1xuICAgKHNvLCBbTHd0LmJpbmRdLCBbTHd0LmpvaW5dLCBldGMpLiBXaGV0aGVyIGRlcGVuZGVuY2llcyBhcmUgZXhwbGljaXQgb3Igbm90XG4gICBpcyByZWxldmFudCBvbmx5IHRvIGNhbmNlbGxhdGlvbi5cblxuXG4gICA1LiBDYW5jZWxsYXRpb25cblxuICAgQXMgZGVzY3JpYmVkIGFib3ZlLCBvcmRpbmFyeSBwcm9taXNlIHJlc29sdXRpb24gcHJvY2VlZHMgZnJvbSBhbiBpbml0aWFsXG4gICBwcm9taXNlLCBmb3J3YXJkIGFsb25nIGNhbGxiYWNrcyB0aHJvdWdoIHRoZSBkZXBlbmRlbmN5IGdyYXBoLiBTaW5jZSBpdFxuICAgc3RhcnRzIGZyb20gYW4gaW5pdGlhbCBwcm9taXNlLCBpdCBjYW4gb25seSBiZSB0cmlnZ2VyZWQgdXNpbmcgYSByZXNvbHZlci5cblxuICAgQ2FuY2VsbGF0aW9uIGlzIGEgc29ydCBvZiBkdWFsIHRvIG9yZGluYXJ5IHJlc29sdXRpb24uIEluc3RlYWQgb2Ygc3RhcnRpbmcgYXRcbiAgIGFuIGluaXRpYWwgcHJvbWlzZS9yZXNvbHZlciwgY2FuY2VsbGF0aW9uIHN0YXJ0cyBhdCAqYW55KiBwcm9taXNlLiBJdCB0aGVuXG4gICBnb2VzICpiYWNrd2FyZHMqIHRocm91Z2ggdGhlIGV4cGxpY2l0IGRlcGVuZGVuY3kgZ3JhcGgsIGxvb2tpbmcgZm9yXG4gICBjYW5jZWxhYmxlIGluaXRpYWwgcHJvbWlzZXMgdG8gY2FuY2VsIC0tIHRob3NlIHRoYXQgd2VyZSBjcmVhdGVkIGJ5XG4gICBbTHd0LnRhc2tdLiBBZnRlciBmaW5kaW5nIHRoZW0sIGNhbmNlbGxhdGlvbiByZXNvbHZlcyB0aGVtIG5vcm1hbGx5IHdpdGhcbiAgIFtSZWplY3RlZCBMd3QuQ2FuY2VsZWRdLCBjYXVzaW5nIGFuIG9yZGluYXJ5IHByb21pc2UgcmVzb2x1dGlvbiBwcm9jZXNzLlxuXG4gICBUbyBzdW1tYXJpemUsIGNhbmNlbGxhdGlvbiBpcyBhIHdheSB0byB0cmlnZ2VyIGFuICpvcmRpbmFyeSogcmVzb2x1dGlvbiBvZlxuICAgcHJvbWlzZXMgY3JlYXRlZCB3aXRoIFtMd3QudGFza10sIGJ5IGZpcnN0IHNlYXJjaGluZyBmb3IgdGhlbSBpbiB0aGUgcHJvbWlzZVxuICAgZGVwZW5kZW5jeSBncmFwaCAod2hpY2ggaXMgYXNzZW1ibGVkIGJ5IFtMd3QuYmluZF0sIFtMd3Quam9pbl0sIGV0YykuXG5cbiAgIFRoaXMgYmFja3dhcmRzIHNlYXJjaCBpcyB0cmlnZ2VyZWQgb25seSBieSBbTHd0LmNhbmNlbF0uIEl0IGlzIGFsc28gcG9zc2libGVcbiAgIGZvciB0aGUgdXNlciB0byBjYW5jZWwgYSBwcm9taXNlIGRpcmVjdGx5IGJ5IHJlamVjdGluZyBpdCB3aXRoXG4gICBbTHd0LkNhbmNlbGVkXSwgYnV0IGluIGFsbCBjYXNlcyB3aGVyZSB0aGUgdXNlciBjYW4gZG8gc28sIHRoZSBzZWFyY2ggd291bGRcbiAgIGJlIHJlZHVuZGFudCBhbnl3YXkgLS0gdGhlIHVzZXIgaGFzIG9ubHkgdHdvIHdheXMgb2YgZGlyZWN0bHkgcmVqZWN0aW5nIGFcbiAgIHByb21pc2Ugd2l0aCBbTHd0LkNhbmNlbGVkXSAob3IgYW55IGV4Y2VwdGlvbiwgZm9yIHRoYXQgbWF0dGVyKTpcblxuICAgLSBUaGUgdXNlciBjYW4gY3JlYXRlIGFuIGluaXRpYWwgcHJvbWlzZSwgdGhlbiByZWplY3QgaXQgdGhyb3VnaCBpdHNcbiAgICAgcmVzb2x2ZXIuIFRoZSBzZWFyY2ggaXMgcmVkdW5kYW50IGJlY2F1c2UgaXQgd291bGQgZmluZCBvbmx5IHRoZSBzYW1lXG4gICAgIGluaXRpYWwgcHJvbWlzZSB0byBjYW5jZWwuXG4gICAtIFRoZSB1c2VyIGNhbiBjcmVhdGUgYSB0cml2aWFsIHByb21pc2UgYnkgY2FsbGluZyBbTHd0LmZhaWwgTHd0LkNhbmNlbGVkXS5cbiAgICAgVGhlIHNlYXJjaCBpcyBhZ2FpbiByZWR1bmRhbnQ7IGluIHRoaXMgY2FzZSBpdCB3b3VsZCBmaW5kIG5vdGhpbmcgdG9cbiAgICAgY2FuY2VsLlxuXG4gICBOb3RlIHRoYXQgdGhlcmUgaXMgYSBxdWlyazogb25seSBwcm9taXNlcyBjcmVhdGVkIGJ5IFtMd3QudGFza10gYXJlXG4gICBzdXNjZXB0aWJsZSB0byBiZWluZyBjYW5jZWxlZCBieSBbTHd0LmNhbmNlbF0sIGJ1dCB0aGUgdXNlciBjYW4gbWFudWFsbHlcbiAgIGNhbmNlbCBpbml0aWFsIHByb21pc2VzIGNyZWF0ZWQgYnkgYm90aCBbTHd0LnRhc2tdIGFuZCBbTHd0LndhaXRdLlxuXG4gICBEdWUgdG8gW0x3dC5jYW5jZWxdLCBwcm9taXNlIGNhbmNlbGxhdGlvbiwgYW5kIHRoZXJlZm9yZSByZXNvbHV0aW9uLCBjYW4gYmVcbiAgIGluaXRpYXRlZCBieSB0aGUgdXNlciB3aXRob3V0IGFjY2VzcyB0byBhIHJlc29sdmVyLiBUaGlzIGlzIGltcG9ydGFudCBmb3JcbiAgIHJlYXNvbmluZyBhYm91dCBzdGF0ZSBjaGFuZ2VzIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBMd3QsIGFuZCBpcyByZWZlcmVuY2VkXG4gICBpbiBzb21lIGltcGxlbWVudGF0aW9uIGRldGFpbCBjb21tZW50cy5cblxuXG4gICA2LiBObyBJL09cblxuICAgVGhlIEx3dCBjb3JlIGRlbGliZXJhdGVseSBkb2Vzbid0IGRvIEkvTy4gVGhlIHJlc29sdXRpb24gbG9vcCBzdG9wcyBydW5uaW5nXG4gICBvbmNlIG5vIHByb21pc2VzIGNhbiBiZSByZXNvbHZlZCBpbW1lZGlhdGVseS4gSXQgaGFzIHRvIGJlIHJlc3RhcnRlZCBsYXRlclxuICAgYnkgc29tZSBzdXJyb3VuZGluZyBJL08gbG9vcC4gVGhpcyBJL08gbG9vcCB0eXBpY2FsbHkga2VlcHMgdHJhY2sgb2YgcGVuZGluZ1xuICAgcHJvbWlzZXMgdGhhdCByZXByZXNlbnQgYmxvY2tlZCBvciBpbi1wcm9ncmVzcyBJL087IG90aGVyIHBlbmRpbmcgcHJvbWlzZXNcbiAgIHRoYXQgaW5kaXJlY3RseSBkZXBlbmQgb24gSS9PIGFyZSBub3QgZXhwbGljaXRseSB0cmFja2VkLiBUaGV5IGFyZSByZXRhaW5lZFxuICAgaW4gbWVtb3J5IGJ5IHJlZmVyZW5jZXMgY2FwdHVyZWQgaW5zaWRlIGNhbGxiYWNrcy5cblxuICAgT24gVW5peCBhbmQgV2luZG93cywgYSBzZXBhcmF0ZSB0b3AtbGV2ZWwgbG9vcCwgdHlwaWNhbGx5IFtMd3RfbWFpbi5ydW5dLCBpc1xuICAgbmVjZXNzYXJ5IHRvIHJlcGVhdGVkbHkgY2FsbCBbc2VsZWN0XSwgW2Vwb2xsXSwgb3IgW2tldmVudF0sIGFuZCByZXNvbHZlXG4gICBibG9ja2VkIEkvTyBwcm9taXNlcy5cblxuICAgSW4gSmF2YVNjcmlwdCwgcmVmZXJlbmNlcyB0byBwcm9taXNlcyBhcmUgcmV0YWluZWQgYnkgSmF2YVNjcmlwdCBjb2RlLCB3aGljaFxuICAgaXMsIGluIHR1cm4sIHRyaWdnZXJlZCBieSB0aGUgSlMgZW5naW5lLiBJbiBvdGhlciB3b3JkcywgdGhlIHRvcC1sZXZlbCBsb29wXG4gICBpcyBidXJpZWQgaW5zaWRlIHRoZSBKUyBlbmdpbmUuXG5cbiAgIFRoaXMgc2VwYXJhdGlvbiBvZiB0aGUgTHd0IGNvcmUgZnJvbSB0aGUgdG9wLWxldmVsIEkvTyBsb29wIGtlZXBzIHRoZSBjb3JlXG4gICBwb3J0YWJsZS5cblxuXG4gICA3LiBQcm9taXNlIFwicHJveHlpbmdcIlxuXG4gICBJbiBbTHd0LmJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XSwgdGhlIG91dGVyIFsnYiB0XSBpcyBjcmVhdGVkIGJ5XG4gICBbYmluZF0gZmlyc3QsIGFuZCByZXR1cm5lZCB0byB0aGUgdXNlci4gVGhlIGlubmVyIFsnYiB0XSBpcyBjcmVhdGVkIGJ5IHRoZVxuICAgdXNlciBsYXRlciwgYW5kIHRoZW4gcmV0dXJuZWQgdG8gW2JpbmRdLiBBdCB0aGF0IHBvaW50LCBbYmluZF0gbmVlZHMgdG8gbWFrZVxuICAgdGhlIGlubmVyIGFuZCBvdXRlciBbJ2IgdF1zIGJlaGF2ZSBpZGVudGljYWxseS5cblxuICAgVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgbWFraW5nIG9uZSBvZiB0aGUgcHJvbWlzZXMgcG9pbnQgdG8gdGhlIG90aGVyLiBUaGVcbiAgIGZpcnN0IG9mIHRoZSBwcm9taXNlcyB0aHVzIGJlY29tZXMgYSBcInByb3h5LFwiIGFuZCB0aGUgb3RoZXIgaXMgaXRzXG4gICBcInVuZGVybHlpbmdcIiBwcm9taXNlLlxuXG4gICBBZnRlciB0aGF0LCBhbGwgb3BlcmF0aW9ucyB0aGF0IHdvdWxkIGJlIHBlcmZvcm1lZCBieSBMd3Qgb24gdGhlIHByb3h5IGFyZVxuICAgaW5zdGVhZCBwZXJmb3JtZWQgb24gdGhlIHVuZGVybHlpbmcgcHJvbWlzZS4gVGhpcyBpcyBlbnN1cmVkIGJ5IHRoZSBudW1lcm91c1xuICAgY2FsbHMgdG8gdGhlIGludGVybmFsIGZ1bmN0aW9uIFt1bmRlcmx5aW5nXSBpbiB0aGlzIGZpbGUuXG5cbiAgIEJlY2F1c2Ugb2YgdGhlIHBlcnZhc2l2ZSB1c2Ugb2YgW3VuZGVybHlpbmddLCBwcm94aWVzIGNhbiBiZSBtb3JlIG9yIGxlc3NcbiAgIGlnbm9yZWQgb24gYSBmaXJzdCByZWFkaW5nIHRoZSBjb2RlLiBIb3dldmVyLCBiZWNvbWluZyBhIHByb3h5IGlzIGEga2luZCBvZlxuICAgc3RhdGUgY2hhbmdlLCBhbmQgYW55IHByb21pc2UgdGhhdCBpcyByZXR1cm5lZCBieSBhIGNhbGxiYWNrIHRvIFtiaW5kXSwgb3IgdG9cbiAgIGEgc2ltaWxhciBMd3QgZnVuY3Rpb24sIG1pZ2h0IGJlY29tZSBhIHByb3h5LiBUaGF0IG1lYW5zOiBqdXN0IGFib3V0IGFueVxuICAgcHJvbWlzZSB0aGF0IGlzIGhhbmRlZCB0byB0aGUgdXNlciwgbWlnaHQgYmVjb21lIGEgcHJveHkgcHJvbWlzZSBieSB0aGUgbmV4dFxuICAgdGltZSBMd3Qgc2VlcyBpdC4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIHJlYXNvbmluZyBhYm91dCBwb3NzaWJsZSBzdGF0ZVxuICAgY2hhbmdlcyBpbiBpbXBsZW1lbnRhdGlvbiBvZiBMd3QsIGFuZCBpcyByZWZlcmVuY2VkIGluIHNvbWUgaW1wbGVtZW50YXRpb25cbiAgIGRldGFpbCBjb21tZW50cy5cblxuXG4gICA4LiBTZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2VcblxuICAgTHd0IGhhcyBhIGdsb2JhbCBrZXktdmFsdWUgbWFwLiBUaGUgbWFwIGNhbiBiZSBwcmVzZXJ2ZWQgYWNyb3NzIHNlcXVlbnRpYWxcbiAgIGNvbXBvc2l0aW9uIGZ1bmN0aW9ucywgc28gdGhhdCBpdCBoYXMgdGhlIHNhbWUgc3RhdGUgaW4gdGhlIHVzZXIncyBjYWxsYmFja1xuICAgW2ZdIGFzIGl0IGRpZCBhdCB0aGUgdGltZSB0aGUgdXNlciBjYWxsZWQgW0x3dC5iaW5kIHAgZl0uXG5cbiAgIFRoZSBkZXRhaWxzIGFyZSBwcmV0dHkgc3RyYWlnaHRmb3J3YXJkLCBhbmQgZGlzY3Vzc2VkIGluIG1vZHVsZVxuICAgW1NlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZV0uIFRoZSBtYWluIHRoaW5nIHRvIGJlIGF3YXJlIG9mIGlzIHRoZSBtYW55XG4gICByZWZlcmVuY2VzIHRvIFtjdXJyZW50X3N0b3JhZ2VdIHRocm91Z2hvdXQgTHd0LCB3aGljaCBhcmUgbmVlZGVkIHRvIHByb3Blcmx5XG4gICBzYXZlIGFuZCByZXN0b3JlIHRoZSBtYXBwaW5nLlxuXG5cbiAgIDkuIFR5cGUgc3lzdGVtIGFidXNlXG5cbiAgIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSB0eXBlIHN5c3RlbSBzb21ld2hhdCBleHRlbnNpdmVseS4gR2VudGxlXG4gICBpbnRyb2R1Y3Rpb25zIGNhbiBiZSBmb3VuZCBoZXJlOlxuXG4gICAgIGh0dHBzOi8vZGlzY3Vzcy5vY2FtbC5vcmcvdC8xNjEvN1xuICAgICBodHRwczovL2Rpc2N1c3Mub2NhbWwub3JnL3QvMTYxLzE2XG5cbiAgIEEgc2hvcnQgc3VtbWFyeSBmb2xsb3dzLlxuXG4gICBUaGUgcHJvbWlzZSBzdGF0ZSBpcywgaW50ZXJuYWxseSwgYSBHQURUIHdoaWNoIGVuY29kZXMgdGhlIHN0YXRlIGluIGl0cyB0eXBlXG4gICBwYXJhbWV0ZXJzLiBUaHVzLCBpZiB5b3UgZG8gW2xldCBwID0gdW5kZXJseWluZyBwXSwgdGhlIHNoYWRvd2luZyByZWZlcmVuY2VcbiAgIFtwXSBpcyBzdGF0aWNhbGx5IGtub3duICpub3QqIHRvIGJlIGEgcHJveHksIGFuZCB0aGUgY29tcGlsZXIga25vd3MgdGhhdCB0aGVcbiAgIGNvcnJlc3BvbmRpbmcgbWF0Y2ggY2FzZSBbUHJveHkgX10gaXMgaW1wb3NzaWJsZS5cblxuICAgVGhlIGV4dGVybmFsIHByb21pc2UgdHlwZSwgWydhIHRdLCBhbmQgdGhlIGV4dGVybmFsIHJlc29sdmVyIHR5cGUsIFsnYSB1XSxcbiAgIGFyZSBub3QgR0FEVHMuIEZ1cnRoZXJtb3JlLCB0aGV5IGFyZSwgcmVzcGVjdGl2ZWx5LCBjb3ZhcmlhbnQgYW5kXG4gICBjb250cmF2YXJpYW50IGluIFsnYV0sIHdoaWxlIHRoZSBpbnRlcm5hbCBwcm9taXNlIHR5cGUgaXMgaW52YXJpYW50IGluIFsnYV0uXG4gICBGb3IgdGhlc2UgcmVhc29ucywgdGhlcmUgYXJlIG5hc3R5IGNhc3RzIGJldHdlZW4gWydhIHRdLCBbJ2EgdV0sIGFuZCB0aGVcbiAgIGludGVybmFsIHByb21pc2UgdHlwZS4gVGhlIGltcGxlbWVudGF0aW9uIGlzLCBvZiBjb3Vyc2UsIHdyaXR0ZW4gaW4gdGVybXMgb2ZcbiAgIHRoZSBpbnRlcm5hbCB0eXBlLlxuXG4gICBDYXN0aW5nIGZyb20gYW4gWydhIHRdIHRvIGFuIGludGVybmFsIHByb21pc2UgcHJvZHVjZXMgYSByZWZlcmVuY2UgZm9yXG4gICB3aGljaCB0aGUgc3RhdGUgaXMgXCJ1bmtub3duXCI6IHRoaXMgaXMgc2ltdWxhdGVkIHdpdGggYSBoZWxwZXIgR0FEVCwgd2hpY2hcbiAgIGVuY29kZXMgZXhpc3RlbnRpYWwgdHlwZXMuIFRoZXJlIGFyZSBzZXZlcmFsIHNpbWlsYXIgY2FzdHMsIHdoaWNoIGFyZSB1c2VkXG4gICB0byBkb2N1bWVudCBwb3NzaWJsZSBzdGF0ZSBjaGFuZ2VzIGJldHdlZW4gdGhlIHRpbWUgYSBwcm9taXNlIGlzIGNyZWF0ZWQsXG4gICBhbmQgdGhlIGxhdGVyIHRpbWUgaXQgaXMgdXNlZCBpbiBhIGNhbGxiYWNrLiBZb3UgY2FuIHNlZSB0aGVzZSBjYXN0cyBpblxuICAgYWN0aW9uIGluIFtMd3QuYmluZF0uIFRoZSBjYXN0IHN5bnRheCBpcyBwcmV0dHkgbGlnaHQsIGFuZCwgYmVzaWRlcyBiZWluZ1xuICAgY29tbWVudGVkIGluIFtiaW5kXSwgYWxsIHN1Y2ggY2FzdHMgYXJlIGRvY3VtZW50ZWQgaW4gbW9kdWxlcyBbUHVibGljX3R5cGVzXVxuICAgYW5kIFtCYXNpY19oZWxwZXJzXS5cblxuXG4gICBJZiB5b3UndmUgbWFkZSBpdCB0aGlzIGZhciwgeW91IGFyZSBhbiBMd3QgZXhwZXJ0ISBSZWpvaWNlISAqKVxuXG5cblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxuKCogU29tZSBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UgdHlwZXNcblxuICAgU2VxdWVuY2UtYXNzb2NpYXRlZCBzdG9yYWdlIGlzIGRlZmluZWQgYW5kIGRvY3VtZW50ZWQgbGF0ZXIsIGluIG1vZHVsZVxuICAgW1NlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZV0uIEhvd2V2ZXIsIHRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIG1lbnRpb25lZCBpblxuICAgdGhlIGRlZmluaXRpb24gb2YgW3Byb21pc2VdLCBzbyB0aGV5IG11c3QgYmUgZGVmaW5lZCBoZXJlIGZpcnN0LiAqKVxubW9kdWxlIFN0b3JhZ2VfbWFwID1cbiAgTWFwLk1ha2VcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBpbnRcbiAgICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgIGVuZClcbnR5cGUgc3RvcmFnZSA9ICh1bml0IC0+IHVuaXQpIFN0b3JhZ2VfbWFwLnRcblxuXG5cbm1vZHVsZSBNYWluX2ludGVybmFsX3R5cGVzID1cbnN0cnVjdFxuICAoKiBQaGFudG9tIHR5cGVzIGZvciB1c2Ugd2l0aCB0eXBlcyBbcHJvbWlzZV0gYW5kIFtzdGF0ZV0uIFRoZXNlIGFyZSBuZXZlclxuICAgICBjb25zdHJ1Y3RlZDsgdGhlIHB1cnBvc2Ugb2YgdGhlIGNvbnN0cnVjdG9ycyBpcyB0byBwcm92ZSB0byB0aGUgdHlwZVxuICAgICBjaGVja2VyIHRoYXQgdGhlc2UgdHlwZXMgYXJlIGRpc3RpbmN0IGZyb20gZWFjaCBvdGhlci4gV2FybmluZyAzNywgXCJ1bnVzZWRcbiAgICAgY29uc3RydWN0b3IsXCIgdGhlcmVmb3JlIGhhcyB0byBiZSB0ZW1wb3JhcmlseSBzdXBwcmVzc2VkLiAqKVxuXG4gIFtAQEBvY2FtbC53YXJuaW5nIFwiLTM3XCJdXG5cbiAgdHlwZSB1bmRlcmx5aW5nID0gcHJpdmF0ZSBVbmRlcmx5aW5nX2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG4gIHR5cGUgcHJveHkgPSBwcml2YXRlIFByb3h5X2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG5cbiAgdHlwZSByZXNvbHZlZCA9IHByaXZhdGUgUmVzb2x2ZWRfYW5kX3RoaXNfY29uc3RydWN0b3JfaXNfbm90X3VzZWRcbiAgdHlwZSBwZW5kaW5nID0gcHJpdmF0ZSBQZW5kaW5nX2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG5cbiAgW0BAQG9jYW1sLndhcm5pbmcgXCIrMzdcIl1cblxuXG5cbiAgKCogUHJvbWlzZXMgcHJvcGVyLiAqKVxuXG4gIHR5cGUgKCdhLCAndSwgJ2MpIHByb21pc2UgPSB7XG4gICAgbXV0YWJsZSBzdGF0ZSA6ICgnYSwgJ3UsICdjKSBzdGF0ZTtcbiAgfVxuXG4gIGFuZCAoXywgXywgXykgc3RhdGUgPVxuICAgIHwgRnVsZmlsbGVkIDogJ2EgICAgICAgICAgICAgICAgICAtPiAoJ2EsIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZVxuICAgIHwgUmVqZWN0ZWQgIDogZXhuICAgICAgICAgICAgICAgICAtPiAoIF8sIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZVxuICAgIHwgUGVuZGluZyAgIDogJ2EgY2FsbGJhY2tzICAgICAgICAtPiAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpICBzdGF0ZVxuICAgIHwgUHJveHkgICAgIDogKCdhLCBfLCAnYykgcHJvbWlzZSAtPiAoJ2EsIHByb3h5LCAgICAgICdjKSAgICAgICBzdGF0ZVxuXG4gICgqIE5vdGU6XG5cbiAgICAgQSBwcm9taXNlIHdob3NlIHN0YXRlIGlzIFtQcm94eSBfXSBpcyBhIFwicHJveHlcIiBwcm9taXNlLiBBIHByb21pc2Ugd2hvc2VcbiAgICAgc3RhdGUgaXMgKm5vdCogW1Byb3h5IF9dIGlzIGFuIFwidW5kZXJseWluZ1wiIHByb21pc2UuXG5cbiAgICAgVGhlIFwidW5kZXJseWluZyBwcm9taXNlIG9mIFtwXVwiIGlzOlxuXG4gICAgIC0gW3BdLCBpZiBbcF0gaXMgaXRzZWxmIHVuZGVybHlpbmcuXG4gICAgIC0gT3RoZXJ3aXNlLCBbcF0gaXMgYSBwcm94eSBhbmQgaGFzIHN0YXRlIFtQcm94eSBwJ10uIFRoZSB1bmRlcmx5aW5nXG4gICAgICAgcHJvbWlzZSBvZiBbcF0gaXMgdGhlIHVuZGVybHlpbmcgcHJvbWlzZSBvZiBbcCddLlxuXG4gICAgIEluIG90aGVyIHdvcmRzLCB0byBmaW5kIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgYSBwcm94eSwgTHd0IGZvbGxvd3MgdGhlXG4gICAgIFtQcm94eSBfXSBsaW5rcyB0byB0aGUgZW5kLiAqKVxuXG4gICgqIE5vdGU6XG5cbiAgICAgV2hlbiBhIHByb21pc2UgaXMgcmVzb2x2ZWQsIG9yIGJlY29tZXMgYSBwcm94eSwgaXRzIHN0YXRlIGZpZWxkIGlzXG4gICAgIG11dGF0ZWQuIFRoaXMgaW52YWxpZGF0ZXMgdGhlIHR5cGUgaW52YXJpYW50cyBvbiB0aGUgcHJvbWlzZS4gU2VlIGludGVybmFsXG4gICAgIGZ1bmN0aW9uIFtzZXRfcHJvbWlzZV9zdGF0ZV0gZm9yIGRldGFpbHMgYWJvdXQgdGhhdC5cblxuICAgICBXaGVuIGFuIEx3dCBmdW5jdGlvbiBoYXMgYSByZWZlcmVuY2UgdG8gYSBwcm9taXNlLCBhbmQgYWxzbyByZWdpc3RlcnMgYVxuICAgICBjYWxsYmFjayB0aGF0IGhhcyBhIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBwcm9taXNlLCB0aGUgaW52YXJpYW50cyBvbiB0aGVcbiAgICAgcmVmZXJlbmNlIG1heSBiZWNvbWUgaW52YWxpZCBieSB0aGUgdGltZSB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkLiBBbGwgc3VjaFxuICAgICBjYWxsYmFja3MgaGF2ZSBjb21tZW50cyBleHBsYWluaW5nIHdoYXQgdGhlIHZhbGlkIGludmFyaWFudHMgYXJlIGF0IHRoYXRcbiAgICAgcG9pbnQsIGFuZC9vciBjYXN0cyB0byAoMSkgZ2V0IHRoZSBjb3JyZWN0IHR5cGluZyBhbmQgKDIpIGRvY3VtZW50IHRoZVxuICAgICBwb3RlbnRpYWwgc3RhdGUgY2hhbmdlIGZvciByZWFkZXJzIG9mIHRoZSBjb2RlLiAqKVxuXG5cblxuICAoKiBDYWxsYmFjayBpbmZvcm1hdGlvbiBmb3IgcGVuZGluZyBwcm9taXNlcy4gKilcblxuICBhbmQgJ2EgY2FsbGJhY2tzID0ge1xuICAgIG11dGFibGUgcmVndWxhcl9jYWxsYmFja3MgOiAnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3Q7XG4gICAgbXV0YWJsZSBjYW5jZWxfY2FsbGJhY2tzICA6ICdhIGNhbmNlbF9jYWxsYmFja19saXN0O1xuICAgIG11dGFibGUgaG93X3RvX2NhbmNlbCAgICAgOiBob3dfdG9fY2FuY2VsO1xuICAgIG11dGFibGUgY2xlYW51cHNfZGVmZXJyZWQgOiBpbnQ7XG4gIH1cblxuICBhbmQgJ2EgcmVndWxhcl9jYWxsYmFjayA9ICdhIHJlc29sdmVkX3N0YXRlIC0+IHVuaXRcblxuICBhbmQgY2FuY2VsX2NhbGxiYWNrID0gdW5pdCAtPiB1bml0XG5cbiAgYW5kICdhIHJlc29sdmVkX3N0YXRlID0gKCdhLCB1bmRlcmx5aW5nLCByZXNvbHZlZCkgc3RhdGVcblxuICBhbmQgaG93X3RvX2NhbmNlbCA9XG4gICAgfCBOb3RfY2FuY2VsYWJsZSAgICAgICAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvd190b19jYW5jZWxcbiAgICB8IENhbmNlbF90aGlzX3Byb21pc2UgICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgaG93X3RvX2NhbmNlbFxuICAgIHwgUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgICAgIDogKF8sIF8sIF8pIHByb21pc2UgICAgICAtPiBob3dfdG9fY2FuY2VsXG4gICAgfCBQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgOiAoXywgXywgXykgcHJvbWlzZSBsaXN0IC0+IGhvd190b19jYW5jZWxcblxuICBhbmQgJ2EgcmVndWxhcl9jYWxsYmFja19saXN0ID1cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eVxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCBvZlxuICAgICAgJ2EgcmVndWxhcl9jYWxsYmFja19saXN0ICogJ2EgcmVndWxhcl9jYWxsYmFja19saXN0XG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIG9mXG4gICAgICAnYSByZWd1bGFyX2NhbGxiYWNrXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2sgb2ZcbiAgICAgICdhIHJlZ3VsYXJfY2FsbGJhY2sgb3B0aW9uIHJlZlxuXG4gIGFuZCBfIGNhbmNlbF9jYWxsYmFja19saXN0ID1cbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5IDpcbiAgICAgIF8gY2FuY2VsX2NhbGxiYWNrX2xpc3RcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCA6XG4gICAgICAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdCAqICdhIGNhbmNlbF9jYWxsYmFja19saXN0IC0+XG4gICAgICAgICdhIGNhbmNlbF9jYWxsYmFja19saXN0XG4gICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jYWxsYmFjayA6XG4gICAgICBzdG9yYWdlICogY2FuY2VsX2NhbGxiYWNrIC0+XG4gICAgICAgIF8gY2FuY2VsX2NhbGxiYWNrX2xpc3RcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIDpcbiAgICAgICgnYSwgXywgXykgcHJvbWlzZSBMd3Rfc2VxdWVuY2Uubm9kZSAtPlxuICAgICAgICAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdFxuXG4gICgqIE5vdGVzOlxuXG4gICAgIFRoZXNlIHR5cGUgZGVmaW5pdGlvbnMgYXJlIGd1aWx0eSBvZiBwZXJmb3JtaW5nIHNldmVyYWwgb3B0aW1pemF0aW9ucyxcbiAgICAgd2l0aG91dCB3aGljaCB0aGV5IHdvdWxkIGJlIG11Y2ggZWFzaWVyIHRvIHVuZGVyc3RhbmQuXG5cbiAgICAgLSBUaGUgdHlwZSBwYXJhbWV0ZXJzIG9mIFsnYSByZXNvbHZlZF9zdGF0ZV0gZ3VhcmFudGVlIHRoYXQgaXQgaXMgZWl0aGVyXG4gICAgICAgW0Z1bGZpbGxlZCBfXSBvciBbUmVqZWN0ZWQgX10uIFNvLCBpdCBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgWygnYSwgZXhuKSBTdGRsaWIucmVzdWx0XSwgYW5kLCBpbmRlZWQsIHNob3VsZCBoYXZlIGFuIGlkZW50aWNhbFxuICAgICAgIG1lbW9yeSByZXByZXNlbnRhdGlvbi5cblxuICAgICAtIEFzIHBlciB0aGUgT3ZlcnZpZXcsIHRoZXJlIGFyZSByZWd1bGFyIGNhbGxiYWNrcyBhbmQgY2FuY2VsIGNhbGxiYWNrcy5cbiAgICAgICBDYW5jZWwgY2FsbGJhY2tzIGFyZSBjYWxsZWQgb25seSBvbiBjYW5jZWxsYXRpb24sIGFuZCwgdGhlbiwgYmVmb3JlIGFueVxuICAgICAgIHJlZ3VsYXIgY2FsbGJhY2tzIGFyZSBjYWxsZWQuXG5cbiAgICAgICBEZXNwaXRlIHRoZSBkaWZmZXJlbnQgdHlwZXMgZm9yIHRoZSB0d28ga2luZHMgb2YgY2FsbGJhY2tzLCB0aGV5IGFyZVxuICAgICAgIG90aGVyd2lzZSB0aGUgc2FtZS4gQ2FuY2VsIGNhbGxiYWNrcyBqdXN0IGRvbid0IG5lZWQgYSByZXN1bHQgc3RhdGVcbiAgICAgICBhcmd1bWVudCwgYmVjYXVzZSBpdCBpcyBrbm93biB0byBiZSBbUmVqZWN0ZWQgQ2FuY2VsZWRdLlxuXG4gICAgIC0gUmVndWxhciBjYWxsYmFja3MgYXJlIG5vdCBhbGxvd2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMuIEFsbCByZWd1bGFyXG4gICAgICAgY2FsbGJhY2tzIGFyZSBjcmVhdGVkIGluIHRoaXMgZmlsZSwgc28gdGhpcyBjYW4gYmUgY2hlY2tlZC5cblxuICAgICAgIENhbmNlbCBjYWxsYmFja3MgY2FuIHJhaXNlIGV4Y2VwdGlvbnMsIGJ1dCBpZiB0aGV5IGRvIHNvLCB0aGUgZXhjZXB0aW9uc1xuICAgICAgIGFyZSBwYXNzZWQgdG8gW2FzeW5jX2V4Y2VwdGlvbl9ob29rXS5cblxuICAgICAtIFtob3dfdG9fY2FuY2VsXSBpbXBsZW1lbnRzIHRoZSBkZXBlbmRlbmN5IGdyYXBoIG1lbnRpb25lZCBpbiB0aGVcbiAgICAgICBPdmVydmlldy4gSXQgaXMgdHJhdmVyc2VkIGJhY2t3YXJkcyBkdXJpbmcgW0x3dC5jYW5jZWxdLiBJdCBpcyBhIEdBRFRcbiAgICAgICBiZWNhdXNlIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGFjdHVhbCB0eXBlcyBvZiB0aGUgcHJvbWlzZSByZWZlcmVuY2VzXG4gICAgICAgc3RvcmVkLCBvciB0aGVpciBpbnZhcmlhbnRzLiBUaGUgY29uc3RydWN0b3JzIGNvcnJlc3BvbmQgdG8gcGVuZGluZ1xuICAgICAgIHByb21pc2Uga2luZHMgYXMgZm9sbG93czpcbiAgICAgICAgIC0gW05vdF9jYW5jZWxhYmxlXTogaW5pdGlhbCwgW0x3dC53YWl0XS5cbiAgICAgICAgIC0gW0NhbmNlbF90aGlzX3Byb21pc2VdOiBpbml0aWFsLCBbTHd0LnRhc2tdLlxuICAgICAgICAgLSBbUHJvcGFnYXRlX2NhbmNlbF90b19vbmVdOiBzZXF1ZW50aWFsIGNvbXBvc2l0aW9uLCBlLmcuIFtMd3QuYmluZF0uXG4gICAgICAgICAtIFtQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWxdOiBjb25jdXJyZW50IGNvbXBvc2l0aW9uLCBlLmcuXG4gICAgICAgICAgIFtMd3Quam9pbl0uXG5cbiAgICAgLSBUaGUgdHdvIGNhbGxiYWNrIGxpc3QgdHlwZXMgYXJlIG9yZGluYXJ5IGFwcGVuZC1mcmllbmRseSBsaXN0cywgd2l0aCB0d29cbiAgICAgICBvcHRpbWl6YXRpb25zIGlubGluZWQ6XG5cbiAgICAgICAtIFsnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3RdIGFwcGFyZW50bHkgaGFzIHR3byBcImtpbmRzXCIgb2YgcmVndWxhclxuICAgICAgICAgY2FsbGJhY2tzLCBpbXBsaWNpdGx5IHJlbW92ZWQgYW5kIGV4cGxpY2l0bHkgcmVtb3ZhYmxlLiBBbGwgY2FsbGJhY2tzXG4gICAgICAgICBhcmUgcmVtb3ZhYmxlLiBJdCdzIGp1c3QgdGhhdCwgZm9yIHNvbWUgY2FsbGJhY2tzLCB0aGV5IHdpbGwgb25seSBiZVxuICAgICAgICAgcmVtb3ZlZCBhdCB0aGUgc2FtZSB0aW1lIHRoYXQgdGhlIHByb21pc2UgdGhleSBhcmUgYXR0YWNoZWQgdG8gYmVjb21lc1xuICAgICAgICAgcmVzb2x2ZWQuIFdoZW4gdGhhdCBoYXBwZW5zLCB0aGUgZW50aXJlIHN0YXRlIG9mIHRoYXQgcHJvbWlzZSBjaGFuZ2VzXG4gICAgICAgICB0byBbRnVsZmlsbGVkIF9dIG9yIFtSZWplY3RlZCBfXSwgYW5kIHRoZSByZWZlcmVuY2UgdG8gdGhlIHdob2xlXG4gICAgICAgICBjYWxsYmFjayBsaXN0IGlzIHNpbXBseSBsb3N0LiBUaGlzIFwicmVtb3Zlc1wiIHRoZSBjYWxsYmFjay4gRm9yIHRoZXNlXG4gICAgICAgICBjYWxsYmFja3MsIFsnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3RdIGF0dGVtcHRzIHRvIHRyaW0gYW4gb3B0aW9uIGFuZCBhXG4gICAgICAgICByZWZlcmVuY2UgY2VsbCB3aXRoIHRoZVxuICAgICAgICAgW1JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2tdIGNvbnN0cnVjdG9yLlxuXG4gICAgICAgLSBbJ2EgY2FuY2VsX2NhbGxiYWNrX2xpc3RdIGhhc1xuICAgICAgICAgW0NhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGVdLCB3aGljaCBpcyB0aGUgc2FtZSBhc1xuICAgICAgICAgW0NhbmNlbF9jYWxsYmFja19saXN0X2NhbGxiYWNrIChfLCAoZnVuIF8gLT5cbiAgICAgICAgICAgTHd0X3NlcXVlbmNlLnJlbW92ZSBub2RlKSldLlxuICAgICAgICAgVGhpcyB3YXMgcHJvYmFibHkgZG9uZSB0byBhdm9pZCBhIGNsb3N1cmUgYWxsb2NhdGlvbi5cblxuICAgICAtIFRoZSBbY2xlYW51cHNfZGVmZXJyZWRdIGZpZWxkIGlzIGV4cGxhaW5lZCBpbiBtb2R1bGVcbiAgICAgICBbUGVuZGluZ19jYWxsYmFja3NdLiAqKVxuZW5kXG5vcGVuIE1haW5faW50ZXJuYWxfdHlwZXNcblxuXG5cbm1vZHVsZSBQdWJsaWNfdHlwZXMgPVxuc3RydWN0XG4gIHR5cGUgKydhIHRcbiAgdHlwZSAtJ2EgdVxuXG4gIGxldCB0b19wdWJsaWNfcHJvbWlzZSA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAnYSB0ID0gT2JqLm1hZ2ljXG4gIGxldCB0b19wdWJsaWNfcmVzb2x2ZXIgOiAoJ2EsIF8sIF8pIHByb21pc2UgLT4gJ2EgdSA9IE9iai5tYWdpY1xuXG4gIHR5cGUgXyBwYWNrZWRfcHJvbWlzZSA9XG4gICAgfCBJbnRlcm5hbCA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAnYSBwYWNrZWRfcHJvbWlzZVxuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgbGV0IHRvX2ludGVybmFsX3Byb21pc2UgKHAgOiAnYSB0KSA6ICdhIHBhY2tlZF9wcm9taXNlID1cbiAgICBJbnRlcm5hbCAoT2JqLm1hZ2ljIHApXG4gIGxldCB0b19pbnRlcm5hbF9yZXNvbHZlciAociA6ICdhIHUpIDogJ2EgcGFja2VkX3Byb21pc2UgPVxuICAgIEludGVybmFsIChPYmoubWFnaWMgcilcblxuICAoKiBNb3N0IGZ1bmN0aW9ucyB0aGF0IHRha2UgYSBwdWJsaWMgcHJvbWlzZSAoWydhIHRdKSBjb252ZXJ0IGl0IHRvIGFuXG4gICAgIGludGVybmFsIHByb21pc2UgYXMgZm9sbG93czpcblxuICAgICAgICgqIHAgOiAnYSB0ICopXG5cbiAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgICAgKCogcCA6ICgnYSwgdSwgYykgcHJvbWlzZSwgd2hlcmUgdSBhbmQgYyBhcmUgZnJlc2ggdHlwZXMsIGkuZS4gdGhlXG4gICAgICAgICAgaW52YXJpYW50cyBvbiBwIGFyZSB1bmtub3duLiAqKVxuXG4gICAgIFRoaXMgY2FzdCBpcyBhIG5vLW9wIGNhc3QuIEl0IG9ubHkgcHJvZHVjZXMgYSByZWZlcmVuY2Ugd2l0aCBhIGRpZmZlcmVudFxuICAgICB0eXBlLiBUaGUgaW50cm9kdWN0aW9uIGFuZCBpbW1lZGlhdGUgZWxpbWluYXRpb24gb2YgW0ludGVybmFsIF9dIHNlZW1zIHRvXG4gICAgIGJlIG9wdGltaXplZCBhd2F5IGV2ZW4gb24gb2xkZXIgdmVyc2lvbnMgb2YgT0NhbWwgdGhhdCBkb24ndCBoYXZlIEZsYW1iZGFcbiAgICAgYW5kIGRvbid0IHN1cHBvcnQgW1tAQG9jYW1sLnVuYm94ZWRdXS4gKilcblxuICAoKiBUaGlzIGNvdWxkIHByb2JhYmx5IHNhdmUgYW4gYWxsb2NhdGlvbiBieSB1c2luZyBbT2JqLm1hZ2ljXS4gKilcbiAgbGV0IHN0YXRlX29mX3Jlc3VsdCA9IGZ1bmN0aW9uXG4gICAgfCBPayB4IC0+IEZ1bGZpbGxlZCB4XG4gICAgfCBFcnJvciBleG4gLT4gUmVqZWN0ZWQgZXhuXG5lbmRcbmluY2x1ZGUgUHVibGljX3R5cGVzXG5cblxuXG5tb2R1bGUgQmFzaWNfaGVscGVycyA6XG5zaWdcbiAgdmFsIGlkZW50aWNhbCA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAoJ2EsIF8sIF8pIHByb21pc2UgLT4gYm9vbFxuICB2YWwgdW5kZXJseWluZyA6ICgnYSwgJ3UsICdjKSBwcm9taXNlIC0+ICgnYSwgdW5kZXJseWluZywgJ2MpIHByb21pc2VcblxuICB0eXBlICgnYSwgJ3UsICdjKSBzdGF0ZV9jaGFuZ2VkID1cbiAgICB8IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgb2YgKCdhLCAndSwgJ2MpIHByb21pc2VcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuICB2YWwgc2V0X3Byb21pc2Vfc3RhdGUgOlxuICAgICgnYSwgXywgXykgcHJvbWlzZSAtPiAoJ2EsICd1LCAnYykgc3RhdGUgLT4gKCdhLCAndSwgJ2MpIHN0YXRlX2NoYW5nZWRcblxuICB0eXBlICdhIG1heV9ub3dfYmVfcHJveHkgPVxuICAgIHwgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IDpcbiAgICAgICgnYSwgXywgcGVuZGluZykgcHJvbWlzZSAtPiAnYSBtYXlfbm93X2JlX3Byb3h5XG4gICAgW0BAb2NhbWwudW5ib3hlZF1cbiAgdmFsIG1heV9ub3dfYmVfcHJveHkgOlxuICAgICgnYSwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZSAtPiAnYSBtYXlfbm93X2JlX3Byb3h5XG5lbmQgPVxuc3RydWN0XG4gICgqIENoZWNrcyBwaHlzaWNhbCBlcXVhbGl0eSAoWz09XSkgb2YgdHdvIGludGVybmFsIHByb21pc2VzLiBVbmxpa2UgWz09XSwgZG9lc1xuICAgICBub3QgZm9yY2UgdW5pZmljYXRpb24gb2YgdGhlaXIgaW52YXJpYW50cy4gKilcbiAgbGV0IGlkZW50aWNhbCBwMSBwMiA9XG4gICAgKHRvX3B1YmxpY19wcm9taXNlIHAxKSA9PSAodG9fcHVibGljX3Byb21pc2UgcDIpXG5cbiAgKCogW3VuZGVybHlpbmcgcF0gZXZhbHVhdGVzIHRvIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgW3BdLlxuXG4gICAgIElmIG11bHRpcGxlIFtQcm94eSBfXSBsaW5rcyBhcmUgdHJhdmVyc2VkLCBbdW5kZXJseWluZ10gdXBkYXRlcyBhbGwgdGhlXG4gICAgIHByb3hpZXMgdG8gcG9pbnQgaW1tZWRpYXRlbHkgdG8gdGhlaXIgZmluYWwgdW5kZXJseWluZyBwcm9taXNlLiAqKVxuICBsZXQgcmVjIHVuZGVybHlpbmdcbiAgICAgIDogdHlwZSB1IGMuICgnYSwgdSwgYykgcHJvbWlzZSAtPiAoJ2EsIHVuZGVybHlpbmcsIGMpIHByb21pc2UgPVxuICAgIGZ1biBwIC0+XG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+IChwIDogKF8sIHVuZGVybHlpbmcsIF8pIHByb21pc2UpXG4gICAgfCBSZWplY3RlZCBfIC0+IHBcbiAgICB8IFBlbmRpbmcgXyAtPiBwXG4gICAgfCBQcm94eSBwJyAtPlxuICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcgaW5cbiAgICAgIGlmIG5vdCAoaWRlbnRpY2FsIHAnJyBwJykgdGhlblxuICAgICAgICBwLnN0YXRlIDwtIFByb3h5IHAnJztcbiAgICAgIHAnJ1xuXG5cblxuICB0eXBlICgnYSwgJ3UsICdjKSBzdGF0ZV9jaGFuZ2VkID1cbiAgICB8IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgb2YgKCdhLCAndSwgJ2MpIHByb21pc2VcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gIGxldCBzZXRfcHJvbWlzZV9zdGF0ZSBwIHN0YXRlID1cbiAgICBsZXQgcCA6IChfLCBfLCBfKSBwcm9taXNlID0gT2JqLm1hZ2ljIHAgaW5cbiAgICBwLnN0YXRlIDwtIHN0YXRlO1xuICAgIFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcFxuXG4gICgqIFtzZXRfcHJvbWlzZV9zdGF0ZSBwIHN0YXRlXSBtdXRhdGVzIHRoZSBzdGF0ZSBvZiBbcF0sIGFuZCBldmFsdWF0ZXMgdG8gYVxuICAgICAod3JhcHBlZCkgcmVmZXJlbmNlIHRvIFtwXSB3aXRoIHRoZSBzYW1lIGludmFyaWFudHMgYXMgb24gW3N0YXRlXS4gVGhlXG4gICAgIG9yaWdpbmFsIHJlZmVyZW5jZSBbcF0gc2hvdWxkIGJlIHNoYWRvd2VkIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uOlxuXG4gICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9IHNldF9wcm9taXNlX3N0YXRlIHAgKEZ1bGZpbGxlZCA0MikgaW4gLi4uXG5cbiAgICAgVGhpcyBpcyBhIGtpbmQgb2YgY2hlYXAgaW1pdGF0aW9uIG9mIGxpbmVhciB0eXBpbmcsIHdoaWNoIGlzIGdvb2QgZW5vdWdoXG4gICAgIGZvciB0aGUgbmVlZHMgb2YgW2x3dC5tbF0uXG5cbiAgICAgSW50ZXJuYWwgZnVuY3Rpb25zIHRoYXQgdHJhbnNpdGl2ZWx5IGNhbGwgW3NldF9wcm9taXNlX3N0YXRlXSBsaWtld2lzZVxuICAgICByZXR1cm4gdGhlIG5ldyByZWZlcmVuY2UuIFRoaXMgZW5kcyBhdCBzb21lIHRvcC1sZXZlbCBmdW5jdGlvbiwgdHlwaWNhbGx5XG4gICAgIGVpdGhlciBhIGNhbGxiYWNrIG9yIGEgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuIFRoZXJlLCB0aGUgbmV3IHJlZmVyZW5jZVxuICAgICBpcyBzdGlsbCBib3VuZCwgYnV0IGlzIHRoZW4gZXhwbGljaXRseSBpZ25vcmVkLlxuXG4gICAgIFRoZSBzdGF0ZSBvZiBhIHByb21pc2UgaXMgbmV2ZXIgdXBkYXRlZCBkaXJlY3RseSBvdXRzaWRlIHRoaXMgbW9kdWxlXG4gICAgIFtCYXNpY19oZWxwZXJzXS4gQWxsIHVwZGF0ZXMgZWxzZXdoZXJlIGFyZSBkb25lIHRocm91Z2hcbiAgICAgW3NldF9wcm9taXNlX3N0YXRlXS5cblxuICAgICBUbyBhdm9pZCBwcm9ibGVtcyB3aXRoIHR5cGUtbGV2ZWwgaW52YXJpYW50cyBub3QgbWF0Y2hpbmcgcmVhbGl0eSwgZGF0YVxuICAgICBzdHJ1Y3R1cmVzIGRvIG5vdCBzdG9yZSBwcm9taXNlcyB3aXRoIGNvbmNyZXRlIGludmFyaWFudHMgLS0gZXhjZXB0XG4gICAgIHJlc29sdmVkIHByb21pc2VzLCB3aGljaCBhcmUgaW1tdXRhYmxlLiBJbmRlZWQsIGlmIG9uZSBsb29rcyBhdFxuICAgICBkZWZpbml0aW9ucyBvZiBkYXRhIHN0cnVjdHVyZXMgdGhhdCBjYW4gc3RvcmUgcGVuZGluZyBwcm9taXNlcywgZS5nLiB0aGVcbiAgICAgW2hvd190b19jYW5jZWxdIGdyYXBoLCB0aGUgaW52YXJpYW50cyBhcmUgZXhpc3RlbnRpYWxseSBxdWFudGlmaWVkLlxuXG4gICAgIE5vdGU6IGl0J3MgcG9zc2libGUgdG8gc3RhdGljYWxseSBkaXNhbGxvdyB0aGUgc2V0dGluZyBvZiB0aGUgW3N0YXRlXSBmaWVsZFxuICAgICBieSBtYWtpbmcgdHlwZSBbcHJvbWlzZV0gcHJpdmF0ZS4gSG93ZXZlciwgdGhhdCBzZWVtcyB0byByZXF1aXJlIHdyaXRpbmcgYVxuICAgICBzaWduYXR1cmUgdGhhdCBpcyBhIG5lYXItZHVwbGljYXRlIG9mIFtNYWluX2ludGVybmFsX3R5cGVzXSwgb3Igc29tZSBhYnVzZVxuICAgICBvZiBmdW5jdG9ycy4gKilcblxuXG5cbiAgdHlwZSAnYSBtYXlfbm93X2JlX3Byb3h5ID1cbiAgICB8IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSA6XG4gICAgICAoJ2EsIF8sIHBlbmRpbmcpIHByb21pc2UgLT4gJ2EgbWF5X25vd19iZV9wcm94eVxuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgbGV0IG1heV9ub3dfYmVfcHJveHkgcCA9IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwXG5cbiAgKCogTWFueSBmdW5jdGlvbnMsIGZvciBleGFtcGxlIFtMd3QuYmluZF0gYW5kIFtMd3Quam9pbl0sIGNyZWF0ZSBhIGZyZXNoXG4gICAgIHBlbmRpbmcgcHJvbWlzZSBbcF0gYW5kIHJldHVybiBpdCB0byB0aGUgdXNlci5cblxuICAgICBUaGV5IGRvIG5vdCByZXR1cm4gYSBjb3JyZXNwb25kaW5nIHJlc29sdmVyLiBUaGF0IG1lYW5zIHRoYXQgb25seSB0aGVcbiAgICAgZnVuY3Rpb24gaXRzZWxmICh0eXBpY2FsbHksIGEgY2FsbGJhY2sgcmVnaXN0ZXJlZCBieSBpdCkgY2FuIHJlc29sdmUgW3BdLlxuICAgICBUaGUgb25seSB0aGluZyB0aGUgdXNlciBjYW4gZG8gZGlyZWN0bHkgaXMgdHJ5IHRvIGNhbmNlbCBbcF0sIGJ1dCwgc2luY2VcbiAgICAgW3BdIGlzIG5vdCBhbiBpbml0aWFsIHByb21pc2UsIHRoZSBjYW5jZWxsYXRpb24gYXR0ZW1wdCBzaW1wbHkgcHJvcGFnYXRlc1xuICAgICBwYXN0IFtwXSB0byBbcF0ncyBwcmVkZWNlc3NvcnMuIElmIHRoYXQgZXZlbnR1YWxseSByZXN1bHRzIGluIGNhbmNlbGluZ1xuICAgICBbcF0sIGl0IHdpbGwgYmUgdGhyb3VnaCB0aGUgbm9ybWFsIG1lY2hhbmlzbXMgb2YgdGhlIGZ1bmN0aW9uIChlLmcuXG4gICAgIFtMd3QuYmluZF0ncyBjYWxsYmFjaykuXG5cbiAgICAgQXMgYSByZXN1bHQsIHRoZSBvbmx5IHBvc3NpYmxlIHN0YXRlIGNoYW5nZSwgYmVmb3JlIHRoZSBjYWxsYmFjaywgaXMgdGhhdFxuICAgICBbcF0gbWF5IGhhdmUgYmVjb21lIGEgcHJveHkuIE5vdyxcblxuICAgICAtIElmIFtwXSBkb2VzIG5vdCB1bmRlcmdvIHRoaXMgc3RhdGUgY2hhbmdlIGFuZCBiZWNvbWUgYSBwcm94eSwgaXQgcmVtYWluc1xuICAgICAgIGFuIHVuZGVybHlpbmcsIHBlbmRpbmcgcHJvbWlzZS5cbiAgICAgLSBJZiBbcF0gZG9lcyBiZWNvbWUgYSBwcm94eSwgaXQgd2lsbCBiZSBhIHByb3h5IGZvciBhbm90aGVyIHByb21pc2UgW3AnXVxuICAgICAgIGNyZWF0ZWQgZnJlc2ggYnkgW0x3dC5iaW5kXSwgdG8gd2hpY2ggdGhpcyBzYW1lIGFyZ3VtZW50IGFwcGxpZXMuIFNlZVxuICAgICAgIFttYWtlX2ludG9fcHJveHldLlxuXG4gICAgIFNvLCBieSBpbmR1Y3Rpb24gb24gdGhlIGxlbmd0aCBvZiB0aGUgcHJveHkgKFtQcm94eSBfXSkgY2hhaW4sIGF0IHRoZSB0aW1lXG4gICAgIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQsIFtwXSBpcyBlaXRoZXIgYW4gdW5kZXJseWluZywgcGVuZGluZyBwcm9taXNlLCBvciBhXG4gICAgIHByb3h5IGZvciBhIHBlbmRpbmcgcHJvbWlzZS5cblxuICAgICBUaGUgY2FzdFxuXG4gICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluIC4uLlxuXG4gICAgIGVuY29kZXMgdGhlIHBvc3NpYmlsaXR5IG9mIHRoaXMgc3RhdGUgY2hhbmdlLiBJdCByZXBsYWNlcyBhIHJlZmVyZW5jZVxuXG4gICAgICAgcCA6ICgnYSwgdW5kZXJseWluZywgcGVuZGluZylcblxuICAgICB3aXRoXG5cbiAgICAgICBwIDogKCdhLCAkVW5rbm93biwgcGVuZGluZylcblxuICAgICBhbmQgaXMgdHlwaWNhbGx5IHNlZW4gYXQgdGhlIGJlZ2lubmluZyBvZiBjYWxsYmFja3MgcmVnaXN0ZXJlZCBieVxuICAgICBbTHd0LmJpbmRdIGFuZCBzaW1pbGFyIGZ1bmN0aW9ucy5cblxuICAgICBUaGUgY2FzdCBpcyBhIG5vLW9wIGNhc3QuIFRoZSBpbnRyb2R1Y3Rpb24gYW5kIGltbWVkaWF0ZSBlbGltaW5hdGlvbiBvZlxuICAgICBbU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBfXSBzZWVtcyB0byBiZSBvcHRpbWl6ZWQgYXdheSBldmVuIG9uIG9sZCB2ZXJzaW9uc1xuICAgICBvZiBPQ2FtbC4gKilcbmVuZFxub3BlbiBCYXNpY19oZWxwZXJzXG5cbigqIFNtYWxsIGhlbHBlcnMgdG8gYXZvaWQgY2F0Y2hpbmcgb2NhbWwtcnVudGltZSBleGNlcHRpb25zICopXG5tb2R1bGUgRXhjZXB0aW9uX2ZpbHRlciA9IHN0cnVjdFxuICB0eXBlIHQgPSBleG4gLT4gYm9vbFxuICBsZXQgaGFuZGxlX2FsbCA9IGZ1biBfIC0+IHRydWVcbiAgbGV0IGhhbmRsZV9hbGxfZXhjZXB0X3J1bnRpbWUgPSBmdW5jdGlvblxuICAgIHwgT3V0X29mX21lbW9yeSAtPiBmYWxzZVxuICAgIHwgU3RhY2tfb3ZlcmZsb3cgLT4gZmFsc2VcbiAgICB8IF8gLT4gdHJ1ZVxuICBsZXQgdiA9XG4gICAgKCogRGVmYXVsdCB2YWx1ZTogdGhlIGxlZ2FjeSBiZWhhdmlvdXIgdG8gYXZvaWQgYnJlYWtpbmcgcHJvZ3JhbXMgKilcbiAgICByZWYgaGFuZGxlX2FsbFxuICBsZXQgc2V0IGYgPSB2IDo9IGZcbiAgbGV0IHJ1biBlID0gIXYgZVxuZW5kXG5cbm1vZHVsZSBTZXF1ZW5jZV9hc3NvY2lhdGVkX3N0b3JhZ2UgOlxuc2lnXG4gICgqIFB1YmxpYyBpbnRlcmZhY2UgKilcbiAgdHlwZSAndiBrZXlcbiAgdmFsIG5ld19rZXkgOiB1bml0IC0+IF8ga2V5XG4gIHZhbCBnZXQgOiAndiBrZXkgLT4gJ3Ygb3B0aW9uXG4gIHZhbCB3aXRoX3ZhbHVlIDogJ3Yga2V5IC0+ICd2IG9wdGlvbiAtPiAodW5pdCAtPiAnYikgLT4gJ2JcblxuICAoKiBJbnRlcm5hbCBpbnRlcmZhY2UgKilcbiAgdmFsIGN1cnJlbnRfc3RvcmFnZSA6IHN0b3JhZ2UgcmVmXG5lbmQgPVxuc3RydWN0XG4gICgqIFRoZSBpZGVhIGJlaGluZCBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UgaXMgdG8gcHJlc2VydmUgc29tZSB2YWx1ZXNcbiAgICAgZHVyaW5nIGEgY2FsbCB0byBbYmluZF0gb3Igb3RoZXIgc2VxdWVudGlhbCBjb21wb3NpdGlvbiBvcGVyYXRpb24sIGFuZFxuICAgICByZXN0b3JlIHRob3NlIHZhbHVlcyBpbiB0aGUgY2FsbGJhY2sgZnVuY3Rpb246XG5cbiAgICAgICBMd3Qud2l0aF92YWx1ZSBteV9rZXkgKFNvbWUgXCJmb29cIikgKGZ1biAoKSAtPlxuICAgICAgIHAgPnw9IGZ1biAoKSAtPlxuICAgICAgIGFzc2VydCAoTHd0LmdldCBteV9rZXkgPSBTb21lIFwiZm9vXCIpKVxuICAgICAgICAgKCogV2lsbCBzdWNjZWVkIGV2ZW4gaWYgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgbGF0ZXIuICopXG5cbiAgICAgTm90ZSB0aGF0IGl0IGRvZXMgbm90IG1hdHRlciB0aGF0IHRoZSBjYWxsYmFjayBpcyBkZWZpbmVkIHdpdGhpbiBhblxuICAgICBhcmd1bWVudCBvZiBbd2l0aF92YWx1ZV0sIGkuZS4sIHRoaXMgZG9lcyB0aGUgc2FtZTpcblxuICAgICAgIGxldCBmID0gZnVuICgpIC0+IGFzc2VydCAoTHd0LmdldCBteV9rZXkgPSBTb21lIFwiZm9vXCIpIGluXG4gICAgICAgTHd0LndpdGhfdmFsdWUgbXlfa2V5IChTb21lIFwiZm9vXCIpIChmdW4gKCkgLT4gcCA+fD0gZilcblxuICAgICBBbGwgdGhhdCBtYXR0ZXJzIGlzIHRoYXQgdGhlIHRvcC1tb3N0IHNlcXVlbmNpbmcgb3BlcmF0aW9uIChpbiB0aGlzIGNhc2UsXG4gICAgIG1hcCkgaXMgZXhlY3V0ZWQgYnkgdGhhdCBhcmd1bWVudC5cblxuICAgICBUaGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc2luZ2xlIGdsb2JhbCBoZXRlcm9nZW5lb3VzIGtleS12YWx1ZSBtYXAuXG4gICAgIFNlcXVlbnRpYWwgY29tcG9zaXRpb24gZnVuY3Rpb25zIHNuYXBzaG90IHRoaXMgbWFwIHdoZW4gdGhleSBhcmUgY2FsbGVkLFxuICAgICBhbmQgcmVzdG9yZSB0aGUgc25hcHNob3QgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIHVzZXIncyBjYWxsYmFjay4gVGhlIHNhbWVcbiAgICAgaGFwcGVucyBmb3IgY2FuY2VsIHRyaWdnZXJzIGFkZGVkIGJ5IFtvbl9jYW5jZWxdLlxuXG4gICAgIE1haW50YWluZXIncyBub3RlOiBJIHRoaW5rIHVzaW5nIHRoaXMgbWVjaGFuaXNtIHNob3VsZCBiZSBkaXNjb3VyYWdlZCBpblxuICAgICBuZXcgY29kZS4gKilcblxuICB0eXBlICd2IGtleSA9IHtcbiAgICBpZCA6IGludDtcbiAgICBtdXRhYmxlIHZhbHVlIDogJ3Ygb3B0aW9uO1xuICB9XG5cbiAgbGV0IG5leHRfa2V5X2lkID0gcmVmIDBcblxuICBsZXQgbmV3X2tleSAoKSA9XG4gICAgbGV0IGlkID0gIW5leHRfa2V5X2lkIGluXG4gICAgbmV4dF9rZXlfaWQgOj0gaWQgKyAxO1xuICAgIHtpZCA9IGlkOyB2YWx1ZSA9IE5vbmV9XG5cbiAgbGV0IGN1cnJlbnRfc3RvcmFnZSA9IHJlZiBTdG9yYWdlX21hcC5lbXB0eVxuXG4gIGxldCBnZXQga2V5ID1cbiAgICBpZiBTdG9yYWdlX21hcC5tZW0ga2V5LmlkICFjdXJyZW50X3N0b3JhZ2UgdGhlbiBiZWdpblxuICAgICAgbGV0IHJlZnJlc2ggPSBTdG9yYWdlX21hcC5maW5kIGtleS5pZCAhY3VycmVudF9zdG9yYWdlIGluXG4gICAgICByZWZyZXNoICgpO1xuICAgICAgbGV0IHZhbHVlID0ga2V5LnZhbHVlIGluXG4gICAgICBrZXkudmFsdWUgPC0gTm9uZTtcbiAgICAgIHZhbHVlXG4gICAgZW5kXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG4gIGxldCB3aXRoX3ZhbHVlIGtleSB2YWx1ZSBmID1cbiAgICBsZXQgbmV3X3N0b3JhZ2UgPVxuICAgICAgbWF0Y2ggdmFsdWUgd2l0aFxuICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgbGV0IHJlZnJlc2ggPSBmdW4gKCkgLT4ga2V5LnZhbHVlIDwtIHZhbHVlIGluXG4gICAgICAgIFN0b3JhZ2VfbWFwLmFkZCBrZXkuaWQgcmVmcmVzaCAhY3VycmVudF9zdG9yYWdlXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgU3RvcmFnZV9tYXAucmVtb3ZlIGtleS5pZCAhY3VycmVudF9zdG9yYWdlXG4gICAgaW5cblxuICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBuZXdfc3RvcmFnZTtcbiAgICB0cnlcbiAgICAgIGxldCByZXN1bHQgPSBmICgpIGluXG4gICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgIHJlc3VsdFxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgIHJhaXNlIGV4blxuZW5kXG5pbmNsdWRlIFNlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZVxuXG5cblxubW9kdWxlIFBlbmRpbmdfY2FsbGJhY2tzIDpcbnNpZ1xuICAoKiBNdXRhdGluZyBjYWxsYmFjayBsaXN0cyBhdHRhY2hlZCB0byBwZW5kaW5nIHByb21pc2VzICopXG4gIHZhbCBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIDpcbiAgICAnYSBjYWxsYmFja3MgLT4gJ2EgcmVndWxhcl9jYWxsYmFjayAtPiB1bml0XG4gIHZhbCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiA6XG4gICAgJ2EgdCBsaXN0IC0+ICdhIHJlZ3VsYXJfY2FsbGJhY2sgLT4gdW5pdFxuICB2YWwgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX3JlbW92ZV9mdW5jdGlvbiA6XG4gICAgJ2EgdCBsaXN0IC0+ICdhIHJlZ3VsYXJfY2FsbGJhY2sgLT4gY2FuY2VsX2NhbGxiYWNrXG4gIHZhbCBhZGRfY2FuY2VsX2NhbGxiYWNrIDogJ2EgY2FsbGJhY2tzIC0+IGNhbmNlbF9jYWxsYmFjayAtPiB1bml0XG4gIHZhbCBtZXJnZV9jYWxsYmFja3MgOiBmcm9tOidhIGNhbGxiYWNrcyAtPiBpbnRvOidhIGNhbGxiYWNrcyAtPiB1bml0XG5lbmQgPVxuc3RydWN0XG4gIGxldCBjb25jYXRfcmVndWxhcl9jYWxsYmFja3MgbDEgbDIgPVxuICAgIGJlZ2luIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHksIF8gLT4gbDJcbiAgICB8IF8sIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPiBsMVxuICAgIHwgXywgXyAtPiBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChsMSwgbDIpXG4gICAgZW5kIFtAb2NhbWwud2FybmluZyBcIi00XCJdXG5cbiAgbGV0IGNvbmNhdF9jYW5jZWxfY2FsbGJhY2tzIGwxIGwyID1cbiAgICBiZWdpbiBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHksIF8gLT4gbDJcbiAgICB8IF8sIENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5IC0+IGwxXG4gICAgfCBfLCBfIC0+IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCAobDEsIGwyKVxuICAgIGVuZCBbQG9jYW1sLndhcm5pbmcgXCItNFwiXVxuXG4gICgqIEluIGEgY2FsbGJhY2sgbGlzdCwgZmlsdGVycyBvdXQgY2VsbHMgb2YgZXhwbGljaXRseSByZW1vdmFibGUgY2FsbGJhY2tzXG4gICAgIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuICopXG4gIGxldCByZWMgY2xlYW5fdXBfY2FsbGJhY2tfY2VsbHMgPSBmdW5jdGlvblxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIHtjb250ZW50cyA9IE5vbmV9IC0+XG4gICAgICBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHlcblxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIHtjb250ZW50cyA9IFNvbWUgX31cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgX1xuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5IGFzIGNhbGxiYWNrcyAtPlxuICAgICAgY2FsbGJhY2tzXG5cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGwxLCBsMikgLT5cbiAgICAgIGxldCBsMSA9IGNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzIGwxIGluXG4gICAgICBsZXQgbDIgPSBjbGVhbl91cF9jYWxsYmFja19jZWxscyBsMiBpblxuICAgICAgY29uY2F0X3JlZ3VsYXJfY2FsbGJhY2tzIGwxIGwyXG5cbiAgKCogU2VlIFtjbGVhcl9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19jZWxsXSBhbmQgW21lcmdlX2NhbGxiYWNrc10uICopXG4gIGxldCBjbGVhbnVwX3Rocm90dGxlID0gNDJcblxuICAoKiBFeHBsaWNpdGx5IHJlbW92YWJsZSBjYWxsYmFja3MgYXJlIGFkZGVkIChtYWlubHkpIGJ5IFtMd3QuY2hvb3NlXSBhbmQgaXRzXG4gICAgIHNpbWlsYXIgZnVuY3Rpb25zLiBJbiBbTHd0LmNob29zZSBbcDsgcCddXSwgaWYgW3AnXSByZXNvbHZlcyBmaXJzdCwgdGhlXG4gICAgIGNhbGxiYWNrIGFkZGVkIGJ5IFtMd3QuY2hvb3NlXSB0byBbcF0gaXMgcmVtb3ZlZC5cblxuICAgICBUaGUgcmVtb3ZhbCBpdHNlbGYgaXMgYWNjb21wbGlzaGVkIHdoZW4gdGhpcyBmdW5jdGlvbiBjbGVhcnMgdGhlIHJlZmVyZW5jZVxuICAgICBjZWxsIFtjZWxsXSwgd2hpY2ggY29udGFpbnMgdGhlIHJlZmVyZW5jZSB0byB0aGF0IGNhbGxiYWNrLlxuXG4gICAgIElmIFtwXSBpcyBhIGxvbmctcGVuZGluZyBwcm9taXNlIHRoYXQgcmVwZWF0ZWRseSBwYXJ0aWNpcGF0ZXMgaW5cbiAgICAgW0x3dC5jaG9vc2VdLCBwZXJoYXBzIGluIGEgbG9vcCwgaXQgd2lsbCBhY2N1bXVsYXRlIGEgbGFyZ2UgbnVtYmVyIG9mXG4gICAgIGNsZWFyZWQgcmVmZXJlbmNlIGNlbGxzIGluIHRoaXMgZmFzaGlvbi4gVG8gYXZvaWQgYSBtZW1vcnkgbGVhaywgdGhleSBtdXN0XG4gICAgIGJlIGNsZWFuZWQgdXAuIEhvd2V2ZXIsIHRoZSBjZWxscyBhcmUgbm90IGNsZWFuZWQgdXAgb24gKmV2ZXJ5KiByZW1vdmFsLFxuICAgICBwcmVzdW1hYmx5IGJlY2F1c2Ugc2Nhbm5pbmcgdGhlIGNhbGxiYWNrIGxpc3QgdGhhdCBvZnRlbiwgYW5kIHJlYnVpbGRpbmdcbiAgICAgaXQsIGNhbiBnZXQgZXhwZW5zaXZlLlxuXG4gICAgIENsZWFudXAgaXMgdGhyb3R0bGVkIGJ5IG1haW50YWluaW5nIGEgY291bnRlciwgW2NsZWFudXBzX2RlZmVycmVkXSwgb24gZWFjaFxuICAgICBwZW5kaW5nIHByb21pc2UuIFRoZSBjb3VudGVyIGlzIGluY3JlbWVudGVkIGVhY2ggdGltZSB0aGlzIGZ1bmN0aW9uIHdhbnRzXG4gICAgIHRvIGNsZWFuIHRoZSBjYWxsYmFjayBsaXN0IChyaWdodCBhZnRlciBjbGVhcmluZyBhIGNlbGwpLiBXaGVuIHRoZSBjb3VudGVyXG4gICAgIHJlYWNoZXMgW2NsZWFudXBfdGhyb3R0bGVdLCB0aGUgY2FsbGJhY2sgbGlzdCBpcyBhY3R1YWxseSBzY2FubmVkIGFuZFxuICAgICBjbGVhcmVkIGNhbGxiYWNrIGNlbGxzIGFyZSByZW1vdmVkLiAqKVxuICBsZXQgY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbCBjZWxsIH5vcmlnaW5hbGx5X2FkZGVkX3RvOnBzID1cbiAgICBjZWxsIDo9IE5vbmU7XG5cbiAgICAoKiBHbyB0aHJvdWdoIHRoZSBwcm9taXNlcyB0aGUgY2VsbCBoYWQgb3JpZ2luYWxseSBiZWVuIGFkZGVkIHRvLCBhbmQgZWl0aGVyXG4gICAgICAgZGVmZXIgYSBjbGVhbnVwLCBvciBhY3R1YWxseSBjbGVhbiB1cCB0aGVpciBjYWxsYmFjayBsaXN0cy4gKilcbiAgICBwcyB8PiBMaXN0Lml0ZXIgKGZ1biBwIC0+XG4gICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgKCogU29tZSBvZiB0aGUgcHJvbWlzZXMgbWF5IGFscmVhZHkgaGF2ZSBiZWVuIHJlc29sdmVkIGF0IHRoZSB0aW1lIHRoaXNcbiAgICAgICAgIGZ1bmN0aW9uIGlzIGNhbGxlZC4gKilcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT4gKClcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPiAoKVxuXG4gICAgICB8IFBlbmRpbmcgY2FsbGJhY2tzIC0+XG4gICAgICAgIG1hdGNoIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyB3aXRoXG4gICAgICAgICgqIElmIHRoZSBwcm9taXNlIGhhcyBvbmx5IG9uZSByZWd1bGFyIGNhbGxiYWNrLCBhbmQgaXQgaXMgcmVtb3ZhYmxlLCBpdFxuICAgICAgICAgICBtdXN0IGhhdmUgYmVlbiB0aGUgY2VsbCBjbGVhcmVkIGluIHRoaXMgZnVuY3Rpb24sIGFib3ZlLiBJbiB0aGF0XG4gICAgICAgICAgIGNhc2UsIGp1c3Qgc2V0IGl0cyBjYWxsYmFjayBsaXN0IHRvIGVtcHR5LiAqKVxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayBfIC0+XG4gICAgICAgICAgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzIDwtIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eVxuXG4gICAgICAgICgqIE1haW50YWluZXIncyBub3RlOiBJIHRoaW5rIHRoaXMgZnVuY3Rpb24gc2hvdWxkbid0IHRyeSB0byB0cmlnZ2VyIGFcbiAgICAgICAgICAgY2xlYW51cCBpbiB0aGUgZmlyc3QgdHdvIGNhc2VzLCBidXQgSSBhbSBwcmVzZXJ2aW5nIHRoZW0gZm9yIG5vdywgYXNcbiAgICAgICAgICAgdGhpcyBpcyBob3cgdGhlIGNvZGUgd2FzIHdyaXR0ZW4gaW4gdGhlIHBhc3QuICopXG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBfXG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCBfIC0+XG4gICAgICAgICAgbGV0IGNsZWFudXBzX2RlZmVycmVkID0gY2FsbGJhY2tzLmNsZWFudXBzX2RlZmVycmVkICsgMSBpblxuICAgICAgICAgIGlmIGNsZWFudXBzX2RlZmVycmVkID4gY2xlYW51cF90aHJvdHRsZSB0aGVuIGJlZ2luXG4gICAgICAgICAgICBjYWxsYmFja3MuY2xlYW51cHNfZGVmZXJyZWQgPC0gMDtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyA8LVxuICAgICAgICAgICAgICBjbGVhbl91cF9jYWxsYmFja19jZWxscyBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3NcbiAgICAgICAgICBlbmQgZWxzZVxuICAgICAgICAgICAgY2FsbGJhY2tzLmNsZWFudXBzX2RlZmVycmVkIDwtIGNsZWFudXBzX2RlZmVycmVkKVxuXG4gICgqIENvbmNhdGVuYXRlcyBib3RoIGtpbmRzIG9mIGNhbGxiYWNrcyBvbiBbfmZyb21dIHRvIHRoZSBjb3JyZXNwb25kaW5nIGxpc3RzXG4gICAgIG9mIFt+aW50b10uIFRoZSBjYWxsYmFjayBsaXN0cyBvbiBbfmZyb21dIGFyZSAqbm90KiB0aGVuIGNsZWFyZWQsIGJlY2F1c2VcbiAgICAgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBieSBbU2VxdWVudGlhbF9jb21wb3NpdGlvbi5tYWtlX2ludG9fcHJveHldLFxuICAgICB3aGljaCBpbW1lZGlhdGVseSBjaGFuZ2VzIHRoZSBzdGF0ZSBvZiBbfmZyb21dIGFuZCBsb3NlcyByZWZlcmVuY2VzIHRvIHRoZVxuICAgICBvcmlnaW5hbCBjYWxsYmFjayBsaXN0cy5cblxuICAgICBUaGUgW2NsZWFudXBzX2RlZmVycmVkXSBmaWVsZHMgb2YgYm90aCBwcm9taXNlcyBhcmUgc3VtbWVkLCBhbmQgaWYgdGhlIHN1bVxuICAgICBleGNlZWRzIFtjbGVhbnVwX3Rocm90dGxlXSwgYSBjbGVhbnVwIG9mIHJlZ3VsYXIgY2FsbGJhY2tzIGlzIHRyaWdnZXJlZC5cbiAgICAgVGhpcyBpcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrczsgc2VlXG4gICAgIFtjbGVhcl9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19jZWxsXS4gKilcbiAgbGV0IG1lcmdlX2NhbGxiYWNrcyB+ZnJvbSB+aW50byA9XG4gICAgbGV0IHJlZ3VsYXJfY2FsbGJhY2tzID1cbiAgICAgIGNvbmNhdF9yZWd1bGFyX2NhbGxiYWNrcyBpbnRvLnJlZ3VsYXJfY2FsbGJhY2tzIGZyb20ucmVndWxhcl9jYWxsYmFja3MgaW5cbiAgICBsZXQgY2xlYW51cHNfZGVmZXJyZWQgPSBpbnRvLmNsZWFudXBzX2RlZmVycmVkICsgZnJvbS5jbGVhbnVwc19kZWZlcnJlZCBpblxuXG4gICAgbGV0IHJlZ3VsYXJfY2FsbGJhY2tzLCBjbGVhbnVwc19kZWZlcnJlZCA9XG4gICAgICBpZiBjbGVhbnVwc19kZWZlcnJlZCA+IGNsZWFudXBfdGhyb3R0bGUgdGhlblxuICAgICAgICBjbGVhbl91cF9jYWxsYmFja19jZWxscyByZWd1bGFyX2NhbGxiYWNrcywgMFxuICAgICAgZWxzZVxuICAgICAgICByZWd1bGFyX2NhbGxiYWNrcywgY2xlYW51cHNfZGVmZXJyZWRcbiAgICBpblxuXG4gICAgbGV0IGNhbmNlbF9jYWxsYmFja3MgPVxuICAgICAgY29uY2F0X2NhbmNlbF9jYWxsYmFja3MgaW50by5jYW5jZWxfY2FsbGJhY2tzIGZyb20uY2FuY2VsX2NhbGxiYWNrcyBpblxuXG4gICAgaW50by5yZWd1bGFyX2NhbGxiYWNrcyA8LSByZWd1bGFyX2NhbGxiYWNrcztcbiAgICBpbnRvLmNhbmNlbF9jYWxsYmFja3MgPC0gY2FuY2VsX2NhbGxiYWNrcztcbiAgICBpbnRvLmNsZWFudXBzX2RlZmVycmVkIDwtIGNsZWFudXBzX2RlZmVycmVkXG5cblxuXG4gICgqIEdlbmVyYWwsIGludGVybmFsLCBmdW5jdGlvbiBmb3IgYWRkaW5nIGEgcmVndWxhciBjYWxsYmFjay4gKilcbiAgbGV0IGFkZF9yZWd1bGFyX2NhbGxiYWNrX2xpc3Rfbm9kZSBjYWxsYmFja3Mgbm9kZSA9XG4gICAgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzIDwtXG4gICAgICBtYXRjaCBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3Mgd2l0aFxuICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT5cbiAgICAgICAgbm9kZVxuICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIF9cbiAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIF9cbiAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCBfIGFzIGV4aXN0aW5nIC0+XG4gICAgICAgIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgKG5vZGUsIGV4aXN0aW5nKVxuXG4gIGxldCBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIGNhbGxiYWNrcyBmID1cbiAgICBhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGVcbiAgICAgIGNhbGxiYWNrcyAoUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBmKVxuXG4gICgqIEFkZHMgW2NhbGxiYWNrXSBhcyByZW1vdmFibGUgdG8gZWFjaCBwcm9taXNlIGluIFtwc10uIFRoZSBmaXJzdCBwcm9taXNlIGluXG4gICAgIFtwc10gdG8gdHJpZ2dlciBbY2FsbGJhY2tdIHJlbW92ZXMgW2NhbGxiYWNrXSBmcm9tIHRoZSBvdGhlciBwcm9taXNlczsgdGhpc1xuICAgICBndWFyYW50ZWVzIHRoYXQgW2NhbGxiYWNrXSBpcyBjYWxsZWQgYXQgbW9zdCBvbmNlLiBBbGwgdGhlIHByb21pc2VzIGluIFtwc11cbiAgICAgbXVzdCBiZSBwZW5kaW5nLlxuXG4gICAgIFRoaXMgaXMgYW4gaW50ZXJuYWwgZnVuY3Rpb24sIGluZGlyZWN0bHkgdXNlZCBieSB0aGUgaW1wbGVtZW50YXRpb25zIG9mXG4gICAgIFtMd3QuY2hvb3NlXSBhbmQgcmVsYXRlZCBmdW5jdGlvbnMuICopXG4gIGxldCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfY2VsbCBwcyBmID1cbiAgICBsZXQgcmVjIGNlbGwgPSByZWYgKFNvbWUgc2VsZl9yZW1vdmluZ19jYWxsYmFja193cmFwcGVyKVxuICAgIGFuZCBzZWxmX3JlbW92aW5nX2NhbGxiYWNrX3dyYXBwZXIgcmVzdWx0ID1cbiAgICAgIGNsZWFyX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2NlbGwgY2VsbCB+b3JpZ2luYWxseV9hZGRlZF90bzpwcztcbiAgICAgIGYgcmVzdWx0XG4gICAgaW5cblxuICAgIGxldCBub2RlID0gUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIGNlbGwgaW5cbiAgICBwcyB8PiBMaXN0Lml0ZXIgKGZ1biBwIC0+XG4gICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgfCBQZW5kaW5nIGNhbGxiYWNrcyAtPiBhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGUgY2FsbGJhY2tzIG5vZGVcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IFJlamVjdGVkIF8gLT4gYXNzZXJ0IGZhbHNlKTtcblxuICAgIGNlbGxcblxuICBsZXQgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgZiA9XG4gICAgaWdub3JlIChhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfY2VsbCBwcyBmKVxuXG4gICgqIFRoaXMgaXMgYmFzaWNhbGx5IGp1c3QgdG8gc3VwcG9ydCBbTHd0LnByb3RlY3RlZF0sIHdoaWNoIG5lZWRzIHRvIHJlbW92ZVxuICAgICB0aGUgY2FsbGJhY2sgaW4gY2lyY3Vtc3RhbmNlcyBvdGhlciB0aGFuIHRoZSBjYWxsYmFjayBiZWluZyBjYWxsZWQuICopXG4gIGxldCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfcmVtb3ZlX2Z1bmN0aW9uIHBzIGYgPVxuICAgIGxldCBjZWxsID0gYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX2NlbGwgcHMgZiBpblxuICAgIGZ1biAoKSAtPlxuICAgICAgY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbCBjZWxsIH5vcmlnaW5hbGx5X2FkZGVkX3RvOnBzXG5cbiAgbGV0IGFkZF9jYW5jZWxfY2FsbGJhY2sgY2FsbGJhY2tzIGYgPVxuICAgIGxldCBub2RlID0gQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgKCFjdXJyZW50X3N0b3JhZ2UsIGYpIGluXG5cbiAgICBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcyA8LVxuICAgICAgbWF0Y2ggY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3Mgd2l0aFxuICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPlxuICAgICAgICBub2RlXG5cbiAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgX1xuICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSBfXG4gICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCBfIC0+XG4gICAgICAgIENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCAobm9kZSwgY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3MpXG5lbmRcbm9wZW4gUGVuZGluZ19jYWxsYmFja3NcblxuXG5cbm1vZHVsZSBSZXNvbHV0aW9uX2xvb3AgOlxuc2lnXG4gICgqIEFsbCB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrcyBhcmUgY2FsbGVkIGJ5IEx3dCBvbmx5IHRocm91Z2ggdGhpcyBtb2R1bGUuIEl0XG4gICAgIHRyYWNrcyB0aGUgY3VycmVudCBjYWxsYmFjayBzdGFjayBkZXB0aCwgYW5kIGRlY2lkZXMgd2hldGhlciBlYWNoIGNhbGxiYWNrXG4gICAgIGNhbGwgc2hvdWxkIGJlIGRlZmVycmVkIG9yIG5vdC4gKilcblxuICAoKiBJbnRlcm5hbCBpbnRlcmZhY2UgdXNlZCBvbmx5IGluIHRoaXMgbW9kdWxlIEx3dCAqKVxuICB2YWwgcmVzb2x2ZSA6XG4gICAgP2FsbG93X2RlZmVycmluZzpib29sIC0+XG4gICAgP21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aDppbnQgLT5cbiAgICAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpIHByb21pc2UgLT5cbiAgICAnYSByZXNvbHZlZF9zdGF0ZSAtPlxuICAgICAgKCdhLCB1bmRlcmx5aW5nLCByZXNvbHZlZCkgc3RhdGVfY2hhbmdlZFxuXG4gIHZhbCBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW0gOlxuICAgID9hbGxvd19kZWZlcnJpbmc6Ym9vbCAtPlxuICAgID9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGg6aW50IC0+XG4gICAgKCdhIGNhbGxiYWNrcykgLT5cbiAgICAnYSByZXNvbHZlZF9zdGF0ZSAtPlxuICAgICAgdW5pdFxuXG4gIHZhbCBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXQgOlxuICAgID9ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6Ym9vbCAtPlxuICAgIGNhbGxiYWNrOih1bml0IC0+ICdhKSAtPlxuICAgIGlmX2RlZmVycmVkOih1bml0IC0+ICdhICogJ2IgcmVndWxhcl9jYWxsYmFjayAqICdiIHJlc29sdmVkX3N0YXRlKSAtPlxuICAgICAgJ2FcblxuICB2YWwgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdFxuXG4gICgqIEludGVybmFsIGludGVyZmFjZSBleHBvc2VkIHRvIG90aGVyIG1vZHVsZXMgaW4gTHd0ICopXG4gIHZhbCBhYmFuZG9uX3dha2V1cHMgOiB1bml0IC0+IHVuaXRcblxuICAoKiBQdWJsaWMgaW50ZXJmYWNlICopXG4gIGV4Y2VwdGlvbiBDYW5jZWxlZFxuXG4gIHZhbCBhc3luY19leGNlcHRpb25faG9vayA6IChleG4gLT4gdW5pdCkgcmVmXG5lbmQgPVxuc3RydWN0XG4gICgqIFdoZW4gTHd0IG5lZWRzIHRvIGNhbGwgYSBjYWxsYmFjaywgaXQgZW50ZXJzIHRoZSByZXNvbHV0aW9uIGxvb3AuIFRoaXNcbiAgICAgdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiBMd3Qgc2V0cyB0aGUgc3RhdGUgb2Ygb25lIHByb21pc2UgdG8gW0Z1bGZpbGxlZCBfXVxuICAgICBvciBbUmVqZWN0ZWQgX10uIFRoZSBjYWxsYmFja3MgdGhhdCB3ZXJlIGF0dGFjaGVkIHRvIHRoZSBwcm9taXNlIHdoZW4gaXRcbiAgICAgd2FzIHBlbmRpbmcgbXVzdCB0aGVuIGJlIGNhbGxlZC5cblxuICAgICBUaGlzIGFsc28gaGFwcGVucyBpbiBhIGZldyBvdGhlciBzaXR1YXRpb25zLiBGb3IgZXhhbXBsZSwgd2hlbiBbTHd0LmJpbmRdXG4gICAgIGlzIGNhbGxlZCBvbiBhIHByb21pc2UsIGJ1dCB0aGF0IHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCwgdGhlIGNhbGxiYWNrXG4gICAgIHBhc3NlZCB0byBbYmluZF0gbXVzdCBiZSBjYWxsZWQuXG5cbiAgICAgVGhlIGNhbGxiYWNrcyB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZXNvbHV0aW9uIGxvb3AgbWlnaHQgcmVzb2x2ZSBtb3JlXG4gICAgIHByb21pc2VzLCB0cmlnZ2VyaW5nIG1vcmUgY2FsbGJhY2tzLCBhbmQgc28gb24uIFRoaXMgaXMgd2hhdCBtYWtlcyB0aGVcbiAgICAgcmVzb2x1dGlvbiBsb29wIGEge2UgbG9vcH0uXG5cbiAgICAgTHd0IGdlbmVyYWxseSB0cmllcyB0byBjYWxsIGVhY2ggY2FsbGJhY2sgaW1tZWRpYXRlbHkuIEhvd2V2ZXIsIHRoaXMgY2FuXG4gICAgIGxlYWQgdG8gYSBwcm9ncmVzc2l2ZSBkZWVwZW5pbmcgb2YgdGhlIGNhbGwgc3RhY2ssIHVudGlsIHRoZXJlIGlzIGEgc3RhY2tcbiAgICAgb3ZlcmZsb3cuIFRoaXMgY2FuJ3QgYmUgYXZvaWRlZCBieSBkb2luZyB0YWlsIGNhbGxzLCBiZWNhdXNlIEx3dCBhbHdheXNcbiAgICAgbmVlZHMgdG8gZG8gZXhjZXB0aW9uIGhhbmRsaW5nIGFyb3VuZCBjYWxsYmFja3MgY2FsbHM6IGVhY2ggY2FsbGJhY2sgY2FsbFxuICAgICBpcyBmb2xsb3dlZCBieSBhbiBleGNlcHRpb24gaGFuZGxlci4gSW5zdGVhZCwgd2hhdCBMd3QgZG9lcyBpcyB0cmFjayB0aGVcbiAgICAgY3VycmVudCBjYWxsYmFjayBjYWxsIGRlcHRoLiBPbmNlIHRoYXQgZGVwdGggcmVhY2hlcyBhIGNlcnRhaW4gbnVtYmVyLFxuICAgICBbZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGhdLCBkZWZpbmVkIGJlbG93LCBmdXJ0aGVyIGNhbGxiYWNrc1xuICAgICBhcmUgZGVmZXJyZWQgaW50byBhIHF1ZXVlIGluc3RlYWQuIFRoYXQgcXVldWUgaXMgZHJhaW5lZCB3aGVuIEx3dCBleGl0c1xuICAgICBmcm9tIHRoZSB0b3AtbW9zdCBjYWxsYmFjayBjYWxsIHRoYXQgdHJpZ2dlcmVkIHRoZSByZXNvbHV0aW9uIGxvb3AgaW4gdGhlXG4gICAgIGZpcnN0IHBsYWNlLlxuXG4gICAgIFRvIGVuc3VyZSB0aGF0IHRoaXMgZGVmZXJyYWwgbWVjaGFuaXNtIGlzIGFsd2F5cyBwcm9wZXJseSBpbnZva2VkLCBhbGxcbiAgICAgY2FsbGJhY2tzIGNhbGxlZCBieSBMd3QgYXJlIGNhbGxlZCB0aHJvdWdoIG9uZSBvZiB0aHJlZSBmdW5jdGlvbnMgcHJvdmlkZWRcbiAgICAgYnkgdGhpcyBtb2R1bGU6XG5cbiAgICAgLSBbcmVzb2x2ZV0sIHdoaWNoIGNhbGxzIGFsbCB0aGUgY2FsbGJhY2tzIGFzc29jaWF0ZWQgdG8gYSBwZW5kaW5nIHByb21pc2VcbiAgICAgICAoYW5kIHJlc29sdmVzIGl0LCBjaGFuZ2luZyBpdHMgc3RhdGUpLlxuICAgICAtIFtydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1dLCB3aGljaCBpcyBpbnRlcm5hbGx5IHVzZWQgYnkgW3Jlc29sdmVdIHRvXG4gICAgICAgY2FsbCBjYWxsYmFja3MgdGhhdCBhcmUgaW4gYSByZWNvcmQgb2YgdHlwZSBbJ2EgY2FsbGJhY2tzXSwgd2hpY2ggcmVjb3Jkc1xuICAgICAgIGFyZSBhc3NvY2lhdGVkIHdpdGggcGVuZGluZyBwcm9taXNlcy4gVGhpcyBmdW5jdGlvbiBpcyBleHBvc2VkIGJlY2F1c2VcbiAgICAgICB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiBbTHd0LmNhbmNlbF0gbmVlZHMgdG8gY2FsbCBpdCBkaXJlY3RseS5cbiAgICAgICBQcm9taXNlIHJlc29sdXRpb24gYW5kIGNhbGxiYWNrIGNhbGxpbmcgYXJlIHNlcGFyYXRlZCBpbiBhIHVuaXF1ZSB3YXkgaW5cbiAgICAgICBbY2FuY2VsXS5cbiAgICAgLSBbcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XSwgd2hpY2ggaXMgdXNlZCBieSBbTHd0LmJpbmRdIGFuZCBzaW1pbGFyXG4gICAgICAgZnVuY3Rpb25zIHRvIGNhbGwgc2luZ2xlIGNhbGxiYWNrcyB3aGVuIHRoZSBwcm9taXNlcyBwYXNzZWQgdG9cbiAgICAgICBbTHd0LmJpbmRdLCBldGMuLCBhcmUgYWxyZWFkeSByZXNvbHZlZC5cblxuICAgICBDdXJyZW50IEx3dCBhY3R1YWxseSBoYXMgYSBtZXNzeSBtaXggb2YgY2FsbGJhY2stY2FsbGluZyBiZWhhdmlvcnMuIEZvclxuICAgICBleGFtcGxlLCBbTHd0LmJpbmRdIGlzIGV4cGVjdGVkIHRvIGFsd2F5cyBjYWxsIGl0cyBjYWxsYmFjayBpbW1lZGlhdGVseSxcbiAgICAgd2hpbGUgW0x3dC53YWtldXBfbGF0ZXJdIGlzIGV4cGVjdGVkIHRvIGRlZmVyIGFsbCBjYWxsYmFja3Mgb2YgdGhlIHByb21pc2VcbiAgICAgcmVzb2x2ZWQsIHtlIHVubGVzc30gTHd0IGlzIG5vdCBhbHJlYWR5IGluc2lkZSB0aGUgcmVzb2x1dGlvbiBsb29wLlxuXG4gICAgIFdlIHBsYW5uZWQgdG8gbWFrZSB0aGVzZSBiZWhhdmlvcnMgdW5pZm9ybSBpbiBMd3QgNC4wLjAsIGJ1dCBkZWNpZGVkXG4gICAgIGFnYWluc3QgaXQgZHVlIHRvIHRoZSByaXNrIG9mIGJyZWFraW5nIHVzZXJzLiBTZWVcblxuICAgICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9wdWxsLzUwMFxuICAgICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9wdWxsLzUxOVxuXG4gICAgIEFzIHBhcnQgb2YgdGhlIHByZXBhcmF0aW9uIGZvciB0aGUgY2hhbmdlLCB0aGUgYWJvdmUgY2FsbGJhY2staW52b2tpbmdcbiAgICAgZnVuY3Rpb25zIHN1cHBvcnQgc2V2ZXJhbCBvcHRpb25hbCBhcmd1bWVudHMgdG8gZW11bGF0ZSB0aGUgdmFyaW91c1xuICAgICBiZWhhdmlvcnMuIFdlIGRlY2lkZWQgbm90IHRvIHJlbW92ZSB0aGlzIG1hY2hpbmVyeSwgYmVjYXVzZSB3ZSBtaWdodCB3YW50XG4gICAgIHRvIGV4cG9zZSBkaWZmZXJlbnQgQVBJcyB0byBMd3QgaW4gdGhlIGZ1dHVyZS5cblxuICAgICAtIFt+YWxsb3dfZGVmZXJyaW5nOmZhbHNlXSBhbGxvd3MgaWdub3JpbmcgdGhlIGNhbGxiYWNrIHN0YWNrIGRlcHRoLCBhbmRcbiAgICAgICBjYWxsaW5nIHRoZSBjYWxsYmFja3MgaW1tZWRpYXRlbHkuIFRoaXMgZW11bGF0ZXMgdGhlIG9sZCByZXNvbHV0aW9uXG4gICAgICAgYmVoYXZpb3IuXG4gICAgIC0gW35tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGg6MV0gYWxsb3dzIGxpbWl0aW5nIHRoZSBkZXB0aCB3aGljaFxuICAgICAgIHRyaWdnZXJzIGRlZmVycmFsIG9uIGEgcGVyLWNhbGwtc2l0ZSBiYXNpcy4gVGhpcyBpcyB1c2VkIGJ5XG4gICAgICAgW0x3dC53YWtldXBfbGF0ZXJdLlxuICAgICAtIFt+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVdIGlzIGxpa2VcbiAgICAgICBbfmFsbG93X2RlZmVycmluZzpmYWxzZV0sIHdoaWNoIGlnbm9yZXMgdGhlIGNhbGxiYWNrIHN0YWNrIGRlcHRoLlxuICAgICAgIEhvd2V2ZXIsIHRvIGVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayBpcyB0YWlsLWNhbGxlZCwgTHd0IGRvZXNuJ3QgZXZlblxuICAgICAgIHVwZGF0ZSB0aGUgY2FsbGJhY2sgc3RhY2sgZGVwdGggZm9yIHRoZSBiZW5lZml0IG9mICpvdGhlciogY2FsbGJhY2tcbiAgICAgICBjYWxscy4gSXQganVzdCBibGluZGx5IGNhbGxzIHRoZSBjYWxsYmFjay5cblxuICAgICBTZWUgZGlzY3Vzc2lvbiBvZiBjYWxsYmFjay1jYWxsaW5nIHNlbWFudGljcyBpbjpcblxuICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9pc3N1ZXMvMzI5XG5cbiAgICAgKiBDb250ZXh0XG5cbiAgICAgVGhlIHJlc29sdXRpb24gbG9vcCBlZmZlY3RpdmVseSBoYW5kbGVzIGFsbCBwcm9taXNlcyB0aGF0IGNhbiBiZSByZXNvbHZlZFxuICAgICBpbW1lZGlhdGVseSwgd2l0aG91dCBibG9ja2luZyBvbiBJL08uIEEgY29tcGxldGUgcHJvZ3JhbSB0aGF0IGRvZXMgSS9PXG4gICAgIGNhbGxzIFtMd3RfbWFpbi5ydW5dLiBTZWUgXCJObyBJL09cIiBpbiB0aGUgT3ZlcnZpZXcuICopXG5cblxuXG4gIGxldCBhc3luY19leGNlcHRpb25faG9vayA9XG4gICAgcmVmIChmdW4gZXhuIC0+XG4gICAgICBwcmVycl9zdHJpbmcgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uIFwiO1xuICAgICAgcHJlcnJfc3RyaW5nIChQcmludGV4Yy50b19zdHJpbmcgZXhuKTtcbiAgICAgIHByZXJyX2NoYXIgJ1xcbic7XG4gICAgICBQcmludGV4Yy5wcmludF9iYWNrdHJhY2Ugc3RkZXJyO1xuICAgICAgZmx1c2ggc3RkZXJyO1xuICAgICAgZXhpdCAyKVxuXG4gIGxldCBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIHYgPVxuICAgICgqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNhcmUgaWYgW2ZdIGV2YWx1YXRlcyB0byBhIHByb21pc2UuIEluXG4gICAgICAgcGFydGljdWxhciwgaWYgW2Ygdl0gZXZhbHVhdGVzIHRvIFtwXSBhbmQgW3BdIGlzIGFscmVhZHkgcmVqZWN0ZWQgb3Igd2lsbFxuICAgICAgIGJlIHJlamVjdCBsYXRlciwgaXQgaXMgbm90IHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGlzIGZ1bmN0aW9uIHRvIHBhc3NcbiAgICAgICB0aGUgZXhjZXB0aW9uIHRvIFshYXN5bmNfZXhjZXB0aW9uX2hvb2tdLiAqKVxuICAgIHRyeSBmIHZcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuXG5cblxuICBleGNlcHRpb24gQ2FuY2VsZWRcblxuXG5cbiAgKCogUnVucyB0aGUgY2FsbGJhY2tzIChmb3JtZXJseSkgYXNzb2NpYXRlZCB0byBhIHByb21pc2UuIENhbmNlbCBjYWxsYmFja3MgYXJlXG4gICAgIHJ1biBmaXJzdCwgaWYgdGhlIHByb21pc2Ugd2FzIGNhbmNlbGVkLiBUaGVzZSBhcmUgZm9sbG93ZWQgYnkgcmVndWxhclxuICAgICBjYWxsYmFja3MuXG5cbiAgICAgVGhlIHJlYXNvbiBmb3IgdGhlIFwiZm9ybWVybHlcIiBpcyB0aGF0IHRoZSBwcm9taXNlJ3Mgc3RhdGUgaGFzIGFscmVhZHkgYmVlblxuICAgICBzZXQgdG8gW0Z1bGZpbGxlZCBfXSBvciBbUmVqZWN0ZWQgX10sIHNvIHRoZSBjYWxsYmFja3MgYXJlIG5vIGxvbmdlclxuICAgICByZWFjaGFibGUgdGhyb3VnaCB0aGUgcHJvbWlzZSByZWZlcmVuY2UuIFRoaXMgaXMgd2h5IHRoZSBkaXJlY3QgW2NhbGxiYWNrc11cbiAgICAgcmVjb3JkIG11c3QgYmUgZ2l2ZW4gdG8gdGhpcyBmdW5jdGlvbi4gKilcbiAgbGV0IHJ1bl9jYWxsYmFja3NcbiAgICAgIChjYWxsYmFja3MgOiAnYSBjYWxsYmFja3MpXG4gICAgICAocmVzdWx0IDogJ2EgcmVzb2x2ZWRfc3RhdGUpIDogdW5pdCA9XG5cbiAgICBsZXQgcnVuX2NhbmNlbF9jYWxsYmFja3MgZnMgPVxuICAgICAgbGV0IHJlYyBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgcmVzdCA9XG4gICAgICAgIG1hdGNoIGZzIHdpdGhcbiAgICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPlxuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgKHN0b3JhZ2UsIGYpIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHN0b3JhZ2U7XG4gICAgICAgICAgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKTtcbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGUgLT5cbiAgICAgICAgICBMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGU7XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGZzLCBmcycpIC0+XG4gICAgICAgICAgaXRlcl9jYWxsYmFja19saXN0IGZzIChmcyc6OnJlc3QpXG5cbiAgICAgIGFuZCBpdGVyX2xpc3QgcmVzdCA9XG4gICAgICAgIG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgZnM6OnJlc3QgLT4gaXRlcl9jYWxsYmFja19saXN0IGZzIHJlc3RcblxuICAgICAgaW5cblxuICAgICAgaXRlcl9jYWxsYmFja19saXN0IGZzIFtdXG4gICAgaW5cblxuICAgIGxldCBydW5fcmVndWxhcl9jYWxsYmFja3MgZnMgPVxuICAgICAgbGV0IHJlYyBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgcmVzdCA9XG4gICAgICAgIG1hdGNoIGZzIHdpdGhcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT5cbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgZiAtPlxuICAgICAgICAgIGYgcmVzdWx0O1xuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrXG4gICAgICAgICAgICB7Y29udGVudHMgPSBOb25lfSAtPlxuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrXG4gICAgICAgICAgICB7Y29udGVudHMgPSBTb21lIGZ9IC0+XG4gICAgICAgICAgZiByZXN1bHQ7XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChmcywgZnMnKSAtPlxuICAgICAgICAgIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyAoZnMnOjpyZXN0KVxuXG4gICAgICBhbmQgaXRlcl9saXN0IHJlc3QgPVxuICAgICAgICBtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGZzOjpyZXN0IC0+IGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyByZXN0XG5cbiAgICAgIGluXG5cbiAgICAgIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyBbXVxuICAgIGluXG5cbiAgICAoKiBQYXR0ZXJuIG1hdGNoaW5nIGlzIG11Y2ggZmFzdGVyIHRoYW4gcG9seW1vcnBoaWMgY29tcGFyaXNvbi4gKilcbiAgICBsZXQgaXNfY2FuY2VsZWQgPVxuICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgIHwgUmVqZWN0ZWQgQ2FuY2VsZWQgLT4gdHJ1ZVxuICAgICAgfCBSZWplY3RlZCBfIC0+IGZhbHNlXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBpZiBpc19jYW5jZWxlZCB0aGVuXG4gICAgICBydW5fY2FuY2VsX2NhbGxiYWNrcyBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcztcbiAgICBydW5fcmVndWxhcl9jYWxsYmFja3MgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzXG5cblxuXG4gIGxldCBkZWZhdWx0X21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IDQyXG5cbiAgbGV0IGN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IHJlZiAwXG5cbiAgdHlwZSBkZWZlcnJlZF9jYWxsYmFja3MgPVxuICAgIERlZmVycmVkIDogKCdhIGNhbGxiYWNrcyAqICdhIHJlc29sdmVkX3N0YXRlKSAtPiBkZWZlcnJlZF9jYWxsYmFja3NcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gIGxldCBkZWZlcnJlZF9jYWxsYmFja3MgOiBkZWZlcnJlZF9jYWxsYmFja3MgUXVldWUudCA9IFF1ZXVlLmNyZWF0ZSAoKVxuXG4gICgqIEJlZm9yZSBlbnRlcmluZyBhIHJlc29sdXRpb24gbG9vcCwgaXQgaXMgbmVjZXNzYXJ5IHRvIHRha2UgYSBzbmFwc2hvdCBvZlxuICAgICB0aGUgY3VycmVudCBzdGF0ZSBvZiBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UuIFRoaXMgaXMgYmVjYXVzZSBtYW55IG9mXG4gICAgIHRoZSBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIHJ1biB3aWxsIG1vZGlmeSB0aGUgc3RvcmFnZS4gVGhlIHN0b3JhZ2UgaXNcbiAgICAgcmVzdG9yZWQgdG8gdGhlIHNuYXBzaG90IHdoZW4gdGhlIHJlc29sdXRpb24gbG9vcCBpcyBleGl0ZWQuICopXG4gIGxldCBlbnRlcl9yZXNvbHV0aW9uX2xvb3AgKCkgPVxuICAgIGN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA6PSAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoICsgMTtcbiAgICBsZXQgc3RvcmFnZV9zbmFwc2hvdCA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cbiAgICBzdG9yYWdlX3NuYXBzaG90XG5cbiAgbGV0IGxlYXZlX3Jlc29sdXRpb25fbG9vcCAoc3RvcmFnZV9zbmFwc2hvdCA6IHN0b3JhZ2UpIDogdW5pdCA9XG4gICAgaWYgIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IDEgdGhlbiBiZWdpblxuICAgICAgd2hpbGUgbm90IChRdWV1ZS5pc19lbXB0eSBkZWZlcnJlZF9jYWxsYmFja3MpIGRvXG4gICAgICAgIGxldCBEZWZlcnJlZCAoY2FsbGJhY2tzLCByZXN1bHQpID0gUXVldWUucG9wIGRlZmVycmVkX2NhbGxiYWNrcyBpblxuICAgICAgICBydW5fY2FsbGJhY2tzIGNhbGxiYWNrcyByZXN1bHRcbiAgICAgIGRvbmVcbiAgICBlbmQ7XG4gICAgY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIDo9ICFjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggLSAxO1xuICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzdG9yYWdlX3NuYXBzaG90XG5cbiAgbGV0IHJ1bl9pbl9yZXNvbHV0aW9uX2xvb3AgZiA9XG4gICAgbGV0IHN0b3JhZ2Vfc25hcHNob3QgPSBlbnRlcl9yZXNvbHV0aW9uX2xvb3AgKCkgaW5cbiAgICBsZXQgcmVzdWx0ID0gZiAoKSBpblxuICAgIGxlYXZlX3Jlc29sdXRpb25fbG9vcCBzdG9yYWdlX3NuYXBzaG90O1xuICAgIHJlc3VsdFxuXG4gICgqIFRoaXMgaXMgYmFzaWNhbGx5IGEgaGFjayB0byBmaXggaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2lzc3Vlcy80OC5cbiAgICAgSWYgY3VycmVudGx5IHJlc29sdmluZyBwcm9taXNlcywgaXQgaW1tZWRpYXRlbHkgZXhpdHMgYWxsIHJlY3Vyc2l2ZVxuICAgICBlbnRyaWVzIG9mIHRoZSByZXNvbHV0aW9uIGxvb3AsIGdvZXMgdG8gdGhlIHRvcCBsZXZlbCwgcnVucyBhbnkgZGVmZXJyZWRcbiAgICAgY2FsbGJhY2tzLCBhbmQgZXhpdHMgdGhlIHRvcC1sZXZlbCByZXNvbHV0aW9uIGxvb3AuXG5cbiAgICAgVGhlIG5hbWUgc2hvdWxkIHByb2JhYmx5IGJlIFthYmFvbmRvbl9yZXNvbHV0aW9uX2xvb3BdLiAqKVxuICBsZXQgYWJhbmRvbl93YWtldXBzICgpID1cbiAgICBpZiAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIDw+IDAgdGhlblxuICAgICAgbGVhdmVfcmVzb2x1dGlvbl9sb29wIFN0b3JhZ2VfbWFwLmVtcHR5XG5cblxuXG4gIGxldCBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgID8oYWxsb3dfZGVmZXJyaW5nID0gdHJ1ZSlcbiAgICAgID8obWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoID0gZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGgpXG4gICAgICBjYWxsYmFja3MgcmVzdWx0ID1cblxuICAgIGxldCBzaG91bGRfZGVmZXIgPVxuICAgICAgYWxsb3dfZGVmZXJyaW5nXG4gICAgICAmJiAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoID49IG1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aFxuICAgIGluXG5cbiAgICBpZiBzaG91bGRfZGVmZXIgdGhlblxuICAgICAgUXVldWUucHVzaCAoRGVmZXJyZWQgKGNhbGxiYWNrcywgcmVzdWx0KSkgZGVmZXJyZWRfY2FsbGJhY2tzXG4gICAgZWxzZVxuICAgICAgcnVuX2luX3Jlc29sdXRpb25fbG9vcCAoZnVuICgpIC0+XG4gICAgICAgIHJ1bl9jYWxsYmFja3MgY2FsbGJhY2tzIHJlc3VsdClcblxuICBsZXQgcmVzb2x2ZSA/YWxsb3dfZGVmZXJyaW5nID9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGggcCByZXN1bHQgPVxuICAgIGxldCBQZW5kaW5nIGNhbGxiYWNrcyA9IHAuc3RhdGUgaW5cbiAgICBsZXQgcCA9IHNldF9wcm9taXNlX3N0YXRlIHAgcmVzdWx0IGluXG5cbiAgICBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgID9hbGxvd19kZWZlcnJpbmcgP21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCBjYWxsYmFja3MgcmVzdWx0O1xuXG4gICAgcFxuXG4gIGxldCBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgID8ocnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsID0gZmFsc2UpXG4gICAgICB+Y2FsbGJhY2s6ZlxuICAgICAgfmlmX2RlZmVycmVkID1cblxuICAgIGlmIHJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbCB0aGVuXG4gICAgICBmICgpXG5cbiAgICBlbHNlXG4gICAgICBsZXQgc2hvdWxkX2RlZmVyID1cbiAgICAgICAgIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aFxuICAgICAgICAgID49IGRlZmF1bHRfbWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoXG4gICAgICBpblxuXG4gICAgICBpZiBzaG91bGRfZGVmZXIgdGhlbiBiZWdpblxuICAgICAgICBsZXQgaW1tZWRpYXRlX3Jlc3VsdCwgZGVmZXJyZWRfY2FsbGJhY2ssIGRlZmVycmVkX3Jlc3VsdCA9XG4gICAgICAgICAgaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgbGV0IGRlZmVycmVkX3JlY29yZCA9XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVndWxhcl9jYWxsYmFja3MgPVxuICAgICAgICAgICAgICBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrXG4gICAgICAgICAgICAgICAgZGVmZXJyZWRfY2FsbGJhY2s7XG4gICAgICAgICAgICBjYW5jZWxfY2FsbGJhY2tzID0gQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHk7XG4gICAgICAgICAgICBob3dfdG9fY2FuY2VsID0gTm90X2NhbmNlbGFibGU7XG4gICAgICAgICAgICBjbGVhbnVwc19kZWZlcnJlZCA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIGluXG4gICAgICAgIFF1ZXVlLnB1c2hcbiAgICAgICAgICAoRGVmZXJyZWQgKGRlZmVycmVkX3JlY29yZCwgZGVmZXJyZWRfcmVzdWx0KSkgZGVmZXJyZWRfY2FsbGJhY2tzO1xuICAgICAgICBpbW1lZGlhdGVfcmVzdWx0XG4gICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgcnVuX2luX3Jlc29sdXRpb25fbG9vcCAoZnVuICgpIC0+XG4gICAgICAgICAgZiAoKSlcbmVuZFxuaW5jbHVkZSBSZXNvbHV0aW9uX2xvb3BcblxuXG5cbm1vZHVsZSBSZXNvbHZpbmcgOlxuc2lnXG4gIHZhbCB3YWtldXBfbGF0ZXJfcmVzdWx0IDogJ2EgdSAtPiAoJ2EsIGV4bikgcmVzdWx0IC0+IHVuaXRcbiAgdmFsIHdha2V1cF9sYXRlciA6ICdhIHUgLT4gJ2EgLT4gdW5pdFxuICB2YWwgd2FrZXVwX2xhdGVyX2V4biA6IF8gdSAtPiBleG4gLT4gdW5pdFxuXG4gIHZhbCB3YWtldXBfcmVzdWx0IDogJ2EgdSAtPiAoJ2EsIGV4bikgcmVzdWx0IC0+IHVuaXRcbiAgdmFsIHdha2V1cCA6ICdhIHUgLT4gJ2EgLT4gdW5pdFxuICB2YWwgd2FrZXVwX2V4biA6IF8gdSAtPiBleG4gLT4gdW5pdFxuXG4gIHZhbCBjYW5jZWwgOiAnYSB0IC0+IHVuaXRcbmVuZCA9XG5zdHJ1Y3RcbiAgKCogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGV2aWF0ZXMgZnJvbSB0aGUgXCJpZGVhbFwiIGNhbGxiYWNrIGRlZmVycmFsXG4gICAgIGJlaGF2aW9yOiBpdCBydW5zIGNhbGxiYWNrcyBkaXJlY3RseSBvbiB0aGUgY3VycmVudCBzdGFjay4gSXQgc2hvdWxkXG4gICAgIHRoZXJlZm9yZSBiZSBwb3NzaWJsZSB0byBjYXVzZSBhIHN0YWNrIG92ZXJmbG93IHVzaW5nIHRoaXMgZnVuY3Rpb24uICopXG4gIGxldCB3YWtldXBfZ2VuZXJhbCBhcGlfZnVuY3Rpb25fbmFtZSByIHJlc3VsdCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9yZXNvbHZlciByIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgUmVqZWN0ZWQgQ2FuY2VsZWQgLT5cbiAgICAgICgpXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnIFwiTHd0LiVzXCIgYXBpX2Z1bmN0aW9uX25hbWVcbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZyBcIkx3dC4lc1wiIGFwaV9mdW5jdGlvbl9uYW1lXG5cbiAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgbGV0IHJlc3VsdCA9IHN0YXRlX29mX3Jlc3VsdCByZXN1bHQgaW5cbiAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPSByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgIGlnbm9yZSBwXG5cbiAgbGV0IHdha2V1cF9yZXN1bHQgciByZXN1bHQgPSB3YWtldXBfZ2VuZXJhbCBcIndha2V1cF9yZXN1bHRcIiByIHJlc3VsdFxuICBsZXQgd2FrZXVwIHIgdiA9IHdha2V1cF9nZW5lcmFsIFwid2FrZXVwXCIgciAoT2sgdilcbiAgbGV0IHdha2V1cF9leG4gciBleG4gPSB3YWtldXBfZ2VuZXJhbCBcIndha2V1cF9leG5cIiByIChFcnJvciBleG4pXG5cbiAgbGV0IHdha2V1cF9sYXRlcl9nZW5lcmFsIGFwaV9mdW5jdGlvbl9uYW1lIHIgcmVzdWx0ID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Jlc29sdmVyIHIgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBSZWplY3RlZCBDYW5jZWxlZCAtPlxuICAgICAgKClcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICBQcmludGYua3NwcmludGYgaW52YWxpZF9hcmcgXCJMd3QuJXNcIiBhcGlfZnVuY3Rpb25fbmFtZVxuICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnIFwiTHd0LiVzXCIgYXBpX2Z1bmN0aW9uX25hbWVcblxuICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICBsZXQgcmVzdWx0ID0gc3RhdGVfb2ZfcmVzdWx0IHJlc3VsdCBpblxuICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgIHJlc29sdmUgfm1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aDoxIHAgcmVzdWx0IGluXG4gICAgICBpZ25vcmUgcFxuXG4gIGxldCB3YWtldXBfbGF0ZXJfcmVzdWx0IHIgcmVzdWx0ID1cbiAgICB3YWtldXBfbGF0ZXJfZ2VuZXJhbCBcIndha2V1cF9sYXRlcl9yZXN1bHRcIiByIHJlc3VsdFxuICBsZXQgd2FrZXVwX2xhdGVyIHIgdiA9XG4gICAgd2FrZXVwX2xhdGVyX2dlbmVyYWwgXCJ3YWtldXBfbGF0ZXJcIiByIChPayB2KVxuICBsZXQgd2FrZXVwX2xhdGVyX2V4biByIGV4biA9XG4gICAgd2FrZXVwX2xhdGVyX2dlbmVyYWwgXCJ3YWtldXBfbGF0ZXJfZXhuXCIgciAoRXJyb3IgZXhuKVxuXG5cblxuICB0eXBlIHBhY2tlZF9jYWxsYmFja3MgPVxuICAgIHwgUGFja2VkIDogXyBjYWxsYmFja3MgLT4gcGFja2VkX2NhbGxiYWNrc1xuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgKCogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGV2aWF0ZXMgZnJvbSB0aGUgXCJpZGVhbFwiIGNhbGxiYWNrIGRlZmVycmFsXG4gICAgIGJlaGF2aW9yOiBpdCBydW5zIGNhbGxiYWNrcyBkaXJlY3RseSBvbiB0aGUgY3VycmVudCBzdGFjay4gSXQgc2hvdWxkXG4gICAgIHRoZXJlZm9yZSBiZSBwb3NzaWJsZSB0byBjYXVzZSBhIHN0YWNrIG92ZXJmbG93IHVzaW5nIHRoaXMgZnVuY3Rpb24uICopXG4gIGxldCBjYW5jZWwgcCA9XG4gICAgbGV0IGNhbmNlbGVkX3Jlc3VsdCA9IFJlamVjdGVkIENhbmNlbGVkIGluXG5cbiAgICAoKiBXYWxrcyB0aGUgcHJvbWlzZSBkZXBlbmRlbmN5IGdyYXBoIGJhY2t3YXJkcywgbG9va2luZyBmb3IgY2FuY2VsYWJsZVxuICAgICAgIGluaXRpYWwgcHJvbWlzZXMsIGFuZCBjYW5jZWxzIChvbmx5KSB0aGVtLlxuXG4gICAgICAgRm91bmQgaW5pdGlhbCBwcm9taXNlcyBhcmUgY2FuY2VsZWQgaW1tZWRpYXRlbHksIGFzIHRoZXkgYXJlIGZvdW5kLCBieVxuICAgICAgIHNldHRpbmcgdGhlaXIgc3RhdGUgdG8gW1JlamVjdGVkIENhbmNlbGVkXS4gVGhpcyBpcyB0byBwcmV2ZW50IHRoZW0gZnJvbVxuICAgICAgIGJlaW5nIFwiZm91bmQgdHdpY2VcIiBpZiB0aGV5IGFyZSByZWFjaGFibGUgYnkgdHdvIG9yIG1vcmUgZGlzdGluY3QgcGF0aHNcbiAgICAgICB0aHJvdWdoIHRoZSBwcm9taXNlIGRlcGVuZGVuY3kgZ3JhcGguXG5cbiAgICAgICBUaGUgY2FsbGJhY2tzIG9mIHRoZXNlIGluaXRpYWwgcHJvbWlzZXMgYXJlIHRoZW4gcnVuLCBpbiBhIHNlcGFyYXRlXG4gICAgICAgcGhhc2UuIFRoZXNlIGNhbGxiYWNrcyBwcm9wYWdhdGUgY2FuY2VsbGF0aW9uIGZvcndhcmRzIHRvIGFueSBkZXBlbmRlbnRcbiAgICAgICBwcm9taXNlcy4gU2VlIFwiQ2FuY2VsbGF0aW9uXCIgaW4gdGhlIE92ZXJ2aWV3LiAqKVxuICAgIGxldCBwcm9wYWdhdGVfY2FuY2VsIDogKF8sIF8sIF8pIHByb21pc2UgLT4gcGFja2VkX2NhbGxiYWNrcyBsaXN0ID1cbiAgICAgICAgZnVuIHAgLT5cbiAgICAgIGxldCByZWMgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyA6XG4gICAgICAgICAgJ2EgJ3UgJ2MuIHBhY2tlZF9jYWxsYmFja3MgbGlzdCAtPiAoJ2EsICd1LCAnYykgcHJvbWlzZSAtPlxuICAgICAgICAgICAgcGFja2VkX2NhbGxiYWNrcyBsaXN0ID1cbiAgICAgICAgICBmdW4gKHR5cGUgYykgY2FsbGJhY2tzX2FjY3VtdWxhdG9yIChwIDogKF8sIF8sIGMpIHByb21pc2UpIC0+XG5cbiAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgICAgICgqIElmIHRoZSBwcm9taXNlIGlzIG5vdCBzdGlsbCBwZW5kaW5nLCBpdCBjYW4ndCBiZSBjYW5jZWxlZC4gKilcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgIGNhbGxiYWNrc19hY2N1bXVsYXRvclxuICAgICAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICAgICBjYWxsYmFja3NfYWNjdW11bGF0b3JcblxuICAgICAgICB8IFBlbmRpbmcgY2FsbGJhY2tzIC0+XG4gICAgICAgICAgbWF0Y2ggY2FsbGJhY2tzLmhvd190b19jYW5jZWwgd2l0aFxuICAgICAgICAgIHwgTm90X2NhbmNlbGFibGUgLT5cbiAgICAgICAgICAgIGNhbGxiYWNrc19hY2N1bXVsYXRvclxuICAgICAgICAgIHwgQ2FuY2VsX3RoaXNfcHJvbWlzZSAtPlxuICAgICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgICAgIHNldF9wcm9taXNlX3N0YXRlIHAgY2FuY2VsZWRfcmVzdWx0IGluXG4gICAgICAgICAgICBpZ25vcmUgcDtcbiAgICAgICAgICAgIChQYWNrZWQgY2FsbGJhY2tzKTo6Y2FsbGJhY2tzX2FjY3VtdWxhdG9yXG4gICAgICAgICAgfCBQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwJyAtPlxuICAgICAgICAgICAgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyBjYWxsYmFja3NfYWNjdW11bGF0b3IgcCdcbiAgICAgICAgICB8IFByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcyAtPlxuICAgICAgICAgICAgTGlzdC5mb2xkX2xlZnQgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyBjYWxsYmFja3NfYWNjdW11bGF0b3IgcHNcbiAgICAgIGluXG4gICAgICBjYW5jZWxfYW5kX2NvbGxlY3RfY2FsbGJhY2tzIFtdIHBcbiAgICBpblxuXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgY2FsbGJhY2tzID0gcHJvcGFnYXRlX2NhbmNlbCBwIGluXG5cbiAgICBjYWxsYmFja3MgfD4gTGlzdC5pdGVyIChmdW4gKFBhY2tlZCBjYWxsYmFja3MpIC0+XG4gICAgICBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgICAgfmFsbG93X2RlZmVycmluZzpmYWxzZSBjYWxsYmFja3MgY2FuY2VsZWRfcmVzdWx0KVxuZW5kXG5pbmNsdWRlIFJlc29sdmluZ1xuXG5cblxubW9kdWxlIFRyaXZpYWxfcHJvbWlzZXMgOlxuc2lnXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG4gIHZhbCBmYWlsIDogZXhuIC0+IF8gdFxuICB2YWwgb2ZfcmVzdWx0IDogKCdhLCBleG4pIHJlc3VsdCAtPiAnYSB0XG5cbiAgdmFsIHJldHVybl91bml0IDogdW5pdCB0XG4gIHZhbCByZXR1cm5fdHJ1ZSA6IGJvb2wgdFxuICB2YWwgcmV0dXJuX2ZhbHNlIDogYm9vbCB0XG4gIHZhbCByZXR1cm5fbm9uZSA6IF8gb3B0aW9uIHRcbiAgdmFsIHJldHVybl9zb21lIDogJ2EgLT4gJ2Egb3B0aW9uIHRcbiAgdmFsIHJldHVybl9vayA6ICdhIC0+ICgnYSwgXykgcmVzdWx0IHRcbiAgdmFsIHJldHVybl9lcnJvciA6ICdlIC0+IChfLCAnZSkgcmVzdWx0IHRcbiAgdmFsIHJldHVybl9uaWwgOiBfIGxpc3QgdFxuXG4gIHZhbCBmYWlsX3dpdGggOiBzdHJpbmcgLT4gXyB0XG4gIHZhbCBmYWlsX2ludmFsaWRfYXJnIDogc3RyaW5nIC0+IF8gdFxuZW5kID1cbnN0cnVjdFxuICBsZXQgcmV0dXJuIHYgPVxuICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IEZ1bGZpbGxlZCB2fVxuXG4gIGxldCBvZl9yZXN1bHQgcmVzdWx0ID1cbiAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBzdGF0ZV9vZl9yZXN1bHQgcmVzdWx0fVxuXG4gIGxldCBmYWlsIGV4biA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgZXhufVxuXG4gIGxldCByZXR1cm5fdW5pdCA9IHJldHVybiAoKVxuICBsZXQgcmV0dXJuX25vbmUgPSByZXR1cm4gTm9uZVxuICBsZXQgcmV0dXJuX3NvbWUgeCA9IHJldHVybiAoU29tZSB4KVxuICBsZXQgcmV0dXJuX25pbCA9IHJldHVybiBbXVxuICBsZXQgcmV0dXJuX3RydWUgPSByZXR1cm4gdHJ1ZVxuICBsZXQgcmV0dXJuX2ZhbHNlID0gcmV0dXJuIGZhbHNlXG4gIGxldCByZXR1cm5fb2sgeCA9IHJldHVybiAoT2sgeClcbiAgbGV0IHJldHVybl9lcnJvciB4ID0gcmV0dXJuIChFcnJvciB4KVxuXG4gIGxldCBmYWlsX3dpdGggbXNnID1cbiAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBSZWplY3RlZCAoRmFpbHVyZSBtc2cpfVxuXG4gIGxldCBmYWlsX2ludmFsaWRfYXJnIG1zZyA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgKEludmFsaWRfYXJndW1lbnQgbXNnKX1cbmVuZFxuaW5jbHVkZSBUcml2aWFsX3Byb21pc2VzXG5cblxuXG5tb2R1bGUgUGVuZGluZ19wcm9taXNlcyA6XG5zaWdcbiAgKCogSW50ZXJuYWwgKilcbiAgdmFsIG5ld19wZW5kaW5nIDpcbiAgICBob3dfdG9fY2FuY2VsOmhvd190b19jYW5jZWwgLT4gKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlXG4gIHZhbCBwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgOiBfIHQgbGlzdCAtPiBob3dfdG9fY2FuY2VsXG5cbiAgKCogSW5pdGlhbCBwZW5kaW5nIHByb21pc2VzIChwdWJsaWMpICopXG4gIHZhbCB3YWl0IDogdW5pdCAtPiAnYSB0ICogJ2EgdVxuICB2YWwgdGFzayA6IHVuaXQgLT4gJ2EgdCAqICdhIHVcblxuICB2YWwgYWRkX3Rhc2tfciA6ICdhIHUgTHd0X3NlcXVlbmNlLnQgLT4gJ2EgdFxuICB2YWwgYWRkX3Rhc2tfbCA6ICdhIHUgTHd0X3NlcXVlbmNlLnQgLT4gJ2EgdFxuXG4gIHZhbCBwcm90ZWN0ZWQgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIG5vX2NhbmNlbCA6ICdhIHQgLT4gJ2EgdFxuZW5kID1cbnN0cnVjdFxuICBsZXQgbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWwgPVxuICAgIGxldCBzdGF0ZSA9XG4gICAgICBQZW5kaW5nIHtcbiAgICAgICAgcmVndWxhcl9jYWxsYmFja3MgPSBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHk7XG4gICAgICAgIGNhbmNlbF9jYWxsYmFja3MgPSBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eTtcbiAgICAgICAgaG93X3RvX2NhbmNlbDtcbiAgICAgICAgY2xlYW51cHNfZGVmZXJyZWQgPSAwO1xuICAgICAgfVxuICAgIGluXG4gICAge3N0YXRlfVxuXG4gIGxldCBwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMgPVxuICAgICgqIFVzaW5nIGEgZGlydHkgY2FzdCBoZXJlIHRvIGF2b2lkIHJlYnVpbGRpbmcgdGhlIGxpc3QgOiggTm90IGJvdGhlcmluZ1xuICAgICAgIHdpdGggdGhlIGludmFyaWFudHMsIGJlY2F1c2UgW1Byb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbF0gcGFja3MgdGhlbSxcbiAgICAgICBhbmQgY29kZSB0aGF0IG1hdGNoZXMgb24gW1Byb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbF0gZG9lc24ndCBjYXJlIGFib3V0XG4gICAgICAgdGhlbSBhbnl3YXkuICopXG4gICAgbGV0IGNhc3RfcHJvbWlzZV9saXN0IDogJ2EgdCBsaXN0IC0+ICgnYSwgXywgXykgcHJvbWlzZSBsaXN0ID0gT2JqLm1hZ2ljIGluXG4gICAgUHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIChjYXN0X3Byb21pc2VfbGlzdCBwcylcblxuXG5cbiAgbGV0IHdhaXQgKCkgPVxuICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Tm90X2NhbmNlbGFibGUgaW5cbiAgICB0b19wdWJsaWNfcHJvbWlzZSBwLCB0b19wdWJsaWNfcmVzb2x2ZXIgcFxuXG4gIGxldCB0YXNrICgpID1cbiAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOkNhbmNlbF90aGlzX3Byb21pc2UgaW5cbiAgICB0b19wdWJsaWNfcHJvbWlzZSBwLCB0b19wdWJsaWNfcmVzb2x2ZXIgcFxuXG5cblxuXG4gIGxldCBjYXN0X3NlcXVlbmNlX25vZGVcbiAgICAgIChub2RlIDogJ2EgdSBMd3Rfc2VxdWVuY2Uubm9kZSlcbiAgICAgIChfYWN0dWFsX2NvbnRlbnQ6KCdhLCAndSwgJ2MpIHByb21pc2UpXG4gICAgICAgIDogKCdhLCAndSwgJ2MpIHByb21pc2UgTHd0X3NlcXVlbmNlLm5vZGUgPVxuICAgIE9iai5tYWdpYyBub2RlXG5cbiAgbGV0IGFkZF90YXNrX3Igc2VxdWVuY2UgPVxuICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Q2FuY2VsX3RoaXNfcHJvbWlzZSBpblxuICAgIGxldCBub2RlID0gTHd0X3NlcXVlbmNlLmFkZF9yICh0b19wdWJsaWNfcmVzb2x2ZXIgcCkgc2VxdWVuY2UgaW5cbiAgICBsZXQgbm9kZSA9IGNhc3Rfc2VxdWVuY2Vfbm9kZSBub2RlIHAgaW5cblxuICAgIGxldCBQZW5kaW5nIGNhbGxiYWNrcyA9IHAuc3RhdGUgaW5cbiAgICBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcyA8LVxuICAgICAgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfcmVtb3ZlX3NlcXVlbmNlX25vZGUgbm9kZTtcblxuICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICBsZXQgYWRkX3Rhc2tfbCBzZXF1ZW5jZSA9XG4gICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpDYW5jZWxfdGhpc19wcm9taXNlIGluXG4gICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX2wgKHRvX3B1YmxpY19yZXNvbHZlciBwKSBzZXF1ZW5jZSBpblxuICAgIGxldCBub2RlID0gY2FzdF9zZXF1ZW5jZV9ub2RlIG5vZGUgcCBpblxuXG4gICAgbGV0IFBlbmRpbmcgY2FsbGJhY2tzID0gcC5zdGF0ZSBpblxuICAgIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzIDwtXG4gICAgICBDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSBub2RlO1xuXG4gICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG5cblxuICBsZXQgcHJvdGVjdGVkIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwX2ludGVybmFsID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcF9pbnRlcm5hbCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT4gcFxuICAgIHwgUmVqZWN0ZWQgXyAtPiBwXG5cbiAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgbGV0IHAnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Q2FuY2VsX3RoaXNfcHJvbWlzZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnID0gbWF5X25vd19iZV9wcm94eSBwJyBpblxuICAgICAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHAnIGluXG4gICAgICAgICgqIEluIHRoaXMgY2FsbGJhY2ssIFtwJ10gd2lsbCBlaXRoZXIgc3RpbGwgaXRzZWxmIGJlIHBlbmRpbmcsIG9yIGl0XG4gICAgICAgICAgIHdpbGwgaGF2ZSBiZWNvbWUgYSBwcm94eSBmb3IgYSBwZW5kaW5nIHByb21pc2UuIFRoZSByZWFzb25pbmcgZm9yXG4gICAgICAgICAgIHRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIGluIHRoZSBjb21tZW50IGF0IFttYXlfbm93X2JlX3Byb3h5XS4gVGhlXG4gICAgICAgICAgIGRpZmZlcmVuY2VzIGFyZTpcblxuICAgICAgICAgICAtIFtwJ10gKmlzKiBhbiBpbml0aWFsIHByb21pc2UsIHNvIGl0ICpjYW4qIGdldCBjYW5jZWxlZC4gSG93ZXZlciwgaWZcbiAgICAgICAgICAgICBpdCBkb2VzLCB0aGUgW29uX2NhbmNlbF0gaGFuZGxlciBpbnN0YWxsZWQgYmVsb3cgd2lsbCByZW1vdmUgdGhpc1xuICAgICAgICAgICAgIGNhbGxiYWNrLlxuICAgICAgICAgICAtIFtwJ10gbmV2ZXIgZ2V0cyBwYXNzZWQgdG8gW21ha2VfaW50b19wcm94eV0sIHRoZSBvbmx5IGVmZmVjdCBvZlxuICAgICAgICAgICAgIHdoaWNoIGlzIHRoYXQgaXQgY2Fubm90IGJlIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgYW5vdGhlclxuICAgICAgICAgICAgIChwcm94eSkgcHJvbWlzZS4gU28sIFtwJ10gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSBoZWFkIG9mIGEgY2hhaW4gb2ZcbiAgICAgICAgICAgICBbUHJveHkgX10gbGlua3MsIGFuZCBpdCdzIG5vdCBuZWNlc3NhcnkgdG8gd29ycnkgYWJvdXQgd2hldGhlciB0aGVcbiAgICAgICAgICAgICBpbmR1Y3RpdmUgcmVhc29uaW5nIGF0IFttYXlfbm93X2JlX3Byb3h5XSBhcHBsaWVzLiAqKVxuXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcgcF9yZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHAnXG4gICAgICBpblxuXG4gICAgICBsZXQgcmVtb3ZlX3RoZV9jYWxsYmFjayA9XG4gICAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19hbmRfZ2l2ZV9yZW1vdmVfZnVuY3Rpb25cbiAgICAgICAgICBbcF0gY2FsbGJhY2tcbiAgICAgIGluXG5cbiAgICAgIGxldCBQZW5kaW5nIHAnX2NhbGxiYWNrcyA9IHAnLnN0YXRlIGluXG4gICAgICBhZGRfY2FuY2VsX2NhbGxiYWNrIHAnX2NhbGxiYWNrcyByZW1vdmVfdGhlX2NhbGxiYWNrO1xuXG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSBwJ1xuXG4gIGxldCBub19jYW5jZWwgcCA9XG4gICAgbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPiBwXG4gICAgfCBSZWplY3RlZCBfIC0+IHBcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IHAnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Tm90X2NhbmNlbGFibGUgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJyA9IG1heV9ub3dfYmVfcHJveHkgcCcgaW5cbiAgICAgICAgbGV0IHAnID0gdW5kZXJseWluZyBwJyBpblxuICAgICAgICAoKiBJbiB0aGlzIGNhbGxiYWNrLCBbcCddIHdpbGwgZWl0aGVyIHN0aWxsIGl0c2VsZiBiZSBwZW5kaW5nLCBvciBpdFxuICAgICAgICAgICB3aWxsIGhhdmUgYmVjb21lIGEgcHJveHkgZm9yIGEgcGVuZGluZyBwcm9taXNlLiBUaGUgcmVhc29uaW5nIGZvclxuICAgICAgICAgICB0aGlzIGlzIGFzIGluIFtwcm90ZWN0ZWRdIGFuZCBbbWF5X25vd19iZV9wcm94eV0sIGJ1dCBldmVuIHNpbXBsZXIsXG4gICAgICAgICAgIGJlY2F1c2UgW3AnXSBpcyBub3QgY2FuY2VsYWJsZS4gKilcblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJyA9XG4gICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnIHBfcmVzdWx0IGluXG4gICAgICAgIGlnbm9yZSBwJ1xuICAgICAgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHAnXG5lbmRcbmluY2x1ZGUgUGVuZGluZ19wcm9taXNlc1xuXG5cblxubW9kdWxlIFNlcXVlbnRpYWxfY29tcG9zaXRpb24gOlxuc2lnXG4gICgqIE1haW4gaW50ZXJmYWNlIChwdWJsaWMpICopXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICB2YWwgbWFwIDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuICB2YWwgY2F0Y2ggOiAodW5pdCAtPiAnYSB0KSAtPiAoZXhuIC0+ICdhIHQpIC0+ICdhIHRcbiAgdmFsIGZpbmFsaXplIDogKHVuaXQgLT4gJ2EgdCkgLT4gKHVuaXQgLT4gdW5pdCB0KSAtPiAnYSB0XG4gIHZhbCB0cnlfYmluZCA6ICh1bml0IC0+ICdhIHQpIC0+ICgnYSAtPiAnYiB0KSAtPiAoZXhuIC0+ICdiIHQpIC0+ICdiIHRcblxuICAoKiBDYW5jZWwgY2FsbGJhY2tzIChwdWJsaWMpLiAqKVxuICB2YWwgb25fY2FuY2VsIDogJ2EgdCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCogTm9uLXByb21pc2UgY2FsbGJhY2tzIChwdWJsaWMpICopXG4gIHZhbCBvbl9zdWNjZXNzIDogJ2EgdCAtPiAoJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgb25fZmFpbHVyZSA6IF8gdCAtPiAoZXhuIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG9uX3Rlcm1pbmF0aW9uIDogXyB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG9uX2FueSA6ICdhIHQgLT4gKCdhIC0+IHVuaXQpIC0+IChleG4gLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqIEJhY2t0cmFjZSBzdXBwb3J0IChpbnRlcm5hbDsgZm9yIHVzZSBieSB0aGUgUFBYKSAqKVxuICB2YWwgYmFja3RyYWNlX2JpbmQgOlxuICAgIChleG4gLT4gZXhuKSAtPiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG4gIHZhbCBiYWNrdHJhY2VfY2F0Y2ggOlxuICAgIChleG4gLT4gZXhuKSAtPiAodW5pdCAtPiAnYSB0KSAtPiAoZXhuIC0+ICdhIHQpIC0+ICdhIHRcbiAgdmFsIGJhY2t0cmFjZV9maW5hbGl6ZSA6XG4gICAgKGV4biAtPiBleG4pIC0+ICh1bml0IC0+ICdhIHQpIC0+ICh1bml0IC0+IHVuaXQgdCkgLT4gJ2EgdFxuICB2YWwgYmFja3RyYWNlX3RyeV9iaW5kIDpcbiAgICAoZXhuIC0+IGV4bikgLT4gKHVuaXQgLT4gJ2EgdCkgLT4gKCdhIC0+ICdiIHQpIC0+IChleG4gLT4gJ2IgdCkgLT4gJ2IgdFxuZW5kID1cbnN0cnVjdFxuICAoKiBUaGVyZSBhcmUgZml2ZSBwcmltYXJ5IHNlcXVlbnRpYWwgY29tcG9zaXRpb24gZnVuY3Rpb25zOiBbYmluZF0sIFttYXBdLFxuICAgICBbY2F0Y2hdLCBbZmluYWxpemVdLCBhbmQgW3RyeV9iaW5kXS4gT2YgdGhlc2UsIFt0cnlfYmluZF0gaXMgdGhlIG1vc3RcbiAgICAgZ2VuZXJhbCAtLSBhbGwgdGhlIG90aGVycyBjYW4gYmUgaW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgaXQuXG5cbiAgICAgTHd0IGNvbmZsYXRlcyBjb25jdXJyZW5jeSB3aXRoIGVycm9yIHByb3BhZ2F0aW9uLiBJZiBMd3QgZGlkIG5vdCBkbyB0aGlzLFxuICAgICB0aGVyZSB3b3VsZCBiZSBvbmx5IHR3byBwcmltYXJ5IGZ1bmN0aW9uczogW2JpbmRdIGFuZCBbbWFwXSwgYW5kLCBvZiB0aGVzZVxuICAgICB0d28sIFtiaW5kXSBpcyB0aGUgbW9zdCBnZW5lcmFsLiBTaW5jZSBbYmluZF0gaXMgdGhlIG1vc3QgcmVsZXZhbnRcbiAgICAgc3BlY2lmaWNhbGx5IHRvIGNvbmN1cnJlbmN5LCBhbmQgaXMgYWxzbyB0aGUgbW9zdCBmYW1pbGlhciBmdW5jdGlvbiBpbiBMd3QsXG4gICAgIGl0cyBpbXBsZW1lbnRhdGlvbiBzZXJ2ZXMgYXMgYSBraW5kIG9mIFwibW9kZWxcIiBmb3IgdGhlIHJlc3QuIEl0IGlzIHRoZSBtb3N0XG4gICAgIGNvbW1lbnRlZCwgYW5kIGFsbCB0aGUgb3RoZXIgZnVuY3Rpb25zIGZvbGxvdyBhIHNpbWlsYXIgcGF0dGVybiB0byBbYmluZF0uXG5cbiAgICAgRm91ciBvZiB0aGUgcHJpbWFyeSBmdW5jdGlvbnMgaGF2ZSBbYmFja3RyYWNlXypdIHZlcnNpb25zLCB3aGljaCBhcmUgbm90XG4gICAgIHRydWx5IHB1YmxpYywgYW5kIGV4aXN0IHRvIHN1cHBvcnQgdGhlIFBQWC4gW2JhY2t0cmFjZV9tYXBdIGRvZXMgbm90IGV4aXN0XG4gICAgIGJlY2F1c2UgdGhlIFBQWCBkb2VzIG5vdCBuZWVkIGl0LlxuXG4gICAgIFRoZSByZW1haW5pbmcgZm91ciBmdW5jdGlvbnMgaW4gdGhpcyBzZWN0aW9uIGF0dGFjaCBcImxvd2VyLWxldmVsLWlzaFwiXG4gICAgIG5vbi1wcm9taXNlLXByb2R1Y2luZyBjYWxsYmFja3MgdG8gcHJvbWlzZXM6IHRoZXNlIGFyZSB0aGUgW29uXypdXG4gICAgIGZ1bmN0aW9ucy4gT2YgdGhlc2UsIFtvbl9hbnldIGlzIHRoZSBtb3N0IGdlbmVyYWwuIElmIEx3dCBkaWQgbm90IGNvbmZsYXRlXG4gICAgIGNvbmN1cnJlbmN5IHdpdGggZXJyb3IgaGFuZGxpbmcsIHRoZXJlIHdvdWxkIG9ubHkgYmUgb25lOiBbb25fc3VjY2Vzc10uICopXG5cblxuXG4gICgqIE1ha2VzIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSBpbnRvIGEgcHJveHkgb2YgW35vdXRlcl9wcm9taXNlXS4gQWZ0ZXJcbiAgICAgW21ha2VfaW50b19wcm94eV0sIHRoZXNlIHR3byBwcm9taXNlIHJlZmVyZW5jZXMgXCJiZWhhdmUgaWRlbnRpY2FsbHkuXCJcblxuICAgICBOb3RlIHRoYXQgdGhpcyBpcyBub3Qgc3ltbWV0cmljOiBbdXNlcl9wcm92aWRlZF9wcm9taXNlXSBhbHdheXMgYmVjb21lcyB0aGVcbiAgICAgcHJveHkuIFttYWtlX2ludG9fcHJveHldIGlzIGNhbGxlZCBvbmx5IGJ5IFtiaW5kXSBhbmQgc2ltaWxhciBmdW5jdGlvbnMgaW5cbiAgICAgdGhpcyBtb2R1bGUuIFRoaXMgbWVhbnMgdGhhdDpcblxuICAgICAtIHRoZSBvbmx5IHdheSBmb3IgYSBwcm9taXNlIHRvIGJlY29tZSBhIHByb3h5IGlzIGJ5IGJlaW5nIHJldHVybmVkIGZyb21cbiAgICAgICB0aGUgY2FsbGJhY2sgZ2l2ZW4gYnkgdGhlIHVzZXIgdG8gW2JpbmRdLCBvciBhIHNpbWlsYXIgZnVuY3Rpb24sIGFuZFxuICAgICAtIHRoZSBvbmx5IHdheSBmb3IgYSBwcm9taXNlIHRvIGJlY29tZSB1bmRlcmx5aW5nIGZvciBhIHByb21pc2Ugb3RoZXIgdGhhblxuICAgICAgIGl0c2VsZiBpcyB0byBiZSB0aGUgb3V0ZXIgcHJvbWlzZSBvcmlnaW5hbGx5IHJldHVybmVkIHRvIHRoZSB1c2VyIGZyb21cbiAgICAgICBbYmluZF0sIG9yIGEgc2ltaWxhciBmdW5jdGlvbi5cblxuICAgICBUaGVzZSB0d28gZmFjdHMgYXJlIGltcG9ydGFudCBmb3IgcmVhc29uaW5nIGFib3V0IGhvdyBhbmQgd2hpY2ggcHJvbWlzZXNcbiAgICAgY2FuIGJlY29tZSBwcm94aWVzLCB1bmRlcmx5aW5nLCBldGMuOyBpbiBwYXJ0aWN1bGFyLCBpdCBpcyB1c2VkIGluIHRoZVxuICAgICBhcmd1bWVudCBpbiBbbWF5X25vd19iZV9wcm94eV0gZm9yIGNvcnJlY3QgcHJlZGljdGlvbnMgYWJvdXQgc3RhdGUgY2hhbmdlcy5cblxuICAgICBbfm91dGVyX3Byb21pc2VdIGlzIGFsd2F5cyBhIHBlbmRpbmcgcHJvbWlzZSB3aGVuIFttYWtlX2ludG9fcHJveHldIGlzXG4gICAgIGNhbGxlZDsgZm9yIHRoZSBleHBsYW5hdGlvbiwgc2VlIFttYXlfbm93X2JlX3Byb3h5XSAodGhvdWdoIHRoZSBjYWxsZXIgb2ZcbiAgICAgW21ha2VfaW50b19wcm94eV0gYWx3YXlzIGNhbGxzIFt1bmRlcmx5aW5nXSBmaXJzdCB0byBwYXNzIHRoZSB1bmRlcmx5aW5nXG4gICAgIHBlbmRpbmcgcHJvbWlzZSB0byBbbWFrZV9pbnRvX3Byb3h5XSkuXG5cbiAgICAgVGhlIHJlYXNvbnMgcHJveHlpbmcgaXMgdXNlZCwgaW5zdGVhZCBvZiBhZGRpbmcgYSBjYWxsYmFjayB0b1xuICAgICBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gdG8gcmVzb2x2ZSBbfm91dGVyX3Byb21pc2VdIHdoZW4gdGhlIGZvcm1lclxuICAgICBiZWNvbWVzIHJlc29sdmVkIHByb2JhYmx5IGFyZTpcblxuICAgICAtIFByb21pc2VzIGhhdmUgbW9yZSBiZWhhdmlvcnMgdGhhbiByZXNvbHV0aW9uLiBPbmUgd291bGQgaGF2ZSB0byBhZGQgYVxuICAgICAgIGNhbmNlbGxhdGlvbiBoYW5kbGVyIHRvIFt+b3V0ZXJfcHJvbWlzZV0gdG8gcHJvcGFnYXRlIHRoZSBjYW5jZWxsYXRpb25cbiAgICAgICBiYWNrIHRvIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSwgZm9yIGV4YW1wbGUuIEl0IG1heSBiZSBlYXNpZXIgdG8ganVzdFxuICAgICAgIHRoaW5rIG9mIHRoZW0gYXMgdGhlIHNhbWUgcHJvbWlzZS5cbiAgICAgLSBJZiB1c2luZyBjYWxsYmFja3MsIHJlc29sdmluZyBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gd291bGQgbm90XG4gICAgICAgaW1tZWRpYXRlbHkgcmVzb2x2ZSBbfm91dGVyX3Byb21pc2VdLiBBbm90aGVyIGNhbGxiYWNrIGFkZGVkIHRvXG4gICAgICAgW351c2VyX3Byb3ZpZGVkX3Byb21pc2VdIG1pZ2h0IHNlZSBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gcmVzb2x2ZWQsXG4gICAgICAgYnV0IFt+b3V0ZXJfcHJvbWlzZV0gc3RpbGwgcGVuZGluZywgZGVwZW5kaW5nIG9uIHRoZSBvcmRlciBpbiB3aGljaFxuICAgICAgIGNhbGxiYWNrcyBhcmUgcnVuLiAqKVxuICBsZXQgbWFrZV9pbnRvX3Byb3h5XG4gICAgICAodHlwZSBjKVxuICAgICAgfihvdXRlcl9wcm9taXNlIDogKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlKVxuICAgICAgfih1c2VyX3Byb3ZpZGVkX3Byb21pc2UgOiAoJ2EsIF8sIGMpIHByb21pc2UpXG4gICAgICAgIDogKCdhLCB1bmRlcmx5aW5nLCBjKSBzdGF0ZV9jaGFuZ2VkID1cblxuICAgICgqIFVzaW5nIFtwJ10gYXMgaXQncyB0aGUgbmFtZSB1c2VkIGluc2lkZSBbYmluZF0sIGV0Yy4sIGZvciBwcm9taXNlcyB3aXRoXG4gICAgICAgdGhpcyByb2xlIC0tIFtwJ10gaXMgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIHVzZXIncyBmdW5jdGlvbi4gKilcbiAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHVzZXJfcHJvdmlkZWRfcHJvbWlzZSBpblxuXG4gICAgaWYgaWRlbnRpY2FsIHAnIG91dGVyX3Byb21pc2UgdGhlblxuICAgICAgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJ1xuICAgICAgKCogV2UgcmVhbGx5IHdhbnQgdG8gcmV0dXJuIFtTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIG91dGVyX3Byb21pc2VdLCBidXRcbiAgICAgICAgIHRoZSByZWZlcmVuY2UgdGhyb3VnaCBbcCddIGhhcyB0aGUgcmlnaHQgdHlwZS4gKilcblxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHAnLnN0YXRlIHdpdGhcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIG91dGVyX3Byb21pc2UgcCcuc3RhdGVcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2Ugb3V0ZXJfcHJvbWlzZSBwJy5zdGF0ZVxuXG4gICAgICB8IFBlbmRpbmcgcCdfY2FsbGJhY2tzIC0+XG4gICAgICAgIGxldCBQZW5kaW5nIG91dGVyX2NhbGxiYWNrcyA9IG91dGVyX3Byb21pc2Uuc3RhdGUgaW5cblxuICAgICAgICBtZXJnZV9jYWxsYmFja3MgfmZyb206cCdfY2FsbGJhY2tzIH5pbnRvOm91dGVyX2NhbGxiYWNrcztcbiAgICAgICAgb3V0ZXJfY2FsbGJhY2tzLmhvd190b19jYW5jZWwgPC0gcCdfY2FsbGJhY2tzLmhvd190b19jYW5jZWw7XG5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcgPVxuICAgICAgICAgIHNldF9wcm9taXNlX3N0YXRlIHAnIChQcm94eSBvdXRlcl9wcm9taXNlKSBpblxuICAgICAgICBpZ25vcmUgcCc7XG5cbiAgICAgICAgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBvdXRlcl9wcm9taXNlXG4gICAgICAgICgqIFRoZSBzdGF0ZSBoYXNuJ3QgYWN0dWFsbHkgY2hhbmdlZCwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gd3JhcFxuICAgICAgICAgICBbb3V0ZXJfcHJvbWlzZV0gZm9yIHR5cGUgY2hlY2tpbmcuICopXG5cbiAgICAgICAgKCogVGhlIHN0YXRlIG9mIFtwJ10gbWF5IGluc3RlYWQgaGF2ZSBjaGFuZ2VkIC0tIGl0IG1heSBoYXZlIGJlY29tZSBhXG4gICAgICAgICAgIHByb3h5LiBIb3dldmVyLCBjYWxsZXJzIG9mIFttYWtlX2ludG9fcHJveHldIGRvbid0IGtub3cgaWZcbiAgICAgICAgICAgW3VzZXJfcHJvdmlkZWRfcHJvbWlzZV0gd2FzIGEgcHJveHkgb3Igbm90ICh0aGF0J3Mgd2h5IHdlIGNhbGxcbiAgICAgICAgICAgdW5kZXJseWluZyBvbiBpdCBhdCB0aGUgdG9wIG9mIHRoaXMgZnVuY3Rpb24sIHRvIGdldCBbcCddKS4gV2UgY2FuXG4gICAgICAgICAgIHRoZXJlZm9yZSB0YWtlIGEgZGFuZ2Vyb3VzIHNob3J0Y3V0IGFuZCBub3QgYm90aGVyIHJldHVybmluZyBhIG5ld1xuICAgICAgICAgICByZWZlcmVuY2UgdG8gW3VzZXJfcHJvdmlkZWRfcHJvbWlzZV0gZm9yIHNoYWRvd2luZy4gKilcblxuXG5cbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IGEgbG90IG9mIHRoZSBjb2RlIGJlbG93IGNhbiBwcm9iYWJseSBiZSBkZWR1cGxpY2F0ZWQgaW5cbiAgICAgc29tZSB3YXksIGVzcGVjaWFsbHkgaWYgYXNzdW1pbmcgRmxhbWJkYS4gKilcblxuICBsZXQgYmluZCBwIGYgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgICgqIEluIGNhc2UgW0x3dC5iaW5kXSBuZWVkcyB0byBkZWZlciB0aGUgY2FsbCB0byBbZl0sIHRoaXMgZnVuY3Rpb24gd2lsbCBiZVxuICAgICAgIGNhbGxlZCB0byBjcmVhdGU6XG5cbiAgICAgICAxLiBUaGUgcHJvbWlzZSwgW3AnJ10sIHRoYXQgbXVzdCBiZSByZXR1cm5lZCB0byB0aGUgY2FsbGVyIGltbWVkaWF0ZWx5LlxuICAgICAgIDIuIFRoZSBjYWxsYmFjayB0aGF0IHJlc29sdmVzIFtwJyddLlxuXG4gICAgICAgW0x3dC5iaW5kXSBkZWZlcnMgdGhlIGNhbGwgdG8gW2ZdIGluIHR3byBjaXJjdW1zdGFuY2VzOlxuXG4gICAgICAgMS4gVGhlIHByb21pc2UgW3BdIGlzIHBlbmRpbmcuXG4gICAgICAgMi4gVGhlIHByb21pc2UgW3BdIGlzIGZ1bGZpbGxlZCwgYnV0IHRoZSBjdXJyZW50IGNhbGxiYWNrIGNhbGwgbmVzdGluZ1xuICAgICAgICAgIGRlcHRoIGlzIHN1Y2ggdGhhdCB0aGUgY2FsbCB0byBbZl0gbXVzdCBnbyBpbnRvIHRoZSBjYWxsYmFjayBxdWV1ZSwgaW5cbiAgICAgICAgICBvcmRlciB0byBhdm9pZCBzdGFjayBvdmVyZmxvdy5cblxuICAgICAgTWVjaGFuaXNtICgyKSBpcyBjdXJyZW50bHkgZGlzYWJsZWQuIEl0IG1heSBiZSB1c2VkIGluIGFuIGFsdGVybmF0aXZlIEx3dFxuICAgICAgQVBJLlxuXG4gICAgICBGdW5jdGlvbnMgb3RoZXIgdGhhbiBbTHd0LmJpbmRdIGhhdmUgYW5hbG9nb3VzIGRlZmVycmFsIGJlaGF2aW9yLiAqKVxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cbiAgICAgICgqIFRoZSByZXN1bHQgcHJvbWlzZSBpcyBhIGZyZXNoIHBlbmRpbmcgcHJvbWlzZS5cblxuICAgICAgICAgSW5pdGlhbGx5LCB0cnlpbmcgdG8gY2FuY2VsIHRoaXMgZnJlc2ggcGVuZGluZyBwcm9taXNlIFtwJyddIHdpbGxcbiAgICAgICAgIHByb3BhZ2F0ZSB0aGUgY2FuY2VsbGF0aW9uIGF0dGVtcHQgdG8gW3BdIChiYWNrd2FyZHMgdGhyb3VnaCB0aGVcbiAgICAgICAgIHByb21pc2UgZGVwZW5kZW5jeSBncmFwaCkuIElmL3doZW4gW3BdIGlzIGZ1bGZpbGxlZCwgTHd0IHdpbGwgY2FsbCB0aGVcbiAgICAgICAgIHVzZXIncyBjYWxsYmFjayBbZl0gYmVsb3csIHdoaWNoIHdpbGwgcHJvdmlkZSBhIG5ldyBwcm9taXNlIFtwJ10sIGFuZFxuICAgICAgICAgW3AnXSB3aWxsIGJlY29tZSBhIHByb3h5IG9mIFtwJyddLiBBdCB0aGF0IHBvaW50LCB0cnlpbmcgdG8gY2FuY2VsXG4gICAgICAgICBbcCcnXSB3aWxsIGJlIGVxdWl2YWxlbnQgdG8gdHJ5aW5nIHRvIGNhbmNlbCBbcCddLCBzbyB0aGUgYmVoYXZpb3Igd2lsbFxuICAgICAgICAgZGVwZW5kIG9uIGhvdyB0aGUgdXNlciBvYnRhaW5lZCBbcCddLiAqKVxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGYgdiB3aXRoIGV4blxuICAgICAgICAgICAgd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cbiAgICAgICAgICAoKiBSdW4gdGhlIHVzZXIncyBmdW5jdGlvbiBbZl0uICopXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG4gICAgICAgICAgKCogW3AnJ10gd2FzIGFuIHVuZGVybHlpbmcgcHJvbWlzZSB3aGVuIGl0IHdhcyBjcmVhdGVkIGFib3ZlLCBidXQgaXRcbiAgICAgICAgICAgICBtYXkgaGF2ZSBiZWNvbWUgYSBwcm94eSBieSB0aGUgdGltZSB0aGlzIGNvZGUgaXMgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICAgICAgICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgZWl0aGVyIGFuIHVuZGVybHlpbmcgcGVuZGluZyBwcm9taXNlLCBvciBhXG4gICAgICAgICAgICAgcHJveHkgZm9yIGEgcGVuZGluZyBwcm9taXNlLiBUaGVyZWZvcmUsIFttYXlfbm93X2JlX3Byb3h5XSBwcm9kdWNlc1xuICAgICAgICAgICAgIGEgcmVmZXJlbmNlIHdpdGggdGhlIHJpZ2h0IHR5cGUgdmFyaWFibGVzLiBXZSBpbW1lZGlhdGVseSBnZXRcbiAgICAgICAgICAgICBbcCcnXSdzIGN1cnJlbnQgdW5kZXJseWluZyBwcm9taXNlLiAqKVxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgICAgICAoKiBNYWtlIHRoZSBvdXRlciBwcm9taXNlIFtwJyddIGJlaGF2aW9yYWxseSBpZGVudGljYWwgdG8gdGhlIHByb21pc2VcbiAgICAgICAgICAgICBbcCddIHJldHVybmVkIGJ5IFtmXSBieSBtYWtpbmcgW3AnXSBpbnRvIGEgcHJveHkgb2YgW3AnJ10uICopXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHBfcmVzdWx0IC0+XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcF9yZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBmIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgKHAnJywgY2FsbGJhY2spID0gY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgIHAnJ1xuXG4gIGxldCBiYWNrdHJhY2VfYmluZCBhZGRfbG9jIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGYgdlxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT5cbiAgICAgICAgICAgICAgZmFpbCAoYWRkX2xvYyBleG4pIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIChSZWplY3RlZCAoYWRkX2xvYyBleG4pKSBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYgdilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgKGFkZF9sb2MgZXhuKX1cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgbWFwIGYgcCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcnX3Jlc3VsdCA9XG4gICAgICAgICAgICB0cnkgRnVsZmlsbGVkIChmIHYpIHdpdGggZXhuXG4gICAgICAgICAgICB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBSZWplY3RlZCBleG5cbiAgICAgICAgICBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcCcnX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcF9yZXN1bHQgLT5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyBwX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2VcbiAgICAgICAgICAgIHtzdGF0ZSA9XG4gICAgICAgICAgICAgIHRyeSBGdWxmaWxsZWQgKGYgdilcbiAgICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gUmVqZWN0ZWQgZXhufSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPSBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgcCcnXG5cbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuXG4gIGxldCBjYXRjaCBmIGggPVxuICAgIGxldCBwID1cbiAgICAgIHRyeSBmICgpXG4gICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIGFzIHBfcmVzdWx0IC0+XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcF9yZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgaCBleG5cbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgaW5cblxuICAgICAgKHRvX3B1YmxpY19wcm9taXNlIHAnJywgY2FsbGJhY2spXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGggZXhuKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgYmFja3RyYWNlX2NhdGNoIGFkZF9sb2MgZiBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyBhcyBwX3Jlc3VsdCAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIHBfcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGggZXhuXG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgICAgICAgICBmYWlsIChhZGRfbG9jIGV4bilcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCAoYWRkX2xvYyBleG4pKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgdHJ5X2JpbmQgZiBmJyBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBmJyB2XG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBoIGV4blxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBmJyB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGggZXhuKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgYmFja3RyYWNlX3RyeV9iaW5kIGFkZF9sb2MgZiBmJyBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBmJyB2XG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgICAgICAgICBmYWlsIChhZGRfbG9jIGV4bilcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgaCBleG5cbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICAgICAgICAgIGZhaWwgKGFkZF9sb2MgZXhuKVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYnIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCAoYWRkX2xvYyBleG4pKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgZmluYWxpemUgZiBmJyA9XG4gICAgdHJ5X2JpbmQgZlxuICAgICAgKGZ1biB4IC0+IGJpbmQgKGYnICgpKSAoZnVuICgpIC0+IHJldHVybiB4KSlcbiAgICAgIChmdW4gZSAtPiBiaW5kIChmJyAoKSkgKGZ1biAoKSAtPiBmYWlsIGUpKVxuXG4gIGxldCBiYWNrdHJhY2VfZmluYWxpemUgYWRkX2xvYyBmIGYnID1cbiAgICBiYWNrdHJhY2VfdHJ5X2JpbmQgYWRkX2xvYyBmXG4gICAgICAoZnVuIHggLT4gYmluZCAoZicgKCkpIChmdW4gKCkgLT4gcmV0dXJuIHgpKVxuICAgICAgKGZ1biBlIC0+IGJpbmQgKGYnICgpKSAoZnVuICgpIC0+IGZhaWwgKGFkZF9sb2MgZSkpKVxuXG5cblxuICBsZXQgb25fY2FuY2VsIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBSZWplY3RlZCBDYW5jZWxlZCAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgICgoKSwgKGZ1biBfIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgKCkpLCBGdWxmaWxsZWQgKCkpKVxuXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAoKVxuXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcblxuICAgIHwgUGVuZGluZyBjYWxsYmFja3MgLT5cbiAgICAgIGFkZF9jYW5jZWxfY2FsbGJhY2sgY2FsbGJhY2tzIGZcblxuXG5cbiAgbGV0IG9uX3N1Y2Nlc3MgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biByZXN1bHQgLT5cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgdlxuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICgpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IG9uX2ZhaWx1cmUgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biByZXN1bHQgLT5cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIGV4blxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAoKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiBleG4pXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAoKCksIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuICBsZXQgb25fdGVybWluYXRpb24gcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biBfcmVzdWx0IC0+XG4gICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IG9uX2FueSBwIGYgZyA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBmdW4gcmVzdWx0IC0+XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIHZcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGcgZXhuXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBnIGV4bilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuZW5kXG5pbmNsdWRlIFNlcXVlbnRpYWxfY29tcG9zaXRpb25cblxuXG4oKiBUaGlzIGJlbG9uZ3Mgd2l0aCB0aGUgW3Byb3RlY3RlZF0gYW5kIHN1Y2gsIGJ1dCBpdCBkZXBlbmRzIG9uIHByaW1pdGl2ZXMgZnJvbVxuICAgW1NlcXVlbnRpYWxfY29tcG9zaXRpb25dLiAqKVxubGV0IHdyYXBfaW5fY2FuY2VsYWJsZSBwID1cbiBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuIGxldCBwX3VuZGVybHlpbmcgPSB1bmRlcmx5aW5nIHBfaW50ZXJuYWwgaW5cbiBtYXRjaCBwX3VuZGVybHlpbmcuc3RhdGUgd2l0aFxuIHwgRnVsZmlsbGVkIF8gLT4gcFxuIHwgUmVqZWN0ZWQgXyAtPiBwXG4gfCBQZW5kaW5nIF8gLT5cbiAgIGxldCBwJywgciA9IHRhc2sgKCkgaW5cbiAgIG9uX2NhbmNlbCBwJyAoZnVuICgpIC0+IGNhbmNlbCBwKTtcbiAgIG9uX2FueSBwICh3YWtldXAgcikgKHdha2V1cF9leG4gcik7XG4gICBwJ1xuXG5cbm1vZHVsZSBDb25jdXJyZW50X2NvbXBvc2l0aW9uIDpcbnNpZ1xuICB2YWwgZG9udF93YWl0IDogKHVuaXQgLT4gXyB0KSAtPiAoZXhuIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGFzeW5jIDogKHVuaXQgLT4gXyB0KSAtPiB1bml0XG4gIHZhbCBpZ25vcmVfcmVzdWx0IDogXyB0IC0+IHVuaXRcblxuICB2YWwgYm90aCA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuICB2YWwgam9pbiA6IHVuaXQgdCBsaXN0IC0+IHVuaXQgdFxuICB2YWwgYWxsIDogKCdhIHQpIGxpc3QgLT4gKCdhIGxpc3QpIHRcblxuICB2YWwgY2hvb3NlIDogJ2EgdCBsaXN0IC0+ICdhIHRcbiAgdmFsIHBpY2sgOiAnYSB0IGxpc3QgLT4gJ2EgdFxuXG4gIHZhbCBuY2hvb3NlIDogJ2EgdCBsaXN0IC0+ICdhIGxpc3QgdFxuICB2YWwgbnBpY2sgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG5cbiAgdmFsIG5jaG9vc2Vfc3BsaXQgOiAnYSB0IGxpc3QgLT4gKCdhIGxpc3QgKiAnYSB0IGxpc3QpIHRcbmVuZCA9XG5zdHJ1Y3RcbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuXG4gIGxldCBkb250X3dhaXQgZiBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgaCBleG5cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgICAoKVxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGggZXhuXG4gICAgICBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuXG4gIGxldCBhc3luYyBmID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuICAgICAgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuICBsZXQgaWdub3JlX3Jlc3VsdCBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICgpXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJlcmFpc2UgZXhuXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayByZXN1bHQgPVxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAgICAgKClcbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICAhYXN5bmNfZXhjZXB0aW9uX2hvb2sgZXhuXG4gICAgICBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuXG5cblxuICBsZXQgam9pbiBwcyA9XG4gICAgbGV0IHAnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgIGxldCBudW1iZXJfcGVuZGluZ19pbl9wcyA9IHJlZiAwIGluXG4gICAgbGV0IGpvaW5fcmVzdWx0ID0gcmVmIChGdWxmaWxsZWQgKCkpIGluXG5cbiAgICAoKiBDYWxsYmFjayBhdHRhY2hlZCB0byBlYWNoIHByb21pc2UgaW4gW3BzXSB0aGF0IGlzIHN0aWxsIHBlbmRpbmcgYXQgdGhlXG4gICAgICAgdGltZSBbam9pbl0gaXMgY2FsbGVkLiAqKVxuICAgIGxldCBjYWxsYmFjayBuZXdfcmVzdWx0ID1cbiAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcgPSBtYXlfbm93X2JlX3Byb3h5IHAnIGluXG5cbiAgICAgIGJlZ2luIG1hdGNoIG5ld19yZXN1bHQgd2l0aFxuICAgICAgfCBGdWxmaWxsZWQgKCkgLT4gKClcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgKCogRm9yIHRoZSBmaXJzdCBwcm9taXNlIGluIFtwc10gdG8gYmUgcmVqZWN0ZWQsIHNldCB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAgICAgW2pvaW5dIHRvIHJlamVjdGVkIHdpdGggdGhlIHNhbWUgZXhjZXB0aW9uLi4gKilcbiAgICAgICAgbWF0Y2ggIWpvaW5fcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgKCkgLT4gam9pbl9yZXN1bHQgOj0gbmV3X3Jlc3VsdFxuICAgICAgICB8IFJlamVjdGVkIF8gLT4gKClcbiAgICAgIGVuZDtcblxuICAgICAgKCogSW4gYWxsIGNhc2VzLCBkZWNyZW1lbnQgdGhlIG51bWJlciBvZiBwcm9taXNlcyBzdGlsbCBwZW5kaW5nLCBhbmRcbiAgICAgICAgIHJlc29sdmUgdGhlIFtqb2luXSBvbmNlIGFsbCBwcm9taXNlcyByZXNvbHZlLiAqKVxuICAgICAgbnVtYmVyX3BlbmRpbmdfaW5fcHMgOj0gIW51bWJlcl9wZW5kaW5nX2luX3BzIC0gMTtcbiAgICAgIGlmICFudW1iZXJfcGVuZGluZ19pbl9wcyA9IDAgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHAnIGluXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgKHVuZGVybHlpbmcgcCcpICFqb2luX3Jlc3VsdCBpblxuICAgICAgICBpZ25vcmUgcCdcbiAgICAgIGVuZFxuICAgIGluXG5cbiAgICAoKiBBdHRhY2ggdGhlIGFib3ZlIGNhbGxiYWNrLiBTaW11bHRhbmVvdXNseSBjb3VudCBob3cgbWFueSBwZW5kaW5nIHByb21pc2VzXG4gICAgICAgdGhlcmUgYXJlIGluIFtwc10gKGluaXRpYWxseSkuIElmIHRoYXQgbnVtYmVyIGlzIHplcm8sIHRoZSBbam9pbl0gbXVzdFxuICAgICAgIHJlc29sdmUgaW1tZWRpYXRlbHkuICopXG4gICAgbGV0IHJlYyBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwcyA9XG4gICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGlmICFudW1iZXJfcGVuZGluZ19pbl9wcyA9IDAgdGhlblxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9ICFqb2luX3Jlc3VsdH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHAnXG5cbiAgICAgIHwgcDo6cHMgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgICAgIG51bWJlcl9wZW5kaW5nX2luX3BzIDo9ICFudW1iZXJfcGVuZGluZ19pbl9wcyArIDE7XG4gICAgICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgICAgICBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyBwX3Jlc3VsdCAtPlxuICAgICAgICAgICgqIEFzIGluIHRoZSBjYWxsYmFjayBhYm92ZSwgYnV0IGZvciBhbHJlYWR5LXJlc29sdmVkIHByb21pc2VzIGluXG4gICAgICAgICAgICAgW3BzXTogcmVqZWN0IHRoZSBbam9pbl0gd2l0aCB0aGUgc2FtZSBleGNlcHRpb24gYXMgaW4gdGhlIGZpcnN0XG4gICAgICAgICAgICAgcmVqZWN0ZWQgcHJvbWlzZSBmb3VuZC4gW2pvaW5dIHN0aWxsIHdhaXRzIGZvciBhbnkgcGVuZGluZyBwcm9taXNlc1xuICAgICAgICAgICAgIGJlZm9yZSBhY3R1YWxseSByZXNvbHZpbmcsIHRob3VnaC4gKilcbiAgICAgICAgICBiZWdpbiBtYXRjaCAham9pbl9yZXN1bHQgd2l0aFxuICAgICAgICAgIHwgRnVsZmlsbGVkICgpIC0+IGpvaW5fcmVzdWx0IDo9IHBfcmVzdWx0O1xuICAgICAgICAgIHwgUmVqZWN0ZWQgXyAtPiAoKVxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwc1xuXG4gICAgICAgIHwgRnVsZmlsbGVkICgpIC0+XG4gICAgICAgICAgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHNcbiAgICBpblxuXG4gICAgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHNcblxuICAoKiB0aGlzIGlzIDMgd29yZHMsIHNtYWxsZXIgdGhhbiB0aGUgMiB0aW1lcyAyIHdvcmRzIGEgcGFpciBvZiByZWZlcmVuY2VzXG4gICAgIHdvdWxkIHRha2UuICopXG4gIHR5cGUgKCdhLCdiKSBwYWlyID0ge1xuICAgIG11dGFibGUgeDE6ICdhIG9wdGlvbjtcbiAgICBtdXRhYmxlIHgyOiAnYiBvcHRpb247XG4gIH1cblxuICBsZXQgYm90aCBwMSBwMiA9XG4gICAgbGV0IHBhaXIgPSB7eDEgPSBOb25lOyB4MiA9IE5vbmV9IGluXG4gICAgbGV0IHAxJyA9IGJpbmQgcDEgKGZ1biB2IC0+IHBhaXIueDEgPC0gU29tZSB2OyByZXR1cm5fdW5pdCkgaW5cbiAgICBsZXQgcDInID0gYmluZCBwMiAoZnVuIHYgLT4gcGFpci54MiA8LSBTb21lIHY7IHJldHVybl91bml0KSBpblxuICAgIGpvaW4gW3AxJzsgcDInXSB8PiBtYXAgKGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggcGFpci54MSwgcGFpci54MiB3aXRoXG4gICAgICB8IFNvbWUgdjEsIFNvbWUgdjIgLT4gdjEsIHYyXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuXG4gIGxldCBhbGwgcHMgPVxuICAgIG1hdGNoIHBzIHdpdGhcbiAgICB8IFtdIC0+IHJldHVybl9uaWxcbiAgICB8IFt4XSAtPiBtYXAgKGZ1biB5IC0+IFt5XSkgeFxuICAgIHwgW3g7IHldIC0+IG1hcCAoZnVuICh4LCB5KSAtPiBbeDsgeV0pIChib3RoIHggeSlcbiAgICB8IF8gLT5cbiAgICAgIGxldCB2cyA9IEFycmF5Lm1ha2UgKExpc3QubGVuZ3RoIHBzKSBOb25lIGluXG4gICAgICBwc1xuICAgICAgfD4gTGlzdC5tYXBpIChmdW4gaW5kZXggcCAtPlxuICAgICAgICBiaW5kIHAgKGZ1biB2IC0+IHZzLihpbmRleCkgPC0gU29tZSB2OyByZXR1cm5fdW5pdCkpXG4gICAgICB8PiBqb2luXG4gICAgICB8PiBtYXAgKGZ1biAoKSAtPlxuICAgICAgICAgIGxldCByZWMgdG9fbGlzdF91bm9wdCBpIGFjYyA9XG4gICAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICAgIGFjY1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBBcnJheS51bnNhZmVfZ2V0IHZzIGkgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICAgIHwgU29tZSB4IC0+IHRvX2xpc3RfdW5vcHQgKGkgLSAxKSAoeDo6YWNjKVxuICAgICAgICAgIGluXG4gICAgICAgICAgdG9fbGlzdF91bm9wdCAoQXJyYXkubGVuZ3RoIHZzIC0gMSkgW10pXG5cbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IHRoZSBuZXh0IGZldyBmdW5jdGlvbnMgYXJlIGhlbHBlcnMgZm9yIFtjaG9vc2VdIGFuZFxuICAgICBbcGlja10uIFBlcmhhcHMgdGhleSBzaG91bGQgYmUgZmFjdG9yZWQgaW50byBzb21lIGtpbmQgb2YgZ2VuZXJpY1xuICAgICBbY2hvb3NlXS9bcGlja10gaW1wbGVtZW50YXRpb24sIHdoaWNoIG1heSBhY3R1YWxseSBiZSBvcHRpbWFsIGFueXdheSB3aXRoXG4gICAgIEZsYW1iZGEuICopXG5cbiAgbGV0IGNvdW50X3Jlc29sdmVkX3Byb21pc2VzX2luIChwcyA6ICdhIHQgbGlzdCkgPVxuICAgIGxldCByZWMgY291bnRfYW5kX2dhdGhlcl9yZWplY3RlZCB0b3RhbCByZWplY3RlZCBwcyA9XG4gICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgIHwgW10gLT4gRXJyb3IgKHRvdGFsLCByZWplY3RlZClcbiAgICAgICB8IHAgOjogcHMgLT5cbiAgICAgICAgICAgIGxldCBJbnRlcm5hbCBxID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgICAgICBtYXRjaCAodW5kZXJseWluZyBxKS5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+IGNvdW50X2FuZF9nYXRoZXJfcmVqZWN0ZWQgdG90YWwgcmVqZWN0ZWQgcHNcbiAgICAgICAgICAgIHwgUmVqZWN0ZWQgXyAtPiBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkICh0b3RhbCArIDEpIChwIDo6IHJlamVjdGVkKSBwc1xuICAgICAgICAgICAgfCBQZW5kaW5nIF8gLT4gY291bnRfYW5kX2dhdGhlcl9yZWplY3RlZCB0b3RhbCByZWplY3RlZCBwc1xuICAgIGluXG4gICAgbGV0IHJlYyBjb3VudF9mdWxmaWxsZWQgdG90YWwgcHMgPVxuICAgICAgIG1hdGNoIHBzIHdpdGhcbiAgICAgICB8IFtdIC0+IE9rIHRvdGFsXG4gICAgICAgfCBwIDo6IHBzIC0+XG4gICAgICAgICAgICBsZXQgSW50ZXJuYWwgcSA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcSkuc3RhdGUgd2l0aFxuICAgICAgICAgICAgfCBGdWxmaWxsZWQgXyAtPiBjb3VudF9mdWxmaWxsZWQgKHRvdGFsICsgMSkgcHNcbiAgICAgICAgICAgIHwgUmVqZWN0ZWQgXyAtPiBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkIDEgW3BdIHBzXG4gICAgICAgICAgICB8IFBlbmRpbmcgXyAtPiBjb3VudF9mdWxmaWxsZWQgdG90YWwgcHNcbiAgICBpblxuICAgIGNvdW50X2Z1bGZpbGxlZCAwIHBzXG5cbiAgKCogRXZhbHVhdGVzIHRvIHRoZSBbbl10aCBwcm9taXNlIGluIFtwc10sIGFtb25nIG9ubHkgdGhvc2UgcHJvbWlzZXMgaW4gW3BzXVxuICAgICB0aGF0IGFyZSByZXNvbHZlZC4gVGhlIGNhbGxlciBpcyBleHBlY3RlZCB0byBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgYXRcbiAgICAgbGVhc3QgW25dIHJlc29sdmVkIHByb21pc2VzIGluIFtwc10uICopXG4gIGxldCByZWMgbnRoX3Jlc29sdmVkIChwcyA6ICdhIHQgbGlzdCkgKG4gOiBpbnQpIDogJ2EgdCA9XG4gICAgbWF0Y2ggcHMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG4gICAgfCBwOjpwcyAtPlxuICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICBtYXRjaCAodW5kZXJseWluZyBwJykuc3RhdGUgd2l0aFxuICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgbnRoX3Jlc29sdmVkIHBzIG5cblxuICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiBwXG4gICAgICAgIGVsc2UgbnRoX3Jlc29sdmVkIHBzIChuIC0gMSlcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiBwXG4gICAgICAgIGVsc2UgbnRoX3Jlc29sdmVkIHBzIChuIC0gMSlcblxuICAoKiBMaWtlIFtudGhfcmVzb2x2ZWRdLCBidXQgY2FuY2VscyBhbGwgcGVuZGluZyBwcm9taXNlcyBmb3VuZCB3aGlsZVxuICAgICB0cmF2ZXJzaW5nIFtwc10uICopXG4gIGxldCByZWMgbnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluZyAocHMgOiAnYSB0IGxpc3QpIChuIDogaW50KSA6ICdhIHQgPVxuICAgIG1hdGNoIHBzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuICAgIHwgcDo6cHMgLT5cbiAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCcpLnN0YXRlIHdpdGhcbiAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgIGNhbmNlbCBwO1xuICAgICAgICBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIG5cblxuICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiAoTGlzdC5pdGVyIGNhbmNlbCBwczsgcClcbiAgICAgICAgZWxzZSBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIChuIC0gMSlcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiAoTGlzdC5pdGVyIGNhbmNlbCBwczsgcClcbiAgICAgICAgZWxzZSBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIChuIC0gMSlcblxuICAoKiBUaGUgUFJORyBzdGF0ZSBpcyBpbml0aWFsaXplZCB3aXRoIGEgY29uc3RhbnQgdG8gbWFrZSBub24tSU8tYmFzZWQgcHJvZ3JhbXNcbiAgICAgZGV0ZXJtaW5pc3RpYy4gKilcbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IGlzIHRoaXMgbmVjZXNzYXJ5PyAqKVxuICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlIFt8fF0pXG5cbiAgbGV0IGNob29zZSBwcyA9XG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ1xuICAgICAgICBcIkx3dC5jaG9vc2UgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIG1hdGNoIGNvdW50X3Jlc29sdmVkX3Byb21pc2VzX2luIHBzIHdpdGhcbiAgICB8IE9rIDAgLT5cbiAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHBcbiAgICAgIGluXG4gICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBPayAxIC0+XG4gICAgICBudGhfcmVzb2x2ZWQgcHMgMFxuXG4gICAgfCBPayBuIC0+XG4gICAgICBudGhfcmVzb2x2ZWQgcHMgKFJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgcHJuZykgbilcblxuICAgIHwgRXJyb3IgKG4sIHBzKSAtPlxuICAgICAgbnRoX3Jlc29sdmVkIHBzIChSYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHBybmcpIG4pXG5cbiAgbGV0IHBpY2sgcHMgPVxuICAgIGlmIHBzID0gW10gdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJMd3QucGljayBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbWF0Y2ggY291bnRfcmVzb2x2ZWRfcHJvbWlzZXNfaW4gcHMgd2l0aFxuICAgIHwgT2sgMCAtPlxuICAgICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDoocHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzKSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPVxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwIHJlc3VsdCBpblxuICAgICAgICBpZ25vcmUgcFxuICAgICAgaW5cbiAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGNhbGxiYWNrO1xuXG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICB8IE9rIDEgLT5cbiAgICAgIG50aF9yZXNvbHZlZF9hbmRfY2FuY2VsX3BlbmRpbmcgcHMgMFxuXG4gICAgfCBPayBuIC0+XG4gICAgICBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzXG4gICAgICAgIChSYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHBybmcpIG4pXG5cbiAgICB8IEVycm9yIChuLCBxcykgLT5cbiAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICBudGhfcmVzb2x2ZWQgcXMgKFJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgcHJuZykgbilcblxuXG5cbiAgKCogSWYgW25jaG9vc2UgcHNdIG9yIFtucGljayBwc10gZm91bmQgYWxsIHByb21pc2VzIGluIFtwc10gcGVuZGluZywgdGhlXG4gICAgIGNhbGxiYWNrIGFkZGVkIHRvIGVhY2ggcHJvbWlzZSBpbiBbcHNdIGV2ZW50dWFsbHkgY2FsbHMgdGhpcyBmdW5jdGlvbi4gVGhlXG4gICAgIGZ1bmN0aW9uIGNvbGxlY3RzIHByb21pc2VzIGluIFtwc10gdGhhdCBoYXZlIGJlY29tZSBmdWxmaWxsZWQsIG9yIGZpbmRzIG9uZVxuICAgICBwcm9taXNlIGluIFtwc10gdGhhdCBoYXMgYmVlbiByZWplY3RlZC4gSXQgdGhlbiByZXR1cm5zIHRoZSBkZXNpcmVkIHN0YXRlXG4gICAgIG9mIHRoZSBmaW5hbCBwcm9taXNlOiBlaXRoZXIgdGhlIGxpc3Qgb2YgcmVzdWx0cyBjb2xsZWN0ZWQsIG9yIHRoZVxuICAgICBleGNlcHRpb24gZm91bmQuICopXG4gIGxldCByZWMgY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZ1xuICAgICAgKHJlc3VsdHMgOiAnYSBsaXN0KVxuICAgICAgKHBzIDogJ2EgdCBsaXN0KSA6XG4gICAgICAgICgnYSBsaXN0IHJlc29sdmVkX3N0YXRlKSA9XG5cbiAgICBtYXRjaCBwcyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgRnVsZmlsbGVkIChMaXN0LnJldiByZXN1bHRzKVxuXG4gICAgfCBwOjpwcyAtPlxuICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICBjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnRlcl9wZW5kaW5nICh2OjpyZXN1bHRzKSBwc1xuXG4gICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgIHJlc3VsdFxuXG4gICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICBjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnRlcl9wZW5kaW5nIHJlc3VsdHMgcHNcblxuICBsZXQgbmNob29zZSBwcyA9XG4gICAgKCogSWYgYXQgbGVhc3Qgb25lIHByb21pc2UgaW4gW3BzXSBpcyBmb3VuZCBmdWxmaWxsZWQsIHRoaXMgZnVuY3Rpb24gaXNcbiAgICAgICBjYWxsZWQgdG8gZmluZCBhbGwgc3VjaCBwcm9taXNlcy4gKilcbiAgICBpZiBwcyA9IFtdIHRoZW5cbiAgICAgIGludmFsaWRfYXJnXG4gICAgICAgIFwiTHd0Lm5jaG9vc2UgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIGxldCByZWMgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIGFjYyBwcyA9XG4gICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIHJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG4gICAgICB8IHA6OnBzIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCAodjo6YWNjKSBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgYWNjIHBzXG4gICAgaW5cblxuICAgICgqIExvb2tzIGZvciBhbHJlYWR5LXJlc29sdmVkIHByb21pc2VzIGluIFtwc10uIElmIG5vbmUgYXJlIGZ1bGZpbGxlZCBvclxuICAgICAgIHJlamVjdGVkLCBhZGRzIGEgY2FsbGJhY2sgdG8gYWxsIHByb21pc2VzIGluIFtwc10gKGFsbCBvZiB3aGljaCBhcmVcbiAgICAgICBwZW5kaW5nKS4gKilcbiAgICBsZXQgcmVjIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzJyA9XG4gICAgICBtYXRjaCBwcycgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICAgICAgbGV0IGNhbGxiYWNrIF9yZXN1bHQgPVxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdGVyX3BlbmRpbmcgW10gcHMgaW5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwIHJlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwXG4gICAgICAgIGluXG4gICAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGNhbGxiYWNrO1xuXG4gICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgW3ZdIHBzXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzXG4gICAgaW5cblxuICAgIGxldCBwID0gY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMgaW5cbiAgICBwXG5cbiAgKCogU2VlIFtuY2hvb3NlXS4gVGhpcyBmdW5jdGlvbiBkaWZmZXJzIG9ubHkgaW4gaGF2aW5nIGFkZGl0aW9uYWwgY2FsbHMgdG9cbiAgICAgW2NhbmNlbF0uICopXG4gIGxldCBucGljayBwcyA9XG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkx3dC5ucGljayBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbGV0IHJlYyBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgYWNjIHBzJyA9XG4gICAgICBtYXRjaCBwcycgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICByZXR1cm4gKExpc3QucmV2IGFjYylcblxuICAgICAgfCBwOjpwcycgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkICh2OjphY2MpIHBzJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBhY2MgcHMnXG4gICAgaW5cblxuICAgIGxldCByZWMgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMnID1cbiAgICAgIG1hdGNoIHBzJyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgICBsZXQgY2FsbGJhY2sgX3Jlc3VsdCA9XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgICBsZXQgcmVzdWx0ID0gY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZyBbXSBwcyBpblxuICAgICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcFxuICAgICAgICBpblxuICAgICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICAgIHwgcDo6cHMnIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBbdl0gcHMnXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMnXG4gICAgaW5cblxuICAgIGxldCBwID0gY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMgaW5cbiAgICBwXG5cblxuXG4gICgqIFNhbWUgZ2VuZXJhbCBwYXR0ZXJuIGFzIFtucGlja10gYW5kIFtuY2hvb3NlXS4gKilcbiAgbGV0IG5jaG9vc2Vfc3BsaXQgcHMgPVxuICAgIGlmIHBzID0gW10gdGhlblxuICAgICAgaW52YWxpZF9hcmdcbiAgICAgICAgXCJMd3QubmNob29zZV9zcGxpdCBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbGV0IHJlYyBmaW5pc2hcbiAgICAgICAgKHRvX3Jlc29sdmUgOiAoJ2EgbGlzdCAqICdhIHQgbGlzdCwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZSlcbiAgICAgICAgKGZ1bGZpbGxlZCA6ICdhIGxpc3QpXG4gICAgICAgIChwZW5kaW5nIDogJ2EgdCBsaXN0KVxuICAgICAgICAocHMgOiAnYSB0IGxpc3QpXG4gICAgICAgICAgOiAoJ2EgbGlzdCAqICdhIHQgbGlzdCwgdW5kZXJseWluZywgcmVzb2x2ZWQpIHN0YXRlX2NoYW5nZWQgPVxuXG4gICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSB0b19yZXNvbHZlXG4gICAgICAgICAgKEZ1bGZpbGxlZCAoTGlzdC5yZXYgZnVsZmlsbGVkLCBMaXN0LnJldiBwZW5kaW5nKSlcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBmaW5pc2ggdG9fcmVzb2x2ZSAodjo6ZnVsZmlsbGVkKSBwZW5kaW5nIHBzXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSB0b19yZXNvbHZlIHJlc3VsdFxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgZmluaXNoIHRvX3Jlc29sdmUgZnVsZmlsbGVkIChwOjpwZW5kaW5nKSBwc1xuICAgIGluXG5cbiAgICBsZXQgcmVjIGNvbGxlY3RfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyByZXN1bHRzIHBlbmRpbmcgcHMgPVxuICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICAoKiBNYWludGFpbmVyJ3Mgbm90ZTogc2hvdWxkIHRoZSBwZW5kaW5nIHByb21pc2UgbGlzdCBhbHNvIGJlXG4gICAgICAgICAgIHJldmVyc2VkPyBJdCBpcyByZXZlcnNlZCBpbiBmaW5pc2guICopXG4gICAgICAgIHJldHVybiAoTGlzdC5yZXYgcmVzdWx0cywgcGVuZGluZylcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgKHY6OnJlc3VsdHMpIHBlbmRpbmcgcHNcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHJlc3VsdHMgKHA6OnBlbmRpbmcpIHBzXG4gICAgaW5cblxuICAgIGxldCByZWMgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcGVuZGluZ19hY2MgcHMnID1cbiAgICAgIG1hdGNoIHBzJyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgICBsZXQgY2FsbGJhY2sgX3Jlc3VsdCA9XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID0gZmluaXNoIHAgW10gW10gcHMgaW5cbiAgICAgICAgICBpZ25vcmUgcFxuICAgICAgICBpblxuICAgICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICAgIHwgcDo6cHMnIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwX2ludGVybmFsID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHBfaW50ZXJuYWwpLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBbdl0gcGVuZGluZ19hY2MgcHMnXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIChwOjpwZW5kaW5nX2FjYykgcHMnXG4gICAgaW5cblxuICAgIGxldCBwID0gY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgW10gcHMgaW5cbiAgICBwXG5lbmRcbmluY2x1ZGUgQ29uY3VycmVudF9jb21wb3NpdGlvblxuXG5cblxubW9kdWxlIE1pc2NlbGxhbmVvdXMgOlxuc2lnXG4gICgqIFByb21pc2Ugc3RhdGUgcXVlcnkgKilcbiAgdHlwZSAnYSBzdGF0ZSA9XG4gICAgfCBSZXR1cm4gb2YgJ2FcbiAgICB8IEZhaWwgb2YgZXhuXG4gICAgfCBTbGVlcFxuXG4gIHZhbCBzdGF0ZSA6ICdhIHQgLT4gJ2Egc3RhdGVcbiAgdmFsIGlzX3NsZWVwaW5nIDogJ2EgdCAtPiBib29sXG4gIHZhbCBkZWJ1Z19zdGF0ZV9pcyA6ICdhIHN0YXRlIC0+ICdhIHQgLT4gYm9vbCB0XG5cbiAgKCogRnVuY3Rpb24gbGlmdGVycyAqKVxuICB2YWwgYXBwbHkgOiAoJ2EgLT4gJ2IgdCkgLT4gJ2EgLT4gJ2IgdFxuXG4gIHZhbCB3cmFwIDpcbiAgICAodW5pdCAtPiAnYikgLT5cbiAgICAnYiB0XG4gIHZhbCB3cmFwMSA6XG4gICAgKCdhMSAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdiIHQpXG4gIHZhbCB3cmFwMiA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2IgdClcbiAgdmFsIHdyYXAzIDpcbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdiIHQpXG4gIHZhbCB3cmFwNCA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdiIHQpXG4gIHZhbCB3cmFwNSA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2IgdClcbiAgdmFsIHdyYXA2IDpcbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdiIHQpXG4gIHZhbCB3cmFwNyA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdhNyAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2E3IC0+ICdiIHQpXG5cbiAgKCogUGF1c2VkIHByb21pc2VzICopXG4gIHZhbCBwYXVzZSA6IHVuaXQgLT4gdW5pdCB0XG4gIHZhbCB3YWtldXBfcGF1c2VkIDogdW5pdCAtPiB1bml0XG4gIHZhbCBwYXVzZWRfY291bnQgOiB1bml0IC0+IGludFxuICB2YWwgcmVnaXN0ZXJfcGF1c2Vfbm90aWZpZXIgOiAoaW50IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGFiYW5kb25fcGF1c2VkIDogdW5pdCAtPiB1bml0XG5cbiAgKCogSW50ZXJuYWwgaW50ZXJmYWNlIGZvciBvdGhlciBtb2R1bGVzIGluIEx3dCAqKVxuICB2YWwgcG9sbCA6ICdhIHQgLT4gJ2Egb3B0aW9uXG5lbmQgPVxuc3RydWN0XG4gIHR5cGUgJ2Egc3RhdGUgPVxuICAgIHwgUmV0dXJuIG9mICdhXG4gICAgfCBGYWlsIG9mIGV4blxuICAgIHwgU2xlZXBcblxuICBleHRlcm5hbCByZXJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmVyYWlzZVwiXG5cbiAgbGV0IHN0YXRlIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT4gUmV0dXJuIHZcbiAgICB8IFJlamVjdGVkIGV4biAtPiBGYWlsIGV4blxuICAgIHwgUGVuZGluZyBfIC0+IFNsZWVwXG5cbiAgbGV0IGRlYnVnX3N0YXRlX2lzIGV4cGVjdGVkX3N0YXRlIHAgPVxuICAgIHJldHVybiAoc3RhdGUgcCA9IGV4cGVjdGVkX3N0YXRlKVxuXG4gIGxldCBpc19zbGVlcGluZyBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+IGZhbHNlXG4gICAgfCBSZWplY3RlZCBfIC0+IGZhbHNlXG4gICAgfCBQZW5kaW5nIF8gLT4gdHJ1ZVxuXG4gIGxldCBwb2xsIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgUmVqZWN0ZWQgZSAtPiByZXJhaXNlIGVcbiAgICB8IEZ1bGZpbGxlZCB2IC0+IFNvbWUgdlxuICAgIHwgUGVuZGluZyBfIC0+IE5vbmVcblxuXG5cbiAgbGV0IGFwcGx5IGYgeCA9XG4gICAgdHJ5IGYgeCB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwIGYgPVxuICAgIHRyeSByZXR1cm4gKGYgKCkpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDEgZiB4MSA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSlcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwMiBmIHgxIHgyID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyKVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXAzIGYgeDEgeDIgeDMgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDQgZiB4MSB4MiB4MyB4NCA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MiB4MyB4NClcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwNSBmIHgxIHgyIHgzIHg0IHg1ID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyIHgzIHg0IHg1KVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXA2IGYgeDEgeDIgeDMgeDQgeDUgeDYgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMgeDQgeDUgeDYpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDcgZiB4MSB4MiB4MyB4NCB4NSB4NiB4NyA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MiB4MyB4NCB4NSB4NiB4NylcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG5cblxuICBsZXQgcGF1c2VfaG9vayA9IHJlZiBpZ25vcmVcblxuICBsZXQgcGF1c2VkID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKVxuICBsZXQgcGF1c2VkX2NvdW50ID0gcmVmIDBcblxuICBsZXQgcGF1c2UgKCkgPVxuICAgIGxldCBwID0gYWRkX3Rhc2tfciBwYXVzZWQgaW5cbiAgICBpbmNyIHBhdXNlZF9jb3VudDtcbiAgICAhcGF1c2VfaG9vayAhcGF1c2VkX2NvdW50O1xuICAgIHBcblxuICBsZXQgd2FrZXVwX3BhdXNlZCAoKSA9XG4gICAgaWYgTHd0X3NlcXVlbmNlLmlzX2VtcHR5IHBhdXNlZCB0aGVuXG4gICAgICBwYXVzZWRfY291bnQgOj0gMFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCB0bXAgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIGluXG4gICAgICBMd3Rfc2VxdWVuY2UudHJhbnNmZXJfciBwYXVzZWQgdG1wO1xuICAgICAgcGF1c2VkX2NvdW50IDo9IDA7XG4gICAgICBMd3Rfc2VxdWVuY2UuaXRlcl9sIChmdW4gciAtPiB3YWtldXAgciAoKSkgdG1wXG4gICAgZW5kXG5cbiAgbGV0IHJlZ2lzdGVyX3BhdXNlX25vdGlmaWVyIGYgPSBwYXVzZV9ob29rIDo9IGZcblxuICBsZXQgYWJhbmRvbl9wYXVzZWQgKCkgPVxuICAgIEx3dF9zZXF1ZW5jZS5jbGVhciBwYXVzZWQ7XG4gICAgcGF1c2VkX2NvdW50IDo9IDBcblxuICBsZXQgcGF1c2VkX2NvdW50ICgpID0gIXBhdXNlZF9jb3VudFxuZW5kXG5pbmNsdWRlIE1pc2NlbGxhbmVvdXNcblxubW9kdWxlIExldF9zeW50YXggPVxuc3RydWN0XG4gIG1vZHVsZSBMZXRfc3ludGF4ID1cbiAgc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgdCB+ZiA9IG1hcCBmIHRcbiAgICBsZXQgYmluZCB0IH5mID0gYmluZCB0IGZcbiAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgIG1vZHVsZSBPcGVuX29uX3JocyA9XG4gICAgc3RydWN0XG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBJbmZpeCA9XG5zdHJ1Y3RcbiAgbGV0ICg+Pj0pID0gYmluZFxuICBsZXQgKD08PCkgZiBwID0gYmluZCBwIGZcbiAgbGV0ICg+fD0pIHAgZiA9IG1hcCBmIHBcbiAgbGV0ICg9fDwpID0gbWFwXG4gIGxldCAoPCY+KSBwIHAnID0gam9pbiBbcDsgcCddXG4gIGxldCAoPD8+KSBwIHAnID0gY2hvb3NlIFtwOyBwJ11cblxuICBpbmNsdWRlIExldF9zeW50YXhcbmVuZFxuaW5jbHVkZSAoIEluZml4IDogbW9kdWxlIHR5cGUgb2YgSW5maXggd2l0aCBtb2R1bGUgTGV0X3N5bnRheCA6PSBMZXRfc3ludGF4LkxldF9zeW50YXggKVxuXG5tb2R1bGUgU3ludGF4ID1cbnN0cnVjdFxuICBsZXQgKGxldCopID0gYmluZFxuICBsZXQgKGFuZCopID0gYm90aFxuXG4gIGxldCAobGV0KykgeCBmID0gbWFwIGYgeFxuICBsZXQgKGFuZCspID0gYm90aFxuZW5kXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbmV4Y2VwdGlvbiBPZmZcblxudHlwZSBvbl9zd2l0Y2ggPSB7XG4gIG11dGFibGUgaG9va3MgOiAodW5pdCAtPiB1bml0IEx3dC50KSBsaXN0O1xufVxuXG50eXBlIHN0YXRlID1cbiAgfCBTdF9vbiBvZiBvbl9zd2l0Y2hcbiAgfCBTdF9vZmZcblxudHlwZSB0ID0geyBtdXRhYmxlIHN0YXRlIDogc3RhdGUgfVxuXG5sZXQgY3JlYXRlICgpID0geyBzdGF0ZSA9IFN0X29uIHsgaG9va3MgPSBbXSB9IH1cblxubGV0IGlzX29uIHN3aXRjaCA9XG4gIG1hdGNoIHN3aXRjaC5zdGF0ZSB3aXRoXG4gIHwgU3Rfb24gXyAtPiB0cnVlXG4gIHwgU3Rfb2ZmIC0+IGZhbHNlXG5cbmxldCBjaGVjayA9IGZ1bmN0aW9uXG4gIHwgU29tZXsgc3RhdGUgPSBTdF9vZmYgfSAtPiByYWlzZSBPZmZcbiAgfCBTb21lIHtzdGF0ZSA9IFN0X29uIF99IHwgTm9uZSAtPiAoKVxuXG5sZXQgYWRkX2hvb2sgc3dpdGNoIGhvb2sgPVxuICBtYXRjaCBzd2l0Y2ggd2l0aFxuICB8IFNvbWUgeyBzdGF0ZSA9IFN0X29uIG9zIH0gLT5cbiAgICBvcy5ob29rcyA8LSBob29rIDo6IG9zLmhvb2tzXG4gIHwgU29tZSB7IHN0YXRlID0gU3Rfb2ZmIH0gLT5cbiAgICByYWlzZSBPZmZcbiAgfCBOb25lIC0+XG4gICAgKClcblxubGV0IGFkZF9ob29rX29yX2V4ZWMgc3dpdGNoIGhvb2sgPVxuICBtYXRjaCBzd2l0Y2ggd2l0aFxuICB8IFNvbWUgeyBzdGF0ZSA9IFN0X29uIG9zIH0gLT5cbiAgICBvcy5ob29rcyA8LSBob29rIDo6IG9zLmhvb2tzO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICB8IFNvbWUgeyBzdGF0ZSA9IFN0X29mZiB9IC0+XG4gICAgaG9vayAoKVxuICB8IE5vbmUgLT5cbiAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IHR1cm5fb2ZmIHN3aXRjaCA9XG4gIG1hdGNoIHN3aXRjaC5zdGF0ZSB3aXRoXG4gIHwgU3Rfb24geyBob29rcyA9IGhvb2tzIH0gLT5cbiAgICBzd2l0Y2guc3RhdGUgPC0gU3Rfb2ZmO1xuICAgIEx3dC5qb2luIChMaXN0Lm1hcCAoZnVuIGhvb2sgLT4gTHd0LmFwcGx5IGhvb2sgKCkpIGhvb2tzKVxuICB8IFN0X29mZiAtPlxuICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgd2l0aF9zd2l0Y2ggZm4gPVxuICBsZXQgc3dpdGNoID0gY3JlYXRlICgpIGluXG4gIEx3dC5maW5hbGl6ZVxuICAgIChmdW4gKCkgLT4gZm4gc3dpdGNoKVxuICAgIChmdW4gKCkgLT4gdHVybl9vZmYgc3dpdGNoKVxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5vcGVuIEx3dC5TeW50YXhcbm9wZW4gTHd0LkluZml4XG5cbnR5cGUgKydhIG5vZGUgPSBOaWwgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZSBMd3QudFxuXG5sZXQgcmV0dXJuX25pbCA9IEx3dC5yZXR1cm4gTmlsXG5cbmxldCBlbXB0eSA6ICdhIHQgPSBmdW4gKCkgLT4gcmV0dXJuX25pbFxuXG5sZXQgcmV0dXJuICh4IDogJ2EpIDogJ2EgdCA9IGZ1biAoKSAtPiBMd3QucmV0dXJuIChDb25zICh4LCBlbXB0eSkpXG5cbmxldCByZXR1cm5fbHd0ICh4IDogJ2EgTHd0LnQpIDogJ2EgdCA9IGZ1biAoKSAtPlxuICAgbGV0KyB4ID0geCBpblxuICAgQ29ucyAoeCwgZW1wdHkpXG5cbmxldCBjb25zIHggdCAoKSA9IEx3dC5yZXR1cm4gKENvbnMgKHgsIHQpKVxuXG5sZXQgY29uc19sd3QgeCB0ICgpID1cbiAgIGxldCsgeCA9IHggaW5cbiAgIENvbnMgKHgsIHQpXG5cbigqIEEgbm90ZSBvbiByZWN1cnNpbmcgdGhyb3VnaCB0aGUgc2VxczpcbiAgIFdoZW4gdHJhdmVyc2luZyBhIHNlcSwgdGhlIGZpcnN0IHRpbWUgd2UgZXZhbHVhdGUgYSBzdXNwZW5kZWQgbm9kZSB3ZSBhcmVcbiAgIG9uIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBiaW5kICg+Pj0pLiBJbiB0aGF0IGNhc2UsIHdlIHVzZSBhcHBseSB0byBjYXB0dXJlXG4gICBleGNlcHRpb25zIGludG8gcHJvbWlzZSByZWplY3Rpb24uXG5cbiAgIFRoaXMgaXMgb25seSBuZWVkZWQgb24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBiZWNhdXNlIHdlIGFyZSB3aXRoaW4gYSBjYWxsYmFja1xuICAgcGFzc2VkIHRvIEx3dCBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIGEgYmluZCBhZnRlciB0aGF0LlxuXG4gICBUaHJvdWdob3V0IHRoaXMgZmlsZSB3ZSB1c2UgdGhlIHNhbWUgY29kZSBwYXR0ZXJuIHRvIGFjaGlldmUgdGhpczogd2VcbiAgIHNoYWRvdyB0aGUgcmVjdXJzaXZlIHRyYXZlcnNhbCBmdW5jdGlvbiB3aXRoIGFuIGlkZW50aWNhbC1idXQtZm9yLXRoZS1hcHBseVxuICAgbm9uLXJlY3Vyc2l2ZSBjb3B5LiAqKVxuXG5sZXQgcmVjIGFwcGVuZCBzZXExIHNlcTIgKCkgPVxuICBzZXExICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiBzZXEyICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMikpXG5sZXQgYXBwZW5kIHNlcTEgc2VxMiAoKSA9XG4gIEx3dC5hcHBseSBzZXExICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiBzZXEyICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMikpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID58PSBmdW5jdGlvblxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIENvbnMgKHgsIG1hcCBmIG5leHQpXG5sZXQgbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+fD0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICBDb25zICh4LCBtYXAgZiBuZXh0KVxuXG5sZXQgcmVjIG1hcF9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCsgeCA9IGYgeCBpblxuICAgICAgQ29ucyAoeCwgbWFwX3MgZiBuZXh0KVxubGV0IG1hcF9zIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBsZXQrIHggPSBmIHggaW5cbiAgICAgIENvbnMgKHgsIG1hcF9zIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gKFxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICB8IFNvbWUgeSAtPiBMd3QucmV0dXJuIChDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dCkgKSlcbmxldCBmaWx0ZXJfbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IChcbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgfCBTb21lIHkgLT4gTHd0LnJldHVybiAoQ29ucyAoeSwgZmlsdGVyX21hcCBmIG5leHQpICkpXG5cbmxldCByZWMgZmlsdGVyX21hcF9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gKFxuICAgICAgbGV0KiB4ID0gZiB4IGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwX3MgZiBuZXh0ICgpXG4gICAgICB8IFNvbWUgeSAtPiBMd3QucmV0dXJuIChDb25zICh5LCBmaWx0ZXJfbWFwX3MgZiBuZXh0KSApKVxubGV0IGZpbHRlcl9tYXBfcyBmIHNlcSAoKSA9XG4gIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiAoXG4gICAgICBsZXQqIHggPSBmIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXBfcyBmIG5leHQgKClcbiAgICAgIHwgU29tZSB5IC0+IEx3dC5yZXR1cm4gKENvbnMgKHksIGZpbHRlcl9tYXBfcyBmIG5leHQpICkpXG5cbmxldCByZWMgZmlsdGVyIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCBvayA9IGYgeCBpblxuICAgICAgaWYgb2sgdGhlbiBMd3QucmV0dXJuIChDb25zICh4LCBmaWx0ZXIgZiBuZXh0KSkgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5sZXQgZmlsdGVyIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBsZXQgb2sgPSBmIHggaW5cbiAgICAgIGlmIG9rIHRoZW4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmlsdGVyIGYgbmV4dCkpIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZpbHRlcl9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCogb2sgPSBmIHggaW5cbiAgICAgIGlmIG9rIHRoZW4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmlsdGVyX3MgZiBuZXh0KSkgZWxzZSBmaWx0ZXJfcyBmIG5leHQgKClcbmxldCBmaWx0ZXJfcyBmIHNlcSAoKSA9XG4gIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0KiBvayA9IGYgeCBpblxuICAgICAgaWYgb2sgdGhlbiBMd3QucmV0dXJuIChDb25zICh4LCBmaWx0ZXJfcyBmIG5leHQpKSBlbHNlIGZpbHRlcl9zIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGZsYXRfbWFwX2FwcCBmIChmIHgpIG5leHQgKClcblxuKCogdGhpcyBpcyBbYXBwZW5kIHNlcSAoZmxhdF9tYXAgZiB0YWlsKV0gKilcbmFuZCBmbGF0X21hcF9hcHAgZiBzZXEgdGFpbCAoKSA9XG4gIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gZmxhdF9tYXAgZiB0YWlsICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmxhdF9tYXBfYXBwIGYgbmV4dCB0YWlsKSlcblxubGV0IGZsYXRfbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBmbGF0X21hcF9hcHAgZiAoZiB4KSBuZXh0ICgpXG5cbmxldCBmb2xkX2xlZnQgZiBhY2Mgc2VxID1cbiAgbGV0IHJlYyBhdXggZiBhY2Mgc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGxldCBhdXggZiBhY2Mgc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBhdXggZiBhY2MgbmV4dFxuICBpblxuICBhdXggZiBhY2Mgc2VxXG5cbmxldCBmb2xkX2xlZnRfcyBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPVxuICAgIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3QucmV0dXJuIGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0KiBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGxldCBhdXggZiBhY2Mgc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQqIGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgYXV4IGYgYWNjIHNlcVxuXG5sZXQgaXRlciBmIHNlcSA9XG4gIGxldCByZWMgYXV4IHNlcSA9XG4gICAgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBhdXggbmV4dFxuICBpblxuICBsZXQgYXV4IHNlcSA9XG4gICAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3QucmV0dXJuX3VuaXRcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgYXV4IHNlcVxuXG5sZXQgaXRlcl9zIGYgc2VxID1cbiAgbGV0IHJlYyBhdXggc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybl91bml0XG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQqICgpID0gZiB4IGluXG4gICAgICAgIGF1eCBuZXh0XG4gIGluXG4gIGxldCBhdXggc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0KiAoKSA9IGYgeCBpblxuICAgICAgICBhdXggbmV4dFxuICBpblxuICBhdXggc2VxXG5cbmxldCBpdGVyX3AgZiBzZXEgPVxuICBsZXQgcmVjIGF1eCBhY2Mgc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LmpvaW4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgcCA9IGYgeCBpblxuICAgICAgICBhdXggKHA6OmFjYykgbmV4dFxuICBpblxuICBsZXQgYXV4IGFjYyBzZXEgPVxuICAgIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LmpvaW4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgcCA9IGYgeCBpblxuICAgICAgICBhdXggKHA6OmFjYykgbmV4dFxuICBpblxuICBhdXggW10gc2VxXG5cbmxldCBpdGVyX24gPyhtYXhfY29uY3VycmVuY3kgPSAxKSBmIHNlcSA9XG4gIGJlZ2luXG4gICAgaWYgbWF4X2NvbmN1cnJlbmN5IDw9IDAgdGhlblxuICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICBQcmludGYuc3ByaW50ZlxuICAgICAgICAgIFwiTHd0X3NlcS5pdGVyX246IG1heF9jb25jdXJyZW5jeSBtdXN0IGJlID4gMCwgJWQgZ2l2ZW5cIlxuICAgICAgICAgIG1heF9jb25jdXJyZW5jeVxuICAgICAgaW5cbiAgICAgIGludmFsaWRfYXJnIG1lc3NhZ2VcbiAgZW5kO1xuICBsZXQgcmVjIGxvb3AgcnVubmluZyBhdmFpbGFibGUgc2VxID1cbiAgICBiZWdpblxuICAgICAgaWYgYXZhaWxhYmxlID4gMCB0aGVuIChcbiAgICAgICAgTHd0LnJldHVybiAocnVubmluZywgYXZhaWxhYmxlKVxuICAgICAgKVxuICAgICAgZWxzZSAoXG4gICAgICAgIEx3dC5uY2hvb3NlX3NwbGl0IHJ1bm5pbmcgPj49IGZ1biAoY29tcGxldGUsIHJ1bm5pbmcpIC0+XG4gICAgICAgIEx3dC5yZXR1cm4gKHJ1bm5pbmcsIGF2YWlsYWJsZSArIExpc3QubGVuZ3RoIGNvbXBsZXRlKVxuICAgICAgKVxuICAgIGVuZCA+Pj0gZnVuIChydW5uaW5nLCBhdmFpbGFibGUpIC0+XG4gICAgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+XG4gICAgICBMd3Quam9pbiBydW5uaW5nXG4gICAgfCBDb25zIChlbHQsIHNlcSkgLT5cbiAgICAgIGxvb3AgKGYgZWx0IDo6IHJ1bm5pbmcpIChwcmVkIGF2YWlsYWJsZSkgc2VxXG4gIGluXG4gICgqIGJlY2F1c2UgdGhlIHJlY3Vyc2lvbiBpcyBtb3JlIGNvbXBsaWNhdGVkIGhlcmUsIHdlIGFwcGx5IHRoZSBzZXEgZGlyZWN0bHkgYXRcbiAgICAgdGhlIGNhbGwtc2l0ZSBpbnN0ZWFkICopXG4gIGxvb3AgW10gbWF4X2NvbmN1cnJlbmN5IChmdW4gKCkgLT4gTHd0LmFwcGx5IHNlcSAoKSlcblxubGV0IHJlYyB1bmZvbGQgZiB1ICgpID1cbiAgbWF0Y2ggZiB1IHdpdGhcbiAgfCBOb25lIC0+IHJldHVybl9uaWxcbiAgfCBTb21lICh4LCB1JykgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgdW5mb2xkIGYgdScpKVxuICB8IGV4Y2VwdGlvbiBleGMgd2hlbiBMd3QuRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhjIC0+IEx3dC5yZXJhaXNlIGV4Y1xuXG5sZXQgcmVjIHVuZm9sZF9sd3QgZiB1ICgpID1cbiAgbGV0KiB4ID0gZiB1IGluXG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gcmV0dXJuX25pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBMd3QucmV0dXJuIChDb25zICh4LCB1bmZvbGRfbHd0IGYgdScpKVxubGV0IHVuZm9sZF9sd3QgZiB1ICgpID1cbiAgbGV0KiB4ID0gTHd0LmFwcGx5IGYgdSBpblxuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHJldHVybl9uaWxcbiAgfCBTb21lICh4LCB1JykgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgdW5mb2xkX2x3dCBmIHUnKSlcblxubGV0IHJlYyBvZl9saXN0IGwgKCkgPVxuICBMd3QucmV0dXJuIChtYXRjaCBsIHdpdGggW10gLT4gTmlsIHwgaCA6OiB0IC0+IENvbnMgKGgsIG9mX2xpc3QgdCkpXG5cbmxldCB0b19saXN0IChzZXEgOiAnYSB0KSA9XG4gIGxldCByZWMgYXV4IGYgc2VxID1cbiAgICBMd3QuYmluZCAoc2VxICgpKSAoZnVuY3Rpb25cbiAgICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gKGYgW10pXG4gICAgICB8IENvbnMgKGgsIHQpIC0+IGF1eCAoZnVuIHggLT4gZiAoaCA6OiB4KSkgdClcbiAgaW5cbiAgYXV4IChmdW4geCAtPiB4KSAoTHd0LmFwcGx5IHNlcSlcblxubGV0IHJlYyBvZl9zZXEgc2VxICgpID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+IHJldHVybl9uaWxcbiAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBMd3QucmV0dXJuIChDb25zICh4LCAob2Zfc2VxIG5leHQpKSlcbiAgfCBleGNlcHRpb24gZXhuIHdoZW4gTHd0LkV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBMd3QucmVyYWlzZSBleG5cblxubGV0IHJlYyBvZl9zZXFfbHd0IChzZXE6ICdhIEx3dC50IFNlcS50KTogJ2EgdCA9IGZ1biAoKSAtPlxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBTZXEuTmlsIC0+IHJldHVybl9uaWxcbiAgICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPlxuICAgICAgIGxldCsgeCA9IHggaW5cbiAgICAgICBsZXQgbmV4dCA9IG9mX3NlcV9sd3QgbmV4dCBpblxuICAgICAgIENvbnMgKHgsIG5leHQpXG5sZXQgb2Zfc2VxX2x3dCAoc2VxOiAnYSBMd3QudCBTZXEudCk6ICdhIHQgPSBmdW4gKCkgLT5cbiAgICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgU2VxLk5pbCAtPiByZXR1cm5fbmlsXG4gICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICBsZXQrIHggPSB4IGluXG4gICAgICAgbGV0IG5leHQgPSBvZl9zZXFfbHd0IG5leHQgaW5cbiAgICAgICBDb25zICh4LCBuZXh0KVxuICAgIHwgZXhjZXB0aW9uIGV4YyB3aGVuIEx3dC5FeGNlcHRpb25fZmlsdGVyLnJ1biBleGMgLT4gTHd0LnJlcmFpc2UgZXhjXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxub3BlbiBMd3QuSW5maXhcblxuZXhjZXB0aW9uIENsb3NlZFxuZXhjZXB0aW9uIEZ1bGxcbmV4Y2VwdGlvbiBFbXB0eVxuXG4oKiBBIG5vZGUgaW4gYSBxdWV1ZSBvZiBwZW5kaW5nIGRhdGEuICopXG50eXBlICdhIG5vZGUgPSB7XG4gIG11dGFibGUgbmV4dCA6ICdhIG5vZGU7XG4gICgqIE5leHQgbm9kZSBpbiB0aGUgcXVldWUuIEZvciB0aGUgbGFzdCBub2RlIGl0IHBvaW50cyB0byBpdHNlbGYuICopXG4gIG11dGFibGUgZGF0YSA6ICdhIG9wdGlvbjtcbiAgKCogRGF0YSBvZiB0aGlzIG5vZGUuIEZvciB0aGUgbGFzdCBub2RlIGl0IGlzIGFsd2F5cyBbTm9uZV0uICopXG59XG5cbigqIE5vdGU6IGEgcXVldWUgZm9yIGFuIGV4aGF1c3RlZCBzdHJlYW0gaXMgcmVwcmVzZW50ZWQgYnkgYSBub2RlXG4gICBjb250YWluaW5nIFtOb25lXSBmb2xsb3dlZCBieSBhIG5vZGUgd2l0aCBpdHNlbGYgYXMgbmV4dCBhbmQgW05vbmVdXG4gICBhcyBkYXRhLiAqKVxuXG5sZXQgbmV3X25vZGUgKCkgPVxuICBsZXQgcmVjIG5vZGUgPSB7IG5leHQgPSBub2RlOyBkYXRhID0gTm9uZSB9IGluXG4gIG5vZGVcblxuKCogVHlwZSBvZiBhIHN0cmVhbSBzb3VyY2UgdXNpbmcgYSBmdW5jdGlvbiB0byBjcmVhdGUgbmV3IGVsZW1lbnRzLiAqKVxudHlwZSAnYSBmcm9tID0ge1xuICBmcm9tX2NyZWF0ZSA6IHVuaXQgLT4gJ2Egb3B0aW9uIEx3dC50O1xuICAoKiBGdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBuZXcgZWxlbWVudHMuICopXG4gIG11dGFibGUgZnJvbV90aHJlYWQgOiB1bml0IEx3dC50O1xuICAoKiBUaHJlYWQgd2hpY2g6XG5cbiAgICAgLSB3YWl0IGZvciB0aGUgdGhyZWFkIHJldHVybmVkIGJ5IHRoZSBsYXN0IGNhbGwgdG8gW2Zyb21fbmV4dF0sXG4gICAgIC0gYWRkIHRoZSBuZXh0IGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUuXG5cbiAgICAgSWYgaXQgaXMgYSBzbGVlcGluZyB0aHJlYWQsIHRoZW4gaXQgbXVzdCBiZSB1c2VkIGluc3RlYWQgb2YgY3JlYXRpbmcgYVxuICAgICBuZXcgb25lIHdpdGggW2Zyb21fY3JlYXRlXS4gKilcbn1cblxuKCogVHlwZSBvZiBhIHN0cmVhbSBzb3VyY2UgZm9yIHB1c2ggc3RyZWFtcy4gKilcbnR5cGUgcHVzaCA9IHtcbiAgbXV0YWJsZSBwdXNoX3NpZ25hbCA6IHVuaXQgTHd0LnQ7XG4gICgqIFRocmVhZCBzaWduYWxlZCB3aGVuIGEgbmV3IGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIHN0cmVhbS4gKilcbiAgbXV0YWJsZSBwdXNoX3dhaXRpbmcgOiBib29sO1xuICAoKiBJcyBhIHRocmVhZCB3YWl0aW5nIG9uIFtwdXNoX3NpZ25hbF0gPyAqKVxuICBtdXRhYmxlIHB1c2hfZXh0ZXJuYWwgOiBPYmoudCBbQG9jYW1sLndhcm5pbmcgXCItNjlcIl07XG4gICgqIFJlZmVyZW5jZSB0byBhbiBleHRlcm5hbCBzb3VyY2UuICopXG59XG5cbigqIFR5cGUgb2YgYSBzdHJlYW0gc291cmNlIGZvciBib3VuZGVkLXB1c2ggc3RyZWFtcy4gKilcbnR5cGUgJ2EgcHVzaF9ib3VuZGVkID0ge1xuICBtdXRhYmxlIHB1c2hiX3NpZ25hbCA6IHVuaXQgTHd0LnQ7XG4gICgqIFRocmVhZCBzaWduYWxlZCB3aGVuIGEgbmV3IGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIHN0cmVhbS4gKilcbiAgbXV0YWJsZSBwdXNoYl93YWl0aW5nIDogYm9vbDtcbiAgKCogSXMgYSB0aHJlYWQgd2FpdGluZyBvbiBbcHVzaGJfc2lnbmFsXSA/ICopXG4gIG11dGFibGUgcHVzaGJfc2l6ZSA6IGludDtcbiAgKCogU2l6ZSBvZiB0aGUgcXVldWUuICopXG4gIG11dGFibGUgcHVzaGJfY291bnQgOiBpbnQ7XG4gICgqIEN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwdXNoYl9wZW5kaW5nIDogJ2Egb3B0aW9uO1xuICAoKiBUaGUgbmV4dCBlbGVtZW50IHRvIHB1c2ggaWYgYSB0aHJlYWQgYmxvY2tlZCBvbiBwdXNoLiBXZSBzdG9yZSBpdFxuICAgICBoZXJlIHRvIGJlIHN1cmUgaXQgd2lsbCBiZSB0aGUgZmlyc3QgZWxlbWVudCB0byBiZSBhZGRlZCB3aGVuXG4gICAgIHNwYWNlIGJlY29tZXMgYXZhaWxhYmxlLiAqKVxuICBtdXRhYmxlIHB1c2hiX3B1c2hfd2FpdGVyIDogdW5pdCBMd3QudDtcbiAgbXV0YWJsZSBwdXNoYl9wdXNoX3dha2VuZXIgOiB1bml0IEx3dC51O1xuICAoKiBUaHJlYWQgYmxvY2tlZCBvbiBwdXNoLiAqKVxuICBtdXRhYmxlIHB1c2hiX2V4dGVybmFsIDogT2JqLnQgW0BvY2FtbC53YXJuaW5nIFwiLTY5XCJdO1xuICAoKiBSZWZlcmVuY2UgdG8gYW4gZXh0ZXJuYWwgc291cmNlLiAqKVxufVxuXG4oKiBTb3VyY2Ugb2YgYSBzdHJlYW0uICopXG50eXBlICdhIHNvdXJjZSA9XG4gIHwgRnJvbSBvZiAnYSBmcm9tXG4gIHwgRnJvbV9kaXJlY3Qgb2YgKHVuaXQgLT4gJ2Egb3B0aW9uKVxuICB8IFB1c2ggb2YgcHVzaFxuICB8IFB1c2hfYm91bmRlZCBvZiAnYSBwdXNoX2JvdW5kZWRcblxudHlwZSAnYSB0ID0ge1xuICBzb3VyY2UgOiAnYSBzb3VyY2U7XG4gICgqIFRoZSBzb3VyY2Ugb2YgdGhlIHN0cmVhbS4gKilcbiAgY2xvc2UgOiB1bml0IEx3dC51O1xuICAoKiBBIHdha2VuZXIgZm9yIGEgdGhyZWFkIHRoYXQgc2xlZXBzIHVudGlsIHRoZSBzdHJlYW0gaXMgY2xvc2VkLiAqKVxuICBjbG9zZWQgOiB1bml0IEx3dC50O1xuICAoKiBBIHdhaXRlciBmb3IgYSB0aHJlYWQgdGhhdCBzbGVlcHMgdW50aWwgdGhlIHN0cmVhbSBpcyBjbG9zZWQuICopXG4gIG11dGFibGUgbm9kZSA6ICdhIG5vZGU7XG4gICgqIFBvaW50ZXIgdG8gZmlyc3QgcGVuZGluZyBlbGVtZW50LCBvciB0byBbbGFzdF0gaWYgdGhlcmUgaXMgbm9cbiAgICAgcGVuZGluZyBlbGVtZW50LiAqKVxuICBsYXN0IDogJ2Egbm9kZSByZWY7XG4gICgqIE5vZGUgbWFya2luZyB0aGUgZW5kIG9mIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIGVsZW1lbnRzLiAqKVxufVxuXG5jbGFzcyB0eXBlIFsnYV0gYm91bmRlZF9wdXNoID0gb2JqZWN0XG4gIG1ldGhvZCBzaXplIDogaW50XG4gIG1ldGhvZCByZXNpemUgOiBpbnQgLT4gdW5pdFxuICBtZXRob2QgcHVzaCA6ICdhIC0+IHVuaXQgTHd0LnRcbiAgbWV0aG9kIGNsb3NlIDogdW5pdFxuICBtZXRob2QgY291bnQgOiBpbnRcbiAgbWV0aG9kIGJsb2NrZWQgOiBib29sXG4gIG1ldGhvZCBjbG9zZWQgOiBib29sXG4gIG1ldGhvZCBzZXRfcmVmZXJlbmNlIDogJ2EuICdhIC0+IHVuaXRcbmVuZFxuXG4oKiBUaGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGNsb25lcyBpcyB0aGUgcG9pbnRlciB0byB0aGUgZmlyc3RcbiAgIHBlbmRpbmcgZWxlbWVudC4gKilcbmxldCBjbG9uZSBzID1cbiAgKG1hdGNoIHMuc291cmNlIHdpdGhcbiAgIHwgUHVzaF9ib3VuZGVkIF8gLT4gaW52YWxpZF9hcmcgXCJMd3Rfc3RyZWFtLmNsb25lXCJcbiAgIHwgRnJvbSBfIHwgRnJvbV9kaXJlY3QgXyB8IFB1c2ggXyAtPiAoKSk7XG4gIHtcbiAgICBzb3VyY2UgPSBzLnNvdXJjZTtcbiAgICBjbG9zZSA9IHMuY2xvc2U7XG4gICAgY2xvc2VkID0gcy5jbG9zZWQ7XG4gICAgbm9kZSA9IHMubm9kZTtcbiAgICBsYXN0ID0gcy5sYXN0O1xuICB9XG5cbmxldCBmcm9tX3NvdXJjZSBzb3VyY2UgPVxuICBsZXQgbm9kZSA9IG5ld19ub2RlICgpIGluXG4gIGxldCBjbG9zZWQsIGNsb3NlID0gTHd0LndhaXQgKCkgaW5cbiAgeyBzb3VyY2UgOyBjbG9zZSA7IGNsb3NlZCA7IG5vZGUgOyBsYXN0ID0gcmVmIG5vZGUgfVxuXG5sZXQgZnJvbSBmID1cbiAgZnJvbV9zb3VyY2UgKEZyb20geyBmcm9tX2NyZWF0ZSA9IGY7IGZyb21fdGhyZWFkID0gTHd0LnJldHVybl91bml0IH0pXG5cbmxldCBmcm9tX2RpcmVjdCBmID1cbiAgZnJvbV9zb3VyY2UgKEZyb21fZGlyZWN0IGYpXG5cbmxldCBjbG9zZWQgcyA9IHMuY2xvc2VkXG5cbmxldCBpc19jbG9zZWQgcyA9XG4gIG5vdCAoTHd0LmlzX3NsZWVwaW5nIChjbG9zZWQgcykpXG5cbmxldCBlbnF1ZXVlJyBlIGxhc3QgPVxuICBsZXQgbm9kZSA9ICFsYXN0XG4gIGFuZCBuZXdfbGFzdCA9IG5ld19ub2RlICgpIGluXG4gIG5vZGUuZGF0YSA8LSBlO1xuICBub2RlLm5leHQgPC0gbmV3X2xhc3Q7XG4gIGxhc3QgOj0gbmV3X2xhc3RcblxubGV0IGVucXVldWUgZSBzID1cbiAgZW5xdWV1ZScgZSBzLmxhc3RcblxubGV0IGNyZWF0ZV93aXRoX3JlZmVyZW5jZSAoKSA9XG4gICgqIENyZWF0ZSB0aGUgc291cmNlIGZvciBub3RpZmljYXRpb25zIG9mIG5ldyBlbGVtZW50cy4gKilcbiAgbGV0IHNvdXJjZSwgcHVzaF9zaWduYWxfcmVzb2x2ZXIgPVxuICAgIGxldCBwdXNoX3NpZ25hbCwgcHVzaF9zaWduYWxfcmVzb2x2ZXIgPSBMd3Qud2FpdCAoKSBpblxuICAgICh7IHB1c2hfc2lnbmFsO1xuICAgICAgIHB1c2hfd2FpdGluZyA9IGZhbHNlO1xuICAgICAgIHB1c2hfZXh0ZXJuYWwgPSBPYmoucmVwciAoKSB9LFxuICAgICByZWYgcHVzaF9zaWduYWxfcmVzb2x2ZXIpXG4gIGluXG4gIGxldCB0ID0gZnJvbV9zb3VyY2UgKFB1c2ggc291cmNlKSBpblxuICAoKiBbcHVzaF0gc2hvdWxkIG5vdCBjbG9zZSBvdmVyIFt0XSBzbyB0aGF0IGl0IGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZCBldmVuXG4gICAqIHRoZXJlIGFyZSBzdGlsbCByZWZlcmVuY2VzIHRvIFtwdXNoXS4gVW5wYWNrIGFsbCB0aGUgY29tcG9uZW50cyBvZiBbdF1cbiAgICogdGhhdCBbcHVzaF0gbmVlZHMgYW5kIHJlZmVyZW5jZSB0aG9zZSBpZGVudGlmaWVycyBpbnN0ZWFkLiAqKVxuICBsZXQgY2xvc2UgPSB0LmNsb3NlIGFuZCBjbG9zZWQgPSB0LmNsb3NlZCBhbmQgbGFzdCA9IHQubGFzdCBpblxuICAoKiBUaGUgcHVzaCBmdW5jdGlvbi4gSXQgZG9lcyBub3Qga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3RyZWFtLiAqKVxuICBsZXQgcHVzaCB4ID1cbiAgICBpZiBub3QgKEx3dC5pc19zbGVlcGluZyBjbG9zZWQpIHRoZW4gcmFpc2UgQ2xvc2VkO1xuICAgICgqIFB1c2ggdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgcXVldWUuICopXG4gICAgZW5xdWV1ZScgeCBsYXN0O1xuICAgICgqIFNlbmQgYSBzaWduYWwgaWYgYXQgbGVhc3Qgb25lIHRocmVhZCBpcyB3YWl0aW5nIGZvciBhIG5ld1xuICAgICAgIGVsZW1lbnQuICopXG4gICAgaWYgc291cmNlLnB1c2hfd2FpdGluZyB0aGVuIGJlZ2luXG4gICAgICBzb3VyY2UucHVzaF93YWl0aW5nIDwtIGZhbHNlO1xuICAgICAgKCogVXBkYXRlIHRocmVhZHMuICopXG4gICAgICBsZXQgb2xkX3B1c2hfc2lnbmFsX3Jlc29sdmVyID0gIXB1c2hfc2lnbmFsX3Jlc29sdmVyIGluXG4gICAgICBsZXQgbmV3X3dhaXRlciwgbmV3X3B1c2hfc2lnbmFsX3Jlc29sdmVyID0gTHd0LndhaXQgKCkgaW5cbiAgICAgIHNvdXJjZS5wdXNoX3NpZ25hbCA8LSBuZXdfd2FpdGVyO1xuICAgICAgcHVzaF9zaWduYWxfcmVzb2x2ZXIgOj0gbmV3X3B1c2hfc2lnbmFsX3Jlc29sdmVyO1xuICAgICAgKCogU2lnbmFsIHRoYXQgYSBuZXcgdmFsdWUgaGFzIGJlZW4gcmVjZWl2ZWQuICopXG4gICAgICBMd3Qud2FrZXVwX2xhdGVyIG9sZF9wdXNoX3NpZ25hbF9yZXNvbHZlciAoKVxuICAgIGVuZDtcbiAgICAoKiBEbyB0aGlzIGF0IHRoZSBlbmQgaW4gY2FzZSBvbmUgb2YgdGhlIGZ1bmN0aW9uIHJhaXNlIGFuXG4gICAgICAgZXhjZXB0aW9uLiAqKVxuICAgIGlmIHggPSBOb25lIHRoZW4gTHd0Lndha2V1cCBjbG9zZSAoKVxuICBpblxuICAodCwgcHVzaCwgZnVuIHggLT4gc291cmNlLnB1c2hfZXh0ZXJuYWwgPC0gT2JqLnJlcHIgeClcblxubGV0IHJldHVybiBhID1cbiAgbGV0IHN0cmVhbSwgcHVzaCwgXyA9IGNyZWF0ZV93aXRoX3JlZmVyZW5jZSAoKSBpblxuICBwdXNoIChTb21lIGEpO1xuICBwdXNoIE5vbmU7XG4gIHN0cmVhbVxuXG5sZXQgcmV0dXJuX2x3dCBhID1cbiAgbGV0IHNvdXJjZSwgcHVzaCwgXyA9IGNyZWF0ZV93aXRoX3JlZmVyZW5jZSAoKSBpblxuICBMd3QuZG9udF93YWl0XG4gICAgKGZ1biAoKSAtPlxuICAgICAgTHd0LmJpbmQgYSAoZnVuIHggLT5cbiAgICAgICAgcHVzaCAoU29tZSB4KTtcbiAgICAgICAgcHVzaCBOb25lO1xuICAgICAgICBMd3QucmV0dXJuX3VuaXQpKVxuICAgIChmdW4gX2V4YyAtPiBwdXNoIE5vbmUpO1xuICBzb3VyY2VcblxubGV0IG9mX3NlcSBzID1cbiAgbGV0IHMgPSByZWYgcyBpblxuICBsZXQgZ2V0ICgpID1cbiAgICBtYXRjaCAhcyAoKSB3aXRoXG4gICAgfCBTZXEuTmlsIC0+IE5vbmVcbiAgICB8IFNlcS5Db25zIChlbHQsIHMnKSAtPiBzIDo9IHMnOyBTb21lIGVsdFxuICBpblxuICBmcm9tX2RpcmVjdCBnZXRcblxubGV0IG9mX2x3dF9zZXEgcyA9XG4gIGxldCBzID0gcmVmIHMgaW5cbiAgbGV0IGdldCAoKSA9XG4gICAgIXMgKCkgPnw9IGZ1bmN0aW9uXG4gICAgfCBMd3Rfc2VxLk5pbCAtPiBOb25lXG4gICAgfCBMd3Rfc2VxLkNvbnMgKGVsdCwgcycpIC0+IHMgOj0gcyc7IFNvbWUgZWx0XG4gIGluXG4gIGZyb20gZ2V0XG5cblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCBzb3VyY2UsIHB1c2gsIF8gPSBjcmVhdGVfd2l0aF9yZWZlcmVuY2UgKCkgaW5cbiAgKHNvdXJjZSwgcHVzaClcblxubGV0IG9mX2l0ZXIgaXRlciBpID1cbiAgbGV0IHN0cmVhbSwgcHVzaCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIChmdW4geCAtPiBwdXNoIChTb21lIHgpKSBpO1xuICBwdXNoIE5vbmU7XG4gIHN0cmVhbVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgb2ZfaXRlciBMaXN0Lml0ZXIgbFxuXG5sZXQgb2ZfYXJyYXkgYSA9XG4gIG9mX2l0ZXIgQXJyYXkuaXRlciBhXG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gIG9mX2l0ZXIgU3RyaW5nLml0ZXIgc1xuXG4oKiBBZGQgdGhlIHBlbmRpbmcgZWxlbWVudCB0byB0aGUgcXVldWUgYW5kIG5vdGlmeSB0aGUgYmxvY2tlZCBwdXNoZWQuXG5cbiAgIFByZWNvbmRpdGlvbjogaW5mby5wdXNoYl9wZW5kaW5nID0gU29tZSBfXG5cbiAgIFRoaXMgZG9lcyBub3QgbW9kaWZ5IGluZm8ucHVzaGJfY291bnQuICopXG5sZXQgbm90aWZ5X3B1c2hlciBpbmZvIGxhc3QgPVxuICAoKiBQdXNoIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIHF1ZXVlLiAqKVxuICBlbnF1ZXVlJyBpbmZvLnB1c2hiX3BlbmRpbmcgbGFzdDtcbiAgKCogQ2xlYXIgcGVuZGluZyBlbGVtZW50LiAqKVxuICBpbmZvLnB1c2hiX3BlbmRpbmcgPC0gTm9uZTtcbiAgKCogV2FrZXVwIHRoZSBwdXNoZXIuICopXG4gIGxldCBvbGRfd2FrZW5lciA9IGluZm8ucHVzaGJfcHVzaF93YWtlbmVyIGluXG4gIGxldCB3YWl0ZXIsIHdha2VuZXIgPSBMd3QudGFzayAoKSBpblxuICBpbmZvLnB1c2hiX3B1c2hfd2FpdGVyIDwtIHdhaXRlcjtcbiAgaW5mby5wdXNoYl9wdXNoX3dha2VuZXIgPC0gd2FrZW5lcjtcbiAgTHd0Lndha2V1cF9sYXRlciBvbGRfd2FrZW5lciAoKVxuXG5jbGFzcyBbJ2FdIGJvdW5kZWRfcHVzaF9pbXBsIChpbmZvIDogJ2EgcHVzaF9ib3VuZGVkKSB3YWtlbmVyX2NlbGwgbGFzdCBjbG9zZSA9IG9iamVjdFxuICB2YWwgbXV0YWJsZSBjbG9zZWQgPSBmYWxzZVxuXG4gIG1ldGhvZCBzaXplID1cbiAgICBpbmZvLnB1c2hiX3NpemVcblxuICBtZXRob2QgcmVzaXplIHNpemUgPVxuICAgIGlmIHNpemUgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMd3Rfc3RyZWFtLmJvdW5kZWRfcHVzaCNyZXNpemVcIjtcbiAgICBpbmZvLnB1c2hiX3NpemUgPC0gc2l6ZTtcbiAgICBpZiBpbmZvLnB1c2hiX2NvdW50IDwgaW5mby5wdXNoYl9zaXplICYmIGluZm8ucHVzaGJfcGVuZGluZyA8PiBOb25lIHRoZW4gYmVnaW5cbiAgICAgIGluZm8ucHVzaGJfY291bnQgPC0gaW5mby5wdXNoYl9jb3VudCArIDE7XG4gICAgICBub3RpZnlfcHVzaGVyIGluZm8gbGFzdFxuICAgIGVuZFxuXG4gIG1ldGhvZCBwdXNoIHggPVxuICAgIGlmIGNsb3NlZCB0aGVuXG4gICAgICBMd3QuZmFpbCBDbG9zZWRcbiAgICBlbHNlIGlmIGluZm8ucHVzaGJfcGVuZGluZyA8PiBOb25lIHRoZW5cbiAgICAgIEx3dC5mYWlsIEZ1bGxcbiAgICBlbHNlIGlmIGluZm8ucHVzaGJfY291bnQgPj0gaW5mby5wdXNoYl9zaXplIHRoZW4gYmVnaW5cbiAgICAgIGluZm8ucHVzaGJfcGVuZGluZyA8LSBTb21lIHg7XG4gICAgICBMd3QuY2F0Y2hcbiAgICAgICAgKGZ1biAoKSAtPiBpbmZvLnB1c2hiX3B1c2hfd2FpdGVyKVxuICAgICAgICAoZnVuIGV4biAtPlxuICAgICAgICAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgICAgICB8IEx3dC5DYW5jZWxlZCAtPlxuICAgICAgICAgICAgIGluZm8ucHVzaGJfcGVuZGluZyA8LSBOb25lO1xuICAgICAgICAgICAgIGxldCB3YWl0ZXIsIHdha2VuZXIgPSBMd3QudGFzayAoKSBpblxuICAgICAgICAgICAgIGluZm8ucHVzaGJfcHVzaF93YWl0ZXIgPC0gd2FpdGVyO1xuICAgICAgICAgICAgIGluZm8ucHVzaGJfcHVzaF93YWtlbmVyIDwtIHdha2VuZXI7XG4gICAgICAgICAgICAgTHd0LnJlcmFpc2UgZXhuXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgIEx3dC5yZXJhaXNlIGV4bilcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgKCogUHVzaCB0aGUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gKilcbiAgICAgIGVucXVldWUnIChTb21lIHgpIGxhc3Q7XG4gICAgICBpbmZvLnB1c2hiX2NvdW50IDwtIGluZm8ucHVzaGJfY291bnQgKyAxO1xuICAgICAgKCogU2VuZCBhIHNpZ25hbCBpZiBhdCBsZWFzdCBvbmUgdGhyZWFkIGlzIHdhaXRpbmcgZm9yIGEgbmV3XG4gICAgICAgICBlbGVtZW50LiAqKVxuICAgICAgaWYgaW5mby5wdXNoYl93YWl0aW5nIHRoZW4gYmVnaW5cbiAgICAgICAgaW5mby5wdXNoYl93YWl0aW5nIDwtIGZhbHNlO1xuICAgICAgICAoKiBVcGRhdGUgdGhyZWFkcy4gKilcbiAgICAgICAgbGV0IG9sZF93YWtlbmVyID0gIXdha2VuZXJfY2VsbCBpblxuICAgICAgICBsZXQgbmV3X3dhaXRlciwgbmV3X3dha2VuZXIgPSBMd3Qud2FpdCAoKSBpblxuICAgICAgICBpbmZvLnB1c2hiX3NpZ25hbCA8LSBuZXdfd2FpdGVyO1xuICAgICAgICB3YWtlbmVyX2NlbGwgOj0gbmV3X3dha2VuZXI7XG4gICAgICAgICgqIFNpZ25hbCB0aGF0IGEgbmV3IHZhbHVlIGhhcyBiZWVuIHJlY2VpdmVkLiAqKVxuICAgICAgICBMd3Qud2FrZXVwX2xhdGVyIG9sZF93YWtlbmVyICgpXG4gICAgICBlbmQ7XG4gICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICBlbmRcblxuICBtZXRob2QgY2xvc2UgPVxuICAgIGlmIG5vdCBjbG9zZWQgdGhlbiBiZWdpblxuICAgICAgY2xvc2VkIDwtIHRydWU7XG4gICAgICBsZXQgbm9kZSA9ICFsYXN0IGFuZCBuZXdfbGFzdCA9IG5ld19ub2RlICgpIGluXG4gICAgICBub2RlLmRhdGEgPC0gTm9uZTtcbiAgICAgIG5vZGUubmV4dCA8LSBuZXdfbGFzdDtcbiAgICAgIGxhc3QgOj0gbmV3X2xhc3Q7XG4gICAgICBpZiBpbmZvLnB1c2hiX3BlbmRpbmcgPD4gTm9uZSB0aGVuIGJlZ2luXG4gICAgICAgIGluZm8ucHVzaGJfcGVuZGluZyA8LSBOb25lO1xuICAgICAgICBMd3Qud2FrZXVwX2xhdGVyX2V4biBpbmZvLnB1c2hiX3B1c2hfd2FrZW5lciBDbG9zZWRcbiAgICAgIGVuZDtcbiAgICAgICgqIFNlbmQgYSBzaWduYWwgaWYgYXQgbGVhc3Qgb25lIHRocmVhZCBpcyB3YWl0aW5nIGZvciBhIG5ld1xuICAgICAgICAgZWxlbWVudC4gKilcbiAgICAgIGlmIGluZm8ucHVzaGJfd2FpdGluZyB0aGVuIGJlZ2luXG4gICAgICAgIGluZm8ucHVzaGJfd2FpdGluZyA8LSBmYWxzZTtcbiAgICAgICAgbGV0IG9sZF93YWtlbmVyID0gIXdha2VuZXJfY2VsbCBpblxuICAgICAgICAoKiBTaWduYWwgdGhhdCBhIG5ldyB2YWx1ZSBoYXMgYmVlbiByZWNlaXZlZC4gKilcbiAgICAgICAgTHd0Lndha2V1cF9sYXRlciBvbGRfd2FrZW5lciAoKVxuICAgICAgZW5kO1xuICAgICAgTHd0Lndha2V1cCBjbG9zZSAoKTtcbiAgICBlbmRcblxuICBtZXRob2QgY291bnQgPVxuICAgIGluZm8ucHVzaGJfY291bnRcblxuICBtZXRob2QgYmxvY2tlZCA9XG4gICAgaW5mby5wdXNoYl9wZW5kaW5nIDw+IE5vbmVcblxuICBtZXRob2QgY2xvc2VkID1cbiAgICBjbG9zZWRcblxuICBtZXRob2Qgc2V0X3JlZmVyZW5jZSA6ICdhLiAnYSAtPiB1bml0ID1cbiAgICBmdW4geCAtPiBpbmZvLnB1c2hiX2V4dGVybmFsIDwtIE9iai5yZXByIHhcbmVuZFxuXG5sZXQgY3JlYXRlX2JvdW5kZWQgc2l6ZSA9XG4gIGlmIHNpemUgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMd3Rfc3RyZWFtLmNyZWF0ZV9ib3VuZGVkXCI7XG4gICgqIENyZWF0ZSB0aGUgc291cmNlIGZvciBub3RpZmljYXRpb25zIG9mIG5ldyBlbGVtZW50cy4gKilcbiAgbGV0IGluZm8sIHdha2VuZXJfY2VsbCA9XG4gICAgbGV0IHdhaXRlciwgd2FrZW5lciA9IEx3dC53YWl0ICgpIGluXG4gICAgbGV0IHB1c2hfd2FpdGVyLCBwdXNoX3dha2VuZXIgPSBMd3QudGFzayAoKSBpblxuICAgICh7IHB1c2hiX3NpZ25hbCA9IHdhaXRlcjtcbiAgICAgICBwdXNoYl93YWl0aW5nID0gZmFsc2U7XG4gICAgICAgcHVzaGJfc2l6ZSA9IHNpemU7XG4gICAgICAgcHVzaGJfY291bnQgPSAwO1xuICAgICAgIHB1c2hiX3BlbmRpbmcgPSBOb25lO1xuICAgICAgIHB1c2hiX3B1c2hfd2FpdGVyID0gcHVzaF93YWl0ZXI7XG4gICAgICAgcHVzaGJfcHVzaF93YWtlbmVyID0gcHVzaF93YWtlbmVyO1xuICAgICAgIHB1c2hiX2V4dGVybmFsID0gT2JqLnJlcHIgKCkgfSxcbiAgICAgcmVmIHdha2VuZXIpXG4gIGluXG4gIGxldCB0ID0gZnJvbV9zb3VyY2UgKFB1c2hfYm91bmRlZCBpbmZvKSBpblxuICAodCwgbmV3IGJvdW5kZWRfcHVzaF9pbXBsIGluZm8gd2FrZW5lcl9jZWxsIHQubGFzdCB0LmNsb3NlKVxuXG4oKiBXYWl0IGZvciBhIG5ldyBlbGVtZW50IHRvIGJlIGFkZGVkIHRvIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIGVsZW1lbnRcbiAgIG9mIHRoZSBzdHJlYW0uICopXG5sZXQgZmVlZCBzID1cbiAgbWF0Y2ggcy5zb3VyY2Ugd2l0aFxuICB8IEZyb20gZnJvbSAtPlxuICAgICgqIFRoZXJlIGlzIGFscmVhZHkgYSB0aHJlYWQgc3RhcnRlZCB0byBjcmVhdGUgYSBuZXcgZWxlbWVudCxcbiAgICAgICB3YWl0IGZvciB0aGlzIG9uZSB0byB0ZXJtaW5hdGUuICopXG4gICAgaWYgTHd0LmlzX3NsZWVwaW5nIGZyb20uZnJvbV90aHJlYWQgdGhlblxuICAgICAgTHd0LnByb3RlY3RlZCBmcm9tLmZyb21fdGhyZWFkXG4gICAgZWxzZSBiZWdpblxuICAgICAgKCogT3RoZXJ3aXNlIHJlcXVlc3QgYSBuZXcgZWxlbWVudC4gKilcbiAgICAgIGxldCB0aHJlYWQgPVxuICAgICAgICAoKiBUaGUgZnVuY3Rpb24gW2Zyb21fY3JlYXRlXSBjYW4gcmFpc2UgYW4gZXhjZXB0aW9uICh3aXRoXG4gICAgICAgICAgIFtyYWlzZV0sIHJhdGhlciB0aGFuIHJldHVybmluZyBhIGZhaWxlZCBwcm9taXNlIHdpdGhcbiAgICAgICAgICAgW0x3dC5mYWlsXSkuIEluIHRoaXMgY2FzZSwgd2UgaGF2ZSB0byBjYXRjaCB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgIGFuZCB0dXJuIGl0IGludG8gYSBzYWZlIGZhaWxlZCBwcm9taXNlLiAqKVxuICAgICAgICBMd3QuY2F0Y2hcbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICBmcm9tLmZyb21fY3JlYXRlICgpID4+PSBmdW4geCAtPlxuICAgICAgICAgICAgKCogUHVzaCB0aGUgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gKilcbiAgICAgICAgICAgIGVucXVldWUgeCBzO1xuICAgICAgICAgICAgaWYgeCA9IE5vbmUgdGhlbiBMd3Qud2FrZXVwIHMuY2xvc2UgKCk7XG4gICAgICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG4gICAgICAgICAgTHd0LnJlcmFpc2VcbiAgICAgIGluXG4gICAgICAoKiBBbGxvdyBvdGhlciB0aHJlYWRzIHRvIGFjY2VzcyB0aGlzIHRocmVhZC4gKilcbiAgICAgIGZyb20uZnJvbV90aHJlYWQgPC0gdGhyZWFkO1xuICAgICAgTHd0LnByb3RlY3RlZCB0aHJlYWRcbiAgICBlbmRcbiAgfCBGcm9tX2RpcmVjdCBmIC0+XG4gICAgbGV0IHggPSBmICgpIGluXG4gICAgKCogUHVzaCB0aGUgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gKilcbiAgICBlbnF1ZXVlIHggcztcbiAgICBpZiB4ID0gTm9uZSB0aGVuIEx3dC53YWtldXAgcy5jbG9zZSAoKTtcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgfCBQdXNoIHB1c2ggLT5cbiAgICBwdXNoLnB1c2hfd2FpdGluZyA8LSB0cnVlO1xuICAgIEx3dC5wcm90ZWN0ZWQgcHVzaC5wdXNoX3NpZ25hbFxuICB8IFB1c2hfYm91bmRlZCBwdXNoIC0+XG4gICAgcHVzaC5wdXNoYl93YWl0aW5nIDwtIHRydWU7XG4gICAgTHd0LnByb3RlY3RlZCBwdXNoLnB1c2hiX3NpZ25hbFxuXG4oKiBSZW1vdmUgW25vZGVdIGZyb20gdGhlIHRvcCBvZiB0aGUgcXVldWUsIG9yIGRvIG5vdGhpbmcgaWYgaXQgd2FzXG4gICBhbHJlYWR5IGNvbnN1bWVkLlxuXG4gICBQcmVjb25kaXRpb246IG5vZGUuZGF0YSA8PiBOb25lXG4qKVxubGV0IGNvbnN1bWUgcyBub2RlID1cbiAgaWYgbm9kZSA9PSBzLm5vZGUgdGhlbiBiZWdpblxuICAgIHMubm9kZSA8LSBub2RlLm5leHQ7XG4gICAgbWF0Y2ggcy5zb3VyY2Ugd2l0aFxuICAgIHwgUHVzaF9ib3VuZGVkIGluZm8gLT5cbiAgICAgIGlmIGluZm8ucHVzaGJfcGVuZGluZyA9IE5vbmUgdGhlblxuICAgICAgICBpbmZvLnB1c2hiX2NvdW50IDwtIGluZm8ucHVzaGJfY291bnQgLSAxXG4gICAgICBlbHNlXG4gICAgICAgIG5vdGlmeV9wdXNoZXIgaW5mbyBzLmxhc3RcbiAgICB8IEZyb20gXyB8IEZyb21fZGlyZWN0IF8gfCBQdXNoIF8gLT5cbiAgICAgICgpXG4gIGVuZFxuXG5sZXQgcmVjIHBlZWtfcmVjIHMgbm9kZSA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBwZWVrX3JlYyBzIG5vZGVcbiAgZWxzZVxuICAgIEx3dC5yZXR1cm4gbm9kZS5kYXRhXG5cbmxldCBwZWVrIHMgPSBwZWVrX3JlYyBzIHMubm9kZVxuXG5sZXQgcmVjIG5wZWVrX3JlYyBub2RlIGFjYyBuIHMgPVxuICBpZiBuIDw9IDAgdGhlblxuICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcbiAgZWxzZSBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gbnBlZWtfcmVjIG5vZGUgYWNjIG4gc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbnBlZWtfcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIChuIC0gMSkgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG5sZXQgbnBlZWsgbiBzID0gbnBlZWtfcmVjIHMubm9kZSBbXSBuIHNcblxubGV0IHJlYyBnZXRfcmVjIHMgbm9kZSA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBnZXRfcmVjIHMgbm9kZVxuICBlbHNlIGJlZ2luXG4gICAgaWYgbm9kZS5kYXRhIDw+IE5vbmUgdGhlbiBjb25zdW1lIHMgbm9kZTtcbiAgICBMd3QucmV0dXJuIG5vZGUuZGF0YVxuICBlbmRcblxubGV0IGdldCBzID0gZ2V0X3JlYyBzIHMubm9kZVxuXG5sZXQgcmVjIGdldF9leG5fcmVjIHMgbm9kZSA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBMd3QudHJ5X2JpbmRcbiAgICAgIChmdW4gKCkgLT4gZmVlZCBzKVxuICAgICAgKGZ1biAoKSAtPiBnZXRfZXhuX3JlYyBzIG5vZGUpXG4gICAgICAoZnVuIGV4biAtPiBMd3QucmV0dXJuIChTb21lIChSZXN1bHQuRXJyb3IgZXhuKSkpXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBMd3QucmV0dXJuIChTb21lIChSZXN1bHQuT2sgdmFsdWUpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG5cbmxldCB3cmFwX2V4biBzID0gZnJvbSAoZnVuICgpIC0+IGdldF9leG5fcmVjIHMgcy5ub2RlKVxuXG5sZXQgcmVjIG5nZXRfcmVjIG5vZGUgYWNjIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuXG4gICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuICBlbHNlIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBuZ2V0X3JlYyBub2RlIGFjYyBuIHNcbiAgZWxzZVxuICAgIG1hdGNoIHMubm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBuZ2V0X3JlYyBub2RlLm5leHQgKHggOjogYWNjKSAobiAtIDEpIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcblxubGV0IG5nZXQgbiBzID0gbmdldF9yZWMgcy5ub2RlIFtdIG4gc1xuXG5sZXQgcmVjIGdldF93aGlsZV9yZWMgbm9kZSBhY2MgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGdldF93aGlsZV9yZWMgbm9kZSBhY2MgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBsZXQgdGVzdCA9IGYgeCBpblxuICAgICAgaWYgdGVzdCB0aGVuIGJlZ2luXG4gICAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgICBnZXRfd2hpbGVfcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIGYgc1xuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG5sZXQgZ2V0X3doaWxlIGYgcyA9IGdldF93aGlsZV9yZWMgcy5ub2RlIFtdIGYgc1xuXG5sZXQgcmVjIGdldF93aGlsZV9zX3JlYyBub2RlIGFjYyBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZ2V0X3doaWxlX3NfcmVjIG5vZGUgYWNjIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPiBiZWdpblxuICAgICAgICBmIHggPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgICAgIGdldF93aGlsZV9zX3JlYyBub2RlLm5leHQgKHggOjogYWNjKSBmIHNcbiAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcbiAgICAgIGVuZFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG5sZXQgZ2V0X3doaWxlX3MgZiBzID0gZ2V0X3doaWxlX3NfcmVjIHMubm9kZSBbXSBmIHNcblxubGV0IHJlYyBuZXh0X3JlYyBzIG5vZGUgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gbmV4dF9yZWMgcyBub2RlXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIEx3dC5yZXR1cm4geFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LmZhaWwgRW1wdHlcblxubGV0IG5leHQgcyA9IG5leHRfcmVjIHMgcy5ub2RlXG5cbmxldCByZWMgbGFzdF9uZXdfcmVjIG5vZGUgeCBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGxldCB0aHJlYWQgPSBmZWVkIHMgaW5cbiAgICBtYXRjaCBMd3Quc3RhdGUgdGhyZWFkIHdpdGhcbiAgICB8IEx3dC5SZXR1cm4gXyAtPlxuICAgICAgbGFzdF9uZXdfcmVjIG5vZGUgeCBzXG4gICAgfCBMd3QuRmFpbCBleG4gLT5cbiAgICAgIEx3dC5mYWlsIGV4blxuICAgIHwgTHd0LlNsZWVwIC0+XG4gICAgICBMd3QucmV0dXJuIHhcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGFzdF9uZXdfcmVjIG5vZGUubmV4dCB4IHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4geFxuXG5sZXQgbGFzdF9uZXcgcyA9XG4gIGxldCBub2RlID0gcy5ub2RlIGluXG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBsZXQgdGhyZWFkID0gbmV4dCBzIGluXG4gICAgbWF0Y2ggTHd0LnN0YXRlIHRocmVhZCB3aXRoXG4gICAgfCBMd3QuUmV0dXJuIHggLT5cbiAgICAgIGxhc3RfbmV3X3JlYyBub2RlIHggc1xuICAgIHwgTHd0LkZhaWwgXyB8IEx3dC5TbGVlcCAtPlxuICAgICAgdGhyZWFkXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxhc3RfbmV3X3JlYyBub2RlLm5leHQgeCBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QuZmFpbCBFbXB0eVxuXG5sZXQgcmVjIHRvX2xpc3RfcmVjIG5vZGUgYWNjIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gdG9fbGlzdF9yZWMgbm9kZSBhY2Mgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICB0b19saXN0X3JlYyBub2RlLm5leHQgKHggOjogYWNjKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG5cbmxldCB0b19saXN0IHMgPSB0b19saXN0X3JlYyBzLm5vZGUgW10gc1xuXG5sZXQgcmVjIHRvX3N0cmluZ19yZWMgbm9kZSBidWYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiB0b19zdHJpbmdfcmVjIG5vZGUgYnVmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiB4O1xuICAgICAgdG9fc3RyaW5nX3JlYyBub2RlLm5leHQgYnVmIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKEJ1ZmZlci5jb250ZW50cyBidWYpXG5cbmxldCB0b19zdHJpbmcgcyA9IHRvX3N0cmluZ19yZWMgcy5ub2RlIChCdWZmZXIuY3JlYXRlIDEyOCkgc1xuXG5sZXQganVuayBzID1cbiAgbGV0IG5vZGUgPSBzLm5vZGUgaW5cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlbiBiZWdpblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+XG4gICAgaWYgbm9kZS5kYXRhIDw+IE5vbmUgdGhlbiBjb25zdW1lIHMgbm9kZTtcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICBpZiBub2RlLmRhdGEgPD4gTm9uZSB0aGVuIGNvbnN1bWUgcyBub2RlO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICBlbmRcblxubGV0IHJlYyBuanVua19yZWMgbm9kZSBuIHMgPVxuICBpZiBuIDw9IDAgdGhlblxuICAgIEx3dC5yZXR1cm5fdW5pdFxuICBlbHNlIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBuanVua19yZWMgbm9kZSBuIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIF8gLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbmp1bmtfcmVjIG5vZGUubmV4dCAobiAtIDEpIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgbmp1bmsgbiBzID0gbmp1bmtfcmVjIHMubm9kZSBuIHNcblxubGV0IHJlYyBqdW5rX3doaWxlX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBqdW5rX3doaWxlX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbGV0IHRlc3QgPSBmIHggaW5cbiAgICAgIGlmIHRlc3QgdGhlbiBiZWdpblxuICAgICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgICAganVua193aGlsZV9yZWMgbm9kZS5uZXh0IGYgc1xuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IGp1bmtfd2hpbGUgZiBzID0ganVua193aGlsZV9yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGp1bmtfd2hpbGVfc19yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4ganVua193aGlsZV9zX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPiBiZWdpblxuICAgICAgICBmIHggPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgICAgIGp1bmtfd2hpbGVfc19yZWMgbm9kZS5uZXh0IGYgc1xuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgICBlbmRcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQganVua193aGlsZV9zIGYgcyA9IGp1bmtfd2hpbGVfc19yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGp1bmtfYXZhaWxhYmxlX3JlYyBub2RlIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgbGV0IHRocmVhZCA9IGZlZWQgcyBpblxuICAgIG1hdGNoIEx3dC5zdGF0ZSB0aHJlYWQgd2l0aFxuICAgIHwgTHd0LlJldHVybiBfIC0+XG4gICAgICBqdW5rX2F2YWlsYWJsZV9yZWMgbm9kZSBzXG4gICAgfCBMd3QuRmFpbCBleG4gLT5cbiAgICAgIHJhaXNlIGV4blxuICAgIHwgTHd0LlNsZWVwIC0+XG4gICAgICAoKVxuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgXyAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBqdW5rX2F2YWlsYWJsZV9yZWMgbm9kZS5uZXh0IHNcbiAgICB8IE5vbmUgLT5cbiAgICAgICgpXG5cbmxldCBqdW5rX2F2YWlsYWJsZSBzID0ganVua19hdmFpbGFibGVfcmVjIHMubm9kZSBzXG5cbmxldCBqdW5rX29sZCBzID0gTHd0LnJldHVybiAoanVua19hdmFpbGFibGUgcylcblxubGV0IHJlYyBnZXRfYXZhaWxhYmxlX3JlYyBub2RlIGFjYyBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGxldCB0aHJlYWQgPSBmZWVkIHMgaW5cbiAgICBtYXRjaCBMd3Quc3RhdGUgdGhyZWFkIHdpdGhcbiAgICB8IEx3dC5SZXR1cm4gXyAtPlxuICAgICAgZ2V0X2F2YWlsYWJsZV9yZWMgbm9kZSBhY2Mgc1xuICAgIHwgTHd0LkZhaWwgZXhuIC0+XG4gICAgICByYWlzZSBleG5cbiAgICB8IEx3dC5TbGVlcCAtPlxuICAgICAgTGlzdC5yZXYgYWNjXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGdldF9hdmFpbGFibGVfcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIExpc3QucmV2IGFjY1xuXG5sZXQgZ2V0X2F2YWlsYWJsZSBzID0gZ2V0X2F2YWlsYWJsZV9yZWMgcy5ub2RlIFtdIHNcblxubGV0IHJlYyBnZXRfYXZhaWxhYmxlX3VwX3RvX3JlYyBub2RlIGFjYyBuIHMgPVxuICBpZiBuIDw9IDAgdGhlblxuICAgIExpc3QucmV2IGFjY1xuICBlbHNlIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBsZXQgdGhyZWFkID0gZmVlZCBzIGluXG4gICAgbWF0Y2ggTHd0LnN0YXRlIHRocmVhZCB3aXRoXG4gICAgfCBMd3QuUmV0dXJuIF8gLT5cbiAgICAgIGdldF9hdmFpbGFibGVfdXBfdG9fcmVjIG5vZGUgYWNjIG4gc1xuICAgIHwgTHd0LkZhaWwgZXhuIC0+XG4gICAgICByYWlzZSBleG5cbiAgICB8IEx3dC5TbGVlcCAtPlxuICAgICAgTGlzdC5yZXYgYWNjXG4gIGVsc2VcbiAgICBtYXRjaCBzLm5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgZ2V0X2F2YWlsYWJsZV91cF90b19yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgKG4gLSAxKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMaXN0LnJldiBhY2NcblxubGV0IGdldF9hdmFpbGFibGVfdXBfdG8gbiBzID0gZ2V0X2F2YWlsYWJsZV91cF90b19yZWMgcy5ub2RlIFtdIG4gc1xuXG5sZXQgcmVjIGlzX2VtcHR5IHMgPVxuICBpZiBzLm5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBpc19lbXB0eSBzXG4gIGVsc2VcbiAgICBMd3QucmV0dXJuIChzLm5vZGUuZGF0YSA9IE5vbmUpXG5cbmxldCBtYXAgZiBzID1cbiAgZnJvbSAoZnVuICgpIC0+IGdldCBzID58PSBmdW5jdGlvblxuICB8IFNvbWUgeCAtPlxuICAgIGxldCB4ID0gZiB4IGluXG4gICAgU29tZSB4XG4gIHwgTm9uZSAtPlxuICAgIE5vbmUpXG5cbmxldCBtYXBfcyBmIHMgPVxuICBmcm9tIChmdW4gKCkgLT4gZ2V0IHMgPj49IGZ1bmN0aW9uXG4gIHwgU29tZSB4IC0+XG4gICAgZiB4ID58PSAoZnVuIHggLT4gU29tZSB4KVxuICB8IE5vbmUgLT5cbiAgICBMd3QucmV0dXJuX25vbmUpXG5cbmxldCBmaWx0ZXIgZiBzID1cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBsZXQgdCA9IGdldCBzIGluXG4gICAgdCA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbGV0IHRlc3QgPSBmIHggaW5cbiAgICAgIGlmIHRlc3QgdGhlblxuICAgICAgICB0XG4gICAgICBlbHNlXG4gICAgICAgIG5leHQgKClcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGZpbHRlcl9zIGYgcyA9XG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbGV0IHQgPSBnZXQgcyBpblxuICAgIHQgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIHggLT4gYmVnaW5cbiAgICAgICAgZiB4ID4+PSBmdW5jdGlvblxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICB0XG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICBuZXh0ICgpXG4gICAgICBlbmRcbiAgICB8IE5vbmUgLT5cbiAgICAgIHRcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBmaWx0ZXJfbWFwIGYgcyA9XG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgZ2V0IHMgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICAobWF0Y2ggeCB3aXRoXG4gICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgIEx3dC5yZXR1cm4geFxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgbmV4dCAoKSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGZpbHRlcl9tYXBfcyBmIHMgPVxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGdldCBzID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSB4IC0+XG4gICAgICBsZXQgdCA9IGYgeCBpblxuICAgICAgKHQgPj49IGZ1bmN0aW9uXG4gICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgIHRcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIG5leHQgKCkpXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBtYXBfbGlzdCBmIHMgPVxuICBsZXQgcGVuZGluZ3MgPSByZWYgW10gaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCAhcGVuZGluZ3Mgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIChnZXQgcyA+Pj0gZnVuY3Rpb25cbiAgICAgICB8IFNvbWUgeCAtPlxuICAgICAgICAgbGV0IGwgPSBmIHggaW5cbiAgICAgICAgIHBlbmRpbmdzIDo9IGw7XG4gICAgICAgICBuZXh0ICgpXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBMd3QucmV0dXJuX25vbmUpXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgIHBlbmRpbmdzIDo9IGw7XG4gICAgICBMd3QucmV0dXJuIChTb21lIHgpXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgbWFwX2xpc3RfcyBmIHMgPVxuICBsZXQgcGVuZGluZ3MgPSByZWYgW10gaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCAhcGVuZGluZ3Mgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIChnZXQgcyA+Pj0gZnVuY3Rpb25cbiAgICAgICB8IFNvbWUgeCAtPlxuICAgICAgICAgZiB4ID4+PSBmdW4gbCAtPlxuICAgICAgICAgcGVuZGluZ3MgOj0gbDtcbiAgICAgICAgIG5leHQgKClcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIEx3dC5yZXR1cm5fbm9uZSlcbiAgICB8IHggOjogbCAtPlxuICAgICAgcGVuZGluZ3MgOj0gbDtcbiAgICAgIEx3dC5yZXR1cm4gKFNvbWUgeClcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBmbGF0dGVuIHMgPVxuICBtYXBfbGlzdCAoZnVuIGwgLT4gbCkgc1xuXG5sZXQgcmVjIGZvbGRfcmVjIG5vZGUgZiBzIGFjYyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmb2xkX3JlYyBub2RlIGYgcyBhY2NcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0IGFjYyA9IGYgeCBhY2MgaW5cbiAgICAgIGZvbGRfcmVjIG5vZGUubmV4dCBmIHMgYWNjXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIGFjY1xuXG5sZXQgZm9sZCBmIHMgYWNjID0gZm9sZF9yZWMgcy5ub2RlIGYgcyBhY2NcblxubGV0IHJlYyBmb2xkX3NfcmVjIG5vZGUgZiBzIGFjYyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmb2xkX3NfcmVjIG5vZGUgZiBzIGFjY1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBmIHggYWNjID4+PSBmdW4gYWNjIC0+XG4gICAgICBmb2xkX3NfcmVjIG5vZGUubmV4dCBmIHMgYWNjXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIGFjY1xuXG5sZXQgZm9sZF9zIGYgcyBhY2MgPSBmb2xkX3NfcmVjIHMubm9kZSBmIHMgYWNjXG5cbmxldCByZWMgaXRlcl9yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gaXRlcl9yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0ICgpID0gZiB4IGluXG4gICAgICBpdGVyX3JlYyBub2RlLm5leHQgZiBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IGl0ZXIgZiBzID0gaXRlcl9yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGl0ZXJfc19yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gaXRlcl9zX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBmIHggPj49IGZ1biAoKSAtPlxuICAgICAgaXRlcl9zX3JlYyBub2RlLm5leHQgZiBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IGl0ZXJfcyBmIHMgPSBpdGVyX3NfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBpdGVyX3BfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGl0ZXJfcF9yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0IHJlcyA9IGYgeCBpblxuICAgICAgbGV0IHJlc3QgPSBpdGVyX3BfcmVjIG5vZGUubmV4dCBmIHMgaW5cbiAgICAgIHJlcyA+Pj0gZnVuICgpIC0+IHJlc3RcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgaXRlcl9wIGYgcyA9IGl0ZXJfcF9yZWMgcy5ub2RlIGYgc1xuXG5sZXQgaXRlcl9uID8obWF4X2NvbmN1cnJlbmN5ID0gMSkgZiBzdHJlYW0gPVxuICBiZWdpblxuICAgIGlmIG1heF9jb25jdXJyZW5jeSA8PSAwIHRoZW5cbiAgICAgIGxldCBtZXNzYWdlID1cbiAgICAgICAgUHJpbnRmLnNwcmludGZcbiAgICAgICAgICBcIkx3dF9zdHJlYW0uaXRlcl9uOiBtYXhfY29uY3VycmVuY3kgbXVzdCBiZSA+IDAsICVkIGdpdmVuXCJcbiAgICAgICAgICBtYXhfY29uY3VycmVuY3lcbiAgICAgIGluXG4gICAgICBpbnZhbGlkX2FyZyBtZXNzYWdlXG4gIGVuZDtcbiAgbGV0IHJlYyBsb29wIHJ1bm5pbmcgYXZhaWxhYmxlID1cbiAgICBiZWdpblxuICAgICAgaWYgYXZhaWxhYmxlID4gMCB0aGVuIChcbiAgICAgICAgTHd0LnJldHVybiAocnVubmluZywgYXZhaWxhYmxlKVxuICAgICAgKVxuICAgICAgZWxzZSAoXG4gICAgICAgIEx3dC5uY2hvb3NlX3NwbGl0IHJ1bm5pbmcgPj49IGZ1biAoY29tcGxldGUsIHJ1bm5pbmcpIC0+XG4gICAgICAgIEx3dC5yZXR1cm4gKHJ1bm5pbmcsIGF2YWlsYWJsZSArIExpc3QubGVuZ3RoIGNvbXBsZXRlKVxuICAgICAgKVxuICAgIGVuZCA+Pj0gZnVuIChydW5uaW5nLCBhdmFpbGFibGUpIC0+XG4gICAgZ2V0IHN0cmVhbSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5qb2luIHJ1bm5pbmdcbiAgICB8IFNvbWUgZWx0IC0+XG4gICAgICBsb29wIChmIGVsdCA6OiBydW5uaW5nKSAocHJlZCBhdmFpbGFibGUpXG4gIGluXG4gIGxvb3AgW10gbWF4X2NvbmN1cnJlbmN5XG5cbmxldCByZWMgZmluZF9yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZmluZF9yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggYXMgb3B0IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxldCB0ZXN0ID0gZiB4IGluXG4gICAgICBpZiB0ZXN0IHRoZW5cbiAgICAgICAgTHd0LnJldHVybiBvcHRcbiAgICAgIGVsc2VcbiAgICAgICAgZmluZF9yZWMgbm9kZS5uZXh0IGYgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG5cbmxldCBmaW5kIGYgcyA9IGZpbmRfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBmaW5kX3NfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGZpbmRfc19yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggYXMgb3B0IC0+IGJlZ2luXG4gICAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgICBmIHggPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIEx3dC5yZXR1cm4gb3B0XG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICBmaW5kX3NfcmVjIG5vZGUubmV4dCBmIHNcbiAgICAgIGVuZFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG5cbmxldCBmaW5kX3MgZiBzID0gZmluZF9zX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMgZmluZF9tYXBfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGZpbmRfbWFwX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsZXQgeCA9IGYgeCBpblxuICAgICAgaWYgeCA9IE5vbmUgdGhlblxuICAgICAgICBmaW5kX21hcF9yZWMgbm9kZS5uZXh0IGYgc1xuICAgICAgZWxzZVxuICAgICAgICBMd3QucmV0dXJuIHhcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgZmluZF9tYXAgZiBzID0gZmluZF9tYXBfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBmaW5kX21hcF9zX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmaW5kX21hcF9zX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsZXQgdCA9IGYgeCBpblxuICAgICAgKHQgPj49IGZ1bmN0aW9uXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBmaW5kX21hcF9zX3JlYyBub2RlLm5leHQgZiBzXG4gICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgIHQpXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcblxubGV0IGZpbmRfbWFwX3MgZiBzID0gZmluZF9tYXBfc19yZWMgcy5ub2RlIGYgc1xuXG5sZXQgY29tYmluZSBzMSBzMiA9XG4gIGxldCBuZXh0ICgpID1cbiAgICBsZXQgdDEgPSBnZXQgczEgYW5kIHQyID0gZ2V0IHMyIGluXG4gICAgdDEgPj49IGZ1biBuMSAtPlxuICAgIHQyID4+PSBmdW4gbjIgLT5cbiAgICBtYXRjaCBuMSwgbjIgd2l0aFxuICAgIHwgU29tZSB4MSwgU29tZSB4MiAtPlxuICAgICAgTHd0LnJldHVybiAoU29tZSh4MSwgeDIpKVxuICAgIHwgXyAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgYXBwZW5kIHMxIHMyID1cbiAgbGV0IGN1cnJlbnRfcyA9IHJlZiBzMSBpblxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGxldCB0ID0gZ2V0ICFjdXJyZW50X3MgaW5cbiAgICB0ID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSBfIC0+XG4gICAgICB0XG4gICAgfCBOb25lIC0+XG4gICAgICBpZiAhY3VycmVudF9zID09IHMyIHRoZW5cbiAgICAgICAgTHd0LnJldHVybl9ub25lXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGN1cnJlbnRfcyA6PSBzMjtcbiAgICAgICAgbmV4dCAoKVxuICAgICAgZW5kXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgY29uY2F0IHNfdG9wID1cbiAgbGV0IGN1cnJlbnRfcyA9IHJlZiAoZnJvbSAoZnVuICgpIC0+IEx3dC5yZXR1cm5fbm9uZSkpIGluXG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbGV0IHQgPSBnZXQgIWN1cnJlbnRfcyBpblxuICAgIHQgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIF8gLT5cbiAgICAgIHRcbiAgICB8IE5vbmUgLT5cbiAgICAgIGdldCBzX3RvcCA+Pj0gZnVuY3Rpb25cbiAgICAgIHwgU29tZSBzIC0+XG4gICAgICAgIGN1cnJlbnRfcyA6PSBzO1xuICAgICAgICBuZXh0ICgpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgTHd0LnJldHVybl9ub25lXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgY2hvb3NlIHN0cmVhbXMgPVxuICBsZXQgc291cmNlIHMgPSAocywgZ2V0IHMgPnw9IGZ1biB4IC0+IChzLCB4KSkgaW5cbiAgbGV0IHN0cmVhbXMgPSByZWYgKExpc3QubWFwIHNvdXJjZSBzdHJlYW1zKSBpblxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIG1hdGNoICFzdHJlYW1zIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgICB8IGwgLT5cbiAgICAgIEx3dC5jaG9vc2UgKExpc3QubWFwIHNuZCBsKSA+Pj0gZnVuIChzLCB4KSAtPlxuICAgICAgbGV0IGwgPSBMaXN0LnJlbW92ZV9hc3NxIHMgbCBpblxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IFNvbWUgXyAtPlxuICAgICAgICBzdHJlYW1zIDo9IHNvdXJjZSBzIDo6IGw7XG4gICAgICAgIEx3dC5yZXR1cm4geFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIHN0cmVhbXMgOj0gbDtcbiAgICAgICAgbmV4dCAoKVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IHBhcnNlIHMgZiA9XG4gIChtYXRjaCBzLnNvdXJjZSB3aXRoXG4gICB8IFB1c2hfYm91bmRlZCBfIC0+IGludmFsaWRfYXJnIFwiTHd0X3N0cmVhbS5wYXJzZVwiXG4gICB8IEZyb20gXyB8IEZyb21fZGlyZWN0IF8gfCBQdXNoIF8gLT4gKCkpO1xuICBsZXQgbm9kZSA9IHMubm9kZSBpblxuICBMd3QuY2F0Y2hcbiAgICAoZnVuICgpIC0+IGYgcylcbiAgICAoZnVuIGV4biAtPlxuICAgICAgIHMubm9kZSA8LSBub2RlO1xuICAgICAgIEx3dC5yZXJhaXNlIGV4bilcblxubGV0IGhleGR1bXAgc3RyZWFtID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgODAgYW5kIG51bSA9IHJlZiAwIGluXG4gIGZyb20gYmVnaW4gZnVuIF8gLT5cbiAgICBuZ2V0IDE2IHN0cmVhbSA+Pj0gZnVuY3Rpb25cbiAgICB8IFtdIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgICB8IGwgLT5cbiAgICAgIEJ1ZmZlci5jbGVhciBidWY7XG4gICAgICBQcmludGYuYnByaW50ZiBidWYgXCIlMDh4fCAgXCIgIW51bTtcbiAgICAgIG51bSA6PSAhbnVtICsgMTY7XG4gICAgICBsZXQgcmVjIGJ5dGVzIHBvcyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT5cbiAgICAgICAgICBibGFua3MgcG9zXG4gICAgICAgIHwgeCA6OiBsIC0+XG4gICAgICAgICAgaWYgcG9zID0gOCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBidWYgJyAnO1xuICAgICAgICAgIFByaW50Zi5icHJpbnRmIGJ1ZiBcIiUwMnggXCIgKENoYXIuY29kZSB4KTtcbiAgICAgICAgICBieXRlcyAocG9zICsgMSkgbFxuICAgICAgYW5kIGJsYW5rcyBwb3MgPVxuICAgICAgICBpZiBwb3MgPCAxNiB0aGVuIGJlZ2luXG4gICAgICAgICAgaWYgcG9zID0gOCB0aGVuXG4gICAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIgICAgXCJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIgICBcIjtcbiAgICAgICAgICBibGFua3MgKHBvcyArIDEpXG4gICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIGJ5dGVzIDAgbDtcbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIiB8XCI7XG4gICAgICBMaXN0Lml0ZXIgKGZ1biBjaCAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmIChpZiBjaCA+PSAnXFx4MjAnICYmIGNoIDw9ICdcXHg3ZScgdGhlbiBjaCBlbHNlICcuJykpIGw7XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICd8JztcbiAgICAgIEx3dC5yZXR1cm4gKFNvbWUoQnVmZmVyLmNvbnRlbnRzIGJ1ZikpXG4gIGVuZFxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cbigqKiBNb2R1bGUgW0x3dF9yZXN1bHRdOiBleHBsaWNpdCBlcnJvciBoYW5kbGluZyAqKVxuXG5vcGVuIFJlc3VsdFxuXG50eXBlICgrJ2EsICsnYikgdCA9ICgnYSwgJ2IpIFJlc3VsdC50IEx3dC50XG5cbmxldCByZXR1cm4geCA9IEx3dC5yZXR1cm4gKE9rIHgpXG5sZXQgZmFpbCBlID0gTHd0LnJldHVybiAoRXJyb3IgZSlcblxubGV0IGxpZnQgPSBMd3QucmV0dXJuXG5sZXQgb2sgeCA9IEx3dC5tYXAgKGZ1biB5IC0+IE9rIHkpIHhcbmxldCBlcnJvciB4ID0gTHd0Lm1hcCAoZnVuIHkgLT4gRXJyb3IgeSkgeFxuXG5sZXQgbWFwIGYgZSA9XG4gIEx3dC5tYXBcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBFcnJvciBlXG4gICAgICB8IE9rIHggLT4gT2sgKGYgeCkpXG4gICAgZVxuXG5sZXQgbWFwX2Vycm9yIGYgZSA9XG4gIEx3dC5tYXBcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBFcnJvciAoZiBlKVxuICAgICAgfCBPayB4IC0+IE9rIHgpXG4gICAgZVxubGV0IG1hcF9lcnIgZiBlID0gbWFwX2Vycm9yIGYgZVxuXG5sZXQgY2F0Y2ggZSA9XG4gIEx3dC5jYXRjaFxuICAgIChmdW4gKCkgLT4gb2sgKGUgKCkpKVxuICAgIGZhaWxcblxubGV0IGdldF9leG4gZSA9XG4gIEx3dC5iaW5kIGVcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgT2sgeCAtPiBMd3QucmV0dXJuIHhcbiAgICAgIHwgRXJyb3IgZSAtPiBMd3QuZmFpbCBlKVxuXG5sZXQgYmluZCBlIGYgPVxuICBMd3QuYmluZCBlXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gTHd0LnJldHVybiAoRXJyb3IgZSlcbiAgICAgIHwgT2sgeCAtPiBmIHgpXG4gICAgICBcbmxldCBiaW5kX2Vycm9yIGUgZiA9XG4gIEx3dC5iaW5kIGVcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBmIGVcbiAgICAgIHwgT2sgeCAtPiBMd3QucmV0dXJuIChPayB4KSlcbiAgICAgIFxubGV0IGJpbmRfbHd0IGUgZiA9XG4gIEx3dC5iaW5kIGVcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgT2sgeCAtPiBvayAoZiB4KVxuICAgICAgfCBFcnJvciBlIC0+IGZhaWwgZSlcblxubGV0IGJpbmRfcmVzdWx0IGUgZiA9XG4gIEx3dC5tYXBcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBFcnJvciBlXG4gICAgICB8IE9rIHggLT4gZiB4KVxuICAgIGVcblxubGV0IGJpbmRfbHd0X2Vycm9yIGUgZiA9XG4gIEx3dC5iaW5kIGVcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBMd3QuYmluZCAoZiBlKSBmYWlsXG4gICAgICB8IE9rIHggLT4gcmV0dXJuIHgpXG5sZXQgYmluZF9sd3RfZXJyIGUgZiA9IGJpbmRfbHd0X2Vycm9yIGUgZlxuXG5sZXQgYm90aCBhIGIgPVxuICBsZXQgcyA9IHJlZiBOb25lIGluXG4gIGxldCBzZXRfb25jZSBlID1cbiAgICBtYXRjaCAhcyB3aXRoXG4gICAgfCBOb25lIC0+IHM6PSBTb21lIGVcbiAgICB8IFNvbWUgXyAtPiAoKVxuICBpblxuICBsZXQgKGEsYikgPSBtYXBfZXJyb3Igc2V0X29uY2UgYSxtYXBfZXJyb3Igc2V0X29uY2UgYiBpblxuICBsZXQgc29tZV9hc3NlcnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IFNvbWUgZSAtPiBFcnJvciBlXG4gIGluXG4gIEx3dC5tYXBcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgT2sgeCwgT2sgeSAtPiBPayAoeCx5KVxuICAgICAgfCBFcnJvciBfLCBPayBfXG4gICAgICB8IE9rIF8sRXJyb3IgX1xuICAgICAgfCBFcnJvciBfLCBFcnJvciBfIC0+IHNvbWVfYXNzZXJ0ICFzKVxuICAgIChMd3QuYm90aCBhIGIpXG5cbmxldCBpdGVyIGYgciA9XG4gIEx3dC5iaW5kIHJcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgT2sgeCAtPiBmIHhcbiAgICAgIHwgRXJyb3IgXyAtPiBMd3QucmV0dXJuX3VuaXQpXG5cbmxldCBpdGVyX2Vycm9yIGYgciA9XG4gIEx3dC5iaW5kIHJcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBmIGVcbiAgICAgIHwgT2sgXyAtPiBMd3QucmV0dXJuX3VuaXQpXG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKD4+PSkgPSBiaW5kXG4gIGxldCAoPnw9KSBlIGYgPSBtYXAgZiBlXG5lbmRcblxubW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCB0IH5mID0gbWFwIGYgdFxuICAgIGxldCBiaW5kIHQgfmYgPSBiaW5kIHQgZlxuICAgIGxldCBib3RoID0gYm90aFxuICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgU3ludGF4ID0gc3RydWN0XG4gIGxldCAobGV0KikgPSBiaW5kXG4gIGxldCAoYW5kKikgPSBib3RoXG5cbiAgbGV0IChsZXQrKSB4IGYgPSBtYXAgZiB4XG4gIGxldCAoYW5kKykgPSBib3RoXG5lbmRcblxuaW5jbHVkZSBJbmZpeFxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG5zaWdcbiAgdHlwZSB0XG4gIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG5lbmRcblxubW9kdWxlIHR5cGUgUyA9XG5zaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSB0XG4gIHZhbCBlbXB0eTogdFxuICB2YWwgaXNfZW1wdHk6IHQgLT4gYm9vbFxuICB2YWwgYWRkOiBlbHQgLT4gdCAtPiB0XG4gIHZhbCB1bmlvbjogdCAtPiB0IC0+IHRcbiAgdmFsIGZpbmRfbWluOiB0IC0+IGVsdFxuICB2YWwgbG9va3VwX21pbjogdCAtPiBlbHQgb3B0aW9uXG4gIHZhbCByZW1vdmVfbWluOiB0IC0+IHRcbiAgdmFsIHNpemU6IHQgLT4gaW50XG5lbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZWx0ID0gT3JkLnQpID1cbnN0cnVjdFxuICB0eXBlIGVsdCA9IE9yZC50XG5cbiAgdHlwZSB0ID0gdHJlZSBsaXN0XG4gIGFuZCB0cmVlID0gTm9kZSBvZiBlbHQgKiBpbnQgKiB0cmVlIGxpc3RcblxuICBsZXQgcm9vdCAoTm9kZSAoeCwgXywgXykpID0geFxuICBsZXQgcmFuayAoTm9kZSAoXywgciwgXykpID0gclxuICBsZXQgbGluayAoTm9kZSAoeDEsIHIxLCBjMSkgYXMgdDEpIChOb2RlICh4MiwgcjIsIGMyKSBhcyB0MikgPVxuICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeDEgeDIgaW5cbiAgICBpZiBjIDw9IDAgdGhlbiBOb2RlICh4MSwgcjEgKyAxLCB0Mjo6YzEpIGVsc2UgTm9kZSh4MiwgcjIgKyAxLCB0MTo6YzIpXG4gIGxldCByZWMgaW5zIHQgPVxuICAgIGZ1bmN0aW9uXG4gICAgICBbXSAgICAgLT5cbiAgICAgIFt0XVxuICAgIHwgKHQnOjpfKSBhcyB0cyB3aGVuIHJhbmsgdCA8IHJhbmsgdCcgLT5cbiAgICAgIHQ6OnRzXG4gICAgfCB0Jzo6dHMgLT5cbiAgICAgIGlucyAobGluayB0IHQnKSB0c1xuXG4gIGxldCBlbXB0eSA9IFtdXG4gIGxldCBpc19lbXB0eSB0cyA9IHRzID0gW11cbiAgbGV0IGFkZCB4IHRzID0gaW5zIChOb2RlICh4LCAwLCBbXSkpIHRzXG4gIGxldCByZWMgdW5pb24gdHMgdHMnID1cbiAgICBtYXRjaCB0cywgdHMnIHdpdGhcbiAgICAgIChbXSwgXykgLT4gdHMnXG4gICAgfCAoXywgW10pIC0+IHRzXG4gICAgfCAodDE6OnRzMSwgdDI6OnRzMikgIC0+XG4gICAgICBpZiByYW5rIHQxIDwgcmFuayB0MiB0aGVuIHQxIDo6IHVuaW9uIHRzMSAodDI6OnRzMilcbiAgICAgIGVsc2UgaWYgcmFuayB0MiA8IHJhbmsgdDEgdGhlbiB0MiA6OiB1bmlvbiAodDE6OnRzMSkgdHMyXG4gICAgICBlbHNlIGlucyAobGluayB0MSB0MikgKHVuaW9uIHRzMSB0czIpXG5cbiAgbGV0IHJlYyBmaW5kX21pbiA9XG4gICAgZnVuY3Rpb25cbiAgICAgIFtdICAgIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgIHwgW3RdICAgLT4gcm9vdCB0XG4gICAgfCB0Ojp0cyAtPlxuICAgICAgbGV0IHggPSBmaW5kX21pbiB0cyBpblxuICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSAocm9vdCB0KSB4IGluXG4gICAgICBpZiBjIDwgMCB0aGVuIHJvb3QgdCBlbHNlIHhcblxuICBsZXQgcmVjIGxvb2t1cF9taW4gPVxuICAgIGZ1bmN0aW9uXG4gICAgfCBbXSAgICAtPiBOb25lXG4gICAgfCBbdF0gICAtPiBTb21lIChyb290IHQpXG4gICAgfCB0Ojp0cyAtPlxuICAgICAgbWF0Y2ggbG9va3VwX21pbiB0cyB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHggYXMgcmVzdWx0IC0+XG4gICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgKHJvb3QgdCkgeCBpblxuICAgICAgICBpZiBjIDwgMCB0aGVuIFNvbWUgKHJvb3QgdCkgZWxzZSByZXN1bHRcblxuICBsZXQgcmVjIGdldF9taW4gPVxuICAgIGZ1bmN0aW9uXG4gICAgICBbXSAgICAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IFt0XSAgIC0+ICh0LCBbXSlcbiAgICB8IHQ6OnRzIC0+XG4gICAgICBsZXQgKHQnLCB0cycpID0gZ2V0X21pbiB0cyBpblxuICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSAocm9vdCB0KSAocm9vdCB0JykgaW5cbiAgICAgIGlmIGMgPCAwIHRoZW4gKHQsIHRzKSBlbHNlICh0JywgdDo6dHMnKVxuXG4gIGxldCByZW1vdmVfbWluID1cbiAgICBmdW5jdGlvblxuICAgICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgfCB0cyAtPlxuICAgICAgbGV0IChOb2RlIChfLCBfLCBjKSwgdHMpID0gZ2V0X21pbiB0cyBpblxuICAgICAgdW5pb24gKExpc3QucmV2IGMpIHRzXG5cbiAgbGV0IHJlYyBzaXplIGwgPVxuICAgIGxldCBzaXpldHJlZSAoTm9kZSAoXyxfLHRsKSkgPSAxICsgc2l6ZSB0bCBpblxuICAgIExpc3QuZm9sZF9sZWZ0IChmdW4gcyB0IC0+IHMgKyBzaXpldHJlZSB0KSAwIGxcbmVuZFxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG4oKiBBIHN1cnZleSBhbmQgbWVhc3VyZW1lbnRzIG9mIG1vcmUgb3B0aW1pemVkIGltcGxlbWVudGF0aW9ucyBjYW4gYmUgZm91bmQgYXQ6XG5cbiAgICBodHRwczovL2pzdGhvbWFzLmdpdGh1Yi5pby9tYXAtY29tcGFyaXNvbi5odG1sXG5cbiAgIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9wdWxsLzM0Ny4gKilcbmxldCB0YWlsX3JlY3Vyc2l2ZV9tYXAgZiBsID1cbiAgTGlzdC5yZXYgKExpc3QucmV2X21hcCBmIGwpXG5cbmxldCB0YWlsX3JlY3Vyc2l2ZV9tYXBpX3JldiBmIGwgPVxuICBsZXQgcmVjIGlubmVyIGFjYyBpID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQ6OnRsIC0+IChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgKChmIGkgaGQpOjphY2MpIChpICsgMSkgdGxcbiAgaW5cbiAgaW5uZXIgW10gMCBsXG5cbm9wZW4gTHd0LkluZml4XG5cbmxldCByZWMgaXRlcl9zIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybl91bml0XG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IGYgeCA+Pj0gZnVuICgpIC0+XG4gICAgaXRlcl9zIGYgbFxuXG5sZXQgaXRlcl9wIGYgbCA9XG4gIGxldCB0cyA9IExpc3QucmV2X21hcCAoTHd0LmFwcGx5IGYpIGwgaW5cbiAgTHd0LmpvaW4gdHNcblxubGV0IHJlYyBpdGVyaV9zIGkgZiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgKGYgaSkgeCA+Pj0gZnVuICgpIC0+XG4gICAgaXRlcmlfcyAoaSArIDEpIGYgbFxuXG5sZXQgaXRlcmlfcyBmIGwgPSBpdGVyaV9zIDAgZiBsXG5cbmxldCBpdGVyaV9wIGYgbCA9XG4gIGxldCBmJyBpID0gTHd0LmFwcGx5IChmIGkpIGluXG4gIGxldCB0cyA9IHRhaWxfcmVjdXJzaXZlX21hcGlfcmV2IGYnIGwgaW5cbiAgTHd0LmpvaW4gdHNcblxubGV0IG1hcF9zIGYgbCA9XG4gIGxldCByZWMgaW5uZXIgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IExpc3QucmV2IGFjYyB8PiBMd3QucmV0dXJuXG4gICAgfCBoZDo6dGwgLT5cbiAgICAgIEx3dC5hcHBseSBmIGhkID4+PSBmdW4gciAtPlxuICAgICAgKGlubmVyIFtAb2NhbWwudGFpbGNhbGxdKSAocjo6YWNjKSB0bFxuICBpblxuICBpbm5lciBbXSBsXG5cbmxldCByZWMgX2NvbGxlY3RfcmV2IGFjYyA9IGZ1bmN0aW9uXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuIGFjY1xuICB8IHQ6OnRzIC0+XG4gICAgdCA+Pj0gZnVuIGkgLT5cbiAgICAoX2NvbGxlY3RfcmV2IFtAb2NhbWwudGFpbGNhbGxdKSAoaTo6YWNjKSB0c1xuXG5sZXQgbWFwX3AgZiBsID1cbiAgbGV0IHRzID0gTGlzdC5yZXZfbWFwIChMd3QuYXBwbHkgZikgbCBpblxuICBfY29sbGVjdF9yZXYgW10gdHNcblxubGV0IGZpbHRlcl9tYXBfcyBmIGwgPVxuICBsZXQgcmVjIGlubmVyIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAgICAgLT4gTGlzdC5yZXYgYWNjIHw+IEx3dC5yZXR1cm5cbiAgICB8IGhkOjp0bCAtPlxuICAgICAgTHd0LmFwcGx5IGYgaGQgPj49IGZ1bmN0aW9uXG4gICAgICB8IFNvbWUgdiAtPiAoaW5uZXIgW0BvY2FtbC50YWlsY2FsbF0pICh2OjphY2MpIHRsXG4gICAgICB8IE5vbmUgLT4gKGlubmVyIFtAb2NhbWwudGFpbGNhbGxdKSBhY2MgdGxcbiAgaW5cbiAgaW5uZXIgW10gbFxuXG5sZXQgZmlsdGVyX21hcF9wIGYgbCA9XG4gIGxldCByZWMgX2NvbGxlY3Rfb3B0aW9uYWxfcmV2IGFjYyA9IGZ1bmN0aW9uXG4gIHwgW10gICAgLT4gTHd0LnJldHVybiBhY2NcbiAgfCB0Ojp0cyAtPlxuICAgIHQgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIHYgLT4gKF9jb2xsZWN0X29wdGlvbmFsX3JldiBbQG9jYW1sLnRhaWxjYWxsXSkgKHY6OmFjYykgdHNcbiAgICB8IE5vbmUgLT4gKF9jb2xsZWN0X29wdGlvbmFsX3JldiBbQG9jYW1sLnRhaWxjYWxsXSkgYWNjIHRzXG4gIGluXG4gIGxldCB0cyA9IExpc3QucmV2X21hcCAoTHd0LmFwcGx5IGYpIGwgaW5cbiAgX2NvbGxlY3Rfb3B0aW9uYWxfcmV2IFtdIHRzXG5cbmxldCBtYXBpX3MgZiBsID1cbiAgbGV0IHJlYyBpbm5lciBhY2MgaSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAgICAgLT4gTGlzdC5yZXYgYWNjIHw+IEx3dC5yZXR1cm5cbiAgICB8IGhkOjp0bCAtPlxuICAgICAgTHd0LmFwcGx5IChmIGkpIGhkID4+PSBmdW4gdiAtPlxuICAgICAgKGlubmVyIFtAb2NhbWwudGFpbGNhbGxdKSAodjo6YWNjKSAoaSsxKSB0bFxuICBpblxuICBpbm5lciBbXSAwIGxcblxubGV0IG1hcGlfcCBmIGwgPVxuICBsZXQgZicgaSA9IEx3dC5hcHBseSAoZiBpKSBpblxuICBsZXQgdHMgPSB0YWlsX3JlY3Vyc2l2ZV9tYXBpX3JldiBmJyBsIGluXG4gIF9jb2xsZWN0X3JldiBbXSB0c1xuXG5sZXQgcmVjIHJldl9tYXBfYXBwZW5kX3MgYWNjIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybiBhY2NcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgZiB4ID4+PSBmdW4geCAtPlxuICAgIHJldl9tYXBfYXBwZW5kX3MgKHggOjogYWNjKSBmIGxcblxubGV0IHJldl9tYXBfcyBmIGwgPVxuICByZXZfbWFwX2FwcGVuZF9zIFtdIGYgbFxuXG5sZXQgcmVjIHJldl9tYXBfYXBwZW5kX3AgYWNjIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgYWNjXG4gIHwgeCA6OiBsIC0+XG4gICAgcmV2X21hcF9hcHBlbmRfcFxuICAgICAgKEx3dC5hcHBseSBmIHggPj49IGZ1biB4IC0+XG4gICAgICAgYWNjID58PSBmdW4gbCAtPlxuICAgICAgIHggOjogbCkgZiBsXG5cbmxldCByZXZfbWFwX3AgZiBsID1cbiAgcmV2X21hcF9hcHBlbmRfcCBMd3QucmV0dXJuX25pbCBmIGxcblxubGV0IHJlYyBmb2xkX2xlZnRfcyBmIGFjYyBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuIGFjY1xuICB8IHggOjogbCAtPlxuICAgIEx3dC5hcHBseSAoZiBhY2MpIHggPj49IGZ1biBhY2MgLT5cbiAgICAoZm9sZF9sZWZ0X3MgW0BvY2FtbC50YWlsY2FsbF0pIGYgYWNjIGxcblxubGV0IGZvbGRfcmlnaHRfcyBmIGwgYWNjID1cbiAgbGV0IHJlYyBpbm5lciBmIGEgPSBmdW5jdGlvblxuICAgIHwgW10gICAgIC0+IEx3dC5yZXR1cm4gYVxuICAgIHwgaGQ6OnRsIC0+IChMd3QuYXBwbHkgKGYgaGQpIGEpID4+PSBmdW4gYScgLT5cbiAgICAgIChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgZiBhJyB0bFxuICBpblxuICBpbm5lciBmIGFjYyAoTGlzdC5yZXYgbClcblxubGV0IHJlYyBmb3JfYWxsX3MgZiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuX3RydWVcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgZiB4ID4+PSBmdW5jdGlvblxuICAgIHwgdHJ1ZSAtPlxuICAgICAgKGZvcl9hbGxfcyBbQG9jYW1sLnRhaWxjYWxsXSkgZiBsXG4gICAgfCBmYWxzZSAtPlxuICAgICAgTHd0LnJldHVybl9mYWxzZVxuXG5sZXQgZm9yX2FsbF9wIGYgbCA9XG4gIG1hcF9wIGYgbCA+Pj0gZnVuIGJsIC0+IExpc3QuZm9yX2FsbCAoZnVuIHggLT4geCkgYmwgfD4gTHd0LnJldHVyblxuXG5sZXQgcmVjIGV4aXN0c19zIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybl9mYWxzZVxuICB8IHggOjogbCAtPlxuICAgIEx3dC5hcHBseSBmIHggPj49IGZ1bmN0aW9uXG4gICAgfCB0cnVlIC0+XG4gICAgICBMd3QucmV0dXJuX3RydWVcbiAgICB8IGZhbHNlIC0+XG4gICAgICAoZXhpc3RzX3MgW0BvY2FtbC50YWlsY2FsbF0pIGYgbFxuXG5sZXQgZXhpc3RzX3AgZiBsID1cbiAgbWFwX3AgZiBsID4+PSBmdW4gYmwgLT4gTGlzdC5leGlzdHMgKGZ1biB4IC0+IHgpIGJsIHw+IEx3dC5yZXR1cm5cblxubGV0IHJlYyBmaW5kX3MgZiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QuZmFpbCBOb3RfZm91bmRcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgZiB4ID4+PSBmdW5jdGlvblxuICAgIHwgdHJ1ZSAtPlxuICAgICAgTHd0LnJldHVybiB4XG4gICAgfCBmYWxzZSAtPlxuICAgICAgKGZpbmRfcyBbQG9jYW1sLnRhaWxjYWxsXSkgZiBsXG5cbmxldCBfb3B0aW9uYWxpemUgZiB4ID1cbiAgZiB4ID4+PSBmdW4gYiAtPiBpZiBiIHRoZW4gTHd0LnJldHVybiAoU29tZSB4KSBlbHNlIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgZmlsdGVyX3MgZiBsID1cbiAgZmlsdGVyX21hcF9zIChfb3B0aW9uYWxpemUgZikgbFxuXG5sZXQgZmlsdGVyX3AgZiBsID1cbiAgIGZpbHRlcl9tYXBfcCAoX29wdGlvbmFsaXplIGYpIGxcblxubGV0IHBhcnRpdGlvbl9zIGYgbCA9XG4gIGxldCByZWMgaW5uZXIgYWNjMSBhY2MyID0gZnVuY3Rpb25cbiAgICB8IFtdICAgICAtPiBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MxLCBMaXN0LnJldiBhY2MyKVxuICAgIHwgaGQ6OnRsIC0+IEx3dC5hcHBseSBmIGhkID4+PSBmdW4gYiAtPlxuICAgICAgICBpZiBiIHRoZW5cbiAgICAgICAgICBpbm5lciAoaGQ6OmFjYzEpIGFjYzIgdGxcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlubmVyIGFjYzEgKGhkOjphY2MyKSB0bFxuICBpblxuICBpbm5lciBbXSBbXSBsXG5cbmxldCBwYXJ0aXRpb25fcCBmIGwgPVxuICBsZXQgZyB4ID0gTHd0LmFwcGx5IGYgeCA+Pj0gZnVuIGIgLT4gTHd0LnJldHVybiAoYiwgeCkgaW5cbiAgbWFwX3AgZyBsID4+PSBmdW4gdGwgLT5cbiAgbGV0IGdyb3VwMSA9IHRhaWxfcmVjdXJzaXZlX21hcCBzbmQgQEAgTGlzdC5maWx0ZXIgZnN0IHRsIGluXG4gIGxldCBncm91cDIgPVxuICAgIHRhaWxfcmVjdXJzaXZlX21hcCBzbmQgQEAgTGlzdC5maWx0ZXIgKGZ1biB4IC0+IG5vdCBAQCBmc3QgeCkgdGwgaW5cbiAgTHd0LnJldHVybiAoZ3JvdXAxLCBncm91cDIpXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbm9wZW4gTHd0LkluZml4XG5cbnR5cGUgJ2EgdCA9IHtcbiAgY3JlYXRlIDogdW5pdCAtPiAnYSBMd3QudDtcbiAgKCogQ3JlYXRlIGEgbmV3IHBvb2wgbWVtYmVyLiAqKVxuICBjaGVjayA6ICdhIC0+IChib29sIC0+IHVuaXQpIC0+IHVuaXQ7XG4gICgqIENoZWNrIHZhbGlkaXR5IG9mIGEgcG9vbCBtZW1iZXIgd2hlbiB1c2UgcmVzdWx0ZWQgaW4gZmFpbGVkIHByb21pc2UuICopXG4gIHZhbGlkYXRlIDogJ2EgLT4gYm9vbCBMd3QudDtcbiAgKCogVmFsaWRhdGUgYW4gZXhpc3RpbmcgZnJlZSBwb29sIG1lbWJlciBiZWZvcmUgdXNlLiAqKVxuICBkaXNwb3NlIDogJ2EgLT4gdW5pdCBMd3QudDtcbiAgKCogRGlzcG9zZSBvZiBhIHBvb2wgbWVtYmVyLiAqKVxuICBjbGVhcmVkIDogYm9vbCByZWYgcmVmO1xuICAoKiBIYXZlIHRoZSBjdXJyZW50IHBvb2wgZWxlbWVudHMgYmVlbiBjbGVhcmVkIG91dD8gKilcbiAgbWF4IDogaW50O1xuICAoKiBTaXplIG9mIHRoZSBwb29sLiAqKVxuICBtdXRhYmxlIGNvdW50IDogaW50O1xuICAoKiBOdW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHBvb2wuICopXG4gIGxpc3QgOiAnYSBRdWV1ZS50O1xuICAoKiBBdmFpbGFibGUgcG9vbCBtZW1iZXJzLiAqKVxuICB3YWl0ZXJzIDogJ2EgTHd0LnUgTHd0X3NlcXVlbmNlLnQ7XG4gICgqIFByb21pc2UgcmVzb2x2ZXJzIHdhaXRpbmcgZm9yIGEgZnJlZSBtZW1iZXIuICopXG59XG5cbmxldCBjcmVhdGUgbSA/KHZhbGlkYXRlID0gZnVuIF8gLT4gTHd0LnJldHVybl90cnVlKSA/KGNoZWNrID0gZnVuIF8gZiAtPiBmIHRydWUpID8oZGlzcG9zZSA9IGZ1biBfIC0+IEx3dC5yZXR1cm5fdW5pdCkgY3JlYXRlID1cbiAgeyBtYXggPSBtO1xuICAgIGNyZWF0ZSA9IGNyZWF0ZTtcbiAgICB2YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgIGNoZWNrID0gY2hlY2s7XG4gICAgZGlzcG9zZSA9IGRpc3Bvc2U7XG4gICAgY2xlYXJlZCA9IHJlZiAocmVmIGZhbHNlKTtcbiAgICBjb3VudCA9IDA7XG4gICAgbGlzdCA9IFF1ZXVlLmNyZWF0ZSAoKTtcbiAgICB3YWl0ZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSB9XG5cbigqIENyZWF0ZSBhIHBvb2wgbWVtYmVyLiAqKVxubGV0IGNyZWF0ZV9tZW1iZXIgcCA9XG4gIEx3dC5jYXRjaFxuICAgIChmdW4gKCkgLT5cbiAgICAgICAoKiBNdXN0IGJlIGRvbmUgYmVmb3JlIHAuY3JlYXRlIHRvIHByZXZlbnQgb3RoZXIgcmVzb2x2ZXJzIGZyb21cbiAgICAgICAgICBjcmVhdGluZyBuZXcgbWVtYmVycyBpZiB0aGUgbGltaXQgaXMgcmVhY2hlZC4gKilcbiAgICAgICBwLmNvdW50IDwtIHAuY291bnQgKyAxO1xuICAgICAgIHAuY3JlYXRlICgpKVxuICAgIChmdW4gZXhuIC0+XG4gICAgICAgKCogQ3JlYXRpb24gZmFpbGVkLCBzbyBkb24ndCBpbmNyZW1lbnQgY291bnQuICopXG4gICAgICAgcC5jb3VudCA8LSBwLmNvdW50IC0gMTtcbiAgICAgICBMd3QuZmFpbCBleG4pXG5cbigqIFJlbGVhc2UgYSBwb29sIG1lbWJlci4gKilcbmxldCByZWxlYXNlIHAgYyA9XG4gIG1hdGNoIEx3dF9zZXF1ZW5jZS50YWtlX29wdF9sIHAud2FpdGVycyB3aXRoXG4gIHwgU29tZSB3YWtlbmVyIC0+XG4gICAgKCogQSBwcm9taXNlIHJlc29sdmVyIGlzIHdhaXRpbmcsIGdpdmUgaXQgdGhlIHBvb2wgbWVtYmVyLiAqKVxuICAgIEx3dC53YWtldXBfbGF0ZXIgd2FrZW5lciBjXG4gIHwgTm9uZSAtPlxuICAgICgqIE5vIG9uZSBpcyB3YWl0aW5nLCBxdWV1ZSBpdC4gKilcbiAgICBRdWV1ZS5wdXNoIGMgcC5saXN0XG5cbigqIERpc3Bvc2Ugb2YgYSBwb29sIG1lbWJlci4gKilcbmxldCBkaXNwb3NlIHAgYyA9XG4gIHAuZGlzcG9zZSBjID4+PSBmdW4gKCkgLT5cbiAgcC5jb3VudCA8LSBwLmNvdW50IC0gMTtcbiAgTHd0LnJldHVybl91bml0XG5cbigqIENyZWF0ZSBhIG5ldyBtZW1iZXIgd2hlbiBvbmUgaXMgdGhyb3duIGF3YXkuICopXG5sZXQgcmVwbGFjZV9kaXNwb3NlZCBwID1cbiAgbWF0Y2ggTHd0X3NlcXVlbmNlLnRha2Vfb3B0X2wgcC53YWl0ZXJzIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgKCogTm8gb25lIGlzIHdhaXRpbmcsIGRvIG5vdCBjcmVhdGUgYSBuZXcgbWVtYmVyIHRvIGF2b2lkXG4gICAgICAgbG9zaW5nIGFuIGVycm9yIGlmIGNyZWF0aW9uIGZhaWxzLiAqKVxuICAgICgpXG4gIHwgU29tZSB3YWtlbmVyIC0+XG4gICAgTHd0Lm9uX2FueVxuICAgICAgKEx3dC5hcHBseSBwLmNyZWF0ZSAoKSlcbiAgICAgIChmdW4gYyAtPlxuICAgICAgICAgTHd0Lndha2V1cF9sYXRlciB3YWtlbmVyIGMpXG4gICAgICAoZnVuIGV4biAtPlxuICAgICAgICAgKCogQ3JlYXRpb24gZmFpbGVkLCBub3RpZnkgdGhlIHdhaXRlciBvZiB0aGUgZmFpbHVyZS4gKilcbiAgICAgICAgIEx3dC53YWtldXBfbGF0ZXJfZXhuIHdha2VuZXIgZXhuKVxuXG4oKiBWZXJpZnkgYSBtZW1iZXIgaXMgc3RpbGwgdmFsaWQgYmVmb3JlIHVzaW5nIGl0LiAqKVxubGV0IHZhbGlkYXRlX2FuZF9yZXR1cm4gcCBjID1cbiAgTHd0LnRyeV9iaW5kXG4gICAgICAoZnVuICgpIC0+XG4gICAgICAgICBwLnZhbGlkYXRlIGMpXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgTHd0LnJldHVybiBjXG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICAoKiBSZW1vdmUgdGhpcyBtZW1iZXIgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuICopXG4gICAgICAgICAgZGlzcG9zZSBwIGMgPj49IGZ1biAoKSAtPlxuICAgICAgICAgIGNyZWF0ZV9tZW1iZXIgcClcbiAgICAgIChmdW4gZSAtPlxuICAgICAgICAgKCogVmFsaWRhdGlvbiBmYWlsZWQ6IGNyZWF0ZSBhIG5ldyBtZW1iZXIgaWYgYXQgbGVhc3Qgb25lXG4gICAgICAgICAgICByZXNvbHZlciBpcyB3YWl0aW5nLiAqKVxuICAgICAgICAgZGlzcG9zZSBwIGMgPj49IGZ1biAoKSAtPlxuICAgICAgICAgcmVwbGFjZV9kaXNwb3NlZCBwO1xuICAgICAgICAgTHd0LnJlcmFpc2UgZSlcblxuKCogQWNxdWlyZSBhIHBvb2wgbWVtYmVyLiAqKVxubGV0IGFjcXVpcmUgcCA9XG4gIGlmIFF1ZXVlLmlzX2VtcHR5IHAubGlzdCB0aGVuXG4gICAgKCogTm8gbW9yZSBhdmFpbGFibGUgbWVtYmVyLiAqKVxuICAgIGlmIHAuY291bnQgPCBwLm1heCB0aGVuXG4gICAgICAoKiBMaW1pdCBub3QgcmVhY2hlZDogY3JlYXRlIGEgbmV3IG9uZS4gKilcbiAgICAgIGNyZWF0ZV9tZW1iZXIgcFxuICAgIGVsc2VcbiAgICAgICgqIExpbWl0IHJlYWNoZWQ6IHdhaXQgZm9yIGEgZnJlZSBvbmUuICopXG4gICAgICAoTHd0LmFkZF90YXNrX3IgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl0pIHAud2FpdGVycyA+Pj0gdmFsaWRhdGVfYW5kX3JldHVybiBwXG4gIGVsc2VcbiAgICAoKiBUYWtlIHRoZSBmaXJzdCBmcmVlIG1lbWJlciBhbmQgdmFsaWRhdGUgaXQuICopXG4gICAgbGV0IGMgPSBRdWV1ZS50YWtlIHAubGlzdCBpblxuICAgIHZhbGlkYXRlX2FuZF9yZXR1cm4gcCBjXG5cbigqIFJlbGVhc2UgYSBtZW1iZXIgd2hlbiB1c2UgcmVzdWx0ZWQgaW4gZmFpbGVkIHByb21pc2UgaWYgdGhlIG1lbWJlclxuICAgaXMgc3RpbGwgdmFsaWQuICopXG5sZXQgY2hlY2tfYW5kX3JlbGVhc2UgcCBjIGNsZWFyZWQgPVxuICBsZXQgb2sgPSByZWYgZmFsc2UgaW5cbiAgcC5jaGVjayBjIChmdW4gcmVzdWx0IC0+IG9rIDo9IHJlc3VsdCk7XG4gIGlmIGNsZWFyZWQgfHwgbm90ICFvayB0aGVuIChcbiAgICAoKiBFbGVtZW50IGlzIG5vdCBvayBvciB0aGUgcG9vbCB3YXMgY2xlYXJlZCAtIGRpc3Bvc2Ugb2YgaXQgKilcbiAgICBkaXNwb3NlIHAgY1xuICApXG4gIGVsc2UgKFxuICAgICgqIEVsZW1lbnQgaXMgb2sgLSByZWxlYXNlIGl0IGJhY2sgdG8gdGhlIHBvb2wgKilcbiAgICByZWxlYXNlIHAgYztcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgKVxuXG5sZXQgdXNlIHAgZiA9XG4gIGFjcXVpcmUgcCA+Pj0gZnVuIGMgLT5cbiAgKCogQ2FwdHVyZSB0aGUgY3VycmVudCBjbGVhcmVkIHN0YXRlIHNvIHdlIGNhbiBzZWUgaWYgaXQgY2hhbmdlcyB3aGlsZSB0aGlzXG4gICAgIGVsZW1lbnQgaXMgaW4gdXNlICopXG4gIGxldCBjbGVhcmVkID0gIShwLmNsZWFyZWQpIGluXG4gIGxldCBwcm9taXNlID1cbiAgICBMd3QuY2F0Y2hcbiAgICAgIChmdW4gKCkgLT4gZiBjKVxuICAgICAgKGZ1biBlIC0+XG4gICAgICAgICBjaGVja19hbmRfcmVsZWFzZSBwIGMgIWNsZWFyZWQgPj49IGZ1biAoKSAtPlxuICAgICAgICAgTHd0LmZhaWwgZSlcbiAgaW5cbiAgcHJvbWlzZSA+Pj0gZnVuIF8gLT5cbiAgaWYgIWNsZWFyZWQgdGhlbiAoXG4gICAgKCogcCB3YXMgY2xlYXJlZCB3aGlsZSBwcm9taXNlIHdhcyByZXNvbHZpbmcgLSBkaXNwb3NlIG9mIHRoaXMgZWxlbWVudCAqKVxuICAgIGRpc3Bvc2UgcCBjID4+PSBmdW4gKCkgLT5cbiAgICBwcm9taXNlXG4gIClcbiAgZWxzZSAoXG4gICAgcmVsZWFzZSBwIGM7XG4gICAgcHJvbWlzZVxuICApXG5cbmxldCBjbGVhciBwID1cbiAgbGV0IGVsZW1lbnRzID0gUXVldWUuZm9sZCAoZnVuIGwgZWxlbWVudCAtPiBlbGVtZW50IDo6IGwpIFtdIHAubGlzdCBpblxuICBRdWV1ZS5jbGVhciBwLmxpc3Q7XG4gICgqIEluZGljYXRlIHRvIGFueSBjdXJyZW50bHkgaW4tdXNlIGVsZW1lbnRzIHRoYXQgd2UgY2xlYXJlZCB0aGUgcG9vbCAqKVxuICBsZXQgb2xkX2NsZWFyZWQgPSAhKHAuY2xlYXJlZCkgaW5cbiAgb2xkX2NsZWFyZWQgOj0gdHJ1ZTtcbiAgcC5jbGVhcmVkIDo9IHJlZiBmYWxzZTtcbiAgTHd0X2xpc3QuaXRlcl9zIChkaXNwb3NlIHApIGVsZW1lbnRzXG5cbmxldCB3YWl0X3F1ZXVlX2xlbmd0aCBwID0gTHd0X3NlcXVlbmNlLmxlbmd0aCBwLndhaXRlcnNcbiIsIigqIE9DYW1sIHByb21pc2UgbGlicmFyeVxuICogaHR0cHM6Ly9vY3NpZ2VuLm9yZy9sd3RcbiAqIENvcHlyaWdodCAoYykgMjAwOSwgTWV0YXdlYiBUZWNobm9sb2dpZXMsIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgTUVUQVdFQiBURUNITk9MT0dJRVMgYGBBUyBJUycnIEFORCBBTllcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIE1FVEFXRUIgVEVDSE5PTE9HSUVTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SXG4gKiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFXG4gKiBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOXG4gKiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqKVxuXG4oKiBUaGlzIGNvZGUgaXMgYWRhcHRlZCBmcm9tXG4gICBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDEwMDEyMTU0MjUvaHR0cDovL2VpZ2VuY2xhc3Mub3JnOjgwL2hpa2kvbGlnaHR3ZWlnaHQtdGhyZWFkcy13aXRoLWx3dC4gKilcblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIG12YXJfY29udGVudHMgOiAnYSBvcHRpb247XG4gICgqIEN1cnJlbnQgY29udGVudHMgKilcblxuICB3cml0ZXJzIDogKCdhICogdW5pdCBMd3QudSkgTHd0X3NlcXVlbmNlLnQ7XG4gICgqIFRocmVhZHMgd2FpdGluZyB0byBwdXQgYSB2YWx1ZSAqKVxuXG4gIHJlYWRlcnMgOiAnYSBMd3QudSBMd3Rfc2VxdWVuY2UudDtcbiAgKCogVGhyZWFkcyB3YWl0aW5nIGZvciBhIHZhbHVlICopXG59XG5cbmxldCBjcmVhdGVfZW1wdHkgKCkgPVxuICB7IG12YXJfY29udGVudHMgPSBOb25lO1xuICAgIHdyaXRlcnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpO1xuICAgIHJlYWRlcnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIH1cblxubGV0IGNyZWF0ZSB2ID1cbiAgeyBtdmFyX2NvbnRlbnRzID0gU29tZSB2O1xuICAgIHdyaXRlcnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpO1xuICAgIHJlYWRlcnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIH1cblxubGV0IHB1dCBtdmFyIHYgPVxuICBtYXRjaCBtdmFyLm12YXJfY29udGVudHMgd2l0aFxuICB8IE5vbmUgLT5cbiAgICBiZWdpbiBtYXRjaCBMd3Rfc2VxdWVuY2UudGFrZV9vcHRfbCBtdmFyLnJlYWRlcnMgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG12YXIubXZhcl9jb250ZW50cyA8LSBTb21lIHZcbiAgICAgIHwgU29tZSB3IC0+XG4gICAgICAgIEx3dC53YWtldXBfbGF0ZXIgdyB2XG4gICAgZW5kO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICB8IFNvbWUgXyAtPlxuICAgIGxldCAocmVzLCB3KSA9IEx3dC50YXNrICgpIGluXG4gICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX3IgKHYsIHcpIG12YXIud3JpdGVycyBpblxuICAgIEx3dC5vbl9jYW5jZWwgcmVzIChmdW4gXyAtPiBMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGUpO1xuICAgIHJlc1xuXG5sZXQgbmV4dF93cml0ZXIgbXZhciA9XG4gIG1hdGNoIEx3dF9zZXF1ZW5jZS50YWtlX29wdF9sIG12YXIud3JpdGVycyB3aXRoXG4gIHwgU29tZSh2JywgdykgLT5cbiAgICBtdmFyLm12YXJfY29udGVudHMgPC0gU29tZSB2JztcbiAgICBMd3Qud2FrZXVwX2xhdGVyIHcgKClcbiAgfCBOb25lIC0+XG4gICAgbXZhci5tdmFyX2NvbnRlbnRzIDwtIE5vbmVcblxubGV0IHRha2VfYXZhaWxhYmxlIG12YXIgPVxuICBtYXRjaCBtdmFyLm12YXJfY29udGVudHMgd2l0aFxuICB8IFNvbWUgdiAtPlxuICAgIG5leHRfd3JpdGVyIG12YXI7XG4gICAgU29tZSB2XG4gIHwgTm9uZSAtPlxuICAgIE5vbmVcblxubGV0IHRha2UgbXZhciA9XG4gIG1hdGNoIHRha2VfYXZhaWxhYmxlIG12YXIgd2l0aFxuICB8IFNvbWUgdiAtPiBMd3QucmV0dXJuIHZcbiAgfCBOb25lIC0+IChMd3QuYWRkX3Rhc2tfciBbQG9jYW1sLndhcm5pbmcgXCItM1wiXSkgbXZhci5yZWFkZXJzXG5cbmxldCBpc19lbXB0eSBtdmFyID1cbiAgbWF0Y2ggbXZhci5tdmFyX2NvbnRlbnRzIHdpdGhcbiAgfCBTb21lIF8gLT4gZmFsc2VcbiAgfCBOb25lIC0+IHRydWVcbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxub3BlbiBMd3QuSW5maXhcblxudHlwZSB0ID0geyBtdXRhYmxlIGxvY2tlZCA6IGJvb2w7IHdhaXRlcnMgOiB1bml0IEx3dC51IEx3dF9zZXF1ZW5jZS50ICB9XG5cbmxldCBjcmVhdGUgKCkgPSB7IGxvY2tlZCA9IGZhbHNlOyB3YWl0ZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSB9XG5cbmxldCBsb2NrIG0gPVxuICBpZiBtLmxvY2tlZCB0aGVuXG4gICAgKEx3dC5hZGRfdGFza19yIFtAb2NhbWwud2FybmluZyBcIi0zXCJdKSBtLndhaXRlcnNcbiAgZWxzZSBiZWdpblxuICAgIG0ubG9ja2VkIDwtIHRydWU7XG4gICAgTHd0LnJldHVybl91bml0XG4gIGVuZFxuXG5sZXQgdW5sb2NrIG0gPVxuICBpZiBtLmxvY2tlZCB0aGVuIGJlZ2luXG4gICAgaWYgTHd0X3NlcXVlbmNlLmlzX2VtcHR5IG0ud2FpdGVycyB0aGVuXG4gICAgICBtLmxvY2tlZCA8LSBmYWxzZVxuICAgIGVsc2VcbiAgICAgICgqIFdlIGRvIG5vdCB1c2UgW0x3dC53YWtldXBdIGhlcmUgdG8gYXZvaWQgYSBzdGFjayBvdmVyZmxvd1xuICAgICAgICAgd2hlbiB1bmxvY2tpbmcgYSBsb3Qgb2YgdGhyZWFkcy4gKilcbiAgICAgIEx3dC53YWtldXBfbGF0ZXIgKEx3dF9zZXF1ZW5jZS50YWtlX2wgbS53YWl0ZXJzKSAoKVxuICBlbmRcblxubGV0IHdpdGhfbG9jayBtIGYgPVxuICBsb2NrIG0gPj49IGZ1biAoKSAtPlxuICBMd3QuZmluYWxpemUgZiAoZnVuICgpIC0+IHVubG9jayBtOyBMd3QucmV0dXJuX3VuaXQpXG5cbmxldCBpc19sb2NrZWQgbSA9IG0ubG9ja2VkXG5sZXQgaXNfZW1wdHkgbSA9IEx3dF9zZXF1ZW5jZS5pc19lbXB0eSBtLndhaXRlcnNcbiIsIigqIE9DYW1sIHByb21pc2UgbGlicmFyeVxuICogaHR0cHM6Ly9vY3NpZ2VuLm9yZy9sd3RcbiAqIENvcHlyaWdodCAoYykgMjAwOSwgTWV0YXdlYiBUZWNobm9sb2dpZXMsIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgTUVUQVdFQiBURUNITk9MT0dJRVMgYGBBUyBJUycnIEFORCBBTllcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIE1FVEFXRUIgVEVDSE5PTE9HSUVTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SXG4gKiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFXG4gKiBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOXG4gKiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqKVxuXG4oKiBbTHd0X3NlcXVlbmNlXSBpcyBkZXByZWNhdGVkIOKAkyB3ZSBkb24ndCB3YW50IHVzZXJzIG91dHNpZGUgTHd0IHVzaW5nIGl0LlxuICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgdXNlZCBpbnRlcm5hbGx5IGJ5IEx3dC4gU28sIGJyaWVmbHkgZGlzYWJsZSB3YXJuaW5nIDNcbiAgIChcImRlcHJlY2F0ZWRcIiksIGFuZCBjcmVhdGUgYSBsb2NhbCwgbm9uLWRlcHJlY2F0ZWQgYWxpYXMgZm9yXG4gICBbTHd0X3NlcXVlbmNlXSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBieSB0aGUgcmVzdCBvZiB0aGUgY29kZSBpbiB0aGlzXG4gICBtb2R1bGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFueSBtb3JlIHdhcm5pbmdzLiAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubW9kdWxlIEx3dF9zZXF1ZW5jZSA9IEx3dF9zZXF1ZW5jZVxuW0BAQG9jYW1sLndhcm5pbmcgXCIrM1wiXVxuXG50eXBlICdhIHQgPSAnYSBMd3QudSBMd3Rfc2VxdWVuY2UudFxuXG5sZXQgY3JlYXRlID0gTHd0X3NlcXVlbmNlLmNyZWF0ZVxuXG5sZXQgd2FpdCA/bXV0ZXggY3ZhciA9XG4gIGxldCB3YWl0ZXIgPSAoTHd0LmFkZF90YXNrX3IgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl0pIGN2YXIgaW5cbiAgbGV0ICgpID1cbiAgICBtYXRjaCBtdXRleCB3aXRoXG4gICAgfCBTb21lIG0gLT4gTHd0X211dGV4LnVubG9jayBtXG4gICAgfCBOb25lIC0+ICgpXG4gIGluXG4gIEx3dC5maW5hbGl6ZVxuICAgIChmdW4gKCkgLT4gd2FpdGVyKVxuICAgIChmdW4gKCkgLT5cbiAgICAgICBtYXRjaCBtdXRleCB3aXRoXG4gICAgICAgfCBTb21lIG0gLT4gTHd0X211dGV4LmxvY2sgbVxuICAgICAgIHwgTm9uZSAtPiBMd3QucmV0dXJuX3VuaXQpXG5cbmxldCBzaWduYWwgY3ZhciBhcmcgPVxuICB0cnlcbiAgICBMd3Qud2FrZXVwX2xhdGVyIChMd3Rfc2VxdWVuY2UudGFrZV9sIGN2YXIpIGFyZ1xuICB3aXRoIEx3dF9zZXF1ZW5jZS5FbXB0eSAtPlxuICAgICgpXG5cbmxldCBicm9hZGNhc3QgY3ZhciBhcmcgPVxuICBsZXQgd2FrZW5lcnMgPSBMd3Rfc2VxdWVuY2UuZm9sZF9yIChmdW4geCBsIC0+IHggOjogbCkgY3ZhciBbXSBpblxuICBMd3Rfc2VxdWVuY2UuaXRlcl9ub2RlX2wgTHd0X3NlcXVlbmNlLnJlbW92ZSBjdmFyO1xuICBMaXN0Lml0ZXIgKGZ1biB3YWtlbmVyIC0+IEx3dC53YWtldXBfbGF0ZXIgd2FrZW5lciBhcmcpIHdha2VuZXJzXG5cbmxldCBicm9hZGNhc3RfZXhuIGN2YXIgZXhuID1cbiAgbGV0IHdha2VuZXJzID0gTHd0X3NlcXVlbmNlLmZvbGRfciAoZnVuIHggbCAtPiB4IDo6IGwpIGN2YXIgW10gaW5cbiAgTHd0X3NlcXVlbmNlLml0ZXJfbm9kZV9sIEx3dF9zZXF1ZW5jZS5yZW1vdmUgY3ZhcjtcbiAgTGlzdC5pdGVyIChmdW4gd2FrZW5lciAtPiBMd3Qud2FrZXVwX2xhdGVyX2V4biB3YWtlbmVyIGV4bikgd2FrZW5lcnNcbiJdfQ==
