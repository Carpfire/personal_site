// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Stream
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Bytes, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = ")",
    cst$4 = ", ",
    cst_stream_ml = "stream.ml",
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "}",
    cst$0 = cst$4,
    cst$1 = cst$5,
    cst$2 = cst$4,
    cst$3 = cst$5,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Failure = [248, "Stream.Failure", caml_fresh_oo_id(0)],
    Error = [248, "Stream.Error", caml_fresh_oo_id(0)],
    _a_ = [0, cst_stream_ml, 53, 12],
    _b_ = [0, 0],
    _c_ = [0, cst_stream_ml, 82, 12],
    cst_count = "{count = ",
    cst_data = "; data = ",
    cst_Sempty = "Sempty",
    cst_Scons = "Scons (",
    cst_Sapp = "Sapp (",
    cst_Slazy = "Slazy",
    cst_Sgen = "Sgen",
    cst_Sbuffio = "Sbuffio";
   function count(param){
    if(! param) return 0;
    var count = param[1][1];
    return count;
   }
   function data(param){
    if(! param) return 0;
    var data = param[1][2];
    return data;
   }
   function fill_buff(b){
    b[3] = caml_call4(Stdlib[84], b[1], b[2], 0, caml_ml_bytes_length(b[2]));
    b[4] = 0;
    return;
   }
   function get_data(count, d){
    var d$0 = d;
    for(;;){
     if(typeof d$0 !== "number")
      switch(d$0[0]){
        case 1:
         var d2 = d$0[2], d1 = d$0[1], match = get_data(count, d1);
         if(typeof match === "number"){var d$0 = d2; continue;}
         if(0 !== match[0])
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         var d11 = match[2], a = match[1];
         return [0, a, [1, d11, d2]];
        case 2:
         var f = d$0[1], _l_ = caml_obj_tag(f);
         a:
         if(250 === _l_)
          var d$1 = f[1];
         else{
          if(246 !== _l_ && 244 !== _l_){var d$1 = f; break a;}
          var d$1 = caml_call1(CamlinternalLazy[2], f);
         }
         var d$0 = d$1;
         continue;
        case 3:
         var g = d$0[1], _m_ = g[1];
         if(_m_){
          var match$0 = _m_[1];
          if(! match$0) return 0;
          var a$0 = match$0[1];
          g[1] = 0;
          return [0, a$0, d$0];
         }
         var match$1 = caml_call1(g[2], count);
         if(match$1){var a$1 = match$1[1]; return [0, a$1, d$0];}
         g[1] = _b_;
         return 0;
        case 4:
         var b = d$0[1];
         if(b[3] <= b[4]) fill_buff(b);
         if(0 === b[3]) return 0;
         var r = caml_bytes_unsafe_get(b[2], b[4]);
         b[4] = b[4] + 1 | 0;
         return [0, r, d$0];
      }
     return d$0;
    }
   }
   function peek_data(s){
    for(;;){
     var match = s[2];
     if(typeof match === "number") return 0;
     switch(match[0]){
       case 0:
        var a = match[1]; return [0, a];
       case 1:
        var d = get_data(s[1], s[2]);
        if(typeof d === "number") return 0;
        if(0 !== d[0])
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        var a$0 = d[1];
        s[2] = d;
        return [0, a$0];
       case 2:
        var f = match[1], _j_ = caml_obj_tag(f);
        a:
        if(250 === _j_)
         var _k_ = f[1];
        else{
         if(246 !== _j_ && 244 !== _j_){var _k_ = f; break a;}
         var _k_ = caml_call1(CamlinternalLazy[2], f);
        }
        s[2] = _k_;
        break;
       case 3:
        var g = match[1], match$0 = g[1];
        if(match$0){var a$1 = match$0[1]; return a$1;}
        var x = caml_call1(g[2], s[1]);
        g[1] = [0, x];
        return x;
       default:
        var b = match[1];
        if(b[3] <= b[4]) fill_buff(b);
        return 0 === b[3]
                ? (s[2] = 0, 0)
                : [0, caml_bytes_unsafe_get(b[2], b[4])];
     }
    }
   }
   function peek(param){
    if(! param) return 0;
    var s = param[1];
    return peek_data(s);
   }
   function junk_data(s){
    for(;;){
     var match = s[2];
     if(typeof match !== "number")
      switch(match[0]){
        case 0:
         var d = match[2]; s[1] = s[1] + 1 | 0; s[2] = d; return 0;
        case 3:
         var g = match[1];
         if(g[1]){s[1] = s[1] + 1 | 0; g[1] = 0; return 0;}
         break;
        case 4:
         var b = match[1];
         if(b[3] <= b[4]) fill_buff(b);
         return 0 === b[3]
                 ? (s[2] = 0, 0)
                 : (s[1] = s[1] + 1 | 0, b[4] = b[4] + 1 | 0, 0);
      }
     if(! peek_data(s)) return 0;
    }
   }
   function junk(param){
    if(! param) return 0;
    var data = param[1];
    return junk_data(data);
   }
   function nget_data(n, s){
    if(0 >= n) return [0, 0, s[2], 0];
    var match = peek_data(s);
    if(! match) return [0, 0, s[2], 0];
    var a = match[1];
    junk_data(s);
    var
     match$0 = nget_data(n - 1 | 0, s),
     k = match$0[3],
     d = match$0[2],
     al = match$0[1];
    return [0, [0, a, al], [0, a, d], k + 1 | 0];
   }
   function npeek(n, param){
    if(! param) return 0;
    var
     d$0 = param[1],
     match = nget_data(n, d$0),
     len = match[3],
     d = match[2],
     al = match[1];
    d$0[1] = d$0[1] - len | 0;
    d$0[2] = d;
    return al;
   }
   function next(s){
    var match = peek(s);
    if(! match) throw caml_maybe_attach_backtrace(Failure, 1);
    var a = match[1];
    junk(s);
    return a;
   }
   function empty(s){
    if(peek(s)) throw caml_maybe_attach_backtrace(Failure, 1);
    return 0;
   }
   function iter(f, strm){
    for(;;){
     var match = peek(strm);
     if(! match) return 0;
     var a = match[1];
     junk(strm);
     caml_call1(f, a);
    }
   }
   function from(f){return [0, [0, 0, [3, [0, 0, f]]]];}
   function of_list(l){
    var _h_ = 0;
    function _i_(x, l){return [0, x, l];}
    return [0, [0, 0, caml_call3(Stdlib_List[27], _i_, l, _h_)]];
   }
   function of_string(s){
    var count = [0, 0];
    return from
            (function(param){
              var c = count[1];
              return c < runtime.caml_ml_string_length(s)
                      ? (count[1]++, [0, runtime.caml_string_get(s, c)])
                      : 0;
             });
   }
   function of_bytes(s){
    var count = [0, 0];
    return from
            (function(param){
              var c = count[1];
              return c < caml_ml_bytes_length(s)
                      ? (count[1]++, [0, runtime.caml_bytes_get(s, c)])
                      : 0;
             });
   }
   function of_channel(ic){
    return [0, [0, 0, [4, [0, ic, runtime.caml_create_bytes(4096), 0, 0]]]];
   }
   function iapp(i, s){
    var _g_ = data(s);
    return [0, [0, 0, [1, data(i), _g_]]];
   }
   function icons(i, s){return [0, [0, 0, [0, i, data(s)]]];}
   function ising(i){return [0, [0, 0, [0, i, 0]]];}
   function lapp(f, s){
    return [0,
            [0,
             0,
             [2,
              [246,
               function(param){
                var _f_ = data(s);
                return [1, data(caml_call1(f, 0)), _f_];
               }]]]];
   }
   function lcons(f, s){
    return [0,
            [0,
             0,
             [2,
              [246,
               function(param){
                var _e_ = data(s);
                return [0, caml_call1(f, 0), _e_];
               }]]]];
   }
   function lsing(f){
    return [0,
            [0,
             0,
             [2, [246, function(param){return [0, caml_call1(f, 0), 0];}]]]];
   }
   var sempty = 0;
   function slazy(f){
    return [0,
            [0,
             0,
             [2, [246, function(param){return data(caml_call1(f, 0));}]]]];
   }
   function dump(f, s){
    caml_call1(Stdlib[42], cst_count);
    var _d_ = count(s);
    caml_call1(Stdlib[44], _d_);
    caml_call1(Stdlib[42], cst_data);
    dump_data(f, data(s));
    caml_call1(Stdlib[42], cst);
    return caml_call1(Stdlib[47], 0);
   }
   function dump_data(f, param){
    if(typeof param === "number") return caml_call1(Stdlib[42], cst_Sempty);
    switch(param[0]){
      case 0:
       var d = param[2], a = param[1];
       caml_call1(Stdlib[42], cst_Scons);
       caml_call1(f, a);
       caml_call1(Stdlib[42], cst$0);
       dump_data(f, d);
       return caml_call1(Stdlib[42], cst$1);
      case 1:
       var d2 = param[2], d1 = param[1];
       caml_call1(Stdlib[42], cst_Sapp);
       dump_data(f, d1);
       caml_call1(Stdlib[42], cst$2);
       dump_data(f, d2);
       return caml_call1(Stdlib[42], cst$3);
      case 2:
       return caml_call1(Stdlib[42], cst_Slazy);
      case 3:
       return caml_call1(Stdlib[42], cst_Sgen);
      default: return caml_call1(Stdlib[42], cst_Sbuffio);
    }
   }
   var
    Stream =
      [0,
       Failure,
       Error,
       from,
       of_list,
       of_string,
       of_bytes,
       of_channel,
       iter,
       next,
       empty,
       peek,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
   runtime.caml_register_global(22, Stream, "Stream");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Genlex
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Char, Stdlib__Hashtbl, Stdlib__List, Stdlib__String, Stream
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = "",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = cst$5,
    cst$0 = cst$5,
    cst$1 = cst$5,
    cst$2 = cst$5,
    cst$4 = cst$5,
    cst$3 = cst$5,
    Stream = global_data.Stream,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    initial_buffer = caml_create_bytes(32),
    buffer = [0, initial_buffer],
    bufpos = [0, 0],
    cst_Illegal_character = "Illegal character ";
   function reset_buffer(param){
    buffer[1] = initial_buffer;
    bufpos[1] = 0;
    return;
   }
   function store(c){
    if(runtime.caml_ml_bytes_length(buffer[1]) <= bufpos[1]){
     var newbuffer = caml_create_bytes(2 * bufpos[1] | 0);
     caml_call5(Stdlib_Bytes[11], buffer[1], 0, newbuffer, 0, bufpos[1]);
     buffer[1] = newbuffer;
    }
    runtime.caml_bytes_set(buffer[1], bufpos[1], c);
    bufpos[1]++;
    return;
   }
   function get_string(param){
    var s = caml_call3(Stdlib_Bytes[8], buffer[1], 0, bufpos[1]);
    buffer[1] = initial_buffer;
    return s;
   }
   function make_lexer(keywords){
    var kwd_table = caml_call2(Stdlib_Hashtbl[1], 0, 17);
    function _a_(s){
     return caml_call3(Stdlib_Hashtbl[5], kwd_table, s, [0, s]);
    }
    caml_call2(Stdlib_List[18], _a_, keywords);
    function ident_or_keyword(id){
     try{var _u_ = caml_call2(Stdlib_Hashtbl[6], kwd_table, id); return _u_;}
     catch(_v_){
      var _t_ = caml_wrap_exception(_v_);
      if(_t_ === Stdlib[8]) return [1, id];
      throw caml_maybe_attach_backtrace(_t_, 0);
     }
    }
    function keyword_or_error(c){
     var s = caml_call2(Stdlib_String[1], 1, c);
     try{var _r_ = caml_call2(Stdlib_Hashtbl[6], kwd_table, s); return _r_;}
     catch(_s_){
      var _p_ = caml_wrap_exception(_s_);
      if(_p_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_p_, 0);
      var _q_ = caml_call2(Stdlib[28], cst_Illegal_character, s);
      throw caml_maybe_attach_backtrace([0, Stream[2], _q_], 1);
     }
    }
    function next_token(strm){
     for(;;){
      var match = caml_call1(Stream[11], strm);
      if(! match) return 0;
      var c = match[1];
      a:
      {
       b:
       {
        if(124 <= c){
         if(127 <= c){if(192 <= c) break a; break b;}
         if(125 === c) break b;
        }
        else{
         var _f_ = c - 65 | 0;
         if(57 < _f_ >>> 0){
          if(58 <= _f_) break b;
          switch(_f_ + 65 | 0){
            case 34:
             caml_call1(Stream[12], strm);
             reset_buffer(0);
             for(;;){
              var match$3 = caml_call1(Stream[11], strm);
              if(! match$3) throw caml_maybe_attach_backtrace(Stream[1], 1);
              var c$3 = match$3[1];
              if(34 === c$3){
               caml_call1(Stream[12], strm);
               return [0, [4, get_string(0)]];
              }
              if(92 === c$3){
               caml_call1(Stream[12], strm);
               try{var c$4 = escape(strm);}
               catch(_o_){
                var _j_ = caml_wrap_exception(_o_);
                if(_j_ === Stream[1])
                 throw caml_maybe_attach_backtrace([0, Stream[2], cst$1], 1);
                throw caml_maybe_attach_backtrace(_j_, 0);
               }
               store(c$4);
              }
              else{caml_call1(Stream[12], strm); store(c$3);}
             }
             break;
            case 39:
             caml_call1(Stream[12], strm);
             try{
              var match$4 = caml_call1(Stream[11], strm);
              if(! match$4) throw caml_maybe_attach_backtrace(Stream[1], 1);
              var c$5 = match$4[1];
              if(92 === c$5){
               caml_call1(Stream[12], strm);
               try{var _l_ = escape(strm), c$0 = _l_;}
               catch(_n_){
                var _k_ = caml_wrap_exception(_n_);
                if(_k_ === Stream[1])
                 throw caml_maybe_attach_backtrace([0, Stream[2], cst$2], 1);
                throw caml_maybe_attach_backtrace(_k_, 0);
               }
              }
              else{caml_call1(Stream[12], strm); var c$0 = c$5;}
             }
             catch(_m_){
              var _g_ = caml_wrap_exception(_m_);
              if(_g_ === Stream[1])
               throw caml_maybe_attach_backtrace([0, Stream[2], cst], 1);
              throw caml_maybe_attach_backtrace(_g_, 0);
             }
             var match$0 = caml_call1(Stream[11], strm);
             if(match$0 && 39 === match$0[1]){
              caml_call1(Stream[12], strm);
              return [0, [5, c$0]];
             }
             throw caml_maybe_attach_backtrace([0, Stream[2], cst$0], 1);
            case 40:
             caml_call1(Stream[12], strm);
             var match$5 = caml_call1(Stream[11], strm);
             if(match$5 && 42 === match$5[1]){
              caml_call1(Stream[12], strm);
              comment(strm);
              continue;
             }
             return [0, keyword_or_error(40)];
            case 45:
             caml_call1(Stream[12], strm);
             var match$2 = caml_call1(Stream[11], strm);
             if(match$2){
              var c$2 = match$2[1];
              if(9 >= c$2 - 48 >>> 0){
               caml_call1(Stream[12], strm);
               reset_buffer(0);
               store(45);
               store(c$2);
               return number(strm);
              }
             }
             reset_buffer(0);
             store(45);
             return ident2(strm);
            case 9:
            case 10:
            case 12:
            case 13:
            case 26:
            case 32:
             caml_call1(Stream[12], strm); continue;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
             caml_call1(Stream[12], strm);
             reset_buffer(0);
             store(c);
             return number(strm);
            case 33:
            case 35:
            case 36:
            case 37:
            case 38:
            case 42:
            case 43:
            case 47:
            case 58:
            case 60:
            case 61:
            case 62:
            case 63:
            case 64: break;
            default: break b;
          }
         }
         else{
          var _h_ = _f_ - 26 | 0;
          if(5 < _h_ >>> 0) break a;
          switch(_h_){case 4: break a;case 1:case 3: break;default: break b;
          }
         }
        }
        caml_call1(Stream[12], strm);
        reset_buffer(0);
        store(c);
        return ident2(strm);
       }
       caml_call1(Stream[12], strm);
       return [0, keyword_or_error(c)];
      }
      caml_call1(Stream[12], strm);
      reset_buffer(0);
      store(c);
      for(;;){
       var match$1 = caml_call1(Stream[11], strm);
       a:
       if(match$1){
        var c$1 = match$1[1];
        if(91 <= c$1){
         var _i_ = c$1 - 95 | 0;
         if(27 < _i_ >>> 0){if(97 > _i_) break a;} else if(1 === _i_) break a;
        }
        else
         if(48 <= c$1){
          if(6 >= c$1 - 58 >>> 0) break a;
         }
         else if(39 !== c$1) break a;
        caml_call1(Stream[12], strm);
        store(c$1);
        continue;
       }
       return [0, ident_or_keyword(get_string(0))];
      }
     }
    }
    function ident2(strm){
     for(;;){
      var match = caml_call1(Stream[11], strm);
      a:
      if(match){
       var c = match[1];
       if(94 <= c){
        var _e_ = c - 95 | 0;
        if(30 < _e_ >>> 0){
         if(32 <= _e_) break a;
        }
        else if(29 !== _e_) break a;
       }
       else
        if(65 <= c){
         if(92 !== c) break a;
        }
        else{
         if(33 > c) break a;
         switch(c - 33 | 0){
           case 0:
           case 2:
           case 3:
           case 4:
           case 5:
           case 9:
           case 10:
           case 12:
           case 14:
           case 25:
           case 27:
           case 28:
           case 29:
           case 30:
           case 31: break;
           default: break a;
         }
        }
       caml_call1(Stream[12], strm);
       store(c);
       continue;
      }
      return [0, ident_or_keyword(get_string(0))];
     }
    }
    function number(strm){
     for(;;){
      var match = caml_call1(Stream[11], strm);
      a:
      if(match){
       var c = match[1];
       if(58 <= c){
        if(69 !== c && 101 !== c) break a;
        caml_call1(Stream[12], strm);
        store(69);
        return exponent_part(strm);
       }
       if(46 === c){
        caml_call1(Stream[12], strm);
        store(46);
        for(;;){
         var match$0 = caml_call1(Stream[11], strm);
         if(match$0){
          var c$0 = match$0[1], _d_ = c$0 - 69 | 0;
          if(32 < _d_ >>> 0){
           if(9 >= _d_ + 21 >>> 0){
            caml_call1(Stream[12], strm);
            store(c$0);
            continue;
           }
          }
          else if(30 < _d_ - 1 >>> 0){
           caml_call1(Stream[12], strm);
           store(69);
           return exponent_part(strm);
          }
         }
         return [0, [3, caml_float_of_string(get_string(0))]];
        }
       }
       if(48 <= c){caml_call1(Stream[12], strm); store(c); continue;}
      }
      return [0, [2, runtime.caml_int_of_string(get_string(0))]];
     }
    }
    function exponent_part(strm){
     var match = caml_call1(Stream[11], strm);
     a:
     if(match){
      var c = match[1];
      if(43 !== c && 45 !== c) break a;
      caml_call1(Stream[12], strm);
      store(c);
      return end_exponent_part(strm);
     }
     return end_exponent_part(strm);
    }
    function end_exponent_part(strm){
     for(;;){
      var match = caml_call1(Stream[11], strm);
      if(match){
       var c = match[1];
       if(9 >= c - 48 >>> 0){
        caml_call1(Stream[12], strm);
        store(c);
        continue;
       }
      }
      return [0, [3, caml_float_of_string(get_string(0))]];
     }
    }
    function escape(strm){
     var match = caml_call1(Stream[11], strm);
     if(! match) throw caml_maybe_attach_backtrace(Stream[1], 1);
     var c1 = match[1];
     if(58 <= c1){
      var switcher = c1 - 110 | 0;
      if(6 >= switcher >>> 0)
       switch(switcher){
         case 0:
          caml_call1(Stream[12], strm); return 10;
         case 4:
          caml_call1(Stream[12], strm); return 13;
         case 6:
          caml_call1(Stream[12], strm); return 9;
       }
     }
     else if(48 <= c1){
      caml_call1(Stream[12], strm);
      var match$0 = caml_call1(Stream[11], strm);
      if(match$0){
       var c2 = match$0[1];
       if(9 >= c2 - 48 >>> 0){
        caml_call1(Stream[12], strm);
        var match$1 = caml_call1(Stream[11], strm);
        if(match$1){
         var c3 = match$1[1];
         if(9 >= c3 - 48 >>> 0){
          caml_call1(Stream[12], strm);
          return caml_call1
                  (Stdlib_Char[1],
                   (((c1 - 48 | 0) * 100 | 0) + ((c2 - 48 | 0) * 10 | 0) | 0)
                   + (c3 - 48 | 0)
                   | 0);
         }
        }
        throw caml_maybe_attach_backtrace([0, Stream[2], cst$4], 1);
       }
      }
      throw caml_maybe_attach_backtrace([0, Stream[2], cst$3], 1);
     }
     caml_call1(Stream[12], strm);
     return c1;
    }
    function comment(strm){
     for(;;){
      var match = caml_call1(Stream[11], strm);
      if(! match) throw caml_maybe_attach_backtrace(Stream[1], 1);
      var switcher = match[1] - 40 | 0;
      if(2 >= switcher >>> 0)
       switch(switcher){
         case 0:
          caml_call1(Stream[12], strm);
          var match$0 = caml_call1(Stream[11], strm);
          if(! match$0) throw caml_maybe_attach_backtrace(Stream[1], 1);
          if(42 === match$0[1]){
           caml_call1(Stream[12], strm);
           comment(strm);
           continue;
          }
          caml_call1(Stream[12], strm);
          continue;
         case 1: break;
         default:
          caml_call1(Stream[12], strm);
          for(;;){
           var match$1 = caml_call1(Stream[11], strm);
           if(! match$1) throw caml_maybe_attach_backtrace(Stream[1], 1);
           var _c_ = match$1[1];
           if(41 === _c_){caml_call1(Stream[12], strm); return;}
           if(42 !== _c_) break;
           caml_call1(Stream[12], strm);
          }
          caml_call1(Stream[12], strm);
          continue;
       }
      caml_call1(Stream[12], strm);
     }
    }
    return function(input){
     function _b_(count){return next_token(input);}
     return caml_call1(Stream[3], _b_);};
   }
   var Genlex = [0, make_lexer];
   runtime.caml_register_global(14, Genlex, "Genlex");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJjYW1scF9zdHJlYW1zLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJjb3VudCIsImRhdGEiLCJmaWxsX2J1ZmYiLCJiIiwiZ2V0X2RhdGEiLCJkIiwiZCQwIiwiZDIiLCJkMSIsImQxMSIsImEiLCJmIiwiZCQxIiwiZyIsImEkMCIsImEkMSIsInIiLCJwZWVrX2RhdGEiLCJzIiwieCIsInBlZWsiLCJqdW5rX2RhdGEiLCJqdW5rIiwibmdldF9kYXRhIiwibiIsImsiLCJhbCIsIm5wZWVrIiwibGVuIiwibmV4dCIsImVtcHR5IiwiaXRlciIsInN0cm0iLCJmcm9tIiwib2ZfbGlzdCIsImwiLCJvZl9zdHJpbmciLCJjIiwib2ZfYnl0ZXMiLCJvZl9jaGFubmVsIiwiaWMiLCJpYXBwIiwiaSIsImljb25zIiwiaXNpbmciLCJsYXBwIiwibGNvbnMiLCJsc2luZyIsInNlbXB0eSIsInNsYXp5IiwiZHVtcCIsImR1bXBfZGF0YSIsImluaXRpYWxfYnVmZmVyIiwiYnVmZmVyIiwiYnVmcG9zIiwicmVzZXRfYnVmZmVyIiwic3RvcmUiLCJuZXdidWZmZXIiLCJnZXRfc3RyaW5nIiwibWFrZV9sZXhlciIsImtleXdvcmRzIiwia3dkX3RhYmxlIiwiaWRlbnRfb3Jfa2V5d29yZCIsImlkIiwia2V5d29yZF9vcl9lcnJvciIsIm5leHRfdG9rZW4iLCJjJDMiLCJjJDQiLCJlc2NhcGUiLCJjJDUiLCJjJDAiLCJjb21tZW50IiwiYyQyIiwibnVtYmVyIiwiaWRlbnQyIiwiYyQxIiwiZXhwb25lbnRfcGFydCIsImVuZF9leHBvbmVudF9wYXJ0IiwiYzEiLCJjMiIsImMzIiwiaW5wdXQiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jYW1scC1zdHJlYW1zL3N0cmVhbS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NhbWxwLXN0cmVhbXMvZ2VubGV4Lm1sIl0s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QUEsdUJBWktBO3lCQWdCSixNQUFBOzswQkFITyx1QkFiSEEsT0FhRzs7V0FDQSx1QkFkSEE7O1VBZUMsdUJBZkRBOzs7TUFJQyx1QkFKREE7O0lBS2dCO0lBYTdCLGdCQUFJaUQ7a0JBQTBCakYsT0FBVSxPQS9JaENpRSxXQStJSmdCLE9BQW9EO0tBQS9CLE9BQUEsMkJBQWdDO0dBQUE7b0JBMUp2RHRCOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRGFuaWVsIGRlIFJhdWdsYXVkcmUsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2EgY2VsbCBvcHRpb25cbmFuZCAnYSBjZWxsID0geyBtdXRhYmxlIGNvdW50IDogaW50OyBtdXRhYmxlIGRhdGEgOiAnYSBkYXRhIH1cbmFuZCAnYSBkYXRhID1cbiAgICBTZW1wdHlcbiAgfCBTY29ucyBvZiAnYSAqICdhIGRhdGFcbiAgfCBTYXBwIG9mICdhIGRhdGEgKiAnYSBkYXRhXG4gIHwgU2xhenkgb2YgJ2EgZGF0YSBMYXp5LnRcbiAgfCBTZ2VuIG9mICdhIGdlblxuICB8IFNidWZmaW8gOiBidWZmaW8gLT4gY2hhciBkYXRhXG5hbmQgJ2EgZ2VuID0geyBtdXRhYmxlIGN1cnIgOiAnYSBvcHRpb24gb3B0aW9uOyBmdW5jIDogaW50IC0+ICdhIG9wdGlvbiB9XG5hbmQgYnVmZmlvID1cbiAgeyBpYyA6IGluX2NoYW5uZWw7IGJ1ZmYgOiBieXRlczsgbXV0YWJsZSBsZW4gOiBpbnQ7IG11dGFibGUgaW5kIDogaW50IH1cblxuZXhjZXB0aW9uIEZhaWx1cmVcbmV4Y2VwdGlvbiBFcnJvciBvZiBzdHJpbmdcblxubGV0IGNvdW50ID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIHsgY291bnQgfSAtPiBjb3VudFxubGV0IGRhdGEgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gU2VtcHR5XG4gIHwgU29tZSB7IGRhdGEgfSAtPiBkYXRhXG5cbmxldCBmaWxsX2J1ZmYgYiA9XG4gIGIubGVuIDwtIGlucHV0IGIuaWMgYi5idWZmIDAgKEJ5dGVzLmxlbmd0aCBiLmJ1ZmYpOyBiLmluZCA8LSAwXG5cblxubGV0IHJlYyBnZXRfZGF0YSA6IHR5cGUgdi4gaW50IC0+IHYgZGF0YSAtPiB2IGRhdGEgPSBmdW4gY291bnQgZCAtPiBtYXRjaCBkIHdpdGhcbiAoKiBSZXR1cm5zIGVpdGhlciBTZW1wdHkgb3IgU2NvbnMoYSwgXykgZXZlbiB3aGVuIGQgaXMgYSBnZW5lcmF0b3JcbiAgICBvciBhIGJ1ZmZlci4gSW4gdGhvc2UgY2FzZXMsIHRoZSBpdGVtIGEgaXMgc2VlbiBhcyBleHRyYWN0ZWQgZnJvbVxuIHRoZSBnZW5lcmF0b3IvYnVmZmVyLlxuIFRoZSBjb3VudCBwYXJhbWV0ZXIgaXMgdXNlZCBmb3IgY2FsbGluZyBgU2dlbi1mdW5jdGlvbnMnLiAgKilcbiAgIFNlbXB0eSB8IFNjb25zIChfLCBfKSAtPiBkXG4gfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIGNvdW50IGQxIHdpdGhcbiAgICAgICBTY29ucyAoYSwgZDExKSAtPiBTY29ucyAoYSwgU2FwcCAoZDExLCBkMikpXG4gICAgIHwgU2VtcHR5IC0+IGdldF9kYXRhIGNvdW50IGQyXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBOb25lfSAtPiBTZW1wdHlcbiB8IFNnZW4gKHtjdXJyID0gU29tZShTb21lIGEpfSBhcyBnKSAtPlxuICAgICBnLmN1cnIgPC0gTm9uZTsgU2NvbnMoYSwgZClcbiB8IFNnZW4gZyAtPlxuICAgICBiZWdpbiBtYXRjaCBnLmZ1bmMgY291bnQgd2l0aFxuICAgICAgIE5vbmUgLT4gZy5jdXJyIDwtIFNvbWUoTm9uZSk7IFNlbXB0eVxuICAgICB8IFNvbWUgYSAtPiBTY29ucyhhLCBkKVxuICAgICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgIGVuZFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBTZW1wdHkgZWxzZVxuICAgICAgIGxldCByID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQgaW5cbiAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgICBiLmluZCA8LSBzdWNjIGIuaW5kOyBTY29ucyhyLCBkKVxuIHwgU2xhenkgZiAtPiBnZXRfZGF0YSBjb3VudCAoTGF6eS5mb3JjZSBmKVxuXG5cbmxldCByZWMgcGVla19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdiBvcHRpb24gPSBmdW4gcyAtPlxuICgqIGNvbnN1bHQgdGhlIGZpcnN0IGl0ZW0gb2YgcyAqKVxuIG1hdGNoIHMuZGF0YSB3aXRoXG4gICBTZW1wdHkgLT4gTm9uZVxuIHwgU2NvbnMgKGEsIF8pIC0+IFNvbWUgYVxuIHwgU2FwcCAoXywgXykgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgcy5jb3VudCBzLmRhdGEgd2l0aFxuICAgICAgIFNjb25zKGEsIF8pIGFzIGQgLT4gcy5kYXRhIDwtIGQ7IFNvbWUgYVxuICAgICB8IFNlbXB0eSAtPiBOb25lXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTbGF6eSBmIC0+IHMuZGF0YSA8LSAoTGF6eS5mb3JjZSBmKTsgcGVla19kYXRhIHNcbiB8IFNnZW4ge2N1cnIgPSBTb21lIGF9IC0+IGFcbiB8IFNnZW4gZyAtPiBsZXQgeCA9IGcuZnVuYyBzLmNvdW50IGluIGcuY3VyciA8LSBTb21lIHg7IHhcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gYmVnaW4gcy5kYXRhIDwtIFNlbXB0eTsgTm9uZSBlbmRcbiAgICAgZWxzZSBTb21lIChCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZClcblxuXG5sZXQgcGVlayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBzIC0+IHBlZWtfZGF0YSBzXG5cblxubGV0IHJlYyBqdW5rX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB1bml0ID0gZnVuIHMgLT5cbiAgbWF0Y2ggcy5kYXRhIHdpdGhcbiAgICBTY29ucyAoXywgZCkgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgcy5kYXRhIDwtIGRcbiAgfCBTZ2VuICh7Y3VyciA9IFNvbWUgX30gYXMgZykgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgZy5jdXJyIDwtIE5vbmVcbiAgfCBTYnVmZmlvIGIgLT5cbiAgICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gcy5kYXRhIDwtIFNlbXB0eVxuICAgICAgZWxzZSAocy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgYi5pbmQgPC0gc3VjYyBiLmluZClcbiAgfCBfIC0+XG4gICAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICAgIE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIC0+IGp1bmtfZGF0YSBzXG5cblxubGV0IGp1bmsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGRhdGEgLT4ganVua19kYXRhIGRhdGFcblxubGV0IHJlYyBuZ2V0X2RhdGEgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW4gW10sIHMuZGF0YSwgMFxuICBlbHNlXG4gICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgU29tZSBhIC0+XG4gICAgICAgIGp1bmtfZGF0YSBzO1xuICAgICAgICBsZXQgKGFsLCBkLCBrKSA9IG5nZXRfZGF0YSAocHJlZCBuKSBzIGluIGEgOjogYWwsIFNjb25zIChhLCBkKSwgc3VjYyBrXG4gICAgfCBOb25lIC0+IFtdLCBzLmRhdGEsIDBcblxuXG5sZXQgbnBlZWtfZGF0YSBuIHMgPVxuICBsZXQgKGFsLCBkLCBsZW4pID0gbmdldF9kYXRhIG4gcyBpblxuICBzLmNvdW50IDwtIChzLmNvdW50IC0gbGVuKTtcbiAgcy5kYXRhIDwtIGQ7XG4gIGFsXG5cblxubGV0IG5wZWVrIG4gPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGQgLT4gbnBlZWtfZGF0YSBuIGRcblxubGV0IG5leHQgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBhIC0+IGp1bmsgczsgYVxuICB8IE5vbmUgLT4gcmFpc2UgRmFpbHVyZVxuXG5cbmxldCBlbXB0eSBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIF8gLT4gcmFpc2UgRmFpbHVyZVxuICB8IE5vbmUgLT4gKClcblxuXG5sZXQgaXRlciBmIHN0cm0gPVxuICBsZXQgcmVjIGRvX3JlYyAoKSA9XG4gICAgbWF0Y2ggcGVlayBzdHJtIHdpdGhcbiAgICAgIFNvbWUgYSAtPiBqdW5rIHN0cm07IGlnbm9yZShmIGEpOyBkb19yZWMgKClcbiAgICB8IE5vbmUgLT4gKClcbiAgaW5cbiAgZG9fcmVjICgpXG5cblxuKCogU3RyZWFtIGJ1aWxkaW5nIGZ1bmN0aW9ucyAqKVxuXG5sZXQgZnJvbSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2dlbiB7Y3VyciA9IE5vbmU7IGZ1bmMgPSBmfX1cblxubGV0IG9mX2xpc3QgbCA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IExpc3QuZm9sZF9yaWdodCAoZnVuIHggbCAtPiBTY29ucyAoeCwgbCkpIGwgU2VtcHR5fVxuXG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgKCogV2UgY2Fubm90IHVzZSB0aGUgaW5kZXggcGFzc2VkIGJ5IHRoZSBbZnJvbV0gZnVuY3Rpb24gZGlyZWN0bHlcbiAgICAgICBiZWNhdXNlIGl0IHJldHVybnMgdGhlIGN1cnJlbnQgc3RyZWFtIGNvdW50LCB3aXRoIGFic29sdXRlbHkgbm9cbiAgICAgICBndWFyYW50ZWUgdGhhdCBpdCB3aWxsIHN0YXJ0IGZyb20gMC4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlXG4gICAgICAgb2YgW1N0cmVhbS5pY29ucyAnYycgKFN0cmVhbS5mcm9tX3N0cmluZyBcImFiXCIpXSwgdGhlIGZpcnN0XG4gICAgICAgYWNjZXNzIHRvIHRoZSBzdHJpbmcgd2lsbCBiZSBtYWRlIHdpdGggY291bnQgWzFdIGFscmVhZHkuXG4gICAgKilcbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBTdHJpbmcubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIHMuW2NdKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfYnl0ZXMgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgQnl0ZXMubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIChCeXRlcy5nZXQgcyBjKSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2NoYW5uZWwgaWMgPVxuICBTb21lIHtjb3VudCA9IDA7XG4gICAgICAgIGRhdGEgPSBTYnVmZmlvIHtpYyA9IGljOyBidWZmID0gQnl0ZXMuY3JlYXRlIDQwOTY7IGxlbiA9IDA7IGluZCA9IDB9fVxuXG5cbigqIFN0cmVhbSBleHByZXNzaW9ucyBidWlsZGVycyAqKVxuXG5sZXQgaWFwcCBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTYXBwIChkYXRhIGksIGRhdGEgcyl9XG5sZXQgaWNvbnMgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIGRhdGEgcyl9XG5sZXQgaXNpbmcgaSA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBTZW1wdHkpfVxuXG5sZXQgbGFwcCBmIHMgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTYXBwIChkYXRhIChmICgpKSwgZGF0YSBzKSkpfVxuXG5sZXQgbGNvbnMgZiBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIGRhdGEgcykpKX1cbmxldCBsc2luZyBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIFNlbXB0eSkpKX1cblxubGV0IHNlbXB0eSA9IE5vbmVcbmxldCBzbGF6eSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoZGF0YSAoZiAoKSkpKX1cblxuKCogRm9yIGRlYnVnZ2luZyB1c2UgKilcblxubGV0IHJlYyBkdW1wIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IHQgLT4gdW5pdCA9IGZ1biBmIHMgLT5cbiAgcHJpbnRfc3RyaW5nIFwie2NvdW50ID0gXCI7XG4gIHByaW50X2ludCAoY291bnQgcyk7XG4gIHByaW50X3N0cmluZyBcIjsgZGF0YSA9IFwiO1xuICBkdW1wX2RhdGEgZiAoZGF0YSBzKTtcbiAgcHJpbnRfc3RyaW5nIFwifVwiO1xuICBwcmludF9uZXdsaW5lICgpXG5hbmQgZHVtcF9kYXRhIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IGRhdGEgLT4gdW5pdCA9IGZ1biBmIC0+XG4gIGZ1bmN0aW9uXG4gICAgU2VtcHR5IC0+IHByaW50X3N0cmluZyBcIlNlbXB0eVwiXG4gIHwgU2NvbnMgKGEsIGQpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTY29ucyAoXCI7XG4gICAgICBmIGE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNhcHAgKFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDI7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTbGF6eSBfIC0+IHByaW50X3N0cmluZyBcIlNsYXp5XCJcbiAgfCBTZ2VuIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2dlblwiXG4gIHwgU2J1ZmZpbyBfIC0+IHByaW50X3N0cmluZyBcIlNidWZmaW9cIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHRva2VuID1cbiAgICBLd2Qgb2Ygc3RyaW5nXG4gIHwgSWRlbnQgb2Ygc3RyaW5nXG4gIHwgSW50IG9mIGludFxuICB8IEZsb2F0IG9mIGZsb2F0XG4gIHwgU3RyaW5nIG9mIHN0cmluZ1xuICB8IENoYXIgb2YgY2hhclxuXG4oKiBUaGUgc3RyaW5nIGJ1ZmZlcmluZyBtYWNoaW5lcnkgKilcblxubGV0IGluaXRpYWxfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDMyXG5cbmxldCBidWZmZXIgPSByZWYgaW5pdGlhbF9idWZmZXJcbmxldCBidWZwb3MgPSByZWYgMFxuXG5sZXQgcmVzZXRfYnVmZmVyICgpID0gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBidWZwb3MgOj0gMFxuXG5sZXQgc3RvcmUgYyA9XG4gIGlmICFidWZwb3MgPj0gQnl0ZXMubGVuZ3RoICFidWZmZXIgdGhlbiBiZWdpblxuICAgIGxldCBuZXdidWZmZXIgPSBCeXRlcy5jcmVhdGUgKDIgKiAhYnVmcG9zKSBpblxuICAgIEJ5dGVzLmJsaXQgIWJ1ZmZlciAwIG5ld2J1ZmZlciAwICFidWZwb3M7XG4gICAgYnVmZmVyIDo9IG5ld2J1ZmZlclxuICBlbmQ7XG4gIEJ5dGVzLnNldCAhYnVmZmVyICFidWZwb3MgYztcbiAgaW5jciBidWZwb3NcblxubGV0IGdldF9zdHJpbmcgKCkgPVxuICBsZXQgcyA9IEJ5dGVzLnN1Yl9zdHJpbmcgIWJ1ZmZlciAwICFidWZwb3MgaW4gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBzXG5cbigqIFRoZSBsZXhlciAqKVxuXG5sZXQgbWFrZV9sZXhlciBrZXl3b3JkcyA9XG4gIGxldCBrd2RfdGFibGUgPSBIYXNodGJsLmNyZWF0ZSAxNyBpblxuICBMaXN0Lml0ZXIgKGZ1biBzIC0+IEhhc2h0YmwuYWRkIGt3ZF90YWJsZSBzIChLd2QgcykpIGtleXdvcmRzO1xuICBsZXQgaWRlbnRfb3Jfa2V5d29yZCBpZCA9XG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgaWQgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IElkZW50IGlkXG4gIGFuZCBrZXl3b3JkX29yX2Vycm9yIGMgPVxuICAgIGxldCBzID0gU3RyaW5nLm1ha2UgMSBjIGluXG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgcyB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciAoXCJJbGxlZ2FsIGNoYXJhY3RlciBcIiBeIHMpKVxuICBpblxuICBsZXQgcmVjIG5leHRfdG9rZW4gKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJyAnIHwgJ1xcMDEwJyB8ICdcXDAxMycgfCAnXFwwMDknIHwgJ1xcMDI2JyB8ICdcXDAxMicpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbmV4dF90b2tlbiBzdHJtX19cbiAgICB8IFNvbWUgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXycgfCAnXFwxOTInLi4nXFwyNTUnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfCAnPicgfFxuICAgICAgICAgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICdcXCcnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBjaGFyIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAnXFwnJyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKENoYXIgYylcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lICdcXFwiJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgU29tZSAoU3RyaW5nIChzdHJpbmcgcykpXG4gICAgfCBTb21lICctJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG5lZ19udW1iZXIgc3RybV9fXG4gICAgfCBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChrZXl3b3JkX29yX2Vycm9yIGMpXG4gICAgfCBfIC0+IE5vbmVcbiAgYW5kIGlkZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXFwxOTInLi4nXFwyNTUnIHwgJzAnLi4nOScgfCAnXycgfCAnXFwnJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBpZGVudDIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy0nIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHxcbiAgICAgICAgICc+JyB8ICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgbmVnX251bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgXyAtPiBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgaWRlbnQyIHNcbiAgYW5kIG51bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICcuJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICcuJzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChJbnQgKGludF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGRlY2ltYWxfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnKycgfCAnLScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IGVuZF9leHBvbmVudF9wYXJ0IHN0cm1fX1xuICBhbmQgZW5kX2V4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIHN0cmluZyAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFwiJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGdldF9zdHJpbmcgKClcbiAgICB8IFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBjaGFyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBlc2NhcGUgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnbicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxuJ1xuICAgIHwgU29tZSAncicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxyJ1xuICAgIHwgU29tZSAndCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFx0J1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYzEpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMikgLT5cbiAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMzKSAtPlxuICAgICAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgICAgICBDaGFyLmNoclxuICAgICAgICAgICAgICAgICAgKChDaGFyLmNvZGUgYzEgLSA0OCkgKiAxMDAgKyAoQ2hhci5jb2RlIGMyIC0gNDgpICogMTAgK1xuICAgICAgICAgICAgICAgICAgICAgKENoYXIuY29kZSBjMyAtIDQ4KSlcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBuZXh0X3Rva2VuIHNcbiAgICB8IF8gLT4gU29tZSAoa2V5d29yZF9vcl9lcnJvciAnKCcpXG4gIGFuZCBjb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfbmVzdGVkX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX25lc3RlZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBjb21tZW50IHNcbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9lbmRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcpJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICgpXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgaW5cbiAgZnVuIGlucHV0IC0+IFN0cmVhbS5mcm9tIChmdW4gX2NvdW50IC0+IG5leHRfdG9rZW4gaW5wdXQpXG4iXX0=
