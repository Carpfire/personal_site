// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Eqaf__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Eqaf = [0];
   runtime.caml_register_global(0, Eqaf, "Eqaf__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Eqaf__Unsafe
//# unitInfo: Requires: Stdlib__Bytes
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function set_int32_le(b, i, x){
    return caml_call3(Stdlib_Bytes[83], b, i, x);
   }
   function get_int64_le(b, i){return caml_call2(Stdlib_Bytes[72], b, i);}
   var Eqaf_Unsafe = [0, set_int32_le, get_int64_le];
   runtime.caml_register_global(1, Eqaf_Unsafe, "Eqaf__Unsafe");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Eqaf
//# unitInfo: Requires: Eqaf__Unsafe, Stdlib, Stdlib__Bytes, Stdlib__Int32, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_mul = runtime.caml_mul,
    caml_string_get = runtime.caml_string_get,
    caml_string_get16 = runtime.caml_string_get16,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Eqaf_Unsafe = global_data.Eqaf__Unsafe,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_digits_0 = "digits < 0",
    cst_m_0 = "m <= 0",
    cst_m_16348_not_supported = "m >= 16348 not supported",
    cst_compare_be_with_len = "compare_be_with_len",
    cst_compare_le_with_len = "compare_le_with_len";
   function equal(a, b){
    var al = caml_ml_string_length(a), bl = caml_ml_string_length(b);
    if(al !== bl) return 0;
    var l1 = al >> 1, r = [0, 0], _q_ = l1 - 1 | 0, _p_ = 0;
    if(_q_ >= 0){
     var i = _p_;
     for(;;){
      var
       _u_ = caml_string_get16(b, i * 2 | 0),
       _v_ = caml_string_get16(a, i * 2 | 0) ^ _u_;
      r[1] = r[1] | _v_;
      var _w_ = i + 1 | 0;
      if(_q_ === i) break;
      var i = _w_;
     }
    }
    var _s_ = al & 1, _r_ = 1;
    if(_s_ >= 1){
     var for$0 = _r_;
     for(;;){
      r[1] =
       r[1]
       |
        caml_string_unsafe_get(a, al - 1 | 0)
        ^ caml_string_unsafe_get(b, al - 1 | 0);
      var _t_ = for$0 + 1 | 0;
      if(_s_ === for$0) break;
      var for$0 = _t_;
     }
    }
    return 0 === r[1] ? 1 : 0;
   }
   function sixteen_if_minus_one_or_less(n){return n >> Stdlib_Sys[10] & 16;}
   function eight_if_one_or_more(n){return (- n | 0) >> Stdlib_Sys[10] & 8;}
   function _a_(ln, a, b){
    var r = [0, 0], i = [0, ln - 1 | 0];
    for(;;){
     if(0 > i[1]) return (r[1] & 8) - (r[1] & 16) | 0;
     var
      xa = caml_string_unsafe_get(a, i[1]),
      xb = caml_string_unsafe_get(b, i[1]),
      c = xa - xb | 0,
      _m_ = r[1],
      _n_ = eight_if_one_or_more(c),
      _o_ = (sixteen_if_minus_one_or_less(c) + _n_ | 0) >>> _m_ | 0;
     r[1] = r[1] | _o_;
     i[1] += -1;
    }
   }
   function compare_le_with_len(ln, a, b){
    var al = caml_ml_string_length(a), bl = caml_ml_string_length(b);
    return 0 === ln
            ? 0
            : 0
              === (al ^ ln | bl ^ ln)
              ? _a_(ln, a, b)
              : caml_call1(Stdlib[1], cst_compare_le_with_len);
   }
   function compare_le(a, b){
    var al = caml_ml_string_length(a), bl = caml_ml_string_length(b);
    return al < bl ? 1 : bl < al ? -1 : _a_(al, a, b);
   }
   function _b_(ln, a, b){
    var r = [0, 0], i = [0, 0];
    for(;;){
     if(i[1] >= ln) return (r[1] & 8) - (r[1] & 16) | 0;
     var
      xa = caml_string_unsafe_get(a, i[1]),
      xb = caml_string_unsafe_get(b, i[1]),
      c = xa - xb | 0,
      _j_ = r[1],
      _k_ = eight_if_one_or_more(c),
      _l_ = (sixteen_if_minus_one_or_less(c) + _k_ | 0) >>> _j_ | 0;
     r[1] = r[1] | _l_;
     i[1]++;
    }
   }
   function compare_be_with_len(ln, a, b){
    var al = caml_ml_string_length(a), bl = caml_ml_string_length(b);
    return 0 === ln
            ? 0
            : 0
              === (al ^ ln | bl ^ ln)
              ? _b_(ln, a, b)
              : caml_call1(Stdlib[1], cst_compare_be_with_len);
   }
   function compare_be(a, b){
    var al = caml_ml_string_length(a), bl = caml_ml_string_length(b);
    return al < bl ? 1 : bl < al ? -1 : _b_(al, a, b);
   }
   function one_if_not_zero(n){
    var n$0 = - n | 0 | n;
    return n$0 >>> (Stdlib_Sys[10] - 1 | 0) | 0;
   }
   function zero_if_not_zero(n){return one_if_not_zero(n) - 1 | 0;}
   function select_int(choose_b, a, b){
    var mask = (- choose_b | 0 | choose_b) >> Stdlib_Sys[10];
    return a & caml_call1(Stdlib[21], mask) | b & mask;
   }
   function bool_of_int(n){return one_if_not_zero(n);}
   function find_uint8(opt, f, str){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    var
     len = caml_ml_string_length(str),
     i = [0, len - 1 | 0],
     a = [0, caml_call1(Stdlib[21], 0)];
    for(;;){
     if(off > i[1]) return a[1];
     var
      byte$0 = caml_string_unsafe_get(str, i[1]),
      pred = caml_call1(f, byte$0);
     a[1] = select_int((i[1] - off | 0) & Stdlib[20] | pred, a[1], i[1]);
     i[1] += -1;
    }
   }
   function exists_uint8(off, f, str){
    var v = find_uint8(off, f, str), r = select_int(v + 1 | 0, 0, 1);
    return r;
   }
   function divmod(x, m){
    if(runtime.caml_lessequal(m, 0))
     throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_m_0], 1);
    if(runtime.caml_greaterequal(m, 16348))
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_m_16348_not_supported], 1);
    function of_uint32(uint){
     var b = caml_call2(Stdlib_Bytes[1], 8, 0);
     caml_call3(Eqaf_Unsafe[1], b, 0, uint);
     return caml_call2(Eqaf_Unsafe[2], b, 0);
    }
    var n = Stdlib_Int32[10], min_int = Stdlib_Int32[10];
    function int32_unsigned_compare(n, m){
     return caml_call2(Stdlib_Int32[15], n - min_int | 0, m - min_int | 0);
    }
    if(runtime.caml_lessthan(m, 0))
     var _i_ = 0 <= int32_unsigned_compare(n, m) ? 1 : 0;
    else
     var
      q = runtime.caml_div(n >>> 1 | 0, m) << 1,
      r = n - caml_mul(q, m) | 0,
      _i_ =
        0 <= int32_unsigned_compare(r, m) ? caml_call1(Stdlib_Int32[6], q) : q;
    var
     v = of_uint32(_i_),
     qpart_0 =
       caml_int64_to_int32
        (caml_int64_shift_right_unsigne(caml_int64_mul(of_uint32(x), v), 31)),
     x_1 = x - caml_mul(qpart_0, m) | 0,
     qpart_1 =
       caml_int64_to_int32
        (caml_int64_shift_right_unsigne(caml_int64_mul(of_uint32(x_1), v), 31)),
     q_1 = (qpart_0 + qpart_1 | 0) + 1 | 0,
     x_2 = x_1 - caml_mul(qpart_1, m) | 0,
     x_3 = x_2 - m | 0,
     mask = 0 - (x_3 >>> 31 | 0) | 0;
    return [0, q_1 + mask | 0, x_3 + (mask & m) | 0];
   }
   function ascii_of_int32(digits, n){
    if(digits < 0)
     throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_digits_0], 1);
    var
     out = caml_call2(Stdlib_Bytes[1], digits, 48),
     idx$1 = digits - 1 | 0,
     x = n,
     idx = idx$1;
    for(;;){
     if(-1 === idx) return caml_call1(Stdlib_Bytes[44], out);
     var match = divmod(x, 10), this$0 = match[2], next = match[1];
     runtime.caml_bytes_set(out, idx, (48 | this$0) & 255);
     var idx$0 = idx - 1 | 0, x = next, idx = idx$0;
    }
   }
   function hex_of_string(rawbytes){
    function _h_(idx){
     var
      byt = caml_string_get(rawbytes, idx >>> 1 | 0),
      nib = 15 & (byt >>> ((caml_call1(Stdlib[21], idx) & 1) << 2) | 0),
      a = 86 + nib | 0,
      c = 1 + (a - (71 * ((a & 16) >>> 4 | 0) | 0) | 0 | 32) | 0;
     return c & 255;
    }
    return caml_call2
            (Stdlib_String[2], 2 * caml_ml_string_length(rawbytes) | 0, _h_);
   }
   function hex_of_bytes(rawbytes){
    return hex_of_string(caml_call1(Stdlib_Bytes[44], rawbytes));
   }
   function select_a_if_in_range(low, high, n, a, b){
    var out_of_range = (n - low | 0 | high - n | 0) & Stdlib[20];
    return select_int(out_of_range, a, b);
   }
   function lowercase_ascii(src){
    function _g_(ch){
     return select_a_if_in_range(65, 90, ch, ch | 32, ch) & 255;
    }
    return caml_call2(Stdlib_String[18], _g_, src);
   }
   function uppercase_ascii(src){
    function _f_(ch){
     return select_a_if_in_range(97, 122, ch, ch ^ 32, ch) & 255;
    }
    return caml_call2(Stdlib_String[18], _f_, src);
   }
   function bytes_of_hex(rawhex){
    var error_bitmap = [0, (caml_ml_string_length(rawhex) & 1) << 4];
    function _d_(idx){
     var idx$0 = idx << 1;
     function nib(idx){
      var
       n = caml_string_get(rawhex, idx),
       n$0 = select_a_if_in_range(65, 90, n, n | 32, n);
      return select_a_if_in_range
              (48,
               57,
               n$0,
               n$0 - 48 | 0,
               select_a_if_in_range
                (97, 102, n$0, (n$0 - 97 | 0) + 10 | 0, 255));
     }
     var nibf0 = nib(idx$0), nib0f = nib(idx$0 + 1 | 0);
     error_bitmap[1] = error_bitmap[1] | nibf0 | nib0f;
     return (nibf0 << 4 | nib0f) & 255;
    }
    var
     decoded =
       caml_call2
        (Stdlib_Bytes[2], caml_ml_string_length(rawhex) >>> 1 | 0, _d_),
     _e_ = caml_call1(Stdlib[21], 15);
    return [0, decoded, error_bitmap[1] & _e_];
   }
   function string_of_hex(rawhex){
    var match = bytes_of_hex(rawhex), error = match[2], byt = match[1];
    return [0, caml_call1(Stdlib_Bytes[44], byt), error];
   }
   var
    Eqaf =
      [0,
       equal,
       compare_be,
       compare_be_with_len,
       compare_le,
       compare_le_with_len,
       divmod,
       find_uint8,
       exists_uint8,
       ascii_of_int32,
       lowercase_ascii,
       uppercase_ascii,
       hex_of_bytes,
       hex_of_string,
       bytes_of_hex,
       string_of_hex,
       one_if_not_zero,
       zero_if_not_zero,
       function(_c_){return _c_;},
       bool_of_int,
       select_int,
       select_a_if_in_range];
   runtime.caml_register_global(19, Eqaf, "Eqaf");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJlcWFmLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJzZXRfaW50MzJfbGUiLCJiIiwiaSIsIngiLCJnZXRfaW50NjRfbGUiLCJlcXVhbCIsImEiLCJhbCIsImJsIiwibDEiLCJyIiwic2l4dGVlbl9pZl9taW51c19vbmVfb3JfbGVzcyIsIm4iLCJlaWdodF9pZl9vbmVfb3JfbW9yZSIsImxuIiwieGEiLCJ4YiIsImMiLCJjb21wYXJlX2xlX3dpdGhfbGVuIiwiY29tcGFyZV9sZSIsImNvbXBhcmVfYmVfd2l0aF9sZW4iLCJjb21wYXJlX2JlIiwib25lX2lmX25vdF96ZXJvIiwibiQwIiwiemVyb19pZl9ub3RfemVybyIsInNlbGVjdF9pbnQiLCJjaG9vc2VfYiIsIm1hc2siLCJib29sX29mX2ludCIsImZpbmRfdWludDgiLCJvcHQiLCJmIiwic3RyIiwic3RoIiwib2ZmIiwibGVuIiwiYnl0ZSQwIiwicHJlZCIsImV4aXN0c191aW50OCIsInYiLCJkaXZtb2QiLCJtIiwib2ZfdWludDMyIiwidWludCIsIm1pbl9pbnQiLCJpbnQzMl91bnNpZ25lZF9jb21wYXJlIiwicSIsInFwYXJ0XzAiLCJ4XzEiLCJxcGFydF8xIiwicV8xIiwieF8yIiwieF8zIiwiYXNjaWlfb2ZfaW50MzIiLCJkaWdpdHMiLCJvdXQiLCJpZHgiLCJ0aGlzJDAiLCJuZXh0IiwiaGV4X29mX3N0cmluZyIsInJhd2J5dGVzIiwiYnl0IiwibmliIiwiaGV4X29mX2J5dGVzIiwic2VsZWN0X2FfaWZfaW5fcmFuZ2UiLCJsb3ciLCJoaWdoIiwib3V0X29mX3JhbmdlIiwibG93ZXJjYXNlX2FzY2lpIiwic3JjIiwiY2giLCJ1cHBlcmNhc2VfYXNjaWkiLCJieXRlc19vZl9oZXgiLCJyYXdoZXgiLCJlcnJvcl9iaXRtYXAiLCJpZHgkMCIsIm5pYmYwIiwibmliMGYiLCJkZWNvZGVkIiwic3RyaW5nX29mX2hleCIsImVycm9yIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZXFhZi91bnNhZmUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9lcWFmL2VxYWYubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O1lBQUlBLGFBQWFDLEdBQUVDLEdBQUVDO0lBQUksT0FBQSw2QkFBUkYsR0FBRUMsR0FBRUM7R0FBNEI7WUFDN0NDLGFBQWFILEdBQUVDLEdBQUksT0FBQSw2QkFBTkQsR0FBRUMsR0FBMEI7eUJBRHpDRixjQUNBSTs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDMkdBQyxNQUFNQyxHQUFFTDtJQUNWLElBbkZTTSwyQkFrRkRELElBRUpFLEtBQUosc0JBRlVQO09BbEZETSxPQW9GTEMsSUFFQztJQTlFRyxJQVBKQyxLQURLRixTQVFMRyxZQU1KLE1BYklELFlBT0k7O1NBTVJQOztNQUEwRDtPQUFBLE1BQUEsa0JBb0VoREQsR0FwRVZDO09BQXFDLE1BQUEsa0JBb0U3QkksR0FwRVJKO01BTklRLE9BQUFBO01BTUosVUFBQVI7aUJBQUFBO1VBQUFBOzs7SUE0QkEsVUExQ1NLLFFBMENUOzs7O01BbENJRztPQUFBQTs7UUFrQ21DLHVCQXdDL0JKLEdBbEZDQztVQTBDa0QsdUJBd0NqRE4sR0FsRkRNO01BMENUOzs7OztpQkFsQ0lHO0dBK0VpQjtZQUdIQyw2QkFBNkJDLEdBQUksT0FBSkEseUJBQWdDO1lBQzdEQyxxQkFBcUJELEdBQUksVUFBSkEsNkJBQWtDO2dCQUUzREUsSUFBR1IsR0FBRUw7SUFDbkIsSUFBSVMsWUFDQVIsUUFGVVk7O1lBRVZaLGNBREFRLGFBQUFBO0tBSU87TUFBTEssS0FBSyx1QkFMTVQsR0FFYko7TUFHb0JjLEtBQUssdUJBTFZmLEdBRWZDO01BSUVlLElBREFGLEtBQWtCQztNQUV0QixNQU5FTjtNQU02QyxNQVQvQkcscUJBUVpJO2FBVFlOLDZCQVNaTTtL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SUFBQUEsU0FBQUE7SUFHTztJQUpmLE9BQUEsbUNBRmtCRDtHQU9YO1lBRUxHLGFBQWFDO0lBRUksSUFBZkMsMENBRldEO2lCQUtOakI7S0FDRixJQUFJbUIsUUFERm5CO2NBRUVNLElBQUlOO01BQ047T0FFTzVDLElBRlAsZ0JBUk02RCxRQU9BakI7T0FRQ2pDLE1BcERFeUMsNkJBK0NGcEQsR0FBQUEsUUFBQUE7TUFTSixPQXhETW9EOzs7ZUFvREZ6QztlQUFBQTtlQXBERXlDOzBCQW9ERnpDLE1BQUFBO0tBVU47S0FFUyxJQUFScUQsUUFwQkFkLElBREFhLFFBc0JBRSxRQXJCQWYsSUFEQWE7S0FKUEQsa0JBQUFBLGtCQXlCT0UsUUFDQUM7YUFEQUQsYUFDQUM7SUFFOEI7SUExQnZDO0tBREVDO09BQ0Y7Z0RBSmFMO0tBa0NhLE1BQUE7SUFBNUIsV0EvQklLLFNBREFKO0dBZ0NrQztZQUVwQ0ssY0FBY047SUFDaEIsSUFBaUIsUUFyQ2ZELGFBb0NjQyxTQUNQTyxrQkFBTG5CO0lBQ0osV0FBQSw2QkFESUEsTUFBS21CO0dBQ3dCOzs7O09BeFIvQjNFO09BOERBZ0I7T0FSQUQ7T0F0QkFEO09BUkFEO09BMkZBc0I7T0FiQVg7T0FRQVM7T0FtRUFlO09BK0NBZTtPQVNBRztPQTlCQVI7T0FSQUo7T0ErQ0FhO09Bb0NBTztPQTlNZ0J6RDtPQUdBRTtxQjtPQVVQSTtPQVBPSDtPQStIQXVDOzs7RSIsInNvdXJjZXNDb250ZW50IjpbImxldCBzZXRfaW50MzJfbGUgYiBpIHggPSBCeXRlcy5zZXRfaW50MzJfbGUgYiBpIHhcbmxldCBnZXRfaW50NjRfbGUgYiBpID0gQnl0ZXMuZ2V0X2ludDY0X2xlIGIgaVxuIiwibGV0W0BpbmxpbmUgYWx3YXlzXSBjaGFyX2NociBjaCA9XG4gICgqIENoYXIuY2hyIGNvbnRhaW5zIGEgYnJhbmNoIG9uIFtjaF0gYW5kIGEgcGx0IGluZGlyZWN0aW9uLCB0aGlzXG4gICAqIGltcGxlbWVudGF0aW9uIGVuc3VyZXMgd2VsbC1mb3JtZWRuZXNzIGJ5IGNvbnN0cnVjdGlvbiBhbmQgYXZvaWRzIHRoYXQ6ICopXG4gIENoYXIudW5zYWZlX2NociAoY2ggbGFuZCAweGZmKVxuXG5sZXRbQGlubGluZV0gZ2V0IHggaSA9IFN0cmluZy51bnNhZmVfZ2V0IHggaSB8PiBDaGFyLmNvZGVcblxuKCogWFhYKGRpbm9zYXVyZSk6IHdlIHVzZSBbdW5zYWZlX2dldF0gdG8gYXZvaWQganVtcCB0byBleGNlcHRpb246XG5cbiAgICAgICAgc2FycSAgICAkMSwgJXJieFxuICAgICAgICBtb3Z6YnEgICglcmF4LCVyYngpLCAlcmF4XG4gICAgICAgIGxlYXEgICAgMSglcmF4LCVyYXgpLCAlcmF4XG4gICAgICAgIHJldFxuKilcblxuZXh0ZXJuYWwgdW5zYWZlX2dldF9pbnQxNiA6IHN0cmluZyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9zdHJpbmdfZ2V0MTZ1XCJcbmxldFtAaW5saW5lXSBnZXQxNiB4IGkgPSB1bnNhZmVfZ2V0X2ludDE2IHggaVxuXG4oKiBYWFgoZGlub3NhdXJlKTogc2FtZSBhcyBbdW5zYWZlX2dldF0gYnV0IGZvciBbaW50MTZdOlxuXG4gICAgICAgIHNhcnEgICAgJDEsICVyYnhcbiAgICAgICAgbW92endxICAoJXJheCwlcmJ4KSwgJXJheFxuICAgICAgICBsZWFxICAgIDEoJXJheCwlcmF4KSwgJXJheFxuICAgICAgICByZXRcbiopXG5cbmxldCBlcXVhbCB+bG4gYSBiID1cbiAgbGV0IGwxID0gbG4gYXNyIDEgaW5cblxuICAoKlxuICAgICAgICBzYXJxICAgICQxLCAlcmN4XG4gICAgICAgIG9ycSAgICAgJDEsICVyY3hcbiAgKilcblxuICBsZXQgciA9IHJlZiAwIGluXG5cbiAgKCpcbiAgICAgICAgbW92cSAgICAkMSwgJXJkeFxuICAqKVxuXG4gIGZvciBpID0gMCB0byBwcmVkIGwxIGRvIHIgOj0gIXIgbG9yIChnZXQxNiBhIChpICogMikgbHhvciBnZXQxNiBiIChpICogMikpIGRvbmUgO1xuXG4gICgqXG4gICAgICAgIG1vdnEgICAgJDEsICVyc2lcbiAgICAgICAgYWRkcSAgICAkLTIsICVyY3hcbiAgICAgICAgY21wcSAgICAlcmN4LCAlcnNpXG4gICAgICAgIGpnICAgICAgLkwxMDRcbi5MMTA1OlxuICAgICAgICBsZWFxICAgIC0xKCVyc2ksJXJzaSksICVyOFxuXG4gICAgICAgIHNhcnEgICAgJDEsICVyOFxuICAgICAgICBtb3Z6d3EgICglcmRpLCVyOCksICVyOVxuICAgICAgICBsZWFxICAgIDEoJXI5LCVyOSksICVyOVxuICAgICAgICBtb3Z6d3EgICglcmJ4LCVyOCksICVyOFxuICAgICAgICBsZWFxICAgIDEoJXI4LCVyOCksICVyOFxuXG4gICAgIC8vIFt1bnNhZmVfZ2V0X2ludDE2IGEgaV0gYW5kIFt1bnNhZmVfZ2V0X2ludDYgYiBpXVxuXG4gICAgICAgIHhvcnEgICAgJXI5LCAlcjhcbiAgICAgICAgb3JxICAgICAkMSwgJXI4XG4gICAgICAgIG9ycSAgICAgJXI4LCAlcmR4XG4gICAgICAgIG1vdnEgICAgJXJzaSwgJXI4XG4gICAgICAgIGFkZHEgICAgJDIsICVyc2lcbiAgICAgICAgY21wcSAgICAlcmN4LCAlcjhcbiAgICAgICAgam5lICAgICAuTDEwNVxuLkwxMDQ6XG4gICopXG5cbiAgZm9yIF8gPSAxIHRvIGxuIGxhbmQgMSBkbyByIDo9ICFyIGxvciAoZ2V0IGEgKGxuIC0gMSkgbHhvciBnZXQgYiAobG4gLSAxKSkgZG9uZSA7XG5cbiAgKCpcbiAgICAgICAgbW92cSAgICAkMywgJXJzaVxuICAgICAgICBtb3ZxICAgICVyYXgsICVyY3hcbiAgICAgICAgYW5kcSAgICAkMywgJXJjeFxuICAgICAgICBjbXBxICAgICVyY3gsICVyc2lcbiAgICAgICAgamcgICAgICAuTDEwMlxuLkwxMDM6XG4gICAgICAgIG1vdnEgICAgJXJheCwgJXI4XG4gICAgICAgIGFkZHEgICAgJC0yLCAlcjhcblxuICAgICAgICBzYXJxICAgICQxLCAlcjhcbiAgICAgICAgbW92emJxICAoJXJkaSwlcjgpLCAlcjlcbiAgICAgICAgbGVhcSAgICAxKCVyOSwlcjkpLCAlcjlcbiAgICAgICAgbW92emJxICAoJXJieCwlcjgpLCAlcjhcbiAgICAgICAgbGVhcSAgICAxKCVyOCwlcjgpLCAlcjhcblxuICAgICAvLyBbdW5zYWZlX2dldCBhIGldIGFuZCBbdW5zYWZlX2dldCBiIGldXG5cbiAgICAgICAgeG9ycSAgICAlcjksICVyOFxuICAgICAgICBvcnEgICAgICQxLCAlcjhcbiAgICAgICAgb3JxICAgICAlcjgsICVyZHhcbiAgICAgICAgbW92cSAgICAlcnNpLCAlcjhcbiAgICAgICAgYWRkcSAgICAkMiwgJXJzaVxuICAgICAgICBjbXBxICAgICVyY3gsICVyOFxuICAgICAgICBqbmUgICAgIC5MMTAzXG4uTDEwMjpcbiAgKilcblxuICAhciA9IDBcblxuKCpcbiAgICAgICAgY21wcSAgICAkMSwgJXJkeFxuICAgICAgICBzZXRlICAgICVhbFxuICAgICAgICBtb3Z6YnEgICVhbCwgJXJheFxuICAgICAgICBsZWFxICAgIDEoJXJheCwlcmF4KSwgJXJheFxuICAgICAgICByZXRcbiopXG5cbmxldCBlcXVhbCBhIGIgPVxuICBsZXQgYWwgPSBTdHJpbmcubGVuZ3RoIGEgaW5cbiAgbGV0IGJsID0gU3RyaW5nLmxlbmd0aCBiIGluXG4gIGlmIGFsIDw+IGJsXG4gIHRoZW4gZmFsc2VcbiAgZWxzZSBlcXVhbCB+bG46YWwgYSBiXG5cbmxldFtAaW5saW5lIGFsd2F5c10gY29tcGFyZSAoYTppbnQpIGIgPSBhIC0gYlxubGV0W0BpbmxpbmUgYWx3YXlzXSBzaXh0ZWVuX2lmX21pbnVzX29uZV9vcl9sZXNzIG4gPSAobiBhc3IgU3lzLmludF9zaXplKSBsYW5kIDE2XG5sZXRbQGlubGluZSBhbHdheXNdIGVpZ2h0X2lmX29uZV9vcl9tb3JlIG4gPSAoKC1uKSBhc3IgU3lzLmludF9zaXplKSBsYW5kIDhcblxubGV0IGNvbXBhcmVfbGUgfmxuIGEgYiA9XG4gIGxldCByID0gcmVmIDAgaW5cbiAgbGV0IGkgPSByZWYgKHByZWQgbG4pIGluXG5cbiAgd2hpbGUgIWkgPj0gMCBkb1xuICAgIGxldCB4YSA9IGdldCBhICFpIGFuZCB4YiA9IGdldCBiICFpIGluXG4gICAgbGV0IGMgPSBjb21wYXJlIHhhIHhiIGluXG4gICAgciA6PSAhciBsb3IgKChzaXh0ZWVuX2lmX21pbnVzX29uZV9vcl9sZXNzIGMgKyBlaWdodF9pZl9vbmVfb3JfbW9yZSBjKSBsc3IgIXIpIDtcbiAgICBkZWNyIGkgO1xuICBkb25lIDtcblxuICAoIXIgbGFuZCA4KSAtICghciBsYW5kIDE2KVxuXG5sZXQgY29tcGFyZV9sZV93aXRoX2xlbiB+bGVuOmxuIGEgYiA9XG4gIGxldCBhbCA9IFN0cmluZy5sZW5ndGggYSBpblxuICBsZXQgYmwgPSBTdHJpbmcubGVuZ3RoIGIgaW5cbiAgaWYgbG4gPSAwIHRoZW4gMFxuICBlbHNlIGlmIChhbCBseG9yIGxuKSBsb3IgKGJsIGx4b3IgbG4pIDw+IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcImNvbXBhcmVfbGVfd2l0aF9sZW5cIlxuICBlbHNlIGNvbXBhcmVfbGUgfmxuIGEgYlxuXG5sZXQgY29tcGFyZV9sZSBhIGIgPVxuICBsZXQgYWwgPSBTdHJpbmcubGVuZ3RoIGEgaW5cbiAgbGV0IGJsID0gU3RyaW5nLmxlbmd0aCBiIGluXG4gIGlmIGFsIDwgYmxcbiAgdGhlbiAxXG4gIGVsc2UgaWYgYWwgPiBibFxuICB0aGVuICgtMSlcbiAgZWxzZSBjb21wYXJlX2xlIH5sbjphbCAoKiA9IGJsICopIGEgYlxuXG5sZXQgY29tcGFyZV9iZSB+bG4gYSBiID1cbiAgbGV0IHIgPSByZWYgMCBpblxuICBsZXQgaSA9IHJlZiAwIGluXG5cbiAgd2hpbGUgIWkgPCBsbiBkb1xuICAgIGxldCB4YSA9IGdldCBhICFpIGFuZCB4YiA9IGdldCBiICFpIGluXG4gICAgbGV0IGMgPSBjb21wYXJlIHhhIHhiIGluXG4gICAgciA6PSAhciBsb3IgKChzaXh0ZWVuX2lmX21pbnVzX29uZV9vcl9sZXNzIGMgKyBlaWdodF9pZl9vbmVfb3JfbW9yZSBjKSBsc3IgIXIpIDtcbiAgICBpbmNyIGkgO1xuICBkb25lIDtcblxuICAoIXIgbGFuZCA4KSAtICghciBsYW5kIDE2KVxuXG5sZXQgY29tcGFyZV9iZV93aXRoX2xlbiB+bGVuOmxuIGEgYiA9XG4gIGxldCBhbCA9IFN0cmluZy5sZW5ndGggYSBpblxuICBsZXQgYmwgPSBTdHJpbmcubGVuZ3RoIGIgaW5cbiAgaWYgbG4gPSAwIHRoZW4gMFxuICBlbHNlIGlmIChhbCBseG9yIGxuKSBsb3IgKGJsIGx4b3IgbG4pIDw+IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcImNvbXBhcmVfYmVfd2l0aF9sZW5cIlxuICBlbHNlIGNvbXBhcmVfYmUgfmxuIGEgYlxuXG5sZXQgY29tcGFyZV9iZSBhIGIgPVxuICBsZXQgYWwgPSBTdHJpbmcubGVuZ3RoIGEgaW5cbiAgbGV0IGJsID0gU3RyaW5nLmxlbmd0aCBiIGluXG4gIGlmIGFsIDwgYmwgdGhlbiAxXG4gIGVsc2UgaWYgYWwgPiBibCB0aGVuICgtMSlcbiAgZWxzZSBjb21wYXJlX2JlIH5sbjphbCAoKiA9IGJsICopIGEgYlxuXG5sZXRbQGlubGluZSBhbHdheXNdIG1pbnVzX29uZV9vcl9sZXNzIG4gPVxuICBuIGxzciAoU3lzLmludF9zaXplIC0gMSlcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBvbmVfaWZfbm90X3plcm8gbiA9XG4gIG1pbnVzX29uZV9vcl9sZXNzICgoLSBuKSBsb3IgbilcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB6ZXJvX2lmX25vdF96ZXJvIG4gPVxuICAob25lX2lmX25vdF96ZXJvIG4pIC0gMVxuXG5sZXRbQGlubGluZSBhbHdheXNdIHNlbGVjdF9pbnQgY2hvb3NlX2IgYSBiID1cbiAgbGV0IG1hc2sgPSAoKC0gY2hvb3NlX2IpIGxvciBjaG9vc2VfYikgYXNyIFN5cy5pbnRfc2l6ZSBpblxuICAoYSBsYW5kIChsbm90IG1hc2spKSBsb3IgKGIgbGFuZCBtYXNrKVxuXG5leHRlcm5hbCBpbnRfb2ZfYm9vbCA6IGJvb2wgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2Jvb2xfb2ZfaW50IDogaW50IC0+IGJvb2wgPSBcIiVpZGVudGl0eVwiXG5cbmxldFtAaW5saW5lXSBib29sX29mX2ludCBuID1cbiAgdW5zYWZlX2Jvb2xfb2ZfaW50IChvbmVfaWZfbm90X3plcm8gbilcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBmaW5kX3VpbnQ4IH5vZmYgfmxlbiB+ZiBzdHIgPVxuICBsZXQgaSA9IHJlZiAobGVuIC0gMSkgaW5cbiAgbGV0IGEgPSByZWYgKGxub3QgMCkgaW5cbiAgd2hpbGUgIWkgPj0gb2ZmIGRvXG4gICAgbGV0IGJ5dGUgPSBnZXQgc3RyICFpIGluXG4gICAgbGV0IHByZWQgPSBpbnRfb2ZfYm9vbCAoZiBieXRlKSBpblxuICAgICgqIFhYWChkaW5vc2F1cmUpOiBhIGNvbXBvc2l0aW9uIG9mIFtmXSB3aXRoIFtib29sX29mX2ludF0gc3VjaCBhc1xuICAgICAgIFtsZXQgZiA9IGJvb2xfb2ZfaW50IDwuPiBmIGluXSBpbXBsaWVzIGFuIGFsbG9jYXRpb24gKG9mIGEgY2xvc3VyZSkuXG4gICAgICAgVG8gYmUgR0MtZnJlZSwgd2UgbXVzdCBzdG9yZSByZXN1bHQgb2YgW2ZdIGludG8gYSByZWdpc3RlciwgYW5kIGFwcGx5XG4gICAgICAgW2Jvb2xfb2ZfaW50XSB0aGVuIChpbnRyb3NwZWN0aW9uIHdhcyBkb25lIG9uIE9DYW1sIDQuMDguMSkuICopXG4gICAgYSA6PSBzZWxlY3RfaW50ICgoKCFpIC0gb2ZmKSBsYW5kIG1pbl9pbnQpIGxvciBwcmVkKSAhYSAhaSA7XG4gICAgZGVjciBpIDtcbiAgZG9uZSA7ICFhXG5cbmxldCBmaW5kX3VpbnQ4ID8ob2ZmPSAwKSB+ZiBzdHIgPVxuICAoKiBYWFgoZGlub3NhdXJlKTogd2l0aCB0aGlzIG92ZXJsb2FkLCBPQ2FtbCBpcyBhYmxlIHRvIHByb2R1Y2UgMiBbZmluZF91aW50OF0uXG4gICAgIE9uZSB3aXRoIFtvZmY9IDBdIGFuZCBvbmUgb3RoZXIgd2hlcmUgW29mZl0gaXMgYW4gYXJndW1lbnQuIEkgdGhpbmsgaXQncyBhYm91dFxuICAgICBjcm9zcy1tb2R1bGUgb3B0aW1pemF0aW9uIHdoZXJlIGEgY2FsbCB0byBbZmluZF91aW50OCB+ZiB2XSB3aWxsIGRpcmVjdGx5IGNhbGxcbiAgICAgdGhlIGZpcnN0IG9uZSBhbmQgYSBjYWxsIHRvIFtmaW5kX3VpbnQ4IH5vZmY6eCB+ZiB2XSB3aWxsIGNhbGwgdGhlIHNlY29uZCBvbmUuICopXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBmaW5kX3VpbnQ4IH5vZmYgfmxlbiB+ZiBzdHJcblxubGV0IGV4aXN0c191aW50OCA/b2ZmIH5mIHN0ciA9XG4gIGxldCB2ID0gZmluZF91aW50OCA/b2ZmIH5mIHN0ciBpblxuICBsZXQgciA9IHNlbGVjdF9pbnQgKHYgKyAxKSAwIDEgaW5cbiAgdW5zYWZlX2Jvb2xfb2ZfaW50IHJcblxubGV0IGRpdm1vZCB+KHg6aW50MzIpIH4obTppbnQzMikgOiBpbnQzMiAqIGludDMyID1cbiAgKCogRGl2aXNpb24gYW5kIHJlbWFpbmRlciBiZWluZyBjb25zdGFudC10aW1lIHdpdGggcmVzcGVjdCB0byBbeF1cbiAgICogKCBOT1QgW21dICEpLiBUaGUgT0NhbWwgdmFyaWFudCB3b3VsZCBiZTpcbiAgICogWyh4IC8gbSAsIHggbW9kIG0pXSB3aGVyZSBbeF0gaXMgYSBzZWNyZXQgYW5kIFttXSBpcyBub3Qgc2VjcmV0LlxuICAgKiBBZGFwdGVkIGZyb20gdGhlIE5UUlUgUHJpbWUgdGVhbSdzIGFsZ29yaXRobSBmcm9tXG4gICAqIHN1cGVyY29wL2NyeXB0b19rZW0vc250cnVwNzYxL3JlZi91aW50MzIuY1xuICAgKiBjaXRlIHRoZSByb3VuZC0yIG50cnUgcHJpbWUgc3VibWlzc2lvbiB0byBuaXN0cHFjIChtYXJjaCAyMDE5KVxuICAgKiBOb3RlIHRoYXQgaW4gcHJhY3RpY2UgdGhpcyB3b3JrcyBmb3IgYXQgbGVhc3Qgc29tZSBtdWNoIGxhcmdlciBbeF0gYW5kIFttXSxcbiAgICogYnV0IGl0J3MgdW5jbGVhciB0byBtZSBob3cgdG8gZXZhbHVhdGUgKndoaWNoKiwgc28gbGVhdmluZyB0aGUgb3JpZ2luYWxcbiAgICogcmVzdHJpY3Rpb25zIGluLlxuICAqKVxuICBsZXQgKCAtICkgLCAoICsgKSwgKCAqICkgPSBJbnQzMi4oc3ViLCBhZGQsIG11bCkgaW5cbiAgbGV0ICggPj4gKSA9IEludDMyLnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgaW5cbiAgaWYgKG0gPD0gMGwpIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJtIDw9IDBcIikgO1xuICBpZiAobSA+PSAxNjM0OGwpIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJtID49IDE2MzQ4IG5vdCBzdXBwb3J0ZWRcIikgO1xuXG4gIGxldCBvZl91aW50MzIgdWludCA9XG4gICAgKCogYXBwYXJlbnRseSBJbnQ2NC5vZl9pbnQzMiBzaWduLWV4dGVuZHMgLi4uIGdyZWF0Li4uIGF2b2lkIHRoYXQ6ICopXG4gICAgbGV0IGIgPSBCeXRlcy5tYWtlIDggJ1xceDAwJyBpblxuICAgIFVuc2FmZS5zZXRfaW50MzJfbGUgYiAwIHVpbnQgO1xuICAgIFVuc2FmZS5nZXRfaW50NjRfbGUgYiAwXG4gIGluXG5cbiAgbGV0IHhfMCA9IHggaW5cblxuICBsZXQgeF8yLCBxXzEgPVxuICAgIGxldCBpbnQzMl9kaXZfdW5zaWduZWQgbiBkID1cbiAgICAgICgqIGNhbiBiZSByZXBsYWNlZCBieSBJbnQzMi51bnNpZ25lZF9kaXZcbiAgICAgICAqIGZyb20gT0NhbWwgPj0gNC4xMCAqKVxuICAgICAgbGV0IHN1YixtaW5faW50ID0gSW50MzIuKHN1YixtaW5faW50KWluXG4gICAgICBsZXQgaW50MzJfdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICAgICAgICBJbnQzMi5jb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcbiAgICAgIGluXG4gICAgICBpZiBkIDwgMF9sIHRoZW5cbiAgICAgICAgaWYgaW50MzJfdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gMF9sIGVsc2UgMV9sXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBxID1cbiAgICAgICAgICBsZXQgb3BlbiBJbnQzMiBpblxuICAgICAgICAgIHNoaWZ0X2xlZnQgKEludDMyLmRpdiAoSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICAgICAgbGV0IHIgPSBzdWIgbiAoSW50MzIubXVsIHEgZCkgaW5cbiAgICAgICAgaWYgaW50MzJfdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIEludDMyLnN1Y2MgcSBlbHNlIHFcbiAgICBpblxuICAgIGxldCB2ID0gaW50MzJfZGl2X3Vuc2lnbmVkIEludDMyLm1pbl9pbnQgbSB8PiBvZl91aW50MzIgaW5cbiAgICAoKmxldCB2ID0gMHg4MF8wMF8wMF8wMCAvIG0gaW4qKSAoKiBmbG9vcmVkIGRpdiAqKVxuICAgIGxldCB4XzEsIHFfMCA9XG4gICAgICBsZXQgcXBhcnRfMCA9XG4gICAgICAgIGxldCBvcGVuIEludDY0IGluXG4gICAgICAgIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG11bCAob2ZfdWludDMyIHhfMCkgdikgMzFcbiAgICAgICAgfD4gdG9faW50MzJcbiAgICAgIGluXG4gICAgICB4XzAgLSAocXBhcnRfMCAqIG0pLCBxcGFydF8wXG4gICAgaW5cbiAgICBsZXQgcXBhcnRfMSA9XG4gICAgICBsZXQgb3BlbiBJbnQ2NCBpblxuICAgICAgc2hpZnRfcmlnaHRfbG9naWNhbCAobXVsIChvZl91aW50MzIgeF8xKSB2KSAzMVxuICAgICAgfD4gdG9faW50MzIgaW5cbiAgICB4XzEgLSAocXBhcnRfMSAqIG0pLFxuICAgIChxXzAgKyBxcGFydF8xICsgMWwpIGluXG4gIGxldCB4XzMgPSB4XzIgLSBtICBpblxuICBsZXQgbWFzayA9IDBsIC0gKHhfMyA+PiAzMSkgaW5cbiAgcV8xICsgbWFzaywgeF8zICsgKEludDMyLmxvZ2FuZCBtYXNrIG0pXG5cbmxldCBhc2NpaV9vZl9pbnQzMiB+ZGlnaXRzIChuOmludDMyKSA6IHN0cmluZyA9XG4gICgqIFJlY3Vyc2l2ZWx5IGNhbGxzIFtkaXZtb2QgbiAxMF07IHRoZSByZW1haW5kZXIgaXMgdHVybmVkIGludG8gQVNDSUlcbiAgICAgYW5kIHRoZSBxdW90aWVudCBpcyB1c2VkIGZvciB0aGUgbmV4dCBkaXZpc2lvbi4qKVxuICBpZiBkaWdpdHMgPCAwIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJkaWdpdHMgPCAwXCIpO1xuICBsZXQgb3V0ID0gQnl0ZXMubWFrZSBkaWdpdHMgJzAnIGluXG4gIGxldCByZWMgbG9vcCB4ID0gZnVuY3Rpb25cbiAgICB8IC0xIC0+IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgb3V0XG4gICAgfCBpZHggLT5cbiAgICAgIGxldCBuZXh0LCB0aGlzID0gZGl2bW9kIH54IH5tOjEwbCBpblxuICAgICAgQnl0ZXMuc2V0IG91dCBpZHggQEAgY2hhcl9jaHIgKDB4MzAgbG9yIChJbnQzMi50b19pbnQgdGhpcykpIDtcbiAgICAgIGxvb3AgbmV4dCAocHJlZCBpZHgpXG4gIGluIGxvb3AgbiAocHJlZCBkaWdpdHMpXG5cbmxldFtAaW5saW5lIGFsd2F5c10gdG9faGV4X25pYmJsZSBmIDogY2hhciA9XG4gIGxldCBhID0gODYgKyBmIGluXG4gIGxldCBjID0gMSArICgoYSAtIDcxICogKChhIGxhbmQgMHgxMCkgbHNyIDQpKSBsb3IgMHgyMCkgaW5cbiAgY2hhcl9jaHIgY1xuXG5sZXQgaGV4X29mX3N0cmluZyByYXdieXRlcyA9XG4gIFN0cmluZy5pbml0ICgyICogU3RyaW5nLmxlbmd0aCByYXdieXRlcylcbiAgICAoZnVuIGlkeCAtPlxuICAgICAgIGxldCBieXQgPSBTdHJpbmcuZ2V0IHJhd2J5dGVzIChpZHggbHNyIDEpIHw+IENoYXIuY29kZSBpblxuICAgICAgICgqIHNlbGVjdCB3aGljaCA0IGJpdHMgdG8gdXNlLCB0aGlzIGNhbiBwcm9iYWJseSBiZSBkb25lIGZhc3RlcjoqKVxuICAgICAgIGxldCBuaWIgPSAweGYgbGFuZCAoYnl0IGxzciAoKChsbm90IGlkeCkgbGFuZCAxKSBsc2wgMikpIGluXG4gICAgICAgdG9faGV4X25pYmJsZSBuaWIpXG5cbmxldCBoZXhfb2ZfYnl0ZXMgcmF3Ynl0ZXMgPSBoZXhfb2Zfc3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJhd2J5dGVzKVxuXG5sZXRbQGlubGluZSBhbHdheXNdIHNlbGVjdF9hX2lmX2luX3JhbmdlIH5sb3cgfmhpZ2ggfm4gYSBiID1cbiAgKCogc2VsZWN0IFthXSBpZiBbbG93IDw9IG4gPD0gaGlnaF0gYW5kIFtiXSBpZiBbbl0gaXMgb3V0IG9mIHJhbmdlLiopXG4gICgqIE5COiBPTkxZIFdPUktTIEZPUiBbMCA8PSBsb3cgPD0gaGlnaCA8PSBtYXhfaW50XSopXG4gICgqIFRoZSBpZGVhIGJlaW5nIHRoYXQ6XG4gICAgIDEuYSkgaWYgbG93IDw9ICAgbiA6IChuIC0gbG93KSAgaXMgcG9zaXRpdmUgK1xuICAgICAxLmIpIGlmIGxvdyAgPiAgIG4gOiAobiAtIGxvdykgIGlzIG5lZ2F0aXZlIC1cbiAgICAgMi5hKSBpZiAgIG4gPD0gaGlnaDogKGhpZ2ggLSBuKSBpcyBwb3NpdGl2ZSArXG4gICAgIDIuYikgaWYgICBuICA+IGhpZ2g6IChoaWdoIC0gbikgaXMgbmVnYXRpdmUgLVxuICAgICBXZSBPUiB0aGUgbnVtYmVycyB0b2dldGhlcjsgd2Ugb25seSByZWFsbHkgY2FyZSBhYm91dCB0aGUgc2lnbiBiaXRcbiAgICAgd2hpY2ggaXMgc2V0IHdoZW4gbmVnYXRpdmUuXG4gICAgIFRodXMgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBpZmYgKGxvdyA8PSBuICYmIG4gPD0gaGlnaCkuXG4gICAgIFdlIHRoZW4gc2VsZWN0IHRoZSBzaWduIGJpdCB3aXRoIChsYW5kIG1pbl9pbnQpIGFuZCB1c2UgdGhhdCB0byBjaG9vc2U6XG4gICopXG4gIGxldCBvdXRfb2ZfcmFuZ2UgPSAoKiBjaG9vc2UgYiBpZiBvdXQgb2YgcmFuZ2UgKilcbiAgICAoKG4gLSBsb3cpIGxvciAoaGlnaCAtIG4pXG4gICAgIGxhbmQgbWluX2ludClcbiAgaW5cbiAgc2VsZWN0X2ludCBvdXRfb2ZfcmFuZ2UgYSBiXG5cbmxldCBsb3dlcmNhc2VfYXNjaWkgc3JjID1cbiAgKCogY3QgdmVyc2lvbiBvZiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpICopXG4gIFN0cmluZy5tYXBcbiAgICAoIGZ1biBjaCAtPiBsZXQgbiA9IENoYXIuY29kZSBjaCBpblxuICAgICAgKCogMHg0MSBpcyAnQSc7IDB4NWEgaXMgJ1onOyAweDIwIGNvbnRyb2xzIGNhc2UgZm9yIEFTQ0lJIGxldHRlcnMgKilcbiAgICAgIHNlbGVjdF9hX2lmX2luX3JhbmdlIH5sb3c6MHg0MSB+aGlnaDoweDVhIH5uIChuIGxvciAweDIwKSAobilcbiAgICAgIHw+IGNoYXJfY2hyXG4gICAgKSBzcmNcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzcmMgPVxuICAoKiBjdCB2ZXJzaW9uIG9mIFN0cmluZy51cHBlcmNhc2VfYXNjaWkgKilcbiAgU3RyaW5nLm1hcFxuICAgICggZnVuIGNoIC0+IGxldCBuID0gQ2hhci5jb2RlIGNoIGluXG4gICAgICAoKiAweDYxIGlzICdhJzsgMHg3YSBpcyAneic7IDB4MjAgY29udHJvbHMgY2FzZSBmb3IgQVNDSUkgbGV0dGVycyAqKVxuICAgICAgc2VsZWN0X2FfaWZfaW5fcmFuZ2UgfmxvdzoweDYxIH5oaWdoOjB4N2Egfm4gKG4gbHhvciAweDIwKSAobilcbiAgICAgIHw+IGNoYXJfY2hyXG4gICAgKSBzcmNcblxubGV0IGJ5dGVzX29mX2hleCByYXdoZXggPVxuICAoKiBoZXggbGVuZ3RoIG11c3QgYmUgbXVsdGlwbGUgb2YgMjogKilcbiAgbGV0IGVycm9yX2JpdG1hcCA9IHJlZiAoKFN0cmluZy5sZW5ndGggcmF3aGV4IGxhbmQgMSkgbHNsIDQpIGluXG4gIGxldCBkZWNvZGVkID1cbiAgICBCeXRlcy5pbml0IChTdHJpbmcubGVuZ3RoIHJhd2hleCBsc3IgMSlcbiAgICAgIChmdW4gaWR4IC0+XG4gICAgICAgICBsZXQgaWR4ID0gaWR4IGxzbCAxIGluXG4gICAgICAgICBsZXQgbmliIGlkeCA9XG4gICAgICAgICAgIFN0cmluZy5nZXQgcmF3aGV4IGlkeFxuICAgICAgICAgICB8PiBDaGFyLmNvZGVcbiAgICAgICAgICAgfD4gZnVuIG4gLT4gKCogdXBwZXJjYXNlIC0+IGxvd2VyY2FzZTogKilcbiAgICAgICAgICAgc2VsZWN0X2FfaWZfaW5fcmFuZ2UgfmxvdzoweDQxIH5oaWdoOjB4NWFcbiAgICAgICAgICAgICB+blxuICAgICAgICAgICAgIChuIGxvciAweDIwKSAoKiBzZXQgY2FzZSBiaXQgKilcbiAgICAgICAgICAgICBuICgqIGxlYXZlIGFzLWlzICopXG4gICAgICAgICAgIHw+IGZ1biBuIC0+ICgqIG5vdyBlaXRoZXIgaW52YWxpZDsgbG93ZXJjYXNlOyBudW1lcmljKilcbiAgICAgICAgICAgKHNlbGVjdF9hX2lmX2luX3JhbmdlIH5sb3c6MHgzMCB+aGlnaDoweDM5XG4gICAgICAgICAgICAgIH5uXG4gICAgICAgICAgICAgIChuIC0gMHgzMCkgKCogbnVtZXJpYzogc3VidHJhY3QgJzAnIHRvIGdldCBbMC4uOV0gKilcbiAgICAgICAgICAgICAgKHNlbGVjdF9hX2lmX2luX3JhbmdlIH5sb3c6MHg2MSB+aGlnaDoweDY2XG4gICAgICAgICAgICAgICAgIH5uXG4gICAgICAgICAgICAgICAgICgqIGEtZjogc3VidHJhY3QgJ2EnIGFuZCBhZGQgMTAgdG8gZ2V0IFsxMC4uMTVdOiAqKVxuICAgICAgICAgICAgICAgICAobiAtIDB4NjEgKyAxMClcbiAgICAgICAgICAgICAgICAgKDB4ZmYpICgqIGludmFsaWQsIGVuc3VyZSB3ZSBzZXQgdXBwZXIgYml0cyBvZiBlcnJvcl9iaXRtYXAgKilcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICApXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IG5pYmYwID0gbmliIGlkeFxuICAgICAgICAgYW5kIG5pYjBmID0gbmliIChzdWNjIGlkeCkgaW5cbiAgICAgICAgIGVycm9yX2JpdG1hcCA6PSAhZXJyb3JfYml0bWFwIGxvciBuaWJmMCBsb3IgbmliMGYgO1xuICAgICAgICAgY2hhcl9jaHIgKChuaWJmMCBsc2wgNCkgbG9yIG5pYjBmKVxuICAgICAgKVxuICBpblxuICAoKiBpZiBhbnkgbm9uLW5pYmJsZSBiaXRzIHdlcmUgc2V0IGluICFlcnJvcl9iaXRtYXAsIGRlY29kaW5nIGZhaWxlZDogKilcbiAgZGVjb2RlZCwgIWVycm9yX2JpdG1hcCBsYW5kIChsbm90IDB4ZilcblxubGV0IHN0cmluZ19vZl9oZXggcmF3aGV4ID1cbiAgbGV0IGJ5dCwgZXJyb3IgPSBieXRlc19vZl9oZXggcmF3aGV4IGluXG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnl0LCBlcnJvclxuIl19
