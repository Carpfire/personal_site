// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Str
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Domain, Stdlib__Int, Stdlib__List, Stdlib__Map, Stdlib__String
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst_str_ml = "str.ml",
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_get = runtime.caml_string_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$2,
    cst$0 = cst$2,
    cst = cst$2,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Map = global_data.Stdlib__Map,
    cst_Str_matched_group = "Str.matched_group",
    cst_Str_group_end = "Str.group_end",
    cst_Str_group_beginning = "Str.group_beginning",
    _b_ = [0, 92],
    cst_group_not_closed_by = "\\( group not closed by \\)",
    _c_ = [0, cst_str_ml, 533, 10],
    cst_class_not_closed_by = "[ class not closed by ]",
    cst_spurious_in_regular_expres = "spurious \\) in regular expression",
    cst_too_many_r_or_r_where_r_is = "too many r* or r+ where r is nullable",
    _a_ = [0, cst_str_ml, 228, 11];
   function string_before(s, n){
    return caml_call3(Stdlib_String[16], s, 0, n);
   }
   function string_after(s, n){
    return caml_call3
            (Stdlib_String[16], s, n, caml_ml_string_length(s) - n | 0);
   }
   function first_chars(s, n){return caml_call3(Stdlib_String[16], s, 0, n);}
   function last_chars(s, n){
    return caml_call3
            (Stdlib_String[16], s, caml_ml_string_length(s) - n | 0, n);
   }
   function lowercase_latin1(c){
    var _ap_ = c - 192 | 0;
    a:
    {
     if(30 < _ap_ >>> 0){
      if(25 < _ap_ + 127 >>> 0) break a;
     }
     else if(23 === _ap_) break a;
     return c + 32 | 0;
    }
    return c;
   }
   var full = caml_call2(Stdlib_Bytes[1], 32, 255);
   function make_empty(param){return caml_call2(Stdlib_Bytes[1], 32, 0);}
   function add(s, c){
    var _ao_ = caml_bytes_get(s, c >>> 3 | 0) | 1 << (c & 7);
    return caml_bytes_set(s, c >>> 3 | 0, caml_call1(Stdlib_Char[1], _ao_));
   }
   function singleton(c){var s = make_empty(0); add(s, c); return s;}
   function complement(s){
    var r = caml_create_bytes(32), i = 0;
    for(;;){
     var _am_ = caml_bytes_get(s, i) ^ 255;
     caml_bytes_set(r, i, caml_call1(Stdlib_Char[1], _am_));
     var _an_ = i + 1 | 0;
     if(31 === i) return r;
     var i = _an_;
    }
   }
   function union(s1, s2){
    var r = caml_create_bytes(32), i = 0;
    for(;;){
     var _aj_ = caml_bytes_get(s2, i), _ak_ = caml_bytes_get(s1, i) | _aj_;
     caml_bytes_set(r, i, caml_call1(Stdlib_Char[1], _ak_));
     var _al_ = i + 1 | 0;
     if(31 === i) return r;
     var i = _al_;
    }
   }
   function disjoint(s1, s2){
    try{
     var i = 0;
     for(;;){
      var _ag_ = caml_bytes_get(s2, i);
      if(0 !== (caml_bytes_get(s1, i) & _ag_))
       throw caml_maybe_attach_backtrace(Stdlib[3], 1);
      var _ah_ = i + 1 | 0;
      if(31 === i){var _af_ = 1; return _af_;}
      var i = _ah_;
     }
    }
    catch(_ai_){
     var _ae_ = caml_wrap_exception(_ai_);
     if(_ae_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_ae_, 0);
    }
   }
   function iter(fn, s){
    var i = 0;
    for(;;){
     var c = caml_bytes_get(s, i);
     if(0 !== c){
      var j = 0;
      for(;;){
       if(0 !== (c & 1 << j))
        caml_call1(fn, caml_call1(Stdlib_Char[1], (i << 3) + j | 0));
       var _ad_ = j + 1 | 0;
       if(7 === j) break;
       var j = _ad_;
      }
     }
     var _ac_ = i + 1 | 0;
     if(31 === i) return;
     var i = _ac_;
    }
   }
   function fold_case(s){
    var r = make_empty(0);
    iter
     (function(c){
       add(r, lowercase_latin1(c));
       var _aa_ = c - 224 | 0;
       a:
       {
        b:
        {
         if(30 < _aa_ >>> 0){
          if(25 < _aa_ + 127 >>> 0) break b;
         }
         else if(23 === _aa_) break b;
         var _ab_ = c - 32 | 0;
         break a;
        }
        var _ab_ = c;
       }
       return add(r, _ab_);
      },
      s);
    return r;
   }
   var
    op_CHAR = 0,
    op_CHARNORM = 1,
    op_STRING = 2,
    op_STRINGNORM = 3,
    op_CHARCLASS = 4,
    op_BOL = 5,
    op_EOL = 6,
    op_WORDBOUNDARY = 7,
    op_BEGGROUP = 8,
    op_ENDGROUP = 9,
    op_REFGROUP = 10,
    op_ACCEPT = 11,
    op_SIMPLEOPT = 12,
    op_SIMPLESTAR = 13,
    op_SIMPLEPLUS = 14,
    op_GOTO = 15,
    op_PUSHBACK = 16,
    op_SETMARK = 17,
    op_CHECKPROGRESS = 18;
   function instr(opc, arg){return opc | arg << 8;}
   function displ(dest, from){return (dest - from | 0) - 1 | 0;}
   function is_nullable(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number")
      switch(param$0){case 0: return 1;case 1: return 1;default: return 1;}
     switch(param$0[0]){
       case 0:
        return 0;
       case 1:
        var s = param$0[1]; return caml_string_equal(s, cst$2);
       case 2:
        return 0;
       case 3:
        var rl = param$0[1];
        return caml_call2(Stdlib_List[33], is_nullable, rl);
       case 4:
        var r2 = param$0[2], r1 = param$0[1], _$_ = is_nullable(r1);
        if(_$_) return _$_;
        var param$0 = r2;
        break;
       case 5:
        return 1;
       case 6:
        var r = param$0[1], param$0 = r; break;
       case 7:
        return 1;
       case 8:
        var r$0 = param$0[2], param$0 = r$0; break;
       default: return 1;
     }
    }
   }
   function first$0(counter, param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number")
      switch(param$0){
        case 0:
         return full;
        case 1:
         return full;
        default: return full;
      }
     switch(param$0[0]){
       case 0:
        var c = param$0[1]; return singleton(c);
       case 1:
        var s = param$0[1];
        return caml_string_equal(s, cst$2)
                ? full
                : singleton(caml_string_get(s, 0));
       case 2:
        var cmpl = param$0[2], cl = param$0[1];
        return cmpl ? complement(cl) : cl;
       case 3:
        var rl = param$0[1];
        if(counter >= 50) return caml_trampoline_return(first_seq$0, [0, rl]);
        var counter$0 = counter + 1 | 0;
        return first_seq$0(counter$0, rl);
       case 4:
        var r2 = param$0[2], r1 = param$0[1], ___ = first(r2);
        return union(first(r1), ___);
       case 5:
        return full;
       case 6:
        var r = param$0[1], param$0 = r; break;
       case 7:
        return full;
       case 8:
        var r$0 = param$0[2], param$0 = r$0; break;
       default: return full;
     }
    }
   }
   function first_seq$0(counter, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return full;
     var r = param$0[1];
     if(typeof r !== "number")
      switch(r[0]){
        case 5:
         var rl$0 = param$0[2], r$0 = r[1], _Y_ = first_seq(rl$0);
         return union(first(r$0), _Y_);
        case 7:
         var rl$1 = param$0[2], r$1 = r[1], _Z_ = first_seq(rl$1);
         return union(first(r$1), _Z_);
        default:
         if(counter >= 50) return caml_trampoline_return(first$0, [0, r]);
         var counter$0 = counter + 1 | 0;
         return first$0(counter$0, r);
      }
     var rl = param$0[2], param$0 = rl;
    }
   }
   function first(param){return caml_trampoline(first$0(0, param));}
   function first_seq(param){return caml_trampoline(first_seq$0(0, param));}
   function charclass_of_regexp(fold_case$0, re){
    a:
    if(typeof re !== "number"){
     switch(re[0]){
       case 0:
        var c = re[1], compl = 0, cl1 = singleton(c); break;
       case 2:
        var compl$0 = re[2], cl = re[1], compl = compl$0, cl1 = cl; break;
       default: break a;
     }
     var
      cl2 = fold_case$0 ? fold_case(cl1) : cl1,
      _X_ = compl ? complement(cl2) : cl2;
     return caml_call1(Stdlib_Bytes[6], _X_);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   var t = caml_create_bytes(256), i = 0;
   for(;;){
    caml_bytes_set(t, i, lowercase_latin1(caml_call1(Stdlib_Char[1], i)));
    var _e_ = i + 1 | 0;
    if(255 === i) break;
    var i = _e_;
   }
   var
    fold_case_table = caml_call1(Stdlib_Bytes[6], t),
    compare = runtime.caml_string_compare,
    StringMap = caml_call1(Stdlib_Map[1], [0, compare]);
   function compile(fold_case$0, re){
    var
     prog = [0, caml_make_vect(32, 0)],
     progpos = [0, 0],
     cpool = [0, StringMap[1]],
     cpoolpos = [0, 0],
     numgroups = [0, 1],
     numregs = [0, 0];
    function emit_instr(opc, arg){
     if(prog[1].length - 1 <= progpos[1]){
      var newlen = [0, prog[1].length - 1];
      for(;;){
       if(newlen[1] > progpos[1]){
        var nprog = caml_make_vect(newlen[1], 0);
        caml_call5(Stdlib_Array[8], prog[1], 0, nprog, 0, prog[1].length - 1);
        prog[1] = nprog;
        break;
       }
       newlen[1] = newlen[1] * 2 | 0;
      }
     }
     var _V_ = instr(opc, arg), _W_ = progpos[1];
     caml_check_bound(prog[1], _W_)[1 + _W_] = _V_;
     progpos[1]++;
     return;
    }
    function emit_hole(param){
     var p = progpos[1];
     emit_instr(op_CHAR, 0);
     return p;
    }
    function patch_instr(pos, opc, dest){
     var _U_ = instr(opc, displ(dest, pos));
     caml_check_bound(prog[1], pos)[1 + pos] = _U_;
     return;
    }
    function cpool_index(s){
     try{var _S_ = caml_call2(StringMap[17], s, cpool[1]); return _S_;}
     catch(_T_){
      var _R_ = caml_wrap_exception(_T_);
      if(_R_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_R_, 0);
      var p = cpoolpos[1];
      cpool[1] = caml_call3(StringMap[2], s, p, cpool[1]);
      cpoolpos[1]++;
      return p;
     }
    }
    function allocate_register_if_nullable(r){
     if(! is_nullable(r)) return -1;
     var n = numregs[1];
     if(64 <= n) caml_call1(Stdlib[2], cst_too_many_r_or_r_where_r_is);
     numregs[1]++;
     return n;
    }
    function emit_code(param){
     if(typeof param === "number")
      switch(param){
        case 0:
         return emit_instr(op_BOL, 0);
        case 1:
         return emit_instr(op_EOL, 0);
        default: return emit_instr(op_WORDBOUNDARY, 0);
      }
     switch(param[0]){
       case 0:
        var c = param[1];
        return fold_case$0
                ? emit_instr(op_CHARNORM, lowercase_latin1(c))
                : emit_instr(op_CHAR, c);
       case 1:
        var s = param[1], match = caml_ml_string_length(s);
        if(0 === match) return;
        if(1 === match)
         return fold_case$0
                 ? emit_instr
                   (op_CHARNORM, lowercase_latin1(caml_string_get(s, 0)))
                 : emit_instr(op_CHAR, caml_string_get(s, 0));
        try{
         var i = caml_call2(Stdlib_String[36], s, 0);
         emit_code([1, string_before(s, i)]);
         emit_instr(op_CHAR, 0);
         emit_code([1, string_after(s, i + 1 | 0)]);
         return;
        }
        catch(_Q_){
         var _M_ = caml_wrap_exception(_Q_);
         if(_M_ === Stdlib[8])
          return fold_case$0
                  ? emit_instr
                    (op_STRINGNORM,
                     cpool_index
                      (caml_call2(Stdlib_String[18], lowercase_latin1, s)))
                  : emit_instr(op_STRING, cpool_index(s));
         throw caml_maybe_attach_backtrace(_M_, 0);
        }
       case 2:
        var
         compl = param[2],
         cl = param[1],
         cl1 = fold_case$0 ? fold_case(cl) : cl,
         cl2 = compl ? complement(cl1) : cl1;
        return emit_instr
                (op_CHARCLASS, cpool_index(caml_call1(Stdlib_Bytes[6], cl2)));
       case 3:
        var rl = param[1], param$0 = rl;
        for(;;){
         if(! param$0) return;
         var r$3 = param$0[1];
         if(typeof r$3 !== "number")
          a:
          switch(r$3[0]){
            case 5:
             var r$4 = r$3[1];
             if(typeof r$4 !== "number")
              switch(r$4[0]){
                case 0:
                case 2:
                 var rl$1 = param$0[2], _N_ = first_seq(rl$1);
                 if(! disjoint_modulo_case(first(r$4), _N_)) break a;
                 emit_instr
                  (op_SIMPLESTAR,
                   cpool_index(charclass_of_regexp(fold_case$0, r$4)));
                 var param$0 = rl$1;
                 continue;
              }
             break;
            case 6:
             var r$5 = r$3[1];
             if(typeof r$5 !== "number")
              switch(r$5[0]){
                case 0:
                case 2:
                 var rl$2 = param$0[2], _O_ = first_seq(rl$2);
                 if(! disjoint_modulo_case(first(r$5), _O_)) break a;
                 emit_instr
                  (op_SIMPLEPLUS,
                   cpool_index(charclass_of_regexp(fold_case$0, r$5)));
                 var param$0 = rl$2;
                 continue;
              }
             break;
            case 7:
             var r$6 = r$3[1];
             if(typeof r$6 !== "number")
              switch(r$6[0]){
                case 0:
                case 2:
                 var rl$3 = param$0[2], _P_ = first_seq(rl$3);
                 if(! disjoint_modulo_case(first(r$6), _P_)) break a;
                 emit_instr
                  (op_SIMPLEOPT,
                   cpool_index(charclass_of_regexp(fold_case$0, r$6)));
                 var param$0 = rl$3;
                 continue;
              }
             break;
          }
         var rl$0 = param$0[2];
         emit_code(r$3);
         var param$0 = rl$0;
        }
        break;
       case 4:
        var r2 = param[2], r1 = param[1], pos_pushback = emit_hole(0);
        emit_code(r1);
        var pos_goto_end = emit_hole(0), lbl1 = progpos[1];
        emit_code(r2);
        var lbl2 = progpos[1];
        patch_instr(pos_pushback, op_PUSHBACK, lbl1);
        return patch_instr(pos_goto_end, op_GOTO, lbl2);
       case 5:
        var
         r = param[1],
         regno = allocate_register_if_nullable(r),
         lbl1$0 = emit_hole(0);
        if(0 <= regno) emit_instr(op_SETMARK, regno);
        emit_code(r);
        if(0 <= regno) emit_instr(op_CHECKPROGRESS, regno);
        emit_instr(op_GOTO, displ(lbl1$0, progpos[1]));
        var lbl2$0 = progpos[1];
        return patch_instr(lbl1$0, op_PUSHBACK, lbl2$0);
       case 6:
        var
         r$0 = param[1],
         regno$0 = allocate_register_if_nullable(r$0),
         lbl1$1 = progpos[1];
        emit_code(r$0);
        if(0 <= regno$0) emit_instr(op_CHECKPROGRESS, regno$0);
        var pos_pushback$0 = emit_hole(0);
        if(0 <= regno$0) emit_instr(op_SETMARK, regno$0);
        emit_instr(op_GOTO, displ(lbl1$1, progpos[1]));
        var lbl2$1 = progpos[1];
        return patch_instr(pos_pushback$0, op_PUSHBACK, lbl2$1);
       case 7:
        var r$1 = param[1], pos_pushback$1 = emit_hole(0);
        emit_code(r$1);
        var lbl = progpos[1];
        return patch_instr(pos_pushback$1, op_PUSHBACK, lbl);
       case 8:
        var r$2 = param[2], n = param[1];
        emit_instr(op_BEGGROUP, n);
        emit_code(r$2);
        emit_instr(op_ENDGROUP, n);
        numgroups[1] = caml_call2(Stdlib_Int[11], numgroups[1], n + 1 | 0);
        return;
       default:
        var n$0 = param[1];
        emit_instr(op_REFGROUP, n$0);
        numgroups[1] = caml_call2(Stdlib_Int[11], numgroups[1], n$0 + 1 | 0);
        return;
     }
    }
    function disjoint_modulo_case(c1, c2){
     if(! fold_case$0) return disjoint(c1, c2);
     var _L_ = fold_case(c2);
     return disjoint(fold_case(c1), _L_);
    }
    emit_code(re);
    emit_instr(op_ACCEPT, 0);
    var start = first(re), start$0 = fold_case$0 ? fold_case(start) : start;
    if(runtime.caml_bytes_equal(start, full))
     var start_pos = -1;
    else{
     var r = caml_call2(Stdlib_Bytes[1], 256, 0);
     iter(function(c){return caml_bytes_set(r, c, 1);}, start$0);
     var start_pos = cpool_index(caml_call1(Stdlib_Bytes[6], r));
    }
    var constantpool = caml_make_vect(cpoolpos[1], cst$2), _H_ = cpool[1];
    function _I_(str, idx){
     caml_check_bound(constantpool, idx)[1 + idx] = str;
     return 0;
    }
    caml_call2(StringMap[23], _I_, _H_);
    var
     _J_ = numregs[1],
     _K_ = numgroups[1],
     fold_case_table$0 = fold_case$0 ? fold_case_table : cst;
    return [0,
            caml_call3(Stdlib_Array[5], prog[1], 0, progpos[1]),
            constantpool,
            fold_case_table$0,
            _K_,
            _J_,
            start_pos];
   }
   function flush(buf){
    var s = caml_call1(Stdlib_Buffer[2], buf[1]);
    caml_call1(Stdlib_Buffer[8], buf[1]);
    var match = caml_ml_string_length(s);
    if(0 === match) return;
    if(1 === match){
     var _G_ = buf[2];
     buf[2] = [0, [0, caml_string_get(s, 0)], _G_];
     return;
    }
    buf[2] = [0, [1, s], buf[2]];
    return;
   }
   var dotclass = complement(singleton(10));
   function parse(s){
    var len = caml_ml_string_length(s), group_counter = [0, 1];
    function regexp0(i){
     var match = regexp1(i), j = match[2], r1 = match[1], r1$0 = r1, i$0 = j;
     for(;;){
      if
       ((i$0 + 2 | 0) <= len
        &&
         92 === caml_string_get(s, i$0)
         && 124 === caml_string_get(s, i$0 + 1 | 0)){
       var
        match$0 = regexp1(i$0 + 2 | 0),
        j$0 = match$0[2],
        r2 = match$0[1],
        r1$1 = [4, r1$0, r2],
        r1$0 = r1$1,
        i$0 = j$0;
       continue;
      }
      return [0, r1$0, i$0];
     }
    }
    function regexp1(i){
     var buf = [0, caml_call1(Stdlib_Buffer[1], 16), 0], i$0 = i;
     for(;;){
      a:
      if(len > i$0){
       if((i$0 + 2 | 0) <= len && 92 === caml_string_get(s, i$0)){
        var
         c$0 = caml_string_get(s, i$0 + 1 | 0),
         _D_ = 124 === c$0 ? 1 : 0,
         _E_ = _D_ || (41 === c$0 ? 1 : 0);
        if(_E_) break a;
       }
       var c$1 = caml_string_get(s, i$0);
       b:
       if(36 === c$1)
        var match = [0, 1, i$0 + 1 | 0];
       else{
        if(91 <= c$1){
         if(95 > c$1)
          switch(c$1 - 91 | 0){
            case 0:
             var i$5 = i$0 + 1 | 0;
             c:
             {
              if(i$5 < len && 94 === caml_string_get(s, i$5)){
               var
                match$2 = regexpclass1(i$5 + 1 | 0),
                j$2 = match$2[2],
                c$4 = match$2[1],
                match$0 = [0, c$4, 1, j$2];
               break c;
              }
              var
               match$3 = regexpclass1(i$5),
               j$3 = match$3[2],
               c$5 = match$3[1],
               match$0 = [0, c$5, 0, j$3];
             }
             var
              j$0 = match$0[3],
              compl = match$0[2],
              c$2 = match$0[1],
              match = [0, [2, c$2, compl], j$0];
             break b;
            case 1:
             var i$6 = i$0 + 1 | 0;
             c:
             if(len <= i$6)
              var _F_ = [0, _b_, i$6];
             else{
              var c$3 = caml_string_get(s, i$6);
              d:
              {
               if(58 <= c$3){
                if(98 === c$3){var _F_ = [0, 2, i$6 + 1 | 0]; break c;}
                if(124 !== c$3) break d;
               }
               else{
                var switcher$0 = c$3 - 40 | 0;
                if(1 < switcher$0 >>> 0){
                 if(9 > switcher$0) break d;
                 var _F_ = [0, [9, c$3 - 48 | 0], i$6 + 1 | 0];
                 break c;
                }
                if(! switcher$0){
                 var group_no = group_counter[1];
                 group_counter[1]++;
                 var
                  match$1 = regexp0(i$6 + 1 | 0),
                  j$1 = match$1[2],
                  r$3 = match$1[1];
                 if
                  ((j$1 + 1 | 0) < len
                   &&
                    92 === caml_string_get(s, j$1)
                    && 41 === caml_string_get(s, j$1 + 1 | 0)){
                  var _F_ = [0, [8, group_no, r$3], j$1 + 2 | 0];
                  break c;
                 }
                 var _F_ = caml_call1(Stdlib[2], cst_group_not_closed_by);
                 break c;
                }
               }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
              }
              var _F_ = [0, [0, c$3], i$6 + 1 | 0];
             }
             var match = _F_;
             break b;
            case 2: break;
            default: var match = [0, 0, i$0 + 1 | 0]; break b;
          }
        }
        else if(46 === c$1){
         var match = [0, [2, dotclass, 0], i$0 + 1 | 0];
         break b;
        }
        var match = [0, [0, c$1], i$0 + 1 | 0];
       }
       var j = match[2], r = match[1];
       b:
       c:
       {
        var re = r, i$1 = j;
        for(;;){
         if(len <= i$1) break c;
         var switcher = caml_string_get(s, i$1) - 42 | 0;
         if(1 < switcher >>> 0){
          if(21 !== switcher) break;
          var i$2 = i$1 + 1 | 0, r$0 = [7, re], re = r$0, i$1 = i$2;
         }
         else if(switcher)
          var i$3 = i$1 + 1 | 0, r$1 = [6, re], re = r$1, i$1 = i$3;
         else
          var i$4 = i$1 + 1 | 0, r$2 = [5, re], re = r$2, i$1 = i$4;
        }
        break b;
       }
       b:
       {
        if(typeof re !== "number" && 0 === re[0]){
         var c = re[1];
         caml_call2(Stdlib_Buffer[12], buf[1], c);
         break b;
        }
        flush(buf);
        buf[2] = [0, re, buf[2]];
       }
       var i$0 = i$1;
       continue;
      }
      flush(buf);
      return [0, [3, caml_call1(Stdlib_List[10], buf[2])], i$0];
     }
    }
    function regexpclass1(start){
     var c = make_empty(0), i$0 = start;
     for(;;){
      if(len <= i$0) caml_call1(Stdlib[2], cst_class_not_closed_by);
      if(93 === caml_string_get(s, i$0) && start < i$0){var j = i$0 + 1 | 0; return [0, c, j];}
      var c1 = caml_string_get(s, i$0);
      if
       ((i$0 + 2 | 0) < len
        &&
         45 === caml_string_get(s, i$0 + 1 | 0)
         && 93 !== caml_string_get(s, i$0 + 2 | 0)){
       var c2 = caml_string_get(s, i$0 + 2 | 0);
       if(c2 >= c1){
        var i = c1;
        for(;;){
         add(c, caml_call1(Stdlib_Char[1], i));
         var _C_ = i + 1 | 0;
         if(c2 === i) break;
         var i = _C_;
        }
       }
       var i$2 = i$0 + 3 | 0, i$0 = i$2;
       continue;
      }
      add(c, c1);
      var i$1 = i$0 + 1 | 0, i$0 = i$1;
     }
    }
    var match = regexp0(0), j = match[2], r = match[1];
    return j === len
            ? r
            : caml_call1(Stdlib[2], cst_spurious_in_regular_expres);
   }
   function regexp(e){return compile(0, parse(e));}
   function regexp_case_fold(e){return compile(1, parse(e));}
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_create_bytes(2 * len | 0),
     pos = [0, 0],
     _y_ = len - 1 | 0,
     _x_ = 0;
    if(_y_ >= 0){
     var i = _x_;
     for(;;){
      var c = caml_string_get(s, i), _z_ = c - 63 | 0;
      a:
      {
       b:
       {
        if(31 < _z_ >>> 0){
         var _A_ = _z_ + 27 | 0;
         if(10 < _A_ >>> 0) break b;
         switch(_A_){case 0:case 6:case 7:case 10: break;default: break b;
         }
        }
        else if(26 >= _z_ - 1 >>> 0) break b;
        caml_bytes_set(buf, pos[1], 92);
        caml_bytes_set(buf, pos[1] + 1 | 0, c);
        pos[1] = pos[1] + 2 | 0;
        break a;
       }
       caml_bytes_set(buf, pos[1], c);
       pos[1] = pos[1] + 1 | 0;
      }
      var _B_ = i + 1 | 0;
      if(_y_ === i) break;
      var i = _B_;
     }
    }
    return caml_call3(Stdlib_Bytes[8], buf, 0, pos[1]);
   }
   function regexp_string(s){return compile(0, [1, s]);}
   function regexp_string_case_fold(s){return compile(1, [1, s]);}
   function _d_(param){return [0];}
   var last_search_result_key = caml_call2(Stdlib_Domain[10][1], 0, _d_);
   function string_match(re, s, pos){
    var res = runtime.re_string_match(re, s, pos);
    caml_call2(Stdlib_Domain[10][3], last_search_result_key, res);
    return 0 < res.length - 1 ? 1 : 0;
   }
   function string_partial_match(re, s, pos){
    var res = runtime.re_partial_match(re, s, pos);
    caml_call2(Stdlib_Domain[10][3], last_search_result_key, res);
    return 0 < res.length - 1 ? 1 : 0;
   }
   function search_forward(re, s, pos){
    var res = runtime.re_search_forward(re, s, pos);
    caml_call2(Stdlib_Domain[10][3], last_search_result_key, res);
    if(0 === res.length - 1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    return caml_check_bound(res, 0)[1];
   }
   function search_backward(re, s, pos){
    var res = runtime.re_search_backward(re, s, pos);
    caml_call2(Stdlib_Domain[10][3], last_search_result_key, res);
    if(0 === res.length - 1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    return caml_check_bound(res, 0)[1];
   }
   function group_beginning(n){
    var
     last_search_result =
       caml_call1(Stdlib_Domain[10][2], last_search_result_key),
     n2 = n + n | 0;
    if(0 <= n && last_search_result.length - 1 > n2){
     var pos = caml_check_bound(last_search_result, n2)[1 + n2];
     if(-1 === pos) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     return pos;
    }
    return caml_call1(Stdlib[1], cst_Str_group_beginning);
   }
   function group_end(n){
    var
     last_search_result =
       caml_call1(Stdlib_Domain[10][2], last_search_result_key),
     n2 = n + n | 0;
    if(0 <= n && last_search_result.length - 1 > n2){
     var
      _w_ = n2 + 1 | 0,
      pos = caml_check_bound(last_search_result, _w_)[1 + _w_];
     if(-1 === pos) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     return pos;
    }
    return caml_call1(Stdlib[1], cst_Str_group_end);
   }
   function matched_group(n, txt){
    var
     last_search_result =
       caml_call1(Stdlib_Domain[10][2], last_search_result_key),
     n2 = n + n | 0;
    if(0 <= n && last_search_result.length - 1 > n2){
     var
      b = caml_check_bound(last_search_result, n2)[1 + n2],
      _v_ = n2 + 1 | 0,
      e = caml_check_bound(last_search_result, _v_)[1 + _v_];
     if(-1 === b) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     return caml_call3(Stdlib_String[16], txt, b, e - b | 0);
    }
    return caml_call1(Stdlib[1], cst_Str_matched_group);
   }
   function match_beginning(param){return group_beginning(0);}
   function match_end(param){return group_end(0);}
   function matched_string(txt){return matched_group(0, txt);}
   function replace_matched(repl, matched){
    var
     last_search_result =
       caml_call1(Stdlib_Domain[10][2], last_search_result_key);
    return runtime.re_replacement_text(repl, last_search_result, matched);
   }
   function substitute_first(expr, repl_fun, text){
    try{
     var
      pos = search_forward(expr, text, 0),
      _q_ = [0, string_after(text, match_end(0)), 0],
      _r_ = [0, caml_call1(repl_fun, text), _q_],
      _s_ = [0, string_before(text, pos), _r_],
      _t_ = caml_call2(Stdlib_String[7], cst$0, _s_);
     return _t_;
    }
    catch(_u_){
     var _p_ = caml_wrap_exception(_u_);
     if(_p_ === Stdlib[8]) return text;
     throw caml_maybe_attach_backtrace(_p_, 0);
    }
   }
   function opt_search_forward(re, s, pos){
    try{var _n_ = [0, search_forward(re, s, pos)]; return _n_;}
    catch(_o_){
     var _m_ = caml_wrap_exception(_o_);
     if(_m_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_m_, 0);
    }
   }
   function global_substitute(expr, repl_fun, text){
    var accu = 0, start = 0, last_was_empty = 0;
    for(;;){
     var startpos = last_was_empty ? start + 1 | 0 : start;
     if(caml_ml_string_length(text) < startpos)
      var _k_ = [0, string_after(text, start), accu];
     else{
      var match = opt_search_forward(expr, text, startpos);
      if(match){
       var
        pos = match[1],
        end_pos = match_end(0),
        repl_text = caml_call1(repl_fun, text),
        last_was_empty$0 = end_pos === pos ? 1 : 0,
        accu$0 =
          [0,
           repl_text,
           [0,
            caml_call3(Stdlib_String[16], text, start, pos - start | 0),
            accu]],
        accu = accu$0,
        start = end_pos,
        last_was_empty = last_was_empty$0;
       continue;
      }
      var _k_ = [0, string_after(text, start), accu];
     }
     var _l_ = caml_call1(Stdlib_List[10], _k_);
     return caml_call2(Stdlib_String[7], cst$1, _l_);
    }
   }
   function global_replace(expr, repl, text){
    return global_substitute
            (expr, function(_j_){return replace_matched(repl, _j_);}, text);
   }
   function replace_first(expr, repl, text){
    return substitute_first
            (expr, function(_i_){return replace_matched(repl, _i_);}, text);
   }
   function opt_search_forward_progress(expr, text, start){
    var match = opt_search_forward(expr, text, start);
    if(! match) return 0;
    var pos = match[1];
    return start < match_end(0)
            ? [0, pos]
            : start
              < caml_ml_string_length(text)
              ? opt_search_forward(expr, text, start + 1 | 0)
              : 0;
   }
   function bounded_split(expr, text, num){
    var
     start = string_match(expr, text, 0) ? match_end(0) : 0,
     accu = 0,
     start$0 = start,
     n = num;
    for(;;){
     if(caml_ml_string_length(text) <= start$0)
      var _h_ = accu;
     else if(1 === n)
      var _h_ = [0, string_after(text, start$0), accu];
     else{
      var match = opt_search_forward_progress(expr, text, start$0);
      if(match){
       var
        pos = match[1],
        n$0 = n - 1 | 0,
        start$1 = match_end(0),
        accu$0 =
          [0,
           caml_call3(Stdlib_String[16], text, start$0, pos - start$0 | 0),
           accu],
        accu = accu$0,
        start$0 = start$1,
        n = n$0;
       continue;
      }
      var _h_ = [0, string_after(text, start$0), accu];
     }
     return caml_call1(Stdlib_List[10], _h_);
    }
   }
   function split(expr, text){return bounded_split(expr, text, 0);}
   function bounded_split_delim(expr, text, num){
    if(caml_string_equal(text, cst$2)) return 0;
    var accu = 0, start = 0, n = num;
    for(;;){
     if(caml_ml_string_length(text) < start)
      var _g_ = accu;
     else if(1 === n)
      var _g_ = [0, string_after(text, start), accu];
     else{
      var match = opt_search_forward_progress(expr, text, start);
      if(match){
       var
        pos = match[1],
        n$0 = n - 1 | 0,
        start$0 = match_end(0),
        accu$0 =
          [0,
           caml_call3(Stdlib_String[16], text, start, pos - start | 0),
           accu],
        accu = accu$0,
        start = start$0,
        n = n$0;
       continue;
      }
      var _g_ = [0, string_after(text, start), accu];
     }
     return caml_call1(Stdlib_List[10], _g_);
    }
   }
   function split_delim(expr, text){
    return bounded_split_delim(expr, text, 0);
   }
   function bounded_full_split(expr, text, num){
    var accu = 0, start = 0, n = num;
    for(;;){
     if(caml_ml_string_length(text) <= start)
      var _f_ = accu;
     else if(1 === n)
      var _f_ = [0, [0, string_after(text, start)], accu];
     else{
      var match = opt_search_forward_progress(expr, text, start);
      if(match){
       var pos = match[1], s = matched_string(text);
       if(start < pos){
        var
         n$0 = n - 1 | 0,
         start$0 = match_end(0),
         accu$0 =
           [0,
            [1, s],
            [0,
             [0, caml_call3(Stdlib_String[16], text, start, pos - start | 0)],
             accu]],
         accu = accu$0,
         start = start$0,
         n = n$0;
        continue;
       }
       var
        n$1 = n - 1 | 0,
        start$1 = match_end(0),
        accu$1 = [0, [1, s], accu],
        accu = accu$1,
        start = start$1,
        n = n$1;
       continue;
      }
      var _f_ = [0, [0, string_after(text, start)], accu];
     }
     return caml_call1(Stdlib_List[10], _f_);
    }
   }
   function full_split(expr, text){return bounded_full_split(expr, text, 0);}
   var
    Str =
      [0,
       regexp,
       regexp_case_fold,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_backward,
       string_partial_match,
       matched_string,
       match_beginning,
       match_end,
       matched_group,
       group_beginning,
       group_end,
       global_replace,
       replace_first,
       global_substitute,
       substitute_first,
       replace_matched,
       split,
       bounded_split,
       split_delim,
       bounded_split_delim,
       full_split,
       bounded_full_split,
       string_before,
       string_after,
       first_chars,
       last_chars];
   runtime.caml_register_global(28, Str, "Str");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdHIuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbXSwic291cmNlcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJLE87Rzs7STs7Rzs4QixPLHVDOztJLE87O0c7O0k7Ozs7Ozs7Szs7STtHO0csVzs4QixPLG1DOztJLFc7SSxPLCtCO0c7eUIsdUIsVyxTOztJLEksSTs7SyxXO0sscUI7SztrQjs7O0c7O0ksSSxJOztLLEksTyx1QixPO0sscUI7SztrQjs7O0c7O0k7OztNLFc7Z0I7TyxNOzttQixjOzs7Ozs7NEI7OztHOztJOztLLFE7Ozs7O1EsZTtPOzs7OztLOzs7O0c7O0k7STs7TztPOzs7Ozs7Ozs7Ozs7OztPO007O0k7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCLHNCOzhCLGlDOztJO0k7OzhCLGlCLGtCOzs7UTs7NEIsTzs7UTs7O1EsTzs7USxzQztRLFE7Ozs7UTs7OztROzs7Z0I7OztHOztJO0k7Ozs7Ozs7Ozs7OzRCOzs7USxPOzs0Qjs7O1E7OztRLGtCLE87O1E7O1Esc0M7UTs7Ozs7Ozs7Ozs7O0c7O0k7STs7Ozs7O1MsbUM7Uzs7UyxtQztTOztTLGtCLE87O1M7Ozs7Rzt5Qjs2Qjs7STs7Ozs7Ozs7O0s7O007SyxPOztJLE07RztHLEksSTs7SSxzQztJOzs7O0c7SSxrQjs7OztJO0ssVztLO0s7SztLO0s7O0s7TTs7O1EsWTtROzs7Ozs7O0ssSTtLOzs7STs7SztLO0s7STs7SztLO0s7STs7SyxJLFUsd0M7Ozs7O2lCOztNOztJOztLLHFCOztpQjs7SztJOztLOzs7Uzs7UztpQjs7Ozs7UTs7OztRLGtCLFE7d0I7Ozs7a0Q7dUM7UTtTLFE7UztTO1M7Uzs7Ozs7Ozs7O3VCOzs7OztROzs7UztTO1E7MkM7OztRO3VCOzs7Ozs7Ozs7OztpQix1QjtpQjtpQjs7Ozs7Ozs7Ozs7OztpQix1QjtpQjtpQjs7Ozs7Ozs7Ozs7OztpQix1QjtpQjtpQjs7Ozs7Ozs7O1M7Ozs7O1Esa0M7UTtRLEksNkI7UTs7UTtROztROztTO1M7dUI7UTt1QjtROztROztROztTO1M7UTt5QjtRO3lCO1E7O1E7O1Esb0I7UTs7UTs7O1E7UTtRO3VCOzs7O1E7dUI7OztJOztLLGtCO0s7SztJO0k7STtJLEksbUI7SSxHOzs7SyxRO0ssaUIsTyx3QjtpQzs7SSxJLGUsb0M7O0s7SztJO0k7Ozs7O0k7WTs7Ozs7Ozs7SSxRO0k7O29COzs7c0I7Ozs7O0c7Rzs7SSxvQzs7SyxJO0s7TTs7O2dCO29CO087UTs7O1E7Ozs7O007O0k7O0ssSSxVO0s7OztPLGtDO1E7UyxNOzs7OztPLFU7Ozs7Ozs7OzthOzs7Yyx1QjtlO2dCOzs7Ozs7YztlOzs7Ozs7Ozs7Ozs7YTs7Ozs7YyxVOzs7Ozs7OztnQjs7Ozs7Ozs7aUI7aUI7a0I7OztpQjs7OzJCOzhCOzs7OzJCOzs7O2UsTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1E7O1MsZTs7O1UsSSxtQjs7O1UsSSxtQjs7VSxJLG1COzs7Ozs7OztTOzs7UTs7Ozs7O007TSxlOztJOztLLEk7SztxQjtnQix3QyxxQjtNLFM7TTs7O2dCO21CO08sUzs7OztTLE87Uzs7Ozs7TyxJOzs7TTtNLEk7O0k7SSxJOzs7YztHO3NCLDRCO2dDLDRCOztJOztLLE07SztLO0s7Ozs7TSxJLEksdUI7Ozs7OztTOzs7Ozs7UTtROzs7O087OztNOzs7OztJLE87Rzs2QiwwQjt1QywwQjt1QixXO0csNkI7O0ksVTtJOztHOztJLFU7STs7Rzs7SSxVO0k7NkIsTTtJO0c7O0ksVTtJOzZCLE07STtHOztJO0s7Tzs7O0s7SyxlLE07Szs7SSxPO0c7O0k7SztPOzs7SztNO007SyxlLE07Szs7SSxPO0c7O0k7SztPOzs7SztNO007TTtLLGEsTTtLLE87O0ksTztHO21DLDBCOzZCLG9CO2dDLDZCOztJOztPO0ksTztHOztJO0s7TTs7Z0I7TTtNLE07Szs7OzsyQjs7O0c7O0ksSSwyQzs7OzJCOzs7Rzs7STtJOztROzs7TTs7Tzs7UTtRLFk7O1E7Ozs7WTs7Ozs7Ozs7O0ssVTtLLE87O0c7O0k7aUM7Rzs7STtpQztHOztJO2dCOzs7Ozs7OztHOztJO0s7Ozs7STs7Ozs7O007O087O1E7UTtROztXOzs7Ozs7Ozs7SyxPOztHOzhCLG9DOztJLEcsZ0M7O0k7Ozs7OztNOztPOztRO1E7UTs7Vzs7Ozs7Ozs7O0ssTzs7Rzs7STtHOztJO0k7Ozs7OztNOztPLG9COztRO1M7UztTOzs7O2lCOzs7Ozs7O087UTtRO1E7Ozs7Ozs7O0ssTzs7RzttQyx5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6W119
