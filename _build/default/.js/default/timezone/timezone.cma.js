// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Timezone__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Timezone = [0],
    Timezone$0 = [0, Timezone];
   runtime.caml_register_global(0, Timezone$0, "Timezone__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timezone__Timezone_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timezone_Timezone_intf = "Timezone__Timezone_intf",
    cst_timezone = "timezone";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timezone_Timezone_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timezone);
   caml_call1(Ppx_expect_runtime[1][1], "src/timezone_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_timezone, "timezone_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_timezone);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timezone_Timezone_intf);
   var Timezone_Timezone_intf = [0];
   runtime.caml_register_global
    (11, Timezone_Timezone_intf, cst_Timezone_Timezone_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timezone
//# unitInfo: Requires: Base__Exn, Base__Hash, Bin_prot__Shape, Bin_shape, CamlinternalLazy, Core, Core__Array, Core__Binable, Core__Core_sys, Core__Error, Core__Hashtbl, Core__Identifiable, Core__Int, Core__Lazy, Core__List, Core__Md5, Core__Option, Core__Sexpable, Core__String, Core__Zone, Diffable__Atomic, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib__Sexp_grammar, Stable_witness, Stdio__In_channel, Stdlib__Sys, Timezone__Timezone_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "/",
    cst_etc_localtime$3 = "/etc/localtime",
    cst_GMT$3 = "GMT",
    cst_Timezone$0 = "Timezone",
    cst_UTC$3 = "UTC",
    cst_src_timezone_ml = "src/timezone.ml",
    cst_t$1 = "t",
    cst_the_local_time_zone_cannot$1 =
      "the local time zone cannot be serialized",
    cst_timezone$0 = "timezone",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    skip_prefixes = [0, "Etc/GMT", [0, "right/", [0, "posix/", 0]]],
    cst = cst$1,
    module_name = cst_Timezone$0,
    Core_String = global_data.Core__String,
    Core = global_data.Core,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Core_Int = global_data.Core__Int,
    Assert_failure = global_data.Assert_failure,
    Base_Exn = global_data.Base__Exn,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Error = global_data.Core__Error,
    Core_Md5 = global_data.Core__Md5,
    Core_Option = global_data.Core__Option,
    Core_List = global_data.Core__List,
    Stdio_In_channel = global_data.Stdio__In_channel,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core_Array = global_data.Core__Array,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Zone = global_data.Core__Zone,
    Core_Core_sys = global_data.Core__Core_sys,
    Core_Lazy = global_data.Core__Lazy,
    Sexplib_Sexp_grammar = global_data.Sexplib__Sexp_grammar,
    Core_Sexpable = global_data.Core__Sexpable,
    Base_Hash = global_data.Base__Hash,
    Core_Binable = global_data.Core__Binable,
    Stable_witness = global_data.Stable_witness,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Diffable_Atomic = global_data.Diffable__Atomic,
    Core_Identifiable = global_data.Core__Identifiable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timezone$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timezone$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_timezone_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_timezone$0, "timezone.ml");
   var
    input_tz_file = Core_Zone[3],
    likely_machine_zones = Core_Zone[4],
    of_utc_offset = Core_Zone[5],
    of_utc_offset_explicit_name = Core_Zone[6],
    utc = Core_Zone[7],
    name = Core_Zone[8],
    original_filename = Core_Zone[9],
    digest = Core_Zone[10],
    Time_in_seconds = Core_Zone[11],
    reset_transition_cache = Core_Zone[12],
    Index = Core_Zone[13],
    index = Core_Zone[14],
    index_of_date_and_ofday = Core_Zone[15],
    index_offset_from_utc_exn = Core_Zone[16],
    index_abbreviation_exn = Core_Zone[17],
    index_has_prev_clock_shift = Core_Zone[18],
    index_prev_clock_shift_time_ex = Core_Zone[19],
    index_prev_clock_shift_amount_ = Core_Zone[20],
    index_has_next_clock_shift = Core_Zone[21],
    index_next_clock_shift_time_ex = Core_Zone[22],
    index_next_clock_shift_amount_ = Core_Zone[23],
    _a_ = caml_call3(Core_String[164][5], 0, 0, 0),
    _b_ = caml_call1(Core_Core_sys[19], "TZDIR"),
    the_one_and_only =
      [0, 0, caml_call2(Core_Option[39], _b_, "/usr/share/zoneinfo/"), _a_],
    cst_etc_localtime$2 = cst_etc_localtime$3,
    cst_the_local_time_zone_cannot$0 = cst_the_local_time_zone_cannot$1,
    cst_etc_localtime$1 = cst_etc_localtime$3,
    cst_the_local_time_zone_cannot = cst_the_local_time_zone_cannot$1,
    cst_UTC$0 = cst_UTC$3,
    cst_GMT$0 = cst_GMT$3,
    cst_GMT$1 = "GMT-",
    cst_GMT$2 = "GMT+",
    cst_UTC$1 = "UTC-",
    cst_UTC$2 = "UTC+",
    _f_ = [0, cst_src_timezone_ml, 181, 22],
    _e_ =
      [0, [11, "Timezone.t_of_sexp: ", [2, 0, 0]], "Timezone.t_of_sexp: %s"],
    cst_Timezone_t_of_sexp_expecte = "Timezone.t_of_sexp: expected atom",
    cst_etc_localtime = cst_etc_localtime$3,
    cst_etc_localtime$0 = cst_etc_localtime$3,
    _d_ = [0, "zone"],
    cst_unknown_zone = "unknown zone",
    cst_UTC = cst_UTC$3,
    cst_Asia_Tokyo = "Asia/Tokyo",
    cst_America_New_York = "America/New_York",
    cst_Asia_Hong_Kong = "Asia/Hong_Kong",
    cst_GMT = cst_GMT$3,
    cst_America_Chicago = "America/Chicago",
    cst_Europe_London = "Europe/London",
    _c_ = [0, cst$1],
    cst_TZ = "TZ",
    _g_ = [0, "Timezone.t"],
    cst_t = cst_t$1,
    cst_src_timezone_ml_245_6 = "src/timezone.ml:245:6",
    cst_t$0 = cst_t$1,
    cst_timezone = cst_timezone$0,
    cst_Timezone = cst_Timezone$0;
   function find(zone){
    return caml_call2(Core_Hashtbl[56], the_one_and_only[3], zone);
   }
   function find_or_load(zonename){
    var match = find(zonename);
    if(match){var z = match[1]; return [0, z];}
    if(the_one_and_only[1]) return 0;
    try{
     var
      _R_ = caml_call2(Core[18], cst, zonename),
      filename = caml_call2(Core[18], the_one_and_only[2], _R_),
      zone = caml_call2(input_tz_file, zonename, filename);
     caml_call3(Core_Hashtbl[37], the_one_and_only[3], zonename, zone);
     var _S_ = [0, zone];
     return _S_;
    }
    catch(_T_){return 0;}
   }
   function traverse(basedir, f){
    var basedir_len = caml_ml_string_length(basedir) + 1 | 0, maxdepth = 10;
    function dfs(dir, depth){
     if(caml_call2(Core[92], depth, 1)) return 0;
     function _M_(fn){
      var
       _O_ = caml_call2(Core[18], cst$0, fn),
       fn$0 = caml_call2(Core[18], dir, _O_),
       relative_fn = caml_call2(Core_String[99], fn$0, basedir_len);
      if(! runtime.caml_sys_is_directory(fn$0))
       return caml_call1(f, relative_fn);
      function _P_(prefix){
       return caml_call2(Core_String[73], relative_fn, prefix);
      }
      var _Q_ = 1 - caml_call2(Core_List[23], skip_prefixes, _P_);
      return _Q_ ? dfs(fn$0, depth - 1 | 0) : _Q_;
     }
     var _N_ = runtime.caml_sys_read_directory(dir);
     return caml_call2(Core_Array[35], _N_, _M_);
    }
    return dfs(basedir, maxdepth);
   }
   function init(param){
    var _J_ = 1 - the_one_and_only[1];
    if(_J_){
     var _K_ = function(zone_name){find_or_load(zone_name); return 0;};
     traverse(the_one_and_only[2], _K_);
     the_one_and_only[1] = 1;
     var _L_ = 0;
    }
    else
     var _L_ = _J_;
    return _L_;
   }
   function initialized_zones(param){
    function _I_(a, b){return caml_call2(Core_String[149], a[1], b[1]);}
    var _H_ = caml_call1(Core_Hashtbl[78], the_one_and_only[3]);
    return caml_call2(Core_List[79], _H_, _I_);
   }
   function find$0(zone){
    a:
    if(caml_string_notequal(zone, "chi"))
     if(caml_string_notequal(zone, "gmt"))
      if(caml_string_notequal(zone, "hkg")){
       if
        (caml_string_notequal(zone, "ldn")
         && caml_string_notequal(zone, "lon")){
        if(! caml_string_notequal(zone, "nyc")){
         var zone$0 = cst_America_New_York;
         break a;
        }
        if(! caml_string_notequal(zone, "tyo")){var zone$0 = cst_Asia_Tokyo; break a;}
        if(caml_string_notequal(zone, "utc")){var zone$0 = zone; break a;}
        var zone$0 = cst_UTC;
        break a;
       }
       var zone$0 = cst_Europe_London;
      }
      else
       var zone$0 = cst_Asia_Hong_Kong;
     else
      var zone$0 = cst_GMT;
    else
     var zone$0 = cst_America_Chicago;
    return find_or_load(zone$0);
   }
   function find_exn(zone){
    var match = find$0(zone);
    if(match){var z = match[1]; return z;}
    var
     _F_ = [0, [1, [0, _d_, [0, caml_call1(Core[558], zone), 0]]], 0],
     _G_ = [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_unknown_zone), _F_]];
    return caml_call1(Core_Error[31], _G_);
   }
   var local_zone_name = caml_call1(Core_Core_sys[19], cst_TZ);
   function load(param){
    if(local_zone_name){
     var zone_name = local_zone_name[1];
     return find_exn(zone_name);
    }
    var
     localtime_t =
       caml_call2(input_tz_file, cst_etc_localtime$0, cst_etc_localtime);
    function file_size(filename){
     var
      c = caml_call2(Stdio_In_channel[3], 0, filename),
      l = caml_call1(Stdio_In_channel[22], c);
     caml_call1(Stdio_In_channel[5], c);
     return l;
    }
    var
     _v_ = caml_call1(original_filename, localtime_t),
     t1_file_size = caml_call2(Core_Option[34], _v_, file_size);
    function _w_(r){
     function return_if_matches(zone_name){
      var
       filename =
         caml_call2
          (Core_String[46], _c_, [0, the_one_and_only[2], [0, zone_name, 0]]);
      try{
       var
        x_002 = [0, file_size(filename)],
        _x_ =
          function(a_005, b_006){return caml_call2(Core[426], a_005, b_006);},
        _y_ = 0 === caml_call3(Core[509], _x_, t1_file_size, x_002) ? 1 : 0;
       if(_y_)
        var
         _z_ = find_or_load(zone_name),
         _A_ = caml_call2(Core_Option[34], _z_, digest),
         x_008 = caml_call1(Core_Option[35], _A_),
         x_007 = caml_call1(digest, localtime_t),
         _B_ =
           function(a_011, b_012){
            return caml_call2(Core_Md5[35], a_011, b_012);
           },
         _C_ = 0 === caml_call3(Core[509], _B_, x_007, x_008) ? 1 : 0,
         _D_ = _C_;
       else
        var _D_ = _y_;
       var matches = _D_;
      }
      catch(_E_){var matches = 0;}
      return matches ? caml_call1(r, find_or_load(zone_name)) : 0;
     }
     caml_call2(Core_List[19], likely_machine_zones[1], return_if_matches);
     traverse(the_one_and_only[2], return_if_matches);
     return 0;
    }
    var match = caml_call1(Core[268], _w_);
    if(! match) return localtime_t;
    var t = match[1];
    return t;
   }
   var
    local = caml_call1(Core_Lazy[38], load),
    include = Core_Zone[24],
    Full_data = include[1];
   function t_of_sexp(sexp){
    if(0 !== sexp[0])
     return caml_call2(Core[154], cst_Timezone_t_of_sexp_expecte, sexp);
    var name = sexp[1];
    if(! caml_string_notequal(name, "Local")){
     var _u_ = runtime.caml_obj_tag(local);
     if(250 === _u_) return local[1];
     if(246 !== _u_ && 244 !== _u_) return local;
     return caml_call1(CamlinternalLazy[2], local);
    }
    try{
     a:
     {
      if
       (!
        caml_call2(Core_String[145], name, cst_UTC$0)
        && ! caml_call2(Core_String[145], name, cst_GMT$0)){
       if
        (!
         caml_call2(Core_String[73], name, cst_GMT$1)
         &&
          !
          caml_call2(Core_String[73], name, cst_GMT$2)
          &&
           !
           caml_call2(Core_String[73], name, cst_UTC$1)
           && ! caml_call2(Core_String[73], name, cst_UTC$2)){var _s_ = find_exn(name); break a;}
       var
        _t_ =
          caml_call3
           (Core_String[3], name, 4, caml_ml_string_length(name) - 4 | 0),
        base = caml_call1(Core_Int[78], _t_),
        switcher = runtime.caml_string_get(name, 3) - 43 | 0;
       b:
       if(2 >= switcher >>> 0){
        switch(switcher){
          case 0:
           var offset = base; break;
          case 1:
           break b;
          default: var offset = -1 * base | 0;
        }
        var _s_ = caml_call2(of_utc_offset_explicit_name, name, offset);
        break a;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
      }
      var _s_ = caml_call2(of_utc_offset_explicit_name, name, 0);
     }
     return _s_;
    }
    catch(exc$0){
     var
      exc = caml_wrap_exception(exc$0),
      _q_ = caml_call1(Base_Exn[10], exc),
      _r_ = caml_call2(Core[265], _e_, _q_);
     return caml_call2(Core[154], _r_, sexp);
    }
   }
   function sexp_of_t(t){
    var name$0 = caml_call1(name, t);
    if(caml_call2(Core_String[145], name$0, cst_etc_localtime$1))
     caml_call1(Core[6], cst_the_local_time_zone_cannot);
    return [0, name$0];
   }
   var
    t_sexp_grammar = [5, [0, Sexplib_Sexp_grammar[4], _g_, 4]],
    include$0 = caml_call1(Core_Sexpable[2][6][1], [0, t_of_sexp, sexp_of_t]),
    of_string = include$0[1],
    to_string = include$0[2];
   function compare(t1, t2){
    var _o_ = caml_call1(to_string, t2), _p_ = caml_call1(to_string, t1);
    return caml_call2(Core_String[146], _p_, _o_);
   }
   function equal(t1, t2){
    var _m_ = caml_call1(to_string, t2), _n_ = caml_call1(to_string, t1);
    return caml_call2(Core_String[145], _n_, _m_);
   }
   function hash_fold_t(state, t){
    var _l_ = caml_call1(to_string, t);
    return caml_call2(Core_String[161], state, _l_);
   }
   var hash = caml_call1(Base_Hash[12], hash_fold_t);
   function to_binable(t){
    var name$0 = caml_call1(name, t);
    if(caml_call2(Core_String[145], name$0, cst_etc_localtime$2))
     caml_call1(Core[6], cst_the_local_time_zone_cannot$0);
    return name$0;
   }
   function of_binable(s){return t_of_sexp([0, s]);}
   var
    include$1 =
      caml_call1
       (caml_call1
         (Core_Binable[16][1][1],
          [0,
           Core_String[130],
           Core_String[126],
           Core_String[127],
           Core_String[128],
           Core_String[129]]),
        [0, to_binable, of_binable]),
    bin_size_t = include$1[1],
    bin_write_t = include$1[2],
    bin_read_t = include$1[3],
    bin_read_t$0 = include$1[4],
    bin_shape_t = include$1[5],
    bin_writer_t = include$1[6],
    bin_reader_t = include$1[7],
    bin_t = include$1[8],
    stable_witness =
      caml_call3
       (Stable_witness[2], Core_String[180][1][10], of_binable, to_binable),
    _h_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, bin_shape_t], 0],
    _i_ = caml_call1(Bin_shape[4][1], cst_src_timezone_ml_245_6),
    group = caml_call2(Bin_prot_Shape[2], _i_, _h_),
    _j_ = caml_call1(Bin_shape[2][1], cst_t$0),
    bin_shape_t$0 = caml_call1(caml_call2(Bin_prot_Shape[10], group, _j_), 0),
    bin_writer_t$0 = [0, bin_size_t, bin_write_t],
    bin_reader_t$0 = [0, bin_read_t, bin_read_t$0],
    bin_t$0 = [0, bin_shape_t$0, bin_writer_t$0, bin_reader_t$0],
    include$2 =
      caml_call1
       (Diffable_Atomic[3],
        [0,
         equal,
         t_of_sexp,
         sexp_of_t,
         bin_size_t,
         bin_write_t,
         bin_read_t,
         bin_read_t$0,
         bin_shape_t$0,
         bin_writer_t$0,
         bin_reader_t$0,
         bin_t$0]),
    Diff = include$2[1],
    _k_ =
      caml_call1
       (Core_Identifiable[2],
        [0,
         bin_size_t,
         bin_write_t,
         bin_read_t,
         bin_read_t$0,
         bin_shape_t,
         bin_writer_t,
         bin_reader_t,
         bin_t,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    pp = _k_[13],
    symbol = _k_[14],
    symbol$0 = _k_[15],
    symbol$1 = _k_[16],
    symbol$2 = _k_[17],
    symbol$3 = _k_[18],
    symbol$4 = _k_[19],
    min = _k_[22],
    max = _k_[23],
    ascending = _k_[24],
    descending = _k_[25],
    between = _k_[26],
    clamp_exn = _k_[27],
    clamp = _k_[28],
    validate_lbound = _k_[29],
    validate_ubound = _k_[30],
    validate_bound = _k_[31],
    Replace_polymorphic_compare = _k_[32],
    comparator = _k_[33],
    Map = _k_[34],
    Set = _k_[35],
    hashable = _k_[38],
    Table = _k_[39],
    Hash_set = _k_[40],
    Hash_queue = _k_[41];
   caml_call1(Ppx_inline_test_lib[7], cst_timezone);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timezone);
   var
    Timezone =
      [0,
       input_tz_file,
       likely_machine_zones,
       of_utc_offset,
       of_utc_offset_explicit_name,
       utc,
       name,
       original_filename,
       digest,
       Time_in_seconds,
       reset_transition_cache,
       Index,
       index,
       index_of_date_and_ofday,
       index_offset_from_utc_exn,
       index_abbreviation_exn,
       index_has_prev_clock_shift,
       index_prev_clock_shift_time_ex,
       index_prev_clock_shift_amount_,
       index_has_next_clock_shift,
       index_next_clock_shift_time_ex,
       index_next_clock_shift_amount_,
       t_sexp_grammar,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       pp,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       comparator,
       Map,
       Set,
       hash_fold_t,
       hash,
       hashable,
       Table,
       Hash_set,
       Hash_queue,
       Diff,
       find$0,
       find_exn,
       local,
       initialized_zones,
       init,
       [0,
        [0,
         bin_size_t,
         bin_write_t,
         bin_read_t,
         bin_read_t$0,
         bin_shape_t,
         bin_writer_t,
         bin_reader_t,
         bin_t,
         compare,
         equal,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         t_sexp_grammar,
         stable_witness,
         of_string,
         to_string,
         Diff],
        Full_data],
       [0, [0, the_one_and_only, init, find]]];
   runtime.caml_register_global(82, Timezone, cst_Timezone$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aW1lem9uZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2tpcF9wcmVmaXhlcyIsIm1vZHVsZV9uYW1lIiwidGhlX29uZV9hbmRfb25seSIsImZpbmQiLCJ6b25lIiwiZmluZF9vcl9sb2FkIiwiem9uZW5hbWUiLCJ6IiwiZmlsZW5hbWUiLCJ0cmF2ZXJzZSIsImJhc2VkaXIiLCJmIiwiYmFzZWRpcl9sZW4iLCJtYXhkZXB0aCIsImRmcyIsImRpciIsImRlcHRoIiwiZm4iLCJmbiQwIiwicmVsYXRpdmVfZm4iLCJwcmVmaXgiLCJpbml0Iiwiem9uZV9uYW1lIiwiaW5pdGlhbGl6ZWRfem9uZXMiLCJhIiwiYiIsImZpbmQkMCIsInpvbmUkMCIsImZpbmRfZXhuIiwibG9jYWxfem9uZV9uYW1lIiwibG9hZCIsImxvY2FsdGltZV90IiwiZmlsZV9zaXplIiwiYyIsImwiLCJ0MV9maWxlX3NpemUiLCJyIiwicmV0dXJuX2lmX21hdGNoZXMiLCJ4XzAwMiIsImFfMDA1IiwiYl8wMDYiLCJ4XzAwOCIsInhfMDA3IiwiYV8wMTEiLCJiXzAxMiIsIm1hdGNoZXMiLCJ0IiwibG9jYWwiLCJ0X29mX3NleHAiLCJzZXhwIiwibmFtZSIsImJhc2UiLCJvZmZzZXQiLCJleGMkMCIsImV4YyIsInNleHBfb2ZfdCIsIm5hbWUkMCIsInRfc2V4cF9ncmFtbWFyIiwiY29tcGFyZSIsInQxIiwidDIiLCJlcXVhbCIsImhhc2hfZm9sZF90Iiwic3RhdGUiLCJoYXNoIiwidG9fYmluYWJsZSIsIm9mX2JpbmFibGUiLCJzIiwiYmluX3NpemVfdCIsImJpbl93cml0ZV90IiwiYmluX3JlYWRfdCIsImJpbl9yZWFkX3QkMCIsImJpbl9zaGFwZV90IiwiYmluX3dyaXRlcl90IiwiYmluX3JlYWRlcl90IiwiYmluX3QiLCJzdGFibGVfd2l0bmVzcyIsImdyb3VwIiwiYmluX3NoYXBlX3QkMCIsImJpbl93cml0ZXJfdCQwIiwiYmluX3JlYWRlcl90JDAiLCJiaW5fdCQwIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvdGltZXpvbmUvdGltZXpvbmVfXy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3RpbWV6b25lL3RpbWV6b25lLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0dBS29COztJQUFBOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lDa0NaQTs7SUFxTkZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E1T1E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBQSxNQUFBO0lBRGUsTUFBQTtJQUZ2QkM7YUFFVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQUtWQyxLQUFLQztJQUFPLE9BQUEsNkJBUFpGLHFCQU9LRTtHQUErQztZQUVwREMsYUFBYUM7SUFDVCxZQUhKSCxLQUVhRztrQkFFUkMsY0FBSyxXQUFMQTtPQVhMTCxxQkFjSztJQUNBO0tBRXlDO01BQUEsTUFBQSwwQkFSakNJO01BUUxFLFdBQVcscUJBakJuQk47TUFrQlFFLE9BQU8sMEJBVEZFLFVBUUxFO0tBRUosNkJBbkJKTixxQkFTYUksVUFTTEY7S0FFSixjQUZJQTtLQUVKOztlQUVLO0dBQUs7WUFHZEssU0FBU0MsU0FBU0M7SUFDcEIsSUFFSUMsY0FBSixzQkFIV0Ysa0JBRVBHO2FBRUlDLElBQUlDLEtBQUlDO0tBQ2QsR0FBRyxxQkFEV0EsV0FFVDtrQkFFeUNDO01BQzFDO09BQWUsTUFBQSw0QkFEMkJBO09BQ3RDQyxPQUFLLHFCQUxISDtPQU1GSSxjQUFjLDRCQURkRCxNQU5OTjtXQVFRLDhCQUZGTTtPQVFPLE9BQUEsV0FqQkdQLEdBVVZRO21CQUlzQ0M7T0FDaEMsT0FBQSw0QkFMTkQsYUFJc0NDO01BQ0k7TUFEdkMsY0FBQSwwQkFiVHBCO21CQUdJYyxJQUtFSSxNQUxNRjtLQWFjO0tBVGYsVUFBQSxnQ0FKSEQ7S0FJK0IsT0FBQTtJQVNaO0lBRS9CLE9BZlFELElBSkdKLFNBRVBHO0dBaUJnQjtZQTZDcEJRO0lBekNBLGNBaERFbkI7O3dCQWtEMENvQixXQXpDMUNqQixhQXlDMENpQixZQUNoQyxTQUFrQztLQTFCNUNiLFNBekJBUDtLQUFBQTs7Ozs7O0dBb0Q4QjtZQXNDaENxQjtJQWhDQSxhQUF3QkMsR0FBRUMsR0FBSyxvQ0FBUEQsTUFBRUMsTUFBcUM7MkNBMUQ3RHZCO0lBMERpQixPQUFBO0dBQTJEO1lBa0M5RXdCLE9BQUt0QjtJQUNQOzRCQURPQTs2QkFBQUE7OEJBQUFBOzs4QkFBQUE7aUNBQUFBO2tDQUFBQTthQUNIdUI7OztrQ0FER3ZCLGtCQUNIdUI7Z0NBREd2QixrQkFDSHVCLFNBREd2QjtZQUNIdUI7OztXQUFBQTs7O1dBQUFBOztVQUFBQTs7U0FBQUE7SUFlSixPQW5HSXRCLGFBb0ZBc0I7R0Fld0I7WUFHMUJDLFNBQVN4QjtJQUNMLFlBcEJKc0IsT0FtQlN0QjtrQkFHSkcsY0FBSyxPQUFMQTs7c0RBSElIOzs7R0FHRTtHQU1TLElBQWxCeUIsa0JBQWtCO1lBQ2xCQztJQUNGLEdBRkVEO1NBR0tQLFlBSExPO0tBR2tCLE9BWnBCRCxTQVlPTjs7SUFHSDtLQWpFb0JTO09BaUVwQjtJQWhFSixTQUFJQyxVQUFVeEI7S0FDWjtNQUFJeUIsSUFBSSxtQ0FESXpCO01BRVIwQixJQUFJLGlDQURKRDtLQUVKLGdDQUZJQTtLQUVKLE9BRElDO0lBRUg7SUFFMkI7S0FBQSxNQUFBLDhCQVBOSDtLQWFDSSxlQU5OLGlDQU5mSDtpQkFPYUk7Y0FDWEMsa0JBQWtCZjtNQUNMO09BQVhkO1NBQVc7cUNBdkVqQk4seUJBc0VzQm9CO01BRXBCO09BRWdEO1FBQTNCZ0IsWUFackJOLFVBU0l4Qjs7bUJBR2lCK0IsT0FBQUMsT0FBQSxPQUFBLHNCQUFBRCxPQUFBQyxPQUFLO29CQUFDLDJCQUFOTCxjQUFBRztPQUFqQjtRQUd1QjtTQUFBLE1BcEU3QmpDLGFBNkRzQmlCO1NBT0UsTUFBQTtTQUZFbUIsUUFFUDtTQUZPQyxRQUNmLG1CQWZXWDs7b0JBY0lZLE9BQUFDO1lBQUEsT0FBQSx5QkFBQUQsT0FBQUM7V0FBSztxQkFBQywyQkFBTkYsT0FBQUQ7Ozs7V0FIcEJJOztxQkFBQUE7TUFTSixPQVRJQSxVQVNxQixXQVpaVCxHQTVEZi9CLGFBNkRzQmlCO0tBV3FDO0tBRTNELG1EQWJJZTtLQTdDSjVCLFNBekJBUCxxQkFzRUltQztLQWNKO0lBQ0k7SUFoQk0sWUFBQTtnQkFnRUMsT0F4RVdOO1FBdUVkZTtJQUFLLE9BQUxBO0dBQ2U7R0FFM0I7SUFsQkVDLFFBa0JGLDBCQWRJakI7OztZQXVCRWtCLFVBQVVDO0lBQ1osU0FEWUE7S0E4QkwsT0FBQSxzREE5QktBO1FBR0FDLE9BSEFEOzhCQUdBQztvQ0E5QmRIOzRCQUFBQTtvQ0FrQkYsT0FsQkVBO0tBa0JGLE9BQUEsZ0NBbEJFQTs7SUErQkk7OztNQUNpQzs7UUFBM0IsNkJBRklHO2FBRXVCLDZCQUZ2QkE7T0FXSTs7U0FISCw0QkFSREE7OztVQVNJLDRCQVRKQTs7O1dBVUksNEJBVkpBO2dCQVdJLDRCQVhKQSw0QkFwQ2R0QixTQW9DY3NCO09BZWE7UUFBQTtVQUFBOzRCQWZiQSwrQkFBQUE7UUFjQ0MsT0FDRjtRQUVJLFdBQUEsd0JBakJIRDs7Ozs7ZUFhREUsU0FDRUQ7Ozt1QkFERkMsY0FDRUQ7O2tCQVFOLHdDQXRCS0QsTUFhREU7OztPQU9LLE1BQUE7O2dCQWpCTix3Q0FIRUY7O0tBR0Y7O1VBc0JMRztLQUNnRDtNQURoREMsMEJBQUFEO01BQ2dELE1BQUEseUJBRGhEQztNQUNjLE1BQUE7S0FBZCxPQUFBLDJCQTdCT0w7O0dBOEJpRDtZQUczRE0sVUFBVVQ7SUFDRCxJQUFQVSxTQUFPLGlCQURDVjtJQUVULEdBQUEsNkJBRENVO0tBRUM7SUFDTCxXQUhJQTtHQUdVO0dBS1Y7SUFGRkM7dURBeENBVCxXQWlDQU87OztZQXdCQUcsUUFBUUMsSUFBR0M7SUFBSyxJQUE4QixNQUFBLHNCQUFuQ0EsS0FBb0IsTUFBQSxzQkFBdkJEO0lBQXNDLE9BQUE7R0FBYztZQUM1REUsTUFBTUYsSUFBR0M7SUFBSyxJQUE0QixNQUFBLHNCQUFqQ0EsS0FBa0IsTUFBQSxzQkFBckJEO0lBQW9DLE9BQUE7R0FBYztZQUN4REcsWUFBWUMsT0FBTWpCO0lBQTZCLFVBQUEsc0JBQTdCQTtJQUE2QixPQUFBLDZCQUFuQ2lCO0dBQWdEO0dBQ3JELElBQVBDLE9BQU8sMEJBRFBGO1lBR0FHLFdBQVduQjtJQUNGLElBQVBVLFNBQU8saUJBREVWO0lBRVYsR0FBQSw2QkFEQ1U7S0FFQztJQUFBLE9BRkRBO0dBR0E7WUFHRlUsV0FBV0MsR0FBSSxPQXJFZm5CLGNBcUVXbUIsSUFBMkI7R0FjeEM7Ozs7Ozs7Ozs7O1lBckJFRixZQU9BQztJQVdFRTtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUVGQztNQUNGO29EQWRFVixZQVBBRDtJQXlCRixjQUFZLHVDQVBSTztJQU9KLE1BQUE7SUFBQUssUUFBQTtJQUFBLE1BQUE7SUFBWUMsZ0JBQVosV0FBQSwrQkFBQUQ7SUFBQUUscUJBUElYLFlBQUFDO0lBT0pXLHFCQVBJVixZQUFBQztJQU9KVSxjQUFZSCxlQUFaQyxnQkFBQUM7Ozs7O1NBN0JFbkI7U0ExREFiO1NBaUNBTztTQStDRWE7U0FBQUM7U0FBQUM7U0FBQUM7U0FPUU87U0FBWkM7U0FBQUM7U0FBQUM7Ozs7OztTQVBJYjtTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQXZCRmpCO1NBRUFJO1NBQ0FFO1NBNURBaEI7U0FpQ0FPOzs7U0E4REZ0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdkRFd0Q7T0F3Q0VXO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BaEZGM0I7T0FpQ0FPOzs7Ozs7Ozs7O09BeUJBTTtPQURBSDs7Ozs7Ozs7Ozs7Ozs7O09BRUFJO09BQ0FFOzs7Ozs7T0FoSEp0QztPQW1CQUU7T0FNQW1CO09BM0JBeEI7T0FEQUY7OztTQXVJTStDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBdkJGakI7U0FDQUc7U0FDQUM7U0FDQUU7U0E1REFoQjtTQWlDQU87U0FPQUU7U0EwQ0FtQjs7Ozs7ZUFsT0YxRSxrQkF5RkZtQixNQWxGRWxCOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIFRpbWV6b25lLlRpbWV6b25lX2ludGYgKilcbm1vZHVsZSBUaW1lem9uZV9pbnRmID0gVGltZXpvbmVfX1RpbWV6b25lX2ludGZcblxubW9kdWxlIFRpbWV6b25lX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsIm9wZW4gQ29yZVxuaW5jbHVkZSBUaW1lem9uZV9pbnRmXG5pbmNsdWRlIENvcmVfcHJpdmF0ZS5UaW1lX3pvbmVcblxubW9kdWxlIHR5cGUgRXh0ZW5kX3pvbmUgPSBUaW1lem9uZV9pbnRmLkV4dGVuZF96b25lXG5cbm1vZHVsZSBab25lX2NhY2hlID0gc3RydWN0XG4gIHR5cGUgeiA9XG4gICAgeyBtdXRhYmxlIGZ1bGwgOiBib29sXG4gICAgOyBiYXNlZGlyIDogc3RyaW5nXG4gICAgOyB0YWJsZSA6IHQgU3RyaW5nLlRhYmxlLnRcbiAgICB9XG5cbiAgbGV0IHRoZV9vbmVfYW5kX29ubHkgPVxuICAgIHsgZnVsbCA9IGZhbHNlXG4gICAgOyBiYXNlZGlyID0gT3B0aW9uLnZhbHVlIChTeXMuZ2V0ZW52IFwiVFpESVJcIikgfmRlZmF1bHQ6XCIvdXNyL3NoYXJlL3pvbmVpbmZvL1wiXG4gICAgOyB0YWJsZSA9IFN0cmluZy5UYWJsZS5jcmVhdGUgKClcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGZpbmQgem9uZSA9IEhhc2h0YmwuZmluZCB0aGVfb25lX2FuZF9vbmx5LnRhYmxlIHpvbmVcblxuICBsZXQgZmluZF9vcl9sb2FkIHpvbmVuYW1lID1cbiAgICBtYXRjaCBmaW5kIHpvbmVuYW1lIHdpdGhcbiAgICB8IFNvbWUgeiAtPiBTb21lIHpcbiAgICB8IE5vbmUgLT5cbiAgICAgIGlmIHRoZV9vbmVfYW5kX29ubHkuZnVsbFxuICAgICAgdGhlbiBOb25lXG4gICAgICBlbHNlIChcbiAgICAgICAgdHJ5XG4gICAgICAgICAgbGV0IGZpbGVuYW1lID0gdGhlX29uZV9hbmRfb25seS5iYXNlZGlyIF4gXCIvXCIgXiB6b25lbmFtZSBpblxuICAgICAgICAgIGxldCB6b25lID0gaW5wdXRfdHpfZmlsZSB+em9uZW5hbWUgfmZpbGVuYW1lIGluXG4gICAgICAgICAgSGFzaHRibC5zZXQgdGhlX29uZV9hbmRfb25seS50YWJsZSB+a2V5OnpvbmVuYW1lIH5kYXRhOnpvbmU7XG4gICAgICAgICAgU29tZSB6b25lXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBfIC0+IE5vbmUpXG4gIDs7XG5cbiAgbGV0IHRyYXZlcnNlIGJhc2VkaXIgfmYgPVxuICAgIGxldCBza2lwX3ByZWZpeGVzID0gWyBcIkV0Yy9HTVRcIjsgXCJyaWdodC9cIjsgXCJwb3NpeC9cIiBdIGluXG4gICAgbGV0IG1heGRlcHRoID0gMTAgaW5cbiAgICBsZXQgYmFzZWRpcl9sZW4gPSBTdHJpbmcubGVuZ3RoIGJhc2VkaXIgKyAxIGluXG4gICAgbGV0IHJlYyBkZnMgZGlyIGRlcHRoID1cbiAgICAgIGlmIGRlcHRoIDwgMVxuICAgICAgdGhlbiAoKVxuICAgICAgZWxzZVxuICAgICAgICBBcnJheS5pdGVyIChTdGRsaWIuU3lzLnJlYWRkaXIgZGlyKSB+ZjooZnVuIGZuIC0+XG4gICAgICAgICAgbGV0IGZuID0gZGlyIF4gXCIvXCIgXiBmbiBpblxuICAgICAgICAgIGxldCByZWxhdGl2ZV9mbiA9IFN0cmluZy5kcm9wX3ByZWZpeCBmbiBiYXNlZGlyX2xlbiBpblxuICAgICAgICAgIG1hdGNoIFN0ZGxpYi5TeXMuaXNfZGlyZWN0b3J5IGZuIHdpdGhcbiAgICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICAgIGlmIG5vdFxuICAgICAgICAgICAgICAgICAoTGlzdC5leGlzdHMgc2tpcF9wcmVmaXhlcyB+ZjooZnVuIHByZWZpeCAtPlxuICAgICAgICAgICAgICAgICAgICBTdHJpbmcuaXNfcHJlZml4IH5wcmVmaXggcmVsYXRpdmVfZm4pKVxuICAgICAgICAgICAgdGhlbiBkZnMgZm4gKGRlcHRoIC0gMSlcbiAgICAgICAgICB8IGZhbHNlIC0+IGYgcmVsYXRpdmVfZm4pXG4gICAgaW5cbiAgICBkZnMgYmFzZWRpciBtYXhkZXB0aFxuICA7O1xuXG4gIGxldCBpbml0ICgpID1cbiAgICBpZiBub3QgdGhlX29uZV9hbmRfb25seS5mdWxsXG4gICAgdGhlbiAoXG4gICAgICB0cmF2ZXJzZSB0aGVfb25lX2FuZF9vbmx5LmJhc2VkaXIgfmY6KGZ1biB6b25lX25hbWUgLT5cbiAgICAgICAgaWdub3JlIChmaW5kX29yX2xvYWQgem9uZV9uYW1lIDogdCBvcHRpb24pKTtcbiAgICAgIHRoZV9vbmVfYW5kX29ubHkuZnVsbCA8LSB0cnVlKVxuICA7O1xuXG4gIGxldCB0b19hbGlzdCAoKSA9IEhhc2h0YmwudG9fYWxpc3QgdGhlX29uZV9hbmRfb25seS50YWJsZVxuXG4gIGxldCBpbml0aWFsaXplZF96b25lcyAoKSA9XG4gICAgTGlzdC5zb3J0IH5jb21wYXJlOihmdW4gYSBiIC0+IFN0cmluZy5hc2NlbmRpbmcgKGZzdCBhKSAoZnN0IGIpKSAodG9fYWxpc3QgKCkpXG4gIDs7XG5cbiAgbGV0IGZpbmRfb3JfbG9hZF9tYXRjaGluZyB0MSA9XG4gICAgbGV0IGZpbGVfc2l6ZSBmaWxlbmFtZSA9XG4gICAgICBsZXQgYyA9IFN0ZGlvLkluX2NoYW5uZWwuY3JlYXRlIGZpbGVuYW1lIGluXG4gICAgICBsZXQgbCA9IFN0ZGlvLkluX2NoYW5uZWwubGVuZ3RoIGMgaW5cbiAgICAgIFN0ZGlvLkluX2NoYW5uZWwuY2xvc2UgYztcbiAgICAgIGxcbiAgICBpblxuICAgIGxldCB0MV9maWxlX3NpemUgPSBPcHRpb24ubWFwIChvcmlnaW5hbF9maWxlbmFtZSB0MSkgfmY6ZmlsZV9zaXplIGluXG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBsZXQgcmV0dXJuX2lmX21hdGNoZXMgem9uZV9uYW1lID1cbiAgICAgICAgbGV0IGZpbGVuYW1lID0gU3RyaW5nLmNvbmNhdCB+c2VwOlwiL1wiIFsgdGhlX29uZV9hbmRfb25seS5iYXNlZGlyOyB6b25lX25hbWUgXSBpblxuICAgICAgICBsZXQgbWF0Y2hlcyA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBbJWNvbXBhcmUuZXF1YWw6IGludDY0IG9wdGlvbl0gdDFfZmlsZV9zaXplIChTb21lIChmaWxlX3NpemUgZmlsZW5hbWUpKVxuICAgICAgICAgICAgJiYgWyVjb21wYXJlLmVxdWFsOiBNZDUudCBvcHRpb25dXG4gICAgICAgICAgICAgICAgIChkaWdlc3QgdDEpXG4gICAgICAgICAgICAgICAgIE9wdGlvbi4oam9pbiAobWFwIChmaW5kX29yX2xvYWQgem9uZV9uYW1lKSB+ZjpkaWdlc3QpKVxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IF8gLT4gZmFsc2VcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbWF0Y2hlcyB0aGVuIHIucmV0dXJuIChmaW5kX29yX2xvYWQgem9uZV9uYW1lKSBlbHNlICgpXG4gICAgICBpblxuICAgICAgTGlzdC5pdGVyICFsaWtlbHlfbWFjaGluZV96b25lcyB+ZjpyZXR1cm5faWZfbWF0Y2hlcztcbiAgICAgIHRyYXZlcnNlIHRoZV9vbmVfYW5kX29ubHkuYmFzZWRpciB+ZjpyZXR1cm5faWZfbWF0Y2hlcztcbiAgICAgIE5vbmUpXG4gIDs7XG5lbmRcblxubGV0IGluaXQgPSBab25lX2NhY2hlLmluaXRcbmxldCBpbml0aWFsaXplZF96b25lcyA9IFpvbmVfY2FjaGUuaW5pdGlhbGl6ZWRfem9uZXNcblxubGV0IGZpbmQgem9uZSA9XG4gIGxldCB6b25lID1cbiAgICAoKiBTb21lIGFsaWFzZXMgZm9yIGNvbnZlbmllbmNlICopXG4gICAgbWF0Y2ggem9uZSB3aXRoXG4gICAgKCogY2FzZSBpbnNlbnNpdGl2aXR5ICopXG4gICAgfCBcInV0Y1wiIC0+IFwiVVRDXCJcbiAgICB8IFwiZ210XCIgLT4gXCJHTVRcIlxuICAgICgqIHNvbWUgYWxpYXNlcyBmb3IgY29tbW9uIHpvbmVzICopXG4gICAgfCBcImNoaVwiIC0+IFwiQW1lcmljYS9DaGljYWdvXCJcbiAgICB8IFwibnljXCIgLT4gXCJBbWVyaWNhL05ld19Zb3JrXCJcbiAgICB8IFwiaGtnXCIgLT4gXCJBc2lhL0hvbmdfS29uZ1wiXG4gICAgfCBcImxvblwiIHwgXCJsZG5cIiAtPiBcIkV1cm9wZS9Mb25kb25cIlxuICAgIHwgXCJ0eW9cIiAtPiBcIkFzaWEvVG9reW9cIlxuICAgICgqIGNhdGNoYWxsICopXG4gICAgfCBfIC0+IHpvbmVcbiAgaW5cbiAgWm9uZV9jYWNoZS5maW5kX29yX2xvYWQgem9uZVxuOztcblxubGV0IGZpbmRfZXhuIHpvbmUgPVxuICBtYXRjaCBmaW5kIHpvbmUgd2l0aFxuICB8IE5vbmUgLT4gRXJyb3IucmFpc2VfcyBbJW1lc3NhZ2UgXCJ1bmtub3duIHpvbmVcIiAoem9uZSA6IHN0cmluZyldXG4gIHwgU29tZSB6IC0+IHpcbjs7XG5cbmxldCBsb2NhbCA9XG4gICgqIExvYWQgW1RaXSBpbW1lZGlhdGVseSBzbyB0aGF0IHN1YnNlcXVlbnQgbW9kaWZpY2F0aW9ucyB0byB0aGUgZW52aXJvbm1lbnQgY2Fubm90XG4gICAgIGFsdGVyIHRoZSByZXN1bHQgb2YgW2ZvcmNlIGxvY2FsXS4gKilcbiAgbGV0IGxvY2FsX3pvbmVfbmFtZSA9IFN5cy5nZXRlbnYgXCJUWlwiIGluXG4gIGxldCBsb2FkICgpID1cbiAgICBtYXRjaCBsb2NhbF96b25lX25hbWUgd2l0aFxuICAgIHwgU29tZSB6b25lX25hbWUgLT4gZmluZF9leG4gem9uZV9uYW1lXG4gICAgfCBOb25lIC0+XG4gICAgICBsZXQgbG9jYWx0aW1lX3QgPVxuICAgICAgICBpbnB1dF90el9maWxlIH56b25lbmFtZTpcIi9ldGMvbG9jYWx0aW1lXCIgfmZpbGVuYW1lOlwiL2V0Yy9sb2NhbHRpbWVcIlxuICAgICAgaW5cbiAgICAgICgqIExvYWQgdGhlIG1hdGNoaW5nIHpvbmUgZmlsZSBmcm9tIHRoZSByZWFsIHpvbmUgY2FjaGUgc28gdGhhdCB3ZSBjYW4gc2VyaWFsaXplIGl0XG4gICAgICAgICBwcm9wZXJseS4gVGhlIGZpbGUgbG9hZGVkIGZyb20gL2V0Yy9sb2NhbHRpbWUgd29uJ3QgaGF2ZSBhIG5hbWUgd2UgY2FuIHVzZSBvbiB0aGVcbiAgICAgICAgIG90aGVyIHNpZGUgdG8gZmluZCB0aGUgcmlnaHQgem9uZS4gKilcbiAgICAgIChtYXRjaCBab25lX2NhY2hlLmZpbmRfb3JfbG9hZF9tYXRjaGluZyBsb2NhbHRpbWVfdCB3aXRoXG4gICAgICAgfCBTb21lIHQgLT4gdFxuICAgICAgIHwgTm9uZSAtPiBsb2NhbHRpbWVfdClcbiAgaW5cbiAgTGF6eS5mcm9tX2Z1biBsb2FkXG47O1xuXG5tb2R1bGUgU3RhYmxlID0gc3RydWN0XG4gIGluY2x1ZGUgQ29yZV9wcml2YXRlLlRpbWVfem9uZS5TdGFibGVcblxuICBtb2R1bGUgVjEgPSBzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICAgIG1hdGNoIHNleHAgd2l0aFxuICAgICAgfCBTZXhwLkF0b20gXCJMb2NhbFwiIC0+IExhenkuZm9yY2UgbG9jYWxcbiAgICAgIHwgU2V4cC5BdG9tIG5hbWUgLT5cbiAgICAgICAgKHRyeVxuICAgICAgICAgICBpZiBTdHJpbmcuZXF1YWwgbmFtZSBcIlVUQ1wiIHx8IFN0cmluZy5lcXVhbCBuYW1lIFwiR01UXCJcbiAgICAgICAgICAgdGhlbiBvZl91dGNfb2Zmc2V0X2V4cGxpY2l0X25hbWUgfm5hbWUgfmhvdXJzOjBcbiAgICAgICAgICAgZWxzZSBpZiAoKiBUaGlzIHNwZWNpYWwgaGFuZGxpbmcgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIG9mZnNldCBkaXJlY3Rpb25hbGl0eSBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICB6b25lIGZpbGVzIGluIC91c3Ivc2hhcmUvem9uZWluZm8gZm9yIEdNVDxvZmZzZXQ+IGZpbGVzIGlzIHRoZSByZXZlcnNlIG9mXG4gICAgICAgICAgICAgICAgICAgICAgd2hhdCBpcyBnZW5lcmFsbHkgZXhwZWN0ZWQuICBUaGF0IGlzLCBHTVQrNSBpcyB3aGF0IG1vc3QgcGVvcGxlIHdvdWxkIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgICBHTVQtNS4gKilcbiAgICAgICAgICAgICAgICAgICBTdHJpbmcuaXNfcHJlZml4IG5hbWUgfnByZWZpeDpcIkdNVC1cIlxuICAgICAgICAgICAgICAgICAgIHx8IFN0cmluZy5pc19wcmVmaXggbmFtZSB+cHJlZml4OlwiR01UK1wiXG4gICAgICAgICAgICAgICAgICAgfHwgU3RyaW5nLmlzX3ByZWZpeCBuYW1lIH5wcmVmaXg6XCJVVEMtXCJcbiAgICAgICAgICAgICAgICAgICB8fCBTdHJpbmcuaXNfcHJlZml4IG5hbWUgfnByZWZpeDpcIlVUQytcIlxuICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICBsZXQgb2Zmc2V0ID1cbiAgICAgICAgICAgICAgIGxldCBiYXNlID1cbiAgICAgICAgICAgICAgICAgSW50Lm9mX3N0cmluZyAoU3RyaW5nLnN1YiBuYW1lIH5wb3M6NCB+bGVuOihTdHJpbmcubGVuZ3RoIG5hbWUgLSA0KSlcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICBtYXRjaCBuYW1lLlszXSB3aXRoXG4gICAgICAgICAgICAgICB8ICctJyAtPiAtMSAqIGJhc2VcbiAgICAgICAgICAgICAgIHwgJysnIC0+IGJhc2VcbiAgICAgICAgICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIG9mX3V0Y19vZmZzZXRfZXhwbGljaXRfbmFtZSB+bmFtZSB+aG91cnM6b2Zmc2V0KVxuICAgICAgICAgICBlbHNlIGZpbmRfZXhuIG5hbWVcbiAgICAgICAgIHdpdGhcbiAgICAgICAgIHwgZXhjIC0+XG4gICAgICAgICAgIG9mX3NleHBfZXJyb3IgKHNwcmludGYgXCJUaW1lem9uZS50X29mX3NleHA6ICVzXCIgKEV4bi50b19zdHJpbmcgZXhjKSkgc2V4cClcbiAgICAgIHwgXyAtPiBvZl9zZXhwX2Vycm9yIFwiVGltZXpvbmUudF9vZl9zZXhwOiBleHBlY3RlZCBhdG9tXCIgc2V4cFxuICAgIDs7XG5cbiAgICBsZXQgc2V4cF9vZl90IHQgPVxuICAgICAgbGV0IG5hbWUgPSBuYW1lIHQgaW5cbiAgICAgIGlmIFN0cmluZy5lcXVhbCBuYW1lIFwiL2V0Yy9sb2NhbHRpbWVcIlxuICAgICAgdGhlbiBmYWlsd2l0aCBcInRoZSBsb2NhbCB0aW1lIHpvbmUgY2Fubm90IGJlIHNlcmlhbGl6ZWRcIjtcbiAgICAgIFNleHAuQXRvbSBuYW1lXG4gICAgOztcblxuICAgIGxldCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYi5TZXhwX2dyYW1tYXIudCA9XG4gICAgICB7IHVudHlwZWQgPVxuICAgICAgICAgIFRhZ2dlZFxuICAgICAgICAgICAgeyBrZXkgPSBTZXhwbGliLlNleHBfZ3JhbW1hci50eXBlX25hbWVfdGFnXG4gICAgICAgICAgICA7IHZhbHVlID0gQXRvbSBcIlRpbWV6b25lLnRcIlxuICAgICAgICAgICAgOyBncmFtbWFyID0gU3RyaW5nXG4gICAgICAgICAgICB9XG4gICAgICB9XG4gICAgOztcblxuICAgIGluY2x1ZGUgU2V4cGFibGUuU3RhYmxlLlRvX3N0cmluZ2FibGUuVjEgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgc2V4cF1cbiAgICBlbmQpXG5cbiAgICAoKiBUaGUgY29ycmVjdG5lc3Mgb2YgdGhlc2UgcmVsaWVzIG9uIG5vdCBleHBvc2luZyByYXcgbG9hZGluZy9jcmVhdGlvbiBmdW5jdGlvbnMgdG9cbiAgICAgICB0aGUgb3V0c2lkZSB3b3JsZCB0aGF0IHdvdWxkIGFsbG93IHRoZSBjb25zdHJ1Y3Rpb24gb2YgdHdvIFpvbmUncyB3aXRoIHRoZSBzYW1lXG4gICAgICAgbmFtZSBhbmQgZGlmZmVyZW50IHRyYW5zaXRpb25zLiAqKVxuICAgIGxldCBjb21wYXJlIHQxIHQyID0gU3RyaW5nLmNvbXBhcmUgKHRvX3N0cmluZyB0MSkgKHRvX3N0cmluZyB0MilcbiAgICBsZXQgZXF1YWwgdDEgdDIgPSBTdHJpbmcuZXF1YWwgKHRvX3N0cmluZyB0MSkgKHRvX3N0cmluZyB0MilcbiAgICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9IFN0cmluZy5oYXNoX2ZvbGRfdCBzdGF0ZSAodG9fc3RyaW5nIHQpXG4gICAgbGV0IGhhc2ggPSBQcHhfaGFzaF9saWIuU3RkLkhhc2gub2ZfZm9sZCBoYXNoX2ZvbGRfdFxuXG4gICAgbGV0IHRvX2JpbmFibGUgdCA9XG4gICAgICBsZXQgbmFtZSA9IG5hbWUgdCBpblxuICAgICAgaWYgU3RyaW5nLmVxdWFsIG5hbWUgXCIvZXRjL2xvY2FsdGltZVwiXG4gICAgICB0aGVuIGZhaWx3aXRoIFwidGhlIGxvY2FsIHRpbWUgem9uZSBjYW5ub3QgYmUgc2VyaWFsaXplZFwiO1xuICAgICAgbmFtZVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfYmluYWJsZSBzID0gdF9vZl9zZXhwIChTZXhwLkF0b20gcylcblxuICAgIGluY2x1ZGUgKFxuICAgICAgQmluYWJsZS5TdGFibGUuT2ZfYmluYWJsZS5WMSBbQGFsZXJ0IFwiLWxlZ2FjeVwiXVxuICAgICAgICAoU3RyaW5nKVxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgICAgIGxldCB0b19iaW5hYmxlID0gdG9fYmluYWJsZVxuICAgICAgICAgIGxldCBvZl9iaW5hYmxlID0gb2ZfYmluYWJsZVxuICAgICAgICBlbmQpIDpcbiAgICAgICAgICBCaW5hYmxlLlMgd2l0aCB0eXBlIHQgOj0gdClcblxuICAgIGxldCBzdGFibGVfd2l0bmVzcyA9XG4gICAgICBTdGFibGVfd2l0bmVzcy5vZl9zZXJpYWxpemFibGUgU3RyaW5nLlN0YWJsZS5WMS5zdGFibGVfd2l0bmVzcyBvZl9iaW5hYmxlIHRvX2JpbmFibGVcbiAgICA7O1xuXG4gICAgaW5jbHVkZSBEaWZmYWJsZS5BdG9taWMuTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdCBbQEBkZXJpdmluZyBzZXhwLCBiaW5faW8sIGVxdWFsXVxuICAgIGVuZClcbiAgZW5kXG5cbiAgbW9kdWxlIEN1cnJlbnQgPSBWMVxuZW5kXG5cbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKHN0cnVjdFxuICBsZXQgbW9kdWxlX25hbWUgPSBcIlRpbWV6b25lXCJcblxuICBpbmNsdWRlIFN0YWJsZS5DdXJyZW50XG5cbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG5lbmQpXG5cbmluY2x1ZGUgU3RhYmxlLkN1cnJlbnRcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFpvbmVfY2FjaGUgPSBab25lX2NhY2hlXG5lbmRcbiJdfQ==
