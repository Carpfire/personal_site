// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ipaddr
//# unitInfo: Requires: Domain_name, Macaddr, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__Int32, Stdlib__List, Stdlib__Map, Stdlib__Printf, Stdlib__Result, Stdlib__Set, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_a_d = "%a/%d",
    cst_s = "%s",
    cst_x = "%x",
    cst$0 = "::",
    cst_Ipaddr$3 = "Ipaddr: ",
    cst_Ipaddr_highest_address_has =
      "Ipaddr: highest address has been reached",
    cst_Ipaddr_lowest_address_has_ = "Ipaddr: lowest address has been reached",
    cst_admin$0 = "admin",
    cst_arpa$1 = "arpa",
    cst_global$0 = "global",
    cst_in_addr$0 = "in-addr",
    cst_interface$0 = "interface",
    cst_invalid_netmask$1 = "invalid netmask",
    cst_invalid_prefix_size$1 = "invalid prefix size",
    cst_ip6$0 = "ip6",
    cst_lib_ipaddr_ml = "lib/ipaddr.ml",
    cst_link$0 = "link",
    cst_n_must_be_0_128$1 = "n must be >= 0 && <= 128",
    cst_octal_notation_disallowed = "octal notation disallowed",
    cst_organization$0 = "organization",
    cst_out_of_bounds$1 = "out of bounds",
    cst_point$0 = "point",
    cst_site$0 = "site",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_equal = runtime.caml_equal,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Result = global_data.Stdlib__Result,
    Domain_name = global_data.Domain_name,
    Stdlib = global_data.Stdlib,
    Macaddr = global_data.Macaddr,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Set = global_data.Stdlib__Set,
    Stdlib_Map = global_data.Stdlib__Map,
    Parse_error = [248, "Ipaddr.Parse_error", caml_fresh_oo_id(0)],
    _M_ = [0, [2, 0, 0], cst_s],
    _L_ =
      [0,
       [11,
        "not an IPv4 prefix: ",
        [2, 0, [11, "\nnot an IPv6 prefix: ", [2, 0, 0]]]],
       "not an IPv4 prefix: %s\nnot an IPv6 prefix: %s"],
    cst_octets_must_be_of_length_4 = "octets must be of length 4 or 16",
    cst_Ipaddr$2 = cst_Ipaddr$3,
    _K_ =
      [0,
       [11,
        "not an IPv4 address: ",
        [2, 0, [11, "\nnot an IPv6 address: ", [2, 0, 0]]]],
       "not an IPv4 address: %s\nnot an IPv6 address: %s"],
    _J_ = [0, [2, 0, 0], cst_s],
    _I_ = [0, cst_lib_ipaddr_ml, 1117, 13],
    _H_ = [0, [2, 0, 0], cst_s],
    _G_ = [0, [15, [12, 47, [4, 0, 0, 0, 0]]], cst_a_d],
    cst_invalid_netmask$0 = cst_invalid_netmask$1,
    _F_ = [0, 0, 1],
    cst_invalid_prefix_size$0 = cst_invalid_prefix_size$1,
    cst_int_of_char_string_invalid =
      "int_of_char_string: invalid hexadecimal string",
    cst_arpa$0 = cst_arpa$1,
    cst_ip6 = cst_ip6$0,
    _D_ = [0, [4, 6, 0, 0, 0], cst_x],
    _E_ = [0, cst_ip6$0, [0, cst_arpa$1, 0]],
    _C_ = [0, [2, 0, 0], cst_s],
    _x_ = [0, 0],
    _z_ = [0, [4, 6, 0, 0, [11, cst$0, 0]], "%x::"],
    _A_ = [0, [4, 6, 0, 0, 0], cst_x],
    _y_ = [0, [4, 6, 0, 0, [12, 58, 0]], "%x:"],
    _B_ = [0, cst_lib_ipaddr_ml, 844, 4],
    cst_Ipaddr$1 = cst_Ipaddr$3,
    _w_ =
      [0,
       [11, "component ", [4, 0, 0, 0, [11, " out of bounds", 0]]],
       "component %d out of bounds"],
    _v_ = [0, -1, 0],
    cst_too_many_components = "too many components",
    _u_ = [1, [0, 3854881, cst_Ipaddr_lowest_address_has_]],
    _t_ = [1, [0, 3854881, cst_Ipaddr_highest_address_has]],
    _s_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    cst_larger_including_offset_th =
      "larger including offset than target bytes",
    cst_n_must_be_0_128$0 = cst_n_must_be_0_128$1,
    cst_n_must_be_0_128 = cst_n_must_be_0_128$1,
    cst_n_must_be_0_8 = "n must be >= 0 && <= 8",
    cst_out_of_bounds$0 = cst_out_of_bounds$1,
    cst_out_of_bounds = cst_out_of_bounds$1,
    cst_not_16_bytes_long = "not 16 bytes long",
    _q_ = [0, [2, 0, 0], cst_s],
    _p_ = [0, [15, [12, 47, [4, 0, 0, 0, 0]]], cst_a_d],
    cst_invalid_netmask = cst_invalid_netmask$1,
    cst_invalid_prefix_size = cst_invalid_prefix_size$1,
    _o_ = [1, [0, 3854881, cst_Ipaddr_lowest_address_has_]],
    _n_ = [1, [0, 3854881, cst_Ipaddr_highest_address_has]],
    cst_label_with_a_too_big_numbe = "label with a too big number",
    cst_arpa = cst_arpa$1,
    cst_in_addr = cst_in_addr$0,
    _m_ = [0, cst_in_addr$0, [0, cst_arpa$1, 0]],
    _l_ = [0, cst_lib_ipaddr_ml, 202, 13],
    _k_ = [0, [2, 0, 0], cst_s],
    _j_ =
      [0,
       [5,
        0,
        0,
        0,
        [12,
         46,
         [5, 0, 0, 0, [12, 46, [5, 0, 0, 0, [12, 46, [5, 0, 0, 0, 0]]]]]]],
       "%ld.%ld.%ld.%ld"],
    cst_Ipaddr$0 = cst_Ipaddr$3,
    cst_first_octet_out_of_bounds = "first octet out of bounds",
    cst_second_octet_out_of_bounds = "second octet out of bounds",
    cst_third_octet_out_of_bounds = "third octet out of bounds",
    cst_fourth_octet_out_of_bounds = "fourth octet out of bounds",
    _i_ =
      [0,
       [11, cst_octal_notation_disallowed, 0],
       cst_octal_notation_disallowed],
    _h_ =
      [0,
       [11, "invalid character '", [0, [11, "' at ", [4, 0, 0, 0, 0]]]],
       "invalid character '%c' at %d"],
    cst_not_enough_data = "not enough data",
    _a_ = [0, 4],
    _b_ = [0, 0],
    _c_ = [0, 5],
    _d_ = [0, 2],
    _e_ = [0, 1],
    _f_ = [0, 6],
    _g_ = [0, 3],
    cst_unknown_scope = "unknown scope: ",
    cst_point = cst_point$0,
    cst_interface = cst_interface$0,
    cst_link = cst_link$0,
    cst_admin = cst_admin$0,
    cst_site = cst_site$0,
    cst_organization = cst_organization$0,
    cst_global = cst_global$0,
    cst_Ipaddr = cst_Ipaddr$3,
    cst_Ipaddr_S128_Overflow = "Ipaddr.S128.Overflow";
   function try_with_result(fn, a){
    try{var _cB_ = [0, caml_call1(fn, a)]; return _cB_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Parse_error) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return [1, [0, 3854881, caml_call2(Stdlib[28], cst_Ipaddr, msg)]];
    }
   }
   function failwith_msg(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var m = param[1][2];
    return caml_call1(Stdlib[2], m);
   }
   function string_of_scope(param){
    switch(param){
      case 0:
       return cst_point;
      case 1:
       return cst_interface;
      case 2:
       return cst_link;
      case 3:
       return cst_admin;
      case 4:
       return cst_site;
      case 5:
       return cst_organization;
      default: return cst_global;
    }
   }
   function scope_of_string(s){
    return caml_string_notequal(s, cst_admin$0)
            ? caml_string_notequal
               (s, cst_global$0)
              ? caml_string_notequal
                 (s, cst_interface$0)
                ? caml_string_notequal
                   (s, cst_link$0)
                  ? caml_string_notequal
                     (s, cst_organization$0)
                    ? caml_string_notequal
                       (s, cst_point$0)
                      ? caml_string_notequal
                         (s, cst_site$0)
                        ? [1,
                          [0, 3854881, caml_call2(Stdlib[28], cst_unknown_scope, s)]]
                        : _a_
                      : _b_
                    : _c_
                  : _d_
                : _e_
              : _f_
            : _g_;
   }
   function pp_scope(fmt, s){
    var _cA_ = string_of_scope(s);
    return caml_call2(Stdlib_Format[13], fmt, _cA_);
   }
   function symbol(x, y){return (x >>> y | 0) & 255;}
   function symbol$0(x, y){return (x & 255) << y;}
   function need_more(x){return [0, Parse_error, cst_not_enough_data, x];}
   function int_of_char(c){
    if(65 <= c){
     if(97 <= c){
      if(103 > c) return (10 + c | 0) - 97 | 0;
     }
     else if(71 > c) return (10 + c | 0) - 65 | 0;
    }
    else if(9 >= c - 48 >>> 0) return c - 48 | 0;
    return -1;
   }
   function bad_char(i, s){
    var
     _cz_ = caml_string_get(s, i),
     msg = caml_call3(Stdlib_Printf[4], _h_, _cz_, i);
    return [0, Parse_error, msg, s];
   }
   function is_number(base, n){
    var _cx_ = 0 <= n ? 1 : 0, _cy_ = _cx_ ? n < base ? 1 : 0 : _cx_;
    return _cy_;
   }
   function parse_int(base, s, i){
    var len = caml_ml_string_length(s), i$0 = i[1];
    if(i$0 >= len) throw caml_maybe_attach_backtrace(need_more(s), 1);
    if(! is_number(base, int_of_char(caml_string_get(s, i$0))))
     throw caml_maybe_attach_backtrace(bad_char(i$0, s), 1);
    var prev = 0;
    for(;;){
     var j = i[1];
     if(len <= j) return prev;
     var c = caml_string_get(s, j), k = int_of_char(c);
     if(! is_number(base, k)) return prev;
     i[1]++;
     var prev$0 = runtime.caml_mul(prev, base) + k | 0, prev = prev$0;
    }
   }
   function parse_dec_int(s, i){return parse_int(10, s, i);}
   function expect_char(s, i, c){
    if(i[1] >= caml_ml_string_length(s))
     throw caml_maybe_attach_backtrace(need_more(s), 1);
    if(caml_string_get(s, i[1]) !== c)
     throw caml_maybe_attach_backtrace(bad_char(i[1], s), 1);
    i[1]++;
    return;
   }
   function expect_end(s, i){
    if(caml_ml_string_length(s) <= i[1]) return;
    throw caml_maybe_attach_backtrace(bad_char(i[1], s), 1);
   }
   function reject_octal(s, i){
    if((i[1] + 1 | 0) < caml_ml_string_length(s)){
     var
      _cv_ = 48 === caml_string_get(s, i[1]) ? 1 : 0,
      _cw_ =
        _cv_
         ? is_number(10, int_of_char(caml_string_get(s, i[1] + 1 | 0)))
         : _cv_;
     if(_cw_){
      var msg = caml_call1(Stdlib_Printf[4], _i_);
      throw caml_maybe_attach_backtrace([0, Parse_error, msg, s], 1);
     }
    }
    return;
   }
   var compare = Stdlib_Int32[16];
   function make(a, b, c, d){
    var
     _cs_ = symbol$0(d, 0),
     _ct_ = symbol$0(c, 8) | _cs_,
     _cu_ = symbol$0(b, 16);
    return symbol$0(a, 24) | _cu_ | _ct_;
   }
   function parse_dotted_quad(s, i){
    reject_octal(s, i);
    var a = parse_dec_int(s, i);
    expect_char(s, i, 46);
    reject_octal(s, i);
    var b = parse_dec_int(s, i);
    expect_char(s, i, 46);
    reject_octal(s, i);
    var c = parse_dec_int(s, i);
    expect_char(s, i, 46);
    reject_octal(s, i);
    var d = parse_dec_int(s, i);
    function valid(a){return (a & 255) !== a ? 1 : 0;}
    if(valid(a))
     throw caml_maybe_attach_backtrace
            ([0, Parse_error, cst_first_octet_out_of_bounds, s], 1);
    if(valid(b))
     throw caml_maybe_attach_backtrace
            ([0, Parse_error, cst_second_octet_out_of_bounds, s], 1);
    if(valid(c))
     throw caml_maybe_attach_backtrace
            ([0, Parse_error, cst_third_octet_out_of_bounds, s], 1);
    if(valid(d))
     throw caml_maybe_attach_backtrace
            ([0, Parse_error, cst_fourth_octet_out_of_bounds, s], 1);
    return make(a, b, c, d);
   }
   function of_string_exn(s){
    var o = [0, 0], x = parse_dotted_quad(s, o);
    expect_end(s, o);
    return x;
   }
   function of_string(s){return try_with_result(of_string_exn, s);}
   function with_port_of_string(default$0, s){
    try{
     var
      len = caml_ml_string_length(s),
      o = [0, 0],
      ipv4 = parse_dotted_quad(s, o);
     a:
     {
      if(o[1] < len && 58 === caml_string_get(s, o[1])){
       o[1]++;
       var port = parse_dec_int(s, o);
       expect_end(s, o);
       var _cr_ = [0, [0, ipv4, port]];
       break a;
      }
      expect_end(s, o);
      var _cr_ = [0, [0, ipv4, default$0]];
     }
     return _cr_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Parse_error) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return [1, [0, 3854881, caml_call2(Stdlib[28], cst_Ipaddr$0, msg)]];
    }
   }
   function to_buffer(b, i){
    var
     _cn_ = symbol(i, 0),
     _co_ = symbol(i, 8),
     _cp_ = symbol(i, 16),
     _cq_ = symbol(i, 24);
    return caml_call6(Stdlib_Printf[5], b, _j_, _cq_, _cp_, _co_, _cn_);
   }
   function to_string(i){
    var b = caml_call1(Stdlib_Buffer[1], 15);
    to_buffer(b, i);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function pp(ppf, i){
    var _cm_ = to_string(i);
    return caml_call3(Stdlib_Format[137], ppf, _k_, _cm_);
   }
   function of_octets_exn(opt, bs){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    try{
     var
      _ch_ = caml_string_get(bs, 3 + off | 0),
      _ci_ = caml_string_get(bs, 2 + off | 0),
      _cj_ = caml_string_get(bs, 1 + off | 0),
      _ck_ = make(caml_string_get(bs, off | 0), _cj_, _ci_, _ch_);
     return _ck_;
    }
    catch(_cl_){throw caml_maybe_attach_backtrace(need_more(bs), 1);}
   }
   function of_octets(off, bs){
    return try_with_result
            (function(_cg_){return of_octets_exn(off, _cg_);}, bs);
   }
   function write_octets_exn(opt, i, b){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    try{
     var _ca_ = symbol(i, 24);
     caml_bytes_set(b, off | 0, caml_call1(Stdlib_Char[1], _ca_));
     var _cb_ = symbol(i, 16);
     caml_bytes_set(b, 1 + off | 0, caml_call1(Stdlib_Char[1], _cb_));
     var _cc_ = symbol(i, 8);
     caml_bytes_set(b, 2 + off | 0, caml_call1(Stdlib_Char[1], _cc_));
     var
      _cd_ = symbol(i, 0),
      _ce_ = caml_bytes_set(b, 3 + off | 0, caml_call1(Stdlib_Char[1], _cd_));
     return _ce_;
    }
    catch(_cf_){
     throw caml_maybe_attach_backtrace
            (need_more(caml_call1(Stdlib_Bytes[6], b)), 1);
    }
   }
   function write_octets(off, i, bs){
    return try_with_result
            (function(_b$_){return write_octets_exn(off, i, _b$_);}, bs);
   }
   function to_octets(i){
    function _b6_(param){
     if(3 < param >>> 0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     switch(param){
       case 0:
        var _b7_ = symbol(i, 24); return caml_call1(Stdlib_Char[1], _b7_);
       case 1:
        var _b8_ = symbol(i, 16); return caml_call1(Stdlib_Char[1], _b8_);
       case 2:
        var _b9_ = symbol(i, 8); return caml_call1(Stdlib_Char[1], _b9_);
       default:
        var _b__ = symbol(i, 0); return caml_call1(Stdlib_Char[1], _b__);
     }
    }
    return caml_call2(Stdlib_String[2], 4, _b6_);
   }
   function of_int32(i){return i;}
   function to_int32(i){return i;}
   function of_int16(param){
    var b = param[2], a = param[1];
    return a << 16 | b;
   }
   function to_int16(a){return [0, a >>> 16 | 0, a & 65535];}
   function multicast_to_mac(i){
    var macb = caml_create_bytes(6);
    caml_bytes_set(macb, 0, caml_call1(Stdlib_Char[1], 1));
    caml_bytes_set(macb, 1, caml_call1(Stdlib_Char[1], 0));
    caml_bytes_set(macb, 2, caml_call1(Stdlib_Char[1], 94));
    caml_bytes_set(macb, 3, caml_call1(Stdlib_Char[1], (i >>> 16 | 0) & 127));
    var _b3_ = symbol(i, 8);
    caml_bytes_set(macb, 4, caml_call1(Stdlib_Char[1], _b3_));
    var _b4_ = symbol(i, 0);
    caml_bytes_set(macb, 5, caml_call1(Stdlib_Char[1], _b4_));
    var _b5_ = caml_call1(Stdlib_Bytes[6], macb);
    return caml_call1(Macaddr[2], _b5_);
   }
   function to_domain_name(i){
    var
     _bV_ = symbol(i, 24),
     _bW_ = [0, caml_call1(Stdlib_Int32[14], _bV_), _m_],
     _bX_ = symbol(i, 16),
     _bY_ = [0, caml_call1(Stdlib_Int32[14], _bX_), _bW_],
     _bZ_ = symbol(i, 8),
     _b0_ = [0, caml_call1(Stdlib_Int32[14], _bZ_), _bY_],
     _b1_ = symbol(i, 0),
     name = [0, caml_call1(Stdlib_Int32[14], _b1_), _b0_],
     _b2_ = caml_call1(Domain_name[34], name);
    return caml_call1(Domain_name[7], _b2_);
   }
   function of_domain_name(n){
    var match = caml_call2(Domain_name[35], 0, n);
    if(match){
     var _bK_ = match[2];
     if(_bK_){
      var _bL_ = _bK_[2];
      if(_bL_){
       var _bM_ = _bL_[2];
       if(_bM_){
        var _bN_ = _bM_[2];
        if(_bN_){
         var _bO_ = _bN_[2];
         if(_bO_ && ! _bO_[2]){
          var
           arpa = _bO_[1],
           in_addr = _bN_[1],
           d = _bM_[1],
           c = _bL_[1],
           b = _bK_[1],
           a = match[1];
          if
           (caml_call3(Domain_name[25], 0, arpa, cst_arpa)
            && caml_call3(Domain_name[25], 0, in_addr, cst_in_addr)){
           var
            conv =
              function(bits, data){
               var i = parse_dec_int(data, [0, 0]);
               if(runtime.caml_greaterthan(i, 255))
                throw caml_maybe_attach_backtrace
                       ([0, Parse_error, cst_label_with_a_too_big_numbe, data], 1);
               return symbol$0(i, bits);
              };
           try{
            var
             _bQ_ = conv(24, d),
             _bR_ = conv(16, c),
             _bS_ = conv(8, b),
             _bT_ = [0, ((conv(0, a) + _bS_ | 0) + _bR_ | 0) + _bQ_ | 0];
            return _bT_;
           }
           catch(_bU_){
            var _bP_ = caml_wrap_exception(_bU_);
            if(_bP_[1] === Parse_error) return 0;
            throw caml_maybe_attach_backtrace(_bP_, 0);
           }
          }
         }
        }
       }
      }
     }
    }
    return 0;
   }
   function succ(t){
    return caml_call2(Stdlib_Int32[17], t, -1)
            ? _n_
            : [0, caml_call1(Stdlib_Int32[6], t)];
   }
   function pred(t){
    return caml_call2(Stdlib_Int32[17], t, 0)
            ? _o_
            : [0, caml_call1(Stdlib_Int32[7], t)];
   }
   var
    any = make(0, 0, 0, 0),
    unspecified = make(0, 0, 0, 0),
    broadcast = make(255, 255, 255, 255),
    localhost = make(127, 0, 0, 1),
    nodes = make(224, 0, 0, 1),
    routers = make(224, 0, 0, 2);
   function compare$0(param, _bJ_){
    var
     sz = _bJ_[2],
     pre = _bJ_[1],
     sz$0 = param[2],
     pre$0 = param[1],
     c = caml_call2(compare, pre$0, pre);
    return 0 === c ? caml_compare(sz$0, sz) : c;
   }
   function mask(sz){return 0 < sz ? 32 <= sz ? -1 : -1 << (32 - sz | 0) : 0;}
   function prefix(param){
    var sz = param[2], pre = param[1];
    return [0, pre & mask(sz), sz];
   }
   function make$0(sz, pre){return [0, pre, sz];}
   function network_address(param, addr){
    var
     sz = param[2],
     pre = param[1],
     _bH_ = mask(sz),
     _bI_ = addr & caml_call1(Stdlib_Int32[11], _bH_);
    return pre & mask(sz) | _bI_;
   }
   function of_string_raw(s, i){
    var quad = parse_dotted_quad(s, i);
    expect_char(s, i, 47);
    var
     p = parse_dec_int(s, i),
     _bF_ = 32 < p ? 1 : 0,
     _bG_ = _bF_ || (p < 0 ? 1 : 0);
    if(_bG_)
     throw caml_maybe_attach_backtrace
            ([0, Parse_error, cst_invalid_prefix_size, s], 1);
    return [0, p, quad];
   }
   function of_string_raw$0(s, i){
    var match = of_string_raw(s, i), quad = match[2], p = match[1];
    return [0, quad, p];
   }
   function of_string_exn$0(s){
    var i = [0, 0], res = of_string_raw(s, i);
    expect_end(s, i);
    var quad = res[2], p = res[1];
    return [0, quad, p];
   }
   function of_string$0(s){return try_with_result(of_string_exn$0, s);}
   function of_netmask_exn(netmask, address){
    var
     bits$1 = netmask & (- netmask | 0),
     i$1 = caml_equal(bits$1, 0) ? 33 : 0,
     bits = bits$1,
     i = i$1;
    for(;;){
     if(caml_equal(bits, 0)){
      var sz = 32 - (i - 1 | 0) | 0;
      if(runtime.caml_notequal(netmask, mask(sz)))
       throw caml_maybe_attach_backtrace
              ([0, Parse_error, cst_invalid_netmask, to_string(netmask)], 1);
      return [0, address, sz];
     }
     var i$0 = i + 1 | 0, bits$0 = bits >>> 1 | 0, bits = bits$0, i = i$0;
    }
   }
   function of_netmask_exn$0(netmask, address){return of_netmask_exn(netmask, address);
   }
   function of_netmask(netmask, address){
    return try_with_result
            (function(_bE_){return of_netmask_exn(netmask, _bE_);}, address);
   }
   function to_buffer$0(buf, param){
    var sz = param[2], pre = param[1];
    return caml_call5(Stdlib_Printf[5], buf, _p_, to_buffer, pre, sz);
   }
   function to_string$0(subnet){
    var b = caml_call1(Stdlib_Buffer[1], 18);
    to_buffer$0(b, subnet);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function pp$0(ppf, i){
    var _bD_ = to_string$0(i);
    return caml_call3(Stdlib_Format[137], ppf, _q_, _bD_);
   }
   function mem(ip, param){
    var sz = param[2], pre = param[1], m = mask(sz);
    return caml_equal(ip & m, pre & m);
   }
   function subset(param, _bB_){
    var
     sz2 = _bB_[2],
     pre2 = _bB_[1],
     sz1 = param[2],
     pre1 = param[1],
     _bC_ = sz2 <= sz1 ? 1 : 0;
    return _bC_ ? mem(pre1, [0, pre2, sz2]) : _bC_;
   }
   function of_addr(ip){return [0, ip, 32];}
   var
    global = [0, make(0, 0, 0, 0), 0],
    relative = [0, make(0, 0, 0, 0), 8],
    loopback = [0, make(127, 0, 0, 0), 8],
    link = [0, make(169, 254, 0, 0), 16],
    multicast = [0, make(224, 0, 0, 0), 4],
    multicast_org = [0, make(239, 192, 0, 0), 14],
    multicast_admin = [0, make(239, 255, 0, 0), 16],
    multicast_link = [0, make(224, 0, 0, 0), 24],
    private_10 = [0, make(10, 0, 0, 0), 8],
    private_172 = [0, make(172, 16, 0, 0), 12],
    private_192 = [0, make(192, 168, 0, 0), 16],
    private_blocks =
      [0,
       loopback,
       [0, link, [0, private_10, [0, private_172, [0, private_192, 0]]]]];
   function broadcast$0(param){
    var sz = param[2], pre = param[1];
    return pre | mask(sz) ^ -1;
   }
   function network(param){
    var sz = param[2], pre = param[1];
    return pre & mask(sz);
   }
   function address(param){var addr = param[1]; return addr;}
   function bits(param){var sz = param[2]; return sz;}
   function netmask(subnet){return mask(subnet[2]);}
   function first(cidr){
    var sz = cidr[2];
    return 30 < sz ? network(cidr) : failwith_msg(succ(network(cidr)));
   }
   function last(cidr){
    var sz = cidr[2];
    return 30 < sz ? broadcast$0(cidr) : failwith_msg(pred(broadcast$0(cidr)));
   }
   function hosts(opt, cidr){
    var sz = cidr[2];
    if(opt) var sth = opt[1], usable = sth; else var usable = 1;
    function iter_seq(start, stop){
     if(0 < compare$0([0, start, 32], [0, stop, 32])) return 0;
     var match = succ(start);
     if(0 !== match[0]) return [0, start, function(param){return 0;}];
     var start_succ = match[1];
     return [0, start, function(param){return iter_seq(start_succ, stop);}];
    }
    if(usable && 32 === sz) return function(param){return 0;};
    if(usable)
     var stop = last(cidr), stop$0 = stop, start = first(cidr);
    else
     var
      stop$1 = broadcast$0(cidr),
      start$0 = network(cidr),
      stop$0 = stop$1,
      start = start$0;
    return function(param){return iter_seq(start, stop$0);};
   }
   function subnets(n, cidr){
    var sz = cidr[2];
    function iter_seq(start, stop, steps){
     if(0 < compare$0([0, start, 32], [0, stop, 32])) return 0;
     var prefix = [0, start, n], start_succ = start + steps | 0;
     return caml_equal(start_succ, 0)
             ? [0, prefix, function(param){return 0;}]
             : [0,
               prefix,
               function(param){return iter_seq(start_succ, stop, steps);}];
    }
    if(n >= sz && 32 >= n){
     var
      start = network(cidr),
      stop = broadcast$0(cidr),
      steps = ((netmask(cidr) ^ -1) + 1 | 0) >>> (n - sz | 0) | 0;
     return function(param){return iter_seq(start, stop, steps);};
    }
    return function(param){return 0;};
   }
   function scope(i){
    function mem$0(_bA_){return mem(i, _bA_);}
    return mem$0(loopback)
            ? 1
            : mem$0
               (link)
              ? 2
              : caml_call2
                 (Stdlib_List[34], mem$0, private_blocks)
                ? 5
                : caml_equal
                   (i, unspecified)
                  ? 0
                  : caml_equal
                     (i, broadcast)
                    ? 3
                    : mem$0
                       (relative)
                      ? 3
                      : mem$0
                         (multicast)
                        ? mem$0
                           (multicast_org)
                          ? 5
                          : mem$0(multicast_admin) ? 3 : mem$0(multicast_link) ? 2 : 6
                        : 6;
   }
   function is_global(i){return 6 === scope(i) ? 1 : 0;}
   function is_multicast(i){return mem(i, multicast);}
   function is_private(i){return 6 !== scope(i) ? 1 : 0;}
   function compare$1(a, b){return caml_call2(compare, a, b);}
   var Set = caml_call1(Stdlib_Set[1], [0, compare$1]);
   function compare$2(a, b){return caml_call2(compare, a, b);}
   var
    Map = caml_call1(Stdlib_Map[1], [0, compare$2]),
    Overflow = [248, cst_Ipaddr_S128_Overflow, caml_fresh_oo_id(0)];
   function mk_zero(param){return caml_call2(Stdlib_Bytes[1], 16, 0);}
   var
    _r_ = mk_zero(0),
    zero = caml_call1(Stdlib_Bytes[44], _r_),
    max_int = caml_call2(Stdlib_String[1], 16, 255),
    compare$3 = Stdlib_String[10],
    equal = Stdlib_String[9];
   function fold_left(f, init, s){
    var a = [0, init], i = 0;
    for(;;){
     var _by_ = caml_string_get(s, i);
     a[1] = caml_call2(f, a[1], _by_);
     var _bz_ = i + 1 | 0;
     if(15 === i) return a[1];
     var i = _bz_;
    }
   }
   function iteri_right2(f, x, y){
    var i = 15;
    for(;;){
     var x$0 = caml_string_get(x, i), y$0 = caml_string_get(y, i);
     caml_call3(f, i, x$0, y$0);
     var _bx_ = i - 1 | 0;
     if(0 === i) return;
     var i = _bx_;
    }
   }
   function of_octets_exn$0(s){
    if(16 !== caml_ml_string_length(s))
     caml_call1(Stdlib[1], cst_not_16_bytes_long);
    return s;
   }
   function to_octets$0(_bw_){return _bw_;}
   function of_int64(param){
    var b = param[2], a = param[1], b$0 = mk_zero(0);
    caml_call3(Stdlib_Bytes[85], b$0, 0, a);
    caml_call3(Stdlib_Bytes[85], b$0, 8, b);
    return caml_call1(Stdlib_Bytes[44], b$0);
   }
   function to_int64(s){
    var
     b = caml_call1(Stdlib_Bytes[45], s),
     _bv_ = caml_call2(Stdlib_Bytes[71], b, 8);
    return [0, caml_call2(Stdlib_Bytes[71], b, 0), _bv_];
   }
   function of_int32$0(param){
    var
     d = param[4],
     c = param[3],
     b = param[2],
     a = param[1],
     b$0 = mk_zero(0);
    caml_call3(Stdlib_Bytes[82], b$0, 0, a);
    caml_call3(Stdlib_Bytes[82], b$0, 4, b);
    caml_call3(Stdlib_Bytes[82], b$0, 8, c);
    caml_call3(Stdlib_Bytes[82], b$0, 12, d);
    return caml_call1(Stdlib_Bytes[44], b$0);
   }
   function to_int32$0(s){
    var
     b = caml_call1(Stdlib_Bytes[45], s),
     _bs_ = caml_call2(Stdlib_Bytes[68], b, 12),
     _bt_ = caml_call2(Stdlib_Bytes[68], b, 8),
     _bu_ = caml_call2(Stdlib_Bytes[68], b, 4);
    return [0, caml_call2(Stdlib_Bytes[68], b, 0), _bu_, _bt_, _bs_];
   }
   function of_int16$0(param){
    var
     h = param[8],
     g = param[7],
     f = param[6],
     e = param[5],
     d = param[4],
     c = param[3],
     b = param[2],
     a = param[1],
     b$0 = mk_zero(0);
    caml_call3(Stdlib_Bytes[76], b$0, 0, a);
    caml_call3(Stdlib_Bytes[76], b$0, 2, b);
    caml_call3(Stdlib_Bytes[76], b$0, 4, c);
    caml_call3(Stdlib_Bytes[76], b$0, 6, d);
    caml_call3(Stdlib_Bytes[76], b$0, 8, e);
    caml_call3(Stdlib_Bytes[76], b$0, 10, f);
    caml_call3(Stdlib_Bytes[76], b$0, 12, g);
    caml_call3(Stdlib_Bytes[76], b$0, 14, h);
    return caml_call1(Stdlib_Bytes[44], b$0);
   }
   function to_int16$0(s){
    var
     b = caml_call1(Stdlib_Bytes[45], s),
     _bl_ = caml_call2(Stdlib_Bytes[62], b, 14),
     _bm_ = caml_call2(Stdlib_Bytes[62], b, 12),
     _bn_ = caml_call2(Stdlib_Bytes[62], b, 10),
     _bo_ = caml_call2(Stdlib_Bytes[62], b, 8),
     _bp_ = caml_call2(Stdlib_Bytes[62], b, 6),
     _bq_ = caml_call2(Stdlib_Bytes[62], b, 4),
     _br_ = caml_call2(Stdlib_Bytes[62], b, 2);
    return [0,
            caml_call2(Stdlib_Bytes[62], b, 0),
            _br_,
            _bq_,
            _bp_,
            _bo_,
            _bn_,
            _bm_,
            _bl_];
   }
   function add_exn(x, y){
    var b = mk_zero(0), carry = [0, 0];
    iteri_right2
     (function(i, x, y){
       var sum = (x + y | 0) + carry[1] | 0;
       return 256 <= sum
               ? (carry
                  [1]
                 = 1,
                 caml_call3(Stdlib_Bytes[73], b, i, sum - 256 | 0))
               : (carry[1] = 0, caml_call3(Stdlib_Bytes[73], b, i, sum));
      },
      x,
      y);
    if(0 === carry[1]) return caml_call1(Stdlib_Bytes[44], b);
    throw caml_maybe_attach_backtrace(Overflow, 1);
   }
   function logand(x, y){
    var b = mk_zero(0);
    iteri_right2
     (function(i, x, y){return caml_call3(Stdlib_Bytes[73], b, i, x & y);},
      x,
      y);
    return caml_call1(Stdlib_Bytes[44], b);
   }
   function logor(x, y){
    var b = mk_zero(0);
    iteri_right2
     (function(i, x, y){return caml_call3(Stdlib_Bytes[73], b, i, x | y);},
      x,
      y);
    return caml_call1(Stdlib_Bytes[44], b);
   }
   function shift_right(x, n){
    if(0 === n) return x;
    if(128 === n) return zero;
    if(0 < n && 128 > n){
     var b = mk_zero(0), shift_bits = n % 8 | 0, shift_bytes = n / 8 | 0;
     if(0 === shift_bits)
      caml_call5(Stdlib_Bytes[12], x, 0, b, shift_bytes, 16 - shift_bytes | 0);
     else{
      var carry = [0, 0], _bj_ = 15 - shift_bytes | 0, _bi_ = 0;
      if(_bj_ >= 0){
       var i = _bi_;
       for(;;){
        var
         x$0 = caml_string_get(x, i),
         _bg_ = shift_bits <= 0 ? 1 : 0,
         _bh_ = _bg_ || (8 < shift_bits ? 1 : 0);
        if(_bh_) caml_call1(Stdlib[1], cst_out_of_bounds);
        var
         new_carry = x$0 & ((1 << shift_bits) - 1 | 0),
         shifted_value = x$0 >>> shift_bits | 0,
         x$1 = carry[1];
        if(0 <= shift_bits && 8 >= shift_bits){
         var
          new_value =
            0 === shift_bits
             ? shifted_value
             : 8
               === shift_bits
               ? x$1
               : x$1 << (8 - shift_bits | 0) | shifted_value;
         caml_call3(Stdlib_Bytes[73], b, i + shift_bytes | 0, new_value);
         carry[1] = new_carry;
         var _bk_ = i + 1 | 0;
         if(_bj_ === i) break;
         var i = _bk_;
         continue;
        }
        throw caml_maybe_attach_backtrace
               ([0, Stdlib[6], cst_n_must_be_0_8], 1);
       }
      }
     }
     return caml_call1(Stdlib_Bytes[44], b);
    }
    throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_n_must_be_0_128], 1);
   }
   function write_octets_exn$0(opt, s, dest){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(16 <= (runtime.caml_ml_bytes_length(dest) - off | 0))
     return caml_call5
             (Stdlib_Bytes[12], s, 0, dest, off, caml_ml_string_length(s));
    throw caml_maybe_attach_backtrace
           ([0, Parse_error, cst_larger_including_offset_th, s], 1);
   }
   function succ_exn(x){return add_exn(x, of_int64(_s_));}
   function succ$0(x){
    try{var _be_ = [0, succ_exn(x)]; return _be_;}
    catch(_bf_){
     var _bd_ = caml_wrap_exception(_bf_);
     if(_bd_ === Overflow) return _t_;
     throw caml_maybe_attach_backtrace(_bd_, 0);
    }
   }
   function pred$0(x){
    try{
     if(caml_call2(equal, x, zero))
      throw caml_maybe_attach_backtrace(Overflow, 1);
     var b = caml_call1(Stdlib_Bytes[5], x), i = 15;
     for(;;){
      var _a$_ = caml_string_get(x, i) - 1 | 0;
      caml_call3(Stdlib_Bytes[73], b, i, _a$_);
      if(0 !== caml_string_get(x, i)){
       var _bb_ = [0, caml_call1(Stdlib_Bytes[44], b)];
       return _bb_;
      }
      var i$0 = i - 1 | 0, i = i$0;
     }
    }
    catch(_bc_){
     var _ba_ = caml_wrap_exception(_bc_);
     if(_ba_ !== Overflow && _ba_[1] !== Stdlib[6])
      throw caml_maybe_attach_backtrace(_ba_, 0);
     return _u_;
    }
   }
   function make$1(a, b, c, d, e, f, g, h){
    return of_int16$0([0, a, b, c, d, e, f, g, h]);
   }
   function of_string_raw$1(s, offset){
    var compressed = [0, 0], len = caml_ml_string_length(s);
    if(len < (offset[1] + 1 | 0))
     throw caml_maybe_attach_backtrace(need_more(s), 1);
    var use_bracket = 91 === caml_string_get(s, offset[1]) ? 1 : 0;
    if(use_bracket) offset[1]++;
    if(len < (offset[1] + 2 | 0))
     throw caml_maybe_attach_backtrace(need_more(s), 1);
    if(58 === caml_string_get(s, offset[1])){
     offset[1]++;
     if(58 !== caml_string_get(s, offset[1]))
      throw caml_maybe_attach_backtrace(bad_char(offset[1], s), 1);
     compressed[1] = 1;
     offset[1]++;
     var acc = _v_;
    }
    else
     var acc = 0;
    var nb$2 = caml_call1(Stdlib_List[1], acc);
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          var nb = nb$2, acc$0 = acc;
          for(;;){
           if(8 <= nb) break b;
           if(len <= offset[1]) break c;
           var pos = offset[1];
           try{var _a0_ = parse_int(16, s, offset), x = _a0_;}
           catch(_a__){var x = -1;}
           if(0 > x) break d;
           if(7 === nb) break e;
           if(offset[1] >= len) break;
           if(58 !== caml_string_get(s, offset[1])) break;
           offset[1]++;
           if(offset[1] >= len)
            throw caml_maybe_attach_backtrace(need_more(s), 1);
           if(58 === caml_string_get(s, offset[1])){
            if(compressed[1]) break f;
            compressed[1] = 1;
            offset[1]++;
            var
             acc$1 = [0, -1, [0, x, acc$0]],
             nb$0 = nb + 2 | 0,
             nb = nb$0,
             acc$0 = acc$1;
           }
           else{
            if(! is_number(16, int_of_char(caml_string_get(s, offset[1]))))
             throw caml_maybe_attach_backtrace(bad_char(offset[1], s), 1);
            var
             acc$2 = [0, x, acc$0],
             nb$1 = nb + 1 | 0,
             nb = nb$1,
             acc$0 = acc$2;
           }
          }
          if(offset[1] < len && 46 === caml_string_get(s, offset[1])){
           offset[1] = pos;
           var
            v4 = parse_dotted_quad(s, offset),
            match = to_int16(v4),
            lo = match[2],
            hi = match[1],
            res = [0, lo, [0, hi, acc$0]];
           break a;
          }
          var res = [0, x, acc$0];
          break a;
         }
         offset[1] += -1;
         var res = [0, x, acc$0];
         break a;
        }
        var res = [0, x, acc$0];
        break a;
       }
       var res = acc$0;
       break a;
      }
      var res = acc$0;
      break a;
     }
     var res = acc$0;
    }
    var res_len = caml_call1(Stdlib_List[1], res);
    if(8 < res_len)
     throw caml_maybe_attach_backtrace
            ([0, Parse_error, cst_too_many_components, s], 1);
    if(0 === res_len) throw caml_maybe_attach_backtrace(need_more(s), 1);
    var a = runtime.caml_make_vect(8, 0);
    if(compressed[1])
     var missing = 8 - (res_len - 1 | 0) | 0;
    else{
     if(8 !== res_len){
      if(offset[1] < len)
       throw caml_maybe_attach_backtrace(bad_char(offset[1], s), 1);
      throw caml_maybe_attach_backtrace(need_more(s), 1);
     }
     var missing = 0;
    }
    var _a1_ = 7;
    function _a2_(i, x){
     if(-1 === x) return i - missing | 0;
     if((x & 65535) !== x)
      throw caml_maybe_attach_backtrace
             ([0, Parse_error, caml_call2(Stdlib_Printf[4], _w_, i), s], 1);
     caml_check_bound(a, i)[1 + i] = x;
     return i - 1 | 0;
    }
    caml_call3(Stdlib_List[26], _a2_, _a1_, res);
    if(use_bracket) expect_char(s, offset, 93);
    var
     _a3_ = caml_check_bound(a, 7)[8],
     _a4_ = caml_check_bound(a, 6)[7],
     _a5_ = caml_check_bound(a, 5)[6],
     _a6_ = caml_check_bound(a, 4)[5],
     _a7_ = caml_check_bound(a, 3)[4],
     _a8_ = caml_check_bound(a, 2)[3],
     _a9_ = caml_check_bound(a, 1)[2];
    return make$1
            (caml_check_bound(a, 0)[1],
             _a9_,
             _a8_,
             _a7_,
             _a6_,
             _a5_,
             _a4_,
             _a3_);
   }
   function of_string_exn$1(s){
    var o = [0, 0], x = of_string_raw$1(s, o);
    expect_end(s, o);
    return x;
   }
   function of_string$1(s){return try_with_result(of_string_exn$1, s);}
   function with_port_of_string$0(default$0, s){
    var len = caml_ml_string_length(s), o = [0, 0];
    try{
     var ipv6 = of_string_raw$1(s, o);
     a:
     {
      if(o[1] < len && 58 === caml_string_get(s, o[1])){
       o[1]++;
       var port = parse_dec_int(s, o);
       expect_end(s, o);
       var _aZ_ = [0, [0, ipv6, port]];
       break a;
      }
      expect_end(s, o);
      var _aZ_ = [0, [0, ipv6, default$0]];
     }
     return _aZ_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Parse_error) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return [1, [0, 3854881, caml_call2(Stdlib[28], cst_Ipaddr$1, msg)]];
    }
   }
   function to_buffer$1(buf, addr){
    var
     comp = to_int16$0(addr),
     h = comp[8],
     g = comp[7],
     f = comp[6],
     e = comp[5],
     d = comp[4],
     c = comp[3],
     b = comp[2],
     a = comp[1];
    a:
    {
     if
      (0 === comp[1]
       &&
        0 === comp[2]
        &&
         0 === comp[3] && 0 === comp[4] && 0 === comp[5] && 65535 === comp[6]){var v4 = 1; break a;}
     var v4 = 0;
    }
    var
     elide = 0,
     zeros = 0,
     acc = 0,
     param = [0, h, [0, g, [0, f, [0, e, [0, d, [0, c, [0, b, [0, a, 0]]]]]]]];
    for(;;){
     if(! param) break;
     var n = param[1];
     if(0 === n)
      var xs = param[2], zeros$0 = zeros - 1 | 0, zeros = zeros$0, param = xs;
     else{
      var xs$0 = param[2];
      if(0 === zeros)
       var acc$0 = [0, n, acc], zeros = 0, acc = acc$0, param = xs$0;
      else
       var
        xs$1 = param[2],
        acc$1 = [0, n, [0, zeros, acc]],
        elide$0 = caml_call2(Stdlib[16], elide, zeros),
        elide = elide$0,
        zeros = 0,
        acc = acc$1,
        param = xs$1;
     }
    }
    var
     elide$1 = caml_call2(Stdlib[16], elide, zeros),
     acc$2 = 0 === zeros ? acc : [0, zeros, acc],
     elide$2 = -1 <= elide$1 ? 0 : [0, elide$1];
    a:
    {
     if(elide$2){var x = elide$2[1]; if(-8 > x){var _aT_ = 0; break a;}}
     var _aT_ = 1;
    }
    if(! _aT_) throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
    var _aU_ = [0, elide$2, 0];
    function _aV_(param, x$1){
     var l$1 = param[2], patt = param[1];
     if(caml_equal([0, x$1], patt)) return [0, 0, [0, 0, l$1]];
     if(0 <= x$1) return [0, patt, [0, [0, x$1], l$1]];
     var l = l$1, x = x$1;
     for(;;){
      if(0 <= x) return [0, patt, l];
      var x$0 = x + 1 | 0, l$0 = [0, _x_, l], l = l$0, x = x$0;
     }
    }
    var
     lrev = caml_call3(Stdlib_List[26], _aV_, _aU_, acc$2)[2],
     param$0 = caml_call1(Stdlib_List[10], lrev);
    for(;;){
     if(! param$0) return 0;
     var _aW_ = param$0[1];
     if(_aW_){
      var hi = _aW_[1], _aX_ = param$0[2];
      if(! _aX_) return caml_call3(Stdlib_Printf[5], buf, _A_, hi);
      var _aY_ = _aX_[1];
      if(_aY_){
       if(! _aX_[2]){
        var lo = _aY_[1];
        if(v4){
         var addr$0 = of_int16([0, hi, lo]);
         return to_buffer(buf, addr$0);
        }
       }
       var xs$2 = param$0[2];
       caml_call3(Stdlib_Printf[5], buf, _y_, hi);
       var param$0 = xs$2;
      }
      else{
       var xs$3 = _aX_[2];
       caml_call3(Stdlib_Printf[5], buf, _z_, hi);
       var param$0 = xs$3;
      }
     }
     else{
      var xs$4 = param$0[2];
      caml_call2(Stdlib_Buffer[16], buf, cst);
      var param$0 = xs$4;
     }
    }
   }
   function to_string$1(l){
    var buf = caml_call1(Stdlib_Buffer[1], 39);
    to_buffer$1(buf, l);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function pp$1(ppf, i){
    var _aS_ = to_string$1(i);
    return caml_call3(Stdlib_Format[137], ppf, _C_, _aS_);
   }
   function of_octets_exn$1(opt, bs){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(16 <= (caml_ml_string_length(bs) - off | 0))
     return of_octets_exn$0(caml_call3(Stdlib_String[16], bs, off, 16));
    throw caml_maybe_attach_backtrace(need_more(bs), 1);
   }
   function of_octets$0(off, bs){
    return try_with_result
            (function(_aR_){return of_octets_exn$1(off, _aR_);}, bs);
   }
   function write_octets$0(off, i, bs){
    return try_with_result
            (function(_aQ_){return write_octets_exn$0(off, i, _aQ_);}, bs);
   }
   function multicast_to_mac$0(s){
    var
     _aO_ = caml_call1(Stdlib_Char[1], 51),
     macb = caml_call2(Stdlib_Bytes[1], 6, _aO_);
    caml_call5(Stdlib_Bytes[12], s, 12, macb, 2, 4);
    var _aP_ = caml_call1(Stdlib_Bytes[6], macb);
    return caml_call1(Macaddr[2], _aP_);
   }
   function to_domain_name$0(b){
    var
     hexstr_of_int = caml_call1(Stdlib_Printf[4], _D_),
     name =
       fold_left
        (function(acc, b){
          var
           x = caml_call1(hexstr_of_int, b & 15),
           y = caml_call1(hexstr_of_int, b >>> 4 | 0);
          return [0, x, [0, y, acc]];
         },
         _E_,
         b),
     _aN_ = caml_call1(Domain_name[34], name);
    return caml_call1(Domain_name[7], _aN_);
   }
   function of_domain_name$0(n){
    function int_of_char_string(param){
     var switch$0 = runtime.caml_string_compare(param, "8");
     if(0 <= switch$0){
      if(0 >= switch$0) return 8;
      if(! caml_string_notequal(param, "9")) return 9;
      if(! caml_string_notequal(param, "a")) return 10;
      if(! caml_string_notequal(param, "b")) return 11;
      if(! caml_string_notequal(param, "c")) return 12;
      if(! caml_string_notequal(param, "d")) return 13;
      if(! caml_string_notequal(param, "e")) return 14;
      if(! caml_string_notequal(param, "f")) return 15;
     }
     else{
      if(! caml_string_notequal(param, "0")) return 0;
      if(! caml_string_notequal(param, "1")) return 1;
      if(! caml_string_notequal(param, "2")) return 2;
      if(! caml_string_notequal(param, "3")) return 3;
      if(! caml_string_notequal(param, "4")) return 4;
      if(! caml_string_notequal(param, "5")) return 5;
      if(! caml_string_notequal(param, "6")) return 6;
      if(! caml_string_notequal(param, "7")) return 7;
     }
     return caml_call1(Stdlib[2], cst_int_of_char_string_invalid);
    }
    var labels = caml_call1(Domain_name[38], n);
    if(34 === labels.length - 1){
     var _aG_ = caml_check_bound(labels, 0)[1];
     if(caml_call3(Domain_name[25], 0, _aG_, cst_arpa$0)){
      var _aH_ = caml_check_bound(labels, 1)[2];
      if(caml_call3(Domain_name[25], 0, _aH_, cst_ip6)){
       var b = caml_create_bytes(16);
       try{
        var bi = 0;
        for(;;){
         var
          i = 2 * (bi + 1 | 0) | 0,
          x = int_of_char_string(caml_check_bound(labels, i)[1 + i]),
          _aK_ = i + 1 | 0,
          y = int_of_char_string(caml_check_bound(labels, _aK_)[1 + _aK_]);
         caml_call3(Stdlib_Bytes[73], b, bi, x << 4 | y);
         var _aL_ = bi + 1 | 0;
         if(15 === bi){
          var _aJ_ = [0, of_octets_exn$0(caml_call1(Stdlib_Bytes[44], b))];
          return _aJ_;
         }
         var bi = _aL_;
        }
       }
       catch(_aM_){
        var _aI_ = caml_wrap_exception(_aM_);
        if(_aI_[1] === Stdlib[7]) return 0;
        throw caml_maybe_attach_backtrace(_aI_, 0);
       }
      }
     }
    }
    return 0;
   }
   var
    unspecified$0 = make$1(0, 0, 0, 0, 0, 0, 0, 0),
    localhost$0 = make$1(0, 0, 0, 0, 0, 0, 0, 1),
    interface_nodes = make$1(65281, 0, 0, 0, 0, 0, 0, 1),
    link_nodes = make$1(65282, 0, 0, 0, 0, 0, 0, 1),
    interface_routers = make$1(65281, 0, 0, 0, 0, 0, 0, 2),
    link_routers = make$1(65282, 0, 0, 0, 0, 0, 0, 2),
    site_routers = make$1(65285, 0, 0, 0, 0, 0, 0, 2);
   function compare$4(param, _aF_){
    var
     sz = _aF_[2],
     pre = _aF_[1],
     sz$0 = param[2],
     pre$0 = param[1],
     c = caml_call2(compare$3, pre$0, pre);
    return 0 === c ? caml_compare(sz$0, sz) : c;
   }
   function mask$0(sz){
    var n = 128 - sz | 0;
    if(0 === n) return max_int;
    if(128 === n) return zero;
    if(0 < n && 128 > n){
     var b = mk_zero(0), shift_bits = n % 8 | 0, shift_bytes = n / 8 | 0;
     if(0 === shift_bits)
      caml_call5
       (Stdlib_Bytes[12], max_int, shift_bytes, b, 0, 16 - shift_bytes | 0);
     else{
      var carry = [0, 0], _aD_ = shift_bytes | 0, _aC_ = 15;
      if(15 >= _aD_){
       var i = _aC_;
       for(;;){
        var
         x = caml_string_get(max_int, i),
         _aA_ = shift_bits <= 0 ? 1 : 0,
         _aB_ = _aA_ || (8 < shift_bits ? 1 : 0);
        if(_aB_) caml_call1(Stdlib[1], cst_out_of_bounds$0);
        var
         new_carry =
           (x & 255 << (8 - shift_bits | 0)) >>> (8 - shift_bits | 0) | 0,
         shifted_value = x << shift_bits,
         new_value = shifted_value | carry[1];
        caml_call3(Stdlib_Bytes[73], b, i - shift_bytes | 0, new_value);
        carry[1] = new_carry;
        var _aE_ = i - 1 | 0;
        if(_aD_ === i) break;
        var i = _aE_;
       }
      }
     }
     return caml_call1(Stdlib_Bytes[44], b);
    }
    throw caml_maybe_attach_backtrace
           ([0, Stdlib[6], cst_n_must_be_0_128$0], 1);
   }
   function prefix$0(param){
    var sz = param[2], pre = param[1];
    return [0, logand(pre, mask$0(sz)), sz];
   }
   function make$2(sz, pre){return [0, pre, sz];}
   function network_address$0(param, addr){
    var sz = param[2], pre = param[1], x = mask$0(sz), b = mk_zero(0);
    function _aw_(i, param){
     var _ay_ = caml_string_get(x, i), _az_ = caml_call1(Stdlib[21], _ay_);
     return caml_call3(Stdlib_Bytes[73], b, i, _az_);
    }
    caml_call2(Stdlib_String[31], _aw_, x);
    var _ax_ = logand(addr, caml_call1(Stdlib_Bytes[44], b));
    return logor(logand(pre, mask$0(sz)), _ax_);
   }
   function of_string_raw$2(s, i){
    var v6 = of_string_raw$1(s, i);
    expect_char(s, i, 47);
    var
     p = parse_dec_int(s, i),
     _au_ = 128 < p ? 1 : 0,
     _av_ = _au_ || (p < 0 ? 1 : 0);
    if(_av_)
     throw caml_maybe_attach_backtrace
            ([0, Parse_error, cst_invalid_prefix_size$0, s], 1);
    return [0, p, v6];
   }
   function of_string_raw$3(s, i){
    var match = of_string_raw$2(s, i), v6 = match[2], p = match[1];
    return [0, v6, p];
   }
   function of_string_exn$2(s){
    var i = [0, 0], res = of_string_raw$2(s, i);
    expect_end(s, i);
    var v6 = res[2], p = res[1];
    return [0, v6, p];
   }
   function of_string$2(s){return try_with_result(of_string_exn$2, s);}
   function of_netmask_exn$1(netmask, address){
    var
     nm_bits_set =
       fold_left
         (function(param$0, e$0){
           var
            is_last_bit_set$0 = param$0[2],
            bits = param$0[1],
            a$0 = [0, bits, is_last_bit_set$0],
            bitmask = [0, 128],
            a = [0, a$0],
            for$0 = 0;
           for(;;){
            var
             e = 0 < (e$0 & bitmask[1]) ? 1 : 0,
             param = a[1],
             is_last_bit_set = param[2],
             a$1 = param[1];
            a:
            {
             if(is_last_bit_set){
              if(e){var _as_ = [0, a$1 + 1 | 0, 1]; break a;}
             }
             else if(e)
              throw caml_maybe_attach_backtrace
                     ([0,
                       Parse_error,
                       cst_invalid_netmask$0,
                       to_string$1(netmask)],
                      1);
             var _as_ = [0, a$1, 0];
            }
            a[1] = _as_;
            bitmask[1] = bitmask[1] >>> 1 | 0;
            var _at_ = for$0 + 1 | 0;
            if(7 === for$0) return a[1];
            var for$0 = _at_;
           }
          },
          _F_,
          netmask)
        [1];
    return [0, address, nm_bits_set];
   }
   function of_netmask_exn$2(netmask, address){return of_netmask_exn$1(netmask, address);
   }
   function of_netmask$0(netmask, address){
    return try_with_result
            (function(_ar_){return of_netmask_exn$1(netmask, _ar_);}, address);
   }
   function to_buffer$2(buf, param){
    var sz = param[2], pre = param[1];
    return caml_call5(Stdlib_Printf[5], buf, _G_, to_buffer$1, pre, sz);
   }
   function to_string$2(subnet){
    var buf = caml_call1(Stdlib_Buffer[1], 43);
    to_buffer$2(buf, subnet);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function pp$2(ppf, i){
    var _aq_ = to_string$2(i);
    return caml_call3(Stdlib_Format[137], ppf, _H_, _aq_);
   }
   function mem$0(ip, param){
    var sz = param[2], pre = param[1], m = mask$0(sz), _ap_ = logand(pre, m);
    return caml_equal(logand(ip, m), _ap_);
   }
   function subset$0(param, _an_){
    var
     sz2 = _an_[2],
     pre2 = _an_[1],
     sz1 = param[2],
     pre1 = param[1],
     _ao_ = sz2 <= sz1 ? 1 : 0;
    return _ao_ ? mem$0(pre1, [0, pre2, sz2]) : _ao_;
   }
   function of_addr$0(ip){return [0, ip, 128];}
   var
    global_unicast_001 = [0, make$1(8192, 0, 0, 0, 0, 0, 0, 0), 3],
    link$0 = [0, make$1(65152, 0, 0, 0, 0, 0, 0, 0), 64],
    unique_local = [0, make$1(64512, 0, 0, 0, 0, 0, 0, 0), 7],
    multicast$0 = [0, make$1(65280, 0, 0, 0, 0, 0, 0, 0), 8],
    ipv4_mapped = [0, make$1(0, 0, 0, 0, 0, 65535, 0, 0), 96],
    noneui64_interface = [0, make$1(0, 0, 0, 0, 0, 0, 0, 0), 3],
    solicited_node = [0, make$1(65282, 0, 0, 0, 0, 1, 65280, 0), 104];
   function network$0(param){
    var sz = param[2], pre = param[1];
    return logand(pre, mask$0(sz));
   }
   function address$0(param){var addr = param[1]; return addr;}
   function bits$0(param){var sz = param[2]; return sz;}
   function netmask$0(subnet){return mask$0(subnet[2]);}
   function first$0(cidr){
    var sz = cidr[2];
    return 126 < sz ? network$0(cidr) : failwith_msg(succ$0(network$0(cidr)));
   }
   function last$0(cidr){
    var sz = cidr[2], _am_ = shift_right(max_int, sz);
    return logor(network$0(cidr), _am_);
   }
   function hosts$0(opt, cidr){
    var sz = cidr[2];
    if(opt) var sth = opt[1], usable = sth; else var usable = 1;
    function iter_seq(start, stop){
     if(0 < caml_call2(compare$3, start, stop)) return 0;
     var match = succ$0(start);
     if(0 !== match[0]) return [0, start, function(param){return 0;}];
     var start_succ = match[1];
     return [0, start, function(param){return iter_seq(start_succ, stop);}];
    }
    if(usable && 128 === sz) return function(param){return 0;};
    if(usable)
     var stop = last$0(cidr), stop$0 = stop, start = first$0(cidr);
    else
     var
      stop$1 = last$0(cidr),
      start$0 = network$0(cidr),
      stop$0 = stop$1,
      start = start$0;
    return function(param){return iter_seq(start, stop$0);};
   }
   function subnets$0(n, cidr){
    var sz = cidr[2];
    function iter_seq(start, stop, steps){
     if(0 < caml_call2(compare$3, start, stop)) return 0;
     var prefix = [0, start, n];
     if(caml_call2(equal, start, stop))
      return [0, prefix, function(param){return 0;}];
     try{var _ak_ = [0, add_exn(start, steps)], match = _ak_;}
     catch(_al_){
      var _aj_ = caml_wrap_exception(_al_);
      if(_aj_ !== Overflow) throw caml_maybe_attach_backtrace(_aj_, 0);
      var match = 0;
     }
     if(! match) return [0, prefix, function(param){return 0;}];
     var start_succ = match[1];
     return [0,
             prefix,
             function(param){return iter_seq(start_succ, stop, steps);}];
    }
    if(n >= sz && 128 >= n){
     var
      start = network$0(cidr),
      stop = last$0(cidr),
      x = netmask$0(cidr),
      b = mk_zero(0),
      _ai_ = n - sz | 0;
     iteri_right2
      (function(i, x, y){return caml_call3(Stdlib_Bytes[73], b, i, x ^ y);},
       x,
       max_int);
     var steps = succ_exn(shift_right(caml_call1(Stdlib_Bytes[44], b), _ai_));
     return function(param){return iter_seq(start, stop, steps);};
    }
    return function(param){return 0;};
   }
   function scope$0(i){
    function mem(_ah_){return mem$0(i, _ah_);}
    if(mem(global_unicast_001)) return 6;
    if(mem(ipv4_mapped)){var v4 = to_int32$0(i)[4]; return scope(v4);}
    if(! mem(multicast$0))
     return mem(link$0)
             ? 2
             : mem
                (unique_local)
               ? 6
               : caml_equal
                  (i, localhost$0)
                 ? 1
                 : caml_equal(i, unspecified$0) ? 0 : 6;
    var x = to_int16$0(i)[1], match = x & 15;
    if(15 < match >>> 0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _I_], 1);
    switch(match){
      case 0:
       return 0;
      case 1:
       return 1;
      case 4:
       return 3;
      case 2:
      case 3:
       return 2;
      case 14:
      case 15:
       return 6;
      case 5:
      case 6:
      case 7:
       return 4;
      default: return 5;
    }
   }
   function link_address_of_mac(mac){
    var
     bmac = caml_call1(Macaddr[6], mac),
     c_0 = caml_string_get(bmac, 0) ^ 2,
     _ad_ = caml_string_get(bmac, 5),
     _ae_ = (caml_string_get(bmac, 4) << 8) + _ad_ | 0,
     _af_ = 65024 + caml_string_get(bmac, 3) | 0,
     _ag_ = (caml_string_get(bmac, 2) << 8) + 255 | 0,
     addr =
       make$1
        (0,
         0,
         0,
         0,
         (c_0 << 8) + caml_string_get(bmac, 1) | 0,
         _ag_,
         _af_,
         _ae_);
    return network_address$0(link$0, addr);
   }
   function is_global$0(i){return 6 === scope$0(i) ? 1 : 0;}
   function is_multicast$0(i){return mem$0(i, multicast$0);}
   function is_private$0(i){return 6 !== scope$0(i) ? 1 : 0;}
   function compare$5(a, b){return caml_call2(compare$3, a, b);}
   var Set$0 = caml_call1(Stdlib_Set[1], [0, compare$5]);
   function compare$6(a, b){return caml_call2(compare$3, a, b);}
   var Map$0 = caml_call1(Stdlib_Map[1], [0, compare$6]);
   function compare$7(a, b){
    if(0 === a[0]){
     var a$0 = a[1];
     if(0 !== b[0]) return -1;
     var b$0 = b[1];
     return caml_call2(compare, a$0, b$0);
    }
    var a$1 = a[1];
    if(0 === b[0]) return 1;
    var b$1 = b[1];
    return caml_call2(compare$3, a$1, b$1);
   }
   function compare$8(a, b){return compare$7(a, b);}
   var Set$1 = caml_call1(Stdlib_Set[1], [0, compare$8]);
   function compare$9(a, b){return compare$7(a, b);}
   var Map$1 = caml_call1(Stdlib_Map[1], [0, compare$9]);
   function to_string$3(param){
    if(0 === param[0]){var x = param[1]; return to_string(x);}
    var x$0 = param[1];
    return to_string$1(x$0);
   }
   function to_buffer$3(buf, param){
    if(0 === param[0]){var x = param[1]; return to_buffer(buf, x);}
    var x$0 = param[1];
    return to_buffer$1(buf, x$0);
   }
   function pp$3(ppf, i){
    var _ac_ = to_string$3(i);
    return caml_call3(Stdlib_Format[137], ppf, _J_, _ac_);
   }
   function of_string_raw$4(s, offset){
    var len = caml_ml_string_length(s);
    if(len < (offset[1] + 1 | 0))
     throw caml_maybe_attach_backtrace(need_more(s), 1);
    if(91 === caml_string_get(s, 0)) return [1, of_string_raw$1(s, offset)];
    var pos = offset[1];
    try{var _ab_ = [0, parse_dotted_quad(s, offset)]; return _ab_;}
    catch(exn$1){
     var exn = caml_wrap_exception(exn$1);
     if(exn[1] !== Parse_error) throw caml_maybe_attach_backtrace(exn, 0);
     var v4_msg = exn[2];
     offset[1] = pos;
     try{var _aa_ = [1, of_string_raw$1(s, offset)]; return _aa_;}
     catch(exn){
      var exn$0 = caml_wrap_exception(exn);
      if(exn$0[1] !== Parse_error)
       throw caml_maybe_attach_backtrace(exn$0, 0);
      var
       s$0 = exn$0[3],
       v6_msg = exn$0[2],
       msg = caml_call3(Stdlib_Printf[4], _K_, v4_msg, v6_msg);
      throw caml_maybe_attach_backtrace([0, Parse_error, msg, s$0], 1);
     }
    }
   }
   function of_string_exn$3(s){
    var o = [0, 0], x = of_string_raw$4(s, o);
    expect_end(s, o);
    return x;
   }
   function of_string$3(s){return try_with_result(of_string_exn$3, s);}
   function with_port_of_string$1(default$0, s){
    var len = caml_ml_string_length(s), o = [0, 0];
    try{
     var ipv6 = of_string_raw$4(s, o);
     a:
     {
      if(o[1] < len && 58 === caml_string_get(s, o[1])){
       o[1]++;
       var port = parse_dec_int(s, o);
       expect_end(s, o);
       var _$_ = [0, [0, ipv6, port]];
       break a;
      }
      expect_end(s, o);
      var _$_ = [0, [0, ipv6, default$0]];
     }
     return _$_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Parse_error) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return [1, [0, 3854881, caml_call2(Stdlib[28], cst_Ipaddr$2, msg)]];
    }
   }
   function of_octets_exn$2(bs){
    var match = caml_ml_string_length(bs);
    if(4 === match) return [0, of_octets_exn(0, bs)];
    if(16 === match) return [1, of_octets_exn$1(0, bs)];
    throw caml_maybe_attach_backtrace
           ([0, Parse_error, cst_octets_must_be_of_length_4, bs], 1);
   }
   function of_octets$1(bs){return try_with_result(of_octets_exn$2, bs);}
   function to_octets$1(i){
    if(0 === i[0]){var p = i[1]; return to_octets(p);}
    var p$0 = i[1];
    return p$0;
   }
   function v6_of_v4(v4){
    return network_address$0(ipv4_mapped, of_int32$0([0, 0, 0, 0, v4]));
   }
   function v4_of_v6(v6){
    if(! mem$0(v6, ipv4_mapped)) return 0;
    var v4 = to_int32$0(v6)[4];
    return [0, v4];
   }
   function to_v4(param){
    if(0 === param[0]){var v4 = param[1]; return [0, v4];}
    var v6 = param[1];
    return v4_of_v6(v6);
   }
   function to_v6(param){
    if(0 === param[0]){var v4 = param[1]; return v6_of_v4(v4);}
    var v6 = param[1];
    return v6;
   }
   function scope$1(param){
    if(0 === param[0]){var v4 = param[1]; return scope(v4);}
    var v6 = param[1];
    return scope$0(v6);
   }
   function is_global$1(param){
    if(0 === param[0]){var v4 = param[1]; return is_global(v4);}
    var v6 = param[1];
    return is_global$0(v6);
   }
   function is_multicast$1(param){
    if(0 === param[0]){var v4 = param[1]; return is_multicast(v4);}
    var v6 = param[1];
    return is_multicast$0(v6);
   }
   function is_private$1(param){
    if(0 === param[0]){var v4 = param[1]; return is_private(v4);}
    var v6 = param[1];
    return is_private$0(v6);
   }
   function multicast_to_mac$1(param){
    if(0 === param[0]){var v4 = param[1]; return multicast_to_mac(v4);}
    var v6 = param[1];
    return multicast_to_mac$0(v6);
   }
   function to_domain_name$1(param){
    if(0 === param[0]){var v4 = param[1]; return to_domain_name(v4);}
    var v6 = param[1];
    return to_domain_name$0(v6);
   }
   function of_domain_name$1(n){
    var match = caml_call1(Domain_name[11], n);
    if(6 === match){
     var match$0 = of_domain_name(n);
     if(! match$0) return 0;
     var x = match$0[1];
     return [0, [0, x]];
    }
    if(34 !== match) return 0;
    var match$1 = of_domain_name$0(n);
    if(! match$1) return 0;
    var x$0 = match$1[1];
    return [0, [1, x$0]];
   }
   function succ$1(param){
    if(0 === param[0]){
     var addr = param[1], _X_ = succ(addr), _Y_ = function(v){return [0, v];};
     return caml_call2(Stdlib_Result[8], _Y_, _X_);
    }
    var addr$0 = param[1], _Z_ = succ$0(addr$0);
    function ___(v){return [1, v];}
    return caml_call2(Stdlib_Result[8], ___, _Z_);
   }
   function pred$1(param){
    if(0 === param[0]){
     var addr = param[1], _T_ = pred(addr), _U_ = function(v){return [0, v];};
     return caml_call2(Stdlib_Result[8], _U_, _T_);
    }
    var addr$0 = param[1], _V_ = pred$0(addr$0);
    function _W_(v){return [1, v];}
    return caml_call2(Stdlib_Result[8], _W_, _V_);
   }
   function compare$10(a, b){
    if(0 === a[0]){
     var a$0 = a[1];
     if(0 !== b[0]) return -1;
     var b$0 = b[1];
     return compare$0(a$0, b$0);
    }
    var a$1 = a[1];
    if(0 === b[0]) return 1;
    var b$1 = b[1];
    return compare$4(a$1, b$1);
   }
   function of_string_raw$5(s, offset){
    var len = caml_ml_string_length(s);
    if(len < (offset[1] + 1 | 0))
     throw caml_maybe_attach_backtrace(need_more(s), 1);
    if(91 === caml_string_get(s, 0)) return [1, of_string_raw$3(s, offset)];
    var pos = offset[1];
    try{var _S_ = [0, of_string_raw$0(s, offset)]; return _S_;}
    catch(exn$1){
     var exn = caml_wrap_exception(exn$1);
     if(exn[1] !== Parse_error) throw caml_maybe_attach_backtrace(exn, 0);
     var v4_msg = exn[2];
     offset[1] = pos;
     try{var _R_ = [1, of_string_raw$3(s, offset)]; return _R_;}
     catch(exn){
      var exn$0 = caml_wrap_exception(exn);
      if(exn$0[1] !== Parse_error)
       throw caml_maybe_attach_backtrace(exn$0, 0);
      var
       s$0 = exn$0[3],
       v6_msg = exn$0[2],
       msg = caml_call3(Stdlib_Printf[4], _L_, v4_msg, v6_msg);
      throw caml_maybe_attach_backtrace([0, Parse_error, msg, s$0], 1);
     }
    }
   }
   function of_string_exn$4(s){
    var o = [0, 0], x = of_string_raw$5(s, o);
    expect_end(s, o);
    return x;
   }
   function of_string$4(s){return try_with_result(of_string_exn$4, s);}
   function v6_of_v4$0(v4){
    var _Q_ = v6_of_v4(network(v4));
    return [0, _Q_, 96 + v4[2] | 0];
   }
   function v4_of_v6$0(v6){
    var match = v4_of_v6(network$0(v6));
    if(! match) return 0;
    var v4 = match[1];
    return [0, [0, v4, v6[2] - 96 | 0]];
   }
   function to_v4$0(param){
    if(0 === param[0]){var v4 = param[1]; return [0, v4];}
    var v6 = param[1];
    return v4_of_v6$0(v6);
   }
   function to_v6$0(param){
    if(0 === param[0]){var v4 = param[1]; return v6_of_v4$0(v4);}
    var v6 = param[1];
    return v6;
   }
   function mem$1(ip, prefix){
    var _P_ = to_v6$0(prefix);
    return mem$0(to_v6(ip), _P_);
   }
   function subset$1(subnet, network){
    var _O_ = to_v6$0(network);
    return subset$0(to_v6$0(subnet), _O_);
   }
   function of_addr$1(param){
    if(0 === param[0]){var p = param[1]; return [0, of_addr(p)];}
    var p$0 = param[1];
    return [1, of_addr$0(p$0)];
   }
   function to_string$4(param){
    if(0 === param[0]){var p = param[1]; return to_string$0(p);}
    var p$0 = param[1];
    return to_string$2(p$0);
   }
   function to_buffer$4(buf, param){
    if(0 === param[0]){var p = param[1]; return to_buffer$0(buf, p);}
    var p$0 = param[1];
    return to_buffer$2(buf, p$0);
   }
   function network$1(param){
    if(0 === param[0]){var p = param[1]; return [0, network(p)];}
    var p$0 = param[1];
    return [1, network$0(p$0)];
   }
   function netmask$1(param){
    if(0 === param[0]){var p = param[1]; return [0, netmask(p)];}
    var p$0 = param[1];
    return [1, netmask$0(p$0)];
   }
   function address$1(param){
    if(0 === param[0]){var p = param[1]; return [0, p[1]];}
    var p$0 = param[1];
    return [1, p$0[1]];
   }
   function pp$4(ppf, i){
    var _N_ = to_string$4(i);
    return caml_call3(Stdlib_Format[137], ppf, _M_, _N_);
   }
   function first$1(param){
    if(0 === param[0]){var p = param[1]; return [0, first(p)];}
    var p$0 = param[1];
    return [1, first$0(p$0)];
   }
   function last$1(param){
    if(0 === param[0]){var p = param[1]; return [0, last(p)];}
    var p$0 = param[1];
    return [1, last$0(p$0)];
   }
   function hosts$1(opt, param){
    if(opt) var sth = opt[1], usable = sth; else var usable = 1;
    if(0 === param[0]){var p = param[1]; return [0, hosts([0, usable], p)];}
    var p$0 = param[1];
    return [1, hosts$0([0, usable], p$0)];
   }
   function subnets$1(n, param){
    if(0 === param[0]){var p = param[1]; return [0, subnets(n, p)];}
    var p$0 = param[1];
    return [1, subnets$0(n, p$0)];
   }
   var
    Ipaddr =
      [0,
       Parse_error,
       string_of_scope,
       scope_of_string,
       pp_scope,
       [0,
        make,
        of_string,
        of_string_exn,
        parse_dotted_quad,
        with_port_of_string,
        to_string,
        to_buffer,
        pp,
        of_octets,
        of_octets_exn,
        write_octets,
        write_octets_exn,
        to_octets,
        of_int32,
        to_int32,
        of_int16,
        to_int16,
        multicast_to_mac,
        to_domain_name,
        of_domain_name,
        succ,
        pred,
        any,
        unspecified,
        broadcast,
        nodes,
        routers,
        localhost,
        [0,
         mask,
         make$0,
         prefix,
         network_address,
         of_string$0,
         of_string_exn$0,
         of_string_raw$0,
         to_string$0,
         pp$0,
         to_buffer$0,
         of_netmask_exn$0,
         of_netmask,
         mem,
         subset,
         of_addr,
         global,
         loopback,
         link,
         relative,
         multicast,
         private_10,
         private_172,
         private_192,
         private_blocks,
         broadcast$0,
         network,
         netmask,
         address,
         bits,
         first,
         last,
         hosts,
         subnets,
         compare$0],
        scope,
        is_global,
        is_multicast,
        is_private,
        compare,
        Set,
        Map],
       [0,
        make$1,
        of_string$1,
        of_string_exn$1,
        with_port_of_string$0,
        of_string_raw$1,
        to_string$1,
        to_buffer$1,
        pp$1,
        of_octets$0,
        of_octets_exn$1,
        write_octets_exn$0,
        write_octets$0,
        to_octets$0,
        of_int64,
        to_int64,
        of_int32$0,
        to_int32$0,
        of_int16$0,
        to_int16$0,
        multicast_to_mac$0,
        to_domain_name$0,
        of_domain_name$0,
        succ$0,
        pred$0,
        unspecified$0,
        localhost$0,
        interface_nodes,
        link_nodes,
        interface_routers,
        link_routers,
        site_routers,
        [0,
         mask$0,
         make$2,
         prefix$0,
         network_address$0,
         of_string_exn$2,
         of_string$2,
         of_string_raw$3,
         to_string$2,
         pp$2,
         to_buffer$2,
         of_netmask_exn$2,
         of_netmask$0,
         mem$0,
         subset$0,
         of_addr$0,
         global_unicast_001,
         unique_local,
         link$0,
         multicast$0,
         ipv4_mapped,
         noneui64_interface,
         solicited_node,
         network$0,
         netmask$0,
         address$0,
         bits$0,
         first$0,
         last$0,
         hosts$0,
         subnets$0,
         compare$4],
        scope$0,
        link_address_of_mac,
        is_global$0,
        is_multicast$0,
        is_private$0,
        compare$3,
        Set$0,
        Map$0],
       to_string$3,
       to_buffer$3,
       pp$3,
       of_string_exn$3,
       of_string$3,
       of_string_raw$4,
       with_port_of_string$1,
       of_octets_exn$2,
       of_octets$1,
       to_octets$1,
       v4_of_v6,
       to_v4,
       v6_of_v4,
       to_v6,
       scope$1,
       is_global$1,
       is_multicast$1,
       is_private$1,
       multicast_to_mac$1,
       to_domain_name$1,
       of_domain_name$1,
       succ$1,
       pred$1,
       [0,
        to_string$4,
        to_buffer$4,
        pp$4,
        of_string_exn$4,
        of_string$4,
        of_string_raw$5,
        v4_of_v6$0,
        to_v4$0,
        v6_of_v4$0,
        to_v6$0,
        mem$1,
        subset$1,
        of_addr$1,
        network$1,
        netmask$1,
        address$1,
        first$1,
        last$1,
        hosts$1,
        subnets$1,
        compare$10],
       compare$7,
       Set$1,
       Map$1];
   runtime.caml_register_global(134, Ipaddr, "Ipaddr");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpcGFkZHIuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInRyeV93aXRoX3Jlc3VsdCIsImZuIiwiYSIsIm1zZyIsImZhaWx3aXRoX21zZyIsIngiLCJtIiwic3RyaW5nX29mX3Njb3BlIiwic2NvcGVfb2Zfc3RyaW5nIiwicyIsInBwX3Njb3BlIiwiZm10Iiwic3ltYm9sIiwieSIsInN5bWJvbCQwIiwibmVlZF9tb3JlIiwiaW50X29mX2NoYXIiLCJjIiwiYmFkX2NoYXIiLCJpIiwiaXNfbnVtYmVyIiwiYmFzZSIsIm4iLCJwYXJzZV9pbnQiLCJsZW4iLCJpJDAiLCJwcmV2IiwiaiIsImsiLCJwcmV2JDAiLCJwYXJzZV9kZWNfaW50IiwiZXhwZWN0X2NoYXIiLCJleHBlY3RfZW5kIiwicmVqZWN0X29jdGFsIiwiY29tcGFyZSIsIm1ha2UiLCJiIiwiZCIsInBhcnNlX2RvdHRlZF9xdWFkIiwidmFsaWQiLCJvZl9zdHJpbmdfZXhuIiwibyIsIm9mX3N0cmluZyIsIndpdGhfcG9ydF9vZl9zdHJpbmciLCJkZWZhdWx0JDAiLCJpcHY0IiwicG9ydCIsInRvX2J1ZmZlciIsInRvX3N0cmluZyIsInBwIiwicHBmIiwib2Zfb2N0ZXRzX2V4biIsIm9wdCIsImJzIiwic3RoIiwib2ZmIiwib2Zfb2N0ZXRzIiwid3JpdGVfb2N0ZXRzX2V4biIsIndyaXRlX29jdGV0cyIsInRvX29jdGV0cyIsIm9mX2ludDMyIiwidG9faW50MzIiLCJvZl9pbnQxNiIsInRvX2ludDE2IiwibXVsdGljYXN0X3RvX21hYyIsIm1hY2IiLCJ0b19kb21haW5fbmFtZSIsIm5hbWUiLCJvZl9kb21haW5fbmFtZSIsImFycGEiLCJpbl9hZGRyIiwiY29udiIsImJpdHMiLCJkYXRhIiwic3VjYyIsInQiLCJwcmVkIiwiYW55IiwidW5zcGVjaWZpZWQiLCJicm9hZGNhc3QiLCJsb2NhbGhvc3QiLCJub2RlcyIsInJvdXRlcnMiLCJjb21wYXJlJDAiLCJzeiIsInByZSIsInN6JDAiLCJwcmUkMCIsIm1hc2siLCJwcmVmaXgiLCJtYWtlJDAiLCJuZXR3b3JrX2FkZHJlc3MiLCJhZGRyIiwib2Zfc3RyaW5nX3JhdyIsInF1YWQiLCJwIiwib2Zfc3RyaW5nX3JhdyQwIiwib2Zfc3RyaW5nX2V4biQwIiwicmVzIiwib2Zfc3RyaW5nJDAiLCJvZl9uZXRtYXNrX2V4biIsIm5ldG1hc2siLCJhZGRyZXNzIiwiYml0cyQxIiwiaSQxIiwiYml0cyQwIiwib2ZfbmV0bWFza19leG4kMCIsIm9mX25ldG1hc2siLCJ0b19idWZmZXIkMCIsImJ1ZiIsInRvX3N0cmluZyQwIiwic3VibmV0IiwicHAkMCIsIm1lbSIsImlwIiwic3Vic2V0Iiwic3oyIiwicHJlMiIsInN6MSIsInByZTEiLCJvZl9hZGRyIiwiZ2xvYmFsIiwicmVsYXRpdmUiLCJsb29wYmFjayIsImxpbmsiLCJtdWx0aWNhc3QiLCJtdWx0aWNhc3Rfb3JnIiwibXVsdGljYXN0X2FkbWluIiwibXVsdGljYXN0X2xpbmsiLCJwcml2YXRlXzEwIiwicHJpdmF0ZV8xNzIiLCJwcml2YXRlXzE5MiIsInByaXZhdGVfYmxvY2tzIiwiYnJvYWRjYXN0JDAiLCJuZXR3b3JrIiwiZmlyc3QiLCJjaWRyIiwibGFzdCIsImhvc3RzIiwidXNhYmxlIiwiaXRlcl9zZXEiLCJzdGFydCIsInN0b3AiLCJzdGFydF9zdWNjIiwic3RvcCQwIiwic3RvcCQxIiwic3RhcnQkMCIsInN1Ym5ldHMiLCJzdGVwcyIsInNjb3BlIiwibWVtJDAiLCJpc19nbG9iYWwiLCJpc19tdWx0aWNhc3QiLCJpc19wcml2YXRlIiwiY29tcGFyZSQxIiwiY29tcGFyZSQyIiwibWtfemVybyIsInplcm8iLCJtYXhfaW50IiwiY29tcGFyZSQzIiwiZXF1YWwiLCJmb2xkX2xlZnQiLCJmIiwiaW5pdCIsIml0ZXJpX3JpZ2h0MiIsIngkMCIsInkkMCIsIm9mX29jdGV0c19leG4kMCIsInRvX29jdGV0cyQwIiwib2ZfaW50NjQiLCJiJDAiLCJ0b19pbnQ2NCIsIm9mX2ludDMyJDAiLCJ0b19pbnQzMiQwIiwib2ZfaW50MTYkMCIsImgiLCJnIiwiZSIsInRvX2ludDE2JDAiLCJhZGRfZXhuIiwiY2FycnkiLCJzdW0iLCJsb2dhbmQiLCJsb2dvciIsInNoaWZ0X3JpZ2h0Iiwic2hpZnRfYml0cyIsInNoaWZ0X2J5dGVzIiwibmV3X2NhcnJ5Iiwic2hpZnRlZF92YWx1ZSIsIngkMSIsIm5ld192YWx1ZSIsIndyaXRlX29jdGV0c19leG4kMCIsImRlc3QiLCJzdWNjX2V4biIsInN1Y2MkMCIsInByZWQkMCIsIm1ha2UkMSIsIm9mX3N0cmluZ19yYXckMSIsIm9mZnNldCIsImNvbXByZXNzZWQiLCJ1c2VfYnJhY2tldCIsImFjYyIsIm5iJDIiLCJuYiIsImFjYyQwIiwicG9zIiwiYWNjJDEiLCJuYiQwIiwiYWNjJDIiLCJuYiQxIiwidjQiLCJsbyIsImhpIiwicmVzX2xlbiIsIm1pc3NpbmciLCJvZl9zdHJpbmdfZXhuJDEiLCJvZl9zdHJpbmckMSIsIndpdGhfcG9ydF9vZl9zdHJpbmckMCIsImlwdjYiLCJ0b19idWZmZXIkMSIsImNvbXAiLCJlbGlkZSIsInplcm9zIiwieHMiLCJ4cyQwIiwieHMkMSIsImVsaWRlJDEiLCJlbGlkZSQyIiwibCQxIiwicGF0dCIsImwiLCJsJDAiLCJscmV2IiwiYWRkciQwIiwieHMkMiIsInhzJDMiLCJ4cyQ0IiwidG9fc3RyaW5nJDEiLCJwcCQxIiwib2Zfb2N0ZXRzX2V4biQxIiwib2Zfb2N0ZXRzJDAiLCJ3cml0ZV9vY3RldHMkMCIsIm11bHRpY2FzdF90b19tYWMkMCIsInRvX2RvbWFpbl9uYW1lJDAiLCJoZXhzdHJfb2ZfaW50Iiwib2ZfZG9tYWluX25hbWUkMCIsImludF9vZl9jaGFyX3N0cmluZyIsImxhYmVscyIsImJpIiwidW5zcGVjaWZpZWQkMCIsImxvY2FsaG9zdCQwIiwiaW50ZXJmYWNlX25vZGVzIiwibGlua19ub2RlcyIsImludGVyZmFjZV9yb3V0ZXJzIiwibGlua19yb3V0ZXJzIiwic2l0ZV9yb3V0ZXJzIiwiY29tcGFyZSQ0IiwibWFzayQwIiwicHJlZml4JDAiLCJtYWtlJDIiLCJuZXR3b3JrX2FkZHJlc3MkMCIsIm9mX3N0cmluZ19yYXckMiIsInY2Iiwib2Zfc3RyaW5nX3JhdyQzIiwib2Zfc3RyaW5nX2V4biQyIiwib2Zfc3RyaW5nJDIiLCJvZl9uZXRtYXNrX2V4biQxIiwibm1fYml0c19zZXQiLCJlJDAiLCJpc19sYXN0X2JpdF9zZXQkMCIsImEkMCIsImJpdG1hc2siLCJpc19sYXN0X2JpdF9zZXQiLCJhJDEiLCJvZl9uZXRtYXNrX2V4biQyIiwib2ZfbmV0bWFzayQwIiwidG9fYnVmZmVyJDIiLCJ0b19zdHJpbmckMiIsInBwJDIiLCJzdWJzZXQkMCIsIm9mX2FkZHIkMCIsImdsb2JhbF91bmljYXN0XzAwMSIsImxpbmskMCIsInVuaXF1ZV9sb2NhbCIsIm11bHRpY2FzdCQwIiwiaXB2NF9tYXBwZWQiLCJub25ldWk2NF9pbnRlcmZhY2UiLCJzb2xpY2l0ZWRfbm9kZSIsIm5ldHdvcmskMCIsImFkZHJlc3MkMCIsIm5ldG1hc2skMCIsImZpcnN0JDAiLCJsYXN0JDAiLCJob3N0cyQwIiwic3VibmV0cyQwIiwic2NvcGUkMCIsImxpbmtfYWRkcmVzc19vZl9tYWMiLCJtYWMiLCJibWFjIiwiY18wIiwiaXNfZ2xvYmFsJDAiLCJpc19tdWx0aWNhc3QkMCIsImlzX3ByaXZhdGUkMCIsImNvbXBhcmUkNSIsImNvbXBhcmUkNiIsImNvbXBhcmUkNyIsImIkMSIsImNvbXBhcmUkOCIsImNvbXBhcmUkOSIsInRvX3N0cmluZyQzIiwidG9fYnVmZmVyJDMiLCJwcCQzIiwib2Zfc3RyaW5nX3JhdyQ0IiwidjRfbXNnIiwicyQwIiwidjZfbXNnIiwib2Zfc3RyaW5nX2V4biQzIiwib2Zfc3RyaW5nJDMiLCJ3aXRoX3BvcnRfb2Zfc3RyaW5nJDEiLCJvZl9vY3RldHNfZXhuJDIiLCJvZl9vY3RldHMkMSIsInRvX29jdGV0cyQxIiwicCQwIiwidjZfb2ZfdjQiLCJ2NF9vZl92NiIsInRvX3Y0IiwidG9fdjYiLCJzY29wZSQxIiwiaXNfZ2xvYmFsJDEiLCJpc19tdWx0aWNhc3QkMSIsImlzX3ByaXZhdGUkMSIsIm11bHRpY2FzdF90b19tYWMkMSIsInRvX2RvbWFpbl9uYW1lJDEiLCJvZl9kb21haW5fbmFtZSQxIiwic3VjYyQxIiwidiIsInByZWQkMSIsImNvbXBhcmUkMTAiLCJvZl9zdHJpbmdfcmF3JDUiLCJvZl9zdHJpbmdfZXhuJDQiLCJvZl9zdHJpbmckNCIsInY2X29mX3Y0JDAiLCJ2NF9vZl92NiQwIiwidG9fdjQkMCIsInRvX3Y2JDAiLCJtZW0kMSIsInN1YnNldCQxIiwib2ZfYWRkciQxIiwidG9fc3RyaW5nJDQiLCJ0b19idWZmZXIkNCIsIm5ldHdvcmskMSIsIm5ldG1hc2skMSIsImFkZHJlc3MkMSIsInBwJDQiLCJmaXJzdCQxIiwibGFzdCQxIiwiaG9zdHMkMSIsInN1Ym5ldHMkMSJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2lwYWRkci9pcGFkZHIubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHQWlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBSUlBLGdCQUFnQkMsSUFBR0M7SUFDckIsSUFBSSxlQUFHLFdBRFdELElBQUdDLEtBQ2pCOzs7O1NBQTRCQztLQUFXLHdCQUFZLG1DQUF2QkE7O0dBQTBDO1lBRXhFQztJQUFlLHVCQUFZQyxjQUFLLE9BQUxBO1FBQXFCQztJQUFNLE9BQUEsc0JBQU5BO0dBQWdCO1lBRWhFQztJQUFrQjs7T0FDVDs7T0FDSTs7T0FDTDs7T0FDQzs7T0FDRDs7T0FDUTtlQUNOOztHQUFRO1lBRWxCQyxnQkFRQUM7SUFSa0Is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QUNBQztRQWlkSXNEO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDOztTQVdFRTtTQUVBRTtTQURBRDtTQUdBRTtTQW9CQUk7U0FJQUM7U0FkQUY7U0EwQ0FjO1NBS0FDO1NBUEFGO1NBTEFGO1NBRUFDO1NBWUE3SDtTQUlBaUk7U0FHQUM7U0FDQUM7U0FFQUU7U0FEQUQ7U0FFQUU7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FHQUU7U0FGQUQ7U0FDQXhMO1NBSUEwTDtTQUdBQztTQUlBQztTQWVBQztTQS9HQXRDO1FBb0lGdUM7UUEwQkFDO1FBY0FJO1FBQ0FDO1FBQ0FDO1FBMXFCSi9JOzs7T0Erc0JFc0o7T0FFQUM7T0FJQUM7T0FvQkFLO09BTUFDO09BeEJBTDtPQTBCQU07T0FjQUM7T0FNQUM7T0FDQUM7T0FLQUc7T0FNQUM7T0FUQUY7T0FVQUc7T0FDQUM7T0FDQUM7T0FFQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FRQUM7T0FJQUU7O1FBZ0VFWTtRQUlBQztRQWdCQUk7UUEvQ0FkO1FBTUFDO1FBeEJBRjtRQTZCQUk7UUFLQUM7UUFSQUY7UUFTQUc7UUFDQUM7UUFFQUM7UUFHQUM7UUFZQUc7UUFJQUM7UUFJQUM7UUFNQUU7UUFJQUM7UUFJQUM7UUFJQUM7UUF0RkFwQjtPQWxJRmhDOzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IERhdmlkIFNoZWV0cyA8c2hlZXRzQGFsdW0ubWl0LmVkdT5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqKVxuXG5leGNlcHRpb24gUGFyc2VfZXJyb3Igb2Ygc3RyaW5nICogc3RyaW5nXG5cbnR5cGUgc2NvcGUgPSBQb2ludCB8IEludGVyZmFjZSB8IExpbmsgfCBBZG1pbiB8IFNpdGUgfCBPcmdhbml6YXRpb24gfCBHbG9iYWxcblxubGV0IHRyeV93aXRoX3Jlc3VsdCBmbiBhID1cbiAgdHJ5IE9rIChmbiBhKSB3aXRoIFBhcnNlX2Vycm9yIChtc2csIF8pIC0+IEVycm9yIChgTXNnIChcIklwYWRkcjogXCIgXiBtc2cpKVxuXG5sZXQgZmFpbHdpdGhfbXNnID0gZnVuY3Rpb24gT2sgeCAtPiB4IHwgRXJyb3IgKGBNc2cgbSkgLT4gZmFpbHdpdGggbVxuXG5sZXQgc3RyaW5nX29mX3Njb3BlID0gZnVuY3Rpb25cbiAgfCBQb2ludCAtPiBcInBvaW50XCJcbiAgfCBJbnRlcmZhY2UgLT4gXCJpbnRlcmZhY2VcIlxuICB8IExpbmsgLT4gXCJsaW5rXCJcbiAgfCBBZG1pbiAtPiBcImFkbWluXCJcbiAgfCBTaXRlIC0+IFwic2l0ZVwiXG4gIHwgT3JnYW5pemF0aW9uIC0+IFwib3JnYW5pemF0aW9uXCJcbiAgfCBHbG9iYWwgLT4gXCJnbG9iYWxcIlxuXG5sZXQgc2NvcGVfb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBcInBvaW50XCIgLT4gT2sgUG9pbnRcbiAgfCBcImludGVyZmFjZVwiIC0+IE9rIEludGVyZmFjZVxuICB8IFwibGlua1wiIC0+IE9rIExpbmtcbiAgfCBcImFkbWluXCIgLT4gT2sgQWRtaW5cbiAgfCBcInNpdGVcIiAtPiBPayBTaXRlXG4gIHwgXCJvcmdhbml6YXRpb25cIiAtPiBPayBPcmdhbml6YXRpb25cbiAgfCBcImdsb2JhbFwiIC0+IE9rIEdsb2JhbFxuICB8IHMgLT4gRXJyb3IgKGBNc2cgKFwidW5rbm93biBzY29wZTogXCIgXiBzKSlcblxubGV0IHBwX3Njb3BlIGZtdCBzID0gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgKHN0cmluZ19vZl9zY29wZSBzKVxubGV0ICggfnwgKSA9IEludDMyLm9mX2ludFxubGV0ICggfH4gKSA9IEludDMyLnRvX2ludFxubGV0ICggJiYmICkgeCB5ID0gSW50MzIubG9nYW5kIHggeVxubGV0ICggfHx8ICkgeCB5ID0gSW50MzIubG9nb3IgeCB5XG5sZXQgKCA8fDwgKSB4IHkgPSBJbnQzMi5zaGlmdF9sZWZ0IHggeVxubGV0ICggPnw+ICkgeCB5ID0gSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbCB4IHlcbmxldCAoID4hICkgeCB5ID0geCA+fD4geSAmJiYgMHhGRl9sXG5sZXQgKCA8ISApIHggeSA9IHggJiYmIDB4RkZfbCA8fDwgeVxubGV0IG5lZWRfbW9yZSB4ID0gUGFyc2VfZXJyb3IgKFwibm90IGVub3VnaCBkYXRhXCIsIHgpXG5sZXQgY2hhcl8wID0gaW50X29mX2NoYXIgJzAnXG5sZXQgY2hhcl9hID0gaW50X29mX2NoYXIgJ2EnXG5sZXQgY2hhcl9BID0gaW50X29mX2NoYXIgJ0EnXG5cbmxldCBpbnRfb2ZfY2hhciBjID1cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyAtPiBTdGRsaWIuaW50X29mX2NoYXIgYyAtIGNoYXJfMFxuICB8ICdhJyAuLiAnZicgLT4gMTAgKyBTdGRsaWIuaW50X29mX2NoYXIgYyAtIGNoYXJfYVxuICB8ICdBJyAuLiAnRicgLT4gMTAgKyBTdGRsaWIuaW50X29mX2NoYXIgYyAtIGNoYXJfQVxuICB8IF8gLT4gLTFcblxubGV0IGJhZF9jaGFyIGkgcyA9XG4gIGxldCBtc2cgPSBQcmludGYuc3ByaW50ZiBcImludmFsaWQgY2hhcmFjdGVyICclYycgYXQgJWRcIiBzLltpXSBpIGluXG4gIFBhcnNlX2Vycm9yIChtc2csIHMpXG5cbmxldCBvY3RhbF9ub3RhdGlvbiBzID1cbiAgbGV0IG1zZyA9IFByaW50Zi5zcHJpbnRmIFwib2N0YWwgbm90YXRpb24gZGlzYWxsb3dlZFwiIGluXG4gIFBhcnNlX2Vycm9yIChtc2csIHMpXG5cbmxldCBpc19udW1iZXIgYmFzZSBuID0gbiA+PSAwICYmIG4gPCBiYXNlXG5cbmxldCBwYXJzZV9pbnQgYmFzZSBzIGkgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbmV4dCBwcmV2ID1cbiAgICBsZXQgaiA9ICFpIGluXG4gICAgaWYgaiA+PSBsZW4gdGhlbiBwcmV2XG4gICAgZWxzZVxuICAgICAgbGV0IGMgPSBzLltqXSBpblxuICAgICAgbGV0IGsgPSBpbnRfb2ZfY2hhciBjIGluXG4gICAgICBpZiBpc19udW1iZXIgYmFzZSBrIHRoZW4gKFxuICAgICAgICBpbmNyIGk7XG4gICAgICAgIG5leHQgKChwcmV2ICogYmFzZSkgKyBrKSlcbiAgICAgIGVsc2UgcHJldlxuICBpblxuICBsZXQgaSA9ICFpIGluXG4gIGlmIGkgPCBsZW4gdGhlblxuICAgIGlmIGlzX251bWJlciBiYXNlIChpbnRfb2ZfY2hhciBzLltpXSkgdGhlbiBuZXh0IDAgZWxzZSByYWlzZSAoYmFkX2NoYXIgaSBzKVxuICBlbHNlIHJhaXNlIChuZWVkX21vcmUgcylcblxubGV0IHBhcnNlX2RlY19pbnQgcyBpID0gcGFyc2VfaW50IDEwIHMgaVxubGV0IHBhcnNlX2hleF9pbnQgcyBpID0gcGFyc2VfaW50IDE2IHMgaVxuXG5sZXQgZXhwZWN0X2NoYXIgcyBpIGMgPVxuICBpZiAhaSA8IFN0cmluZy5sZW5ndGggcyB0aGVuXG4gICAgaWYgcy5bIWldIDw+IGMgdGhlbiByYWlzZSAoYmFkX2NoYXIgIWkgcykgZWxzZSBpbmNyIGlcbiAgZWxzZSByYWlzZSAobmVlZF9tb3JlIHMpXG5cbmxldCBleHBlY3RfZW5kIHMgaSA9IGlmIFN0cmluZy5sZW5ndGggcyA8PSAhaSB0aGVuICgpIGVsc2UgcmFpc2UgKGJhZF9jaGFyICFpIHMpXG5cbmxldCByZWplY3Rfb2N0YWwgcyBpID1cbiAgaWYgIWkgKyAxIDwgU3RyaW5nLmxlbmd0aCBzIHRoZW5cbiAgICBpZiBzLlshaV0gPT0gJzAnICYmIGlzX251bWJlciAxMCAoaW50X29mX2NoYXIgcy5bIWkgKyAxXSkgdGhlblxuICAgICAgcmFpc2UgKG9jdGFsX25vdGF0aW9uIHMpXG5cbm1vZHVsZSBWNCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQzMlxuXG4gIGxldCBjb21wYXJlID0gSW50MzIudW5zaWduZWRfY29tcGFyZVxuICBsZXQgbWFrZSBhIGIgYyBkID0gfnxhIDwhIDI0IHx8fCAofnxiIDwhIDE2KSB8fHwgKH58YyA8ISA4IHx8fCAofnxkIDwhIDApKVxuXG4gICgqIHBhcnNpbmcgKilcblxuICBsZXQgcGFyc2VfZG90dGVkX3F1YWQgcyBpID1cbiAgICByZWplY3Rfb2N0YWwgcyBpO1xuICAgIGxldCBhID0gcGFyc2VfZGVjX2ludCBzIGkgaW5cbiAgICBleHBlY3RfY2hhciBzIGkgJy4nO1xuICAgIHJlamVjdF9vY3RhbCBzIGk7XG4gICAgbGV0IGIgPSBwYXJzZV9kZWNfaW50IHMgaSBpblxuICAgIGV4cGVjdF9jaGFyIHMgaSAnLic7XG4gICAgcmVqZWN0X29jdGFsIHMgaTtcbiAgICBsZXQgYyA9IHBhcnNlX2RlY19pbnQgcyBpIGluXG4gICAgZXhwZWN0X2NoYXIgcyBpICcuJztcbiAgICByZWplY3Rfb2N0YWwgcyBpO1xuICAgIGxldCBkID0gcGFyc2VfZGVjX2ludCBzIGkgaW5cbiAgICBsZXQgdmFsaWQgYSA9IGEgbGFuZCAweGZmIDw+IGEgaW5cbiAgICBpZiB2YWxpZCBhIHRoZW4gcmFpc2UgKFBhcnNlX2Vycm9yIChcImZpcnN0IG9jdGV0IG91dCBvZiBib3VuZHNcIiwgcykpXG4gICAgZWxzZSBpZiB2YWxpZCBiIHRoZW4gcmFpc2UgKFBhcnNlX2Vycm9yIChcInNlY29uZCBvY3RldCBvdXQgb2YgYm91bmRzXCIsIHMpKVxuICAgIGVsc2UgaWYgdmFsaWQgYyB0aGVuIHJhaXNlIChQYXJzZV9lcnJvciAoXCJ0aGlyZCBvY3RldCBvdXQgb2YgYm91bmRzXCIsIHMpKVxuICAgIGVsc2UgaWYgdmFsaWQgZCB0aGVuIHJhaXNlIChQYXJzZV9lcnJvciAoXCJmb3VydGggb2N0ZXQgb3V0IG9mIGJvdW5kc1wiLCBzKSlcbiAgICBlbHNlIG1ha2UgYSBiIGMgZFxuXG4gICgqIHN0cmluZyBjb252ZXJzaW9uICopXG5cbiAgbGV0IG9mX3N0cmluZ19yYXcgPSBwYXJzZV9kb3R0ZWRfcXVhZFxuXG4gIGxldCBvZl9zdHJpbmdfZXhuIHMgPVxuICAgIGxldCBvID0gcmVmIDAgaW5cbiAgICBsZXQgeCA9IG9mX3N0cmluZ19yYXcgcyBvIGluXG4gICAgZXhwZWN0X2VuZCBzIG87XG4gICAgeFxuXG4gIGxldCBvZl9zdHJpbmcgcyA9IHRyeV93aXRoX3Jlc3VsdCBvZl9zdHJpbmdfZXhuIHNcblxuICBsZXQgd2l0aF9wb3J0X29mX3N0cmluZyB+ZGVmYXVsdCBzID1cbiAgICB0cnlcbiAgICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgYW5kIG8gPSByZWYgMCBpblxuICAgICAgbGV0IGlwdjQgPSBvZl9zdHJpbmdfcmF3IHMgbyBpblxuICAgICAgaWYgIW8gPCBsZW4gJiYgcy5bIW9dID0gJzonIHRoZW4gKFxuICAgICAgICBpbmNyIG87XG4gICAgICAgIGxldCBwb3J0ID0gcGFyc2VfZGVjX2ludCBzIG8gaW5cbiAgICAgICAgZXhwZWN0X2VuZCBzIG87XG4gICAgICAgIE9rIChpcHY0LCBwb3J0KSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBleHBlY3RfZW5kIHMgbztcbiAgICAgICAgT2sgKGlwdjQsIGRlZmF1bHQpKVxuICAgIHdpdGggUGFyc2VfZXJyb3IgKG1zZywgXykgLT4gRXJyb3IgKGBNc2cgKFwiSXBhZGRyOiBcIiBeIG1zZykpXG5cbiAgbGV0IHRvX2J1ZmZlciBiIGkgPVxuICAgIFByaW50Zi5icHJpbnRmIGIgXCIlbGQuJWxkLiVsZC4lbGRcIiAoaSA+ISAyNCkgKGkgPiEgMTYpIChpID4hIDgpIChpID4hIDApXG5cbiAgbGV0IHRvX3N0cmluZyBpID1cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTUgaW5cbiAgICB0b19idWZmZXIgYiBpO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG5cbiAgbGV0IHBwIHBwZiBpID0gRm9ybWF0LmZwcmludGYgcHBmIFwiJXNcIiAodG9fc3RyaW5nIGkpXG5cbiAgKCogT2N0ZXRzIGNvbnZlcnNpb24gKilcblxuICBsZXQgb2Zfb2N0ZXRzX2V4biA/KG9mZiA9IDApIGJzID1cbiAgICB0cnlcbiAgICAgIG1ha2VcbiAgICAgICAgKENoYXIuY29kZSBicy5bMCArIG9mZl0pXG4gICAgICAgIChDaGFyLmNvZGUgYnMuWzEgKyBvZmZdKVxuICAgICAgICAoQ2hhci5jb2RlIGJzLlsyICsgb2ZmXSlcbiAgICAgICAgKENoYXIuY29kZSBicy5bMyArIG9mZl0pXG4gICAgd2l0aCBfIC0+IHJhaXNlIChuZWVkX21vcmUgYnMpXG5cbiAgbGV0IG9mX29jdGV0cyA/b2ZmIGJzID0gdHJ5X3dpdGhfcmVzdWx0IChvZl9vY3RldHNfZXhuID9vZmYpIGJzXG5cbiAgbGV0IHdyaXRlX29jdGV0c19leG4gPyhvZmYgPSAwKSBpIGIgPVxuICAgIHRyeVxuICAgICAgQnl0ZXMuc2V0IGIgKDAgKyBvZmYpIChDaGFyLmNociAoKCB8fiApIChpID4hIDI0KSkpO1xuICAgICAgQnl0ZXMuc2V0IGIgKDEgKyBvZmYpIChDaGFyLmNociAoKCB8fiApIChpID4hIDE2KSkpO1xuICAgICAgQnl0ZXMuc2V0IGIgKDIgKyBvZmYpIChDaGFyLmNociAoKCB8fiApIChpID4hIDgpKSk7XG4gICAgICBCeXRlcy5zZXQgYiAoMyArIG9mZikgKENoYXIuY2hyICgoIHx+ICkgKGkgPiEgMCkpKVxuICAgIHdpdGggXyAtPiByYWlzZSAobmVlZF9tb3JlIChCeXRlcy50b19zdHJpbmcgYikpXG5cbiAgbGV0IHdyaXRlX29jdGV0cyA/b2ZmIGkgYnMgPSB0cnlfd2l0aF9yZXN1bHQgKHdyaXRlX29jdGV0c19leG4gP29mZiBpKSBic1xuXG4gIGxldCB0b19vY3RldHMgaSA9XG4gICAgU3RyaW5nLmluaXQgNCAoZnVuY3Rpb25cbiAgICAgIHwgMCAtPiBDaGFyLmNociAoKCB8fiApIChpID4hIDI0KSlcbiAgICAgIHwgMSAtPiBDaGFyLmNociAoKCB8fiApIChpID4hIDE2KSlcbiAgICAgIHwgMiAtPiBDaGFyLmNociAoKCB8fiApIChpID4hIDgpKVxuICAgICAgfCAzIC0+IENoYXIuY2hyICgoIHx+ICkgKGkgPiEgMCkpXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuXG4gICgqIEludDMyICopXG4gIGxldCBvZl9pbnQzMiBpID0gaVxuICBsZXQgdG9faW50MzIgaSA9IGlcblxuICAoKiBJbnQxNiAqKVxuICBsZXQgb2ZfaW50MTYgKGEsIGIpID0gfnxhIDx8PCAxNiB8fHwgfnxiXG4gIGxldCB0b19pbnQxNiBhID0gKCggfH4gKSAoYSA+fD4gMTYpLCAoIHx+ICkgKGEgJiYmIDB4RkZfRkZfbCkpXG5cbiAgKCogTUFDICopXG4gICgqIHt7Omh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExMTIjc2VjdGlvbi02LjJ9UkZDIDExMTJ9LiAqKVxuICBsZXQgbXVsdGljYXN0X3RvX21hYyBpID1cbiAgICBsZXQgbWFjYiA9IEJ5dGVzLmNyZWF0ZSA2IGluXG4gICAgQnl0ZXMuc2V0IG1hY2IgMCAoQ2hhci5jaHIgMHgwMSk7XG4gICAgQnl0ZXMuc2V0IG1hY2IgMSAoQ2hhci5jaHIgMHgwMCk7XG4gICAgQnl0ZXMuc2V0IG1hY2IgMiAoQ2hhci5jaHIgMHg1RSk7XG4gICAgQnl0ZXMuc2V0IG1hY2IgMyAoQ2hhci5jaHIgKCggfH4gKSAoaSA+fD4gMTYgJiYmIDB4N0ZfbCkpKTtcbiAgICBCeXRlcy5zZXQgbWFjYiA0IChDaGFyLmNociAoKCB8fiApIChpID4hIDgpKSk7XG4gICAgQnl0ZXMuc2V0IG1hY2IgNSAoQ2hhci5jaHIgKCggfH4gKSAoaSA+ISAwKSkpO1xuICAgIE1hY2FkZHIub2Zfb2N0ZXRzX2V4biAoQnl0ZXMudG9fc3RyaW5nIG1hY2IpXG5cbiAgKCogSG9zdCAqKVxuICBsZXQgdG9fZG9tYWluX25hbWUgaSA9XG4gICAgbGV0IG5hbWUgPVxuICAgICAgW1xuICAgICAgICBJbnQzMi50b19zdHJpbmcgKGkgPiEgMCk7XG4gICAgICAgIEludDMyLnRvX3N0cmluZyAoaSA+ISA4KTtcbiAgICAgICAgSW50MzIudG9fc3RyaW5nIChpID4hIDE2KTtcbiAgICAgICAgSW50MzIudG9fc3RyaW5nIChpID4hIDI0KTtcbiAgICAgICAgXCJpbi1hZGRyXCI7XG4gICAgICAgIFwiYXJwYVwiO1xuICAgICAgXVxuICAgIGluXG4gICAgRG9tYWluX25hbWUuKGhvc3RfZXhuIChvZl9zdHJpbmdzX2V4biBuYW1lKSlcblxuICBsZXQgb2ZfZG9tYWluX25hbWUgbiA9XG4gICAgbWF0Y2ggRG9tYWluX25hbWUudG9fc3RyaW5ncyBuIHdpdGhcbiAgICB8IFsgYTsgYjsgYzsgZDsgaW5fYWRkcjsgYXJwYSBdXG4gICAgICB3aGVuIERvbWFpbl9uYW1lLihcbiAgICAgICAgICAgICBlcXVhbF9sYWJlbCBhcnBhIFwiYXJwYVwiICYmIGVxdWFsX2xhYmVsIGluX2FkZHIgXCJpbi1hZGRyXCIpIC0+IChcbiAgICAgICAgbGV0IGNvbnYgYml0cyBkYXRhID1cbiAgICAgICAgICBsZXQgaSA9IEludDMyLm9mX2ludCAocGFyc2VfZGVjX2ludCBkYXRhIChyZWYgMCkpIGluXG4gICAgICAgICAgaWYgaSA+IDB4RkZsIHRoZW5cbiAgICAgICAgICAgIHJhaXNlIChQYXJzZV9lcnJvciAoXCJsYWJlbCB3aXRoIGEgdG9vIGJpZyBudW1iZXJcIiwgZGF0YSkpXG4gICAgICAgICAgZWxzZSBpIDwhIGJpdHNcbiAgICAgICAgaW5cbiAgICAgICAgdHJ5XG4gICAgICAgICAgbGV0ICggKyApID0gSW50MzIuYWRkIGluXG4gICAgICAgICAgU29tZSAoY29udiAwIGEgKyBjb252IDggYiArIGNvbnYgMTYgYyArIGNvbnYgMjQgZClcbiAgICAgICAgd2l0aCBQYXJzZV9lcnJvciBfIC0+IE5vbmUpXG4gICAgfCBfIC0+IE5vbmVcblxuICBsZXQgc3VjYyB0ID1cbiAgICBpZiBJbnQzMi5lcXVhbCB0IDB4RkZfRkZfRkZfRkZsIHRoZW5cbiAgICAgIEVycm9yIChgTXNnIFwiSXBhZGRyOiBoaWdoZXN0IGFkZHJlc3MgaGFzIGJlZW4gcmVhY2hlZFwiKVxuICAgIGVsc2UgT2sgKEludDMyLnN1Y2MgdClcblxuICBsZXQgcHJlZCB0ID1cbiAgICBpZiBJbnQzMi5lcXVhbCB0IDB4MDBfMDBfMDBfMDBsIHRoZW5cbiAgICAgIEVycm9yIChgTXNnIFwiSXBhZGRyOiBsb3dlc3QgYWRkcmVzcyBoYXMgYmVlbiByZWFjaGVkXCIpXG4gICAgZWxzZSBPayAoSW50MzIucHJlZCB0KVxuXG4gICgqIGNvbnN0YW50ICopXG5cbiAgbGV0IGFueSA9IG1ha2UgMCAwIDAgMFxuICBsZXQgdW5zcGVjaWZpZWQgPSBtYWtlIDAgMCAwIDBcbiAgbGV0IGJyb2FkY2FzdCA9IG1ha2UgMjU1IDI1NSAyNTUgMjU1XG4gIGxldCBsb2NhbGhvc3QgPSBtYWtlIDEyNyAwIDAgMVxuICBsZXQgbm9kZXMgPSBtYWtlIDIyNCAwIDAgMVxuICBsZXQgcm91dGVycyA9IG1ha2UgMjI0IDAgMCAyXG5cbiAgbW9kdWxlIFByZWZpeCA9IHN0cnVjdFxuICAgIHR5cGUgYWRkciA9IHRcbiAgICB0eXBlIHQgPSBhZGRyICogaW50XG5cbiAgICBsZXQgY29tcGFyZSAocHJlLCBzeikgKHByZScsIHN6JykgPVxuICAgICAgbGV0IGMgPSBjb21wYXJlIHByZSBwcmUnIGluXG4gICAgICBpZiBjID0gMCB0aGVuIFN0ZGxpYi5jb21wYXJlIHN6IHN6JyBlbHNlIGNcblxuICAgIGxldCBpcCA9IG1ha2VcblxuICAgIGxldCBtYXNrIHN6ID1cbiAgICAgIGlmIHN6IDw9IDAgdGhlbiAwX2xcbiAgICAgIGVsc2UgaWYgc3ogPj0gMzIgdGhlbiAweDBfRkZfRkZfRkZfRkZfbFxuICAgICAgZWxzZSAweDBfRkZfRkZfRkZfRkZfbCA8fDwgMzIgLSBzelxuXG4gICAgbGV0IHByZWZpeCAocHJlLCBzeikgPSAocHJlICYmJiBtYXNrIHN6LCBzeilcbiAgICBsZXQgbWFrZSBzeiBwcmUgPSAocHJlLCBzeilcblxuICAgIGxldCBuZXR3b3JrX2FkZHJlc3MgKHByZSwgc3opIGFkZHIgPVxuICAgICAgcHJlICYmJiBtYXNrIHN6IHx8fCAoYWRkciAmJiYgSW50MzIubG9nbm90IChtYXNrIHN6KSlcblxuICAgICgqIHN0cmluZyBjb252ZXJzaW9uICopXG5cbiAgICBsZXQgX29mX3N0cmluZ19yYXcgcyBpID1cbiAgICAgIGxldCBxdWFkID0gb2Zfc3RyaW5nX3JhdyBzIGkgaW5cbiAgICAgIGV4cGVjdF9jaGFyIHMgaSAnLyc7XG4gICAgICBsZXQgcCA9IHBhcnNlX2RlY19pbnQgcyBpIGluXG4gICAgICBpZiBwID4gMzIgfHwgcCA8IDAgdGhlbiByYWlzZSAoUGFyc2VfZXJyb3IgKFwiaW52YWxpZCBwcmVmaXggc2l6ZVwiLCBzKSk7XG4gICAgICAocCwgcXVhZClcblxuICAgIGxldCBvZl9zdHJpbmdfcmF3IHMgaSA9XG4gICAgICBsZXQgcCwgcXVhZCA9IF9vZl9zdHJpbmdfcmF3IHMgaSBpblxuICAgICAgbWFrZSBwIHF1YWRcblxuICAgIGxldCBfb2Zfc3RyaW5nX2V4biBzID1cbiAgICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICAgIGxldCByZXMgPSBfb2Zfc3RyaW5nX3JhdyBzIGkgaW5cbiAgICAgIGV4cGVjdF9lbmQgcyBpO1xuICAgICAgcmVzXG5cbiAgICBsZXQgb2Zfc3RyaW5nX2V4biBzID1cbiAgICAgIGxldCBwLCBxdWFkID0gX29mX3N0cmluZ19leG4gcyBpblxuICAgICAgbWFrZSBwIHF1YWRcblxuICAgIGxldCBvZl9zdHJpbmcgcyA9IHRyeV93aXRoX3Jlc3VsdCBvZl9zdHJpbmdfZXhuIHNcblxuICAgIGxldCBfb2ZfbmV0bWFza19leG4gfm5ldG1hc2sgYWRkcmVzcyA9XG4gICAgICBsZXQgcmVjIGZpbmRfZ3JlYXRlc3Rfb25lIGJpdHMgaSA9XG4gICAgICAgIGlmIGJpdHMgPSAwX2wgdGhlbiBpIC0gMSBlbHNlIGZpbmRfZ3JlYXRlc3Rfb25lIChiaXRzID58PiAxKSAoaSArIDEpXG4gICAgICBpblxuICAgICAgbGV0IG9uZSA9IG5ldG1hc2sgJiYmIEludDMyLm5lZyBuZXRtYXNrIGluXG4gICAgICBsZXQgc3ogPSAzMiAtIGZpbmRfZ3JlYXRlc3Rfb25lIG9uZSAoaWYgb25lID0gMF9sIHRoZW4gMzMgZWxzZSAwKSBpblxuICAgICAgaWYgbmV0bWFzayA8PiBtYXNrIHN6IHRoZW5cbiAgICAgICAgcmFpc2UgKFBhcnNlX2Vycm9yIChcImludmFsaWQgbmV0bWFza1wiLCB0b19zdHJpbmcgbmV0bWFzaykpXG4gICAgICBlbHNlIG1ha2Ugc3ogYWRkcmVzc1xuXG4gICAgbGV0IG9mX25ldG1hc2tfZXhuIH5uZXRtYXNrIH5hZGRyZXNzID0gX29mX25ldG1hc2tfZXhuIH5uZXRtYXNrIGFkZHJlc3NcblxuICAgIGxldCBvZl9uZXRtYXNrIH5uZXRtYXNrIH5hZGRyZXNzID1cbiAgICAgIHRyeV93aXRoX3Jlc3VsdCAoX29mX25ldG1hc2tfZXhuIH5uZXRtYXNrKSBhZGRyZXNzXG5cbiAgICBsZXQgdG9fYnVmZmVyIGJ1ZiAocHJlLCBzeikgPSBQcmludGYuYnByaW50ZiBidWYgXCIlYS8lZFwiIHRvX2J1ZmZlciBwcmUgc3pcblxuICAgIGxldCB0b19zdHJpbmcgc3VibmV0ID1cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxOCBpblxuICAgICAgdG9fYnVmZmVyIGIgc3VibmV0O1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxuICAgIGxldCBwcCBwcGYgaSA9IEZvcm1hdC5mcHJpbnRmIHBwZiBcIiVzXCIgKHRvX3N0cmluZyBpKVxuXG4gICAgbGV0IG1lbSBpcCAocHJlLCBzeikgPVxuICAgICAgbGV0IG0gPSBtYXNrIHN6IGluXG4gICAgICBpcCAmJiYgbSA9IChwcmUgJiYmIG0pXG5cbiAgICBsZXQgc3Vic2V0IH5zdWJuZXQ6KHByZTEsIHN6MSkgfm5ldHdvcms6KHByZTIsIHN6MikgPVxuICAgICAgc3oxID49IHN6MiAmJiBtZW0gcHJlMSAocHJlMiwgc3oyKVxuXG4gICAgbGV0IG9mX2FkZHIgaXAgPSBtYWtlIDMyIGlwXG4gICAgbGV0IGdsb2JhbCA9IG1ha2UgMCAoaXAgMCAwIDAgMClcbiAgICBsZXQgcmVsYXRpdmUgPSBtYWtlIDggKGlwIDAgMCAwIDApXG4gICAgbGV0IGxvb3BiYWNrID0gbWFrZSA4IChpcCAxMjcgMCAwIDApXG4gICAgbGV0IGxpbmsgPSBtYWtlIDE2IChpcCAxNjkgMjU0IDAgMClcbiAgICBsZXQgbXVsdGljYXN0ID0gbWFrZSA0IChpcCAyMjQgMCAwIDApXG4gICAgbGV0IG11bHRpY2FzdF9vcmcgPSBtYWtlIDE0IChpcCAyMzkgMTkyIDAgMClcbiAgICBsZXQgbXVsdGljYXN0X2FkbWluID0gbWFrZSAxNiAoaXAgMjM5IDI1NSAwIDApXG4gICAgbGV0IG11bHRpY2FzdF9saW5rID0gbWFrZSAyNCAoaXAgMjI0IDAgMCAwKVxuXG4gICAgKCogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjM2NSAqKVxuXG4gICAgbGV0IHByaXZhdGVfMTAgPSBtYWtlIDggKGlwIDEwIDAgMCAwKVxuICAgIGxldCBwcml2YXRlXzE3MiA9IG1ha2UgMTIgKGlwIDE3MiAxNiAwIDApXG4gICAgbGV0IHByaXZhdGVfMTkyID0gbWFrZSAxNiAoaXAgMTkyIDE2OCAwIDApXG5cbiAgICBsZXQgcHJpdmF0ZV9ibG9ja3MgPVxuICAgICAgWyBsb29wYmFjazsgbGluazsgcHJpdmF0ZV8xMDsgcHJpdmF0ZV8xNzI7IHByaXZhdGVfMTkyIF1cblxuICAgIGxldCBicm9hZGNhc3QgKHByZSwgc3opID1cbiAgICAgIEludDMyLmxvZ29yIHByZSAoSW50MzIubG9neG9yIChtYXNrIHN6KSAweEZGX0ZGX0ZGX0ZGbClcblxuICAgIGxldCBuZXR3b3JrIChwcmUsIHN6KSA9IHByZSAmJiYgbWFzayBzelxuICAgIGxldCBhZGRyZXNzIChhZGRyLCBfKSA9IGFkZHJcbiAgICBsZXQgYml0cyAoXywgc3opID0gc3pcbiAgICBsZXQgbmV0bWFzayBzdWJuZXQgPSBtYXNrIChiaXRzIHN1Ym5ldClcbiAgICBsZXQgaG9zdG1hc2sgY2lkciA9IEludDMyLmxvZ3hvciAobmV0bWFzayBjaWRyKSAweEZGX0ZGX0ZGX0ZGbFxuXG4gICAgbGV0IGZpcnN0ICgoXywgc3opIGFzIGNpZHIpID1cbiAgICAgIGlmIHN6ID4gMzAgdGhlbiBuZXR3b3JrIGNpZHIgZWxzZSBuZXR3b3JrIGNpZHIgfD4gc3VjYyB8PiBmYWlsd2l0aF9tc2dcblxuICAgIGxldCBsYXN0ICgoXywgc3opIGFzIGNpZHIpID1cbiAgICAgIGlmIHN6ID4gMzAgdGhlbiBicm9hZGNhc3QgY2lkciBlbHNlIGJyb2FkY2FzdCBjaWRyIHw+IHByZWQgfD4gZmFpbHdpdGhfbXNnXG5cbiAgICBsZXQgaG9zdHMgPyh1c2FibGUgPSB0cnVlKSAoKF8sIHN6KSBhcyBjaWRyKSA9XG4gICAgICBsZXQgcmVjIGl0ZXJfc2VxIHN0YXJ0IHN0b3AgPVxuICAgICAgICBpZiBjb21wYXJlIChzdGFydCwgMzIpIChzdG9wLCAzMikgPiAwIHRoZW4gU2VxLk5pbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggc3VjYyBzdGFydCB3aXRoXG4gICAgICAgICAgfCBPayBzdGFydF9zdWNjIC0+IFNlcS5Db25zIChzdGFydCwgZnVuICgpIC0+IGl0ZXJfc2VxIHN0YXJ0X3N1Y2Mgc3RvcClcbiAgICAgICAgICB8IEVycm9yIF8gLT4gU2VxLkNvbnMgKHN0YXJ0LCBmdW4gKCkgLT4gU2VxLk5pbClcbiAgICAgIGluXG4gICAgICBpZiB1c2FibGUgJiYgc3ogPSAzMiB0aGVuIGZ1biAoKSAtPiBTZXEuTmlsXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzdGFydCwgc3RvcCA9XG4gICAgICAgICAgaWYgdXNhYmxlIHRoZW4gKGZpcnN0IGNpZHIsIGxhc3QgY2lkcilcbiAgICAgICAgICBlbHNlIChuZXR3b3JrIGNpZHIsIGJyb2FkY2FzdCBjaWRyKVxuICAgICAgICBpblxuICAgICAgICBmdW4gKCkgLT4gaXRlcl9zZXEgc3RhcnQgc3RvcFxuXG4gICAgbGV0IHN1Ym5ldHMgbiAoKF8sIHN6KSBhcyBjaWRyKSA9XG4gICAgICBsZXQgcmVjIGl0ZXJfc2VxIHN0YXJ0IHN0b3Agc3RlcHMgPVxuICAgICAgICBpZiBjb21wYXJlIChzdGFydCwgMzIpIChzdG9wLCAzMikgPiAwIHRoZW4gU2VxLk5pbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHByZWZpeCA9IG1ha2UgbiBzdGFydCBpblxuICAgICAgICAgIGxldCBzdGFydF9zdWNjID0gSW50MzIuYWRkIHN0YXJ0IHN0ZXBzIGluXG4gICAgICAgICAgaWYgc3RhcnRfc3VjYyA9IDBsIHRoZW4gU2VxLkNvbnMgKHByZWZpeCwgZnVuICgpIC0+IFNlcS5OaWwpXG4gICAgICAgICAgZWxzZSBTZXEuQ29ucyAocHJlZml4LCBmdW4gKCkgLT4gaXRlcl9zZXEgc3RhcnRfc3VjYyBzdG9wIHN0ZXBzKVxuICAgICAgaW5cbiAgICAgIGlmIHN6ID4gbiB8fCBuID4gMzIgdGhlbiBmdW4gKCkgLT4gU2VxLk5pbFxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3RhcnQgPSBuZXR3b3JrIGNpZHIgaW5cbiAgICAgICAgbGV0IHN0b3AgPSBicm9hZGNhc3QgY2lkciBpblxuICAgICAgICBsZXQgc3RlcHMgPSBJbnQzMi5hZGQgKGhvc3RtYXNrIGNpZHIpIDFsID58PiBuIC0gc3ogaW5cbiAgICAgICAgZnVuICgpIC0+IGl0ZXJfc2VxIHN0YXJ0IHN0b3Agc3RlcHNcbiAgZW5kXG5cbiAgKCogVE9ETzogdGhpcyBjb3VsZCBiZSBvcHRpbWl6ZWQgd2l0aCBzb21ldGhpbmcgdHJpZS1saWtlICopXG4gIGxldCBzY29wZSBpID1cbiAgICBsZXQgbWVtID0gUHJlZml4Lm1lbSBpIGluXG4gICAgaWYgbWVtIFByZWZpeC5sb29wYmFjayB0aGVuIEludGVyZmFjZVxuICAgIGVsc2UgaWYgbWVtIFByZWZpeC5saW5rIHRoZW4gTGlua1xuICAgIGVsc2UgaWYgTGlzdC5leGlzdHMgbWVtIFByZWZpeC5wcml2YXRlX2Jsb2NrcyB0aGVuIE9yZ2FuaXphdGlvblxuICAgIGVsc2UgaWYgaSA9IHVuc3BlY2lmaWVkIHRoZW4gUG9pbnRcbiAgICBlbHNlIGlmIGkgPSBicm9hZGNhc3QgdGhlbiBBZG1pblxuICAgIGVsc2UgaWYgbWVtIFByZWZpeC5yZWxhdGl2ZSB0aGVuIEFkbWluXG4gICAgZWxzZSBpZiBtZW0gUHJlZml4Lm11bHRpY2FzdCB0aGVuXG4gICAgICBpZiBtZW0gUHJlZml4Lm11bHRpY2FzdF9vcmcgdGhlbiBPcmdhbml6YXRpb25cbiAgICAgIGVsc2UgaWYgbWVtIFByZWZpeC5tdWx0aWNhc3RfYWRtaW4gdGhlbiBBZG1pblxuICAgICAgZWxzZSBpZiBtZW0gUHJlZml4Lm11bHRpY2FzdF9saW5rIHRoZW4gTGlua1xuICAgICAgZWxzZSBHbG9iYWxcbiAgICBlbHNlIEdsb2JhbFxuXG4gIGxldCBpc19nbG9iYWwgaSA9IHNjb3BlIGkgPSBHbG9iYWxcbiAgbGV0IGlzX211bHRpY2FzdCBpID0gUHJlZml4LihtZW0gaSBtdWx0aWNhc3QpXG4gIGxldCBpc19wcml2YXRlIGkgPSBzY29wZSBpIDw+IEdsb2JhbFxuXG4gIG1vZHVsZSBTZXQgPSBTZXQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBjb21wYXJlIChhIDogdCkgKGIgOiB0KSA9IGNvbXBhcmUgYSBiXG4gIGVuZClcblxuICBtb2R1bGUgTWFwID0gTWFwLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgY29tcGFyZSAoYSA6IHQpIChiIDogdCkgPSBjb21wYXJlIGEgYlxuICBlbmQpXG5lbmRcblxubW9kdWxlIFMxMjggOiBzaWdcbiAgZXhjZXB0aW9uIE92ZXJmbG93XG5cbiAgdHlwZSB0XG5cbiAgdmFsIHplcm8gOiB0IFtAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbiAgdmFsIG1heF9pbnQgOiB0XG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICB2YWwgZm9sZF9sZWZ0IDogKCdhIC0+IGludCAtPiAnYSkgLT4gJ2EgLT4gdCAtPiAnYVxuICB2YWwgb2Zfb2N0ZXRzX2V4biA6IHN0cmluZyAtPiB0XG4gIHZhbCB0b19vY3RldHMgOiB0IC0+IHN0cmluZ1xuICB2YWwgb2ZfaW50NjQgOiBpbnQ2NCAqIGludDY0IC0+IHRcbiAgdmFsIHRvX2ludDY0IDogdCAtPiBpbnQ2NCAqIGludDY0XG4gIHZhbCBvZl9pbnQzMiA6IGludDMyICogaW50MzIgKiBpbnQzMiAqIGludDMyIC0+IHRcbiAgdmFsIHRvX2ludDMyIDogdCAtPiBpbnQzMiAqIGludDMyICogaW50MzIgKiBpbnQzMlxuICB2YWwgb2ZfaW50MTYgOiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgLT4gdFxuICB2YWwgdG9faW50MTYgOiB0IC0+IGludCAqIGludCAqIGludCAqIGludCAqIGludCAqIGludCAqIGludCAqIGludFxuICB2YWwgYWRkX2V4biA6IHQgLT4gdCAtPiB0IFtAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbiAgdmFsIHByZWRfZXhuIDogdCAtPiB0IFtAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbiAgdmFsIGFkZCA6IHQgLT4gdCAtPiB0IG9wdGlvblxuICB2YWwgbG9nYW5kIDogdCAtPiB0IC0+IHRcbiAgdmFsIGxvZ29yIDogdCAtPiB0IC0+IHRcbiAgdmFsIGxvZ3hvciA6IHQgLT4gdCAtPiB0XG4gIHZhbCBsb2dub3QgOiB0IC0+IHRcblxuICBtb2R1bGUgQnl0ZSA6IHNpZ1xuICAgIHZhbCBnZXRfbHNiaXRzIDogaW50IC0+IGludCAtPiBpbnQgW0BAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuICAgIHZhbCBnZXRfbXNiaXRzIDogaW50IC0+IGludCAtPiBpbnQgW0BAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuICAgIHZhbCBzZXRfbXNiaXRzIDogaW50IC0+IGludCAtPiBpbnQgLT4gaW50IFtAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbiAgICB2YWwgZm9sZF9sZWZ0IDogKCdhIC0+IGJvb2wgLT4gJ2EpIC0+ICdhIC0+IGludCAtPiAnYVxuICBlbmRcblxuICB2YWwgc2hpZnRfcmlnaHQgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBzaGlmdF9sZWZ0IDogdCAtPiBpbnQgLT4gdFxuICB2YWwgd3JpdGVfb2N0ZXRzX2V4biA6ID9vZmY6aW50IC0+IHQgLT4gYnl0ZXMgLT4gdW5pdFxuICB2YWwgc3VjY19leG4gOiB0IC0+IHRcbiAgdmFsIHN1Y2MgOiB0IC0+ICh0LCBbPiBgTXNnIG9mIHN0cmluZyBdKSByZXN1bHRcbiAgdmFsIHByZWQgOiB0IC0+ICh0LCBbPiBgTXNnIG9mIHN0cmluZyBdKSByZXN1bHRcbmVuZCA9IHN0cnVjdFxuICBleGNlcHRpb24gT3ZlcmZsb3dcblxuICB0eXBlIHQgPSBzdHJpbmdcblxuICBsZXQgbWtfemVybyAoKSA9IEJ5dGVzLm1ha2UgMTYgJ1xceDAwJ1xuICBsZXQgemVybyA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgKG1rX3plcm8gKCkpXG4gIGxldCBtYXhfaW50ID0gU3RyaW5nLm1ha2UgMTYgJ1xceGZmJ1xuICBsZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG4gIGxldCBlcXVhbCA9IFN0cmluZy5lcXVhbFxuXG4gIGxldCBmb2xkX2xlZnQgZiBpbml0IHMgPVxuICAgICgqIFdpdGggT0NhbWw+PTQuMTMuMDpcbiAgICAgICBbU3RyaW5nLmZvbGRfbGVmdCAoZnVuIGFjYyBjIC0+IGYgYWNjIChDaGFyLmNvZGUgYykpIGluaXQgc10gKilcbiAgICBsZXQgYSA9IHJlZiBpbml0IGluXG4gICAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgICBhIDo9IGYgIWEgKENoYXIuY29kZSAoU3RyaW5nLmdldCBzIGkpKVxuICAgIGRvbmU7XG4gICAgIWFcblxuICBsZXQgaXRlcmlfcmlnaHQyIGYgeCB5ID1cbiAgICBmb3IgaSA9IDE1IGRvd250byAwIGRvXG4gICAgICBsZXQgeCcgPSBDaGFyLmNvZGUgKFN0cmluZy5nZXQgeCBpKSBpblxuICAgICAgbGV0IHknID0gQ2hhci5jb2RlIChTdHJpbmcuZ2V0IHkgaSkgaW5cbiAgICAgIGYgaSB4JyB5J1xuICAgIGRvbmVcblxuICBsZXQgb2Zfb2N0ZXRzX2V4biBzID1cbiAgICBpZiBTdHJpbmcubGVuZ3RoIHMgPD4gMTYgdGhlbiBpbnZhbGlkX2FyZyBcIm5vdCAxNiBieXRlcyBsb25nXCI7XG4gICAgc1xuXG4gIGxldCB0b19vY3RldHMgPSBGdW4uaWRcblxuICBsZXQgb2ZfaW50NjQgKGEsIGIpID1cbiAgICBsZXQgYicgPSBta196ZXJvICgpIGluXG4gICAgQnl0ZXMuc2V0X2ludDY0X2JlIGInIDAgYTtcbiAgICBCeXRlcy5zZXRfaW50NjRfYmUgYicgOCBiO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYidcblxuICBsZXQgdG9faW50NjQgcyA9XG4gICAgKCogd2l0aCBPQ2FtbD49NC4xMywgdXNlIFN0cmluZy5nZXRfaW50NjRfYmUgKilcbiAgICBsZXQgYiA9IEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgcyBpblxuICAgIChCeXRlcy5nZXRfaW50NjRfYmUgYiAwLCBCeXRlcy5nZXRfaW50NjRfYmUgYiA4KVxuXG4gIGxldCBvZl9pbnQzMiAoYSwgYiwgYywgZCkgPVxuICAgIGxldCBiJyA9IG1rX3plcm8gKCkgaW5cbiAgICBCeXRlcy5zZXRfaW50MzJfYmUgYicgMCBhO1xuICAgIEJ5dGVzLnNldF9pbnQzMl9iZSBiJyA0IGI7XG4gICAgQnl0ZXMuc2V0X2ludDMyX2JlIGInIDggYztcbiAgICBCeXRlcy5zZXRfaW50MzJfYmUgYicgMTIgZDtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGInXG5cbiAgbGV0IHRvX2ludDMyIHMgPVxuICAgICgqIHdpdGggT0NhbWw+PTQuMTMsIHVzZSBTdHJpbmcuZ2V0X2ludDMyX2JlICopXG4gICAgbGV0IGIgPSBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIHMgaW5cbiAgICAoIEJ5dGVzLmdldF9pbnQzMl9iZSBiIDAsXG4gICAgICBCeXRlcy5nZXRfaW50MzJfYmUgYiA0LFxuICAgICAgQnl0ZXMuZ2V0X2ludDMyX2JlIGIgOCxcbiAgICAgIEJ5dGVzLmdldF9pbnQzMl9iZSBiIDEyIClcblxuICBsZXQgb2ZfaW50MTYgKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpID1cbiAgICBsZXQgYicgPSBta196ZXJvICgpIGluXG4gICAgQnl0ZXMuc2V0X3VpbnQxNl9iZSBiJyAwIGE7XG4gICAgQnl0ZXMuc2V0X3VpbnQxNl9iZSBiJyAyIGI7XG4gICAgQnl0ZXMuc2V0X3VpbnQxNl9iZSBiJyA0IGM7XG4gICAgQnl0ZXMuc2V0X3VpbnQxNl9iZSBiJyA2IGQ7XG4gICAgQnl0ZXMuc2V0X3VpbnQxNl9iZSBiJyA4IGU7XG4gICAgQnl0ZXMuc2V0X3VpbnQxNl9iZSBiJyAxMCBmO1xuICAgIEJ5dGVzLnNldF91aW50MTZfYmUgYicgMTIgZztcbiAgICBCeXRlcy5zZXRfdWludDE2X2JlIGInIDE0IGg7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiJ1xuXG4gIGxldCB0b19pbnQxNiBzID1cbiAgICAoKiB3aXRoIE9DYW1sPj00LjEzLCB1c2UgU3RyaW5nLmdldF91aW50MTZfYmUgKilcbiAgICBsZXQgYiA9IEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgcyBpblxuICAgICggQnl0ZXMuZ2V0X3VpbnQxNl9iZSBiIDAsXG4gICAgICBCeXRlcy5nZXRfdWludDE2X2JlIGIgMixcbiAgICAgIEJ5dGVzLmdldF91aW50MTZfYmUgYiA0LFxuICAgICAgQnl0ZXMuZ2V0X3VpbnQxNl9iZSBiIDYsXG4gICAgICBCeXRlcy5nZXRfdWludDE2X2JlIGIgOCxcbiAgICAgIEJ5dGVzLmdldF91aW50MTZfYmUgYiAxMCxcbiAgICAgIEJ5dGVzLmdldF91aW50MTZfYmUgYiAxMixcbiAgICAgIEJ5dGVzLmdldF91aW50MTZfYmUgYiAxNCApXG5cbiAgbGV0IGFkZF9leG4geCB5ID1cbiAgICBsZXQgYiA9IG1rX3plcm8gKCkgaW5cbiAgICBsZXQgY2FycnkgPSByZWYgMCBpblxuICAgIGl0ZXJpX3JpZ2h0MlxuICAgICAgKGZ1biBpIHgnIHknIC0+XG4gICAgICAgIGxldCBzdW0gPSB4JyArIHknICsgIWNhcnJ5IGluXG4gICAgICAgIGlmIHN1bSA+PSAyNTYgdGhlbiAoXG4gICAgICAgICAgY2FycnkgOj0gMTtcbiAgICAgICAgICBCeXRlcy5zZXRfdWludDggYiBpIChzdW0gLSAyNTYpKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBjYXJyeSA6PSAwO1xuICAgICAgICAgIEJ5dGVzLnNldF91aW50OCBiIGkgc3VtKSlcbiAgICAgIHggeTtcbiAgICBpZiAhY2FycnkgPD4gMCB0aGVuIHJhaXNlIE92ZXJmbG93IGVsc2UgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiXG5cbiAgbGV0IGFkZCB4IHkgPSB0cnkgU29tZSAoYWRkX2V4biB4IHkpIHdpdGggT3ZlcmZsb3cgLT4gTm9uZVxuXG4gIGxldCBwcmVkX2V4biB4ID1cbiAgICBpZiBlcXVhbCB4IHplcm8gdGhlbiByYWlzZSBPdmVyZmxvdztcbiAgICBsZXQgYiA9IEJ5dGVzLm9mX3N0cmluZyB4IGluXG4gICAgbGV0IHJlYyBnbyBpID1cbiAgICAgIEJ5dGVzLnNldF91aW50OCBiIGkgKENoYXIuY29kZSAoU3RyaW5nLmdldCB4IGkpIC0gMSk7XG4gICAgICBpZiBDaGFyLmNvZGUgKFN0cmluZy5nZXQgeCBpKSA9IDAgdGhlbiBnbyAoU3RkbGliLnByZWQgaSlcbiAgICBpblxuICAgIGdvIDE1O1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYlxuXG4gIGxldCBsb2dhbmQgeCB5ID1cbiAgICBsZXQgYiA9IG1rX3plcm8gKCkgaW5cbiAgICBpdGVyaV9yaWdodDIgKGZ1biBpIHggeSAtPiBCeXRlcy5zZXRfdWludDggYiBpICh4IGxhbmQgeSkpIHggeTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJcblxuICBsZXQgbG9nb3IgeCB5ID1cbiAgICBsZXQgYiA9IG1rX3plcm8gKCkgaW5cbiAgICBpdGVyaV9yaWdodDIgKGZ1biBpIHggeSAtPiBCeXRlcy5zZXRfdWludDggYiBpICh4IGxvciB5KSkgeCB5O1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYlxuXG4gIGxldCBsb2d4b3IgeCB5ID1cbiAgICBsZXQgYiA9IG1rX3plcm8gKCkgaW5cbiAgICBpdGVyaV9yaWdodDIgKGZ1biBpIHggeSAtPiBCeXRlcy5zZXRfdWludDggYiBpICh4IGx4b3IgeSkpIHggeTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJcblxuICBsZXQgbG9nbm90IHggPVxuICAgIGxldCBiID0gbWtfemVybyAoKSBpblxuICAgIFN0cmluZy5pdGVyaVxuICAgICAgKGZ1biBpIF8gLT4gQnl0ZXMuc2V0X3VpbnQ4IGIgaSAobG5vdCAoQ2hhci5jb2RlIChTdHJpbmcuZ2V0IHggaSkpKSlcbiAgICAgIHg7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiXG5cbiAgbW9kdWxlIEJ5dGUgPSBzdHJ1Y3RcbiAgICAoKiBFeHRyYWN0IHRoZSBbbl0gbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBmcm9tIFtpXSAqKVxuICAgIGxldCBnZXRfbHNiaXRzIG4gaSA9XG4gICAgICBpZiBuIDw9IDAgfHwgbiA+IDggdGhlbiBpbnZhbGlkX2FyZyBcIm91dCBvZiBib3VuZHNcIjtcbiAgICAgIGkgbGFuZCAoKDEgbHNsIG4pIC0gMSlcblxuICAgICgqIEV4dHJhY3QgdGhlIFtuXSBtb3N0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBbaV0gKilcbiAgICBsZXQgZ2V0X21zYml0cyBuIGkgPVxuICAgICAgaWYgbiA8PSAwIHx8IG4gPiA4IHRoZW4gaW52YWxpZF9hcmcgXCJvdXQgb2YgYm91bmRzXCI7XG4gICAgICAoaSBsYW5kICgyNTUgbHNsICg4IC0gbikpKSBsc3IgKDggLSBuKVxuXG4gICAgKCogU2V0IHZhbHVlIFt4XSBpbiBbaV0ncyBbbl0gbW9zdCBzaWduaWZpY2FudCBiaXRzICopXG4gICAgbGV0IHNldF9tc2JpdHMgbiB4IGkgPVxuICAgICAgaWYgbiA8IDAgfHwgbiA+IDggdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIm4gbXVzdCBiZSA+PSAwICYmIDw9IDhcIilcbiAgICAgIGVsc2UgaWYgbiA9IDAgdGhlbiBpXG4gICAgICBlbHNlIGlmIG4gPSA4IHRoZW4geFxuICAgICAgZWxzZSAoeCBsc2wgKDggLSBuKSkgbG9yIGlcblxuICAgICgqIHNldCBiaXRzIGFyZSByZXByZXNlbnRlZCBhcyB0cnVlICopXG4gICAgbGV0IGZvbGRfbGVmdCBmIGEgaSA9XG4gICAgICBsZXQgYml0bWFzayA9IHJlZiAwYjEwMDBfMDAwMCBpblxuICAgICAgbGV0IGEnID0gcmVmIGEgaW5cbiAgICAgIGZvciBfID0gMCB0byA3IGRvXG4gICAgICAgIGEnIDo9IGYgIWEnIChpIGxhbmQgIWJpdG1hc2sgPiAwKTtcbiAgICAgICAgYml0bWFzayA6PSAhYml0bWFzayBsc3IgMVxuICAgICAgZG9uZTtcbiAgICAgICFhJ1xuICBlbmRcblxuICBsZXQgc2hpZnRfcmlnaHQgeCBuID1cbiAgICBtYXRjaCBuIHdpdGhcbiAgICB8IDAgLT4geFxuICAgIHwgMTI4IC0+IHplcm9cbiAgICB8IG4gd2hlbiBuID4gMCAmJiBuIDwgMTI4IC0+XG4gICAgICAgIGxldCBiID0gbWtfemVybyAoKSBpblxuICAgICAgICBsZXQgc2hpZnRfYnl0ZXMsIHNoaWZ0X2JpdHMgPSAobiAvIDgsIG4gbW9kIDgpIGluXG4gICAgICAgIChpZiBzaGlmdF9iaXRzID0gMCB0aGVuXG4gICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIHggMCBiIHNoaWZ0X2J5dGVzICgxNiAtIHNoaWZ0X2J5dGVzKVxuICAgICAgICAgZWxzZVxuICAgICAgICAgICBsZXQgY2FycnkgPSByZWYgMCBpblxuICAgICAgICAgICBmb3IgaSA9IDAgdG8gMTUgLSBzaGlmdF9ieXRlcyBkb1xuICAgICAgICAgICAgIGxldCB4JyA9IENoYXIuY29kZSAoU3RyaW5nLmdldCB4IGkpIGluXG4gICAgICAgICAgICAgbGV0IG5ld19jYXJyeSA9IEJ5dGUuZ2V0X2xzYml0cyBzaGlmdF9iaXRzIHgnIGluXG4gICAgICAgICAgICAgbGV0IHNoaWZ0ZWRfdmFsdWUgPSB4JyBsc3Igc2hpZnRfYml0cyBpblxuICAgICAgICAgICAgIGxldCBuZXdfdmFsdWUgPSBCeXRlLnNldF9tc2JpdHMgc2hpZnRfYml0cyAhY2Fycnkgc2hpZnRlZF92YWx1ZSBpblxuICAgICAgICAgICAgIEJ5dGVzLnNldF91aW50OCBiIChpICsgc2hpZnRfYnl0ZXMpIG5ld192YWx1ZTtcbiAgICAgICAgICAgICBjYXJyeSA6PSBuZXdfY2FycnlcbiAgICAgICAgICAgZG9uZSk7XG4gICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYlxuICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIm4gbXVzdCBiZSA+PSAwICYmIDw9IDEyOFwiKVxuXG4gIGxldCBzaGlmdF9sZWZ0IHggbiA9XG4gICAgbWF0Y2ggbiB3aXRoXG4gICAgfCAwIC0+IHhcbiAgICB8IDEyOCAtPiB6ZXJvXG4gICAgfCBuIHdoZW4gbiA+IDAgJiYgbiA8IDEyOCAtPlxuICAgICAgICBsZXQgYiA9IG1rX3plcm8gKCkgaW5cbiAgICAgICAgbGV0IHNoaWZ0X2J5dGVzLCBzaGlmdF9iaXRzID0gKG4gLyA4LCBuIG1vZCA4KSBpblxuICAgICAgICAoaWYgc2hpZnRfYml0cyA9IDAgdGhlblxuICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB4IHNoaWZ0X2J5dGVzIGIgMCAoMTYgLSBzaGlmdF9ieXRlcylcbiAgICAgICAgIGVsc2VcbiAgICAgICAgICAgbGV0IGNhcnJ5ID0gcmVmIDAgaW5cbiAgICAgICAgICAgZm9yIGkgPSAxNSBkb3dudG8gMCArIHNoaWZ0X2J5dGVzIGRvXG4gICAgICAgICAgICAgbGV0IHgnID0gQ2hhci5jb2RlIChTdHJpbmcuZ2V0IHggaSkgaW5cbiAgICAgICAgICAgICBsZXQgbmV3X2NhcnJ5ID0gQnl0ZS5nZXRfbXNiaXRzIHNoaWZ0X2JpdHMgeCcgaW5cbiAgICAgICAgICAgICBsZXQgc2hpZnRlZF92YWx1ZSA9IHgnIGxzbCBzaGlmdF9iaXRzIGluXG4gICAgICAgICAgICAgbGV0IG5ld192YWx1ZSA9IHNoaWZ0ZWRfdmFsdWUgbG9yICFjYXJyeSBpblxuICAgICAgICAgICAgIEJ5dGVzLnNldF91aW50OCBiIChpIC0gc2hpZnRfYnl0ZXMpIG5ld192YWx1ZTtcbiAgICAgICAgICAgICBjYXJyeSA6PSBuZXdfY2FycnlcbiAgICAgICAgICAgZG9uZSk7XG4gICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYlxuICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIm4gbXVzdCBiZSA+PSAwICYmIDw9IDEyOFwiKVxuXG4gIGxldCB3cml0ZV9vY3RldHNfZXhuID8ob2ZmID0gMCkgcyBkZXN0ID1cbiAgICBpZiBCeXRlcy5sZW5ndGggZGVzdCAtIG9mZiA8IDE2IHRoZW5cbiAgICAgIHJhaXNlIChQYXJzZV9lcnJvciAoXCJsYXJnZXIgaW5jbHVkaW5nIG9mZnNldCB0aGFuIHRhcmdldCBieXRlc1wiLCBzKSlcbiAgICBlbHNlIEJ5dGVzLmJsaXRfc3RyaW5nIHMgMCBkZXN0IG9mZiAoU3RyaW5nLmxlbmd0aCBzKVxuXG4gIGxldCBzdWNjX2V4biB4ID0gYWRkX2V4biB4IChvZl9pbnQ2NCAoMEwsIDFMKSlcblxuICBsZXQgc3VjYyB4ID1cbiAgICB0cnkgT2sgKHN1Y2NfZXhuIHgpXG4gICAgd2l0aCBPdmVyZmxvdyAtPiBFcnJvciAoYE1zZyBcIklwYWRkcjogaGlnaGVzdCBhZGRyZXNzIGhhcyBiZWVuIHJlYWNoZWRcIilcblxuICBsZXQgcHJlZCB4ID1cbiAgICB0cnkgT2sgKHByZWRfZXhuIHgpXG4gICAgd2l0aCBPdmVyZmxvdyB8IEludmFsaWRfYXJndW1lbnQgXyAtPlxuICAgICAgRXJyb3IgKGBNc2cgXCJJcGFkZHI6IGxvd2VzdCBhZGRyZXNzIGhhcyBiZWVuIHJlYWNoZWRcIilcbmVuZFxuXG5tb2R1bGUgVjYgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTMTI4XG5cbiAgbGV0IG1ha2UgYSBiIGMgZCBlIGYgZyBoID0gb2ZfaW50MTYgKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpXG5cbiAgKCogcGFyc2luZyAqKVxuICBsZXQgcGFyc2VfaXB2NiBzIGkgPVxuICAgIGxldCBjb21wcmVzc2VkID0gcmVmIGZhbHNlIGluXG4gICAgKCogOjogKilcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgaWYgbGVuIDwgIWkgKyAxIHRoZW4gcmFpc2UgKG5lZWRfbW9yZSBzKTtcbiAgICBsZXQgdXNlX2JyYWNrZXQgPSBzLlshaV0gPSAnWycgaW5cbiAgICBpZiB1c2VfYnJhY2tldCB0aGVuIGluY3IgaTtcbiAgICBpZiBsZW4gPCAhaSArIDIgdGhlbiByYWlzZSAobmVlZF9tb3JlIHMpO1xuICAgICgqIGNoZWNrIGlmIGl0IHN0YXJ0cyB3aXRoIDo6ICopXG4gICAgbGV0IGwgPVxuICAgICAgaWYgcy5bIWldID0gJzonIHRoZW4gKFxuICAgICAgICBpbmNyIGk7XG4gICAgICAgIGlmIHMuWyFpXSA9ICc6JyB0aGVuIChcbiAgICAgICAgICBjb21wcmVzc2VkIDo9IHRydWU7XG4gICAgICAgICAgaW5jciBpO1xuICAgICAgICAgIFsgLTEgXSlcbiAgICAgICAgZWxzZSByYWlzZSAoYmFkX2NoYXIgIWkgcykpXG4gICAgICBlbHNlIFtdXG4gICAgaW5cblxuICAgIGxldCByZWMgbG9vcCBuYiBhY2MgPVxuICAgICAgaWYgbmIgPj0gOCB0aGVuIGFjY1xuICAgICAgZWxzZSBpZiAhaSA+PSBsZW4gdGhlbiBhY2NcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHBvcyA9ICFpIGluXG4gICAgICAgIGxldCB4ID0gdHJ5IHBhcnNlX2hleF9pbnQgcyBpIHdpdGggXyAtPiAtMSBpblxuICAgICAgICBpZiB4IDwgMCB0aGVuIGFjY1xuICAgICAgICBlbHNlIGlmIG5iID0gNyB0aGVuIHggOjogYWNjXG4gICAgICAgIGVsc2UgaWYgIWkgPCBsZW4gJiYgcy5bIWldID0gJzonIHRoZW4gKFxuICAgICAgICAgIGluY3IgaTtcbiAgICAgICAgICBpZiAhaSA8IGxlbiB0aGVuXG4gICAgICAgICAgICBpZiBzLlshaV0gPSAnOicgdGhlblxuICAgICAgICAgICAgICBpZiAhY29tcHJlc3NlZCB0aGVuIChcbiAgICAgICAgICAgICAgICBkZWNyIGk7XG4gICAgICAgICAgICAgICAgeCA6OiBhY2MgKCogdHJhaWxpbmcgOjogKikpXG4gICAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICAgIGNvbXByZXNzZWQgOj0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbmNyIGk7XG4gICAgICAgICAgICAgICAgbG9vcCAobmIgKyAyKSAoLTEgOjogeCA6OiBhY2MpKVxuICAgICAgICAgICAgZWxzZSBpZiBpc19udW1iZXIgMTYgKGludF9vZl9jaGFyIHMuWyFpXSkgdGhlblxuICAgICAgICAgICAgICBsb29wIChuYiArIDEpICh4IDo6IGFjYylcbiAgICAgICAgICAgIGVsc2UgcmFpc2UgKGJhZF9jaGFyICFpIHMpXG4gICAgICAgICAgZWxzZSByYWlzZSAobmVlZF9tb3JlIHMpKVxuICAgICAgICBlbHNlIGlmICFpIDwgbGVuICYmIHMuWyFpXSA9ICcuJyB0aGVuIChcbiAgICAgICAgICBpIDo9IHBvcztcbiAgICAgICAgICBsZXQgdjQgPSBWNC5vZl9zdHJpbmdfcmF3IHMgaSBpblxuICAgICAgICAgIGxldCBoaSwgbG8gPSBWNC50b19pbnQxNiB2NCBpblxuICAgICAgICAgIGxvIDo6IGhpIDo6IGFjYylcbiAgICAgICAgZWxzZSB4IDo6IGFjY1xuICAgIGluXG5cbiAgICBsZXQgcmVzID0gbG9vcCAoTGlzdC5sZW5ndGggbCkgbCBpblxuICAgIGxldCByZXNfbGVuID0gTGlzdC5sZW5ndGggcmVzIGluXG4gICAgaWYgcmVzX2xlbiA+IDggdGhlbiByYWlzZSAoUGFyc2VfZXJyb3IgKFwidG9vIG1hbnkgY29tcG9uZW50c1wiLCBzKSlcbiAgICBlbHNlIGlmIHJlc19sZW4gPSAwIHRoZW4gcmFpc2UgKG5lZWRfbW9yZSBzKVxuICAgIGVsc2VcbiAgICAgIGxldCBhID0gQXJyYXkubWFrZSA4IDAgaW5cbiAgICAgIGxldCBtaXNzaW5nID1cbiAgICAgICAgaWYgIWNvbXByZXNzZWQgdGhlbiA4IC0gKHJlc19sZW4gLSAxKVxuICAgICAgICBlbHNlIGlmIHJlc19sZW4gPD4gOCB0aGVuXG4gICAgICAgICAgaWYgIWkgPCBsZW4gdGhlbiByYWlzZSAoYmFkX2NoYXIgIWkgcykgZWxzZSByYWlzZSAobmVlZF9tb3JlIHMpXG4gICAgICAgIGVsc2UgMFxuICAgICAgaW5cbiAgICAgIGxldCBfID1cbiAgICAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAgICAoZnVuIGkgeCAtPlxuICAgICAgICAgICAgaWYgeCA9IC0xIHRoZW4gaSAtIG1pc3NpbmdcbiAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICBpZiB4IGxhbmQgMHhmZmZmIDw+IHggdGhlblxuICAgICAgICAgICAgICAgIHJhaXNlXG4gICAgICAgICAgICAgICAgICAoUGFyc2VfZXJyb3IgKFByaW50Zi5zcHJpbnRmIFwiY29tcG9uZW50ICVkIG91dCBvZiBib3VuZHNcIiBpLCBzKSk7XG4gICAgICAgICAgICAgIGEuKGkpIDwtIHg7XG4gICAgICAgICAgICAgIGkgLSAxKSlcbiAgICAgICAgICA3IHJlc1xuICAgICAgaW5cbiAgICAgIGlmIHVzZV9icmFja2V0IHRoZW4gZXhwZWN0X2NoYXIgcyBpICddJztcbiAgICAgIGFcblxuICAoKiBzdHJpbmcgY29udmVyc2lvbiAqKVxuXG4gIGxldCBvZl9zdHJpbmdfcmF3IHMgb2Zmc2V0ID1cbiAgICBsZXQgYSA9IHBhcnNlX2lwdjYgcyBvZmZzZXQgaW5cbiAgICBtYWtlIGEuKDApIGEuKDEpIGEuKDIpIGEuKDMpIGEuKDQpIGEuKDUpIGEuKDYpIGEuKDcpXG5cbiAgbGV0IG9mX3N0cmluZ19leG4gcyA9XG4gICAgbGV0IG8gPSByZWYgMCBpblxuICAgIGxldCB4ID0gb2Zfc3RyaW5nX3JhdyBzIG8gaW5cbiAgICBleHBlY3RfZW5kIHMgbztcbiAgICB4XG5cbiAgbGV0IG9mX3N0cmluZyBzID0gdHJ5X3dpdGhfcmVzdWx0IG9mX3N0cmluZ19leG4gc1xuXG4gIGxldCB3aXRoX3BvcnRfb2Zfc3RyaW5nIH5kZWZhdWx0IHMgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgYW5kIG8gPSByZWYgMCBpblxuICAgIHRyeVxuICAgICAgbGV0IGlwdjYgPSBvZl9zdHJpbmdfcmF3IHMgbyBpblxuICAgICAgaWYgIW8gPCBsZW4gJiYgcy5bIW9dID0gJzonIHRoZW4gKFxuICAgICAgICBpbmNyIG87XG4gICAgICAgIGxldCBwb3J0ID0gcGFyc2VfZGVjX2ludCBzIG8gaW5cbiAgICAgICAgZXhwZWN0X2VuZCBzIG87XG4gICAgICAgIE9rIChpcHY2LCBwb3J0KSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBleHBlY3RfZW5kIHMgbztcbiAgICAgICAgT2sgKGlwdjYsIGRlZmF1bHQpKVxuICAgIHdpdGggUGFyc2VfZXJyb3IgKG1zZywgXykgLT4gRXJyb3IgKGBNc2cgKFwiSXBhZGRyOiBcIiBeIG1zZykpXG5cbiAgKCogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTk1MiAqKVxuICBsZXQgdG9fYnVmZmVyIGJ1ZiBhZGRyID1cbiAgICBsZXQgKChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSBhcyBjb21wKSA9IHRvX2ludDE2IGFkZHIgaW5cblxuICAgIGxldCB2NCA9XG4gICAgICBtYXRjaCBjb21wIHdpdGggMCwgMCwgMCwgMCwgMCwgMHhmZmZmLCBfLCBfIC0+IHRydWUgfCBfIC0+IGZhbHNlXG4gICAgaW5cblxuICAgIGxldCByZWMgbG9vcCBlbGlkZSB6ZXJvcyBhY2MgPSBmdW5jdGlvblxuICAgICAgfCAwIDo6IHhzIC0+IGxvb3AgZWxpZGUgKHplcm9zIC0gMSkgYWNjIHhzXG4gICAgICB8IG4gOjogeHMgd2hlbiB6ZXJvcyA9IDAgLT4gbG9vcCBlbGlkZSAwIChuIDo6IGFjYykgeHNcbiAgICAgIHwgbiA6OiB4cyAtPiBsb29wIChtaW4gZWxpZGUgemVyb3MpIDAgKG4gOjogemVyb3MgOjogYWNjKSB4c1xuICAgICAgfCBbXSAtPlxuICAgICAgICAgIGxldCBlbGlkZSA9IG1pbiBlbGlkZSB6ZXJvcyBpblxuICAgICAgICAgICggKGlmIGVsaWRlIDwgLTEgdGhlbiBTb21lIGVsaWRlIGVsc2UgTm9uZSksXG4gICAgICAgICAgICBpZiB6ZXJvcyA9IDAgdGhlbiBhY2MgZWxzZSB6ZXJvcyA6OiBhY2MgKVxuICAgIGluXG5cbiAgICBsZXQgZWxpZGUsIGwgPSBsb29wIDAgMCBbXSBbIGg7IGc7IGY7IGU7IGQ7IGM7IGI7IGEgXSBpblxuICAgIGFzc2VydCAobWF0Y2ggZWxpZGUgd2l0aCBTb21lIHggd2hlbiB4IDwgLTggLT4gZmFsc2UgfCBfIC0+IHRydWUpO1xuXG4gICAgbGV0IHJlYyBjb25zX3plcm9zIGwgeCA9XG4gICAgICBpZiB4ID49IDAgdGhlbiBsIGVsc2UgY29uc196ZXJvcyAoU29tZSAwIDo6IGwpICh4ICsgMSlcbiAgICBpblxuXG4gICAgbGV0IF8sIGxyZXYgPVxuICAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAgKGZ1biAocGF0dCwgbCkgeCAtPlxuICAgICAgICAgIGlmIFNvbWUgeCA9IHBhdHQgdGhlbiAoTm9uZSwgTm9uZSA6OiBsKVxuICAgICAgICAgIGVsc2UgaWYgeCA8IDAgdGhlbiAocGF0dCwgY29uc196ZXJvcyBsIHgpXG4gICAgICAgICAgZWxzZSAocGF0dCwgU29tZSB4IDo6IGwpKVxuICAgICAgICAoZWxpZGUsIFtdKSBsXG4gICAgaW5cblxuICAgIGxldCByZWMgZmlsbCA9IGZ1bmN0aW9uXG4gICAgICB8IFsgU29tZSBoaTsgU29tZSBsbyBdIHdoZW4gdjQgLT5cbiAgICAgICAgICBsZXQgYWRkciA9IFY0Lm9mX2ludDE2IChoaSwgbG8pIGluXG4gICAgICAgICAgVjQudG9fYnVmZmVyIGJ1ZiBhZGRyXG4gICAgICB8IE5vbmUgOjogeHMgLT5cbiAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCI6OlwiO1xuICAgICAgICAgIGZpbGwgeHNcbiAgICAgIHwgWyBTb21lIG4gXSAtPiBQcmludGYuYnByaW50ZiBidWYgXCIleFwiIG5cbiAgICAgIHwgU29tZSBuIDo6IE5vbmUgOjogeHMgLT5cbiAgICAgICAgICBQcmludGYuYnByaW50ZiBidWYgXCIleDo6XCIgbjtcbiAgICAgICAgICBmaWxsIHhzXG4gICAgICB8IFNvbWUgbiA6OiB4cyAtPlxuICAgICAgICAgIFByaW50Zi5icHJpbnRmIGJ1ZiBcIiV4OlwiIG47XG4gICAgICAgICAgZmlsbCB4c1xuICAgICAgfCBbXSAtPiAoKVxuICAgIGluXG4gICAgZmlsbCAoTGlzdC5yZXYgbHJldilcblxuICBsZXQgdG9fc3RyaW5nIGwgPVxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDM5IGluXG4gICAgdG9fYnVmZmVyIGJ1ZiBsO1xuICAgIEJ1ZmZlci5jb250ZW50cyBidWZcblxuICBsZXQgcHAgcHBmIGkgPSBGb3JtYXQuZnByaW50ZiBwcGYgXCIlc1wiICh0b19zdHJpbmcgaSlcblxuICAoKiBieXRlIGNvbnZlcnNpb24gKilcblxuICBsZXQgb2Zfb2N0ZXRzX2V4biA/KG9mZiA9IDApIGJzID1cbiAgICBpZiBTdHJpbmcubGVuZ3RoIGJzIC0gb2ZmIDwgMTYgdGhlbiByYWlzZSAobmVlZF9tb3JlIGJzKVxuICAgIGVsc2UgUzEyOC5vZl9vY3RldHNfZXhuIChTdHJpbmcuc3ViIGJzIG9mZiAxNilcblxuICBsZXQgb2Zfb2N0ZXRzID9vZmYgYnMgPSB0cnlfd2l0aF9yZXN1bHQgKG9mX29jdGV0c19leG4gP29mZikgYnNcbiAgbGV0IHdyaXRlX29jdGV0cyA/b2ZmIGkgYnMgPSB0cnlfd2l0aF9yZXN1bHQgKHdyaXRlX29jdGV0c19leG4gP29mZiBpKSBic1xuICBsZXQgdG9fb2N0ZXRzID0gUzEyOC50b19vY3RldHNcblxuICAoKiBNQUMgKilcbiAgKCoge3s6aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI0NjQjc2VjdGlvbi03fVJGQyAyNDY0fS4gKilcbiAgbGV0IG11bHRpY2FzdF90b19tYWMgcyA9XG4gICAgbGV0IG1hY2IgPSBCeXRlcy5tYWtlIDYgKENoYXIuY2hyIDB4MzMpIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgKFMxMjgudG9fb2N0ZXRzIHMpIDEyIG1hY2IgMiA0O1xuICAgIE1hY2FkZHIub2Zfb2N0ZXRzX2V4biAoQnl0ZXMudG9fc3RyaW5nIG1hY2IpXG5cbiAgKCogSG9zdCAqKVxuICBsZXQgdG9fZG9tYWluX25hbWUgYiA9XG4gICAgbGV0IGhleHN0cl9vZl9pbnQgPSBQcmludGYuc3ByaW50ZiBcIiV4XCIgaW5cbiAgICBsZXQgbmFtZSA9XG4gICAgICBTMTI4LmZvbGRfbGVmdFxuICAgICAgICAoZnVuIGFjYyBiIC0+XG4gICAgICAgICAgbGV0IHggPSBoZXhzdHJfb2ZfaW50IChiIGxhbmQgKCgxIGxzbCA0KSAtIDEpKSBpblxuICAgICAgICAgIGxldCB5ID0gaGV4c3RyX29mX2ludCAoYiBsc3IgNCkgaW5cbiAgICAgICAgICB4IDo6IHkgOjogYWNjKVxuICAgICAgICBbIFwiaXA2XCI7IFwiYXJwYVwiIF0gYlxuICAgIGluXG4gICAgRG9tYWluX25hbWUuKGhvc3RfZXhuIChvZl9zdHJpbmdzX2V4biBuYW1lKSlcblxuICBsZXQgb2ZfZG9tYWluX25hbWUgbiA9XG4gICAgbGV0IGludF9vZl9jaGFyX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgICB8IFwiMFwiIC0+IDBcbiAgICAgIHwgXCIxXCIgLT4gMVxuICAgICAgfCBcIjJcIiAtPiAyXG4gICAgICB8IFwiM1wiIC0+IDNcbiAgICAgIHwgXCI0XCIgLT4gNFxuICAgICAgfCBcIjVcIiAtPiA1XG4gICAgICB8IFwiNlwiIC0+IDZcbiAgICAgIHwgXCI3XCIgLT4gN1xuICAgICAgfCBcIjhcIiAtPiA4XG4gICAgICB8IFwiOVwiIC0+IDlcbiAgICAgIHwgXCJhXCIgLT4gMTBcbiAgICAgIHwgXCJiXCIgLT4gMTFcbiAgICAgIHwgXCJjXCIgLT4gMTJcbiAgICAgIHwgXCJkXCIgLT4gMTNcbiAgICAgIHwgXCJlXCIgLT4gMTRcbiAgICAgIHwgXCJmXCIgLT4gMTVcbiAgICAgIHwgXyAtPiBmYWlsd2l0aCBcImludF9vZl9jaGFyX3N0cmluZzogaW52YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmdcIlxuICAgIGluXG4gICAgbGV0IGxhYmVscyA9IERvbWFpbl9uYW1lLnRvX2FycmF5IG4gaW5cbiAgICBpZlxuICAgICAgQXJyYXkubGVuZ3RoIGxhYmVscyA9IDM0XG4gICAgICAmJiBEb21haW5fbmFtZS5lcXVhbF9sYWJlbCBsYWJlbHMuKDApIFwiYXJwYVwiXG4gICAgICAmJiBEb21haW5fbmFtZS5lcXVhbF9sYWJlbCBsYWJlbHMuKDEpIFwiaXA2XCJcbiAgICB0aGVuXG4gICAgICBsZXQgYiA9IEJ5dGVzLmNyZWF0ZSAxNiBpblxuICAgICAgdHJ5XG4gICAgICAgIGZvciBiaSA9IDAgdG8gMTUgZG9cbiAgICAgICAgICBsZXQgaSA9IDIgKiBJbnQuc3VjYyBiaSBpblxuICAgICAgICAgIGxldCB4ID0gaW50X29mX2NoYXJfc3RyaW5nIGxhYmVscy4oaSkgaW5cbiAgICAgICAgICBsZXQgeSA9IGludF9vZl9jaGFyX3N0cmluZyBsYWJlbHMuKGkgKyAxKSBpblxuICAgICAgICAgIEJ5dGVzLnNldF91aW50OCBiIGJpIChJbnQubG9nb3IgKEludC5zaGlmdF9sZWZ0IHggNCkgeSlcbiAgICAgICAgZG9uZTtcbiAgICAgICAgU29tZSAoUzEyOC5vZl9vY3RldHNfZXhuIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpKVxuICAgICAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuICAgIGVsc2UgTm9uZVxuXG4gICgqIGNvbnN0YW50ICopXG5cbiAgbGV0IHVuc3BlY2lmaWVkID0gbWFrZSAwIDAgMCAwIDAgMCAwIDBcbiAgbGV0IGxvY2FsaG9zdCA9IG1ha2UgMCAwIDAgMCAwIDAgMCAxXG4gIGxldCBpbnRlcmZhY2Vfbm9kZXMgPSBtYWtlIDB4ZmYwMSAwIDAgMCAwIDAgMCAxXG4gIGxldCBsaW5rX25vZGVzID0gbWFrZSAweGZmMDIgMCAwIDAgMCAwIDAgMVxuICBsZXQgaW50ZXJmYWNlX3JvdXRlcnMgPSBtYWtlIDB4ZmYwMSAwIDAgMCAwIDAgMCAyXG4gIGxldCBsaW5rX3JvdXRlcnMgPSBtYWtlIDB4ZmYwMiAwIDAgMCAwIDAgMCAyXG4gIGxldCBzaXRlX3JvdXRlcnMgPSBtYWtlIDB4ZmYwNSAwIDAgMCAwIDAgMCAyXG5cbiAgbW9kdWxlIFByZWZpeCA9IHN0cnVjdFxuICAgIHR5cGUgYWRkciA9IHRcbiAgICB0eXBlIHQgPSBhZGRyICogaW50XG5cbiAgICBsZXQgY29tcGFyZSAocHJlLCBzeikgKHByZScsIHN6JykgPVxuICAgICAgbGV0IGMgPSBjb21wYXJlIHByZSBwcmUnIGluXG4gICAgICBpZiBjID0gMCB0aGVuIFN0ZGxpYi5jb21wYXJlIHN6IHN6JyBlbHNlIGNcblxuICAgIGxldCBpcCA9IG1ha2VcbiAgICBsZXQgbWFzayBzeiA9IHNoaWZ0X2xlZnQgbWF4X2ludCAoMTI4IC0gc3opXG4gICAgbGV0IHByZWZpeCAocHJlLCBzeikgPSAobG9nYW5kIHByZSAobWFzayBzeiksIHN6KVxuICAgIGxldCBtYWtlIHN6IHByZSA9IChwcmUsIHN6KVxuXG4gICAgbGV0IG5ldHdvcmtfYWRkcmVzcyAocHJlLCBzeikgYWRkciA9XG4gICAgICBsb2dvciAobG9nYW5kIHByZSAobWFzayBzeikpIChsb2dhbmQgYWRkciAobG9nbm90IChtYXNrIHN6KSkpXG5cbiAgICBsZXQgX29mX3N0cmluZ19yYXcgcyBpID1cbiAgICAgIGxldCB2NiA9IG9mX3N0cmluZ19yYXcgcyBpIGluXG4gICAgICBleHBlY3RfY2hhciBzIGkgJy8nO1xuICAgICAgbGV0IHAgPSBwYXJzZV9kZWNfaW50IHMgaSBpblxuICAgICAgaWYgcCA+IDEyOCB8fCBwIDwgMCB0aGVuIHJhaXNlIChQYXJzZV9lcnJvciAoXCJpbnZhbGlkIHByZWZpeCBzaXplXCIsIHMpKTtcbiAgICAgIChwLCB2NilcblxuICAgIGxldCBvZl9zdHJpbmdfcmF3IHMgaSA9XG4gICAgICBsZXQgcCwgdjYgPSBfb2Zfc3RyaW5nX3JhdyBzIGkgaW5cbiAgICAgIG1ha2UgcCB2NlxuXG4gICAgbGV0IF9vZl9zdHJpbmdfZXhuIHMgPVxuICAgICAgbGV0IGkgPSByZWYgMCBpblxuICAgICAgbGV0IHJlcyA9IF9vZl9zdHJpbmdfcmF3IHMgaSBpblxuICAgICAgZXhwZWN0X2VuZCBzIGk7XG4gICAgICByZXNcblxuICAgIGxldCBvZl9zdHJpbmdfZXhuIHMgPVxuICAgICAgbGV0IHAsIHY2ID0gX29mX3N0cmluZ19leG4gcyBpblxuICAgICAgbWFrZSBwIHY2XG5cbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSB0cnlfd2l0aF9yZXN1bHQgb2Zfc3RyaW5nX2V4biBzXG5cbiAgICBsZXQgX29mX25ldG1hc2tfZXhuIH5uZXRtYXNrIGFkZHJlc3MgPVxuICAgICAgbGV0IGNvdW50X2JpdHMgYml0cyBpc19sYXN0X2JpdF9zZXQgaSA9XG4gICAgICAgIFMxMjguQnl0ZS5mb2xkX2xlZnRcbiAgICAgICAgICAoZnVuIChhLCBpc19sYXN0X2JpdF9zZXQpIGUgLT5cbiAgICAgICAgICAgIG1hdGNoIChpc19sYXN0X2JpdF9zZXQsIGUpIHdpdGhcbiAgICAgICAgICAgIHwgdHJ1ZSwgZmFsc2UgfCBmYWxzZSwgZmFsc2UgLT4gKGEsIGZhbHNlKVxuICAgICAgICAgICAgfCB0cnVlLCB0cnVlIC0+IChhICsgMSwgdHJ1ZSlcbiAgICAgICAgICAgIHwgZmFsc2UsIHRydWUgLT5cbiAgICAgICAgICAgICAgICAoKiBuZXRtYXNrIGlzIG5vdCBjb250aWd1b3VzICopXG4gICAgICAgICAgICAgICAgcmFpc2UgKFBhcnNlX2Vycm9yIChcImludmFsaWQgbmV0bWFza1wiLCB0b19zdHJpbmcgbmV0bWFzaykpKVxuICAgICAgICAgIChiaXRzLCBpc19sYXN0X2JpdF9zZXQpIGlcbiAgICAgIGluXG4gICAgICBsZXQgbm1fYml0c19zZXQsIF8gPVxuICAgICAgICBTMTI4LmZvbGRfbGVmdFxuICAgICAgICAgIChmdW4gKGEsIGlzX2xhc3RfYml0X3NldCkgZSAtPiBjb3VudF9iaXRzIGEgaXNfbGFzdF9iaXRfc2V0IGUpXG4gICAgICAgICAgKDAsIHRydWUpIG5ldG1hc2tcbiAgICAgIGluXG4gICAgICBtYWtlIG5tX2JpdHNfc2V0IGFkZHJlc3NcblxuICAgIGxldCBvZl9uZXRtYXNrX2V4biB+bmV0bWFzayB+YWRkcmVzcyA9IF9vZl9uZXRtYXNrX2V4biB+bmV0bWFzayBhZGRyZXNzXG5cbiAgICBsZXQgb2ZfbmV0bWFzayB+bmV0bWFzayB+YWRkcmVzcyA9XG4gICAgICB0cnlfd2l0aF9yZXN1bHQgKF9vZl9uZXRtYXNrX2V4biB+bmV0bWFzaykgYWRkcmVzc1xuXG4gICAgbGV0IHRvX2J1ZmZlciBidWYgKHByZSwgc3opID0gUHJpbnRmLmJwcmludGYgYnVmIFwiJWEvJWRcIiB0b19idWZmZXIgcHJlIHN6XG5cbiAgICBsZXQgdG9fc3RyaW5nIHN1Ym5ldCA9XG4gICAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSA0MyBpblxuICAgICAgdG9fYnVmZmVyIGJ1ZiBzdWJuZXQ7XG4gICAgICBCdWZmZXIuY29udGVudHMgYnVmXG5cbiAgICBsZXQgcHAgcHBmIGkgPSBGb3JtYXQuZnByaW50ZiBwcGYgXCIlc1wiICh0b19zdHJpbmcgaSlcblxuICAgIGxldCBtZW0gaXAgKHByZSwgc3opID1cbiAgICAgIGxldCBtID0gbWFzayBzeiBpblxuICAgICAgbG9nYW5kIGlwIG0gPSBsb2dhbmQgcHJlIG1cblxuICAgIGxldCBzdWJzZXQgfnN1Ym5ldDoocHJlMSwgc3oxKSB+bmV0d29yazoocHJlMiwgc3oyKSA9XG4gICAgICBzejEgPj0gc3oyICYmIG1lbSBwcmUxIChwcmUyLCBzejIpXG5cbiAgICBsZXQgb2ZfYWRkciBpcCA9IG1ha2UgMTI4IGlwXG4gICAgbGV0IGdsb2JhbF91bmljYXN0XzAwMSA9IG1ha2UgMyAoaXAgMHgyMDAwIDAgMCAwIDAgMCAwIDApXG4gICAgbGV0IGxpbmsgPSBtYWtlIDY0IChpcCAweGZlODAgMCAwIDAgMCAwIDAgMClcbiAgICBsZXQgdW5pcXVlX2xvY2FsID0gbWFrZSA3IChpcCAweGZjMDAgMCAwIDAgMCAwIDAgMClcbiAgICBsZXQgbXVsdGljYXN0ID0gbWFrZSA4IChpcCAweGZmMDAgMCAwIDAgMCAwIDAgMClcbiAgICBsZXQgaXB2NF9tYXBwZWQgPSBtYWtlIDk2IChpcCAwIDAgMCAwIDAgMHhmZmZmIDAgMClcbiAgICBsZXQgbm9uZXVpNjRfaW50ZXJmYWNlID0gbWFrZSAzIChpcCAweDAwMDAgMCAwIDAgMCAwIDAgMClcbiAgICBsZXQgc29saWNpdGVkX25vZGUgPSBtYWtlIDEwNCAoaXAgMHhmZjAyIDAgMCAwIDAgMSAweGZmMDAgMClcbiAgICBsZXQgbmV0d29yayAocHJlLCBzeikgPSBsb2dhbmQgcHJlIChtYXNrIHN6KVxuICAgIGxldCBhZGRyZXNzIChhZGRyLCBfKSA9IGFkZHJcbiAgICBsZXQgYml0cyAoXywgc3opID0gc3pcbiAgICBsZXQgbmV0bWFzayBzdWJuZXQgPSBtYXNrIChiaXRzIHN1Ym5ldClcbiAgICBsZXQgaG9zdG1hc2sgY2lkciA9IFMxMjgubG9neG9yIChuZXRtYXNrIGNpZHIpIFMxMjgubWF4X2ludFxuXG4gICAgbGV0IGZpcnN0ICgoXywgc3opIGFzIGNpZHIpID1cbiAgICAgIGlmIHN6ID4gMTI2IHRoZW4gbmV0d29yayBjaWRyIGVsc2UgbmV0d29yayBjaWRyIHw+IHN1Y2MgfD4gZmFpbHdpdGhfbXNnXG5cbiAgICBsZXQgbGFzdCAoKF8sIHN6KSBhcyBjaWRyKSA9XG4gICAgICBsZXQgZmZmZiA9IFMxMjgubWF4X2ludCBpblxuICAgICAgbG9nb3IgKG5ldHdvcmsgY2lkcikgKFMxMjguc2hpZnRfcmlnaHQgZmZmZiBzeilcblxuICAgIGxldCBob3N0cyA/KHVzYWJsZSA9IHRydWUpICgoXywgc3opIGFzIGNpZHIpID1cbiAgICAgIGxldCByZWMgaXRlcl9zZXEgc3RhcnQgc3RvcCA9XG4gICAgICAgIGlmIFMxMjguY29tcGFyZSBzdGFydCBzdG9wID4gMCB0aGVuIFNlcS5OaWxcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1hdGNoIHN1Y2Mgc3RhcnQgd2l0aFxuICAgICAgICAgIHwgT2sgc3RhcnRfc3VjYyAtPiBTZXEuQ29ucyAoc3RhcnQsIGZ1biAoKSAtPiBpdGVyX3NlcSBzdGFydF9zdWNjIHN0b3ApXG4gICAgICAgICAgfCBFcnJvciBfIC0+IFNlcS5Db25zIChzdGFydCwgZnVuICgpIC0+IFNlcS5OaWwpXG4gICAgICBpblxuICAgICAgaWYgdXNhYmxlICYmIHN6ID0gMTI4IHRoZW4gZnVuICgpIC0+IFNlcS5OaWxcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHN0YXJ0LCBzdG9wID1cbiAgICAgICAgICBpZiB1c2FibGUgdGhlbiAoZmlyc3QgY2lkciwgbGFzdCBjaWRyKSBlbHNlIChuZXR3b3JrIGNpZHIsIGxhc3QgY2lkcilcbiAgICAgICAgaW5cbiAgICAgICAgZnVuICgpIC0+IGl0ZXJfc2VxIHN0YXJ0IHN0b3BcblxuICAgIGxldCBzdWJuZXRzIG4gKChfLCBzeikgYXMgY2lkcikgPVxuICAgICAgbGV0IHJlYyBpdGVyX3NlcSBzdGFydCBzdG9wIHN0ZXBzID1cbiAgICAgICAgaWYgUzEyOC5jb21wYXJlIHN0YXJ0IHN0b3AgPiAwIHRoZW4gU2VxLk5pbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHByZWZpeCA9IG1ha2UgbiBzdGFydCBpblxuICAgICAgICAgIGlmIFMxMjguZXF1YWwgc3RhcnQgc3RvcCB0aGVuIFNlcS5Db25zIChwcmVmaXgsIGZ1biAoKSAtPiBTZXEuTmlsKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIFMxMjguYWRkIHN0YXJ0IHN0ZXBzIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBTZXEuQ29ucyAocHJlZml4LCBmdW4gKCkgLT4gU2VxLk5pbClcbiAgICAgICAgICAgIHwgU29tZSBzdGFydF9zdWNjIC0+XG4gICAgICAgICAgICAgICAgU2VxLkNvbnMgKHByZWZpeCwgZnVuICgpIC0+IGl0ZXJfc2VxIHN0YXJ0X3N1Y2Mgc3RvcCBzdGVwcylcbiAgICAgIGluXG4gICAgICBpZiBzeiA+IG4gfHwgbiA+IDEyOCB0aGVuIGZ1biAoKSAtPiBTZXEuTmlsXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzdGFydCA9IG5ldHdvcmsgY2lkciBpblxuICAgICAgICBsZXQgc3RvcCA9IGxhc3QgY2lkciBpblxuICAgICAgICBsZXQgc3RlcHMgPSBTMTI4LihzdWNjX2V4biAoc2hpZnRfcmlnaHQgKGhvc3RtYXNrIGNpZHIpIChuIC0gc3opKSkgaW5cbiAgICAgICAgZnVuICgpIC0+IGl0ZXJfc2VxIHN0YXJ0IHN0b3Agc3RlcHNcbiAgZW5kXG5cbiAgKCogVE9ETzogVGhpcyBjb3VsZCBiZSBvcHRpbWl6ZWQgd2l0aCBzb21ldGhpbmcgdHJpZS1saWtlICopXG4gIGxldCBzY29wZSBpID1cbiAgICBsZXQgbWVtID0gUHJlZml4Lm1lbSBpIGluXG4gICAgaWYgbWVtIFByZWZpeC5nbG9iYWxfdW5pY2FzdF8wMDEgdGhlbiBHbG9iYWxcbiAgICBlbHNlIGlmXG4gICAgICBtZW0gUHJlZml4LmlwdjRfbWFwcGVkICgqIHJmYyBzYXlzIHRoZXkgYXJlIHRlY2huaWNhbGx5IGdsb2JhbCBidXQuLi4gKilcbiAgICB0aGVuXG4gICAgICBWNC5zY29wZVxuICAgICAgICAobGV0IF8sIF8sIF8sIHY0ID0gdG9faW50MzIgaSBpblxuICAgICAgICAgVjQub2ZfaW50MzIgdjQpXG4gICAgZWxzZSBpZiBtZW0gUHJlZml4Lm11bHRpY2FzdCB0aGVuXG4gICAgICBsZXQgeCwgXywgXywgXywgXywgXywgXywgXyA9IHRvX2ludDE2IGkgaW5cbiAgICAgIG1hdGNoIHggbGFuZCAweGYgd2l0aFxuICAgICAgfCAwIC0+IFBvaW50XG4gICAgICB8IDEgLT4gSW50ZXJmYWNlXG4gICAgICB8IDIgfCAzIC0+IExpbmtcbiAgICAgIHwgNCAtPiBBZG1pblxuICAgICAgfCA1IHwgNiB8IDcgLT4gU2l0ZVxuICAgICAgfCA4IHwgOSB8IDEwIHwgMTEgfCAxMiB8IDEzIC0+IE9yZ2FuaXphdGlvblxuICAgICAgfCAxNCB8IDE1IC0+IEdsb2JhbFxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgIGVsc2UgaWYgbWVtIFByZWZpeC5saW5rIHRoZW4gTGlua1xuICAgIGVsc2UgaWYgbWVtIFByZWZpeC51bmlxdWVfbG9jYWwgdGhlbiBHbG9iYWxcbiAgICBlbHNlIGlmIGkgPSBsb2NhbGhvc3QgdGhlbiBJbnRlcmZhY2VcbiAgICBlbHNlIGlmIGkgPSB1bnNwZWNpZmllZCB0aGVuIFBvaW50XG4gICAgZWxzZSBHbG9iYWxcblxuICBsZXQgbGlua19hZGRyZXNzX29mX21hYyA9XG4gICAgbGV0IGMgYiBpID0gQ2hhci5jb2RlIGIuW2ldIGluXG4gICAgZnVuIG1hYyAtPlxuICAgICAgbGV0IGJtYWMgPSBNYWNhZGRyLnRvX29jdGV0cyBtYWMgaW5cbiAgICAgIGxldCBjXzAgPSBjIGJtYWMgMCBseG9yIDIgaW5cbiAgICAgIGxldCBhZGRyID1cbiAgICAgICAgbWFrZSAwIDAgMCAwXG4gICAgICAgICAgKChjXzAgbHNsIDgpICsgYyBibWFjIDEpXG4gICAgICAgICAgKChjIGJtYWMgMiBsc2wgOCkgKyAweGZmKVxuICAgICAgICAgICgweGZlMDAgKyBjIGJtYWMgMylcbiAgICAgICAgICAoKGMgYm1hYyA0IGxzbCA4KSArIGMgYm1hYyA1KVxuICAgICAgaW5cbiAgICAgIFByZWZpeC4obmV0d29ya19hZGRyZXNzIGxpbmsgYWRkcilcblxuICBsZXQgaXNfZ2xvYmFsIGkgPSBzY29wZSBpID0gR2xvYmFsXG4gIGxldCBpc19tdWx0aWNhc3QgaSA9IFByZWZpeC4obWVtIGkgbXVsdGljYXN0KVxuICBsZXQgaXNfcHJpdmF0ZSBpID0gc2NvcGUgaSA8PiBHbG9iYWxcblxuICBtb2R1bGUgU2V0ID0gU2V0Lk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgY29tcGFyZSAoYSA6IHQpIChiIDogdCkgPSBjb21wYXJlIGEgYlxuICBlbmQpXG5cbiAgbW9kdWxlIE1hcCA9IE1hcC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IGNvbXBhcmUgKGEgOiB0KSAoYiA6IHQpID0gY29tcGFyZSBhIGJcbiAgZW5kKVxuZW5kXG5cbnR5cGUgKCd2NCwgJ3Y2KSB2NHY2ID0gVjQgb2YgJ3Y0IHwgVjYgb2YgJ3Y2XG50eXBlIHQgPSAoVjQudCwgVjYudCkgdjR2NlxuXG5sZXQgY29tcGFyZSBhIGIgPVxuICBtYXRjaCAoYSwgYikgd2l0aFxuICB8IFY0IGEsIFY0IGIgLT4gVjQuY29tcGFyZSBhIGJcbiAgfCBWNiBhLCBWNiBiIC0+IFY2LmNvbXBhcmUgYSBiXG4gIHwgVjQgXywgVjYgXyAtPiAtMVxuICB8IFY2IF8sIFY0IF8gLT4gMVxuXG5tb2R1bGUgU2V0ID0gU2V0Lk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCBjb21wYXJlIChhIDogdCkgKGIgOiB0KSA9IGNvbXBhcmUgYSBiXG5lbmQpXG5cbm1vZHVsZSBNYXAgPSBNYXAuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IGNvbXBhcmUgKGEgOiB0KSAoYiA6IHQpID0gY29tcGFyZSBhIGJcbmVuZClcblxubGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uIFY0IHggLT4gVjQudG9fc3RyaW5nIHggfCBWNiB4IC0+IFY2LnRvX3N0cmluZyB4XG5cbmxldCB0b19idWZmZXIgYnVmID0gZnVuY3Rpb25cbiAgfCBWNCB4IC0+IFY0LnRvX2J1ZmZlciBidWYgeFxuICB8IFY2IHggLT4gVjYudG9fYnVmZmVyIGJ1ZiB4XG5cbmxldCBwcCBwcGYgaSA9IEZvcm1hdC5mcHJpbnRmIHBwZiBcIiVzXCIgKHRvX3N0cmluZyBpKVxuXG5sZXQgb2Zfc3RyaW5nX3JhdyBzIG9mZnNldCA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgaWYgbGVuIDwgIW9mZnNldCArIDEgdGhlbiByYWlzZSAobmVlZF9tb3JlIHMpO1xuICBtYXRjaCBzLlswXSB3aXRoXG4gIHwgJ1snIC0+IFY2IChWNi5vZl9zdHJpbmdfcmF3IHMgb2Zmc2V0KVxuICB8IF8gLT4gKFxuICAgICAgbGV0IHBvcyA9ICFvZmZzZXQgaW5cbiAgICAgIHRyeSBWNCAoVjQub2Zfc3RyaW5nX3JhdyBzIG9mZnNldClcbiAgICAgIHdpdGggUGFyc2VfZXJyb3IgKHY0X21zZywgXykgLT4gKFxuICAgICAgICBvZmZzZXQgOj0gcG9zO1xuICAgICAgICB0cnkgVjYgKFY2Lm9mX3N0cmluZ19yYXcgcyBvZmZzZXQpXG4gICAgICAgIHdpdGggUGFyc2VfZXJyb3IgKHY2X21zZywgcykgLT5cbiAgICAgICAgICBsZXQgbXNnID1cbiAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwibm90IGFuIElQdjQgYWRkcmVzczogJXNcXG5ub3QgYW4gSVB2NiBhZGRyZXNzOiAlc1wiXG4gICAgICAgICAgICAgIHY0X21zZyB2Nl9tc2dcbiAgICAgICAgICBpblxuICAgICAgICAgIHJhaXNlIChQYXJzZV9lcnJvciAobXNnLCBzKSkpKVxuXG5sZXQgb2Zfc3RyaW5nX2V4biBzID1cbiAgbGV0IG8gPSByZWYgMCBpblxuICBsZXQgeCA9IG9mX3N0cmluZ19yYXcgcyBvIGluXG4gIGV4cGVjdF9lbmQgcyBvO1xuICB4XG5cbmxldCBvZl9zdHJpbmcgcyA9IHRyeV93aXRoX3Jlc3VsdCBvZl9zdHJpbmdfZXhuIHNcblxubGV0IHdpdGhfcG9ydF9vZl9zdHJpbmcgfmRlZmF1bHQgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgYW5kIG8gPSByZWYgMCBpblxuICB0cnlcbiAgICBsZXQgaXB2NiA9IG9mX3N0cmluZ19yYXcgcyBvIGluXG4gICAgaWYgIW8gPCBsZW4gJiYgcy5bIW9dID0gJzonIHRoZW4gKFxuICAgICAgaW5jciBvO1xuICAgICAgbGV0IHBvcnQgPSBwYXJzZV9kZWNfaW50IHMgbyBpblxuICAgICAgZXhwZWN0X2VuZCBzIG87XG4gICAgICBPayAoaXB2NiwgcG9ydCkpXG4gICAgZWxzZSAoXG4gICAgICBleHBlY3RfZW5kIHMgbztcbiAgICAgIE9rIChpcHY2LCBkZWZhdWx0KSlcbiAgd2l0aCBQYXJzZV9lcnJvciAobXNnLCBfKSAtPiBFcnJvciAoYE1zZyAoXCJJcGFkZHI6IFwiIF4gbXNnKSlcblxubGV0IG9mX29jdGV0c19leG4gYnMgPVxuICBtYXRjaCBTdHJpbmcubGVuZ3RoIGJzIHdpdGhcbiAgfCA0IC0+IFY0IChWNC5vZl9vY3RldHNfZXhuIGJzKVxuICB8IDE2IC0+IFY2IChWNi5vZl9vY3RldHNfZXhuIGJzKVxuICB8IF8gLT4gcmFpc2UgKFBhcnNlX2Vycm9yIChcIm9jdGV0cyBtdXN0IGJlIG9mIGxlbmd0aCA0IG9yIDE2XCIsIGJzKSlcblxubGV0IG9mX29jdGV0cyBicyA9IHRyeV93aXRoX3Jlc3VsdCBvZl9vY3RldHNfZXhuIGJzXG5sZXQgdG9fb2N0ZXRzIGkgPSBtYXRjaCBpIHdpdGggVjQgcCAtPiBWNC50b19vY3RldHMgcCB8IFY2IHAgLT4gVjYudG9fb2N0ZXRzIHBcblxubGV0IHY2X29mX3Y0IHY0ID1cbiAgVjYuKFByZWZpeC4obmV0d29ya19hZGRyZXNzIGlwdjRfbWFwcGVkIChvZl9pbnQzMiAoMGwsIDBsLCAwbCwgdjQpKSkpXG5cbmxldCB2NF9vZl92NiB2NiA9XG4gIGlmIFY2LlByZWZpeC4obWVtIHY2IGlwdjRfbWFwcGVkKSB0aGVuXG4gICAgbGV0IF8sIF8sIF8sIHY0ID0gVjYudG9faW50MzIgdjYgaW5cbiAgICBTb21lIFY0LihvZl9pbnQzMiB2NClcbiAgZWxzZSBOb25lXG5cbmxldCB0b192NCA9IGZ1bmN0aW9uIFY0IHY0IC0+IFNvbWUgdjQgfCBWNiB2NiAtPiB2NF9vZl92NiB2NlxubGV0IHRvX3Y2ID0gZnVuY3Rpb24gVjQgdjQgLT4gdjZfb2ZfdjQgdjQgfCBWNiB2NiAtPiB2NlxubGV0IHNjb3BlID0gZnVuY3Rpb24gVjQgdjQgLT4gVjQuc2NvcGUgdjQgfCBWNiB2NiAtPiBWNi5zY29wZSB2NlxubGV0IGlzX2dsb2JhbCA9IGZ1bmN0aW9uIFY0IHY0IC0+IFY0LmlzX2dsb2JhbCB2NCB8IFY2IHY2IC0+IFY2LmlzX2dsb2JhbCB2NlxuXG5sZXQgaXNfbXVsdGljYXN0ID0gZnVuY3Rpb25cbiAgfCBWNCB2NCAtPiBWNC5pc19tdWx0aWNhc3QgdjRcbiAgfCBWNiB2NiAtPiBWNi5pc19tdWx0aWNhc3QgdjZcblxubGV0IGlzX3ByaXZhdGUgPSBmdW5jdGlvblxuICB8IFY0IHY0IC0+IFY0LmlzX3ByaXZhdGUgdjRcbiAgfCBWNiB2NiAtPiBWNi5pc19wcml2YXRlIHY2XG5cbmxldCBtdWx0aWNhc3RfdG9fbWFjID0gZnVuY3Rpb25cbiAgfCBWNCB2NCAtPiBWNC5tdWx0aWNhc3RfdG9fbWFjIHY0XG4gIHwgVjYgdjYgLT4gVjYubXVsdGljYXN0X3RvX21hYyB2NlxuXG5sZXQgdG9fZG9tYWluX25hbWUgPSBmdW5jdGlvblxuICB8IFY0IHY0IC0+IFY0LnRvX2RvbWFpbl9uYW1lIHY0XG4gIHwgVjYgdjYgLT4gVjYudG9fZG9tYWluX25hbWUgdjZcblxubGV0IG9mX2RvbWFpbl9uYW1lIG4gPVxuICBtYXRjaCBEb21haW5fbmFtZS5jb3VudF9sYWJlbHMgbiB3aXRoXG4gIHwgNiAtPiAoXG4gICAgICBtYXRjaCBWNC5vZl9kb21haW5fbmFtZSBuIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB4IC0+IFNvbWUgKFY0IHgpKVxuICB8IDM0IC0+IChcbiAgICAgIG1hdGNoIFY2Lm9mX2RvbWFpbl9uYW1lIG4gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHggLT4gU29tZSAoVjYgeCkpXG4gIHwgXyAtPiBOb25lXG5cbmxldCBzdWNjID0gZnVuY3Rpb25cbiAgfCBWNCBhZGRyIC0+IFJlc3VsdC5tYXAgKGZ1biB2IC0+IFY0IHYpIChWNC5zdWNjIGFkZHIpXG4gIHwgVjYgYWRkciAtPiBSZXN1bHQubWFwIChmdW4gdiAtPiBWNiB2KSAoVjYuc3VjYyBhZGRyKVxuXG5sZXQgcHJlZCA9IGZ1bmN0aW9uXG4gIHwgVjQgYWRkciAtPiBSZXN1bHQubWFwIChmdW4gdiAtPiBWNCB2KSAoVjQucHJlZCBhZGRyKVxuICB8IFY2IGFkZHIgLT4gUmVzdWx0Lm1hcCAoZnVuIHYgLT4gVjYgdikgKFY2LnByZWQgYWRkcilcblxubW9kdWxlIFByZWZpeCA9IHN0cnVjdFxuICBtb2R1bGUgQWRkciA9IHN0cnVjdFxuICAgIGxldCB0b192NiA9IHRvX3Y2XG4gIGVuZFxuXG4gIHR5cGUgYWRkciA9IHRcbiAgdHlwZSB0ID0gKFY0LlByZWZpeC50LCBWNi5QcmVmaXgudCkgdjR2NlxuXG4gIGxldCBjb21wYXJlIGEgYiA9XG4gICAgbWF0Y2ggKGEsIGIpIHdpdGhcbiAgICB8IFY0IGEsIFY0IGIgLT4gVjQuUHJlZml4LmNvbXBhcmUgYSBiXG4gICAgfCBWNiBhLCBWNiBiIC0+IFY2LlByZWZpeC5jb21wYXJlIGEgYlxuICAgIHwgVjQgXywgVjYgXyAtPiAtMVxuICAgIHwgVjYgXywgVjQgXyAtPiAxXG5cbiAgbGV0IG9mX3N0cmluZ19yYXcgcyBvZmZzZXQgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBpZiBsZW4gPCAhb2Zmc2V0ICsgMSB0aGVuIHJhaXNlIChuZWVkX21vcmUgcyk7XG4gICAgbWF0Y2ggcy5bMF0gd2l0aFxuICAgIHwgJ1snIC0+IFY2IChWNi5QcmVmaXgub2Zfc3RyaW5nX3JhdyBzIG9mZnNldClcbiAgICB8IF8gLT4gKFxuICAgICAgICBsZXQgcG9zID0gIW9mZnNldCBpblxuICAgICAgICB0cnkgVjQgKFY0LlByZWZpeC5vZl9zdHJpbmdfcmF3IHMgb2Zmc2V0KVxuICAgICAgICB3aXRoIFBhcnNlX2Vycm9yICh2NF9tc2csIF8pIC0+IChcbiAgICAgICAgICBvZmZzZXQgOj0gcG9zO1xuICAgICAgICAgIHRyeSBWNiAoVjYuUHJlZml4Lm9mX3N0cmluZ19yYXcgcyBvZmZzZXQpXG4gICAgICAgICAgd2l0aCBQYXJzZV9lcnJvciAodjZfbXNnLCBzKSAtPlxuICAgICAgICAgICAgbGV0IG1zZyA9XG4gICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwibm90IGFuIElQdjQgcHJlZml4OiAlc1xcbm5vdCBhbiBJUHY2IHByZWZpeDogJXNcIlxuICAgICAgICAgICAgICAgIHY0X21zZyB2Nl9tc2dcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICByYWlzZSAoUGFyc2VfZXJyb3IgKG1zZywgcykpKSlcblxuICBsZXQgb2Zfc3RyaW5nX2V4biBzID1cbiAgICBsZXQgbyA9IHJlZiAwIGluXG4gICAgbGV0IHggPSBvZl9zdHJpbmdfcmF3IHMgbyBpblxuICAgIGV4cGVjdF9lbmQgcyBvO1xuICAgIHhcblxuICBsZXQgb2Zfc3RyaW5nIHMgPSB0cnlfd2l0aF9yZXN1bHQgb2Zfc3RyaW5nX2V4biBzXG5cbiAgbGV0IHY2X29mX3Y0IHY0ID1cbiAgICBWNi5QcmVmaXgubWFrZSAoOTYgKyBWNC5QcmVmaXguYml0cyB2NCkgKHY2X29mX3Y0IChWNC5QcmVmaXgubmV0d29yayB2NCkpXG5cbiAgbGV0IHY0X29mX3Y2IHY2ID1cbiAgICBtYXRjaCB2NF9vZl92NiAoVjYuUHJlZml4Lm5ldHdvcmsgdjYpIHdpdGhcbiAgICB8IFNvbWUgdjQgLT4gU29tZSAoVjQuUHJlZml4Lm1ha2UgKFY2LlByZWZpeC5iaXRzIHY2IC0gOTYpIHY0KVxuICAgIHwgTm9uZSAtPiBOb25lXG5cbiAgbGV0IHRvX3Y0ID0gZnVuY3Rpb24gVjQgdjQgLT4gU29tZSB2NCB8IFY2IHY2IC0+IHY0X29mX3Y2IHY2XG4gIGxldCB0b192NiA9IGZ1bmN0aW9uIFY0IHY0IC0+IHY2X29mX3Y0IHY0IHwgVjYgdjYgLT4gdjZcbiAgbGV0IG1lbSBpcCBwcmVmaXggPSBWNi5QcmVmaXgubWVtIChBZGRyLnRvX3Y2IGlwKSAodG9fdjYgcHJlZml4KVxuXG4gIGxldCBzdWJzZXQgfnN1Ym5ldCB+bmV0d29yayA9XG4gICAgVjYuUHJlZml4LnN1YnNldCB+c3VibmV0Oih0b192NiBzdWJuZXQpIH5uZXR3b3JrOih0b192NiBuZXR3b3JrKVxuXG4gIGxldCBvZl9hZGRyID0gZnVuY3Rpb25cbiAgICB8IFY0IHAgLT4gVjQgKFY0LlByZWZpeC5vZl9hZGRyIHApXG4gICAgfCBWNiBwIC0+IFY2IChWNi5QcmVmaXgub2ZfYWRkciBwKVxuXG4gIGxldCB0b19zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgVjQgcCAtPiBWNC5QcmVmaXgudG9fc3RyaW5nIHBcbiAgICB8IFY2IHAgLT4gVjYuUHJlZml4LnRvX3N0cmluZyBwXG5cbiAgbGV0IHRvX2J1ZmZlciBidWYgPSBmdW5jdGlvblxuICAgIHwgVjQgcCAtPiBWNC5QcmVmaXgudG9fYnVmZmVyIGJ1ZiBwXG4gICAgfCBWNiBwIC0+IFY2LlByZWZpeC50b19idWZmZXIgYnVmIHBcblxuICBsZXQgbmV0d29yayA9IGZ1bmN0aW9uXG4gICAgfCBWNCBwIC0+IFY0IChWNC5QcmVmaXgubmV0d29yayBwKVxuICAgIHwgVjYgcCAtPiBWNiAoVjYuUHJlZml4Lm5ldHdvcmsgcClcblxuICBsZXQgbmV0bWFzayA9IGZ1bmN0aW9uXG4gICAgfCBWNCBwIC0+IFY0IChWNC5QcmVmaXgubmV0bWFzayBwKVxuICAgIHwgVjYgcCAtPiBWNiAoVjYuUHJlZml4Lm5ldG1hc2sgcClcblxuICBsZXQgYWRkcmVzcyA9IGZ1bmN0aW9uXG4gICAgfCBWNCBwIC0+IFY0IChWNC5QcmVmaXguYWRkcmVzcyBwKVxuICAgIHwgVjYgcCAtPiBWNiAoVjYuUHJlZml4LmFkZHJlc3MgcClcblxuICBsZXQgcHAgcHBmIGkgPSBGb3JtYXQuZnByaW50ZiBwcGYgXCIlc1wiICh0b19zdHJpbmcgaSlcblxuICBsZXQgZmlyc3QgPSBmdW5jdGlvblxuICAgIHwgVjQgcCAtPiBWNCAoVjQuUHJlZml4LmZpcnN0IHApXG4gICAgfCBWNiBwIC0+IFY2IChWNi5QcmVmaXguZmlyc3QgcClcblxuICBsZXQgbGFzdCA9IGZ1bmN0aW9uXG4gICAgfCBWNCBwIC0+IFY0IChWNC5QcmVmaXgubGFzdCBwKVxuICAgIHwgVjYgcCAtPiBWNiAoVjYuUHJlZml4Lmxhc3QgcClcblxuICBsZXQgaG9zdHMgPyh1c2FibGUgPSB0cnVlKSA9IGZ1bmN0aW9uXG4gICAgfCBWNCBwIC0+IFY0IChWNC5QcmVmaXguaG9zdHMgfnVzYWJsZSBwKVxuICAgIHwgVjYgcCAtPiBWNiAoVjYuUHJlZml4Lmhvc3RzIH51c2FibGUgcClcblxuICBsZXQgc3VibmV0cyBuID0gZnVuY3Rpb25cbiAgICB8IFY0IHAgLT4gVjQgKFY0LlByZWZpeC5zdWJuZXRzIG4gcClcbiAgICB8IFY2IHAgLT4gVjYgKFY2LlByZWZpeC5zdWJuZXRzIG4gcClcbmVuZFxuIl19
