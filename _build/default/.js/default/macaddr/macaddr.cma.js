// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Macaddr
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__List, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_hex_pairs_required$2 = "hex pairs required",
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call12(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
    return (f.l >= 0 ? f.l : f.l = f.length) == 12
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    partial = [4, 6, [0, 2, 2], 0, 0],
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Parse_error = [248, "Macaddr.Parse_error", runtime.caml_fresh_oo_id(0)],
    _d_ = [0, [2, 0, 0], "%s"],
    _c_ =
      [0,
       [4,
        6,
        [0, 2, 2],
        0,
        [0,
         [4,
          6,
          [0, 2, 2],
          0,
          [0,
           [4,
            6,
            [0, 2, 2],
            0,
            [0, [4, 6, [0, 2, 2], 0, [0, [4, 6, [0, 2, 2], 0, [0, partial]]]]]]]]]],
       "%02x%c%02x%c%02x%c%02x%c%02x%c%02x"],
    _b_ = [0, 58, [0, 45, 0]],
    cst_hex_pairs_required = cst_hex_pairs_required$2,
    cst_hex_pairs_required$1 = cst_hex_pairs_required$2,
    cst_hex_pairs_required$0 = cst_hex_pairs_required$2,
    cst_address_segment_too_large = "address segment too large",
    _a_ =
      [0,
       [11, "invalid character '", [0, [11, "' at ", [4, 0, 0, 0, 0]]]],
       "invalid character '%c' at %d"],
    cst_MAC_is_exactly_6_bytes = "MAC is exactly 6 bytes",
    cst_Macaddr = "Macaddr: ",
    cst_not_enough_data = "not enough data";
   function need_more(x){return [0, Parse_error, cst_not_enough_data, x];}
   function try_with_result(fn, a){
    try{var _z_ = [0, caml_call1(fn, a)]; return _z_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Parse_error) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return [1, [0, 3854881, caml_call2(Stdlib[28], cst_Macaddr, msg)]];
    }
   }
   var compare = Stdlib_Bytes[40];
   function of_octets_exn(x){
    if(6 === caml_ml_string_length(x)) return caml_call1(Stdlib_Bytes[5], x);
    throw caml_maybe_attach_backtrace
           ([0, Parse_error, cst_MAC_is_exactly_6_bytes, x], 1);
   }
   function of_octets(x){return try_with_result(of_octets_exn, x);}
   function int_of_hex_char(c){
    var c$0 = caml_call1(Stdlib_Char[4], c) - 48 | 0;
    return 9 < c$0 ? 16 < c$0 ? c$0 - 7 | 0 : -1 : c$0;
   }
   function is_hex(i){
    var _x_ = 0 <= i ? 1 : 0, _y_ = _x_ ? i < 16 ? 1 : 0 : _x_;
    return _y_;
   }
   function bad_char(i, s){
    var
     _w_ = caml_string_get(s, i),
     msg = caml_call3(Stdlib_Printf[4], _a_, _w_, i);
    return [0, Parse_error, msg, s];
   }
   function parse_hex_int(term, s, i){
    var len = caml_ml_string_length(s), i$0 = i[1];
    if(i$0 >= len) throw caml_maybe_attach_backtrace(need_more(s), 1);
    if(! is_hex(int_of_hex_char(caml_string_get(s, i$0))))
     throw caml_maybe_attach_backtrace(bad_char(i$0, s), 1);
    var prev = 0;
    for(;;){
     var j = i[1];
     if(len <= j) return prev;
     var c = caml_string_get(s, j), k = int_of_hex_char(c);
     if(! is_hex(k)){
      if(caml_call2(Stdlib_List[37], c, term)) return prev;
      throw caml_maybe_attach_backtrace(bad_char(j, s), 1);
     }
     i[1]++;
     var prev$0 = (prev << 4) + k | 0, prev = prev$0;
    }
   }
   function of_string_exn(x){
    var i = [0, 0], m = caml_create_bytes(6);
    try{
     var p = i[1], _r_ = parse_hex_int(_b_, x, i);
     caml_bytes_set(m, 0, caml_call1(Stdlib_Char[1], _r_));
     if(caml_ml_string_length(x) <= i[1])
      throw caml_maybe_attach_backtrace(need_more(x), 1);
     var sep = [0, caml_string_get(x, i[1]), 0];
     if(2 !== (i[1] - p | 0))
      throw caml_maybe_attach_backtrace
             ([0, Parse_error, cst_hex_pairs_required, x], 1);
     i[1]++;
     var k = 1;
     for(;;){
      var p$1 = i[1], _t_ = parse_hex_int(sep, x, i);
      caml_bytes_set(m, k, caml_call1(Stdlib_Char[1], _t_));
      if(2 !== (i[1] - p$1 | 0))
       throw caml_maybe_attach_backtrace
              ([0, Parse_error, cst_hex_pairs_required$1, x], 1);
      i[1]++;
      var _u_ = k + 1 | 0;
      if(4 === k){
       var p$0 = i[1], _s_ = parse_hex_int(0, x, i);
       caml_bytes_set(m, 5, caml_call1(Stdlib_Char[1], _s_));
       if(2 !== (i[1] - p$0 | 0))
        throw caml_maybe_attach_backtrace
               ([0, Parse_error, cst_hex_pairs_required$0, x], 1);
       return m;
      }
      var k = _u_;
     }
    }
    catch(_v_){
     var _q_ = caml_wrap_exception(_v_);
     if(_q_[1] === Stdlib[6])
      throw caml_maybe_attach_backtrace
             ([0, Parse_error, cst_address_segment_too_large, x], 1);
     throw caml_maybe_attach_backtrace(_q_, 0);
    }
   }
   function of_string(x){return try_with_result(of_string_exn, x);}
   function to_string(opt, x){
    if(opt) var sth = opt[1], sep = sth; else var sep = 58;
    var
     _k_ = caml_bytes_get(x, 5),
     _l_ = caml_bytes_get(x, 4),
     _m_ = caml_bytes_get(x, 3),
     _n_ = caml_bytes_get(x, 2),
     _o_ = caml_bytes_get(x, 1),
     _p_ = caml_bytes_get(x, 0);
    return caml_call12
            (Stdlib_Printf[4],
             _c_,
             _p_,
             sep,
             _o_,
             sep,
             _n_,
             sep,
             _m_,
             sep,
             _l_,
             sep,
             _k_);
   }
   function to_octets(x){return caml_call1(Stdlib_Bytes[6], x);}
   function pp(ppf, i){
    var _j_ = to_string(0, i);
    return caml_call3(Stdlib_Format[137], ppf, _d_, _j_);
   }
   var broadcast = caml_call2(Stdlib_Bytes[1], 6, 255);
   function make_local(bytegenf){
    var
     x = caml_create_bytes(6),
     _g_ = ((caml_call1(bytegenf, 0) | 2) >>> 1 | 0) << 1;
    caml_bytes_set(x, 0, caml_call1(Stdlib_Char[1], _g_));
    var i = 1;
    for(;;){
     var _h_ = caml_call1(bytegenf, i);
     caml_bytes_set(x, i, caml_call1(Stdlib_Char[1], _h_));
     var _i_ = i + 1 | 0;
     if(5 === i) return x;
     var i = _i_;
    }
   }
   function get_oui(x){
    var _e_ = caml_bytes_get(x, 2), _f_ = caml_bytes_get(x, 1) << 8;
    return caml_bytes_get(x, 0) << 16 | _f_ | _e_;
   }
   function is_local(x){
    return 1 === ((caml_bytes_get(x, 0) >>> 1 | 0) & 1) ? 1 : 0;
   }
   function is_unicast(x){return 0 === (caml_bytes_get(x, 0) & 1) ? 1 : 0;}
   var
    Macaddr =
      [0,
       Parse_error,
       of_octets_exn,
       of_octets,
       of_string_exn,
       of_string,
       to_octets,
       to_string,
       pp,
       broadcast,
       make_local,
       get_oui,
       is_local,
       is_unicast,
       compare];
   runtime.caml_register_global(18, Macaddr, "Macaddr");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJtYWNhZGRyLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJuZWVkX21vcmUiLCJ4IiwidHJ5X3dpdGhfcmVzdWx0IiwiZm4iLCJhIiwibXNnIiwiY29tcGFyZSIsIm9mX29jdGV0c19leG4iLCJvZl9vY3RldHMiLCJpbnRfb2ZfaGV4X2NoYXIiLCJjIiwiYyQwIiwiaXNfaGV4IiwiaSIsImJhZF9jaGFyIiwicyIsInBhcnNlX2hleF9pbnQiLCJ0ZXJtIiwibGVuIiwiaSQwIiwicHJldiIsImoiLCJrIiwicHJldiQwIiwib2Zfc3RyaW5nX2V4biIsIm0iLCJwIiwic2VwIiwicCQxIiwicCQwIiwib2Zfc3RyaW5nIiwidG9fc3RyaW5nIiwib3B0Iiwic3RoIiwidG9fb2N0ZXRzIiwicHAiLCJwcGYiLCJicm9hZGNhc3QiLCJtYWtlX2xvY2FsIiwiYnl0ZWdlbmYiLCJnZXRfb3VpIiwiaXNfbG9jYWwiLCJpc191bmljYXN0Il0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbWFjYWRkci9tYWNhZGRyLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7O0dBaUJBOzs7Ozs7Ozs7SUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFFSUEsVUFBVUMsR0FBSSw2Q0FBSkEsR0FBc0M7WUFFaERDLGdCQUFnQkMsSUFBR0M7SUFDckIsSUFBSSxjQUFHLFdBRFdELElBQUdDLEtBQ2pCOzs7O1NBQTRCQztLQUFXLHdCQUFZLG9DQUF2QkE7O0dBQTJDO09BSXpFQztZQUdBQyxjQUFjTjtJQUNoQiwrQkFEZ0JBLElBRVgsT0FBQSw0QkFGV0E7SUFDYSxNQUFBO3lEQURiQTtHQUVNO1lBRXBCTyxVQUFVUCxHQUFJLE9BWmRDLGdCQVFBSyxlQUlVTixHQUFtQztZQUU3Q1EsZ0JBQWdCQztJQUNFLElBQWhCQyxNQUFnQiwyQkFERkQ7SUFF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T0F5REFnQjtPQUNBTTtPQU9BSTtPQUpBSDtPQUtBSTtPQUNBRTtPQUVBQztPQVNBRTtPQUNBQztPQUNBQztPQXZGQXBDOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgQW5pbCBNYWRoYXZhcGVkZHkgPGFuaWxAcmVjb2lsLm9yZz5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBEYXZpZCBTaGVldHMgPHNoZWV0c0BhbHVtLm1pdC5lZHU+XG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqKVxuXG5leGNlcHRpb24gUGFyc2VfZXJyb3Igb2Ygc3RyaW5nICogc3RyaW5nXG5cbmxldCBuZWVkX21vcmUgeCA9IFBhcnNlX2Vycm9yIChcIm5vdCBlbm91Z2ggZGF0YVwiLCB4KVxuXG5sZXQgdHJ5X3dpdGhfcmVzdWx0IGZuIGEgPVxuICB0cnkgT2sgKGZuIGEpIHdpdGggUGFyc2VfZXJyb3IgKG1zZywgXykgLT4gRXJyb3IgKGBNc2cgKFwiTWFjYWRkcjogXCIgXiBtc2cpKVxuXG50eXBlIHQgPSBCeXRlcy50ICgqIGxlbmd0aCA2IG9ubHkgKilcblxubGV0IGNvbXBhcmUgPSBCeXRlcy5jb21wYXJlXG5cbigqIFJhdyBNQUMgYWRkcmVzcyBvZmYgdGhlIHdpcmUgKG5ldHdvcmsgZW5kaWFuKSAqKVxubGV0IG9mX29jdGV0c19leG4geCA9XG4gIGlmIFN0cmluZy5sZW5ndGggeCA8PiA2IHRoZW4gcmFpc2UgKFBhcnNlX2Vycm9yIChcIk1BQyBpcyBleGFjdGx5IDYgYnl0ZXNcIiwgeCkpXG4gIGVsc2UgQnl0ZXMub2Zfc3RyaW5nIHhcblxubGV0IG9mX29jdGV0cyB4ID0gdHJ5X3dpdGhfcmVzdWx0IG9mX29jdGV0c19leG4geFxuXG5sZXQgaW50X29mX2hleF9jaGFyIGMgPVxuICBsZXQgYyA9IGludF9vZl9jaGFyIChDaGFyLnVwcGVyY2FzZV9hc2NpaSBjKSAtIDQ4IGluXG4gIGlmIGMgPiA5IHRoZW5cbiAgICBpZiBjID4gMTYgdGhlbiBjIC0gNyAoKiB1cHBlciBoZXggb2Zmc2V0ICopIGVsc2UgLTEgKCogOjs8PT4/QCAqKVxuICBlbHNlIGNcblxubGV0IGlzX2hleCBpID0gaSA+PSAwICYmIGkgPCAxNlxuXG5sZXQgYmFkX2NoYXIgaSBzID1cbiAgbGV0IG1zZyA9IFByaW50Zi5zcHJpbnRmIFwiaW52YWxpZCBjaGFyYWN0ZXIgJyVjJyBhdCAlZFwiIHMuW2ldIGkgaW5cbiAgUGFyc2VfZXJyb3IgKG1zZywgcylcblxubGV0IHBhcnNlX2hleF9pbnQgdGVybSBzIGkgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgaGV4IHByZXYgPVxuICAgIGxldCBqID0gIWkgaW5cbiAgICBpZiBqID49IGxlbiB0aGVuIHByZXZcbiAgICBlbHNlXG4gICAgICBsZXQgYyA9IHMuW2pdIGluXG4gICAgICBsZXQgayA9IGludF9vZl9oZXhfY2hhciBjIGluXG4gICAgICBpZiBpc19oZXggayB0aGVuIChcbiAgICAgICAgaW5jciBpO1xuICAgICAgICBoZXggKChwcmV2IGxzbCA0KSArIGspKVxuICAgICAgZWxzZSBpZiBMaXN0Lm1lbSBjIHRlcm0gdGhlbiBwcmV2XG4gICAgICBlbHNlIHJhaXNlIChiYWRfY2hhciBqIHMpXG4gIGluXG4gIGxldCBpID0gIWkgaW5cbiAgaWYgaSA8IGxlbiB0aGVuXG4gICAgaWYgaXNfaGV4IChpbnRfb2ZfaGV4X2NoYXIgcy5baV0pIHRoZW4gaGV4IDAgZWxzZSByYWlzZSAoYmFkX2NoYXIgaSBzKVxuICBlbHNlIHJhaXNlIChuZWVkX21vcmUgcylcblxubGV0IHBhcnNlX3NleHR1cGxlIHMgaSA9XG4gIGxldCBtID0gQnl0ZXMuY3JlYXRlIDYgaW5cbiAgdHJ5XG4gICAgbGV0IHAgPSAhaSBpblxuICAgIEJ5dGVzLnNldCBtIDAgKENoYXIuY2hyIChwYXJzZV9oZXhfaW50IFsgJzonOyAnLScgXSBzIGkpKTtcbiAgICBpZiAhaSA+PSBTdHJpbmcubGVuZ3RoIHMgdGhlbiByYWlzZSAobmVlZF9tb3JlIHMpXG4gICAgZWxzZVxuICAgICAgbGV0IHNlcCA9IFsgcy5bIWldIF0gaW5cbiAgICAgIGlmICFpIC0gcCA8PiAyIHRoZW4gcmFpc2UgKFBhcnNlX2Vycm9yIChcImhleCBwYWlycyByZXF1aXJlZFwiLCBzKSk7XG4gICAgICBpbmNyIGk7XG4gICAgICBmb3IgayA9IDEgdG8gNCBkb1xuICAgICAgICBsZXQgcCA9ICFpIGluXG4gICAgICAgIEJ5dGVzLnNldCBtIGsgKENoYXIuY2hyIChwYXJzZV9oZXhfaW50IHNlcCBzIGkpKTtcbiAgICAgICAgaWYgIWkgLSBwIDw+IDIgdGhlbiByYWlzZSAoUGFyc2VfZXJyb3IgKFwiaGV4IHBhaXJzIHJlcXVpcmVkXCIsIHMpKTtcbiAgICAgICAgaW5jciBpXG4gICAgICBkb25lO1xuICAgICAgbGV0IHAgPSAhaSBpblxuICAgICAgQnl0ZXMuc2V0IG0gNSAoQ2hhci5jaHIgKHBhcnNlX2hleF9pbnQgW10gcyBpKSk7XG4gICAgICBpZiAhaSAtIHAgPD4gMiB0aGVuIHJhaXNlIChQYXJzZV9lcnJvciAoXCJoZXggcGFpcnMgcmVxdWlyZWRcIiwgcykpO1xuICAgICAgbVxuICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPlxuICAgIHJhaXNlIChQYXJzZV9lcnJvciAoXCJhZGRyZXNzIHNlZ21lbnQgdG9vIGxhcmdlXCIsIHMpKVxuXG4oKiBSZWFkIGEgTUFDIGFkZHJlc3MgY29sb24tc2VwYXJhdGVkIHN0cmluZyAqKVxubGV0IG9mX3N0cmluZ19leG4geCA9IHBhcnNlX3NleHR1cGxlIHggKHJlZiAwKVxubGV0IG9mX3N0cmluZyB4ID0gdHJ5X3dpdGhfcmVzdWx0IG9mX3N0cmluZ19leG4geFxubGV0IGNocmkgeCBpID0gQ2hhci5jb2RlIChCeXRlcy5nZXQgeCBpKVxuXG5sZXQgdG9fc3RyaW5nID8oc2VwID0gJzonKSB4ID1cbiAgUHJpbnRmLnNwcmludGYgXCIlMDJ4JWMlMDJ4JWMlMDJ4JWMlMDJ4JWMlMDJ4JWMlMDJ4XCIgKGNocmkgeCAwKSBzZXAgKGNocmkgeCAxKVxuICAgIHNlcCAoY2hyaSB4IDIpIHNlcCAoY2hyaSB4IDMpIHNlcCAoY2hyaSB4IDQpIHNlcCAoY2hyaSB4IDUpXG5cbmxldCB0b19vY3RldHMgeCA9IEJ5dGVzLnRvX3N0cmluZyB4XG5sZXQgcHAgcHBmIGkgPSBGb3JtYXQuZnByaW50ZiBwcGYgXCIlc1wiICh0b19zdHJpbmcgaSlcbmxldCBicm9hZGNhc3QgPSBCeXRlcy5tYWtlIDYgJ1xcMjU1J1xuXG5sZXQgbWFrZV9sb2NhbCBieXRlZ2VuZiA9XG4gIGxldCB4ID0gQnl0ZXMuY3JlYXRlIDYgaW5cbiAgKCogc2V0IGxvY2FsbHkgYWRtaW5pc3RlcmVkIGFuZCB1bmljYXN0IGJpdHMgKilcbiAgQnl0ZXMuc2V0IHggMCAoQ2hhci5jaHIgKCgoYnl0ZWdlbmYgMCBsb3IgMikgbHNyIDEpIGxzbCAxKSk7XG4gIGZvciBpID0gMSB0byA1IGRvXG4gICAgQnl0ZXMuc2V0IHggaSAoQ2hhci5jaHIgKGJ5dGVnZW5mIGkpKVxuICBkb25lO1xuICB4XG5cbmxldCBnZXRfb3VpIHggPSAoY2hyaSB4IDAgbHNsIDE2KSBsb3IgKGNocmkgeCAxIGxzbCA4KSBsb3IgY2hyaSB4IDJcbmxldCBpc19sb2NhbCB4ID0gKGNocmkgeCAwIGxzciAxKSBsYW5kIDEgPSAxXG5sZXQgaXNfdW5pY2FzdCB4ID0gY2hyaSB4IDAgbGFuZCAxID0gMFxuIl19
