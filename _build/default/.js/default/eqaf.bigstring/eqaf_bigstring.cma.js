// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Eqaf_bigstring
//# unitInfo: Requires: Eqaf, Stdlib, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_uint8_get16 = runtime.caml_ba_uint8_get16;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Eqaf = global_data.Eqaf,
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_compare_be_with_len = "compare_be_with_len",
    cst_compare_le_with_len = "compare_le_with_len";
   function equal(a, b){
    var al = caml_ba_dim_1(a), bl = caml_ba_dim_1(b);
    if(al !== bl) return 0;
    var l1 = al >> 1, r = [0, 0], _j_ = l1 - 1 | 0, _i_ = 0;
    if(_j_ >= 0){
     var i = _i_;
     for(;;){
      var
       _p_ = caml_ba_uint8_get16(b, i * 2 | 0),
       _q_ = caml_ba_uint8_get16(a, i * 2 | 0) ^ _p_;
      r[1] = r[1] | _q_;
      var _r_ = i + 1 | 0;
      if(_j_ === i) break;
      var i = _r_;
     }
    }
    var _l_ = al & 1, _k_ = 1;
    if(_l_ >= 1){
     var for$0 = _k_;
     for(;;){
      var
       _m_ = caml_ba_get_1(b, al - 1 | 0),
       _n_ = caml_ba_get_1(a, al - 1 | 0) ^ _m_;
      r[1] = r[1] | _n_;
      var _o_ = for$0 + 1 | 0;
      if(_l_ === for$0) break;
      var for$0 = _o_;
     }
    }
    return 0 === r[1] ? 1 : 0;
   }
   function sixteen_if_minus_one_or_less(n){return n >> Stdlib_Sys[10] & 16;}
   function eight_if_one_or_more(n){return (- n | 0) >> Stdlib_Sys[10] & 8;}
   function _a_(ln, a, b){
    var r = [0, 0], i = [0, ln - 1 | 0];
    for(;;){
     if(0 > i[1]) return (r[1] & 8) - (r[1] & 16) | 0;
     var
      xa = caml_ba_get_1(a, i[1]),
      xb = caml_ba_get_1(b, i[1]),
      c = xa - xb | 0,
      _f_ = r[1],
      _g_ = eight_if_one_or_more(c),
      _h_ = (sixteen_if_minus_one_or_less(c) + _g_ | 0) >>> _f_ | 0;
     r[1] = r[1] | _h_;
     i[1] += -1;
    }
   }
   function compare_le_with_len(ln, a, b){
    var al = caml_ba_dim_1(a), bl = caml_ba_dim_1(b);
    return 0 === ln
            ? 0
            : 0
              === (al ^ ln | bl ^ ln)
              ? _a_(ln, a, b)
              : caml_call1(Stdlib[1], cst_compare_le_with_len);
   }
   function compare_le(a, b){
    var al = caml_ba_dim_1(a), bl = caml_ba_dim_1(b);
    return al < bl ? 1 : bl < al ? -1 : _a_(al, a, b);
   }
   function _b_(ln, a, b){
    var r = [0, 0], i = [0, 0];
    for(;;){
     if(i[1] >= ln) return (r[1] & 8) - (r[1] & 16) | 0;
     var
      xa = caml_ba_get_1(a, i[1]),
      xb = caml_ba_get_1(b, i[1]),
      c = xa - xb | 0,
      _c_ = r[1],
      _d_ = eight_if_one_or_more(c),
      _e_ = (sixteen_if_minus_one_or_less(c) + _d_ | 0) >>> _c_ | 0;
     r[1] = r[1] | _e_;
     i[1]++;
    }
   }
   function compare_be_with_len(ln, a, b){
    var al = caml_ba_dim_1(a), bl = caml_ba_dim_1(b);
    return 0 === ln
            ? 0
            : 0
              === (al ^ ln | bl ^ ln)
              ? _b_(ln, a, b)
              : caml_call1(Stdlib[1], cst_compare_be_with_len);
   }
   function compare_be(a, b){
    var al = caml_ba_dim_1(a), bl = caml_ba_dim_1(b);
    return al < bl ? 1 : bl < al ? -1 : _b_(al, a, b);
   }
   function find_uint8(opt, f, str){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    var
     len = caml_ba_dim_1(str),
     i = [0, len - 1 | 0],
     a = [0, caml_call1(Stdlib[21], 0)];
    for(;;){
     if(off > i[1]) return a[1];
     var byte$0 = caml_ba_get_1(str, i[1]), pred = caml_call1(f, byte$0);
     a[1] =
      caml_call3(Eqaf[20], (i[1] - off | 0) & Stdlib[20] | pred, a[1], i[1]);
     i[1] += -1;
    }
   }
   function exists_uint8(off, f, str){
    var
     v = find_uint8(off, f, str),
     r = caml_call3(Eqaf[20], v + 1 | 0, 0, 1);
    return r;
   }
   var
    Eqaf_bigstring =
      [0,
       equal,
       compare_be,
       compare_be_with_len,
       compare_le,
       compare_le_with_len,
       find_uint8,
       exists_uint8];
   runtime.caml_register_global(5, Eqaf_bigstring, "Eqaf_bigstring");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJlcWFmX2JpZ3N0cmluZy5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZXF1YWwiLCJhIiwiYiIsImFsIiwiYmwiLCJsMSIsInIiLCJpIiwic2l4dGVlbl9pZl9taW51c19vbmVfb3JfbGVzcyIsIm4iLCJlaWdodF9pZl9vbmVfb3JfbW9yZSIsImxuIiwieGEiLCJ4YiIsImMiLCJjb21wYXJlX2xlX3dpdGhfbGVuIiwiY29tcGFyZV9sZSIsImNvbXBhcmVfYmVfd2l0aF9sZW4iLCJjb21wYXJlX2JlIiwiZmluZF91aW50OCIsIm9wdCIsImYiLCJzdHIiLCJzdGgiLCJvZmYiLCJsZW4iLCJieXRlJDAiLCJwcmVkIiwiZXhpc3RzX3VpbnQ4IiwidiJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL2JvbnNhaS9saWIvZXFhZi9iaWdzdHJpbmcvZXFhZl9iaWdzdHJpbmcubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7O1lBY0lBLE1BQU1DLEdBQUVDO0lBQ1YsSUFSU0MsS0FRQSxjQURERixJQUVKRyxLQUFLLGNBRkNGO09BUERDLE9BU0xDLElBRUM7SUFURyxJQURKQyxLQURLRixTQUVMRyxZQUNKLE1BRklELFlBQ0k7O1NBQ1JFOztNQUEwRDtPQUFBLE1BQUEsb0JBSWhETCxHQUpWSztPQUFxQyxNQUFBLG9CQUk3Qk4sR0FKUk07TUFESUQsT0FBQUE7TUFDSixVQUFBQztpQkFBQUE7VUFBQUE7OztJQUNBLFVBSlNKLFFBSVQ7Ozs7TUFBMkQ7T0FBQSxNQUFBLGNBR2pERCxHQVBEQztPQUk4QixNQUFBLGNBRy9CRixHQVBDRTtNQUVMRyxPQUFBQTtNQUVKOzs7OztpQkFGSUE7R0FVaUI7WUFHSEUsNkJBQTZCQyxHQUFJLE9BQUpBLHlCQUFnQztZQUM3REMscUJBQXFCRCxHQUFJLFVBQUpBLDZCQUFrQztnQkFFM0RFLElBQUdWLEdBQUVDO0lBQ25CLElBQUlJLFlBQ0FDLFFBRlVJOztZQUVWSixjQURBRCxhQUFBQTtLQUlPO01BQUxNLEtBQUssY0FMTVgsR0FFYk07TUFHb0JNLEtBQUssY0FMVlgsR0FFZks7TUFJRU8sSUFEQUYsS0FBa0JDO01BRXRCLE1BTkVQO01BTTZDLE1BVC9CSSxxQkFRWkk7YUFUWU4sNkJBU1pNO0tBTEZSLE9BQUFBO0tBQ0FDOztHQVNzQjtZQUV4QlEsb0JBQXlCSixJQUFHVixHQUFFQztJQUNoQyxJQUFJQyxLQUFLLGNBRHFCRixJQUUxQkcsS0FBSyxjQUZ1QkY7SUFHaEMsYUFIMkJTOzs7bUJBQ3ZCUixLQUR1QlEsS0FFdkJQLEtBRnVCTztvQkFBQUEsSUFBR1YsR0FBRUM7Z0JBSzNCO0dBQ2tCO1lBRXJCYyxXQUFXZixHQUFFQztJQUNmLElBQUlDLEtBQUssY0FESUYsSUFFVEcsS0FBSyxjQUZNRjtXQUNYQyxLQUNBQyxTQUFBQSxLQURBRCxjQUFBQSxJQURTRixHQUFFQztHQU9zQjtnQkFFdkJTLElBQUdWLEdBQUVDO0lBQ25CLElBQUlJLFlBQ0FDOztRQUFBQSxRQUZVSSxZQUNWTCxhQUFBQTtLQUlPO01BQUxNLEtBQUssY0FMTVgsR0FFYk07TUFHb0JNLEtBQUssY0FMVlgsR0FFZks7TUFJRU8sSUFEQUYsS0FBa0JDO01BRXRCLE1BTkVQO01BTTZDLE1BdkMvQkkscUJBc0NaSTthQXZDWU4sNkJBdUNaTTtLQUxGUixPQUFBQTtLQUNBQzs7R0FTc0I7WUFFeEJVLG9CQUF5Qk4sSUFBR1YsR0FBRUM7SUFDaEMsSUFBSUMsS0FBSyxjQURxQkYsSUFFMUJHLEtBQUssY0FGdUJGO0lBR2hDLGFBSDJCUzs7O21CQUN2QlIsS0FEdUJRLEtBRXZCUCxLQUZ1Qk87b0JBQUFBLElBQUdWLEdBQUVDO2dCQUszQjtHQUNrQjtZQUVyQmdCLFdBQVdqQixHQUFFQztJQUNmLElBQUlDLEtBQUssY0FESUYsSUFFVEcsS0FBSyxjQUZNRjtXQUNYQyxLQUNBQyxTQUFBQSxLQURBRCxjQUFBQSxJQURTRixHQUFFQztHQUtzQjtZQWlCbkNpQixXQUFhQyxLQUFTQyxHQUFFQztJQUMxQixHQURlRixTQUFLRyxNQUFMSCxRQVZlSSxNQVVWRCxjQVZVQztJQVdwQjtLQVh5QkMsTUFXekIsY0FEZ0JIO0tBVHRCZixRQUQrQmtCO0tBRS9CeEIsUUFBUTs7UUFGa0J1QixNQUMxQmpCLGFBQ0FOO0tBRVMsSUFBUHlCLFNBQU8sY0FNYUosS0FUdEJmLE9BSUVvQixPQUFtQixXQUtETixHQU5sQks7S0FGRnpCO01BSUcsc0JBTEhNLE9BRDBCaUIsd0JBS3hCRyxNQUhGMUIsTUFEQU07S0FBQUE7O0dBV3VCO1lBRXpCcUIsYUFBY0osS0FBS0gsR0FBRUM7SUFDdkI7S0FBSU8sSUFMRlYsV0FJY0ssS0FBS0gsR0FBRUM7S0FFbkJoQixJQUFJLHFCQURKdUI7SUFFSixPQURJdkI7R0FDZ0I7Ozs7T0EzRmxCTjtPQThEQWtCO09BUkFEO09BdEJBRDtPQVJBRDtPQTREQUk7T0FJQVM7OztFIiwic291cmNlc0NvbnRlbnQiOlsidHlwZSBiaWdzdHJpbmcgPSAoY2hhciwgQmlnYXJyYXkuaW50OF91bnNpZ25lZF9lbHQsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5BcnJheTEudFxuXG5sZXQgbGVuZ3RoIHggPSBCaWdhcnJheS5BcnJheTEuZGltIHggW0BAaW5saW5lXVxubGV0IGdldCB4IGkgPSBCaWdhcnJheS5BcnJheTEudW5zYWZlX2dldCB4IGkgfD4gQ2hhci5jb2RlIFtAQGlubGluZV1cbmV4dGVybmFsIHVuc2FmZV9nZXRfaW50MTYgOiBiaWdzdHJpbmcgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYmlnc3RyaW5nX2dldDE2dVwiIFtAQG5vYWxsb2NdXG5sZXQgZ2V0MTYgeCBpID0gdW5zYWZlX2dldF9pbnQxNiB4IGkgW0BAaW5saW5lXVxuXG5sZXQgZXF1YWwgfmxuIGEgYiA9XG4gIGxldCBsMSA9IGxuIGFzciAxIGluXG4gIGxldCByID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIHByZWQgbDEgZG8gciA6PSAhciBsb3IgKGdldDE2IGEgKGkgKiAyKSBseG9yIGdldDE2IGIgKGkgKiAyKSkgZG9uZSA7XG4gIGZvciBfID0gMSB0byBsbiBsYW5kIDEgZG8gciA6PSAhciBsb3IgKGdldCBhIChsbiAtIDEpIGx4b3IgZ2V0IGIgKGxuIC0gMSkpIGRvbmUgO1xuICAhciA9IDBcblxubGV0IGVxdWFsIGEgYiA9XG4gIGxldCBhbCA9IGxlbmd0aCBhIGluXG4gIGxldCBibCA9IGxlbmd0aCBiIGluXG4gIGlmIGFsIDw+IGJsXG4gIHRoZW4gZmFsc2VcbiAgZWxzZSBlcXVhbCB+bG46YWwgYSBiXG5cbmxldFtAaW5saW5lIGFsd2F5c10gY29tcGFyZSAoYTppbnQpIGIgPSBhIC0gYlxubGV0W0BpbmxpbmUgYWx3YXlzXSBzaXh0ZWVuX2lmX21pbnVzX29uZV9vcl9sZXNzIG4gPSAobiBhc3IgU3lzLmludF9zaXplKSBsYW5kIDE2XG5sZXRbQGlubGluZSBhbHdheXNdIGVpZ2h0X2lmX29uZV9vcl9tb3JlIG4gPSAoKC1uKSBhc3IgU3lzLmludF9zaXplKSBsYW5kIDhcblxubGV0IGNvbXBhcmVfbGUgfmxuIGEgYiA9XG4gIGxldCByID0gcmVmIDAgaW5cbiAgbGV0IGkgPSByZWYgKHByZWQgbG4pIGluXG5cbiAgd2hpbGUgIWkgPj0gMCBkb1xuICAgIGxldCB4YSA9IGdldCBhICFpIGFuZCB4YiA9IGdldCBiICFpIGluXG4gICAgbGV0IGMgPSBjb21wYXJlIHhhIHhiIGluXG4gICAgciA6PSAhciBsb3IgKChzaXh0ZWVuX2lmX21pbnVzX29uZV9vcl9sZXNzIGMgKyBlaWdodF9pZl9vbmVfb3JfbW9yZSBjKSBsc3IgIXIpIDtcbiAgICBkZWNyIGkgO1xuICBkb25lIDtcblxuICAoIXIgbGFuZCA4KSAtICghciBsYW5kIDE2KVxuXG5sZXQgY29tcGFyZV9sZV93aXRoX2xlbiB+bGVuOmxuIGEgYiA9XG4gIGxldCBhbCA9IGxlbmd0aCBhIGluXG4gIGxldCBibCA9IGxlbmd0aCBiIGluXG4gIGlmIGxuID0gMCB0aGVuIDBcbiAgZWxzZSBpZiAoYWwgbHhvciBsbikgbG9yIChibCBseG9yIGxuKSA8PiAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJjb21wYXJlX2xlX3dpdGhfbGVuXCJcbiAgZWxzZSBjb21wYXJlX2xlIH5sbiBhIGJcblxubGV0IGNvbXBhcmVfbGUgYSBiID1cbiAgbGV0IGFsID0gbGVuZ3RoIGEgaW5cbiAgbGV0IGJsID0gbGVuZ3RoIGIgaW5cbiAgaWYgYWwgPCBibFxuICB0aGVuIDFcbiAgZWxzZSBpZiBhbCA+IGJsXG4gIHRoZW4gKC0xKVxuICBlbHNlIGNvbXBhcmVfbGUgfmxuOmFsICgqID0gYmwgKikgYSBiXG5cbmxldCBjb21wYXJlX2JlIH5sbiBhIGIgPVxuICBsZXQgciA9IHJlZiAwIGluXG4gIGxldCBpID0gcmVmIDAgaW5cblxuICB3aGlsZSAhaSA8IGxuIGRvXG4gICAgbGV0IHhhID0gZ2V0IGEgIWkgYW5kIHhiID0gZ2V0IGIgIWkgaW5cbiAgICBsZXQgYyA9IGNvbXBhcmUgeGEgeGIgaW5cbiAgICByIDo9ICFyIGxvciAoKHNpeHRlZW5faWZfbWludXNfb25lX29yX2xlc3MgYyArIGVpZ2h0X2lmX29uZV9vcl9tb3JlIGMpIGxzciAhcikgO1xuICAgIGluY3IgaSA7XG4gIGRvbmUgO1xuXG4gICghciBsYW5kIDgpIC0gKCFyIGxhbmQgMTYpXG5cbmxldCBjb21wYXJlX2JlX3dpdGhfbGVuIH5sZW46bG4gYSBiID1cbiAgbGV0IGFsID0gbGVuZ3RoIGEgaW5cbiAgbGV0IGJsID0gbGVuZ3RoIGIgaW5cbiAgaWYgbG4gPSAwIHRoZW4gMFxuICBlbHNlIGlmIChhbCBseG9yIGxuKSBsb3IgKGJsIGx4b3IgbG4pIDw+IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcImNvbXBhcmVfYmVfd2l0aF9sZW5cIlxuICBlbHNlIGNvbXBhcmVfYmUgfmxuIGEgYlxuXG5sZXQgY29tcGFyZV9iZSBhIGIgPVxuICBsZXQgYWwgPSBsZW5ndGggYSBpblxuICBsZXQgYmwgPSBsZW5ndGggYiBpblxuICBpZiBhbCA8IGJsIHRoZW4gMVxuICBlbHNlIGlmIGFsID4gYmwgdGhlbiAoLTEpXG4gIGVsc2UgY29tcGFyZV9iZSB+bG46YWwgKCogPSBibCAqKSBhIGJcblxuKCogWFhYKGRpbm9zYXVyZSk6IHNlZSBbZXFhZi5tbF0gZm9yIHRoaXMgcGFydC4gKilcblxuZXh0ZXJuYWwgaW50X29mX2Jvb2wgOiBib29sIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9ib29sX29mX2ludCA6IGludCAtPiBib29sID0gXCIlaWRlbnRpdHlcIlxuXG5sZXRbQGlubGluZSBhbHdheXNdIGZpbmRfdWludDggfm9mZiB+bGVuIH5mIHN0ciA9XG4gIGxldCBpID0gcmVmIChsZW4gLSAxKSBpblxuICBsZXQgYSA9IHJlZiAobG5vdCAwKSBpblxuICB3aGlsZSAhaSA+PSBvZmYgZG9cbiAgICBsZXQgYnl0ZSA9IGdldCBzdHIgIWkgaW5cbiAgICBsZXQgcHJlZCA9IGludF9vZl9ib29sIChmIGJ5dGUpIGluXG4gICAgYSA6PSBFcWFmLnNlbGVjdF9pbnQgKCgoIWkgLSBvZmYpIGxhbmQgbWluX2ludCkgbG9yIHByZWQpICFhICFpIDtcbiAgICBkZWNyIGkgO1xuICBkb25lIDsgIWFcblxubGV0IGZpbmRfdWludDggPyhvZmY9IDApIH5mIHN0ciA9XG4gIGxldCBsZW4gPSBsZW5ndGggc3RyIGluXG4gIGZpbmRfdWludDggfm9mZiB+bGVuIH5mIHN0clxuXG5sZXQgZXhpc3RzX3VpbnQ4ID9vZmYgfmYgc3RyID1cbiAgbGV0IHYgPSBmaW5kX3VpbnQ4ID9vZmYgfmYgc3RyIGluXG4gIGxldCByID0gRXFhZi5zZWxlY3RfaW50ICh2ICsgMSkgMCAxIGluXG4gIHVuc2FmZV9ib29sX29mX2ludCByXG4iXX0=
