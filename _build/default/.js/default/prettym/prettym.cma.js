// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Prettym__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Prettym = [0];
   runtime.caml_register_global(0, Prettym, "Prettym__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Prettym__Enclosure
//# unitInfo: Requires: Bigstringaf, Fmt, Ke__Fke, Overlap, Stdlib, Stdlib__Array, Stdlib__Bigarray, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$3 = " ",
    cst$2 = "  ",
    cst$1 = " }",
    cst_hov = "<hov>",
    cst$0 = "@ ",
    cst$4 = "@,",
    cst_lib_enclosure_ml = "lib/enclosure.ml",
    cst = "{ ",
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_sub = runtime.caml_ba_sub,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call10(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    return (f.l >= 0 ? f.l : f.l = f.length) == 10
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    partial =
      [4,
       0,
       0,
       0,
       [12,
        59,
        [17,
         [0, cst$0, 1, 0],
         [11,
          "received= ",
          [4,
           0,
           0,
           0,
           [12,
            59,
            [17,
             [0, cst$0, 1, 0],
             [11, "emitter= #emitter;", [17, 0, [11, cst$1, 0]]]]]]]]]],
    partial$0 =
      [15,
       [17,
        0,
        [12,
         59,
         [17,
          [0, cst$0, 1, 0],
          [11,
           "flush= ",
           [18,
            [1, [0, [11, cst_hov, 0], cst_hov]],
            [15,
             [17,
              0,
              [12, 59, [17, [0, cst$0, 1, 0], [11, "written= ", partial]]]]]]]]]]],
    partial$1 = [1, [0, [11, cst_hov, 0], cst_hov]],
    partial$2 =
      [12,
       59,
       [17,
        [0, cst$0, 1, 0],
        [11, "len= ", [4, 0, 0, 0, [12, 59, [17, 0, [11, cst$1, 0]]]]]]],
    partial$3 =
      [11,
       "m = ",
       [4,
        0,
        0,
        0,
        [12,
         59,
         [17,
          [0, cst$0, 1, 0],
          [11, "q = ", [15, [12, 59, [17, 0, [11, cst$1, 0]]]]]]]]],
    partial$4 = [0, cst$0, 1, 0],
    deadbeef = "\xde\xad\xbe\xef",
    Ke_Fke = global_data.Ke__Fke,
    Assert_failure = global_data.Assert_failure,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Overlap = global_data.Overlap,
    Fmt = global_data.Fmt,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    _Q_ = [0, 8],
    _R_ = [0, 0],
    _P_ = [0, cst_lib_enclosure_ml, 504, 6],
    _O_ = [0, cst_lib_enclosure_ml, 505, 6],
    _M_ = [0, 4],
    _N_ = [0, 0],
    _L_ = [0, cst_lib_enclosure_ml, 493, 6],
    _K_ = [0, cst_lib_enclosure_ml, 494, 6],
    _I_ = [0, 2],
    _J_ = [0, 0],
    _H_ = [0, cst_lib_enclosure_ml, 482, 6],
    _G_ = [0, cst_lib_enclosure_ml, 483, 6],
    _F_ = [0, cst_lib_enclosure_ml, 477, 18],
    _D_ = [0, 1],
    _E_ = [0, 0],
    _C_ = [0, cst_lib_enclosure_ml, 451, 4],
    _B_ = [0, cst_lib_enclosure_ml, 452, 4],
    _A_ = [0, cst_lib_enclosure_ml, 449, 17],
    _y_ = [0, 1],
    _z_ = [0, 0],
    _x_ = [0, cst_lib_enclosure_ml, 440, 4],
    _w_ = [0, cst_lib_enclosure_ml, 441, 4],
    _v_ = [0, cst_lib_enclosure_ml, 438, 17],
    _r_ =
      [0,
       [11,
        cst,
        [18,
         [1, [0, [11, cst_hov, 0], cst_hov]],
         [11,
          "sched= ",
          [18,
           [1, [0, [11, cst_hov, 0], cst_hov]],
           [15,
            [17,
             0,
             [12,
              59,
              [17,
               [0, cst$0, 1, 0],
               [11, "write= ", [18, partial$1, partial$0]]]]]]]]]],
       "{ @[<hov>sched= @[<hov>%a@];@ write= @[<hov>%a@];@ flush= @[<hov>%a@];@ written= %d;@ received= %d;@ emitter= #emitter;@] }"],
    cst_flush = "#flush",
    _q_ = [0, cst_lib_enclosure_ml, 162, 8],
    _p_ = [0, cst_lib_enclosure_ml, 154, 4],
    _o_ = [0, cst_lib_enclosure_ml, 150, 4],
    _l_ =
      [0,
       [11,
        cst,
        [18,
         [1, [0, [11, cst_hov, 0], cst_hov]],
         [11,
          "buffer= ",
          [18,
           [1, [0, [11, cst_hov, 0], cst_hov]],
           [15,
            [17,
             0,
             [12,
              59,
              [17, [0, cst$0, 1, 0], [11, "off= ", [4, 0, 0, 0, partial$2]]]]]]]]]],
       "{ @[<hov>buffer= @[<hov>%a@];@ off= %d;@ len= %d;@] }"],
    _d_ = [0, [4, 6, [0, 2, 8], 0, [11, ": ", 0]], "%08x: "],
    _i_ = [0, [4, 6, [0, 2, 2], 0, 0], "%02x"],
    _k_ = [0, [11, cst$2, 0], cst$2],
    _j_ = [0, [12, 32, 0], cst$3],
    _e_ = [0, [11, cst$2, 0], cst$2],
    _g_ = [0, [15, 0], "%a"],
    _h_ = [0, [12, 32, 0], cst$3],
    _f_ = [0, [17, [0, cst$4, 0, 0], 0], cst$4],
    _a_ =
      [0,
       [11,
        cst,
        [18,
         [1, [0, [11, cst_hov, 0], cst_hov]],
         [11,
          "a = ",
          [15,
           [12,
            59,
            [17,
             [0, cst$0, 1, 0],
             [11, "c = ", [4, 0, 0, 0, [12, 59, [17, partial$4, partial$3]]]]]]]]]],
       "{ @[<hov>a = %a;@ c = %d;@ m = %d;@ q = %a;@] }"],
    cst_Prettym_Enclosure_RBQ_V_Fu = "Prettym__Enclosure.RBQ(V).Full",
    _b_ = Fmt[56];
   function _c_(x){return 94 < x - 32 >>> 0 ? 46 : x;}
   var pp_chr = caml_call2(Fmt[19], _c_, _b_);
   function pp_scalar(get, length, ppf, b){
    var l = caml_call1(length, b), _bj_ = l / 16 | 0, _bi_ = 0;
    if(_bj_ >= 0){
     var i = _bi_;
     for(;;){
      caml_call3(Fmt[3], ppf, _d_, i * 16 | 0);
      var j = [0, 0];
      for(;;){
       if(16 <= j[1]) break;
       if(((i * 16 | 0) + j[1] | 0) < l){
        var _bm_ = caml_call2(get, b, (i * 16 | 0) + j[1] | 0);
        caml_call3(Fmt[3], ppf, _i_, _bm_);
       }
       else
        caml_call2(Fmt[3], ppf, _k_);
       if(0 !== (j[1] % 2 | 0)) caml_call2(Fmt[3], ppf, _j_);
       j[1]++;
      }
      caml_call2(Fmt[3], ppf, _e_);
      j[1] = 0;
      for(;;){
       if(16 <= j[1]) break;
       if(((i * 16 | 0) + j[1] | 0) < l){
        var _bl_ = caml_call2(get, b, (i * 16 | 0) + j[1] | 0);
        caml_call4(Fmt[3], ppf, _g_, pp_chr, _bl_);
       }
       else
        caml_call2(Fmt[3], ppf, _h_);
       j[1]++;
      }
      caml_call2(Fmt[3], ppf, _f_);
      var _bk_ = i + 1 | 0;
      if(_bj_ === i) break;
      var i = _bk_;
     }
    }
    return 0;
   }
   function pp$0(ppf, param){
    switch(param[0]){
      case 0:
       var x = param[1];
       return pp_scalar(runtime.caml_ba_get_1, Bigstringaf[6], ppf, x);
      case 1:
       var x$0 = param[1];
       return pp_scalar
               (runtime.caml_string_get, caml_ml_string_length, ppf, x$0);
      default:
       var x$1 = param[1];
       return pp_scalar
               (runtime.caml_bytes_get, caml_ml_bytes_length, ppf, x$1);
    }
   }
   function weight(param){
    switch(param[0]){
      case 0:
       var x = param[1]; return caml_call1(Bigstringaf[6], x);
      case 1:
       var x$0 = param[1]; return caml_ml_string_length(x$0);
      default: var x$1 = param[1]; return caml_ml_bytes_length(x$1);
    }
   }
   function sub(buffer, off, len){
    switch(buffer[0]){
      case 0:
       var x = buffer[1]; return [0, caml_call3(Bigstringaf[5], x, off, len)];
      case 1:
       var x$0 = buffer[1];
       return [1, caml_call3(Stdlib_String[16], x$0, off, len)];
      default:
       var x$1 = buffer[1];
       return [2, caml_call3(Stdlib_Bytes[7], x$1, off, len)];
    }
   }
   function weight$0(param){var len = param[3]; return len;}
   function pp$1(ppf, t){
    return caml_call6(Fmt[3], ppf, _l_, pp$0, t[1], t[2], t[3]);
   }
   var sentinel = [0, [1, deadbeef], 0, 4];
   function length(param){var len = param[3]; return len;}
   var _m_ = 0;
   function _n_(a, x){return x[3] + a | 0;}
   var lengthv = caml_call2(Stdlib_List[26], _n_, _m_);
   function shift(param, n){
    var len = param[3], off = param[2], buffer = param[1];
    if(n <= len) return [0, buffer, off + n | 0, len - n | 0];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
   }
   function split(param, n){
    var len = param[3], off = param[2], buffer = param[1];
    if(n > len)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _bh_ = [0, sub(buffer, off + n | 0, len - n | 0), 0, len - n | 0];
    return [0, [0, sub(buffer, off, n), 0, n], _bh_];
   }
   function merge(a, b){
    var _bg_ = a[1];
    switch(_bg_[0]){
      case 0:
       var a$0 = _bg_[1];
       if(0 === b[1][0])
        return (a[2] + a[3] | 0) === b[2]
                ? [0, [0, [0, a$0], a[2], a[3] + b[3] | 0]]
                : 0;
       break;
      case 1: break;
      default:
       var match = b[1], a$1 = _bg_[1];
       if(2 === match[0]){
        var b$0 = match[1];
        if(a$1 === b$0)
         return (a[2] + a[3] | 0) === b[2]
                 ? [0, [0, [2, a$1], a[2], a[3] + b[3] | 0]]
                 : 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
       }
    }
    return 0;
   }
   function pp(ppf, t){
    var
     a = caml_make_vect(caml_call1(Ke_Fke[18][5], t[4]), sentinel),
     x = [0, 0],
     _a9_ = t[4];
    function _a__(i){
     var _be_ = caml_check_bound(t[1], i)[1 + i], _bf_ = x[1];
     caml_check_bound(a, _bf_)[1 + _bf_] = _be_;
     x[1]++;
     return 0;
    }
    caml_call2(Ke_Fke[18][18], _a__, _a9_);
    var
     _a$_ = t[4],
     _ba_ = caml_call1(Ke_Fke[18][22], Fmt[45]),
     _bb_ = t[3],
     _bc_ = t[2],
     _bd_ = caml_call1(Fmt[70][8], pp$1);
    return caml_call8(Fmt[3], ppf, _a_, _bd_, a, _bc_, _bb_, _ba_, _a$_);
   }
   function mask(x, t){return x & (t[3] - 1 | 0);}
   var
    Full = [248, cst_Prettym_Enclosure_RBQ_V_Fu, runtime.caml_fresh_oo_id(0)];
   function pp_flush(ppf, param){return caml_call2(Fmt[57], ppf, cst_flush);}
   function pp$2(ppf, t){
    var
     _a3_ = t[5],
     _a4_ = t[4],
     _a5_ = t[3],
     _a6_ = caml_call2(Ke_Fke[16], 0, pp_flush),
     _a7_ = t[2],
     _a8_ = caml_call2(Ke_Fke[18][21], 0, pp_chr);
    return caml_call10
            (Fmt[3], ppf, _r_, pp, t[1], _a8_, _a7_, _a6_, _a5_, _a4_, _a3_);
   }
   function is_empty(t){
    var t$0 = t[1];
    return caml_call1(Ke_Fke[18][3], t$0[4]);
   }
   function create(emitter, len){
    var
     write = caml_call2(Ke_Fke[18][4], [0, len], 12)[1],
     capacity$0 = len * 2 | 0,
     _a2_ = Ke_Fke[2],
     match = caml_call2(Ke_Fke[18][4], [0, capacity$0], 8),
     capacity = match[2],
     q = match[1];
    return [0,
            [0, caml_make_vect(capacity, sentinel), 0, capacity, q],
            write,
            _a2_,
            0,
            0,
            emitter];
   }
   function check(iovec, param){
    var write = param[2], match = iovec[1];
    if(0 !== match[0]) return 0;
    var x = match[1], buf = caml_call1(Ke_Fke[18][23], write);
    return caml_call2(Overlap[3], x, buf) ? 1 : 0;
   }
   function flush(k, t$6){
    var t$1 = t$6[1], _aG_ = t$1[4], _aH_ = 0;
    function _aI_(a, i){return a + caml_check_bound(t$1[1], i)[1 + i][3] | 0;}
    var written = caml_call3(Ke_Fke[18][20], _aI_, _aH_, _aG_);
    function go(t){
     try{
      var
       _aZ_ = caml_call1(Ke_Fke[10], t[3]),
       flush = _aZ_[2],
       match = _aZ_[1],
       f = match[2],
       threshold = match[1],
       _a0_ =
         0
          <=
           runtime.caml_int_compare
            ((t[4] + written | 0) - Stdlib[20] | 0,
             threshold - Stdlib[20] | 0)
          ? (caml_call2
             (f, written, [0, t[1], t[2], flush, t[4], t[5], t[6]]),
            go([0, t[1], t[2], flush, t[4], t[5], t[6]]))
          : t;
      return _a0_;
     }
     catch(_a1_){
      var _aY_ = caml_wrap_exception(_a1_);
      if(_aY_ === Ke_Fke[1]) return t;
      throw caml_maybe_attach_backtrace(_aY_, 0);
     }
    }
    var t$0 = go(t$6), t$7 = t$0[1], res = [0, 0], _aJ_ = t$7[4];
    function _aK_(i){
     var _aX_ = res[1];
     res[1] = [0, caml_check_bound(t$7[1], i)[1 + i], _aX_];
     return 0;
    }
    caml_call2(Ke_Fke[18][19], _aK_, _aJ_);
    var drain = caml_call1(t$0[6], res[1]);
    a:
    {
     var rest = drain, t$2 = t$0;
     for(;;){
      try{
       var
        t$3 = t$2[1],
        match = caml_call1(Ke_Fke[18][10], t$3[4]),
        q = match[2],
        i = match[1],
        shifted = [0, t$3[1], t$3[2], t$3[3], q],
        iovec = caml_check_bound(t$3[1], i)[1 + i];
      }
      catch(_aW_){
       var _aL_ = caml_wrap_exception(_aW_);
       if(_aL_ !== Ke_Fke[18][1]) throw caml_maybe_attach_backtrace(_aL_, 0);
       var t$5 = t$2;
       break a;
      }
      var len = iovec[3];
      if(len > rest) break;
      var
       _aM_ = t$2[6],
       _aN_ = t$2[5],
       _aO_ = t$2[4],
       _aP_ = t$2[3],
       _aQ_ =
         check(iovec, t$2)
          ? caml_call2(Ke_Fke[18][17][6], t$2[2], len)
          : t$2[2],
       t$4 = [0, shifted, _aQ_, _aP_, _aO_, _aN_, _aM_],
       rest$0 = rest - len | 0,
       rest = rest$0,
       t$2 = t$4;
     }
     var
      _aR_ = t$2[6],
      _aS_ = t$2[5],
      _aT_ = t$2[4],
      _aU_ = t$2[3],
      _aV_ =
        check(iovec, t$2)
         ? caml_call2(Ke_Fke[18][17][6], t$2[2], rest)
         : t$2[2],
      v = shift(iovec, rest),
      i$0 = mask(shifted[2], shifted),
      match$0 = caml_call2(Ke_Fke[18][13], shifted[4], i$0);
     if(match$0){
      var q$0 = match$0[1];
      caml_check_bound(shifted[1], i$0)[1 + i$0] = v;
      var match$1 = [0, [0, shifted[1], shifted[2] + 1 | 0, shifted[3], q$0]];
     }
     else
      var match$1 = [1, shifted];
     if(0 !== match$1[0]) throw caml_maybe_attach_backtrace(Full, 1);
     var t = match$1[1], t$5 = [0, t, _aV_, _aU_, _aT_, _aS_, _aR_];
    }
    return caml_call1
            (k,
             [0,
              t$5[1],
              t$5[2],
              t$5[3],
              (t$5[4] + drain | 0) + drain | 0,
              t$5[5],
              t$5[6]]);
   }
   function schedule(k, length, buffer, opt, len, v, t){
    var k$0 = k, opt$0 = opt, len$0 = len;
    for(;;){
     if(opt$0) var sth = opt$0[1], off = sth; else var off = 0;
     if(len$0)
      var len$1 = len$0[1], len$2 = len$1;
     else
      var len$2 = caml_call1(length, v) - off | 0;
     var
      v$0 = [0, caml_call1(buffer, v), off, len$2],
      t$0 = t[1],
      i = mask(t$0[2], t$0),
      match = caml_call2(Ke_Fke[18][8], t$0[4], i);
     if(match){
      var q = match[1];
      caml_check_bound(t$0[1], i)[1 + i] = v$0;
      var match$0 = [0, [0, t$0[1], t$0[2] + 1 | 0, t$0[3], q]];
     }
     else
      var match$0 = [1, t$0];
     if(0 === match$0[0]){
      var sched = match$0[1];
      return caml_call1
              (k$0, [0, sched, t[2], t[3], t[4], t[5] + len$2 | 0, t[6]]);
     }
     var
      t$1 = t[1],
      max = caml_call1(Ke_Fke[18][6], t$1[4]),
      k$3 =
        function(max, k, off, len){
         function k$0(t){
          return schedule
                  (k,
                   length,
                   buffer,
                   [0, off + max | 0],
                   [0, len - max | 0],
                   v,
                   t);
         }
         return k$0;
        },
      k$1 = k$3(max, k$0, off, len$2),
      len$3 = [0, max],
      opt$1 = [0, off],
      k$4 =
        function(k){function k$0(_aF_){return flush(k, _aF_);} return k$0;},
      k$2 = k$4(k$1),
      k$0 = k$2,
      opt$0 = opt$1,
      len$0 = len$3;
    }
   }
   var length$0 = caml_ml_string_length;
   function buffer(x){return [1, x];}
   function kschedule_string(k, t, opt, len, v){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    return schedule(k, length$0, buffer, [0, off], len, v, t);
   }
   function _s_(_aE_){return _aE_;}
   function schedule_string(_aA_, _aB_, _aC_, _aD_){
    return kschedule_string(_s_, _aA_, _aB_, _aC_, _aD_);
   }
   var length$1 = caml_ml_bytes_length;
   function buffer$0(x){return [2, x];}
   function kschedule_bytes(k, t, opt, len, v){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    return schedule(k, length$1, buffer$0, [0, off], len, v, t);
   }
   function _t_(_az_){return _az_;}
   function schedule_bytes(_av_, _aw_, _ax_, _ay_){
    return kschedule_bytes(_t_, _av_, _aw_, _ax_, _ay_);
   }
   var length$2 = caml_ba_dim_1;
   function buffer$1(x){return [0, x];}
   function kschedule_bigstring(k, t, opt, len, v){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    return schedule(k, length$2, buffer$1, [0, off], len, v, t);
   }
   function _u_(_au_){return _au_;}
   function schedule_bigstring(_aq_, _ar_, _as_, _at_){
    return kschedule_bigstring(_u_, _aq_, _ar_, _as_, _at_);
   }
   function schedule_flush(f, t){
    var
     _am_ = t[6],
     _an_ = t[5],
     _ao_ = t[4],
     _ap_ = caml_call2(Ke_Fke[5], t[3], [0, t[5], f]);
    return [0, t[1], t[2], _ap_, _ao_, _an_, _am_];
   }
   function kschedulev_bigstring(k, l, t){
    function go(t, param){
     if(! param) return caml_call1(k, t);
     var r = param[2], buffer = param[1], _ak_ = 0, _al_ = 0;
     return kschedule_bigstring
             (function(t){return go(t, r);}, t, _al_, _ak_, buffer);
    }
    return go(t, l);
   }
   function kwrite(k, blit, length, opt, len, buffer, t){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(length, buffer) - off | 0;
    var available = caml_call1(Ke_Fke[18][6], t[2]);
    if(len$1 <= available){
     var
      match =
        caml_call6
         (Ke_Fke[18][17][1], t[2], blit, length, [0, off], [0, len$1], buffer),
      write = match[2],
      areas = match[1];
     return kschedulev_bigstring
             (k, areas, [0, t[1], write, t[3], t[4], t[5], t[6]]);
    }
    if(0 < available){
     var
      k$0 =
        function(t){
         return kwrite
                 (k,
                  blit,
                  length,
                  [0, off + available | 0],
                  [0, len$1 - available | 0],
                  buffer,
                  t);
        },
      match$0 =
        caml_call6
         (Ke_Fke[18][17][1],
          t[2],
          blit,
          length,
          [0, off],
          [0, available],
          buffer),
      write$0 = match$0[2],
      areas$0 = match$0[1],
      _ai_ = [0, t[1], write$0, t[3], t[4], t[5], t[6]];
     return kschedulev_bigstring
             (function(_aj_){return flush(k$0, _aj_);}, areas$0, _ai_);
    }
    function k$1(t){
     return kwrite(k, blit, length, [0, off], [0, len$1], buffer, t);
    }
    return flush(k$1, t);
   }
   function bigarray_blit_from_string(src, src_off, dst, dst_off, len){
    return caml_call5(Bigstringaf[24], src, src_off, dst, dst_off, len);
   }
   function bigarray_blit_from_bytes(src, src_off, dst, dst_off, len){
    return caml_call5(Bigstringaf[25], src, src_off, dst, dst_off, len);
   }
   function bigarray_blit(src, src_off, dst, dst_off, len){
    var _ah_ = caml_ba_sub(dst, dst_off, len);
    return runtime.caml_ba_blit(caml_ba_sub(src, src_off, len), _ah_);
   }
   var length$3 = caml_ml_string_length;
   function k(_ag_){return _ag_;}
   function write_string(opt, len, a, t){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    return kwrite(k, bigarray_blit_from_string, length$3, [0, off], len, a, t);
   }
   var length$4 = caml_ml_bytes_length;
   function k$0(_af_){return _af_;}
   function write_bytes(opt, len, a, t){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    return kwrite
            (k$0, bigarray_blit_from_bytes, length$4, [0, off], len, a, t);
   }
   var length$5 = caml_ba_dim_1;
   function k$1(_ae_){return _ae_;}
   function write_bigstring(opt, len, a, t){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    return kwrite(k$1, bigarray_blit, length$5, [0, off], len, a, t);
   }
   function length$6(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
   }
   function blit(src, src_off, dst, dst_off, len){
    if(0 !== src_off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
    if(1 === len) return caml_ba_set_1(dst, dst_off, src);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
   }
   function k$2(_ad_){return _ad_;}
   function write_char(a, t){
    return kwrite(k$2, blit, length$6, _z_, _y_, a, t);
   }
   function length$7(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
   }
   function blit$0(src, src_off, dst, dst_off, len){
    if(0 !== src_off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
    if(1 === len) return caml_ba_set_1(dst, dst_off, src);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
   }
   function k$3(_ac_){return _ac_;}
   function write_uint8(a, t){
    return kwrite(k$3, blit$0, length$7, _E_, _D_, a, t);
   }
   function Make(X){
    function length(param){
     throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
    }
    function blit(src, src_off, dst, dst_off, len){
     if(0 !== src_off)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
     if(2 === len) return caml_call3(X[1], dst, dst_off, src);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
    }
    function kwrite_uint16(k, a, t){
     return kwrite(k, blit, length, _J_, _I_, a, t);
    }
    function _S_(_ab_){return _ab_;}
    function write_uint16(_$_, _aa_){return kwrite_uint16(_S_, _$_, _aa_);}
    function blit$0(src, src_off, dst, dst_off, len){
     if(0 !== src_off)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
     if(4 === len) return caml_call3(X[2], dst, dst_off, src);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _K_], 1);
    }
    function kwrite_uint32(k, a, t){
     return kwrite(k, blit$0, length, _N_, _M_, a, t);
    }
    function _T_(___){return ___;}
    function write_uint32(_Y_, _Z_){return kwrite_uint32(_T_, _Y_, _Z_);}
    function blit$1(src, src_off, dst, dst_off, len){
     if(0 !== src_off)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
     if(8 === len) return caml_call3(X[3], dst, dst_off, src);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
    }
    function kwrite_uint64(k, a, t){
     return kwrite(k, blit$1, length, _R_, _Q_, a, t);
    }
    function _U_(_X_){return _X_;}
    function write_uint64(_V_, _W_){return kwrite_uint64(_U_, _V_, _W_);}
    return [0, , write_uint16, , write_uint32, , write_uint64];
   }
   var
    set_int16 = Bigstringaf[11],
    set_int32 = Bigstringaf[13],
    set_int64 = Bigstringaf[15],
    LE = [0, set_int16, set_int32, set_int64],
    set_int16$0 = Bigstringaf[18],
    set_int32$0 = Bigstringaf[20],
    set_int64$0 = Bigstringaf[22],
    BE = [0, set_int16$0, set_int32$0, set_int64$0],
    LE$0 = Make(LE),
    BE$0 = Make(BE),
    Prettym_Enclosure =
      [0,
       [0, weight, sub],
       [0, weight$0, length, lengthv, shift, split, merge],
       is_empty,
       pp$2,
       schedule_flush,
       schedule_bigstring,
       kschedule_bigstring,
       schedule_string,
       kschedule_string,
       schedule_bytes,
       kschedule_bytes,
       write_char,
       write_string,
       write_bigstring,
       write_bytes,
       write_uint8,
       flush,
       [0, LE$0[2], LE$0[4], LE$0[6]],
       [0, BE$0[2], BE$0[4], BE$0[6]],
       create];
   runtime.caml_register_global(49, Prettym_Enclosure, "Prettym__Enclosure");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Prettym__Pretty
//# unitInfo: Requires: Bigstringaf, Fmt, Ke__Fke, Prettym__Enclosure, Stdlib, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_S = "%S",
    cst_Indent = "(`Indent ",
    cst_Indent_d = "(`Indent %d)",
    cst_hov = "<hov>",
    cst$0 = "@ ",
    cst_root = "[<root>",
    cst_lib_pretty_ml = "lib/pretty.ml",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call15
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14){
    return (f.l >= 0 ? f.l : f.l = f.length) == 15
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\r\n",
    partial = [17, 0, [11, " }", 0]],
    partial$0 =
      [11,
       "queue= ",
       [18,
        [1, [0, [11, cst_hov, 0], cst_hov]],
        [15,
         [17,
          0,
          [12,
           59,
           [17,
            [0, cst$0, 1, 0],
            [11,
             "encoder= ",
             [18,
              [1, [0, [11, cst_hov, 0], cst_hov]],
              [15, [17, 0, [12, 59, partial]]]]]]]]]]],
    partial$1 = [0, cst$0, 1, 0],
    partial$2 =
      [4,
       0,
       0,
       0,
       [12,
        59,
        [17,
         [0, cst$0, 1, 0],
         [11,
          "margin= ",
          [4,
           0,
           0,
           0,
           [12,
            59,
            [17,
             [0, cst$0, 1, 0],
             [11, "new_line= ", [3, 0, [12, 59, [17, partial$1, partial$0]]]]]]]]]]],
    partial$3 =
      [15,
       [17,
        0,
        [12,
         59,
         [17,
          [0, cst$0, 1, 0],
          [11,
           "inner= ",
           [18,
            [1, [0, [11, cst_hov, 0], cst_hov]],
            [15,
             [17,
              0,
              [12, 59, [17, [0, cst$0, 1, 0], [11, "indent= ", partial$2]]]]]]]]]]],
    partial$4 = [1, [0, [11, cst_hov, 0], cst_hov]],
    fws = [2, 1, 1],
    Ke_Fke = global_data.Ke__Fke,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    Prettym_Enclosure = global_data.Prettym__Enclosure,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Fmt = global_data.Fmt,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Bigstringaf = global_data.Bigstringaf,
    _m_ = [0, cst_lib_pretty_ml, 315, 14],
    _n_ = [2, 3306987],
    cst_In = "In",
    _l_ =
      [0,
       [11,
        "{ ",
        [18,
         [1, [0, [11, cst_hov, 0], cst_hov]],
         [11,
          "boxes= ",
          [18,
           [1, [0, [11, cst_hov, 0], cst_hov]],
           [15,
            [17,
             0,
             [12,
              59,
              [17,
               [0, cst$0, 1, 0],
               [11, "breaks= ", [18, partial$4, partial$3]]]]]]]]]],
       "{ @[<hov>boxes= @[<hov>%a@];@ breaks= @[<hov>%a@];@ inner= @[<hov>%a@];@ indent= %d;@ margin= %d;@ new_line= %S;@ queue= @[<hov>%a@];@ encoder= @[<hov>%a@];@] }"],
    _d_ = [0, [12, 93, 0], "]"],
    _e_ = [0, [3, 0, 0], cst_S],
    _f_ = [0, [3, 0, 0], cst_S],
    _g_ = [0, [3, 0, 0], cst_S],
    _h_ = [0, [12, 60, [3, 0, [12, 62, 0]]], "<%S>"],
    _i_ = [0, [11, cst_root, 0], cst_root],
    _j_ = [0, [12, 91, 0], "["],
    _k_ = [0, [11, "[<", [4, 0, 0, 0, [12, 62, 0]]], "[<%d>"],
    _c_ = [0, [11, cst_Indent, [4, 0, 0, 0, [12, 41, 0]]], cst_Indent_d],
    cst_Root = "`Root",
    cst_Box = "`Box",
    _b_ = [0, [11, cst_Indent, [4, 0, 0, 0, [12, 41, 0]]], cst_Indent_d],
    _a_ = [0, cst_lib_pretty_ml, 22, 2],
    cst_Prettym_Pretty_Stack_Empty = "Prettym__Pretty.Stack.Empty";
   function length_of_value(param){var vec = param[1]; return vec[2];}
   var box = 0;
   function tbox(indent){return [0, indent];}
   var bbox = 1;
   function o(box){return [3, box];}
   var new_line = 0, close = 1;
   function spaces(len){return [2, len, 0];}
   function break$0(len, indent){return [2, len, indent];}
   function v(breakable){
    return breakable
            ? function(x){return [0, x];}
            : function(x){return [1, x];};
   }
   function string(opt, _cS_, len, x){
    if(opt) var sth = opt[1], breakable = sth; else var breakable = 0;
    if(_cS_) var sth$0 = _cS_[1], off = sth$0; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = runtime.caml_ml_string_length(x) - off | 0;
    var value = [0, [0, off, len$1], x];
    return v(breakable)(value);
   }
   function bytes(opt, _cR_, len, x){
    if(opt) var sth = opt[1], breakable = sth; else var breakable = 0;
    if(_cR_) var sth$0 = _cR_[1], off = sth$0; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = runtime.caml_ml_bytes_length(x) - off | 0;
    var value = [1, [0, off, len$1], x];
    return v(breakable)(value);
   }
   function bigstring(opt, _cQ_, len, x){
    if(opt) var sth = opt[1], breakable = sth; else var breakable = 0;
    if(_cQ_) var sth$0 = _cQ_[1], off = sth$0; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(Bigstringaf[6], x) - off | 0;
    var value = [2, [0, off, len$1], x];
    return v(breakable)(value);
   }
   function length_of_token(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var value = param[1]; return length_of_value(value);
      case 1:
       var len = param[1]; return len;
      default: return 0;
    }
   }
   var
    Empty = [248, cst_Prettym_Pretty_Stack_Empty, caml_fresh_oo_id(0)],
    empty = 0;
   function swap_exn(f, param){
    if(! param) throw caml_maybe_attach_backtrace(Empty, 1);
    var r = param[2], x = param[1];
    return [0, caml_call1(f, x), r];
   }
   var fold = Stdlib_List[26];
   function tail_exn(param){
    if(! param) throw caml_maybe_attach_backtrace(Empty, 1);
    var r = param[2];
    return r;
   }
   function map(f, l){return caml_call2(Stdlib_List[20], f, l);}
   var pp = Fmt[70][7];
   function pp_box(ppf, param){
    if(typeof param === "number")
     return 914889282 <= param
             ? caml_call2(Fmt[57], ppf, cst_Root)
             : caml_call2(Fmt[57], ppf, cst_Box);
    var n = param[2];
    return caml_call3(Fmt[3], ppf, _b_, n);
   }
   function pp_break(ppf, param){
    var n = param[2];
    return caml_call3(Fmt[3], ppf, _c_, n);
   }
   function pp_token(ppf, param){
    if(typeof param === "number") return caml_call2(Fmt[3], ppf, _d_);
    switch(param[0]){
      case 0:
       var _cL_ = param[1];
       switch(_cL_[0]){
         case 0:
          var
           x = _cL_[2],
           match = _cL_[1],
           len = match[2],
           off = match[1],
           _cM_ = caml_call3(Stdlib_String[16], x, off, len);
          return caml_call3(Fmt[3], ppf, _e_, _cM_);
         case 1:
          var
           x$0 = _cL_[2],
           match$0 = _cL_[1],
           len$0 = match$0[2],
           off$0 = match$0[1],
           _cN_ = caml_call3(Stdlib_Bytes[8], x$0, off$0, len$0);
          return caml_call3(Fmt[3], ppf, _f_, _cN_);
         default:
          var
           x$1 = _cL_[2],
           match$1 = _cL_[1],
           len$1 = match$1[2],
           off$1 = match$1[1],
           _cO_ = caml_call3(Bigstringaf[7], x$1, off$1, len$1);
          return caml_call3(Fmt[3], ppf, _g_, _cO_);
       }
      case 1:
       var len$2 = param[1], _cP_ = caml_call2(Stdlib_String[1], len$2, 32);
       return caml_call3(Fmt[3], ppf, _h_, _cP_);
      default:
       var match$2 = param[1];
       if(typeof match$2 === "number")
        return 914889282 <= match$2
                ? caml_call2(Fmt[3], ppf, _i_)
                : caml_call2(Fmt[3], ppf, _j_);
       var n = match$2[2];
       return caml_call3(Fmt[3], ppf, _k_, n);
    }
   }
   function pp$0(ppf, t){
    var
     _cy_ = t[8],
     _cz_ = Prettym_Enclosure[4],
     _cA_ = t[7],
     _cB_ = caml_call2(Ke_Fke[16], 0, pp_token),
     _cC_ = t[6],
     _cD_ = t[5],
     _cE_ = t[4],
     _cF_ = t[3],
     _cG_ = caml_call1(pp, caml_call1(Fmt[70][7], Fmt[45])),
     _cH_ = t[2],
     _cI_ = caml_call1(pp, caml_call1(Fmt[70][7], pp_break)),
     _cJ_ = t[1],
     _cK_ = caml_call1(pp, pp_box);
    return caml_call15
            (Fmt[3],
             ppf,
             _l_,
             _cK_,
             _cJ_,
             _cI_,
             _cH_,
             _cG_,
             _cF_,
             _cE_,
             _cD_,
             _cC_,
             _cB_,
             _cA_,
             _cz_,
             _cy_);
   }
   function symbol(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function flip(f, a, b){return caml_call2(f, b, a);}
   function emit_line(k, t){
    function go(queue, encoder){
     var queue$0 = queue;
     for(;;){
      var match = caml_call1(Ke_Fke[9], queue$0);
      if(! match){
       var
        k$0 =
          function(encoder){
           return caml_call1
                   (k,
                    [0, t[1], t[2], t[3], t[4], t[5], t[6], Ke_Fke[2], encoder]);
          },
        k$1 =
          function(encoder){
           return caml_call2(Prettym_Enclosure[17], k$0, encoder);
          };
       return caml_call5(Prettym_Enclosure[9], k$1, encoder, 0, 0, t[6]);
      }
      var _cf_ = match[1], match$0 = _cf_[1];
      if(typeof match$0 !== "number")
       switch(match$0[0]){
         case 0:
          var _cg_ = match$0[1];
          switch(_cg_[0]){
            case 0:
             var
              queue$2 = _cf_[2],
              v = _cg_[2],
              match$1 = _cg_[1],
              len = match$1[2],
              off = match$1[1],
              _ch_ = [0, len],
              _ci_ = [0, off],
              _cj_ = function(_cx_){return go(queue$2, _cx_);};
             return caml_call5
                     (Prettym_Enclosure[9], _cj_, encoder, _ci_, _ch_, v);
            case 1:
             var
              queue$3 = _cf_[2],
              v$0 = _cg_[2],
              match$2 = _cg_[1],
              len$0 = match$2[2],
              off$0 = match$2[1],
              _ck_ = [0, len$0],
              _cl_ = [0, off$0],
              _cm_ = function(_cw_){return go(queue$3, _cw_);};
             return caml_call5
                     (Prettym_Enclosure[11], _cm_, encoder, _cl_, _ck_, v$0);
            default:
             var
              queue$4 = _cf_[2],
              v$1 = _cg_[2],
              match$3 = _cg_[1],
              len$1 = match$3[2],
              off$1 = match$3[1],
              _cn_ = [0, len$1],
              _co_ = [0, off$1],
              _cp_ = function(_cv_){return go(queue$4, _cv_);};
             return caml_call5
                     (Prettym_Enclosure[7], _cp_, encoder, _co_, _cn_, v$1);
          }
         case 1:
          var
           queue$5 = _cf_[2],
           len$2 = match$0[1],
           _cq_ = caml_call2(Stdlib_String[1], len$2, 32),
           _cr_ = [0, len$2],
           _cs_ = 0,
           _ct_ = function(_cu_){return go(queue$5, _cu_);};
          return caml_call5
                  (Prettym_Enclosure[9], _ct_, encoder, _cs_, _cr_, _cq_);
       }
      var queue$1 = _cf_[2], queue$0 = queue$1;
     }
    }
    var
     _b__ = caml_call2(Stdlib_String[1], t[4], 32),
     _b$_ = 0,
     _ca_ = 0,
     _cb_ = t[8],
     _cc_ = t[7];
    function _cd_(_ce_){return go(_cc_, _ce_);}
    return caml_call5(Prettym_Enclosure[9], _cd_, _cb_, _ca_, _b$_, _b__);
   }
   function merge_indents(k, t){
    var
     _bY_ = t[1],
     _bZ_ = 0,
     indent_by_box =
       caml_call3
        (fold,
         function(a, param){
          if(typeof param === "number") return a;
          var n = param[2];
          return a + n | 0;
         },
         _bZ_,
         _bY_);
    function k$0(a, l){
     function _b9_(a, param){
      var n = param[2];
      return caml_call2(Stdlib[17], a, n);
     }
     return caml_call3(Stdlib_List[26], _b9_, a, l);
    }
    var
     indent_by_break = caml_call3(fold, k$0, 0, t[2]),
     _b0_ = t[8],
     _b1_ = t[7],
     _b2_ = t[6],
     _b3_ = t[5],
     _b4_ = indent_by_box + indent_by_break | 0,
     _b5_ = t[1],
     _b6_ = map(function(param){return 0;}, _b5_),
     _b7_ = t[1],
     _b8_ = map(function(param){return 0;}, _b7_);
    return caml_call1(k, [0, t[1], _b8_, _b6_, _b4_, _b3_, _b2_, _b1_, _b0_]);
   }
   function is_in_box(t){
    var In = [248, cst_In, caml_fresh_oo_id(0)];
    try{
     var
      _bU_ = t[7],
      _bV_ =
        function(param){
         if(typeof param !== "number" && 2 === param[0])
          throw caml_maybe_attach_backtrace(In, 1);
         return 0;
        };
     caml_call2(Ke_Fke[14], _bV_, _bU_);
     var _bW_ = 0;
     return _bW_;
    }
    catch(_bX_){
     var _bT_ = caml_wrap_exception(_bX_);
     if(_bT_ === In) return 1;
     throw caml_maybe_attach_backtrace(_bT_, 0);
    }
   }
   function without_last_box(q){
    var q$0 = q;
    for(;;){
     var match = caml_call1(Ke_Fke[11], q$0);
     if(! match) return Ke_Fke[2];
     var _bR_ = match[1], q$1 = _bR_[1], _bS_ = _bR_[2];
     if(typeof _bS_ !== "number" && 2 === _bS_[0]) return q$1;
     var q$0 = q$1;
    }
   }
   function unroll_last_box_and_emit(k, value, t){
    var q$1 = t[7], acc$1 = [0, [0, value], 0], acc = acc$1, q = q$1;
    for(;;){
     var match = caml_call1(Ke_Fke[12], q), x = match[2], q$0 = match[1];
     if(typeof x !== "number" && 2 === x[0]){
      var
       box = caml_call1(Stdlib_List[10], [0, x, acc]),
       k$0 =
         function(t){
          var
           q$1 = t[7],
           acc$1 = caml_call1(Stdlib_List[10], box),
           acc = acc$1,
           q = q$1;
          for(;;){
           if(! acc)
            return caml_call1
                    (k, [0, t[1], t[2], t[3], t[4], t[5], t[6], q, t[8]]);
           var
            acc$0 = acc[2],
            x = acc[1],
            q$0 = caml_call2(Ke_Fke[5], q, x),
            acc = acc$0,
            q = q$0;
          }
         },
       _bP_ = [0, t[1], t[2], t[3], t[4], t[5], t[6], q$0, t[8]];
      return emit_line(function(_bQ_){return merge_indents(k$0, _bQ_);}, _bP_);
     }
     var acc$0 = [0, x, acc], acc = acc$0, q = q$0;
    }
   }
   function kpush(k, value, t){
    var _S_ = t[7], _T_ = 0;
    function _U_(_bO_, _bN_){return _bO_ + _bN_ | 0;}
    function _V_(_bM_){return symbol(_U_, length_of_token, _bM_);}
    function _W_(_bK_, _bL_){return flip(_V_, _bK_, _bL_);}
    var
     _X_ = caml_call3(Ke_Fke[15], _W_, _T_, _S_),
     current_length_of_line = t[4] + _X_ | 0;
    function append(stack, len){
     if(stack)
      var r = stack[2], x = stack[1], match = [0, [0, x, r]];
     else
      var match = 0;
     if(! match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     var match$0 = match[1], stack$0 = match$0[2], lenv = match$0[1];
     return [0, [0, len, lenv], stack$0];
    }
    if(typeof value === "number"){
     if(0 === value)
      return emit_line(function(_bJ_){return merge_indents(k, _bJ_);}, t);
     var
      _aD_ = t[8],
      _aE_ = caml_call2(Ke_Fke[5], t[7], 0),
      _aF_ = t[6],
      _aG_ = t[5],
      _aH_ = t[4],
      _aI_ = tail_exn(t[3]),
      _aJ_ = tail_exn(t[2]);
     return caml_call1
             (k,
              [0, tail_exn(t[1]), _aJ_, _aI_, _aH_, _aG_, _aF_, _aE_, _aD_]);
    }
    switch(value[0]){
      case 0:
       var value$0 = value[1];
       if(t[5] <= current_length_of_line){
        var
         _Y_ = [0, value$0],
         _Z_ = function(_bI_){return kpush(k, _Y_, _bI_);};
        return emit_line(function(_bH_){return merge_indents(_Z_, _bH_);}, t);
       }
       var ___ = t[5];
       if(___ >= (current_length_of_line + length_of_token([0, value$0]) | 0)){
        var
         _ae_ = t[8],
         _af_ = caml_call2(Ke_Fke[5], t[7], [0, value$0]),
         _ag_ = t[6],
         _ah_ = t[5],
         _ai_ = t[4],
         _aj_ = t[3],
         _ak_ =
           swap_exn
            (function(lenv){return [0, length_of_value(value$0), lenv];},
             _aj_);
        return caml_call1
                (k, [0, t[1], t[2], _ak_, _ai_, _ah_, _ag_, _af_, _ae_]);
       }
       if(is_in_box(t)){
        var _$_ = without_last_box(t[7]);
        if(! caml_call1(Ke_Fke[3], _$_))
         return unroll_last_box_and_emit(k, value$0, t);
       }
       var len$0 = t[5] - current_length_of_line | 0;
       if(0 >= len$0)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
       switch(value$0[0]){
         case 0:
          var
           v$0 = value$0[2],
           vec = value$0[1],
           v0 = caml_call3(Stdlib_String[16], v$0, 0, len$0),
           v1 = caml_call3(Stdlib_String[16], v$0, len$0, vec[2] - len$0 | 0),
           match =
             [0, [0, [0, 0, len$0], v0], [0, [0, 0, vec[2] - len$0 | 0], v1]];
          break;
         case 1:
          var
           v$1 = value$0[2],
           vec$0 = value$0[1],
           v0$0 = caml_call3(Stdlib_Bytes[7], v$1, 0, len$0),
           v1$0 =
             caml_call3(Stdlib_Bytes[7], v$1, len$0, vec$0[2] - len$0 | 0),
           match =
             [0,
              [1, [0, 0, len$0], v0$0],
              [1, [0, 0, vec$0[2] - len$0 | 0], v1$0]];
          break;
         default:
          var
           v$2 = value$0[2],
           vec$1 = value$0[1],
           match =
             [0,
              [2, [0, vec$1[1], len$0], v$2],
              [2, [0, vec$1[1] + len$0 | 0, vec$1[2] - len$0 | 0], v$2]];
       }
       var
        value1 = match[2],
        value0 = match[1],
        token0 = [0, value0],
        token1 = v(1)(value1),
        _aa_ = t[8],
        _ab_ = caml_call2(Ke_Fke[5], t[7], token0),
        _ac_ = [0, t[1], t[2], t[3], t[4], t[5], t[6], _ab_, _aa_],
        _ad_ = function(_bG_){return kpush(k, token1, _bG_);};
       return emit_line
               (function(_bF_){return merge_indents(_ad_, _bF_);}, _ac_);
      case 1:
       var value$1 = value[1], _al_ = t[5];
       if
        (_al_ < (current_length_of_line + length_of_token([0, value$1]) | 0)
         && ! caml_call1(Ke_Fke[3], t[7])){
        if(is_in_box(t)){
         var _at_ = without_last_box(t[7]);
         if(! caml_call1(Ke_Fke[3], _at_))
          return unroll_last_box_and_emit(k, value$1, t);
        }
        var match$0 = caml_call1(Ke_Fke[11], t[7]);
        if(! match$0){
         var
          _aB_ = [1, value$1],
          _aC_ = function(_bE_){return kpush(k, _aB_, _bE_);};
         return emit_line
                 (function(_bD_){return merge_indents(_aC_, _bD_);}, t);
        }
        var _au_ = match$0[1], _av_ = _au_[2];
        if(typeof _av_ !== "number" && 1 === _av_[0]){
         var
          queue$0 = _au_[1],
          _ay_ = [0, t[1], t[2], t[3], t[4], t[5], t[6], queue$0, t[8]],
          _az_ = [1, value$1],
          _aA_ = function(_bC_){return kpush(k, _az_, _bC_);};
         return emit_line
                 (function(_bB_){return merge_indents(_aA_, _bB_);}, _ay_);
        }
        var
         _aw_ = [1, value$1],
         _ax_ = function(_bA_){return kpush(k, _aw_, _bA_);};
        return emit_line(function(_bz_){return merge_indents(_ax_, _bz_);}, t);
       }
       var
        _am_ = t[8],
        _an_ = caml_call2(Ke_Fke[5], t[7], [0, value$1]),
        _ao_ = t[6],
        _ap_ = t[5],
        _aq_ = t[4],
        _ar_ = t[3],
        _as_ =
          swap_exn
           (function(lenv){return [0, length_of_value(value$1), lenv];}, _ar_);
       return caml_call1
               (k, [0, t[1], t[2], _as_, _aq_, _ap_, _ao_, _an_, _am_]);
      case 2:
       var
        indent = value[2],
        len$1 = value[1],
        x$1 = caml_call1(Ke_Fke[11], t[7]);
       if(x$1){
        var x = x$1[1], x$0 = x[2], queue = x[1];
        a:
        {
         if
          (typeof value !== "number"
           && 2 === value[0] && typeof x$0 !== "number" && 1 === x$0[0]){
          var
           len = x$0[1],
           len_x = value[1],
           _R_ = [0, [0, queue, len_x + len | 0]];
          break a;
         }
         var _R_ = 0;
        }
        var match$1 = _R_;
       }
       else
        var match$1 = 0;
       if(match$1){
        var
         match$2 = match$1[1],
         len$2 = match$2[2],
         queue$1 = match$2[1],
         _aK_ = t[5];
        if(_aK_ <= (current_length_of_line + length_of_token([1, len$2]) | 0)){
         var
          _aL_ = t[8],
          _aM_ = t[6],
          _aN_ = t[5],
          _aO_ = t[4],
          _aP_ = t[3],
          _aQ_ = append(t[2], [0, -930643828, indent]),
          _aR_ = [0, t[1], _aQ_, _aP_, _aO_, _aN_, _aM_, queue$1, _aL_];
         return emit_line
                 (function(_by_){return merge_indents(k, _by_);}, _aR_);
        }
        var
         _aS_ = t[8],
         _aT_ = caml_call2(Ke_Fke[5], queue$1, [1, len$2]),
         _aU_ = t[6],
         _aV_ = t[5],
         _aW_ = t[4],
         _aX_ = append(t[3], len$2),
         _aY_ = append(t[2], [0, -930643828, indent]);
        return caml_call1
                (k, [0, t[1], _aY_, _aX_, _aW_, _aV_, _aU_, _aT_, _aS_]);
       }
       var _aZ_ = t[5];
       if(_aZ_ < (current_length_of_line + length_of_token([1, len$1]) | 0)){
        var
         _a0_ = t[8],
         _a1_ = t[7],
         _a2_ = t[6],
         _a3_ = t[5],
         _a4_ = t[4],
         _a5_ = t[3],
         _a6_ = append(t[2], [0, -930643828, indent]),
         _a7_ = [0, t[1], _a6_, _a5_, _a4_, _a3_, _a2_, _a1_, _a0_];
        return emit_line(function(_bx_){return merge_indents(k, _bx_);}, _a7_);
       }
       var
        _a8_ = t[8],
        _a9_ = caml_call2(Ke_Fke[5], t[7], [1, len$1]),
        _a__ = t[6],
        _a$_ = t[5],
        _ba_ = t[4],
        _bb_ = append(t[3], len$1),
        _bc_ = append(t[2], [0, -930643828, indent]);
       return caml_call1
               (k, [0, t[1], _bc_, _bb_, _ba_, _a$_, _a__, _a9_, _a8_]);
      default:
       var match$3 = value[1];
       if(typeof match$3 !== "number"){
        var
         indent$1 = match$3[1],
         _bo_ = t[8],
         _bp_ = caml_call2(Ke_Fke[5], t[7], [2, [0, -930643828, indent$1]]);
        return caml_call1
                (k,
                 [0,
                  [0, [0, -930643828, indent$1], t[1]],
                  [0, 0, t[2]],
                  [0, 0, t[3]],
                  t[4],
                  t[5],
                  t[6],
                  _bp_,
                  _bo_]);
       }
       if(match$3){
        var
         _bd_ = t[3],
         _be_ = 0,
         _bf_ = 0,
         _bg_ = function(_bw_, _bv_){return _bw_ + _bv_ | 0;},
         _bh_ = caml_call2(Stdlib_List[26], _bg_, _bf_),
         _bi_ = function(_bu_, _bt_){return _bu_ + _bt_ | 0;},
         _bj_ = function(_bs_){return symbol(_bi_, _bh_, _bs_);},
         indent$0 =
           caml_call3
            (fold,
             function(_bq_, _br_){return flip(_bj_, _bq_, _br_);},
             _be_,
             _bd_),
         _bk_ = t[8],
         _bl_ = caml_call2(Ke_Fke[5], t[7], [2, [0, -930643828, indent$0]]);
        return caml_call1
                (k,
                 [0,
                  [0, [0, -930643828, indent$0], t[1]],
                  [0, 0, t[2]],
                  [0, 0, t[3]],
                  t[4],
                  t[5],
                  t[6],
                  _bl_,
                  _bk_]);
       }
       var _bm_ = t[8], _bn_ = caml_call2(Ke_Fke[5], t[7], _n_);
       return caml_call1
               (k,
                [0,
                 [0, 3306987, t[1]],
                 [0, 0, t[2]],
                 [0, 0, t[3]],
                 t[4],
                 t[5],
                 t[6],
                 _bn_,
                 _bm_]);
    }
   }
   function kflush(k, t){
    function go(queue, encoder){
     var queue$0 = queue;
     for(;;){
      var match = caml_call1(Ke_Fke[9], queue$0);
      if(! match){
       var
        _M_ =
          function(encoder){
           return caml_call1
                   (k,
                    [0, t[1], t[2], t[3], t[4], t[5], t[6], Ke_Fke[2], encoder]);
          };
       return caml_call2(Prettym_Enclosure[17], _M_, encoder);
      }
      var _x_ = match[1], match$0 = _x_[1];
      if(typeof match$0 !== "number")
       switch(match$0[0]){
         case 0:
          var _y_ = match$0[1];
          switch(_y_[0]){
            case 0:
             var
              queue$2 = _x_[2],
              v = _y_[2],
              match$1 = _y_[1],
              len = match$1[2],
              off = match$1[1],
              _z_ = [0, len],
              _A_ = [0, off],
              _B_ = function(_Q_){return go(queue$2, _Q_);};
             return caml_call5
                     (Prettym_Enclosure[9], _B_, encoder, _A_, _z_, v);
            case 1:
             var
              queue$3 = _x_[2],
              v$0 = _y_[2],
              match$2 = _y_[1],
              len$0 = match$2[2],
              off$0 = match$2[1],
              _C_ = [0, len$0],
              _D_ = [0, off$0],
              _E_ = function(_P_){return go(queue$3, _P_);};
             return caml_call5
                     (Prettym_Enclosure[11], _E_, encoder, _D_, _C_, v$0);
            default:
             var
              queue$4 = _x_[2],
              v$1 = _y_[2],
              match$3 = _y_[1],
              len$1 = match$3[2],
              off$1 = match$3[1],
              _F_ = [0, len$1],
              _G_ = [0, off$1],
              _H_ = function(_O_){return go(queue$4, _O_);};
             return caml_call5
                     (Prettym_Enclosure[7], _H_, encoder, _G_, _F_, v$1);
          }
         case 1:
          var
           queue$5 = _x_[2],
           len$2 = match$0[1],
           _I_ = caml_call2(Stdlib_String[1], len$2, 32),
           _J_ = [0, len$2],
           _K_ = 0,
           _L_ = function(_N_){return go(queue$5, _N_);};
          return caml_call5(Prettym_Enclosure[9], _L_, encoder, _K_, _J_, _I_);
       }
      var queue$1 = _x_[2], queue$0 = queue$1;
     }
    }
    return go(t[7], t[8]);
   }
   function _o_(_w_){return _w_;}
   function push(_u_, _v_){return kpush(_o_, _u_, _v_);}
   function _p_(_t_){return _t_;}
   function flush(_s_){return kflush(_p_, _s_);}
   function is_empty(t){
    var _r_ = caml_call1(Ke_Fke[3], t[7]);
    return _r_ ? caml_call1(Prettym_Enclosure[3], t[8]) : _r_;
   }
   function create(opt, _q_, emitter, len){
    if(opt) var sth = opt[1], margin = sth; else var margin = 998;
    if(_q_) var sth$0 = _q_[1], new_line = sth$0; else var new_line = cst;
    var encoder = caml_call2(Prettym_Enclosure[20], emitter, len);
    return [0,
            [0, 914889282, empty],
            [0, 0, empty],
            [0, 0, empty],
            0,
            margin,
            new_line,
            Ke_Fke[2],
            encoder];
   }
   var
    Prettym_Pretty =
      [0,
       pp$0,
       box,
       tbox,
       bbox,
       o,
       new_line,
       close,
       string,
       bytes,
       bigstring,
       fws,
       spaces,
       break$0,
       kpush,
       push,
       kflush,
       flush,
       is_empty,
       create];
   runtime.caml_register_global(41, Prettym_Pretty, "Prettym__Pretty");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Prettym__Fancy
//# unitInfo: Requires: Prettym__Pretty, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    fws = [3, 1, 1],
    cut = [3, 0, 0],
    Prettym_Pretty = global_data.Prettym__Pretty,
    Stdlib_String = global_data.Stdlib__String,
    _e_ = [0, 1],
    _d_ = [0, 0],
    _c_ = [0, 0],
    _b_ = [0, 0],
    _a_ = [0, 0];
   function keval_order(k, t, param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return function(encoder, v){
         return caml_call1(k, caml_call2(encoder, t, v));};
       case 1:
        return caml_call3(Prettym_Pretty[14], k, Prettym_Pretty[6], t);
       default:
        return caml_call3(Prettym_Pretty[14], k, Prettym_Pretty[7], t);
     }
    switch(param[0]){
      case 0:
       var v = param[2], encoder = param[1];
       return caml_call1(k, caml_call2(encoder, t, v));
      case 1:
       var encoder$0 = param[1];
       return function(v){return caml_call1(k, caml_call2(encoder$0, t, v));};
      case 2:
       var box = param[1], _h_ = caml_call1(Prettym_Pretty[5], box);
       return caml_call3(Prettym_Pretty[14], k, _h_, t);
      default:
       var
        len = param[2],
        indent = param[1],
        _i_ = caml_call2(Prettym_Pretty[13], len, indent);
       return caml_call3(Prettym_Pretty[14], k, _i_, t);
    }
   }
   function const$0(encoder, v){return [0, encoder, v];}
   function atom(encoder){return [1, encoder];}
   var a = 0, new_line = 1;
   function tbox(indent){return [2, caml_call1(Prettym_Pretty[3], indent)];}
   var bbox = [2, Prettym_Pretty[4]], box = [2, Prettym_Pretty[2]], close = 2;
   function break$0(indent, len){return [3, indent, len];}
   function spaces(len){return [3, 0, len];}
   function using(f, encoder, t, v){
    return caml_call2(encoder, t, caml_call1(f, v));
   }
   function list(param, encoder){
    var e = param[2], sep = param[1];
    function go(t, param){
     var t$0 = t, param$0 = param;
     for(;;){
      if(! param$0) return t$0;
      var x = param$0[1];
      if(! param$0[2]) return caml_call2(encoder, t$0, x);
      var
       r = param$0[2],
       t$1 = caml_call2(encoder, t$0, x),
       t$2 = caml_call2(sep, t$1, e),
       t$0 = t$2,
       param$0 = r;
     }
    }
    return go;
   }
   function option(encoder, t, param){
    if(! param) return t;
    var x = param[1];
    return caml_call2(encoder, t, x);
   }
   function char$0(t, x){
    var
     _g_ = caml_call2(Stdlib_String[1], 1, x),
     atom = caml_call4(Prettym_Pretty[8], _a_, 0, 0, _g_);
    return caml_call2(Prettym_Pretty[15], atom, t);
   }
   function string(t, x){
    var atom = caml_call4(Prettym_Pretty[8], _b_, 0, 0, x);
    return caml_call2(Prettym_Pretty[15], atom, t);
   }
   function bytes(t, x){
    var atom = caml_call4(Prettym_Pretty[9], _c_, 0, 0, x);
    return caml_call2(Prettym_Pretty[15], atom, t);
   }
   function bigstring(t, x){
    var atom = caml_call4(Prettym_Pretty[10], _d_, 0, 0, x);
    return caml_call2(Prettym_Pretty[15], atom, t);
   }
   function breakable(t, x){
    var atom = caml_call4(Prettym_Pretty[8], _e_, 0, 0, x);
    return caml_call2(Prettym_Pretty[15], atom, t);
   }
   function concat(l1, l2){
    if(! l1) return l2;
    var t = l1[2], h = l1[1];
    return [0, h, concat(t, l2)];
   }
   function keval(k, t, param){
    if(! param) return caml_call1(k, t);
    var r = param[2], x = param[1];
    function k$0(t){return keval(k, t, r);}
    return keval_order(k$0, t, x);
   }
   function eval$0(t, fmt){return keval(function(_f_){return _f_;}, t, fmt);}
   var
    Prettym_Fancy =
      [0,
       keval_order,
       break$0,
       fws,
       spaces,
       cut,
       const$0,
       atom,
       a,
       atom,
       const$0,
       new_line,
       tbox,
       bbox,
       box,
       close,
       using,
       string,
       bytes,
       bigstring,
       breakable,
       char$0,
       list,
       option,
       concat,
       keval,
       eval$0];
   runtime.caml_register_global(9, Prettym_Fancy, "Prettym__Fancy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Prettym
//# unitInfo: Requires: Bigstringaf, Fmt, Prettym__Enclosure, Prettym__Fancy, Prettym__Pretty, Stdlib__Buffer, Stdlib__List, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "\r\n",
    cst_Leave_a_non_empty_encoder = "Leave a non-empty encoder",
    cst_Leave_with_a_non_empty_enc = "Leave with a non-empty encoder",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Prettym_Pretty = global_data.Prettym__Pretty,
    Fmt = global_data.Fmt,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_List = global_data.Stdlib__List,
    Prettym_Fancy = global_data.Prettym__Fancy,
    Prettym_Enclosure = global_data.Prettym__Enclosure,
    keval_order = Prettym_Fancy[1],
    break$0 = Prettym_Fancy[2],
    fws = Prettym_Fancy[3],
    spaces = Prettym_Fancy[4],
    cut = Prettym_Fancy[5],
    const$0 = Prettym_Fancy[6],
    atom = Prettym_Fancy[7],
    a = Prettym_Fancy[8],
    symbol = Prettym_Fancy[9],
    symbol$0 = Prettym_Fancy[10],
    new_line = Prettym_Fancy[11],
    tbox = Prettym_Fancy[12],
    bbox = Prettym_Fancy[13],
    box = Prettym_Fancy[14],
    close = Prettym_Fancy[15],
    using = Prettym_Fancy[16],
    string = Prettym_Fancy[17],
    bytes = Prettym_Fancy[18],
    bigstring = Prettym_Fancy[19],
    breakable = Prettym_Fancy[20],
    char$0 = Prettym_Fancy[21],
    list = Prettym_Fancy[22],
    option = Prettym_Fancy[23],
    concat = Prettym_Fancy[24],
    keval = Prettym_Fancy[25],
    eval$0 = Prettym_Fancy[26],
    create = Prettym_Pretty[19],
    is_empty = Prettym_Pretty[18],
    flush = Prettym_Pretty[17],
    kflush = Prettym_Pretty[16],
    _b_ =
      [0,
       [11, cst_Leave_with_a_non_empty_enc, 0],
       cst_Leave_with_a_non_empty_enc],
    _a_ =
      [0,
       [11, cst_Leave_a_non_empty_encoder, 0],
       cst_Leave_a_non_empty_encoder],
    io_buffer_size = 65536;
   function to_string(opt, _g_, gen, value){
    if(opt) var sth = opt[1], margin = sth; else var margin = 78;
    if(_g_) var sth$0 = _g_[1], new_line = sth$0; else var new_line = cst;
    var buf = caml_call1(Stdlib_Buffer[1], 256);
    function write(a, x){
     var match = x[1];
     switch(match[0]){
       case 0:
        var
         len = x[3],
         off = x[2],
         x$0 = match[1],
         x$1 = caml_call3(Bigstringaf[7], x$0, off, len);
        caml_call2(Stdlib_Buffer[16], buf, x$1);
        return a + len | 0;
       case 1:
        var len$0 = x[3], off$0 = x[2], x$2 = match[1];
        caml_call4(Stdlib_Buffer[18], buf, x$2, off$0, len$0);
        return a + len$0 | 0;
       default:
        var len$1 = x[3], off$1 = x[2], x$3 = match[1];
        caml_call4(Stdlib_Buffer[19], buf, x$3, off$1, len$1);
        return a + len$1 | 0;
     }
    }
    var
     emitter = caml_call2(Stdlib_List[26], write, 0),
     encoder =
       caml_call4
        (Prettym_Pretty[19], [0, margin], [0, new_line], emitter, 256);
    function kend(encoder){
     return caml_call1(Prettym_Pretty[18], encoder)
             ? 0
             : caml_call1(Fmt[11], _a_);
    }
    var
     encoder$0 =
       caml_call3
        (eval$0, encoder, [0, caml_call1(Prettym_Fancy[9], gen), 0], value);
    caml_call2(Prettym_Pretty[16], kend, encoder$0);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function to_stream(opt, _c_, gen, value){
    if(opt) var sth = opt[1], margin = sth; else var margin = 78;
    if(_c_) var sth$0 = _c_[1], new_line = sth$0; else var new_line = cst$0;
    var
     queue = caml_call1(Stdlib_Queue[2], 0),
     line = caml_call1(Stdlib_Buffer[1], 4096);
    function emitter(iovecs){
     function write(a, x){
      var match = x[1];
      switch(match[0]){
        case 0:
         var
          len = x[3],
          off = x[2],
          x$0 = match[1],
          x$1 = caml_call3(Bigstringaf[7], x$0, off, len);
         caml_call2(Stdlib_Buffer[16], line, x$1);
         return a + len | 0;
        case 1:
         var len$0 = x[3], off$0 = x[2], x$2 = match[1];
         caml_call4(Stdlib_Buffer[18], line, x$2, off$0, len$0);
         return a + len$0 | 0;
        default:
         var len$1 = x[3], off$1 = x[2], x$3 = match[1];
         caml_call4(Stdlib_Buffer[19], line, x$3, off$1, len$1);
         return a + len$1 | 0;
      }
     }
     var
      len = caml_call3(Stdlib_List[26], write, 0, iovecs),
      res = caml_call1(Stdlib_Buffer[2], line);
     if(0 < runtime.caml_ml_string_length(res))
      caml_call2(Stdlib_Queue[3], res, queue);
     caml_call1(Stdlib_Buffer[8], line);
     return len;
    }
    function consumer(param){
     try{var x = caml_call1(Stdlib_Queue[7], queue);}
     catch(_f_){
      var _e_ = caml_wrap_exception(_f_);
      if(_e_ === Stdlib_Queue[1]) return 0;
      throw caml_maybe_attach_backtrace(_e_, 0);
     }
     return [0, x];
    }
    var
     encoder =
       caml_call4
        (Prettym_Pretty[19], [0, margin], [0, new_line], emitter, 4096);
    function kend(encoder){
     return caml_call1(Prettym_Pretty[18], encoder)
             ? 0
             : caml_call1(Fmt[11], _b_);
    }
    var _d_ = [0, caml_call1(Prettym_Fancy[9], gen), 0];
    caml_call4
     (keval, caml_call1(Prettym_Pretty[16], kend), encoder, _d_, value);
    return consumer;
   }
   var
    Prettym =
      [0,
       keval_order,
       break$0,
       fws,
       spaces,
       cut,
       const$0,
       atom,
       a,
       symbol,
       symbol$0,
       new_line,
       tbox,
       bbox,
       box,
       close,
       using,
       string,
       bytes,
       bigstring,
       breakable,
       char$0,
       list,
       option,
       concat,
       keval,
       eval$0,
       Prettym_Enclosure[1],
       Prettym_Enclosure[2],
       io_buffer_size,
       create,
       is_empty,
       flush,
       kflush,
       to_string,
       to_stream];
   runtime.caml_register_global(12, Prettym, "Prettym");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcmV0dHltLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJkZWFkYmVlZiIsIngiLCJwcF9jaHIiLCJwcF9zY2FsYXIiLCJnZXQiLCJsZW5ndGgiLCJwcGYiLCJiIiwibCIsImkiLCJqIiwicHAkMCIsIngkMCIsIngkMSIsIndlaWdodCIsInN1YiIsImJ1ZmZlciIsIm9mZiIsImxlbiIsIndlaWdodCQwIiwicHAkMSIsInQiLCJzZW50aW5lbCIsImEiLCJsZW5ndGh2Iiwic2hpZnQiLCJuIiwic3BsaXQiLCJtZXJnZSIsImEkMCIsImEkMSIsImIkMCIsInBwIiwibWFzayIsInBwX2ZsdXNoIiwicHAkMiIsImlzX2VtcHR5IiwidCQwIiwiY3JlYXRlIiwiZW1pdHRlciIsIndyaXRlIiwiY2FwYWNpdHkkMCIsImNhcGFjaXR5IiwicSIsImNoZWNrIiwiaW92ZWMiLCJidWYiLCJmbHVzaCIsImsiLCJ0JDYiLCJ0JDEiLCJ3cml0dGVuIiwiZ28iLCJmIiwidGhyZXNob2xkIiwidCQ3IiwicmVzIiwiZHJhaW4iLCJyZXN0IiwidCQyIiwidCQzIiwic2hpZnRlZCIsInQkNSIsInQkNCIsInJlc3QkMCIsInYiLCJpJDAiLCJxJDAiLCJzY2hlZHVsZSIsIm9wdCIsImskMCIsIm9wdCQwIiwibGVuJDAiLCJzdGgiLCJsZW4kMSIsImxlbiQyIiwidiQwIiwic2NoZWQiLCJtYXgiLCJrJDMiLCJrJDEiLCJsZW4kMyIsIm9wdCQxIiwiayQ0IiwiayQyIiwibGVuZ3RoJDAiLCJrc2NoZWR1bGVfc3RyaW5nIiwic2NoZWR1bGVfc3RyaW5nIiwibGVuZ3RoJDEiLCJidWZmZXIkMCIsImtzY2hlZHVsZV9ieXRlcyIsInNjaGVkdWxlX2J5dGVzIiwibGVuZ3RoJDIiLCJidWZmZXIkMSIsImtzY2hlZHVsZV9iaWdzdHJpbmciLCJzY2hlZHVsZV9iaWdzdHJpbmciLCJzY2hlZHVsZV9mbHVzaCIsImtzY2hlZHVsZXZfYmlnc3RyaW5nIiwiciIsImt3cml0ZSIsImJsaXQiLCJhdmFpbGFibGUiLCJhcmVhcyIsIndyaXRlJDAiLCJhcmVhcyQwIiwiYmlnYXJyYXlfYmxpdF9mcm9tX3N0cmluZyIsInNyYyIsInNyY19vZmYiLCJkc3QiLCJkc3Rfb2ZmIiwiYmlnYXJyYXlfYmxpdF9mcm9tX2J5dGVzIiwiYmlnYXJyYXlfYmxpdCIsImxlbmd0aCQzIiwid3JpdGVfc3RyaW5nIiwibGVuZ3RoJDQiLCJ3cml0ZV9ieXRlcyIsImxlbmd0aCQ1Iiwid3JpdGVfYmlnc3RyaW5nIiwibGVuZ3RoJDYiLCJ3cml0ZV9jaGFyIiwibGVuZ3RoJDciLCJibGl0JDAiLCJ3cml0ZV91aW50OCIsImt3cml0ZV91aW50MTYiLCJ3cml0ZV91aW50MTYiLCJrd3JpdGVfdWludDMyIiwid3JpdGVfdWludDMyIiwiYmxpdCQxIiwia3dyaXRlX3VpbnQ2NCIsIndyaXRlX3VpbnQ2NCIsInNldF9pbnQxNiIsInNldF9pbnQzMiIsInNldF9pbnQ2NCIsInNldF9pbnQxNiQwIiwic2V0X2ludDMyJDAiLCJzZXRfaW50NjQkMCIsImZ3cyIsImxlbmd0aF9vZl92YWx1ZSIsInZlYyIsImJveCIsInRib3giLCJpbmRlbnQiLCJiYm94IiwibyIsIm5ld19saW5lIiwiY2xvc2UiLCJzcGFjZXMiLCJicmVhayQwIiwiYnJlYWthYmxlIiwic3RyaW5nIiwic3RoJDAiLCJ2YWx1ZSIsImJ5dGVzIiwiYmlnc3RyaW5nIiwibGVuZ3RoX29mX3Rva2VuIiwiZW1wdHkiLCJzd2FwX2V4biIsImZvbGQiLCJ0YWlsX2V4biIsIm1hcCIsInBwX2JveCIsInBwX2JyZWFrIiwicHBfdG9rZW4iLCJvZmYkMCIsIm9mZiQxIiwic3ltYm9sIiwiZyIsImZsaXAiLCJlbWl0X2xpbmUiLCJxdWV1ZSIsImVuY29kZXIiLCJxdWV1ZSQwIiwicXVldWUkMiIsInF1ZXVlJDMiLCJxdWV1ZSQ0IiwidiQxIiwicXVldWUkNSIsInF1ZXVlJDEiLCJtZXJnZV9pbmRlbnRzIiwiaW5kZW50X2J5X2JveCIsImluZGVudF9ieV9icmVhayIsImlzX2luX2JveCIsIndpdGhvdXRfbGFzdF9ib3giLCJxJDEiLCJ1bnJvbGxfbGFzdF9ib3hfYW5kX2VtaXQiLCJhY2MkMSIsImFjYyIsImFjYyQwIiwia3B1c2giLCJjdXJyZW50X2xlbmd0aF9vZl9saW5lIiwiYXBwZW5kIiwic3RhY2siLCJzdGFjayQwIiwibGVudiIsInZhbHVlJDAiLCJ2MCIsInYxIiwidmVjJDAiLCJ2MCQwIiwidjEkMCIsInYkMiIsInZlYyQxIiwidmFsdWUxIiwidmFsdWUwIiwidG9rZW4wIiwidG9rZW4xIiwidmFsdWUkMSIsImxlbl94IiwiaW5kZW50JDEiLCJpbmRlbnQkMCIsImtmbHVzaCIsInB1c2giLCJtYXJnaW4iLCJjdXQiLCJrZXZhbF9vcmRlciIsImVuY29kZXIkMCIsImNvbnN0JDAiLCJhdG9tIiwidXNpbmciLCJsaXN0IiwiZSIsInNlcCIsIm9wdGlvbiIsImNoYXIkMCIsImNvbmNhdCIsImwxIiwibDIiLCJoIiwia2V2YWwiLCJldmFsJDAiLCJmbXQiLCJpb19idWZmZXJfc2l6ZSIsInRvX3N0cmluZyIsImdlbiIsIngkMiIsIngkMyIsImtlbmQiLCJ0b19zdHJlYW0iLCJsaW5lIiwiaW92ZWNzIiwiY29uc3VtZXIiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9wcmV0dHltL2VuY2xvc3VyZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3ByZXR0eW0vcHJldHR5Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcHJldHR5bS9mYW5jeS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3ByZXR0eW0vcHJldHR5bS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7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MEIsNEJBRDFCQSxLQW5CRmlIO0tBcUJGLDZCQXBCRXFFO0tBb0JGLE9BSEk1TjtJQUlEO0lBRUwsU0FBSThOO0tBQ0YsSUFBTSxJQUFxQi9PLElBQXJCLDRCQXpCSndLOzs7a0NBeUJnRTs7O0tBQWxDLFdBQUx4SztJQUEyQztJQUUxRDtLQUFWeUs7T0FBVTtpQ0E1QkEwQyxhQUFlcEUsV0FHekJ6RztJQTBCSixTQUFJcU0sS0FBS2xFO0tBQ1AsT0FBRywrQkFESUE7O2VBRUY7SUFBNkM7SUFFRixjQUFFLDZCQWpDSitEO0lBaUN2QzthQUFNLCtCQUpYRyxPQURBbEUsY0E1QmdEbkI7SUFrQ3BELE9BVEl5RjtHQVNJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXpFTlQ7T0FJQWpNO09BQ0FGO09BQ0FXO09BQ0FtSztPQUVBc0I7T0E4QkFLOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIltAQEB3YXJuaW5nIFwiLTMyXCJdXG5cbm1vZHVsZSB0eXBlIFYgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHBwIDogdCBGbXQudFxuICB2YWwgc2VudGluZWwgOiB0XG4gIHZhbCB3ZWlnaHQgOiB0IC0+IGludFxuICB2YWwgbWVyZ2UgOiB0IC0+IHQgLT4gdCBvcHRpb25cbmVuZFxuXG5tb2R1bGUgUkJRIChWIDogVikgPSBzdHJ1Y3RcbiAgbW9kdWxlIFF1ZXVlID0gS2UuRmtlLldlaWdodGVkXG5cbiAgdHlwZSB0ID0ge1xuICAgIGEgOiBWLnQgYXJyYXk7XG4gICAgYyA6IGludDtcbiAgICBtIDogaW50O1xuICAgIHEgOiAoaW50LCBCaWdhcnJheS5pbnRfZWx0KSBRdWV1ZS50O1xuICB9XG4gICgqIFhYWChkaW5vc2F1cmUpOiBba2VdIGlzIGxpbWl0ZWQgdG8gW0JpZ2FycmF5LmtpbmRdLiBXZSBtYWtlIGFuIFthcnJheV1cbiAgICAgd2hpY2ggd2lsbCBjb250YWluIHZhbHVlcyBhbmQgW3FdIHdpbGwgY29udGFpbiBpbmRleCBvZiB0aGVtLiBMZW5ndGggb2YgW2FdXG4gICAgIGlzIGxlbmd0aCBvZiBbcV0uIEJ5IHRoaXMgd2F5LCBsZW5ndGggaXMgYSBwb3dlciBvZiB0d28gYW5kIFthXSBmb2xsb3dzXG4gICAgIHNhbWUgYXNzZXJ0aW9ucyAoc2VlIFttYXNrXSkgYXMgW0tlXS5cblxuICAgICBbY10gd2lsbCBiZSB0aGUgY3Vyc29yIGluIFthXS4gW21dIGlzIHRoZSBjYXBhY2l0eS4gSXQncyBhIGdvb2QgZXhhbXBsZSBvZlxuICAgICBba2VdIHdpdGggc29tZXRoaW5nIGVsc2UgdGhhbiBbQmlnYXJyYXkua2luZF0uICopXG5cbiAgbGV0IG1ha2UgY2FwYWNpdHkgPVxuICAgIGxldCBxLCBjYXBhY2l0eSA9IFF1ZXVlLmNyZWF0ZSB+Y2FwYWNpdHkgQmlnYXJyYXkuSW50IGluXG4gICAgeyBhID0gQXJyYXkubWFrZSBjYXBhY2l0eSBWLnNlbnRpbmVsOyBjID0gMDsgbSA9IGNhcGFjaXR5OyBxIH1cblxuICBsZXQgcHAgcHBmIHQgPVxuICAgIGxldCBhID0gQXJyYXkubWFrZSAoUXVldWUubGVuZ3RoIHQucSkgVi5zZW50aW5lbCBpblxuICAgIGxldCB4ID0gcmVmIDAgaW5cbiAgICBRdWV1ZS5pdGVyXG4gICAgICAoZnVuIGkgLT5cbiAgICAgICAgYS4oIXgpIDwtIHQuYS4oaSk7XG4gICAgICAgIGluY3IgeClcbiAgICAgIHQucTtcbiAgICBGbXQucGYgcHBmIFwieyBAWzxob3Y+YSA9ICVhO0AgYyA9ICVkO0AgbSA9ICVkO0AgcSA9ICVhO0BdIH1cIlxuICAgICAgRm10LihEdW1wLmFycmF5IFYucHApXG4gICAgICBhIHQuYyB0Lm0gKFF1ZXVlLmR1bXAgRm10LmludCkgdC5xXG5cbiAgbGV0IGF2YWlsYWJsZSB0ID0gUXVldWUuYXZhaWxhYmxlIHQucVxuICBsZXQgaXNfZW1wdHkgdCA9IFF1ZXVlLmlzX2VtcHR5IHQucVxuICBsZXRbQGlubGluZSBhbHdheXNdIG1hc2sgeCB0ID0geCBsYW5kICh0Lm0gLSAxKVxuXG4gIGxldCBwdXNoIHQgdiA9XG4gICAgbGV0IGkgPSBtYXNrIHQuYyB0IGluXG4gICAgbWF0Y2ggUXVldWUucHVzaCB0LnEgaSB3aXRoXG4gICAgfCBTb21lIHEgLT5cbiAgICAgICAgdC5hLihpKSA8LSB2O1xuICAgICAgICBPayB7IHQgd2l0aCBjID0gc3VjYyB0LmM7IHEgfVxuICAgIHwgTm9uZSAtPiBFcnJvciB0XG5cbiAgbGV0IHNoaWZ0X2V4biB0ID1cbiAgICBsZXQgaSwgcSA9IFF1ZXVlLnBvcF9leG4gdC5xIGluXG4gICAgKHQuYS4oaSksIHsgdCB3aXRoIHEgfSlcblxuICBsZXQgY29ucyB0IHYgPVxuICAgIGxldCBpID0gbWFzayB0LmMgdCBpblxuICAgIG1hdGNoIFF1ZXVlLmNvbnMgdC5xIGkgd2l0aFxuICAgIHwgU29tZSBxIC0+XG4gICAgICAgIHQuYS4oaSkgPC0gdjtcbiAgICAgICAgT2sgeyB0IHdpdGggYyA9IHN1Y2MgdC5jOyBxIH1cbiAgICB8IE5vbmUgLT4gRXJyb3IgdFxuXG4gIGV4Y2VwdGlvbiBGdWxsXG5cbiAgbGV0IGNvbnNfZXhuIHQgdiA9IG1hdGNoIGNvbnMgdCB2IHdpdGggT2sgdCAtPiB0IHwgRXJyb3IgXyAtPiByYWlzZSBGdWxsXG4gIGxldCB3ZWlnaHQgdCA9IFF1ZXVlLmZvbGQgKGZ1biBhIGkgLT4gYSArIFYud2VpZ2h0IHQuYS4oaSkpIDAgdC5xXG5cbiAgbGV0IHRvX2xpc3QgdCA9XG4gICAgbGV0IHJlcyA9IHJlZiBbXSBpblxuICAgIFF1ZXVlLnJldl9pdGVyIChmdW4gaSAtPiByZXMgOj0gdC5hLihpKSA6OiAhcmVzKSB0LnE7XG4gICAgIXJlc1xuZW5kXG5cbmxldCBwcF9jaHIgPVxuICBGbXQudXNpbmcgKGZ1bmN0aW9uICdcXDAzMicgLi4gJ1xcMTI2JyBhcyB4IC0+IHggfCBfIC0+ICcuJykgRm10LmNoYXJcblxubGV0IHBwX3NjYWxhciA6XG4gICAgdHlwZSBidWZmZXIuXG4gICAgZ2V0OihidWZmZXIgLT4gaW50IC0+IGNoYXIpIC0+IGxlbmd0aDooYnVmZmVyIC0+IGludCkgLT4gYnVmZmVyIEZtdC50ID1cbiBmdW4gfmdldCB+bGVuZ3RoIHBwZiBiIC0+XG4gIGxldCBsID0gbGVuZ3RoIGIgaW5cbiAgZm9yIGkgPSAwIHRvIGwgLyAxNiBkb1xuICAgIEZtdC5wZiBwcGYgXCIlMDh4OiBcIiAoaSAqIDE2KTtcbiAgICBsZXQgaiA9IHJlZiAwIGluXG4gICAgd2hpbGUgIWogPCAxNiBkb1xuICAgICAgaWYgKGkgKiAxNikgKyAhaiA8IGwgdGhlblxuICAgICAgICBGbXQucGYgcHBmIFwiJTAyeFwiIChDaGFyLmNvZGUgQEAgZ2V0IGIgKChpICogMTYpICsgIWopKVxuICAgICAgZWxzZSBGbXQucGYgcHBmIFwiICBcIjtcbiAgICAgIGlmICFqIG1vZCAyIDw+IDAgdGhlbiBGbXQucGYgcHBmIFwiIFwiO1xuICAgICAgaW5jciBqXG4gICAgZG9uZTtcbiAgICBGbXQucGYgcHBmIFwiICBcIjtcbiAgICBqIDo9IDA7XG4gICAgd2hpbGUgIWogPCAxNiBkb1xuICAgICAgaWYgKGkgKiAxNikgKyAhaiA8IGwgdGhlbiBGbXQucGYgcHBmIFwiJWFcIiBwcF9jaHIgKGdldCBiICgoaSAqIDE2KSArICFqKSlcbiAgICAgIGVsc2UgRm10LnBmIHBwZiBcIiBcIjtcbiAgICAgIGluY3IgalxuICAgIGRvbmU7XG5cbiAgICBGbXQucGYgcHBmIFwiQCxcIlxuICBkb25lXG5cbm1vZHVsZSBSQkEgPSBLZS5Ga2UuV2VpZ2h0ZWRcblxubW9kdWxlIEJ1ZmZlciA9IHN0cnVjdFxuICB0eXBlIHQgPSBCaWdzdHJpbmcgb2YgQmlnc3RyaW5nYWYudCB8IFN0cmluZyBvZiBzdHJpbmcgfCBCeXRlcyBvZiBieXRlc1xuXG4gIGxldCBwcCBwcGYgPSBmdW5jdGlvblxuICAgIHwgQmlnc3RyaW5nIHggLT5cbiAgICAgICAgcHBfc2NhbGFyIH5sZW5ndGg6Qmlnc3RyaW5nYWYubGVuZ3RoIH5nZXQ6Qmlnc3RyaW5nYWYuZ2V0IHBwZiB4XG4gICAgfCBTdHJpbmcgeCAtPiBwcF9zY2FsYXIgfmxlbmd0aDpTdHJpbmcubGVuZ3RoIH5nZXQ6U3RyaW5nLmdldCBwcGYgeFxuICAgIHwgQnl0ZXMgeCAtPiBwcF9zY2FsYXIgfmxlbmd0aDpCeXRlcy5sZW5ndGggfmdldDpCeXRlcy5nZXQgcHBmIHhcblxuICBsZXQgd2VpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IEJpZ3N0cmluZyB4IC0+IEJpZ3N0cmluZ2FmLmxlbmd0aCB4XG4gICAgfCBTdHJpbmcgeCAtPiBTdHJpbmcubGVuZ3RoIHhcbiAgICB8IEJ5dGVzIHggLT4gQnl0ZXMubGVuZ3RoIHhcblxuICBsZXQgc3ViIGJ1ZmZlciBvZmYgbGVuID1cbiAgICBtYXRjaCBidWZmZXIgd2l0aFxuICAgIHwgQmlnc3RyaW5nIHggLT4gQmlnc3RyaW5nIChCaWdzdHJpbmdhZi5zdWIgeCB+b2ZmIH5sZW4pXG4gICAgfCBTdHJpbmcgeCAtPiBTdHJpbmcgKFN0cmluZy5zdWIgeCBvZmYgbGVuKVxuICAgIHwgQnl0ZXMgeCAtPiBCeXRlcyAoQnl0ZXMuc3ViIHggb2ZmIGxlbilcbmVuZFxuXG5tb2R1bGUgSU9WZWMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBidWZmZXIgOiBCdWZmZXIudDsgb2ZmIDogaW50OyBsZW4gOiBpbnQgfVxuXG4gIGxldCB3ZWlnaHQgeyBsZW47IF8gfSA9IGxlblxuXG4gIGxldCBwcCBwcGYgdCA9XG4gICAgRm10LnBmIHBwZiBcInsgQFs8aG92PmJ1ZmZlcj0gQFs8aG92PiVhQF07QCBvZmY9ICVkO0AgbGVuPSAlZDtAXSB9XCIgQnVmZmVyLnBwXG4gICAgICB0LmJ1ZmZlciB0Lm9mZiB0LmxlblxuXG4gIGxldCBzZW50aW5lbCA9XG4gICAgbGV0IGRlYWRiZWVmID0gXCJcXDIyMlxcMTczXFwxOTBcXDIzOVwiIGluXG4gICAgeyBidWZmZXIgPSBCdWZmZXIuU3RyaW5nIGRlYWRiZWVmOyBvZmYgPSAwOyBsZW4gPSBTdHJpbmcubGVuZ3RoIGRlYWRiZWVmIH1cblxuICBsZXQgbWFrZSBidWZmZXIgb2ZmIGxlbiA9IHsgYnVmZmVyOyBvZmY7IGxlbiB9XG4gIGxldCBsZW5ndGggeyBsZW47IF8gfSA9IGxlblxuICBsZXQgbGVuZ3RodiA9IExpc3QuZm9sZF9sZWZ0IChmdW4gYSB4IC0+IGxlbmd0aCB4ICsgYSkgMFxuXG4gIGxldCBzaGlmdCB7IGJ1ZmZlcjsgb2ZmOyBsZW4gfSBuID1cbiAgICBhc3NlcnQgKG4gPD0gbGVuKTtcbiAgICB7IGJ1ZmZlcjsgb2ZmID0gb2ZmICsgbjsgbGVuID0gbGVuIC0gbiB9XG5cbiAgbGV0IHNwbGl0IHsgYnVmZmVyOyBvZmY7IGxlbiB9IG4gPVxuICAgIGFzc2VydCAobiA8PSBsZW4pO1xuICAgICggeyBidWZmZXIgPSBCdWZmZXIuc3ViIGJ1ZmZlciBvZmYgbjsgb2ZmID0gMDsgbGVuID0gbiB9LFxuICAgICAgeyBidWZmZXIgPSBCdWZmZXIuc3ViIGJ1ZmZlciAob2ZmICsgbikgKGxlbiAtIG4pOyBvZmYgPSAwOyBsZW4gPSBsZW4gLSBuIH1cbiAgICApXG5cbiAgbGV0IG1lcmdlIGEgYiA9XG4gICAgbWF0Y2ggKGEsIGIpIHdpdGhcbiAgICB8IHsgYnVmZmVyID0gQnVmZmVyLkJ5dGVzIGEnOyBfIH0sIHsgYnVmZmVyID0gQnVmZmVyLkJ5dGVzIGInOyBfIH0gLT5cbiAgICAgICAgYXNzZXJ0IChhJyA9PSBiJyk7XG4gICAgICAgIGlmIGEub2ZmICsgYS5sZW4gPSBiLm9mZiB0aGVuXG4gICAgICAgICAgU29tZSB7IGJ1ZmZlciA9IEJ1ZmZlci5CeXRlcyBhJzsgb2ZmID0gYS5vZmY7IGxlbiA9IGEubGVuICsgYi5sZW4gfVxuICAgICAgICBlbHNlIE5vbmVcbiAgICB8IHsgYnVmZmVyID0gQnVmZmVyLkJpZ3N0cmluZyBhJzsgXyB9LCB7IGJ1ZmZlciA9IEJ1ZmZlci5CaWdzdHJpbmcgXzsgXyB9IC0+XG4gICAgICAgIGlmIGEub2ZmICsgYS5sZW4gPSBiLm9mZiB0aGVuXG4gICAgICAgICAgU29tZVxuICAgICAgICAgICAgeyBidWZmZXIgPSBCdWZmZXIuQmlnc3RyaW5nIGEnOyBvZmYgPSBhLm9mZjsgbGVuID0gYS5sZW4gKyBiLmxlbiB9XG4gICAgICAgIGVsc2UgTm9uZVxuICAgIHwgXywgXyAtPiBOb25lXG5lbmRcblxubW9kdWxlIFJCUyA9IFJCUSAoSU9WZWMpXG5cbnR5cGUgZW1pdHRlciA9IElPVmVjLnQgbGlzdCAtPiBpbnRcblxudHlwZSBlbmNvZGVyID0ge1xuICBzY2hlZCA6IFJCUy50O1xuICB3cml0ZSA6IChjaGFyLCBCaWdhcnJheS5pbnQ4X3Vuc2lnbmVkX2VsdCkgUkJBLnQ7XG4gIGZsdXNoIDogKGludCAqIChpbnQgLT4gZW5jb2RlciAtPiB1bml0KSkgS2UuRmtlLnQ7XG4gIHdyaXR0ZW4gOiBpbnQ7XG4gIHJlY2VpdmVkIDogaW50O1xuICBlbWl0dGVyIDogZW1pdHRlcjtcbn1cblxubGV0IHBwX2ZsdXNoIHBwZiBfID0gRm10LnN0cmluZyBwcGYgXCIjZmx1c2hcIlxuXG5sZXQgcHAgcHBmIHQgPVxuICBGbXQucGYgcHBmXG4gICAgXCJ7IEBbPGhvdj5zY2hlZD0gQFs8aG92PiVhQF07QCB3cml0ZT0gQFs8aG92PiVhQF07QCBmbHVzaD0gQFs8aG92PiVhQF07QCBcXFxuICAgICB3cml0dGVuPSAlZDtAIHJlY2VpdmVkPSAlZDtAIGVtaXR0ZXI9ICNlbWl0dGVyO0BdIH1cIlxuICAgIFJCUy5wcCB0LnNjaGVkIChSQkEucHAgcHBfY2hyKSB0LndyaXRlIChLZS5Ga2UucHAgcHBfZmx1c2gpIHQuZmx1c2hcbiAgICB0LndyaXR0ZW4gdC5yZWNlaXZlZFxuXG5sZXQgaXNfZW1wdHkgdCA9IFJCUy5pc19lbXB0eSB0LnNjaGVkXG5cbigqIFhYWChkaW5vc2F1cmUpOiBbc2NoZWRdIGlzIGEgcXVldWUgb2YgW0lPVmVjXS4gW3dyaXRlXSBpcyBhXG4gICByaW5nLWJ1ZmZlci9bQmlnc3RyaW5nYWYudF0uIFtmbHVzaF0gaXMgYSBxdWV1ZSB3aGljaCBjYW4gY29udGFpblxuICAgdXNlci1kZWZpbmVkIG9wZXJhdGlvbiBhdCBhIGJyZWFrIHBvaW50LiBbd3JpdHRlbl0gaXMgaG93IG1hbnkgYnl0ZXMgd2VcbiAgIHNlbmRlZCB0byB0aGUgdXNlciAoYWZ0ZXJ3YXJkcyBhICpmbHVzaCogb3BlcmF0aW9uKS4gW3JlY2VpdmVkXSBpcyBob3cgbWFueVxuICAgYnl0ZXMgd2UgcmVjZWl2ZWQgZnJvbSB0aGUgdXNlci5cblxuICAgVGhlIGdvYWwgaXMgdG8gaGF2ZSB0d28gd2F5cyB0byBmaWxsIG91dHB1dDpcbiAgIC0gYW4gaGVhdnkgd2F5IHdpdGggW3dyaXRlXypdIG9wZXJhdGlvbnMgd2hpY2ggd2lsbCBkbyBpbnRlcm5hbGx5IGEgW2JsaXRdLlxuICAgLSBhIHNvZnQgd2F5IHdpdGggW3NoZWR1bGVfKl0gb3BlcmF0aW9ucyB3aGljaCB3aWxsIHN0b3JlIGEgcG9pbnRlci5cblxuICAgVGhlIGNvbXBsZXhpdHkgaXMgdW5kZXIgW3NjaGVkXSB3aGVyZSBpdCBzdG9yZXMgcG9pbnRlciBmcm9tIHVzZXIgYnV0IHBvaW50ZXJcbiAgIGZyb20gW3dyaXRlXSBxdWV1ZSB0b28uIEluZGVlZCwgW3dyaXRlX10gb3BlcmF0aW9ucyBkaWQgbm90IGRvIG9ubHkgYSBbYmxpdF1cbiAgIGJ1dCB0aGVuIHRoZXkgc3RvcmUgcmVzdWx0ZWQvKmJsaXR0ZWQqIFtCaWdzdHJpbmdhZi50XSBwYXJ0IHRvIFtzY2hlZF0uXG5cbiAgIFdoZW4gd2Ugd2FudCB0byBzaGlmdCBhIHBhcnQgb2YgW2VuY29kZXJdLCAqKmFsbCoqIGJ1ZmZlcnMgYXJlIHN0b3JlZCBpblxuICAgW3NjaGVkXS4gU28gd2UgbmVlZCB0byBzaGlmdCBbc2NoZWRdLiBIb3dldmVyLCByZXN1bHRlZCBbSU9WZWNdIGNhbiBiZVxuICAgcGh5c2ljYWxseSBhIHBhcnQgb2YgW3dyaXRlXS4gSW4gdGhpcyBjb250ZXh0LCB3ZSBuZWVkIHRvIHNoaWZ0IFt3cml0ZV0uICopXG5cbmxldCBjcmVhdGUgfmVtaXR0ZXIgbGVuID1cbiAgbGV0IHdyaXRlLCBfID0gUkJBLmNyZWF0ZSB+Y2FwYWNpdHk6bGVuIEJpZ2FycmF5LkNoYXIgaW5cbiAge1xuICAgIHNjaGVkID0gUkJTLm1ha2UgKGxlbiAqIDIpO1xuICAgIHdyaXRlO1xuICAgIGZsdXNoID0gS2UuRmtlLmVtcHR5O1xuICAgIHdyaXR0ZW4gPSAwO1xuICAgIHJlY2VpdmVkID0gMDtcbiAgICBlbWl0dGVyO1xuICB9XG5cbmxldCBjaGVjayBpb3ZlYyB7IHdyaXRlOyBfIH0gPVxuICBtYXRjaCBpb3ZlYyB3aXRoXG4gIHwgeyBJT1ZlYy5idWZmZXIgPSBCdWZmZXIuQmlnc3RyaW5nIHg7IF8gfSAtPiAoXG4gICAgICBsZXQgYnVmID0gUkJBLnVuc2FmZV9iaWdhcnJheSB3cml0ZSBpblxuICAgICAgbWF0Y2ggT3ZlcmxhcC5hcnJheTEgeCBidWYgd2l0aCBTb21lIChfLCBfLCBfKSAtPiB0cnVlIHwgTm9uZSAtPiBmYWxzZSlcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBzaGlmdF9idWZmZXJzIHdyaXR0ZW4gdCA9XG4gIGxldCByZWMgZ28gd3JpdHRlbiBhY2MgdCA9XG4gICAgbWF0Y2ggUkJTLnNoaWZ0X2V4biB0LnNjaGVkIHdpdGhcbiAgICB8IGlvdmVjLCBzaGlmdGVkIC0+XG4gICAgICAgIGxldCBsZW4gPSBJT1ZlYy5sZW5ndGggaW92ZWMgaW5cbiAgICAgICAgaWYgd3JpdHRlbiA+IGxlbiB0aGVuXG4gICAgICAgICAgZ28gKHdyaXR0ZW4gLSBsZW4pIChpb3ZlYyA6OiBhY2MpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHQgd2l0aFxuICAgICAgICAgICAgICBzY2hlZCA9IHNoaWZ0ZWQ7XG4gICAgICAgICAgICAgIHdyaXRlID1cbiAgICAgICAgICAgICAgICAoaWYgY2hlY2sgaW92ZWMgdCB0aGVuIFJCQS5OLnNoaWZ0X2V4biB0LndyaXRlIGxlbiBlbHNlIHQud3JpdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIHdyaXR0ZW4gPiAwIHRoZW5cbiAgICAgICAgICBsZXQgbGFzdCwgcmVzdCA9IElPVmVjLnNwbGl0IGlvdmVjIHdyaXR0ZW4gaW5cbiAgICAgICAgICAoIExpc3QucmV2IChsYXN0IDo6IGFjYyksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHQgd2l0aFxuICAgICAgICAgICAgICBzY2hlZCA9IFJCUy5jb25zX2V4biBzaGlmdGVkIHJlc3Q7XG4gICAgICAgICAgICAgIHdyaXRlID1cbiAgICAgICAgICAgICAgICAoaWYgY2hlY2sgaW92ZWMgdCB0aGVuXG4gICAgICAgICAgICAgICAgIFJCQS5OLnNoaWZ0X2V4biB0LndyaXRlIChJT1ZlYy5sZW5ndGggbGFzdClcbiAgICAgICAgICAgICAgICBlbHNlIHQud3JpdGUpO1xuICAgICAgICAgICAgfSApXG4gICAgICAgIGVsc2UgKExpc3QucmV2IGFjYywgdClcbiAgICB8IGV4Y2VwdGlvbiBSQlMuUXVldWUuRW1wdHkgLT4gKExpc3QucmV2IGFjYywgdClcbiAgaW5cbiAgZ28gd3JpdHRlbiBbXSB0XG5cbmxldCBzaGlmdF9mbHVzaGVzIHdyaXR0ZW4gdCA9XG4gIGxldCByZWMgZ28gdCA9XG4gICAgdHJ5XG4gICAgICBsZXQgKHRocmVzaG9sZCwgZiksIGZsdXNoID0gS2UuRmtlLnBvcF9leG4gdC5mbHVzaCBpblxuICAgICAgaWYgY29tcGFyZSAodC53cml0dGVuICsgd3JpdHRlbiAtIG1pbl9pbnQpICh0aHJlc2hvbGQgLSBtaW5faW50KSA+PSAwIHRoZW5cbiAgICAgICAgbGV0ICgpID0gZiB3cml0dGVuIHsgdCB3aXRoIGZsdXNoIH0gaW5cbiAgICAgICAgZ28geyB0IHdpdGggZmx1c2ggfVxuICAgICAgZWxzZSB0XG4gICAgd2l0aCBLZS5Ga2UuRW1wdHkgLT4gdFxuICBpblxuICBnbyB0XG5cbmxldCBzaGlmdCBuIHQgPVxuICBsZXQgbHN0LCB0ID0gc2hpZnRfYnVmZmVycyBuIHQgaW5cbiAgKCBsc3QsXG4gICAgbGV0IHQgPSBzaGlmdF9mbHVzaGVzIChJT1ZlYy5sZW5ndGh2IGxzdCkgdCBpblxuICAgIHsgdCB3aXRoIHdyaXR0ZW4gPSB0LndyaXR0ZW4gKyBuIH0gKVxuXG5sZXQgaGFzIHQgPSBSQlMud2VpZ2h0IHQuc2NoZWRcblxubGV0IGRyYWluIGRyYWluIHQgPVxuICBsZXQgcmVjIGdvIHJlc3QgdCA9XG4gICAgbWF0Y2ggUkJTLnNoaWZ0X2V4biB0LnNjaGVkIHdpdGhcbiAgICB8IGlvdmVjLCBzaGlmdGVkIC0+XG4gICAgICAgIGxldCBsZW4gPSBJT1ZlYy5sZW5ndGggaW92ZWMgaW5cbiAgICAgICAgaWYgcmVzdCA+PSBsZW4gdGhlblxuICAgICAgICAgIGdvIChyZXN0IC0gbGVuKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0IHdpdGhcbiAgICAgICAgICAgICAgc2NoZWQgPSBzaGlmdGVkO1xuICAgICAgICAgICAgICB3cml0ZSA9XG4gICAgICAgICAgICAgICAgKGlmIGNoZWNrIGlvdmVjIHQgdGhlbiBSQkEuTi5zaGlmdF9leG4gdC53cml0ZSBsZW4gZWxzZSB0LndyaXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHQgd2l0aFxuICAgICAgICAgICAgc2NoZWQgPSBSQlMuY29uc19leG4gc2hpZnRlZCAoSU9WZWMuc2hpZnQgaW92ZWMgcmVzdCk7XG4gICAgICAgICAgICB3cml0ZSA9XG4gICAgICAgICAgICAgIChpZiBjaGVjayBpb3ZlYyB0IHRoZW4gUkJBLk4uc2hpZnRfZXhuIHQud3JpdGUgcmVzdCBlbHNlIHQud3JpdGUpO1xuICAgICAgICAgIH1cbiAgICB8IGV4Y2VwdGlvbiBSQlMuUXVldWUuRW1wdHkgLT4gdFxuICBpblxuICBsZXQgdCA9IGdvIGRyYWluIHQgaW5cbiAgeyB0IHdpdGggd3JpdHRlbiA9IHQud3JpdHRlbiArIGRyYWluIH1cblxubGV0IGZsdXNoIGsgdCA9XG4gIGxldCB0ID0gc2hpZnRfZmx1c2hlcyAoaGFzIHQpIHQgaW5cbiAgbGV0IG4gPSB0LmVtaXR0ZXIgKFJCUy50b19saXN0IHQuc2NoZWQpIGluXG4gIGxldCB0ID0gZHJhaW4gbiB0IGluXG4gIGsgeyB0IHdpdGggd3JpdHRlbiA9IHQud3JpdHRlbiArIG4gfVxuXG5sZXQgcmVjIHNjaGVkdWxlIGsgfmxlbmd0aCB+YnVmZmVyID8ob2ZmID0gMCkgP2xlbiB2IHQgPVxuICBsZXQgbGVuID0gbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBsZW5ndGggdiAtIG9mZiBpblxuICBtYXRjaCBSQlMucHVzaCB0LnNjaGVkIChJT1ZlYy5tYWtlIChidWZmZXIgdikgb2ZmIGxlbikgd2l0aFxuICB8IE9rIHNjaGVkIC0+XG4gICAgICAoKiBUT0RPOiBtZXJnZSBbQmlnc3RyaW5nYWYudF0uICopXG4gICAgICBrIHsgdCB3aXRoIHNjaGVkOyByZWNlaXZlZCA9IHQucmVjZWl2ZWQgKyBsZW4gfVxuICB8IEVycm9yIF8gLT5cbiAgICAgIGxldCBtYXggPSBSQlMuYXZhaWxhYmxlIHQuc2NoZWQgaW5cbiAgICAgIGxldCBrIHQgPVxuICAgICAgICAoc2NoZWR1bGUgW0B0YWlsY2FsbF0pIGsgfmxlbmd0aCB+YnVmZmVyIH5vZmY6KG9mZiArIG1heClcbiAgICAgICAgICB+bGVuOihsZW4gLSBtYXgpIHYgdFxuICAgICAgaW5cbiAgICAgIHNjaGVkdWxlIChmbHVzaCBrKSB+bGVuZ3RoIH5idWZmZXIgfm9mZiB+bGVuOm1heCB2IHRcblxuZXh0ZXJuYWwgaWRlbnRpdHkgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcblxubGV0IGtzY2hlZHVsZV9zdHJpbmcgPVxuICBsZXQgbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCBpblxuICBsZXQgYnVmZmVyIHggPSBCdWZmZXIuU3RyaW5nIHggaW5cbiAgZnVuIGsgdCA/KG9mZiA9IDApID9sZW4gdiAtPiBzY2hlZHVsZSBrIH5sZW5ndGggfmJ1ZmZlciB+b2ZmID9sZW4gdiB0XG5cbmxldCBzY2hlZHVsZV9zdHJpbmcgPSBrc2NoZWR1bGVfc3RyaW5nIGlkZW50aXR5XG5cbmxldCBrc2NoZWR1bGVfYnl0ZXMgPVxuICBsZXQgbGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGluXG4gIGxldCBidWZmZXIgeCA9IEJ1ZmZlci5CeXRlcyB4IGluXG4gIGZ1biBrIHQgPyhvZmYgPSAwKSA/bGVuIHYgLT4gc2NoZWR1bGUgayB+bGVuZ3RoIH5idWZmZXIgfm9mZiA/bGVuIHYgdFxuXG5sZXQgc2NoZWR1bGVfYnl0ZXMgPSBrc2NoZWR1bGVfYnl0ZXMgaWRlbnRpdHlcblxubGV0IGtzY2hlZHVsZV9iaWdzdHJpbmcgPVxuICBsZXQgbGVuZ3RoID0gQmlnYXJyYXkuQXJyYXkxLmRpbSBpblxuICBsZXQgYnVmZmVyIHggPSBCdWZmZXIuQmlnc3RyaW5nIHggaW5cbiAgZnVuIGsgdCA/KG9mZiA9IDApID9sZW4gdiAtPiBzY2hlZHVsZSBrIH5sZW5ndGggfmJ1ZmZlciB+b2ZmID9sZW4gdiB0XG5cbmxldCBzY2hlZHVsZV9iaWdzdHJpbmcgPSBrc2NoZWR1bGVfYmlnc3RyaW5nIGlkZW50aXR5XG5sZXQgc2NoZWR1bGVfZmx1c2ggZiB0ID0geyB0IHdpdGggZmx1c2ggPSBLZS5Ga2UucHVzaCB0LmZsdXNoICh0LnJlY2VpdmVkLCBmKSB9XG5cbmxldCBrc2NoZWR1bGV2IGsgbCB0ID1cbiAgbGV0IHJlYyBnbyB0ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGsgdFxuICAgIHwgKGxlbmd0aCwgb2ZmLCBsZW4sIGJ1ZmZlcikgOjogciAtPlxuICAgICAgICBzY2hlZHVsZVxuICAgICAgICAgIChmdW4gdCAtPiAoZ28gW0B0YWlsY2FsbF0pIHQgcilcbiAgICAgICAgICB+bGVuZ3RoID9vZmYgP2xlbiB+YnVmZmVyOmlkZW50aXR5IGJ1ZmZlciB0XG4gIGluXG4gIGdvIHQgbFxuXG5sZXQgc2NoZWR1bGV2ID0ga3NjaGVkdWxldiBpZGVudGl0eVxuXG5sZXQga3NjaGVkdWxldl9iaWdzdHJpbmcgayBsIHQgPVxuICBsZXQgcmVjIGdvIHQgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gayB0XG4gICAgfCBidWZmZXIgOjogciAtPlxuICAgICAgICBrc2NoZWR1bGVfYmlnc3RyaW5nIChmdW4gdCAtPiAoZ28gW0B0YWlsY2FsbF0pIHQgcikgdCBidWZmZXJcbiAgaW5cbiAgZ28gdCBsXG5cbmxldCBzY2hlZHVsZXZfYmlnc3RyaW5nID0ga3NjaGVkdWxldl9iaWdzdHJpbmcgaWRlbnRpdHlcblxubGV0IHJlYyBrd3JpdGUgayB+YmxpdCB+bGVuZ3RoID8ob2ZmID0gMCkgP2xlbiBidWZmZXIgdCA9XG4gIGxldCBsZW4gPSBtYXRjaCBsZW4gd2l0aCBTb21lIGxlbiAtPiBsZW4gfCBOb25lIC0+IGxlbmd0aCBidWZmZXIgLSBvZmYgaW5cbiAgbGV0IGF2YWlsYWJsZSA9IFJCQS5hdmFpbGFibGUgdC53cml0ZSBpblxuICAoKiBYWFgoZGlub3NhdXJlKTogd2UgY2FuIGZhY3Rvcml6ZSB0aGUgZmlyc3QgYW5kIHRoZSBzZWNvbmQgYnJhbmNoLiAqKVxuICBpZiBhdmFpbGFibGUgPj0gbGVuIHRoZW5cbiAgICBsZXQgYXJlYXMsIHdyaXRlID0gUkJBLk4ucHVzaF9leG4gdC53cml0ZSB+YmxpdCB+bGVuZ3RoIH5vZmYgfmxlbiBidWZmZXIgaW5cbiAgICBrc2NoZWR1bGV2X2JpZ3N0cmluZyBrIGFyZWFzIHsgdCB3aXRoIHdyaXRlIH1cbiAgZWxzZSBpZiBhdmFpbGFibGUgPiAwIHRoZW5cbiAgICBsZXQgayB0ID1cbiAgICAgIChrd3JpdGUgW0B0YWlsY2FsbF0pIGsgfmJsaXQgfmxlbmd0aCB+b2ZmOihvZmYgKyBhdmFpbGFibGUpXG4gICAgICAgIH5sZW46KGxlbiAtIGF2YWlsYWJsZSkgYnVmZmVyIHRcbiAgICBpblxuICAgIGxldCBhcmVhcywgd3JpdGUgPVxuICAgICAgUkJBLk4ucHVzaF9leG4gdC53cml0ZSB+YmxpdCB+bGVuZ3RoIH5vZmYgfmxlbjphdmFpbGFibGUgYnVmZmVyXG4gICAgaW5cbiAgICBrc2NoZWR1bGV2X2JpZ3N0cmluZyAoZmx1c2ggaykgYXJlYXMgeyB0IHdpdGggd3JpdGUgfVxuICBlbHNlXG4gICAgbGV0IGsgdCA9IChrd3JpdGUgW0B0YWlsY2FsbF0pIGsgfmJsaXQgfmxlbmd0aCB+b2ZmIH5sZW4gYnVmZmVyIHQgaW5cbiAgICBmbHVzaCBrIHRcblxubGV0IHdyaXRlID0ga3dyaXRlIGlkZW50aXR5XG5cbmxldCBrd3JpdGV2IGsgbCB0ID1cbiAgbGV0IHJlYyBnbyB0ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGsgdFxuICAgIHwgKGJsaXQsIGxlbmd0aCwgb2ZmLCBsZW4sIGJ1ZmZlcikgOjogciAtPlxuICAgICAgICBrd3JpdGUgKGZ1biB0IC0+IChnbyBbQHRhaWxjYWxsXSkgdCByKSB+YmxpdCB+bGVuZ3RoID9vZmYgP2xlbiBidWZmZXIgdFxuICBpblxuICBnbyB0IGxcblxubGV0IGJpZ2FycmF5X2JsaXRfZnJvbV9zdHJpbmcgc3JjIHNyY19vZmYgZHN0IGRzdF9vZmYgbGVuID1cbiAgQmlnc3RyaW5nYWYuYmxpdF9mcm9tX3N0cmluZyBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIH5sZW5cblxubGV0IGJpZ2FycmF5X2JsaXRfZnJvbV9ieXRlcyBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiBsZW4gPVxuICBCaWdzdHJpbmdhZi5ibGl0X2Zyb21fYnl0ZXMgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiB+bGVuXG5cbmxldCBiaWdhcnJheV9ibGl0IHNyYyBzcmNfb2ZmIGRzdCBkc3Rfb2ZmIGxlbiA9XG4gIEJpZ2FycmF5LkFycmF5MS4oYmxpdCAoc3ViIHNyYyBzcmNfb2ZmIGxlbikgKHN1YiBkc3QgZHN0X29mZiBsZW4pKVxuXG5sZXQgYmlnYXJyYXlfYmxpdF90b19ieXRlcyBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiBsZW4gPVxuICBCaWdzdHJpbmdhZi5ibGl0X3RvX2J5dGVzIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgfmxlblxuXG5sZXQga3dyaXRlX3N0cmluZyA9XG4gIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoIGluXG4gIGxldCBibGl0ID0gYmlnYXJyYXlfYmxpdF9mcm9tX3N0cmluZyBpblxuICBmdW4gayA/KG9mZiA9IDApID9sZW4gYSB0IC0+IGt3cml0ZSBrIH5ibGl0IH5sZW5ndGggfm9mZiA/bGVuIGEgdFxuXG5sZXQgd3JpdGVfc3RyaW5nID0ga3dyaXRlX3N0cmluZyBpZGVudGl0eVxuXG5sZXQga3dyaXRlX2J5dGVzID1cbiAgbGV0IGxlbmd0aCA9IEJ5dGVzLmxlbmd0aCBpblxuICBsZXQgYmxpdCA9IGJpZ2FycmF5X2JsaXRfZnJvbV9ieXRlcyBpblxuICBmdW4gayA/KG9mZiA9IDApID9sZW4gYSB0IC0+IGt3cml0ZSBrIH5ibGl0IH5sZW5ndGggfm9mZiA/bGVuIGEgdFxuXG5sZXQgd3JpdGVfYnl0ZXMgPSBrd3JpdGVfYnl0ZXMgaWRlbnRpdHlcblxubGV0IGt3cml0ZV9iaWdzdHJpbmcgPVxuICBsZXQgbGVuZ3RoID0gQmlnYXJyYXkuQXJyYXkxLmRpbSBpblxuICBsZXQgYmxpdCA9IGJpZ2FycmF5X2JsaXQgaW5cbiAgZnVuIGsgPyhvZmYgPSAwKSA/bGVuIGEgdCAtPiBrd3JpdGUgayB+YmxpdCB+bGVuZ3RoIH5vZmYgP2xlbiBhIHRcblxubGV0IHdyaXRlX2JpZ3N0cmluZyA9IGt3cml0ZV9iaWdzdHJpbmcgaWRlbnRpdHlcblxubGV0IGt3cml0ZV9jaGFyID1cbiAgbGV0IGxlbmd0aCBfID0gYXNzZXJ0IGZhbHNlIGluXG4gIGxldCBibGl0IHNyYyBzcmNfb2ZmIGRzdCBkc3Rfb2ZmIGxlbiA9XG4gICAgYXNzZXJ0IChzcmNfb2ZmID0gMCk7XG4gICAgYXNzZXJ0IChsZW4gPSAxKTtcbiAgICBCaWdzdHJpbmdhZi5zZXQgZHN0IGRzdF9vZmYgc3JjXG4gIGluXG4gIGZ1biBrIGEgdCAtPiBrd3JpdGUgayB+bGVuZ3RoIH5ibGl0IH5vZmY6MCB+bGVuOjEgYSB0XG5cbmxldCB3cml0ZV9jaGFyID0ga3dyaXRlX2NoYXIgaWRlbnRpdHlcblxubGV0IGt3cml0ZV91aW50OCA9XG4gIGxldCBsZW5ndGggXyA9IGFzc2VydCBmYWxzZSBpblxuICBsZXQgYmxpdCBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiBsZW4gPVxuICAgIGFzc2VydCAoc3JjX29mZiA9IDApO1xuICAgIGFzc2VydCAobGVuID0gMSk7XG4gICAgQmlnc3RyaW5nYWYuc2V0IGRzdCBkc3Rfb2ZmIChDaGFyLnVuc2FmZV9jaHIgc3JjKVxuICBpblxuICBmdW4gayBhIHQgLT4ga3dyaXRlIGsgfmxlbmd0aCB+YmxpdCB+b2ZmOjAgfmxlbjoxIGEgdFxuXG5sZXQgd3JpdGVfdWludDggPSBrd3JpdGVfdWludDggaWRlbnRpdHlcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB2YWwga3dyaXRlX3VpbnQxNiA6IChlbmNvZGVyIC0+ICd2KSAtPiBpbnQgLT4gZW5jb2RlciAtPiAndlxuICB2YWwgd3JpdGVfdWludDE2IDogaW50IC0+IGVuY29kZXIgLT4gZW5jb2RlclxuICB2YWwga3dyaXRlX3VpbnQzMiA6IChlbmNvZGVyIC0+ICd2KSAtPiBpbnQzMiAtPiBlbmNvZGVyIC0+ICd2XG4gIHZhbCB3cml0ZV91aW50MzIgOiBpbnQzMiAtPiBlbmNvZGVyIC0+IGVuY29kZXJcbiAgdmFsIGt3cml0ZV91aW50NjQgOiAoZW5jb2RlciAtPiAndikgLT4gaW50NjQgLT4gZW5jb2RlciAtPiAndlxuICB2YWwgd3JpdGVfdWludDY0IDogaW50NjQgLT4gZW5jb2RlciAtPiBlbmNvZGVyXG5lbmRcblxubW9kdWxlIHR5cGUgRU5ESUFOID0gc2lnXG4gIHR5cGUgdCA9IEJpZ3N0cmluZ2FmLnRcblxuICB2YWwgc2V0X2ludDE2IDogdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHNldF9pbnQzMiA6IHQgLT4gaW50IC0+IGludDMyIC0+IHVuaXRcbiAgdmFsIHNldF9pbnQ2NCA6IHQgLT4gaW50IC0+IGludDY0IC0+IHVuaXRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoWCA6IEVORElBTikgOiBTID0gc3RydWN0XG4gIGxldCBfbGVuZ3RoIF8gPSBhc3NlcnQgZmFsc2VcblxuICBsZXQga3dyaXRlX3VpbnQxNiA9XG4gICAgbGV0IGxlbmd0aCA9IF9sZW5ndGggaW5cbiAgICBsZXQgYmxpdCBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiBsZW4gPVxuICAgICAgYXNzZXJ0IChzcmNfb2ZmID0gMCk7XG4gICAgICBhc3NlcnQgKGxlbiA9IDIpO1xuICAgICAgWC5zZXRfaW50MTYgZHN0IGRzdF9vZmYgc3JjXG4gICAgaW5cbiAgICBmdW4gayBhIHQgLT4ga3dyaXRlIGsgfmxlbmd0aCB+YmxpdCB+b2ZmOjAgfmxlbjoyIGEgdFxuXG4gIGxldCB3cml0ZV91aW50MTYgPSBrd3JpdGVfdWludDE2IGlkZW50aXR5XG5cbiAgbGV0IGt3cml0ZV91aW50MzIgPVxuICAgIGxldCBsZW5ndGggPSBfbGVuZ3RoIGluXG4gICAgbGV0IGJsaXQgc3JjIHNyY19vZmYgZHN0IGRzdF9vZmYgbGVuID1cbiAgICAgIGFzc2VydCAoc3JjX29mZiA9IDApO1xuICAgICAgYXNzZXJ0IChsZW4gPSA0KTtcbiAgICAgIFguc2V0X2ludDMyIGRzdCBkc3Rfb2ZmIHNyY1xuICAgIGluXG4gICAgZnVuIGsgYSB0IC0+IGt3cml0ZSBrIH5sZW5ndGggfmJsaXQgfm9mZjowIH5sZW46NCBhIHRcblxuICBsZXQgd3JpdGVfdWludDMyID0ga3dyaXRlX3VpbnQzMiBpZGVudGl0eVxuXG4gIGxldCBrd3JpdGVfdWludDY0ID1cbiAgICBsZXQgbGVuZ3RoID0gX2xlbmd0aCBpblxuICAgIGxldCBibGl0IHNyYyBzcmNfb2ZmIGRzdCBkc3Rfb2ZmIGxlbiA9XG4gICAgICBhc3NlcnQgKHNyY19vZmYgPSAwKTtcbiAgICAgIGFzc2VydCAobGVuID0gOCk7XG4gICAgICBYLnNldF9pbnQ2NCBkc3QgZHN0X29mZiBzcmNcbiAgICBpblxuICAgIGZ1biBrIGEgdCAtPiBrd3JpdGUgayB+bGVuZ3RoIH5ibGl0IH5vZmY6MCB+bGVuOjggYSB0XG5cbiAgbGV0IHdyaXRlX3VpbnQ2NCA9IGt3cml0ZV91aW50NjQgaWRlbnRpdHlcbmVuZFxuXG5tb2R1bGUgTEUnID0gc3RydWN0XG4gIHR5cGUgdCA9IEJpZ3N0cmluZ2FmLnRcblxuICBsZXQgc2V0X2ludDE2ID0gQmlnc3RyaW5nYWYuc2V0X2ludDE2X2xlXG4gIGxldCBzZXRfaW50MzIgPSBCaWdzdHJpbmdhZi5zZXRfaW50MzJfbGVcbiAgbGV0IHNldF9pbnQ2NCA9IEJpZ3N0cmluZ2FmLnNldF9pbnQ2NF9sZVxuZW5kXG5cbm1vZHVsZSBCRScgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQmlnc3RyaW5nYWYudFxuXG4gIGxldCBzZXRfaW50MTYgPSBCaWdzdHJpbmdhZi5zZXRfaW50MTZfYmVcbiAgbGV0IHNldF9pbnQzMiA9IEJpZ3N0cmluZ2FmLnNldF9pbnQzMl9iZVxuICBsZXQgc2V0X2ludDY0ID0gQmlnc3RyaW5nYWYuc2V0X2ludDY0X2JlXG5lbmRcblxubW9kdWxlIExFID0gTWFrZSAoTEUnKVxubW9kdWxlIEJFID0gTWFrZSAoQkUnKVxuIiwiW0BAQHdhcm5pbmcgXCItMzJcIl0gKCogcHJldHR5LXByaW50ZXJzICopXG5cbnR5cGUgdmVjID0geyBvZmYgOiBpbnQ7IGxlbiA6IGludCB9XG50eXBlIGJveCA9IEJveCB8IFRCb3ggb2YgaW50IHwgQkJveFxuXG5sZXQgcHBfYm94IHBwZiA9IGZ1bmN0aW9uXG4gIHwgQm94IC0+IEZtdC5zdHJpbmcgcHBmIFwiYm94XCJcbiAgfCBUQm94IHRhYiAtPiBGbXQucGYgcHBmIFwiKFRCb3ggJWQpXCIgdGFiXG4gIHwgQkJveCAtPiBGbXQuc3RyaW5nIHBwZiBcImJib3hcIlxuXG50eXBlIHZhbHVlID1cbiAgfCBTdHJpbmcgb2YgdmVjICogc3RyaW5nXG4gIHwgQnl0ZXMgb2YgdmVjICogYnl0ZXNcbiAgfCBCaWdzdHJpbmcgb2YgdmVjICogQmlnc3RyaW5nYWYudFxuXG5sZXQgcHBfdmFsdWUgcHBmID0gZnVuY3Rpb25cbiAgfCBTdHJpbmcgKHZlYywgdikgLT4gRm10LnBmIHBwZiBcIiVTXCIgKFN0cmluZy5zdWIgdiB2ZWMub2ZmIHZlYy5sZW4pXG4gIHwgQnl0ZXMgKHZlYywgdikgLT4gRm10LnBmIHBwZiBcIiVTXCIgKEJ5dGVzLnN1Yl9zdHJpbmcgdiB2ZWMub2ZmIHZlYy5sZW4pXG4gIHwgQmlnc3RyaW5nIF8gLT4gRm10LnBmIHBwZiBcIiNiaWdzdHJpbmdcIlxuXG5sZXQgc3BsaXRfdmFsdWUgbGVuIHggPVxuICBhc3NlcnQgKGxlbiA+IDApO1xuXG4gIG1hdGNoIHggd2l0aFxuICB8IFN0cmluZyAodmVjLCB2KSAtPlxuICAgICAgbGV0IHYwID0gU3RyaW5nLnN1YiB2IDAgbGVuIGluXG4gICAgICBsZXQgdjEgPSBTdHJpbmcuc3ViIHYgbGVuICh2ZWMubGVuIC0gbGVuKSBpblxuICAgICAgKCBTdHJpbmcgKHsgb2ZmID0gMDsgbGVuIH0sIHYwKSxcbiAgICAgICAgU3RyaW5nICh7IG9mZiA9IDA7IGxlbiA9IHZlYy5sZW4gLSBsZW4gfSwgdjEpIClcbiAgfCBCeXRlcyAodmVjLCB2KSAtPlxuICAgICAgbGV0IHYwID0gQnl0ZXMuc3ViIHYgMCBsZW4gaW5cbiAgICAgIGxldCB2MSA9IEJ5dGVzLnN1YiB2IGxlbiAodmVjLmxlbiAtIGxlbikgaW5cbiAgICAgICggQnl0ZXMgKHsgb2ZmID0gMDsgbGVuIH0sIHYwKSxcbiAgICAgICAgQnl0ZXMgKHsgb2ZmID0gMDsgbGVuID0gdmVjLmxlbiAtIGxlbiB9LCB2MSkgKVxuICB8IEJpZ3N0cmluZyAodmVjLCB2KSAtPlxuICAgICAgKCBCaWdzdHJpbmcgKHsgb2ZmID0gdmVjLm9mZjsgbGVuIH0sIHYpLFxuICAgICAgICBCaWdzdHJpbmcgKHsgb2ZmID0gdmVjLm9mZiArIGxlbjsgbGVuID0gdmVjLmxlbiAtIGxlbiB9LCB2KSApXG5cbmxldCBsZW5ndGhfb2ZfdmFsdWUgPSBmdW5jdGlvblxuICB8IFN0cmluZyAodmVjLCBfKSB8IEJ5dGVzICh2ZWMsIF8pIHwgQmlnc3RyaW5nICh2ZWMsIF8pIC0+IHZlYy5sZW5cblxudHlwZSBhdG9tID1cbiAgfCBCcmVha2FibGUgb2YgdmFsdWVcbiAgfCBVbmJyZWFrYWJsZSBvZiB2YWx1ZVxuICB8IEJyZWFrIG9mIHsgbGVuIDogaW50OyBpbmRlbnQgOiBpbnQgfVxuICB8IE5ld19saW5lXG4gIHwgT3BlbiBvZiBib3hcbiAgfCBDbG9zZVxuXG5sZXQgcHBfYXRvbSBwcGYgPSBmdW5jdGlvblxuICB8IEJyZWFrYWJsZSB2IC0+IEZtdC5wZiBwcGYgXCI8YnJlYWthYmxlOiVhPlwiIHBwX3ZhbHVlIHZcbiAgfCBVbmJyZWFrYWJsZSB2IC0+IEZtdC5wZiBwcGYgXCI8dW5icmVha2FibGU6JWE+XCIgcHBfdmFsdWUgdlxuICB8IEJyZWFrIHsgbGVuOyBpbmRlbnQgfSAtPiBGbXQucGYgcHBmIFwiPGJyZWFrOmxlbj0gJWQsIGluZGVudD0gJWQ+XCIgbGVuIGluZGVudFxuICB8IE5ld19saW5lIC0+IEZtdC5wZiBwcGYgXCI8bmV3LWxpbmU+XCJcbiAgfCBPcGVuIGJveCAtPiBGbXQucGYgcHBmIFwiKGJveCAlYVwiIHBwX2JveCBib3hcbiAgfCBDbG9zZSAtPiBGbXQucGYgcHBmIFwiKVwiXG5cbmxldCBib3ggPSBCb3hcbmxldCB0Ym94IGluZGVudCA9IFRCb3ggaW5kZW50XG5sZXQgYmJveCA9IEJCb3hcbmxldCBvIGJveCA9IE9wZW4gYm94XG5sZXQgbmV3X2xpbmUgPSBOZXdfbGluZVxubGV0IGNsb3NlID0gQ2xvc2VcbmxldCBmd3MgPSBCcmVhayB7IGxlbiA9IDE7IGluZGVudCA9IDEgfVxubGV0IHNwYWNlcyBsZW4gPSBCcmVhayB7IGxlbjsgaW5kZW50ID0gMCB9XG5sZXQgYnJlYWsgfmxlbiB+aW5kZW50ID0gQnJlYWsgeyBsZW47IGluZGVudCB9XG5cbmxldCB2IH5icmVha2FibGUgPVxuICBtYXRjaCBicmVha2FibGUgd2l0aFxuICB8IHRydWUgLT4gZnVuIHggLT4gQnJlYWthYmxlIHhcbiAgfCBmYWxzZSAtPiBmdW4geCAtPiBVbmJyZWFrYWJsZSB4XG5cbmxldCBzdHJpbmcgPyhicmVha2FibGUgPSBmYWxzZSkgPyhvZmYgPSAwKSA/bGVuIHggPVxuICBsZXQgbGVuID0gbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHggLSBvZmYgaW5cbiAgbGV0IHZhbHVlID0gU3RyaW5nICh7IG9mZjsgbGVuIH0sIHgpIGluXG4gIHYgfmJyZWFrYWJsZSB2YWx1ZVxuXG5sZXQgYnl0ZXMgPyhicmVha2FibGUgPSBmYWxzZSkgPyhvZmYgPSAwKSA/bGVuIHggPVxuICBsZXQgbGVuID0gbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBCeXRlcy5sZW5ndGggeCAtIG9mZiBpblxuICBsZXQgdmFsdWUgPSBCeXRlcyAoeyBvZmY7IGxlbiB9LCB4KSBpblxuICB2IH5icmVha2FibGUgdmFsdWVcblxubGV0IGJpZ3N0cmluZyA/KGJyZWFrYWJsZSA9IGZhbHNlKSA/KG9mZiA9IDApID9sZW4geCA9XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoIFNvbWUgbGVuIC0+IGxlbiB8IE5vbmUgLT4gQmlnc3RyaW5nYWYubGVuZ3RoIHggLSBvZmZcbiAgaW5cbiAgbGV0IHZhbHVlID0gQmlnc3RyaW5nICh7IG9mZjsgbGVuIH0sIHgpIGluXG4gIHYgfmJyZWFrYWJsZSB2YWx1ZVxuXG50eXBlIHRva2VuID1cbiAgfCBUVmFsdWUgb2YgdmFsdWVcbiAgfCBUQnJlYWsgb2YgaW50XG4gIHwgVEJveCBvZiBbIGBSb290IHwgYEJveCB8IGBJbmRlbnQgb2YgaW50IF1cbiAgfCBUQ2xvc2VcblxubGV0IGxlbmd0aF9vZl90b2tlbiA9IGZ1bmN0aW9uXG4gIHwgVFZhbHVlIHZhbHVlIC0+IGxlbmd0aF9vZl92YWx1ZSB2YWx1ZVxuICB8IFRCcmVhayBsZW4gLT4gbGVuXG4gIHwgVEJveCBfIC0+IDBcbiAgfCBUQ2xvc2UgLT4gMFxuXG5tb2R1bGUgT3B0aW9uID0gc3RydWN0XG4gIGxldCBiaW5kIHggZiA9IG1hdGNoIHggd2l0aCBTb21lIHggLT4gZiB4IHwgTm9uZSAtPiBOb25lIGxldCAoID4+PSApID0gYmluZFxuZW5kXG5cbm1vZHVsZSBTdGFjayA6IHNpZ1xuICB0eXBlICsnYSB0XG5cbiAgdmFsIGVtcHR5IDogXyB0XG4gIHZhbCBwdXNoIDogJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gIHZhbCBzd2FwX2V4biA6ICgnYSAtPiAnYSkgLT4gJ2EgdCAtPiAnYSB0XG4gIHZhbCBwb3AgOiAnYSB0IC0+ICgnYSAqICdhIHQpIG9wdGlvblxuICB2YWwgZm9sZCA6ICgnYSAtPiAnYiAtPiAnYSkgLT4gJ2EgLT4gJ2IgdCAtPiAnYVxuICB2YWwgdGFpbF9leG4gOiAnYSB0IC0+ICdhIHRcbiAgdmFsIG1hcCA6ICgnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gIHZhbCBwcCA6ICdhIEZtdC50IC0+ICdhIHQgRm10LnRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgbGV0IGVtcHR5ID0gW11cbiAgbGV0IHB1c2ggeCB0ID0geCA6OiB0XG5cbiAgZXhjZXB0aW9uIEVtcHR5XG5cbiAgbGV0IHN3YXBfZXhuIGYgPSBmdW5jdGlvbiBbXSAtPiByYWlzZSBFbXB0eSB8IHggOjogciAtPiBmIHggOjogclxuICBsZXQgcG9wID0gZnVuY3Rpb24gW10gLT4gTm9uZSB8IHggOjogciAtPiBTb21lICh4LCByKVxuICBsZXQgZm9sZCA9IExpc3QuZm9sZF9sZWZ0XG4gIGxldCB0YWlsX2V4biA9IGZ1bmN0aW9uIF8gOjogciAtPiByIHwgW10gLT4gcmFpc2UgRW1wdHlcbiAgbGV0IG1hcCBmIGwgPSBMaXN0Lm1hcCBmIGxcbiAgbGV0IHBwID0gRm10LkR1bXAubGlzdFxuZW5kXG5cbm1vZHVsZSBRdWV1ZSA9IEtlLkZrZVxuXG50eXBlIHQgPSB7XG4gIGJveGVzIDogWyBgUm9vdCB8IGBCb3ggfCBgSW5kZW50IG9mIGludCBdIFN0YWNrLnQ7XG4gIGJyZWFrcyA6IFsgYEluZGVudCBvZiBpbnQgXSBsaXN0IFN0YWNrLnQ7XG4gIGlubmVyIDogaW50IGxpc3QgU3RhY2sudDtcbiAgaW5kZW50IDogaW50O1xuICBtYXJnaW4gOiBpbnQ7XG4gIG5ld19saW5lIDogc3RyaW5nO1xuICBxdWV1ZSA6IHRva2VuIFF1ZXVlLnQ7XG4gIGVuY29kZXIgOiBFbmNsb3N1cmUuZW5jb2Rlcjtcbn1cblxubGV0IHBwX2JveCBwcGYgPSBmdW5jdGlvblxuICB8IGBSb290IC0+IEZtdC5zdHJpbmcgcHBmIFwiYFJvb3RcIlxuICB8IGBCb3ggLT4gRm10LnN0cmluZyBwcGYgXCJgQm94XCJcbiAgfCBgSW5kZW50IG4gLT4gRm10LnBmIHBwZiBcIihgSW5kZW50ICVkKVwiIG5cblxubGV0IHBwX2JyZWFrIHBwZiAoYEluZGVudCBuKSA9IEZtdC5wZiBwcGYgXCIoYEluZGVudCAlZClcIiBuXG5cbmxldCBwcF90b2tlbiBwcGYgPSBmdW5jdGlvblxuICB8IFRWYWx1ZSAoU3RyaW5nICh7IG9mZjsgbGVuIH0sIHgpKSAtPiBGbXQucGYgcHBmIFwiJVNcIiAoU3RyaW5nLnN1YiB4IG9mZiBsZW4pXG4gIHwgVFZhbHVlIChCeXRlcyAoeyBvZmY7IGxlbiB9LCB4KSkgLT5cbiAgICAgIEZtdC5wZiBwcGYgXCIlU1wiIChCeXRlcy5zdWJfc3RyaW5nIHggb2ZmIGxlbilcbiAgfCBUVmFsdWUgKEJpZ3N0cmluZyAoeyBvZmY7IGxlbiB9LCB4KSkgLT5cbiAgICAgIEZtdC5wZiBwcGYgXCIlU1wiIChCaWdzdHJpbmdhZi5zdWJzdHJpbmcgeCB+b2ZmIH5sZW4pXG4gIHwgVEJyZWFrIGxlbiAtPiBGbXQucGYgcHBmIFwiPCVTPlwiIChTdHJpbmcubWFrZSBsZW4gJyAnKVxuICB8IFRCb3ggYEJveCAtPiBGbXQucGYgcHBmIFwiW1wiXG4gIHwgVEJveCAoYEluZGVudCBuKSAtPiBGbXQucGYgcHBmIFwiWzwlZD5cIiBuXG4gIHwgVEJveCBgUm9vdCAtPiBGbXQucGYgcHBmIFwiWzxyb290PlwiXG4gIHwgVENsb3NlIC0+IEZtdC5wZiBwcGYgXCJdXCJcblxubGV0IHBwIHBwZiB0ID1cbiAgRm10LnBmIHBwZlxuICAgIFwieyBAWzxob3Y+Ym94ZXM9IEBbPGhvdj4lYUBdO0AgYnJlYWtzPSBAWzxob3Y+JWFAXTtAIGlubmVyPSBAWzxob3Y+JWFAXTtAIFxcXG4gICAgIGluZGVudD0gJWQ7QCBtYXJnaW49ICVkO0AgbmV3X2xpbmU9ICVTO0AgcXVldWU9IEBbPGhvdj4lYUBdO0AgZW5jb2Rlcj0gXFxcbiAgICAgQFs8aG92PiVhQF07QF0gfVwiXG4gICAgKFN0YWNrLnBwIHBwX2JveCkgdC5ib3hlc1xuICAgIChTdGFjay5wcCAoRm10LkR1bXAubGlzdCBwcF9icmVhaykpXG4gICAgdC5icmVha3NcbiAgICAoU3RhY2sucHAgRm10LihEdW1wLmxpc3QgaW50KSlcbiAgICB0LmlubmVyIHQuaW5kZW50IHQubWFyZ2luIHQubmV3X2xpbmUgKFF1ZXVlLnBwIHBwX3Rva2VuKSB0LnF1ZXVlXG4gICAgRW5jbG9zdXJlLnBwIHQuZW5jb2RlclxuXG5sZXQgKCA8Lj4gKSBmIGcgeCA9IGYgKGcgeClcbmxldCBmbGlwIGYgYSBiID0gZiBiIGFcblxubGV0IG1lcmdlX2JyZWFrcyB0b2tlbiAocXVldWUsIHgpID1cbiAgbWF0Y2ggKHRva2VuLCB4KSB3aXRoXG4gIHwgQnJlYWsgeyBsZW4gPSBsZW5feDsgXyB9LCBUQnJlYWsgbGVuIC0+IFNvbWUgKHF1ZXVlLCBsZW5feCArIGxlbilcbiAgfCBfLCBfIC0+IE5vbmVcblxubGV0IGN1cnJlbnRfbGVuZ3RoX29mX2xpbmUgdCA9XG4gIHQuaW5kZW50ICsgUXVldWUuZm9sZCAoZmxpcCAoKCArICkgPC4+IGxlbmd0aF9vZl90b2tlbikpIDAgdC5xdWV1ZVxuXG5sZXQgZW1pdF9saW5lIGsgdCA9XG4gIGxldCByZWMgZ28gcXVldWUgZW5jb2RlciA9XG4gICAgbWF0Y2ggUXVldWUucG9wIHF1ZXVlIHdpdGhcbiAgICB8IFNvbWUgKFRWYWx1ZSAoU3RyaW5nICh7IG9mZjsgbGVuIH0sIHYpKSwgcXVldWUpIC0+XG4gICAgICAgIEVuY2xvc3VyZS5rc2NoZWR1bGVfc3RyaW5nIChnbyBxdWV1ZSkgZW5jb2RlciB+b2ZmIH5sZW4gdlxuICAgIHwgU29tZSAoVFZhbHVlIChCeXRlcyAoeyBvZmY7IGxlbiB9LCB2KSksIHF1ZXVlKSAtPlxuICAgICAgICBFbmNsb3N1cmUua3NjaGVkdWxlX2J5dGVzIChnbyBxdWV1ZSkgZW5jb2RlciB+b2ZmIH5sZW4gdlxuICAgIHwgU29tZSAoVFZhbHVlIChCaWdzdHJpbmcgKHsgb2ZmOyBsZW4gfSwgdikpLCBxdWV1ZSkgLT5cbiAgICAgICAgRW5jbG9zdXJlLmtzY2hlZHVsZV9iaWdzdHJpbmcgKGdvIHF1ZXVlKSBlbmNvZGVyIH5vZmYgfmxlbiB2XG4gICAgfCBTb21lIChUQnJlYWsgbGVuLCBxdWV1ZSkgLT5cbiAgICAgICAgRW5jbG9zdXJlLmtzY2hlZHVsZV9zdHJpbmcgKGdvIHF1ZXVlKSBlbmNvZGVyIH5sZW4gKFN0cmluZy5tYWtlIGxlbiAnICcpXG4gICAgfCBTb21lIChUQm94IF8sIHF1ZXVlKSB8IFNvbWUgKFRDbG9zZSwgcXVldWUpIC0+IGdvIHF1ZXVlIGVuY29kZXJcbiAgICB8IE5vbmUgLT5cbiAgICAgICAgbGV0IGsgZW5jb2RlciA9IGsgeyB0IHdpdGggZW5jb2RlcjsgcXVldWUgPSBRdWV1ZS5lbXB0eSB9IGluXG4gICAgICAgIGxldCBrIGVuY29kZXIgPSBFbmNsb3N1cmUuZmx1c2ggayBlbmNvZGVyIGluXG4gICAgICAgIEVuY2xvc3VyZS5rc2NoZWR1bGVfc3RyaW5nIGsgZW5jb2RlciB0Lm5ld19saW5lXG4gIGluXG4gIEVuY2xvc3VyZS5rc2NoZWR1bGVfc3RyaW5nIChnbyB0LnF1ZXVlKSB0LmVuY29kZXIgKFN0cmluZy5tYWtlIHQuaW5kZW50ICcgJylcblxubGV0IG1lcmdlX2luZGVudHMgayB0ID1cbiAgbGV0IGluZGVudF9ieV9ib3ggPVxuICAgIFN0YWNrLmZvbGRcbiAgICAgIChmdW4gYSAtPiBmdW5jdGlvbiBgQm94IHwgYFJvb3QgLT4gYSB8IGBJbmRlbnQgbiAtPiBhICsgbilcbiAgICAgIDAgdC5ib3hlc1xuICBpblxuICBsZXQgaW5kZW50X2J5X2JyZWFrID1cbiAgICBsZXQgayBhIGwgPVxuICAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAgKGZ1biBhIC0+IGZ1bmN0aW9uIGBJbmRlbnQgbiAtPiAobWF4IDogaW50IC0+IGludCAtPiBpbnQpIGEgbilcbiAgICAgICAgYSBsXG4gICAgaW5cbiAgICBTdGFjay5mb2xkIGsgMCB0LmJyZWFrc1xuICBpblxuICBrXG4gICAge1xuICAgICAgdCB3aXRoXG4gICAgICBpbmRlbnQgPSBpbmRlbnRfYnlfYm94ICsgaW5kZW50X2J5X2JyZWFrO1xuICAgICAgaW5uZXIgPSBTdGFjay5tYXAgKGZ1biBfIC0+IFtdKSB0LmJveGVzO1xuICAgICAgYnJlYWtzID0gU3RhY2subWFwIChmdW4gXyAtPiBbXSkgdC5ib3hlcztcbiAgICB9XG5cbmxldCBpc19pbl9ib3ggdCA9XG4gIGxldCBleGNlcHRpb24gSW4gaW5cbiAgdHJ5XG4gICAgUXVldWUucmV2X2l0ZXIgKGZ1bmN0aW9uIFRCb3ggXyAtPiByYWlzZSBJbiB8IF8gLT4gKCkpIHQucXVldWU7XG4gICAgZmFsc2VcbiAgd2l0aCBJbiAtPiB0cnVlXG5cbmxldCB3aXRob3V0X2xhc3RfYm94IHEgPVxuICBsZXQgcmVjIGdvIHEgPVxuICAgIG1hdGNoIFF1ZXVlLnRhaWwgcSB3aXRoXG4gICAgfCBTb21lIChxLCBUQm94IF8pIC0+IHFcbiAgICB8IFNvbWUgKHEsIF8pIC0+IGdvIHFcbiAgICB8IE5vbmUgLT4gUXVldWUuZW1wdHlcbiAgaW5cbiAgZ28gcVxuXG5sZXQgdW5yb2xsX2xhc3RfYm94X2FuZF9lbWl0IGsgdmFsdWUgdCA9XG4gIGxldCByZWMgdW5yb2xsIGFjYyBxID1cbiAgICBsZXQgcSwgeCA9IFF1ZXVlLnRhaWxfZXhuIHEgaW5cbiAgICBtYXRjaCB4IHdpdGggVEJveCBfIC0+IChMaXN0LnJldiAoeCA6OiBhY2MpLCBxKSB8IHggLT4gdW5yb2xsICh4IDo6IGFjYykgcVxuICBpblxuICBsZXQgYm94LCBxID0gdW5yb2xsIFsgVFZhbHVlIHZhbHVlIF0gdC5xdWV1ZSBpblxuICAoKiBhc3NlcnQgKFF1ZXVlLmlzX2VtcHR5IHEgPSBmYWxzZSk7ICopXG4gIGxldCBrIHQgPVxuICAgIGxldCByZWMgcm9sbCBhY2MgcSA9XG4gICAgICBtYXRjaCBhY2Mgd2l0aCBbXSAtPiBxIHwgeCA6OiByIC0+IHJvbGwgciAoUXVldWUucHVzaCBxIHgpXG4gICAgaW5cbiAgICBsZXQgcSA9IHJvbGwgKExpc3QucmV2IGJveCkgdC5xdWV1ZSBpblxuICAgIGsgeyB0IHdpdGggcXVldWUgPSBxIH1cbiAgaW5cbiAgZW1pdF9saW5lIChtZXJnZV9pbmRlbnRzIGspIHsgdCB3aXRoIHF1ZXVlID0gcSB9XG5cbmxldCByZWMga3B1c2hfYnJlYWthYmxlX3ZhbHVlIH5jdXJyZW50X2xlbmd0aF9vZl9saW5lIGsgdmFsdWUgdCA9XG4gIGlmIGN1cnJlbnRfbGVuZ3RoX29mX2xpbmUgPj0gdC5tYXJnaW4gdGhlblxuICAgIGVtaXRfbGluZSAobWVyZ2VfaW5kZW50cyAoa3B1c2ggayAoQnJlYWthYmxlIHZhbHVlKSkpIHRcbiAgZWxzZSBpZiBjdXJyZW50X2xlbmd0aF9vZl9saW5lICsgbGVuZ3RoX29mX3Rva2VuIChUVmFsdWUgdmFsdWUpID4gdC5tYXJnaW5cbiAgdGhlblxuICAgIGlmIGlzX2luX2JveCB0ICYmIG5vdCAoUXVldWUuaXNfZW1wdHkgKHdpdGhvdXRfbGFzdF9ib3ggdC5xdWV1ZSkpIHRoZW5cbiAgICAgIHVucm9sbF9sYXN0X2JveF9hbmRfZW1pdCBrIHZhbHVlIHRcbiAgICBlbHNlXG4gICAgICBsZXQgbGVuID0gdC5tYXJnaW4gLSBjdXJyZW50X2xlbmd0aF9vZl9saW5lIGluXG4gICAgICBsZXQgdmFsdWUwLCB2YWx1ZTEgPSBzcGxpdF92YWx1ZSBsZW4gdmFsdWUgaW5cbiAgICAgIGxldCB0b2tlbjAgPSBUVmFsdWUgdmFsdWUwIGluXG4gICAgICBsZXQgdG9rZW4xID0gdiB+YnJlYWthYmxlOnRydWUgdmFsdWUxIGluXG4gICAgICBlbWl0X2xpbmVcbiAgICAgICAgKG1lcmdlX2luZGVudHMgKGtwdXNoIGsgdG9rZW4xKSlcbiAgICAgICAgeyB0IHdpdGggcXVldWUgPSBRdWV1ZS5wdXNoIHQucXVldWUgdG9rZW4wIH1cbiAgZWxzZVxuICAgIGtcbiAgICAgIHtcbiAgICAgICAgdCB3aXRoXG4gICAgICAgIHF1ZXVlID0gUXVldWUucHVzaCB0LnF1ZXVlIChUVmFsdWUgdmFsdWUpO1xuICAgICAgICBpbm5lciA9XG4gICAgICAgICAgU3RhY2suc3dhcF9leG4gKGZ1biBsZW52IC0+IGxlbmd0aF9vZl92YWx1ZSB2YWx1ZSA6OiBsZW52KSB0LmlubmVyO1xuICAgICAgfVxuXG5hbmQga3B1c2hfdW5icmVha2FibGVfdmFsdWUgfmN1cnJlbnRfbGVuZ3RoX29mX2xpbmUgayB2YWx1ZSB0ID1cbiAgaWZcbiAgICBjdXJyZW50X2xlbmd0aF9vZl9saW5lICsgbGVuZ3RoX29mX3Rva2VuIChUVmFsdWUgdmFsdWUpID4gdC5tYXJnaW5cbiAgICAmJiBub3QgKFF1ZXVlLmlzX2VtcHR5IHQucXVldWUpXG4gIHRoZW5cbiAgICBpZiBpc19pbl9ib3ggdCAmJiBub3QgKFF1ZXVlLmlzX2VtcHR5ICh3aXRob3V0X2xhc3RfYm94IHQucXVldWUpKSB0aGVuXG4gICAgICB1bnJvbGxfbGFzdF9ib3hfYW5kX2VtaXQgayB2YWx1ZSB0XG4gICAgZWxzZVxuICAgICAgbWF0Y2ggUXVldWUudGFpbCB0LnF1ZXVlIHdpdGhcbiAgICAgIHwgU29tZSAocXVldWUsIFRCcmVhayBfKSAtPlxuICAgICAgICAgIGVtaXRfbGluZVxuICAgICAgICAgICAgKG1lcmdlX2luZGVudHMgKGtwdXNoIGsgKFVuYnJlYWthYmxlIHZhbHVlKSkpXG4gICAgICAgICAgICB7IHQgd2l0aCBxdWV1ZSB9XG4gICAgICB8IFNvbWUgXyAtPiBlbWl0X2xpbmUgKG1lcmdlX2luZGVudHMgKGtwdXNoIGsgKFVuYnJlYWthYmxlIHZhbHVlKSkpIHRcbiAgICAgIHwgTm9uZSAtPiBlbWl0X2xpbmUgKG1lcmdlX2luZGVudHMgKGtwdXNoIGsgKFVuYnJlYWthYmxlIHZhbHVlKSkpIHRcbiAgZWxzZVxuICAgIGtcbiAgICAgIHtcbiAgICAgICAgdCB3aXRoXG4gICAgICAgIHF1ZXVlID0gUXVldWUucHVzaCB0LnF1ZXVlIChUVmFsdWUgdmFsdWUpO1xuICAgICAgICBpbm5lciA9XG4gICAgICAgICAgU3RhY2suc3dhcF9leG4gKGZ1biBsZW52IC0+IGxlbmd0aF9vZl92YWx1ZSB2YWx1ZSA6OiBsZW52KSB0LmlubmVyO1xuICAgICAgfVxuXG5hbmQga3B1c2ggayB2YWx1ZSB0ID1cbiAgbGV0IGN1cnJlbnRfbGVuZ3RoX29mX2xpbmUgPSBjdXJyZW50X2xlbmd0aF9vZl9saW5lIHQgaW5cblxuICBsZXQgYXBwZW5kIHN0YWNrIGxlbiA9XG4gICAgbWF0Y2ggU3RhY2sucG9wIHN0YWNrIHdpdGhcbiAgICB8IFNvbWUgKGxlbnYsIHN0YWNrKSAtPiBTdGFjay5wdXNoIChsZW4gOjogbGVudikgc3RhY2tcbiAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG5cbiAgbWF0Y2ggdmFsdWUgd2l0aFxuICB8IE5ld19saW5lIC0+IGVtaXRfbGluZSAobWVyZ2VfaW5kZW50cyBrKSB0XG4gIHwgT3BlbiBCb3ggLT5cbiAgICAgIGtcbiAgICAgICAge1xuICAgICAgICAgIHQgd2l0aFxuICAgICAgICAgIGJveGVzID0gU3RhY2sucHVzaCBgQm94IHQuYm94ZXM7XG4gICAgICAgICAgaW5uZXIgPSBTdGFjay5wdXNoIFtdIHQuaW5uZXI7XG4gICAgICAgICAgYnJlYWtzID0gU3RhY2sucHVzaCBbXSB0LmJyZWFrcztcbiAgICAgICAgICBxdWV1ZSA9IFF1ZXVlLnB1c2ggdC5xdWV1ZSAoVEJveCBgQm94KTtcbiAgICAgICAgfVxuICB8IE9wZW4gKFRCb3ggaW5kZW50KSAtPlxuICAgICAga1xuICAgICAgICB7XG4gICAgICAgICAgdCB3aXRoXG4gICAgICAgICAgYm94ZXMgPSBTdGFjay5wdXNoIChgSW5kZW50IGluZGVudCkgdC5ib3hlcztcbiAgICAgICAgICBpbm5lciA9IFN0YWNrLnB1c2ggW10gdC5pbm5lcjtcbiAgICAgICAgICBicmVha3MgPSBTdGFjay5wdXNoIFtdIHQuYnJlYWtzO1xuICAgICAgICAgIHF1ZXVlID0gUXVldWUucHVzaCB0LnF1ZXVlIChUQm94IChgSW5kZW50IGluZGVudCkpO1xuICAgICAgICB9XG4gIHwgT3BlbiBCQm94IC0+XG4gICAgICBsZXQgaW5kZW50ID1cbiAgICAgICAgU3RhY2suZm9sZCAoZmxpcCAoKCArICkgPC4+IExpc3QuZm9sZF9sZWZ0ICggKyApIDApKSAwIHQuaW5uZXJcbiAgICAgIGluXG4gICAgICBrXG4gICAgICAgIHtcbiAgICAgICAgICB0IHdpdGhcbiAgICAgICAgICBib3hlcyA9IFN0YWNrLnB1c2ggKGBJbmRlbnQgaW5kZW50KSB0LmJveGVzO1xuICAgICAgICAgIGlubmVyID0gU3RhY2sucHVzaCBbXSB0LmlubmVyO1xuICAgICAgICAgIGJyZWFrcyA9IFN0YWNrLnB1c2ggW10gdC5icmVha3M7XG4gICAgICAgICAgcXVldWUgPSBRdWV1ZS5wdXNoIHQucXVldWUgKFRCb3ggKGBJbmRlbnQgaW5kZW50KSk7XG4gICAgICAgIH1cbiAgfCBDbG9zZSAtPlxuICAgICAgKCogWFhYKGRpbm9zYXVyZSk6IGNoZWNrIFtgUm9vdF0gYm94LiAqKVxuICAgICAga1xuICAgICAgICB7XG4gICAgICAgICAgdCB3aXRoXG4gICAgICAgICAgYm94ZXMgPSBTdGFjay50YWlsX2V4biB0LmJveGVzO1xuICAgICAgICAgIGlubmVyID0gU3RhY2sudGFpbF9leG4gdC5pbm5lcjtcbiAgICAgICAgICBicmVha3MgPSBTdGFjay50YWlsX2V4biB0LmJyZWFrcztcbiAgICAgICAgICBxdWV1ZSA9IFF1ZXVlLnB1c2ggdC5xdWV1ZSBUQ2xvc2U7XG4gICAgICAgIH1cbiAgfCBCcmVha2FibGUgdmFsdWUgLT4ga3B1c2hfYnJlYWthYmxlX3ZhbHVlIH5jdXJyZW50X2xlbmd0aF9vZl9saW5lIGsgdmFsdWUgdFxuICB8IFVuYnJlYWthYmxlIHZhbHVlIC0+XG4gICAgICBrcHVzaF91bmJyZWFrYWJsZV92YWx1ZSB+Y3VycmVudF9sZW5ndGhfb2ZfbGluZSBrIHZhbHVlIHRcbiAgfCBCcmVhayB7IGxlbjsgaW5kZW50IH0gYXMgYnJlYWsgLT4gKFxuICAgICAgbWF0Y2hcbiAgICAgICAgbGV0IG9wZW4gT3B0aW9uIGluXG4gICAgICAgIFF1ZXVlLnRhaWwgdC5xdWV1ZSA+Pj0gbWVyZ2VfYnJlYWtzIGJyZWFrXG4gICAgICB3aXRoXG4gICAgICB8IFNvbWUgKHF1ZXVlLCBsZW4pIC0+XG4gICAgICAgICAgaWYgY3VycmVudF9sZW5ndGhfb2ZfbGluZSArIGxlbmd0aF9vZl90b2tlbiAoVEJyZWFrIGxlbikgPj0gdC5tYXJnaW5cbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICBlbWl0X2xpbmUgKG1lcmdlX2luZGVudHMgaylcbiAgICAgICAgICAgICAgeyB0IHdpdGggcXVldWU7IGJyZWFrcyA9IGFwcGVuZCB0LmJyZWFrcyAoYEluZGVudCBpbmRlbnQpIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBrXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0IHdpdGhcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IFF1ZXVlLnB1c2ggcXVldWUgKFRCcmVhayBsZW4pO1xuICAgICAgICAgICAgICAgIGlubmVyID0gYXBwZW5kIHQuaW5uZXIgbGVuO1xuICAgICAgICAgICAgICAgIGJyZWFrcyA9IGFwcGVuZCB0LmJyZWFrcyAoYEluZGVudCBpbmRlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBpZiBjdXJyZW50X2xlbmd0aF9vZl9saW5lICsgbGVuZ3RoX29mX3Rva2VuIChUQnJlYWsgbGVuKSA+IHQubWFyZ2luXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgZW1pdF9saW5lIChtZXJnZV9pbmRlbnRzIGspXG4gICAgICAgICAgICAgIHsgdCB3aXRoIGJyZWFrcyA9IGFwcGVuZCB0LmJyZWFrcyAoYEluZGVudCBpbmRlbnQpIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBrXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0IHdpdGhcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IFF1ZXVlLnB1c2ggdC5xdWV1ZSAoVEJyZWFrIGxlbik7XG4gICAgICAgICAgICAgICAgaW5uZXIgPSBhcHBlbmQgdC5pbm5lciBsZW47XG4gICAgICAgICAgICAgICAgYnJlYWtzID0gYXBwZW5kIHQuYnJlYWtzIChgSW5kZW50IGluZGVudCk7XG4gICAgICAgICAgICAgIH0pXG5cbmxldCBrZmx1c2ggayB0ID1cbiAgbGV0IHJlYyBnbyBxdWV1ZSBlbmNvZGVyID1cbiAgICBtYXRjaCBRdWV1ZS5wb3AgcXVldWUgd2l0aFxuICAgIHwgU29tZSAoVFZhbHVlIChTdHJpbmcgKHsgb2ZmOyBsZW4gfSwgdikpLCBxdWV1ZSkgLT5cbiAgICAgICAgRW5jbG9zdXJlLmtzY2hlZHVsZV9zdHJpbmcgKGdvIHF1ZXVlKSBlbmNvZGVyIH5vZmYgfmxlbiB2XG4gICAgfCBTb21lIChUVmFsdWUgKEJ5dGVzICh7IG9mZjsgbGVuIH0sIHYpKSwgcXVldWUpIC0+XG4gICAgICAgIEVuY2xvc3VyZS5rc2NoZWR1bGVfYnl0ZXMgKGdvIHF1ZXVlKSBlbmNvZGVyIH5vZmYgfmxlbiB2XG4gICAgfCBTb21lIChUVmFsdWUgKEJpZ3N0cmluZyAoeyBvZmY7IGxlbiB9LCB2KSksIHF1ZXVlKSAtPlxuICAgICAgICBFbmNsb3N1cmUua3NjaGVkdWxlX2JpZ3N0cmluZyAoZ28gcXVldWUpIGVuY29kZXIgfm9mZiB+bGVuIHZcbiAgICB8IFNvbWUgKFRCcmVhayBsZW4sIHF1ZXVlKSAtPlxuICAgICAgICBFbmNsb3N1cmUua3NjaGVkdWxlX3N0cmluZyAoZ28gcXVldWUpIGVuY29kZXIgfmxlbiAoU3RyaW5nLm1ha2UgbGVuICcgJylcbiAgICB8IFNvbWUgKFRCb3ggXywgcXVldWUpIHwgU29tZSAoVENsb3NlLCBxdWV1ZSkgLT4gZ28gcXVldWUgZW5jb2RlclxuICAgIHwgTm9uZSAtPlxuICAgICAgICBFbmNsb3N1cmUuZmx1c2hcbiAgICAgICAgICAoZnVuIGVuY29kZXIgLT4gayB7IHQgd2l0aCBlbmNvZGVyOyBxdWV1ZSA9IFF1ZXVlLmVtcHR5IH0pXG4gICAgICAgICAgZW5jb2RlclxuICBpblxuICBnbyB0LnF1ZXVlIHQuZW5jb2RlclxuXG5leHRlcm5hbCBpZGVudGl0eSA6ICdhIC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgcHVzaCA9IGtwdXNoIGlkZW50aXR5XG5sZXQgZmx1c2ggPSBrZmx1c2ggaWRlbnRpdHlcbmxldCBpc19lbXB0eSB0ID0gUXVldWUuaXNfZW1wdHkgdC5xdWV1ZSAmJiBFbmNsb3N1cmUuaXNfZW1wdHkgdC5lbmNvZGVyXG5cbmxldCBjcmVhdGUgPyhtYXJnaW4gPSA5OTgpID8obmV3X2xpbmUgPSBcIlxcclxcblwiKSB+ZW1pdHRlciBsZW4gPVxuICBsZXQgZW5jb2RlciA9IEVuY2xvc3VyZS5jcmVhdGUgfmVtaXR0ZXIgbGVuIGluXG4gIHtcbiAgICBlbmNvZGVyO1xuICAgIHF1ZXVlID0gUXVldWUuZW1wdHk7XG4gICAgYm94ZXMgPSBTdGFjay5wdXNoIGBSb290IFN0YWNrLmVtcHR5O1xuICAgIGJyZWFrcyA9IFN0YWNrLnB1c2ggW10gU3RhY2suZW1wdHk7XG4gICAgaW5uZXIgPSBTdGFjay5wdXNoIFtdIFN0YWNrLmVtcHR5O1xuICAgIGluZGVudCA9IDA7XG4gICAgbWFyZ2luO1xuICAgIG5ld19saW5lO1xuICB9XG4iLCJ0eXBlIHBwZiA9IFByZXR0eS50XG50eXBlICdhIHQgPSBwcGYgLT4gJ2EgLT4gcHBmXG5cbnR5cGUgKCd0eSwgJ3YpIG9yZGVyID1cbiAgfCBDb25zdCA6ICdhIHQgKiAnYSAtPiAoJ3YsICd2KSBvcmRlclxuICB8IEF0b20gOiAnYSB0IC0+ICgnYSAtPiAndiwgJ3YpIG9yZGVyXG4gIHwgUGFyYW0gOiAoJ2EgdCAtPiAnYSAtPiAndiwgJ3YpIG9yZGVyXG4gIHwgTmV3X2xpbmUgOiAoJ3YsICd2KSBvcmRlclxuICB8IE9wZW4gOiBQcmV0dHkuYm94IC0+ICgndiwgJ3YpIG9yZGVyXG4gIHwgQ2xvc2UgOiAoJ3YsICd2KSBvcmRlclxuICB8IEJyZWFrIDogeyBpbmRlbnQgOiBpbnQ7IGxlbiA6IGludCB9IC0+ICgndiwgJ3YpIG9yZGVyXG5cbmxldCBrZXZhbF9vcmRlciA6IHR5cGUgdHkgdi4gKHBwZiAtPiB2KSAtPiBwcGYgLT4gKHR5LCB2KSBvcmRlciAtPiB0eSA9XG4gZnVuIGsgdCAtPiBmdW5jdGlvblxuICB8IENvbnN0IChlbmNvZGVyLCB2KSAtPiBrIChlbmNvZGVyIHQgdilcbiAgfCBBdG9tIGVuY29kZXIgLT4gZnVuIHYgLT4gayAoZW5jb2RlciB0IHYpXG4gIHwgUGFyYW0gLT4gZnVuIGVuY29kZXIgdiAtPiBrIChlbmNvZGVyIHQgdilcbiAgfCBOZXdfbGluZSAtPiBQcmV0dHkua3B1c2ggayBQcmV0dHkubmV3X2xpbmUgdFxuICB8IE9wZW4gYm94IC0+IFByZXR0eS5rcHVzaCBrIChQcmV0dHkubyBib3gpIHRcbiAgfCBDbG9zZSAtPiBQcmV0dHkua3B1c2ggayBQcmV0dHkuY2xvc2UgdFxuICB8IEJyZWFrIHsgaW5kZW50OyBsZW4gfSAtPiBQcmV0dHkua3B1c2ggayAoUHJldHR5LmJyZWFrIH5sZW4gfmluZGVudCkgdFxuXG5sZXQgY29uc3QgZW5jb2RlciB2ID0gQ29uc3QgKGVuY29kZXIsIHYpXG5sZXQgYXRvbSBlbmNvZGVyID0gQXRvbSBlbmNvZGVyXG5sZXQgYSA9IFBhcmFtXG5sZXQgKCAhISApID0gYXRvbVxubGV0ICggJCApID0gY29uc3RcbmxldCBuZXdfbGluZSA9IE5ld19saW5lXG5sZXQgdGJveCBpbmRlbnQgPSBPcGVuIChQcmV0dHkudGJveCBpbmRlbnQpXG5sZXQgYmJveCA9IE9wZW4gUHJldHR5LmJib3hcbmxldCBib3ggPSBPcGVuIFByZXR0eS5ib3hcbmxldCBjbG9zZSA9IENsb3NlXG5sZXQgYnJlYWsgfmluZGVudCB+bGVuID0gQnJlYWsgeyBpbmRlbnQ7IGxlbiB9XG5sZXQgZndzID0gQnJlYWsgeyBpbmRlbnQgPSAxOyBsZW4gPSAxIH1cbmxldCBzcGFjZXMgbGVuID0gQnJlYWsgeyBpbmRlbnQgPSAwOyBsZW4gfVxubGV0IGN1dCA9IEJyZWFrIHsgaW5kZW50ID0gMDsgbGVuID0gMCB9XG5sZXQgdXNpbmcgOiAoJ2IgLT4gJ2EpIC0+ICdhIHQgLT4gJ2IgdCA9IGZ1biBmIGVuY29kZXIgdCB2IC0+IGVuY29kZXIgdCAoZiB2KVxuXG5sZXQgbGlzdCB+c2VwOihzZXAsIGUpIGVuY29kZXIgPVxuICBsZXQgcmVjIGdvIHQgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gdFxuICAgIHwgWyB4IF0gLT4gZW5jb2RlciB0IHhcbiAgICB8IHggOjogciAtPlxuICAgICAgICBsZXQgdCA9IGVuY29kZXIgdCB4IGluXG4gICAgICAgIGxldCB0ID0gc2VwIHQgZSBpblxuICAgICAgICBnbyB0IHJcbiAgaW5cbiAgZ29cblxubGV0IG9wdGlvbiBlbmNvZGVyIHQgPSBmdW5jdGlvbiBTb21lIHggLT4gZW5jb2RlciB0IHggfCBOb25lIC0+IHRcblxubGV0IGNoYXIgOiBjaGFyIHQgPVxuIGZ1biB0IHggLT5cbiAgKCogWFhYKGRpbm9zYXVyZSk6IHdlIHNob3VsZCBvcHRpbWl6ZSBpdCEgKilcbiAgbGV0IGF0b20gPSBQcmV0dHkuc3RyaW5nIH5icmVha2FibGU6ZmFsc2UgKFN0cmluZy5tYWtlIDEgeCkgaW5cbiAgUHJldHR5LnB1c2ggYXRvbSB0XG5cbmxldCBzdHJpbmcgOiBzdHJpbmcgdCA9XG4gZnVuIHQgeCAtPlxuICBsZXQgYXRvbSA9IFByZXR0eS5zdHJpbmcgfmJyZWFrYWJsZTpmYWxzZSB4IGluXG4gIFByZXR0eS5wdXNoIGF0b20gdFxuXG5sZXQgYnl0ZXMgOiBCeXRlcy50IHQgPVxuIGZ1biB0IHggLT5cbiAgbGV0IGF0b20gPSBQcmV0dHkuYnl0ZXMgfmJyZWFrYWJsZTpmYWxzZSB4IGluXG4gIFByZXR0eS5wdXNoIGF0b20gdFxuXG5sZXQgYmlnc3RyaW5nIDogQmlnc3RyaW5nYWYudCB0ID1cbiBmdW4gdCB4IC0+XG4gIGxldCBhdG9tID0gUHJldHR5LmJpZ3N0cmluZyB+YnJlYWthYmxlOmZhbHNlIHggaW5cbiAgUHJldHR5LnB1c2ggYXRvbSB0XG5cbmxldCBicmVha2FibGUgOiBzdHJpbmcgdCA9XG4gZnVuIHQgeCAtPlxuICBsZXQgYXRvbSA9IFByZXR0eS5zdHJpbmcgfmJyZWFrYWJsZTp0cnVlIHggaW5cbiAgUHJldHR5LnB1c2ggYXRvbSB0XG5cbnR5cGUgKCd0eSwgJ3YpIGZtdCA9XG4gIHwgW10gOiAoJ3YsICd2KSBmbXRcbiAgfCAoIDo6ICkgOiAoJ3gsICd2KSBvcmRlciAqICgndiwgJ3IpIGZtdCAtPiAoJ3gsICdyKSBmbXRcblxubGV0IHJlYyBjb25jYXQgOiB0eXBlIGEgYiBjLiAoYSwgYikgZm10IC0+IChiLCBjKSBmbXQgLT4gKGEsIGMpIGZtdCA9XG4gZnVuIGwxIGwyIC0+IG1hdGNoIChsMSwgbDIpIHdpdGggW10sIGwgLT4gbCB8IGggOjogdCwgbCAtPiBoIDo6IGNvbmNhdCB0IGxcblxubGV0IHJlYyBrZXZhbCA6IHR5cGUgdHkgdi4gKHBwZiAtPiB2KSAtPiBwcGYgLT4gKHR5LCB2KSBmbXQgLT4gdHkgPVxuIGZ1biBrIHQgLT4gZnVuY3Rpb25cbiAgfCBbXSAtPiBrIHRcbiAgfCB4IDo6IHIgLT5cbiAgICAgIGxldCBrIHQgPSBrZXZhbCBrIHQgciBpblxuICAgICAga2V2YWxfb3JkZXIgayB0IHhcblxuZXh0ZXJuYWwgaWRlbnRpdHkgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcblxubGV0IGV2YWwgOiB0eXBlIHR5LiBwcGYgLT4gKHR5LCBwcGYpIGZtdCAtPiB0eSA9XG4gZnVuIHQgZm10IC0+IGtldmFsIGlkZW50aXR5IHQgZm10XG4iLCJpbmNsdWRlIEZhbmN5XG5cbmxldCBpb19idWZmZXJfc2l6ZSA9IDY1NTM2XG4oKiBYWFgoZGlub3NhdXJlKTogaWYgW21hcmdpbl0gaXMgc2V0IHRvIFtpb19idWZmZXJfc2l6ZV0sIHdlIHNob3VsZCBuZXZlciBhZGRcbiAgIGFuIFtGV1NdIHRva2VuLiAqKVxuXG5sZXQgY3JlYXRlID0gUHJldHR5LmNyZWF0ZVxubGV0IGlzX2VtcHR5ID0gUHJldHR5LmlzX2VtcHR5XG5sZXQgZmx1c2ggPSBQcmV0dHkuZmx1c2hcbmxldCBrZmx1c2ggPSBQcmV0dHkua2ZsdXNoXG5cbmxldCB0b19zdHJpbmcgPyhtYXJnaW4gPSA3OCkgPyhuZXdfbGluZSA9IFwiXFxyXFxuXCIpIGdlbiB2YWx1ZSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDB4MTAwIGluXG5cbiAgbGV0IGVtaXR0ZXIgPVxuICAgIGxldCB3cml0ZSBhIHggPVxuICAgICAgbGV0IG9wZW4gRW5jbG9zdXJlLklPVmVjIGluXG4gICAgICBsZXQgb3BlbiBFbmNsb3N1cmUuQnVmZmVyIGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgeyBidWZmZXIgPSBTdHJpbmcgeDsgb2ZmOyBsZW4gfSAtPlxuICAgICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiB4IG9mZiBsZW47XG4gICAgICAgICAgYSArIGxlblxuICAgICAgfCB7IGJ1ZmZlciA9IEJ5dGVzIHg7IG9mZjsgbGVuIH0gLT5cbiAgICAgICAgICBCdWZmZXIuYWRkX3N1YmJ5dGVzIGJ1ZiB4IG9mZiBsZW47XG4gICAgICAgICAgYSArIGxlblxuICAgICAgfCB7IGJ1ZmZlciA9IEJpZ3N0cmluZyB4OyBvZmY7IGxlbiB9IC0+XG4gICAgICAgICAgbGV0IHggPSBCaWdzdHJpbmdhZi5zdWJzdHJpbmcgeCB+b2ZmIH5sZW4gaW5cbiAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgeDtcbiAgICAgICAgICBhICsgbGVuXG4gICAgaW5cbiAgICBMaXN0LmZvbGRfbGVmdCB3cml0ZSAwXG4gIGluXG4gIGxldCBlbmNvZGVyID0gUHJldHR5LmNyZWF0ZSB+ZW1pdHRlciB+bWFyZ2luIH5uZXdfbGluZSAweDEwMCBpblxuICBsZXQga2VuZCBlbmNvZGVyID1cbiAgICBpZiBQcmV0dHkuaXNfZW1wdHkgZW5jb2RlciB0aGVuICgpXG4gICAgZWxzZSBGbXQuZmFpbHdpdGggXCJMZWF2ZSBhIG5vbi1lbXB0eSBlbmNvZGVyXCJcbiAgaW5cbiAgbGV0IGVuY29kZXIgPSBldmFsIGVuY29kZXIgRmFuY3kuWyAhIWdlbiBdIHZhbHVlIGluXG4gIGxldCAoKSA9IFByZXR0eS5rZmx1c2gga2VuZCBlbmNvZGVyIGluXG4gIEJ1ZmZlci5jb250ZW50cyBidWZcblxubGV0IHRvX3N0cmVhbSA/KG1hcmdpbiA9IDc4KSA/KG5ld19saW5lID0gXCJcXHJcXG5cIikgZ2VuIHZhbHVlID1cbiAgbGV0IHF1ZXVlID0gUXVldWUuY3JlYXRlICgpIGluXG4gIGxldCBsaW5lID0gQnVmZmVyLmNyZWF0ZSA0MDk2IGluXG4gIGxldCBlbWl0dGVyIGlvdmVjcyA9XG4gICAgbGV0IHdyaXRlIGEgeCA9XG4gICAgICBsZXQgb3BlbiBFbmNsb3N1cmUuSU9WZWMgaW5cbiAgICAgIGxldCBvcGVuIEVuY2xvc3VyZS5CdWZmZXIgaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCB7IGJ1ZmZlciA9IFN0cmluZyB4OyBvZmY7IGxlbiB9IC0+XG4gICAgICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgbGluZSB4IG9mZiBsZW47XG4gICAgICAgICAgYSArIGxlblxuICAgICAgfCB7IGJ1ZmZlciA9IEJ5dGVzIHg7IG9mZjsgbGVuIH0gLT5cbiAgICAgICAgICBCdWZmZXIuYWRkX3N1YmJ5dGVzIGxpbmUgeCBvZmYgbGVuO1xuICAgICAgICAgIGEgKyBsZW5cbiAgICAgIHwgeyBidWZmZXIgPSBCaWdzdHJpbmcgeDsgb2ZmOyBsZW4gfSAtPlxuICAgICAgICAgIGxldCB4ID0gQmlnc3RyaW5nYWYuc3Vic3RyaW5nIHggfm9mZiB+bGVuIGluXG4gICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgbGluZSB4O1xuICAgICAgICAgIGEgKyBsZW5cbiAgICBpblxuICAgIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCB3cml0ZSAwIGlvdmVjcyBpblxuICAgIGxldCByZXMgPSBCdWZmZXIuY29udGVudHMgbGluZSBpblxuICAgIGlmIFN0cmluZy5sZW5ndGggcmVzID4gMCB0aGVuIFF1ZXVlLmFkZCByZXMgcXVldWU7XG4gICAgQnVmZmVyLmNsZWFyIGxpbmU7XG4gICAgbGVuXG4gIGluXG4gIGxldCBjb25zdW1lciAoKSA9XG4gICAgbWF0Y2ggUXVldWUucG9wIHF1ZXVlIHdpdGggeCAtPiBTb21lIHggfCBleGNlcHRpb24gUXVldWUuRW1wdHkgLT4gTm9uZVxuICBpblxuICBsZXQgZW5jb2RlciA9IFByZXR0eS5jcmVhdGUgfmVtaXR0ZXIgfm1hcmdpbiB+bmV3X2xpbmUgNDA5NiBpblxuICBsZXQga2VuZCBlbmNvZGVyID1cbiAgICBpZiBQcmV0dHkuaXNfZW1wdHkgZW5jb2RlciB0aGVuICgpXG4gICAgZWxzZSBGbXQuZmFpbHdpdGggXCJMZWF2ZSB3aXRoIGEgbm9uLWVtcHR5IGVuY29kZXJcIlxuICBpblxuICBsZXQgKCkgPSBrZXZhbCAoUHJldHR5LmtmbHVzaCBrZW5kKSBlbmNvZGVyIEZhbmN5LlsgISFnZW4gXSB2YWx1ZSBpblxuICBjb25zdW1lclxuXG5tb2R1bGUgSU9WZWMgPSBFbmNsb3N1cmUuSU9WZWNcbm1vZHVsZSBCdWZmZXIgPSBFbmNsb3N1cmUuQnVmZmVyXG4iXX0=
