// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Weak_hashtbl
//# unitInfo: Requires: Base__Error, Base__Exn, Base__Hashable, Base__Hashtbl, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdlib, Stdlib__Gc, Thread_safe_queue, Weak_pointer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Weak_hashtbl$0 = "Weak_hashtbl",
    cst = "_",
    cst_weak_hashtbl$0 = "weak_hashtbl",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Weak_pointer = global_data.Weak_pointer,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Error = global_data.Base__Error,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Stdlib = global_data.Stdlib,
    Base_Hashable = global_data.Base__Hashable,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Weak_hashtbl$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_weak_hashtbl$0);
   caml_call1(Ppx_expect_runtime[1][1], "weak_hashtbl/src/weak_hashtbl.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_weak_hashtbl$0, "weak_hashtbl.ml");
   var
    _e_ = [0, cst],
    _d_ = [0, cst],
    cst_weak_hashtbl_src_weak_hash = "weak_hashtbl/src/weak_hashtbl.ml:74:71",
    cst_Weak_hashtbl_add_exn_of_ke = "Weak_hashtbl.add_exn of key in use",
    _a_ = [0, "thread_safe_run_when_unused_data"],
    _b_ = [0, "keys_with_unused_data"],
    _c_ = [0, "entry_by_key"],
    cst_weak_hashtbl = cst_weak_hashtbl$0,
    cst_Weak_hashtbl = cst_Weak_hashtbl$0;
   function sexp_of_t(of_a_001, of_b_002, param){
    var
     keys_with_unused_data_006 = param[2],
     entry_by_key_004 = param[1],
     bnds_003 = 0;
    function _t_(_v_){return 0;}
    var
     arg_009 = caml_call1(Sexplib0_Sexp_conv[24], _t_),
     bnds_003$0 = [0, [1, [0, _a_, [0, arg_009, 0]]], bnds_003],
     arg_007 =
       caml_call2(Thread_safe_queue[1], of_a_001, keys_with_unused_data_006),
     bnds_003$1 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_003$0],
     _u_ = caml_call1(Weak_pointer[1], of_b_002),
     arg_005 = caml_call3(Base_Hashtbl[3], of_a_001, _u_, entry_by_key_004),
     bnds_003$2 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_003$1];
    return [1, bnds_003$2];
   }
   function create(growth_allowed, size, hashable){
    function _p_(_s_){return 0;}
    var
     _q_ = caml_call1(Thread_safe_queue[3], 0),
     _r_ = caml_call1(Base_Hashable[4], hashable);
    return [0,
            caml_call3(Base_Hashtbl[4], growth_allowed, size, _r_),
            _q_,
            _p_];
   }
   var Using_hashable = [0, create];
   function create$0(growth_allowed, size, m){
    var _o_ = caml_call1(Base_Hashable[3], m);
    return caml_call3(Using_hashable[1], growth_allowed, size, _o_);
   }
   function set_run_when_unused_data(t, thread_safe_f){t[3] = thread_safe_f; return 0;
   }
   function remove(t, key){return caml_call2(Base_Hashtbl[32], t[1], key);}
   function clear(t){return caml_call1(Base_Hashtbl[16], t[1]);}
   function reclaim_space_for_keys_with_un(t){
    for(;;){
     if(0 >= caml_call1(Thread_safe_queue[4], t[2])) return 0;
     var
      key = caml_call1(Thread_safe_queue[6], t[2]),
      match = caml_call2(Base_Hashtbl[56], t[1], key);
     if(match){
      var entry = match[1];
      if(caml_call1(Weak_pointer[6], entry)) remove(t, key);
     }
    }
   }
   function get_entry(t, key){
    function _n_(param){return caml_call1(Weak_pointer[2], 0);}
    return caml_call3(Base_Hashtbl[54], t[1], key, _n_);
   }
   function mem(t, key){
    var match = caml_call2(Base_Hashtbl[56], t[1], key);
    if(! match) return 0;
    var entry = match[1];
    return caml_call1(Weak_pointer[5], entry);
   }
   function key_is_using_space(t, key){
    return caml_call2(Base_Hashtbl[31], t[1], key);
   }
   function set_data(t, key, entry, data){
    caml_call2(Weak_pointer[7], entry, data);
    function cleanup(param){
     function _m_(param){
      caml_call2(Thread_safe_queue[5], t[2], key);
      return caml_call1(t[3], 0);
     }
     return caml_call1(Base_Exn[15], _m_);
    }
    try{var _k_ = caml_call2(Stdlib_Gc[4], cleanup, data); return _k_;}
    catch(_l_){
     var _j_ = caml_wrap_exception(_l_);
     if(_j_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_j_, 0);
    }
   }
   function replace(t, key, data){
    return set_data(t, key, get_entry(t, key), data);
   }
   function add_exn(x_010, key, data){
    var entry = get_entry(x_010, key);
    if(caml_call1(Weak_pointer[5], entry)){
     var
      _f_ =
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_weak_hashtbl_src_weak_hash),
         0],
      _g_ = function(param){return _d_;},
      _h_ = [0, sexp_of_t(function(param){return _e_;}, _g_, x_010), _f_],
      _i_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Weak_hashtbl_add_exn_of_ke),
          _h_]];
     caml_call1(Base_Error[32], _i_);
    }
    return set_data(x_010, key, entry, data);
   }
   function find(t, key){
    var match = caml_call2(Base_Hashtbl[56], t[1], key);
    if(! match) return 0;
    var entry = match[1];
    return caml_call1(Weak_pointer[4], entry);
   }
   function find_or_add(t, key, default$0){
    var entry = get_entry(t, key), match = caml_call1(Weak_pointer[4], entry);
    if(match){var v = match[1]; return v;}
    var data = caml_call1(default$0, 0);
    set_data(t, key, entry, data);
    return data;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_weak_hashtbl);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Weak_hashtbl);
   var
    Weak_hashtbl =
      [0,
       sexp_of_t,
       create$0,
       Using_hashable,
       mem,
       find,
       find_or_add,
       remove,
       clear,
       add_exn,
       replace,
       key_is_using_space,
       reclaim_space_for_keys_with_un,
       set_run_when_unused_data];
   runtime.caml_register_global(27, Weak_hashtbl, cst_Weak_hashtbl$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ3ZWFrX2hhc2h0YmwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInNleHBfb2ZfdCIsIm9mX2FfMDAxIiwib2ZfYl8wMDIiLCJrZXlzX3dpdGhfdW51c2VkX2RhdGFfMDA2IiwiZW50cnlfYnlfa2V5XzAwNCIsImJuZHNfMDAzIiwiYXJnXzAwOSIsImJuZHNfMDAzJDAiLCJhcmdfMDA3IiwiYm5kc18wMDMkMSIsImFyZ18wMDUiLCJibmRzXzAwMyQyIiwiY3JlYXRlIiwiZ3Jvd3RoX2FsbG93ZWQiLCJzaXplIiwiaGFzaGFibGUiLCJjcmVhdGUkMCIsIm0iLCJzZXRfcnVuX3doZW5fdW51c2VkX2RhdGEiLCJ0IiwidGhyZWFkX3NhZmVfZiIsInJlbW92ZSIsImtleSIsImNsZWFyIiwicmVjbGFpbV9zcGFjZV9mb3Jfa2V5c193aXRoX3VuIiwiZW50cnkiLCJnZXRfZW50cnkiLCJtZW0iLCJrZXlfaXNfdXNpbmdfc3BhY2UiLCJzZXRfZGF0YSIsImRhdGEiLCJjbGVhbnVwIiwicmVwbGFjZSIsImFkZF9leG4iLCJ4XzAxMCIsImZpbmQiLCJmaW5kX29yX2FkZCIsImRlZmF1bHQkMCIsInYiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlX2tlcm5lbC93ZWFrX2hhc2h0Ymwvd2Vha19oYXNodGJsLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FFQSxTQUFBQSxVQUFNQyxVQUFJQztJQUFWO0tBRUlDO0tBREFDO0tBREpDO3NCO0lBR1k7S0FBQUM7S0FIWkMsa0NBR1lELGVBSFpEO0tBRUlHO09BQUEsaUNBRkVQLFVBRUZFO0tBRkpNLGtDQUVJRCxlQUZKRDt1Q0FBVUw7S0FDTlEsVUFBQSw0QkFERVQsZUFDRkc7S0FESk8sa0NBQ0lELGVBREpEO0lBQUEsV0FBQUU7R0FLb0I7WUFHZEMsT0FBUUMsZ0JBQWdCQyxNQUFLQztJQUMvQixrQjtJQUMwQjtLQUFBLE1BQUE7S0FENEIsTUFBQSw2QkFEdkJBO0lBQy9CO1lBQWlCLDRCQURQRixnQkFBZ0JDOzs7R0FJekI7R0FMbUIseUJBQ2xCRjtZQVFGSSxTQUFRSCxnQkFBZ0JDLE1BQUtHO0lBQ2EsVUFBQSw2QkFEYkE7SUFDYSxPQUFBLDhCQURsQ0osZ0JBQWdCQztHQUNxQztZQUc3REkseUJBQXlCQyxHQUFHQyxlQUFIRCxPQUFHQztHQUNxQjtZQUdqREMsT0FBT0YsR0FBRUcsS0FBTSxPQUFBLDZCQUFSSCxNQUFFRyxLQUF1QztZQUNoREMsTUFBTUosR0FBSSxvQ0FBSkEsTUFBZ0M7WUFLdENLLCtCQUF3Q0w7SUFDMUM7S0FBTSxRQUFBLGlDQURvQ0E7S0FFOUI7TUFBTkcsTUFBTSxpQ0FGOEJIO01BR2xDLFFBQUEsNkJBSGtDQSxNQUVwQ0c7O1VBR0dHO01BQVksR0FBQSw0QkFBWkEsUUFYUEosT0FNd0NGLEdBRXBDRzs7O0dBSUY7WUFHRkksVUFBVVAsR0FBRUc7SUFDZCxvQkFBMkQsT0FBQSwrQkFBc0I7SUFBakMsT0FBQSw2QkFEcENILE1BQUVHO0dBQ29FO1lBR2hGSyxJQUFJUixHQUFFRztJQUNGLFlBQUEsNkJBREFILE1BQUVHO2dCQUVFO1FBQ0hHO0lBQVMsT0FBQSw0QkFBVEE7R0FBbUM7WUFHeENHLG1CQUFtQlQsR0FBRUc7SUFBTSxPQUFBLDZCQUFSSCxNQUFFRztHQUFvQztZQUV6RE8sU0FBU1YsR0FBRUcsS0FBSUcsT0FBT0s7SUFDeEIsNEJBRGlCTCxPQUFPSzthQUVwQkM7O01BRUEsaUNBSk9aLE1BQUVHO01BSVQsT0FBQSxXQUpPSDtLQUs4QjtLQUZWLE9BQUE7SUFFVztJQUUxQyxJQUFJLFVBQUEseUJBTEFZLFNBRm9CRCxPQU9wQjs7OzhCQUdvQjs7O0dBQUU7WUFHeEJFLFFBQVFiLEdBQUdHLEtBQUtRO0lBQU8sT0FidkJELFNBYVFWLEdBQUdHLEtBekJYSSxVQXlCUVAsR0FBR0csTUFBS1E7R0FBNEM7WUFFNURHLFFBQVFDLE9BQUdaLEtBQUtRO0lBQ04sSUFBUkwsUUE1QkZDLFVBMkJRUSxPQUFHWjtJQUVWLEdBQUEsNEJBRENHOzs7Ozs7NEI7Z0JBbkVOekIsMEIsbUJBa0VZa0M7Ozs7OztLQUlSOztJQUFBLE9BbkJBTCxTQWVRSyxPQUFHWixLQUNURyxPQURjSztHQU1PO1lBR3ZCSyxLQUFLaEIsR0FBRUc7SUFDSCxZQUFBLDZCQURDSCxNQUFFRztnQkFFQztRQUNIRztJQUFTLE9BQUEsNEJBQVRBO0dBQStCO1lBR3BDVyxZQUFZakIsR0FBRUcsS0FBS2U7SUFDckIsSUFBSVosUUEzQ0ZDLFVBMENZUCxHQUFFRyxNQUVWLFFBQUEsNEJBREZHO2tCQUVHYSxjQUFLLE9BQUxBO0lBRU0sSUFBUFIsT0FBTyxXQUxRTztJQTlCbkJSLFNBOEJZVixHQUFFRyxLQUNaRyxPQUlFSztJQUNKLE9BRElBO0dBRUE7Ozs7Ozs7O09BeEZSOUI7T0FnQklnQjs7T0EyQkFXO09BZ0NBUTtPQU1BQztPQXpEQWY7T0FDQUU7T0F5Q0FVO09BRkFEO09BZkFKO09BbkJBSjtPQVZBTjs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBCYXNlXG5cbnR5cGUgKCdhLCAnYikgdCA9XG4gIHsgZW50cnlfYnlfa2V5IDogKCdhLCAnYiBXZWFrX3BvaW50ZXIudCkgSGFzaHRibC50XG4gIDsga2V5c193aXRoX3VudXNlZF9kYXRhIDogJ2EgVGhyZWFkX3NhZmVfcXVldWUudFxuICA7IG11dGFibGUgdGhyZWFkX3NhZmVfcnVuX3doZW5fdW51c2VkX2RhdGEgOiB1bml0IC0+IHVuaXRcbiAgfVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubW9kdWxlIFVzaW5nX2hhc2hhYmxlID0gc3RydWN0XG4gIGxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIGhhc2hhYmxlID1cbiAgICB7IGVudHJ5X2J5X2tleSA9IEhhc2h0YmwuY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoQmFzZS5IYXNoYWJsZS50b19rZXkgaGFzaGFibGUpXG4gICAgOyBrZXlzX3dpdGhfdW51c2VkX2RhdGEgPSBUaHJlYWRfc2FmZV9xdWV1ZS5jcmVhdGUgKClcbiAgICA7IHRocmVhZF9zYWZlX3J1bl93aGVuX3VudXNlZF9kYXRhID0gaWdub3JlXG4gICAgfVxuICA7O1xuZW5kXG5cbmxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gPVxuICBVc2luZ19oYXNoYWJsZS5jcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIChIYXNoYWJsZS5vZl9rZXkgbSlcbjs7XG5cbmxldCBzZXRfcnVuX3doZW5fdW51c2VkX2RhdGEgdCB+dGhyZWFkX3NhZmVfZiA9XG4gIHQudGhyZWFkX3NhZmVfcnVuX3doZW5fdW51c2VkX2RhdGEgPC0gdGhyZWFkX3NhZmVfZlxuOztcblxubGV0IHJlbW92ZSB0IGtleSA9IEhhc2h0YmwucmVtb3ZlIHQuZW50cnlfYnlfa2V5IGtleVxubGV0IGNsZWFyIHQgPSBIYXNodGJsLmNsZWFyIHQuZW50cnlfYnlfa2V5XG5cbigqIEluIG9yZGVyIGZvciBhIGNhbGwgdG8gW3JlY2xhaW1fc3BhY2VfZm9yX2tleXNfd2l0aF91bnVzZWRfZGF0YV0gdG8gcmVjbGFpbSBhIGtleSB0aGF0XG4gICB3YXMgcHJldmlvdXNseSBmaW5hbGl6ZWQsIHRoZSB3ZWFrIHBvaW50ZXIgbXVzdCBoYXZlIGJlZW4gY2xlYXJlZC4gIFRoaXMgcmVsaWVzIG9uIHRoZVxuICAgZmFjdCB0aGF0IHRoZSBPQ2FtbCBnYXJiYWdlIGNvbGxlY3RvciBjbGVhcnMgd2Vha3MgYW5kIHRoZW4gcnVucyBmaW5hbGl6ZXJzLiAqKVxubGV0IHJlY2xhaW1fc3BhY2VfZm9yX2tleXNfd2l0aF91bnVzZWRfZGF0YSB0ID1cbiAgd2hpbGUgVGhyZWFkX3NhZmVfcXVldWUubGVuZ3RoIHQua2V5c193aXRoX3VudXNlZF9kYXRhID4gMCBkb1xuICAgIGxldCBrZXkgPSBUaHJlYWRfc2FmZV9xdWV1ZS5kZXF1ZXVlX2V4biB0LmtleXNfd2l0aF91bnVzZWRfZGF0YSBpblxuICAgIG1hdGNoIEhhc2h0YmwuZmluZCB0LmVudHJ5X2J5X2tleSBrZXkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBlbnRyeSAtPiBpZiBXZWFrX3BvaW50ZXIuaXNfbm9uZSBlbnRyeSB0aGVuIHJlbW92ZSB0IGtleVxuICBkb25lXG47O1xuXG5sZXQgZ2V0X2VudHJ5IHQga2V5ID1cbiAgSGFzaHRibC5maW5kX29yX2FkZCB0LmVudHJ5X2J5X2tleSBrZXkgfmRlZmF1bHQ6KGZ1biAoKSAtPiBXZWFrX3BvaW50ZXIuY3JlYXRlICgpKVxuOztcblxubGV0IG1lbSB0IGtleSA9XG4gIG1hdGNoIEhhc2h0YmwuZmluZCB0LmVudHJ5X2J5X2tleSBrZXkgd2l0aFxuICB8IE5vbmUgLT4gZmFsc2VcbiAgfCBTb21lIGVudHJ5IC0+IFdlYWtfcG9pbnRlci5pc19zb21lIGVudHJ5XG47O1xuXG5sZXQga2V5X2lzX3VzaW5nX3NwYWNlIHQga2V5ID0gSGFzaHRibC5tZW0gdC5lbnRyeV9ieV9rZXkga2V5XG5cbmxldCBzZXRfZGF0YSB0IGtleSBlbnRyeSAoZGF0YSA6IF8gSGVhcF9ibG9jay50KSA9XG4gIFdlYWtfcG9pbnRlci5zZXQgZW50cnkgZGF0YTtcbiAgbGV0IGNsZWFudXAgKCkgPVxuICAgIEV4bi5oYW5kbGVfdW5jYXVnaHRfYW5kX2V4aXQgKGZ1biAoKSAtPlxuICAgICAgVGhyZWFkX3NhZmVfcXVldWUuZW5xdWV1ZSB0LmtleXNfd2l0aF91bnVzZWRfZGF0YSBrZXk7XG4gICAgICB0LnRocmVhZF9zYWZlX3J1bl93aGVuX3VudXNlZF9kYXRhICgpKVxuICBpblxuICB0cnkgU3RkbGliLkdjLmZpbmFsaXNlX2xhc3QgY2xlYW51cCBkYXRhIHdpdGhcbiAgKCogSW4gdGhpcyBjYXNlLCBbeF0gaXMga25vd24gdG8gYmUgc3RhdGljIGRhdGEsIHdoaWNoIHdpbGxcbiAgICAgbmV2ZXIgYmUgY29sbGVjdGVkIGJ5IHRoZSBHQyBhbnl3YXksIHNvIGl0J3Mgc2FmZSB0byBkcm9wICopXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+ICgpXG47O1xuXG5sZXQgcmVwbGFjZSB0IH5rZXkgfmRhdGEgPSBzZXRfZGF0YSB0IGtleSAoZ2V0X2VudHJ5IHQga2V5KSBkYXRhXG5cbmxldCBhZGRfZXhuIHQgfmtleSB+ZGF0YSA9XG4gIGxldCBlbnRyeSA9IGdldF9lbnRyeSB0IGtleSBpblxuICBpZiBXZWFrX3BvaW50ZXIuaXNfc29tZSBlbnRyeVxuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlIFwiV2Vha19oYXNodGJsLmFkZF9leG4gb2Yga2V5IGluIHVzZVwiIH5fOih0IDogKF8sIF8pIHQpIFslaGVyZV1dO1xuICBzZXRfZGF0YSB0IGtleSBlbnRyeSBkYXRhXG47O1xuXG5sZXQgZmluZCB0IGtleSA9XG4gIG1hdGNoIEhhc2h0YmwuZmluZCB0LmVudHJ5X2J5X2tleSBrZXkgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgZW50cnkgLT4gV2Vha19wb2ludGVyLmdldCBlbnRyeVxuOztcblxubGV0IGZpbmRfb3JfYWRkIHQga2V5IH5kZWZhdWx0ID1cbiAgbGV0IGVudHJ5ID0gZ2V0X2VudHJ5IHQga2V5IGluXG4gIG1hdGNoIFdlYWtfcG9pbnRlci5nZXQgZW50cnkgd2l0aFxuICB8IFNvbWUgdiAtPiB2XG4gIHwgTm9uZSAtPlxuICAgIGxldCBkYXRhID0gZGVmYXVsdCAoKSBpblxuICAgIHNldF9kYXRhIHQga2V5IGVudHJ5IGRhdGE7XG4gICAgZGF0YVxuOztcbiJdfQ==
