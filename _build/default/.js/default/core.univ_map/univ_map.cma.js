// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Univ_map__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Univ_map = [0],
    Univ_map$0 = [0, Univ_map];
   runtime.caml_register_global(0, Univ_map$0, "Univ_map__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Univ_map__Univ_map_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Univ_map_Univ_map_intf = "Univ_map__Univ_map_intf",
    cst_univ_map = "univ_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Univ_map_Univ_map_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_univ_map);
   caml_call1(Ppx_expect_runtime[1][1], "univ_map/src/univ_map_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_univ_map, "univ_map_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_univ_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Univ_map_Univ_map_intf);
   var Univ_map_Univ_map_intf = [0];
   runtime.caml_register_global
    (11, Univ_map_Univ_map_intf, cst_Univ_map_Univ_map_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Univ_map
//# unitInfo: Requires: Base, Base__Invariant, Base__List, Base__Map, Base__Option, Base__Printf, Base__Set, Base__String, Base__Type_equal, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Univ_map__Univ_map_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Univ_map$0 = "Univ_map",
    cst = "_",
    cst_univ_map$0 = "univ_map",
    cst_univ_map_src_univ_map_ml = "univ_map/src/univ_map.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Option = global_data.Base__Option,
    Base_Type_equal = global_data.Base__Type_equal,
    Base_Map = global_data.Base__Map,
    Base = global_data.Base,
    Base_Set = global_data.Base__Set,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Base_String = global_data.Base__String,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Univ_map$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_univ_map$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_univ_map_src_univ_map_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_univ_map$0, "univ_map.ml");
   var
    _m_ =
      [0,
       [11, "Univ_map.change_exn on unknown key ", [2, 0, 0]],
       "Univ_map.change_exn on unknown key %s"],
    _l_ =
      [0,
       [11, "Univ_map.add_exn on existing key ", [2, 0, 0]],
       "Univ_map.add_exn on existing key %s"],
    _k_ =
      [0,
       [11, "Univ_map.find_exn on unknown key ", [2, 0, 0]],
       "Univ_map.find_exn on unknown key %s"],
    _i_ = [0, cst],
    _h_ = [0, cst_univ_map_src_univ_map_ml, 82, 40],
    _j_ = [0, cst_univ_map_src_univ_map_ml, 81, 2431, 2455],
    _f_ = [0, cst],
    _d_ = [0, "type_id2"],
    _e_ = [0, "type_id1"],
    _g_ = [0, "key"],
    cst_Key_type_id_must_not_provi =
      "[Key.type_id] must not provide different type ids when called on the same input",
    _a_ = [0, "<uid>"],
    _b_ = [0, "uid"],
    _c_ = [0, "name"],
    cst_univ_map = cst_univ_map$0,
    cst_Univ_map = cst_Univ_map$0;
   function Make1(Key, Data){
    var sexp_of_t = Key[1];
    function sexp_of_type_id(type_id){
     var _aG_ = 0, _aH_ = 0;
     if(Ppx_inline_test_lib[1])
      var _aI_ = _a_;
     else
      var
       _aL_ = caml_call1(Base_Type_equal[12][3], type_id),
       _aI_ = caml_call1(Base_Type_equal[12][2][3], _aL_);
     var
      _aJ_ =
        [0, [1, [0, _b_, [0, caml_call1(Base[85][5], _aI_), _aH_]]], _aG_],
      _aK_ = caml_call1(Base_Type_equal[12][6], type_id);
     return [1, [0, [1, [0, _c_, [0, caml_call1(Base[202], _aK_), 0]]], _aJ_]];
    }
    function type_id(x_003){
     var
      type_id1 = caml_call1(Key[2], x_003),
      type_id2 = caml_call1(Key[2], x_003);
     if(caml_call2(Base_Type_equal[12][9], type_id1, type_id2))
      return type_id1;
     var
      _aA_ = [0, [1, [0, _d_, [0, sexp_of_type_id(type_id2), 0]]], 0],
      _aB_ = [0, [1, [0, _e_, [0, sexp_of_type_id(type_id1), 0]]], _aA_],
      _aC_ = 0;
     function _aD_(param){return _f_;}
     var
      _aE_ =
        [0, [1, [0, _g_, [0, caml_call2(Key[1], _aD_, x_003), _aC_]]], _aB_],
      _aF_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Key_type_id_must_not_provi),
          _aE_]];
     return caml_call1(Base[246], _aF_);
    }
    var Key$0 = [0, sexp_of_t, sexp_of_type_id, type_id];
    function name_of_key(key){
     var _az_ = Key$0[3].call(null, key);
     return caml_call1(Base_Type_equal[12][6], _az_);
    }
    function uid_of_key(key){
     var _ay_ = Key$0[3].call(null, key);
     return caml_call1(Base_Type_equal[12][3], _ay_);
    }
    function sexp_of_t$0(sexp_of_a, param){
     var
      data = param[2],
      key = param[1],
      _aw_ = Key$0[3].call(null, key),
      _ax_ = caml_call1(Base_Type_equal[12][7], _aw_);
     return caml_call3(Data[1], sexp_of_a, _ax_, data);
    }
    function type_id_name(param){var key = param[1]; return name_of_key(key);}
    function type_id_uid(param){var key = param[1]; return uid_of_key(key);}
    function compare(t1, t2){
     var
      _as_ = type_id_name(t2),
      _at_ = type_id_name(t1),
      c = caml_call2(Base_String[51], _at_, _as_);
     if(0 !== c) return c;
     var _au_ = type_id_uid(t2), _av_ = type_id_uid(t1);
     return caml_call2(Base_Type_equal[12][2][11], _av_, _au_);
    }
    var Packed = [0, sexp_of_t$0, type_id_name, type_id_uid, compare];
    function to_alist(t){
     var _aq_ = Packed[4], _ar_ = caml_call1(Base_Map[74], t);
     return caml_call2(Base_List[83], _ar_, _aq_);
    }
    function sexp_of_t$1(sexp_of_a, t){
     function _an_(packed){return [0, Packed[2].call(null, packed), packed];}
     var _ao_ = to_alist(t), x_008 = caml_call2(Base_List[53], _ao_, _an_);
     function _ap_(param){
      var
       arg1_005 = param[2],
       arg0_004 = param[1],
       res0_006 = caml_call1(Base[202], arg0_004),
       res1_007 = Packed[1].call(null, sexp_of_a, arg1_005);
      return [1, [0, res0_006, [0, res1_007, 0]]];
     }
     return caml_call2(Base[165], _ap_, x_008);
    }
    function invariant(t){
     function _aj_(param){
      function _al_(key, data){
       var _am_ = Packed[3].call(null, data);
       if(caml_call2(Base_Type_equal[12][2][10], key, _am_)) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      }
      return caml_call2(Base_Map[48], t, _al_);
     }
     function _ak_(x_009){
      return sexp_of_t$1(function(param){return _i_;}, x_009);
     }
     return caml_call4(Base_Invariant[1], _j_, t, _ak_, _aj_);
    }
    function set(t, key, data){
     var _ai_ = uid_of_key(key);
     return caml_call3(Base_Map[34], t, _ai_, [0, key, data]);
    }
    function mem_by_id(t, id){return caml_call2(Base_Map[45], t, id);}
    function mem(t, key){return mem_by_id(t, uid_of_key(key));}
    function remove_by_id(t, id){return caml_call2(Base_Map[44], t, id);}
    function remove(t, key){return remove_by_id(t, uid_of_key(key));}
    var empty = caml_call1(Base_Map[6], [0, Base_Type_equal[12][2][19]]);
    function singleton(key, data){
     var _ah_ = uid_of_key(key);
     return caml_call3
             (Base_Map[7],
              [0, Base_Type_equal[12][2][19]],
              _ah_,
              [0, key, data]);
    }
    var is_empty = Base_Map[32];
    function find(t, key){
     var _ae_ = uid_of_key(key), match = caml_call2(Base_Map[42], t, _ae_);
     if(! match) return 0;
     var
      match$0 = match[1],
      value = match$0[2],
      key$0 = match$0[1],
      _af_ = Key$0[3].call(null, key$0),
      _ag_ = Key$0[3].call(null, key);
     caml_call2(Base_Type_equal[12][11], _ag_, _af_);
     return [0, value];
    }
    function find_exn(t, key){
     var match = find(t, key);
     if(match){var data = match[1]; return data;}
     var _ad_ = name_of_key(key);
     return caml_call3(Base_Printf[6], _k_, _ad_, 0);
    }
    function add(t, key, data){
     return mem(t, key) ? -1024851605 : [0, 17724, set(t, key, data)];
    }
    function add_exn(t, key, data){
     var match = add(t, key, data);
     if(typeof match === "number"){
      var _ac_ = name_of_key(key);
      return caml_call3(Base_Printf[6], _l_, _ac_, 0);
     }
     var t$0 = match[2];
     return t$0;
    }
    function change_exn(t, key, update){
     var match = find(t, key);
     if(match){
      var data = match[1];
      return set(t, key, caml_call1(update, data));
     }
     var _ab_ = name_of_key(key);
     return caml_call3(Base_Printf[6], _m_, _ab_, 0);
    }
    function change(t, key, update){
     var orig = find(t, key), next = caml_call1(update, orig);
     if(! next) return caml_call1(Base_Option[52], orig) ? t : remove(t, key);
     var data = next[1];
     return set(t, key, data);
    }
    function update(t, key, f){
     return change(t, key, function(data){return [0, caml_call1(f, data)];});
    }
    function key_id_set(t){
     var _aa_ = caml_call1(Base_Map[73], t);
     return caml_call2(Base_Set[32], [0, Base_Type_equal[12][2][19]], _aa_);
    }
    function of_alist_exn(t){
     function ___(p){return [0, Packed[3].call(null, p), p];}
     var _$_ = caml_call2(Base_List[53], t, ___);
     return caml_call2(Base_Map[10], [0, Base_Type_equal[12][2][19]], _$_);
    }
    var
     find_packed_by_id = Base_Map[42],
     find_packed_by_id_exn = Base_Map[43];
    return [0,
            Key$0,
            ,
            ,
            ,
            to_alist,
            sexp_of_t$1,
            invariant,
            set,
            mem_by_id,
            mem,
            remove_by_id,
            remove,
            empty,
            singleton,
            is_empty,
            find,
            find_exn,
            add,
            add_exn,
            change_exn,
            change,
            update,
            key_id_set,
            of_alist_exn,
            find_packed_by_id,
            find_packed_by_id_exn,
            0];
   }
   function Make(Key, Data){
    function sexp_of_t(of_a_011, of_a_012, x_013){return caml_call2(Data[1], of_a_012, x_013);
    }
    var M = Make1(Key, [0, sexp_of_t]);
    function sexp_of_t$0(x_014){return M[6].call(null, Base[220], x_014);}
    var
     invariant = M[7],
     empty = M[13],
     singleton = M[14],
     is_empty = M[15],
     set = M[8],
     mem = M[10],
     mem_by_id = M[9],
     find = M[16],
     find_exn = M[17],
     add = M[18],
     add_exn = M[19],
     change = M[21],
     change_exn = M[20],
     update = M[22],
     remove = M[12],
     remove_by_id = M[11],
     Packed = [0],
     key_id_set = M[23],
     to_alist = M[5],
     of_alist_exn = M[24],
     find_packed_by_id = M[25],
     find_packed_by_id_exn = M[26];
    return [0,
            ,
            sexp_of_t$0,
            Key,
            invariant,
            empty,
            singleton,
            is_empty,
            set,
            mem,
            mem_by_id,
            find,
            find_exn,
            add,
            add_exn,
            change,
            change_exn,
            update,
            remove,
            remove_by_id,
            Packed,
            key_id_set,
            to_alist,
            of_alist_exn,
            find_packed_by_id,
            find_packed_by_id_exn,
            0];
   }
   var sexp_of_t = Base_Type_equal[12][1];
   function type_id(_Z_){return _Z_;}
   var Type_id_key = [0, sexp_of_t, type_id];
   function sexp_of_t$0(of_a_017){return of_a_017;}
   var
    _s_ = Make(Type_id_key, [0, sexp_of_t$0]),
    type_equal = _s_[26],
    find_packed_by_id_exn = _s_[25],
    find_packed_by_id = _s_[24],
    of_alist_exn = _s_[23],
    to_alist = _s_[22],
    key_id_set = _s_[21],
    Packed = _s_[20],
    remove_by_id = _s_[19],
    remove = _s_[18],
    update = _s_[17],
    change_exn = _s_[16],
    change = _s_[15],
    add_exn = _s_[14],
    add = _s_[13],
    find_exn = _s_[12],
    find = _s_[11],
    mem_by_id = _s_[10],
    mem = _s_[9],
    set = _s_[8],
    is_empty = _s_[7],
    singleton = _s_[6],
    empty = _s_[5],
    invariant = _s_[4],
    sexp_of_t$1 = _s_[2];
   function create(default$0, name, sexp_of){
    return [0, caml_call2(Base_Type_equal[12][4], name, sexp_of), default$0];
   }
   function id(t){return t[1];}
   var Key = [0, create, id];
   function find$0(t, param){
    var default$0 = param[2], key = param[1], _Y_ = find(t, key);
    return caml_call2(Base_Option[30], _Y_, default$0);
   }
   function set$0(t, param, data){
    var key = param[1];
    return set(t, key, data);
   }
   function change$0(t, key, update){
    return set$0(t, key, caml_call1(update, find$0(t, key)));
   }
   function create$0(init, f, name, sexp_of){
    return [0, caml_call3(Key[1], init, name, sexp_of), f];
   }
   function id$0(t){return caml_call1(Key[2], t[1]);}
   var Key$0 = [0, create$0, id$0];
   function find$1(t, param){var key = param[1]; return find$0(t, key);}
   function set$1(t, param, data){
    var key = param[1];
    return set$0(t, key, data);
   }
   function change$1(t, param, update){
    var key = param[1];
    return change$0(t, key, update);
   }
   function add$0(t, param, data){
    var f = param[2], key = param[1];
    return change$0(t, key, function(acc){return caml_call2(f, acc, data);});
   }
   function create$1(name, sexp_of){
    var _W_ = caml_call1(Base_List[6], sexp_of);
    function _X_(xs, x){return [0, x, xs];}
    return caml_call4(Key$0[1], 0, _X_, name, _W_);
   }
   var
    id$1 = Key$0[2],
    Key$1 = [0, create$1, id$1],
    Multi = [0, Key$1, set$1, find$1, add$0, change$1];
   caml_call1(Ppx_inline_test_lib[7], cst_univ_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Univ_map);
   var
    _n_ = [0, Key$0, set$1, find$1, add$0, change$1],
    _o_ = [0, Key, set$0, find$0, change$0];
   function _p_(Key, _M_, _L_, Output_data){
    Make1(Key, Output_data);
    function merge(t1, t2, param){
     var f = param[1];
     function f$0(key, merge_result){
      function _U_(data){return [0, key, data];}
      var _V_ = caml_call2(f, key, merge_result);
      return caml_call2(Base_Option[24], _V_, _U_);
     }
     function _N_(param, _O_){
      var _P_ = _O_[1];
      if(737457313 === _P_){
       var
        _Q_ = _O_[2],
        _R_ = _Q_[2],
        right_data = _R_[2],
        right_key = _R_[1],
        match = _Q_[1],
        left_data = match[2],
        left_key = match[1],
        _S_ = caml_call1(Key[2], right_key),
        _T_ = caml_call1(Key[2], left_key);
       caml_call2(Base_Type_equal[12][11], _T_, _S_);
       return f$0(left_key, [0, 737457313, [0, left_data, right_data]]);
      }
      if(847852583 <= _P_){
       var match$0 = _O_[2], data = match$0[2], key = match$0[1];
       return f$0(key, [0, 847852583, data]);
      }
      var match$1 = _O_[2], data$0 = match$1[2], key$0 = match$1[1];
      return f$0(key$0, [0, -57574468, data$0]);
     }
     return caml_call3(Base_Map[76], t1, t2, _N_);
    }
    return [0, merge];
   }
   function _q_(Key, _B_, _A_, Output_data){
    Make(Key, Output_data);
    function merge(t1, t2, param){
     var f = param[1];
     function f$0(key, merge_result){
      function _J_(data){return [0, key, data];}
      var _K_ = caml_call2(f, key, merge_result);
      return caml_call2(Base_Option[24], _K_, _J_);
     }
     function _C_(param, _D_){
      var _E_ = _D_[1];
      if(737457313 === _E_){
       var
        _F_ = _D_[2],
        _G_ = _F_[2],
        right_data = _G_[2],
        right_key = _G_[1],
        match = _F_[1],
        left_data = match[2],
        left_key = match[1],
        _H_ = caml_call1(Key[2], right_key),
        _I_ = caml_call1(Key[2], left_key);
       caml_call2(Base_Type_equal[12][11], _I_, _H_);
       return f$0(left_key, [0, 737457313, [0, left_data, right_data]]);
      }
      if(847852583 <= _E_){
       var match$0 = _D_[2], data = match$0[2], key = match$0[1];
       return f$0(key, [0, 847852583, data]);
      }
      var match$1 = _D_[2], data$0 = match$1[2], key$0 = match$1[1];
      return f$0(key$0, [0, -57574468, data$0]);
     }
     return caml_call3(Base_Map[76], t1, t2, _C_);
    }
    return [0, merge];
   }
   function _r_(_x_, _w_){
    var _y_ = Make1(_x_, _w_), _z_ = _y_[1];
    return [0,
            _y_[6],
            [0, _z_[1], _z_[3]],
            _y_[7],
            _y_[13],
            _y_[14],
            _y_[15],
            _y_[8],
            _y_[10],
            _y_[9],
            _y_[16],
            _y_[17],
            _y_[18],
            _y_[19],
            _y_[21],
            _y_[20],
            _y_[22],
            _y_[12],
            _y_[11],
            [0],
            _y_[23],
            _y_[5],
            _y_[24],
            _y_[25],
            _y_[26],
            _y_[27]];
   }
   var
    Univ_map =
      [0,
       Type_id_key,
       sexp_of_t$1,
       invariant,
       empty,
       singleton,
       is_empty,
       set,
       mem,
       mem_by_id,
       find,
       find_exn,
       add,
       add_exn,
       change,
       change_exn,
       update,
       remove,
       remove_by_id,
       Packed,
       key_id_set,
       to_alist,
       of_alist_exn,
       find_packed_by_id,
       find_packed_by_id_exn,
       type_equal,
       function(_u_, _t_){
        var _v_ = Make(_u_, _t_);
        return [0,
                _v_[2],
                _v_[3],
                _v_[4],
                _v_[5],
                _v_[6],
                _v_[7],
                _v_[8],
                _v_[9],
                _v_[10],
                _v_[11],
                _v_[12],
                _v_[13],
                _v_[14],
                _v_[15],
                _v_[16],
                _v_[17],
                _v_[18],
                _v_[19],
                _v_[20],
                _v_[21],
                _v_[22],
                _v_[23],
                _v_[24],
                _v_[25],
                _v_[26]];
       },
       _r_,
       _q_,
       _p_,
       _o_,
       _n_,
       Multi];
   runtime.caml_register_global(36, Univ_map, cst_Univ_map$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1bml2X21hcC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90Iiwic2V4cF9vZl90eXBlX2lkIiwidHlwZV9pZCIsInhfMDAzIiwidHlwZV9pZDEiLCJ0eXBlX2lkMiIsIm5hbWVfb2Zfa2V5Iiwia2V5IiwidWlkX29mX2tleSIsInNleHBfb2ZfdCQwIiwic2V4cF9vZl9hIiwiZGF0YSIsInR5cGVfaWRfbmFtZSIsInR5cGVfaWRfdWlkIiwiY29tcGFyZSIsInQxIiwidDIiLCJjIiwidG9fYWxpc3QiLCJ0Iiwic2V4cF9vZl90JDEiLCJwYWNrZWQiLCJ4XzAwOCIsImFyZzFfMDA1IiwiYXJnMF8wMDQiLCJyZXMwXzAwNiIsInJlczFfMDA3IiwiaW52YXJpYW50IiwieF8wMDkiLCJzZXQiLCJtZW1fYnlfaWQiLCJpZCIsIm1lbSIsInJlbW92ZV9ieV9pZCIsInJlbW92ZSIsImVtcHR5Iiwic2luZ2xldG9uIiwiaXNfZW1wdHkiLCJmaW5kIiwidmFsdWUiLCJrZXkkMCIsImZpbmRfZXhuIiwiYWRkIiwiYWRkX2V4biIsInQkMCIsImNoYW5nZV9leG4iLCJ1cGRhdGUiLCJjaGFuZ2UiLCJvcmlnIiwibmV4dCIsImYiLCJrZXlfaWRfc2V0Iiwib2ZfYWxpc3RfZXhuIiwicCIsImZpbmRfcGFja2VkX2J5X2lkIiwiZmluZF9wYWNrZWRfYnlfaWRfZXhuIiwib2ZfYV8wMTEiLCJvZl9hXzAxMiIsInhfMDEzIiwieF8wMTQiLCJvZl9hXzAxNyIsInR5cGVfZXF1YWwiLCJjcmVhdGUiLCJkZWZhdWx0JDAiLCJuYW1lIiwic2V4cF9vZiIsImZpbmQkMCIsInNldCQwIiwiY2hhbmdlJDAiLCJjcmVhdGUkMCIsImluaXQiLCJpZCQwIiwiZmluZCQxIiwic2V0JDEiLCJjaGFuZ2UkMSIsImFkZCQwIiwiYWNjIiwiY3JlYXRlJDEiLCJ4cyIsIngiLCJpZCQxIiwibWVyZ2UiLCJmJDAiLCJtZXJnZV9yZXN1bHQiLCJyaWdodF9kYXRhIiwicmlnaHRfa2V5IiwibGVmdF9kYXRhIiwibGVmdF9rZXkiLCJkYXRhJDAiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlL3VuaXZfbWFwL3VuaXZfbWFwX18ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlL3VuaXZfbWFwL3VuaXZfbWFwLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0dBS29COztJQUFBOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDYWhCQTthQUdJQyxnQkFBZ0JDOzs7OztNQU1zQjtPQUFBLE9BQUEsbUNBTnRCQTtjQU1OO0tBSkE7OztNQUFBLE9BQUEsbUNBRk1BOzs7YUFXaEJBLFFBVWFDO0tBVGY7TUFBSUMsV0FBVyxtQkFTQUQ7TUFSWEUsV0FBVyxtQkFRQUY7S0FQWixHQUFBLG1DQUZDQyxVQUNBQztNQUVDLE9BSEREOztrQ0FaRkgsZ0JBYUVJO2tDQWJGSixnQkFZRUc7OzBCOzs7c0RBU1dEOzs7Ozs7O0lBRWM7SUEzQnBCLGdCQUNYSCxXQUdJQyxpQkFXQUM7YUFrQkZJLFlBQVlDO0tBQXlCLCtCQUF6QkE7S0FBeUIsT0FBQTtJQUFpQjthQUN0REMsV0FBV0Q7S0FBd0IsK0JBQXhCQTtLQUF3QixPQUFBO0lBQWlCO2FBS2xERSxZQUFVQztLQUNvQztNQURqQkM7TUFBTEo7TUFDc0IsMkJBRHRCQTtNQUNELE9BQUE7S0FBekIsT0FBQSxvQkFEWUcsaUJBQW1CQzs7YUFJN0JDLHdCQUFpQkwsZ0JBQVcsT0FWOUJELFlBVW1CQzthQUNqQk0sdUJBQWdCTixnQkFBVyxPQVY3QkMsV0FVa0JEO2FBRWhCTyxRQUFRQyxJQUFHQztLQUNiO01BQXlDLE9BSnZDSixhQUdXSTtN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O09Bc0VBN0Q7T0FBQU87T0FBQVE7T0FBQUM7T0FBQUM7T0FBQVI7T0FBQUc7T0FBQUY7T0FBQVE7T0FBQUc7T0FBQUM7T0FBQUM7T0FBQUk7T0FBQUY7T0FBQUM7T0FBQVo7T0FBQUQ7O09BQUFrQjtPQUFBakM7T0FBQWtDO09BQUFFO09BQUFDO09BQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgVW5pdl9tYXAuVW5pdl9tYXBfaW50ZiAqKVxubW9kdWxlIFVuaXZfbWFwX2ludGYgPSBVbml2X21hcF9fVW5pdl9tYXBfaW50ZlxuXG5tb2R1bGUgVW5pdl9tYXBfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwib3BlbiEgQmFzZVxuaW5jbHVkZSBVbml2X21hcF9pbnRmXG5tb2R1bGUgVWlkID0gVHlwZV9lcXVhbC5JZC5VaWRcblxubW9kdWxlIE1ha2UxXG4gIChLZXkgOiBLZXkpIChEYXRhIDogc2lnXG4gICAgdHlwZSAoJ3MsICdhKSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZCkgPVxuc3RydWN0XG4gICgqIEEgd3JhcHBlciBmb3IgdGhlIFtLZXldIG1vZHVsZSB0aGF0IGFkZHMgYSBkeW5hbWljIGNoZWNrIHRvIFtLZXkudHlwZV9pZF0uXG5cbiAgICAgSXQncyBhIGJ1ZyBpZiB0aGUgdXNlci1wcm92aWRlZCBbS2V5LnR5cGVfaWRdIGdpdmVzIGRpZmZlcmVudCB0eXBlIGlkcyBvbiBkaWZmZXJlbnRcbiAgICAgY2FsbHMuICBCZWNhdXNlIHRoaXMgY2hlY2sgc2hvdWxkIGJlIGZhaXJseSBjaGVhcCwgd2UgZG8gaXQgZHluYW1pY2FsbHkgdG8gYXZvaWRcbiAgICAgc3VidGxlciBwcm9ibGVtcyBsYXRlci5cblxuICAgICBPZiBjb3Vyc2UsIHdlJ3JlIG5vdCBjaGVja2luZyB0cnVseSBwYXRob2xvZ2ljYWwgdGhpbmdzIGxpa2UgdGhlIHByb3ZpZGVkXG4gICAgIFtLZXkudHlwZV9pZF0gb25seSBjaGFuZ2VzIHRoZSB2YWx1ZSBpdCByZXR1cm5zIG9uIGV2ZXJ5IHRoaXJkIGNhbGwuLi4gKilcbiAgbW9kdWxlIEtleSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIEtleS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICAoKiB0ZXN0LWZyaWVuZGx5IHNleHAgY29udmVyc2lvbiAqKVxuICAgIGxldCBzZXhwX29mX3R5cGVfaWQgdHlwZV9pZCA9XG4gICAgICBbJXNleHBcbiAgICAgICAgeyBuYW1lID0gKFR5cGVfZXF1YWwuSWQubmFtZSB0eXBlX2lkIDogc3RyaW5nKVxuICAgICAgICA7IHVpZCA9XG4gICAgICAgICAgICAoaWYgUHB4X2lubGluZV90ZXN0X2xpYi5hbV9ydW5uaW5nXG4gICAgICAgICAgICAgdGhlbiBTZXhwLkF0b20gXCI8dWlkPlwiXG4gICAgICAgICAgICAgZWxzZSBUeXBlX2VxdWFsLklkLlVpZC5zZXhwX29mX3QgKFR5cGVfZXF1YWwuSWQudWlkIHR5cGVfaWQpXG4gICAgICAgICAgICAgIDogU2V4cC50KVxuICAgICAgICB9XVxuICAgIDs7XG5cbiAgICBsZXQgdHlwZV9pZCBrZXkgPVxuICAgICAgbGV0IHR5cGVfaWQxID0gS2V5LnR5cGVfaWQga2V5IGluXG4gICAgICBsZXQgdHlwZV9pZDIgPSBLZXkudHlwZV9pZCBrZXkgaW5cbiAgICAgIGlmIFR5cGVfZXF1YWwuSWQuc2FtZSB0eXBlX2lkMSB0eXBlX2lkMlxuICAgICAgdGhlbiB0eXBlX2lkMVxuICAgICAgZWxzZVxuICAgICAgICByYWlzZV9zXG4gICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICBcIltLZXkudHlwZV9pZF0gbXVzdCBub3QgcHJvdmlkZSBkaWZmZXJlbnQgdHlwZSBpZHMgd2hlbiBjYWxsZWQgb24gdGhlIHNhbWUgXFxcbiAgICAgICAgICAgICBpbnB1dFwiXG4gICAgICAgICAgICAgIChrZXkgOiBfIEtleS50KVxuICAgICAgICAgICAgICAodHlwZV9pZDEgOiB0eXBlX2lkKVxuICAgICAgICAgICAgICAodHlwZV9pZDIgOiB0eXBlX2lkKV1cbiAgICA7O1xuICBlbmRcblxuICB0eXBlICgncywgJ2EpIGRhdGEgPSAoJ3MsICdhKSBEYXRhLnRcblxuICBsZXQgbmFtZV9vZl9rZXkga2V5ID0gVHlwZV9lcXVhbC5JZC5uYW1lIChLZXkudHlwZV9pZCBrZXkpXG4gIGxldCB1aWRfb2Zfa2V5IGtleSA9IFR5cGVfZXF1YWwuSWQudWlkIChLZXkudHlwZV9pZCBrZXkpXG5cbiAgbW9kdWxlIFBhY2tlZCA9IHN0cnVjdFxuICAgIHR5cGUgJ3MgdCA9IFQgOiAnYSBLZXkudCAqICgncywgJ2EpIERhdGEudCAtPiAncyB0XG5cbiAgICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSAoVCAoa2V5LCBkYXRhKSkgPVxuICAgICAgRGF0YS5zZXhwX29mX3Qgc2V4cF9vZl9hIChUeXBlX2VxdWFsLklkLnRvX3NleHAgKEtleS50eXBlX2lkIGtleSkpIGRhdGFcbiAgICA7O1xuXG4gICAgbGV0IHR5cGVfaWRfbmFtZSAoVCAoa2V5LCBfKSkgPSBuYW1lX29mX2tleSBrZXlcbiAgICBsZXQgdHlwZV9pZF91aWQgKFQgKGtleSwgXykpID0gdWlkX29mX2tleSBrZXlcblxuICAgIGxldCBjb21wYXJlIHQxIHQyID1cbiAgICAgIGxldCBjID0gU3RyaW5nLmNvbXBhcmUgKHR5cGVfaWRfbmFtZSB0MSkgKHR5cGVfaWRfbmFtZSB0MikgaW5cbiAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZSBVaWQuY29tcGFyZSAodHlwZV9pZF91aWQgdDEpICh0eXBlX2lkX3VpZCB0MilcbiAgICA7O1xuICBlbmRcblxuICB0eXBlICdzIHQgPSAncyBQYWNrZWQudCBNYXAuTShVaWQpLnRcblxuICBsZXQgdG9fYWxpc3QgdCA9IE1hcC5kYXRhIHQgfD4gTGlzdC5zb3J0IH5jb21wYXJlOlBhY2tlZC5jb21wYXJlXG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgdG9fYWxpc3QgdFxuICAgIHw+IExpc3QubWFwIH5mOihmdW4gcGFja2VkIC0+IFBhY2tlZC50eXBlX2lkX25hbWUgcGFja2VkLCBwYWNrZWQpXG4gICAgfD4gWyVzZXhwX29mOiAoc3RyaW5nICogYSBQYWNrZWQudCkgbGlzdF1cbiAgOztcblxuICBsZXQgaW52YXJpYW50ICh0IDogXyB0KSA9XG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICAgIE1hcC5pdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBhc3NlcnQgKFVpZC5lcXVhbCBrZXkgKFBhY2tlZC50eXBlX2lkX3VpZCBkYXRhKSkpKVxuICA7O1xuXG4gIGxldCBzZXQgdCB+a2V5IH5kYXRhID0gTWFwLnNldCB0IH5rZXk6KHVpZF9vZl9rZXkga2V5KSB+ZGF0YTooUGFja2VkLlQgKGtleSwgZGF0YSkpXG4gIGxldCBtZW1fYnlfaWQgdCBpZCA9IE1hcC5tZW0gdCBpZFxuICBsZXQgbWVtIHQga2V5ID0gbWVtX2J5X2lkIHQgKHVpZF9vZl9rZXkga2V5KVxuICBsZXQgcmVtb3ZlX2J5X2lkIHQgaWQgPSBNYXAucmVtb3ZlIHQgaWRcbiAgbGV0IHJlbW92ZSB0IGtleSA9IHJlbW92ZV9ieV9pZCB0ICh1aWRfb2Zfa2V5IGtleSlcbiAgbGV0IGVtcHR5ID0gTWFwLmVtcHR5IChtb2R1bGUgVWlkKVxuXG4gIGxldCBzaW5nbGV0b24ga2V5IGRhdGEgPVxuICAgIE1hcC5zaW5nbGV0b24gKG1vZHVsZSBVaWQpICh1aWRfb2Zfa2V5IGtleSkgKFBhY2tlZC5UIChrZXksIGRhdGEpKVxuICA7O1xuXG4gIGxldCBpc19lbXB0eSA9IE1hcC5pc19lbXB0eVxuXG4gIGxldCBmaW5kICh0eXBlIGIpIHQgKGtleSA6IGIgS2V5LnQpID1cbiAgICBtYXRjaCBNYXAuZmluZCB0ICh1aWRfb2Zfa2V5IGtleSkgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChQYWNrZWQuVCAoa2V5JywgdmFsdWUpKSAtPlxuICAgICAgKCogY2Fubm90IHJhaXNlIC0tIHNlZSBbaW52YXJpYW50XSAqKVxuICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9XG4gICAgICAgIFR5cGVfZXF1YWwuSWQuc2FtZV93aXRuZXNzX2V4biAoS2V5LnR5cGVfaWQga2V5KSAoS2V5LnR5cGVfaWQga2V5JylcbiAgICAgIGluXG4gICAgICBTb21lICh2YWx1ZSA6IChfLCBiKSBEYXRhLnQpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuIHQga2V5ID1cbiAgICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgICB8IFNvbWUgZGF0YSAtPiBkYXRhXG4gICAgfCBOb25lIC0+IFByaW50Zi5mYWlsd2l0aGYgXCJVbml2X21hcC5maW5kX2V4biBvbiB1bmtub3duIGtleSAlc1wiIChuYW1lX29mX2tleSBrZXkpICgpXG4gIDs7XG5cbiAgbGV0IGFkZCB0IH5rZXkgfmRhdGEgPSBpZiBtZW0gdCBrZXkgdGhlbiBgRHVwbGljYXRlIGVsc2UgYE9rIChzZXQgdCB+a2V5IH5kYXRhKVxuXG4gIGxldCBhZGRfZXhuIHQgfmtleSB+ZGF0YSA9XG4gICAgbWF0Y2ggYWRkIHQgfmtleSB+ZGF0YSB3aXRoXG4gICAgfCBgT2sgdCAtPiB0XG4gICAgfCBgRHVwbGljYXRlIC0+XG4gICAgICBQcmludGYuZmFpbHdpdGhmIFwiVW5pdl9tYXAuYWRkX2V4biBvbiBleGlzdGluZyBrZXkgJXNcIiAobmFtZV9vZl9rZXkga2V5KSAoKVxuICA7O1xuXG4gIGxldCBjaGFuZ2VfZXhuIHQga2V5IH5mOnVwZGF0ZSA9XG4gICAgbWF0Y2ggZmluZCB0IGtleSB3aXRoXG4gICAgfCBTb21lIGRhdGEgLT4gc2V0IHQgfmtleSB+ZGF0YToodXBkYXRlIGRhdGEpXG4gICAgfCBOb25lIC0+XG4gICAgICBQcmludGYuZmFpbHdpdGhmIFwiVW5pdl9tYXAuY2hhbmdlX2V4biBvbiB1bmtub3duIGtleSAlc1wiIChuYW1lX29mX2tleSBrZXkpICgpXG4gIDs7XG5cbiAgbGV0IGNoYW5nZSB0IGtleSB+Zjp1cGRhdGUgPVxuICAgIGxldCBvcmlnID0gZmluZCB0IGtleSBpblxuICAgIGxldCBuZXh0ID0gdXBkYXRlIG9yaWcgaW5cbiAgICBtYXRjaCBuZXh0IHdpdGhcbiAgICB8IFNvbWUgZGF0YSAtPiBzZXQgdCB+a2V5IH5kYXRhXG4gICAgfCBOb25lIC0+IGlmIE9wdGlvbi5pc19ub25lIG9yaWcgdGhlbiB0IGVsc2UgcmVtb3ZlIHQga2V5XG4gIDs7XG5cbiAgbGV0IHVwZGF0ZSB0IGtleSB+ZiA9IGNoYW5nZSB0IGtleSB+ZjooZnVuIGRhdGEgLT4gU29tZSAoZiBkYXRhKSlcbiAgbGV0IGtleV9pZF9zZXQgdCA9IFNldC5vZl9saXN0IChtb2R1bGUgVWlkKSAoTWFwLmtleXMgdClcblxuICBsZXQgb2ZfYWxpc3RfZXhuIHQgPVxuICAgIE1hcC5vZl9hbGlzdF9leG4gKG1vZHVsZSBVaWQpIChMaXN0Lm1hcCB0IH5mOihmdW4gcCAtPiBQYWNrZWQudHlwZV9pZF91aWQgcCwgcCkpXG4gIDs7XG5cbiAgbGV0IGZpbmRfcGFja2VkX2J5X2lkID0gTWFwLmZpbmRcbiAgbGV0IGZpbmRfcGFja2VkX2J5X2lkX2V4biA9IE1hcC5maW5kX2V4blxuICBsZXQgdHlwZV9lcXVhbCA6ICgncyB0LCAncyBQYWNrZWQudCBNYXAuTShUeXBlX2VxdWFsLklkLlVpZCkudCkgVHlwZV9lcXVhbC50ID0gVFxuZW5kXG5cbm1vZHVsZSBNYWtlXG4gIChLZXkgOiBLZXkpIChEYXRhIDogc2lnXG4gICAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBNID1cbiAgICBNYWtlMVxuICAgICAgKEtleSlcbiAgICAgIChzdHJ1Y3RcbiAgICAgICAgdHlwZSAoXywgJ2EpIHQgPSAnYSBEYXRhLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICAgIGVuZClcblxuICB0eXBlIHQgPSB1bml0IE0udCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIG1vZHVsZSBLZXkgPSBLZXlcblxuICB0eXBlICdhIGRhdGEgPSAnYSBEYXRhLnRcblxuICBsZXQgaW52YXJpYW50ID0gTS5pbnZhcmlhbnRcbiAgbGV0IGVtcHR5ID0gTS5lbXB0eVxuICBsZXQgc2luZ2xldG9uID0gTS5zaW5nbGV0b25cbiAgbGV0IGlzX2VtcHR5ID0gTS5pc19lbXB0eVxuICBsZXQgc2V0ID0gTS5zZXRcbiAgbGV0IG1lbSA9IE0ubWVtXG4gIGxldCBtZW1fYnlfaWQgPSBNLm1lbV9ieV9pZFxuICBsZXQgZmluZCA9IE0uZmluZFxuICBsZXQgZmluZF9leG4gPSBNLmZpbmRfZXhuXG4gIGxldCBhZGQgPSBNLmFkZFxuICBsZXQgYWRkX2V4biA9IE0uYWRkX2V4blxuICBsZXQgY2hhbmdlID0gTS5jaGFuZ2VcbiAgbGV0IGNoYW5nZV9leG4gPSBNLmNoYW5nZV9leG5cbiAgbGV0IHVwZGF0ZSA9IE0udXBkYXRlXG4gIGxldCByZW1vdmUgPSBNLnJlbW92ZVxuICBsZXQgcmVtb3ZlX2J5X2lkID0gTS5yZW1vdmVfYnlfaWRcblxuICBtb2R1bGUgUGFja2VkID0gc3RydWN0XG4gICAgdHlwZSAncyB0MSA9ICdzIE0uUGFja2VkLnQgPSBUIDogJ2EgS2V5LnQgKiAnYSBEYXRhLnQgLT4gJ3MgdDFcbiAgICB0eXBlIHQgPSB1bml0IHQxXG4gIGVuZFxuXG4gIGxldCBrZXlfaWRfc2V0ID0gTS5rZXlfaWRfc2V0XG4gIGxldCB0b19hbGlzdCA9IE0udG9fYWxpc3RcbiAgbGV0IG9mX2FsaXN0X2V4biA9IE0ub2ZfYWxpc3RfZXhuXG4gIGxldCBmaW5kX3BhY2tlZF9ieV9pZCA9IE0uZmluZF9wYWNrZWRfYnlfaWRcbiAgbGV0IGZpbmRfcGFja2VkX2J5X2lkX2V4biA9IE0uZmluZF9wYWNrZWRfYnlfaWRfZXhuXG4gIGxldCB0eXBlX2VxdWFsIDogKHQsIFBhY2tlZC50IE1hcC5NKFR5cGVfZXF1YWwuSWQuVWlkKS50KSBUeXBlX2VxdWFsLnQgPSBUXG5lbmRcblxubW9kdWxlIE1lcmdlIChLZXkgOiBLZXkpIChJbnB1dDFfZGF0YSA6IERhdGEpIChJbnB1dDJfZGF0YSA6IERhdGEpIChPdXRwdXRfZGF0YSA6IERhdGEpID1cbnN0cnVjdFxuICB0eXBlIGYgPVxuICAgIHsgZiA6XG4gICAgICAgICdhLlxuICAgICAgICBrZXk6J2EgS2V5LnRcbiAgICAgICAgLT4gWyBgTGVmdCBvZiAnYSBJbnB1dDFfZGF0YS50XG4gICAgICAgICAgIHwgYFJpZ2h0IG9mICdhIElucHV0Ml9kYXRhLnRcbiAgICAgICAgICAgfCBgQm90aCBvZiAnYSBJbnB1dDFfZGF0YS50ICogJ2EgSW5wdXQyX2RhdGEudFxuICAgICAgICAgICBdXG4gICAgICAgIC0+ICdhIE91dHB1dF9kYXRhLnQgb3B0aW9uXG4gICAgfVxuXG4gIG1vZHVsZSBPdXRwdXQgPSBNYWtlIChLZXkpIChPdXRwdXRfZGF0YSlcblxuICBsZXQgbWVyZ2UgKHQxIDogTWFrZShLZXkpKElucHV0MV9kYXRhKS50KSAodDIgOiBNYWtlKEtleSkoSW5wdXQyX2RhdGEpLnQpIH5mOnsgZiB9XG4gICAgOiBNYWtlKEtleSkoT3V0cHV0X2RhdGEpLnRcbiAgICA9XG4gICAgbGV0IGYgfmtleSBtZXJnZV9yZXN1bHQgPVxuICAgICAgT3B0aW9uLm1hcCAoZiB+a2V5IG1lcmdlX3Jlc3VsdCkgfmY6KGZ1biBkYXRhIC0+IE91dHB1dC5NLlBhY2tlZC5UIChrZXksIGRhdGEpKVxuICAgIGluXG4gICAgTWFwLm1lcmdlIHQxIHQyIH5mOihmdW4gfmtleTpfIC0+IGZ1bmN0aW9uXG4gICAgICB8IGBMZWZ0IChUIChrZXksIGRhdGEpKSAtPiBmIH5rZXkgKGBMZWZ0IGRhdGEpXG4gICAgICB8IGBSaWdodCAoVCAoa2V5LCBkYXRhKSkgLT4gZiB+a2V5IChgUmlnaHQgZGF0YSlcbiAgICAgIHwgYEJvdGggKFQgKGxlZnRfa2V5LCBsZWZ0X2RhdGEpLCBUIChyaWdodF9rZXksIHJpZ2h0X2RhdGEpKSAtPlxuICAgICAgICAoKiBDYW4ndCByYWlzZSBkdWUgdG8gdGhlIGludmFyaWFudCAqKVxuICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID1cbiAgICAgICAgICBUeXBlX2VxdWFsLklkLnNhbWVfd2l0bmVzc19leG4gKEtleS50eXBlX2lkIGxlZnRfa2V5KSAoS2V5LnR5cGVfaWQgcmlnaHRfa2V5KVxuICAgICAgICBpblxuICAgICAgICBmIH5rZXk6bGVmdF9rZXkgKGBCb3RoIChsZWZ0X2RhdGEsIHJpZ2h0X2RhdGEpKSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWVyZ2UxXG4gIChLZXkgOiBLZXkpXG4gIChJbnB1dDFfZGF0YSA6IERhdGExKVxuICAoSW5wdXQyX2RhdGEgOiBEYXRhMSlcbiAgKE91dHB1dF9kYXRhIDogRGF0YTEpID1cbnN0cnVjdFxuICB0eXBlICgnczEsICdzMiwgJ3MzKSBmID1cbiAgICB7IGYgOlxuICAgICAgICAnYS5cbiAgICAgICAga2V5OidhIEtleS50XG4gICAgICAgIC0+IFsgYExlZnQgb2YgKCdzMSwgJ2EpIElucHV0MV9kYXRhLnRcbiAgICAgICAgICAgfCBgUmlnaHQgb2YgKCdzMiwgJ2EpIElucHV0Ml9kYXRhLnRcbiAgICAgICAgICAgfCBgQm90aCBvZiAoJ3MxLCAnYSkgSW5wdXQxX2RhdGEudCAqICgnczIsICdhKSBJbnB1dDJfZGF0YS50XG4gICAgICAgICAgIF1cbiAgICAgICAgLT4gKCdzMywgJ2EpIE91dHB1dF9kYXRhLnQgb3B0aW9uXG4gICAgfVxuXG4gIG1vZHVsZSBPdXRwdXQgPSBNYWtlMSAoS2V5KSAoT3V0cHV0X2RhdGEpXG5cbiAgbGV0IG1lcmdlXG4gICAgKHR5cGUgczEgczIpXG4gICAgKHQxIDogczEgTWFrZTEoS2V5KShJbnB1dDFfZGF0YSkudClcbiAgICAodDIgOiBzMiBNYWtlMShLZXkpKElucHV0Ml9kYXRhKS50KVxuICAgIH5mOnsgZiB9XG4gICAgPVxuICAgIGxldCBmIH5rZXkgbWVyZ2VfcmVzdWx0ID1cbiAgICAgIE9wdGlvbi5tYXAgKGYgfmtleSBtZXJnZV9yZXN1bHQpIH5mOihmdW4gZGF0YSAtPiBPdXRwdXQuUGFja2VkLlQgKGtleSwgZGF0YSkpXG4gICAgaW5cbiAgICBNYXAubWVyZ2UgdDEgdDIgfmY6KGZ1biB+a2V5Ol8gLT4gZnVuY3Rpb25cbiAgICAgIHwgYExlZnQgKFQgKGtleSwgZGF0YSkpIC0+IGYgfmtleSAoYExlZnQgZGF0YSlcbiAgICAgIHwgYFJpZ2h0IChUIChrZXksIGRhdGEpKSAtPiBmIH5rZXkgKGBSaWdodCBkYXRhKVxuICAgICAgfCBgQm90aCAoVCAobGVmdF9rZXksIGxlZnRfZGF0YSksIFQgKHJpZ2h0X2tleSwgcmlnaHRfZGF0YSkpIC0+XG4gICAgICAgICgqIENhbid0IHJhaXNlIGR1ZSB0byB0aGUgaW52YXJpYW50ICopXG4gICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuSWQuc2FtZV93aXRuZXNzX2V4biAoS2V5LnR5cGVfaWQgbGVmdF9rZXkpIChLZXkudHlwZV9pZCByaWdodF9rZXkpXG4gICAgICAgIGluXG4gICAgICAgIGYgfmtleTpsZWZ0X2tleSAoYEJvdGggKGxlZnRfZGF0YSwgcmlnaHRfZGF0YSkpKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBUeXBlX2lkX2tleSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBUeXBlX2VxdWFsLklkLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgdHlwZV9pZCA9IEZuLmlkXG5lbmRcblxuaW5jbHVkZSAoXG4gIE1ha2VcbiAgICAoVHlwZV9pZF9rZXkpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICBlbmQpIDpcbiAgICAgIFMgd2l0aCB0eXBlICdhIGRhdGEgPSAnYSBhbmQgbW9kdWxlIEtleSA6PSBUeXBlX2lkX2tleSlcblxubW9kdWxlIEtleSA9IFR5cGVfZXF1YWwuSWRcblxubW9kdWxlIFdpdGhfZGVmYXVsdCA9IHN0cnVjdFxuICBtb2R1bGUgS2V5ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsga2V5IDogJ2EgVHlwZV9lcXVhbC5JZC50XG4gICAgICA7IGRlZmF1bHQgOiAnYVxuICAgICAgfVxuXG4gICAgbGV0IGNyZWF0ZSB+ZGVmYXVsdCB+bmFtZSBzZXhwX29mID1cbiAgICAgIHsgZGVmYXVsdDsga2V5ID0gVHlwZV9lcXVhbC5JZC5jcmVhdGUgfm5hbWUgc2V4cF9vZiB9XG4gICAgOztcblxuICAgIGxldCBpZCB0ID0gdC5rZXlcbiAgZW5kXG5cbiAgbGV0IGZpbmQgdCB7IEtleS5rZXk7IGRlZmF1bHQgfSA9IE9wdGlvbi52YWx1ZSB+ZGVmYXVsdCAoZmluZCB0IGtleSlcbiAgbGV0IHNldCB0IH5rZXk6eyBLZXkua2V5OyBkZWZhdWx0ID0gXyB9IH5kYXRhID0gc2V0IHQgfmtleSB+ZGF0YVxuICBsZXQgY2hhbmdlIHQga2V5IH5mOnVwZGF0ZSA9IHNldCB0IH5rZXkgfmRhdGE6KHVwZGF0ZSAoZmluZCB0IGtleSkpXG5lbmRcblxubW9kdWxlIFdpdGhfZm9sZCA9IHN0cnVjdFxuICBtb2R1bGUgS2V5ID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICAgIHsga2V5IDogJ2IgV2l0aF9kZWZhdWx0LktleS50XG4gICAgICA7IGYgOiAnYiAtPiAnYSAtPiAnYlxuICAgICAgfVxuXG4gICAgbGV0IGNyZWF0ZSB+aW5pdCB+ZiB+bmFtZSBzZXhwX29mID1cbiAgICAgIHsgZjsga2V5ID0gV2l0aF9kZWZhdWx0LktleS5jcmVhdGUgfmRlZmF1bHQ6aW5pdCB+bmFtZSBzZXhwX29mIH1cbiAgICA7O1xuXG4gICAgbGV0IGlkIHQgPSBXaXRoX2RlZmF1bHQuS2V5LmlkIHQua2V5XG4gIGVuZFxuXG4gIGxldCBmaW5kIHQgeyBLZXkua2V5OyBmID0gXyB9ID0gV2l0aF9kZWZhdWx0LmZpbmQgdCBrZXlcbiAgbGV0IHNldCB0IH5rZXk6eyBLZXkua2V5OyBmID0gXyB9IH5kYXRhID0gV2l0aF9kZWZhdWx0LnNldCB0IH5rZXkgfmRhdGFcbiAgbGV0IGNoYW5nZSB0IHsgS2V5LmtleTsgZiA9IF8gfSB+Zjp1cGRhdGUgPSBXaXRoX2RlZmF1bHQuY2hhbmdlIHQga2V5IH5mOnVwZGF0ZVxuXG4gIGxldCBhZGQgdCB+a2V5OnsgS2V5LmtleTsgZiB9IH5kYXRhID1cbiAgICBXaXRoX2RlZmF1bHQuY2hhbmdlIHQga2V5IH5mOihmdW4gYWNjIC0+IGYgYWNjIGRhdGEpXG4gIDs7XG5lbmRcblxubW9kdWxlIE11bHRpID0gc3RydWN0XG4gIG9wZW4gV2l0aF9mb2xkXG5cbiAgbW9kdWxlIEtleSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICgnYSwgJ2EgbGlzdCkgS2V5LnRcblxuICAgIGxldCBjcmVhdGUgfm5hbWUgc2V4cF9vZiA9XG4gICAgICBLZXkuY3JlYXRlIH5pbml0OltdIH5mOihmdW4geHMgeCAtPiB4IDo6IHhzKSB+bmFtZSAoTGlzdC5zZXhwX29mX3Qgc2V4cF9vZilcbiAgICA7O1xuXG4gICAgbGV0IGlkID0gV2l0aF9mb2xkLktleS5pZFxuICBlbmRcblxuICBsZXQgc2V0ID0gc2V0XG4gIGxldCBmaW5kID0gZmluZFxuICBsZXQgYWRkID0gYWRkXG4gIGxldCBjaGFuZ2UgPSBjaGFuZ2VcbmVuZFxuIl19
