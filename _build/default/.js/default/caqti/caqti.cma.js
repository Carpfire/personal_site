// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Caqti_type_sig
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Caqti_type_sig = [0];
   runtime.caml_register_global(0, Caqti_type_sig, "Caqti_type_sig");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_type
//# unitInfo: Requires: Ptime, Stdlib__Bool, Stdlib__Buffer, Stdlib__Float, Stdlib__Format, Stdlib__Int, Stdlib__Int32, Stdlib__Int64, Stdlib__String
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_S = "%S",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = " \xc3\x97 ",
    cst$0 = ", ",
    bool = [0, 0],
    int$0 = [0, 1],
    int16 = [0, 2],
    int32 = [0, 3],
    int64 = [0, 4],
    float$0 = [0, 5],
    string = [0, 6],
    octets = [0, 7],
    pdate = [0, 8],
    ptime = [0, 9],
    ptime_span = [0, 10],
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Ptime = global_data.Ptime,
    Stdlib_Bool = global_data.Stdlib__Bool,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Float = global_data.Stdlib__Float,
    Stdlib_String = global_data.Stdlib__String,
    Reject = [248, "Caqti_type.Reject", caml_fresh_oo_id(0)],
    _v_ = [0, 0],
    cst_option = " option",
    cst_unit = "unit",
    cst_redacted = " redacted",
    cst_Some = "Some ",
    cst_None = "None",
    cst_redacted$0 = "#redacted#",
    _u_ = [0, 0],
    cst_Serial = "Serial",
    _o_ = [0, [5, 0, 0, 0, [12, 108, 0]], "%ldl"],
    _p_ = [0, [7, 0, 0, 0, [12, 76, 0]], "%LdL"],
    _q_ = [0, [8, [0, 0, 5], 0, 0, 0], "%F"],
    _r_ = [0, [3, 0, 0], cst_S],
    _s_ = [0, [3, 0, 0], cst_S],
    _t_ =
      [0,
       [4,
        0,
        0,
        0,
        [12, 45, [4, 0, [0, 2, 2], 0, [12, 45, [4, 0, [0, 2, 2], 0, 0]]]]],
       "%d-%02d-%02d"],
    cst_bool = "bool",
    cst_int = "int",
    cst_int16 = "int16",
    cst_int32 = "int32",
    cst_int64 = "int64",
    cst_float = "float",
    cst_string = "string",
    cst_octets = "octets",
    cst_pdate = "pdate",
    cst_ptime = "ptime",
    cst_ptime_span = "ptime_span",
    _a_ = [0, 0],
    _b_ = [0, 0],
    _c_ = [0, 0],
    _d_ = [0, 0],
    _e_ = [0, 0],
    _f_ = [0, 0],
    _g_ = [0, 0],
    _h_ = [0, 0],
    _i_ = [0, 0],
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _n_ = [0, 0];
   function unify(ft1, ft2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            i:
            {
             j:
             {
              k:
              {
               l:
               {
                m:
                {
                 n:
                 {
                  o:
                  {
                   p:
                   {
                    if(typeof ft1 === "number"){
                     q:
                     {
                      r:
                      {
                       s:
                       {
                        t:
                        {
                         switch(ft1){
                           case 0:
                            if(typeof ft2 !== "number") break a;
                            if(ft2) break a;
                            return _a_;
                           case 1:
                            if(typeof ft2 !== "number") break q;
                            if(1 === ft2) return _b_;
                            if(ft2) break q;
                            break c;
                           case 2:
                            if(typeof ft2 !== "number") break q;
                            if(2 === ft2) return _c_;
                            if(3 <= ft2) break q;
                            break c;
                           case 3:
                            if(typeof ft2 === "number")
                             switch(ft2){
                               case 3:
                                return _d_;
                               case 2:
                                break f;
                               case 0:
                               case 1:
                                break c;
                               default: break r;
                             }
                            break r;
                           case 4:
                            if(typeof ft2 === "number")
                             switch(ft2){
                               case 4:
                                return _e_;
                               case 0:
                               case 1:
                                break c;
                               case 2:
                               case 3:
                                break f;
                               default: break r;
                             }
                            break r;
                           case 5:
                            if(typeof ft2 === "number")
                             switch(ft2){
                               case 5:
                                return _f_;
                               case 4:
                                break i;
                               case 0:
                               case 1:
                                break c;
                               case 2:
                               case 3:
                                break f;
                               default: break s;
                             }
                            break s;
                           case 6:
                            if(typeof ft2 === "number")
                             switch(ft2){
                               case 6:
                                return _g_;
                               case 0:
                               case 1:
                                break c;
                               case 2:
                               case 3:
                                break f;
                               case 4:
                               case 5:
                                break i;
                               default: break s;
                             }
                            break s;
                           case 7:
                            if(typeof ft2 === "number")
                             switch(ft2){
                               case 7:
                                return _h_;
                               case 6:
                                break l;
                               case 0:
                               case 1:
                                break c;
                               case 2:
                               case 3:
                                break f;
                               case 4:
                               case 5:
                                break i;
                               default: break t;
                             }
                            break t;
                           case 8:
                            if(typeof ft2 === "number")
                             switch(ft2){
                               case 8:
                                return _i_;
                               case 0:
                               case 1:
                                break c;
                               case 2:
                               case 3:
                                break f;
                               case 4:
                               case 5:
                                break i;
                               case 6:
                               case 7:
                                break l;
                               default: break t;
                             }
                            break t;
                           case 9:
                            if(typeof ft2 === "number")
                             switch(ft2){
                               case 9:
                                return _j_;
                               case 8:
                                break o;
                               case 10: break;
                               case 0:
                               case 1:
                                break c;
                               case 2:
                               case 3:
                                break f;
                               case 4:
                               case 5:
                                break i;
                               default: break l;
                             }
                            break;
                           default:
                            if(typeof ft2 === "number")
                             switch(ft2){
                               case 10:
                                return _k_;
                               case 0:
                               case 1:
                                break c;
                               case 2:
                               case 3:
                                break f;
                               case 4:
                               case 5:
                                break i;
                               case 6:
                               case 7:
                                break l;
                               default: break o;
                             }
                         }
                         if(typeof ft1 !== "number") break n;
                         if(10 === ft1) break p;
                         break n;
                        }
                        if(typeof ft1 !== "number") break k;
                        if(8 === ft1) break m;
                        break k;
                       }
                       if(typeof ft1 !== "number") break h;
                       if(6 === ft1) break j;
                       break h;
                      }
                      if(typeof ft1 !== "number") break e;
                      if(4 === ft1) break g;
                      break e;
                     }
                     if(typeof ft1 !== "number") break b;
                     if(2 === ft1) break d;
                     break b;
                    }
                    var name1 = ft1[1];
                    if(typeof ft2 !== "number"){
                     var name2 = ft2[1];
                     return runtime.caml_string_equal(name1, name2) ? _l_ : 0;
                    }
                    switch(ft2){
                      case 10: break;
                      case 0:
                      case 1:
                       break c;
                      case 2:
                      case 3:
                       break f;
                      case 4:
                      case 5:
                       break i;
                      case 6:
                      case 7:
                       break l;
                      default: break o;
                    }
                   }
                   return 0;
                  }
                  if(typeof ft2 !== "number" || 9 !== ft2) break m;
                 }
                 return 0;
                }
                return 0;
               }
               if(typeof ft2 !== "number" || 7 !== ft2) break j;
              }
              return 0;
             }
             return 0;
            }
            if(typeof ft2 !== "number" || 5 !== ft2) break g;
           }
           return 0;
          }
          return 0;
         }
         if(typeof ft2 !== "number" || 3 !== ft2) break d;
        }
        return 0;
       }
       return 0;
      }
      if(typeof ft2 !== "number" || 1 !== ft2) break a;
     }
     return 0;
    }
    return 0;
   }
   function equal_value(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return Stdlib_Bool[2];
       case 1:
        return Stdlib_Int[8];
       case 2:
        return Stdlib_Int[8];
       case 3:
        return Stdlib_Int32[17];
       case 4:
        return Stdlib_Int64[17];
       case 5:
        return Stdlib_Float[22];
       case 6:
        return Stdlib_String[9];
       case 7:
        return Stdlib_String[9];
       case 8:
        return Ptime[13];
       case 9:
        return Ptime[13];
       default: return Ptime[1][11];
     }
    return Stdlib_String[9];
   }
   function to_string(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return cst_bool;
       case 1:
        return cst_int;
       case 2:
        return cst_int16;
       case 3:
        return cst_int32;
       case 4:
        return cst_int64;
       case 5:
        return cst_float;
       case 6:
        return cst_string;
       case 7:
        return cst_octets;
       case 8:
        return cst_pdate;
       case 9:
        return cst_ptime;
       default: return cst_ptime_span;
     }
    var name = param[1];
    return name;
   }
   function pp(ppf, ft){
    var _aU_ = to_string(ft);
    return caml_call2(Stdlib_Format[13], ppf, _aU_);
   }
   var pp_ptime = caml_call4(Ptime[33], _n_, 0, _m_, 0);
   function pp_value(ppf, param){
    var _aT_ = param[1];
    if(typeof _aT_ === "number")
     switch(_aT_){
       case 0:
        var x = param[2]; return caml_call2(Stdlib_Format[25], ppf, x);
       case 1:
        var x$0 = param[2]; return caml_call2(Stdlib_Format[19], ppf, x$0);
       case 2:
        var x$1 = param[2]; return caml_call2(Stdlib_Format[19], ppf, x$1);
       case 3:
        var x$2 = param[2];
        return caml_call3(Stdlib_Format[137], ppf, _o_, x$2);
       case 4:
        var x$3 = param[2];
        return caml_call3(Stdlib_Format[137], ppf, _p_, x$3);
       case 5:
        var x$4 = param[2];
        return caml_call3(Stdlib_Format[137], ppf, _q_, x$4);
       case 6:
        var x$5 = param[2];
        return caml_call3(Stdlib_Format[137], ppf, _r_, x$5);
       case 7:
        var x$6 = param[2];
        return caml_call3(Stdlib_Format[137], ppf, _s_, x$6);
       case 8:
        var
         x$7 = param[2],
         match = caml_call2(Ptime[23], 0, x$7),
         d = match[3],
         m = match[2],
         y = match[1];
        return caml_call5(Stdlib_Format[137], ppf, _t_, y, m, d);
       case 9:
        var x$8 = param[2]; return caml_call2(pp_ptime, ppf, x$8);
       default: var x$9 = param[2]; return caml_call2(Ptime[1][19], ppf, x$9);
     }
    var x$10 = param[2];
    return caml_call2(Stdlib_Format[13], ppf, x$10);
   }
   function unify$0(t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     a:
     {
      b:
      {
       c:
       {
        d:
        {
         switch(t1$0[0]){
           case 0:
            var ft1 = t1$0[1];
            if(0 !== t2$0[0]) break a;
            var ft2 = t2$0[1];
            return unify(ft1, ft2);
           case 1:
            var t1$1 = t1$0[1];
            switch(t2$0[0]){
              case 0:
               break c;
              case 1:
               var t2$1 = t2$0[1]; return unify$0(t1$1, t2$1) ? _v_ : 0;
            }
            break;
           case 2:
            var id1 = t1$0[1];
            switch(t2$0[0]){
              case 2:
               var id2 = t2$0[1], serial = id2[1], is_serial = id1[2];
               return caml_call1(is_serial, serial);
              case 3: break;
              default: break c;
            }
            break;
           default:
            var t1$2 = t1$0[2];
            switch(t2$0[0]){
              case 2:
               break d;
              case 3:
               var t2$2 = t2$0[2], t1$0 = t1$2, t2$0 = t2$2; continue;
              default: break c;
            }
         }
         if(2 !== t1$0[0]) break b;
        }
        return 0;
       }
       if(1 !== t2$0[0]) break a;
      }
      return 0;
     }
     return 0;
    }
   }
   function equal_value$0(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var ft = param$0[1]; return equal_value(ft);
       case 1:
        var t = param$0[1], f = equal_value$0(t);
        return function(x$0, y$0){
         if(x$0){
          if(y$0){var y = y$0[1], x = x$0[1]; return caml_call2(f, x, y);}
         }
         else if(! y$0) return 1;
         return 0;};
       case 2:
        var prod = param$0[3]; return equal_value_prod(prod);
       default: var t$0 = param$0[2], param$0 = t$0;
     }
   }
   function equal_value_prod(param){
    if(! param) return function(param, _aS_){return 1;};
    var
     prod = param[3],
     p = param[2],
     t = param[1],
     eq_first = equal_value$0(t),
     eq_rest = equal_value_prod(prod);
    return function(x, y){
     var
      _aQ_ = caml_call1(p, y),
      _aR_ = caml_call2(eq_first, caml_call1(p, x), _aQ_);
     return _aR_ ? eq_rest(x, y) : _aR_;};
   }
   function length(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        return 1;
       case 1:
        var t = param$0[1], param$0 = t; break;
       case 2:
        var
         prod = param$0[3],
         loop =
           function(param){
            if(! param) return function(_aP_){return _aP_;};
            var prod = param[3], t = param[1];
            return function(n){
             var _aO_ = n + length(t) | 0;
             return loop(prod)(_aO_);};
           };
        return loop(prod)(0);
       default: var t$0 = param$0[2], param$0 = t$0;
     }
   }
   function pp_at(prec, ppf, param){
    switch(param[0]){
      case 0:
       var ft = param[1], _aM_ = to_string(ft);
       return caml_call2(Stdlib_Format[13], ppf, _aM_);
      case 1:
       var t = param[1];
       pp_at(1, ppf, t);
       return caml_call2(Stdlib_Format[13], ppf, cst_option);
      case 2:
       var match = param[3];
       if(! match) return caml_call2(Stdlib_Format[13], ppf, cst_unit);
       var prod = match[3], t0 = match[1];
       if(0 < prec) caml_call2(Stdlib_Format[23], ppf, 40);
       pp_at(1, ppf, t0);
       var param$0 = prod;
       for(;;){
        if(! param$0){
         var _aN_ = 0 < prec ? 1 : 0;
         return _aN_ ? caml_call2(Stdlib_Format[23], ppf, 41) : _aN_;
        }
        var prod$0 = param$0[3], t$0 = param$0[1];
        caml_call2(Stdlib_Format[13], ppf, cst);
        pp_at(1, ppf, t$0);
        var param$0 = prod$0;
       }
       break;
      default:
       var t$1 = param[2];
       pp_at(1, ppf, t$1);
       return caml_call2(Stdlib_Format[13], ppf, cst_redacted);
    }
   }
   function pp$0(ppf){
    var _aK_ = 0;
    return function(_aL_){return pp_at(_aK_, ppf, _aL_);};
   }
   function pp_any(ppf, param){var t = param[1]; return pp_at(0, ppf, t);}
   function pp_value$0(ppf, param){
    var param$0 = param;
    for(;;){
     var match = param$0[1];
     switch(match[0]){
       case 0:
        var fv = param$0[2], ft = match[1]; return pp_value(ppf, [0, ft, fv]);
       case 1:
        var match$0 = param$0[2], t = match[1];
        if(! match$0) return caml_call2(Stdlib_Format[13], ppf, cst_None);
        var x = match$0[1];
        caml_call2(Stdlib_Format[13], ppf, cst_Some);
        var param$0 = [0, t, x];
        break;
       case 2:
        var x$0 = param$0[2], prod = match[3], i = 0, param$1 = prod;
        for(;;){
         if(! param$1) return 0;
         var prod$0 = param$1[3], p = param$1[2], t$0 = param$1[1];
         if(0 < i) caml_call2(Stdlib_Format[13], ppf, cst$0);
         pp_value$0(ppf, [0, t$0, caml_call1(p, x$0)]);
         var i$0 = i + 1 | 0, i = i$0, param$1 = prod$0;
        }
        break;
       default: return caml_call2(Stdlib_Format[13], ppf, cst_redacted$0);
     }
    }
   }
   function show(t){
    var
     buf = caml_call1(Stdlib_Buffer[1], 64),
     ppf = caml_call1(Stdlib_Format[114], buf);
    pp$0(ppf)(t);
    caml_call2(Stdlib_Format[38], ppf, 0);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function field(ft){return [0, ft];}
   function option(t){return [1, t];}
   function product(intro, prod){
    var Serial = [248, cst_Serial, caml_fresh_oo_id(0)];
    function is_serial(param){return param === Serial ? _u_ : 0;}
    return [2, [0, Serial, is_serial], intro, prod];
   }
   function proj(t, p, prod){return [0, t, p, prod];}
   var unit = product(0, 0), proj_end = 0;
   function tup2(t1, t2){
    function intro(x1, x2){return [0, x1, x2];}
    var _aH_ = [0, t2, function(_aJ_){return _aJ_[2];}, proj_end];
    return product(intro, [0, t1, function(_aI_){return _aI_[1];}, _aH_]);
   }
   function tup3(t1, t2, t3){
    function intro(x1, x2, x3){return [0, x1, x2, x3];}
    var
     _aG_ = [0, t3, function(param){var x = param[3]; return x;}, proj_end],
     _aF_ = [0, t2, function(param){var x = param[2]; return x;}, _aG_];
    return product
            (intro,
             [0, t1, function(param){var x = param[1]; return x;}, _aF_]);
   }
   function tup4(t1, t2, t3, t4){
    function intro(x1, x2, x3, x4){return [0, x1, x2, x3, x4];}
    var
     _aE_ = [0, t4, function(param){var x = param[4]; return x;}, proj_end],
     _aD_ = [0, t3, function(param){var x = param[3]; return x;}, _aE_],
     _aC_ = [0, t2, function(param){var x = param[2]; return x;}, _aD_];
    return product
            (intro,
             [0, t1, function(param){var x = param[1]; return x;}, _aC_]);
   }
   function t5(t1, t2, t3, t4, t5){
    function intro(x1, x2, x3, x4, x5){return [0, x1, x2, x3, x4, x5];}
    var
     _aB_ = [0, t5, function(param){var x = param[5]; return x;}, proj_end],
     _aA_ = [0, t4, function(param){var x = param[4]; return x;}, _aB_],
     _az_ = [0, t3, function(param){var x = param[3]; return x;}, _aA_],
     _ay_ = [0, t2, function(param){var x = param[2]; return x;}, _az_];
    return product
            (intro,
             [0, t1, function(param){var x = param[1]; return x;}, _ay_]);
   }
   function t6(t1, t2, t3, t4, t5, t6){
    function intro(x1, x2, x3, x4, x5, x6){return [0, x1, x2, x3, x4, x5, x6];
    }
    var
     _ax_ = [0, t6, function(param){var x = param[6]; return x;}, proj_end],
     _aw_ = [0, t5, function(param){var x = param[5]; return x;}, _ax_],
     _av_ = [0, t4, function(param){var x = param[4]; return x;}, _aw_],
     _au_ = [0, t3, function(param){var x = param[3]; return x;}, _av_],
     _at_ = [0, t2, function(param){var x = param[2]; return x;}, _au_];
    return product
            (intro,
             [0, t1, function(param){var x = param[1]; return x;}, _at_]);
   }
   function t7(t1, t2, t3, t4, t5, t6, t7){
    function intro(x1, x2, x3, x4, x5, x6, x7){return [0, x1, x2, x3, x4, x5, x6, x7];
    }
    var
     _as_ = [0, t7, function(param){var x = param[7]; return x;}, proj_end],
     _ar_ = [0, t6, function(param){var x = param[6]; return x;}, _as_],
     _aq_ = [0, t5, function(param){var x = param[5]; return x;}, _ar_],
     _ap_ = [0, t4, function(param){var x = param[4]; return x;}, _aq_],
     _ao_ = [0, t3, function(param){var x = param[3]; return x;}, _ap_],
     _an_ = [0, t2, function(param){var x = param[2]; return x;}, _ao_];
    return product
            (intro,
             [0, t1, function(param){var x = param[1]; return x;}, _an_]);
   }
   function t8(t1, t2, t3, t4, t5, t6, t7, t8){
    function intro(x1, x2, x3, x4, x5, x6, x7, x8){return [0, x1, x2, x3, x4, x5, x6, x7, x8];
    }
    var
     _am_ = [0, t8, function(param){var x = param[8]; return x;}, proj_end],
     _al_ = [0, t7, function(param){var x = param[7]; return x;}, _am_],
     _ak_ = [0, t6, function(param){var x = param[6]; return x;}, _al_],
     _aj_ = [0, t5, function(param){var x = param[5]; return x;}, _ak_],
     _ai_ = [0, t4, function(param){var x = param[4]; return x;}, _aj_],
     _ah_ = [0, t3, function(param){var x = param[3]; return x;}, _ai_],
     _ag_ = [0, t2, function(param){var x = param[2]; return x;}, _ah_];
    return product
            (intro,
             [0, t1, function(param){var x = param[1]; return x;}, _ag_]);
   }
   function t9(t1, t2, t3, t4, t5, t6, t7, t8, t9){
    function intro(x1, x2, x3, x4, x5, x6, x7, x8, x9){return [0, x1, x2, x3, x4, x5, x6, x7, x8, x9];
    }
    var
     _af_ = [0, t9, function(param){var x = param[9]; return x;}, proj_end],
     _ae_ = [0, t8, function(param){var x = param[8]; return x;}, _af_],
     _ad_ = [0, t7, function(param){var x = param[7]; return x;}, _ae_],
     _ac_ = [0, t6, function(param){var x = param[6]; return x;}, _ad_],
     _ab_ = [0, t5, function(param){var x = param[5]; return x;}, _ac_],
     _aa_ = [0, t4, function(param){var x = param[4]; return x;}, _ab_],
     _$_ = [0, t3, function(param){var x = param[3]; return x;}, _aa_],
     ___ = [0, t2, function(param){var x = param[2]; return x;}, _$_];
    return product
            (intro,
             [0, t1, function(param){var x = param[1]; return x;}, ___]);
   }
   function t10(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10){
    function intro(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10){return [0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10];
    }
    var
     _Z_ = [0, t10, function(param){var x = param[10]; return x;}, proj_end],
     _Y_ = [0, t9, function(param){var x = param[9]; return x;}, _Z_],
     _X_ = [0, t8, function(param){var x = param[8]; return x;}, _Y_],
     _W_ = [0, t7, function(param){var x = param[7]; return x;}, _X_],
     _V_ = [0, t6, function(param){var x = param[6]; return x;}, _W_],
     _U_ = [0, t5, function(param){var x = param[5]; return x;}, _V_],
     _T_ = [0, t4, function(param){var x = param[4]; return x;}, _U_],
     _S_ = [0, t3, function(param){var x = param[3]; return x;}, _T_],
     _R_ = [0, t2, function(param){var x = param[2]; return x;}, _S_];
    return product
            (intro,
             [0, t1, function(param){var x = param[1]; return x;}, _R_]);
   }
   function t11(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11){
    function intro(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11){return [0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11];
    }
    var
     _Q_ = [0, t11, function(param){var x = param[11]; return x;}, proj_end],
     _P_ = [0, t10, function(param){var x = param[10]; return x;}, _Q_],
     _O_ = [0, t9, function(param){var x = param[9]; return x;}, _P_],
     _N_ = [0, t8, function(param){var x = param[8]; return x;}, _O_],
     _M_ = [0, t7, function(param){var x = param[7]; return x;}, _N_],
     _L_ = [0, t6, function(param){var x = param[6]; return x;}, _M_],
     _K_ = [0, t5, function(param){var x = param[5]; return x;}, _L_],
     _J_ = [0, t4, function(param){var x = param[4]; return x;}, _K_],
     _I_ = [0, t3, function(param){var x = param[3]; return x;}, _J_],
     _H_ = [0, t2, function(param){var x = param[2]; return x;}, _I_];
    return product
            (intro,
             [0, t1, function(param){var x = param[1]; return x;}, _H_]);
   }
   function t12(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12){
    function intro(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12){return [0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12];
    }
    var
     _G_ = [0, t12, function(param){var x = param[12]; return x;}, proj_end],
     _F_ = [0, t11, function(param){var x = param[11]; return x;}, _G_],
     _E_ = [0, t10, function(param){var x = param[10]; return x;}, _F_],
     _D_ = [0, t9, function(param){var x = param[9]; return x;}, _E_],
     _C_ = [0, t8, function(param){var x = param[8]; return x;}, _D_],
     _B_ = [0, t7, function(param){var x = param[7]; return x;}, _C_],
     _A_ = [0, t6, function(param){var x = param[6]; return x;}, _B_],
     _z_ = [0, t5, function(param){var x = param[5]; return x;}, _A_],
     _y_ = [0, t4, function(param){var x = param[4]; return x;}, _z_],
     _x_ = [0, t3, function(param){var x = param[3]; return x;}, _y_],
     _w_ = [0, t2, function(param){var x = param[2]; return x;}, _x_];
    return product
            (intro,
             [0, t1, function(param){var x = param[1]; return x;}, _w_]);
   }
   function custom(encode, decode, rep){
    function encode$0(x){
     var match = caml_call1(encode, x);
     if(0 === match[0]){var y = match[1]; return y;}
     var msg = match[1];
     throw caml_maybe_attach_backtrace([0, Reject, msg], 1);
    }
    function decode$0(y){
     var match = caml_call1(decode, y);
     if(0 === match[0]){var x = match[1]; return x;}
     var msg = match[1];
     throw caml_maybe_attach_backtrace([0, Reject, msg], 1);
    }
    return product(decode$0, [0, rep, encode$0, proj_end]);
   }
   function redacted(t){return [3, -780714144, t];}
   function enum$0(encode, decode, name){
    function decode$0(y){
     var match = caml_call1(decode, y);
     if(0 === match[0]){var x = match[1]; return x;}
     var msg = match[1];
     throw caml_maybe_attach_backtrace([0, Reject, msg], 1);
    }
    return product(decode$0, [0, [0, [0, name]], encode, proj_end]);
   }
   var
    Caqti_type =
      [0,
       Reject,
       [0, unify, equal_value, to_string, pp, pp_value],
       unify$0,
       equal_value$0,
       length,
       pp$0,
       pp_any,
       pp_value$0,
       show,
       field,
       [0,
        bool,
        int$0,
        int16,
        int32,
        int64,
        float$0,
        string,
        octets,
        pdate,
        ptime,
        ptime_span,
        enum$0,
        product,
        proj,
        proj_end,
        custom,
        option,
        redacted,
        unit,
        tup2,
        tup3,
        tup4,
        t5,
        t6,
        t7,
        t8,
        t9,
        t10,
        t11,
        t12,
        tup2,
        tup3,
        tup4],
       bool,
       int$0,
       int16,
       int32,
       int64,
       float$0,
       string,
       octets,
       pdate,
       ptime,
       ptime_span,
       enum$0,
       product,
       proj,
       proj_end,
       custom,
       option,
       redacted,
       unit,
       tup2,
       tup3,
       tup4,
       t5,
       t6,
       t7,
       t8,
       t9,
       t10,
       t11,
       t12,
       tup2,
       tup3,
       tup4];
   runtime.caml_register_global(63, Caqti_type, "Caqti_type");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_switch_sig
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Caqti_switch_sig = [0];
   runtime.caml_register_global(0, Caqti_switch_sig, "Caqti_switch_sig");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_stream_sig
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Caqti_stream_sig = [0];
   runtime.caml_register_global(0, Caqti_stream_sig, "Caqti_stream_sig");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_query
//# unitInfo: Requires: Angstrom, Bigstringaf, Caqti_type, Stdlib, Stdlib__Buffer, Stdlib__Format, Stdlib__Hashtbl, Stdlib__Int, Stdlib__List, Stdlib__Printf, Stdlib__String
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$15 = "",
    cst$16 = "$$",
    cst$14 = "$(",
    cst$17 = ".",
    cst_E$0 = "E",
    cst_Q = "Q",
    cst_caqti_lib_caqti_query_ml = "caqti/lib/caqti_query.ml",
    cst_unterminated$1 = "unterminated",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = "\\'",
    cst$0 = "\\\\",
    cst$13 = cst$15,
    cst$12 = cst$15,
    cst$10 = cst$15,
    cst$11 = cst$15,
    cst$9 = cst$15,
    cst = cst$15,
    cst$2 = "''",
    cst$3 = '""',
    cst$4 = "$.",
    cst$5 = cst$14,
    cst$6 = cst$16,
    cst$7 = cst$16,
    cst$8 = "--",
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Caqti_type = global_data.Caqti_type,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom = global_data.Angstrom,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    cst_E = "E'",
    cst_t = "\\t",
    cst_n = "\\n",
    cst_r = "\\r",
    _d_ = [0, [11, "\\x", [4, 6, [0, 2, 2], 0, 0]], "\\x%02x"],
    _e_ = [0, [11, cst$14, [2, 0, [12, 41, 0]]], "$(%s)"],
    cst_invalid_nesting_of_query_t =
      "invalid nesting of query tags; did you forget a `@}`?",
    _aT_ = [0, cst_caqti_lib_caqti_query_ml, 389, 64],
    _aS_ = [0, cst_caqti_lib_caqti_query_ml, 384, 53],
    cst_SQL_FRAGMENT = "... SQL FRAGMENT ...",
    _aR_ =
      [0,
       [11, "Parse error at byte ", [4, 0, 0, 0, [11, ": ", [2, 0, 0]]]],
       "Parse error at byte %d: %s"],
    cst_Expression_cannot_contain_ = "Expression cannot contain semicolon.",
    _aQ_ = [0, cst_caqti_lib_caqti_query_ml, 318, 6],
    cst_unterminated$0 = cst_unterminated$1,
    cst_unterminated = cst_unterminated$1,
    cst_Inconsistent_parameter_sty = "Inconsistent parameter style.",
    _ar_ = [0, ";"],
    _ap_ = [3, -1],
    cst_is_not_allowed_after_param =
      "':' is not allowed after parameter reference '?'",
    _ao_ =
      [0,
       [1, [11, " is not allowed after parameter reference '?'", 0]],
       "%C is not allowed after parameter reference '?'"],
    _an_ = [0, "invalid dollar sequence"],
    _af_ = [0, [0, cst$16], 0],
    _ag_ = [0, [0, cst$16], 0],
    _R_ = [4, cst$17],
    _w_ = [0, [1, [11, " is not valid here", 0]], "%C is not valid here"],
    _h_ = [0, [0, cst$17], 0],
    _f_ =
      [0,
       [11, "Undefined variable ", [2, 0, [11, " in query ", [15, 0]]]],
       "Undefined variable %s in query %a"],
    _g_ =
      [0,
       [11,
        "While expanding ",
        [15,
         [11,
          ", lookup of ",
          [2,
           0,
           [11,
            " gives ",
            [15,
             [11,
              ", which is invalid because it contains an environment or parameter reference.",
              0]]]]]]],
       "While expanding %a, lookup of %s gives %a, which is invalid because it contains an environment or parameter reference."],
    _c_ = [5, 0],
    _b_ = [0, "NULL"],
    _a_ = [5, 0],
    cst_Caqti_query_Expand_error = "Caqti_query.Expand_error",
    ___ = [0, "invalid environment lookup"],
    cst_Caqti_query_Stag_query = "Caqti_query.Stag_query";
   function concat(sep, param$0){
    if(! param$0) return _a_;
    var
     qs$0 = param$0[2],
     q$0 = param$0[1],
     pfx = [0, sep],
     acc = 0,
     param = caml_call1(Stdlib_List[10], qs$0);
    for(;;){
     if(! param) return [5, [0, q$0, acc]];
     var
      qs = param[2],
      q = param[1],
      acc$0 = [0, pfx, [0, q, acc]],
      acc = acc$0,
      param = qs;
    }
   }
   function bool(x){return [1, 0, x];}
   function int$0(x){return [1, 1, x];}
   function float$0(x){return [1, 5, x];}
   function string(x){return [1, 6, x];}
   function octets(x){return [1, 7, x];}
   function pdate(x){return [1, 8, x];}
   function ptime(x){return [1, 9, x];}
   function ptime_span(x){return [1, 10, x];}
   function const_fields(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var ft = param$0[1]; return function(x){return [0, [1, ft, x], 0];};
       case 1:
        var t = param$0[1];
        return function(param){
         if(param){var x = param[1]; return const_fields(t)(x);}
         function _bY_(param){return _b_;}
         var _bZ_ = caml_call1(Caqti_type[5], t);
         return caml_call2(Stdlib_List[11], _bZ_, _bY_);};
       case 2:
        var pt = param$0[3]; return const_fields_product(pt);
       default: var t$0 = param$0[2], param$0 = t$0;
     }
   }
   function const_fields_product(param){
    if(! param) return function(param){return 0;};
    var pt = param[3], p = param[2], t = param[1];
    return function(x){
     var
      _bV_ = const_fields_product(pt)(x),
      _bW_ = caml_call1(p, x),
      _bX_ = const_fields(t)(_bW_);
     return caml_call2(Stdlib[37], _bX_, _bV_);};
   }
   function normal(q$2){
    var acc = 0, param = [0, q$2, 0];
    for(;;){
     if(! param){
      var qs$4 = caml_call1(Stdlib_List[10], acc);
      if(! qs$4) return _c_;
      if(qs$4[2]) return [5, qs$4];
      var q$3 = qs$4[1];
      return q$3;
     }
     var q = param[1];
     switch(q[0]){
       case 0:
        var s = q[1];
        if(caml_string_notequal(s, cst$15)){
         var qs = param[2], accL = [0, s, 0];
         a:
         {
          var accL$0 = accL, qs$5 = qs;
          b:
          for(;;){
           if(! qs$5) break a;
           var _bT_ = qs$5[1];
           switch(_bT_[0]){
             case 0:
              var s$0 = _bT_[1];
              if(caml_string_notequal(s$0, cst$15)){
               var
                qs$6 = qs$5[2],
                accL$1 = [0, s$0, accL$0],
                accL$0 = accL$1,
                qs$5 = qs$6;
               continue;
              }
              break;
             case 5:
              var match$0 = _bT_[1];
              if(match$0){
               var
                qs$8 = qs$5[2],
                qs$9 = match$0[2],
                q$1 = match$0[1],
                qs$10 = [0, q$1, [0, [5, qs$9], qs$8]],
                qs$5 = qs$10;
               continue;
              }
              break;
             default: break b;
           }
           var qs$7 = qs$5[2], qs$5 = qs$7;
          }
         }
         var
          _bU_ = caml_call1(Stdlib_List[10], accL$0),
          acc$1 = [0, [0, caml_call2(Stdlib_String[7], cst, _bU_)], acc],
          acc = acc$1,
          param = qs$5;
         continue;
        }
        break;
       case 5:
        var match = q[1];
        if(match){
         var
          qs$2 = param[2],
          qs$3 = match[2],
          q$0 = match[1],
          param = [0, q$0, [0, [5, qs$3], qs$2]];
         continue;
        }
        break;
       default:
        var qs$1 = param[2], acc$0 = [0, q, acc], acc = acc$0, param = qs$1;
        continue;
     }
     var qs$0 = param[2], param = qs$0;
    }
   }
   function equal(t1, t2){
    switch(t1[0]){
      case 0:
       var s1 = t1[1];
       if(0 !== t2[0]) return 0;
       var s2 = t2[1];
       return caml_call2(Stdlib_String[9], s1, s2);
      case 1:
       var t1$0 = t1[1];
       if(1 !== t2[0]) return 0;
       var v2 = t2[2], t2$0 = t2[1], v1 = t1[2];
       return caml_call2(Caqti_type[2][1], t1$0, t2$0)
               ? caml_call3(Caqti_type[2][2], t1$0, v1, v2)
               : 0;
      case 2:
       var s1$0 = t1[1];
       if(2 !== t2[0]) return 0;
       var s2$0 = t2[1];
       return caml_call2(Stdlib_String[9], s1$0, s2$0);
      case 3:
       var i1 = t1[1];
       if(3 !== t2[0]) return 0;
       var i2 = t2[1];
       return caml_call2(Stdlib_Int[8], i1, i2);
      case 4:
       var n1 = t1[1];
       if(4 !== t2[0]) return 0;
       var n2 = t2[1];
       return caml_call2(Stdlib_String[9], n1, n2);
      default:
       var ts1 = t1[1];
       if(5 !== t2[0]) return 0;
       var ts2 = t2[1], xs = ts1, ys = ts2;
       for(;;){
        if(xs){
         if(ys){
          var
           ys$0 = ys[2],
           y = ys[1],
           xs$0 = xs[2],
           x = xs[1],
           _bS_ = equal(x, y);
          if(! _bS_) return _bS_;
          var xs = xs$0, ys = ys$0;
          continue;
         }
        }
        else if(! ys) return 1;
        return 0;
       }
    }
   }
   var hash = Stdlib_Hashtbl[28];
   function pp(ppf, param){
    switch(param[0]){
      case 0:
       var s = param[1]; return caml_call2(Stdlib_Format[13], ppf, s);
      case 1:
       var v = param[2], t = param[1];
       return caml_call2(Caqti_type[2][5], ppf, [0, t, v]);
      case 2:
       var s$0 = param[1];
       caml_call2(Stdlib_Format[13], ppf, cst_E);
       var _bN_ = caml_ml_string_length(s$0) - 1 | 0, _bM_ = 0;
       if(_bN_ >= 0){
        var i = _bM_;
        for(;;){
         var c = caml_string_get(s$0, i);
         a:
         {
          b:
          {
           if(39 > c){
            c:
            if(14 <= c){
             if(32 <= c) break b;
            }
            else if(9 <= c){
             switch(c - 9 | 0){
               case 0:
                caml_call2(Stdlib_Format[13], ppf, cst_t); break;
               case 1:
                caml_call2(Stdlib_Format[13], ppf, cst_n); break;
               case 4:
                caml_call2(Stdlib_Format[13], ppf, cst_r); break;
               default: break c;
             }
             break a;
            }
            caml_call3(Stdlib_Format[137], ppf, _d_, c);
            break a;
           }
           if(92 === c){caml_call2(Stdlib_Format[13], ppf, cst$0); break a;}
           if(40 > c){caml_call2(Stdlib_Format[13], ppf, cst$1); break a;}
          }
          var _bP_ = caml_string_get(s$0, i);
          caml_call2(Stdlib_Format[23], ppf, _bP_);
         }
         var _bO_ = i + 1 | 0;
         if(_bN_ === i) break;
         var i = _bO_;
        }
       }
       return caml_call2(Stdlib_Format[23], ppf, 39);
      case 3:
       var n = param[1];
       caml_call2(Stdlib_Format[23], ppf, 36);
       return caml_call2(Stdlib_Format[19], ppf, n + 1 | 0);
      case 4:
       var n$0 = param[1];
       return caml_call3(Stdlib_Format[137], ppf, _e_, n$0);
      default:
       var qs = param[1], _bQ_ = function(_bR_){return pp(ppf, _bR_);};
       return caml_call2(Stdlib_List[18], _bQ_, qs);
    }
   }
   function show(q){
    var
     buf = caml_call1(Stdlib_Buffer[1], 512),
     ppf = caml_call1(Stdlib_Format[114], buf);
    pp(ppf, q);
    caml_call2(Stdlib_Format[38], ppf, 0);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function pp_expand_error(ppf, param){
    var reason = param[3], var$0 = param[2], query = param[1];
    if(typeof reason === "number")
     return caml_call5(Stdlib_Format[137], ppf, _f_, var$0, pp, query);
    var expansion = reason[2];
    return caml_call7
            (Stdlib_Format[137], ppf, _g_, pp, query, var$0, pp, expansion);
   }
   var
    Expand_error = [248, cst_Caqti_query_Expand_error, caml_fresh_oo_id(0)];
   function expand(opt, f, query){
    if(opt) var sth = opt[1], final$0 = sth; else var final$0 = 0;
    function is_valid(param){
     switch(param[0]){
       case 5:
        var qs = param[1]; return caml_call2(Stdlib_List[33], is_valid, qs);
       case 3:
       case 4:
        return 0;
       default: return 1;
     }
    }
    function recurse(q){
     switch(q[0]){
       case 4:
        var
         var$0 = q[1],
         not_found =
           function(param){
            if(final$0)
             throw caml_maybe_attach_backtrace
                    ([0, Expand_error, [0, query, var$0, 1054678640]], 1);
            return q;
           };
        try{var q$1 = caml_call1(f, var$0);}
        catch(_bK_){
         var _bI_ = caml_wrap_exception(_bK_);
         if(_bI_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_bI_, 0);
         var l = caml_ml_string_length(var$0);
         if(0 < l && 46 === caml_string_get(var$0, l - 1 | 0)){
          try{
           var
            q$0 =
              normal
               (caml_call1
                 (f, caml_call3(Stdlib_String[16], var$0, 0, l - 1 | 0)));
          }
          catch(_bL_){
           var _bJ_ = caml_wrap_exception(_bL_);
           if(_bJ_ === Stdlib[8]) return not_found(0);
           throw caml_maybe_attach_backtrace(_bJ_, 0);
          }
          if(5 === q$0[0] && ! q$0[1]) return q$0;
          return [5, [0, q$0, _h_]];
         }
         return not_found(0);
        }
        if(is_valid(q$1)) return q$1;
        throw caml_maybe_attach_backtrace
               ([0, Expand_error, [0, query, var$0, [0, 144245463, q$1]]], 1);
       case 5:
        var qs = q[1]; return [5, caml_call2(Stdlib_List[20], recurse, qs)];
       default: return q;
     }
    }
    return recurse(query);
   }
   var failf = caml_call1(Stdlib_Printf[10], Angstrom[52]);
   function ign(p){
    function _bH_(param){return 0;}
    return caml_call2(Angstrom[55], p, _bH_);
   }
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function is_digit_nz(param){return 8 < param - 49 >>> 0 ? 0 : 1;}
   function is_idrfst(param){
    var _bG_ = param - 91 | 0;
    a:
    {
     if(5 < _bG_ >>> 0){
      if(57 < _bG_ + 26 >>> 0) break a;
     }
     else if(4 !== _bG_) break a;
     return 1;
    }
    return 0;
   }
   function is_idrcnt(param){
    a:
    {
     if(91 <= param){
      if(97 <= param){if(123 > param) break a;} else if(95 === param) break a;
     }
     else
      if(58 <= param){if(65 <= param) break a;} else if(48 <= param) break a;
     return 0;
    }
    return 1;
   }
   function is_space(param){
    var _bF_ = param - 9 | 0;
    a:
    {
     if(4 < _bF_ >>> 0){
      if(23 === _bF_) break a;
     }
     else if(1 < _bF_ - 2 >>> 0) break a;
     return 0;
    }
    return 1;
   }
   var
    _i_ = ign(caml_call1(Angstrom[8], cst$2)),
    _j_ = ign(caml_call1(Angstrom[5], 39)),
    _k_ = caml_call2(Angstrom[47], _j_, _i_),
    single_quoted = caml_call1(Angstrom[43], _k_),
    _l_ = ign(caml_call1(Angstrom[8], cst$3)),
    _m_ = ign(caml_call1(Angstrom[5], 34)),
    _n_ = caml_call2(Angstrom[47], _m_, _l_),
    double_quoted = caml_call1(Angstrom[43], _n_);
   function _o_(tag){
    function _by_(param){return 0;}
    var
     _bz_ = caml_call1(Angstrom[4], 36),
     _bA_ = caml_call1(Angstrom[8], tag),
     _bB_ = caml_call1(Angstrom[4], 36),
     _bC_ = caml_call2(Angstrom[58], _bB_, _bA_),
     _bD_ = caml_call2(Angstrom[59], _bC_, _bz_),
     _bE_ = caml_call2(Angstrom[40], Angstrom[6], _bD_);
    return caml_call2(Angstrom[55], _bE_, _by_);
   }
   var
    _p_ = caml_call1(Angstrom[4], 36),
    _q_ = caml_call1(Angstrom[11], is_idrcnt),
    _r_ = caml_call1(Angstrom[10], is_idrfst),
    _s_ = caml_call2(Angstrom[58], _r_, _q_),
    _t_ = caml_call1(Angstrom[16], _s_),
    _u_ = caml_call2(Angstrom[59], _t_, _p_),
    tagged_quote_cont = caml_call2(Angstrom[53], _u_, _o_);
   function _v_(c){
    if(64 <= c){
     if(96 === c){
      var
       _bo_ = caml_call1(Angstrom[4], 96),
       _bp_ = caml_call1(Angstrom[5], 96),
       _bq_ = caml_call1(Angstrom[43], _bp_);
      return caml_call2(Angstrom[59], _bq_, _bo_);
     }
    }
    else if(34 <= c)
     switch(c - 34 | 0){
       case 0:
        var _br_ = caml_call1(Angstrom[4], 34);
        return caml_call2(Angstrom[59], double_quoted, _br_);
       case 2:
        return tagged_quote_cont;
       case 5:
        var _bs_ = caml_call1(Angstrom[4], 39);
        return caml_call2(Angstrom[59], single_quoted, _bs_);
       case 11:
        var
         _bt_ =
           function(param){
            if(param && 45 === param[1]){
             var
              _bu_ = caml_call1(Angstrom[4], 10),
              _bv_ = function(_bx_){return 10 !== _bx_ ? 1 : 0;},
              _bw_ = caml_call1(Angstrom[11], _bv_);
             return caml_call2(Angstrom[59], _bw_, _bu_);
            }
            return caml_call1(Angstrom[51], 0);
           };
        return caml_call2(Angstrom[53], Angstrom[1], _bt_);
       case 25:
       case 29:
        return caml_call2(failf, _w_, c);
     }
    return caml_call1(Angstrom[51], 0);
   }
   var fragment = caml_call2(Angstrom[53], Angstrom[6], _v_);
   function _x_(s){return [0, s];}
   var
    _y_ = caml_call1(Angstrom[39], fragment),
    _z_ = caml_call1(Angstrom[16], _y_),
    verbatim = caml_call2(Angstrom[55], _z_, _x_),
    _A_ = caml_call1(Angstrom[11], is_idrcnt),
    _B_ = caml_call1(Angstrom[10], is_idrfst),
    skip_idr = caml_call2(Angstrom[58], _B_, _A_),
    _C_ = caml_call1(Angstrom[4], 46),
    _D_ = caml_call2(Angstrom[58], skip_idr, _C_),
    identifier_dot = caml_call1(Angstrom[16], _D_),
    _E_ = caml_call1(Angstrom[4], 46),
    _F_ = caml_call2(Angstrom[34], 32, _E_),
    _G_ = caml_call2(Angstrom[34], 0, skip_idr),
    _H_ = caml_call2(Angstrom[58], _G_, _F_),
    identifier_dotopt = caml_call1(Angstrom[16], _H_),
    _I_ = caml_call1(Angstrom[11], is_digit),
    _J_ = caml_call1(Angstrom[10], is_digit_nz),
    _K_ = caml_call2(Angstrom[58], _J_, _I_),
    parameter_number = caml_call1(Angstrom[16], _K_),
    _L_ = 0;
   function _M_(v){return [4, v];}
   var
    _N_ = caml_call1(Angstrom[4], 36),
    _O_ = caml_call2(Angstrom[58], _N_, identifier_dot),
    _P_ = [0, caml_call2(Angstrom[55], _O_, _M_), _L_];
   function _Q_(param){return _R_;}
   var
    _S_ = caml_call1(Angstrom[8], cst$4),
    _T_ = [0, caml_call2(Angstrom[55], _S_, _Q_), _P_];
   function _U_(v){return [4, v];}
   var
    _V_ = caml_call1(Angstrom[4], 41),
    _W_ = caml_call1(Angstrom[8], cst$5),
    _X_ = caml_call2(Angstrom[58], _W_, identifier_dotopt),
    _Y_ = caml_call2(Angstrom[59], _X_, _V_),
    _Z_ = [0, caml_call2(Angstrom[55], _Y_, _U_), _T_],
    lookup = caml_call2(Angstrom[48], ___, _Z_);
   function _$_(s){return [0, s];}
   function _aa_(param){return 36 === param ? 0 : 1;}
   var
    _ab_ = caml_call1(Angstrom[7], _aa_),
    _ac_ = caml_call1(Angstrom[39], _ab_),
    _ad_ = caml_call1(Angstrom[16], _ac_),
    nonlookup = caml_call2(Angstrom[55], _ad_, _$_);
   function _ae_(qs){
    var _bn_ = caml_call2(Stdlib[37], qs, _af_);
    return normal([5, caml_call2(Stdlib[37], _ag_, _bn_)]);
   }
   var
    _ah_ = caml_call1(Angstrom[8], cst$6),
    _ai_ = caml_call2(Angstrom[47], lookup, nonlookup),
    _aj_ = caml_call2(Angstrom[40], _ai_, _ah_),
    _ak_ = caml_call1(Angstrom[8], cst$7),
    _al_ = caml_call2(Angstrom[58], _ak_, _aj_),
    untagged_quote = caml_call2(Angstrom[55], _al_, _ae_);
   function _am_(param){
    if(36 === param){
     var
      _bc_ = [0, lookup, [0, untagged_quote, [0, verbatim, 0]]],
      _bd_ = function(iP){return [3, runtime.caml_int_of_string(iP) - 1 | 0];},
      _be_ = caml_call1(Angstrom[4], 36),
      _bf_ = caml_call2(Angstrom[58], _be_, parameter_number),
      _bg_ = [0, caml_call2(Angstrom[55], _bf_, _bd_), _bc_];
     return caml_call2(Angstrom[48], _an_, _bg_);
    }
    if(63 !== param) return verbatim;
    function _bh_(param){
     a:
     if(param){
      var c = param[1];
      if(60 <= c){
       if(124 <= c){
        if(125 === c || 127 <= c) break a;
       }
       else
        if(94 <= c){if(123 <= c) break a;} else if(91 <= c) break a;
      }
      else if(47 <= c){
       if(58 <= c){
        if(59 <= c) break a;
        var
         _bl_ =
           function(param){
            return caml_string_notequal(param, "::")
                    ? caml_call1(Angstrom[52], cst_is_not_allowed_after_param)
                    : caml_call1(Angstrom[51], 0);
           },
         _bm_ = caml_call1(Angstrom[3], 2);
        return caml_call2(Angstrom[53], _bm_, _bl_);
       }
       if(48 > c) break a;
      }
      else
       if(40 <= c){if(46 > c) break a;} else if(33 > c) break a;
      return caml_call2(failf, _ao_, c);
     }
     return caml_call1(Angstrom[51], 0);
    }
    var valid_lookahead = caml_call2(Angstrom[53], Angstrom[1], _bh_);
    function _bi_(param){return _ap_;}
    var
     _bj_ = caml_call1(Angstrom[4], 63),
     _bk_ = caml_call2(Angstrom[55], _bj_, _bi_);
    return caml_call2(Angstrom[59], _bk_, valid_lookahead);
   }
   var atom = caml_call2(Angstrom[53], Angstrom[2], _am_);
   function _aq_(param){return _ar_;}
   var
    _as_ = caml_call1(Angstrom[4], 59),
    _at_ = caml_call2(Angstrom[55], _as_, _aq_),
    atom_or_semi = caml_call2(Angstrom[47], _at_, atom);
   function reindex(atoms){
    function _ba_(param){
     if(3 === param[0] && -1 === param[1]) return 0;
     return 1;
    }
    if(caml_call2(Stdlib_List[33], _ba_, atoms))
     return caml_call1(Angstrom[51], atoms);
    var iP = 0, acc = 0, param = atoms;
    for(;;){
     if(! param){
      var _bb_ = caml_call1(Stdlib_List[10], acc);
      return caml_call1(Angstrom[51], _bb_);
     }
     var frag = param[1];
     if(3 === frag[0]){
      if(-1 !== frag[1])
       return caml_call1(Angstrom[52], cst_Inconsistent_parameter_sty);
      var
       frags$0 = param[2],
       acc$1 = [0, [3, iP], acc],
       iP$0 = iP + 1 | 0,
       iP = iP$0,
       acc = acc$1,
       param = frags$0;
     }
     else
      var
       frags = param[2],
       acc$0 = [0, frag, acc],
       acc = acc$0,
       param = frags;
    }
   }
   function _au_(param){
    if(param && 59 !== param[1])
     return caml_call1(Angstrom[52], cst_unterminated);
    return caml_call1(Angstrom[51], 0);
   }
   var stop = caml_call2(Angstrom[53], Angstrom[1], _au_);
   function _av_(qs){
    if(qs && ! qs[2]){var q = qs[1]; return q;}
    return [5, qs];
   }
   function _aw_(p){
    var
     _a8_ = caml_call2(Angstrom[57], Stdlib_List[5], atom),
     _a9_ = caml_call2(Angstrom[56], _a8_, p),
     _a__ = caml_call1(Angstrom[51], 0),
     _a$_ = caml_call2(Angstrom[58], stop, _a__);
    return caml_call2(Angstrom[47], _a$_, _a9_);
   }
   var
    _ax_ = caml_call1(Angstrom[45], _aw_),
    _ay_ = caml_call2(Angstrom[53], _ax_, reindex),
    angstrom_parser = caml_call2(Angstrom[55], _ay_, _av_);
   function _az_(param){
    return param
            ? caml_call1(Angstrom[52], cst_unterminated$0)
            : caml_call1(Angstrom[51], 0);
   }
   var stop$0 = caml_call2(Angstrom[53], Angstrom[1], _az_);
   function _aA_(qs){
    if(qs && ! qs[2]){var q = qs[1]; return q;}
    return [5, qs];
   }
   function _aB_(p){
    var
     _a4_ = caml_call2(Angstrom[57], Stdlib_List[5], atom_or_semi),
     _a5_ = caml_call2(Angstrom[56], _a4_, p),
     _a6_ = caml_call1(Angstrom[51], 0),
     _a7_ = caml_call2(Angstrom[58], stop$0, _a6_);
    return caml_call2(Angstrom[47], _a7_, _a5_);
   }
   var
    _aC_ = caml_call1(Angstrom[45], _aB_),
    _aD_ = caml_call2(Angstrom[53], _aC_, reindex),
    angstrom_parser_with_semicolon = caml_call2(Angstrom[55], _aD_, _aA_),
    _aE_ = Angstrom[50];
   function _aF_(_a3_){return 10 === _a3_ ? 1 : 0;}
   var
    _aG_ = caml_call1(Angstrom[15], _aF_),
    _aH_ = caml_call1(Angstrom[8], cst$8),
    _aI_ = caml_call2(Angstrom[58], _aH_, _aG_),
    _aJ_ = caml_call1(Angstrom[14], is_space),
    _aK_ = caml_call2(Angstrom[47], _aJ_, _aI_),
    _aL_ = caml_call1(Angstrom[38], _aK_),
    white = caml_call2(Angstrom[59], _aL_, _aE_),
    _aM_ = caml_call1(Angstrom[4], 59),
    _aN_ = caml_call2(Angstrom[59], angstrom_parser, _aM_),
    _aO_ = caml_call2(Angstrom[59], _aN_, white),
    _aP_ = caml_call1(Angstrom[38], _aO_),
    angstrom_list_parser = caml_call2(Angstrom[58], white, _aP_);
   function of_string(s){
    var match = caml_call1(Angstrom[77][1], angstrom_parser_with_semicolon);
    if(0 === match[0]){
     var _a2_ = match[1];
     if(0 === _a2_[1]){
      var
       continue$0 = _a2_[2],
       len = caml_ml_string_length(s),
       bs = caml_call3(Bigstringaf[3], 0, len, s),
       match$0 = caml_call4(continue$0, bs, 0, len, 0);
      switch(match$0[0]){
        case 0:
         var committed = match$0[1][1]; break;
        case 1:
         var committed$0 = match$0[1], q = match$0[2];
         if(committed$0 === len) return [0, q];
         var committed = committed$0;
         break;
        default:
         var msg = match$0[3], committed$1 = match$0[1];
         return [1, [0, 144245463, [0, committed$1, msg]]];
      }
      return [1,
              [0, 144245463, [0, committed, cst_Expression_cannot_contain_]]];
     }
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
   }
   function of_string_exn(s){
    var match = of_string(s);
    if(0 === match[0]){var q = match[1]; return q;}
    var match$0 = match[1][2], msg = match$0[2], pos = match$0[1];
    return caml_call4(Stdlib_Printf[10], Stdlib[2], _aR_, pos, msg);
   }
   var Stag_query = [248, cst_Caqti_query_Stag_query, caml_fresh_oo_id(0)];
   function query(ppf, q){
    caml_call2(Stdlib_Format[80], ppf, [0, Stag_query, q]);
    caml_call2(Stdlib_Format[13], ppf, cst_SQL_FRAGMENT);
    return caml_call2(Stdlib_Format[82], ppf, 0);
   }
   function quote(ppf, q){return query(ppf, [2, q]);}
   function env(ppf, e){return query(ppf, [4, e]);}
   function param(ppf, p){return query(ppf, [3, p]);}
   function kqprintf(k, fmt){
    var elems = [0, 0], buf = caml_call1(Stdlib_Buffer[1], 512);
    function push(q){elems[1] = [0, q, elems[1]]; return 0;}
    var mode = [0, 0];
    function flush_literal(param){
     var _a1_ = mode[1];
     if(typeof _a1_ === "number" && ! _a1_) return 0;
     return caml_call1(Stdlib[2], cst_invalid_nesting_of_query_t);
    }
    function output_string(s, p, n){
     var _aZ_ = mode[1];
     if(typeof _aZ_ !== "number")
      return caml_call4(Stdlib_Buffer[18], buf, s, p, n);
     if(_aZ_) return 0;
     var _a0_ = 0 < n ? 1 : 0;
     if(! _a0_) return _a0_;
     if(0 === p && n === caml_ml_string_length(s)) return push([0, s]);
     return push([0, caml_call3(Stdlib_String[16], s, p, n)]);
    }
    var
     ppf = caml_call2(Stdlib_Format[120], output_string, flush_literal),
     match = caml_call2(Stdlib_Format[106], ppf, 0),
     print_close_stag = match[4],
     print_open_stag = match[3],
     mark_close_stag = match[2],
     mark_open_stag = match[1];
    function mark_open_stag$0(t){
     if(t[1] === Stdlib_Format[79]){
      var _aY_ = t[2];
      if(! caml_string_notequal(_aY_, cst_E$0)){
       flush_literal(0);
       mode[1] = [0, function(s){return [4, s];}];
       return cst$11;
      }
      if(! caml_string_notequal(_aY_, cst_Q)){
       flush_literal(0);
       mode[1] = [0, function(s){return [2, s];}];
       return cst$10;
      }
     }
     if(t[1] !== Stag_query) return caml_call1(mark_open_stag, t);
     var q = t[2];
     flush_literal(0);
     push(q);
     mode[1] = 1;
     return cst$9;
    }
    function mark_close_stag$0(t){
     a:
     if(t[1] === Stdlib_Format[79]){
      var _aX_ = t[2];
      if
       (caml_string_notequal(_aX_, cst_E$0)
        && caml_string_notequal(_aX_, cst_Q))
       break a;
      var match = mode[1];
      if(typeof match === "number")
       throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
      var mk = match[1];
      push(caml_call1(mk, caml_call1(Stdlib_Buffer[2], buf)));
      caml_call1(Stdlib_Buffer[9], buf);
      mode[1] = 0;
      return cst$13;
     }
     if(t[1] !== Stag_query) return caml_call1(mark_close_stag, t);
     var _aW_ = mode[1];
     if(typeof _aW_ === "number" && _aW_){mode[1] = 0; return cst$12;}
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aT_], 1);
    }
    caml_call2
     (Stdlib_Format[104],
      ppf,
      [0,
       mark_open_stag$0,
       mark_close_stag$0,
       print_open_stag,
       print_close_stag]);
    caml_call2(Stdlib_Format[88], ppf, 1);
    function _aV_(ppf){
     caml_call2(Stdlib_Format[38], ppf, 0);
     return caml_call1(k, [5, caml_call1(Stdlib_List[10], elems[1])]);
    }
    return caml_call3(Stdlib_Format[144], _aV_, ppf, fmt);
   }
   function qprintf(fmt){return kqprintf(function(_aU_){return _aU_;}, fmt);}
   var
    Caqti_query =
      [0,
       concat,
       bool,
       int$0,
       float$0,
       string,
       octets,
       pdate,
       ptime,
       ptime_span,
       const_fields,
       normal,
       equal,
       hash,
       pp,
       show,
       pp_expand_error,
       Expand_error,
       expand,
       angstrom_parser,
       angstrom_parser_with_semicolon,
       angstrom_list_parser,
       of_string,
       of_string_exn,
       qprintf,
       kqprintf,
       param,
       env,
       quote,
       query];
   runtime.caml_register_global(68, Caqti_query, "Caqti_query");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_error
//# unitInfo: Requires: Caqti_query, Caqti_type, Stdlib, Stdlib__Buffer, Stdlib__Format, Stdlib__Hashtbl, Stdlib__Obj, Stdlib__Printexc, Stdlib__Printf, Uri
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_for = " for <",
    cst$3 = ": ",
    cst_failed = "> failed",
    cst_Field_type_not_supported_a$1 =
      "Field type not supported and no fallback provided.",
    cst_caqti_lib_caqti_error_ml = "caqti/lib/caqti_error.ml",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$3,
    cst$1 = cst$3,
    cst$0 = cst$3,
    cst = cst$3,
    Stdlib_Format = global_data.Stdlib__Format,
    Caqti_query = global_data.Caqti_query,
    Match_failure = global_data.Match_failure,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Caqti_type = global_data.Caqti_type,
    Uri = global_data.Uri,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    _e_ =
      [0,
       [11, "Failed to load driver for <", [15, [12, 62, 0]]],
       "Failed to load driver for <%a>"],
    _f_ =
      [0,
       [11, "Cannot connect to <", [15, [12, 62, 0]]],
       "Cannot connect to <%a>"],
    cst_During_post_connect = "During post-connect: ",
    _g_ =
      [0,
       [11, "Request to <", [15, [11, cst_failed, 0]]],
       "Request to <%a> failed"],
    _h_ =
      [0,
       [11, "Cannot load driver for <", [15, [12, 62, 0]]],
       "Cannot load driver for <%a>"],
    _i_ =
      [0,
       [11, "Failed to bind ", [15, [11, cst_for, [15, [12, 62, 0]]]]],
       "Failed to bind %a for <%a>"],
    _k_ =
      [0,
       [11, "Cannot decode ", [15, [11, " from <", [15, [12, 62, 0]]]]],
       "Cannot decode %a from <%a>"],
    _l_ =
      [0,
       [11, "Failed to connect to <", [15, [12, 62, 0]]],
       "Failed to connect to <%a>"],
    _m_ =
      [0,
       [11, "Cannot encode ", [15, [11, cst_for, [15, [12, 62, 0]]]]],
       "Cannot encode %a for <%a>"],
    _n_ =
      [0,
       [11, "Response from <", [15, [11, cst_failed, 0]]],
       "Response from <%a> failed"],
    _j_ =
      [0,
       [11, "Unexpected result from <", [15, [12, 62, 0]]],
       "Unexpected result from <%a>"],
    _o_ = [0, cst_caqti_lib_caqti_error_ml, 270, 48],
    cst_Field_type_not_supported_a$0 = cst_Field_type_not_supported_a$1,
    cst_Field_type_not_supported_a = cst_Field_type_not_supported_a$1,
    _d_ = [0, [11, " Query: ", [3, 0, [12, 46, 0]]], " Query: %S."],
    _c_ = [0, "_"],
    _b_ = [0, cst_caqti_lib_caqti_error_ml, 96, 10],
    _a_ =
      [0,
       [11,
        "Missing call to Caqti_error.define_msg for (",
        [2, 0, [11, " _ : Caqti_error.msg)]", 0]]],
       "Missing call to Caqti_error.define_msg for (%s _ : Caqti_error.msg)]"],
    cst_too_many_connections = "too many connections",
    cst_exclusion_violation = "exclusion violation",
    cst_UNIQUE_constraint_violatio = "UNIQUE constraint violation",
    cst_RESTRICT_violation = "RESTRICT violation",
    cst_insufficient_resources = "insufficient resources",
    cst_FOREIGN_KEY_constraint_vio = "FOREIGN KEY constraint violation",
    cst_out_of_memory = "out of memory",
    cst_NOT_NULL_constraint_violat = "NOT NULL constraint violation",
    cst_unknown_cause = "unknown cause",
    cst_disk_full = "disk full",
    cst_configuration_limit_exceed = "configuration limit exceeded",
    cst_integrity_constraint_viola = "integrity constraint violation",
    cst_CHECK_constraint_violation = "CHECK constraint violation",
    cst_Caqti_error_Msg = "Caqti_error.Msg",
    cst_Caqti_error_Exn = "Caqti_error.Exn";
   function show_cause(param){
    return 58559994 <= param
            ? 328993730
              <= param
              ? 439010708
                <= param
                ? 504538400
                  <= param
                  ? cst_too_many_connections
                  : cst_exclusion_violation
                : 406226903
                  <= param
                  ? cst_UNIQUE_constraint_violatio
                  : cst_RESTRICT_violation
              : 122406424
                === param
                ? cst_out_of_memory
                : 327437805
                  <= param
                  ? cst_insufficient_resources
                  : cst_FOREIGN_KEY_constraint_vio
            : -435482528
              <= param
              ? -123350241
                <= param
                ? -113858631
                  <= param
                  ? cst_NOT_NULL_constraint_violat
                  : cst_unknown_cause
                : -352670511
                  <= param
                  ? cst_disk_full
                  : cst_configuration_limit_exceed
              : -793072735
                <= param
                ? cst_integrity_constraint_viola
                : cst_CHECK_constraint_violation;
   }
   var msg_impl = caml_call2(Stdlib_Hashtbl[1], 0, 7);
   function default_cause(param){return -123350241;}
   function define_msg(pp, opt, ec){
    if(opt) var sth = opt[1], cause = sth; else var cause = default_cause;
    return caml_call3(Stdlib_Hashtbl[5], msg_impl, ec, [0, pp, cause]);
   }
   function find_impl(msg){
    var c = caml_call1(Stdlib_Obj[23][1], msg);
    try{var _A_ = caml_call2(Stdlib_Hashtbl[6], msg_impl, c); return _A_;}
    catch(_B_){
     var _y_ = caml_wrap_exception(_B_);
     if(_y_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_y_, 0);
     var _z_ = caml_call1(Stdlib_Obj[23][2], c);
     return caml_call3(Stdlib_Printf[10], Stdlib[2], _a_, _z_);
    }
   }
   var Msg = [248, cst_Caqti_error_Msg, caml_fresh_oo_id(0)];
   function pp(ppf, param){
    if(param[1] !== Msg)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var s = param[2];
    caml_call2(Stdlib_Format[13], ppf, s);
    var _v_ = runtime.caml_string_notequal(s, "");
    if(_v_){
     var
      _u_ =
        runtime.caml_string_get(s, runtime.caml_ml_string_length(s) - 1 | 0)
        - 33
        | 0;
     a:
     {
      b:
      {
       if(13 < _u_ >>> 0){
        if(30 === _u_) break b;
       }
       else if(11 < _u_ - 1 >>> 0) break b;
       var _w_ = 0;
       break a;
      }
      var _w_ = 1;
     }
     var _x_ = 1 - _w_;
    }
    else
     var _x_ = _v_;
    return _x_ ? caml_call2(Stdlib_Format[23], ppf, 46) : _x_;
   }
   define_msg(pp, [0, default_cause], Msg);
   function pp_msg(ppf, msg){return caml_call2(find_impl(msg)[1], ppf, msg);}
   function pp_uri(ppf, uri){
    if(! caml_call1(Uri[34], uri)) return caml_call2(Uri[44], ppf, uri);
    var _t_ = caml_call2(Uri[35], uri, _c_);
    return caml_call2(Uri[44], ppf, _t_);
   }
   function pp_load_msg(ppf, fmt, err){
    caml_call4(Stdlib_Format[137], ppf, fmt, pp_uri, err[1]);
    caml_call2(Stdlib_Format[13], ppf, cst);
    return pp_msg(ppf, err[2]);
   }
   function pp_connection_msg(ppf, fmt, err){
    caml_call4(Stdlib_Format[137], ppf, fmt, pp_uri, err[1]);
    caml_call2(Stdlib_Format[13], ppf, cst$0);
    return pp_msg(ppf, err[2]);
   }
   function pp_query_msg(ppf, fmt, err){
    caml_call4(Stdlib_Format[137], ppf, fmt, pp_uri, err[1]);
    caml_call2(Stdlib_Format[13], ppf, cst$1);
    pp_msg(ppf, err[3]);
    return caml_call3(Stdlib_Format[137], ppf, _d_, err[2]);
   }
   function pp_coding_error(ppf, fmt, err){
    caml_call6
     (Stdlib_Format[137], ppf, fmt, Caqti_type[7], err[2], pp_uri, err[1]);
    caml_call2(Stdlib_Format[13], ppf, cst$2);
    return pp_msg(ppf, err[3]);
   }
   function load_rejected(uri, msg){return [0, 463288279, [0, uri, msg]];}
   function load_failed(uri, msg){return [0, 1039467990, [0, uri, msg]];}
   function connect_rejected(uri, msg){return [0, 893831635, [0, uri, msg]];}
   function connect_failed(uri, msg){return [0, 62185682, [0, uri, msg]];}
   function encode_missing(uri, field_type, param){
    var
     typ = [0, caml_call1(Caqti_type[10], field_type)],
     msg = [0, Msg, cst_Field_type_not_supported_a];
    return [0, -249947673, [0, uri, typ, msg]];
   }
   function encode_rejected(uri, typ, msg){
    var typ$0 = [0, typ];
    return [0, -249947673, [0, uri, typ$0, msg]];
   }
   function encode_failed(uri, typ, msg){
    var typ$0 = [0, typ];
    return [0, 286933990, [0, uri, typ$0, msg]];
   }
   function request_failed(uri, query, msg){
    return [0, 750887949, [0, uri, query, msg]];
   }
   function decode_missing(uri, field_type, param){
    var
     typ = [0, caml_call1(Caqti_type[10], field_type)],
     msg = [0, Msg, cst_Field_type_not_supported_a$0];
    return [0, 67537871, [0, uri, typ, msg]];
   }
   function decode_rejected(uri, typ, msg){
    var typ$0 = [0, typ];
    return [0, 67537871, [0, uri, typ$0, msg]];
   }
   function response_failed(uri, query, msg){
    return [0, -898469157, [0, uri, query, msg]];
   }
   function response_rejected(uri, query, msg){
    return [0, -736907236, [0, uri, query, msg]];
   }
   function uri(param){
    var param$0 = param;
    for(;;){
     var _s_ = param$0[1];
     if(286933990 > _s_){
      if(-736907236 === _s_){var uri$4 = param$0[2][1]; return uri$4;}
      if(62185682 <= _s_){
       if(67537871 <= _s_){var uri$5 = param$0[2][1]; return uri$5;}
       var uri$6 = param$0[2][1];
       return uri$6;
      }
      if(-249947673 <= _s_){var uri$7 = param$0[2][1]; return uri$7;}
      var uri$8 = param$0[2][1];
      return uri$8;
     }
     if(750887949 > _s_){
      if(463288279 <= _s_){var uri$2 = param$0[2][1]; return uri$2;}
      var uri$3 = param$0[2][1];
      return uri$3;
     }
     if(893831635 <= _s_){
      if(1039467990 <= _s_){var uri = param$0[2][1]; return uri;}
      var uri$0 = param$0[2][1];
      return uri$0;
     }
     if(844285419 > _s_){var uri$1 = param$0[2][1]; return uri$1;}
     var err = param$0[2], param$0 = err;
    }
   }
   function pp$0(ppf, param){
    var param$0 = param;
    for(;;){
     var _r_ = param$0[1];
     if(286933990 > _r_){
      if(-736907236 === _r_){
       var err$5 = param$0[2];
       return pp_query_msg(ppf, _j_, err$5);
      }
      if(62185682 <= _r_){
       if(67537871 <= _r_){
        var err$6 = param$0[2];
        return pp_coding_error(ppf, _k_, err$6);
       }
       var err$7 = param$0[2];
       return pp_connection_msg(ppf, _l_, err$7);
      }
      if(-249947673 <= _r_){
       var err$8 = param$0[2];
       return pp_coding_error(ppf, _m_, err$8);
      }
      var err$9 = param$0[2];
      return pp_query_msg(ppf, _n_, err$9);
     }
     if(750887949 > _r_){
      if(463288279 <= _r_){
       var err$3 = param$0[2];
       return pp_load_msg(ppf, _h_, err$3);
      }
      var err$4 = param$0[2];
      return pp_coding_error(ppf, _i_, err$4);
     }
     if(893831635 <= _r_){
      if(1039467990 <= _r_){
       var err = param$0[2];
       return pp_load_msg(ppf, _e_, err);
      }
      var err$0 = param$0[2];
      return pp_connection_msg(ppf, _f_, err$0);
     }
     if(844285419 > _r_){
      var err$2 = param$0[2];
      return pp_query_msg(ppf, _g_, err$2);
     }
     var err$1 = param$0[2];
     caml_call2(Stdlib_Format[13], ppf, cst_During_post_connect);
     var param$0 = err$1;
    }
   }
   function show_of_pp(pp, err){
    var
     buf = caml_call1(Stdlib_Buffer[1], 128),
     ppf = caml_call1(Stdlib_Format[114], buf);
    caml_call2(pp, ppf, err);
    caml_call2(Stdlib_Format[38], ppf, 0);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function show(err){return show_of_pp(pp$0, err);}
   function cause(param){
    var err = param[2], _q_ = err[3];
    return caml_call1(find_impl(err[3])[2], _q_);
   }
   function uncongested(x){
    if(1 === x[0] && 48080384 === x[1][1])
     throw caml_maybe_attach_backtrace([0, Match_failure, _o_], 1);
    return x;
   }
   var Exn = [248, cst_Caqti_error_Exn, caml_fresh_oo_id(0)];
   function _p_(param){
    if(param[1] === Exn){var err = param[2]; return [0, show(err)];}
    if(param[1] !== Caqti_query[17]) return 0;
    var err$0 = param[2];
    return [0, show_of_pp(Caqti_query[16], err$0)];
   }
   caml_call1(Stdlib_Printexc[9], _p_);
   var
    Caqti_error =
      [0,
       show_cause,
       define_msg,
       pp_msg,
       Msg,
       pp_uri,
       load_rejected,
       load_failed,
       connect_rejected,
       connect_failed,
       encode_missing,
       encode_rejected,
       encode_failed,
       request_failed,
       decode_missing,
       decode_rejected,
       response_failed,
       response_rejected,
       uri,
       pp$0,
       show,
       cause,
       uncongested,
       Exn];
   runtime.caml_register_global(50, Caqti_error, "Caqti_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_response_sig
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Caqti_response_sig = [0];
   runtime.caml_register_global(0, Caqti_response_sig, "Caqti_response_sig");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_driver_info
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_dummy = "dummy";
   function create
   (uri_scheme, opt, _a_, can_pool, can_concur, can_transact, param){
    if(opt)
     var sth = opt[1], dialect_tag = sth;
    else
     var dialect_tag = -912009552;
    if(_a_)
     var sth$0 = _a_[1], parameter_style = sth$0;
    else
     var parameter_style = 870530776;
    return [0,
            uri_scheme,
            dialect_tag,
            parameter_style,
            can_transact,
            can_pool,
            can_concur];
   }
   var dummy = create(cst_dummy, 0, 0, 0, 0, 0, 0);
   function uri_scheme(di){return di[1];}
   function dialect_tag(di){return di[2];}
   function parameter_style(di){return di[3];}
   function can_pool(di){return di[5];}
   function can_concur(di){return di[6];}
   function can_transact(di){return di[4];}
   var
    Caqti_driver_info =
      [0,
       create,
       dummy,
       uri_scheme,
       dialect_tag,
       parameter_style,
       can_pool,
       can_concur,
       can_transact];
   runtime.caml_register_global(1, Caqti_driver_info, "Caqti_driver_info");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_mult
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_caqti_lib_caqti_mult_ml = "caqti/lib/caqti_mult.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    _c_ = [0, cst_caqti_lib_caqti_mult_ml, 42, 35],
    _b_ = [0, cst_caqti_lib_caqti_mult_ml, 40, 28],
    _a_ = [0, cst_caqti_lib_caqti_mult_ml, 38, 29],
    zero = 0,
    one = 1,
    zero_or_one = 2,
    zero_or_more = 3;
   function only_zero(param){
    if(param) throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return 0;
   }
   function only_one(param){
    if(1 === param) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function only_zero_or_one(param){
    if(2 <= param)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    return 0;
   }
   function expose(param){
    switch(param){
      case 0:
       return 1003109192;
      case 1:
       return 3953222;
      case 2:
       return 450190689;
      default: return -561334214;
    }
   }
   function can_be_zero(param){return 1 === param ? 0 : 1;}
   function can_be_many(param){return 3 <= param ? 1 : 0;}
   var
    Caqti_mult =
      [0,
       zero,
       one,
       zero_or_one,
       zero_or_more,
       only_zero,
       only_one,
       only_zero_or_one,
       expose,
       can_be_zero,
       can_be_many];
   runtime.caml_register_global(4, Caqti_mult, "Caqti_mult");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_request
//# unitInfo: Requires: Caqti_driver_info, Caqti_mult, Caqti_query, Caqti_type, Logs, Stdlib, Stdlib__Format, Stdlib__Sys
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ".",
    cst$0 = "?",
    cst$1 = "",
    cst$2 = "*",
    Caqti_type = global_data.Caqti_type,
    Stdlib_Format = global_data.Stdlib__Format,
    Caqti_driver_info = global_data.Caqti_driver_info,
    Caqti_query = global_data.Caqti_query,
    Caqti_mult = global_data.Caqti_mult,
    Stdlib = global_data.Stdlib,
    Logs = global_data.Logs,
    _d_ = [0, [12, 32, [15, 0]], " %a"],
    _f_ =
      [0,
       [11,
        "Invalid value ",
        [2, 0, [11, " for CAQTI_DEBUG_PARAM, assuming false.", 0]]],
       "Invalid value %s for CAQTI_DEBUG_PARAM, assuming false."],
    _b_ =
      [0,
       [12,
        40,
        [15,
         [11,
          " -->",
          [2, 0, [12, 32, [15, [11, ") {|", [15, [11, "|}", 0]]]]]]]]],
       "(%a -->%s %a) {|%a|}"],
    cst_caqti = "caqti";
   function symbol(f, g, x){return caml_call1(f, caml_call1(g, x));}
   var
    _a_ = caml_call2(Logs[7][1], 0, cst_caqti),
    Log = caml_call1(Logs[18], _a_),
    last_id = [0, -1];
   function create(opt, param_type, row_type, row_mult, query){
    if(opt) var sth = opt[1], oneshot = sth; else var oneshot = 0;
    var id = oneshot ? 0 : (last_id[1]++, [0, last_id[1]]);
    return [0, id, query, param_type, row_type, row_mult];
   }
   function param_type(request){return request[3];}
   function row_type(request){return request[4];}
   function row_mult(request){return request[5];}
   function query_id(request){return request[1];}
   function query(request){return request[2];}
   function symbol$0(t, u, oneshot, f){
    return create(oneshot, t, u, Caqti_mult[1], f);
   }
   function symbol$1(t, u, oneshot, f){
    return create(oneshot, t, u, Caqti_mult[2], f);
   }
   function symbol$2(t, u, oneshot, f){
    return create(oneshot, t, u, Caqti_mult[3], f);
   }
   function symbol$3(t, u, oneshot, f){
    return create(oneshot, t, u, Caqti_mult[4], f);
   }
   function symbol$4(f, s){
    var q = caml_call1(Caqti_query[23], s);
    return caml_call1(f, function(param){return q;});
   }
   function symbol$5(f, g){
    var _D_ = Caqti_driver_info[4], _E_ = Caqti_query[23];
    function _F_(_H_){return symbol(_E_, g, _H_);}
    return caml_call1(f, function(_G_){return symbol(_F_, _D_, _G_);});
   }
   function symbol$6(t, u, oneshot, s){
    var _B_ = Caqti_mult[1];
    return symbol$4(function(_C_){return create(oneshot, t, u, _B_, _C_);}, s);
   }
   function symbol$7(t, u, oneshot, s){
    var _z_ = Caqti_mult[2];
    return symbol$4(function(_A_){return create(oneshot, t, u, _z_, _A_);}, s);
   }
   function symbol$8(t, u, oneshot, s){
    var _x_ = Caqti_mult[3];
    return symbol$4(function(_y_){return create(oneshot, t, u, _x_, _y_);}, s);
   }
   function symbol$9(t, u, oneshot, s){
    var _v_ = Caqti_mult[4];
    return symbol$4(function(_w_){return create(oneshot, t, u, _v_, _w_);}, s);
   }
   function no_env(param, _u_){
    throw caml_maybe_attach_backtrace(Stdlib[8], 1);
   }
   function make_pp(opt, _n_, param, ppf, req){
    if(opt) var sth = opt[1], env = sth; else var env = no_env;
    if(_n_)
     var sth$0 = _n_[1], driver_info = sth$0;
    else
     var driver_info = Caqti_driver_info[2];
    var
     _o_ = caml_call1(req[2], driver_info),
     _p_ = caml_call1(env, driver_info),
     query = caml_call3(Caqti_query[18], 0, _p_, _o_),
     _q_ = Caqti_query[14],
     _r_ = req[4],
     _s_ = Caqti_type[6],
     match = caml_call1(Caqti_mult[8], req[5]),
     _t_ =
       450190689 <= match
        ? 1003109192 <= match ? cst : cst$0
        : 3953222 <= match ? cst$1 : cst$2;
    return caml_call9
            (Stdlib_Format[137],
             ppf,
             _b_,
             Caqti_type[6],
             req[3],
             _t_,
             _s_,
             _r_,
             _q_,
             query);
   }
   function pp(ppf){
    var _j_ = 0, _k_ = 0, _l_ = 0;
    return function(_m_){return make_pp(_l_, _k_, _j_, ppf, _m_);};
   }
   a:
   {
    try{var s = runtime.caml_sys_getenv("CAQTI_DEBUG_PARAM");}
    catch(_i_){
     var _c_ = caml_wrap_exception(_i_);
     if(_c_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_c_, 0);
     var pp_with_param_enabled = 0;
     break a;
    }
    if(caml_string_notequal(s, "false"))
     if(caml_string_notequal(s, "true")){
      var _e_ = function(f){return caml_call4(f, 0, 0, _f_, s);};
      caml_call1(Log[3], _e_);
      var _g_ = 0;
     }
     else
      var _g_ = 1;
    else
     var _g_ = 0;
    var pp_with_param_enabled = _g_;
   }
   function make_pp_with_param(env, driver_info, param, ppf, _h_){
    var req = _h_[1], param$0 = _h_[2];
    make_pp(env, driver_info, 0, ppf, req);
    return pp_with_param_enabled
            ? caml_call4
              (Stdlib_Format[137],
               ppf,
               _d_,
               Caqti_type[8],
               [0, req[3], param$0])
            : pp_with_param_enabled;
   }
   var
    Caqti_request =
      [0,
       create,
       param_type,
       row_type,
       row_mult,
       query_id,
       query,
       [0,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$5],
       make_pp,
       pp,
       make_pp_with_param];
   runtime.caml_register_global(18, Caqti_request, "Caqti_request");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_query_fmt
//# unitInfo: Requires: Caqti_query
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Caqti_query = global_data.Caqti_query,
    qprintf = Caqti_query[24],
    kqprintf = Caqti_query[25],
    env = Caqti_query[27],
    quote = Caqti_query[28],
    query = Caqti_query[29],
    param = Caqti_query[26];
   function bool(ppf, x){return caml_call2(query, ppf, [1, 0, x]);}
   function int$0(ppf, x){return caml_call2(query, ppf, [1, 1, x]);}
   function float$0(ppf, x){return caml_call2(query, ppf, [1, 5, x]);}
   function string(ppf, x){return caml_call2(query, ppf, [1, 6, x]);}
   function octets(ppf, x){return caml_call2(query, ppf, [1, 7, x]);}
   function pdate(ppf, x){return caml_call2(query, ppf, [1, 8, x]);}
   function ptime(ppf, x){return caml_call2(query, ppf, [1, 9, x]);}
   function ptime_span(ppf, x){return caml_call2(query, ppf, [1, 10, x]);}
   var
    Caqti_query_fmt =
      [0,
       qprintf,
       kqprintf,
       param,
       env,
       quote,
       query,
       bool,
       int$0,
       float$0,
       string,
       octets,
       pdate,
       ptime,
       ptime_span];
   runtime.caml_register_global(1, Caqti_query_fmt, "Caqti_query_fmt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_pool_sig
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Caqti_pool_sig = [0];
   runtime.caml_register_global(0, Caqti_pool_sig, "Caqti_pool_sig");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_pool_config
//# unitInfo: Requires: Logs, Mtime, Stdlib, Stdlib__List, Stdlib__Sys
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pfx = "CAQTI_POOL",
    keys = [0, [0, 0], [0, [0, 1], [0, [0, 2], [0, [0, 3], 0]]]],
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Mtime = global_data.Mtime,
    Logs = global_data.Logs,
    _a_ = caml_call2(Logs[7][1], 0, "caqti.config"),
    Log = caml_call1(Logs[18], _a_),
    _b_ =
      [0,
       [11, "Failed to parse $", [2, 0, [11, " = ", [2, 0, [12, 46, 0]]]]],
       "Failed to parse $%s = %s."],
    cst_MAX_USE_COUNT = "_MAX_USE_COUNT",
    cst_MAX_IDLE_AGE = "_MAX_IDLE_AGE",
    cst_MAX_IDLE_SIZE = "_MAX_IDLE_SIZE",
    cst_MAX_SIZE = "_MAX_SIZE",
    cst_Mtime_Span_of_float_ns = "Mtime.Span.of_float_ns";
   function create
   (max_size, max_idle_size, max_idle_age, max_use_count, param){
    return [0, max_size, max_idle_size, max_idle_age, max_use_count];
   }
   function option_of_string(f, s){
    if(caml_string_notequal(s, "") && caml_string_notequal(s, "none"))
     return [0, caml_call1(f, s)];
    return 0;
   }
   function mtime_span_of_string(s){
    var
     x = runtime.caml_float_of_string(s),
     match = caml_call1(Mtime[1][22], x * 1000000000.);
    if(! match) return caml_call1(Stdlib[2], cst_Mtime_Span_of_float_ns);
    var x$0 = match[1];
    return x$0;
   }
   var default$0 = [0, 0, 0, 0, 0];
   function default_from_env(param){
    function get(conv, sfx){
     var
      var$0 = caml_call2(Stdlib[28], pfx, sfx),
      match = caml_call1(Stdlib_Sys[2], var$0);
     if(! match) return 0;
     var str = match[1];
     try{var value = caml_call1(conv, str);}
     catch(_k_){
      var _i_ = caml_wrap_exception(_k_);
      if(_i_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_i_, 0);
      var _j_ = function(m){return caml_call5(m, 0, 0, _b_, var$0, str);};
      caml_call1(Log[3], _j_);
      return 0;
     }
     return [0, value];
    }
    var
     _c_ = caml_int_of_string,
     _d_ =
       get
        (function(_h_){return option_of_string(_c_, _h_);}, cst_MAX_USE_COUNT),
     _e_ =
       get
        (function(_g_){return option_of_string(mtime_span_of_string, _g_);},
         cst_MAX_IDLE_AGE),
     _f_ = get(caml_int_of_string, cst_MAX_IDLE_SIZE);
    return [0, get(caml_int_of_string, cst_MAX_SIZE), _f_, _e_, _d_];
   }
   var max_size = 0, max_idle_size = 1, max_idle_age = 2, max_use_count = 3;
   function get(k, config){
    switch(k){
      case 0:
       return config[1];
      case 1:
       return config[2];
      case 2:
       return config[3];
      default: return config[4];
    }
   }
   function modify(k, v, config){
    switch(k){
      case 0:
       return [0, v, config[2], config[3], config[4]];
      case 1:
       return [0, config[1], v, config[3], config[4]];
      case 2:
       return [0, config[1], config[2], v, config[4]];
      default: return [0, config[1], config[2], config[3], v];
    }
   }
   function set(k, v, config){return modify(k, [0, v], config);}
   function unset(k, config){return modify(k, 0, config);}
   function merge_left(cL, cR){
    function add(acc, param){
     var k = param[1], match = get(k, cL);
     if(! match) return acc;
     var v = match[1];
     return set(k, v, acc);
    }
    return caml_call3(Stdlib_List[26], add, cR, keys);
   }
   var
    Caqti_pool_config =
      [0,
       create,
       default$0,
       default_from_env,
       merge_left,
       get,
       set,
       unset,
       max_size,
       max_idle_size,
       max_idle_age,
       max_use_count];
   runtime.caml_register_global(17, Caqti_pool_config, "Caqti_pool_config");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_connection_sig
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Caqti_connection_sig = [0];
   runtime.caml_register_global
    (0, Caqti_connection_sig, "Caqti_connection_sig");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_connect_config
//# unitInfo: Requires: Stdlib__Map, Stdlib__String
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Map = global_data.Stdlib__Map,
    cst_Tag = "Tag",
    _a_ = [0, 1, 7],
    cst_tweaks_version = "tweaks_version";
   function create_key(name, default$0){
    var Tag = [248, cst_Tag, runtime.caml_fresh_oo_id(0)];
    return [0, Tag, name, default$0];
   }
   var
    String_map = caml_call1(Stdlib_Map[1], [0, Stdlib_String[10]]),
    default$0 = String_map[1];
   function mem_name(key_name){return caml_call1(String_map[32], key_name);}
   function get(Key, m){
    var match = caml_call2(String_map[18], Key[2], m);
    if(match){
     var _b_ = match[1];
     if(_b_[1] === Key[1]){var v = _b_[2]; return v;}
    }
    return Key[3];
   }
   function set(Key, v, m){
    return caml_call3(String_map[2], Key[2], [0, Key[1], v], m);
   }
   function reset(Key, m){return caml_call2(String_map[6], Key[2], m);}
   var
    tweaks_version = create_key(cst_tweaks_version, _a_),
    Caqti_connect_config =
      [0, default$0, get, set, reset, tweaks_version, create_key, mem_name];
   runtime.caml_register_global
    (5, Caqti_connect_config, "Caqti_connect_config");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Caqti_connect_sig
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Caqti_connect_sig = [0];
   runtime.caml_register_global(0, Caqti_connect_sig, "Caqti_connect_sig");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJjYXF0aS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiYm9vbCIsImludCQwIiwiaW50MTYiLCJpbnQzMiIsImludDY0IiwiZmxvYXQkMCIsInN0cmluZyIsIm9jdGV0cyIsInBkYXRlIiwicHRpbWUiLCJwdGltZV9zcGFuIiwidW5pZnkiLCJmdDEiLCJmdDIiLCJuYW1lMSIsIm5hbWUyIiwiZXF1YWxfdmFsdWUiLCJ0b19zdHJpbmciLCJuYW1lIiwicHAiLCJwcGYiLCJmdCIsInBwX3B0aW1lIiwicHBfdmFsdWUiLCJ4IiwieCQwIiwieCQxIiwieCQyIiwieCQzIiwieCQ0IiwieCQ1IiwieCQ2IiwieCQ3IiwiZCIsIm0iLCJ5IiwieCQ4IiwieCQ5IiwieCQxMCIsInVuaWZ5JDAiLCJ0MSIsInQyIiwidDEkMCIsInQyJDAiLCJ0MSQxIiwidDIkMSIsImlkMSIsImlkMiIsInNlcmlhbCIsImlzX3NlcmlhbCIsInQxJDIiLCJ0MiQyIiwiZXF1YWxfdmFsdWUkMCIsInQiLCJmIiwieSQwIiwicHJvZCIsImVxdWFsX3ZhbHVlX3Byb2QiLCJ0JDAiLCJwIiwiZXFfZmlyc3QiLCJlcV9yZXN0IiwibGVuZ3RoIiwibG9vcCIsIm4iLCJwcF9hdCIsInByZWMiLCJ0MCIsInByb2QkMCIsInQkMSIsInBwJDAiLCJwcF9hbnkiLCJwcF92YWx1ZSQwIiwiZnYiLCJpIiwic2hvdyIsImJ1ZiIsImZpZWxkIiwib3B0aW9uIiwicHJvZHVjdCIsImludHJvIiwicHJvaiIsInVuaXQiLCJwcm9qX2VuZCIsInR1cDIiLCJ4MSIsIngyIiwidHVwMyIsInQzIiwieDMiLCJ0dXA0IiwidDQiLCJ4NCIsInQ1IiwieDUiLCJ0NiIsIng2IiwidDciLCJ4NyIsInQ4IiwieDgiLCJ0OSIsIng5IiwidDEwIiwieDEwIiwidDExIiwieDExIiwidDEyIiwieDEyIiwiY3VzdG9tIiwiZW5jb2RlIiwiZGVjb2RlIiwicmVwIiwiZW5jb2RlJDAiLCJtc2ciLCJkZWNvZGUkMCIsInJlZGFjdGVkIiwiZW51bSQwIiwiY29uY2F0Iiwic2VwIiwicXMkMCIsInEkMCIsInBmeCIsImFjYyIsInFzIiwicSIsImNvbnN0X2ZpZWxkcyIsInB0IiwiY29uc3RfZmllbGRzX3Byb2R1Y3QiLCJub3JtYWwiLCJxJDIiLCJxcyQ0IiwicSQzIiwicyIsImFjY0wkMCIsInFzJDUiLCJzJDAiLCJxcyQ2IiwicXMkOCIsInFzJDkiLCJxJDEiLCJxcyQ3IiwicXMkMiIsInFzJDMiLCJxcyQxIiwiZXF1YWwiLCJzMSIsInMyIiwidjIiLCJ2MSIsInMxJDAiLCJzMiQwIiwiaTEiLCJpMiIsIm4xIiwibjIiLCJ0czEiLCJ0czIiLCJ4cyIsInlzIiwieXMkMCIsInhzJDAiLCJoYXNoIiwidiIsImMiLCJuJDAiLCJwcF9leHBhbmRfZXJyb3IiLCJyZWFzb24iLCJ2YXIkMCIsInF1ZXJ5IiwiZXhwYW5zaW9uIiwiZXhwYW5kIiwib3B0Iiwic3RoIiwiZmluYWwkMCIsImlzX3ZhbGlkIiwicmVjdXJzZSIsIm5vdF9mb3VuZCIsImwiLCJmYWlsZiIsImlnbiIsImlzX2RpZ2l0IiwiaXNfZGlnaXRfbnoiLCJpc19pZHJmc3QiLCJpc19pZHJjbnQiLCJpc19zcGFjZSIsInNpbmdsZV9xdW90ZWQiLCJkb3VibGVfcXVvdGVkIiwidGFnIiwidGFnZ2VkX3F1b3RlX2NvbnQiLCJmcmFnbWVudCIsInZlcmJhdGltIiwic2tpcF9pZHIiLCJpZGVudGlmaWVyX2RvdCIsImlkZW50aWZpZXJfZG90b3B0IiwicGFyYW1ldGVyX251bWJlciIsImxvb2t1cCIsIm5vbmxvb2t1cCIsInVudGFnZ2VkX3F1b3RlIiwiaVAiLCJ2YWxpZF9sb29rYWhlYWQiLCJhdG9tIiwiYXRvbV9vcl9zZW1pIiwicmVpbmRleCIsImF0b21zIiwiZnJhZyIsImZyYWdzJDAiLCJmcmFncyIsInN0b3AiLCJhbmdzdHJvbV9wYXJzZXIiLCJzdG9wJDAiLCJhbmdzdHJvbV9wYXJzZXJfd2l0aF9zZW1pY29sb24iLCJ3aGl0ZSIsImFuZ3N0cm9tX2xpc3RfcGFyc2VyIiwib2Zfc3RyaW5nIiwiY29udGludWUkMCIsImxlbiIsImJzIiwiY29tbWl0dGVkIiwiY29tbWl0dGVkJDAiLCJjb21taXR0ZWQkMSIsIm9mX3N0cmluZ19leG4iLCJwb3MiLCJxdW90ZSIsImVudiIsImUiLCJwYXJhbSIsImtxcHJpbnRmIiwiayIsImZtdCIsImVsZW1zIiwicHVzaCIsIm1vZGUiLCJmbHVzaF9saXRlcmFsIiwib3V0cHV0X3N0cmluZyIsInByaW50X2Nsb3NlX3N0YWciLCJwcmludF9vcGVuX3N0YWciLCJtYXJrX2Nsb3NlX3N0YWciLCJtYXJrX29wZW5fc3RhZyIsIm1hcmtfb3Blbl9zdGFnJDAiLCJtYXJrX2Nsb3NlX3N0YWckMCIsIm1rIiwicXByaW50ZiIsInNob3dfY2F1c2UiLCJtc2dfaW1wbCIsImRlZmF1bHRfY2F1c2UiLCJkZWZpbmVfbXNnIiwiZWMiLCJjYXVzZSIsImZpbmRfaW1wbCIsInBwX21zZyIsInBwX3VyaSIsInVyaSIsInBwX2xvYWRfbXNnIiwiZXJyIiwicHBfY29ubmVjdGlvbl9tc2ciLCJwcF9xdWVyeV9tc2ciLCJwcF9jb2RpbmdfZXJyb3IiLCJsb2FkX3JlamVjdGVkIiwibG9hZF9mYWlsZWQiLCJjb25uZWN0X3JlamVjdGVkIiwiY29ubmVjdF9mYWlsZWQiLCJlbmNvZGVfbWlzc2luZyIsImZpZWxkX3R5cGUiLCJ0eXAiLCJlbmNvZGVfcmVqZWN0ZWQiLCJ0eXAkMCIsImVuY29kZV9mYWlsZWQiLCJyZXF1ZXN0X2ZhaWxlZCIsImRlY29kZV9taXNzaW5nIiwiZGVjb2RlX3JlamVjdGVkIiwicmVzcG9uc2VfZmFpbGVkIiwicmVzcG9uc2VfcmVqZWN0ZWQiLCJ1cmkkNCIsInVyaSQ1IiwidXJpJDYiLCJ1cmkkNyIsInVyaSQ4IiwidXJpJDIiLCJ1cmkkMyIsInVyaSQwIiwidXJpJDEiLCJlcnIkNSIsImVyciQ2IiwiZXJyJDciLCJlcnIkOCIsImVyciQ5IiwiZXJyJDMiLCJlcnIkNCIsImVyciQwIiwiZXJyJDIiLCJlcnIkMSIsInNob3dfb2ZfcHAiLCJ1bmNvbmdlc3RlZCIsImNyZWF0ZSIsInVyaV9zY2hlbWUiLCJjYW5fcG9vbCIsImNhbl9jb25jdXIiLCJjYW5fdHJhbnNhY3QiLCJkaWFsZWN0X3RhZyIsInN0aCQwIiwicGFyYW1ldGVyX3N0eWxlIiwiZHVtbXkiLCJkaSIsInplcm8iLCJvbmUiLCJ6ZXJvX29yX29uZSIsInplcm9fb3JfbW9yZSIsIm9ubHlfemVybyIsIm9ubHlfb25lIiwib25seV96ZXJvX29yX29uZSIsImV4cG9zZSIsImNhbl9iZV96ZXJvIiwiY2FuX2JlX21hbnkiLCJzeW1ib2wiLCJnIiwibGFzdF9pZCIsInBhcmFtX3R5cGUiLCJyb3dfdHlwZSIsInJvd19tdWx0Iiwib25lc2hvdCIsImlkIiwicmVxdWVzdCIsInF1ZXJ5X2lkIiwic3ltYm9sJDAiLCJ1Iiwic3ltYm9sJDEiLCJzeW1ib2wkMiIsInN5bWJvbCQzIiwic3ltYm9sJDQiLCJzeW1ib2wkNSIsInN5bWJvbCQ2Iiwic3ltYm9sJDciLCJzeW1ib2wkOCIsInN5bWJvbCQ5Iiwibm9fZW52IiwibWFrZV9wcCIsInJlcSIsImRyaXZlcl9pbmZvIiwicHBfd2l0aF9wYXJhbV9lbmFibGVkIiwibWFrZV9wcF93aXRoX3BhcmFtIiwicGFyYW0kMCIsImtleXMiLCJtYXhfc2l6ZSIsIm1heF9pZGxlX3NpemUiLCJtYXhfaWRsZV9hZ2UiLCJtYXhfdXNlX2NvdW50Iiwib3B0aW9uX29mX3N0cmluZyIsIm10aW1lX3NwYW5fb2Zfc3RyaW5nIiwiZGVmYXVsdCQwIiwiZGVmYXVsdF9mcm9tX2VudiIsImdldCIsImNvbnYiLCJzZngiLCJzdHIiLCJ2YWx1ZSIsImNvbmZpZyIsIm1vZGlmeSIsInNldCIsInVuc2V0IiwibWVyZ2VfbGVmdCIsImNMIiwiY1IiLCJhZGQiLCJjcmVhdGVfa2V5IiwibWVtX25hbWUiLCJrZXlfbmFtZSIsIktleSIsInJlc2V0IiwidHdlYWtzX3ZlcnNpb24iXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jYXF0aS9jYXF0aV90eXBlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY2FxdGkvY2FxdGlfcXVlcnkubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jYXF0aS9jYXF0aV9lcnJvci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NhcXRpL2NhcXRpX2RyaXZlcl9pbmZvLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY2FxdGkvY2FxdGlfbXVsdC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NhcXRpL2NhcXRpX3JlcXVlc3QubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jYXF0aS9jYXF0aV9xdWVyeV9mbXQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jYXF0aS9jYXF0aV9wb29sX2NvbmZpZy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NhcXRpL2NhcXRpX2Nvbm5lY3RfY29uZmlnLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHQWlCQTs7OztJQXdZTUE7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7Ozs7Ozs7Ozs7SUFsWk47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQW9CTUMsTUFDRUMsS0FBSUM7SUFDUjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBRElEOzs7Ozs7Ozs7Z0NBQUFBOztzQ0FBSUM7K0JBQUFBOzRC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Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7WUN2REFrQixXQUlJMVYsTUFDQTJVO0lBRlU7SUFGQyxnQkFHWDNVLE1BQ0EyVTtHQUVnQzs7O0lBUXBDQTtZQUVBZ0IsU0FBU0MsVUFBVyxPQUFBLDJCQUFYQSxVQUFrQztZQUUzQ2YsSUFBb0NnQixLQUFhN1U7SUFDNUMsWUFBQSwyQkFEK0I2VSxRQUFhN1U7OzttQkFBYjZVLFlBRVg1TSxZQUFPLE9BQVBBOztXQUZXNE07R0FHbEI7WUFFbEJULElBQXlDUyxLQUFhNU0sR0FBRWpJO0lBQzFELE9BQUEsMEJBRDJDNlUsWUFBQUEsUUFBYTVNLElBQUVqSTtHQUNWO1lBRTlDOFUsTUFBc0NELEtBQWE3VSxHQUNyRCxPQUFBLDBCQUR3QzZVLFFBQWE3VSxHQUN6QjtHQUlTO0lBQW5DK1UsaUJBaENBTDs7VUFlQWYsV0FJQUUsS0FLQU8sS0FHQVUsT0FLQUMsZ0JBaENBTCxZQWlCQUM7Ozs7RTs7Ozs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIENvcHlyaWdodCAoQykgMjAxNy0tMjAyMyAgUGV0dGVyIEEuIFVya2VkYWwgPHBhdXJrZWRhbEBnbWFpbC5jb20+XG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXJcbiAqIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24sIHdpdGggdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYW5kIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbiBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeS4gIElmIG5vdCwgc2VlXG4gKiA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4gYW5kIDxodHRwczovL3NwZHgub3JnPiwgcmVzcGVjdGl2ZWx5LlxuICopXG5cbmV4Y2VwdGlvbiBSZWplY3Qgb2Ygc3RyaW5nXG5cbnR5cGUgKF8sIF8pIGVxID0gRXF1YWwgOiAoJ2EsICdhKSBlcSAoKiBPQ2FtbCA1LjEgKilcblxubW9kdWxlIEZpZWxkID0gc3RydWN0XG5cbiAgdHlwZSAnYSB0ID1cbiAgICB8IEJvb2wgOiBib29sIHRcbiAgICB8IEludCA6IGludCB0XG4gICAgfCBJbnQxNiA6IGludCB0XG4gICAgfCBJbnQzMiA6IGludDMyIHRcbiAgICB8IEludDY0IDogaW50NjQgdFxuICAgIHwgRmxvYXQgOiBmbG9hdCB0XG4gICAgfCBTdHJpbmcgOiBzdHJpbmcgdFxuICAgIHwgT2N0ZXRzIDogc3RyaW5nIHRcbiAgICB8IFBkYXRlIDogUHRpbWUudCB0XG4gICAgfCBQdGltZSA6IFB0aW1lLnQgdFxuICAgIHwgUHRpbWVfc3BhbiA6IFB0aW1lLnNwYW4gdFxuICAgIHwgRW51bSA6IHN0cmluZyAtPiBzdHJpbmcgdFxuXG4gIGxldCB1bmlmeSA6IHR5cGUgYSBiLiBhIHQgLT4gYiB0IC0+IChhLCBiKSBlcSBvcHRpb24gPVxuICAgIGZ1biBmdDEgZnQyIC0+XG4gICAgKG1hdGNoIGZ0MSwgZnQyIHdpdGhcbiAgICAgfCBCb29sLCBCb29sIC0+IFNvbWUgRXF1YWxcbiAgICAgfCBCb29sLCBfIHwgXywgQm9vbCAtPiBOb25lXG4gICAgIHwgSW50LCBJbnQgLT4gU29tZSBFcXVhbFxuICAgICB8IEludCwgXyB8IF8sIEludCAtPiBOb25lXG4gICAgIHwgSW50MTYsIEludDE2IC0+IFNvbWUgRXF1YWxcbiAgICAgfCBJbnQxNiwgXyB8IF8sIEludDE2IC0+IE5vbmVcbiAgICAgfCBJbnQzMiwgSW50MzIgLT4gU29tZSBFcXVhbFxuICAgICB8IEludDMyLCBfIHwgXywgSW50MzIgLT4gTm9uZVxuICAgICB8IEludDY0LCBJbnQ2NCAtPiBTb21lIEVxdWFsXG4gICAgIHwgSW50NjQsIF8gfCBfLCBJbnQ2NCAtPiBOb25lXG4gICAgIHwgRmxvYXQsIEZsb2F0IC0+IFNvbWUgRXF1YWxcbiAgICAgfCBGbG9hdCwgXyB8IF8sIEZsb2F0IC0+IE5vbmVcbiAgICAgfCBTdHJpbmcsIFN0cmluZyAtPiBTb21lIEVxdWFsXG4gICAgIHwgU3RyaW5nLCBfIHwgXywgU3RyaW5nIC0+IE5vbmVcbiAgICAgfCBPY3RldHMsIE9jdGV0cyAtPiBTb21lIEVxdWFsXG4gICAgIHwgT2N0ZXRzLCBfIHwgXywgT2N0ZXRzIC0+IE5vbmVcbiAgICAgfCBQZGF0ZSwgUGRhdGUgLT4gU29tZSBFcXVhbFxuICAgICB8IFBkYXRlLCBfIHwgXywgUGRhdGUgLT4gTm9uZVxuICAgICB8IFB0aW1lLCBQdGltZSAtPiBTb21lIEVxdWFsXG4gICAgIHwgUHRpbWUsIF8gfCBfLCBQdGltZSAtPiBOb25lXG4gICAgIHwgUHRpbWVfc3BhbiwgUHRpbWVfc3BhbiAtPiBTb21lIEVxdWFsXG4gICAgIHwgUHRpbWVfc3BhbiwgXyB8IF8sIFB0aW1lX3NwYW4gLT4gTm9uZVxuICAgICB8IEVudW0gbmFtZTEsIEVudW0gbmFtZTIgd2hlbiBuYW1lMSA9IG5hbWUyIC0+IFNvbWUgRXF1YWxcbiAgICAgfCBFbnVtIF8sIEVudW0gXyAtPiBOb25lKVxuXG4gIGxldCBlcXVhbF92YWx1ZSA6IHR5cGUgYS4gYSB0IC0+IGEgLT4gYSAtPiBib29sID0gZnVuY3Rpb25cbiAgIHwgQm9vbCAtPiBCb29sLmVxdWFsXG4gICB8IEludCAtPiBJbnQuZXF1YWxcbiAgIHwgSW50MTYgLT4gSW50LmVxdWFsXG4gICB8IEludDMyIC0+IEludDMyLmVxdWFsXG4gICB8IEludDY0IC0+IEludDY0LmVxdWFsXG4gICB8IEZsb2F0IC0+IEZsb2F0LmVxdWFsXG4gICB8IFN0cmluZyAtPiBTdHJpbmcuZXF1YWxcbiAgIHwgT2N0ZXRzIC0+IFN0cmluZy5lcXVhbFxuICAgfCBQZGF0ZSAtPiBQdGltZS5lcXVhbFxuICAgfCBQdGltZSAtPiBQdGltZS5lcXVhbFxuICAgfCBQdGltZV9zcGFuIC0+IFB0aW1lLlNwYW4uZXF1YWxcbiAgIHwgRW51bSBfIC0+IFN0cmluZy5lcXVhbFxuXG4gIGxldCB0b19zdHJpbmcgOiB0eXBlIGEuIGEgdCAtPiBzdHJpbmcgPSBmdW5jdGlvblxuICAgfCBCb29sIC0+IFwiYm9vbFwiXG4gICB8IEludCAtPiBcImludFwiXG4gICB8IEludDE2IC0+IFwiaW50MTZcIlxuICAgfCBJbnQzMiAtPiBcImludDMyXCJcbiAgIHwgSW50NjQgLT4gXCJpbnQ2NFwiXG4gICB8IEZsb2F0IC0+IFwiZmxvYXRcIlxuICAgfCBTdHJpbmcgLT4gXCJzdHJpbmdcIlxuICAgfCBPY3RldHMgLT4gXCJvY3RldHNcIlxuICAgfCBQZGF0ZSAtPiBcInBkYXRlXCJcbiAgIHwgUHRpbWUgLT4gXCJwdGltZVwiXG4gICB8IFB0aW1lX3NwYW4gLT4gXCJwdGltZV9zcGFuXCJcbiAgIHwgRW51bSBuYW1lIC0+IG5hbWVcblxuICBsZXQgcHAgcHBmIGZ0ID0gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKHRvX3N0cmluZyBmdClcblxuICBsZXQgcHBfcHRpbWUgPSBQdGltZS5wcF9yZmMzMzM5IH50el9vZmZzZXRfczowIH5zcGFjZTpmYWxzZSAoKVxuXG4gIGxldCBwcF92YWx1ZSA6IHR5cGUgYS4gXyAtPiBhIHQgKiBhIC0+IHVuaXQgPSBmdW4gcHBmIC0+IGZ1bmN0aW9uXG4gICB8IEJvb2wsIHggLT4gRm9ybWF0LnBwX3ByaW50X2Jvb2wgcHBmIHhcbiAgIHwgSW50LCB4IC0+IEZvcm1hdC5wcF9wcmludF9pbnQgcHBmIHhcbiAgIHwgSW50MTYsIHggLT4gRm9ybWF0LnBwX3ByaW50X2ludCBwcGYgeFxuICAgfCBJbnQzMiwgeCAtPiBGb3JtYXQuZnByaW50ZiBwcGYgXCIlbGRsXCIgeFxuICAgfCBJbnQ2NCwgeCAtPiBGb3JtYXQuZnByaW50ZiBwcGYgXCIlTGRMXCIgeFxuICAgfCBGbG9hdCwgeCAtPiBGb3JtYXQuZnByaW50ZiBwcGYgXCIlRlwiIHhcbiAgIHwgU3RyaW5nLCB4IC0+IEZvcm1hdC5mcHJpbnRmIHBwZiBcIiVTXCIgeFxuICAgfCBPY3RldHMsIHggLT4gRm9ybWF0LmZwcmludGYgcHBmIFwiJVNcIiB4XG4gICB8IFBkYXRlLCB4IC0+XG4gICAgICBsZXQgeSwgbSwgZCA9IFB0aW1lLnRvX2RhdGUgeCBpblxuICAgICAgRm9ybWF0LmZwcmludGYgcHBmIFwiJWQtJTAyZC0lMDJkXCIgeSBtIGRcbiAgIHwgUHRpbWUsIHggLT4gcHBfcHRpbWUgcHBmIHhcbiAgIHwgUHRpbWVfc3BhbiwgeCAtPiBQdGltZS5TcGFuLnBwIHBwZiB4XG4gICB8IEVudW0gXywgeCAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiB4XG5lbmRcblxudHlwZSBfIHJlY29yZF9zZXJpYWwgPSAuLlxuXG50eXBlICdhIHByb2R1Y3RfaWQgPSB7XG4gIHNlcmlhbDogJ2EgcmVjb3JkX3NlcmlhbDtcbiAgaXNfc2VyaWFsOiAnYi4gJ2IgcmVjb3JkX3NlcmlhbCAtPiAoJ2EsICdiKSBlcSBvcHRpb247XG59XG5cbmxldCBtYWtlX2lkICh0eXBlIGEpICgpIDogYSBwcm9kdWN0X2lkID1cbiAgbGV0IG1vZHVsZSBNID0gc3RydWN0XG4gICAgdHlwZSBfIHJlY29yZF9zZXJpYWwgKz0gU2VyaWFsIDogYSByZWNvcmRfc2VyaWFsXG4gIGVuZCBpblxuICBsZXQgaXNfc2VyaWFsIDogdHlwZSBiLiBiIHJlY29yZF9zZXJpYWwgLT4gKGEsIGIpIGVxIG9wdGlvbiA9IGZ1bmN0aW9uXG4gICB8IE0uU2VyaWFsIC0+IFNvbWUgRXF1YWxcbiAgIHwgXyAtPiBOb25lXG4gIGluXG4gIHtzZXJpYWwgPSBNLlNlcmlhbDsgaXNfc2VyaWFsfVxuXG5sZXQgdW5pZnlfaWQge2lzX3NlcmlhbDsgX30ge3NlcmlhbDsgX30gPSBpc19zZXJpYWwgc2VyaWFsXG5cbnR5cGUgXyB0ID1cbiAgfCBGaWVsZCA6ICdhIEZpZWxkLnQgLT4gJ2EgdFxuICB8IE9wdGlvbiA6ICdhIHQgLT4gJ2Egb3B0aW9uIHRcbiAgfCBQcm9kdWN0IDogJ2EgcHJvZHVjdF9pZCAqICdpICogKCdhLCAnaSkgcHJvZHVjdCAtPiAnYSB0XG4gIHwgQW5ub3QgOiBbYFJlZGFjdGVkXSAqICdhIHQgLT4gJ2EgdFxuYW5kIChfLCBfKSBwcm9kdWN0ID1cbiAgfCBQcm9qX2VuZCA6ICgnYSwgJ2EpIHByb2R1Y3RcbiAgfCBQcm9qIDogJ2IgdCAqICgnYSAtPiAnYikgKiAoJ2EsICdpKSBwcm9kdWN0IC0+ICgnYSwgJ2IgLT4gJ2kpIHByb2R1Y3RcblxudHlwZSBhbnkgPSBBbnkgOiAnYSB0IC0+IGFueVxuXG5sZXQgcmVjIHVuaWZ5IDogdHlwZSBhIGIuIGEgdCAtPiBiIHQgLT4gKGEsIGIpIGVxIG9wdGlvbiA9XG4gIGZ1biB0MSB0MiAtPlxuICAobWF0Y2ggdDEsIHQyIHdpdGhcbiAgIHwgRmllbGQgZnQxLCBGaWVsZCBmdDIgLT4gRmllbGQudW5pZnkgZnQxIGZ0MlxuICAgfCBGaWVsZCBfLCBfIHwgXywgRmllbGQgXyAtPiBOb25lXG4gICB8IE9wdGlvbiB0MSwgT3B0aW9uIHQyIC0+XG4gICAgICAobWF0Y2ggdW5pZnkgdDEgdDIgd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIEVxdWFsIC0+IFNvbWUgRXF1YWwpXG4gICB8IE9wdGlvbiBfLCBfIHwgXywgT3B0aW9uIF8gLT4gTm9uZVxuICAgfCBQcm9kdWN0IChpZDEsIF8sIF8pLCBQcm9kdWN0IChpZDIsIF8sIF8pIC0+IHVuaWZ5X2lkIGlkMSBpZDJcbiAgIHwgUHJvZHVjdCBfLCBfIHwgXywgUHJvZHVjdCBfIC0+IE5vbmVcbiAgIHwgQW5ub3QgKGBSZWRhY3RlZCwgdDEpLCBBbm5vdCAoYFJlZGFjdGVkLCB0MikgLT4gdW5pZnkgdDEgdDIpXG5cbmxldCBlcXVhbF9vcHRpb24gZiB4IHkgPVxuICAobWF0Y2ggeCwgeSB3aXRoXG4gICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICAgfCBTb21lIHgsIFNvbWUgeSAtPiBmIHggeVxuICAgfCBOb25lLCBTb21lIF8gfCBTb21lIF8sIE5vbmUgLT4gZmFsc2UpXG5sZXQgcmVjIGVxdWFsX3ZhbHVlIDogdHlwZSBhLiBhIHQgLT4gYSAtPiBhIC0+IGJvb2wgPVxuICAoZnVuY3Rpb25cbiAgIHwgRmllbGQgZnQgLT4gRmllbGQuZXF1YWxfdmFsdWUgZnRcbiAgIHwgT3B0aW9uIHQgLT4gZXF1YWxfb3B0aW9uIChlcXVhbF92YWx1ZSB0KVxuICAgfCBQcm9kdWN0IChfLCBfLCBwcm9kKSAtPiBlcXVhbF92YWx1ZV9wcm9kIHByb2RcbiAgIHwgQW5ub3QgKF8sIHQpIC0+IGVxdWFsX3ZhbHVlIHQpXG5hbmQgZXF1YWxfdmFsdWVfcHJvZCA6IHR5cGUgYSBpLiAoYSwgaSkgcHJvZHVjdCAtPiBhIC0+IGEgLT4gYm9vbCA9XG4gIChmdW5jdGlvblxuICAgfCBQcm9qX2VuZCAtPiBmdW4gXyBfIC0+IHRydWVcbiAgIHwgUHJvaiAodCwgcCwgcHJvZCkgLT5cbiAgICAgIGxldCBlcV9maXJzdCA9IGVxdWFsX3ZhbHVlIHQgaW5cbiAgICAgIGxldCBlcV9yZXN0ID0gZXF1YWxfdmFsdWVfcHJvZCBwcm9kIGluXG4gICAgICBmdW4geCB5IC0+IGVxX2ZpcnN0IChwIHgpIChwIHkpICYmIGVxX3Jlc3QgeCB5KVxuXG5sZXQgcmVjIGxlbmd0aCA6IHR5cGUgYS4gYSB0IC0+IGludCA9IGZ1bmN0aW9uXG4gfCBGaWVsZCBfIC0+IDFcbiB8IE9wdGlvbiB0IC0+IGxlbmd0aCB0XG4gfCBQcm9kdWN0IChfLCBfLCBwcm9kKSAtPlxuICAgIGxldCByZWMgbG9vcCA6IHR5cGUgYSBpLiAoYSwgaSkgcHJvZHVjdCAtPiBfIC0+IF8gPSBmdW5jdGlvblxuICAgICB8IFByb2pfZW5kIC0+IEZ1bi5pZFxuICAgICB8IFByb2ogKHQsIF8sIHByb2QpIC0+IGZ1biBuIC0+IGxvb3AgcHJvZCAobiArIGxlbmd0aCB0KVxuICAgIGluXG4gICAgbG9vcCBwcm9kIDBcbiB8IEFubm90IChfLCB0KSAtPiBsZW5ndGggdFxuXG5sZXQgcmVjIHBwX2F0IDogdHlwZSBhLiBpbnQgLT4gRm9ybWF0LmZvcm1hdHRlciAtPiBhIHQgLT4gdW5pdCA9XG4gICAgZnVuIHByZWMgcHBmIC0+IGZ1bmN0aW9uXG4gfCBGaWVsZCBmdCAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiAoRmllbGQudG9fc3RyaW5nIGZ0KVxuIHwgT3B0aW9uIHQgLT4gcHBfYXQgMSBwcGYgdDsgRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgXCIgb3B0aW9uXCJcbiB8IFByb2R1Y3QgKF8sIF8sIFByb2pfZW5kKSAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiBcInVuaXRcIlxuIHwgUHJvZHVjdCAoXywgXywgUHJvaiAodDAsIF8sIHByb2QpKSAtPlxuICAgIGlmIHByZWMgPiAwIHRoZW4gRm9ybWF0LnBwX3ByaW50X2NoYXIgcHBmICcoJztcbiAgICBsZXQgcmVjIGxvb3AgOiB0eXBlIGEgaS4gKGEsIGkpIHByb2R1Y3QgLT4gXyA9IGZ1bmN0aW9uXG4gICAgIHwgUHJval9lbmQgLT4gKClcbiAgICAgfCBQcm9qICh0LCBfLCBwcm9kKSAtPlxuICAgICAgICBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiBcIiDDlyBcIjtcbiAgICAgICAgcHBfYXQgMSBwcGYgdDtcbiAgICAgICAgbG9vcCBwcm9kXG4gICAgaW5cbiAgICBwcF9hdCAxIHBwZiB0MDtcbiAgICBsb29wIHByb2Q7XG4gICAgaWYgcHJlYyA+IDAgdGhlbiBGb3JtYXQucHBfcHJpbnRfY2hhciBwcGYgJyknXG4gfCBBbm5vdCAoYFJlZGFjdGVkLCB0KSAtPlxuICAgIHBwX2F0IDEgcHBmIHQ7XG4gICAgRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgXCIgcmVkYWN0ZWRcIlxuXG5sZXQgcHAgcHBmID0gcHBfYXQgMCBwcGZcbmxldCBwcF9hbnkgcHBmIChBbnkgdCkgPSBwcF9hdCAwIHBwZiB0XG5cbmxldCByZWMgcHBfdmFsdWUgOiB0eXBlIGEuIF8gLT4gYSB0ICogYSAtPiB1bml0ID0gZnVuIHBwZiAtPiBmdW5jdGlvblxuIHwgRmllbGQgZnQsIGZ2IC0+IEZpZWxkLnBwX3ZhbHVlIHBwZiAoZnQsIGZ2KVxuIHwgT3B0aW9uIF8sIE5vbmUgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgXCJOb25lXCJcbiB8IE9wdGlvbiB0LCBTb21lIHggLT5cbiAgICBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiBcIlNvbWUgXCI7XG4gICAgcHBfdmFsdWUgcHBmICh0LCB4KVxuIHwgUHJvZHVjdCAoXywgXywgcHJvZCksIHggLT5cbiAgICBsZXQgcmVjIGxvb3AgOiB0eXBlIGkuIGludCAtPiAoYSwgaSkgcHJvZHVjdCAtPiBfID0gZnVuIGkgLT4gZnVuY3Rpb25cbiAgICAgfCBQcm9qX2VuZCAtPiAoKVxuICAgICB8IFByb2ogKHQsIHAsIHByb2QpIC0+XG4gICAgICAgIGlmIGkgPiAwIHRoZW4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgXCIsIFwiO1xuICAgICAgICBwcF92YWx1ZSBwcGYgKHQsIHAgeCk7XG4gICAgICAgIGxvb3AgKGkgKyAxKSBwcm9kXG4gICAgaW5cbiAgICBsb29wIDAgcHJvZFxuIHwgQW5ub3QgKGBSZWRhY3RlZCwgXyksIF8gLT5cbiAgICBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiBcIiNyZWRhY3RlZCNcIlxuXG5sZXQgc2hvdyB0ID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgbGV0IHBwZiA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICBwcCBwcGYgdDtcbiAgRm9ybWF0LnBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG5sZXQgZmllbGQgZnQgPSBGaWVsZCBmdFxuXG5tb2R1bGUgU3RkID0gc3RydWN0XG4gIGxldCBvcHRpb24gdCA9IE9wdGlvbiB0XG5cbiAgbGV0IHByb2R1Y3QgaW50cm8gcHJvZCA9IFByb2R1Y3QgKG1ha2VfaWQgKCksIGludHJvLCBwcm9kKVxuICBsZXQgcHJvaiB0IHAgcHJvZCA9IFByb2ogKHQsIHAsIHByb2QpXG4gIGxldCBwcm9qX2VuZCA9IFByb2pfZW5kXG5cbiAgbGV0IHVuaXQgPSBwcm9kdWN0ICgpIHByb2pfZW5kXG5cbiAgbGV0IHQyIHQxIHQyID1cbiAgICBsZXQgaW50cm8geDEgeDIgPSAoeDEsIHgyKSBpblxuICAgIHByb2R1Y3QgaW50cm9cbiAgICAgIEBAIHByb2ogdDEgZnN0XG4gICAgICBAQCBwcm9qIHQyIHNuZFxuICAgICAgQEAgcHJval9lbmRcblxuICBsZXQgdDMgdDEgdDIgdDMgPVxuICAgIGxldCBpbnRybyB4MSB4MiB4MyA9ICh4MSwgeDIsIHgzKSBpblxuICAgIHByb2R1Y3QgaW50cm9cbiAgICAgIEBAIHByb2ogdDEgKGZ1biAoeCwgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDIgKGZ1biAoXywgeCwgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDMgKGZ1biAoXywgXywgeCkgLT4geClcbiAgICAgIEBAIHByb2pfZW5kXG5cbiAgbGV0IHQ0IHQxIHQyIHQzIHQ0ID1cbiAgICBsZXQgaW50cm8geDEgeDIgeDMgeDQgPSAoeDEsIHgyLCB4MywgeDQpIGluXG4gICAgcHJvZHVjdCBpbnRyb1xuICAgICAgQEAgcHJvaiB0MSAoZnVuICh4LCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MiAoZnVuIChfLCB4LCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MyAoZnVuIChfLCBfLCB4LCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NCAoZnVuIChfLCBfLCBfLCB4KSAtPiB4KVxuICAgICAgQEAgcHJval9lbmRcblxuICBsZXQgdDUgdDEgdDIgdDMgdDQgdDUgPVxuICAgIGxldCBpbnRybyB4MSB4MiB4MyB4NCB4NSA9ICh4MSwgeDIsIHgzLCB4NCwgeDUpIGluXG4gICAgcHJvZHVjdCBpbnRyb1xuICAgICAgQEAgcHJvaiB0MSAoZnVuICh4LCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MiAoZnVuIChfLCB4LCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MyAoZnVuIChfLCBfLCB4LCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NCAoZnVuIChfLCBfLCBfLCB4LCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NSAoZnVuIChfLCBfLCBfLCBfLCB4KSAtPiB4KVxuICAgICAgQEAgcHJval9lbmRcblxuICBsZXQgdDYgdDEgdDIgdDMgdDQgdDUgdDYgPVxuICAgIGxldCBpbnRybyB4MSB4MiB4MyB4NCB4NSB4NiA9ICh4MSwgeDIsIHgzLCB4NCwgeDUsIHg2KSBpblxuICAgIHByb2R1Y3QgaW50cm9cbiAgICAgIEBAIHByb2ogdDEgKGZ1biAoeCwgXywgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDIgKGZ1biAoXywgeCwgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDMgKGZ1biAoXywgXywgeCwgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDQgKGZ1biAoXywgXywgXywgeCwgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDUgKGZ1biAoXywgXywgXywgXywgeCwgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDYgKGZ1biAoXywgXywgXywgXywgXywgeCkgLT4geClcbiAgICAgIEBAIHByb2pfZW5kXG5cbiAgbGV0IHQ3IHQxIHQyIHQzIHQ0IHQ1IHQ2IHQ3ID1cbiAgICBsZXQgaW50cm8geDEgeDIgeDMgeDQgeDUgeDYgeDcgPSAoeDEsIHgyLCB4MywgeDQsIHg1LCB4NiwgeDcpIGluXG4gICAgcHJvZHVjdCBpbnRyb1xuICAgICAgQEAgcHJvaiB0MSAoZnVuICh4LCBfLCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MiAoZnVuIChfLCB4LCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MyAoZnVuIChfLCBfLCB4LCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NCAoZnVuIChfLCBfLCBfLCB4LCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NSAoZnVuIChfLCBfLCBfLCBfLCB4LCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NiAoZnVuIChfLCBfLCBfLCBfLCBfLCB4LCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NyAoZnVuIChfLCBfLCBfLCBfLCBfLCBfLCB4KSAtPiB4KVxuICAgICAgQEAgcHJval9lbmRcblxuICBsZXQgdDggdDEgdDIgdDMgdDQgdDUgdDYgdDcgdDggPVxuICAgIGxldCBpbnRybyB4MSB4MiB4MyB4NCB4NSB4NiB4NyB4OCA9ICh4MSwgeDIsIHgzLCB4NCwgeDUsIHg2LCB4NywgeDgpIGluXG4gICAgcHJvZHVjdCBpbnRyb1xuICAgICAgQEAgcHJvaiB0MSAoZnVuICh4LCBfLCBfLCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MiAoZnVuIChfLCB4LCBfLCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MyAoZnVuIChfLCBfLCB4LCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NCAoZnVuIChfLCBfLCBfLCB4LCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NSAoZnVuIChfLCBfLCBfLCBfLCB4LCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NiAoZnVuIChfLCBfLCBfLCBfLCBfLCB4LCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NyAoZnVuIChfLCBfLCBfLCBfLCBfLCBfLCB4LCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0OCAoZnVuIChfLCBfLCBfLCBfLCBfLCBfLCBfLCB4KSAtPiB4KVxuICAgICAgQEAgcHJval9lbmRcblxuICBsZXQgdDkgdDEgdDIgdDMgdDQgdDUgdDYgdDcgdDggdDkgPVxuICAgIGxldCBpbnRybyB4MSB4MiB4MyB4NCB4NSB4NiB4NyB4OCB4OSA9XG4gICAgICAoeDEsIHgyLCB4MywgeDQsIHg1LCB4NiwgeDcsIHg4LCB4OSlcbiAgICBpblxuICAgIHByb2R1Y3QgaW50cm9cbiAgICAgIEBAIHByb2ogdDEgKGZ1biAoeCwgXywgXywgXywgXywgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDIgKGZ1biAoXywgeCwgXywgXywgXywgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDMgKGZ1biAoXywgXywgeCwgXywgXywgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDQgKGZ1biAoXywgXywgXywgeCwgXywgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDUgKGZ1biAoXywgXywgXywgXywgeCwgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDYgKGZ1biAoXywgXywgXywgXywgXywgeCwgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDcgKGZ1biAoXywgXywgXywgXywgXywgXywgeCwgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDggKGZ1biAoXywgXywgXywgXywgXywgXywgXywgeCwgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDkgKGZ1biAoXywgXywgXywgXywgXywgXywgXywgXywgeCkgLT4geClcbiAgICAgIEBAIHByb2pfZW5kXG5cbiAgbGV0IHQxMCB0MSB0MiB0MyB0NCB0NSB0NiB0NyB0OCB0OSB0MTAgPVxuICAgIGxldCBpbnRybyB4MSB4MiB4MyB4NCB4NSB4NiB4NyB4OCB4OSB4MTAgPVxuICAgICAgKHgxLCB4MiwgeDMsIHg0LCB4NSwgeDYsIHg3LCB4OCwgeDksIHgxMClcbiAgICBpblxuICAgIHByb2R1Y3QgaW50cm9cbiAgICAgIEBAIHByb2ogdDEgIChmdW4gKHgsIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8pIC0+IHgpXG4gICAgICBAQCBwcm9qIHQyICAoZnVuIChfLCB4LCBfLCBfLCBfLCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MyAgKGZ1biAoXywgXywgeCwgXywgXywgXywgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDQgIChmdW4gKF8sIF8sIF8sIHgsIF8sIF8sIF8sIF8sIF8sIF8pIC0+IHgpXG4gICAgICBAQCBwcm9qIHQ1ICAoZnVuIChfLCBfLCBfLCBfLCB4LCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NiAgKGZ1biAoXywgXywgXywgXywgXywgeCwgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDcgIChmdW4gKF8sIF8sIF8sIF8sIF8sIF8sIHgsIF8sIF8sIF8pIC0+IHgpXG4gICAgICBAQCBwcm9qIHQ4ICAoZnVuIChfLCBfLCBfLCBfLCBfLCBfLCBfLCB4LCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0OSAgKGZ1biAoXywgXywgXywgXywgXywgXywgXywgXywgeCwgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDEwIChmdW4gKF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIHgpIC0+IHgpXG4gICAgICBAQCBwcm9qX2VuZFxuXG4gIGxldCB0MTEgdDEgdDIgdDMgdDQgdDUgdDYgdDcgdDggdDkgdDEwIHQxMSA9XG4gICAgbGV0IGludHJvIHgxIHgyIHgzIHg0IHg1IHg2IHg3IHg4IHg5IHgxMCB4MTEgPVxuICAgICAgKHgxLCB4MiwgeDMsIHg0LCB4NSwgeDYsIHg3LCB4OCwgeDksIHgxMCwgeDExKVxuICAgIGluXG4gICAgcHJvZHVjdCBpbnRyb1xuICAgICAgQEAgcHJvaiB0MSAgKGZ1biAoeCwgXywgXywgXywgXywgXywgXywgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDIgIChmdW4gKF8sIHgsIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8pIC0+IHgpXG4gICAgICBAQCBwcm9qIHQzICAoZnVuIChfLCBfLCB4LCBfLCBfLCBfLCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NCAgKGZ1biAoXywgXywgXywgeCwgXywgXywgXywgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDUgIChmdW4gKF8sIF8sIF8sIF8sIHgsIF8sIF8sIF8sIF8sIF8sIF8pIC0+IHgpXG4gICAgICBAQCBwcm9qIHQ2ICAoZnVuIChfLCBfLCBfLCBfLCBfLCB4LCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NyAgKGZ1biAoXywgXywgXywgXywgXywgXywgeCwgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDggIChmdW4gKF8sIF8sIF8sIF8sIF8sIF8sIF8sIHgsIF8sIF8sIF8pIC0+IHgpXG4gICAgICBAQCBwcm9qIHQ5ICAoZnVuIChfLCBfLCBfLCBfLCBfLCBfLCBfLCBfLCB4LCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MTAgKGZ1biAoXywgXywgXywgXywgXywgXywgXywgXywgXywgeCwgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDExIChmdW4gKF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIHgpIC0+IHgpXG4gICAgICBAQCBwcm9qX2VuZFxuXG4gIGxldCB0MTIgdDEgdDIgdDMgdDQgdDUgdDYgdDcgdDggdDkgdDEwIHQxMSB0MTIgPVxuICAgIGxldCBpbnRybyB4MSB4MiB4MyB4NCB4NSB4NiB4NyB4OCB4OSB4MTAgeDExIHgxMiA9XG4gICAgICAoeDEsIHgyLCB4MywgeDQsIHg1LCB4NiwgeDcsIHg4LCB4OSwgeDEwLCB4MTEsIHgxMilcbiAgICBpblxuICAgIHByb2R1Y3QgaW50cm9cbiAgICAgIEBAIHByb2ogdDEgIChmdW4gKHgsIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8pIC0+IHgpXG4gICAgICBAQCBwcm9qIHQyICAoZnVuIChfLCB4LCBfLCBfLCBfLCBfLCBfLCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MyAgKGZ1biAoXywgXywgeCwgXywgXywgXywgXywgXywgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDQgIChmdW4gKF8sIF8sIF8sIHgsIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8pIC0+IHgpXG4gICAgICBAQCBwcm9qIHQ1ICAoZnVuIChfLCBfLCBfLCBfLCB4LCBfLCBfLCBfLCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0NiAgKGZ1biAoXywgXywgXywgXywgXywgeCwgXywgXywgXywgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDcgIChmdW4gKF8sIF8sIF8sIF8sIF8sIF8sIHgsIF8sIF8sIF8sIF8sIF8pIC0+IHgpXG4gICAgICBAQCBwcm9qIHQ4ICAoZnVuIChfLCBfLCBfLCBfLCBfLCBfLCBfLCB4LCBfLCBfLCBfLCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0OSAgKGZ1biAoXywgXywgXywgXywgXywgXywgXywgXywgeCwgXywgXywgXykgLT4geClcbiAgICAgIEBAIHByb2ogdDEwIChmdW4gKF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIF8sIHgsIF8sIF8pIC0+IHgpXG4gICAgICBAQCBwcm9qIHQxMSAoZnVuIChfLCBfLCBfLCBfLCBfLCBfLCBfLCBfLCBfLCBfLCB4LCBfKSAtPiB4KVxuICAgICAgQEAgcHJvaiB0MTIgKGZ1biAoXywgXywgXywgXywgXywgXywgXywgXywgXywgXywgXywgeCkgLT4geClcbiAgICAgIEBAIHByb2pfZW5kXG5cbiAgbGV0IGN1c3RvbSB+ZW5jb2RlIH5kZWNvZGUgcmVwID1cbiAgICBsZXQgZW5jb2RlJyB4ID1cbiAgICAgIChtYXRjaCBlbmNvZGUgeCB3aXRoXG4gICAgICAgfCBPayB5IC0+IHlcbiAgICAgICB8IEVycm9yIG1zZyAtPiByYWlzZSAoUmVqZWN0IG1zZykpXG4gICAgaW5cbiAgICBsZXQgZGVjb2RlJyB5ID1cbiAgICAgIChtYXRjaCBkZWNvZGUgeSB3aXRoXG4gICAgICAgfCBPayB4IC0+IHhcbiAgICAgICB8IEVycm9yIG1zZyAtPiByYWlzZSAoUmVqZWN0IG1zZykpXG4gICAgaW5cbiAgICBwcm9kdWN0IGRlY29kZScgQEAgcHJvaiByZXAgZW5jb2RlJyBAQCBwcm9qX2VuZFxuXG4gIGxldCByZWRhY3RlZCB0ID0gQW5ub3QgKGBSZWRhY3RlZCwgdClcblxuICBsZXQgZW51bSB+ZW5jb2RlIH5kZWNvZGUgbmFtZSA9XG4gICAgbGV0IGRlY29kZScgeSA9XG4gICAgICAobWF0Y2ggZGVjb2RlIHkgd2l0aFxuICAgICAgIHwgT2sgeCAtPiB4XG4gICAgICAgfCBFcnJvciBtc2cgLT4gcmFpc2UgKFJlamVjdCBtc2cpKVxuICAgIGluXG4gICAgcHJvZHVjdCBkZWNvZGUnIEBAIHByb2ogKEZpZWxkIChFbnVtIG5hbWUpKSBlbmNvZGUgQEAgcHJval9lbmRcblxuICBsZXQgYm9vbCA9IEZpZWxkIEJvb2xcbiAgbGV0IGludCA9IEZpZWxkIEludFxuICBsZXQgaW50MTYgPSBGaWVsZCBJbnQxNlxuICBsZXQgaW50MzIgPSBGaWVsZCBJbnQzMlxuICBsZXQgaW50NjQgPSBGaWVsZCBJbnQ2NFxuICBsZXQgZmxvYXQgPSBGaWVsZCBGbG9hdFxuICBsZXQgc3RyaW5nID0gRmllbGQgU3RyaW5nXG4gIGxldCBvY3RldHMgPSBGaWVsZCBPY3RldHNcbiAgbGV0IHBkYXRlID0gRmllbGQgUGRhdGVcbiAgbGV0IHB0aW1lID0gRmllbGQgUHRpbWVcbiAgbGV0IHB0aW1lX3NwYW4gPSBGaWVsZCBQdGltZV9zcGFuXG5cbiAgKCogZGVwcmVjYXRlZCAqKVxuICBsZXQgdHVwMiA9IHQyXG4gIGxldCB0dXAzID0gdDNcbiAgbGV0IHR1cDQgPSB0NFxuZW5kXG5pbmNsdWRlIFN0ZFxuIiwiKCogQ29weXJpZ2h0IChDKSAyMDE5LS0yMDI0ICBQZXR0ZXIgQS4gVXJrZWRhbCA8cGF1cmtlZGFsQGdtYWlsLmNvbT5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91clxuICogb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbiwgd2l0aCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbmQgdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LiAgSWYgbm90LCBzZWVcbiAqIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPiBhbmQgPGh0dHBzOi8vc3BkeC5vcmc+LCByZXNwZWN0aXZlbHkuXG4gKilcblxudHlwZSB0ID1cbiAgfCBMIG9mIHN0cmluZ1xuICB8IFYgOiAnYSBDYXF0aV90eXBlLkZpZWxkLnQgKiAnYSAtPiB0XG4gIHwgUSBvZiBzdHJpbmdcbiAgfCBQIG9mIGludFxuICB8IEUgb2Ygc3RyaW5nXG4gIHwgUyBvZiB0IGxpc3RcblxubGV0IGNvbmNhdCA9XG4gIGxldCByZWMgbG9vcCBwZnggYWNjID0gZnVuY3Rpb25cbiAgIHwgW10gLT4gYWNjXG4gICB8IHEgOjogcXMgLT4gbG9vcCBwZnggKHBmeCA6OiBxIDo6IGFjYykgcXNcbiAgaW5cbiAgZnVuIHNlcCAtPiBmdW5jdGlvblxuICAgfCBbXSAtPiBTW11cbiAgIHwgcSA6OiBxcyAtPiBTIChxIDo6IGxvb3AgKEwgc2VwKSBbXSAoTGlzdC5yZXYgcXMpKVxuXG5sZXQgYm9vbCB4ID0gViAoQ2FxdGlfdHlwZS5GaWVsZC5Cb29sLCB4KVxubGV0IGludCB4ID0gViAoQ2FxdGlfdHlwZS5GaWVsZC5JbnQsIHgpXG5sZXQgZmxvYXQgeCA9IFYgKENhcXRpX3R5cGUuRmllbGQuRmxvYXQsIHgpXG5sZXQgc3RyaW5nIHggPSBWIChDYXF0aV90eXBlLkZpZWxkLlN0cmluZywgeClcbmxldCBvY3RldHMgeCA9IFYgKENhcXRpX3R5cGUuRmllbGQuT2N0ZXRzLCB4KVxubGV0IHBkYXRlIHggPSBWIChDYXF0aV90eXBlLkZpZWxkLlBkYXRlLCB4KVxubGV0IHB0aW1lIHggPSBWIChDYXF0aV90eXBlLkZpZWxkLlB0aW1lLCB4KVxubGV0IHB0aW1lX3NwYW4geCA9IFYgKENhcXRpX3R5cGUuRmllbGQuUHRpbWVfc3BhbiwgeClcblxubGV0IG51bGxzIHQgPSBMaXN0LmluaXQgKENhcXRpX3R5cGUubGVuZ3RoIHQpIChmdW4gXyAtPiBMXCJOVUxMXCIpXG5cbmxldCByZWMgY29uc3RfZmllbGRzIDogdHlwZSBhLiBhIENhcXRpX3R5cGUudCAtPiBhIC0+IHQgbGlzdCA9XG4gIChmdW5jdGlvblxuICAgfCBGaWVsZCBmdCAtPiBmdW4geCAtPiBbViAoZnQsIHgpXVxuICAgfCBPcHRpb24gdCAtPiAoZnVuY3Rpb24gTm9uZSAtPiBudWxscyB0IHwgU29tZSB4IC0+IGNvbnN0X2ZpZWxkcyB0IHgpXG4gICB8IFByb2R1Y3QgKF8sIF8sIHB0KSAtPiBjb25zdF9maWVsZHNfcHJvZHVjdCBwdFxuICAgfCBBbm5vdCAoXywgdCkgLT4gY29uc3RfZmllbGRzIHQpXG5hbmQgY29uc3RfZmllbGRzX3Byb2R1Y3QgOiB0eXBlIGEgaS4gKGEsIGkpIENhcXRpX3R5cGUucHJvZHVjdCAtPiBhIC0+IHQgbGlzdCA9XG4gIChmdW5jdGlvblxuICAgfCBQcm9qX2VuZCAtPiBmdW4gXyAtPiBbXVxuICAgfCBQcm9qICh0LCBwLCBwdCcpIC0+XG4gICAgICBmdW4geCAtPiBjb25zdF9maWVsZHMgdCAocCB4KSBAIGNvbnN0X2ZpZWxkc19wcm9kdWN0IHB0JyB4KVxuXG5sZXQgcmVjIGVxdWFsX2xpc3QgZiB4cyB5cyA9ICgqIHN0ZGxpYiA0LjEyLjAgKilcbiAgKG1hdGNoIHhzLCB5cyB3aXRoXG4gICB8IFtdLCBbXSAtPiB0cnVlXG4gICB8IHggOjogeHMnLCB5IDo6IHlzJyAtPiBmIHggeSAmJiBlcXVhbF9saXN0IGYgeHMnIHlzJ1xuICAgfCBbXSwgXyA6OiBfIHwgXyA6OiBfLCBbXSAtPiBmYWxzZSlcblxubGV0IG5vcm1hbCA9XG4gIGxldCByZWMgY29sbGVjdCBhY2MgPSBmdW5jdGlvblxuICAgfCBbXSAtPiBMaXN0LnJldiBhY2NcbiAgIHwgKChMXCJcIiB8IFNbXSkgOjogcXMpIC0+IGNvbGxlY3QgYWNjIHFzXG4gICB8ICgoUCBfIHwgViBfIHwgUSBfIHwgRSBfIGFzIHEpIDo6IHFzKSAtPiBjb2xsZWN0IChxIDo6IGFjYykgcXNcbiAgIHwgKFMgKHEnIDo6IHFzJykgOjogcXMpIC0+IGNvbGxlY3QgYWNjIChxJyA6OiBTIHFzJyA6OiBxcylcbiAgIHwgKEwgcyA6OiBxcykgLT4gY29sbGVjdEwgYWNjIFtzXSBxc1xuICBhbmQgY29sbGVjdEwgYWNjIGFjY0wgPSBmdW5jdGlvblxuICAgfCAoKExcIlwiIHwgU1tdKSA6OiBxcykgLT4gY29sbGVjdEwgYWNjIGFjY0wgcXNcbiAgIHwgKEwgcyA6OiBxcykgLT4gY29sbGVjdEwgYWNjIChzIDo6IGFjY0wpIHFzXG4gICB8IChTIChxJyA6OiBxcycpIDo6IHFzKSAtPiBjb2xsZWN0TCBhY2MgYWNjTCAocScgOjogUyBxcycgOjogcXMpXG4gICB8IFtdIHwgKChQIF8gfCBWIF8gfCBRIF8gfCBFIF8pIDo6IF8pIGFzIHFzIC0+XG4gICAgICBjb2xsZWN0IChMIChTdHJpbmcuY29uY2F0IFwiXCIgKExpc3QucmV2IGFjY0wpKSA6OiBhY2MpIHFzXG4gIGluXG4gIGZ1biBxIC0+XG4gICAgKG1hdGNoIGNvbGxlY3QgW10gW3FdIHdpdGhcbiAgICAgfCBbXSAtPiBTW11cbiAgICAgfCBbcV0gLT4gcVxuICAgICB8IHFzIC0+IFMgcXMpXG5cbmxldCByZWMgZXF1YWwgdDEgdDIgPVxuICAobWF0Y2ggdDEsIHQyIHdpdGhcbiAgIHwgTCBzMSwgTCBzMiAtPiBTdHJpbmcuZXF1YWwgczEgczJcbiAgIHwgViAodDEsIHYxKSwgViAodDIsIHYyKSAtPlxuICAgICAgKG1hdGNoIENhcXRpX3R5cGUuRmllbGQudW5pZnkgdDEgdDIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgIHwgU29tZSBDYXF0aV90eXBlLkVxdWFsIC0+IENhcXRpX3R5cGUuRmllbGQuZXF1YWxfdmFsdWUgdDEgdjEgdjIpXG4gICB8IFEgczEsIFEgczIgLT4gU3RyaW5nLmVxdWFsIHMxIHMyXG4gICB8IFAgaTEsIFAgaTIgLT4gSW50LmVxdWFsIGkxIGkyXG4gICB8IEUgbjEsIEUgbjIgLT4gU3RyaW5nLmVxdWFsIG4xIG4yXG4gICB8IFMgdHMxLCBTIHRzMiAtPiBlcXVhbF9saXN0IGVxdWFsIHRzMSB0czJcbiAgIHwgViBfLCBfIC0+IGZhbHNlXG4gICB8IEwgXywgXyAtPiBmYWxzZVxuICAgfCBRIF8sIF8gLT4gZmFsc2VcbiAgIHwgUCBfLCBfIC0+IGZhbHNlXG4gICB8IEUgXywgXyAtPiBmYWxzZVxuICAgfCBTIF8sIF8gLT4gZmFsc2UpXG5cbmxldCBoYXNoID0gSGFzaHRibC5oYXNoXG5cbmxldCByZWMgcHAgcHBmID0gZnVuY3Rpb25cbiB8IEwgcyAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiBzXG4gfCBWICh0LCB2KSAtPiBDYXF0aV90eXBlLkZpZWxkLnBwX3ZhbHVlIHBwZiAodCwgdilcbiB8IFEgcyAtPlxuICAgICgqIFVzaW5nIG5vbi1TUUwgcXVvdGluZywgdG8gYXZvaWQgaXNzdWVzIHdpdGggbmV3bGluZXMgYW5kIG90aGVyIGNvbnRyb2xcbiAgICAgKiBjaGFyYWN0ZXJzIHdoZW4gcHJpbnRpbmcgdG8gbG9nIGZpbGVzLiAqKVxuICAgIEZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmIFwiRSdcIjtcbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgKG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgICB8ICdcXFxcJyAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiB7fFxcXFx8fVxuICAgICAgIHwgJ1xcJycgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYge3xcXCd8fVxuICAgICAgIHwgJ1xcdCcgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYge3xcXHR8fVxuICAgICAgIHwgJ1xcbicgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYge3xcXG58fVxuICAgICAgIHwgJ1xccicgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYge3xcXHJ8fVxuICAgICAgIHwgJ1xceDAwJy4uJ1xceDFmJyBhcyBjIC0+IEZvcm1hdC5mcHJpbnRmIHBwZiB7fFxceCUwMnh8fSAoQ2hhci5jb2RlIGMpXG4gICAgICAgfCBfIC0+IEZvcm1hdC5wcF9wcmludF9jaGFyIHBwZiBzLltpXSlcbiAgICBkb25lO1xuICAgIEZvcm1hdC5wcF9wcmludF9jaGFyIHBwZiAnXFwnJ1xuIHwgUCBuIC0+IEZvcm1hdC5wcF9wcmludF9jaGFyIHBwZiAnJCc7IEZvcm1hdC5wcF9wcmludF9pbnQgcHBmIChuICsgMSlcbiB8IEUgbiAtPiBGb3JtYXQuZnByaW50ZiBwcGYgXCIkKCVzKVwiIG5cbiB8IFMgcXMgLT4gTGlzdC5pdGVyIChwcCBwcGYpIHFzXG5cbmxldCBzaG93IHEgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSA1MTIgaW5cbiAgbGV0IHBwZiA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICBwcCBwcGYgcTsgRm9ybWF0LnBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG50eXBlIGV4cGFuZF9lcnJvciA9IHtcbiAgcXVlcnk6IHQ7XG4gIHZhcjogc3RyaW5nO1xuICByZWFzb246IFtgVW5kZWZpbmVkIHwgYEludmFsaWQgb2YgdF07XG59XG5cbmxldCBwcF9leHBhbmRfZXJyb3IgcHBmIHtxdWVyeTsgdmFyOyByZWFzb259ID1cbiAgbGV0IG9wZW4gRm9ybWF0IGluXG4gIChtYXRjaCByZWFzb24gd2l0aFxuICAgfCBgVW5kZWZpbmVkIC0+XG4gICAgICBmcHJpbnRmIHBwZiBcIlVuZGVmaW5lZCB2YXJpYWJsZSAlcyBpbiBxdWVyeSAlYVwiIHZhciBwcCBxdWVyeVxuICAgfCBgSW52YWxpZCBleHBhbnNpb24gLT5cbiAgICAgIGZwcmludGYgcHBmXG4gICAgICAgIFwiV2hpbGUgZXhwYW5kaW5nICVhLCBsb29rdXAgb2YgJXMgZ2l2ZXMgJWEsIHdoaWNoIGlzIGludmFsaWQgXFxcbiAgICAgICAgIGJlY2F1c2UgaXQgY29udGFpbnMgYW4gZW52aXJvbm1lbnQgb3IgcGFyYW1ldGVyIHJlZmVyZW5jZS5cIlxuICAgICAgICBwcCBxdWVyeSB2YXIgcHAgZXhwYW5zaW9uKVxuXG5leGNlcHRpb24gRXhwYW5kX2Vycm9yIG9mIGV4cGFuZF9lcnJvclxuXG5sZXQgZXhwYW5kID8oZmluYWwgPSBmYWxzZSkgZiBxdWVyeSA9XG4gIGxldCByZWMgaXNfdmFsaWQgPSBmdW5jdGlvblxuICAgfCBMIF8gfCBWIF8gfCBRIF8gLT4gdHJ1ZVxuICAgfCBQIF8gfCBFIF8gLT4gZmFsc2VcbiAgIHwgUyBxcyAtPiBMaXN0LmZvcl9hbGwgaXNfdmFsaWQgcXNcbiAgaW5cbiAgbGV0IHJlYyByZWN1cnNlID0gZnVuY3Rpb25cbiAgIHwgTCBfIHwgViBfIHwgUSBfIHwgUCBfIGFzIHEgLT4gcVxuICAgfCBFIHZhciBhcyBxIC0+XG4gICAgICBsZXQgbm90X2ZvdW5kICgpID1cbiAgICAgICAgaWYgbm90IGZpbmFsIHRoZW4gcSBlbHNlXG4gICAgICAgIHJhaXNlIChFeHBhbmRfZXJyb3Ige3F1ZXJ5OyB2YXI7IHJlYXNvbiA9IGBVbmRlZmluZWR9KVxuICAgICAgaW5cbiAgICAgIChtYXRjaCBmIHZhciB3aXRoXG4gICAgICAgfCBxJyAtPlxuICAgICAgICAgIGlmIGlzX3ZhbGlkIHEnIHRoZW4gcScgZWxzZVxuICAgICAgICAgIHJhaXNlIChFeHBhbmRfZXJyb3Ige3F1ZXJ5OyB2YXI7IHJlYXNvbiA9IGBJbnZhbGlkIHEnfSlcbiAgICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgICAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggdmFyIGluXG4gICAgICAgICAgaWYgbCA+IDAgJiYgdmFyLltsIC0gMV0gPSAnLicgdGhlblxuICAgICAgICAgICAgKG1hdGNoIG5vcm1hbCAoZiAoU3RyaW5nLnN1YiB2YXIgMCAobCAtIDEpKSkgd2l0aFxuICAgICAgICAgICAgIHwgU1tdIGFzIHEnIC0+IHEnXG4gICAgICAgICAgICAgfCBxJyAtPiBTW3EnOyBMXCIuXCJdXG4gICAgICAgICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IG5vdF9mb3VuZCAoKSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBub3RfZm91bmQgKCkpXG4gICB8IFMgcXMgLT4gUyAoTGlzdC5tYXAgcmVjdXJzZSBxcylcbiAgaW5cbiAgcmVjdXJzZSBxdWVyeVxuXG5tb2R1bGUgQW5nc3Ryb21fcGFyc2VycyA9IHN0cnVjdFxuICBvcGVuIEFuZ3N0cm9tXG5cbiAgbGV0IGZhaWxmID0gUHJpbnRmLmtzcHJpbnRmIGZhaWxcbiAgbGV0IGlnbiBwID0gcCA+PnwgZnVuIF8gLT4gKClcblxuICBsZXQgaXNfZGlnaXQgPSBmdW5jdGlvbiAnMCcuLic5JyAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuICBsZXQgaXNfZGlnaXRfbnogPSBmdW5jdGlvbiAnMScuLic5JyAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuICBsZXQgaXNfaWRyZnN0ID0gZnVuY3Rpb24gJ2EnLi4neid8J0EnLi4nWicgfCAnXycgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcbiAgbGV0IGlzX2lkcmNudCA9IGZ1bmN0aW9uICdhJy4uJ3onfCdBJy4uJ1onIHwgJ18nIHwgJzAnLi4nOScgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcbiAgbGV0IGlzX3NwYWNlID0gZnVuY3Rpb24gJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IHNpbmdsZV9xdW90ZWQgPSBza2lwX21hbnkgKGlnbiAobm90X2NoYXIgJ1xcJycpIDx8PiBpZ24gKHN0cmluZyBcIicnXCIpKVxuICBsZXQgZG91YmxlX3F1b3RlZCA9IHNraXBfbWFueSAoaWduIChub3RfY2hhciAnXCInKSA8fD4gaWduIChzdHJpbmcgXCJcXFwiXFxcIlwiKSlcblxuICBsZXQgdGFnZ2VkX3F1b3RlX2NvbnQgPVxuICAgIGNvbnN1bWVkIChza2lwIGlzX2lkcmZzdCAqPiBza2lwX3doaWxlIGlzX2lkcmNudCkgPCogY2hhciAnJCcgPj49IGZ1biB0YWcgLT5cbiAgICBtYW55X3RpbGwgYW55X2NoYXIgKGNoYXIgJyQnICo+IHN0cmluZyB0YWcgPCogY2hhciAnJCcpID4+fCAoZnVuIF8gLT4gKCkpXG5cbiAgbGV0IHZlcmJhdGltID1cbiAgICBsZXQgZnJhZ21lbnQgPSBhbnlfY2hhciA+Pj0gZnVuY3Rpb25cbiAgICAgfCAnXFwnJyAtPiBzaW5nbGVfcXVvdGVkIDwqIGNoYXIgJ1xcJydcbiAgICAgfCAnXCInIC0+IGRvdWJsZV9xdW90ZWQgPCogY2hhciAnXCInXG4gICAgIHwgJ2AnIC0+IHNraXBfbWFueSAobm90X2NoYXIgJ2AnKSA8KiBjaGFyICdgJ1xuICAgICB8ICctJyAtPlxuICAgICAgICAocGVla19jaGFyID4+PSBmdW5jdGlvblxuICAgICAgICAgfCBTb21lICctJyAtPiBza2lwX3doaWxlICgoPD4pICdcXG4nKSA8KiBjaGFyICdcXG4nXG4gICAgICAgICB8IF8gLT4gcmV0dXJuICgpKVxuICAgICB8ICckJyAtPiB0YWdnZWRfcXVvdGVfY29udFxuICAgICB8ICc/JyB8ICc7JyBhcyBjIC0+IGZhaWxmIFwiJUMgaXMgbm90IHZhbGlkIGhlcmVcIiBjXG4gICAgIHwgXyAtPiByZXR1cm4gKClcbiAgICBpblxuICAgIGNvbnN1bWVkIChtYW55MSBmcmFnbWVudCkgPj58IChmdW4gcyAtPiAoTCBzKSlcblxuICBsZXQgc2tpcF9pZHIgPSBza2lwIGlzX2lkcmZzdCAqPiBza2lwX3doaWxlIGlzX2lkcmNudFxuICBsZXQgaWRlbnRpZmllcl9kb3QgPSBjb25zdW1lZCAoc2tpcF9pZHIgKj4gY2hhciAnLicpXG4gIGxldCBpZGVudGlmaWVyX2RvdG9wdCA9IGNvbnN1bWVkIChvcHRpb24gKCkgc2tpcF9pZHIgKj4gb3B0aW9uICcgJyAoY2hhciAnLicpKVxuICBsZXQgcGFyYW1ldGVyX251bWJlciA9IGNvbnN1bWVkIChza2lwIGlzX2RpZ2l0X256ICo+IHNraXBfd2hpbGUgaXNfZGlnaXQpXG5cbiAgbGV0IGxvb2t1cCA9XG4gICAgY2hvaWNlIH5mYWlsdXJlX21zZzpcImludmFsaWQgZW52aXJvbm1lbnQgbG9va3VwXCIgW1xuICAgICAgc3RyaW5nIFwiJChcIiAqPiBpZGVudGlmaWVyX2RvdG9wdCA8KiBjaGFyICcpJyA+PnwgKGZ1biB2IC0+IEUgdik7XG4gICAgICBzdHJpbmcgXCIkLlwiID4+fCAoZnVuIF8gLT4gRSBcIi5cIik7XG4gICAgICBjaGFyICckJyAqPiBpZGVudGlmaWVyX2RvdCA+PnwgKGZ1biB2IC0+IEUgdik7XG4gICAgXVxuXG4gIGxldCB1bnRhZ2dlZF9xdW90ZSA9XG4gICAgbGV0IG5vbmxvb2t1cCA9XG4gICAgICBjb25zdW1lZCAobWFueTEgKHNhdGlzZnkgKGZ1bmN0aW9uICckJyAtPiBmYWxzZSB8IF8gLT4gdHJ1ZSkpKVxuICAgICAgICA+PnwgKGZ1biBzIC0+IChMIHMpKVxuICAgIGluXG4gICAgc3RyaW5nIFwiJCRcIiAqPiBtYW55X3RpbGwgKGxvb2t1cCA8fD4gbm9ubG9va3VwKSAoc3RyaW5nIFwiJCRcIikgPj58IGZ1biBxcyAtPlxuICAgIG5vcm1hbCAoUyAoW0wgXCIkJFwiXSBAIHFzIEAgW0wgXCIkJFwiXSkpXG5cbiAgbGV0IGF0b20gPVxuICAgIHBlZWtfY2hhcl9mYWlsID4+PSBmdW5jdGlvblxuICAgICB8ICckJyAtPlxuICAgICAgICBjaG9pY2UgfmZhaWx1cmVfbXNnOlwiaW52YWxpZCBkb2xsYXIgc2VxdWVuY2VcIiBbXG4gICAgICAgICAgY2hhciAnJCcgKj4gcGFyYW1ldGVyX251bWJlciA+PnwgKGZ1biBpUCAtPiBQIChpbnRfb2Zfc3RyaW5nIGlQIC0gMSkpO1xuICAgICAgICAgIGxvb2t1cDtcbiAgICAgICAgICB1bnRhZ2dlZF9xdW90ZTtcbiAgICAgICAgICB2ZXJiYXRpbTtcbiAgICAgICAgXVxuICAgICB8ICc/JyAtPlxuICAgICAgICBsZXQgdmFsaWRfbG9va2FoZWFkID0gcGVla19jaGFyID4+PSBmdW5jdGlvblxuICAgICAgICAgfCBTb21lICc6JyAtPlxuICAgICAgICAgICAgKHBlZWtfc3RyaW5nIDIgPj49IGZ1bmN0aW9uXG4gICAgICAgICAgICAgfCBcIjo6XCIgLT4gcmV0dXJuICgpXG4gICAgICAgICAgICAgfCBfIC0+IGZhaWwgXCInOicgaXMgbm90IGFsbG93ZWQgYWZ0ZXIgcGFyYW1ldGVyIHJlZmVyZW5jZSAnPydcIilcbiAgICAgICAgIHwgU29tZSAoJ0EnLi4nWicgfCAnYScuLid6JyB8ICcwJy4uJzknIHwgJ18nXG4gICAgICAgICAgICAgICB8ICchJyB8ICdcIicgfCAnIycgfCAnJCcgfCAnJScgfCAnJicgfCAnXFwnJyB8ICcuJ1xuICAgICAgICAgICAgICAgfCAnPCcgfCAnPScgfCAnPicgfCAnPycgfCAnQCcgfCAnXicgfCAnYCcgfCAnfCcgfCAnficgYXMgYykgLT5cbiAgICAgICAgICAgIGZhaWxmIFwiJUMgaXMgbm90IGFsbG93ZWQgYWZ0ZXIgcGFyYW1ldGVyIHJlZmVyZW5jZSAnPydcIiBjXG4gICAgICAgICB8IE5vbmUgfCBTb21lIF8gLT5cbiAgICAgICAgICAgIHJldHVybiAoKVxuICAgICAgICBpblxuICAgICAgICBjaGFyICc/JyA+PnwgKGZ1biBfIC0+IFAgKC0xKSkgPCogdmFsaWRfbG9va2FoZWFkXG4gICAgIHwgXyAtPlxuICAgICAgICB2ZXJiYXRpbVxuXG4gIGxldCBhdG9tX29yX3NlbWkgPSAoY2hhciAnOycgPj58IGZ1biBfIC0+IExcIjtcIikgPHw+IGF0b21cblxuICBsZXQgcmVpbmRleCBhdG9tcyA9XG4gICAgaWYgTGlzdC5mb3JfYWxsIChmdW5jdGlvbiBQICgtMSkgLT4gZmFsc2UgfCBfIC0+IHRydWUpIGF0b21zIHRoZW5cbiAgICAgIHJldHVybiBhdG9tc1xuICAgIGVsc2VcbiAgICBsZXQgcmVjIGxvb3AgaVAgYWNjID0gZnVuY3Rpb25cbiAgICAgfCBbXSAtPiByZXR1cm4gKExpc3QucmV2IGFjYylcbiAgICAgfCBQICgtMSkgOjogZnJhZ3MgLT4gbG9vcCAoaVAgKyAxKSAoUCBpUCA6OiBhY2MpIGZyYWdzXG4gICAgIHwgUCBfIDo6IF8gLT4gZmFpbCBcIkluY29uc2lzdGVudCBwYXJhbWV0ZXIgc3R5bGUuXCJcbiAgICAgfCBmcmFnIDo6IGZyYWdzIC0+IGxvb3AgaVAgKGZyYWcgOjogYWNjKSBmcmFnc1xuICAgIGluXG4gICAgbG9vcCAwIFtdIGF0b21zXG5cbiAgbGV0IGV4cHJlc3Npb24gPVxuICAgIGxldCBzdG9wID1cbiAgICAgIHBlZWtfY2hhciA+Pj0gZnVuY3Rpb25cbiAgICAgICB8IE5vbmUgfCBTb21lICc7JyAtPiByZXR1cm4gKClcbiAgICAgICB8IF8gLT4gZmFpbCBcInVudGVybWluYXRlZFwiXG4gICAgaW5cbiAgICBmaXggKGZ1biBwIC0+IChzdG9wICo+IHJldHVybiBbXSkgPHw+IChMaXN0LmNvbnMgPCQ+IGF0b20gPCo+IHApKVxuICAgICAgPj49IHJlaW5kZXggPj58IChmdW5jdGlvbiBbcV0gLT4gcSB8IHFzIC0+IFMgcXMpXG5cbiAgbGV0IGV4cHJlc3Npb25fd2l0aF9zZW1pID1cbiAgICBsZXQgc3RvcCA9XG4gICAgICBwZWVrX2NoYXIgPj49IGZ1bmN0aW9uXG4gICAgICAgfCBOb25lIC0+IHJldHVybiAoKVxuICAgICAgIHwgXyAtPiBmYWlsIFwidW50ZXJtaW5hdGVkXCJcbiAgICBpblxuICAgIGZpeCAoZnVuIHAgLT4gKHN0b3AgKj4gcmV0dXJuIFtdKSA8fD4gKExpc3QuY29ucyA8JD4gYXRvbV9vcl9zZW1pIDwqPiBwKSlcbiAgICAgID4+PSByZWluZGV4ID4+fCAoZnVuY3Rpb24gW3FdIC0+IHEgfCBxcyAtPiBTIHFzKVxuXG4gIGxldCBleHByZXNzaW9uX2xpc3QgPVxuICAgIGxldCB3aGl0ZSA9XG4gICAgICBtYW55ICh0YWtlX3doaWxlMSBpc19zcGFjZSA8fD4gKHN0cmluZyBcIi0tXCIgKj4gdGFrZV90aWxsICgoPSkgJ1xcbicpKSlcbiAgICAgICAgPCogY29tbWl0XG4gICAgaW5cbiAgICB3aGl0ZSAqPiBtYW55IChleHByZXNzaW9uIDwqIGNoYXIgJzsnIDwqIHdoaXRlKVxuZW5kXG5cbmxldCBhbmdzdHJvbV9wYXJzZXIgPSBBbmdzdHJvbV9wYXJzZXJzLmV4cHJlc3Npb25cbmxldCBhbmdzdHJvbV9wYXJzZXJfd2l0aF9zZW1pY29sb24gPSBBbmdzdHJvbV9wYXJzZXJzLmV4cHJlc3Npb25fd2l0aF9zZW1pXG5sZXQgYW5nc3Ryb21fbGlzdF9wYXJzZXIgPSBBbmdzdHJvbV9wYXJzZXJzLmV4cHJlc3Npb25fbGlzdFxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICBsZXQgb3BlbiBBbmdzdHJvbS5VbmJ1ZmZlcmVkIGluXG4gIChtYXRjaCBwYXJzZSBhbmdzdHJvbV9wYXJzZXJfd2l0aF9zZW1pY29sb24gd2l0aFxuICAgfCBQYXJ0aWFsIHtjb21taXR0ZWQgPSAwOyBjb250aW51ZX0gLT5cbiAgICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICAgIGxldCBicyA9IEJpZ3N0cmluZ2FmLm9mX3N0cmluZyB+b2ZmOjAgfmxlbiBzIGluXG4gICAgICAobWF0Y2ggY29udGludWUgYnMgfm9mZjowIH5sZW4gQ29tcGxldGUgd2l0aFxuICAgICAgIHwgRG9uZSAoY29tbWl0dGVkLCBxKSB3aGVuIGNvbW1pdHRlZCA9IGxlbiAtPiBPayBxXG4gICAgICAgfCBEb25lIChjb21taXR0ZWQsIF8pIHwgUGFydGlhbCB7Y29tbWl0dGVkOyBffSAtPlxuICAgICAgICAgIEVycm9yIChgSW52YWxpZCAoY29tbWl0dGVkLCBcIkV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gc2VtaWNvbG9uLlwiKSlcbiAgICAgICB8IEZhaWwgKGNvbW1pdHRlZCwgXywgbXNnKSAtPlxuICAgICAgICAgIEVycm9yIChgSW52YWxpZCAoY29tbWl0dGVkLCBtc2cpKSlcbiAgIHwgUGFydGlhbCBfIHwgRG9uZSBfIHwgRmFpbCBfIC0+XG4gICAgICBhc3NlcnQgZmFsc2UpXG5cbmxldCBvZl9zdHJpbmdfZXhuIHMgPVxuICAobWF0Y2ggb2Zfc3RyaW5nIHMgd2l0aFxuICAgfCBPayBxIC0+IHFcbiAgIHwgRXJyb3IgKGBJbnZhbGlkIChwb3MsIG1zZykpIC0+XG4gICAgICBQcmludGYua3NwcmludGYgZmFpbHdpdGggXCJQYXJzZSBlcnJvciBhdCBieXRlICVkOiAlc1wiIHBvcyBtc2cpXG5cbigqIFByaW50Zi1saWtlIGhlbHBlcnMgKilcblxudHlwZSBGb3JtYXQuc3RhZyArPSBTdGFnX3F1ZXJ5IG9mIHRcblxubGV0IHF1ZXJ5IHBwZiBxID1cbiAgRm9ybWF0LnBwX29wZW5fc3RhZyBwcGYgKFN0YWdfcXVlcnkgcSk7XG4gIEZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmIFwiLi4uIFNRTCBGUkFHTUVOVCAuLi5cIjtcbiAgRm9ybWF0LnBwX2Nsb3NlX3N0YWcgcHBmICgpXG5cbmxldCBxdW90ZSBwcGYgcSA9IHF1ZXJ5IHBwZiAoUSBxKVxubGV0IGVudiBwcGYgZSA9IHF1ZXJ5IHBwZiAoRSBlKVxubGV0IHBhcmFtIHBwZiBwID0gcXVlcnkgcHBmIChQIHApXG5cbnR5cGUgbW9kZSA9IE1vZGVfbGl0ZXJhbCB8IE1vZGVfaWdub3JlIHwgTW9kZV9yYXcgb2YgKHN0cmluZyAtPiB0KVxuXG5sZXQga3FwcmludGYgayBmbXQgPVxuICAoKiBUaGUgZm9ybWF0dGVyIGNhbiBiZSBpbiB0aHJlZSBkaWZmZXJlbnQgbW9kZXMsIHdoaWNoIGlzIGRldGVybWluZWRcbiAgICAgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50bHkgb3BlbiB0YWdzICh3ZSBleHBsb2l0IHRoZSBmYWN0IHRoYXRcbiAgICAgW21hcmtfb3Blbl9zdGFnXSBhbmQgW21hcmtfY2xvc2VfdGFnXSBhcmUgY2FsbGVkIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgdGFnXG4gICAgIHdvdWxkIGFjdHVhbGx5IGJlIG91dHB1dCB0byB0aGUgZm9ybWF0dGVyLCBhbmQgc28gY2FuIHdlIGNhbiBlZmZlY3RpdmVseVxuICAgICB1c2UgdGhlbSBhcyBjb250cm9sIGRpcmVjdGl2ZXMgZm9yIHRoZSBiZWhhdmlvciBvZiBbb3V0cHV0X3N0cmluZ10pLlxuXG4gICAgIEludGVybmFsbHksIHRoZSBmb3JtYXR0ZXIgaG9sZHMgYSBsaXN0IG9mIHF1ZXJ5IGVsZW1lbnRzIGluIHRoZSByZXZlcnNlXG4gICAgIG9yZGVyIHRoYXQgdGhleSBoYXZlIGJlZW4gcHJvZHVjZWQgaW4uIE9uY2Ugd2UgaGF2ZSBmaW5pc2hlZCBwYXJzaW5nLCB0aGF0XG4gICAgIGxpc3QgaXMgcmV2ZXJzZWQsIHdyYXBwZWQgaW50byB0aGUgW1NdIGNvbnN0cnVjdG9yLCBhbmQgcmV0dXJuZWQuIFdlIHdpbGxcbiAgICAgY2FsbCB0aGlzIGxpc3Qgb2YgZWxlbWVudHMgd2UgYXJlIGJ1aWxkaW5nIFwidGhlIHF1ZXVlXCIgaW4gdGhlIGZvbGxvd2luZy5cblxuICAgICBJbml0aWFsbHksIHRoZSBmb3JtYXR0ZXIgc3RhcnRzIGluIGxpdGVyYWwgbW9kZS4gSW4gbGl0ZXJhbCBtb2RlLCB3ZSBzaW1wbHlcbiAgICAgcHVzaCBlYWNoIHN0cmluZyB0aGF0IHdlIHJlY2VpdmUgZnJvbSB0aGUgZm9ybWF0dGVyIGludG8gdGhlIHF1ZXVlXG4gICAgIHVubW9kaWZpZWQgYXMgYSBsaXRlcmFsLlxuXG4gICAgIFdoZW4gd2UgZW5jb3VudGVyIGEgdGFnIGluIGxpdGVyYWwgbW9kZSwgd2UgZW50ZXIgb25lIG9mIHR3byBhdXhpbGlhcnlcbiAgICAgbW9kZXM6XG5cbiAgICAgIC0gSWYgdGhlIHRhZyBpcyB0aGUgc3RyaW5nIHRhZyBcIlFcIiBvciBcIkVcIiAoZGVub3RpbmcgYSBuZXN0ZWQgcXVvdGUgb3IgZW52XG4gICAgICAgIHZhciBmb3JtYXQsIHJlc3BlY3RpdmVseSksIHdlIGVudGVyIHJhdyBtb2RlLCBwYXJhbWV0ZXJpemVkIGJ5IGFcbiAgICAgICAgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVpdGhlciBbUV0gb3IgW0VdLiBJbiByYXcgbW9kZSwgd2UgYWNjdW11bGF0ZSB0aGVcbiAgICAgICAgY29udGVudCB0aGF0IGdldHMgcHJpbnRlZCBpbnRvIGEgYnVmZmVyLCBhbmQgd2hlbiBleGl0aW5nIHJhdyBtb2RlXG4gICAgICAgIChpLmUuIHdoZW4gdGhlIGNvcnJlc3BvbmRpbmcgdGFnIGdldHMgY2xvc2VkKSwgd2Ugd3JhcCB0aGUgYWNjdW11bGF0ZWRcbiAgICAgICAgY29udGVudCBhcyBhIHN0cmluZyBpbnRvIGVpdGhlciB0aGUgW1FdIG9yIFtFXSBjb25zdHJ1Y3RvciwgYW5kIHB1c2ggaXRcbiAgICAgICAgaW50byB0aGUgcXVldWUuIFRoZW4sIHdlIGV4aXQgZ28gYmFjayB0byBsaXRlcmFsIG1vZGUuXG5cbiAgICAgIC0gSWYgdGhlIHRhZyBpcyBjdXN0b20gdGFnIFtTdGFnX3F1ZXJ5XSwgYWRkZWQgYnkgdGhlIHshcXVlcnl9IHByaW50ZXIsIHdlXG4gICAgICAgIHB1c2ggdGhlIGVtYmVkZGVkIHF1ZXJ5IHdpdGhvdXQgbW9kaWZpY2F0aW9ucyBvbnRvIHRoZSBxdWV1ZSwgdGhlblxuICAgICAgICBzd2l0Y2ggdG8gaWdub3JlIG1vZGUuIEluIGlnbm9yZSBtb2RlLCB3ZSBzaW1wbHkgZGlzY2FyZCB3aGF0IGlzIHByaW50ZWRcbiAgICAgICAgdW50aWwgd2UgZXhpdCBpZ25vcmUgbW9kZSBieSBjbG9zaW5nIHRoZSBjb3JyZXNwb25kaW5nIHRhZy4gVGhpcyBpc1xuICAgICAgICBiZWNhdXNlLCBpbiBpZ25vcmUgbW9kZSwgdGhlIGNvbnRlbnQgdGhhdCB3ZSBhcmUgaW50ZXJlc3RlZCBpbiBpcyB0aGVcbiAgICAgICAgcGFyYW1ldGVyIG9mIHRoZSBbU3RhZ19xdWVyeV0sIG5vdCB0aGUgdGV4dHVhbCBjb250ZW50IHdpdGhpbiB0aGUgdGFnLlxuXG4gICAgIE5lc3Rpbmcgb2YgdGFncyBpcyBub3Qgc3VwcG9ydGVkLCBzbyBpZiB3ZSBzZWUgb25lIG9mIHRoZSB0YWdzIGFib3ZlIGluXG4gICAgIGVpdGhlciBvZiB0aGVzZSBtb2Rlcywgd2UgcmFpc2UgYSBbRmFpbHVyZV0gZXhjZXB0aW9uLlxuICAqKVxuICBsZXQgZWxlbXMgPSByZWYgW10gaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNTEyIGluXG5cbiAgbGV0IHB1c2ggcSA9IGVsZW1zIDo9IHEgOjogIWVsZW1zIGluXG4gIGxldCBtb2RlID0gcmVmIE1vZGVfbGl0ZXJhbCBpblxuICBsZXQgZmx1c2hfcmF3ICgpID1cbiAgICBsZXQgbWsgPSBtYXRjaCAhbW9kZSB3aXRoIE1vZGVfcmF3IGYgLT4gZiB8IF8gLT4gYXNzZXJ0IGZhbHNlIGluXG4gICAgcHVzaCBAQCBtayBAQCBCdWZmZXIuY29udGVudHMgYnVmO1xuICAgIEJ1ZmZlci5yZXNldCBidWY7XG4gICAgbW9kZSA6PSBNb2RlX2xpdGVyYWxcbiAgYW5kIGZsdXNoX2lnbm9yZSAoKSA9XG4gICAgbWF0Y2ggIW1vZGUgd2l0aCBNb2RlX2lnbm9yZSAtPiBtb2RlIDo9IE1vZGVfbGl0ZXJhbCB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGFuZCBmbHVzaF9saXRlcmFsICgpID1cbiAgICAoKiBVbmxpa2UgdGhlIHNpbWlsYXIgY2FzZXMgaW4gW2ZsdXNoX3Jhd10gYW5kIFtmbHVzaF9pZ25vcmVdLCBpdCBpcyBhY3R1YWxseVxuICAgICAgIHBvc3NpYmxlIHRvIGNhbGwgW2ZsdXNoX2xpdGVyYWxdIHdoaWxlIG5vdCBpbiBsaXRlcmFsIG1vZGUgYnkgbmVzdGluZyA8UT5cbiAgICAgICBhbmQvb3IgPEU+IHNlbWFudGljIHRhZ3MuXG5cbiAgICAgICBUaGVyZSBpcyBhY3R1YWxseSBub3RoaW5nIHRvIGRvIGhlcmUsIGJlY2F1c2Ugd2UgcHVzaCBvdXRwdXQgc3RyaW5ncyBpbnRvXG4gICAgICAgdGhlIHF1ZXVlIG9uIHRoZSBmbHkuICopXG4gICAgYmVnaW5cbiAgICAgIG1hdGNoICFtb2RlIHdpdGhcbiAgICAgIHwgTW9kZV9saXRlcmFsIC0+ICgpXG4gICAgICB8IF8gLT4gZmFpbHdpdGggXCJpbnZhbGlkIG5lc3Rpbmcgb2YgcXVlcnkgdGFnczsgZGlkIHlvdSBmb3JnZXQgYSBgQH1gP1wiXG4gICAgZW5kXG4gIGFuZCBvdXRwdXRfc3RyaW5nIHMgcCBuID1cbiAgICBtYXRjaCAhbW9kZSB3aXRoXG4gICAgfCBNb2RlX2xpdGVyYWwgLT5cbiAgICAgIGlmIG4gPiAwIHRoZW5cbiAgICAgICAgaWYgcCA9IDAgJiYgbiA9IFN0cmluZy5sZW5ndGggcyB0aGVuXG4gICAgICAgICAgcHVzaCAoTCBzKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcHVzaCAoTCAoU3RyaW5nLnN1YiBzIHAgbikpXG4gICAgfCBNb2RlX3JhdyBfIC0+IEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzIHAgblxuICAgIHwgTW9kZV9pZ25vcmUgLT4gKClcbiAgaW5cbiAgbGV0IHBwZiA9IEZvcm1hdC5tYWtlX2Zvcm1hdHRlciBvdXRwdXRfc3RyaW5nIGZsdXNoX2xpdGVyYWwgaW5cbiAgbGV0IEZvcm1hdC5cbiAgICAgICAgeyBtYXJrX29wZW5fc3RhZzsgbWFya19jbG9zZV9zdGFnOyBwcmludF9vcGVuX3N0YWc7IHByaW50X2Nsb3NlX3N0YWcgfSA9XG4gICAgRm9ybWF0LnBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgcHBmICgpXG4gIGluXG4gICgqIE5vdGUgdGhhdCB3ZSBjYWxsIFtmbHVzaF9saXRlcmFsXSB3aGVuICpvcGVuaW5nKiB0YWdzIGJ1dCB0aGUgb3RoZXIgW2ZsdXNoXVxuICAgICBmdW5jdGlvbnMgd2hlbiAqY2xvc2luZyogdGFncy4gIFNpbmNlIFtGb3JtYXRdIGVuZm9yY2VzIHRoZVxuICAgICB3ZWxsLXBhcmVudGhlc2lzaW5nIG9mIHRhZ3MsIHdlIGFyZSBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSBpbiB0aGUgY29ycmVjdFxuICAgICBtb2RlIHdoZW4gY2FsbGluZyBbZmx1c2hfcmF3XSBhbmQgW2ZsdXNoX2lnbm9yZV0sIGJ1dCB0aGF0IGlzICpub3QqIHRoZVxuICAgICBjYXNlIGZvciBbZmx1c2hfbGl0ZXJhXS5cbiAgKilcbiAgbGV0IG1hcmtfb3Blbl9zdGFnID0gZnVuY3Rpb25cbiAgICB8IEZvcm1hdC5TdHJpbmdfdGFnIFwiUVwiIC0+XG4gICAgICAgIGZsdXNoX2xpdGVyYWwgKCk7XG4gICAgICAgIG1vZGUgOj0gTW9kZV9yYXcgKGZ1biBzIC0+IFEgcyk7XG4gICAgICAgIFwiXCJcbiAgICB8IEZvcm1hdC5TdHJpbmdfdGFnIFwiRVwiIC0+XG4gICAgICAgIGZsdXNoX2xpdGVyYWwgKCk7XG4gICAgICAgIG1vZGUgOj0gTW9kZV9yYXcgKGZ1biBzIC0+IEUgcyk7XG4gICAgICAgIFwiXCJcbiAgICB8IFN0YWdfcXVlcnkgcSAtPlxuICAgICAgICBmbHVzaF9saXRlcmFsICgpO1xuICAgICAgICBwdXNoIHE7XG4gICAgICAgIG1vZGUgOj0gTW9kZV9pZ25vcmU7XG4gICAgICAgIFwiXCJcbiAgICB8IHQgLT4gbWFya19vcGVuX3N0YWcgdFxuICBhbmQgbWFya19jbG9zZV9zdGFnID0gZnVuY3Rpb25cbiAgICB8IEZvcm1hdC5TdHJpbmdfdGFnIChcIlFcIiB8IFwiRVwiKSAtPlxuICAgICAgICBmbHVzaF9yYXcgKCk7XG4gICAgICAgIFwiXCJcbiAgICB8IFN0YWdfcXVlcnkgXyAtPlxuICAgICAgICBmbHVzaF9pZ25vcmUgKCk7XG4gICAgICAgIFwiXCJcbiAgICB8IHQgLT4gbWFya19jbG9zZV9zdGFnIHRcbiAgaW5cbiAgRm9ybWF0LnBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgcHBmXG4gICAgeyBtYXJrX29wZW5fc3RhZzsgbWFya19jbG9zZV9zdGFnOyBwcmludF9vcGVuX3N0YWc7IHByaW50X2Nsb3NlX3N0YWcgfTtcbiAgRm9ybWF0LnBwX3NldF9tYXJrX3RhZ3MgcHBmIHRydWU7XG4gIEZvcm1hdC5rZnByaW50ZlxuICAgIChmdW4gcHBmIC0+XG4gICAgICBGb3JtYXQucHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICAgICAgayAoUyAoTGlzdC5yZXYgIWVsZW1zKSkpXG4gICAgcHBmIGZtdFxuXG5sZXQgcXByaW50ZiBmbXQgPSBrcXByaW50ZiBGdW4uaWQgZm10XG4iLCIoKiBDb3B5cmlnaHQgKEMpIDIwMTctLTIwMjIgIFBldHRlciBBLiBVcmtlZGFsIDxwYXVya2VkYWxAZ21haWwuY29tPlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyXG4gKiBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLCB3aXRoIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbi5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFuZCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24gYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuICBJZiBub3QsIHNlZVxuICogPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+IGFuZCA8aHR0cHM6Ly9zcGR4Lm9yZz4sIHJlc3BlY3RpdmVseS5cbiAqKVxuXG4oKiBFcnJvciBDYXVzZSAqKVxuXG50eXBlIGludGVncml0eV9jb25zdHJhaW50X3Zpb2xhdGlvbiA9IFtcbiAgfCBgUmVzdHJpY3RfdmlvbGF0aW9uXG4gIHwgYE5vdF9udWxsX3Zpb2xhdGlvblxuICB8IGBGb3JlaWduX2tleV92aW9sYXRpb25cbiAgfCBgVW5pcXVlX3Zpb2xhdGlvblxuICB8IGBDaGVja192aW9sYXRpb25cbiAgfCBgRXhjbHVzaW9uX3Zpb2xhdGlvblxuICB8IGBJbnRlZ3JpdHlfY29uc3RyYWludF92aW9sYXRpb25fX2Rvbid0X21hdGNoXG5dXG5cbnR5cGUgaW5zdWZmaWNpZW50X3Jlc291cmNlcyA9IFtcbiAgfCBgRGlza19mdWxsXG4gIHwgYE91dF9vZl9tZW1vcnlcbiAgfCBgVG9vX21hbnlfY29ubmVjdGlvbnNcbiAgfCBgQ29uZmlndXJhdGlvbl9saW1pdF9leGNlZWRlZFxuICB8IGBJbnN1ZmZpY2llbnRfcmVzb3VyY2VzX19kb24ndF9tYXRjaFxuXVxuXG50eXBlIGNhdXNlID0gW1xuICB8IGludGVncml0eV9jb25zdHJhaW50X3Zpb2xhdGlvblxuICB8IGluc3VmZmljaWVudF9yZXNvdXJjZXNcbiAgfCBgVW5zcGVjaWZpZWRfX2Rvbid0X21hdGNoXG5dXG5cbmxldCBzaG93X2NhdXNlID0gZnVuY3Rpb25cbiB8IGBSZXN0cmljdF92aW9sYXRpb24gLT4gXCJSRVNUUklDVCB2aW9sYXRpb25cIlxuIHwgYE5vdF9udWxsX3Zpb2xhdGlvbiAtPiBcIk5PVCBOVUxMIGNvbnN0cmFpbnQgdmlvbGF0aW9uXCJcbiB8IGBGb3JlaWduX2tleV92aW9sYXRpb24gLT4gXCJGT1JFSUdOIEtFWSBjb25zdHJhaW50IHZpb2xhdGlvblwiXG4gfCBgVW5pcXVlX3Zpb2xhdGlvbiAtPiBcIlVOSVFVRSBjb25zdHJhaW50IHZpb2xhdGlvblwiXG4gfCBgQ2hlY2tfdmlvbGF0aW9uIC0+IFwiQ0hFQ0sgY29uc3RyYWludCB2aW9sYXRpb25cIlxuIHwgYEV4Y2x1c2lvbl92aW9sYXRpb24gLT4gXCJleGNsdXNpb24gdmlvbGF0aW9uXCJcbiB8IGBJbnRlZ3JpdHlfY29uc3RyYWludF92aW9sYXRpb25fX2Rvbid0X21hdGNoIC0+XG4gICAgXCJpbnRlZ3JpdHkgY29uc3RyYWludCB2aW9sYXRpb25cIlxuIHwgYERpc2tfZnVsbCAtPiBcImRpc2sgZnVsbFwiXG4gfCBgT3V0X29mX21lbW9yeSAtPiBcIm91dCBvZiBtZW1vcnlcIlxuIHwgYFRvb19tYW55X2Nvbm5lY3Rpb25zIC0+IFwidG9vIG1hbnkgY29ubmVjdGlvbnNcIlxuIHwgYENvbmZpZ3VyYXRpb25fbGltaXRfZXhjZWVkZWQgLT4gXCJjb25maWd1cmF0aW9uIGxpbWl0IGV4Y2VlZGVkXCJcbiB8IGBJbnN1ZmZpY2llbnRfcmVzb3VyY2VzX19kb24ndF9tYXRjaCAtPiBcImluc3VmZmljaWVudCByZXNvdXJjZXNcIlxuIHwgYFVuc3BlY2lmaWVkX19kb24ndF9tYXRjaCAtPiBcInVua25vd24gY2F1c2VcIlxuXG4oKiBEcml2ZXIgKilcblxudHlwZSBtc2cgPSAuLlxuXG50eXBlIG1zZ19pbXBsID0ge1xuICBtc2dfcHA6IEZvcm1hdC5mb3JtYXR0ZXIgLT4gbXNnIC0+IHVuaXQ7XG4gIG1zZ19jYXVzZTogbXNnIC0+IGNhdXNlO1xufVxubGV0IG1zZ19pbXBsID0gSGFzaHRibC5jcmVhdGUgN1xuXG5sZXQgZGVmYXVsdF9jYXVzZSBfID0gYFVuc3BlY2lmaWVkX19kb24ndF9tYXRjaFxuXG5sZXQgZGVmaW5lX21zZyB+cHAgPyhjYXVzZSA9IGRlZmF1bHRfY2F1c2UpIGVjID1cbiAgSGFzaHRibC5hZGQgbXNnX2ltcGwgZWMge21zZ19wcCA9IHBwOyBtc2dfY2F1c2UgPSBjYXVzZX1cblxubGV0IGZpbmRfaW1wbCBtc2cgPVxuICBsZXQgYyA9IE9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIG1zZyBpblxuICB0cnlcbiAgICBIYXNodGJsLmZpbmQgbXNnX2ltcGwgY1xuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIFByaW50Zi5rc3ByaW50ZiBmYWlsd2l0aFxuICAgICAgXCJNaXNzaW5nIGNhbGwgdG8gQ2FxdGlfZXJyb3IuZGVmaW5lX21zZyBmb3IgKCVzIF8gOiBDYXF0aV9lcnJvci5tc2cpXVwiXG4gICAgICAoT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5uYW1lIGMpXG5cbnR5cGUgbXNnICs9IE1zZyA6IHN0cmluZyAtPiBtc2dcblxubGV0IGlzX3B1bmN0ID0gZnVuY3Rpb25cbiB8ICcuJyB8ICchJyB8ICc/JyAtPiB0cnVlXG4gfCBfIC0+IGZhbHNlXG5cbmxldCAoKSA9XG4gIGxldCBwcCBwcGYgPSBmdW5jdGlvblxuICAgfCBNc2cgcyAtPlxuICAgICAgRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgICAgIGlmIHMgPD4gXCJcIiAmJiBub3QgKGlzX3B1bmN0IHMuW1N0cmluZy5sZW5ndGggcyAtIDFdKSB0aGVuXG4gICAgICAgIEZvcm1hdC5wcF9wcmludF9jaGFyIHBwZiAnLidcbiAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgaW5cbiAgZGVmaW5lX21zZyB+cHAgfmNhdXNlOmRlZmF1bHRfY2F1c2UgWyVleHRlbnNpb25fY29uc3RydWN0b3IgTXNnXVxuXG5sZXQgcHBfbXNnIHBwZiBtc2cgPVxuICAoZmluZF9pbXBsIG1zZykubXNnX3BwIHBwZiBtc2dcblxuKCogV2UgZG9uJ3Qgd2FudCB0byBleHBvc2UgYW55IERCIHBhc3N3b3JkIGluIGVycm9yIG1lc3NhZ2VzLiAqKVxubGV0IHBwX3VyaSBwcGYgdXJpID1cbiAgKG1hdGNoIFVyaS5wYXNzd29yZCB1cmkgd2l0aFxuICAgfCBOb25lIC0+IFVyaS5wcF9odW0gcHBmIHVyaVxuICAgfCBTb21lIF8gLT4gVXJpLnBwX2h1bSBwcGYgKFVyaS53aXRoX3Bhc3N3b3JkIHVyaSAoU29tZSBcIl9cIikpKVxuXG4oKiBSZWNvcmRzICopXG5cbnR5cGUgbG9hZF9lcnJvciA9IHtcbiAgdXJpOiBVcmkudDtcbiAgbXNnOiBtc2c7XG59XG5sZXQgcHBfbG9hZF9tc2cgcHBmIGZtdCBlcnIgPVxuICBGb3JtYXQuZnByaW50ZiBwcGYgZm10IHBwX3VyaSBlcnIudXJpO1xuICBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiBcIjogXCI7XG4gIHBwX21zZyBwcGYgZXJyLm1zZ1xuXG50eXBlIGNvbm5lY3Rpb25fZXJyb3IgPSB7XG4gIHVyaTogVXJpLnQ7XG4gIG1zZzogbXNnO1xufVxubGV0IHBwX2Nvbm5lY3Rpb25fbXNnIHBwZiBmbXQgZXJyID1cbiAgRm9ybWF0LmZwcmludGYgcHBmIGZtdCBwcF91cmkgZXJyLnVyaTtcbiAgRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgXCI6IFwiO1xuICBwcF9tc2cgcHBmIGVyci5tc2dcblxudHlwZSBxdWVyeV9lcnJvciA9IHtcbiAgdXJpOiBVcmkudDtcbiAgcXVlcnk6IHN0cmluZztcbiAgbXNnOiBtc2c7XG59XG5cbmxldCBwcF9xdWVyeV9tc2cgcHBmIGZtdCBlcnIgPVxuICBGb3JtYXQuZnByaW50ZiBwcGYgZm10IHBwX3VyaSBlcnIudXJpO1xuICBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiBcIjogXCI7XG4gIHBwX21zZyBwcGYgZXJyLm1zZztcbiAgRm9ybWF0LmZwcmludGYgcHBmIFwiIFF1ZXJ5OiAlUy5cIiBlcnIucXVlcnlcblxudHlwZSBjb2RpbmdfZXJyb3IgPSB7XG4gIHVyaTogVXJpLnQ7XG4gIHR5cDogQ2FxdGlfdHlwZS5hbnk7XG4gIG1zZzogbXNnO1xufVxubGV0IHBwX2NvZGluZ19lcnJvciBwcGYgZm10IGVyciA9XG4gIEZvcm1hdC5mcHJpbnRmIHBwZiBmbXQgQ2FxdGlfdHlwZS5wcF9hbnkgZXJyLnR5cCBwcF91cmkgZXJyLnVyaTtcbiAgRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgXCI6IFwiO1xuICBwcF9tc2cgcHBmIGVyci5tc2dcblxuKCogTG9hZCAqKVxuXG5sZXQgbG9hZF9yZWplY3RlZCB+dXJpIG1zZyA9IGBMb2FkX3JlamVjdGVkICh7dXJpOyBtc2d9IDogbG9hZF9lcnJvcilcbmxldCBsb2FkX2ZhaWxlZCB+dXJpIG1zZyA9IGBMb2FkX2ZhaWxlZCAoe3VyaTsgbXNnfSA6IGxvYWRfZXJyb3IpXG5cbigqIENvbm5lY3QgKilcblxubGV0IGNvbm5lY3RfcmVqZWN0ZWQgfnVyaSBtc2cgPVxuICBgQ29ubmVjdF9yZWplY3RlZCAoe3VyaTsgbXNnfSA6IGNvbm5lY3Rpb25fZXJyb3IpXG5cbmxldCBjb25uZWN0X2ZhaWxlZCB+dXJpIG1zZyA9XG4gIGBDb25uZWN0X2ZhaWxlZCAoe3VyaTsgbXNnfSA6IGNvbm5lY3Rpb25fZXJyb3IpXG5cbigqIENhbGwgKilcblxubGV0IGVuY29kZV9taXNzaW5nIH51cmkgfmZpZWxkX3R5cGUgKCkgPVxuICBsZXQgdHlwID0gQ2FxdGlfdHlwZS5BbnkgKENhcXRpX3R5cGUuZmllbGQgZmllbGRfdHlwZSkgaW5cbiAgbGV0IG1zZyA9IE1zZyBcIkZpZWxkIHR5cGUgbm90IHN1cHBvcnRlZCBhbmQgbm8gZmFsbGJhY2sgcHJvdmlkZWQuXCIgaW5cbiAgYEVuY29kZV9yZWplY3RlZCAoe3VyaTsgdHlwOyBtc2d9IDogY29kaW5nX2Vycm9yKVxubGV0IGVuY29kZV9yZWplY3RlZCB+dXJpIH50eXAgbXNnID1cbiAgbGV0IHR5cCA9IENhcXRpX3R5cGUuQW55IHR5cCBpblxuICBgRW5jb2RlX3JlamVjdGVkICh7dXJpOyB0eXA7IG1zZ30gOiBjb2RpbmdfZXJyb3IpXG5sZXQgZW5jb2RlX2ZhaWxlZCB+dXJpIH50eXAgbXNnID1cbiAgbGV0IHR5cCA9IENhcXRpX3R5cGUuQW55IHR5cCBpblxuICBgRW5jb2RlX2ZhaWxlZCAoe3VyaTsgdHlwOyBtc2d9IDogY29kaW5nX2Vycm9yKVxubGV0IHJlcXVlc3RfZmFpbGVkIH51cmkgfnF1ZXJ5IG1zZyA9XG4gIGBSZXF1ZXN0X2ZhaWxlZCAoe3VyaTsgcXVlcnk7IG1zZ30gOiBxdWVyeV9lcnJvcilcblxuKCogUmV0cmlldmUgKilcblxubGV0IGRlY29kZV9taXNzaW5nIH51cmkgfmZpZWxkX3R5cGUgKCkgPVxuICBsZXQgdHlwID0gQ2FxdGlfdHlwZS5BbnkgKENhcXRpX3R5cGUuZmllbGQgZmllbGRfdHlwZSkgaW5cbiAgbGV0IG1zZyA9IE1zZyBcIkZpZWxkIHR5cGUgbm90IHN1cHBvcnRlZCBhbmQgbm8gZmFsbGJhY2sgcHJvdmlkZWQuXCIgaW5cbiAgYERlY29kZV9yZWplY3RlZCAoe3VyaTsgdHlwOyBtc2d9IDogY29kaW5nX2Vycm9yKVxubGV0IGRlY29kZV9yZWplY3RlZCB+dXJpIH50eXAgbXNnID1cbiAgbGV0IHR5cCA9IENhcXRpX3R5cGUuQW55IHR5cCBpblxuICBgRGVjb2RlX3JlamVjdGVkICh7dXJpOyB0eXA7IG1zZ30gOiBjb2RpbmdfZXJyb3IpXG5sZXQgcmVzcG9uc2VfZmFpbGVkIH51cmkgfnF1ZXJ5IG1zZyA9XG4gIGBSZXNwb25zZV9mYWlsZWQgKHt1cmk7IHF1ZXJ5OyBtc2d9IDogcXVlcnlfZXJyb3IpXG5sZXQgcmVzcG9uc2VfcmVqZWN0ZWQgfnVyaSB+cXVlcnkgbXNnID1cbiAgYFJlc3BvbnNlX3JlamVjdGVkICh7dXJpOyBxdWVyeTsgbXNnfSA6IHF1ZXJ5X2Vycm9yKVxuXG4oKiBDb21tb24gKilcblxudHlwZSBjYWxsID1cbiAgWyBgRW5jb2RlX3JlamVjdGVkIG9mIGNvZGluZ19lcnJvclxuICB8IGBFbmNvZGVfZmFpbGVkIG9mIGNvZGluZ19lcnJvclxuICB8IGBSZXF1ZXN0X2ZhaWxlZCBvZiBxdWVyeV9lcnJvclxuICB8IGBSZXNwb25zZV9yZWplY3RlZCBvZiBxdWVyeV9lcnJvciBdXG5cbnR5cGUgcmV0cmlldmUgPVxuICBbIGBEZWNvZGVfcmVqZWN0ZWQgb2YgY29kaW5nX2Vycm9yXG4gIHwgYFJlcXVlc3RfZmFpbGVkIG9mIHF1ZXJ5X2Vycm9yXG4gIHwgYFJlc3BvbnNlX2ZhaWxlZCBvZiBxdWVyeV9lcnJvclxuICB8IGBSZXNwb25zZV9yZWplY3RlZCBvZiBxdWVyeV9lcnJvciBdXG5cbnR5cGUgY2FsbF9vcl9yZXRyaWV2ZSA9IFtjYWxsIHwgcmV0cmlldmVdXG5cbnR5cGUgdHJhbnNhY3QgPSBjYWxsX29yX3JldHJpZXZlXG5cbnR5cGUgbG9hZCA9XG4gIFsgYExvYWRfcmVqZWN0ZWQgb2YgbG9hZF9lcnJvclxuICB8IGBMb2FkX2ZhaWxlZCBvZiBsb2FkX2Vycm9yIF1cblxudHlwZSBjb25uZWN0ID1cbiAgWyBgQ29ubmVjdF9yZWplY3RlZCBvZiBjb25uZWN0aW9uX2Vycm9yXG4gIHwgYENvbm5lY3RfZmFpbGVkIG9mIGNvbm5lY3Rpb25fZXJyb3JcbiAgfCBgUG9zdF9jb25uZWN0IG9mIGNhbGxfb3JfcmV0cmlldmUgXVxuXG50eXBlIGxvYWRfb3JfY29ubmVjdCA9IFtsb2FkIHwgY29ubmVjdF1cblxudHlwZSB0ID0gW2xvYWQgfCBjb25uZWN0IHwgY2FsbCB8IHJldHJpZXZlXVxuXG5sZXQgcmVjIHVyaSA6ICdhLiAoWzwgdF0gYXMgJ2EpIC0+IFVyaS50ID0gZnVuY3Rpb25cbiB8IGBMb2FkX3JlamVjdGVkICh7dXJpOyBffSA6IGxvYWRfZXJyb3IpIC0+IHVyaVxuIHwgYExvYWRfZmFpbGVkICh7dXJpOyBffSA6IGxvYWRfZXJyb3IpIC0+IHVyaVxuIHwgYENvbm5lY3RfcmVqZWN0ZWQgKHt1cmk7IF99IDogY29ubmVjdGlvbl9lcnJvcikgLT4gdXJpXG4gfCBgQ29ubmVjdF9mYWlsZWQgKHt1cmk7IF99IDogY29ubmVjdGlvbl9lcnJvcikgLT4gdXJpXG4gfCBgUG9zdF9jb25uZWN0IGVyciAtPiB1cmkgZXJyXG4gfCBgRW5jb2RlX3JlamVjdGVkICh7dXJpOyBffSA6IGNvZGluZ19lcnJvcikgLT4gdXJpXG4gfCBgRW5jb2RlX2ZhaWxlZCAoe3VyaTsgX30gOiBjb2RpbmdfZXJyb3IpIC0+IHVyaVxuIHwgYFJlcXVlc3RfZmFpbGVkICh7dXJpOyBffSA6IHF1ZXJ5X2Vycm9yKSAtPiB1cmlcbiB8IGBEZWNvZGVfcmVqZWN0ZWQgKHt1cmk7IF99IDogY29kaW5nX2Vycm9yKSAtPiB1cmlcbiB8IGBSZXNwb25zZV9mYWlsZWQgKHt1cmk7IF99IDogcXVlcnlfZXJyb3IpIC0+IHVyaVxuIHwgYFJlc3BvbnNlX3JlamVjdGVkICh7dXJpOyBffSA6IHF1ZXJ5X2Vycm9yKSAtPiB1cmlcblxubGV0IHJlYyBwcCA6ICdhLiBfIC0+IChbPCB0XSBhcyAnYSkgLT4gdW5pdCA9IGZ1biBwcGYgLT4gZnVuY3Rpb25cbiB8IGBMb2FkX3JlamVjdGVkIGVyciAtPiBwcF9sb2FkX21zZyBwcGYgXCJDYW5ub3QgbG9hZCBkcml2ZXIgZm9yIDwlYT5cIiBlcnJcbiB8IGBMb2FkX2ZhaWxlZCBlcnIgLT4gcHBfbG9hZF9tc2cgcHBmIFwiRmFpbGVkIHRvIGxvYWQgZHJpdmVyIGZvciA8JWE+XCIgZXJyXG4gfCBgQ29ubmVjdF9yZWplY3RlZCBlcnIgLT4gcHBfY29ubmVjdGlvbl9tc2cgcHBmIFwiQ2Fubm90IGNvbm5lY3QgdG8gPCVhPlwiIGVyclxuIHwgYENvbm5lY3RfZmFpbGVkIGVyciAtPiBwcF9jb25uZWN0aW9uX21zZyBwcGYgXCJGYWlsZWQgdG8gY29ubmVjdCB0byA8JWE+XCIgZXJyXG4gfCBgUG9zdF9jb25uZWN0IGVyciAtPlxuICAgIEZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmIFwiRHVyaW5nIHBvc3QtY29ubmVjdDogXCI7XG4gICAgcHAgcHBmIGVyclxuIHwgYEVuY29kZV9yZWplY3RlZCBlcnIgLT4gcHBfY29kaW5nX2Vycm9yIHBwZiBcIkNhbm5vdCBlbmNvZGUgJWEgZm9yIDwlYT5cIiBlcnJcbiB8IGBFbmNvZGVfZmFpbGVkIGVyciAtPiBwcF9jb2RpbmdfZXJyb3IgcHBmIFwiRmFpbGVkIHRvIGJpbmQgJWEgZm9yIDwlYT5cIiBlcnJcbiB8IGBEZWNvZGVfcmVqZWN0ZWQgZXJyIC0+IHBwX2NvZGluZ19lcnJvciBwcGYgXCJDYW5ub3QgZGVjb2RlICVhIGZyb20gPCVhPlwiIGVyclxuIHwgYFJlcXVlc3RfZmFpbGVkIGVyciAtPiBwcF9xdWVyeV9tc2cgcHBmIFwiUmVxdWVzdCB0byA8JWE+IGZhaWxlZFwiIGVyclxuIHwgYFJlc3BvbnNlX2ZhaWxlZCBlcnIgLT4gcHBfcXVlcnlfbXNnIHBwZiBcIlJlc3BvbnNlIGZyb20gPCVhPiBmYWlsZWRcIiBlcnJcbiB8IGBSZXNwb25zZV9yZWplY3RlZCBlcnIgLT4gcHBfcXVlcnlfbXNnIHBwZiBcIlVuZXhwZWN0ZWQgcmVzdWx0IGZyb20gPCVhPlwiIGVyclxuXG5sZXQgc2hvd19vZl9wcCBwcCBlcnIgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxMjggaW5cbiAgbGV0IHBwZiA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICBwcCBwcGYgZXJyO1xuICBGb3JtYXQucHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBCdWZmZXIuY29udGVudHMgYnVmXG5cbmxldCBzaG93IGVyciA9IHNob3dfb2ZfcHAgcHAgZXJyXG5cbmxldCBjYXVzZSA9IGZ1bmN0aW9uXG4gfCBgUmVxdWVzdF9mYWlsZWQgZXJyIHwgYFJlc3BvbnNlX2ZhaWxlZCBlcnIgLT5cbiAgICAoZmluZF9pbXBsIChlcnIgOiBxdWVyeV9lcnJvcikubXNnKS5tc2dfY2F1c2UgZXJyLm1zZ1xuXG50eXBlIGNvdW5pdCA9IHxcblxuW0BAQHdhcm5pbmcgXCItNTZcIl1cbmxldCB1bmNvbmdlc3RlZCA9IGZ1bmN0aW9uXG4gfCBFcnJvciAjdCB8IE9rIF8gYXMgeCAtPiB4XG4gfCBFcnJvciAoYENvbmdlc3RlZCAobm90aGluZ25lc3MgOiBjb3VuaXQpKSAtPiAobWF0Y2ggbm90aGluZ25lc3Mgd2l0aCBfIC0+IC4pXG5bQEBAd2FybmluZyBcIis1NlwiXVxuXG5leGNlcHRpb24gRXhuIG9mIHRcblxubGV0ICgpID0gUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciBAQCBmdW5jdGlvblxuIHwgRXhuIGVyciAtPlxuICAgIFNvbWUgKHNob3cgZXJyKVxuIHwgQ2FxdGlfcXVlcnkuRXhwYW5kX2Vycm9yIGVyciAtPlxuICAgIFNvbWUgKHNob3dfb2ZfcHAgQ2FxdGlfcXVlcnkucHBfZXhwYW5kX2Vycm9yIGVycilcbiB8IF8gLT5cbiAgICBOb25lXG4iLCIoKiBDb3B5cmlnaHQgKEMpIDIwMTctLTIwMTggIFBldHRlciBBLiBVcmtlZGFsIDxwYXVya2VkYWxAZ21haWwuY29tPlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyXG4gKiBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLCB3aXRoIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbi5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFuZCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24gYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuICBJZiBub3QsIHNlZVxuICogPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+IGFuZCA8aHR0cHM6Ly9zcGR4Lm9yZz4sIHJlc3BlY3RpdmVseS5cbiAqKVxuXG50eXBlIGRpYWxlY3RfdGFnID0gW2BNeXNxbCB8IGBQZ3NxbCB8IGBTcWxpdGUgfCBgT3RoZXJdXG50eXBlIHNxbF9kaWFsZWN0X3RhZyA9IFtgTXlzcWwgfCBgUGdzcWwgfCBgU3FsaXRlXVxudHlwZSBwYXJhbWV0ZXJfc3R5bGUgPVxuICBbIGBOb25lXG4gIHwgYExpbmVhciBvZiBzdHJpbmdcbiAgfCBgSW5kZXhlZCBvZiAoaW50IC0+IHN0cmluZykgXVxuXG50eXBlIHQgPSB7XG4gIHVyaV9zY2hlbWU6IHN0cmluZztcbiAgZGlhbGVjdF90YWc6IGRpYWxlY3RfdGFnO1xuICBwYXJhbWV0ZXJfc3R5bGU6IHBhcmFtZXRlcl9zdHlsZTtcbiAgY2FuX3RyYW5zYWN0OiBib29sO1xuICBjYW5fcG9vbDogYm9vbDtcbiAgY2FuX2NvbmN1cjogYm9vbDtcbn1cblxubGV0IGNyZWF0ZVxuICAgIH51cmlfc2NoZW1lXG4gICAgPyhkaWFsZWN0X3RhZyA9IGBPdGhlcilcbiAgICA/KHBhcmFtZXRlcl9zdHlsZSA9IGBOb25lKVxuICAgIH5jYW5fcG9vbFxuICAgIH5jYW5fY29uY3VyXG4gICAgfmNhbl90cmFuc2FjdFxuICAgICgpID1cbiAge1xuICAgIHVyaV9zY2hlbWU7XG4gICAgZGlhbGVjdF90YWc7XG4gICAgcGFyYW1ldGVyX3N0eWxlO1xuICAgIGNhbl90cmFuc2FjdDtcbiAgICBjYW5fcG9vbDtcbiAgICBjYW5fY29uY3VyO1xuICB9XG5cbmxldCBkdW1teSA9IGNyZWF0ZVxuICB+dXJpX3NjaGVtZTpcImR1bW15XCJcbiAgfmNhbl9wb29sOmZhbHNlIH5jYW5fY29uY3VyOmZhbHNlIH5jYW5fdHJhbnNhY3Q6ZmFsc2VcbiAgKClcblxubGV0IHVyaV9zY2hlbWUgZGkgPSBkaS51cmlfc2NoZW1lXG5sZXQgZGlhbGVjdF90YWcgZGkgPSBkaS5kaWFsZWN0X3RhZ1xubGV0IHBhcmFtZXRlcl9zdHlsZSBkaSA9IGRpLnBhcmFtZXRlcl9zdHlsZVxubGV0IGNhbl9wb29sIGRpID0gZGkuY2FuX3Bvb2xcbmxldCBjYW5fY29uY3VyIGRpID0gZGkuY2FuX2NvbmN1clxubGV0IGNhbl90cmFuc2FjdCBkaSA9IGRpLmNhbl90cmFuc2FjdFxuIiwiKCogQ29weXJpZ2h0IChDKSAyMDE3LS0yMDE4ICBQZXR0ZXIgQS4gVXJrZWRhbCA8cGF1cmtlZGFsQGdtYWlsLmNvbT5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91clxuICogb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbiwgd2l0aCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbmQgdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LiAgSWYgbm90LCBzZWVcbiAqIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPiBhbmQgPGh0dHBzOi8vc3BkeC5vcmc+LCByZXNwZWN0aXZlbHkuXG4gKilcblxuKCoqIE11bHRpcGxpY2l0aWVzIG9mIHplcm8sIG9uZSwgYW5kIG1hbnkuICopXG5cbnR5cGUgKydtIHQgPSAoKiBub3QgR0FEVCBkdWUgdG8gdmFyaWFuY2UgKilcbiB8IFplcm9cbiB8IE9uZVxuIHwgWmVyb19vcl9vbmVcbiB8IFplcm9fb3JfbW9yZVxuY29uc3RyYWludCAnbSA9IFs8IGBaZXJvIHwgYE9uZSB8IGBNYW55XVxuXG50eXBlIHplcm8gPSBbYFplcm9dXG50eXBlIG9uZSA9IFtgT25lXVxudHlwZSB6ZXJvX29yX29uZSA9IFtgWmVybyB8IGBPbmVdXG50eXBlIHplcm9fb3JfbW9yZSA9IFtgWmVybyB8IGBPbmUgfCBgTWFueV1cblxubGV0IHplcm8gOiBbPiBgWmVyb10gdCA9IFplcm9cbmxldCBvbmUgOiBbPiBgT25lXSB0ID0gT25lXG5sZXQgemVyb19vcl9vbmUgOiBbPiBgWmVybyB8IGBPbmVdIHQgPSBaZXJvX29yX29uZVxubGV0IHplcm9fb3JfbW9yZSA6IChbPiBgWmVybyB8IGBPbmUgfCBgTWFueV0gYXMgJ2EpIHQgPSBaZXJvX29yX21vcmVcblxubGV0IG9ubHlfemVybyA6IFs8IGBaZXJvXSB0IC0+IHVuaXQgPVxuICBmdW5jdGlvbiBaZXJvIC0+ICgpIHwgXyAtPiBhc3NlcnQgZmFsc2VcbmxldCBvbmx5X29uZSA6IFs8IGBPbmVdIHQgLT4gdW5pdCA9XG4gIGZ1bmN0aW9uIE9uZSAtPiAoKSB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5sZXQgb25seV96ZXJvX29yX29uZSA6IFs8IGBaZXJvIHwgYE9uZV0gdCAtPiB1bml0ID1cbiAgZnVuY3Rpb24gWmVybyB8IE9uZSAtPiAoKSB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBleHBvc2UgPSBmdW5jdGlvblxuIHwgWmVybyAtPiBgWmVyb1xuIHwgT25lIC0+IGBPbmVcbiB8IFplcm9fb3Jfb25lIC0+IGBaZXJvX29yX29uZVxuIHwgWmVyb19vcl9tb3JlIC0+IGBaZXJvX29yX21vcmVcblxubGV0IGNhbl9iZV96ZXJvID0gZnVuY3Rpb25cbiB8IE9uZSAtPiBmYWxzZVxuIHwgWmVybyB8IFplcm9fb3Jfb25lIHwgWmVyb19vcl9tb3JlIC0+IHRydWVcblxubGV0IGNhbl9iZV9tYW55ID0gZnVuY3Rpb25cbiB8IFplcm8gfCBPbmUgfCBaZXJvX29yX29uZSAtPiBmYWxzZVxuIHwgWmVyb19vcl9tb3JlIC0+IHRydWVcbiIsIigqIENvcHlyaWdodCAoQykgMjAxNy0tMjAyMyAgUGV0dGVyIEEuIFVya2VkYWwgPHBhdXJrZWRhbEBnbWFpbC5jb20+XG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXJcbiAqIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24sIHdpdGggdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYW5kIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbiBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeS4gIElmIG5vdCwgc2VlXG4gKiA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4gYW5kIDxodHRwczovL3NwZHgub3JnPiwgcmVzcGVjdGl2ZWx5LlxuICopXG5cbmxldCAoJSkgZiBnIHggPSBmIChnIHgpXG5tb2R1bGUgTG9nID0gKHZhbCBMb2dzLnNyY19sb2cgKExvZ3MuU3JjLmNyZWF0ZSBcImNhcXRpXCIpKVxuXG50eXBlICgnYSwgJ2IsICsnbSkgdCA9IHtcbiAgaWQ6IGludCBvcHRpb247XG4gIHF1ZXJ5OiBDYXF0aV9kcml2ZXJfaW5mby50IC0+IENhcXRpX3F1ZXJ5LnQ7XG4gIHBhcmFtX3R5cGU6ICdhIENhcXRpX3R5cGUudDtcbiAgcm93X3R5cGU6ICdiIENhcXRpX3R5cGUudDtcbiAgcm93X211bHQ6ICdtIENhcXRpX211bHQudDtcbn0gY29uc3RyYWludCAnbSA9IFs8IGBaZXJvIHwgYE9uZSB8IGBNYW55XVxuXG5sZXQgbGFzdF9pZCA9IHJlZiAoLTEpXG5cbmxldCBjcmVhdGUgPyhvbmVzaG90ID0gZmFsc2UpIHBhcmFtX3R5cGUgcm93X3R5cGUgcm93X211bHQgcXVlcnkgPVxuICBsZXQgaWQgPSBpZiBvbmVzaG90IHRoZW4gTm9uZSBlbHNlIChpbmNyIGxhc3RfaWQ7IFNvbWUgIWxhc3RfaWQpIGluXG4gIHtpZDsgcXVlcnk7IHBhcmFtX3R5cGU7IHJvd190eXBlOyByb3dfbXVsdH1cblxubGV0IHBhcmFtX3R5cGUgcmVxdWVzdCA9IHJlcXVlc3QucGFyYW1fdHlwZVxubGV0IHJvd190eXBlIHJlcXVlc3QgPSByZXF1ZXN0LnJvd190eXBlXG5sZXQgcm93X211bHQgcmVxdWVzdCA9IHJlcXVlc3Qucm93X211bHRcblxubGV0IHF1ZXJ5X2lkIHJlcXVlc3QgPSByZXF1ZXN0LmlkXG5sZXQgcXVlcnkgcmVxdWVzdCA9IHJlcXVlc3QucXVlcnlcblxuXG4oKiBDb252ZW5pZW5jZSBJbnRlcmZhY2UgKilcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGxldCAoLS0+LikgdCB1ID9vbmVzaG90IGYgPSBjcmVhdGUgP29uZXNob3QgdCB1IENhcXRpX211bHQuemVybyBmXG4gIGxldCAoLS0+ISkgdCB1ID9vbmVzaG90IGYgPSBjcmVhdGUgP29uZXNob3QgdCB1IENhcXRpX211bHQub25lIGZcbiAgbGV0ICgtLT4/KSB0IHUgP29uZXNob3QgZiA9IGNyZWF0ZSA/b25lc2hvdCB0IHUgQ2FxdGlfbXVsdC56ZXJvX29yX29uZSBmXG4gIGxldCAoLS0+KikgdCB1ID9vbmVzaG90IGYgPSBjcmVhdGUgP29uZXNob3QgdCB1IENhcXRpX211bHQuemVyb19vcl9tb3JlIGZcblxuICBsZXQgKEA6LSkgZiBzID1cbiAgICBsZXQgcSA9IENhcXRpX3F1ZXJ5Lm9mX3N0cmluZ19leG4gcyBpblxuICAgIGYgKGZ1biBfIC0+IHEpXG5cbiAgbGV0IChAQDotKSBmIGcgPVxuICAgIGYgKENhcXRpX3F1ZXJ5Lm9mX3N0cmluZ19leG4gJSBnICUgQ2FxdGlfZHJpdmVyX2luZm8uZGlhbGVjdF90YWcpXG5cbiAgbGV0ICgtPi4pIHQgdSA/b25lc2hvdCBzID0gY3JlYXRlID9vbmVzaG90IHQgdSBDYXF0aV9tdWx0Lnplcm8gQDotIHNcbiAgbGV0ICgtPiEpIHQgdSA/b25lc2hvdCBzID0gY3JlYXRlID9vbmVzaG90IHQgdSBDYXF0aV9tdWx0Lm9uZSBAOi0gc1xuICBsZXQgKC0+PykgdCB1ID9vbmVzaG90IHMgPSBjcmVhdGUgP29uZXNob3QgdCB1IENhcXRpX211bHQuemVyb19vcl9vbmUgQDotIHNcbiAgbGV0ICgtPiopIHQgdSA/b25lc2hvdCBzID0gY3JlYXRlID9vbmVzaG90IHQgdSBDYXF0aV9tdWx0Lnplcm9fb3JfbW9yZSBAOi0gc1xuZW5kXG5cbmxldCBub19lbnYgXyBfID0gcmFpc2UgTm90X2ZvdW5kXG5cbmxldCBtYWtlX3BwID8oZW52ID0gbm9fZW52KSA/KGRyaXZlcl9pbmZvID0gQ2FxdGlfZHJpdmVyX2luZm8uZHVtbXkpICgpXG4gICAgICAgICAgICBwcGYgcmVxID1cbiAgbGV0IHF1ZXJ5ID0gQ2FxdGlfcXVlcnkuZXhwYW5kIChlbnYgZHJpdmVyX2luZm8pIChyZXEucXVlcnkgZHJpdmVyX2luZm8pIGluXG4gIEZvcm1hdC5mcHJpbnRmIHBwZiBcIiglYSAtLT4lcyAlYSkge3wlYXx9XCJcbiAgICBDYXF0aV90eXBlLnBwIHJlcS5wYXJhbV90eXBlXG4gICAgKG1hdGNoIENhcXRpX211bHQuZXhwb3NlIHJlcS5yb3dfbXVsdCB3aXRoXG4gICAgIHwgYFplcm8gLT4gXCIuXCJcbiAgICAgfCBgT25lIC0+IFwiXCJcbiAgICAgfCBgWmVyb19vcl9vbmUgLT4gXCI/XCJcbiAgICAgfCBgWmVyb19vcl9tb3JlIC0+IFwiKlwiKVxuICAgIENhcXRpX3R5cGUucHAgcmVxLnJvd190eXBlXG4gICAgQ2FxdGlfcXVlcnkucHAgcXVlcnlcblxubGV0IHBwIHBwZiA9IG1ha2VfcHAgKCkgcHBmXG5cbmxldCBwcF93aXRoX3BhcmFtX2VuYWJsZWQgPVxuICAobWF0Y2ggU3lzLmdldGVudiBcIkNBUVRJX0RFQlVHX1BBUkFNXCIgd2l0aFxuICAgfCBcInRydWVcIiAtPiB0cnVlXG4gICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICAgfCBzIC0+XG4gICAgICBMb2cuZXJyIChmdW4gZiAtPlxuICAgICAgICBmIFwiSW52YWxpZCB2YWx1ZSAlcyBmb3IgQ0FRVElfREVCVUdfUEFSQU0sIGFzc3VtaW5nIGZhbHNlLlwiIHMpO1xuICAgICAgZmFsc2VcbiAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBmYWxzZSlcblxubGV0IG1ha2VfcHBfd2l0aF9wYXJhbSA/ZW52ID9kcml2ZXJfaW5mbyAoKSBwcGYgKHJlcSwgcGFyYW0pID1cbiAgbGV0IHBwID0gbWFrZV9wcCA/ZW52ID9kcml2ZXJfaW5mbyAoKSBpblxuICBwcCBwcGYgcmVxO1xuICBpZiBwcF93aXRoX3BhcmFtX2VuYWJsZWQgdGhlblxuICAgIEZvcm1hdC5mcHJpbnRmIHBwZiBcIiAlYVwiIENhcXRpX3R5cGUucHBfdmFsdWUgKHJlcS5wYXJhbV90eXBlLCBwYXJhbSlcbiIsIigqIENvcHlyaWdodCAoQykgMjAyMyAgUGV0dGVyIEEuIFVya2VkYWwgPHBhdXJrZWRhbEBnbWFpbC5jb20+XG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXJcbiAqIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24sIHdpdGggdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYW5kIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbiBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeS4gIElmIG5vdCwgc2VlXG4gKiA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4gYW5kIDxodHRwczovL3NwZHgub3JnPiwgcmVzcGVjdGl2ZWx5LlxuICopXG5cbnR5cGUgJ2EgdCA9IEZvcm1hdC5mb3JtYXR0ZXIgLT4gJ2EgLT4gdW5pdFxuXG5bQEBAYWxlcnQgXCItZGVwcmVjYXRlZFwiXVxubGV0IHFwcmludGYgPSBDYXF0aV9xdWVyeS5xcHJpbnRmXG5sZXQga3FwcmludGYgPSBDYXF0aV9xdWVyeS5rcXByaW50ZlxubGV0IHBhcmFtID0gQ2FxdGlfcXVlcnkucGFyYW1cbmxldCBlbnYgPSBDYXF0aV9xdWVyeS5lbnZcbmxldCBxdW90ZSA9IENhcXRpX3F1ZXJ5LnF1b3RlXG5sZXQgcXVlcnkgPSBDYXF0aV9xdWVyeS5xdWVyeVxuW0BAQGFsZXJ0IFwiK2RlcHJlY2F0ZWRcIl1cblxubGV0IGJvb2wgcHBmIHggPSBxdWVyeSBwcGYgKFYgKENhcXRpX3R5cGUuRmllbGQuQm9vbCwgeCkpXG5sZXQgaW50IHBwZiB4ID0gcXVlcnkgcHBmIChWIChDYXF0aV90eXBlLkZpZWxkLkludCwgeCkpXG5sZXQgZmxvYXQgcHBmIHggPSBxdWVyeSBwcGYgKFYgKENhcXRpX3R5cGUuRmllbGQuRmxvYXQsIHgpKVxubGV0IHN0cmluZyBwcGYgeCA9IHF1ZXJ5IHBwZiAoViAoQ2FxdGlfdHlwZS5GaWVsZC5TdHJpbmcsIHgpKVxubGV0IG9jdGV0cyBwcGYgeCA9IHF1ZXJ5IHBwZiAoViAoQ2FxdGlfdHlwZS5GaWVsZC5PY3RldHMsIHgpKVxubGV0IHBkYXRlIHBwZiB4ID0gcXVlcnkgcHBmIChWIChDYXF0aV90eXBlLkZpZWxkLlBkYXRlLCB4KSlcbmxldCBwdGltZSBwcGYgeCA9IHF1ZXJ5IHBwZiAoViAoQ2FxdGlfdHlwZS5GaWVsZC5QdGltZSwgeCkpXG5sZXQgcHRpbWVfc3BhbiBwcGYgeCA9IHF1ZXJ5IHBwZiAoViAoQ2FxdGlfdHlwZS5GaWVsZC5QdGltZV9zcGFuLCB4KSlcbiIsIigqIENvcHlyaWdodCAoQykgMjAyMyAgUGV0dGVyIEEuIFVya2VkYWwgPHBhdXJrZWRhbEBnbWFpbC5jb20+XG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXJcbiAqIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24sIHdpdGggdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYW5kIHRoZSBMR1BMLTMuMCBMaW5raW5nIEV4Y2VwdGlvbiBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeS4gIElmIG5vdCwgc2VlXG4gKiA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4gYW5kIDxodHRwczovL3NwZHgub3JnPiwgcmVzcGVjdGl2ZWx5LlxuICopXG5cbm1vZHVsZSBMb2cgPSAodmFsIExvZ3Muc3JjX2xvZyAoTG9ncy5TcmMuY3JlYXRlIFwiY2FxdGkuY29uZmlnXCIpKVxuXG50eXBlIHQgPSB7XG4gIG1heF9zaXplOiBpbnQgb3B0aW9uO1xuICBtYXhfaWRsZV9zaXplOiBpbnQgb3B0aW9uO1xuICBtYXhfaWRsZV9hZ2U6IE10aW1lLlNwYW4udCBvcHRpb24gb3B0aW9uO1xuICBtYXhfdXNlX2NvdW50OiBpbnQgb3B0aW9uIG9wdGlvbjtcbn1cblxudHlwZSBfIGtleSA9XG4gIHwgTWF4X3NpemUgOiBpbnQga2V5XG4gIHwgTWF4X2lkbGVfc2l6ZSA6IGludCBrZXlcbiAgfCBNYXhfaWRsZV9hZ2UgOiBNdGltZS5TcGFuLnQgb3B0aW9uIGtleVxuICB8IE1heF91c2VfY291bnQgOiBpbnQgb3B0aW9uIGtleVxuXG50eXBlIGFueV9rZXkgPSBBbnkgOiBfIGtleSAtPiBhbnlfa2V5XG5cbmxldCBrZXlzID0gW1xuICBBbnkgTWF4X3NpemU7XG4gIEFueSBNYXhfaWRsZV9zaXplO1xuICBBbnkgTWF4X2lkbGVfYWdlO1xuICBBbnkgTWF4X3VzZV9jb3VudDtcbl1cblxubGV0IGNyZWF0ZVxuICAgICAgP21heF9zaXplXG4gICAgICA/bWF4X2lkbGVfc2l6ZVxuICAgICAgP21heF9pZGxlX2FnZVxuICAgICAgP21heF91c2VfY291bnRcbiAgICAgICgpID1cbiAge21heF9zaXplOyBtYXhfaWRsZV9zaXplOyBtYXhfaWRsZV9hZ2U7IG1heF91c2VfY291bnR9XG5cbmxldCBvcHRpb25fb2Zfc3RyaW5nIGYgPSBmdW5jdGlvblxuIHwgXCJcIiB8IFwibm9uZVwiIC0+IE5vbmVcbiB8IHMgLT4gU29tZSAoZiBzKVxuXG5sZXQgbXRpbWVfc3Bhbl9vZl9zdHJpbmcgcyA9XG4gIGxldCB4ID0gZmxvYXRfb2Zfc3RyaW5nIHMgaW5cbiAgKG1hdGNoIE10aW1lLlNwYW4ub2ZfZmxvYXRfbnMgKHggKi4gMWU5KSB3aXRoXG4gICB8IE5vbmUgLT4gZmFpbHdpdGggXCJNdGltZS5TcGFuLm9mX2Zsb2F0X25zXCJcbiAgIHwgU29tZSB4IC0+IHgpXG5cbmxldCBkZWZhdWx0ID0gY3JlYXRlICgpXG5cbmxldCBjcmVhdGVfZnJvbV9lbnYgcGZ4ID1cbiAgbGV0IGdldCBjb252IHNmeCA9XG4gICAgbGV0IHZhciA9IHBmeCBeIHNmeCBpblxuICAgIChtYXRjaCBTeXMuZ2V0ZW52X29wdCB2YXIgd2l0aFxuICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICB8IFNvbWUgc3RyIC0+XG4gICAgICAgIChtYXRjaCBjb252IHN0ciB3aXRoXG4gICAgICAgICB8IHZhbHVlIC0+IFNvbWUgdmFsdWVcbiAgICAgICAgIHwgZXhjZXB0aW9uIEZhaWx1cmUgXyAtPlxuICAgICAgICAgICAgTG9nLmVyciAoZnVuIG0gLT4gbSBcIkZhaWxlZCB0byBwYXJzZSAkJXMgPSAlcy5cIiB2YXIgc3RyKTtcbiAgICAgICAgICAgIE5vbmUpKVxuICBpblxuICB7XG4gICAgbWF4X3NpemUgPSBnZXQgaW50X29mX3N0cmluZyBcIl9NQVhfU0laRVwiO1xuICAgIG1heF9pZGxlX3NpemUgPSBnZXQgaW50X29mX3N0cmluZyBcIl9NQVhfSURMRV9TSVpFXCI7XG4gICAgbWF4X2lkbGVfYWdlID0gZ2V0IChvcHRpb25fb2Zfc3RyaW5nIG10aW1lX3NwYW5fb2Zfc3RyaW5nKSBcIl9NQVhfSURMRV9BR0VcIjtcbiAgICBtYXhfdXNlX2NvdW50ID0gZ2V0IChvcHRpb25fb2Zfc3RyaW5nIGludF9vZl9zdHJpbmcpIFwiX01BWF9VU0VfQ09VTlRcIjtcbiAgfVxuXG5sZXQgZGVmYXVsdF9mcm9tX2VudiAoKSA9IGNyZWF0ZV9mcm9tX2VudiBcIkNBUVRJX1BPT0xcIlxuXG5sZXQgbWF4X3NpemUgPSBNYXhfc2l6ZVxubGV0IG1heF9pZGxlX3NpemUgPSBNYXhfaWRsZV9zaXplXG5sZXQgbWF4X2lkbGVfYWdlID0gTWF4X2lkbGVfYWdlXG5sZXQgbWF4X3VzZV9jb3VudCA9IE1heF91c2VfY291bnRcblxubGV0IGdldCAodHlwZSBhKSAoayA6IGEga2V5KSBjb25maWcgOiBhIG9wdGlvbiA9XG4gIChtYXRjaCBrIHdpdGhcbiAgIHwgTWF4X3NpemUgLT4gY29uZmlnLm1heF9zaXplXG4gICB8IE1heF9pZGxlX3NpemUgLT4gY29uZmlnLm1heF9pZGxlX3NpemVcbiAgIHwgTWF4X2lkbGVfYWdlIC0+IGNvbmZpZy5tYXhfaWRsZV9hZ2VcbiAgIHwgTWF4X3VzZV9jb3VudCAtPiBjb25maWcubWF4X3VzZV9jb3VudClcblxubGV0IG1vZGlmeSAodHlwZSBhKSAoayA6IGEga2V5KSAodiA6IGEgb3B0aW9uKSBjb25maWcgPVxuICAobWF0Y2ggayB3aXRoXG4gICB8IE1heF9zaXplIC0+IHtjb25maWcgd2l0aCBtYXhfc2l6ZSA9IHZ9XG4gICB8IE1heF9pZGxlX3NpemUgLT4ge2NvbmZpZyB3aXRoIG1heF9pZGxlX3NpemUgPSB2fVxuICAgfCBNYXhfaWRsZV9hZ2UgLT4ge2NvbmZpZyB3aXRoIG1heF9pZGxlX2FnZSA9IHZ9XG4gICB8IE1heF91c2VfY291bnQgLT4ge2NvbmZpZyB3aXRoIG1heF91c2VfY291bnQgPSB2fSlcblxubGV0IHNldCBrIHYgY29uZmlnID0gbW9kaWZ5IGsgKFNvbWUgdikgY29uZmlnXG5sZXQgdW5zZXQgayBjb25maWcgPSBtb2RpZnkgayBOb25lIGNvbmZpZ1xuXG5sZXQgbWVyZ2VfbGVmdCBjTCBjUiA9XG4gIGxldCBhZGQgYWNjIChBbnkgaykgPVxuICAgIG1hdGNoIGdldCBrIGNMIHdpdGggTm9uZSAtPiBhY2MgfCBTb21lIHYgLT4gKHNldCBrIHYgYWNjKVxuICBpblxuICBMaXN0LmZvbGRfbGVmdCBhZGQgY1Iga2V5c1xuIiwiKCogQ29weXJpZ2h0IChDKSAyMDIzLS0yMDI0ICBQZXR0ZXIgQS4gVXJrZWRhbCA8cGF1cmtlZGFsQGdtYWlsLmNvbT5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91clxuICogb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbiwgd2l0aCB0aGUgTEdQTC0zLjAgTGlua2luZyBFeGNlcHRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbmQgdGhlIExHUEwtMy4wIExpbmtpbmcgRXhjZXB0aW9uIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LiAgSWYgbm90LCBzZWVcbiAqIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPiBhbmQgPGh0dHBzOi8vc3BkeC5vcmc+LCByZXNwZWN0aXZlbHkuXG4gKilcblxuKCogTWFwIEltcGxlbWVudGF0aW9uICopXG5cbnR5cGUgJ2EgdGFnID0gLi5cblxubW9kdWxlIHR5cGUgS0VZID0gc2lnXG4gIHR5cGUgdmFsdWVcbiAgdHlwZSAnYSB0YWcgKz0gVGFnIDogdmFsdWUgdGFnXG4gIHZhbCBuYW1lIDogc3RyaW5nIFtAQHdhcm5pbmcgXCItMzJcIl1cbiAgdmFsIGRlZmF1bHQgOiB2YWx1ZVxuZW5kXG5cbnR5cGUgJ2Ega2V5ID0gKG1vZHVsZSBLRVkgd2l0aCB0eXBlIHZhbHVlID0gJ2EpXG5cbmxldCBjcmVhdGVfa2V5ICh0eXBlIGEpIG5hbWUgKGRlZmF1bHQgOiBhKSA6IGEga2V5ID1cbiAgbGV0IG1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgICB0eXBlIHZhbHVlID0gYVxuICAgIHR5cGUgXyB0YWcgKz0gVGFnIDogdmFsdWUgdGFnXG4gICAgbGV0IG5hbWUgPSBuYW1lXG4gICAgbGV0IGRlZmF1bHQgPSBkZWZhdWx0XG4gIGVuZCBpblxuICAobW9kdWxlIEtleSA6IEtFWSB3aXRoIHR5cGUgdmFsdWUgPSBhKVxuXG5tb2R1bGUgU3RyaW5nX21hcCA9IE1hcC5NYWtlIChTdHJpbmcpXG5cbnR5cGUgYmluZGluZyA9IEJpbmRpbmcgOiAnYSB0YWcgKiAnYSAtPiBiaW5kaW5nXG5cbnR5cGUgdCA9IGJpbmRpbmcgU3RyaW5nX21hcC50XG5cbmxldCBkZWZhdWx0ID0gU3RyaW5nX21hcC5lbXB0eVxuXG5sZXQgbWVtX25hbWUga2V5X25hbWUgPSBTdHJpbmdfbWFwLm1lbSBrZXlfbmFtZVxuXG5sZXQgZ2V0IDogdHlwZSBhLiBhIGtleSAtPiB0IC0+IGEgPSBmdW4gKG1vZHVsZSBLZXkpIG0gLT5cbiAgKG1hdGNoIFN0cmluZ19tYXAuZmluZF9vcHQgS2V5Lm5hbWUgbSB3aXRoXG4gICB8IFNvbWUgKEJpbmRpbmcgKEtleS5UYWcsIHYpKSAtPiB2XG4gICB8IF8gLT4gS2V5LmRlZmF1bHQpXG5cbmxldCBzZXQgOiB0eXBlIGEuIGEga2V5IC0+IGEgLT4gdCAtPiB0ID0gZnVuIChtb2R1bGUgS2V5KSB2IG0gLT5cbiAgU3RyaW5nX21hcC5hZGQgS2V5Lm5hbWUgKEJpbmRpbmcgKEtleS5UYWcsIHYpKSBtXG5cbmxldCByZXNldCA6IHR5cGUgYS4gYSBrZXkgLT4gdCAtPiB0ID0gZnVuIChtb2R1bGUgS2V5KSBtIC0+XG4gIFN0cmluZ19tYXAucmVtb3ZlIEtleS5uYW1lIG1cblxuKCogQ29uZmlndXJhdGlvbiBLZXlzICopXG5cbmxldCB0d2Vha3NfdmVyc2lvbiA6IChpbnQgKiBpbnQpIGtleSA9IGNyZWF0ZV9rZXkgXCJ0d2Vha3NfdmVyc2lvblwiICgxLCA3KVxuIl19
