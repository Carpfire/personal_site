// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ppx_expect_runtime__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Ppx_expect_runtime = [0],
    Ppx_expect_runtime$0 = [0, Ppx_expect_runtime];
   runtime.caml_register_global
    (0, Ppx_expect_runtime$0, "Ppx_expect_runtime__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Types
//# unitInfo: Requires: Base, Base__Comparable, Base__Int
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    default$0 = [0, 2, 0, "%", "@@"],
    default$1 = [0, cst],
    Base = global_data.Base,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int = global_data.Base__Int,
    _f_ = [0, cst];
   function equal(a, b){
    var _g_ = a[1] === b[1] ? 1 : 0;
    if(_g_)
     var _h_ = a[2] === b[2] ? 1 : 0, _i_ = _h_ ? a[3] === b[3] ? 1 : 0 : _h_;
    else
     var _i_ = _g_;
    return _i_;
   }
   var _a_ = 0;
   function _b_(t){return t[3];}
   var _c_ = [0, caml_call2(Base_Comparable[2], Base[129], _b_), _a_];
   function _d_(t){return t[2];}
   var
    _e_ = [0, caml_call2(Base_Comparable[2], Base[129], _d_), _c_],
    compare_character_range = caml_call1(Base_Comparable[1], _e_),
    Compact_loc = [0, equal, compare_character_range],
    Flexibility = [0],
    Expect_node_formatting = [0, default$0, Flexibility],
    Virtual_loc = [0],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash = Base_Int[8],
    sexp_of_t = Base_Int[10],
    compare = Base_Int[14],
    counter = [0, 0];
   function mint(param){
    var id = counter[1];
    counter[1] = id + 1 | 0;
    return id;
   }
   var Hand = [0], Kind = [0], Shape = [0];
   function handed(t, hand){return hand ? t ? t : _f_ : t;}
   var
    Ppx_expect_runtime_Types =
      [0,
       Expect_node_formatting,
       Compact_loc,
       Virtual_loc,
       [0, of_int_exn, to_int_exn, compare, sexp_of_t, hash, mint],
       [0, Hand, Kind, Shape, [0, default$1, handed]]];
   runtime.caml_register_global
    (6, Ppx_expect_runtime_Types, "Ppx_expect_runtime__Types");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Write_corrected_file
//# unitInfo: Requires: Base, Base__Comparable, Base__List, Base__String, Make_corrected_file, Ppx_expect_runtime__Types, Stdio__Out_channel, Stdlib, Stdlib__Filename, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Stdlib = global_data.Stdlib,
    Base_String = global_data.Base__String,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Make_corrected_file = global_data.Make_corrected_file,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Comparable = global_data.Base__Comparable,
    Base_List = global_data.Base__List,
    Patch_with_file_contents = [0],
    cst_corrected = ".corrected",
    cst_corrected_tmp = ".corrected.tmp";
   function f
   (use_color,
    in_place,
    diff_command,
    diff_path_prefix,
    filename,
    with$0,
    corrections$0){
    var
     dot_corrected = caml_call2(Base[241], filename, cst_corrected),
     in_channel = caml_call1(Stdlib[79], filename),
     _d_ = caml_call1(Stdlib[92], in_channel),
     original_file_contents = caml_call2(Stdlib[86], in_channel, _d_);
    caml_call1(Stdlib[93], in_channel);
    function remove(file){
     if(runtime.caml_sys_file_exists(file)) runtime.caml_sys_remove(file);
     return;
    }
    var
     corrections$1 = caml_call2(with$0, original_file_contents, corrections$0),
     _a_ =
       caml_call2
        (Base_Comparable[2], Ppx_expect_runtime_Types[2][2], Base[242]),
     corrections = caml_call2(Base_List[83], corrections$1, _a_);
    function _b_(l_pos, param){
     var
      correction = param[2],
      match = param[1],
      end_pos = match[3],
      start_pos = match[2],
      code_chunk =
        caml_call3
         (Base_String[3],
          original_file_contents,
          l_pos,
          start_pos - l_pos | 0);
     return [0, end_pos, [0, code_chunk, [0, correction, 0]]];
    }
    var
     match = caml_call3(Base_List[96], corrections, 0, _b_),
     strs = match[2],
     l_pos = match[1],
     _c_ = caml_call1(Base_List[11], strs),
     result = caml_call2(Base_String[68], 0, _c_),
     rest = caml_call3(Base_String[5], [0, l_pos], 0, original_file_contents),
     next_contents = caml_call2(Base[241], result, rest);
    if(in_place){
     if
      (1 - caml_call2(Base_String[134], original_file_contents, next_contents))
      caml_call2(Stdio_Out_channel[37], filename, next_contents);
     remove(dot_corrected);
     return 0;
    }
    if(diff_command && ! runtime.caml_string_notequal(diff_command[1], "-")){
     caml_call2(Stdio_Out_channel[37], dot_corrected, next_contents);
     return 0;
    }
    var
     _e_ = caml_call1(Stdlib_Filename[13], filename),
     _f_ = [0, caml_call1(Stdlib_Filename[14], filename)],
     tmp_corrected =
       caml_call3(Stdlib_Filename[16], _f_, _e_, cst_corrected_tmp);
    return 0
            ===
             caml_call8
               (Make_corrected_file[1],
                0,
                [0, tmp_corrected],
                [0, use_color],
                diff_command,
                diff_path_prefix,
                next_contents,
                filename,
                0)
              [0]
            ? (remove(dot_corrected), remove(tmp_corrected), 0)
            : (runtime.caml_sys_rename(tmp_corrected, dot_corrected), 1);
   }
   var Ppx_expect_runtime_Write_corre = [0, Patch_with_file_contents, f];
   runtime.caml_register_global
    (12,
     Ppx_expect_runtime_Write_corre,
     "Ppx_expect_runtime__Write_corrected_file");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Output
//# unitInfo: Requires: Base, Base__List, Base__Printf, Base__String, Ppx_expect_runtime__Types
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Printf = global_data.Base__Printf,
    Base_String = global_data.Base__String,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    Type = [0],
    compare = Base[195],
    Formatted = [0],
    _g_ =
      [0,
       [12, 123, [2, 0, [2, 0, [12, 124, [2, 0, [11, "|}", 0]]]]]],
       "{%s%s|%s|}"],
    _f_ =
      [0,
       [12,
        123,
        [2,
         0,
         [2,
          0,
          [12, 32, [2, 0, [12, 124, [2, 0, [12, 124, [2, 0, [12, 125, 0]]]]]]]]]],
       "{%s%s %s|%s|%s}"],
    _h_ =
      [0,
       [12, 91, [2, 0, [2, 0, [12, 32, [2, 0, [12, 93, 0]]]]]],
       "[%s%s %s]"],
    _d_ = [0, [12, 123, [2, 0, [12, 124, 0]]], "{%s|"],
    _e_ = [0, [12, 124, [2, 0, [12, 125, 0]]], "|%s}"],
    cst_xxx = "xxx",
    _a_ = [0, "\n"],
    _b_ =
      [0,
       [12, 123, [2, 0, [12, 124, [2, 0, [12, 124, [2, 0, [12, 125, 0]]]]]]],
       "{%s|%s|%s}"],
    _c_ = [0, [12, 34, [2, 0, [12, 34, 0]]], '"%s"'];
   function create(format){return format;}
   function apply(format, str){return caml_call1(format, str);}
   var Formatter = [0, create, apply];
   function compare$0(a, b){
    if(! a) return b ? -1 : 0;
    if(! b) return 1;
    var b$0 = b[1], a$0 = a[1];
    return caml_call2(compare, a$0, b$0);
   }
   var Test_result = [0, compare$0];
   function default$0(contents){
    return [0, contents, Ppx_expect_runtime_Types[5][4][1]];
   }
   function to_source_code_string(param){
    var tag = param[2], test_output = param[1];
    if(tag){
     var tag$0 = tag[1];
     return caml_call4(Base_Printf[2], _b_, tag$0, test_output, tag$0);
    }
    var
     _k_ = caml_call2(Base_String[102], test_output, 10),
     _l_ = caml_call2(Base_List[53], _k_, Base_String[69]),
     _m_ = caml_call1(caml_call1(Base_String[68], _a_), _l_);
    return caml_call2(Base_Printf[2], _c_, _m_);
   }
   var Payload = [0, default$0, to_source_code_string];
   function reconcile(expected_output, test_output){
    return caml_call2(Base_String[134], expected_output, test_output)
            ? 0
            : [0, test_output];
   }
   function fail(error_output){return [0, error_output];}
   function fix_delimiter_conflicts(contents, delimiter){
    if(! delimiter) return 0;
    var tag$1 = delimiter[1], tag = tag$1;
    for(;;){
     var
      tag_conflicts_with$0 =
        function(tag){
         function tag_conflicts_with(fstr){
          var _j_ = caml_call2(Base_Printf[2], fstr, tag);
          return caml_call2(Base_String[92], contents, _j_);
         }
         return tag_conflicts_with;
        },
      tag_conflicts_with = tag_conflicts_with$0(tag);
     if(! tag_conflicts_with(_d_) && ! tag_conflicts_with(_e_))
      return [0, tag];
     var tag$0 = caml_call2(Base[241], tag, cst_xxx), tag = tag$0;
    }
   }
   function to_formatted_payload(param, contents){
    return [0, contents, fix_delimiter_conflicts(contents, param)];
   }
   function to_source_code_string$0
   (expect_node_formatting, shape, tag, contents){
    var
     delimiter =
       fix_delimiter_conflicts
        (contents,
         caml_call2(Ppx_expect_runtime_Types[5][4][2], tag, shape[2])),
     payload = [0, contents, delimiter];
    if(shape[2]){
     var prefix = expect_node_formatting[3], tag$0 = delimiter[1];
     return runtime.caml_string_notequal(tag$0, "")
             ? caml_call6
               (Base_Printf[2], _f_, prefix, shape[1], tag$0, contents, tag$0)
             : caml_call4(Base_Printf[2], _g_, prefix, shape[1], contents);
    }
    var
     prefix$0 =
       shape[3] ? expect_node_formatting[3] : expect_node_formatting[4],
     _i_ = caml_call1(Payload[2], payload);
    return caml_call4(Base_Printf[2], _h_, prefix$0, shape[1], _i_);
   }
   var
    Ppx_expect_runtime_Output =
      [0,
       Type,
       Formatted,
       [0],
       Formatter,
       Test_result,
       Payload,
       reconcile,
       fail,
       to_formatted_payload,
       to_source_code_string$0];
   runtime.caml_register_global
    (15, Ppx_expect_runtime_Output, "Ppx_expect_runtime__Output");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Expectation_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Insert_loc = [0],
    Behavior_type = [0],
    Expect_reachability = [0],
    On_unreachable = [0],
    Behavior = [0],
    Definitions =
      [0,
       Insert_loc,
       Behavior_type,
       Expect_reachability,
       On_unreachable,
       Behavior],
    Ppx_expect_runtime_Expectation = [0, Definitions];
   runtime.caml_register_global
    (0,
     Ppx_expect_runtime_Expectation,
     "Ppx_expect_runtime__Expectation_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Expectation
//# unitInfo: Requires: Base, Base__Char, Base__Int, Base__List, Base__Staged, Base__String, Ppx_expect_runtime__Expectation_intf, Ppx_expect_runtime__Output, Ppx_expect_runtime__Types
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$7 = "",
    cst$6 = " ",
    cst_expect$0 = "expect",
    cst_expect_uncaught_exn = "expect.uncaught_exn",
    cst_test_output$2 = "test output",
    cst_uncaught_exception$1 = "uncaught exception",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$5 = cst$6,
    cst$4 = cst$7,
    cst$0 = cst$7,
    cst$1 = cst$6,
    cst$2 = cst$6,
    cst$3 = cst$7,
    cst = cst$7,
    last_line = cst$6,
    first_line = cst$6,
    Ppx_expect_runtime_Output = global_data.Ppx_expect_runtime__Output,
    Base_Staged = global_data.Base__Staged,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_Int = global_data.Base__Int,
    Base_List = global_data.Base__List,
    Base_Char = global_data.Base__Char,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    cst_uncaught_exception$0 = cst_uncaught_exception$1,
    _g_ = [0, cst_expect_uncaught_exn, 0, 0],
    _h_ = [1, 1],
    cst_trailing_output = "trailing output",
    _f_ = [0, cst_expect$0, 0, 1],
    cst_uncaught_exception = cst_uncaught_exception$1,
    _e_ = [0, cst_expect_uncaught_exn, 0, 0],
    cst_test_output$1 = cst_test_output$2,
    _c_ = [0, cst_expect$0, 0, 1],
    _d_ = [1, 0],
    cst_test_output$0 = cst_test_output$2,
    cst_expect_exact = "expect_exact",
    cst_test_output = cst_test_output$2,
    cst_expect = cst_expect$0,
    _b_ = [0, cst$6, 0],
    _a_ = [0, "\n"];
   function loc(param){
    if(0 === param[0]){var whole_node = param[1]; return whole_node;}
    var loc = param[1][1];
    return loc;
   }
   var Insert_loc = [0, loc];
   function with_behavior(param, behavior){
    var
     inconsistent_outputs_message = param[5],
     on_incorrect_output = param[4],
     payload_type = param[3],
     position = param[1];
    return [0,
            position,
            behavior,
            payload_type,
            on_incorrect_output,
            inconsistent_outputs_message];
   }
   function formatter(expect_node_formatting, param){
    var
     on_incorrect_output = param[4],
     payload_type = param[3],
     behavior = param[2],
     position = param[1],
     _r_ =
       payload_type
        ? function
         (str){
          var
           _s_ = caml_call1(Base_String[104], str),
           func = Base_List[53],
           _t_ =
             caml_call2
              (func, _s_, caml_call1(Base_String[108], [0, Base_Char[45]])),
           _u_ = caml_call2(Base_List[142], _t_, Base_String[14]),
           _v_ = caml_call1(Base_List[63], _u_),
           _w_ = caml_call2(Base_List[142], _v_, Base_String[14]),
           stripped = caml_call1(Base_List[63], _w_);
          function _x_(line){
           var
            _J_ = caml_call2(Base_String[109], 0, line),
            _H_ = caml_call1(Base_String[25], line),
            func = Base_List[141],
            _I_ = caml_call2(func, _H_, caml_call1(Base_Char[12], 32));
           return [0, caml_call1(Base_List[45], _I_), _J_];
          }
          var
           indent_and_contents = caml_call2(Base_List[53], stripped, _x_),
           _y_ = Base_List[13],
           _z_ =
             caml_call2
              (_y_,
               indent_and_contents,
               function(param){
                var indent = param[1];
                return caml_string_notequal(param[2], cst$7) ? [0, indent] : 0;
               }),
           match = caml_call2(Base_List[31], _z_, Base_Int[14]);
          if(match)
           var
            min_indent = match[1],
            _A_ =
              function(param){
               var line = param[2], indent = param[1];
               return [0,
                       caml_call2(Base_Int[16], 0, indent - min_indent | 0),
                       line];
              },
            lines = caml_call2(Base_List[53], indent_and_contents, _A_);
          else
           var lines = 0;
          if(0 === behavior[0])
           var tag = behavior[1][2], tag$0 = tag;
          else
           var tag$0 = Ppx_expect_runtime_Types[5][4][1];
          var _B_ = expect_node_formatting[2];
          if(! lines) return tag$0 ? cst$2 : cst$3;
          if(! lines[2] && ! _B_){
           var line = lines[1][2];
           return tag$0
                   ? caml_call2(Base_String[68], 0, [0, cst$1, [0, line, _b_]])
                   : line;
          }
          if(0 === position[0])
           var
            match$0 = position[1],
            start_pos = match$0[2],
            start_bol = match$0[1],
            _C_ = start_pos - start_bol | 0;
          else
           var
            match$1 = position[1][2],
            start_pos$0 = match$1[2],
            start_bol$0 = match$1[1],
            _F_ = on_incorrect_output[3] ? expect_node_formatting[1] : 0,
            _C_ = (start_pos$0 - start_bol$0 | 0) + _F_ | 0;
          var location_indent = expect_node_formatting[1] + _C_ | 0;
          function spaces(n){return caml_call2(Base_String[66], n, 32);}
          if(tag$0)
           var
            last_line$0 = spaces(location_indent),
            indentation = location_indent,
            first_line$0 = cst;
          else
           var
            last_line$0 = last_line,
            indentation = 1,
            first_line$0 = first_line;
          function _D_(param){
           var indent = param[1];
           if(! caml_string_notequal(param[2], cst$7)) return cst$0;
           var line = param[2], _G_ = spaces(indentation + indent | 0);
           return caml_call2(Base[241], _G_, line);
          }
          var
           lines$0 = caml_call2(Base_List[53], lines, _D_),
           _E_ =
             caml_call1
              (Base_List[11],
               [0,
                [0, first_line$0, 0],
                [0, lines$0, [0, [0, last_line$0, 0], 0]]]);
          return caml_call1(caml_call1(Base_String[68], _a_), _E_);
         }
        : function(_K_){return _K_;};
    return caml_call1(Ppx_expect_runtime_Output[4][1], _r_);
   }
   function extension_syntax(extension_name, payload_loc, node_loc){
    if(payload_loc){
     var
      payload_loc$0 = payload_loc[1],
      _p_ = payload_loc$0[2] <= node_loc[2] ? 1 : 0,
      _q_ = _p_ ? node_loc[3] <= payload_loc$0[3] ? 1 : 0 : _p_;
     if(_q_) return [0, extension_name, 1, 1];
    }
    return [0, extension_name, 0, 1];
   }
   function possibly_relax_strictness(formatting_flexibility, t){
    if(! formatting_flexibility) return t;
    var
     expect_node_formatting = formatting_flexibility[1],
     fmt = formatter(expect_node_formatting, t),
     _n_ = t[2],
     reachability = _n_[3],
     on_unreachable = _n_[2],
     match = _n_[1],
     tag = match[2],
     contents = match[1],
     _o_ = caml_call2(Ppx_expect_runtime_Output[4][2], fmt, contents),
     match$0 = caml_call2(Ppx_expect_runtime_Output[7], contents, _o_);
    if(! match$0) return t;
    var
     contents$0 = match$0[1],
     payload = caml_call2(Ppx_expect_runtime_Output[9], tag, contents$0);
    return with_behavior(t, [0, payload, on_unreachable, reachability]);
   }
   function expected_string_and_payload_lo(param){
    if(! param)
     return [0, caml_call1(Ppx_expect_runtime_Output[6][1], cst$4), 0];
    var match = param[1], b = match[2], a = match[1];
    return [0, a, [0, b]];
   }
   function expect(formatting_flexibility, node_loc, located_payload){
    var
     match = expected_string_and_payload_lo(located_payload),
     payload_loc = match[2],
     payload = match[1];
    return possibly_relax_strictness
            (formatting_flexibility,
             [0,
              [0, node_loc, payload_loc],
              [0, payload, 2, 0],
              1,
              extension_syntax(cst_expect, payload_loc, node_loc),
              cst_test_output]);
   }
   function expect_exact(formatting_flexibility, node_loc, located_payload){
    var
     match = expected_string_and_payload_lo(located_payload),
     payload_loc = match[2],
     payload = match[1];
    return possibly_relax_strictness
            (formatting_flexibility,
             [0,
              [0, node_loc, payload_loc],
              [0, payload, 2, 0],
              0,
              extension_syntax(cst_expect_exact, payload_loc, node_loc),
              cst_test_output$0]);
   }
   function expect_unreachable(node_loc){
    return [0, [0, node_loc, 0], _d_, 1, _c_, cst_test_output$1];
   }
   function expect_uncaught_exn
   (formatting_flexibility, node_loc, located_payload){
    var
     match = expected_string_and_payload_lo(located_payload),
     payload_loc = match[2],
     payload = match[1];
    return possibly_relax_strictness
            (formatting_flexibility,
             [0,
              [0, node_loc, payload_loc],
              [0, payload, 1, 1],
              1,
              _e_,
              cst_uncaught_exception]);
   }
   function expect_trailing(insert_loc){
    return [0,
            [1, insert_loc],
            [0, caml_call1(Ppx_expect_runtime_Output[6][1], cst$5), 0, 0],
            1,
            _f_,
            cst_trailing_output];
   }
   function expect_no_uncaught_exn(insert_loc){
    return [0, [1, insert_loc], _h_, 1, _g_, cst_uncaught_exception$0];
   }
   function format_payload(mk_node){
    function _k_(expect_node_formatting, payload_loc, node_loc, tag, contents){
     var
      node =
        caml_call3
         (mk_node, 0, node_loc, [0, [0, [0, contents, tag], payload_loc]]),
      _l_ = formatter(expect_node_formatting, node),
      formatted_contents =
        caml_call2(Ppx_expect_runtime_Output[4][2], _l_, contents),
      match =
        caml_call2(Ppx_expect_runtime_Output[7], contents, formatted_contents);
     if(! match) return 0;
     var contents$0 = match[1], node_shape = node[4];
     if(node_shape[2])
      var
       source_code_string =
         caml_call4
          (Ppx_expect_runtime_Output[10],
           expect_node_formatting,
           node_shape,
           tag,
           contents$0);
     else
      var
       _m_ = caml_call2(Ppx_expect_runtime_Output[9], tag, contents$0),
       source_code_string = caml_call1(Ppx_expect_runtime_Output[6][2], _m_);
     return [0, source_code_string];
    }
    return caml_call1(Base_Staged[1], _k_);
   }
   var
    _i_ = format_payload(expect),
    format_expect_payload = caml_call1(Base_Staged[2], _i_),
    _j_ = format_payload(expect_uncaught_exn),
    format_uncaught_exn_payload = caml_call1(Base_Staged[2], _j_),
    Ppx_expect_runtime_Expectation =
      [0,
       Insert_loc,
       with_behavior,
       formatter,
       expect,
       expect_exact,
       expect_unreachable,
       expect_uncaught_exn,
       expect_trailing,
       expect_no_uncaught_exn,
       [0, format_expect_payload, format_uncaught_exn_payload]];
   runtime.caml_register_global
    (35, Ppx_expect_runtime_Expectation, "Ppx_expect_runtime__Expectation");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Test_node
//# unitInfo: Requires: Base, Base__Char, Base__Comparable, Base__Error, Base__Hashtbl, Base__List, Base__Option, Base__Printf, Base__Queue, Base__String, Ppx_expect_runtime__Expectation, Ppx_expect_runtime__Output, Ppx_expect_runtime__Types
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$4 = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    tag = [0, cst$4],
    cst$3 = cst$4,
    cst$2 = ";",
    cst = cst$4,
    cst$0 = "\n",
    cst$1 = cst$4,
    Ppx_expect_runtime_Output = global_data.Ppx_expect_runtime__Output,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Ppx_expect_runtime_Expectation =
      global_data.Ppx_expect_runtime__Expectation,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base_List = global_data.Base__List,
    Base = global_data.Base,
    Base_Comparable = global_data.Base__Comparable,
    Base_Option = global_data.Base__Option,
    Base_Queue = global_data.Base__Queue,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Printf = global_data.Base__Printf,
    Base_Error = global_data.Base__Error,
    _e_ =
      [0,
       [11,
        "Internal expect test bug: could not find test\nFile: ",
        [2, 0, [11, "\nID:   ", [4, 0, 0, 0, 0]]]],
       "Internal expect test bug: could not find test\nFile: %s\nID:   %d"],
    _c_ =
      [0,
       [11, "<expect test ran without ", [2, 0, [12, 62, 0]]],
       "<expect test ran without %s>"],
    _b_ = [0, 0],
    _a_ =
      [0,
       [12, 91, [2, 0, [11, "expect.unreachable]", 0]]],
       "[%sexpect.unreachable]"];
   function record_and_return_result
   (expect_node_formatting, failure_ref, test_output_raw, t){
    var
     results = t[2],
     expectation = t[1],
     _P_ =
       caml_call2
        (Ppx_expect_runtime_Expectation[3],
         expect_node_formatting,
         expectation),
     test_output =
       caml_call2(Ppx_expect_runtime_Output[4][2], _P_, test_output_raw),
     _Q_ = expectation[2];
    if(0 === _Q_[0])
     var
      match = _Q_[1],
      tag$0 = match[2],
      contents = match[1],
      tag$1 = tag$0,
      result = caml_call2(Ppx_expect_runtime_Output[7], contents, test_output);
    else
     var
      result$0 = caml_call1(Ppx_expect_runtime_Output[8], test_output),
      tag$1 = tag,
      result = result$0;
    if(result) failure_ref[1] = 1;
    caml_call2(Base_Queue[35], results, [0, [0, result, test_output_raw]]);
    t[3] = 1;
    return [0, result, tag$1];
   }
   function of_expectation(expectation){
    return [0, [0, expectation, caml_call2(Base_Queue[58], 0, 0), 0]];
   }
   function record_end_of_run(t){
    var
     match = t[1],
     results = match[2],
     reached_this_run = match[3],
     _O_ = 1 - reached_this_run;
    return _O_ ? caml_call2(Base_Queue[35], results, 0) : _O_;
   }
   function record_result
   (expect_node_formatting, failure_ref, test_output_raw, param){
    var inner = param[1];
    record_and_return_result
     (expect_node_formatting, failure_ref, test_output_raw, inner);
    return 0;
   }
   function _d_(_N_){return runtime.Base_hash_string(_N_);}
   var
    global_results_table =
      caml_call3
       (Base_Hashtbl[4], 0, 0, [0, Base_String[51], Base_String[42], _d_]);
   function find_test(absolute_filename, test_id){
    var
     _I_ =
       caml_call2(Base_Hashtbl[56], global_results_table, absolute_filename),
     _J_ = Base_Option[22],
     _K_ =
       caml_call2
        (_J_,
         _I_,
         function(param){
          var expectations = param[1];
          return caml_call2(Base_Hashtbl[56], expectations, test_id);
         }),
     func = Base_Option[31],
     _L_ = caml_call1(Ppx_expect_runtime_Types[4][2], test_id),
     _M_ = caml_call3(Base_Printf[2], _e_, absolute_filename, _L_);
    return caml_call2
            (caml_call2(func, 0, [0, caml_call1(Base_Error[14], _M_)]),
             0,
             _K_);
   }
   function initialize_and_register_tests
   (absolute_filename, tests, postprocess){
    var tests_as_in_table = caml_call2(Base_Queue[58], 0, 0);
    function _D_(file){
     var
      _E_ = Ppx_expect_runtime_Types[4],
      _F_ =
        [0,
         caml_call3(Base_Hashtbl[4], 0, 0, [0, _E_[3], _E_[4], _E_[5]]),
         postprocess],
      file$0 = caml_call2(Base_Option[30], file, _F_),
      _G_ = Ppx_expect_runtime_Types[4],
      tests$0 =
        caml_call4(Base_Hashtbl[8], 0, 0, [0, _G_[3], _G_[4], _G_[5]], tests);
     function _H_(test_id, new_test, existing_test){
      var test = caml_call2(Base_Option[30], existing_test, new_test);
      test[1][3] = 0;
      caml_call2(Base_Queue[35], tests_as_in_table, [0, test_id, test]);
      return [0, test];
     }
     caml_call3(Base_Hashtbl[66], tests$0, file$0[1], _H_);
     return file$0;
    }
    caml_call3(Base_Hashtbl[41], global_results_table, absolute_filename, _D_);
    return caml_call1(Base_Queue[20], tests_as_in_table);
   }
   function process_each_file(f){
    var
     _A_ = caml_call1(Base_Hashtbl[78], global_results_table),
     func = Base_List[83],
     _B_ =
       caml_call2
        (func,
         _A_,
         caml_call2(Base_Comparable[2], Base_String[51], Base[242])),
     _C_ = Base_List[53];
    return caml_call2
            (_C_,
             _B_,
             function(param){
              var
               match = param[2],
               postprocess = match[2],
               expectations = match[1],
               filename = param[1],
               test_nodes = caml_call1(Base_Hashtbl[68], expectations);
              return caml_call3(f, filename, test_nodes, postprocess);
             });
   }
   function expect(formatting_flexibility, node_loc, located_payload){
    return of_expectation
            (caml_call3
              (Ppx_expect_runtime_Expectation[4],
               formatting_flexibility,
               node_loc,
               located_payload));
   }
   function expect_exact(formatting_flexibility, node_loc, located_payload){
    return of_expectation
            (caml_call3
              (Ppx_expect_runtime_Expectation[5],
               formatting_flexibility,
               node_loc,
               located_payload));
   }
   function expect_unreachable(node_loc){
    return of_expectation
            (caml_call1(Ppx_expect_runtime_Expectation[6], node_loc));
   }
   var Create = [0, expect, expect_exact, expect_unreachable];
   function loc(param){
    var position = param[1][1][1];
    return caml_call1(Ppx_expect_runtime_Expectation[1][1], position);
   }
   function expectation_of_t(param){
    var expectation = param[1][1], _z_ = expectation[2];
    if(0 !== _z_[0]) return 0;
    var contents = _z_[1][1];
    return [0, contents];
   }
   function record_and_return_number_of_li
   (expect_node_formatting, failure_ref, test_output_raw, param){
    var
     _w_ =
       record_and_return_result
        (expect_node_formatting, failure_ref, test_output_raw, param[1]),
     match = _w_[1];
    if(! match) return 0;
    var
     tag = _w_[2],
     contents = match[1],
     _x_ = caml_call2(Ppx_expect_runtime_Output[9], tag, contents),
     correction = caml_call1(Ppx_expect_runtime_Output[6][2], _x_),
     _y_ = caml_call1(Base_Char[16], 10);
    return [0, caml_call2(Base_String[21], correction, _y_) + 1 | 0];
   }
   function to_diffs
   (cr_for_multiple_outputs,
    expect_node_formatting,
    original_file_contents,
    t){
    var
     match$4 = t[1],
     results = match$4[2],
     expectation = match$4[1],
     results_list = caml_call1(Base_Queue[20], results);
    function _p_(param){
     if(! param) return _b_;
     var output = param[1];
     return [1, output];
    }
    var
     match$5 = caml_call2(Base_List[16], results_list, _p_),
     outputs_list = match$5[2],
     unreached_list = match$5[1];
    function _q_(param){var result = param[1]; return result;}
    var
     _r_ =
       caml_call2(Base_Comparable[2], Ppx_expect_runtime_Output[5][1], _q_),
     distinct_outputs = caml_call2(Base_List[126], outputs_list, _r_),
     was_reached = caml_call1(Base_List[18], unreached_list),
     match$6 = expectation[2];
    if(0 === match$6[0])
     var reachability = match$6[3], reachability_behavior = reachability;
    else
     var
      reachability_of_corrected = match$6[1],
      reachability_behavior = reachability_of_corrected;
    function correction_for_single_result(param){
     if(! param) return 0;
     var received = param[1];
     return [0, [0, expectation, received]];
    }
    a:
    if(distinct_outputs){
     b:
     if(! distinct_outputs[2]){
      var result = distinct_outputs[1][1];
      if(! was_reached && reachability_behavior) break b;
      var match$7 = correction_for_single_result(result);
      break a;
     }
     var
      _s_ = Base_List[53],
      outputs =
        caml_call2
         (_s_,
          results_list,
          function(param){
           if(! param) return caml_call2(Base_Printf[2], _c_, expectation[5]);
           var raw = param[1][2];
           return raw;
          }),
      _t_ = caml_call2(cr_for_multiple_outputs, expectation[5], outputs),
      _u_ =
        caml_call2
         (Ppx_expect_runtime_Expectation[3],
          expect_node_formatting,
          expectation),
      _v_ = caml_call1(caml_call1(Ppx_expect_runtime_Output[4][2], _u_), _t_),
      match$7 =
        correction_for_single_result
         (caml_call1(Ppx_expect_runtime_Output[8], _v_));
    }
    else
     var
      behavior$0 = expectation[2],
      match$7 =
        0 === behavior$0[0]
         ? [0,
           [1,
            caml_call2
             (Ppx_expect_runtime_Expectation[2], expectation, behavior$0)]]
         : 0;
    if(! match$7) return 0;
    var correction$2 = match$7[1];
    function safe_byte_get(string, i){
     if(0 <= i && i < runtime.caml_ml_string_length(string))
      return [0, runtime.caml_string_get(string, i)];
     return 0;
    }
    if(0 === correction$2[0]){
     var
      _f_ = correction$2[1],
      on_incorrect_output = _f_[4],
      test_output = correction$2[2],
      behavior = _f_[2],
      position = _f_[1];
     if(0 === position[0])
      var whitespace = cst;
     else
      var
       match = position[1][2],
       start_pos = match[2],
       start_bol = match[1],
       let_offset = start_pos - start_bol | 0,
       _j_ = on_incorrect_output[3] ? expect_node_formatting[1] : 0,
       indent = let_offset + _j_ | 0,
       _k_ = caml_call2(Base_String[66], indent, 32),
       whitespace$0 = caml_call2(Base[241], cst$0, _k_),
       whitespace = whitespace$0;
     if(0 === behavior[0])
      var tag = behavior[1][2], tag$0 = tag;
     else
      var tag$0 = Ppx_expect_runtime_Types[5][4][1];
     a:
     {
      if(0 === position[0]){
       var _h_ = position[2], _g_ = position[1];
       if(_h_ && ! on_incorrect_output[2] && on_incorrect_output[3]){
        var
         payload_loc = _h_[1],
         _i_ = caml_call2(Ppx_expect_runtime_Output[9], tag$0, test_output),
         correction$1 = caml_call1(Ppx_expect_runtime_Output[6][2], _i_),
         correction$0 = correction$1,
         loc$0 = payload_loc;
        break a;
       }
       var loc = _g_;
      }
      else
       var loc = position[1][1];
      var
       correction =
         caml_call4
          (Ppx_expect_runtime_Output[10],
           expect_node_formatting,
           on_incorrect_output,
           tag$0,
           test_output),
       correction$0 = correction,
       loc$0 = loc;
     }
     var
      match$0 =
        [0, [0, loc$0, caml_call2(Base[241], whitespace, correction$0)]];
    }
    else{
     var
      _l_ = correction$2[1],
      on_incorrect_output$0 = _l_[4],
      on_unreachable = _l_[2][2],
      position$0 = _l_[1],
      loc$1 = caml_call1(Ppx_expect_runtime_Expectation[1][1], position$0);
     switch(on_unreachable){
       case 0:
        var match$0 = 0; break;
       case 1:
        var match$0 = [0, [0, loc$1, cst$1]]; break;
       default:
        var
         prefix =
           on_incorrect_output$0[3]
            ? expect_node_formatting[3]
            : expect_node_formatting[4],
         match$0 = [0, [0, loc$1, caml_call2(Base_Printf[2], _a_, prefix)]];
     }
    }
    if(! match$0) return 0;
    var
     match$1 = match$0[1],
     diff = match$1[2],
     loc$2 = match$1[1],
     end_pos = loc$2[3],
     start_pos$0 = loc$2[2],
     start_bol$0 = loc$2[1],
     main_correction = [0, [0, loc$2, diff], 0];
    a:
    {
     if(1 === correction$2[0] && ! correction$2[1][4][3]){
      var
       match$2 = safe_byte_get(original_file_contents, start_pos$0 - 1 | 0),
       match$3 = safe_byte_get(original_file_contents, end_pos);
      b:
      {
       c:
       if(match$2 && 10 === match$2[1]){
        if(match$3 && 10 !== match$3[1]) break c;
        var
         _o_ =
           [0, [0, [0, start_bol$0, start_pos$0 - 1 | 0, start_pos$0], cst$3]];
        break b;
       }
       var _o_ = 0;
      }
      var remove_empty_line_from_deleted = _o_;
      break a;
     }
     var remove_empty_line_from_deleted = 0;
    }
    a:
    {
     if(0 === correction$2[0]){
      var _m_ = correction$2[1], _n_ = _m_[1];
      if(0 !== _n_[0] && _m_[4][3]){
       var
        body_loc = _n_[1][2],
        add_semicolon_before_trailing_ =
          [0, [0, [0, body_loc[1], body_loc[3], body_loc[3]], cst$2]];
       break a;
      }
     }
     var add_semicolon_before_trailing_ = 0;
    }
    var
     additional_corrections =
       caml_call2
        (Base_List[14],
         [0,
          remove_empty_line_from_deleted,
          [0, add_semicolon_before_trailing_, 0]],
         Base_Option[42]);
    return caml_call2(Base[222], additional_corrections, main_correction);
   }
   var
    Ppx_expect_runtime_Test_node =
      [0,
       Create,
       of_expectation,
       record_end_of_run,
       record_result,
       [0, initialize_and_register_tests, find_test, process_each_file],
       [0, expectation_of_t, record_and_return_number_of_li, loc, to_diffs]];
   runtime.caml_register_global
    (23, Ppx_expect_runtime_Test_node, "Ppx_expect_runtime__Test_node");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Current_file
//# unitInfo: Requires: Base, Base__Or_error, Base__Printf, Base__String, CamlinternalLazy, Stdlib__Filename, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_String = global_data.Base__String,
    Base = global_data.Base,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Filename = global_data.Stdlib__Filename,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Or_error = global_data.Base__Or_error,
    current = [0, 0],
    _c_ =
      [0,
       [11,
        "Trying to run an expect test from the wrong file.\n- test declared at ",
        [2,
         0,
         [12,
          58,
          [4,
           0,
           0,
           0,
           [11, "\n- trying to run it from ", [2, 0, [12, 10, 0]]]]]]],
       "Trying to run an expect test from the wrong file.\n- test declared at %s:%d\n- trying to run it from %s\n"],
    cst_Expect_test_collector_get_ =
      "Expect_test_collector.get: there is no active file",
    cst_Expect_test_collector_unse =
      "Expect_test_collector.unset: there is no active file",
    cst_new_file = "new_file",
    cst_old_file = "old_file",
    cst_Expect_test_collector_set_ =
      "Expect_test_collector.set: there is already an active file",
    _b_ = [0, 1];
   function set(filename_rel_to_project_root){
    var match = current[1];
    if(match){
     var
      current$0 = match[1],
      _j_ =
        [0,
         [0,
          cst_new_file,
          caml_call1(Base[202], filename_rel_to_project_root)],
         0],
      _k_ = [0, [0, cst_old_file, caml_call1(Base[202], current$0)], _j_],
      _l_ = caml_call2(Base[85][8], cst_Expect_test_collector_set_, _k_);
     return caml_call1(Base[246], _l_);
    }
    current[1] = [0, filename_rel_to_project_root];
    return 0;
   }
   function unset(param){
    if(current[1]){current[1] = 0; return 0;}
    var _i_ = caml_call2(Base[85][8], cst_Expect_test_collector_unse, 0);
    return caml_call1(Base[246], _i_);
   }
   function get(param){
    var match = current[1];
    if(match){var fn = match[1]; return fn;}
    var _h_ = caml_call2(Base[85][8], cst_Expect_test_collector_get_, 0);
    return caml_call1(Base[246], _h_);
   }
   function _a_(_g_){return runtime.caml_sys_getcwd(_g_);}
   var
    dir_or_error = caml_call2(Base_Or_error[31], _b_, _a_),
    initial_dir =
      [246,
       function(_f_){return caml_call1(Base_Or_error[34], dir_or_error);}];
   function absolute_path(file){
    if(! caml_call1(Stdlib_Filename[5], file)) return file;
    var _d_ = runtime.caml_obj_tag(initial_dir);
    a:
    if(250 === _d_)
     var _e_ = initial_dir[1];
    else{
     if(246 !== _d_ && 244 !== _d_){var _e_ = initial_dir; break a;}
     var _e_ = caml_call1(CamlinternalLazy[2], initial_dir);
    }
    return caml_call2(Stdlib_Filename[4], _e_, file);
   }
   function verify_that_file_is_current_ex
   (line_number, filename_rel_to_project_root){
    var registering_tests_for = get(0);
    return caml_call2
             (Base_String[134],
              filename_rel_to_project_root,
              registering_tests_for)
            ? 0
            : caml_call5
              (Base_Printf[4],
               Base[244],
               _c_,
               filename_rel_to_project_root,
               line_number,
               registering_tests_for);
   }
   var
    Ppx_expect_runtime_Current_fil =
      [0,
       set,
       unset,
       get,
       initial_dir,
       absolute_path,
       verify_that_file_is_current_ex];
   runtime.caml_register_global
    (13, Ppx_expect_runtime_Current_fil, "Ppx_expect_runtime__Current_file");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Test_block
//# unitInfo: Requires: Base, Base__Exn, Base__List, Base__Option, Base__Printf, Base__Source_code_position, Base__String, Expect_test_config, Ppx_expect_runtime__Current_file, Ppx_expect_runtime__Expectation, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Types, Ppx_inline_test_lib, Stdlib, Stdlib__Filename, Stdlib__Format, Stdlib__Obj, Stdlib__Printexc, Stdlib__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst$5 = "\n",
    cst$6 = "(* ",
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    partial = [12, 10, [10, 0]],
    cst$3 = cst$4,
    cst$1 = "---------------",
    cst$2 = cst$4,
    cst = "\n\n",
    cst$0 = cst$4,
    Expect_test_config = global_data.Expect_test_config,
    Base_Source_code_position = global_data.Base__Source_code_position,
    Base_Printf = global_data.Base__Printf,
    Base = global_data.Base,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Base_Option = global_data.Base__Option,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_List = global_data.Base__List,
    Ppx_expect_runtime_Current_fil =
      global_data.Ppx_expect_runtime__Current_file,
    Ppx_expect_runtime_Expectation =
      global_data.Ppx_expect_runtime__Expectation,
    Base_String = global_data.Base__String,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Format = global_data.Stdlib__Format,
    _o_ =
      [0,
       [11,
        "Ppx_expect_runtime.read_current_test_output_exn called while there are no tests running at ",
        [2, 0, 0]],
       "Ppx_expect_runtime.read_current_test_output_exn called while there are no tests running at %s"],
    _n_ =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4,
             0,
             0,
             0,
             [12,
              45,
              [4,
               0,
               0,
               0,
               [11,
                ":\nError: program exited while expect test was running!\nOutput captured so far:\n",
                [2, 0, partial]]]]]]]]]],
       "File %S, line %d, characters %d-%d:\nError: program exited while expect test was running!\nOutput captured so far:\n%s\n%!"],
    cst_Trailing_output = "Trailing output",
    _m_ = [0, cst$5],
    _k_ = [0, "line"],
    _l_ = [0, "file"],
    cst_inner_test = "inner_test",
    cst_outer_test = "outer_test",
    cst_Expect_test_runtime_reache =
      "Expect_test_runtime: reached one [let%expect_test] from another. Nesting expect\ntests is prohibited.",
    _i_ =
      [0,
       [11,
        '("',
        [2, 0, [11, '(Cannot print more details, Exn.to_string failed)")', 0]]],
       '("%s(Cannot print more details, Exn.to_string failed)")'],
    _j_ = [0, cst$5],
    _h_ =
      [0,
       "Raised at ",
       [0, "Called from ", [0, "Raised by primitive operation ", 0]]],
    _e_ =
      [0,
       [11,
        "=== Output ",
        [4, 0, 0, 0, [11, " / ", [4, 0, 0, 0, [11, " ===", 0]]]]],
       "=== Output %d / %d ==="],
    _f_ = [0, [2, 0, [2, 0, [2, 0, 0]]], "%s%s%s"],
    _c_ =
      [0,
       [11, "Test ran multiple times with different ", [2, 0, [12, 115, 0]]],
       "Test ran multiple times with different %ss"],
    _d_ =
      [0,
       [11, cst$6, [2, 0, [11, "expect_test: ", [2, 0, [11, " *)", 0]]]]],
       "(* %sexpect_test: %s *)"],
    _g_ = [0, cst$5],
    cst_CR = "CR ",
    _b_ =
      [0,
       [11,
        cst$6,
        [2,
         0,
         [11,
          "expect_test_collector: This test expectation appears to contain a backtrace.\n   This is strongly discouraged as backtraces are fragile.\n   Please change this test to not include a backtrace. *)",
          0]]],
       "(* %sexpect_test_collector: This test expectation appears to contain a backtrace.\n   This is strongly discouraged as backtraces are fragile.\n   Please change this test to not include a backtrace. *)"],
    cst_output = "output",
    cst_expect_test = "expect-test",
    _a_ = [0, 1, [0, 3, 0]];
   function clean_up_block(param){
    var
     test_output_writer = param[5],
     test_output_reader = param[4],
     output_file = param[2];
    caml_call1(Stdlib[93], test_output_reader);
    runtime.ppx_expect_runtime_after_test(Stdlib[39], Stdlib[40]);
    caml_call1(Stdlib[76], test_output_writer);
    runtime.caml_sys_remove(output_file);
    return;
   }
   function flush(param){
    caml_call2(Stdlib_Format[38], Stdlib_Format[110], 0);
    caml_call2(Stdlib_Format[38], Stdlib_Format[112], 0);
    caml_call1(Stdlib[63], Stdlib[39]);
    caml_call1(Stdlib[63], Stdlib[40]);
    runtime.ppx_expect_runtime_flush_stubs_streams(0);
    return;
   }
   function read_test_output_unsanitized(param){
    var old_offset = param[6], test_output_reader = param[4];
    flush(0);
    var
     new_offset = runtime.ppx_expect_runtime_out_channel_position(Stdlib[39]),
     len = new_offset - old_offset[1] | 0;
    old_offset[1] = new_offset;
    return caml_call2(Stdlib[86], test_output_reader, len);
   }
   function Configured(C){
    var
     cr_prefix = 15023 <= C[4] ? cst_CR : cst$0,
     cr_for_backtrace = caml_call2(Base_Printf[2], _b_, cr_prefix);
    function cr_for_multiple_outputs(output_name, outputs){
     var
      cr_body = caml_call2(Base_Printf[2], _c_, output_name),
      cr = caml_call3(Base_Printf[2], _d_, cr_prefix, cr_body),
      num_outputs = caml_call1(Base_List[45], outputs);
     function _W_(index, output){
      var
       header = caml_call3(Base_Printf[2], _e_, index + 1 | 0, num_outputs),
       pad_length =
         caml_ml_string_length(cr) - caml_ml_string_length(header) | 0,
       _X_ = [0, output, 0];
      if(0 < pad_length)
       var
        lpad = caml_call2(Base_String[66], pad_length / 2 | 0, 61),
        rpad =
          caml_call2
           (Base_String[66], pad_length - (pad_length / 2 | 0) | 0, 61),
        _Y_ = caml_call4(Base_Printf[2], _f_, lpad, header, rpad);
      else
       var _Y_ = header;
      return [0, _Y_, _X_];
     }
     var outputs_with_headers = caml_call2(Base_List[44], outputs, _W_);
     return caml_call2(Base_String[68], _g_, [0, cr, outputs_with_headers]);
    }
    var sanitize = C[3];
    function check_for_backtraces(s){
     function _U_(substring){
      return caml_call2(Base_String[92], s, substring);
     }
     if(! caml_call2(Base_List[23], _h_, _U_)) return s;
     var _V_ = caml_call2(Base[241], cst, s);
     return caml_call2(Base[241], cr_for_backtrace, _V_);
    }
    function dump_backtrace(possible_exn){
     try{caml_call1(C[2], possible_exn);}
     catch(exn$0){
      var
       exn = caml_wrap_exception(exn$0),
       bt = caml_call1(Stdlib_Printexc[12], 0);
      try{var _S_ = caml_call1(Base_Exn[10], exn), exn_string = _S_;}
      catch(_T_){
       var
        _Q_ = caml_call1(Stdlib_Obj[23][1], exn),
        name = caml_call1(Stdlib_Obj[23][2], _Q_),
        exn_string = caml_call2(Base_Printf[2], _i_, name);
      }
      var
       bt$0 = caml_call1(Stdlib_Printexc[14], bt),
       _R_ =
         caml_string_notequal(bt$0, cst$4)
          ? caml_call2
            (Base_String[68],
             _j_,
             [0, cr_for_backtrace, [0, exn_string, [0, bt$0, 0]]])
          : exn_string;
      return [0, _R_];
     }
     return 0;
    }
    return [0,
            ,
            ,
            cr_for_multiple_outputs,
            sanitize,
            check_for_backtraces,
            dump_backtrace];
   }
   var test_is_running = [0, 0];
   function am_running_expect_test(param){
    return caml_call1(Base_Option[53], test_is_running[1]);
   }
   function current_test(param){
    function _P_(param){var test_block = param[4]; return test_block;}
    return caml_call2(Base_Option[24], test_is_running[1], _P_);
   }
   function current_test_exn(param){
    var _O_ = current_test(0);
    return caml_call4(Base_Option[31], 0, 0, 0, _O_);
   }
   function iter(f){
    return caml_call2(Base_Option[37], test_is_running[1], f);
   }
   function at_exit(param){
    return iter
            (function(param){
              var
               test_block = param[4],
               match = param[3],
               end_pos = match[3],
               start_pos = match[2],
               start_bol = match[1],
               basename = param[2],
               line_number = param[1];
              flush(0);
              var
               fin = caml_call1(Stdlib[79], test_block[2]),
               _N_ = caml_call1(Stdlib[92], fin),
               all_out = caml_call2(Stdlib[86], fin, _N_);
              clean_up_block(test_block);
              return caml_call6
                      (Stdlib_Printf[3],
                       _n_,
                       basename,
                       line_number,
                       start_pos - start_bol | 0,
                       end_pos - start_bol | 0,
                       all_out);
             });
   }
   function read_current_test_output_exn(here){
    var match = current_test(0);
    if(match){
     var
      test_block = match[1],
      _K_ = read_test_output_unsanitized(test_block);
     return caml_call1(Expect_test_config[3], _K_);
    }
    var
     _L_ = caml_call1(Base_Source_code_position[22], here),
     _M_ = caml_call2(Base_Printf[2], _o_, _L_);
    return caml_call1(Base[244], _M_);
   }
   var
    default_cr_for_multiple_output = Configured(Expect_test_config)[3],
    For_external =
      [0,
       read_current_test_output_exn,
       am_running_expect_test,
       default_cr_for_multiple_output],
    Ppx_expect_runtime_Test_block =
      [0,
       function(C){
        var Configured$0 = Configured(C);
        function read_test_output_no_backtrace_(param){
         var _J_ = read_test_output_unsanitized(current_test_exn(0));
         return caml_call1(Configured$0[4], _J_);
        }
        function read_test_output_sanitized_and(param){
         var _I_ = read_test_output_no_backtrace_(0);
         return Configured$0[5].call(null, _I_);
        }
        function run_test_inner(test_id, test_output_raw, t){
         var
          _H_ = caml_call2(Ppx_expect_runtime_Test_node[5][2], t[1], test_id);
         return caml_call4
                 (Ppx_expect_runtime_Test_node[4],
                  Ppx_expect_runtime_Types[1][1],
                  t[3],
                  test_output_raw,
                  _H_);
        }
        function run_test(test_id){
         var _G_ = current_test_exn(0);
         return run_test_inner
                 (test_id, read_test_output_sanitized_and(0), _G_);
        }
        function run_suite
        (filename_rel_to_project_root,
         line_number,
         location,
         trailing_loc,
         body_loc,
         formatting_flexibility,
         expected_exn,
         test_to_run,
         exn_test_id,
         description,
         tags,
         inline_test_config,
         expectations,
         f){
         var
          end_pos = location[3],
          start_pos = location[2],
          start_bol = location[1],
          basename =
            caml_call1(Stdlib_Filename[13], filename_rel_to_project_root);
         iter
          (function(param){
            var outer_basename = param[2], outer_line_number = param[1];
            function sexp_here(basename, line_number){
             var
              _F_ =
                [0,
                 [1, [0, _k_, [0, caml_call1(Base[136], line_number), 0]]],
                 0];
             return [1,
                     [0,
                      [1, [0, _l_, [0, caml_call1(Base[202], basename), 0]]],
                      _F_]];
            }
            var
             _C_ =
               [0, [0, cst_inner_test, sexp_here(basename, line_number)], 0],
             _D_ =
               [0,
                [0,
                 cst_outer_test,
                 sexp_here(outer_basename, outer_line_number)],
                _C_],
             _E_ =
               caml_call2(Base[85][8], cst_Expect_test_runtime_reache, _D_);
            return caml_call1(Base[246], _E_);
           });
         function _p_(param){
          caml_call2
           (Ppx_expect_runtime_Current_fil[6],
            line_number,
            filename_rel_to_project_root);
          var
           absolute_filename =
             caml_call1(Ppx_expect_runtime_Current_fil[5], basename),
           _v_ =
             caml_call1
              (Ppx_expect_runtime_Expectation[8],
               [0,
                [0, trailing_loc[1], trailing_loc[2], trailing_loc[2]],
                body_loc]),
           trailing_test = caml_call1(Ppx_expect_runtime_Test_node[2], _v_);
          if(expected_exn)
           var
            _w_ =
              caml_call3
               (Ppx_expect_runtime_Expectation[7],
                formatting_flexibility,
                trailing_loc,
                expected_exn),
            exn_test = caml_call1(Ppx_expect_runtime_Test_node[2], _w_);
          else
           var
            _A_ =
              caml_call1
               (Ppx_expect_runtime_Expectation[9],
                [0, trailing_loc, body_loc]),
            exn_test = caml_call1(Ppx_expect_runtime_Test_node[2], _A_);
          var
           expectations$0 =
             [0,
              [0, exn_test_id, exn_test],
              [0, [0, test_to_run, trailing_test], expectations]];
          function _x_(original_file_contents, ts){
           var
            _B_ =
              caml_call3
               (Ppx_expect_runtime_Test_node[6][4],
                Configured$0[3],
                Ppx_expect_runtime_Types[1][1],
                original_file_contents);
           return caml_call2(Base_List[14], ts, _B_);
          }
          var
           expectations$1 =
             caml_call3
              (Ppx_expect_runtime_Test_node[5][1],
               absolute_filename,
               expectations$0,
               _x_);
          flush(0);
          var
           _u_ =
             caml_call3(Stdlib_Filename[16], 0, cst_expect_test, cst_output),
           output_file = caml_call1(Ppx_expect_runtime_Current_fil[5], _u_),
           test_output_writer = caml_call3(Stdlib[62], _a_, 420, output_file),
           test_output_reader = caml_call1(Stdlib[79], output_file);
          runtime.ppx_expect_runtime_before_test
           (test_output_writer, Stdlib[39], Stdlib[40]);
          var
           test_block =
             [0,
              absolute_filename,
              output_file,
              [0, 0],
              test_output_reader,
              test_output_writer,
              [0, 0]],
           t = [0, line_number, basename, location, test_block];
          test_is_running[1] = [0, t];
          function _y_(param){
           read_test_output_unsanitized(test_block);
           return caml_call1(f, 0);
          }
          var
           test_exn = Configured$0[6].call(null, _y_),
           trailing_raw = read_test_output_sanitized_and(0),
           trailing_output =
             caml_string_notequal
               (caml_call2(Base_String[109], 0, trailing_raw), cst$4)
              ? [0, trailing_raw]
              : 0;
          if(test_exn){
           var test_exn$0 = test_exn[1];
           if(trailing_output)
            var
             trailing_output$0 = trailing_output[1],
             test_output =
               caml_call2
                (Base_String[68],
                 _m_,
                 [0,
                  test_exn$0,
                  [0,
                   cst_Trailing_output,
                   [0, cst$1, [0, trailing_output$0, 0]]]]);
           else
            var test_output = test_exn$0;
           var test_to_run$0 = exn_test_id, test_output$0 = test_output;
          }
          else
           var
            test_output$1 =
              caml_call2(Base_Option[30], trailing_output, cst$2),
            test_to_run$0 = test_to_run,
            test_output$0 = test_output$1;
          run_test_inner(test_to_run$0, test_output$0, test_block);
          function _z_(param){
           var test_node = param[2];
           return caml_call1(Ppx_expect_runtime_Test_node[3], test_node);
          }
          caml_call2(Base_List[19], expectations$1, _z_);
          clean_up_block(test_block);
          test_is_running[1] = 0;
          return 1;
         }
         var
          _q_ = end_pos - start_bol | 0,
          _r_ = start_pos - start_bol | 0,
          _s_ =
            [246,
             function(_t_){
              return caml_call2(Base_Option[30], description, cst$3);
             }];
         return caml_call8
                 (Ppx_inline_test_lib[8],
                  inline_test_config,
                  _s_,
                  tags,
                  basename,
                  line_number,
                  _r_,
                  _q_,
                  _p_);
        }
        return [0, read_test_output_no_backtrace_, run_test, run_suite];
       },
       For_external,
       at_exit];
   runtime.caml_register_global
    (48, Ppx_expect_runtime_Test_block, "Ppx_expect_runtime__Test_block");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime
//# unitInfo: Requires: CamlinternalLazy, Ppx_expect_runtime__Current_file, Ppx_expect_runtime__Test_block, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Write_corrected_file, Ppx_inline_test_lib, Stdlib, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ppx_expect_runtime_Write_corre =
      global_data.Ppx_expect_runtime__Write_corrected_file,
    Ppx_expect_runtime_Current_fil =
      global_data.Ppx_expect_runtime__Current_file,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Ppx_expect_runtime_Test_block = global_data.Ppx_expect_runtime__Test_block,
    Stdlib = global_data.Stdlib;
   function _a_(param){
    var
     _b_ = Ppx_expect_runtime_Current_fil[4],
     _c_ = runtime.caml_obj_tag(_b_);
    a:
    if(250 === _c_)
     var _d_ = _b_[1];
    else{
     if(246 !== _c_ && 244 !== _c_){var _d_ = _b_; break a;}
     var _d_ = caml_call1(CamlinternalLazy[2], _b_);
    }
    runtime.caml_sys_chdir(_d_);
    function _e_(filename, test_nodes, postprocess){
     var
      _g_ = caml_call1(Ppx_inline_test_lib[14], 0),
      _h_ = caml_call1(Ppx_inline_test_lib[13], 0),
      _i_ = caml_call1(Ppx_inline_test_lib[12], 0),
      _j_ = caml_call1(Ppx_inline_test_lib[11], 0);
     return caml_call7
             (Ppx_expect_runtime_Write_corre[2],
              _j_,
              _i_,
              _h_,
              _g_,
              filename,
              postprocess,
              test_nodes);
    }
    var _f_ = caml_call1(Ppx_expect_runtime_Test_node[5][3], _e_);
    return caml_call1(Ppx_inline_test_lib[5][2], _f_);
   }
   caml_call1(Ppx_inline_test_lib[16], _a_);
   caml_call1(Stdlib[100], Ppx_expect_runtime_Test_block[3]);
   var
    Current_file =
      [0,
       Ppx_expect_runtime_Current_fil[1],
       Ppx_expect_runtime_Current_fil[2]],
    Test_node = [0],
    Ppx_expect_runtime = [0, Current_file, Test_node];
   runtime.caml_register_global(7, Ppx_expect_runtime, "Ppx_expect_runtime");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfZXhwZWN0X3J1bnRpbWUuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImRlZmF1bHQkMCIsImRlZmF1bHQkMSIsImVxdWFsIiwiYSIsImIiLCJ0IiwiY29tcGFyZV9jaGFyYWN0ZXJfcmFuZ2UiLCJjb3VudGVyIiwibWludCIsImlkIiwiaGFuZGVkIiwiaGFuZCIsImYiLCJ1c2VfY29sb3IiLCJpbl9wbGFjZSIsImRpZmZfY29tbWFuZCIsImRpZmZfcGF0aF9wcmVmaXgiLCJmaWxlbmFtZSIsIndpdGgkMCIsImNvcnJlY3Rpb25zJDAiLCJkb3RfY29ycmVjdGVkIiwiaW5fY2hhbm5lbCIsIm9yaWdpbmFsX2ZpbGVfY29udGVudHMiLCJyZW1vdmUiLCJmaWxlIiwiY29ycmVjdGlvbnMkMSIsImNvcnJlY3Rpb25zIiwibF9wb3MiLCJjb3JyZWN0aW9uIiwiZW5kX3BvcyIsInN0YXJ0X3BvcyIsImNvZGVfY2h1bmsiLCJzdHJzIiwicmVzdWx0IiwicmVzdCIsIm5leHRfY29udGVudHMiLCJ0bXBfY29ycmVjdGVkIiwiY29tcGFyZSIsImNyZWF0ZSIsImZvcm1hdCIsImFwcGx5Iiwic3RyIiwiY29tcGFyZSQwIiwiYiQwIiwiYSQwIiwiY29udGVudHMiLCJ0b19zb3VyY2VfY29kZV9zdHJpbmciLCJ0YWciLCJ0ZXN0X291dHB1dCIsInRhZyQwIiwicmVjb25jaWxlIiwiZXhwZWN0ZWRfb3V0cHV0IiwiZmFpbCIsImVycm9yX291dHB1dCIsImZpeF9kZWxpbWl0ZXJfY29uZmxpY3RzIiwiZGVsaW1pdGVyIiwidGFnJDEiLCJ0YWdfY29uZmxpY3RzX3dpdGgkMCIsInRhZ19jb25mbGljdHNfd2l0aCIsImZzdHIiLCJ0b19mb3JtYXR0ZWRfcGF5bG9hZCIsInBhcmFtIiwidG9fc291cmNlX2NvZGVfc3RyaW5nJDAiLCJleHBlY3Rfbm9kZV9mb3JtYXR0aW5nIiwic2hhcGUiLCJwYXlsb2FkIiwicHJlZml4IiwicHJlZml4JDAiLCJsYXN0X2xpbmUiLCJmaXJzdF9saW5lIiwibG9jIiwid2hvbGVfbm9kZSIsIndpdGhfYmVoYXZpb3IiLCJiZWhhdmlvciIsImluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UiLCJvbl9pbmNvcnJlY3Rfb3V0cHV0IiwicGF5bG9hZF90eXBlIiwicG9zaXRpb24iLCJmb3JtYXR0ZXIiLCJzdHJpcHBlZCIsImxpbmUiLCJpbmRlbnRfYW5kX2NvbnRlbnRzIiwiaW5kZW50IiwibWluX2luZGVudCIsImxpbmVzIiwic3RhcnRfYm9sIiwic3RhcnRfcG9zJDAiLCJzdGFydF9ib2wkMCIsImxvY2F0aW9uX2luZGVudCIsInNwYWNlcyIsIm4iLCJsYXN0X2xpbmUkMCIsImluZGVudGF0aW9uIiwiZmlyc3RfbGluZSQwIiwibGluZXMkMCIsImV4dGVuc2lvbl9zeW50YXgiLCJleHRlbnNpb25fbmFtZSIsInBheWxvYWRfbG9jIiwibm9kZV9sb2MiLCJwYXlsb2FkX2xvYyQwIiwicG9zc2libHlfcmVsYXhfc3RyaWN0bmVzcyIsImZvcm1hdHRpbmdfZmxleGliaWxpdHkiLCJmbXQiLCJyZWFjaGFiaWxpdHkiLCJvbl91bnJlYWNoYWJsZSIsImNvbnRlbnRzJDAiLCJleHBlY3RlZF9zdHJpbmdfYW5kX3BheWxvYWRfbG8iLCJleHBlY3QiLCJsb2NhdGVkX3BheWxvYWQiLCJleHBlY3RfZXhhY3QiLCJleHBlY3RfdW5yZWFjaGFibGUiLCJleHBlY3RfdW5jYXVnaHRfZXhuIiwiZXhwZWN0X3RyYWlsaW5nIiwiaW5zZXJ0X2xvYyIsImV4cGVjdF9ub191bmNhdWdodF9leG4iLCJmb3JtYXRfcGF5bG9hZCIsIm1rX25vZGUiLCJub2RlIiwiZm9ybWF0dGVkX2NvbnRlbnRzIiwibm9kZV9zaGFwZSIsInNvdXJjZV9jb2RlX3N0cmluZyIsImZvcm1hdF9leHBlY3RfcGF5bG9hZCIsImZvcm1hdF91bmNhdWdodF9leG5fcGF5bG9hZCIsInJlY29yZF9hbmRfcmV0dXJuX3Jlc3VsdCIsImZhaWx1cmVfcmVmIiwidGVzdF9vdXRwdXRfcmF3IiwicmVzdWx0cyIsImV4cGVjdGF0aW9uIiwicmVzdWx0JDAiLCJvZl9leHBlY3RhdGlvbiIsInJlY29yZF9lbmRfb2ZfcnVuIiwicmVhY2hlZF90aGlzX3J1biIsInJlY29yZF9yZXN1bHQiLCJpbm5lciIsImdsb2JhbF9yZXN1bHRzX3RhYmxlIiwiZmluZF90ZXN0IiwiYWJzb2x1dGVfZmlsZW5hbWUiLCJ0ZXN0X2lkIiwiZXhwZWN0YXRpb25zIiwiaW5pdGlhbGl6ZV9hbmRfcmVnaXN0ZXJfdGVzdHMiLCJ0ZXN0cyIsInBvc3Rwcm9jZXNzIiwidGVzdHNfYXNfaW5fdGFibGUiLCJmaWxlJDAiLCJ0ZXN0cyQwIiwibmV3X3Rlc3QiLCJleGlzdGluZ190ZXN0IiwidGVzdCIsInByb2Nlc3NfZWFjaF9maWxlIiwidGVzdF9ub2RlcyIsImV4cGVjdGF0aW9uX29mX3QiLCJyZWNvcmRfYW5kX3JldHVybl9udW1iZXJfb2ZfbGkiLCJ0b19kaWZmcyIsImNyX2Zvcl9tdWx0aXBsZV9vdXRwdXRzIiwicmVzdWx0c19saXN0Iiwib3V0cHV0Iiwib3V0cHV0c19saXN0IiwidW5yZWFjaGVkX2xpc3QiLCJkaXN0aW5jdF9vdXRwdXRzIiwid2FzX3JlYWNoZWQiLCJyZWFjaGFiaWxpdHlfYmVoYXZpb3IiLCJyZWFjaGFiaWxpdHlfb2ZfY29ycmVjdGVkIiwiY29ycmVjdGlvbl9mb3Jfc2luZ2xlX3Jlc3VsdCIsInJlY2VpdmVkIiwib3V0cHV0cyIsInJhdyIsImJlaGF2aW9yJDAiLCJjb3JyZWN0aW9uJDIiLCJzYWZlX2J5dGVfZ2V0Iiwic3RyaW5nIiwiaSIsIndoaXRlc3BhY2UiLCJsZXRfb2Zmc2V0Iiwid2hpdGVzcGFjZSQwIiwiY29ycmVjdGlvbiQxIiwiY29ycmVjdGlvbiQwIiwibG9jJDAiLCJvbl9pbmNvcnJlY3Rfb3V0cHV0JDAiLCJwb3NpdGlvbiQwIiwibG9jJDEiLCJkaWZmIiwibG9jJDIiLCJtYWluX2NvcnJlY3Rpb24iLCJyZW1vdmVfZW1wdHlfbGluZV9mcm9tX2RlbGV0ZWQiLCJib2R5X2xvYyIsImFkZF9zZW1pY29sb25fYmVmb3JlX3RyYWlsaW5nXyIsImFkZGl0aW9uYWxfY29ycmVjdGlvbnMiLCJjdXJyZW50Iiwic2V0IiwiZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdCIsImN1cnJlbnQkMCIsInVuc2V0IiwiZ2V0IiwiZm4iLCJkaXJfb3JfZXJyb3IiLCJpbml0aWFsX2RpciIsImFic29sdXRlX3BhdGgiLCJ2ZXJpZnlfdGhhdF9maWxlX2lzX2N1cnJlbnRfZXgiLCJsaW5lX251bWJlciIsInJlZ2lzdGVyaW5nX3Rlc3RzX2ZvciIsImNsZWFuX3VwX2Jsb2NrIiwidGVzdF9vdXRwdXRfd3JpdGVyIiwidGVzdF9vdXRwdXRfcmVhZGVyIiwib3V0cHV0X2ZpbGUiLCJmbHVzaCIsInJlYWRfdGVzdF9vdXRwdXRfdW5zYW5pdGl6ZWQiLCJvbGRfb2Zmc2V0IiwibmV3X29mZnNldCIsImxlbiIsImNyX3ByZWZpeCIsImNyX2Zvcl9iYWNrdHJhY2UiLCJvdXRwdXRfbmFtZSIsImNyX2JvZHkiLCJjciIsIm51bV9vdXRwdXRzIiwiaW5kZXgiLCJoZWFkZXIiLCJwYWRfbGVuZ3RoIiwibHBhZCIsInJwYWQiLCJvdXRwdXRzX3dpdGhfaGVhZGVycyIsInNhbml0aXplIiwiY2hlY2tfZm9yX2JhY2t0cmFjZXMiLCJzIiwic3Vic3RyaW5nIiwiZHVtcF9iYWNrdHJhY2UiLCJwb3NzaWJsZV9leG4iLCJleG4kMCIsImV4biIsImJ0IiwiZXhuX3N0cmluZyIsIm5hbWUiLCJidCQwIiwidGVzdF9pc19ydW5uaW5nIiwiYW1fcnVubmluZ19leHBlY3RfdGVzdCIsImN1cnJlbnRfdGVzdCIsInRlc3RfYmxvY2siLCJjdXJyZW50X3Rlc3RfZXhuIiwiaXRlciIsImF0X2V4aXQiLCJiYXNlbmFtZSIsImZpbiIsImFsbF9vdXQiLCJyZWFkX2N1cnJlbnRfdGVzdF9vdXRwdXRfZXhuIiwiaGVyZSIsImRlZmF1bHRfY3JfZm9yX211bHRpcGxlX291dHB1dCIsInJlYWRfdGVzdF9vdXRwdXRfbm9fYmFja3RyYWNlXyIsInJlYWRfdGVzdF9vdXRwdXRfc2FuaXRpemVkX2FuZCIsInJ1bl90ZXN0X2lubmVyIiwicnVuX3Rlc3QiLCJydW5fc3VpdGUiLCJsb2NhdGlvbiIsInRyYWlsaW5nX2xvYyIsImV4cGVjdGVkX2V4biIsInRlc3RfdG9fcnVuIiwiZXhuX3Rlc3RfaWQiLCJkZXNjcmlwdGlvbiIsInRhZ3MiLCJpbmxpbmVfdGVzdF9jb25maWciLCJvdXRlcl9iYXNlbmFtZSIsIm91dGVyX2xpbmVfbnVtYmVyIiwic2V4cF9oZXJlIiwidHJhaWxpbmdfdGVzdCIsImV4bl90ZXN0IiwiZXhwZWN0YXRpb25zJDAiLCJ0cyIsImV4cGVjdGF0aW9ucyQxIiwidGVzdF9leG4iLCJ0cmFpbGluZ19yYXciLCJ0cmFpbGluZ19vdXRwdXQiLCJ0ZXN0X2V4biQwIiwidHJhaWxpbmdfb3V0cHV0JDAiLCJ0ZXN0X3RvX3J1biQwIiwidGVzdF9vdXRwdXQkMCIsInRlc3Rfb3V0cHV0JDEiLCJ0ZXN0X25vZGUiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvcHB4X2V4cGVjdF9ydW50aW1lX18ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvdHlwZXMubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvd3JpdGVfY29ycmVjdGVkX2ZpbGUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvb3V0cHV0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcHB4X2V4cGVjdC9ydW50aW1lL2V4cGVjdGF0aW9uX2ludGYubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvZXhwZWN0YXRpb24ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvdGVzdF9ub2RlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcHB4X2V4cGVjdC9ydW50aW1lL2N1cnJlbnRfZmlsZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3BweF9leHBlY3QvcnVudGltZS90ZXN0X2Jsb2NrLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcHB4X2V4cGVjdC9ydW50aW1lL3BweF9leHBlY3RfcnVudGltZS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztHQTBCOEI7O0lBQUE7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7O0lDR3hCQTtJQW1FRUM7Ozs7O1lBdkZGQyxNQUFNQyxHQUFFQztJQUNWLFVBRFFELFNBQUVDOztlQUFGRCxTQUFFQywwQkFBRkQsU0FBRUM7Ozs7R0FDcUU7O2dCQU12Q0MsR0FBSyxPQUFMQSxLQUFjO2lCQUFsRDtnQkFEb0NBLEdBQUssT0FBTEEsS0FBZ0I7R0FBdEQ7SUFBQSxVQUFFO0lBRkZDLDBCQUNGO0lBWmlCLGtCQU9mSixPQUlBSTtJQXdCaUI7SUFoQlMsNkJBUTFCTjtJQWVlOzs7Ozs7SUFXYk87R0FDSixTQUZFQztJQUdBLElBQUlDLEtBRkZGO0lBQUFBLGFBRUVFO0lBRUosT0FGSUE7R0FFRjtHQVFRLElBQUEsWUFNQSxZQU1DO1lBNEJUQyxPQUNFTCxHQUFFTSxNQUNOLE9BRE1BLE9BQUZOLElBQUFBLFVBQUFBLEVBR3NCOzs7Ozs7OzZEQXpEMUJHO2tDQTBDRVAsV0FXQVM7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0dDeEcwQjs7Ozs7Ozs7Ozs7O0lBQUE7OztZQTBCOUJF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TUFBQTtNQURKLE1BQUE7TUFEQyxNQUFBO0tBRmIsT0FBQTs7Ozs7O2NBRFM1SDtjQUFzQjRIO2NBQVpRO0lBUVI7SUFUYixVQUFBO0lBQUEsT0FBQTtHQVU4QztHQVpoRDtHQWdCTztHQWNQO0lBQUE7Ozs7SUFFaUI7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIFBweF9leHBlY3RfcnVudGltZS5DdXJyZW50X2ZpbGUgKilcbm1vZHVsZSBDdXJyZW50X2ZpbGUgPSBQcHhfZXhwZWN0X3J1bnRpbWVfX0N1cnJlbnRfZmlsZVxuXG4oKiogQGNhbm9uaWNhbCBQcHhfZXhwZWN0X3J1bnRpbWUuRXhwZWN0YXRpb24gKilcbm1vZHVsZSBFeHBlY3RhdGlvbiA9IFBweF9leHBlY3RfcnVudGltZV9fRXhwZWN0YXRpb25cblxuKCoqIEBjYW5vbmljYWwgUHB4X2V4cGVjdF9ydW50aW1lLkV4cGVjdGF0aW9uX2ludGYgKilcbm1vZHVsZSBFeHBlY3RhdGlvbl9pbnRmID0gUHB4X2V4cGVjdF9ydW50aW1lX19FeHBlY3RhdGlvbl9pbnRmXG5cbigqKiBAY2Fub25pY2FsIFBweF9leHBlY3RfcnVudGltZS5PdXRwdXQgKilcbm1vZHVsZSBPdXRwdXQgPSBQcHhfZXhwZWN0X3J1bnRpbWVfX091dHB1dFxuXG4oKiogQGNhbm9uaWNhbCBQcHhfZXhwZWN0X3J1bnRpbWUuVGVzdF9ibG9jayAqKVxubW9kdWxlIFRlc3RfYmxvY2sgPSBQcHhfZXhwZWN0X3J1bnRpbWVfX1Rlc3RfYmxvY2tcblxuKCoqIEBjYW5vbmljYWwgUHB4X2V4cGVjdF9ydW50aW1lLlRlc3Rfbm9kZSAqKVxubW9kdWxlIFRlc3Rfbm9kZSA9IFBweF9leHBlY3RfcnVudGltZV9fVGVzdF9ub2RlXG5cbigqKiBAY2Fub25pY2FsIFBweF9leHBlY3RfcnVudGltZS5UeXBlcyAqKVxubW9kdWxlIFR5cGVzID0gUHB4X2V4cGVjdF9ydW50aW1lX19UeXBlc1xuXG4oKiogQGNhbm9uaWNhbCBQcHhfZXhwZWN0X3J1bnRpbWUuV3JpdGVfY29ycmVjdGVkX2ZpbGUgKilcbm1vZHVsZSBXcml0ZV9jb3JyZWN0ZWRfZmlsZSA9IFBweF9leHBlY3RfcnVudGltZV9fV3JpdGVfY29ycmVjdGVkX2ZpbGVcblxubW9kdWxlIFBweF9leHBlY3RfcnVudGltZV9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJvcGVuISBCYXNlXG5cbm1vZHVsZSBDb21wYWN0X2xvYyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgc3RhcnRfYm9sIDogaW50XG4gICAgOyBzdGFydF9wb3MgOiBpbnRcbiAgICA7IGVuZF9wb3MgOiBpbnRcbiAgICB9XG5cbiAgbGV0IGVxdWFsIGEgYiA9XG4gICAgYS5zdGFydF9ib2wgPSBiLnN0YXJ0X2JvbCAmJiBhLnN0YXJ0X3BvcyA9IGIuc3RhcnRfcG9zICYmIGEuZW5kX3BvcyA9IGIuZW5kX3Bvc1xuICA7O1xuXG4gIGxldCBjb21wYXJlX2NoYXJhY3Rlcl9yYW5nZSA9XG4gICAgQ29tcGFyYWJsZS5sZXhpY29ncmFwaGljXG4gICAgICBbIENvbXBhcmFibGUubGlmdCBjb21wYXJlX2ludCB+ZjooZnVuIHQgLT4gdC5zdGFydF9wb3MpXG4gICAgICA7IENvbXBhcmFibGUubGlmdCBjb21wYXJlX2ludCB+ZjooZnVuIHQgLT4gdC5lbmRfcG9zKVxuICAgICAgXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBpbmRlbnQgOiBpbnRcbiAgICA7IGFsd2F5c19vbl9vd25fbGluZSA6IGJvb2xcbiAgICA7IGV4dGVuc2lvbl9zaWdpbCA6IHN0cmluZ1xuICAgIDsgYXR0cmlidXRlX3NpZ2lsIDogc3RyaW5nXG4gICAgfVxuXG4gIGxldCBkZWZhdWx0ID1cbiAgICB7IGluZGVudCA9IDJcbiAgICA7IGFsd2F5c19vbl9vd25fbGluZSA9IGZhbHNlXG4gICAgOyBleHRlbnNpb25fc2lnaWwgPSBcIiVcIlxuICAgIDsgYXR0cmlidXRlX3NpZ2lsID0gXCJAQFwiXG4gICAgfVxuICA7O1xuXG4gIG1vZHVsZSBGbGV4aWJpbGl0eSA9IHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPVxuICAgICAgfCBGbGV4aWJsZV9tb2R1bG8gb2YgdFxuICAgICAgfCBFeGFjdGx5X2Zvcm1hdHRlZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgVmlydHVhbF9sb2MgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGxvYyA6IENvbXBhY3RfbG9jLnRcbiAgICA7IGJvZHlfbG9jIDogQ29tcGFjdF9sb2MudFxuICAgIH1cbmVuZFxuXG5tb2R1bGUgRXhwZWN0YXRpb25faWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbnRcblxuICBsZXQgbWludCA9XG4gICAgbGV0IGNvdW50ZXIgPSByZWYgMCBpblxuICAgIGZ1biAoKSAtPlxuICAgICAgbGV0IGlkID0gIWNvdW50ZXIgaW5cbiAgICAgIGNvdW50ZXIgOj0gaWQgKyAxO1xuICAgICAgaWRcbiAgOztcbmVuZFxuXG5tb2R1bGUgU3RyaW5nX25vZGVfZm9ybWF0ID0gc3RydWN0XG4gIHR5cGUgbG9uZ2hhbmQgPSBMb25naGFuZFxuICB0eXBlIHNob3J0aGFuZCA9IFNob3J0aGFuZFxuXG4gIG1vZHVsZSBIYW5kID0gc3RydWN0XG4gICAgdHlwZSBfIHQgPVxuICAgICAgfCBMb25naGFuZCA6IGxvbmdoYW5kIHRcbiAgICAgIHwgU2hvcnRoYW5kIDogc2hvcnRoYW5kIHRcbiAgZW5kXG5cbiAgbW9kdWxlIEtpbmQgPSBzdHJ1Y3RcbiAgICB0eXBlIF8gdCA9XG4gICAgICB8IEF0dHJpYnV0ZSA6IGxvbmdoYW5kIHRcbiAgICAgIHwgRXh0ZW5zaW9uIDogXyB0XG4gIGVuZFxuXG4gIG1vZHVsZSBTaGFwZSA9IHN0cnVjdFxuICAgIHR5cGUgJ2hhbmQgdW5wYWNrZWQgPVxuICAgICAgeyBuYW1lIDogc3RyaW5nXG4gICAgICA7IGhhbmQgOiAnaGFuZCBIYW5kLnRcbiAgICAgIDsga2luZCA6ICdoYW5kIEtpbmQudFxuICAgICAgfVxuXG4gICAgdHlwZSB0ID0gVCA6IF8gdW5wYWNrZWQgLT4gdCBbQEB1bmJveGVkXVxuICBlbmRcblxuICBtb2R1bGUgRGVsaW1pdGVyID0gc3RydWN0XG4gICAgdHlwZSBfIHVucGFja2VkID1cbiAgICAgIHwgUXVvdGUgOiBsb25naGFuZCB1bnBhY2tlZFxuICAgICAgfCBUYWcgOiBzdHJpbmcgLT4gXyB1bnBhY2tlZFxuXG4gICAgdHlwZSB0ID0gVCA6IF8gdW5wYWNrZWQgLT4gdCBbQEB1bmJveGVkXVxuXG4gICAgbGV0IGRlZmF1bHQgPSBUIChUYWcgXCJcIilcblxuICAgIGxldCBsb25naGFuZCA9IGZ1bmN0aW9uXG4gICAgICB8IFQgKChRdW90ZSB8IFRhZyBfKSBhcyB1bnBhY2tlZCkgLT4gdW5wYWNrZWRcbiAgICA7O1xuXG4gICAgbGV0IHNob3J0aGFuZCA9IGZ1bmN0aW9uXG4gICAgICB8IFQgKFRhZyBfIGFzIHVucGFja2VkKSAtPiB1bnBhY2tlZFxuICAgICAgfCBUIFF1b3RlIC0+IFRhZyBcIlwiXG4gICAgOztcblxuICAgIGxldCBoYW5kZWQgOiB0eXBlIGEuIHQgLT4gYSBIYW5kLnQgLT4gYSB1bnBhY2tlZCA9XG4gICAgICBmdW4gdCBoYW5kIC0+XG4gICAgICBtYXRjaCBoYW5kIHdpdGhcbiAgICAgIHwgTG9uZ2hhbmQgLT4gbG9uZ2hhbmQgdFxuICAgICAgfCBTaG9ydGhhbmQgLT4gc2hvcnRoYW5kIHRcbiAgICA7O1xuICBlbmRcblxuICB0eXBlICdhIHVucGFja2VkID1cbiAgICB7IHNoYXBlIDogJ2EgU2hhcGUudW5wYWNrZWRcbiAgICA7IGRlbGltaXRlciA6ICdhIERlbGltaXRlci51bnBhY2tlZFxuICAgIH1cblxuICB0eXBlIHQgPSBUIDogXyB1bnBhY2tlZCAtPiB0IFtAQHVuYm94ZWRdXG5lbmRcbiIsIm9wZW4hIEJhc2Vcbm9wZW4gVHlwZXNcblxubW9kdWxlIFBhdGNoX3dpdGhfZmlsZV9jb250ZW50cyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSBvcmlnaW5hbF9maWxlX2NvbnRlbnRzOnN0cmluZyAtPiAnYSAtPiAoQ29tcGFjdF9sb2MudCAqIHN0cmluZykgbGlzdFxuZW5kXG5cbmxldCByZXdyaXRlX2NvcnJlY3Rpb25zIH5vcmlnaW5hbF9maWxlX2NvbnRlbnRzIH5jb3JyZWN0aW9ucyA9XG4gICgqIEVuc3VyZSB0aGF0IHdlIGVuY291bnRlciB0aGUgY29ycmVjdGlvbnMgaW4gb3JkZXIgYXMgd2UgYnVpbGQgdXAgdGhlIGZpbGUuICopXG4gIGxldCBjb3JyZWN0aW9ucyA9XG4gICAgTGlzdC5zb3J0XG4gICAgICB+Y29tcGFyZTooQ29tcGFyYWJsZS5saWZ0IENvbXBhY3RfbG9jLmNvbXBhcmVfY2hhcmFjdGVyX3JhbmdlIH5mOmZzdClcbiAgICAgIGNvcnJlY3Rpb25zXG4gIGluXG4gIGxldCBsX3Bvcywgc3RycyA9XG4gICAgTGlzdC5mb2xkX21hcFxuICAgICAgY29ycmVjdGlvbnNcbiAgICAgIH5pbml0OjBcbiAgICAgIH5mOihmdW4gbF9wb3MgKHsgc3RhcnRfcG9zOyBlbmRfcG9zOyBzdGFydF9ib2wgPSBfIH0sIGNvcnJlY3Rpb24pIC0+XG4gICAgICBsZXQgY29kZV9jaHVuayA9XG4gICAgICAgIFN0cmluZy5zdWIgb3JpZ2luYWxfZmlsZV9jb250ZW50cyB+cG9zOmxfcG9zIH5sZW46KHN0YXJ0X3BvcyAtIGxfcG9zKVxuICAgICAgaW5cbiAgICAgIGVuZF9wb3MsIFsgY29kZV9jaHVuazsgY29ycmVjdGlvbiBdKVxuICBpblxuICBsZXQgcmVzdWx0ID0gTGlzdC5jb25jYXQgc3RycyB8PiBTdHJpbmcuY29uY2F0IGluXG4gIGxldCByZXN0ID0gU3RyaW5nLnN1Ym8gb3JpZ2luYWxfZmlsZV9jb250ZW50cyB+cG9zOmxfcG9zIGluXG4gIHJlc3VsdCBeIHJlc3Rcbjs7XG5cbmxldCBmIH51c2VfY29sb3IgfmluX3BsYWNlIH5kaWZmX2NvbW1hbmQgfmRpZmZfcGF0aF9wcmVmaXggfmZpbGVuYW1lIH53aXRoXyBjb3JyZWN0aW9uc1xuICA6IFBweF9pbmxpbmVfdGVzdF9saWIuVGVzdF9yZXN1bHQudFxuICA9XG4gIGxldCBkb3RfY29ycmVjdGVkID0gZmlsZW5hbWUgXiBcIi5jb3JyZWN0ZWRcIiBpblxuICBsZXQgb3JpZ2luYWxfZmlsZV9jb250ZW50cyA9XG4gICAgbGV0IGluX2NoYW5uZWwgPSBTdGRsaWIub3Blbl9pbiBmaWxlbmFtZSBpblxuICAgIGxldCBjb250ZW50cyA9XG4gICAgICBTdGRsaWIucmVhbGx5X2lucHV0X3N0cmluZyBpbl9jaGFubmVsIChTdGRsaWIuaW5fY2hhbm5lbF9sZW5ndGggaW5fY2hhbm5lbClcbiAgICBpblxuICAgIFN0ZGxpYi5jbG9zZV9pbiBpbl9jaGFubmVsO1xuICAgIGNvbnRlbnRzXG4gIGluXG4gIGxldCByZW1vdmUgZmlsZSA9IGlmIFN0ZGxpYi5TeXMuZmlsZV9leGlzdHMgZmlsZSB0aGVuIFN0ZGxpYi5TeXMucmVtb3ZlIGZpbGUgaW5cbiAgbGV0IGNvcnJlY3Rpb25zID0gd2l0aF8gfm9yaWdpbmFsX2ZpbGVfY29udGVudHMgY29ycmVjdGlvbnMgaW5cbiAgbGV0IG5leHRfY29udGVudHMgPSByZXdyaXRlX2NvcnJlY3Rpb25zIH5vcmlnaW5hbF9maWxlX2NvbnRlbnRzIH5jb3JyZWN0aW9ucyBpblxuICBtYXRjaCBpbl9wbGFjZSB3aXRoXG4gIHwgdHJ1ZSAtPlxuICAgIGlmIG5vdCAoU3RyaW5nLmVxdWFsIG9yaWdpbmFsX2ZpbGVfY29udGVudHMgbmV4dF9jb250ZW50cylcbiAgICB0aGVuIFN0ZGlvLk91dF9jaGFubmVsLndyaXRlX2FsbCBmaWxlbmFtZSB+ZGF0YTpuZXh0X2NvbnRlbnRzO1xuICAgIHJlbW92ZSBkb3RfY29ycmVjdGVkO1xuICAgIFN1Y2Nlc3NcbiAgfCBmYWxzZSAtPlxuICAgIChtYXRjaCBkaWZmX2NvbW1hbmQgd2l0aFxuICAgICB8IFNvbWUgXCItXCIgKCogSnVzdCB3cml0ZSB0aGUgLmNvcnJlY3RlZCBmaWxlIC0gZG8gbm90IG91dHB1dCBhIGRpZmYuICopIC0+XG4gICAgICAgU3RkaW8uT3V0X2NoYW5uZWwud3JpdGVfYWxsIGRvdF9jb3JyZWN0ZWQgfmRhdGE6bmV4dF9jb250ZW50cztcbiAgICAgICBTdWNjZXNzXG4gICAgIHwgXyAtPlxuICAgICAgICgqIEJ5IGludm9raW5nIFtNYWtlX2NvcnJlY3RlZF9maWxlLmZdIHdpdGggYSBmcmVzaCB0ZW1wb3JhcnkgZmlsZSwgd2UgYXZvaWQgdGhlXG4gICAgICAgICAgZm9sbG93aW5nIHBvc3NpYmxlIHJhY2UgYmV0d2VlbiBpbmxpbmVfdGVzdF9ydW5uZXJzIEEgYW5kIEI6XG4gICAgICAgICAgMS4gQSBydW5zIHRlc3QgVDEgYW5kIGdlbmVyYXRlcyBuZXh0IGNvbnRlbnRzIEMxLlxuICAgICAgICAgIDIuIEIgcnVucyB0ZXN0IFQyIGFuZCBnZW5lcmF0ZXMgbmV4dCBjb250ZW50cyBDMi5cbiAgICAgICAgICAzLiBBIHdyaXRlcyBDMSB0byB0aGUgLmNvcnJlY3RlZCBmaWxlLlxuICAgICAgICAgIDQuIEIgd3JpdGVzIEMyIHRvIHRoZSAuY29ycmVjdGVkIGZpbGUuXG4gICAgICAgICAgNS4gQSBkaWZmcyB0aGUgLmNvcnJlY3RlZCBmaWxlIGFnYWluc3QgdGhlIG9yaWdpbmFsIGZpbGUgYW5kIHJlcG9ydHMgdGhlXG4gICAgICAgICAgcmVzdWx0LiBJdCB0aGlua3MgaXQgaXMgcmVwb3J0aW5nIHRoZSBkaWZmIHByb2R1Y2VkIGJ5IFQxLCBidXQgaXMgaW4gZmFjdFxuICAgICAgICAgIHJlcG9ydGluZyB0aGUgZGlmZiBwcm9kdWNlZCBieSBUMi4gVGhlIGtleSBhc3BlY3Qgb2YgdXNpbmcgdGVtcG9yYXJ5IGZpbGVzIGlzXG4gICAgICAgICAgdGhhdCBldmVuIGlmIGluIHRoZSBhYm92ZSBzY2VuYXJpbyB0aGUgZmluYWwgY29udGVudHMgb2YgdGhlIC5jb3JyZWN0ZWQgZmlsZVxuICAgICAgICAgIGFyZSBDMiwgdGhlIGRpZmYgcmVwb3J0ZWQgYnkgQSBjb21lcyBmcm9tIGl0cyB0bXAgZmlsZSBhbmQgd2lsbCBzdGlsbCBiZSB0aGVcbiAgICAgICAgICBkaWZmIHByb2R1Y2VkIGJ5IFQxLiAqKVxuICAgICAgIGxldCB0bXBfY29ycmVjdGVkID1cbiAgICAgICAgIFN0ZGxpYi5GaWxlbmFtZS50ZW1wX2ZpbGVcbiAgICAgICAgICAgKFN0ZGxpYi5GaWxlbmFtZS5iYXNlbmFtZSBmaWxlbmFtZSlcbiAgICAgICAgICAgXCIuY29ycmVjdGVkLnRtcFwiXG4gICAgICAgICAgIH50ZW1wX2RpcjooU3RkbGliLkZpbGVuYW1lLmRpcm5hbWUgZmlsZW5hbWUpXG4gICAgICAgaW5cbiAgICAgICAobWF0Y2hcbiAgICAgICAgICBNYWtlX2NvcnJlY3RlZF9maWxlLmZcbiAgICAgICAgICAgIH51c2VfY29sb3JcbiAgICAgICAgICAgID9kaWZmX2NvbW1hbmRcbiAgICAgICAgICAgID9kaWZmX3BhdGhfcHJlZml4XG4gICAgICAgICAgICB+Y29ycmVjdGVkX3BhdGg6dG1wX2NvcnJlY3RlZFxuICAgICAgICAgICAgfm5leHRfY29udGVudHNcbiAgICAgICAgICAgIH5wYXRoOmZpbGVuYW1lXG4gICAgICAgICAgICAoKVxuICAgICAgICB3aXRoXG4gICAgICAgIHwgT2sgXyAtPlxuICAgICAgICAgICgqIEV2ZW4gdGhvdWdoIHRoaXMgZXhlY3V0aW9uIG9mIHRoZSBleHBlY3QgdGVzdCByYW4gd2l0aG91dCBtYWtpbmdcbiAgICAgICAgICAgICBjb3JyZWN0aW9ucywgd2Ugc2hvdWxkIGRlbGV0ZSBhbnkgb2xkIFsuY29ycmVjdGVkXSBmaWxlcyB0aGF0IGFyZSBsZWZ0IG92ZXJcbiAgICAgICAgICAgICBmcm9tIHByZXZpb3VzIGJ1aWxkcy4gSW4gcGFydGljdWxhciwgaHlkcmEgcmVsaWVzIG9uIHRoaXMgYmVoYXZpb3IgZm9yXG4gICAgICAgICAgICAgZmxha3kgdGVzdHM7IGlmIHRoZSB0ZXN0IGZhaWxzIHRoZSBmaXJzdCB0aW1lIGFuZCBwYXNzZXMgdGhlIHNlY29uZCwgdGhlXG4gICAgICAgICAgICAgc2Vjb25kIHJ1biBzaG91bGQgbWFrZSBzdXJlIHRoZSBbLmNvcnJlY3RlZF0gZmlsZSBpcyBub3QgbGluZ2VyaW5nIGluIHRoZVxuICAgICAgICAgICAgIHNhbmRib3guICopXG4gICAgICAgICAgcmVtb3ZlIGRvdF9jb3JyZWN0ZWQ7XG4gICAgICAgICAgcmVtb3ZlIHRtcF9jb3JyZWN0ZWQ7XG4gICAgICAgICAgU3VjY2Vzc1xuICAgICAgICB8IEVycm9yIF8gLT5cbiAgICAgICAgICBTdGRsaWIuU3lzLnJlbmFtZSB0bXBfY29ycmVjdGVkIGRvdF9jb3JyZWN0ZWQ7XG4gICAgICAgICAgRmFpbHVyZSkpXG47O1xuIiwib3BlbiEgQmFzZVxub3BlbiBUeXBlc1xuXG5tb2R1bGUgVHlwZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgRXhhY3RcbiAgICB8IFByZXR0eVxuZW5kXG5cbm1vZHVsZSBSZWNvbmNpbGVkID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZ1xuXG4gIGxldCBjb21wYXJlID0gY29tcGFyZV9zdHJpbmdcbmVuZFxuXG5tb2R1bGUgRm9ybWF0dGVkID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZ1xuZW5kXG5cbm1vZHVsZSBGb3JtYXR0ZXIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nIC0+IEZvcm1hdHRlZC50XG5cbiAgbGV0IGNyZWF0ZSBmb3JtYXQgPSBmb3JtYXRcbiAgbGV0IGFwcGx5IGZvcm1hdCBzdHIgPSBmb3JtYXQgc3RyXG5lbmRcblxubW9kdWxlIFRlc3RfcmVzdWx0ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBQYXNzXG4gICAgfCBGYWlsIG9mIFJlY29uY2lsZWQudFxuXG4gIGxldCBjb21wYXJlIGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBQYXNzLCBQYXNzIC0+IDBcbiAgICB8IFBhc3MsIF8gLT4gLTFcbiAgICB8IF8sIFBhc3MgLT4gMVxuICAgIHwgRmFpbCBhLCBGYWlsIGIgLT4gUmVjb25jaWxlZC5jb21wYXJlIGEgYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBQYXlsb2FkID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBjb250ZW50cyA6IHN0cmluZ1xuICAgIDsgdGFnIDogU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci50XG4gICAgfVxuXG4gIGxldCBkZWZhdWx0IGNvbnRlbnRzID0geyBjb250ZW50czsgdGFnID0gU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci5kZWZhdWx0IH1cblxuICBsZXQgdG9fc291cmNlX2NvZGVfc3RyaW5nIHsgY29udGVudHM7IHRhZyB9ID1cbiAgICBsZXQgZXNjYXBlX2xpbmVzIHRlc3Rfb3V0cHV0ID1cbiAgICAgIHRlc3Rfb3V0cHV0XG4gICAgICB8PiBTdHJpbmcuc3BsaXQgfm9uOidcXG4nXG4gICAgICB8PiBMaXN0Lm1hcCB+ZjpTdHJpbmcuZXNjYXBlZFxuICAgICAgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuXCJcbiAgICBpblxuICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgfCBUIChUYWcgdGFnKSAtPiBQcmludGYuc3ByaW50ZiBcInslc3wlc3wlc31cIiB0YWcgY29udGVudHMgdGFnXG4gICAgfCBUIFF1b3RlIC0+IFByaW50Zi5zcHJpbnRmIHt8XCIlc1wifH0gKGVzY2FwZV9saW5lcyBjb250ZW50cylcbiAgOztcbmVuZFxuXG5sZXQgcmVjb25jaWxlIH5leHBlY3RlZF9vdXRwdXQgfnRlc3Rfb3V0cHV0IDogVGVzdF9yZXN1bHQudCA9XG4gIGlmIFN0cmluZy5lcXVhbCBleHBlY3RlZF9vdXRwdXQgdGVzdF9vdXRwdXQgdGhlbiBQYXNzIGVsc2UgRmFpbCB0ZXN0X291dHB1dFxuOztcblxubGV0IGZhaWwgZXJyb3Jfb3V0cHV0IDogVGVzdF9yZXN1bHQudCA9IEZhaWwgZXJyb3Jfb3V0cHV0XG5cbmxldCBmaXhfZGVsaW1pdGVyX2NvbmZsaWN0c1xuICAodHlwZSBoYW5kZWRuZXNzKVxuICB+Y29udGVudHNcbiAgfihkZWxpbWl0ZXIgOiBoYW5kZWRuZXNzIFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIudW5wYWNrZWQpXG4gIDogaGFuZGVkbmVzcyBTdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyLnVucGFja2VkXG4gID1cbiAgbGV0IHJlYyBmaXhfdGFnX2NvbmZsaWN0cyB+Y29udGVudHMgfnRhZyA9XG4gICAgbGV0IHRhZ19jb25mbGljdHNfd2l0aCBmc3RyID1cbiAgICAgIFN0cmluZy5pc19zdWJzdHJpbmcgfnN1YnN0cmluZzooUHJpbnRmLnNwcmludGYgZnN0ciB0YWcpIGNvbnRlbnRzXG4gICAgaW5cbiAgICBpZiB0YWdfY29uZmxpY3RzX3dpdGggXCJ7JXN8XCIgfHwgdGFnX2NvbmZsaWN0c193aXRoIFwifCVzfVwiXG4gICAgdGhlbiBmaXhfdGFnX2NvbmZsaWN0cyB+Y29udGVudHMgfnRhZzoodGFnIF4gXCJ4eHhcIilcbiAgICBlbHNlIHRhZ1xuICBpblxuICBtYXRjaCBkZWxpbWl0ZXIgd2l0aFxuICB8IFF1b3RlIC0+IFF1b3RlXG4gIHwgVGFnIHRhZyAtPiBUYWcgKGZpeF90YWdfY29uZmxpY3RzIH5jb250ZW50cyB+dGFnKVxuOztcblxubGV0IHRvX2Zvcm1hdHRlZF9wYXlsb2FkIH50YWc6KFQgZGVsaW1pdGVyIDogU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci50KSBjb250ZW50c1xuICA6IFBheWxvYWQudFxuICA9XG4gIHsgY29udGVudHM7IHRhZyA9IFQgKGZpeF9kZWxpbWl0ZXJfY29uZmxpY3RzIH5jb250ZW50cyB+ZGVsaW1pdGVyKSB9XG47O1xuXG5sZXQgdG9fc291cmNlX2NvZGVfc3RyaW5nXG4gIH4oZXhwZWN0X25vZGVfZm9ybWF0dGluZyA6IEV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcudClcbiAgfm5vZGVfc2hhcGU6KFQgc2hhcGUgOiBTdHJpbmdfbm9kZV9mb3JtYXQuU2hhcGUudClcbiAgfih0YWcgOiBTdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyLnQpXG4gIGNvbnRlbnRzXG4gID1cbiAgbGV0IGRlbGltaXRlciA9XG4gICAgZml4X2RlbGltaXRlcl9jb25mbGljdHNcbiAgICAgIH5jb250ZW50c1xuICAgICAgfmRlbGltaXRlcjooU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci5oYW5kZWQgdGFnIHNoYXBlLmhhbmQpXG4gIGluXG4gIGxldCBwYXlsb2FkIDogUGF5bG9hZC50ID0geyBjb250ZW50czsgdGFnID0gVCBkZWxpbWl0ZXIgfSBpblxuICBtYXRjaCBzaGFwZS5oYW5kIHdpdGhcbiAgfCBMb25naGFuZCAtPlxuICAgIGxldCBwcmVmaXggPVxuICAgICAgbWF0Y2ggc2hhcGUua2luZCB3aXRoXG4gICAgICB8IEV4dGVuc2lvbiAtPiBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmV4dGVuc2lvbl9zaWdpbFxuICAgICAgfCBBdHRyaWJ1dGUgLT4gZXhwZWN0X25vZGVfZm9ybWF0dGluZy5hdHRyaWJ1dGVfc2lnaWxcbiAgICBpblxuICAgIFByaW50Zi5zcHJpbnRmIFwiWyVzJXMgJXNdXCIgcHJlZml4IHNoYXBlLm5hbWUgKFBheWxvYWQudG9fc291cmNlX2NvZGVfc3RyaW5nIHBheWxvYWQpXG4gIHwgU2hvcnRoYW5kIC0+XG4gICAgbGV0IHByZWZpeCA9XG4gICAgICBtYXRjaCBzaGFwZS5raW5kIHdpdGhcbiAgICAgIHwgRXh0ZW5zaW9uIC0+IGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuZXh0ZW5zaW9uX3NpZ2lsXG4gICAgaW5cbiAgICAobWF0Y2ggZGVsaW1pdGVyIHdpdGhcbiAgICAgfCBUYWcgXCJcIiAtPiBQcmludGYuc3ByaW50ZiBcInslcyVzfCVzfH1cIiBwcmVmaXggc2hhcGUubmFtZSBjb250ZW50c1xuICAgICB8IFRhZyB0YWcgLT4gUHJpbnRmLnNwcmludGYgXCJ7JXMlcyAlc3wlc3wlc31cIiBwcmVmaXggc2hhcGUubmFtZSB0YWcgY29udGVudHMgdGFnKVxuOztcbiIsIm9wZW4hIEJhc2Vcbm9wZW4gVHlwZXNcblxubW9kdWxlIERlZmluaXRpb25zID0gc3RydWN0XG4gIG1vZHVsZSBJbnNlcnRfbG9jID0gc3RydWN0XG4gICAgKCoqIFdoZXRoZXIgdGhpcyBleHBlY3RhdGlvbiBpcyB0aWVkIHRvIGFuIEFTVCBub2RlIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgc291cmNlLCBhbmRcbiAgICAgICAgdGhlIGxvY2F0aW9uIGluZm9ybWF0aW9uIG5lZWRlZCB0byBkZXRlcm1pbmUgd2hlcmUgdG8gaW5zZXJ0IGNvcnJlY3Rpb25zIGZvciB0aGlzXG4gICAgICAgIGV4cGVjdGF0aW9uICopXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgT3ZlcndyaXRlIG9mXG4gICAgICAgICAgeyB3aG9sZV9ub2RlIDogQ29tcGFjdF9sb2MudFxuICAgICAgICAgIDsgcGF5bG9hZCA6IENvbXBhY3RfbG9jLnQgb3B0aW9uXG4gICAgICAgICAgfVxuICAgICAgICAgICgqKiBBbiBleHBlY3RhdGlvbiBwYXJzZWQgZnJvbSB0aGUgdGVzdCBmaWxlIGFuZCB3aGljaCBzaG91bGQgYmUgb3ZlcndyaXR0ZW4gYnlcbiAgICAgICAgICBjb3JyZWN0aW9ucy4gQ29ycmVjdGlvbnMgdG8ganVzdCB0aGUgcGF5bG9hZCBzaG91bGQgb3ZlcndyaXRlIGp1c3QgdGhlIFtwYXlsb2FkXVxuICAgICAgICAgIGxvY2F0aW9uLCBpZiBwcmVzZW50LiBJZiBubyBbcGF5bG9hZF0gbG9jYXRpb24gaXMgcHJlc2VudCwgb3IgZm9yIGNvcnJlY3Rpb25zXG4gICAgICAgICAgdGhhdCBjaGFuZ2UgdGhlIGVudGlyZSBub2RlIChlLmcuIGEgY2hhbmdlIGZyb20gW1slZXhwZWN0IF9dXSB0b1xuICAgICAgICAgIFtbJWV4cGVjdC51bnJlYWNoYWJsZV1dKSwgb3ZlcndyaXRlIHRoZSBbd2hvbGVfbm9kZV0gbG9jLiAqKVxuICAgICAgfCBJbnNlcnQgb2YgVmlydHVhbF9sb2MudFxuICAgICAgICAgICgqKiBBbiBleHBlY3RhdGlvbiBub3QgcGFyc2VkIGZyb20gdGhlIGZpbGUgdGhhdCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50b1xuICAgICAgICAgIFtWaXJ0dWFsX2xvYy5sb2NdIGFuZCBpcyBhc3NvY2lhdGVkIHdpdGggYSB0ZXN0IHdob3NlIGJvZHkgaXMgYXRcbiAgICAgICAgICBbVmlydHVhbF9sb2MuYm9keV9sb2NdICopXG4gIGVuZFxuXG4gIG1vZHVsZSBCZWhhdmlvcl90eXBlID0gc3RydWN0XG4gICAgKCoqIFRoZSB0eXBlIG9mIGV4cGVjdCBub2RlICopXG4gICAgdHlwZSB0ID1cbiAgICAgIFsgYEV4cGVjdFxuICAgICAgfCBgVW5yZWFjaGFibGVcbiAgICAgIF1cbiAgZW5kXG5cbiAgbW9kdWxlIEV4cGVjdF9yZWFjaGFiaWxpdHkgPSBzdHJ1Y3RcbiAgICAoKiogV2hldGhlciBhbiBleHBlY3Qgbm9kZSBleHByZXNzZXMgYW4gYXNzZXJ0aW9uIHRoYXQgY29udHJvbCBmbG93IHBhc3NlcyB0aHJvdWdoIGl0XG4gICAgICAgIGV2ZXJ5IHRpbWUgYSB0ZXN0IGlzIHJ1biAqKVxuICAgIHR5cGUgdCA9XG4gICAgICB8IENhbl9yZWFjaFxuICAgICAgICAgICgqKiBUZXN0IHBhc3NlcyBldmVuIGlmIG5vZGUgaXMgb25seSByZWFjaGVkIG9uICpzb21lKiBleGVjdXRpb25zIG9mIGEgdGVzdCAqKVxuICAgICAgfCBNdXN0X3JlYWNoICgqKiBUZXN0IGZhaWxzIHVubGVzcyBub2RlIGlzIHJlYWNoZWQgYnkgKmFsbCogZXhlY3V0aW9ucyBvZiBhIHRlc3QgKilcbiAgZW5kXG5cbiAgbW9kdWxlIE9uX3VucmVhY2hhYmxlID0gc3RydWN0XG4gICAgKCoqIFdoYXQgc2hvdWxkIGJlIGRvbmUgaWYgdGhpcyBleHBlY3RhdGlvbiBpcyBuZXZlciByZWFjaGVkIGluIHRoZSB0ZXN0IGV4ZWN1dGlvbiAqKVxuICAgIHR5cGUgdCA9XG4gICAgICB8IFNpbGVudCAoKiogRG8gbm90aGluZyAqKVxuICAgICAgfCBEZWxldGUgKCoqIERlbGV0ZSB0aGlzIGV4cGVjdGF0aW9uIGZyb20gdGhlIHNvdXJjZSBmaWxlICopXG4gICAgICB8IFJlcGxhY2Vfd2l0aF91bnJlYWNoYWJsZVxuICAgICAgICAgICgqKiBSZXBsYWNlIHRoaXMgZXhwZWN0YXRpb24gd2l0aCBhIFtbJWV4cGVjdC51bnJlYWNoYWJsZV1dIG5vZGUgKilcbiAgZW5kXG5cbiAgbW9kdWxlIEJlaGF2aW9yID0gc3RydWN0XG4gICAgKCoqIEEgWydiZWhhdmlvcl90eXBlIHRdIGRlc2NyaWJlcyBob3cgdG8gaGFuZGxlIGEgdGVzdCBub2RlIHdoZW4gcnVubmluZyB0ZXN0c1xuICAgICAgICBhbmQgd3JpdGluZyBjb3JyZWN0aW9ucy5cblxuICAgICAgICBbJ2JlaGF2aW9yX3R5cGVdIGRldGVybWluZXMgdGhlIHR5cGVzIG9mIHJld3JpdGVzIHRoYXQgYXJlIHBvc3NpYmxlIGF0IHRoaXMgbm9kZS5cbiAgICAgICAgSXQgaXMgZWl0aGVyIFtgRXhwZWN0XSAoaW5kaWNhdGluZyB0aGF0IGJvdGggY29ycmVjdGlvbnMgZm9yIHVuZXhwZWN0ZWQgb3V0cHV0IGFuZFxuICAgICAgICByZXdyaXRlcyBmb3IgdW5yZWFjaGFiaWxpdHkgYXJlIHBvc3NpYmxlKSBvciBbYFVucmVhY2hhYmxlXSAoaW5kaWNhdGluZyB0aGF0IG9ubHlcbiAgICAgICAgY29ycmVjdGlvbnMgZm9yIHVuZXhwZWN0ZWQgb3V0cHV0IGFyZSBwb3NzaWJsZSkuXG4gICAgKilcbiAgICB0eXBlIF8gdCA9XG4gICAgICB8IEV4cGVjdCA6XG4gICAgICAgICAgeyBwYXlsb2FkIDogT3V0cHV0LlBheWxvYWQudFxuICAgICAgICAgIDsgb25fdW5yZWFjaGFibGUgOiBPbl91bnJlYWNoYWJsZS50XG4gICAgICAgICAgOyByZWFjaGFiaWxpdHkgOiBFeHBlY3RfcmVhY2hhYmlsaXR5LnRcbiAgICAgICAgICB9XG4gICAgICAgICAgLT4gWyBgRXhwZWN0IF0gdFxuICAgICAgfCBVbnJlYWNoYWJsZSA6XG4gICAgICAgICAgeyByZWFjaGFiaWxpdHlfb2ZfY29ycmVjdGVkIDogRXhwZWN0X3JlYWNoYWJpbGl0eS50XG4gICAgICAgICAgICAgICgqKiBUaGUgcmVhY2hhYmlsaXR5IG9mIHRoZSBub2RlIGluc2VydGVkIGlmIHRoaXMgdW5yZWFjaGFibGUgbm9kZSBpc1xuICAgICAgICAgICAgICB1bmV4cGVjdGVkbHkgcmVhY2hlZCAqKVxuICAgICAgICAgIH1cbiAgICAgICAgICAtPiBbIGBVbnJlYWNoYWJsZSBdIHRcbiAgZW5kXG5cbiAgKCoqIEEgWygnYmVoYXZpb3JfdHlwZSkgdF0gY2FycmllcyBpbmZvcm1hdGlvbiBhYm91dCBob3cgdG8gcnVuIHRlc3RzIGZvciBhXG4gICAgICBzcGVjaWZpYyBleHBlY3Qgbm9kZSBhbmQgcmV3cml0ZSBpdCBpbiB0aGUgc291cmNlIGZpbGUgaWYgdGhlcmUgYXJlIGNvcnJlY3Rpb25zLiBUaGVcbiAgICAgIFsnYmVoYXZpb3JfdHlwZV0gdHlwZSB2YXJpYWJsZSBoYXMgdGhlIHNhbWUgbWVhbmluZ3MgYXMgaW5cbiAgICAgIFsnYmVoYXZpb3JfdHlwZSBCZWhhdmlvci50XS5cbiAgKilcbiAgdHlwZSAnYmVoYXZpb3JfdHlwZSB0ID1cbiAgICB7IHBvc2l0aW9uIDogSW5zZXJ0X2xvYy50XG4gICAgOyBiZWhhdmlvciA6ICdiZWhhdmlvcl90eXBlIEJlaGF2aW9yLnRcbiAgICA7IHBheWxvYWRfdHlwZSA6IE91dHB1dC5UeXBlLnRcbiAgICA7IG9uX2luY29ycmVjdF9vdXRwdXQgOiBTdHJpbmdfbm9kZV9mb3JtYXQuU2hhcGUudFxuICAgICAgICAoKiogVGhlIG5hbWUgYW5kIHN5bnRheCBzdHlsZSBvZiB0aGUgZXh0ZW5zaW9uIHBvaW50IG9yIGF0dHJpYnV0ZSB1c2VkIHRvIHdyaXRlXG4gICAgICAgIGNvcnJlY3Rpb25zIHdoZW4gcmVjZWl2aW5nIFwiaW5jb3JyZWN0XCIgb3V0cHV0IGZvciB0aGlzIHRlc3Qgbm9kZS4gRm9yIGVhY2ggW3RdLFxuICAgICAgICB0aGVyZSBpcyBvbmx5IG9uZSBzdWNoIG5vZGUuIEZvciBleGFtcGxlLCBpZiBhbiBbeyVleHBlY3RfZXhhY3R8fH1dIG5vZGUgaXNcbiAgICAgICAgcmVhY2hlZCB3aXRoIGluY29ycmVjdCBvdXRwdXQsIGl0IGlzIGFsd2F5cyBjb3JyZWN0ZWQgdG8gYSBkaWZmZXJlbnRcbiAgICAgICAgW3slZXhwZWN0X2V4YWN0fHx9XSBub2RlLCBhbmQgYW4gW1slZXhwZWN0LnVucmVhY2hhYmxlXV0gdGhhdCBpcyByZWFjaGVkIGlzXG4gICAgICAgIGFsd2F5cyBjb3JyZWN0ZWQgdG8gYW4gW1slZXhwZWN0XV0gbm9kZS5cblxuICAgICAgICBOb3RlIHRoYXQgZm9yIGEgbm9kZSB0aGF0IHNob3VsZCBiZSByZWFjaGFibGUsIHRoZSBjb3JyZWN0aW9uIHdoZW4gaXQgaXMgZm91bmQgdG9cbiAgICAgICAgYmUgdW5yZWFjaGFibGUgaXMgaW5zdGVhZCBnb3Zlcm5lZCBieSBbb25fdW5yZWFjaGFibGVdIGluIHRoZSBbRXhwZWN0XSBjb25zdHJ1Y3RvclxuICAgICAgICBvZiBbYmVoYXZpb3JdLlxuICAgICopXG4gICAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlIDogc3RyaW5nXG4gICAgfVxuZW5kXG5cbm1vZHVsZSB0eXBlIEV4cGVjdGF0aW9uID0gc2lnXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBEZWZpbml0aW9uc1xuICBlbmRcblxuICBtb2R1bGUgSW5zZXJ0X2xvYyA6IHNpZ1xuICAgIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgICBpbmNsdWRlIEluc2VydF9sb2NcbiAgICBlbmRcblxuICAgIHZhbCBsb2MgOiBJbnNlcnRfbG9jLnQgLT4gQ29tcGFjdF9sb2MudFxuICBlbmRcblxuICB2YWwgd2l0aF9iZWhhdmlvciA6ICdvbGRfYmVoYXZpb3IgdCAtPiAnbmV3X2JlaGF2aW9yIEJlaGF2aW9yLnQgLT4gJ25ld19iZWhhdmlvciB0XG5cbiAgKCoqIFtmb3JtYXR0ZXIgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgdF0gcmV0dXJucyB0aGUgW091dHB1dC5Gb3JtYXR0ZXIudF0gdGhhdCBmb3JtYXRzXG4gICAgICB0ZXN0IG91dHB1dCBhY2NvcmRpbmcgdG8gdGhlIHR5cGUgKFtleGFjdF0gb3IgW3ByZXR0eV0pIG9mIFt0XSwgdXNpbmcgaW5mb3JtYXRpb25cbiAgICAgIGFib3V0IHRoZSBsb2NhdGlvbiBhbmQgcGF5bG9hZCBvZiBbdF0gZm9yIGZvcm1hdHRpbmcuICopXG4gIHZhbCBmb3JtYXR0ZXJcbiAgICA6ICBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nOkV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcudFxuICAgIC0+IF8gdFxuICAgIC0+IE91dHB1dC5Gb3JtYXR0ZXIudFxuXG4gICgqKiBbWyVleHBlY3QgX11dICopXG4gIHZhbCBleHBlY3RcbiAgICA6ICBmb3JtYXR0aW5nX2ZsZXhpYmlsaXR5OkV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuRmxleGliaWxpdHkudFxuICAgIC0+IG5vZGVfbG9jOkNvbXBhY3RfbG9jLnRcbiAgICAtPiBsb2NhdGVkX3BheWxvYWQ6KE91dHB1dC5QYXlsb2FkLnQgKiBDb21wYWN0X2xvYy50KSBvcHRpb25cbiAgICAtPiBbIGBFeHBlY3QgXSB0XG5cbiAgKCoqIFtbJWV4cGVjdF9leGFjdCBfXV0gKilcbiAgdmFsIGV4cGVjdF9leGFjdFxuICAgIDogIGZvcm1hdHRpbmdfZmxleGliaWxpdHk6RXhwZWN0X25vZGVfZm9ybWF0dGluZy5GbGV4aWJpbGl0eS50XG4gICAgLT4gbm9kZV9sb2M6Q29tcGFjdF9sb2MudFxuICAgIC0+IGxvY2F0ZWRfcGF5bG9hZDooT3V0cHV0LlBheWxvYWQudCAqIENvbXBhY3RfbG9jLnQpIG9wdGlvblxuICAgIC0+IFsgYEV4cGVjdCBdIHRcblxuICAoKiogW1slZXhwZWN0LnVucmVhY2hhYmxlXV0gKilcbiAgdmFsIGV4cGVjdF91bnJlYWNoYWJsZSA6IG5vZGVfbG9jOkNvbXBhY3RfbG9jLnQgLT4gWyBgVW5yZWFjaGFibGUgXSB0XG5cbiAgKCoqIFtbQEBleHBlY3QudW5jYXVnaHRfZXhuIF9dXSAqKVxuICB2YWwgZXhwZWN0X3VuY2F1Z2h0X2V4blxuICAgIDogIGZvcm1hdHRpbmdfZmxleGliaWxpdHk6RXhwZWN0X25vZGVfZm9ybWF0dGluZy5GbGV4aWJpbGl0eS50XG4gICAgLT4gbm9kZV9sb2M6Q29tcGFjdF9sb2MudFxuICAgIC0+IGxvY2F0ZWRfcGF5bG9hZDooT3V0cHV0LlBheWxvYWQudCAqIENvbXBhY3RfbG9jLnQpIG9wdGlvblxuICAgIC0+IFsgYEV4cGVjdCBdIHRcblxuICAoKiogUnVudGltZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW1wbGljaXQgW1slZXhwZWN0IHt8fH1dXSBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGV4cGVjdFxuICAgICAgdGVzdC4gKilcbiAgdmFsIGV4cGVjdF90cmFpbGluZyA6IGluc2VydF9sb2M6VmlydHVhbF9sb2MudCAtPiBbIGBFeHBlY3QgXSB0XG5cbiAgKCoqIFJ1bnRpbWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFzc2VydGlvbiB0aGF0IGEgdGVzdCBkb2VzIG5vdCBwcm9kdWNlIHVuY2F1Z2h0XG4gICAgICBleGNlcHRpb25zLCB3aGljaCBhIHVzZXIgaW1wbGljaXRseSBtYWtlcyBieSBvbWl0dGluZyBhbiBbW0BAZXhwZWN0LnVuY2F1Z2h0X2V4biBfXV1cbiAgICAgIGF0dHJpYnV0ZS4gKilcbiAgdmFsIGV4cGVjdF9ub191bmNhdWdodF9leG4gOiBpbnNlcnRfbG9jOlZpcnR1YWxfbG9jLnQgLT4gWyBgVW5yZWFjaGFibGUgXSB0XG5cbiAgbW9kdWxlIEZvcl9hcHBseV9zdHlsZSA6IHNpZ1xuICAgIHR5cGUgZm9ybWF0X3BheWxvYWQgOj1cbiAgICAgIGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmc6RXhwZWN0X25vZGVfZm9ybWF0dGluZy50XG4gICAgICAtPiBwYXlsb2FkX2xvYzpDb21wYWN0X2xvYy50XG4gICAgICAtPiBub2RlX2xvYzpDb21wYWN0X2xvYy50XG4gICAgICAtPiBTdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyLnRcbiAgICAgIC0+IHN0cmluZ1xuICAgICAgLT4gc3RyaW5nIG9wdGlvblxuXG4gICAgdmFsIGZvcm1hdF9leHBlY3RfcGF5bG9hZCA6IGZvcm1hdF9wYXlsb2FkXG4gICAgdmFsIGZvcm1hdF91bmNhdWdodF9leG5fcGF5bG9hZCA6IGZvcm1hdF9wYXlsb2FkXG4gIGVuZFxuZW5kXG4iLCJvcGVuISBCYXNlXG5vcGVuIFR5cGVzXG5pbmNsdWRlIEV4cGVjdGF0aW9uX2ludGYuRGVmaW5pdGlvbnNcblxubW9kdWxlIEluc2VydF9sb2MgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbnNlcnRfbG9jXG5cbiAgbGV0IGxvYyA9IGZ1bmN0aW9uXG4gICAgfCBPdmVyd3JpdGUgeyB3aG9sZV9ub2RlOyBwYXlsb2FkID0gXyB9IC0+IHdob2xlX25vZGVcbiAgICB8IEluc2VydCB7IGxvYzsgYm9keV9sb2MgPSBfIH0gLT4gbG9jXG4gIDs7XG5lbmRcblxubGV0IHdpdGhfYmVoYXZpb3JcbiAgeyBwb3NpdGlvblxuICA7IGJlaGF2aW9yID0gX1xuICA7IHBheWxvYWRfdHlwZVxuICA7IG9uX2luY29ycmVjdF9vdXRwdXRcbiAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlXG4gIH1cbiAgYmVoYXZpb3JcbiAgPVxuICB7IHBvc2l0aW9uOyBiZWhhdmlvcjsgcGF5bG9hZF90eXBlOyBvbl9pbmNvcnJlY3Rfb3V0cHV0OyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlIH1cbjs7XG5cbmxldCBmb3JtYXR0ZXJcbiAgKHR5cGUgYmVoYXZpb3IpXG4gIH4oZXhwZWN0X25vZGVfZm9ybWF0dGluZyA6IEV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcudClcbiAgKHsgcG9zaXRpb25cbiAgIDsgYmVoYXZpb3JcbiAgIDsgcGF5bG9hZF90eXBlXG4gICA7IG9uX2luY29ycmVjdF9vdXRwdXQgPSBUIG9uX2luY29ycmVjdF9vdXRwdXRcbiAgIDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSA9IF9cbiAgIH0gOlxuICAgIGJlaGF2aW9yIHQpXG4gID1cbiAgbGV0IGNvdW50X2xlYWRpbmdfc3BhY2VzIGxpbmUgPVxuICAgIGxpbmUgfD4gU3RyaW5nLnRvX2xpc3QgfD4gTGlzdC50YWtlX3doaWxlIH5mOihDaGFyLiggPSApICcgJykgfD4gTGlzdC5sZW5ndGhcbiAgaW5cbiAgT3V0cHV0LkZvcm1hdHRlci5jcmVhdGVcbiAgQEBcbiAgbWF0Y2ggcGF5bG9hZF90eXBlIHdpdGhcbiAgfCBFeGFjdCAtPiBGbi5pZFxuICB8IFByZXR0eSAtPlxuICAgIGZ1biBzdHIgLT5cbiAgICAgIGxldCBsaW5lcyA9XG4gICAgICAgICgqIEluIHByZXR0eSBwYXlsb2Fkcywgd2Ugbm9ybWFsaXplIGFsbCBuZXdsaW5lcyB0byBbJ1xcbiddLiBbWyVleHBlY3RfZXhhY3QgXCJcIl1dXG4gICAgICAgICAgIGNhbiBiZSB1c2VkIGluIGNhc2VzIHdoZXJlIGEgdXNlciB3YW50cyB0byBpbnNwZWN0IHRoZSB3aGl0ZXNwYWNlIHByb2R1Y2VkIGJ5XG4gICAgICAgICAgIHRoZWlyIG91dHB1dCBtb3JlIGNsb3NlbHkuICopXG4gICAgICAgIGxldCBzdHJpcHBlZCA9XG4gICAgICAgICAgc3RyXG4gICAgICAgICAgfD4gU3RyaW5nLnNwbGl0X2xpbmVzXG4gICAgICAgICAgfD4gTGlzdC5tYXAgfmY6KFN0cmluZy5yc3RyaXAgfmRyb3A6Q2hhci5pc193aGl0ZXNwYWNlKVxuICAgICAgICAgIHw+IExpc3QuZHJvcF93aGlsZSB+ZjpTdHJpbmcuaXNfZW1wdHlcbiAgICAgICAgICB8PiBMaXN0LnJldlxuICAgICAgICAgIHw+IExpc3QuZHJvcF93aGlsZSB+ZjpTdHJpbmcuaXNfZW1wdHlcbiAgICAgICAgICB8PiBMaXN0LnJldlxuICAgICAgICBpblxuICAgICAgICBsZXQgaW5kZW50X2FuZF9jb250ZW50cyA9XG4gICAgICAgICAgTGlzdC5tYXAgc3RyaXBwZWQgfmY6KGZ1biBsaW5lIC0+XG4gICAgICAgICAgICAoKiBUaGUgbGVnYWN5IGJlaGF2aW9yIGlzIHRvIG9ubHkgY291bnQgdGhlIGxvbmdlc3QgcHJlZml4IG9mIGFjdHVhbCBzcGFjZXNcbiAgICAgICAgICAgICAgIChbJyAnXSkgZm9yIGluZGVudGF0aW9uLCBidXQgdG8gc3RyaXAgYWxsIHdoaXRlc3BhY2UgKGluY2x1ZGluZywgZS5nLixcbiAgICAgICAgICAgICAgIFsnXFx0J10pLiBOb3RlIHRoYXQgdGhpcyBtZWFucyBbXCIgXFx0IGNvbnRlbnRzXCJdIGlzIGNvdW50ZWQgYXMgaGF2aW5nXG4gICAgICAgICAgICAgICBjb250ZW50cyBbXCJjb250ZW50c1wiXSBhbmQgaW5kZW50YXRpb24gWzFdLiAqKVxuICAgICAgICAgICAgY291bnRfbGVhZGluZ19zcGFjZXMgbGluZSwgU3RyaW5nLnN0cmlwIGxpbmUpXG4gICAgICAgIGluXG4gICAgICAgIG1hdGNoXG4gICAgICAgICAgaW5kZW50X2FuZF9jb250ZW50c1xuICAgICAgICAgIHw+IExpc3QuZmlsdGVyX21hcCB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgIHwgX2luZGVudCwgXCJcIiAtPiBOb25lXG4gICAgICAgICAgICAgICB8IGluZGVudCwgXyAtPiBTb21lIGluZGVudClcbiAgICAgICAgICB8PiBMaXN0Lm1pbl9lbHQgfmNvbXBhcmU6SW50LmNvbXBhcmVcbiAgICAgICAgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgfCBTb21lIG1pbl9pbmRlbnQgLT5cbiAgICAgICAgICBMaXN0Lm1hcCBpbmRlbnRfYW5kX2NvbnRlbnRzIH5mOihmdW4gKGluZGVudCwgbGluZSkgLT5cbiAgICAgICAgICAgIEludC5tYXggMCAoaW5kZW50IC0gbWluX2luZGVudCksIGxpbmUpXG4gICAgICBpblxuICAgICAgbGV0IChUIHRhZykgPVxuICAgICAgICBtYXRjaCAoYmVoYXZpb3IgOiBfIEJlaGF2aW9yLnQpIHdpdGhcbiAgICAgICAgfCBFeHBlY3QgeyBwYXlsb2FkID0geyB0YWc7IGNvbnRlbnRzID0gXyB9OyBfIH0gLT4gdGFnXG4gICAgICAgIHwgVW5yZWFjaGFibGUgXyAtPiBTdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyLmRlZmF1bHRcbiAgICAgIGluXG4gICAgICAobWF0Y2ggbGluZXMsIGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuYWx3YXlzX29uX293bl9saW5lIHdpdGhcbiAgICAgICB8IFtdLCBfIC0+XG4gICAgICAgICAoKiBBbiBlbXB0eSBib2R5IHNob3VsZCBlaXRoZXIgYmUgW3t8IHx9XSBvciBbXCJcIl0gKilcbiAgICAgICAgIChtYXRjaCB0YWcgd2l0aFxuICAgICAgICAgIHwgVGFnIF8gLT4gXCIgXCJcbiAgICAgICAgICB8IFF1b3RlIC0+IFwiXCIpXG4gICAgICAgfCBbIChfaW5kZW50LCBsaW5lKSBdLCBmYWxzZSAtPlxuICAgICAgICAgKCogQSBzaW5nbGUgbGluZSBzaG91bGQgZWl0aGVyIGJlIFt7fCBsaW5lIHx9XSBvciBbXCJsaW5lXCJdICopXG4gICAgICAgICAobWF0Y2ggdGFnIHdpdGhcbiAgICAgICAgICB8IFRhZyBfIC0+IFN0cmluZy5jb25jYXQgWyBcIiBcIjsgbGluZTsgXCIgXCIgXVxuICAgICAgICAgIHwgUXVvdGUgLT4gbGluZSlcbiAgICAgICB8IGxpbmVzLCBfIC0+XG4gICAgICAgICBsZXQgbG9jYXRpb25faW5kZW50ID1cbiAgICAgICAgICAgZXhwZWN0X25vZGVfZm9ybWF0dGluZy5pbmRlbnRcbiAgICAgICAgICAgKCogVGhlIGNvbnRlbnRzIGFyZSBhbHdheXMgaW5kZW50ZWQgdHdvIHNwYWNlcyBwYXN0IHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlXG4gICAgICAgICAgICAgIGV4dGVuc2lvbiBwb2ludCAqKVxuICAgICAgICAgICArXG4gICAgICAgICAgIG1hdGNoIHBvc2l0aW9uIHdpdGhcbiAgICAgICAgICAgfCBPdmVyd3JpdGUgeyB3aG9sZV9ub2RlID0geyBzdGFydF9ib2w7IHN0YXJ0X3BvczsgZW5kX3BvcyA9IF8gfTsgcGF5bG9hZCA9IF8gfVxuICAgICAgICAgICAgIC0+XG4gICAgICAgICAgICAgKCogSWYgd2UgYXJlIG92ZXJ3cml0aW5nIGFuIGV4dGVuc2lvbiBwb2ludCwgd2Ugc2hvdWxkIHRha2UgaXRzIGxlZnQgZWRnZSAqKVxuICAgICAgICAgICAgIHN0YXJ0X3BvcyAtIHN0YXJ0X2JvbFxuICAgICAgICAgICB8IEluc2VydCB7IGJvZHlfbG9jID0geyBzdGFydF9ib2w7IHN0YXJ0X3BvczsgZW5kX3BvcyA9IF8gfTsgbG9jID0gXyB9IC0+XG4gICAgICAgICAgICAgKCogSWYgd2UgYXJlIGluc2VydGluZyBhIG5ldyBleHRlbnNpb24gcG9pbnQsIHdlIHNob3VsZCBjb21wdXRlIGl0cyBsZWZ0XG4gICAgICAgICAgICAgICAgZWRnZWQgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSBbbGV0JWV4cGVjdF90ZXN0XSBub2RlICopXG4gICAgICAgICAgICAgc3RhcnRfcG9zXG4gICAgICAgICAgICAgLSBzdGFydF9ib2xcbiAgICAgICAgICAgICArXG4gICAgICAgICAgICAgKG1hdGNoIG9uX2luY29ycmVjdF9vdXRwdXQua2luZCB3aXRoXG4gICAgICAgICAgICAgIHwgRXh0ZW5zaW9uIC0+IGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuaW5kZW50XG4gICAgICAgICAgICAgIHwgQXR0cmlidXRlIC0+IDApXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IHNwYWNlcyBuID0gU3RyaW5nLm1ha2UgbiAnICcgaW5cbiAgICAgICAgIGxldCBmaXJzdF9saW5lLCBpbmRlbnRhdGlvbiwgbGFzdF9saW5lID1cbiAgICAgICAgICAgbWF0Y2ggdGFnIHdpdGhcbiAgICAgICAgICAgfCBRdW90ZSAtPlxuICAgICAgICAgICAgICgqIFNpbmNlIG9jYW1sZm9ybWF0IHdpbGwgc3BsaXQgdGhlIHN0cmluZyBvbnRvIGxpbmVzIGFuZCBpbmRlbnQgdGhlbSBmb3JcbiAgICAgICAgICAgICAgICB1cywgd2Ugc2hvdWxkbid0IGluc2VydCBsaXRlcmFsIHdoaXRlc3BhY2UgdG8gaW5kZW50IHRoZSBzdHJpbmcuICopXG4gICAgICAgICAgICAgXCIgXCIsIDEsIFwiIFwiXG4gICAgICAgICAgIHwgVGFnIF8gLT4gXCJcIiwgbG9jYXRpb25faW5kZW50LCBzcGFjZXMgbG9jYXRpb25faW5kZW50XG4gICAgICAgICBpblxuICAgICAgICAgbGV0IGxpbmVzID1cbiAgICAgICAgICAgTGlzdC5tYXAgbGluZXMgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgICAgfCBfaW5kZW50LCBcIlwiIC0+IFwiXCJcbiAgICAgICAgICAgICB8IGxpbmVfaW5kZW50LCBsaW5lIC0+IHNwYWNlcyAoaW5kZW50YXRpb24gKyBsaW5lX2luZGVudCkgXiBsaW5lKVxuICAgICAgICAgaW5cbiAgICAgICAgIFsgWyBmaXJzdF9saW5lIF07IGxpbmVzOyBbIGxhc3RfbGluZSBdIF1cbiAgICAgICAgIHw+IExpc3QuY29uY2F0XG4gICAgICAgICB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCJcXG5cIilcbjs7XG5cbmxldCBleHRlbnNpb25fc3ludGF4IGV4dGVuc2lvbl9uYW1lIH5wYXlsb2FkX2xvYyB+bm9kZV9sb2MgPVxuICBsZXQgY29udGFpbnMgKG91dGVyIDogQ29tcGFjdF9sb2MudCkgfihpbm5lciA6IENvbXBhY3RfbG9jLnQpID1cbiAgICBvdXRlci5zdGFydF9wb3MgPD0gaW5uZXIuc3RhcnRfcG9zICYmIG91dGVyLmVuZF9wb3MgPj0gaW5uZXIuZW5kX3Bvc1xuICBpblxuICBtYXRjaCBwYXlsb2FkX2xvYyB3aXRoXG4gIHwgU29tZSBwYXlsb2FkX2xvYyB3aGVuIGNvbnRhaW5zIHBheWxvYWRfbG9jIH5pbm5lcjpub2RlX2xvYyAtPlxuICAgICgqIEFuIGV4dGVuc2lvbiBwb2ludCB3aG9zZSBwYXlsb2FkIGxvY2F0aW9uIGNvbnRhaW5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgZW50aXJlXG4gICAgICAgZXh0ZW5zaW9uIHBvaW50IGlzIHVzaW5nIHRoZSBcInNob3J0aGFuZFwiIHN5bnRheC4gKilcbiAgICAoVCB7IG5hbWUgPSBleHRlbnNpb25fbmFtZTsga2luZCA9IEV4dGVuc2lvbjsgaGFuZCA9IFNob3J0aGFuZCB9XG4gICAgICA6IFN0cmluZ19ub2RlX2Zvcm1hdC5TaGFwZS50KVxuICB8IF8gLT4gVCB7IG5hbWUgPSBleHRlbnNpb25fbmFtZTsga2luZCA9IEV4dGVuc2lvbjsgaGFuZCA9IExvbmdoYW5kIH1cbjs7XG5cbmxldCBwb3NzaWJseV9yZWxheF9zdHJpY3RuZXNzXG4gIH4oZm9ybWF0dGluZ19mbGV4aWJpbGl0eSA6IEV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuRmxleGliaWxpdHkudClcbiAgKHQgOiBbIGBFeHBlY3QgXSB0KVxuICA9XG4gIG1hdGNoIGZvcm1hdHRpbmdfZmxleGliaWxpdHkgd2l0aFxuICB8IEV4YWN0bHlfZm9ybWF0dGVkIC0+IHRcbiAgfCBGbGV4aWJsZV9tb2R1bG8gZXhwZWN0X25vZGVfZm9ybWF0dGluZyAtPlxuICAgIGxldCBmbXQgPSBmb3JtYXR0ZXIgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgdCBpblxuICAgIGxldCAoRXhwZWN0IHsgcGF5bG9hZCA9IHsgY29udGVudHM7IHRhZyB9OyBvbl91bnJlYWNoYWJsZTsgcmVhY2hhYmlsaXR5IH0pID1cbiAgICAgIHQuYmVoYXZpb3JcbiAgICBpblxuICAgIChtYXRjaFxuICAgICAgIE91dHB1dC5yZWNvbmNpbGVcbiAgICAgICAgIH5leHBlY3RlZF9vdXRwdXQ6Y29udGVudHNcbiAgICAgICAgIH50ZXN0X291dHB1dDooT3V0cHV0LkZvcm1hdHRlci5hcHBseSBmbXQgY29udGVudHMpXG4gICAgIHdpdGhcbiAgICAgfCBQYXNzIC0+IHRcbiAgICAgfCBGYWlsIGNvbnRlbnRzIC0+XG4gICAgICAgbGV0IHBheWxvYWQgPSBPdXRwdXQudG9fZm9ybWF0dGVkX3BheWxvYWQgfnRhZyBjb250ZW50cyBpblxuICAgICAgIHdpdGhfYmVoYXZpb3IgdCAoRXhwZWN0IHsgcGF5bG9hZDsgb25fdW5yZWFjaGFibGU7IHJlYWNoYWJpbGl0eSB9KSlcbjs7XG5cbmxldCBleHBlY3RlZF9zdHJpbmdfYW5kX3BheWxvYWRfbG9jID0gZnVuY3Rpb25cbiAgfCBTb21lIChhLCBiKSAtPiBhLCBTb21lIGJcbiAgfCBOb25lIC0+IE91dHB1dC5QYXlsb2FkLmRlZmF1bHQgXCJcIiwgTm9uZVxuOztcblxubGV0IGV4cGVjdCB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eSB+bm9kZV9sb2MgfmxvY2F0ZWRfcGF5bG9hZCA9XG4gIGxldCBwYXlsb2FkLCBwYXlsb2FkX2xvYyA9IGV4cGVjdGVkX3N0cmluZ19hbmRfcGF5bG9hZF9sb2MgbG9jYXRlZF9wYXlsb2FkIGluXG4gIHsgcG9zaXRpb24gPSBPdmVyd3JpdGUgeyB3aG9sZV9ub2RlID0gbm9kZV9sb2M7IHBheWxvYWQgPSBwYXlsb2FkX2xvYyB9XG4gIDsgYmVoYXZpb3IgPVxuICAgICAgRXhwZWN0XG4gICAgICAgIHsgcGF5bG9hZDsgb25fdW5yZWFjaGFibGUgPSBSZXBsYWNlX3dpdGhfdW5yZWFjaGFibGU7IHJlYWNoYWJpbGl0eSA9IENhbl9yZWFjaCB9XG4gIDsgcGF5bG9hZF90eXBlID0gUHJldHR5XG4gIDsgb25faW5jb3JyZWN0X291dHB1dCA9IGV4dGVuc2lvbl9zeW50YXggXCJleHBlY3RcIiB+cGF5bG9hZF9sb2Mgfm5vZGVfbG9jXG4gIDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSA9IFwidGVzdCBvdXRwdXRcIlxuICB9XG4gIHw+IHBvc3NpYmx5X3JlbGF4X3N0cmljdG5lc3MgfmZvcm1hdHRpbmdfZmxleGliaWxpdHlcbjs7XG5cbmxldCBleHBlY3RfZXhhY3QgfmZvcm1hdHRpbmdfZmxleGliaWxpdHkgfm5vZGVfbG9jIH5sb2NhdGVkX3BheWxvYWQgPVxuICBsZXQgcGF5bG9hZCwgcGF5bG9hZF9sb2MgPSBleHBlY3RlZF9zdHJpbmdfYW5kX3BheWxvYWRfbG9jIGxvY2F0ZWRfcGF5bG9hZCBpblxuICB7IHBvc2l0aW9uID0gT3ZlcndyaXRlIHsgd2hvbGVfbm9kZSA9IG5vZGVfbG9jOyBwYXlsb2FkID0gcGF5bG9hZF9sb2MgfVxuICA7IGJlaGF2aW9yID1cbiAgICAgIEV4cGVjdFxuICAgICAgICB7IHBheWxvYWQ7IG9uX3VucmVhY2hhYmxlID0gUmVwbGFjZV93aXRoX3VucmVhY2hhYmxlOyByZWFjaGFiaWxpdHkgPSBDYW5fcmVhY2ggfVxuICA7IHBheWxvYWRfdHlwZSA9IEV4YWN0XG4gIDsgb25faW5jb3JyZWN0X291dHB1dCA9IGV4dGVuc2lvbl9zeW50YXggXCJleHBlY3RfZXhhY3RcIiB+cGF5bG9hZF9sb2Mgfm5vZGVfbG9jXG4gIDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSA9IFwidGVzdCBvdXRwdXRcIlxuICB9XG4gIHw+IHBvc3NpYmx5X3JlbGF4X3N0cmljdG5lc3MgfmZvcm1hdHRpbmdfZmxleGliaWxpdHlcbjs7XG5cbmxldCBleHBlY3RfdW5yZWFjaGFibGUgfm5vZGVfbG9jID1cbiAgeyBwb3NpdGlvbiA9IE92ZXJ3cml0ZSB7IHdob2xlX25vZGUgPSBub2RlX2xvYzsgcGF5bG9hZCA9IE5vbmUgfVxuICA7IGJlaGF2aW9yID0gVW5yZWFjaGFibGUgeyByZWFjaGFiaWxpdHlfb2ZfY29ycmVjdGVkID0gQ2FuX3JlYWNoIH1cbiAgOyBwYXlsb2FkX3R5cGUgPSBQcmV0dHlcbiAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gVCB7IG5hbWUgPSBcImV4cGVjdFwiOyBraW5kID0gRXh0ZW5zaW9uOyBoYW5kID0gTG9uZ2hhbmQgfVxuICA7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UgPSBcInRlc3Qgb3V0cHV0XCJcbiAgfVxuOztcblxubGV0IGV4cGVjdF91bmNhdWdodF9leG4gfmZvcm1hdHRpbmdfZmxleGliaWxpdHkgfm5vZGVfbG9jIH5sb2NhdGVkX3BheWxvYWQgPVxuICBsZXQgcGF5bG9hZCwgcGF5bG9hZF9sb2MgPSBleHBlY3RlZF9zdHJpbmdfYW5kX3BheWxvYWRfbG9jIGxvY2F0ZWRfcGF5bG9hZCBpblxuICB7IHBvc2l0aW9uID0gT3ZlcndyaXRlIHsgd2hvbGVfbm9kZSA9IG5vZGVfbG9jOyBwYXlsb2FkID0gcGF5bG9hZF9sb2MgfVxuICA7IGJlaGF2aW9yID0gRXhwZWN0IHsgcGF5bG9hZDsgb25fdW5yZWFjaGFibGUgPSBEZWxldGU7IHJlYWNoYWJpbGl0eSA9IE11c3RfcmVhY2ggfVxuICA7IHBheWxvYWRfdHlwZSA9IFByZXR0eVxuICA7IG9uX2luY29ycmVjdF9vdXRwdXQgPVxuICAgICAgVCB7IG5hbWUgPSBcImV4cGVjdC51bmNhdWdodF9leG5cIjsga2luZCA9IEF0dHJpYnV0ZTsgaGFuZCA9IExvbmdoYW5kIH1cbiAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlID0gXCJ1bmNhdWdodCBleGNlcHRpb25cIlxuICB9XG4gIHw+IHBvc3NpYmx5X3JlbGF4X3N0cmljdG5lc3MgfmZvcm1hdHRpbmdfZmxleGliaWxpdHlcbjs7XG5cbmxldCBleHBlY3RfdHJhaWxpbmcgfmluc2VydF9sb2MgPVxuICB7IHBvc2l0aW9uID0gSW5zZXJ0IGluc2VydF9sb2NcbiAgOyBiZWhhdmlvciA9XG4gICAgICBFeHBlY3RcbiAgICAgICAgeyBwYXlsb2FkID0gT3V0cHV0LlBheWxvYWQuZGVmYXVsdCBcIiBcIlxuICAgICAgICA7IG9uX3VucmVhY2hhYmxlID0gU2lsZW50XG4gICAgICAgIDsgcmVhY2hhYmlsaXR5ID0gQ2FuX3JlYWNoXG4gICAgICAgIH1cbiAgOyBwYXlsb2FkX3R5cGUgPSBQcmV0dHlcbiAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gVCB7IG5hbWUgPSBcImV4cGVjdFwiOyBraW5kID0gRXh0ZW5zaW9uOyBoYW5kID0gTG9uZ2hhbmQgfVxuICA7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UgPSBcInRyYWlsaW5nIG91dHB1dFwiXG4gIH1cbjs7XG5cbmxldCBleHBlY3Rfbm9fdW5jYXVnaHRfZXhuIH5pbnNlcnRfbG9jID1cbiAgeyBwb3NpdGlvbiA9IEluc2VydCBpbnNlcnRfbG9jXG4gIDsgYmVoYXZpb3IgPSBVbnJlYWNoYWJsZSB7IHJlYWNoYWJpbGl0eV9vZl9jb3JyZWN0ZWQgPSBNdXN0X3JlYWNoIH1cbiAgOyBwYXlsb2FkX3R5cGUgPSBQcmV0dHlcbiAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID1cbiAgICAgIFQgeyBuYW1lID0gXCJleHBlY3QudW5jYXVnaHRfZXhuXCI7IGtpbmQgPSBBdHRyaWJ1dGU7IGhhbmQgPSBMb25naGFuZCB9XG4gIDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSA9IFwidW5jYXVnaHQgZXhjZXB0aW9uXCJcbiAgfVxuOztcblxubW9kdWxlIEZvcl9hcHBseV9zdHlsZSA9IHN0cnVjdFxuICBsZXQgZm9ybWF0X3BheWxvYWQgbWtfbm9kZSA9XG4gICAgU3RhZ2VkLnN0YWdlXG4gICAgQEAgZnVuIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nIH5wYXlsb2FkX2xvYyB+bm9kZV9sb2MgdGFnIGNvbnRlbnRzIC0+XG4gICAgbGV0IG5vZGUgPVxuICAgICAgbWtfbm9kZVxuICAgICAgICB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eTooRXhhY3RseV9mb3JtYXR0ZWQgOiBFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nLkZsZXhpYmlsaXR5LnQpXG4gICAgICAgIH5ub2RlX2xvY1xuICAgICAgICB+bG9jYXRlZF9wYXlsb2FkOihTb21lICgoeyB0YWc7IGNvbnRlbnRzIH0gOiBPdXRwdXQuUGF5bG9hZC50KSwgcGF5bG9hZF9sb2MpKVxuICAgIGluXG4gICAgbGV0IGZvcm1hdHRlZF9jb250ZW50cyA9XG4gICAgICBPdXRwdXQuRm9ybWF0dGVyLmFwcGx5IChmb3JtYXR0ZXIgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgbm9kZSkgY29udGVudHNcbiAgICBpblxuICAgIG1hdGNoIE91dHB1dC5yZWNvbmNpbGUgfmV4cGVjdGVkX291dHB1dDpjb250ZW50cyB+dGVzdF9vdXRwdXQ6Zm9ybWF0dGVkX2NvbnRlbnRzIHdpdGhcbiAgICB8IFBhc3MgLT4gTm9uZVxuICAgIHwgRmFpbCBjb250ZW50cyAtPlxuICAgICAgbGV0IHNvdXJjZV9jb2RlX3N0cmluZyA9XG4gICAgICAgIG1hdGNoIG5vZGUub25faW5jb3JyZWN0X291dHB1dCB3aXRoXG4gICAgICAgIHwgVCB7IGhhbmQgPSBMb25naGFuZDsgXyB9IC0+XG4gICAgICAgICAgT3V0cHV0LnRvX2Zvcm1hdHRlZF9wYXlsb2FkIH50YWcgY29udGVudHNcbiAgICAgICAgICB8PiBPdXRwdXQuUGF5bG9hZC50b19zb3VyY2VfY29kZV9zdHJpbmdcbiAgICAgICAgfCBUIHsgaGFuZCA9IFNob3J0aGFuZDsgXyB9IGFzIG5vZGVfc2hhcGUgLT5cbiAgICAgICAgICBPdXRwdXQudG9fc291cmNlX2NvZGVfc3RyaW5nIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nIH5ub2RlX3NoYXBlIH50YWcgY29udGVudHNcbiAgICAgIGluXG4gICAgICBTb21lIHNvdXJjZV9jb2RlX3N0cmluZ1xuICA7O1xuXG4gIGxldCBmb3JtYXRfZXhwZWN0X3BheWxvYWQgPSBmb3JtYXRfcGF5bG9hZCBleHBlY3QgfD4gU3RhZ2VkLnVuc3RhZ2VcbiAgbGV0IGZvcm1hdF91bmNhdWdodF9leG5fcGF5bG9hZCA9IGZvcm1hdF9wYXlsb2FkIGV4cGVjdF91bmNhdWdodF9leG4gfD4gU3RhZ2VkLnVuc3RhZ2VcbmVuZFxuIiwib3BlbiEgQmFzZVxub3BlbiBUeXBlc1xuXG5tb2R1bGUgQ29ycmVjdGlvbiA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgTmV3X3BheWxvYWQgOlxuICAgICAgICBbPCBFeHBlY3RhdGlvbi5CZWhhdmlvcl90eXBlLnQgXSBFeHBlY3RhdGlvbi50ICogT3V0cHV0LlJlY29uY2lsZWQudFxuICAgICAgICAtPiB0XG4gICAgfCBVbnJlYWNoYWJsZSA6IFsgYEV4cGVjdCBdIEV4cGVjdGF0aW9uLnQgLT4gdFxuXG4gICgqKiBbU29tZSAobG9jLCBwYXRjaCldIGlmIFtjb3JyZWN0aW9uXSB3YXJyYW50cyBpbnNlcnRpbmcgW3BhdGNoXSBpbnRvIHRoZSByZXdyaXR0ZW5cbiAgICAgIGZpbGUgYXQgW2xvY10sIFtOb25lXSBpZiBubyBjaGFuZ2UgaXMgbmVlZGVkIGZyb20gW2NvcnJlY3Rpb25dLiAqKVxuICBsZXQgdG9fcGF0Y2hfb3B0IH4oZXhwZWN0X25vZGVfZm9ybWF0dGluZyA6IEV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcudCkgY29ycmVjdGlvbiA9XG4gICAgbWF0Y2ggY29ycmVjdGlvbiB3aXRoXG4gICAgfCBOZXdfcGF5bG9hZFxuICAgICAgICAoIHsgcG9zaXRpb25cbiAgICAgICAgICA7IGJlaGF2aW9yXG4gICAgICAgICAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gVCBvbl9pbmNvcnJlY3Rfb3V0cHV0XG4gICAgICAgICAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlID0gX1xuICAgICAgICAgIDsgcGF5bG9hZF90eXBlID0gX1xuICAgICAgICAgIH1cbiAgICAgICAgLCB0ZXN0X291dHB1dCApIC0+XG4gICAgICBsZXQgd2hpdGVzcGFjZSA9XG4gICAgICAgIG1hdGNoIHBvc2l0aW9uIHdpdGhcbiAgICAgICAgfCBJbnNlcnQgeyBib2R5X2xvYyA9IHsgc3RhcnRfcG9zOyBzdGFydF9ib2w7IF8gfTsgXyB9IC0+XG4gICAgICAgICAgKCogW2xldF9vZmZzZXRdIGlzIHRoZSBzcGFjZSB1bnRpbCB0aGUgbGF5ZXIgb2YgaW5kZW50YXRpb24gb2YgdGhlXG4gICAgICAgICAgICAgW2xldCVleHBlY3RfdGVzdF0gYmluZGluZy4gKilcbiAgICAgICAgICBsZXQgbGV0X29mZnNldCA9IHN0YXJ0X3BvcyAtIHN0YXJ0X2JvbCBpblxuICAgICAgICAgICgqIFRoZSBjb250ZW50cyBvZiB0aGUgZXhwZWN0IG5vZGUgYXJlIGluZGVudGVkIGFuIGFkZGl0aW9uYWwgdHdvIHNwYWNlcyBwYXN0XG4gICAgICAgICAgICAgdGhlIG5vZGUgaXRzZWxmLiAqKVxuICAgICAgICAgIGxldCBpbmRlbnQgPVxuICAgICAgICAgICAgbGV0X29mZnNldFxuICAgICAgICAgICAgK1xuICAgICAgICAgICAgbWF0Y2ggb25faW5jb3JyZWN0X291dHB1dC5raW5kIHdpdGhcbiAgICAgICAgICAgIHwgRXh0ZW5zaW9uIC0+IGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuaW5kZW50XG4gICAgICAgICAgICB8IEF0dHJpYnV0ZSAtPiAwXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgd2hpdGVzcGFjZSA9IFwiXFxuXCIgXiBTdHJpbmcubWFrZSBpbmRlbnQgJyAnIGluXG4gICAgICAgICAgd2hpdGVzcGFjZVxuICAgICAgICB8IE92ZXJ3cml0ZSBfIC0+IFwiXCJcbiAgICAgIGluXG4gICAgICBsZXQgdGFnID1cbiAgICAgICAgbWF0Y2ggYmVoYXZpb3Igd2l0aFxuICAgICAgICB8IEV4cGVjdCB7IHBheWxvYWQgPSB7IHRhZzsgXyB9OyBvbl91bnJlYWNoYWJsZSA9IF87IHJlYWNoYWJpbGl0eSA9IF8gfSAtPiB0YWdcbiAgICAgICAgfCBVbnJlYWNoYWJsZSBfIC0+IFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIuZGVmYXVsdFxuICAgICAgaW5cbiAgICAgIGxldCBsb2MsIGNvcnJlY3Rpb24gPVxuICAgICAgICBtYXRjaCBwb3NpdGlvbiwgb25faW5jb3JyZWN0X291dHB1dCB3aXRoXG4gICAgICAgIHwgKCBPdmVyd3JpdGUgeyBwYXlsb2FkID0gU29tZSBwYXlsb2FkX2xvYzsgd2hvbGVfbm9kZSA9IF8gfVxuICAgICAgICAgICwgeyBraW5kID0gRXh0ZW5zaW9uOyBoYW5kID0gTG9uZ2hhbmQ7IG5hbWUgPSBfIH0gKSAtPlxuICAgICAgICAgIGxldCBjb3JyZWN0aW9uID1cbiAgICAgICAgICAgIE91dHB1dC50b19mb3JtYXR0ZWRfcGF5bG9hZCB+dGFnIHRlc3Rfb3V0cHV0XG4gICAgICAgICAgICB8PiBPdXRwdXQuUGF5bG9hZC50b19zb3VyY2VfY29kZV9zdHJpbmdcbiAgICAgICAgICBpblxuICAgICAgICAgIHBheWxvYWRfbG9jLCBjb3JyZWN0aW9uXG4gICAgICAgIHwgKE92ZXJ3cml0ZSB7IHBheWxvYWQgPSBfOyB3aG9sZV9ub2RlID0gbG9jIH0gfCBJbnNlcnQgeyBsb2M7IGJvZHlfbG9jID0gXyB9KSwgX1xuICAgICAgICAgIC0+XG4gICAgICAgICAgKCBsb2NcbiAgICAgICAgICAsIE91dHB1dC50b19zb3VyY2VfY29kZV9zdHJpbmdcbiAgICAgICAgICAgICAgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmdcbiAgICAgICAgICAgICAgfm5vZGVfc2hhcGU6KFQgb25faW5jb3JyZWN0X291dHB1dClcbiAgICAgICAgICAgICAgfnRhZ1xuICAgICAgICAgICAgICB0ZXN0X291dHB1dCApXG4gICAgICBpblxuICAgICAgU29tZSAobG9jLCB3aGl0ZXNwYWNlIF4gY29ycmVjdGlvbilcbiAgICB8IFVucmVhY2hhYmxlXG4gICAgICAgIHsgYmVoYXZpb3IgPSBFeHBlY3QgeyBvbl91bnJlYWNoYWJsZTsgcGF5bG9hZCA9IF87IHJlYWNoYWJpbGl0eSA9IF8gfVxuICAgICAgICA7IG9uX2luY29ycmVjdF9vdXRwdXQgPSBUIG9uX2luY29ycmVjdF9vdXRwdXRcbiAgICAgICAgOyBwb3NpdGlvblxuICAgICAgICA7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UgPSBfXG4gICAgICAgIDsgcGF5bG9hZF90eXBlID0gX1xuICAgICAgICB9IC0+XG4gICAgICBsZXQgbG9jID0gRXhwZWN0YXRpb24uSW5zZXJ0X2xvYy5sb2MgcG9zaXRpb24gaW5cbiAgICAgIChtYXRjaCBvbl91bnJlYWNoYWJsZSB3aXRoXG4gICAgICAgfCBTaWxlbnQgLT4gTm9uZVxuICAgICAgIHwgRGVsZXRlIC0+IFNvbWUgKGxvYywgXCJcIilcbiAgICAgICB8IFJlcGxhY2Vfd2l0aF91bnJlYWNoYWJsZSAtPlxuICAgICAgICAgbGV0IHByZWZpeCA9XG4gICAgICAgICAgIG1hdGNoIG9uX2luY29ycmVjdF9vdXRwdXQua2luZCB3aXRoXG4gICAgICAgICAgIHwgRXh0ZW5zaW9uIC0+IGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuZXh0ZW5zaW9uX3NpZ2lsXG4gICAgICAgICAgIHwgQXR0cmlidXRlIC0+IGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuYXR0cmlidXRlX3NpZ2lsXG4gICAgICAgICBpblxuICAgICAgICAgU29tZSAobG9jLCBQcmludGYuc3ByaW50ZiBcIlslc2V4cGVjdC51bnJlYWNoYWJsZV1cIiBwcmVmaXgpKVxuICA7O1xuXG4gIGxldCB0b19kaWZmcyB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB+b3JpZ2luYWxfZmlsZV9jb250ZW50cyBjb3JyZWN0aW9uID1cbiAgICBsZXQgc2FmZV9ieXRlX2dldCBzdHJpbmcgaSA9XG4gICAgICBpZiBpID49IDAgJiYgaSA8IFN0cmluZy5sZW5ndGggc3RyaW5nIHRoZW4gU29tZSAoU3RyaW5nLmdldCBzdHJpbmcgaSkgZWxzZSBOb25lXG4gICAgaW5cbiAgICBtYXRjaCB0b19wYXRjaF9vcHQgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgY29ycmVjdGlvbiB3aXRoXG4gICAgfCBOb25lIC0+IFtdXG4gICAgfCBTb21lIChsb2MsIGRpZmYpIC0+XG4gICAgICBsZXQgKHsgc3RhcnRfYm9sOyBzdGFydF9wb3M7IGVuZF9wb3MgfSA6IENvbXBhY3RfbG9jLnQpID0gbG9jIGluXG4gICAgICBsZXQgbWFpbl9jb3JyZWN0aW9uID0gWyBsb2MsIGRpZmYgXSBpblxuICAgICAgKCogQWRkaXRpb25hbCBjb3JyZWN0aW9ucyBuZWNlc3NhcnkgZm9yIHByb2R1Y2luZyBjb3JyZWN0IGZvcm1hdHRpbmcgKilcbiAgICAgIGxldCBhZGRpdGlvbmFsX2NvcnJlY3Rpb25zID1cbiAgICAgICAgKCogSWYgZGVsZXRpbmcgYW4gW1tAQGV4cGVjdC51bmNhdWdodF9leG5dXSBhdHRyaWJ1dGUgd291bGRcbiAgICAgICAgICAgbGVhdmUgYW4gZW1wdHkgbGluZSwgZGVsZXRlIHRoYXQgbGluZS4gKilcbiAgICAgICAgbGV0IHJlbW92ZV9lbXB0eV9saW5lX2Zyb21fZGVsZXRlZF91bmNhdWdodF9leG4gPVxuICAgICAgICAgIG1hdGNoIGNvcnJlY3Rpb24gd2l0aFxuICAgICAgICAgIHwgVW5yZWFjaGFibGUgeyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gVCB7IGtpbmQgPSBBdHRyaWJ1dGU7IF8gfTsgXyB9IC0+XG4gICAgICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgICAgICggc2FmZV9ieXRlX2dldCBvcmlnaW5hbF9maWxlX2NvbnRlbnRzIChzdGFydF9wb3MgLSAxKVxuICAgICAgICAgICAgICAgLCBzYWZlX2J5dGVfZ2V0IG9yaWdpbmFsX2ZpbGVfY29udGVudHMgZW5kX3BvcyApXG4gICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgIHwgU29tZSAnXFxuJywgKE5vbmUgfCBTb21lICdcXG4nKSAtPlxuICAgICAgICAgICAgICAgU29tZVxuICAgICAgICAgICAgICAgICAoIHsgQ29tcGFjdF9sb2Muc3RhcnRfcG9zID0gc3RhcnRfcG9zIC0gMVxuICAgICAgICAgICAgICAgICAgIDsgZW5kX3BvcyA9IHN0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgIDsgc3RhcnRfYm9sXG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAsIFwiXCIgKVxuICAgICAgICAgICAgIHwgXyAtPiBOb25lKVxuICAgICAgICAgIHwgXyAtPiBOb25lXG4gICAgICAgIGluXG4gICAgICAgICgqIEluY2x1ZGUgdGhlIHNlbWljb2xvbiBuZWVkZWQgYXQgdGhlIGVuZCBvZiB0aGUgYm9keVxuICAgICAgICAgICBmb3IgYSB0cmFpbGluZyBbWyVleHBlY3RdXSBleHRlbnNpb24gcG9pbnQuICopXG4gICAgICAgIGxldCBhZGRfc2VtaWNvbG9uX2JlZm9yZV90cmFpbGluZ19leHBlY3QgPVxuICAgICAgICAgIG1hdGNoIGNvcnJlY3Rpb24gd2l0aFxuICAgICAgICAgIHwgTmV3X3BheWxvYWRcbiAgICAgICAgICAgICAgKCB7IG9uX2luY29ycmVjdF9vdXRwdXQgPSBUIHsga2luZCA9IEV4dGVuc2lvbjsgXyB9XG4gICAgICAgICAgICAgICAgOyBwb3NpdGlvbiA9IEluc2VydCB7IGJvZHlfbG9jOyBfIH1cbiAgICAgICAgICAgICAgICA7IF9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICwgXyApIC0+IFNvbWUgKHsgYm9keV9sb2Mgd2l0aCBzdGFydF9wb3MgPSBib2R5X2xvYy5lbmRfcG9zIH0sIFwiO1wiKVxuICAgICAgICAgIHwgXyAtPiBOb25lXG4gICAgICAgIGluXG4gICAgICAgIExpc3QuY29uY2F0X21hcFxuICAgICAgICAgIH5mOk9wdGlvbi50b19saXN0XG4gICAgICAgICAgWyByZW1vdmVfZW1wdHlfbGluZV9mcm9tX2RlbGV0ZWRfdW5jYXVnaHRfZXhuXG4gICAgICAgICAgOyBhZGRfc2VtaWNvbG9uX2JlZm9yZV90cmFpbGluZ19leHBlY3RcbiAgICAgICAgICBdXG4gICAgICBpblxuICAgICAgYWRkaXRpb25hbF9jb3JyZWN0aW9ucyBAIG1haW5fY29ycmVjdGlvblxuICA7O1xuZW5kXG5cbnR5cGUgb25lX291dHB1dCA9XG4gIHsgcmVzdWx0IDogT3V0cHV0LlRlc3RfcmVzdWx0LnRcbiAgOyByYXcgOiBzdHJpbmdcbiAgfVxuXG50eXBlIG9uZV9ydW4gPVxuICB8IFJlYWNoZWRfd2l0aF9vdXRwdXQgb2Ygb25lX291dHB1dFxuICB8IERpZF9ub3RfcmVhY2hcblxudHlwZSAnYmVoYXZpb3IgaW5uZXIgPVxuICB8IFRlc3QgOlxuICAgICAgeyBleHBlY3RhdGlvbiA6IChbPCBFeHBlY3RhdGlvbi5CZWhhdmlvcl90eXBlLnQgXSBhcyAnYmVoYXZpb3IpIEV4cGVjdGF0aW9uLnRcbiAgICAgIDsgcmVzdWx0cyA6IG9uZV9ydW4gUXVldWUudFxuICAgICAgOyBtdXRhYmxlIHJlYWNoZWRfdGhpc19ydW4gOiBib29sXG4gICAgICB9XG4gICAgICAtPiAnYmVoYXZpb3IgaW5uZXJcblxudHlwZSB0ID0gVCA6ICdiZWhhdmlvciBpbm5lciAtPiB0XG5cbmxldCB0b19jb3JyZWN0aW9uXG4gIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nXG4gIH5jcl9mb3JfbXVsdGlwbGVfb3V0cHV0c1xuICAoVCAoVGVzdCB7IGV4cGVjdGF0aW9uOyByZXN1bHRzOyByZWFjaGVkX3RoaXNfcnVuID0gXyB9KSlcbiAgOiBDb3JyZWN0aW9uLnQgb3B0aW9uXG4gID1cbiAgbGV0IHJlc3VsdHNfbGlzdCA9IFF1ZXVlLnRvX2xpc3QgcmVzdWx0cyBpblxuICBsZXQgdW5yZWFjaGVkX2xpc3QsIG91dHB1dHNfbGlzdCA9XG4gICAgTGlzdC5wYXJ0aXRpb25fbWFwIHJlc3VsdHNfbGlzdCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRGlkX25vdF9yZWFjaCAtPiBGaXJzdCAoKVxuICAgICAgfCBSZWFjaGVkX3dpdGhfb3V0cHV0IG91dHB1dCAtPiBTZWNvbmQgb3V0cHV0KVxuICBpblxuICBsZXQgZGlzdGluY3Rfb3V0cHV0cyA9XG4gICAgKCogQWxsb3cgZGlzdGluY3QgcmF3IG91dHB1dHMgYXMgbG9uZyBhcyB0aGVpciBmb3JtYXR0ZWQgW3Jlc3VsdF1zXG4gICAgICAgYXJlIGNvbnNpZGVyZWQgZXF1aXZhbGVudCBhY2NvcmRpbmcgdG8gW1BheWxvYWRfdHlwZV0uICopXG4gICAgTGlzdC5kZWR1cF9hbmRfc29ydFxuICAgICAgfmNvbXBhcmU6XG4gICAgICAgIChDb21wYXJhYmxlLmxpZnQgfmY6KGZ1biB7IHJlc3VsdDsgXyB9IC0+IHJlc3VsdCkgT3V0cHV0LlRlc3RfcmVzdWx0LmNvbXBhcmUpXG4gICAgICBvdXRwdXRzX2xpc3RcbiAgaW5cbiAgbGV0IHdhc19yZWFjaGVkID0gTGlzdC5pc19lbXB0eSB1bnJlYWNoZWRfbGlzdCBpblxuICBsZXQgcmVhY2hhYmlsaXR5X2JlaGF2aW9yID1cbiAgICBtYXRjaCBleHBlY3RhdGlvbi5iZWhhdmlvciB3aXRoXG4gICAgfCBFeHBlY3QgeyByZWFjaGFiaWxpdHk7IHBheWxvYWQgPSBfOyBvbl91bnJlYWNoYWJsZSA9IF8gfSAtPiByZWFjaGFiaWxpdHlcbiAgICB8IFVucmVhY2hhYmxlIHsgcmVhY2hhYmlsaXR5X29mX2NvcnJlY3RlZCB9IC0+IHJlYWNoYWJpbGl0eV9vZl9jb3JyZWN0ZWRcbiAgaW5cbiAgbGV0IGNvcnJlY3Rpb25fZm9yX3NpbmdsZV9yZXN1bHQgOiBPdXRwdXQuVGVzdF9yZXN1bHQudCAtPiBDb3JyZWN0aW9uLnQgb3B0aW9uXG4gICAgPSBmdW5jdGlvblxuICAgIHwgUGFzcyAtPiBOb25lXG4gICAgfCBGYWlsIHJlY2VpdmVkIC0+IFNvbWUgKE5ld19wYXlsb2FkIChleHBlY3RhdGlvbiwgcmVjZWl2ZWQpKVxuICBpblxuICBtYXRjaCBkaXN0aW5jdF9vdXRwdXRzLCAod2FzX3JlYWNoZWQsIHJlYWNoYWJpbGl0eV9iZWhhdmlvcikgd2l0aFxuICB8IFtdLCAoXywgXykgLT5cbiAgICAoKiBUaGUgdGVzdCB3YXMgbmV2ZXIgcmVhY2hlZCAqKVxuICAgIChtYXRjaCBleHBlY3RhdGlvbi5iZWhhdmlvciB3aXRoXG4gICAgIHwgVW5yZWFjaGFibGUgXyAtPiBOb25lXG4gICAgIHwgRXhwZWN0IF8gYXMgYmVoYXZpb3IgLT5cbiAgICAgICAoKiBFcnJvciBpZiBhbiBleHBlY3QgdGVzdCB3YXMgbm90IHJlYWNoZWQgKilcbiAgICAgICBTb21lIChVbnJlYWNoYWJsZSAoRXhwZWN0YXRpb24ud2l0aF9iZWhhdmlvciBleHBlY3RhdGlvbiBiZWhhdmlvcikpKVxuICB8IFsgeyByZXN1bHQ7IF8gfSBdLCAodHJ1ZSwgXyB8IF8sIENhbl9yZWFjaCkgLT5cbiAgICAoKiBUaGUgdGVzdCBvbmx5IHByb2R1Y2VkIG9uZSB1bmlxdWUgcmVzdWx0IGFuZDpcbiAgICAgICAtIFRoZSB0ZXN0IG5ldmVyIGZhaWxlZCB0byBiZSByZWFjaGVkIE9SXG4gICAgICAgLSBUaGUgdGVzdCBzb21ldGltZXMgZmFpbGVkIHRvIGJlIHJlYWNoZWQsIGJ1dCB0aGUgdGVzdCBpcyBtYXJrZWQgYXMgW0Nhbl9yZWFjaF1cbiAgICAgICAgIChvciByZXdyaXRlcyB0byBvbmUgbWFya2VkIGFzIFtDYW5fcmVhY2hdKSBzbyB0aGF0J3MgT0tcbiAgICAqKVxuICAgIGNvcnJlY3Rpb25fZm9yX3NpbmdsZV9yZXN1bHQgcmVzdWx0XG4gIHwgXyA6OiBfIDo6IF8sIF8gfCBfLCAoZmFsc2UsIE11c3RfcmVhY2gpIC0+XG4gICAgKCogVGhlIHRlc3QgcmVzdWx0cyB3ZXJlIGluY29uc2lzdGVudCBiZWNhdXNlOlxuICAgICAgIC0gVGhlIHRlc3Qgd2FzIHJlYWNoZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgb3V0cHV0cyBPUlxuICAgICAgIC0gVGhlIHRlc3Qgd2FzIHNvbWV0aW1lcyByZWFjaGVkIGFuZCBzb21ldGltZXMgbm90LCBidXQgdGhlIHRlc3QgcmV3cml0ZXMgdG8gYVxuICAgICAgICAgdGVzdCBtYXJrZWQgYXMgW011c3RfcmVhY2hdXG4gICAgKilcbiAgICBsZXQgb3V0cHV0cyA9XG4gICAgICByZXN1bHRzX2xpc3RcbiAgICAgIHw+IExpc3QubWFwIH5mOihmdW5jdGlvblxuICAgICAgICAgICB8IFJlYWNoZWRfd2l0aF9vdXRwdXQgeyByYXc7IF8gfSAtPiByYXdcbiAgICAgICAgICAgfCBEaWRfbm90X3JlYWNoIC0+XG4gICAgICAgICAgICAgUHJpbnRmLnNwcmludGZcbiAgICAgICAgICAgICAgIFwiPGV4cGVjdCB0ZXN0IHJhbiB3aXRob3V0ICVzPlwiXG4gICAgICAgICAgICAgICBleHBlY3RhdGlvbi5pbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlKVxuICAgIGluXG4gICAgY3JfZm9yX211bHRpcGxlX291dHB1dHMgfm91dHB1dF9uYW1lOmV4cGVjdGF0aW9uLmluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2Ugfm91dHB1dHNcbiAgICB8PiBPdXRwdXQuRm9ybWF0dGVyLmFwcGx5IChFeHBlY3RhdGlvbi5mb3JtYXR0ZXIgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgZXhwZWN0YXRpb24pXG4gICAgfD4gT3V0cHV0LmZhaWxcbiAgICB8PiBjb3JyZWN0aW9uX2Zvcl9zaW5nbGVfcmVzdWx0XG47O1xuXG5sZXQgcmVjb3JkX2FuZF9yZXR1cm5fcmVzdWx0XG4gICh0eXBlIGJlaGF2aW9yKVxuICB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZ1xuICB+ZmFpbHVyZV9yZWZcbiAgfnRlc3Rfb3V0cHV0X3Jhd1xuICAoVGVzdCAoeyBleHBlY3RhdGlvbjsgcmVzdWx0czsgcmVhY2hlZF90aGlzX3J1biA9IF8gfSBhcyB0KSA6IGJlaGF2aW9yIGlubmVyKVxuICA9XG4gIGxldCB0ZXN0X291dHB1dCA9XG4gICAgT3V0cHV0LkZvcm1hdHRlci5hcHBseVxuICAgICAgKEV4cGVjdGF0aW9uLmZvcm1hdHRlciB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyBleHBlY3RhdGlvbilcbiAgICAgIHRlc3Rfb3V0cHV0X3Jhd1xuICBpblxuICBsZXQgKHJlc3VsdCA6IE91dHB1dC5UZXN0X3Jlc3VsdC50KSwgKHRhZyA6IFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIudCkgPVxuICAgIG1hdGNoIGV4cGVjdGF0aW9uLmJlaGF2aW9yIHdpdGhcbiAgICB8IFVucmVhY2hhYmxlIF8gLT4gT3V0cHV0LmZhaWwgdGVzdF9vdXRwdXQsIFQgKFRhZyBcIlwiKVxuICAgIHwgRXhwZWN0IHsgcGF5bG9hZCA9IHsgY29udGVudHM7IHRhZyB9OyBvbl91bnJlYWNoYWJsZSA9IF87IHJlYWNoYWJpbGl0eSA9IF8gfSAtPlxuICAgICAgT3V0cHV0LnJlY29uY2lsZSB+ZXhwZWN0ZWRfb3V0cHV0OmNvbnRlbnRzIH50ZXN0X291dHB1dCwgdGFnXG4gIGluXG4gIChtYXRjaCByZXN1bHQgd2l0aFxuICAgfCBGYWlsIF8gLT4gZmFpbHVyZV9yZWYgOj0gdHJ1ZVxuICAgfCBQYXNzIC0+ICgpKTtcbiAgUXVldWUuZW5xdWV1ZSByZXN1bHRzIChSZWFjaGVkX3dpdGhfb3V0cHV0IHsgcmVzdWx0OyByYXcgPSB0ZXN0X291dHB1dF9yYXcgfSk7XG4gIHQucmVhY2hlZF90aGlzX3J1biA8LSB0cnVlO1xuICByZXN1bHQsIHRhZ1xuOztcblxubGV0IG9mX2V4cGVjdGF0aW9uIGV4cGVjdGF0aW9uID1cbiAgVCAoVGVzdCB7IGV4cGVjdGF0aW9uOyByZXN1bHRzID0gUXVldWUuY3JlYXRlICgpOyByZWFjaGVkX3RoaXNfcnVuID0gZmFsc2UgfSlcbjs7XG5cbmxldCByZWNvcmRfZW5kX29mX3J1biB0ID1cbiAgbGV0IChUIChUZXN0IHsgZXhwZWN0YXRpb24gPSBfOyByZXN1bHRzOyByZWFjaGVkX3RoaXNfcnVuIH0pKSA9IHQgaW5cbiAgaWYgbm90IHJlYWNoZWRfdGhpc19ydW4gdGhlbiBRdWV1ZS5lbnF1ZXVlIHJlc3VsdHMgRGlkX25vdF9yZWFjaFxuOztcblxubGV0IHJlY29yZF9yZXN1bHQgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgfmZhaWx1cmVfcmVmIH50ZXN0X291dHB1dF9yYXcgKFQgaW5uZXIpID1cbiAgaWdub3JlXG4gICAgKHJlY29yZF9hbmRfcmV0dXJuX3Jlc3VsdCB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB+ZmFpbHVyZV9yZWYgfnRlc3Rfb3V0cHV0X3JhdyBpbm5lclxuICAgICAgOiBPdXRwdXQuVGVzdF9yZXN1bHQudCAqIFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIudClcbjs7XG5cbm1vZHVsZSBHbG9iYWxfcmVzdWx0c190YWJsZSA9IHN0cnVjdFxuICB0eXBlIG5vZGUgPSB0XG4gIHR5cGUgcG9zdHByb2Nlc3MgPSBub2RlIGxpc3QgV3JpdGVfY29ycmVjdGVkX2ZpbGUuUGF0Y2hfd2l0aF9maWxlX2NvbnRlbnRzLnRcblxuICB0eXBlIGZpbGUgPVxuICAgIHsgZXhwZWN0YXRpb25zIDogbm9kZSBIYXNodGJsLk0oRXhwZWN0YXRpb25faWQpLnRcbiAgICA7IHBvc3Rwcm9jZXNzIDogcG9zdHByb2Nlc3NcbiAgICB9XG5cbiAgbGV0IGdsb2JhbF9yZXN1bHRzX3RhYmxlIDogZmlsZSBIYXNodGJsLk0oU3RyaW5nKS50ID0gSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBTdHJpbmcpXG5cbiAgbGV0IGZpbmRfdGVzdCB+YWJzb2x1dGVfZmlsZW5hbWUgfih0ZXN0X2lkIDogRXhwZWN0YXRpb25faWQudCkgPVxuICAgIEhhc2h0YmwuZmluZCBnbG9iYWxfcmVzdWx0c190YWJsZSBhYnNvbHV0ZV9maWxlbmFtZVxuICAgIHw+IE9wdGlvbi5iaW5kIH5mOihmdW4geyBleHBlY3RhdGlvbnM7IF8gfSAtPiBIYXNodGJsLmZpbmQgZXhwZWN0YXRpb25zIHRlc3RfaWQpXG4gICAgfD4gT3B0aW9uLnZhbHVlX2V4blxuICAgICAgICAgfmVycm9yOlxuICAgICAgICAgICAoRXJyb3Iub2Zfc3RyaW5nXG4gICAgICAgICAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICAgICBcIkludGVybmFsIGV4cGVjdCB0ZXN0IGJ1ZzogY291bGQgbm90IGZpbmQgdGVzdFxcbkZpbGU6ICVzXFxuSUQ6ICAgJWRcIlxuICAgICAgICAgICAgICAgICBhYnNvbHV0ZV9maWxlbmFtZVxuICAgICAgICAgICAgICAgICAoRXhwZWN0YXRpb25faWQudG9faW50X2V4biB0ZXN0X2lkKSkpXG4gIDs7XG5cbiAgbGV0IGluaXRpYWxpemVfYW5kX3JlZ2lzdGVyX3Rlc3RzIH5hYnNvbHV0ZV9maWxlbmFtZSB0ZXN0cyBwb3N0cHJvY2VzcyA9XG4gICAgbGV0IHRlc3RzX2FzX2luX3RhYmxlID0gUXVldWUuY3JlYXRlICgpIGluXG4gICAgSGFzaHRibC51cGRhdGUgZ2xvYmFsX3Jlc3VsdHNfdGFibGUgYWJzb2x1dGVfZmlsZW5hbWUgfmY6KGZ1biBmaWxlIC0+XG4gICAgICBsZXQgZmlsZSA9XG4gICAgICAgIE9wdGlvbi52YWx1ZVxuICAgICAgICAgIGZpbGVcbiAgICAgICAgICB+ZGVmYXVsdDp7IGV4cGVjdGF0aW9ucyA9IEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgRXhwZWN0YXRpb25faWQpOyBwb3N0cHJvY2VzcyB9XG4gICAgICBpblxuICAgICAgbGV0IHRlc3RzID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBFeHBlY3RhdGlvbl9pZCkgdGVzdHMgaW5cbiAgICAgIEhhc2h0YmwubWVyZ2VfaW50b1xuICAgICAgICB+c3JjOnRlc3RzXG4gICAgICAgIH5kc3Q6ZmlsZS5leHBlY3RhdGlvbnNcbiAgICAgICAgfmY6KGZ1biB+a2V5OnRlc3RfaWQgbmV3X3Rlc3QgZXhpc3RpbmdfdGVzdCAtPlxuICAgICAgICBsZXQgKFQgKFRlc3QgdCkgYXMgdGVzdCkgPSBPcHRpb24udmFsdWUgZXhpc3RpbmdfdGVzdCB+ZGVmYXVsdDpuZXdfdGVzdCBpblxuICAgICAgICB0LnJlYWNoZWRfdGhpc19ydW4gPC0gZmFsc2U7XG4gICAgICAgIFF1ZXVlLmVucXVldWUgdGVzdHNfYXNfaW5fdGFibGUgKHRlc3RfaWQsIHRlc3QpO1xuICAgICAgICBTZXRfdG8gdGVzdCk7XG4gICAgICBmaWxlKTtcbiAgICBRdWV1ZS50b19saXN0IHRlc3RzX2FzX2luX3RhYmxlXG4gIDs7XG5cbiAgbGV0IHByb2Nlc3NfZWFjaF9maWxlIH5mID1cbiAgICBnbG9iYWxfcmVzdWx0c190YWJsZVxuICAgIHw+IEhhc2h0YmwudG9fYWxpc3RcbiAgICB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6KENvbXBhcmFibGUubGlmdCB+Zjpmc3QgU3RyaW5nLmNvbXBhcmUpXG4gICAgfD4gTGlzdC5tYXAgfmY6KGZ1biAoZmlsZW5hbWUsIHsgZXhwZWN0YXRpb25zOyBwb3N0cHJvY2VzcyB9KSAtPlxuICAgICAgICAgbGV0IHRlc3Rfbm9kZXMgPSBIYXNodGJsLmRhdGEgZXhwZWN0YXRpb25zIGluXG4gICAgICAgICBmIH5maWxlbmFtZSB+dGVzdF9ub2RlcyB+cG9zdHByb2Nlc3MpXG4gIDs7XG5lbmRcblxubW9kdWxlIENyZWF0ZSA9IHN0cnVjdFxuICBsZXQgZXhwZWN0IH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IH5ub2RlX2xvYyB+bG9jYXRlZF9wYXlsb2FkID1cbiAgICBvZl9leHBlY3RhdGlvbiAoRXhwZWN0YXRpb24uZXhwZWN0IH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IH5ub2RlX2xvYyB+bG9jYXRlZF9wYXlsb2FkKVxuICA7O1xuXG4gIGxldCBleHBlY3RfZXhhY3QgfmZvcm1hdHRpbmdfZmxleGliaWxpdHkgfm5vZGVfbG9jIH5sb2NhdGVkX3BheWxvYWQgPVxuICAgIG9mX2V4cGVjdGF0aW9uXG4gICAgICAoRXhwZWN0YXRpb24uZXhwZWN0X2V4YWN0IH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IH5ub2RlX2xvYyB+bG9jYXRlZF9wYXlsb2FkKVxuICA7O1xuXG4gIGxldCBleHBlY3RfdW5yZWFjaGFibGUgfm5vZGVfbG9jID1cbiAgICBvZl9leHBlY3RhdGlvbiAoRXhwZWN0YXRpb24uZXhwZWN0X3VucmVhY2hhYmxlIH5ub2RlX2xvYylcbiAgOztcbmVuZFxuXG5tb2R1bGUgRm9yX21sdCA9IHN0cnVjdFxuICBsZXQgbG9jIChUIChUZXN0IHsgZXhwZWN0YXRpb24gPSB7IHBvc2l0aW9uOyBfIH07IHJlc3VsdHMgPSBfOyByZWFjaGVkX3RoaXNfcnVuID0gXyB9KSkgPVxuICAgIEV4cGVjdGF0aW9uLkluc2VydF9sb2MubG9jIHBvc2l0aW9uXG4gIDs7XG5cbiAgbGV0IGV4cGVjdGF0aW9uX29mX3QgKFQgKFRlc3QgeyBleHBlY3RhdGlvbjsgcmVzdWx0cyA9IF87IHJlYWNoZWRfdGhpc19ydW4gPSBfIH0pKSA9XG4gICAgbWF0Y2ggZXhwZWN0YXRpb24uYmVoYXZpb3Igd2l0aFxuICAgIHwgRXhwZWN0IHsgcGF5bG9hZCA9IHsgY29udGVudHM7IHRhZyA9IF8gfTsgb25fdW5yZWFjaGFibGUgPSBfOyByZWFjaGFiaWxpdHkgPSBfIH0gLT5cbiAgICAgIFNvbWUgY29udGVudHNcbiAgICB8IFVucmVhY2hhYmxlIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCByZWNvcmRfYW5kX3JldHVybl9udW1iZXJfb2ZfbGluZXNfaW5fY29ycmVjdGlvblxuICAgIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nXG4gICAgfmZhaWx1cmVfcmVmXG4gICAgfnRlc3Rfb3V0cHV0X3Jhd1xuICAgIChUIChUZXN0IGlubmVyKSlcbiAgICA9XG4gICAgbWF0Y2hcbiAgICAgIHJlY29yZF9hbmRfcmV0dXJuX3Jlc3VsdFxuICAgICAgICB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZ1xuICAgICAgICB+ZmFpbHVyZV9yZWZcbiAgICAgICAgfnRlc3Rfb3V0cHV0X3Jhd1xuICAgICAgICAoVGVzdCBpbm5lcilcbiAgICB3aXRoXG4gICAgfCBGYWlsIGNvbnRlbnRzLCB0YWcgLT5cbiAgICAgIGxldCBjb3JyZWN0aW9uID1cbiAgICAgICAgT3V0cHV0LnRvX2Zvcm1hdHRlZF9wYXlsb2FkIH50YWcgY29udGVudHMgfD4gT3V0cHV0LlBheWxvYWQudG9fc291cmNlX2NvZGVfc3RyaW5nXG4gICAgICBpblxuICAgICAgU29tZSAoU3RyaW5nLmNvdW50IH5mOihDaGFyLmVxdWFsICdcXG4nKSBjb3JyZWN0aW9uICsgMSlcbiAgICB8IFBhc3MsIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCB0b19kaWZmcyB+Y3JfZm9yX211bHRpcGxlX291dHB1dHMgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgfm9yaWdpbmFsX2ZpbGVfY29udGVudHMgdCA9XG4gICAgbWF0Y2ggdG9fY29ycmVjdGlvbiB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB+Y3JfZm9yX211bHRpcGxlX291dHB1dHMgdCB3aXRoXG4gICAgfCBOb25lIC0+IFtdXG4gICAgfCBTb21lIGNvcnJlY3Rpb24gLT5cbiAgICAgIENvcnJlY3Rpb24udG9fZGlmZnMgY29ycmVjdGlvbiB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB+b3JpZ2luYWxfZmlsZV9jb250ZW50c1xuICA7O1xuZW5kXG4iLCJvcGVuISBCYXNlXG5cbmxldCBjdXJyZW50ID0gcmVmIE5vbmVcblxubGV0IHNldCB+ZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdCA9XG4gIG1hdGNoICFjdXJyZW50IHdpdGhcbiAgfCBOb25lIC0+IGN1cnJlbnQgOj0gU29tZSBmaWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290XG4gIHwgU29tZSBjdXJyZW50IC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJFeHBlY3RfdGVzdF9jb2xsZWN0b3Iuc2V0OiB0aGVyZSBpcyBhbHJlYWR5IGFuIGFjdGl2ZSBmaWxlXCJcbiAgICAgICAgIFsgXCJvbGRfZmlsZVwiLCBzZXhwX29mX3N0cmluZyBjdXJyZW50XG4gICAgICAgICA7IFwibmV3X2ZpbGVcIiwgc2V4cF9vZl9zdHJpbmcgZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdFxuICAgICAgICAgXSlcbjs7XG5cbmxldCB1bnNldCAoKSA9XG4gIG1hdGNoICFjdXJyZW50IHdpdGhcbiAgfCBTb21lIF8gLT4gY3VycmVudCA6PSBOb25lXG4gIHwgTm9uZSAtPlxuICAgIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIkV4cGVjdF90ZXN0X2NvbGxlY3Rvci51bnNldDogdGhlcmUgaXMgbm8gYWN0aXZlIGZpbGVcIiBbXSlcbjs7XG5cbmxldCBnZXQgKCkgPVxuICBtYXRjaCAhY3VycmVudCB3aXRoXG4gIHwgU29tZSBmbiAtPiBmblxuICB8IE5vbmUgLT4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiRXhwZWN0X3Rlc3RfY29sbGVjdG9yLmdldDogdGhlcmUgaXMgbm8gYWN0aXZlIGZpbGVcIiBbXSlcbjs7XG5cbmxldCBpbml0aWFsX2RpciA9XG4gIGxldCBkaXJfb3JfZXJyb3IgPSBPcl9lcnJvci50cnlfd2l0aCB+YmFja3RyYWNlOnRydWUgU3RkbGliLlN5cy5nZXRjd2QgaW5cbiAgbGF6eSAoT3JfZXJyb3Iub2tfZXhuIGRpcl9vcl9lcnJvcilcbjs7XG5cbmxldCBhYnNvbHV0ZV9wYXRoIGZpbGUgPVxuICBpZiBTdGRsaWIuRmlsZW5hbWUuaXNfcmVsYXRpdmUgZmlsZVxuICB0aGVuIFN0ZGxpYi5GaWxlbmFtZS5jb25jYXQgKExhenkuZm9yY2UgaW5pdGlhbF9kaXIpIGZpbGVcbiAgZWxzZSBmaWxlXG47O1xuXG5sZXQgdmVyaWZ5X3RoYXRfZmlsZV9pc19jdXJyZW50X2V4biB+bGluZV9udW1iZXIgfmZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3QgPVxuICBsZXQgcmVnaXN0ZXJpbmdfdGVzdHNfZm9yID0gZ2V0ICgpIGluXG4gIGlmIG5vdCAoU3RyaW5nLmVxdWFsIGZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3QgcmVnaXN0ZXJpbmdfdGVzdHNfZm9yKVxuICB0aGVuXG4gICAgUHJpbnRmLmtzcHJpbnRmXG4gICAgICBmYWlsd2l0aFxuICAgICAgXCJUcnlpbmcgdG8gcnVuIGFuIGV4cGVjdCB0ZXN0IGZyb20gdGhlIHdyb25nIGZpbGUuXFxuXFxcbiAgICAgICAtIHRlc3QgZGVjbGFyZWQgYXQgJXM6JWRcXG5cXFxuICAgICAgIC0gdHJ5aW5nIHRvIHJ1biBpdCBmcm9tICVzXFxuXCJcbiAgICAgIGZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3RcbiAgICAgIGxpbmVfbnVtYmVyXG4gICAgICByZWdpc3RlcmluZ190ZXN0c19mb3JcbiAgZWxzZSAoKVxuOztcbiIsIm9wZW4hIEJhc2Vcbm9wZW4gVHlwZXNcblxuKCogW1NoYXJlZF0gYW5kIFtDb25maWd1cmVkXSBwcmltYXJpbHkgY29udGFpbiBib2lsZXJwbGF0ZSBpbnZvbHZpbmcgdGhlIEZGSSBhbmQgcHJpbnRpbmdcbiAgIFtDUl1zLiBUaGUgaW50ZXJlc3RpbmcgbG9naWMgaXMgaW4gW01ha2VdLiAqKVxuXG5tb2R1bGUgU2hhcmVkIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBzcmNfZmlsZW5hbWUgOiB0IC0+IHN0cmluZ1xuICB2YWwgb3V0cHV0X2ZpbGUgOiB0IC0+IHN0cmluZ1xuICB2YWwgZmFpbHVyZV9yZWYgOiB0IC0+IGJvb2wgcmVmXG4gIHZhbCBzZXRfdXBfYmxvY2sgOiBzdHJpbmcgLT4gdFxuICB2YWwgcmVhZF90ZXN0X291dHB1dF91bnNhbml0aXplZCA6IHQgLT4gc3RyaW5nXG4gIHZhbCBmbHVzaCA6IHVuaXQgLT4gdW5pdFxuICB2YWwgY2xlYW5fdXBfYmxvY2sgOiB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgc3JjX2ZpbGVuYW1lIDogc3RyaW5nXG4gICAgOyBvdXRwdXRfZmlsZSA6IHN0cmluZ1xuICAgIDsgZmFpbCA6IGJvb2wgcmVmXG4gICAgOyB0ZXN0X291dHB1dF9yZWFkZXIgOiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIDsgdGVzdF9vdXRwdXRfd3JpdGVyIDogU3RkbGliLm91dF9jaGFubmVsXG4gICAgOyBvbGRfb2Zmc2V0IDogaW50IHJlZlxuICAgIH1cblxuICBsZXQgc3JjX2ZpbGVuYW1lIHsgc3JjX2ZpbGVuYW1lOyBfIH0gPSBzcmNfZmlsZW5hbWVcbiAgbGV0IG91dHB1dF9maWxlIHsgb3V0cHV0X2ZpbGU7IF8gfSA9IG91dHB1dF9maWxlXG4gIGxldCBmYWlsdXJlX3JlZiB7IGZhaWw7IF8gfSA9IGZhaWxcblxuICBleHRlcm5hbCByZWRpcmVjdF9zdGRvdXRcbiAgICA6ICBvdXRwdXQ6U3RkbGliLm91dF9jaGFubmVsXG4gICAgLT4gc3Rkb3V0OlN0ZGxpYi5vdXRfY2hhbm5lbFxuICAgIC0+IHN0ZGVycjpTdGRsaWIub3V0X2NoYW5uZWxcbiAgICAtPiB1bml0XG4gICAgPSBcInBweF9leHBlY3RfcnVudGltZV9iZWZvcmVfdGVzdFwiXG5cbiAgZXh0ZXJuYWwgcmVzdG9yZV9zdGRvdXRcbiAgICA6ICBzdGRvdXQ6U3RkbGliLm91dF9jaGFubmVsXG4gICAgLT4gc3RkZXJyOlN0ZGxpYi5vdXRfY2hhbm5lbFxuICAgIC0+IHVuaXRcbiAgICA9IFwicHB4X2V4cGVjdF9ydW50aW1lX2FmdGVyX3Rlc3RcIlxuXG4gIGV4dGVybmFsIHBvc19vdXQgOiBTdGRsaWIub3V0X2NoYW5uZWwgLT4gaW50ID0gXCJwcHhfZXhwZWN0X3J1bnRpbWVfb3V0X2NoYW5uZWxfcG9zaXRpb25cIlxuICBleHRlcm5hbCBmbHVzaF9zdHVicyA6IHVuaXQgLT4gdW5pdCA9IFwicHB4X2V4cGVjdF9ydW50aW1lX2ZsdXNoX3N0dWJzX3N0cmVhbXNcIlxuXG4gICgqIFNhdmUgc3RkIGZpbGUgZGVzY3JpcHRvcnMsIG9wZW4gYSB0ZW1wIGZpbGUgZm9yIHRlc3Qgb3V0cHV0LCBhbmQgcmVyb3V0ZSBzdGRvdXQgYW5kXG4gICAgIHN0ZGVyciB0aGVyZS4gKilcbiAgbGV0IHNldF91cF9ibG9jayBzcmNfZmlsZW5hbWUgPVxuICAgIGxldCBvdXRwdXRfZmlsZSA9XG4gICAgICBDdXJyZW50X2ZpbGUuYWJzb2x1dGVfcGF0aCAoU3RkbGliLkZpbGVuYW1lLnRlbXBfZmlsZSBcImV4cGVjdC10ZXN0XCIgXCJvdXRwdXRcIilcbiAgICBpblxuICAgIGxldCB0ZXN0X291dHB1dF93cml0ZXIgPVxuICAgICAgU3RkbGliLm9wZW5fb3V0X2dlbiBbIE9wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0IF0gMG82NDQgb3V0cHV0X2ZpbGVcbiAgICBpblxuICAgIGxldCB0ZXN0X291dHB1dF9yZWFkZXIgPSBTdGRsaWIub3Blbl9pbiBvdXRwdXRfZmlsZSBpblxuICAgIHJlZGlyZWN0X3N0ZG91dCB+b3V0cHV0OnRlc3Rfb3V0cHV0X3dyaXRlciB+c3Rkb3V0OlN0ZGxpYi5zdGRvdXQgfnN0ZGVycjpTdGRsaWIuc3RkZXJyO1xuICAgIHsgc3JjX2ZpbGVuYW1lXG4gICAgOyBvdXRwdXRfZmlsZVxuICAgIDsgdGVzdF9vdXRwdXRfcmVhZGVyXG4gICAgOyB0ZXN0X291dHB1dF93cml0ZXJcbiAgICA7IG9sZF9vZmZzZXQgPSByZWYgMFxuICAgIDsgZmFpbCA9IHJlZiBmYWxzZVxuICAgIH1cbiAgOztcblxuICAoKiBDbG9zZSB0aGUgdGVtcCBmaWxlIGFuZCByZXN0b3JlIHN0ZG91dCBhbmQgc3RkZXJyLiAqKVxuICBsZXQgY2xlYW5fdXBfYmxvY2sgeyBvdXRwdXRfZmlsZTsgdGVzdF9vdXRwdXRfcmVhZGVyOyB0ZXN0X291dHB1dF93cml0ZXI7IF8gfSA9XG4gICAgU3RkbGliLmNsb3NlX2luIHRlc3Rfb3V0cHV0X3JlYWRlcjtcbiAgICByZXN0b3JlX3N0ZG91dCB+c3Rkb3V0OlN0ZGxpYi5zdGRvdXQgfnN0ZGVycjpTdGRsaWIuc3RkZXJyO1xuICAgIFN0ZGxpYi5jbG9zZV9vdXQgdGVzdF9vdXRwdXRfd3JpdGVyO1xuICAgIFN0ZGxpYi5TeXMucmVtb3ZlIG91dHB1dF9maWxlXG4gIDs7XG5cbiAgbGV0IGZsdXNoICgpID1cbiAgICBTdGRsaWIuRm9ybWF0LnBwX3ByaW50X2ZsdXNoIFN0ZGxpYi5Gb3JtYXQuc3RkX2Zvcm1hdHRlciAoKTtcbiAgICBTdGRsaWIuRm9ybWF0LnBwX3ByaW50X2ZsdXNoIFN0ZGxpYi5Gb3JtYXQuZXJyX2Zvcm1hdHRlciAoKTtcbiAgICBTdGRsaWIuZmx1c2ggU3RkbGliLnN0ZG91dDtcbiAgICBTdGRsaWIuZmx1c2ggU3RkbGliLnN0ZGVycjtcbiAgICBmbHVzaF9zdHVicyAoKVxuICA7O1xuXG4gIGxldCByZWFkX3Rlc3Rfb3V0cHV0X3Vuc2FuaXRpemVkIHsgdGVzdF9vdXRwdXRfcmVhZGVyOyBvbGRfb2Zmc2V0OyBfIH0gPVxuICAgIGxldCBuZXdfb2Zmc2V0ID1cbiAgICAgIGZsdXNoICgpO1xuICAgICAgcG9zX291dCBTdGRsaWIuc3Rkb3V0XG4gICAgaW5cbiAgICBsZXQgbGVuID0gbmV3X29mZnNldCAtICFvbGRfb2Zmc2V0IGluXG4gICAgb2xkX29mZnNldCA6PSBuZXdfb2Zmc2V0O1xuICAgIFN0ZGxpYi5yZWFsbHlfaW5wdXRfc3RyaW5nIHRlc3Rfb3V0cHV0X3JlYWRlciBsZW5cbiAgOztcbmVuZFxuXG5tb2R1bGUgQ29uZmlndXJlZCAoQyA6IEV4cGVjdF90ZXN0X2NvbmZpZ190eXBlcy5TKSA9IHN0cnVjdFxuICBsZXQgY3JfcHJlZml4ID1cbiAgICBtYXRjaCBDLnVwb25fdW5yZWxlYXNhYmxlX2lzc3VlIHdpdGhcbiAgICB8IGBDUiAtPiBcIkNSIFwiXG4gICAgfCBgV2FybmluZ19mb3JfY29sbGVjdG9yX3Rlc3RpbmcgLT4gXCJcIlxuICA7O1xuXG4gIGxldCBjcl9mb3JfYmFja3RyYWNlID1cbiAgICBQcmludGYuc3ByaW50ZlxuICAgICAge3woKiAlc2V4cGVjdF90ZXN0X2NvbGxlY3RvcjogVGhpcyB0ZXN0IGV4cGVjdGF0aW9uIGFwcGVhcnMgdG8gY29udGFpbiBhIGJhY2t0cmFjZS5cbiAgIFRoaXMgaXMgc3Ryb25nbHkgZGlzY291cmFnZWQgYXMgYmFja3RyYWNlcyBhcmUgZnJhZ2lsZS5cbiAgIFBsZWFzZSBjaGFuZ2UgdGhpcyB0ZXN0IHRvIG5vdCBpbmNsdWRlIGEgYmFja3RyYWNlLiAqKXx9XG4gICAgICBjcl9wcmVmaXhcbiAgOztcblxuICBsZXQgY3JfZm9yX211bHRpcGxlX291dHB1dHMgfm91dHB1dF9uYW1lIH5vdXRwdXRzID1cbiAgICBsZXQgY3JfYm9keSA9XG4gICAgICBQcmludGYuc3ByaW50ZiBcIlRlc3QgcmFuIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50ICVzc1wiIG91dHB1dF9uYW1lXG4gICAgaW5cbiAgICBsZXQgY3IgPSBQcmludGYuc3ByaW50ZiBcIigqICVzZXhwZWN0X3Rlc3Q6ICVzICopXCIgY3JfcHJlZml4IGNyX2JvZHkgaW5cbiAgICBsZXQgbnVtX291dHB1dHMgPSBMaXN0Lmxlbmd0aCBvdXRwdXRzIGluXG4gICAgbGV0IGhlYWRlciBpbmRleCA9XG4gICAgICBsZXQgaGVhZGVyID0gUHJpbnRmLnNwcmludGYgXCI9PT0gT3V0cHV0ICVkIC8gJWQgPT09XCIgKGluZGV4ICsgMSkgbnVtX291dHB1dHMgaW5cbiAgICAgIGxldCBwYWRfbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCBjciAtIFN0cmluZy5sZW5ndGggaGVhZGVyIGluXG4gICAgICBpZiBwYWRfbGVuZ3RoIDw9IDBcbiAgICAgIHRoZW4gaGVhZGVyXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxwYWQgPSBTdHJpbmcubWFrZSAocGFkX2xlbmd0aCAvIDIpICc9JyBpblxuICAgICAgICBsZXQgcnBhZCA9IFN0cmluZy5tYWtlIChwYWRfbGVuZ3RoIC0gKHBhZF9sZW5ndGggLyAyKSkgJz0nIGluXG4gICAgICAgIFByaW50Zi5zcHJpbnRmIFwiJXMlcyVzXCIgbHBhZCBoZWFkZXIgcnBhZClcbiAgICBpblxuICAgIGxldCBvdXRwdXRzX3dpdGhfaGVhZGVycyA9XG4gICAgICBMaXN0LmNvbmNhdF9tYXBpIG91dHB1dHMgfmY6KGZ1biBpbmRleCBvdXRwdXQgLT4gWyBoZWFkZXIgaW5kZXg7IG91dHB1dCBdKVxuICAgIGluXG4gICAgU3RyaW5nLmNvbmNhdCAoY3IgOjogb3V0cHV0c193aXRoX2hlYWRlcnMpIH5zZXA6XCJcXG5cIlxuICA7O1xuXG4gIGxldCBzYW5pdGl6ZSA9IEMuc2FuaXRpemVcblxuICBsZXQgY2hlY2tfZm9yX2JhY2t0cmFjZXMgcyA9XG4gICAgaWYgTGlzdC5leGlzdHNcbiAgICAgICAgIH5mOihmdW4gc3Vic3RyaW5nIC0+IFN0cmluZy5pc19zdWJzdHJpbmcgfnN1YnN0cmluZyBzKVxuICAgICAgICAgWyBcIlJhaXNlZCBhdCBcIjsgXCJDYWxsZWQgZnJvbSBcIjsgXCJSYWlzZWQgYnkgcHJpbWl0aXZlIG9wZXJhdGlvbiBcIiBdXG4gICAgdGhlbiBjcl9mb3JfYmFja3RyYWNlIF4gXCJcXG5cXG5cIiBeIHNcbiAgICBlbHNlIHNcbiAgOztcblxuICBsZXQgZHVtcF9iYWNrdHJhY2UgcG9zc2libGVfZXhuID1cbiAgICBtYXRjaCBDLnJ1biBwb3NzaWJsZV9leG4gd2l0aFxuICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgbGV0IGJ0ID0gU3RkbGliLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBsZXQgZXhuX3N0cmluZyA9XG4gICAgICAgIHRyeSBFeG4udG9fc3RyaW5nIGV4biB3aXRoXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGxldCBuYW1lID1cbiAgICAgICAgICAgIFN0ZGxpYi5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCBleG5cbiAgICAgICAgICAgIHw+IFN0ZGxpYi5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgICBpblxuICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiKFxcXCIlcyhDYW5ub3QgcHJpbnQgbW9yZSBkZXRhaWxzLCBFeG4udG9fc3RyaW5nIGZhaWxlZClcXFwiKVwiIG5hbWVcbiAgICAgIGluXG4gICAgICBTb21lXG4gICAgICAgIChtYXRjaCBTdGRsaWIuUHJpbnRleGMucmF3X2JhY2t0cmFjZV90b19zdHJpbmcgYnQgd2l0aFxuICAgICAgICAgfCBcIlwiIC0+IGV4bl9zdHJpbmdcbiAgICAgICAgIHwgYnQgLT4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuXCIgWyBjcl9mb3JfYmFja3RyYWNlOyBleG5fc3RyaW5nOyBidCBdKVxuICAgIHwgXyAtPiBOb25lXG4gIDs7XG5lbmRcblxuKCogVGhlIGV4cGVjdCB0ZXN0IGN1cnJlbnRseSBiZWluZyBleGVjdXRlZCBhbmQgc29tZSBpbmZvIHdlIHByaW50IGlmIHRoZSBwcm9ncmFtXG4gICBjcmFzaGVzIGluIHRoZSBtaWRkbGUgb2YgYSB0ZXN0LiAqKVxubW9kdWxlIEN1cnJlbnRfdGVzdCA6IHNpZ1xuICB0eXBlIHQgPVxuICAgIHsgbGluZV9udW1iZXIgOiBpbnRcbiAgICA7IGJhc2VuYW1lIDogc3RyaW5nXG4gICAgOyBsb2NhdGlvbiA6IENvbXBhY3RfbG9jLnRcbiAgICA7IHRlc3RfYmxvY2sgOiBTaGFyZWQudFxuICAgIH1cblxuICB2YWwgc2V0IDogdCAtPiB1bml0XG4gIHZhbCB1bnNldCA6IHVuaXQgLT4gdW5pdFxuICB2YWwgaXNfcnVubmluZyA6IHVuaXQgLT4gYm9vbFxuICB2YWwgY3VycmVudF90ZXN0IDogdW5pdCAtPiBTaGFyZWQudCBvcHRpb25cbiAgdmFsIGN1cnJlbnRfdGVzdF9leG4gOiB1bml0IC0+IFNoYXJlZC50XG4gIHZhbCBpdGVyIDogZjoodCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBhc3NlcnRfbm9fdGVzdF9ydW5uaW5nIDogYmFzZW5hbWU6c3RyaW5nIC0+IGxpbmVfbnVtYmVyOmludCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGxpbmVfbnVtYmVyIDogaW50XG4gICAgOyBiYXNlbmFtZSA6IHN0cmluZ1xuICAgIDsgbG9jYXRpb24gOiBDb21wYWN0X2xvYy50XG4gICAgOyB0ZXN0X2Jsb2NrIDogU2hhcmVkLnRcbiAgICB9XG5cbiAgbGV0IHRlc3RfaXNfcnVubmluZyA6IHQgb3B0aW9uIHJlZiA9IHJlZiBOb25lXG4gIGxldCBzZXQgdCA9IHRlc3RfaXNfcnVubmluZyA6PSBTb21lIHRcbiAgbGV0IHVuc2V0ICgpID0gdGVzdF9pc19ydW5uaW5nIDo9IE5vbmVcbiAgbGV0IGlzX3J1bm5pbmcgKCkgPSBPcHRpb24uaXNfc29tZSAhdGVzdF9pc19ydW5uaW5nXG5cbiAgbGV0IGN1cnJlbnRfdGVzdCAoKSA9XG4gICAgT3B0aW9uLm1hcCAhdGVzdF9pc19ydW5uaW5nIH5mOihmdW4geyB0ZXN0X2Jsb2NrOyBfIH0gLT4gdGVzdF9ibG9jaylcbiAgOztcblxuICBsZXQgY3VycmVudF90ZXN0X2V4biAoKSA9IE9wdGlvbi52YWx1ZV9leG4gKGN1cnJlbnRfdGVzdCAoKSlcbiAgbGV0IGl0ZXIgfmYgPSBPcHRpb24uaXRlciAhdGVzdF9pc19ydW5uaW5nIH5mXG5cbiAgbGV0IGFzc2VydF9ub190ZXN0X3J1bm5pbmcgfmJhc2VuYW1lIH5saW5lX251bWJlciA9XG4gICAgaXRlclxuICAgICAgfmY6XG4gICAgICAgIChmdW5cbiAgICAgICAgICB7IGxpbmVfbnVtYmVyID0gb3V0ZXJfbGluZV9udW1iZXJcbiAgICAgICAgICA7IGJhc2VuYW1lID0gb3V0ZXJfYmFzZW5hbWVcbiAgICAgICAgICA7IGxvY2F0aW9uID0gX1xuICAgICAgICAgIDsgdGVzdF9ibG9jayA9IF9cbiAgICAgICAgICB9XG4gICAgICAgICAgLT5cbiAgICAgIGxldCBzZXhwX2hlcmUgfmJhc2VuYW1lIH5saW5lX251bWJlciA6IFNleHAudCA9XG4gICAgICAgIExpc3RcbiAgICAgICAgICBbIExpc3QgWyBBdG9tIFwiZmlsZVwiOyBzZXhwX29mX3N0cmluZyBiYXNlbmFtZSBdXG4gICAgICAgICAgOyBMaXN0IFsgQXRvbSBcImxpbmVcIjsgc2V4cF9vZl9pbnQgbGluZV9udW1iZXIgXVxuICAgICAgICAgIF1cbiAgICAgIGluXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJFeHBlY3RfdGVzdF9ydW50aW1lOiByZWFjaGVkIG9uZSBbbGV0JWV4cGVjdF90ZXN0XSBmcm9tIGFub3RoZXIuIE5lc3RpbmcgXFxcbiAgICAgICAgICAgIGV4cGVjdFxcblxcXG4gICAgICAgICAgICB0ZXN0cyBpcyBwcm9oaWJpdGVkLlwiXG4gICAgICAgICAgIFsgKCBcIm91dGVyX3Rlc3RcIlxuICAgICAgICAgICAgICwgc2V4cF9oZXJlIH5iYXNlbmFtZTpvdXRlcl9iYXNlbmFtZSB+bGluZV9udW1iZXI6b3V0ZXJfbGluZV9udW1iZXIgKVxuICAgICAgICAgICA7IFwiaW5uZXJfdGVzdFwiLCBzZXhwX2hlcmUgfmJhc2VuYW1lIH5saW5lX251bWJlclxuICAgICAgICAgICBdKSlcbiAgOztcbmVuZFxuXG4oKiBUaGUgbWFpbiB0ZXN0aW5nIGZ1bmN0aW9ucyBvZiBhIHRlc3QgYmxvY2ssIHdoaWNoIGRlcGVuZCBvbiBjb25maWd1cmF0aW9ucy4gKilcbm1vZHVsZSBNYWtlIChDIDogRXhwZWN0X3Rlc3RfY29uZmlnX3R5cGVzLlMpID0gc3RydWN0XG4gIG1vZHVsZSBDb25maWd1cmVkID0gQ29uZmlndXJlZCAoQylcblxuICBsZXQgcmVhZF90ZXN0X291dHB1dF9ub19iYWNrdHJhY2VfY2hlY2sgKCkgPVxuICAgIEN1cnJlbnRfdGVzdC5jdXJyZW50X3Rlc3RfZXhuICgpXG4gICAgfD4gU2hhcmVkLnJlYWRfdGVzdF9vdXRwdXRfdW5zYW5pdGl6ZWRcbiAgICB8PiBDb25maWd1cmVkLnNhbml0aXplXG4gIDs7XG5cbiAgbGV0IHJlYWRfdGVzdF9vdXRwdXRfc2FuaXRpemVkX2FuZF9jaGVja2VkICgpID1cbiAgICByZWFkX3Rlc3Rfb3V0cHV0X25vX2JhY2t0cmFjZV9jaGVjayAoKSB8PiBDb25maWd1cmVkLmNoZWNrX2Zvcl9iYWNrdHJhY2VzXG4gIDs7XG5cbiAgbGV0IHJ1bl90ZXN0X2lubmVyIH50ZXN0X2lkIH50ZXN0X291dHB1dF9yYXcgdCA9XG4gICAgVGVzdF9ub2RlLnJlY29yZF9yZXN1bHRcbiAgICAgIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nOkV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuZGVmYXVsdFxuICAgICAgfmZhaWx1cmVfcmVmOihTaGFyZWQuZmFpbHVyZV9yZWYgdClcbiAgICAgIH50ZXN0X291dHB1dF9yYXdcbiAgICAgIChUZXN0X25vZGUuR2xvYmFsX3Jlc3VsdHNfdGFibGUuZmluZF90ZXN0XG4gICAgICAgICB+YWJzb2x1dGVfZmlsZW5hbWU6KFNoYXJlZC5zcmNfZmlsZW5hbWUgdClcbiAgICAgICAgIH50ZXN0X2lkKVxuICA7O1xuXG4gIGxldCBydW5fdGVzdCB+dGVzdF9pZCA9XG4gICAgQ3VycmVudF90ZXN0LmN1cnJlbnRfdGVzdF9leG4gKClcbiAgICB8PiBydW5fdGVzdF9pbm5lclxuICAgICAgICAgfnRlc3RfaWRcbiAgICAgICAgIH50ZXN0X291dHB1dF9yYXc6KHJlYWRfdGVzdF9vdXRwdXRfc2FuaXRpemVkX2FuZF9jaGVja2VkICgpKVxuICA7O1xuXG4gIGxldCBydW5fc3VpdGVcbiAgICB+ZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdFxuICAgIH5saW5lX251bWJlclxuICAgIH4obG9jYXRpb24gOiBDb21wYWN0X2xvYy50KVxuICAgIH4odHJhaWxpbmdfbG9jIDogQ29tcGFjdF9sb2MudClcbiAgICB+KGJvZHlfbG9jIDogQ29tcGFjdF9sb2MudClcbiAgICB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eVxuICAgIH5leHBlY3RlZF9leG5cbiAgICB+dHJhaWxpbmdfdGVzdF9pZFxuICAgIH5leG5fdGVzdF9pZFxuICAgIH5kZXNjcmlwdGlvblxuICAgIH50YWdzXG4gICAgfmlubGluZV90ZXN0X2NvbmZpZ1xuICAgIH5leHBlY3RhdGlvbnNcbiAgICBmXG4gICAgPVxuICAgIGxldCAoeyBzdGFydF9ib2w7IHN0YXJ0X3BvczsgZW5kX3BvcyB9IDogQ29tcGFjdF9sb2MudCkgPSBsb2NhdGlvbiBpblxuICAgIGxldCBiYXNlbmFtZSA9IFN0ZGxpYi5GaWxlbmFtZS5iYXNlbmFtZSBmaWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290IGluXG4gICAgKCogRXZlbiBpZiB0aGUgY3VycmVudCB0YWcgc2V0IGluZGljYXRlcyB0aGlzIHRlc3Qgc2hvdWxkIGJlIGRyb3BwZWQsIGNoZWNrIHRoYXQgaXRcbiAgICAgICB3YXNuJ3QgcmVhY2hlZCBmcm9tIGFub3RoZXIgZXhwZWN0IHRlc3QgKilcbiAgICBDdXJyZW50X3Rlc3QuYXNzZXJ0X25vX3Rlc3RfcnVubmluZyB+YmFzZW5hbWUgfmxpbmVfbnVtYmVyO1xuICAgIFBweF9pbmxpbmVfdGVzdF9saWIudGVzdFxuICAgICAgfmNvbmZpZzppbmxpbmVfdGVzdF9jb25maWdcbiAgICAgIH5kZXNjcjoobGF6eSAoT3B0aW9uLnZhbHVlIGRlc2NyaXB0aW9uIH5kZWZhdWx0OlwiXCIpKVxuICAgICAgfnRhZ3NcbiAgICAgIH5maWxlbmFtZTpiYXNlbmFtZVxuICAgICAgfmxpbmVfbnVtYmVyXG4gICAgICB+c3RhcnRfcG9zOihzdGFydF9wb3MgLSBzdGFydF9ib2wpXG4gICAgICB+ZW5kX3BvczooZW5kX3BvcyAtIHN0YXJ0X2JvbClcbiAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgKCogQ2hlY2sgdGhhdCB0aGUgdGVzdCBpcyBiZWluZyBydW4gZnJvbSB0aGUgZmlsZSBpbiB3aGljaCBpdCB3YXMgZGVmaW5lZCAqKVxuICAgICAgICBDdXJyZW50X2ZpbGUudmVyaWZ5X3RoYXRfZmlsZV9pc19jdXJyZW50X2V4blxuICAgICAgICAgIH5saW5lX251bWJlclxuICAgICAgICAgIH5maWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290O1xuICAgICAgICBsZXQgYWJzb2x1dGVfZmlsZW5hbWUgPSBDdXJyZW50X2ZpbGUuYWJzb2x1dGVfcGF0aCBiYXNlbmFtZSBpblxuICAgICAgICAoKiBDcmVhdGUgdGhlIHRlc3RzIGZvciB0cmFpbGluZyBvdXRwdXQgYW5kIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgKilcbiAgICAgICAgbGV0IGV4cGVjdGF0aW9ucyA9XG4gICAgICAgICAgbGV0IHRyYWlsaW5nX3Rlc3QgPVxuICAgICAgICAgICAgRXhwZWN0YXRpb24uZXhwZWN0X3RyYWlsaW5nXG4gICAgICAgICAgICAgIH5pbnNlcnRfbG9jOlxuICAgICAgICAgICAgICAgIHsgbG9jID0geyB0cmFpbGluZ19sb2Mgd2l0aCBlbmRfcG9zID0gdHJhaWxpbmdfbG9jLnN0YXJ0X3BvcyB9OyBib2R5X2xvYyB9XG4gICAgICAgICAgICB8PiBUZXN0X25vZGUub2ZfZXhwZWN0YXRpb25cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBleG5fdGVzdCA9XG4gICAgICAgICAgICBtYXRjaCBleHBlY3RlZF9leG4gd2l0aFxuICAgICAgICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgICAgICAgRXhwZWN0YXRpb24uZXhwZWN0X3VuY2F1Z2h0X2V4blxuICAgICAgICAgICAgICAgIH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5XG4gICAgICAgICAgICAgICAgfmxvY2F0ZWRfcGF5bG9hZDpleHBlY3RlZF9leG5cbiAgICAgICAgICAgICAgICB+bm9kZV9sb2M6dHJhaWxpbmdfbG9jXG4gICAgICAgICAgICAgIHw+IFRlc3Rfbm9kZS5vZl9leHBlY3RhdGlvblxuICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIEV4cGVjdGF0aW9uLmV4cGVjdF9ub191bmNhdWdodF9leG5cbiAgICAgICAgICAgICAgICB+aW5zZXJ0X2xvYzp7IGxvYyA9IHRyYWlsaW5nX2xvYzsgYm9keV9sb2MgfVxuICAgICAgICAgICAgICB8PiBUZXN0X25vZGUub2ZfZXhwZWN0YXRpb25cbiAgICAgICAgICBpblxuICAgICAgICAgIChleG5fdGVzdF9pZCwgZXhuX3Rlc3QpIDo6ICh0cmFpbGluZ190ZXN0X2lkLCB0cmFpbGluZ190ZXN0KSA6OiBleHBlY3RhdGlvbnNcbiAgICAgICAgaW5cbiAgICAgICAgKCogQWRkIHRoZSB0ZXN0cyB0byB0aGUgZ2xvYmFsIHRhYmxlIGFuZCByZXNldCB0aGVpciBbcmVhY2hlZF90aGlzX3J1bl0gZmxhZ3MgKilcbiAgICAgICAgbGV0IGV4cGVjdGF0aW9ucyA9XG4gICAgICAgICAgVGVzdF9ub2RlLkdsb2JhbF9yZXN1bHRzX3RhYmxlLmluaXRpYWxpemVfYW5kX3JlZ2lzdGVyX3Rlc3RzXG4gICAgICAgICAgICB+YWJzb2x1dGVfZmlsZW5hbWVcbiAgICAgICAgICAgIGV4cGVjdGF0aW9uc1xuICAgICAgICAgICAgKGZ1biB+b3JpZ2luYWxfZmlsZV9jb250ZW50cyB0cyAtPlxuICAgICAgICAgICAgTGlzdC5jb25jYXRfbWFwXG4gICAgICAgICAgICAgIHRzXG4gICAgICAgICAgICAgIH5mOlxuICAgICAgICAgICAgICAgIChUZXN0X25vZGUuRm9yX21sdC50b19kaWZmc1xuICAgICAgICAgICAgICAgICAgIH5jcl9mb3JfbXVsdGlwbGVfb3V0cHV0czpDb25maWd1cmVkLmNyX2Zvcl9tdWx0aXBsZV9vdXRwdXRzXG4gICAgICAgICAgICAgICAgICAgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmc6RXhwZWN0X25vZGVfZm9ybWF0dGluZy5kZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgfm9yaWdpbmFsX2ZpbGVfY29udGVudHMpKVxuICAgICAgICBpblxuICAgICAgICAoKiBUbyBhdm9pZCBjYXB0dXJpbmcgbm90LXlldCBmbHVzaGVkIGRhdGEgb2YgdGhlIHN0ZG91dC9zdGRlcnIgYnVmZmVycy4gKilcbiAgICAgICAgU2hhcmVkLmZsdXNoICgpO1xuICAgICAgICAoKiBSZWRpcmVjdCBzdGRvdXQvc3RkZXJyICopXG4gICAgICAgIGxldCB0ZXN0X2Jsb2NrID0gU2hhcmVkLnNldF91cF9ibG9jayBhYnNvbHV0ZV9maWxlbmFtZSBpblxuICAgICAgICAoKiBSdW4gdGhlIHRlc3QgKilcbiAgICAgICAgQ3VycmVudF90ZXN0LnNldCB7IGxpbmVfbnVtYmVyOyBiYXNlbmFtZTsgbG9jYXRpb247IHRlc3RfYmxvY2sgfTtcbiAgICAgICAgbGV0IHRlc3RfZXhuID1cbiAgICAgICAgICBDb25maWd1cmVkLmR1bXBfYmFja3RyYWNlIChmdW4gKCkgLT5cbiAgICAgICAgICAgICgqIElnbm9yZSBvdXRwdXQgdGhhdCB3YXMgcHJpbnRlZCBiZWZvcmUgdGhlIHRlc3Qgc3RhcnRlZCAqKVxuICAgICAgICAgICAgbGV0IChfIDogc3RyaW5nKSA9IFNoYXJlZC5yZWFkX3Rlc3Rfb3V0cHV0X3Vuc2FuaXRpemVkIHRlc3RfYmxvY2sgaW5cbiAgICAgICAgICAgIGYgKCkpXG4gICAgICAgIGluXG4gICAgICAgICgqIFJ1biB0aGUgdHJhaWxpbmcgb3V0cHV0IGFuZCB1bmNhdWdodCBleG4gdGVzdCAqKVxuICAgICAgICBsZXQgdGVzdF9vdXRwdXQsIHRlc3RfdG9fcnVuID1cbiAgICAgICAgICBsZXQgdHJhaWxpbmdfb3V0cHV0ID1cbiAgICAgICAgICAgIGxldCB0cmFpbGluZ19yYXcgPSByZWFkX3Rlc3Rfb3V0cHV0X3Nhbml0aXplZF9hbmRfY2hlY2tlZCAoKSBpblxuICAgICAgICAgICAgbWF0Y2ggU3RyaW5nLnN0cmlwIHRyYWlsaW5nX3JhdyB3aXRoXG4gICAgICAgICAgICB8IFwiXCIgLT4gTm9uZVxuICAgICAgICAgICAgfCBfIC0+IFNvbWUgdHJhaWxpbmdfcmF3XG4gICAgICAgICAgaW5cbiAgICAgICAgICBtYXRjaCB0ZXN0X2V4biB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IE9wdGlvbi52YWx1ZSB0cmFpbGluZ19vdXRwdXQgfmRlZmF1bHQ6XCJcIiwgdHJhaWxpbmdfdGVzdF9pZFxuICAgICAgICAgIHwgU29tZSB0ZXN0X2V4biAtPlxuICAgICAgICAgICAgbGV0IHRlc3Rfb3V0cHV0ID1cbiAgICAgICAgICAgICAgbWF0Y2ggdHJhaWxpbmdfb3V0cHV0IHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IHRlc3RfZXhuXG4gICAgICAgICAgICAgIHwgU29tZSB0cmFpbGluZ19vdXRwdXQgLT5cbiAgICAgICAgICAgICAgICBTdHJpbmcuY29uY2F0XG4gICAgICAgICAgICAgICAgICB+c2VwOlwiXFxuXCJcbiAgICAgICAgICAgICAgICAgIFsgdGVzdF9leG47IFwiVHJhaWxpbmcgb3V0cHV0XCI7IFwiLS0tLS0tLS0tLS0tLS0tXCI7IHRyYWlsaW5nX291dHB1dCBdXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgdGVzdF9vdXRwdXQsIGV4bl90ZXN0X2lkXG4gICAgICAgIGluXG4gICAgICAgIHJ1bl90ZXN0X2lubmVyIHRlc3RfYmxvY2sgfnRlc3Rfb3V0cHV0X3Jhdzp0ZXN0X291dHB1dCB+dGVzdF9pZDp0ZXN0X3RvX3J1bjtcbiAgICAgICAgKCogUGVyZm9ybSB0aGUgcGVyLXRlc3QgcmVhY2hhYmlsaXR5IGNoZWNrICopXG4gICAgICAgIExpc3QuaXRlciBleHBlY3RhdGlvbnMgfmY6KGZ1biAoXywgdGVzdF9ub2RlKSAtPlxuICAgICAgICAgIFRlc3Rfbm9kZS5yZWNvcmRfZW5kX29mX3J1biB0ZXN0X25vZGUpO1xuICAgICAgICAoKiBSZXN0b3JlIHN0ZG91dC9zdGRlcnIgKilcbiAgICAgICAgU2hhcmVkLmNsZWFuX3VwX2Jsb2NrIHRlc3RfYmxvY2s7XG4gICAgICAgIEN1cnJlbnRfdGVzdC51bnNldCAoKTtcbiAgICAgICAgKCogUmVwb3J0IHRoYXQgdGhpcyB0ZXN0IHBhc3NlZCwgYmVjYXVzZSB3ZSByZXBvcnQgZXhwZWN0IHRlc3QgZmFpbHVyZXMgYnkgYVxuICAgICAgICAgICAgZGlmZmVyZW50IG1lY2hhbmlzbS4gKilcbiAgICAgICAgdHJ1ZSlcbiAgOztcbmVuZFxuXG5sZXQgYXRfZXhpdCAoKSA9XG4gIEN1cnJlbnRfdGVzdC5pdGVyXG4gICAgfmY6XG4gICAgICAoZnVuXG4gICAgICAgIHsgbGluZV9udW1iZXJcbiAgICAgICAgOyBiYXNlbmFtZVxuICAgICAgICA7IGxvY2F0aW9uID0geyBzdGFydF9ib2w7IHN0YXJ0X3BvczsgZW5kX3BvcyB9XG4gICAgICAgIDsgdGVzdF9ibG9ja1xuICAgICAgICB9XG4gICAgICAgIC0+XG4gICAgU2hhcmVkLmZsdXNoICgpO1xuICAgIGxldCBmaW4gPSBTdGRsaWIub3Blbl9pbiAoU2hhcmVkLm91dHB1dF9maWxlIHRlc3RfYmxvY2spIGluXG4gICAgbGV0IGFsbF9vdXQgPSBTdGRsaWIucmVhbGx5X2lucHV0X3N0cmluZyBmaW4gKFN0ZGxpYi5pbl9jaGFubmVsX2xlbmd0aCBmaW4pIGluXG4gICAgU2hhcmVkLmNsZWFuX3VwX2Jsb2NrIHRlc3RfYmxvY2s7XG4gICAgU3RkbGliLlByaW50Zi5lcHJpbnRmXG4gICAgICBcIkZpbGUgJVMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQ6XFxuXFxcbiAgICAgICBFcnJvcjogcHJvZ3JhbSBleGl0ZWQgd2hpbGUgZXhwZWN0IHRlc3Qgd2FzIHJ1bm5pbmchXFxuXFxcbiAgICAgICBPdXRwdXQgY2FwdHVyZWQgc28gZmFyOlxcblxcXG4gICAgICAgJXNcXG5cXFxuICAgICAgICUhXCJcbiAgICAgIGJhc2VuYW1lXG4gICAgICBsaW5lX251bWJlclxuICAgICAgKHN0YXJ0X3BvcyAtIHN0YXJ0X2JvbClcbiAgICAgIChlbmRfcG9zIC0gc3RhcnRfYm9sKVxuICAgICAgYWxsX291dClcbjs7XG5cbm1vZHVsZSBGb3JfZXh0ZXJuYWwgPSBzdHJ1Y3RcbiAgbGV0IHJlYWRfY3VycmVudF90ZXN0X291dHB1dF9leG4gfmhlcmUgPVxuICAgIG1hdGNoIEN1cnJlbnRfdGVzdC5jdXJyZW50X3Rlc3QgKCkgd2l0aFxuICAgIHwgU29tZSB0ZXN0X2Jsb2NrIC0+XG4gICAgICB0ZXN0X2Jsb2NrIHw+IFNoYXJlZC5yZWFkX3Rlc3Rfb3V0cHV0X3Vuc2FuaXRpemVkIHw+IEV4cGVjdF90ZXN0X2NvbmZpZy5zYW5pdGl6ZVxuICAgIHwgTm9uZSAtPlxuICAgICAgZmFpbHdpdGhcbiAgICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICAgIFwiUHB4X2V4cGVjdF9ydW50aW1lLnJlYWRfY3VycmVudF90ZXN0X291dHB1dF9leG4gY2FsbGVkIHdoaWxlIHRoZXJlIGFyZSBubyBcXFxuICAgICAgICAgICAgdGVzdHMgcnVubmluZyBhdCAlc1wiXG4gICAgICAgICAgIChTb3VyY2VfY29kZV9wb3NpdGlvbi50b19zdHJpbmcgaGVyZSkpXG4gIDs7XG5cbiAgbGV0IGFtX3J1bm5pbmdfZXhwZWN0X3Rlc3QgPSBDdXJyZW50X3Rlc3QuaXNfcnVubmluZ1xuXG4gIGxldCBkZWZhdWx0X2NyX2Zvcl9tdWx0aXBsZV9vdXRwdXRzID1cbiAgICBsZXQgbW9kdWxlIENvbmZpZ3VyZWQgPSBDb25maWd1cmVkIChFeHBlY3RfdGVzdF9jb25maWcpIGluXG4gICAgQ29uZmlndXJlZC5jcl9mb3JfbXVsdGlwbGVfb3V0cHV0c1xuICA7O1xuZW5kXG4iLCJvcGVuISBCYXNlXG5cbigqKiBUaGlzIGxpYnJhcnkgcHJvdmlkZXMgdGhlIHJ1bnRpbWUgcmVwcmVzZW50YXRpb24gb2YgZXhwZWN0IHRlc3RzIGFuZCBtdWNoIG9mIHRoZSBsb2dpY1xuICAgIGZvciBydW5uaW5nIHRoZW0uXG5cbiAgICBUaGUgW1Rlc3RfYmxvY2tdIG1vZHVsZSBkZWZpbmVzIHRoZSBydW50aW1lIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB3aG9sZVxuICAgIFtsZXQlZXhwZWN0X3Rlc3RdIGJsb2NrLiBJdCBleHBvcnRzIGEgW01ha2VdIGZ1bmN0b3IgdGhhdCBpcyB1c2VkIGluIGdlbmVyYXRlZCBjb2RlIHRvXG4gICAgcHJvZHVjZSBhIG1vZHVsZSBmcm9tIHRoZSBsb2NhbGx5IGJvdW5kIFtFeHBlY3RfdGVzdF9jb25maWddLiBbcnVuX3N1aXRlXSBmcm9tIHRoZVxuICAgIHJlc3VsdGluZyBtb2R1bGUgdGFrZXMgaW4gcmVtYWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBleHBlY3QgdGVzdCwgaW5jbHVkaW5nXG4gICAgaW5saW5lIHRlc3QgY29uZmlndXJhdGlvbnMsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb250YWluZWQgZXhwZWN0YXRpb25zLCBhbmQgYVxuICAgIGNhbGxiYWNrIGNvbnRhaW5pbmcgdGhlIGJvZHkgb2YgdGhlIHRlc3QuXG5cbiAgICBUaGUgW35leHBlY3RhdGlvbnNdIGFyZ3VtZW50IHRvIFtydW5fc3VpdGVdIGlzIGFuIGFzc29jIGxpc3QgbWFwcGluZyB1bmlxdWUgaWRzIHRvXG4gICAgW1Rlc3Rfbm9kZS50XXMuIEEgW1Rlc3Rfbm9kZS50XSBzdG9yZXMgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIFtbJWV4cGVjdF1dIHRlc3RcbiAgICBBU1Qgbm9kZSBhbmQgY29sbGVjdHMgdGhlIHJlc3VsdHMgb2YgdGVzdHMgdGhhdCByZWFjaCB0aGlzIG5vZGUuXG5cbiAgICBJbiB0aGUgYm9keSBvZiB0aGUgdGVzdCwgdGhlIFtbJWV4cGVjdF1dIEFTVCBub2RlcyBhcmUgcmVwbGFjZWQgYnkgY2FsbHMgdG9cbiAgICBbcnVuX3Rlc3RdLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBpZCBwYXNzZWQgYXMgYW4gYXJndW1lbnQuXG5cbiAgICBGb3IgYW4gZXhhbXBsZSwgY29uc2lkZXIgYSBmaWxlIHRoYXQgY29udGFpbnMganVzdCB0aGUgc2ltcGxlIFtsZXQlZXhwZWN0X3Rlc3RdIGJlbG93OlxuXG4gICAge1tcbiAgICAgIGxldCVleHBlY3RfdGVzdCBfID1cbiAgICAgICAgcHJpbnRfc3RyaW5nIFwiSGVsbG9cIjtcbiAgICAgICAgWyVleHBlY3Qge3wgSGVsbG8gfH1dO1xuICAgICAgICBwcmludF9zdHJpbmcgXCJ3b3JsZFwiO1xuICAgICAgICBbJWV4cGVjdF9leGFjdCB7eHx3b3JsZHx4fV1cbiAgICAgIDs7XG4gICAgXX1cblxuICAgIEl0IHdpbGwgZXhwYW5kIHRvIGNvZGUgdGhhdCBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuXG4gICAge1tcbiAgICAgICgqIFRoaXMgc3RhdGVtZW50IGlzIGFkZGVkIHRvIHRoZSB0b3Agb2YgZWFjaCByZXdyaXR0ZW4gZmlsZTsgaXQgaXMgdXNlZCB0byBtYWtlXG4gICAgICAgICBzdXJlIHRlc3RzIGFyZSBvbmx5IHJ1biBmcm9tIHRoZSBmaWxlcyBpbiB3aGljaCB0aGV5IGFyZSBkZWNsYXJlZC4gKilcbiAgICAgIGxldCAoKSA9XG4gICAgICAgIFBweF9leHBlY3RfcnVudGltZS5DdXJyZW50X2ZpbGUuc2V0XG4gICAgICAgICAgfmZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3Q6XCJmb28vYmFyL3Rlc3QvdGVzdC5tbFwiXG5cbiAgICAgICgqIEVhY2ggdGVzdCBleHBhbmRzIGludG8gc29tZXRoaW5nIHRoYXQgbG9va3MgYXBwcm94aW1hdGVseSBsaWtlIHRoaXMuIFNvbWUgb2YgdGhlXG4gICAgICAgICBhcmd1bWVudHMgdG8gW1BweF9leHBlY3RfdGVzdF9ibG9jay5ydW5fc3VpdGVdIGFyZSBlbGlkZWQgZm9yIGNsYXJpdHkuICopXG4gICAgICBsZXQgKCkgPVxuICAgICAgICAoKiBQcmVwYXJlIHRvIHJlYWQgdGVzdCBvdXRwdXQgdXNpbmcgdGhlIHNldHRpbmdzIGZyb20gW0V4cGVjdF90ZXN0X2NvbmZpZ10gKilcbiAgICAgICAgbGV0IG1vZHVsZSBQcHhfZXhwZWN0X3Rlc3RfYmxvY2sgPVxuICAgICAgICAgIFBweF9leHBlY3RfcnVudGltZS5NYWtlX3Rlc3RfYmxvY2soRXhwZWN0X3Rlc3RfY29uZmlnKSBpblxuICAgICAgICBQcHhfZXhwZWN0X3Rlc3RfYmxvY2sucnVuX3N1aXRlXG4gICAgICAgICAgKCogVGhlIG5hbWUgb2YgdGhlIGZpbGUgaW4gd2hpY2ggdGhlIHRlc3QgaXMgZGVmaW5lZC4gVGhpcyBsZXRzIHRoZSBydW50aW1lXG4gICAgICAgICAgICAgY2hlY2sgdGhhdCB0aGUgZmlsZW5hbWUgc2V0IGhlcmUgYXQgcHB4LXRpbWUgbWF0Y2hlcyB0aGUgb25lIHRoYXQgaXMgc2V0IGJ5XG4gICAgICAgICAgICAgdGhlIGJsb2NrIGFib3ZlIGF0IHJ1bnRpbWUuIElmIHRoZSB0ZXN0IHdlcmUgZGVmaW5lZCBpbiBhIGZ1bmN0b3IgYW5kIHRoYXRcbiAgICAgICAgICAgICBmdW5jdG9yIGludm9rZWQgZnJvbSBhbm90aGVyIGZpbGUsIHRoZSBmaWxlbmFtZXMgd291bGQgbm90IG1hdGNoLiAqKVxuICAgICAgICAgIH5maWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290OlwiZm9vL2Jhci90ZXN0L3Rlc3QubWxcIlxuICAgICAgICAgICgqIFRoZSBpZHMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIHJlZ2lzdGVyaW5nIHRoZSB0cmFpbGluZyBvdXRwdXQgdGVzdCBhbmQgdGhlXG4gICAgICAgICAgICAgdW5jYXVnaHQgZXhjZXB0aW9uIHRlc3RzLiBUaGV5IGFyZSBtaW50ZWQgYXQgcHB4IHRpbWUgYmVjYXVzZSB0aGF0IGlzIHRoZVxuICAgICAgICAgICAgIHRpbWUgdGhhdCBpdCBpcyBlYXNpZXN0IHRvIGd1YXJhbnRlZSB0aGVpciB1bmlxdWVuZXNzLiAqKVxuICAgICAgICAgIH50cmFpbGluZ190ZXN0X2lkOihQcHhfZXhwZWN0X3J1bnRpbWUuRXhwZWN0YXRpb25faWQub2ZfaW50IDIpXG4gICAgICAgICAgfmV4bl90ZXN0X2lkOihQcHhfZXhwZWN0X3J1bnRpbWUuRXhwZWN0YXRpb25faWQub2ZfaW50IDMpXG4gICAgICAgICAgKCogQW4gYXNzb2MgbGlzdCBtYXBwaW5nIGlkcyB0byByZXByZXNlbnRhdGlvbnMgb2YgZXhwZWN0IG5vZGVzIHRoYXQgYXBwZWFyIGluXG4gICAgICAgICAgICAgdGhpcyB0ZXN0LiBMYXRlciwgd2hlbiBlbmNvdW50ZXJpbmcgZXhwZWN0IG5vZGVzLCBpbmZvcm1hdGlvbiBhYm91dCB0aGVtIGlzXG4gICAgICAgICAgICAgbG9va2VkIHVwIGluIHRoaXMgdGFibGUuICopXG4gICAgICAgICAgfmV4cGVjdGF0aW9uczooKFsoUHB4X2V4cGVjdF9ydW50aW1lLkV4cGVjdGF0aW9uX2lkLm9mX2ludCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBweF9leHBlY3RfcnVudGltZS5UZXN0X25vZGUuQ3JlYXRlLmV4cGVjdF9leGFjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBjb250ZW50cyA9IFwid29ybGRcIjsgdGFnID0gKFRhZyBcInhcIikgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGFydF9ib2wgPSAuLi47IHN0YXJ0X3BvcyA9IC4uLjsgZW5kX3BvcyA9IC4uLiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChQcHhfZXhwZWN0X3J1bnRpbWUuRXhwZWN0YXRpb25faWQub2ZfaW50IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHB4X2V4cGVjdF9ydW50aW1lLlRlc3Rfbm9kZS5DcmVhdGUuZXhwZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGNvbnRlbnRzID0gXCIgSGVsbG8gXCI7IHRhZyA9IChUYWcgXCJcIikgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGFydF9ib2wgPSAuLi47IHN0YXJ0X3BvcyA9IC4uLjsgZW5kX3BvcyA9IC4uLiB9KV0pXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgKCogVGhlIGJvZHkgb2YgdGhlIGxldCBiaW5kaW5nIGlzIHBhc3NlZCBhcyBhIGNhbGxiYWNrLiAqKVxuICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgICBwcmludF9zdHJpbmcgXCJIZWxsb1wiO1xuICAgICAgICAgICAgICgqIFRlc3RzIGFyZSBydW4gYnkgcGFzc2luZyBpbiB0aGUgaWQgb2YgdGhlIGVuY291bnRlcmVkIHRlc3Qgbm9kZS4gKilcbiAgICAgICAgICAgICBQcHhfZXhwZWN0X3Rlc3RfYmxvY2sucnVuX3Rlc3RcbiAgICAgICAgICAgICAgIH50ZXN0X2lkOihQcHhfZXhwZWN0X3J1bnRpbWUuRXhwZWN0YXRpb25faWQub2ZfaW50IDApO1xuICAgICAgICAgICAgIHByaW50X3N0cmluZyBcIndvcmxkXCI7XG4gICAgICAgICAgICAgUHB4X2V4cGVjdF90ZXN0X2Jsb2NrLnJ1bl90ZXN0XG4gICAgICAgICAgICAgICB+dGVzdF9pZDooUHB4X2V4cGVjdF9ydW50aW1lLkV4cGVjdGF0aW9uX2lkLm9mX2ludCAxKSlcblxuICAgICAgKCogVGhpcyBzdGF0ZW1lbnQgaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiBlYWNoIGZpbGUgc28gdGhhdCB0aGUgZXhwZWN0IHRlc3QgcnVudGltZVxuICAgICAgICAga25vd3MgdGhlIGZpbGUgaXMgZmluaXNoZWQgZXhlY3V0aW5nIGFuZCBhIG5ldyBvbmUgY2FuIGJlIHNldCBhcyBjdXJyZW50LiAqKVxuICAgICAgbGV0ICgpID0gUHB4X2V4cGVjdF9ydW50aW1lLkN1cnJlbnRfZmlsZS51bnNldCAoKVxuICAgIF19XG4qKVxuXG4oKiBSZWdpc3RlciB0aGUgcmVhY2hhYmlsaXR5IGNoZWNrIGFuZCBjb3JyZWN0ZWQgZmlsZSB3cml0aW5nIGFzIGFuIGV2YWx1YXRvciB3aXRoXG4gICBbUHB4X2lubGluZV90ZXN0X2xpYl0gKilcbmxldCAoKSA9XG4gIFBweF9pbmxpbmVfdGVzdF9saWIuYWRkX2V2YWx1YXRvciB+ZjooZnVuICgpIC0+XG4gICAgU3RkbGliLlN5cy5jaGRpciAoTGF6eS5mb3JjZSBDdXJyZW50X2ZpbGUuaW5pdGlhbF9kaXIpO1xuICAgIFRlc3Rfbm9kZS5HbG9iYWxfcmVzdWx0c190YWJsZS5wcm9jZXNzX2VhY2hfZmlsZVxuICAgICAgfmY6KGZ1biB+ZmlsZW5hbWUgfnRlc3Rfbm9kZXMgfnBvc3Rwcm9jZXNzIC0+XG4gICAgICBXcml0ZV9jb3JyZWN0ZWRfZmlsZS5mXG4gICAgICAgIHRlc3Rfbm9kZXNcbiAgICAgICAgfnVzZV9jb2xvcjooUHB4X2lubGluZV90ZXN0X2xpYi51c2VfY29sb3IgKCkpXG4gICAgICAgIH5pbl9wbGFjZTooUHB4X2lubGluZV90ZXN0X2xpYi5pbl9wbGFjZSAoKSlcbiAgICAgICAgfmRpZmZfY29tbWFuZDooUHB4X2lubGluZV90ZXN0X2xpYi5kaWZmX2NvbW1hbmQgKCkpXG4gICAgICAgIH5kaWZmX3BhdGhfcHJlZml4OihQcHhfaW5saW5lX3Rlc3RfbGliLmRpZmZfcGF0aF9wcmVmaXggKCkpXG4gICAgICAgIH53aXRoXzpwb3N0cHJvY2Vzc1xuICAgICAgICB+ZmlsZW5hbWUpXG4gICAgfD4gUHB4X2lubGluZV90ZXN0X2xpYi5UZXN0X3Jlc3VsdC5jb21iaW5lX2FsbClcbjs7XG5cbigqIEFsZXJ0IG9mIG1pZC10ZXN0IHJ1bnRpbWUgZmFpbHVyZS4gKilcbmxldCAoKSA9IFN0ZGxpYi5hdF9leGl0IFRlc3RfYmxvY2suYXRfZXhpdFxuXG4oKiBFeHBvcnRlZCBkZWZpbml0aW9ucyAqKVxuXG5tb2R1bGUgRXhwZWN0X25vZGVfZm9ybWF0dGluZyA9IFR5cGVzLkV4cGVjdF9ub2RlX2Zvcm1hdHRpbmdcbm1vZHVsZSBDb21wYWN0X2xvYyA9IFR5cGVzLkNvbXBhY3RfbG9jXG5tb2R1bGUgRXhwZWN0YXRpb25faWQgPSBUeXBlcy5FeHBlY3RhdGlvbl9pZFxubW9kdWxlIERlbGltaXRlciA9IFR5cGVzLlN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXJcbm1vZHVsZSBQYXlsb2FkID0gT3V0cHV0LlBheWxvYWRcblxubW9kdWxlIEN1cnJlbnRfZmlsZSA6IHNpZ1xuICB2YWwgc2V0IDogZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdDpzdHJpbmcgLT4gdW5pdFxuICB2YWwgdW5zZXQgOiB1bml0IC0+IHVuaXRcbmVuZCA9XG4gIEN1cnJlbnRfZmlsZVxuXG5tb2R1bGUgVGVzdF9ub2RlID0gc3RydWN0XG4gIHR5cGUgdCA9IFRlc3Rfbm9kZS50XG5cbiAgbW9kdWxlIENyZWF0ZSA9IFRlc3Rfbm9kZS5DcmVhdGVcbiAgbW9kdWxlIEZvcl9tbHQgPSBUZXN0X25vZGUuRm9yX21sdFxuZW5kXG5cbm1vZHVsZSBXcml0ZV9jb3JyZWN0ZWRfZmlsZSA9IFdyaXRlX2NvcnJlY3RlZF9maWxlXG5tb2R1bGUgTWFrZV90ZXN0X2Jsb2NrID0gVGVzdF9ibG9jay5NYWtlXG5tb2R1bGUgRm9yX2V4dGVybmFsID0gVGVzdF9ibG9jay5Gb3JfZXh0ZXJuYWxcbm1vZHVsZSBGb3JfYXBwbHlfc3R5bGUgPSBFeHBlY3RhdGlvbi5Gb3JfYXBwbHlfc3R5bGVcbiJdfQ==
