// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Multipart_form__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Multipart_form = [0];
   runtime.caml_register_global(0, Multipart_form, "Multipart_form__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Multipart_form__Content_type
//# unitInfo: Requires: Angstrom, Fmt, Prettym, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__Map, Stdlib__Result, Stdlib__String, Unstrctrd, Uutf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_does_not_respect_standards = " does not respect standards",
    cst_An_extension_token_MUST_be =
      "An extension token MUST be prefixed by [X-]: ",
    cst_An_extension_token_MUST_be$0 =
      "An extension token MUST be prefixed by [X-]: %S",
    cst_Extension_token = "Extension token ",
    cst_Extension_token_S_does_not =
      "Extension token %S does not respect standards",
    cst_Extension_token_MUST_have_ =
      "Extension token MUST have, at least, 3 bytes: ",
    cst_Extension_token_MUST_have_$0 =
      "Extension token MUST have, at least, 3 bytes: %S",
    cst_Value = "Value ",
    cst_X$1 = "X-",
    cst_application$2 = "application",
    cst_audio$2 = "audio",
    cst_ietf = "ietf:",
    cst_ietf_s = "ietf:%s",
    cst_image$2 = "image",
    cst_multipart$2 = "multipart",
    cst_text$2 = "text",
    cst_video$2 = "video",
    cst_x = "x:",
    cst_x_s = "x:%s",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    default$0 = [0, 672582309, "plain"],
    cst = "",
    Prettym = global_data.Prettym,
    Stdlib = global_data.Stdlib,
    Unstrctrd = global_data.Unstrctrd,
    Angstrom = global_data.Angstrom,
    Stdlib_Result = global_data.Stdlib__Result,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Fmt = global_data.Fmt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Uutf = global_data.Uutf,
    Stdlib_Map = global_data.Stdlib__Map,
    cst_X$0 = cst_X$1,
    cst_X = cst_X$1,
    cst_audio$1 = cst_audio$2,
    cst_text$1 = cst_text$2,
    cst_application$1 = cst_application$2,
    cst_message = "message",
    cst_image$1 = cst_image$2,
    cst_multipart$1 = cst_multipart$2,
    cst_video$1 = cst_video$2,
    _aG_ =
      [0,
       [11, "Invalid (unfolded) Content-Type value: ", [3, 0, 0]],
       "Invalid (unfolded) Content-Type value: %S"],
    _u_ = [0, [11, "invalid token: ", [2, 0, 0]], "invalid token: %s"],
    _t_ = [0, [15, [12, 47, [15, [12, 32, [15, 0]]]]], "%a/%a %a"],
    cst_boundary = "boundary",
    _p_ = [0, [15, [12, 61, [15, 0]]], "%a=%a"],
    _q_ = [0, [12, 59, [17, [0, "@ ", 1, 0], 0]], ";@ "],
    _o_ = [0, [3, 0, 0], "%S"],
    _n_ =
      [0,
       [11, cst_Value, [3, 0, [11, " is not a valid UTF-8 string", 0]]],
       "Value %S is not a valid UTF-8 string"],
    _m_ =
      [0,
       [11, cst_Value, [3, 0, [11, cst_does_not_respect_standards, 0]]],
       "Value %S does not respect standards"],
    _l_ =
      [0,
       [11, "Key ", [3, 0, [11, cst_does_not_respect_standards, 0]]],
       "Key %S does not respect standards"],
    _j_ = [0, [11, "iana:", [2, 0, 0]], "iana:%s"],
    _k_ = [0, [11, cst_x, [2, 0, 0]], cst_x_s],
    _i_ = [0, [11, cst_ietf, [2, 0, 0]], cst_ietf_s],
    _h_ =
      [0,
       [11, cst_Extension_token_MUST_have_, [3, 0, 0]],
       cst_Extension_token_MUST_have_$0],
    _f_ =
      [0,
       [11,
        cst_Extension_token,
        [3, 0, [11, cst_does_not_respect_standards, 0]]],
       cst_Extension_token_S_does_not],
    _g_ =
      [0,
       [11, cst_An_extension_token_MUST_be, [3, 0, 0]],
       cst_An_extension_token_MUST_be$0],
    cst_audio$0 = cst_audio$2,
    cst_text$0 = cst_text$2,
    cst_application$0 = cst_application$2,
    cst_image$0 = cst_image$2,
    cst_video$0 = cst_video$2,
    cst_multipart$0 = cst_multipart$2,
    cst_audio = cst_audio$2,
    cst_text = cst_text$2,
    cst_application = cst_application$2,
    cst_image = cst_image$2,
    cst_video = cst_video$2,
    cst_multipart = cst_multipart$2,
    _d_ = [0, [11, cst_ietf, [2, 0, 0]], cst_ietf_s],
    _e_ = [0, [11, cst_x, [2, 0, 0]], cst_x_s],
    _c_ =
      [0,
       [11, cst_Extension_token_MUST_have_, [3, 0, 0]],
       cst_Extension_token_MUST_have_$0],
    _a_ =
      [0,
       [11,
        cst_Extension_token,
        [3, 0, [11, cst_does_not_respect_standards, 0]]],
       cst_Extension_token_S_does_not],
    _b_ =
      [0,
       [11, cst_An_extension_token_MUST_be, [3, 0, 0]],
       cst_An_extension_token_MUST_be$0],
    cst_Multipart_form_Content_typ =
      "Multipart_form__Content_type.Invalid_token",
    cst_Multipart_form_Content_typ$0 =
      "Multipart_form__Content_type.Parameters.Invalid_utf_8",
    _r_ = [1, "us-ascii"],
    cst_charset = "charset";
   function error_msgf(fmt){
    function _c4_(msg){return [1, [0, 3854881, msg]];}
    return caml_call2(Fmt[8], _c4_, fmt);
   }
   var
    Invalid_token = [248, cst_Multipart_form_Content_typ, caml_fresh_oo_id(0)];
   function is_tspecials(param){
    var _c3_ = param - 34 | 0;
    a:
    {
     if(30 < _c3_ >>> 0){
      if(2 < _c3_ - 57 >>> 0) break a;
     }
     else if(24 > _c3_)
      switch(_c3_){
        case 0:
        case 6:
        case 7:
        case 10:
        case 13: break;
        default: break a;
      }
     return 1;
    }
    return 0;
   }
   function is_ctl(param){
    if(127 !== param && 32 <= param) return 0;
    return 1;
   }
   function is_space(_c2_){return 32 === _c2_ ? 1 : 0;}
   function is_ascii(param){return 128 <= param ? 0 : 1;}
   function is_token(c){
    var _cY_ = is_ascii(c);
    if(_cY_){
     var _cZ_ = 1 - is_tspecials(c);
     if(_cZ_)
      var _c0_ = 1 - is_ctl(c), _c1_ = _c0_ ? 1 - (32 === c ? 1 : 0) : _c0_;
     else
      var _c1_ = _cZ_;
    }
    else
     var _c1_ = _cY_;
    return _c1_;
   }
   function is_obs_no_ws_ctl(param){
    a:
    {
     if(13 <= param){
      if(32 <= param){
       if(127 === param) break a;
      }
      else if(14 <= param) break a;
     }
     else
      if(9 <= param){if(11 <= param) break a;} else if(param) break a;
     return 0;
    }
    return 1;
   }
   function is_qtext(param){
    var _cX_ = param - 13 | 0;
    a:
    {
     if(21 < _cX_ >>> 0){
      if(79 === _cX_) break a;
     }
     else if(19 < _cX_ - 1 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   var
    text = 936573133,
    image = -795439301,
    audio = 984475830,
    video = -903248805,
    application = 242303792,
    multipart = -1031569716;
   function is_discrete(param){
    a:
    if(typeof param === "number"){
     if(242303792 <= param){
      if(936573133 !== param && 984475830 !== param && 242303793 <= param)
       break a;
     }
     else if(-903248805 !== param && -795439301 !== param) break a;
     return 1;
    }
    return 0;
   }
   function is_multipart(param){
    if(typeof param === "number" && -1031569716 === param) return 1;
    return 0;
   }
   function ietf(token){return [0, [0, 452357416, token]];}
   function extension(token){
    if(3 > caml_ml_string_length(token))
     return caml_call1(error_msgf(_c_), token);
    var match = caml_string_get(token, 0);
    a:
    {
     var match$0 = caml_string_get(token, 1);
     if(88 !== match && 120 !== match) break a;
     if(45 === match$0)
      try{
       var
        _cS_ =
          caml_call3
           (Stdlib_String[16], token, 2, caml_ml_string_length(token) - 2 | 0),
        _cT_ =
          function(chr){
           var _cW_ = 1 - is_token(chr);
           if(_cW_) throw caml_maybe_attach_backtrace(Invalid_token, 1);
           return _cW_;
          };
       caml_call2(Stdlib_String[30], _cT_, _cS_);
       var _cU_ = [0, [0, -613180270, token]];
       return _cU_;
      }
      catch(_cV_){
       var _cR_ = caml_wrap_exception(_cV_);
       if(_cR_ === Invalid_token) return caml_call1(error_msgf(_a_), token);
       throw caml_maybe_attach_backtrace(_cR_, 0);
      }
    }
    return caml_call1(error_msgf(_b_), token);
   }
   function pp(ppf, param){
    if(typeof param === "number")
     return -795439301 <= param
             ? 936573133
               <= param
               ? 984475830
                 <= param
                 ? caml_call2(Fmt[57], ppf, cst_audio)
                 : caml_call2(Fmt[57], ppf, cst_text)
               : 242303792
                 <= param
                 ? caml_call2(Fmt[57], ppf, cst_application)
                 : caml_call2(Fmt[57], ppf, cst_image)
             : -903248805
               <= param
               ? caml_call2(Fmt[57], ppf, cst_video)
               : caml_call2(Fmt[57], ppf, cst_multipart);
    if(452357416 <= param[1]){
     var token = param[2];
     return caml_call3(Fmt[3], ppf, _d_, token);
    }
    var token$0 = param[2];
    return caml_call3(Fmt[3], ppf, _e_, token$0);
   }
   function to_string(param){
    if(typeof param === "number")
     return -795439301 <= param
             ? 936573133
               <= param
               ? 984475830 <= param ? cst_audio$0 : cst_text$0
               : 242303792 <= param ? cst_application$0 : cst_image$0
             : -903248805 <= param ? cst_video$0 : cst_multipart$0;
    var token = param[2];
    return token;
   }
   function compare(a, b){
    var
     _cN_ = to_string(b),
     _cO_ = caml_call1(Stdlib_String[27], _cN_),
     _cP_ = to_string(a),
     _cQ_ = caml_call1(Stdlib_String[27], _cP_);
    return caml_call2(Stdlib_String[10], _cQ_, _cO_);
   }
   function equal(a, b){return 0 === compare(a, b) ? 1 : 0;}
   var
    Type =
      [0,
       text,
       image,
       audio,
       video,
       application,
       multipart,
       is_discrete,
       is_multipart,
       ietf,
       extension,
       pp,
       to_string,
       compare,
       equal,
       936573133];
   function ietf$0(token){return [0, [0, 452357416, token]];}
   function iana(token){return [0, [0, 672582309, token]];}
   function iana_exn(token){
    var match = iana(token);
    if(0 === match[0]){var v = match[1]; return v;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   function v(token){return iana_exn(token);}
   function extension$0(token){
    if(3 > caml_ml_string_length(token))
     return caml_call1(error_msgf(_h_), token);
    var match = caml_string_get(token, 0);
    a:
    {
     var match$0 = caml_string_get(token, 1);
     if(88 !== match && 120 !== match) break a;
     if(45 === match$0)
      try{
       var
        _cI_ =
          caml_call3
           (Stdlib_String[16], token, 2, caml_ml_string_length(token) - 2 | 0),
        _cJ_ =
          function(chr){
           var _cM_ = 1 - is_token(chr);
           if(_cM_) throw caml_maybe_attach_backtrace(Invalid_token, 1);
           return _cM_;
          };
       caml_call2(Stdlib_String[30], _cJ_, _cI_);
       var _cK_ = [0, [0, -613180270, token]];
       return _cK_;
      }
      catch(_cL_){
       var _cH_ = caml_wrap_exception(_cL_);
       if(_cH_ === Invalid_token) return caml_call1(error_msgf(_f_), token);
       throw caml_maybe_attach_backtrace(_cH_, 0);
      }
    }
    return caml_call1(error_msgf(_g_), token);
   }
   function pp$0(ppf, param){
    var _cG_ = param[1];
    if(452357416 === _cG_){
     var token = param[2];
     return caml_call3(Fmt[3], ppf, _i_, token);
    }
    if(672582309 <= _cG_){
     var token$0 = param[2];
     return caml_call3(Fmt[3], ppf, _j_, token$0);
    }
    var token$1 = param[2];
    return caml_call3(Fmt[3], ppf, _k_, token$1);
   }
   function compare$0(a, b){
    var
     a$0 = a[2],
     b$0 = b[2],
     _cE_ = caml_call1(Stdlib_String[27], b$0),
     _cF_ = caml_call1(Stdlib_String[27], a$0);
    return caml_call2(Stdlib_String[10], _cF_, _cE_);
   }
   function equal$0(a, b){return 0 === compare$0(a, b) ? 1 : 0;}
   var
    Subtype =
      [0,
       ietf$0,
       iana,
       iana_exn,
       v,
       extension$0,
       pp$0,
       compare$0,
       equal$0,
       default$0],
    Map = caml_call1(Stdlib_Map[1], [0, Stdlib_String[10]]);
   function key(key){
    try{
     var
      _cA_ =
        function(chr){
         var _cD_ = 1 - is_token(chr);
         if(_cD_) throw caml_maybe_attach_backtrace(Invalid_token, 1);
         return _cD_;
        };
     caml_call2(Stdlib_String[30], _cA_, key);
     var _cB_ = [0, caml_call1(Stdlib_String[27], key)];
     return _cB_;
    }
    catch(_cC_){
     var _cz_ = caml_wrap_exception(_cC_);
     if(_cz_ === Invalid_token) return caml_call1(error_msgf(_l_), key);
     throw caml_maybe_attach_backtrace(_cz_, 0);
    }
   }
   function key_exn(x){
    var match = key(x);
    if(0 === match[0]){var v = match[1]; return v;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   function k(x){return key_exn(x);}
   var
    Invalid_utf_8 =
      [248, cst_Multipart_form_Content_typ$0, caml_fresh_oo_id(0)];
   function value(v){
    function escape_characters(x){
     var
      len = caml_ml_string_length(x),
      buf = caml_call1(Stdlib_Buffer[1], len);
     function _cw_(chr){
      a:
      {
       b:
       {
        if(14 <= chr){
         if(34 === chr || 92 === chr) break b;
        }
        else
         if(11 <= chr){if(13 <= chr) break b;} else if(9 <= chr) break b;
        var _cx_ = 0;
        break a;
       }
       var _cx_ = 1;
      }
      if(! _cx_) return caml_call2(Stdlib_Buffer[12], buf, chr);
      caml_call2(Stdlib_Buffer[12], buf, 92);
      var switcher = chr - 9 | 0;
      a:
      {
       if(4 >= switcher >>> 0)
        switch(switcher){
          case 0:
           var _cy_ = 116; break a;
          case 1:
           var _cy_ = 110; break a;
          case 4:
           var _cy_ = 114; break a;
        }
       var _cy_ = chr;
      }
      return caml_call2(Stdlib_Buffer[12], buf, _cy_);
     }
     caml_call2(Stdlib_String[30], _cw_, x);
     return caml_call1(Stdlib_Buffer[2], buf);
    }
    try{
     var
      _ck_ =
        function(chr){
         var _cv_ = 1 - is_token(chr);
         if(_cv_) throw caml_maybe_attach_backtrace(Invalid_token, 1);
         return _cv_;
        };
     caml_call2(Stdlib_String[30], _ck_, v);
     var _cl_ = [0, [1, v]], v$0 = _cl_;
    }
    catch(_cu_){
     var _cj_ = caml_wrap_exception(_cu_);
     if(_cj_ !== Invalid_token) throw caml_maybe_attach_backtrace(_cj_, 0);
     var v$0 = caml_call1(error_msgf(_m_), v);
    }
    if(0 === v$0[0]) return v$0;
    function symbol_map(x, f){return caml_call2(Stdlib_Result[8], f, x);}
    function _cq_(x){return [0, x];}
    try{
     var
      _cn_ = 0,
      _co_ =
        function(param, pos, _ct_){
         if(852405675 <= _ct_[1]) return 0;
         throw caml_maybe_attach_backtrace(Invalid_utf_8, 1);
        };
     caml_call5(Uutf[22][2], 0, 0, _co_, _cn_, v);
     var _cp_ = [0, v], _cr_ = _cp_;
    }
    catch(_cs_){
     var _cm_ = caml_wrap_exception(_cs_);
     if(_cm_ !== Invalid_utf_8) throw caml_maybe_attach_backtrace(_cm_, 0);
     var _cr_ = caml_call1(error_msgf(_n_), v);
    }
    return symbol_map(symbol_map(_cr_, escape_characters), _cq_);
   }
   function value_exn(x){
    var match = value(x);
    if(0 === match[0]){var v = match[1]; return v;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   function v$0(x){return value_exn(x);}
   var empty = Map[1];
   function mem(key, t){return caml_call2(Map[32], key, t);}
   function add(key, value, t){return caml_call3(Map[2], key, value, t);}
   function singleton(key, value){return caml_call2(Map[5], key, value);}
   function remove(key, t){return caml_call2(Map[6], key, t);}
   function find(key, t){
    try{var x = caml_call2(Map[17], key, t);}
    catch(_ci_){
     var _ch_ = caml_wrap_exception(_ci_);
     if(_ch_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_ch_, 0);
    }
    return [0, x];
   }
   function iter(f, t){return caml_call2(Map[23], f, t);}
   var pp_key = Fmt[57];
   function pp_value(ppf, param){
    if(0 === param[0]){
     var value = param[1];
     return caml_call3(Fmt[3], ppf, _o_, value);
    }
    var token = param[1];
    return caml_call2(Fmt[57], ppf, token);
   }
   function pp$1(ppf, t){
    function pp(ppf, param){
     var value = param[2], key = param[1];
     return caml_call6(Fmt[3], ppf, _p_, pp_key, key, pp_value, value);
    }
    var _cf_ = caml_call1(Map[10], t), _cg_ = [0, caml_call1(Fmt[18], _q_)];
    return caml_call4(Fmt[64], _cg_, pp, ppf, _cf_);
   }
   function of_escaped_character(c){
    var switcher = c - 97 | 0;
    if(21 >= switcher >>> 0)
     switch(switcher){
       case 0:
        return 7;
       case 1:
        return 8;
       case 5:
        return 12;
       case 13:
        return 10;
       case 17:
        return 13;
       case 19:
        return 9;
       case 21:
        return 11;
     }
    return c;
   }
   function value_unescape(x){
    var
     len = caml_ml_string_length(x),
     res = caml_call1(Stdlib_Buffer[1], len),
     pos = [0, 0];
    for(;;){
     if(pos[1] >= len) return caml_call1(Stdlib_Buffer[2], res);
     if(92 === caml_string_get(x, pos[1]) && pos[1] < (len - 1 | 0)){
      var _cd_ = of_escaped_character(caml_string_get(x, pos[1] + 1 | 0));
      caml_call2(Stdlib_Buffer[12], res, _cd_);
      pos[1] = pos[1] + 2 | 0;
      continue;
     }
     var _ce_ = caml_string_get(x, pos[1]);
     caml_call2(Stdlib_Buffer[12], res, _ce_);
     pos[1]++;
    }
   }
   function value_compare(a, b){
    if(0 === a[0]){
     var a$0 = a[1];
     if(0 === b[0]){
      var b$0 = b[1], _ca_ = value_unescape(b$0), _cb_ = value_unescape(a$0);
      return caml_call2(Stdlib_String[10], _cb_, _ca_);
     }
     var b$1 = b[1], a$1 = a$0;
    }
    else{
     var a$2 = a[1];
     if(0 !== b[0]){
      var b$2 = b[1];
      return caml_call2(Stdlib_String[10], a$2, b$2);
     }
     var b$1 = a$2, a$1 = b[1];
    }
    var _cc_ = value_unescape(a$1);
    return caml_call2(Stdlib_String[10], _cc_, b$1);
   }
   function value_equal(a, b){
    if(0 === a[0]){
     var a$0 = a[1];
     if(0 === b[0]){
      var b$0 = b[1], _b9_ = value_unescape(b$0), _b__ = value_unescape(a$0);
      return caml_call2(Stdlib_String[9], _b__, _b9_);
     }
     var b$1 = b[1], a$1 = a$0;
    }
    else{
     var a$2 = a[1];
     if(0 !== b[0]){
      var b$2 = b[1];
      return caml_call2(Stdlib_String[9], a$2, b$2);
     }
     var b$1 = a$2, a$1 = b[1];
    }
    var _b$_ = value_unescape(a$1);
    return caml_call2(Stdlib_String[9], _b$_, b$1);
   }
   var
    compare$1 = caml_call1(Map[34], value_compare),
    equal$1 = caml_call1(Map[33], value_equal);
   function of_list(lst){
    var _b7_ = Map[1];
    function _b8_(a, param){
     var value = param[2], key = param[1];
     return caml_call3(Map[2], key, value, a);
    }
    return caml_call3(Stdlib_List[26], _b8_, _b7_, lst);
   }
   function to_list(t){return caml_call1(Map[10], t);}
   var
    default$1 = caml_call3(Map[2], cst_charset, _r_, Map[1]),
    Parameters =
      [0,
       Map,
       key,
       key_exn,
       k,
       Invalid_utf_8,
       value,
       value_exn,
       v$0,
       empty,
       mem,
       add,
       singleton,
       remove,
       find,
       iter,
       pp_key,
       pp_value,
       pp$1,
       of_escaped_character,
       value_unescape,
       value_compare,
       value_equal,
       compare$1,
       equal$1,
       of_list,
       to_list,
       default$1],
    _s_ = caml_call1(Parameters[26], Parameters[27]),
    default$2 = [0, Type[15], Subtype[9], _s_];
   function ty(param){var ty = param[1]; return ty;}
   function subty(param){var subty = param[2]; return subty;}
   function parameters(param){var parameters = param[3]; return parameters;}
   function is_discrete$0(param){
    var ty = param[1];
    return caml_call1(Type[7], ty);
   }
   function is_multipart$0(param){
    var ty = param[1];
    return caml_call1(Type[8], ty);
   }
   function with_type(t, ty){return [0, ty, t[2], t[3]];}
   function with_subtype(t, subty){return [0, t[1], subty, t[3]];}
   function with_parameter(t, param){
    var
     v = param[2],
     k = param[1],
     parameters = caml_call1(Parameters[25], [0, [0, k, v], t[3]]),
     _b6_ = caml_call1(Parameters[26], parameters);
    return [0, t[1], t[2], _b6_];
   }
   function boundary(param){
    var
     parameters = param[3],
     match = caml_call2(Stdlib_List[50], cst_boundary, parameters);
    if(! match) return 0;
    var v = match[1][1];
    return [0, v];
   }
   function make(ty, subty, parameters){
    return [0, ty, subty, caml_call1(Parameters[26], parameters)];
   }
   function pp$2(ppf, param){
    var
     parameters = param[3],
     subty = param[2],
     ty = param[1],
     _b4_ = caml_call1(Parameters[25], parameters),
     _b5_ = caml_call2(Fmt[35], 0, Parameters[18]);
    return caml_call8
            (Fmt[3], ppf, _t_, Type[11], ty, Subtype[6], subty, _b5_, _b4_);
   }
   function equal$2(a, b){
    var _bZ_ = caml_call2(Type[14], a[1], b[1]);
    if(_bZ_){
     var _b0_ = caml_call2(Subtype[8], a[2], b[2]);
     if(_b0_){
      var
       _b1_ = caml_call1(Parameters[25], b[3]),
       _b2_ = caml_call1(Parameters[25], a[3]);
      return caml_call2(Parameters[24], _b2_, _b1_);
     }
     var _b3_ = _b0_;
    }
    else
     var _b3_ = _bZ_;
    return _b3_;
   }
   function invalid_token(token){
    return caml_call3(Fmt[8], Angstrom[52], _u_, token);
   }
   function of_string(s, a){
    var match = caml_call3(Angstrom[75], 1, a, s);
    if(0 !== match[0]) return 0;
    var v = match[1];
    return [0, v];
   }
   function is_wsp(param){if(9 !== param && 32 !== param) return 0; return 1;}
   var
    token = caml_call1(Angstrom[14], is_token),
    attribute = caml_call2(Angstrom[55], token, Stdlib_String[27]),
    _v_ = caml_call1(Angstrom[4], 45);
   function _w_(param){if(88 !== param && 120 !== param) return 0; return 1;}
   var
    _x_ = caml_call1(Angstrom[7], _w_),
    _y_ = caml_call2(Angstrom[58], _x_, _v_),
    x_token = caml_call2(Angstrom[58], _y_, token);
   function _z_(param){
    a:
    if(param){
     var _bW_ = param[1];
     if(88 !== _bW_ && 120 !== _bW_) break a;
     var _bX_ = function(v){return [0, -613180270, v];};
     return caml_call2(Angstrom[55], x_token, _bX_);
    }
    function _bY_(v){return [0, 452357416, v];}
    return caml_call2(Angstrom[55], token, _bY_);
   }
   var extension_token = caml_call2(Angstrom[53], Angstrom[1], _z_);
   function _A_(s){
    var match = caml_call1(Stdlib_String[27], s);
    if(! caml_string_notequal(match, cst_application$2))
     return caml_call1(Angstrom[51], 242303792);
    if(! caml_string_notequal(match, cst_audio$2))
     return caml_call1(Angstrom[51], 984475830);
    if(! caml_string_notequal(match, cst_image$2))
     return caml_call1(Angstrom[51], -795439301);
    if(! caml_string_notequal(match, cst_multipart$2))
     return caml_call1(Angstrom[51], -1031569716);
    if(! caml_string_notequal(match, cst_text$2))
     return caml_call1(Angstrom[51], 936573133);
    if(! caml_string_notequal(match, cst_video$2))
     return caml_call1(Angstrom[51], -903248805);
    var match$0 = of_string(s, extension_token);
    if(! match$0) return invalid_token(s);
    var v = match$0[1];
    return caml_call1(Angstrom[51], v);
   }
   var ty$0 = caml_call2(Angstrom[53], token, _A_);
   function _B_(s){
    try{
     var v$0 = [0, 672582309, s], _bU_ = caml_call1(Angstrom[51], v$0);
     return _bU_;
    }
    catch(_bV_){
     var _bT_ = caml_wrap_exception(_bV_);
     if(_bT_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_bT_, 0);
     var match = of_string(s, extension_token);
     if(! match) return invalid_token(s);
     var v = match[1];
     return caml_call1(Angstrom[51], v);
    }
   }
   var subty$0 = caml_call2(Angstrom[53], token, _B_);
   function _3(x, y, z){return [0, x, y, z];}
   function _4(a, b, c, d){return [0, a, b, c, d];}
   var symbol = caml_bytes_set;
   function _C_(param){return 63 < param - 128 >>> 0 ? 0 : 1;}
   var utf_8_tail = caml_call1(Angstrom[7], _C_);
   function _D_(b0){
    function _bR_(b1){
     var res = caml_create_bytes(2);
     caml_bytes_set(res, 0, b0);
     caml_bytes_set(res, 1, b1);
     var _bS_ = caml_call1(Stdlib_Bytes[44], res);
     return caml_call1(Angstrom[51], _bS_);
    }
    return caml_call2(Angstrom[53], utf_8_tail, _bR_);
   }
   function _E_(param){return 29 < param - 194 >>> 0 ? 0 : 1;}
   var
    _F_ = caml_call1(Angstrom[7], _E_),
    utf_8_0 = caml_call2(Angstrom[53], _F_, _D_);
   function _G_(param){return 1 < param - 238 >>> 0 ? 0 : 1;}
   var
    _H_ = caml_call1(Angstrom[7], _G_),
    _I_ = caml_call4(Angstrom[62], _3, _H_, utf_8_tail, utf_8_tail);
   function _J_(param){return 31 < param - 128 >>> 0 ? 0 : 1;}
   var
    _K_ = caml_call1(Angstrom[7], _J_),
    _L_ = caml_call1(Angstrom[4], 237),
    _M_ = caml_call4(Angstrom[62], _3, _L_, _K_, utf_8_tail);
   function _N_(param){return 11 < param - 225 >>> 0 ? 0 : 1;}
   var
    _O_ = caml_call1(Angstrom[7], _N_),
    _P_ = caml_call4(Angstrom[62], _3, _O_, utf_8_tail, utf_8_tail);
   function _Q_(param){return 31 < param - 160 >>> 0 ? 0 : 1;}
   var
    _R_ = caml_call1(Angstrom[7], _Q_),
    _S_ = caml_call1(Angstrom[4], 224),
    _T_ = caml_call4(Angstrom[62], _3, _S_, _R_, utf_8_tail),
    _U_ = caml_call2(Angstrom[47], _T_, _P_),
    _V_ = caml_call2(Angstrom[47], _U_, _M_),
    utf_8_1 = caml_call2(Angstrom[47], _V_, _I_);
   function _W_(param){
    var
     b2 = param[3],
     b1 = param[2],
     b0 = param[1],
     res = caml_create_bytes(3);
    caml_bytes_set(res, 0, b0);
    caml_bytes_set(res, 1, b1);
    caml_bytes_set(res, 2, b2);
    var _bQ_ = caml_call1(Stdlib_Bytes[44], res);
    return caml_call1(Angstrom[51], _bQ_);
   }
   var utf_8_1$0 = caml_call2(Angstrom[53], utf_8_1, _W_);
   function _X_(param){return 15 < param - 128 >>> 0 ? 0 : 1;}
   var
    _Y_ = caml_call1(Angstrom[7], _X_),
    _Z_ = caml_call1(Angstrom[4], 244),
    ___ = caml_call5(Angstrom[63], _4, _Z_, _Y_, utf_8_tail, utf_8_tail);
   function _$_(param){return 2 < param - 241 >>> 0 ? 0 : 1;}
   var
    _aa_ = caml_call1(Angstrom[7], _$_),
    _ab_ =
      caml_call5(Angstrom[63], _4, _aa_, utf_8_tail, utf_8_tail, utf_8_tail);
   function _ac_(param){return 47 < param - 144 >>> 0 ? 0 : 1;}
   var
    _ad_ = caml_call1(Angstrom[7], _ac_),
    _ae_ = caml_call1(Angstrom[4], 240),
    _af_ = caml_call5(Angstrom[63], _4, _ae_, _ad_, utf_8_tail, utf_8_tail),
    _ag_ = caml_call2(Angstrom[47], _af_, _ab_),
    utf_8_2 = caml_call2(Angstrom[47], _ag_, ___);
   function _ah_(param){
    var
     b3 = param[4],
     b2 = param[3],
     b1 = param[2],
     b0 = param[1],
     res = caml_create_bytes(4);
    caml_bytes_set(res, 0, b0);
    caml_bytes_set(res, 1, b1);
    caml_bytes_set(res, 2, b2);
    caml_bytes_set(res, 3, b3);
    var _bP_ = caml_call1(Stdlib_Bytes[44], res);
    return caml_call1(Angstrom[51], _bP_);
   }
   var utf_8_2$0 = caml_call2(Angstrom[53], utf_8_2, _ah_);
   function utf_8_and(is){
    var
     _bK_ = caml_call1(Stdlib_String[1], 1),
     _bL_ = caml_call1(Angstrom[7], is),
     _bM_ = caml_call2(Angstrom[55], _bL_, _bK_),
     _bN_ = caml_call2(Angstrom[47], _bM_, utf_8_0),
     _bO_ = caml_call2(Angstrom[47], _bN_, utf_8_1$0);
    return caml_call2(Angstrom[47], _bO_, utf_8_2$0);
   }
   var
    _ai_ = caml_call1(Stdlib_String[1], 1),
    _aj_ = Parameters[19],
    _ak_ = Angstrom[6],
    _al_ = caml_call1(Angstrom[4], 92),
    _am_ = caml_call2(Angstrom[58], _al_, _ak_),
    _an_ = caml_call2(Angstrom[55], _am_, _aj_),
    quoted_pair = caml_call2(Angstrom[55], _an_, _ai_),
    _ao_ = caml_call1(Stdlib_String[7], cst),
    _ap_ = caml_call1(Angstrom[4], 34),
    _aq_ = utf_8_and(is_qtext),
    _ar_ = caml_call2(Angstrom[47], quoted_pair, _aq_),
    _as_ = caml_call1(Angstrom[38], _ar_),
    _at_ = caml_call1(Angstrom[4], 34),
    _au_ = caml_call2(Angstrom[58], _at_, _as_),
    _av_ = caml_call2(Angstrom[59], _au_, _ap_),
    quoted_string = caml_call2(Angstrom[55], _av_, _ao_);
   function _aw_(v){return [1, v];}
   var _ax_ = caml_call2(Angstrom[55], token, _aw_);
   function _ay_(v){return [0, v];}
   var
    _az_ = caml_call2(Angstrom[55], quoted_string, _ay_),
    value$0 = caml_call2(Angstrom[47], _az_, _ax_);
   function _aA_(attribute){
    function _bD_(value){return [0, attribute, value];}
    var
     _bE_ = caml_call1(Angstrom[11], is_wsp),
     _bF_ = caml_call1(Angstrom[4], 61),
     _bG_ = caml_call1(Angstrom[11], is_wsp),
     _bH_ = caml_call2(Angstrom[58], _bG_, _bF_),
     _bI_ = caml_call2(Angstrom[58], _bH_, _bE_),
     _bJ_ = caml_call2(Angstrom[58], _bI_, value$0);
    return caml_call2(Angstrom[55], _bJ_, _bD_);
   }
   var parameter = caml_call2(Angstrom[53], attribute, _aA_);
   function _aB_(ty){
    function _bo_(param){
     function _bq_(subty){
      function _bv_(parameters){return [0, ty, subty, parameters];}
      var
       _bw_ = caml_call1(Angstrom[11], is_wsp),
       _bx_ = caml_call1(Angstrom[4], 59),
       _by_ = caml_call1(Angstrom[11], is_wsp),
       _bz_ = caml_call2(Angstrom[58], _by_, _bx_),
       _bA_ = caml_call2(Angstrom[58], _bz_, _bw_),
       _bB_ = caml_call2(Angstrom[58], _bA_, parameter),
       _bC_ = caml_call1(Angstrom[38], _bB_);
      return caml_call2(Angstrom[55], _bC_, _bv_);
     }
     var
      _br_ = caml_call1(Angstrom[11], is_wsp),
      _bs_ = caml_call1(Angstrom[11], is_wsp),
      _bt_ = caml_call2(Angstrom[58], _bs_, subty$0),
      _bu_ = caml_call2(Angstrom[59], _bt_, _br_);
     return caml_call2(Angstrom[53], _bu_, _bq_);
    }
    var _bp_ = caml_call1(Angstrom[4], 47);
    return caml_call2(Angstrom[53], _bp_, _bo_);
   }
   var
    _aC_ = caml_call1(Angstrom[11], is_wsp),
    _aD_ = caml_call1(Angstrom[11], is_wsp),
    _aE_ = caml_call2(Angstrom[58], _aD_, ty$0),
    _aF_ = caml_call2(Angstrom[59], _aE_, _aC_),
    content = caml_call2(Angstrom[53], _aF_, _aB_),
    Decoder =
      [0,
       invalid_token,
       of_string,
       is_wsp,
       token,
       attribute,
       token,
       x_token,
       extension_token,
       ty$0,
       subty$0,
       _3,
       _4,
       symbol,
       utf_8_tail,
       utf_8_0,
       utf_8_1$0,
       utf_8_2$0,
       utf_8_and,
       quoted_pair,
       quoted_string,
       value$0,
       parameter,
       content];
   function of_string$0(str){
    var symbol_bind = Stdlib_Result[6];
    function symbol_map(x, f){return caml_call2(Stdlib_Result[8], f, x);}
    function _bk_(str){
     var match = caml_call3(Angstrom[75], 0, Decoder[23], str);
     if(0 !== match[0]) return caml_call1(error_msgf(_aG_), str);
     var v = match[1];
     return [0, v];
    }
    var arg = Unstrctrd[7];
    function _bl_(eta){return caml_call2(arg, 0, eta);}
    var _bm_ = Unstrctrd[14];
    function _bn_(param){
     var v = param[2];
     return caml_call1(Unstrctrd[15], v);
    }
    return caml_call2
            (symbol_bind,
             symbol_map
              (caml_call2
                (symbol_bind,
                 symbol_map(caml_call1(Unstrctrd[3], str), _bn_),
                 _bm_),
               _bl_),
             _bk_);
   }
   function ty$1(ppf, param){
    if(typeof param === "number")
     return -412983897 <= param
             ? 936573133
               <= param
               ? 984475830
                 <= param
                 ? caml_call2(Prettym[17], ppf, cst_audio$1)
                 : caml_call2(Prettym[17], ppf, cst_text$1)
               : 242303792
                 <= param
                 ? caml_call2(Prettym[17], ppf, cst_application$1)
                 : caml_call2(Prettym[17], ppf, cst_message)
             : -903248805
               === param
               ? caml_call2(Prettym[17], ppf, cst_video$1)
               : -795439301
                 <= param
                 ? caml_call2(Prettym[17], ppf, cst_image$1)
                 : caml_call2(Prettym[17], ppf, cst_multipart$1);
    if(452357416 <= param[1]){
     var v = param[2];
     return caml_call2(Prettym[17], ppf, v);
    }
    var v$0 = param[2], _bi_ = Prettym[17];
    function _bj_(v){return caml_call2(Stdlib[28], cst_X, v);}
    return caml_call4(Prettym[16], _bj_, _bi_, ppf, v$0);
   }
   function subty$1(ppf, param){
    var _bf_ = param[1];
    if(452357416 === _bf_){
     var v = param[2];
     return caml_call2(Prettym[17], ppf, v);
    }
    if(672582309 <= _bf_){
     var v$0 = param[2];
     return caml_call2(Prettym[17], ppf, v$0);
    }
    var v$1 = param[2], _bg_ = Prettym[17];
    function _bh_(v){return caml_call2(Stdlib[28], cst_X$0, v);}
    return caml_call4(Prettym[16], _bh_, _bg_, ppf, v$1);
   }
   function value$1(ppf, param){
    if(0 === param[0]){
     var
      x = param[1],
      _bb_ = [0, caml_call2(Prettym[10], Prettym[21], 34), 0],
      _bc_ = [0, caml_call1(Prettym[9], Prettym[17]), _bb_],
      _bd_ = [0, caml_call2(Prettym[10], Prettym[21], 34), _bc_];
     return caml_call3(Prettym[26], ppf, _bd_, x);
    }
    var x$0 = param[1], _be_ = [0, caml_call1(Prettym[9], Prettym[17]), 0];
    return caml_call3(Prettym[26], ppf, _be_, x$0);
   }
   function parameter$0(ppf, param){
    var
     v = param[2],
     key = param[1],
     _a7_ = [0, Prettym[15], 0],
     _a8_ = [0, caml_call1(Prettym[9], value$1), _a7_],
     _a9_ = [0, Prettym[5], _a8_],
     _a__ = [0, caml_call2(Prettym[10], Prettym[21], 61), _a9_],
     _a$_ = [0, Prettym[5], _a__],
     _ba_ = [0, caml_call1(Prettym[9], Prettym[17]), _a$_];
    return caml_call4(Prettym[26], ppf, [0, Prettym[14], _ba_], key, v);
   }
   function parameters$0(ppf, parameters){
    function sep(ppf, param){
     var
      _a5_ = [0, Prettym[3], 0],
      _a6_ = [0, caml_call2(Prettym[10], Prettym[21], 59), _a5_];
     return caml_call2(Prettym[26], ppf, _a6_);
    }
    var
     _a2_ = [0, Prettym[15], 0],
     _a3_ = caml_call2(Prettym[22], [0, sep, 0], parameter$0),
     _a4_ = [0, caml_call1(Prettym[9], _a3_), _a2_];
    return caml_call3(Prettym[26], ppf, [0, Prettym[14], _a4_], parameters);
   }
   function content_type(ppf, t){
    if(t[3]){
     var
      _aH_ = t[3],
      _aI_ = t[2],
      _aJ_ = t[1],
      _aK_ = [0, Prettym[15], 0],
      _aL_ = [0, caml_call1(Prettym[9], parameters$0), _aK_],
      _aM_ = [0, Prettym[3], _aL_],
      _aN_ = [0, caml_call2(Prettym[10], Prettym[21], 59), _aM_],
      _aO_ = [0, Prettym[5], _aN_],
      _aP_ = [0, caml_call1(Prettym[9], subty$1), _aO_],
      _aQ_ = [0, Prettym[5], _aP_],
      _aR_ = [0, caml_call2(Prettym[10], Prettym[21], 47), _aQ_],
      _aS_ = [0, Prettym[5], _aR_],
      _aT_ = [0, caml_call1(Prettym[9], ty$1), _aS_];
     return caml_call5
             (Prettym[26], ppf, [0, Prettym[13], _aT_], _aJ_, _aI_, _aH_);
    }
    var
     _aU_ = t[2],
     _aV_ = t[1],
     _aW_ = [0, Prettym[15], 0],
     _aX_ = [0, caml_call1(Prettym[9], subty$1), _aW_],
     _aY_ = [0, Prettym[5], _aX_],
     _aZ_ = [0, caml_call2(Prettym[10], Prettym[21], 47), _aY_],
     _a0_ = [0, Prettym[5], _aZ_],
     _a1_ = [0, caml_call1(Prettym[9], ty$1), _a0_];
    return caml_call4(Prettym[26], ppf, [0, Prettym[13], _a1_], _aV_, _aU_);
   }
   var
    Encoder =
      [0, ty$1, subty$1, value$1, parameter$0, parameters$0, content_type];
   function to_string$0(v){
    return caml_call4(Prettym[34], 0, 0, Encoder[6], v);
   }
   var
    Multipart_form_Content_type =
      [0,
       error_msgf,
       Invalid_token,
       is_tspecials,
       is_ctl,
       is_space,
       is_ascii,
       is_token,
       is_obs_no_ws_ctl,
       is_qtext,
       Type,
       Subtype,
       Parameters,
       default$2,
       ty,
       subty,
       parameters,
       is_discrete$0,
       is_multipart$0,
       with_type,
       with_subtype,
       with_parameter,
       boundary,
       make,
       pp$2,
       equal$2,
       Decoder,
       of_string$0,
       Encoder,
       to_string$0];
   runtime.caml_register_global
    (66, Multipart_form_Content_type, "Multipart_form__Content_type");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Multipart_form__Content_disposition
//# unitInfo: Requires: Angstrom, Fmt, Multipart_form__Content_type, Prettym, Stdlib, Stdlib__List, Stdlib__Result, Stdlib__String, Unstrctrd
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_date = "#date",
    cst_hov = "<hov>",
    cst = "@ ",
    cst_X$0 = "X-",
    cst_attachment$1 = "attachment",
    cst_filename$1 = "filename",
    cst_inline$1 = "inline",
    cst_name$1 = "name",
    cst_nothing_to_do = "nothing to do",
    cst_parameters = "parameters",
    cst_read_date$1 = "read-date",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call16
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15){
    return (f.l >= 0 ? f.l : f.l = f.length) == 16
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    partial = [11, " }", 0],
    partial$0 =
      [17,
       [0, cst, 1, 0],
       [11,
        "size= ",
        [15,
         [12,
          59,
          [17,
           [0, cst, 1, 0],
           [11,
            "parameters= ",
            [18,
             [1, [0, [11, cst_hov, 0], cst_hov]],
             [15, [17, 0, [12, 59, [17, 0, partial]]]]]]]]]]],
    partial$1 =
      [11,
       "creation= ",
       [15,
        [12,
         59,
         [17,
          [0, cst, 1, 0],
          [11,
           "modification= ",
           [15,
            [12,
             59,
             [17, [0, cst, 1, 0], [11, "read= ", [15, [12, 59, partial$0]]]]]]]]]]],
    partial$2 = [0, cst, 1, 0],
    Prettym = global_data.Prettym,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Unstrctrd = global_data.Unstrctrd,
    Angstrom = global_data.Angstrom,
    Stdlib_Result = global_data.Stdlib__Result,
    Stdlib_String = global_data.Stdlib__String,
    Fmt = global_data.Fmt,
    Multipart_form_Content_type = global_data.Multipart_form__Content_type,
    cst_filename$0 = cst_filename$1,
    cst_size = "size",
    cst_attachment$0 = cst_attachment$1,
    cst_inline$0 = cst_inline$1,
    cst_X = cst_X$0,
    _T_ =
      [0,
       [11, "Invalid (unfolded) Content-Disposition value: ", [3, 0, 0]],
       "Invalid (unfolded) Content-Disposition value: %S"],
    _j_ = [0, [11, "invalid token: ", [2, 0, 0]], "invalid token: %s"],
    cst_name$0 = cst_name$1,
    _e_ = [0, [11, cst_parameters, 0], cst_parameters],
    _f_ = [0, [11, cst_date, 0], cst_date],
    _g_ = [0, [11, cst_date, 0], cst_date],
    _h_ = [0, [11, cst_date, 0], cst_date],
    _i_ =
      [0,
       [11,
        "{ ",
        [18,
         [1, [0, [11, cst_hov, 0], cst_hov]],
         [11,
          "type= ",
          [15,
           [12,
            59,
            [17,
             [0, cst, 1, 0],
             [11, "filename= ", [15, [12, 59, [17, partial$2, partial$1]]]]]]]]]],
       "{ @[<hov>type= %a;@ filename= %a;@ creation= %a;@ modification= %a;@ read= %a;@ size= %a;@ parameters= @[<hov>%a@];@] }"],
    _d_ = [0, [3, 0, 0], "%S"],
    cst_attachment = cst_attachment$1,
    cst_inline = cst_inline$1,
    _b_ = [0, [11, "<ietf:", [2, 0, [12, 62, 0]]], "<ietf:%s>"],
    _c_ = [0, [11, cst_X$0, [2, 0, 0]], "X-%s"],
    _a_ = [0, 452357416, "form-data"],
    cst_name = cst_name$1,
    _k_ = [0, [11, cst_nothing_to_do, 0], cst_nothing_to_do],
    cst_filename = cst_filename$1,
    cst_creation_date = "creation-date",
    cst_modification_date = "modification-date",
    cst_read_date = cst_read_date$1,
    cst_read_date$0 = cst_read_date$1;
   function error_msgf(fmt){
    function _by_(msg){return [1, [0, 3854881, msg]];}
    return caml_call2(Fmt[8], _by_, fmt);
   }
   function v(filename, opt, size, name){
    if(opt) var sth = opt[1], kind = sth; else var kind = _a_;
    return [0,
            kind,
            filename,
            0,
            0,
            0,
            size,
            [0, [0, cst_name, [0, name]], 0]];
   }
   function pp_disposition_type(ppf, param){
    if(typeof param === "number")
     return -735835133 <= param
             ? caml_call2(Fmt[57], ppf, cst_attachment)
             : caml_call2(Fmt[57], ppf, cst_inline);
    if(452357416 <= param[1]){
     var v = param[2];
     return caml_call3(Fmt[3], ppf, _b_, v);
    }
    var v$0 = param[2];
    return caml_call3(Fmt[3], ppf, _c_, v$0);
   }
   function pp_value(ppf, param){
    if(0 === param[0]){
     var v = param[1];
     return caml_call3(Fmt[3], ppf, _d_, v);
    }
    var v$0 = param[1];
    return caml_call2(Fmt[57], ppf, v$0);
   }
   function pp(ppf, t){
    var _bf_ = t[7], _bg_ = Fmt[57], _bh_ = caml_call1(Fmt[18], _e_);
    function _bi_(f){
     function _bx_(param){
      var v = param[2], k = param[1];
      return caml_call2(f, k, v);
     }
     return caml_call1(Stdlib_List[18], _bx_);
    }
    var
     _bj_ = caml_call4(Fmt[70][16], _bi_, _bh_, _bg_, pp_value),
     _bk_ = t[6],
     _bl_ = caml_call2(Fmt[62], 0, Fmt[45]),
     _bm_ = t[5],
     _bn_ = caml_call1(Fmt[18], _f_),
     _bo_ = caml_call2(Fmt[62], 0, _bn_),
     _bp_ = t[4],
     _bq_ = caml_call1(Fmt[18], _g_),
     _br_ = caml_call2(Fmt[62], 0, _bq_),
     _bs_ = t[3],
     _bt_ = caml_call1(Fmt[18], _h_),
     _bu_ = caml_call2(Fmt[62], 0, _bt_),
     _bv_ = t[2],
     _bw_ = caml_call2(Fmt[62], 0, Fmt[57]);
    return caml_call16
            (Fmt[3],
             ppf,
             _i_,
             pp_disposition_type,
             t[1],
             _bw_,
             _bv_,
             _bu_,
             _bs_,
             _br_,
             _bp_,
             _bo_,
             _bm_,
             _bl_,
             _bk_,
             _bj_,
             _bf_);
   }
   function name(t){
    var match = caml_call2(Stdlib_List[50], cst_name$0, t[7]);
    if(! match) return 0;
    var v = match[1][1];
    return [0, v];
   }
   function filename(param){var filename = param[2]; return filename;}
   function size(param){var size = param[6]; return size;}
   function disposition_type(param){var ty = param[1]; return ty;}
   function of_escaped_character(c){
    var switcher = c - 97 | 0;
    if(21 >= switcher >>> 0)
     switch(switcher){
       case 0:
        return 7;
       case 1:
        return 8;
       case 5:
        return 12;
       case 13:
        return 10;
       case 17:
        return 13;
       case 19:
        return 9;
       case 21:
        return 11;
     }
    return c;
   }
   function is_obs_no_ws_ctl(param){
    a:
    {
     if(13 <= param){
      if(32 <= param){
       if(127 === param) break a;
      }
      else if(14 <= param) break a;
     }
     else
      if(9 <= param){if(11 <= param) break a;} else if(param) break a;
     return 0;
    }
    return 1;
   }
   function is_qtext(c){
    var _be_ = c - 35 | 0;
    a:
    {
     if(91 < _be_ >>> 0){
      if(-2 !== _be_) break a;
     }
     else if(57 === _be_) break a;
     return 1;
    }
    return is_obs_no_ws_ctl(c);
   }
   function is_wsp(param){if(9 !== param && 32 !== param) return 0; return 1;}
   function is_tspecials(param){
    var _bd_ = param - 34 | 0;
    a:
    {
     if(30 < _bd_ >>> 0){
      if(2 < _bd_ - 57 >>> 0) break a;
     }
     else if(24 > _bd_)
      switch(_bd_){
        case 0:
        case 6:
        case 7:
        case 10:
        case 13: break;
        default: break a;
      }
     return 1;
    }
    return 0;
   }
   function invalid_token(token){
    return caml_call3(Fmt[8], Angstrom[52], _j_, token);
   }
   var nothing_to_do = caml_call2(Fmt[8], Angstrom[52], _k_);
   function is_ctl(param){
    if(127 !== param && 32 <= param) return 0;
    return 1;
   }
   function is_space(_bc_){return 32 === _bc_ ? 1 : 0;}
   function is_ascii(param){return 128 <= param ? 0 : 1;}
   function is_token(c){
    var _a__ = is_ascii(c);
    if(_a__){
     var _a$_ = 1 - is_tspecials(c);
     if(_a$_)
      var _ba_ = 1 - is_ctl(c), _bb_ = _ba_ ? 1 - (32 === c ? 1 : 0) : _ba_;
     else
      var _bb_ = _a$_;
    }
    else
     var _bb_ = _a__;
    return _bb_;
   }
   var token = caml_call1(Angstrom[14], is_token);
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   var
    attribute = caml_call2(Angstrom[55], token, Stdlib_String[27]),
    _l_ = caml_call1(Angstrom[4], 45);
   function _m_(param){if(88 !== param && 120 !== param) return 0; return 1;}
   var
    _n_ = caml_call1(Angstrom[7], _m_),
    _o_ = caml_call2(Angstrom[58], _n_, _l_),
    x_token = caml_call2(Angstrom[58], _o_, token);
   function _p_(param){
    a:
    if(param){
     var _a7_ = param[1];
     if(88 !== _a7_ && 120 !== _a7_) break a;
     var _a8_ = function(v){return [0, -613180270, v];};
     return caml_call2(Angstrom[55], x_token, _a8_);
    }
    function _a9_(v){return [0, 452357416, v];}
    return caml_call2(Angstrom[55], token, _a9_);
   }
   var extension_token = caml_call2(Angstrom[53], Angstrom[1], _p_);
   function _q_(v){return [1, v];}
   var _r_ = caml_call2(Angstrom[55], token, _q_);
   function _s_(v){return [0, v];}
   var
    _t_ = caml_call2(Angstrom[55], Multipart_form_Content_type[26][20], _s_),
    value = caml_call2(Angstrom[47], _t_, _r_);
   function of_string(s, a){
    var match = caml_call3(Angstrom[75], 1, a, s);
    if(0 !== match[0]) return 0;
    var v = match[1];
    return [0, v];
   }
   function _u_(s){
    var match = caml_call1(Stdlib_String[27], s);
    if(! caml_string_notequal(match, cst_attachment$1))
     return caml_call1(Angstrom[51], -735835133);
    if(! caml_string_notequal(match, cst_inline$1))
     return caml_call1(Angstrom[51], -841728391);
    var match$0 = of_string(s, extension_token);
    if(! match$0) return invalid_token(s);
    var v = match$0[1];
    return caml_call1(Angstrom[51], v);
   }
   var disposition_type$0 = caml_call2(Angstrom[53], token, _u_);
   function _v_(attribute){
    function _a0_(value){return [0, attribute, value];}
    var
     _a1_ = caml_call1(Angstrom[11], is_wsp),
     _a2_ = caml_call1(Angstrom[4], 61),
     _a3_ = caml_call1(Angstrom[11], is_wsp),
     _a4_ = caml_call2(Angstrom[58], _a3_, _a2_),
     _a5_ = caml_call2(Angstrom[58], _a4_, _a1_),
     _a6_ = caml_call2(Angstrom[58], _a5_, value);
    return caml_call2(Angstrom[55], _a6_, _a0_);
   }
   var parameter = caml_call2(Angstrom[53], attribute, _v_);
   function _w_(param){return 0;}
   var quoted_date_time = caml_call2(Angstrom[55], value, _w_);
   function parm(parm, value){
    var
     _aT_ = caml_call1(Angstrom[11], is_wsp),
     _aU_ = caml_call1(Angstrom[4], 61),
     _aV_ = caml_call1(Angstrom[11], is_wsp),
     _aW_ = caml_call1(Angstrom[8], parm),
     _aX_ = caml_call2(Angstrom[58], _aW_, _aV_),
     _aY_ = caml_call2(Angstrom[58], _aX_, _aU_),
     _aZ_ = caml_call2(Angstrom[58], _aY_, _aT_);
    return caml_call2(Angstrom[58], _aZ_, value);
   }
   var
    filename_parm = parm(cst_filename, value),
    creation_date_parm = parm(cst_creation_date, quoted_date_time),
    modification_date_parm = parm(cst_modification_date, quoted_date_time),
    read_date_parm = parm(cst_read_date, quoted_date_time),
    _x_ = caml_call1(Angstrom[14], is_digit),
    size_parm =
      parm
       (cst_read_date$0,
        caml_call2(Angstrom[55], _x_, runtime.caml_int_of_string));
   function _y_(v){return [5, v];}
   var _z_ = caml_call2(Angstrom[55], parameter, _y_);
   function _A_(v){return [4, v];}
   var _B_ = caml_call2(Angstrom[55], size_parm, _A_);
   function _C_(v){return [3, v];}
   var _D_ = caml_call2(Angstrom[55], read_date_parm, _C_);
   function _E_(v){return [2, v];}
   var _F_ = caml_call2(Angstrom[55], modification_date_parm, _E_);
   function _G_(v){return [1, v];}
   var _H_ = caml_call2(Angstrom[55], creation_date_parm, _G_);
   function _I_(v){return [0, v];}
   var
    _J_ = caml_call2(Angstrom[55], filename_parm, _I_),
    _K_ = caml_call2(Angstrom[47], _J_, _H_),
    _L_ = caml_call2(Angstrom[47], _K_, _F_),
    _M_ = caml_call2(Angstrom[47], _L_, _D_),
    _N_ = caml_call2(Angstrom[47], _M_, _B_),
    disposition_parm = caml_call2(Angstrom[47], _N_, _z_);
   function _O_(ty){
    function _aJ_(parameters){
     var
      filename = [0, 0],
      creation = [0, 0],
      modification = [0, 0],
      read = [0, 0],
      size = [0, 0],
      _aR_ = 0;
     function _aS_(a, param){
      switch(param[0]){
        case 0:
         var v = param[1][1]; filename[1] = [0, v]; return a;
        case 1:
         var v$0 = param[1]; creation[1] = [0, v$0]; return a;
        case 2:
         var v$1 = param[1]; modification[1] = [0, v$1]; return a;
        case 3:
         var v$2 = param[1]; read[1] = [0, v$2]; return a;
        case 4:
         var v$3 = param[1]; size[1] = [0, v$3]; return a;
        default: var v$4 = param[1]; return [0, v$4, a];
      }
     }
     var parameters$0 = caml_call3(Stdlib_List[26], _aS_, _aR_, parameters);
     return caml_call1
             (Angstrom[51],
              [0,
               ty,
               filename[1],
               creation[1],
               modification[1],
               read[1],
               size[1],
               parameters$0]);
    }
    var
     _aK_ = caml_call1(Angstrom[11], is_wsp),
     _aL_ = caml_call1(Angstrom[4], 59),
     _aM_ = caml_call1(Angstrom[11], is_wsp),
     _aN_ = caml_call2(Angstrom[58], _aM_, _aL_),
     _aO_ = caml_call2(Angstrom[58], _aN_, _aK_),
     _aP_ = caml_call2(Angstrom[58], _aO_, disposition_parm),
     _aQ_ = caml_call1(Angstrom[38], _aP_);
    return caml_call2(Angstrom[53], _aQ_, _aJ_);
   }
   var
    _P_ = caml_call1(Angstrom[11], is_wsp),
    _Q_ = caml_call1(Angstrom[11], is_wsp),
    _R_ = caml_call2(Angstrom[58], _Q_, disposition_type$0),
    _S_ = caml_call2(Angstrom[59], _R_, _P_),
    disposition = caml_call2(Angstrom[53], _S_, _O_),
    Decoder =
      [0,
       is_tspecials,
       invalid_token,
       nothing_to_do,
       is_ctl,
       is_space,
       is_ascii,
       is_token,
       token,
       is_digit,
       attribute,
       token,
       x_token,
       extension_token,
       value,
       of_string,
       disposition_type$0,
       parameter,
       quoted_date_time,
       parm,
       filename_parm,
       creation_date_parm,
       modification_date_parm,
       read_date_parm,
       size_parm,
       disposition_parm,
       disposition];
   function of_string$0(str){
    var symbol_bind = Stdlib_Result[6];
    function symbol_map(x, f){return caml_call2(Stdlib_Result[8], f, x);}
    function _aG_(str){
     var match = caml_call3(Angstrom[75], 1, Decoder[26], str);
     if(0 !== match[0]) return caml_call1(error_msgf(_T_), str);
     var v = match[1];
     return [0, v];
    }
    var arg = Unstrctrd[7];
    function _aH_(eta){return caml_call2(arg, 0, eta);}
    function _aI_(param){
     var v = param[2];
     return caml_call1(Unstrctrd[15], v);
    }
    return caml_call2
            (symbol_bind,
             symbol_map(symbol_map(caml_call1(Unstrctrd[3], str), _aI_), _aH_),
             _aG_);
   }
   function disposition_type$1(ppf, param){
    if(typeof param === "number"){
     if(-735835133 <= param){
      var
       _aB_ = [0, caml_call2(Prettym[10], Prettym[17], cst_attachment$0), 0];
      return caml_call2(Prettym[26], ppf, _aB_);
     }
     var _aC_ = [0, caml_call2(Prettym[10], Prettym[17], cst_inline$0), 0];
     return caml_call2(Prettym[26], ppf, _aC_);
    }
    if(452357416 <= param[1]){
     var v = param[2], _aD_ = [0, caml_call1(Prettym[9], Prettym[17]), 0];
     return caml_call3(Prettym[26], ppf, _aD_, v);
    }
    var
     v$0 = param[2],
     _aE_ = [0, caml_call1(Prettym[9], Prettym[17]), 0],
     _aF_ = [0, caml_call2(Prettym[10], Prettym[17], cst_X), _aE_];
    return caml_call3(Prettym[26], ppf, _aF_, v$0);
   }
   function token$0(ppf, str){
    var _aA_ = [0, caml_call1(Prettym[9], Prettym[17]), 0];
    return caml_call3(Prettym[26], ppf, _aA_, str);
   }
   function value$0(ppf, param){
    if(0 === param[0]){
     var
      v = param[1],
      _ax_ = [0, caml_call2(Prettym[10], Prettym[21], 34), 0],
      _ay_ = [0, caml_call1(Prettym[9], Prettym[17]), _ax_],
      _az_ = [0, caml_call2(Prettym[10], Prettym[21], 34), _ay_];
     return caml_call3(Prettym[26], ppf, _az_, v);
    }
    var v$0 = param[1];
    return token$0(ppf, v$0);
   }
   function disposition_parm$0(ppf, param){
    var v = param[1];
    switch(v[1]){
      case 0:
       var match = v[2];
       if(! match) return ppf;
       var
        v$0 = match[1],
        _ad_ = [0, Prettym[3], 0],
        _ae_ = [0, caml_call2(Prettym[10], Prettym[21], 59), _ad_],
        _af_ = [0, caml_call1(Prettym[9], token$0), _ae_],
        _ag_ = [0, caml_call2(Prettym[10], Prettym[21], 61), _af_],
        _ah_ = [0, Prettym[5], _ag_],
        _ai_ = [0, caml_call2(Prettym[10], Prettym[17], cst_filename$0), _ah_];
       return caml_call3(Prettym[26], ppf, _ai_, v$0);
      case 1:
       return ppf;
      case 2:
       return ppf;
      case 3:
       return ppf;
      case 4:
       var match$0 = v[2];
       if(! match$0) return ppf;
       var
        v$1 = match$0[1],
        _aj_ = caml_call1(Stdlib[33], v$1),
        _ak_ = [0, Prettym[3], 0],
        _al_ = [0, caml_call2(Prettym[10], Prettym[21], 59), _ak_],
        _am_ = [0, caml_call1(Prettym[9], Prettym[17]), _al_],
        _an_ = [0, caml_call2(Prettym[10], Prettym[21], 61), _am_],
        _ao_ = [0, Prettym[5], _an_],
        _ap_ = [0, caml_call2(Prettym[10], Prettym[17], cst_size), _ao_];
       return caml_call3(Prettym[26], ppf, _ap_, _aj_);
      default:
       var _aq_ = v[2];
       if(! _aq_) return ppf;
       var
        match$1 = _aq_[1],
        v$2 = match$1[2],
        k = match$1[1],
        _ar_ = [0, Prettym[3], 0],
        _as_ = [0, caml_call2(Prettym[10], Prettym[21], 59), _ar_],
        _at_ = [0, caml_call1(Prettym[9], value$0), _as_],
        _au_ = [0, caml_call2(Prettym[10], Prettym[21], 61), _at_],
        _av_ = [0, Prettym[5], _au_],
        _aw_ = [0, caml_call1(Prettym[9], Prettym[17]), _av_];
       return caml_call4(Prettym[26], ppf, _aw_, k, v$2);
    }
   }
   function disposition$0(ppf, v){
    function sep(ppf, param){
     return caml_call2(Prettym[26], ppf, [0, Prettym[5], 0]);
    }
    var _U_ = v[7];
    function _V_(param){
     var v = param[2], k = param[1];
     return [0, [0, 5, [0, [0, k, v]]]];
    }
    var
     _W_ = caml_call2(Stdlib_List[20], _V_, _U_),
     _X_ =
       caml_call2
        (Stdlib[37],
         [0,
          [0, [0, 0, v[2]]],
          [0,
           [0, [0, 1, v[3]]],
           [0,
            [0, [0, 2, v[4]]],
            [0, [0, [0, 3, v[5]]], [0, [0, [0, 4, v[6]]], 0]]]]],
         _W_),
     _Y_ = v[1],
     _Z_ = caml_call2(Prettym[22], [0, sep, 0], disposition_parm$0),
     ___ = [0, caml_call1(Prettym[9], _Z_), 0],
     _$_ = [0, Prettym[3], ___],
     _aa_ = [0, caml_call2(Prettym[10], Prettym[21], 59), _$_],
     _ab_ = [0, Prettym[5], _aa_],
     _ac_ = [0, caml_call1(Prettym[9], disposition_type$1), _ab_];
    return caml_call4(Prettym[26], ppf, _ac_, _Y_, _X_);
   }
   var
    Encoder =
      [0,
       disposition_type$1,
       token$0,
       value$0,
       disposition_parm$0,
       disposition$0];
   function to_string(v){return caml_call4(Prettym[34], 0, 0, Encoder[5], v);}
   var
    Multipart_form_Content_disposi =
      [0,
       error_msgf,
       v,
       pp_disposition_type,
       pp_value,
       pp,
       name,
       filename,
       size,
       disposition_type,
       of_escaped_character,
       is_obs_no_ws_ctl,
       is_qtext,
       is_wsp,
       Decoder,
       of_string$0,
       Encoder,
       to_string];
   runtime.caml_register_global
    (37,
     Multipart_form_Content_disposi,
     "Multipart_form__Content_disposition");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Multipart_form__Content_encoding
//# unitInfo: Requires: Angstrom, Fmt, Prettym, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_7bit$1 = "7bit",
    cst_8bit$1 = "8bit",
    cst_base64$1 = "base64",
    cst_binary$1 = "binary",
    cst_quoted_printable$1 = "quoted-printable",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Prettym = global_data.Prettym,
    Stdlib_String = global_data.Stdlib__String,
    Angstrom = global_data.Angstrom,
    Fmt = global_data.Fmt,
    cst_8bit$0 = cst_8bit$1,
    cst_7bit$0 = cst_7bit$1,
    cst_binary$0 = cst_binary$1,
    cst_base64$0 = cst_base64$1,
    cst_quoted_printable$0 = cst_quoted_printable$1,
    cst_X = "X-",
    _i_ = [0, [11, "invalid token: ", [2, 0, 0]], "invalid token: %s"],
    _d_ = [0, 456100816],
    _e_ = [0, 564146209],
    _f_ = [0, 163344815],
    _g_ = [0, 737158891],
    _h_ = [0, 737158890],
    _c_ =
      [0,
       [11, "Invalid MIME encoding: ", [2, 0, 0]],
       "Invalid MIME encoding: %s"],
    cst_8bit = cst_8bit$1,
    cst_7bit = cst_7bit$1,
    cst_binary = cst_binary$1,
    cst_base64 = cst_base64$1,
    cst_quoted_printable = cst_quoted_printable$1,
    _a_ = [0, [11, "ietf:", [2, 0, 0]], "ietf:%s"],
    _b_ = [0, [11, "x:", [2, 0, 0]], "x:%s"];
   function error_msgf(fmt){
    function _J_(msg){return [1, [0, 3854881, msg]];}
    return caml_call2(Fmt[8], _J_, fmt);
   }
   function pp(ppf, param){
    if(typeof param === "number")
     return 456100816 === param
             ? caml_call2(Fmt[57], ppf, cst_quoted_printable)
             : 737158890
               <= param
               ? 737158891
                 <= param
                 ? caml_call2(Fmt[57], ppf, cst_8bit)
                 : caml_call2(Fmt[57], ppf, cst_7bit)
               : 564146209
                 <= param
                 ? caml_call2(Fmt[57], ppf, cst_binary)
                 : caml_call2(Fmt[57], ppf, cst_base64);
    if(452357416 <= param[1]){
     var token = param[2];
     return caml_call3(Fmt[3], ppf, _a_, token);
    }
    var token$0 = param[2];
    return caml_call3(Fmt[3], ppf, _b_, token$0);
   }
   var
    default$0 = 737158890,
    bit8 = 737158891,
    bit7 = 737158890,
    binary = 564146209,
    quoted_printable = 456100816,
    base64 = 163344815;
   function of_string(x){
    return caml_string_notequal(x, cst_7bit$1)
            ? caml_string_notequal
               (x, cst_8bit$1)
              ? caml_string_notequal
                 (x, cst_base64$1)
                ? caml_string_notequal
                   (x, cst_binary$1)
                  ? caml_string_notequal
                     (x, cst_quoted_printable$1)
                    ? caml_call1(error_msgf(_c_), x)
                    : _d_
                  : _e_
                : _f_
              : _g_
            : _h_;
   }
   function equal(a, b){
    if(typeof a === "number"){
     if(564146209 <= a){
      if(737158890 === a){
       if(typeof b === "number" && 737158890 === b) return 1;
      }
      else
       if(737158891 === a){
        if(typeof b === "number" && 737158891 === b) return 1;
       }
       else if(564146210 > a && typeof b === "number" && 564146209 === b)
        return 1;
     }
     else
      if(163344815 === a){
       if(typeof b === "number" && 163344815 === b) return 1;
      }
      else if(456100816 === a && typeof b === "number" && 456100816 === b)
       return 1;
    }
    else{
     var _E_ = a[1];
     if(-613180270 === _E_){
      if(typeof b !== "number" && -613180270 === b[1]){
       var
        b$0 = b[2],
        a$0 = a[2],
        _F_ = caml_call1(Stdlib_String[27], b$0),
        _G_ = caml_call1(Stdlib_String[27], a$0);
       return caml_call2(Stdlib_String[9], _G_, _F_);
      }
     }
     else if(452357416 === _E_ && typeof b !== "number" && 452357416 === b[1]){
      var
       b$1 = b[2],
       a$1 = a[2],
       _H_ = caml_call1(Stdlib_String[27], b$1),
       _I_ = caml_call1(Stdlib_String[27], a$1);
      return caml_call2(Stdlib_String[9], _I_, _H_);
     }
    }
    return 0;
   }
   function invalid_token(token){
    return caml_call3(Fmt[8], Angstrom[52], _i_, token);
   }
   function of_string$0(s, a){
    var match = caml_call3(Angstrom[75], 1, a, s);
    if(0 !== match[0]) return 0;
    var v = match[1];
    return [0, v];
   }
   function is_tspecials(param){
    var _D_ = param - 34 | 0;
    a:
    {
     if(30 < _D_ >>> 0){
      if(2 < _D_ - 57 >>> 0) break a;
     }
     else if(24 > _D_)
      switch(_D_){
        case 0:
        case 6:
        case 7:
        case 10:
        case 13: break;
        default: break a;
      }
     return 1;
    }
    return 0;
   }
   function is_ctl(param){
    if(127 !== param && 32 <= param) return 0;
    return 1;
   }
   function is_space(_C_){return 32 === _C_ ? 1 : 0;}
   function is_ascii(param){return 128 <= param ? 0 : 1;}
   function is_token(c){
    var _y_ = is_ascii(c);
    if(_y_){
     var _z_ = 1 - is_tspecials(c);
     if(_z_)
      var _A_ = 1 - is_ctl(c), _B_ = _A_ ? 1 - (32 === c ? 1 : 0) : _A_;
     else
      var _B_ = _z_;
    }
    else
     var _B_ = _y_;
    return _B_;
   }
   var
    token = caml_call1(Angstrom[14], is_token),
    _j_ = caml_call1(Angstrom[4], 45);
   function _k_(param){if(88 !== param && 120 !== param) return 0; return 1;}
   var
    _l_ = caml_call1(Angstrom[7], _k_),
    _m_ = caml_call2(Angstrom[58], _l_, _j_),
    x_token = caml_call2(Angstrom[58], _m_, token);
   function _n_(param){
    a:
    if(param){
     var _v_ = param[1];
     if(88 !== _v_ && 120 !== _v_) break a;
     var _w_ = function(v){return [0, -613180270, v];};
     return caml_call2(Angstrom[55], x_token, _w_);
    }
    function _x_(v){return [0, 452357416, v];}
    return caml_call2(Angstrom[55], token, _x_);
   }
   var extension_token = caml_call2(Angstrom[53], Angstrom[1], _n_);
   function is_wsp(param){if(9 !== param && 32 !== param) return 0; return 1;}
   function _o_(s){
    var match = caml_call1(Stdlib_String[27], s);
    if(! caml_string_notequal(match, cst_7bit$1))
     return caml_call1(Angstrom[51], 737158890);
    if(! caml_string_notequal(match, cst_8bit$1))
     return caml_call1(Angstrom[51], 737158891);
    if(! caml_string_notequal(match, cst_base64$1))
     return caml_call1(Angstrom[51], 163344815);
    if(! caml_string_notequal(match, cst_binary$1))
     return caml_call1(Angstrom[51], 564146209);
    if(! caml_string_notequal(match, cst_quoted_printable$1))
     return caml_call1(Angstrom[51], 456100816);
    var match$0 = of_string$0(s, extension_token);
    if(! match$0) return invalid_token(s);
    var v = match$0[1];
    return caml_call1(Angstrom[51], v);
   }
   var
    _p_ = caml_call1(Angstrom[11], is_wsp),
    _q_ = caml_call1(Angstrom[11], is_wsp),
    _r_ = caml_call2(Angstrom[58], _q_, token),
    _s_ = caml_call2(Angstrom[59], _r_, _p_),
    mechanism = caml_call2(Angstrom[53], _s_, _o_),
    Decoder =
      [0,
       invalid_token,
       of_string$0,
       is_tspecials,
       is_ctl,
       is_space,
       is_ascii,
       is_token,
       token,
       token,
       x_token,
       extension_token,
       is_wsp,
       mechanism];
   function mechanism$0(ppf, param){
    if(typeof param === "number")
     return 456100816 === param
             ? caml_call2(Prettym[17], ppf, cst_quoted_printable$0)
             : 737158890
               <= param
               ? 737158891
                 <= param
                 ? caml_call2(Prettym[17], ppf, cst_8bit$0)
                 : caml_call2(Prettym[17], ppf, cst_7bit$0)
               : 564146209
                 <= param
                 ? caml_call2(Prettym[17], ppf, cst_binary$0)
                 : caml_call2(Prettym[17], ppf, cst_base64$0);
    if(452357416 <= param[1]){
     var x = param[2];
     return caml_call2(Prettym[17], ppf, x);
    }
    var
     x$0 = param[2],
     _t_ = [0, caml_call1(Prettym[9], Prettym[17]), 0],
     _u_ = [0, caml_call2(Prettym[10], Prettym[17], cst_X), _t_];
    return caml_call3(Prettym[26], ppf, _u_, x$0);
   }
   var Encoder = [0, mechanism$0];
   function to_string(v){return caml_call4(Prettym[34], 0, 0, Encoder[1], v);}
   var
    Multipart_form_Content_encodin =
      [0,
       error_msgf,
       pp,
       default$0,
       bit8,
       bit7,
       binary,
       quoted_printable,
       base64,
       of_string,
       equal,
       Decoder,
       Encoder,
       to_string];
   runtime.caml_register_global
    (34, Multipart_form_Content_encodin, "Multipart_form__Content_encoding");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Multipart_form__Field_name
//# unitInfo: Requires: Angstrom, Fmt, Prettym, Stdlib__Bytes, Stdlib__Map, Stdlib__Set, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    content_type = "Content-Type",
    content_transfer_encoding = "Content-Transfer-Encoding",
    content_disposition = "Content-Disposition",
    Stdlib_String = global_data.Stdlib__String,
    Fmt = global_data.Fmt,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Angstrom = global_data.Angstrom,
    Prettym = global_data.Prettym,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Set = global_data.Stdlib__Set,
    _c_ =
      [0,
       [11, "Field.prefixed_by: ", [2, 0, [11, " contains '-'", 0]]],
       "Field.prefixed_by: %s contains '-'"],
    _d_ = [0, "lib/field_name.ml", 56, 10],
    _b_ = [0, [2, 0, 0], "%s"],
    _a_ = [0, [11, "Invalid field: ", [3, 0, 0]], "Invalid field: %S"],
    cst_Multipart_form_Field_name_ = "Multipart_form__Field_name.Break";
   function error_msgf(fmt){
    function _r_(msg){return [1, [0, 3854881, msg]];}
    return caml_call2(Fmt[8], _r_, fmt);
   }
   function compare(a, b){
    var
     a$0 = caml_call1(Stdlib_String[27], a),
     b$0 = caml_call1(Stdlib_String[27], b);
    return caml_call2(Stdlib_String[10], a$0, b$0);
   }
   function equal(a, b){return 0 === compare(a, b) ? 1 : 0;}
   function capitalize(x){
    function capitalize(res, idx){
     var
      chr = runtime.caml_bytes_get(res, idx),
      _q_ = 25 < chr - 97 >>> 0 ? chr : chr - 32 | 0;
     runtime.caml_bytes_set(res, idx, _q_);
     return;
    }
    var
     res = caml_call1(Stdlib_Bytes[5], x),
     _n_ = caml_ml_string_length(x) - 1 | 0,
     _m_ = 0;
    if(_n_ >= 0){
     var i = _m_;
     for(;;){
      a:
      {
       if(0 < i){
        var param = caml_string_get(x, i - 1 | 0);
        b:
        {if(32 !== param && 45 !== param){var _o_ = 0; break b;} var _o_ = 1;}
        if(_o_){capitalize(res, i); break a;}
       }
       if(0 === i) capitalize(res, i);
      }
      var _p_ = i + 1 | 0;
      if(_n_ === i) break;
      var i = _p_;
     }
    }
    return caml_call1(Stdlib_Bytes[44], res);
   }
   var
    canonicalize = Stdlib_String[27],
    Break = [248, cst_Multipart_form_Field_name_, runtime.caml_fresh_oo_id(0)];
   function is_ftext(param){
    var switcher = param - 33 | 0;
    if(93 >= switcher >>> 0 && 25 !== switcher) return 1;
    return 0;
   }
   function of_string(x){
    try{
     var _i_ = caml_ml_string_length(x) - 1 | 0, _h_ = 0;
     if(_i_ >= 0){
      var i = _h_;
      for(;;){
       if(1 - is_ftext(caml_string_get(x, i)))
        throw caml_maybe_attach_backtrace(Break, 1);
       var _k_ = i + 1 | 0;
       if(_i_ === i) break;
       var i = _k_;
      }
     }
     var _j_ = [0, x];
     return _j_;
    }
    catch(_l_){
     var _g_ = caml_wrap_exception(_l_);
     if(_g_ === Break) return caml_call1(error_msgf(_a_), x);
     throw caml_maybe_attach_backtrace(_g_, 0);
    }
   }
   function of_string_exn(x){
    var match = of_string(x);
    if(0 === match[0]){var x$0 = match[1]; return x$0;}
    var err = match[1][2];
    return caml_call2(Fmt[13], _b_, err);
   }
   var pp = caml_call2(Fmt[19], capitalize, Fmt[57]);
   function prefixed_by(prefix, field){
    if(caml_call2(Stdlib_String[15], prefix, 45))
     caml_call2(Fmt[13], _c_, prefix);
    var
     _e_ = caml_call1(Stdlib_String[27], field),
     match = caml_call2(Stdlib_String[17], 45, _e_);
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    var x = match[1];
    if(! match[2]) return 0;
    var _f_ = caml_call1(Stdlib_String[27], prefix);
    return caml_call2(Stdlib_String[9], x, _f_);
   }
   var
    field_name = caml_call1(Angstrom[14], is_ftext),
    Decoder = [0, field_name],
    field_name$0 = caml_call2(Prettym[16], capitalize, Prettym[17]),
    Encoder = [0, field_name$0],
    Map = caml_call1(Stdlib_Map[1], [0, Stdlib_String[10]]),
    Set = caml_call1(Stdlib_Set[1], [0, Stdlib_String[10]]),
    Multipart_form_Field_name =
      [0,
       error_msgf,
       compare,
       equal,
       capitalize,
       canonicalize,
       Break,
       is_ftext,
       of_string,
       of_string_exn,
       of_string_exn,
       pp,
       prefixed_by,
       Decoder,
       Encoder,
       Map,
       Set,
       content_type,
       content_transfer_encoding,
       content_disposition];
   runtime.caml_register_global
    (16, Multipart_form_Field_name, "Multipart_form__Field_name");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Multipart_form__Field
//# unitInfo: Requires: Angstrom, Fmt, Multipart_form__Content_disposition, Multipart_form__Content_encoding, Multipart_form__Content_type, Multipart_form__Field_name, Prettym, Stdlib__Bytes, Stdlib__Option, Stdlib__Result, Stdlib__String, Unstrctrd, Unstrctrd_parser
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_hov = "<hov>",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ":",
    Prettym = global_data.Prettym,
    Multipart_form_Field_name = global_data.Multipart_form__Field_name,
    Multipart_form_Content_type = global_data.Multipart_form__Content_type,
    Multipart_form_Content_encodin =
      global_data.Multipart_form__Content_encoding,
    Multipart_form_Content_disposi =
      global_data.Multipart_form__Content_disposition,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Result = global_data.Stdlib__Result,
    Stdlib_Option = global_data.Stdlib__Option,
    Angstrom = global_data.Angstrom,
    Unstrctrd = global_data.Unstrctrd,
    Unstrctrd_parser = global_data.Unstrctrd_parser,
    Stdlib_String = global_data.Stdlib__String,
    Fmt = global_data.Fmt,
    _f_ = [0, "lib/field.ml", 73, 13],
    _c_ = [0, 0],
    _d_ = [0, 1],
    _e_ = [0, 2],
    _b_ = [0, 3],
    _a_ =
      [0,
       [15,
        [12,
         91,
         [0,
          [11,
           "]: ",
           [18, [1, [0, [11, cst_hov, 0], cst_hov]], [15, [17, 0, 0]]]]]]],
       "%a[%c]: @[<hov>%a@]"];
   function pp_unstrctrd(ppf, v){
    var _z_ = caml_call2(Unstrctrd[7], 0, v);
    return caml_call2(Fmt[57], ppf, _z_);
   }
   function pp(ppf, param){
    var
     v = param[3],
     w = param[2],
     field_name = param[1],
     is_unstructured = 3 <= w ? 1 : 0;
    switch(w){
      case 0:
       var _x_ = Multipart_form_Content_type[24]; break;
      case 1:
       var _x_ = Multipart_form_Content_encodin[2]; break;
      case 2:
       var _x_ = Multipart_form_Content_disposi[5]; break;
      default: var _x_ = pp_unstrctrd;
    }
    var _y_ = is_unstructured ? 33 : 42;
    return caml_call7
            (Fmt[3],
             ppf,
             _a_,
             Multipart_form_Field_name[11],
             field_name,
             _y_,
             _x_,
             v);
   }
   function symbol(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function of_field_name(field_name){
    var match = caml_call1(Stdlib_String[27], field_name);
    return caml_string_notequal(match, "content-disposition")
            ? caml_string_notequal
               (match, "content-transfer-encoding")
              ? caml_string_notequal(match, "content-type") ? _b_ : _c_
              : _d_
            : _e_;
   }
   function parser(param){
    switch(param){
      case 0:
       return Multipart_form_Content_type[26][23];
      case 1:
       return Multipart_form_Content_encodin[11][13];
      case 2:
       return Multipart_form_Content_disposi[14][26];
      default:
       var buf = caml_create_bytes(127);
       return caml_call1(Unstrctrd_parser[1], buf);
    }
   }
   function field(g, field_name){
    var buf = caml_create_bytes(127);
    function _m_(v){
     var
      _o_ = caml_call1(Multipart_form_Field_name[15][18], field_name),
      match = caml_call2(Stdlib_Option[5], g, _o_);
     if(match)
      var w = match[1], match$0 = w;
     else
      var match$0 = of_field_name(field_name);
     var
      w$0 = match$0[1],
      parser$0 = parser(w$0),
      symbol_bind = Stdlib_Result[6];
     function symbol_map(x, f){return caml_call2(Stdlib_Result[8], f, x);}
     function _p_(v){return [0, field_name, w$0, v];}
     var _q_ = caml_call1(caml_call1(Angstrom[75], 0), parser$0);
     function _r_(msg){return [0, 3854881, msg];}
     var _s_ = caml_call1(Stdlib_Result[9], _r_);
     function _t_(_w_){return symbol(_s_, _q_, _w_);}
     var arg = Unstrctrd[7];
     function _u_(eta){return caml_call2(arg, 0, eta);}
     var
      _v_ = Unstrctrd[15],
      res =
        symbol_map
         (caml_call2
           (symbol_bind,
            symbol_map(symbol_map(caml_call1(Unstrctrd[14], v), _v_), _u_),
            _t_),
          _p_);
     if(0 !== res[0]) return caml_call1(Angstrom[51], [0, field_name, 3, v]);
     var v$0 = res[1];
     return caml_call1(Angstrom[51], v$0);
    }
    var _n_ = caml_call1(Unstrctrd_parser[1], buf);
    return caml_call2(Angstrom[53], _n_, _m_);
   }
   var Decoder = [0, field];
   function encoder(param){
    switch(param){
      case 0:
       return Multipart_form_Content_type[28][6];
      case 1:
       return Multipart_form_Content_encodin[12][1];
      case 2:
       return Multipart_form_Content_disposi[16][5];
      default: throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
   }
   function field$0(ppf, field){
    var
     v = field[3],
     w = field[2],
     field_name = field[1],
     e = encoder(w),
     _g_ = [0, Prettym[15], [0, Prettym[11], 0]],
     _h_ = [0, caml_call1(Prettym[9], e), _g_],
     _i_ = [0, caml_call1(Prettym[4], 1), _h_],
     _j_ = [0, caml_call2(Prettym[10], Prettym[17], cst), _i_],
     _k_ = [0, caml_call1(Prettym[9], Multipart_form_Field_name[14][1]), _j_],
     _l_ = [0, caml_call1(Prettym[12], 1), _k_];
    return caml_call4(Prettym[26], ppf, _l_, field_name, v);
   }
   var
    Encoder = [0, field$0],
    Multipart_form_Field =
      [0,
       pp_unstrctrd,
       pp,
       symbol,
       of_field_name,
       parser,
       Decoder,
       encoder,
       Encoder];
   runtime.caml_register_global
    (23, Multipart_form_Field, "Multipart_form__Field");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Multipart_form__Header
//# unitInfo: Requires: Angstrom, Fmt, Multipart_form__Content_encoding, Multipart_form__Content_type, Multipart_form__Field, Multipart_form__Field_name, Prettym, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Multipart_form_Field = global_data.Multipart_form__Field,
    Angstrom = global_data.Angstrom,
    Multipart_form_Field_name = global_data.Multipart_form__Field_name,
    Stdlib_List = global_data.Stdlib__List,
    Multipart_form_Content_encodin =
      global_data.Multipart_form__Content_encoding,
    Multipart_form_Content_type = global_data.Multipart_form__Content_type,
    Stdlib = global_data.Stdlib,
    Fmt = global_data.Fmt,
    Prettym = global_data.Prettym,
    _a_ = Multipart_form_Field[2],
    _b_ = [0, caml_call1(Fmt[18], [0, [17, 3, 0], "@\n"])],
    pp = caml_call2(Fmt[64], _b_, _a_);
   function assoc(field_name, header){
    function f(acc, field){
     var field_name$0 = field[1];
     return caml_call2(Multipart_form_Field_name[3], field_name, field_name$0)
             ? [0, field, acc]
             : acc;
    }
    var _t_ = caml_call3(Stdlib_List[26], f, 0, header);
    return caml_call1(Stdlib_List[10], _t_);
   }
   function remove_assoc(field_name, header){
    function f(acc, x){
     var field_name$0 = x[1];
     return caml_call2(Multipart_form_Field_name[3], field_name, field_name$0)
             ? acc
             : [0, x, acc];
    }
    var _s_ = caml_call3(Stdlib_List[26], f, 0, header);
    return caml_call1(Stdlib_List[10], _s_);
   }
   function exists(field_name, t){
    function _r_(param){
     var field_name$0 = param[1];
     return caml_call2(Multipart_form_Field_name[3], field_name, field_name$0);
    }
    return caml_call2(Stdlib_List[34], _r_, t);
   }
   var empty = 0;
   function concat(a, b){return caml_call2(Stdlib[37], a, b);}
   function to_list(x){return x;}
   function add(field_name, param, t){
    var v = param[2], w = param[1], field = [0, field_name, w, v];
    return [0, field, t];
   }
   function replace(field_name, param, t){
    var
     v = param[2],
     w = param[1],
     header = remove_assoc(field_name, t),
     field = [0, field_name, w, v];
    return [0, field, header];
   }
   function of_list(x){return x;}
   function of_list_with_location(x){return x;}
   function content_type(header){
    var content = [0, Multipart_form_Content_type[13]];
    function _o_(param){
     if(param[2]) return 0;
     var
      v = param[3],
      field_name = param[1],
      _p_ =
        caml_call2
         (Multipart_form_Field_name[3],
          field_name,
          Multipart_form_Field_name[17]),
      _q_ = _p_ ? (content[1] = v, 0) : _p_;
     return _q_;
    }
    caml_call2(Stdlib_List[18], _o_, header);
    return content[1];
   }
   function content_encoding(header){
    var mechanism = [0, Multipart_form_Content_encodin[3]];
    function _l_(param){
     if(1 !== param[2]) return 0;
     var
      v = param[3],
      field_name = param[1],
      _m_ =
        caml_call2
         (Multipart_form_Field_name[3],
          field_name,
          Multipart_form_Field_name[18]),
      _n_ = _m_ ? (mechanism[1] = v, 0) : _m_;
     return _n_;
    }
    caml_call2(Stdlib_List[18], _l_, header);
    return mechanism[1];
   }
   function content_disposition(header){
    var disposition = [0, 0];
    function _i_(param){
     if(2 !== param[2]) return 0;
     var
      v = param[3],
      field_name = param[1],
      _j_ =
        caml_call2
         (Multipart_form_Field_name[3],
          field_name,
          Multipart_form_Field_name[19]),
      _k_ = _j_ ? (disposition[1] = [0, v], 0) : _j_;
     return _k_;
    }
    caml_call2(Stdlib_List[18], _i_, header);
    return disposition[1];
   }
   function is_wsp(param){if(9 !== param && 32 !== param) return 0; return 1;}
   function _c_(field_name){
    var
     _e_ = caml_call2(Multipart_form_Field[6][1], 0, field_name),
     _f_ = caml_call1(Angstrom[4], 58),
     _g_ = caml_call1(Angstrom[11], is_wsp),
     _h_ = caml_call2(Angstrom[58], _g_, _f_);
    return caml_call2(Angstrom[58], _h_, _e_);
   }
   var
    field = caml_call2(Angstrom[53], Multipart_form_Field_name[13][1], _c_),
    header = caml_call1(Angstrom[38], field),
    Decoder = [0, is_wsp, field, header],
    keval_order = Prettym[1],
    break$0 = Prettym[2],
    fws = Prettym[3],
    spaces = Prettym[4],
    cut = Prettym[5],
    const$0 = Prettym[6],
    atom = Prettym[7],
    a = Prettym[8],
    symbol = Prettym[9],
    symbol$0 = Prettym[10],
    new_line = Prettym[11],
    tbox = Prettym[12],
    bbox = Prettym[13],
    box = Prettym[14],
    close = Prettym[15],
    using = Prettym[16],
    string = Prettym[17],
    bytes = Prettym[18],
    bigstring = Prettym[19],
    breakable = Prettym[20],
    char$0 = Prettym[21],
    list = Prettym[22],
    option = Prettym[23],
    concat$0 = Prettym[24],
    keval = Prettym[25],
    eval$0 = Prettym[26],
    Buffer = Prettym[27],
    IOVec = Prettym[28],
    io_buffer_size = Prettym[29],
    create = Prettym[30],
    is_empty = Prettym[31],
    flush = Prettym[32],
    kflush = Prettym[33],
    to_string = Prettym[34],
    to_stream = Prettym[35],
    _d_ = 0,
    noop = [0, function(ppf, param){return ppf;}, _d_];
   function field$0(ppf, x){
    return caml_call2(Multipart_form_Field[8][1], ppf, x);
   }
   function header$0(ppf, x){
    return caml_call2(caml_call2(list, noop, field$0), ppf, x);
   }
   var
    Encoder =
      [0,
       keval_order,
       break$0,
       fws,
       spaces,
       cut,
       const$0,
       atom,
       a,
       symbol,
       symbol$0,
       new_line,
       tbox,
       bbox,
       box,
       close,
       using,
       string,
       bytes,
       bigstring,
       breakable,
       char$0,
       list,
       option,
       concat$0,
       keval,
       eval$0,
       Buffer,
       IOVec,
       io_buffer_size,
       create,
       is_empty,
       flush,
       kflush,
       to_string,
       to_stream,
       noop,
       field$0,
       header$0],
    Multipart_form_Header =
      [0,
       pp,
       assoc,
       remove_assoc,
       exists,
       empty,
       concat,
       to_list,
       add,
       replace,
       of_list,
       of_list_with_location,
       content_type,
       content_encoding,
       content_disposition,
       Decoder,
       Encoder];
   runtime.caml_register_global
    (10, Multipart_form_Header, "Multipart_form__Header");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Multipart_form__Rfc2046
//# unitInfo: Requires: Angstrom, Bigstringaf, Fmt, Multipart_form__Header, Stdlib, Stdlib__Option, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "--",
    cst_nothing_to_do = "nothing to do",
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$2,
    cst$0 = "\r\n",
    cst = cst$2,
    Angstrom = global_data.Angstrom,
    Stdlib_Option = global_data.Stdlib__Option,
    Multipart_form_Header = global_data.Multipart_form__Header,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Fmt = global_data.Fmt,
    _b_ = [0, [11, cst_nothing_to_do, 0], cst_nothing_to_do];
   function is_bcharsnospace(param){
    a:
    {
     b:
     {
      if(95 <= param){
       if(97 <= param){if(123 <= param) break b; break a;}
       if(96 <= param) break b;
      }
      else{
       if(65 <= param){if(91 <= param) break b; break a;}
       if(39 > param) break b;
       switch(param - 39 | 0){
         case 3:
         case 20:
         case 21:
         case 23:
         case 25:
          break b;
         case 9:
         case 10:
         case 11:
         case 12:
         case 13:
         case 14:
         case 15:
         case 16:
         case 17:
         case 18:
          return 1;
       }
      }
      return 1;
     }
     return 0;
    }
    return 1;
   }
   function is_bchars(c){return 32 === c ? 1 : is_bcharsnospace(c);}
   function make_dash_boundary(boundary){
    return caml_call2(Stdlib[28], cst, boundary);
   }
   function dash_boundary(boundary){
    var _as_ = make_dash_boundary(boundary);
    return caml_call1(Angstrom[8], _as_);
   }
   function make_delimiter(boundary){
    var _ar_ = make_dash_boundary(boundary);
    return caml_call2(Stdlib[28], cst$0, _ar_);
   }
   function make_close_delimiter(boundary){
    var _aq_ = make_delimiter(boundary);
    return caml_call2(Stdlib[28], _aq_, cst$1);
   }
   function close_delimiter(boundary){
    var _ap_ = make_close_delimiter(boundary);
    return caml_call1(Angstrom[8], _ap_);
   }
   function discard_all_to_dash_boundary(boundary){
    var
     dash_boundary = make_dash_boundary(boundary),
     expected_len = caml_ml_string_length(dash_boundary);
    function _ae_(ba, off, len){
     var raw = caml_call3(Bigstringaf[7], ba, off, len);
     return caml_call2(Stdlib_String[9], raw, dash_boundary);
    }
    var check_boundary = caml_call2(Angstrom[72][5], expected_len, _ae_);
    function _af_(m){
     function _ag_(param){
      if(! param) return caml_call1(Angstrom[51], 0);
      if(45 === param[1]){
       var
        _am_ =
          function(param){
           if(param) return caml_call1(Angstrom[51], 0);
           var _ao_ = caml_call1(Angstrom[22], 1);
           return caml_call2(Angstrom[58], _ao_, m);
          };
       return caml_call2(Angstrom[53], check_boundary, _am_);
      }
      var _an_ = caml_call1(Angstrom[22], 1);
      return caml_call2(Angstrom[58], _an_, m);
     }
     var _ah_ = Angstrom[1];
     function _ai_(_al_){return 45 !== _al_ ? 1 : 0;}
     var
      _aj_ = caml_call1(Angstrom[11], _ai_),
      _ak_ = caml_call2(Angstrom[58], _aj_, _ah_);
     return caml_call2(Angstrom[53], _ak_, _ag_);
    }
    return caml_call1(Angstrom[45], _af_);
   }
   function _a_(param){if(9 !== param && 32 !== param) return 0; return 1;}
   var transport_padding = caml_call1(Angstrom[11], _a_);
   function discard_all_to_delimiter(boundary){
    var
     delimiter = make_delimiter(boundary),
     expected_len = caml_ml_string_length(delimiter);
    function _V_(ba, off, len){
     var raw = caml_call3(Bigstringaf[7], ba, off, len);
     return caml_call2(Stdlib_String[9], raw, delimiter);
    }
    var check_delimiter = caml_call2(Angstrom[72][5], expected_len, _V_);
    function _W_(m){
     function _X_(param){
      if(! param) return caml_call1(Angstrom[51], 0);
      if(13 === param[1]){
       var
        _ab_ =
          function(param){
           if(param) return caml_call1(Angstrom[51], 0);
           var _ad_ = caml_call1(Angstrom[22], 1);
           return caml_call2(Angstrom[58], _ad_, m);
          };
       return caml_call2(Angstrom[53], check_delimiter, _ab_);
      }
      var _ac_ = caml_call1(Angstrom[22], 1);
      return caml_call2(Angstrom[58], _ac_, m);
     }
     var _Y_ = Angstrom[1];
     function _Z_(_aa_){return 13 !== _aa_ ? 1 : 0;}
     var
      ___ = caml_call1(Angstrom[11], _Z_),
      _$_ = caml_call2(Angstrom[58], ___, _Y_);
     return caml_call2(Angstrom[53], _$_, _X_);
    }
    return caml_call1(Angstrom[45], _W_);
   }
   var
    nothing_to_do = caml_call2(Fmt[8], Angstrom[52], _b_),
    _c_ = caml_call1(Angstrom[4], 10),
    _d_ = caml_call1(Angstrom[4], 13),
    crlf = caml_call2(Angstrom[58], _d_, _c_);
   function body_part(body){
    function _J_(fields){
     function _K_(body){return [0, fields, body];}
     function _L_(param){
      if(747095785 > param) return caml_call1(Angstrom[51], 0);
      var _T_ = Stdlib_Option[2], _U_ = caml_call1(body, fields);
      return caml_call2(Angstrom[55], _U_, _T_);
     }
     var
      _M_ = Angstrom[50],
      _N_ = caml_call1(Angstrom[51], 481346541),
      _O_ = caml_call1(Angstrom[51], 747095785),
      _P_ = caml_call2(Angstrom[58], crlf, _O_),
      _Q_ = caml_call2(Angstrom[47], _P_, _N_),
      _R_ = caml_call2(Angstrom[59], _Q_, _M_),
      _S_ = caml_call2(Angstrom[53], _R_, _L_);
     return caml_call2(Angstrom[55], _S_, _K_);
    }
    return caml_call2(Angstrom[53], Multipart_form_Header[15][3], _J_);
   }
   function encapsulation(boundary, body){
    var
     _C_ = body_part(body),
     _D_ = Angstrom[50],
     _E_ = make_delimiter(boundary),
     _F_ = caml_call1(Angstrom[8], _E_),
     _G_ = caml_call2(Angstrom[58], _F_, transport_padding),
     _H_ = caml_call2(Angstrom[58], _G_, crlf),
     _I_ = caml_call2(Angstrom[58], _H_, _D_);
    return caml_call2(Angstrom[58], _I_, _C_);
   }
   function preambule(boundary){
    return discard_all_to_dash_boundary(boundary);
   }
   function epilogue(parent){
    if(parent){
     var boundary = parent[1];
     return discard_all_to_delimiter(boundary);
    }
    function _B_(param){return 1;}
    return caml_call1(Angstrom[11], _B_);
   }
   function multipart_body(parent, boundary, body){
    function _e_(x){
     function _p_(r){
      var
       _s_ = caml_call1(Angstrom[51], [0, x, r]),
       _t_ = caml_call1(Angstrom[51], 0),
       _u_ = epilogue(parent),
       _v_ = caml_call2(Angstrom[34], 0, _u_),
       _w_ = close_delimiter(boundary),
       _x_ = caml_call2(Angstrom[58], Angstrom[50], _w_),
       _y_ = caml_call2(Angstrom[58], _x_, transport_padding),
       _z_ = caml_call2(Angstrom[58], _y_, _v_),
       _A_ = caml_call2(Angstrom[47], _z_, _t_);
      return caml_call2(Angstrom[58], _A_, _s_);
     }
     var
      _q_ = encapsulation(boundary, body),
      _r_ = caml_call1(Angstrom[38], _q_);
     return caml_call2(Angstrom[53], _r_, _p_);
    }
    var
     _f_ = body_part(body),
     _g_ = Angstrom[50],
     _h_ = dash_boundary(boundary),
     _i_ = preambule(boundary),
     _j_ = caml_call2(Angstrom[34], 0, _i_),
     _k_ = caml_call2(Angstrom[58], _j_, _h_),
     _l_ = caml_call2(Angstrom[58], _k_, transport_padding),
     _m_ = caml_call2(Angstrom[58], _l_, crlf),
     _n_ = caml_call2(Angstrom[58], _m_, _g_),
     _o_ = caml_call2(Angstrom[58], _n_, _f_);
    return caml_call2(Angstrom[53], _o_, _e_);
   }
   var
    Multipart_form_Rfc2046 =
      [0,
       is_bcharsnospace,
       is_bchars,
       make_dash_boundary,
       dash_boundary,
       make_delimiter,
       make_close_delimiter,
       close_delimiter,
       discard_all_to_dash_boundary,
       transport_padding,
       discard_all_to_delimiter,
       nothing_to_do,
       crlf,
       body_part,
       encapsulation,
       preambule,
       epilogue,
       multipart_body];
   runtime.caml_register_global
    (11, Multipart_form_Rfc2046, "Multipart_form__Rfc2046");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Multipart_form
//# unitInfo: Requires: Angstrom, Base64_rfc2045, Bigstringaf, Fmt, Ke__Rke, Logs, Multipart_form__Content_disposition, Multipart_form__Content_encoding, Multipart_form__Content_type, Multipart_form__Field, Multipart_form__Field_name, Multipart_form__Header, Multipart_form__Rfc2046, Pecu, Prettym, Stdlib, Stdlib__Bigarray, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Hashtbl, Stdlib__List, Stdlib__Option, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = "\n",
    cst$4 = "\r\n",
    cst_byte_s = " byte(s).",
    cst_Content_type_MUST_be_discr =
      "Content-type MUST be discrete type to a make a part",
    cst_Decode_a_8_bit_part = "Decode a 8-bit part.",
    cst_Decode_a_base64_part = "Decode a base64 part.",
    cst_Decode_a_quoted_printable_ = "Decode a quoted-printable part.",
    cst_Decode_the_8_bit_final_par = "Decode the 8-bit final part.",
    cst_Decode_the_base64_final_pa = "Decode the base64 final part.",
    cst_Decode_the_quoted_printabl = "Decode the quoted-printable final part.",
    cst_End_of_input = "End of input.",
    cst_Invalid_Content_Transfer_E =
      "Invalid Content-Transfer-Encoding value (",
    cst_Invalid_Content_Transfer_E$0 =
      "Invalid Content-Transfer-Encoding value (%s)",
    cst_Invalid_Content_Type_missi = "Invalid Content-Type, missing boundary",
    cst_Multipart_MUST_have_a_boun = "Multipart MUST have a boundary",
    cst_No_more_payloads = "No more payloads.",
    cst_Partial_state_of_the_multi =
      "Partial state of the multipart/form stream.",
    cst_Remain_multiple_payloads = "Remain multiple payloads",
    cst_boundary$1 = "boundary",
    cst_lib_multipart_form_ml = "lib/multipart_form.ml",
    cst_wrong_padding$3 = "wrong padding",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$4,
    cst$2 = cst$4,
    cst$3 = cst$4,
    cst$0 = cst$4,
    cst = cst$5,
    end_of_line = cst$5,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_List = global_data.Stdlib__List,
    Multipart_form_Header = global_data.Multipart_form__Header,
    Multipart_form_Content_type = global_data.Multipart_form__Content_type,
    Fmt = global_data.Fmt,
    Multipart_form_Rfc2046 = global_data.Multipart_form__Rfc2046,
    Stdlib = global_data.Stdlib,
    Prettym = global_data.Prettym,
    Multipart_form_Field_name = global_data.Multipart_form__Field_name,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Ke_Rke = global_data.Ke__Rke,
    Bigstringaf = global_data.Bigstringaf,
    Match_failure = global_data.Match_failure,
    Angstrom = global_data.Angstrom,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Base64_rfc2045 = global_data.Base64_rfc2045,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Char = global_data.Stdlib__Char,
    Pecu = global_data.Pecu,
    Stdlib_String = global_data.Stdlib__String,
    Logs = global_data.Logs,
    Multipart_form_Content_disposi =
      global_data.Multipart_form__Content_disposition,
    Multipart_form_Content_encodin =
      global_data.Multipart_form__Content_encoding,
    src = caml_call2(Logs[7][1], 0, "multipart-form"),
    Log = caml_call1(Logs[18], src),
    _F_ =
      [0,
       [11, cst_Multipart_MUST_have_a_boun, 0],
       cst_Multipart_MUST_have_a_boun],
    cst_boundary$0 = cst_boundary$1,
    _B_ =
      [0,
       [11, cst_Content_type_MUST_be_discr, 0],
       cst_Content_type_MUST_be_discr],
    _C_ = [0, cst_lib_multipart_form_ml, 637, 36],
    _A_ = [1, [0, 3854881, "Invalid input"]],
    _x_ =
      [0,
       [11,
        "Length of the internal queue: ",
        [4, 0, 0, 0, [11, cst_byte_s, 0]]],
       "Length of the internal queue: %d byte(s)."],
    _w_ =
      [0,
       [11,
        "Capacity of the internal queue: ",
        [4, 0, 0, 0, [11, cst_byte_s, 0]]],
       "Capacity of the internal queue: %d byte(s)."],
    _v_ = [0, [11, cst_No_more_payloads, 0], cst_No_more_payloads],
    _u_ =
      [0, [11, "Remain one payload: ", [3, 0, 0]], "Remain one payload: %S"],
    _t_ =
      [0, [11, cst_Remain_multiple_payloads, 0], cst_Remain_multiple_payloads],
    _s_ = [0, [11, cst_End_of_input, 0], cst_End_of_input],
    _r_ =
      [0,
       [11, cst_Partial_state_of_the_multi, 0],
       cst_Partial_state_of_the_multi],
    _y_ = [0, 0],
    _z_ = [0, cst_lib_multipart_form_ml, 538, 31],
    _q_ = [0, 4096],
    _o_ =
      [0,
       [11, cst_Invalid_Content_Type_missi, 0],
       cst_Invalid_Content_Type_missi],
    _p_ =
      [0,
       [11, cst_Invalid_Content_Transfer_E, [2, 0, [12, 41, 0]]],
       cst_Invalid_Content_Transfer_E$0],
    cst_boundary = cst_boundary$1,
    _k_ =
      [0,
       [11, cst_Decode_the_quoted_printabl, 0],
       cst_Decode_the_quoted_printabl],
    _m_ =
      [0,
       [11, cst_Decode_the_base64_final_pa, 0],
       cst_Decode_the_base64_final_pa],
    _l_ =
      [0,
       [11, cst_Decode_the_8_bit_final_par, 0],
       cst_Decode_the_8_bit_final_par],
    _g_ =
      [0,
       [11, cst_Decode_a_quoted_printable_, 0],
       cst_Decode_a_quoted_printable_],
    _i_ = [0, [11, cst_Decode_a_base64_part, 0], cst_Decode_a_base64_part],
    _h_ = [0, [11, cst_Decode_a_8_bit_part, 0], cst_Decode_a_8_bit_part],
    _j_ =
      [0,
       [11, cst_Invalid_Content_Transfer_E, [2, 0, [12, 41, 0]]],
       cst_Invalid_Content_Transfer_E$0],
    _n_ =
      [0,
       [11, cst_Invalid_Content_Transfer_E, [2, 0, [12, 41, 0]]],
       cst_Invalid_Content_Transfer_E$0],
    cst_Found = "Found",
    _f_ = [0, cst_lib_multipart_form_ml, 401, 8],
    _e_ = [0, 128],
    _d_ = [0, cst_lib_multipart_form_ml, 355, 8],
    _c_ = [0, 128],
    _b_ = [0, cst_lib_multipart_form_ml, 195, 20],
    cst_wrong_padding$2 = cst_wrong_padding$3,
    cst_wrong_padding$1 = cst_wrong_padding$3,
    _a_ = [0, cst_lib_multipart_form_ml, 28, 20],
    cst_wrong_padding = cst_wrong_padding$3,
    cst_wrong_padding$0 = cst_wrong_padding$3,
    cst_form_data = "form-data";
   function map(f, param){
    if(0 === param[0]){
     var match = param[1], body = match[2], header = match[1];
     return [0, [0, header, caml_call1(f, body)]];
    }
    var match$0 = param[1], body$0 = match$0[2], header$0 = match$0[1];
    function _b1_(_b3_){return map(f, _b3_);}
    var _b2_ = caml_call1(Stdlib_Option[7], _b1_);
    return [1, [0, header$0, caml_call2(Stdlib_List[20], _b2_, body$0)]];
   }
   function flatten(param){
    if(0 === param[0]){var elt = param[1]; return [0, elt, 0];}
    var
     body = param[1][2],
     _bZ_ = caml_call1(Stdlib_Option[7], flatten),
     _b0_ = caml_call2(Stdlib_List[23], _bZ_, body);
    return caml_call1(Stdlib_List[15], _b0_);
   }
   function iter(f, buf, off, len){
    var _bX_ = len - 1 | 0;
    if(_bX_ >= off){
     var i = off;
     for(;;){
      caml_call1(f, caml_string_get(buf, i));
      var _bY_ = i + 1 | 0;
      if(_bX_ === i) break;
      var i = _bY_;
     }
    }
    return;
   }
   function content_encoding(fields){
    var
     encoding = [0, 737158890],
     Found = [248, cst_Found, runtime.caml_fresh_oo_id(0)];
    try{
     var
      _bU_ =
        function(param){
         if(1 !== param[2]) return 0;
         var v = param[3];
         encoding[1] = v;
         throw caml_maybe_attach_backtrace(Found, 1);
        };
     caml_call2(Stdlib_List[18], _bU_, fields);
     var _bV_ = encoding[1];
     return _bV_;
    }
    catch(_bW_){
     var _bT_ = caml_wrap_exception(_bW_);
     if(_bT_ === Found) return encoding[1];
     throw caml_maybe_attach_backtrace(_bT_, 0);
    }
   }
   function failf(fmt){return caml_call2(Fmt[8], Angstrom[52], fmt);}
   function parser(emitters, content_type){
    var header = [0, [0, Multipart_form_Field_name[17], 0, content_type], 0];
    function body(boundary$1, header){
     var
      _az_ = caml_call1(Multipart_form_Header[12], header),
      match$2 = caml_call1(Multipart_form_Content_type[14], _az_);
     if(typeof match$2 !== "number"){
      var v$1 = match$2[2];
      return caml_call1(failf(_p_), v$1);
     }
     if(-903248805 > match$2){
      var
       content_type = caml_call1(Multipart_form_Header[12], header),
       _ay_ = caml_call1(Multipart_form_Content_type[16], content_type),
       match$1 = caml_call2(Stdlib_List[50], cst_boundary, _ay_);
      if(match$1)
       var boundary$0 = match$1[1][1], match$4 = [0, boundary$0];
      else
       var match$4 = 0;
      if(! match$4) return failf(_o_);
      var
       boundary$2 = match$4[1],
       _aC_ = function(parts){return [1, [0, header, parts]];},
       _aD_ = function(param){var contents = param[2]; return contents;},
       _aE_ = caml_call1(Stdlib_List[20], _aD_),
       _aF_ = caml_call1(Stdlib_Option[2], boundary$2),
       _aG_ = function(_bS_){return body(_aF_, _bS_);},
       _aH_ =
         caml_call3(Multipart_form_Rfc2046[17], boundary$1, boundary$2, _aG_),
       _aI_ = caml_call2(Angstrom[55], _aH_, _aE_);
      return caml_call2(Angstrom[55], _aI_, _aC_);
     }
     var
      match$3 = caml_call1(emitters, header),
      id = match$3[2],
      emitter = match$3[1];
     function _aA_(param){return [0, [0, header, id]];}
     if(boundary$1){
      var
       boundary = boundary$1[1],
       end_of_body = caml_call1(Multipart_form_Rfc2046[5], boundary),
       _ao_ =
         function(param){
          caml_call1(emitter, 0);
          return caml_call1(Angstrom[51], 0);
         },
       match = content_encoding(header);
      if(typeof match === "number")
       if(456100816 === match){
        var _ap_ = function(m){return caml_call3(m, 0, 0, _g_);};
        caml_call1(Log[6], _ap_);
        var
         write_data$1 = function(x){return caml_call1(emitter, [0, x]);},
         write_line =
           function(x){
            return caml_call1
                    (emitter, [0, caml_call2(Stdlib[28], x, end_of_line)]);
           },
         dec$1 = caml_call1(Pecu[2], -328752538),
         expected_len$1 = caml_ml_string_length(end_of_body),
         _al_ =
           function(ba, off, len){
            var raw = caml_call3(Bigstringaf[7], ba, off, len);
            return caml_call2(Stdlib_String[9], raw, end_of_body);
           },
         check_end_of_body$1 =
           caml_call2(Angstrom[72][5], expected_len$1, _al_),
         trailer =
           function(param){
            function finish(param){
             var match = caml_call1(Pecu[3], dec$1);
             if(typeof match === "number"){
              if(1006505782 <= match)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
              return Angstrom[50];
             }
             var _aY_ = match[1];
             if(758940234 === _aY_){
              var data = match[2];
              write_data$1(data);
              return caml_call2(Angstrom[53], Angstrom[50], finish);
             }
             if(848053268 <= _aY_){
              var line = match[2];
              write_line(line);
              return caml_call2(Angstrom[53], Angstrom[50], finish);
             }
             var err = match[2], _aZ_ = caml_call1(Angstrom[52], err);
             return caml_call2(Angstrom[58], Angstrom[50], _aZ_);
            }
            function go(param){
             var match = caml_call1(Pecu[3], dec$1);
             if(typeof match === "number")
              return 1006505782 <= match
                      ? (caml_call4
                         (Pecu[1], dec$1, Stdlib_Bytes[3], 0, 0),
                        caml_call2(Angstrom[53], Angstrom[50], finish))
                      : Angstrom[50];
             var _aW_ = match[1];
             if(758940234 === _aW_){
              var data = match[2];
              write_data$1(data);
              return caml_call2(Angstrom[53], Angstrom[50], go);
             }
             if(848053268 <= _aW_){
              var line = match[2];
              write_line(line);
              return caml_call2(Angstrom[53], Angstrom[50], go);
             }
             var err = match[2], _aX_ = caml_call1(Angstrom[52], err);
             return caml_call2(Angstrom[58], Angstrom[50], _aX_);
            }
            return go(0);
           },
         _am_ =
           function(m){
            function _aJ_(chunk){
             function go(param){
              var match = caml_call1(Pecu[3], dec$1);
              if(typeof match === "number"){
               if(1006505782 > match) return Angstrom[50];
               var
                chunk$0 =
                  caml_create_bytes(caml_ml_string_length(chunk) + 1 | 0);
               caml_call5
                (Stdlib_Bytes[12],
                 chunk,
                 0,
                 chunk$0,
                 0,
                 caml_ml_string_length(chunk));
               var
                _aP_ =
                  function(param){
                   if(param){
                    var
                     chunk =
                       caml_call3
                        (Stdlib_Bytes[7],
                         chunk$0,
                         0,
                         caml_ml_bytes_length(chunk$0) - 1 | 0);
                    caml_call4
                     (Pecu[1], dec$1, chunk, 0, caml_ml_bytes_length(chunk));
                    return caml_call2(Angstrom[53], Angstrom[50], trailer);
                   }
                   caml_bytes_set
                    (chunk$0,
                     caml_ml_bytes_length(chunk$0) - 1 | 0,
                     caml_string_get(end_of_body, 0));
                   caml_call4
                    (Pecu[1], dec$1, chunk$0, 0, caml_ml_bytes_length(chunk$0));
                   var
                    _aT_ = Angstrom[50],
                    _aU_ = caml_call1(Angstrom[22], 1),
                    _aV_ = caml_call2(Angstrom[58], _aU_, _aT_);
                   return caml_call2(Angstrom[58], _aV_, m);
                  },
                _aQ_ =
                  caml_call2(Angstrom[59], check_end_of_body$1, Angstrom[50]);
               return caml_call2(Angstrom[53], _aQ_, _aP_);
              }
              var _aR_ = match[1];
              if(758940234 === _aR_){
               var data = match[2];
               write_data$1(data);
               return caml_call2(Angstrom[53], Angstrom[50], go);
              }
              if(848053268 <= _aR_){
               var line = match[2];
               write_line(line);
               return caml_call2(Angstrom[53], Angstrom[50], go);
              }
              var err = match[2], _aS_ = caml_call1(Angstrom[52], err);
              return caml_call2(Angstrom[58], Angstrom[50], _aS_);
             }
             return go(0);
            }
            var _aK_ = Bigstringaf[7], _aL_ = caml_string_get(end_of_body, 0);
            function _aM_(_aO_){return _aL_ !== _aO_ ? 1 : 0;}
            var _aN_ = caml_call2(Angstrom[72][2], _aM_, _aK_);
            return caml_call2(Angstrom[53], _aN_, _aJ_);
           },
         _aq_ = caml_call1(Angstrom[45], _am_);
       }
       else if(163344816 <= match){
        var _ar_ = function(m){return caml_call3(m, 0, 0, _h_);};
        caml_call1(Log[6], _ar_);
        var
         write_data$0 = function(x){return caml_call1(emitter, [0, x]);},
         expected_len$0 = caml_ml_string_length(end_of_body),
         _ai_ =
           function(ba, off, len){
            var raw = caml_call3(Bigstringaf[7], ba, off, len);
            return caml_call2(Stdlib_String[9], raw, end_of_body);
           },
         check_end_of_body$0 =
           caml_call2(Angstrom[72][5], expected_len$0, _ai_),
         _aj_ =
           function(m){
            function _a0_(len){
             if(0 === len){
              var
               _a1_ =
                 function(param){
                  return param ? m : caml_call1(Angstrom[51], 0);
                 };
              return caml_call2(Angstrom[53], Angstrom[1], _a1_);
             }
             function _a2_(chunk){
              try{
               var
                chr = caml_string_get(end_of_body, 0),
                max = caml_call1(Bigstringaf[6], chunk),
                idx = 0;
               for(;;){
                if(max <= idx)
                 throw caml_maybe_attach_backtrace(Stdlib[8], 1);
                if(runtime.caml_ba_get_1(chunk, idx) === chr) break;
                var idx$0 = idx + 1 | 0, idx = idx$0;
               }
              }
              catch(_be_){
               var _a4_ = caml_wrap_exception(_be_);
               if(_a4_ !== Stdlib[8])
                throw caml_maybe_attach_backtrace(_a4_, 0);
               write_data$0(caml_call1(Bigstringaf[8], chunk));
               var
                _a5_ = Angstrom[50],
                _a6_ = caml_call1(Angstrom[22], len),
                _a7_ = caml_call2(Angstrom[58], _a6_, _a5_);
               return caml_call2(Angstrom[58], _a7_, m);
              }
              var chunk$0 = caml_create_bytes(idx + 1 | 0);
              caml_call5(Bigstringaf[26], chunk, 0, chunk$0, 0, idx + 1 | 0);
              function _a8_(param){
               if(param){
                var
                 chunk =
                   caml_call3
                    (Stdlib_Bytes[8],
                     chunk$0,
                     0,
                     caml_ml_bytes_length(chunk$0) - 1 | 0);
                write_data$0(chunk);
                return Angstrom[50];
               }
               write_data$0(caml_call1(Stdlib_Bytes[44], chunk$0));
               var
                _bb_ = Angstrom[50],
                _bc_ = caml_call1(Angstrom[22], 1),
                _bd_ = caml_call2(Angstrom[58], _bc_, _bb_);
               return caml_call2(Angstrom[58], _bd_, m);
              }
              var
               _a9_ = Angstrom[50],
               _a__ = caml_call1(Angstrom[22], idx),
               _a$_ = caml_call2(Angstrom[58], _a__, check_end_of_body$0),
               _ba_ = caml_call2(Angstrom[59], _a$_, _a9_);
              return caml_call2(Angstrom[53], _ba_, _a8_);
             }
             var _a3_ = caml_call2(Angstrom[72][5], len, Bigstringaf[5]);
             return caml_call2(Angstrom[53], _a3_, _a2_);
            }
            return caml_call2(Angstrom[53], Angstrom[79], _a0_);
           },
         _aq_ = caml_call1(Angstrom[45], _aj_);
       }
       else{
        var _as_ = function(m){return caml_call3(m, 0, 0, _i_);};
        caml_call1(Log[6], _as_);
        var
         write_data = function(x){return caml_call1(emitter, [0, x]);},
         dec = caml_call1(Base64_rfc2045[3], -328752538),
         expected_len = caml_ml_string_length(end_of_body),
         _af_ =
           function(ba, off, len){
            var raw = caml_call3(Bigstringaf[7], ba, off, len);
            return caml_call2(Stdlib_String[9], raw, end_of_body);
           },
         check_end_of_body = caml_call2(Angstrom[72][5], expected_len, _af_),
         _ag_ =
           function(m){
            function _bf_(chunk){
             function go(param){
              var match = caml_call1(Base64_rfc2045[4], dec);
              if(typeof match === "number"){
               if(3455931 === match) return Angstrom[50];
               if(1006505782 <= match){
                var
                 chunk$0 =
                   caml_create_bytes(caml_ml_string_length(chunk) + 1 | 0);
                caml_call5
                 (Stdlib_Bytes[12],
                  chunk,
                  0,
                  chunk$0,
                  0,
                  caml_ml_string_length(chunk));
                var
                 _bl_ =
                   function(param){
                    if(param){
                     var
                      chunk =
                        caml_call3
                         (Stdlib_Bytes[7],
                          chunk$0,
                          0,
                          caml_ml_bytes_length(chunk$0) - 1 | 0);
                     caml_call4
                      (Base64_rfc2045[2],
                       dec,
                       chunk,
                       0,
                       caml_ml_bytes_length(chunk));
                     var
                      finish =
                        function(param){
                         var match = caml_call1(Base64_rfc2045[4], dec);
                         if(typeof match === "number"){
                          if(3455931 === match) return Angstrom[50];
                          if(1006505782 <= match)
                           throw caml_maybe_attach_backtrace
                                  ([0, Assert_failure, _a_], 1);
                          var _bu_ = caml_call1(Angstrom[52], cst_wrong_padding);
                          return caml_call2(Angstrom[58], Angstrom[50], _bu_);
                         }
                         if(659980059 <= match[1]){
                          var err = match[2], _bv_ = caml_call1(Angstrom[52], err);
                          return caml_call2(Angstrom[58], Angstrom[50], _bv_);
                         }
                         var data = match[2];
                         write_data(data);
                         return caml_call2(Angstrom[53], Angstrom[50], finish);
                        },
                      go =
                        function(param){
                         var match = caml_call1(Base64_rfc2045[4], dec);
                         if(typeof match === "number"){
                          if(3455931 === match) return Angstrom[50];
                          if(1006505782 <= match){
                           caml_call4(Base64_rfc2045[2], dec, Stdlib_Bytes[3], 0, 0);
                           return caml_call2(Angstrom[53], Angstrom[50], finish);
                          }
                          var _bs_ = caml_call1(Angstrom[52], cst_wrong_padding$0);
                          return caml_call2(Angstrom[58], Angstrom[50], _bs_);
                         }
                         if(659980059 <= match[1]){
                          var err = match[2], _bt_ = caml_call1(Angstrom[52], err);
                          return caml_call2(Angstrom[58], Angstrom[50], _bt_);
                         }
                         var data = match[2];
                         write_data(data);
                         return caml_call2(Angstrom[53], Angstrom[50], go);
                        },
                      _bo_ = go(0);
                     return caml_call2(Angstrom[58], Angstrom[50], _bo_);
                    }
                    caml_bytes_set
                     (chunk$0,
                      caml_ml_bytes_length(chunk$0) - 1 | 0,
                      caml_string_get(end_of_body, 0));
                    caml_call4
                     (Base64_rfc2045[2],
                      dec,
                      chunk$0,
                      0,
                      caml_ml_bytes_length(chunk$0));
                    var
                     _bp_ = Angstrom[50],
                     _bq_ = caml_call1(Angstrom[22], 1),
                     _br_ = caml_call2(Angstrom[58], _bq_, _bp_);
                    return caml_call2(Angstrom[58], _br_, m);
                   };
                return caml_call2(Angstrom[53], check_end_of_body, _bl_);
               }
               var _bm_ = caml_call1(Angstrom[52], cst_wrong_padding$1);
               return caml_call2(Angstrom[58], Angstrom[50], _bm_);
              }
              if(659980059 <= match[1]){
               var err = match[2], _bn_ = caml_call1(Angstrom[52], err);
               return caml_call2(Angstrom[58], Angstrom[50], _bn_);
              }
              var data = match[2];
              write_data(data);
              return caml_call2(Angstrom[53], Angstrom[50], go);
             }
             return go(0);
            }
            var _bg_ = Bigstringaf[7], _bh_ = caml_string_get(end_of_body, 0);
            function _bi_(_bk_){return _bh_ !== _bk_ ? 1 : 0;}
            var _bj_ = caml_call2(Angstrom[72][2], _bi_, _bg_);
            return caml_call2(Angstrom[53], _bj_, _bf_);
           },
         _aq_ = caml_call1(Angstrom[45], _ag_);
       }
      else
       var v = match[2], _aq_ = caml_call1(failf(_j_), v);
      var _aB_ = caml_call2(Angstrom[53], _aq_, _ao_);
     }
     else{
      var
       write_data$2 = function(data){return caml_call1(emitter, [0, data]);},
       _at_ =
         function(param){
          caml_call1(emitter, 0);
          return caml_call1(Angstrom[51], 0);
         },
       match$0 = content_encoding(header);
      if(typeof match$0 === "number")
       if(456100816 === match$0){
        var _au_ = function(m){return caml_call3(m, 0, 0, _k_);};
        caml_call1(Log[6], _au_);
        var
         dec$2 = caml_call1(Pecu[2], -328752538),
         _an_ =
           function(m){
            var match = caml_call1(Pecu[3], dec$2);
            if(typeof match === "number"){
             if(1006505782 > match) return Angstrom[50];
             var
              _bw_ =
                function(param){
                 if(param){
                  var
                   _bz_ =
                     function(n){
                      var _bA_ = Angstrom[50];
                      function _bB_(ba, off, len){
                       var chunk = caml_create_bytes(len);
                       caml_call5(Bigstringaf[26], ba, off, chunk, 0, len);
                       return caml_call4(Pecu[1], dec$2, chunk, 0, len);
                      }
                      var
                       _bC_ = caml_call2(Angstrom[72][1], n, _bB_),
                       _bD_ = caml_call2(Angstrom[58], _bC_, _bA_);
                      return caml_call2(Angstrom[58], _bD_, m);
                     };
                  return caml_call2(Angstrom[53], Angstrom[79], _bz_);
                 }
                 caml_call4(Pecu[1], dec$2, Stdlib_Bytes[3], 0, 0);
                 return Angstrom[50];
                };
             return caml_call2(Angstrom[53], Angstrom[1], _bw_);
            }
            var _bx_ = match[1];
            if(758940234 === _bx_){
             var data = match[2];
             write_data$2(data);
             return caml_call2(Angstrom[58], Angstrom[50], m);
            }
            if(848053268 <= _bx_){
             var line = match[2];
             caml_call1(emitter, [0, caml_call2(Stdlib[28], line, cst)]);
             return caml_call2(Angstrom[58], Angstrom[50], m);
            }
            var err = match[2], _by_ = caml_call1(Angstrom[52], err);
            return caml_call2(Angstrom[58], Angstrom[50], _by_);
           },
         _av_ = caml_call1(Angstrom[45], _an_);
       }
       else if(163344816 <= match$0){
        var _aw_ = function(m){return caml_call3(m, 0, 0, _l_);};
        caml_call1(Log[6], _aw_);
        var
         _ak_ =
           function(m){
            function _bE_(param){
             if(! param) return Angstrom[50];
             function _bF_(n){
              var _bG_ = Angstrom[50];
              function _bH_(ba, off, len){
               var chunk = caml_create_bytes(len);
               caml_call5(Bigstringaf[26], ba, off, chunk, 0, len);
               return write_data$2(caml_call1(Stdlib_Bytes[44], chunk));
              }
              var
               _bI_ = caml_call2(Angstrom[72][1], n, _bH_),
               _bJ_ = caml_call2(Angstrom[58], _bI_, _bG_);
              return caml_call2(Angstrom[58], _bJ_, m);
             }
             return caml_call2(Angstrom[53], Angstrom[79], _bF_);
            }
            return caml_call2(Angstrom[53], Angstrom[1], _bE_);
           },
         _av_ = caml_call1(Angstrom[45], _ak_);
       }
       else{
        var _ax_ = function(m){return caml_call3(m, 0, 0, _m_);};
        caml_call1(Log[6], _ax_);
        var
         dec$0 = caml_call1(Base64_rfc2045[3], -328752538),
         _ah_ =
           function(m){
            var match = caml_call1(Base64_rfc2045[4], dec$0);
            if(typeof match === "number"){
             if(3455931 === match) return Angstrom[50];
             if(1006505782 <= match){
              var
               _bK_ =
                 function(param){
                  if(param){
                   var
                    _bN_ =
                      function(n){
                       function _bP_(param){
                        return caml_call2(Angstrom[58], Angstrom[50], m);
                       }
                       function _bQ_(ba, off, len){
                        var chunk = caml_create_bytes(len);
                        caml_call5(Bigstringaf[26], ba, off, chunk, 0, len);
                        return caml_call4(Base64_rfc2045[2], dec$0, chunk, 0, len);
                       }
                       var _bR_ = caml_call2(Angstrom[72][1], n, _bQ_);
                       return caml_call2(Angstrom[53], _bR_, _bP_);
                      };
                   return caml_call2(Angstrom[53], Angstrom[79], _bN_);
                  }
                  caml_call4(Base64_rfc2045[2], dec$0, Stdlib_Bytes[3], 0, 0);
                  var _bO_ = caml_call1(Angstrom[51], 0);
                  return caml_call2(Angstrom[58], Angstrom[50], _bO_);
                 };
              return caml_call2(Angstrom[53], Angstrom[1], _bK_);
             }
             var _bL_ = caml_call1(Angstrom[52], cst_wrong_padding$2);
             return caml_call2(Angstrom[58], Angstrom[50], _bL_);
            }
            if(659980059 <= match[1]){
             var err = match[2], _bM_ = caml_call1(Angstrom[52], err);
             return caml_call2(Angstrom[58], Angstrom[50], _bM_);
            }
            var data = match[2];
            write_data$2(data);
            return caml_call2(Angstrom[58], Angstrom[50], m);
           },
         _av_ = caml_call1(Angstrom[45], _ah_);
       }
      else
       var v$0 = match$0[2], _av_ = caml_call1(failf(_n_), v$0);
      var _aB_ = caml_call2(Angstrom[53], _av_, _at_);
     }
     return caml_call2(Angstrom[55], _aB_, _aA_);
    }
    return body(0, header);
   }
   function blit(src, src_off, dst, dst_off, len){
    return caml_call5(Bigstringaf[24], src, src_off, dst, dst_off, len);
   }
   function parse(emitters, content_type){
    var
     parser$0 = parser(emitters, content_type),
     state = [0, caml_call1(Angstrom[77][1], parser$0)],
     ke = caml_call2(Ke_Rke[3], _q_, Stdlib_Bigarray[13]);
    return function(data){
     var match = state[1];
     switch(match[0]){
       case 0:
        var
         match$0 = match[1],
         continue$0 = match$0[2],
         committed = match$0[1];
        caml_call2(Ke_Rke[15][6], ke, committed);
        if(0 === committed) caml_call1(Ke_Rke[14], ke);
        var ___ = function(m){return caml_call3(m, 0, 0, _r_);};
        caml_call1(Log[6], ___);
        if(typeof data === "number"){
         var _$_ = function(m){return caml_call3(m, 0, 0, _s_);};
         caml_call1(Log[6], _$_);
         var match$1 = caml_call1(Ke_Rke[15][4], ke);
         if(match$1){
          var slice = match$1[1];
          if(match$1[2]){
           var _aa_ = function(m){return caml_call3(m, 0, 0, _t_);};
           caml_call1(Log[6], _aa_);
           state[1] =
            caml_call4
             (continue$0, slice, 0, caml_call1(Bigstringaf[6], slice), 1);
          }
          else{
           var
            _ab_ =
              function(m){
               return caml_call4
                       (m, 0, 0, _u_, caml_call1(Bigstringaf[8], slice));
              };
           caml_call1(Log[6], _ab_);
           state[1] =
            caml_call4
             (continue$0, slice, 0, caml_call1(Bigstringaf[6], slice), 0);
          }
         }
         else{
          var _ac_ = function(m){return caml_call3(m, 0, 0, _v_);};
          caml_call1(Log[6], _ac_);
          state[1] = caml_call4(continue$0, Bigstringaf[2], 0, 0, 0);
         }
        }
        else{
         var str = data[2];
         if(runtime.caml_string_notequal(str, "")){
          var
           _ad_ =
             function(m){
              return caml_call4(m, 0, 0, _w_, caml_call1(Ke_Rke[4], ke));
             };
          caml_call1(Log[6], _ad_);
          var
           _ae_ =
             function(m){
              return caml_call4(m, 0, 0, _x_, caml_call1(Ke_Rke[5], ke));
             };
          caml_call1(Log[6], _ae_);
          caml_call6
           (Ke_Rke[15][1],
            ke,
            blit,
            caml_ml_string_length,
            _y_,
            [0, caml_ml_string_length(str)],
            str);
          var match$2 = caml_call1(Ke_Rke[15][4], ke);
          if(! match$2)
           throw caml_maybe_attach_backtrace([0, Match_failure, _z_], 1);
          var slice$0 = match$2[1];
          state[1] =
           caml_call4
            (continue$0, slice$0, 0, caml_call1(Bigstringaf[6], slice$0), 1);
         }
        }
        return 192584839;
       case 1:
        var tree = match[2]; return [0, 759635106, tree];
       default: var msg = match[3]; return [0, 781116926, msg];
     }};
   }
   function of_stream_tbl(stream, content_type){
    var v = [0, -1], tbl = caml_call2(Stdlib_Hashtbl[1], 0, 16);
    function emitters(header){
     v[1]++;
     var idx = v[1], buf = caml_call1(Stdlib_Buffer[1], 256);
     caml_call3(Stdlib_Hashtbl[5], tbl, idx, buf);
     return [0,
             function(param){
              if(! param) return 0;
              var str = param[1];
              return caml_call2(Stdlib_Buffer[16], buf, str);
             },
             idx];
    }
    var parse$0 = parse(emitters, content_type);
    for(;;){
     var match = caml_call1(stream, 0);
     if(match)
      var str = match[1], data = [0, -976970511, str];
     else
      var data = 3456156;
     var match$0 = parse$0(data);
     if(typeof match$0 !== "number"){
      if(781116926 <= match$0[1]) return _A_;
      var m = match$0[2];
      return [0, [0, m, tbl]];
     }
    }
   }
   function of_stream_to_list(stream, content_type){
    var match = of_stream_tbl(stream, content_type);
    if(0 === match[0]){
     var
      match$0 = match[1],
      tbl = match$0[2],
      m = match$0[1],
      _Y_ = 0,
      _Z_ =
        function(k, b, a){
         return [0, [0, k, caml_call1(Stdlib_Buffer[2], b)], a];
        },
      assoc = caml_call3(Stdlib_Hashtbl[14], _Z_, tbl, _Y_);
     return [0, [0, m, assoc]];
    }
    var e = match[1];
    return [1, e];
   }
   function of_stream_to_tree(stream, content_type){
    var match = of_stream_tbl(stream, content_type);
    if(0 === match[0]){
     var
      match$0 = match[1],
      tbl = match$0[2],
      m = match$0[1],
      m$0 =
        map
         (function(k){
           var _X_ = caml_call2(Stdlib_Hashtbl[6], tbl, k);
           return caml_call1(Stdlib_Buffer[2], _X_);
          },
          m);
     return [0, m$0];
    }
    var e = match[1];
    return [1, e];
   }
   function stream_of_string(str){
    var consumed = [0, 0];
    return function(param){
     return consumed[1] ? 0 : (consumed[1] = 1, [0, str]);};
   }
   function of_string_to_list(str, content_type){
    return of_stream_to_list(stream_of_string(str), content_type);
   }
   function of_string_to_tree(str, content_type){
    return of_stream_to_tree(stream_of_string(str), content_type);
   }
   function part(opt, disposition, encoding, stream){
    if(opt)
     var sth = opt[1], header = sth;
    else
     var header = Multipart_form_Header[5];
    if(disposition)
     var
      v = disposition[1],
      header$0 =
        caml_call3
         (Multipart_form_Header[8],
          Multipart_form_Field_name[19],
          [0, 2, v],
          header);
    else
     var header$0 = header;
    if(encoding)
     var
      v$0 = encoding[1],
      header$1 =
        caml_call3
         (Multipart_form_Header[8],
          Multipart_form_Field_name[18],
          [0, 1, v$0],
          header$0);
    else
     var header$1 = header$0;
    var
     content_type = caml_call1(Multipart_form_Header[12], header$1),
     encoding$0 = content_encoding(header$1);
    if(1 - caml_call1(Multipart_form_Content_type[17], content_type))
     caml_call1(Fmt[13], _B_);
    if(typeof encoding$0 !== "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
    if(456100816 === encoding$0){
     var
      chunk = caml_create_bytes(4096),
      encoder = caml_call1(Pecu[7], -328752538),
      queue = caml_call2(Ke_Rke[3], _c_, 8),
      chunk_length = 4096,
      emit =
        function(param){
         caml_call2(Ke_Rke[11], queue, 256);
         var len = 4096 - caml_call1(Pecu[11], encoder) | 0;
         return [0, [0, caml_call1(Stdlib_Bytes[44], chunk), 0, len]];
        },
      go$2 =
        function(counter, param){
         for(;;){
          try{var chr = caml_call1(Ke_Rke[8], queue);}
          catch(_S_){
           var _Q_ = caml_wrap_exception(_S_);
           if(_Q_ !== Ke_Rke[1]) throw caml_maybe_attach_backtrace(_Q_, 0);
           var match = caml_call1(stream, 0);
           if(match){
            var
             match$0 = match[1],
             len$0 = match$0[3],
             off = match$0[2],
             buf = match$0[1];
            iter
             (function(chr){return caml_call2(Ke_Rke[6], queue, chr);},
              buf,
              off,
              len$0);
            continue;
           }
           caml_call2(Ke_Rke[6], queue, 257);
           continue;
          }
          var switcher = chr - 256 | 0;
          if(3 < switcher >>> 0){
           var _R_ = [0, 748194550, caml_call1(Stdlib_Char[1], chr)];
           if(939392865 <= caml_call2(Pecu[8], encoder, _R_)) return emit(0);
          }
          else
           switch(switcher){
             case 0:
              caml_call4(Pecu[10], encoder, chunk, 0, chunk_length);
              if(939392865 <= caml_call2(Pecu[8], encoder, 1006505782))
               return emit(0);
              break;
             case 1:
              caml_call2(Ke_Rke[11], queue, 258);
              if(939392865 <= caml_call2(Pecu[8], encoder, -879233260))
               return emit(0);
              break;
             case 2:
              caml_call2(Ke_Rke[11], queue, 259);
              if(939392865 <= caml_call2(Pecu[8], encoder, 3455931)){
               var len = 4096 - caml_call1(Pecu[11], encoder) | 0;
               return [0, [0, caml_call1(Stdlib_Bytes[44], chunk), 0, len]];
              }
              var _P_ = 0;
              if(counter >= 50) return caml_trampoline_return(go$2, [0, _P_]);
              var counter$0 = counter + 1 | 0;
              return go$2(counter$0, _P_);
             default:
              if(17724 !== caml_call2(Pecu[8], encoder, 1006505782))
               throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
              caml_call2(Ke_Rke[11], queue, 259);
              return 0;
           }
         }
        },
      go = function(param){return caml_trampoline(go$2(0, param));};
     caml_call4(Pecu[10], encoder, chunk, 0, chunk_length);
     var stream$0 = go;
    }
    else if(163344816 <= encoding$0)
     var stream$0 = stream;
    else{
     var
      chunk$0 = caml_create_bytes(4096),
      encoder$0 = caml_call1(Base64_rfc2045[8], -328752538),
      queue$0 = caml_call2(Ke_Rke[3], _e_, 8),
      chunk_length$0 = 4096,
      emit$0 =
        function(param){
         caml_call2(Ke_Rke[11], queue$0, 256);
         var len = 4096 - caml_call1(Base64_rfc2045[12], encoder$0) | 0;
         return [0, [0, caml_call1(Stdlib_Bytes[44], chunk$0), 0, len]];
        },
      go$1 =
        function(counter, param){
         for(;;){
          try{var chr = caml_call1(Ke_Rke[8], queue$0);}
          catch(_W_){
           var _U_ = caml_wrap_exception(_W_);
           if(_U_ !== Ke_Rke[1]) throw caml_maybe_attach_backtrace(_U_, 0);
           var match = caml_call1(stream, 0);
           if(match){
            var
             match$0 = match[1],
             len$0 = match$0[3],
             off = match$0[2],
             buf = match$0[1];
            iter
             (function(chr){return caml_call2(Ke_Rke[6], queue$0, chr);},
              buf,
              off,
              len$0);
            continue;
           }
           caml_call2(Ke_Rke[6], queue$0, 257);
           continue;
          }
          var switcher = chr - 256 | 0;
          if(2 < switcher >>> 0){
           var _V_ = [0, 748194550, caml_call1(Stdlib_Char[1], chr)];
           if(939392865 <= caml_call2(Base64_rfc2045[9], encoder$0, _V_))
            return emit$0(0);
          }
          else
           switch(switcher){
             case 0:
              caml_call4
               (Base64_rfc2045[11], encoder$0, chunk$0, 0, chunk_length$0);
              if
               (939392865
                <= caml_call2(Base64_rfc2045[9], encoder$0, 1006505782))
               return emit$0(0);
              break;
             case 1:
              caml_call2(Ke_Rke[11], queue$0, 258);
              if
               (939392865 <= caml_call2(Base64_rfc2045[9], encoder$0, 3455931)){
               var len = 4096 - caml_call1(Base64_rfc2045[12], encoder$0) | 0;
               return [0, [0, caml_call1(Stdlib_Bytes[44], chunk$0), 0, len]];
              }
              var _T_ = 0;
              if(counter >= 50) return caml_trampoline_return(go$1, [0, _T_]);
              var counter$0 = counter + 1 | 0;
              return go$1(counter$0, _T_);
             default:
              if
               (17724 !== caml_call2(Base64_rfc2045[9], encoder$0, 1006505782))
               throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
              caml_call2(Ke_Rke[11], queue$0, 258);
              return 0;
           }
         }
        },
      go$0 = function(param){return caml_trampoline(go$1(0, param));};
     caml_call4(Base64_rfc2045[11], encoder$0, chunk$0, 0, chunk_length$0);
     var stream$0 = go$0;
    }
    return [0, header$1, stream$0];
   }
   var
    _D_ = Multipart_form_Content_type[12][9],
    _E_ = caml_call1(Multipart_form_Content_type[11][4], cst_form_data),
    multipart_content_default =
      caml_call3(Multipart_form_Content_type[23], -1031569716, _E_, _D_);
   function multipart(rng, g, opt, boundary, parts){
    if(opt)
     var sth = opt[1], header = sth;
    else
     var header = Multipart_form_Header[5];
    if(boundary)
     var boundary$0 = boundary[1], boundary$1 = boundary$0;
    else
     var boundary$1 = caml_call2(rng, g, 8);
    var
     boundary$2 = caml_call1(Multipart_form_Content_type[12][8], boundary$1),
     content_type =
       caml_call2
         (Multipart_form_Header[4], Multipart_form_Field_name[17], header)
        ? caml_call1(Multipart_form_Header[12], header)
        : multipart_content_default,
     content_type$0 =
       caml_call2
        (Multipart_form_Content_type[21],
         content_type,
         [0, cst_boundary$0, boundary$2]),
     header$0 =
       caml_call3
        (Multipart_form_Header[9],
         Multipart_form_Field_name[17],
         [0, 0, content_type$0],
         header);
    return [0, header$0, parts];
   }
   function none(param){return 0;}
   function of_string(x){
    var once = [0, 0];
    function go(param){
     return once[1]
             ? 0
             : (once[1] = 1, [0, [0, x, 0, caml_ml_string_length(x)]]);
    }
    return go;
   }
   function symbol(s0, s1){
    var c = [0, s0];
    function go(param){
     for(;;){
      var match = caml_call1(c[1], 0);
      if(match){var x = match[1]; return [0, x];}
      if(c[1] !== s0) return 0;
      c[1] = s1;
     }
    }
    return go;
   }
   function of_part(param){
    var
     body = param[2],
     header = param[1],
     stream =
       caml_call4(Prettym[35], 0, 0, Multipart_form_Header[16][38], header);
    function content_stream(param){
     var match = caml_call1(stream, 0);
     if(! match) return 0;
     var v = match[1];
     return [0, [0, v, 0, caml_ml_string_length(v)]];
    }
    return symbol(content_stream, symbol(of_string(cst$0), body));
   }
   function to_stream(param){
    var
     parts = param[2],
     header = param[1],
     _I_ = caml_call1(Multipart_form_Header[12], header),
     match = caml_call1(Multipart_form_Content_type[22], _I_);
    if(match)
     var v = match[1], boundary = v;
    else
     var boundary = caml_call1(Fmt[11], _F_);
    var
     _J_ = caml_call1(Multipart_form_Rfc2046[3], boundary),
     beginner = caml_call2(Stdlib[28], _J_, cst$1),
     _K_ = caml_call1(Multipart_form_Rfc2046[5], boundary),
     inner = caml_call2(Stdlib[28], _K_, cst$2),
     _L_ = caml_call1(Multipart_form_Rfc2046[6], boundary),
     closer = caml_call2(Stdlib[28], _L_, cst$3),
     stream$1 = of_string(beginner),
     stream = stream$1,
     param$0 = parts;
    for(;;){
     if(param$0){
      var x = param$0[1];
      if(param$0[2]){
       var
        r = param$0[2],
        _M_ = of_string(inner),
        stream$0 = symbol(stream, symbol(of_part(x), _M_)),
        stream = stream$0,
        param$0 = r;
       continue;
      }
      var
       _N_ = of_string(closer),
       _O_ = symbol(stream, symbol(of_part(x), _N_));
     }
     else
      var _O_ = none;
     return [0, header, _O_];
    }
   }
   var
    _G_ = Multipart_form_Content_type[12],
    _H_ = Multipart_form_Content_type[11],
    Multipart_form =
      [0,
       [0,
        Multipart_form_Field_name[2],
        Multipart_form_Field_name[3],
        Multipart_form_Field_name[4],
        Multipart_form_Field_name[5],
        Multipart_form_Field_name[8],
        Multipart_form_Field_name[9],
        Multipart_form_Field_name[10],
        Multipart_form_Field_name[12],
        Multipart_form_Field_name[17],
        Multipart_form_Field_name[18],
        Multipart_form_Field_name[19],
        Multipart_form_Field_name[11]],
       [0,
        [0, Multipart_form_Content_type[10][11]],
        [0, _H_[2], _H_[6]],
        [0,
         _G_[1],
         _G_[2],
         _G_[3],
         _G_[4],
         _G_[6],
         _G_[7],
         _G_[8],
         _G_[11],
         _G_[9],
         _G_[18],
         _G_[25],
         _G_[26]],
        Multipart_form_Content_type[23],
        Multipart_form_Content_type[25],
        Multipart_form_Content_type[24],
        Multipart_form_Content_type[27],
        Multipart_form_Content_type[29]],
       [0,
        Multipart_form_Content_encodin[2],
        Multipart_form_Content_encodin[9],
        Multipart_form_Content_encodin[13]],
       [0,
        Multipart_form_Content_disposi[9],
        Multipart_form_Content_disposi[6],
        Multipart_form_Content_disposi[7],
        Multipart_form_Content_disposi[8],
        Multipart_form_Content_disposi[5],
        Multipart_form_Content_disposi[2],
        Multipart_form_Content_disposi[15],
        Multipart_form_Content_disposi[17]],
       [0],
       [0,
        Multipart_form_Header[2],
        Multipart_form_Header[4],
        Multipart_form_Header[12],
        Multipart_form_Header[13],
        Multipart_form_Header[14],
        Multipart_form_Header[7],
        Multipart_form_Header[10],
        Multipart_form_Header[1],
        [0, Multipart_form_Header[15][3]]],
       map,
       flatten,
       parse,
       parser,
       of_stream_to_list,
       of_string_to_list,
       of_stream_to_tree,
       of_string_to_tree,
       part,
       multipart,
       to_stream];
   runtime.caml_register_global(71, Multipart_form, "Multipart_form");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJtdWx0aXBhcnRfZm9ybS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZGVmYXVsdCQwIiwiZXJyb3JfbXNnZiIsImZtdCIsIm1zZyIsImlzX3RzcGVjaWFscyIsImlzX2N0bCIsImlzX3NwYWNlIiwiaXNfYXNjaWkiLCJpc190b2tlbiIsImMiLCJpc19vYnNfbm9fd3NfY3RsIiwiaXNfcXRleHQiLCJ0ZXh0IiwiaW1hZ2UiLCJhdWRpbyIsInZpZGVvIiwiYXBwbGljYXRpb24iLCJtdWx0aXBhcnQiLCJpc19kaXNjcmV0ZSIsImlzX211bHRpcGFydCIsImlldGYiLCJ0b2tlbiIsImV4dGVuc2lvbiIsImNociIsInBwIiwicHBmIiwidG9rZW4kMCIsInRvX3N0cmluZyIsImNvbXBhcmUiLCJhIiwiYiIsImVxdWFsIiwiaWV0ZiQwIiwiaWFuYSIsImlhbmFfZXhuIiwidiIsImVyciIsImV4dGVuc2lvbiQwIiwicHAkMCIsInRva2VuJDEiLCJjb21wYXJlJDAiLCJhJDAiLCJiJDAiLCJlcXVhbCQwIiwia2V5Iiwia2V5X2V4biIsIngiLCJrIiwidmFsdWUiLCJlc2NhcGVfY2hhcmFjdGVycyIsImxlbiIsImJ1ZiIsInYkMCIsInN5bWJvbF9tYXAiLCJmIiwidmFsdWVfZXhuIiwiZW1wdHkiLCJtZW0iLCJ0IiwiYWRkIiwic2luZ2xldG9uIiwicmVtb3ZlIiwiZmluZCIsIml0ZXIiLCJwcF9rZXkiLCJwcF92YWx1ZSIsInBwJDEiLCJvZl9lc2NhcGVkX2NoYXJhY3RlciIsInZhbHVlX3VuZXNjYXBlIiwicmVzIiwicG9zIiwidmFsdWVfY29tcGFyZSIsImIkMSIsImEkMSIsImEkMiIsImIkMiIsInZhbHVlX2VxdWFsIiwiY29tcGFyZSQxIiwiZXF1YWwkMSIsIm9mX2xpc3QiLCJsc3QiLCJ0b19saXN0IiwiZGVmYXVsdCQxIiwiZGVmYXVsdCQyIiwidHkiLCJzdWJ0eSIsInBhcmFtZXRlcnMiLCJpc19kaXNjcmV0ZSQwIiwiaXNfbXVsdGlwYXJ0JDAiLCJ3aXRoX3R5cGUiLCJ3aXRoX3N1YnR5cGUiLCJ3aXRoX3BhcmFtZXRlciIsImJvdW5kYXJ5IiwibWFrZSIsInBwJDIiLCJlcXVhbCQyIiwiaW52YWxpZF90b2tlbiIsIm9mX3N0cmluZyIsInMiLCJpc193c3AiLCJhdHRyaWJ1dGUiLCJ4X3Rva2VuIiwiZXh0ZW5zaW9uX3Rva2VuIiwidHkkMCIsInN1YnR5JDAiLCJfMyIsInkiLCJ6IiwiXzQiLCJkIiwic3ltYm9sIiwidXRmXzhfdGFpbCIsImIwIiwiYjEiLCJ1dGZfOF8wIiwidXRmXzhfMSIsImIyIiwidXRmXzhfMSQwIiwidXRmXzhfMiIsImIzIiwidXRmXzhfMiQwIiwidXRmXzhfYW5kIiwiaXMiLCJxdW90ZWRfcGFpciIsInF1b3RlZF9zdHJpbmciLCJ2YWx1ZSQwIiwicGFyYW1ldGVyIiwiY29udGVudCIsIm9mX3N0cmluZyQwIiwic3RyIiwic3ltYm9sX2JpbmQiLCJ0eSQxIiwic3VidHkkMSIsInYkMSIsInZhbHVlJDEiLCJ4JDAiLCJwYXJhbWV0ZXIkMCIsInBhcmFtZXRlcnMkMCIsInNlcCIsImNvbnRlbnRfdHlwZSIsInRvX3N0cmluZyQwIiwiZmlsZW5hbWUiLCJvcHQiLCJzaXplIiwibmFtZSIsInN0aCIsImtpbmQiLCJwcF9kaXNwb3NpdGlvbl90eXBlIiwiZGlzcG9zaXRpb25fdHlwZSIsIm5vdGhpbmdfdG9fZG8iLCJpc19kaWdpdCIsImRpc3Bvc2l0aW9uX3R5cGUkMCIsInF1b3RlZF9kYXRlX3RpbWUiLCJwYXJtIiwiZmlsZW5hbWVfcGFybSIsImNyZWF0aW9uX2RhdGVfcGFybSIsIm1vZGlmaWNhdGlvbl9kYXRlX3Bhcm0iLCJyZWFkX2RhdGVfcGFybSIsInNpemVfcGFybSIsImRpc3Bvc2l0aW9uX3Bhcm0iLCJjcmVhdGlvbiIsIm1vZGlmaWNhdGlvbiIsInJlYWQiLCJ2JDIiLCJ2JDMiLCJ2JDQiLCJkaXNwb3NpdGlvbiIsImRpc3Bvc2l0aW9uX3R5cGUkMSIsImRpc3Bvc2l0aW9uX3Bhcm0kMCIsImRpc3Bvc2l0aW9uJDAiLCJiaXQ4IiwiYml0NyIsImJpbmFyeSIsInF1b3RlZF9wcmludGFibGUiLCJiYXNlNjQiLCJtZWNoYW5pc20iLCJtZWNoYW5pc20kMCIsImNvbnRlbnRfdHJhbnNmZXJfZW5jb2RpbmciLCJjb250ZW50X2Rpc3Bvc2l0aW9uIiwiY2FwaXRhbGl6ZSIsImlkeCIsImkiLCJjYW5vbmljYWxpemUiLCJpc19mdGV4dCIsIm9mX3N0cmluZ19leG4iLCJwcmVmaXhlZF9ieSIsInByZWZpeCIsImZpZWxkIiwiZmllbGRfbmFtZSIsImZpZWxkX25hbWUkMCIsInBwX3Vuc3RyY3RyZCIsInciLCJpc191bnN0cnVjdHVyZWQiLCJnIiwib2ZfZmllbGRfbmFtZSIsInBhcnNlciIsIm1hdGNoJDAiLCJ3JDAiLCJwYXJzZXIkMCIsImVuY29kZXIiLCJmaWVsZCQwIiwiZSIsImFzc29jIiwiaGVhZGVyIiwiYWNjIiwicmVtb3ZlX2Fzc29jIiwiZXhpc3RzIiwiY29uY2F0IiwicmVwbGFjZSIsIm9mX2xpc3Rfd2l0aF9sb2NhdGlvbiIsImNvbnRlbnRfZW5jb2RpbmciLCJub29wIiwiaGVhZGVyJDAiLCJpc19iY2hhcnNub3NwYWNlIiwiaXNfYmNoYXJzIiwibWFrZV9kYXNoX2JvdW5kYXJ5IiwiZGFzaF9ib3VuZGFyeSIsIm1ha2VfZGVsaW1pdGVyIiwibWFrZV9jbG9zZV9kZWxpbWl0ZXIiLCJjbG9zZV9kZWxpbWl0ZXIiLCJkaXNjYXJkX2FsbF90b19kYXNoX2JvdW5kYXJ5IiwiZXhwZWN0ZWRfbGVuIiwiYmEiLCJvZmYiLCJyYXciLCJjaGVja19ib3VuZGFyeSIsIm0iLCJ0cmFuc3BvcnRfcGFkZGluZyIsImRpc2NhcmRfYWxsX3RvX2RlbGltaXRlciIsImRlbGltaXRlciIsImNoZWNrX2RlbGltaXRlciIsImNybGYiLCJib2R5X3BhcnQiLCJib2R5IiwiZmllbGRzIiwiZW5jYXBzdWxhdGlvbiIsInByZWFtYnVsZSIsImVwaWxvZ3VlIiwicGFyZW50IiwibXVsdGlwYXJ0X2JvZHkiLCJyIiwiZW5kX29mX2xpbmUiLCJzcmMiLCJtYXAiLCJib2R5JDAiLCJmbGF0dGVuIiwiZWx0IiwiZW5jb2RpbmciLCJmYWlsZiIsImVtaXR0ZXJzIiwiYm91bmRhcnkkMSIsImJvdW5kYXJ5JDAiLCJib3VuZGFyeSQyIiwicGFydHMiLCJjb250ZW50cyIsImlkIiwiZW1pdHRlciIsImVuZF9vZl9ib2R5Iiwid3JpdGVfZGF0YSQxIiwid3JpdGVfbGluZSIsImRlYyQxIiwiZXhwZWN0ZWRfbGVuJDEiLCJjaGVja19lbmRfb2ZfYm9keSQxIiwidHJhaWxlciIsImZpbmlzaCIsImRhdGEiLCJsaW5lIiwiZ28iLCJjaHVuayIsImNodW5rJDAiLCJ3cml0ZV9kYXRhJDAiLCJleHBlY3RlZF9sZW4kMCIsImNoZWNrX2VuZF9vZl9ib2R5JDAiLCJtYXgiLCJpZHgkMCIsIndyaXRlX2RhdGEiLCJkZWMiLCJjaGVja19lbmRfb2ZfYm9keSIsIndyaXRlX2RhdGEkMiIsImRlYyQyIiwibiIsImRlYyQwIiwiYmxpdCIsInNyY19vZmYiLCJkc3QiLCJkc3Rfb2ZmIiwicGFyc2UiLCJzdGF0ZSIsImtlIiwiY29udGludWUkMCIsImNvbW1pdHRlZCIsInNsaWNlIiwic2xpY2UkMCIsInRyZWUiLCJvZl9zdHJlYW1fdGJsIiwic3RyZWFtIiwidGJsIiwicGFyc2UkMCIsIm9mX3N0cmVhbV90b19saXN0Iiwib2Zfc3RyZWFtX3RvX3RyZWUiLCJtJDAiLCJzdHJlYW1fb2Zfc3RyaW5nIiwiY29uc3VtZWQiLCJvZl9zdHJpbmdfdG9fbGlzdCIsIm9mX3N0cmluZ190b190cmVlIiwicGFydCIsImhlYWRlciQxIiwiZW5jb2RpbmckMCIsInF1ZXVlIiwiY2h1bmtfbGVuZ3RoIiwiZW1pdCIsImdvJDIiLCJsZW4kMCIsInN0cmVhbSQwIiwiZW5jb2RlciQwIiwicXVldWUkMCIsImNodW5rX2xlbmd0aCQwIiwiZW1pdCQwIiwiZ28kMSIsImdvJDAiLCJtdWx0aXBhcnRfY29udGVudF9kZWZhdWx0Iiwicm5nIiwiY29udGVudF90eXBlJDAiLCJub25lIiwib25jZSIsInMwIiwiczEiLCJvZl9wYXJ0IiwiY29udGVudF9zdHJlYW0iLCJ0b19zdHJlYW0iLCJiZWdpbm5lciIsImlubmVyIiwiY2xvc2VyIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbXVsdGlwYXJ0X2Zvcm0vY29udGVudF90eXBlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbXVsdGlwYXJ0X2Zvcm0vY29udGVudF9kaXNwb3NpdGlvbi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL211bHRpcGFydF9mb3JtL2NvbnRlbnRfZW5jb2RpbmcubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9tdWx0aXBhcnRfZm9ybS9maWVsZF9uYW1lLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbXVsdGlwYXJ0X2Zvcm0vZmllbGQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9tdWx0aXBhcnRfZm9ybS9oZWFkZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9tdWx0aXBhcnRfZm9ybS9yZmMyMDQ2Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbXVsdGlwYXJ0X2Zvcm0vbXVsdGlwYXJ0X2Zvcm0ubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUE0SU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUE1SUZDLFdBQVdDO2tCQUFvQkMsS0FBTyx3QkFBUEEsTUFBdUI7SUFBckMsT0FBQSx5QkFBTkQ7R0FBZ0Q7R0FFL0Q7O1lBY0lFO0lBQWU7Ozs7Ozs7Ozs7Ozs7OztLQUdiOztJQUNHO0dBQUs7WUFFVkM7SUFBUyxpQ0FBa0Q7SUFBWjtHQUFpQjtHQUNyRCxTQUFYQyxlO1lBT0FDLGdCQUFXLDRCQUE4QztZQUV6REMsU0FBU0M7SUFDWCxXQUhFRixTQUVTRTtJQUNYO0tBQW1CLGVBakJqQkwsYUFnQlNLOztNQUNrQyxJQUFBLFdBWDNDSixPQVVTSSw4QkFBQUE7Ozs7OztJQUNxRDtHQUFZO1lBRTFFQztJQUFtQjs7Ozs7Ozs7OztLQUVkOztJQUQ2RDtHQUN4RDtZQUVWQztJQUFXOzs7Ozs7O0tBQTJDOztJQUFiO0dBQWlCO0dBQS9DO0lBUVRDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBQ0FDO0lBQWM7Ozs7Ozs7S0FBc0I7O0lBQVk7R0FBSztZQUNyREM7SUFBZSx1REFBdUI7SUFBWTtHQUFLO1lBQ3ZEQyxLQUFLQyxPQUFRLDBCQUFSQSxRQUE4QjtZQUVuQ0MsVUFBVUQ7SUFDWiw2QkFEWUE7S0FFUCxPQUFBLFdBM0RMcEIsaUJBeURZb0I7SUFJSCxZQUFBLGdCQUpHQTs7O0tBSVEsY0FBQSxnQkFKUkE7OztNQUtZO09BSWQ7UUFBQTtVQUFBOytCQVRFQSxnQ0FBQUE7O21CQVFHRTtXQUFjLGVBakM3QmYsU0FpQ2VlO29CQUFrQyxNQUFBO1dBQXBCO1VBQXVDO09BRDVEO09BR0EsK0JBVklGO09BVUo7Ozs7a0NBRUEsT0FBQSxXQXJFUnBCLGlCQXlEWW9COzs7O0lBYUgsT0FBQSxXQXRFVHBCLGlCQXlEWW9CO0dBYStEO1lBRXpFRyxHQUFHQztJOzs7Ozs7bUJBR08sb0JBSFBBO21CQUNNLG9CQUROQTs7O21CQUthLG9CQUxiQTttQkFFTyxvQkFGUEE7OztpQkFJTyxvQkFKUEE7aUJBTVcsb0JBTlhBOztTQU9TSjtLQUFTLE9BQUEsbUJBUGxCSSxVQU9TSjs7UUFDSEs7SUFBUyxPQUFBLG1CQVJmRCxVQVFNQzs7WUFFVEM7SUFBWTs7Ozs7OztRQU9BTjtJQUEwQixPQUExQkE7R0FBK0I7WUFFM0NPLFFBQVFDLEdBQUVDO0lBQ1o7S0FDMkQsT0FYekRILFVBU1VHO0tBRThCLE9BQUE7S0FBZixPQVh6QkgsVUFTUUU7S0FFQSxPQUFBO0lBQWdDLE9BQUE7R0FBZ0M7WUFFeEVFLE1BQU1GLEdBQUVDLEdBQUksYUFKWkYsUUFJTUMsR0FBRUMsV0FBbUI7R0F0RG5COzs7T0FNUmxCO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFFO09BZUFFO09BVUFHO09BU0FDO09BSUFHOztZQU9BQyxPQUFLWCxPQUVQLDBCQUZPQSxRQUVlO1lBRXBCWSxLQUFLWixPQUFRLDBCQUFSQSxRQUE4QjtZQUVuQ2EsU0FBU2I7SUFDTCxZQUhKWSxLQUVTWjsyQkFDY2MsY0FBSyxPQUFMQTtRQUFxQkM7SUFBUSxPQUFBLHNCQUFSQTtHQUF1QjtZQUVuRUQsRUFBRWQsT0FBUSxPQUhWYSxTQUdFYixPQUFzQjtZQUV4QmdCLFlBQVVoQjtJQUNaLDZCQURZQTtLQUVQLE9BQUEsV0FuSExwQixpQkFpSFlvQjtJQUlILFlBQUEsZ0JBSkdBOzs7S0FJUSxjQUFBLGdCQUpSQTs7O01BS1k7T0FJZDtRQUFBO1VBQUE7K0JBVEVBLGdDQUFBQTs7bUJBUUdFO1dBQWMsZUF6RjdCZixTQXlGZWU7b0JBQWtDLE1BQUE7V0FBcEI7VUFBdUM7T0FENUQ7T0FHQSwrQkFWSUY7T0FVSjs7OztrQ0FFQSxPQUFBLFdBN0hScEIsaUJBaUhZb0I7Ozs7SUFhSCxPQUFBLFdBOUhUcEIsaUJBaUhZb0I7R0FhK0Q7WUFFekVpQixLQUFHYjs7O1NBQ1NKO0tBQVMsT0FBQSxtQkFEbEJJLFVBQ1NKOzs7U0FDQUs7S0FBUyxPQUFBLG1CQUZsQkQsVUFFU0M7O1FBQ0hhO0lBQVMsT0FBQSxtQkFIZmQsVUFHTWM7O1lBRVRDLFVBQVFYLEdBQUVDO0lBQ1o7S0FDaUJXLE1BRlBaO0tBR09hLE1BSExaO0tBSTRCLE9BQUEsOEJBRHZCWTtLQUNHLE9BQUEsOEJBRkhEO0lBRXVCLE9BQUE7R0FBb0I7WUFFMURFLFFBQU1kLEdBQUVDLEdBQUksYUFOWlUsVUFNTVgsR0FBRUMsV0FBbUI7R0F4Q2hCO0lBQUE7O09BR1hFO09BSUFDO09BRUFDO09BR0FDO09BRUFFO09BZUFDO09BS0FFO09BTUFHO09BQ0EzQzs7WUFVQTRDLElBQUlBO0lBS047OztpQkFFU3JCO1NBQWMsZUE3SHZCZixTQTZIU2U7a0JBQWtDLE1BQUE7U0FBcEI7UUFBdUM7S0FENUQsb0NBTklxQjtLQVNKLGVBQUcsOEJBVENBO0tBU0o7Ozs7Z0NBQ29CLE9BQUEsV0FoS3RCM0MsaUJBc0pNMkM7OztHQVVrRTtZQUV0RUMsUUFBUUM7SUFDSixZQWJKRixJQVlRRTsyQkFDVVgsY0FBSyxPQUFMQTtRQUFxQkM7SUFBUSxPQUFBLHNCQUFSQTtHQUF1QjtZQUU5RFcsRUFBRUQsR0FBSSxPQUhORCxRQUdFQyxHQUFhO0dBRW5COzs7WUFFSUUsTUFBTWI7YUF5QkpjLGtCQUFrQkg7S0FDcEI7TUFBSUksNEJBRGdCSjtNQUVoQkssTUFBTSw2QkFETkQ7bUJBR0czQjtNQUNIOzs7O2lCQURHQTttQkFBQUEsY0FBQUE7OztrQkFBQUEsY0FBQUEsNEJBQUFBOzs7Ozs7TUFDQSxXQUlFLE9BQUEsOEJBUEw0QixLQUVHNUI7TUFHRCw4QkFMRjRCO01BUHFCLGVBU2xCNUI7Ozs7Ozs7Ozs7OztrQkFBQUE7O01BSW1CLE9BQUEsOEJBTnRCNEI7S0FPNEI7S0FOaEMsb0NBSG9CTDtLQUdwQixPQUFBLDZCQURJSztJQVNlO0lBbENuQjs7O2lCQUVTNUI7U0FBYyxlQTdJekJmLFNBNklXZTtrQkFBa0MsTUFBQTtTQUFwQjtRQUF1QztLQUQ1RCxvQ0FISVk7S0FNSixJQUFBLGVBTklBLEtBZ0ROaUI7Ozs7O1NBQUFBLE1BL0NGLFdBMUtBbkQsaUJBeUtRa0M7O2FBZ0ROaUIsUUFBYSxPQUFiQTtJQWdCRSxTQUFJQyxXQUFRUCxHQUFFUSxHQUFJLE9BQUEsNkJBQUpBLEdBQUZSLEdBQW9CO0lBQ2hDLGNBQXNDQSxHQUFLLFdBQUxBLEdBQWE7SUEzQnJEOzs7OztTQUVJLHlCQUVnQjtTQURJLE1BQUE7UUFDRDtLQUhyQiwwQ0F2Q0lYO0tBNENKLElBQUEsV0E1Q0lBOzs7OztnQkE4Q0osV0F2TkpsQyxpQkF5S1FrQzs7SUFpRThCLE9BRDlCa0IsV0FBQUEsaUJBdkNKSjtHQXdDbUQ7WUFFckRNLFVBQVVUO0lBQ04sWUFwRUpFLE1BbUVVRjsyQkFDVVgsY0FBSyxPQUFMQTtRQUFxQkM7SUFBUSxPQUFBLHNCQUFSQTtHQUF1QjtZQUVoRWdCLElBQUVOLEdBQUksT0FITlMsVUFHRVQsR0FBZTtPQUNqQlU7WUFFQUMsSUFBSWIsS0FBSWMsR0FHVixPQUFBLG9CQUhNZCxLQUFJYyxHQUdHO1lBRVhDLElBQUlmLEtBQUlJLE9BQU1VLEdBQUksT0FBQSxtQkFBZGQsS0FBSUksT0FBTVUsR0FBdUI7WUFDckNFLFVBQVVoQixLQUFJSSxPQUFRLE9BQUEsbUJBQVpKLEtBQUlJLE9BQStCO1lBQzdDYSxPQUFPakIsS0FBSWMsR0FBSSxPQUFBLG1CQUFSZCxLQUFJYyxHQUFvQjtZQUUvQkksS0FBS2xCLEtBQUljO0lBQ1gsSUFBTSxJQUFvQlosSUFBcEIsb0JBRENGLEtBQUljOzs7NEJBQ29EOzs7SUFBaEMsV0FBTFo7R0FBeUM7WUFFakVpQixLQUFLVCxHQUFFSSxHQUFJLE9BQUEsb0JBQU5KLEdBQUVJLEdBQWdCO09BQ3ZCTTtZQUVBQyxTQUFTeEM7STtTQUVGdUI7S0FBUyxPQUFBLG1CQUZQdkIsVUFFRnVCOztRQUREM0I7SUFBUyxPQUFBLG9CQUROSSxLQUNISjs7WUFHTjZDLEtBQUd6QyxLQUFJaUM7YUFDTGxDLEdBQUdDO1NBQVV1QixrQkFBTEo7S0FBYyxPQUFBLG1CQUFuQm5CLFVBUEx1QyxRQU9VcEIsS0FMVnFCLFVBS2VqQjs7SUFDb0IsSUFBQSxPQUFBLG9CQUY1QlUsSUFFSyxXQUFBO0lBQXVCLE9BQUEsMEJBRGpDbEMsSUFEQ0M7R0FFZ0Q7WUFFbkQwQyxxQkFRQTFEO0lBUnVCLGVBUXZCQTs7OztRQVBVOztRQUNBOztRQUlBOztRQUZBOztRQUdBOztRQUpBOztRQUVBOztJQUdMLE9BQUxBO0dBQU07WUFFTjJELGVBQWV0QjtJQUNqQjtLQUFJSSw0QkFEYUo7S0FFYnVCLE1BQU0sNkJBRE5uQjtLQUVBb0I7O1FBQUFBLFVBRkFwQixLQWFKLE9BQUEsNkJBWkltQjtlQUdDLGdCQUxZdkIsR0FHYndCLFdBQUFBLFVBRkFwQjtNQU9vQixXQWxCdEJpQixxQkFrQjRDLGdCQVI3QnJCLEdBR2J3QjtNQUtBLDhCQU5BRDtNQUNBQyxTQUFBQTs7O0tBUW9CLFdBQUEsZ0JBWFB4QixHQUdid0I7S0FRQSw4QkFUQUQ7S0FDQUM7O0dBV2U7WUFFakJDLGNBQWMxQyxHQUFFQztJQUNsQixTQURnQkQ7U0FLUFksTUFMT1o7Y0FBRUM7TUFLd0MsSUFBdkNZLE1BTERaLE1BS3dDLE9BckJ4RHNDLGVBcUJpQjFCLE1BQW9CLE9BckJyQzBCLGVBcUJPM0I7TUFBaUQsT0FBQTs7U0FGeEMrQixNQUhBMUMsTUFHVDJDLE1BRUFoQzs7O1NBSERpQyxNQUZRN0M7Y0FBRUM7VUFFRDZDLE1BRkM3QztNQUVJLE9BQUEsOEJBQWQ0QyxLQUFTQzs7U0FDQ0gsTUFEVkUsS0FDQ0QsTUFIUzNDOztJQUlDLFdBcEJqQnNDLGVBbUJPSztJQUNMLE9BQUEsb0NBRGNEO0dBRTBEO1lBRTFFSSxZQUFZL0MsR0FBRUM7SUFDaEIsU0FEY0Q7U0FJTFksTUFKS1o7Y0FBRUM7TUFJd0MsSUFBckNZLE1BSkhaLE1BSXdDLE9BM0J0RHNDLGVBMkJpQjFCLE1BQWtCLE9BM0JuQzBCLGVBMkJPM0I7TUFBK0MsT0FBQTs7U0FEdEMrQixNQUhGMUMsTUFHUDJDLE1BQ0FoQzs7O1NBRkRpQyxNQUZNN0M7Y0FBRUM7VUFFQzZDLE1BRkQ3QztNQUVNLE9BQUEsNkJBQWQ0QyxLQUFTQzs7U0FDQ0gsTUFEVkUsS0FDQ0QsTUFITzNDOztJQUd3QyxXQTFCdERzQyxlQTBCT0s7SUFBa0MsT0FBQSxtQ0FBekJEO0dBQ3dEO0dBRTlEO0lBQVZLLFlBQVUsb0JBYlZOO0lBY0FPLFVBQVEsb0JBUFJGO1lBU0FHLFFBQVFDO0lBQ1Y7a0JBQW9CbkQ7S0FBTCxJQUFhbUIsa0JBQUxKO0tBQWUsT0FBQSxtQkFBZkEsS0FBS0ksT0FBUm5CO0lBQXNDO0lBQTFELE9BQUEsd0NBRFVtRDtHQUM4RDtZQUV0RUMsUUFBUXZCLEdBQUksT0FBQSxvQkFBSkEsR0FBa0I7R0FDaEI7SUFBVndCLFlBQVU7SUF4S0k7OztPQU9kdEM7T0FZQUM7T0FHQUU7O09BSUFDO09BbUVBTztPQUdBSDtPQUNBSTtPQUVBQztPQUtBRTtPQUNBQztPQUNBQztPQUVBQztPQUdBQztPQUNBQztPQUVBQztPQUlBQztPQUlBQztPQVVBQztPQWdCQUc7T0FPQUs7T0FNQUM7T0FDQUM7T0FFQUM7T0FHQUU7T0FDQUM7SUFhVyxNQUFBO0lBSmJDO1lBT0FDLGNBQUtBLGVBQVUsT0FBVkE7WUFDTEMsaUJBQVFBLGtCQUFhLE9BQWJBO1lBQ1JDLHNCQUFhQSx1QkFBa0IsT0FBbEJBO1lBQ2JDO1FBQWNIO0lBQVUsT0FBQSxvQkFBVkE7O1lBQ2RJO1FBQWVKO0lBQVUsT0FBQSxvQkFBVkE7O1lBQ2ZLLFVBQW1DL0IsR0FBRTBCLElBQU0sV0FBTkEsSUFBRjFCLE1BQUFBLE1BQXFCO1lBQ3hEZ0MsYUFBeUNoQyxHQUFFMkIsT0FBUyxXQUFYM0IsTUFBRTJCLE9BQUYzQixNQUEyQjtZQUVwRWlDLGVBQ0NqQztJQUFKO0tBQVV2QjtLQUFIWTtLQUNGdUMsYUFBYSxtQ0FEWHZDLEdBQUdaLElBQU51QjtLQUVtQixPQUFBLDJCQURsQjRCO0lBQ0osV0FGRzVCLE1BQUFBO0dBRWtEO1lBRW5Ea0M7SUFDSTtLQURPTjtLQUNQLFFBQUEsMENBRE9BO2dCQUdIO1FBREluRDtJQUFpQixXQUFqQkE7O1lBR1owRCxLQUFLVCxJQUFHQyxPQUFNQztJQUNoQixXQURPRixJQUFHQyxPQUNnQiwyQkFEVkM7R0FDeUM7WUFFdkRRLEtBQUdyRTtJQUVIO0tBRm9CNkQ7S0FBUEQ7S0FBSkQ7S0FFVCxPQUFBLDJCQUZvQkU7S0FDNEIsT0FBQTtJQUNoRCxPQUFBO3FCQUZHN0Qsb0JBQU0yRCxnQkFBSUM7O1lBSWJVLFFBQU1sRSxHQUFFQztJQUNWLFdBQUEscUJBRFFELE1BQUVDO0lBQ1Y7S0FDRyxXQUFBLHVCQUZLRCxNQUFFQztLQUVQO01BQ3lDO09BQUEsT0FBQSwyQkFIbENBO09BR1csT0FBQSwyQkFIYkQ7TUFHb0MsT0FBQTs7Ozs7O0lBRHpDO0dBQ2dFO1lBSy9EbUUsY0FBYzNFO0lBQVEsT0FBQSxzQ0FBUkE7R0FBK0M7WUFFN0Q0RSxVQUFVQyxHQUFFckU7SUFDUixZQUFBLDRCQURRQSxHQUFGcUU7dUJBR0M7UUFEUi9EO0lBQUssV0FBTEE7R0FDWTtZQUVmZ0UsY0FBUyxnQ0FBbUMsVUFBWixTQUFpQjtHQUN6QztJQUFSOUUsUUFBUSx5QkFoVlZiO0lBd1ZFNEYsWUFBWSx5QkFSWi9FO0lBNkJtRCxNQUFBO3VCQUE3QyxrQ0FBbUMsVUFBWixTQUFrQjtHQUFqRDtJQUFBLE1BQUE7SUFBQSxNQUFBO0lBREVnRixVQUNGLDhCQTdCRWhGOztJQW9DWTs7OztLQUNXLG9CQUFnQmMsR0FBSyx1QkFBTEEsR0FBZTtLQUFuQixPQUFBLHlCQVRuQ2tFOztJQVVLLGNBQW1CbEUsR0FBSyxzQkFBTEEsR0FBa0I7SUFBdEIsT0FBQSx5QkF0Q3BCZDtHQXNDMEM7R0FGNUMsSUFERWlGLGtCQUNGO2dCQVljSjtJQUVSLFlBQUEsOEJBRlFBOztLQU9LLE9BQUE7O0tBRk4sT0FBQTs7S0FEQSxPQUFBOztLQUlJLE9BQUE7O0tBTEwsT0FBQTs7S0FHQyxPQUFBO0lBSVAsY0FoRUpELFVBc0RZQyxHQWJaSTtrQkF5QlEsT0FwRVJOLGNBd0RZRTtRQVdQL0Q7SUFBSyxPQUFBLHlCQUFMQTtHQUNrQjtHQVp6QixJQURFb0UsT0FDRix5QkFoREVsRjtnQkFtRVk2RTtJQUNkO0tBQ1UsSUFBSjlDLHFCQUZROEMsSUFHWixPQUFBLHlCQURJOUM7S0FDSjs7Ozs7S0FFTSxZQTlFTjZDLFVBeUVZQyxHQWhDWkk7aUJBdUNVLE9BbEZWTixjQTJFWUU7U0FNTC9EO0tBQUssT0FBQSx5QkFBTEE7O0dBQ21CO0dBUDVCLElBREVxRSxVQUNGLHlCQW5FRW5GO1lBNEVBb0YsR0FBRzNELEdBQUU0RCxHQUFFQyxHQUFJLFdBQVI3RCxHQUFFNEQsR0FBRUMsR0FBYTtZQUNwQkMsR0FBRy9FLEdBQUVDLEdBQUVyQixHQUFFb0csR0FBSSxXQUFWaEYsR0FBRUMsR0FBRXJCLEdBQUVvRyxHQUFnQjtPQUN6QkM7dUJBQ3dCLHNDQUE4QztHQUF6RCxJQUFiQyxhQUFhO2dCQUdrREM7a0JBQzlDQztLQUNULElBQU41QyxNQUFNO0tBQ1YsZUFESUEsUUFGNkQyQztLQUlqRSxlQUZJM0MsUUFEZTRDO0tBSVosV0FBQSw2QkFISDVDO0tBR0csT0FBQTtJQUE0QjtJQUpwQixPQUFBLHlCQUpiMEM7R0FRaUM7dUJBTDNCLHNDQUFnRDtHQUF4RDtJQUFBLE1BQUE7SUFERUcsVUFDRjt1QkFrQmtCLHFDQUE4QztHQUExRDtJQUFBLE1BQUE7SUFERixNQUFBLHlCQXZCRlQsU0FHQU0sWUFBQUE7dUJBa0JnQixzQ0FBOEM7R0FBMUQ7SUFBQSxNQUFBO0lBRE8sTUFBQTtJQUFULE1BQUEseUJBcEJGTixjQUdBTTt1QkFlZ0Isc0NBQThDO0dBQTFEO0lBQUEsTUFBQTtJQURGLE1BQUEseUJBakJGTixTQUdBTSxZQUFBQTt1QkFZWSxzQ0FBOEM7R0FBMUQ7SUFBQSxNQUFBO0lBRE8sTUFBQTtJQUFULE1BQUEseUJBZEVOLGNBR0FNO0lBV0YsTUFBQTtJQUFBLE1BQUE7SUFERUksVUFDRjs7SUFjWTtLQUFhQztLQUFKSDtLQUFKRDtLQUNiM0MsTUFBTTtJQUNWLGVBRElBLFFBRGEyQztJQUdqQixlQUZJM0MsUUFEaUI0QztJQUlyQixlQUhJNUMsUUFEcUIrQztJQUtsQixXQUFBLDZCQUpIL0M7SUFJRyxPQUFBO0dBQTRCO0dBTG5DLElBREVnRCxZQUNGLHlCQWZFRjt1QkE4QmdCLHNDQUE4QztHQUExRDtJQUFBLE1BQUE7SUFETyxNQUFBO0lBQVQsTUFBQSx5QkF6Q0ZQLGNBRUFHLFlBQUFBO3VCQXFDZ0IscUNBQThDO0dBQTFEO0lBQUEsT0FBQTtJQURGO01BQUEseUJBdENGSCxVQUVBRyxZQUFBQSxZQUFBQTt3QkFrQ1ksc0NBQThDO0dBQTFEO0lBQUEsT0FBQTtJQURPLE9BQUE7SUFBVCxPQUFBLHlCQW5DRUgsZ0JBRUFHLFlBQUFBO0lBaUNGLE9BQUE7SUFERU8sVUFDRjs7SUFXWTtLQUFpQkM7S0FBSkg7S0FBSkg7S0FBSkQ7S0FDYjNDLE1BQU07SUFDVixlQURJQSxRQURhMkM7SUFHakIsZUFGSTNDLFFBRGlCNEM7SUFJckIsZUFISTVDLFFBRHFCK0M7SUFLekIsZUFKSS9DLFFBRHlCa0Q7SUFNdEIsV0FBQSw2QkFMSGxEO0lBS0csT0FBQTtHQUE0QjtHQU5uQyxJQURFbUQsWUFDRix5QkFaRUY7WUFvQkFHLFVBQVVDO0lBQ1o7S0FBZSxPQUFBO0tBQWYsT0FBQSx3QkFEWUE7S0FDWixPQUFBO0tBQUEsT0FBQSwrQkFuREVSO0tBbURGLE9BQUEsK0JBN0JFRztJQW9CRixPQUFBLCtCQURFRztHQVU4RDtHQUdGO0lBQUEsT0FBQTs7O0lBQTlELE9BQUE7SUFBQSxPQUFBO0lBQUEsT0FBQTtJQURFRyxjQUNGO0lBS0ksT0FBQTtJQURELE9BQUE7SUFEK0IsT0FQaENGLFVBNWNGOUc7SUFtZGlCLE9BQUEseUJBSmZnSDtJQUlVLE9BQUE7SUFBWixPQUFBO0lBQUEsT0FBQTtJQUFBLE9BQUE7SUFERUMsZ0JBQ0Y7aUJBV21CekYsR0FBSyxXQUFMQSxHQUF1QjtHQUF0QyxXQUFBLHlCQXJKRmQ7aUJBb0pPYyxHQUFLLFdBQUxBLEdBQXdCO0dBRGpDO0lBQUEsT0FBQSx5QkFWRXlGO0lBU0FDLFVBQ0Y7aUJBU2tCekI7a0JBQ2tEcEQsT0FDcEUsV0FGa0JvRCxXQUNrRHBELE9BQ2xEO0lBRGU7S0FBQSxPQUFBLHlCQTlKL0JtRDtLQThKbUIsT0FBQTtLQUFyQixPQUFBLHlCQTlKRUE7S0E4SkYsT0FBQTtLQUFBLE9BQUE7S0FBQSxPQUFBLCtCQVhFMEI7SUFXOEQsT0FBQTtHQUM5QztHQUZsQixJQURFQyxZQUNGLHlCQXBKRTFCO2lCQStLbURoQjs7bUJBRUdDO29CQUVoREMsWUFBYyxXQUorQkYsSUFFR0MsT0FFaERDLFlBQXVDO01BRFI7T0FBQSxPQUFBLHlCQTNMckNhO09BMkx5QixPQUFBO09BQXJCLE9BQUEseUJBM0xKQTtPQTJMSSxPQUFBO09BQUEsT0FBQTtPQUFELE9BQUEsK0JBL0JIMkI7T0ErQkYsT0FBQTtNQUNJLE9BQUE7S0FBMkM7S0FGakI7TUFBQSxPQUFBLHlCQTFMNUIzQjtNQTBMRixPQUFBLHlCQTFMRUE7TUEwTEYsT0FBQSwrQkF2SEVLO01BdUhGLE9BQUE7S0FBb0QsT0FBQTtJQUVMO0lBSC9DLFdBQUE7SUFBYSxPQUFBO0dBR2tDO0dBSnBCO0lBQUEsT0FBQSx5QkF4THpCTDtJQXdMRixPQUFBLHlCQXhMRUE7SUF3TEYsT0FBQSwrQkF4SUVJO0lBd0lGLE9BQUE7SUFERXdCLFVBQ0Y7SUFsTWE7O09BR1gvQjtPQUVBQztPQUtBRTtPQUNBOUU7T0FRQStFO09BUkEvRTtPQTRCQWdGO09BT0FDO09BWUFDO09BbUJBQztPQVVBQztPQUNBRztPQUNBRTtPQUNBQztPQUVBRztPQXNCQUc7T0FtQkFHO09BU0FDO09BR0FFO09BR0FDO09BU0FDO09BU0FDO09BMkJBQztZQVFGQyxZQUFVQztJQUNaLElBQUlDO2FBQTBCN0UsV0FBUVAsR0FBRVEsR0FBSSxPQUFBLDZCQUFKQSxHQUFGUixHQUFvQjtrQkFLbERtRjtLQUNGLFlBQUEseUNBREVBO3dCQUdLLE9BQUEsV0F2akJYaEksa0JBb2pCTWdJO1NBRUg5RjtLQUFLLFdBQUxBO0lBQ2tFO0lBSG5FO3VCOzs7S0FIQSxJQUFTQTtLQUFNLE9BQUEsMEJBQU5BO0lBQTJCO0lBR3BDLE9BQUE7YUFMQStGO2FBQTBCN0U7ZUFDOUI7aUJBREk2RTtpQkFBMEI3RSxXQUM5Qix5QkFGWTRFOzs7O0dBUzJEO1lBS25FRSxLQUFHMUc7STs7Ozs7O21CQUdPLHdCQUhQQTttQkFDTSx3QkFETkE7OzttQkFLYSx3QkFMYkE7bUJBTVMsd0JBTlRBOzs7aUJBSU8sd0JBSlBBOzs7bUJBRU8sd0JBRlBBO21CQU9XLHdCQVBYQTs7U0FRU1U7S0FBSyxPQUFBLHdCQVJkVixLQVFTVTs7UUFDSGlCO2tCQUFnQmpCLEdBQUssT0FBQSw4QkFBTEEsR0FBYTtJQUF4QixPQUFBLG9DQVRYVixLQVNNMkI7O1lBRVRnRixRQUFNM0c7OztTQUNNVTtLQUFLLE9BQUEsd0JBRFhWLEtBQ01VOzs7U0FDQWlCO0tBQUssT0FBQSx3QkFGWDNCLEtBRU0yQjs7UUFDSGlGO2tCQUFnQmxHLEdBQUssT0FBQSxnQ0FBTEEsR0FBYTtJQUF4QixPQUFBLG9DQUhSVixLQUdHNEc7O1lBRVRDLFFBQU03RztJO0tBRTBCO01BQWRxQjtpQkFBc0M7aUJBQVY7TUFBZCxXQUFFO0tBQVgsT0FBQSx3QkFGakJyQixXQUVZcUI7O0lBRGEsSUFBZHlGLGdCQUFjLFdBQUU7SUFBWCxPQUFBLHdCQURoQjlHLFdBQ1c4Rzs7WUFHakJDLFlBQVUvRzs7S0FBVVU7S0FBTFM7O2dCQUMrQix1QkFMOUMwRjs7Z0JBSzZCOztnQkFBZjtJQUFoQixPQUFBLHdCQURZN0csNkJBQUttQixLQUFLVDs7WUFHcEJzRyxhQUFXaEgsS0FBSTZEO0lBQ2pCLFNBQUlvRCxJQUFJakg7S0FBUzs7TUFBUyxXQUFFO0tBQUYsT0FBQSx3QkFBbEJBO0lBQXFDO0lBQzNCOztLQUFBLE9BQUEsNEJBRGRpSCxTQUpGRjtnQkFLYztJQUFoQixPQUFBLHdCQUZhL0csNkJBQUk2RDtHQUVvRDtZQUVuRXFELGFBQWFsSCxLQUFJaUM7SUFDbkIsR0FEbUJBOzthQUFBQTthQUFBQTthQUFBQTs7aUJBa0JYLHVCQXRCTitFOztpQkFvQk07O2lCQUZBLHVCQTlCTkw7O2lCQTRCTTs7aUJBRkEsdUJBckNORDs7MkJBMkJhMUc7OztZQUFJaUM7WUFBQUE7O2dCQUl1Qix1QkFwQnhDMEU7O2dCQW9CdUI7O2dCQUFYLHVCQS9CWkQ7bUNBMkJhMUc7R0FxQmdCO0dBbkRsQjs7VUFHWDBHLE1BV0FDLFNBS0FFLFNBSUFFLGFBR0FDLGNBSUFFO1lBd0JGQyxZQUFVekc7SUFBSSxPQUFBLDBDQUFKQTtHQUE0Qzs7OztPQS9tQnREbEM7O09BZ0JBRztPQU1BQztPQUNBQztPQU9BQztPQUVBQztPQUdBRTtPQUlBQzs7OztPQXlSQXdFO09BT0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFDO09BS0FDO09BS0FDO09BR0FDO09BSUFDOztPQThNQWlDOztPQWlFQVk7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDL2xCQTNJLFdBQVdDO2tCQUFvQkMsS0FBTyx3QkFBUEEsTUFBdUI7SUFBckMsT0FBQSx5QkFBTkQ7R0FBZ0Q7WUFFM0RpQyxFQUFHMEcsVUFBV0MsS0FBaUNDLE1BQUtDO0lBQ3RELEdBRGdCRixTQUFPRyxNQUFQSCxRQUFBSSxPQUFPRCxjQUFQQztJQUNoQjtZQURnQkE7WUFBWEw7Ozs7WUFBNENFO2tDQUFLQztHQVNyRDtZQUVDRyxvQkFBb0IxSDtJOztlQUVMLG9CQUZLQTtlQUNULG9CQURTQTs7U0FHUlU7S0FBSyxPQUFBLG1CQUhHVixVQUdSVTs7UUFDSGlCO0lBQUssT0FBQSxtQkFKTTNCLFVBSVgyQjs7WUFFVGEsU0FBU3hDO0k7U0FDRlU7S0FBSyxPQUFBLG1CQURIVixVQUNGVTs7UUFDRGlCO0lBQUssT0FBQSxvQkFGRjNCLEtBRUgyQjs7WUFFTjVCLEdBQUdDLEtBQUlpQztJQUNULFdBRFNBLHNCQWtCSCxPQUFBO2tCQURLSjs7TUFBZSxJQUFTbkIsY0FBSFk7TUFBUyxPQUFBLFdBQTlCTyxHQUFxQlAsR0FBR1o7S0FBWTtLQUFyQixPQUFBO0lBQXFCO0lBRDNDO0tBQUEsT0FBQSwwQ0FwQkY4QjtZQUlPUDtLQWFGLE9BQUE7WUFiRUE7S0FXSyxPQUFBO0tBQVAsT0FBQTtZQVhFQTtLQVNLLE9BQUE7S0FBUCxPQUFBO1lBVEVBO0tBT0ssT0FBQTtLQUFQLE9BQUE7WUFQRUE7S0FLRixPQUFBOzs7YUFMRmpDOzthQVZIMEg7YUFVT3pGOzs7Ozs7Ozs7Ozs7O0dBbUJLO1lBRVpzRixLQUFLdEY7SUFDRCxZQUFBLHdDQURDQTtnQkFHRztRQURLdkI7SUFBZ0IsV0FBaEJBO0dBQ0Q7WUFFWjBHLG9CQUFXQSxxQkFBZ0IsT0FBaEJBO1lBQ1hFLGdCQUFPQSxpQkFBWSxPQUFaQTtZQUNQSyw0QkFBbUJoRSxlQUFVLE9BQVZBO1lBRW5CakIscUJBUUExRDtJQVJ1QixlQVF2QkE7Ozs7UUFQVTs7UUFDQTs7UUFJQTs7UUFGQTs7UUFHQTs7UUFKQTs7UUFFQTs7SUFHTCxPQUFMQTtHQUFNO1lBRU5DO0lBQW1COzs7Ozs7Ozs7O0tBRWQ7O0lBRDZEO0dBQ3hEO1lBRVZDLFNBRUFGO0lBRlcsV0FFWEE7Ozs7Ozs7S0FEZ0Q7O0lBQzNDLE9BTkxDLGlCQU1BRDtHQUF1QjtZQUV2QjBGLGNBQVMsZ0NBQW1DLFVBQVosU0FBaUI7WUF5Qi9DL0Y7SUFBZTs7Ozs7Ozs7Ozs7Ozs7O0tBR2I7O0lBQ0c7R0FBSztZQUVWNEYsY0FBYzNFO0lBQVEsT0FBQSxzQ0FBUkE7R0FBK0M7R0FDN0MsSUFBaEJnSSxnQkFBZ0I7WUFJaEJoSjtJQUFTLGlDQUFrRDtJQUFaO0dBQWlCO0dBQ3JELFNBQVhDLGU7WUFPQUMsZ0JBQVcsNEJBQThDO1lBRXpEQyxTQUFTQztJQUNYLFdBSEVGLFNBRVNFO0lBQ1g7S0FBbUIsZUF0QmpCTCxhQXFCU0s7O01BQ2tDLElBQUEsV0FYM0NKLE9BVVNJLDhCQUFBQTs7Ozs7O0lBQ3FEO0dBQVk7R0FFbEUsSUFBUlksUUFBUSx5QkFIUmI7WUFJQThJLGdCQUFXLG9DQUF3QztHQVF2QztJQUFabEQsWUFBWSx5QkFUWi9FO0lBOEJtRCxNQUFBO3VCQUE3QyxrQ0FBbUMsVUFBWixTQUFrQjtHQUFqRDtJQUFBLE1BQUE7SUFBQSxNQUFBO0lBREVnRixVQUNGLDhCQTlCRWhGOztJQXFDWTs7OztLQUNXLG9CQUFnQmMsR0FBSyx1QkFBTEEsR0FBZTtLQUFuQixPQUFBLHlCQVRuQ2tFOztJQVVLLGNBQW1CbEUsR0FBSyxzQkFBTEEsR0FBa0I7SUFBdEIsT0FBQSx5QkF2Q3BCZDtHQXVDMEM7R0FGNUMsSUFERWlGLGtCQUNGO2dCQVdtQm5FLEdBQUssV0FBTEEsR0FBWTtHQUEzQixVQUFBLHlCQWhERmQ7Z0JBK0NPYyxHQUFLLFdBQUxBLEdBQWE7R0FEdEI7SUFBQSxNQUFBO0lBREVhLFFBQ0Y7WUFJRWlELFVBQVVDLEdBQUVyRTtJQUNSLFlBQUEsNEJBRFFBLEdBQUZxRTt1QkFDeUQ7UUFBekIvRDtJQUFLLFdBQUxBO0dBQTZCO2dCQUczRCtEO0lBQ1IsWUFBQSw4QkFEUUE7O0tBR0ksT0FBQTs7S0FESixPQUFBO0lBR1IsY0FUSkQsVUFJWUMsR0FsQlpJO2tCQXlCUSxPQS9FUk4sY0F3RVlFO1FBTVAvRDtJQUFLLE9BQUEseUJBQUxBO0dBQ2tCO0dBUHpCLElBREVvSCxxQkFDRix5QkF0REVsSTtnQkFvRWdCK0U7a0JBQ2tEcEQsT0FDcEUsV0FGa0JvRCxXQUNrRHBELE9BQ2xEO0lBRGU7S0FBQSxPQUFBLHlCQXRIakNtRDtLQXNIcUIsT0FBQTtLQUFyQixPQUFBLHlCQXRIQUE7S0FzSEEsT0FBQTtLQUFBLE9BQUE7S0FBQSxPQUFBLCtCQXhCRW5EO0lBd0I4RCxPQUFBO0dBQzlDO0dBRmxCLElBREU4RSxZQUNGLHlCQTNERTFCO3VCQStEc0MsU0FBRTtHQUFyQixJQUFuQm9ELG1CQUFtQix5QkEzQm5CeEc7WUE2QkF5RyxLQUFLQSxNQUFLekc7SUFDWjtLQUFnRCxPQUFBLHlCQTVIaERtRDtLQTRIb0MsT0FBQTtLQUFyQixPQUFBLHlCQTVIZkE7S0E0SEEsT0FBQSx3QkFET3NEO0tBQ1AsT0FBQTtLQUFBLE9BQUE7S0FBQSxPQUFBO0lBQUEsT0FBQSwrQkFEWXpHO0dBQzhEO0dBRXhEO0lBQWhCMEcsZ0JBSEFELG1CQTdCQXpHO0lBaUNBMkcscUJBSkFGLHdCQUZBRDtJQU9BSSx5QkFMQUgsNEJBRkFEO0lBUUFLLGlCQU5BSixvQkFGQUQ7SUFTOEIsTUFBQSx5QkFoRjlCRjtJQWdGQVE7TUFQQUw7O1FBTzZCO2dCQVNSdEgsR0FBSyxXQUFMQSxHQUFnQjtHQUFuQyxVQUFBLHlCQXZCRjJGO2dCQXNCcUIzRixHQUFLLFdBQUxBLEdBQVc7R0FBOUIsVUFBQSx5QkFSRjJIO2dCQU8wQjNILEdBQUssV0FBTEEsR0FBVztHQUFuQyxVQUFBLHlCQVJGMEg7Z0JBT2tDMUgsR0FBSyxXQUFMQSxHQUFtQjtHQUFuRCxVQUFBLHlCQVJGeUg7Z0JBTzhCekgsR0FBSyxXQUFMQSxHQUFlO0dBQTNDLFVBQUEseUJBUkZ3SDtnQkFPT3hILEdBQUssV0FBTEEsR0FBZTtHQUR4QjtJQUFBLE1BQUEseUJBUEV1SDtJQU9GLE1BQUE7SUFBQSxNQUFBO0lBQUEsTUFBQTtJQUFBLE1BQUE7SUFERUssbUJBQ0Y7Z0JBU21FM0U7a0JBRTNERTtLQUNSO01BQUl1RDtNQUNBbUI7TUFDQUM7TUFDQUM7TUFDQW5CO01BQ0o7bUJBRVNsSDtNQUFMOzthQUNxQk0saUJBUnJCMEcsa0JBUXFCMUcsSUFFZixPQUhETjs7YUFJUXVCLGdCQVZiNEcsa0JBVWE1RyxNQUVQLE9BTkR2Qjs7YUFPWXdHLGdCQVpqQjRCLHNCQVlpQjVCLE1BRVgsT0FURHhHOzthQVVJc0ksZ0JBZFRELGNBY1NDLE1BRUgsT0FaRHRJOzthQWFJdUksZ0JBaEJUckIsY0FnQlNxQixNQUVILE9BZkR2STtxQkFnQlN3SSxnQkFBSyxXQUFMQSxLQWhCVHhJOztLQWdCcUI7S0FqQjVCLElBREU0RyxlQUNGLHdDQVBNbkQ7S0EyQk4sT0FBQTs7O2VBN0JpRUY7ZUFHL0R5RDtlQUNBbUI7ZUFDQUM7ZUFDQUM7ZUFDQW5CO2VBQ0FOO0lBNkJEO0lBcENvQztLQUFBLE9BQUEseUJBL0l2Q3RDO0tBK0kyQixPQUFBO0tBQXJCLE9BQUEseUJBL0lOQTtLQStJTSxPQUFBO0tBQUEsT0FBQTtLQUFELE9BQUEsK0JBWEg0RDtLQVdGLE9BQUE7SUFDSSxPQUFBO0dBbUNEO0dBckNzQztJQUFBLE1BQUEseUJBOUl6QzVEO0lBOElBLE1BQUEseUJBOUlBQTtJQThJQSxNQUFBLDhCQXhDRW9EO0lBd0NGLE1BQUE7SUFERWUsY0FDRjtJQTVJYTs7T0F1QlhsSztPQU1BNEY7T0FDQXFEO09BSUFoSjtPQUNBQztPQU9BQztPQUVBQztPQUdBYTtPQUNBaUk7T0FRQWxEO09BVEEvRTtPQTZCQWdGO09BT0FDO09BU0F0RDtPQUtBaUQ7T0FHQXNEO09BY0F6QjtPQUtBMEI7T0FFQUM7T0FHQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUM7T0FTQU87WUF5Q0Z0QyxZQUFVQztJQUNaLElBQUlDO2FBQTBCN0UsV0FBUVAsR0FBRVEsR0FBSSxPQUFBLDZCQUFKQSxHQUFGUixHQUFvQjtrQkFJbERtRjtLQUNGLFlBQUEseUNBREVBO3dCQUdLLE9BQUEsV0FyUVhoSSxpQkFrUU1nSTtTQUVIOUY7S0FBSyxXQUFMQTtJQUN5RTtJQUgxRTt1Qjs7S0FGQSxJQUFTQTtLQUFNLE9BQUEsMEJBQU5BO0lBQTJCO0lBRXBDLE9BQUE7YUFKQStGO2FBQTBCN0UsV0FBQUEsV0FDOUIseUJBRlk0RTs7R0FRa0U7WUFLMUVzQyxtQkFBaUI5STtJOztNQUNPO2tCQUFFO01BQUYsT0FBQSx3QkFEUEE7O0tBRUcsZUFBRTtLQUFGLE9BQUEsd0JBRkhBOzs7S0FHUyxJQUFkVSxjQUFjLFdBQUU7S0FBWCxPQUFBLHdCQUhBVixXQUdMVTs7SUFDVztLQUFkaUI7Z0JBQStCO0tBQWpCLFdBQUU7SUFBWCxPQUFBLHdCQUpHM0IsV0FJUjJCOztZQUVUMUIsUUFBTUQsS0FBSXdHO0lBQWUsZUFBRTtJQUFYLE9BQUEsd0JBQVZ4RyxXQUFJd0c7R0FBK0I7WUFJekNKLFFBQU1wRztJO0tBRWU7TUFBZFU7aUJBQXNDO2lCQUFWO01BQWQsV0FBRTtLQUFYLE9BQUEsd0JBRk5WLFdBRUNVOztRQUREaUI7SUFBSyxPQUxYMUIsUUFJTUQsS0FDQTJCOztZQWFOb0gsbUJBQ0MvSTtJQUFKLElBQVdVO1dBQUFBOzttQkFBQUE7bUJBTVUsT0FOakJWO09BSUc7UUFGVzJCOzttQkFFc0M7bUJBQVQsdUJBdkI1QzFCO21CQXVCZ0M7O1FBQTVCLFdBQUU7T0FESixPQUFBLHdCQUhERCxXQUVjMkI7O09BS0EsT0FQZDNCOztPQVFrQixPQVJsQkE7O09BU1UsT0FUVkE7O3FCQUFPVTtxQkFjTSxPQWRiVjtPQWFHO1FBSE80RztRQUdQLE9BQUEsdUJBSE9BOzttQkFFdUM7bUJBQVY7bUJBQVo7O1FBQXhCLFdBQUU7T0FDRixPQUFBLHdCQWJINUc7O2tCQUFPVTtrQkFpQlcsT0FqQmxCVjtPQWdCVTs7UUFEUzBJO1FBQUhwSDs7bUJBQ2dDO21CQUFULHVCQS9CeEM4RTttQkErQjRCOztRQUFqQixXQUFFO09BQVgsT0FBQSx3QkFoQkRwRyxXQWVnQnNCLEdBQUdvSDs7R0FFRTtZQUV0Qk0sY0FBWWhKLEtBQUlVO0lBQ2xCLFNBQUl1RyxJQUFJakg7S0FBUyxPQUFTLHdCQUFsQkE7SUFBeUI7SUFDakMsVUFGa0JVOztLQWtCTCxJQUFTQSxjQUFIWTtLQUFTLDBCQUFUQSxHQUFHWjtJQUFpQztJQUFuRDtLQUFBLE1BQUE7S0FQRjtPQUFBOzs7cUJBWGdCQTs7c0JBQUFBOzt1QkFBQUE7MkJBQUFBLHVCQUFBQTs7V0FBQUE7S0FRWixNQUFBLDRCQVBGdUcsU0FyQkY4QjtlQTRCRTs7Z0JBRkE7O0tBSEYsV0FDRSx1QkFoREZEO0lBdURBLE9BQUEsd0JBWFk5STtHQWtCdUQ7R0FqRXhEOzs7T0FHWDhJO09BTUE3STtPQUlBbUc7T0FjQTJDO09Bb0JBQztZQXFCRjlJLFVBQVVRLEdBQUksT0FBQSwwQ0FBSkEsR0FBMkM7Ozs7T0EzVXJEbEM7T0FFQWtDO09BV0FnSDtPQU1BbEY7T0FJQXpDO09BcUJBd0g7T0FLQUg7T0FDQUU7T0FDQUs7T0FFQWpGO09BVUF6RDtPQUlBQztPQUlBd0Y7O09Bc0xBNkI7O09BOEVBckc7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNsVkExQixXQUFXQztpQkFBb0JDLEtBQU8sd0JBQVBBLE1BQXVCO0lBQXJDLE9BQUEsd0JBQU5EO0dBQWdEO1lBRTNEc0IsR0FBR0M7STs7ZUFJa0Isb0JBSmxCQTs7Ozs7bUJBRU0sb0JBRk5BO21CQUNNLG9CQUROQTs7O21CQUdRLG9CQUhSQTttQkFLUSxvQkFMUkE7O1NBTVNKO0tBQVMsT0FBQSxtQkFObEJJLFVBTVNKOztRQUNISztJQUFTLE9BQUEsbUJBUGZELFVBT01DOzs7SUFFVDFCO0lBQ0EwSztJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQUVBN0UsVUFNQW5EO0lBTlksNEJBTVpBOztnQkFBQUE7O2tCQUFBQTs7b0JBQUFBOztzQkFBQUE7c0JBQUssV0F4Qkw3QyxpQkF3QkE2Qzs7Ozs7O0dBQTZDO1lBTTdDZixNQUFNRixHQUFFQztJQUNWLFVBRFFEO3FCQUFBQTt1QkFBQUE7aUJBQUVDLGdDQUFBQSxHQUVROzs7d0JBRlZEO2tCQUFFQyxnQ0FBQUEsR0FHUTs7MkJBSFZELFlBQUVDLGdDQUFBQTtRQUlZOzs7dUJBSmREO2lCQUFFQyxnQ0FBQUEsR0FNWTs7NEJBTmRELFlBQUVDLGdDQUFBQTtPQUtnQzs7O2VBTGxDRDs7Z0JBQUVDLGlDQUFBQTtPQVU0QjtRQURmWSxNQVRiWjtRQVNDVyxNQVRIWjtRQVU4QixNQUFBLDhCQURmYTtRQUNMLE1BQUEsOEJBRFBEO09BQzJCLE9BQUE7Ozt5Q0FWNUJYLGdDQUFBQTtNQVE0QjtPQURUMEMsTUFQbkIxQztPQU9JMkMsTUFQTjVDO09BUThCLE1BQUEsOEJBRFQyQztPQUNYLE1BQUEsOEJBREpDO01BQ3dCLE9BQUE7OztJQUc1QjtHQUFLO1lBS1h1QixjQUFjM0U7SUFBUSxPQUFBLHNDQUFSQTtHQUErQztZQUU3RDJHLFlBQVU5QixHQUFFckU7SUFDUixZQUFBLDRCQURRQSxHQUFGcUU7dUJBR0M7UUFEUi9EO0lBQUssV0FBTEE7R0FDWTtZQWNmL0I7SUFBZTs7Ozs7Ozs7Ozs7Ozs7O0tBR2I7O0lBQ0c7R0FBSztZQUVWQztJQUFTLGlDQUFrRDtJQUFaO0dBQWlCO0dBQ3JELFNBQVhDLGM7WUFPQUMsZ0JBQVcsNEJBQThDO1lBRXpEQyxTQUFTQztJQUNYLFVBSEVGLFNBRVNFO0lBQ1g7S0FBbUIsY0FqQmpCTCxhQWdCU0s7O01BQ2tDLElBQUEsVUFYM0NKLE9BVVNJLDRCQUFBQTs7Ozs7O0lBQ3FEO0dBQVk7R0FFbEU7SUFBUlksUUFBUSx5QkFIUmI7SUFxQm1ELE1BQUE7dUJBQTdDLGtDQUFtQyxVQUFaLFNBQWtCO0dBQWpEO0lBQUEsTUFBQTtJQUFBLE1BQUE7SUFERTZGLFVBQ0YsOEJBbEJFaEY7O0lBeUJZOzs7O0tBQ1csbUJBQWdCYyxHQUFLLHVCQUFMQSxHQUFlO0tBQW5CLE9BQUEseUJBVG5Da0U7O0lBVUssYUFBbUJsRSxHQUFLLHNCQUFMQSxHQUFrQjtJQUF0QixPQUFBLHlCQTNCcEJkO0dBMkIwQztHQUY1QyxJQURFaUYsa0JBQ0Y7WUFJRUgsY0FBUyxnQ0FBbUMsVUFBWixTQUFpQjtnQkFlS0Q7SUFFbEQsWUFBQSw4QkFGa0RBOztLQUc1QyxPQUFBOztLQUNBLE9BQUE7O0tBR0UsT0FBQTs7S0FGQSxPQUFBOztLQUNVLE9BQUE7SUFHbEIsY0F6Rko4QixZQWdGc0Q5QixHQXBCdERJO2tCQStCUSxPQTdGUk4sY0FrRnNERTtRQVVqRC9EO0lBQUssT0FBQSx5QkFBTEE7R0FDa0I7R0FYSztJQUFBLE1BQUEseUJBZjVCZ0U7SUFlRixNQUFBLHlCQWZFQTtJQWVGLE1BQUEsOEJBNUNFOUU7SUE0Q0YsTUFBQTtJQURFMEosWUFDRjtJQXJGYTs7T0FHWC9FO09BRUFnQztPQWlCQTVIO09BTUFDO09BQ0FDO09BT0FDO09BRUFDO09BR0FhO09BQUFBO09BaUJBZ0Y7T0FPQUM7T0FLQUg7T0FjQTRFO1lBa0JBQyxZQUFVdko7STs7ZUFJVyx3QkFKWEE7Ozs7O21CQUVELHdCQUZDQTttQkFDRCx3QkFEQ0E7OzttQkFHQyx3QkFIREE7bUJBS0Msd0JBTERBOztTQU1FcUI7S0FBSyxPQUFBLHdCQU5QckIsS0FNRXFCOztJQUNXO0tBQWR5RjtlQUErQjtLQUFqQixVQUFFO0lBQVgsT0FBQSx3QkFQSjlHLFVBT0Q4Rzs7R0FWRSxrQkFHWHlDO1lBVUZySixVQUFVUSxHQUFJLE9BQUEsMENBQUpBLEdBQXlDOzs7O09BM0puRGxDO09BRUF1QjtPQVNBeEI7T0FDQTBLO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUE3RTtPQVlBbEU7OztPQTZIQUo7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7SUMxRkFnSDtJQUNBc0M7SUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBMUVBakwsV0FBV0M7aUJBQW9CQyxLQUFPLHdCQUFQQSxNQUF1QjtJQUFyQyxPQUFBLHdCQUFORDtHQUFnRDtZQUUzRDBCLFFBQVFDLEdBQUVDO0lBQ1o7S0FBSVcsTUFBSSw4QkFERVo7S0FFTmEsTUFBSSw4QkFGSVo7SUFHWixPQUFBLDhCQUZJVyxLQUNBQztHQUNjO1lBRWhCWCxNQUFNRixHQUFFQyxHQUFJLGFBTFpGLFFBS01DLEdBQUVDLFdBQW1CO1lBRTNCcUosV0FBV3JJO0lBQ2IsU0FBSXFJLFdBQVc5RyxLQUFJK0c7S0FDakI7TUFDSTdKLE1BRW1CLHVCQUpWOEMsS0FBSStHO2lCQUViN0osaUJBQUFBLE1BQUFBO0tBRUosdUJBSmE4QyxLQUFJK0c7S0FJakI7SUFBMkM7SUFFbkM7S0FBTi9HLE1BQU0sNEJBUEd2QjtpQ0FBQUE7S0FPSDs7U0FDVnVJOzs7O2NBQUFBO1FBQytCLFlBQUEsZ0JBVGxCdkksR0FRYnVJOzs7UUFDYyxRQVJWRixXQU1BOUcsS0FDSmdIOztnQkFBQUEsR0FQSUYsV0FNQTlHLEtBQ0pnSDs7TUFJTyxVQUpQQTtpQkFBQUE7VUFBQUE7OztJQU1BLE9BQUEsNkJBUEloSDtHQU9zQjtHQUk1QjtJQUZJaUg7SUFFSjtZQUVJQztJQUFXO2dEQUM0QjtJQUNsQztHQUFLO1lBRVZ0RixVQUFVbkQ7SUFDWjtxQ0FEWUE7O1VBRVZ1STs7Y0FOQUUsU0FPbUIsZ0JBSFR6SSxHQUVWdUk7UUFDK0IsTUFBQTtpQkFEL0JBO2tCQUFBQTtXQUFBQTs7O0tBR0EsY0FMVXZJO0tBS1Y7Ozs7dUJBQ1ksT0FBQSxXQXZDWjdDLGlCQWlDVTZDOzs7R0FNa0M7WUFFNUMwSSxjQUFjMUk7SUFDVixZQVRKbUQsVUFRY25EOzJCQUVYeUYsZ0JBQUssT0FBTEE7UUFDU25HO0lBQVEsT0FBQSx5QkFBUkE7R0FBZ0M7R0FHdkMsSUFBTFosS0FBSyxvQkF0Q0wySjtZQXdDQU0sWUFBWUMsUUFBT0M7SUFDckIsR0FBRyw4QkFEV0Q7S0FFVCx5QkFGU0E7SUFHa0I7S0FBQSxNQUFBLDhCQUhYQztLQUdQLFFBQUE7O0tBQ04sTUFBQTtRQUVON0k7bUJBRFM7SUFDaUIsVUFBQSw4QkFOZDRJO0lBTWMsT0FBQSw2QkFBMUI1STtHQUFtRDtHQUtwQztJQUFiOEksYUFBYSx5QkEvQmZMO0lBNEJhLGNBR1hLO0lBTUFDLGVBQWEsd0JBekRmVjtJQXNEYSxjQUdYVTs7Ozs7T0FsRUY1TDtPQUVBMkI7T0FLQUc7T0FFQW9KO09BZ0JBRzs7T0FJQUM7T0FJQXRGO09BUUF1RjtPQUFBQTtPQU1BaEs7T0FFQWlLOzs7OztPQXVCQTlDO09BQ0FzQztPQUNBQzs7OztFOzs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ25FQVksYUFBYXJLLEtBQUlVO0lBQW1CLFVBQUEsNEJBQW5CQTtJQUFtQixPQUFBLG9CQUF2QlY7R0FBb0Q7WUFFakVELEdBQUdDO0lBTUw7S0FOZ0NVO0tBQUg0SjtLQUFaSDtLQU1iSSx1QkFOeUJEO1dBQUFBOzs7Ozs7O3lCQUYzQkQ7O2NBUUVFO0lBQ0osT0FBQTs7YUFQS3ZLOzs7YUFBWW1LOzs7YUFBZXpKOztZQVc5QjJFLE9BQVF4RCxHQUFFMkksR0FBRW5KLEdBQUksT0FBRSxXQUFWUSxHQUFVLFdBQVIySSxHQUFFbkosSUFBVztZQUV2Qm9KLGNBQ0NOO0lBQ0csWUFBQSw4QkFESEE7Ozs7Ozs7R0FLaUI7WUFFbEJPO0k7Ozs7Ozs7O09BS1ksSUFBTmhKLE1BQU07T0FDVixPQUFBLGdDQURJQTs7O1lBTUp3SSxNQUFPTSxHQUFFTDtJQUNELElBQU56SSxNQUFNO2lCQUU2QmhCO0tBQ3ZDO01BQ3NCLE1BQUEsOENBTFh5SjtNQUtILFFBQUEsNkJBTENLOztVQU9BRixjQUFBSyxVQUFBTDs7VUFBQUssVUExQlRGLGNBbUJXTjtLQVFFO01BSkFTLE1BR0pEO01BQ0xFLFdBbkJKSCxPQWVhRTtNQU1QbkU7Y0FBMEI3RSxXQUFRUCxHQUFFUSxHQUFJLE9BQUEsNkJBQUpBLEdBQUZSLEdBQW9CO2tCQVNsRFgsR0FBSyxXQW5CSnlKLFlBSUVTLEtBZUhsSyxHQUE2QjtLQUQ3QixVQUFBLFdBQUEsNkJBVk5tSztrQkFTeUJuTSxLQUFPLG9CQUFQQSxLQUFlO0tBQXJDLFVBQUE7S0FBRCxrQixPQXRDTjJHO0tBc0NNO3VCO0tBTko7O01BRkV6QztRQUM0QmhCO1VBQzlCO1lBREk2RTtZQUEwQjdFLFdBQUFBLFdBQzlCLDBCQVJxQ2xCOzs7S0FpQnZDLFNBWElrQyxRQWFnQixPQUFBLDZCQXRCVHVILGVBRzRCeko7U0FrQmxDaUIsTUFaRGlCO0tBWU0sT0FBQSx5QkFBTGpCO0lBQzZDO0lBbkJsRCxVQUFBLGdDQUZJRDtJQUUrQixPQUFBO0dBbUJlO0dBekJyQyxrQkFHWHdJO1lBeUJGWTtJOzs7Ozs7O2VBSVMsTUFBQTs7O1lBT1BDLFFBQU0vSyxLQUFJa0s7SUFDWjtLQUEyQnhKLElBRGZ3SjtLQUNZSSxJQURaSjtLQUNBQyxhQURBRDtLQUVSYyxJQWJKRixRQVl3QlI7O2VBUXBCLHVCQVBBVTtlQU1BO2VBREE7ZUFEQTtLQUZGLFVBQ0U7SUFGSixPQUFBLHdCQUhRaEwsVUFDSW1LLFlBQWV6SjtHQVliO0dBaEJEO0lBQUEsY0FHWHFLOzs7T0F0RUZWO09BRUF0SztPQVdBc0Y7T0FFQW9GO09BUUFDOztPQW9DQUk7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHQ2xFb0I7Ozs7Ozs7Ozs7Ozs7SUFBQSxVQUFBO0lBQXBCL0ssS0FBVTtZQUVWa0wsTUFBTWQsWUFBV2U7YUFDZnJKLEVBQUVzSixLQUFJakI7U0FBY0UsZUFBZEY7S0FDTCxPQUFBLHlDQUZHQyxZQUNnQkM7bUJBQWRGLE9BQUppQjtlQUFBQTs7SUFFTixVQUFBLDRCQUZJdEosTUFEZXFKO0lBR25CLE9BQUE7R0FBc0M7WUFFcENFLGFBQWFqQixZQUFXZTthQUN0QnJKLEVBQUVzSixLQUFJOUo7S0FDUixJQUFrQitJLGVBRFYvSTtLQUVMLE9BQUEseUNBSFU4SSxZQUVLQztlQURkZTttQkFBSTlKLEdBQUo4SjtJQUU2RDtJQUNuRSxVQUFBLDRCQUhJdEosTUFEc0JxSjtJQUkxQixPQUFBO0dBQXNDO1lBRXBDRyxPQUFPbEIsWUFBV2xJOztLQUVsQixJQUFtQm1JO0tBQ2pCLE9BQUEseUNBSEtELFlBRVlDO0lBQ3VCO0lBRjVDLE9BQUEsaUNBRG9Cbkk7R0FJakI7T0FFREY7WUFDQXVKLE9BQU9sTCxHQUFFQyxHQUFJLE9BQUEsdUJBQU5ELEdBQUVDLEdBQVM7WUFDbEJtRCxRQUFRbkMsR0FBSSxPQUFKQSxFQUFLO1lBRWJhLElBQ0NpSSxtQkFBa0JsSTtJQUNULElBRE12QixjQUFINEosY0FDWEosWUFEREMsWUFBWUcsR0FBRzVKO0lBRWxCLFdBREl3SixPQURpQmpJOztZQUluQnNKLFFBQ0NwQixtQkFBa0JsSTtJQUNSO0tBREt2QjtLQUFINEo7S0FDWFksU0F2QkZFLGFBc0JDakIsWUFBa0JsSTtLQUVqQmlJLFlBRkRDLFlBQVlHLEdBQUc1SjtJQUdsQixXQURJd0osT0FEQWdCOztZQUlGNUgsUUFBUWpDLEdBQUksT0FBSkEsRUFBSztZQUNibUssc0JBQXNCbkssR0FBSSxPQUFKQSxFQUFLO1lBRTNCNkYsYUFBYWdFO0lBQ29CLElBQS9CNUU7O0tBRUYsYUFJUztLQUZBO01BRHdDNUY7TUFBaEN5SjtNQUNSO1FBQUE7O1VBRFFBOztNQUNSLGFBSlA3RCxhQUcrQzVGOztJQUdyQztJQUxkLGlDQUZld0s7V0FDWDVFO0dBUUk7WUFFTm1GLGlCQUFpQlA7SUFDc0IsSUFBckM1Qjs7S0FFRixtQkFJUztLQUZBO01BRDRDNUk7TUFBcEN5SjtNQUNSO1FBQUE7O1VBRFFBOztNQUNSLGFBSlBiLGVBR21ENUk7O0lBR3pDO0lBTGQsaUNBRm1Cd0s7V0FDZjVCO0dBUU07WUFFUkcsb0JBQW9CeUI7SUFDK0IsSUFBakRyQzs7S0FFRixtQkFJUztLQUZBO01BRCtDbkk7TUFBdkN5SjtNQUNSO1FBQUE7O1VBRFFBOztNQUNSLGFBSlB0QixxQkFHc0RuSTs7SUFHNUM7SUFMZCxpQ0FGc0J3SztXQUNsQnJDO0dBUVE7WUFLUm5FLGNBQVMsZ0NBQW1DLFVBQVosU0FBaUI7Z0JBR2J5RjtJQUN0QztLQUFpQyxNQUFBLDBDQURLQTtLQUNqQixNQUFBO0tBQXJCLE1BQUEseUJBSkV6RjtLQUlGLE1BQUE7SUFBaUMsT0FBQTtHQUE4QjtHQUQvRDtJQURFd0YsUUFDRjtJQUdFZ0IsU0FBUyx5QkFKVGhCO0lBTFcsY0FHWHhGLFFBRUF3RixPQUlBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFNQVEsb0JBQWExTCxZQUFVLE9BQVZBLElBQWE7WUFDMUIrSyxRQUFNL0ssS0FBSXFCO0lBQUksT0FBQSx1Q0FBUnJCLEtBQUlxQjtHQUE2QjtZQUN2Q3NLLFNBQU8zTCxLQUFJcUI7SUFBSSxPQUFBLFdBQUEsaUJBRmZxSyxNQUNBWCxVQUNPL0ssS0FBSXFCO0dBQWdDO0dBTGhDO0lBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FHWHFLO09BQ0FYO09BQ0FZOzs7T0F2RkY1TDtPQUVBa0w7T0FLQUc7T0FNQUM7T0FNQXRKO09BQ0F1SjtPQUNBOUg7T0FFQXRCO09BS0FxSjtPQU1Bakk7T0FDQWtJO09BRUF0RTtPQVdBdUU7T0FXQWhDOzs7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNyREFtQztJQUFtQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQUlMOzs7TUFGWjs7S0FHRzs7SUFGc0I7R0FFakI7WUFNVkMsVUFBbUM3TSxHQUF2QixjQUF1QkEsUUFYbkM0TSxpQkFXbUM1TSxHQUF1QjtZQVMxRDhNLG1CQUFtQjNIO0lBQVcsT0FBQSw0QkFBWEE7R0FBMEI7WUFDN0M0SCxjQUFjNUg7SUFBa0IsV0FEaEMySCxtQkFDYzNIO0lBQWtCLE9BQUE7R0FBNkI7WUFDN0Q2SCxlQUFlN0g7SUFBb0IsV0FGbkMySCxtQkFFZTNIO0lBQW9CLE9BQUE7R0FBMkI7WUFDOUQ4SCxxQkFBcUI5SDtJQUFXLFdBRGhDNkgsZUFDcUI3SDtJQUFXLE9BQUE7R0FBOEI7WUFDOUQrSCxnQkFBZ0IvSDtJQUFrQixXQURsQzhILHFCQUNnQjlIO0lBQWtCLE9BQUE7R0FBK0I7WUFHakVnSSw2QkFBNkJoSTtJQUMvQjtLQUNNNEgsZ0JBVEpELG1CQU82QjNIO0tBR3pCaUksZUFBSixzQkFESUw7SUFFSixjQUE4Qk0sSUFBSUMsS0FBSzdLO0tBQ3pCLElBQU44SyxNQUFNLDJCQURnQkYsSUFBSUMsS0FBSzdLO0tBRW5DLE9BQUEsNkJBREk4SyxLQUhKUjtJQUk4QjtJQUZsQyxJQUhFUyxpQkFHRiw0QkFESUo7SUFJTixjQUFXSzs7TUFDOEIsWUFJL0IsT0FBQTs7Ozs7V0FGYSxVQUFpQixPQUFBO1dBQXFCLFdBQUE7V0FGN0QsT0FBQSwrQkFEV0E7VUFHZ0U7T0FBcEQsT0FBQSx5QkFUbkJEOztNQVVRLFdBQUE7TUFIWixPQUFBLCtCQURXQztLQUtRO0tBSnNCO0tBQTlCLG9CO0tBQVg7TUFBQSxPQUFBO01BQUEsT0FBQTtLQUF5QyxPQUFBO0lBSXRCO0lBTFosT0FBQTtHQUtZO3VCQVlSLGdDQUF5QyxVQUFaLFNBQWtCO0dBQTFELElBREVDLG9CQUNGO1lBRUVDLHlCQUF5QnhJO0lBQzNCO0tBQ015SSxZQWpDSlosZUErQnlCN0g7S0FHckJpSSxlQUFKLHNCQURJUTtJQUVKLGFBQThCUCxJQUFJQyxLQUFLN0s7S0FDekIsSUFBTjhLLE1BQU0sMkJBRGdCRixJQUFJQyxLQUFLN0s7S0FFbkMsT0FBQSw2QkFESThLLEtBSEpLO0lBSTBCO0lBRjlCLElBSEVDLGtCQUdGLDRCQURJVDtJQUlOLGFBQVdLOztNQUMrQixZQUloQyxPQUFBOzs7OztXQUZjLFVBQWlCLE9BQUE7V0FBcUIsV0FBQTtXQUY5RCxPQUFBLCtCQURXQTtVQUdpRTtPQUFwRCxPQUFBLHlCQVRwQkk7O01BVVEsV0FBQTtNQUhaLE9BQUEsK0JBRFdKO0tBS1E7S0FKdUI7S0FBL0IsbUI7S0FBWDtNQUFBLE1BQUE7TUFBQSxNQUFBO0tBQTBDLE9BQUE7SUFJdkI7SUFMWixPQUFBO0dBS1k7R0FFRDtJQUFoQjdFLGdCQUFnQjtJQUNJLE1BQUE7SUFBYixNQUFBO0lBQVBrRixPQUFPO1lBRVBDLFVBQVVDO2lCQUNrQkM7a0JBSXRCRCxNQUFRLFdBSmNDLFFBSXRCRCxNQUFzQjs7TUFIMEIsc0JBRXpDLE9BQUE7TUFESCxJQUFBLHdCQUFBLE1BQUEsV0FIQUEsTUFDa0JDO01BRWxCLE9BQUE7S0FDYztLQUY4QjtNQUFBO01BQTlCLE1BQUE7TUFBakIsTUFBQTtNQUFSLE1BQUEseUJBSkNIO01BSUQsTUFBQTtNQUFBLE1BQUE7TUFBRCxNQUFBO0tBR0ksT0FBQTtJQUEwQjtJQUpKLE9BQUE7R0FJSTtZQUU1QkksY0FBYy9JLFVBQVM2STtJQUN6QjtLQUlHLE1BWkRELFVBT3VCQztLQUt0QjtLQUpJLE1BeERMaEIsZUF1RGM3SDtLQUNoQixNQUFBO0tBQUEsTUFBQSw4QkE1QkV1STtLQTRCRixNQUFBLDhCQVZFSTtLQVVGLE1BQUE7SUFJRyxPQUFBO0dBQWM7WUFTZkssVUFBVWhKO0lBQVcsT0FoRXJCZ0ksNkJBZ0VVaEk7R0FBZ0Q7WUFFMURpSixTQUFTQztJQUNYLEdBRFdBO1NBRUpsSixXQUZJa0o7S0FFUSxPQTFDakJWLHlCQTBDS3hJOztJQUNHLG9CQUFxQixTQUFJO0lBQWQsT0FBQTtHQUFlO1lBRWxDbUosZUFBZ0JELFFBQU9sSixVQUFTNkk7aUJBTzFCM0w7a0JBQ21Da007TUFDM0M7T0FLRyxNQUFBLDZCQVBLbE0sR0FDbUNrTTtPQUt2QyxNQUFBO09BRFUsTUFqQlpILFNBS2dCQztPQVlkLE1BQUE7T0FGQSxNQXBGRm5CLGdCQTBFdUIvSDtPQVN4QixNQUFBO09BQUEsTUFBQSw4QkF6REN1STtPQXlERCxNQUFBO09BQUQsTUFBQTtNQUtHLE9BQUE7S0FBZTtLQU5iO01BQUEsTUE3QkhRLGNBcUJ1Qi9JLFVBQVM2STtNQVFsQyxNQUFBO0tBQXVDLE9BQUE7SUFNckI7SUFSZjtLQUFBLE1BbENERCxVQTRCZ0NDO0tBTS9CO0tBSkEsTUEvRURqQixjQTZFdUI1SDtLQUNmLE1BUlJnSixVQU91QmhKO0tBQ3pCLE1BQUE7S0FBQSxNQUFBO0tBQUEsTUFBQSw4QkFqREV1STtLQWlERixNQUFBLDhCQS9CRUk7S0ErQkYsTUFBQTtLQUFBLE1BQUE7SUFNSSxPQUFBO0dBT2M7Ozs7T0FoSGhCbEI7T0FXQUM7T0FTQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FHQUM7T0F1QkFPO09BR0FDO09BY0EvRTtPQUNBa0Y7T0FFQUM7T0FPQUc7T0FjQUM7T0FFQUM7T0FLQUU7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7R0MxR007Ozs7Ozs7O0lBNFFXRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTVRakJDLE1BQU07SUFFUSxNQUFBLHFCQUZkQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBZ1RJQyxJQUFJN0w7STsyQkFDT21MLGlCQUFSOUI7S0FBa0IsZUFBbEJBLFFBQXdDLFdBRHZDckosR0FDT21MOzs0QkFDS1cscUJBQVJoQztJQUNzQyxvQixPQUg5QytCLElBQUk3TDtJQUc4QixXQUFBO0lBQXBDLGVBRFU4SixVQUNpQixrQ0FEVGdDOztZQUdoQkM7SUFBVSx1QkFDVEMsZ0JBQU8sV0FBUEE7SUFFNkI7S0FEVmI7S0FDVSxPQUFBLDZCQUg5Qlk7S0FHYyxPQUFBLGtDQURNWjtJQUNOLE9BQUE7R0FBeUM7WUFFM0QxSyxLQUFNVCxHQUFFSCxLQUFLNEssS0FBSzdLO0lBQ3BCLFdBRG9CQTtlQUFMNks7U0FDZjFDLElBRGUwQzs7TUFFYixXQUZNekssR0FFSixnQkFGTUgsS0FDVmtJO01BQ0UsV0FERkE7a0JBQUFBO1VBQUFBOzs7O0dBRUk7WUFzR0Y2QixpQkFBaUJ3QjtJQUNuQjtLQUFJYTtLQUNVLHlCQUFkOzs7OztTQUdJLG1CQUlTO2FBSDZCcE47U0FMdENvTixjQUtzQ3BOO1NBRWhDLE1BQUE7UUFDTTtLQUxkLGtDQUppQnVNO2dCQUNmYTs7Ozs7K0JBQUFBOzs7R0FXbUI7WUFFckJDLE1BQU10UCxLQUFNLE9BQUEsaUNBQU5BLEtBQWdDO1lBc0V0Q2lNLE9BQVFzRCxVQUFTOUc7SUFFakIsSUFwQldnRSxtREFrQk1oRTthQWhCWDhGLEtBQUtpQixZQUFPL0M7S0FDbEI7TUFBc0IsT0FBQSxzQ0FESkE7TUFDWixVQUFBOztVQUNRdEU7TUFDVixPQUFBLFdBekRKbUgsWUF3RGNuSDs7O01BVkc7T0FBZk0sZUFBZSxzQ0FRQ2dFO09BUFksT0FBQSw0Q0FENUJoRTtPQUNFLFVBQUE7O1dBQ1FnSCwwQ0FBQUE7OztvQkFtQkYsT0FuRVZIO01BZ0VJO09BREdJO09BQ0gsZ0JBRVFDLE9BQVMsZUFaSGxELFFBWU5rRCxRQUEyQzs4QkFEdEMsSUFBZUMscUJBQWEsT0FBYkEsU0FBc0I7T0FBOUMsT0FBQTtPQUQwQyxPQUFBLDZCQUQzQ0Y7T0FDcUMsc0IsT0FWdENuQjtPQVVGO1NBQUEsdUNBVk9pQixZQVNKRTtPQUNILE9BQUE7TUFFSSxPQUFBOztLQVBjO01BQUEsVUFBQSxXQVdkSCxVQWhCVTlDO01BS0RvRDtNQXpEVkM7MEJBMER3QyxlQU43QnJELFFBS0RvRCxLQUN3RDtRQU45REw7TUE3QlM7T0FEZjlKLFdBOEJNOEo7T0EzTm1DTyxjQThMMUIsc0NBRGZySztPQUVIOztVQWFBLFdBckNLb0s7VUFxQ0wsT0FBQTtTQUNTO09BZEYsUUF4Q1Q5QyxpQkFvRWtCUDs7O1FBMUJaLG9CQUFldUIsR0FBSyxPQUFBLFdBQUxBLGNBQXdDO1FBQXZEO1FBaE1OO1NBdkZVZ0Msd0JBdUZLcE4sR0FBSSxPQUFRLFdBc0twQmtOLGFBdEtRbE4sSUFBb0I7U0F2RmJxTjtvQkF3RlByTjtZQUFJLE9BQVE7cUJBcUtwQmtOLGFBckswQix1QkFBbEJsTixHQUZFbU07V0FFa0M7U0F2Ri9DbUIsUUFBTTtTQUdKQyxpQkFETixzQkFtRjhDSjtTQWpGNUM7b0JBQThCbkMsSUFBSUMsS0FBSzdLO1lBQ3pCLElBQU44SyxNQUFNLDJCQURnQkYsSUFBSUMsS0FBSzdLO1lBRW5DLE9BQUEsNkJBREk4SyxLQWdGb0NpQztXQS9FWjtTQUo5Qks7V0FFRiw0QkFESUQ7U0FLRkU7O3FCQUNNQzthQUNBLFlBQUEsb0JBVk5KOzs7ZUFXWSxNQUFBO2NBV0Y7Ozs7a0JBTkZLO2NBakJGUCxhQWlCRU87NERBUEZEOzs7a0JBVUVFO2NBcEJVUCxXQW9CVk87NERBVkZGOzthQWN3QixJQUFqQnBPLGdCQUFpQixPQUFBLHlCQUFqQkE7YUFBaUIsT0FBQTtZQUFRO3FCQUNwQ3VPO2FBQ0ksWUFBQSxvQkF6Qk5QOzs7eUJBNEJJO21DQTVCSkE7K0RBU01JOzs7O2tCQXFCRUM7Y0EvQkZQLGFBK0JFTzs0REFOTkU7OztrQkFTTUQ7Y0FsQ1VQLFdBa0NWTzs0REFUTkM7O2FBYTRCLElBQWpCdk8sZ0JBQWlCLE9BQUEseUJBQWpCQTthQUFpQixPQUFBO1lBQVE7WUFFeEMsT0FmSXVPO1dBZUM7O29CQUVJekM7MEJBb0JIMEM7c0JBRUFEO2NBQ0EsWUFBQSxvQkFoRUpQOztzQ0FpRVE7ZUFRTztnQkEvQlJTO2tCQStCUSx3Q0FaWEQ7ZUFhRjs7aUJBYkVBOztpQkFuQkdDOzt1Q0FtQkhEO2VBYzhCO2dCQUFBOzttQjtvQkE1QnBCO3FCQUFSQTt1QkFBUTs7eUJBTFBDOzs4Q0FBQUE7b0JBTUw7K0JBaERGVCxPQStDTVEsK0JBQUFBO29CQU5WLE9BQUEsdUNBakNJTDs7bUJBK0NFO3FCQWJLTTswQ0FBQUE7cUJBYW9DLGdCQThCRFo7bUJBN0J4Qzs4QkF4REZHLE9BMENPUyxpQ0FBQUE7bUJBZUw7O29CQUFBLE9BQUE7b0JBQUEsT0FBQTttQkFmTixPQUFBLCtCQURXM0M7O2dCQWtDTDtrQkFBQSx5QkF6RUZvQztlQXlFa0MsT0FBQTs7OzttQkFDNUJHO2VBN0VBUCxhQTZFQU87NkRBYkZFOzs7bUJBZ0JFRDtlQWhGWVAsV0FnRlpPOzZEQWhCRkM7O2NBbUJ3QixJQUFqQnZPLGdCQUFpQixPQUFBLHlCQUFqQkE7Y0FBaUIsT0FBQTthQUFRO2FBQ3hDLE9BcEJRdU87WUFvQkg7WUF0QkQsSUFBQSx1QkFEc0IsT0FBQSxnQkF5Qm9CVjtZQXpCNUIsb0I7WUFBbEIsV0FBQTtZQUNJLE9BQUE7V0FzQkM7Z0JBMUNFOzs7UUFtUEQsb0JBQWUvQixHQUFLLE9BQUEsV0FBTEEsY0FBNkI7UUFBNUM7UUE1Vko7U0FIUTRDLHdCQThDS2hPLEdBQUksT0FBUSxXQWlScEJrTixhQWpSUWxOLElBQW9CO1NBNUM3QmlPLHVDQXNKd0NkO1NBcko1QztvQkFBOEJuQyxJQUFJQyxLQUFLN0s7WUFDekIsSUFBTjhLLE1BQU0sMkJBRGdCRixJQUFJQyxLQUFLN0s7WUFFbkMsT0FBQSw2QkFESThLLEtBb0pvQ2lDO1dBbkpaO1NBSjlCZTtXQUVGLDRCQURJRDs7b0JBS0s3QzswQkFvQlRoTDthQUZZLFNBRVpBOzs7O2tCQURxQixlQW5CWmdMLElBbUI2QjtpQkFBdUI7Y0FBeEMsT0FBQTs7MkJBRXFCMEM7Y0FDeEM7ZUFBa0I7Z0JBL0JaclAsTUErQlksZ0JBMkh3QjBPO2dCQWpLaENnQixNQU9VLDJCQThCb0JMO2dCQUV0Q3hGO2VBdENOO21CQURjNkYsT0F1Q1I3RjtpQkFyQ0QsTUFBQTttQkFDRyxzQkFrQ29Dd0YsT0FFdEN4RixTQWhDSTdKO29CQVBRMlAsUUF1Q1o5RixhQUFBQSxNQXZDWThGOzs7Ozs7O2VBU1JKLGFBMENTLDJCQWR5QkY7ZUFlcEM7O2dCQUFBLE9BQUEseUJBaEJOMU47Z0JBZ0JNLE9BQUE7ZUFsQlIsT0FBQSwrQkFsQldnTDs7Y0EwQk8sSUF6QlAyQyxVQXlCTyxrQkFIWnpGO2NBSUUsNEJBTm9Dd0YsVUFwQmpDQyxZQXNCTHpGO2NBUWlEO2U7Z0JBeEJyQztpQkFBUndGO21CQUFROztxQkFOUEM7OzBDQUFBQTtnQkFSREMsYUFjQUY7Z0JBQ0o7O2VBZklFLGFBc0JPLDZCQWRORDtlQWVMOztnQkFBQSxPQUFBO2dCQUFBLE9BQUE7ZUFmTixPQUFBLCtCQURXM0M7O2NBK0I0QztlQUFBO2VBQS9DLE9BQUEseUJBUkY5QztlQVFFLE9BQUEsK0JBckNKNEY7ZUFxQ0ksT0FBQTtjQUErQyxPQUFBO2FBS3JCO2FBZjlCLFdBQUEsNEJBREY5TjthQUNzQyxPQUFBO1lBZUw7WUFsQnJCLE9BQUE7V0FrQnFCO2dCQXBDNUI7OztRQXFWRCxvQkFBZWdMLEdBQUssT0FBQSxXQUFMQSxjQUE4QjtRQUE3QztRQWhjSTtTQURBaUQsc0JBNkRLck8sR0FBSSxPQUFRLFdBdVdwQmtOLGFBdldRbE4sSUFBb0I7U0E1RC9Cc08sTUFBTTtTQUdKdkQsZUFETixzQkEwUDhDb0M7U0F4UDVDO29CQUE4Qm5DLElBQUlDLEtBQUs3SztZQUN6QixJQUFOOEssTUFBTSwyQkFEZ0JGLElBQUlDLEtBQUs3SztZQUVuQyxPQUFBLDZCQURJOEssS0F1UG9DaUM7V0F0UFo7U0FKOUJvQixvQkFFRiw0QkFESXhEOztvQkE2QktLOzBCQVlIMEM7c0JBQ0FEO2NBQ0EsWUFBQSw4QkE5Q0pTOztxQ0ErQ1E7O2dCQUVPO2lCQWhCUlA7bUJBZ0JRLHdDQUxYRDtnQkFNRjs7a0JBTkVBOztrQkFYR0M7O3dDQVdIRDtnQkFPb0I7OztvQjtxQkFoQlY7c0JBQVJBO3dCQUFROzswQkFGUEM7OytDQUFBQTtxQkFHTDs7dUJBcENGTzt1QkFtQ01SOzs0Q0FBQUE7cUJBTFI7c0JBckJRSjs7eUJBQ0EsWUFBQSw4QkFWTlk7O2dEQWlCVTs7MkJBTkUsTUFBQTs7MEJBS2tCLFdBQUE7MEJBQUEsT0FBQTs7OzBCQURBLElBQWpCaFAsZ0JBQWlCLE9BQUEseUJBQWpCQTswQkFBaUIsT0FBQTs7NkJBSHJCcU87eUJBYkhVLFdBYUdWO3VFQUhIRDt3QkFRVTtzQkFDZEc7O3lCQUNJLFlBQUEsOEJBbkJOUzs7Z0RBNEJVOzsyQkFQTiw4QkFyQkpBO3lFQVNNWjs7MEJBa0J3QixXQUFBOzBCQUFBLE9BQUE7OzswQkFEQSxJQUFqQnBPLGdCQUFpQixPQUFBLHlCQUFqQkE7MEJBQWlCLE9BQUE7OzZCQUhyQnFPO3lCQXhCSFUsV0F3QkdWO3VFQUxQRTt3QkFVYztzQkFFbEIsT0FaSUE7cUJBbUJVLE9BQUE7O29CQUVWO3NCQU5LRTsyQ0FBQUE7c0JBTW9DLGdCQXFORFo7b0JBcE54Qzs7c0JBeENGbUI7c0JBaUNPUDs7MkNBQUFBO29CQVFMOztxQkFBQSxPQUFBO3FCQUFBLE9BQUE7b0JBUk4sT0FBQSwrQkFEVzNDOztnQkFtQmlCLE9BQUEseUJBakR4Qm1EOztlQXNENEIsV0FBQTtlQUFBLE9BQUE7OztlQURBLElBQWpCalAsZ0JBQWlCLE9BQUEseUJBQWpCQTtlQUFpQixPQUFBOztrQkFIckJxTztjQXJERFUsV0FxRENWOzREQVBIRTthQVc0QzthQUNwRCxPQVpRQTtZQVlIO1lBYkQsSUFBQSx1QkFEc0IsT0FBQSxnQkFpTm9CVjtZQWpONUIsb0I7WUFBbEIsV0FBQTtZQUNJLE9BQUE7V0FhQztnQkF6QkU7OztXQXFhUzlOLHFCQUNWLFdBckNOcU4sWUFvQ2dCck47aUJBRVY7OztNQS9CSjtPQXZLaUJtUCx3QkF1S0ZiLE1BQU8sT0FBUSxXQUx6QlQsYUFLVVMsT0FBMEI7T0FFekM7O1VBYUEsV0FwQktUO1VBb0JMLE9BQUE7U0FDUztPQWRGLFVBdkJUOUMsaUJBb0VrQlA7OztRQTNDWixvQkFBZXVCLEdBQUssT0FBQSxXQUFMQSxjQUFnRDtRQUEvRDtRQTFLSTtTQUFOcUQsUUFBTTs7b0JBRUNyRDtZQUNMLFlBQUEsb0JBSEZxRDs7b0NBSU07Ozs7aUJBRVE7Ozs4QkFLUUM7c0JBQ2xCO29DQUFtQjFELElBQUlDLEtBQUs3Szt1QkFDWixJQUFSME4sUUFBUSxrQkFEWTFOO3VCQUV4Qiw0QkFGZTRLLElBQUlDLEtBQ2Y2QyxVQURvQjFOO3VCQUV4QixPQUFBLG9CQWRScU8sT0FhWVgsVUFEb0IxTjtzQkFHQTtzQkFINUI7dUJBQUEsT0FBQSw0QkFEa0JzTzt1QkFDbEIsT0FBQTtzQkFQSSxPQUFBLCtCQUhEdEQ7cUJBZUM7a0JBTlUsT0FBQTs7aUJBSGQsb0JBUkpxRDtpQkFRSTtnQkFTSTthQVhNLE9BQUE7Ozs7aUJBWVZkO2FBbkJXYSxhQW1CWGI7YUFDSixPQUFBLHVDQWpCT3ZDOzs7aUJBbUtNd0M7YUFBZSxXQUp6QlYsYUFJK0IsdUJBQXJCVTthQS9JYixPQUFBLHVDQXBCT3hDOztZQXNCbUIsSUFBakI5TCxnQkFBaUIsT0FBQSx5QkFBakJBO1lBQWlCLE9BQUE7V0FBUTtnQkF0Qi9COzs7UUE4S0Qsb0JBQWU4TCxHQUFLLE9BQUEsV0FBTEEsY0FBcUM7UUFBcEQ7OztvQkE1UktBOzthQUNHLFlBQ0o7MkJBRVlzRDtjQUNsQjs0QkFBbUIxRCxJQUFJQyxLQUFLN0s7ZUFDWixJQUFSME4sUUFBUSxrQkFEWTFOO2VBRXhCLDRCQUZlNEssSUFBSUMsS0FDZjZDLFVBRG9CMU47ZUFHYixPQW1HQW9PLGFBbkdBLDZCQUZQVjtjQUVxQztjQUg3QztlQUFBLE9BQUEsNEJBRGtCWTtlQUNsQixPQUFBO2NBSkosT0FBQSwrQkFEV3REO2FBVUg7YUFOVSxPQUFBO1lBTVY7WUFUTSxPQUFBO1dBU047Z0JBVkQ7OztRQXlSRCxvQkFBZUEsR0FBSyxPQUFBLFdBQUxBLGNBQXNDO1FBQXJEO1FBL1dJO1NBQU51RCxRQUFNOztvQkFFQ3ZEO1lBQ0wsWUFBQSw4QkFIRnVEOzttQ0FJTTs7Ozs7a0JBRVE7OzsrQkFLUUQ7O3dCQUtKLE9BWFYsdUNBSER0RDt1QkFjc0I7cUNBSk5KLElBQUlDLEtBQUs3Szt3QkFDWixJQUFSME4sUUFBUSxrQkFEWTFOO3dCQUV4Qiw0QkFGZTRLLElBQUlDLEtBQ2Y2QyxVQURvQjFOO3dCQUV4QixPQUFBLDhCQWRSdU8sT0FhWWIsVUFEb0IxTjt1QkFHVTt1QkFIdEMsV0FBQSw0QkFEa0JzTzt1QkFLZCxPQUFBO3NCQUFxQjttQkFMWCxPQUFBOztrQkFIZCw4QkFSSkM7a0JBU2MsV0FBQTtrQkFBQSxPQUFBO2lCQU9lO2NBVmYsT0FBQTs7YUFlWSxXQUFBO2FBQUEsT0FBQTs7O2FBREEsSUFBakJyUCxnQkFBaUIsT0FBQSx5QkFBakJBO2FBQWlCLE9BQUE7O2dCQUhyQnFPO1lBZ0xVYSxhQWhMVmI7WUFDTCxPQUFBLHVDQWhCT3ZDO1dBbUJ1QztnQkFuQjNDOzs7V0FrWFM5Syx5QkFDVixXQXBCTm9NLFlBbUJnQnBNO2lCQUVWOztLQXVDK0IsT0FBQTtJQU9tQjtJQUMxRCxPQWRRcUwsUUFGSzlCO0dBb0JnRTtZQUUzRStFLEtBQUt4QyxLQUFJeUMsU0FBUUMsS0FBSUMsU0FBUTNPO0lBQy9CLE9BQUEsNEJBRE9nTSxLQUFJeUMsU0FBUUMsS0FBSUMsU0FBUTNPO0dBQzRCO1lBRXpENE8sTUFLRXJDLFVBQVM5RztJQUNiO0tBQUkyRCxXQWJGSCxPQVlFc0QsVUFBUzlHO0tBRVRvSixZQUFZLDRCQURaekY7S0FFQTBGLEtBQUs7SUFDVCxnQkFBSXZCO0tBQ0YsWUFIRXNCOzs7OztTQU1xQkU7U0FBWEM7UUFDUiwwQkFORkYsSUFLVUU7aUJBQUFBLFdBRWMsdUJBUHhCRjtRQU93QixtQkFDUDlELEdBQUssT0FBQSxXQUFMQSxjQUFvRDtRQUFuRTtrQkFQRnVDO1NBcUJZLG1CQUNTdkMsR0FBSyxPQUFBLFdBQUxBLGNBQXNCO1NBQXJDO1NBQ00sY0FBQSwwQkF4Qlo4RDs7Y0E0QlVHOztXQU1BLG9CQUFlakUsR0FBSyxPQUFBLFdBQUxBLGNBQWlDO1dBQWhEO1dBbkNWNkQ7WUFxQ1k7Y0EvQlNFLFlBdUJYRSxVQVE2QiwyQkFSN0JBOzs7Ozt1QkFDZWpFO2VBQ1gsT0FBMkI7d0JBRGhCQSxjQUNnQiwyQkFGL0JpRTtjQUU0RDtXQUQ1RDtXQTlCVko7WUFpQ1k7Y0EzQlNFLFlBdUJYRSxVQUk2QiwyQkFKN0JBOzs7O1VBRkEsb0JBQWVqRSxHQUFLLE9BQUEsV0FBTEEsY0FBMEI7VUFBekM7VUEzQlY2RCxXQTRCbUIsV0F0QkVFOzs7O2FBTVRoSyxNQVZad0k7eUNBVVl4STs7O3NCQUNTaUc7Y0FDWCxPQUNFLFdBRlNBLGNBRVQsc0JBZFo4RDthQWNnQztVQUYxQjs7O3NCQUdlOUQ7Y0FDWCxPQUE4QyxXQURuQ0EsY0FDbUMsc0JBaEJ4RDhEO2FBZ0IwRTtVQURwRTtVQUVBOztZQWpCTkE7WUFYRk47OztzQ0FzQmN6SjtZQUFBQTtVQVE0QixjQUFBLDBCQW5CeEMrSjs7V0FtQnlCLE1BQUE7Y0FBQ0k7VUFwQjFCTDtXQXNCUTthQWhCYUUsWUFjS0csWUFFUywyQkFGVEE7OztRQW1CeEI7O1lBbkMyQkMsaUJBQVMsc0JBQVRBO29CQUNqQmxTLGdCQUFRLHNCQUFSQTtNQWtDRDtHQUFBO1lBRWJtUyxjQUFjQyxRQUFPNUo7SUFDdkIsSUFDTXhHLGFBSUZxUSxNQUFNO2FBQ04vQyxTQUFTOUM7S0FMUHhLO0tBT00sSUFETmlKLE1BTkFqSixNQU9BZ0IsTUFBTTtLQUNWLDhCQUpFcVAsS0FFRXBILEtBQ0FqSTtLQUVKOztjQUFDLFlBQTBEO2tCQUEzQzhFO2NBQU8sT0FBQSw4QkFGbkI5RSxLQUVZOEU7YUFBOEM7YUFIMURtRDtJQUdnRTtJQUMxRCxJQUFScUgsVUE1REZYLE1BdURFckMsVUFQbUI5RztJQWNyQjtLQUFpQixZQUFBLFdBZEg0Sjs7VUFjc0N0SyxnQkFBaER3SSx1QkFBZ0R4STs7VUFBaER3STtLQUNFLGNBSEpnQyxRQUVFaEM7O2tDQUlZO1VBRFJ2QztNQUFLLGVBQUxBLEdBWE5zRTs7O0dBYUM7WUFFSEUsa0JBQWtCSCxRQUFPNUo7SUFDckIsWUF0QkoySixjQXFCa0JDLFFBQU81Sjs7S0FJckI7O01BRkc2SjtNQUFIdEU7OztpQkFFa0JuTCxHQUFFakIsR0FBRUQ7U0FBSyxlQUFUa0IsR0FBYSw2QkFBWGpCLEtBQUVEO1FBQWdDO01BRHBENkssUUFDRixvQ0FGRzhGO0tBR0wsZUFIRXRFLEdBQ0V4Qjs7UUFHQUQ7SUFBSyxXQUFMQTtHQUFZO1lBRWxCa0csa0JBQWtCSixRQUFPNUo7SUFDckIsWUE5QkoySixjQTZCa0JDLFFBQU81Sjs7S0FHZDs7TUFESjZKO01BQUh0RTtNQUNFMEU7UUE5UkZ6RDttQkE4UmdCcE07V0FBcUIsVUFBQSw4QkFEbEN5UCxLQUNhelA7V0FBcUIsT0FBQTtVQUFvQjtVQUR6RG1MO0tBRUYsV0FESTBFOztRQUVBbkc7SUFBSyxXQUFMQTtHQUFZO1lBRWxCb0csaUJBQWlCNUs7SUFDSixJQUFYNks7SUFDSjtLQUNFLE9BRkVBLG1CQUFBQSxxQkFEZTdLLE1BT047R0FBQTtZQUVYOEssa0JBQWtCOUssS0FBSVU7SUFDeEIsT0F6QkUrSixrQkFlQUcsaUJBU2tCNUssTUFBSVU7R0FDNkI7WUFFbkRxSyxrQkFBa0IvSyxLQUFJVTtJQUN4QixPQXBCRWdLLGtCQU9BRSxpQkFZa0I1SyxNQUFJVTtHQUM2QjtZQUtuRHNLLEtBQU9uSyxLQUF3QndCLGFBQWFpRixVQUFTZ0Q7SUFDdkQsR0FEU3pKO1NBQVNHLE1BQVRILFFBQUE2RCxTQUFTMUQ7O1NBQVQwRDtJQUNULEdBRGlDckM7O01BR3hCbkksSUFId0JtSTtNQUM3QjhDO1FBR0U7OztpQkFER2pMO1VBSEF3Szs7U0FDTFMsV0FES1Q7SUFRVCxHQVI4QzRDOztNQVVyQ25NLE1BVnFDbU07TUFRMUMyRDtRQUdFOzs7aUJBREc5UDtVQVRMZ0s7O1NBT0E4RixXQVBBOUY7SUFjZTtLQUFmekUsZUFBZSxzQ0FQZnVLO0tBUUFDLGFBak5GakcsaUJBeU1FZ0c7V0FTRyw0Q0FGSHZLO0tBR0M7Y0FGRHdLO0tBUThCLE1BQUE7cUJBUjlCQTtLQWxUUTtNQUFSdkMsUUFBUTtNQUNSckUsVUFBVTtNQUNWNkcsUUFBUTtNQUhBQztNQUtKQzs7U0FDTix1QkFIRUY7YUFJRWxRLGFBQXFCLHFCQUx2QnFKO1NBTUYsZUFBTSw2QkFQSnFFLFdBTUUxTjtRQUN1QztNQU16Q3FROztTQUNGO1VBQUEsSUFBTSxJQXFCSmhTLE1BckJJLHNCQVpKNlI7Ozs7V0FzQ0ksWUFBQSxXQTBQK0NiOzs7O2FBelBuQ2lCO2FBQUx6RjthQUFMNUs7WUFqRFJZO3VCQWtEaUJ4QyxLQUFPLE9BQUEsc0JBeEN0QjZSLE9Bd0NlN1IsS0FBd0M7Y0FEakQ0QjtjQUFLNEs7Y0FBS3lGOzs7V0FJZCxzQkEzQ0ZKOzs7VUFZSSxlQXFCSjdSOztXQUM0Qix5QkFBTywyQkFEbkNBOzJCQUNRLG9CQW5DUmdMLGVBcUNnQixPQWxDWitHOzs7OztjQVlGLHFCQWZGL0csU0FEQXFFLFVBRFF5Qzs4QkFrQkEsb0JBaEJSOUc7ZUFrQmdCLE9BZlorRzs7O2NBb0JGLHVCQXRCRkY7OEJBdUJRLG9CQXhCUjdHO2VBMEJnQixPQXZCWitHOzs7Y0F5QkYsdUJBM0JGRjs4QkE0QndCLG9CQTdCeEI3RzttQkFVTXJKLGFBQXFCLHFCQVYzQnFKO2VBV0UsZUFBTSw2QkFaUnFFLFdBV00xTjs7Y0FGQztjQUFBLGtCQUFBLE9BQUEsdUJBSVBxUTs7Y0FKTyxPQUlQQTs7Y0FtQlUsYUFBQSxvQkEvQlZoSDtlQStCRSxNQUFBO2NBQ0EsdUJBL0JGNkc7Y0ErQkU7OztRQWFtQjtNQWpDckJ6QyxxQix1QkFBQTRDO0tBbUNKLHFCQS9DSWhILFNBREFxRSxVQURReUM7U0FzVFJJLFdBeFNBOUM7O3lCQXFTQXdDO1NBR0FNLFdBbkJtRGxCOztLQTVPM0M7TUFBUjFCLFVBQVE7TUFDUjZDLFlBQVU7TUFDVkMsVUFBUTtNQUhBQztNQUtKQzs7U0FDTix1QkFIRUY7YUFJRXpRLGFBQXFCLCtCQUx2QndRO1NBTUYsZUFBTSw2QkFQSjdDLGFBTUUzTjtRQUN1QztNQU16QzRROztTQUNGO1VBQUEsSUFBTSxJQWFKdlMsTUFiSSxzQkFaSm9TOzs7O1dBOEJJLFlBQUEsV0E0TStDcEI7Ozs7YUEzTW5DaUI7YUFBTHpGO2FBQUw1SztZQS9GUlk7dUJBZ0dpQnhDLEtBQU8sT0FBQSxzQkFoQ3RCb1MsU0FnQ2VwUyxLQUF3QztjQURqRDRCO2NBQUs0SztjQUFLeUY7OztXQUlkLHNCQW5DRkc7OztVQVlJLGVBYUpwUzs7V0FDc0MseUJBQU8sMkJBRDdDQTsyQkFDUSw4QkEzQlJtUztZQTZCZ0IsT0ExQlpHOzs7OztjQVlGO29DQWZGSCxXQURBN0MsWUFEUStDOzs7bUJBa0JBLDhCQWhCUkY7ZUFrQmdCLE9BZlpHOzs7Y0FpQkYsdUJBbkJGRjs7NkJBb0J3Qiw4QkFyQnhCRDttQkFVTXhRLGFBQXFCLCtCQVYzQndRO2VBV0UsZUFBTSw2QkFaUjdDLGFBV00zTjs7Y0FGQztjQUFBLGtCQUFBLE9BQUEsdUJBSVA0UTs7Y0FKTyxPQUlQQTs7Y0FXVTswQkFBQSw4QkF2QlZKO2VBdUJFLE1BQUE7Y0FDQSx1QkF2QkZDO2NBdUJFOzs7UUFhbUI7TUF6QnJCSSx1Qix1QkFBQUQ7S0EyQkosK0JBdkNJSixXQURBN0MsWUFEUStDO1NBZ1FSSCxXQWxQQU07O0lBd1BKLFdBakJJYixVQVdBTztHQU1xQjtHQUlUOztJQUFBLE1BQUE7SUFGZE87TUFFRjtZQUVFL1MsVUFBV2dULEtBQUtoSSxHQUFJbkQsS0FBd0JsRCxVQUFTaUs7SUFDdkQsR0FEc0IvRztTQUFTRyxNQUFUSCxRQUFBNkQsU0FBUzFEOztTQUFUMEQ7SUFDdEIsR0FEOEMvRztTQUVuQitKLGFBRm1CL0osYUFDMUM4SixhQUN1QkM7O1NBRHZCRCxhQUNzRCxXQUY3Q3VFLEtBQUtoSTtJQUdIO0tBQVgyRCxhQUFXLCtDQUZYRjtLQUdBL0c7T0FDQzttRUFMaUJnRTtVQU1mLHNDQU5lQTtVQUpwQnFIO0tBWUVFO09BQ0Y7O1NBTEV2TDs2QkFEQWlIO0tBT0F4QztPQUNGOzs7Z0JBSEU4RztTQVJrQnZIO0lBY3RCLFdBSklTLFVBVm1EeUM7R0FjdEM7WUFJYnNFLFlBQVUsU0FBSTtZQU1kbE8sVUFBVW5EO0lBQ0QsSUFBUHNSO2FBQ0F6RDtLQUNGLE9BRkV5RDs7Z0JBQUFBLHFCQURRdFIsNEJBQUFBO0lBT3FCO0lBQ2pDLE9BTkk2TjtHQU1GO1lBaUJBN0osT0FBTXVOLElBQUVDO0lBWkYsSUFBSjdULFFBWUk0VDthQVhBMUQ7S0FDTjtNQUFNLFlBQUEsV0FGSmxRO29CQUdLcUMsY0FBSyxXQUFMQTtTQUhMckMsU0FZSTRULElBSEc7TUFUUDVULE9BWU02VDs7SUFISztJQUNmLE9BVFEzRDtHQVdnQjtZQUV0QjREO0lBSUU7S0FKZ0I5RjtLQUFSOUI7S0EvQko0RjtPQW1DSiw2REFKUTVGO2FBQ1I2SDtLQS9CYyxZQUFBLFdBRFZqQztpQkFDd0Q7U0FpQ3ZEcFE7S0FqQ2tDLGVBaUNsQ0EsNEJBQUFBO0lBakMyRDtJQW1DbkQsT0FQZjJFLE9BR0UwTixnQkFIRjFOLE9BekJBYixrQkEyQmtCd0k7O1lBUXBCZ0c7SUFDSDtLQUFjNUU7S0FBUmxEO0tBRXlCLE1BQUEsc0NBRnpCQTtLQUVHLFFBQUE7O1NBQ0N4SyxjQUZMeUQsV0FFS3pEOztTQUZMeUQsV0FHUTtJQUVHO0tBQUEsTUFBQSxzQ0FMWEE7S0FLQThPLFdBQVc7S0FDSCxNQUFBLHNDQU5SOU87S0FNQStPLFFBQVE7S0FDQyxNQUFBLHNDQVBUL087S0FPQWdQLFNBQVM7S0FTRCxXQXJEUjNPLFVBMENBeU87S0FJT25DO2VBVkUxQzs7O1VBWVAvTTs7T0FFMEM7UUFEdkNrTTtRQUN1QyxNQWxENUMvSSxVQTJDQTBPO1FBT01sQixXQXpCTjNNLE9BcUJPeUwsUUFyQlB6TCxPQUVBeU4sUUFxQkV6UjtRQUZLeVAsU0FJRGtCO2tCQUREekU7OztNQURpQztPQUFBLE1BaER0Qy9JLFVBNENBMk87YUFuQkE5TixPQXFCT3lMLFFBckJQekwsT0FFQXlOLFFBcUJFelI7OztnQkF0REZxUjtLQTJESixXQWpCS3hIOztHQWlCeUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FoYXhDd0M7T0FLQUU7T0F5TUp5QztPQVBBM0Y7T0E0RUF1RztPQXdCQUs7T0FoQkFKO09BbUJBSztPQU1BQztPQStCQWhTO09BMkRBd1Q7OztFIiwic291cmNlc0NvbnRlbnQiOlsibGV0IGVycm9yX21zZ2YgZm10ID0gRm10LmtzdHIgKGZ1biBtc2cgLT4gRXJyb3IgKGBNc2cgbXNnKSkgZm10XG5cbmV4Y2VwdGlvbiBJbnZhbGlkX3Rva2VuXG5cbigqIEZyb20gUkZDIDIwNDVcblxuICAgICAgICB0c3BlY2lhbHMgOj0gIFwiKFwiIC8gXCIpXCIgLyBcIjxcIiAvIFwiPlwiIC8gXCJAXCIgL1xuICAgICAgICAgICAgICAgICAgICAgIFwiLFwiIC8gXCI7XCIgLyBcIjpcIiAvIFwiXFxcIiAvIDxcIj5cbiAgICAgICAgICAgICAgICAgICAgICBcIi9cIiAvIFwiW1wiIC8gXCJdXCIgLyBcIj9cIiAvIFwiPVwiXG4gICAgICAgICAgICAgICAgICAgICAgOyBNdXN0IGJlIGluIHF1b3RlZC1zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgOyB0byB1c2Ugd2l0aGluIHBhcmFtZXRlciB2YWx1ZXNcblxuICAgICAgTm90ZSB0aGF0IHRoZSBkZWZpbml0aW9uIG9mIFwidHNwZWNpYWxzXCIgaXMgdGhlIHNhbWUgYXMgdGhlIFJGQyA4MjJcbiAgICAgIGRlZmluaXRpb24gb2YgXCJzcGVjaWFsc1wiIHdpdGggdGhlIGFkZGl0aW9uIG9mIHRoZSB0aHJlZSBjaGFyYWN0ZXJzXG4gICAgICBcIi9cIiwgXCI/XCIsIGFuZCBcIj1cIiwgYW5kIHRoZSByZW1vdmFsIG9mIFwiLlwiLlxuKilcbmxldCBpc190c3BlY2lhbHMgPSBmdW5jdGlvblxuICB8ICcoJyB8ICcpJyB8ICc8JyB8ICc+JyB8ICdAJyB8ICcsJyB8ICc7JyB8ICc6JyB8ICdcXFxcJyB8ICdcIicgfCAnLycgfCAnWycgfCAnXSdcbiAgfCAnPycgfCAnPScgLT5cbiAgICAgIHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBpc19jdGwgPSBmdW5jdGlvbiAnXFwwMDAnIC4uICdcXDAzMScgfCAnXFwxMjcnIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5sZXQgaXNfc3BhY2UgPSAoID0gKSAnICdcblxuKCogRnJvbSBSRkMgMjA0NVxuXG4gICAgICAgIHRva2VuIDo9IDEqPGFueSAoVVMtQVNDSUkpIENIQVIgZXhjZXB0IFNQQUNFLCBDVExzLFxuICAgICAgICAgICAgICAgICAgICBvciB0c3BlY2lhbHM+XG4qKVxubGV0IGlzX2FzY2lpID0gZnVuY3Rpb24gJ1xcMDAwJyAuLiAnXFwxMjcnIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbmxldCBpc190b2tlbiBjID1cbiAgaXNfYXNjaWkgYyAmJiAobm90IChpc190c3BlY2lhbHMgYykpICYmIChub3QgKGlzX2N0bCBjKSkgJiYgbm90IChpc19zcGFjZSBjKVxuXG5sZXQgaXNfb2JzX25vX3dzX2N0bCA9IGZ1bmN0aW9uXG4gIHwgJ1xcMDAxJyAuLiAnXFwwMDgnIHwgJ1xcMDExJyB8ICdcXDAxMicgfCAnXFwwMTQnIC4uICdcXDAzMScgfCAnXFwxMjcnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBpc19xdGV4dCA9IGZ1bmN0aW9uICdcXHInIHwgJ1xcXFwnIHwgJ1wiJyAtPiBmYWxzZSB8IF8gLT4gdHJ1ZVxuXG5tb2R1bGUgVHlwZSA9IHN0cnVjdFxuICB0eXBlIGRpc2NyZXRlID0gWyBgVGV4dCB8IGBJbWFnZSB8IGBBdWRpbyB8IGBWaWRlbyB8IGBBcHBsaWNhdGlvbiBdXG4gIHR5cGUgY29tcG9zaXRlID0gWyBgTXVsdGlwYXJ0IF1cbiAgdHlwZSBleHRlbnNpb24gPSBbIGBJZXRmX3Rva2VuIG9mIHN0cmluZyB8IGBYX3Rva2VuIG9mIHN0cmluZyBdXG4gIHR5cGUgdCA9IFsgZGlzY3JldGUgfCBjb21wb3NpdGUgfCBleHRlbnNpb24gXVxuXG4gIGxldCB0ZXh0ID0gYFRleHRcbiAgbGV0IGltYWdlID0gYEltYWdlXG4gIGxldCBhdWRpbyA9IGBBdWRpb1xuICBsZXQgdmlkZW8gPSBgVmlkZW9cbiAgbGV0IGFwcGxpY2F0aW9uID0gYEFwcGxpY2F0aW9uXG4gIGxldCBtdWx0aXBhcnQgPSBgTXVsdGlwYXJ0XG4gIGxldCBpc19kaXNjcmV0ZSA9IGZ1bmN0aW9uICNkaXNjcmV0ZSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuICBsZXQgaXNfbXVsdGlwYXJ0ID0gZnVuY3Rpb24gYE11bHRpcGFydCAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuICBsZXQgaWV0ZiB0b2tlbiA9IE9rIChgSWV0Zl90b2tlbiB0b2tlbilcblxuICBsZXQgZXh0ZW5zaW9uIHRva2VuID1cbiAgICBpZiBTdHJpbmcubGVuZ3RoIHRva2VuIDwgM1xuICAgIHRoZW4gZXJyb3JfbXNnZiBcIkV4dGVuc2lvbiB0b2tlbiBNVVNUIGhhdmUsIGF0IGxlYXN0LCAzIGJ5dGVzOiAlU1wiIHRva2VuXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggKHRva2VuLlswXSwgdG9rZW4uWzFdKSB3aXRoXG4gICAgICB8ICgneCcgfCAnWCcpLCAnLScgLT4gKFxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgU3RyaW5nLml0ZXJcbiAgICAgICAgICAgICAgKGZ1biBjaHIgLT4gaWYgbm90IChpc190b2tlbiBjaHIpIHRoZW4gcmFpc2UgSW52YWxpZF90b2tlbilcbiAgICAgICAgICAgICAgKFN0cmluZy5zdWIgdG9rZW4gMiAoU3RyaW5nLmxlbmd0aCB0b2tlbiAtIDIpKSA7XG4gICAgICAgICAgICBPayAoYFhfdG9rZW4gdG9rZW4pXG4gICAgICAgICAgd2l0aCBJbnZhbGlkX3Rva2VuIC0+XG4gICAgICAgICAgICBlcnJvcl9tc2dmIFwiRXh0ZW5zaW9uIHRva2VuICVTIGRvZXMgbm90IHJlc3BlY3Qgc3RhbmRhcmRzXCIgdG9rZW4pXG4gICAgICB8IF8gLT4gZXJyb3JfbXNnZiBcIkFuIGV4dGVuc2lvbiB0b2tlbiBNVVNUIGJlIHByZWZpeGVkIGJ5IFtYLV06ICVTXCIgdG9rZW5cblxuICBsZXQgcHAgcHBmID0gZnVuY3Rpb25cbiAgICB8IGBUZXh0IC0+IEZtdC5zdHJpbmcgcHBmIFwidGV4dFwiXG4gICAgfCBgSW1hZ2UgLT4gRm10LnN0cmluZyBwcGYgXCJpbWFnZVwiXG4gICAgfCBgQXVkaW8gLT4gRm10LnN0cmluZyBwcGYgXCJhdWRpb1wiXG4gICAgfCBgVmlkZW8gLT4gRm10LnN0cmluZyBwcGYgXCJ2aWRlb1wiXG4gICAgfCBgQXBwbGljYXRpb24gLT4gRm10LnN0cmluZyBwcGYgXCJhcHBsaWNhdGlvblwiXG4gICAgfCBgTXVsdGlwYXJ0IC0+IEZtdC5zdHJpbmcgcHBmIFwibXVsdGlwYXJ0XCJcbiAgICB8IGBJZXRmX3Rva2VuIHRva2VuIC0+IEZtdC5wZiBwcGYgXCJpZXRmOiVzXCIgdG9rZW5cbiAgICB8IGBYX3Rva2VuIHRva2VuIC0+IEZtdC5wZiBwcGYgXCJ4OiVzXCIgdG9rZW5cblxuICBsZXQgdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgICB8IGBUZXh0IC0+IFwidGV4dFwiXG4gICAgfCBgSW1hZ2UgLT4gXCJpbWFnZVwiXG4gICAgfCBgQXVkaW8gLT4gXCJhdWRpb1wiXG4gICAgfCBgVmlkZW8gLT4gXCJ2aWRlb1wiXG4gICAgfCBgQXBwbGljYXRpb24gLT4gXCJhcHBsaWNhdGlvblwiXG4gICAgfCBgTXVsdGlwYXJ0IC0+IFwibXVsdGlwYXJ0XCJcbiAgICB8IGBJZXRmX3Rva2VuIHRva2VuIHwgYFhfdG9rZW4gdG9rZW4gLT4gdG9rZW5cblxuICBsZXQgY29tcGFyZSBhIGIgPVxuICAgIFN0cmluZy4oXG4gICAgICBjb21wYXJlIChsb3dlcmNhc2VfYXNjaWkgKHRvX3N0cmluZyBhKSkgKGxvd2VyY2FzZV9hc2NpaSAodG9fc3RyaW5nIGIpKSlcblxuICBsZXQgZXF1YWwgYSBiID0gY29tcGFyZSBhIGIgPSAwXG4gIGxldCBkZWZhdWx0ID0gYFRleHRcbmVuZFxuXG5tb2R1bGUgU3VidHlwZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBbIGBJZXRmX3Rva2VuIG9mIHN0cmluZyB8IGBJYW5hX3Rva2VuIG9mIHN0cmluZyB8IGBYX3Rva2VuIG9mIHN0cmluZyBdXG5cbiAgbGV0IGlldGYgdG9rZW4gPVxuICAgICgqIFhYWChkaW5vc2F1cmUpOiBub3Qgc3VyZSBob3cgdG8gY2hlY2sgdGhpcyB2YWx1ZS4gKilcbiAgICBPayAoYElldGZfdG9rZW4gdG9rZW4pXG5cbiAgbGV0IGlhbmEgdG9rZW4gPSBPayAoYElhbmFfdG9rZW4gdG9rZW4pXG5cbiAgbGV0IGlhbmFfZXhuIHRva2VuID1cbiAgICBtYXRjaCBpYW5hIHRva2VuIHdpdGggT2sgdiAtPiB2IHwgRXJyb3IgKGBNc2cgZXJyKSAtPiBpbnZhbGlkX2FyZyBlcnJcblxuICBsZXQgdiB0b2tlbiA9IGlhbmFfZXhuIHRva2VuXG5cbiAgbGV0IGV4dGVuc2lvbiB0b2tlbiA9XG4gICAgaWYgU3RyaW5nLmxlbmd0aCB0b2tlbiA8IDNcbiAgICB0aGVuIGVycm9yX21zZ2YgXCJFeHRlbnNpb24gdG9rZW4gTVVTVCBoYXZlLCBhdCBsZWFzdCwgMyBieXRlczogJVNcIiB0b2tlblxuICAgIGVsc2VcbiAgICAgIG1hdGNoICh0b2tlbi5bMF0sIHRva2VuLlsxXSkgd2l0aFxuICAgICAgfCAoJ3gnIHwgJ1gnKSwgJy0nIC0+IChcbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIFN0cmluZy5pdGVyXG4gICAgICAgICAgICAgIChmdW4gY2hyIC0+IGlmIG5vdCAoaXNfdG9rZW4gY2hyKSB0aGVuIHJhaXNlIEludmFsaWRfdG9rZW4pXG4gICAgICAgICAgICAgIChTdHJpbmcuc3ViIHRva2VuIDIgKFN0cmluZy5sZW5ndGggdG9rZW4gLSAyKSkgO1xuICAgICAgICAgICAgT2sgKGBYX3Rva2VuIHRva2VuKVxuICAgICAgICAgIHdpdGggSW52YWxpZF90b2tlbiAtPlxuICAgICAgICAgICAgZXJyb3JfbXNnZiBcIkV4dGVuc2lvbiB0b2tlbiAlUyBkb2VzIG5vdCByZXNwZWN0IHN0YW5kYXJkc1wiIHRva2VuKVxuICAgICAgfCBfIC0+IGVycm9yX21zZ2YgXCJBbiBleHRlbnNpb24gdG9rZW4gTVVTVCBiZSBwcmVmaXhlZCBieSBbWC1dOiAlU1wiIHRva2VuXG5cbiAgbGV0IHBwIHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBgSWV0Zl90b2tlbiB0b2tlbiAtPiBGbXQucGYgcHBmIFwiaWV0Zjolc1wiIHRva2VuXG4gICAgfCBgSWFuYV90b2tlbiB0b2tlbiAtPiBGbXQucGYgcHBmIFwiaWFuYTolc1wiIHRva2VuXG4gICAgfCBgWF90b2tlbiB0b2tlbiAtPiBGbXQucGYgcHBmIFwieDolc1wiIHRva2VuXG5cbiAgbGV0IGNvbXBhcmUgYSBiID1cbiAgICBtYXRjaCAoYSwgYikgd2l0aFxuICAgIHwgKCAoYElldGZfdG9rZW4gYSB8IGBJYW5hX3Rva2VuIGEgfCBgWF90b2tlbiBhKSxcbiAgICAgICAgKGBJZXRmX3Rva2VuIGIgfCBgSWFuYV90b2tlbiBiIHwgYFhfdG9rZW4gYikgKSAtPlxuICAgICAgICBTdHJpbmcuKGNvbXBhcmUgKGxvd2VyY2FzZV9hc2NpaSBhKSAobG93ZXJjYXNlX2FzY2lpIGIpKVxuXG4gIGxldCBlcXVhbCBhIGIgPSBjb21wYXJlIGEgYiA9IDBcbiAgbGV0IGRlZmF1bHQgPSBgSWFuYV90b2tlbiBcInBsYWluXCJcbmVuZFxuXG5tb2R1bGUgUGFyYW1ldGVycyA9IHN0cnVjdFxuICBtb2R1bGUgTWFwID0gTWFwLk1ha2UgKFN0cmluZylcblxuICB0eXBlIGtleSA9IHN0cmluZ1xuICB0eXBlIHZhbHVlID0gU3RyaW5nIG9mIHN0cmluZyB8IFRva2VuIG9mIHN0cmluZ1xuICB0eXBlIHQgPSB2YWx1ZSBNYXAudFxuXG4gIGxldCBrZXkga2V5ID1cbiAgICAoKiBYWFgoZGlub3NhdXJlKTogUkZDIDIwNDUgc2F5czpcbiAgICAgICAtIGF0dHJpYnV0ZSBpcyBBTFdBWVMgY2FzZS1pbnNlbnNpdGl2ZVxuICAgICAgIC0gYXR0cmlidXRlIDo9IHRva2VuXG4gICAgKilcbiAgICB0cnlcbiAgICAgIFN0cmluZy5pdGVyXG4gICAgICAgIChmdW4gY2hyIC0+IGlmIG5vdCAoaXNfdG9rZW4gY2hyKSB0aGVuIHJhaXNlIEludmFsaWRfdG9rZW4pXG4gICAgICAgIGtleSA7XG4gICAgICBPayAoU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBrZXkpXG4gICAgd2l0aCBJbnZhbGlkX3Rva2VuIC0+IGVycm9yX21zZ2YgXCJLZXkgJVMgZG9lcyBub3QgcmVzcGVjdCBzdGFuZGFyZHNcIiBrZXlcblxuICBsZXQga2V5X2V4biB4ID1cbiAgICBtYXRjaCBrZXkgeCB3aXRoIE9rIHYgLT4gdiB8IEVycm9yIChgTXNnIGVycikgLT4gaW52YWxpZF9hcmcgZXJyXG5cbiAgbGV0IGsgeCA9IGtleV9leG4geFxuXG4gIGV4Y2VwdGlvbiBJbnZhbGlkX3V0Zl84XG5cbiAgbGV0IHZhbHVlIHYgPVxuICAgIGxldCB0b190b2tlbiB4ID1cbiAgICAgIHRyeVxuICAgICAgICBTdHJpbmcuaXRlclxuICAgICAgICAgIChmdW4gY2hyIC0+IGlmIG5vdCAoaXNfdG9rZW4gY2hyKSB0aGVuIHJhaXNlIEludmFsaWRfdG9rZW4pXG4gICAgICAgICAgeCA7XG4gICAgICAgIE9rIChUb2tlbiB4KVxuICAgICAgd2l0aCBJbnZhbGlkX3Rva2VuIC0+IGVycm9yX21zZ2YgXCJWYWx1ZSAlUyBkb2VzIG5vdCByZXNwZWN0IHN0YW5kYXJkc1wiIHZcbiAgICBpblxuXG4gICAgKCogWFhYKGRpbm9zYXVyZSk6IFtpc19xdW90ZWRfcGFpcl0gYWNjZXB0cyBjaGFyYWN0ZXJzIFxcMDAwLVxcMTI3LiBVVEYtOFxuICAgICAgIGV4dGVuZHMgdG8gXFwwMDAtXFwyNTUuIEhvd2V2ZXIsIHF0ZXh0IGludmFsaWRzIHNvbWUgb2YgdGhlbTogXFwwMDksIFxcMDEwLFxuICAgICAgIFxcMDEzLCBcXDAzMiwgXFwwMzQgYW5kIFxcMDkyLiBNb3N0IG9mIHRoZW0gbmVlZCB0byBiZSBlc2NhcGVkLlxuXG4gICAgICAgQWJvdXQgXFwwMzIsIHRoaXMgY2FzZSBpcyBsaXR0bGUgYml0IHdlaXJkIHdoZW4gW3Fjb250ZW50XSBhY2NlcHRzIFtGV1NdLlxuICAgICAgIEF0IHRoZSBlbmQsIFxcMDMyLCBpcyBwb3NzaWJsZSBpbiBhIHF1b3RlZC1zdHJpbmcgaG93ZXZlciwgbnVtYmVyIG9mIGl0XG4gICAgICAgZG9lcyBub3QgbG9vayBzaWduaWZpY2FudCAtIHNvIHdlIGRvbid0IHRyeSB0byBlc2NhcGUgaXQuICopXG4gICAgbGV0IG5lZWRfdG9fZXNjYXBlID0gZnVuY3Rpb25cbiAgICAgIHwgJ1xcMDA5JyB8ICdcXDAxMCcgfCAnXFwwMTMnIHwgJ1xcMDM0JyB8ICdcXDA5MicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlIGluXG4gICAgbGV0IG9mX2VzY2FwZWRfY2hhcmFjdGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ1xcMDA5JyAtPiAndCdcbiAgICAgIHwgJ1xcMDEwJyAtPiAnbidcbiAgICAgIHwgJ1xcMDEzJyAtPiAncidcbiAgICAgIHwgYyAtPiBjIGluXG4gICAgbGV0IGVzY2FwZV9jaGFyYWN0ZXJzIHggPVxuICAgICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggeCBpblxuICAgICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgICBTdHJpbmcuaXRlclxuICAgICAgICAoZnVuIGNociAtPlxuICAgICAgICAgIGlmIG5lZWRfdG9fZXNjYXBlIGNoclxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxcXCcgO1xuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAob2ZfZXNjYXBlZF9jaGFyYWN0ZXIgY2hyKSlcbiAgICAgICAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBidWYgY2hyKVxuICAgICAgICB4IDtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgICBsZXQgdXRmXzggeCA9XG4gICAgICB0cnlcbiAgICAgICAgVXV0Zi5TdHJpbmcuZm9sZF91dGZfOFxuICAgICAgICAgIChmdW4gKCkgX3BvcyAtPiBmdW5jdGlvblxuICAgICAgICAgICAgfCBgTWFsZm9ybWVkIF8gLT4gcmFpc2UgSW52YWxpZF91dGZfOFxuICAgICAgICAgICAgfCBgVWNoYXIgXyAtPiAoKSlcbiAgICAgICAgICAoKSB4IDtcbiAgICAgICAgT2sgeFxuICAgICAgd2l0aCBJbnZhbGlkX3V0Zl84IC0+XG4gICAgICAgIGVycm9yX21zZ2YgXCJWYWx1ZSAlUyBpcyBub3QgYSB2YWxpZCBVVEYtOCBzdHJpbmdcIiB4IGluXG4gICAgbWF0Y2ggdG9fdG9rZW4gdiB3aXRoXG4gICAgfCBPayBfIGFzIHYgLT4gdlxuICAgIHwgRXJyb3IgXyAtPlxuICAgICAgICAoKiBVVEYtOCByZXNwZWN0cyBhbiBpbnRlcnZhbCBvZiB2YWx1ZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gaGF2ZSBhblxuICAgICAgICAgICBpbnZhbGlkIFVURi04IHN0cmluZy4gU28gd2UgbmVlZCB0byBjaGVjayBpdC4gVVRGLTggaXMgYSBzdXBlcnNldCBvZlxuICAgICAgICAgICBBU0NJSSwgc28gd2UgbmVlZCwgZmlyc3RseSB0byBjaGVjayBpZiBpdCdzIGEgdmFsaWQgVVRGLTggc3RyaW5nLiBJblxuICAgICAgICAgICB0aGlzIGNhc2UsIGFuZCBtb3N0bHkgYmVjYXVzZSB3ZSBjYW4gZXNjYXBlIGFueXRoaW5nIChzZWVcbiAgICAgICAgICAgW2lzX3F1b3RlZF9wYWlyXSksIHdlIGRvIGEgcGFzcyB0byBlc2NhcGUgc29tZSBvZiBBU0NJSSBjaGFyYWN0ZXJzIG9ubHlcbiAgICAgICAgICAgdGhlbi5cblxuICAgICAgICAgICBBdCB0aGUgZW5kLCBpZiBbdmFsdWVdIGlzIGEgdmFsaWQgVVRGLTggc3RyaW5nLCB3ZSB3aWxsIGRvbid0IGhhdmUgYVxuICAgICAgICAgICBwcm9ibGVtIHRvIGVuY29kZSBpdCBpZiB3ZSB0YWtlIGNhcmUgdG8gZXNjYXBlIGludmFsaWQgW3F0ZXh0XVxuICAgICAgICAgICBjaGFyYWN0ZXJzLlxuXG4gICAgICAgICAgIEhvd2V2ZXIsIG9yZGVyIGlzIHJlYWxseSBpbXBvcnRhbnQgc2VtYW50aWNhbGx5LiBVVEYtOCAtPiBlc2NhcGVcbiAgICAgICAgICAgZXhwZWN0cyBhIHNwZWNpYWwgcHJvY2VzcyB0byBkZWNvZGVyIChlc2NhcGUgLT4gVVRGLTgpLiBBYm91dCBoaXN0b3J5LFxuICAgICAgICAgICB1bmljb3JuIGFuZCBzbyBvbiwgaXQgc2hvdWxkIGJlIHRoZSBiZXN0IHRvIGtlZXAgdGhpcyBvcmRlci4gKilcbiAgICAgICAgbGV0ICggPj58ICkgeCBmID0gUmVzdWx0Lm1hcCBmIHggaW5cbiAgICAgICAgdXRmXzggdiA+PnwgZXNjYXBlX2NoYXJhY3RlcnMgPj58IGZ1biB4IC0+IFN0cmluZyB4XG5cbiAgbGV0IHZhbHVlX2V4biB4ID1cbiAgICBtYXRjaCB2YWx1ZSB4IHdpdGggT2sgdiAtPiB2IHwgRXJyb3IgKGBNc2cgZXJyKSAtPiBpbnZhbGlkX2FyZyBlcnJcblxuICBsZXQgdiB4ID0gdmFsdWVfZXhuIHhcbiAgbGV0IGVtcHR5ID0gTWFwLmVtcHR5XG5cbiAgbGV0IG1lbSBrZXkgdCA9XG4gICAgKCogWFhYKGRpbm9zYXVyZSk6IFtrZXldIGNhbiBvbmx5IGV4aXN0IGJ5IFtrZXldIGZ1bmN0aW9uIHdoaWNoIGFwcGx5XG4gICAgICAgW1N0cmluZy5sb3dlcmNhc2VfYXNjaWldLiAqKVxuICAgIE1hcC5tZW0ga2V5IHRcblxuICBsZXQgYWRkIGtleSB2YWx1ZSB0ID0gTWFwLmFkZCBrZXkgdmFsdWUgdFxuICBsZXQgc2luZ2xldG9uIGtleSB2YWx1ZSA9IE1hcC5zaW5nbGV0b24ga2V5IHZhbHVlXG4gIGxldCByZW1vdmUga2V5IHQgPSBNYXAucmVtb3ZlIGtleSB0XG5cbiAgbGV0IGZpbmQga2V5IHQgPVxuICAgIG1hdGNoIE1hcC5maW5kIGtleSB0IHdpdGggeCAtPiBTb21lIHggfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IE5vbmVcblxuICBsZXQgaXRlciBmIHQgPSBNYXAuaXRlciBmIHRcbiAgbGV0IHBwX2tleSA6IGtleSBGbXQudCA9IEZtdC5zdHJpbmdcblxuICBsZXQgcHBfdmFsdWUgcHBmID0gZnVuY3Rpb25cbiAgICB8IFRva2VuIHRva2VuIC0+IEZtdC5zdHJpbmcgcHBmIHRva2VuXG4gICAgfCBTdHJpbmcgdmFsdWUgLT4gRm10LnBmIHBwZiBcIiVTXCIgdmFsdWVcblxuICBsZXQgcHAgcHBmIHQgPVxuICAgIGxldCBwcCBwcGYgKGtleSwgdmFsdWUpID0gRm10LnBmIHBwZiBcIiVhPSVhXCIgcHBfa2V5IGtleSBwcF92YWx1ZSB2YWx1ZSBpblxuICAgIEZtdC5saXN0IH5zZXA6KEZtdC5hbnkgXCI7QCBcIikgcHAgcHBmIChNYXAuYmluZGluZ3MgdClcblxuICBsZXQgb2ZfZXNjYXBlZF9jaGFyYWN0ZXIgPSBmdW5jdGlvblxuICAgIHwgJ1xceDYxJyAtPiAnXFx4MDcnICgqIFwiXFxhXCIgKilcbiAgICB8ICdcXHg2MicgLT4gJ1xceDA4JyAoKiBcIlxcYlwiICopXG4gICAgfCAnXFx4NzQnIC0+ICdcXHgwOScgKCogXCJcXHRcIiAqKVxuICAgIHwgJ1xceDZFJyAtPiAnXFx4MEEnICgqIFwiXFxuXCIgKilcbiAgICB8ICdcXHg3NicgLT4gJ1xceDBCJyAoKiBcIlxcdlwiICopXG4gICAgfCAnXFx4NjYnIC0+ICdcXHgwQycgKCogXCJcXGZcIiAqKVxuICAgIHwgJ1xceDcyJyAtPiAnXFx4MEQnICgqIFwiXFxyXCIgKilcbiAgICB8IGMgLT4gY1xuXG4gIGxldCB2YWx1ZV91bmVzY2FwZSB4ID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCB4IGluXG4gICAgbGV0IHJlcyA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgd2hpbGUgIXBvcyA8IGxlbiBkb1xuICAgICAgaWYgeC5bIXBvc10gPSAnXFxcXCcgJiYgIXBvcyA8IGxlbiAtIDFcbiAgICAgICAgICgqIFhYWChkaW5vc2F1cmUpOiB3ZSBjYW4gYXZvaWQgdGhpcyBjaGVjayB3aGVuIFt2YWx1ZV0gdGFrZXMgY2FyZSBhYm91dCB0aGF0LiAqKVxuICAgICAgdGhlbiAoXG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciByZXMgKG9mX2VzY2FwZWRfY2hhcmFjdGVyIHguWyFwb3MgKyAxXSkgO1xuICAgICAgICBwb3MgOj0gIXBvcyArIDIpXG4gICAgICBlbHNlIChcbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIHJlcyB4LlshcG9zXSA7XG4gICAgICAgIGluY3IgcG9zKVxuICAgIGRvbmUgO1xuICAgIEJ1ZmZlci5jb250ZW50cyByZXNcblxuICBsZXQgdmFsdWVfY29tcGFyZSBhIGIgPVxuICAgIG1hdGNoIChhLCBiKSB3aXRoXG4gICAgfCBUb2tlbiBhLCBUb2tlbiBiIC0+IFN0cmluZy5jb21wYXJlIGEgYlxuICAgIHwgU3RyaW5nIGEsIFRva2VuIGIgfCBUb2tlbiBiLCBTdHJpbmcgYSAtPlxuICAgICAgICBTdHJpbmcuY29tcGFyZSAodmFsdWVfdW5lc2NhcGUgYSkgYlxuICAgIHwgU3RyaW5nIGEsIFN0cmluZyBiIC0+IFN0cmluZy5jb21wYXJlICh2YWx1ZV91bmVzY2FwZSBhKSAodmFsdWVfdW5lc2NhcGUgYilcblxuICBsZXQgdmFsdWVfZXF1YWwgYSBiID1cbiAgICBtYXRjaCAoYSwgYikgd2l0aFxuICAgIHwgVG9rZW4gYSwgVG9rZW4gYiAtPiBTdHJpbmcuZXF1YWwgYSBiXG4gICAgfCBTdHJpbmcgYSwgVG9rZW4gYiB8IFRva2VuIGIsIFN0cmluZyBhIC0+IFN0cmluZy5lcXVhbCAodmFsdWVfdW5lc2NhcGUgYSkgYlxuICAgIHwgU3RyaW5nIGEsIFN0cmluZyBiIC0+IFN0cmluZy5lcXVhbCAodmFsdWVfdW5lc2NhcGUgYSkgKHZhbHVlX3VuZXNjYXBlIGIpXG5cbiAgbGV0IGNvbXBhcmUgPSBNYXAuY29tcGFyZSB2YWx1ZV9jb21wYXJlXG4gIGxldCBlcXVhbCA9IE1hcC5lcXVhbCB2YWx1ZV9lcXVhbFxuXG4gIGxldCBvZl9saXN0IGxzdCA9XG4gICAgTGlzdC5mb2xkX2xlZnQgKGZ1biBhIChrZXksIHZhbHVlKSAtPiBNYXAuYWRkIGtleSB2YWx1ZSBhKSBNYXAuZW1wdHkgbHN0XG5cbiAgbGV0IHRvX2xpc3QgdCA9IE1hcC5iaW5kaW5ncyB0XG4gIGxldCBkZWZhdWx0ID0gTWFwLmFkZCBcImNoYXJzZXRcIiAoVG9rZW4gXCJ1cy1hc2NpaVwiKSBNYXAuZW1wdHlcbmVuZFxuXG50eXBlIHQgPSB7XG4gIHR5IDogVHlwZS50O1xuICBzdWJ0eSA6IFN1YnR5cGUudDtcbiAgcGFyYW1ldGVycyA6IChzdHJpbmcgKiBQYXJhbWV0ZXJzLnZhbHVlKSBsaXN0O1xufVxuXG5sZXQgZGVmYXVsdCA9XG4gIHtcbiAgICB0eSA9IFR5cGUuZGVmYXVsdDtcbiAgICBzdWJ0eSA9IFN1YnR5cGUuZGVmYXVsdDtcbiAgICBwYXJhbWV0ZXJzID0gUGFyYW1ldGVycy50b19saXN0IFBhcmFtZXRlcnMuZGVmYXVsdDtcbiAgfVxuXG5sZXQgdHkgeyB0eTsgXyB9ID0gdHlcbmxldCBzdWJ0eSB7IHN1YnR5OyBfIH0gPSBzdWJ0eVxubGV0IHBhcmFtZXRlcnMgeyBwYXJhbWV0ZXJzOyBfIH0gPSBwYXJhbWV0ZXJzXG5sZXQgaXNfZGlzY3JldGUgeyB0eTsgXyB9ID0gVHlwZS5pc19kaXNjcmV0ZSB0eVxubGV0IGlzX211bHRpcGFydCB7IHR5OyBfIH0gPSBUeXBlLmlzX211bHRpcGFydCB0eVxubGV0IHdpdGhfdHlwZSA6IHQgLT4gVHlwZS50IC0+IHQgPSBmdW4gdCB0eSAtPiB7IHQgd2l0aCB0eSB9XG5sZXQgd2l0aF9zdWJ0eXBlIDogdCAtPiBTdWJ0eXBlLnQgLT4gdCA9IGZ1biB0IHN1YnR5IC0+IHsgdCB3aXRoIHN1YnR5IH1cblxubGV0IHdpdGhfcGFyYW1ldGVyIDogdCAtPiBQYXJhbWV0ZXJzLmtleSAqIFBhcmFtZXRlcnMudmFsdWUgLT4gdCA9XG4gZnVuIHQgKGssIHYpIC0+XG4gIGxldCBwYXJhbWV0ZXJzID0gUGFyYW1ldGVycy5vZl9saXN0ICgoaywgdikgOjogdC5wYXJhbWV0ZXJzKSBpblxuICB7IHQgd2l0aCBwYXJhbWV0ZXJzID0gUGFyYW1ldGVycy50b19saXN0IHBhcmFtZXRlcnMgfVxuXG5sZXQgYm91bmRhcnkgeyBwYXJhbWV0ZXJzOyBfIH0gPVxuICBtYXRjaCBMaXN0LmFzc29jX29wdCBcImJvdW5kYXJ5XCIgcGFyYW1ldGVycyB3aXRoXG4gIHwgU29tZSAoVG9rZW4gdiB8IFN0cmluZyB2KSAtPiBTb21lIHZcbiAgfCBOb25lIC0+IE5vbmVcblxubGV0IG1ha2UgdHkgc3VidHkgcGFyYW1ldGVycyA9XG4gIHsgdHk7IHN1YnR5OyBwYXJhbWV0ZXJzID0gUGFyYW1ldGVycy50b19saXN0IHBhcmFtZXRlcnMgfVxuXG5sZXQgcHAgcHBmIHsgdHk7IHN1YnR5OyBwYXJhbWV0ZXJzIH0gPVxuICBGbXQucGYgcHBmIFwiJWEvJWEgJWFcIiBUeXBlLnBwIHR5IFN1YnR5cGUucHAgc3VidHkgKEZtdC5odmJveCBQYXJhbWV0ZXJzLnBwKVxuICAgIChQYXJhbWV0ZXJzLm9mX2xpc3QgcGFyYW1ldGVycylcblxubGV0IGVxdWFsIGEgYiA9XG4gIFR5cGUuZXF1YWwgYS50eSBiLnR5XG4gICYmIFN1YnR5cGUuZXF1YWwgYS5zdWJ0eSBiLnN1YnR5XG4gICYmIFBhcmFtZXRlcnMuKGVxdWFsIChvZl9saXN0IGEucGFyYW1ldGVycykgKG9mX2xpc3QgYi5wYXJhbWV0ZXJzKSlcblxubW9kdWxlIERlY29kZXIgPSBzdHJ1Y3RcbiAgb3BlbiBBbmdzdHJvbVxuXG4gIGxldCBpbnZhbGlkX3Rva2VuIHRva2VuID0gRm10LmtzdHIgZmFpbCBcImludmFsaWQgdG9rZW46ICVzXCIgdG9rZW5cblxuICBsZXQgb2Zfc3RyaW5nIHMgYSA9XG4gICAgbWF0Y2ggcGFyc2Vfc3RyaW5nIH5jb25zdW1lOkNvbnN1bWUuQWxsIGEgcyB3aXRoXG4gICAgfCBPayB2IC0+IFNvbWUgdlxuICAgIHwgRXJyb3IgXyAtPiBOb25lXG5cbiAgbGV0IGlzX3dzcCA9IGZ1bmN0aW9uICcgJyB8ICdcXHQnIC0+IHRydWUgfCBfIC0+IGZhbHNlXG4gIGxldCB0b2tlbiA9IHRha2Vfd2hpbGUxIGlzX3Rva2VuXG5cbiAgKCogRnJvbSBSRkMgMjA0NVxuXG4gICAgICAgICAgYXR0cmlidXRlIDo9IHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgIDsgTWF0Y2hpbmcgb2YgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICA7IGlzIEFMV0FZUyBjYXNlLWluc2Vuc2l0aXZlLlxuICAqKVxuICBsZXQgYXR0cmlidXRlID0gdG9rZW4gPj58IFN0cmluZy5sb3dlcmNhc2VfYXNjaWlcblxuICAoKiBGcm9tIFJGQyAyMDQ1XG5cbiAgICAgICAgICBpZXRmLXRva2VuIDo9IDxBbiBleHRlbnNpb24gdG9rZW4gZGVmaW5lZCBieSBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhbmRhcmRzLXRyYWNrIFJGQyBhbmQgcmVnaXN0ZXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggSUFOQS4+XG4gICAgICAgICAgaWFuYS10b2tlbiA6PSA8QSBwdWJsaWNseS1kZWZpbmVkIGV4dGVuc2lvbiB0b2tlbi4gVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhpcyBmb3JtIG11c3QgYmUgcmVnaXN0ZXJlZCB3aXRoIElBTkFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBzcGVjaWZpZWQgaW4gUkZDIDIwNDguPlxuXG4gICAgIFhYWChkaW5vc2F1cmUpOiB3ZSBkb24ndCBjaGVjayBhdCB0aGlzIHRpbWUgaWYgSUVURi9JQU5BIHRva2VuIGV4aXN0cy5cbiAgKilcbiAgbGV0IGlldGZfdG9rZW4gPSB0b2tlblxuXG4gICgqIEZyb20gUkZDIDIwNDVcblxuICAgICAgICAgIHgtdG9rZW4gOj0gPFRoZSB0d28gY2hhcmFjdGVycyBcIlgtXCIgb3IgXCJ4LVwiIGZvbGxvd2VkLCB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgbm8gaW50ZXJ2ZW5pbmcgd2hpdGUgc3BhY2UsIGJ5IGFueSB0b2tlbj5cbiAgKilcbiAgbGV0IHhfdG9rZW4gPVxuICAgIHNhdGlzZnkgKGZ1bmN0aW9uICd4JyB8ICdYJyAtPiB0cnVlIHwgXyAtPiBmYWxzZSkgKj4gY2hhciAnLScgKj4gdG9rZW5cblxuICAoKiBGcm9tIFJGQyAyMDQ1XG5cbiAgICAgICAgICBleHRlbnNpb24tdG9rZW4gOj0gaWV0Zi10b2tlbiAvIHgtdG9rZW5cbiAgKilcbiAgbGV0IGV4dGVuc2lvbl90b2tlbiA9XG4gICAgcGVla19jaGFyID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSAnWCcgfCBTb21lICd4JyAtPiB4X3Rva2VuID4+fCBmdW4gdiAtPiBgWF90b2tlbiB2XG4gICAgfCBfIC0+IGlldGZfdG9rZW4gPj58IGZ1biB2IC0+IGBJZXRmX3Rva2VuIHZcblxuICAoKiBGcm9tIFJGQyAyMDQ1XG5cbiAgICAgICAgICBkaXNjcmV0ZS10eXBlIDo9IFwidGV4dFwiIC8gXCJpbWFnZVwiIC8gXCJhdWRpb1wiIC8gXCJ2aWRlb1wiIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXBwbGljYXRpb25cIiAvIGV4dGVuc2lvbi10b2tlblxuICAgICAgICAgIGNvbXBvc2l0ZS10eXBlIDo9IFwibWVzc2FnZVwiIC8gXCJtdWx0aXBhcnRcIiAvIGV4dGVuc2lvbi10b2tlblxuICAgICAgICAgIHR5cGUgOj0gZGlzY3JldGUtdHlwZSAvIGNvbXBvc2l0ZS10eXBlXG4gICopXG4gIGxldCB0eSA9XG4gICAgdG9rZW4gPj49IGZ1biBzIC0+XG4gICAgKCogWFhYKGRpbm9zYXVyZSk6IGxvd2VyY2FzZV8qYXNjaWkqIGlzIGZpbmUsIG5vdCB1dGY4IGluIHRoaXMgcGFydC4gKilcbiAgICBtYXRjaCBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgd2l0aFxuICAgIHwgXCJ0ZXh0XCIgLT4gcmV0dXJuIGBUZXh0XG4gICAgfCBcImltYWdlXCIgLT4gcmV0dXJuIGBJbWFnZVxuICAgIHwgXCJhdWRpb1wiIC0+IHJldHVybiBgQXVkaW9cbiAgICB8IFwidmlkZW9cIiAtPiByZXR1cm4gYFZpZGVvXG4gICAgfCBcImFwcGxpY2F0aW9uXCIgLT4gcmV0dXJuIGBBcHBsaWNhdGlvblxuICAgIHwgXCJtdWx0aXBhcnRcIiAtPiByZXR1cm4gYE11bHRpcGFydFxuICAgIHwgXyAtPlxuICAgIG1hdGNoIG9mX3N0cmluZyBzIGV4dGVuc2lvbl90b2tlbiB3aXRoXG4gICAgfCBTb21lIHYgLT4gcmV0dXJuIHZcbiAgICB8IE5vbmUgLT4gaW52YWxpZF90b2tlbiBzXG5cbiAgKCogRnJvbSBSRkMgMjA0NVxuXG4gICAgICAgICAgc3VidHlwZSA6PSBleHRlbnNpb24tdG9rZW4gLyBpYW5hLXRva2VuXG4gICopXG4gIGxldCBzdWJ0eSA9XG4gICAgdG9rZW4gPj49IGZ1biBzIC0+XG4gICAgdHJ5XG4gICAgICBsZXQgdiA9IGBJYW5hX3Rva2VuIHMgaW5cbiAgICAgIHJldHVybiB2XG4gICAgd2l0aCBOb3RfZm91bmQgLT4gKFxuICAgICAgbWF0Y2ggb2Zfc3RyaW5nIHMgZXh0ZW5zaW9uX3Rva2VuIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IHJldHVybiB2XG4gICAgICB8IE5vbmUgLT4gaW52YWxpZF90b2tlbiBzKVxuXG4gIGxldCBfMyB4IHkgeiA9ICh4LCB5LCB6KVxuICBsZXQgXzQgYSBiIGMgZCA9IChhLCBiLCBjLCBkKVxuICBsZXQgKCAuIVtdPC0gKSA9IEJ5dGVzLnNldFxuICBsZXQgdXRmXzhfdGFpbCA9IHNhdGlzZnkgQEAgZnVuY3Rpb24gJ1xceDgwJyAuLiAnXFx4YmYnIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IHV0Zl84XzAgPVxuICAgIHNhdGlzZnkgKGZ1bmN0aW9uICdcXHhjMicgLi4gJ1xceGRmJyAtPiB0cnVlIHwgXyAtPiBmYWxzZSkgPj49IGZ1biBiMCAtPlxuICAgIHV0Zl84X3RhaWwgPj49IGZ1biBiMSAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgMiBpblxuICAgIHJlcy4hWzBdIDwtIGIwIDtcbiAgICByZXMuIVsxXSA8LSBiMSA7XG4gICAgcmV0dXJuIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlcylcblxuICBsZXQgdXRmXzhfMSA9XG4gICAgbGlmdDMgXzMgKGNoYXIgJ1xceGUwJylcbiAgICAgIChzYXRpc2Z5IEBAIGZ1bmN0aW9uICdcXHhhMCcgLi4gJ1xceGJmJyAtPiB0cnVlIHwgXyAtPiBmYWxzZSlcbiAgICAgIHV0Zl84X3RhaWxcbiAgICA8fD4gbGlmdDMgXzNcbiAgICAgICAgICAoc2F0aXNmeSBAQCBmdW5jdGlvbiAnXFx4ZTEnIC4uICdcXHhlYycgLT4gdHJ1ZSB8IF8gLT4gZmFsc2UpXG4gICAgICAgICAgdXRmXzhfdGFpbCB1dGZfOF90YWlsXG4gICAgPHw+IGxpZnQzIF8zIChjaGFyICdcXHhlZCcpXG4gICAgICAgICAgKHNhdGlzZnkgQEAgZnVuY3Rpb24gJ1xceDgwJyAuLiAnXFx4OWYnIC0+IHRydWUgfCBfIC0+IGZhbHNlKVxuICAgICAgICAgIHV0Zl84X3RhaWxcbiAgICA8fD4gbGlmdDMgXzNcbiAgICAgICAgICAoc2F0aXNmeSBAQCBmdW5jdGlvbiAnXFx4ZWUnIC4uICdcXHhlZicgLT4gdHJ1ZSB8IF8gLT4gZmFsc2UpXG4gICAgICAgICAgdXRmXzhfdGFpbCB1dGZfOF90YWlsXG5cbiAgbGV0IHV0Zl84XzEgPVxuICAgIHV0Zl84XzEgPj49IGZ1biAoYjAsIGIxLCBiMikgLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIDMgaW5cbiAgICByZXMuIVswXSA8LSBiMCA7XG4gICAgcmVzLiFbMV0gPC0gYjEgO1xuICAgIHJlcy4hWzJdIDwtIGIyIDtcbiAgICByZXR1cm4gKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzKVxuXG4gIGxldCB1dGZfOF8yID1cbiAgICBsaWZ0NCBfNCAoY2hhciAnXFx4ZjAnKVxuICAgICAgKHNhdGlzZnkgQEAgZnVuY3Rpb24gJ1xceDkwJyAuLiAnXFx4YmYnIC0+IHRydWUgfCBfIC0+IGZhbHNlKVxuICAgICAgdXRmXzhfdGFpbCB1dGZfOF90YWlsXG4gICAgPHw+IGxpZnQ0IF80XG4gICAgICAgICAgKHNhdGlzZnkgQEAgZnVuY3Rpb24gJ1xceGYxJyAuLiAnXFx4ZjMnIC0+IHRydWUgfCBfIC0+IGZhbHNlKVxuICAgICAgICAgIHV0Zl84X3RhaWwgdXRmXzhfdGFpbCB1dGZfOF90YWlsXG4gICAgPHw+IGxpZnQ0IF80IChjaGFyICdcXHhmNCcpXG4gICAgICAgICAgKHNhdGlzZnkgQEAgZnVuY3Rpb24gJ1xceDgwJyAuLiAnXFx4OGYnIC0+IHRydWUgfCBfIC0+IGZhbHNlKVxuICAgICAgICAgIHV0Zl84X3RhaWwgdXRmXzhfdGFpbFxuXG4gIGxldCB1dGZfOF8yID1cbiAgICB1dGZfOF8yID4+PSBmdW4gKGIwLCBiMSwgYjIsIGIzKSAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgNCBpblxuICAgIHJlcy4hWzBdIDwtIGIwIDtcbiAgICByZXMuIVsxXSA8LSBiMSA7XG4gICAgcmVzLiFbMl0gPC0gYjIgO1xuICAgIHJlcy4hWzNdIDwtIGIzIDtcbiAgICByZXR1cm4gKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzKVxuXG4gIGxldCB1dGZfOF9hbmQgaXMgPVxuICAgIHNhdGlzZnkgaXMgPj58IFN0cmluZy5tYWtlIDEgPHw+IHV0Zl84XzAgPHw+IHV0Zl84XzEgPHw+IHV0Zl84XzJcblxuICBsZXQgcXVvdGVkX3BhaXIgPVxuICAgIGNoYXIgJ1xcXFwnICo+IGFueV9jaGFyID4+fCBQYXJhbWV0ZXJzLm9mX2VzY2FwZWRfY2hhcmFjdGVyID4+fCBTdHJpbmcubWFrZSAxXG5cbiAgbGV0IHF1b3RlZF9zdHJpbmcgPVxuICAgIGNoYXIgJ1wiJyAqPiBtYW55IChxdW90ZWRfcGFpciA8fD4gdXRmXzhfYW5kIGlzX3F0ZXh0KVxuICAgIDwqIGNoYXIgJ1wiJ1xuICAgID4+fCBTdHJpbmcuY29uY2F0IFwiXCJcblxuICAoKiBGcm9tIFJGQyAyMDQ1XG5cbiAgICAgICAgICB2YWx1ZSA6PSB0b2tlbiAvIHF1b3RlZC1zdHJpbmdcbiAgKilcbiAgbGV0IHZhbHVlID1cbiAgICBxdW90ZWRfc3RyaW5nXG4gICAgPj58IChmdW4gdiAtPiBQYXJhbWV0ZXJzLlN0cmluZyB2KVxuICAgIDx8PiAodG9rZW4gPj58IGZ1biB2IC0+IFBhcmFtZXRlcnMuVG9rZW4gdilcblxuICAoKiBGcm9tIFJGQyAyMDQ1XG5cbiAgICAgICAgICBwYXJhbWV0ZXIgOj0gYXR0cmlidXRlIFwiPVwiIHZhbHVlXG4gICopXG4gIGxldCBwYXJhbWV0ZXIgPVxuICAgIGF0dHJpYnV0ZSA+Pj0gZnVuIGF0dHJpYnV0ZSAtPlxuICAgIHNraXBfd2hpbGUgaXNfd3NwICo+IGNoYXIgJz0nICo+IHNraXBfd2hpbGUgaXNfd3NwICo+IHZhbHVlID4+fCBmdW4gdmFsdWUgLT5cbiAgICAoYXR0cmlidXRlLCB2YWx1ZSlcblxuICAoKiBGcm9tIFJGQyAyMDQ1XG5cbiAgICAgICAgICBjb250ZW50IDo9IFwiQ29udGVudC1UeXBlXCIgXCI6XCIgdHlwZSBcIi9cIiBzdWJ0eXBlXG4gICAgICAgICAgICAgICAgICAgICAqKFwiO1wiIHBhcmFtZXRlcilcbiAgICAgICAgICAgICAgICAgICAgIDsgTWF0Y2hpbmcgb2YgbWVkaWEgdHlwZSBhbmQgc3VidHlwZVxuICAgICAgICAgICAgICAgICAgICAgOyBpcyBBTFdBWVMgY2FzZS1pbnNlbnNpdGl2ZS5cblxuICAgICBYWFgoZGlub3NhdXJlKTogQXMgb3RoZXJzIGZpZWxkcyBvbiBtYWlscywgd2UgY29uc2lkZXIgV1NQIGJldHdlZW5cbiAgICAgdG9rZW5zIGFzIFJGQyA4MjIgc2FpZDpcblxuICAgICAgICAgIEVhY2ggaGVhZGVyIGZpZWxkIGNhbiBiZSB2aWV3ZWQgYXMgYSBzaW5nbGUsIGxvZ2ljYWwgIGxpbmUgIG9mXG4gICAgICAgICAgQVNDSUkgIGNoYXJhY3RlcnMsICBjb21wcmlzaW5nICBhIGZpZWxkLW5hbWUgYW5kIGEgZmllbGQtYm9keS5cbiAgICAgICAgICBGb3IgY29udmVuaWVuY2UsIHRoZSBmaWVsZC1ib2R5ICBwb3J0aW9uICBvZiAgdGhpcyAgY29uY2VwdHVhbFxuICAgICAgICAgIGVudGl0eSAgY2FuIGJlIHNwbGl0IGludG8gYSBtdWx0aXBsZS1saW5lIHJlcHJlc2VudGF0aW9uOyB0aGlzXG4gICAgICAgICAgaXMgY2FsbGVkIFwiZm9sZGluZ1wiLiAgVGhlIGdlbmVyYWwgcnVsZSBpcyB0aGF0IHdoZXJldmVyICB0aGVyZVxuICAgICAgICAgIG1heSAgYmUgIGxpbmVhci13aGl0ZS1zcGFjZSAgKE5PVCAgc2ltcGx5ICBMV1NQLWNoYXJzKSwgYSBDUkxGXG4gICAgICAgICAgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgQVQgTEVBU1Qgb25lIExXU1AtY2hhciBtYXkgaW5zdGVhZCAgYmVcbiAgICAgICAgICBpbnNlcnRlZC5cblxuICAgICBOT1RFOiBXU1AgaXMgYSByZXBsYWNlbWVudCBvZiBDRldTIHRva2VuIGJ1dCBpdCBoYW5kbGVzIGJ5XG4gICAgIFt1bnN0cmN0cmRdIGFuZCBmb2xkZWQgdG8gV1NQLlxuICAqKVxuICBsZXQgY29udGVudCA9XG4gICAgc2tpcF93aGlsZSBpc193c3AgKj4gdHkgPCogc2tpcF93aGlsZSBpc193c3AgPj49IGZ1biB0eSAtPlxuICAgIGNoYXIgJy8nID4+PSBmdW4gXyAtPlxuICAgIHNraXBfd2hpbGUgaXNfd3NwICo+IHN1YnR5IDwqIHNraXBfd2hpbGUgaXNfd3NwID4+PSBmdW4gc3VidHkgLT5cbiAgICBtYW55IChza2lwX3doaWxlIGlzX3dzcCAqPiBjaGFyICc7JyAqPiBza2lwX3doaWxlIGlzX3dzcCAqPiBwYXJhbWV0ZXIpXG4gICAgPj58IGZ1biBwYXJhbWV0ZXJzIC0+IHsgdHk7IHN1YnR5OyBwYXJhbWV0ZXJzIH1cbmVuZFxuXG5sZXQgb2Zfc3RyaW5nIHN0ciA9XG4gIGxldCAoID4+PSApID0gUmVzdWx0LmJpbmQgYW5kICggPj58ICkgeCBmID0gUmVzdWx0Lm1hcCBmIHggaW5cbiAgVW5zdHJjdHJkLm9mX3N0cmluZyBzdHJcbiAgPj58IChmdW4gKF8sIHYpIC0+IFVuc3RyY3RyZC5mb2xkX2Z3cyB2KVxuICA+Pj0gVW5zdHJjdHJkLndpdGhvdXRfY29tbWVudHNcbiAgPj58IFVuc3RyY3RyZC50b191dGZfOF9zdHJpbmdcbiAgPj49IGZ1biBzdHIgLT5cbiAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOlByZWZpeCBEZWNvZGVyLmNvbnRlbnQgc3RyIHdpdGhcbiAgfCBPayB2IC0+IE9rIHZcbiAgfCBFcnJvciBfIC0+IGVycm9yX21zZ2YgXCJJbnZhbGlkICh1bmZvbGRlZCkgQ29udGVudC1UeXBlIHZhbHVlOiAlU1wiIHN0clxuXG5tb2R1bGUgRW5jb2RlciA9IHN0cnVjdFxuICBvcGVuIFByZXR0eW1cblxuICBsZXQgdHkgcHBmID0gZnVuY3Rpb25cbiAgICB8IGBUZXh0IC0+IHN0cmluZyBwcGYgXCJ0ZXh0XCJcbiAgICB8IGBJbWFnZSAtPiBzdHJpbmcgcHBmIFwiaW1hZ2VcIlxuICAgIHwgYEF1ZGlvIC0+IHN0cmluZyBwcGYgXCJhdWRpb1wiXG4gICAgfCBgVmlkZW8gLT4gc3RyaW5nIHBwZiBcInZpZGVvXCJcbiAgICB8IGBBcHBsaWNhdGlvbiAtPiBzdHJpbmcgcHBmIFwiYXBwbGljYXRpb25cIlxuICAgIHwgYE1lc3NhZ2UgLT4gc3RyaW5nIHBwZiBcIm1lc3NhZ2VcIlxuICAgIHwgYE11bHRpcGFydCAtPiBzdHJpbmcgcHBmIFwibXVsdGlwYXJ0XCJcbiAgICB8IGBJZXRmX3Rva2VuIHYgLT4gc3RyaW5nIHBwZiB2XG4gICAgfCBgWF90b2tlbiB2IC0+IHVzaW5nIChmdW4gdiAtPiBcIlgtXCIgXiB2KSBzdHJpbmcgcHBmIHZcblxuICBsZXQgc3VidHkgcHBmID0gZnVuY3Rpb25cbiAgICB8IGBJZXRmX3Rva2VuIHYgLT4gc3RyaW5nIHBwZiB2XG4gICAgfCBgSWFuYV90b2tlbiB2IC0+IHN0cmluZyBwcGYgdlxuICAgIHwgYFhfdG9rZW4gdiAtPiB1c2luZyAoZnVuIHYgLT4gXCJYLVwiIF4gdikgc3RyaW5nIHBwZiB2XG5cbiAgbGV0IHZhbHVlIHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBQYXJhbWV0ZXJzLlRva2VuIHggLT4gZXZhbCBwcGYgWyAhIXN0cmluZyBdIHhcbiAgICB8IFBhcmFtZXRlcnMuU3RyaW5nIHggLT4gZXZhbCBwcGYgWyBjaGFyICQgJ1wiJzsgISFzdHJpbmc7IGNoYXIgJCAnXCInIF0geFxuXG4gIGxldCBwYXJhbWV0ZXIgcHBmIChrZXksIHYpID1cbiAgICBldmFsIHBwZiBbIGJveDsgISFzdHJpbmc7IGN1dDsgY2hhciAkICc9JzsgY3V0OyAhIXZhbHVlOyBjbG9zZSBdIGtleSB2XG5cbiAgbGV0IHBhcmFtZXRlcnMgcHBmIHBhcmFtZXRlcnMgPVxuICAgIGxldCBzZXAgcHBmICgpID0gZXZhbCBwcGYgWyBjaGFyICQgJzsnOyBmd3MgXSBpblxuICAgIGV2YWwgcHBmIFsgYm94OyAhIShsaXN0IH5zZXA6KHNlcCwgKCkpIHBhcmFtZXRlcik7IGNsb3NlIF0gcGFyYW1ldGVyc1xuXG4gIGxldCBjb250ZW50X3R5cGUgcHBmIHQgPVxuICAgIG1hdGNoIHQucGFyYW1ldGVycyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgICBldmFsIHBwZlxuICAgICAgICAgIFsgYmJveDsgISF0eTsgY3V0OyBjaGFyICQgJy8nOyBjdXQ7ICEhc3VidHk7IGNsb3NlIF1cbiAgICAgICAgICB0LnR5IHQuc3VidHlcbiAgICB8IF8gLT5cbiAgICAgICAgZXZhbCBwcGZcbiAgICAgICAgICBbXG4gICAgICAgICAgICBiYm94O1xuICAgICAgICAgICAgISF0eTtcbiAgICAgICAgICAgIGN1dDtcbiAgICAgICAgICAgIGNoYXIgJCAnLyc7XG4gICAgICAgICAgICBjdXQ7XG4gICAgICAgICAgICAhIXN1YnR5O1xuICAgICAgICAgICAgY3V0O1xuICAgICAgICAgICAgY2hhciAkICc7JztcbiAgICAgICAgICAgIGZ3cztcbiAgICAgICAgICAgICEhcGFyYW1ldGVycztcbiAgICAgICAgICAgIGNsb3NlO1xuICAgICAgICAgIF1cbiAgICAgICAgICB0LnR5IHQuc3VidHkgdC5wYXJhbWV0ZXJzXG5lbmRcblxubGV0IHRvX3N0cmluZyB2ID0gUHJldHR5bS50b19zdHJpbmcgRW5jb2Rlci5jb250ZW50X3R5cGUgdlxuIiwidHlwZSBkaXNwb3NpdGlvbl90eXBlID1cbiAgWyBgSW5saW5lIHwgYEF0dGFjaG1lbnQgfCBgSWV0Zl90b2tlbiBvZiBzdHJpbmcgfCBgWF90b2tlbiBvZiBzdHJpbmcgXVxuXG50eXBlIHQgPSB7XG4gIHR5IDogZGlzcG9zaXRpb25fdHlwZTtcbiAgZmlsZW5hbWUgOiBzdHJpbmcgb3B0aW9uO1xuICBjcmVhdGlvbiA6IGRhdGUgb3B0aW9uO1xuICBtb2RpZmljYXRpb24gOiBkYXRlIG9wdGlvbjtcbiAgcmVhZCA6IGRhdGUgb3B0aW9uO1xuICBzaXplIDogaW50IG9wdGlvbjtcbiAgcGFyYW1ldGVycyA6IChzdHJpbmcgKiB2YWx1ZSkgbGlzdDtcbn1cblxuYW5kIHZhbHVlID0gU3RyaW5nIG9mIHN0cmluZyB8IFRva2VuIG9mIHN0cmluZ1xuYW5kIGRhdGUgPSB1bml0XG5cbmxldCBlcnJvcl9tc2dmIGZtdCA9IEZtdC5rc3RyIChmdW4gbXNnIC0+IEVycm9yIChgTXNnIG1zZykpIGZtdFxuXG5sZXQgdiA/ZmlsZW5hbWUgPyhraW5kID0gYElldGZfdG9rZW4gXCJmb3JtLWRhdGFcIikgP3NpemUgbmFtZSA9XG4gIHtcbiAgICB0eSA9IGtpbmQ7XG4gICAgZmlsZW5hbWU7XG4gICAgY3JlYXRpb24gPSBOb25lO1xuICAgIG1vZGlmaWNhdGlvbiA9IE5vbmU7XG4gICAgcmVhZCA9IE5vbmU7XG4gICAgc2l6ZTtcbiAgICBwYXJhbWV0ZXJzID0gWyAoXCJuYW1lXCIsIFN0cmluZyBuYW1lKSBdO1xuICB9XG5cbmxldCBwcF9kaXNwb3NpdGlvbl90eXBlIHBwZiA9IGZ1bmN0aW9uXG4gIHwgYElubGluZSAtPiBGbXQuc3RyaW5nIHBwZiBcImlubGluZVwiXG4gIHwgYEF0dGFjaG1lbnQgLT4gRm10LnN0cmluZyBwcGYgXCJhdHRhY2htZW50XCJcbiAgfCBgSWV0Zl90b2tlbiB2IC0+IEZtdC5wZiBwcGYgXCI8aWV0Zjolcz5cIiB2XG4gIHwgYFhfdG9rZW4gdiAtPiBGbXQucGYgcHBmIFwiWC0lc1wiIHZcblxubGV0IHBwX3ZhbHVlIHBwZiA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nIHYgLT4gRm10LnBmIHBwZiBcIiVTXCIgdlxuICB8IFRva2VuIHYgLT4gRm10LnN0cmluZyBwcGYgdlxuXG5sZXQgcHAgcHBmIHQgPVxuICBGbXQucGYgcHBmXG4gICAgXCJ7IEBbPGhvdj50eXBlPSAlYTtAIGZpbGVuYW1lPSAlYTtAIGNyZWF0aW9uPSAlYTtAIG1vZGlmaWNhdGlvbj0gJWE7QCBcXFxuICAgICByZWFkPSAlYTtAIHNpemU9ICVhO0AgcGFyYW1ldGVycz0gQFs8aG92PiVhQF07QF0gfVwiXG4gICAgcHBfZGlzcG9zaXRpb25fdHlwZSB0LnR5XG4gICAgRm10LihvcHRpb24gc3RyaW5nKVxuICAgIHQuZmlsZW5hbWVcbiAgICBGbXQuKG9wdGlvbiAoYW55IFwiI2RhdGVcIikpXG4gICAgdC5jcmVhdGlvblxuICAgIEZtdC4ob3B0aW9uIChhbnkgXCIjZGF0ZVwiKSlcbiAgICB0Lm1vZGlmaWNhdGlvblxuICAgIEZtdC4ob3B0aW9uIChhbnkgXCIjZGF0ZVwiKSlcbiAgICB0LnJlYWRcbiAgICBGbXQuKG9wdGlvbiBpbnQpXG4gICAgdC5zaXplXG4gICAgRm10LihcbiAgICAgIER1bXAuaXRlcl9iaW5kaW5nc1xuICAgICAgICAoZnVuIGYgLT4gTGlzdC5pdGVyIChmdW4gKGssIHYpIC0+IGYgayB2KSlcbiAgICAgICAgKGFueSBcInBhcmFtZXRlcnNcIikgc3RyaW5nIHBwX3ZhbHVlKVxuICAgIHQucGFyYW1ldGVyc1xuXG5sZXQgbmFtZSB0ID1cbiAgbWF0Y2ggTGlzdC5hc3NvY19vcHQgXCJuYW1lXCIgdC5wYXJhbWV0ZXJzIHdpdGhcbiAgfCBTb21lIChTdHJpbmcgdiB8IFRva2VuIHYpIC0+IFNvbWUgdlxuICB8IE5vbmUgLT4gTm9uZVxuXG5sZXQgZmlsZW5hbWUgeyBmaWxlbmFtZTsgXyB9ID0gZmlsZW5hbWVcbmxldCBzaXplIHsgc2l6ZTsgXyB9ID0gc2l6ZVxubGV0IGRpc3Bvc2l0aW9uX3R5cGUgeyB0eTsgXyB9ID0gdHlcblxubGV0IG9mX2VzY2FwZWRfY2hhcmFjdGVyID0gZnVuY3Rpb25cbiAgfCAnXFx4NjEnIC0+ICdcXHgwNycgKCogXCJcXGFcIiAqKVxuICB8ICdcXHg2MicgLT4gJ1xceDA4JyAoKiBcIlxcYlwiICopXG4gIHwgJ1xceDc0JyAtPiAnXFx4MDknICgqIFwiXFx0XCIgKilcbiAgfCAnXFx4NkUnIC0+ICdcXHgwQScgKCogXCJcXG5cIiAqKVxuICB8ICdcXHg3NicgLT4gJ1xceDBCJyAoKiBcIlxcdlwiICopXG4gIHwgJ1xceDY2JyAtPiAnXFx4MEMnICgqIFwiXFxmXCIgKilcbiAgfCAnXFx4NzInIC0+ICdcXHgwRCcgKCogXCJcXHJcIiAqKVxuICB8IGMgLT4gY1xuXG5sZXQgaXNfb2JzX25vX3dzX2N0bCA9IGZ1bmN0aW9uXG4gIHwgJ1xcMDAxJyAuLiAnXFwwMDgnIHwgJ1xcMDExJyB8ICdcXDAxMicgfCAnXFwwMTQnIC4uICdcXDAzMScgfCAnXFwxMjcnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBpc19xdGV4dCA9IGZ1bmN0aW9uXG4gIHwgJ1xcMDMzJyB8ICdcXDAzNScgLi4gJ1xcMDkxJyB8ICdcXDA5MycgLi4gJ1xcMTI2JyAtPiB0cnVlXG4gIHwgYyAtPiBpc19vYnNfbm9fd3NfY3RsIGNcblxubGV0IGlzX3dzcCA9IGZ1bmN0aW9uICcgJyB8ICdcXHQnIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbm1vZHVsZSBEZWNvZGVyID0gc3RydWN0XG4gIHR5cGUgcGFyYW1ldGVyID1cbiAgICB8IEZpbGVuYW1lIG9mIHZhbHVlXG4gICAgfCBDcmVhdGlvbiBvZiB1bml0XG4gICAgfCBNb2RpZmljYXRpb24gb2YgdW5pdFxuICAgIHwgUmVhZCBvZiB1bml0XG4gICAgfCBTaXplIG9mIGludFxuICAgIHwgUGFyYW1ldGVyIG9mIChzdHJpbmcgKiB2YWx1ZSlcblxuICBvcGVuIEFuZ3N0cm9tXG5cbiAgKCogRnJvbSBSRkMgMjA0NVxuXG4gICAgICAgICAgdHNwZWNpYWxzIDo9ICBcIihcIiAvIFwiKVwiIC8gXCI8XCIgLyBcIj5cIiAvIFwiQFwiIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiLFwiIC8gXCI7XCIgLyBcIjpcIiAvIFwiXFxcIiAvIDxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiL1wiIC8gXCJbXCIgLyBcIl1cIiAvIFwiP1wiIC8gXCI9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDsgTXVzdCBiZSBpbiBxdW90ZWQtc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgOyB0byB1c2Ugd2l0aGluIHBhcmFtZXRlciB2YWx1ZXNcblxuICAgICAgICBOb3RlIHRoYXQgdGhlIGRlZmluaXRpb24gb2YgXCJ0c3BlY2lhbHNcIiBpcyB0aGUgc2FtZSBhcyB0aGUgUkZDIDgyMlxuICAgICAgICBkZWZpbml0aW9uIG9mIFwic3BlY2lhbHNcIiB3aXRoIHRoZSBhZGRpdGlvbiBvZiB0aGUgdGhyZWUgY2hhcmFjdGVyc1xuICAgICAgICBcIi9cIiwgXCI/XCIsIGFuZCBcIj1cIiwgYW5kIHRoZSByZW1vdmFsIG9mIFwiLlwiLlxuICAqKVxuICBsZXQgaXNfdHNwZWNpYWxzID0gZnVuY3Rpb25cbiAgICB8ICcoJyB8ICcpJyB8ICc8JyB8ICc+JyB8ICdAJyB8ICcsJyB8ICc7JyB8ICc6JyB8ICdcXFxcJyB8ICdcIicgfCAnLycgfCAnWydcbiAgICB8ICddJyB8ICc/JyB8ICc9JyAtPlxuICAgICAgICB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IGludmFsaWRfdG9rZW4gdG9rZW4gPSBGbXQua3N0ciBmYWlsIFwiaW52YWxpZCB0b2tlbjogJXNcIiB0b2tlblxuICBsZXQgbm90aGluZ190b19kbyA9IEZtdC5rc3RyIGZhaWwgXCJub3RoaW5nIHRvIGRvXCJcblxuICAoKiAvICopXG5cbiAgbGV0IGlzX2N0bCA9IGZ1bmN0aW9uICdcXDAwMCcgLi4gJ1xcMDMxJyB8ICdcXDEyNycgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcbiAgbGV0IGlzX3NwYWNlID0gKCA9ICkgJyAnXG5cbiAgKCogRnJvbSBSRkMgMjA0NVxuXG4gICAgICAgICAgdG9rZW4gOj0gMSo8YW55IChVUy1BU0NJSSkgQ0hBUiBleGNlcHQgU1BBQ0UsIENUTHMsXG4gICAgICAgICAgICAgICAgICAgICAgb3IgdHNwZWNpYWxzPlxuICAqKVxuICBsZXQgaXNfYXNjaWkgPSBmdW5jdGlvbiAnXFwwMDAnIC4uICdcXDEyNycgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICBsZXQgaXNfdG9rZW4gYyA9XG4gICAgaXNfYXNjaWkgYyAmJiAobm90IChpc190c3BlY2lhbHMgYykpICYmIChub3QgKGlzX2N0bCBjKSkgJiYgbm90IChpc19zcGFjZSBjKVxuXG4gIGxldCB0b2tlbiA9IHRha2Vfd2hpbGUxIGlzX3Rva2VuXG4gIGxldCBpc19kaWdpdCA9IGZ1bmN0aW9uICcwJyAuLiAnOScgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAoKiBGcm9tIFJGQyAyMDQ1XG5cbiAgICAgICAgICBhdHRyaWJ1dGUgOj0gdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgOyBNYXRjaGluZyBvZiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgIDsgaXMgQUxXQVlTIGNhc2UtaW5zZW5zaXRpdmUuXG4gICopXG4gIGxldCBhdHRyaWJ1dGUgPSB0b2tlbiA+PnwgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaVxuXG4gICgqIEZyb20gUkZDIDIwNDVcblxuICAgICAgICAgIGlldGYtdG9rZW4gOj0gPEFuIGV4dGVuc2lvbiB0b2tlbiBkZWZpbmVkIGJ5IGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZHMtdHJhY2sgUkZDIGFuZCByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBJQU5BLj5cbiAgICAgICAgICBpYW5hLXRva2VuIDo9IDxBIHB1YmxpY2x5LWRlZmluZWQgZXh0ZW5zaW9uIHRva2VuLiBUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGlzIGZvcm0gbXVzdCBiZSByZWdpc3RlcmVkIHdpdGggSUFOQVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIHNwZWNpZmllZCBpbiBSRkMgMjA0OC4+XG5cbiAgICAgWFhYKGRpbm9zYXVyZSk6IHdlIGRvbid0IGNoZWNrIGF0IHRoaXMgdGltZSBpZiBJRVRGL0lBTkEgdG9rZW4gZXhpc3RzLlxuICAqKVxuICBsZXQgaWV0Zl90b2tlbiA9IHRva2VuXG5cbiAgKCogRnJvbSBSRkMgMjA0NVxuXG4gICAgICAgICAgeC10b2tlbiA6PSA8VGhlIHR3byBjaGFyYWN0ZXJzIFwiWC1cIiBvciBcIngtXCIgZm9sbG93ZWQsIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICBubyBpbnRlcnZlbmluZyB3aGl0ZSBzcGFjZSwgYnkgYW55IHRva2VuPlxuICAqKVxuICBsZXQgeF90b2tlbiA9XG4gICAgc2F0aXNmeSAoZnVuY3Rpb24gJ3gnIHwgJ1gnIC0+IHRydWUgfCBfIC0+IGZhbHNlKSAqPiBjaGFyICctJyAqPiB0b2tlblxuXG4gICgqIEZyb20gUkZDIDIwNDVcblxuICAgICAgICAgIGV4dGVuc2lvbi10b2tlbiA6PSBpZXRmLXRva2VuIC8geC10b2tlblxuICAqKVxuICBsZXQgZXh0ZW5zaW9uX3Rva2VuID1cbiAgICBwZWVrX2NoYXIgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lICdYJyB8IFNvbWUgJ3gnIC0+IHhfdG9rZW4gPj58IGZ1biB2IC0+IGBYX3Rva2VuIHZcbiAgICB8IF8gLT4gaWV0Zl90b2tlbiA+PnwgZnVuIHYgLT4gYElldGZfdG9rZW4gdlxuXG4gICgqIEZyb20gUkZDIDIwNDVcblxuICAgICAgICAgIHZhbHVlIDo9IHRva2VuIC8gcXVvdGVkLXN0cmluZ1xuICAqKVxuICBsZXQgdmFsdWUgPVxuICAgIENvbnRlbnRfdHlwZS5EZWNvZGVyLnF1b3RlZF9zdHJpbmdcbiAgICA+PnwgKGZ1biB2IC0+IFN0cmluZyB2KVxuICAgIDx8PiAodG9rZW4gPj58IGZ1biB2IC0+IFRva2VuIHYpXG5cbiAgbGV0IG9mX3N0cmluZyBzIGEgPVxuICAgIG1hdGNoIHBhcnNlX3N0cmluZyB+Y29uc3VtZTpBbGwgYSBzIHdpdGggT2sgdiAtPiBTb21lIHYgfCBFcnJvciBfIC0+IE5vbmVcblxuICBsZXQgZGlzcG9zaXRpb25fdHlwZSA9XG4gICAgdG9rZW4gPj49IGZ1biBzIC0+XG4gICAgbWF0Y2ggU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzIHdpdGhcbiAgICB8IFwiaW5saW5lXCIgLT4gcmV0dXJuIGBJbmxpbmVcbiAgICB8IFwiYXR0YWNobWVudFwiIC0+IHJldHVybiBgQXR0YWNobWVudFxuICAgIHwgXyAtPlxuICAgIG1hdGNoIG9mX3N0cmluZyBzIGV4dGVuc2lvbl90b2tlbiB3aXRoXG4gICAgfCBTb21lIHYgLT4gcmV0dXJuIHZcbiAgICB8IE5vbmUgLT4gaW52YWxpZF90b2tlbiBzXG5cbiAgKCogRnJvbSBSRkMgMjA0NVxuXG4gICAgICAgICAgcGFyYW1ldGVyIDo9IGF0dHJpYnV0ZSBcIj1cIiB2YWx1ZVxuICAqKVxuICBsZXQgcGFyYW1ldGVyID1cbiAgICBhdHRyaWJ1dGUgPj49IGZ1biBhdHRyaWJ1dGUgLT5cbiAgICBza2lwX3doaWxlIGlzX3dzcCAqPiBjaGFyICc9JyAqPiBza2lwX3doaWxlIGlzX3dzcCAqPiB2YWx1ZSA+PnwgZnVuIHZhbHVlIC0+XG4gICAgKGF0dHJpYnV0ZSwgdmFsdWUpXG5cbiAgbGV0IHF1b3RlZF9kYXRlX3RpbWUgPSB2YWx1ZSA+PnwgZnVuIF8gLT4gKClcblxuICBsZXQgcGFybSBwYXJtIHZhbHVlID1cbiAgICBzdHJpbmcgcGFybSAqPiBza2lwX3doaWxlIGlzX3dzcCAqPiBjaGFyICc9JyAqPiBza2lwX3doaWxlIGlzX3dzcCAqPiB2YWx1ZVxuXG4gIGxldCBmaWxlbmFtZV9wYXJtID0gcGFybSBcImZpbGVuYW1lXCIgdmFsdWVcbiAgbGV0IGNyZWF0aW9uX2RhdGVfcGFybSA9IHBhcm0gXCJjcmVhdGlvbi1kYXRlXCIgcXVvdGVkX2RhdGVfdGltZVxuICBsZXQgbW9kaWZpY2F0aW9uX2RhdGVfcGFybSA9IHBhcm0gXCJtb2RpZmljYXRpb24tZGF0ZVwiIHF1b3RlZF9kYXRlX3RpbWVcbiAgbGV0IHJlYWRfZGF0ZV9wYXJtID0gcGFybSBcInJlYWQtZGF0ZVwiIHF1b3RlZF9kYXRlX3RpbWVcbiAgbGV0IHNpemVfcGFybSA9IHBhcm0gXCJyZWFkLWRhdGVcIiAodGFrZV93aGlsZTEgaXNfZGlnaXQgPj58IGludF9vZl9zdHJpbmcpXG5cbiAgbGV0IGRpc3Bvc2l0aW9uX3Bhcm0gPVxuICAgIGZpbGVuYW1lX3Bhcm1cbiAgICA+PnwgKGZ1biB2IC0+IEZpbGVuYW1lIHYpXG4gICAgPHw+IChjcmVhdGlvbl9kYXRlX3Bhcm0gPj58IGZ1biB2IC0+IENyZWF0aW9uIHYpXG4gICAgPHw+IChtb2RpZmljYXRpb25fZGF0ZV9wYXJtID4+fCBmdW4gdiAtPiBNb2RpZmljYXRpb24gdilcbiAgICA8fD4gKHJlYWRfZGF0ZV9wYXJtID4+fCBmdW4gdiAtPiBSZWFkIHYpXG4gICAgPHw+IChzaXplX3Bhcm0gPj58IGZ1biB2IC0+IFNpemUgdilcbiAgICA8fD4gKHBhcmFtZXRlciA+PnwgZnVuIHYgLT4gUGFyYW1ldGVyIHYpXG5cbiAgbGV0IGRpc3Bvc2l0aW9uID1cbiAgICBza2lwX3doaWxlIGlzX3dzcCAqPiBkaXNwb3NpdGlvbl90eXBlIDwqIHNraXBfd2hpbGUgaXNfd3NwID4+PSBmdW4gdHkgLT5cbiAgICBtYW55IChza2lwX3doaWxlIGlzX3dzcCAqPiBjaGFyICc7JyAqPiBza2lwX3doaWxlIGlzX3dzcCAqPiBkaXNwb3NpdGlvbl9wYXJtKVxuICAgID4+PSBmdW4gcGFyYW1ldGVycyAtPlxuICAgIGxldCBmaWxlbmFtZSA9IHJlZiBOb25lIGluXG4gICAgbGV0IGNyZWF0aW9uID0gcmVmIE5vbmUgaW5cbiAgICBsZXQgbW9kaWZpY2F0aW9uID0gcmVmIE5vbmUgaW5cbiAgICBsZXQgcmVhZCA9IHJlZiBOb25lIGluXG4gICAgbGV0IHNpemUgPSByZWYgTm9uZSBpblxuICAgIGxldCBwYXJhbWV0ZXJzID1cbiAgICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgIChmdW4gYSAtPiBmdW5jdGlvblxuICAgICAgICAgIHwgRmlsZW5hbWUgKFN0cmluZyB2KSB8IEZpbGVuYW1lIChUb2tlbiB2KSAtPlxuICAgICAgICAgICAgICBmaWxlbmFtZSA6PSBTb21lIHYgO1xuICAgICAgICAgICAgICBhXG4gICAgICAgICAgfCBDcmVhdGlvbiB2IC0+XG4gICAgICAgICAgICAgIGNyZWF0aW9uIDo9IFNvbWUgdiA7XG4gICAgICAgICAgICAgIGFcbiAgICAgICAgICB8IE1vZGlmaWNhdGlvbiB2IC0+XG4gICAgICAgICAgICAgIG1vZGlmaWNhdGlvbiA6PSBTb21lIHYgO1xuICAgICAgICAgICAgICBhXG4gICAgICAgICAgfCBSZWFkIHYgLT5cbiAgICAgICAgICAgICAgcmVhZCA6PSBTb21lIHYgO1xuICAgICAgICAgICAgICBhXG4gICAgICAgICAgfCBTaXplIHYgLT5cbiAgICAgICAgICAgICAgc2l6ZSA6PSBTb21lIHYgO1xuICAgICAgICAgICAgICBhXG4gICAgICAgICAgfCBQYXJhbWV0ZXIgdiAtPiB2IDo6IGEpXG4gICAgICAgIFtdIHBhcmFtZXRlcnMgaW5cbiAgICByZXR1cm5cbiAgICAgIHtcbiAgICAgICAgdHk7XG4gICAgICAgIGZpbGVuYW1lID0gIWZpbGVuYW1lO1xuICAgICAgICBjcmVhdGlvbiA9ICFjcmVhdGlvbjtcbiAgICAgICAgbW9kaWZpY2F0aW9uID0gIW1vZGlmaWNhdGlvbjtcbiAgICAgICAgcmVhZCA9ICFyZWFkO1xuICAgICAgICBzaXplID0gIXNpemU7XG4gICAgICAgIHBhcmFtZXRlcnM7XG4gICAgICB9XG5lbmRcblxubGV0IG9mX3N0cmluZyBzdHIgPVxuICBsZXQgKCA+Pj0gKSA9IFJlc3VsdC5iaW5kIGFuZCAoID4+fCApIHggZiA9IFJlc3VsdC5tYXAgZiB4IGluXG4gIFVuc3RyY3RyZC5vZl9zdHJpbmcgc3RyXG4gID4+fCAoZnVuIChfLCB2KSAtPiBVbnN0cmN0cmQuZm9sZF9md3MgdilcbiAgPj58IFVuc3RyY3RyZC50b191dGZfOF9zdHJpbmdcbiAgPj49IGZ1biBzdHIgLT5cbiAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOkFsbCBEZWNvZGVyLmRpc3Bvc2l0aW9uIHN0ciB3aXRoXG4gIHwgT2sgdiAtPiBPayB2XG4gIHwgRXJyb3IgXyAtPiBlcnJvcl9tc2dmIFwiSW52YWxpZCAodW5mb2xkZWQpIENvbnRlbnQtRGlzcG9zaXRpb24gdmFsdWU6ICVTXCIgc3RyXG5cbm1vZHVsZSBFbmNvZGVyID0gc3RydWN0XG4gIG9wZW4gUHJldHR5bVxuXG4gIGxldCBkaXNwb3NpdGlvbl90eXBlIHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBgQXR0YWNobWVudCAtPiBldmFsIHBwZiBbIHN0cmluZyAkIFwiYXR0YWNobWVudFwiIF1cbiAgICB8IGBJbmxpbmUgLT4gZXZhbCBwcGYgWyBzdHJpbmcgJCBcImlubGluZVwiIF1cbiAgICB8IGBJZXRmX3Rva2VuIHYgLT4gZXZhbCBwcGYgWyAhIXN0cmluZyBdIHZcbiAgICB8IGBYX3Rva2VuIHYgLT4gZXZhbCBwcGYgWyBzdHJpbmcgJCBcIlgtXCI7ICEhc3RyaW5nIF0gdlxuXG4gIGxldCB0b2tlbiBwcGYgc3RyID0gZXZhbCBwcGYgWyAhIXN0cmluZyBdIHN0clxuXG4gICgqIFRPRE8oZGlub3NhdXJlKTogdW5zYWZlIHRva2VuLiAqKVxuXG4gIGxldCB2YWx1ZSBwcGYgPSBmdW5jdGlvblxuICAgIHwgVG9rZW4gdiAtPiB0b2tlbiBwcGYgdlxuICAgIHwgU3RyaW5nIHYgLT4gZXZhbCBwcGYgWyBjaGFyICQgJ1wiJzsgISFzdHJpbmc7IGNoYXIgJCAnXCInIF0gdlxuXG4gIHR5cGUgJ2EgcGFyYW0gPVxuICAgIHwgRmlsZW5hbWUgOiBzdHJpbmcgcGFyYW1cbiAgICB8IENyZWF0aW9uIDogZGF0ZSBwYXJhbVxuICAgIHwgTW9kaWZpY2F0aW9uIDogZGF0ZSBwYXJhbVxuICAgIHwgUmVhZCA6IGRhdGUgcGFyYW1cbiAgICB8IFNpemUgOiBpbnQgcGFyYW1cbiAgICB8IFBhcmFtZXRlciA6IChzdHJpbmcgKiB2YWx1ZSkgcGFyYW1cblxuICB0eXBlIHYgPSBWIDogKCdhIHBhcmFtICogJ2Egb3B0aW9uKSAtPiB2XG5cbiAgbGV0IGRpc3Bvc2l0aW9uX3Bhcm0gOiB2IFByZXR0eW0udCA9XG4gICBmdW4gcHBmIChWIHYpIC0+XG4gICAgbWF0Y2ggdiB3aXRoXG4gICAgfCBGaWxlbmFtZSwgU29tZSB2IC0+XG4gICAgICAgIGV2YWwgcHBmXG4gICAgICAgICAgWyBzdHJpbmcgJCBcImZpbGVuYW1lXCI7IGN1dDsgY2hhciAkICc9JzsgISF0b2tlbjsgY2hhciAkICc7JzsgZndzIF1cbiAgICAgICAgICB2XG4gICAgfCBGaWxlbmFtZSwgTm9uZSAtPiBwcGZcbiAgICB8IENyZWF0aW9uLCBfIC0+IHBwZlxuICAgIHwgTW9kaWZpY2F0aW9uLCBfIC0+IHBwZlxuICAgIHwgUmVhZCwgXyAtPiBwcGZcbiAgICB8IFNpemUsIFNvbWUgdiAtPlxuICAgICAgICBldmFsIHBwZlxuICAgICAgICAgIFsgc3RyaW5nICQgXCJzaXplXCI7IGN1dDsgY2hhciAkICc9JzsgISFzdHJpbmc7IGNoYXIgJCAnOyc7IGZ3cyBdXG4gICAgICAgICAgKHN0cmluZ19vZl9pbnQgdilcbiAgICB8IFNpemUsIE5vbmUgLT4gcHBmXG4gICAgfCBQYXJhbWV0ZXIsIFNvbWUgKGssIHYpIC0+XG4gICAgICAgIGV2YWwgcHBmIFsgISFzdHJpbmc7IGN1dDsgY2hhciAkICc9JzsgISF2YWx1ZTsgY2hhciAkICc7JzsgZndzIF0gayB2XG4gICAgfCBQYXJhbWV0ZXIsIE5vbmUgLT4gcHBmXG5cbiAgbGV0IGRpc3Bvc2l0aW9uIHBwZiB2ID1cbiAgICBsZXQgc2VwIHBwZiAoKSA9IGV2YWwgcHBmIFsgY3V0IF0gaW5cbiAgICBldmFsIHBwZlxuICAgICAgW1xuICAgICAgICAhIWRpc3Bvc2l0aW9uX3R5cGU7XG4gICAgICAgIGN1dDtcbiAgICAgICAgY2hhciAkICc7JztcbiAgICAgICAgZndzO1xuICAgICAgICAhIShsaXN0IH5zZXA6KHNlcCwgKCkpIGRpc3Bvc2l0aW9uX3Bhcm0pO1xuICAgICAgXVxuICAgICAgdi50eVxuICAgICAgKFtcbiAgICAgICAgIFYgKEZpbGVuYW1lLCB2LmZpbGVuYW1lKTtcbiAgICAgICAgIFYgKENyZWF0aW9uLCB2LmNyZWF0aW9uKTtcbiAgICAgICAgIFYgKE1vZGlmaWNhdGlvbiwgdi5tb2RpZmljYXRpb24pO1xuICAgICAgICAgViAoUmVhZCwgdi5yZWFkKTtcbiAgICAgICAgIFYgKFNpemUsIHYuc2l6ZSk7XG4gICAgICAgXVxuICAgICAgQCBMaXN0Lm1hcCAoZnVuIChrLCB2KSAtPiBWIChQYXJhbWV0ZXIsIFNvbWUgKGssIHYpKSkgdi5wYXJhbWV0ZXJzKVxuZW5kXG5cbmxldCB0b19zdHJpbmcgdiA9IFByZXR0eW0udG9fc3RyaW5nIEVuY29kZXIuZGlzcG9zaXRpb24gdlxuIiwidHlwZSB0ID1cbiAgWyBgQml0N1xuICB8IGBCaXQ4XG4gIHwgYEJpbmFyeVxuICB8IGBRdW90ZWRfcHJpbnRhYmxlXG4gIHwgYEJhc2U2NFxuICB8IGBJZXRmX3Rva2VuIG9mIHN0cmluZ1xuICB8IGBYX3Rva2VuIG9mIHN0cmluZyBdXG5cbmxldCBlcnJvcl9tc2dmIGZtdCA9IEZtdC5rc3RyIChmdW4gbXNnIC0+IEVycm9yIChgTXNnIG1zZykpIGZtdFxuXG5sZXQgcHAgcHBmID0gZnVuY3Rpb25cbiAgfCBgQml0NyAtPiBGbXQuc3RyaW5nIHBwZiBcIjdiaXRcIlxuICB8IGBCaXQ4IC0+IEZtdC5zdHJpbmcgcHBmIFwiOGJpdFwiXG4gIHwgYEJpbmFyeSAtPiBGbXQuc3RyaW5nIHBwZiBcImJpbmFyeVwiXG4gIHwgYFF1b3RlZF9wcmludGFibGUgLT4gRm10LnN0cmluZyBwcGYgXCJxdW90ZWQtcHJpbnRhYmxlXCJcbiAgfCBgQmFzZTY0IC0+IEZtdC5zdHJpbmcgcHBmIFwiYmFzZTY0XCJcbiAgfCBgSWV0Zl90b2tlbiB0b2tlbiAtPiBGbXQucGYgcHBmIFwiaWV0Zjolc1wiIHRva2VuXG4gIHwgYFhfdG9rZW4gdG9rZW4gLT4gRm10LnBmIHBwZiBcIng6JXNcIiB0b2tlblxuXG5sZXQgZGVmYXVsdCA9IGBCaXQ3XG5sZXQgYml0OCA9IGBCaXQ4XG5sZXQgYml0NyA9IGBCaXQ3XG5sZXQgYmluYXJ5ID0gYEJpbmFyeVxubGV0IHF1b3RlZF9wcmludGFibGUgPSBgUXVvdGVkX3ByaW50YWJsZVxubGV0IGJhc2U2NCA9IGBCYXNlNjRcblxubGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG4gIHwgXCI3Yml0XCIgLT4gT2sgYEJpdDdcbiAgfCBcIjhiaXRcIiAtPiBPayBgQml0OFxuICB8IFwiYmluYXJ5XCIgLT4gT2sgYEJpbmFyeVxuICB8IFwicXVvdGVkLXByaW50YWJsZVwiIC0+IE9rIGBRdW90ZWRfcHJpbnRhYmxlXG4gIHwgXCJiYXNlNjRcIiAtPiBPayBgQmFzZTY0XG4gIHwgeCAtPiBlcnJvcl9tc2dmIFwiSW52YWxpZCBNSU1FIGVuY29kaW5nOiAlc1wiIHhcblxuKCogVE9ETzpcbiAgIC0gbGV0IHRoZSB1c2VyIHRvIGNyYWZ0IGFuIGV4dGVuc2lvbiB0b2tlbi5cbiAgIC0gY2hlY2sgSUVURiBkYXRhYmFzZSAqKVxuXG5sZXQgZXF1YWwgYSBiID1cbiAgbWF0Y2ggKGEsIGIpIHdpdGhcbiAgfCBgQml0NywgYEJpdDcgLT4gdHJ1ZVxuICB8IGBCaXQ4LCBgQml0OCAtPiB0cnVlXG4gIHwgYEJpbmFyeSwgYEJpbmFyeSAtPiB0cnVlXG4gIHwgYFF1b3RlZF9wcmludGFibGUsIGBRdW90ZWRfcHJpbnRhYmxlIC0+IHRydWVcbiAgfCBgQmFzZTY0LCBgQmFzZTY0IC0+IHRydWVcbiAgfCBgSWV0Zl90b2tlbiBhLCBgSWV0Zl90b2tlbiBiIC0+XG4gICAgICBTdHJpbmcuKGVxdWFsIChsb3dlcmNhc2VfYXNjaWkgYSkgKGxvd2VyY2FzZV9hc2NpaSBiKSlcbiAgfCBgWF90b2tlbiBhLCBgWF90b2tlbiBiIC0+XG4gICAgICBTdHJpbmcuKGVxdWFsIChsb3dlcmNhc2VfYXNjaWkgYSkgKGxvd2VyY2FzZV9hc2NpaSBiKSlcbiAgfCBfLCBfIC0+IGZhbHNlXG5cbm1vZHVsZSBEZWNvZGVyID0gc3RydWN0XG4gIG9wZW4gQW5nc3Ryb21cblxuICBsZXQgaW52YWxpZF90b2tlbiB0b2tlbiA9IEZtdC5rc3RyIGZhaWwgXCJpbnZhbGlkIHRva2VuOiAlc1wiIHRva2VuXG5cbiAgbGV0IG9mX3N0cmluZyBzIGEgPVxuICAgIG1hdGNoIHBhcnNlX3N0cmluZyB+Y29uc3VtZTpDb25zdW1lLkFsbCBhIHMgd2l0aFxuICAgIHwgT2sgdiAtPiBTb21lIHZcbiAgICB8IEVycm9yIF8gLT4gTm9uZVxuXG4gICgqIEZyb20gUkZDIDIwNDVcblxuICAgICAgICAgIHRzcGVjaWFscyA6PSAgXCIoXCIgLyBcIilcIiAvIFwiPFwiIC8gXCI+XCIgLyBcIkBcIiAvXG4gICAgICAgICAgICAgICAgICAgICAgICBcIixcIiAvIFwiO1wiIC8gXCI6XCIgLyBcIlxcXCIgLyA8XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBcIi9cIiAvIFwiW1wiIC8gXCJdXCIgLyBcIj9cIiAvIFwiPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA7IE11c3QgYmUgaW4gcXVvdGVkLXN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDsgdG8gdXNlIHdpdGhpbiBwYXJhbWV0ZXIgdmFsdWVzXG5cbiAgICAgICAgTm90ZSB0aGF0IHRoZSBkZWZpbml0aW9uIG9mIFwidHNwZWNpYWxzXCIgaXMgdGhlIHNhbWUgYXMgdGhlIFJGQyA4MjJcbiAgICAgICAgZGVmaW5pdGlvbiBvZiBcInNwZWNpYWxzXCIgd2l0aCB0aGUgYWRkaXRpb24gb2YgdGhlIHRocmVlIGNoYXJhY3RlcnNcbiAgICAgICAgXCIvXCIsIFwiP1wiLCBhbmQgXCI9XCIsIGFuZCB0aGUgcmVtb3ZhbCBvZiBcIi5cIi5cbiAgKilcbiAgbGV0IGlzX3RzcGVjaWFscyA9IGZ1bmN0aW9uXG4gICAgfCAnKCcgfCAnKScgfCAnPCcgfCAnPicgfCAnQCcgfCAnLCcgfCAnOycgfCAnOicgfCAnXFxcXCcgfCAnXCInIHwgJy8nIHwgJ1snXG4gICAgfCAnXScgfCAnPycgfCAnPScgLT5cbiAgICAgICAgdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuXG4gIGxldCBpc19jdGwgPSBmdW5jdGlvbiAnXFwwMDAnIC4uICdcXDAzMScgfCAnXFwxMjcnIC0+IHRydWUgfCBfIC0+IGZhbHNlXG4gIGxldCBpc19zcGFjZSA9ICggPSApICcgJ1xuXG4gICgqIEZyb20gUkZDIDIwNDVcblxuICAgICAgICAgIHRva2VuIDo9IDEqPGFueSAoVVMtQVNDSUkpIENIQVIgZXhjZXB0IFNQQUNFLCBDVExzLFxuICAgICAgICAgICAgICAgICAgICAgIG9yIHRzcGVjaWFscz5cbiAgKilcbiAgbGV0IGlzX2FzY2lpID0gZnVuY3Rpb24gJ1xcMDAwJyAuLiAnXFwxMjcnIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IGlzX3Rva2VuIGMgPVxuICAgIGlzX2FzY2lpIGMgJiYgKG5vdCAoaXNfdHNwZWNpYWxzIGMpKSAmJiAobm90IChpc19jdGwgYykpICYmIG5vdCAoaXNfc3BhY2UgYylcblxuICBsZXQgdG9rZW4gPSB0YWtlX3doaWxlMSBpc190b2tlblxuXG4gICgqIEZyb20gUkZDIDIwNDVcblxuICAgICAgICAgIGlldGYtdG9rZW4gOj0gPEFuIGV4dGVuc2lvbiB0b2tlbiBkZWZpbmVkIGJ5IGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZHMtdHJhY2sgUkZDIGFuZCByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBJQU5BLj5cblxuICAgICBYWFgoZGlub3NhdXJlKTogd2UgZG9uJ3QgY2hlY2sgYXQgdGhpcyB0aW1lIGlmIElFVEYgdG9rZW4gZXhpc3RzLlxuICAqKVxuICBsZXQgaWV0Zl90b2tlbiA9IHRva2VuXG5cbiAgKCogRnJvbSBSRkMgMjA0NVxuXG4gICAgICAgICAgeC10b2tlbiA6PSA8VGhlIHR3byBjaGFyYWN0ZXJzIFwiWC1cIiBvciBcIngtXCIgZm9sbG93ZWQsIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICBubyBpbnRlcnZlbmluZyB3aGl0ZSBzcGFjZSwgYnkgYW55IHRva2VuPlxuICAqKVxuICBsZXQgeF90b2tlbiA9XG4gICAgc2F0aXNmeSAoZnVuY3Rpb24gJ3gnIHwgJ1gnIC0+IHRydWUgfCBfIC0+IGZhbHNlKSAqPiBjaGFyICctJyAqPiB0b2tlblxuXG4gICgqIEZyb20gUkZDIDIwNDVcblxuICAgICAgICAgIGV4dGVuc2lvbi10b2tlbiA6PSBpZXRmLXRva2VuIC8geC10b2tlblxuICAqKVxuICBsZXQgZXh0ZW5zaW9uX3Rva2VuID1cbiAgICBwZWVrX2NoYXIgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lICdYJyB8IFNvbWUgJ3gnIC0+IHhfdG9rZW4gPj58IGZ1biB2IC0+IGBYX3Rva2VuIHZcbiAgICB8IF8gLT4gaWV0Zl90b2tlbiA+PnwgZnVuIHYgLT4gYElldGZfdG9rZW4gdlxuXG4gIGxldCBpc193c3AgPSBmdW5jdGlvbiAnICcgfCAnXFx0JyAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICgqIEZyb20gUkZDIDIwNDVcblxuICAgICAgICAgIG1lY2hhbmlzbSA6PSBcIjdiaXRcIiAvIFwiOGJpdFwiIC8gXCJiaW5hcnlcIiAvXG4gICAgICAgICAgICAgICAgICAgICAgIFwicXVvdGVkLXByaW50YWJsZVwiIC8gXCJiYXNlNjRcIiAvXG4gICAgICAgICAgICAgICAgICAgICAgIGlldGYtdG9rZW4gLyB4LXRva2VuXG5cbiAgICAgICAgVGhlc2UgdmFsdWVzIGFyZSBub3QgY2FzZSBzZW5zaXRpdmUgLS0gQmFzZTY0IGFuZCBCQVNFNjQgYW5kIGJBc0U2NFxuICAgICAgICBhcmUgYWxsIGVxdWl2YWxlbnQuICBBbiBlbmNvZGluZyB0eXBlIG9mIDdCSVQgcmVxdWlyZXMgdGhhdCB0aGUgYm9keVxuICAgICAgICBpcyBhbHJlYWR5IGluIGEgN2JpdCBtYWlsLXJlYWR5IHJlcHJlc2VudGF0aW9uLiAgVGhpcyBpcyB0aGUgZGVmYXVsdFxuICAgICAgICB2YWx1ZSAtLSB0aGF0IGlzLCBcIkNvbnRlbnQtVHJhbnNmZXItRW5jb2Rpbmc6IDdCSVRcIiBpcyBhc3N1bWVkIGlmIHRoZVxuICAgICAgICBDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nIGhlYWRlciBmaWVsZCBpcyBub3QgcHJlc2VudC5cbiAgKilcbiAgbGV0IG1lY2hhbmlzbSA9XG4gICAgc2tpcF93aGlsZSBpc193c3AgKj4gdG9rZW4gPCogc2tpcF93aGlsZSBpc193c3AgPj49IGZ1biBzIC0+XG4gICAgKCogWFhYKGRpbm9zYXVyZSk6IGxvd2VyY2FzZV8qYXNjaWkqIGlzIGZpbmUsIG5vdCB1dGY4IGluIHRoaXMgcGFydC4gKilcbiAgICBtYXRjaCBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgd2l0aFxuICAgIHwgXCI3Yml0XCIgLT4gcmV0dXJuIGBCaXQ3XG4gICAgfCBcIjhiaXRcIiAtPiByZXR1cm4gYEJpdDhcbiAgICB8IFwiYmluYXJ5XCIgLT4gcmV0dXJuIGBCaW5hcnlcbiAgICB8IFwicXVvdGVkLXByaW50YWJsZVwiIC0+IHJldHVybiBgUXVvdGVkX3ByaW50YWJsZVxuICAgIHwgXCJiYXNlNjRcIiAtPiByZXR1cm4gYEJhc2U2NFxuICAgIHwgXyAtPlxuICAgIG1hdGNoIG9mX3N0cmluZyBzIGV4dGVuc2lvbl90b2tlbiB3aXRoXG4gICAgfCBTb21lIHYgLT4gcmV0dXJuIHZcbiAgICB8IE5vbmUgLT4gaW52YWxpZF90b2tlbiBzXG5lbmRcblxubW9kdWxlIEVuY29kZXIgPSBzdHJ1Y3RcbiAgb3BlbiBQcmV0dHltXG5cbiAgbGV0IG1lY2hhbmlzbSBwcGYgPSBmdW5jdGlvblxuICAgIHwgYEJpdDcgLT4gc3RyaW5nIHBwZiBcIjdiaXRcIlxuICAgIHwgYEJpdDggLT4gc3RyaW5nIHBwZiBcIjhiaXRcIlxuICAgIHwgYEJpbmFyeSAtPiBzdHJpbmcgcHBmIFwiYmluYXJ5XCJcbiAgICB8IGBRdW90ZWRfcHJpbnRhYmxlIC0+IHN0cmluZyBwcGYgXCJxdW90ZWQtcHJpbnRhYmxlXCJcbiAgICB8IGBCYXNlNjQgLT4gc3RyaW5nIHBwZiBcImJhc2U2NFwiXG4gICAgfCBgSWV0Zl90b2tlbiB4IC0+IHN0cmluZyBwcGYgeFxuICAgIHwgYFhfdG9rZW4geCAtPiBldmFsIHBwZiBbIHN0cmluZyAkIFwiWC1cIjsgISFzdHJpbmcgXSB4XG5lbmRcblxubGV0IHRvX3N0cmluZyB2ID0gUHJldHR5bS50b19zdHJpbmcgRW5jb2Rlci5tZWNoYW5pc20gdlxuIiwidHlwZSB0ID0gc3RyaW5nXG5cbmxldCBlcnJvcl9tc2dmIGZtdCA9IEZtdC5rc3RyIChmdW4gbXNnIC0+IEVycm9yIChgTXNnIG1zZykpIGZtdFxuXG5sZXQgY29tcGFyZSBhIGIgPVxuICBsZXQgYSA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgYSBpblxuICBsZXQgYiA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgYiBpblxuICBTdHJpbmcuY29tcGFyZSBhIGJcblxubGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuXG5sZXQgY2FwaXRhbGl6ZSB4ID1cbiAgbGV0IGNhcGl0YWxpemUgcmVzIGlkeCA9XG4gICAgbGV0IG1hcCA9IGZ1bmN0aW9uXG4gICAgICB8ICdhJyAuLiAneicgYXMgY2hyIC0+IENoYXIudW5zYWZlX2NociAoQ2hhci5jb2RlIGNociAtIDMyKVxuICAgICAgfCBjaHIgLT4gY2hyIGluXG4gICAgQnl0ZXMuc2V0IHJlcyBpZHggKG1hcCAoQnl0ZXMuZ2V0IHJlcyBpZHgpKSBpblxuICBsZXQgaXNfZGFzaF9vcl9zcGFjZSA9IGZ1bmN0aW9uICcgJyB8ICctJyAtPiB0cnVlIHwgXyAtPiBmYWxzZSBpblxuICBsZXQgcmVzID0gQnl0ZXMub2Zfc3RyaW5nIHggaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggeCAtIDEgZG9cbiAgICBpZiBpID4gMCAmJiBpc19kYXNoX29yX3NwYWNlIHguW2kgLSAxXVxuICAgIHRoZW4gY2FwaXRhbGl6ZSByZXMgaVxuICAgIGVsc2UgaWYgaSA9IDBcbiAgICB0aGVuIGNhcGl0YWxpemUgcmVzIGlcbiAgZG9uZSA7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbmxldCBjYW5vbmljYWxpemUgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpXG5cbmV4Y2VwdGlvbiBCcmVha1xuXG5sZXQgaXNfZnRleHQgPSBmdW5jdGlvblxuICB8ICdcXDAzMycgLi4gJ1xcMDU3JyB8ICdcXDA1OScgLi4gJ1xcMTI2JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgb2Zfc3RyaW5nIHggPVxuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCB4IC0gMSBkb1xuICAgICAgaWYgbm90IChpc19mdGV4dCB4LltpXSkgdGhlbiByYWlzZSBCcmVha1xuICAgIGRvbmUgO1xuICAgIE9rIHhcbiAgd2l0aCBCcmVhayAtPiBlcnJvcl9tc2dmIFwiSW52YWxpZCBmaWVsZDogJVNcIiB4XG5cbmxldCBvZl9zdHJpbmdfZXhuIHggPVxuICBtYXRjaCBvZl9zdHJpbmcgeCB3aXRoXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3IgKGBNc2cgZXJyKSAtPiBGbXQuaW52YWxpZF9hcmcgXCIlc1wiIGVyclxuXG5sZXQgdiA9IG9mX3N0cmluZ19leG5cbmxldCBwcCA9IEZtdC51c2luZyBjYXBpdGFsaXplIEZtdC5zdHJpbmdcblxubGV0IHByZWZpeGVkX2J5IHByZWZpeCBmaWVsZCA9XG4gIGlmIFN0cmluZy5jb250YWlucyBwcmVmaXggJy0nXG4gIHRoZW4gRm10LmludmFsaWRfYXJnIFwiRmllbGQucHJlZml4ZWRfYnk6ICVzIGNvbnRhaW5zICctJ1wiIHByZWZpeCA7XG4gIG1hdGNoIFN0cmluZy4oc3BsaXRfb25fY2hhciAnLScgKGxvd2VyY2FzZV9hc2NpaSBmaWVsZCkpIHdpdGhcbiAgfCBbXSAtPiBhc3NlcnQgZmFsc2UgKCogWFhYKGRpbm9zYXVyZSk6IHNlZSBpbnZhcmlhbnRzIG9mIFtzcGxpdF9vbl9jaGFyXS4gKilcbiAgfCBbIF8gXSAtPiBmYWxzZVxuICB8IHggOjogXyAtPiBTdHJpbmcuKGVxdWFsIHggKGxvd2VyY2FzZV9hc2NpaSBwcmVmaXgpKVxuXG5tb2R1bGUgRGVjb2RlciA9IHN0cnVjdFxuICBvcGVuIEFuZ3N0cm9tXG5cbiAgbGV0IGZpZWxkX25hbWUgPSB0YWtlX3doaWxlMSBpc19mdGV4dFxuZW5kXG5cbm1vZHVsZSBFbmNvZGVyID0gc3RydWN0XG4gIG9wZW4gUHJldHR5bVxuXG4gIGxldCBmaWVsZF9uYW1lID0gdXNpbmcgY2FwaXRhbGl6ZSBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgTWFwID0gTWFwLk1ha2UgKFN0cmluZylcbm1vZHVsZSBTZXQgPSBTZXQuTWFrZSAoU3RyaW5nKVxuXG5sZXQgY29udGVudF90eXBlID0gXCJDb250ZW50LVR5cGVcIlxubGV0IGNvbnRlbnRfdHJhbnNmZXJfZW5jb2RpbmcgPSBcIkNvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmdcIlxubGV0IGNvbnRlbnRfZGlzcG9zaXRpb24gPSBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIlxuIiwidHlwZSAnYSB0ID1cbiAgfCBDb250ZW50X3R5cGUgOiBDb250ZW50X3R5cGUudCB0XG4gIHwgQ29udGVudF9lbmNvZGluZyA6IENvbnRlbnRfZW5jb2RpbmcudCB0XG4gIHwgQ29udGVudF9kaXNwb3NpdGlvbiA6IENvbnRlbnRfZGlzcG9zaXRpb24udCB0XG4gIHwgRmllbGQgOiBVbnN0cmN0cmQudCB0XG5cbnR5cGUgd2l0bmVzcyA9IFdpdG5lc3MgOiAnYSB0IC0+IHdpdG5lc3NcbnR5cGUgZmllbGQgPSBGaWVsZCA6IEZpZWxkX25hbWUudCAqICdhIHQgKiAnYSAtPiBmaWVsZFxuXG5sZXQgcHBfdW5zdHJjdHJkIHBwZiB2ID0gRm10LnN0cmluZyBwcGYgKFVuc3RyY3RyZC50b191dGZfOF9zdHJpbmcgdilcblxubGV0IHBwIHBwZiAoRmllbGQgKGZpZWxkX25hbWUsIHcsIHYpKSA9XG4gIGxldCBvZl93aXRuZXNzIDogdHlwZSBhLiBhIHQgLT4gYSBGbXQudCA9IGZ1bmN0aW9uXG4gICAgfCBDb250ZW50X3R5cGUgLT4gQ29udGVudF90eXBlLnBwXG4gICAgfCBDb250ZW50X2VuY29kaW5nIC0+IENvbnRlbnRfZW5jb2RpbmcucHBcbiAgICB8IENvbnRlbnRfZGlzcG9zaXRpb24gLT4gQ29udGVudF9kaXNwb3NpdGlvbi5wcFxuICAgIHwgRmllbGQgLT4gcHBfdW5zdHJjdHJkIGluXG4gIGxldCBpc191bnN0cnVjdHVyZWQgPSBtYXRjaCB3IHdpdGggRmllbGQgLT4gdHJ1ZSB8IF8gLT4gZmFsc2UgaW5cbiAgRm10LnBmIHBwZiBcIiVhWyVjXTogQFs8aG92PiVhQF1cIiBGaWVsZF9uYW1lLnBwIGZpZWxkX25hbWVcbiAgICAoaWYgaXNfdW5zdHJ1Y3R1cmVkIHRoZW4gJyEnIGVsc2UgJyonKVxuICAgIChvZl93aXRuZXNzIHcpIHZcblxubGV0ICggPC4+ICkgZiBnIHggPSBmIChnIHgpXG5cbmxldCBvZl9maWVsZF9uYW1lIDogRmllbGRfbmFtZS50IC0+IHdpdG5lc3MgPVxuIGZ1biBmaWVsZF9uYW1lIC0+XG4gIG1hdGNoIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgKGZpZWxkX25hbWUgOj4gc3RyaW5nKSB3aXRoXG4gIHwgXCJjb250ZW50LXR5cGVcIiAtPiBXaXRuZXNzIENvbnRlbnRfdHlwZVxuICB8IFwiY29udGVudC10cmFuc2Zlci1lbmNvZGluZ1wiIC0+IFdpdG5lc3MgQ29udGVudF9lbmNvZGluZ1xuICB8IFwiY29udGVudC1kaXNwb3NpdGlvblwiIC0+IFdpdG5lc3MgQ29udGVudF9kaXNwb3NpdGlvblxuICB8IF8gLT4gV2l0bmVzcyBGaWVsZFxuXG5sZXQgcGFyc2VyIDogdHlwZSBhLiBhIHQgLT4gYSBBbmdzdHJvbS50ID0gZnVuY3Rpb25cbiAgfCBDb250ZW50X3R5cGUgLT4gQ29udGVudF90eXBlLkRlY29kZXIuY29udGVudFxuICB8IENvbnRlbnRfZW5jb2RpbmcgLT4gQ29udGVudF9lbmNvZGluZy5EZWNvZGVyLm1lY2hhbmlzbVxuICB8IENvbnRlbnRfZGlzcG9zaXRpb24gLT4gQ29udGVudF9kaXNwb3NpdGlvbi5EZWNvZGVyLmRpc3Bvc2l0aW9uXG4gIHwgRmllbGQgLT5cbiAgICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgMHg3ZiBpblxuICAgICAgVW5zdHJjdHJkX3BhcnNlci51bnN0cmN0cmQgYnVmXG5cbm1vZHVsZSBEZWNvZGVyID0gc3RydWN0XG4gIG9wZW4gQW5nc3Ryb21cblxuICBsZXQgZmllbGQgP2cgZmllbGRfbmFtZSA9XG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAweDdmIGluXG4gICAgKCogWFhYKGRpbm9zYXVyZSk6IGZhc3QgYWxsb2NhdGlvbi4gKilcbiAgICBVbnN0cmN0cmRfcGFyc2VyLnVuc3RyY3RyZCBidWYgPj49IGZ1biB2IC0+XG4gICAgbGV0IChXaXRuZXNzIHcpID1cbiAgICAgIG1hdGNoIE9wdGlvbi5iaW5kIGcgKEZpZWxkX25hbWUuTWFwLmZpbmRfb3B0IGZpZWxkX25hbWUpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBvZl9maWVsZF9uYW1lIGZpZWxkX25hbWVcbiAgICAgIHwgU29tZSB3IC0+IHcgaW5cbiAgICBsZXQgcGFyc2VyID0gcGFyc2VyIHcgaW5cbiAgICBsZXQgcmVzID1cbiAgICAgIGxldCAoID4+PSApID0gUmVzdWx0LmJpbmQgYW5kICggPj58ICkgeCBmID0gUmVzdWx0Lm1hcCBmIHggaW5cbiAgICAgIFVuc3RyY3RyZC53aXRob3V0X2NvbW1lbnRzIHZcbiAgICAgID4+fCBVbnN0cmN0cmQuZm9sZF9md3NcbiAgICAgID4+fCBVbnN0cmN0cmQudG9fdXRmXzhfc3RyaW5nXG4gICAgICAoKiBYWFgoZGlub3NhdXJlKTogbm9ybWFsaXplZCB2YWx1ZSBjYW4gaGF2ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgKiBzdWNoIGFzIFwidmFsdWUgKGNvbW1lbnQpXCIgcmV0dXJucyBcInZhbHVlIFwiLiBHaXZlbiBwYXJzZXIgY2FuXG4gICAgICAgKiBpZ25vcmUgaXQgKGFuZCBpdCBkb2VzIG5vdCBjb25zdW1lIGFsbCBpbnB1dHMgZmluYWxseSkuICopXG4gICAgICA+Pj0gKFJlc3VsdC5tYXBfZXJyb3IgKGZ1biBtc2cgLT4gYE1zZyBtc2cpXG4gICAgICAgICAgPC4+IChwYXJzZV9zdHJpbmcgfmNvbnN1bWU6Q29uc3VtZS5QcmVmaXgpIHBhcnNlcilcbiAgICAgID4+fCBmdW4gdiAtPiBGaWVsZCAoZmllbGRfbmFtZSwgdywgdikgaW5cbiAgICBtYXRjaCByZXMgd2l0aFxuICAgIHwgT2sgdiAtPiByZXR1cm4gdlxuICAgIHwgRXJyb3IgXyAtPiByZXR1cm4gKEZpZWxkIChmaWVsZF9uYW1lLCBGaWVsZCwgdikpXG5lbmRcblxubGV0IGVuY29kZXIgOiB0eXBlIGEuIGEgdCAtPiBhIFByZXR0eW0udCA9IGZ1bmN0aW9uXG4gIHwgQ29udGVudF90eXBlIC0+IENvbnRlbnRfdHlwZS5FbmNvZGVyLmNvbnRlbnRfdHlwZVxuICB8IENvbnRlbnRfZW5jb2RpbmcgLT4gQ29udGVudF9lbmNvZGluZy5FbmNvZGVyLm1lY2hhbmlzbVxuICB8IENvbnRlbnRfZGlzcG9zaXRpb24gLT4gQ29udGVudF9kaXNwb3NpdGlvbi5FbmNvZGVyLmRpc3Bvc2l0aW9uXG4gIHwgRmllbGQgLT4gYXNzZXJ0IGZhbHNlXG5cbigqIFRPRE8gKilcblxubW9kdWxlIEVuY29kZXIgPSBzdHJ1Y3RcbiAgb3BlbiBQcmV0dHltXG5cbiAgbGV0IGZpZWxkIHBwZiBmaWVsZCA9XG4gICAgbGV0IChGaWVsZCAoZmllbGRfbmFtZSwgdywgdikpID0gZmllbGQgaW5cbiAgICBsZXQgZSA9IGVuY29kZXIgdyBpblxuICAgIGV2YWwgcHBmXG4gICAgICBbXG4gICAgICAgIHRib3ggMTtcbiAgICAgICAgISFGaWVsZF9uYW1lLkVuY29kZXIuZmllbGRfbmFtZTtcbiAgICAgICAgc3RyaW5nICQgXCI6XCI7XG4gICAgICAgIHNwYWNlcyAxO1xuICAgICAgICAhIWU7XG4gICAgICAgIGNsb3NlO1xuICAgICAgICBuZXdfbGluZTtcbiAgICAgIF1cbiAgICAgIGZpZWxkX25hbWUgdlxuZW5kXG4iLCJ0eXBlIHQgPSBGaWVsZC5maWVsZCBsaXN0XG5cbmxldCBwcCA9IEZtdC4obGlzdCB+c2VwOihhbnkgXCJAXFxuXCIpIEZpZWxkLnBwKVxuXG5sZXQgYXNzb2MgZmllbGRfbmFtZSBoZWFkZXIgPVxuICBsZXQgZiBhY2MgKEZpZWxkLkZpZWxkIChmaWVsZF9uYW1lJywgXywgXykgYXMgZmllbGQpID1cbiAgICBpZiBGaWVsZF9uYW1lLmVxdWFsIGZpZWxkX25hbWUgZmllbGRfbmFtZScgdGhlbiBmaWVsZCA6OiBhY2MgZWxzZSBhY2MgaW5cbiAgTGlzdC5mb2xkX2xlZnQgZiBbXSBoZWFkZXIgfD4gTGlzdC5yZXZcblxubGV0IHJlbW92ZV9hc3NvYyBmaWVsZF9uYW1lIGhlYWRlciA9XG4gIGxldCBmIGFjYyB4ID1cbiAgICBsZXQgKEZpZWxkLkZpZWxkIChmaWVsZF9uYW1lJywgXywgXykpID0geCBpblxuICAgIGlmIEZpZWxkX25hbWUuZXF1YWwgZmllbGRfbmFtZSBmaWVsZF9uYW1lJyB0aGVuIGFjYyBlbHNlIHggOjogYWNjIGluXG4gIExpc3QuZm9sZF9sZWZ0IGYgW10gaGVhZGVyIHw+IExpc3QucmV2XG5cbmxldCBleGlzdHMgZmllbGRfbmFtZSB0ID1cbiAgTGlzdC5leGlzdHNcbiAgICAoZnVuIChGaWVsZC5GaWVsZCAoZmllbGRfbmFtZScsIF8sIF8pKSAtPlxuICAgICAgRmllbGRfbmFtZS5lcXVhbCBmaWVsZF9uYW1lIGZpZWxkX25hbWUnKVxuICAgIHRcblxubGV0IGVtcHR5ID0gW11cbmxldCBjb25jYXQgYSBiID0gYSBAIGJcbmxldCB0b19saXN0IHggPSB4XG5cbmxldCBhZGQgOiB0eXBlIGEuIEZpZWxkX25hbWUudCAtPiBhIEZpZWxkLnQgKiBhIC0+IHQgLT4gdCA9XG4gZnVuIGZpZWxkX25hbWUgKHcsIHYpIHQgLT5cbiAgbGV0IGZpZWxkID0gRmllbGQuRmllbGQgKGZpZWxkX25hbWUsIHcsIHYpIGluXG4gIGZpZWxkIDo6IHRcblxubGV0IHJlcGxhY2UgOiB0eXBlIGEuIEZpZWxkX25hbWUudCAtPiBhIEZpZWxkLnQgKiBhIC0+IHQgLT4gdCA9XG4gZnVuIGZpZWxkX25hbWUgKHcsIHYpIHQgLT5cbiAgbGV0IGhlYWRlciA9IHJlbW92ZV9hc3NvYyBmaWVsZF9uYW1lIHQgaW5cbiAgbGV0IGZpZWxkID0gRmllbGQuRmllbGQgKGZpZWxkX25hbWUsIHcsIHYpIGluXG4gIGZpZWxkIDo6IGhlYWRlclxuXG5sZXQgb2ZfbGlzdCB4ID0geFxubGV0IG9mX2xpc3Rfd2l0aF9sb2NhdGlvbiB4ID0geFxuXG5sZXQgY29udGVudF90eXBlIGhlYWRlciA9XG4gIGxldCBjb250ZW50IDogQ29udGVudF90eXBlLnQgcmVmID0gcmVmIENvbnRlbnRfdHlwZS5kZWZhdWx0IGluXG4gIExpc3QuaXRlclxuICAgIChmdW5jdGlvblxuICAgICAgfCBGaWVsZC5GaWVsZCAoZmllbGRfbmFtZSwgRmllbGQuQ29udGVudF90eXBlLCB2KSAtPlxuICAgICAgICAgIGlmIEZpZWxkX25hbWUuZXF1YWwgZmllbGRfbmFtZSBGaWVsZF9uYW1lLmNvbnRlbnRfdHlwZVxuICAgICAgICAgIHRoZW4gY29udGVudCA6PSB2XG4gICAgICB8IF8gLT4gKCkpXG4gICAgaGVhZGVyIDtcbiAgIWNvbnRlbnRcblxubGV0IGNvbnRlbnRfZW5jb2RpbmcgaGVhZGVyID1cbiAgbGV0IG1lY2hhbmlzbSA6IENvbnRlbnRfZW5jb2RpbmcudCByZWYgPSByZWYgQ29udGVudF9lbmNvZGluZy5kZWZhdWx0IGluXG4gIExpc3QuaXRlclxuICAgIChmdW5jdGlvblxuICAgICAgfCBGaWVsZC5GaWVsZCAoZmllbGRfbmFtZSwgRmllbGQuQ29udGVudF9lbmNvZGluZywgdikgLT5cbiAgICAgICAgICBpZiBGaWVsZF9uYW1lLmVxdWFsIGZpZWxkX25hbWUgRmllbGRfbmFtZS5jb250ZW50X3RyYW5zZmVyX2VuY29kaW5nXG4gICAgICAgICAgdGhlbiBtZWNoYW5pc20gOj0gdlxuICAgICAgfCBfIC0+ICgpKVxuICAgIGhlYWRlciA7XG4gICFtZWNoYW5pc21cblxubGV0IGNvbnRlbnRfZGlzcG9zaXRpb24gaGVhZGVyID1cbiAgbGV0IGRpc3Bvc2l0aW9uIDogQ29udGVudF9kaXNwb3NpdGlvbi50IG9wdGlvbiByZWYgPSByZWYgTm9uZSBpblxuICBMaXN0Lml0ZXJcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRmllbGQuRmllbGQgKGZpZWxkX25hbWUsIEZpZWxkLkNvbnRlbnRfZGlzcG9zaXRpb24sIHYpIC0+XG4gICAgICAgICAgaWYgRmllbGRfbmFtZS5lcXVhbCBmaWVsZF9uYW1lIEZpZWxkX25hbWUuY29udGVudF9kaXNwb3NpdGlvblxuICAgICAgICAgIHRoZW4gZGlzcG9zaXRpb24gOj0gU29tZSB2XG4gICAgICB8IF8gLT4gKCkpXG4gICAgaGVhZGVyIDtcbiAgIWRpc3Bvc2l0aW9uXG5cbm1vZHVsZSBEZWNvZGVyID0gc3RydWN0XG4gIG9wZW4gQW5nc3Ryb21cblxuICBsZXQgaXNfd3NwID0gZnVuY3Rpb24gJyAnIHwgJ1xcdCcgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICBsZXQgZmllbGQgPVxuICAgIEZpZWxkX25hbWUuRGVjb2Rlci5maWVsZF9uYW1lID4+PSBmdW4gZmllbGRfbmFtZSAtPlxuICAgIHNraXBfd2hpbGUgaXNfd3NwICo+IGNoYXIgJzonICo+IEZpZWxkLkRlY29kZXIuZmllbGQgZmllbGRfbmFtZVxuXG4gIGxldCBoZWFkZXIgPSBtYW55IGZpZWxkXG5lbmRcblxubW9kdWxlIEVuY29kZXIgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmV0dHltXG5cbiAgbGV0IG5vb3AgPSAoKGZ1biBwcGYgKCkgLT4gcHBmKSwgKCkpXG4gIGxldCBmaWVsZCBwcGYgeCA9IEZpZWxkLkVuY29kZXIuZmllbGQgcHBmIHhcbiAgbGV0IGhlYWRlciBwcGYgeCA9IChsaXN0IH5zZXA6bm9vcCBmaWVsZCkgcHBmIHhcbmVuZFxuIiwib3BlbiBBbmdzdHJvbVxuXG4oKiBGcm9tIFJGQyAyMDQ2XG5cbiAgICAgYmNoYXJzbm9zcGFjZSA6PSBESUdJVCAvIEFMUEhBIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiIC9cbiAgICAgICAgICAgICAgICAgICAgICBcIitcIiAvIFwiX1wiIC8gXCIsXCIgLyBcIi1cIiAvIFwiLlwiIC9cbiAgICAgICAgICAgICAgICAgICAgICBcIi9cIiAvIFwiOlwiIC8gXCI9XCIgLyBcIj9cIlxuKilcbmxldCBpc19iY2hhcnNub3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnXFwnJyB8ICcoJyB8ICcpJyB8ICcrJyB8ICdfJyB8ICcsJyB8ICctJyB8ICcuJyB8ICcvJyB8ICc6JyB8ICc9JyB8ICc/JyAtPlxuICAgICAgdHJ1ZVxuICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIC0+IHRydWVcbiAgfCAnMCcgLi4gJzknIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbigqIEZyb20gUkZDIDIwNDZcblxuICAgICBiY2hhcnMgOj0gYmNoYXJzbm9zcGFjZSAvIFwiIFwiXG4qKVxubGV0IGlzX2JjaGFycyA9IGZ1bmN0aW9uICcgJyAtPiB0cnVlIHwgYyAtPiBpc19iY2hhcnNub3NwYWNlIGNcblxuKCogRnJvbSBSRkMgMjA0NlxuXG4gICAgIGRhc2gtYm91bmRhcnkgOj0gXCItLVwiIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgOyBib3VuZGFyeSB0YWtlbiBmcm9tIHRoZSB2YWx1ZSBvZlxuICAgICAgICAgICAgICAgICAgICAgIDsgYm91bmRhcnkgcGFyYW1ldGVyIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIDsgQ29udGVudC1UeXBlIGZpZWxkLlxuKilcbmxldCBtYWtlX2Rhc2hfYm91bmRhcnkgYm91bmRhcnkgPSBcIi0tXCIgXiBib3VuZGFyeVxubGV0IGRhc2hfYm91bmRhcnkgYm91bmRhcnkgPSBzdHJpbmcgKG1ha2VfZGFzaF9ib3VuZGFyeSBib3VuZGFyeSlcbmxldCBtYWtlX2RlbGltaXRlciBib3VuZGFyeSA9IFwiXFxyXFxuXCIgXiBtYWtlX2Rhc2hfYm91bmRhcnkgYm91bmRhcnlcbmxldCBtYWtlX2Nsb3NlX2RlbGltaXRlciBib3VuZGFyeSA9IG1ha2VfZGVsaW1pdGVyIGJvdW5kYXJ5IF4gXCItLVwiXG5sZXQgY2xvc2VfZGVsaW1pdGVyIGJvdW5kYXJ5ID0gc3RyaW5nIChtYWtlX2Nsb3NlX2RlbGltaXRlciBib3VuZGFyeSlcblxuKCogTk9URTogdGhpcyBwYXJzZXIgdGVybWluYXRlIGF0IHRoZSBib3VuZGFyeSwgaG93ZXZlciBpdCBkb2VzIG5vdCBjb25zdW1lIGl0LiAqKVxubGV0IGRpc2NhcmRfYWxsX3RvX2Rhc2hfYm91bmRhcnkgYm91bmRhcnkgPVxuICBsZXQgY2hlY2tfYm91bmRhcnkgPVxuICAgIGxldCBkYXNoX2JvdW5kYXJ5ID0gbWFrZV9kYXNoX2JvdW5kYXJ5IGJvdW5kYXJ5IGluXG4gICAgbGV0IGV4cGVjdGVkX2xlbiA9IFN0cmluZy5sZW5ndGggZGFzaF9ib3VuZGFyeSBpblxuICAgIFVuc2FmZS5wZWVrIGV4cGVjdGVkX2xlbiAoZnVuIGJhIH5vZmYgfmxlbiAtPlxuICAgICAgICBsZXQgcmF3ID0gQmlnc3RyaW5nYWYuc3Vic3RyaW5nIGJhIH5vZmYgfmxlbiBpblxuICAgICAgICBTdHJpbmcuZXF1YWwgcmF3IGRhc2hfYm91bmRhcnkpIGluXG4gIGZpeCBAQCBmdW4gbSAtPlxuICBza2lwX3doaWxlICgoIDw+ICkgJy0nKSAqPiBwZWVrX2NoYXIgPj49IGZ1bmN0aW9uXG4gIHwgU29tZSAnLScgLT4gKFxuICAgICAgY2hlY2tfYm91bmRhcnkgPj49IGZ1bmN0aW9uIHRydWUgLT4gcmV0dXJuICgpIHwgZmFsc2UgLT4gYWR2YW5jZSAxICo+IG0pXG4gIHwgU29tZSBfIC0+IGFkdmFuY2UgMSAqPiBtICgqIGltcG9zc2libGUgY2FzZT8gKilcbiAgfCBOb25lIC0+IHJldHVybiAoKVxuXG4oKiBGcm9tIFJGQyAyMDQ2XG5cbiAgICAgdHJhbnNwb3J0LXBhZGRpbmcgOj0gKkxXU1AtY2hhclxuICAgICAgICAgICAgICAgICAgICAgICAgICA7IENvbXBvc2VycyBNVVNUIE5PVCBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICA7IG5vbi16ZXJvIGxlbmd0aCB0cmFuc3BvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOyBwYWRkaW5nLCBidXQgcmVjZWl2ZXJzIE1VU1RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOyBiZSBhYmxlIHRvIGhhbmRsZSBwYWRkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDsgYWRkZWQgYnkgbWVzc2FnZSB0cmFuc3BvcnRzLlxuKilcbmxldCB0cmFuc3BvcnRfcGFkZGluZyA9XG4gIHNraXBfd2hpbGUgKGZ1bmN0aW9uICdcXHgwOScgfCAnXFx4MjAnIC0+IHRydWUgfCBfIC0+IGZhbHNlKVxuXG5sZXQgZGlzY2FyZF9hbGxfdG9fZGVsaW1pdGVyIGJvdW5kYXJ5ID1cbiAgbGV0IGNoZWNrX2RlbGltaXRlciA9XG4gICAgbGV0IGRlbGltaXRlciA9IG1ha2VfZGVsaW1pdGVyIGJvdW5kYXJ5IGluXG4gICAgbGV0IGV4cGVjdGVkX2xlbiA9IFN0cmluZy5sZW5ndGggZGVsaW1pdGVyIGluXG4gICAgVW5zYWZlLnBlZWsgZXhwZWN0ZWRfbGVuIChmdW4gYmEgfm9mZiB+bGVuIC0+XG4gICAgICAgIGxldCByYXcgPSBCaWdzdHJpbmdhZi5zdWJzdHJpbmcgYmEgfm9mZiB+bGVuIGluXG4gICAgICAgIFN0cmluZy5lcXVhbCByYXcgZGVsaW1pdGVyKSBpblxuICBmaXggQEAgZnVuIG0gLT5cbiAgc2tpcF93aGlsZSAoKCA8PiApICdcXHInKSAqPiBwZWVrX2NoYXIgPj49IGZ1bmN0aW9uXG4gIHwgU29tZSAnXFxyJyAtPiAoXG4gICAgICBjaGVja19kZWxpbWl0ZXIgPj49IGZ1bmN0aW9uIHRydWUgLT4gcmV0dXJuICgpIHwgZmFsc2UgLT4gYWR2YW5jZSAxICo+IG0pXG4gIHwgU29tZSBfIC0+IGFkdmFuY2UgMSAqPiBtICgqIGltcG9zc2libGUgY2FzZT8gKilcbiAgfCBOb25lIC0+IHJldHVybiAoKVxuXG5sZXQgbm90aGluZ190b19kbyA9IEZtdC5rc3RyIGZhaWwgXCJub3RoaW5nIHRvIGRvXCJcbmxldCBjcmxmID0gY2hhciAnXFxyJyAqPiBjaGFyICdcXG4nXG5cbmxldCBib2R5X3BhcnQgYm9keSA9XG4gIEhlYWRlci5EZWNvZGVyLmhlYWRlciA+Pj0gZnVuIGZpZWxkcyAtPlxuICAoY3JsZiAqPiByZXR1cm4gYENSTEYgPHw+IHJldHVybiBgTm90aGluZyA8KiBjb21taXQgPj49IGZ1bmN0aW9uXG4gICB8IGBDUkxGIC0+IGJvZHkgZmllbGRzID4+fCBPcHRpb24uc29tZVxuICAgfCBgTm90aGluZyAtPiByZXR1cm4gTm9uZSlcbiAgPj58IGZ1biBib2R5IC0+IChmaWVsZHMsIGJvZHkpXG5cbmxldCBlbmNhcHN1bGF0aW9uIGJvdW5kYXJ5IGJvZHkgPVxuICBzdHJpbmcgKG1ha2VfZGVsaW1pdGVyIGJvdW5kYXJ5KVxuICAqPiB0cmFuc3BvcnRfcGFkZGluZ1xuICAqPiBjcmxmXG4gICo+IGNvbW1pdFxuICAqPiBib2R5X3BhcnQgYm9keVxuXG4oKiBGcm9tIFJGQyAyMDQ2OlxuXG4gICAgIHByZWFtYmxlIDo9IGRpc2NhcmQtdGV4dFxuICAgICBkaXNjYXJkLXRleHQgOj0gKiggKnRleHQgQ1JMRilcbiAgICAgICAgICAgICAgICAgICAgIDsgTWF5IGJlIGlnbm9yZWQgb3IgZGlzY2FyZGVkLlxuXG4gICBYWFgoZGlub3NhdXJlKTogdGhpcyBwYXJzZXIgY29uc3VtZSB0aGUgbGFzdCBDUkxGIHdoaWNoIGlzIE5PVCBpbmNsdWRlZCBpbiB0aGUgQUJORi4gKilcbmxldCBwcmVhbWJ1bGUgYm91bmRhcnkgPSBkaXNjYXJkX2FsbF90b19kYXNoX2JvdW5kYXJ5IGJvdW5kYXJ5XG5cbmxldCBlcGlsb2d1ZSBwYXJlbnQgPVxuICBtYXRjaCBwYXJlbnQgd2l0aFxuICB8IFNvbWUgYm91bmRhcnkgLT4gZGlzY2FyZF9hbGxfdG9fZGVsaW1pdGVyIGJvdW5kYXJ5XG4gIHwgTm9uZSAtPiBza2lwX3doaWxlIChmdW4gXyAtPiB0cnVlKVxuXG5sZXQgbXVsdGlwYXJ0X2JvZHkgP3BhcmVudCBib3VuZGFyeSBib2R5ID1cbiAgb3B0aW9uICgpIChwcmVhbWJ1bGUgYm91bmRhcnkpICgqIHNlZSBbcHJlYW1idWxlXS4gKilcbiAgKj4gZGFzaF9ib3VuZGFyeSBib3VuZGFyeVxuICAqPiB0cmFuc3BvcnRfcGFkZGluZ1xuICAqPiBjcmxmXG4gICo+IGNvbW1pdFxuICAqPiBib2R5X3BhcnQgYm9keVxuICA+Pj0gZnVuIHggLT5cbiAgbWFueSAoZW5jYXBzdWxhdGlvbiBib3VuZGFyeSBib2R5KSA+Pj0gZnVuIHIgLT5cbiAgKGNvbW1pdFxuICAgKj4gY2xvc2VfZGVsaW1pdGVyIGJvdW5kYXJ5XG4gICAqPiB0cmFuc3BvcnRfcGFkZGluZ1xuICAgKj4gb3B0aW9uICgpIChlcGlsb2d1ZSBwYXJlbnQpXG4gIDx8PiByZXR1cm4gKCkpXG4gICo+IHJldHVybiAoeCA6OiByKVxuIiwibGV0IHNyYyA9IExvZ3MuU3JjLmNyZWF0ZSBcIm11bHRpcGFydC1mb3JtXCJcblxubW9kdWxlIExvZyA9ICh2YWwgTG9ncy5zcmNfbG9nIHNyYyA6IExvZ3MuTE9HKVxubW9kdWxlIEZpZWxkX25hbWUgPSBGaWVsZF9uYW1lXG5tb2R1bGUgRmllbGQgPSBGaWVsZFxubW9kdWxlIEhlYWRlciA9IEhlYWRlclxubW9kdWxlIENvbnRlbnRfdHlwZSA9IENvbnRlbnRfdHlwZVxubW9kdWxlIENvbnRlbnRfZW5jb2RpbmcgPSBDb250ZW50X2VuY29kaW5nXG5tb2R1bGUgQ29udGVudF9kaXNwb3NpdGlvbiA9IENvbnRlbnRfZGlzcG9zaXRpb25cblxudHlwZSAnYSBzdHJlYW0gPSB1bml0IC0+ICdhIG9wdGlvblxuXG5tb2R1bGUgQjY0ID0gc3RydWN0XG4gIG9wZW4gQW5nc3Ryb21cblxuICBsZXQgcGFyc2VyIH53cml0ZV9kYXRhIGVuZF9vZl9ib2R5ID1cbiAgICBsZXQgZGVjID0gQmFzZTY0X3JmYzIwNDUuZGVjb2RlciBgTWFudWFsIGluXG5cbiAgICBsZXQgY2hlY2tfZW5kX29mX2JvZHkgPVxuICAgICAgbGV0IGV4cGVjdGVkX2xlbiA9IFN0cmluZy5sZW5ndGggZW5kX29mX2JvZHkgaW5cbiAgICAgIFVuc2FmZS5wZWVrIGV4cGVjdGVkX2xlbiAoZnVuIGJhIH5vZmYgfmxlbiAtPlxuICAgICAgICAgIGxldCByYXcgPSBCaWdzdHJpbmdhZi5zdWJzdHJpbmcgYmEgfm9mZiB+bGVuIGluXG4gICAgICAgICAgU3RyaW5nLmVxdWFsIHJhdyBlbmRfb2ZfYm9keSkgaW5cblxuICAgIGxldCB0cmFpbGVyICgpID1cbiAgICAgIGxldCByZWMgZmluaXNoICgpID1cbiAgICAgICAgbWF0Y2ggQmFzZTY0X3JmYzIwNDUuZGVjb2RlIGRlYyB3aXRoXG4gICAgICAgIHwgYEF3YWl0IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICB8IGBGbHVzaCBkYXRhIC0+XG4gICAgICAgICAgICB3cml0ZV9kYXRhIGRhdGEgO1xuICAgICAgICAgICAgY29tbWl0ID4+PSBmaW5pc2hcbiAgICAgICAgfCBgTWFsZm9ybWVkIGVyciAtPiBjb21taXQgKj4gZmFpbCBlcnJcbiAgICAgICAgfCBgV3JvbmdfcGFkZGluZyAtPiBjb21taXQgKj4gZmFpbCBcIndyb25nIHBhZGRpbmdcIlxuICAgICAgICB8IGBFbmQgLT4gY29tbWl0XG4gICAgICBhbmQgZ28gKCkgPVxuICAgICAgICBtYXRjaCBCYXNlNjRfcmZjMjA0NS5kZWNvZGUgZGVjIHdpdGhcbiAgICAgICAgfCBgQXdhaXQgLT5cbiAgICAgICAgICAgIEJhc2U2NF9yZmMyMDQ1LnNyYyBkZWMgQnl0ZXMuZW1wdHkgMCAwIDtcbiAgICAgICAgICAgIGNvbW1pdCA+Pj0gZmluaXNoXG4gICAgICAgIHwgYEZsdXNoIGRhdGEgLT5cbiAgICAgICAgICAgIHdyaXRlX2RhdGEgZGF0YSA7XG4gICAgICAgICAgICBjb21taXQgPj49IGdvXG4gICAgICAgIHwgYE1hbGZvcm1lZCBlcnIgLT4gY29tbWl0ICo+IGZhaWwgZXJyXG4gICAgICAgIHwgYFdyb25nX3BhZGRpbmcgLT4gY29tbWl0ICo+IGZhaWwgXCJ3cm9uZyBwYWRkaW5nXCJcbiAgICAgICAgfCBgRW5kIC0+IGNvbW1pdCBpblxuXG4gICAgICBnbyAoKSBpblxuXG4gICAgZml4IEBAIGZ1biBtIC0+XG4gICAgbGV0IGNob29zZSBjaHVuayA9IGZ1bmN0aW9uXG4gICAgICB8IHRydWUgLT5cbiAgICAgICAgICBsZXQgY2h1bmsgPSBCeXRlcy5zdWIgY2h1bmsgMCAoQnl0ZXMubGVuZ3RoIGNodW5rIC0gMSkgaW5cbiAgICAgICAgICBCYXNlNjRfcmZjMjA0NS5zcmMgZGVjIGNodW5rIDAgKEJ5dGVzLmxlbmd0aCBjaHVuaykgO1xuICAgICAgICAgIGNvbW1pdCAqPiB0cmFpbGVyICgpXG4gICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgQnl0ZXMuc2V0IGNodW5rIChCeXRlcy5sZW5ndGggY2h1bmsgLSAxKSBlbmRfb2ZfYm9keS5bMF0gO1xuICAgICAgICAgIEJhc2U2NF9yZmMyMDQ1LnNyYyBkZWMgY2h1bmsgMCAoQnl0ZXMubGVuZ3RoIGNodW5rKSA7XG4gICAgICAgICAgYWR2YW5jZSAxICo+IGNvbW1pdCAqPiBtIGluXG5cbiAgICBVbnNhZmUudGFrZV93aGlsZSAoKCA8PiApIGVuZF9vZl9ib2R5LlswXSkgQmlnc3RyaW5nYWYuc3Vic3RyaW5nXG4gICAgPj49IGZ1biBjaHVuayAtPlxuICAgIGxldCByZWMgZ28gKCkgPVxuICAgICAgbWF0Y2ggQmFzZTY0X3JmYzIwNDUuZGVjb2RlIGRlYyB3aXRoXG4gICAgICB8IGBFbmQgLT4gY29tbWl0XG4gICAgICB8IGBBd2FpdCAtPlxuICAgICAgICAgIGxldCBjaHVuaycgPSBCeXRlcy5jcmVhdGUgKFN0cmluZy5sZW5ndGggY2h1bmsgKyAxKSBpblxuICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIGNodW5rIDAgY2h1bmsnIDAgKFN0cmluZy5sZW5ndGggY2h1bmspIDtcbiAgICAgICAgICBjaGVja19lbmRfb2ZfYm9keSA+Pj0gY2hvb3NlIGNodW5rJ1xuICAgICAgfCBgRmx1c2ggZGF0YSAtPlxuICAgICAgICAgIHdyaXRlX2RhdGEgZGF0YSA7XG4gICAgICAgICAgY29tbWl0ID4+PSBnb1xuICAgICAgfCBgTWFsZm9ybWVkIGVyciAtPiBjb21taXQgKj4gZmFpbCBlcnJcbiAgICAgIHwgYFdyb25nX3BhZGRpbmcgLT4gY29tbWl0ICo+IGZhaWwgXCJ3cm9uZyBwYWRkaW5nXCIgaW5cbiAgICBnbyAoKVxuXG4gIGxldCB3aXRoX2VtaXR0ZXIgfmVtaXR0ZXIgZW5kX29mX2JvZHkgPVxuICAgIGxldCB3cml0ZV9kYXRhIHggPSBlbWl0dGVyIChTb21lIHgpIGluXG4gICAgcGFyc2VyIH53cml0ZV9kYXRhIGVuZF9vZl9ib2R5XG5cbiAgbGV0IHRvX2VuZF9vZl9pbnB1dCB+d3JpdGVfZGF0YSA9XG4gICAgbGV0IGRlYyA9IEJhc2U2NF9yZmMyMDQ1LmRlY29kZXIgYE1hbnVhbCBpblxuXG4gICAgZml4IEBAIGZ1biBtIC0+XG4gICAgbWF0Y2ggQmFzZTY0X3JmYzIwNDUuZGVjb2RlIGRlYyB3aXRoXG4gICAgfCBgRW5kIC0+IGNvbW1pdFxuICAgIHwgYEF3YWl0IC0+IChcbiAgICAgICAgcGVla19jaGFyID4+PSBmdW5jdGlvblxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgIEJhc2U2NF9yZmMyMDQ1LnNyYyBkZWMgQnl0ZXMuZW1wdHkgMCAwIDtcbiAgICAgICAgICAgIGNvbW1pdCAqPiByZXR1cm4gKClcbiAgICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgICAgIGF2YWlsYWJsZSA+Pj0gZnVuIG4gLT5cbiAgICAgICAgICAgIFVuc2FmZS50YWtlIG4gKGZ1biBiYSB+b2ZmIH5sZW4gLT5cbiAgICAgICAgICAgICAgICBsZXQgY2h1bmsgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgICAgICAgICAgICAgQmlnc3RyaW5nYWYuYmxpdF90b19ieXRlcyBiYSB+c3JjX29mZjpvZmYgY2h1bmsgfmRzdF9vZmY6MCB+bGVuIDtcbiAgICAgICAgICAgICAgICBCYXNlNjRfcmZjMjA0NS5zcmMgZGVjIGNodW5rIDAgbGVuKVxuICAgICAgICAgICAgPj49IGZ1biAoKSAtPiBjb21taXQgKj4gbSlcbiAgICB8IGBGbHVzaCBkYXRhIC0+XG4gICAgICAgIHdyaXRlX2RhdGEgZGF0YSA7XG4gICAgICAgIGNvbW1pdCAqPiBtXG4gICAgfCBgTWFsZm9ybWVkIGVyciAtPiBjb21taXQgKj4gZmFpbCBlcnJcbiAgICB8IGBXcm9uZ19wYWRkaW5nIC0+IGNvbW1pdCAqPiBmYWlsIFwid3JvbmcgcGFkZGluZ1wiXG5lbmRcblxubW9kdWxlIFJBVyA9IHN0cnVjdFxuICBvcGVuIEFuZ3N0cm9tXG5cbiAgbGV0IHJlYyBpbmRleCB2IG1heCBpZHggY2hyID1cbiAgICBpZiBpZHggPj0gbWF4XG4gICAgdGhlbiByYWlzZSBOb3RfZm91bmRcbiAgICBlbHNlIGlmIEJpZ3N0cmluZ2FmLmdldCB2IGlkeCA9IGNoclxuICAgIHRoZW4gaWR4XG4gICAgZWxzZSBpbmRleCB2IG1heCAoc3VjYyBpZHgpIGNoclxuXG4gIGxldCBpbmRleCB2IGNociA9IGluZGV4IHYgKEJpZ3N0cmluZ2FmLmxlbmd0aCB2KSAwIGNoclxuXG4gIGxldCBwYXJzZXIgfndyaXRlX2RhdGEgZW5kX29mX2JvZHkgPVxuICAgIGxldCBjaGVja19lbmRfb2ZfYm9keSA9XG4gICAgICBsZXQgZXhwZWN0ZWRfbGVuID0gU3RyaW5nLmxlbmd0aCBlbmRfb2ZfYm9keSBpblxuICAgICAgVW5zYWZlLnBlZWsgZXhwZWN0ZWRfbGVuIChmdW4gYmEgfm9mZiB+bGVuIC0+XG4gICAgICAgICAgbGV0IHJhdyA9IEJpZ3N0cmluZ2FmLnN1YnN0cmluZyBiYSB+b2ZmIH5sZW4gaW5cbiAgICAgICAgICBTdHJpbmcuZXF1YWwgcmF3IGVuZF9vZl9ib2R5KSBpblxuXG4gICAgZml4IEBAIGZ1biBtIC0+XG4gICAgbGV0IGNob29zZSBjaHVuayA9IGZ1bmN0aW9uXG4gICAgICB8IHRydWUgLT5cbiAgICAgICAgICAoKiBYWFgoZGlub3NhdXJlKTogaWYgaXQgcmV0dXJucyBbdHJ1ZV0sIHdlIGhhdmUgaW4gZnJvbnRcbiAgICAgICAgICAgKiBvZiB1cyB0aGUgZW5kIG9mIHRoZSBwYXJ0LiBXZSBuZWVkIHRvICoqZGVsZXRlKiogdGhlXG4gICAgICAgICAgICogY2hhcmFjdGVyIHdoaWNoIGhlbHBlZCB1cyB0byByZWNvZ25pemUgdGhlIGJlZ2luIG9mXG4gICAgICAgICAgICogW2VuZF9vZl9ib2R5XS4gKilcbiAgICAgICAgICBsZXQgY2h1bmsgPSBCeXRlcy5zdWJfc3RyaW5nIGNodW5rIDAgKEJ5dGVzLmxlbmd0aCBjaHVuayAtIDEpIGluXG4gICAgICAgICAgd3JpdGVfZGF0YSBjaHVuayA7XG4gICAgICAgICAgY29tbWl0XG4gICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgKCogWFhYKGRpbm9zYXVyZSk6IG90aGVyd2lzZSwgd2UgcmVzdG9yZSB0aGUgZW5kIG9mIG91ciBjaHVua1xuICAgICAgICAgICAqIHdpdGggdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBbZW5kX29mX2JvZHldIGFuZCBwYXNzIGl0IHRvXG4gICAgICAgICAgICogW3dyaXRlX2RhdGFdLiBUaGVuIHdlIHJlZG8gdGhlIGNvbXB1YXRpb24uICopXG4gICAgICAgICAgKCogQnl0ZXMuc2V0IGNodW5rIChCeXRlcy5sZW5ndGggY2h1bmsgLSAxKSBlbmRfb2ZfYm9keS5bMF0gOyAqKVxuICAgICAgICAgIHdyaXRlX2RhdGEgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY2h1bmspIDtcbiAgICAgICAgICBhZHZhbmNlIDEgKj4gY29tbWl0ICo+IG0gaW5cblxuICAgIGF2YWlsYWJsZSA+Pj0gZnVuY3Rpb25cbiAgICB8IDAgLT4gKCBwZWVrX2NoYXIgPj49IGZ1bmN0aW9uIE5vbmUgLT4gcmV0dXJuICgpIHwgU29tZSBfIC0+IG0pXG4gICAgfCBsZW4gLT4gKFxuICAgICAgICBVbnNhZmUucGVlayBsZW4gQmlnc3RyaW5nYWYuc3ViID4+PSBmdW4gY2h1bmsgLT5cbiAgICAgICAgbWF0Y2ggaW5kZXggY2h1bmsgZW5kX29mX2JvZHkuWzBdIHdpdGhcbiAgICAgICAgfCBwb3MgLT5cbiAgICAgICAgICAgICgqIFhYWChkaW5vc2F1cmUpOiBpbiB0aGF0IGNhc2UsIGl0J3MgcG9zc2libGUgdGhhdCB3ZSBoYXZlXG4gICAgICAgICAgICAgKiB0aGUgZW5kIG9mIHRoZSBwYXJ0LiBTbyB3ZSBuZWVkIHRvIGNoZWNrLiAqKVxuICAgICAgICAgICAgbGV0IHRtcCA9IEJ5dGVzLmNyZWF0ZSAocG9zICsgMSkgaW5cbiAgICAgICAgICAgIEJpZ3N0cmluZ2FmLmJsaXRfdG9fYnl0ZXMgY2h1bmsgfnNyY19vZmY6MCB0bXAgfmRzdF9vZmY6MFxuICAgICAgICAgICAgICB+bGVuOihwb3MgKyAxKSA7XG4gICAgICAgICAgICAoKiBYWFgoZGlub3NhdXJlKTogW2NoZWNrX2VuZF9vZl9ib2R5XSB3aWxsIHRyeSB0byBjaGVja1xuICAgICAgICAgICAgICogaWYgd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgcGFydCBhbmQgYXNrIHNvbWUgbW9yZSBieXRlcy4gKilcbiAgICAgICAgICAgIGFkdmFuY2UgcG9zICo+IGNoZWNrX2VuZF9vZl9ib2R5IDwqIGNvbW1pdCA+Pj0gY2hvb3NlIHRtcFxuICAgICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgICgqIFhYWChkaW5vc2F1cmUpOiBvdGhlcndpc2UsIHdlIGp1c3QgcGFzcyB0aGUgdmFsdWUgZGlyZWN0bHlcbiAgICAgICAgICAgICAqIHRvIHRoZSBbd3JpdGVfZGF0ZV0gYW5kIGNvbnRpbnVlLiAqKVxuICAgICAgICAgICAgd3JpdGVfZGF0YSAoQmlnc3RyaW5nYWYudG9fc3RyaW5nIGNodW5rKSA7XG4gICAgICAgICAgICBhZHZhbmNlIGxlbiAqPiBjb21taXQgKj4gbSlcblxuICBsZXQgd2l0aF9lbWl0dGVyIH5lbWl0dGVyIGVuZF9vZl9ib2R5ID1cbiAgICBsZXQgd3JpdGVfZGF0YSB4ID0gZW1pdHRlciAoU29tZSB4KSBpblxuICAgIHBhcnNlciB+d3JpdGVfZGF0YSBlbmRfb2ZfYm9keVxuXG4gIGxldCB0b19lbmRfb2ZfaW5wdXQgfndyaXRlX2RhdGEgPVxuICAgIGZpeCBAQCBmdW4gbSAtPlxuICAgIHBlZWtfY2hhciA+Pj0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gY29tbWl0XG4gICAgfCBTb21lIF8gLT5cbiAgICAgICAgYXZhaWxhYmxlID4+PSBmdW4gbiAtPlxuICAgICAgICBVbnNhZmUudGFrZSBuIChmdW4gYmEgfm9mZiB+bGVuIC0+XG4gICAgICAgICAgICBsZXQgY2h1bmsgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgICAgICAgICBCaWdzdHJpbmdhZi5ibGl0X3RvX2J5dGVzIGJhIH5zcmNfb2ZmOm9mZiBjaHVuayB+ZHN0X29mZjowIH5sZW4gO1xuICAgICAgICAgICAgd3JpdGVfZGF0YSAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjaHVuaykpXG4gICAgICAgICo+IGNvbW1pdFxuICAgICAgICAqPiBtXG5lbmRcblxubW9kdWxlIFFQID0gc3RydWN0XG4gIG9wZW4gQW5nc3Ryb21cblxuICBsZXQgcGFyc2VyIH53cml0ZV9kYXRhIH53cml0ZV9saW5lIGVuZF9vZl9ib2R5ID1cbiAgICBsZXQgZGVjID0gUGVjdS5kZWNvZGVyIGBNYW51YWwgaW5cblxuICAgIGxldCBjaGVja19lbmRfb2ZfYm9keSA9XG4gICAgICBsZXQgZXhwZWN0ZWRfbGVuID0gU3RyaW5nLmxlbmd0aCBlbmRfb2ZfYm9keSBpblxuICAgICAgVW5zYWZlLnBlZWsgZXhwZWN0ZWRfbGVuIChmdW4gYmEgfm9mZiB+bGVuIC0+XG4gICAgICAgICAgbGV0IHJhdyA9IEJpZ3N0cmluZ2FmLnN1YnN0cmluZyBiYSB+b2ZmIH5sZW4gaW5cbiAgICAgICAgICBTdHJpbmcuZXF1YWwgcmF3IGVuZF9vZl9ib2R5KSBpblxuXG4gICAgbGV0IHRyYWlsZXIgKCkgPVxuICAgICAgbGV0IHJlYyBmaW5pc2ggKCkgPVxuICAgICAgICBtYXRjaCBQZWN1LmRlY29kZSBkZWMgd2l0aFxuICAgICAgICB8IGBBd2FpdCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgKCogb24gW3BlY3VdLCBiZWNhdXNlIFtmaW5pc2hdIHdhcyBjYWxsZWQganVzdCBiZWZvcmUgW1BlY3Uuc3JjIGRlY1xuICAgICAgICAgICBCeXRlcy5lbXB0eSAwIDBdIChzbywgd2hlbiBbbGVuID0gMF0pLCBzZW1hbnRpY2FsbHksIGl0J3MgaW1wb3NzaWJsZVxuICAgICAgICAgICB0byByZXRyaWV2ZSB0aGlzIGNhc2UuIElmIFtwZWN1XSBleHBlY3RzIG1vcmUgaW5wdXRzIGFuZCB3ZSBub3RpY2VkXG4gICAgICAgICAgIGVuZCBvZiBpbnB1dCwgaXQgd2lsbCByZXR1cm4gW2BNYWxmb3JtZWRdLiAqKVxuICAgICAgICB8IGBEYXRhIGRhdGEgLT5cbiAgICAgICAgICAgIHdyaXRlX2RhdGEgZGF0YSA7XG4gICAgICAgICAgICBjb21taXQgPj49IGZpbmlzaFxuICAgICAgICB8IGBMaW5lIGxpbmUgLT5cbiAgICAgICAgICAgIHdyaXRlX2xpbmUgbGluZSA7XG4gICAgICAgICAgICBjb21taXQgPj49IGZpbmlzaFxuICAgICAgICB8IGBFbmQgLT4gY29tbWl0XG4gICAgICAgIHwgYE1hbGZvcm1lZCBlcnIgLT4gY29tbWl0ICo+IGZhaWwgZXJyXG4gICAgICBhbmQgZ28gKCkgPVxuICAgICAgICBtYXRjaCBQZWN1LmRlY29kZSBkZWMgd2l0aFxuICAgICAgICB8IGBBd2FpdCAtPlxuICAgICAgICAgICAgKCogZGVmaW5pdGVseSBbZW5kX29mX2JvZHldLiAqKVxuICAgICAgICAgICAgUGVjdS5zcmMgZGVjIEJ5dGVzLmVtcHR5IDAgMCA7XG4gICAgICAgICAgICBjb21taXQgPj49IGZpbmlzaFxuICAgICAgICB8IGBEYXRhIGRhdGEgLT5cbiAgICAgICAgICAgIHdyaXRlX2RhdGEgZGF0YSA7XG4gICAgICAgICAgICBjb21taXQgPj49IGdvXG4gICAgICAgIHwgYExpbmUgbGluZSAtPlxuICAgICAgICAgICAgd3JpdGVfbGluZSBsaW5lIDtcbiAgICAgICAgICAgIGNvbW1pdCA+Pj0gZ29cbiAgICAgICAgfCBgRW5kIC0+IGNvbW1pdFxuICAgICAgICB8IGBNYWxmb3JtZWQgZXJyIC0+IGNvbW1pdCAqPiBmYWlsIGVyciBpblxuXG4gICAgICBnbyAoKSBpblxuXG4gICAgZml4IEBAIGZ1biBtIC0+XG4gICAgbGV0IGNob29zZSBjaHVuayA9IGZ1bmN0aW9uXG4gICAgICB8IHRydWUgLT5cbiAgICAgICAgICAoKiBhdCB0aGlzIHN0YWdlLCB3ZSBhcmUgYXQgdGhlIGVuZCBvZiBib2R5LiBXZSBjYW1lIGZyb20gW2BBd2FpdF0gY2FzZSxcbiAgICAgICAgICAgICBzbyBpdCdzIHNhZmUgdG8gbm90aWNlIHRvIFtwZWN1XSB0aGUgbGFzdCBbY2h1bmtdLiBbdHJhaWxlcl0gd2lsbFxuICAgICAgICAgICAgIHVucm9sbCBhbGwgb3V0cHV0cyBhdmFpbGFibGVzIG9uIFtwZWN1XS4gKilcbiAgICAgICAgICBsZXQgY2h1bmsgPSBCeXRlcy5zdWIgY2h1bmsgMCAoQnl0ZXMubGVuZ3RoIGNodW5rIC0gMSkgaW5cbiAgICAgICAgICBQZWN1LnNyYyBkZWMgY2h1bmsgMCAoQnl0ZXMubGVuZ3RoIGNodW5rKSA7XG4gICAgICAgICAgY29tbWl0ID4+PSB0cmFpbGVyXG4gICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgKCogYXQgdGhpcyBzdGFnZSwgYnl0ZSBhZnRlciBbY2h1bmtdIGlzIE5PVCBhIHBhcnQgb2YgW2VuZF9vZl9ib2R5XS4gV2VcbiAgICAgICAgICAgICBjYW4gbm90aWNlIHRvIFtwZWN1XSBbY2h1bmsgKyBlbmRfb2ZfYm9keS5bMF1dLCBhZHZhbmNlIG9uIHRoZVxuICAgICAgICAgICAgIEFuZ3N0cm9tJ3MgaW5wdXQgdG8gb25lIGJ5dGUsIGFuZCByZWNhbGwgZml4cG9pbnQgdW50aWwgW2BBd2FpdF0gY2FzZVxuICAgICAgICAgICAgIChzZWUgYmVsb3cpLiAqKVxuICAgICAgICAgIEJ5dGVzLnNldCBjaHVuayAoQnl0ZXMubGVuZ3RoIGNodW5rIC0gMSkgZW5kX29mX2JvZHkuWzBdIDtcbiAgICAgICAgICBQZWN1LnNyYyBkZWMgY2h1bmsgMCAoQnl0ZXMubGVuZ3RoIGNodW5rKSA7XG4gICAgICAgICAgYWR2YW5jZSAxICo+IGNvbW1pdCAqPiBtIGluXG5cbiAgICAoKiB0YWtlIHdoaWxlIHdlIGRpZCBub3QgZGlzY292ZXIgdGhlIGZpcnN0IGJ5dGUgb2YgW2VuZF9vZl9ib2R5XS4gKilcbiAgICBVbnNhZmUudGFrZV93aGlsZSAoKCA8PiApIGVuZF9vZl9ib2R5LlswXSkgQmlnc3RyaW5nYWYuc3Vic3RyaW5nXG4gICAgPj49IGZ1biBjaHVuayAtPlxuICAgICgqIHN0YXJ0IHRvIGtub3cgd2hhdCB3ZSBuZWVkIHRvIGRvIHdpdGggW3BlY3VdLiAqKVxuICAgIGxldCByZWMgZ28gKCkgPVxuICAgICAgbWF0Y2ggUGVjdS5kZWNvZGUgZGVjIHdpdGhcbiAgICAgIHwgYEVuZCAtPiBjb21taXRcbiAgICAgIHwgYEF3YWl0IC0+XG4gICAgICAgICAgKCogW3BlY3VdIGV4cGVjdHMgaW5wdXRzLiBBdCB0aGlzIHN0YWdlLCB3ZSBrbm93IHRoYXQgYWZ0ZXIgW2NodW5rXSwgd2VcbiAgICAgICAgICAgICBoYXZlIHRoZSBmaXJzdCBieXRlIG9mIFtlbmRfb2ZfYm9keV0gLSBidXQgd2UgZG9uJ3Qga25vdyBpZiB3ZSBoYXZlXG4gICAgICAgICAgICAgW2VuZF9vZl9ib2R5XSBvciBhIHBhcnQgb2YgaXQuXG5cbiAgICAgICAgICAgICBbY2hlY2tfZW5kX29mX2JvZHldIHdpbGwgYWR2YW5jZSB0byBzZWUgaWYgd2UgcmVhbGx5IGhhdmVcbiAgICAgICAgICAgICBbZW5kX29mX2JvZHldLiBUaGUgcmVzdWx0IHdpbGwgYmUgc2VuZGVkIHRvIFtjaG9vc2VdLiAqKVxuICAgICAgICAgIGxldCBjaHVuaycgPSBCeXRlcy5jcmVhdGUgKFN0cmluZy5sZW5ndGggY2h1bmsgKyAxKSBpblxuICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIGNodW5rIDAgY2h1bmsnIDAgKFN0cmluZy5sZW5ndGggY2h1bmspIDtcbiAgICAgICAgICBjaGVja19lbmRfb2ZfYm9keSA8KiBjb21taXQgPj49IGNob29zZSBjaHVuaydcbiAgICAgIHwgYERhdGEgZGF0YSAtPlxuICAgICAgICAgIHdyaXRlX2RhdGEgZGF0YSA7XG4gICAgICAgICAgY29tbWl0ID4+PSBnb1xuICAgICAgfCBgTGluZSBsaW5lIC0+XG4gICAgICAgICAgd3JpdGVfbGluZSBsaW5lIDtcbiAgICAgICAgICBjb21taXQgPj49IGdvXG4gICAgICB8IGBNYWxmb3JtZWQgZXJyIC0+IGNvbW1pdCAqPiBmYWlsIGVyciBpblxuICAgIGdvICgpXG5cbiAgbGV0IHdpdGhfZW1pdHRlciA/KGVuZF9vZl9saW5lID0gXCJcXG5cIikgfmVtaXR0ZXIgZW5kX29mX2JvZHkgPVxuICAgIGxldCB3cml0ZV9kYXRhIHggPSBlbWl0dGVyIChTb21lIHgpIGluXG4gICAgbGV0IHdyaXRlX2xpbmUgeCA9IGVtaXR0ZXIgKFNvbWUgKHggXiBlbmRfb2ZfbGluZSkpIGluXG4gICAgcGFyc2VyIH53cml0ZV9kYXRhIH53cml0ZV9saW5lIGVuZF9vZl9ib2R5XG5cbiAgbGV0IHRvX2VuZF9vZl9pbnB1dCB+d3JpdGVfZGF0YSB+d3JpdGVfbGluZSA9XG4gICAgbGV0IGRlYyA9IFBlY3UuZGVjb2RlciBgTWFudWFsIGluXG5cbiAgICBmaXggQEAgZnVuIG0gLT5cbiAgICBtYXRjaCBQZWN1LmRlY29kZSBkZWMgd2l0aFxuICAgIHwgYEVuZCAtPiBjb21taXRcbiAgICB8IGBBd2FpdCAtPiAoXG4gICAgICAgIHBlZWtfY2hhciA+Pj0gZnVuY3Rpb25cbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICBQZWN1LnNyYyBkZWMgQnl0ZXMuZW1wdHkgMCAwIDtcbiAgICAgICAgICAgIGNvbW1pdFxuICAgICAgICB8IFNvbWUgXyAtPlxuICAgICAgICAgICAgYXZhaWxhYmxlID4+PSBmdW4gbiAtPlxuICAgICAgICAgICAgVW5zYWZlLnRha2UgbiAoZnVuIGJhIH5vZmYgfmxlbiAtPlxuICAgICAgICAgICAgICAgIGxldCBjaHVuayA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICAgICAgICAgICAgICBCaWdzdHJpbmdhZi5ibGl0X3RvX2J5dGVzIGJhIH5zcmNfb2ZmOm9mZiBjaHVuayB+ZHN0X29mZjowIH5sZW4gO1xuICAgICAgICAgICAgICAgIFBlY3Uuc3JjIGRlYyBjaHVuayAwIGxlbilcbiAgICAgICAgICAgICo+IGNvbW1pdFxuICAgICAgICAgICAgKj4gbSlcbiAgICB8IGBEYXRhIGRhdGEgLT5cbiAgICAgICAgd3JpdGVfZGF0YSBkYXRhIDtcbiAgICAgICAgY29tbWl0ICo+IG1cbiAgICB8IGBMaW5lIGxpbmUgLT5cbiAgICAgICAgd3JpdGVfbGluZSBsaW5lIDtcbiAgICAgICAgY29tbWl0ICo+IG1cbiAgICB8IGBNYWxmb3JtZWQgZXJyIC0+IGNvbW1pdCAqPiBmYWlsIGVyclxuZW5kXG5cbnR5cGUgJ2EgZWx0ID0geyBoZWFkZXIgOiBIZWFkZXIudDsgYm9keSA6ICdhIH1cbnR5cGUgJ2EgdCA9IExlYWYgb2YgJ2EgZWx0IHwgTXVsdGlwYXJ0IG9mICdhIHQgb3B0aW9uIGxpc3QgZWx0XG5cbmxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICB8IExlYWYgeyBoZWFkZXI7IGJvZHkgfSAtPiBMZWFmIHsgaGVhZGVyOyBib2R5ID0gZiBib2R5IH1cbiAgfCBNdWx0aXBhcnQgeyBoZWFkZXI7IGJvZHkgfSAtPlxuICAgICAgTXVsdGlwYXJ0IHsgaGVhZGVyOyBib2R5ID0gTGlzdC5tYXAgKE9wdGlvbi5tYXAgKG1hcCBmKSkgYm9keSB9XG5cbmxldCByZWMgZmxhdHRlbiA9IGZ1bmN0aW9uXG4gIHwgTGVhZiBlbHQgLT4gWyBlbHQgXVxuICB8IE11bHRpcGFydCB7IGhlYWRlciA9IF87IGJvZHkgfSAtPlxuICAgICAgTGlzdC5mbGF0dGVuIEBAIExpc3QuZmlsdGVyX21hcCAoT3B0aW9uLm1hcCBmbGF0dGVuKSBib2R5XG5cbmxldCBpdGVyIH5mIGJ1ZiB+b2ZmIH5sZW4gPVxuICBmb3IgaSA9IG9mZiB0byBsZW4gLSAxIGRvXG4gICAgZiBidWYuW2ldXG4gIGRvbmVcblxubGV0IHRvX3F1b3RlZF9wcmludGFibGUgOlxuICAgID9sZW5ndGg6aW50IC0+IChzdHJpbmcgKiBpbnQgKiBpbnQpIHN0cmVhbSAtPiAoc3RyaW5nICogaW50ICogaW50KSBzdHJlYW0gPVxuIGZ1biA/bGVuZ3RoOihjaHVua19sZW5ndGggPSA0MDk2KSBzdHJlYW0gLT5cbiAgbGV0IGNodW5rID0gQnl0ZXMuY3JlYXRlIGNodW5rX2xlbmd0aCBpblxuICBsZXQgZW5jb2RlciA9IFBlY3UuZW5jb2RlciBgTWFudWFsIGluXG4gIGxldCBxdWV1ZSA9IEtlLlJrZS5jcmVhdGUgfmNhcGFjaXR5OjEyOCBCaWdhcnJheS5JbnQgaW5cblxuICBsZXQgcmVjIGVtaXQgKCkgPVxuICAgIEtlLlJrZS5jb25zIHF1ZXVlIDI1NiA7XG4gICAgbGV0IGxlbiA9IGNodW5rX2xlbmd0aCAtIFBlY3UuZHN0X3JlbSBlbmNvZGVyIGluXG4gICAgU29tZSAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjaHVuaywgMCwgbGVuKVxuICBhbmQgcGVuZGluZyA9IGZ1bmN0aW9uXG4gICAgfCBgT2sgLT4gZ28gKClcbiAgICB8IGBQYXJ0aWFsIC0+XG4gICAgICAgIGxldCBsZW4gPSBjaHVua19sZW5ndGggLSBQZWN1LmRzdF9yZW0gZW5jb2RlciBpblxuICAgICAgICBTb21lIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGNodW5rLCAwLCBsZW4pXG4gIGFuZCBnbyAoKSA9XG4gICAgbWF0Y2ggS2UuUmtlLnBvcF9leG4gcXVldWUgd2l0aFxuICAgIHwgMjU2ICgqIEF3YWl0ICopIC0+IChcbiAgICAgICAgUGVjdS5kc3QgZW5jb2RlciBjaHVuayAwIGNodW5rX2xlbmd0aCA7XG4gICAgICAgIG1hdGNoIFBlY3UuZW5jb2RlIGVuY29kZXIgYEF3YWl0IHdpdGhcbiAgICAgICAgfCBgT2sgLT4gKGdvIFtAdGFpbGNhbGxdKSAoKVxuICAgICAgICB8IGBQYXJ0aWFsIC0+IChlbWl0IFtAdGFpbGNhbGxdKSAoKSlcbiAgICB8IDI1NyAoKiBMaW5lX2JyZWFrICopIC0+IChcbiAgICAgICAgKCogWFhYKGRpbm9zYXVyZSk6IHdlIGVuY29kZSwgaW4gYW55IGNhc2UsIGEgbGFzdCBDUkxGIHRvIGVuc3VyZSB0aGF0IGFueVxuICAgICAgICAgICBsaW5lIGVtaXR0ZWQgYnkgW3RvX3F1b3RlZF9wcmludGFibGVdIGZpbmlzaCB3aXRoIGEgW0NSTEZdLiBUT0RPOiBtYXlcbiAgICAgICAgICAgYmUgdGhpcyBiZWhhdmlvciBpcyBzdHJpY3RseSB1bmRlciBbUGVjdV0gaW1wbC4gKilcbiAgICAgICAgS2UuUmtlLmNvbnMgcXVldWUgMjU4IDtcbiAgICAgICAgbWF0Y2ggUGVjdS5lbmNvZGUgZW5jb2RlciBgTGluZV9icmVhayB3aXRoXG4gICAgICAgIHwgYE9rIC0+IGdvICgpXG4gICAgICAgIHwgYFBhcnRpYWwgLT4gKGVtaXQgW0B0YWlsY2FsbF0pICgpKVxuICAgIHwgMjU4ICgqIEVuZCAqKSAtPlxuICAgICAgICBLZS5Sa2UuY29ucyBxdWV1ZSAyNTkgO1xuICAgICAgICAocGVuZGluZyBbQHRhaWxjYWxsXSkgKFBlY3UuZW5jb2RlIGVuY29kZXIgYEVuZClcbiAgICB8IDI1OSAtPlxuICAgICAgICBhc3NlcnQgKFBlY3UuZW5jb2RlIGVuY29kZXIgYEF3YWl0ID0gYE9rKSA7XG4gICAgICAgIEtlLlJrZS5jb25zIHF1ZXVlIDI1OSA7XG4gICAgICAgIE5vbmVcbiAgICB8IGNociAtPiAoXG4gICAgICAgIG1hdGNoIFBlY3UuZW5jb2RlIGVuY29kZXIgKGBDaGFyIChDaGFyLmNociBjaHIpKSB3aXRoXG4gICAgICAgIHwgYE9rIC0+IChnbyBbQHRhaWxjYWxsXSkgKClcbiAgICAgICAgfCBgUGFydGlhbCAtPiAoZW1pdCBbQHRhaWxjYWxsXSkgKCkpXG4gICAgfCBleGNlcHRpb24gS2UuUmtlLkVtcHR5IC0+XG4gICAgbWF0Y2ggc3RyZWFtICgpIHdpdGhcbiAgICB8IFNvbWUgKGJ1Ziwgb2ZmLCBsZW4pIC0+XG4gICAgICAgIGl0ZXIgfmY6KGZ1biBjaHIgLT4gS2UuUmtlLnB1c2ggcXVldWUgKENoYXIuY29kZSBjaHIpKSBidWYgfm9mZiB+bGVuIDtcbiAgICAgICAgKGdvIFtAdGFpbGNhbGxdKSAoKVxuICAgIHwgTm9uZSAtPlxuICAgICAgICBLZS5Sa2UucHVzaCBxdWV1ZSAyNTcgO1xuICAgICAgICAoZ28gW0B0YWlsY2FsbF0pICgpIGluXG5cbiAgUGVjdS5kc3QgZW5jb2RlciBjaHVuayAwIGNodW5rX2xlbmd0aCA7XG4gIGdvXG5cbmxldCB0b19iYXNlNjQgOlxuICAgID9sZW5ndGg6aW50IC0+IChzdHJpbmcgKiBpbnQgKiBpbnQpIHN0cmVhbSAtPiAoc3RyaW5nICogaW50ICogaW50KSBzdHJlYW0gPVxuIGZ1biA/bGVuZ3RoOihjaHVua19sZW5ndGggPSA0MDk2KSBzdHJlYW0gLT5cbiAgbGV0IGNodW5rID0gQnl0ZXMuY3JlYXRlIGNodW5rX2xlbmd0aCBpblxuICBsZXQgZW5jb2RlciA9IEJhc2U2NF9yZmMyMDQ1LmVuY29kZXIgYE1hbnVhbCBpblxuICBsZXQgcXVldWUgPSBLZS5Sa2UuY3JlYXRlIH5jYXBhY2l0eToxMjggQmlnYXJyYXkuSW50IGluXG5cbiAgbGV0IHJlYyBlbWl0ICgpID1cbiAgICBLZS5Sa2UuY29ucyBxdWV1ZSAyNTYgO1xuICAgIGxldCBsZW4gPSBjaHVua19sZW5ndGggLSBCYXNlNjRfcmZjMjA0NS5kc3RfcmVtIGVuY29kZXIgaW5cbiAgICBTb21lIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGNodW5rLCAwLCBsZW4pXG4gIGFuZCBwZW5kaW5nID0gZnVuY3Rpb25cbiAgICB8IGBPayAtPiAoZ28gW0B0YWlsY2FsbF0pICgpXG4gICAgfCBgUGFydGlhbCAtPlxuICAgICAgICBsZXQgbGVuID0gY2h1bmtfbGVuZ3RoIC0gQmFzZTY0X3JmYzIwNDUuZHN0X3JlbSBlbmNvZGVyIGluXG4gICAgICAgIFNvbWUgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY2h1bmssIDAsIGxlbilcbiAgYW5kIGdvICgpID1cbiAgICBtYXRjaCBLZS5Sa2UucG9wX2V4biBxdWV1ZSB3aXRoXG4gICAgfCAyNTYgKCogQXdhaXQgKikgLT4gKFxuICAgICAgICBCYXNlNjRfcmZjMjA0NS5kc3QgZW5jb2RlciBjaHVuayAwIGNodW5rX2xlbmd0aCA7XG4gICAgICAgIG1hdGNoIEJhc2U2NF9yZmMyMDQ1LmVuY29kZSBlbmNvZGVyIGBBd2FpdCB3aXRoXG4gICAgICAgIHwgYE9rIC0+IChnbyBbQHRhaWxjYWxsXSkgKClcbiAgICAgICAgfCBgUGFydGlhbCAtPiAoZW1pdCBbQHRhaWxjYWxsXSkgKCkpXG4gICAgfCAyNTcgKCogRW5kICopIC0+XG4gICAgICAgIEtlLlJrZS5jb25zIHF1ZXVlIDI1OCA7XG4gICAgICAgIChwZW5kaW5nIFtAdGFpbGNhbGxdKSAoQmFzZTY0X3JmYzIwNDUuZW5jb2RlIGVuY29kZXIgYEVuZClcbiAgICB8IDI1OCAtPlxuICAgICAgICBhc3NlcnQgKEJhc2U2NF9yZmMyMDQ1LmVuY29kZSBlbmNvZGVyIGBBd2FpdCA9IGBPaykgO1xuICAgICAgICBLZS5Sa2UuY29ucyBxdWV1ZSAyNTggO1xuICAgICAgICBOb25lXG4gICAgfCBjaHIgLT4gKFxuICAgICAgICBtYXRjaCBCYXNlNjRfcmZjMjA0NS5lbmNvZGUgZW5jb2RlciAoYENoYXIgKENoYXIuY2hyIGNocikpIHdpdGhcbiAgICAgICAgfCBgT2sgLT4gKGdvIFtAdGFpbGNhbGxdKSAoKVxuICAgICAgICB8IGBQYXJ0aWFsIC0+IChlbWl0IFtAdGFpbGNhbGxdKSAoKSlcbiAgICB8IGV4Y2VwdGlvbiBLZS5Sa2UuRW1wdHkgLT5cbiAgICBtYXRjaCBzdHJlYW0gKCkgd2l0aFxuICAgIHwgU29tZSAoYnVmLCBvZmYsIGxlbikgLT5cbiAgICAgICAgaXRlciB+ZjooZnVuIGNociAtPiBLZS5Sa2UucHVzaCBxdWV1ZSAoQ2hhci5jb2RlIGNocikpIGJ1ZiB+b2ZmIH5sZW4gO1xuICAgICAgICAoZ28gW0B0YWlsY2FsbF0pICgpXG4gICAgfCBOb25lIC0+XG4gICAgICAgIEtlLlJrZS5wdXNoIHF1ZXVlIDI1NyA7XG4gICAgICAgIChnbyBbQHRhaWxjYWxsXSkgKCkgaW5cblxuICBCYXNlNjRfcmZjMjA0NS5kc3QgZW5jb2RlciBjaHVuayAwIGNodW5rX2xlbmd0aCA7XG4gIGdvXG5cbmxldCBjb250ZW50X2VuY29kaW5nIGZpZWxkcyA9XG4gIGxldCBlbmNvZGluZyA6IENvbnRlbnRfZW5jb2RpbmcudCByZWYgPSByZWYgYEJpdDcgaW5cbiAgbGV0IGV4Y2VwdGlvbiBGb3VuZCBpblxuICB0cnlcbiAgICBMaXN0Lml0ZXJcbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IEZpZWxkLkZpZWxkIChfLCBDb250ZW50X2VuY29kaW5nLCB2KSAtPlxuICAgICAgICAgICAgZW5jb2RpbmcgOj0gdiA7XG4gICAgICAgICAgICByYWlzZSBGb3VuZFxuICAgICAgICB8IF8gLT4gKCkpXG4gICAgICBmaWVsZHMgO1xuICAgICFlbmNvZGluZ1xuICB3aXRoIEZvdW5kIC0+ICFlbmNvZGluZ1xuXG5sZXQgZmFpbGYgZm10ID0gRm10LmtzdHIgQW5nc3Ryb20uZmFpbCBmbXRcblxubGV0IG9jdGV0IH5lbWl0dGVyIGJvdW5kYXJ5IGhlYWRlciA9XG4gIGxldCBvcGVuIEFuZ3N0cm9tIGluXG4gIG1hdGNoIGJvdW5kYXJ5IHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBsZXQgd3JpdGVfbGluZSBsaW5lID0gZW1pdHRlciAoU29tZSAobGluZSBeIFwiXFxuXCIpKSBpblxuICAgICAgbGV0IHdyaXRlX2RhdGEgZGF0YSA9IGVtaXR0ZXIgKFNvbWUgZGF0YSkgaW5cblxuICAgICAgKG1hdGNoIGNvbnRlbnRfZW5jb2RpbmcgaGVhZGVyIHdpdGhcbiAgICAgIHwgYFF1b3RlZF9wcmludGFibGUgLT5cbiAgICAgICAgICBMb2cuZGVidWcgKGZ1biBtIC0+IG0gXCJEZWNvZGUgdGhlIHF1b3RlZC1wcmludGFibGUgZmluYWwgcGFydC5cIikgO1xuICAgICAgICAgIFFQLnRvX2VuZF9vZl9pbnB1dCB+d3JpdGVfZGF0YSB+d3JpdGVfbGluZVxuICAgICAgfCBgQmFzZTY0IC0+XG4gICAgICAgICAgTG9nLmRlYnVnIChmdW4gbSAtPiBtIFwiRGVjb2RlIHRoZSBiYXNlNjQgZmluYWwgcGFydC5cIikgO1xuICAgICAgICAgIEI2NC50b19lbmRfb2ZfaW5wdXQgfndyaXRlX2RhdGFcbiAgICAgIHwgYEJpdDcgfCBgQml0OCB8IGBCaW5hcnkgLT5cbiAgICAgICAgICBMb2cuZGVidWcgKGZ1biBtIC0+IG0gXCJEZWNvZGUgdGhlIDgtYml0IGZpbmFsIHBhcnQuXCIpIDtcbiAgICAgICAgICBSQVcudG9fZW5kX29mX2lucHV0IH53cml0ZV9kYXRhXG4gICAgICB8IGBJZXRmX3Rva2VuIHYgfCBgWF90b2tlbiB2IC0+XG4gICAgICAgICAgZmFpbGYgXCJJbnZhbGlkIENvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmcgdmFsdWUgKCVzKVwiIHYpXG4gICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICBlbWl0dGVyIE5vbmUgO1xuICAgICAgcmV0dXJuICgpXG4gIHwgU29tZSBib3VuZGFyeSAtPlxuICAgICAgbGV0IGVuZF9vZl9ib2R5ID0gUmZjMjA0Ni5tYWtlX2RlbGltaXRlciBib3VuZGFyeSBpblxuICAgICAgKG1hdGNoIGNvbnRlbnRfZW5jb2RpbmcgaGVhZGVyIHdpdGhcbiAgICAgIHwgYFF1b3RlZF9wcmludGFibGUgLT5cbiAgICAgICAgICBMb2cuZGVidWcgKGZ1biBtIC0+IG0gXCJEZWNvZGUgYSBxdW90ZWQtcHJpbnRhYmxlIHBhcnQuXCIpIDtcbiAgICAgICAgICBRUC53aXRoX2VtaXR0ZXIgfmVtaXR0ZXIgZW5kX29mX2JvZHlcbiAgICAgIHwgYEJhc2U2NCAtPlxuICAgICAgICAgIExvZy5kZWJ1ZyAoZnVuIG0gLT4gbSBcIkRlY29kZSBhIGJhc2U2NCBwYXJ0LlwiKSA7XG4gICAgICAgICAgQjY0LndpdGhfZW1pdHRlciB+ZW1pdHRlciBlbmRfb2ZfYm9keVxuICAgICAgfCBgQml0NyB8IGBCaXQ4IHwgYEJpbmFyeSAtPlxuICAgICAgICAgIExvZy5kZWJ1ZyAoZnVuIG0gLT4gbSBcIkRlY29kZSBhIDgtYml0IHBhcnQuXCIpIDtcbiAgICAgICAgICBSQVcud2l0aF9lbWl0dGVyIH5lbWl0dGVyIGVuZF9vZl9ib2R5XG4gICAgICB8IGBJZXRmX3Rva2VuIHYgfCBgWF90b2tlbiB2IC0+XG4gICAgICAgICAgZmFpbGYgXCJJbnZhbGlkIENvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmcgdmFsdWUgKCVzKVwiIHYpXG4gICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICBlbWl0dGVyIE5vbmUgO1xuICAgICAgcmV0dXJuICgpXG5cbnR5cGUgJ2lkIGVtaXR0ZXJzID0gSGVhZGVyLnQgLT4gKHN0cmluZyBvcHRpb24gLT4gdW5pdCkgKiAnaWRcbnR5cGUgZGlzY3JldGUgPSBbIGBUZXh0IHwgYEltYWdlIHwgYEF1ZGlvIHwgYFZpZGVvIHwgYEFwcGxpY2F0aW9uIF1cblxubGV0IGJvdW5kYXJ5IGhlYWRlciA9XG4gIGxldCBjb250ZW50X3R5cGUgPSBIZWFkZXIuY29udGVudF90eXBlIGhlYWRlciBpblxuICBtYXRjaCBMaXN0LmFzc29jX29wdCBcImJvdW5kYXJ5XCIgKENvbnRlbnRfdHlwZS5wYXJhbWV0ZXJzIGNvbnRlbnRfdHlwZSkgd2l0aFxuICB8IFNvbWUgKFRva2VuIGJvdW5kYXJ5KSB8IFNvbWUgKFN0cmluZyBib3VuZGFyeSkgLT4gU29tZSBib3VuZGFyeVxuICB8IE5vbmUgLT4gTm9uZVxuXG5sZXQgcGFyc2VyIDogZW1pdHRlcnM6J2lkIGVtaXR0ZXJzIC0+IEZpZWxkLmZpZWxkIGxpc3QgLT4gJ2lkIHQgQW5nc3Ryb20udCA9XG4gZnVuIH5lbWl0dGVycyBoZWFkZXIgLT5cbiAgbGV0IG9wZW4gQW5nc3Ryb20gaW5cbiAgbGV0IHJlYyBib2R5IHBhcmVudCBoZWFkZXIgPVxuICAgIG1hdGNoIENvbnRlbnRfdHlwZS50eSAoSGVhZGVyLmNvbnRlbnRfdHlwZSBoZWFkZXIpIHdpdGhcbiAgICB8IGBJZXRmX3Rva2VuIHYgfCBgWF90b2tlbiB2IC0+XG4gICAgICAgIGZhaWxmIFwiSW52YWxpZCBDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nIHZhbHVlICglcylcIiB2XG4gICAgfCAjZGlzY3JldGUgLT5cbiAgICAgICAgbGV0IGVtaXR0ZXIsIGlkID0gZW1pdHRlcnMgaGVhZGVyIGluXG4gICAgICAgIG9jdGV0IH5lbWl0dGVyIHBhcmVudCBoZWFkZXIgPj58IGZ1biAoKSAtPiBMZWFmIHsgaGVhZGVyOyBib2R5ID0gaWQgfVxuICAgIHwgYE11bHRpcGFydCAtPlxuICAgIG1hdGNoIGJvdW5kYXJ5IGhlYWRlciB3aXRoXG4gICAgfCBTb21lIGJvdW5kYXJ5IC0+XG4gICAgICAgIFJmYzIwNDYubXVsdGlwYXJ0X2JvZHkgP3BhcmVudCBib3VuZGFyeSAoYm9keSAoT3B0aW9uLnNvbWUgYm91bmRhcnkpKVxuICAgICAgICA+PnwgTGlzdC5tYXAgKGZ1biAoX2hlYWRlciwgY29udGVudHMpIC0+IGNvbnRlbnRzKVxuICAgICAgICA+PnwgZnVuIHBhcnRzIC0+IE11bHRpcGFydCB7IGhlYWRlcjsgYm9keSA9IHBhcnRzIH1cbiAgICB8IE5vbmUgLT4gZmFpbGYgXCJJbnZhbGlkIENvbnRlbnQtVHlwZSwgbWlzc2luZyBib3VuZGFyeVwiIGluXG4gIGJvZHkgTm9uZSBoZWFkZXJcblxubGV0IHBhcnNlciB+ZW1pdHRlcnMgY29udGVudF90eXBlID1cbiAgcGFyc2VyIH5lbWl0dGVyc1xuICAgIFsgRmllbGQuRmllbGQgKEZpZWxkX25hbWUuY29udGVudF90eXBlLCBGaWVsZC5Db250ZW50X3R5cGUsIGNvbnRlbnRfdHlwZSkgXVxuXG5sZXQgYmxpdCBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiBsZW4gPVxuICBCaWdzdHJpbmdhZi5ibGl0X2Zyb21fc3RyaW5nIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgfmxlblxuXG5sZXQgcGFyc2UgOlxuICAgIGVtaXR0ZXJzOidpZCBlbWl0dGVycyAtPlxuICAgIENvbnRlbnRfdHlwZS50IC0+XG4gICAgWyBgU3RyaW5nIG9mIHN0cmluZyB8IGBFb2YgXSAtPlxuICAgIFsgYENvbnRpbnVlIHwgYERvbmUgb2YgJ2lkIHQgfCBgRmFpbCBvZiBzdHJpbmcgXSA9XG4gZnVuIH5lbWl0dGVycyBjb250ZW50X3R5cGUgLT5cbiAgbGV0IHBhcnNlciA9IHBhcnNlciB+ZW1pdHRlcnMgY29udGVudF90eXBlIGluXG4gIGxldCBzdGF0ZSA9IHJlZiAoQW5nc3Ryb20uVW5idWZmZXJlZC5wYXJzZSBwYXJzZXIpIGluXG4gIGxldCBrZSA9IEtlLlJrZS5jcmVhdGUgfmNhcGFjaXR5OjB4MTAwMCBCaWdhcnJheS5jaGFyIGluXG4gIGZ1biBkYXRhIC0+XG4gICAgbWF0Y2ggIXN0YXRlIHdpdGhcbiAgICB8IEFuZ3N0cm9tLlVuYnVmZmVyZWQuRG9uZSAoXywgdHJlZSkgLT4gYERvbmUgdHJlZVxuICAgIHwgRmFpbCAoXywgXywgbXNnKSAtPiBgRmFpbCBtc2dcbiAgICB8IFBhcnRpYWwgeyBjb21taXR0ZWQ7IGNvbnRpbnVlIH0gLT5cbiAgICAgICAgS2UuUmtlLk4uc2hpZnRfZXhuIGtlIGNvbW1pdHRlZCA7XG4gICAgICAgIGlmIGNvbW1pdHRlZCA9IDAgdGhlbiBLZS5Sa2UuY29tcHJlc3Mga2UgO1xuICAgICAgICBMb2cuZGVidWcgKGZ1biBtIC0+IG0gXCJQYXJ0aWFsIHN0YXRlIG9mIHRoZSBtdWx0aXBhcnQvZm9ybSBzdHJlYW0uXCIpIDtcbiAgICAgICAgKG1hdGNoIGRhdGEgd2l0aFxuICAgICAgICB8IGBTdHJpbmcgXCJcIiAtPiAoKVxuICAgICAgICB8IGBTdHJpbmcgc3RyIC0+XG4gICAgICAgICAgICBMb2cuZGVidWcgKGZ1biBtIC0+XG4gICAgICAgICAgICAgICAgbSBcIkNhcGFjaXR5IG9mIHRoZSBpbnRlcm5hbCBxdWV1ZTogJWQgYnl0ZShzKS5cIlxuICAgICAgICAgICAgICAgICAgKEtlLlJrZS5jYXBhY2l0eSBrZSkpIDtcbiAgICAgICAgICAgIExvZy5kZWJ1ZyAoZnVuIG0gLT5cbiAgICAgICAgICAgICAgICBtIFwiTGVuZ3RoIG9mIHRoZSBpbnRlcm5hbCBxdWV1ZTogJWQgYnl0ZShzKS5cIiAoS2UuUmtlLmxlbmd0aCBrZSkpIDtcbiAgICAgICAgICAgIEtlLlJrZS5OLnB1c2gga2UgfmJsaXQgfmxlbmd0aDpTdHJpbmcubGVuZ3RoIH5vZmY6MFxuICAgICAgICAgICAgICB+bGVuOihTdHJpbmcubGVuZ3RoIHN0cikgc3RyIDtcbiAgICAgICAgICAgIGxldFtAd2FybmluZyBcIi04XCJdIChzbGljZSA6OiBfKSA9IEtlLlJrZS5OLnBlZWsga2UgaW5cbiAgICAgICAgICAgIHN0YXRlIDo9XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHNsaWNlIH5vZmY6MCB+bGVuOihCaWdzdHJpbmdhZi5sZW5ndGggc2xpY2UpIEluY29tcGxldGVcbiAgICAgICAgfCBgRW9mIC0+IChcbiAgICAgICAgICAgIExvZy5kZWJ1ZyAoZnVuIG0gLT4gbSBcIkVuZCBvZiBpbnB1dC5cIikgO1xuICAgICAgICAgICAgbWF0Y2ggS2UuUmtlLk4ucGVlayBrZSB3aXRoXG4gICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgTG9nLmRlYnVnIChmdW4gbSAtPiBtIFwiTm8gbW9yZSBwYXlsb2Fkcy5cIikgO1xuICAgICAgICAgICAgICAgIHN0YXRlIDo9IGNvbnRpbnVlIEJpZ3N0cmluZ2FmLmVtcHR5IH5vZmY6MCB+bGVuOjAgQ29tcGxldGVcbiAgICAgICAgICAgIHwgWyBzbGljZSBdIC0+XG4gICAgICAgICAgICAgICAgTG9nLmRlYnVnIChmdW4gbSAtPlxuICAgICAgICAgICAgICAgICAgICBtIFwiUmVtYWluIG9uZSBwYXlsb2FkOiAlU1wiIChCaWdzdHJpbmdhZi50b19zdHJpbmcgc2xpY2UpKSA7XG4gICAgICAgICAgICAgICAgc3RhdGUgOj1cbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNsaWNlIH5vZmY6MCB+bGVuOihCaWdzdHJpbmdhZi5sZW5ndGggc2xpY2UpIENvbXBsZXRlXG4gICAgICAgICAgICB8IHNsaWNlIDo6IF8gLT5cbiAgICAgICAgICAgICAgICBMb2cuZGVidWcgKGZ1biBtIC0+IG0gXCJSZW1haW4gbXVsdGlwbGUgcGF5bG9hZHNcIikgO1xuICAgICAgICAgICAgICAgIHN0YXRlIDo9XG4gICAgICAgICAgICAgICAgICBjb250aW51ZSBzbGljZSB+b2ZmOjAgfmxlbjooQmlnc3RyaW5nYWYubGVuZ3RoIHNsaWNlKVxuICAgICAgICAgICAgICAgICAgICBJbmNvbXBsZXRlKSkgO1xuICAgICAgICBgQ29udGludWVcblxubGV0IG9mX3N0cmVhbV90Ymwgc3RyZWFtIGNvbnRlbnRfdHlwZSA9XG4gIGxldCBnZW4gPVxuICAgIGxldCB2ID0gcmVmICgtMSkgaW5cbiAgICBmdW4gKCkgLT5cbiAgICAgIGluY3IgdiA7XG4gICAgICAhdiBpblxuICBsZXQgdGJsID0gSGFzaHRibC5jcmVhdGUgMHgxMCBpblxuICBsZXQgZW1pdHRlcnMgX2hlYWRlciA9XG4gICAgbGV0IGlkeCA9IGdlbiAoKSBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDB4MTAwIGluXG4gICAgSGFzaHRibC5hZGQgdGJsIGlkeCBidWYgO1xuICAgICgoZnVuY3Rpb24gU29tZSBzdHIgLT4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHN0ciB8IE5vbmUgLT4gKCkpLCBpZHgpIGluXG4gIGxldCBwYXJzZSA9IHBhcnNlIH5lbWl0dGVycyBjb250ZW50X3R5cGUgaW5cbiAgbGV0IHJlYyBnbyAoKSA9XG4gICAgbGV0IGRhdGEgPSBtYXRjaCBzdHJlYW0gKCkgd2l0aCBOb25lIC0+IGBFb2YgfCBTb21lIHN0ciAtPiBgU3RyaW5nIHN0ciBpblxuICAgIG1hdGNoIHBhcnNlIGRhdGEgd2l0aFxuICAgIHwgYENvbnRpbnVlIC0+IGdvICgpXG4gICAgfCBgRG9uZSBtIC0+IE9rIChtLCB0YmwpXG4gICAgfCBgRmFpbCBfbXNnIC0+IEVycm9yIChgTXNnIFwiSW52YWxpZCBpbnB1dFwiKSBpblxuICBnbyAoKVxuXG5sZXQgb2Zfc3RyZWFtX3RvX2xpc3Qgc3RyZWFtIGNvbnRlbnRfdHlwZSA9XG4gIG1hdGNoIG9mX3N0cmVhbV90Ymwgc3RyZWFtIGNvbnRlbnRfdHlwZSB3aXRoXG4gIHwgT2sgKG0sIHRibCkgLT5cbiAgICAgIGxldCBhc3NvYyA9XG4gICAgICAgIEhhc2h0YmwuZm9sZCAoZnVuIGsgYiBhIC0+IChrLCBCdWZmZXIuY29udGVudHMgYikgOjogYSkgdGJsIFtdIGluXG4gICAgICBPayAobSwgYXNzb2MpXG4gIHwgRXJyb3IgZSAtPiBFcnJvciBlXG5cbmxldCBvZl9zdHJlYW1fdG9fdHJlZSBzdHJlYW0gY29udGVudF90eXBlID1cbiAgbWF0Y2ggb2Zfc3RyZWFtX3RibCBzdHJlYW0gY29udGVudF90eXBlIHdpdGhcbiAgfCBPayAobSwgdGJsKSAtPlxuICAgICAgbGV0IG0nID0gbWFwIChmdW4gayAtPiBCdWZmZXIuY29udGVudHMgKEhhc2h0YmwuZmluZCB0YmwgaykpIG0gaW5cbiAgICAgIE9rIG0nXG4gIHwgRXJyb3IgZSAtPiBFcnJvciBlXG5cbmxldCBzdHJlYW1fb2Zfc3RyaW5nIHN0ciA9XG4gIGxldCBjb25zdW1lZCA9IHJlZiBmYWxzZSBpblxuICBmdW4gKCkgLT5cbiAgICBpZiAhY29uc3VtZWRcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIGNvbnN1bWVkIDo9IHRydWUgO1xuICAgICAgU29tZSBzdHIpXG5cbmxldCBvZl9zdHJpbmdfdG9fbGlzdCBzdHIgY29udGVudF90eXBlID1cbiAgb2Zfc3RyZWFtX3RvX2xpc3QgKHN0cmVhbV9vZl9zdHJpbmcgc3RyKSBjb250ZW50X3R5cGVcblxubGV0IG9mX3N0cmluZ190b190cmVlIHN0ciBjb250ZW50X3R5cGUgPVxuICBvZl9zdHJlYW1fdG9fdHJlZSAoc3RyZWFtX29mX3N0cmluZyBzdHIpIGNvbnRlbnRfdHlwZVxuXG50eXBlIHBhcnQgPSB7IGhlYWRlciA6IEhlYWRlci50OyBib2R5IDogKHN0cmluZyAqIGludCAqIGludCkgc3RyZWFtIH1cbnR5cGUgbXVsdGlwYXJ0ID0geyBoZWFkZXIgOiBIZWFkZXIudDsgcGFydHMgOiBwYXJ0IGxpc3QgfVxuXG5sZXQgcGFydCA/KGhlYWRlciA9IEhlYWRlci5lbXB0eSkgP2Rpc3Bvc2l0aW9uID9lbmNvZGluZyBzdHJlYW0gPVxuICBsZXQgaGVhZGVyID1cbiAgICBtYXRjaCBkaXNwb3NpdGlvbiB3aXRoXG4gICAgfCBTb21lIHYgLT5cbiAgICAgICAgSGVhZGVyLmFkZCBGaWVsZF9uYW1lLmNvbnRlbnRfZGlzcG9zaXRpb25cbiAgICAgICAgICAoRmllbGQuQ29udGVudF9kaXNwb3NpdGlvbiwgdilcbiAgICAgICAgICBoZWFkZXJcbiAgICB8IE5vbmUgLT4gaGVhZGVyIGluXG4gIGxldCBoZWFkZXIgPVxuICAgIG1hdGNoIGVuY29kaW5nIHdpdGhcbiAgICB8IFNvbWUgdiAtPlxuICAgICAgICBIZWFkZXIuYWRkIEZpZWxkX25hbWUuY29udGVudF90cmFuc2Zlcl9lbmNvZGluZ1xuICAgICAgICAgIChGaWVsZC5Db250ZW50X2VuY29kaW5nLCB2KVxuICAgICAgICAgIGhlYWRlclxuICAgIHwgTm9uZSAtPiBoZWFkZXIgaW5cbiAgbGV0IGNvbnRlbnRfdHlwZSA9IEhlYWRlci5jb250ZW50X3R5cGUgaGVhZGVyIGluXG4gIGxldCBlbmNvZGluZyA9IGNvbnRlbnRfZW5jb2RpbmcgaGVhZGVyIGluXG4gIGlmIG5vdCAoQ29udGVudF90eXBlLmlzX2Rpc2NyZXRlIGNvbnRlbnRfdHlwZSlcbiAgdGhlbiBGbXQuaW52YWxpZF9hcmcgXCJDb250ZW50LXR5cGUgTVVTVCBiZSBkaXNjcmV0ZSB0eXBlIHRvIGEgbWFrZSBhIHBhcnRcIiA7XG4gIGxldCBzdHJlYW0gPVxuICAgIG1hdGNoIGVuY29kaW5nIHdpdGhcbiAgICB8IGBRdW90ZWRfcHJpbnRhYmxlIC0+IHRvX3F1b3RlZF9wcmludGFibGUgc3RyZWFtXG4gICAgfCBgQmFzZTY0IC0+IHRvX2Jhc2U2NCBzdHJlYW1cbiAgICB8IGBCaXQ4IHwgYEJpbmFyeSB8IGBCaXQ3IC0+IHN0cmVhbVxuICAgIHwgYElldGZfdG9rZW4gXyB8IGBYX3Rva2VuIF8gLT4gYXNzZXJ0IGZhbHNlIGluXG4gIHsgaGVhZGVyOyBib2R5ID0gc3RyZWFtIH1cblxubGV0IG11bHRpcGFydF9jb250ZW50X2RlZmF1bHQgPVxuICBsZXQgb3BlbiBDb250ZW50X3R5cGUgaW5cbiAgbWFrZSBgTXVsdGlwYXJ0IChTdWJ0eXBlLnYgXCJmb3JtLWRhdGFcIikgUGFyYW1ldGVycy5lbXB0eVxuXG5sZXQgbXVsdGlwYXJ0IH5ybmcgP2cgPyhoZWFkZXIgPSBIZWFkZXIuZW1wdHkpID9ib3VuZGFyeSBwYXJ0cyA9XG4gIGxldCBib3VuZGFyeSA9XG4gICAgbWF0Y2ggYm91bmRhcnkgd2l0aCBTb21lIGJvdW5kYXJ5IC0+IGJvdW5kYXJ5IHwgTm9uZSAtPiBybmcgP2cgOCBpblxuICBsZXQgYm91bmRhcnkgPSBDb250ZW50X3R5cGUuUGFyYW1ldGVycy52IGJvdW5kYXJ5IGluXG4gIGxldCBjb250ZW50X3R5cGUgPVxuICAgIGlmIEhlYWRlci5leGlzdHMgRmllbGRfbmFtZS5jb250ZW50X3R5cGUgaGVhZGVyXG4gICAgdGhlbiBIZWFkZXIuY29udGVudF90eXBlIGhlYWRlclxuICAgIGVsc2UgbXVsdGlwYXJ0X2NvbnRlbnRfZGVmYXVsdCBpblxuICBsZXQgY29udGVudF90eXBlID1cbiAgICBDb250ZW50X3R5cGUud2l0aF9wYXJhbWV0ZXIgY29udGVudF90eXBlIChcImJvdW5kYXJ5XCIsIGJvdW5kYXJ5KSBpblxuICBsZXQgaGVhZGVyID1cbiAgICBIZWFkZXIucmVwbGFjZSBGaWVsZF9uYW1lLmNvbnRlbnRfdHlwZVxuICAgICAgKEZpZWxkLkNvbnRlbnRfdHlwZSwgY29udGVudF90eXBlKVxuICAgICAgaGVhZGVyIGluXG4gIHsgaGVhZGVyOyBwYXJ0cyB9XG5cbigqIHN0cmVhbSBoZWxwZXJzICopXG5tb2R1bGUgU3RyZWFtID0gc3RydWN0XG4gIGxldCBub25lICgpID0gTm9uZVxuXG4gIGxldCBtYXAgZiBzdHJlYW0gPVxuICAgIGxldCBnbyAoKSA9IG1hdGNoIHN0cmVhbSAoKSB3aXRoIFNvbWUgdiAtPiBTb21lIChmIHYpIHwgTm9uZSAtPiBOb25lIGluXG4gICAgZ29cblxuICBsZXQgb2Zfc3RyaW5nIHggPVxuICAgIGxldCBvbmNlID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IGdvICgpID1cbiAgICAgIGlmICFvbmNlXG4gICAgICB0aGVuIE5vbmVcbiAgICAgIGVsc2UgKFxuICAgICAgICBvbmNlIDo9IHRydWUgO1xuICAgICAgICBTb21lICh4LCAwLCBTdHJpbmcubGVuZ3RoIHgpKSBpblxuICAgIGdvXG5cbiAgbGV0IGNybGYgKCkgPSBvZl9zdHJpbmcgXCJcXHJcXG5cIlxuXG4gIGxldCBjb25jYXQgczAgczEgPVxuICAgIGxldCBjID0gcmVmIHMwIGluXG4gICAgbGV0IHJlYyBnbyAoKSA9XG4gICAgICBtYXRjaCAhYyAoKSB3aXRoXG4gICAgICB8IFNvbWUgeCAtPiBTb21lIHhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGlmICFjID09IHMwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBjIDo9IHMxIDtcbiAgICAgICAgICAgIGdvICgpKVxuICAgICAgICAgIGVsc2UgTm9uZSBpblxuICAgIGdvXG5cbiAgbGV0ICggQCApIGEgYiA9IGNvbmNhdCBhIGJcblxuICBsZXQgb2ZfcGFydCB7IGhlYWRlcjsgYm9keSB9ID1cbiAgICBsZXQgY29udGVudF9zdHJlYW0gPVxuICAgICAgbWFwXG4gICAgICAgIChmdW4gcyAtPiAocywgMCwgU3RyaW5nLmxlbmd0aCBzKSlcbiAgICAgICAgKFByZXR0eW0udG9fc3RyZWFtIEhlYWRlci5FbmNvZGVyLmhlYWRlciBoZWFkZXIpIGluXG4gICAgY29udGVudF9zdHJlYW0gQCBjcmxmICgpIEAgYm9keVxuZW5kXG5cbmxldCB0b19zdHJlYW0gOiBtdWx0aXBhcnQgLT4gSGVhZGVyLnQgKiAoc3RyaW5nICogaW50ICogaW50KSBzdHJlYW0gPVxuIGZ1biB7IGhlYWRlcjsgcGFydHMgfSAtPlxuICBsZXQgYm91bmRhcnkgPVxuICAgIG1hdGNoIENvbnRlbnRfdHlwZS5ib3VuZGFyeSAoSGVhZGVyLmNvbnRlbnRfdHlwZSBoZWFkZXIpIHdpdGhcbiAgICB8IFNvbWUgdiAtPiB2XG4gICAgfCBOb25lIC0+IEZtdC5mYWlsd2l0aCBcIk11bHRpcGFydCBNVVNUIGhhdmUgYSBib3VuZGFyeVwiXG4gICAgKCogWFhYKGRpbm9zYXVyZSk6IHNob3VsZCBuZXZlciBvY2N1ciEgKikgaW5cbiAgbGV0IGJlZ2lubmVyID0gUmZjMjA0Ni5tYWtlX2Rhc2hfYm91bmRhcnkgYm91bmRhcnkgXiBcIlxcclxcblwiIGluXG4gIGxldCBpbm5lciA9IFJmYzIwNDYubWFrZV9kZWxpbWl0ZXIgYm91bmRhcnkgXiBcIlxcclxcblwiIGluXG4gIGxldCBjbG9zZXIgPSBSZmMyMDQ2Lm1ha2VfY2xvc2VfZGVsaW1pdGVyIGJvdW5kYXJ5IF4gXCJcXHJcXG5cIiBpblxuXG4gIGxldCByZWMgZ28gc3RyZWFtID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFN0cmVhbS5ub25lXG4gICAgfCBbIHggXSAtPiBTdHJlYW0uKHN0cmVhbSBAIG9mX3BhcnQgeCBAIG9mX3N0cmluZyBjbG9zZXIpXG4gICAgfCB4IDo6IHIgLT5cbiAgICAgICAgbGV0IHN0cmVhbSA9IFN0cmVhbS4oc3RyZWFtIEAgb2ZfcGFydCB4IEAgb2Zfc3RyaW5nIGlubmVyKSBpblxuICAgICAgICBnbyBzdHJlYW0gciBpblxuXG4gIChoZWFkZXIsIGdvIChTdHJlYW0ub2Zfc3RyaW5nIGJlZ2lubmVyKSBwYXJ0cylcbiJdfQ==
