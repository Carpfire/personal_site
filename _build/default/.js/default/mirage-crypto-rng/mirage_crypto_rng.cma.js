// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Mirage_crypto_rng__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Mirage_crypto_rng = [0];
   runtime.caml_register_global(0, Mirage_crypto_rng, "Mirage_crypto_rng__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto_rng__Rng
//# unitInfo: Requires: Stdlib, Stdlib__Atomic, Stdlib__Bytes, Stdlib__Option, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    setup_rng =
      '\nTo initialize the RNG with a default generator, and set up entropy collection and periodic reseeding as a background task, do the following:\n  If you are using MirageOS, use the random device in config.ml: `let main = Mirage.main "Unikernel.Main" (random @-> job)`, and `let () = register "my_unikernel" [main $ default_random]`. \n  If you are using Lwt, execute `Mirage_crypto_rng_lwt.initialize (module Mirage_crypto_rng.Fortuna)` at startup. \n  If you are using Async, execute `Mirage_crypto_rng_async.initialize (module Mirage_crypto_rng.Fortuna)` at startup. \n  If you are using Eio, execute in one of the fibers `Mirage_crypto_rng_eio.run (module Fortuna) env` (`env` from `Eio_main.run`).\n   \n  Otherwise, there is no periodic reseeding. For an initial seed from getrandom(), execute `Mirage_crypto_rng_unix.initialize (module Mirage_crypto_rng.Fortuna)`. You can use `Mirage_crypto_rng.accumulate` and `Mirage_crypto_rng.reseed` to reseed the RNG manually.',
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Unseeded_generator =
      [248, "Mirage_crypto_rng__Rng.Unseeded_generator", caml_fresh_oo_id(0)],
    No_default_generator =
      [248,
       "Mirage_crypto_rng__Rng.No_default_generator",
       caml_fresh_oo_id(0)],
    _b_ = [0, 0],
    cst_buffer_too_short = "buffer too short",
    cst_The_RNG_has_not_been_seede = "The RNG has not been seeded.",
    cst_The_default_generator_is_n =
      "The default generator is not yet initialized. ";
   function _a_(param){
    return param === Unseeded_generator
            ? [0,
              caml_call2
               (Stdlib[28], cst_The_RNG_has_not_been_seede, setup_rng)]
            : param
              === No_default_generator
              ? [0,
                caml_call2
                 (Stdlib[28], cst_The_default_generator_is_n, setup_rng)]
              : 0;
   }
   caml_call1(Stdlib_Printexc[9], _a_);
   function create(g, seed, opt, time, m){
    if(opt) var sth = opt[1], strict = sth; else var strict = 0;
    var
     _d_ = caml_call2(m[2], time, 0),
     g$0 = caml_call2(Stdlib_Option[3], g, _d_),
     _e_ = caml_call1(m[4], g$0);
    caml_call2(Stdlib_Option[9], _e_, seed);
    return [0, [0, g$0, strict, m]];
   }
   var default_generator = caml_call1(Stdlib_Atomic[1], 0);
   function set_default_generator(g){
    return caml_call2(Stdlib_Atomic[3], default_generator, [0, g]);
   }
   function unset_default_generator(param){
    return caml_call2(Stdlib_Atomic[3], default_generator, 0);
   }
   function default_generator$0(param){
    var match = caml_call1(Stdlib_Atomic[2], default_generator);
    if(! match) throw caml_maybe_attach_backtrace(No_default_generator, 1);
    var g = match[1];
    return g;
   }
   function get(param){
    if(! param) return default_generator$0(0);
    var g = param[1];
    return g;
   }
   function generate_into(opt, b, _c_, n){
    if(opt) var sth = opt[1], g = sth; else var g = default_generator$0(0);
    if(_c_) var sth$0 = _c_[1], off = sth$0; else var off = 0;
    var match = g[1], m = match[3], g$0 = match[1];
    if((runtime.caml_ml_bytes_length(b) - off | 0) < n)
     caml_call1(Stdlib[1], cst_buffer_too_short);
    return caml_call4(m[3], g$0, b, off, n);
   }
   function generate(g, n){
    var data = runtime.caml_create_bytes(n);
    generate_into(g, data, _b_, n);
    return caml_call1(Stdlib_Bytes[44], data);
   }
   function reseed(opt, cs){
    if(opt) var sth = opt[1], g = sth; else var g = default_generator$0(0);
    var match = g[1], m = match[3], g$0 = match[1];
    return caml_call2(m[4], g$0, cs);
   }
   function accumulate(g, source){
    var match = get(g)[1], m = match[3], g$0 = match[1];
    return caml_call2(m[5], g$0, source);
   }
   function seeded(g){
    var match = get(g)[1], m = match[3], g$0 = match[1];
    return caml_call1(m[6], g$0);
   }
   function block(g){var m = get(g)[1][3]; return m[1];}
   function pools(g){var m = get(g)[1][3]; return m[7];}
   function strict(g){var s = get(g)[1][2]; return s;}
   var
    Mirage_crypto_rng_Rng =
      [0,
       Unseeded_generator,
       No_default_generator,
       setup_rng,
       create,
       default_generator,
       set_default_generator,
       unset_default_generator,
       default_generator$0,
       get,
       generate_into,
       generate,
       reseed,
       accumulate,
       seeded,
       block,
       pools,
       strict];
   runtime.caml_register_global
    (12, Mirage_crypto_rng_Rng, "Mirage_crypto_rng__Rng");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto_rng__Entropy
//# unitInfo: Requires: Mirage_crypto_rng__Rng, Stdlib, Stdlib__Atomic, Stdlib__Bytes, Stdlib__Format, Stdlib__List, Stdlib__Set, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Mirage_crypto_rng_Rng = global_data.Mirage_crypto_rng__Rng,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Set = global_data.Stdlib__Set,
    match = runtime.mc_cpu_rng_type(0),
    cst_rdseed = "rdseed",
    cst_rdrand = "rdrand",
    cst_timer = "timer",
    cst_Mirage_crypto_rng_Entropy_ =
      "Mirage_crypto_rng.Entropy: 0 is a bad CPU RNG value",
    _b_ = [0, [12, 91, [4, 0, 0, 0, [11, "] ", [2, 0, 0]]]], "[%d] %s"],
    _a_ = [0, "rng/entropy.ml", 43, 11],
    _e_ = [0, 687466103, 0],
    _f_ = [0, 698752579, 0],
    _g_ = [0, 687466103, [0, 698752579, 0]],
    _d_ = [1, 404463778],
    _c_ = [1, 404463778];
   if(3 < match >>> 0)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   switch(match){
     case 0:
      var cpu_rng = 0; break;
     case 1:
      var cpu_rng = _e_; break;
     case 2:
      var cpu_rng = _f_; break;
     default: var cpu_rng = _g_;
   }
   var Cpu_native = [0, cpu_rng];
   function compare(param, _w_){
    var bn = _w_[2], an = param[2];
    return caml_call2(Stdlib_String[10], an, bn);
   }
   var
    S = caml_call1(Stdlib_Set[1], [0, compare]),
    sources = caml_call1(Stdlib_Atomic[1], S[1]);
   function register_source(name){
    for(;;){
     var
      sources$0 = caml_call1(Stdlib_Atomic[2], sources),
      n = caml_call1(S[9], sources$0),
      source = [0, n, name],
      _v_ = caml_call2(S[2], source, sources$0);
     if(caml_call3(Stdlib_Atomic[5], sources, sources$0, _v_)) return source;
    }
   }
   function id(param){var idx = param[1]; return idx;}
   function sources$0(param){
    var _u_ = caml_call1(Stdlib_Atomic[2], sources);
    return caml_call1(S[10], _u_);
   }
   function pp_source(ppf, param){
    var name = param[2], idx = param[1];
    return caml_call4(Stdlib_Format[137], ppf, _b_, idx, name);
   }
   function cpu_rng$0(param){
    return 698752579 <= param
            ? function(_s_){return runtime.mc_cpu_rdseed(_s_);}
            : function(_t_){return runtime.mc_cpu_rdrand(_t_);};
   }
   function random(preferred){
    var xs = Cpu_native[1];
    if(! xs) return 0;
    if(caml_call2(Stdlib_List[37], preferred, xs)) return [0, preferred];
    var y = xs[1];
    return [0, y];
   }
   function write_header(source, data){
    caml_call3(Stdlib_Bytes[73], data, 0, source);
    return caml_call3
            (Stdlib_Bytes[73],
             data,
             1,
             runtime.caml_ml_bytes_length(data) - 2 | 0);
   }
   function header(source, data){
    var hdr = caml_create_bytes(2 + caml_ml_string_length(data) | 0);
    runtime.caml_blit_string(data, 0, hdr, 2, caml_ml_string_length(data));
    write_header(source, hdr);
    return caml_call1(Stdlib_Bytes[44], hdr);
   }
   function whirlwind_bootstrap(id){
    var buf = caml_create_bytes(202), i = 0;
    for(;;){
     var tsc = runtime.mc_cycle_counter(0);
     caml_call3(Stdlib_Bytes[77], buf, (i + 1 | 0) * 2 | 0, tsc);
     var _p_ = tsc % 1024 | 0, _o_ = 1;
     if(_p_ >= 1){
      var j = _o_;
      for(;;){
       runtime.caml_div(tsc, j);
       var _r_ = j + 1 | 0;
       if(_p_ === j) break;
       var j = _r_;
      }
     }
     var _q_ = i + 1 | 0;
     if(99 === i){
      write_header(id, buf);
      return caml_call1(Stdlib_Bytes[44], buf);
     }
     var i = _q_;
    }
   }
   var match$0 = random(698752579);
   if(match$0)
    var
     insn = match$0[1],
     cpu_rng_bootstrap =
       function(id){
        var r = cpu_rng$0(insn)(0);
        if(0 === r) caml_call1(Stdlib[2], cst_Mirage_crypto_rng_Entropy_);
        var buf = caml_create_bytes(10);
        caml_call3(Stdlib_Bytes[86], buf, 2, caml_int64_of_int32(r));
        write_header(id, buf);
        return caml_call1(Stdlib_Bytes[44], buf);
       },
     cpu_rng_bootstrap$0 = [0, cpu_rng_bootstrap];
   else
    var cpu_rng_bootstrap$0 = _d_;
   function bootstrap(id){
    if(0 !== cpu_rng_bootstrap$0[0]) return whirlwind_bootstrap(id);
    var cpu_rng_bootstrap = cpu_rng_bootstrap$0[1];
    try{var _m_ = caml_call1(cpu_rng_bootstrap, id); return _m_;}
    catch(_n_){
     var _l_ = caml_wrap_exception(_n_);
     if(_l_[1] === Stdlib[7]) return whirlwind_bootstrap(id);
     throw caml_maybe_attach_backtrace(_l_, 0);
    }
   }
   function interrupt_hook(param){
    var buf = caml_create_bytes(4), a = runtime.mc_cycle_counter(0);
    caml_call3(Stdlib_Bytes[83], buf, 0, a);
    return caml_call1(Stdlib_Bytes[44], buf);
   }
   function timer_accumulator(g){
    if(g)
     var g$0 = g[1], g$1 = [0, g$0];
    else
     var g$1 = [0, caml_call1(Mirage_crypto_rng_Rng[8], 0)];
    var
     source = register_source(cst_timer),
     handle = caml_call2(Mirage_crypto_rng_Rng[13], g$1, source)[2];
    return function(param){return caml_call1(handle, interrupt_hook(0));};
   }
   function feed_pools(g, source, f){
    if(g)
     var g$0 = g[1], g$1 = [0, g$0];
    else
     var g$1 = [0, caml_call1(Mirage_crypto_rng_Rng[8], 0)];
    var
     handle = caml_call2(Mirage_crypto_rng_Rng[13], g$1, source)[2],
     _j_ = caml_call1(Mirage_crypto_rng_Rng[16], g$1) - 1 | 0,
     _i_ = 0;
    if(_j_ >= 0){
     var i = _i_;
     for(;;){
      caml_call1(handle, caml_call1(f, 0));
      var _k_ = i + 1 | 0;
      if(_j_ === i) break;
      var i = _k_;
     }
    }
    return 0;
   }
   var match$1 = random(687466103);
   if(match$1)
    var
     insn$0 = match$1[1],
     cpu_rng$1 =
       function(g){
        var
         randomf = cpu_rng$0(insn$0),
         s = 698752579 <= insn$0 ? cst_rdseed : cst_rdrand,
         source = register_source(s);
        function f(param){
         var
          buf = caml_create_bytes(8),
          _h_ = caml_int64_of_int32(randomf(0));
         caml_call3(Stdlib_Bytes[86], buf, 0, _h_);
         return caml_call1(Stdlib_Bytes[44], buf);
        }
        return function(param){return feed_pools(g, source, f);};
       },
     cpu_rng$2 = [0, cpu_rng$1];
   else
    var cpu_rng$2 = _c_;
   var
    Mirage_crypto_rng_Entropy =
      [0,
       Cpu_native,
       S,
       sources,
       register_source,
       id,
       sources$0,
       pp_source,
       random,
       write_header,
       header,
       whirlwind_bootstrap,
       cpu_rng_bootstrap$0,
       bootstrap,
       interrupt_hook,
       timer_accumulator,
       feed_pools,
       cpu_rng$2];
   runtime.caml_register_global
    (20, Mirage_crypto_rng_Entropy, "Mirage_crypto_rng__Entropy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto_rng__Fortuna
//# unitInfo: Requires: Digestif, Mirage_crypto, Mirage_crypto_rng__Rng, Stdlib__Array, Stdlib__Bytes, Stdlib__Int64, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    now = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    min_time_duration = runtime.caml_int64_create_lo_mi_hi(10144256, 59, 0),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Mirage_crypto = global_data.Mirage_crypto,
    Mirage_crypto_rng_Rng = global_data.Mirage_crypto_rng__Rng,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Digestif = global_data.Digestif,
    empty = Digestif[4][2],
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _a_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(0, 0, 0)];
   function get(t){
    var
     _A_ = caml_call1(Digestif[4][10], t),
     _B_ = caml_call1(Digestif[4][39], _A_),
     _C_ = caml_call3(Digestif[4][12], 0, 0, _B_);
    return caml_call1(Digestif[4][39], _C_);
   }
   function digest(x){
    var
     _x_ = caml_call3(Digestif[4][12], 0, 0, x),
     _y_ = caml_call1(Digestif[4][39], _x_),
     _z_ = caml_call3(Digestif[4][12], 0, 0, _y_);
    return caml_call1(Digestif[4][39], _z_);
   }
   function digesti(i){
    var
     _u_ = caml_call1(Digestif[4][15], i),
     _v_ = caml_call1(Digestif[4][39], _u_),
     _w_ = caml_call3(Digestif[4][12], 0, 0, _v_);
    return caml_call1(Digestif[4][39], _w_);
   }
   var
    feedi = Digestif[4][8],
    SHAd256 = [0, empty, get, digest, digesti, feedi],
    block = 16,
    min_pool_size = 64,
    pools = 32;
   function create(time, param){
    var
     k = caml_call2(Stdlib_String[1], 32, 0),
     _t_ = runtime.caml_make_vect(32, SHAd256[1]);
    return [0,
            _b_,
            k,
            caml_call1(Mirage_crypto[4][3][1], k),
            _t_,
            0,
            0,
            _a_,
            time];
   }
   function seeded(g){
    var
     match = g[1],
     hi = match[2],
     lo = match[1],
     _r_ = caml_call2(Stdlib_Int64[17], lo, _c_),
     _s_ = _r_ ? caml_call2(Stdlib_Int64[17], hi, _d_) : _r_;
    return 1 - _s_;
   }
   function set_key(g, sec){
    g[2] = sec;
    g[3] = caml_call1(Mirage_crypto[4][3][1], sec);
    return 0;
   }
   function reseedi(g, iter){
    function _q_(f){caml_call1(f, g[2]); return caml_call1(iter, f);}
    set_key(g, caml_call1(SHAd256[4], _q_));
    g[1] = caml_call2(Mirage_crypto[4][3][4], g[1], _e_);
    return 0;
   }
   function iter1(a, f){return caml_call1(f, a);}
   function reseed(g, cs){
    return reseedi(g, function(_p_){return iter1(cs, _p_);});
   }
   function generate_rekey(g, buf, off, len){
    var
     b = caml_call2(Mirage_crypto[1][1], len, block) + 2 | 0,
     n = b * 16 | 0,
     r = caml_call3(Mirage_crypto[4][3][7], g[3], g[1], n);
    runtime.caml_blit_string(r, 0, buf, off, len);
    var r2 = caml_call3(Stdlib_String[16], r, n - 32 | 0, 32);
    set_key(g, r2);
    g[1] =
     caml_call2(Mirage_crypto[4][3][4], g[1], runtime.caml_int64_of_int32(b));
    return 0;
   }
   function add_pool_entropy(g){
    var _l_ = 64 < g[5] ? 1 : 0;
    if(_l_){
     var match = g[8];
     if(match)
      var
       f = match[1],
       now$0 = caml_call1(f, 0),
       now$1 = now$0,
       should_reseed =
         runtime.caml_greaterthan
          (runtime.caml_int64_sub(now$0, g[7]), min_time_duration);
     else
      var now$1 = now, should_reseed = 1;
     if(should_reseed){
      g[6] = g[6] + 1 | 0;
      g[7] = now$1;
      g[5] = 0;
      return reseedi
              (g,
               function(add){
                var i = 0;
                for(;;){
                 if(0 === (g[6] & ((1 << i) - 1 | 0))){
                  var _m_ = caml_check_bound(g[4], i)[1 + i];
                  caml_call1(add, caml_call1(SHAd256[2], _m_));
                  var _n_ = SHAd256[1];
                  caml_check_bound(g[4], i)[1 + i] = _n_;
                 }
                 var _o_ = i + 1 | 0;
                 if(31 === i) return 0;
                 var i = _o_;
                }
               });
     }
     var should_reseed$0 = should_reseed;
    }
    else
     var should_reseed$0 = _l_;
    return should_reseed$0;
   }
   function generate_into(g, buf, off, len){
    add_pool_entropy(g);
    if(1 - seeded(g))
     throw caml_maybe_attach_backtrace(Mirage_crypto_rng_Rng[1], 1);
    var off$0 = off, i = len;
    for(;;){
     if(0 >= i) return 0;
     var n = caml_call2(Mirage_crypto[1][2], i, 65536);
     generate_rekey(g, buf, off$0, n);
     var i$0 = i - n | 0, off$1 = off$0 + n | 0, off$0 = off$1, i = i$0;
    }
   }
   function add(g, param, pool, data){
    var
     source = param[1],
     buf = runtime.caml_create_bytes(2),
     pool$0 = pool & 31,
     source$0 = source & 255;
    caml_call3(Stdlib_Bytes[73], buf, 0, source$0);
    caml_call3(Stdlib_Bytes[73], buf, 1, caml_ml_string_length(data));
    var
     _f_ = caml_call1(Stdlib_Bytes[44], buf),
     _g_ = caml_call2(Mirage_crypto[1][4], _f_, data),
     _h_ = caml_check_bound(g[4], pool$0)[1 + pool$0],
     _i_ = caml_call2(SHAd256[5], _h_, _g_);
    caml_check_bound(g[4], pool$0)[1 + pool$0] = _i_;
    var
     _j_ = 0 === pool$0 ? 1 : 0,
     _k_ = _j_ ? (g[5] = g[5] + caml_ml_string_length(data) | 0, 0) : _j_;
    return _k_;
   }
   function accumulate(g, source){
    var pool = [0, 0];
    return [0,
            3254561,
            function(buf){add(g, source, pool[1], buf); pool[1]++; return 0;}];
   }
   var
    Mirage_crypto_rng_Fortuna =
      [0,
       SHAd256,
       block,
       min_pool_size,
       min_time_duration,
       pools,
       create,
       seeded,
       set_key,
       reseedi,
       iter1,
       reseed,
       generate_rekey,
       add_pool_entropy,
       generate_into,
       add,
       accumulate];
   runtime.caml_register_global
    (13, Mirage_crypto_rng_Fortuna, "Mirage_crypto_rng__Fortuna");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto_rng__Hmac_drbg
//# unitInfo: Requires: Mirage_crypto, Mirage_crypto_rng__Rng, Stdlib, Stdlib__Bytes, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_blit_string = runtime.caml_blit_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    bx01 = "\x01",
    bx00 = "\0",
    Stdlib = global_data.Stdlib,
    Mirage_crypto_rng_Rng = global_data.Mirage_crypto_rng__Rng,
    Mirage_crypto = global_data.Mirage_crypto,
    Stdlib_String = global_data.Stdlib__String,
    cst_Implement_Hmac_drbg_accumu = "Implement Hmac_drbg.accumulate...";
   function Make(H){
    var
     block = H[1],
     k0 = caml_call2(Stdlib_String[1], H[1], 0),
     v0 = caml_call2(Stdlib_String[1], H[1], 1);
    function create(param, _l_){return [0, k0, v0, 0];}
    function seeded(g){return g[3];}
    function reseed(g, buf){
     var
      v = g[2],
      k = g[1],
      _f_ = caml_call2(Stdlib_String[7], cst, [0, v, [0, bx00, [0, buf, 0]]]),
      _g_ = caml_call3(caml_call1(H[21], k), 0, 0, _f_),
      k$0 = caml_call1(H[39], _g_),
      _h_ = caml_call4(H[21], k$0, 0, 0, v),
      v$0 = caml_call1(H[39], _h_),
      _i_ =
        caml_call2(Stdlib_String[7], cst$0, [0, v$0, [0, bx01, [0, buf, 0]]]),
      _j_ = caml_call3(caml_call1(H[21], k$0), 0, 0, _i_),
      k$1 = caml_call1(H[39], _j_),
      _k_ = caml_call4(H[21], k$1, 0, 0, v$0),
      v$1 = caml_call1(H[39], _k_);
     g[1] = k$1;
     g[2] = v$1;
     g[3] = 1;
     return 0;
    }
    function generate_into(g, buf, off, len){
     if(1 - g[3])
      throw caml_maybe_attach_backtrace(Mirage_crypto_rng_Rng[1], 1);
     var
      i$1 = caml_call2(Mirage_crypto[1][1], len, H[1]),
      v$2 = g[2],
      k = g[1];
     a:
     {
      var off$0 = off, v = v$2, i = i$1;
      for(;;){
       if(0 === i){var v$3 = v; break a;}
       if(1 === i) break;
       var _b_ = caml_call4(H[21], k, 0, 0, v), v$1 = caml_call1(H[39], _b_);
       caml_blit_string(v$1, 0, buf, off$0, H[1]);
       var
        i$0 = i - 1 | 0,
        off$1 = off$0 + H[1] | 0,
        off$0 = off$1,
        v = v$1,
        i = i$0;
      }
      var
       _a_ = caml_call4(H[21], k, 0, 0, v),
       v$0 = caml_call1(H[39], _a_),
       rem = runtime.caml_mod(len, H[1]),
       len$0 = 0 === rem ? H[1] : rem;
      caml_blit_string(v$0, 0, buf, off$0, len$0);
      var v$3 = v$0;
     }
     var
      _c_ = caml_call2(Stdlib[28], v$3, bx00),
      _d_ = caml_call4(H[21], g[1], 0, 0, _c_);
     g[1] = caml_call1(H[39], _d_);
     var _e_ = caml_call4(H[21], g[1], 0, 0, v$3);
     g[2] = caml_call1(H[39], _e_);
     return 0;
    }
    function accumulate(param){
     return caml_call1(Stdlib[1], cst_Implement_Hmac_drbg_accumu);
    }
    return [0,
            block,
            bx00,
            bx01,
            k0,
            v0,
            create,
            seeded,
            reseed,
            generate_into,
            accumulate,
            0];
   }
   var Mirage_crypto_rng_Hmac_drbg = [0, Make];
   runtime.caml_register_global
    (9, Mirage_crypto_rng_Hmac_drbg, "Mirage_crypto_rng__Hmac_drbg");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto_rng
//# unitInfo: Requires: Mirage_crypto_rng__Entropy, Mirage_crypto_rng__Fortuna, Mirage_crypto_rng__Hmac_drbg, Mirage_crypto_rng__Rng
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Mirage_crypto_rng_Rng = global_data.Mirage_crypto_rng__Rng,
    Mirage_crypto_rng_Hmac_drbg = global_data.Mirage_crypto_rng__Hmac_drbg,
    Mirage_crypto_rng_Fortuna = global_data.Mirage_crypto_rng__Fortuna,
    Mirage_crypto_rng_Entropy = global_data.Mirage_crypto_rng__Entropy,
    Unseeded_generator = Mirage_crypto_rng_Rng[1],
    No_default_generator = Mirage_crypto_rng_Rng[2],
    create = Mirage_crypto_rng_Rng[4],
    set_default_generator = Mirage_crypto_rng_Rng[6],
    unset_default_generator = Mirage_crypto_rng_Rng[7],
    default_generator = Mirage_crypto_rng_Rng[8],
    generate_into = Mirage_crypto_rng_Rng[10],
    generate = Mirage_crypto_rng_Rng[11],
    reseed = Mirage_crypto_rng_Rng[12],
    accumulate = Mirage_crypto_rng_Rng[13],
    seeded = Mirage_crypto_rng_Rng[14],
    block = Mirage_crypto_rng_Rng[15],
    pools = Mirage_crypto_rng_Rng[16],
    strict = Mirage_crypto_rng_Rng[17],
    _a_ = Mirage_crypto_rng_Hmac_drbg[1];
   function _b_(_c_){
    var _d_ = caml_call1(_a_, _c_);
    return [0, _d_[1], _d_[6], _d_[9], _d_[8], _d_[10], _d_[7], _d_[11]];
   }
   var
    Mirage_crypto_rng =
      [0,
       Unseeded_generator,
       No_default_generator,
       [0,
        Mirage_crypto_rng_Entropy[6],
        Mirage_crypto_rng_Entropy[7],
        Mirage_crypto_rng_Entropy[4],
        Mirage_crypto_rng_Entropy[11],
        Mirage_crypto_rng_Entropy[12],
        Mirage_crypto_rng_Entropy[13],
        Mirage_crypto_rng_Entropy[14],
        Mirage_crypto_rng_Entropy[15],
        Mirage_crypto_rng_Entropy[16],
        Mirage_crypto_rng_Entropy[17],
        Mirage_crypto_rng_Entropy[5],
        Mirage_crypto_rng_Entropy[10]],
       [0,
        Mirage_crypto_rng_Fortuna[2],
        Mirage_crypto_rng_Fortuna[6],
        Mirage_crypto_rng_Fortuna[14],
        Mirage_crypto_rng_Fortuna[11],
        Mirage_crypto_rng_Fortuna[16],
        Mirage_crypto_rng_Fortuna[7],
        Mirage_crypto_rng_Fortuna[5]],
       _b_,
       create,
       default_generator,
       set_default_generator,
       unset_default_generator,
       generate_into,
       generate,
       block,
       reseed,
       accumulate,
       seeded,
       pools,
       strict];
   runtime.caml_register_global(4, Mirage_crypto_rng, "Mirage_crypto_rng");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJtaXJhZ2VfY3J5cHRvX3JuZy5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V0dXBfcm5nIiwiY3JlYXRlIiwiZyIsInNlZWQiLCJvcHQiLCJ0aW1lIiwibSIsInN0aCIsInN0cmljdCIsImckMCIsImRlZmF1bHRfZ2VuZXJhdG9yIiwic2V0X2RlZmF1bHRfZ2VuZXJhdG9yIiwidW5zZXRfZGVmYXVsdF9nZW5lcmF0b3IiLCJkZWZhdWx0X2dlbmVyYXRvciQwIiwiZ2V0IiwiZ2VuZXJhdGVfaW50byIsImIiLCJuIiwic3RoJDAiLCJvZmYiLCJnZW5lcmF0ZSIsImRhdGEiLCJyZXNlZWQiLCJjcyIsImFjY3VtdWxhdGUiLCJzb3VyY2UiLCJzZWVkZWQiLCJibG9jayIsInBvb2xzIiwicyIsImNwdV9ybmciLCJjb21wYXJlIiwiYm4iLCJhbiIsInNvdXJjZXMiLCJyZWdpc3Rlcl9zb3VyY2UiLCJuYW1lIiwic291cmNlcyQwIiwiaWQiLCJpZHgiLCJwcF9zb3VyY2UiLCJwcGYiLCJjcHVfcm5nJDAiLCJyYW5kb20iLCJwcmVmZXJyZWQiLCJ4cyIsInkiLCJ3cml0ZV9oZWFkZXIiLCJoZWFkZXIiLCJoZHIiLCJ3aGlybHdpbmRfYm9vdHN0cmFwIiwiYnVmIiwiaSIsInRzYyIsImoiLCJpbnNuIiwiY3B1X3JuZ19ib290c3RyYXAiLCJyIiwiY3B1X3JuZ19ib290c3RyYXAkMCIsImJvb3RzdHJhcCIsImludGVycnVwdF9ob29rIiwiYSIsInRpbWVyX2FjY3VtdWxhdG9yIiwiZyQxIiwiaGFuZGxlIiwiZmVlZF9wb29scyIsImYiLCJpbnNuJDAiLCJjcHVfcm5nJDEiLCJyYW5kb21mIiwiY3B1X3JuZyQyIiwibm93IiwibWluX3RpbWVfZHVyYXRpb24iLCJlbXB0eSIsInQiLCJkaWdlc3QiLCJ4IiwiZGlnZXN0aSIsImZlZWRpIiwibWluX3Bvb2xfc2l6ZSIsImsiLCJoaSIsImxvIiwic2V0X2tleSIsInNlYyIsInJlc2VlZGkiLCJpdGVyIiwiaXRlcjEiLCJnZW5lcmF0ZV9yZWtleSIsImxlbiIsInIyIiwiYWRkX3Bvb2xfZW50cm9weSIsIm5vdyQwIiwibm93JDEiLCJzaG91bGRfcmVzZWVkIiwiYWRkIiwic2hvdWxkX3Jlc2VlZCQwIiwib2ZmJDAiLCJpJDAiLCJvZmYkMSIsInBvb2wiLCJwb29sJDAiLCJzb3VyY2UkMCIsImJ4MDEiLCJieDAwIiwiazAiLCJ2MCIsInYiLCJrJDAiLCJ2JDAiLCJrJDEiLCJ2JDEiLCJ2JDMiLCJyZW0iLCJsZW4kMCJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL21pcmFnZS1jcnlwdG8tcm5nL3JuZy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL21pcmFnZS1jcnlwdG8tcm5nL2VudHJvcHkubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9taXJhZ2UtY3J5cHRvLXJuZy9mb3J0dW5hLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbWlyYWdlLWNyeXB0by1ybmcvaG1hY19kcmJnLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHQUVBOztJQUlJQTs7Ozs7OztJQUpKOztJQUVBOzs7Ozs7Ozs7O0lBdUJtQzs7Y0FFeEI7NERBdkJQQTs7OztnQkF5Qk87OERBekJQQTs7R0EwQlk7R0FMUDtZQXFCTEMsT0FBaUJDLEdBQUdDLE1BQU9DLEtBQWVDLE1BQU1DO0lBQ2xELEdBRDZCRixTQUFPRyxNQUFQSCxRQUFBSSxTQUFPRCxjQUFQQztJQUVHO0tBQUEsTUFBQSxXQUZrQkYsTUFBTkQ7S0FFeENJLE1BQUksNkJBRldQO0tBR1AsTUFBQSxXQUhzQ0ksTUFFOUNHO0lBQ0osa0NBSHNCTjtJQUl0QixlQUZJTSxLQUZ5QkQsUUFBcUJGO0dBSTFCO0dBRUQsSUFBckJJLG9CQUFx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Q0EsVUFBQSxrQkFuQlVBLFlBaUJiOEc7S0FqQmE5RyxPQW1CVjs7SUFBMkM7YUFHaERzQjtLQUFrQixPQUFBO0lBQStDO0lBaER4QztZQU96Qkc7WUFFQzZFO1lBQU1EO1lBRVBFO1lBQ0FDO1lBRUF6RztZQUVBeUI7WUFFQUo7WUFRQVA7WUFzQkFTOzs7Ozs7O0U7Ozs7Ozs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsidHlwZSBzb3VyY2UgPSBpbnQgKiBzdHJpbmdcblxuZXhjZXB0aW9uIFVuc2VlZGVkX2dlbmVyYXRvclxuXG5leGNlcHRpb24gTm9fZGVmYXVsdF9nZW5lcmF0b3JcblxubGV0IHNldHVwX3JuZyA9XG4gIFwiXFxuVG8gaW5pdGlhbGl6ZSB0aGUgUk5HIHdpdGggYSBkZWZhdWx0IGdlbmVyYXRvciwgYW5kIHNldCB1cCBlbnRyb3B5IFxcXG4gICBjb2xsZWN0aW9uIGFuZCBwZXJpb2RpYyByZXNlZWRpbmcgYXMgYSBiYWNrZ3JvdW5kIHRhc2ssIGRvIHRoZSBcXFxuICAgZm9sbG93aW5nOlxcXG4gICBcXG4gIElmIHlvdSBhcmUgdXNpbmcgTWlyYWdlT1MsIHVzZSB0aGUgcmFuZG9tIGRldmljZSBpbiBjb25maWcubWw6IFxcXG4gICBgbGV0IG1haW4gPSBNaXJhZ2UubWFpbiBcXFwiVW5pa2VybmVsLk1haW5cXFwiIChyYW5kb20gQC0+IGpvYilgLCBcXFxuICAgYW5kIGBsZXQgKCkgPSByZWdpc3RlciBcXFwibXlfdW5pa2VybmVsXFxcIiBbbWFpbiAkIGRlZmF1bHRfcmFuZG9tXWAuIFxcXG4gICBcXG4gIElmIHlvdSBhcmUgdXNpbmcgTHd0LCBleGVjdXRlIFxcXG4gICBgTWlyYWdlX2NyeXB0b19ybmdfbHd0LmluaXRpYWxpemUgKG1vZHVsZSBNaXJhZ2VfY3J5cHRvX3JuZy5Gb3J0dW5hKWAgXFxcbiAgIGF0IHN0YXJ0dXAuIFxcXG4gICBcXG4gIElmIHlvdSBhcmUgdXNpbmcgQXN5bmMsIGV4ZWN1dGUgXFxcbiAgIGBNaXJhZ2VfY3J5cHRvX3JuZ19hc3luYy5pbml0aWFsaXplIChtb2R1bGUgTWlyYWdlX2NyeXB0b19ybmcuRm9ydHVuYSlgIFxcXG4gICBhdCBzdGFydHVwLiBcXFxuICAgXFxuICBJZiB5b3UgYXJlIHVzaW5nIEVpbywgZXhlY3V0ZSBpbiBvbmUgb2YgdGhlIGZpYmVycyBcXFxuICAgYE1pcmFnZV9jcnlwdG9fcm5nX2Vpby5ydW4gKG1vZHVsZSBGb3J0dW5hKSBlbnZgIChgZW52YCBmcm9tIGBFaW9fbWFpbi5ydW5gKS5cbiAgIFxcbiAgT3RoZXJ3aXNlLCB0aGVyZSBpcyBubyBwZXJpb2RpYyByZXNlZWRpbmcuIEZvciBhbiBpbml0aWFsIHNlZWQgZnJvbSBcXFxuICAgZ2V0cmFuZG9tKCksIGV4ZWN1dGUgXFxcbiAgIGBNaXJhZ2VfY3J5cHRvX3JuZ191bml4LmluaXRpYWxpemUgKG1vZHVsZSBNaXJhZ2VfY3J5cHRvX3JuZy5Gb3J0dW5hKWAuIFxcXG4gICBZb3UgY2FuIHVzZSBgTWlyYWdlX2NyeXB0b19ybmcuYWNjdW11bGF0ZWAgYW5kIGBNaXJhZ2VfY3J5cHRvX3JuZy5yZXNlZWRgIFxcXG4gICB0byByZXNlZWQgdGhlIFJORyBtYW51YWxseS5cIlxuXG5sZXQgKCkgPSBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIChmdW5jdGlvblxuICAgIHwgVW5zZWVkZWRfZ2VuZXJhdG9yIC0+XG4gICAgICBTb21lIChcIlRoZSBSTkcgaGFzIG5vdCBiZWVuIHNlZWRlZC5cIiBeIHNldHVwX3JuZylcbiAgICB8IE5vX2RlZmF1bHRfZ2VuZXJhdG9yIC0+XG4gICAgICBTb21lIChcIlRoZSBkZWZhdWx0IGdlbmVyYXRvciBpcyBub3QgeWV0IGluaXRpYWxpemVkLiBcIiBeIHNldHVwX3JuZylcbiAgICB8IF8gLT4gTm9uZSlcblxubW9kdWxlIHR5cGUgR2VuZXJhdG9yID0gc2lnXG4gIHR5cGUgZ1xuICB2YWwgYmxvY2sgOiBpbnRcbiAgdmFsIGNyZWF0ZSA6ID90aW1lOih1bml0IC0+IGludDY0KSAtPiB1bml0IC0+IGdcbiAgdmFsIGdlbmVyYXRlX2ludG8gOiBnOmcgLT4gYnl0ZXMgLT4gb2ZmOmludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgcmVzZWVkIDogZzpnIC0+IHN0cmluZyAtPiB1bml0XG4gIHZhbCBhY2N1bXVsYXRlIDogZzpnIC0+IHNvdXJjZSAtPiBbYEFjYyBvZiBzdHJpbmcgLT4gdW5pdF1cbiAgdmFsIHNlZWRlZCA6IGc6ZyAtPiBib29sXG4gIHZhbCBwb29scyA6IGludFxuZW5kXG5cbnR5cGUgJ2EgZ2VuZXJhdG9yID0gKG1vZHVsZSBHZW5lcmF0b3Igd2l0aCB0eXBlIGcgPSAnYSlcbnR5cGUgZyA9IEdlbmVyYXRvciA6ICgnYSAqIGJvb2wgKiAnYSBnZW5lcmF0b3IpIC0+IGdcblxubGV0IGNyZWF0ZSAodHlwZSBhKSA/ZyA/c2VlZCA/KHN0cmljdD1mYWxzZSkgP3RpbWUgKG0gOiBhIGdlbmVyYXRvcikgPVxuICBsZXQgbW9kdWxlIE0gPSAodmFsIG0pIGluXG4gIGxldCBnID0gT3B0aW9uLnZhbHVlIGcgfmRlZmF1bHQ6KE0uY3JlYXRlID90aW1lICgpKSBpblxuICBPcHRpb24uaXRlciAoTS5yZXNlZWQgfmcpIHNlZWQ7XG4gIEdlbmVyYXRvciAoZywgc3RyaWN0LCBtKVxuXG5sZXQgX2RlZmF1bHRfZ2VuZXJhdG9yID0gQXRvbWljLm1ha2UgTm9uZVxuXG5sZXQgc2V0X2RlZmF1bHRfZ2VuZXJhdG9yIGcgPSBBdG9taWMuc2V0IF9kZWZhdWx0X2dlbmVyYXRvciAoU29tZSBnKVxuXG5sZXQgdW5zZXRfZGVmYXVsdF9nZW5lcmF0b3IgKCkgPSBBdG9taWMuc2V0IF9kZWZhdWx0X2dlbmVyYXRvciBOb25lXG5cbmxldCBkZWZhdWx0X2dlbmVyYXRvciAoKSA9XG4gIG1hdGNoIEF0b21pYy5nZXQgX2RlZmF1bHRfZ2VuZXJhdG9yIHdpdGhcbiAgfCBOb25lIC0+IHJhaXNlIE5vX2RlZmF1bHRfZ2VuZXJhdG9yXG4gIHwgU29tZSBnIC0+IGdcblxubGV0IGdldCA9IGZ1bmN0aW9uIFNvbWUgZyAtPiBnIHwgTm9uZSAtPiBkZWZhdWx0X2dlbmVyYXRvciAoKVxuXG5sZXQgZ2VuZXJhdGVfaW50byA/KGcgPSBkZWZhdWx0X2dlbmVyYXRvciAoKSkgYiA/KG9mZiA9IDApIG4gPVxuICBsZXQgR2VuZXJhdG9yIChnLCBfLCBtKSA9IGcgaW5cbiAgbGV0IG1vZHVsZSBNID0gKHZhbCBtKSBpblxuICBpZiBCeXRlcy5sZW5ndGggYiAtIG9mZiA8IG4gdGhlblxuICAgIGludmFsaWRfYXJnIFwiYnVmZmVyIHRvbyBzaG9ydFwiO1xuICBNLmdlbmVyYXRlX2ludG8gfmcgYiB+b2ZmIG5cblxubGV0IGdlbmVyYXRlID9nIG4gPVxuICBsZXQgZGF0YSA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4gIGdlbmVyYXRlX2ludG8gP2cgZGF0YSB+b2ZmOjAgbjtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkYXRhXG5cbmxldCByZXNlZWQgPyhnID0gZGVmYXVsdF9nZW5lcmF0b3IgKCkpIGNzID1cbiAgbGV0IEdlbmVyYXRvciAoZywgXywgbSkgPSBnIGluIGxldCBtb2R1bGUgTSA9ICh2YWwgbSkgaW4gTS5yZXNlZWQgfmcgY3NcblxubGV0IGFjY3VtdWxhdGUgZyBzb3VyY2UgPVxuICBsZXQgR2VuZXJhdG9yIChnLCBfLCBtKSA9IGdldCBnIGluXG4gIGxldCBtb2R1bGUgTSA9ICh2YWwgbSkgaW5cbiAgTS5hY2N1bXVsYXRlIH5nIHNvdXJjZVxuXG5sZXQgc2VlZGVkIGcgPVxuICBsZXQgR2VuZXJhdG9yIChnLCBfLCBtKSA9IGdldCBnIGluIGxldCBtb2R1bGUgTSA9ICh2YWwgbSkgaW4gTS5zZWVkZWQgfmdcblxubGV0IGJsb2NrIGcgPVxuICBsZXQgR2VuZXJhdG9yIChfLCBfLCBtKSA9IGdldCBnIGluIGxldCBtb2R1bGUgTSA9ICh2YWwgbSkgaW4gTS5ibG9ja1xuXG5sZXQgcG9vbHMgZyA9XG4gIGxldCBHZW5lcmF0b3IgKF8sIF8sIG0pID0gZ2V0IGcgaW4gbGV0IG1vZHVsZSBNID0gKHZhbCBtKSBpbiBNLnBvb2xzXG5cbmxldCBzdHJpY3QgZyA9XG4gIGxldCBHZW5lcmF0b3IgKF8sIHMsIF8pID0gZ2V0IGcgaW4gc1xuIiwiKCpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBIYW5uZXMgTWVobmVydFxuICogQ29weXJpZ2h0IChjKSAyMDE0IEFuaWwgTWFkaGF2YXBlZGR5IDxhbmlsQHJlY29pbC5vcmc+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiBEYXZpZCBLYWxvcGVyIE1lcsWhaW5qYWtcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXRyaXggU3lzdGVtcyBJbmNcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSXG4gKiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLFxuICogT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKilcblxubW9kdWxlIENwdV9uYXRpdmUgPSBzdHJ1Y3RcblxuICBleHRlcm5hbCBjeWNsZXMgOiB1bml0IC0+IGludCAgPSBcIm1jX2N5Y2xlX2NvdW50ZXJcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCByZHNlZWQgOiB1bml0IC0+IGludCAgPSBcIm1jX2NwdV9yZHNlZWRcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCByZHJhbmQgOiB1bml0IC0+IGludCAgPSBcIm1jX2NwdV9yZHJhbmRcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCBybmdfdHlwZSA6IHVuaXQgLT4gaW50ICA9IFwibWNfY3B1X3JuZ190eXBlXCIgW0BAbm9hbGxvY11cblxuICBsZXQgY3B1X3JuZyA9XG4gICAgbWF0Y2ggcm5nX3R5cGUgKCkgd2l0aFxuICAgIHwgMCAtPiBbXVxuICAgIHwgMSAtPiBbIGBSZHJhbmQgXVxuICAgIHwgMiAtPiBbIGBSZHNlZWQgXVxuICAgIHwgMyAtPiBbIGBSZHJhbmQgOyBgUmRzZWVkIF1cbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5lbmRcblxubW9kdWxlIFMgPSBTZXQuTWFrZShzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQgKiBzdHJpbmdcbiAgICAoKiBvbmx5IHRoZSBuYW1lIGlzIHJlbGV2YW50IGZvciBjb21wYXJpc29uIC0gdGhlIGlkeCBub3QgKilcbiAgICBsZXQgY29tcGFyZSAoKF9hLCBhbikgOiBpbnQgKiBzdHJpbmcpICgoX2IsIGJuKSA6IGludCAqIHN0cmluZykgPVxuICAgICAgU3RyaW5nLmNvbXBhcmUgYW4gYm5cbiAgZW5kKVxuXG5sZXQgX3NvdXJjZXMgPSBBdG9taWMubWFrZSBTLmVtcHR5XG5cbnR5cGUgc291cmNlID0gUm5nLnNvdXJjZVxuXG5sZXQgcmVnaXN0ZXJfc291cmNlIG5hbWUgPVxuICBsZXQgcmVjIHNldCAoKSA9XG4gICAgbGV0IHNvdXJjZXMgPSBBdG9taWMuZ2V0IF9zb3VyY2VzIGluXG4gICAgbGV0IG4gPSBTLmNhcmRpbmFsIHNvdXJjZXMgaW5cbiAgICBsZXQgc291cmNlID0gKG4sIG5hbWUpIGluXG4gICAgaWYgQXRvbWljLmNvbXBhcmVfYW5kX3NldCBfc291cmNlcyBzb3VyY2VzIChTLmFkZCBzb3VyY2Ugc291cmNlcykgdGhlblxuICAgICAgc291cmNlXG4gICAgZWxzZVxuICAgICAgc2V0ICgpXG4gIGluXG4gIHNldCAoKVxuXG5sZXQgaWQgKGlkeCwgXykgPSBpZHhcblxubGV0IHNvdXJjZXMgKCkgPSBTLmVsZW1lbnRzIChBdG9taWMuZ2V0IF9zb3VyY2VzKVxuXG5sZXQgcHBfc291cmNlIHBwZiAoaWR4LCBuYW1lKSA9IEZvcm1hdC5mcHJpbnRmIHBwZiBcIlslZF0gJXNcIiBpZHggbmFtZVxuXG5sZXQgY3B1X3JuZyA9IGZ1bmN0aW9uXG4gIHwgYFJkc2VlZCAtPiBDcHVfbmF0aXZlLnJkc2VlZFxuICB8IGBSZHJhbmQgLT4gQ3B1X25hdGl2ZS5yZHJhbmRcblxubGV0IHJhbmRvbSBwcmVmZXJyZWQgPVxuICBtYXRjaCBDcHVfbmF0aXZlLmNwdV9ybmcgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4cyB3aGVuIExpc3QubWVtIHByZWZlcnJlZCB4cyAtPiBTb21lIHByZWZlcnJlZFxuICB8IHk6Ol8gLT4gU29tZSB5XG5cbmxldCB3cml0ZV9oZWFkZXIgc291cmNlIGRhdGEgPVxuICBCeXRlcy5zZXRfdWludDggZGF0YSAwIHNvdXJjZTtcbiAgQnl0ZXMuc2V0X3VpbnQ4IGRhdGEgMSAoQnl0ZXMubGVuZ3RoIGRhdGEgLSAyKVxuXG5sZXQgaGVhZGVyIHNvdXJjZSBkYXRhID1cbiAgbGV0IGhkciA9IEJ5dGVzLmNyZWF0ZSAoMiArIFN0cmluZy5sZW5ndGggZGF0YSkgaW5cbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIGRhdGEgMCBoZHIgMiAoU3RyaW5nLmxlbmd0aCBkYXRhKTtcbiAgd3JpdGVfaGVhZGVyIHNvdXJjZSBoZHI7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgaGRyXG5cbigqIE5vdGU6XG4gKiBgYm9vdHN0cmFwYCBpcyBub3QgYSBzaW1wbGUgZmVlZGJhY2sgbG9vcC4gSXQgYXR0ZW1wdHMgdG8gZXhwbG9pdCBDUFUtbGV2ZWxcbiAqIGRhdGEgcmFjZXMgdGhhdCBsZWFkIHRvIGV4ZWN1dGlvbi10aW1lIHZhcmlhYmlsaXR5IG9mIGlkZW50aWNhbCBpbnN0cnVjdGlvbnMuXG4gKiBTZWUgV2hpcmx3aW5kIFJORzpcbiAqICAgaHR0cDovL3d3dy5pZWVlLXNlY3VyaXR5Lm9yZy9UQy9TUDIwMTQvcGFwZXJzL05vdC1Tby1SYW5kb21OdW1iZXJzaW5WaXJ0dWFsaXplZExpbnV4YW5kdGhlV2hpcmx3aW5kUk5HLnBkZlxuKilcbmxldCB3aGlybHdpbmRfYm9vdHN0cmFwIGlkID1cbiAgbGV0IG91dGVyICAgICA9IDEwMFxuICBhbmQgaW5uZXJfbWF4ID0gMTAyNFxuICBhbmQgYSAgICAgICAgID0gcmVmIDBcbiAgaW5cbiAgbGV0IGJ1ZiAgICAgICA9IEJ5dGVzLmNyZWF0ZSAob3V0ZXIgKiAyICsgMikgaW5cbiAgZm9yIGkgPSAwIHRvIG91dGVyIC0gMSBkb1xuICAgIGxldCB0c2MgPSBDcHVfbmF0aXZlLmN5Y2xlcyAoKSBpblxuICAgIEJ5dGVzLnNldF91aW50MTZfbGUgYnVmICgoaSArIDEpICogMikgdHNjO1xuICAgIGZvciBqID0gMSB0byB0c2MgbW9kIGlubmVyX21heCBkb1xuICAgICAgYSA6PSB0c2MgLyBqIC0gIWEgKiBpICsgMVxuICAgIGRvbmVcbiAgZG9uZTtcbiAgd3JpdGVfaGVhZGVyIGlkIGJ1ZjtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcblxubGV0IGNwdV9ybmdfYm9vdHN0cmFwID1cbiAgbWF0Y2ggcmFuZG9tIGBSZHNlZWQgd2l0aFxuICB8IE5vbmUgLT4gRXJyb3IgYE5vdF9zdXBwb3J0ZWRcbiAgfCBTb21lIGluc24gLT5cbiAgICBsZXQgY3B1X3JuZ19ib290c3RyYXAgaWQgPVxuICAgICAgbGV0IHIgPSBjcHVfcm5nIGluc24gKCkgaW5cbiAgICAgIGlmIHIgPSAwIHRoZW4gZmFpbHdpdGggXCJNaXJhZ2VfY3J5cHRvX3JuZy5FbnRyb3B5OiAwIGlzIGEgYmFkIENQVSBSTkcgdmFsdWVcIjtcbiAgICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgMTAgaW5cbiAgICAgIEJ5dGVzLnNldF9pbnQ2NF9sZSBidWYgMiAoSW50NjQub2ZfaW50IHIpO1xuICAgICAgd3JpdGVfaGVhZGVyIGlkIGJ1ZjtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG4gICAgaW5cbiAgICBPayBjcHVfcm5nX2Jvb3RzdHJhcFxuXG5sZXQgYm9vdHN0cmFwIGlkID1cbiAgbWF0Y2ggY3B1X3JuZ19ib290c3RyYXAgd2l0aFxuICB8IEVycm9yIGBOb3Rfc3VwcG9ydGVkIC0+IHdoaXJsd2luZF9ib290c3RyYXAgaWRcbiAgfCBPayBjcHVfcm5nX2Jvb3RzdHJhcCAtPlxuICAgIHRyeSBjcHVfcm5nX2Jvb3RzdHJhcCBpZCB3aXRoIEZhaWx1cmUgXyAtPiB3aGlybHdpbmRfYm9vdHN0cmFwIGlkXG5cbmxldCBpbnRlcnJ1cHRfaG9vayAoKSA9XG4gIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgNCBpblxuICBsZXQgYSA9IENwdV9uYXRpdmUuY3ljbGVzICgpIGluXG4gIEJ5dGVzLnNldF9pbnQzMl9sZSBidWYgMCAoSW50MzIub2ZfaW50IGEpIDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcblxubGV0IHRpbWVyX2FjY3VtdWxhdG9yIGcgPVxuICBsZXQgZyA9IG1hdGNoIGcgd2l0aCBOb25lIC0+IFNvbWUgKFJuZy5kZWZhdWx0X2dlbmVyYXRvciAoKSkgfCBTb21lIGcgLT4gU29tZSBnIGluXG4gIGxldCBzb3VyY2UgPSByZWdpc3Rlcl9zb3VyY2UgXCJ0aW1lclwiIGluXG4gIGxldCBgQWNjIGhhbmRsZSA9IFJuZy5hY2N1bXVsYXRlIGcgc291cmNlIGluXG4gIChmdW4gKCkgLT4gaGFuZGxlIChpbnRlcnJ1cHRfaG9vayAoKSkpXG5cbmxldCBmZWVkX3Bvb2xzIGcgc291cmNlIGYgPVxuICBsZXQgZyA9IG1hdGNoIGcgd2l0aCBOb25lIC0+IFNvbWUgKFJuZy5kZWZhdWx0X2dlbmVyYXRvciAoKSkgfCBTb21lIGcgLT4gU29tZSBnIGluXG4gIGxldCBgQWNjIGhhbmRsZSA9IFJuZy5hY2N1bXVsYXRlIGcgc291cmNlIGluXG4gIGZvciBfaSA9IDAgdG8gcHJlZCAoUm5nLnBvb2xzIGcpIGRvXG4gICAgaGFuZGxlIChmICgpKVxuICBkb25lXG5cbmxldCBjcHVfcm5nID1cbiAgbWF0Y2ggcmFuZG9tIGBSZHJhbmQgd2l0aFxuICB8IE5vbmUgLT4gRXJyb3IgYE5vdF9zdXBwb3J0ZWRcbiAgfCBTb21lIGluc24gLT5cbiAgICBsZXQgY3B1X3JuZyBnID1cbiAgICAgIGxldCByYW5kb21mID0gY3B1X3JuZyBpbnNuXG4gICAgICBhbmQgc291cmNlID1cbiAgICAgICAgbGV0IHMgPSBtYXRjaCBpbnNuIHdpdGggYFJkcmFuZCAtPiBcInJkcmFuZFwiIHwgYFJkc2VlZCAtPiBcInJkc2VlZFwiIGluXG4gICAgICAgIHJlZ2lzdGVyX3NvdXJjZSBzXG4gICAgICBpblxuICAgICAgbGV0IGYgKCkgPVxuICAgICAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIDggaW5cbiAgICAgICAgQnl0ZXMuc2V0X2ludDY0X2xlIGJ1ZiAwIChJbnQ2NC5vZl9pbnQgKHJhbmRvbWYgKCkpKTtcbiAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcbiAgICAgIGluXG4gICAgICBmdW4gKCkgLT4gZmVlZF9wb29scyBnIHNvdXJjZSBmXG4gICAgaW5cbiAgICBPayBjcHVfcm5nXG4iLCIoKiBOT1RFOiB3aGVuIG1vZGlmeWluZyB0aGlzIGZpbGUsIHBsZWFzZSBhbHNvIGNoZWNrIHdoZXRoZXJcbiAgIHJuZy9taW91L3Bmb3J0dW5hLm1sIG5lZWRzIHRvIGJlIHVwZGF0ZWQuICopXG5cbm9wZW4gTWlyYWdlX2NyeXB0b1xub3BlbiBNaXJhZ2VfY3J5cHRvLlVuY29tbW9uXG5cbm1vZHVsZSBTSEFkMjU2ID0gc3RydWN0XG4gIG9wZW4gRGlnZXN0aWZcbiAgdHlwZSB0ID0gU0hBMjU2LnRcbiAgdHlwZSBjdHggPSBTSEEyNTYuY3R4XG4gIGxldCBlbXB0eSAgICAgPSBTSEEyNTYuZW1wdHlcbiAgbGV0IGdldCB0ICAgICA9IFNIQTI1Ni4oZ2V0IHQgfD4gdG9fcmF3X3N0cmluZyB8PiBkaWdlc3Rfc3RyaW5nIHw+IHRvX3Jhd19zdHJpbmcpXG4gIGxldCBkaWdlc3QgeCAgPSBTSEEyNTYuKGRpZ2VzdF9zdHJpbmcgeCB8PiB0b19yYXdfc3RyaW5nIHw+IGRpZ2VzdF9zdHJpbmcgfD4gdG9fcmF3X3N0cmluZylcbiAgbGV0IGRpZ2VzdGkgaSA9IFNIQTI1Ni4oZGlnZXN0aV9zdHJpbmcgaSB8PiB0b19yYXdfc3RyaW5nIHw+IGRpZ2VzdF9zdHJpbmcgfD4gdG9fcmF3X3N0cmluZylcbiAgbGV0IGZlZWRpICAgICA9IFNIQTI1Ni5mZWVkaV9zdHJpbmdcbmVuZFxuXG5sZXQgYmxvY2sgPSAxNlxuXG4oKiB0aGUgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgaW4gYSBwb29sIHRvIHRyaWdnZXIgYSByZXNlZWQgKilcbmxldCBtaW5fcG9vbF9zaXplID0gNjRcbigqIHRoZSBtaW5pbWFsIGR1cmF0aW9uIGJldHdlZW4gdHdvIHJlc2VlZHMgKilcbmxldCBtaW5fdGltZV9kdXJhdGlvbiA9IDFfMDAwXzAwMF8wMDBMXG4oKiBudW1iZXIgb2YgcG9vbHMgKilcbmxldCBwb29scyA9IDMyXG5cbigqIFhYWCBMb2NraW5nISEgKilcbnR5cGUgZyA9XG4gIHsgbXV0YWJsZSBjdHIgICAgOiBBRVMuQ1RSLmN0clxuICA7IG11dGFibGUgc2VjcmV0IDogc3RyaW5nXG4gIDsgbXV0YWJsZSBrZXkgICAgOiBBRVMuQ1RSLmtleVxuICA7IHBvb2xzICAgICAgICAgIDogU0hBZDI1Ni5jdHggYXJyYXlcbiAgOyBtdXRhYmxlIHBvb2wwX3NpemUgOiBpbnRcbiAgOyBtdXRhYmxlIHJlc2VlZF9jb3VudCA6IGludFxuICA7IG11dGFibGUgbGFzdF9yZXNlZWQgOiBpbnQ2NFxuICA7IHRpbWUgOiAodW5pdCAtPiBpbnQ2NCkgb3B0aW9uXG4gIH1cblxubGV0IGNyZWF0ZSA/dGltZSAoKSA9XG4gIGxldCBrID0gU3RyaW5nLm1ha2UgMzIgJ1xceDAwJyBpblxuICB7IGN0ciAgICA9ICgwTCwgMEwpXG4gIDsgc2VjcmV0ID0ga1xuICA7IGtleSAgICA9IEFFUy5DVFIub2Zfc2VjcmV0IGtcbiAgOyBwb29scyAgPSBBcnJheS5tYWtlIHBvb2xzIFNIQWQyNTYuZW1wdHlcbiAgOyBwb29sMF9zaXplID0gMFxuICA7IHJlc2VlZF9jb3VudCA9IDBcbiAgOyBsYXN0X3Jlc2VlZCA9IDBMXG4gIDsgdGltZVxuICB9XG5cbmxldCBzZWVkZWQgfmcgPVxuICBsZXQgbG8sIGhpID0gZy5jdHIgaW5cbiAgbm90IChJbnQ2NC5lcXVhbCBsbyAwTCAmJiBJbnQ2NC5lcXVhbCBoaSAwTClcblxuKCogWFhYIFdlIG1pZ2h0IHdhbnQgdG8gZXJhc2UgdGhlIG9sZCBrZXkuICopXG5sZXQgc2V0X2tleSB+ZyBzZWMgPVxuICBnLnNlY3JldCA8LSBzZWMgO1xuICBnLmtleSAgICA8LSBBRVMuQ1RSLm9mX3NlY3JldCBzZWNcblxubGV0IHJlc2VlZGkgfmcgaXRlciA9XG4gIHNldF9rZXkgfmcgQEAgU0hBZDI1Ni5kaWdlc3RpIChmdW4gZiAtPiBmIGcuc2VjcmV0OyBpdGVyIGYpO1xuICBnLmN0ciA8LSBBRVMuQ1RSLmFkZF9jdHIgZy5jdHIgMUxcblxubGV0IGl0ZXIxIGEgICAgIGYgPSBmIGFcblxubGV0IHJlc2VlZCB+ZyBjcyA9IHJlc2VlZGkgfmcgKGl0ZXIxIGNzKVxuXG5sZXQgZ2VuZXJhdGVfcmVrZXkgfmcgYnVmIH5vZmYgbGVuID1cbiAgbGV0IGIgID0gbGVuIC8vIGJsb2NrICsgMiBpblxuICBsZXQgbiAgPSBiICogYmxvY2sgaW5cbiAgbGV0IHIgID0gQUVTLkNUUi5zdHJlYW0gfmtleTpnLmtleSB+Y3RyOmcuY3RyIG4gaW5cbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHIgMCBidWYgb2ZmIGxlbjtcbiAgbGV0IHIyID0gU3RyaW5nLnN1YiByIChuIC0gMzIpIDMyIGluXG4gIHNldF9rZXkgfmcgcjIgO1xuICBnLmN0ciA8LSBBRVMuQ1RSLmFkZF9jdHIgZy5jdHIgKEludDY0Lm9mX2ludCBiKVxuXG5sZXQgYWRkX3Bvb2xfZW50cm9weSBnID1cbiAgaWYgZy5wb29sMF9zaXplID4gbWluX3Bvb2xfc2l6ZSB0aGVuXG4gICAgbGV0IHNob3VsZF9yZXNlZWQsIG5vdyA9XG4gICAgICBtYXRjaCBnLnRpbWUgd2l0aFxuICAgICAgfCBOb25lIC0+IHRydWUsIDBMXG4gICAgICB8IFNvbWUgZiAtPlxuICAgICAgICBsZXQgbm93ID0gZiAoKSBpblxuICAgICAgICBJbnQ2NC4oc3ViIG5vdyBnLmxhc3RfcmVzZWVkID4gbWluX3RpbWVfZHVyYXRpb24pLCBub3dcbiAgICBpblxuICAgIGlmIHNob3VsZF9yZXNlZWQgdGhlbiBiZWdpblxuICAgICAgZy5yZXNlZWRfY291bnQgPC0gZy5yZXNlZWRfY291bnQgKyAxO1xuICAgICAgZy5sYXN0X3Jlc2VlZCA8LSBub3c7XG4gICAgICBnLnBvb2wwX3NpemUgPC0gMDtcbiAgICAgIHJlc2VlZGkgfmcgQEAgZnVuIGFkZCAtPlxuICAgICAgZm9yIGkgPSAwIHRvIHBvb2xzIC0gMSBkb1xuICAgICAgICBpZiBnLnJlc2VlZF9jb3VudCBsYW5kICgoMSBsc2wgaSkgLSAxKSA9IDAgdGhlblxuICAgICAgICAgIChTSEFkMjU2LmdldCBnLnBvb2xzLihpKSB8PiBhZGQ7IGcucG9vbHMuKGkpIDwtIFNIQWQyNTYuZW1wdHkpXG4gICAgICBkb25lXG4gICAgZW5kXG5cbmxldCBnZW5lcmF0ZV9pbnRvIH5nIGJ1ZiB+b2ZmIGxlbiA9XG4gIGFkZF9wb29sX2VudHJvcHkgZztcbiAgaWYgbm90IChzZWVkZWQgfmcpIHRoZW4gcmFpc2UgUm5nLlVuc2VlZGVkX2dlbmVyYXRvciA7XG4gIGxldCByZWMgY2h1bmsgb2ZmID0gZnVuY3Rpb25cbiAgICB8IGkgd2hlbiBpIDw9IDAgLT4gKClcbiAgICB8IG4gLT5cbiAgICAgIGxldCBuJyA9IGltaW4gbiAweDEwMDAwIGluXG4gICAgICBnZW5lcmF0ZV9yZWtleSB+ZyBidWYgfm9mZiBuJztcbiAgICAgIGNodW5rIChvZmYgKyBuJykgKG4gLSBuJylcbiAgaW5cbiAgY2h1bmsgb2ZmIGxlblxuXG5sZXQgYWRkIH5nIChzb3VyY2UsIF8pIH5wb29sIGRhdGEgPVxuICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIDJcbiAgYW5kIHBvb2wgICA9IHBvb2wgbGFuZCAocG9vbHMgLSAxKVxuICBhbmQgc291cmNlID0gc291cmNlIGxhbmQgMHhmZiBpblxuICBCeXRlcy5zZXRfdWludDggYnVmIDAgc291cmNlO1xuICBCeXRlcy5zZXRfdWludDggYnVmIDEgKFN0cmluZy5sZW5ndGggZGF0YSk7XG4gIGcucG9vbHMuKHBvb2wpIDwtIFNIQWQyNTYuZmVlZGkgZy5wb29scy4ocG9vbCkgKGl0ZXIyIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZikgZGF0YSk7XG4gIGlmIHBvb2wgPSAwIHRoZW4gZy5wb29sMF9zaXplIDwtIGcucG9vbDBfc2l6ZSArIFN0cmluZy5sZW5ndGggZGF0YVxuXG4oKiBYWFhcbiAqIFNjaG5laWVyIHJlY29tbWVuZHMgYWdhaW5zdCB1c2luZyBnZW5lcmF0b3ItaW1wb3NlZCBwb29sLXNlZWRpbmcgc2NoZWR1bGVcbiAqIGJ1dCBpdCBqdXN0IG1ha2VzIGZvciBhIGhvcnJpZCBhcGkuXG4gKilcbmxldCBhY2N1bXVsYXRlIH5nIHNvdXJjZSA9XG4gIGxldCBwb29sID0gcmVmIDAgaW5cbiAgYEFjYyAoZnVuIGJ1ZiAtPlxuICAgIGFkZCB+ZyBzb3VyY2UgfnBvb2w6IXBvb2wgYnVmIDtcbiAgICBpbmNyIHBvb2wpXG4iLCJtb2R1bGUgTWFrZSAoSCA6IERpZ2VzdGlmLlMpID0gc3RydWN0XG4gIHR5cGUgZyA9XG4gICAgeyBtdXRhYmxlIGsgICAgICA6IHN0cmluZ1xuICAgIDsgbXV0YWJsZSB2ICAgICAgOiBzdHJpbmdcbiAgICA7IG11dGFibGUgc2VlZGVkIDogYm9vbFxuICAgIH1cblxuICBsZXQgYmxvY2sgPSBILmRpZ2VzdF9zaXplXG5cbiAgbGV0IChieDAwLCBieDAxKSA9IFwiXFx4MDBcIiwgXCJcXHgwMVwiXG5cbiAgbGV0IGswID0gU3RyaW5nLm1ha2UgSC5kaWdlc3Rfc2l6ZSAnXFx4MDAnXG4gIGFuZCB2MCA9IFN0cmluZy5tYWtlIEguZGlnZXN0X3NpemUgJ1xceDAxJ1xuXG4gIGxldCBjcmVhdGUgP3RpbWU6XyAoKSA9IHsgayA9IGswIDsgdiA9IHYwIDsgc2VlZGVkID0gZmFsc2UgfVxuXG4gIGxldCBzZWVkZWQgfmcgPSBnLnNlZWRlZFxuXG4gIGxldCByZXNlZWQgfmcgYnVmID1cbiAgICBsZXQgKGssIHYpID0gKGcuaywgZy52KSBpblxuICAgIGxldCBrID0gSC5obWFjX3N0cmluZyB+a2V5OmsgQEAgU3RyaW5nLmNvbmNhdCBcIlwiIFt2OyBieDAwOyBidWZdIHw+IEgudG9fcmF3X3N0cmluZyBpblxuICAgIGxldCB2ID0gSC5obWFjX3N0cmluZyB+a2V5OmsgdiB8PiBILnRvX3Jhd19zdHJpbmcgaW5cbiAgICBsZXQgayA9IEguaG1hY19zdHJpbmcgfmtleTprIEBAIFN0cmluZy5jb25jYXQgXCJcIiBbdjsgYngwMTsgYnVmXSB8PiBILnRvX3Jhd19zdHJpbmcgaW5cbiAgICBsZXQgdiA9IEguaG1hY19zdHJpbmcgfmtleTprIHYgfD4gSC50b19yYXdfc3RyaW5nIGluXG4gICAgZy5rIDwtIGsgOyBnLnYgPC0gdiA7IGcuc2VlZGVkIDwtIHRydWVcblxuICBsZXQgZ2VuZXJhdGVfaW50byB+ZyBidWYgfm9mZiBsZW4gPVxuICAgIGlmIG5vdCBnLnNlZWRlZCB0aGVuIHJhaXNlIFJuZy5VbnNlZWRlZF9nZW5lcmF0b3IgO1xuICAgIGxldCByZWMgZ28gb2ZmIGsgdiA9IGZ1bmN0aW9uXG4gICAgICB8IDAgLT4gdlxuICAgICAgfCAxIC0+XG4gICAgICAgIGxldCB2ID0gSC5obWFjX3N0cmluZyB+a2V5OmsgdiB8PiBILnRvX3Jhd19zdHJpbmcgaW5cbiAgICAgICAgbGV0IGxlbiA9XG4gICAgICAgICAgbGV0IHJlbSA9IGxlbiBtb2QgSC5kaWdlc3Rfc2l6ZSBpblxuICAgICAgICAgIGlmIHJlbSA9IDAgdGhlbiBILmRpZ2VzdF9zaXplIGVsc2UgcmVtXG4gICAgICAgIGluXG4gICAgICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyB2IDAgYnVmIG9mZiBsZW47XG4gICAgICAgIHZcbiAgICAgIHwgaSAtPlxuICAgICAgICBsZXQgdiA9IEguaG1hY19zdHJpbmcgfmtleTprIHYgfD4gSC50b19yYXdfc3RyaW5nIGluXG4gICAgICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyB2IDAgYnVmIG9mZiBILmRpZ2VzdF9zaXplO1xuICAgICAgICBnbyAob2ZmICsgSC5kaWdlc3Rfc2l6ZSkgayB2IChwcmVkIGkpXG4gICAgaW5cbiAgICBsZXQgdiA9IGdvIG9mZiBnLmsgZy52IE1pcmFnZV9jcnlwdG8uVW5jb21tb24uKGxlbiAvLyBILmRpZ2VzdF9zaXplKSBpblxuICAgIGcuayA8LSBILmhtYWNfc3RyaW5nIH5rZXk6Zy5rICh2IF4gYngwMCkgfD4gSC50b19yYXdfc3RyaW5nO1xuICAgIGcudiA8LSBILmhtYWNfc3RyaW5nIH5rZXk6Zy5rIHYgfD4gSC50b19yYXdfc3RyaW5nXG5cbiAgKCogWFhYICopXG4gIGxldCBhY2N1bXVsYXRlIH5nOl8gPSBpbnZhbGlkX2FyZyBcIkltcGxlbWVudCBIbWFjX2RyYmcuYWNjdW11bGF0ZS4uLlwiXG5cbiAgbGV0IHBvb2xzID0gMFxuZW5kXG4iXX0=
