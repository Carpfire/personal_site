// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Core_thread__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Core_thread = [0],
    Core_thread$0 = [0, Core_thread];
   runtime.caml_register_global(0, Core_thread$0, "Core_thread__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Core_thread__Import
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Core_thread_Import = "Core_thread__Import",
    cst_core_thread = "core_thread";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Core_thread_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_core_thread);
   caml_call1(Ppx_expect_runtime[1][1], "core_thread/src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_core_thread, "import.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_core_thread);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Core_thread_Import);
   var Core_thread_Import = [0];
   runtime.caml_register_global
    (11, Core_thread_Import, cst_Core_thread_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Core_thread
//# unitInfo: Requires: Base__Exn, Caml_unix, Core, Core__Int, Core__List, Core__Set, Core__Signal, Core__String, Event, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdio__In_channel, Thread
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Core_thread$0 = "Core_thread",
    cst_core_thread$0 = "core_thread";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Int = global_data.Core__Int,
    Core_Set = global_data.Core__Set,
    Event = global_data.Event,
    Core_String = global_data.Core__String,
    Caml_unix = global_data.Caml_unix,
    Core = global_data.Core,
    Stdio_In_channel = global_data.Stdio__In_channel,
    Core_Signal = global_data.Core__Signal,
    Core_List = global_data.Core__List,
    Base_Exn = global_data.Base__Exn,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Thread = global_data.Thread;
   caml_call1(Ppx_module_timer_runtime[4], cst_Core_thread$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_core_thread$0);
   caml_call1(Ppx_expect_runtime[1][1], "core_thread/src/core_thread.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_core_thread$0, "core_thread.ml");
   var
    _a_ = [0, 0],
    self = Thread[2],
    id = Thread[3],
    exit = Thread[5],
    delay = Thread[6],
    join = Thread[7],
    yield$0 = Thread[8],
    wait_timed_read = Thread[9],
    wait_timed_write = Thread[10],
    cst_Threads = "Threads:",
    cst_status = "/status",
    cst_proc = "/proc/",
    cst_Core_thread_create_request = "Core_thread.create requested to raise",
    _e_ = [0, "id"],
    cst_thread = "thread",
    cst_core_thread = cst_core_thread$0,
    cst_Core_thread = cst_Core_thread$0,
    _b_ = Thread[1],
    _c_ = Thread[13],
    _d_ = Thread[14];
   function sexp_of_t(t){
    var
     _v_ = caml_call1(id, t),
     _w_ = [0, [1, [0, _e_, [0, caml_call1(Core[389], _v_), 0]]], 0];
    return [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_thread), _w_]];
   }
   var create_should_raise = [0, 0];
   function create(on_uncaught_exn, f, arg){
    if(create_should_raise[1]){
     var
      _t_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Core_thread_create_request);
     caml_call1(Core[261], _t_);
    }
    _a_[1] = 1;
    function f$0(arg){
     var exit = 890699316 <= on_uncaught_exn ? 0 : 1;
     function _u_(param){return caml_call1(f, arg);}
     return caml_call2(Base_Exn[14], exit, _u_);
    }
    return caml_call2(_b_, f$0, arg);
   }
   function threads_have_been_created(param){return _a_[1];}
   function wait_signal(sigs){
    return caml_call1(_d_, caml_call2(Core_List[51], sigs, Core_Signal[41]));
   }
   function sigmask(cmd, sigs){
    var
     cmd$0 = -18967500 === cmd ? 2 : 4150146 <= cmd ? 0 : 1,
     sigs$0 = caml_call2(Core_List[51], sigs, Core_Signal[41]),
     _r_ = Core_Signal[40],
     _s_ = caml_call2(_c_, cmd$0, sigs$0);
    return caml_call2(Core_List[51], _s_, _r_);
   }
   function num_threads(param){
    try{
     var
      _k_ = caml_call1(Caml_unix[18], 0),
      _l_ = caml_call1(Core[22], _k_),
      _m_ = caml_call2(Core[18], _l_, cst_status),
      _n_ = caml_call2(Core[18], cst_proc, _m_),
      param$0 = caml_call2(Stdio_In_channel[24], 0, _n_);
     for(;;){
      if(param$0){
       var xs = param$0[2], line = param$0[1];
       if(! caml_call2(Core_String[73], line, cst_Threads)){var param$0 = xs; continue;}
       try{
        var
         _i_ = caml_call2(Core_String[74], line, 58)[2],
         _j_ =
           [0,
            runtime.caml_int_of_string(caml_call2(Core_String[85], 0, _i_))],
         _o_ = _j_;
       }
       catch(_q_){var _o_ = 0;}
      }
      else
       var _o_ = 0;
      return _o_;
     }
    }
    catch(_p_){return 0;}
   }
   function block_forever(param){
    var _g_ = caml_call1(Event[1], 0), _h_ = caml_call1(Event[3], _g_);
    return caml_call1(Event[9], _h_);
   }
   function setaffinity_self_exn(cpuset){
    return runtime.pthread_np_setaffinity_self
            (caml_call1(Core_Set[40], cpuset));
   }
   var setaffinity_self_exn$0 = [0, setaffinity_self_exn];
   function getaffinity_self_exn(param){
    var _f_ = runtime.pthread_np_getaffinity_self(0);
    return caml_call1(Core_Int[99][10], _f_);
   }
   var
    getaffinity_self_exn$0 = [0, getaffinity_self_exn],
    For_testing = [0, create_should_raise];
   caml_call1(Ppx_inline_test_lib[7], cst_core_thread);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Core_thread);
   var
    Core_thread =
      [0,
       sexp_of_t,
       create,
       self,
       id,
       exit,
       delay,
       join,
       wait_timed_read,
       wait_timed_write,
       yield$0,
       sigmask,
       wait_signal,
       threads_have_been_created,
       num_threads,
       block_forever,
       setaffinity_self_exn$0,
       getaffinity_self_exn$0,
       For_testing];
   runtime.caml_register_global(29, Core_thread, cst_Core_thread$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJjb3JlX3RocmVhZC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZXhpdCIsIndhaXRfdGltZWRfcmVhZCIsIndhaXRfdGltZWRfd3JpdGUiLCJzZXhwX29mX3QiLCJ0IiwiY3JlYXRlX3Nob3VsZF9yYWlzZSIsImNyZWF0ZSIsIm9uX3VuY2F1Z2h0X2V4biIsImYiLCJhcmciLCJmJDAiLCJ0aHJlYWRzX2hhdmVfYmVlbl9jcmVhdGVkIiwid2FpdF9zaWduYWwiLCJzaWdzIiwic2lnbWFzayIsImNtZCIsImNtZCQwIiwic2lncyQwIiwibnVtX3RocmVhZHMiLCJ4cyIsImxpbmUiLCJibG9ja19mb3JldmVyIiwic2V0YWZmaW5pdHlfc2VsZl9leG4iLCJjcHVzZXQiLCJzZXRhZmZpbml0eV9zZWxmX2V4biQwIiwiZ2V0YWZmaW5pdHlfc2VsZl9leG4iLCJnZXRhZmZpbml0eV9zZWxmX2V4biQwIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY29yZV91bml4L2NvcmVfdGhyZWFkL2NvcmVfdGhyZWFkX18ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlX3VuaXgvY29yZV90aHJlYWQvY29yZV90aHJlYWQubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FLdUI7O0lBQUE7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQ0ZTO0lBQUE7OztJQU01QkE7Ozs7SUFGQUM7SUFDQUM7Ozs7Ozs7Ozs7OztZQUVBQyxVQUFVQztJQUE0QjtLQUFBLE1BQUEsZUFBNUJBOzs7O0dBQ1ksSUFBdEJDO1lBRUFDLE9BQVFDLGlCQUFnQkMsR0FBRUM7SUFDNUIsR0FIRUo7OztLQUcyQjs7O2FBRXpCSyxJQUFFRDtLQUNKLElBQUlULG9CQUpJTzt5QkFTNkIsT0FBckMsV0FUd0JDLEdBR3BCQyxLQU1zQztLQUFoQixPQUFBLHlCQUx0QlQ7SUFLdUM7SUFFN0MsT0FBQSxnQkFSSVUsS0FId0JEO0dBV2hCO1lBR1ZFLGlDQUErQixjQUEwQjtZQUN6REMsWUFBWUM7SUFBTyxPQUFZLGdCQUFBLDBCQUFuQkE7R0FBd0Q7WUFFcEVDLFFBQVFDLEtBQUlGO0lBQ2Q7S0FBSUcsc0JBRE1ELHFCQUFBQTtLQU9ORSxTQUFPLDBCQVBHSjtLQU9IO0tBQ29CLE1BQUEsZ0JBUDNCRyxPQU1BQztJQUNKLE9BQUE7R0FBaUQ7WUFHL0NDO0lBQ0Y7S0FhcUQ7TUFBQSxNQUFBO01BQWQsTUFBQTtNQUFBLE1BQUE7TUFBWixNQUFBO2dCQUF2QjtLQWJ3Qjs7V0FFaEJDLGlCQUFSQztPQUNHLEtBQUEsNEJBREhBLGtDQUFRRDtPQUVIO1FBRXNDO1NBQUEsTUFBQSw0QkFKM0NDO1NBSUk7O1lBQUssMkJBQWU7Ozs7Ozs7TUFNMUI7OztlQUdLO0dBQUk7WUFHVEM7SUFBbUIsSUFBMEIsTUFBQSx5QkFBZixNQUFBO0lBQUEsT0FBQTtHQUFzQztZQVNsRUMscUJBQXFCQztJQUFTLE9BQUE7YUFBcUIseUJBQTlCQTtHQUFtRDtHQUM1RSxJQUZFQyw2QkFDRUY7WUFLQUc7SUFBMkMsVUFBQTtJQUFBLE9BQUE7R0FBeUI7R0FDeEU7SUFGRUMsNkJBQ0VEO0lBZ0JlLGtCQS9FakJwQjs7Ozs7Ozs7T0FEQUY7T0FHQUc7OztPQUpBTjs7O09BRkFDO09BQ0FDOztPQXNCQVk7T0FGQUY7T0FEQUQ7T0FjQU87T0FtQkFHO09BUUFHO09BS0FFOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBDb3JlX3RocmVhZC5JbXBvcnQgKilcbm1vZHVsZSBJbXBvcnQgPSBDb3JlX3RocmVhZF9fSW1wb3J0XG5cbm1vZHVsZSBDb3JlX3RocmVhZF9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubGV0IHRocmVhZHNfaGF2ZV9iZWVuX2NyZWF0ZWQgPSByZWYgZmFsc2VcblxuaW5jbHVkZSBDYW1sX3RocmVhZHMuVGhyZWFkIFtAQG9jYW1sLmFsZXJ0IFwiLWRlcHJlY2F0ZWRcIl1cblxubGV0IHdhaXRfdGltZWRfcmVhZCA9IHdhaXRfdGltZWRfcmVhZCBbQEBvY2FtbC5hbGVydCBcIi1kZXByZWNhdGVkXCJdXG5sZXQgd2FpdF90aW1lZF93cml0ZSA9IHdhaXRfdGltZWRfd3JpdGUgW0BAb2NhbWwuYWxlcnQgXCItZGVwcmVjYXRlZFwiXVxubGV0IGV4aXQgPSBleGl0IFtAQG9jYW1sLmFsZXJ0IFwiLWRlcHJlY2F0ZWRcIl1cbmxldCBzZXhwX29mX3QgdCA9IFslbWVzc2FnZSBcInRocmVhZFwiIH5pZDooaWQgdCA6IGludCldXG5sZXQgY3JlYXRlX3Nob3VsZF9yYWlzZSA9IHJlZiBmYWxzZVxuXG5sZXQgY3JlYXRlIH5vbl91bmNhdWdodF9leG4gZiBhcmcgPVxuICBpZiAhY3JlYXRlX3Nob3VsZF9yYWlzZSB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiQ29yZV90aHJlYWQuY3JlYXRlIHJlcXVlc3RlZCB0byByYWlzZVwiXTtcbiAgdGhyZWFkc19oYXZlX2JlZW5fY3JlYXRlZCA6PSB0cnVlO1xuICBsZXQgZiBhcmcgOiB1bml0ID1cbiAgICBsZXQgZXhpdCA9XG4gICAgICBtYXRjaCBvbl91bmNhdWdodF9leG4gd2l0aFxuICAgICAgfCBgUHJpbnRfdG9fc3RkZXJyIC0+IGZhbHNlXG4gICAgICB8IGBLaWxsX3dob2xlX3Byb2Nlc3MgLT4gdHJ1ZVxuICAgIGluXG4gICAgRXhuLmhhbmRsZV91bmNhdWdodCB+ZXhpdCAoZnVuICgpIC0+IGYgYXJnKVxuICBpblxuICBjcmVhdGUgZiBhcmdcbjs7XG5cbmxldCB0aHJlYWRzX2hhdmVfYmVlbl9jcmVhdGVkICgpID0gIXRocmVhZHNfaGF2ZV9iZWVuX2NyZWF0ZWRcbmxldCB3YWl0X3NpZ25hbCBzaWdzID0gd2FpdF9zaWduYWwgKExpc3QubWFwIH5mOlNpZ25hbC50b19jYW1sX2ludCBzaWdzKVxuXG5sZXQgc2lnbWFzayBjbWQgc2lncyA9XG4gIGxldCBjbWQgPVxuICAgIG1hdGNoIGNtZCB3aXRoXG4gICAgfCBgU2V0IC0+IFVuaXguU0lHX1NFVE1BU0tcbiAgICB8IGBCbG9jayAtPiBVbml4LlNJR19CTE9DS1xuICAgIHwgYFVuYmxvY2sgLT4gVW5peC5TSUdfVU5CTE9DS1xuICBpblxuICBsZXQgc2lncyA9IExpc3QubWFwIH5mOlNpZ25hbC50b19jYW1sX2ludCBzaWdzIGluXG4gIExpc3QubWFwIH5mOlNpZ25hbC5vZl9jYW1sX2ludCAoc2lnbWFzayBjbWQgc2lncylcbjs7XG5cbmxldCBudW1fdGhyZWFkcyAoKSA9XG4gIGxldCByZWMgZmluZF90aHJlYWRfY291bnQgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgbGluZSA6OiB4cyAtPlxuICAgICAgaWYgU3RyaW5nLmlzX3ByZWZpeCBsaW5lIH5wcmVmaXg6XCJUaHJlYWRzOlwiXG4gICAgICB0aGVuIChcbiAgICAgICAgdHJ5XG4gICAgICAgICAgU29tZSAoaW50X29mX3N0cmluZyAoU3RyaW5nLnN0cmlwIChzbmQgKFN0cmluZy5sc3BsaXQyX2V4biBsaW5lIH5vbjonOicpKSkpXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBfIC0+IE5vbmUpXG4gICAgICBlbHNlIGZpbmRfdGhyZWFkX2NvdW50IHhzXG4gIGluXG4gIHRyeVxuICAgIGZpbmRfdGhyZWFkX2NvdW50XG4gICAgICAoSW5fY2hhbm5lbC5yZWFkX2xpbmVzIChcIi9wcm9jL1wiIF4gc3RyaW5nX29mX2ludCAoVW5peC5nZXRwaWQgKCkpIF4gXCIvc3RhdHVzXCIpKVxuICB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgYmxvY2tfZm9yZXZlciAoKSA9IEV2ZW50LnN5bmMgKEV2ZW50LnJlY2VpdmUgKEV2ZW50Lm5ld19jaGFubmVsICgpKSlcblxuWyUlaW1wb3J0IFwiY29uZmlnLmhcIl1cblslJWlmZGVmIEpTQ19QVEhSRUFEX05QXVxuXG5leHRlcm5hbCBzZXRhZmZpbml0eV9zZWxmX2V4biA6IGludCBBcnJheS50IC0+IHVuaXQgPSBcInB0aHJlYWRfbnBfc2V0YWZmaW5pdHlfc2VsZlwiXG5leHRlcm5hbCBnZXRhZmZpbml0eV9zZWxmX2V4biA6IHVuaXQgLT4gaW50IEFycmF5LnQgPSBcInB0aHJlYWRfbnBfZ2V0YWZmaW5pdHlfc2VsZlwiXG5cbmxldCBzZXRhZmZpbml0eV9zZWxmX2V4biA9XG4gIGxldCBzZXRhZmZpbml0eV9zZWxmX2V4biBjcHVzZXQgPSBzZXRhZmZpbml0eV9zZWxmX2V4biAoU2V0LnRvX2FycmF5IGNwdXNldCkgaW5cbiAgT2sgc2V0YWZmaW5pdHlfc2VsZl9leG5cbjs7XG5cbmxldCBnZXRhZmZpbml0eV9zZWxmX2V4biA9XG4gIGxldCBnZXRhZmZpbml0eV9zZWxmX2V4biAoKSA9IEludC5TZXQub2ZfYXJyYXkgKGdldGFmZmluaXR5X3NlbGZfZXhuICgpKSBpblxuICBPayBnZXRhZmZpbml0eV9zZWxmX2V4blxuOztcblxuWyUlZWxzZV1cblxubGV0IG5vdF9zdXBwb3J0ZWQgbmFtZSA9XG4gIEVycm9yLm9mX3N0cmluZ1xuICAgIChzcHJpbnRmIFwiJXM6IG5vbi1wb3J0YWJsZSBwdGhyZWFkIGV4dGVuc2lvbiBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgcGxhdGZvcm1cIiBuYW1lKVxuOztcblxubGV0IHNldGFmZmluaXR5X3NlbGZfZXhuID0gRXJyb3IgKG5vdF9zdXBwb3J0ZWQgXCJwdGhyZWFkX3NldGFmZmluaXR5X25wXCIpXG5sZXQgZ2V0YWZmaW5pdHlfc2VsZl9leG4gPSBFcnJvciAobm90X3N1cHBvcnRlZCBcInB0aHJlYWRfZ2V0YWZmaW5pdHlfbnBcIilcblxuWyUlZW5kaWZdXG5cbm1vZHVsZSBGb3JfdGVzdGluZyA9IHN0cnVjdFxuICBsZXQgY3JlYXRlX3Nob3VsZF9yYWlzZSA9IGNyZWF0ZV9zaG91bGRfcmFpc2VcbmVuZFxuIl19
