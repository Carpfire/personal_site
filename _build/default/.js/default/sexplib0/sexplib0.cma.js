// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Sexplib0__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Sexplib0 = [0],
    Sexplib0$0 = [0, Sexplib0];
   runtime.caml_register_global(0, Sexplib0$0, "Sexplib0__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp
//# unitInfo: Requires: Stdlib__Buffer, Stdlib__Bytes, Stdlib__BytesLabels, Stdlib__Char, Stdlib__Format, Stdlib__ListLabels, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "(",
    cst$12 = "()",
    cst$13 = ")",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$11,
    cst$3 = cst$12,
    cst$4 = cst$13,
    cst$5 = " ",
    cst$6 = cst$11,
    cst$7 = cst$12,
    cst$8 = cst$13,
    cst$10 = cst$12,
    cst$9 = cst$12,
    cst = "\\",
    cst$0 = ' "',
    cst$1 = '"',
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    _b_ = [0, [15, [17, 2, 0]], "%a@?"],
    _a_ = [0, 0, 0],
    cst_n = "\\n",
    cst_Sexplib0_Sexp_Not_found_s = "Sexplib0__Sexp.Not_found_s",
    cst_Sexplib0_Sexp_Of_sexp_erro = "Sexplib0__Sexp.Of_sexp_error";
   function sexp_of_t(t){return t;}
   function t_of_sexp(t){return t;}
   function compare(a$0, b$0){
    if(a$0 === b$0) return 0;
    if(0 === a$0[0]){
     var a$1 = a$0[1];
     if(0 !== b$0[0]) return -1;
     var b$1 = b$0[1];
     return caml_call2(Stdlib_StringLabels[10], a$1, b$1);
    }
    var a$2 = a$0[1];
    if(0 === b$0[0]) return 1;
    var b$2 = b$0[1], a = a$2, b = b$2;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], res = compare(x, y);
     if(0 !== res) return res;
     var a = xs, b = ys;
    }
   }
   function equal(a, b){
    var _E_ = a === b ? 1 : 0;
    if(_E_)
     var _F_ = _E_;
    else{
     if(0 === a[0]){
      var a$0 = a[1];
      if(0 === b[0]){
       var b$0 = b[1];
       return caml_call2(Stdlib_StringLabels[9], a$0, b$0);
      }
     }
     else{
      var a$1 = a[1];
      if(0 !== b[0]){
       var b$1 = b[1];
       return caml_call3(Stdlib_ListLabels[16], equal, a$1, b$1);
      }
     }
     var _F_ = 0;
    }
    return _F_;
   }
   var
    Not_found_s = [248, cst_Sexplib0_Sexp_Not_found_s, caml_fresh_oo_id(0)],
    Of_sexp_error = [248, cst_Sexplib0_Sexp_Of_sexp_erro, caml_fresh_oo_id(0)],
    default_indent = [0, 1];
   function must_escape(str){
    var len = caml_ml_string_length(str), _u_ = 0 === len ? 1 : 0;
    if(_u_) return _u_;
    var ix$1 = len - 1 | 0, ix = ix$1;
    for(;;){
     var match = caml_string_get(str, ix);
     a:
     {
      b:
      {
       if(92 <= match){
        var switcher = match - 93 | 0;
        if(33 < switcher >>> 0){if(0 <= switcher) break a; break b;}
        if(31 === switcher){
         var _v_ = 0 < ix ? 1 : 0;
         if(_v_){
          var
           next = ix - 1 | 0,
           _w_ = caml_string_get(str, next),
           _x_ = caml_call2(Stdlib_Char[6], _w_, 35);
          if(! _x_){var ix = next; continue;}
          var _y_ = _x_;
         }
         else
          var _y_ = _v_;
         return _y_;
        }
       }
       else
        if(42 <= match){
         if(59 === match) break b;
        }
        else{
         if(33 > match) break a;
         switch(match - 33 | 0){
           case 2:
            var _A_ = 0 < ix ? 1 : 0;
            if(_A_){
             var
              next$0 = ix - 1 | 0,
              _B_ = caml_string_get(str, next$0),
              _C_ = caml_call2(Stdlib_Char[6], _B_, 124);
             if(! _C_){var ix = next$0; continue;}
             var _D_ = _C_;
            }
            else
             var _D_ = _A_;
            return _D_;
           case 1:
           case 7:
           case 8:
            break b;
         }
        }
       var _z_ = 0 < ix ? 1 : 0;
       if(! _z_) return _z_;
       var ix$0 = ix - 1 | 0, ix = ix$0;
       continue;
      }
      return 1;
     }
     return 1;
    }
   }
   function escaped(s){
    var n = [0, 0], _k_ = caml_ml_string_length(s) - 1 | 0, _j_ = 0;
    if(_k_ >= 0){
     var i$0 = _j_;
     for(;;){
      var match = caml_string_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _r_ = match - 34 | 0;
          if(58 < _r_ >>> 0){
           if(93 <= _r_) break c;
          }
          else if(56 < _r_ - 1 >>> 0) break b;
          var _s_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _s_ = 4;
        break a;
       }
       var _s_ = 2;
      }
      n[1] = n[1] + _s_ | 0;
      var _t_ = i$0 + 1 | 0;
      if(_k_ === i$0) break;
      var i$0 = _t_;
     }
    }
    if(n[1] === caml_ml_string_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _m_ = caml_ml_string_length(s) - 1 | 0, _l_ = 0;
    if(_m_ >= 0){
     var i = _l_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        var _o_ = caml_call1(Stdlib_Char[1], 48 + (c / 100 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _o_);
        n[1]++;
        var
         _p_ = caml_call1(Stdlib_Char[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _p_);
        n[1]++;
        var _q_ = caml_call1(Stdlib_Char[1], 48 + (c % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _q_);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _n_ = i + 1 | 0;
      if(_m_ === i) break;
      var i = _n_;
     }
    }
    return caml_call1(Stdlib_BytesLabels[44], s$0);
   }
   function esc_str(str){
    var
     estr = escaped(str),
     elen = caml_ml_string_length(estr),
     res = caml_create_bytes(elen + 2 | 0);
    caml_call5(Stdlib_Bytes[12], estr, 0, res, 1, elen);
    caml_bytes_unsafe_set(res, 0, 34);
    caml_bytes_unsafe_set(res, elen + 1 | 0, 34);
    return caml_call1(Stdlib_BytesLabels[44], res);
   }
   function index_of_newline(str, start){
    return caml_call3(Stdlib_StringLabels[33], str, start, 10);
   }
   function mach_maybe_esc_str(str){
    return must_escape(str) ? esc_str(str) : str;
   }
   function pp_hum_indent(indent, ppf, param){
    if(0 === param[0]){
     var str = param[1];
     if(! must_escape(str)) return caml_call2(Stdlib_Format[13], ppf, str);
     var match = index_of_newline(str, 0);
     if(match)
      var
       index = match[1],
       _g_ = (index + 1 | 0) === caml_ml_string_length(str) ? 1 : 0;
     else
      var _g_ = 1;
     if(_g_){
      var _h_ = esc_str(str);
      return caml_call2(Stdlib_Format[13], ppf, _h_);
     }
     caml_call2(Stdlib_Format[1], ppf, 0);
     caml_call2(Stdlib_Format[13], ppf, cst$0);
     var index$0 = 0;
     for(;;){
      var next_newline = index_of_newline(str, index$0);
      if(next_newline)
       var end_pos = next_newline[1], end_pos$0 = end_pos;
      else
       var end_pos$0 = caml_ml_string_length(str);
      var
       next_line =
         caml_call3
          (Stdlib_StringLabels[16], str, index$0, end_pos$0 - index$0 | 0),
       _i_ = escaped(next_line);
      caml_call2(Stdlib_Format[13], ppf, _i_);
      if(! next_newline){
       caml_call2(Stdlib_Format[13], ppf, cst$1);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var newline_index = next_newline[1];
      caml_call2(Stdlib_Format[13], ppf, cst);
      caml_call2(Stdlib_Format[34], ppf, 0);
      caml_call2(Stdlib_Format[13], ppf, cst_n);
      var index$1 = newline_index + 1 | 0, index$0 = index$1;
     }
    }
    else{
     var match$0 = param[1];
     if(! match$0) return caml_call2(Stdlib_Format[13], ppf, cst$3);
     var t = match$0[2], h = match$0[1];
     caml_call2(Stdlib_Format[1], ppf, indent);
     caml_call2(Stdlib_Format[13], ppf, cst$2);
     pp_hum_indent(indent, ppf, h);
     var param$0 = t;
     for(;;){
      if(! param$0){
       caml_call2(Stdlib_Format[13], ppf, cst$4);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var t$0 = param$0[2], h$0 = param$0[1];
      caml_call2(Stdlib_Format[27], ppf, 0);
      pp_hum_indent(indent, ppf, h$0);
      var param$0 = t$0;
     }
    }
   }
   function pp_mach_internal(may_need_space, ppf, param){
    if(0 === param[0]){
     var
      str = param[1],
      str$0 = mach_maybe_esc_str(str),
      new_may_need_space = str$0 === str ? 1 : 0,
      new_may_need_space$0 =
        may_need_space ? new_may_need_space : may_need_space;
     if(new_may_need_space$0) caml_call2(Stdlib_Format[13], ppf, cst$5);
     caml_call2(Stdlib_Format[13], ppf, str$0);
     return new_may_need_space;
    }
    var match = param[1];
    if(! match){caml_call2(Stdlib_Format[13], ppf, cst$7); return 0;}
    var t = match[2], h = match[1];
    caml_call2(Stdlib_Format[13], ppf, cst$6);
    var
     may_need_space$0 = pp_mach_internal(0, ppf, h),
     may_need_space$1 = may_need_space$0,
     param$0 = t;
    for(;;){
     if(! param$0){caml_call2(Stdlib_Format[13], ppf, cst$8); return 0;}
     var
      t$0 = param$0[2],
      h$0 = param$0[1],
      may_need_space$2 = pp_mach_internal(may_need_space$1, ppf, h$0),
      may_need_space$1 = may_need_space$2,
      param$0 = t$0;
    }
   }
   function pp_hum(ppf, sexp){
    return pp_hum_indent(default_indent[1], ppf, sexp);
   }
   function pp_mach(ppf, sexp){pp_mach_internal(0, ppf, sexp); return 0;}
   function size_loop(acc, param){
    var c = acc[2], v = acc[1];
    if(0 === param[0]){
     var str = param[1];
     return [0, v + 1 | 0, c + caml_ml_string_length(str) | 0];
    }
    var lst = param[1];
    return caml_call3(Stdlib_ListLabels[26], size_loop, acc, lst);
   }
   function size(sexp){return size_loop(_a_, sexp);}
   function to_buffer_hum(buf, opt, sexp){
    if(opt)
     var sth = opt[1], indent = sth;
    else
     var indent = default_indent[1];
    var ppf = caml_call1(Stdlib_Format[114], buf);
    function _d_(_e_, _f_){return pp_hum_indent(indent, _e_, _f_);}
    return caml_call4(Stdlib_Format[137], ppf, _b_, _d_, sexp);
   }
   function to_buffer_mach(buf, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(Stdlib_Buffer[12], buf, 32);
      caml_call2(Stdlib_Buffer[16], buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(Stdlib_Buffer[16], buf, cst$9); return 0;}
     var t = match[2], h = match[1];
     caml_call2(Stdlib_Buffer[12], buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(Stdlib_Buffer[12], buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0),
       may_need_space$1 = may_need_space$2,
       param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function to_buffer_gen(buf, add_char, add_string, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(add_char, buf, 32);
      caml_call2(add_string, buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(add_string, buf, cst$10); return 0;}
     var t = match[2], h = match[1];
     caml_call2(add_char, buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(add_char, buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0),
       may_need_space$1 = may_need_space$2,
       param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function buffer(param){return caml_call1(Stdlib_Buffer[1], 1024);}
   function to_string_hum(indent, sexp){
    if(0 === sexp[0]){
     var str = sexp[1], _c_ = index_of_newline(str, 0) ? 0 : 1;
     if(_c_) return mach_maybe_esc_str(str);
    }
    var buf = buffer(0);
    to_buffer_hum(buf, indent, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function to_string_mach(sexp){
    if(0 === sexp[0]){var str = sexp[1]; return mach_maybe_esc_str(str);}
    var buf = buffer(0);
    to_buffer_mach(buf, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_float_style = [0, 1009018843], of_int_style = [0, 1009018843];
   function message(name, fields){
    function conv_fields(param){
     if(! param) return 0;
     var
      rest = param[2],
      match = param[1],
      fsexp = match[2],
      fname = match[1];
     return runtime.caml_string_notequal(fname, "")
             ? [0, [1, [0, [0, fname], [0, fsexp, 0]]], conv_fields(rest)]
             : [0, fsexp, conv_fields(rest)];
    }
    return [1, [0, [0, name], conv_fields(fields)]];
   }
   var
    Sexplib0_Sexp =
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp_mach,
       to_string_hum,
       to_string_mach,
       to_string_mach,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer_mach,
        to_buffer_hum,
        to_buffer_mach,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
   runtime.caml_register_global(25, Sexplib0_Sexp, "Sexplib0__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_grammar
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    doc_comment_tag = "sexp_grammar.doc_comment",
    type_name_tag = "sexp_grammar.type_name",
    assoc_tag = "sexp_grammar.assoc",
    assoc_key_tag = "sexp_grammar.assoc.key",
    assoc_value_tag = "sexp_grammar.assoc.value",
    completion_suggested = "sexp_grammar.completion-suggested";
   function coerce(t){return t;}
   function tag(param, key, value){return [5, [0, key, value, param]];}
   var
    Sexplib0_Sexp_grammar =
      [0,
       coerce,
       tag,
       doc_comment_tag,
       type_name_tag,
       assoc_tag,
       assoc_key_tag,
       assoc_value_tag,
       completion_suggested];
   runtime.caml_register_global
    (6, Sexplib0_Sexp_grammar, "Sexplib0__Sexp_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_grammar
//# unitInfo: Requires: Sexplib0__Sexp_grammar, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    unit_sexp_grammar = [2, 0],
    sexp_t_sexp_grammar = [0, "Sexp.t"],
    empty_sexp_grammar = [4, 0],
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels;
   function sexp_grammar_with_tags(grammar, tags){
    function _b_(param, grammar){
     var value = param[2], key = param[1];
     return [5, [0, key, value, grammar]];
    }
    return caml_call3(Stdlib_ListLabels[27], _b_, tags, grammar);
   }
   function sexp_grammar_with_tag_list(x, tags){
    function _a_(param, grammar){
     var value = param[2], key = param[1];
     return [0, [0, key, value, grammar]];
    }
    return caml_call3(Stdlib_ListLabels[27], _a_, tags, x);
   }
   var
    bool_sexp_grammar = 0,
    string_sexp_grammar = 4,
    bytes_sexp_grammar = 4,
    char_sexp_grammar = 1,
    int_sexp_grammar = 2,
    float_sexp_grammar = 3,
    int32_sexp_grammar = 2,
    int64_sexp_grammar = 2,
    nativeint_sexp_grammar = 2;
   function ref_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function lazy_t_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function option_sexp_grammar(param){return [1, param];}
   function list_sexp_grammar(param){return [2, [1, param]];}
   function array_sexp_grammar(param){return [2, [1, param]];}
   var
    Sexplib0_Sexp_conv_grammar =
      [0,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       empty_sexp_grammar,
       empty_sexp_grammar];
   runtime.caml_register_global
    (5, Sexplib0_Sexp_conv_grammar, "Sexplib0__Sexp_conv_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv
//# unitInfo: Requires: CamlinternalLazy, Sexplib0__Sexp, Sexplib0__Sexp_conv_grammar, Stdlib, Stdlib__Arg, Stdlib__ArrayLabels, Stdlib__BytesLabels, Stdlib__Ephemeron, Stdlib__Int32, Stdlib__Int64, Stdlib__Lazy, Stdlib__ListLabels, Stdlib__MoreLabels, Stdlib__Nativeint, Stdlib__Obj, Stdlib__Parsing, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Scanf, Stdlib__Stack, Stdlib__StringLabels, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Assert_failure$0 = "Assert_failure",
    cst_None = "None",
    cst_Some = "Some",
    cst_none = "none",
    cst_option_of_sexp_only_none_c$1 = "option_of_sexp: only none can be atom",
    cst_some = "some",
    cst_src_sexp_conv_ml = "src/sexp_conv.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_format_float = runtime.caml_format_float,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Parsing = global_data.Stdlib__Parsing,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Obj = global_data.Stdlib__Obj,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Ephemeron = global_data.Stdlib__Ephemeron,
    Sexplib0_Sexp_conv_grammar = global_data.Sexplib0__Sexp_conv_grammar,
    _aF_ = [0, 0],
    _aG_ = [0, 1],
    _aB_ = [0, "Sexplib.Conv.Of_sexp_error"],
    _aC_ = [0, cst_src_sexp_conv_ml, 406, 15],
    _ay_ = [0, 0],
    _az_ = [0, 0],
    cst_Assert_failure = cst_Assert_failure$0,
    _av_ = [0, cst_src_sexp_conv_ml, 330, 15],
    _ar_ = [0, "Exit"],
    _as_ = [0, cst_src_sexp_conv_ml, 334, 15],
    _an_ = [0, "End_of_file"],
    _ao_ = [0, cst_src_sexp_conv_ml, 338, 15],
    _aj_ = [0, "Failure"],
    _ak_ = [0, cst_src_sexp_conv_ml, 342, 15],
    _af_ = [0, "Not_found"],
    _ag_ = [0, cst_src_sexp_conv_ml, 346, 15],
    _ab_ = [0, "Invalid_argument"],
    _ac_ = [0, cst_src_sexp_conv_ml, 350, 15],
    cst_Match_failure = "Match_failure",
    ___ = [0, cst_src_sexp_conv_ml, 354, 15],
    _W_ = [0, "Not_found_s"],
    _X_ = [0, cst_src_sexp_conv_ml, 358, 15],
    _S_ = [0, "Sys_error"],
    _T_ = [0, cst_src_sexp_conv_ml, 362, 15],
    _O_ = [0, "Arg.Help"],
    _P_ = [0, cst_src_sexp_conv_ml, 366, 15],
    _K_ = [0, "Arg.Bad"],
    _L_ = [0, cst_src_sexp_conv_ml, 370, 15],
    _G_ = [0, "Lazy.Undefined"],
    _H_ = [0, cst_src_sexp_conv_ml, 374, 15],
    _C_ = [0, "Parsing.Parse_error"],
    _D_ = [0, cst_src_sexp_conv_ml, 378, 15],
    _y_ = [0, "Queue.Empty"],
    _z_ = [0, cst_src_sexp_conv_ml, 382, 15],
    _u_ = [0, "Scanf.Scan_failure"],
    _v_ = [0, cst_src_sexp_conv_ml, 386, 15],
    _q_ = [0, "Stack.Empty"],
    _r_ = [0, cst_src_sexp_conv_ml, 390, 15],
    _m_ = [0, "Sys.Break"],
    _n_ = [0, cst_src_sexp_conv_ml, 394, 15],
    _j_ =
      [0,
       [2,
        0,
        [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, [12, 58, [4, 0, 0, 0, 0]]]]]]],
       "%s %s:%d:%d"],
    cst_fun_of_sexp_cannot_convert =
      "fun_of_sexp: cannot convert function values",
    cst_opaque_of_sexp_cannot_conv =
      "opaque_of_sexp: cannot convert opaque values",
    cst_hashtbl_of_sexp_tuple_list = "hashtbl_of_sexp: tuple list needed",
    cst_hashtbl_of_sexp_list_neede = "hashtbl_of_sexp: list needed",
    cst_array_of_sexp_list_needed = "array_of_sexp: list needed",
    cst_list_of_sexp_list_needed = "list_of_sexp: list needed",
    cst_triple_of_sexp_list_needed = "triple_of_sexp: list needed",
    cst_triple_of_sexp_list_must_c =
      "triple_of_sexp: list must contain exactly three elements only",
    cst_pair_of_sexp_list_needed = "pair_of_sexp: list needed",
    cst_pair_of_sexp_list_must_con =
      "pair_of_sexp: list must contain exactly two elements only",
    cst_option_of_sexp_only_none_c = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_r =
      "option_of_sexp: list must represent optional value",
    cst_option_of_sexp_only_none_c$0 = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_b = "option_of_sexp: list must be (some el)",
    cst_nativeint_of_sexp = "nativeint_of_sexp: ",
    cst_nativeint_of_sexp_atom_nee = "nativeint_of_sexp: atom needed",
    cst_int64_of_sexp = "int64_of_sexp: ",
    cst_int64_of_sexp_atom_needed = "int64_of_sexp: atom needed",
    cst_int32_of_sexp = "int32_of_sexp: ",
    cst_int32_of_sexp_atom_needed = "int32_of_sexp: atom needed",
    cst_float_of_sexp = "float_of_sexp: ",
    cst_float_of_sexp_atom_needed = "float_of_sexp: atom needed",
    cst_int_of_sexp = "int_of_sexp: ",
    cst_int_of_sexp_atom_needed = "int_of_sexp: atom needed",
    cst_char_of_sexp_atom_string_m =
      "char_of_sexp: atom string must contain one character only",
    cst_char_of_sexp_atom_needed = "char_of_sexp: atom needed",
    cst_bytes_of_sexp_atom_needed = "bytes_of_sexp: atom needed",
    cst_string_of_sexp_atom_needed = "string_of_sexp: atom needed",
    cst_bool_of_sexp_unknown_strin = "bool_of_sexp: unknown string",
    cst_bool_of_sexp_atom_needed = "bool_of_sexp: atom needed",
    cst_unit_of_sexp_empty_list_ne = "unit_of_sexp: empty list needed",
    _i_ = [0, 2],
    _h_ = [0, 2],
    _f_ = [0, "<fun>"],
    _e_ = [0, "<opaque>"],
    _b_ = [0, cst_some],
    _c_ = [1, 0],
    _d_ = [0, cst_none],
    _a_ = [1, 0],
    default_string_of_float =
      [0,
       function(x){
        var y = caml_format_float("%.15G", x);
        return caml_float_of_string(y) == x
                ? y
                : caml_format_float("%.17G", x);
       }],
    read_old_option_format = [0, 1],
    write_old_option_format = [0, 1];
   function list_map(f, l){return caml_call2(Stdlib_ListLabels[20], f, l);}
   function sexp_of_unit(param){return _a_;}
   function sexp_of_bool(b){return [0, caml_call1(Stdlib[30], b)];}
   function sexp_of_string(str){return [0, str];}
   function sexp_of_bytes(bytes){
    return [0, caml_call1(Stdlib_BytesLabels[6], bytes)];
   }
   function sexp_of_char(c){
    return [0, caml_call2(Stdlib_StringLabels[1], 1, c)];
   }
   function sexp_of_int(n){return [0, caml_call1(Stdlib[33], n)];}
   function sexp_of_float(n){
    return [0, caml_call1(default_string_of_float[1], n)];
   }
   function sexp_of_int32(n){return [0, caml_call1(Stdlib_Int32[14], n)];}
   function sexp_of_int64(n){return [0, caml_call1(Stdlib_Int64[14], n)];}
   function sexp_of_nativeint(n){
    return [0, caml_call1(Stdlib_Nativeint[15], n)];
   }
   function sexp_of_ref(sexp_of_a, rf){return caml_call1(sexp_of_a, rf[1]);}
   function sexp_of_lazy_t(sexp_of_a, lv){
    var _bl_ = runtime.caml_obj_tag(lv);
    a:
    if(250 === _bl_)
     var _bm_ = lv[1];
    else{
     if(246 !== _bl_ && 244 !== _bl_){var _bm_ = lv; break a;}
     var _bm_ = caml_call1(CamlinternalLazy[2], lv);
    }
    return caml_call1(sexp_of_a, _bm_);
   }
   function sexp_of_option(sexp_of_a, param){
    if(! param) return write_old_option_format[1] ? _c_ : _d_;
    var x = param[1];
    return write_old_option_format[1]
            ? [1, [0, caml_call1(sexp_of_a, x), 0]]
            : [1, [0, _b_, [0, caml_call1(sexp_of_a, x), 0]]];
   }
   function sexp_of_pair(sexp_of_a, sexp_of_b, param){
    var b = param[2], a = param[1], _bk_ = [0, caml_call1(sexp_of_b, b), 0];
    return [1, [0, caml_call1(sexp_of_a, a), _bk_]];
   }
   function sexp_of_triple(sexp_of_a, sexp_of_b, sexp_of_c, param){
    var
     c = param[3],
     b = param[2],
     a = param[1],
     _bi_ = [0, caml_call1(sexp_of_c, c), 0],
     _bj_ = [0, caml_call1(sexp_of_b, b), _bi_];
    return [1, [0, caml_call1(sexp_of_a, a), _bj_]];
   }
   function sexp_of_list(sexp_of_a, lst){
    return [1, caml_call2(Stdlib_ListLabels[20], sexp_of_a, lst)];
   }
   function sexp_of_array(sexp_of_a, ar){
    var lst_ref = [0, 0], _bf_ = ar.length - 1 - 1 | 0;
    if(_bf_ >= 0){
     var i = _bf_;
     for(;;){
      var _bg_ = lst_ref[1];
      lst_ref[1] =
       [0, caml_call1(sexp_of_a, caml_check_bound(ar, i)[1 + i]), _bg_];
      var _bh_ = i - 1 | 0;
      if(0 === i) break;
      var i = _bh_;
     }
    }
    return [1, lst_ref[1]];
   }
   function sexp_of_hashtbl(sexp_of_key, sexp_of_val, htbl){
    function coll(k, v, acc){
     var _be_ = [0, caml_call1(sexp_of_val, v), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, k), _be_]], acc];
    }
    return [1, caml_call3(Stdlib_MoreLabels[1][14], coll, htbl, 0)];
   }
   function sexp_of_opaque(param){return _e_;}
   function sexp_of_fun(param){return _f_;}
   function equal(_bd_, _bc_){return _bd_ === _bc_ ? 1 : 0;}
   var
    hash = Stdlib_Obj[23][3],
    Exn_table = caml_call1(Stdlib_Ephemeron[1][3], [0, equal, hash]),
    the_exn_table = caml_call1(Exn_table[1], 17);
   function add(opt, param, extension_constructor, sexp_of_exn){
    if(opt) var sth = opt[1], printexc = sth; else var printexc = 1;
    return caml_call3
            (Exn_table[5],
             the_exn_table,
             extension_constructor,
             [0, sexp_of_exn, printexc]);
   }
   function find_auto(for_printexc, exn){
    var
     extension_constructor = caml_call1(Stdlib_Obj[23][1], exn),
     match = caml_call2(Exn_table[8], the_exn_table, extension_constructor);
    if(! match) return 0;
    var match$0 = match[1], printexc = match$0[2], sexp_of_exn = match$0[1];
    if(for_printexc && ! printexc) return 0;
    return [0, caml_call1(sexp_of_exn, exn)];
   }
   function size(param){return caml_call1(Exn_table[18], the_exn_table)[1];}
   var For_unit_tests_only = [0, size];
   function sexp_of_exn_opt(exn){return find_auto(0, exn);}
   function sexp_of_exn(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return [1, [0, [0, caml_call1(Stdlib_Printexc[1], exn)], 0]];
    var sexp = match[1];
    return sexp;
   }
   function exn_to_string(e){
    var _bb_ = sexp_of_exn(e);
    return caml_call2(Sexplib0_Sexp[13], 0, _bb_);
   }
   function _g_(exn){
    var match = find_auto(1, exn);
    if(! match) return 0;
    var sexp = match[1];
    return [0, caml_call2(Sexplib0_Sexp[13], _h_, sexp)];
   }
   caml_call1(Stdlib_Printexc[9], _g_);
   function printexc_prefer_sexp(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return caml_call1(Stdlib_Printexc[1], exn);
    var sexp = match[1];
    return caml_call2(Sexplib0_Sexp[13], _i_, sexp);
   }
   var Of_sexp_error = Sexplib0_Sexp[6], record_check_extra_fields = [0, 1];
   function of_sexp_error_exn(exc, sexp){
    throw caml_maybe_attach_backtrace([0, Of_sexp_error, exc, sexp], 1);
   }
   function of_sexp_error(what, sexp){
    throw caml_maybe_attach_backtrace
           ([0, Of_sexp_error, [0, Stdlib[7], what], sexp], 1);
   }
   function unit_of_sexp(sexp){
    if(1 === sexp[0] && ! sexp[1]) return 0;
    return of_sexp_error(cst_unit_of_sexp_empty_list_ne, sexp);
   }
   function bool_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bool_of_sexp_atom_needed, sexp);
    var _ba_ = sexp[1];
    a:
    if(caml_string_notequal(_ba_, "False")){
     if(caml_string_notequal(_ba_, "True")){
      if(! caml_string_notequal(_ba_, "false")) break a;
      if(caml_string_notequal(_ba_, "true"))
       return of_sexp_error(cst_bool_of_sexp_unknown_strin, sexp);
     }
     return 1;
    }
    return 0;
   }
   function string_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_string_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return str;
   }
   function bytes_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bytes_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return caml_call1(Stdlib_BytesLabels[5], str);
   }
   function char_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_char_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    if(1 !== runtime.caml_ml_string_length(str))
     of_sexp_error(cst_char_of_sexp_atom_string_m, sexp);
    return runtime.caml_string_get(str, 0);
   }
   function int_of_sexp(sexp){
    if(0 !== sexp[0]) return of_sexp_error(cst_int_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a$_ = caml_int_of_string(str); return _a$_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a__ = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_int_of_sexp, _a__), sexp);
    }
   }
   function float_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_float_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a9_ = caml_float_of_string(str); return _a9_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a8_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_float_of_sexp, _a8_), sexp);
    }
   }
   function int32_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int32_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a7_ = caml_int_of_string(str); return _a7_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a6_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int32_of_sexp, _a6_), sexp);
    }
   }
   function int64_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int64_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a5_ = runtime.caml_int64_of_string(str); return _a5_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a4_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int64_of_sexp, _a4_), sexp);
    }
   }
   function nativeint_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_nativeint_of_sexp_atom_nee, sexp);
    var str = sexp[1];
    try{var _a3_ = caml_int_of_string(str); return _a3_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a2_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_nativeint_of_sexp, _a2_), sexp);
    }
   }
   function ref_of_sexp(a_of_sexp, sexp){
    return [0, caml_call1(a_of_sexp, sexp)];
   }
   function lazy_t_of_sexp(a_of_sexp, sexp){
    var _a1_ = caml_call1(a_of_sexp, sexp);
    return caml_call1(Stdlib_Lazy[4], _a1_);
   }
   function option_of_sexp(a_of_sexp, sexp){
    if(! read_old_option_format[1]){
     if(0 === sexp[0]){
      var _aW_ = sexp[1];
      if
       (caml_string_notequal(_aW_, cst_None)
        && caml_string_notequal(_aW_, cst_none))
       return of_sexp_error(cst_option_of_sexp_only_none_c$0, sexp);
      return 0;
     }
     var _aX_ = sexp[1];
     a:
     if(_aX_){
      var _aY_ = _aX_[1];
      if(0 === _aY_[0]){
       var _aZ_ = _aY_[1];
       if
        (caml_string_notequal(_aZ_, cst_Some)
         && caml_string_notequal(_aZ_, cst_some))
        break a;
       var _a0_ = _aX_[2];
       if(_a0_ && ! _a0_[2]){
        var el$0 = _a0_[1];
        return [0, caml_call1(a_of_sexp, el$0)];
       }
      }
     }
     return of_sexp_error(cst_option_of_sexp_list_must_b, sexp);
    }
    if(0 === sexp[0]){
     var _aR_ = sexp[1];
     if
      (caml_string_notequal(_aR_, cst_None)
       && caml_string_notequal(_aR_, cst_none))
      return of_sexp_error(cst_option_of_sexp_only_none_c, sexp);
    }
    else{
     var _aS_ = sexp[1];
     if(_aS_){
      var _aT_ = _aS_[1];
      a:
      {
       if(_aS_[2]){
        b:
        if(0 === _aT_[0]){
         var _aU_ = _aT_[1];
         if
          (caml_string_notequal(_aU_, cst_Some)
           && caml_string_notequal(_aU_, cst_some))
          break b;
         var _aV_ = _aS_[2];
         if(! _aV_[2]){var el = _aV_[1]; break a;}
        }
        return of_sexp_error(cst_option_of_sexp_list_must_r, sexp);
       }
       var el = _aT_;
      }
      return [0, caml_call1(a_of_sexp, el)];
     }
    }
    return 0;
   }
   function pair_of_sexp(a_of_sexp, b_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_pair_of_sexp_list_needed, sexp);
    var _aP_ = sexp[1];
    if(_aP_){
     var _aQ_ = _aP_[2];
     if(_aQ_ && ! _aQ_[2]){
      var
       b_sexp = _aQ_[1],
       a_sexp = _aP_[1],
       a = caml_call1(a_of_sexp, a_sexp),
       b = caml_call1(b_of_sexp, b_sexp);
      return [0, a, b];
     }
    }
    return of_sexp_error(cst_pair_of_sexp_list_must_con, sexp);
   }
   function triple_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_triple_of_sexp_list_needed, sexp);
    var _aM_ = sexp[1];
    if(_aM_){
     var _aN_ = _aM_[2];
     if(_aN_){
      var _aO_ = _aN_[2];
      if(_aO_ && ! _aO_[2]){
       var
        c_sexp = _aO_[1],
        b_sexp = _aN_[1],
        a_sexp = _aM_[1],
        a = caml_call1(a_of_sexp, a_sexp),
        b = caml_call1(b_of_sexp, b_sexp),
        c = caml_call1(c_of_sexp, c_sexp);
       return [0, a, b, c];
      }
     }
    }
    return of_sexp_error(cst_triple_of_sexp_list_must_c, sexp);
   }
   function list_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_list_of_sexp_list_needed, sexp);
    var lst = sexp[1];
    return caml_call2(Stdlib_ListLabels[20], a_of_sexp, lst);
   }
   function array_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_array_of_sexp_list_needed, sexp);
    var match = sexp[1];
    if(! match) return [0];
    var
     t = match[2],
     h = match[1],
     len = caml_call1(Stdlib_ListLabels[1], t) + 1 | 0,
     res = runtime.caml_make_vect(len, caml_call1(a_of_sexp, h)),
     i = 1,
     param = t;
    for(;;){
     if(! param) return res;
     var t$0 = param[2], h$0 = param[1], _aL_ = caml_call1(a_of_sexp, h$0);
     caml_check_bound(res, i)[1 + i] = _aL_;
     var i$0 = i + 1 | 0, i = i$0, param = t$0;
    }
   }
   function hashtbl_of_sexp(key_of_sexp, val_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_hashtbl_of_sexp_list_neede, sexp);
    var lst = sexp[1], htbl = caml_call2(Stdlib_MoreLabels[1][1], 0, 0);
    function act(param){
     if(1 === param[0]){
      var _aH_ = param[1];
      if(_aH_){
       var _aI_ = _aH_[2];
       if(_aI_ && ! _aI_[2]){
        var
         v_sexp = _aI_[1],
         k_sexp = _aH_[1],
         _aJ_ = caml_call1(val_of_sexp, v_sexp),
         _aK_ = caml_call1(key_of_sexp, k_sexp);
        return caml_call3(Stdlib_MoreLabels[1][5], htbl, _aK_, _aJ_);
       }
      }
     }
     return of_sexp_error(cst_hashtbl_of_sexp_tuple_list, sexp);
    }
    caml_call2(Stdlib_ListLabels[18], act, lst);
    return htbl;
   }
   function opaque_of_sexp(sexp){
    return of_sexp_error(cst_opaque_of_sexp_cannot_conv, sexp);
   }
   function fun_of_sexp(sexp){
    return of_sexp_error(cst_fun_of_sexp_cannot_convert, sexp);
   }
   var
    sexp_grammar_with_tags = Sexplib0_Sexp_conv_grammar[1],
    sexp_grammar_with_tag_list = Sexplib0_Sexp_conv_grammar[2],
    unit_sexp_grammar = Sexplib0_Sexp_conv_grammar[3],
    bool_sexp_grammar = Sexplib0_Sexp_conv_grammar[4],
    string_sexp_grammar = Sexplib0_Sexp_conv_grammar[5],
    bytes_sexp_grammar = Sexplib0_Sexp_conv_grammar[6],
    char_sexp_grammar = Sexplib0_Sexp_conv_grammar[7],
    int_sexp_grammar = Sexplib0_Sexp_conv_grammar[8],
    float_sexp_grammar = Sexplib0_Sexp_conv_grammar[9],
    int32_sexp_grammar = Sexplib0_Sexp_conv_grammar[10],
    int64_sexp_grammar = Sexplib0_Sexp_conv_grammar[11],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv_grammar[12],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[13],
    ref_sexp_grammar = Sexplib0_Sexp_conv_grammar[14],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[15],
    option_sexp_grammar = Sexplib0_Sexp_conv_grammar[16],
    list_sexp_grammar = Sexplib0_Sexp_conv_grammar[17],
    array_sexp_grammar = Sexplib0_Sexp_conv_grammar[18],
    opaque_sexp_grammar = Sexplib0_Sexp_conv_grammar[19],
    fun_sexp_grammar = Sexplib0_Sexp_conv_grammar[20];
   function get_flc_error(name, param){
    var chr = param[3], line = param[2], file = param[1];
    return [0, caml_call5(Stdlib_Printf[4], _j_, name, file, line, chr)];
   }
   var _k_ = 0;
   function _l_(param){
    if(param === Stdlib_Sys[44]) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   var _o_ = [0, [0, Stdlib_Sys[44], _l_], _k_];
   function _p_(param){
    if(param === Stdlib_Stack[1]) return _q_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
   }
   var _s_ = [0, [0, Stdlib_Stack[1], _p_], _o_];
   function _t_(param){
    if(param[1] !== Stdlib_Scanf[2])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
    var arg = param[2];
    return [1, [0, _u_, [0, [0, arg], 0]]];
   }
   var _w_ = [0, [0, Stdlib_Scanf[2], _t_], _s_];
   function _x_(param){
    if(param === Stdlib_Queue[1]) return _y_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
   }
   var _A_ = [0, [0, Stdlib_Queue[1], _x_], _w_];
   function _B_(param){
    if(param === Stdlib_Parsing[10]) return _C_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
   }
   var _E_ = [0, [0, Stdlib_Parsing[10], _B_], _A_];
   function _F_(param){
    if(param === Stdlib_Lazy[1]) return _G_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
   }
   var _I_ = [0, [0, Stdlib_Lazy[1], _F_], _E_];
   function _J_(param){
    if(param[1] !== Stdlib_Arg[8])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    var arg = param[2];
    return [1, [0, _K_, [0, [0, arg], 0]]];
   }
   var _M_ = [0, [0, Stdlib_Arg[8], _J_], _I_];
   function _N_(param){
    if(param[1] !== Stdlib_Arg[7])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
    var arg = param[2];
    return [1, [0, _O_, [0, [0, arg], 0]]];
   }
   var _Q_ = [0, [0, Stdlib_Arg[7], _N_], _M_];
   function _R_(param){
    if(param[1] !== Stdlib[11])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    var arg = param[2];
    return [1, [0, _S_, [0, [0, arg], 0]]];
   }
   var _U_ = [0, [0, Stdlib[11], _R_], _Q_];
   function _V_(param){
    if(param[1] !== Sexplib0_Sexp[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
    var arg = param[2];
    return [1, [0, _W_, [0, arg, 0]]];
   }
   var _Y_ = [0, [0, Sexplib0_Sexp[5], _V_], _U_];
   function _Z_(param){
    if(param[1] !== Stdlib[4])
     throw caml_maybe_attach_backtrace([0, Assert_failure, ___], 1);
    var arg = param[2];
    return get_flc_error(cst_Match_failure, arg);
   }
   var _$_ = [0, [0, Stdlib[4], _Z_], _Y_];
   function _aa_(param){
    if(param[1] !== Stdlib[6])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
    var arg = param[2];
    return [1, [0, _ab_, [0, [0, arg], 0]]];
   }
   var _ad_ = [0, [0, Stdlib[6], _aa_], _$_];
   function _ae_(param){
    if(param === Stdlib[8]) return _af_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ag_], 1);
   }
   var _ah_ = [0, [0, Stdlib[8], _ae_], _ad_];
   function _ai_(param){
    if(param[1] !== Stdlib[7])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ak_], 1);
    var arg = param[2];
    return [1, [0, _aj_, [0, [0, arg], 0]]];
   }
   var _al_ = [0, [0, Stdlib[7], _ai_], _ah_];
   function _am_(param){
    if(param === Stdlib[12]) return _an_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
   }
   var _ap_ = [0, [0, Stdlib[12], _am_], _al_];
   function _aq_(param){
    if(param === Stdlib[3]) return _ar_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
   }
   var _at_ = [0, [0, Stdlib[3], _aq_], _ap_];
   function _au_(param){
    if(param[1] !== Stdlib[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
    var arg = param[2];
    return get_flc_error(cst_Assert_failure, arg);
   }
   var _aw_ = [0, [0, Stdlib[5], _au_], _at_];
   function _ax_(param){
    var handler = param[2], extension_constructor = param[1];
    return add(_az_, _ay_, extension_constructor, handler);
   }
   caml_call2(Stdlib_ListLabels[18], _ax_, _aw_);
   var
    _aA_ = 0,
    _aD_ =
      [0,
       [0,
        Of_sexp_error,
        function(param){
         if(param[1] !== Of_sexp_error)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aC_], 1);
         var sexp = param[3], exc = param[2];
         return [1, [0, _aB_, [0, sexp_of_exn(exc), [0, sexp, 0]]]];
        }],
       _aA_];
   function _aE_(param){
    var handler = param[2], extension_constructor = param[1];
    return add(_aG_, _aF_, extension_constructor, handler);
   }
   caml_call2(Stdlib_ListLabels[18], _aE_, _aD_);
   var
    Sexplib0_Sexp_conv =
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       [0, add, For_unit_tests_only]];
   runtime.caml_register_global
    (117, Sexplib0_Sexp_conv, "Sexplib0__Sexp_conv");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_error
//# unitInfo: Requires: Sexplib0__Sexp_conv, Stdlib__ListLabels, Stdlib__Printf, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = " ",
    cst_has_incorrect_number_of_ar = " has incorrect number of arguments",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    _h_ =
      [0,
       [11,
        "polymorphic variant tag ",
        [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]],
       "polymorphic variant tag %S has incorrect number of arguments"],
    _g_ =
      [0,
       [11, "the following record elements were undefined: ", [2, 0, 0]],
       "the following record elements were undefined: %s"],
    cst_extra_fields = "extra fields",
    cst_duplicate_fields = "duplicate fields",
    _f_ = [0, [2, 0, [11, ": ", [2, 0, 0]]], "%s: %s"],
    _e_ =
      [0,
       [11, "sum tag ", [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]],
       "sum tag %S has incorrect number of arguments"],
    _d_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: incorrect label for element ",
         [2, 0, [11, " at position ", [4, 3, 0, 0, 0]]]]],
       "%s_of_sexp: incorrect label for element %s at position %i"],
    _c_ =
      [0,
       [2,
        0,
        [11, "_of_sexp: expected a pair beginning with label ", [2, 0, 0]]],
       "%s_of_sexp: expected a pair beginning with label %s"],
    _b_ =
      [0,
       [11, "tuple of size ", [4, 0, 0, 0, [11, " expected", 0]]],
       "tuple of size %d expected"],
    _a_ = [0, [2, 0, [11, "_of_sexp: ", [2, 0, 0]]], "%s_of_sexp: %s"],
    cst_this_constructor_does_not_ =
      "this constructor does not take arguments",
    cst_this_constructor_requires_ = "this constructor requires arguments",
    cst_expected_a_variant_type_sa =
      "expected a variant type, saw a nested list",
    cst_expected_a_variant_type_sa$0 =
      "expected a variant type, saw an empty list",
    cst_unexpected_variant_constru = "unexpected variant constructor",
    cst_record_conversion_a_sexp_b =
      "record conversion: a [sexp.bool] field was given a payload.",
    cst_record_conversion_only_pai =
      "record conversion: only pairs expected, their first element must be an atom",
    cst_list_instead_of_atom_for_r =
      "list instead of atom for record expected",
    cst_cannot_convert_values_of_t =
      "cannot convert values of types resulting from polymorphic record fields",
    cst_Sexplib0_Sexp_conv_error_N =
      "Sexplib0__Sexp_conv_error.No_variant_match",
    cst_no_matching_variant_found = "no matching variant found",
    cst_polymorphic_variant_does_n =
      "polymorphic variant does not take arguments",
    cst_polymorphic_variant_tag_ta =
      "polymorphic variant tag takes an argument",
    cst_a_nested_list_is_an_invali =
      "a nested list is an invalid polymorphic variant",
    cst_the_empty_list_is_an_inval =
      "the empty list is an invalid polymorphic variant",
    cst_trying_to_convert_an_empty = "trying to convert an empty type";
   function error(loc, sexp, msg){
    var _O_ = caml_call3(Stdlib_Printf[4], _a_, loc, msg);
    return caml_call2(Sexplib0_Sexp_conv[27], _O_, sexp);
   }
   function simple_error(msg, loc, sexp){return error(loc, sexp, msg);}
   function tuple_of_size_n_expected(loc, n, sexp){
    return error(loc, sexp, caml_call2(Stdlib_Printf[4], _b_, n));
   }
   function tuple_pair_expected(loc, name, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _c_, loc, name);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function tuple_incorrect_label(loc, name, pos, sexp){
    var msg = caml_call4(Stdlib_Printf[4], _d_, loc, name, pos);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function stag_no_args(_M_, _N_){
    return simple_error(cst_this_constructor_does_not_, _M_, _N_);
   }
   function stag_incorrect_n_args(loc, tag, sexp){
    return error(loc, sexp, caml_call2(Stdlib_Printf[4], _e_, tag));
   }
   function stag_takes_args(_K_, _L_){
    return simple_error(cst_this_constructor_requires_, _K_, _L_);
   }
   function nested_list_invalid_sum(_I_, _J_){
    return simple_error(cst_expected_a_variant_type_sa, _I_, _J_);
   }
   function empty_list_invalid_sum(_G_, _H_){
    return simple_error(cst_expected_a_variant_type_sa$0, _G_, _H_);
   }
   function unexpected_stag(_E_, _F_){
    return simple_error(cst_unexpected_variant_constru, _E_, _F_);
   }
   function record_sexp_bool_with_payload(_C_, _D_){
    return simple_error(cst_record_conversion_a_sexp_b, _C_, _D_);
   }
   function record_only_pairs_expected(_A_, _B_){
    return simple_error(cst_record_conversion_only_pai, _A_, _B_);
   }
   function record_invalid_fields(what, loc, fld_names, sexp){
    var fld_names_str = caml_call2(Stdlib_StringLabels[7], cst, fld_names);
    return error
            (loc,
             sexp,
             caml_call3(Stdlib_Printf[4], _f_, what, fld_names_str));
   }
   function record_duplicate_fields(loc, fld_names, sexp){
    return record_invalid_fields(cst_duplicate_fields, loc, fld_names, sexp);
   }
   function record_extra_fields(loc, fld_names, sexp){
    return record_invalid_fields(cst_extra_fields, loc, fld_names, sexp);
   }
   function record_get_undefined_loop(fields, param){
    var fields$0 = fields, param$0 = param;
    for(;;){
     if(! param$0){
      var _z_ = caml_call1(Stdlib_ListLabels[10], fields$0);
      return caml_call2(Stdlib_StringLabels[7], cst$0, _z_);
     }
     var _y_ = param$0[1];
     if(_y_[1])
      var
       rest = param$0[2],
       field = _y_[2],
       fields$1 = [0, field, fields$0],
       fields$0 = fields$1,
       param$0 = rest;
     else
      var rest$0 = param$0[2], param$0 = rest$0;
    }
   }
   function record_undefined_elements(loc, sexp, lst){
    var
     undefined$0 = record_get_undefined_loop(0, lst),
     msg = caml_call2(Stdlib_Printf[4], _g_, undefined$0);
    return error(loc, sexp, msg);
   }
   function record_list_instead_atom(_w_, _x_){
    return simple_error(cst_list_instead_of_atom_for_r, _w_, _x_);
   }
   function record_poly_field_value(_u_, _v_){
    return simple_error(cst_cannot_convert_values_of_t, _u_, _v_);
   }
   var
    No_variant_match =
      [248, cst_Sexplib0_Sexp_conv_error_N, runtime.caml_fresh_oo_id(0)];
   function no_variant_match(param){
    throw caml_maybe_attach_backtrace(No_variant_match, 1);
   }
   function no_matching_variant_found(_s_, _t_){
    return simple_error(cst_no_matching_variant_found, _s_, _t_);
   }
   function ptag_no_args(_q_, _r_){
    return simple_error(cst_polymorphic_variant_does_n, _q_, _r_);
   }
   function ptag_incorrect_n_args(loc, cnstr, sexp){
    return error(loc, sexp, caml_call2(Stdlib_Printf[4], _h_, cnstr));
   }
   function ptag_takes_args(_o_, _p_){
    return simple_error(cst_polymorphic_variant_tag_ta, _o_, _p_);
   }
   function nested_list_invalid_poly_var(_m_, _n_){
    return simple_error(cst_a_nested_list_is_an_invali, _m_, _n_);
   }
   function empty_list_invalid_poly_var(_k_, _l_){
    return simple_error(cst_the_empty_list_is_an_inval, _k_, _l_);
   }
   function empty_type(_i_, _j_){
    return simple_error(cst_trying_to_convert_an_empty, _i_, _j_);
   }
   var
    Sexplib0_Sexp_conv_error =
      [0,
       Of_sexp_error,
       error,
       simple_error,
       tuple_of_size_n_expected,
       tuple_pair_expected,
       tuple_incorrect_label,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_sexp_bool_with_payload,
       record_only_pairs_expected,
       record_invalid_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       empty_type];
   runtime.caml_register_global
    (32, Sexplib0_Sexp_conv_error, "Sexplib0__Sexp_conv_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_labeled_tuple
//# unitInfo: Requires: Sexplib0__Sexp_conv_error, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error;
   function labeled_tuple_of_sexp(caller, fields$2, create, original_sexp){
    var t = fields$2, acc = 0;
    for(;;){
     if(! t) break;
     var acc$0 = acc + 1 | 0, t$0 = t[3], t = t$0, acc = acc$0;
    }
    if(0 === original_sexp[0])
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], caller, acc, original_sexp);
    var list$2 = original_sexp[1];
    a:
    {
     var pos$1 = 0;
     if(fields$2){
      var fields = fields$2[3], conv = fields$2[2], name = fields$2[1];
      if(list$2){
       var list = list$2[2], sexp = list$2[1];
       if(1 === sexp[0]){
        var _a_ = sexp[1];
        if(_a_){
         var _b_ = _a_[1];
         if(0 === _b_[0]){
          var _c_ = _a_[2];
          if(_c_ && ! _c_[2]){
           var sexp$0 = _c_[1], atom = _b_[1];
           if(! caml_call2(Stdlib_String[9], atom, name)){
            var
             _g_ =
               caml_call4
                (Sexplib0_Sexp_conv_error[6],
                 caller,
                 name,
                 pos$1,
                 original_sexp);
            break a;
           }
           var
            block = [0, caml_call1(conv, sexp$0), 24029],
            dst = block,
            offset = 1,
            fields$0 = fields,
            pos = 1,
            list$0 = list;
           for(;;){
            b:
            if(fields$0){
             var
              fields$1 = fields$0[3],
              conv$0 = fields$0[2],
              name$0 = fields$0[1];
             if(list$0){
              var list$1 = list$0[2], sexp$1 = list$0[1];
              if(1 === sexp$1[0]){
               var _d_ = sexp$1[1];
               if(_d_){
                var _e_ = _d_[1];
                if(0 === _e_[0]){
                 var _f_ = _d_[2];
                 if(_f_ && ! _f_[2]){
                  var sexp$2 = _f_[1], atom$0 = _e_[1];
                  if(caml_call2(Stdlib_String[9], atom$0, name$0)){
                   var dst$0 = [0, caml_call1(conv$0, sexp$2), 24029];
                   dst[1 + offset] = dst$0;
                   var
                    pos$0 = pos + 1 | 0,
                    dst = dst$0,
                    offset = 1,
                    fields$0 = fields$1,
                    pos = pos$0,
                    list$0 = list$1;
                   continue;
                  }
                  dst[1 + offset] =
                   caml_call4
                    (Sexplib0_Sexp_conv_error[6],
                     caller,
                     name$0,
                     pos,
                     original_sexp);
                  break b;
                 }
                }
               }
              }
              dst[1 + offset] =
               caml_call3(Sexplib0_Sexp_conv_error[5], caller, name$0, sexp$1);
             }
             else
              dst[1 + offset] =
               caml_call3
                (Sexplib0_Sexp_conv_error[4], caller, acc, original_sexp);
            }
            else if(list$0)
             dst[1 + offset] =
              caml_call3
               (Sexplib0_Sexp_conv_error[4], caller, acc, original_sexp);
            else
             dst[1 + offset] = 0;
            var _g_ = block;
            break a;
           }
          }
         }
        }
       }
       var _g_ = caml_call3(Sexplib0_Sexp_conv_error[5], caller, name, sexp);
      }
      else
       var
        _g_ =
          caml_call3(Sexplib0_Sexp_conv_error[4], caller, acc, original_sexp);
     }
     else
      var
       _g_ =
         list$2
          ? caml_call3
            (Sexplib0_Sexp_conv_error[4], caller, acc, original_sexp)
          : 0;
    }
    return caml_call1(create, _g_);
   }
   var Sexplib0_Sexp_conv_labeled_tup = [0, [0], labeled_tuple_of_sexp];
   runtime.caml_register_global
    (2, Sexplib0_Sexp_conv_labeled_tup, "Sexplib0__Sexp_conv_labeled_tuple");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_record
//# unitInfo: Requires: Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stdlib, Stdlib__ArrayLabels, Stdlib__ListLabels, Stdlib__Option, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    absent = [0, ""],
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib = global_data.Stdlib,
    Kind = [0],
    _a_ = [1, 0],
    _b_ = [3, 0],
    cst_Sexplib0_Sexp_conv_record_ = "Sexplib0__Sexp_conv_record.Malformed";
   function combine(a, b){
    a:
    if(typeof a !== "number"){
     b:
     {
      c:
      {
       d:
       {
        e:
        switch(a[0]){
          case 0:
           var a$0 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 0:
               var b$0 = b[1]; return [0, caml_call2(Stdlib[37], a$0, b$0)];
              case 1:
               break d;
              default: var t$0 = a; break e;
            }
           break b;
          case 1:
           var a$1 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 1:
               var b$1 = b[1]; return [1, caml_call2(Stdlib[37], a$1, b$1)];
              default: var t = a; break c;
            }
           break b;
          case 2:
           var a$2 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 0:
               var t$0 = b; break e;
              case 1:
               break d;
              default:
               var b$2 = b[1]; return [2, caml_call2(Stdlib[37], a$2, b$2)];
            }
           break b;
          default: break a;
        }
        return t$0;
       }
       var t = b;
      }
      return t;
     }
     return b;
    }
    return a;
   }
   var
    Malformed =
      [248, cst_Sexplib0_Sexp_conv_record_, runtime.caml_fresh_oo_id(0)];
   function parse_value_malformed(malformed, fields, state, pos){
    try{
     parse_values(fields[4], state, pos + 1 | 0);
     var malformed$0 = malformed;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var other = exn[2], malformed$0 = combine(malformed, other);
    }
    throw caml_maybe_attach_backtrace([0, Malformed, malformed$0], 1);
   }
   function parse_values(fields, state, pos){
    if(! fields) return 0;
    var
     rest = fields[4],
     conv = fields[3],
     kind = fields[2],
     name = fields[1],
     sexp = state[1 + pos];
    a:
    {
     b:
     {
      if(typeof kind !== "number"){
       var default$0 = kind[1];
       if(0 === sexp[0])
        var _F_ = caml_call1(default$0, 0);
       else{
        var _G_ = sexp[1];
        if(! _G_) break b;
        var _H_ = _G_[2];
        if(! _H_) break b;
        if(_H_[2]) break b;
        var sexp$5 = _H_[1], _F_ = caml_call1(conv, sexp$5);
       }
       var value = _F_;
       break a;
      }
      switch(kind){
        case 0:
         if(0 === sexp[0]){var value = caml_call1(conv, _a_); break a;}
         var _r_ = sexp[1];
         if(_r_){
          var _s_ = _r_[2];
          if(_s_ && ! _s_[2]){
           var sexp$0 = _s_[1], value = caml_call1(conv, sexp$0);
           break a;
          }
         }
         break;
        case 1:
         if(0 === sexp[0]){
          var
           value =
             parse_value_malformed([2, [0, name, 0]], fields, state, pos);
          break a;
         }
         var _v_ = sexp[1];
         if(_v_){
          var _w_ = _v_[2];
          if(_w_ && ! _w_[2]){
           var sexp$1 = _w_[1], value = caml_call1(conv, sexp$1);
           break a;
          }
         }
         break;
        case 2:
         if(0 === sexp[0]){var value = [0]; break a;}
         var _x_ = sexp[1];
         if(_x_){
          var _y_ = _x_[2];
          if(_y_ && ! _y_[2]){
           var
            sexp$2 = _y_[1],
            value = caml_call2(Sexplib0_Sexp_conv[45], conv, sexp$2);
           break a;
          }
         }
         break;
        case 3:
         if(0 === sexp[0]){var value = 0; break a;}
         var _z_ = sexp[1];
         c:
         {
          if(_z_ && ! _z_[2]){var _A_ = 1; break c;}
          var _A_ = parse_value_malformed(0, fields, state, pos);
         }
         var value = _A_;
         break a;
        case 4:
         if(0 === sexp[0]){var value = 0; break a;}
         var _B_ = sexp[1];
         if(_B_){
          var _C_ = _B_[2];
          if(_C_ && ! _C_[2]){
           var
            sexp$3 = _C_[1],
            value = caml_call2(Sexplib0_Sexp_conv[44], conv, sexp$3);
           break a;
          }
         }
         break;
        default:
         if(0 === sexp[0]){var value = 0; break a;}
         var _D_ = sexp[1];
         if(_D_){
          var _E_ = _D_[2];
          if(_E_ && ! _E_[2]){
           var sexp$4 = _E_[1], value = [0, caml_call1(conv, sexp$4)];
           break a;
          }
         }
      }
     }
     var _t_ = sexp[1];
     b:
     {
      if(_t_ && _t_[2]){
       var _u_ = parse_value_malformed([3, [0, sexp]], fields, state, pos);
       break b;
      }
      var _u_ = parse_value_malformed(_b_, fields, state, pos);
     }
     var value = _u_;
    }
    return [0, value, parse_values(rest, state, pos + 1 | 0)];
   }
   function parse_spine_malformed
   (malformed, index, extra, seen, state, len, sexps){
    try{
     parse_spine_slow(index, extra, seen, state, len, sexps);
     var malformed$0 = malformed;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var other = exn[2], malformed$0 = combine(malformed, other);
    }
    throw caml_maybe_attach_backtrace([0, Malformed, malformed$0], 1);
   }
   function parse_spine_slow(index, extra, seen, state, len, sexps){
    var sexps$0 = sexps;
    for(;;){
     if(! sexps$0) return;
     var field = sexps$0[1];
     if(1 === field[0]){
      var _m_ = field[1];
      if(_m_){
       var match = _m_[1];
       if(0 === match[0]){
        var
         sexps$2 = sexps$0[2],
         name = match[1],
         i = caml_call1(index, name),
         _n_ = seen <= i ? 1 : 0,
         _o_ = _n_ ? i < len ? 1 : 0 : _n_;
        if(_o_){
         var pos = i - seen | 0;
         if(0 !== state[1 + pos][0])
          return parse_spine_malformed
                  ([1, [0, name, 0]], index, extra, seen, state, len, sexps$2);
         state[1 + pos] = field;
         var sexps$0 = sexps$2;
         continue;
        }
        var _p_ = 0 <= i ? 1 : 0, _q_ = _p_ ? i < seen ? 1 : 0 : _p_;
        if(_q_)
         return parse_spine_malformed
                 ([1, [0, name, 0]], index, extra, seen, state, len, sexps$2);
        if(! extra)
         return parse_spine_malformed
                 ([0, [0, name, 0]], index, extra, seen, state, len, sexps$2);
        var sexps$0 = sexps$2;
        continue;
       }
      }
     }
     var sexps$1 = sexps$0[2];
     return parse_spine_malformed
             ([3, [0, field]], index, extra, seen, state, len, sexps$1);
    }
   }
   function parse_record_slow(fields, index, extra, seen, sexps){
    var t = fields, unseen = 0;
    for(;;){
     if(! t){
      var
       state = runtime.caml_make_vect(unseen, absent),
       len = seen + unseen | 0;
      parse_spine_slow(index, extra, seen, state, len, sexps);
      return parse_values(fields, state, 0);
     }
     var rest = t[4], acc = unseen + 1 | 0, t = rest, unseen = acc;
    }
   }
   function parse_spine_fast(fields, index, extra, seen, sexps){
    if(! fields)
     return sexps ? parse_record_slow(fields, index, extra, seen, sexps) : 0;
    var
     rest = fields[4],
     conv = fields[3],
     kind = fields[2],
     name = fields[1];
    if(sexps){
     var _e_ = sexps[1];
     if(0 !== _e_[0]){
      var _f_ = _e_[1];
      if(_f_){
       var match = _f_[1];
       if(0 === match[0]){
        var others = sexps[2], args = _f_[2], atom = match[1];
        if(caml_call2(Stdlib_StringLabels[9], atom, name)){
         if(typeof kind === "number")
          switch(kind){
            case 0:
             if(args && ! args[2]){
              var
               sexp = args[1],
               _g_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, caml_call1(conv, sexp), _g_];
             }
             break;
            case 1:
             if(args && ! args[2]){
              var
               sexp$0 = args[1],
               _h_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, caml_call1(conv, sexp$0), _h_];
             }
             break;
            case 2:
             if(args && ! args[2]){
              var
               sexp$1 = args[1],
               _i_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0,
                      caml_call2(Sexplib0_Sexp_conv[45], conv, sexp$1),
                      _i_];
             }
             break;
            case 3:
             if(! args)
              return [0,
                      1,
                      parse_spine_fast(rest, index, extra, seen + 1 | 0, others)];
             break;
            case 4:
             if(args && ! args[2]){
              var
               sexp$2 = args[1],
               _j_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0,
                      caml_call2(Sexplib0_Sexp_conv[44], conv, sexp$2),
                      _j_];
             }
             break;
            default:
             if(args && ! args[2]){
              var
               sexp$3 = args[1],
               _k_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, [0, caml_call1(conv, sexp$3)], _k_];
             }
          }
         else if(args && ! args[2]){
          var
           sexp$4 = args[1],
           _l_ = parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
          return [0, caml_call1(conv, sexp$4), _l_];
         }
         return parse_record_slow(fields, index, extra, seen, sexps);
        }
       }
      }
     }
    }
    return parse_record_slow(fields, index, extra, seen, sexps);
   }
   function record_of_sexps
   (caller,
    context$0,
    fields,
    index_of_field,
    allow_extra_fields,
    create,
    sexps){
    var
     allow_extra_fields$0 =
       allow_extra_fields || 1 - Sexplib0_Sexp_conv[26][1];
    try{
     var
      value =
        parse_spine_fast
         (fields, index_of_field, allow_extra_fields$0, 0, sexps);
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var malformed = exn[2];
     if(typeof malformed === "number")
      return caml_call2(Sexplib0_Sexp_conv_error[13], caller, context$0);
     switch(malformed[0]){
       case 0:
        var names = malformed[1];
        return caml_call3
                (Sexplib0_Sexp_conv_error[17], caller, names, context$0);
       case 1:
        var names$0 = malformed[1];
        return caml_call3
                (Sexplib0_Sexp_conv_error[16], caller, names$0, context$0);
       case 2:
        var
         names$1 = malformed[1],
         _c_ = function(name){return [0, 1, name];},
         _d_ = caml_call2(Stdlib_ListLabels[20], _c_, names$1);
        return caml_call1
                (caml_call2(Sexplib0_Sexp_conv_error[19], caller, context$0),
                 _d_);
       default:
        var
         maybe_context = malformed[1],
         context = caml_call2(Stdlib_Option[3], maybe_context, context$0);
        return caml_call2(Sexplib0_Sexp_conv_error[14], caller, context);
     }
    }
    return caml_call1(create, value);
   }
   function record_of_sexp
   (caller, fields, index_of_field, allow_extra_fields, create, sexp){
    if(0 === sexp[0])
     return caml_call2(Sexplib0_Sexp_conv_error[20], caller, sexp);
    var sexps = sexp[1];
    return record_of_sexps
            (caller,
             sexp,
             fields,
             index_of_field,
             allow_extra_fields,
             create,
             sexps);
   }
   var
    Sexplib0_Sexp_conv_record =
      [0, Kind, [0], record_of_sexp, record_of_sexps];
   runtime.caml_register_global
    (10, Sexplib0_Sexp_conv_record, "Sexplib0__Sexp_conv_record");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexpable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0_Sexpable = [0];
   runtime.caml_register_global(0, Sexplib0_Sexpable, "Sexplib0__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90IiwidCIsInRfb2Zfc2V4cCIsImNvbXBhcmUiLCJhJDAiLCJiJDAiLCJhJDEiLCJiJDEiLCJhJDIiLCJiJDIiLCJhIiwiYiIsInlzIiwieSIsInhzIiwieCIsInJlcyIsImVxdWFsIiwiZGVmYXVsdF9pbmRlbnQiLCJtdXN0X2VzY2FwZSIsInN0ciIsImxlbiIsIml4JDEiLCJpeCIsIm5leHQiLCJuZXh0JDAiLCJpeCQwIiwiZXNjYXBlZCIsInMiLCJuIiwiaSQwIiwicyQwIiwiaSIsImMiLCJlc2Nfc3RyIiwiZXN0ciIsImVsZW4iLCJpbmRleF9vZl9uZXdsaW5lIiwic3RhcnQiLCJtYWNoX21heWJlX2VzY19zdHIiLCJwcF9odW1faW5kZW50IiwiaW5kZW50IiwicHBmIiwiaW5kZXgiLCJpbmRleCQwIiwibmV4dF9uZXdsaW5lIiwiZW5kX3BvcyIsImVuZF9wb3MkMCIsIm5leHRfbGluZSIsIm5ld2xpbmVfaW5kZXgiLCJpbmRleCQxIiwiaCIsInQkMCIsImgkMCIsInBwX21hY2hfaW50ZXJuYWwiLCJtYXlfbmVlZF9zcGFjZSIsInN0ciQwIiwibmV3X21heV9uZWVkX3NwYWNlIiwibmV3X21heV9uZWVkX3NwYWNlJDAiLCJtYXlfbmVlZF9zcGFjZSQwIiwibWF5X25lZWRfc3BhY2UkMSIsIm1heV9uZWVkX3NwYWNlJDIiLCJwcF9odW0iLCJzZXhwIiwicHBfbWFjaCIsInNpemVfbG9vcCIsImFjYyIsInYiLCJsc3QiLCJzaXplIiwidG9fYnVmZmVyX2h1bSIsImJ1ZiIsIm9wdCIsInN0aCIsInRvX2J1ZmZlcl9tYWNoIiwibG9vcCIsInRvX2J1ZmZlcl9nZW4iLCJhZGRfY2hhciIsImFkZF9zdHJpbmciLCJidWZmZXIiLCJ0b19zdHJpbmdfaHVtIiwidG9fc3RyaW5nX21hY2giLCJvZl9mbG9hdF9zdHlsZSIsIm9mX2ludF9zdHlsZSIsIm1lc3NhZ2UiLCJuYW1lIiwiZmllbGRzIiwiY29udl9maWVsZHMiLCJyZXN0IiwiZnNleHAiLCJmbmFtZSIsImRvY19jb21tZW50X3RhZyIsInR5cGVfbmFtZV90YWciLCJhc3NvY190YWciLCJhc3NvY19rZXlfdGFnIiwiYXNzb2NfdmFsdWVfdGFnIiwiY29tcGxldGlvbl9zdWdnZXN0ZWQiLCJjb2VyY2UiLCJ0YWciLCJwYXJhbSIsImtleSIsInZhbHVlIiwidW5pdF9zZXhwX2dyYW1tYXIiLCJzZXhwX3Rfc2V4cF9ncmFtbWFyIiwiZW1wdHlfc2V4cF9ncmFtbWFyIiwic2V4cF9ncmFtbWFyX3dpdGhfdGFncyIsImdyYW1tYXIiLCJ0YWdzIiwic2V4cF9ncmFtbWFyX3dpdGhfdGFnX2xpc3QiLCJib29sX3NleHBfZ3JhbW1hciIsInN0cmluZ19zZXhwX2dyYW1tYXIiLCJieXRlc19zZXhwX2dyYW1tYXIiLCJjaGFyX3NleHBfZ3JhbW1hciIsImludF9zZXhwX2dyYW1tYXIiLCJmbG9hdF9zZXhwX2dyYW1tYXIiLCJpbnQzMl9zZXhwX2dyYW1tYXIiLCJpbnQ2NF9zZXhwX2dyYW1tYXIiLCJuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIiwicmVmX3NleHBfZ3JhbW1hciIsImxhenlfdF9zZXhwX2dyYW1tYXIiLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwibGlzdF9zZXhwX2dyYW1tYXIiLCJhcnJheV9zZXhwX2dyYW1tYXIiLCJkZWZhdWx0X3N0cmluZ19vZl9mbG9hdCIsInJlYWRfb2xkX29wdGlvbl9mb3JtYXQiLCJ3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCIsImxpc3RfbWFwIiwiZiIsImwiLCJzZXhwX29mX3VuaXQiLCJzZXhwX29mX2Jvb2wiLCJzZXhwX29mX3N0cmluZyIsInNleHBfb2ZfYnl0ZXMiLCJieXRlcyIsInNleHBfb2ZfY2hhciIsInNleHBfb2ZfaW50Iiwic2V4cF9vZl9mbG9hdCIsInNleHBfb2ZfaW50MzIiLCJzZXhwX29mX2ludDY0Iiwic2V4cF9vZl9uYXRpdmVpbnQiLCJzZXhwX29mX3JlZiIsInNleHBfb2ZfYSIsInJmIiwic2V4cF9vZl9sYXp5X3QiLCJsdiIsInNleHBfb2Zfb3B0aW9uIiwic2V4cF9vZl9wYWlyIiwic2V4cF9vZl9iIiwic2V4cF9vZl90cmlwbGUiLCJzZXhwX29mX2MiLCJzZXhwX29mX2xpc3QiLCJzZXhwX29mX2FycmF5IiwiYXIiLCJsc3RfcmVmIiwic2V4cF9vZl9oYXNodGJsIiwic2V4cF9vZl9rZXkiLCJzZXhwX29mX3ZhbCIsImh0YmwiLCJjb2xsIiwiayIsInNleHBfb2Zfb3BhcXVlIiwic2V4cF9vZl9mdW4iLCJoYXNoIiwidGhlX2V4bl90YWJsZSIsImFkZCIsImV4dGVuc2lvbl9jb25zdHJ1Y3RvciIsInNleHBfb2ZfZXhuIiwicHJpbnRleGMiLCJmaW5kX2F1dG8iLCJmb3JfcHJpbnRleGMiLCJleG4iLCJzZXhwX29mX2V4bl9vcHQiLCJleG5fdG9fc3RyaW5nIiwiZSIsInByaW50ZXhjX3ByZWZlcl9zZXhwIiwicmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkcyIsIm9mX3NleHBfZXJyb3JfZXhuIiwiZXhjIiwib2Zfc2V4cF9lcnJvciIsIndoYXQiLCJ1bml0X29mX3NleHAiLCJib29sX29mX3NleHAiLCJzdHJpbmdfb2Zfc2V4cCIsImJ5dGVzX29mX3NleHAiLCJjaGFyX29mX3NleHAiLCJpbnRfb2Zfc2V4cCIsImV4YyQwIiwiZmxvYXRfb2Zfc2V4cCIsImludDMyX29mX3NleHAiLCJpbnQ2NF9vZl9zZXhwIiwibmF0aXZlaW50X29mX3NleHAiLCJyZWZfb2Zfc2V4cCIsImFfb2Zfc2V4cCIsImxhenlfdF9vZl9zZXhwIiwib3B0aW9uX29mX3NleHAiLCJlbCQwIiwiZWwiLCJwYWlyX29mX3NleHAiLCJiX29mX3NleHAiLCJiX3NleHAiLCJhX3NleHAiLCJ0cmlwbGVfb2Zfc2V4cCIsImNfb2Zfc2V4cCIsImNfc2V4cCIsImxpc3Rfb2Zfc2V4cCIsImFycmF5X29mX3NleHAiLCJoYXNodGJsX29mX3NleHAiLCJrZXlfb2Zfc2V4cCIsInZhbF9vZl9zZXhwIiwiYWN0Iiwidl9zZXhwIiwia19zZXhwIiwib3BhcXVlX29mX3NleHAiLCJmdW5fb2Zfc2V4cCIsImdldF9mbGNfZXJyb3IiLCJjaHIiLCJsaW5lIiwiZmlsZSIsImFyZyIsImhhbmRsZXIiLCJlcnJvciIsImxvYyIsIm1zZyIsInNpbXBsZV9lcnJvciIsInR1cGxlX29mX3NpemVfbl9leHBlY3RlZCIsInR1cGxlX3BhaXJfZXhwZWN0ZWQiLCJ0dXBsZV9pbmNvcnJlY3RfbGFiZWwiLCJwb3MiLCJzdGFnX25vX2FyZ3MiLCJzdGFnX2luY29ycmVjdF9uX2FyZ3MiLCJzdGFnX3Rha2VzX2FyZ3MiLCJuZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSIsImVtcHR5X2xpc3RfaW52YWxpZF9zdW0iLCJ1bmV4cGVjdGVkX3N0YWciLCJyZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCIsInJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIiwicmVjb3JkX2ludmFsaWRfZmllbGRzIiwiZmxkX25hbWVzIiwiZmxkX25hbWVzX3N0ciIsInJlY29yZF9kdXBsaWNhdGVfZmllbGRzIiwicmVjb3JkX2V4dHJhX2ZpZWxkcyIsInJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AiLCJmaWVsZHMkMCIsImZpZWxkIiwicmVzdCQwIiwicmVjb3JkX3VuZGVmaW5lZF9lbGVtZW50cyIsInVuZGVmaW5lZCQwIiwicmVjb3JkX2xpc3RfaW5zdGVhZF9hdG9tIiwicmVjb3JkX3BvbHlfZmllbGRfdmFsdWUiLCJub192YXJpYW50X21hdGNoIiwibm9fbWF0Y2hpbmdfdmFyaWFudF9mb3VuZCIsInB0YWdfbm9fYXJncyIsInB0YWdfaW5jb3JyZWN0X25fYXJncyIsImNuc3RyIiwicHRhZ190YWtlc19hcmdzIiwibmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhciIsImVtcHR5X2xpc3RfaW52YWxpZF9wb2x5X3ZhciIsImVtcHR5X3R5cGUiLCJsYWJlbGVkX3R1cGxlX29mX3NleHAiLCJjYWxsZXIiLCJmaWVsZHMkMiIsImNyZWF0ZSIsIm9yaWdpbmFsX3NleHAiLCJhY2MkMCIsImxpc3QkMiIsInBvcyQxIiwiY29udiIsImxpc3QiLCJzZXhwJDAiLCJhdG9tIiwiYWJzZW50IiwiY29tYmluZSIsInBhcnNlX3ZhbHVlX21hbGZvcm1lZCIsIm1hbGZvcm1lZCIsInN0YXRlIiwicGFyc2VfdmFsdWVzIiwibWFsZm9ybWVkJDAiLCJvdGhlciIsImtpbmQiLCJkZWZhdWx0JDAiLCJzZXhwJDUiLCJzZXhwJDEiLCJzZXhwJDIiLCJzZXhwJDMiLCJzZXhwJDQiLCJwYXJzZV9zcGluZV9tYWxmb3JtZWQiLCJleHRyYSIsInNlZW4iLCJzZXhwcyIsInBhcnNlX3NwaW5lX3Nsb3ciLCJzZXhwcyQwIiwic2V4cHMkMiIsInNleHBzJDEiLCJwYXJzZV9yZWNvcmRfc2xvdyIsInVuc2VlbiIsInBhcnNlX3NwaW5lX2Zhc3QiLCJvdGhlcnMiLCJhcmdzIiwicmVjb3JkX29mX3NleHBzIiwiY29udGV4dCQwIiwiaW5kZXhfb2ZfZmllbGQiLCJhbGxvd19leHRyYV9maWVsZHMiLCJhbGxvd19leHRyYV9maWVsZHMkMCIsIm5hbWVzIiwibmFtZXMkMCIsIm5hbWVzJDEiLCJtYXliZV9jb250ZXh0IiwiY29udGV4dCIsInJlY29yZF9vZl9zZXhwIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvc2V4cGxpYjAvc2V4cGxpYjBfXy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3NleHBsaWIwL3NleHAubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9zZXhwbGliMC9zZXhwX2dyYW1tYXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfZ3JhbW1hci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3NleHBsaWIwL3NleHBfY29udi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3NleHBsaWIwL3NleHBfY29udl9lcnJvci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3NleHBsaWIwL3NleHBfY29udl9sYWJlbGVkX3R1cGxlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvc2V4cGxpYjAvc2V4cF9jb252X3JlY29yZC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztHQTBCb0I7O0lBQUE7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDWGhCQSxVQUFVQyxHQUFJLE9BQUpBLEVBQUs7WUFDZkMsVUFBVUQsR0FBSSxPQUFKQSxFQUFLO1lBV2ZFLFFBQVFDLEtBQUVDO0lBQ1osR0FEVUQsUUFBRUMsS0FFUDthQUZLRDtTQUtERSxNQUxDRjtjQUFFQyxRQU1LO1NBREFFLE1BTExGO0tBS1UsT0FBQSxvQ0FBYkMsS0FBUUM7O1FBR1JDLE1BUkNKO2FBQUVDLFFBT0s7UUFoQklJLE1BU1RKLFFBVE9LLElBaUJWRixLQWpCWUcsSUFBQUY7SUFDckI7VUFEbUJDLFVBQUVDO1VBQUFBLEdBSVY7S0FFQyxJQU5TQyxLQUFBRCxNQUtWRSxJQUxVRixNQUFGRyxLQUFBSixNQUtqQkssSUFMaUJMLE1BTWJNLE1BR0piLFFBSkFZLEdBQVNGO0tBRVQsU0FESUcsS0FDYSxPQURiQTtTQU5hTixJQUFBSSxJQUFFSCxJQUFBQzs7R0FpQmtCO1lBR2pDSyxNQUFNUCxHQUFFQztJQUNkLFVBRFlELE1BQUVDOzs7O2NBQUZEO1VBSUxOLE1BSktNO2VBQUVDO1dBSUNOLE1BSkRNO09BSU0sT0FBQSxtQ0FBYlAsS0FBUUM7Ozs7VUFFUkMsTUFOS0k7ZUFBRUM7V0FNQ0osTUFOREk7T0FNTSxPQUFBLGtDQU5kTSxPQU1D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OztZQUdDOEIsUUFIRDlCO1FBR1UsT0FBQTsrQ0F5TW5CZCxRQXpNVTRDLE9BME1WSjs7WUF6TVFLLFVBSkMvQjtRQUlRLE9BQUE7K0NBd01qQmQsUUF4TVE2QyxTQXlNUkw7O1FBdk1HO1NBRFFNLFVBTEZoQzt3QkFNaUI1TCxNQUFRLGNBQVJBLE1BQWtCO1NBQXpDLE1BQUEsdUNBRFE0TjtRQUNSLE9BQUE7aUJBQ0cseUNBcU1OOUMsUUFDQXdDOzs7UUFwTWlCO1NBRExPLGdCQVJIakM7U0FTRmtDLFVBQVUsNkJBRExELGVBcU1aUDtRQW5NRyxPQUFBLHlDQWtNSHhDLFFBbk1PZ0Q7OztJQWlORyxPQUFBLFdBVFY5QyxRQVNDaEs7R0FDMkU7WUFHM0UrTTtJQUFnQmpELFFBQVE3SyxRQUFRc04sZ0JBQWdCQyxvQkFBb0J4QyxRQUFPdE07SUFDN0UsU0FENkVBO0tBRXRELE9BQUEseUNBRkxvTSxRQUEyRHBNO1FBR3RFaU8sUUFIc0VqTztJQUkzRSxPQXZCQTJPO2FBbUJnQnZDO2FBQTJEcE07YUFBbkR1QjthQUFRc047YUFBZ0JDO2FBQW9CeEM7YUFHL0QyQjtHQVFFOzs7cUJBWFBvQixnQkFuQkFWOzs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIFNleHBsaWIwLlNleHAgKilcbm1vZHVsZSBTZXhwID0gU2V4cGxpYjBfX1NleHBcblxuKCoqIEBjYW5vbmljYWwgU2V4cGxpYjAuU2V4cF9jb252ICopXG5tb2R1bGUgU2V4cF9jb252ID0gU2V4cGxpYjBfX1NleHBfY29udlxuXG4oKiogQGNhbm9uaWNhbCBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IgKilcbm1vZHVsZSBTZXhwX2NvbnZfZXJyb3IgPSBTZXhwbGliMF9fU2V4cF9jb252X2Vycm9yXG5cbigqKiBAY2Fub25pY2FsIFNleHBsaWIwLlNleHBfY29udl9ncmFtbWFyICopXG5tb2R1bGUgU2V4cF9jb252X2dyYW1tYXIgPSBTZXhwbGliMF9fU2V4cF9jb252X2dyYW1tYXJcblxuKCoqIEBjYW5vbmljYWwgU2V4cGxpYjAuU2V4cF9jb252X2xhYmVsZWRfdHVwbGUgKilcbm1vZHVsZSBTZXhwX2NvbnZfbGFiZWxlZF90dXBsZSA9IFNleHBsaWIwX19TZXhwX2NvbnZfbGFiZWxlZF90dXBsZVxuXG4oKiogQGNhbm9uaWNhbCBTZXhwbGliMC5TZXhwX2NvbnZfcmVjb3JkICopXG5tb2R1bGUgU2V4cF9jb252X3JlY29yZCA9IFNleHBsaWIwX19TZXhwX2NvbnZfcmVjb3JkXG5cbigqKiBAY2Fub25pY2FsIFNleHBsaWIwLlNleHBfZ3JhbW1hciAqKVxubW9kdWxlIFNleHBfZ3JhbW1hciA9IFNleHBsaWIwX19TZXhwX2dyYW1tYXJcblxuKCoqIEBjYW5vbmljYWwgU2V4cGxpYjAuU2V4cGFibGUgKilcbm1vZHVsZSBTZXhwYWJsZSA9IFNleHBsaWIwX19TZXhwYWJsZVxuXG5tb2R1bGUgU2V4cGxpYjBfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwiW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG4oKiBibGl0X3N0cmluZyBkb2Vzbid0IGV4aXN0IGluIFtTdGRMYWJlbHMuQnl0ZXNdLi4uICAqKVxubGV0IGJ5dGVzX2JsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuID1cbiAgQnl0ZXMuYmxpdF9zdHJpbmcgc3JjIHNyY19wb3MgZHN0IGRzdF9wb3MgbGVuXG47O1xuXG5vcGVuIFN0ZExhYmVsc1xub3BlbiBGb3JtYXRcblxuKCoqIFR5cGUgb2YgUy1leHByZXNzaW9ucyAqKVxudHlwZSB0ID1cbiAgfCBBdG9tIG9mIHN0cmluZ1xuICB8IExpc3Qgb2YgdCBsaXN0XG5cbmxldCBzZXhwX29mX3QgdCA9IHRcbmxldCB0X29mX3NleHAgdCA9IHRcblxubGV0IHJlYyBjb21wYXJlX2xpc3QgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgbGV0IHJlcyA9IGNvbXBhcmUgeCB5IGluXG4gICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBjb21wYXJlX2xpc3QgeHMgeXNcblxuYW5kIGNvbXBhcmUgYSBiID1cbiAgaWYgYSA9PSBiXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IEF0b20gYSwgQXRvbSBiIC0+IFN0cmluZy5jb21wYXJlIGEgYlxuICAgIHwgQXRvbSBfLCBfIC0+IC0xXG4gICAgfCBfLCBBdG9tIF8gLT4gMVxuICAgIHwgTGlzdCBhLCBMaXN0IGIgLT4gY29tcGFyZV9saXN0IGEgYilcbjs7XG5cbmxldCByZWMgZXF1YWwgYSBiID1cbiAgYSA9PSBiXG4gIHx8XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IEF0b20gYSwgQXRvbSBiIC0+IFN0cmluZy5lcXVhbCBhIGJcbiAgfCBBdG9tIF8sIF8gfCBfLCBBdG9tIF8gLT4gZmFsc2VcbiAgfCBMaXN0IGEsIExpc3QgYiAtPiBMaXN0LmVxdWFsIH5lcTplcXVhbCBhIGJcbjs7XG5cbmV4Y2VwdGlvbiBOb3RfZm91bmRfcyBvZiB0XG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciBvZiBleG4gKiB0XG5cbm1vZHVsZSBQcmludGluZyA9IHN0cnVjdFxuICAoKiBEZWZhdWx0IGluZGVudGF0aW9uIGxldmVsIGZvciBodW1hbi1yZWFkYWJsZSBjb252ZXJzaW9ucyAqKVxuXG4gIGxldCBkZWZhdWx0X2luZGVudCA9IHJlZiAxXG5cbiAgKCogRXNjYXBpbmcgb2Ygc3RyaW5ncyB1c2VkIGFzIGF0b21zIGluIFMtZXhwcmVzc2lvbnMgKilcblxuICBsZXQgbXVzdF9lc2NhcGUgc3RyID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZW4gPSAwXG4gICAgfHxcbiAgICBsZXQgcmVjIGxvb3Agc3RyIGl4ID1cbiAgICAgIG1hdGNoIHN0ci5baXhdIHdpdGhcbiAgICAgIHwgJ1wiJyB8ICcoJyB8ICcpJyB8ICc7JyB8ICdcXFxcJyAtPiB0cnVlXG4gICAgICB8ICd8JyAtPlxuICAgICAgICBpeCA+IDBcbiAgICAgICAgJiZcbiAgICAgICAgbGV0IG5leHQgPSBpeCAtIDEgaW5cbiAgICAgICAgQ2hhci5lcXVhbCBzdHIuW25leHRdICcjJyB8fCBsb29wIHN0ciBuZXh0XG4gICAgICB8ICcjJyAtPlxuICAgICAgICBpeCA+IDBcbiAgICAgICAgJiZcbiAgICAgICAgbGV0IG5leHQgPSBpeCAtIDEgaW5cbiAgICAgICAgQ2hhci5lcXVhbCBzdHIuW25leHRdICd8JyB8fCBsb29wIHN0ciBuZXh0XG4gICAgICB8ICdcXDAwMCcgLi4gJ1xcMDMyJyB8ICdcXDEyNycgLi4gJ1xcMjU1JyAtPiB0cnVlXG4gICAgICB8IF8gLT4gaXggPiAwICYmIGxvb3Agc3RyIChpeCAtIDEpXG4gICAgaW5cbiAgICBsb29wIHN0ciAobGVuIC0gMSlcbiAgOztcblxuICBsZXQgZXNjYXBlZCBzID1cbiAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgIG5cbiAgICAgICAgOj0gIW5cbiAgICAgICAgICAgK1xuICAgICAgICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICAgICAgfCBfIC0+IDRcbiAgICBkb25lO1xuICAgIGlmICFuID0gU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiBzXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcycgPSBCeXRlcy5jcmVhdGUgIW4gaW5cbiAgICAgIG4gOj0gMDtcbiAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIChtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICAgfCAoJ1xcXCInIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgICAgfCAnXFxuJyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICd0J1xuICAgICAgICAgfCAnXFxyJyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdyJ1xuICAgICAgICAgfCAnXFxiJyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgICAgfCAnICcgLi4gJ34nIGFzIGMgLT4gQnl0ZXMudW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICAgICB8IGMgLT5cbiAgICAgICAgICAgbGV0IGEgPSBDaGFyLmNvZGUgYyBpblxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIChDaGFyLmNociAoNDggKyAoYSAvIDEwMCkpKTtcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIChDaGFyLmNociAoNDggKyAoYSAvIDEwIG1vZCAxMCkpKTtcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIChDaGFyLmNociAoNDggKyAoYSBtb2QgMTApKSkpO1xuICAgICAgICBpbmNyIG5cbiAgICAgIGRvbmU7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMnKVxuICA7O1xuXG4gIGxldCBlc2Nfc3RyIHN0ciA9XG4gICAgbGV0IGVzdHIgPSBlc2NhcGVkIHN0ciBpblxuICAgIGxldCBlbGVuID0gU3RyaW5nLmxlbmd0aCBlc3RyIGluXG4gICAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSAoZWxlbiArIDIpIGluXG4gICAgYnl0ZXNfYmxpdF9zdHJpbmcgfnNyYzplc3RyIH5zcmNfcG9zOjAgfmRzdDpyZXMgfmRzdF9wb3M6MSB+bGVuOmVsZW47XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXMgMCAnXCInO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzIChlbGVuICsgMSkgJ1wiJztcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICA7O1xuXG4gIGxldCBpbmRleF9vZl9uZXdsaW5lIHN0ciBzdGFydCA9IFN0cmluZy5pbmRleF9mcm9tX29wdCBzdHIgc3RhcnQgJ1xcbidcblxuICBsZXQgZ2V0X3N1YnN0cmluZyBzdHIgaW5kZXggZW5kX3Bvc19vcHQgPVxuICAgIGxldCBlbmRfcG9zID1cbiAgICAgIG1hdGNoIGVuZF9wb3Nfb3B0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHN0clxuICAgICAgfCBTb21lIGVuZF9wb3MgLT4gZW5kX3Bvc1xuICAgIGluXG4gICAgU3RyaW5nLnN1YiBzdHIgfnBvczppbmRleCB+bGVuOihlbmRfcG9zIC0gaW5kZXgpXG4gIDs7XG5cbiAgbGV0IGlzX29uZV9saW5lIHN0ciA9XG4gICAgbWF0Y2ggaW5kZXhfb2ZfbmV3bGluZSBzdHIgMCB3aXRoXG4gICAgfCBOb25lIC0+IHRydWVcbiAgICB8IFNvbWUgaW5kZXggLT4gaW5kZXggKyAxID0gU3RyaW5nLmxlbmd0aCBzdHJcbiAgOztcblxuICBsZXQgcHBfaHVtX21heWJlX2VzY19zdHIgcHBmIHN0ciA9XG4gICAgaWYgbm90IChtdXN0X2VzY2FwZSBzdHIpXG4gICAgdGhlbiBwcF9wcmludF9zdHJpbmcgcHBmIHN0clxuICAgIGVsc2UgaWYgaXNfb25lX2xpbmUgc3RyXG4gICAgdGhlbiBwcF9wcmludF9zdHJpbmcgcHBmIChlc2Nfc3RyIHN0cilcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCBpbmRleCA9XG4gICAgICAgIGxldCBuZXh0X25ld2xpbmUgPSBpbmRleF9vZl9uZXdsaW5lIHN0ciBpbmRleCBpblxuICAgICAgICBsZXQgbmV4dF9saW5lID0gZ2V0X3N1YnN0cmluZyBzdHIgaW5kZXggbmV4dF9uZXdsaW5lIGluXG4gICAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKGVzY2FwZWQgbmV4dF9saW5lKTtcbiAgICAgICAgbWF0Y2ggbmV4dF9uZXdsaW5lIHdpdGhcbiAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgIHwgU29tZSBuZXdsaW5lX2luZGV4IC0+XG4gICAgICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIlxcXFxcIjtcbiAgICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKTtcbiAgICAgICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiXFxcXG5cIjtcbiAgICAgICAgICBsb29wIChuZXdsaW5lX2luZGV4ICsgMSlcbiAgICAgIGluXG4gICAgICBwcF9vcGVuX2JveCBwcGYgMDtcbiAgICAgICgqIHRoZSBsZWFkaW5nIHNwYWNlIGlzIHRvIGxpbmUgdXAgdGhlIGxpbmVzICopXG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiIFxcXCJcIjtcbiAgICAgIGxvb3AgMDtcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCJcXFwiXCI7XG4gICAgICBwcF9jbG9zZV9ib3ggcHBmICgpKVxuICA7O1xuXG4gIGxldCBtYWNoX21heWJlX2VzY19zdHIgc3RyID0gaWYgbXVzdF9lc2NhcGUgc3RyIHRoZW4gZXNjX3N0ciBzdHIgZWxzZSBzdHJcblxuICAoKiBPdXRwdXQgb2YgUy1leHByZXNzaW9ucyB0byBmb3JtYXR0ZXJzICopXG5cbiAgbGV0IHJlYyBwcF9odW1faW5kZW50IGluZGVudCBwcGYgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT4gcHBfaHVtX21heWJlX2VzY19zdHIgcHBmIHN0clxuICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgcHBfb3Blbl9ib3ggcHBmIGluZGVudDtcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIoXCI7XG4gICAgICBwcF9odW1faW5kZW50IGluZGVudCBwcGYgaDtcbiAgICAgIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgdFxuICAgIHwgTGlzdCBbXSAtPiBwcF9wcmludF9zdHJpbmcgcHBmIFwiKClcIlxuXG4gIGFuZCBwcF9odW1fcmVzdCBpbmRlbnQgcHBmID0gZnVuY3Rpb25cbiAgICB8IGggOjogdCAtPlxuICAgICAgcHBfcHJpbnRfc3BhY2UgcHBmICgpO1xuICAgICAgcHBfaHVtX2luZGVudCBpbmRlbnQgcHBmIGg7XG4gICAgICBwcF9odW1fcmVzdCBpbmRlbnQgcHBmIHRcbiAgICB8IFtdIC0+XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKVwiO1xuICAgICAgcHBfY2xvc2VfYm94IHBwZiAoKVxuICA7O1xuXG4gIGxldCByZWMgcHBfbWFjaF9pbnRlcm5hbCBtYXlfbmVlZF9zcGFjZSBwcGYgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgIGxldCBzdHInID0gbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciBpblxuICAgICAgbGV0IG5ld19tYXlfbmVlZF9zcGFjZSA9IHN0cicgPT0gc3RyIGluXG4gICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBwcF9wcmludF9zdHJpbmcgcHBmIFwiIFwiO1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBzdHInO1xuICAgICAgbmV3X21heV9uZWVkX3NwYWNlXG4gICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKFwiO1xuICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gcHBfbWFjaF9pbnRlcm5hbCBmYWxzZSBwcGYgaCBpblxuICAgICAgcHBfbWFjaF9yZXN0IG1heV9uZWVkX3NwYWNlIHBwZiB0O1xuICAgICAgZmFsc2VcbiAgICB8IExpc3QgW10gLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIoKVwiO1xuICAgICAgZmFsc2VcblxuICBhbmQgcHBfbWFjaF9yZXN0IG1heV9uZWVkX3NwYWNlIHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBoIDo6IHQgLT5cbiAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IHBwX21hY2hfaW50ZXJuYWwgbWF5X25lZWRfc3BhY2UgcHBmIGggaW5cbiAgICAgIHBwX21hY2hfcmVzdCBtYXlfbmVlZF9zcGFjZSBwcGYgdFxuICAgIHwgW10gLT4gcHBfcHJpbnRfc3RyaW5nIHBwZiBcIilcIlxuICA7O1xuXG4gIGxldCBwcF9odW0gcHBmIHNleHAgPSBwcF9odW1faW5kZW50ICFkZWZhdWx0X2luZGVudCBwcGYgc2V4cFxuICBsZXQgcHBfbWFjaCBwcGYgc2V4cCA9IGlnbm9yZSAocHBfbWFjaF9pbnRlcm5hbCBmYWxzZSBwcGYgc2V4cClcbiAgbGV0IHBwID0gcHBfbWFjaFxuXG4gICgqIFNleHAgc2l6ZSAqKVxuXG4gIGxldCByZWMgc2l6ZV9sb29wICgodiwgYykgYXMgYWNjKSA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPiB2ICsgMSwgYyArIFN0cmluZy5sZW5ndGggc3RyXG4gICAgfCBMaXN0IGxzdCAtPiBMaXN0LmZvbGRfbGVmdCBsc3QgfmluaXQ6YWNjIH5mOnNpemVfbG9vcFxuICA7O1xuXG4gIGxldCBzaXplIHNleHAgPSBzaXplX2xvb3AgKDAsIDApIHNleHBcblxuICAoKiBCdWZmZXIgY29udmVyc2lvbnMgKilcblxuICBsZXQgdG9fYnVmZmVyX2h1bSB+YnVmID8oaW5kZW50ID0gIWRlZmF1bHRfaW5kZW50KSBzZXhwID1cbiAgICBsZXQgcHBmID0gRm9ybWF0LmZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gICAgRm9ybWF0LmZwcmludGYgcHBmIFwiJWFAP1wiIChwcF9odW1faW5kZW50IGluZGVudCkgc2V4cFxuICA7O1xuXG4gIGxldCB0b19idWZmZXJfbWFjaCB+YnVmIHNleHAgPVxuICAgIGxldCByZWMgbG9vcCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IEF0b20gc3RyIC0+XG4gICAgICAgIGxldCBzdHInID0gbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciBpblxuICAgICAgICBsZXQgbmV3X21heV9uZWVkX3NwYWNlID0gc3RyJyA9PSBzdHIgaW5cbiAgICAgICAgaWYgbWF5X25lZWRfc3BhY2UgJiYgbmV3X21heV9uZWVkX3NwYWNlIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnICc7XG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBzdHInO1xuICAgICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICcoJztcbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBmYWxzZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0O1xuICAgICAgICBmYWxzZVxuICAgICAgfCBMaXN0IFtdIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIigpXCI7XG4gICAgICAgIGZhbHNlXG4gICAgYW5kIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IGggOjogdCAtPlxuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIG1heV9uZWVkX3NwYWNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHRcbiAgICAgIHwgW10gLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnKSdcbiAgICBpblxuICAgIGlnbm9yZSAobG9vcCBmYWxzZSBzZXhwKVxuICA7O1xuXG4gIGxldCB0b19idWZmZXIgPSB0b19idWZmZXJfbWFjaFxuXG4gIGxldCB0b19idWZmZXJfZ2VuIH5idWYgfmFkZF9jaGFyIH5hZGRfc3RyaW5nIHNleHAgPVxuICAgIGxldCByZWMgbG9vcCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IEF0b20gc3RyIC0+XG4gICAgICAgIGxldCBzdHInID0gbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciBpblxuICAgICAgICBsZXQgbmV3X21heV9uZWVkX3NwYWNlID0gc3RyJyA9PSBzdHIgaW5cbiAgICAgICAgaWYgbWF5X25lZWRfc3BhY2UgJiYgbmV3X21heV9uZWVkX3NwYWNlIHRoZW4gYWRkX2NoYXIgYnVmICcgJztcbiAgICAgICAgYWRkX3N0cmluZyBidWYgc3RyJztcbiAgICAgICAgbmV3X21heV9uZWVkX3NwYWNlXG4gICAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgICAgYWRkX2NoYXIgYnVmICcoJztcbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBmYWxzZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0O1xuICAgICAgICBmYWxzZVxuICAgICAgfCBMaXN0IFtdIC0+XG4gICAgICAgIGFkZF9zdHJpbmcgYnVmIFwiKClcIjtcbiAgICAgICAgZmFsc2VcbiAgICBhbmQgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgbWF5X25lZWRfc3BhY2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdFxuICAgICAgfCBbXSAtPiBhZGRfY2hhciBidWYgJyknXG4gICAgaW5cbiAgICBpZ25vcmUgKGxvb3AgZmFsc2Ugc2V4cClcbiAgOztcblxuICAoKiBUaGUgbWF4aW11bSBzaXplIG9mIGEgdGhpbmcgb24gdGhlIG1pbm9yIGhlYXAgaXMgMjU2IHdvcmRzLlxuICAgICBQcmV2aW91c2x5LCB0aGlzIHNpemUgb2YgdGhlIHJldHVybmVkIGJ1ZmZlciBoZXJlIHdhcyA0MDk2IGJ5dGVzLCB3aGljaFxuICAgICBjYXVzZWQgdGhlIEJ1ZmZlciB0byBiZSBhbGxvY2F0ZWQgb24gdGhlICptYWpvciogaGVhcCBldmVyeSB0aW1lLlxuXG4gICAgIEFjY29yZGluZyB0byBhIHNpbXBsZSBiZW5jaG1hcmsgYnkgUm9uLCB3ZSBjYW4gaW1wcm92ZSBwZXJmb3JtYW5jZSBmb3JcbiAgICAgc21hbGwgcy1leHByZXNzaW9ucyBieSBhIGZhY3RvciBvZiB+NCBpZiB3ZSBvbmx5IGFsbG9jYXRlIDEwMjQgYnl0ZXNcbiAgICAgKDEyOCB3b3JkcyArIHNvbWUgc21hbGwgb3ZlcmhlYWQpIHdvcnRoIG9mIGJ1ZmZlciBpbml0aWFsbHkuICBBbmQgb25lXG4gICAgIGNhbiBhcmd1ZSB0aGF0IGlmIGl0J3MgZnJlZSB0byBhbGxvY2F0ZSBzdHJpbmdzIHNtYWxsZXIgdGhhbiAyNTYgd29yZHMsXG4gICAgIGxhcmdlIHMtZXhwcmVzc2lvbnMgcmVxdWlyaW5nIGxhcmdlciBleHBlbnNpdmUgYnVmZmVycyB3b24ndCBub3RpY2VcbiAgICAgdGhlIGV4dHJhIHR3byBkb3VibGluZ3MgZnJvbSAxMDI0IGJ5dGVzIHRvIDIwNDggYW5kIDQwOTYuIEFuZCBlc3BlY2lhbGx5XG4gICAgIHBlcmZvcm1hbmNlLXNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgdG8gYWx3YXlzIHBhc3MgaW4gYSBsYXJnZXIgYnVmZmVyIHRvXG4gICAgIHVzZS4gKilcbiAgbGV0IGJ1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgMTAyNFxuXG4gICgqIFN0cmluZyBjb252ZXJzaW9ucyAqKVxuXG4gIGxldCB0b19zdHJpbmdfaHVtID9pbmRlbnQgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHJcbiAgICAgIHdoZW4gbWF0Y2ggaW5kZXhfb2ZfbmV3bGluZSBzdHIgMCB3aXRoXG4gICAgICAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICAgICAgIHwgU29tZSBfIC0+IGZhbHNlIC0+IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHJcbiAgICB8IHNleHAgLT5cbiAgICAgIGxldCBidWYgPSBidWZmZXIgKCkgaW5cbiAgICAgIHRvX2J1ZmZlcl9odW0gP2luZGVudCBzZXhwIH5idWY7XG4gICAgICBCdWZmZXIuY29udGVudHMgYnVmXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZ19tYWNoID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHJcbiAgICB8IHNleHAgLT5cbiAgICAgIGxldCBidWYgPSBidWZmZXIgKCkgaW5cbiAgICAgIHRvX2J1ZmZlcl9tYWNoIHNleHAgfmJ1ZjtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nX21hY2hcbmVuZFxuXG5pbmNsdWRlIFByaW50aW5nXG5cbmxldCBvZl9mbG9hdF9zdHlsZSA6IFsgYFVuZGVyc2NvcmVzIHwgYE5vX3VuZGVyc2NvcmVzIF0gcmVmID0gcmVmIGBOb191bmRlcnNjb3Jlc1xubGV0IG9mX2ludF9zdHlsZSA6IFsgYFVuZGVyc2NvcmVzIHwgYE5vX3VuZGVyc2NvcmVzIF0gcmVmID0gcmVmIGBOb191bmRlcnNjb3Jlc1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBpbmNsdWRlIFByaW50aW5nXG5lbmRcblxubGV0IG1lc3NhZ2UgbmFtZSBmaWVsZHMgPVxuICBsZXQgcmVjIGNvbnZfZmllbGRzID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFtdXG4gICAgfCAoZm5hbWUsIGZzZXhwKSA6OiByZXN0IC0+XG4gICAgICAobWF0Y2ggZm5hbWUgd2l0aFxuICAgICAgIHwgXCJcIiAtPiBmc2V4cCA6OiBjb252X2ZpZWxkcyByZXN0XG4gICAgICAgfCBfIC0+IExpc3QgWyBBdG9tIGZuYW1lOyBmc2V4cCBdIDo6IGNvbnZfZmllbGRzIHJlc3QpXG4gIGluXG4gIExpc3QgKEF0b20gbmFtZSA6OiBjb252X2ZpZWxkcyBmaWVsZHMpXG47O1xuIiwiKCoqIFJlcHJlc2VudGF0aW9uIG9mIFMtZXhwcmVzc2lvbiBncmFtbWFycyAqKVxuXG4oKiogVGhpcyBtb2R1bGUgZGVmaW5lcyBhIHJlcHJlc2VudGF0aW9uIGZvciBzLWV4cHJlc3Npb24gZ3JhbW1hcnMuIFVzaW5nIHBweF9zZXhwX2NvbnZcbiAgICBhbmQgW1tAQGRlcml2aW5nIHNleHBfZ3JhbW1hcl1dIHByb2R1Y2VzIGEgZ3JhbW1hciB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgZGVyaXZlZFxuICAgIFtvZl9zZXhwXSBmb3IgYSBnaXZlbiB0eXBlLlxuXG4gICAgQXMgd2l0aCBvdGhlciBkZXJpdmVkIGRlZmluaXRpb25zLCBwb2x5bW9ycGhpYyB0eXBlcyBkZXJpdmUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFcbiAgICBncmFtbWFyIGZvciBlYWNoIHR5cGUgYXJndW1lbnQgYW5kIHByb2R1Y2VzIGEgZ3JhbW1hciBmb3IgdGhlIG1vbm9tb3JwaGl6ZWQgdHlwZS5cblxuICAgIE1vbm9tb3JwaGljIHR5cGVzIGRlcml2ZSBhIGdyYW1tYXIgZGlyZWN0bHkuIFRvIGF2b2lkIHRvcC1sZXZlbCBzaWRlIGVmZmVjdHMsXG4gICAgW1tAQGRlcml2aW5nIHNleHBfZ3JhbW1hcl1dIHdyYXBzIGdyYW1tYXJzIGluIHRoZSBbTGF6eV0gY29uc3RydWN0b3IgYXMgbmVlZGVkLlxuXG4gICAgVGhpcyB0eXBlIG1heSBjaGFuZ2Ugb3ZlciB0aW1lIGFzIG91ciBuZWVkcyBmb3IgZXhwcmVzc2l2ZSBncmFtbWFycyBjaGFuZ2UuIFdlIHdpbGxcbiAgICBhdHRlbXB0IHRvIG1ha2UgY2hhbmdlcyBiYWNrd2FyZC1jb21wYXRpYmxlLCBvciBhdCBsZWFzdCBwcm92aWRlIGEgcmVhc29uYWJsZSB1cGdyYWRlXG4gICAgcGF0aC4gKilcblxuW0BAQHdhcm5pbmcgXCItMzBcIl0gKCogYWxsb3cgZHVwbGljYXRlIGZpZWxkIG5hbWVzICopXG5cbigqKiBHcmFtbWFyIG9mIGEgc2V4cC4gKilcbnR5cGUgZ3JhbW1hciA9XG4gIHwgQW55IG9mIHN0cmluZyAoKiogYWNjZXB0cyBhbnkgc2V4cDsgc3RyaW5nIGlzIGEgdHlwZSBuYW1lIGZvciBodW1hbiByZWFkYWJpbGl0eSAqKVxuICB8IEJvb2wgKCoqIGFjY2VwdHMgdGhlIGF0b21zIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIiwgbW9kdWxvIGNhcGl0YWxpemF0aW9uICopXG4gIHwgQ2hhciAoKiogYWNjZXB0cyBhbnkgc2luZ2xlLWNoYXJhY3RlciBhdG9tICopXG4gIHwgSW50ZWdlciAoKiogYWNjZXB0cyBhbnkgYXRvbSBtYXRjaGluZyBvY2FtbCBpbnRlZ2VyIHN5bnRheCwgcmVnYXJkbGVzcyBvZiBiaXQgd2lkdGggKilcbiAgfCBGbG9hdCAoKiogYWNjZXB0cyBhbnkgYXRvbSBtYXRjaGluZyBvY2FtbCBmbG9hdCBzeW50YXggKilcbiAgfCBTdHJpbmcgKCoqIGFjY2VwdHMgYW55IGF0b20gKilcbiAgfCBPcHRpb24gb2YgZ3JhbW1hciAoKiogYWNjZXB0cyBhbiBvcHRpb24sIGJvdGggW05vbmVdIHZzIFtTb21lIF9dIGFuZCBbKCldIHZzIFsoXyldLiAqKVxuICB8IExpc3Qgb2YgbGlzdF9ncmFtbWFyICgqKiBhY2NlcHRzIGEgbGlzdCAqKVxuICB8IFZhcmlhbnQgb2YgdmFyaWFudCAoKiogYWNjZXB0cyBjbGF1c2VzIGtleWVkIGJ5IGEgbGVhZGluZyBvciBzb2xlIGF0b20gKilcbiAgfCBVbmlvbiBvZiBncmFtbWFyIGxpc3QgKCoqIGFjY2VwdHMgYSBzZXhwIGlmIGFueSBvZiB0aGUgbGlzdGVkIGdyYW1tYXJzIGFjY2VwdHMgaXQgKilcbiAgfCBUYWdnZWQgb2YgZ3JhbW1hciB3aXRoX3RhZ1xuICAgICAgKCoqIGFubm90YXRlcyBhIGdyYW1tYXIgd2l0aCBhIGNsaWVudC1zcGVjaWZpYyBrZXkvdmFsdWUgcGFpciAqKVxuICB8IFR5dmFyIG9mIHN0cmluZ1xuICAgICAgKCoqIE5hbWUgb2YgYSB0eXBlIHZhcmlhYmxlLCBlLmcuIFtUeXZhciBcImFcIl0gZm9yIFsnYV0uIE9ubHkgbWVhbmluZ2Z1bCB3aGVuIHRoZSBib2R5IG9mXG4gICAgICB0aGUgaW5uZXJtb3N0IGVuY2xvc2luZyBbZGVmbl0gZGVmaW5lcyBhIGNvcnJlc3BvbmRpbmcgdHlwZSB2YXJpYWJsZS4gKilcbiAgfCBUeWNvbiBvZiBzdHJpbmcgKiBncmFtbWFyIGxpc3QgKiBkZWZuIGxpc3RcbiAgICAgICgqKiBUeXBlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdG8gYXJndW1lbnRzLCBhbmQgaXRzIGRlZmluaXRpb24uXG5cbiAgICAgIEZvciBleGFtcGxlLCB3cml0aW5nIFtUeWNvbiAoXCJ0cmVlXCIsIFsgSW50ZWdlciBdLCBkZWZucyldIHJlcHJlc2VudHMgW2ludCB0cmVlXSwgZm9yXG4gICAgICB3aGF0ZXZlciBbdHJlZV0gaXMgZGVmaW5lZCBhcyBpbiBbZGVmbnNdLiBUaGUgZm9sbG93aW5nIGRlZmluZXMgW3RyZWVdIGFzIGEgYmluYXJ5XG4gICAgICB0cmVlIHdpdGggdGhlIHBhcmFtZXRlciB0eXBlIHN0b3JlZCBhdCB0aGUgbGVhdmVzLlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgZGVmbnMgPVxuICAgICAgICAgIFsgeyB0eWNvbiA9IFwidHJlZVwiXG4gICAgICAgICAgICA7IHR5dmFycyA9IFtcImFcIl1cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9XG4gICAgICAgICAgICAgICAgVmFyaWFudFxuICAgICAgICAgICAgICAgICAgeyBuYW1lX2tpbmQgPSBDYXBpdGFsaXplZFxuICAgICAgICAgICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgICAgICAgICBbIHsgbmFtZSA9IFwiTm9kZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChSZWN1cnNpdmUgKFwibm9kZVwiLCBbVHl2YXIgXCJhXCJdKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgOyB7IG5hbWUgPSBcIkxlYWZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOyBhcmdzID0gQ29ucyAoUmVjdXJzaXZlIChcImxlYWZcIiwgW1R5dmFyIFwiYVwiXSksIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA7IHsgdHljb24gPSBcIm5vZGVcIlxuICAgICAgICAgICAgOyB0eXZhcnMgPSBbXCJhXCJdXG4gICAgICAgICAgICA7IGdyYW1tYXIgPSBMaXN0IChNYW55IChSZWN1cnNpdmUgXCJ0cmVlXCIsIFtUeXZhciBcImFcIl0pKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDsgeyB0eWNvbiA9IFwibGVhZlwiXG4gICAgICAgICAgICA7IHR5dmFycyA9IFtcImFcIl1cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9IFtUeXZhciBcImFcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIDs7XG4gICAgICBdfVxuXG4gICAgICBUbyBpbGx1c3RyYXRlIHRoZSBtZWFuaW5nIG9mIFtUeWNvbl0gd2l0aCByZXNwZWN0IHRvIFtkZWZuc10sIGFuZCB0byBkZW1vbnN0cmF0ZSBvbmVcbiAgICAgIHdheSB0byBhY2Nlc3MgdGhlbSwgaXQgaXMgZXF1aXZhbGVudCB0byBleHBhbmQgdGhlIGRlZmluaXRpb24gb2YgXCJ0cmVlXCIgb25lIGxldmVsXG4gICAgICBhbmQgbW92ZSB0aGUgW2RlZm5zXSB0byBlbmNsb3NlZCByZWN1cnNpdmUgcmVmZXJlbmNlczpcblxuICAgICAge1tcbiAgICAgICAgVHljb24gKFwidHJlZVwiLCBbIEludGVnZXIgXSwgZGVmbnMpXG4gICAgICAgIC0tPlxuICAgICAgICBWYXJpYW50XG4gICAgICAgICAgeyBuYW1lX2tpbmQgPSBDYXBpdGFsaXplZFxuICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgIFsgeyBuYW1lID0gXCJOb2RlXCJcbiAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJub2RlXCIsIFtUeXZhciBcImFcIl0sIGRlZm5zKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA7IHsgbmFtZSA9IFwiTGVhZlwiXG4gICAgICAgICAgICAgICAgOyBhcmdzID0gQ29ucyAoVHljb24gKFwibGVhZlwiLCBbVHl2YXIgXCJhXCJdLCBkZWZucyksIEVtcHR5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgIF19XG5cbiAgICAgIFRoaXMgdHJhbnNmb3JtYXRpb24gZXhwb3NlcyB0aGUgc3RydWN0dXJlIG9mIGEgZ3JhbW1hciB3aXRoIHJlY3Vyc2l2ZSByZWZlcmVuY2VzLFxuICAgICAgd2hpbGUgcHJlc2VydmluZyB0aGUgbWVhbmluZyBvZiByZWN1cnNpdmVseS1kZWZpbmVkIGVsZW1lbnRzLiAqKVxuICB8IFJlY3Vyc2l2ZSBvZiBzdHJpbmcgKiBncmFtbWFyIGxpc3RcbiAgICAgICgqKiBUeXBlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdG8gYXJndW1lbnRzLiBVc2VkIHRvIGRlbm90ZSByZWN1cnNpdmUgdHlwZSByZWZlcmVuY2VzLlxuICAgICAgT25seSBtZWFuaW5nZnVsIHdoZW4gdXNlZCBpbnNpZGUgdGhlIFtkZWZuXXMgb2YgYSBbVHljb25dIGdyYW1tYXIsIHRvIHJlZmVyIHRvIGFcbiAgICAgIHR5cGUgY29uc3RydWN0b3IgaW4gdGhlIG5lYXJlc3QgZW5jbG9zaW5nIFtkZWZuXSBsaXN0LiAqKVxuICB8IExhenkgb2YgZ3JhbW1hciBsYXp5X3RcbiAgICAgICgqKiBMYXppbHkgY29tcHV0ZWQgZ3JhbW1hci4gVXNlIFtMYXp5XSB0byBhdm9pZCB0b3AtbGV2ZWwgc2lkZSBlZmZlY3RzLiBUbyBkZWZpbmVcbiAgICAgIHJlY3Vyc2l2ZSBncmFtbWFycywgdXNlIFtSZWN1cnNpdmVdIGluc3RlYWQuICopXG5cbigqKiBHcmFtbWFyIG9mIGEgbGlzdCBvZiBzZXhwcy4gKilcbmFuZCBsaXN0X2dyYW1tYXIgPVxuICB8IEVtcHR5ICgqKiBhY2NlcHRzIGFuIGVtcHR5IGxpc3Qgb2Ygc2V4cHMgKilcbiAgfCBDb25zIG9mIGdyYW1tYXIgKiBsaXN0X2dyYW1tYXJcbiAgICAgICgqKiBhY2NlcHRzIGEgbm9uLWVtcHR5IGxpc3Qgd2l0aCBoZWFkIGFuZCB0YWlsIG1hdGNoaW5nIHRoZSBnaXZlbiBncmFtbWFycyAqKVxuICB8IE1hbnkgb2YgZ3JhbW1hciAoKiogYWNjZXB0cyB6ZXJvIG9yIG1vcmUgc2V4cHMsIGVhY2ggbWF0Y2hpbmcgdGhlIGdpdmVuIGdyYW1tYXIgKilcbiAgfCBGaWVsZHMgb2YgcmVjb3JkICgqKiBhY2NlcHRzIHNleHBzIHJlcHJlc2VudGluZyBmaWVsZHMgb2YgYSByZWNvcmQgKilcblxuKCoqIENhc2Ugc2Vuc2l0aXZpdHkgb3B0aW9ucyBmb3IgbmFtZXMgb2YgdmFyaWFudCBjb25zdHJ1Y3RvcnMuICopXG5hbmQgY2FzZV9zZW5zaXRpdml0eSA9XG4gIHwgQ2FzZV9pbnNlbnNpdGl2ZSAoKiogQ29tcGFyaXNvbiBpcyBjYXNlIGluc2Vuc2l0aXZlLiBVc2VkIGZvciBjdXN0b20gcGFyc2Vycy4gKilcbiAgfCBDYXNlX3NlbnNpdGl2ZSAoKiogQ29tcGFyaXNvbiBpcyBjYXNlIHNlbnNpdGl2ZS4gVXNlZCBmb3IgcG9seW1vcnBoaWMgdmFyaWFudHMuICopXG4gIHwgQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgKCoqIENvbXBhcmlzb24gaXMgY2FzZSBpbnNlbnNpdGl2ZSBmb3IgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgY2FzZSBzZW5zaXRpdmUgYWZ0ZXJ3YXJkLlxuICAgICAgVXNlZCBmb3IgcmVndWxhciB2YXJpYW50cy4gKilcblxuKCoqIEdyYW1tYXIgb2YgdmFyaWFudHMuIEFjY2VwdHMgYW55IHNleHAgbWF0Y2hpbmcgb25lIG9mIHRoZSBjbGF1c2VzLiAqKVxuYW5kIHZhcmlhbnQgPVxuICB7IGNhc2Vfc2Vuc2l0aXZpdHkgOiBjYXNlX3NlbnNpdGl2aXR5XG4gIDsgY2xhdXNlcyA6IGNsYXVzZSB3aXRoX3RhZ19saXN0IGxpc3RcbiAgfVxuXG4oKiogR3JhbW1hciBvZiBhIHNpbmdsZSB2YXJpYW50IGNsYXVzZS4gQWNjZXB0cyBzZXhwcyBiYXNlZCBvbiB0aGUgW2NsYXVzZV9raW5kXS4gKilcbmFuZCBjbGF1c2UgPVxuICB7IG5hbWUgOiBzdHJpbmdcbiAgOyBjbGF1c2Vfa2luZCA6IGNsYXVzZV9raW5kXG4gIH1cblxuKCoqIEdyYW1tYXIgb2YgYSBzaW5nbGUgdmFyaWFudCBjbGF1c2UncyBjb250ZW50cy4gW0F0b21fY2xhdXNlXSBhY2NlcHRzIGFuIGF0b20gbWF0Y2hpbmdcbiAgICB0aGUgY2xhdXNlJ3MgbmFtZS4gW0xpc3RfY2xhdXNlXSBhY2NlcHRzIGEgbGlzdCB3aG9zZSBoZWFkIGlzIGFuIGF0b20gbWF0Y2hpbmcgdGhlXG4gICAgY2xhdXNlJ3MgbmFtZSBhbmQgd2hvc2UgdGFpbCBtYXRjaGVzIFthcmdzXS4gVGhlIGNsYXVzZSdzIG5hbWUgaXMgbWF0Y2hlZCBtb2R1bG8gdGhlXG4gICAgdmFyaWFudCdzIFtuYW1lX2tpbmRdLiAqKVxuYW5kIGNsYXVzZV9raW5kID1cbiAgfCBBdG9tX2NsYXVzZVxuICB8IExpc3RfY2xhdXNlIG9mIHsgYXJncyA6IGxpc3RfZ3JhbW1hciB9XG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjb3JkLiBBY2NlcHRzIGFueSBsaXN0IG9mIHNleHBzIHNwZWNpZnlpbmcgZWFjaCBvZiB0aGUgZmllbGRzLFxuICAgIHJlZ2FyZGxlc3Mgb2Ygb3JkZXIuIElmIFthbGxvd19leHRyYV9maWVsZHNdIGlzIHNwZWNpZmllZCwgaWdub3JlcyBzZXhwcyB3aXRoIG5hbWVzXG4gICAgbm90IGZvdW5kIGluIFtmaWVsZHNdLiAqKVxuYW5kIHJlY29yZCA9XG4gIHsgYWxsb3dfZXh0cmFfZmllbGRzIDogYm9vbFxuICA7IGZpZWxkcyA6IGZpZWxkIHdpdGhfdGFnX2xpc3QgbGlzdFxuICB9XG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjb3JkIGZpZWxkLiBBIGZpZWxkIG11c3Qgc2hvdyB1cCBleGFjdGx5IG9uY2UgaW4gYSByZWNvcmQgaWZcbiAgICBbcmVxdWlyZWRdLCBvciBhdCBtb3N0IG9uY2Ugb3RoZXJ3aXNlLiBBY2NlcHRzIGEgbGlzdCBoZWFkZWQgYnkgW25hbWVdIGFzIGFuIGF0b20sXG4gICAgZm9sbG93ZWQgYnkgc2V4cHMgbWF0Y2hpbmcgW2FyZ3NdLiAqKVxuYW5kIGZpZWxkID1cbiAgeyBuYW1lIDogc3RyaW5nXG4gIDsgcmVxdWlyZWQgOiBib29sXG4gIDsgYXJncyA6IGxpc3RfZ3JhbW1hclxuICB9XG5cbigqKiBHcmFtbWFyIHRhZ2dlZCB3aXRoIGNsaWVudC1zcGVjaWZpYyBrZXkvdmFsdWUgcGFpci4gKilcbmFuZCAnYSB3aXRoX3RhZyA9XG4gIHsga2V5IDogc3RyaW5nXG4gIDsgdmFsdWUgOiBTZXhwLnRcbiAgOyBncmFtbWFyIDogJ2FcbiAgfVxuXG5hbmQgJ2Egd2l0aF90YWdfbGlzdCA9XG4gIHwgVGFnIG9mICdhIHdpdGhfdGFnX2xpc3Qgd2l0aF90YWdcbiAgfCBOb190YWcgb2YgJ2FcblxuKCoqIEdyYW1tYXIgb2YgYSByZWN1cnNpdmUgdHlwZSBkZWZpbml0aW9uLiBOYW1lcyB0aGUgW3R5Y29uXSBiZWluZyBkZWZpbmVkLCBhbmQgdGhlXG4gICAgW3R5dmFyc10gaXQgdGFrZXMgYXMgcGFyYW1ldGVycy4gU3BlY2lmaWVzIHRoZSBbZ3JhbW1hcl0gb2YgdGhlIFt0eWNvbl0uIFRoZSBncmFtbWFyXG4gICAgbWF5IHJlZmVyIHRvIGFueSBvZiB0aGUgW3R5dmFyc10sIGFuZCB0byBhbnkgb2YgdGhlIFt0eWNvbl1zIGZyb20gdGhlIHNhbWUgc2V0IG9mXG4gICAgW1JlY3Vyc2l2ZV0gZGVmaW5pdGlvbnMuICopXG5hbmQgZGVmbiA9XG4gIHsgdHljb24gOiBzdHJpbmdcbiAgOyB0eXZhcnMgOiBzdHJpbmcgbGlzdFxuICA7IGdyYW1tYXIgOiBncmFtbWFyXG4gIH1cblxuKCoqIFRvcC1sZXZlbCBncmFtbWFyIHR5cGUuIEhhcyBhIHBoYW50b20gdHlwZSBwYXJhbWV0ZXIgdG8gYXNzb2NpYXRlIGVhY2ggZ3JhbW1hciB3aXRoXG4gICAgdGhlIHR5cGUgaXRzIHNleHBzIHJlcHJlc2VudC4gVGhpcyBtYWtlcyBpdCBoYXJkZXIgdG8gYXBwbHkgZ3JhbW1hcnMgdG8gdGhlIHdyb25nXG4gICAgdHlwZSwgd2hpbGUgZ3JhbW1hcnMgY2FuIHN0aWxsIGJlIGVhc2lseSBjb2VyY2VkIHRvIGEgbmV3IHR5cGUgaWYgbmVlZGVkLiAqKVxudHlwZSBfIHQgPSB7IHVudHlwZWQgOiBncmFtbWFyIH0gW0BAdW5ib3hlZF1cblxubGV0IGNvZXJjZSAodHlwZSBhIGIpICh7IHVudHlwZWQgPSBfIH0gYXMgdCA6IGEgdCkgOiBiIHQgPSB0XG5cbmxldCB0YWcgKHR5cGUgYSkgKHsgdW50eXBlZCA9IGdyYW1tYXIgfSA6IGEgdCkgfmtleSB+dmFsdWUgOiBhIHQgPVxuICB7IHVudHlwZWQgPSBUYWdnZWQgeyBrZXk7IHZhbHVlOyBncmFtbWFyIH0gfVxuOztcblxuKCoqIFRoaXMgcmVzZXJ2ZWQga2V5IGlzIHVzZWQgZm9yIGFsbCB0YWdzIGdlbmVyYXRlZCBmcm9tIGRvYyBjb21tZW50cy4gKilcbmxldCBkb2NfY29tbWVudF90YWcgPSBcInNleHBfZ3JhbW1hci5kb2NfY29tbWVudFwiXG5cbigqKiBUaGlzIHJlc2VydmVkIGtleSBjYW4gYmUgdXNlZCB0byBhc3NvY2lhdGUgYSB0eXBlIG5hbWUgd2l0aCBhIGdyYW1tYXIuICopXG5sZXQgdHlwZV9uYW1lX3RhZyA9IFwic2V4cF9ncmFtbWFyLnR5cGVfbmFtZVwiXG5cbigqKiBUaGlzIHJlc2VydmVkIGtleSBpbmRpY2F0ZXMgdGhhdCBhIHNleHAgcmVwcmVzZW50cyBhIGtleS92YWx1ZSBhc3NvY2lhdGlvbi4gVGhlIHRhZydzXG4gICAgdmFsdWUgaXMgaWdub3JlZC4gKilcbmxldCBhc3NvY190YWcgPSBcInNleHBfZ3JhbW1hci5hc3NvY1wiXG5cbigqKiBUaGlzIHJlc2VydmVkIGtleSBpbmRpY2F0ZXMgdGhhdCBhIHNleHAgaXMgYSBrZXkgaW4gYSBrZXkvdmFsdWUgYXNzb2NpYXRpb24uIFRoZSB0YWcnc1xuICAgIHZhbHVlIGlzIGlnbm9yZWQuICopXG5sZXQgYXNzb2Nfa2V5X3RhZyA9IFwic2V4cF9ncmFtbWFyLmFzc29jLmtleVwiXG5cbigqKiBUaGlzIHJlc2VydmVkIGtleSBpbmRpY2F0ZXMgdGhhdCBhIHNleHAgaXMgYSB2YWx1ZSBpbiBhIGtleS92YWx1ZSBhc3NvY2lhdGlvbi4gVGhlXG4gICAgdGFnJ3MgdmFsdWUgaXMgaWdub3JlZC4gKilcbmxldCBhc3NvY192YWx1ZV90YWcgPSBcInNleHBfZ3JhbW1hci5hc3NvYy52YWx1ZVwiXG5cbigqKiBXaGVuIHRoZSBrZXkgaXMgc2V0IHRvIFtBdG9tIFwiZmFsc2VcIl0gZm9yIGEgdmFyaWFudCBjbGF1c2UsIHRoYXQgY2xhdXNlIHNob3VsZCBub3QgYmVcbiAgICBzdWdnZXN0ZWQgaW4gYXV0by1jb21wbGV0aW9uIGJhc2VkIG9uIHRoZSBzZXhwIGdyYW1tYXIuICopXG5sZXQgY29tcGxldGlvbl9zdWdnZXN0ZWQgPSBcInNleHBfZ3JhbW1hci5jb21wbGV0aW9uLXN1Z2dlc3RlZFwiXG4iLCJvcGVuIFN0ZExhYmVsc1xuXG5sZXQgc2V4cF9ncmFtbWFyX3dpdGhfdGFncyBncmFtbWFyIH50YWdzID1cbiAgTGlzdC5mb2xkX3JpZ2h0IHRhZ3MgfmluaXQ6Z3JhbW1hciB+ZjooZnVuIChrZXksIHZhbHVlKSBncmFtbWFyIC0+XG4gICAgU2V4cF9ncmFtbWFyLlRhZ2dlZCB7IGtleTsgdmFsdWU7IGdyYW1tYXIgfSlcbjs7XG5cbmxldCBzZXhwX2dyYW1tYXJfd2l0aF90YWdfbGlzdCB4IH50YWdzID1cbiAgTGlzdC5mb2xkX3JpZ2h0IHRhZ3MgfmluaXQ6eCB+ZjooZnVuIChrZXksIHZhbHVlKSBncmFtbWFyIC0+XG4gICAgU2V4cF9ncmFtbWFyLlRhZyB7IGtleTsgdmFsdWU7IGdyYW1tYXIgfSlcbjs7XG5cbmxldCB1bml0X3NleHBfZ3JhbW1hciA6IHVuaXQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBMaXN0IEVtcHR5IH1cbmxldCBib29sX3NleHBfZ3JhbW1hciA6IGJvb2wgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBCb29sIH1cbmxldCBzdHJpbmdfc2V4cF9ncmFtbWFyIDogc3RyaW5nIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gU3RyaW5nIH1cbmxldCBieXRlc19zZXhwX2dyYW1tYXIgOiBieXRlcyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFN0cmluZyB9XG5sZXQgY2hhcl9zZXhwX2dyYW1tYXIgOiBjaGFyIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQ2hhciB9XG5sZXQgaW50X3NleHBfZ3JhbW1hciA6IGludCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IGZsb2F0X3NleHBfZ3JhbW1hciA6IGZsb2F0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gRmxvYXQgfVxubGV0IGludDMyX3NleHBfZ3JhbW1hciA6IGludDMyIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgaW50NjRfc2V4cF9ncmFtbWFyIDogaW50NjQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIDogbmF0aXZlaW50IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgc2V4cF90X3NleHBfZ3JhbW1hciA6IFNleHAudCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEFueSBcIlNleHAudFwiIH1cbmxldCByZWZfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwX2dyYW1tYXIuY29lcmNlIGdyYW1tYXJcbmxldCBsYXp5X3Rfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwX2dyYW1tYXIuY29lcmNlIGdyYW1tYXJcblxubGV0IG9wdGlvbl9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIG9wdGlvbiBTZXhwX2dyYW1tYXIudCA9XG4gIHsgdW50eXBlZCA9IE9wdGlvbiB1bnR5cGVkIH1cbjs7XG5cbmxldCBsaXN0X3NleHBfZ3JhbW1hciAoeyB1bnR5cGVkIH0gOiBfIFNleHBfZ3JhbW1hci50KSA6IF8gbGlzdCBTZXhwX2dyYW1tYXIudCA9XG4gIHsgdW50eXBlZCA9IExpc3QgKE1hbnkgdW50eXBlZCkgfVxuOztcblxubGV0IGFycmF5X3NleHBfZ3JhbW1hciAoeyB1bnR5cGVkIH0gOiBfIFNleHBfZ3JhbW1hci50KSA6IF8gYXJyYXkgU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBMaXN0IChNYW55IHVudHlwZWQpIH1cbjs7XG5cbmxldCBlbXB0eV9zZXhwX2dyYW1tYXIgOiBfIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gVW5pb24gW10gfVxubGV0IG9wYXF1ZV9zZXhwX2dyYW1tYXIgPSBlbXB0eV9zZXhwX2dyYW1tYXJcbmxldCBmdW5fc2V4cF9ncmFtbWFyID0gZW1wdHlfc2V4cF9ncmFtbWFyXG4iLCIoKiBVdGlsaXR5IE1vZHVsZSBmb3IgUy1leHByZXNzaW9uIENvbnZlcnNpb25zICopXG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIE1vcmVMYWJlbHNcbm9wZW4gUHJpbnRmXG5vcGVuIFNleHBcblxuKCogQ29udmVyc2lvbiBvZiBPQ2FtbC12YWx1ZXMgdG8gUy1leHByZXNzaW9ucyAqKVxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG4oKiAnJS4xN2cnIGlzIGd1YXJhbnRlZWQgdG8gYmUgcm91bmQtdHJpcHBhYmxlLlxuXG4gICAnJS4xNWcnIHdpbGwgYmUgcm91bmQtdHJpcHBhYmxlIGFuZCBub3QgaGF2ZSBub2lzZSBhdCB0aGUgbGFzdCBkaWdpdCBvciB0d28gZm9yIGEgZmxvYXRcbiAgIHdoaWNoIHdhcyBjb252ZXJ0ZWQgZnJvbSBhIGRlY2ltYWwgKHN0cmluZykgd2l0aCA8PSAxNSBzaWduaWZpY2FudCBkaWdpdHMuICBTbyBpdCdzXG4gICB3b3J0aCB0cnlpbmcgZmlyc3QgdG8gYXZvaWQgdGhpbmdzIGxpa2UgXCIzLjE0MDAwMDAwMDAwMDAwMDFcIi5cblxuICAgU2VlIGNvbW1lbnQgYWJvdmUgW3RvX3N0cmluZ19yb3VuZF90cmlwcGFibGVdIGluIHshQ29yZS5GbG9hdH0gZm9yXG4gICBkZXRhaWxlZCBleHBsYW5hdGlvbiBhbmQgZXhhbXBsZXMuICopXG5sZXQgZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQgPVxuICByZWYgKGZ1biB4IC0+XG4gICAgbGV0IHkgPSBmb3JtYXRfZmxvYXQgXCIlLjE1R1wiIHggaW5cbiAgICBpZiBmbG9hdF9vZl9zdHJpbmcgeSA9IHggdGhlbiB5IGVsc2UgZm9ybWF0X2Zsb2F0IFwiJS4xN0dcIiB4KVxuOztcblxubGV0IHJlYWRfb2xkX29wdGlvbl9mb3JtYXQgPSByZWYgdHJ1ZVxubGV0IHdyaXRlX29sZF9vcHRpb25fZm9ybWF0ID0gcmVmIHRydWVcbmxldCBsaXN0X21hcCBmIGwgPSBMaXN0Lm1hcCBsIH5mXG5sZXQgc2V4cF9vZl91bml0ICgpID0gTGlzdCBbXVxubGV0IHNleHBfb2ZfYm9vbCBiID0gQXRvbSAoc3RyaW5nX29mX2Jvb2wgYilcbmxldCBzZXhwX29mX3N0cmluZyBzdHIgPSBBdG9tIHN0clxubGV0IHNleHBfb2ZfYnl0ZXMgYnl0ZXMgPSBBdG9tIChCeXRlcy50b19zdHJpbmcgYnl0ZXMpXG5sZXQgc2V4cF9vZl9jaGFyIGMgPSBBdG9tIChTdHJpbmcubWFrZSAxIGMpXG5sZXQgc2V4cF9vZl9pbnQgbiA9IEF0b20gKHN0cmluZ19vZl9pbnQgbilcbmxldCBzZXhwX29mX2Zsb2F0IG4gPSBBdG9tICghZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQgbilcbmxldCBzZXhwX29mX2ludDMyIG4gPSBBdG9tIChJbnQzMi50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX2ludDY0IG4gPSBBdG9tIChJbnQ2NC50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX25hdGl2ZWludCBuID0gQXRvbSAoTmF0aXZlaW50LnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfcmVmIHNleHBfb2ZfX2EgcmYgPSBzZXhwX29mX19hICFyZlxubGV0IHNleHBfb2ZfbGF6eV90IHNleHBfb2ZfX2EgbHYgPSBzZXhwX29mX19hIChMYXp5LmZvcmNlIGx2KVxuXG5sZXQgc2V4cF9vZl9vcHRpb24gc2V4cF9vZl9fYSA9IGZ1bmN0aW9uXG4gIHwgU29tZSB4IHdoZW4gIXdyaXRlX29sZF9vcHRpb25fZm9ybWF0IC0+IExpc3QgWyBzZXhwX29mX19hIHggXVxuICB8IFNvbWUgeCAtPiBMaXN0IFsgQXRvbSBcInNvbWVcIjsgc2V4cF9vZl9fYSB4IF1cbiAgfCBOb25lIHdoZW4gIXdyaXRlX29sZF9vcHRpb25fZm9ybWF0IC0+IExpc3QgW11cbiAgfCBOb25lIC0+IEF0b20gXCJub25lXCJcbjs7XG5cbmxldCBzZXhwX29mX3BhaXIgc2V4cF9vZl9fYSBzZXhwX29mX19iIChhLCBiKSA9IExpc3QgWyBzZXhwX29mX19hIGE7IHNleHBfb2ZfX2IgYiBdXG5cbmxldCBzZXhwX29mX3RyaXBsZSBzZXhwX29mX19hIHNleHBfb2ZfX2Igc2V4cF9vZl9fYyAoYSwgYiwgYykgPVxuICBMaXN0IFsgc2V4cF9vZl9fYSBhOyBzZXhwX29mX19iIGI7IHNleHBfb2ZfX2MgYyBdXG47O1xuXG5sZXQgc2V4cF9vZl9saXN0IHNleHBfb2ZfX2EgbHN0ID0gTGlzdCAoTGlzdC5tYXAgbHN0IH5mOnNleHBfb2ZfX2EpXG5cbmxldCBzZXhwX29mX2FycmF5IHNleHBfb2ZfX2EgYXIgPVxuICBsZXQgbHN0X3JlZiA9IHJlZiBbXSBpblxuICBmb3IgaSA9IEFycmF5Lmxlbmd0aCBhciAtIDEgZG93bnRvIDAgZG9cbiAgICBsc3RfcmVmIDo9IHNleHBfb2ZfX2EgYXIuKGkpIDo6ICFsc3RfcmVmXG4gIGRvbmU7XG4gIExpc3QgIWxzdF9yZWZcbjs7XG5cbmxldCBzZXhwX29mX2hhc2h0Ymwgc2V4cF9vZl9rZXkgc2V4cF9vZl92YWwgaHRibCA9XG4gIGxldCBjb2xsIH5rZXk6ayB+ZGF0YTp2IGFjYyA9IExpc3QgWyBzZXhwX29mX2tleSBrOyBzZXhwX29mX3ZhbCB2IF0gOjogYWNjIGluXG4gIExpc3QgKEhhc2h0YmwuZm9sZCBodGJsIH5pbml0OltdIH5mOmNvbGwpXG47O1xuXG5sZXQgc2V4cF9vZl9vcGFxdWUgXyA9IEF0b20gXCI8b3BhcXVlPlwiXG5sZXQgc2V4cF9vZl9mdW4gXyA9IEF0b20gXCI8ZnVuPlwiXG5cbigqIEV4Y2VwdGlvbiBjb252ZXJ0ZXIgcmVnaXN0cmF0aW9uIGFuZCBsb29rdXAgKilcblxubW9kdWxlIEV4bl9jb252ZXJ0ZXIgPSBzdHJ1Y3RcbiAgKCogVGhlc2UgZXhjZXB0aW9uIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgY29udGV4dC1zd2l0Y2hlc1xuICAgICBjYW5ub3QgaGFwcGVuIHVubGVzcyB0aGVyZSBpcyBhbiBhbGxvY2F0aW9uLiAgSXQgaXMgcmVhc29uYWJsZSB0byBleHBlY3RcbiAgICAgdGhhdCB0aGlzIHdpbGwgcmVtYWluIHRydWUgZm9yIHRoZSBmb3Jlc2VlYWJsZSBmdXR1cmUuICBUaGF0IHdheSB3ZVxuICAgICBhdm9pZCB1c2luZyBtdXRleGVzIGFuZCB0aHVzIGEgZGVwZW5kZW5jeSBvbiB0aGUgdGhyZWFkcyBsaWJyYXJ5LiAqKVxuXG4gICgqIEZhc3QgYW5kIGF1dG9tYXRpYyBleGNlcHRpb24gcmVnaXN0cmF0aW9uICopXG5cbiAgbW9kdWxlIFJlZ2lzdHJhdGlvbiA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB7IHNleHBfb2ZfZXhuIDogZXhuIC0+IFNleHAudFxuICAgICAgOyAoKiBJZiBbcHJpbnRleGMgPSB0cnVlXSB0aGVuIHRoaXMgc2V4cCBjb252ZXJ0ZXIgaXMgdXNlZCBmb3IgUHJpbnRleGMudG9fc3RyaW5nICopXG4gICAgICAgIHByaW50ZXhjIDogYm9vbFxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgRXhuX3RhYmxlID0gRXBoZW1lcm9uLksxLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgdCA9IGV4dGVuc2lvbl9jb25zdHJ1Y3RvclxuXG4gICAgbGV0IGVxdWFsID0gKCA9PSApXG4gICAgbGV0IGhhc2ggPSBPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkXG4gIGVuZClcblxuICBsZXQgdGhlX2V4bl90YWJsZSA6IFJlZ2lzdHJhdGlvbi50IEV4bl90YWJsZS50ID0gRXhuX3RhYmxlLmNyZWF0ZSAxN1xuXG4gICgqIEVwaGVtZXJvbnMgYXJlIHVzZWQgc28gdGhhdCBbc2V4cF9vZl9leG5dIGNsb3N1cmUgZG9uJ3Qga2VlcCB0aGVcbiAgICAgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIGxpdmUuICopXG4gIGxldCBhZGQgPyhwcmludGV4YyA9IHRydWUpID9maW5hbGlzZTpfIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBzZXhwX29mX2V4biA9XG4gICAgRXhuX3RhYmxlLmFkZCB0aGVfZXhuX3RhYmxlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB7IHNleHBfb2ZfZXhuOyBwcmludGV4YyB9XG4gIDs7XG5cbiAgbGV0IGZpbmRfYXV0byB+Zm9yX3ByaW50ZXhjIGV4biA9XG4gICAgbGV0IGV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9IE9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIGV4biBpblxuICAgIG1hdGNoIEV4bl90YWJsZS5maW5kX29wdCB0aGVfZXhuX3RhYmxlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeyBzZXhwX29mX2V4bjsgcHJpbnRleGMgfSAtPlxuICAgICAgKG1hdGNoIGZvcl9wcmludGV4YywgcHJpbnRleGMgd2l0aFxuICAgICAgIHwgZmFsc2UsIF8gfCBfLCB0cnVlIC0+IFNvbWUgKHNleHBfb2ZfZXhuIGV4bilcbiAgICAgICB8IHRydWUsIGZhbHNlIC0+IE5vbmUpXG4gIDs7XG5cbiAgbW9kdWxlIEZvcl91bml0X3Rlc3RzX29ubHkgPSBzdHJ1Y3RcbiAgICBsZXQgc2l6ZSAoKSA9IChFeG5fdGFibGUuc3RhdHNfYWxpdmUgdGhlX2V4bl90YWJsZSkubnVtX2JpbmRpbmdzXG4gIGVuZFxuZW5kXG5cbmxldCBzZXhwX29mX2V4bl9vcHRfZm9yX3ByaW50ZXhjIGV4biA9IEV4bl9jb252ZXJ0ZXIuZmluZF9hdXRvIH5mb3JfcHJpbnRleGM6dHJ1ZSBleG5cbmxldCBzZXhwX29mX2V4bl9vcHQgZXhuID0gRXhuX2NvbnZlcnRlci5maW5kX2F1dG8gfmZvcl9wcmludGV4YzpmYWxzZSBleG5cblxubGV0IHNleHBfb2ZfZXhuIGV4biA9XG4gIG1hdGNoIHNleHBfb2ZfZXhuX29wdCBleG4gd2l0aFxuICB8IE5vbmUgLT4gTGlzdCBbIEF0b20gKFByaW50ZXhjLnRvX3N0cmluZyBleG4pIF1cbiAgfCBTb21lIHNleHAgLT4gc2V4cFxuOztcblxubGV0IGV4bl90b19zdHJpbmcgZSA9IFNleHAudG9fc3RyaW5nX2h1bSAoc2V4cF9vZl9leG4gZSlcblxuKCoge1tleGNlcHRpb24gQmxhaCBbQEBkZXJpdmluZyBzZXhwXV19IGdlbmVyYXRlcyBhIGNhbGwgdG8gdGhlIGZ1bmN0aW9uXG4gICBbRXhuX2NvbnZlcnRlci5hZGRdIGRlZmluZWQgaW4gdGhpcyBmaWxlLiAgU28gd2UgYXJlIGd1YXJhbnRlZCB0aGF0IGFzIHNvb24gYXMgd2VcbiAgIG1hcmsgYW4gZXhjZXB0aW9uIGFzIHNleHBhYmxlLCB0aGlzIG1vZHVsZSB3aWxsIGJlIGxpbmtlZCBpbiBhbmQgdGhpcyBwcmludGVyIHdpbGwgYmVcbiAgIHJlZ2lzdGVyZWQsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudC4gKilcbmxldCAoKSA9XG4gIFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgKGZ1biBleG4gLT5cbiAgICBtYXRjaCBzZXhwX29mX2V4bl9vcHRfZm9yX3ByaW50ZXhjIGV4biB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgc2V4cCAtPiBTb21lIChTZXhwLnRvX3N0cmluZ19odW0gfmluZGVudDoyIHNleHApKVxuOztcblxubGV0IHByaW50ZXhjX3ByZWZlcl9zZXhwIGV4biA9XG4gIG1hdGNoIHNleHBfb2ZfZXhuX29wdCBleG4gd2l0aFxuICB8IE5vbmUgLT4gUHJpbnRleGMudG9fc3RyaW5nIGV4blxuICB8IFNvbWUgc2V4cCAtPiBTZXhwLnRvX3N0cmluZ19odW0gfmluZGVudDoyIHNleHBcbjs7XG5cbigqIENvbnZlcnNpb24gb2YgUy1leHByZXNzaW9ucyB0byBPQ2FtbC12YWx1ZXMgKilcblxuZXhjZXB0aW9uIE9mX3NleHBfZXJyb3IgPSBTZXhwLk9mX3NleHBfZXJyb3JcblxubGV0IHJlY29yZF9jaGVja19leHRyYV9maWVsZHMgPSByZWYgdHJ1ZVxubGV0IG9mX3NleHBfZXJyb3JfZXhuIGV4YyBzZXhwID0gcmFpc2UgKE9mX3NleHBfZXJyb3IgKGV4Yywgc2V4cCkpXG5sZXQgb2Zfc2V4cF9lcnJvciB3aGF0IHNleHAgPSByYWlzZSAoT2Zfc2V4cF9lcnJvciAoRmFpbHVyZSB3aGF0LCBzZXhwKSlcblxubGV0IHVuaXRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbXSAtPiAoKVxuICB8IEF0b20gXyB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwidW5pdF9vZl9zZXhwOiBlbXB0eSBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBib29sX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gKFwidHJ1ZVwiIHwgXCJUcnVlXCIpIC0+IHRydWVcbiAgfCBBdG9tIChcImZhbHNlXCIgfCBcIkZhbHNlXCIpIC0+IGZhbHNlXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJib29sX29mX3NleHA6IHVua25vd24gc3RyaW5nXCIgc2V4cFxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiYm9vbF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBzdHJpbmdfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT4gc3RyXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJzdHJpbmdfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgYnl0ZXNfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT4gQnl0ZXMub2Zfc3RyaW5nIHN0clxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiYnl0ZXNfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgY2hhcl9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgIGlmIFN0cmluZy5sZW5ndGggc3RyIDw+IDFcbiAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJjaGFyX29mX3NleHA6IGF0b20gc3RyaW5nIG11c3QgY29udGFpbiBvbmUgY2hhcmFjdGVyIG9ubHlcIiBzZXhwO1xuICAgIHN0ci5bMF1cbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImNoYXJfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaW50X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBpbnRfb2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiaW50X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJpbnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgZmxvYXRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IGZsb2F0X29mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImZsb2F0X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJmbG9hdF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBpbnQzMl9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgSW50MzIub2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiaW50MzJfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImludDMyX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGludDY0X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBJbnQ2NC5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnQ2NF9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiaW50NjRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgbmF0aXZlaW50X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBOYXRpdmVpbnQub2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwibmF0aXZlaW50X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJuYXRpdmVpbnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgcmVmX29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID0gcmVmIChhX19vZl9zZXhwIHNleHApXG5sZXQgbGF6eV90X29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID0gTGF6eS5mcm9tX3ZhbCAoYV9fb2Zfc2V4cCBzZXhwKVxuXG5sZXQgb3B0aW9uX29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID1cbiAgaWYgIXJlYWRfb2xkX29wdGlvbl9mb3JtYXRcbiAgdGhlbiAoXG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBMaXN0IFtdIHwgQXRvbSAoXCJub25lXCIgfCBcIk5vbmVcIikgLT4gTm9uZVxuICAgIHwgTGlzdCBbIGVsIF0gfCBMaXN0IFsgQXRvbSAoXCJzb21lXCIgfCBcIlNvbWVcIik7IGVsIF0gLT4gU29tZSAoYV9fb2Zfc2V4cCBlbClcbiAgICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IGxpc3QgbXVzdCByZXByZXNlbnQgb3B0aW9uYWwgdmFsdWVcIiBzZXhwXG4gICAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBvbmx5IG5vbmUgY2FuIGJlIGF0b21cIiBzZXhwKVxuICBlbHNlIChcbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IEF0b20gKFwibm9uZVwiIHwgXCJOb25lXCIpIC0+IE5vbmVcbiAgICB8IExpc3QgWyBBdG9tIChcInNvbWVcIiB8IFwiU29tZVwiKTsgZWwgXSAtPiBTb21lIChhX19vZl9zZXhwIGVsKVxuICAgIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogb25seSBub25lIGNhbiBiZSBhdG9tXCIgc2V4cFxuICAgIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogbGlzdCBtdXN0IGJlIChzb21lIGVsKVwiIHNleHApXG47O1xuXG5sZXQgcGFpcl9vZl9zZXhwIGFfX29mX3NleHAgYl9fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbIGFfc2V4cDsgYl9zZXhwIF0gLT5cbiAgICBsZXQgYSA9IGFfX29mX3NleHAgYV9zZXhwIGluXG4gICAgbGV0IGIgPSBiX19vZl9zZXhwIGJfc2V4cCBpblxuICAgIGEsIGJcbiAgfCBMaXN0IF8gLT5cbiAgICBvZl9zZXhwX2Vycm9yIFwicGFpcl9vZl9zZXhwOiBsaXN0IG11c3QgY29udGFpbiBleGFjdGx5IHR3byBlbGVtZW50cyBvbmx5XCIgc2V4cFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwicGFpcl9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCB0cmlwbGVfb2Zfc2V4cCBhX19vZl9zZXhwIGJfX29mX3NleHAgY19fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbIGFfc2V4cDsgYl9zZXhwOyBjX3NleHAgXSAtPlxuICAgIGxldCBhID0gYV9fb2Zfc2V4cCBhX3NleHAgaW5cbiAgICBsZXQgYiA9IGJfX29mX3NleHAgYl9zZXhwIGluXG4gICAgbGV0IGMgPSBjX19vZl9zZXhwIGNfc2V4cCBpblxuICAgIGEsIGIsIGNcbiAgfCBMaXN0IF8gLT5cbiAgICBvZl9zZXhwX2Vycm9yIFwidHJpcGxlX29mX3NleHA6IGxpc3QgbXVzdCBjb250YWluIGV4YWN0bHkgdGhyZWUgZWxlbWVudHMgb25seVwiIHNleHBcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcInRyaXBsZV9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBsaXN0X29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBsc3QgLT4gTGlzdC5tYXAgbHN0IH5mOmFfX29mX3NleHBcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImxpc3Rfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgYXJyYXlfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFtdIC0+IFt8fF1cbiAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIHQgKyAxIGluXG4gICAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgbGVuIChhX19vZl9zZXhwIGgpIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXNcbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIHJlcy4oaSkgPC0gYV9fb2Zfc2V4cCBoO1xuICAgICAgICBsb29wIChpICsgMSkgdFxuICAgIGluXG4gICAgbG9vcCAxIHRcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImFycmF5X29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGhhc2h0Ymxfb2Zfc2V4cCBrZXlfb2Zfc2V4cCB2YWxfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBsc3QgLT5cbiAgICBsZXQgaHRibCA9IEhhc2h0YmwuY3JlYXRlIDAgaW5cbiAgICBsZXQgYWN0ID0gZnVuY3Rpb25cbiAgICAgIHwgTGlzdCBbIGtfc2V4cDsgdl9zZXhwIF0gLT5cbiAgICAgICAgSGFzaHRibC5hZGQgaHRibCB+a2V5OihrZXlfb2Zfc2V4cCBrX3NleHApIH5kYXRhOih2YWxfb2Zfc2V4cCB2X3NleHApXG4gICAgICB8IExpc3QgXyB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiaGFzaHRibF9vZl9zZXhwOiB0dXBsZSBsaXN0IG5lZWRlZFwiIHNleHBcbiAgICBpblxuICAgIExpc3QuaXRlciBsc3QgfmY6YWN0O1xuICAgIGh0YmxcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImhhc2h0Ymxfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgb3BhcXVlX29mX3NleHAgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgXCJvcGFxdWVfb2Zfc2V4cDogY2Fubm90IGNvbnZlcnQgb3BhcXVlIHZhbHVlc1wiIHNleHBcbjs7XG5cbmxldCBmdW5fb2Zfc2V4cCBzZXhwID0gb2Zfc2V4cF9lcnJvciBcImZ1bl9vZl9zZXhwOiBjYW5ub3QgY29udmVydCBmdW5jdGlvbiB2YWx1ZXNcIiBzZXhwXG5cbigqIFNleHAgR3JhbW1hcnMgKilcblxuaW5jbHVkZSBTZXhwX2NvbnZfZ3JhbW1hclxuXG4oKiBSZWdpc3RlcmluZyBkZWZhdWx0IGV4Y2VwdGlvbiBwcmludGVycyAqKVxuXG5sZXQgZ2V0X2ZsY19lcnJvciBuYW1lIChmaWxlLCBsaW5lLCBjaHIpID0gQXRvbSAoc3ByaW50ZiBcIiVzICVzOiVkOiVkXCIgbmFtZSBmaWxlIGxpbmUgY2hyKVxuXG5sZXQgKCkgPVxuICBMaXN0Lml0ZXJcbiAgICB+ZjooZnVuIChleHRlbnNpb25fY29uc3RydWN0b3IsIGhhbmRsZXIpIC0+XG4gICAgICBFeG5fY29udmVydGVyLmFkZCB+cHJpbnRleGM6ZmFsc2UgfmZpbmFsaXNlOmZhbHNlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBoYW5kbGVyKVxuICAgIFsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBc3NlcnRfZmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBc3NlcnRfZmFpbHVyZSBhcmcgLT4gZ2V0X2ZsY19lcnJvciBcIkFzc2VydF9mYWlsdXJlXCIgYXJnXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFeGl0XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEV4aXQgLT4gQXRvbSBcIkV4aXRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgRW5kX29mX2ZpbGVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRW5kX29mX2ZpbGUgLT4gQXRvbSBcIkVuZF9vZl9maWxlXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRmFpbHVyZSBhcmcgLT4gTGlzdCBbIEF0b20gXCJGYWlsdXJlXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE5vdF9mb3VuZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBOb3RfZm91bmQgLT4gQXRvbSBcIk5vdF9mb3VuZFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBJbnZhbGlkX2FyZ3VtZW50XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEludmFsaWRfYXJndW1lbnQgYXJnIC0+IExpc3QgWyBBdG9tIFwiSW52YWxpZF9hcmd1bWVudFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNYXRjaF9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE1hdGNoX2ZhaWx1cmUgYXJnIC0+IGdldF9mbGNfZXJyb3IgXCJNYXRjaF9mYWlsdXJlXCIgYXJnXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBOb3RfZm91bmRfc11cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBOb3RfZm91bmRfcyBhcmcgLT4gTGlzdCBbIEF0b20gXCJOb3RfZm91bmRfc1wiOyBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3lzX2Vycm9yXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFN5c19lcnJvciBhcmcgLT4gTGlzdCBbIEF0b20gXCJTeXNfZXJyb3JcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgQXJnLkhlbHBdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgQXJnLkhlbHAgYXJnIC0+IExpc3QgWyBBdG9tIFwiQXJnLkhlbHBcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgQXJnLkJhZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBcmcuQmFkIGFyZyAtPiBMaXN0IFsgQXRvbSBcIkFyZy5CYWRcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTGF6eS5VbmRlZmluZWRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTGF6eS5VbmRlZmluZWQgLT4gQXRvbSBcIkxhenkuVW5kZWZpbmVkXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFBhcnNpbmcuUGFyc2VfZXJyb3JdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgUGFyc2luZy5QYXJzZV9lcnJvciAtPiBBdG9tIFwiUGFyc2luZy5QYXJzZV9lcnJvclwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBRdWV1ZS5FbXB0eV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBRdWV1ZS5FbXB0eSAtPiBBdG9tIFwiUXVldWUuRW1wdHlcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU2NhbmYuU2Nhbl9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFNjYW5mLlNjYW5fZmFpbHVyZSBhcmcgLT4gTGlzdCBbIEF0b20gXCJTY2FuZi5TY2FuX2ZhaWx1cmVcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3RhY2suRW1wdHldXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU3RhY2suRW1wdHkgLT4gQXRvbSBcIlN0YWNrLkVtcHR5XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFN5cy5CcmVha11cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTeXMuQnJlYWsgLT4gQXRvbSBcIlN5cy5CcmVha1wiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIF1cbjs7XG5cbmxldCAoKSA9XG4gIExpc3QuaXRlclxuICAgIH5mOihmdW4gKGV4dGVuc2lvbl9jb25zdHJ1Y3RvciwgaGFuZGxlcikgLT5cbiAgICAgIEV4bl9jb252ZXJ0ZXIuYWRkIH5wcmludGV4Yzp0cnVlIH5maW5hbGlzZTpmYWxzZSBleHRlbnNpb25fY29uc3RydWN0b3IgaGFuZGxlcilcbiAgICBbICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgT2Zfc2V4cF9lcnJvcl1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBPZl9zZXhwX2Vycm9yIChleGMsIHNleHApIC0+XG4gICAgICAgICAgTGlzdCBbIEF0b20gXCJTZXhwbGliLkNvbnYuT2Zfc2V4cF9lcnJvclwiOyBzZXhwX29mX2V4biBleGM7IHNleHAgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICBdXG47O1xuXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuIiwiKCogQ29udl9lcnJvcjogTW9kdWxlIGZvciBIYW5kbGluZyBFcnJvcnMgZHVyaW5nIEF1dG9tYXRlZCBTLWV4cHJlc3Npb25cbiAgIENvbnZlcnNpb25zICopXG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIFByaW50Zlxub3BlbiBTZXhwX2NvbnZcblxuZXhjZXB0aW9uIE9mX3NleHBfZXJyb3IgPSBPZl9zZXhwX2Vycm9yXG5cbmxldCBlcnJvciB+bG9jIH5zZXhwIG1zZyA9IG9mX3NleHBfZXJyb3IgKHNwcmludGYgXCIlc19vZl9zZXhwOiAlc1wiIGxvYyBtc2cpIHNleHBcbmxldCBzaW1wbGVfZXJyb3IgbXNnIGxvYyBzZXhwID0gZXJyb3IgfmxvYyB+c2V4cCBtc2dcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgdHVwbGVzICopXG5cbmxldCB0dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgbG9jIG4gc2V4cCA9XG4gIGVycm9yIH5sb2MgfnNleHAgKHNwcmludGYgXCJ0dXBsZSBvZiBzaXplICVkIGV4cGVjdGVkXCIgbilcbjs7XG5cbmxldCB0dXBsZV9wYWlyX2V4cGVjdGVkIGxvYyBuYW1lIHNleHAgPVxuICBsZXQgbXNnID0gc3ByaW50ZiBcIiVzX29mX3NleHA6IGV4cGVjdGVkIGEgcGFpciBiZWdpbm5pbmcgd2l0aCBsYWJlbCAlc1wiIGxvYyBuYW1lIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCB0dXBsZV9pbmNvcnJlY3RfbGFiZWwgbG9jIG5hbWUgcG9zIHNleHAgPVxuICBsZXQgbXNnID1cbiAgICBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogaW5jb3JyZWN0IGxhYmVsIGZvciBlbGVtZW50ICVzIGF0IHBvc2l0aW9uICVpXCIgbG9jIG5hbWUgcG9zXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbigqIEVycm9ycyBjb25jZXJuaW5nIHN1bSB0eXBlcyAqKVxuXG5sZXQgc3RhZ19ub19hcmdzID0gc2ltcGxlX2Vycm9yIFwidGhpcyBjb25zdHJ1Y3RvciBkb2VzIG5vdCB0YWtlIGFyZ3VtZW50c1wiXG5cbmxldCBzdGFnX2luY29ycmVjdF9uX2FyZ3MgbG9jIHRhZyBzZXhwID1cbiAgZXJyb3IgfmxvYyB+c2V4cCAoc3ByaW50ZiBcInN1bSB0YWcgJVMgaGFzIGluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzXCIgdGFnKVxuOztcblxubGV0IHN0YWdfdGFrZXNfYXJncyA9IHNpbXBsZV9lcnJvciBcInRoaXMgY29uc3RydWN0b3IgcmVxdWlyZXMgYXJndW1lbnRzXCJcbmxldCBuZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSA9IHNpbXBsZV9lcnJvciBcImV4cGVjdGVkIGEgdmFyaWFudCB0eXBlLCBzYXcgYSBuZXN0ZWQgbGlzdFwiXG5sZXQgZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSA9IHNpbXBsZV9lcnJvciBcImV4cGVjdGVkIGEgdmFyaWFudCB0eXBlLCBzYXcgYW4gZW1wdHkgbGlzdFwiXG5sZXQgdW5leHBlY3RlZF9zdGFnID0gc2ltcGxlX2Vycm9yIFwidW5leHBlY3RlZCB2YXJpYW50IGNvbnN0cnVjdG9yXCJcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgcmVjb3JkcyAqKVxuXG5sZXQgcmVjb3JkX3NleHBfYm9vbF93aXRoX3BheWxvYWQgPVxuICBzaW1wbGVfZXJyb3IgXCJyZWNvcmQgY29udmVyc2lvbjogYSBbc2V4cC5ib29sXSBmaWVsZCB3YXMgZ2l2ZW4gYSBwYXlsb2FkLlwiXG47O1xuXG5sZXQgcmVjb3JkX29ubHlfcGFpcnNfZXhwZWN0ZWQgPVxuICBzaW1wbGVfZXJyb3JcbiAgICBcInJlY29yZCBjb252ZXJzaW9uOiBvbmx5IHBhaXJzIGV4cGVjdGVkLCB0aGVpciBmaXJzdCBlbGVtZW50IG11c3QgYmUgYW4gYXRvbVwiXG47O1xuXG5sZXQgcmVjb3JkX2ludmFsaWRfZmllbGRzIH53aGF0IH5sb2MgZmxkX25hbWVzIHNleHAgPVxuICBsZXQgZmxkX25hbWVzX3N0ciA9IFN0cmluZy5jb25jYXQgZmxkX25hbWVzIH5zZXA6XCIgXCIgaW5cbiAgZXJyb3IgfmxvYyB+c2V4cCAoc3ByaW50ZiBcIiVzOiAlc1wiIHdoYXQgZmxkX25hbWVzX3N0cilcbjs7XG5cbmxldCByZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyBsb2MgZmxkX25hbWVzIHNleHAgPVxuICByZWNvcmRfaW52YWxpZF9maWVsZHMgfndoYXQ6XCJkdXBsaWNhdGUgZmllbGRzXCIgfmxvYyBmbGRfbmFtZXMgc2V4cFxuOztcblxubGV0IHJlY29yZF9leHRyYV9maWVsZHMgbG9jIGZsZF9uYW1lcyBzZXhwID1cbiAgcmVjb3JkX2ludmFsaWRfZmllbGRzIH53aGF0OlwiZXh0cmEgZmllbGRzXCIgfmxvYyBmbGRfbmFtZXMgc2V4cFxuOztcblxubGV0IHJlYyByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIGZpZWxkcyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gU3RyaW5nLmNvbmNhdCAoTGlzdC5yZXYgZmllbGRzKSB+c2VwOlwiIFwiXG4gIHwgKHRydWUsIGZpZWxkKSA6OiByZXN0IC0+IHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgKGZpZWxkIDo6IGZpZWxkcykgcmVzdFxuICB8IF8gOjogcmVzdCAtPiByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIGZpZWxkcyByZXN0XG47O1xuXG5sZXQgcmVjb3JkX3VuZGVmaW5lZF9lbGVtZW50cyBsb2Mgc2V4cCBsc3QgPVxuICBsZXQgdW5kZWZpbmVkID0gcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCBbXSBsc3QgaW5cbiAgbGV0IG1zZyA9IHNwcmludGYgXCJ0aGUgZm9sbG93aW5nIHJlY29yZCBlbGVtZW50cyB3ZXJlIHVuZGVmaW5lZDogJXNcIiB1bmRlZmluZWQgaW5cbiAgZXJyb3IgfmxvYyB+c2V4cCBtc2dcbjs7XG5cbmxldCByZWNvcmRfbGlzdF9pbnN0ZWFkX2F0b20gPSBzaW1wbGVfZXJyb3IgXCJsaXN0IGluc3RlYWQgb2YgYXRvbSBmb3IgcmVjb3JkIGV4cGVjdGVkXCJcblxubGV0IHJlY29yZF9wb2x5X2ZpZWxkX3ZhbHVlID1cbiAgc2ltcGxlX2Vycm9yIFwiY2Fubm90IGNvbnZlcnQgdmFsdWVzIG9mIHR5cGVzIHJlc3VsdGluZyBmcm9tIHBvbHltb3JwaGljIHJlY29yZCBmaWVsZHNcIlxuOztcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgcG9seW1vcnBoaWMgdmFyaWFudHMgKilcblxuZXhjZXB0aW9uIE5vX3ZhcmlhbnRfbWF0Y2hcblxubGV0IG5vX3ZhcmlhbnRfbWF0Y2ggKCkgPSByYWlzZSBOb192YXJpYW50X21hdGNoXG5sZXQgbm9fbWF0Y2hpbmdfdmFyaWFudF9mb3VuZCA9IHNpbXBsZV9lcnJvciBcIm5vIG1hdGNoaW5nIHZhcmlhbnQgZm91bmRcIlxubGV0IHB0YWdfbm9fYXJncyA9IHNpbXBsZV9lcnJvciBcInBvbHltb3JwaGljIHZhcmlhbnQgZG9lcyBub3QgdGFrZSBhcmd1bWVudHNcIlxuXG5sZXQgcHRhZ19pbmNvcnJlY3Rfbl9hcmdzIGxvYyBjbnN0ciBzZXhwID1cbiAgZXJyb3JcbiAgICB+bG9jXG4gICAgfnNleHBcbiAgICAoc3ByaW50ZiBcInBvbHltb3JwaGljIHZhcmlhbnQgdGFnICVTIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50c1wiIGNuc3RyKVxuOztcblxubGV0IHB0YWdfdGFrZXNfYXJncyA9IHNpbXBsZV9lcnJvciBcInBvbHltb3JwaGljIHZhcmlhbnQgdGFnIHRha2VzIGFuIGFyZ3VtZW50XCJcblxubGV0IG5lc3RlZF9saXN0X2ludmFsaWRfcG9seV92YXIgPVxuICBzaW1wbGVfZXJyb3IgXCJhIG5lc3RlZCBsaXN0IGlzIGFuIGludmFsaWQgcG9seW1vcnBoaWMgdmFyaWFudFwiXG47O1xuXG5sZXQgZW1wdHlfbGlzdF9pbnZhbGlkX3BvbHlfdmFyID1cbiAgc2ltcGxlX2Vycm9yIFwidGhlIGVtcHR5IGxpc3QgaXMgYW4gaW52YWxpZCBwb2x5bW9ycGhpYyB2YXJpYW50XCJcbjs7XG5cbmxldCBlbXB0eV90eXBlID0gc2ltcGxlX2Vycm9yIFwidHJ5aW5nIHRvIGNvbnZlcnQgYW4gZW1wdHkgdHlwZVwiXG4iLCJtb2R1bGUgRmllbGRzID0gc3RydWN0XG4gIHR5cGUgXyB0ID1cbiAgICB8IEZpZWxkIDpcbiAgICAgICAgeyBuYW1lIDogc3RyaW5nXG4gICAgICAgIDsgY29udiA6IFNleHAudCAtPiAnYVxuICAgICAgICA7IHJlc3QgOiAnYiB0XG4gICAgICAgIH1cbiAgICAgICAgLT4gKCdhICogJ2IpIHRcbiAgICB8IEVtcHR5IDogdW5pdCB0XG5cbiAgbGV0IHJlYyBsZW5ndGhfbG9vcCA6IHR5cGUgYS4gYSB0IC0+IGludCAtPiBpbnQgPVxuICAgIGZ1biB0IGFjYyAtPlxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjXG4gICAgfCBGaWVsZCBmaWVsZCAtPiBsZW5ndGhfbG9vcCBmaWVsZC5yZXN0IChhY2MgKyAxKVxuICA7O1xuXG4gIGxldCBsZW5ndGggdCA9IGxlbmd0aF9sb29wIHQgMFxuZW5kXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIG9mX2xpc3RcbiAgOiB0eXBlIGEuXG4gICAgY2FsbGVyOnN0cmluZ1xuICAgIC0+IGZpZWxkczphIEZpZWxkcy50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IG9yaWdpbmFsX3NleHA6U2V4cC50XG4gICAgLT4gcG9zOmludFxuICAgIC0+IFNleHAudCBsaXN0XG4gICAgLT4gYVxuICA9XG4gIGZ1biB+Y2FsbGVyIH5maWVsZHMgfmxlbiB+b3JpZ2luYWxfc2V4cCB+cG9zIGxpc3QgLT5cbiAgbWF0Y2ggZmllbGRzIHdpdGhcbiAgfCBFbXB0eSAtPlxuICAgIChtYXRjaCBsaXN0IHdpdGhcbiAgICAgfCBbXSAtPiAoKVxuICAgICB8IF8gOjogXyAtPiBTZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkIGNhbGxlciBsZW4gb3JpZ2luYWxfc2V4cClcbiAgfCBGaWVsZCB7IG5hbWU7IGNvbnY7IHJlc3QgfSAtPlxuICAgIChtYXRjaCBsaXN0IHdpdGhcbiAgICAgfCBbXSAtPiBTZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkIGNhbGxlciBsZW4gb3JpZ2luYWxfc2V4cFxuICAgICB8IHNleHAgOjogbGlzdCAtPlxuICAgICAgIChtYXRjaCBzZXhwIHdpdGhcbiAgICAgICAgfCBMaXN0IFsgQXRvbSBhdG9tOyBzZXhwIF0gLT5cbiAgICAgICAgICBpZiBTdHJpbmcuZXF1YWwgYXRvbSBuYW1lXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgKCBjb252IHNleHBcbiAgICAgICAgICAgICwgb2ZfbGlzdCB+Y2FsbGVyIH5maWVsZHM6cmVzdCB+bGVuIH5vcmlnaW5hbF9zZXhwIH5wb3M6KHBvcyArIDEpIGxpc3QgKVxuICAgICAgICAgIGVsc2UgU2V4cF9jb252X2Vycm9yLnR1cGxlX2luY29ycmVjdF9sYWJlbCBjYWxsZXIgbmFtZSBwb3Mgb3JpZ2luYWxfc2V4cFxuICAgICAgICB8IF8gLT4gU2V4cF9jb252X2Vycm9yLnR1cGxlX3BhaXJfZXhwZWN0ZWQgY2FsbGVyIG5hbWUgc2V4cCkpXG47O1xuXG5sZXQgbGFiZWxlZF90dXBsZV9vZl9zZXhwIH5jYWxsZXIgfmZpZWxkcyB+Y3JlYXRlIG9yaWdpbmFsX3NleHAgPVxuICBsZXQgbGVuID0gRmllbGRzLmxlbmd0aCBmaWVsZHMgaW5cbiAgbWF0Y2ggKG9yaWdpbmFsX3NleHAgOiBTZXhwLnQpIHdpdGhcbiAgfCBBdG9tIF8gLT4gU2V4cF9jb252X2Vycm9yLnR1cGxlX29mX3NpemVfbl9leHBlY3RlZCBjYWxsZXIgbGVuIG9yaWdpbmFsX3NleHBcbiAgfCBMaXN0IGxpc3QgLT4gY3JlYXRlIChvZl9saXN0IH5jYWxsZXIgfmZpZWxkcyB+bGVuIH5vcmlnaW5hbF9zZXhwIH5wb3M6MCBsaXN0KVxuOztcbiIsIm9wZW4hIFN0ZExhYmVsc1xub3BlbiEgU2V4cF9jb252XG5vcGVuISBTZXhwX2NvbnZfZXJyb3JcblxubW9kdWxlIEtpbmQgPSBzdHJ1Y3RcbiAgdHlwZSAoXywgXykgdCA9XG4gICAgfCBEZWZhdWx0IDogKHVuaXQgLT4gJ2EpIC0+ICgnYSwgU2V4cC50IC0+ICdhKSB0XG4gICAgfCBPbWl0X25pbCA6ICgnYSwgU2V4cC50IC0+ICdhKSB0XG4gICAgfCBSZXF1aXJlZCA6ICgnYSwgU2V4cC50IC0+ICdhKSB0XG4gICAgfCBTZXhwX2FycmF5IDogKCdhIGFycmF5LCBTZXhwLnQgLT4gJ2EpIHRcbiAgICB8IFNleHBfYm9vbCA6IChib29sLCB1bml0KSB0XG4gICAgfCBTZXhwX2xpc3QgOiAoJ2EgbGlzdCwgU2V4cC50IC0+ICdhKSB0XG4gICAgfCBTZXhwX29wdGlvbiA6ICgnYSBvcHRpb24sIFNleHAudCAtPiAnYSkgdFxuZW5kXG5cbm1vZHVsZSBGaWVsZHMgPSBzdHJ1Y3RcbiAgdHlwZSBfIHQgPVxuICAgIHwgRW1wdHkgOiB1bml0IHRcbiAgICB8IEZpZWxkIDpcbiAgICAgICAgeyBuYW1lIDogc3RyaW5nXG4gICAgICAgIDsga2luZCA6ICgnYSwgJ2NvbnYpIEtpbmQudFxuICAgICAgICA7IGNvbnYgOiAnY29udlxuICAgICAgICA7IHJlc3QgOiAnYiB0XG4gICAgICAgIH1cbiAgICAgICAgLT4gKCdhICogJ2IpIHRcblxuICBsZXQgbGVuZ3RoID1cbiAgICBsZXQgcmVjIGxlbmd0aF9sb29wIDogdHlwZSBhLiBhIHQgLT4gaW50IC0+IGludCA9XG4gICAgICBmdW4gdCBhY2MgLT5cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBGaWVsZCB7IHJlc3Q7IF8gfSAtPiBsZW5ndGhfbG9vcCByZXN0IChhY2MgKyAxKVxuICAgICAgfCBFbXB0eSAtPiBhY2NcbiAgICBpblxuICAgIGZ1biB0IC0+IGxlbmd0aF9sb29wIHQgMFxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWxmb3JtZWQgPSBzdHJ1Y3RcbiAgKCogUmVwcmVzZW50cyBlcnJvcnMgdGhhdCBjYW4gb2NjdXIgZHVlIHRvIG1hbGZvcm1lZCByZWNvcmQgc2V4cHMuIEFjY3VtdWxhdGVkIGFzIGFcbiAgICAgdmFsdWUgc28gd2UgY2FuIHJlcG9ydCBtdWx0aXBsZSBuYW1lcyBhdCBvbmNlIGZvciBleHRyYSBmaWVsZHMsIGR1cGxpY2F0ZSBmaWVsZHMsIG9yXG4gICAgIG1pc3NpbmcgZmllbGRzLiAqKVxuICB0eXBlIHQgPVxuICAgIHwgQm9vbF9wYXlsb2FkXG4gICAgfCBFeHRyYXMgb2Ygc3RyaW5nIGxpc3RcbiAgICB8IER1cHMgb2Ygc3RyaW5nIGxpc3RcbiAgICB8IE1pc3Npbmcgb2Ygc3RyaW5nIGxpc3RcbiAgICB8IE5vbl9wYWlyIG9mIFNleHAudCBvcHRpb25cblxuICBsZXQgY29tYmluZSBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgICgqIGNob29zZSB0aGUgZmlyc3QgYm9vbC1wYXlsb2FkIG9yIG5vbi1wYWlyIGVycm9yIHRoYXQgb2NjdXJzICopXG4gICAgfCAoKEJvb2xfcGF5bG9hZCB8IE5vbl9wYWlyIF8pIGFzIHQpLCBfIC0+IHRcbiAgICB8IF8sICgoQm9vbF9wYXlsb2FkIHwgTm9uX3BhaXIgXykgYXMgdCkgLT4gdFxuICAgICgqIGNvbWJpbmUgbGlzdHMgb2Ygc2ltaWxhciBlcnJvcnMgKilcbiAgICB8IEV4dHJhcyBhLCBFeHRyYXMgYiAtPiBFeHRyYXMgKGEgQCBiKVxuICAgIHwgRHVwcyBhLCBEdXBzIGIgLT4gRHVwcyAoYSBAIGIpXG4gICAgfCBNaXNzaW5nIGEsIE1pc3NpbmcgYiAtPiBNaXNzaW5nIChhIEAgYilcbiAgICAoKiBvdGhlcndpc2UsIGR1cHMgPiBleHRyYXMgPiBtaXNzaW5nICopXG4gICAgfCAoRHVwcyBfIGFzIHQpLCBfIHwgXywgKER1cHMgXyBhcyB0KSAtPiB0XG4gICAgfCAoRXh0cmFzIF8gYXMgdCksIF8gfCBfLCAoRXh0cmFzIF8gYXMgdCkgLT4gdFxuICA7O1xuXG4gIGxldCByYWlzZSB0IH5jYWxsZXIgfmNvbnRleHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgQm9vbF9wYXlsb2FkIC0+IHJlY29yZF9zZXhwX2Jvb2xfd2l0aF9wYXlsb2FkIGNhbGxlciBjb250ZXh0XG4gICAgfCBFeHRyYXMgbmFtZXMgLT4gcmVjb3JkX2V4dHJhX2ZpZWxkcyBjYWxsZXIgbmFtZXMgY29udGV4dFxuICAgIHwgRHVwcyBuYW1lcyAtPiByZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyBjYWxsZXIgbmFtZXMgY29udGV4dFxuICAgIHwgTWlzc2luZyBuYW1lcyAtPlxuICAgICAgTGlzdC5tYXAgbmFtZXMgfmY6KGZ1biBuYW1lIC0+IHRydWUsIG5hbWUpXG4gICAgICB8PiByZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIGNhbGxlciBjb250ZXh0XG4gICAgfCBOb25fcGFpciBtYXliZV9jb250ZXh0IC0+XG4gICAgICBsZXQgY29udGV4dCA9IE9wdGlvbi52YWx1ZSBtYXliZV9jb250ZXh0IH5kZWZhdWx0OmNvbnRleHQgaW5cbiAgICAgIHJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIGNhbGxlciBjb250ZXh0XG4gIDs7XG5lbmRcblxuZXhjZXB0aW9uIE1hbGZvcm1lZCBvZiBNYWxmb3JtZWQudFxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgKCogU3RvcmVzIHNleHBzIGNvcnJlc3BvbmRpbmcgdG8gcmVjb3JkIGZpZWxkcywgaW4gdGhlIG9yZGVyIHRoZSBmaWVsZHMgd2VyZSBkZWNsYXJlZC5cbiAgICAgRXhjbHVkZXMgZmllbGRzIGFscmVhZHkgcGFyc2VkIGluIHRoZSBmYXN0IHBhdGguXG5cbiAgICAgTGlzdCBzZXhwcyByZXByZXNlbnQgYSBmaWVsZCB0aGF0IGlzIHByZXNlbnQsIHN1Y2ggYXMgKHggMSkgZm9yIGEgZmllbGQgbmFtZWQgXCJ4XCIuXG4gICAgIEF0b20gc2V4cHMgcmVwcmVzZW50IGEgZmllbGQgdGhhdCBpcyBhYnNlbnQsIG9yIGF0IGxlYXN0IG5vdCB5ZXQgc2Vlbi4gKilcbiAgdHlwZSB0ID0geyBzdGF0ZSA6IFNleHAudCBhcnJheSB9IFtAQHVuYm94ZWRdXG5cbiAgbGV0IHVuc2FmZV9nZXQgdCBwb3MgPSBBcnJheS51bnNhZmVfZ2V0IHQuc3RhdGUgcG9zXG4gIGxldCB1bnNhZmVfc2V0IHQgcG9zIHNleHAgPSBBcnJheS51bnNhZmVfc2V0IHQuc3RhdGUgcG9zIHNleHBcbiAgbGV0IGFic2VudCA9IFNleHAuQXRvbSBcIlwiXG4gIGxldCBjcmVhdGUgbGVuID0geyBzdGF0ZSA9IEFycmF5Lm1ha2UgbGVuIGFic2VudCB9XG5lbmRcblxuKCogUGFyc2luZyBmaWVsZCB2YWx1ZXMgZnJvbSBzdGF0ZS4gKilcblxubGV0IHJlYyBwYXJzZV92YWx1ZV9tYWxmb3JtZWRcbiAgOiB0eXBlIGEgYi4gTWFsZm9ybWVkLnQgLT4gZmllbGRzOihhICogYikgRmllbGRzLnQgLT4gc3RhdGU6U3RhdGUudCAtPiBwb3M6aW50IC0+IGFcbiAgPVxuICBmdW4gbWFsZm9ybWVkIH5maWVsZHMgfnN0YXRlIH5wb3MgLT5cbiAgbGV0IChGaWVsZCBmaWVsZCkgPSBmaWVsZHMgaW5cbiAgbGV0IG1hbGZvcm1lZCA9XG4gICAgbWF0Y2ggcGFyc2VfdmFsdWVzIH5maWVsZHM6ZmllbGQucmVzdCB+c3RhdGUgfnBvczoocG9zICsgMSkgd2l0aFxuICAgIHwgKF8gOiBiKSAtPiBtYWxmb3JtZWRcbiAgICB8IGV4Y2VwdGlvbiBNYWxmb3JtZWQgb3RoZXIgLT4gTWFsZm9ybWVkLmNvbWJpbmUgbWFsZm9ybWVkIG90aGVyXG4gIGluXG4gIHJhaXNlIChNYWxmb3JtZWQgbWFsZm9ybWVkKVxuXG5hbmQgcGFyc2VfdmFsdWUgOiB0eXBlIGEgYi4gZmllbGRzOihhICogYikgRmllbGRzLnQgLT4gc3RhdGU6U3RhdGUudCAtPiBwb3M6aW50IC0+IGEgKiBiID1cbiAgZnVuIH5maWVsZHMgfnN0YXRlIH5wb3MgLT5cbiAgbGV0IChGaWVsZCB7IG5hbWU7IGtpbmQ7IGNvbnY7IHJlc3QgfSkgPSBmaWVsZHMgaW5cbiAgbGV0IHZhbHVlIDogYSA9XG4gICAgbWF0Y2gga2luZCwgU3RhdGUudW5zYWZlX2dldCBzdGF0ZSBwb3Mgd2l0aFxuICAgICgqIHdlbGwtZm9ybWVkICopXG4gICAgfCBSZXF1aXJlZCwgTGlzdCBbIF87IHNleHAgXSAtPiBjb252IHNleHBcbiAgICB8IERlZmF1bHQgXywgTGlzdCBbIF87IHNleHAgXSAtPiBjb252IHNleHBcbiAgICB8IE9taXRfbmlsLCBMaXN0IFsgXzsgc2V4cCBdIC0+IGNvbnYgc2V4cFxuICAgIHwgU2V4cF9vcHRpb24sIExpc3QgWyBfOyBzZXhwIF0gLT4gU29tZSAoY29udiBzZXhwKVxuICAgIHwgU2V4cF9saXN0LCBMaXN0IFsgXzsgc2V4cCBdIC0+IGxpc3Rfb2Zfc2V4cCBjb252IHNleHBcbiAgICB8IFNleHBfYXJyYXksIExpc3QgWyBfOyBzZXhwIF0gLT4gYXJyYXlfb2Zfc2V4cCBjb252IHNleHBcbiAgICB8IFNleHBfYm9vbCwgTGlzdCBbIF8gXSAtPiB0cnVlXG4gICAgKCogaWxsLWZvcm1lZCAqKVxuICAgIHwgKCAoUmVxdWlyZWQgfCBEZWZhdWx0IF8gfCBPbWl0X25pbCB8IFNleHBfb3B0aW9uIHwgU2V4cF9saXN0IHwgU2V4cF9hcnJheSlcbiAgICAgICwgKExpc3QgKF8gOjogXyA6OiBfIDo6IF8pIGFzIHNleHApICkgLT5cbiAgICAgIHBhcnNlX3ZhbHVlX21hbGZvcm1lZCAoTm9uX3BhaXIgKFNvbWUgc2V4cCkpIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgICB8ICggKFJlcXVpcmVkIHwgRGVmYXVsdCBfIHwgT21pdF9uaWwgfCBTZXhwX29wdGlvbiB8IFNleHBfbGlzdCB8IFNleHBfYXJyYXkpXG4gICAgICAsIExpc3QgKFtdIHwgWyBfIF0pICkgLT4gcGFyc2VfdmFsdWVfbWFsZm9ybWVkIChOb25fcGFpciBOb25lKSB+ZmllbGRzIH5zdGF0ZSB+cG9zXG4gICAgfCBTZXhwX2Jvb2wsIExpc3QgKFtdIHwgXyA6OiBfIDo6IF8pIC0+XG4gICAgICBwYXJzZV92YWx1ZV9tYWxmb3JtZWQgQm9vbF9wYXlsb2FkIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgICAoKiBhYnNlbnQgKilcbiAgICB8IFJlcXVpcmVkLCBBdG9tIF8gLT4gcGFyc2VfdmFsdWVfbWFsZm9ybWVkIChNaXNzaW5nIFsgbmFtZSBdKSB+ZmllbGRzIH5zdGF0ZSB+cG9zXG4gICAgfCBEZWZhdWx0IGRlZmF1bHQsIEF0b20gXyAtPiBkZWZhdWx0ICgpXG4gICAgfCBPbWl0X25pbCwgQXRvbSBfIC0+IGNvbnYgKExpc3QgW10pXG4gICAgfCBTZXhwX29wdGlvbiwgQXRvbSBfIC0+IE5vbmVcbiAgICB8IFNleHBfbGlzdCwgQXRvbSBfIC0+IFtdXG4gICAgfCBTZXhwX2FycmF5LCBBdG9tIF8gLT4gW3x8XVxuICAgIHwgU2V4cF9ib29sLCBBdG9tIF8gLT4gZmFsc2VcbiAgaW5cbiAgdmFsdWUsIHBhcnNlX3ZhbHVlcyB+ZmllbGRzOnJlc3QgfnN0YXRlIH5wb3M6KHBvcyArIDEpXG5cbmFuZCBwYXJzZV92YWx1ZXMgOiB0eXBlIGEuIGZpZWxkczphIEZpZWxkcy50IC0+IHN0YXRlOlN0YXRlLnQgLT4gcG9zOmludCAtPiBhID1cbiAgZnVuIH5maWVsZHMgfnN0YXRlIH5wb3MgLT5cbiAgbWF0Y2ggZmllbGRzIHdpdGhcbiAgfCBGaWVsZCBfIC0+IHBhcnNlX3ZhbHVlIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgfCBFbXB0eSAtPiAoKVxuOztcblxuKCogUG9wdWxhdGluZyBzdGF0ZS4gSGFuZGxlcyBzbG93IHBhdGggY2FzZXMgd2hlcmUgdGhlcmUgbWF5IGJlIHJlb3JkZXJlZCwgZHVwbGljYXRlZCxcbiAgIG1pc3NpbmcsIG9yIGV4dHJhIGZpZWxkcy4gKilcblxubGV0IHJlYyBwYXJzZV9zcGluZV9tYWxmb3JtZWQgbWFsZm9ybWVkIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHMgPVxuICBsZXQgbWFsZm9ybWVkID1cbiAgICBtYXRjaCBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHMgd2l0aFxuICAgIHwgKCkgLT4gbWFsZm9ybWVkXG4gICAgfCBleGNlcHRpb24gTWFsZm9ybWVkIG90aGVyIC0+IE1hbGZvcm1lZC5jb21iaW5lIG1hbGZvcm1lZCBvdGhlclxuICBpblxuICByYWlzZSAoTWFsZm9ybWVkIG1hbGZvcm1lZClcblxuYW5kIHBhcnNlX3NwaW5lX3Nsb3cgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwcyA9XG4gIG1hdGNoIChzZXhwcyA6IFNleHAudCBsaXN0KSB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCAoTGlzdCAoQXRvbSBuYW1lIDo6IF8pIGFzIGZpZWxkKSA6OiBzZXhwcyAtPlxuICAgIGxldCBpID0gaW5kZXggbmFtZSBpblxuICAgIChtYXRjaCBzZWVuIDw9IGkgJiYgaSA8IGxlbiB3aXRoXG4gICAgIHwgdHJ1ZSAtPlxuICAgICAgICgqIHZhbGlkIGZpZWxkIGZvciBzbG93LXBhdGggcGFyc2luZyAqKVxuICAgICAgIGxldCBwb3MgPSBpIC0gc2VlbiBpblxuICAgICAgIChtYXRjaCBTdGF0ZS51bnNhZmVfZ2V0IHN0YXRlIHBvcyB3aXRoXG4gICAgICAgIHwgQXRvbSBfIC0+XG4gICAgICAgICAgKCogZmllbGQgbm90IHNlZW4geWV0ICopXG4gICAgICAgICAgU3RhdGUudW5zYWZlX3NldCBzdGF0ZSBwb3MgZmllbGQ7XG4gICAgICAgICAgcGFyc2Vfc3BpbmVfc2xvdyB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzXG4gICAgICAgIHwgTGlzdCBfIC0+XG4gICAgICAgICAgKCogZmllbGQgYWxyZWFkeSBzZWVuICopXG4gICAgICAgICAgcGFyc2Vfc3BpbmVfbWFsZm9ybWVkIChEdXBzIFsgbmFtZSBdKSB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzKVxuICAgICB8IGZhbHNlIC0+XG4gICAgICAgKG1hdGNoIDAgPD0gaSAmJiBpIDwgc2VlbiB3aXRoXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgICgqIGZpZWxkIHNlZW4gaW4gZmFzdCBwYXRoICopXG4gICAgICAgICAgcGFyc2Vfc3BpbmVfbWFsZm9ybWVkIChEdXBzIFsgbmFtZSBdKSB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzXG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICAoKiBleHRyYSBmaWVsZCAqKVxuICAgICAgICAgIChtYXRjaCBleHRyYSB3aXRoXG4gICAgICAgICAgIHwgdHJ1ZSAtPiBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHNcbiAgICAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgICAgIHBhcnNlX3NwaW5lX21hbGZvcm1lZCAoRXh0cmFzIFsgbmFtZSBdKSB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzKSkpXG4gIHwgc2V4cCA6OiBzZXhwcyAtPlxuICAgIHBhcnNlX3NwaW5lX21hbGZvcm1lZCAoTm9uX3BhaXIgKFNvbWUgc2V4cCkpIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHNcbjs7XG5cbigqIFNsb3cgcGF0aCBmb3IgcmVjb3JkIHBhcnNpbmcuIFVzZXMgc3RhdGUgdG8gc3RvcmUgZmllbGRzIGFzIHRoZXkgYXJlIGRpc2NvdmVyZWQuICopXG5cbmxldCBwYXJzZV9yZWNvcmRfc2xvdyB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHMgPVxuICBsZXQgdW5zZWVuID0gRmllbGRzLmxlbmd0aCBmaWVsZHMgaW5cbiAgbGV0IHN0YXRlID0gU3RhdGUuY3JlYXRlIHVuc2VlbiBpblxuICBsZXQgbGVuID0gc2VlbiArIHVuc2VlbiBpblxuICAoKiBwb3B1bGF0ZSBzdGF0ZSAqKVxuICBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHM7XG4gICgqIHBhcnNlIHZhbHVlcyBmcm9tIHN0YXRlICopXG4gIHBhcnNlX3ZhbHVlcyB+ZmllbGRzIH5zdGF0ZSB+cG9zOjBcbjs7XG5cbigqIEZhc3QgcGF0aCBmb3IgcmVjb3JkIHBhcnNpbmcuIERpcmVjdGx5IHBhcnNlcyBhbmQgcmV0dXJucyBmaWVsZHMgaW4gdGhlIG9yZGVyIHRoZXkgYXJlXG4gICBkZWNsYXJlZC4gRmFsbHMgYmFjayBvbiBzbG93IHBhdGggaWYgYW55IGZpZWxkcyBhcmUgYWJzZW50LCByZW9yZGVyZWQsIG9yIG1hbGZvcm1lZC4gKilcblxubGV0IHJlYyBwYXJzZV9maWVsZF9mYXN0XG4gIDogdHlwZSBhIGIuXG4gICAgZmllbGRzOihhICogYikgRmllbGRzLnRcbiAgICAtPiBpbmRleDooc3RyaW5nIC0+IGludClcbiAgICAtPiBleHRyYTpib29sXG4gICAgLT4gc2VlbjppbnRcbiAgICAtPiBTZXhwLnQgbGlzdFxuICAgIC0+IGEgKiBiXG4gID1cbiAgZnVuIH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwcyAtPlxuICBsZXQgKEZpZWxkIHsgbmFtZTsga2luZDsgY29udjsgcmVzdCB9KSA9IGZpZWxkcyBpblxuICBtYXRjaCBzZXhwcyB3aXRoXG4gIHwgTGlzdCAoQXRvbSBhdG9tIDo6IGFyZ3MpIDo6IG90aGVycyB3aGVuIFN0cmluZy5lcXVhbCBhdG9tIG5hbWUgLT5cbiAgICAobWF0Y2gga2luZCwgYXJncyB3aXRoXG4gICAgIHwgUmVxdWlyZWQsIFsgc2V4cCBdIC0+XG4gICAgICAgY29udiBzZXhwLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzXG4gICAgIHwgRGVmYXVsdCBfLCBbIHNleHAgXSAtPlxuICAgICAgIGNvbnYgc2V4cCwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVyc1xuICAgICB8IE9taXRfbmlsLCBbIHNleHAgXSAtPlxuICAgICAgIGNvbnYgc2V4cCwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVyc1xuICAgICB8IFNleHBfb3B0aW9uLCBbIHNleHAgXSAtPlxuICAgICAgICggU29tZSAoY29udiBzZXhwKVxuICAgICAgICwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVycyApXG4gICAgIHwgU2V4cF9saXN0LCBbIHNleHAgXSAtPlxuICAgICAgICggbGlzdF9vZl9zZXhwIGNvbnYgc2V4cFxuICAgICAgICwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVycyApXG4gICAgIHwgU2V4cF9hcnJheSwgWyBzZXhwIF0gLT5cbiAgICAgICAoIGFycmF5X29mX3NleHAgY29udiBzZXhwXG4gICAgICAgLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzIClcbiAgICAgfCBTZXhwX2Jvb2wsIFtdIC0+XG4gICAgICAgdHJ1ZSwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVyc1xuICAgICAoKiBtYWxmb3JtZWQgZmllbGQgb2Ygc29tZSBraW5kLCBkaXNwYXRjaCB0byBzbG93IHBhdGggKilcbiAgICAgfCBfLCBfIC0+IHBhcnNlX3JlY29yZF9zbG93IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwcylcbiAgKCogbWFsZm9ybWVkIG9yIG91dC1vZi1vcmRlciBmaWVsZCwgZGlzcGF0Y2ggdG8gc2xvdyBwYXRoICopXG4gIHwgXyAtPiBwYXJzZV9yZWNvcmRfc2xvdyB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHNcblxuYW5kIHBhcnNlX3NwaW5lX2Zhc3RcbiAgOiB0eXBlIGEuXG4gICAgZmllbGRzOmEgRmllbGRzLnRcbiAgICAtPiBpbmRleDooc3RyaW5nIC0+IGludClcbiAgICAtPiBleHRyYTpib29sXG4gICAgLT4gc2VlbjppbnRcbiAgICAtPiBTZXhwLnQgbGlzdFxuICAgIC0+IGFcbiAgPVxuICBmdW4gfmZpZWxkcyB+aW5kZXggfmV4dHJhIH5zZWVuIHNleHBzIC0+XG4gIG1hdGNoIGZpZWxkcyB3aXRoXG4gIHwgRmllbGQgXyAtPiBwYXJzZV9maWVsZF9mYXN0IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwc1xuICB8IEVtcHR5IC0+XG4gICAgKG1hdGNoIHNleHBzIHdpdGhcbiAgICAgfCBbXSAtPiAoKVxuICAgICB8IF8gOjogXyAtPlxuICAgICAgICgqIGV4dHJhIHNleHBzLCBkaXNwYXRjaCB0byBzbG93IHBhdGggKilcbiAgICAgICBwYXJzZV9yZWNvcmRfc2xvdyB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHMpXG47O1xuXG5sZXQgcGFyc2VfcmVjb3JkX2Zhc3QgfmZpZWxkcyB+aW5kZXggfmV4dHJhIHNleHBzID1cbiAgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW46MCBzZXhwc1xuOztcblxuKCogRW50cnkgcG9pbnRzLiAqKVxuXG5sZXQgcmVjb3JkX29mX3NleHBzXG4gIH5jYWxsZXJcbiAgfmNvbnRleHRcbiAgfmZpZWxkc1xuICB+aW5kZXhfb2ZfZmllbGRcbiAgfmFsbG93X2V4dHJhX2ZpZWxkc1xuICB+Y3JlYXRlXG4gIHNleHBzXG4gID1cbiAgbGV0IGFsbG93X2V4dHJhX2ZpZWxkcyA9XG4gICAgYWxsb3dfZXh0cmFfZmllbGRzIHx8IG5vdCAhU2V4cF9jb252LnJlY29yZF9jaGVja19leHRyYV9maWVsZHNcbiAgaW5cbiAgbWF0Y2hcbiAgICBwYXJzZV9yZWNvcmRfZmFzdCB+ZmllbGRzIH5pbmRleDppbmRleF9vZl9maWVsZCB+ZXh0cmE6YWxsb3dfZXh0cmFfZmllbGRzIHNleHBzXG4gIHdpdGhcbiAgfCB2YWx1ZSAtPiBjcmVhdGUgdmFsdWVcbiAgfCBleGNlcHRpb24gTWFsZm9ybWVkIG1hbGZvcm1lZCAtPiBNYWxmb3JtZWQucmFpc2UgbWFsZm9ybWVkIH5jYWxsZXIgfmNvbnRleHRcbjs7XG5cbmxldCByZWNvcmRfb2Zfc2V4cCB+Y2FsbGVyIH5maWVsZHMgfmluZGV4X29mX2ZpZWxkIH5hbGxvd19leHRyYV9maWVsZHMgfmNyZWF0ZSBzZXhwID1cbiAgbWF0Y2ggKHNleHAgOiBTZXhwLnQpIHdpdGhcbiAgfCBBdG9tIF8gYXMgY29udGV4dCAtPiByZWNvcmRfbGlzdF9pbnN0ZWFkX2F0b20gY2FsbGVyIGNvbnRleHRcbiAgfCBMaXN0IHNleHBzIGFzIGNvbnRleHQgLT5cbiAgICByZWNvcmRfb2Zfc2V4cHNcbiAgICAgIH5jYWxsZXJcbiAgICAgIH5jb250ZXh0XG4gICAgICB+ZmllbGRzXG4gICAgICB+aW5kZXhfb2ZfZmllbGRcbiAgICAgIH5hbGxvd19leHRyYV9maWVsZHNcbiAgICAgIH5jcmVhdGVcbiAgICAgIHNleHBzXG47O1xuIl19
