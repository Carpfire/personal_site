// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Base__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base = [0], Base$0 = [0, Base];
   runtime.caml_register_global(0, Base$0, "Base__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool0
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Bool0 = [0];
   runtime.caml_register_global(0, Base_Bool0, "Base__Bool0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Globalize
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_dup = runtime.caml_obj_dup;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function globalize_bool(b){return b;}
   function globalize_char(c){return c;}
   function globalize_unit(u){return u;}
   function globalize_array(param, a){return a.slice();}
   function globalize_list(f, param){
    if(! param) return 0;
    var xs = param[2], x = param[1], _g_ = globalize_list(f, xs);
    return [0, caml_call1(f, x), _g_];
   }
   function globalize_option(f, param){
    if(! param) return 0;
    var x = param[1];
    return [0, caml_call1(f, x)];
   }
   function globalize_result(globalize_a, globalize_b, t){
    if(0 === t[0]){var a = t[1]; return [0, caml_call1(globalize_a, a)];}
    var b = t[1];
    return [1, caml_call1(globalize_b, b)];
   }
   function globalize_ref(param, r){return [0, r[1]];}
   function globalize_lazy_t(param, t){return t;}
   var
    _a_ = caml_obj_dup,
    _b_ = caml_obj_dup,
    _c_ = caml_obj_dup,
    _d_ = caml_obj_dup,
    _e_ = caml_obj_dup,
    Base_Globalize =
      [0,
       globalize_bool,
       globalize_char,
       caml_obj_dup,
       function(_f_){return _f_;},
       _e_,
       _d_,
       _c_,
       _b_,
       _a_,
       globalize_unit,
       globalize_array,
       globalize_lazy_t,
       globalize_list,
       globalize_option,
       globalize_result,
       globalize_ref];
   runtime.caml_register_global(0, Base_Globalize, "Base__Globalize");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Poly0
//# unitInfo: Requires: Base__Bool0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_compare = runtime.caml_compare;
   function descending(x, y){return caml_compare(y, x);}
   function max(x, y){
    return runtime.caml_csel_value(runtime.caml_greaterequal(x, y), x, y);
   }
   function min(x, y){
    return runtime.caml_csel_value(runtime.caml_lessequal(x, y), x, y);
   }
   var Base_Poly0 = [0, caml_compare, descending, min, max];
   runtime.caml_register_global(0, Base_Poly0, "Base__Poly0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import0
//# unitInfo: Requires: Base__Bool0, Base__Poly0, Shadow_stdlib, Stdlib, Stdlib__MoreLabels, Stdlib__StdLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_compare = runtime.caml_bytes_compare,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_bytes_greaterequal = runtime.caml_bytes_greaterequal,
    caml_bytes_lessequal = runtime.caml_bytes_lessequal,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int_compare = runtime.caml_int_compare,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_notequal = runtime.caml_notequal,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_greaterequal = runtime.caml_string_greaterequal,
    caml_string_lessequal = runtime.caml_string_lessequal;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Poly0 = global_data.Base__Poly0,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Stdlib = global_data.Stdlib,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Exit = Shadow_stdlib[3],
    Not_found = Shadow_stdlib[4],
    max_int = Shadow_stdlib[8],
    min_int = Shadow_stdlib[9],
    infinity = Shadow_stdlib[11],
    neg_infinity = Shadow_stdlib[12],
    nan = Shadow_stdlib[13],
    max_float = Shadow_stdlib[14],
    min_float = Shadow_stdlib[15],
    epsilon_float = Shadow_stdlib[16],
    char_of_int = Shadow_stdlib[18],
    string_of_bool = Shadow_stdlib[19],
    bool_of_string_opt = Shadow_stdlib[20],
    bool_of_string = Shadow_stdlib[21],
    string_of_int = Shadow_stdlib[22],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_float = Shadow_stdlib[24],
    float_of_string_opt = Shadow_stdlib[25],
    stdin = Shadow_stdlib[27],
    stdout = Shadow_stdlib[28],
    stderr = Shadow_stdlib[29],
    print_char = Shadow_stdlib[30],
    print_string = Shadow_stdlib[31],
    print_bytes = Shadow_stdlib[32],
    print_int = Shadow_stdlib[33],
    print_float = Shadow_stdlib[34],
    print_endline = Shadow_stdlib[35],
    print_newline = Shadow_stdlib[36],
    prerr_char = Shadow_stdlib[37],
    prerr_string = Shadow_stdlib[38],
    prerr_bytes = Shadow_stdlib[39],
    prerr_int = Shadow_stdlib[40],
    prerr_float = Shadow_stdlib[41],
    prerr_endline = Shadow_stdlib[42],
    prerr_newline = Shadow_stdlib[43],
    read_line = Shadow_stdlib[44],
    read_int_opt = Shadow_stdlib[45],
    read_int = Shadow_stdlib[46],
    read_float_opt = Shadow_stdlib[47],
    read_float = Shadow_stdlib[48],
    open_out = Shadow_stdlib[49],
    open_out_bin = Shadow_stdlib[50],
    open_out_gen = Shadow_stdlib[51],
    flush = Shadow_stdlib[52],
    flush_all = Shadow_stdlib[53],
    output_char = Shadow_stdlib[54],
    output_string = Shadow_stdlib[55],
    output_bytes = Shadow_stdlib[56],
    output = Shadow_stdlib[57],
    output_substring = Shadow_stdlib[58],
    output_byte = Shadow_stdlib[59],
    output_binary_int = Shadow_stdlib[60],
    output_value = Shadow_stdlib[61],
    seek_out = Shadow_stdlib[62],
    pos_out = Shadow_stdlib[63],
    out_channel_length = Shadow_stdlib[64],
    close_out = Shadow_stdlib[65],
    close_out_noerr = Shadow_stdlib[66],
    set_binary_mode_out = Shadow_stdlib[67],
    open_in = Shadow_stdlib[68],
    open_in_bin = Shadow_stdlib[69],
    open_in_gen = Shadow_stdlib[70],
    input_char = Shadow_stdlib[71],
    input_line = Shadow_stdlib[72],
    input = Shadow_stdlib[73],
    really_input = Shadow_stdlib[74],
    really_input_string = Shadow_stdlib[75],
    input_byte = Shadow_stdlib[76],
    input_binary_int = Shadow_stdlib[77],
    input_value = Shadow_stdlib[78],
    seek_in = Shadow_stdlib[79],
    pos_in = Shadow_stdlib[80],
    in_channel_length = Shadow_stdlib[81],
    close_in = Shadow_stdlib[82],
    close_in_noerr = Shadow_stdlib[83],
    set_binary_mode_in = Shadow_stdlib[84],
    string_of_format = Shadow_stdlib[85],
    symbol = Shadow_stdlib[86],
    exit = Shadow_stdlib[87],
    at_exit = Shadow_stdlib[88],
    valid_float_lexem = Shadow_stdlib[89],
    unsafe_really_input = Shadow_stdlib[90],
    do_at_exit = Shadow_stdlib[91],
    do_domain_local_at_exit = Shadow_stdlib[92],
    invalid_arg = Stdlib[1],
    failwith = Stdlib[2],
    Exit$0 = Stdlib[3],
    Match_failure = Stdlib[4],
    Assert_failure = Stdlib[5],
    Invalid_argument = Stdlib[6],
    Failure = Stdlib[7],
    Not_found$0 = Stdlib[8],
    Out_of_memory = Stdlib[9],
    Stack_overflow = Stdlib[10],
    Sys_error = Stdlib[11],
    End_of_file = Stdlib[12],
    Division_by_zero = Stdlib[13],
    Sys_blocked_io = Stdlib[14],
    Undefined_recursive_module = Stdlib[15],
    min = Stdlib[16],
    max = Stdlib[17],
    abs = Stdlib[18],
    max_int$0 = Stdlib[19],
    min_int$0 = Stdlib[20],
    lnot = Stdlib[21],
    infinity$0 = Stdlib[22],
    neg_infinity$0 = Stdlib[23],
    nan$0 = Stdlib[24],
    max_float$0 = Stdlib[25],
    min_float$0 = Stdlib[26],
    epsilon_float$0 = Stdlib[27],
    symbol$0 = Stdlib[28],
    char_of_int$0 = Stdlib[29],
    string_of_bool$0 = Stdlib[30],
    bool_of_string_opt$0 = Stdlib[31],
    bool_of_string$0 = Stdlib[32],
    string_of_int$0 = Stdlib[33],
    int_of_string_opt$0 = Stdlib[34],
    string_of_float$0 = Stdlib[35],
    float_of_string_opt$0 = Stdlib[36],
    symbol$1 = Stdlib[37],
    stdin$0 = Stdlib[38],
    stdout$0 = Stdlib[39],
    stderr$0 = Stdlib[40],
    print_char$0 = Stdlib[41],
    print_string$0 = Stdlib[42],
    print_bytes$0 = Stdlib[43],
    print_int$0 = Stdlib[44],
    print_float$0 = Stdlib[45],
    print_endline$0 = Stdlib[46],
    print_newline$0 = Stdlib[47],
    prerr_char$0 = Stdlib[48],
    prerr_string$0 = Stdlib[49],
    prerr_bytes$0 = Stdlib[50],
    prerr_int$0 = Stdlib[51],
    prerr_float$0 = Stdlib[52],
    prerr_endline$0 = Stdlib[53],
    prerr_newline$0 = Stdlib[54],
    read_line$0 = Stdlib[55],
    read_int_opt$0 = Stdlib[56],
    read_int$0 = Stdlib[57],
    read_float_opt$0 = Stdlib[58],
    read_float$0 = Stdlib[59],
    open_out$0 = Stdlib[60],
    open_out_bin$0 = Stdlib[61],
    open_out_gen$0 = Stdlib[62],
    flush$0 = Stdlib[63],
    flush_all$0 = Stdlib[64],
    output_char$0 = Stdlib[65],
    output_string$0 = Stdlib[66],
    output_bytes$0 = Stdlib[67],
    output$0 = Stdlib[68],
    output_substring$0 = Stdlib[69],
    output_byte$0 = Stdlib[70],
    output_binary_int$0 = Stdlib[71],
    output_value$0 = Stdlib[72],
    seek_out$0 = Stdlib[73],
    pos_out$0 = Stdlib[74],
    out_channel_length$0 = Stdlib[75],
    close_out$0 = Stdlib[76],
    close_out_noerr$0 = Stdlib[77],
    set_binary_mode_out$0 = Stdlib[78],
    open_in$0 = Stdlib[79],
    open_in_bin$0 = Stdlib[80],
    open_in_gen$0 = Stdlib[81],
    input_char$0 = Stdlib[82],
    input_line$0 = Stdlib[83],
    input$0 = Stdlib[84],
    really_input$0 = Stdlib[85],
    really_input_string$0 = Stdlib[86],
    input_byte$0 = Stdlib[87],
    input_binary_int$0 = Stdlib[88],
    input_value$0 = Stdlib[89],
    seek_in$0 = Stdlib[90],
    pos_in$0 = Stdlib[91],
    in_channel_length$0 = Stdlib[92],
    close_in$0 = Stdlib[93],
    close_in_noerr$0 = Stdlib[94],
    set_binary_mode_in$0 = Stdlib[95],
    LargeFile = Stdlib[96],
    string_of_format$0 = Stdlib[97],
    symbol$2 = Stdlib[98],
    exit$0 = Stdlib[99],
    at_exit$0 = Stdlib[100],
    valid_float_lexem$0 = Stdlib[101],
    unsafe_really_input$0 = Stdlib[102],
    do_at_exit$0 = Stdlib[103],
    do_domain_local_at_exit$0 = Stdlib[104],
    Hashtbl = Stdlib_MoreLabels[1],
    Map = Stdlib_MoreLabels[2],
    Set = Stdlib_MoreLabels[3],
    Stdlib$0 =
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found$0,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int$0,
       min_int$0,
       lnot,
       infinity$0,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       symbol$0,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string_opt$0,
       bool_of_string$0,
       string_of_int$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string_opt$0,
       symbol$1,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int_opt$0,
       read_int$0,
       read_float_opt$0,
       read_float$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$0,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$0,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile,
       string_of_format$0,
       symbol$2,
       exit$0,
       at_exit$0,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       do_domain_local_at_exit$0,
       Hashtbl,
       Map,
       Set];
   function bool_to_int(x){return x;}
   function symbol$3(_F_, _E_){return _F_ !== _E_ ? 1 : 0;}
   var symbol$4 = runtime.caml_mul;
   function symbol$5(_D_, _C_){return Math.pow(_D_, _C_);}
   function symbol$6(_B_, _A_){return _B_ * _A_;}
   function symbol$7(_z_, _y_){return _z_ + _y_ | 0;}
   function symbol$8(_x_, _w_){return _x_ + _w_;}
   function symbol$9(_v_, _u_){return _v_ - _u_ | 0;}
   function symbol$10(_t_, _s_){return _t_ - _s_;}
   var symbol$11 = runtime.caml_div;
   function symbol$12(_r_, _q_){return _r_ / _q_;}
   var ascending = caml_int_compare;
   function descending(x, y){return caml_int_compare(y, x);}
   function max$0(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$0(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Int_replace_polymorphic_compar = [0, ascending, descending, max$0, min$0],
    ascending$0 = Int_replace_polymorphic_compar[1],
    descending$0 = Int_replace_polymorphic_compar[2],
    max$1 = Int_replace_polymorphic_compar[3],
    min$1 = Int_replace_polymorphic_compar[4],
    symbol$13 = caml_lessthan,
    symbol$14 = caml_lessequal,
    symbol$15 = caml_notequal,
    symbol$16 = caml_equal,
    symbol$17 = caml_greaterthan,
    symbol$18 = caml_greaterequal;
   function ascending$1(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$1(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var
    compare = caml_int_compare,
    compare_local = caml_int_compare,
    equal = caml_equal,
    equal_local = caml_equal;
   function max$2(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$2(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Int32_replace_polymorphic_comp =
      [0,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       ascending$1,
       descending$1,
       compare,
       compare_local,
       equal,
       equal_local,
       max$2,
       min$2];
   function ascending$2(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$2(x, y){return caml_call2(Base_Poly0[2], x, y);}
   function max$3(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$3(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Int64_replace_polymorphic_comp =
      [0, ascending$2, descending$2, max$3, min$3],
    symbol$19 = caml_lessthan,
    symbol$20 = caml_lessequal,
    symbol$21 = caml_notequal,
    symbol$22 = caml_equal,
    symbol$23 = caml_greaterthan,
    symbol$24 = caml_greaterequal;
   function ascending$3(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$3(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var
    compare$0 = caml_int_compare,
    compare_local$0 = caml_int_compare,
    equal$0 = caml_equal,
    equal_local$0 = caml_equal;
   function max$4(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$4(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Nativeint_replace_polymorphic_ =
      [0,
       symbol$19,
       symbol$20,
       symbol$21,
       symbol$22,
       symbol$23,
       symbol$24,
       ascending$3,
       descending$3,
       compare$0,
       compare_local$0,
       equal$0,
       equal_local$0,
       max$4,
       min$4];
   function symbol$25(x, y){return x < y ? 1 : 0;}
   function symbol$26(x, y){return x <= y ? 1 : 0;}
   function symbol$27(x, y){return x !== y ? 1 : 0;}
   function symbol$28(x, y){return x === y ? 1 : 0;}
   function symbol$29(x, y){return y < x ? 1 : 0;}
   function symbol$30(x, y){return y <= x ? 1 : 0;}
   function ascending$4(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$4(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$1 = caml_int_compare, compare_local$1 = caml_int_compare;
   function equal$1(x, y){return x === y ? 1 : 0;}
   function equal_local$1(x, y){return x === y ? 1 : 0;}
   function max$5(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$5(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Bool_replace_polymorphic_compa =
      [0,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol$30,
       ascending$4,
       descending$4,
       compare$1,
       compare_local$1,
       equal$1,
       equal_local$1,
       max$5,
       min$5];
   function symbol$31(x, y){return x < y ? 1 : 0;}
   function symbol$32(x, y){return x <= y ? 1 : 0;}
   function symbol$33(x, y){return x !== y ? 1 : 0;}
   function symbol$34(x, y){return x === y ? 1 : 0;}
   function symbol$35(x, y){return y < x ? 1 : 0;}
   function symbol$36(x, y){return y <= x ? 1 : 0;}
   function ascending$5(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$5(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$2 = caml_int_compare, compare_local$2 = caml_int_compare;
   function equal$2(x, y){return x === y ? 1 : 0;}
   function equal_local$2(x, y){return x === y ? 1 : 0;}
   function max$6(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$6(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Char_replace_polymorphic_compa =
      [0,
       symbol$31,
       symbol$32,
       symbol$33,
       symbol$34,
       symbol$35,
       symbol$36,
       ascending$5,
       descending$5,
       compare$2,
       compare_local$2,
       equal$2,
       equal_local$2,
       max$6,
       min$6];
   function symbol$37(x, y){return x < y ? 1 : 0;}
   function symbol$38(x, y){return x <= y ? 1 : 0;}
   function symbol$39(x, y){return x !== y ? 1 : 0;}
   function symbol$40(x, y){return x === y ? 1 : 0;}
   function symbol$41(x, y){return y < x ? 1 : 0;}
   function symbol$42(x, y){return y <= x ? 1 : 0;}
   function ascending$6(x, y){
    return caml_call2(Int_replace_polymorphic_compar[1], x, y);
   }
   function descending$6(x, y){
    return caml_call2(Int_replace_polymorphic_compar[2], x, y);
   }
   var compare$3 = caml_int_compare;
   function equal$3(x, y){return x === y ? 1 : 0;}
   var compare_local$3 = caml_int_compare;
   function equal_local$3(x, y){return x === y ? 1 : 0;}
   function max$7(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$7(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Uchar_replace_polymorphic_comp =
      [0,
       symbol$37,
       symbol$38,
       symbol$39,
       symbol$40,
       symbol$41,
       symbol$42,
       ascending$6,
       descending$6,
       compare$3,
       equal$3,
       compare_local$3,
       equal_local$3,
       max$7,
       min$7];
   function ascending$7(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$7(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare_local$4 = runtime.caml_float_compare;
   function equal_local$4(x, y){return x == y ? 1 : 0;}
   function max$8(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$8(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Float_replace_polymorphic_comp =
      [0,
       ascending$7,
       descending$7,
       compare_local$4,
       equal_local$4,
       max$8,
       min$8],
    symbol$43 = runtime.caml_string_lessthan,
    symbol$44 = caml_string_lessequal,
    symbol$45 = runtime.caml_string_notequal,
    symbol$46 = caml_string_equal,
    symbol$47 = runtime.caml_string_greaterthan,
    symbol$48 = caml_string_greaterequal;
   function ascending$8(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$8(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var
    compare$4 = caml_string_compare,
    compare_local$5 = caml_string_compare,
    equal$4 = caml_string_equal,
    equal_local$5 = caml_string_equal;
   function max$9(x, y){
    return runtime.caml_csel_value(caml_string_greaterequal(x, y), x, y);
   }
   function min$9(x, y){
    return runtime.caml_csel_value(caml_string_lessequal(x, y), x, y);
   }
   var
    String_replace_polymorphic_com =
      [0,
       symbol$43,
       symbol$44,
       symbol$45,
       symbol$46,
       symbol$47,
       symbol$48,
       ascending$8,
       descending$8,
       compare$4,
       compare_local$5,
       equal$4,
       equal_local$5,
       max$9,
       min$9],
    symbol$49 = runtime.caml_bytes_lessthan,
    symbol$50 = caml_bytes_lessequal,
    symbol$51 = runtime.caml_bytes_notequal,
    symbol$52 = caml_bytes_equal,
    symbol$53 = runtime.caml_bytes_greaterthan,
    symbol$54 = caml_bytes_greaterequal;
   function ascending$9(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$9(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var
    compare$5 = caml_bytes_compare,
    compare_local$6 = caml_bytes_compare,
    equal$5 = caml_bytes_equal,
    equal_local$6 = caml_bytes_equal;
   function max$10(x, y){
    return runtime.caml_csel_value(caml_bytes_greaterequal(x, y), x, y);
   }
   function min$10(x, y){
    return runtime.caml_csel_value(caml_bytes_lessequal(x, y), x, y);
   }
   var
    Bytes_replace_polymorphic_comp =
      [0,
       symbol$49,
       symbol$50,
       symbol$51,
       symbol$52,
       symbol$53,
       symbol$54,
       ascending$9,
       descending$9,
       compare$5,
       compare_local$6,
       equal$5,
       equal_local$6,
       max$10,
       min$10],
    symbol$55 = Stdlib$0[37],
    symbol$56 = Stdlib$0[28];
   function symbol$57(_p_){return - _p_ | 0;}
   function symbol$58(_o_){return - _o_;}
   function asr(_n_, _m_){return _n_ >> _m_;}
   function land(_l_, _k_){return _l_ & _k_;}
   var lnot$0 = Stdlib$0[21];
   function lor(_j_, _i_){return _j_ | _i_;}
   function lsl(_h_, _g_){return _h_ << _g_;}
   function lsr(_f_, _e_){return _f_ >>> _e_ | 0;}
   function lxor(_d_, _c_){return _d_ ^ _c_;}
   var mod = runtime.caml_mod, abs$0 = Stdlib$0[18], failwith$0 = Stdlib$0[2];
   function fst(_b_){return _b_[1];}
   var invalid_arg$0 = Stdlib$0[1];
   function snd(_a_){return _a_[2];}
   var
    float_of_string = runtime.caml_float_of_string,
    am_testing = runtime.Base_am_testing(0),
    Base_Import0 =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Stdlib$0,
       bool_to_int,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       Int_replace_polymorphic_compar,
       ascending$0,
       descending$0,
       max$1,
       min$1,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$55,
       symbol$56,
       symbol$57,
       symbol$58,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       fst,
       invalid_arg$0,
       snd,
       float_of_string,
       am_testing];
   runtime.caml_register_global(4, Base_Import0, "Base__Import0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int0
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    to_string = Stdlib[33],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib[34];
   function to_float(_d_){return _d_;}
   function of_float(_c_){return _c_ | 0;}
   var max_value = Stdlib[19], min_value = Stdlib[20];
   function succ(_b_){return _b_ + 1 | 0;}
   function pred(_a_){return _a_ - 1 | 0;}
   var
    Base_Int0 =
      [0,
       to_string,
       of_string,
       of_string_opt,
       to_float,
       of_float,
       max_value,
       min_value,
       succ,
       pred];
   runtime.caml_register_global(1, Base_Int0, "Base__Int0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Printf
//# unitInfo: Requires: Base__Import0, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_Printf = global_data.Stdlib__Printf,
    sprintf = Stdlib_Printf[4],
    bprintf = Stdlib_Printf[5],
    ifprintf = Stdlib_Printf[6],
    ksprintf = Stdlib_Printf[10],
    kbprintf = Stdlib_Printf[11];
   function failwithf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[124], s);},
             fmt);
   }
   function invalid_argf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[126], s);},
             fmt);
   }
   var
    Base_Printf =
      [0,
       ifprintf,
       sprintf,
       bprintf,
       ksprintf,
       kbprintf,
       failwithf,
       invalid_argf];
   runtime.caml_register_global(2, Base_Printf, "Base__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys0
//# unitInfo: Requires: Base__Import0, Base__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Sys = global_data.Stdlib__Sys,
    backend_type = Stdlib_Sys[5],
    interactive = Stdlib_Sys[3],
    os_type = Stdlib_Sys[4],
    unix = Stdlib_Sys[6],
    win32 = Stdlib_Sys[7],
    cygwin = Stdlib_Sys[8],
    word_size_in_bits = Stdlib_Sys[9],
    int_size_in_bits = Stdlib_Sys[10],
    big_endian = Stdlib_Sys[11],
    max_string_length = Stdlib_Sys[12],
    max_array_length = Stdlib_Sys[13],
    runtime_variant = runtime.caml_runtime_variant,
    runtime_parameters = runtime.caml_runtime_parameters,
    argv = caml_sys_argv(0),
    _a_ =
      [0,
       [11,
        "Sys.getenv_exn: environment variable ",
        [2, 0, [11, " is not set", 0]]],
       "Sys.getenv_exn: environment variable %s is not set"];
   function get_argv(param){return caml_sys_argv(0);}
   var
    ocaml_version = Stdlib_Sys[46],
    enable_runtime_warnings = Stdlib_Sys[49],
    runtime_warnings_enabled = Stdlib_Sys[50];
   function Make_immediate64(_h_, _g_){
    return caml_call1(caml_call1(Stdlib_Sys[51][1], _h_), _g_);
   }
   function getenv_exn(var$0){
    try{var _e_ = caml_sys_getenv(var$0); return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Base_Import0[85][8])
      return caml_call3(Base_Printf[6], _a_, var$0, 0);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function getenv(var$0){
    try{var x = caml_sys_getenv(var$0);}
    catch(_c_){
     var _b_ = caml_wrap_exception(_c_);
     if(_b_ === Base_Import0[85][8]) return 0;
     throw caml_maybe_attach_backtrace(_b_, 0);
    }
    return [0, x];
   }
   var
    Break = Stdlib_Sys[44],
    Base_Sys0 =
      [0,
       backend_type,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       argv,
       get_argv,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       Make_immediate64,
       getenv_exn,
       getenv,
       Break];
   runtime.caml_register_global(4, Base_Sys0, "Base__Sys0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array0
//# unitInfo: Requires: Base__Import0, Base__Int0, Base__Printf, Base__Sys0, Stdlib, Stdlib__ArrayLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ArrayLabels = global_data.Stdlib__ArrayLabels,
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0;
   global_data.Stdlib;
   var
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    invalid_argf = Base_Printf[7],
    Array = [0],
    max_length = Base_Sys0[11],
    cst_Array_init = "Array.init";
   function create(len, x){return caml_make_vect(len, x);}
   function create_local(len, x){return caml_make_vect(len, x);}
   function create_float_uninitialized(len){
    return runtime.caml_make_float_vect(len);
   }
   var
    append = Stdlib_ArrayLabels[3],
    blit = Stdlib_ArrayLabels[8],
    concat = Stdlib_ArrayLabels[4],
    copy = Stdlib_ArrayLabels[6],
    fill = Stdlib_ArrayLabels[7];
   function init(len, f){
    if(0 === len) return [0];
    if(0 > len) return caml_call1(Base_Import0[126], cst_Array_init);
    var
     res = caml_make_vect(len, caml_call1(f, 0)),
     _s_ = caml_call1(Base_Int0[9], len),
     _r_ = 1;
    if(_s_ >= 1){
     var i = _r_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _t_ = i + 1 | 0;
      if(_s_ === i) break;
      var i = _t_;
     }
    }
    return res;
   }
   var
    make_matrix = Stdlib_ArrayLabels[2],
    of_list = Stdlib_ArrayLabels[10],
    sub = Stdlib_ArrayLabels[5],
    to_list = Stdlib_ArrayLabels[9];
   function fold(t, init, f){
    var
     r = [0, init],
     _p_ = caml_call2(Base_Import0[93], t.length - 1, 1),
     _o_ = 0;
    if(_p_ >= 0){
     var i = _o_;
     for(;;){
      r[1] = caml_call2(f, r[1], t[1 + i]);
      var _q_ = i + 1 | 0;
      if(_p_ === i) break;
      var i = _q_;
     }
    }
    return r[1];
   }
   function fold_right(t, f, init){
    var r = [0, init], _m_ = caml_call2(Base_Import0[93], t.length - 1, 1);
    if(_m_ >= 0){
     var i = _m_;
     for(;;){
      r[1] = caml_call2(f, t[1 + i], r[1]);
      var _n_ = i - 1 | 0;
      if(0 === i) break;
      var i = _n_;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _k_ = caml_call2(Base_Import0[93], t.length - 1, 1), _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      caml_call1(f, t[1 + i]);
      var _l_ = i + 1 | 0;
      if(_k_ === i) break;
      var i = _l_;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var _h_ = caml_call2(Base_Import0[93], t.length - 1, 1), _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      caml_call2(f, i, t[1 + i]);
      var _i_ = i + 1 | 0;
      if(_h_ === i) break;
      var i = _i_;
     }
    }
    return 0;
   }
   function map(t, f){
    var len = t.length - 1;
    if(0 === len) return [0];
    var
     r = caml_make_vect(len, caml_call1(f, t[1])),
     _e_ = caml_call2(Base_Import0[93], len, 1),
     _d_ = 1;
    if(_e_ >= 1){
     var i = _d_;
     for(;;){
      r[1 + i] = caml_call1(f, t[1 + i]);
      var _f_ = i + 1 | 0;
      if(_e_ === i) break;
      var i = _f_;
     }
    }
    return r;
   }
   function mapi(t, f){
    var len = t.length - 1;
    if(0 === len) return [0];
    var
     r = caml_make_vect(len, caml_call2(f, 0, t[1])),
     _b_ = caml_call2(Base_Import0[93], len, 1),
     _a_ = 1;
    if(_b_ >= 1){
     var i = _a_;
     for(;;){
      r[1 + i] = caml_call2(f, i, t[1 + i]);
      var _c_ = i + 1 | 0;
      if(_b_ === i) break;
      var i = _c_;
     }
    }
    return r;
   }
   function stable_sort(t, compare){
    return caml_call2(Stdlib_ArrayLabels[35], compare, t);
   }
   function swap(t, i, j){
    var
     elt_i = caml_check_bound(t, i)[1 + i],
     elt_j = caml_check_bound(t, j)[1 + j];
    t[1 + i] = elt_j;
    t[1 + j] = elt_i;
    return 0;
   }
   var
    Base_Array0 =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap];
   runtime.caml_register_global(10, Base_Array0, "Base__Array0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char0
//# unitInfo: Requires: Base__Printf, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Printf = global_data.Base__Printf,
    Stdlib_Char = global_data.Stdlib__Char,
    failwithf = Base_Printf[6],
    escaped = Stdlib_Char[2],
    lowercase = Stdlib_Char[3],
    _a_ =
      [0,
       [11, "Char.of_int_exn got integer out of range: ", [4, 0, 0, 0, 0]],
       "Char.of_int_exn got integer out of range: %d"];
   function to_int(_e_){return _e_;}
   function unsafe_of_int(_d_){return _d_;}
   var uppercase = Stdlib_Char[4];
   function int_is_ok(i){
    var _b_ = 0 <= i ? 1 : 0, _c_ = _b_ ? i <= 255 ? 1 : 0 : _b_;
    return _c_;
   }
   var min_value = 0, max_value = 255;
   function of_int(i){return int_is_ok(i) ? [0, i] : 0;}
   function of_int_exn(i){
    return int_is_ok(i) ? i : caml_call3(failwithf, _a_, i, 0);
   }
   function equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var
    Base_Char0 =
      [0,
       failwithf,
       escaped,
       lowercase,
       to_int,
       unsafe_of_int,
       uppercase,
       int_is_ok,
       min_value,
       max_value,
       of_int,
       of_int_exn,
       equal];
   runtime.caml_register_global(3, Base_Char0, "Base__Char0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_intf = [0];
   runtime.caml_register_global(0, Base_Hash_intf, "Base__Hash_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List0
//# unitInfo: Requires: Base__Import0, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    hd_exn = Stdlib_ListLabels[6],
    rev_append = Stdlib_ListLabels[13],
    tl_exn = Stdlib_ListLabels[7],
    unzip = Stdlib_ListLabels[57],
    cst_List_exists2 = "List.exists2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_iter2 = "List.iter2",
    cst_List_rev_map2 = "List.rev_map2";
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var
      l = param[2],
      len$0 = caml_call2(Base_Import0[91], len, 1),
      len = len$0,
      param = l;
    }
   }
   function exists(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var xs = t$0[2], x = t$0[1];
     if(caml_call1(f, x)) return 1;
     var t$0 = xs;
    }
   }
   function exists2_ok(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _e_ = caml_call2(f, a1, a2);
       if(_e_) return _e_;
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Base_Import0[126], cst_List_exists2);
    }
   }
   function fold(t, init, f){
    var t$0 = t, init$0 = init;
    for(;;){
     if(! t$0) return init$0;
     var
      l = t$0[2],
      a = t$0[1],
      init$1 = caml_call2(f, init$0, a),
      t$0 = l,
      init$0 = init$1;
    }
   }
   function fold2_ok(l1, l2, init, f){
    var l1$0 = l1, l2$0 = l2, init$0 = init;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        init$1 = caml_call3(f, init$0, a1, a2),
        l1$0 = l1$1,
        l2$0 = l2$1,
        init$0 = init$1;
       continue;
      }
     }
     else if(! l2$0) return init$0;
     return caml_call1(Base_Import0[126], cst_List_fold_left2);
    }
   }
   function for_all(t, f){
    return 1 - exists(t, function(x){return 1 - caml_call1(f, x);});
   }
   function for_all2_ok(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _d_ = caml_call2(f, a1, a2);
       if(! _d_) return _d_;
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return caml_call1(Base_Import0[126], cst_List_for_all2);
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], a = t$0[1];
     caml_call1(f, a);
     var t$0 = l;
    }
   }
   function iter2_ok(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
       caml_call2(f, a1, a2);
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Base_Import0[126], cst_List_iter2);
    }
   }
   function nontail_map(t, f){
    if(! t) return 0;
    var xs = t[2], x = t[1], y = caml_call1(f, x);
    return [0, y, nontail_map(xs, f)];
   }
   function nontail_mapi(t, f){
    return caml_call2(Stdlib_ListLabels[21], f, t);
   }
   function partition(t, f){return caml_call2(Stdlib_ListLabels[47], f, t);}
   function rev_map(l$0, f){
    var accu = 0, param = l$0;
    for(;;){
     if(! param) return accu;
     var
      l = param[2],
      a = param[1],
      accu$0 = [0, caml_call1(f, a), accu],
      accu = accu$0,
      param = l;
    }
   }
   function rev_map2_ok(l1$1, l2$1, f){
    var accu = 0, l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu],
        accu = accu$0,
        l1 = l1$0,
        l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return accu;
     return caml_call1(Base_Import0[126], cst_List_rev_map2);
    }
   }
   function rev(res){
    if(res){
     var match = res[2];
     if(match){
      var rest = match[2], y = match[1], x = res[1];
      return caml_call2(rev_append, rest, [0, y, [0, x, 0]]);
     }
    }
    return res;
   }
   function fold_right(l, f, init){
    if(! l) return init;
    function _c_(a, b){return caml_call2(f, b, a);}
    return fold(rev(l), init, _c_);
   }
   function fold_right2_ok(l1, l2, f, init){
    if(! l1 && ! l2) return init;
    function _a_(a, b, c){return caml_call3(f, b, c, a);}
    var _b_ = rev(l2);
    return fold2_ok(rev(l1), _b_, init, _a_);
   }
   var
    Base_List0 =
      [0,
       hd_exn,
       rev_append,
       tl_exn,
       unzip,
       length,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       rev,
       fold_right,
       fold_right2_ok];
   runtime.caml_register_global(7, Base_List0, "Base__List0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash
//# unitInfo: Requires: Base__Char0, Base__Hash_intf, Base__Import0, Base__Int0, Base__List0, Base_internalhash_types, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    description = "internalhash",
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_List0 = global_data.Base__List0,
    Base_Char0 = global_data.Base__Char0;
   function Folding(Hash){
    function hash_fold_unit(s, param){return s;}
    var
     hash_fold_int = Hash[2],
     hash_fold_int64 = Hash[3],
     hash_fold_float = Hash[4],
     hash_fold_string = Hash[5];
    function as_int(f, s, x){
     return caml_call2(hash_fold_int, s, caml_call1(f, x));
    }
    function _Q_(_ar_){return _ar_;}
    function hash_fold_int32(_ap_, _aq_){return as_int(_Q_, _ap_, _aq_);}
    var _R_ = Base_Char0[4];
    function hash_fold_char(_an_, _ao_){return as_int(_R_, _an_, _ao_);}
    function _S_(param){return param ? 1 : 0;}
    function hash_fold_bool(_al_, _am_){return as_int(_S_, _al_, _am_);}
    function hash_fold_nativeint(s, x){
     return caml_call2(hash_fold_int64, s, runtime.caml_int64_of_int32(x));
    }
    function hash_fold_option(hash_fold_elem, s, param){
     if(! param) return caml_call2(hash_fold_int, s, 0);
     var x = param[1];
     return caml_call2(hash_fold_elem, caml_call2(hash_fold_int, s, 1), x);
    }
    function hash_fold_list(hash_fold_elem, s$1, list$1){
     var
      s$2 = caml_call2(hash_fold_int, s$1, caml_call1(Base_List0[5], list$1)),
      s = s$2,
      list = list$1;
     for(;;){
      if(! list) return s;
      var
       list$0 = list[2],
       x = list[1],
       s$0 = caml_call2(hash_fold_elem, s, x),
       s = s$0,
       list = list$0;
     }
    }
    function hash_fold_lazy_t(hash_fold_elem, s, x){
     var _aj_ = runtime.caml_obj_tag(x);
     a:
     if(250 === _aj_)
      var _ak_ = x[1];
     else{
      if(246 !== _aj_ && 244 !== _aj_){var _ak_ = x; break a;}
      var _ak_ = caml_call1(CamlinternalLazy[2], x);
     }
     return caml_call2(hash_fold_elem, s, _ak_);
    }
    function hash_fold_ref_frozen(hash_fold_elem, s, x){return caml_call2(hash_fold_elem, s, x[1]);
    }
    function hash_fold_array_frozen(hash_fold_elem, s$1, array){
     var
      s$2 = caml_call2(hash_fold_int, s$1, array.length - 1),
      s = s$2,
      i = 0;
     for(;;){
      if(i === array.length - 1) return s;
      var
       e = array[1 + i],
       i$0 = caml_call2(Base_Import0[91], i, 1),
       s$0 = caml_call2(hash_fold_elem, s, e),
       s = s$0,
       i = i$0;
     }
    }
    function hash_nativeint(x){
     var
      _ah_ = caml_call1(Hash[6], 0),
      _ai_ = hash_fold_nativeint(caml_call2(Hash[7], 0, _ah_), x);
     return caml_call1(Hash[8], _ai_);
    }
    function hash_int64(x){
     var
      _af_ = caml_call1(Hash[6], 0),
      _ag_ = caml_call2(hash_fold_int64, caml_call2(Hash[7], 0, _af_), x);
     return caml_call1(Hash[8], _ag_);
    }
    function hash_int32(x){
     var
      _ad_ = caml_call1(Hash[6], 0),
      _ae_ = hash_fold_int32(caml_call2(Hash[7], 0, _ad_), x);
     return caml_call1(Hash[8], _ae_);
    }
    function hash_char(x){
     var
      _ab_ = caml_call1(Hash[6], 0),
      _ac_ = hash_fold_char(caml_call2(Hash[7], 0, _ab_), x);
     return caml_call1(Hash[8], _ac_);
    }
    function hash_int(x){
     var
      _$_ = caml_call1(Hash[6], 0),
      _aa_ = caml_call2(hash_fold_int, caml_call2(Hash[7], 0, _$_), x);
     return caml_call1(Hash[8], _aa_);
    }
    function hash_bool(x){
     var
      _Z_ = caml_call1(Hash[6], 0),
      ___ = hash_fold_bool(caml_call2(Hash[7], 0, _Z_), x);
     return caml_call1(Hash[8], ___);
    }
    function hash_string(x){
     var
      _X_ = caml_call1(Hash[6], 0),
      _Y_ = caml_call2(hash_fold_string, caml_call2(Hash[7], 0, _X_), x);
     return caml_call1(Hash[8], _Y_);
    }
    function hash_float(x){
     var
      _V_ = caml_call1(Hash[6], 0),
      _W_ = caml_call2(hash_fold_float, caml_call2(Hash[7], 0, _V_), x);
     return caml_call1(Hash[8], _W_);
    }
    function hash_unit(x){
     var _T_ = caml_call1(Hash[6], 0), _U_ = caml_call2(Hash[7], 0, _T_);
     return caml_call1(Hash[8], _U_);
    }
    return [0,
            hash_fold_nativeint,
            hash_fold_int64,
            hash_fold_int32,
            hash_fold_char,
            hash_fold_int,
            hash_fold_bool,
            hash_fold_string,
            hash_fold_float,
            hash_fold_unit,
            hash_fold_option,
            hash_fold_list,
            hash_fold_lazy_t,
            hash_fold_ref_frozen,
            hash_fold_array_frozen,
            hash_nativeint,
            hash_int64,
            hash_int32,
            hash_char,
            hash_int,
            hash_bool,
            hash_string,
            hash_float,
            hash_unit];
   }
   function F(Hash){
    var
     description = Hash[1],
     fold_int = Hash[2],
     fold_int64 = Hash[3],
     fold_float = Hash[4],
     fold_string = Hash[5],
     alloc = Hash[6],
     reset = Hash[7],
     get_hash_value = Hash[8],
     For_tests = Hash[9];
    function create(seed, param){
     return caml_call2(reset, seed, caml_call1(alloc, 0));
    }
    function of_fold(hash_fold_t, t){
     return caml_call1
             (get_hash_value, caml_call2(hash_fold_t, create(0, 0), t));
    }
    var Builtin = Folding(Hash);
    function run(seed, folder, x){
     var
      _O_ = caml_call1(Hash[6], 0),
      _P_ = caml_call2(folder, caml_call2(Hash[7], seed, _O_), x);
     return caml_call1(Hash[8], _P_);
    }
    return [0,
            description,
            fold_int,
            fold_int64,
            fold_float,
            fold_string,
            alloc,
            reset,
            get_hash_value,
            For_tests,
            create,
            of_fold,
            Builtin,
            run];
   }
   function alloc(param){return 0;}
   function reset(opt, t){
    if(opt) var sth = opt[1], seed = sth; else var seed = 0;
    return seed;
   }
   var compare_state = runtime.caml_int_compare;
   function state_to_string(state){return caml_call1(Base_Int0[1], state);}
   var For_tests = [0, compare_state, state_to_string];
   function create(seed, param){return reset(seed, 0);}
   function run(seed, folder, x){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(folder, reset(seed, 0), x));
   }
   function of_fold(hash_fold_t, t){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(hash_fold_t, create(0, 0), t));
   }
   function _a_(_N_){return runtime.Base_internalhash_get_hash_value(_N_);}
   function _b_(_M_, _L_){
    return runtime.Base_internalhash_fold_string(_M_, _L_);
   }
   function _c_(_K_, _J_){
    return runtime.Base_internalhash_fold_float(_K_, _J_);
   }
   function _d_(_I_, _H_){
    return runtime.Base_internalhash_fold_int64(_I_, _H_);
   }
   var
    Folding$0 =
      Folding
       ([0,
         description,
         function(_G_, _F_){
          return runtime.Base_internalhash_fold_int(_G_, _F_);
         },
         _d_,
         _c_,
         _b_,
         alloc,
         reset,
         _a_,
         For_tests]),
    hash_fold_nativeint = Folding$0[1],
    hash_fold_int64 = Folding$0[2],
    hash_fold_int32 = Folding$0[3],
    hash_fold_char = Folding$0[4],
    hash_fold_int = Folding$0[5],
    hash_fold_bool = Folding$0[6],
    hash_fold_string = Folding$0[7],
    hash_fold_float = Folding$0[8],
    hash_fold_unit = Folding$0[9],
    hash_fold_option = Folding$0[10],
    hash_fold_list = Folding$0[11],
    hash_fold_lazy_t = Folding$0[12],
    hash_fold_ref_frozen = Folding$0[13],
    hash_fold_array_frozen = Folding$0[14],
    hash_nativeint = Folding$0[15],
    hash_int64 = Folding$0[16],
    hash_int32 = Folding$0[17],
    hash_string = Folding$0[21],
    hash_char = Base_Char0[4];
   function hash_int(t){
    var
     _t_ = caml_call2(Base_Import0[119], t, 21),
     _u_ = caml_call1(Base_Import0[117], t),
     t$0 = caml_call2(Base_Import0[91], _u_, _t_),
     _v_ = caml_call2(Base_Import0[120], t$0, 24),
     t$1 = caml_call2(Base_Import0[121], t$0, _v_),
     _w_ = caml_call2(Base_Import0[119], t$1, 8),
     _x_ = caml_call2(Base_Import0[119], t$1, 3),
     _y_ = caml_call2(Base_Import0[91], t$1, _x_),
     t$2 = caml_call2(Base_Import0[91], _y_, _w_),
     _z_ = caml_call2(Base_Import0[120], t$2, 14),
     t$3 = caml_call2(Base_Import0[121], t$2, _z_),
     _A_ = caml_call2(Base_Import0[119], t$3, 4),
     _B_ = caml_call2(Base_Import0[119], t$3, 2),
     _C_ = caml_call2(Base_Import0[91], t$3, _B_),
     t$4 = caml_call2(Base_Import0[91], _C_, _A_),
     _D_ = caml_call2(Base_Import0[120], t$4, 28),
     t$5 = caml_call2(Base_Import0[121], t$4, _D_),
     _E_ = caml_call2(Base_Import0[119], t$5, 31);
    return caml_call2(Base_Import0[91], t$5, _E_);
   }
   function hash_bool(x){return x ? 1 : 0;}
   function hash_unit(param){return 0;}
   var
    _e_ =
      [0,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       function(_s_){return runtime.Base_hash_double(_s_);},
       hash_unit];
   function _f_(_r_){return runtime.Base_internalhash_get_hash_value(_r_);}
   function _g_(_q_, _p_){
    return runtime.Base_internalhash_fold_string(_q_, _p_);
   }
   function _h_(_o_, _n_){
    return runtime.Base_internalhash_fold_float(_o_, _n_);
   }
   function _i_(_m_, _l_){
    return runtime.Base_internalhash_fold_int64(_m_, _l_);
   }
   var
    Base_Hash =
      [0,
       F,
       description,
       function(_k_, _j_){
        return runtime.Base_internalhash_fold_int(_k_, _j_);
       },
       _i_,
       _h_,
       _g_,
       alloc,
       reset,
       _f_,
       For_tests,
       create,
       of_fold,
       _e_,
       run];
   runtime.caml_register_global(6, Base_Hash, "Base__Hash");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_compare_lib
//# unitInfo: Requires: Base__Import0, Base__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_which_is_abstract_in_an_im =
      ", which is abstract in an implementation.",
    caml_bytes_compare = runtime.caml_bytes_compare,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_equal = runtime.caml_equal,
    caml_float_compare = runtime.caml_float_compare,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int_compare = runtime.caml_int_compare,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_equal = runtime.caml_string_equal;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    _b_ =
      [0,
       [11,
        "Equal called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Equal called on the type %s, which is abstract in an implementation."],
    _a_ =
      [0,
       [11,
        "Compare called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Compare called on the type %s, which is abstract in an implementation."];
   function compare_abstract(type_name, param, _F_){
    return caml_call3(Base_Printf[4], Base_Import0[124], _a_, type_name);
   }
   function equal_abstract(type_name, param, _E_){
    return caml_call3(Base_Printf[4], Base_Import0[124], _b_, type_name);
   }
   var
    Comparable = [0],
    Equal = [0],
    compare_bool = caml_int_compare,
    compare_bool_local = caml_int_compare,
    compare_char = caml_int_compare,
    compare_char_local = caml_int_compare,
    compare_float = caml_float_compare,
    compare_float_local = caml_float_compare,
    compare_int = caml_int_compare,
    compare_int_local = caml_int_compare,
    compare_int32 = caml_int_compare,
    compare_int32_local = caml_int_compare;
   function compare_int64(_D_, _C_){return caml_int64_compare(_D_, _C_);}
   function compare_int64_local(_B_, _A_){return caml_int64_compare(_B_, _A_);
   }
   var
    compare_nativeint = caml_int_compare,
    compare_nativeint_local = caml_int_compare,
    compare_string = caml_string_compare,
    compare_string_local = caml_string_compare,
    compare_bytes = caml_bytes_compare,
    compare_bytes_local = caml_bytes_compare,
    compare_unit = caml_int_compare,
    compare_unit_local = caml_int_compare;
   function compare_array_local(compare_elt, a, b){
    if(a === b) return 0;
    var
     len_a = a.length - 1,
     len_b = b.length - 1,
     ret = caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var l = a[1 + i], r = b[1 + i], res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import0[91], i, 1), i = i$0;
    }
   }
   function compare_array(compare_elt, a, b){
    return compare_array_local(compare_elt, a, b);
   }
   function compare_list(compare_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      res = caml_call2(compare_elt, x, y);
     if(0 !== res) return res;
     var a$0 = xs, b$0 = ys;
    }
   }
   function compare_list_local(compare_elt_local, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      res = caml_call2(compare_elt_local, x, y);
     if(0 !== res) return res;
     var a$0 = xs, b$0 = ys;
    }
   }
   function compare_option(compare_elt, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt, a$0, b$0);
   }
   function compare_option_local(compare_elt_local, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt_local, a$0, b$0);
   }
   function compare_ref(compare_elt, a, b){
    return caml_call2(compare_elt, a[1], b[1]);
   }
   function compare_ref_local(compare_elt, a, b){return caml_call2(compare_elt, a[1], b[1]);
   }
   function equal_bool(_z_, _y_){return _z_ === _y_ ? 1 : 0;}
   function equal_bool_local(_x_, _w_){return _x_ === _w_ ? 1 : 0;}
   function equal_char(_v_, _u_){return _v_ === _u_ ? 1 : 0;}
   function equal_char_local(_t_, _s_){return _t_ === _s_ ? 1 : 0;}
   function equal_int(_r_, _q_){return _r_ === _q_ ? 1 : 0;}
   function equal_int_local(_p_, _o_){return _p_ === _o_ ? 1 : 0;}
   var
    equal_int32 = caml_equal,
    equal_int32_local = caml_equal,
    equal_int64 = caml_equal,
    equal_int64_local = caml_equal,
    equal_nativeint = caml_equal,
    equal_nativeint_local = caml_equal,
    equal_string = caml_string_equal,
    equal_string_local = caml_string_equal,
    equal_bytes = caml_bytes_equal,
    equal_bytes_local = caml_bytes_equal;
   function equal_unit(_n_, _m_){return _n_ === _m_ ? 1 : 0;}
   function equal_unit_local(_l_, _k_){return _l_ === _k_ ? 1 : 0;}
   function equal_float(x, y){return caml_float_compare(x, y) === 0 ? 1 : 0;}
   function equal_float_local(x, y){
    return caml_float_compare(x, y) === 0 ? 1 : 0;
   }
   function equal_array_local(equal_elt, a, b){
    var _e_ = a === b ? 1 : 0;
    if(_e_)
     var _f_ = _e_;
    else{
     var
      len_a = a.length - 1,
      len_b = b.length - 1,
      _g_ = len_a === len_b ? 1 : 0;
     if(_g_){
      var i = 0;
      for(;;){
       var _h_ = i === len_a ? 1 : 0;
       if(_h_)
        var _i_ = _h_;
       else{
        var l = a[1 + i], r = b[1 + i], _j_ = caml_call2(equal_elt, l, r);
        if(_j_){
         var i$0 = caml_call2(Base_Import0[91], i, 1), i = i$0;
         continue;
        }
        var _i_ = _j_;
       }
       return _i_;
      }
     }
     var _f_ = _g_;
    }
    return _f_;
   }
   function equal_array(equal_elt, a, b){
    return equal_array_local(equal_elt, a, b);
   }
   function equal_list(equal_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(a$0){
      if(b$0){
       var
        ys = b$0[2],
        y = b$0[1],
        xs = a$0[2],
        x = a$0[1],
        _d_ = caml_call2(equal_elt, x, y);
       if(! _d_) return _d_;
       var a$0 = xs, b$0 = ys;
       continue;
      }
     }
     else if(! b$0) return 1;
     return 0;
    }
   }
   function equal_list_local(equal_elt_local, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(a$0){
      if(b$0){
       var
        ys = b$0[2],
        y = b$0[1],
        xs = a$0[2],
        x = a$0[1],
        _c_ = caml_call2(equal_elt_local, x, y);
       if(! _c_) return _c_;
       var a$0 = xs, b$0 = ys;
       continue;
      }
     }
     else if(! b$0) return 1;
     return 0;
    }
   }
   function equal_option(equal_elt, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_option_local(equal_elt_local, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt_local, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_ref(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   function equal_ref_local(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   var
    Base_Ppx_compare_lib =
      [0,
       compare_abstract,
       equal_abstract,
       Comparable,
       Equal,
       [0,
        compare_bool,
        compare_char,
        compare_float,
        compare_int,
        compare_int32,
        compare_int64,
        compare_nativeint,
        compare_string,
        compare_bytes,
        compare_unit,
        compare_array,
        compare_list,
        compare_option,
        compare_ref,
        equal_bool,
        equal_char,
        equal_float,
        equal_int,
        equal_int32,
        equal_int64,
        equal_nativeint,
        equal_string,
        equal_bytes,
        equal_unit,
        equal_array,
        equal_list,
        equal_option,
        equal_ref,
        compare_bool_local,
        compare_char_local,
        compare_float_local,
        compare_int_local,
        compare_int32_local,
        compare_int64_local,
        compare_nativeint_local,
        compare_string_local,
        compare_bytes_local,
        compare_unit_local,
        compare_array_local,
        compare_list_local,
        compare_option_local,
        compare_ref_local,
        equal_bool_local,
        equal_char_local,
        equal_float_local,
        equal_int_local,
        equal_int32_local,
        equal_int64_local,
        equal_nativeint_local,
        equal_string_local,
        equal_bytes_local,
        equal_unit_local,
        equal_array_local,
        equal_list_local,
        equal_option_local,
        equal_ref_local]];
   runtime.caml_register_global
    (4, Base_Ppx_compare_lib, "Base__Ppx_compare_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_hash_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Std = [0],
    Hashable = [0],
    Base_Ppx_hash_lib = [0, Std, Hashable];
   runtime.caml_register_global(0, Base_Ppx_hash_lib, "Base__Ppx_hash_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp
//# unitInfo: Requires: Base__Globalize, Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Globalize = global_data.Base__Globalize,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    t_of_sexp = Sexplib0_Sexp[1],
    sexp_of_t = Sexplib0_Sexp[2],
    equal = Sexplib0_Sexp[3],
    Not_found_s = Sexplib0_Sexp[5],
    Of_sexp_error = Sexplib0_Sexp[6],
    message = Sexplib0_Sexp[7],
    default_indent = Sexplib0_Sexp[8],
    pp_hum = Sexplib0_Sexp[9],
    pp_hum_indent = Sexplib0_Sexp[10],
    pp_mach = Sexplib0_Sexp[11],
    pp = Sexplib0_Sexp[12],
    to_string_hum = Sexplib0_Sexp[13],
    to_string_mach = Sexplib0_Sexp[14],
    to_string = Sexplib0_Sexp[15],
    of_float_style = Sexplib0_Sexp[16],
    of_int_style = Sexplib0_Sexp[17],
    Private = Sexplib0_Sexp[18];
   function compare_local(a_001, b_002){
    if(a_001 === b_002) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(Base_Ppx_compare_lib[5][36], a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call3
            (Base_Ppx_compare_lib[5][40], compare_local, a_005, b_006);
   }
   function compare(a, b){return compare_local(a, b);}
   function globalize(x_009){
    if(0 === x_009[0]){
     var arg_010 = x_009[1];
     return [0, caml_call1(Base_Globalize[9], arg_010)];
    }
    var arg_011 = x_009[1];
    return [1, caml_call2(Base_Globalize[13], globalize, arg_011)];
   }
   var
    hash_fold_t = function _f_(_d_, _e_){return _f_.fun(_d_, _e_);},
    hash = function _c_(_b_){return _c_.fun(_b_);};
   caml_update_dummy
    (hash_fold_t,
     function(hsv, arg){
      if(0 === arg[0]){
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(Base_Hash[13][7], hsv$0, a0);
      }
      var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
      return caml_call3(Base_Hash[13][11], hash_fold_t, hsv$1, a0$0);
     });
   caml_update_dummy
    (hash,
     function(arg){
      var
       hsv = caml_call2(Base_Hash[11], 0, 0),
       _a_ = caml_call2(hash_fold_t, hsv, arg);
      return caml_call1(Base_Hash[9], _a_);
     });
   var t_sexp_grammar = Sexplib0_Sexp_conv[61], of_string = 0;
   function invariant(param){return 0;}
   function equal_local(a, b){return 0 === compare_local(a, b) ? 1 : 0;}
   var
    Base_Sexp =
      [0,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       Private,
       equal_local,
       compare_local,
       t_sexp_grammar,
       invariant,
       of_string];
   runtime.caml_register_global(5, Base_Sexp, "Base__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import
//# unitInfo: Requires: Base__Globalize, Base__Hash, Base__Import0, Base__Ppx_compare_lib, Base__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Globalize = global_data.Base__Globalize,
    Base_Sexp = global_data.Base__Sexp,
    Exit = Base_Import0[1],
    Not_found = Base_Import0[2],
    max_int = Base_Import0[3],
    min_int = Base_Import0[4],
    infinity = Base_Import0[5],
    neg_infinity = Base_Import0[6],
    nan = Base_Import0[7],
    max_float = Base_Import0[8],
    min_float = Base_Import0[9],
    epsilon_float = Base_Import0[10],
    char_of_int = Base_Import0[11],
    string_of_bool = Base_Import0[12],
    bool_of_string_opt = Base_Import0[13],
    bool_of_string = Base_Import0[14],
    string_of_int = Base_Import0[15],
    int_of_string_opt = Base_Import0[16],
    string_of_float = Base_Import0[17],
    float_of_string_opt = Base_Import0[18],
    stdin = Base_Import0[19],
    stdout = Base_Import0[20],
    stderr = Base_Import0[21],
    print_char = Base_Import0[22],
    print_string = Base_Import0[23],
    print_bytes = Base_Import0[24],
    print_int = Base_Import0[25],
    print_float = Base_Import0[26],
    print_endline = Base_Import0[27],
    print_newline = Base_Import0[28],
    prerr_char = Base_Import0[29],
    prerr_string = Base_Import0[30],
    prerr_bytes = Base_Import0[31],
    prerr_int = Base_Import0[32],
    prerr_float = Base_Import0[33],
    prerr_endline = Base_Import0[34],
    prerr_newline = Base_Import0[35],
    read_line = Base_Import0[36],
    read_int_opt = Base_Import0[37],
    read_int = Base_Import0[38],
    read_float_opt = Base_Import0[39],
    read_float = Base_Import0[40],
    open_out = Base_Import0[41],
    open_out_bin = Base_Import0[42],
    open_out_gen = Base_Import0[43],
    flush = Base_Import0[44],
    flush_all = Base_Import0[45],
    output_char = Base_Import0[46],
    output_string = Base_Import0[47],
    output_bytes = Base_Import0[48],
    output = Base_Import0[49],
    output_substring = Base_Import0[50],
    output_byte = Base_Import0[51],
    output_binary_int = Base_Import0[52],
    output_value = Base_Import0[53],
    seek_out = Base_Import0[54],
    pos_out = Base_Import0[55],
    out_channel_length = Base_Import0[56],
    close_out = Base_Import0[57],
    close_out_noerr = Base_Import0[58],
    set_binary_mode_out = Base_Import0[59],
    open_in = Base_Import0[60],
    open_in_bin = Base_Import0[61],
    open_in_gen = Base_Import0[62],
    input_char = Base_Import0[63],
    input_line = Base_Import0[64],
    input = Base_Import0[65],
    really_input = Base_Import0[66],
    really_input_string = Base_Import0[67],
    input_byte = Base_Import0[68],
    input_binary_int = Base_Import0[69],
    input_value = Base_Import0[70],
    seek_in = Base_Import0[71],
    pos_in = Base_Import0[72],
    in_channel_length = Base_Import0[73],
    close_in = Base_Import0[74],
    close_in_noerr = Base_Import0[75],
    set_binary_mode_in = Base_Import0[76],
    string_of_format = Base_Import0[77],
    symbol = Base_Import0[78],
    exit = Base_Import0[79],
    at_exit = Base_Import0[80],
    valid_float_lexem = Base_Import0[81],
    unsafe_really_input = Base_Import0[82],
    do_at_exit = Base_Import0[83],
    do_domain_local_at_exit = Base_Import0[84],
    Stdlib = Base_Import0[85],
    bool_to_int = Base_Import0[86],
    symbol$0 = Base_Import0[87],
    symbol$1 = Base_Import0[88],
    symbol$2 = Base_Import0[89],
    symbol$3 = Base_Import0[90],
    symbol$4 = Base_Import0[91],
    symbol$5 = Base_Import0[92],
    symbol$6 = Base_Import0[93],
    symbol$7 = Base_Import0[94],
    symbol$8 = Base_Import0[95],
    symbol$9 = Base_Import0[96],
    Int_replace_polymorphic_compar = Base_Import0[97],
    ascending = Base_Import0[98],
    descending = Base_Import0[99],
    max = Base_Import0[100],
    min = Base_Import0[101],
    Int32_replace_polymorphic_comp = Base_Import0[102],
    Int64_replace_polymorphic_comp = Base_Import0[103],
    Nativeint_replace_polymorphic_ = Base_Import0[104],
    Bool_replace_polymorphic_compa = Base_Import0[105],
    Char_replace_polymorphic_compa = Base_Import0[106],
    Uchar_replace_polymorphic_comp = Base_Import0[107],
    Float_replace_polymorphic_comp = Base_Import0[108],
    String_replace_polymorphic_com = Base_Import0[109],
    Bytes_replace_polymorphic_comp = Base_Import0[110],
    symbol$10 = Base_Import0[111],
    symbol$11 = Base_Import0[112],
    symbol$12 = Base_Import0[113],
    symbol$13 = Base_Import0[114],
    asr = Base_Import0[115],
    land = Base_Import0[116],
    lnot = Base_Import0[117],
    lor = Base_Import0[118],
    lsl = Base_Import0[119],
    lsr = Base_Import0[120],
    lxor = Base_Import0[121],
    mod = Base_Import0[122],
    abs = Base_Import0[123],
    failwith = Base_Import0[124],
    fst = Base_Import0[125],
    invalid_arg = Base_Import0[126],
    snd = Base_Import0[127],
    float_of_string = Base_Import0[128],
    am_testing = Base_Import0[129],
    default_string_of_float = Sexplib0_Sexp_conv[1],
    write_old_option_format = Sexplib0_Sexp_conv[2],
    read_old_option_format = Sexplib0_Sexp_conv[3],
    list_map = Sexplib0_Sexp_conv[4],
    sexp_of_unit = Sexplib0_Sexp_conv[5],
    sexp_of_bool = Sexplib0_Sexp_conv[6],
    sexp_of_string = Sexplib0_Sexp_conv[7],
    sexp_of_bytes = Sexplib0_Sexp_conv[8],
    sexp_of_char = Sexplib0_Sexp_conv[9],
    sexp_of_int = Sexplib0_Sexp_conv[10],
    sexp_of_float = Sexplib0_Sexp_conv[11],
    sexp_of_int32 = Sexplib0_Sexp_conv[12],
    sexp_of_int64 = Sexplib0_Sexp_conv[13],
    sexp_of_nativeint = Sexplib0_Sexp_conv[14],
    sexp_of_ref = Sexplib0_Sexp_conv[15],
    sexp_of_lazy_t = Sexplib0_Sexp_conv[16],
    sexp_of_option = Sexplib0_Sexp_conv[17],
    sexp_of_pair = Sexplib0_Sexp_conv[18],
    sexp_of_triple = Sexplib0_Sexp_conv[19],
    sexp_of_list = Sexplib0_Sexp_conv[20],
    sexp_of_array = Sexplib0_Sexp_conv[21],
    sexp_of_hashtbl = Sexplib0_Sexp_conv[22],
    sexp_of_opaque = Sexplib0_Sexp_conv[23],
    sexp_of_fun = Sexplib0_Sexp_conv[24],
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    record_check_extra_fields = Sexplib0_Sexp_conv[26],
    of_sexp_error = Sexplib0_Sexp_conv[27],
    of_sexp_error_exn = Sexplib0_Sexp_conv[28],
    unit_of_sexp = Sexplib0_Sexp_conv[29],
    bool_of_sexp = Sexplib0_Sexp_conv[30],
    string_of_sexp = Sexplib0_Sexp_conv[31],
    bytes_of_sexp = Sexplib0_Sexp_conv[32],
    char_of_sexp = Sexplib0_Sexp_conv[33],
    int_of_sexp = Sexplib0_Sexp_conv[34],
    float_of_sexp = Sexplib0_Sexp_conv[35],
    int32_of_sexp = Sexplib0_Sexp_conv[36],
    int64_of_sexp = Sexplib0_Sexp_conv[37],
    nativeint_of_sexp = Sexplib0_Sexp_conv[38],
    ref_of_sexp = Sexplib0_Sexp_conv[39],
    lazy_t_of_sexp = Sexplib0_Sexp_conv[40],
    option_of_sexp = Sexplib0_Sexp_conv[41],
    pair_of_sexp = Sexplib0_Sexp_conv[42],
    triple_of_sexp = Sexplib0_Sexp_conv[43],
    list_of_sexp = Sexplib0_Sexp_conv[44],
    array_of_sexp = Sexplib0_Sexp_conv[45],
    hashtbl_of_sexp = Sexplib0_Sexp_conv[46],
    opaque_of_sexp = Sexplib0_Sexp_conv[47],
    fun_of_sexp = Sexplib0_Sexp_conv[48],
    sexp_grammar_with_tags = Sexplib0_Sexp_conv[49],
    sexp_grammar_with_tag_list = Sexplib0_Sexp_conv[50],
    unit_sexp_grammar = Sexplib0_Sexp_conv[51],
    bool_sexp_grammar = Sexplib0_Sexp_conv[52],
    string_sexp_grammar = Sexplib0_Sexp_conv[53],
    bytes_sexp_grammar = Sexplib0_Sexp_conv[54],
    char_sexp_grammar = Sexplib0_Sexp_conv[55],
    int_sexp_grammar = Sexplib0_Sexp_conv[56],
    float_sexp_grammar = Sexplib0_Sexp_conv[57],
    int32_sexp_grammar = Sexplib0_Sexp_conv[58],
    int64_sexp_grammar = Sexplib0_Sexp_conv[59],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv[60],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv[61],
    ref_sexp_grammar = Sexplib0_Sexp_conv[62],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv[63],
    option_sexp_grammar = Sexplib0_Sexp_conv[64],
    list_sexp_grammar = Sexplib0_Sexp_conv[65],
    array_sexp_grammar = Sexplib0_Sexp_conv[66],
    opaque_sexp_grammar = Sexplib0_Sexp_conv[67],
    fun_sexp_grammar = Sexplib0_Sexp_conv[68],
    sexp_of_exn = Sexplib0_Sexp_conv[69],
    printexc_prefer_sexp = Sexplib0_Sexp_conv[70],
    sexp_of_exn_opt = Sexplib0_Sexp_conv[71],
    Exn_converter = Sexplib0_Sexp_conv[72],
    _a_ = Base_Hash[13],
    hash_fold_nativeint = _a_[1],
    hash_fold_int64 = _a_[2],
    hash_fold_int32 = _a_[3],
    hash_fold_char = _a_[4],
    hash_fold_int = _a_[5],
    hash_fold_bool = _a_[6],
    hash_fold_string = _a_[7],
    hash_fold_float = _a_[8],
    hash_fold_unit = _a_[9],
    hash_fold_option = _a_[10],
    hash_fold_list = _a_[11],
    hash_fold_lazy_t = _a_[12],
    hash_fold_ref_frozen = _a_[13],
    hash_fold_array_frozen = _a_[14],
    hash_nativeint = _a_[15],
    hash_int64 = _a_[16],
    hash_int32 = _a_[17],
    hash_char = _a_[18],
    hash_int = _a_[19],
    hash_bool = _a_[20],
    hash_string = _a_[21],
    hash_float = _a_[22],
    hash_unit = _a_[23],
    _b_ = Base_Ppx_compare_lib[5],
    compare_bool = _b_[1],
    compare_char = _b_[2],
    compare_float = _b_[3],
    compare_int = _b_[4],
    compare_int32 = _b_[5],
    compare_int64 = _b_[6],
    compare_nativeint = _b_[7],
    compare_string = _b_[8],
    compare_bytes = _b_[9],
    compare_unit = _b_[10],
    compare_array = _b_[11],
    compare_list = _b_[12],
    compare_option = _b_[13],
    compare_ref = _b_[14],
    equal_bool = _b_[15],
    equal_char = _b_[16],
    equal_float = _b_[17],
    equal_int = _b_[18],
    equal_int32 = _b_[19],
    equal_int64 = _b_[20],
    equal_nativeint = _b_[21],
    equal_string = _b_[22],
    equal_bytes = _b_[23],
    equal_unit = _b_[24],
    equal_array = _b_[25],
    equal_list = _b_[26],
    equal_option = _b_[27],
    equal_ref = _b_[28],
    compare_bool_local = _b_[29],
    compare_char_local = _b_[30],
    compare_float_local = _b_[31],
    compare_int_local = _b_[32],
    compare_int32_local = _b_[33],
    compare_int64_local = _b_[34],
    compare_nativeint_local = _b_[35],
    compare_string_local = _b_[36],
    compare_bytes_local = _b_[37],
    compare_unit_local = _b_[38],
    compare_array_local = _b_[39],
    compare_list_local = _b_[40],
    compare_option_local = _b_[41],
    compare_ref_local = _b_[42],
    equal_bool_local = _b_[43],
    equal_char_local = _b_[44],
    equal_float_local = _b_[45],
    equal_int_local = _b_[46],
    equal_int32_local = _b_[47],
    equal_int64_local = _b_[48],
    equal_nativeint_local = _b_[49],
    equal_string_local = _b_[50],
    equal_bytes_local = _b_[51],
    equal_unit_local = _b_[52],
    equal_array_local = _b_[53],
    equal_list_local = _b_[54],
    equal_option_local = _b_[55],
    equal_ref_local = _b_[56],
    globalize_bool = Base_Globalize[1],
    globalize_char = Base_Globalize[2],
    globalize_float = Base_Globalize[3],
    globalize_int = Base_Globalize[4],
    globalize_int32 = Base_Globalize[5],
    globalize_int64 = Base_Globalize[6],
    globalize_nativeint = Base_Globalize[7],
    globalize_bytes = Base_Globalize[8],
    globalize_string = Base_Globalize[9],
    globalize_unit = Base_Globalize[10],
    globalize_array = Base_Globalize[11],
    globalize_lazy_t = Base_Globalize[12],
    globalize_list = Base_Globalize[13],
    globalize_option = Base_Globalize[14],
    globalize_result = Base_Globalize[15],
    globalize_ref = Base_Globalize[16],
    Not_found_s = Base_Sexp[8],
    Base_Import =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Stdlib,
       bool_to_int,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       Int_replace_polymorphic_compar,
       ascending,
       descending,
       max,
       min,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$10,
       symbol$11,
       symbol$12,
       symbol$13,
       asr,
       land,
       lnot,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs,
       failwith,
       fst,
       invalid_arg,
       snd,
       float_of_string,
       am_testing,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       Exn_converter,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       hash_float,
       hash_unit,
       compare_bool,
       compare_char,
       compare_float,
       compare_int,
       compare_int32,
       compare_int64,
       compare_nativeint,
       compare_string,
       compare_bytes,
       compare_unit,
       compare_array,
       compare_list,
       compare_option,
       compare_ref,
       equal_bool,
       equal_char,
       equal_float,
       equal_int,
       equal_int32,
       equal_int64,
       equal_nativeint,
       equal_string,
       equal_bytes,
       equal_unit,
       equal_array,
       equal_list,
       equal_option,
       equal_ref,
       compare_bool_local,
       compare_char_local,
       compare_float_local,
       compare_int_local,
       compare_int32_local,
       compare_int64_local,
       compare_nativeint_local,
       compare_string_local,
       compare_bytes_local,
       compare_unit_local,
       compare_array_local,
       compare_list_local,
       compare_option_local,
       compare_ref_local,
       equal_bool_local,
       equal_char_local,
       equal_float_local,
       equal_int_local,
       equal_int32_local,
       equal_int64_local,
       equal_nativeint_local,
       equal_string_local,
       equal_bytes_local,
       equal_unit_local,
       equal_array_local,
       equal_list_local,
       equal_option_local,
       equal_ref_local,
       globalize_bool,
       globalize_char,
       globalize_float,
       globalize_int,
       globalize_int32,
       globalize_int64,
       globalize_nativeint,
       globalize_bytes,
       globalize_string,
       globalize_unit,
       globalize_array,
       globalize_lazy_t,
       globalize_list,
       globalize_option,
       globalize_result,
       globalize_ref,
       Not_found_s];
   runtime.caml_register_global(6, Base_Import, "Base__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Word_size
//# unitInfo: Requires: Base__Import, Base__Sys0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import = global_data.Base__Import,
    _a_ = [0, "W64"],
    _b_ = [0, "W32"],
    cst_unknown_word_size = "unknown word size";
   function sexp_of_t(param){return param ? _a_ : _b_;}
   function num_bits(param){return param ? 64 : 32;}
   var
    _c_ = Base_Sys0[7],
    word_size =
      32 === _c_
       ? 0
       : 64 === _c_ ? 1 : caml_call1(Base_Import[124], cst_unknown_word_size),
    Base_Word_size = [0, sexp_of_t, num_bits, word_size];
   runtime.caml_register_global(5, Base_Word_size, "Base__Word_size");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Formatter
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Formatter = [0];
   runtime.caml_register_global(0, Base_Formatter, "Base__Formatter");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pretty_printer
//# unitInfo: Requires: Base__Import, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Import = global_data.Base__Import,
    r = [0, [0, "Base.Sexp.pp_hum", 0]],
    cst_pp = ".pp";
   function all(param){return r[1];}
   function register(p){r[1] = [0, p, r[1]]; return 0;}
   function Register_pp(M){
    var pp = M[1];
    register(caml_call2(Base_Import[112], M[2], cst_pp));
    return [0, pp];
   }
   function _a_(_c_){return [0, Register_pp(_c_)[1]];}
   var
    Base_Pretty_printer =
      [0,
       all,
       function(M){
        var module_name = M[1];
        function pp(formatter, t){
         var _b_ = caml_call1(M[2], t);
         return caml_call2(Stdlib_Format[13], formatter, _b_);
        }
        return [0, Register_pp([0, pp, module_name])[1]];
       },
       _a_,
       register];
   runtime.caml_register_global
    (4, Base_Pretty_printer, "Base__Pretty_printer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Exn
//# unitInfo: Requires: Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_2 = "<2>",
    cst_src_exn_ml = "src/exn.ml",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Exn",
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Import = global_data.Base__Import,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Sexp = global_data.Base__Sexp,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    sexp_of_t = Base_Import[198],
    exit = Base_Import[85][99],
    Finally = [248, "Base__Exn.Finally", caml_fresh_oo_id(0)],
    _k_ =
      [0,
       [11, "Exn.handle_uncaught could not print; exiting anyway\n", [10, 0]],
       "Exn.handle_uncaught could not print; exiting anyway\n%!"],
    _j_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11,
         "Uncaught exception:",
         [17,
          3,
          [17,
           3,
           [18, [1, [0, 0, ""]], [15, [17, 0, [17, 0, [17, 3, [17, 4, 0]]]]]]]]]],
       "@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@."],
    _i_ = [0, 2],
    _h_ = [0, cst_src_exn_ml, 53, 6],
    _e_ = [0, "exn.ml.Reraised"],
    _f_ = [0, cst_src_exn_ml, 32, 11],
    _b_ = [0, "exn.ml.Finally"],
    _c_ = [0, cst_src_exn_ml, 19, 11],
    cst_Base_Exn_Reraised = "Base__Exn.Reraised",
    cst_Base_Exn_Sexp = "Base__Exn.Sexp";
   function _a_(param){
    if(param[1] !== Finally)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var
     arg1_002 = param[3],
     arg0_001 = param[2],
     res0_003 = caml_call1(sexp_of_t, arg0_001),
     res1_004 = caml_call1(sexp_of_t, arg1_002);
    return [1, [0, _b_, [0, res0_003, [0, res1_004, 0]]]];
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Finally, _a_);
   var Reraised = [248, cst_Base_Exn_Reraised, caml_fresh_oo_id(0)];
   function _d_(param){
    if(param[1] !== Reraised)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var
     arg1_006 = param[3],
     arg0_005 = param[2],
     res0_007 = caml_call1(Base_Import[136], arg0_005),
     res1_008 = caml_call1(sexp_of_t, arg1_006);
    return [1, [0, _e_, [0, res0_007, [0, res1_008, 0]]]];
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Reraised, _d_);
   var Sexp = [248, cst_Base_Exn_Sexp, caml_fresh_oo_id(0)];
   function _g_(param){
    if(param[1] !== Sexp)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var t = param[2];
    return t;
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Sexp, _g_);
   function create_s(sexp){return [0, Sexp, sexp];}
   function raise_with_original_backtrace(t, backtrace){
    runtime.caml_restore_raw_backtrace(t, backtrace);
    throw caml_maybe_attach_backtrace(t, 0);
   }
   function reraise(exn, str){
    var exn$0 = [0, Reraised, str, exn];
    if(! runtime.Base_caml_exn_is_most_recent_exn(exn))
     throw caml_maybe_attach_backtrace(exn$0, 1);
    var bt = caml_call1(Stdlib_Printexc[12], 0);
    return raise_with_original_backtrace(exn$0, bt);
   }
   function reraisef(exc, format){
    function _y_(str, param){return reraise(exc, str);}
    return caml_call2(Base_Printf[4], _y_, format);
   }
   function to_string(exc){
    var _x_ = caml_call1(Base_Import[198], exc);
    return caml_call2(Base_Sexp[16], _i_, _x_);
   }
   function to_string_mach(exc){
    var _w_ = caml_call1(Base_Import[198], exc);
    return caml_call1(Base_Sexp[17], _w_);
   }
   var sexp_of_t$0 = Base_Import[198];
   function protectx(f, x, finally$0){
    try{var res = caml_call1(f, x);}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     try{caml_call1(finally$0, x);}
     catch(final_exn$0){
      var final_exn = caml_wrap_exception(final_exn$0);
      return raise_with_original_backtrace([0, Finally, exn, final_exn], bt);
     }
     return raise_with_original_backtrace(exn, bt);
    }
    caml_call1(finally$0, x);
    return res;
   }
   function protect(f, finally$0){return protectx(f, 0, finally$0);}
   function does_raise(f){
    try{caml_call1(f, 0); var _u_ = 0; return _u_;}catch(_v_){return 1;}
   }
   function pp(ppf, t){
    var match = caml_call1(Base_Import[200], t);
    if(match){
     var sexp = match[1];
     return caml_call2(Base_Sexp[12], ppf, sexp);
    }
    var _t_ = caml_call1(Stdlib_Printexc[1], t);
    return caml_call2(Stdlib_Format[13], ppf, _t_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1];
   function print_with_backtrace(exc, raw_backtrace){
    caml_call3(Stdlib_Format[139], _j_, pp$0, exc);
    if(caml_call1(Stdlib_Printexc[8], 0))
     caml_call2(Stdlib_Printexc[13], Base_Import[85][40], raw_backtrace);
    return caml_call1(Base_Import[85][63], Base_Import[85][40]);
   }
   function handle_uncaught_aux(do_at_exit, exit, f){
    try{var _p_ = caml_call1(f, 0); return _p_;}
    catch(exc$0){
     var
      exc = caml_wrap_exception(exc$0),
      raw_backtrace = caml_call1(Stdlib_Printexc[12], 0);
     if(do_at_exit) try{caml_call1(Base_Import[85][103], 0);}catch(_s_){}
     try{print_with_backtrace(exc, raw_backtrace);}
     catch(_q_){try{caml_call1(Stdlib_Printf[3], _k_);}catch(_r_){}}
     return caml_call1(exit, 1);
    }
   }
   function handle_uncaught_and_exit(f){
    return handle_uncaught_aux(1, exit, f);
   }
   function handle_uncaught(must_exit, f){
    var exit$0 = must_exit ? exit : function(_o_){return 0;};
    return handle_uncaught_aux(must_exit, exit$0, f);
   }
   function reraise_uncaught(str, func){
    try{var _n_ = caml_call1(func, 0); return _n_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     return raise_with_original_backtrace([0, Reraised, str, exn], bt);
    }
   }
   function raise_without_backtrace(e){
    runtime.Base_clear_caml_backtrace_pos(0);
    throw e;
   }
   function initialize_module(param){
    return caml_call1(Stdlib_Printexc[16], print_with_backtrace);
   }
   function clear_backtrace(_m_){
    return runtime.Base_clear_caml_backtrace_pos(_m_);
   }
   var
    Private = [0, clear_backtrace],
    Base_Exn =
      [0,
       sexp_of_t$0,
       pp$0,
       Finally,
       Reraised,
       create_s,
       raise_without_backtrace,
       raise_with_original_backtrace,
       reraise,
       reraisef,
       to_string,
       to_string_mach,
       protectx,
       protect,
       handle_uncaught,
       handle_uncaught_and_exit,
       reraise_uncaught,
       does_raise,
       function(_l_){return runtime.Base_caml_exn_is_most_recent_exn(_l_);},
       initialize_module,
       Private];
   runtime.caml_register_global(21, Base_Exn, "Base__Exn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__With_return
//# unitInfo: Requires: Base__Exn, Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    cst_use_of_return_from_a_with_ =
      "use of [return] from a [with_return] that already returned",
    cst_Return = "Return";
   function with_return(f){
    var
     Return = [248, cst_Return, runtime.caml_fresh_oo_id(0)],
     is_alive = [0, 1];
    function return$0(a){
     if(1 - is_alive[1])
      caml_call1(Base_Import[124], cst_use_of_return_from_a_with_);
     return caml_call1(Base_Exn[6], [0, Return, a]);
    }
    try{var a$0 = caml_call1(f, return$0); is_alive[1] = 0; return a$0;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     is_alive[1] = 0;
     if(exn[1] !== Return) throw caml_maybe_attach_backtrace(exn, 0);
     var a = exn[2];
     return a;
    }
   }
   function with_return_option(f){
    return with_return
            (function(return$0){
              caml_call1(f, function(a){return caml_call1(return$0, [0, a]);});
              return 0;
             });
   }
   function prepend(param, f){
    return function(x){return caml_call1(param, caml_call1(f, x));};
   }
   var Base_With_return = [0, with_return, with_return_option, prepend];
   runtime.caml_register_global(4, Base_With_return, "Base__With_return");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variant
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variant = [0];
   runtime.caml_register_global(0, Base_Variant, "Base__Variant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variantslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variantslib = [0];
   runtime.caml_register_global(0, Base_Variantslib, "Base__Variantslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fn
//# unitInfo: Requires: Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import;
   function const$0(c, param){return c;}
   function non(f, x){return 1 - caml_call1(f, x);}
   function forever(f){
    try{for(;;) caml_call1(f, 0);}
    catch(e$0){var e = caml_wrap_exception(e$0); return e;}
   }
   function compose(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function apply_n_times(n, f, x){
    var n$0 = n, x$0 = x;
    for(;;){
     if(0 >= n$0) return x$0;
     var
      x$1 = caml_call1(f, x$0),
      n$1 = caml_call2(Base_Import[93], n$0, 1),
      n$0 = n$1,
      x$0 = x$1;
    }
   }
   var Base_Fn = [0, const$0, non, forever, apply_n_times, compose, flip];
   runtime.caml_register_global(1, Base_Fn, "Base__Fn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function S_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S3(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_to_S_indexed(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit,
            Let_syntax];
   }
   function S3_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_indexed_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   var
    Base_Monad_intf =
      [0,
       S_to_S2,
       S2_to_S3,
       S_to_S_indexed,
       S2_to_S,
       S3_to_S2,
       S_indexed_to_S2];
   runtime.caml_register_global(0, Base_Monad_intf, "Base__Monad_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad
//# unitInfo: Requires: Base__List0, Base__Monad_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0;
   function Make_general(_M_){
    var bind = _M_[1], return$0 = _M_[3];
    function map_via_bind(ma, f){
     function _N_(a){
      var _O_ = caml_call1(f, a);
      return caml_call1(_M_[3], _O_);
     }
     return caml_call2(_M_[1], ma, _N_);
    }
    var match = _M_[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var
     Monad_infix = [0, symbol_bind, symbol_map],
     symbol_bind$0 = Monad_infix[1],
     symbol_map$0 = Monad_infix[2],
     symbol_bind$1 = Monad_infix[1],
     symbol_map$1 = Monad_infix[2];
    function both(a, b){
     return caml_call2
             (symbol_bind$1,
              a,
              function(a){
               return caml_call2
                       (symbol_map$1, b, function(b){return [0, a, b];});
              });
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$0, symbol_bind$1, symbol_map$1, Let_syntax];
    function join(t){
     return caml_call2(symbol_bind$0, t, function(t){return t;});
    }
    function ignore_m(t){
     return caml_call2(map, t, function(param){return 0;});
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$0, caml_call1(Base_List0[19], vs));
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(v){return loop([0, v, vs], ts);});
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$0, 0);
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(param){return all_unit(ts);});
    }
    return [0,
            bind,
            return$0,
            ,
            map,
            Monad_infix,
            symbol_bind$0,
            symbol_map$0,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_indexed(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _L_ = Make_general([0, bind, map, return$0]);
    return [0,
            _L_[6],
            _L_[7],
            _L_[8],
            _L_[5],
            _L_[1],
            _L_[2],
            _L_[4],
            _L_[9],
            _L_[10],
            _L_[11],
            _L_[12]];
   }
   function Make3(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _K_ = Make_general([0, bind, map, return$0]);
    return [0,
            _K_[6],
            _K_[7],
            _K_[8],
            _K_[5],
            _K_[1],
            _K_[2],
            _K_[4],
            _K_[9],
            _K_[10],
            _K_[11],
            _K_[12]];
   }
   function Make2(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _J_ = Make_general([0, bind, map, return$0]);
    return [0,
            _J_[6],
            _J_[7],
            _J_[8],
            _J_[5],
            _J_[1],
            _J_[2],
            _J_[4],
            _J_[9],
            _J_[10],
            _J_[11],
            _J_[12]];
   }
   function Make(M){
    var
     bind = M[1],
     return$0 = M[2],
     map = M[3],
     _I_ = Make_general([0, bind, map, return$0]);
    return [0,
            _I_[6],
            _I_[7],
            _I_[5],
            _I_[1],
            _I_[2],
            _I_[4],
            _I_[9],
            _I_[10],
            _I_[11],
            _I_[12],
            _I_[8]];
   }
   function Make2_local(_E_){
    var bind = _E_[1], return$0 = _E_[3];
    function map_via_bind(ma, f){
     function _G_(a){
      var _H_ = caml_call1(f, a);
      return caml_call1(_E_[3], _H_);
     }
     var res = caml_call2(_E_[1], ma, _G_);
     return res;
    }
    var match = _E_[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var
     Monad_infix = [0, symbol_bind, symbol_map],
     symbol_bind$0 = Monad_infix[1],
     symbol_map$0 = Monad_infix[2],
     symbol_bind$1 = Monad_infix[1],
     symbol_map$1 = Monad_infix[2];
    function both(a, b){
     var
      res =
        caml_call2
         (bind,
          a,
          function(a){
           var res = caml_call2(map, b, function(b){return [0, a, b];});
           return res;
          });
     return res;
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$0, symbol_bind$1, symbol_map$1, Let_syntax];
    function join(t){
     return caml_call2(symbol_bind$0, t, function(_F_){return _F_;});
    }
    function ignore_m(t){
     var res = caml_call2(map, t, function(param){return 0;});
     return res;
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$0, caml_call1(Base_List0[19], vs));
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(v){return loop([0, v, vs], ts);});
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$0, 0);
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(param){return all_unit(ts);});
    }
    return [0,
            bind,
            return$0,
            ,
            map,
            Monad_infix,
            symbol_bind$0,
            symbol_map$0,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_local(M){
    var
     bind = M[1],
     return$0 = M[2],
     map = M[3],
     _D_ = Make2_local([0, bind, map, return$0]);
    return [0,
            _D_[6],
            _D_[7],
            _D_[5],
            _D_[1],
            _D_[2],
            _D_[4],
            _D_[9],
            _D_[10],
            _D_[11],
            _D_[12],
            _D_[8]];
   }
   function Of_monad_general(Monad, M){
    function return$0(a){
     var _C_ = caml_call1(Monad[3], a);
     return caml_call1(M[2], _C_);
    }
    function bind(t, f){
     function _y_(a){
      var _B_ = caml_call1(f, a);
      return caml_call1(M[1], _B_);
     }
     var _z_ = caml_call1(M[1], t), _A_ = caml_call2(Monad[1], _z_, _y_);
     return caml_call1(M[2], _A_);
    }
    var
     map =
       [0,
        -198771759,
        function(t, f){
         var _w_ = caml_call1(M[1], t), _x_ = caml_call2(Monad[2], _w_, f);
         return caml_call1(M[2], _x_);
        }];
    return Make_general([0, bind, map, return$0]);
   }
   function bind(a, f){return caml_call1(f, a);}
   function map(a, f){return caml_call1(f, a);}
   function symbol_map(a, f){return map(a, f);}
   function symbol_bind(a, f){return bind(a, f);}
   function return$0(_v_){return _v_;}
   function both(a, b){return [0, a, b];}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
    _a_ = [0, return$0, symbol_bind, symbol_map, Let_syntax];
   function _b_(_u_){return 0;}
   function _c_(_t_){return _t_;}
   function _d_(_s_){return 0;}
   function _e_(_r_){return _r_;}
   var
    _f_ =
      [0,
       symbol_bind,
       symbol_map,
       [0, symbol_bind, symbol_map],
       bind,
       function(_q_){return _q_;},
       map,
       _e_,
       _d_,
       _c_,
       _b_,
       _a_];
   function _g_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _p_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _p_[6],
            _p_[7],
            _p_[8],
            _p_[5],
            _p_[1],
            _p_[2],
            _p_[4],
            _p_[9],
            _p_[10],
            _p_[11],
            _p_[12]];
   }
   function _h_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _o_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _o_[6],
            _o_[7],
            _o_[8],
            _o_[5],
            _o_[1],
            _o_[2],
            _o_[4],
            _o_[9],
            _o_[10],
            _o_[11],
            _o_[12]];
   }
   function _i_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _n_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _n_[6],
            _n_[7],
            _n_[8],
            _n_[5],
            _n_[1],
            _n_[2],
            _n_[4],
            _n_[9],
            _n_[10],
            _n_[11],
            _n_[12]];
   }
   function _j_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[4],
     return$0 = Monad[5],
     map = Monad[6],
     _m_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _m_[6],
            _m_[7],
            _m_[5],
            _m_[1],
            _m_[2],
            _m_[4],
            _m_[9],
            _m_[10],
            _m_[11],
            _m_[12],
            _m_[8]];
   }
   var
    Base_Monad =
      [0,
       Make,
       Make2,
       Make3,
       Make_indexed,
       Make_local,
       function(_k_){
        var _l_ = Make2_local(_k_);
        return [0,
                _l_[6],
                _l_[7],
                _l_[8],
                _l_[5],
                _l_[1],
                _l_[2],
                _l_[4],
                _l_[9],
                _l_[10],
                _l_[11],
                _l_[12]];
       },
       _j_,
       _i_,
       _h_,
       _g_,
       _f_];
   runtime.caml_register_global(1, Base_Monad, "Base__Monad");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__T
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_T = [0];
   runtime.caml_register_global(0, Base_T, "Base__T");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Applicative_intf = [0];
   runtime.caml_register_global
    (0, Base_Applicative_intf, "Base__Applicative_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative
//# unitInfo: Requires: Base__Applicative_intf, Base__Import, Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0;
   function S_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S(T, X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S3(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S2(T, X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S(T1, T2, X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Make3(_X_){
    var return$0 = _X_[1], symbol = _X_[2];
    function derived_map(t, f){
     return caml_call2(symbol, caml_call1(return$0, f), t);
    }
    var match = _X_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function map2(ta, tb, f){
     return caml_call2(symbol, caml_call2(map, ta, f), tb);
    }
    function map3(ta, tb, tc, f){
     return caml_call2
             (symbol, caml_call2(symbol, caml_call2(map, ta, f), tb), tc);
    }
    function all(ts){
     var _Z_ = caml_call1(return$0, 0);
     function ___(x, xs){return [0, x, xs];}
     function _$_(_aa_){return function(_ab_){return map2(_aa_, _ab_, ___);};}
     return caml_call3(Base_List0[20], ts, _$_, _Z_);
    }
    function both(ta, tb){
     return map2(ta, tb, function(a, b){return [0, a, b];});
    }
    function symbol$0(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(param, y){return y;}),
                u),
              v);
    }
    function symbol$1(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(x, param){return x;}),
                u),
              v);
    }
    function all_unit(ts){
     var _Y_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _Y_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make3([0, return$0, apply, map]);
   }
   function Make(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make2([0, return$0, apply, map]);
   }
   function Make_let_syntax3(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     return$1 = X[1],
     map$0 = X[2],
     both$0 = X[3],
     symbol$2 = X[4],
     symbol$3 = X[5],
     symbol$4 = X[6],
     symbol_map$0 = X[7],
     Let_syntax =
       [0,
        return$1,
        map$0,
        both$0,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol_map$0,
        Impl],
     Let_syntax$0 =
       [0,
        return$0,
        map,
        both,
        symbol,
        symbol$0,
        symbol$1,
        symbol_map,
        Let_syntax];
    return [0, Let_syntax$0];
   }
   function Make_let_syntax2(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7];
    return Make_let_syntax3
            ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
             Intf,
             Impl);
   }
   function Make3_using_map2(_O_){
    var return$0 = _O_[1], map2 = _O_[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){return symbol(caml_call1(return$0, f), t);}
    var match = _O_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     function _W_(fab, c){return caml_call1(fab, c);}
     return caml_call3(map2, caml_call3(map2, ta, tb, f), tc, _W_);
    }
    function all(ts){
     var _Q_ = caml_call1(return$0, 0);
     function _R_(x, xs){return [0, x, xs];}
     function _S_(_T_){
      var _U_ = caml_call1(map2, _T_);
      return function(_V_){return caml_call2(_U_, _V_, _R_);};
     }
     return caml_call3(Base_List0[20], ts, _S_, _Q_);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var _P_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _P_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2([0, return$0, map2, map]);
   }
   function Make_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2([0, return$0, map2, map]);
   }
   function Make3_using_map2_local(_E_){
    var return$0 = _E_[1], map2 = _E_[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){
     function _N_(param){return f;}
     return caml_call3(map2, caml_call1(return$0, 0), t, _N_);
    }
    var match = _E_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var map$0 = match[2], map = map$0;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     function _M_(param, c){
      var b = param[2], a = param[1];
      return caml_call3(f, a, b, c);
     }
     var res = caml_call3(map2, both(ta, tb), tc, _M_);
     return res;
    }
    function all(ts){
     var _G_ = caml_call1(return$0, 0);
     function _H_(x, xs){return [0, x, xs];}
     function _I_(_J_){
      var _K_ = caml_call1(map2, _J_);
      return function(_L_){return caml_call2(_K_, _L_, _H_);};
     }
     return caml_call3(Base_List0[20], ts, _I_, _G_);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var _F_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _F_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2_local(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2_local([0, return$0, map2, map]);
   }
   function Make_using_map2_local(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2_local([0, return$0, map2, map]);
   }
   function Of_monad2(M){
    var return$0 = M[6];
    function apply(mf, mx){
     function _D_(f){return caml_call2(M[7], mx, f);}
     return caml_call2(M[5], mf, _D_);
    }
    var map = [0, -198771759, M[7]];
    return Make2([0, return$0, apply, map]);
   }
   function Of_monad(M){
    var
     symbol_bind = M[1],
     symbol_map = M[2],
     Monad_infix = M[3],
     bind = M[4],
     return$0 = M[5],
     map = M[6],
     join = M[7],
     ignore_m = M[8],
     all = M[9],
     all_unit = M[10],
     Let_syntax = M[11];
    return Of_monad2
            ([0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]);
   }
   function Compose(F, G){
    function return$0(a){
     var _C_ = caml_call1(F[1], a);
     return caml_call1(G[1], _C_);
    }
    function apply(tf, tx){
     var _B_ = caml_call2(G[2], tf, F[8]);
     return caml_call2(G[8], _B_, tx);
    }
    function custom_map(t, f){
     var _y_ = F[2];
     function _z_(_A_){return caml_call2(_y_, _A_, f);}
     return caml_call2(G[2], t, _z_);
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Pair(F, G){
    function return$0(a){
     var _x_ = caml_call1(G[1], a);
     return [0, caml_call1(F[1], a), _x_];
    }
    function apply(tf, tx){
     var
      _s_ = caml_call1(Base_Import[127], tx),
      _t_ = caml_call1(Base_Import[127], tf),
      _u_ = caml_call2(G[8], _t_, _s_),
      _v_ = caml_call1(Base_Import[125], tx),
      _w_ = caml_call1(Base_Import[125], tf);
     return [0, caml_call2(F[8], _w_, _v_), _u_];
    }
    function custom_map(t, f){
     var
      _p_ = caml_call1(Base_Import[127], t),
      _q_ = caml_call2(G[2], _p_, f),
      _r_ = caml_call1(Base_Import[125], t);
     return [0, caml_call2(F[2], _r_, f), _q_];
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function return$0(_o_){return _o_;}
   function map2(a, b, f){return caml_call2(f, a, b);}
   var
    map = [0, -198771759, function(a, f){return caml_call1(f, a);}],
    include = Make_using_map2_local([0, return$0, map2, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply = include[8],
    map2$0 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    Ident =
      [0,
       return$1,
       map$0,
       both,
       symbol,
       symbol$0,
       symbol$1,
       symbol_map,
       apply,
       map2$0,
       map3,
       all,
       all_unit,
       Applicative_infix];
   function _a_(_l_, _k_, _j_){
    var _m_ = Make_let_syntax3(_l_, _k_, _j_)[1], _n_ = _m_[8];
    return [0,
            [0,
             _m_[1],
             _m_[4],
             _m_[5],
             _m_[6],
             _m_[7],
             [0, _n_[1], _n_[2], _n_[3], _n_[8]]]];
   }
   function _b_(_g_, _f_, _e_){
    var _h_ = Make_let_syntax2(_g_, _f_, _e_)[1], _i_ = _h_[8];
    return [0,
            [0,
             _h_[1],
             _h_[4],
             _h_[5],
             _h_[6],
             _h_[7],
             [0, _i_[1], _i_[2], _i_[3], _i_[8]]]];
   }
   var
    Base_Applicative =
      [0,
       Ident,
       S2_to_S,
       S_to_S2,
       S3_to_S2,
       S3_to_S,
       S2_to_S3,
       Make,
       Make2,
       Make3,
       function(X, Intf, Impl){
        var
         return$0 = X[1],
         map = X[2],
         both = X[3],
         symbol = X[4],
         symbol$0 = X[5],
         symbol$1 = X[6],
         symbol_map = X[7],
         _c_ =
           Make_let_syntax2
             ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
              Intf,
              Impl)
            [1],
         _d_ = _c_[8];
        return [0,
                [0,
                 _c_[1],
                 _c_[4],
                 _c_[5],
                 _c_[6],
                 _c_[7],
                 [0, _d_[1], _d_[2], _d_[3], _d_[8]]]];
       },
       _b_,
       _a_,
       Make_using_map2,
       Make2_using_map2,
       Make3_using_map2,
       Make_using_map2_local,
       Make2_using_map2_local,
       Make3_using_map2_local,
       Of_monad,
       Of_monad2,
       Compose,
       Pair];
   runtime.caml_register_global(2, Base_Applicative, "Base__Applicative");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparator
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var Module = [0], _a_ = [0, "_"];
   function of_module(M){return M[1];}
   function to_module(t){return [0, t];}
   function make(compare, sexp_of_t){
    var comparator = [0, compare, sexp_of_t];
    return [0, comparator];
   }
   function S_to_S1(S){var comparator = S[1]; return [0, comparator];}
   function Make1(M){
    var comparator = [0, M[1], M[2]];
    return [0, comparator];
   }
   var compare = runtime.caml_compare;
   function sexp_of_t(param){return _a_;}
   var
    include = Make1([0, compare, sexp_of_t]),
    comparator = include[1],
    Poly = [0, comparator];
   function Derived(M){
    function comparator(a){
     var _e_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _e_];
    }
    return [0, comparator];
   }
   function Derived2(M){
    function comparator(a, b){
     var _d_ = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), _d_];
    }
    return [0, comparator];
   }
   function Derived_phantom(M){
    function comparator(a){
     var _c_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _c_];
    }
    return [0, comparator];
   }
   function Derived2_phantom(M){
    function comparator(a, b){
     var _b_ = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), _b_];
    }
    return [0, comparator];
   }
   var
    Base_Comparator =
      [0,
       make,
       Poly,
       Module,
       of_module,
       to_module,
       S_to_S1,
       function(M){var comparator = [0, M[1], M[2]]; return [0, comparator];},
       Make1,
       Derived,
       Derived2,
       Derived_phantom,
       Derived2_phantom];
   runtime.caml_register_global(1, Base_Comparator, "Base__Comparator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparisons
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparisons = [0];
   runtime.caml_register_global(0, Base_Comparisons, "Base__Comparisons");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either0
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_First$0 = "First",
    cst_Second$0 = "Second",
    cst_first = "first",
    cst_second = "second",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_017 = "either0.ml.t",
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    cst_Second = cst_Second$0,
    cst_First = cst_First$0,
    _a_ = [0, cst_First$0],
    _b_ = [0, cst_Second$0];
   function compare_local(cmp_f, cmp_s, a_007, b_008){
    if(a_007 === b_008) return 0;
    if(0 === a_007[0]){
     var a_009 = a_007[1];
     if(0 !== b_008[0]) return -1;
     var b_010 = b_008[1];
     return caml_call2(cmp_f, a_009, b_010);
    }
    var a_011 = a_007[1];
    if(0 === b_008[0]) return 1;
    var b_012 = b_008[1];
    return caml_call2(cmp_s, a_011, b_012);
   }
   function compare(cmp_f, cmp_s, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(cmp_f, a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call2(cmp_s, a_005, b_006);
   }
   function hash_fold_t(hash_fold_f, hash_fold_s, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_f, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_s, hsv$1, a0$0);
   }
   function t_of_sexp(of_f_013, of_s_014, sexp_019){
    a:
    {
     if(0 === sexp_019[0]){
      var _c_ = sexp_019[1];
      b:
      if(caml_string_notequal(_c_, cst_First$0)){
       if(caml_string_notequal(_c_, cst_Second$0)){
        if(! caml_string_notequal(_c_, cst_first)) break b;
        if(caml_string_notequal(_c_, cst_second)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_017, sexp_019);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_017, sexp_019);
     }
     var _d_ = sexp_019[1];
     if(! _d_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_017, sexp_019);
     var _e_ = _d_[1];
     if(0 !== _e_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_017, sexp_019);
     var tag_020 = _e_[1];
     b:
     if(caml_string_notequal(tag_020, cst_First$0)){
      if(caml_string_notequal(tag_020, cst_Second$0)){
       if(! caml_string_notequal(tag_020, cst_first)) break b;
       if(caml_string_notequal(tag_020, cst_second)) break a;
      }
      var sexp_args_026 = _d_[2];
      if(sexp_args_026 && ! sexp_args_026[2]){
       var
        arg0_027 = sexp_args_026[1],
        res0_028 = caml_call1(of_s_014, arg0_027);
       return [1, res0_028];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_017,
               tag_020,
               sexp_019);
     }
     var sexp_args_021 = _d_[2];
     if(sexp_args_021 && ! sexp_args_021[2]){
      var
       arg0_022 = sexp_args_021[1],
       res0_023 = caml_call1(of_f_013, arg0_022);
      return [0, res0_023];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_017,
              tag_020,
              sexp_019);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_017, sexp_019);
   }
   function sexp_of_t(of_f_031, of_s_032, param){
    if(0 === param[0]){
     var arg0_033 = param[1], res0_034 = caml_call1(of_f_031, arg0_033);
     return [1, [0, _a_, [0, res0_034, 0]]];
    }
    var arg0_035 = param[1], res0_036 = caml_call1(of_s_032, arg0_035);
    return [1, [0, _b_, [0, res0_036, 0]]];
   }
   function t_sexp_grammar(f_sexp_grammar, s_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_First, [0, [0, f_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Second, [0, [0, s_sexp_grammar, 0]]]], 0]]]];
   }
   var
    Base_Either0 =
      [0,
       compare_local,
       compare,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar];
   runtime.caml_register_global(15, Base_Either0, "Base__Either0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Field
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function opaque_identity(_b_){return _b_;}
   var For_generated_code = [0, opaque_identity];
   function name(param){return param[2];}
   function get(param, r){return caml_call1(param[4], r);}
   function fset(param, r, v){return caml_call2(param[5], r, v);}
   function setter(param){return param[3];}
   function map(param, r, f){
    var _a_ = caml_call1(f, caml_call1(param[4], r));
    return caml_call2(param[5], r, _a_);
   }
   function updater(field){
    var match = field[3];
    if(! match) return 0;
    var setter = match[1];
    return [0,
            function(r, f){
             return caml_call2
                     (setter, r, caml_call1(f, caml_call1(field[4], r)));
            }];
   }
   var
    Base_Field =
      [0, For_generated_code, name, get, fset, setter, map, updater];
   runtime.caml_register_global(0, Base_Field, "Base__Field");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_conversions
//# unitInfo: Requires: Base__Import, Base__Int0, Base__Printf, Base__Sys0, Base__Word_size, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_int$3 = "int",
    cst_int32$3 = "int32",
    cst_int64$3 = "int64",
    cst_nativeint$2 = "nativeint",
    cst_src_int_conversions_ml = "src/int_conversions.ml",
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Word_size = global_data.Base__Word_size,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Int0 = global_data.Base__Int0,
    cst_int63 = "int63",
    cst_int64$2 = cst_int64$3,
    cst_nativeint$1 = cst_nativeint$2,
    cst_int64$1 = cst_int64$3,
    cst_int32$2 = cst_int32$3,
    cst_nativeint$0 = cst_nativeint$2,
    cst_int32$1 = cst_int32$3,
    cst_int64$0 = cst_int64$3,
    cst_int$2 = cst_int$3,
    cst_nativeint = cst_nativeint$2,
    cst_int$1 = cst_int$3,
    cst_int64 = cst_int64$3,
    _d_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_int$0 = cst_int$3,
    cst_int32$0 = cst_int32$3,
    cst_int32 = cst_int32$3,
    cst_int = cst_int$3,
    _a_ =
      [0,
       [11,
        "conversion from ",
        [2,
         0,
         [11,
          " to ",
          [2, 0, [11, " failed: ", [2, 0, [11, " is out of range", 0]]]]]]],
       "conversion from %s to %s failed: %s is out of range"],
    _k_ = [0, cst_src_int_conversions_ml, 19, 9],
    _j_ = [0, cst_src_int_conversions_ml, 82, 9],
    _i_ = [0, cst_src_int_conversions_ml, 103, 9],
    _h_ = [0, cst_src_int_conversions_ml, 155, 9],
    _g_ = [0, cst_src_int_conversions_ml, 183, 9];
   function convert_failure(x, a, b, to_string){
    var _H_ = caml_call1(to_string, x);
    return caml_call5(Base_Printf[6], _a_, a, b, _H_, 0);
   }
   var
    num_bits_int = Base_Sys0[8],
    num_bits_nativeint = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    num_bits_int32 = 32,
    num_bits_int64 = 64;
   if(63 !== num_bits_int && 31 !== num_bits_int && 32 !== num_bits_int)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   var
    min_int32 = Stdlib_Int32[10],
    max_int32 = Stdlib_Int32[9],
    min_int64 = Stdlib_Int64[10],
    max_int64 = Stdlib_Int64[9],
    min_nativeint = Stdlib_Nativeint[11],
    max_nativeint = Stdlib_Nativeint[10],
    int64_to_string = Stdlib_Int64[14],
    nativeint_to_string = Stdlib_Nativeint[15],
    _b_ = Base_Import[85][33],
    _c_ = Stdlib_Int32[14];
   function int32_to_int_trunc(_G_){return _G_;}
   function int_to_int32_trunc(_F_){return _F_;}
   var
    int_is_representable_as_int32 =
      num_bits_int <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _D_ = caml_call2(Base_Import[228], min_int32, x) <= 0 ? 1 : 0,
          _E_ =
            _D_
             ? caml_call2(Base_Import[228], x, max_int32) <= 0 ? 1 : 0
             : _D_;
         return _E_;
        };
   if(32 <= num_bits_int)
    var int32_is_representable_as_int = function(param){return 1;};
   else
    var
     min$4 = Base_Int0[7],
     max$4 = Base_Int0[6],
     int32_is_representable_as_int =
       function(x){
        var
         _B_ = caml_call2(Base_Import[229], min$4, x) <= 0 ? 1 : 0,
         _C_ = _B_ ? caml_call2(Base_Import[229], x, max$4) <= 0 ? 1 : 0 : _B_;
        return _C_;
       };
   function int_to_int32(x){
    return int_is_representable_as_int32(x) ? [0, x] : 0;
   }
   function int32_to_int(x){
    return int32_is_representable_as_int(x) ? [0, x] : 0;
   }
   function int_to_int32_exn(x){
    return int_is_representable_as_int32(x)
            ? x
            : convert_failure(x, cst_int, cst_int32, _b_);
   }
   function int32_to_int_exn(x){
    return int32_is_representable_as_int(x)
            ? x
            : convert_failure(x, cst_int32$0, cst_int$0, _c_);
   }
   if(num_bits_int >= 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   var
    int_to_int64 = caml_int64_of_int32,
    int64_to_int_trunc = caml_int64_to_int32,
    min = caml_int64_of_int32(Base_Int0[7]),
    max = caml_int64_of_int32(Base_Int0[6]);
   function int64_is_representable_as_int(x){
    var
     _z_ = caml_call2(Base_Import[230], min, x) <= 0 ? 1 : 0,
     _A_ = _z_ ? caml_call2(Base_Import[230], x, max) <= 0 ? 1 : 0 : _z_;
    return _A_;
   }
   function int64_to_int(x){
    return int64_is_representable_as_int(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int_exn(x){
    return int64_is_representable_as_int(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (runtime.caml_int64_add(x, _d_),
               cst_int64,
               cst_int$1,
               int64_to_string);
   }
   if(num_bits_int > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   function int_to_nativeint(_y_){return _y_;}
   function nativeint_to_int_trunc(_x_){return _x_;}
   if(num_bits_nativeint <= num_bits_int)
    var _e_ = function(param){return 1;};
   else
    var
     min$3 = Base_Int0[7],
     max$3 = Base_Int0[6],
     _e_ =
       function(x){
        var
         _v_ = caml_call2(Base_Import[231], min$3, x) <= 0 ? 1 : 0,
         _w_ = _v_ ? caml_call2(Base_Import[231], x, max$3) <= 0 ? 1 : 0 : _v_;
        return _w_;
       };
   function nativeint_to_int(x){return _e_(x) ? [0, x] : 0;}
   function nativeint_to_int_exn(x){
    return _e_(x)
            ? x
            : convert_failure
              (x, cst_nativeint, cst_int$2, nativeint_to_string);
   }
   var
    int32_to_int64 = caml_int64_of_int32,
    int64_to_int32_trunc = caml_int64_to_int32,
    min$0 = caml_int64_of_int32(min_int32),
    max$0 = caml_int64_of_int32(max_int32);
   function int64_is_representable_as_int3(x){
    var
     _t_ = caml_call2(Base_Import[230], min$0, x) <= 0 ? 1 : 0,
     _u_ = _t_ ? caml_call2(Base_Import[230], x, max$0) <= 0 ? 1 : 0 : _t_;
    return _u_;
   }
   function int64_to_int32(x){
    return int64_is_representable_as_int3(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int32_exn(x){
    return int64_is_representable_as_int3(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64$0, cst_int32$1, int64_to_string);
   }
   if(32 > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   function int32_to_nativeint(_s_){return _s_;}
   function nativeint_to_int32_trunc(_r_){return _r_;}
   var
    _f_ =
      num_bits_nativeint <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _p_ = caml_call2(Base_Import[231], min_int32, x) <= 0 ? 1 : 0,
          _q_ =
            _p_
             ? caml_call2(Base_Import[231], x, max_int32) <= 0 ? 1 : 0
             : _p_;
         return _q_;
        };
   function nativeint_to_int32(x){return _f_(x) ? [0, x] : 0;}
   function nativeint_to_int32_exn(x){
    return _f_(x)
            ? x
            : convert_failure
              (x, cst_nativeint$0, cst_int32$2, nativeint_to_string);
   }
   if(num_bits_nativeint > 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   var
    int64_to_nativeint_trunc = caml_int64_to_int32,
    nativeint_to_int64 = caml_int64_of_int32;
   if(64 <= num_bits_nativeint)
    var int64_is_representable_as_nati = function(param){return 1;};
   else
    var
     min$2 = caml_int64_of_int32(min_nativeint),
     max$2 = caml_int64_of_int32(max_nativeint),
     int64_is_representable_as_nati =
       function(x){
        var
         _n_ = caml_call2(Base_Import[230], min$2, x) <= 0 ? 1 : 0,
         _o_ = _n_ ? caml_call2(Base_Import[230], x, max$2) <= 0 ? 1 : 0 : _n_;
        return _o_;
       };
   function int64_to_nativeint(x){
    return int64_is_representable_as_nati(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_nativeint_exn(x){
    return int64_is_representable_as_nati(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (x, cst_int64$1, cst_nativeint$1, int64_to_string);
   }
   var
    min$1 = caml_int64_shift_right(min_int64, 1),
    max$1 = caml_int64_shift_right(max_int64, 1);
   function int64_is_representable_as_int6(x){
    var
     _l_ = caml_call2(Base_Import[230], min$1, x) <= 0 ? 1 : 0,
     _m_ = _l_ ? caml_call2(Base_Import[230], x, max$1) <= 0 ? 1 : 0 : _l_;
    return _m_;
   }
   function int64_fit_on_int63_exn(x){
    return int64_is_representable_as_int6(x)
            ? 0
            : convert_failure(x, cst_int64$2, cst_int63, int64_to_string);
   }
   var
    Base_Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int32_is_representable_as_int,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint];
   runtime.caml_register_global
    (33, Base_Int_conversions, "Base__Int_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar0
//# unitInfo: Requires: Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    succ = Stdlib_Uchar[5],
    pred = Stdlib_Uchar[6],
    is_valid = Stdlib_Uchar[7],
    is_char = Stdlib_Uchar[11],
    unsafe_to_char = Stdlib_Uchar[14],
    unsafe_of_int = Stdlib_Uchar[9],
    of_int = Stdlib_Uchar[8],
    to_int = Stdlib_Uchar[10],
    of_char = Stdlib_Uchar[12],
    compare = Stdlib_Uchar[16],
    equal = Stdlib_Uchar[15],
    min_value = Stdlib_Uchar[1],
    max_value = Stdlib_Uchar[2],
    byte_order_mark = Stdlib_Uchar[3],
    replacement_char = Stdlib_Uchar[4],
    utf_8_byte_length = Stdlib_Uchar[23],
    utf_16_byte_length = Stdlib_Uchar[24],
    utf_decode_is_valid = Stdlib_Uchar[18],
    utf_decode_uchar = Stdlib_Uchar[19],
    utf_decode_length = Stdlib_Uchar[20],
    utf_decode = Stdlib_Uchar[21],
    utf_decode_invalid = Stdlib_Uchar[22],
    Base_Uchar0 =
      [0,
       succ,
       pred,
       is_valid,
       is_char,
       unsafe_to_char,
       unsafe_of_int,
       of_int,
       to_int,
       of_char,
       compare,
       equal,
       min_value,
       max_value,
       byte_order_mark,
       replacement_char,
       utf_8_byte_length,
       utf_16_byte_length,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid];
   runtime.caml_register_global(1, Base_Uchar0, "Base__Uchar0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String0
//# unitInfo: Requires: Base__Char0, Base__Import0, Base__Int_conversions, Base__Sys0, Base__Uchar0, Stdlib, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Base_Import0 = global_data.Base__Import0,
    Base_Char0 = global_data.Base__Char0,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Base_Sys0 = global_data.Base__Sys0,
    String = [0],
    max_length = Base_Sys0[10],
    symbol = Base_Import0[112],
    capitalize = Stdlib_StringLabels[28],
    compare = Stdlib_StringLabels[10],
    escaped = Stdlib_StringLabels[25],
    lowercase = Stdlib_StringLabels[27],
    make = Stdlib_StringLabels[1],
    sub = Stdlib_StringLabels[16],
    uncapitalize = Stdlib_StringLabels[29],
    uppercase = Stdlib_StringLabels[26],
    is_valid_utf_8 = Stdlib_StringLabels[44],
    is_valid_utf_16le = Stdlib_StringLabels[48],
    is_valid_utf_16be = Stdlib_StringLabels[46],
    cst_index_out_of_bounds = "index out of bounds";
   function get_utf_8_uchar(t, byte_pos){
    return caml_call2(Stdlib_StringLabels[43], t, byte_pos);
   }
   function get_utf_16le_uchar(t, byte_pos){
    return caml_call2(Stdlib_StringLabels[47], t, byte_pos);
   }
   function get_utf_16be_uchar(t, byte_pos){
    return caml_call2(Stdlib_StringLabels[45], t, byte_pos);
   }
   function get_utf_32_uchar(get_int32, t, byte_pos){
    var
     len = caml_ml_string_length(t),
     _j_ = 0 <= byte_pos ? 1 : 0,
     _k_ = _j_ ? byte_pos < len ? 1 : 0 : _j_;
    if(! _k_)
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_index_out_of_bounds], 1);
    var bytes_read = caml_call2(Base_Import0[93], len, byte_pos);
    if(2 >= bytes_read - 1 >>> 0)
     return caml_call1(Base_Uchar0[22], bytes_read);
    var int32 = caml_call2(get_int32, t, byte_pos);
    if(! caml_call1(Base_Int_conversions[11], int32))
     return caml_call1(Base_Uchar0[22], 4);
    var int$0 = caml_call1(Base_Int_conversions[8], int32);
    if(! caml_call1(Base_Uchar0[3], int$0))
     return caml_call1(Base_Uchar0[22], 4);
    var _l_ = caml_call1(Base_Uchar0[6], int$0);
    return caml_call2(Base_Uchar0[21], 4, _l_);
   }
   function get_utf_32le_uchar(t, byte_pos){
    return get_utf_32_uchar(Stdlib_StringLabels[61], t, byte_pos);
   }
   function get_utf_32be_uchar(t, byte_pos){
    return get_utf_32_uchar(Stdlib_StringLabels[60], t, byte_pos);
   }
   function concat(opt, l){
    if(opt) var sth = opt[1], sep = sth; else var sep = cst$0;
    if(! l) return cst;
    if(l[2]) return caml_call2(Stdlib_StringLabels[7], sep, l);
    var x = l[1];
    return x;
   }
   function iter(t, f){
    var
     _h_ = caml_call2(Base_Import0[93], caml_ml_string_length(t), 1),
     _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      caml_call1(f, runtime.caml_string_unsafe_get(t, i));
      var _i_ = i + 1 | 0;
      if(_h_ === i) break;
      var i = _i_;
     }
    }
    return 0;
   }
   function back_up_at_newline(t, pos, eol){
    a:
    {
     if(0 < pos[1]){
      var _e_ = caml_string_get(t, caml_call2(Base_Import0[93], pos[1], 1));
      if(caml_call2(Base_Char0[12], _e_, 13)){var _f_ = 2; break a;}
     }
     var _f_ = 1;
    }
    pos[1] = caml_call2(Base_Import0[93], pos[1], _f_);
    eol[1] = caml_call2(Base_Import0[91], pos[1], 1);
    return;
   }
   function split_lines(t){
    var n = caml_ml_string_length(t);
    if(0 === n) return 0;
    var
     pos = [0, caml_call2(Base_Import0[93], n, 1)],
     eol = [0, n],
     ac = [0, 0],
     _a_ = caml_string_get(t, pos[1]);
    if(caml_call2(Base_Char0[12], _a_, 10)) back_up_at_newline(t, pos, eol);
    for(;;){
     if(0 > pos[1]){
      var _d_ = ac[1];
      return [0, caml_call3(sub, t, 0, eol[1]), _d_];
     }
     var _b_ = caml_string_get(t, pos[1]);
     if(caml_call2(Base_Char0[12], _b_, 10)){
      var start = caml_call2(Base_Import0[91], pos[1], 1), _c_ = ac[1];
      ac[1] =
       [0,
        caml_call3(sub, t, start, caml_call2(Base_Import0[93], eol[1], start)),
        _c_];
      back_up_at_newline(t, pos, eol);
     }
     else
      pos[1] += -1;
    }
   }
   var
    Base_String0 =
      [0,
       String,
       max_length,
       symbol,
       capitalize,
       compare,
       escaped,
       lowercase,
       make,
       sub,
       uncapitalize,
       uppercase,
       is_valid_utf_8,
       is_valid_utf_16le,
       is_valid_utf_16be,
       get_utf_8_uchar,
       get_utf_16le_uchar,
       get_utf_16be_uchar,
       get_utf_32le_uchar,
       get_utf_32be_uchar,
       concat,
       iter,
       split_lines];
   runtime.caml_register_global(10, Base_String0, "Base__String0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position0
//# unitInfo: Requires: Base__Comparator, Base__Hash, Base__Import, Base__Int0, Base__String0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = ":";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Import = global_data.Base__Import,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Base_Hash = global_data.Base__Hash,
    Base_Comparator = global_data.Base__Comparator,
    _a_ = [0, "pos_cnum"],
    _b_ = [0, "pos_bol"],
    _c_ = [0, "pos_lnum"],
    _d_ = [0, "pos_fname"];
   function compare_local(a_001, b_002){
    if(a_001 === b_002) return 0;
    var n = caml_call2(Base_Import[260], a_001[1], b_002[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Base_Import[256], a_001[2], b_002[2]);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Base_Import[256], a_001[3], b_002[3]);
    return 0 === n$1 ? caml_call2(Base_Import[256], a_001[4], b_002[4]) : n$1;
   }
   function compare(a, b){return compare_local(a, b);}
   function hash_fold_t(hsv, arg){
    var
     hsv$0 = caml_call2(Base_Import[208], hsv, arg[1]),
     hsv$1 = caml_call2(Base_Import[206], hsv$0, arg[2]),
     hsv$2 = caml_call2(Base_Import[206], hsv$1, arg[3]);
    return caml_call2(Base_Import[206], hsv$2, arg[4]);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function sexp_of_t(param){
    var
     pos_cnum_010 = param[4],
     pos_bol_008 = param[3],
     pos_lnum_006 = param[2],
     pos_fname_004 = param[1],
     arg_011 = caml_call1(Base_Import[139], pos_cnum_010),
     bnds_003 = [0, [1, [0, _a_, [0, arg_011, 0]]], 0],
     arg_009 = caml_call1(Base_Import[139], pos_bol_008),
     bnds_003$0 = [0, [1, [0, _b_, [0, arg_009, 0]]], bnds_003],
     arg_007 = caml_call1(Base_Import[139], pos_lnum_006),
     bnds_003$1 = [0, [1, [0, _c_, [0, arg_007, 0]]], bnds_003$0],
     arg_005 = caml_call1(Base_Import[136], pos_fname_004),
     bnds_003$2 = [0, [1, [0, _d_, [0, arg_005, 0]]], bnds_003$1];
    return [1, bnds_003$2];
   }
   var
    T = [0, compare_local, compare, hash_fold_t, hash, sexp_of_t],
    compare_local$0 = T[1],
    compare$0 = T[2],
    hash_fold_t$0 = T[3],
    hash$0 = T[4],
    include = caml_call1(Base_Comparator[7], [0, T[2], T[5]]),
    comparator = include[1];
   function make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol){
    var
     _e_ = caml_call2(Base_Import[93], pos_cnum, pos_bol),
     _f_ = [0, cst, [0, caml_call1(Base_Int0[1], _e_), 0]],
     _g_ =
       [0,
        pos_fname,
        [0, cst$0, [0, caml_call1(Base_Int0[1], pos_lnum), _f_]]];
    return caml_call2(Base_String0[20], 0, _g_);
   }
   function to_string(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1];
    return make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol);
   }
   function sexp_of_t$0(t){return [0, to_string(t)];}
   var
    Base_Source_code_position0 =
      [0,
       T,
       compare_local$0,
       compare$0,
       hash_fold_t$0,
       hash$0,
       comparator,
       make_location_string,
       to_string,
       sexp_of_t$0];
   runtime.caml_register_global
    (11, Base_Source_code_position0, "Base__Source_code_position0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Invariant_intf = [0];
   runtime.caml_register_global
    (0, Base_Invariant_intf, "Base__Invariant_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List1
//# unitInfo: Requires: Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0,
    hd_exn = Base_List0[1],
    rev_append = Base_List0[2],
    tl_exn = Base_List0[3],
    unzip = Base_List0[4],
    length = Base_List0[5],
    exists = Base_List0[6],
    exists2_ok = Base_List0[7],
    fold = Base_List0[8],
    fold2_ok = Base_List0[9],
    for_all = Base_List0[10],
    for_all2_ok = Base_List0[11],
    iter = Base_List0[12],
    iter2_ok = Base_List0[13],
    nontail_map = Base_List0[14],
    nontail_mapi = Base_List0[15],
    partition = Base_List0[16],
    rev_map = Base_List0[17],
    rev_map2_ok = Base_List0[18],
    rev = Base_List0[19],
    fold_right = Base_List0[20],
    fold_right2_ok = Base_List0[21];
   function is_empty(param){return param ? 0 : 1;}
   function partition_map(t, f){
    var t$0 = t, fst = 0, snd = 0;
    for(;;){
     if(! t$0){
      var _a_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _a_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x);
     if(0 === match[0])
      var y = match[1], fst$0 = [0, y, fst], t$0 = t$1, fst = fst$0;
     else
      var y$0 = match[1], snd$0 = [0, y$0, snd], t$0 = t$1, snd = snd$0;
    }
   }
   var
    Base_List1 =
      [0,
       hd_exn,
       rev_append,
       tl_exn,
       unzip,
       length,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       rev,
       fold_right,
       fold_right2_ok,
       is_empty,
       partition_map];
   runtime.caml_register_global(1, Base_List1, "Base__List1");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Result
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Printf, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Error$0 = "Error",
    cst_Ok$0 = "Ok",
    cst_error = "error",
    cst_ok = "ok",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_005 = "result.ml.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Monad = global_data.Base__Monad,
    _c_ = [0, 0],
    cst_Error = cst_Error$0,
    cst_Ok = cst_Ok$0,
    _a_ = [0, cst_Ok$0],
    _b_ = [0, cst_Error$0];
   function t_of_sexp(of_a_001, of_b_002, sexp_007){
    a:
    {
     if(0 === sexp_007[0]){
      var _f_ = sexp_007[1];
      b:
      if(caml_string_notequal(_f_, cst_Error$0)){
       if(caml_string_notequal(_f_, cst_Ok$0)){
        if(! caml_string_notequal(_f_, cst_error)) break b;
        if(caml_string_notequal(_f_, cst_ok)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_005, sexp_007);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_005, sexp_007);
     }
     var _g_ = sexp_007[1];
     if(! _g_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_005, sexp_007);
     var _h_ = _g_[1];
     if(0 !== _h_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_005, sexp_007);
     var tag_008 = _h_[1];
     b:
     if(caml_string_notequal(tag_008, cst_Error$0)){
      if(caml_string_notequal(tag_008, cst_Ok$0)){
       if(! caml_string_notequal(tag_008, cst_error)) break b;
       if(caml_string_notequal(tag_008, cst_ok)) break a;
      }
      var sexp_args_009 = _g_[2];
      if(sexp_args_009 && ! sexp_args_009[2]){
       var
        arg0_010 = sexp_args_009[1],
        res0_011 = caml_call1(of_a_001, arg0_010);
       return [0, res0_011];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_005,
               tag_008,
               sexp_007);
     }
     var sexp_args_014 = _g_[2];
     if(sexp_args_014 && ! sexp_args_014[2]){
      var
       arg0_015 = sexp_args_014[1],
       res0_016 = caml_call1(of_b_002, arg0_015);
      return [1, res0_016];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_005,
              tag_008,
              sexp_007);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_005, sexp_007);
   }
   function sexp_of_t(of_a_019, of_b_020, param){
    if(0 === param[0]){
     var arg0_021 = param[1], res0_022 = caml_call1(of_a_019, arg0_021);
     return [1, [0, _a_, [0, res0_022, 0]]];
    }
    var arg0_023 = param[1], res0_024 = caml_call1(of_b_020, arg0_023);
    return [1, [0, _b_, [0, res0_024, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Ok, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Error, [0, [0, b_sexp_grammar, 0]]]], 0]]]];
   }
   function compare_local(cmp_a, cmp_b, a_033, b_034){
    if(a_033 === b_034) return 0;
    if(0 === a_033[0]){
     var a_035 = a_033[1];
     if(0 !== b_034[0]) return -1;
     var b_036 = b_034[1];
     return caml_call2(cmp_a, a_035, b_036);
    }
    var a_037 = a_033[1];
    if(0 === b_034[0]) return 1;
    var b_038 = b_034[1];
    return caml_call2(cmp_b, a_037, b_038);
   }
   function compare(cmp_a, cmp_b, a_027, b_028){
    if(a_027 === b_028) return 0;
    if(0 === a_027[0]){
     var a_029 = a_027[1];
     if(0 !== b_028[0]) return -1;
     var b_030 = b_028[1];
     return caml_call2(cmp_a, a_029, b_030);
    }
    var a_031 = a_027[1];
    if(0 === b_028[0]) return 1;
    var b_032 = b_028[1];
    return caml_call2(cmp_b, a_031, b_032);
   }
   function equal_local(cmp_a, cmp_b, a_045, b_046){
    if(a_045 === b_046) return 1;
    if(0 === a_045[0]){
     var a_047 = a_045[1];
     if(0 !== b_046[0]) return 0;
     var b_048 = b_046[1];
     return caml_call2(cmp_a, a_047, b_048);
    }
    var a_049 = a_045[1];
    if(0 === b_046[0]) return 0;
    var b_050 = b_046[1];
    return caml_call2(cmp_b, a_049, b_050);
   }
   function equal(cmp_a, cmp_b, a_039, b_040){
    if(a_039 === b_040) return 1;
    if(0 === a_039[0]){
     var a_041 = a_039[1];
     if(0 !== b_040[0]) return 0;
     var b_042 = b_040[1];
     return caml_call2(cmp_a, a_041, b_042);
    }
    var a_043 = a_039[1];
    if(0 === b_040[0]) return 0;
    var b_044 = b_040[1];
    return caml_call2(cmp_b, a_043, b_044);
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_a, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_b, hsv$1, a0$0);
   }
   var globalize = Base_Import[295];
   function bind(x, f){
    if(0 !== x[0]) return x;
    var x$0 = x[1];
    return caml_call1(f, x$0);
   }
   var
    map =
      [0,
       -198771759,
       function(x, f){
        if(0 !== x[0]) return x;
        var x$0 = x[1];
        return [0, caml_call1(f, x$0)];
       }];
   function return$0(x){return [0, x];}
   var
    include = caml_call1(Base_Monad[6], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function invariant(check_ok, check_error, t){
    if(0 === t[0]){var ok = t[1]; return caml_call1(check_ok, ok);}
    var error = t[1];
    return caml_call1(check_error, error);
   }
   function fail(x){return [1, x];}
   function failf(format){return caml_call2(Base_Printf[4], fail, format);}
   function map_error(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return [1, caml_call1(f, x)];
   }
   function bind$1(x, f){
    if(0 === x[0]) return x;
    var e = x[1];
    return caml_call1(f, e);
   }
   var map$1 = [0, -198771759, map_error];
   function return$2(e){return [1, e];}
   var Error = caml_call1(Base_Monad[6], [0, bind$1, map$1, return$2]);
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function ok(param){
    if(0 !== param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function error(param){
    if(0 === param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function of_option(opt, error){
    if(! opt) return [1, error];
    var x = opt[1];
    return [0, x];
   }
   function iter(v, f){
    if(0 !== v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function iter_error(v, f){
    if(0 === v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function to_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function of_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function ok_if_true(bool, error){return bool ? _c_ : [1, error];}
   function try_with(f){
    try{var _e_ = [0, caml_call1(f, 0)]; return _e_;}
    catch(exn$0){var exn = caml_wrap_exception(exn$0); return [1, exn];}
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    throw caml_maybe_attach_backtrace(exn, 1);
   }
   function ok_or_failwith(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var str = param[1];
    return caml_call1(Base_Import[124], str);
   }
   function combine(t1, t2, ok, err){
    if(0 === t1[0]){
     var ok1 = t1[1];
     if(0 === t2[0]){var ok2 = t2[1]; return [0, caml_call2(ok, ok1, ok2)];}
     var e = t2[1];
    }
    else{
     var err1 = t1[1];
     if(0 !== t2[0]){
      var err2 = t2[1];
      return [1, caml_call2(err, err1, err2)];
     }
     var e = err1;
    }
    return [1, e];
   }
   function combine_errors(l){
    var
     match = caml_call2(Base_List1[23], l, to_either),
     errs = match[2],
     ok = match[1];
    return errs ? [1, errs] : [0, ok];
   }
   function combine_errors_unit(l){
    function _d_(param){return 0;}
    return caml_call2(map$0, combine_errors(l), _d_);
   }
   var
    Base_Result =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       compare_local,
       equal,
       equal_local,
       hash_fold_t,
       globalize,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       Error,
       invariant,
       fail,
       failf,
       is_ok,
       is_error,
       ok,
       ok_exn,
       ok_or_failwith,
       error,
       of_option,
       iter,
       iter_error,
       map$0,
       map_error,
       combine,
       combine_errors,
       combine_errors_unit,
       to_either,
       of_either,
       ok_if_true,
       try_with,
       [0, is_ok, is_error]];
   runtime.caml_register_global(20, Base_Result, "Base__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Continue_or_stop = [0],
    Export = [0, Continue_or_stop],
    Continue_or_stop$0 = Export[1],
    Base_Container_intf = [0, Export, Continue_or_stop$0];
   runtime.caml_register_global
    (0, Base_Container_intf, "Base__Container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container
//# unitInfo: Requires: Base__Array0, Base__Container_intf, Base__Import, Base__List0, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_List0 = global_data.Base__List0,
    Base_Import = global_data.Base__Import,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iter(fold, t, f){
    return caml_call3
            (fold, t, 0, function(param, a){return caml_call1(f, a);});
   }
   function count(fold, t, f){
    return caml_call3
            (fold,
             t,
             0,
             function(n, a){
              return caml_call1(f, a) ? caml_call2(Base_Import[91], n, 1) : n;
             });
   }
   function sum(fold, M, t, f){
    function _u_(n, a){
     var _v_ = caml_call1(f, a);
     return caml_call2(M[2], n, _v_);
    }
    return caml_call3(fold, t, M[1], _u_);
   }
   function fold_result(fold, init, f, t){
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      caml_call3
                       (fold,
                        t,
                        init,
                        function(acc, item){
                         var e = caml_call2(f, acc, item);
                         if(0 !== e[0]) return caml_call1(param, e);
                         var x = e[1];
                         return x;
                        })];
             });
   }
   function fold_until(fold, init, f, finish, t){
    return caml_call1
            (with_return,
             function(param){
              return caml_call1
                      (finish,
                       caml_call3
                        (fold,
                         t,
                         init,
                         function(acc, item){
                          var match = caml_call2(f, acc, item);
                          if(0 === match[0]){var x = match[1]; return x;}
                          var x$0 = match[1];
                          return caml_call1(param, x$0);
                         }));
             });
   }
   function min_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var min = acc[1];
              return 0 < caml_call2(compare, min, elt) ? [0, elt] : acc;
             });
   }
   function max_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var max = acc[1];
              return 0 <= caml_call2(compare, max, elt) ? acc : [0, elt];
             });
   }
   function length(fold, c){
    return caml_call3
            (fold,
             c,
             0,
             function(acc, param){return caml_call2(Base_Import[91], acc, 1);});
   }
   function is_empty(iter, c){
    return caml_call1
            (with_return,
             function(r){
              caml_call2(iter, c, function(param){return caml_call1(r, 0);});
              return 1;
             });
   }
   function mem(iter, c, x, equal){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(y){
                 var _t_ = caml_call2(equal, x, y);
                 return _t_ ? caml_call1(r, 1) : _t_;
                });
              return 0;
             });
   }
   function exists(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _s_ = caml_call1(f, x);
                 return _s_ ? caml_call1(r, 1) : _s_;
                });
              return 0;
             });
   }
   function for_all(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _r_ = 1 - caml_call1(f, x);
                 return _r_ ? caml_call1(r, 0) : _r_;
                });
              return 1;
             });
   }
   function find_map(iter, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                t,
                function(x){
                 var res = caml_call1(f, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function find(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _q_ = caml_call1(f, x);
                 return _q_ ? caml_call1(r, [0, x]) : _q_;
                });
              return 0;
             });
   }
   function to_list(fold, c){
    var _p_ = caml_call3(fold, c, 0, function(acc, x){return [0, x, acc];});
    return caml_call1(Base_List0[19], _p_);
   }
   function to_array(length, iter, c){
    var array = [0, [0]], i = [0, 0];
    caml_call2
     (iter,
      c,
      function(x){
       if(0 === i[1]){
        var _n_ = caml_call1(length, c);
        array[1] = caml_call2(Base_Array0[4], _n_, x);
       }
       var _o_ = i[1];
       runtime.caml_check_bound(array[1], _o_)[1 + _o_] = x;
       i[1]++;
       return 0;
      });
    return array[1];
   }
   function Make_gen(T){
    var fold = T[1], match = T[2];
    if(typeof match === "number")
     var iter$0 = function(t, f){return iter(fold, t, f);};
    else
     var iter$1 = match[2], iter$0 = iter$1;
    var match$0 = T[3];
    if(typeof match$0 === "number")
     var length$0 = function(t){return length(fold, t);};
    else
     var length$1 = match$0[2], length$0 = length$1;
    function is_empty$0(t){return is_empty(iter$0, t);}
    function mem$0(t, x, equal){return mem(iter$0, t, x, equal);}
    function sum$0(m, t){return function(_m_){return sum(fold, m, t, _m_);};}
    function count$0(t, f){return count(fold, t, f);}
    function exists$0(t, f){return exists(iter$0, t, f);}
    function for_all$0(t, f){return for_all(iter$0, t, f);}
    function find_map$0(t, f){return find_map(iter$0, t, f);}
    function find$0(t, f){return find(iter$0, t, f);}
    function to_list$0(t){return to_list(fold, t);}
    function to_array$0(t){return to_array(length$0, iter$0, t);}
    function min_elt$0(t, compare){return min_elt(fold, t, compare);}
    function max_elt$0(t, compare){return max_elt(fold, t, compare);}
    function fold_result$0(t, init, f){return fold_result(fold, init, f, t);}
    function fold_until$0(t, init, f, finish){
     return fold_until(fold, init, f, finish, t);
    }
    return [0,
            length$0,
            is_empty$0,
            mem$0,
            iter$0,
            fold,
            fold_result$0,
            fold_until$0,
            exists$0,
            for_all$0,
            count$0,
            sum$0,
            find$0,
            find_map$0,
            to_list$0,
            to_array$0,
            min_elt$0,
            max_elt$0];
   }
   function Make_gen_with_creators(T){
    var
     include = Make_gen([0, T[1], T[2], T[3]]),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     of_list = T[4],
     of_array = T[5],
     concat = T[6],
     concat_of_array = T[7];
    function append(a, b){
     return caml_call1(concat, caml_call1(concat_of_array, [0, a, b]));
    }
    function concat_map(t, f){
     var _l_ = caml_call1(to_array, t);
     return caml_call1
             (concat,
              caml_call1(concat_of_array, caml_call2(Base_Array0[21], _l_, f)));
    }
    function filter_map(t, f){
     return concat_map
             (t,
              function(x){
               var match = caml_call1(f, x);
               if(! match) return caml_call1(of_array, [0]);
               var y = match[1];
               return caml_call1(of_array, [0, y]);
              });
    }
    function map(t, f){
     return filter_map(t, function(x){return [0, caml_call1(f, x)];});
    }
    function filter(t, f){
     return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
    }
    function partition_map(t, f){
     var
      _f_ = caml_call1(to_array, t),
      array = caml_call2(Base_Array0[21], _f_, f),
      _g_ = 0;
     function _h_(either, acc){
      if(0 !== either[0]) return acc;
      var x = either[1];
      return [0, x, acc];
     }
     var xs = caml_call3(Base_Array0[18], array, _h_, _g_), _i_ = 0;
     function _j_(either, acc){
      if(0 === either[0]) return acc;
      var x = either[1];
      return [0, x, acc];
     }
     var
      ys = caml_call3(Base_Array0[18], array, _j_, _i_),
      _k_ = caml_call1(of_list, ys);
     return [0, caml_call1(of_list, xs), _k_];
    }
    function partition_tf(t, f){
     return partition_map
             (t, function(x){return caml_call1(f, x) ? [0, x] : [1, x];});
    }
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            of_list,
            of_array,
            append,
            concat,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map];
   }
   function _a_(T){
    var
     fold = T[2],
     iter = T[3],
     length = T[4],
     of_list = T[5],
     of_array = T[6],
     concat = T[7],
     concat_of_array = Base_Array0[16],
     include =
       Make_gen_with_creators
        ([0, fold, iter, length, of_list, of_array, concat, concat_of_array]),
     length$0 = include[1],
     is_empty = include[2],
     iter$0 = include[4],
     fold$0 = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     of_list$0 = include[18],
     of_array$0 = include[19],
     append = include[20],
     concat$0 = include[21],
     map = include[22],
     filter = include[23],
     filter_map = include[24],
     concat_map = include[25],
     partition_tf = include[26],
     partition_map = include[27],
     _e_ = include[3];
    function mem(t, x){return caml_call3(_e_, t, x, T[1][1]);}
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            of_list$0,
            of_array$0,
            append,
            concat$0,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map];
   }
   function _b_(T){
    var
     fold = T[1],
     iter = T[2],
     length = T[3],
     of_list = T[4],
     of_array = T[5],
     concat = T[6],
     include =
       Make_gen_with_creators
        ([0, fold, iter, length, of_list, of_array, concat, of_array]),
     length$0 = include[1],
     is_empty = include[2],
     mem = include[3],
     iter$0 = include[4],
     fold$0 = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     of_list$0 = include[18],
     of_array$0 = include[19],
     append = include[20],
     concat$0 = include[21],
     map = include[22],
     filter = include[23],
     filter_map = include[24],
     concat_map = include[25],
     partition_tf = include[26],
     partition_map = include[27];
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            of_list$0,
            of_array$0,
            append,
            concat$0,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map];
   }
   function _c_(T){
    var
     fold = T[2],
     iter = T[3],
     length = T[4],
     include = Make_gen([0, fold, iter, length]),
     length$0 = include[1],
     is_empty = include[2],
     iter$0 = include[4],
     fold$0 = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     _d_ = include[3];
    function mem(t, x){return caml_call3(_d_, t, x, T[1][1]);}
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt];
   }
   var
    Base_Container =
      [0,
       iter,
       count,
       min_elt,
       max_elt,
       length,
       to_list,
       sum,
       fold_result,
       fold_until,
       is_empty,
       mem,
       exists,
       for_all,
       find,
       find_map,
       to_array,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         mem = include[3],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       _c_,
       Make_gen,
       _b_,
       _a_,
       Make_gen_with_creators];
   runtime.caml_register_global(4, Base_Container, "Base__Container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Indexed_container_intf = [0];
   runtime.caml_register_global
    (0, Base_Indexed_container_intf, "Base__Indexed_container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container
//# unitInfo: Requires: Base__Array0, Base__Container, Base__Import, Base__Indexed_container_intf, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_Container = global_data.Base__Container,
    Base_Import = global_data.Base__Import,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iteri(fold, t, f){
    caml_call3
     (fold,
      t,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return caml_call2(Base_Import[91], i, 1);
      });
    return 0;
   }
   function foldi(fold, t, init, f){
    var i = [0, 0];
    return caml_call3
            (fold,
             t,
             init,
             function(acc, v){
              var acc$0 = caml_call3(f, i[1], acc, v);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return acc$0;
             });
   }
   function counti(foldi, t, f){
    return caml_call3
            (foldi,
             t,
             0,
             function(i, n, a){
              return caml_call2(f, i, a)
                      ? caml_call2(Base_Import[91], n, 1)
                      : n;
             });
   }
   function existsi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _k_ = caml_call2(f, i, x);
                 return _k_ ? caml_call1(r, 1) : _k_;
                });
              return 0;
             });
   }
   function for_alli(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _j_ = 1 - caml_call2(f, i, x);
                 return _j_ ? caml_call1(r, 0) : _j_;
                });
              return 1;
             });
   }
   function find_mapi(iteri, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                t,
                function(i, x){
                 var res = caml_call2(f, i, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function findi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _i_ = caml_call2(f, i, x);
                 return _i_ ? caml_call1(r, [0, [0, i, x]]) : _i_;
                });
              return 0;
             });
   }
   function Make_gen_with_container(T, _h_){
    var
     length = _h_[1],
     is_empty = _h_[2],
     mem = _h_[3],
     iter = _h_[4],
     fold = _h_[5],
     fold_result = _h_[6],
     fold_until = _h_[7],
     exists = _h_[8],
     for_all = _h_[9],
     count = _h_[10],
     sum = _h_[11],
     find = _h_[12],
     find_map = _h_[13],
     to_list = _h_[14],
     to_array = _h_[15],
     min_elt = _h_[16],
     max_elt = _h_[17],
     match = T[4];
    if(typeof match === "number")
     var iteri$0 = function(t, f){return iteri(fold, t, f);};
    else
     var iteri$1 = match[2], iteri$0 = iteri$1;
    var match$0 = T[5];
    if(typeof match$0 === "number")
     var foldi$0 = function(t, init, f){return foldi(fold, t, init, f);};
    else
     var foldi$1 = match$0[2], foldi$0 = foldi$1;
    function counti$0(t, f){return counti(foldi$0, t, f);}
    function existsi$0(t, f){return existsi(iteri$0, t, f);}
    function for_alli$0(t, f){return for_alli(iteri$0, t, f);}
    function find_mapi$0(t, f){return find_mapi(iteri$0, t, f);}
    function findi$0(t, f){return findi(iteri$0, t, f);}
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi$0,
            for_alli$0,
            counti$0,
            findi$0,
            find_mapi$0];
   }
   function Make_gen(T){
    var
     C = caml_call1(Base_Container[19], [0, T[1], T[2], T[3]]),
     include = Make_gen_with_container(T, C),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     foldi = include[18],
     iteri = include[19],
     existsi = include[20],
     for_alli = include[21],
     counti = include[22],
     findi = include[23],
     find_mapi = include[24];
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi,
            iteri,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi];
   }
   function Make_gen_with_creators(T){
    var
     C =
       caml_call1
        (Base_Container[22], [0, T[5], T[6], T[7], T[2], T[3], T[4], T[1]]),
     of_list = C[18],
     of_array = C[19],
     append = C[20],
     concat = C[21],
     map = C[22],
     filter = C[23],
     filter_map = C[24],
     concat_map = C[25],
     partition_tf = C[26],
     partition_map = C[27],
     include =
       Make_gen_with_container
        ([0, T[5], T[6], T[7], T[8], T[9]],
         [0,
          C[1],
          C[2],
          C[3],
          C[4],
          C[5],
          C[6],
          C[7],
          C[8],
          C[9],
          C[10],
          C[11],
          C[12],
          C[13],
          C[14],
          C[15],
          C[16],
          C[17]]),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     foldi = include[18],
     iteri = include[19],
     existsi = include[20],
     for_alli = include[21],
     counti = include[22],
     findi = include[23],
     find_mapi = include[24];
    function derived_init(n, f){
     return caml_call1(of_array, caml_call2(Base_Array0[12], n, f));
    }
    var match = T[10];
    if(typeof match === "number")
     var derived_init$0 = derived_init;
    else
     var init = match[2], derived_init$0 = init;
    function derived_concat_mapi(t, f){
     var
      _f_ = caml_call1(to_array, t),
      _g_ = caml_call2(Base_Array0[22], _f_, f);
     return caml_call1(concat, caml_call1(T[1], _g_));
    }
    var match$0 = T[11];
    if(typeof match$0 === "number")
     var concat_mapi = derived_concat_mapi;
    else
     var concat_mapi$0 = match$0[2], concat_mapi = concat_mapi$0;
    function filter_mapi(t, f){
     return caml_call2
             (concat_mapi,
              t,
              function(i, x){
               var match = caml_call2(f, i, x);
               if(! match) return caml_call1(of_array, [0]);
               var y = match[1];
               return caml_call1(of_array, [0, y]);
              });
    }
    function mapi(t, f){
     return filter_mapi(t, function(i, x){return [0, caml_call2(f, i, x)];});
    }
    function filteri(t, f){
     return filter_mapi
             (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
    }
    return [0,
            of_list,
            of_array,
            append,
            concat,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi,
            iteri,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi,
            derived_init$0,
            mapi,
            filteri,
            filter_mapi,
            concat_mapi];
   }
   function _a_(T){
    var
     of_list = T[2],
     of_array = T[3],
     concat = T[4],
     fold = T[5],
     iter = T[6],
     length = T[7],
     iteri = T[8],
     foldi = T[9],
     init = T[10],
     concat_mapi = T[11],
     concat_of_array = Base_Array0[16],
     include =
       Make_gen_with_creators
        ([0,
          concat_of_array,
          of_list,
          of_array,
          concat,
          fold,
          iter,
          length,
          iteri,
          foldi,
          init,
          concat_mapi]),
     of_list$0 = include[1],
     of_array$0 = include[2],
     append = include[3],
     concat$0 = include[4],
     map = include[5],
     filter = include[6],
     filter_map = include[7],
     concat_map = include[8],
     partition_tf = include[9],
     partition_map = include[10],
     length$0 = include[11],
     is_empty = include[12],
     iter$0 = include[14],
     fold$0 = include[15],
     fold_result = include[16],
     fold_until = include[17],
     exists = include[18],
     for_all = include[19],
     count = include[20],
     sum = include[21],
     find = include[22],
     find_map = include[23],
     to_list = include[24],
     to_array = include[25],
     min_elt = include[26],
     max_elt = include[27],
     foldi$0 = include[28],
     iteri$0 = include[29],
     existsi = include[30],
     for_alli = include[31],
     counti = include[32],
     findi = include[33],
     find_mapi = include[34],
     init$0 = include[35],
     mapi = include[36],
     filteri = include[37],
     filter_mapi = include[38],
     concat_mapi$0 = include[39],
     _e_ = include[13];
    function mem(t, x){return caml_call3(_e_, t, x, T[1][1]);}
    return [0,
            of_list$0,
            of_array$0,
            append,
            concat$0,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi,
            init$0,
            mapi,
            filteri,
            filter_mapi,
            concat_mapi$0];
   }
   function _b_(T){
    var
     of_list = T[1],
     of_array = T[2],
     concat = T[3],
     fold = T[4],
     iter = T[5],
     length = T[6],
     iteri = T[7],
     foldi = T[8],
     init = T[9],
     concat_mapi = T[10],
     include =
       Make_gen_with_creators
        ([0,
          of_array,
          of_list,
          of_array,
          concat,
          fold,
          iter,
          length,
          iteri,
          foldi,
          init,
          concat_mapi]),
     of_list$0 = include[1],
     of_array$0 = include[2],
     append = include[3],
     concat$0 = include[4],
     map = include[5],
     filter = include[6],
     filter_map = include[7],
     concat_map = include[8],
     partition_tf = include[9],
     partition_map = include[10],
     length$0 = include[11],
     is_empty = include[12],
     mem = include[13],
     iter$0 = include[14],
     fold$0 = include[15],
     fold_result = include[16],
     fold_until = include[17],
     exists = include[18],
     for_all = include[19],
     count = include[20],
     sum = include[21],
     find = include[22],
     find_map = include[23],
     to_list = include[24],
     to_array = include[25],
     min_elt = include[26],
     max_elt = include[27],
     foldi$0 = include[28],
     iteri$0 = include[29],
     existsi = include[30],
     for_alli = include[31],
     counti = include[32],
     findi = include[33],
     find_mapi = include[34],
     init$0 = include[35],
     mapi = include[36],
     filteri = include[37],
     filter_mapi = include[38],
     concat_mapi$0 = include[39];
    return [0,
            of_list$0,
            of_array$0,
            append,
            concat$0,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi,
            init$0,
            mapi,
            filteri,
            filter_mapi,
            concat_mapi$0];
   }
   function _c_(T){
    var
     fold = T[2],
     iter = T[3],
     length = T[4],
     iteri = T[5],
     foldi = T[6],
     include = Make_gen([0, fold, iter, length, iteri, foldi]),
     length$0 = include[1],
     is_empty = include[2],
     iter$0 = include[4],
     fold$0 = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     foldi$0 = include[18],
     iteri$0 = include[19],
     existsi = include[20],
     for_alli = include[21],
     counti = include[22],
     findi = include[23],
     find_mapi = include[24],
     _d_ = include[3];
    function mem(t, x){return caml_call3(_d_, t, x, T[1][1]);}
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi];
   }
   var
    Base_Indexed_container =
      [0,
       foldi,
       iteri,
       counti,
       existsi,
       for_alli,
       findi,
       find_mapi,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         iteri = T[4],
         foldi = T[5],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         mem = include[3],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         foldi$0 = include[18],
         iteri$0 = include[19],
         existsi = include[20],
         for_alli = include[21],
         counti = include[22],
         findi = include[23],
         find_mapi = include[24];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       _c_,
       Make_gen,
       _b_,
       _a_,
       Make_gen_with_creators];
   runtime.caml_register_global
    (4, Base_Indexed_container, "Base__Indexed_container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Lazy
//# unitInfo: Requires: Base__Globalize, Base__Hash, Base__Import, Base__Monad, CamlinternalLazy, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Import = global_data.Base__Import,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base_Globalize = global_data.Base__Globalize,
    Base_Hash = global_data.Base__Hash,
    Base_Monad = global_data.Base__Monad,
    Undefined = Stdlib_Lazy[1],
    is_val = Stdlib_Lazy[3],
    from_val = Stdlib_Lazy[4],
    from_fun = Stdlib_Lazy[6],
    force_val = Stdlib_Lazy[7],
    t_of_sexp = Base_Import[169],
    sexp_of_t = Base_Import[145],
    cst_unforced_lazy = "<unforced lazy>";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[192], a_sexp_grammar);
   }
   var globalize = Base_Globalize[12];
   function _a_(t, f){
    return [246,
            function(_s_){
             var _t_ = caml_obj_tag(t);
             a:
             if(250 === _t_)
              var _u_ = t[1];
             else{
              if(246 !== _t_ && 244 !== _t_){var _u_ = t; break a;}
              var _u_ = caml_call1(CamlinternalLazy[2], t);
             }
             return caml_call1(f, _u_);
            }];
   }
   function compare_local(compare_a, t1, t2){
    if(t1 === t2) return 0;
    var _o_ = caml_obj_tag(t2);
    a:
    if(250 === _o_)
     var _p_ = t2[1];
    else{
     if(246 !== _o_ && 244 !== _o_){var _p_ = t2; break a;}
     var _p_ = caml_call1(CamlinternalLazy[2], t2);
    }
    var _q_ = caml_obj_tag(t1);
    a:
    if(250 === _q_)
     var _r_ = t1[1];
    else{
     if(246 !== _q_ && 244 !== _q_){var _r_ = t1; break a;}
     var _r_ = caml_call1(CamlinternalLazy[2], t1);
    }
    return caml_call2(compare_a, _r_, _p_);
   }
   function compare(compare_a, t1, t2){
    return compare_local(compare_a, t1, t2);
   }
   function equal_local(equal_a, t1, t2){
    if(t1 === t2) return 1;
    var _k_ = caml_obj_tag(t2);
    a:
    if(250 === _k_)
     var _l_ = t2[1];
    else{
     if(246 !== _k_ && 244 !== _k_){var _l_ = t2; break a;}
     var _l_ = caml_call1(CamlinternalLazy[2], t2);
    }
    var _m_ = caml_obj_tag(t1);
    a:
    if(250 === _m_)
     var _n_ = t1[1];
    else{
     if(246 !== _m_ && 244 !== _m_){var _n_ = t1; break a;}
     var _n_ = caml_call1(CamlinternalLazy[2], t1);
    }
    return caml_call2(equal_a, _n_, _l_);
   }
   function equal(equal_a, t1, t2){return equal_local(equal_a, t1, t2);}
   var hash_fold_t = Base_Hash[13][12];
   function peek(t){
    if(! caml_call1(is_val, t)) return 0;
    var _i_ = caml_obj_tag(t);
    a:
    if(250 === _i_)
     var _j_ = t[1];
    else{
     if(246 !== _i_ && 244 !== _i_){var _j_ = t; break a;}
     var _j_ = caml_call1(CamlinternalLazy[2], t);
    }
    return [0, _j_];
   }
   function return$0(x){return caml_call1(from_val, x);}
   function bind(t, f){
    return [246,
            function(_d_){
             var _e_ = caml_obj_tag(t);
             a:
             if(250 === _e_)
              var _f_ = t[1];
             else{
              if(246 !== _e_ && 244 !== _e_){var _f_ = t; break a;}
              var _f_ = caml_call1(CamlinternalLazy[2], t);
             }
             var _g_ = caml_call1(f, _f_), _h_ = caml_obj_tag(_g_);
             if(250 === _h_) return _g_[1];
             if(246 !== _h_ && 244 !== _h_) return _g_;
             return caml_call1(CamlinternalLazy[2], _g_);
            }];
   }
   var
    map = [0, -198771759, _a_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function sexp_of_t$0(sexp_of_a, t){
    if(! caml_call1(is_val, t))
     return caml_call1(Base_Import[136], cst_unforced_lazy);
    var _b_ = caml_obj_tag(t);
    a:
    if(250 === _b_)
     var _c_ = t[1];
    else{
     if(246 !== _b_ && 244 !== _b_){var _c_ = t; break a;}
     var _c_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call1(sexp_of_a, _c_);
   }
   var
    T_unforcing = [0, sexp_of_t$0],
    Base_Lazy =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       peek,
       T_unforcing];
   runtime.caml_register_global(7, Base_Lazy, "Base__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Info_intf = [0];
   runtime.caml_register_global(0, Base_Info_intf, "Base__Info_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common0
//# unitInfo: Requires: Base__Import, Base__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    invalid_argf = Base_Printf[7],
    _a_ =
      [0,
       [11, "Negative position: ", [4, 0, 0, 0, 0]],
       "Negative position: %d"],
    _b_ =
      [0, [11, "Negative length: ", [4, 0, 0, 0, 0]], "Negative length: %d"],
    _c_ =
      [0,
       [11,
        "pos + len past end: ",
        [4, 0, 0, 0, [11, " + ", [4, 0, 0, 0, [11, " > ", [4, 0, 0, 0, 0]]]]]],
       "pos + len past end: %d + %d > %d"];
   function slow_check_pos_len_exn(pos, len, total_length){
    if(pos < 0) caml_call3(invalid_argf, _a_, pos, 0);
    if(len < 0) caml_call3(invalid_argf, _b_, len, 0);
    var _h_ = caml_call2(Base_Import[93], total_length, len) < pos ? 1 : 0;
    return _h_
            ? caml_call5(invalid_argf, _c_, pos, len, total_length, 0)
            : _h_;
   }
   function check_pos_len_exn(pos, len, total_length){
    var
     stop = caml_call2(Base_Import[91], pos, len),
     _d_ = caml_call2(Base_Import[93], total_length, stop),
     _e_ = caml_call2(Base_Import[118], pos, len),
     _f_ = caml_call2(Base_Import[118], _e_, stop),
     _g_ = caml_call2(Base_Import[118], _f_, _d_) < 0 ? 1 : 0;
    return _g_ ? slow_check_pos_len_exn(pos, len, total_length) : _g_;
   }
   function get_pos_len_exn(opt, len, param, total_length){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], len$0 = i;
    else
     var len$0 = caml_call2(Base_Import[93], total_length, pos);
    check_pos_len_exn(pos, len$0, total_length);
    return [0, pos, len$0];
   }
   var
    Private = [0, slow_check_pos_len_exn],
    Base_Ordered_collection_common =
      [0, get_pos_len_exn, check_pos_len_exn, Private];
   runtime.caml_register_global
    (5, Base_Ordered_collection_common, "Base__Ordered_collection_common0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random_repr
//# unitInfo: Requires: Stdlib__Bigarray, Stdlib__Domain, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random;
   function of_state(_c_){return _c_;}
   var Repr = [0, of_state];
   function assign(t, state){
    var
     _b_ = caml_call1(Stdlib_Domain[10][2], t),
     dst = caml_call1(Repr[1], _b_),
     src = caml_call1(Repr[1], state);
    return runtime.caml_ba_blit(src, dst);
   }
   function make(state){
    function split_from_parent(v){
     return caml_call1(Stdlib_Random[15][15], v);
    }
    function _a_(param){return state;}
    var t = caml_call2(Stdlib_Domain[10][1], [0, split_from_parent], _a_);
    caml_call1(Stdlib_Domain[10][2], t);
    return t;
   }
   function make_lazy(f){
    function split_from_parent(v){
     return caml_call1(Stdlib_Random[15][15], v);
    }
    return caml_call2(Stdlib_Domain[10][1], [0, split_from_parent], f);
   }
   function get_state(t){return caml_call1(Stdlib_Domain[10][2], t);}
   var Base_Random_repr = [0, Repr, assign, make, make_lazy, get_state];
   runtime.caml_register_global(2, Base_Random_repr, "Base__Random_repr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random
//# unitInfo: Requires: Base__Char0, Base__Import, Base__Int0, Base__Printf, Base__Random_repr, Base__Word_size, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_int64_xor = runtime.caml_int64_xor;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Random_repr = global_data.Base__Random_repr,
    Base_Import = global_data.Base__Import,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Int0 = global_data.Base__Int0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Char0 = global_data.Base__Char0,
    Base_Word_size = global_data.Base__Word_size,
    cst_float = "float",
    cst_int64 = "int64",
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_nativeint = "nativeint",
    cst_int32 = "int32",
    cst_int = "int",
    _a_ =
      [0,
       [11,
        "Random.",
        [2,
         0,
         [11, ": crossed bounds [", [2, 0, [11, " > ", [2, 0, [12, 93, 0]]]]]]],
       "Random.%s: crossed bounds [%s > %s]"],
    cst_initializing_Random_with_a =
      "initializing Random with a nondeterministic seed is forbidden in inline tests";
   function forbid_nondeterminism_in_tests(allow_in_tests){
    var _D_ = Base_Import[129];
    if(! _D_) return _D_;
    if(allow_in_tests && allow_in_tests[1]) return;
    return caml_call1(Base_Import[124], cst_initializing_Random_with_a);
   }
   function bits(t){
    var _C_ = caml_call1(Base_Random_repr[5], t);
    return caml_call1(Stdlib_Random[15][4], _C_);
   }
   function bits64(t){
    var _B_ = caml_call1(Base_Random_repr[5], t);
    return caml_call1(Stdlib_Random[15][13], _B_);
   }
   function bool(t){
    var _A_ = caml_call1(Base_Random_repr[5], t);
    return caml_call1(Stdlib_Random[15][11], _A_);
   }
   function int$0(t, x){
    var _z_ = caml_call1(Base_Random_repr[5], t);
    return caml_call2(Stdlib_Random[15][5], _z_, x);
   }
   function int32(t, x){
    var _y_ = caml_call1(Base_Random_repr[5], t);
    return caml_call2(Stdlib_Random[15][7], _y_, x);
   }
   function int64(t, x){
    var _x_ = caml_call1(Base_Random_repr[5], t);
    return caml_call2(Stdlib_Random[15][9], _x_, x);
   }
   function nativeint(t, x){
    var _w_ = caml_call1(Base_Random_repr[5], t);
    return caml_call2(Stdlib_Random[15][8], _w_, x);
   }
   function make(seed){
    var _v_ = caml_call1(Stdlib_Random[15][1], seed);
    return caml_call1(Base_Random_repr[3], _v_);
   }
   function copy(t){
    var
     _t_ = caml_call1(Base_Random_repr[5], t),
     _u_ = caml_call1(Stdlib_Random[15][3], _t_);
    return caml_call1(Base_Random_repr[3], _u_);
   }
   function char$0(t){
    var _s_ = int$0(t, 256);
    return caml_call1(Base_Char0[5], _s_);
   }
   function ascii(t){
    var _r_ = int$0(t, 128);
    return caml_call1(Base_Char0[5], _r_);
   }
   function make_self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return caml_call1(Base_Random_repr[4], Stdlib_Random[15][2]);
   }
   var assign = Base_Random_repr[2];
   if(Base_Import[129]){
    var t = caml_call1(Stdlib_Random[16], 0);
    caml_call1(Stdlib_Random[1], 137);
    var default$0 = caml_call1(Base_Random_repr[3], t);
   }
   else
    var default$0 = make_self_init(0, 0);
   function int_on_64bits(t, bound){
    return 1073741823 < bound
            ? caml_int64_to_int32(int64(t, caml_int64_of_int32(bound)))
            : int$0(t, bound);
   }
   function int_on_32bits(t, bound){
    return 1073741823 < bound ? int32(t, bound) : int$0(t, bound);
   }
   var int$1 = Base_Word_size[3] ? int_on_64bits : int_on_32bits;
   function bits$0(state){return caml_int64_of_int32(bits(state));}
   function full_range_int64(state){
    var
     _p_ = caml_int64_shift_left(bits$0(state), 60),
     _q_ = caml_int64_xor(caml_int64_shift_left(bits$0(state), 30), _p_);
    return caml_int64_xor(bits$0(state), _q_);
   }
   function bits$1(state){return bits(state);}
   function full_range_int32(state){
    var _o_ = bits$1(state) << 30;
    return bits$1(state) ^ _o_;
   }
   function full_range_int_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_int_on_32bits(state){return full_range_int32(state);}
   var
    full_range_int_on_64bits$0 =
      Base_Word_size[3] ? full_range_int_on_64bits : full_range_int_on_32bits;
   function full_range_nativeint_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_nativeint_on_32bits(state){return full_range_int32(state);
   }
   var
    full_range_nativeint =
      Base_Word_size[3]
       ? full_range_nativeint_on_64bits
       : full_range_nativeint_on_32bits;
   function raise_crossed_bounds
   (name, lower_bound, upper_bound, string_of_bound){
    var
     _m_ = caml_call1(string_of_bound, upper_bound),
     _n_ = caml_call1(string_of_bound, lower_bound);
    return caml_call5(Base_Printf[6], _a_, name, _n_, _m_, 0);
   }
   function int_incl(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_int, lo, hi, Base_Int0[1]);
    var diff = caml_call2(Base_Import[93], hi, lo);
    if(diff === Base_Int0[6]){
     var
      _i_ = Base_Int0[6],
      _j_ = full_range_int_on_64bits$0(state),
      _k_ = caml_call2(Base_Import[116], _j_, _i_);
     return caml_call2(Base_Import[91], lo, _k_);
    }
    if(0 <= diff){
     var _l_ = int$1(state, caml_call1(Base_Int0[8], diff));
     return caml_call2(Base_Import[91], lo, _l_);
    }
    for(;;){
     var int$0 = full_range_int_on_64bits$0(state);
     if(lo <= int$0 && int$0 <= hi) return int$0;
    }
   }
   function int32_incl(state, lo, hi){
    if(caml_call2(Base_Import[102][5], lo, hi))
     raise_crossed_bounds(cst_int32, lo, hi, Stdlib_Int32[14]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[102][4], diff, Stdlib_Int32[9])){
     var _h_ = Stdlib_Int32[9];
     return lo + (full_range_int32(state) & _h_) | 0;
    }
    if(caml_call2(Base_Import[102][6], diff, 0))
     return lo + int32(state, caml_call1(Stdlib_Int32[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_int32(state);
     if
      (caml_call2(Base_Import[102][6], int$0, lo)
       && caml_call2(Base_Import[102][2], int$0, hi))
      return int$0;
    }
   }
   function nativeint_incl(state, lo, hi){
    if(caml_call2(Base_Import[104][5], lo, hi))
     raise_crossed_bounds(cst_nativeint, lo, hi, Stdlib_Nativeint[15]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[104][4], diff, Stdlib_Nativeint[10])){
     var _g_ = Stdlib_Nativeint[10];
     return lo + (full_range_nativeint(state) & _g_) | 0;
    }
    if(caml_call2(Base_Import[104][6], diff, 0))
     return lo + nativeint(state, caml_call1(Stdlib_Nativeint[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_nativeint(state);
     if
      (caml_call2(Base_Import[104][6], int$0, lo)
       && caml_call2(Base_Import[104][2], int$0, hi))
      return int$0;
    }
   }
   function int64_incl(state, lo, hi){
    if(runtime.caml_greaterthan(lo, hi))
     raise_crossed_bounds(cst_int64, lo, hi, Stdlib_Int64[14]);
    var diff = runtime.caml_int64_sub(hi, lo);
    if(runtime.caml_equal(diff, Stdlib_Int64[9])){
     var _f_ = Stdlib_Int64[9];
     return caml_int64_add
             (lo, runtime.caml_int64_and(full_range_int64(state), _f_));
    }
    if(caml_greaterequal(diff, _b_))
     return caml_int64_add
             (lo, int64(state, caml_call1(Stdlib_Int64[6], diff)));
    for(;;){
     var int$0 = full_range_int64(state);
     if(caml_greaterequal(int$0, lo) && runtime.caml_lessequal(int$0, hi))
      return int$0;
    }
   }
   function float$0(state, hi){
    for(;;){
     var
      r1 = bits(state),
      r2 = bits(state),
      _d_ = caml_call2(Base_Import[90], r1, 9.313225746154785e-10),
      _e_ = caml_call2(Base_Import[92], _d_, r2),
      result = caml_call2(Base_Import[90], _e_, 9.313225746154785e-10);
     if(result < 1.) return caml_call2(Base_Import[90], result, hi);
    }
   }
   function float_range(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_float, lo, hi, Base_Import[85][35]);
    var _c_ = float$0(state, caml_call2(Base_Import[94], hi, lo));
    return caml_call2(Base_Import[92], lo, _c_);
   }
   function bits$2(param){return bits(default$0);}
   function bits64$0(param){return bits64(default$0);}
   function int$2(x){return int$1(default$0, x);}
   function int32$0(x){return int32(default$0, x);}
   function nativeint$0(x){return nativeint(default$0, x);}
   function int64$0(x){return int64(default$0, x);}
   function float$1(x){return float$0(default$0, x);}
   function int_incl$0(x, y){return int_incl(default$0, x, y);}
   function int32_incl$0(x, y){return int32_incl(default$0, x, y);}
   function nativeint_incl$0(x, y){return nativeint_incl(default$0, x, y);}
   function int64_incl$0(x, y){return int64_incl(default$0, x, y);}
   function float_range$0(x, y){return float_range(default$0, x, y);}
   function bool$0(param){return bool(default$0);}
   function char$1(param){return char$0(default$0);}
   function ascii$0(param){return ascii(default$0);}
   function full_init(seed){
    return caml_call2
            (assign, default$0, caml_call1(Stdlib_Random[15][1], seed));
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return full_init(runtime.caml_sys_random_seed(0));
   }
   function set_state(s){
    return caml_call2(assign, default$0, caml_call1(Base_Random_repr[5], s));
   }
   var
    Base_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$2,
       bits64$0,
       int$2,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       int_incl$0,
       int32_incl$0,
       nativeint_incl$0,
       int64_incl$0,
       float_range$0,
       bool$0,
       char$1,
       ascii$0,
       [0,
        default$0,
        make,
        make_self_init,
        copy,
        bits,
        bits64,
        int$1,
        int32,
        nativeint,
        int64,
        float$0,
        int_incl,
        int32_incl,
        nativeint_incl,
        int64_incl,
        float_range,
        bool,
        char$0,
        ascii],
       set_state];
   runtime.caml_register_global(22, Base_Random, "Base__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array_permute
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Ordered_collection_common0, Base__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    Base_Array0 = global_data.Base__Array0,
    invalid_argf = Base_Array0[1],
    Array = Base_Array0[2],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_local = Base_Array0[5],
    create_float_uninitialized = Base_Array0[6],
    append = Base_Array0[7],
    blit = Base_Array0[8],
    concat = Base_Array0[9],
    copy = Base_Array0[10],
    fill = Base_Array0[11],
    init = Base_Array0[12],
    make_matrix = Base_Array0[13],
    of_list = Base_Array0[14],
    sub = Base_Array0[15],
    to_list = Base_Array0[16],
    fold = Base_Array0[17],
    fold_right = Base_Array0[18],
    iter = Base_Array0[19],
    iteri = Base_Array0[20],
    map = Base_Array0[21],
    mapi = Base_Array0[22],
    stable_sort = Base_Array0[23],
    swap = Base_Array0[24];
   function permute(opt, _a_, len, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    if(_a_) var sth$0 = _a_[1], pos = sth$0; else var pos = 0;
    var total_length = t.length - 1;
    if(len)
     var l = len[1], len$0 = l;
    else
     var len$0 = caml_call2(Base_Import[93], total_length, pos);
    caml_call3(Base_Ordered_collection_common[2], pos, len$0, total_length);
    var num_swaps = caml_call2(Base_Import[93], len$0, 1);
    if(num_swaps >= 1){
     var i = num_swaps;
     for(;;){
      var
       this_i = caml_call2(Base_Import[91], pos, i),
       _b_ = caml_call2(Base_Import[91], i, 1),
       _c_ = caml_call2(Base_Random[19][7], random_state, _b_),
       random_i = caml_call2(Base_Import[91], pos, _c_);
      caml_call3(swap, t, this_i, random_i);
      var _d_ = i - 1 | 0;
      if(1 === i) break;
      var i = _d_;
     }
    }
    return 0;
   }
   var
    Base_Array_permute =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap,
       permute];
   runtime.caml_register_global(4, Base_Array_permute, "Base__Array_permute");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Equal = [0];
   runtime.caml_register_global(0, Base_Equal, "Base__Equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordering
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Equal = "Equal",
    cst_Greater = "Greater",
    cst_Less = "Less",
    cst_equal = "equal",
    cst_greater = "greater",
    cst_less = "less",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "ordering.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Less, 0]],
         [0, [1, [0, cst_Equal, 0]], [0, [1, [0, cst_Greater, 0]], 0]]]]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    compare_local = caml_int_compare,
    compare = caml_int_compare,
    _a_ = [0, cst_Less],
    _b_ = [0, cst_Equal],
    _c_ = [0, cst_Greater];
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       var _i_ = 0; break;
      case 1:
       var _i_ = 1; break;
      default: var _i_ = 2;
    }
    return caml_call2(Base_Hash[3], hsv, _i_);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var _d_ = sexp_006[1];
      b:
      if(caml_string_notequal(_d_, cst_Equal)){
       c:
       if(caml_string_notequal(_d_, cst_Greater)){
        if(caml_string_notequal(_d_, cst_Less)){
         if(! caml_string_notequal(_d_, cst_equal)) break b;
         if(! caml_string_notequal(_d_, cst_greater)) break c;
         if(caml_string_notequal(_d_, cst_less)) break a;
        }
        return 0;
       }
       return 2;
      }
      return 1;
     }
     var _e_ = sexp_006[1];
     if(! _e_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_005, sexp_006);
     var _f_ = _e_[1];
     if(0 !== _f_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_005, sexp_006);
     var _g_ = _f_[1];
     b:
     if(caml_string_notequal(_g_, cst_Equal)){
      c:
      if(caml_string_notequal(_g_, cst_Greater)){
       if(caml_string_notequal(_g_, cst_Less)){
        if(! caml_string_notequal(_g_, cst_equal)) break b;
        if(! caml_string_notequal(_g_, cst_greater)) break c;
        if(caml_string_notequal(_g_, cst_less)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   function equal(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   function equal_local(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   var Export = [0];
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   var
    Base_Ordering =
      [0,
       compare,
       compare_local,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       all,
       equal,
       equal_local,
       of_int,
       to_int,
       Export];
   runtime.caml_register_global(20, Base_Ordering, "Base__Ordering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List
//# unitInfo: Requires: Base__Applicative, Base__Array0, Base__Array_permute, Base__Container, Base__Import, Base__List1, Base__Monad, Base__Ordering, Base__Printf, Base__Random, Base__Result, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = " <> ",
    cst$0 = ": ",
    cst_List_map2$1 = "List.map2",
    cst_List_map3$1 = "List.map3",
    cst_List_range_stride_function$2 =
      "List.range': stride function cannot change direction",
    cst_length_mismatch_in = "length mismatch in ",
    cst_src_list_ml = "src/list.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    error_source_036 = "list.ml.Assoc.t",
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Random = global_data.Base__Random,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Result = global_data.Base__Result,
    Base_Ordering = global_data.Base__Ordering,
    Base_List1 = global_data.Base__List1,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    hd_exn = Base_List1[1],
    rev_append = Base_List1[2],
    tl_exn = Base_List1[3],
    length = Base_List1[5],
    exists = Base_List1[6],
    exists2_ok = Base_List1[7],
    fold = Base_List1[8],
    fold2_ok = Base_List1[9],
    for_all = Base_List1[10],
    for_all2_ok = Base_List1[11],
    iter = Base_List1[12],
    iter2_ok = Base_List1[13],
    rev_map = Base_List1[17],
    rev_map2_ok = Base_List1[18],
    rev = Base_List1[19],
    fold_right = Base_List1[20],
    fold_right2_ok = Base_List1[21],
    is_empty = Base_List1[22],
    partition_map = Base_List1[23],
    invalid_argf = Base_Printf[7],
    globalize = Base_Import[293],
    t_of_sexp = Base_Import[173],
    sexp_of_t = Base_Import[149],
    cst_List_map2 = cst_List_map2$1,
    cst_List_map2$0 = cst_List_map2$1,
    cst_List_map3 = cst_List_map3$1,
    cst_List_map3$0 = cst_List_map3$1,
    cst_List_last = "List.last",
    _v_ = [0, "list.ml.Transpose_got_lists_of_different_lengths"],
    _w_ = [0, cst_src_list_ml, 1588, 11],
    cst_List_random_element_exn_em = "List.random_element_exn: empty list",
    cst_List_drop_last_exn_empty_l = "List.drop_last_exn: empty list",
    _t_ =
      [0,
       [11, "List.chunks_of: Expected length > 0, got ", [4, 0, 0, 0, 0]],
       "List.chunks_of: Expected length > 0, got %d"],
    cst_List_sub = "List.sub",
    _r_ = [0, cst_src_list_ml, 1305, 12],
    _q_ = [1, 0],
    _p_ = [1, 0],
    _o_ = [1, 0],
    _n_ = [0, cst_src_list_ml, 1111, 4],
    _m_ = [0, [11, "List.init ", [4, 0, 0, 0, 0]], "List.init %d"],
    cst_List_reduce_balanced_exn = "List.reduce_balanced_exn",
    _l_ = [0, cst_src_list_ml, 626, 14],
    cst_List_reduce_exn = "List.reduce_exn",
    _k_ =
      [0,
       [11,
        "length mismatch in zip_exn: ",
        [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]],
       "length mismatch in zip_exn: %d <> %d"],
    cst_map3_exn = "map3_exn",
    cst_rev_map3_exn = "rev_map3_exn",
    _j_ = [0, cst_src_list_ml, 476, 11],
    cst_map2_exn = "map2_exn",
    cst_exists2_exn = "exists2_exn",
    cst_for_all2_exn = "for_all2_exn",
    cst_fold_right2_exn = "fold_right2_exn",
    cst_fold2_exn = "fold2_exn",
    cst_rev_map2_exn = "rev_map2_exn",
    cst_iter2_exn = "iter2_exn",
    _e_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2,
         0,
         [11,
          cst$0,
          [4,
           0,
           0,
           0,
           [11,
            cst,
            [4,
             0,
             0,
             0,
             [11, " || ", [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]]]]]],
       "length mismatch in %s: %d <> %d || %d <> %d"],
    _d_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2, 0, [11, cst$0, [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _c_ =
      [0,
       [11,
        "List.nth_exn ",
        [4, 0, 0, 0, [11, " called on list of length ", [4, 0, 0, 0, 0]]]],
       "List.nth_exn %d called on list of length %d"],
    cst_List_range_stride_must_be_ = "List.range: stride must be non-zero",
    cst_List_range_stride_function$0 = cst_List_range_stride_function$2,
    cst_List_range_stride_function$1 = cst_List_range_stride_function$2,
    cst_List_range_stride_function =
      "List.range': stride function cannot return the same value",
    _a_ = [0, "Ok"],
    _b_ = [0, "Unequal_lengths"],
    _f_ = [0, "List.find_map_exn: not found"],
    _g_ = [0, "List.find_exn: not found"],
    _h_ = [0, "List.findi_exn: not found"],
    _i_ = [0, "List.find_mapi_exn: not found"],
    _s_ = [0, "List.Assoc.find_exn: not found"],
    cst_Base_List_Transpose_got_li =
      "Base__List.Transpose_got_lists_of_different_lengths";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[194], a_sexp_grammar);
   }
   function compare_local(cmp_a, a_014, b_015){
    if(a_014 === b_015) return 0;
    if(! a_014) return b_015 ? 1 : 0;
    var a_016 = a_014[1];
    if(! b_015) return -1;
    var b_017 = b_015[1];
    return caml_call2(cmp_a, a_016, b_017);
   }
   function compare(cmp_a, a_010, b_011){
    if(a_010 === b_011) return 0;
    if(! a_010) return b_011 ? 1 : 0;
    var a_012 = a_010[1];
    if(! b_011) return -1;
    var b_013 = b_011[1];
    return caml_call2(cmp_a, a_012, b_013);
   }
   function sexp_of_t$0(of_a_018, param){
    if(! param) return _b_;
    var arg0_019 = param[1], res0_020 = caml_call1(of_a_018, arg0_019);
    return [1, [0, _a_, [0, res0_020, 0]]];
   }
   function invariant(f, t){return caml_call2(iter, t, f);}
   function of_list(t){return t;}
   function singleton(x){return [0, x, 0];}
   function range(compare, stride, opt, _bI_, start_i, stop_i){
    if(opt) var sth = opt[1], start = sth; else var start = 104758188;
    if(_bI_) var sth$0 = _bI_[1], stop = sth$0; else var stop = -160346914;
    var next_i = caml_call1(stride, start_i);
    function order(x, y){
     var _bJ_ = caml_call2(compare, x, y);
     return caml_call1(Base_Ordering[11], _bJ_);
    }
    function raise_stride_cannot_return_sam(param){
     return caml_call1(Base_Import[126], cst_List_range_stride_function);
    }
    switch(order(start_i, next_i)){
      case 0:
       var initial_stride_order = 847855481; break;
      case 1:
       var initial_stride_order = raise_stride_cannot_return_sam(0); break;
      default: var initial_stride_order = 85047514;
    }
    var
     start_i$0 = 104758188 <= start ? start_i : next_i,
     i_to_stop_order = order(start_i$0, stop_i);
    a:
    {
     switch(i_to_stop_order){
       case 0:
        if(847855481 > initial_stride_order) break a; break;
       case 1:
        return 104758188 <= stop ? [0, start_i$0, 0] : 0;
       default: if(847855481 <= initial_stride_order) break a;
     }
     var next_i$0 = caml_call1(stride, start_i$0);
     b:
     {
      switch(order(start_i$0, next_i$0)){
        case 0:
         if(847855481 > initial_stride_order) break b; break;
        case 1:
         return raise_stride_cannot_return_sam(0);
        default: if(847855481 <= initial_stride_order) break b;
      }
      var
       block = [0, start_i$0, 24029],
       dst = block,
       offset = 1,
       i = next_i$0;
      for(;;){
       var i_to_stop_order$0 = order(i, stop_i);
       c:
       {
        d:
        {
         switch(i_to_stop_order$0){
           case 0:
            if(847855481 <= initial_stride_order) break d; break;
           case 1:
            if(104758188 <= stop){dst[1 + offset] = [0, i, 0]; break c;}
            dst[1 + offset] = 0;
            break c;
           default: if(847855481 > initial_stride_order) break d;
         }
         dst[1 + offset] = 0;
         break c;
        }
        var next_i$1 = caml_call1(stride, i);
        d:
        {
         switch(order(i, next_i$1)){
           case 0:
            if(847855481 <= initial_stride_order) break d; break;
           case 1:
            dst[1 + offset] = raise_stride_cannot_return_sam(0); break c;
           default: if(847855481 > initial_stride_order) break d;
         }
         dst[1 + offset] =
          caml_call1(Base_Import[126], cst_List_range_stride_function$1);
         break c;
        }
        var dst$0 = [0, i, 24029];
        dst[1 + offset] = dst$0;
        var dst = dst$0, offset = 1, i = next_i$1;
        continue;
       }
       return block;
      }
     }
     return caml_call1(Base_Import[126], cst_List_range_stride_function$0);
    }
    return 0;
   }
   function range$0(opt, _bF_, _bE_, start_i, stop_i){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(_bF_) var sth$0 = _bF_[1], start = sth$0; else var start = 104758188;
    if(_bE_) var sth$1 = _bE_[1], stop = sth$1; else var stop = -160346914;
    if(0 === stride)
     caml_call1(Base_Import[126], cst_List_range_stride_must_be_);
    var _bG_ = [0, stop], _bH_ = [0, start];
    return range
            (runtime.caml_int_compare,
             function(x){return caml_call2(Base_Import[91], x, stride);},
             _bH_,
             _bG_,
             start_i,
             stop_i);
   }
   function hd(t){if(! t) return 0; var x = t[1]; return [0, x];}
   function tl(t){if(! t) return 0; var t$0 = t[2]; return [0, t$0];}
   function nth(t, n){
    if(0 > n) return 0;
    var t$0 = t, n$0 = n;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], a = t$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = caml_call2(Base_Import[93], n$0, 1), t$0 = t$1, n$0 = n$1;
    }
   }
   function nth_exn(t, n){
    var match = nth(t, n);
    if(! match)
     return caml_call4(invalid_argf, _c_, n, caml_call1(length, t), 0);
    var a = match[1];
    return a;
   }
   function unordered_append(l1, l2){
    if(l1){
     if(l2) return caml_call2(rev_append, l1, l2);
     var l = l1;
    }
    else
     var l = l2;
    return l;
   }
   function of_lists(l1, l2){
    var a = l1, b = l2, shared_length = 0;
    for(;;){
     if(a){
      if(b){
       var
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[91], shared_length, 1),
        a = a$0,
        b = b$0,
        shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b) return [0, shared_length];
     return [1, shared_length, a, b];
    }
   }
   function check_length2_exn(name, l1, l2){
    var match = of_lists(l1, l2);
    if(0 === match[0]) return;
    var
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _bB_ = caml_call1(length, tail_of_b),
     _bC_ = caml_call2(Base_Import[91], shared_length, _bB_),
     _bD_ = caml_call1(length, tail_of_a);
    return caml_call5
            (invalid_argf,
             _d_,
             name,
             caml_call2(Base_Import[91], shared_length, _bD_),
             _bC_,
             0);
   }
   function check_length2(l1, l2, f){
    return 0 === of_lists(l1, l2)[0] ? [0, caml_call2(f, l1, l2)] : 0;
   }
   function of_lists$0(l1, l2, l3){
    var a = l1, b = l2, c = l3, shared_length = 0;
    for(;;){
     if(a){
      if(b && c){
       var
        c$0 = c[2],
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[91], shared_length, 1),
        a = a$0,
        b = b$0,
        c = c$0,
        shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b && ! c) return [0, shared_length];
     return [1, shared_length, a, b, c];
    }
   }
   function check_length3_exn(name, l1, l2, l3){
    var match = of_lists$0(l1, l2, l3);
    if(0 === match[0]) return;
    var
     tail_of_c = match[4],
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _by_ = caml_call1(length, tail_of_a),
     n1 = caml_call2(Base_Import[91], shared_length, _by_),
     _bz_ = caml_call1(length, tail_of_b),
     n2 = caml_call2(Base_Import[91], shared_length, _bz_),
     _bA_ = caml_call1(length, tail_of_c),
     n3 = caml_call2(Base_Import[91], shared_length, _bA_);
    return caml_call7(invalid_argf, _e_, name, n1, n2, n2, n3, 0);
   }
   function check_length3(l1, l2, l3, f){
    return 0 === of_lists$0(l1, l2, l3)[0]
            ? [0, caml_call3(f, l1, l2, l3)]
            : 0;
   }
   function iter2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_bv_){
              var _bw_ = caml_call1(iter2_ok, _bv_);
              return function(_bx_){return caml_call2(_bw_, _bx_, f);};
             });
   }
   function iter2_exn(l1, l2, f){
    check_length2_exn(cst_iter2_exn, l1, l2);
    return caml_call3(iter2_ok, l1, l2, f);
   }
   function rev_map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_bs_){
              var _bt_ = caml_call1(rev_map2_ok, _bs_);
              return function(_bu_){return caml_call2(_bt_, _bu_, f);};
             });
   }
   function rev_map2_exn(l1, l2, f){
    check_length2_exn(cst_rev_map2_exn, l1, l2);
    return caml_call3(rev_map2_ok, l1, l2, f);
   }
   function fold2(l1, l2, init, f){
    return check_length2
            (l1,
             l2,
             function(_bp_){
              var _bq_ = caml_call1(fold2_ok, _bp_);
              return function(_br_){return caml_call3(_bq_, _br_, init, f);};
             });
   }
   function fold2_exn(l1, l2, init, f){
    check_length2_exn(cst_fold2_exn, l1, l2);
    return caml_call4(fold2_ok, l1, l2, init, f);
   }
   function fold_right2(l1, l2, f, init){
    return check_length2
            (l1,
             l2,
             function(_bm_){
              var _bn_ = caml_call1(fold_right2_ok, _bm_);
              return function(_bo_){return caml_call3(_bn_, _bo_, f, init);};
             });
   }
   function fold_right2_exn(l1, l2, f, init){
    check_length2_exn(cst_fold_right2_exn, l1, l2);
    return caml_call4(fold_right2_ok, l1, l2, f, init);
   }
   function for_all2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_bj_){
              var _bk_ = caml_call1(for_all2_ok, _bj_);
              return function(_bl_){return caml_call2(_bk_, _bl_, f);};
             });
   }
   function for_all2_exn(l1, l2, f){
    check_length2_exn(cst_for_all2_exn, l1, l2);
    return caml_call3(for_all2_ok, l1, l2, f);
   }
   function exists2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_bg_){
              var _bh_ = caml_call1(exists2_ok, _bg_);
              return function(_bi_){return caml_call2(_bh_, _bi_, f);};
             });
   }
   function exists2_exn(l1, l2, f){
    check_length2_exn(cst_exists2_exn, l1, l2);
    return caml_call3(exists2_ok, l1, l2, f);
   }
   function mem(t, a, equal){
    var param = t;
    for(;;){
     if(! param) return 0;
     var bs = param[2], b = param[1], _bf_ = caml_call2(equal, a, b);
     if(_bf_) return _bf_;
     var param = bs;
    }
   }
   function rev_filter(t, f){
    var accu = 0, param = t;
    for(;;){
     if(! param) return accu;
     var l = param[2], x = param[1];
     if(caml_call1(f, x))
      var accu$0 = [0, x, accu], accu = accu$0, param = l;
     else
      var param = l;
    }
   }
   function filter(l, f){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1];
     if(caml_call1(f, hd)){
      var block = [0, hd, 24029], dst = block, offset = 1, l$1 = tl;
      for(;;){
       if(! l$1){dst[1 + offset] = 0; return block;}
       var tl$0 = l$1[2], hd$0 = l$1[1];
       if(caml_call1(f, hd$0)){
        var dst$0 = [0, hd$0, 24029];
        dst[1 + offset] = dst$0;
        var dst = dst$0, offset = 1, l$1 = tl$0;
       }
       else
        var l$1 = tl$0;
      }
     }
     else
      var l$0 = tl;
    }
   }
   function find_map(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], r = caml_call1(f, x);
     if(r) return r;
     var param = l;
    }
   }
   var not_found = [0, Base_Import[297], _f_];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)) return [0, x];
     var param = l;
    }
   }
   var not_found$0 = [0, Base_Import[297], _g_];
   function find_exn(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(not_found$0, 1);
     var t$1 = t$0[2], x = t$0[1];
     if(caml_call1(f, x)) return x;
     var t$0 = t$1;
    }
   }
   function findi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1];
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = l;
    }
   }
   var not_found$1 = [0, Base_Import[297], _h_];
   function findi_exn(t, f){
    var match = findi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$1, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = l;
    }
   }
   var not_found$2 = [0, Base_Import[297], _i_];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$2, 1);
    var x = match[1];
    return x;
   }
   function for_alli(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 1;
     var tl = t$0[2], hd = t$0[1], _be_ = caml_call2(f, i, hd);
     if(! _be_) return _be_;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = tl;
    }
   }
   function existsi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var tl = t$0[2], hd = t$0[1], _bd_ = caml_call2(f, i, hd);
     if(_bd_) return _bd_;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = tl;
    }
   }
   var of_array = Base_Array0[16], to_array = Base_Array0[14];
   function to_list(t){return t;}
   function append(l1$0, l2){
    if(! l2) return l1$0;
    if(! l1$0) return l2;
    var _a9_ = l1$0[2], x1 = l1$0[1];
    if(! _a9_) return [0, x1, l2];
    var _a__ = _a9_[2], x2 = _a9_[1];
    if(! _a__) return [0, x1, [0, x2, l2]];
    var _a$_ = _a__[2], x3 = _a__[1];
    if(! _a$_) return [0, x1, [0, x2, [0, x3, l2]]];
    var match = _a$_[2], x4 = _a$_[1];
    if(! match) return [0, x1, [0, x2, [0, x3, [0, x4, l2]]]];
    var
     tl = match[2],
     x5 = match[1],
     block = [0, x5, 24029],
     dst = block,
     offset = 1,
     l1 = tl;
    for(;;){
     if(l1){
      var _ba_ = l1[2], x1$0 = l1[1];
      if(_ba_){
       var _bb_ = _ba_[2], x2$0 = _ba_[1];
       if(_bb_){
        var _bc_ = _bb_[2], x3$0 = _bb_[1];
        if(_bc_){
         var match$0 = _bc_[2], x4$0 = _bc_[1];
         if(match$0){
          var tl$0 = match$0[2], x5$0 = match$0[1], dst$0 = [0, x5$0, 24029];
          dst[1 + offset] = [0, x1$0, [0, x2$0, [0, x3$0, [0, x4$0, dst$0]]]];
          var dst = dst$0, offset = 1, l1 = tl$0;
          continue;
         }
         dst[1 + offset] = [0, x1$0, [0, x2$0, [0, x3$0, [0, x4$0, l2]]]];
        }
        else
         dst[1 + offset] = [0, x1$0, [0, x2$0, [0, x3$0, l2]]];
       }
       else
        dst[1 + offset] = [0, x1$0, [0, x2$0, l2]];
      }
      else
       dst[1 + offset] = [0, x1$0, l2];
     }
     else
      dst[1 + offset] = l2;
     return [0, x1, [0, x2, [0, x3, [0, x4, block]]]];
    }
   }
   function map(l, f){
    if(! l) return 0;
    var
     tl = l[2],
     x = l[1],
     block = [0, caml_call1(f, x), 24029],
     dst = block,
     offset = 1,
     l$0 = tl;
    for(;;){
     if(! l$0){dst[1 + offset] = 0; return block;}
     var tl$0 = l$0[2], x$0 = l$0[1], dst$0 = [0, caml_call1(f, x$0), 24029];
     dst[1 + offset] = dst$0;
     var dst = dst$0, offset = 1, l$0 = tl$0;
    }
   }
   function folding_map(t, init, f){
    var acc = [0, init];
    return map
            (t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       map
        (t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function symbol_map(l, f){return map(l, f);}
   function map2_ok(l1, l2, f){
    if(l1){
     if(l2){
      var
       l2$0 = l2[2],
       x2 = l2[1],
       l1$0 = l1[2],
       x1 = l1[1],
       block = [0, caml_call2(f, x1, x2), 24029],
       dst = block,
       offset = 1,
       l1$1 = l1$0,
       l2$1 = l2$0;
      for(;;){
       a:
       {
        if(l1$1){
         if(l2$1){
          var
           l2$2 = l2$1[2],
           x2$0 = l2$1[1],
           l1$2 = l1$1[2],
           x1$0 = l1$1[1],
           dst$0 = [0, caml_call2(f, x1$0, x2$0), 24029];
          dst[1 + offset] = dst$0;
          var dst = dst$0, offset = 1, l1$1 = l1$2, l2$1 = l2$2;
          continue;
         }
        }
        else if(! l2$1){dst[1 + offset] = 0; break a;}
        dst[1 + offset] = caml_call1(Base_Import[126], cst_List_map2$0);
       }
       return block;
      }
     }
    }
    else if(! l2) return 0;
    return caml_call1(Base_Import[126], cst_List_map2);
   }
   function map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_a7_){
              return function(_a8_){return map2_ok(_a7_, _a8_, f);};
             });
   }
   function map2_exn(l1, l2, f){
    check_length2_exn(cst_map2_exn, l1, l2);
    return map2_ok(l1, l2, f);
   }
   function rev_map3_ok(l1, l2, l3, f){
    var l1$0 = l1, l2$0 = l2, l3$0 = l3, ac = 0;
    for(;;){
     if(l1$0){
      if(l2$0 && l3$0){
       var
        l3$1 = l3$0[2],
        x3 = l3$0[1],
        l2$1 = l2$0[2],
        x2 = l2$0[1],
        l1$1 = l1$0[2],
        x1 = l1$0[1],
        ac$0 = [0, caml_call3(f, x1, x2, x3), ac],
        l1$0 = l1$1,
        l2$0 = l2$1,
        l3$0 = l3$1,
        ac = ac$0;
       continue;
      }
     }
     else if(! l2$0 && ! l3$0) return ac;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    }
   }
   function rev_map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_a4_){
              return function(_a5_){
               return function(_a6_){
                return rev_map3_ok(_a4_, _a5_, _a6_, f);};};
             });
   }
   function rev_map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_rev_map3_exn, l1, l2, l3);
    return rev_map3_ok(l1, l2, l3, f);
   }
   function map3_ok(l1, l2, l3, f){
    if(l1){
     if(l2 && l3){
      var
       l3$0 = l3[2],
       x3 = l3[1],
       l2$0 = l2[2],
       x2 = l2[1],
       l1$0 = l1[2],
       x1 = l1[1],
       block = [0, caml_call3(f, x1, x2, x3), 24029],
       dst = block,
       offset = 1,
       l1$1 = l1$0,
       l2$1 = l2$0,
       l3$1 = l3$0;
      for(;;){
       a:
       {
        if(l1$1){
         if(l2$1 && l3$1){
          var
           l3$2 = l3$1[2],
           x3$0 = l3$1[1],
           l2$2 = l2$1[2],
           x2$0 = l2$1[1],
           l1$2 = l1$1[2],
           x1$0 = l1$1[1],
           dst$0 = [0, caml_call3(f, x1$0, x2$0, x3$0), 24029];
          dst[1 + offset] = dst$0;
          var dst = dst$0, offset = 1, l1$1 = l1$2, l2$1 = l2$2, l3$1 = l3$2;
          continue;
         }
        }
        else if(! l2$1 && ! l3$1){dst[1 + offset] = 0; break a;}
        dst[1 + offset] = caml_call1(Base_Import[126], cst_List_map3$0);
       }
       return block;
      }
     }
    }
    else if(! l2 && ! l3) return 0;
    return caml_call1(Base_Import[126], cst_List_map3);
   }
   function map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_a1_){
              return function(_a2_){
               return function(_a3_){return map3_ok(_a1_, _a2_, _a3_, f);};};
             });
   }
   function map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_map3_exn, l1, l2, l3);
    return map3_ok(l1, l2, l3, f);
   }
   function rev_map_append(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var
      l1$1 = l1$0[2],
      h = l1$0[1],
      l2$1 = [0, caml_call1(f, h), l2$0],
      l1$0 = l1$1,
      l2$0 = l2$1;
    }
   }
   function unzip(list){
    var list$2 = caml_call1(rev, list), list$0 = list$2, l1 = 0, l2 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2];
     var
      list$1 = list$0[2],
      match = list$0[1],
      y = match[2],
      x = match[1],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1],
      list$0 = list$1,
      l1 = l1$0,
      l2 = l2$0;
    }
   }
   function unzip3(list){
    var
     list$2 = caml_call1(rev, list),
     list$0 = list$2,
     l1 = 0,
     l2 = 0,
     l3 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2, l3];
     var
      list$1 = list$0[2],
      match = list$0[1],
      z = match[3],
      y = match[2],
      x = match[1],
      l3$0 = [0, z, l3],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1],
      list$0 = list$1,
      l1 = l1$0,
      l2 = l2$0,
      l3 = l3$0;
    }
   }
   function zip_exn(l1, l2){
    try{
     var _aZ_ = map2_ok(l1, l2, function(a, b){return [0, a, b];});
     return _aZ_;
    }
    catch(_a0_){
     var _aY_ = caml_call1(length, l2);
     return caml_call4(invalid_argf, _k_, caml_call1(length, l1), _aY_, 0);
    }
   }
   function zip(l1, l2){
    return map2(l1, l2, function(a, b){return [0, a, b];});
   }
   function rev_mapi(l, f){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      t = param[2],
      h = param[1],
      acc$0 = [0, caml_call2(f, i, h), acc],
      i$0 = caml_call2(Base_Import[91], i, 1),
      i = i$0,
      acc = acc$0,
      param = t;
    }
   }
   function mapi(l, f){
    var i$2 = 0;
    if(! l) return 0;
    var
     t = l[2],
     h = l[1],
     block = [0, caml_call2(f, i$2, h), 24029],
     i = caml_call2(Base_Import[91], i$2, 1),
     dst = block,
     offset = 1,
     i$0 = i,
     param = t;
    for(;;){
     if(! param){dst[1 + offset] = 0; return block;}
     var
      t$0 = param[2],
      h$0 = param[1],
      block0_arg0 = caml_call2(f, i$0, h$0),
      block$0 = [0, block0_arg0, 24029];
     dst[1 + offset] = block$0;
     var
      i$1 = caml_call2(Base_Import[91], i$0, 1),
      dst = block$0,
      offset = 1,
      i$0 = i$1,
      param = t$0;
    }
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return mapi
            (t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       mapi
        (t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function iteri(l, f){
    caml_call3
     (fold,
      l,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return caml_call2(Base_Import[91], i, 1);
      });
    return 0;
   }
   function foldi(t, init, f){
    var
     _aW_ =
       caml_call3
        (fold,
         t,
         [0, 0, init],
         function(param, v){
          var acc = param[2], i = param[1], _aX_ = caml_call3(f, i, acc, v);
          return [0, caml_call2(Base_Import[91], i, 1), _aX_];
         });
    return caml_call1(Base_Import[127], _aW_);
   }
   function filteri(l, f){
    var pos = 0, l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1];
     if(caml_call2(f, pos, hd)) break;
     var pos$1 = caml_call2(Base_Import[91], pos, 1), pos = pos$1, l$0 = tl;
    }
    var
     block = [0, hd, 24029],
     pos$0 = caml_call2(Base_Import[91], pos, 1),
     dst = block,
     offset = 1,
     pos$2 = pos$0,
     l$1 = tl;
    for(;;){
     if(! l$1){dst[1 + offset] = 0; return block;}
     var tl$0 = l$1[2], hd$0 = l$1[1];
     if(caml_call2(f, pos$2, hd$0)){
      var block$0 = [0, hd$0, 24029];
      dst[1 + offset] = block$0;
      var
       pos$3 = caml_call2(Base_Import[91], pos$2, 1),
       dst = block$0,
       offset = 1,
       pos$2 = pos$3,
       l$1 = tl$0;
     }
     else
      var
       pos$4 = caml_call2(Base_Import[91], pos$2, 1),
       pos$2 = pos$4,
       l$1 = tl$0;
    }
   }
   function reduce(l, f){
    if(! l) return 0;
    var tl = l[2], hd = l[1];
    return [0, caml_call3(fold, tl, hd, f)];
   }
   function reduce_exn(l, f){
    var match = reduce(l, f);
    if(! match) return caml_call1(Base_Import[126], cst_List_reduce_exn);
    var v = match[1];
    return v;
   }
   function reduce_balanced(l, f){
    function step_accum(num, acc, x){
     var num$0 = num, acc$0 = acc, x$0 = x;
     for(;;){
      if(0 === caml_call2(Base_Import[116], num$0, 1)) return [0, x$0, acc$0];
      if(! acc$0)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
      var
       acc$1 = acc$0[2],
       y = acc$0[1],
       x$1 = caml_call2(f, y, x$0),
       num$1 = caml_call2(Base_Import[115], num$0, 1),
       num$0 = num$1,
       acc$0 = acc$1,
       x$0 = x$1;
     }
    }
    var match = foldi(l, 0, step_accum);
    if(! match) return 0;
    var xs = match[2], x = match[1];
    return [0,
            caml_call3
             (fold, xs, x, function(x, y){return caml_call2(f, y, x);})];
   }
   function reduce_balanced_exn(l, f){
    var match = reduce_balanced(l, f);
    if(! match)
     return caml_call1(Base_Import[126], cst_List_reduce_balanced_exn);
    var v = match[1];
    return v;
   }
   function groupi(l, break$0){
    var pos = [0, 0], l$0 = [0, l];
    function take_group(param){
     var group = l$0[1];
     if(group){
      var tl = group[2];
      if(tl){
       var y = tl[1], x = group[1];
       pos[1] = caml_call2(Base_Import[91], pos[1], 1);
       l$0[1] = tl;
       if(caml_call3(break$0, pos[1], x, y)) return [0, x, 0];
       var block = [0, x, 24029], dst = block, offset = 1;
       for(;;){
        var group$0 = l$0[1];
        a:
        {
         if(group$0){
          var tl$0 = group$0[2];
          if(tl$0){
           var y$0 = tl$0[1], x$0 = group$0[1];
           pos[1] = caml_call2(Base_Import[91], pos[1], 1);
           l$0[1] = tl$0;
           if(caml_call3(break$0, pos[1], x$0, y$0)){dst[1 + offset] = [0, x$0, 0]; break a;}
           var dst$0 = [0, x$0, 24029];
           dst[1 + offset] = dst$0;
           var dst = dst$0, offset = 1;
           continue;
          }
         }
         l$0[1] = 0;
         dst[1 + offset] = group$0;
        }
        return block;
       }
      }
     }
     l$0[1] = 0;
     return group;
    }
    if(caml_call1(is_empty, l$0[1])) return 0;
    var
     group = take_group(0),
     block = [0, group, 24029],
     dst = block,
     offset = 1;
    for(;;){
     if(caml_call1(is_empty, l$0[1])){dst[1 + offset] = 0; return block;}
     var group$0 = take_group(0), dst$0 = [0, group$0, 24029];
     dst[1 + offset] = dst$0;
     var dst = dst$0, offset = 1;
    }
   }
   function group(l, break$0){
    return groupi(l, function(param, x, y){return caml_call2(break$0, x, y);});
   }
   function merge(l1, l2, compare){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    if(0 < caml_call2(compare, h1, h2)){
     var block = [0, h2, 24029];
     merge_dps(block, 1, l1, t2, compare);
     return block;
    }
    var block$0 = [0, h1, 24029];
    merge_dps(block$0, 1, t1, l2, compare);
    return block$0;
   }
   function merge_dps(dst, offset, l1, l2, compare){
    var dst$0 = dst, offset$0 = offset, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0){dst$0[1 + offset$0] = l2$0; return;}
     if(! l2$0){dst$0[1 + offset$0] = l1$0; return;}
     var t2 = l2$0[2], h2 = l2$0[1], t1 = l1$0[2], h1 = l1$0[1];
     if(0 < caml_call2(compare, h1, h2)){
      var dst$1 = [0, h2, 24029];
      dst$0[1 + offset$0] = dst$1;
      var dst$0 = dst$1, offset$0 = 1, l2$0 = t2;
     }
     else{
      var dst$2 = [0, h1, 24029];
      dst$0[1 + offset$0] = dst$2;
      var dst$0 = dst$2, offset$0 = 1, l1$0 = t1;
     }
    }
   }
   function stable_sort(l, cmp){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _aV_ = l[2];
      if(_aV_){
       var match$2 = _aV_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _aV_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = caml_call2(Base_Import[115], n, 1),
      n2 = caml_call2(Base_Import[93], n, n1),
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu], l1 = t1, accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu], l2 = t2, accu = accu$1;
        continue;
       }
       var _aU_ = caml_call2(rev_append, l1, accu);
      }
      else
       var _aU_ = caml_call2(rev_append, l2, accu);
      return [0, _aU_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _aT_ = l[2];
      if(_aT_){
       var match$2 = _aT_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _aT_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = caml_call2(Base_Import[115], n, 1),
      n2 = caml_call2(Base_Import[93], n, n1),
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu], l2 = t2, accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
        continue;
       }
       var _aS_ = caml_call2(rev_append, l1, accu);
      }
      else
       var _aS_ = caml_call2(rev_append, l2, accu);
      return [0, _aS_, tl$0];
     }
    }
    var len = caml_call1(length, l);
    if(2 > len) return l;
    var _aR_ = sort(len, l);
    return caml_call1(Base_Import[125], _aR_);
   }
   function sort_and_group(l, compare){
    var _aQ_ = stable_sort(l, compare);
    return group
            (_aQ_,
             function(x, y){return 0 !== caml_call2(compare, x, y) ? 1 : 0;});
   }
   function dedup_and_sort(l, cmp){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2);
        if(0 <= c$0)
         var _aC_ = 0 < c$0 ? [0, x2, [0, x1, 0]] : [0, x2, 0], s = _aC_;
        else
         var s = [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _aE_ = l[2];
      if(_aE_){
       var match$2 = _aE_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _aE_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 <= c$1){
         if(0 < c$1){
          var c$2 = caml_call2(cmp, x1$0, x3);
          if(0 <= c$2){
           if(0 < c$2){
            var c$3 = caml_call2(cmp, x2$0, x3);
            if(0 <= c$3)
             var
              _aF_ =
                0 < c$3
                 ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                 : [0, x3, [0, x1$0, 0]],
              _aG_ = _aF_;
            else
             var _aG_ = [0, x2$0, [0, x3, [0, x1$0, 0]]];
            var _aH_ = _aG_;
           }
           else
            var _aH_ = [0, x2$0, [0, x3, 0]];
           var _aI_ = _aH_;
          }
          else
           var _aI_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
          var _aJ_ = _aI_;
         }
         else{
          var c$4 = caml_call2(cmp, x2$0, x3);
          if(0 <= c$4)
           var
            _aK_ = 0 < c$4 ? [0, x3, [0, x2$0, 0]] : [0, x3, 0],
            _aL_ = _aK_;
          else
           var _aL_ = [0, x2$0, [0, x3, 0]];
          var _aJ_ = _aL_;
         }
         var s$0 = _aJ_;
        }
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 <= c$5){
          if(0 < c$5){
           var c$6 = caml_call2(cmp, x1$0, x3);
           if(0 <= c$6)
            var
             _aM_ =
               0 < c$6
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x3, [0, x2$0, 0]],
             _aN_ = _aM_;
           else
            var _aN_ = [0, x1$0, [0, x3, [0, x2$0, 0]]];
           var _aO_ = _aN_;
          }
          else
           var _aO_ = [0, x1$0, [0, x3, 0]];
          var _aP_ = _aO_;
         }
         else
          var _aP_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         var s$0 = _aP_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = caml_call2(Base_Import[115], n, 1),
      n2 = caml_call2(Base_Import[93], n, n1),
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 < c){
         var accu$0 = [0, h1, accu], l1 = t1, accu = accu$0;
         continue;
        }
        if(0 <= c){var l1 = t1; continue;}
        var accu$1 = [0, h2, accu], l2 = t2, accu = accu$1;
        continue;
       }
       var _aD_ = caml_call2(rev_append, l1, accu);
      }
      else
       var _aD_ = caml_call2(rev_append, l2, accu);
      return [0, _aD_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2);
        if(0 < c$0)
         var s = [0, x1, [0, x2, 0]];
        else
         var _ao_ = 0 <= c$0 ? [0, x2, 0] : [0, x2, [0, x1, 0]], s = _ao_;
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _aq_ = l[2];
      if(_aq_){
       var match$2 = _aq_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _aq_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 < c$1){
         var c$2 = caml_call2(cmp, x2$0, x3);
         if(0 < c$2)
          var _ar_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else{
          if(0 <= c$2)
           var _as_ = [0, x1$0, [0, x3, 0]];
          else{
           var c$3 = caml_call2(cmp, x1$0, x3);
           if(0 < c$3)
            var _at_ = [0, x1$0, [0, x3, [0, x2$0, 0]]];
           else
            var
             _au_ =
               0 <= c$3
                ? [0, x3, [0, x2$0, 0]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]],
             _at_ = _au_;
           var _as_ = _at_;
          }
          var _ar_ = _as_;
         }
         var s$0 = _ar_;
        }
        else{
         if(0 <= c$1){
          var c$4 = caml_call2(cmp, x2$0, x3);
          if(0 < c$4)
           var _av_ = [0, x2$0, [0, x3, 0]];
          else
           var
            _ax_ = 0 <= c$4 ? [0, x3, 0] : [0, x3, [0, x2$0, 0]],
            _av_ = _ax_;
          var _aw_ = _av_;
         }
         else{
          var c$5 = caml_call2(cmp, x1$0, x3);
          if(0 < c$5)
           var _ay_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
          else{
           if(0 <= c$5)
            var _az_ = [0, x2$0, [0, x3, 0]];
           else{
            var c$6 = caml_call2(cmp, x2$0, x3);
            if(0 < c$6)
             var _aA_ = [0, x2$0, [0, x3, [0, x1$0, 0]]];
            else
             var
              _aB_ =
                0 <= c$6
                 ? [0, x3, [0, x1$0, 0]]
                 : [0, x3, [0, x2$0, [0, x1$0, 0]]],
              _aA_ = _aB_;
            var _az_ = _aA_;
           }
           var _ay_ = _az_;
          }
          var _aw_ = _ay_;
         }
         var s$0 = _aw_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = caml_call2(Base_Import[115], n, 1),
      n2 = caml_call2(Base_Import[93], n, n1),
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 > c){
         var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
         continue;
        }
        if(0 < c){
         var accu$0 = [0, h2, accu], l2 = t2, accu = accu$0;
         continue;
        }
        var l1 = t1;
        continue;
       }
       var _ap_ = caml_call2(rev_append, l1, accu);
      }
      else
       var _ap_ = caml_call2(rev_append, l2, accu);
      return [0, _ap_, tl$0];
     }
    }
    var len = caml_call1(length, l);
    if(2 > len) return l;
    var _an_ = sort(len, l);
    return caml_call1(Base_Import[125], _an_);
   }
   function stable_dedup(list, compare){
    if(list && list[2]){
     var
      dedups = caml_call2(rev_map, list, function(elt){return [0, elt, 1];}),
      unique =
        dedup_and_sort
         (dedups, function(x, y){return caml_call2(compare, x[1], y[1]);});
     caml_call2(iter, unique, function(dedup){dedup[2] = 0; return 0;});
     return caml_call3
             (fold,
              dedups,
              0,
              function(acc, dedup){
               return dedup[2] ? acc : [0, dedup[1], acc];
              });
    }
    return list;
   }
   function concat_mapi(l, f){
    function outer_loop_dps$0(counter, dst, offset, pos, param){
     if(! param){dst[1 + offset] = 0; return;}
     var tl = param[2], hd = param[1];
     if(! tl){dst[1 + offset] = caml_call2(f, pos, hd); return;}
     var
      _al_ = caml_call2(f, pos, hd),
      _am_ = caml_call2(Base_Import[91], pos, 1);
     if(counter >= 50)
      return caml_trampoline_return
              (inner_loop_dps$0, [0, dst, offset, _am_, _al_, tl]);
     var counter$0 = counter + 1 | 0;
     return inner_loop_dps$0(counter$0, dst, offset, _am_, _al_, tl);
    }
    function inner_loop_dps$0(counter, dst, offset, pos, l1, l2){
     var dst$0 = dst, offset$0 = offset, l1$0 = l1;
     for(;;){
      if(! l1$0){
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, dst$0, offset$0, pos, l2]);
       var counter$4 = counter + 1 | 0;
       return outer_loop_dps$0(counter$4, dst$0, offset$0, pos, l2);
      }
      var _aa_ = l1$0[2], x1 = l1$0[1];
      if(! _aa_){
       var _aj_ = [0, x1, 24029];
       dst$0[1 + offset$0] = _aj_;
       var _ak_ = 1;
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, _aj_, _ak_, pos, l2]);
       var counter$3 = counter + 1 | 0;
       return outer_loop_dps$0(counter$3, _aj_, _ak_, pos, l2);
      }
      var _ab_ = _aa_[2], x2 = _aa_[1];
      if(! _ab_){
       var _ah_ = [0, x2, 24029];
       dst$0[1 + offset$0] = [0, x1, _ah_];
       var _ai_ = 1;
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, _ah_, _ai_, pos, l2]);
       var counter$2 = counter + 1 | 0;
       return outer_loop_dps$0(counter$2, _ah_, _ai_, pos, l2);
      }
      var _ac_ = _ab_[2], x3 = _ab_[1];
      if(! _ac_){
       var _af_ = [0, x3, 24029];
       dst$0[1 + offset$0] = [0, x1, [0, x2, _af_]];
       var _ag_ = 1;
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, _af_, _ag_, pos, l2]);
       var counter$1 = counter + 1 | 0;
       return outer_loop_dps$0(counter$1, _af_, _ag_, pos, l2);
      }
      var match = _ac_[2], x4 = _ac_[1];
      if(! match){
       var _ad_ = [0, x4, 24029];
       dst$0[1 + offset$0] = [0, x1, [0, x2, [0, x3, _ad_]]];
       var _ae_ = 1;
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, _ad_, _ae_, pos, l2]);
       var counter$0 = counter + 1 | 0;
       return outer_loop_dps$0(counter$0, _ad_, _ae_, pos, l2);
      }
      var tl = match[2], x5 = match[1], dst$1 = [0, x5, 24029];
      dst$0[1 + offset$0] = [0, x1, [0, x2, [0, x3, [0, x4, dst$1]]]];
      var dst$0 = dst$1, offset$0 = 1, l1$0 = tl;
     }
    }
    function outer_loop_dps(dst, offset, pos, param){
     return caml_trampoline(outer_loop_dps$0(0, dst, offset, pos, param));
    }
    function inner_loop_dps(dst, offset, pos, l1, l2){
     return caml_trampoline(inner_loop_dps$0(0, dst, offset, pos, l1, l2));
    }
    var pos = 0, param = l;
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1];
     if(! tl) return caml_call2(f, pos, hd);
     var
      l1 = caml_call2(f, pos, hd),
      pos$0 = caml_call2(Base_Import[91], pos, 1);
     if(l1) break;
     var pos = pos$0, param = tl;
    }
    var _Z_ = l1[2], x1 = l1[1];
    if(! _Z_){
     var block$3 = [0, x1, 24029];
     outer_loop_dps(block$3, 1, pos$0, tl);
     return block$3;
    }
    var ___ = _Z_[2], x2 = _Z_[1];
    if(! ___){
     var block$2 = [0, x2, 24029];
     outer_loop_dps(block$2, 1, pos$0, tl);
     return [0, x1, block$2];
    }
    var _$_ = ___[2], x3 = ___[1];
    if(! _$_){
     var block$1 = [0, x3, 24029];
     outer_loop_dps(block$1, 1, pos$0, tl);
     return [0, x1, [0, x2, block$1]];
    }
    var match = _$_[2], x4 = _$_[1];
    if(match){
     var tl$0 = match[2], x5 = match[1], block = [0, x5, 24029];
     inner_loop_dps(block, 1, pos$0, tl$0, tl);
     return [0, x1, [0, x2, [0, x3, [0, x4, block]]]];
    }
    var block$0 = [0, x4, 24029];
    outer_loop_dps(block$0, 1, pos$0, tl);
    return [0, x1, [0, x2, [0, x3, block$0]]];
   }
   function concat_map(l, f){
    return concat_mapi(l, function(param, x){return caml_call1(f, x);});
   }
   function map2$0(a, b, f){
    return concat_map
            (a,
             function(x){
              return map(b, function(y){return caml_call2(f, x, y);});
             });
   }
   function symbol_bind(t, f){return concat_map(t, f);}
   var
    map$0 = [0, -198771759, map],
    Applicative =
      caml_call1(Base_Applicative[13], [0, singleton, map2$0, map$0]),
    map$1 = [0, -198771759, map],
    Monad = caml_call1(Base_Monad[1], [0, concat_map, singleton, map$1]),
    all = Monad[9],
    all_unit = Monad[10],
    ignore_m = Monad[8],
    join = Monad[7],
    apply = Applicative[8],
    both = Applicative[3],
    map3$0 = Applicative[10],
    symbol = Applicative[4],
    symbol$0 = Applicative[6],
    symbol$1 = Applicative[5],
    symbol$2 = Applicative[4],
    symbol$3 = Applicative[6],
    symbol$4 = Applicative[5],
    Open_on_rhs = [0],
    Let_syntax = [0, singleton, concat_map, map, both, Open_on_rhs],
    Let_syntax$0 = [0, singleton, symbol_bind, symbol_map, Let_syntax],
    Monad_infix = [0, symbol_bind, symbol_map];
   function last_exn(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return caml_call1(Base_Import[126], cst_List_last);
     var x = list$0[1];
     if(! list$0[2]) return x;
     var list$1 = list$0[2], list$0 = list$1;
    }
   }
   function last(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return 0;
     var x = list$0[1];
     if(! list$0[2]) return [0, x];
     var list$1 = list$0[2], list$0 = list$1;
    }
   }
   function is_prefix(list, prefix, equal){
    var list$0 = list, prefix$0 = prefix;
    for(;;){
     if(! prefix$0) return 1;
     var prefix$1 = prefix$0[2], hd = prefix$0[1];
     if(! list$0) return 0;
     var
      list$1 = list$0[2],
      hd$0 = list$0[1],
      _Y_ = caml_call2(equal, hd, hd$0);
     if(! _Y_) return _Y_;
     var list$0 = list$1, prefix$0 = prefix$1;
    }
   }
   function find_consecutive_duplicate(t, equal){
    if(! t) return 0;
    var t$0 = t[2], a1 = t[1], a1$0 = a1, t$1 = t$0;
    for(;;){
     if(! t$1) return 0;
     var t$2 = t$1[2], a2 = t$1[1];
     if(caml_call2(equal, a1$0, a2)) return [0, [0, a1$0, a2]];
     var a1$0 = a2, t$1 = t$2;
    }
   }
   function remove_consecutive_duplicates(opt, list, equal){
    if(opt)
     var sth = opt[1], which_to_keep = sth;
    else
     var which_to_keep = 847656566;
    if(! list) return 0;
    var
     tl$0 = list[2],
     to_keep$2 = list[1],
     to_keep = to_keep$2,
     accum = 0,
     param = tl$0;
    for(;;){
     if(! param) return caml_call1(rev, [0, to_keep, accum]);
     var tl = param[2], to_keep$0 = param[1];
     if(caml_call2(equal, to_keep$0, to_keep))
      var
       to_keep$1 = 847656566 <= which_to_keep ? to_keep$0 : to_keep,
       to_keep = to_keep$1,
       param = tl;
     else
      var
       accum$0 = [0, to_keep, accum],
       to_keep = to_keep$0,
       accum = accum$0,
       param = tl;
    }
   }
   function find_a_dup(l, compare){
    var sorted = stable_sort(l, compare), l$0 = sorted;
    for(;;){
     if(l$0){
      var tl = l$0[2];
      if(tl){
       var hd2 = tl[1], hd1 = l$0[1];
       if(0 === caml_call2(compare, hd1, hd2)) return [0, hd1];
       var l$0 = tl;
       continue;
      }
     }
     return 0;
    }
   }
   function contains_dup(lst, compare){
    return find_a_dup(lst, compare) ? 1 : 0;
   }
   function find_all_dups(l, compare){
    var sorted = stable_sort(l, compare);
    if(! sorted) return 0;
    var
     sorted$4 = sorted[2],
     prev$3 = sorted[1],
     sorted$0 = sorted$4,
     prev = prev$3,
     already_recorded = 0;
    for(;;){
     if(! sorted$0) return 0;
     var sorted$1 = sorted$0[2], prev$0 = sorted$0[1];
     if(0 === caml_call2(compare, prev, prev$0)){
      if(! already_recorded) break;
      var sorted$0 = sorted$1, prev = prev$0, already_recorded = 1;
     }
     else
      var sorted$0 = sorted$1, prev = prev$0, already_recorded = 0;
    }
    var
     block = [0, prev$0, 24029],
     dst = block,
     offset = 1,
     sorted$2 = sorted$1,
     prev$1 = prev$0,
     already_recorded$0 = 1;
    for(;;){
     if(! sorted$2){dst[1 + offset] = 0; return block;}
     var sorted$3 = sorted$2[2], prev$2 = sorted$2[1];
     if(0 === caml_call2(compare, prev$1, prev$2))
      if(already_recorded$0)
       var sorted$2 = sorted$3, prev$1 = prev$2, already_recorded$0 = 1;
      else{
       var dst$0 = [0, prev$2, 24029];
       dst[1 + offset] = dst$0;
       var
        dst = dst$0,
        offset = 1,
        sorted$2 = sorted$3,
        prev$1 = prev$2,
        already_recorded$0 = 1;
      }
     else
      var sorted$2 = sorted$3, prev$1 = prev$2, already_recorded$0 = 0;
    }
   }
   function all_equal(t$0, equal){
    if(! t$0) return 0;
    var xs$0 = t$0[2], x$0 = t$0[1], t = xs$0;
    for(;;){
     if(t){
      var xs = t[2], x = t[1], _W_ = caml_call2(equal, x, x$0);
      if(_W_){var t = xs; continue;}
      var _X_ = _W_;
     }
     else
      var _X_ = 1;
     return _X_ ? [0, x$0] : 0;
    }
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[91], count, 1)
                      : count;
             });
   }
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _m_, n, 0);
    var i = n, accum = 0;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
     if(0 === i) return accum;
     var
      accum$0 = [0, caml_call1(f, caml_call2(Base_Import[93], i, 1)), accum],
      i$0 = caml_call2(Base_Import[93], i, 1),
      i = i$0,
      accum = accum$0;
    }
   }
   function rev_filter_map(l, f){
    var l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call1(f, hd);
     if(match)
      var x = match[1], accum$0 = [0, x, accum], l$0 = tl, accum = accum$0;
     else
      var l$0 = tl;
    }
   }
   function filter_map(l, f){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], match = caml_call1(f, hd);
     if(match){
      var
       x = match[1],
       block = [0, x, 24029],
       dst = block,
       offset = 1,
       l$1 = tl;
      for(;;){
       if(! l$1){dst[1 + offset] = 0; return block;}
       var tl$0 = l$1[2], hd$0 = l$1[1], match$0 = caml_call1(f, hd$0);
       if(match$0){
        var x$0 = match$0[1], dst$0 = [0, x$0, 24029];
        dst[1 + offset] = dst$0;
        var dst = dst$0, offset = 1, l$1 = tl$0;
       }
       else
        var l$1 = tl$0;
      }
     }
     else
      var l$0 = tl;
    }
   }
   function rev_filter_mapi(l, f){
    var i = 0, l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, i, hd);
     if(match)
      var
       x = match[1],
       accum$0 = [0, x, accum],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       l$0 = tl,
       accum = accum$0;
     else
      var i$1 = caml_call2(Base_Import[91], i, 1), i = i$1, l$0 = tl;
    }
   }
   function filter_mapi(l, f){
    var pos = 0, l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, pos, hd);
     if(match) break;
     var pos$1 = caml_call2(Base_Import[91], pos, 1), pos = pos$1, l$0 = tl;
    }
    var
     x = match[1],
     block = [0, x, 24029],
     pos$0 = caml_call2(Base_Import[91], pos, 1),
     dst = block,
     offset = 1,
     pos$2 = pos$0,
     l$1 = tl;
    for(;;){
     if(! l$1){dst[1 + offset] = 0; return block;}
     var tl$0 = l$1[2], hd$0 = l$1[1], match$0 = caml_call2(f, pos$2, hd$0);
     if(match$0){
      var x$0 = match$0[1], block$0 = [0, x$0, 24029];
      dst[1 + offset] = block$0;
      var
       pos$3 = caml_call2(Base_Import[91], pos$2, 1),
       dst = block$0,
       offset = 1,
       pos$2 = pos$3,
       l$1 = tl$0;
     }
     else
      var
       pos$4 = caml_call2(Base_Import[91], pos$2, 1),
       pos$2 = pos$4,
       l$1 = tl$0;
    }
   }
   function filter_opt(l){return filter_map(l, function(_V_){return _V_;});}
   function partition3_map(t, f){
    var t$0 = t, fst = 0, snd = 0, trd = 0;
    for(;;){
     if(! t$0){
      var _T_ = caml_call1(rev, trd), _U_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _U_, _T_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x), _S_ = match[1];
     if(4152137 === _S_)
      var y = match[2], snd$0 = [0, y, snd], t$0 = t$1, snd = snd$0;
     else if(4202758 <= _S_)
      var y$0 = match[2], trd$0 = [0, y$0, trd], t$0 = t$1, trd = trd$0;
     else
      var y$1 = match[2], fst$0 = [0, y$1, fst], t$0 = t$1, fst = fst$0;
    }
   }
   function partition_tf(t, f){
    function f$0(x){return caml_call1(f, x) ? [0, x] : [1, x];}
    return caml_call2(partition_map, t, f$0);
   }
   function partition_result(t){
    return caml_call2(partition_map, t, Base_Result[38]);
   }
   function t_of_sexp$0(of_a_028, of_b_029, x_037){
    function _P_(sexp_035){
     if(1 === sexp_035[0]){
      var _Q_ = sexp_035[1];
      if(_Q_){
       var _R_ = _Q_[2];
       if(_R_ && ! _R_[2]){
        var
         arg1_032 = _R_[1],
         arg0_031 = _Q_[1],
         res0_033 = caml_call1(of_a_028, arg0_031),
         res1_034 = caml_call1(of_b_029, arg1_032);
        return [0, res0_033, res1_034];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], error_source_036, 2, sexp_035);
    }
    return caml_call2(Base_Import[173], _P_, x_037);
   }
   function sexp_of_t$1(of_a_038, of_b_039, x_044){
    function _O_(param){
     var
      arg1_041 = param[2],
      arg0_040 = param[1],
      res0_042 = caml_call1(of_a_038, arg0_040),
      res1_043 = caml_call1(of_b_039, arg1_041);
     return [1, [0, res0_042, [0, res1_043, 0]]];
    }
    return caml_call2(Base_Import[149], _O_, x_044);
   }
   function t_sexp_grammar$0(a_sexp_grammar, b_sexp_grammar){
    var
     _N_ =
       caml_call1
        (Base_Import[194],
         [2,
          [0,
           [5, [0, Sexplib0_Sexp_grammar[6], _o_, a_sexp_grammar]],
           [0, [5, [0, Sexplib0_Sexp_grammar[7], _p_, b_sexp_grammar]], 0]]]);
    return [5, [0, Sexplib0_Sexp_grammar[5], _q_, _N_]];
   }
   function pair_of_group(list){
    if(! list) throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
    var k = list[1][1];
    return [0, k, map(list, Base_Import[127])];
   }
   function group$0(alist, equal){
    return map
            (group
              (alist,
               function(param, _M_){
                var y = _M_[1], x = param[1];
                return 1 - caml_call2(equal, x, y);
               }),
             pair_of_group);
   }
   function sort_and_group$0(alist, compare){
    return map
            (sort_and_group
              (alist,
               function(param, _L_){
                var y = _L_[1], x = param[1];
                return caml_call2(compare, x, y);
               }),
             pair_of_group);
   }
   function find$0(t, equal, key){
    var
     match =
       find
        (t,
         function(param){
          var key$0 = param[1];
          return caml_call2(equal, key, key$0);
         });
    if(! match) return 0;
    var x = match[1];
    return [0, caml_call1(Base_Import[127], x)];
   }
   var not_found$3 = [0, Base_Import[297], _s_];
   function find_exn$0(t, equal, key){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(not_found$3, 1);
     var t$1 = t$0[2], match = t$0[1], value = match[2], key$0 = match[1];
     if(caml_call2(equal, key, key$0)) return value;
     var t$0 = t$1;
    }
   }
   function mem$0(t, equal, key){return find$0(t, equal, key) ? 1 : 0;}
   function remove(t, equal, key){
    return filter
            (t,
             function(param){
              var key$0 = param[1];
              return 1 - caml_call2(equal, key, key$0);
             });
   }
   function add(t, equal, key, value){
    return [0, [0, key, value], remove(t, equal, key)];
   }
   function inverse(t){
    return map
            (t,
             function(param){
              var y = param[2], x = param[1];
              return [0, y, x];
             });
   }
   function map$2(t, f){
    return map
            (t,
             function(param){
              var value = param[2], key = param[1];
              return [0, key, caml_call1(f, value)];
             });
   }
   function sub(l, pos, len){
    var _H_ = pos < 0 ? 1 : 0;
    if(_H_)
     var _I_ = _H_;
    else{
     var _J_ = len < 0 ? 1 : 0;
     if(_J_)
      var _I_ = _J_;
     else
      var
       _K_ = caml_call1(length, l),
       _I_ = caml_call2(Base_Import[93], _K_, len) < pos ? 1 : 0;
    }
    if(_I_) caml_call1(Base_Import[126], cst_List_sub);
    var stop = caml_call2(Base_Import[91], pos, len), i = 0, l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1];
     if(i >= pos) break;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, l$0 = tl;
    }
    if(i >= stop) return 0;
    var
     block = [0, hd, 24029],
     i$1 = caml_call2(Base_Import[91], i, 1),
     dst = block,
     offset = 1,
     i$2 = i$1,
     l$1 = tl;
    for(;;){
     if(l$1){
      var tl$0 = l$1[2], hd$0 = l$1[1];
      if(i$2 < pos){
       var i$3 = caml_call2(Base_Import[91], i$2, 1), i$2 = i$3, l$1 = tl$0;
       continue;
      }
      if(i$2 < stop){
       var block$0 = [0, hd$0, 24029];
       dst[1 + offset] = block$0;
       var
        i$4 = caml_call2(Base_Import[91], i$2, 1),
        dst = block$0,
        offset = 1,
        i$2 = i$4,
        l$1 = tl$0;
       continue;
      }
      dst[1 + offset] = 0;
     }
     else
      dst[1 + offset] = 0;
     return block;
    }
   }
   function split_n(t_orig, n){
    if(0 >= n) return [0, 0, t_orig];
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(! t) return [0, t_orig, 0];
     var tl = t[2], hd = t[1];
     if(0 === n$0) return [0, caml_call1(rev, accum), t];
     var
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[93], n$0, 1),
      n$0 = n$1,
      t = tl,
      accum = accum$0;
    }
   }
   function take(t_orig, n){
    if(0 >= n) return 0;
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(! t) return t_orig;
     var tl = t[2], hd = t[1];
     if(0 === n$0) return caml_call1(rev, accum);
     var
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[93], n$0, 1),
      n$0 = n$1,
      t = tl,
      accum = accum$0;
    }
   }
   function drop(t, n){
    var t$0 = t, n$0 = n;
    for(;;){
     if(t$0){
      var tl = t$0[2];
      if(0 < n$0){
       var n$1 = caml_call2(Base_Import[93], n$0, 1), t$0 = tl, n$0 = n$1;
       continue;
      }
     }
     return t$0;
    }
   }
   function chunks_of(l, length){
    if(length <= 0) caml_call3(invalid_argf, _t_, length, 0);
    var acc = 0, l$0 = l;
    for(;;){
     if(! l$0) return caml_call1(rev, acc);
     var
      match = split_n(l$0, length),
      l$1 = match[2],
      sublist = match[1],
      acc$0 = [0, sublist, acc],
      acc = acc$0,
      l$0 = l$1;
    }
   }
   function split_while(xs, f){
    var acc = 0, t = xs;
    for(;;){
     if(t){
      var tl = t[2], hd = t[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc], acc = acc$0, t = tl;
       continue;
      }
     }
     return [0, caml_call1(rev, acc), t];
    }
   }
   function take_while(xs, f){
    var acc = 0, param = xs;
    for(;;){
     if(param){
      var tl = param[2], hd = param[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc], acc = acc$0, param = tl;
       continue;
      }
     }
     return caml_call1(rev, acc);
    }
   }
   function drop_while(t, f){
    var t$0 = t;
    for(;;){
     if(t$0){
      var tl = t$0[2], hd = t$0[1];
      if(caml_call1(f, hd)){var t$0 = tl; continue;}
     }
     return t$0;
    }
   }
   function drop_last(t){
    var match = caml_call1(rev, t);
    if(! match) return 0;
    var lst = match[2];
    return [0, caml_call1(rev, lst)];
   }
   function drop_last_exn(t){
    var match = drop_last(t);
    if(! match)
     return caml_call1(Base_Import[124], cst_List_drop_last_exn_empty_l);
    var lst = match[1];
    return lst;
   }
   function cartesian_product(list1, list2){
    if(caml_call1(is_empty, list2)) return 0;
    var l1 = list1;
    for(;;){
     if(! l1) return 0;
     var l1$0 = l1[2], x1 = l1[1];
     if(list2) break;
     var l1 = l1$0;
    }
    var
     l2 = list2[2],
     x2 = list2[1],
     block = [0, [0, x1, x2], 24029],
     dst = block,
     offset = 1,
     x1$1 = x1,
     l1$2 = l1$0,
     l2$0 = l2;
    for(;;)
     if(l2$0){
      var l2$1 = l2$0[2], x2$0 = l2$0[1], dst$0 = [0, [0, x1$1, x2$0], 24029];
      dst[1 + offset] = dst$0;
      var dst = dst$0, offset = 1, l2$0 = l2$1;
     }
     else{
      if(! l1$2){dst[1 + offset] = 0; return block;}
      var
       l1$1 = l1$2[2],
       x1$0 = l1$2[1],
       x1$1 = x1$0,
       l1$2 = l1$1,
       l2$0 = list2;
     }
   }
   function concat(l){return caml_call3(fold_right, l, append, 0);}
   function concat_no_order(l){
    return caml_call3
            (fold,
             l,
             0,
             function(acc, l){return caml_call2(rev_append, l, acc);});
   }
   function cons(x, l){return [0, x, l];}
   function is_sorted(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _G_ = caml_call2(compare, x1, x2) <= 0 ? 1 : 0;
       if(! _G_) return _G_;
       var l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   function is_sorted_strictly(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _F_ = caml_call2(compare, x1, x2) < 0 ? 1 : 0;
       if(! _F_) return _F_;
       var l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   var Infix = [0, append];
   function permute(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    if(list){
     var _E_ = list[2];
     if(_E_){
      if(_E_[2]){
       var arr = caml_call1(Base_Array0[14], list);
       caml_call4(Base_Array_permute[25], [0, random_state], 0, 0, arr);
       return caml_call1(Base_Array0[16], arr);
      }
      var y = _E_[1], x = list[1];
      return caml_call1(Base_Random[19][17], random_state)
              ? [0, y, [0, x, 0]]
              : list;
     }
    }
    return list;
   }
   function random_element_exn(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    if(caml_call1(is_empty, list))
     return caml_call1(Base_Import[124], cst_List_random_element_exn_em);
    var _D_ = caml_call1(length, list);
    return nth_exn(list, caml_call2(Base_Random[19][7], random_state, _D_));
   }
   function random_element(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    try{
     var _B_ = [0, random_element_exn([0, random_state], list)];
     return _B_;
    }
    catch(_C_){return 0;}
   }
   function compare$0(cmp, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     var a$0 = xs, b$0 = ys;
    }
   }
   function compare_local$0(cmp, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     var a$0 = xs, b$0 = ys;
    }
   }
   var hash_fold_t = Base_Import[212];
   function equal_with_local_closure(equal, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        _A_ = caml_call2(equal, x1, x2);
       if(! _A_) return _A_;
       var t1$0 = t1$1, t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function equal(f, x, y){return equal_with_local_closure(f, x, y);}
   function equal_local(equal_a_local, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        _z_ = caml_call2(equal_a_local, x1, x2);
       if(! _z_) return _z_;
       var t1$0 = t1$1, t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function transpose(rows$0){
    var rows = rows$0, columns = 0, do_rev = 1;
    for(;;){
     var t = rows, column_acc = 0, trimmed_rows = 0, found_empty = 0;
     for(;;){
      if(! t) break;
      var match = t[1];
      if(match)
       var
        tl = t[2],
        xs = match[2],
        x = match[1],
        trimmed = [0, xs, trimmed_rows],
        column_acc$0 = [0, x, column_acc],
        t = tl,
        column_acc = column_acc$0,
        trimmed_rows = trimmed;
      else
       var tl$0 = t[2], t = tl$0, found_empty = 1;
     }
     if(! column_acc && ! trimmed_rows) return [0, caml_call1(rev, columns)];
     if(found_empty) return 0;
     var
      column = do_rev ? caml_call1(rev, column_acc) : column_acc,
      do_rev$0 = 1 - do_rev,
      columns$0 = [0, column, columns],
      rows = trimmed_rows,
      columns = columns$0,
      do_rev = do_rev$0;
    }
   }
   var
    Transpose_got_lists_of_differe =
      [248, cst_Base_List_Transpose_got_li, runtime.caml_fresh_oo_id(0)];
   function _u_(param){
    if(param[1] !== Transpose_got_lists_of_differe)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
    var
     arg0_045 = param[2],
     res0_046 = caml_call2(Base_Import[149], Base_Import[139], arg0_045);
    return [1, [0, _v_, [0, res0_046, 0]]];
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Transpose_got_lists_of_differe, _u_);
   function transpose_exn(l){
    var match = transpose(l);
    if(! match)
     throw caml_maybe_attach_backtrace
            ([0, Transpose_got_lists_of_differe, map(l, length)], 1);
    var l$0 = match[1];
    return l$0;
   }
   function intersperse(t, sep){
    if(! t) return 0;
    var xs = t[2], x = t[1], _y_ = 0;
    return [0,
            x,
            caml_call3
             (fold_right,
              xs,
              function(y, acc){return [0, sep, [0, y, acc]];},
              _y_)];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   function is_suffix(list, suffix, equal_elt){
    var
     list_len = caml_call1(length, list),
     suffix_len = caml_call1(length, suffix),
     _x_ = suffix_len <= list_len ? 1 : 0;
    return _x_
            ? equal_with_local_closure
              (equal_elt,
               drop(list, caml_call2(Base_Import[93], list_len, suffix_len)),
               suffix)
            : _x_;
   }
   var
    Base_List =
      [0,
       compare$0,
       compare_local$0,
       globalize,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       of_list,
       of_array,
       append,
       concat,
       filter,
       filter_map,
       concat_map,
       partition_tf,
       partition_map,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       concat_mapi,
       length,
       invariant,
       [0,
        both,
        symbol,
        symbol$1,
        symbol$0,
        apply,
        map2$0,
        map3$0,
        [0, symbol$2, symbol$4, symbol$3, symbol_map],
        symbol_bind,
        symbol_map,
        [0, symbol_bind, symbol_map],
        concat_map,
        singleton,
        map,
        join,
        ignore_m,
        all,
        all_unit,
        [0, singleton, symbol_bind, symbol_map, Let_syntax]],
       symbol_bind,
       symbol_map,
       Monad_infix,
       concat_map,
       singleton,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax$0,
       [0, compare, compare_local, sexp_of_t$0],
       singleton,
       nth,
       nth_exn,
       rev,
       rev_append,
       unordered_append,
       rev_map,
       iter2_exn,
       iter2,
       rev_map2_exn,
       rev_map2,
       fold2_exn,
       fold2,
       fold_right2_exn,
       fold_right2,
       for_all2_exn,
       for_all2,
       exists2_exn,
       exists2,
       rev_filter,
       partition3_map,
       partition_result,
       split_n,
       stable_sort,
       stable_sort,
       merge,
       hd,
       tl,
       hd_exn,
       tl_exn,
       findi_exn,
       find_exn,
       find_map_exn,
       find_mapi_exn,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       map2_exn,
       map2,
       rev_map3_exn,
       rev_map3,
       map3_exn,
       map3,
       rev_map_append,
       fold_right,
       fold,
       unzip,
       unzip3,
       zip,
       zip_exn,
       rev_mapi,
       reduce_exn,
       reduce,
       reduce_balanced,
       reduce_balanced_exn,
       group,
       groupi,
       sort_and_group,
       chunks_of,
       last,
       last_exn,
       is_prefix,
       is_suffix,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       dedup_and_sort,
       stable_dedup,
       find_a_dup,
       contains_dup,
       find_all_dups,
       all_equal,
       range$0,
       range,
       rev_filter_map,
       rev_filter_mapi,
       filter_opt,
       [0,
        t_of_sexp$0,
        sexp_of_t$1,
        t_sexp_grammar$0,
        add,
        find$0,
        find_exn$0,
        mem$0,
        remove,
        map$2,
        inverse,
        group$0,
        sort_and_group$0],
       sub,
       take,
       drop,
       take_while,
       drop_while,
       split_while,
       drop_last,
       drop_last_exn,
       concat_no_order,
       cons,
       cartesian_product,
       permute,
       random_element,
       random_element_exn,
       is_sorted,
       is_sorted_strictly,
       equal,
       equal_local,
       Infix,
       transpose,
       transpose_exn,
       intersperse];
   runtime.caml_register_global(62, Base_List, "Base__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info
//# unitInfo: Requires: Base__Exn, Base__Hash, Base__Import, Base__Info_intf, Base__List, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Source_code_position0, Base__String0, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    _j_ = [0, [0, "cycle while computing message"]],
    t_sexp_grammar = [0, "Info.t"],
    module_name = "Base.Info",
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_List = global_data.Base__List,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_String0 = global_data.Base__String0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    _l_ = [0, "src/info.ml", 261, 6],
    _a_ = [0, "Could_not_construct"],
    _b_ = [0, "String"],
    _c_ = [0, "Exn"],
    _d_ = [0, "Sexp"],
    _e_ = [0, "Tag_sexp"],
    _f_ = [0, "Tag_t"],
    _g_ = [0, "Tag_arg"],
    _h_ = [0, "Of_list"],
    _i_ = [0, "With_backtrace"],
    cst_Base_Info_Exn = "Base__Info.Exn";
   function sexp_of_t(param){
    switch(param[0]){
      case 0:
       var arg0_001 = param[1], res0_002 = caml_call1(Base_Sexp[5], arg0_001);
       return [1, [0, _a_, [0, res0_002, 0]]];
      case 1:
       var
        arg0_003 = param[1],
        res0_004 = caml_call1(Base_Import[136], arg0_003);
       return [1, [0, _b_, [0, res0_004, 0]]];
      case 2:
       var
        arg0_005 = param[1],
        res0_006 = caml_call1(Base_Import[198], arg0_005);
       return [1, [0, _c_, [0, res0_006, 0]]];
      case 3:
       var arg0_007 = param[1], res0_008 = caml_call1(Base_Sexp[5], arg0_007);
       return [1, [0, _d_, [0, res0_008, 0]]];
      case 4:
       var
        arg2_011 = param[3],
        arg1_010 = param[2],
        arg0_009 = param[1],
        res0_012 = caml_call1(Base_Import[136], arg0_009),
        res1_013 = caml_call1(Base_Sexp[5], arg1_010),
        res2_014 =
          caml_call2
           (Base_Import[146], Base_Source_code_position0[9], arg2_011);
       return [1, [0, _e_, [0, res0_012, [0, res1_013, [0, res2_014, 0]]]]];
      case 5:
       var
        arg1_016 = param[2],
        arg0_015 = param[1],
        res0_017 = caml_call1(Base_Import[136], arg0_015),
        res1_018 = sexp_of_t(arg1_016);
       return [1, [0, _f_, [0, res0_017, [0, res1_018, 0]]]];
      case 6:
       var
        arg2_021 = param[3],
        arg1_020 = param[2],
        arg0_019 = param[1],
        res0_022 = caml_call1(Base_Import[136], arg0_019),
        res1_023 = caml_call1(Base_Sexp[5], arg1_020),
        res2_024 = sexp_of_t(arg2_021);
       return [1, [0, _g_, [0, res0_022, [0, res1_023, [0, res2_024, 0]]]]];
      case 7:
       var
        arg1_026 = param[2],
        arg0_025 = param[1],
        res0_027 = caml_call2(Base_Import[146], Base_Import[139], arg0_025),
        res1_028 = caml_call2(Base_Import[149], sexp_of_t, arg1_026);
       return [1, [0, _h_, [0, res0_027, [0, res1_028, 0]]]];
      default:
       var
        arg1_030 = param[2],
        arg0_029 = param[1],
        res0_031 = sexp_of_t(arg0_029),
        res1_032 = caml_call1(Base_Import[136], arg1_030);
       return [1, [0, _i_, [0, res0_031, [0, res1_032, 0]]]];
    }
   }
   function to_sexps_hum(t, ac){
    switch(t[0]){
      case 0:
       return [0, sexp_of_t(t), ac];
      case 1:
       var string = t[1]; return [0, [0, string], ac];
      case 2:
       var exn = t[1]; return [0, caml_call1(Base_Exn[1], exn), ac];
      case 3:
       var sexp = t[1]; return [0, sexp, ac];
      case 4:
       var here = t[3], sexp$0 = t[2], tag = t[1];
       if(here)
        var
         here$0 = here[1],
         _T_ = [0, caml_call1(Base_Source_code_position0[9], here$0), 0];
       else
        var _T_ = 0;
       return [0, [1, [0, [0, tag], [0, sexp$0, _T_]]], ac];
      case 5:
       var t$0 = t[2], tag$0 = t[1];
       return [0, [1, [0, [0, tag$0], to_sexps_hum(t$0, 0)]], ac];
      case 6:
       var
        t$1 = t[3],
        sexp$1 = t[2],
        tag$1 = t[1],
        body = [0, sexp$1, to_sexps_hum(t$1, 0)];
       return 0 === runtime.caml_ml_string_length(tag$1)
               ? [0, [1, body], ac]
               : [0, [1, [0, [0, tag$1], body]], ac];
      case 7:
       var
        ts = t[2],
        _U_ = function(ac, t){return to_sexps_hum(t, ac);},
        _V_ = caml_call1(Base_List[63], ts);
       return caml_call3(Base_List[20], _V_, ac, _U_);
      default:
       var
        backtrace = t[2],
        t$2 = t[1],
        _W_ = caml_call1(Base_String0[22], backtrace),
        _X_ = [0, caml_call2(Base_Import[149], Base_Import[136], _W_), 0];
       return [0, [1, [0, to_sexp_hum(t$2), _X_]], ac];
    }
   }
   function to_sexp_hum(t){
    var sexps = to_sexps_hum(t, 0);
    if(sexps && ! sexps[2]){var sexp = sexps[1]; return sexp;}
    return [1, sexps];
   }
   function globalize_info(param){return param;}
   function compute_info$0(counter, info, stack){
    var info$0 = info, stack$0 = stack;
    for(;;){
     var match = info$0[1];
     if(typeof match === "number"){
      if(counter >= 50)
       return caml_trampoline_return(compute_message, [0, _j_, stack$0]);
      var counter$1 = counter + 1 | 0;
      return compute_message(counter$1, _j_, stack$0);
     }
     if(0 !== match[0]){
      var message = match[1];
      if(counter >= 50)
       return caml_trampoline_return(compute_message, [0, message, stack$0]);
      var counter$2 = counter + 1 | 0;
      return compute_message(counter$2, message, stack$0);
     }
     var cons = match[1];
     info$0[1] = 0;
     var stack$1 = [0, [0, info$0], stack$0];
     switch(cons[0]){
       case 0:
        var lazy_info = cons[1];
        try{
         var _R_ = caml_obj_tag(lazy_info);
         a:
         if(250 === _R_)
          var info$1 = lazy_info[1];
         else{
          if(246 !== _R_ && 244 !== _R_){var info$1 = lazy_info; break a;}
          var info$1 = caml_call1(CamlinternalLazy[2], lazy_info);
         }
        }
        catch(exn$0){
         var
          exn = caml_wrap_exception(exn$0),
          _Q_ = [0, caml_call1(Base_Exn[1], exn)];
         if(counter >= 50)
          return caml_trampoline_return(compute_message, [0, _Q_, stack$1]);
         var counter$3 = counter + 1 | 0;
         return compute_message(counter$3, _Q_, stack$1);
        }
        var info$0 = info$1, stack$0 = stack$1;
        break;
       case 1:
        var infos = cons[1], _S_ = 0;
        if(counter >= 50)
         return caml_trampoline_return
                 (compute_info_list, [0, infos, _S_, stack$1]);
        var counter$0 = counter + 1 | 0;
        return compute_info_list(counter$0, infos, _S_, stack$1);
       case 2:
        var
         info$2 = cons[3],
         arg = cons[2],
         tag = cons[1],
         stack$2 = [0, [1, tag, arg], stack$1],
         info$0 = info$2,
         stack$0 = stack$2;
        break;
       default:
        var
         info$3 = cons[2],
         tag$0 = cons[1],
         stack$3 = [0, [2, tag$0], stack$1],
         info$0 = info$3,
         stack$0 = stack$3;
     }
    }
   }
   function compute_info_list(counter, fwd_prefix, rev_suffix, stack){
    if(fwd_prefix){
     var
      fwd_prefix$0 = fwd_prefix[2],
      info = fwd_prefix[1],
      _N_ = [0, [3, fwd_prefix$0, rev_suffix], stack];
     if(counter >= 50)
      return caml_trampoline_return(compute_info$0, [0, info, _N_]);
     var counter$0 = counter + 1 | 0;
     return compute_info$0(counter$0, info, _N_);
    }
    function _O_(tail, message){
     if(7 !== message[0]) return [0, message, tail];
     var messages = message[2];
     return caml_call2(Base_Import[111], messages, tail);
    }
    var
     infos = caml_call3(Base_List[20], rev_suffix, 0, _O_),
     _P_ = [7, 0, infos];
    if(counter >= 50)
     return caml_trampoline_return(compute_message, [0, _P_, stack]);
    var counter$1 = counter + 1 | 0;
    return compute_message(counter$1, _P_, stack);
   }
   function compute_message(counter, message, stack){
    var message$0 = message, stack$0 = stack;
    for(;;){
     if(! stack$0) return message$0;
     var match = stack$0[1];
     switch(match[0]){
       case 0:
        var stack$1 = stack$0[2], info = match[1];
        info[1] = [1, message$0];
        var stack$0 = stack$1;
        break;
       case 1:
        var
         stack$2 = stack$0[2],
         arg = match[2],
         tag = match[1],
         message$1 = [6, tag, arg, message$0],
         message$0 = message$1,
         stack$0 = stack$2;
        break;
       case 2:
        var
         stack$3 = stack$0[2],
         tag$0 = match[1],
         message$2 = [5, tag$0, message$0],
         message$0 = message$2,
         stack$0 = stack$3;
        break;
       default:
        var
         stack$4 = stack$0[2],
         rev_suffix = match[2],
         fwd_prefix = match[1],
         _M_ = [0, message$0, rev_suffix];
        if(counter >= 50)
         return caml_trampoline_return
                 (compute_info_list, [0, fwd_prefix, _M_, stack$4]);
        var counter$0 = counter + 1 | 0;
        return compute_info_list(counter$0, fwd_prefix, _M_, stack$4);
     }
    }
   }
   function compute_info(info, stack){
    return caml_trampoline(compute_info$0(0, info, stack));
   }
   function to_message(info){return compute_info(info, 0);}
   function of_message(message){return [0, [1, message]];}
   function of_cons(cons){return [0, [0, cons]];}
   function of_lazy_cons(lazy_cons){
    return of_cons
            ([0,
              [246,
               function(_J_){
                var _K_ = caml_obj_tag(lazy_cons);
                a:
                if(250 === _K_)
                 var _L_ = lazy_cons[1];
                else{
                 if(246 !== _K_ && 244 !== _K_){var _L_ = lazy_cons; break a;}
                 var _L_ = caml_call1(CamlinternalLazy[2], lazy_cons);
                }
                return of_cons(_L_);
               }]]);
   }
   function of_lazy_message(lazy_message){
    return of_cons
            ([0,
              [246,
               function(_G_){
                var _H_ = caml_obj_tag(lazy_message);
                a:
                if(250 === _H_)
                 var _I_ = lazy_message[1];
                else{
                 if(246 !== _H_ && 244 !== _H_){
                  var _I_ = lazy_message;
                  break a;
                 }
                 var _I_ = caml_call1(CamlinternalLazy[2], lazy_message);
                }
                return of_message(_I_);
               }]]);
   }
   function invariant(param){return 0;}
   function sexp_of_t$0(t){return to_sexp_hum(to_message(t));}
   function t_of_sexp(sexp){return of_message([3, sexp]);}
   function compare(t1, t2){
    var _E_ = sexp_of_t$0(t2), _F_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[7], _F_, _E_);
   }
   function compare_local(t1, t2){return compare(t1, t2);}
   function equal(t1, t2){
    var _C_ = sexp_of_t$0(t2), _D_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[6], _D_, _C_);
   }
   function equal_local(t1, t2){return equal(t1, t2);}
   function hash_fold_t(state, t){
    var _B_ = sexp_of_t$0(t);
    return caml_call2(Base_Sexp[2], state, _B_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string_hum(t){
    var message = to_message(t);
    if(1 === message[0]){var s = message[1]; return s;}
    var _A_ = to_sexp_hum(message);
    return caml_call2(Base_Sexp[16], 0, _A_);
   }
   function to_string_mach(t){
    var _z_ = sexp_of_t$0(t);
    return caml_call1(Base_Sexp[17], _z_);
   }
   function of_lazy(l){
    return of_lazy_message
            ([246,
              function(_w_){
               var _x_ = caml_obj_tag(l);
               a:
               if(250 === _x_)
                var _y_ = l[1];
               else{
                if(246 !== _x_ && 244 !== _x_){var _y_ = l; break a;}
                var _y_ = caml_call1(CamlinternalLazy[2], l);
               }
               return [1, _y_];
              }]);
   }
   function of_lazy_sexp(l){
    return of_lazy_message
            ([246,
              function(_t_){
               var _u_ = caml_obj_tag(l);
               a:
               if(250 === _u_)
                var _v_ = l[1];
               else{
                if(246 !== _u_ && 244 !== _u_){var _v_ = l; break a;}
                var _v_ = caml_call1(CamlinternalLazy[2], l);
               }
               return [3, _v_];
              }]);
   }
   function of_lazy_t(lazy_info){return of_cons([0, lazy_info]);}
   function of_string(message){return of_message([1, message]);}
   function createf(format){
    return caml_call2(Base_Printf[4], of_string, format);
   }
   function of_thunk(f){
    return of_lazy_message
            ([246, function(param){return [1, caml_call1(f, 0)];}]);
   }
   function create(here, strict, tag, x, sexp_of_x){
    return strict
            ? of_message([4, tag, caml_call1(sexp_of_x, x), here])
            : of_lazy_message
              ([246,
                function(param){
                 return [4, tag, caml_call1(sexp_of_x, x), here];
                }]);
   }
   function create_s(sexp){return of_message([3, sexp]);}
   function tag(t, tag){return of_cons([3, tag, t]);}
   function tag_s_lazy(t, tag){
    return of_lazy_cons
            ([246,
              function(_q_){
               var _r_ = caml_obj_tag(tag);
               a:
               if(250 === _r_)
                var _s_ = tag[1];
               else{
                if(246 !== _r_ && 244 !== _r_){var _s_ = tag; break a;}
                var _s_ = caml_call1(CamlinternalLazy[2], tag);
               }
               return [2, cst, _s_, t];
              }]);
   }
   function tag_s(t, tag){return of_cons([2, cst$0, tag, t]);}
   function tag_arg(t, tag, x, sexp_of_x){
    return of_lazy_cons
            ([246,
              function(param){return [2, tag, caml_call1(sexp_of_x, x), t];}]);
   }
   function of_list(ts){return of_cons([1, ts]);}
   var Exn = [248, cst_Base_Info_Exn, runtime.caml_fresh_oo_id(0)];
   function _k_(param){
    if(param[1] !== Exn)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    var t = param[2];
    return sexp_of_t$0(t);
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Exn, _k_);
   function to_exn(info){
    var _o_ = info[1];
    a:
    {
     if(typeof _o_ !== "number" && 1 === _o_[0]){var _p_ = 1; break a;}
     var _p_ = 0;
    }
    if(! _p_) return [0, Exn, info];
    var match = to_message(info);
    if(2 !== match[0]) return [0, Exn, info];
    var exn = match[1];
    return exn;
   }
   function of_exn(backtrace, exn){
    if(backtrace){
     var match = backtrace[1];
     if(typeof match === "number")
      var _n_ = [0, caml_call1(Stdlib_Printexc[6], 0)];
     else
      var s = match[2], _n_ = [0, s];
     var backtrace$0 = _n_;
    }
    else
     var backtrace$0 = 0;
    if(exn[1] === Exn){
     var t = exn[2];
     if(! backtrace$0) return t;
     var backtrace$1 = backtrace$0[1];
     return of_lazy_message
             ([246, function(param){return [8, to_message(t), backtrace$1];}]);
    }
    if(! backtrace$0) return of_message([2, exn]);
    var backtrace$2 = backtrace$0[1];
    return of_lazy_message
            ([246,
              function(param){
               return [8, [3, caml_call1(Base_Exn[1], exn)], backtrace$2];
              }]);
   }
   function pp(ppf, t){
    var _m_ = to_string_hum(t);
    return caml_call2(Stdlib_Format[13], ppf, _m_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Info =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize_info,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       [0, sexp_of_t, to_message, of_message]];
   runtime.caml_register_global(30, Base_Info, "Base__Info");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Error
//# unitInfo: Requires: Base__Info, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [0, "Error.t"],
    module_name = "Base.Error",
    Base_Info = global_data.Base__Info,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Info[1],
    compare_local = Base_Info[2],
    equal = Base_Info[3],
    equal_local = Base_Info[4],
    globalize = Base_Info[5],
    hash_fold_t = Base_Info[6],
    hash = Base_Info[7],
    t_of_sexp = Base_Info[8],
    sexp_of_t = Base_Info[9],
    invariant = Base_Info[11],
    to_string_hum = Base_Info[12],
    to_string_mach = Base_Info[13],
    of_string = Base_Info[14],
    of_lazy = Base_Info[15],
    of_lazy_sexp = Base_Info[16],
    of_thunk = Base_Info[17],
    of_lazy_t = Base_Info[18],
    create = Base_Info[19],
    create_s = Base_Info[20],
    createf = Base_Info[21],
    tag = Base_Info[22],
    tag_s = Base_Info[23],
    tag_s_lazy = Base_Info[24],
    tag_arg = Base_Info[25],
    of_list = Base_Info[26],
    of_exn = Base_Info[27],
    to_exn = Base_Info[28],
    pp = Base_Info[29],
    Internal_repr = Base_Info[30];
   function raise(t){
    throw caml_maybe_attach_backtrace(caml_call1(to_exn, t), 1);
   }
   function raise_s(sexp){return raise(caml_call1(create_s, sexp));}
   function to_info(t){return t;}
   function of_info(t){return t;}
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Error =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       Internal_repr,
       raise,
       raise_s,
       to_info,
       of_info];
   runtime.caml_register_global(4, Base_Error, "Base__Error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant
//# unitInfo: Requires: Base__Error, Base__Field, Base__Import, Base__Invariant_intf, Base__Sexp, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_exn$1 = "exn",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Field = global_data.Base__Field,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[32],
    cst_exn$0 = cst_exn$1,
    cst_field = "field",
    cst_problem_with_field = "problem with field",
    cst_exn = cst_exn$1,
    cst_invariant_failed = "invariant failed";
   function invariant(here, t, sexp_of_t, f){
    try{var _h_ = caml_call1(f, 0); return _h_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _e_ = [0, [0, cst, caml_call1(sexp_of_t, t)], 0],
      _f_ = [0, [0, cst_exn, caml_call1(Base_Import[198], exn)], _e_],
      _g_ =
        [0, [0, cst$0, caml_call1(Base_Source_code_position0[9], here)], _f_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[10], cst_invariant_failed, _g_));
    }
   }
   function check_field(t, f, field){
    try{
     var _d_ = caml_call1(f, caml_call2(Base_Field[3], field, t));
     return _d_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _a_ = [0, [0, cst_exn$0, caml_call1(Base_Import[198], exn)], 0],
      _b_ = caml_call1(Base_Field[2], field),
      _c_ = [0, [0, cst_field, caml_call1(Base_Import[136], _b_)], _a_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[10], cst_problem_with_field, _c_));
    }
   }
   var Base_Invariant = [0, invariant, check_field];
   runtime.caml_register_global(12, Base_Invariant, "Base__Invariant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Or_error
//# unitInfo: Requires: Base__Applicative, Base__Error, Base__Import, Base__List, Base__Printf, Base__Result, Base__With_return
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Error = global_data.Base__Error,
    Base_With_return = global_data.Base__With_return,
    Assert_failure = global_data.Assert_failure,
    Base_Result = global_data.Base__Result,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative,
    _b_ = [0, "src/or_error.ml", 192, 21],
    cst_unimplemented = "unimplemented",
    _a_ = [0, 3553398];
   function compare_local(cmp_a, a_007, b_008){
    return caml_call4(Base_Result[5], cmp_a, Base_Error[2], a_007, b_008);
   }
   function compare(cmp_a, a_001, b_002){
    return caml_call4(Base_Result[4], cmp_a, Base_Error[1], a_001, b_002);
   }
   function equal_local(cmp_a, a_019, b_020){
    return caml_call4(Base_Result[7], cmp_a, Base_Error[4], a_019, b_020);
   }
   function equal(cmp_a, a_013, b_014){
    return caml_call4(Base_Result[6], cmp_a, Base_Error[3], a_013, b_014);
   }
   function globalize(globalize_a_026, x_027){
    return caml_call3(Base_Result[9], globalize_a_026, Base_Error[5], x_027);
   }
   function hash_fold_t(hash_fold_a, hsv, arg){
    return caml_call4(Base_Result[8], hash_fold_a, Base_Error[6], hsv, arg);
   }
   function t_of_sexp(of_a_030, x_032){
    return caml_call3(Base_Result[1], of_a_030, Base_Error[8], x_032);
   }
   function sexp_of_t(of_a_033, x_034){
    return caml_call3(Base_Result[2], of_a_033, Base_Error[9], x_034);
   }
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call2(Base_Result[3], a_sexp_grammar, Base_Error[10]);
   }
   var
    symbol_bind = Base_Result[10],
    symbol_map = Base_Result[11],
    bind = Base_Result[14],
    ignore_m = Base_Result[17],
    join = Base_Result[16],
    map = Base_Result[33],
    return$0 = Base_Result[15];
   function invariant(invariant_a, t){
    if(0 === t[0]){var a = t[1]; return caml_call1(invariant_a, a);}
    var error = t[1];
    return caml_call1(Base_Error[11], error);
   }
   function map2(a, b, f){
    if(0 === a[0]){
     var x = a[1];
     if(0 === b[0]){var y = b[1]; return [0, caml_call2(f, x, y)];}
     var e = b;
    }
    else{
     var e1 = a[1];
     if(0 !== b[0]){
      var e2 = b[1];
      return [1, caml_call1(Base_Error[26], [0, e1, [0, e2, 0]])];
     }
     var e = a;
    }
    return e;
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      caml_call1(Base_Applicative[16], [0, return$0, map2, map$0]),
    symbol = For_applicative[6],
    symbol$0 = For_applicative[5],
    symbol$1 = For_applicative[4],
    apply = For_applicative[8],
    both = For_applicative[3],
    map3 = For_applicative[10],
    include = Base_Result[13],
    symbol_bind$0 = include[1],
    symbol_map$0 = include[2],
    Open_on_rhs = [0],
    ok = Base_Result[26],
    is_ok = Base_Result[24],
    is_error = Base_Result[25];
   function try_with(opt, f){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 0;
    try{var _v_ = [0, caml_call1(f, 0)]; return _v_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), _u_ = backtrace ? _a_ : 0;
     return [1, caml_call2(Base_Error[27], _u_, exn)];
    }
   }
   function try_with_join(backtrace, f){
    return caml_call1(join, try_with(backtrace, f));
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var err = param[1];
    return caml_call1(Base_Error[31], err);
   }
   function of_exn(backtrace, exn){
    return [1, caml_call2(Base_Error[27], backtrace, exn)];
   }
   function of_exn_result(backtrace, z){
    if(0 === z[0]) return z;
    var exn = z[1];
    return of_exn(backtrace, exn);
   }
   var of_option = Base_Result[30];
   function error(here, strict, message, a, sexp_of_a){
    return [1,
            caml_call5(Base_Error[19], here, strict, message, a, sexp_of_a)];
   }
   function error_s(sexp){return [1, caml_call1(Base_Error[20], sexp)];}
   function error_string(message){
    return [1, caml_call1(Base_Error[14], message)];
   }
   function errorf(format){
    return caml_call2(Base_Printf[4], error_string, format);
   }
   function tag(t, tag){
    var _r_ = Base_Error[22];
    function _s_(_t_){return caml_call2(_r_, _t_, tag);}
    return caml_call2(Base_Result[34], t, _s_);
   }
   function tag_s(t, tag){
    var _o_ = Base_Error[23];
    function _p_(_q_){return caml_call2(_o_, _q_, tag);}
    return caml_call2(Base_Result[34], t, _p_);
   }
   function tag_s_lazy(t, tag){
    var _l_ = Base_Error[24];
    function _m_(_n_){return caml_call2(_l_, _n_, tag);}
    return caml_call2(Base_Result[34], t, _m_);
   }
   function tag_arg(t, message, a, sexp_of_a){
    function _k_(e){
     return caml_call4(Base_Error[25], e, message, a, sexp_of_a);
    }
    return caml_call2(Base_Result[34], t, _k_);
   }
   function unimplemented(s){
    return error(0, 0, cst_unimplemented, s, Base_Import[136]);
   }
   function combine_internal(list, on_ok, on_error){
    var match = caml_call1(Base_Result[36], list);
    if(0 === match[0]){var x = match[1]; return [0, caml_call1(on_ok, x)];}
    var errs = match[1];
    return [1, caml_call1(on_error, errs)];
   }
   function ignore_unit_list(param){return 0;}
   function error_of_list_if_necessary(list){
    if(list && ! list[2]){var e = list[1]; return e;}
    return caml_call1(Base_Error[26], list);
   }
   function all(list){
    return combine_internal
            (list, function(_j_){return _j_;}, error_of_list_if_necessary);
   }
   function all_unit(list){
    return combine_internal
            (list, ignore_unit_list, error_of_list_if_necessary);
   }
   function combine_errors(list){
    var _h_ = Base_Error[26];
    return combine_internal(list, function(_i_){return _i_;}, _h_);
   }
   function combine_errors_unit(list){
    return combine_internal(list, ignore_unit_list, Base_Error[26]);
   }
   function filter_ok_at_least_one(l){
    var
     match = caml_call2(Base_List[16], l, Base_Result[38]),
     errs = match[2],
     ok = match[1];
    return ok ? [0, ok] : [1, caml_call1(Base_Error[26], errs)];
   }
   function find_ok(l){
    var match = caml_call2(Base_List[28], l, Base_Result[26]);
    if(match){var x = match[1]; return [0, x];}
    function _f_(param){
     if(0 === param[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var err = param[1];
     return err;
    }
    var _g_ = caml_call2(Base_List[53], l, _f_);
    return [1, caml_call1(Base_Error[26], _g_)];
   }
   function find_map_ok(l, f){
    function _c_(param){
     function _d_(elt){
      var x = caml_call1(f, elt);
      if(0 === x[0]) return caml_call1(param, x);
      var err = x[1];
      return err;
     }
     var _e_ = caml_call2(Base_List[53], l, _d_);
     return [1, caml_call1(Base_Error[26], _e_)];
    }
    return caml_call1(Base_With_return[1], _c_);
   }
   var
    map$1 = Base_Result[33],
    iter = Base_Result[31],
    iter_error = Base_Result[32],
    Base_Or_error =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       both,
       symbol$1,
       symbol$0,
       symbol,
       apply,
       map2,
       map3,
       For_applicative[13],
       invariant,
       symbol_bind,
       symbol_map,
       Base_Result[13],
       bind,
       return$0,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$0,
        symbol_bind$0,
        symbol_map$0,
        [0, return$0, bind, map, both, Open_on_rhs]],
       is_ok,
       is_error,
       try_with,
       try_with_join,
       ok,
       ok_exn,
       of_exn,
       of_exn_result,
       of_option,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       map$1,
       iter,
       iter_error,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_ok,
       find_map_ok];
   runtime.caml_register_global(11, Base_Or_error, "Base__Or_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign0
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Poly0, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign0.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0, [1, [0, cst_Zero, 0]], [0, [1, [0, cst_Pos, 0]], 0]]]]],
    all = [0, 0, [0, 1, [0, 2, 0]]],
    module_name = "Base.Sign",
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _f_ = sexp_004[1];
      b:
      if(caml_string_notequal(_f_, cst_Neg)){
       c:
       if(caml_string_notequal(_f_, cst_Pos)){
        if(caml_string_notequal(_f_, cst_Zero)){
         if(! caml_string_notequal(_f_, cst_neg)) break b;
         if(! caml_string_notequal(_f_, cst_pos)) break c;
         if(caml_string_notequal(_f_, cst_zero)) break a;
        }
        return 1;
       }
       return 2;
      }
      return 0;
     }
     var _g_ = sexp_004[1];
     if(! _g_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_003, sexp_004);
     var _h_ = _g_[1];
     if(0 !== _h_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_003, sexp_004);
     var _i_ = _h_[1];
     b:
     if(caml_string_notequal(_i_, cst_Neg)){
      c:
      if(caml_string_notequal(_i_, cst_Pos)){
       if(caml_string_notequal(_i_, cst_Zero)){
        if(! caml_string_notequal(_i_, cst_neg)) break b;
        if(! caml_string_notequal(_i_, cst_pos)) break c;
        if(caml_string_notequal(_i_, cst_zero)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var compare_local = caml_int_compare, compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       var _e_ = 0; break;
      case 1:
       var _e_ = 1; break;
      default: var _e_ = 2;
    }
    return caml_call2(Base_Hash[3], hsv, _e_);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function equal_local(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    Replace_polymorphic_compare =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       ascending,
       descending,
       compare$0,
       equal,
       equal_local,
       max,
       min];
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[136], s));}
   function to_string(t){
    var _d_ = sexp_of_t(t);
    return caml_call1(Base_Import[160], _d_);
   }
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   var
    Base_Sign0 =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare_local,
       compare,
       hash_fold_t,
       all,
       Replace_polymorphic_compare,
       of_string,
       to_string,
       to_int,
       to_int,
       module_name,
       of_int];
   runtime.caml_register_global(23, Base_Sign0, "Base__Sign0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparable_intf = [0];
   runtime.caml_register_global
    (0, Base_Comparable_intf, "Base__Comparable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable
//# unitInfo: Requires: Base__Comparable_intf, Base__Comparator, Base__Or_error, Base__Poly0, Base__Sexp, Base__Sign0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_clamp_requires_min_max$1 = "clamp requires [min <= max]",
    cst_max$1 = "max",
    cst_min$1 = "min",
    cst_src_comparable_ml = "src/comparable.ml",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Sign0 = global_data.Base__Sign0,
    cst_max$0 = cst_max$1,
    cst_min$0 = cst_min$1,
    cst_clamp_requires_min_max$0 = cst_clamp_requires_min_max$1,
    _b_ = [0, cst_src_comparable_ml, 135, 4],
    cst_max = cst_max$1,
    cst_min = cst_min$1,
    cst_clamp_requires_min_max = cst_clamp_requires_min_max$1,
    _a_ = [0, cst_src_comparable_ml, 47, 4];
   function geq(cmp, a, b){return 0 <= caml_call2(cmp, a, b) ? 1 : 0;}
   function leq(cmp, a, b){return caml_call2(cmp, a, b) <= 0 ? 1 : 0;}
   function equal(cmp, a, b){return 0 === caml_call2(cmp, a, b) ? 1 : 0;}
   function min(cmp, t$0, t){return leq(cmp, t$0, t) ? t$0 : t;}
   function max(cmp, t$0, t){return geq(cmp, t$0, t) ? t$0 : t;}
   function Infix(T){
    function symbol(a, b){
     var cmp = T[1];
     return 0 < caml_call2(cmp, a, b) ? 1 : 0;
    }
    function symbol$0(a, b){
     var cmp = T[1];
     return caml_call2(cmp, a, b) < 0 ? 1 : 0;
    }
    function symbol$1(a, b){return geq(T[1], a, b);}
    function symbol$2(a, b){return leq(T[1], a, b);}
    function symbol$3(a, b){return equal(T[1], a, b);}
    function symbol$4(a, b){
     var cmp = T[1];
     return 0 !== caml_call2(cmp, a, b) ? 1 : 0;
    }
    return [0, symbol$1, symbol$2, symbol$3, symbol, symbol$0, symbol$4];
   }
   function Comparisons(T){
    var
     include = Infix(T),
     symbol = include[1],
     symbol$0 = include[2],
     symbol$1 = include[3],
     symbol$2 = include[4],
     symbol$3 = include[5],
     symbol$4 = include[6],
     compare = T[1];
    function min$0(t$0, t){return min(compare, t$0, t);}
    function max$0(t$0, t){return max(compare, t$0, t);}
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            symbol$1,
            compare,
            min$0,
            max$0];
   }
   function Make_using_comparator(T){
    var
     sexp_of_t = T[1],
     comparator = T[2],
     compare = comparator[1],
     Replace_polymorphic_compare = Comparisons([0, compare]),
     symbol = Replace_polymorphic_compare[1],
     symbol$0 = Replace_polymorphic_compare[2],
     symbol$1 = Replace_polymorphic_compare[3],
     symbol$2 = Replace_polymorphic_compare[4],
     symbol$3 = Replace_polymorphic_compare[5],
     symbol$4 = Replace_polymorphic_compare[6],
     equal = Replace_polymorphic_compare[7],
     compare$0 = Replace_polymorphic_compare[8],
     min = Replace_polymorphic_compare[9],
     max = Replace_polymorphic_compare[10];
    function descending(t$0, t){return caml_call2(compare$0, t, t$0);}
    function between(t, low, high){
     var _s_ = caml_call2(symbol$0, low, t);
     return _s_ ? caml_call2(symbol$0, t, high) : _s_;
    }
    function clamp_unchecked(t, min, max){
     return caml_call2(symbol$3, t, min)
             ? min
             : caml_call2(symbol$0, t, max) ? t : max;
    }
    function clamp_exn(t, min, max){
     if(caml_call2(symbol$0, min, max)) return clamp_unchecked(t, min, max);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    }
    function clamp(t, min, max){
     if(! caml_call2(symbol$2, min, max))
      return [0, clamp_unchecked(t, min, max)];
     var
      _p_ = [0, [0, cst_max$0, caml_call1(sexp_of_t, max)], 0],
      _q_ = [0, [0, cst_min$0, caml_call1(sexp_of_t, min)], _p_],
      _r_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max$0, _q_);
     return caml_call1(Base_Or_error[39], _r_);
    }
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            compare$0,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator];
   }
   function Make(T){
    var
     sexp_of_t = T[2],
     include = caml_call1(Base_Comparator[7], T),
     comparator = include[1];
    return Make_using_comparator([0, sexp_of_t, comparator]);
   }
   function Inherit(C, T){
    var sexp_of_t = T[1];
    function compare(t$0, t){
     var _n_ = caml_call1(T[2], t), _o_ = caml_call1(T[2], t$0);
     return caml_call2(C[1], _o_, _n_);
    }
    return Make([0, compare, sexp_of_t]);
   }
   function lexicographic(cmps, x, y){
    var param = cmps;
    for(;;){
     if(! param) return 0;
     var cmps$0 = param[2], cmp = param[1], res = caml_call2(cmp, x, y);
     if(0 !== res) return res;
     var param = cmps$0;
    }
   }
   function lift(cmp, f, x, y){
    var _m_ = caml_call1(f, y);
    return caml_call2(cmp, caml_call1(f, x), _m_);
   }
   function reverse(cmp, x, y){return caml_call2(cmp, y, x);}
   function compare_reversed(cmp, x, y){return caml_call2(cmp, y, x);}
   function _c_(_i_){
    var _j_ = _i_[3], _k_ = _i_[1];
    function is_positive(t){return 0 < caml_call2(_k_, t, _j_) ? 1 : 0;}
    function is_non_negative(t){return 0 <= caml_call2(_k_, t, _j_) ? 1 : 0;}
    function is_negative(t){return caml_call2(_k_, t, _j_) < 0 ? 1 : 0;}
    function is_non_positive(t){return caml_call2(_k_, t, _j_) <= 0 ? 1 : 0;}
    function sign(t){
     var _l_ = caml_call2(_k_, t, _j_);
     return caml_call1(Base_Sign0[14], _l_);
    }
    return [0,
            is_positive,
            is_non_negative,
            is_negative,
            is_non_positive,
            sign];
   }
   var
    Base_Comparable =
      [0,
       lexicographic,
       lift,
       reverse,
       compare_reversed,
       equal,
       max,
       min,
       Infix,
       Comparisons,
       Inherit,
       Make,
       Make_using_comparator,
       function(T){
        var
         sexp_of_t = T[1],
         ascending = Base_Poly0[1],
         descending = Base_Poly0[2],
         min = Base_Poly0[3],
         max = Base_Poly0[4];
        function between(t, low, high){
         var
          _g_ = caml_lessequal(low, t),
          _h_ = _g_ ? caml_lessequal(t, high) : _g_;
         return _h_;
        }
        function clamp_unchecked(t, min, max){
         return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
        }
        function clamp_exn(t, min, max){
         if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        }
        function clamp(t, min, max){
         if(! caml_greaterthan(min, max))
          return [0, clamp_unchecked(t, min, max)];
         var
          _d_ = [0, [0, cst_max, caml_call1(T[1], max)], 0],
          _e_ = [0, [0, cst_min, caml_call1(T[1], min)], _d_],
          _f_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _e_);
         return caml_call1(Base_Or_error[39], _f_);
        }
        var
         include =
           caml_call1(Base_Comparator[7], [0, caml_compare, sexp_of_t]),
         comparator = include[1];
        return [0,
                runtime.caml_greaterequal,
                caml_lessequal,
                caml_equal,
                caml_greaterthan,
                caml_lessthan,
                runtime.caml_notequal,
                caml_equal,
                caml_compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator];
       },
       _c_];
   runtime.caml_register_global(14, Base_Comparable, "Base__Comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable_intf
//# unitInfo: Requires: Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    _a_ = [0, "_"];
   function equal(a, b){
    var _b_ = a === b ? 1 : 0;
    if(_b_)
     var _c_ = _b_;
    else{
     var _d_ = a[1] === b[1] ? 1 : 0;
     if(_d_)
      var
       _e_ = a[2] === b[2] ? 1 : 0,
       _c_ = _e_ ? a[3] === b[3] ? 1 : 0 : _e_;
     else
      var _c_ = _d_;
    }
    return _c_;
   }
   var
    hash_param = Base_Import[85][105][30],
    hash = Base_Import[85][105][28],
    poly = [0, hash, runtime.caml_compare, function(param){return _a_;}];
   function of_key(Key){return [0, Key[3], Key[1], Key[2]];}
   function to_key(param){
    var sexp_of_t = param[3], compare = param[2], hash = param[1];
    return [0, compare, sexp_of_t, hash];
   }
   var
    Hashable = [0, equal, hash_param, hash, poly, of_key, to_key],
    equal$0 = Hashable[1],
    hash_param$0 = Hashable[2],
    hash$0 = Hashable[3],
    poly$0 = Hashable[4],
    of_key$0 = Hashable[5],
    to_key$0 = Hashable[6],
    Base_Hashable_intf =
      [0, Hashable, equal$0, hash_param$0, hash$0, poly$0, of_key$0, to_key$0];
   runtime.caml_register_global(2, Base_Hashable_intf, "Base__Hashable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable
//# unitInfo: Requires: Base__Hashable_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Hashable_intf = global_data.Base__Hashable_intf,
    equal = Base_Hashable_intf[2],
    hash_param = Base_Hashable_intf[3],
    hash = Base_Hashable_intf[4],
    poly = Base_Hashable_intf[5],
    of_key = Base_Hashable_intf[6],
    to_key = Base_Hashable_intf[7],
    Base_Hashable = [0, equal, poly, of_key, to_key, hash_param, hash];
   runtime.caml_register_global(1, Base_Hashable, "Base__Hashable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stringable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stringable = [0];
   runtime.caml_register_global(0, Base_Stringable, "Base__Stringable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Identifiable_intf = [0];
   runtime.caml_register_global
    (0, Base_Identifiable_intf, "Base__Identifiable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable
//# unitInfo: Requires: Base__Comparable, Base__Identifiable_intf, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer;
   function _a_(T){
    var
     hash_fold_t = T[2],
     hash = T[3],
     t_of_sexp = T[4],
     sexp_of_t = T[5],
     of_string = T[6],
     to_string = T[7],
     _c_ = caml_call1(Base_Comparable[12], [0, T[5], T[9]]),
     symbol = _c_[1],
     symbol$0 = _c_[2],
     symbol$1 = _c_[3],
     symbol$2 = _c_[4],
     symbol$3 = _c_[5],
     symbol$4 = _c_[6],
     equal = _c_[7],
     compare = _c_[8],
     min = _c_[9],
     max = _c_[10],
     ascending = _c_[11],
     descending = _c_[12],
     between = _c_[13],
     clamp_exn = _c_[14],
     clamp = _c_[15],
     comparator = _c_[16],
     include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
     pp = include[1],
     hashable = [0, hash, compare, sexp_of_t];
    return [0,
            hash_fold_t,
            hash,
            t_of_sexp,
            sexp_of_t,
            of_string,
            to_string,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare,
            min,
            max,
            ascending,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator,
            pp,
            hashable];
   }
   var
    Base_Identifiable =
      [0,
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         _b_ = caml_call1(Base_Comparable[11], [0, T[1], T[5]]),
         symbol = _b_[1],
         symbol$0 = _b_[2],
         symbol$1 = _b_[3],
         symbol$2 = _b_[4],
         symbol$3 = _b_[5],
         symbol$4 = _b_[6],
         equal = _b_[7],
         compare = _b_[8],
         min = _b_[9],
         max = _b_[10],
         ascending = _b_[11],
         descending = _b_[12],
         between = _b_[13],
         clamp_exn = _b_[14],
         clamp = _b_[15],
         comparator = _b_[16],
         include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       },
       _a_];
   runtime.caml_register_global(2, Base_Identifiable, "Base__Identifiable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Unit
//# unitInfo: Requires: Base__Identifiable, Base__Import
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$0 = "()";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    all = [0, 0, 0],
    module_name = "Base.Unit",
    Base_Import = global_data.Base__Import,
    Base_Identifiable = global_data.Base__Identifiable,
    globalize = Base_Import[290],
    hash_fold_t = Base_Import[210],
    func = Base_Import[224],
    cst_Base_Unit_of_string_expect = "Base.Unit.of_string: () expected";
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[158],
    sexp_of_t = Base_Import[134],
    t_sexp_grammar = Base_Import[180];
   function compare(param, _c_){return 0;}
   function compare_local(param, _b_){return 0;}
   function equal_local(param, _a_){return 1;}
   function of_string(param){
    return runtime.caml_string_notequal(param, cst$0)
            ? caml_call1(Base_Import[124], cst_Base_Unit_of_string_expect)
            : 0;
   }
   function to_string(param){return cst;}
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function invariant(param){return 0;}
   var
    Base_Unit =
      [0,
       all,
       globalize,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       equal_local,
       compare_local,
       invariant];
   runtime.caml_register_global(7, Base_Unit, "Base__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common
//# unitInfo: Requires: Base__Error, Base__Ordered_collection_common0, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Base_Error = global_data.Base__Error,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    get_pos_len_exn = Base_Ordered_collection_common[1],
    check_pos_len_exn = Base_Ordered_collection_common[2],
    Private = Base_Ordered_collection_common[3];
   function get_pos_len(pos, len, param, total_length){
    try{
     var _a_ = [0, caml_call4(get_pos_len_exn, pos, len, 0, total_length)];
     return _a_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var s = exn[2];
     return [1, caml_call1(Base_Error[14], s)];
    }
   }
   var
    Base_Ordered_collection_common$0 =
      [0, get_pos_len_exn, check_pos_len_exn, Private, get_pos_len];
   runtime.caml_register_global
    (3, Base_Ordered_collection_common$0, "Base__Ordered_collection_common");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_search
//# unitInfo: Requires: Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function find_first_satisfying(pos, len, t, get, length, pred){
    var
     _e_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _e_),
     len$0 = match[2],
     pos$0 = match[1],
     _f_ = caml_call2(Base_Import[91], pos$0, len$0),
     hi$0 = caml_call2(Base_Import[93], _f_, 1),
     lo$1 = pos$0,
     hi = hi$0;
    for(;;){
     if(8 >= caml_call2(Base_Import[93], hi, lo$1)) break;
     var
      _c_ = caml_call2(Base_Import[93], hi, lo$1),
      _d_ = caml_call2(Base_Import[95], _c_, 2),
      mid = caml_call2(Base_Import[91], lo$1, _d_);
     if(caml_call1(pred, caml_call2(get, t, mid)))
      var hi = mid;
     else
      var lo$2 = caml_call2(Base_Import[91], mid, 1), lo$1 = lo$2;
    }
    var lo = lo$1;
    for(;;){
     if(hi < lo) return 0;
     if(caml_call1(pred, caml_call2(get, t, lo))) return [0, lo];
     var lo$0 = caml_call2(Base_Import[91], lo, 1), lo = lo$0;
    }
   }
   function find_last_satisfying(pos, len, t, pred, get, length){
    var
     _a_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _a_),
     len$0 = match[2],
     pos$0 = match[1];
    if(0 === len$0) return 0;
    var
     match$0 =
       find_first_satisfying
        ([0, pos$0],
         [0, len$0],
         t,
         get,
         length,
         function(x){return 1 - caml_call1(pred, x);});
    if(match$0){
     var i = match$0[1];
     return i === pos$0 ? 0 : [0, caml_call2(Base_Import[93], i, 1)];
    }
    var _b_ = caml_call2(Base_Import[91], pos$0, len$0);
    return [0, caml_call2(Base_Import[93], _b_, 1)];
   }
   function binary_search(pos, len, t, length, get, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;},
                  get,
                  length)
             : -253007807
               <= how
               ? find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
                  get,
                  length)
               : find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      match =
        find_last_satisfying
         (pos,
          len,
          t,
          function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
          get,
          length);
     if(match){
      var x = match[1];
      if(0 === caml_call2(compare, caml_call2(get, t, x), v)) return [0, x];
     }
     return 0;
    }
    var
     match$0 =
       find_first_satisfying
        (pos,
         len,
         t,
         get,
         length,
         function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(match$0){
     var x$0 = match$0[1];
     if(0 === caml_call2(compare, caml_call2(get, t, x$0), v))
      return [0, x$0];
    }
    return 0;
   }
   function binary_search_segmented(pos, len, t, length, get, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(pos, len, t, is_left, get, length)
            : find_first_satisfying(pos, len, t, get, length, is_right);
   }
   var Base_Binary_search = [0, binary_search, binary_search_segmented];
   runtime.caml_register_global(2, Base_Binary_search, "Base__Binary_search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    all =
      [0,
       200870407,
       [0,
        -253007807,
        [0, -1055410545, [0, -1056898635, [0, 926943384, [0, -839473056, 0]]]]]],
    all$0 = [0, 125585502, [0, -63348021, 0]],
    Which_target_by_key = [0, all],
    Which_target_by_segment = [0, all$0],
    Base_Binary_searchable_intf =
      [0, Which_target_by_key, Which_target_by_segment];
   runtime.caml_register_global
    (2, Base_Binary_searchable_intf, "Base__Binary_searchable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable
//# unitInfo: Requires: Base__Binary_search, Base__Binary_searchable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Binary_search = global_data.Base__Binary_search;
   function Make_gen(T){
    var get = T[1], length = T[2];
    function binary_search(pos, len, t, compare, how, v){
     return caml_call8
             (Base_Binary_search[1],
              pos,
              len,
              t,
              length,
              get,
              compare,
              how,
              v);
    }
    function binary_search_segmented(pos, len, t, segment_of, how){
     return caml_call7
             (Base_Binary_search[2],
              pos,
              len,
              t,
              length,
              get,
              segment_of,
              how);
    }
    return [0, , , binary_search, binary_search_segmented];
   }
   function _a_(T){
    var get = T[1], length = T[2], _c_ = Make_gen([0, get, length]);
    return [0, _c_[3], _c_[4]];
   }
   var
    Base_Binary_searchable =
      [0,
       function(T){
        var get = T[1], length = T[2], _b_ = Make_gen([0, get, length]);
        return [0, _b_[3], _b_[4]];
       },
       _a_];
   runtime.caml_register_global
    (1, Base_Binary_searchable, "Base__Binary_searchable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Blit_intf = [0];
   runtime.caml_register_global(0, Base_Blit_intf, "Base__Blit_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes0
//# unitInfo: Requires: Base__Import0, Base__Int_conversions, Base__Sys0, Base__Uchar0, Stdlib__BytesLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Uchar0 = global_data.Base__Uchar0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Primitives = [0],
    max_length = Base_Sys0[10],
    blit = Stdlib_BytesLabels[11],
    blit_string = Stdlib_BytesLabels[12],
    compare = Stdlib_BytesLabels[40],
    copy = Stdlib_BytesLabels[4],
    create = caml_create_bytes,
    set_uchar_utf_8 = Stdlib_BytesLabels[51],
    set_uchar_utf_16le = Stdlib_BytesLabels[57],
    set_uchar_utf_16be = Stdlib_BytesLabels[54],
    cst_Bytes_create_local = "Bytes.create_local";
   function set_utf_32_uchar(set_int32, bytes, idx, uchar){
    var
     _o_ = caml_call1(Base_Uchar0[8], uchar),
     _p_ = caml_call1(Base_Int_conversions[3], _o_);
    caml_call1(caml_call2(set_int32, bytes, idx), _p_);
    return 4;
   }
   var _a_ = Stdlib_BytesLabels[83];
   function set_uchar_utf_32le(_l_, _m_, _n_){
    return set_utf_32_uchar(_a_, _l_, _m_, _n_);
   }
   var _b_ = Stdlib_BytesLabels[82];
   function set_uchar_utf_32be(_i_, _j_, _k_){
    return set_utf_32_uchar(_b_, _i_, _j_, _k_);
   }
   function create_local(len){
    if(Base_Sys0[10] < len)
     caml_call1(Base_Import0[126], cst_Bytes_create_local);
    return runtime.Base_unsafe_create_local_bytes(len);
   }
   var fill = Stdlib_BytesLabels[10], make = Stdlib_BytesLabels[1];
   function map(t, f){
    var l = caml_ml_bytes_length(t);
    if(0 === l) return t;
    var
     r = caml_create_bytes(l),
     _g_ = caml_call2(Base_Import0[93], l, 1),
     _f_ = 0;
    if(_g_ >= 0){
     var i = _f_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(t, i)));
      var _h_ = i + 1 | 0;
      if(_g_ === i) break;
      var i = _h_;
     }
    }
    return r;
   }
   function mapi(t, f){
    var l = caml_ml_bytes_length(t);
    if(0 === l) return t;
    var
     r = caml_create_bytes(l),
     _d_ = caml_call2(Base_Import0[93], l, 1),
     _c_ = 0;
    if(_d_ >= 0){
     var i = _c_;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(t, i)));
      var _e_ = i + 1 | 0;
      if(_d_ === i) break;
      var i = _e_;
     }
    }
    return r;
   }
   var
    sub = Stdlib_BytesLabels[7],
    to_string = Stdlib_BytesLabels[6],
    of_string = Stdlib_BytesLabels[5],
    Base_Bytes0 =
      [0,
       Primitives,
       max_length,
       blit,
       blit_string,
       compare,
       copy,
       create,
       set_uchar_utf_8,
       set_uchar_utf_16le,
       set_uchar_utf_16be,
       set_utf_32_uchar,
       set_uchar_utf_32le,
       set_uchar_utf_32be,
       create_local,
       fill,
       make,
       map,
       mapi,
       sub,
       to_string,
       of_string];
   runtime.caml_register_global(6, Base_Bytes0, "Base__Bytes0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit
//# unitInfo: Requires: Base__Blit_intf, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function Make_gen(Src, Dst){
    var unsafe_blit = Dst[3];
    function blit(src, src_pos, dst, dst_pos, len){
     var _o_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], src_pos, len, _o_);
     var _p_ = caml_call1(Dst[1], dst);
     caml_call3(Base_Ordered_collection_common[2], dst_pos, len, _p_);
     var _q_ = 0 < len ? 1 : 0;
     return _q_
             ? caml_call5(unsafe_blit, src, src_pos, dst, dst_pos, len)
             : _q_;
    }
    function blito(src, opt, _m_, dst, _l_, param){
     if(opt) var sth = opt[1], src_pos = sth; else var src_pos = 0;
     if(_m_)
      var sth$0 = _m_[1], src_len = sth$0;
     else
      var
       _n_ = caml_call1(Src[1], src),
       src_len = caml_call2(Base_Import[93], _n_, src_pos);
     if(_l_) var sth$1 = _l_[1], dst_pos = sth$1; else var dst_pos = 0;
     return blit(src, src_pos, dst, dst_pos, src_len);
    }
    function sub(src, pos, len){
     var _k_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], pos, len, _k_);
     var dst = caml_call2(Dst[2], len, src);
     if(0 < len) caml_call5(unsafe_blit, src, pos, dst, 0, len);
     return dst;
    }
    function subo(opt, len, src){
     if(opt) var sth = opt[1], pos = sth; else var pos = 0;
     if(len)
      var i = len[1], i$0 = i;
     else
      var
       _j_ = caml_call1(Src[1], src),
       i$0 = caml_call2(Base_Import[93], _j_, pos);
     return sub(src, pos, i$0);
    }
    return [0, unsafe_blit, blit, blito, sub, subo];
   }
   function Make_to_string(T, To_bytes){
    function sub(src, pos, len){
     return caml_string_of_bytes(caml_call3(To_bytes[4], src, pos, len));
    }
    function subo(pos, len, src){
     return caml_string_of_bytes(caml_call3(To_bytes[5], pos, len, src));
    }
    return [0, sub, subo];
   }
   function _a_(_h_){
    var _i_ = Make_gen([0, _h_[2]], [0, _h_[2], _h_[1], _h_[3]]);
    return [0, _i_[2], _i_[3], _i_[1], _i_[4], _i_[5]];
   }
   function _b_(_e_){
    var _f_ = [0, _e_[2], _e_[1], _e_[3]], _g_ = Make_gen([0, _f_[1]], _f_);
    return [0, _g_[2], _g_[3], _g_[1], _g_[4], _g_[5]];
   }
   function _c_(Src, Dst){
    var length = Dst[1];
    function create_like(len, param){return caml_call1(Dst[2], len);}
    var
     unsafe_blit = Dst[3],
     length$0 = Src[1],
     _d_ = Make_gen([0, length$0], [0, length, create_like, unsafe_blit]);
    return [0, _d_[2], _d_[3], _d_[1], _d_[4], _d_[5]];
   }
   var
    Base_Blit =
      [0,
       function(Sequence){
        function create_like(len, param){return caml_call1(Sequence[2], len);}
        var
         length = Sequence[1],
         unsafe_blit = Sequence[3],
         include =
           Make_gen([0, length], [0, length, create_like, unsafe_blit]),
         unsafe_blit$0 = include[1],
         blit = include[2],
         blito = include[3],
         sub = include[4],
         subo = include[5];
        return [0, blit, blito, unsafe_blit$0, sub, subo];
       },
       _c_,
       Make_to_string,
       _b_,
       _a_];
   runtime.caml_register_global(2, Base_Blit, "Base__Blit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool
//# unitInfo: Requires: Base__Bool0, Base__Comparator, Base__Import, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_bool_ml = "src/bool.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, 0]],
    module_name = "Base.Bool",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Printf = global_data.Base__Printf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    invalid_argf = Base_Printf[7],
    compare = Base_Import[225],
    globalize = Base_Import[281],
    hash_fold_t = Base_Import[207],
    func = Base_Import[221],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, cst_src_bool_ml, 59, 2],
    _a_ =
      [0,
       [11, "Bool.of_string: expected true or false but got ", [2, 0, 0]],
       "Bool.of_string: expected true or false but got %s"],
    _c_ = [0, cst_src_bool_ml, 86, 9];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[159],
    sexp_of_t = Base_Import[135],
    t_sexp_grammar = Base_Import[181],
    hashable = [0, hash, compare, sexp_of_t];
   function of_string(s){
    return caml_string_notequal(s, "false")
            ? caml_string_notequal
               (s, "true")
              ? caml_call3(invalid_argf, _a_, s, 0)
              : 1
            : 0;
   }
   var
    to_string = Base_Import[85][30],
    include = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t]),
    comparator = include[1],
    include$0 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$0[1];
   function invariant(param){return 0;}
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[105][2], low, t);
    return _k_ ? caml_call2(Base_Import[105][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[105][1], t, min)
            ? min
            : caml_call2(Base_Import[105][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[105][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[105][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[39], _j_);
   }
   function to_int(x){return caml_call1(Base_Import[86], x);}
   function symbol(a, b){
    var _f_ = to_int(b), _g_ = to_int(a);
    return caml_call2(Base_Import[118], _g_, _f_);
   }
   function symbol$0(a, b){
    var _d_ = to_int(b), _e_ = to_int(a);
    return caml_call2(Base_Import[116], _e_, _d_);
   }
   if(1 === to_int(1) && 0 === to_int(0)){
    var
     include$1 = Base_Import[105],
     symbol$1 = include$1[1],
     symbol$2 = include$1[2],
     symbol$3 = include$1[3],
     symbol$4 = include$1[4],
     symbol$5 = include$1[5],
     symbol$6 = include$1[6],
     ascending = include$1[7],
     descending = include$1[8],
     compare$0 = include$1[9],
     compare_local = include$1[10],
     equal = include$1[11],
     equal_local = include$1[12],
     max = include$1[13],
     min = include$1[14],
     Base_Bool =
       [0,
        all,
        globalize,
        t_sexp_grammar,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        symbol$6,
        symbol$2,
        symbol$4,
        symbol$5,
        symbol$1,
        symbol$3,
        equal,
        compare$0,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        compare_local,
        equal_local,
        invariant,
        to_int,
        [0, symbol$0, symbol]];
    runtime.caml_register_global(17, Base_Bool, "Base__Bool");
    return;
   }
   throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
  }
  (globalThis));

//# unitInfo: Provides: Base__Either_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Either_intf = [0];
   runtime.caml_register_global(0, Base_Either_intf, "Base__Either_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either
//# unitInfo: Requires: Base__Applicative, Base__Either0, Base__Either_intf, Base__List0, Base__Monad, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_With_return = global_data.Base__With_return,
    Base_List0 = global_data.Base__List0,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    Base_Either0 = global_data.Base__Either0,
    compare_local = Base_Either0[1],
    compare = Base_Either0[2],
    hash_fold_t = Base_Either0[3],
    t_of_sexp = Base_Either0[4],
    sexp_of_t = Base_Either0[5],
    t_sexp_grammar = Base_Either0[6];
   function swap(param){
    if(0 === param[0]){var x = param[1]; return [1, x];}
    var x$0 = param[1];
    return [0, x$0];
   }
   function is_first(param){return 0 === param[0] ? 1 : 0;}
   function is_second(param){return 0 === param[0] ? 0 : 1;}
   function value(param){var x = param[1]; return x;}
   function value_map(t, first, second){
    if(0 === t[0]){var x = t[1]; return caml_call1(first, x);}
    var x$0 = t[1];
    return caml_call1(second, x$0);
   }
   function map(t, first, second){
    if(0 === t[0]){var x = t[1]; return [0, caml_call1(first, x)];}
    var x$0 = t[1];
    return [1, caml_call1(second, x$0)];
   }
   function first(x){return [0, x];}
   function second(x){return [1, x];}
   function equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function local_equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function invariant(f, s, param){
    if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
    var y = param[1];
    return caml_call1(s, y);
   }
   function Make_focused(M){
    var
     return$0 = M[1],
     other = M[2],
     focus = M[3],
     combine = M[4],
     bind = M[5],
     map =
       [0,
        -198771759,
        function(t, f){
         var
          res =
            caml_call2
             (bind,
              t,
              function(x){return caml_call1(return$0, caml_call1(f, x));});
         return res;
        }],
     include = caml_call1(Base_Monad[6], [0, bind, map, return$0]),
     symbol_bind = include[1],
     Let_syntax = include[3],
     Monad_infix = include[4],
     bind$0 = include[5],
     return$1 = include[6],
     join = include[8],
     ignore_m = include[9],
     map$0 = [0, -198771759, include[7]];
    function map2(t1, t2, f){
     return caml_call2
             (bind$0,
              t1,
              function(x){
               return caml_call2
                       (bind$0,
                        t2,
                        function(y){
                         return caml_call1(return$1, caml_call2(f, x, y));
                        });
              });
    }
    var
     App = caml_call1(Base_Applicative[17], [0, return$1, map2, map$0]),
     return$2 = App[1],
     map$1 = App[2],
     both = App[3],
     symbol = App[4],
     symbol$0 = App[5],
     symbol$1 = App[6],
     symbol_map = App[7],
     apply = App[8],
     map2$0 = App[9],
     map3 = App[10],
     all = App[11],
     all_unit = App[12],
     Applicative_infix = App[13];
    function combine_all(ts$1, f){
     var acc$1 = 0, param$0 = ts$1;
     for(;;){
      if(! param$0)
       return caml_call1(return$2, caml_call1(Base_List0[19], acc$1));
      var
       ts$0 = param$0[2],
       t$0 = param$0[1],
       match$0 = caml_call1(focus, t$0);
      if(0 !== match$0[0]) break;
      var acc$2 = [0, match$0[1], acc$1], acc$1 = acc$2, param$0 = ts$0;
     }
     var acc$3 = match$0[1], acc = acc$3, param = ts$0;
     for(;;){
      if(! param) return caml_call1(other, acc);
      var ts = param[2], t = param[1], match = caml_call1(focus, t);
      if(0 === match[0])
       var param = ts;
      else
       var acc$0 = caml_call2(f, acc, match[1]), acc = acc$0, param = ts;
     }
    }
    function combine_all_unit(ts$1, f){
     var param$0 = ts$1;
     for(;;){
      if(! param$0) return caml_call1(return$2, 0);
      var
       ts$0 = param$0[2],
       t$0 = param$0[1],
       match$0 = caml_call1(focus, t$0);
      if(0 !== match$0[0]) break;
      var param$0 = ts$0;
     }
     var acc$1 = match$0[1], acc = acc$1, param = ts$0;
     for(;;){
      if(! param) return caml_call1(other, acc);
      var ts = param[2], t = param[1], match = caml_call1(focus, t);
      if(0 === match[0])
       var param = ts;
      else
       var acc$0 = caml_call2(f, acc, match[1]), acc = acc$0, param = ts;
     }
    }
    function to_option(t){
     var match = caml_call1(focus, t);
     return 0 === match[0] ? [0, match[1]] : 0;
    }
    function value(t, default$0){
     var match = caml_call1(focus, t);
     return 0 === match[0] ? match[1] : default$0;
    }
    function with_return(f){
     function _a_(ret){
      return caml_call1
              (other,
               caml_call1(f, caml_call2(Base_With_return[3], ret, return$2)));
     }
     return caml_call1(Base_With_return[1], _a_);
    }
    return [0,
            ,
            ,
            combine,
            symbol_bind,
            Let_syntax,
            Monad_infix,
            bind$0,
            join,
            ignore_m,
            ,
            return$2,
            map$1,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2$0,
            map3,
            all,
            all_unit,
            Applicative_infix,
            combine_all,
            combine_all_unit,
            to_option,
            value,
            with_return];
   }
   function focus(t){
    if(0 === t[0]){var x = t[1]; return [0, x];}
    var y = t[1];
    return [1, y];
   }
   function combine(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(f, x, y)];}
     var x$0 = t2[1];
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){
      var y$0 = t2[1];
      return [1, caml_call2(other, x$1, y$0)];
     }
     var x$0 = x$1;
    }
    return [1, x$0];
   }
   function bind(t, f){
    if(0 !== t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var First = Make_focused([0, first, second, focus, combine, bind]);
   function focus$0(t){
    if(0 === t[0]){var y = t[1]; return [1, y];}
    var x = t[1];
    return [0, x];
   }
   function combine$0(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(other, x, y)];}
     var x$0 = x;
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return [1, caml_call2(f, x$1, y$0)];}
     var x$0 = t2[1];
    }
    return [0, x$0];
   }
   function bind$0(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var
    Second = Make_focused([0, second, first, focus$0, combine$0, bind$0]),
    Export = [0],
    Base_Either =
      [0,
       compare,
       compare_local,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       swap,
       value,
       value_map,
       value_map,
       map,
       equal,
       local_equal,
       [0,
        First[4],
        First[5],
        First[6],
        First[7],
        First[8],
        First[9],
        First[11],
        First[12],
        First[13],
        First[14],
        First[15],
        First[16],
        First[17],
        First[18],
        First[19],
        First[20],
        First[21],
        First[22],
        First[23],
        First[27],
        First[26],
        First[28],
        First[3],
        First[24],
        First[25]],
       [0,
        Second[4],
        Second[5],
        Second[6],
        Second[7],
        Second[8],
        Second[9],
        Second[11],
        Second[12],
        Second[13],
        Second[14],
        Second[15],
        Second[16],
        Second[17],
        Second[18],
        Second[19],
        Second[20],
        Second[21],
        Second[22],
        Second[23],
        Second[27],
        Second[26],
        Second[28],
        Second[3],
        Second[24],
        Second[25]],
       is_first,
       is_second,
       first,
       second,
       Export];
   runtime.caml_register_global(5, Base_Either, "Base__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option
//# unitInfo: Requires: Base__Applicative, Base__Error, Base__Import, Base__Monad, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    compare_local = Base_Import[265],
    compare = Base_Import[237],
    globalize = Base_Import[294],
    hash_fold_t = Base_Import[211],
    t_of_sexp = Base_Import[170],
    sexp_of_t = Base_Import[146],
    cst_Option_value_exn = "Option.value_exn",
    cst_Option_value_exn_None = "Option.value_exn None";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[193], a_sexp_grammar);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function value_map(o, default$0, f){
    if(! o) return default$0;
    var x = o[1];
    return caml_call1(f, x);
   }
   function iter(o, f){
    if(! o) return 0;
    var a = o[1];
    return caml_call1(f, a);
   }
   function invariant(f, t){return iter(t, f);}
   function call(x, f){
    if(! f) return 0;
    var f$0 = f[1];
    return caml_call1(f$0, x);
   }
   function value(t, default$0){
    if(! t) return default$0;
    var x = t[1];
    return x;
   }
   function value_exn(here, error, message, t){
    if(t){var x = t[1]; return x;}
    if(here){
     var p = here[1];
     if(error)
      var
       e = error[1],
       _e_ =
         caml_call2
          (Base_Import[147], Base_Error[9], Base_Source_code_position0[9]),
       _f_ = value(message, cst),
       _g_ = caml_call5(Base_Error[19], 0, 0, _f_, [0, e, p], _e_);
     else if(message)
      var
       m = message[1],
       _g_ =
         caml_call5(Base_Error[19], 0, 0, m, p, Base_Source_code_position0[9]);
     else
      var
       _g_ =
         caml_call5
          (Base_Error[19],
           0,
           0,
           cst_Option_value_exn,
           p,
           Base_Source_code_position0[9]);
     var error$0 = _g_;
    }
    else if(error){
     var e$0 = error[1];
     if(message)
      var m$0 = message[1], _h_ = caml_call2(Base_Error[22], e$0, m$0);
     else
      var _h_ = e$0;
     var error$0 = _h_;
    }
    else if(message)
     var m$1 = message[1], error$0 = caml_call1(Base_Error[14], m$1);
    else
     var error$0 = caml_call1(Base_Error[14], cst_Option_value_exn_None);
    return caml_call1(Base_Error[31], error$0);
   }
   function value_or_thunk(o, default$0){
    if(! o) return caml_call1(default$0, 0);
    var x = o[1];
    return x;
   }
   function to_array(t){if(! t) return [0]; var x = t[1]; return [0, x];}
   function to_list(t){if(! t) return 0; var x = t[1]; return [0, x, 0];}
   function for_all(t, f){
    if(! t) return 1;
    var x = t[1];
    return caml_call1(f, x);
   }
   function exists(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x);
   }
   function mem(t, a, equal){
    if(! t) return 0;
    var a$0 = t[1];
    return caml_call2(equal, a, a$0);
   }
   function length(t){return t ? 1 : 0;}
   function fold(t, init, f){
    if(! t) return init;
    var x = t[1];
    return caml_call2(f, init, x);
   }
   function find(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x) ? t : 0;
   }
   function find_map(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a);
   }
   function equal(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function equal_local(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function some(x){return [0, x];}
   function first_some(x, y){return x ? x : y;}
   function some_if(cond, x){return cond ? [0, x] : 0;}
   function merge(a, b, f){
    if(a){
     if(b){var b$0 = b[1], a$0 = a[1]; return [0, caml_call2(f, a$0, b$0)];}
     var x = a;
    }
    else
     var x = b;
    return x;
   }
   function filter(t, f){
    if(t){var v = t[1]; if(caml_call1(f, v)) return t;}
    return 0;
   }
   function try_with(f){
    try{var x = caml_call1(f, 0);}catch(_d_){return 0;}
    return [0, x];
   }
   function try_with_join(f){
    try{var x = caml_call1(f, 0); return x;}catch(_c_){return 0;}
   }
   function _a_(t, f){
    if(! t) return 0;
    var a = t[1];
    return [0, caml_call1(f, a)];
   }
   function return$0(x){return [0, x];}
   var map = [0, -198771759, _a_];
   function bind(o, f){
    if(! o) return 0;
    var x = o[1];
    return caml_call1(f, x);
   }
   var
    include = caml_call1(Base_Monad[5], [0, bind, return$0, map]),
    symbol_bind = include[1],
    Monad_infix = include[3],
    bind$0 = include[4],
    join = include[7],
    ignore_m = include[8],
    Let_syntax = include[11],
    _b_ = include[6];
   function return$1(x){return [0, x];}
   var map$0 = [0, -198771759, _b_];
   function map2(x, y, f){
    if(x && y){
     var y$0 = y[1], x$0 = x[1];
     return [0, caml_call2(f, x$0, y$0)];
    }
    return 0;
   }
   var
    include$0 = caml_call1(Base_Applicative[16], [0, return$1, map2, map$0]),
    return$2 = include$0[1],
    map$1 = include$0[2],
    both = include$0[3],
    symbol = include$0[4],
    symbol$0 = include$0[5],
    symbol$1 = include$0[6],
    symbol_map = include$0[7],
    apply = include$0[8],
    map2$0 = include$0[9],
    map3 = include$0[10],
    all = include$0[11],
    all_unit = include$0[12],
    Applicative_infix = include$0[13],
    Base_Option =
      [0,
       compare,
       compare_local,
       globalize,
       hash_fold_t,
       t_sexp_grammar,
       equal,
       equal_local,
       invariant,
       t_of_sexp,
       sexp_of_t,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2$0,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$2,
       map$1,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       value,
       value_exn,
       value_map,
       value_or_thunk,
       fold,
       mem,
       length,
       iter,
       exists,
       for_all,
       find,
       find_map,
       to_list,
       to_array,
       call,
       merge,
       filter,
       try_with,
       try_with_join,
       some,
       first_some,
       some_if,
       is_none,
       is_some];
   runtime.caml_register_global(8, Base_Option, "Base__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_enumerate_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Enumerable = [0],
    Base_Ppx_enumerate_lib = [0, Enumerable];
   runtime.caml_register_global
    (0, Base_Ppx_enumerate_lib, "Base__Ppx_enumerate_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sequence
//# unitInfo: Requires: Base__Array0, Base__Bool, Base__Container, Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Result, CamlinternalLazy, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Both$0 = "Both",
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Sequence_nth$1 = "Sequence.nth",
    cst_both = "both",
    cst_left = "left",
    cst_right = "right",
    cst_state = "state",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_057 = "sequence.ml.Merge_with_duplicates_element.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Result = global_data.Base__Result,
    Base_Container = global_data.Base__Container,
    Base_Bool = global_data.Base__Bool,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    Base_Monad = global_data.Base__Monad,
    _m_ = [0, 0],
    cst_Bug_This_branch_should_be_ = "Bug: This branch should be unreachable",
    cst_Sequence_cycle_list_exn = "Sequence.cycle_list_exn",
    cst_Sequence_drop = "Sequence.drop",
    cst_Sequence_take = "Sequence.take",
    cst_Sequence_sub = "Sequence.sub",
    cst_Sequence_reduce_exn = "Sequence.reduce_exn",
    cst_Sequence_find_exn = "Sequence.find_exn",
    cst_Sequence_chunks_exn = "Sequence.chunks_exn",
    cst_Sequence_tl_exn = "Sequence.tl_exn",
    cst_hd_exn = "hd_exn",
    cst_Both = cst_Both$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0,
    _j_ = [0, cst_Left$0],
    _k_ = [0, cst_Right$0],
    _l_ = [0, cst_Both$0],
    cst_Sequence_nth$0 = cst_Sequence_nth$1,
    cst_Sequence_nth = cst_Sequence_nth$1,
    _i_ = [0, "src/sequence.ml", 304, 14],
    _h_ = [0, 0, 0],
    _a_ = [0, "Done"],
    _b_ = [0, cst_state],
    _c_ = [0, "Skip"],
    _d_ = [0, cst_state],
    _e_ = [0, "value"],
    _f_ = [0, "Yield"];
   function sexp_of_t(of_a_001, of_s_002, param){
    if(typeof param === "number") return _a_;
    if(0 === param[0]){
     var
      state_004 = param[1],
      arg_005 = caml_call1(of_s_002, state_004),
      bnds_003 = [0, [1, [0, _b_, [0, arg_005, 0]]], 0];
     return [1, [0, _c_, bnds_003]];
    }
    var
     state_009 = param[2],
     value_007 = param[1],
     arg_010 = caml_call1(of_s_002, state_009),
     bnds_006 = [0, [1, [0, _d_, [0, arg_010, 0]]], 0],
     arg_008 = caml_call1(of_a_001, value_007),
     bnds_006$0 = [0, [1, [0, _e_, [0, arg_008, 0]]], bnds_006];
    return [1, [0, _f_, bnds_006$0]];
   }
   var Step = [0, sexp_of_t], T = [0];
   function globalize(param, _ac_){
    var next = _ac_[2], state = _ac_[1];
    return [0, state, next];
   }
   function view(t){return t;}
   function next_step(param){
    var f = param[2], s = param[1], match = caml_call1(f, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, s$0, f]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, s$1, f]];
   }
   function delayed_fold_step(s, init, f, finish){
    function loop(s, next, finish, f, acc){
     var match = caml_call1(next, s);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$0 = match[1];
      return caml_call3
              (f,
               acc,
               0,
               function(_ab_){return loop(s$0, next, finish, f, _ab_);});
     }
     var s$1 = match[2], a = match[1];
     return caml_call3
             (f,
              acc,
              [0, a],
              function(_aa_){return loop(s$1, next, finish, f, _aa_);});
    }
    var next = s[2], s$0 = s[1];
    return loop(s$0, next, finish, f, init);
   }
   function unfold_step(init, f){return [0, init, f];}
   function unfold(init, f){
    return [0,
            init,
            function(s){
             var match = caml_call1(f, s);
             if(! match) return 0;
             var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
             return [1, a, s$0];
            }];
   }
   function unfold_with(s, init, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, init, s$0],
            function(param){
             var s = param[2], seed = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$0 = match[1];
              return [0, [0, seed, s$0]];
             }
             var
              s$1 = match[2],
              a = match[1],
              match$0 = caml_call2(f, seed, a);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var seed$0 = match$0[1];
              return [0, [0, seed$0, s$1]];
             }
             var seed$1 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, seed$1, s$1]];
            }];
   }
   function unfold_with_and_finish
   (s, init, running_step, inner_finished, finishing_step){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -172306698, [0, init, s$0]],
            function(state){
             if(301075099 <= state[1]){
              var
               state$0 = state[2],
               match = caml_call1(finishing_step, state$0);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var state$1 = match[1];
               return [0, [0, 301075099, state$1]];
              }
              var state$2 = match[2], y = match[1];
              return [1, y, [0, 301075099, state$2]];
             }
             var
              match$0 = state[2],
              inner_state = match$0[2],
              state$3 = match$0[1],
              match$1 = caml_call1(next, inner_state);
             if(typeof match$1 === "number")
              return [0, [0, 301075099, caml_call1(inner_finished, state$3)]];
             if(0 === match$1[0]){
              var inner_state$0 = match$1[1];
              return [0, [0, -172306698, [0, state$3, inner_state$0]]];
             }
             var
              inner_state$1 = match$1[2],
              x = match$1[1],
              match$2 = caml_call2(running_step, state$3, x);
             if(typeof match$2 === "number") return 0;
             if(0 === match$2[0]){
              var state$4 = match$2[1];
              return [0, [0, -172306698, [0, state$4, inner_state$1]]];
             }
             var state$5 = match$2[2], y$0 = match$2[1];
             return [1, y$0, [0, -172306698, [0, state$5, inner_state$1]]];
            }];
   }
   function of_list(l){
    return [0,
            l,
            function(param){
             if(! param) return 0;
             var l = param[2], x = param[1];
             return [1, x, l];
            }];
   }
   function fold(t, init, f){
    var next = t[2], seed$2 = t[1], seed = seed$2, v = init;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return v;
     if(0 === match[0])
      var seed$0 = match[1], seed = seed$0;
     else
      var
       seed$1 = match[2],
       a = match[1],
       v$0 = caml_call2(f, v, a),
       seed = seed$1,
       v = v$0;
    }
   }
   function to_list_rev(t){
    return fold(t, 0, function(l, x){return [0, x, l];});
   }
   function to_list(param){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]) break;
     var s$1 = match[1], s$0 = s$1;
    }
    var
     s$2 = match[2],
     a = match[1],
     block = [0, a, 24029],
     dst = block,
     offset = 1,
     s$3 = s$2;
    for(;;){
     var match$0 = caml_call1(next, s$3);
     if(typeof match$0 === "number"){dst[1 + offset] = 0; return block;}
     if(0 === match$0[0])
      var s$4 = match$0[1], s$3 = s$4;
     else{
      var s$5 = match$0[2], a$0 = match$0[1], dst$0 = [0, a$0, 24029];
      dst[1 + offset] = dst$0;
      var dst = dst$0, offset = 1, s$3 = s$5;
     }
    }
   }
   function sexp_of_t$0(sexp_of_a, t){
    var _$_ = to_list(t);
    return caml_call2(Base_Import[149], sexp_of_a, _$_);
   }
   function range(opt, ___, _Z_, start_v, stop_v){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(___) var sth$0 = ___[1], start = sth$0; else var start = 104758188;
    if(_Z_) var sth$1 = _Z_[1], stop = sth$1; else var stop = -160346914;
    var
     step =
       104758188 <= stop
        ? 0
          <= stride
          ? function
           (i){
            return stop_v < i
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
          : function
           (i){
            return i < stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
        : 0
          <= stride
          ? function
           (i){
            return stop_v <= i
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
          : function
           (i){
            return i <= stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           },
     init =
       104758188 <= start
        ? start_v
        : caml_call2(Base_Import[91], start_v, stride);
    return [0, init, step];
   }
   function of_lazy(t_lazy){
    return [0,
            t_lazy,
            function(t_lazy){
             var _Y_ = caml_obj_tag(t_lazy);
             a:
             if(250 === _Y_)
              var match = t_lazy[1];
             else{
              if(246 !== _Y_ && 244 !== _Y_){var match = t_lazy; break a;}
              var match = caml_call1(CamlinternalLazy[2], t_lazy);
             }
             var next = match[2], s = match[1], match$0 = caml_call1(next, s);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$0 = match$0[1], v = [0, s$0, next];
              return [0, v];
             }
             var s$1 = match$0[2], x = match$0[1], v$0 = [0, s$1, next];
             return [1, x, v$0];
            }];
   }
   function _g_(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var s$0 = match[2], a = match[1];
             return [1, caml_call1(f, a), s$0];
            }];
   }
   function mapi(t, f){
    var next = t[2], s = t[1];
    return [0,
            [0, 0, s],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var
              s$1 = match[2],
              a = match[1],
              _X_ = [0, caml_call2(Base_Import[91], i, 1), s$1];
             return [1, caml_call2(f, i, a), _X_];
            }];
   }
   function folding_map(t, init, f){
    return unfold_with
            (t,
             init,
             function(acc, x){
              var
               match = caml_call2(f, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, acc$0];
             });
   }
   function folding_mapi(t, init, f){
    return unfold_with
            (t,
             [0, 0, init],
             function(param, x){
              var
               acc = param[2],
               i = param[1],
               match = caml_call3(f, i, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, [0, caml_call2(Base_Import[91], i, 1), acc$0]];
             });
   }
   function filter(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var a = match[1], s$0 = match[2];
             if(caml_call1(f, a)) return [1, a, s$0];
             var s$1 = match[2];
             return [0, s$1];
            }];
   }
   function filteri(t, f){
    var _V_ = Base_Import[127];
    function _W_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return _g_(filter(mapi(t, function(i, s){return [0, i, s];}), _W_), _V_);
   }
   function length(t){
    var next = t[2], seed = t[1], i = 0, s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return i;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       s = s$1;
    }
   }
   function to_array(t){
    var
     match =
       fold
        (t,
         _h_,
         function(param, x){
          var i = param[2], l = param[1];
          return [0, [0, x, l], caml_call2(Base_Import[91], i, 1)];
         }),
     len = match[2],
     l = match[1];
    if(! l) return [0];
    var
     l$0 = l[2],
     x = l[1],
     a = caml_call2(Base_Array0[4], len, x),
     i$1 = caml_call2(Base_Import[93], len, 2),
     i = i$1,
     l$1 = l$0;
    for(;;){
     if(! l$1){
      if(-1 === i) return a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
     var l$2 = l$1[2], x$0 = l$1[1];
     runtime.caml_check_bound(a, i)[1 + i] = x$0;
     var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0, l$1 = l$2;
    }
   }
   function find(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(caml_call1(f, a)) return [0, a];
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function find_map(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call1(f, a);
      if(some_b) return some_b;
      var s = s$1;
     }
    }
   }
   function find_mapi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call2(f, i, a);
      if(some_b) return some_b;
      var i$0 = caml_call2(Base_Import[91], i, 1), s = s$1, i = i$0;
     }
    }
   }
   function for_all(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(! caml_call1(f, a)) return 0;
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function for_alli(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var a = match[1];
      if(! caml_call2(f, i, a)) return 0;
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       s = s$1,
       i = i$0;
     }
    }
   }
   function exists(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{var a = match[1]; if(caml_call1(f, a)) return 1; var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function existsi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return 1;
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       s = s$1,
       i = i$0;
     }
    }
   }
   function iter(t, f){
    var next = t[2], seed$2 = t[1], seed = seed$2;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var seed$0 = match[1], seed = seed$0;
     else{
      var seed$1 = match[2], a = match[1];
      caml_call1(f, a);
      var seed = seed$1;
     }
    }
   }
   function is_empty(t){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 !== match[0]) return 0;
     var s$0 = match[1], s = s$0;
    }
   }
   function mem(t, a, equal){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var b = match[1];
      if(caml_call2(equal, a, b)) return 1;
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   var empty = [0, 0, function(param){return 0;}];
   function bind(t, f){
    return [0,
            [0, empty, t],
            function(param){
             var
              rest = param[2],
              match = param[1],
              next = match[2],
              seed = match[1],
              match$0 = caml_call1(next, seed);
             if(typeof match$0 === "number"){
              var
               next$0 = rest[2],
               seed$0 = rest[1],
               match$1 = caml_call1(next$0, seed$0);
              if(typeof match$1 === "number") return 0;
              if(0 === match$1[0]){
               var s = match$1[1];
               return [0, [0, empty, [0, s, next$0]]];
              }
              var s$0 = match$1[2], a = match$1[1];
              return [0, [0, caml_call1(f, a), [0, s$0, next$0]]];
             }
             if(0 === match$0[0]){
              var s$1 = match$0[1];
              return [0, [0, [0, s$1, next], rest]];
             }
             var s$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, [0, s$2, next], rest]];
            }];
   }
   function return$0(x){
    return [0,
            [0, x],
            function(param){
             if(! param) return 0;
             var x = param[1];
             return [1, x, 0];
            }];
   }
   var
    map = [0, -198771759, _g_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function nth(s, n){
    if(0 > n) return 0;
    var next = s[2], s$3 = s[1], i = n, s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1];
      if(0 === i) return [0, a];
      var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0, s$0 = s$2;
     }
    }
   }
   function nth_exn(s, n){
    if(0 > n) return caml_call1(Base_Import[126], cst_Sequence_nth$0);
    var match = nth(s, n);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_nth);
    var x = match[1];
    return x;
   }
   function compare_local(cmp_a, cmp_b, a_023, b_024){
    if(a_023 === b_024) return 0;
    switch(a_023[0]){
      case 0:
       var a_025 = a_023[1];
       if(0 !== b_024[0]) return -1;
       var b_026 = b_024[1];
       return caml_call2(cmp_a, a_025, b_026);
      case 1:
       var a_027 = a_023[1];
       switch(b_024[0]){
         case 0: break;
         case 1:
          var b_028 = b_024[1]; return caml_call2(cmp_b, a_027, b_028);
         default: return -1;
       }
       break;
      default:
       var a_031 = a_023[2], a_029 = a_023[1];
       switch(b_024[0]){
         case 0: break;
         case 1:
          return 1;
         default:
          var
           b_032 = b_024[2],
           b_030 = b_024[1],
           n = caml_call2(cmp_a, a_029, b_030);
          return 0 === n ? caml_call2(cmp_b, a_031, b_032) : n;
       }
    }
    return 1;
   }
   function compare(cmp_a, cmp_b, a_013, b_014){
    if(a_013 === b_014) return 0;
    switch(a_013[0]){
      case 0:
       var a_015 = a_013[1];
       if(0 !== b_014[0]) return -1;
       var b_016 = b_014[1];
       return caml_call2(cmp_a, a_015, b_016);
      case 1:
       var a_017 = a_013[1];
       switch(b_014[0]){
         case 0: break;
         case 1:
          var b_018 = b_014[1]; return caml_call2(cmp_b, a_017, b_018);
         default: return -1;
       }
       break;
      default:
       var a_021 = a_013[2], a_019 = a_013[1];
       switch(b_014[0]){
         case 0: break;
         case 1:
          return 1;
         default:
          var
           b_022 = b_014[2],
           b_020 = b_014[1],
           n = caml_call2(cmp_a, a_019, b_020);
          return 0 === n ? caml_call2(cmp_b, a_021, b_022) : n;
       }
    }
    return 1;
   }
   function equal_local(cmp_a, cmp_b, a_043, b_044){
    if(a_043 === b_044) return 1;
    switch(a_043[0]){
      case 0:
       var a_045 = a_043[1];
       if(0 !== b_044[0]) return 0;
       var b_046 = b_044[1];
       return caml_call2(cmp_a, a_045, b_046);
      case 1:
       var a_047 = a_043[1];
       switch(b_044[0]){
         case 0: break;
         case 1:
          var b_048 = b_044[1]; return caml_call2(cmp_b, a_047, b_048);
         default: return 0;
       }
       break;
      default:
       var a_051 = a_043[2], a_049 = a_043[1];
       switch(b_044[0]){
         case 0: break;
         case 1:
          return 0;
         default:
          var
           b_052 = b_044[2],
           b_050 = b_044[1],
           _U_ = caml_call2(cmp_a, a_049, b_050);
          return _U_ ? caml_call2(cmp_b, a_051, b_052) : _U_;
       }
    }
    return 0;
   }
   function equal(cmp_a, cmp_b, a_033, b_034){
    if(a_033 === b_034) return 1;
    switch(a_033[0]){
      case 0:
       var a_035 = a_033[1];
       if(0 !== b_034[0]) return 0;
       var b_036 = b_034[1];
       return caml_call2(cmp_a, a_035, b_036);
      case 1:
       var a_037 = a_033[1];
       switch(b_034[0]){
         case 0: break;
         case 1:
          var b_038 = b_034[1]; return caml_call2(cmp_b, a_037, b_038);
         default: return 0;
       }
       break;
      default:
       var a_041 = a_033[2], a_039 = a_033[1];
       switch(b_034[0]){
         case 0: break;
         case 1:
          return 0;
         default:
          var
           b_042 = b_034[2],
           b_040 = b_034[1],
           _T_ = caml_call2(cmp_a, a_039, b_040);
          return _T_ ? caml_call2(cmp_b, a_041, b_042) : _T_;
       }
    }
    return 0;
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    switch(arg[0]){
      case 0:
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(hash_fold_a, hsv$0, a0);
      case 1:
       var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
       return caml_call2(hash_fold_b, hsv$1, a0$0);
      default:
       var
        a1 = arg[2],
        a0$1 = arg[1],
        hsv$2 = caml_call2(Base_Hash[3], hsv, 2),
        hsv$3 = caml_call2(hash_fold_a, hsv$2, a0$1);
       return caml_call2(hash_fold_b, hsv$3, a1);
    }
   }
   function t_of_sexp(of_a_053, of_b_054, sexp_059){
    a:
    {
     if(0 === sexp_059[0]){
      var _P_ = sexp_059[1];
      b:
      if(caml_string_notequal(_P_, cst_Both$0)){
       c:
       if(caml_string_notequal(_P_, cst_Left$0)){
        if(caml_string_notequal(_P_, cst_Right$0)){
         if(! caml_string_notequal(_P_, cst_both)) break b;
         if(! caml_string_notequal(_P_, cst_left)) break c;
         if(caml_string_notequal(_P_, cst_right)) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_057, sexp_059);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_057, sexp_059);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_057, sexp_059);
     }
     var _Q_ = sexp_059[1];
     if(! _Q_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_057, sexp_059);
     var _R_ = _Q_[1];
     if(0 !== _R_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_057, sexp_059);
     var tag_060 = _R_[1];
     b:
     if(caml_string_notequal(tag_060, cst_Both$0)){
      c:
      if(caml_string_notequal(tag_060, cst_Left$0)){
       if(caml_string_notequal(tag_060, cst_Right$0)){
        if(! caml_string_notequal(tag_060, cst_both)) break b;
        if(! caml_string_notequal(tag_060, cst_left)) break c;
        if(caml_string_notequal(tag_060, cst_right)) break a;
       }
       var sexp_args_066 = _Q_[2];
       if(sexp_args_066 && ! sexp_args_066[2]){
        var
         arg0_067 = sexp_args_066[1],
         res0_068 = caml_call1(of_b_054, arg0_067);
        return [1, res0_068];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_057,
                tag_060,
                sexp_059);
      }
      var sexp_args_061 = _Q_[2];
      if(sexp_args_061 && ! sexp_args_061[2]){
       var
        arg0_062 = sexp_args_061[1],
        res0_063 = caml_call1(of_a_053, arg0_062);
       return [0, res0_063];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_057,
               tag_060,
               sexp_059);
     }
     var sexp_args_071 = _Q_[2];
     if(sexp_args_071){
      var _S_ = sexp_args_071[2];
      if(_S_ && ! _S_[2]){
       var
        arg1_073 = _S_[1],
        arg0_072 = sexp_args_071[1],
        res0_074 = caml_call1(of_a_053, arg0_072),
        res1_075 = caml_call1(of_b_054, arg1_073);
       return [2, res0_074, res1_075];
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_057,
              tag_060,
              sexp_059);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_057, sexp_059);
   }
   function sexp_of_t$1(of_a_078, of_b_079, param){
    switch(param[0]){
      case 0:
       var arg0_080 = param[1], res0_081 = caml_call1(of_a_078, arg0_080);
       return [1, [0, _j_, [0, res0_081, 0]]];
      case 1:
       var arg0_082 = param[1], res0_083 = caml_call1(of_b_079, arg0_082);
       return [1, [0, _k_, [0, res0_083, 0]]];
      default:
       var
        arg1_085 = param[2],
        arg0_084 = param[1],
        res0_086 = caml_call1(of_a_078, arg0_084),
        res1_087 = caml_call1(of_b_079, arg1_085);
       return [1, [0, _l_, [0, res0_086, [0, res1_087, 0]]]];
    }
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Left, [0, [0, a_sexp_grammar, 0]]]],
              [0,
               [1, [0, cst_Right, [0, [0, b_sexp_grammar, 0]]]],
               [0,
                [1,
                 [0,
                  cst_Both,
                  [0, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]]],
                0]]]]];
   }
   function merge_with_duplicates(param, _O_, compare){
    var next2 = _O_[2], s2 = _O_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [1, b], [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, [0, a], [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 <= comparison
               ? 0
                 === comparison
                 ? [1, [2, a, b$0], [0, [0, s1$1], [0, s2$3]]]
                 : [1, [1, b$0], [0, s1, [0, s2$3]]]
               : [1, [0, a], [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function merge_deduped_and_sorted(s1, s2, compare){
    function _N_(param){var x = param[1]; return x;}
    return caml_call2(map$0, merge_with_duplicates(s1, s2, compare), _N_);
   }
   function merge_sorted(param, _M_, compare){
    var next2 = _M_[2], s2 = _M_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, b, [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, a, [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 < comparison
               ? [1, b$0, [0, s1, [0, s2$3]]]
               : [1, a, [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function hd(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){var a = match[1]; return [0, a];}
     var s$1 = match[1], s$0 = s$1;
    }
   }
   function hd_exn(s){
    var match = hd(s);
    if(! match) return caml_call1(Base_Import[124], cst_hd_exn);
    var a = match[1];
    return a;
   }
   function tl(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      var match$0 = 0;
     else{
      if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
      var a = match[2], match$0 = [0, a];
     }
     if(! match$0) return 0;
     var s$3 = match$0[1];
     return [0, [0, s$3, next]];
    }
   }
   function tl_eagerly_exn(s){
    var match = tl(s);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_tl_exn);
    var s$0 = match[1];
    return s$0;
   }
   function lift_identity(next, s){
    var match = caml_call1(next, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, 316735838, s$0]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, 316735838, s$1]];
   }
   function next(s){
    var next = s[2], s$3 = s[1], s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){
      var s$2 = match[2], a = match[1];
      return [0, [0, a, [0, s$2, next]]];
     }
     var s$1 = match[1], s$0 = s$1;
    }
   }
   function filter_opt(s){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var match$0 = match[1];
             if(match$0){
              var s$1 = match[2], a = match$0[1];
              return [1, a, s$1];
             }
             var s$2 = match[2];
             return [0, s$2];
            }];
   }
   function filter_map(s, f){return filter_opt(caml_call2(map$0, s, f));}
   function filter_mapi(s, f){
    function _L_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return filter_map(mapi(s, function(i, s){return [0, i, s];}), _L_);
   }
   function split_n(s, n){
    var next = s[2], s$3 = s[1], s$0 = s$3, i = n, accum = 0;
    for(;;){
     if(0 >= i) return [0, caml_call1(Base_List1[19], accum), [0, s$0, next]];
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      return [0, caml_call1(Base_List1[19], accum), empty];
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else
      var
       s$2 = match[2],
       a = match[1],
       accum$0 = [0, a, accum],
       i$0 = caml_call2(Base_Import[93], i, 1),
       s$0 = s$2,
       i = i$0,
       accum = accum$0;
    }
   }
   function chunks_exn(t, n){
    return 0 < n
            ? [0,
              t,
              function(t){
               var match = split_n(t, n), xs = match[1];
               if(! xs) return 0;
               var t$0 = match[2];
               return [1, xs, t$0];
              }]
            : caml_call1(Base_Import[126], cst_Sequence_chunks_exn);
   }
   function findi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return [0, [0, i, a]];
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       s = s$1,
       i = i$0;
     }
    }
   }
   function find_exn(s, f){
    var match = find(s, f);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_find_exn);
    var x = match[1];
    return x;
   }
   function append(s1, s2){
    var next2 = s2[2], s2$0 = s2[1], next1 = s1[2], s1$0 = s1[1];
    return [0,
            [0, 472258093, s1$0],
            function(param){
             if(472258093 <= param[1]){
              var s1 = param[2], match = caml_call1(next1, s1);
              if(typeof match === "number") return [0, [0, -630817751, s2$0]];
              if(0 === match[0]){
               var s1$0 = match[1];
               return [0, [0, 472258093, s1$0]];
              }
              var s1$1 = match[2], a = match[1];
              return [1, a, [0, 472258093, s1$1]];
             }
             var s2 = param[2], match$0 = caml_call1(next2, s2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s2$1 = match$0[1];
              return [0, [0, -630817751, s2$1]];
             }
             var s2$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, -630817751, s2$2]];
            }];
   }
   function concat_map(s, f){return caml_call2(bind$0, s, f);}
   function concat(s){return concat_map(s, function(_K_){return _K_;});}
   function concat_mapi(s, f){
    function _J_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return concat_map(mapi(s, function(i, s){return [0, i, s];}), _J_);
   }
   function zip(param, _H_){
    var next2 = _H_[2], s2 = _H_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var _I_ = param[1];
     if(typeof _I_ !== "number"){
      if(1 === _I_[0]){
       var match = param[2], s1$0 = _I_[2], a = _I_[1];
       if(typeof match !== "number"){
        if(0 === match[0]){
         var s2$0 = param[2][1];
         return [0, [0, _I_, caml_call1(next2, s2$0)]];
        }
        var s2$1 = match[2], b = match[1];
        return [1, [0, a, b], [0, [0, s1$0], [0, s2$1]]];
       }
      }
      if(typeof param[2] !== "number"){
       var s2 = param[2], s1 = _I_[1];
       return [0, [0, caml_call1(next1, s1), s2]];
      }
     }
     return 0;
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function zip_full(param, _G_){
    var next2 = _G_[2], s2 = _G_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [0, -57574468, b], [0, 0, caml_call1(next2, s2$0)]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var match$0 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof match$0 === "number")
       return [1, [0, 847852583, a], [0, caml_call1(next1, s1$1), 0]];
      if(0 !== match$0[0]){
       var s2$2 = match$0[2], b$0 = match$0[1];
       return [1, [0, 737457313, [0, a, b$0]], [0, [0, s1$1], [0, s2$2]]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function bounded_length(param, at_most){
    var next = param[2], seed = param[1], i = 0, seed$0 = seed;
    for(;;){
     if(at_most < i) return 85047514;
     var match = caml_call1(next, seed$0);
     if(typeof match === "number") return [0, 16394, i];
     if(0 === match[0])
      var seed$1 = match[1], seed$0 = seed$1;
     else
      var
       seed$2 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       seed$0 = seed$2;
    }
   }
   function length_is_bounded_by(opt, max, t){
    if(opt) var sth = opt[1], min = sth; else var min = -1;
    if(max){
     var max$0 = max[1], match$0 = bounded_length(t, max$0);
     if(typeof match$0 !== "number" && 16394 === match$0[1]){var len = match$0[2]; if(min <= len) return 1;}
     return 0;
    }
    var next = t[2], s = t[1], s$0 = s, acc = 0;
    for(;;){
     if(min <= acc) return 1;
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else
      var
       s$2 = match[2],
       acc$0 = caml_call2(Base_Import[91], acc, 1),
       s$0 = s$2,
       acc = acc$0;
    }
   }
   function iteri(s, f){
    function _F_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return iter(mapi(s, function(i, s){return [0, i, s];}), _F_);
   }
   function foldi(s, init, f){
    function _E_(acc, param){
     var s = param[2], i = param[1];
     return caml_call3(f, i, acc, s);
    }
    return fold(mapi(s, function(i, s){return [0, i, s];}), init, _E_);
   }
   function reduce(s, f){
    var match = next(s);
    if(! match) return 0;
    var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
    return [0, fold(s$0, a, f)];
   }
   function reduce_exn(s, f){
    var match = reduce(s, f);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_reduce_exn);
    var res = match[1];
    return res;
   }
   function group(param, break$0){
    var next = param[2], s = param[1];
    return [0,
            [0, [0, 0, s]],
            function(param){
             if(! param) return 0;
             var
              match = param[1],
              s = match[2],
              acc = match[1],
              match$0 = caml_call1(next, s);
             if(typeof match$0 !== "number" && 0 === match$0[0]){
              var s$2 = match$0[1];
              return [0, [0, [0, acc, s$2]]];
             }
             if(acc){
              if(typeof match$0 === "number")
               return [1, caml_call1(Base_List1[19], acc), 0];
              var s$0 = match$0[2], cur = match$0[1], prev = acc[1];
              return caml_call2(break$0, prev, cur)
                      ? [1,
                        caml_call1(Base_List1[19], acc),
                        [0, [0, [0, cur, 0], s$0]]]
                      : [0, [0, [0, [0, cur, acc], s$0]]];
             }
             if(typeof match$0 === "number") return 0;
             var s$1 = match$0[2], cur$0 = match$0[1];
             return [0, [0, [0, [0, cur$0, 0], s$1]]];
            }];
   }
   function find_consecutive_duplicate(param, equal){
    var next = param[2], s = param[1], last_elt = 0, s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1];
      if(last_elt){
       var b = last_elt[1];
       if(caml_call2(equal, a, b)) return [0, [0, b, a]];
      }
      var last_elt$0 = [0, a], last_elt = last_elt$0, s$0 = s$2;
     }
    }
   }
   function remove_consecutive_duplicates(s, equal){
    return unfold_with
            (s,
             0,
             function(prev, a){
              if(prev){
               var b = prev[1];
               if(caml_call2(equal, a, b)) return [0, [0, a]];
              }
              return [1, a, [0, a]];
             });
   }
   function count(s, f){
    return fold
            (s,
             0,
             function(acc, elt){
              var
               _C_ = caml_call1(f, elt),
               _D_ = caml_call1(Base_Bool[31], _C_);
              return caml_call2(Base_Import[91], acc, _D_);
             });
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(i, acc, elt){
              var
               _A_ = caml_call2(f, i, elt),
               _B_ = caml_call1(Base_Bool[31], _A_);
              return caml_call2(Base_Import[91], acc, _B_);
             });
   }
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function init(n, f){
    return [0,
            0,
            function(i){
             if(n <= i) return 0;
             var _z_ = caml_call2(Base_Import[91], i, 1);
             return [1, caml_call1(f, i), _z_];
            }];
   }
   function sub(s, pos, len){
    var _x_ = pos < 0 ? 1 : 0, _y_ = _x_ || (len < 0 ? 1 : 0);
    if(_y_) caml_call1(Base_Import[124], cst_Sequence_sub);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= caml_call2(Base_Import[93], i, pos)) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(pos <= i)
              return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[91], i, 1), s$2]];
            }];
   }
   function take(s, len){
    if(len < 0) caml_call1(Base_Import[124], cst_Sequence_take);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= i) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var s$1 = match[2], a = match[1];
             return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
            }];
   }
   function drop(s, len){
    if(len < 0) caml_call1(Base_Import[124], cst_Sequence_drop);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(len <= i)
              return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[91], i, 1), s$2]];
            }];
   }
   function take_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var a = match[1], s$1 = match[2];
             return caml_call1(f, a) ? [1, a, s$1] : 0;
            }];
   }
   function drop_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -557110719, s$0],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var s$0 = param[2], match = caml_call1(next, s$0);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$1 = match[1];
              return [0, [0, -557110719, s$1]];
             }
             var a = match[1], s$2 = match[2];
             if(caml_call1(f, a)) return [0, [0, -557110719, s$2]];
             var s$3 = match[2];
             return [1, a, [0, 316735838, s$3]];
            }];
   }
   function shift_right(s, x){
    var next = s[2], seed = s[1];
    return [0,
            [0, -433944719, [0, seed, x]],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var match = param[2], x = match[2], seed = match[1];
             return [1, x, [0, 316735838, seed]];
            }];
   }
   function shift_right_with_list(s, l){return append(of_list(l), s);}
   var Infix = [0, append];
   function intersperse(s, sep){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 815032112, s$0],
            function(param){
             var _w_ = param[1];
             if(815032112 === _w_){
              var s = param[2], match = caml_call1(next, s);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var s$0 = match[1];
               return [0, [0, 815032112, s$0]];
              }
              var s$1 = match[2], a = match[1];
              return [1, a, [0, 951752159, s$1]];
             }
             if(951752159 > _w_){
              var match$1 = param[2], s$5 = match$1[2], a$1 = match$1[1];
              return [1, a$1, [0, 951752159, s$5]];
             }
             var s$2 = param[2], match$0 = caml_call1(next, s$2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$3 = match$0[1];
              return [0, [0, 951752159, s$3]];
             }
             var s$4 = match$0[2], a$0 = match$0[1];
             return [1, sep, [0, -571577571, [0, a$0, s$4]]];
            }];
   }
   function repeat(x){return [0, x, function(x){return [1, x, x];}];}
   function cycle_list_exn(xs){
    if(caml_call1(Base_List1[22], xs))
     caml_call1(Base_Import[126], cst_Sequence_cycle_list_exn);
    var s = of_list(xs);
    function _v_(param){return s;}
    return concat_map(repeat(0), _v_);
   }
   function cartesian_product(sa, sb){
    return concat_map(sa, function(a){return zip(repeat(a), sb);});
   }
   function singleton(x){return caml_call1(return$1, x);}
   function delayed_fold(s, init, f, finish){
    return delayed_fold_step
            (s,
             init,
             function(acc, option, k){
              if(! option) return caml_call1(k, acc);
              var a = option[1];
              return caml_call3(f, acc, a, k);
             },
             finish);
   }
   function fold_m(bind, return$0, t, init, f){
    return delayed_fold_step
            (t,
             init,
             function(acc, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$0, acc), k);
              var a = option[1];
              return caml_call2(bind, caml_call2(f, acc, a), k);
             },
             return$0);
   }
   function iter_m(bind, return$0, t, f){
    return delayed_fold_step
            (t,
             0,
             function(param, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$0, 0), k);
              var a = option[1];
              return caml_call2(bind, caml_call1(f, a), k);
             },
             return$0);
   }
   function fold_until(s, init, f, finish){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1], match$0 = caml_call2(f, acc, a);
      if(0 !== match$0[0]){var x = match$0[1]; return x;}
      var acc$0 = match$0[1], s$0 = s$2, acc = acc$0;
     }
    }
   }
   function fold_result(s, init, f){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(Base_Result[15], acc);
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1], e = caml_call2(f, acc, a);
      if(0 !== e[0]) return e;
      var acc$0 = e[1], s$0 = s$2, acc = acc$0;
     }
    }
   }
   function force_eagerly(t){return of_list(to_list(t));}
   function memoize(param){
    var next = param[2], s = param[1];
    function memoize(s){
     return [0,
             [246,
              function(_u_){
               var s$0 = s;
               for(;;){
                var match = caml_call1(next, s$0);
                if(typeof match === "number") return 0;
                if(0 !== match[0]){
                 var s$2 = match[2], a = match[1];
                 return [1, a, memoize(s$2)];
                }
                var s$1 = match[1], s$0 = s$1;
               }
              }]];
    }
    function _s_(param){
     var l = param[1], _t_ = caml_obj_tag(l);
     if(250 === _t_) return l[1];
     if(246 !== _t_ && 244 !== _t_) return l;
     return caml_call1(CamlinternalLazy[2], l);
    }
    return [0, memoize(s), _s_];
   }
   function drop_eagerly(s, len){
    var next = s[2], s$3 = s[1], i = 0, s$0 = s$3;
    for(;;){
     if(len <= i) return [0, s$0, next];
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return empty;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else
      var
       s$2 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       s$0 = s$2;
    }
   }
   function drop_while_option(param, f){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], x = match[1];
      if(! caml_call1(f, x)) return [0, [0, x, [0, s$2, next]]];
      var s$0 = s$2;
     }
    }
   }
   function skip_loop(s, next){
    var s$0 = s;
    for(;;){
     var next$0 = caml_call1(next, s$0);
     if(typeof next$0 !== "number" && 0 === next$0[0]){var state = next$0[1], s$0 = state; continue;}
     return next$0;
    }
   }
   function compare$0(compare_a, param, r){
    var
     next_r = r[2],
     s_r$1 = r[1],
     next_l = param[2],
     s_l$1 = param[1],
     s_l = s_l$1,
     s_r = s_r$1;
    for(;;){
     var l = skip_loop(s_l, next_l), r$0 = skip_loop(s_r, next_r);
     if(typeof l === "number"){
      if(typeof r$0 === "number") return 0;
      if(1 === r$0[0]) return -1;
     }
     else if(1 === l[0]){
      if(typeof r$0 === "number") return 1;
      if(1 === r$0[0]){
       var c = caml_call2(compare_a, l[1], r$0[1]);
       if(0 !== c) return c;
       var s_r$0 = r$0[2], s_l$0 = l[2], s_l = s_l$0, s_r = s_r$0;
       continue;
      }
     }
     return caml_call1(Base_Import[124], cst_Bug_This_branch_should_be_);
    }
   }
   function compare_local$0(compare_a_local, t1, t2){
    var _q_ = globalize(0, t2), _r_ = globalize(0, t1);
    return compare$0
            (function(x, y){return caml_call2(compare_a_local, x, y);},
             _r_,
             _q_);
   }
   function equal$0(equal_a, t1, t2){
    function _p_(param){
     if(737457313 !== param[1]) return 0;
     var match = param[2], a2 = match[2], a1 = match[1];
     return caml_call2(equal_a, a1, a2);
    }
    return for_all(zip_full(t1, t2), _p_);
   }
   function equal_local$0(equal_a_local, t1, t2){
    var _n_ = globalize(0, t2), _o_ = globalize(0, t1);
    return equal$0
            (function(x, y){return caml_call2(equal_a_local, x, y);},
             _o_,
             _n_);
   }
   function round_robin(list){
    function next(param){
     var done_stack = param[2], todo_stack = param[1];
     if(! todo_stack)
      return caml_call1(Base_List1[22], done_stack)
              ? 0
              : [0, [0, caml_call1(Base_List1[19], done_stack), 0]];
     var
      todo_stack$0 = todo_stack[2],
      match = todo_stack[1],
      f = match[2],
      s = match[1],
      match$0 = caml_call1(f, s);
     if(typeof match$0 === "number")
      return [0, [0, todo_stack$0, done_stack]];
     if(0 === match$0[0]){
      var s$0 = match$0[1];
      return [0, [0, [0, [0, s$0, f], todo_stack$0], done_stack]];
     }
     var s$1 = match$0[2], x = match$0[1];
     return [1, x, [0, todo_stack$0, [0, [0, s$1, f], done_stack]]];
    }
    var state = [0, list, 0];
    return [0, state, next];
   }
   function interleave(param){
    var f1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[3], done_stack = param[2], todo_stack = param[1];
     if(todo_stack){
      var
       todo_stack$0 = todo_stack[2],
       match = todo_stack[1],
       f2 = match[2],
       s2 = match[1],
       match$0 = caml_call1(f2, s2);
      if(typeof match$0 === "number")
       return [0, [0, todo_stack$0, done_stack, s1]];
      if(0 === match$0[0]){
       var s2$0 = match$0[1];
       return [0, [0, todo_stack$0, [0, [0, s2$0, f2], done_stack], s1]];
      }
      var s2$1 = match$0[2], x = match$0[1];
      return [1, x, [0, todo_stack$0, [0, [0, s2$1, f2], done_stack], s1]];
     }
     var match$1 = caml_call1(f1, s1);
     if(typeof match$1 === "number")
      return done_stack
              ? [0, [0, caml_call1(Base_List1[19], done_stack), 0, s1]]
              : 0;
     if(0 === match$1[0]){
      var s1$0 = match$1[1];
      return [0, [0, caml_call1(Base_List1[19], done_stack), 0, s1$0]];
     }
     var s1$1 = match$1[2], t = match$1[1];
     return [0, [0, caml_call1(Base_List1[19], [0, t, done_stack]), 0, s1$1]];
    }
    var state = [0, 0, 0, s1];
    return [0, state, next];
   }
   function interleaved_cartesian_product(s1, s2){
    return interleave
            (caml_call2
              (map$0,
               s1,
               function(x1){
                return caml_call2
                        (map$0, s2, function(x2){return [0, x1, x2];});
               }));
   }
   function of_seq(seq){
    return [0,
            seq,
            function(seq){
             var match = caml_call1(seq, 0);
             if(! match) return 0;
             var tl = match[2], hd = match[1];
             return [1, hd, tl];
            }];
   }
   function to_seq(param){
    var next = param[2], state = param[1];
    function loop(state){
     var state$0 = state;
     for(;;){
      var match = caml_call1(next, state$0);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var state$2 = match[2], hd = match[1];
       return [0, hd, function(param){return loop(state$2);}];
      }
      var state$1 = match[1], state$0 = state$1;
     }
    }
    return function(param){return loop(state);};
   }
   function return$2(x, k){return caml_call1(k, x);}
   function bind$1(m, f, k){
    return caml_call1
            (m,
             function(a){var m = caml_call1(f, a); return caml_call1(m, k);});
   }
   var
    map$1 =
      [0,
       -198771759,
       function(m, f, k){
        return caml_call1
                (m, function(a){return caml_call1(k, caml_call1(f, a));});
       }],
    include$0 = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]),
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Let_syntax$0 = include$0[3],
    Monad_infix$0 = include$0[4],
    bind$2 = include$0[5],
    return$3 = include$0[6],
    map$2 = include$0[7],
    join$0 = include$0[8],
    ignore_m$0 = include$0[9],
    all$0 = include$0[10],
    all_unit$0 = include$0[11];
   function yield$0(e, k){return [0, [1, e, k]];}
   function of_sequence(sequence){
    return delayed_fold
            (sequence,
             0,
             function(param, x, k, f){
              return [0, [1, x, function(param){return caml_call2(k, 0, f);}]];
             },
             return$3);
   }
   function run(t){
    function init(param){return caml_call1(t, function(param){return _m_;});}
    function f(thunk){return caml_call1(thunk, 0)[1];}
    return [0, init, f];
   }
   var
    Base_Sequence =
      [0,
       globalize,
       sexp_of_t$0,
       equal$0,
       equal_local$0,
       compare$0,
       compare_local$0,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       counti,
       findi,
       find_mapi,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       empty,
       next,
       Step,
       unfold_step,
       unfold,
       unfold_with,
       unfold_with_and_finish,
       nth,
       nth_exn,
       folding_map,
       folding_mapi,
       mapi,
       filteri,
       filter,
       merge_deduped_and_sorted,
       merge_sorted,
       [0,
        compare,
        compare_local,
        equal,
        equal_local,
        hash_fold_t,
        t_of_sexp,
        sexp_of_t$1,
        t_sexp_grammar],
       merge_with_duplicates,
       hd,
       hd_exn,
       tl,
       tl_eagerly_exn,
       find_exn,
       for_alli,
       append,
       concat,
       concat_map,
       concat_mapi,
       interleave,
       round_robin,
       zip,
       zip_full,
       reduce_exn,
       reduce,
       group,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       range,
       init,
       filter_map,
       filter_mapi,
       filter_opt,
       sub,
       take,
       drop,
       drop_eagerly,
       take_while,
       drop_while,
       drop_while_option,
       split_n,
       chunks_exn,
       shift_right,
       shift_right_with_list,
       drop,
       Infix,
       cartesian_product,
       interleaved_cartesian_product,
       intersperse,
       cycle_list_exn,
       repeat,
       singleton,
       delayed_fold,
       fold_m,
       iter_m,
       to_list_rev,
       of_list,
       of_lazy,
       memoize,
       force_eagerly,
       bounded_length,
       length_is_bounded_by,
       of_seq,
       to_seq,
       [0,
        symbol_bind$0,
        symbol_map$0,
        Let_syntax$0,
        Monad_infix$0,
        bind$2,
        return$3,
        map$2,
        join$0,
        ignore_m$0,
        all$0,
        all_unit$0,
        yield$0,
        of_sequence,
        run],
       [0, next_step, delayed_fold_step, T, view]];
   runtime.caml_register_global(51, Base_Sequence, "Base__Sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexpable
//# unitInfo: Requires: Base__Import, Sexplib0__Sexp_grammar, Sexplib0__Sexpable
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    cst_Sexpable_Of_stringable_t_o =
      "Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list";
   function Of_sexpable(Sexpable, M){
    function t_of_sexp(sexp){
     var s = caml_call1(Sexpable[1], sexp);
     try{var _i_ = caml_call1(M[2], s); return _i_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[157], exn, sexp);
     }
    }
    function sexp_of_t(t){
     var _h_ = caml_call1(M[1], t);
     return caml_call1(Sexpable[2], _h_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable1(Sexpable, M){
    function t_of_sexp(a_of_sexp, sexp){
     var s = caml_call2(Sexpable[1], a_of_sexp, sexp);
     try{var _g_ = caml_call1(M[2], s); return _g_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[157], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, t){
     var _f_ = caml_call1(M[1], t);
     return caml_call2(Sexpable[2], sexp_of_a, _f_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable2(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, sexp){
     var s = caml_call3(Sexpable[1], a_of_sexp, b_of_sexp, sexp);
     try{var _e_ = caml_call1(M[2], s); return _e_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[157], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, t){
     var _d_ = caml_call1(M[1], t);
     return caml_call3(Sexpable[2], sexp_of_a, sexp_of_b, _d_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable3(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
     var s = caml_call4(Sexpable[1], a_of_sexp, b_of_sexp, c_of_sexp, sexp);
     try{var _c_ = caml_call1(M[2], s); return _c_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[157], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, sexp_of_c, t){
     var _b_ = caml_call1(M[1], t);
     return caml_call4(Sexpable[2], sexp_of_a, sexp_of_b, sexp_of_c, _b_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_stringable(M){
    function t_of_sexp(sexp){
     if(0 !== sexp[0])
      return caml_call2
              (Base_Import[156], cst_Sexpable_Of_stringable_t_o, sexp);
     var s = sexp[1];
     try{var _a_ = caml_call1(M[1], s); return _a_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[157], exn, sexp);
     }
    }
    function sexp_of_t(t){return [0, caml_call1(M[2], t)];}
    var
     t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_Import[182]);
    return [0, t_sexp_grammar, t_of_sexp, sexp_of_t];
   }
   var
    Base_Sexpable =
      [0,
       Of_sexpable,
       Of_sexpable1,
       Of_sexpable2,
       Of_sexpable3,
       Of_stringable];
   runtime.caml_register_global(3, Base_Sexpable, "Base__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array
//# unitInfo: Requires: Base__Array0, Base__Array_permute, Base__Binary_searchable, Base__Blit, Base__Bool, Base__Container, Base__Import, Base__List, Base__Option, Base__Ordered_collection_common, Base__Random, Base__Sequence
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_array_ml = "src/array.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Sequence = global_data.Base__Sequence,
    Base_Random = global_data.Base__Random,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Bool = global_data.Base__Bool,
    Base_Container = global_data.Base__Container,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    Base_Blit = global_data.Base__Blit,
    invalid_argf = Base_Array0[1],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_local = Base_Array0[5],
    create_float_uninitialized = Base_Array0[6],
    append = Base_Array0[7],
    concat = Base_Array0[9],
    copy = Base_Array0[10],
    fill = Base_Array0[11],
    init = Base_Array0[12],
    make_matrix = Base_Array0[13],
    of_list = Base_Array0[14],
    sub = Base_Array0[15],
    to_list = Base_Array0[16],
    fold = Base_Array0[17],
    fold_right = Base_Array0[18],
    iter = Base_Array0[19],
    iteri = Base_Array0[20],
    map = Base_Array0[21],
    mapi = Base_Array0[22],
    stable_sort = Base_Array0[23],
    swap = Base_Array0[24],
    compare_local = Base_Import[263],
    compare = Base_Import[235],
    globalize = Base_Import[291],
    t_of_sexp = Base_Import[174],
    sexp_of_t = Base_Import[150],
    _g_ = [0, cst_src_array_ml, 917, 6],
    cst_Array_transpose_exn = "Array.transpose_exn",
    cst_Array_zip_exn = "Array.zip_exn",
    cst_Array_random_element_exn_e = "Array.random_element_exn: empty array",
    cst_Array_reduce_exn = "Array.reduce_exn",
    _d_ = [0, "Array.find_exn: not found"],
    _c_ = [0, "Array.findi_exn: not found"],
    cst_Array_for_all2_exn = "Array.for_all2_exn",
    cst_Array_exists2_exn = "Array.exists2_exn",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Array_iter2_exn = "Array.iter2_exn",
    _b_ =
      [0,
       [11,
        "length mismatch in ",
        [2, 0, [11, ": ", [4, 0, 0, 0, [11, " <> ", [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _a_ = [0, cst_src_array_ml, 486, 14],
    _e_ = [0, "Array.find_map_exn: not found"],
    _f_ = [0, "Array.find_mapi_exn: not found"];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[195], a_sexp_grammar);
   }
   function Sorter(S){
    var get = S[1], set = S[2], length = S[3];
    function swap(arr, i, j){
     var tmp = caml_call2(get, arr, i);
     caml_call3(set, arr, i, caml_call2(get, arr, j));
     return caml_call3(set, arr, j, tmp);
    }
    function sort(arr, compare, left, right){
     var _a0_ = caml_call2(Base_Import[91], left, 1);
     if(right >= _a0_){
      var pos = _a0_;
      for(;;){
       var v = caml_call2(get, arr, pos), final_pos = pos;
       for(;;){
        var i_next = caml_call2(Base_Import[93], final_pos, 1);
        if(left > i_next) break;
        if(0 >= caml_call2(compare, caml_call2(get, arr, i_next), v)) break;
        caml_call3(set, arr, final_pos, caml_call2(get, arr, i_next));
        var final_pos = i_next;
       }
       caml_call3(set, arr, final_pos, v);
       var _a1_ = pos + 1 | 0;
       if(right === pos) break;
       var pos = _a1_;
      }
     }
     return 0;
    }
    var Insertion_sort = [0, sort];
    function heapify(arr, compare, root, left, right){
     var root$0 = root;
     for(;;){
      var
       relative_root = caml_call2(Base_Import[93], root$0, left),
       _aT_ = caml_call2(Base_Import[88], 2, relative_root),
       _aU_ = caml_call2(Base_Import[91], _aT_, left),
       left_child = caml_call2(Base_Import[91], _aU_, 1),
       _aV_ = caml_call2(Base_Import[88], 2, relative_root),
       _aW_ = caml_call2(Base_Import[91], _aV_, left),
       right_child = caml_call2(Base_Import[91], _aW_, 2);
      a:
      {
       if(left_child <= right){
        var _aX_ = caml_call2(get, arr, root$0);
        if(0 < caml_call2(compare, caml_call2(get, arr, left_child), _aX_)){var largest = left_child; break a;}
       }
       var largest = root$0;
      }
      a:
      {
       if(right_child <= right){
        var _aY_ = caml_call2(get, arr, largest);
        if(0 < caml_call2(compare, caml_call2(get, arr, right_child), _aY_)){var largest$0 = right_child; break a;}
       }
       var largest$0 = largest;
      }
      var _aZ_ = largest$0 !== root$0 ? 1 : 0;
      if(! _aZ_) return _aZ_;
      swap(arr, root$0, largest$0);
      var root$0 = largest$0;
     }
    }
    function sort$0(arr, compare, left, right){
     var
      _aO_ = caml_call2(Base_Import[91], left, right),
      _aP_ = caml_call2(Base_Import[95], _aO_, 2);
     if(_aP_ >= left){
      var i = _aP_;
      for(;;){
       heapify(arr, compare, i, left, right);
       var _aQ_ = i - 1 | 0;
       if(left === i) break;
       var i = _aQ_;
      }
     }
     var _aR_ = caml_call2(Base_Import[91], left, 1);
     if(right >= _aR_){
      var i$0 = right;
      for(;;){
       swap(arr, left, i$0);
       heapify(arr, compare, left, left, caml_call2(Base_Import[93], i$0, 1));
       var _aS_ = i$0 - 1 | 0;
       if(_aR_ === i$0) break;
       var i$0 = _aS_;
      }
     }
     return 0;
    }
    var Heap_sort = [0, sort$0];
    function five_element_sort(arr, compare, m1, m2, m3, m4, m5){
     function compare_and_swap(i, j){
      var
       _aM_ = caml_call2(get, arr, j),
       _aN_ = 0 < caml_call2(compare, caml_call2(get, arr, i), _aM_) ? 1 : 0;
      return _aN_ ? swap(arr, i, j) : _aN_;
     }
     compare_and_swap(m1, m2);
     compare_and_swap(m4, m5);
     compare_and_swap(m1, m3);
     compare_and_swap(m2, m3);
     compare_and_swap(m1, m4);
     compare_and_swap(m3, m4);
     compare_and_swap(m2, m5);
     compare_and_swap(m2, m3);
     return compare_and_swap(m4, m5);
    }
    function intro_sort(arr, max_depth, compare, left, right){
     var max_depth$0 = max_depth, left$0 = left;
     for(;;){
      var
       _aL_ = caml_call2(Base_Import[93], right, left$0),
       len = caml_call2(Base_Import[91], _aL_, 1);
      if(32 >= len)
       return caml_call4(Insertion_sort[1], arr, compare, left$0, right);
      if(0 > max_depth$0)
       return caml_call4(Heap_sort[1], arr, compare, left$0, right);
      var
       max_depth$1 = caml_call2(Base_Import[93], max_depth$0, 1),
       _aK_ = caml_call2(Base_Import[93], right, left$0),
       sixth = caml_call2(Base_Import[95], _aK_, 6),
       m1 = caml_call2(Base_Import[91], left$0, sixth),
       m2 = caml_call2(Base_Import[91], m1, sixth),
       m3 = caml_call2(Base_Import[91], m2, sixth),
       m4 = caml_call2(Base_Import[91], m3, sixth),
       m5 = caml_call2(Base_Import[91], m4, sixth);
      five_element_sort(arr, compare, m1, m2, m3, m4, m5);
      var
       m2_val = caml_call2(get, arr, m2),
       m3_val = caml_call2(get, arr, m3),
       m4_val = caml_call2(get, arr, m4),
       match =
         0 === caml_call2(compare, m2_val, m3_val)
          ? [0, m2_val, m3_val, 1]
          : 0
            === caml_call2(compare, m3_val, m4_val)
            ? [0, m3_val, m4_val, 1]
            : [0, m2_val, m4_val, 0],
       middle_sorted = match[3],
       pivot2 = match[2],
       pivot1 = match[1],
       l$0 = left$0,
       p$1 = left$0,
       r$2 = right;
      for(;;){
       if(r$2 < p$1) break;
       var pv = caml_call2(get, arr, p$1);
       if(0 <= caml_call2(compare, pv, pivot1))
        if(0 < caml_call2(compare, pv, pivot2)){
         var r = r$2;
         for(;;){
          if(p$1 >= r) break;
          if(0 >= caml_call2(compare, caml_call2(get, arr, r), pivot2)) break;
          var r$0 = caml_call2(Base_Import[93], r, 1), r = r$0;
         }
         swap(arr, r, p$1);
         var r$1 = caml_call2(Base_Import[93], r, 1), r$2 = r$1;
        }
        else
         var p = caml_call2(Base_Import[91], p$1, 1), p$1 = p;
       else{
        swap(arr, p$1, l$0);
        var
         p$0 = caml_call2(Base_Import[91], p$1, 1),
         l = caml_call2(Base_Import[91], l$0, 1),
         l$0 = l,
         p$1 = p$0;
       }
      }
      intro_sort
       (arr,
        max_depth$1,
        compare,
        left$0,
        caml_call2(Base_Import[93], l$0, 1));
      if(1 - middle_sorted) intro_sort(arr, max_depth$1, compare, l$0, r$2);
      var
       left$1 = caml_call2(Base_Import[91], r$2, 1),
       max_depth$0 = max_depth$1,
       left$0 = left$1;
     }
    }
    function sort$1(arr, compare, left, right){
     return intro_sort(arr, 32, compare, left, right);
    }
    var Intro_sort = [0, sort$1, five_element_sort];
    function sort$2(pos, len, arr, compare){
     var
      _aH_ = caml_call1(length, arr),
      match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _aH_),
      len$0 = match[2],
      pos$0 = match[1],
      _aI_ = caml_call2(Base_Import[91], pos$0, len$0),
      _aJ_ = caml_call2(Base_Import[93], _aI_, 1);
     return caml_call4(Intro_sort[1], arr, compare, pos$0, _aJ_);
    }
    return [0, , , , , Insertion_sort, Heap_sort, Intro_sort, sort$2];
   }
   function get(_aG_, _aF_){return _aG_[1 + _aF_];}
   function set(_aE_, _aD_, _aC_){_aE_[1 + _aD_] = _aC_; return 0;}
   function length(_aB_){return _aB_.length - 1;}
   var Sort = Sorter([0, get, set, length]), sort = Sort[8];
   function of_array(t){return t;}
   function to_array(t){return t;}
   function is_empty(t){return 0 === t.length - 1 ? 1 : 0;}
   function is_sorted(t, compare){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[93], i[1], 1)];
      if(0 < caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function is_sorted_strictly(t, compare){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[93], i[1], 1)];
      if(0 <= caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function merge(a1, a2, compare){
    var l1 = a1.length - 1, l2 = a2.length - 1;
    if(0 === l1) return caml_call1(copy, a2);
    if(0 === l2) return caml_call1(copy, a1);
    var _aw_ = a1[1 + caml_call2(Base_Import[93], l1, 1)];
    if(0 <= caml_call2(compare, a2[1], _aw_))
     return caml_call2(append, a1, a2);
    var _ax_ = a2[1 + caml_call2(Base_Import[93], l2, 1)];
    if(0 < caml_call2(compare, a1[1], _ax_))
     return caml_call2(append, a2, a1);
    var
     len = caml_call2(Base_Import[91], l1, l2),
     merged = caml_call2(create, len, a1[1]),
     a1_index = [0, 0],
     a2_index = [0, 0],
     _az_ = caml_call2(Base_Import[93], len, 1),
     _ay_ = 0;
    if(_az_ >= 0){
     var i = _ay_;
     for(;;){
      var
       use_a1 =
         l1 === a1_index[1]
          ? 0
          : l2
            === a2_index[1]
            ? 1
            : caml_call2
               (compare, a1[1 + a1_index[1]], a2[1 + a2_index[1]])
              <= 0
              ? 1
              : 0;
      if(use_a1){
       merged[1 + i] = a1[1 + a1_index[1]];
       a1_index[1] = caml_call2(Base_Import[91], a1_index[1], 1);
      }
      else{
       merged[1 + i] = a2[1 + a2_index[1]];
       a2_index[1] = caml_call2(Base_Import[91], a2_index[1], 1);
      }
      var _aA_ = i + 1 | 0;
      if(_az_ === i) break;
      var i = _aA_;
     }
    }
    return merged;
   }
   function copy_matrix(_av_){return caml_call2(map, _av_, copy);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return caml_call2
            (map,
             t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (map,
         t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function extremal_element(t, compare, keep_left_if){
    if(is_empty(t)) return 0;
    var
     result = [0, t[1]],
     _as_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _ar_ = 1;
    if(_as_ >= 1){
     var i = _ar_;
     for(;;){
      var x = t[1 + i], _at_ = result[1];
      result[1] =
       runtime.caml_csel_value
        (caml_call1(keep_left_if, caml_call2(compare, x, result[1])), x, _at_);
      var _au_ = i + 1 | 0;
      if(_as_ === i) break;
      var i = _au_;
     }
    }
    return [0, result[1]];
   }
   function min_elt(t, compare){
    return extremal_element
            (t,
             compare,
             function(compare_result){return compare_result < 0 ? 1 : 0;});
   }
   function max_elt(t, compare){
    return extremal_element
            (t,
             compare,
             function(compare_result){return 0 < compare_result ? 1 : 0;});
   }
   function foldi(t, init, f){
    var
     acc = [0, init],
     _ap_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _ao_ = 0;
    if(_ap_ >= 0){
     var i = _ao_;
     for(;;){
      acc[1] = caml_call3(f, i, acc[1], t[1 + i]);
      var _aq_ = i + 1 | 0;
      if(_ap_ === i) break;
      var i = _aq_;
     }
    }
    return acc[1];
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return caml_call2
            (mapi,
             t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (mapi,
         t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function count(t, f){
    var
     result = [0, 0],
     _ak_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _aj_ = 0;
    if(_ak_ >= 0){
     var i = _aj_;
     for(;;){
      var
       _al_ = caml_call1(f, t[1 + i]),
       _am_ = caml_call1(Base_Bool[31], _al_);
      result[1] = caml_call2(Base_Import[91], result[1], _am_);
      var _an_ = i + 1 | 0;
      if(_ak_ === i) break;
      var i = _an_;
     }
    }
    return result[1];
   }
   function counti(t, f){
    var
     result = [0, 0],
     _af_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _ae_ = 0;
    if(_af_ >= 0){
     var i = _ae_;
     for(;;){
      var
       _ag_ = caml_call2(f, i, t[1 + i]),
       _ah_ = caml_call1(Base_Bool[31], _ag_);
      result[1] = caml_call2(Base_Import[91], result[1], _ah_);
      var _ai_ = i + 1 | 0;
      if(_af_ === i) break;
      var i = _ai_;
     }
    }
    return result[1];
   }
   function concat_map(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(map, t, f)));
   }
   function concat_mapi(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(mapi, t, f)));
   }
   function rev_inplace(t){
    var i = [0, 0], j = [0, caml_call2(Base_Import[93], t.length - 1, 1)];
    for(;;){
     if(i[1] >= j[1]) return 0;
     caml_call3(swap, t, i[1], j[1]);
     i[1]++;
     j[1] += -1;
    }
   }
   function rev(t){
    var t$0 = caml_call1(copy, t);
    rev_inplace(t$0);
    return t$0;
   }
   function of_list_rev(l){
    if(! l) return [0];
    var
     l$0 = l[2],
     a = l[1],
     _ab_ = caml_call1(Base_List[45], l$0),
     len = caml_call2(Base_Import[91], 1, _ab_),
     t = caml_call2(create, len, a),
     r = [0, l$0],
     _ac_ = caml_call2(Base_Import[93], len, 2);
    if(_ac_ >= 0){
     var i = _ac_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      var l$1 = match[2], a$0 = match[1];
      caml_check_bound(t, i)[1 + i] = a$0;
      r[1] = l$1;
      var _ad_ = i - 1 | 0;
      if(0 === i) break;
      var i = _ad_;
     }
    }
    return t;
   }
   function of_list_map(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _$_ = caml_call1(f, hd),
     _aa_ = caml_call1(Base_List[45], tl),
     a = caml_call2(create, caml_call2(Base_Import[91], 1, _aa_), _$_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call1(f, hd$0);
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, param = tl$0;
    }
   }
   function of_list_mapi(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _Z_ = caml_call2(f, 0, hd),
     ___ = caml_call1(Base_List[45], tl),
     a = caml_call2(create, caml_call2(Base_Import[91], 1, ___), _Z_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call2(f, i, hd$0);
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, param = tl$0;
    }
   }
   function of_list_rev_map(xs, f){
    var t = of_list_map(xs, f);
    rev_inplace(t);
    return t;
   }
   function of_list_rev_mapi(xs, f){
    var t = of_list_mapi(xs, f);
    rev_inplace(t);
    return t;
   }
   function filter_mapi(t, f){
    var
     r = [0, [0]],
     k = [0, 0],
     _X_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      var match = caml_call2(f, i, t[1 + i]);
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = caml_call2(create, t.length - 1, a);
       r[1][1 + k[1]] = a;
       k[1]++;
      }
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      var i = _Y_;
     }
    }
    return k[1] === t.length - 1
            ? r[1]
            : 0 < k[1] ? caml_call3(sub, r[1], 0, k[1]) : [0];
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter_opt(t){return filter_map(t, function(_V_){return _V_;});}
   function check_length2_exn(name, t1, t2){
    var n1 = t1.length - 1, n2 = t2.length - 1, _U_ = n1 !== n2 ? 1 : 0;
    return _U_ ? caml_call5(invalid_argf, _b_, name, n1, n2, 0) : _U_;
   }
   function iter2_exn(t1, t2, f){
    check_length2_exn(cst_Array_iter2_exn, t1, t2);
    return caml_call2
            (iteri, t1, function(i, x1){return caml_call2(f, x1, t2[1 + i]);});
   }
   function map2_exn(t1, t2, f){
    check_length2_exn(cst_Array_map2_exn, t1, t2);
    return caml_call2
            (init,
             t1.length - 1,
             function(i){return caml_call2(f, t1[1 + i], t2[1 + i]);});
   }
   function fold2_exn(t1, t2, init, f){
    check_length2_exn(cst_Array_fold2_exn, t1, t2);
    return foldi
            (t1,
             init,
             function(i, ac, x){return caml_call3(f, ac, x, t2[1 + i]);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function exists(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call1(f, t[1 + i[1]])){result[1] = 1; continue;}
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function existsi(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){result[1] = 1; continue;}
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function mem(t, a, equal){return exists(t, caml_call1(equal, a));}
   function for_all(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call1(f, t[1 + i[1]])){i[1] += -1; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(t, f){
    var
     length = t.length - 1,
     i = [0, caml_call2(Base_Import[93], length, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){i[1] += -1; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function exists2_exn(t1, t2, f){
    check_length2_exn(cst_Array_exists2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[93], t1.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){result[1] = 1; continue;}
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function for_all2_local_exn(t1, t2, f){
    check_length2_exn(cst_Array_for_all2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[93], t1.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){i[1] += -1; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_all2_exn(t1, t2, f){return for_all2_local_exn(t1, t2, f);}
   function equal_local(equal, t1, t2){
    var _T_ = t1.length - 1 === t2.length - 1 ? 1 : 0;
    return _T_ ? for_all2_local_exn(t1, t2, equal) : _T_;
   }
   function equal(equal, t1, t2){return equal_local(equal, t1, t2);}
   function map_inplace(t, f){
    var _R_ = caml_call2(Base_Import[93], t.length - 1, 1), _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      t[1 + i] = caml_call1(f, t[1 + i]);
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      var i = _S_;
     }
    }
    return 0;
   }
   function findi_internal(t, f, if_found, if_not_found){
    var length = t.length - 1;
    if(0 === length) return caml_call1(if_not_found, 0);
    var i = [0, 0], found = [0, 0], value_found = [0, t[1]];
    for(;;){
     if(! found[1] && i[1] < length){
      var value = t[1 + i[1]];
      if(caml_call2(f, i[1], value)){
       value_found[1] = value;
       found[1] = 1;
      }
      else
       i[1]++;
      continue;
     }
     return found[1]
             ? caml_call2(if_found, i[1], value_found[1])
             : caml_call1(if_not_found, 0);
    }
   }
   function findi(t, f){
    function _P_(param){return 0;}
    return findi_internal
            (t, f, function(i, value){return [0, [0, i, value]];}, _P_);
   }
   function findi_exn(t, f){
    function _O_(param){
     throw caml_maybe_attach_backtrace([0, Base_Import[297], _c_], 1);
    }
    return findi_internal
            (t, f, function(i, value){return [0, i, value];}, _O_);
   }
   function find_exn(t, f){
    function _M_(param){
     throw caml_maybe_attach_backtrace([0, Base_Import[297], _d_], 1);
    }
    function _N_(param, value){return value;}
    return findi_internal
            (t, function(i, x){return caml_call1(f, x);}, _N_, _M_);
   }
   function find(t, f){
    function _K_(param){var x = param[2]; return x;}
    var _L_ = findi(t, function(i, x){return caml_call1(f, x);});
    return caml_call2(Base_Option[24], _L_, _K_);
   }
   function find_map(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[52], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call1(f, value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   var not_found = [0, Base_Import[297], _e_];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[52], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call2(f, i[1], value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   var not_found$0 = [0, Base_Import[297], _f_];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$0, 1);
    var x = match[1];
    return x;
   }
   function find_consecutive_duplicate(t, equal){
    var n = t.length - 1;
    if(1 >= n) return 0;
    var result = [0, 0], i = [0, 1], prev = [0, t[1]];
    for(;;){
     if(i[1] >= n) return result[1];
     var cur = t[1 + i[1]];
     if(caml_call2(equal, cur, prev[1])){
      result[1] = [0, [0, prev[1], cur]];
      i[1] = n;
     }
     else{prev[1] = cur; i[1]++;}
    }
   }
   function reduce(t, f){
    if(0 === t.length - 1) return 0;
    var
     r = [0, t[1]],
     _I_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _H_ = 1;
    if(_I_ >= 1){
     var i = _H_;
     for(;;){
      r[1] = caml_call2(f, r[1], t[1 + i]);
      var _J_ = i + 1 | 0;
      if(_I_ === i) break;
      var i = _J_;
     }
    }
    return [0, r[1]];
   }
   function reduce_exn(t, f){
    var match = reduce(t, f);
    if(! match) return caml_call1(Base_Import[126], cst_Array_reduce_exn);
    var v = match[1];
    return v;
   }
   var permute = Base_Array_permute[25];
   function random_element_exn(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    if(is_empty(t))
     return caml_call1(Base_Import[124], cst_Array_random_element_exn_e);
    var _G_ = caml_call2(Base_Random[19][7], random_state, t.length - 1);
    return caml_check_bound(t, _G_)[1 + _G_];
   }
   function random_element(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    try{var _E_ = [0, random_element_exn([0, random_state], t)]; return _E_;}
    catch(_F_){return 0;}
   }
   function zip(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? 0
            : [0, map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];})];
   }
   function zip_exn(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? caml_call1(Base_Import[124], cst_Array_zip_exn)
            : map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];});
   }
   function unzip(t){
    var n = t.length - 1;
    if(0 === n) return [0, [0], [0]];
    var
     match = caml_check_bound(t, 0)[1],
     y = match[2],
     x = match[1],
     res1 = caml_call2(create, n, x),
     res2 = caml_call2(create, n, y),
     _C_ = caml_call2(Base_Import[93], n, 1),
     _B_ = 1;
    if(_C_ >= 1){
     var i = _B_;
     for(;;){
      var
       match$0 = caml_check_bound(t, i)[1 + i],
       y$0 = match$0[2],
       x$0 = match$0[1];
      caml_check_bound(res1, i)[1 + i] = x$0;
      caml_check_bound(res2, i)[1 + i] = y$0;
      var _D_ = i + 1 | 0;
      if(_C_ === i) break;
      var i = _D_;
     }
    }
    return [0, res1, res2];
   }
   function sorted_copy(t, compare){
    var t1 = caml_call1(copy, t);
    sort(0, 0, t1, compare);
    return t1;
   }
   function partition_mapi(t, f){
    var
     both = caml_call2(mapi, t, f),
     firsts =
       filter_map
        (both,
         function(param){
          if(0 !== param[0]) return 0;
          var x = param[1];
          return [0, x];
         }),
     seconds =
       filter_map
        (both,
         function(param){
          if(0 === param[0]) return 0;
          var x = param[1];
          return [0, x];
         });
    return [0, firsts, seconds];
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : [1, x];});
   }
   function partition_map(t, f){
    return partition_mapi(t, function(param, x){return caml_call1(f, x);});
   }
   function partition_tf(t, f){
    return partitioni_tf(t, function(param, x){return caml_call1(f, x);});
   }
   function last(t){
    var _A_ = caml_call2(Base_Import[93], t.length - 1, 1);
    return caml_check_bound(t, _A_)[1 + _A_];
   }
   function to_sequence_mutable(t){
    function _y_(i){
     if(t.length - 1 <= i) return 0;
     var _z_ = caml_call2(Base_Import[91], i, 1);
     return [1, caml_check_bound(t, i)[1 + i], _z_];
    }
    return caml_call2(Base_Sequence[44], 0, _y_);
   }
   function to_sequence(t){return to_sequence_mutable(caml_call1(copy, t));}
   function cartesian_product(t1, t2){
    if(! is_empty(t1) && ! is_empty(t2)){
     var
      n1 = t1.length - 1,
      n2 = t2.length - 1,
      _n_ = caml_check_bound(t2, 0)[1],
      _o_ = [0, caml_check_bound(t1, 0)[1], _n_],
      t = caml_call2(create, caml_call2(Base_Import[88], n1, n2), _o_),
      r = [0, 0],
      _q_ = caml_call2(Base_Import[93], n1, 1),
      _p_ = 0;
     if(_q_ >= 0){
      var i1 = _p_;
      for(;;){
       var _s_ = caml_call2(Base_Import[93], n2, 1), _r_ = 0;
       if(_s_ >= 0){
        var i2 = _r_;
        for(;;){
         var
          _u_ = caml_check_bound(t2, i2)[1 + i2],
          _v_ = [0, caml_check_bound(t1, i1)[1 + i1], _u_],
          _w_ = r[1];
         caml_check_bound(t, _w_)[1 + _w_] = _v_;
         r[1]++;
         var _x_ = i2 + 1 | 0;
         if(_s_ === i2) break;
         var i2 = _x_;
        }
       }
       var _t_ = i1 + 1 | 0;
       if(_q_ === i1) break;
       var i1 = _t_;
      }
     }
     return t;
    }
    return [0];
   }
   function transpose(tt){
    if(0 === tt.length - 1) return [0, [0]];
    var width = tt.length - 1, depth = caml_check_bound(tt, 0)[1].length - 1;
    return exists(tt, function(t){return t.length - 1 !== depth ? 1 : 0;})
            ? 0
            : [0,
              caml_call2
               (init,
                depth,
                function(d){
                 return caml_call2
                         (init,
                          width,
                          function(w){
                           return caml_check_bound(caml_check_bound(tt, w)[1 + w], d)
                                   [1 + d];
                          });
                })];
   }
   function transpose_exn(tt){
    var match = transpose(tt);
    if(! match) return caml_call1(Base_Import[126], cst_Array_transpose_exn);
    var tt$0 = match[1];
    return tt$0;
   }
   function get$0(_m_, _l_){return caml_check_bound(_m_, _l_)[1 + _l_];}
   function length$0(_k_){return _k_.length - 1;}
   var
    include = caml_call1(Base_Binary_searchable[2], [0, get$0, length$0]),
    binary_search = include[1],
    binary_search_segmented = include[2];
   function length$1(_j_){return _j_.length - 1;}
   function create_like(len, t){
    if(0 === len) return [0];
    if(0 < t.length - 1)
     return caml_call2(create, len, caml_check_bound(t, 0)[1]);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   var
    unsafe_blit = runtime.caml_array_blit,
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length$1, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub$0 = include$0[4],
    subo = include$0[5];
   function invariant(invariant_a, t){
    return caml_call2(iter, t, invariant_a);
   }
   function _h_(_i_){return [0, Sorter(_i_)[8]];}
   var
    Base_Array =
      [0,
       compare,
       compare_local,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       binary_search,
       binary_search_segmented,
       of_list,
       of_array,
       append,
       map,
       filter,
       filter_map,
       concat_map,
       partition_tf,
       partition_map,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       concat_mapi,
       invariant,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       make_matrix,
       copy_matrix,
       concat,
       copy,
       fill,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       fold_right,
       sort,
       stable_sort,
       is_sorted,
       is_sorted_strictly,
       merge,
       partitioni_tf,
       cartesian_product,
       transpose,
       transpose_exn,
       filter_opt,
       iter2_exn,
       map2_exn,
       fold2_exn,
       for_all2_exn,
       exists2_exn,
       swap,
       rev_inplace,
       rev,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn,
       find_map_exn,
       findi_exn,
       find_mapi_exn,
       find_consecutive_duplicate,
       reduce,
       reduce_exn,
       permute,
       random_element,
       random_element_exn,
       zip,
       zip_exn,
       unzip,
       sorted_copy,
       last,
       equal,
       equal_local,
       to_sequence,
       to_sequence_mutable,
       [0, [0, Sort[5], Sort[6], Sort[7]], _h_]];
   runtime.caml_register_global(29, Base_Array, "Base__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Floatable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Floatable = [0];
   runtime.caml_register_global(0, Base_Floatable, "Base__Floatable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float0
//# unitInfo: Requires: Base__Import, Base__Import0, Base__Option, Base__Printf, Ocaml_intrinsics_kernel__Float, Stdlib__Float, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_float0_ml = "src/float0.ml",
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Float = global_data.Stdlib__Float,
    _g_ = [0, cst_src_float0_ml, 186, 4],
    _f_ = [0, cst_src_float0_ml, 190, 4],
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ = [0, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    _a_ =
      [0,
       [8,
        [0, 0, 0],
        0,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [8,
            [0, 0, 0],
            0,
            0,
            [11, " in float0.ml: modulus should be positive", 0]]]]]],
       "%f %% %f in float0.ml: modulus should be positive"];
   function ceil(_p_){return Math.ceil(_p_);}
   function floor(_o_){return Math.floor(_o_);}
   function mod_float(_n_, _m_){return _n_ % _m_;}
   var
    modf = runtime.caml_modf_float,
    float_of_string = runtime.caml_float_of_string,
    float_of_string_opt = Base_Import[85][36],
    nan = Base_Import[85][24],
    infinity = Base_Import[85][22],
    neg_infinity = Base_Import[85][23],
    max_finite_value = Base_Import[85][25],
    epsilon_float = Base_Import[85][27],
    classify_float = runtime.caml_classify_float;
   function abs_float(_l_){return Math.abs(_l_);}
   var is_integer = Stdlib_Float[18];
   function symbol(_k_, _j_){return Math.pow(_k_, _j_);}
   function symbol$0(a, b){
    if(b < 0.) caml_call4(Base_Printf[7], _a_, a, b, 0);
    var m = a % b;
    return m < 0. ? caml_call2(Base_Import[92], m, b) : m;
   }
   var frexp = runtime.caml_frexp_float, ldexp = runtime.caml_ldexp_float;
   function is_nan(x){return x != x ? 1 : 0;}
   function to_int64_preserve_order(t){
    return t != t
            ? 0
            : t
              == 0.
              ? _b_
              : 0.
                < t
                ? [0, caml_int64_bits_of_float(t)]
                : [0,
                  caml_int64_neg
                   (caml_int64_bits_of_float(caml_call1(Base_Import[114], t)))];
   }
   function to_int64_preserve_order_exn(x){
    var _i_ = to_int64_preserve_order(x);
    return caml_call4(Base_Option[31], 0, 0, 0, _i_);
   }
   function of_int64_preserve_order(x){
    return runtime.caml_greaterequal(x, _c_)
            ? caml_int64_float_of_bits(x)
            : caml_call1
              (Base_Import[114], caml_int64_float_of_bits(caml_int64_neg(x)));
   }
   function one_ulp(dir, t){
    var match = to_int64_preserve_order(t);
    if(! match) return Base_Import[85][24];
    var x = match[1], _h_ = 759637122 <= dir ? _d_ : _e_;
    return of_int64_preserve_order(runtime.caml_int64_add(x, _h_));
   }
   function upper_bound_for_int(num_bits){
    var exp = caml_call2(Base_Import[93], num_bits, 1);
    return one_ulp(759637122, Math.pow(2., exp));
   }
   function is_x_minus_one_exact(x){
    return 1
           -
            runtime.caml_equal
             (caml_int64_bits_of_float(x),
              caml_int64_bits_of_float(caml_call2(Base_Import[94], x, 1.)));
   }
   function lower_bound_for_int(num_bits){
    var
     exp = caml_call2(Base_Import[93], num_bits, 1),
     min_int_as_float = caml_call1(Base_Import[114], Math.pow(2., exp));
    if(53 <= caml_call2(Base_Import[93], num_bits, 1)){
     if(is_x_minus_one_exact(min_int_as_float))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     return min_int_as_float;
    }
    if(is_x_minus_one_exact(min_int_as_float))
     return one_ulp(19067, caml_call2(Base_Import[94], min_int_as_float, 1.));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   function min(a, b){return runtime.caml_sse2_float64_min_bytecode(a, b);}
   function max(a, b){return runtime.caml_sse2_float64_max_bytecode(a, b);}
   var Intrinsics_with_weird_nan_beha = [0, min, max];
   function clamp_unchecked
   (to_clamp_maybe_nan, min_which_is_not_nan, max_which_is_not_nan){
    var
     t_maybe_nan =
       caml_call2
        (Intrinsics_with_weird_nan_beha[2],
         min_which_is_not_nan,
         to_clamp_maybe_nan);
    return caml_call2
            (Intrinsics_with_weird_nan_beha[1],
             max_which_is_not_nan,
             t_maybe_nan);
   }
   var x = 0.;
   function box(f){return caml_call2(Base_Import[92], f, x);}
   var
    include = Base_Import[108],
    ascending = include[1],
    descending = include[2],
    compare_local = include[3],
    equal_local = include[4],
    max$0 = include[5],
    min$0 = include[6],
    Base_Float0 =
      [0,
       ceil,
       floor,
       mod_float,
       modf,
       float_of_string,
       float_of_string_opt,
       nan,
       infinity,
       neg_infinity,
       max_finite_value,
       epsilon_float,
       classify_float,
       abs_float,
       is_integer,
       symbol,
       symbol$0,
       frexp,
       ldexp,
       is_nan,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       upper_bound_for_int,
       is_x_minus_one_exact,
       lower_bound_for_int,
       Intrinsics_with_weird_nan_beha,
       clamp_unchecked,
       box,
       ascending,
       descending,
       compare_local,
       equal_local,
       max$0,
       min$0];
   runtime.caml_register_global(21, Base_Float0, "Base__Float0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Intable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Intable = [0];
   runtime.caml_register_global(0, Base_Intable, "Base__Intable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Int_intf = [0];
   runtime.caml_register_global(0, Base_Int_intf, "Base__Int_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pow_overflow_bounds
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Int_conversions
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    overflow_bound_max_int63_on_in =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    overflow_bound_max_int64_value =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Base_Import = global_data.Base__Import,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    int32_positive_overflow_bounds =
      [0,
        2147483647,
        2147483647,
        46340,
        1290,
        215,
        73,
        35,
        21,
        14,
        10,
        8,
        7,
        5,
        5,
        4,
        4,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1].slice
       (),
    overflow_bound_max_int_value = caml_call2(Base_Import[120], -1, 1),
    switcher = Base_Int_conversions[30] - 31 | 0,
    _g_ = [0, "src/pow_overflow_bounds.ml", 216, 9],
    _a_ = runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _c_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _i_ =
      [0,
       1073741823,
       1073741823,
       32767,
       1023,
       181,
       63,
       31,
       19,
       13,
       10,
       7,
       6,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
    _d_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
       runtime.caml_int64_create_lo_mi_hi(1664510, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(46340, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5404, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1290, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(463, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(215, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(118, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(73, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(49, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(35, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(27, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(21, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(17, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(14, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(12, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(10, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _e_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(324403, 181, 0),
       runtime.caml_int64_create_lo_mi_hi(2097151, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(55108, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6208, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1448, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(511, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(234, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(127, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(78, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(52, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(38, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(28, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(22, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(18, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(15, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(13, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(11, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _f_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(16452813, 16777034, 65535),
       runtime.caml_int64_create_lo_mi_hi(14680065, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16722108, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16771008, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16775768, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776705, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776982, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777089, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777138, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777164, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777178, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777188, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777194, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777198, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777201, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777203, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777205, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777207, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777208, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535)],
    overflow_bound_max_int32_value = 2147483647;
   if(1 < switcher >>> 0){
    if(32 !== switcher)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    var
     int_positive_overflow_bounds =
       [0,
        caml_int64_to_int32(_c_),
        caml_int64_to_int32(_b_),
        caml_int64_to_int32(_a_),
        1664510,
        46340,
        5404,
        1290,
        463,
        215,
        118,
        73,
        49,
        35,
        27,
        21,
        17,
        14,
        12,
        10,
        9,
        8,
        7,
        7,
        6,
        5,
        5,
        5,
        4,
        4,
        4,
        4,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1];
   }
   else if(switcher)
    var
     _h_ = function(_j_){return _j_;},
     int_positive_overflow_bounds =
       caml_call2(Base_Array0[21], int32_positive_overflow_bounds, _h_);
   else
    var int_positive_overflow_bounds = _i_.slice();
   var
    int63_on_int64_positive_overfl = _d_.slice(),
    int64_positive_overflow_bounds = _e_.slice(),
    int64_negative_overflow_bounds = _f_.slice(),
    Base_Pow_overflow_bounds =
      [0,
       overflow_bound_max_int32_value,
       int32_positive_overflow_bounds,
       overflow_bound_max_int_value,
       int_positive_overflow_bounds,
       overflow_bound_max_int63_on_in,
       int63_on_int64_positive_overfl,
       overflow_bound_max_int64_value,
       int64_positive_overflow_bounds,
       int64_negative_overflow_bounds];
   runtime.caml_register_global
    (16, Base_Pow_overflow_bounds, "Base__Pow_overflow_bounds");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_math
//# unitInfo: Requires: Base__Import, Base__Pow_overflow_bounds, Base__Printf, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_exponent_can_not_be_negati = "exponent can not be negative",
    cst_integer_overflow_in_pow = "integer overflow in pow",
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessthan = runtime.caml_lessthan;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Pow_overflow_bounds = global_data.Base__Pow_overflow_bounds,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    invalid_argf = Base_Printf[7],
    _m_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    _l_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _j_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _k_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _h_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ =
      [0, [11, cst_integer_overflow_in_pow, 0], cst_integer_overflow_in_pow],
    _a_ =
      [0,
       [11, cst_exponent_can_not_be_negati, 0],
       cst_exponent_can_not_be_negati];
   function negative_exponent(param){
    return caml_call2(Base_Printf[7], _a_, 0);
   }
   function overflow(param){return caml_call2(Base_Printf[7], _b_, 0);}
   function int_pow(base, exponent){
    if(exponent < 0) negative_exponent(0);
    var _J_ = 1 < caml_call1(Base_Import[123], base) ? 1 : 0;
    if(_J_){
     var _K_ = 63 < exponent ? 1 : 0;
     if(_K_)
      var _L_ = _K_;
     else
      var
       _M_ =
         caml_check_bound(Base_Pow_overflow_bounds[4], exponent)[1 + exponent],
       _L_ = _M_ < caml_call1(Base_Import[123], base) ? 1 : 0;
    }
    else
     var _L_ = _J_;
    if(_L_) overflow(0);
    return runtime.Base_int_math_int_pow_stub(base, exponent);
   }
   var abs = Stdlib_Int64[8];
   function int64_pow(base, exponent){
    if(caml_lessthan(exponent, _c_)) negative_exponent(0);
    var
     _A_ = caml_greaterthan(base, _d_),
     _B_ = _A_ || caml_lessthan(base, _h_);
    if(_B_){
     var _C_ = caml_greaterthan(exponent, _e_);
     if(_C_)
      var _D_ = _C_;
     else{
      var _E_ = runtime.caml_greaterequal(base, _f_);
      if(_E_)
       var
        _F_ = caml_int64_to_int32(exponent),
        _G_ =
          caml_greaterthan
           (base, caml_check_bound(Base_Pow_overflow_bounds[8], _F_)[1 + _F_]);
      else
       var _G_ = _E_;
      if(_G_)
       var _D_ = _G_;
      else{
       var _H_ = caml_lessthan(base, _g_);
       if(_H_)
        var
         _I_ = caml_int64_to_int32(exponent),
         _D_ =
           caml_lessthan
            (base,
             caml_check_bound(Base_Pow_overflow_bounds[9], _I_)[1 + _I_]);
       else
        var _D_ = _H_;
      }
     }
    }
    else
     var _D_ = _B_;
    if(_D_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   function int63_pow_on_int64(base, exponent){
    if(caml_lessthan(exponent, _i_)) negative_exponent(0);
    var _v_ = caml_greaterthan(caml_call1(abs, base), _j_);
    if(_v_){
     var _w_ = caml_greaterthan(exponent, _k_);
     if(_w_)
      var _x_ = _w_;
     else
      var
       _y_ = caml_int64_to_int32(exponent),
       _z_ = caml_check_bound(Base_Pow_overflow_bounds[6], _y_)[1 + _y_],
       _x_ = caml_greaterthan(caml_call1(abs, base), _z_);
    }
    else
     var _x_ = _v_;
    if(_x_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   var
    Private = [0, int_pow, int64_pow, int63_pow_on_int64],
    Base_Int_math =
      [0,
       function(X){
        function symbol(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _u_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _l_, caml_call1(X[4], x), _u_, 0);
         }
         var rval = caml_call2(X[20], x, y);
         return caml_call2(X[14], rval, X[18])
                 ? caml_call2(X[5], rval, y)
                 : rval;
        }
        var one = caml_call1(X[19], 1);
        function symbol$0(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _r_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _m_, caml_call1(X[4], x), _r_, 0);
         }
         if(! caml_call2(X[14], x, X[18])) return caml_call2(X[8], x, y);
         var _s_ = caml_call2(X[5], x, one), _t_ = caml_call2(X[8], _s_, y);
         return caml_call2(X[6], _t_, one);
        }
        function symbol$1(x, y){
         var _p_ = caml_call1(X[2], y), _q_ = caml_call1(X[2], x);
         return caml_call2(Base_Import[96], _q_, _p_);
        }
        function round_down(i, modulus){
         var _o_ = symbol(i, modulus);
         return caml_call2(X[6], i, _o_);
        }
        function round_up(i, modulus){
         var remainder = symbol(i, modulus);
         if(caml_call2(X[12], remainder, X[18])) return i;
         var _n_ = caml_call2(X[5], i, modulus);
         return caml_call2(X[6], _n_, remainder);
        }
        function round_towards_zero(i, to_multiple_of){
         return caml_call2(X[12], i, X[18])
                 ? X[18]
                 : caml_call2
                    (X[13], i, X[18])
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        function round_nearest(i, modulus){
         var
          remainder = symbol(i, modulus),
          modulus_minus_remainder = caml_call2(X[6], modulus, remainder);
         return caml_call2(X[11], modulus_minus_remainder, remainder)
                 ? caml_call2(X[5], i, modulus_minus_remainder)
                 : caml_call2(X[6], i, remainder);
        }
        function round(opt, i, to_multiple_of){
         if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
         return 857423934 <= dir
                 ? 1003109192
                   <= dir
                   ? round_towards_zero(i, to_multiple_of)
                   : round_nearest(i, to_multiple_of)
                 : 759637122
                   <= dir
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        return [0,
                symbol,
                symbol$0,
                symbol$1,
                round,
                round_towards_zero,
                round_down,
                round_up,
                round_nearest];
       },
       Private];
   runtime.caml_register_global(17, Base_Int_math, "Base__Int_math");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Staged
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function stage(_b_){return _b_;}
   function unstage(_a_){return _a_;}
   var Base_Staged = [0, stage, unstage];
   runtime.caml_register_global(0, Base_Staged, "Base__Staged");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Bytes_intf = [0];
   runtime.caml_register_global(0, Base_Bytes_intf, "Base__Bytes_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char
//# unitInfo: Requires: Base__Array0, Base__Char0, Base__Comparable, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Sexp, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Char",
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_String0 = global_data.Base__String0,
    Base_Char0 = global_data.Base__Char0,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Array0 = global_data.Base__Array0,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Char0[1],
    escaped = Base_Char0[2],
    lowercase = Base_Char0[3],
    to_int = Base_Char0[4],
    unsafe_of_int = Base_Char0[5],
    uppercase = Base_Char0[6],
    min_value = Base_Char0[8],
    max_value = Base_Char0[9],
    of_int = Base_Char0[10],
    of_int_exn = Base_Char0[11],
    compare = Base_Import[226],
    hash_fold_t = Base_Import[205],
    func = Base_Import[219],
    cst_char = "char",
    cst_Char_get_hex_digit_exn_not =
      "Char.get_hex_digit_exn: not a hexadecimal digit",
    _d_ =
      [0,
       [11, "Char.get_digit_exn ", [1, [11, ": not a digit", 0]]],
       "Char.get_digit_exn %C: not a digit"],
    _b_ = [0, [1, 0], "%C"],
    _a_ = [0, [11, "Char.of_string: ", [3, 0, 0]], "Char.of_string: %S"];
   function hash(x){return caml_call1(func, x);}
   var
    globalize = Base_Import[282],
    t_of_sexp = Base_Import[162],
    sexp_of_t = Base_Import[138],
    t_sexp_grammar = Base_Import[184];
   function to_string(t){return caml_call2(Base_String0[8], 1, t);}
   function of_string(s){
    return 1 === runtime.caml_ml_string_length(s)
            ? runtime.caml_string_get(s, 0)
            : caml_call3(failwithf, _a_, s, 0);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    hashable = include[24];
   function pp(fmt, c){return caml_call3(Stdlib_Format[137], fmt, _b_, c);}
   function invariant(param){return 0;}
   var
    _c_ = caml_call2(Base_Array0[12], 256, unsafe_of_int),
    all = caml_call1(Base_Array0[16], _c_);
   function is_lowercase(param){return 25 < param - 97 >>> 0 ? 0 : 1;}
   function is_uppercase(param){return 25 < param - 65 >>> 0 ? 0 : 1;}
   function is_print(param){return 94 < param - 32 >>> 0 ? 0 : 1;}
   function is_whitespace(param){
    a:
    {
     if(14 <= param){if(32 === param) break a;} else if(9 <= param) break a;
     return 0;
    }
    return 1;
   }
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function is_alpha(param){
    a:
    {
     if(91 <= param){
      if(25 < param - 97 >>> 0) break a;
     }
     else if(65 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_alphanum(param){
    var _v_ = param - 48 | 0;
    a:
    {
     if(42 < _v_ >>> 0){
      if(25 < _v_ - 49 >>> 0) break a;
     }
     else if(6 >= _v_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function get_digit_unsafe(t){
    var _t_ = caml_call1(to_int, 48), _u_ = caml_call1(to_int, t);
    return caml_call2(Base_Import[93], _u_, _t_);
   }
   function get_digit_exn(t){
    return is_digit(t)
            ? get_digit_unsafe(t)
            : caml_call3(failwithf, _d_, t, 0);
   }
   function get_digit(t){return is_digit(t) ? [0, get_digit_unsafe(t)] : 0;}
   function is_hex_digit(param){
    var _s_ = param - 48 | 0;
    a:
    {
     if(22 < _s_ >>> 0){
      if(5 < _s_ - 49 >>> 0) break a;
     }
     else if(6 >= _s_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_lower(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 97 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_upper(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 65 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function get_hex_digit_exn(t){
    if(65 <= t){
     if(97 <= t){
      if(103 > t){
       var
        _k_ = caml_call1(to_int, 97),
        _l_ = caml_call1(to_int, t),
        _m_ = caml_call2(Base_Import[93], _l_, _k_);
       return caml_call2(Base_Import[91], _m_, 10);
      }
     }
     else if(71 > t){
      var
       _n_ = caml_call1(to_int, 65),
       _o_ = caml_call1(to_int, t),
       _p_ = caml_call2(Base_Import[93], _o_, _n_);
      return caml_call2(Base_Import[91], _p_, 10);
     }
    }
    else if(9 >= t - 48 >>> 0){
     var _q_ = caml_call1(to_int, 48), _r_ = caml_call1(to_int, t);
     return caml_call2(Base_Import[93], _r_, _q_);
    }
    var
     _i_ = [0, [0, cst_char, caml_call1(sexp_of_t$0, t)], 0],
     _j_ = caml_call2(Base_Sexp[10], cst_Char_get_hex_digit_exn_not, _i_);
    return caml_call1(Base_Error[32], _j_);
   }
   function get_hex_digit(t){
    return is_hex_digit(t) ? [0, get_hex_digit_exn(t)] : 0;
   }
   var
    symbol = Base_Import[106][6],
    symbol$0 = Base_Import[106][2],
    symbol$1 = Base_Import[106][4],
    symbol$2 = Base_Import[106][5],
    symbol$3 = Base_Import[106][1],
    symbol$4 = Base_Import[106][3],
    O = [0, symbol, symbol$0, symbol$1, symbol$2, symbol$3, symbol$4],
    t_of_sexp$1 = Base_Import[162],
    sexp_of_t$1 = Base_Import[138],
    t_sexp_grammar$0 = Base_Import[184];
   function compare$0(c1, c2){
    var _g_ = caml_call1(lowercase, c2), _h_ = caml_call1(lowercase, c1);
    return caml_call2(Base_Import[106][9], _h_, _g_);
   }
   function compare_local(c1, c2){return compare$0(c1, c2);}
   function hash_fold_t$1(state, t){
    var _f_ = caml_call1(lowercase, t);
    return caml_call2(Base_Import[205], state, _f_);
   }
   function hash$1(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$1, t);}
   var
    include$0 = caml_call1(Base_Comparable[11], [0, compare$0, sexp_of_t$1]),
    symbol$5 = include$0[1],
    symbol$6 = include$0[2],
    symbol$7 = include$0[3],
    symbol$8 = include$0[4],
    symbol$9 = include$0[5],
    symbol$10 = include$0[6],
    equal = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between$0 = include$0[13],
    clamp_exn$0 = include$0[14],
    clamp$0 = include$0[15],
    comparator$0 = include$0[16];
   function equal_local(t1, t2){
    var _e_ = compare_local(t1, t2);
    return caml_call2(Base_Import[242], _e_, 0);
   }
   var
    include$1 = Base_Import[106],
    symbol$11 = include$1[1],
    symbol$12 = include$1[2],
    symbol$13 = include$1[3],
    symbol$14 = include$1[4],
    symbol$15 = include$1[5],
    symbol$16 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    compare_local$0 = include$1[10],
    equal$0 = include$1[11],
    equal_local$0 = include$1[12],
    max$0 = include$1[13],
    min$0 = include$1[14],
    Base_Char =
      [0,
       all,
       globalize,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$16,
       symbol$12,
       symbol$14,
       symbol$15,
       symbol$11,
       symbol$13,
       equal$0,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       equal_local$0,
       compare_local$0,
       invariant,
       O,
       to_int,
       of_int,
       of_int_exn,
       unsafe_of_int,
       escaped,
       lowercase,
       uppercase,
       is_digit,
       is_lowercase,
       is_uppercase,
       is_alpha,
       is_alphanum,
       is_print,
       is_whitespace,
       get_digit,
       get_digit_exn,
       is_hex_digit,
       is_hex_digit_lower,
       is_hex_digit_upper,
       get_hex_digit,
       get_hex_digit_exn,
       min_value,
       max_value,
       [0,
        hash_fold_t$1,
        hash$1,
        t_of_sexp$1,
        sexp_of_t$1,
        t_sexp_grammar$0,
        symbol$5,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        equal,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between$0,
        clamp_exn$0,
        clamp$0,
        comparator$0,
        equal_local,
        compare_local]];
   runtime.caml_register_global(16, Base_Char, "Base__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_tr
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Import0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Char = global_data.Base__Char,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import0 = global_data.Base__Import0;
   function tr_create_map(target, replacement){
    var tr_map = caml_call1(Base_Bytes0[7], 256), i$3 = 0;
    for(;;){
     caml_bytes_unsafe_set(tr_map, i$3, caml_call1(Base_Char[34], i$3));
     var _j_ = i$3 + 1 | 0;
     if(255 === i$3) break;
     var i$3 = _j_;
    }
    var
     _b_ =
       caml_call2
        (Base_Import0[97][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement))
       - 1
       | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i$2 = _a_;
     for(;;){
      var
       index$0 =
         caml_call1(Base_Char[32], caml_string_unsafe_get(target, i$2));
      caml_bytes_unsafe_set
       (tr_map, index$0, caml_string_unsafe_get(replacement, i$2));
      var _i_ = i$2 + 1 | 0;
      if(_b_ === i$2) break;
      var i$2 = _i_;
     }
    }
    var
     last_replacement =
       caml_string_unsafe_get
        (replacement, caml_ml_string_length(replacement) - 1 | 0),
     _c_ =
       caml_call2
        (Base_Import0[97][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement)),
     _d_ = caml_ml_string_length(target) - 1 | 0;
    if(_d_ >= _c_){
     var i$1 = _c_;
     for(;;){
      var
       index = caml_call1(Base_Char[32], caml_string_unsafe_get(target, i$1));
      caml_bytes_unsafe_set(tr_map, index, last_replacement);
      var _h_ = i$1 + 1 | 0;
      if(_d_ === i$1) break;
      var i$1 = _h_;
     }
    }
    var
     first_target = runtime.caml_string_get(target, 0),
     _f_ =
       caml_bytes_unsafe_get(tr_map, caml_call1(Base_Char[32], first_target));
    if(! caml_call2(Base_Char[15], _f_, first_target)){
     var i = 0;
     for(;;){
      if(256 === i)
       var _g_ = 0;
      else{
       var _e_ = caml_call1(Base_Char[34], i);
       if(! caml_call2(Base_Char[15], caml_bytes_unsafe_get(tr_map, i), _e_)){var i$0 = i + 1 | 0, i = i$0; continue;}
       var _g_ = 1;
      }
      if(_g_) break;
      return 0;
     }
    }
    return [0, runtime.caml_string_of_bytes(tr_map)];
   }
   var Base_Bytes_tr = [0, tr_create_map];
   runtime.caml_register_global(3, Base_Bytes_tr, "Base__Bytes_tr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_String_intf = [0];
   runtime.caml_register_global(0, Base_String_intf, "Base__String_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String
//# unitInfo: Requires: Base__Array0, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparable, Base__Comparator, Base__Container, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Indexed_container, Base__Int0, Base__List, Base__Option, Base__Or_error, Base__Ordered_collection_common, Base__Printf, Base__Sequence, Base__Sexp, Base__Sexpable, Base__Staged, Base__String0, Base__String_intf, Base__Uchar0, CamlinternalLazy, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$15 = "",
    cst_case_sensitive = "case_sensitive",
    cst_char$1 = "char",
    cst_escape_char$1 = "escape_char",
    cst_pattern = "pattern",
    cst_pos$2 = "pos",
    cst_src_string_ml = "src/string.ml",
    cst_str$1 = "str",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$14 = cst$15,
    cst$13 = cst$15,
    cst$12 = cst$15,
    cst$11 = cst$15,
    cst$10 = cst$15,
    cst$8 = cst$15,
    cst$9 = cst$15,
    cst$6 = cst$15,
    cst$7 = cst$15,
    cst$5 = cst$15,
    cst$4 = cst$15,
    cst$3 = cst$15,
    cst$2 = cst$15,
    cst$1 = cst$15,
    cst$0 = cst$15,
    cst = cst$15,
    codec_name = "UTF-8",
    module_name = "Base.String.Utf8",
    codec_name$0 = "UTF-16LE",
    module_name$0 = "Base.String.Utf16le",
    codec_name$1 = "UTF-16BE",
    module_name$1 = "Base.String.Utf16be",
    codec_name$2 = "UTF-32LE",
    module_name$2 = "Base.String.Utf32le",
    codec_name$3 = "UTF-32BE",
    module_name$3 = "Base.String.Utf32be",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Uchar0 = global_data.Base__Uchar0,
    Base_Bytes0 = global_data.Base__Bytes0,
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base_Sequence = global_data.Base__Sequence,
    Base_Sexp = global_data.Base__Sexp,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Printf = global_data.Base__Printf,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Or_error = global_data.Base__Or_error,
    Base_Option = global_data.Base__Option,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Container = global_data.Base__Container,
    Base_Hash = global_data.Base__Hash,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_String0 = global_data.Base__String0,
    Base_Error = global_data.Base__Error,
    Base_Staged = global_data.Base__Staged,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    max_length = Base_String0[2],
    symbol = Base_String0[3],
    capitalize = Base_String0[4],
    compare = Base_String0[5],
    escaped = Base_String0[6],
    lowercase = Base_String0[7],
    make = Base_String0[8],
    uncapitalize = Base_String0[10],
    uppercase = Base_String0[11],
    is_valid_utf_8 = Base_String0[12],
    is_valid_utf_16le = Base_String0[13],
    is_valid_utf_16be = Base_String0[14],
    get_utf_8_uchar = Base_String0[15],
    get_utf_16le_uchar = Base_String0[16],
    get_utf_16be_uchar = Base_String0[17],
    get_utf_32le_uchar = Base_String0[18],
    get_utf_32be_uchar = Base_String0[19],
    concat = Base_String0[20],
    iter = Base_String0[21],
    split_lines = Base_String0[22],
    invalid_argf = Base_Printf[7],
    raise_s = Base_Error[32],
    stage = Base_Staged[1],
    globalize = Base_Import[289],
    hash_fold_t = Base_Import[208],
    func = Base_Import[222],
    _N_ = [0, cst$15],
    _M_ = [0, cst_src_string_ml, 2020, 4],
    _L_ = [0, cst_src_string_ml, 2006, 4],
    _K_ = [0, cst_src_string_ml, 1996, 4],
    cst_pos$1 = cst_pos$2,
    _J_ =
      [0,
       [2,
        0,
        [11, ".get: invalid ", [2, 0, [11, " encoding at given position", 0]]]],
       "%s.get: invalid %s encoding at given position"],
    cst_of_string_invalid = ".of_string: invalid ",
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _I_ = [0, cst_src_string_ml, 1872, 2],
    _H_ = [0, cst_src_string_ml, 1858, 19],
    cst_char$0 = cst_char$1,
    cst_pos$0 = cst_pos$2,
    cst_escape_char$0 = cst_escape_char$1,
    cst_str$0 = cst_str$1,
    cst_rindex_from_exn_not_found = "rindex_from_exn: not found",
    cst_rindex_from = "rindex_from",
    cst_char = cst_char$1,
    cst_pos = cst_pos$2,
    cst_escape_char = cst_escape_char$1,
    cst_str = cst_str$1,
    cst_index_from_exn_not_found = "index_from_exn: not found",
    cst_index_from = "index_from",
    cst_is_char_literal = "is_char_literal",
    cst_is_char_escaped = "is_char_escaped",
    cst_is_char_escaping = "is_char_escaping",
    _G_ = [0, [2, 0, [11, ": out of bounds", 0]], "%s: out of bounds"],
    cst_escapeworthy_map = "escapeworthy_map",
    cst_c_to = "c_to",
    cst_c_from = "c_from",
    cst_escapeworthy_map_not_one_t = "escapeworthy_map not one-to-one",
    _F_ = [0, cst$15, cst$15],
    _E_ = [0, [3, 0, 0], "%S"],
    _D_ =
      [0,
       [11, "String.chop_suffix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_suffix_exn %S %S"],
    _C_ =
      [0,
       [11, "String.chop_prefix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_prefix_exn %S %S"],
    _B_ = [0, cst_src_string_ml, 925, 4],
    cst_tr_multi_replacement_is_em = "tr_multi replacement is empty string",
    _A_ = [0, cst_src_string_ml, 761, 17],
    cst_suffix = "suffix",
    cst_prefix = "prefix",
    cst_drop_suffix = "drop_suffix",
    cst_drop_prefix = "drop_prefix",
    cst_expecting_nonnegative_argu = " expecting nonnegative argument",
    _z_ = [0, "String.rsplit2_exn: not found"],
    _y_ = [0, "String.lsplit2_exn: not found"],
    _x_ = [0, [11, "String.init ", [4, 0, 0, 0, 0]], "String.init %d"],
    _p_ =
      [0,
       [11,
        "String.is_substring_at: invalid index ",
        [4, 0, 0, 0, [11, " for string of length ", [4, 0, 0, 0, 0]]]],
       "String.is_substring_at: invalid index %d for string of length %d"],
    _g_ = [0, "kmp_array"],
    _h_ = [0, cst_case_sensitive],
    _i_ = [0, cst_pattern],
    cst_substring = "substring",
    cst_Substring_not_found = "Substring not found",
    _e_ = [0, cst_case_sensitive],
    _f_ = [0, cst_pattern],
    cst_String_rindex_from_exn = "String.rindex_from_exn",
    _d_ = [0, "String.rindex_from_exn: not found"],
    _c_ = [0, "String.rindex_exn: not found"],
    cst_String_index_from_exn = "String.index_from_exn",
    _b_ = [0, "String.index_from_exn: not found"],
    _a_ = [0, "String.index_exn: not found"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[160],
    sexp_of_t = Base_Import[136],
    t_sexp_grammar = Base_Import[182],
    hashable = [0, hash, compare, sexp_of_t],
    include = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function unsafe_sub(src, pos, len){
    if(0 === len) return cst;
    var dst = caml_call1(Base_Bytes0[7], len);
    caml_blit_string(src, pos, dst, 0, len);
    return caml_string_of_bytes(dst);
   }
   function sub(src, pos, len){
    if(0 === pos && len === caml_ml_string_length(src)) return src;
    caml_call3
     (Base_Ordered_collection_common[2], pos, len, caml_ml_string_length(src));
    return unsafe_sub(src, pos, len);
   }
   function subo(opt, len, src){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], i$0 = i;
    else
     var i$0 = caml_call2(Base_Import[93], caml_ml_string_length(src), pos);
    return sub(src, pos, i$0);
   }
   function contains(opt, len, t, char$0){
    if(opt) var sth = opt[1], pos$1 = sth; else var pos$1 = 0;
    var
     total_length = caml_ml_string_length(t),
     _eG_ = caml_call2(Base_Import[93], total_length, pos$1),
     len$0 = caml_call2(Base_Option[30], len, _eG_);
    caml_call3(Base_Ordered_collection_common[2], pos$1, len$0, total_length);
    var end = caml_call2(Base_Import[91], pos$1, len$0), pos = pos$1;
    for(;;){
     var _eD_ = pos < end ? 1 : 0;
     if(_eD_){
      var
       _eE_ =
         caml_call2(Base_Char[16], caml_string_unsafe_get(t, pos), char$0);
      if(! _eE_){
       var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
       continue;
      }
      var _eF_ = _eE_;
     }
     else
      var _eF_ = _eD_;
     return _eF_;
    }
   }
   function is_empty(t){return 0 === caml_ml_string_length(t) ? 1 : 0;}
   function index_from_internal(string, len, not_found, found, char$0, pos){
    var pos$0 = pos;
    for(;;){
     if(len <= pos$0) return caml_call1(not_found, 0);
     if
      (caml_call2
        (Base_Char[16], caml_string_unsafe_get(string, pos$0), char$0))
      return caml_call1(found, pos$0);
     var pos$1 = caml_call2(Base_Import[91], pos$0, 1), pos$0 = pos$1;
    }
   }
   function index(t, char$0){
    var _eB_ = 0, _eC_ = Base_Option[49];
    return index_from_internal
            (t,
             caml_ml_string_length(t),
             function(param){return 0;},
             _eC_,
             char$0,
             _eB_);
   }
   function index_exn(t, char$0){
    var _ey_ = 0;
    function _ez_(_eA_){return _eA_;}
    return index_from_internal
            (t,
             caml_ml_string_length(t),
             function(param){
              throw caml_maybe_attach_backtrace([0, Base_Import[297], _a_], 1);
             },
             _ez_,
             char$0,
             _ey_);
   }
   function index_from(t, pos, char$0){
    var _ex_ = Base_Option[49];
    return index_from_internal
            (t,
             caml_ml_string_length(t),
             function(param){return 0;},
             _ex_,
             char$0,
             pos);
   }
   function not_found(param){
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _b_], 1);
   }
   function index_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(0 <= pos && len >= pos)
     return index_from_internal
             (t, len, not_found, function(_ew_){return _ew_;}, char$0, pos);
    return caml_call1(Base_Import[126], cst_String_index_from_exn);
   }
   function rindex_from_internal(string, char$0, found, not_found, pos){
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) return caml_call1(not_found, 0);
     if
      (caml_call2
        (Base_Char[16], caml_string_unsafe_get(string, pos$0), char$0))
      return caml_call1(found, pos$0);
     var pos$1 = caml_call2(Base_Import[93], pos$0, 1), pos$0 = pos$1;
    }
   }
   function rindex(t, char$0){
    var _eu_ = caml_call2(Base_Import[93], caml_ml_string_length(t), 1);
    function _ev_(param){return 0;}
    return rindex_from_internal(t, char$0, Base_Option[49], _ev_, _eu_);
   }
   function rindex_exn(t, char$0){
    var _er_ = caml_call2(Base_Import[93], caml_ml_string_length(t), 1);
    function _es_(param){
     throw caml_maybe_attach_backtrace([0, Base_Import[297], _c_], 1);
    }
    return rindex_from_internal
            (t, char$0, function(_et_){return _et_;}, _es_, _er_);
   }
   function rindex_from(t, pos, char$0){
    function _eq_(param){return 0;}
    return rindex_from_internal(t, char$0, Base_Option[49], _eq_, pos);
   }
   function not_found$0(param){
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _d_], 1);
   }
   function rindex_from_exn(t, pos, char$0){
    if(-1 <= pos && caml_ml_string_length(t) > pos)
     return rindex_from_internal
             (t, char$0, function(_ep_){return _ep_;}, not_found$0, pos);
    return caml_call1(Base_Import[126], cst_String_rindex_from_exn);
   }
   function sexp_of_t$0(param){
    var
     case_sensitive = param[2],
     pattern = param[1],
     _eo_ =
       [0,
        [1, [0, _e_, [0, caml_call1(Base_Import[135], case_sensitive), 0]]],
        0];
    return [1,
            [0,
             [1, [0, _f_, [0, caml_call1(Base_Import[136], pattern), 0]]],
             _eo_]];
   }
   function pattern(t){return t[1];}
   function case_sensitive(t){return t[2];}
   function kmp_internal_loop
   (matched_chars, next_text_char, pattern, kmp_array, char_equal){
    var matched_chars$0 = [0, matched_chars];
    for(;;){
     if
      (0 < matched_chars$0[1]
       &&
        !
        caml_call2
         (char_equal,
          next_text_char,
          caml_string_unsafe_get(pattern, matched_chars$0[1]))){
      matched_chars$0[1] =
       kmp_array[1 + caml_call2(Base_Import[93], matched_chars$0[1], 1)];
      continue;
     }
     if
      (caml_call2
        (char_equal,
         next_text_char,
         caml_string_unsafe_get(pattern, matched_chars$0[1])))
      matched_chars$0[1] = caml_call2(Base_Import[91], matched_chars$0[1], 1);
     return matched_chars$0[1];
    }
   }
   function get_char_equal(case_sensitive){
    return case_sensitive ? Base_Char[16] : Base_Char[55][12];
   }
   function create(pattern, case_sensitive){
    var
     n = caml_ml_string_length(pattern),
     kmp_array = caml_call2(Base_Array0[4], n, -1);
    if(0 < n){
     var char_equal = get_char_equal(case_sensitive);
     kmp_array[1] = 0;
     var
      matched_chars = [0, 0],
      _em_ = caml_call2(Base_Import[93], n, 1),
      _el_ = 1;
     if(_em_ >= 1){
      var i = _el_;
      for(;;){
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1],
          caml_string_unsafe_get(pattern, i),
          pattern,
          kmp_array,
          char_equal);
       kmp_array[1 + i] = matched_chars[1];
       var _en_ = i + 1 | 0;
       if(_em_ === i) break;
       var i = _en_;
      }
     }
    }
    return [0, pattern, case_sensitive, kmp_array];
   }
   function index_internal(opt, param){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    return function(text){
     if
      (0 <= pos
       &&
        caml_call2
         (Base_Import[93],
          caml_ml_string_length(text),
          caml_ml_string_length(pattern))
        >= pos){
      var
       char_equal = get_char_equal(case_sensitive),
       j = [0, pos],
       matched_chars = [0, 0],
       k = caml_ml_string_length(pattern),
       n = caml_ml_string_length(text);
      for(;;){
       if(j[1] < n && matched_chars[1] < k){
        var next_text_char = caml_string_unsafe_get(text, j[1]);
        matched_chars[1] =
         kmp_internal_loop
          (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
        j[1] = caml_call2(Base_Import[91], j[1], 1);
        continue;
       }
       return matched_chars[1] === k
               ? caml_call2(Base_Import[93], j[1], k)
               : -1;
      }
     }
     return -1;};
   }
   function matches(t, str){return 0 <= index_internal(0, t)(str) ? 1 : 0;}
   function index$0(pos, t, in$0){
    var p = index_internal(pos, t)(in$0);
    return 0 <= p ? [0, p] : 0;
   }
   function index_exn$0(pos, t, in$0){
    var p = index_internal(pos, t)(in$0);
    if(0 <= p) return p;
    var _ek_ = [0, [0, cst_substring, caml_call1(Base_Import[136], t[1])], 0];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[10], cst_Substring_not_found, _ek_));
   }
   function index_all(param, may_overlap, text){
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    if(0 === caml_ml_string_length(pattern)){
     var
      _ee_ = function(_ej_){return _ej_;},
      _ef_ = caml_call2(Base_Import[91], 1, caml_ml_string_length(text));
     return caml_call2(Base_List[40], _ef_, _ee_);
    }
    var
     char_equal = get_char_equal(case_sensitive),
     matched_chars = [0, 0],
     k = caml_ml_string_length(pattern),
     n = caml_ml_string_length(text),
     found = [0, 0],
     _eg_ = 0;
    if(n >= 0){
     var j = _eg_;
     for(;;){
      if(matched_chars[1] === k){
       var _eh_ = found[1];
       found[1] = [0, caml_call2(Base_Import[93], j, k), _eh_];
       matched_chars[1] =
        may_overlap ? kmp_array[1 + caml_call2(Base_Import[93], k, 1)] : 0;
      }
      if(j < n){
       var next_text_char = caml_string_unsafe_get(text, j);
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
      }
      var _ei_ = j + 1 | 0;
      if(n === j) break;
      var j = _ei_;
     }
    }
    return caml_call1(Base_List[63], found[1]);
   }
   function replace_first(pos, t, s, with$0){
    var match = index$0(pos, t, s);
    if(! match) return s;
    var
     i = match[1],
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     _d__ = caml_call2(Base_Import[91], len_s, len_with),
     _d$_ = caml_call2(Base_Import[93], _d__, len_t),
     dst = caml_call1(Base_Bytes0[7], _d$_);
    caml_call5(Base_Bytes0[4], s, 0, dst, 0, i);
    caml_call5(Base_Bytes0[4], with$0, 0, dst, i, len_with);
    var
     _ea_ = caml_call2(Base_Import[93], len_s, i),
     _eb_ = caml_call2(Base_Import[93], _ea_, len_t),
     _ec_ = caml_call2(Base_Import[91], i, len_with),
     _ed_ = caml_call2(Base_Import[91], i, len_t);
    caml_call5(Base_Bytes0[4], s, _ed_, dst, _ec_, _eb_);
    return caml_string_of_bytes(dst);
   }
   function replace_all(t, s, with$0){
    var matches = index_all(t, 0, s);
    if(! matches) return s;
    var
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     num_matches = caml_call1(Base_List[45], matches),
     _d2_ = caml_call2(Base_Import[93], len_with, len_t),
     _d3_ = caml_call2(Base_Import[88], _d2_, num_matches),
     _d4_ = caml_call2(Base_Import[91], len_s, _d3_),
     dst = caml_call1(Base_Bytes0[7], _d4_),
     next_dst_pos = [0, 0],
     next_src_pos = [0, 0];
    function _d5_(i){
     var len = caml_call2(Base_Import[93], i, next_src_pos[1]);
     caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], len);
     var _d7_ = caml_call2(Base_Import[91], next_dst_pos[1], len);
     caml_call5(Base_Bytes0[4], with$0, 0, dst, _d7_, len_with);
     var _d8_ = caml_call2(Base_Import[91], next_dst_pos[1], len);
     next_dst_pos[1] = caml_call2(Base_Import[91], _d8_, len_with);
     var _d9_ = caml_call2(Base_Import[91], next_src_pos[1], len);
     next_src_pos[1] = caml_call2(Base_Import[91], _d9_, len_t);
     return 0;
    }
    caml_call2(Base_List[19], matches, _d5_);
    var _d6_ = caml_call2(Base_Import[93], len_s, next_src_pos[1]);
    caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], _d6_);
    return caml_string_of_bytes(dst);
   }
   function split_on(t, s){
    var
     pattern_len = caml_ml_string_length(t[1]),
     matches = index_all(t, 0, s);
    function _dX_(i, j){
     var
      _d0_ = caml_call2(Base_Import[93], j, i),
      _d1_ = caml_call2(Base_Import[93], _d0_, pattern_len);
     return sub(s, caml_call2(Base_Import[91], i, pattern_len), _d1_);
    }
    var
     _dY_ =
       caml_call2(Base_Import[111], matches, [0, caml_ml_string_length(s), 0]),
     _dZ_ = [0, caml_call1(Base_Import[113], pattern_len), matches];
    return caml_call3(Base_List[98], _dZ_, _dY_, _dX_);
   }
   function equal_local(a_003, b_004){
    if(a_003 === b_004) return 1;
    var _dU_ = caml_call2(Base_Import[274], a_003[1], b_004[1]);
    if(_dU_){
     var _dV_ = caml_call2(Base_Import[267], a_003[2], b_004[2]);
     if(_dV_)
      return caml_call3
              (Base_Import[277], Base_Import[270], a_003[3], b_004[3]);
     var _dW_ = _dV_;
    }
    else
     var _dW_ = _dU_;
    return _dW_;
   }
   function equal(a, b){return equal_local(a, b);}
   function sexp_of_t$1(param){
    var
     kmp_array_012 = param[3],
     case_sensitive_010 = param[2],
     pattern_008 = param[1],
     arg_013 = caml_call2(Base_Import[150], Base_Import[139], kmp_array_012),
     bnds_007 = [0, [1, [0, _g_, [0, arg_013, 0]]], 0],
     arg_011 = caml_call1(Base_Import[135], case_sensitive_010),
     bnds_007$0 = [0, [1, [0, _h_, [0, arg_011, 0]]], bnds_007],
     arg_009 = caml_call1(Base_Import[136], pattern_008),
     bnds_007$1 = [0, [1, [0, _i_, [0, arg_009, 0]]], bnds_007$0];
    return [1, bnds_007$1];
   }
   function representation(_dT_){return _dT_;}
   function substr_index_gen(case_sensitive, pos, t, pattern){return index$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_exn_gen(case_sensitive, pos, t, pattern){return index_exn$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_all_gen(case_sensitive, t, may_overlap, pattern){return index_all(create(pattern, case_sensitive), may_overlap, t);
   }
   function substr_replace_first_gen(case_sensitive, pos, t, pattern){
    var _dR_ = create(pattern, case_sensitive);
    return function(_dS_){return replace_first(pos, _dR_, t, _dS_);};
   }
   function substr_replace_all_gen(case_sensitive, t, pattern){
    var _dP_ = create(pattern, case_sensitive);
    return function(_dQ_){return replace_all(_dP_, t, _dQ_);};
   }
   function is_substring_gen(case_sensitive, t, substring){
    var _dO_ = substr_index_gen(case_sensitive, 0, t, substring);
    return caml_call1(Base_Option[53], _dO_);
   }
   var _j_ = 1;
   function substr_index(_dL_, _dM_, _dN_){
    return substr_index_gen(_j_, _dL_, _dM_, _dN_);
   }
   var _k_ = 1;
   function substr_index_exn(_dI_, _dJ_, _dK_){
    return substr_index_exn_gen(_k_, _dI_, _dJ_, _dK_);
   }
   var _l_ = 1;
   function substr_index_all(_dF_, _dG_, _dH_){
    return substr_index_all_gen(_l_, _dF_, _dG_, _dH_);
   }
   var _m_ = 1;
   function substr_replace_first(_dC_, _dD_, _dE_){
    return substr_replace_first_gen(_m_, _dC_, _dD_, _dE_);
   }
   var _n_ = 1;
   function substr_replace_all(_dA_, _dB_){
    return substr_replace_all_gen(_n_, _dA_, _dB_);
   }
   var _o_ = 1;
   function is_substring(_dy_, _dz_){
    return is_substring_gen(_o_, _dy_, _dz_);
   }
   function is_substring_at_gen(str, str_pos$1, sub, char_equal){
    var
     str_len = caml_ml_string_length(str),
     sub_len = caml_ml_string_length(sub),
     _dv_ = str_pos$1 < 0 ? 1 : 0,
     _dw_ = _dv_ || (str_len < str_pos$1 ? 1 : 0);
    if(_dw_) caml_call4(invalid_argf, _p_, str_pos$1, str_len, 0);
    var
     _dx_ = caml_call2(Base_Import[91], str_pos$1, sub_len) <= str_len ? 1 : 0;
    if(! _dx_) return _dx_;
    var str_pos = str_pos$1, sub_pos = 0;
    for(;;){
     if(sub_pos === sub_len) return 1;
     if
      (!
       caml_call2
        (char_equal,
         caml_string_unsafe_get(str, str_pos),
         caml_string_unsafe_get(sub, sub_pos)))
      return 0;
     var
      sub_pos$0 = caml_call2(Base_Import[91], sub_pos, 1),
      str_pos$0 = caml_call2(Base_Import[91], str_pos, 1),
      str_pos = str_pos$0,
      sub_pos = sub_pos$0;
    }
   }
   function is_suffix_gen(string, suffix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     suffix_len = caml_ml_string_length(suffix),
     _du_ = suffix_len <= string_len ? 1 : 0;
    return _du_
            ? is_substring_at_gen
              (string,
               caml_call2(Base_Import[93], string_len, suffix_len),
               suffix,
               char_equal)
            : _du_;
   }
   function is_prefix_gen(string, prefix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     prefix_len = caml_ml_string_length(prefix),
     _dt_ = prefix_len <= string_len ? 1 : 0;
    return _dt_ ? is_substring_at_gen(string, 0, prefix, char_equal) : _dt_;
   }
   var
    t_of_sexp$0 = Base_Import[160],
    sexp_of_t$2 = Base_Import[136],
    t_sexp_grammar$0 = Base_Import[182];
   function compare_local(string1, string2){
    if(string1 === string2) return 0;
    var
     len2 = caml_ml_string_length(string2),
     len1 = caml_ml_string_length(string1),
     pos = 0;
    for(;;){
     if(pos === len1) return pos === len2 ? 0 : -1;
     if(pos === len2) return 1;
     var
      c2 = caml_string_unsafe_get(string2, pos),
      c1 = caml_string_unsafe_get(string1, pos),
      _dr_ = caml_call1(Base_Char[37], c2),
      _ds_ = caml_call1(Base_Char[37], c1),
      c = caml_call2(Base_Char[17], _ds_, _dr_);
     if(0 !== c) return c;
     var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
    }
   }
   function compare$0(a, b){return compare_local(a, b);}
   function hash_fold_t$0(state, t){
    var
     len = caml_ml_string_length(t),
     state$0 = [0, caml_call2(Base_Import[206], state, len)],
     _do_ = caml_call2(Base_Import[93], len, 1),
     _dn_ = 0;
    if(_do_ >= 0){
     var pos = _dn_;
     for(;;){
      var _dp_ = caml_call1(Base_Char[37], caml_string_unsafe_get(t, pos));
      state$0[1] = caml_call2(Base_Import[205], state$0[1], _dp_);
      var _dq_ = pos + 1 | 0;
      if(_do_ === pos) break;
      var pos = _dq_;
     }
    }
    return state$0[1];
   }
   function hash$0(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$0, t);}
   function is_suffix(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[55][12]);
   }
   function is_prefix(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[55][12]);
   }
   var _q_ = 0;
   function substr_index$0(_dk_, _dl_, _dm_){
    return substr_index_gen(_q_, _dk_, _dl_, _dm_);
   }
   var _r_ = 0;
   function substr_index_exn$0(_dh_, _di_, _dj_){
    return substr_index_exn_gen(_r_, _dh_, _di_, _dj_);
   }
   var _s_ = 0;
   function substr_index_all$0(_de_, _df_, _dg_){
    return substr_index_all_gen(_s_, _de_, _df_, _dg_);
   }
   var _t_ = 0;
   function substr_replace_first$0(_db_, _dc_, _dd_){
    return substr_replace_first_gen(_t_, _db_, _dc_, _dd_);
   }
   var _u_ = 0;
   function substr_replace_all$0(_c$_, _da_){
    return substr_replace_all_gen(_u_, _c$_, _da_);
   }
   var _v_ = 0;
   function is_substring$0(_c9_, _c__){
    return is_substring_gen(_v_, _c9_, _c__);
   }
   var _w_ = Base_Char[55][12];
   function is_substring_at(_c6_){
    return function(_c7_){
     return function(_c8_){
      return is_substring_at_gen(_c6_, _c7_, _c8_, _w_);};};
   }
   var
    include$0 = caml_call1(Base_Comparable[11], [0, compare$0, sexp_of_t$2]),
    symbol$0 = include$0[1],
    symbol$1 = include$0[2],
    symbol$2 = include$0[3],
    symbol$3 = include$0[4],
    symbol$4 = include$0[5],
    symbol$5 = include$0[6],
    equal$0 = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator$0 = include$0[16];
   function of_string(_c5_){return _c5_;}
   function to_string(_c4_){return _c4_;}
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _x_, n, 0);
    var
     t = caml_call1(Base_Bytes0[7], n),
     _c2_ = caml_call2(Base_Import[93], n, 1),
     _c1_ = 0;
    if(_c2_ >= 0){
     var i = _c1_;
     for(;;){
      caml_bytes_set(t, i, caml_call1(f, i));
      var _c3_ = i + 1 | 0;
      if(_c2_ === i) break;
      var i = _c3_;
     }
    }
    return caml_string_of_bytes(t);
   }
   function to_list(s){
    var
     i$1 = caml_call2(Base_Import[93], caml_ml_string_length(s), 1),
     acc = 0,
     i = i$1;
    for(;;){
     if(0 > i) return acc;
     var
      i$0 = caml_call2(Base_Import[93], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc],
      acc = acc$0,
      i = i$0;
    }
   }
   function to_list_rev(s){
    var len = caml_ml_string_length(s), acc = 0, i = 0;
    for(;;){
     if(i === len) return acc;
     var
      i$0 = caml_call2(Base_Import[91], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc],
      acc = acc$0,
      i = i$0;
    }
   }
   function rev(t){
    var
     len = caml_ml_string_length(t),
     res = caml_call1(Base_Bytes0[7], len),
     _cY_ = caml_call2(Base_Import[93], len, 1),
     _cX_ = 0;
    if(_cY_ >= 0){
     var i = _cX_;
     for(;;){
      var _cZ_ = caml_call2(Base_Import[93], len, 1);
      caml_bytes_unsafe_set
       (res,
        i,
        caml_string_unsafe_get(t, caml_call2(Base_Import[93], _cZ_, i)));
      var _c0_ = i + 1 | 0;
      if(_cY_ === i) break;
      var i = _c0_;
     }
    }
    return caml_string_of_bytes(res);
   }
   function not_found$1(param){
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _y_], 1);
   }
   function lsplit2_exn(line, delim){
    var
     len = caml_ml_string_length(line),
     _cS_ = 0,
     pos =
       index_from_internal
        (line, len, not_found$1, function(_cW_){return _cW_;}, delim, _cS_),
     _cT_ = caml_call2(Base_Import[93], len, pos),
     _cU_ = caml_call2(Base_Import[93], _cT_, 1),
     _cV_ = sub(line, caml_call2(Base_Import[91], pos, 1), _cU_);
    return [0, sub(line, 0, pos), _cV_];
   }
   function not_found$2(param){
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _z_], 1);
   }
   function rsplit2_exn(line, delim){
    var
     len = caml_ml_string_length(line),
     _cN_ = caml_call2(Base_Import[93], len, 1),
     pos =
       rindex_from_internal
        (line, delim, function(_cR_){return _cR_;}, not_found$2, _cN_),
     _cO_ = caml_call2(Base_Import[93], len, pos),
     _cP_ = caml_call2(Base_Import[93], _cO_, 1),
     _cQ_ = sub(line, caml_call2(Base_Import[91], pos, 1), _cP_);
    return [0, sub(line, 0, pos), _cQ_];
   }
   function lsplit2(line, on){
    try{var _cL_ = [0, lsplit2_exn(line, on)]; return _cL_;}
    catch(_cM_){
     var _cK_ = caml_wrap_exception(_cM_);
     if(_cK_[1] !== Base_Import[297] && _cK_ !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(_cK_, 0);
     return 0;
    }
   }
   function rsplit2(line, on){
    try{var _cI_ = [0, rsplit2_exn(line, on)]; return _cI_;}
    catch(_cJ_){
     var _cH_ = caml_wrap_exception(_cJ_);
     if(_cH_[1] !== Base_Import[297] && _cH_ !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(_cH_, 0);
     return 0;
    }
   }
   function char_list_mem(l, c){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], _cG_ = caml_call2(Base_Char[16], hd, c);
     if(_cG_) return _cG_;
     var l$0 = tl;
    }
   }
   function split_gen(str, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[16], c$0, c);};
    var
     last_pos = caml_ml_string_length(str),
     pos$1 = caml_call2(Base_Import[93], last_pos, 1),
     acc = 0,
     last_pos$1 = last_pos,
     last_pos$0 = pos$1;
    for(;;){
     if(-1 === last_pos$0) return [0, sub(str, 0, last_pos$1), acc];
     if(is_delim(caml_string_get(str, last_pos$0)))
      var
       pos1 = caml_call2(Base_Import[91], last_pos$0, 1),
       sub_str = sub(str, pos1, caml_call2(Base_Import[93], last_pos$1, pos1)),
       pos = caml_call2(Base_Import[93], last_pos$0, 1),
       acc$0 = [0, sub_str, acc],
       acc = acc$0,
       last_pos$1 = last_pos$0,
       last_pos$0 = pos;
     else
      var
       pos$0 = caml_call2(Base_Import[93], last_pos$0, 1),
       last_pos$0 = pos$0;
    }
   }
   function split(str, on){return split_gen(str, [0, -1044422954, on]);}
   function split_on_chars(str, chars){
    return split_gen(str, [0, 552554919, chars]);
   }
   function is_suffix$0(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[16]);
   }
   function is_prefix$0(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[16]);
   }
   function is_substring_at$0(s, pos, substring){
    return is_substring_at_gen(s, pos, substring, Base_Char[16]);
   }
   function wrap_sub_n(t, n, name, pos, len, on_error){
    if(0 <= n)
     try{var _cD_ = sub(t, pos, len); return _cD_;}
     catch(_cF_){return on_error;}
    var _cE_ = caml_call2(symbol, name, cst_expecting_nonnegative_argu);
    return caml_call1(Base_Import[126], _cE_);
   }
   function drop_prefix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_prefix,
             n,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             cst$0);
   }
   function drop_suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_suffix,
             0,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             cst$1);
   }
   function prefix(t, n){return wrap_sub_n(t, n, cst_prefix, 0, n, t);}
   function suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_suffix,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             n,
             t);
   }
   function lfindi(opt, t, f){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var n = caml_ml_string_length(t), i = pos;
    for(;;){
     if(i === n) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   function find(t, f){
    var match = lfindi(0, t, function(param, c){return caml_call1(f, c);});
    if(! match) return 0;
    var i = match[1];
    return [0, caml_string_get(t, i)];
   }
   function find_map(t, f){
    var n = caml_ml_string_length(t), i = 0;
    for(;;){
     if(i === n) return 0;
     var res = caml_call1(f, caml_string_get(t, i));
     if(res) return res;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   function rfindi(pos, t, f){
    if(pos)
     var pos$0 = pos[1], pos$1 = pos$0;
    else
     var pos$1 = caml_call2(Base_Import[93], caml_ml_string_length(t), 1);
    var i = pos$1;
    for(;;){
     if(0 > i) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0;
    }
   }
   function last_non_drop(drop, t){
    return rfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function rstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var match = last_non_drop(drop, t);
    if(! match) return cst$2;
    var i = match[1];
    return i === caml_call2(Base_Import[93], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[91], i, 1));
   }
   function first_non_drop(drop, t){
    return lfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function lstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var match = first_non_drop(drop, t);
    if(! match) return cst$3;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[93], length, 1))))
      break a;
     var match = first_non_drop(drop, t);
     if(! match) return cst$4;
     var first = match[1], match$0 = last_non_drop(drop, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     var last = match$0[1], _cC_ = caml_call2(Base_Import[93], last, first);
     return sub(t, first, caml_call2(Base_Import[91], _cC_, 1));
    }
    return t;
   }
   function mapi(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _cA_ = caml_call2(Base_Import[93], l, 1),
     _cz_ = 0;
    if(_cA_ >= 0){
     var i = _cz_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call2(f, i, caml_string_get(t, i)));
      var _cB_ = i + 1 | 0;
      if(_cA_ === i) break;
      var i = _cB_;
     }
    }
    return caml_string_of_bytes(t$0);
   }
   function map(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _cx_ = caml_call2(Base_Import[93], l, 1),
     _cw_ = 0;
    if(_cx_ >= 0){
     var i = _cw_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call1(f, caml_string_get(t, i)));
      var _cy_ = i + 1 | 0;
      if(_cx_ === i) break;
      var i = _cy_;
     }
    }
    return caml_string_of_bytes(t$0);
   }
   function to_array(s){
    function _cv_(i){return caml_string_get(s, i);}
    return caml_call2(Base_Array0[12], caml_ml_string_length(s), _cv_);
   }
   function exists(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _cs_ = i < len ? 1 : 0;
     if(_cs_){
      var _ct_ = caml_call1(f, caml_string_get(s, i));
      if(! _ct_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _cu_ = _ct_;
     }
     else
      var _cu_ = _cs_;
     return _cu_;
    }
   }
   function for_all(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _cp_ = i === len ? 1 : 0;
     if(_cp_)
      var _cq_ = _cp_;
     else{
      var _cr_ = caml_call1(f, caml_string_get(s, i));
      if(_cr_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _cq_ = _cr_;
     }
     return _cq_;
    }
   }
   function fold(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call2(f, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[91], i, 1),
      i = i$0,
      ac = ac$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call3(f, i, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[91], i, 1),
      i = i$0,
      ac = ac$0;
    }
   }
   function iteri(t, f){
    var
     _cn_ = caml_call2(Base_Import[93], caml_ml_string_length(t), 1),
     _cm_ = 0;
    if(_cn_ >= 0){
     var i = _cm_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(t, i));
      var _co_ = i + 1 | 0;
      if(_cn_ === i) break;
      var i = _co_;
     }
    }
    return 0;
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t){return caml_call2(Base_Container[3], fold, t);}
   function max_elt(t){return caml_call2(Base_Container[4], fold, t);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   function find_mapi(t, f){
    return caml_call3(Base_Indexed_container[7], iteri, t, f);
   }
   function findi(t, f){
    return caml_call3(Base_Indexed_container[6], iteri, t, f);
   }
   function counti(t, f){
    return caml_call3(Base_Indexed_container[3], foldi, t, f);
   }
   function for_alli(t, f){
    return caml_call3(Base_Indexed_container[5], iteri, t, f);
   }
   function existsi(t, f){
    return caml_call3(Base_Indexed_container[4], iteri, t, f);
   }
   function mem(t, c){
    var len = caml_ml_string_length(t), i = 0;
    for(;;){
     var _cj_ = i < len ? 1 : 0;
     if(_cj_){
      var _ck_ = caml_call2(Base_Char[16], c, caml_string_unsafe_get(t, i));
      if(! _ck_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _cl_ = _ck_;
     }
     else
      var _cl_ = _cj_;
     return _cl_;
    }
   }
   function tr(target, replacement, s){
    return caml_call2(Base_Char[16], target, replacement)
            ? s
            : mem
               (s, target)
              ? map
                (s,
                 function(c){
                  return caml_call2(Base_Char[16], c, target)
                          ? replacement
                          : c;
                 })
              : s;
   }
   function tr_multi(target, replacement){
    if(is_empty(target))
     return caml_call1(stage, function(_ci_){return _ci_;});
    if(is_empty(replacement))
     return caml_call1(Base_Import[126], cst_tr_multi_replacement_is_em);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_ch_){return _ch_;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              return exists
                       (s,
                        function(c){
                         var
                          _cg_ =
                            caml_string_unsafe_get(tr_map, caml_call1(Base_Char[32], c));
                         return caml_call2(Base_Char[15], c, _cg_);
                        })
                      ? map
                        (s,
                         function(c){
                          return caml_string_unsafe_get
                                  (tr_map, caml_call1(Base_Char[32], c));
                         })
                      : s;
             });
   }
   function concat_array(sep, ar){
    return caml_call2(concat, sep, caml_call1(Base_Array0[16], ar));
   }
   function concat_map(sep, s, f){
    var _cf_ = to_array(s);
    return concat_array(sep, caml_call2(Base_Array0[21], _cf_, f));
   }
   function concat_mapi(sep, t, f){
    var _ce_ = to_array(t);
    return concat_array(sep, caml_call2(Base_Array0[22], _ce_, f));
   }
   function concat_lines(opt, lines$3){
    if(opt) var sth = opt[1], crlf = sth; else var crlf = 0;
    var newline_len = crlf ? 2 : 1, lines = lines$3, sum = 0;
    for(;;){
     if(! lines) break;
     var
      lines$0 = lines[2],
      line = lines[1],
      _cd_ = caml_call2(Base_Import[91], sum, caml_ml_string_length(line)),
      sum$0 = caml_call2(Base_Import[91], _cd_, newline_len),
      lines = lines$0,
      sum = sum$0;
    }
    var buf = caml_call1(Base_Bytes0[7], sum), lines$1 = lines$3, written = 0;
    for(;;){
     if(! lines$1){
      if(written === sum) return caml_string_of_bytes(buf);
      throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
     }
     var lines$2 = lines$1[2], line$0 = lines$1[1];
     caml_blit_string(line$0, 0, buf, written, caml_ml_string_length(line$0));
     var
      pos =
        caml_call2(Base_Import[91], written, caml_ml_string_length(line$0)),
      pos$0 =
        crlf
         ? (caml_bytes_unsafe_set
            (buf, pos, 13),
           caml_call2(Base_Import[91], pos, 1))
         : pos;
     caml_bytes_unsafe_set(buf, pos$0, 10);
     var
      pos$1 = caml_call2(Base_Import[91], pos$0, 1),
      lines$1 = lines$2,
      written = pos$1;
    }
   }
   function filter(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     if(! caml_call1(f, caml_string_get(t, i[1]))) break;
     i[1]++;
    }
    if(i[1] === n) return t;
    var
     _cb_ = caml_call2(Base_Import[93], n, 1),
     out = caml_call1(Base_Bytes0[7], _cb_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    i[1]++;
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_string_of_bytes(out),
       _cc_ = caml_call2(Base_Import[93], n, 1);
      return out_pos[1] === _cc_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call1(f, c)){caml_bytes_set(out, out_pos[1], c); out_pos[1]++;}
     i[1]++;
    }
   }
   function filteri(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     var _b__ = caml_string_get(t, i[1]);
     if(! caml_call2(f, i[1], _b__)) break;
     i[1]++;
    }
    if(i[1] === n) return t;
    var
     _b$_ = caml_call2(Base_Import[93], n, 1),
     out = caml_call1(Base_Bytes0[7], _b$_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    i[1]++;
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_string_of_bytes(out),
       _ca_ = caml_call2(Base_Import[93], n, 1);
      return out_pos[1] === _ca_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call2(f, i[1], c)){
      caml_bytes_set(out, out_pos[1], c);
      out_pos[1]++;
     }
     i[1]++;
    }
   }
   function chop_prefix(s, prefix){
    return is_prefix$0(s, prefix)
            ? [0, drop_prefix(s, caml_ml_string_length(prefix))]
            : 0;
   }
   function chop_prefix_if_exists(s, prefix){
    return is_prefix$0(s, prefix)
            ? drop_prefix(s, caml_ml_string_length(prefix))
            : s;
   }
   function chop_prefix_exn(s, prefix){
    var match = chop_prefix(s, prefix);
    if(! match) return caml_call4(invalid_argf, _C_, s, prefix, 0);
    var str = match[1];
    return str;
   }
   function chop_suffix(s, suffix){
    return is_suffix$0(s, suffix)
            ? [0, drop_suffix(s, caml_ml_string_length(suffix))]
            : 0;
   }
   function chop_suffix_if_exists(s, suffix){
    return is_suffix$0(s, suffix)
            ? drop_suffix(s, caml_ml_string_length(suffix))
            : s;
   }
   function chop_suffix_exn(s, suffix){
    var match = chop_suffix(s, suffix);
    if(! match) return caml_call4(invalid_argf, _D_, s, suffix, 0);
    var str = match[1];
    return str;
   }
   function shorter(a, b){
    return caml_ml_string_length(a) <= caml_ml_string_length(b) ? a : b;
   }
   function shortest(list){
    if(! list) return cst$5;
    var rest = list[2], first = list[1];
    return caml_call3(Base_List[20], rest, first, shorter);
   }
   function pos_from_left(param, i){return i;}
   function pos_from_right(t, i){
    var _b9_ = caml_call2(Base_Import[93], caml_ml_string_length(t), i);
    return caml_call2(Base_Import[93], _b9_, 1);
   }
   function common_generic2_length_loop(a, b, get_pos, max_len, len_so_far){
    var len_so_far$0 = len_so_far;
    for(;;){
     if(max_len <= len_so_far$0) return max_len;
     var
      _b7_ = caml_string_unsafe_get(b, caml_call2(get_pos, b, len_so_far$0)),
      _b8_ = caml_string_unsafe_get(a, caml_call2(get_pos, a, len_so_far$0));
     if(! caml_call2(Base_Char[16], _b8_, _b7_)) return len_so_far$0;
     var
      len_so_far$1 = caml_call2(Base_Import[91], len_so_far$0, 1),
      len_so_far$0 = len_so_far$1;
    }
   }
   function common_generic2_length(a, b, get_pos){
    var
     max_len =
       caml_call2
        (Base_Import[101], caml_ml_string_length(a), caml_ml_string_length(b));
    return common_generic2_length_loop(a, b, get_pos, max_len, 0);
   }
   function common_generic_length_loop(first, list, get_pos, max_len){
    var first$0 = first, list$0 = list, max_len$0 = max_len;
    for(;;){
     if(! list$0) return max_len$0;
     var
      rest = list$0[2],
      second = list$0[1],
      max_len$1 =
        common_generic2_length_loop(first$0, second, get_pos, max_len$0, 0),
      first$0 = second,
      list$0 = rest,
      max_len$0 = max_len$1;
    }
   }
   function common_generic_length(list, get_pos){
    if(! list) return 0;
    var
     rest = list[2],
     first = list[1],
     max_len = caml_ml_string_length(shortest(list));
    return common_generic_length_loop(first, rest, get_pos, max_len);
   }
   function common_generic2(a, b, get_pos, take){
    var len = common_generic2_length(a, b, get_pos);
    return caml_call2(take, shorter(a, b), len);
   }
   function common_generic(list, get_pos, take){
    if(! list) return cst$7;
    var
     rest = list[2],
     first = list[1],
     s = shortest(list),
     max_len = caml_ml_string_length(s);
    if(0 === max_len) return cst$6;
    var len = common_generic_length_loop(first, rest, get_pos, max_len);
    return caml_call2(take, s, len);
   }
   function common_prefix(list){
    return common_generic(list, pos_from_left, prefix);
   }
   function common_suffix(list){
    return common_generic(list, pos_from_right, suffix);
   }
   function common_prefix2(a, b){
    return common_generic2(a, b, pos_from_left, prefix);
   }
   function common_suffix2(a, b){
    return common_generic2(a, b, pos_from_right, suffix);
   }
   function common_prefix_length(list){
    return common_generic_length(list, pos_from_left);
   }
   function common_suffix_length(list){
    return common_generic_length(list, pos_from_right);
   }
   function common_prefix2_length(a, b){
    return common_generic2_length(a, b, pos_from_left);
   }
   function common_suffix2_length(a, b){
    return common_generic2_length(a, b, pos_from_right);
   }
   function pp(ppf, string){
    return caml_call3(Stdlib_Format[137], ppf, _E_, string);
   }
   function of_char(c){return caml_call2(make, 1, c);}
   function of_char_list(l){
    var
     _b5_ = caml_call1(Base_List[45], l),
     t = caml_call1(Base_Bytes0[7], _b5_);
    function _b6_(i, c){return caml_bytes_set(t, i, c);}
    caml_call2(Base_List[34], l, _b6_);
    return caml_string_of_bytes(t);
   }
   function of_array(a){
    return init
            (a.length - 1,
             function(_b4_){return caml_check_bound(a, _b4_)[1 + _b4_];});
   }
   function to_sequence(t){
    var len = caml_ml_string_length(t);
    function _b3_(pos){
     return len <= pos
             ? 0
             : [1,
               caml_string_unsafe_get(t, pos),
               caml_call2(Base_Import[91], pos, 1)];
    }
    return caml_call2(Base_Sequence[44], 0, _b3_);
   }
   function of_sequence(s){
    return of_char_list(caml_call1(Base_Sequence[20], s));
   }
   function pad_right(opt, s, len){
    if(opt) var sth = opt[1], char$0 = sth; else var char$0 = 32;
    var src_len = caml_ml_string_length(s);
    if(len <= src_len) return s;
    var res = caml_call1(Base_Bytes0[7], len);
    caml_call5(Base_Bytes0[4], s, 0, res, 0, src_len);
    var _b2_ = caml_call2(Base_Import[93], len, src_len);
    caml_call4(Base_Bytes0[15], res, src_len, _b2_, char$0);
    return caml_string_of_bytes(res);
   }
   function pad_left(opt, s, len){
    if(opt) var sth = opt[1], char$0 = sth; else var char$0 = 32;
    var src_len = caml_ml_string_length(s);
    if(len <= src_len) return s;
    var
     res = caml_call1(Base_Bytes0[7], len),
     _b0_ = caml_call2(Base_Import[93], len, src_len);
    caml_call5(Base_Bytes0[4], s, 0, res, _b0_, src_len);
    var _b1_ = caml_call2(Base_Import[93], len, src_len);
    caml_call4(Base_Bytes0[15], res, 0, _b1_, char$0);
    return caml_string_of_bytes(res);
   }
   function local_copy_prefix(src, prefix_len, buffer_len){
    var dst = caml_call1(Base_Bytes0[14], buffer_len);
    caml_blit_string(src, 0, dst, 0, prefix_len);
    return dst;
   }
   function local_copy_to_string(buf, pos){
    var str = caml_string_of_bytes(buf);
    return unsafe_sub(str, 0, pos);
   }
   function filter_mapi(src, f){
    var src_len = caml_ml_string_length(src);
    a:
    {
     var pos = 0;
     for(;;){
      if(pos === src_len) return src;
      var
       c1 = caml_string_unsafe_get(src, pos),
       src_pos$0 = caml_call1(Base_Int0[8], pos),
       option = caml_call2(f, pos, c1);
      if(! option) break a;
      var c2 = option[1];
      if(! caml_call2(Base_Char[16], c1, c2)) break;
      var pos = src_pos$0;
     }
    }
    var copy = local_copy_prefix(src, pos, src_len);
    if(option){
     var c$0 = option[1];
     caml_bytes_unsafe_set(copy, pos, c$0);
     var dst_pos$0 = src_pos$0;
    }
    else
     var dst_pos$0 = pos;
    var
     dst_pos = [0, dst_pos$0],
     _bY_ = caml_call2(Base_Import[93], src_len, 1);
    if(_bY_ >= src_pos$0){
     var src_pos = src_pos$0;
     for(;;){
      var
       match = caml_call2(f, src_pos, caml_string_unsafe_get(src, src_pos));
      if(match){
       var c = match[1];
       caml_bytes_unsafe_set(copy, dst_pos[1], c);
       dst_pos[1]++;
      }
      var _bZ_ = src_pos + 1 | 0;
      if(_bY_ === src_pos) break;
      var src_pos = _bZ_;
     }
    }
    return local_copy_to_string(copy, dst_pos[1]);
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, c){return caml_call1(f, c);});
   }
   function partition_map_difference
   (src, f, len, src_pos$0, fst_pos$0, snd_pos$0, either){
    var
     fsts = local_copy_prefix(src, fst_pos$0, len),
     snds = local_copy_prefix(src, snd_pos$0, len);
    if(0 === either[0]){
     var c$1 = either[1];
     caml_bytes_unsafe_set(fsts, fst_pos$0, c$1);
     var
      snd_pos$1 = snd_pos$0,
      fst_pos$1 = caml_call2(Base_Import[91], fst_pos$0, 1);
    }
    else{
     var c$2 = either[1];
     caml_bytes_unsafe_set(snds, snd_pos$0, c$2);
     var
      snd_pos$2 = caml_call2(Base_Import[91], snd_pos$0, 1),
      snd_pos$1 = snd_pos$2,
      fst_pos$1 = fst_pos$0;
    }
    var
     src_pos$1 = caml_call2(Base_Import[91], src_pos$0, 1),
     fst_pos = [0, fst_pos$1],
     snd_pos = [0, snd_pos$1],
     _bV_ = caml_call2(Base_Import[93], len, 1);
    if(_bV_ >= src_pos$1){
     var src_pos = src_pos$1;
     for(;;){
      var match = caml_call1(f, caml_string_unsafe_get(src, src_pos));
      if(0 === match[0]){
       var c = match[1];
       caml_bytes_unsafe_set(fsts, fst_pos[1], c);
       fst_pos[1]++;
      }
      else{
       var c$0 = match[1];
       caml_bytes_unsafe_set(snds, snd_pos[1], c$0);
       snd_pos[1]++;
      }
      var _bX_ = src_pos + 1 | 0;
      if(_bV_ === src_pos) break;
      var src_pos = _bX_;
     }
    }
    var _bW_ = local_copy_to_string(snds, snd_pos[1]);
    return [0, local_copy_to_string(fsts, fst_pos[1]), _bW_];
   }
   function partition_map(src, f){
    var len = caml_ml_string_length(src);
    if(0 === len) return _F_;
    var c1$1 = caml_string_unsafe_get(src, 0), either$1 = caml_call1(f, c1$1);
    if(0 === either$1[0]){
     var c2$1 = either$1[1];
     if(caml_call2(Base_Char[16], c1$1, c2$1)){
      var pos = 1;
      for(;;){
       if(pos === len) return [0, src, cst$8];
       var c1 = caml_string_unsafe_get(src, pos), either = caml_call1(f, c1);
       if(0 === either[0]){
        var c2 = either[1];
        if(caml_call2(Base_Char[16], c1, c2)){
         var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
         continue;
        }
       }
       return partition_map_difference(src, f, len, pos, pos, 0, either);
      }
     }
    }
    else{
     var c2$2 = either$1[1];
     if(caml_call2(Base_Char[16], c1$1, c2$2)){
      var pos$1 = 1;
      for(;;){
       if(pos$1 === len) return [0, cst$9, src];
       var
        c1$0 = caml_string_unsafe_get(src, pos$1),
        either$0 = caml_call1(f, c1$0);
       if(1 === either$0[0]){
        var c2$0 = either$0[1];
        if(caml_call2(Base_Char[16], c1$0, c2$0)){
         var pos$2 = caml_call2(Base_Import[91], pos$1, 1), pos$1 = pos$2;
         continue;
        }
       }
       return partition_map_difference(src, f, len, pos$1, 0, pos$1, either$0);
      }
     }
    }
    return partition_map_difference(src, f, len, 0, 0, 0, either$1);
   }
   function partition_tf(t, f){
    return partition_map
            (t, function(c){return caml_call1(f, c) ? [0, c] : [1, c];});
   }
   function edit_distance(s1, s2){
    if(caml_ml_string_length(s1) <= caml_ml_string_length(s2))
     var s2$0 = s2, s1$0 = s1;
    else
     var s2$0 = s1, s1$0 = s2;
    var
     _br_ = caml_call2(Base_Import[91], 1, caml_ml_string_length(s1$0)),
     _bs_ = caml_call2(Base_Import[88], 2, _br_),
     table = caml_call2(Base_Array0[5], _bs_, 0);
    function at(i, j){
     var
      _bT_ = caml_call2(Base_Import[122], j, 2),
      _bU_ = caml_call2(Base_Import[88], i, 2);
     return caml_call2(Base_Import[91], _bU_, _bT_);
    }
    var _bu_ = caml_ml_string_length(s1$0), _bt_ = 1;
    if(_bu_ >= 1){
     var i$0 = _bt_;
     for(;;){
      var _bR_ = at(i$0, 0);
      caml_check_bound(table, _bR_)[1 + _bR_] = i$0;
      var _bS_ = i$0 + 1 | 0;
      if(_bu_ === i$0) break;
      var i$0 = _bS_;
     }
    }
    var _bw_ = caml_ml_string_length(s2$0), _bv_ = 1;
    if(_bw_ >= 1){
     var j = _bv_;
     for(;;){
      var _by_ = at(0, j);
      caml_check_bound(table, _by_)[1 + _by_] = j;
      var _bA_ = caml_ml_string_length(s1$0), _bz_ = 1;
      if(_bA_ >= 1){
       var i = _bz_;
       for(;;){
        var
         _bC_ = caml_string_get(s2$0, caml_call2(Base_Import[93], j, 1)),
         _bD_ = caml_string_get(s1$0, caml_call2(Base_Import[93], i, 1));
        if(caml_call2(Base_Char[16], _bD_, _bC_)){
         var
          _bE_ = caml_call2(Base_Import[93], j, 1),
          _bF_ = at(caml_call2(Base_Import[93], i, 1), _bE_),
          _bG_ = caml_check_bound(table, _bF_)[1 + _bF_],
          _bH_ = at(i, j);
         caml_check_bound(table, _bH_)[1 + _bH_] = _bG_;
        }
        else{
         var
          _bJ_ = caml_call2(Base_Import[93], j, 1),
          _bK_ = at(caml_call2(Base_Import[93], i, 1), _bJ_),
          sub = caml_check_bound(table, _bK_)[1 + _bK_],
          _bL_ = at(caml_call2(Base_Import[93], i, 1), j),
          add = caml_check_bound(table, _bL_)[1 + _bL_],
          _bM_ = at(i, caml_call2(Base_Import[93], j, 1)),
          del = caml_check_bound(table, _bM_)[1 + _bM_],
          _bN_ = caml_call2(Base_Import[101], add, del),
          _bO_ = caml_call2(Base_Import[101], sub, _bN_),
          _bP_ = caml_call2(Base_Import[91], 1, _bO_),
          _bQ_ = at(i, j);
         caml_check_bound(table, _bQ_)[1 + _bQ_] = _bP_;
        }
        var _bI_ = i + 1 | 0;
        if(_bA_ === i) break;
        var i = _bI_;
       }
      }
      var _bB_ = j + 1 | 0;
      if(_bw_ === j) break;
      var j = _bB_;
     }
    }
    var _bx_ = at(caml_ml_string_length(s1$0), caml_ml_string_length(s2$0));
    return caml_check_bound(table, _bx_)[1 + _bx_];
   }
   function build_and_validate_escapeworth
   (escapeworthy_map, escape_char, func){
    var
     escapeworthy_map$0 =
       caml_call3
         (Base_List[137][7], escapeworthy_map, Base_Char[16], escape_char)
        ? escapeworthy_map
        : [0, [0, escape_char, escape_char], escapeworthy_map],
     arr = caml_call2(Base_Array0[4], 256, -1),
     vals = caml_call2(Base_Array0[4], 256, 0),
     param = escapeworthy_map$0;
    for(;;){
     if(! param) return [0, arr];
     var l = param[2], match = param[1], c_to = match[2], c_from = match[1];
     if(919809722 <= func)
      var v = c_from, k = caml_call1(Base_Char[32], c_to);
     else
      var k$0 = caml_call1(Base_Char[32], c_from), v = c_to, k = k$0;
     if(-1 !== caml_check_bound(arr, k)[1 + k]) break;
     var _bj_ = caml_call1(Base_Char[32], v);
     if(caml_check_bound(vals, _bj_)[1 + _bj_]) break;
     var _bp_ = caml_call1(Base_Char[32], v);
     caml_check_bound(arr, k)[1 + k] = _bp_;
     var _bq_ = caml_call1(Base_Char[32], v);
     caml_check_bound(vals, _bq_)[1 + _bq_] = 1;
     var param = l;
    }
    var
     _bk_ = caml_call2(Base_Import[147], Base_Import[138], Base_Import[138]),
     _bl_ =
       [0,
        [0,
         cst_escapeworthy_map,
         caml_call2(Base_Import[149], _bk_, escapeworthy_map$0)],
        0],
     _bm_ = [0, [0, cst_c_to, caml_call1(Base_Import[138], c_to)], _bl_],
     _bn_ = [0, [0, cst_c_from, caml_call1(Base_Import[138], c_from)], _bm_],
     _bo_ = caml_call2(Base_Sexp[10], cst_escapeworthy_map_not_one_t, _bn_);
    return caml_call1(Base_Or_error[39], _bo_);
   }
   function escape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 258914209);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var
              to_escape_len = [0, 0],
              to_escape =
                foldi
                 (src,
                  0,
                  function(i, acc, c){
                   var
                    _bi_ = caml_call1(Base_Char[32], c),
                    n = caml_check_bound(escapeworthy, _bi_)[1 + _bi_];
                   return -1 === n
                           ? acc
                           : (to_escape_len
                              [1]++,
                             [0, [0, i, caml_call1(Base_Char[35], n)], acc]);
                  });
             if(! to_escape) return src;
             var
              last_idx = caml_ml_string_length(src),
              last_dst_pos =
                caml_call2(Base_Import[91], last_idx, to_escape_len[1]),
              dst = caml_call1(Base_Bytes0[7], last_dst_pos),
              last_idx$0 = last_idx,
              last_dst_pos$0 = last_dst_pos,
              param = to_escape;
             for(;;){
              if(! param){
               caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               return caml_string_of_bytes(dst);
              }
              var
               to_escape$0 = param[2],
               match = param[1],
               escaped_char = match[2],
               last_idx$1 = match[1],
               _bg_ = caml_call2(Base_Import[93], last_idx$0, last_idx$1),
               len = caml_call2(Base_Import[93], _bg_, 1),
               dst_pos = caml_call2(Base_Import[93], last_dst_pos$0, len),
               _bh_ = caml_call2(Base_Import[91], last_idx$1, 1);
              caml_call5(Base_Bytes0[4], src, _bh_, dst, dst_pos, len);
              var last_dst_pos$1 = caml_call2(Base_Import[93], dst_pos, 2);
              caml_bytes_set(dst, last_dst_pos$1, escape_char);
              caml_bytes_set
               (dst,
                caml_call2(Base_Import[91], last_dst_pos$1, 1),
                escaped_char);
              var
               last_idx$0 = last_idx$1,
               last_dst_pos$0 = last_dst_pos$1,
               param = to_escape$0;
             }
            }];
   }
   function escape_gen_exn(escapeworthy_map, escape_char){
    var _bf_ = escape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[34], _bf_));
   }
   function escape(escapeworthy, escape_char){
    var
     _bd_ = caml_call2(Base_List[126], escapeworthy, Base_Char[17]),
     _be_ = Base_List[53],
     escapeworthy_map = caml_call2(_be_, _bd_, function(c){return [0, c, c];});
    return escape_gen_exn(escapeworthy_map, escape_char);
   }
   function unescape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 919809722);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var i = 0, status = -512962225, to_unescape = 0;
             for(;;){
              if(caml_ml_string_length(src) <= i) break;
              if(-512962225 <= status)
               var
                _a7_ = caml_string_get(src, i),
                status$0 =
                  caml_call2(Base_Char[16], _a7_, escape_char)
                   ? -767030498
                   : -512962225;
              else
               var status$0 = -244189789;
              var
               acc =
                 -512962225 <= status$0 ? to_unescape : [0, i, to_unescape],
               i$0 = caml_call2(Base_Import[91], i, 1),
               i = i$0,
               status = status$0,
               to_unescape = acc;
             }
             if(! to_unescape) return src;
             var
              to_unescape$0 = to_unescape[2],
              idx = to_unescape[1],
              _a8_ = caml_call1(Base_List[45], to_unescape),
              _a9_ =
                caml_call2(Base_Import[93], caml_ml_string_length(src), _a8_),
              dst = caml_call1(Base_Bytes0[7], _a9_);
             function loop(last_idx, last_dst_pos, param){
              var
               last_idx$0 = last_idx,
               last_dst_pos$0 = last_dst_pos,
               param$0 = param;
              for(;;){
               if(! param$0)
                return caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               var
                to_unescape = param$0[2],
                last_idx$1 = param$0[1],
                _a__ = caml_call2(Base_Import[93], last_idx$0, last_idx$1),
                len = caml_call2(Base_Import[93], _a__, 2),
                dst_pos = caml_call2(Base_Import[93], last_dst_pos$0, len),
                _a$_ = caml_call2(Base_Import[91], last_idx$1, 2);
               caml_call5(Base_Bytes0[4], src, _a$_, dst, dst_pos, len);
               var
                last_dst_pos$1 = caml_call2(Base_Import[93], dst_pos, 1),
                _ba_ =
                  caml_string_get
                   (src, caml_call2(Base_Import[91], last_idx$1, 1)),
                _bb_ = caml_call1(Base_Char[32], _ba_),
                n = caml_check_bound(escapeworthy, _bb_)[1 + _bb_],
                _bc_ =
                  -1 === n
                   ? caml_string_get
                     (src, caml_call2(Base_Import[91], last_idx$1, 1))
                   : caml_call1(Base_Char[35], n);
               caml_bytes_set(dst, last_dst_pos$1, _bc_);
               var
                last_idx$0 = last_idx$1,
                last_dst_pos$0 = last_dst_pos$1,
                param$0 = to_unescape;
              }
             }
             if
              (idx
               < caml_call2(Base_Import[93], caml_ml_string_length(src), 1))
              loop
               (caml_ml_string_length(src),
                caml_ml_bytes_length(dst),
                to_unescape);
             else
              loop
               (caml_call2(Base_Import[93], caml_ml_string_length(src), 1),
                caml_ml_bytes_length(dst),
                to_unescape$0);
             return caml_string_of_bytes(dst);
            }];
   }
   function unescape_gen_exn(escapeworthy_map, escape_char){
    var _a6_ = unescape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[34], _a6_));
   }
   function unescape(escape_char){return unescape_gen_exn(0, escape_char);}
   function preceding_escape_chars(str, escape_char, pos){
    var p$1 = caml_call2(Base_Import[93], pos, 1), p = p$1, cnt = 0;
    for(;;){
     if(0 <= p){
      var _a5_ = caml_string_get(str, p);
      if(! caml_call2(Base_Char[15], _a5_, escape_char)){
       var
        cnt$0 = caml_call2(Base_Import[91], cnt, 1),
        p$0 = caml_call2(Base_Import[93], p, 1),
        p = p$0,
        cnt = cnt$0;
       continue;
      }
     }
     return cnt;
    }
   }
   function update_escape_status(str, escape_char, i, param){
    if(-512962225 > param) return -244189789;
    var _a4_ = caml_string_get(str, i);
    return caml_call2(Base_Char[16], _a4_, escape_char)
            ? -767030498
            : -512962225;
   }
   function escape_status(str, escape_char, pos){
    var
     _a2_ = preceding_escape_chars(str, escape_char, pos),
     odd = 1 === caml_call2(Base_Import[122], _a2_, 2) ? 1 : 0,
     _a3_ = caml_string_get(str, pos),
     match = caml_call2(Base_Char[16], _a3_, escape_char);
    return odd ? -244189789 : match ? -767030498 : -512962225;
   }
   function check_bound(str, pos, function_name){
    var
     _a0_ = caml_ml_string_length(str) <= pos ? 1 : 0,
     _a1_ = _a0_ || (pos < 0 ? 1 : 0);
    return _a1_ ? caml_call3(invalid_argf, _G_, function_name, 0) : _a1_;
   }
   function is_char_escaping(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaping);
    return -512962225 <= escape_status(str, escape_char, pos) ? 0 : 1;
   }
   function is_char_escaped(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaped);
    return -244189789 <= escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function is_char_literal(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_literal);
    return -512962225 === escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function index_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_index_from);
    var
     status$1 = escape_status(str, escape_char, pos),
     i = pos,
     status = status$1;
    for(;;){
     if(pos <= i){
      var _aY_ = -512962225 === status ? 1 : 0;
      if(_aY_){
       var _aZ_ = caml_string_get(str, i);
       if(caml_call2(Base_Char[16], _aZ_, char$0)) return [0, i];
      }
     }
     var i$0 = caml_call2(Base_Import[91], i, 1);
     if(caml_ml_string_length(str) <= i$0) return 0;
     var
      status$0 = update_escape_status(str, escape_char, i$0, status),
      i = i$0,
      status = status$0;
    }
   }
   function index_from_exn$0(str, escape_char, pos, char$0){
    var match = index_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _aU_ = [0, [0, cst_char, caml_call1(Base_Import[138], char$0)], 0],
     _aV_ = [0, [0, cst_pos, caml_call1(Base_Import[139], pos)], _aU_],
     _aW_ =
       [0,
        [0, cst_escape_char, caml_call1(Base_Import[138], escape_char)],
        _aV_],
     _aX_ = [0, [0, cst_str, caml_call1(sexp_of_t, str)], _aW_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[10], cst_index_from_exn_not_found, _aX_));
   }
   function index$1(str, escape_char, char$0){
    return index_from$0(str, escape_char, 0, char$0);
   }
   function index_exn$1(str, escape_char, char$0){
    return index_from_exn$0(str, escape_char, 0, char$0);
   }
   function rindex_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_rindex_from);
    if(caml_call2(Base_Char[16], char$0, escape_char)) return 0;
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) return 0;
     var escape_chars = preceding_escape_chars(str, escape_char, pos$0);
     if(0 === caml_call2(Base_Import[122], escape_chars, 2)){
      var _aS_ = caml_string_get(str, pos$0);
      if(caml_call2(Base_Char[16], _aS_, char$0)) return [0, pos$0];
     }
     var
      _aT_ = caml_call2(Base_Import[93], pos$0, escape_chars),
      pos$1 = caml_call2(Base_Import[93], _aT_, 1),
      pos$0 = pos$1;
    }
   }
   function rindex_from_exn$0(str, escape_char, pos, char$0){
    var match = rindex_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _aO_ = [0, [0, cst_char$0, caml_call1(Base_Import[138], char$0)], 0],
     _aP_ = [0, [0, cst_pos$0, caml_call1(Base_Import[139], pos)], _aO_],
     _aQ_ =
       [0,
        [0, cst_escape_char$0, caml_call1(Base_Import[138], escape_char)],
        _aP_],
     _aR_ = [0, [0, cst_str$0, caml_call1(sexp_of_t, str)], _aQ_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[10], cst_rindex_from_exn_not_found, _aR_));
   }
   function rindex$0(str, escape_char, char$0){
    return is_empty(str)
            ? 0
            : rindex_from$0
              (str,
               escape_char,
               caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
               char$0);
   }
   function rindex_exn$0(str, escape_char, char$0){
    return rindex_from_exn$0
            (str,
             escape_char,
             caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
             char$0);
   }
   function split_gen$0(str, escape_char, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[16], c$0, c);};
    var
     len = caml_ml_string_length(str),
     acc = 0,
     status = -512962225,
     last_pos = 0,
     pos = 0;
    for(;;){
     if(pos === len){
      var
       _aM_ =
         [0,
          sub(str, last_pos, caml_call2(Base_Import[93], len, last_pos)),
          acc];
      return caml_call1(Base_List[63], _aM_);
     }
     var
      status$0 = update_escape_status(str, escape_char, pos, status),
      _aN_ = -512962225 === status$0 ? 1 : 0;
     if(_aN_ && is_delim(caml_string_get(str, pos))){
      var
       sub_str =
         sub(str, last_pos, caml_call2(Base_Import[93], pos, last_pos)),
       pos$0 = caml_call2(Base_Import[91], pos, 1),
       last_pos$0 = caml_call2(Base_Import[91], pos, 1),
       acc$0 = [0, sub_str, acc],
       acc = acc$0,
       status = status$0,
       last_pos = last_pos$0,
       pos = pos$0;
      continue;
     }
     var
      pos$1 = caml_call2(Base_Import[91], pos, 1),
      status = status$0,
      pos = pos$1;
    }
   }
   function split$0(str, on){
    var _aK_ = [0, -1044422954, on];
    return function(_aL_){return split_gen$0(str, _aL_, _aK_);};
   }
   function split_on_chars$0(str, chars){
    var _aI_ = [0, 552554919, chars];
    return function(_aJ_){return split_gen$0(str, _aJ_, _aI_);};
   }
   function split_at(str, pos){
    var
     _aF_ = caml_call2(Base_Import[93], caml_ml_string_length(str), pos),
     _aG_ = caml_call2(Base_Import[93], _aF_, 1),
     _aH_ = sub(str, caml_call2(Base_Import[91], pos, 1), _aG_);
    return [0, sub(str, 0, pos), _aH_];
   }
   function lsplit2$0(str, on, escape_char){
    function _aD_(x){return split_at(str, x);}
    var _aE_ = index$1(str, escape_char, on);
    return caml_call2(Base_Option[24], _aE_, _aD_);
   }
   function rsplit2$0(str, on, escape_char){
    function _aB_(x){return split_at(str, x);}
    var _aC_ = rindex$0(str, escape_char, on);
    return caml_call2(Base_Option[24], _aC_, _aB_);
   }
   function lsplit2_exn$0(str, on, escape_char){
    return split_at(str, index_exn$1(str, escape_char, on));
   }
   function rsplit2_exn$0(str, on, escape_char){
    return split_at(str, rindex_exn$0(str, escape_char, on));
   }
   function last_non_drop_literal(drop, escape_char, t){
    return rfindi
            (0,
             t,
             function(i, c){
              var _ay_ = 1 - caml_call1(drop, c);
              if(_ay_)
               var _az_ = _ay_;
              else{
               var _aA_ = is_char_escaping(t, escape_char, i);
               if(! _aA_) return is_char_escaped(t, escape_char, i);
               var _az_ = _aA_;
              }
              return _az_;
             });
   }
   function first_non_drop_literal(drop, escape_char, t){
    return lfindi
            (0,
             t,
             function(i, c){
              var _av_ = 1 - caml_call1(drop, c);
              if(_av_)
               var _aw_ = _av_;
              else{
               var _ax_ = is_char_escaping(t, escape_char, i);
               if(! _ax_) return is_char_escaped(t, escape_char, i);
               var _aw_ = _ax_;
              }
              return _aw_;
             });
   }
   function rstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var match = last_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$10;
    var i = match[1];
    return i === caml_call2(Base_Import[93], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[91], i, 1));
   }
   function lstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var match = first_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$11;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[93], length, 1))))
      break a;
     var match = first_non_drop_literal(drop, escape_char, t);
     if(! match) return cst$12;
     var
      first = match[1],
      match$0 = last_non_drop_literal(drop, escape_char, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
     var last = match$0[1], _au_ = caml_call2(Base_Import[93], last, first);
     return sub(t, first, caml_call2(Base_Import[91], _au_, 1));
    }
    return t;
   }
   function between$0(t, low, high){
    var _at_ = caml_call2(Base_Import[109][2], low, t);
    return _at_ ? caml_call2(Base_Import[109][2], t, high) : _at_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[109][1], t, min)
            ? min
            : caml_call2(Base_Import[109][2], t, max) ? t : max;
   }
   function clamp_exn$0(t, min, max){
    if(caml_call2(Base_Import[109][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _I_], 1);
   }
   function clamp$0(t, min, max){
    if(! caml_call2(Base_Import[109][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _aq_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _ar_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _aq_],
     _as_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _ar_);
    return caml_call1(Base_Or_error[39], _as_);
   }
   function create$0(opt, pattern){
    if(opt)
     var sth = opt[1], case_sensitive = sth;
    else
     var case_sensitive = 1;
    return create(pattern, case_sensitive);
   }
   function Make_utf(Format){
    var
     codec_name = Format[1],
     is_valid = Format[3],
     raise_get_message =
       [246,
        function(_ap_){
         return caml_call3(Base_Printf[2], _J_, Format[2], Format[1]);
        }];
    function raise_get(t, pos){
     var
      _am_ =
        [0,
         [0, cst$13, [0, t]],
         [0, [0, cst_pos$1, caml_call1(Base_Import[139], pos)], 0]],
      _an_ = runtime.caml_obj_tag(raise_get_message);
     a:
     if(250 === _an_)
      var _ao_ = raise_get_message[1];
     else{
      if(246 !== _an_ && 244 !== _an_){var _ao_ = raise_get_message; break a;}
      var _ao_ = caml_call1(CamlinternalLazy[2], raise_get_message);
     }
     return caml_call1(raise_s, caml_call2(Base_Sexp[10], _ao_, _am_));
    }
    function get(t, byte_pos){
     var decode = caml_call2(Format[5], t, byte_pos);
     return caml_call1(Base_Uchar0[18], decode)
             ? caml_call1(Base_Uchar0[19], decode)
             : raise_get(t, byte_pos);
    }
    function to_string(_al_){return _al_;}
    function of_string_unchecked(_ak_){return _ak_;}
    var
     raise_of_string_message =
       caml_call2
        (concat,
         0,
         [0, Format[2], [0, cst_of_string_invalid, [0, codec_name, 0]]]);
    function raise_of_string(string){
     return caml_call1
             (raise_s,
              caml_call2
               (Base_Sexp[10],
                raise_of_string_message,
                [0, [0, cst$14, [0, string]], 0]));
    }
    function of_string(string){
     return caml_call1(is_valid, string) ? string : raise_of_string(string);
    }
    var
     include = caml_call1(Base_Sexpable[5], [0, of_string, to_string]),
     t_sexp_grammar = include[1],
     t_of_sexp = include[2],
     sexp_of_t = include[3],
     compare = Base_Import[109][9];
    function hash(_aj_){return runtime.Base_hash_string(_aj_);}
    var
     module_name = Format[2],
     include$0 =
       caml_call1
        (Base_Identifiable[1],
         [0,
          compare,
          hash_fold_t,
          hash,
          t_of_sexp,
          sexp_of_t,
          of_string,
          to_string,
          module_name]),
     hash_fold_t$0 = include$0[1],
     hash$0 = include$0[2],
     t_of_sexp$0 = include$0[3],
     sexp_of_t$0 = include$0[4],
     of_string$0 = include$0[5],
     to_string$0 = include$0[6],
     symbol = include$0[7],
     symbol$0 = include$0[8],
     symbol$1 = include$0[9],
     symbol$2 = include$0[10],
     symbol$3 = include$0[11],
     symbol$4 = include$0[12],
     equal = include$0[13],
     compare$0 = include$0[14],
     min = include$0[15],
     max = include$0[16],
     ascending = include$0[17],
     descending = include$0[18],
     between = include$0[19],
     clamp_exn = include$0[20],
     clamp = include$0[21],
     comparator = include$0[22],
     pp = include$0[23],
     hashable = include$0[24];
    function to_sequence(t){
     var len = caml_ml_string_length(t);
     function _ag_(byte_pos){
      if(len <= byte_pos) return 0;
      var
       decode = caml_call2(Format[5], t, byte_pos),
       _ah_ = caml_call1(Base_Uchar0[20], decode),
       _ai_ = caml_call2(Base_Import[91], byte_pos, _ah_);
      return [0, [0, caml_call1(Base_Uchar0[19], decode), _ai_]];
     }
     return caml_call2(Base_Sequence[45], 0, _ag_);
    }
    function fold(t, acc, f){
     var len = caml_ml_string_length(t), byte_pos = 0, acc$0 = acc;
     for(;;){
      if(byte_pos === len) return acc$0;
      var
       decode = caml_call2(Format[5], t, byte_pos),
       acc$1 = caml_call2(f, acc$0, caml_call1(Base_Uchar0[19], decode)),
       _af_ = caml_call1(Base_Uchar0[20], decode),
       byte_pos$0 = caml_call2(Base_Import[91], byte_pos, _af_),
       byte_pos = byte_pos$0,
       acc$0 = acc$1;
     }
    }
    function sanitize(t){
     var
      len =
        fold
         (t,
          0,
          function(pos, uchar){
           var _ae_ = caml_call1(Format[4], uchar);
           return caml_call2(Base_Import[91], pos, _ae_);
          }),
      bytes = caml_call1(Base_Bytes0[7], len),
      pos =
        fold
         (t,
          0,
          function(pos, uchar){
           var _ad_ = caml_call3(Format[6], bytes, pos, uchar);
           return caml_call2(Base_Import[91], pos, _ad_);
          });
     if(pos === len) return caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _K_], 1);
    }
    function of_list(uchars){
     function _$_(n, u){
      var _ac_ = caml_call1(Format[4], u);
      return caml_call2(Base_Import[91], n, _ac_);
     }
     var
      len = caml_call3(Base_List[20], uchars, 0, _$_),
      bytes = caml_call1(Base_Bytes0[7], len);
     function _aa_(pos, uchar){
      var _ab_ = caml_call3(Format[6], bytes, pos, uchar);
      return caml_call2(Base_Import[91], pos, _ab_);
     }
     var pos = caml_call3(Base_List[20], uchars, 0, _aa_);
     if(pos === len) return caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    }
    function of_array(uchars){
     var
      len = [0, 0],
      _S_ = caml_call2(Base_Import[93], uchars.length - 1, 1),
      _R_ = 0;
     if(_S_ >= 0){
      var i$0 = _R_;
      for(;;){
       var
        _Y_ = caml_check_bound(uchars, i$0)[1 + i$0],
        _Z_ = caml_call1(Format[4], _Y_);
       len[1] = caml_call2(Base_Import[91], len[1], _Z_);
       var ___ = i$0 + 1 | 0;
       if(_S_ === i$0) break;
       var i$0 = ___;
      }
     }
     var
      bytes = caml_call1(Base_Bytes0[7], len[1]),
      pos = [0, 0],
      _U_ = caml_call2(Base_Import[93], uchars.length - 1, 1),
      _T_ = 0;
     if(_U_ >= 0){
      var i = _T_;
      for(;;){
       var
        _V_ = caml_check_bound(uchars, i)[1 + i],
        _W_ = caml_call3(Format[6], bytes, pos[1], _V_);
       pos[1] = caml_call2(Base_Import[91], pos[1], _W_);
       var _X_ = i + 1 | 0;
       if(_U_ === i) break;
       var i = _X_;
      }
     }
     if(pos[1] === len[1]) return caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
    }
    function concat$0(list){return caml_call2(concat, _N_, list);}
    function split(t, on){
     var len = caml_ml_string_length(t), until = 0, start$1 = 0;
     for(;;){
      if(until === len)
       return [0,
               sub(t, start$1, caml_call2(Base_Import[93], until, start$1)),
               0];
      var
       uchar = get(t, until),
       _P_ = caml_call1(Format[4], uchar),
       until$0 = caml_call2(Base_Import[91], until, _P_);
      if(caml_call2(Base_Uchar0[11], uchar, on)) break;
      var until = until$0;
     }
     var
      block =
        [0,
         sub(t, start$1, caml_call2(Base_Import[93], until, start$1)),
         24029],
      dst = block,
      offset = 1,
      start = until$0,
      until$1 = until$0;
     for(;;){
      if(until$1 === len){
       dst[1 + offset] =
        [0, sub(t, start, caml_call2(Base_Import[93], until$1, start)), 0];
       return block;
      }
      var
       uchar$0 = get(t, until$1),
       _Q_ = caml_call1(Format[4], uchar$0),
       start$0 = caml_call2(Base_Import[91], until$1, _Q_);
      if(caml_call2(Base_Uchar0[11], uchar$0, on)){
       var
        dst$0 =
          [0,
           sub(t, start, caml_call2(Base_Import[93], until$1, start)),
           24029];
       dst[1 + offset] = dst$0;
       var dst = dst$0, offset = 1, start = start$0, until$1 = start$0;
      }
      else
       var until$1 = start$0;
     }
    }
    var
     C =
       caml_call1
        (Base_Indexed_container[12],
         [0,
          [0, Base_Uchar0[11]],
          of_list,
          of_array,
          concat$0,
          fold,
          -304398144,
          -304398144,
          -304398144,
          -304398144,
          348729712,
          -637740141]),
     append = C[3],
     concat_map = C[8],
     concat_mapi = C[39],
     count = C[20],
     counti = C[32],
     exists = C[18],
     existsi = C[30],
     filter = C[6],
     filter_map = C[7],
     filter_mapi = C[38],
     filteri = C[37],
     find = C[22],
     find_map = C[23],
     find_mapi = C[34],
     findi = C[33],
     fold_result = C[16],
     fold_until = C[17],
     foldi = C[28],
     for_all = C[19],
     for_alli = C[31],
     init = C[35],
     is_empty = C[13],
     iter = C[14],
     iteri = C[29],
     length = C[12],
     map = C[5],
     mapi = C[36],
     max_elt = C[27],
     mem = C[11],
     min_elt = C[26],
     partition_map = C[10],
     partition_tf = C[9],
     sum = C[21],
     to_array = C[25],
     to_list = C[24];
    return [0,
            codec_name,
            is_valid,
            ,
            ,
            get,
            of_string_unchecked,
            ,
            ,
            t_sexp_grammar,
            hash_fold_t$0,
            hash$0,
            t_of_sexp$0,
            sexp_of_t$0,
            of_string$0,
            to_string$0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            ascending,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator,
            pp,
            hashable,
            to_sequence,
            fold,
            sanitize,
            of_list,
            of_array,
            concat$0,
            split,
            ,
            append,
            concat_map,
            concat_mapi,
            count,
            counti,
            exists,
            existsi,
            filter,
            filter_map,
            filter_mapi,
            filteri,
            find,
            find_map,
            find_mapi,
            findi,
            fold_result,
            fold_until,
            foldi,
            for_all,
            for_alli,
            init,
            is_empty,
            iter,
            iteri,
            length,
            map,
            mapi,
            max_elt,
            mem,
            min_elt,
            partition_map,
            partition_tf,
            sum,
            to_array,
            to_list,
            length];
   }
   var
    byte_length = Base_Uchar0[16],
    set = Base_Bytes0[8],
    Utf8 =
      Make_utf
       ([0,
         codec_name,
         module_name,
         is_valid_utf_8,
         byte_length,
         get_utf_8_uchar,
         set]),
    byte_length$0 = Base_Uchar0[17],
    set$0 = Base_Bytes0[9],
    Utf16le =
      Make_utf
       ([0,
         codec_name$0,
         module_name$0,
         is_valid_utf_16le,
         byte_length$0,
         get_utf_16le_uchar,
         set$0]),
    byte_length$1 = Base_Uchar0[17],
    set$1 = Base_Bytes0[10],
    Utf16be =
      Make_utf
       ([0,
         codec_name$1,
         module_name$1,
         is_valid_utf_16be,
         byte_length$1,
         get_utf_16be_uchar,
         set$1]);
   function Make_utf32(Format){
    function byte_length(param){return 4;}
    var
     codec_name = Format[1],
     module_name = Format[2],
     set = Format[4],
     get_decode_result = Format[3];
    function is_valid(t){
     var len = caml_ml_string_length(t);
     if(0 !== caml_call2(Base_Import[122], len, 4)) return 0;
     var byte_pos = 0;
     for(;;){
      if(byte_pos >= len) return 1;
      var
       result = caml_call2(Format[3], t, byte_pos),
       _O_ = caml_call1(Base_Uchar0[18], result);
      if(! _O_) return _O_;
      var
       byte_pos$0 = caml_call2(Base_Import[91], byte_pos, 4),
       byte_pos = byte_pos$0;
     }
    }
    return Make_utf
            ([0,
              codec_name,
              module_name,
              is_valid,
              byte_length,
              get_decode_result,
              set]);
   }
   var
    set$2 = Base_Bytes0[12],
    Utf32le =
      Make_utf32([0, codec_name$2, module_name$2, get_utf_32le_uchar, set$2]),
    set$3 = Base_Bytes0[13],
    Utf32be =
      Make_utf32([0, codec_name$3, module_name$3, get_utf_32be_uchar, set$3]),
    include$1 = Base_Import[109],
    symbol$6 = include$1[1],
    symbol$7 = include$1[2],
    symbol$8 = include$1[3],
    symbol$9 = include$1[4],
    symbol$10 = include$1[5],
    symbol$11 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    compare_local$0 = include$1[10],
    equal$1 = include$1[11],
    equal_local$0 = include$1[12],
    max$0 = include$1[13],
    min$0 = include$1[14],
    Base_String =
      [0,
       globalize,
       t_sexp_grammar,
       sub,
       unsafe_sub,
       subo,
       of_char_list,
       of_array,
       symbol,
       map,
       filter,
       filter_map,
       partition_tf,
       partition_map,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$11,
       symbol$7,
       symbol$9,
       symbol$10,
       symbol$6,
       symbol$8,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator,
       pp,
       hashable,
       compare_local$0,
       invariant,
       max_length,
       mem,
       make,
       symbol,
       concat,
       escaped,
       contains,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       [0,
        hash_fold_t$0,
        hash$0,
        t_of_sexp$0,
        sexp_of_t$2,
        t_sexp_grammar$0,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$5,
        equal$0,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator$0,
        compare_local,
        is_suffix,
        is_prefix,
        is_substring$0,
        is_substring_at,
        substr_index$0,
        substr_index_exn$0,
        substr_index_all$0,
        substr_replace_first$0,
        substr_replace_all$0],
       index,
       index_exn,
       index_from,
       index_from_exn,
       rindex,
       rindex_exn,
       rindex_from,
       rindex_from_exn,
       to_sequence,
       of_sequence,
       [0,
        sexp_of_t$0,
        create$0,
        pattern,
        case_sensitive,
        matches,
        index$0,
        index_exn$0,
        index_all,
        replace_first,
        replace_all,
        split_on,
        [0, equal, equal_local, sexp_of_t$1, representation]],
       substr_index,
       substr_index_exn,
       substr_index_all,
       substr_replace_first,
       substr_replace_all,
       is_substring,
       is_substring_at$0,
       to_list_rev,
       rev,
       is_suffix$0,
       is_prefix$0,
       lsplit2_exn,
       rsplit2_exn,
       lsplit2,
       rsplit2,
       split,
       split_on_chars,
       split_lines,
       lfindi,
       rfindi,
       lstrip,
       rstrip,
       strip,
       concat_map,
       concat_mapi,
       tr,
       tr_multi,
       chop_suffix_exn,
       chop_prefix_exn,
       chop_suffix,
       chop_prefix,
       chop_suffix_if_exists,
       chop_prefix_if_exists,
       suffix,
       prefix,
       drop_suffix,
       drop_prefix,
       common_suffix,
       common_prefix,
       common_suffix_length,
       common_prefix_length,
       common_suffix2,
       common_prefix2,
       common_suffix2_length,
       common_prefix2_length,
       concat_array,
       concat_lines,
       equal$1,
       equal_local$0,
       of_char,
       of_char_list,
       pad_left,
       pad_right,
       edit_distance,
       [0,
        escape_gen_exn,
        escape_gen,
        escape,
        unescape_gen_exn,
        unescape_gen,
        unescape,
        is_char_escaping,
        is_char_escaped,
        is_char_literal,
        index$1,
        index_exn$1,
        rindex$0,
        rindex_exn$0,
        index_from$0,
        index_from_exn$0,
        rindex_from$0,
        rindex_from_exn$0,
        split$0,
        split_on_chars$0,
        lsplit2$0,
        lsplit2_exn$0,
        rsplit2$0,
        rsplit2_exn$0,
        lstrip_literal,
        rstrip_literal,
        strip_literal],
       [0,
        Utf8[9],
        Utf8[10],
        Utf8[11],
        Utf8[12],
        Utf8[13],
        Utf8[14],
        Utf8[15],
        Utf8[16],
        Utf8[17],
        Utf8[18],
        Utf8[19],
        Utf8[20],
        Utf8[21],
        Utf8[22],
        Utf8[23],
        Utf8[24],
        Utf8[25],
        Utf8[26],
        Utf8[27],
        Utf8[28],
        Utf8[29],
        Utf8[30],
        Utf8[31],
        Utf8[32],
        Utf8[33],
        Utf8[37],
        Utf8[38],
        Utf8[42],
        Utf8[39],
        Utf8[67],
        Utf8[49],
        Utf8[50],
        Utf8[43],
        Utf8[73],
        Utf8[72],
        Utf8[70],
        Utf8[63],
        Utf8[64],
        Utf8[35],
        Utf8[57],
        Utf8[58],
        Utf8[47],
        Utf8[60],
        Utf8[45],
        Utf8[74],
        Utf8[53],
        Utf8[54],
        Utf8[76],
        Utf8[75],
        Utf8[71],
        Utf8[69],
        Utf8[59],
        Utf8[65],
        Utf8[48],
        Utf8[61],
        Utf8[46],
        Utf8[56],
        Utf8[55],
        Utf8[62],
        Utf8[68],
        Utf8[52],
        Utf8[51],
        Utf8[44],
        Utf8[34],
        Utf8[2],
        Utf8[36],
        Utf8[5],
        Utf8[6],
        Utf8[40],
        Utf8[1],
        Utf8[77],
        Utf8[66]],
       [0,
        Utf16le[9],
        Utf16le[10],
        Utf16le[11],
        Utf16le[12],
        Utf16le[13],
        Utf16le[14],
        Utf16le[15],
        Utf16le[16],
        Utf16le[17],
        Utf16le[18],
        Utf16le[19],
        Utf16le[20],
        Utf16le[21],
        Utf16le[22],
        Utf16le[23],
        Utf16le[24],
        Utf16le[25],
        Utf16le[26],
        Utf16le[27],
        Utf16le[28],
        Utf16le[29],
        Utf16le[30],
        Utf16le[31],
        Utf16le[32],
        Utf16le[33],
        Utf16le[37],
        Utf16le[38],
        Utf16le[42],
        Utf16le[39],
        Utf16le[67],
        Utf16le[49],
        Utf16le[50],
        Utf16le[43],
        Utf16le[73],
        Utf16le[72],
        Utf16le[70],
        Utf16le[63],
        Utf16le[64],
        Utf16le[35],
        Utf16le[57],
        Utf16le[58],
        Utf16le[47],
        Utf16le[60],
        Utf16le[45],
        Utf16le[74],
        Utf16le[53],
        Utf16le[54],
        Utf16le[76],
        Utf16le[75],
        Utf16le[71],
        Utf16le[69],
        Utf16le[59],
        Utf16le[65],
        Utf16le[48],
        Utf16le[61],
        Utf16le[46],
        Utf16le[56],
        Utf16le[55],
        Utf16le[62],
        Utf16le[68],
        Utf16le[52],
        Utf16le[51],
        Utf16le[44],
        Utf16le[34],
        Utf16le[2],
        Utf16le[36],
        Utf16le[5],
        Utf16le[6],
        Utf16le[40],
        Utf16le[1],
        Utf16le[77],
        Utf16le[66]],
       [0,
        Utf16be[9],
        Utf16be[10],
        Utf16be[11],
        Utf16be[12],
        Utf16be[13],
        Utf16be[14],
        Utf16be[15],
        Utf16be[16],
        Utf16be[17],
        Utf16be[18],
        Utf16be[19],
        Utf16be[20],
        Utf16be[21],
        Utf16be[22],
        Utf16be[23],
        Utf16be[24],
        Utf16be[25],
        Utf16be[26],
        Utf16be[27],
        Utf16be[28],
        Utf16be[29],
        Utf16be[30],
        Utf16be[31],
        Utf16be[32],
        Utf16be[33],
        Utf16be[37],
        Utf16be[38],
        Utf16be[42],
        Utf16be[39],
        Utf16be[67],
        Utf16be[49],
        Utf16be[50],
        Utf16be[43],
        Utf16be[73],
        Utf16be[72],
        Utf16be[70],
        Utf16be[63],
        Utf16be[64],
        Utf16be[35],
        Utf16be[57],
        Utf16be[58],
        Utf16be[47],
        Utf16be[60],
        Utf16be[45],
        Utf16be[74],
        Utf16be[53],
        Utf16be[54],
        Utf16be[76],
        Utf16be[75],
        Utf16be[71],
        Utf16be[69],
        Utf16be[59],
        Utf16be[65],
        Utf16be[48],
        Utf16be[61],
        Utf16be[46],
        Utf16be[56],
        Utf16be[55],
        Utf16be[62],
        Utf16be[68],
        Utf16be[52],
        Utf16be[51],
        Utf16be[44],
        Utf16be[34],
        Utf16be[2],
        Utf16be[36],
        Utf16be[5],
        Utf16be[6],
        Utf16be[40],
        Utf16be[1],
        Utf16be[77],
        Utf16be[66]],
       [0,
        Utf32le[9],
        Utf32le[10],
        Utf32le[11],
        Utf32le[12],
        Utf32le[13],
        Utf32le[14],
        Utf32le[15],
        Utf32le[16],
        Utf32le[17],
        Utf32le[18],
        Utf32le[19],
        Utf32le[20],
        Utf32le[21],
        Utf32le[22],
        Utf32le[23],
        Utf32le[24],
        Utf32le[25],
        Utf32le[26],
        Utf32le[27],
        Utf32le[28],
        Utf32le[29],
        Utf32le[30],
        Utf32le[31],
        Utf32le[32],
        Utf32le[33],
        Utf32le[37],
        Utf32le[38],
        Utf32le[42],
        Utf32le[39],
        Utf32le[67],
        Utf32le[49],
        Utf32le[50],
        Utf32le[43],
        Utf32le[73],
        Utf32le[72],
        Utf32le[70],
        Utf32le[63],
        Utf32le[64],
        Utf32le[35],
        Utf32le[57],
        Utf32le[58],
        Utf32le[47],
        Utf32le[60],
        Utf32le[45],
        Utf32le[74],
        Utf32le[53],
        Utf32le[54],
        Utf32le[76],
        Utf32le[75],
        Utf32le[71],
        Utf32le[69],
        Utf32le[59],
        Utf32le[65],
        Utf32le[48],
        Utf32le[61],
        Utf32le[46],
        Utf32le[56],
        Utf32le[55],
        Utf32le[62],
        Utf32le[68],
        Utf32le[52],
        Utf32le[51],
        Utf32le[44],
        Utf32le[34],
        Utf32le[2],
        Utf32le[36],
        Utf32le[5],
        Utf32le[6],
        Utf32le[40],
        Utf32le[1],
        Utf32le[77],
        Utf32le[66]],
       [0,
        Utf32be[9],
        Utf32be[10],
        Utf32be[11],
        Utf32be[12],
        Utf32be[13],
        Utf32be[14],
        Utf32be[15],
        Utf32be[16],
        Utf32be[17],
        Utf32be[18],
        Utf32be[19],
        Utf32be[20],
        Utf32be[21],
        Utf32be[22],
        Utf32be[23],
        Utf32be[24],
        Utf32be[25],
        Utf32be[26],
        Utf32be[27],
        Utf32be[28],
        Utf32be[29],
        Utf32be[30],
        Utf32be[31],
        Utf32be[32],
        Utf32be[33],
        Utf32be[37],
        Utf32be[38],
        Utf32be[42],
        Utf32be[39],
        Utf32be[67],
        Utf32be[49],
        Utf32be[50],
        Utf32be[43],
        Utf32be[73],
        Utf32be[72],
        Utf32be[70],
        Utf32be[63],
        Utf32be[64],
        Utf32be[35],
        Utf32be[57],
        Utf32be[58],
        Utf32be[47],
        Utf32be[60],
        Utf32be[45],
        Utf32be[74],
        Utf32be[53],
        Utf32be[54],
        Utf32be[76],
        Utf32be[75],
        Utf32be[71],
        Utf32be[69],
        Utf32be[59],
        Utf32be[65],
        Utf32be[48],
        Utf32be[61],
        Utf32be[46],
        Utf32be[56],
        Utf32be[55],
        Utf32be[62],
        Utf32be[68],
        Utf32be[52],
        Utf32be[51],
        Utf32be[44],
        Utf32be[34],
        Utf32be[2],
        Utf32be[36],
        Utf32be[5],
        Utf32be[6],
        Utf32be[40],
        Utf32be[1],
        Utf32be[77],
        Utf32be[66]]];
   runtime.caml_register_global(114, Base_String, "Base__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes
//# unitInfo: Requires: Base__Array0, Base__Blit, Base__Bytes0, Base__Bytes_intf, Base__Bytes_tr, Base__Char, Base__Comparator, Base__Import, Base__List, Base__Or_error, Base__Ordered_collection_common, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Staged, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Bytes",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Array0 = global_data.Base__Array0,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Staged = global_data.Base__Staged,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Blit = global_data.Base__Blit,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    stage = Base_Staged[1],
    globalize = Base_Import[288],
    t_of_sexp = Base_Import[161],
    sexp_of_t = Base_Import[137],
    t_sexp_grammar = Base_Import[183],
    max_length = Base_Bytes0[2],
    compare = Base_Bytes0[5],
    copy = Base_Bytes0[6],
    create = Base_Bytes0[7],
    set_uchar_utf_8 = Base_Bytes0[8],
    set_uchar_utf_16le = Base_Bytes0[9],
    set_uchar_utf_16be = Base_Bytes0[10],
    set_uchar_utf_32le = Base_Bytes0[12],
    set_uchar_utf_32be = Base_Bytes0[13],
    create_local = Base_Bytes0[14],
    fill = Base_Bytes0[15],
    make = Base_Bytes0[16],
    map = Base_Bytes0[17],
    mapi = Base_Bytes0[18],
    to_string = Base_Bytes0[20],
    of_string = Base_Bytes0[21],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _c_ = [0, "src/bytes.ml", 130, 2],
    cst_tr_multi_replacement_is_th =
      "tr_multi: replacement is the empty string",
    _b_ = [0, [11, "Bytes.init ", [4, 0, 0, 0, 0]], "Bytes.init %d"],
    _a_ = [0, [3, 0, 0], "%S"];
   function pp(fmt, t){
    var _y_ = caml_call1(to_string, t);
    return caml_call3(Stdlib_Format[137], fmt, _a_, _y_);
   }
   function create$0(len){return caml_call1(create, len);}
   var
    To_bytes =
      caml_call1
       (Base_Blit[1],
        [0, caml_ml_bytes_length, create$0, runtime.caml_blit_bytes]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    comparator = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t])[1],
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes);
   function create$1(len){return caml_call1(create, len);}
   var
    length = caml_ml_bytes_length,
    unsafe_blit$0 = runtime.caml_blit_string,
    length$0 = caml_ml_string_length,
    From_string =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length$0]),
        [0, length, create$1, unsafe_blit$0]);
   function invariant(param){return 0;}
   function init(n, f){
    if(n < 0) caml_call3(Base_Printf[7], _b_, n, 0);
    var
     t = caml_call1(create, n),
     _w_ = caml_call2(Base_Import[93], n, 1),
     _v_ = 0;
    if(_w_ >= 0){
     var i = _v_;
     for(;;){
      caml_bytes_unsafe_set(t, i, caml_call1(f, i));
      var _x_ = i + 1 | 0;
      if(_w_ === i) break;
      var i = _x_;
     }
    }
    return t;
   }
   function of_char_list(l){
    var t = caml_call1(create, caml_call1(Base_List[45], l));
    function _u_(i, c){return runtime.caml_bytes_set(t, i, c);}
    caml_call2(Base_List[34], l, _u_);
    return t;
   }
   function to_list(t){
    var
     i$1 = caml_call2(Base_Import[93], caml_ml_bytes_length(t), 1),
     i = i$1,
     acc = 0;
    for(;;){
     if(0 > i) return acc;
     var
      acc$0 = [0, caml_bytes_unsafe_get(t, i), acc],
      i$0 = caml_call2(Base_Import[93], i, 1),
      i = i$0,
      acc = acc$0;
    }
   }
   function to_array(t){
    function _t_(i){return caml_bytes_unsafe_get(t, i);}
    return caml_call2(Base_Array0[12], caml_ml_bytes_length(t), _t_);
   }
   function map$0(t, f){return caml_call2(map, t, f);}
   function mapi$0(t, f){return caml_call2(mapi, t, f);}
   function fold(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call2(f, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[91], pos, 1),
      pos = pos$0,
      acc = acc$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call3(f, pos, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[91], pos, 1),
      pos = pos$0,
      acc = acc$0;
    }
   }
   function tr(target, replacement, s){
    var
     _r_ = caml_call2(Base_Import[93], caml_ml_bytes_length(s), 1),
     _q_ = 0;
    if(_r_ >= 0){
     var i = _q_;
     for(;;){
      if(caml_call2(Base_Char[16], caml_bytes_unsafe_get(s, i), target))
       caml_bytes_unsafe_set(s, i, replacement);
      var _s_ = i + 1 | 0;
      if(_r_ === i) break;
      var i = _s_;
     }
    }
    return 0;
   }
   function tr_multi(target, replacement){
    if(0 === caml_ml_string_length(target))
     return caml_call1(stage, function(_p_){return 0;});
    if(0 === caml_ml_string_length(replacement))
     return caml_call1(Base_Import[126], cst_tr_multi_replacement_is_th);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_o_){return 0;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              var
               _m_ = caml_call2(Base_Import[93], caml_ml_bytes_length(s), 1),
               _l_ = 0;
              if(_m_ >= 0){
               var i = _l_;
               for(;;){
                caml_bytes_unsafe_set
                 (s,
                  i,
                  runtime.caml_string_unsafe_get
                   (tr_map,
                    caml_call1(Base_Char[32], caml_bytes_unsafe_get(s, i))));
                var _n_ = i + 1 | 0;
                if(_m_ === i) break;
                var i = _n_;
               }
              }
              return 0;
             });
   }
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[110][2], low, t);
    return _k_ ? caml_call2(Base_Import[110][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[110][1], t, min)
            ? min
            : caml_call2(Base_Import[110][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[110][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[110][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[39], _j_);
   }
   function contains(pos, len, t, char$0){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1],
         pos,
         len,
         0,
         caml_ml_bytes_length(t)),
     len$0 = match[2],
     pos$0 = match[1],
     last = caml_call2(Base_Import[91], pos$0, len$0),
     i = pos$0;
    for(;;){
     var _d_ = i < last ? 1 : 0;
     if(_d_){
      var
       _e_ = caml_bytes_get(t, i),
       _f_ = caml_call2(Base_Char[16], _e_, char$0);
      if(! _f_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _g_ = _f_;
     }
     else
      var _g_ = _d_;
     return _g_;
    }
   }
   var
    Utf8 = [0, set_uchar_utf_8],
    Utf16le = [0, set_uchar_utf_16le],
    Utf16be = [0, set_uchar_utf_16be],
    Utf32le = [0, set_uchar_utf_32le],
    Utf32be = [0, set_uchar_utf_32be],
    include$0 = Base_Import[110],
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    ascending = include$0[7],
    descending = include$0[8],
    compare$0 = include$0[9],
    compare_local = include$0[10],
    equal = include$0[11],
    equal_local = include$0[12],
    max = include$0[13],
    min = include$0[14],
    Base_Bytes =
      [0,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       blit,
       blito,
       unsafe_blit,
       sub,
       subo,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local,
       of_string,
       to_string,
       pp$0,
       invariant,
       To_string,
       From_string,
       create,
       create_local,
       make,
       map$0,
       mapi$0,
       copy,
       init,
       of_char_list,
       caml_bytes_get,
       fill,
       tr,
       tr_multi,
       to_list,
       to_array,
       fold,
       foldi,
       contains,
       max_length,
       Utf8,
       Utf16le,
       Utf16be,
       Utf32le,
       Utf32be];
   runtime.caml_register_global(24, Base_Bytes, "Base__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hex_lexer
//# unitInfo: Requires: Stdlib__Lexing
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    ocaml_lex_tables =
      [0,
       "\0\0\0\0\x01\0\x01\0\x02\0\x1b\0R\0i\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x01\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\x01\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\x06\0\x04\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x04\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\x02\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\x01\0\x03\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\x03\0\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       cst,
       cst,
       cst,
       cst,
       cst,
       cst],
    Stdlib_Lexing = global_data.Stdlib__Lexing;
   function parse_hex(lexbuf){
    var ocaml_lex_state = 0;
    for(;;){
     var
      ocaml_lex_state$0 =
        caml_call3
         (Stdlib_Lexing[20], ocaml_lex_tables, ocaml_lex_state, lexbuf);
     if(0 === ocaml_lex_state$0){
      var
       body =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 3 | 0, lexbuf[6]);
      return [0, body];
     }
     if(1 === ocaml_lex_state$0){
      var
       body$0 =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 2 | 0, lexbuf[6]);
      return [1, body$0];
     }
     caml_call1(lexbuf[1], lexbuf);
     var ocaml_lex_state = ocaml_lex_state$0;
    }
   }
   var Base_Hex_lexer = [0, parse_hex];
   runtime.caml_register_global(2, Base_Hex_lexer, "Base__Hex_lexer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_string_conversions
//# unitInfo: Requires: Base__Bytes, Base__Char, Base__Hex_lexer, Base__Import, Base__Option, Base__Printf, Base__Sexp, Base__Sexpable, Base__String, Stdlib__Lexing
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_0b$1 = "0b",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Base_Hex_lexer = global_data.Base__Hex_lexer,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Bytes = global_data.Base__Bytes,
    Base_Sexp = global_data.Base__Sexp,
    cst_0b$0 = cst_0b$1,
    cst_0b = cst_0b$1,
    cst_0 = "0",
    _a_ =
      [0,
       [2, 0, [11, ".of_string: invalid input ", [3, 0, 0]]],
       "%s.of_string: invalid input %S"],
    cst_0x = "-0x",
    cst_0x$0 = "0x";
   function insert_delimiter_every(input, delimiter, chars_per_delimiter){
    var input_length = runtime.caml_ml_string_length(input);
    if(input_length <= chars_per_delimiter) return input;
    var match = caml_string_get(input, 0);
    a:
    {
     if(43 !== match && 45 !== match){var has_sign = 0; break a;}
     var has_sign = 1;
    }
    var
     num_digits =
       has_sign ? caml_call2(Base_Import[93], input_length, 1) : input_length,
     _A_ = caml_call2(Base_Import[93], num_digits, 1),
     num_delimiters = caml_call2(Base_Import[95], _A_, chars_per_delimiter),
     output_length = caml_call2(Base_Import[91], input_length, num_delimiters),
     output = caml_call1(Base_Bytes[34], output_length),
     input_pos = [0, caml_call2(Base_Import[93], input_length, 1)],
     output_pos = [0, caml_call2(Base_Import[93], output_length, 1)],
     num_chars_until_delimiter = [0, chars_per_delimiter],
     first_digit_pos = has_sign ? 1 : 0;
    for(;;){
     if(first_digit_pos > input_pos[1]){
      if(has_sign) caml_bytes_set(output, 0, caml_string_get(input, 0));
      return runtime.caml_string_of_bytes(output);
     }
     if(0 === num_chars_until_delimiter[1]){
      caml_bytes_set(output, output_pos[1], delimiter);
      output_pos[1] += -1;
      num_chars_until_delimiter[1] = chars_per_delimiter;
     }
     var _B_ = caml_string_get(input, input_pos[1]);
     caml_bytes_set(output, output_pos[1], _B_);
     input_pos[1] += -1;
     output_pos[1] += -1;
     num_chars_until_delimiter[1] += -1;
    }
   }
   function insert_delimiter(input, delimiter){
    return insert_delimiter_every(input, delimiter, 3);
   }
   function insert_underscores(input){return insert_delimiter(input, 95);}
   var sexp_of_int_style = Base_Sexp[20];
   function _b_(_j_){
    var
     func = _j_[6],
     hash_fold_t = _j_[5],
     compare_local = _j_[2],
     _k_ = _j_[12],
     _l_ = _j_[13],
     _m_ = _j_[11],
     _n_ = _j_[10],
     _o_ = _j_[9],
     _p_ = _j_[8],
     _q_ = _j_[7],
     _r_ = _j_[4];
    function compare(a, b){return caml_call2(compare_local, a, b);}
    function hash(x){return caml_call1(func, x);}
    function to_string_suffix(t){
     if(caml_call2(_r_, t, _l_))
      var bits = 0;
     else
      var
       _u_ = caml_call1(_q_, t),
       bits = caml_call2(Base_Import[93], _m_, _u_);
     if(0 === bits) return cst_0;
     function _v_(char_index){
      var
       _w_ = caml_call2(Base_Import[93], bits, char_index),
       bit_index = caml_call2(Base_Import[93], _w_, 1),
       bit = caml_call2(_o_, caml_call2(_p_, t, bit_index), _k_),
       _x_ = caml_call1(_n_, bit),
       _y_ = caml_call1(Base_Char[32], 48),
       _z_ = caml_call2(Base_Import[91], _y_, _x_);
      return caml_call1(Base_Char[35], _z_);
     }
     return caml_call2(Base_String[36], bits, _v_);
    }
    function to_string(t){
     var _t_ = to_string_suffix(t);
     return caml_call2(Base_Import[112], cst_0b, _t_);
    }
    function to_string_hum(opt, t){
     if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
     var _s_ = insert_delimiter_every(to_string_suffix(t), delimiter, 4);
     return caml_call2(Base_Import[112], cst_0b$0, _s_);
    }
    function sexp_of_t(t){return [0, to_string_hum(0, t)];}
    return [0,
            [0,
             sexp_of_t,
             compare,
             compare_local,
             hash_fold_t,
             hash,
             to_string,
             to_string_hum]];
   }
   function _c_(I){
    var compare_local = I[2];
    function compare(a, b){return caml_call2(compare_local, a, b);}
    var hash_fold_t = I[3], func = I[4];
    function hash(x){return caml_call1(func, x);}
    var chars_per_delimiter = 4;
    function to_string(delimiter, t){
     if(delimiter)
      var
       delimiter$0 = delimiter[1],
       make_suffix =
         function(t){
          return insert_delimiter_every
                  (caml_call1(I[5], t), delimiter$0, chars_per_delimiter);
         };
     else
      var make_suffix = I[5];
     if(caml_call2(I[8], t, I[7])){
      var _h_ = caml_call1(make_suffix, caml_call1(I[9], t));
      return caml_call2(Base_Import[112], cst_0x, _h_);
     }
     var _i_ = caml_call1(make_suffix, t);
     return caml_call2(Base_Import[112], cst_0x$0, _i_);
    }
    function to_string$0(t){return to_string(0, t);}
    function to_string_hum(opt, t){
     if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
     return to_string([0, delimiter], t);
    }
    function invalid(str){
     return caml_call4(Base_Printf[6], _a_, I[10], str, 0);
    }
    function of_string_with_delimiter(str){
     function _f_(c){return caml_call2(Base_Char[15], c, 95);}
     var _g_ = caml_call2(Base_String[10], str, _f_);
     return caml_call1(I[6], _g_);
    }
    function of_string(str){
     var lex = caml_call2(Stdlib_Lexing[3], 0, str);
     function _d_(param){return caml_call1(Base_Hex_lexer[1], lex);}
     var result = caml_call1(Base_Option[47], _d_);
     if(lex[6] !== lex[3]) return invalid(str);
     if(! result) return invalid(str);
     var match = result[1];
     if(0 === match[0]){
      var body = match[1], _e_ = of_string_with_delimiter(body);
      return caml_call1(I[9], _e_);
     }
     var body$0 = match[1];
     return of_string_with_delimiter(body$0);
    }
    var
     include = caml_call1(Base_Sexpable[5], [0, of_string, to_string$0]),
     t_sexp_grammar = include[1],
     t_of_sexp = include[2],
     sexp_of_t = include[3];
    return [0,
            [0,
             t_of_sexp,
             sexp_of_t,
             t_sexp_grammar,
             compare,
             compare_local,
             hash_fold_t,
             hash,
             of_string,
             to_string$0,
             to_string_hum]];
   }
   var
    Base_Int_string_conversions =
      [0,
       function(I){
        var chars_per_delimiter = 3;
        function to_string_hum(opt, t){
         if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
         return insert_delimiter_every
                 (caml_call1(I[1], t), delimiter, chars_per_delimiter);
        }
        function sexp_of_t(t){
         var
          s = caml_call1(I[1], t),
          s$0 =
            1009018843 <= sexp_of_int_style[1]
             ? s
             : insert_delimiter_every(s, 95, chars_per_delimiter);
         return [0, s$0];
        }
        return [0, to_string_hum, sexp_of_t];
       },
       _c_,
       _b_,
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores];
   runtime.caml_register_global
    (16, Base_Int_string_conversions, "Base__Int_string_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Popcount
//# unitInfo: Requires: Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    m1 = runtime.caml_int64_create_lo_mi_hi(5592405, 5592405, 21845),
    m2 = runtime.caml_int64_create_lo_mi_hi(3355443, 3355443, 13107),
    m4 = runtime.caml_int64_create_lo_mi_hi(986895, 986895, 3855),
    h01 = runtime.caml_int64_create_lo_mi_hi(65793, 65793, 257),
    mask = runtime.caml_int64_create_lo_mi_hi(16777215, 255, 0),
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Assert_failure = global_data.Assert_failure,
    _b_ = [0, "src/popcount.ml", 45, 9];
   function int64_popcount(x){
    var
     x$0 =
       runtime.caml_int64_sub
        (x, caml_int64_and(caml_int64_shift_right_unsigne(x, 1), m1)),
     x$1 =
       caml_int64_add
        (caml_int64_and(x$0, m2),
         caml_int64_and(caml_int64_shift_right_unsigne(x$0, 2), m2)),
     x$2 =
       caml_int64_and
        (caml_int64_add(x$1, caml_int64_shift_right_unsigne(x$1, 4)), m4);
    return runtime.caml_int64_to_int32
            (caml_int64_shift_right_unsigne
              (runtime.caml_int64_mul(x$2, h01), 56));
   }
   function int32_popcount(x){
    return int64_popcount(caml_int64_and(caml_int64_of_int32(x), mask));
   }
   var _a_ = Stdlib_Nativeint[9];
   if(32 === _a_)
    var nativeint_popcount = function(x){return int32_popcount(x);};
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var
     nativeint_popcount =
       function(x){return int64_popcount(caml_int64_of_int32(x));};
   }
   var
    Base_Popcount =
      [0,
       function(_c_){return runtime.Base_int_math_int_popcount(_c_);},
       int32_popcount,
       int64_popcount,
       nativeint_popcount];
   runtime.caml_register_global(8, Base_Popcount, "Base__Popcount");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign
//# unitInfo: Requires: Base__Identifiable, Base__Import, Base__Sign0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Sign0 = global_data.Base__Sign0,
    Base_Identifiable = global_data.Base__Identifiable,
    t_sexp_grammar = Base_Sign0[3],
    compare_local = Base_Sign0[4],
    all = Base_Sign0[7],
    Replace_polymorphic_compare = Base_Sign0[8],
    to_int = Base_Sign0[11],
    of_int = Base_Sign0[14],
    _a_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         Base_Sign0[5],
         Base_Sign0[6],
         Base_Sign0[12],
         Base_Sign0[1],
         Base_Sign0[2],
         Base_Sign0[9],
         Base_Sign0[10],
         Base_Sign0[13]]),
    hash_fold_t = _a_[1],
    hash = _a_[2],
    t_of_sexp = _a_[3],
    sexp_of_t = _a_[4],
    of_string = _a_[5],
    to_string = _a_[6],
    between = _a_[19],
    clamp_exn = _a_[20],
    clamp = _a_[21],
    comparator = _a_[22],
    pp = _a_[23],
    hashable = _a_[24],
    cst_negative = "negative",
    cst_zero = "zero",
    cst_positive = "positive";
   function to_string_hum(param){
    switch(param){
      case 0:
       return cst_negative;
      case 1:
       return cst_zero;
      default: return cst_positive;
    }
   }
   function to_float(param){
    switch(param){case 0: return -1.;case 1: return 0.;default: return 1.;
    }
   }
   function flip(param){
    switch(param){case 0: return 2;case 1: return 1;default: return 0;
    }
   }
   function symbol(t$0, t){
    var _b_ = caml_call1(to_int, t), _c_ = caml_call1(to_int, t$0);
    return caml_call1(of_int, caml_call2(Base_Import[88], _c_, _b_));
   }
   var
    symbol$0 = Replace_polymorphic_compare[1],
    symbol$1 = Replace_polymorphic_compare[2],
    symbol$2 = Replace_polymorphic_compare[3],
    symbol$3 = Replace_polymorphic_compare[4],
    symbol$4 = Replace_polymorphic_compare[5],
    symbol$5 = Replace_polymorphic_compare[6],
    ascending = Replace_polymorphic_compare[7],
    descending = Replace_polymorphic_compare[8],
    compare = Replace_polymorphic_compare[9],
    equal = Replace_polymorphic_compare[10],
    equal_local = Replace_polymorphic_compare[11],
    max = Replace_polymorphic_compare[12],
    min = Replace_polymorphic_compare[13],
    Base_Sign =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$5,
       symbol$1,
       symbol$3,
       symbol$4,
       symbol$0,
       symbol$2,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       compare_local,
       equal_local,
       to_string_hum,
       of_int,
       to_int,
       to_float,
       flip,
       symbol];
   runtime.caml_register_global(9, Base_Sign, "Base__Sign");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int0, Base__Int_conversions, Base__Int_intf, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Sign, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_x = "%x",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_div = runtime.caml_div,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int.Hex",
    module_name$0 = "Base.Int",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Float0 = global_data.Base__Float0,
    Base_Int0 = global_data.Base__Int0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Int_math = global_data.Base__Int_math,
    Base_Error = global_data.Base__Error,
    Base_Sign = global_data.Base__Sign,
    Base_Popcount = global_data.Base__Popcount,
    to_string = Base_Int0[1],
    of_string = Base_Int0[2],
    of_string_opt = Base_Int0[3],
    globalize = Base_Import[284],
    hash_fold_t = Base_Import[206],
    func = Base_Import[220],
    _u_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    _t_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    cst_Int_ceil_log2_got_invalid_ = "[Int.ceil_log2] got invalid input",
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    _g_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _f_ = [0, "src/int.ml", 111, 2],
    _e_ = [0, [4, 6, 0, 0, 0], cst_x],
    _d_ = [0, [4, 6, 0, 0, 0], cst_x],
    _b_ =
      [0,
       [11,
        "Int.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int.of_float: argument (%f) is out of range or NaN"],
    _a_ = [0, [11, "Int.of_string: ", [3, 0, 0]], "Int.of_string: %S"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[163],
    sexp_of_t = Base_Import[139],
    t_sexp_grammar = Base_Import[185],
    hashable = [0, hash, caml_int_compare, sexp_of_t],
    compare = caml_int_compare;
   function of_string$0(s){
    try{var _aL_ = caml_call1(of_string, s); return _aL_;}
    catch(_aM_){return caml_call3(Base_Printf[6], _a_, s, 0);}
   }
   var
    num_bits = Base_Int_conversions[30],
    float_lower_bound = caml_call1(Base_Float0[26], num_bits),
    float_upper_bound = caml_call1(Base_Float0[24], num_bits);
   function to_float(_aK_){return _aK_;}
   function of_float_unchecked(_aJ_){return _aJ_ | 0;}
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound) return f | 0;
    var _aI_ = caml_call1(Base_Float0[29], f);
    return caml_call3(Base_Printf[7], _b_, _aI_, 0);
   }
   var
    comparator = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t])[1],
    _c_ = caml_call1(Base_Comparable[14], [0, compare, sexp_of_t, 0]),
    is_positive = _c_[1],
    is_non_negative = _c_[2],
    is_negative = _c_[3],
    is_non_positive = _c_[4],
    include = caml_call1(Base_Int_string_conversions[1], [0, to_string]),
    to_string_hum = include[1],
    sexp_of_t$0 = include[2],
    compare_local = Base_Import[256],
    zero = 0,
    one = 1,
    minus_one = -1;
   function compare$0(a, b){return caml_call2(compare_local, a, b);}
   var hash_fold_t$0 = Base_Import[206], func$0 = Base_Import[220];
   function hash$0(x){return caml_call1(func$0, x);}
   var neg = Base_Import[113];
   function symbol(_aH_, _aG_){return _aH_ < _aG_ ? 1 : 0;}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$1(s){
    function _aE_(_aF_){return _aF_;}
    return caml_call3(Stdlib_Scanf[5], s, _e_, _aE_);
   }
   var
    include$0 =
      caml_call1
       (Base_Int_string_conversions[2],
        [0,
         compare$0,
         compare_local,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$1,
         zero,
         symbol,
         neg,
         module_name]),
    Hex = include$0[1],
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$1[1];
   function invariant(param){return 0;}
   function between(t, low, high){
    var _aC_ = low <= t ? 1 : 0, _aD_ = _aC_ ? t <= high ? 1 : 0 : _aC_;
    return _aD_;
   }
   function clamp_unchecked(t, min, max){
    var _aB_ = caml_call2(Base_Import[97][4], t, max);
    return caml_call1(caml_call1(Base_Import[97][3], min), _aB_);
   }
   function clamp_exn(t, min, max){
    if(min <= max) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(max >= min) return [0, clamp_unchecked(t, min, max)];
    var
     _ay_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _az_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _ay_],
     _aA_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _az_);
    return caml_call1(Base_Or_error[39], _aA_);
   }
   function pred(i){return caml_call2(Base_Import[93], i, 1);}
   function succ(i){return caml_call2(Base_Import[91], i, 1);}
   function to_int(i){return i;}
   function of_int_exn(i){return i;}
   var
    max_value = Base_Import[85][19],
    min_value = Base_Import[85][20],
    of_int32 = Base_Int_conversions[6],
    of_int32_exn = Base_Int_conversions[7],
    to_int32 = Base_Int_conversions[1],
    to_int32_exn = Base_Int_conversions[2],
    of_int64 = Base_Int_conversions[12],
    of_int64_exn = Base_Int_conversions[13],
    to_int64 = Base_Int_conversions[4],
    of_nativeint = Base_Int_conversions[23],
    of_nativeint_exn = Base_Int_conversions[24],
    to_nativeint = Base_Int_conversions[5],
    max_value_30_bits = 1073741823;
   function abs(x){return caml_call1(Base_Import[123], x);}
   function rem(a, b){return caml_call2(Base_Import[122], a, b);}
   function incr(_ax_){_ax_[1]++; return 0;}
   function decr(_aw_){_aw_[1] += -1; return 0;}
   function shift_right(a, b){return caml_call2(Base_Import[115], a, b);}
   function shift_right_logical(a, b){
    return caml_call2(Base_Import[120], a, b);
   }
   function shift_left(a, b){return caml_call2(Base_Import[119], a, b);}
   function bit_not(a){return caml_call1(Base_Import[117], a);}
   function bit_or(a, b){return caml_call2(Base_Import[118], a, b);}
   function bit_and(a, b){return caml_call2(Base_Import[116], a, b);}
   function bit_xor(a, b){return caml_call2(Base_Import[121], a, b);}
   var pow = Base_Int_math[2][1];
   function symbol$0(b, e){return caml_call2(pow, b, e);}
   var raise_s = Base_Error[32];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _g_, 0);
   }
   function ceil_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     x$0 = caml_call2(Base_Import[93], x, 1),
     _aq_ = caml_call2(Base_Import[120], x$0, 1),
     x$1 = caml_call2(Base_Import[118], x$0, _aq_),
     _ar_ = caml_call2(Base_Import[120], x$1, 2),
     x$2 = caml_call2(Base_Import[118], x$1, _ar_),
     _as_ = caml_call2(Base_Import[120], x$2, 4),
     x$3 = caml_call2(Base_Import[118], x$2, _as_),
     _at_ = caml_call2(Base_Import[120], x$3, 8),
     x$4 = caml_call2(Base_Import[118], x$3, _at_),
     _au_ = caml_call2(Base_Import[120], x$4, 16),
     x$5 = caml_call2(Base_Import[118], x$4, _au_),
     _av_ = caml_call2(Base_Import[120], x$5, 32),
     x$6 = caml_call2(Base_Import[118], x$5, _av_);
    return caml_call2(Base_Import[91], x$6, 1);
   }
   function floor_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     _aj_ = caml_call2(Base_Import[120], x, 1),
     x$0 = caml_call2(Base_Import[118], x, _aj_),
     _ak_ = caml_call2(Base_Import[120], x$0, 2),
     x$1 = caml_call2(Base_Import[118], x$0, _ak_),
     _al_ = caml_call2(Base_Import[120], x$1, 4),
     x$2 = caml_call2(Base_Import[118], x$1, _al_),
     _am_ = caml_call2(Base_Import[120], x$2, 8),
     x$3 = caml_call2(Base_Import[118], x$2, _am_),
     _an_ = caml_call2(Base_Import[120], x$3, 16),
     x$4 = caml_call2(Base_Import[118], x$3, _an_),
     _ao_ = caml_call2(Base_Import[120], x$4, 32),
     x$5 = caml_call2(Base_Import[118], x$4, _ao_),
     _ap_ = caml_call2(Base_Import[120], x$5, 1);
    return caml_call2(Base_Import[93], x$5, _ap_);
   }
   function is_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var _ai_ = caml_call2(Base_Import[93], x, 1);
    return 0 === caml_call2(Base_Import[116], x, _ai_) ? 1 : 0;
   }
   function floor_log2(i){
    if(i <= 0){
     var _af_ = [0, [0, cst, caml_call1(Base_Import[139], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int_floor_log2_got_invalid, _af_));
    }
    var
     _ag_ = runtime.Base_int_math_int_clz(i),
     _ah_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _ah_, _ag_);
   }
   function ceil_log2(i){
    if(i <= 0){
     var _ad_ = [0, [0, cst$0, caml_call1(Base_Import[139], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int_ceil_log2_got_invalid_, _ad_));
    }
    if(1 === i) return 0;
    var
     _ae_ = runtime.Base_int_math_int_clz(caml_call2(Base_Import[93], i, 1));
    return caml_call2(Base_Import[93], num_bits, _ae_);
   }
   var
    sign = Base_Sign[30],
    popcount = Base_Popcount[1],
    compare_local$0 = Base_Import[256];
   function compare$1(a, b){return caml_call2(compare_local$0, a, b);}
   var equal_local = Base_Import[270];
   function equal(a, b){return caml_call2(equal_local, a, b);}
   var hash_fold_t$1 = Base_Import[206], func$1 = Base_Import[220];
   function hash$1(x){return caml_call1(func$1, x);}
   var land = Base_Import[116], lsr = Base_Import[120];
   function clz(_ac_){return runtime.Base_int_math_int_clz(_ac_);}
   var
    Binary =
      caml_call1
        (Base_Int_string_conversions[3],
         [0,
          compare$1,
          compare_local$0,
          equal,
          equal_local,
          hash_fold_t$1,
          hash$1,
          clz,
          lsr,
          land,
          to_int,
          num_bits,
          one,
          zero])
       [1];
   function _h_(_ab_){return - _ab_ | 0;}
   function _i_(_aa_, _$_){return _aa_ !== _$_ ? 1 : 0;}
   function _j_(___, _Z_){return ___ < _Z_ ? 1 : 0;}
   function _k_(_Y_, _X_){return _X_ < _Y_ ? 1 : 0;}
   function _l_(_W_, _V_){return _W_ === _V_ ? 1 : 0;}
   function _m_(_U_, _T_){return _U_ <= _T_ ? 1 : 0;}
   function _n_(_S_, _R_){return _R_ <= _S_ ? 1 : 0;}
   function _o_(_Q_){return - _Q_ | 0;}
   var _p_ = caml_div, _q_ = runtime.caml_mul;
   function _r_(_P_, _O_){return _P_ - _O_ | 0;}
   var
    _s_ =
      [0,
       of_float,
       to_float,
       of_string$0,
       to_string,
       function(_N_, _M_){return _N_ + _M_ | 0;},
       _r_,
       _q_,
       _p_,
       _o_,
       _n_,
       _m_,
       _l_,
       _k_,
       _j_,
       _i_,
       abs,
       _h_,
       zero,
       of_int_exn,
       rem],
    F = caml_call1(Base_Int_math[1], _s_),
    round = F[4],
    round_towards_zero = F[5],
    round_down = F[6],
    round_up = F[7],
    round_nearest = F[8];
   function symbol$1(x, y){
    if(y <= 0){
     var _K_ = caml_call1(to_string, y), _L_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _t_, _L_, _K_, 0);
    }
    var rval = rem(x, y);
    return rval < 0 ? rval + y | 0 : rval;
   }
   function symbol$2(x, y){
    if(y <= 0){
     var _I_ = caml_call1(to_string, y), _J_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _u_, _J_, _I_, 0);
    }
    return x < 0 ? caml_div(x + 1 | 0, y) - 1 | 0 : caml_div(x, y);
   }
   function symbol$3(x, y){return caml_call2(Base_Import[96], x, y);}
   var
    lnot = Base_Import[117],
    include$2 = Base_Import[97],
    ascending = include$2[1],
    descending = include$2[2],
    max = include$2[3],
    min = include$2[4],
    _v_ = [0, [0, F[1], F[2], F[3]]],
    _w_ = [0, symbol$0, lnot, abs, zero, symbol$1, symbol$2, symbol$3];
   function _x_(_H_){return runtime.Base_int_math_int_ctz(_H_);}
   function _y_(_G_){return runtime.Base_int_math_int_clz(_G_);}
   function _z_(_F_, _E_){return _F_ === _E_ ? 1 : 0;}
   var
    _A_ = caml_int_compare,
    _B_ = caml_int_compare,
    Base_Int =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string$0,
       to_string,
       function(_D_, _C_){return _D_ === _C_ ? 1 : 0;},
       _B_,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       _A_,
       _z_,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       _y_,
       _x_,
       _w_,
       symbol$0,
       lnot,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       max_value_30_bits,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_int64,
       of_nativeint,
       to_nativeint,
       _v_];
   runtime.caml_register_global(34, Base_Int, "Base__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys
//# unitInfo: Requires: Base__Sys0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    backend_type = Base_Sys0[1],
    interactive = Base_Sys0[2],
    os_type = Base_Sys0[3],
    unix = Base_Sys0[4],
    win32 = Base_Sys0[5],
    cygwin = Base_Sys0[6],
    word_size_in_bits = Base_Sys0[7],
    int_size_in_bits = Base_Sys0[8],
    big_endian = Base_Sys0[9],
    max_string_length = Base_Sys0[10],
    max_array_length = Base_Sys0[11],
    runtime_variant = Base_Sys0[12],
    runtime_parameters = Base_Sys0[13],
    argv = Base_Sys0[14],
    get_argv = Base_Sys0[15],
    ocaml_version = Base_Sys0[16],
    enable_runtime_warnings = Base_Sys0[17],
    runtime_warnings_enabled = Base_Sys0[18],
    getenv_exn = Base_Sys0[20],
    getenv = Base_Sys0[21],
    Base_Sys =
      [0,
       get_argv,
       argv,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       backend_type,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv,
       getenv_exn];
   runtime.caml_register_global(1, Base_Sys, "Base__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_local
//# unitInfo: Requires: Base__Sys, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Heap = "Heap",
    cst_Immediate = "Immediate",
    cst_Stack = "Stack",
    cst_heap = "heap",
    cst_immediate = "immediate",
    cst_stack = "stack",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "obj_local.ml.stack_or_heap",
    Base_Sys = global_data.Base__Sys,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, cst_Immediate],
    _b_ = [0, cst_Stack],
    _c_ = [0, cst_Heap];
   function size(t){return t.length - 1;}
   function stack_or_heap_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _e_ = sexp_004[1];
      b:
      if(caml_string_notequal(_e_, cst_Heap)){
       c:
       if(caml_string_notequal(_e_, cst_Immediate)){
        if(caml_string_notequal(_e_, cst_Stack)){
         if(! caml_string_notequal(_e_, cst_heap)) break b;
         if(! caml_string_notequal(_e_, cst_immediate)) break c;
         if(caml_string_notequal(_e_, cst_stack)) break a;
        }
        return 1;
       }
       return 0;
      }
      return 2;
     }
     var _f_ = sexp_004[1];
     if(! _f_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_003, sexp_004);
     var _g_ = _f_[1];
     if(0 !== _g_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_003, sexp_004);
     var _h_ = _g_[1];
     b:
     if(caml_string_notequal(_h_, cst_Heap)){
      c:
      if(caml_string_notequal(_h_, cst_Immediate)){
       if(caml_string_notequal(_h_, cst_Stack)){
        if(! caml_string_notequal(_h_, cst_heap)) break b;
        if(! caml_string_notequal(_h_, cst_immediate)) break c;
        if(caml_string_notequal(_h_, cst_stack)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_003, sexp_004);
   }
   function sexp_of_stack_or_heap(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var compare_stack_or_heap = runtime.caml_int_compare;
   function stack_or_heap(repr){
    if(typeof repr === "number") return 0;
    var _d_ = Base_Sys[8];
    return typeof _d_ === "number"
            ? _d_ ? 2 : runtime.caml_dummy_obj_is_stack(repr) ? 1 : 2
            : 2;
   }
   var
    Base_Obj_local =
      [0,
       size,
       sexp_of_stack_or_heap,
       stack_or_heap_of_sexp,
       compare_stack_or_heap,
       stack_or_heap];
   runtime.caml_register_global(18, Base_Obj_local, "Base__Obj_local");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_array
//# unitInfo: Requires: Base__Array0, Base__Blit, Base__Import, Base__Int0, Base__String0, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Assert_failure = global_data.Assert_failure,
    Base_Blit = global_data.Base__Blit,
    _b_ = [0, ">", 0],
    cst_Obj_array_t_of_length = "<Obj_array.t of length ",
    _c_ = [0, ""],
    _a_ = [0, "src/obj_array.ml", 12, 2];
   function invariant(t){
    var _t_ = Stdlib_Obj[17];
    if(caml_obj_tag(t) !== _t_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function length(_s_){return _s_.length - 1;}
   function sexp_of_t(t){
    var
     _r_ =
       [0,
        cst_Obj_array_t_of_length,
        [0, caml_call1(Base_Int0[1], t.length - 1), _b_]];
    return [0, caml_call2(Base_String0[20], _c_, _r_)];
   }
   var zero_obj = 0;
   function create_zero(len){
    return caml_call2(Base_Array0[4], len, zero_obj);
   }
   var empty = [0];
   function get(t, i){return caml_check_bound(t, i)[1 + i];}
   function unsafe_get(t, i){return t[1 + i];}
   function unsafe_set_with_caml_modify(t, i, obj){t[1 + i] = obj; return 0;}
   function set_with_caml_modify(t, i, obj){
    caml_check_bound(t, i)[1 + i] = obj;
    return 0;
   }
   function unsafe_set_int_assuming_curren(t, i, int$0){t[1 + i] = int$0; return 0;
   }
   function set(t, i, obj){
    var old_obj = get(t, i);
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _q_ = 1 - (old_obj === obj ? 1 : 0);
    return _q_ ? unsafe_set_with_caml_modify(t, i, obj) : _q_;
   }
   function unsafe_set(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _p_ = 1 - (old_obj === obj ? 1 : 0);
    return _p_ ? unsafe_set_with_caml_modify(t, i, obj) : _p_;
   }
   function unsafe_set_omit_phys_equal_che(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    return unsafe_set_with_caml_modify(t, i, obj);
   }
   function swap(t, i, j){
    var a = get(t, i), b = get(t, j);
    unsafe_set(t, i, b);
    return unsafe_set(t, j, a);
   }
   function create(len, x){
    if(typeof x !== "number"){
     var _l_ = Stdlib_Obj[16];
     if(caml_obj_tag(x) === _l_){
      var
       t = create_zero(len),
       _n_ = caml_call2(Base_Import[93], len, 1),
       _m_ = 0;
      if(_n_ >= 0){
       var i = _m_;
       for(;;){
        unsafe_set_with_caml_modify(t, i, x);
        var _o_ = i + 1 | 0;
        if(_n_ === i) break;
        var i = _o_;
       }
      }
      return t;
     }
    }
    return caml_call2(Base_Array0[4], len, x);
   }
   function singleton(obj){return create(1, obj);}
   function unsafe_set_assuming_currently_(t, i, obj){
    return typeof obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, obj)
            : unsafe_set_with_caml_modify(t, i, obj);
   }
   function unsafe_set_int(t, i, int$0){
    var old_obj = t[1 + i];
    return typeof old_obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, int$0)
            : unsafe_set_with_caml_modify(t, i, int$0);
   }
   function unsafe_clear_if_pointer(t, i){
    var old_obj = t[1 + i], _k_ = 1 - (typeof old_obj === "number" ? 1 : 0);
    return _k_ ? unsafe_set_with_caml_modify(t, i, 0) : _k_;
   }
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    if(dst_pos < src_pos){
     var _e_ = caml_call2(Base_Import[93], len, 1), _d_ = 0;
     if(_e_ >= 0){
      var i = _d_;
      for(;;){
       var _f_ = src[1 + caml_call2(Base_Import[91], src_pos, i)];
       unsafe_set(dst, caml_call2(Base_Import[91], dst_pos, i), _f_);
       var _g_ = i + 1 | 0;
       if(_e_ === i) break;
       var i = _g_;
      }
     }
     return 0;
    }
    var _h_ = caml_call2(Base_Import[93], len, 1);
    if(_h_ >= 0){
     var i$0 = _h_;
     for(;;){
      var _i_ = src[1 + caml_call2(Base_Import[91], src_pos, i$0)];
      unsafe_set(dst, caml_call2(Base_Import[91], dst_pos, i$0), _i_);
      var _j_ = i$0 - 1 | 0;
      if(0 === i$0) break;
      var i$0 = _j_;
     }
    }
    return 0;
   }
   var
    include = caml_call1(Base_Blit[1], [0, length, create_zero, unsafe_blit]),
    blit = include[1],
    blito = include[2],
    unsafe_blit$0 = include[3],
    subo = include[5];
   function copy(src){
    var dst = create_zero(src.length - 1);
    caml_call6(blito, src, 0, 0, dst, 0, 0);
    return dst;
   }
   var
    sub = Base_Array0[15],
    Base_Obj_array =
      [0,
       sexp_of_t,
       blit,
       blito,
       unsafe_blit$0,
       subo,
       invariant,
       create,
       create_zero,
       copy,
       singleton,
       empty,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       set_with_caml_modify,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       unsafe_clear_if_pointer,
       sub];
   runtime.caml_register_global(12, Base_Obj_array, "Base__Obj_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uniform_array
//# unitInfo: Requires: Base__Array, Base__Binary_searchable, Base__Blit, Base__Container, Base__Import, Base__Int, Base__List, Base__Obj_array, Base__Option, Base__Sexpable, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_uniform_array_ml = "src/uniform_array.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Int = global_data.Base__Int,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Obj_array = global_data.Base__Obj_array,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Blit = global_data.Base__Blit,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    empty = Base_Obj_array[11],
    _b_ = [0, cst_src_uniform_array_ml, 347, 6],
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Uniform_array_init = "Uniform_array.init",
    _a_ = [0, cst_src_uniform_array_ml, 80, 2];
   function unsafe_create_uninitialized(len){
    return caml_call1(Base_Obj_array[8], len);
   }
   function create_obj_array(len){return caml_call1(Base_Obj_array[8], len);}
   function create(len, x){return caml_call2(Base_Obj_array[7], len, x);}
   function singleton(x){return caml_call1(Base_Obj_array[10], x);}
   function swap(t, i, j){return caml_call3(Base_Obj_array[17], t, i, j);}
   function get(arr, i){return caml_call2(Base_Obj_array[13], arr, i);}
   function set(arr, i, x){return caml_call3(Base_Obj_array[15], arr, i, x);}
   function unsafe_get_local(arr, i){
    return caml_call2(Base_Obj_array[14], arr, i);
   }
   function unsafe_get(arr, i){return unsafe_get_local(arr, i);}
   function unsafe_set(arr, i, x){
    return caml_call3(Base_Obj_array[16], arr, i, x);
   }
   function unsafe_set_int(arr, i, x){
    return caml_call3(Base_Obj_array[21], arr, i, x);
   }
   function unsafe_set_int_assuming_curren(arr, i, x){return caml_call3(Base_Obj_array[20], arr, i, x);
   }
   function unsafe_set_assuming_currently_(arr, i, x){return caml_call3(Base_Obj_array[19], arr, i, x);
   }
   function unsafe_to_array_inplace_promis(arr){return arr;}
   var
    length = Base_Obj_array[12],
    unsafe_blit = Base_Obj_array[4],
    copy = Base_Obj_array[9];
   function unsafe_set_omit_phys_equal_che(t, i, x){return caml_call3(Base_Obj_array[22], t, i, x);
   }
   function unsafe_set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[23], t, i, x);
   }
   function set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[18], t, i, x);
   }
   var unsafe_clear_if_pointer = Base_Obj_array[24], sub = Base_Obj_array[25];
   function invariant(t){
    var _aq_ = Stdlib_Obj[17];
    if(runtime.caml_obj_tag(t) !== _aq_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function init(l, f){
    if(0 > l) return caml_call1(Base_Import[126], cst_Uniform_array_init);
    var
     res = unsafe_create_uninitialized(l),
     _ao_ = caml_call2(Base_Import[93], l, 1),
     _an_ = 0;
    if(_ao_ >= 0){
     var i = _an_;
     for(;;){
      unsafe_set(res, i, caml_call1(f, i));
      var _ap_ = i + 1 | 0;
      if(_ao_ === i) break;
      var i = _ap_;
     }
    }
    return res;
   }
   function of_array(arr){
    return init(arr.length - 1, function(_am_){return arr[1 + _am_];});
   }
   function map(a, f){
    function _al_(i){return caml_call1(f, unsafe_get(a, i));}
    return init(caml_call1(length, a), _al_);
   }
   function mapi(a, f){
    function _ak_(i){return caml_call2(f, i, unsafe_get(a, i));}
    return init(caml_call1(length, a), _ak_);
   }
   function iter(a, f){
    var
     _ah_ = caml_call1(length, a),
     _ai_ = caml_call2(Base_Import[93], _ah_, 1),
     _ag_ = 0;
    if(_ai_ >= 0){
     var i = _ag_;
     for(;;){
      caml_call1(f, unsafe_get(a, i));
      var _aj_ = i + 1 | 0;
      if(_ai_ === i) break;
      var i = _aj_;
     }
    }
    return 0;
   }
   function iteri(a, f){
    var
     _ad_ = caml_call1(length, a),
     _ae_ = caml_call2(Base_Import[93], _ad_, 1),
     _ac_ = 0;
    if(_ae_ >= 0){
     var i = _ac_;
     for(;;){
      caml_call2(f, i, unsafe_get(a, i));
      var _af_ = i + 1 | 0;
      if(_ae_ === i) break;
      var i = _af_;
     }
    }
    return 0;
   }
   function foldi(a, init, f){
    var
     acc = [0, init],
     ___ = caml_call1(length, a),
     _$_ = caml_call2(Base_Import[93], ___, 1),
     _Z_ = 0;
    if(_$_ >= 0){
     var i = _Z_;
     for(;;){
      var _aa_ = unsafe_get(a, i);
      acc[1] = caml_call3(f, i, acc[1], _aa_);
      var _ab_ = i + 1 | 0;
      if(_$_ === i) break;
      var i = _ab_;
     }
    }
    return acc[1];
   }
   function fold(t, init, f){
    var
     r = [0, init],
     _V_ = caml_call1(length, t),
     _W_ = caml_call2(Base_Import[93], _V_, 1),
     _U_ = 0;
    if(_W_ >= 0){
     var i = _U_;
     for(;;){
      var _X_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _X_);
      var _Y_ = i + 1 | 0;
      if(_W_ === i) break;
      var i = _Y_;
     }
    }
    return r[1];
   }
   function to_list(t){
    function _R_(_T_){return get(t, _T_);}
    var _S_ = caml_call1(length, t);
    return caml_call2(Base_List[40], _S_, _R_);
   }
   function of_list(l){
    var
     len = caml_call1(Base_List[45], l),
     res = unsafe_create_uninitialized(len);
    function _Q_(i, x){return set(res, i, x);}
    caml_call2(Base_List[34], l, _Q_);
    return res;
   }
   function of_list_rev(l){
    var
     len = caml_call1(Base_List[45], l),
     res = unsafe_create_uninitialized(len);
    function _O_(i, x){
     var _P_ = caml_call2(Base_Import[93], len, i);
     return set(res, caml_call2(Base_Import[93], _P_, 1), x);
    }
    caml_call2(Base_List[34], l, _O_);
    return res;
   }
   function to_array(t){
    function _M_(i){return unsafe_get(t, i);}
    var _N_ = caml_call1(length, t);
    return caml_call2(Base_Array[41], _N_, _M_);
   }
   function exists(t, f){
    var
     _L_ = caml_call1(length, t),
     i = [0, caml_call2(Base_Import[93], _L_, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call1(f, unsafe_get(t, i[1]))){result[1] = 1; continue;}
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function existsi(t, f){
    var
     _J_ = caml_call1(length, t),
     i = [0, caml_call2(Base_Import[93], _J_, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      var _K_ = unsafe_get(t, i[1]);
      if(caml_call2(f, i[1], _K_)){result[1] = 1; continue;}
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function for_all(t, f){
    var
     _I_ = caml_call1(length, t),
     i = [0, caml_call2(Base_Import[93], _I_, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call1(f, unsafe_get(t, i[1]))){i[1] += -1; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(t, f){
    var
     length$0 = caml_call1(length, t),
     i = [0, caml_call2(Base_Import[93], length$0, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      var _H_ = unsafe_get(t, i[1]);
      if(caml_call2(f, i[1], _H_)){i[1] += -1; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function filter_mapi(t, f){
    var
     r = [0, empty],
     k = [0, 0],
     _D_ = caml_call1(length, t),
     _E_ = caml_call2(Base_Import[93], _D_, 1),
     _C_ = 0;
    if(_E_ >= 0){
     var i = _C_;
     for(;;){
      var match = caml_call2(f, i, unsafe_get(t, i));
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = create(caml_call1(length, t), a);
       unsafe_set(r[1], k[1], a);
       k[1]++;
      }
      var _G_ = i + 1 | 0;
      if(_E_ === i) break;
      var i = _G_;
     }
    }
    var _F_ = caml_call1(length, t);
    return k[1] === _F_
            ? r[1]
            : 0 < k[1] ? caml_call3(sub, r[1], 0, k[1]) : empty;
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function fold2_exn(t1, t2, init, f){
    var len = caml_call1(length, t1);
    if(caml_call1(length, t2) !== len)
     caml_call1(Base_Import[126], cst_Array_fold2_exn);
    var acc = [0, init], _y_ = caml_call2(Base_Import[93], len, 1), _x_ = 0;
    if(_y_ >= 0){
     var i = _x_;
     for(;;){
      var _z_ = unsafe_get(t2, i), _A_ = unsafe_get(t1, i);
      acc[1] = caml_call3(f, acc[1], _A_, _z_);
      var _B_ = i + 1 | 0;
      if(_y_ === i) break;
      var i = _B_;
     }
    }
    return acc[1];
   }
   function map2_exn(t1, t2, f){
    var len = caml_call1(length, t1);
    if(caml_call1(length, t2) !== len)
     caml_call1(Base_Import[126], cst_Array_map2_exn);
    return init
            (len,
             function(i){
              var _w_ = unsafe_get(t2, i);
              return caml_call2(f, unsafe_get(t1, i), _w_);
             });
   }
   function concat(ts){
    function _n_(t){return caml_call1(length, t);}
    function _o_(_v_, _u_){return _v_ + _u_ | 0;}
    var
     total_len = caml_call3(Base_List[26], [0, Base_Int[79], _o_], ts, _n_),
     res = unsafe_create_uninitialized(total_len);
    function _p_(so_far, t){
     var
      len = caml_call1(length, t),
      _r_ = caml_call2(Base_Import[93], len, 1),
      _q_ = 0;
     if(_r_ >= 0){
      var i = _q_;
      for(;;){
       var _s_ = get(t, i);
       set(res, caml_call2(Base_Import[91], so_far, i), _s_);
       var _t_ = i + 1 | 0;
       if(_r_ === i) break;
       var i = _t_;
      }
     }
     return caml_call2(Base_Import[91], so_far, len);
    }
    caml_call3(Base_List[20], ts, 0, _p_);
    return res;
   }
   function concat_mapi(t, f){
    var _m_ = to_list(t);
    return concat(caml_call2(Base_List[41], _m_, f));
   }
   function concat_map(t, f){
    var _l_ = to_list(t);
    return concat(caml_call2(Base_List[53], _l_, f));
   }
   function partition_map(t, f){
    var
     right = [0, empty],
     left = [0, empty],
     right_idx = [0, 0],
     left_idx = [0, 0];
    function append(data, idx, value){
     if(0 === idx[1]) data[1] = create(caml_call1(length, t), value);
     unsafe_set(data[1], idx[1], value);
     idx[1]++;
     return;
    }
    var
     _g_ = caml_call1(length, t),
     _h_ = caml_call2(Base_Import[93], _g_, 1),
     _f_ = 0;
    if(_h_ >= 0){
     var i = _f_;
     for(;;){
      var match = caml_call1(f, unsafe_get(t, i));
      if(0 === match[0]){
       var a = match[1];
       append(left, left_idx, a);
      }
      else{var a$0 = match[1]; append(right, right_idx, a$0);}
      var _j_ = i + 1 | 0;
      if(_h_ === i) break;
      var i = _j_;
     }
    }
    function trim(data, idx){
     var _k_ = caml_call1(length, t);
     return idx[1] === _k_
             ? data[1]
             : 0 < idx[1] ? caml_call3(sub, data[1], 0, idx[1]) : empty;
    }
    var _i_ = trim(right, right_idx);
    return [0, trim(left, left_idx), _i_];
   }
   function find_map(t, f){
    var length$0 = caml_call1(length, t);
    if(0 === length$0) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[52], value_found[1]) && i[1] < length$0){
      var value = unsafe_get(t, i[1]);
      value_found[1] = caml_call1(f, value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   function find_mapi(t, f){
    var length$0 = caml_call1(length, t);
    if(0 === length$0) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[52], value_found[1]) && i[1] < length$0){
      var value = unsafe_get(t, i[1]);
      value_found[1] = caml_call2(f, i[1], value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   function find(t, f){
    function _d_(param){var x = param[2]; return x;}
    var length$0 = caml_call1(length, t);
    if(0 === length$0)
     var _e_ = 0;
    else{
     var i = [0, 0], found = [0, 0], value_found = [0, unsafe_get(t, 0)];
     for(;;){
      if(! found[1] && i[1] < length$0){
       var value = unsafe_get(t, i[1]);
       if(caml_call1(f, value)){
        value_found[1] = value;
        found[1] = 1;
       }
       else
        i[1]++;
       continue;
      }
      if(found[1]){var _e_ = [0, [0, i[1], value_found[1]]]; break;}
      var _e_ = 0;
      break;
     }
    }
    return caml_call2(Base_Option[24], _e_, _d_);
   }
   function findi(t, f){
    var len = caml_call1(length, t), i = 0;
    for(;;){
     if(len <= i) return 0;
     var x = unsafe_get(t, i);
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   function t_sexp_grammar(grammar){
    var _c_ = caml_call1(Base_Array[6], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _c_);
   }
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Array[4], Base_Array[5]]),
        [0, to_array, of_array]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function create_like(len, t){
    if(0 === len) return empty;
    if(0 < caml_call1(length, t)) return create(len, get(t, 0));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   var
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub$0 = include$0[4],
    subo = include$0[5];
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function compare_local(compare_elt, a, b){
    if(a === b) return 0;
    var
     len_a = caml_call1(length, a),
     len_b = caml_call1(length, b),
     ret = runtime.caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var
      l = unsafe_get_local(a, i),
      r = unsafe_get_local(b, i),
      res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   function compare(compare_elt, a, b){
    return compare_local(compare_elt, a, b);
   }
   var
    Sort = caml_call1(Base_Array[109][2], [0, unsafe_get, unsafe_set, length]),
    sort = Sort[1],
    include$1 = caml_call1(Base_Binary_searchable[2], [0, unsafe_get, length]),
    binary_search = include$1[1],
    binary_search_segmented = include$1[2],
    Base_Uniform_array =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       compare_local,
       invariant,
       empty,
       create,
       singleton,
       init,
       length,
       get,
       unsafe_get,
       unsafe_get_local,
       set,
       unsafe_set,
       swap,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       map,
       mapi,
       iter,
       iteri,
       fold,
       foldi,
       unsafe_to_array_inplace_promis,
       of_array,
       to_array,
       of_list,
       of_list_rev,
       to_list,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       copy,
       exists,
       existsi,
       for_all,
       for_alli,
       concat,
       concat_map,
       concat_mapi,
       partition_map,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       find,
       findi,
       find_map,
       find_mapi,
       map2_exn,
       fold2_exn,
       min_elt,
       max_elt,
       sort,
       binary_search,
       binary_search_segmented,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_clear_if_pointer];
   runtime.caml_register_global(18, Base_Uniform_array, "Base__Uniform_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Uchar_intf = [0];
   runtime.caml_register_global(0, Base_Uchar_intf, "Base__Uchar_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar
//# unitInfo: Requires: Base__Bytes0, Base__Comparable, Base__Error, Base__Hash, Base__Hashable, Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String0, Base__Uchar0, Base__Uchar_intf, Sexplib0__Sexp_grammar, Stdlib, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_U = "U+",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Uchar",
    codec_name = "UTF-8",
    module_name$0 = "Base.Uchar.Utf8",
    codec_name$0 = "UTF-16LE",
    module_name$1 = "Base.Uchar.Utf16le",
    codec_name$1 = "UTF-16BE",
    module_name$2 = "Base.Uchar.Utf16be",
    codec_name$2 = "UTF-32LE",
    module_name$3 = "Base.Uchar.Utf32le",
    codec_name$3 = "UTF-32BE",
    module_name$4 = "Base.Uchar.Utf32be",
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Base_Bytes0 = global_data.Base__Bytes0,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Comparable = global_data.Base__Comparable,
    Base_String0 = global_data.Base__String0,
    failwithf = Base_Printf[6],
    is_valid = Base_Uchar0[3],
    is_char = Base_Uchar0[4],
    unsafe_to_char = Base_Uchar0[5],
    unsafe_of_int = Base_Uchar0[6],
    to_int = Base_Uchar0[8],
    of_char = Base_Uchar0[9],
    compare = Base_Uchar0[10],
    min_value = Base_Uchar0[12],
    max_value = Base_Uchar0[13],
    byte_order_mark = Base_Uchar0[14],
    replacement_char = Base_Uchar0[15],
    utf_8_byte_length = Base_Uchar0[16],
    utf_16_byte_length = Base_Uchar0[17],
    cst_string = "string",
    _h_ = [0, "src/uchar.ml", 134, 4],
    cst_of_string_expected_a_singl =
      ".of_string: expected a single Unicode character",
    _g_ =
      [0,
       "Uchar.Decode_result.uchar_exn was called on an invalid decode result"],
    _f_ =
      [0,
       [11,
        "Uchar.to_char_exn got a non latin-1 character: U+",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.to_char_exn got a non latin-1 character: U+%04X"],
    _e_ =
      [0,
       [11,
        "Uchar.of_int_exn got a invalid Unicode scalar value: ",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.of_int_exn got a invalid Unicode scalar value: %04X"],
    _d_ = [0, [11, "Uchar.pred_exn: ", [2, 0, 0]], "Uchar.pred_exn: %s"],
    _c_ = [0, [11, "Uchar.succ_exn: ", [2, 0, 0]], "Uchar.succ_exn: %s"],
    _b_ = [0, [11, cst_U, [4, 8, 0, 0, 0]], "U+%X"],
    cst_Uchar_t_of_sexp_atom_of_th =
      "Uchar.t_of_sexp: atom of the form U+XXXX needed",
    cst_Uchar_t_of_sexp_atom_neede = "Uchar.t_of_sexp: atom needed",
    _a_ = [0, [11, cst_U, [4, 8, [0, 2, 4], 0, 0]], "U+%04X"];
   function hash_fold_t(state, t){
    var _y_ = caml_call1(to_int, t);
    return caml_call2(Base_Hash[3], state, _y_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string_internal(t){
    var _x_ = caml_call1(to_int, t);
    return caml_call2(Base_Printf[2], _a_, _x_);
   }
   function sexp_of_t(t){return [0, to_string_internal(t)];}
   function t_of_sexp(sexp){
    if(0 !== sexp[0])
     return caml_call2(Base_Import[156], cst_Uchar_t_of_sexp_atom_neede, sexp);
    var s = sexp[1];
    try{
     var
      _u_ = function(i){return caml_call1(Base_Uchar0[7], i);},
      _v_ = caml_call3(Stdlib_Scanf[5], s, _b_, _u_);
     return _v_;
    }
    catch(_w_){
     return caml_call2(Base_Import[156], cst_Uchar_t_of_sexp_atom_of_th, sexp);
    }
   }
   var
    t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_Import[182]),
    include =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string_internal]),
    pp = include[1],
    include$0 = caml_call1(Base_Comparable[11], [0, compare, sexp_of_t]),
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator = include$0[16];
   function invariant(param){return 0;}
   function succ_exn(c){
    try{var _t_ = caml_call1(Base_Uchar0[1], c); return _t_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _c_, msg, 0);
    }
   }
   function succ(c){
    try{var _r_ = [0, caml_call1(Base_Uchar0[1], c)]; return _r_;}
    catch(_s_){
     var _q_ = caml_wrap_exception(_s_);
     if(_q_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_q_, 0);
    }
   }
   function pred_exn(c){
    try{var _p_ = caml_call1(Base_Uchar0[2], c); return _p_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _d_, msg, 0);
    }
   }
   function pred(c){
    try{var _n_ = [0, caml_call1(Base_Uchar0[2], c)]; return _n_;}
    catch(_o_){
     var _m_ = caml_wrap_exception(_o_);
     if(_m_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_m_, 0);
    }
   }
   function of_scalar(i){
    return caml_call1(is_valid, i) ? [0, caml_call1(unsafe_of_int, i)] : 0;
   }
   function of_scalar_exn(i){
    return caml_call1(is_valid, i)
            ? caml_call1(unsafe_of_int, i)
            : caml_call3(failwithf, _e_, i, 0);
   }
   function to_scalar(t){return caml_call1(Base_Uchar0[8], t);}
   function to_char(c){
    return caml_call1(is_char, c) ? [0, caml_call1(unsafe_to_char, c)] : 0;
   }
   function to_char_exn(c){
    return caml_call1(is_char, c)
            ? caml_call1(unsafe_to_char, c)
            : caml_call3(failwithf, _f_, caml_call1(to_int, c), 0);
   }
   var compare$0 = runtime.caml_int_compare;
   function equal(_l_, _k_){return _l_ === _k_ ? 1 : 0;}
   function hash_fold_t$0(state, t){
    var _j_ = caml_call1(Base_Hashable[6], t);
    return caml_call2(Base_Import[206], state, _j_);
   }
   var
    hash$0 = Base_Hashable[6],
    is_valid$0 = Base_Uchar0[18],
    bytes_consumed = Base_Uchar0[20],
    uchar_or_replacement_char = Base_Uchar0[19];
   function sexp_of_t$0(t){
    return sexp_of_t(caml_call1(uchar_or_replacement_char, t));
   }
   function uchar(t){
    return caml_call1(is_valid$0, t)
            ? [0, caml_call1(uchar_or_replacement_char, t)]
            : 0;
   }
   function uchar_exn(t){
    return caml_call1(is_valid$0, t)
            ? caml_call1(uchar_or_replacement_char, t)
            : caml_call1(Base_Error[32], _g_);
   }
   function Make_utf(Format){
    var codec_name = Format[1], byte_length = Format[3];
    function to_string(t){
     var
      len = caml_call1(byte_length, t),
      bytes = caml_call1(Base_Bytes0[7], len),
      pos = caml_call3(Format[5], bytes, 0, t);
     if(pos === len) return runtime.caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    }
    var
     of_string_message =
       caml_call2(Base_Import[112], Format[2], cst_of_string_expected_a_singl);
    function of_string(string){
     var
      decode = caml_call2(Format[4], string, 0),
      string_len = runtime.caml_ml_string_length(string),
      decode_len = caml_call1(bytes_consumed, decode);
     if(string_len === decode_len && caml_call1(is_valid$0, decode))
      return caml_call1(uchar_or_replacement_char, decode);
     var
      _i_ =
        caml_call2
         (Base_Sexp[10],
          of_string_message,
          [0, [0, cst_string, [0, string]], 0]);
     return caml_call1(Base_Error[32], _i_);
    }
    return [0, of_string, to_string, byte_length, codec_name];
   }
   var
    get_decode_result = Base_String0[15],
    set = Base_Bytes0[8],
    Utf8 =
      Make_utf
       ([0,
         codec_name,
         module_name$0,
         utf_8_byte_length,
         get_decode_result,
         set]),
    get_decode_result$0 = Base_String0[16],
    set$0 = Base_Bytes0[9],
    Utf16le =
      Make_utf
       ([0,
         codec_name$0,
         module_name$1,
         utf_16_byte_length,
         get_decode_result$0,
         set$0]),
    get_decode_result$1 = Base_String0[17],
    set$1 = Base_Bytes0[10],
    Utf16be =
      Make_utf
       ([0,
         codec_name$1,
         module_name$2,
         utf_16_byte_length,
         get_decode_result$1,
         set$1]);
   function byte_length(param){return 4;}
   var
    get_decode_result$2 = Base_String0[18],
    set$2 = Base_Bytes0[12],
    Utf32le =
      Make_utf
       ([0,
         codec_name$2,
         module_name$3,
         byte_length,
         get_decode_result$2,
         set$2]);
   function byte_length$0(param){return 4;}
   var
    get_decode_result$3 = Base_String0[19],
    set$3 = Base_Bytes0[13],
    Utf32be =
      Make_utf
       ([0,
         codec_name$3,
         module_name$4,
         byte_length$0,
         get_decode_result$3,
         set$3]),
    include$1 = Base_Import[107],
    symbol = include$1[1],
    symbol$0 = include$1[2],
    symbol$1 = include$1[3],
    symbol$2 = include$1[4],
    symbol$3 = include$1[5],
    symbol$4 = include$1[6],
    ascending = include$1[7],
    descending = include$1[8],
    compare$1 = include$1[9],
    equal$0 = include$1[10],
    compare_local = include$1[11],
    equal_local = include$1[12],
    max = include$1[13],
    min = include$1[14],
    Base_Uchar =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal$0,
       compare$1,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local,
       pp,
       invariant,
       succ,
       succ_exn,
       pred,
       pred_exn,
       is_char,
       to_char,
       to_char_exn,
       of_char,
       is_valid,
       of_scalar,
       of_scalar_exn,
       to_scalar,
       utf_8_byte_length,
       utf_16_byte_length,
       min_value,
       max_value,
       byte_order_mark,
       replacement_char,
       [0,
        compare$0,
        equal,
        hash_fold_t$0,
        hash$0,
        sexp_of_t$0,
        is_valid$0,
        bytes_consumed,
        uchar,
        uchar_exn,
        uchar_or_replacement_char],
       Utf8,
       Utf16le,
       Utf16be,
       Utf32le,
       Utf32be];
   runtime.caml_register_global(38, Base_Uchar, "Base__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function Type_equal_defns(Type_equal){
    function Composition_preserves_injectiv(M1, M2){
     function strip(e){
      var _a_ = caml_call1(M2[1], e);
      return caml_call1(M1[1], _a_);
     }
     return [0, strip];
    }
    return [0, Composition_preserves_injectiv];
   }
   function Type_equal_id_defns(Id){return [0];}
   var Base_Type_equal_intf = [0, Type_equal_defns, Type_equal_id_defns];
   runtime.caml_register_global
    (0, Base_Type_equal_intf, "Base__Type_equal_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal
//# unitInfo: Requires: Base__Comparable, Base__Error, Base__Hash, Base__Import, Base__Sexp, Base__Type_equal_intf, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_T = "T",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Hash = global_data.Base__Hash,
    Base_Type_equal_intf = global_data.Base__Type_equal_intf,
    Base_Comparable = global_data.Base__Comparable,
    _g_ = [0, 0],
    cst_Base_Type_equal_Id_Create3 = "Base__Type_equal.Id.Create3(T).T3",
    _f_ = [0, 0],
    cst_Base_Type_equal_Id_Create2 = "Base__Type_equal.Id.Create2(T).T2",
    _e_ = [0, 0],
    cst_Base_Type_equal_Id_Create1 = "Base__Type_equal.Id.Create1(T).T1",
    _d_ = [0, 0],
    cst_Base_Type_equal_Id_Create0 = "Base__Type_equal.Id.Create0(T).T0",
    cst_Type_equal_Id_same_witness =
      "Type_equal.Id.same_witness_exn got different ids",
    _c_ = [0, cst_T],
    _b_ = [0, 0, 0],
    _a_ = [0, cst_T];
   function sexp_of_t(of_a_001, of_b_002, param){return _a_;}
   var
    include = caml_call1(Base_Type_equal_intf[1], [0]),
    Composition_preserves_injectiv = include[1],
    refl = 0;
   function sym(param){return 0;}
   function trans(param, _E_){return 0;}
   function conv(param, a){return a;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   function Lift2(X){function lift(param, _D_){return 0;} return [0, lift];}
   function Lift3(X){
    function lift(param, _C_, _B_){return 0;}
    return [0, lift];
   }
   function detuple2(param){return _b_;}
   function tuple2(param, _A_){return 0;}
   function compare(a_005, b_006){
    if(a_005 === b_006) return 0;
    var
     b_010 = b_006[2],
     b_008 = b_006[1],
     a_009 = a_005[2],
     a_007 = a_005[1],
     n = caml_call2(Base_Import[228], a_007, b_008);
    return 0 === n ? caml_call3(Base_Import[236], compare, a_009, b_010) : n;
   }
   var
    hash_fold_t = function _z_(_x_, _y_){return _z_.fun(_x_, _y_);},
    hash = function _w_(_v_){return _w_.fun(_v_);};
   caml_update_dummy
    (hash_fold_t,
     function(hsv, arg){
      var
       a1 = arg[2],
       a0 = arg[1],
       hsv$0 = caml_call2(Base_Import[206], hsv, a0);
      return caml_call3(Base_Import[212], hash_fold_t, hsv$0, a1);
     });
   caml_update_dummy
    (hash,
     function(arg){
      var
       hsv = caml_call2(Base_Hash[11], 0, 0),
       _u_ = caml_call2(hash_fold_t, hsv, arg);
      return caml_call1(Base_Hash[9], _u_);
     });
   function sexp_of_t$0(param){
    var
     arg1_014 = param[2],
     arg0_013 = param[1],
     res0_015 = caml_call1(Base_Import[139], arg0_013),
     res1_016 = caml_call2(Base_Import[149], sexp_of_t$0, arg1_014);
    return [1, [0, _c_, [0, res0_015, [0, res1_016, 0]]]];
   }
   var
    include$0 = caml_call1(Base_Comparable[11], [0, compare, sexp_of_t$0]),
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    equal = include$0[7],
    compare$0 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator = include$0[16];
   function create(key, args){
    var
     _t_ = caml_call1(Stdlib_Obj[23][1], key),
     tag = caml_call1(Stdlib_Obj[23][3], _t_);
    return [0, tag, args];
   }
   function uid(A){return A[2];}
   function name(A){return A[3];}
   function sexp_of_t$1(param, A){return A[4];}
   function to_sexp(A){return A[1];}
   function hash$0(t){return caml_call1(hash, t[2]);}
   function hash_fold_t$0(state, t){
    return caml_call2(hash_fold_t, state, t[2]);
   }
   function same_witness(A, B){return caml_call1(A[6], B[5]);}
   function same_witness_exn(t1, t2){
    var match = same_witness(t1, t2);
    if(match){var equal = match[1]; return equal;}
    var _l_ = 0, _m_ = [0, t1, t2];
    function _n_(_s_){return _s_[4];}
    function _o_(_r_){return _r_[4];}
    var
     _p_ = [0, [0, cst, caml_call3(Base_Import[147], _o_, _n_, _m_)], _l_],
     _q_ = caml_call2(Base_Sexp[10], cst_Type_equal_Id_same_witness, _p_);
    return caml_call1(Base_Error[32], _q_);
   }
   function same(t1, t2){return same_witness(t1, t2) ? 1 : 0;}
   caml_call1(Base_Type_equal_intf[2], [0]);
   function Create0(T){
    var
     T0 = [248, cst_Base_Type_equal_Id_Create0, caml_fresh_oo_id(0)],
     id_name = T[2],
     id_sexp = [0, id_name],
     sexp_of_t = T[1],
     uid = create(T0, 0);
    function type_equal(otherkey){return otherkey === T0 ? _d_ : 0;}
    var type_equal_id = [0, sexp_of_t, uid, id_name, id_sexp, T0, type_equal];
    return [0, , type_equal_id];
   }
   function create$0(name, sexp_of_t){
    return Create0([0, sexp_of_t, name])[2];
   }
   function _h_(T){
    var T3 = [248, cst_Base_Type_equal_Id_Create3, caml_fresh_oo_id(0)];
    function type_equal_id(A, B, C){
     var
      id_name = T[2],
      id_sexp = [1, [0, [0, id_name], [0, A[4], [0, B[4], [0, C[4], 0]]]]];
     function sexp_of_t(t){return caml_call4(T[1], A[1], B[1], C[1], t);}
     var
      type_key = [0, T3, A[5], B[5], C[5]],
      uid = create(type_key, [0, A[2], [0, B[2], [0, C[2], 0]]]);
     function type_equal(otherkey){
      if(otherkey[1] !== T3) return 0;
      var
       ckey = otherkey[4],
       bkey = otherkey[3],
       akey = otherkey[2],
       match = caml_call1(A[6], akey),
       match$0 = caml_call1(B[6], bkey),
       match$1 = caml_call1(C[6], ckey);
      if(match && match$0 && match$1) return _g_;
      return 0;
     }
     return [0, sexp_of_t, uid, id_name, id_sexp, type_key, type_equal];
    }
    return [0, type_equal_id];
   }
   function _i_(T){
    var T2 = [248, cst_Base_Type_equal_Id_Create2, caml_fresh_oo_id(0)];
    function type_equal_id(A, B){
     var
      id_name = T[2],
      id_sexp = [1, [0, [0, id_name], [0, A[4], [0, B[4], 0]]]];
     function sexp_of_t(t){return caml_call3(T[1], A[1], B[1], t);}
     var
      type_key = [0, T2, A[5], B[5]],
      uid = create(type_key, [0, A[2], [0, B[2], 0]]);
     function type_equal(otherkey){
      if(otherkey[1] !== T2) return 0;
      var
       bkey = otherkey[3],
       akey = otherkey[2],
       match = caml_call1(A[6], akey),
       match$0 = caml_call1(B[6], bkey);
      if(match && match$0) return _f_;
      return 0;
     }
     return [0, sexp_of_t, uid, id_name, id_sexp, type_key, type_equal];
    }
    return [0, type_equal_id];
   }
   function _j_(T){
    var T1 = [248, cst_Base_Type_equal_Id_Create1, caml_fresh_oo_id(0)];
    function type_equal_id(A){
     var id_name = T[2], id_sexp = [1, [0, [0, id_name], [0, A[4], 0]]];
     function sexp_of_t(t){return caml_call2(T[1], A[1], t);}
     var type_key = [0, T1, A[5]], uid = create(type_key, [0, A[2], 0]);
     function type_equal(otherkey){
      if(otherkey[1] !== T1) return 0;
      var akey = otherkey[2];
      return caml_call1(A[6], akey) ? _e_ : 0;
     }
     return [0, sexp_of_t, uid, id_name, id_sexp, type_key, type_equal];
    }
    return [0, type_equal_id];
   }
   var
    Base_Type_equal =
      [0,
       sexp_of_t,
       Composition_preserves_injectiv,
       refl,
       sym,
       trans,
       conv,
       Lift,
       Lift2,
       Lift3,
       detuple2,
       tuple2,
       [0,
        sexp_of_t$1,
        [0,
         hash_fold_t,
         hash,
         sexp_of_t$0,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         equal,
         compare$0,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator],
        uid,
        create$0,
        hash$0,
        name,
        to_sexp,
        hash_fold_t$0,
        same,
        same_witness,
        same_witness_exn,
        function(_k_){return [0, Create0(_k_)[2]];},
        _j_,
        _i_,
        _h_]];
   runtime.caml_register_global(20, Base_Type_equal, "Base__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stack_intf = [0];
   runtime.caml_register_global(0, Base_Stack_intf, "Base__Stack_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option_array
//# unitInfo: Requires: Base__Array, Base__Blit, Base__Import, Base__Indexed_container, Base__Option, Base__Sexpable, Base__Uniform_array, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array = global_data.Base__Array,
    Base_Import = global_data.Base__Import,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Option = global_data.Base__Option,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Blit = global_data.Base__Blit,
    none_substitute = runtime.caml_obj_block(Stdlib_Obj[14], 1),
    cst_Option_array_get_some_exn_ =
      "Option_array.get_some_exn: the element is [None]",
    none = 24791911;
   function is_none(x){return x === 24791911 ? 1 : 0;}
   function is_some(x){return 1 - (x === 24791911 ? 1 : 0);}
   function some(x){return x === 24791911 ? none_substitute : x;}
   function value_unsafe(x){return x === none_substitute ? none : x;}
   function value_exn(x){
    return is_some(x)
            ? value_unsafe(x)
            : caml_call1(Base_Import[124], cst_Option_array_get_some_exn_);
   }
   function of_sexpable(param){
    if(! param) return none;
    var x = param[1];
    return some(x);
   }
   function to_sexpable(x){return is_some(x) ? [0, value_unsafe(x)] : 0;}
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Option[9], Base_Option[10]]),
        [0, to_sexpable, of_sexpable]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function t_of_sexp$0(of_a_001, x_003){
    var _A_ = caml_call1(t_of_sexp, of_a_001);
    return caml_call2(Base_Uniform_array[1], _A_, x_003);
   }
   function sexp_of_t$0(of_a_004, x_005){
    var _z_ = caml_call1(sexp_of_t, of_a_004);
    return caml_call2(Base_Uniform_array[2], _z_, x_005);
   }
   function t_sexp_grammar(a_sexp_grammar){
    var
     _x_ = caml_call1(Base_Option[5], a_sexp_grammar),
     _y_ = caml_call1(Sexplib0_Sexp_grammar[1], _x_);
    return caml_call1(Base_Uniform_array[3], _y_);
   }
   var empty = Base_Uniform_array[7];
   function create(len){return caml_call2(Base_Uniform_array[8], len, none);}
   function init(n, f){
    function _w_(i){return of_sexpable(caml_call1(f, i));}
    return caml_call2(Base_Uniform_array[10], n, _w_);
   }
   function init_some(n, f){
    function _v_(i){return some(caml_call1(f, i));}
    return caml_call2(Base_Uniform_array[10], n, _v_);
   }
   var _a_ = Base_Uniform_array[11];
   function get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[12], t, i));
   }
   function get_local(t, i){
    var x = caml_call2(Base_Uniform_array[12], t, i);
    return is_some(x) ? [0, value_unsafe(x)] : 0;
   }
   function get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[12], t, i));
   }
   function is_none$0(t, i){
    return caml_call2(Base_Uniform_array[12], t, i) === 24791911 ? 1 : 0;
   }
   function is_some$0(t, i){
    return is_some(caml_call2(Base_Uniform_array[12], t, i));
   }
   function set(t, i, x){
    var _u_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[15], t, i, _u_);
   }
   function set_some(t, i, x){
    var _t_ = some(x);
    return caml_call3(Base_Uniform_array[15], t, i, _t_);
   }
   function set_none(t, i){
    return caml_call3(Base_Uniform_array[15], t, i, none);
   }
   function swap(t, i, j){return caml_call3(Base_Uniform_array[17], t, i, j);}
   function unsafe_get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[13], t, i));
   }
   function unsafe_get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[13], t, i));
   }
   function unsafe_get_some_assuming_some(t, i){
    return value_unsafe(caml_call2(Base_Uniform_array[13], t, i));
   }
   function unsafe_is_some(t, i){
    return is_some(caml_call2(Base_Uniform_array[13], t, i));
   }
   function unsafe_set(t, i, x){
    var _s_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[16], t, i, _s_);
   }
   function unsafe_set_some(t, i, x){
    var _r_ = some(x);
    return caml_call3(Base_Uniform_array[16], t, i, _r_);
   }
   function unsafe_set_none(t, i){
    return caml_call3(Base_Uniform_array[16], t, i, none);
   }
   function clear(t){
    var
     _o_ = caml_call1(_a_, t),
     _p_ = caml_call2(Base_Import[93], _o_, 1),
     _n_ = 0;
    if(_p_ >= 0){
     var i = _n_;
     for(;;){
      unsafe_set_none(t, i);
      var _q_ = i + 1 | 0;
      if(_p_ === i) break;
      var i = _q_;
     }
    }
    return 0;
   }
   function _b_(input, f){
    var
     _k_ = caml_call1(_a_, input),
     _l_ = caml_call2(Base_Import[93], _k_, 1),
     _j_ = 0;
    if(_l_ >= 0){
     var i = _j_;
     for(;;){
      caml_call2(f, i, unsafe_get(input, i));
      var _m_ = i + 1 | 0;
      if(_l_ === i) break;
      var i = _m_;
     }
    }
    return 0;
   }
   function _c_(input, f){
    return _b_(input, function(param, x){return caml_call1(f, x);});
   }
   function _d_(input, init, f){
    var acc = [0, init];
    _b_
     (input,
      function(i, elem){acc[1] = caml_call3(f, i, acc[1], elem); return 0;});
    return acc[1];
   }
   function fold(input, init, f){
    return _d_
            (input,
             init,
             function(param, acc, x){return caml_call2(f, acc, x);});
   }
   var
    foldi = [0, -198771759, _d_],
    iter = [0, -198771759, _c_],
    iteri = [0, -198771759, _b_],
    length = [0, -198771759, _a_],
    include$0 =
      caml_call1
       (Base_Indexed_container[10], [0, fold, iter, length, iteri, foldi]),
    is_empty = include$0[2],
    mem = include$0[3],
    iter$0 = include$0[4],
    fold$0 = include$0[5],
    fold_result = include$0[6],
    fold_until = include$0[7],
    exists = include$0[8],
    for_all = include$0[9],
    count = include$0[10],
    sum = include$0[11],
    find = include$0[12],
    find_map = include$0[13],
    to_list = include$0[14],
    min_elt = include$0[16],
    max_elt = include$0[17],
    foldi$0 = include$0[18],
    iteri$0 = include$0[19],
    existsi = include$0[20],
    for_alli = include$0[21],
    counti = include$0[22],
    findi = include$0[23],
    find_mapi = include$0[24],
    length$0 = Base_Uniform_array[11];
   function map(input, f){
    var output = create(caml_call1(length$0, input));
    caml_call2
     (iteri$0,
      input,
      function(i, elem){return unsafe_set(output, i, caml_call1(f, elem));});
    return output;
   }
   function map_some(input, f){
    var
     len = caml_call1(length$0, input),
     output = create(len),
     _h_ = caml_call2(Base_Import[93], len, 1),
     _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      var opt = caml_call2(Base_Uniform_array[13], input, i);
      if(is_some(opt)){
       var x = value_unsafe(opt);
       unsafe_set_some(output, i, caml_call1(f, x));
      }
      var _i_ = i + 1 | 0;
      if(_h_ === i) break;
      var i = _i_;
     }
    }
    return output;
   }
   function of_array(array){
    return init(array.length - 1, function(i){return array[1 + i];});
   }
   function of_array_some(array){
    return init_some(array.length - 1, function(i){return array[1 + i];});
   }
   function to_array(t){
    function _e_(i){return unsafe_get(t, i);}
    var _f_ = caml_call1(length$0, t);
    return caml_call2(Base_Array[41], _f_, _e_);
   }
   function create_like(len, param){return create(len);}
   var
    unsafe_blit = Base_Uniform_array[35],
    include$1 =
      caml_call1(Base_Blit[5], [0, create_like, length$0, unsafe_blit]),
    blit = include$1[1],
    blito = include$1[2],
    unsafe_blit$0 = include$1[3],
    sub = include$1[4],
    subo = include$1[5],
    copy = Base_Uniform_array[38],
    Base_Option_array =
      [0,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       empty,
       create,
       is_empty,
       mem,
       iter$0,
       fold$0,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       min_elt,
       max_elt,
       foldi$0,
       iteri$0,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       length$0,
       init_some,
       init,
       of_array,
       of_array_some,
       to_array,
       get,
       get_local,
       get_some_exn,
       is_none$0,
       is_some$0,
       unsafe_get,
       unsafe_get_some_exn,
       unsafe_get_some_assuming_some,
       unsafe_is_some,
       set,
       set_some,
       set_none,
       swap,
       clear,
       map,
       map_some,
       unsafe_set,
       unsafe_set_some,
       unsafe_set_none,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       [0,
        [0,
         t_of_sexp,
         sexp_of_t,
         none,
         some,
         is_none,
         is_some,
         value_exn,
         value_unsafe,
         to_sexpable,
         of_sexpable]]];
   runtime.caml_register_global(10, Base_Option_array, "Base__Option_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack
//# unitInfo: Requires: Base__Container, Base__Error, Base__Exn, Base__Import, Base__List, Base__Option_array, Base__Sexp, Base__Stack_intf, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_stack_ml = "src/stack.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Exn = global_data.Base__Exn,
    Base_Error = global_data.Base__Error,
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Sexp = global_data.Base__Sexp,
    Base_Container = global_data.Base__Container,
    raise_s = Base_Error[32],
    _e_ = [0, cst_src_stack_ml, 109, 14],
    _d_ = [0, cst_src_stack_ml, 41, 4],
    _c_ = [0, cst_src_stack_ml, 48, 6],
    cst_stack = "stack",
    cst_exn = "exn",
    cst_Stack_invariant_failed = "Stack.invariant failed",
    _a_ = [0, "elts"],
    _b_ = [0, "length"],
    cst_Stack_pop_of_empty_stack = "Stack.pop of empty stack",
    cst_Stack_top_of_empty_stack = "Stack.top of empty stack";
   function capacity(t){return caml_call1(Base_Option_array[28], t[2]);}
   function invariant(invariant_a, t){
    var length = t[1], elts = t[2];
    try{
     if(0 <= length && length <= caml_call1(Base_Option_array[28], elts)){
      var _P_ = caml_call2(Base_Import[93], length, 1), _O_ = 0;
      if(_P_ >= 0){
       var i$0 = _O_;
       for(;;){
        caml_call1(invariant_a, caml_call2(Base_Option_array[36], elts, i$0));
        var _U_ = i$0 + 1 | 0;
        if(_P_ === i$0) break;
        var i$0 = _U_;
       }
      }
      var
       _Q_ = caml_call1(Base_Option_array[28], elts),
       _R_ = caml_call2(Base_Import[93], _Q_, 1);
      if(_R_ >= length){
       var i = length;
       for(;;){
        if(caml_call2(Base_Option_array[38], elts, i))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        var _T_ = i + 1 | 0;
        if(_R_ === i) break;
        var i = _T_;
       }
      }
      var _S_ = 0;
      return _S_;
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      of_a_001 = Base_Import[152],
      length_003 = t[1],
      elts_005 = t[2],
      arg_006 = caml_call2(Base_Option_array[2], of_a_001, elts_005),
      bnds_002 = [0, [1, [0, _a_, [0, arg_006, 0]]], 0],
      arg_004 = caml_call1(Base_Import[139], length_003),
      bnds_002$0 = [0, [1, [0, _b_, [0, arg_004, 0]]], bnds_002],
      _N_ =
        [0,
         [0, cst_exn, caml_call1(Base_Exn[1], exn)],
         [0, [0, cst_stack, [1, bnds_002$0]], 0]];
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[10], cst_Stack_invariant_failed, _N_));
    }
   }
   function create(param){return [0, 0, Base_Option_array[4]];}
   function length(t){return t[1];}
   function is_empty(t){return 0 === t[1] ? 1 : 0;}
   function fold(t, init, f){
    var r = [0, init], _K_ = caml_call2(Base_Import[93], t[1], 1);
    if(_K_ >= 0){
     var i = _K_;
     for(;;){
      var _L_ = caml_call2(Base_Option_array[36], t[2], i);
      r[1] = caml_call2(f, r[1], _L_);
      var _M_ = i - 1 | 0;
      if(0 === i) break;
      var i = _M_;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _I_ = caml_call2(Base_Import[93], t[1], 1);
    if(_I_ >= 0){
     var i = _I_;
     for(;;){
      caml_call1(f, caml_call2(Base_Option_array[36], t[2], i));
      var _J_ = i - 1 | 0;
      if(0 === i) break;
      var i = _J_;
     }
    }
    return 0;
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = caml_call1(Base_Container[17], [0, fold, iter$0, length$0]),
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7];
   function of_list(l){
    if(caml_call1(Base_List[18], l)) return create(0);
    var
     length = caml_call1(Base_List[45], l),
     _F_ = caml_call2(Base_Import[88], 2, length),
     elts = caml_call1(Base_Option_array[5], _F_),
     r = [0, l],
     _G_ = caml_call2(Base_Import[93], length, 1);
    if(_G_ >= 0){
     var i = _G_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var l$0 = match[2], a = match[1];
      caml_call3(Base_Option_array[44], elts, i, a);
      r[1] = l$0;
      var _H_ = i - 1 | 0;
      if(0 === i) break;
      var i = _H_;
     }
    }
    return [0, length, elts];
   }
   function sexp_of_t(sexp_of_a, t){
    var _E_ = caml_call1(to_list, t);
    return caml_call2(Base_List[6], sexp_of_a, _E_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[5], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _D_ = caml_call1(Base_List[7], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _D_);
   }
   function resize(t, size){
    var arr = caml_call1(Base_Option_array[5], size);
    caml_call5(Base_Option_array[53], t[2], 0, arr, 0, t[1]);
    t[2] = arr;
    return 0;
   }
   function set_capacity(t, new_capacity){
    var
     new_capacity$0 = caml_call2(Base_Import[100], new_capacity, t[1]),
     _C_ = new_capacity$0 !== capacity(t) ? 1 : 0;
    return _C_ ? resize(t, new_capacity$0) : _C_;
   }
   function push(t, a){
    var _A_ = caml_call1(Base_Option_array[28], t[2]);
    if(t[1] === _A_){
     var _B_ = caml_call2(Base_Import[91], t[1], 1);
     resize(t, caml_call2(Base_Import[88], 2, _B_));
    }
    caml_call3(Base_Option_array[44], t[2], t[1], a);
    t[1] = caml_call2(Base_Import[91], t[1], 1);
    return 0;
   }
   function pop_nonempty(t){
    var
     i = caml_call2(Base_Import[93], t[1], 1),
     result = caml_call2(Base_Option_array[36], t[2], i);
    caml_call2(Base_Option_array[45], t[2], i);
    t[1] = i;
    return result;
   }
   var pop_error = caml_call1(Base_Error[14], cst_Stack_pop_of_empty_stack);
   function pop(t){return is_empty(t) ? 0 : [0, pop_nonempty(t)];}
   function pop_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[31], pop_error)
            : pop_nonempty(t);
   }
   function top_nonempty(t){
    var _z_ = caml_call2(Base_Import[93], t[1], 1);
    return caml_call2(Base_Option_array[36], t[2], _z_);
   }
   var top_error = caml_call1(Base_Error[14], cst_Stack_top_of_empty_stack);
   function top(t){return is_empty(t) ? 0 : [0, top_nonempty(t)];}
   function top_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[31], top_error)
            : top_nonempty(t);
   }
   function copy(param){
    var length = param[1], elts = param[2];
    return [0, length, caml_call1(Base_Option_array[58], elts)];
   }
   function clear(t){
    var _u_ = 0 < t[1] ? 1 : 0;
    if(_u_){
     var _w_ = caml_call2(Base_Import[93], t[1], 1), _v_ = 0;
     if(_w_ >= 0){
      var i = _v_;
      for(;;){
       caml_call2(Base_Option_array[45], t[2], i);
       var _y_ = i + 1 | 0;
       if(_w_ === i) break;
       var i = _y_;
      }
     }
     t[1] = 0;
     var _x_ = 0;
    }
    else
     var _x_ = _u_;
    return _x_;
   }
   function until_empty(t, f){
    for(;;){
     var _t_ = 0 < t[1] ? 1 : 0;
     if(! _t_) return _t_;
     caml_call1(f, pop_nonempty(t));
    }
   }
   function filter_map(t, f){
    var
     t_result = create(0),
     _r_ = caml_call2(Base_Import[93], t[1], 1),
     _q_ = 0;
    if(_r_ >= 0){
     var i = _q_;
     for(;;){
      var match = caml_call1(f, caml_call2(Base_Option_array[36], t[2], i));
      if(match){var x = match[1]; push(t_result, x);}
      var _s_ = i + 1 | 0;
      if(_r_ === i) break;
      var i = _s_;
     }
    }
    return t_result;
   }
   function filter(t, f){
    var
     t_result = create(0),
     _o_ = caml_call2(Base_Import[93], t[1], 1),
     _n_ = 0;
    if(_o_ >= 0){
     var i = _n_;
     for(;;){
      var x = caml_call2(Base_Option_array[36], t[2], i);
      if(caml_call1(f, x)) push(t_result, x);
      var _p_ = i + 1 | 0;
      if(_o_ === i) break;
      var i = _p_;
     }
    }
    return t_result;
   }
   function filter_inplace(t, f){
    var write_index = [0, 0];
    function _f_(param){
     var _k_ = write_index[1], _l_ = caml_call2(Base_Import[93], t[1], 1);
     if(_l_ >= _k_){
      var i = _k_;
      for(;;){
       caml_call2(Base_Option_array[52], t[2], i);
       var _m_ = i + 1 | 0;
       if(_l_ === i) break;
       var i = _m_;
      }
     }
     t[1] = write_index[1];
     return 0;
    }
    function _g_(param){
     var _i_ = caml_call2(Base_Import[93], t[1], 1), _h_ = 0;
     if(_i_ >= 0){
      var read_index = _h_;
      for(;;){
       var x = caml_call2(Base_Option_array[41], t[2], read_index);
       if(caml_call1(f, x)){
        if(write_index[1] < read_index)
         caml_call3(Base_Option_array[51], t[2], write_index[1], x);
        write_index[1]++;
       }
       var _j_ = read_index + 1 | 0;
       if(_i_ === read_index) break;
       var read_index = _j_;
      }
     }
     return 0;
    }
    return caml_call2(Base_Exn[13], _g_, _f_);
   }
   function singleton(x){var t = create(0); push(t, x); return t;}
   var
    Base_Stack =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       of_list,
       create,
       singleton,
       push,
       pop,
       pop_exn,
       top,
       top_exn,
       clear,
       copy,
       until_empty,
       filter_map,
       filter,
       filter_inplace,
       capacity,
       set_capacity];
   runtime.caml_register_global(19, Base_Stack, "Base__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position
//# unitInfo: Requires: Base__Comparable, Base__Import, Base__Int, Base__Source_code_position0, Base__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Int = global_data.Base__Int,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Comparable = global_data.Base__Comparable;
   function hash_override(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1],
     _b_ = caml_call1(Base_Int[8], pos_cnum),
     _c_ = caml_call1(Base_Int[8], pos_bol),
     _d_ = caml_call1(Base_Int[8], pos_lnum),
     _e_ = runtime.Base_hash_string(pos_fname),
     _f_ = caml_call2(Base_Import[121], _e_, _d_),
     _g_ = caml_call2(Base_Import[121], _f_, _c_);
    return caml_call2(Base_Import[121], _g_, _b_);
   }
   var
    compare_local = Base_Source_code_position0[2],
    hash_fold_t = Base_Source_code_position0[4],
    comparator = Base_Source_code_position0[6],
    to_string = Base_Source_code_position0[8],
    sexp_of_t = Base_Source_code_position0[9],
    include = caml_call1(Base_Comparable[12], [0, sexp_of_t, comparator]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator$0 = include[16];
   function equal_local(a, b){
    var _a_ = caml_call2(compare_local, a, b);
    return caml_call2(Base_Import[242], _a_, 0);
   }
   function of_pos(param){
    var pos_cnum = param[3], pos_lnum = param[2], pos_fname = param[1];
    return [0, pos_fname, pos_lnum, 0, pos_cnum];
   }
   var
    Base_Source_code_position =
      [0,
       hash_fold_t,
       hash_override,
       sexp_of_t,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator$0,
       equal_local,
       compare_local,
       to_string,
       of_pos];
   runtime.caml_register_global
    (4, Base_Source_code_position, "Base__Source_code_position");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign_or_nan
//# unitInfo: Requires: Base__Hash, Base__Identifiable, Base__Import, Base__Poly0, Base__Sign, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Nan = "Nan",
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_nan = "nan",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero$0 = "zero",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign_or_nan.ml.T.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0,
          [1, [0, cst_Zero, 0]],
          [0, [1, [0, cst_Pos, 0]], [0, [1, [0, cst_Nan, 0]], 0]]]]]],
    all = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    module_name = "Base.Sign_or_nan",
    Base_Sign = global_data.Base__Sign,
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Identifiable = global_data.Base__Identifiable,
    cst_negative = "negative",
    cst_zero = cst_zero$0,
    cst_positive = "positive",
    cst_not_a_number = "not-a-number",
    cst_Base_Sign_or_nan_to_sign_e = "Base.Sign_or_nan.to_sign_exn: Nan",
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos],
    _d_ = [0, cst_Nan];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _l_ = sexp_004[1];
      b:
      if(caml_string_notequal(_l_, cst_Nan)){
       c:
       if(caml_string_notequal(_l_, cst_Neg)){
        d:
        if(caml_string_notequal(_l_, cst_Pos)){
         if(caml_string_notequal(_l_, cst_Zero)){
          if(! caml_string_notequal(_l_, cst_nan)) break b;
          if(! caml_string_notequal(_l_, cst_neg)) break c;
          if(! caml_string_notequal(_l_, cst_pos)) break d;
          if(caml_string_notequal(_l_, cst_zero$0)) break a;
         }
         return 1;
        }
        return 2;
       }
       return 0;
      }
      return 3;
     }
     var _m_ = sexp_004[1];
     if(! _m_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_003, sexp_004);
     var _n_ = _m_[1];
     if(0 !== _n_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_003, sexp_004);
     var _o_ = _n_[1];
     b:
     if(caml_string_notequal(_o_, cst_Nan)){
      c:
      if(caml_string_notequal(_o_, cst_Neg)){
       d:
       if(caml_string_notequal(_o_, cst_Pos)){
        if(caml_string_notequal(_o_, cst_Zero)){
         if(! caml_string_notequal(_o_, cst_nan)) break b;
         if(! caml_string_notequal(_o_, cst_neg)) break c;
         if(! caml_string_notequal(_o_, cst_pos)) break d;
         if(caml_string_notequal(_o_, cst_zero$0)) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){
      case 0:
       return _a_;
      case 1:
       return _b_;
      case 2:
       return _c_;
      default: return _d_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       var _k_ = 0; break;
      case 1:
       var _k_ = 1; break;
      case 2:
       var _k_ = 2; break;
      default: var _k_ = 3;
    }
    return caml_call2(Base_Hash[3], hsv, _k_);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _j_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _j_);
   }
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[136], s));}
   function to_string(t){
    var _i_ = sexp_of_t(t);
    return caml_call1(Base_Import[160], _i_);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare, compare_local = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function equal_local(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    _e_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = _e_[1],
    hash$0 = _e_[2],
    t_of_sexp$0 = _e_[3],
    sexp_of_t$0 = _e_[4],
    of_string$0 = _e_[5],
    to_string$0 = _e_[6],
    between = _e_[19],
    clamp_exn = _e_[20],
    clamp = _e_[21],
    comparator = _e_[22],
    pp = _e_[23],
    hashable = _e_[24];
   function of_sign(param){
    switch(param){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function to_sign_exn(param){
    switch(param){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      default:
       return caml_call1(Base_Import[126], cst_Base_Sign_or_nan_to_sign_e);
    }
   }
   function of_int(n){return of_sign(caml_call1(Base_Sign[30], n));}
   function to_int_exn(t){
    var _h_ = to_sign_exn(t);
    return caml_call1(Base_Sign[31], _h_);
   }
   function flip(param){
    switch(param){
      case 0:
       return 2;
      case 1:
       return 1;
      case 2:
       return 0;
      default: return 3;
    }
   }
   function symbol$5(t$0, t){
    if(3 > t$0 && 3 > t){
     var _f_ = to_sign_exn(t), _g_ = to_sign_exn(t$0);
     return of_sign(caml_call2(Base_Sign[34], _g_, _f_));
    }
    return 3;
   }
   function to_string_hum(param){
    switch(param){
      case 0:
       return cst_negative;
      case 1:
       return cst_zero;
      case 2:
       return cst_positive;
      default: return cst_not_a_number;
    }
   }
   var
    Base_Sign_or_nan =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       compare_local,
       equal_local,
       to_string_hum,
       of_int,
       to_int_exn,
       of_sign,
       to_sign_exn,
       flip,
       symbol$5];
   runtime.caml_register_global(35, Base_Sign_or_nan, "Base__Sign_or_nan");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp_with_comparable
//# unitInfo: Requires: Base__Comparable, Base__Sexp
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Base_Comparable = global_data.Base__Comparable,
    _a_ = caml_call1(Base_Comparable[11], [0, Base_Sexp[7], Base_Sexp[5]]),
    symbol = _a_[1],
    symbol$0 = _a_[2],
    symbol$1 = _a_[3],
    symbol$2 = _a_[4],
    symbol$3 = _a_[5],
    symbol$4 = _a_[6],
    min = _a_[9],
    max = _a_[10],
    ascending = _a_[11],
    descending = _a_[12],
    between = _a_[13],
    clamp_exn = _a_[14],
    clamp = _a_[15],
    comparator = _a_[16],
    globalize = Base_Sexp[1],
    hash_fold_t = Base_Sexp[2],
    hash = Base_Sexp[3],
    t_of_sexp = Base_Sexp[4],
    sexp_of_t = Base_Sexp[5],
    equal = Base_Sexp[6],
    compare = Base_Sexp[7],
    Not_found_s = Base_Sexp[8],
    Of_sexp_error = Base_Sexp[9],
    message = Base_Sexp[10],
    default_indent = Base_Sexp[11],
    pp_hum = Base_Sexp[12],
    pp_hum_indent = Base_Sexp[13],
    pp_mach = Base_Sexp[14],
    pp = Base_Sexp[15],
    to_string_hum = Base_Sexp[16],
    to_string_mach = Base_Sexp[17],
    to_string = Base_Sexp[18],
    of_float_style = Base_Sexp[19],
    of_int_style = Base_Sexp[20],
    equal_local = Base_Sexp[22],
    compare_local = Base_Sexp[23],
    t_sexp_grammar = Base_Sexp[24],
    invariant = Base_Sexp[25],
    of_string = Base_Sexp[26],
    Base_Sexp_with_comparable =
      [0,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local];
   runtime.caml_register_global
    (2, Base_Sexp_with_comparable, "Base__Sexp_with_comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_immutable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Definitions = [0],
    Base_Dictionary_immutable_intf = [0, Definitions];
   runtime.caml_register_global
    (0, Base_Dictionary_immutable_intf, "Base__Dictionary_immutable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_immutable
//# unitInfo: Requires: Base__Dictionary_immutable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Dictionary_immutable = [0];
   runtime.caml_register_global
    (0, Base_Dictionary_immutable, "Base__Dictionary_immutable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hasher
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hasher = [0];
   runtime.caml_register_global(0, Base_Hasher, "Base__Hasher");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Maybe_bound
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Above_upper_bound = "Above_upper_bound",
    cst_Below_lower_bound = "Below_lower_bound",
    cst_Excl$0 = "Excl",
    cst_In_range = "In_range",
    cst_Incl$0 = "Incl",
    cst_Unbounded = "Unbounded",
    cst_above_upper_bound = "above_upper_bound",
    cst_below_lower_bound = "below_lower_bound",
    cst_excl = "excl",
    cst_in_range = "in_range",
    cst_incl = "incl",
    cst_unbounded = "unbounded",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_006 = "maybe_bound.ml.t",
    error_source_033 = "maybe_bound.ml.interval_comparison",
    interval_comparison_sexp_gramm =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Below_lower_bound, 0]],
         [0,
          [1, [0, cst_In_range, 0]],
          [0, [1, [0, cst_Above_upper_bound, 0]], 0]]]]],
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_List = global_data.Base__List,
    cst_Maybe_bound_compare_to_int =
      "Maybe_bound.compare_to_interval_exn: lower bound > upper bound",
    _f_ = [0, cst_Below_lower_bound],
    _g_ = [0, cst_In_range],
    _h_ = [0, cst_Above_upper_bound],
    _e_ = [0, [1, [0, cst_Unbounded, 0]], 0],
    cst_Excl = cst_Excl$0,
    cst_Incl = cst_Incl$0,
    _b_ = [0, cst_Unbounded],
    _c_ = [0, cst_Incl$0],
    _d_ = [0, cst_Excl$0],
    _a_ = [0, 0, 0];
   function all(all_of_a){
    var l = all_of_a, acc = 0;
    for(;;){
     if(! l) break;
     var
      l$0 = l[2],
      enumerate_002 = l[1],
      acc$0 = [0, [1, enumerate_002], acc],
      l = l$0,
      acc = acc$0;
    }
    var
     _r_ = caml_call1(Base_List[63], acc),
     l$1 = all_of_a,
     acc$1 = 0,
     _s_ = caml_call2(Base_List[10], _r_, _a_);
    for(;;){
     if(! l$1){
      var _t_ = caml_call1(Base_List[63], acc$1);
      return caml_call2(Base_List[10], _t_, _s_);
     }
     var
      l$2 = l$1[2],
      enumerate_001 = l$1[1],
      acc$2 = [0, [0, enumerate_001], acc$1],
      l$1 = l$2,
      acc$1 = acc$2;
    }
   }
   function t_of_sexp(of_a_003, sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var _o_ = sexp_008[1];
      b:
      if(caml_string_notequal(_o_, cst_Excl$0)){
       c:
       if(caml_string_notequal(_o_, cst_Incl$0)){
        if(caml_string_notequal(_o_, cst_Unbounded)){
         if(! caml_string_notequal(_o_, cst_excl)) break b;
         if(! caml_string_notequal(_o_, cst_incl)) break c;
         if(caml_string_notequal(_o_, cst_unbounded)) break a;
        }
        return 0;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_006, sexp_008);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_006, sexp_008);
     }
     var _p_ = sexp_008[1];
     if(! _p_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_006, sexp_008);
     var _q_ = _p_[1];
     if(0 !== _q_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_006, sexp_008);
     var tag_009 = _q_[1];
     b:
     if(caml_string_notequal(tag_009, cst_Excl$0)){
      c:
      if(caml_string_notequal(tag_009, cst_Incl$0)){
       if(caml_string_notequal(tag_009, cst_Unbounded)){
        if(! caml_string_notequal(tag_009, cst_excl)) break b;
        if(! caml_string_notequal(tag_009, cst_incl)) break c;
        if(caml_string_notequal(tag_009, cst_unbounded)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_008);
      }
      var sexp_args_010 = _p_[2];
      if(sexp_args_010 && ! sexp_args_010[2]){
       var
        arg0_011 = sexp_args_010[1],
        res0_012 = caml_call1(of_a_003, arg0_011);
       return [0, res0_012];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_006,
               tag_009,
               sexp_008);
     }
     var sexp_args_015 = _p_[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_a_003, arg0_016);
      return [1, res0_017];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_006,
              tag_009,
              sexp_008);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_006, sexp_008);
   }
   function sexp_of_t(of_a_019, param){
    if(typeof param === "number") return _b_;
    if(0 === param[0]){
     var arg0_020 = param[1], res0_021 = caml_call1(of_a_019, arg0_020);
     return [1, [0, _c_, [0, res0_021, 0]]];
    }
    var arg0_022 = param[1], res0_023 = caml_call1(of_a_019, arg0_022);
    return [1, [0, _d_, [0, res0_023, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Incl, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Excl, [0, [0, a_sexp_grammar, 0]]]], _e_]]]];
   }
   function globalize(globalize_a_026, x_027){
    if(typeof x_027 === "number") return x_027;
    if(0 === x_027[0]){
     var arg_029 = x_027[1];
     return [0, caml_call1(globalize_a_026, arg_029)];
    }
    var arg_030 = x_027[1];
    return [1, caml_call1(globalize_a_026, arg_030)];
   }
   function interval_comparison_of_sexp(sexp_034){
    a:
    {
     if(0 === sexp_034[0]){
      var _k_ = sexp_034[1];
      b:
      if(caml_string_notequal(_k_, cst_Above_upper_bound)){
       c:
       if(caml_string_notequal(_k_, cst_Below_lower_bound)){
        if(caml_string_notequal(_k_, cst_In_range)){
         if(! caml_string_notequal(_k_, cst_above_upper_bound)) break b;
         if(! caml_string_notequal(_k_, cst_below_lower_bound)) break c;
         if(caml_string_notequal(_k_, cst_in_range)) break a;
        }
        return 1;
       }
       return 0;
      }
      return 2;
     }
     var _l_ = sexp_034[1];
     if(! _l_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_033, sexp_034);
     var _m_ = _l_[1];
     if(0 !== _m_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_033, sexp_034);
     var _n_ = _m_[1];
     b:
     if(caml_string_notequal(_n_, cst_Above_upper_bound)){
      c:
      if(caml_string_notequal(_n_, cst_Below_lower_bound)){
       if(caml_string_notequal(_n_, cst_In_range)){
        if(! caml_string_notequal(_n_, cst_above_upper_bound)) break b;
        if(! caml_string_notequal(_n_, cst_below_lower_bound)) break c;
        if(caml_string_notequal(_n_, cst_in_range)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_033, sexp_034);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_033, sexp_034);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_033, sexp_034);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_033, sexp_034);
   }
   function sexp_of_interval_comparison(param){
    switch(param){case 0: return _f_;case 1: return _g_;default: return _h_;
    }
   }
   var
    compare_interval_comparison_lo = caml_int_compare,
    compare_interval_comparison = caml_int_compare;
   function hash_fold_interval_comparison(hsv, arg){
    switch(arg){
      case 0:
       var _j_ = 0; break;
      case 1:
       var _j_ = 1; break;
      default: var _j_ = 2;
    }
    return caml_call2(Base_Hash[3], hsv, _j_);
   }
   function hash_interval_comparison(arg){
    var
     hsv = caml_call2(Base_Hash[11], 0, 0),
     _i_ = hash_fold_interval_comparison(hsv, arg);
    return caml_call1(Base_Hash[9], _i_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var incl = t[1]; return [0, caml_call1(f, incl)];}
    var excl = t[1];
    return [1, caml_call1(f, excl)];
   }
   function is_lower_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, incl, a) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, excl, a) < 0 ? 1 : 0;
   }
   function is_upper_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, a, incl) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, a, excl) < 0 ? 1 : 0;
   }
   function bounds_crossed(lower, upper, compare){
    if(typeof lower === "number") return 0;
    var lower$0 = lower[1];
    if(typeof upper === "number") return 0;
    var upper$0 = upper[1];
    return 0 < caml_call2(compare, lower$0, upper$0) ? 1 : 0;
   }
   function compare_to_interval_exn(lower, upper, a, compare){
    if(bounds_crossed(lower, upper, compare))
     caml_call1(Base_Import[124], cst_Maybe_bound_compare_to_int);
    return is_lower_bound(lower, a, compare)
            ? is_upper_bound(upper, a, compare) ? 1 : 2
            : 0;
   }
   function interval_contains_exn(lower, upper, a, compare){
    return 1 === compare_to_interval_exn(lower, upper, a, compare) ? 1 : 0;
   }
   var
    Base_Maybe_bound =
      [0,
       all,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       globalize,
       map,
       is_lower_bound,
       is_upper_bound,
       interval_contains_exn,
       bounds_crossed,
       sexp_of_interval_comparison,
       interval_comparison_of_sexp,
       interval_comparison_sexp_gramm,
       compare_interval_comparison,
       compare_interval_comparison_lo,
       hash_fold_interval_comparison,
       hash_interval_comparison,
       compare_to_interval_exn];
   runtime.caml_register_global(42, Base_Maybe_bound, "Base__Maybe_bound");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map_intf
//# unitInfo: Requires: Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Unequal$0 = "Unequal",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_057 = "map_intf.ml.Symmetric_diff_element.t",
    all = [0, 0, [0, 1, 0]],
    all$0 = [0, 0, [0, 1, 0]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _k_ = [0, "Unfinished"],
    _l_ = [0, "Finished"],
    _i_ = [0, "Stop"],
    _j_ = [0, "Continue"],
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0],
    _f_ = [0, "Both"],
    cst_Unequal = cst_Unequal$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0,
    _d_ = [0, cst_Unequal$0],
    _e_ = [0, cst_Right$0],
    _c_ = [0, cst_Left$0],
    _a_ = [0, "Duplicate"],
    _b_ = [0, "Ok"];
   function compare(cmp_a, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(typeof a_001 === "number"){
     if(typeof b_002 === "number" && -1024851605 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 17724 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return caml_compare(a_001, b_002);
   }
   function equal(cmp_a, a_005, b_006){
    if(a_005 === b_006) return 1;
    if(typeof a_005 === "number"){
     if(typeof b_006 === "number" && -1024851605 === b_006) return 1;
    }
    else if(typeof b_006 !== "number" && 17724 === b_006[1]){
     var right_008 = b_006[2], left_007 = a_005[2];
     return caml_call2(cmp_a, left_007, right_008);
    }
    return caml_equal(a_005, b_006);
   }
   function sexp_of_t(of_a_009, param){
    if(typeof param === "number") return _a_;
    var v_010 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_009, v_010), 0]]];
   }
   var
    Or_duplicate = [0, compare, equal, sexp_of_t],
    Without_comparator = [0],
    With_comparator = [0],
    With_first_class_module = [0];
   function compare$0(cmp_k, cmp_v, a_011, b_012){
    var
     t_014 = a_011[2],
     t_013 = a_011[1],
     t_016 = b_012[2],
     t_015 = b_012[1],
     n = caml_call2(cmp_k, t_013, t_015);
    if(0 !== n) return n;
    if(t_014 === t_016) return 0;
    var _O_ = t_014[1];
    if(847852583 === _O_){
     if(typeof t_016 !== "number" && 847852583 === t_016[1]){
      var right_018 = t_016[2], left_017 = t_014[2];
      return caml_call2(cmp_v, left_017, right_018);
     }
    }
    else
     if(1013247643 <= _O_){
      if(typeof t_016 !== "number" && 1013247643 === t_016[1]){
       var
        right_022 = t_016[2],
        left_021 = t_014[2],
        t_024 = left_021[2],
        t_023 = left_021[1],
        t_026 = right_022[2],
        t_025 = right_022[1],
        n$0 = caml_call2(cmp_v, t_023, t_025);
       return 0 === n$0 ? caml_call2(cmp_v, t_024, t_026) : n$0;
      }
     }
     else if(typeof t_016 !== "number" && -57574468 === t_016[1]){
      var right_020 = t_016[2], left_019 = t_014[2];
      return caml_call2(cmp_v, left_019, right_020);
     }
    return caml_compare(t_014, t_016);
   }
   function equal$0(cmp_k, cmp_v, a_027, b_028){
    var
     t_030 = a_027[2],
     t_029 = a_027[1],
     t_032 = b_028[2],
     t_031 = b_028[1],
     _K_ = caml_call2(cmp_k, t_029, t_031);
    if(_K_){
     if(t_030 === t_032) return 1;
     var _L_ = t_030[1];
     if(847852583 === _L_){
      if(typeof t_032 !== "number" && 847852583 === t_032[1]){
       var right_034 = t_032[2], left_033 = t_030[2];
       return caml_call2(cmp_v, left_033, right_034);
      }
     }
     else
      if(1013247643 <= _L_){
       if(typeof t_032 !== "number" && 1013247643 === t_032[1]){
        var
         right_038 = t_032[2],
         left_037 = t_030[2],
         t_040 = left_037[2],
         t_039 = left_037[1],
         t_042 = right_038[2],
         t_041 = right_038[1],
         _N_ = caml_call2(cmp_v, t_039, t_041);
        return _N_ ? caml_call2(cmp_v, t_040, t_042) : _N_;
       }
      }
      else if(typeof t_032 !== "number" && -57574468 === t_032[1]){
       var right_036 = t_032[2], left_035 = t_030[2];
       return caml_call2(cmp_v, left_035, right_036);
      }
     var _M_ = caml_equal(t_030, t_032);
    }
    else
     var _M_ = _K_;
    return _M_;
   }
   function t_of_sexp(of_k_043, of_v_044, sexp_071){
    if(1 === sexp_071[0]){
     var _v_ = sexp_071[1];
     if(_v_){
      var _w_ = _v_[2];
      if(_w_ && ! _w_[2]){
       var
        arg1_068 = _w_[1],
        arg0_067 = _v_[1],
        res0_069 = caml_call1(of_k_043, arg0_067);
       try{
        if(0 === arg1_068[0])
         var
          atom_047 = arg1_068[1],
          _y_ =
            caml_string_notequal(atom_047, cst_Left$0)
             ? caml_string_notequal
                (atom_047, cst_Right$0)
               ? caml_string_notequal
                  (atom_047, cst_Unequal$0)
                 ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
                 : caml_call2
                   (Sexplib0_Sexp_conv_error[27], error_source_057, arg1_068)
               : caml_call2
                 (Sexplib0_Sexp_conv_error[27], error_source_057, arg1_068)
             : caml_call2
               (Sexplib0_Sexp_conv_error[27], error_source_057, arg1_068),
          _z_ = _y_;
        else{
         var _A_ = arg1_068[1];
         if(_A_){
          var match = _A_[1];
          if(0 === match[0]){
           var sexp_args_050 = _A_[2], atom_047$0 = match[1];
           if(caml_string_notequal(atom_047$0, cst_Left$0))
            if(caml_string_notequal(atom_047$0, cst_Right$0))
             if(caml_string_notequal(atom_047$0, cst_Unequal$0))
              var _B_ = caml_call1(Sexplib0_Sexp_conv_error[23], 0);
             else{
              a:
              {
               if(sexp_args_050 && ! sexp_args_050[2]){
                var arg0_058 = sexp_args_050[1];
                b:
                {
                 if(1 === arg0_058[0]){
                  var _F_ = arg0_058[1];
                  if(_F_){
                   var _G_ = _F_[2];
                   if(_G_ && ! _G_[2]){
                    var
                     arg1_053 = _G_[1],
                     arg0_052 = _F_[1],
                     res0_054 = caml_call1(of_v_044, arg0_052),
                     res1_055 = caml_call1(of_v_044, arg1_053),
                     res0_059 = [0, res0_054, res1_055];
                    break b;
                   }
                  }
                 }
                 var
                  res0_059 =
                    caml_call3
                     (Sexplib0_Sexp_conv_error[4], error_source_057, 2, arg0_058);
                }
                var _E_ = [0, 1013247643, res0_059];
                break a;
               }
               var
                _E_ =
                  caml_call3
                   (Sexplib0_Sexp_conv_error[26],
                    error_source_057,
                    atom_047$0,
                    arg1_068);
              }
              var _B_ = _E_;
             }
            else{
             a:
             {
              if(sexp_args_050 && ! sexp_args_050[2]){
               var
                arg0_061 = sexp_args_050[1],
                res0_062 = caml_call1(of_v_044, arg0_061),
                _H_ = [0, -57574468, res0_062];
               break a;
              }
              var
               _H_ =
                 caml_call3
                  (Sexplib0_Sexp_conv_error[26],
                   error_source_057,
                   atom_047$0,
                   arg1_068);
             }
             var _B_ = _H_;
            }
           else{
            a:
            {
             if(sexp_args_050 && ! sexp_args_050[2]){
              var
               arg0_064 = sexp_args_050[1],
               res0_065 = caml_call1(of_v_044, arg0_064),
               _I_ = [0, 847852583, res0_065];
              break a;
             }
             var
              _I_ =
                caml_call3
                 (Sexplib0_Sexp_conv_error[26],
                  error_source_057,
                  atom_047$0,
                  arg1_068);
            }
            var _B_ = _I_;
           }
           var _C_ = _B_;
          }
          else
           var
            _C_ =
              caml_call2
               (Sexplib0_Sexp_conv_error[28], error_source_057, arg1_068);
          var _D_ = _C_;
         }
         else
          var
           _D_ =
             caml_call2
              (Sexplib0_Sexp_conv_error[29], error_source_057, arg1_068);
         var _z_ = _D_;
        }
        var res1_070 = _z_;
       }
       catch(_J_){
        var _x_ = caml_wrap_exception(_J_);
        if(_x_ !== Sexplib0_Sexp_conv_error[22])
         throw caml_maybe_attach_backtrace(_x_, 0);
        var
         res1_070 =
           caml_call2
            (Sexplib0_Sexp_conv_error[24], error_source_057, arg1_068);
       }
       return [0, res0_069, res1_070];
      }
     }
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[4], error_source_057, 2, sexp_071);
   }
   function sexp_of_t$0(of_k_072, of_v_073, param){
    var
     arg1_082 = param[2],
     arg0_081 = param[1],
     res0_083 = caml_call1(of_k_072, arg0_081),
     _u_ = arg1_082[1];
    if(847852583 === _u_)
     var
      v_074 = arg1_082[2],
      res1_084 = [1, [0, _c_, [0, caml_call1(of_v_073, v_074), 0]]];
    else if(1013247643 <= _u_)
     var
      v_076 = arg1_082[2],
      arg1_078 = v_076[2],
      arg0_077 = v_076[1],
      res0_079 = caml_call1(of_v_073, arg0_077),
      res1_080 = caml_call1(of_v_073, arg1_078),
      res1_084 = [1, [0, _d_, [0, [1, [0, res0_079, [0, res1_080, 0]]], 0]]];
    else
     var
      v_075 = arg1_082[2],
      res1_084 = [1, [0, _e_, [0, caml_call1(of_v_073, v_075), 0]]];
    return [1, [0, res0_083, [0, res1_084, 0]]];
   }
   function t_sexp_grammar(k_sexp_grammar, v_sexp_grammar){
    return [2,
            [0,
             k_sexp_grammar,
             [0,
              [3,
               [0,
                1,
                [0,
                 [1, [0, cst_Left, [0, [0, v_sexp_grammar, 0]]]],
                 [0,
                  [1, [0, cst_Right, [0, [0, v_sexp_grammar, 0]]]],
                  [0,
                   [1,
                    [0,
                     cst_Unequal,
                     [0,
                      [0, [2, [0, v_sexp_grammar, [0, v_sexp_grammar, 0]]], 0]]]],
                   0]]]]],
              0]]];
   }
   var
    Symmetric_diff_element =
      [0, compare$0, equal$0, t_of_sexp, sexp_of_t$0, t_sexp_grammar];
   function compare$1(cmp_left, cmp_right, a_085, b_086){
    if(a_085 === b_086) return 0;
    var _t_ = a_085[1];
    if(737457313 === _t_){
     if(typeof b_086 !== "number" && 737457313 === b_086[1]){
      var
       right_092 = b_086[2],
       left_091 = a_085[2],
       t_094 = left_091[2],
       t_093 = left_091[1],
       t_096 = right_092[2],
       t_095 = right_092[1],
       n = caml_call2(cmp_left, t_093, t_095);
      return 0 === n ? caml_call2(cmp_right, t_094, t_096) : n;
     }
    }
    else
     if(847852583 <= _t_){
      if(typeof b_086 !== "number" && 847852583 === b_086[1]){
       var right_088 = b_086[2], left_087 = a_085[2];
       return caml_call2(cmp_left, left_087, right_088);
      }
     }
     else if(typeof b_086 !== "number" && -57574468 === b_086[1]){
      var right_090 = b_086[2], left_089 = a_085[2];
      return caml_call2(cmp_right, left_089, right_090);
     }
    return caml_compare(a_085, b_086);
   }
   function equal$1(cmp_left, cmp_right, a_097, b_098){
    if(a_097 === b_098) return 1;
    var _r_ = a_097[1];
    if(737457313 === _r_){
     if(typeof b_098 !== "number" && 737457313 === b_098[1]){
      var
       right_104 = b_098[2],
       left_103 = a_097[2],
       t_106 = left_103[2],
       t_105 = left_103[1],
       t_108 = right_104[2],
       t_107 = right_104[1],
       _s_ = caml_call2(cmp_left, t_105, t_107);
      return _s_ ? caml_call2(cmp_right, t_106, t_108) : _s_;
     }
    }
    else
     if(847852583 <= _r_){
      if(typeof b_098 !== "number" && 847852583 === b_098[1]){
       var right_100 = b_098[2], left_099 = a_097[2];
       return caml_call2(cmp_left, left_099, right_100);
      }
     }
     else if(typeof b_098 !== "number" && -57574468 === b_098[1]){
      var right_102 = b_098[2], left_101 = a_097[2];
      return caml_call2(cmp_right, left_101, right_102);
     }
    return caml_equal(a_097, b_098);
   }
   function sexp_of_t$1(of_left_109, of_right_110, param){
    var _q_ = param[1];
    if(737457313 === _q_){
     var
      v_113 = param[2],
      arg1_115 = v_113[2],
      arg0_114 = v_113[1],
      res0_116 = caml_call1(of_left_109, arg0_114),
      res1_117 = caml_call1(of_right_110, arg1_115);
     return [1, [0, _f_, [0, [1, [0, res0_116, [0, res1_117, 0]]], 0]]];
    }
    if(847852583 <= _q_){
     var v_111 = param[2];
     return [1, [0, _g_, [0, caml_call1(of_left_109, v_111), 0]]];
    }
    var v_112 = param[2];
    return [1, [0, _h_, [0, caml_call1(of_right_110, v_112), 0]]];
   }
   var
    Merge_element = [0, compare$1, equal$1, sexp_of_t$1],
    compare$2 = caml_int_compare;
   function equal$2(_p_, _o_){return _p_ === _o_ ? 1 : 0;}
   function sexp_of_t$2(param){return param ? _i_ : _j_;}
   var
    Continue_or_stop = [0, compare$2, all, equal$2, sexp_of_t$2],
    compare$3 = caml_int_compare;
   function equal$3(_n_, _m_){return _n_ === _m_ ? 1 : 0;}
   function sexp_of_t$3(param){return param ? _k_ : _l_;}
   var
    Finished_or_unfinished = [0, compare$3, all$0, equal$3, sexp_of_t$3],
    Base_Map_intf =
      [0,
       Or_duplicate,
       Without_comparator,
       With_comparator,
       With_first_class_module,
       Symmetric_diff_element,
       Merge_element,
       Continue_or_stop,
       Finished_or_unfinished];
   runtime.caml_register_global(25, Base_Map_intf, "Base__Map_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Named = [0],
    Base_Set_intf = [0, Named];
   runtime.caml_register_global(0, Base_Set_intf, "Base__Set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set
//# unitInfo: Requires: Base__Array, Base__Comparator, Base__Container, Base__Exn, Base__Fn, Base__Hash, Base__Import, Base__List, Base__Option, Base__Or_error, Base__Sequence, Base__Set_intf, Base__Sexp, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_set_ml = "src/set.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Or_error = global_data.Base__Or_error,
    Base_Container = global_data.Base__Container,
    Base_List = global_data.Base__List,
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Fn = global_data.Base__Fn,
    Base_Option = global_data.Base__Option,
    Base_Exn = global_data.Base__Exn,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    with_return = Base_With_return[1],
    _v_ = [0, "_"],
    cst_Set_remove_min_elt = "Set.remove_min_elt",
    _p_ = [0, 0, 0],
    _q_ = [0, 0, 0],
    _u_ = [0, 0],
    cst_invalid_elements = "invalid_elements",
    cst_is_not_a_subset_of = " is not a subset of ",
    cst_Set_t_of_sexp_duplicate_el = "Set.t_of_sexp: duplicate element in set",
    cst_Set_t_of_sexp_list_needed = "Set.t_of_sexp: list needed",
    _t_ = [0, cst_src_set_ml, 1120, 8],
    cst_Set_find_exn_failed_to_fin =
      "Set.find_exn failed to find a matching element",
    _r_ = [0, 0, 0],
    _o_ = [0, 0, 0, 0],
    _m_ = [0, "set.ml.Tree0.Set_max_elt_exn_of_empty_set"],
    _n_ = [0, cst_src_set_ml, 289, 13],
    _j_ = [0, "set.ml.Tree0.Set_min_elt_exn_of_empty_set"],
    _k_ = [0, cst_src_set_ml, 276, 13],
    _a_ = [0, cst_src_set_ml, 169, 17],
    _b_ = [0, cst_src_set_ml, 170, 28],
    _c_ = [0, cst_src_set_ml, 176, 21],
    _d_ = [0, cst_src_set_ml, 178, 12],
    _e_ = [0, cst_src_set_ml, 185, 17],
    _f_ = [0, cst_src_set_ml, 186, 28],
    _g_ = [0, cst_src_set_ml, 192, 21],
    _h_ = [0, cst_src_set_ml, 194, 12],
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_Base_Set_Tree0_Same = "Base__Set.Tree0.Same",
    cst_Base_Set_Tree0_Set_min_elt =
      "Base__Set.Tree0.Set_min_elt_exn_of_empty_set",
    cst_Base_Set_Tree0_Set_max_elt =
      "Base__Set.Tree0.Set_max_elt_exn_of_empty_set",
    _s_ = [0, "Set.choose_exn: empty set"];
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[4];
    return h;
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var s = param[5];
    return s;
   }
   function in_range(lower, upper, compare_elt, v){
    if(lower)
     var
      lower$0 = lower[1],
      _bM_ = caml_call2(compare_elt, lower$0, v) < 0 ? 1 : 0;
    else
     var _bM_ = 1;
    if(_bM_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_elt, v, upper$0) < 0 ? 1 : 0;
     }
     var _bN_ = 1;
    }
    else
     var _bN_ = _bM_;
    return _bN_;
   }
   function loop(lower, upper, compare_elt, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var v = t$0[1];
      return in_range(lower$0, upper, compare_elt, v);
     }
     var
      n = t$0[5],
      h = t$0[4],
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _bB_ = caml_call2(Base_Import[93], hl, hr),
      _bC_ = caml_call1(Base_Import[123], _bB_) <= 2 ? 1 : 0;
     if(_bC_){
      var
       _bD_ = caml_call2(Base_Import[100], hl, hr),
       _bE_ = h === caml_call2(Base_Import[91], _bD_, 1) ? 1 : 0;
      if(_bE_){
       var
        _bF_ = length(r),
        _bG_ = length(l),
        _bH_ = caml_call2(Base_Import[91], _bG_, _bF_),
        _bI_ = n === caml_call2(Base_Import[91], _bH_, 1) ? 1 : 0;
       if(_bI_){
        var _bJ_ = in_range(lower$0, upper, compare_elt, v$0);
        if(_bJ_){
         var _bK_ = loop(lower$0, [0, v$0], compare_elt, l);
         if(_bK_){
          var lower$1 = [0, v$0], lower$0 = lower$1, t$0 = r;
          continue;
         }
         var _bL_ = _bK_;
        }
        else
         var _bL_ = _bJ_;
       }
       else
        var _bL_ = _bI_;
      }
      else
       var _bL_ = _bE_;
     }
     else
      var _bL_ = _bC_;
     return _bL_;
    }
   }
   function invariants(t, compare_elt){return loop(0, 0, compare_elt, t);}
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function create(l, v, r){
    var
     hl = height(l),
     hr = height(r),
     h =
       hr <= hl
        ? caml_call2(Base_Import[91], hl, 1)
        : caml_call2(Base_Import[91], hr, 1);
    if(1 === h) return [0, v];
    var
     sl = length(l),
     sr = length(r),
     _bA_ = caml_call2(Base_Import[91], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[91], _bA_, 1)];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var k$0 = caml_call1(f, i); return [0, k$0];
        case 2:
         var
          kl = caml_call1(f, i),
          k$1 = caml_call1(f, caml_call2(Base_Import[91], i, 1));
         return create([0, kl], k$1, 0);
        default:
         var
          kl$0 = caml_call1(f, i),
          k$2 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          kr = caml_call1(f, caml_call2(Base_Import[91], i, 2));
         return create([0, kl$0], k$2, [0, kr]);
      }
     var
      left_length = caml_call2(Base_Import[120], n, 1),
      _by_ = caml_call2(Base_Import[93], n, left_length),
      right_length = caml_call2(Base_Import[93], _by_, 1),
      left = loop(left_length, f, i),
      k = caml_call1(f, caml_call2(Base_Import[91], i, left_length)),
      _bz_ = caml_call2(Base_Import[91], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[91], _bz_, 1));
     return create(left, k, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_elt){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var _bv_ = caml_check_bound(array, 1)[2];
      if(0 <= caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bv_)){
       var
        next =
          function(i){
           var
            _bw_ = caml_call2(Base_Import[93], array_length, 1),
            _bx_ = caml_call2(Base_Import[93], _bw_, i);
           return caml_check_bound(array, _bx_)[1 + _bx_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return of_increasing_iterator_uncheck(array_length, next);
   }
   function of_sorted_array(array, compare_elt){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _bp_ = caml_check_bound(array, 1)[2],
                i =
                  caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bp_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[40], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _br_ = caml_call2(Base_Import[93], array.length - 1, 2),
                _bq_ = 1;
               if(_br_ >= 1){
                var i$0 = _bq_;
                for(;;){
                 var
                  _bs_ = caml_call2(Base_Import[91], i$0, 1),
                  _bt_ = caml_check_bound(array, _bs_)[1 + _bs_],
                  i$1 =
                    caml_call2
                     (compare_elt, caml_check_bound(array, i$0)[1 + i$0], _bt_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[40], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[40], cst_of_sorted_array_elements_a));
                 var _bu_ = i$0 + 1 | 0;
                 if(_br_ === i$0) break;
                 var i$0 = _bu_;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_elt)];
              });
    return [0, of_sorted_array_unchecked(array, compare_elt)];
   }
   function bal(l, v, r){
    var hl = height(l), hr = height(r);
    if(caml_call2(Base_Import[91], hr, 2) < hl){
     if(typeof l === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var lr = l[3], lv = l[2], ll = l[1], _bj_ = height(lr);
     if(_bj_ <= height(ll)) return create(ll, lv, create(lr, v, r));
     if(typeof lr === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     if(0 !== lr[0]){
      var lrr = lr[3], lrv$0 = lr[2], lrl = lr[1], _bl_ = create(lrr, v, r);
      return create(create(ll, lv, lrl), lrv$0, _bl_);
     }
     var lrv = lr[1];
     if(! is_empty(ll))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var _bk_ = create(0, v, r);
     return create(create(ll, lv, 0), lrv, _bk_);
    }
    if(caml_call2(Base_Import[91], hl, 2) >= hr) return create(l, v, r);
    if(typeof r === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var rr = r[3], rv = r[2], rl = r[1], _bm_ = height(rl);
    if(_bm_ <= height(rr)) return create(create(l, v, rl), rv, rr);
    if(typeof rl === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    if(0 !== rl[0]){
     var rlr = rl[3], rlv$0 = rl[2], rll = rl[1], _bo_ = create(rlr, rv, rr);
     return create(create(l, v, rll), rlv$0, _bo_);
    }
    var rlv = rl[1];
    if(! is_empty(rr))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var _bn_ = create(0, rv, rr);
    return create(create(l, v, 0), rlv, _bn_);
   }
   var Same = [248, cst_Base_Set_Tree0_Same, caml_fresh_oo_id(0)];
   function add(t, x, compare_elt){
    function aux(param){
     if(typeof param === "number") return [0, x];
     if(0 === param[0]){
      var v = param[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? caml_call1(Base_Exn[6], Same)
              : 0 <= c ? create(0, v, [0, x]) : create([0, x], v, 0);
     }
     var
      r = param[3],
      v$0 = param[2],
      l = param[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     return 0 === c$0
             ? caml_call1(Base_Exn[6], Same)
             : 0 <= c$0 ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var _bh_ = aux(t); return _bh_;}
    catch(_bi_){
     var _bg_ = caml_wrap_exception(_bi_);
     if(_bg_ === Same) return t;
     throw caml_maybe_attach_backtrace(_bg_, 0);
    }
   }
   function add_min(x, t){
    if(typeof t === "number") return [0, x];
    if(0 === t[0]) return [1, 0, x, t, 2, 2];
    var r = t[3], v = t[2], l = t[1];
    return bal(add_min(x, l), v, r);
   }
   function add_max(t, x){
    if(typeof t === "number") return [0, x];
    if(0 === t[0]) return [1, t, x, 0, 2, 2];
    var r = t[3], v = t[2], l = t[1];
    return bal(l, v, add_max(r, x));
   }
   function join(l, v, r){
    if(typeof l === "number") return add_min(v, r);
    if(1 === l[0]){
     var lh = l[4], lr = l[3], lv$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){var rv = r[1]; return add_max(add_max(l, v), rv);}
      var rh = r[4], rr = r[3], rv$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[91], rh, 2) < lh
              ? bal(ll, lv$0, join(lr, v, r))
              : caml_call2
                 (Base_Import[91], lh, 2)
                < rh
                ? bal(join(l, v, rl), rv$0, rr)
                : create(l, v, r);
     }
    }
    if(typeof r === "number") return add_max(l, v);
    var lv = l[1];
    return add_min(lv, add_min(v, r));
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      var l = param$0[1];
      if(typeof l !== "number"){var param$0 = l; continue;}
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   var
    Set_min_elt_exn_of_empty_set =
      [248, cst_Base_Set_Tree0_Set_min_elt, caml_fresh_oo_id(0)];
   function _i_(param){
    if(param === Set_min_elt_exn_of_empty_set) return _j_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Set_min_elt_exn_of_empty_set, _i_);
   var
    Set_max_elt_exn_of_empty_set =
      [248, cst_Base_Set_Tree0_Set_max_elt, caml_fresh_oo_id(0)];
   function _l_(param){
    if(param === Set_max_elt_exn_of_empty_set) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Set_max_elt_exn_of_empty_set, _l_);
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_min_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function fold_until(t, init, f, finish){
    function fold_until_helper(f, t, acc){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var value = t$0[1];
       return caml_call2(f, acc$0, value);
      }
      var
       right = t$0[3],
       value$0 = t$0[2],
       left = t$0[1],
       x = fold_until_helper(f, left, acc$0);
      if(0 !== x[0]) return x;
      var acc$1 = x[1], x$0 = caml_call2(f, acc$1, value$0);
      if(0 !== x$0[0]) return x$0;
      var acc$2 = x$0[1], t$0 = right, acc$0 = acc$2;
     }
    }
    var match = fold_until_helper(f, t, init);
    if(0 === match[0]){var x = match[1]; return caml_call1(finish, x);}
    var x$0 = match[1];
    return x$0;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      if(typeof param$0[3] !== "number"){
       var r = param$0[3], param$0 = r;
       continue;
      }
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_max_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(param){
    if(typeof param === "number")
     return caml_call1(Base_Import[126], cst_Set_remove_min_elt);
    if(0 === param[0]) return 0;
    var l = param[1];
    if(typeof l === "number"){var r = param[3]; return r;}
    var r$0 = param[3], v = param[2];
    return bal(remove_min_elt(l), v, r$0);
   }
   function merge(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var _bf_ = remove_min_elt(t2);
    return bal(t1, min_elt_exn(t2), _bf_);
   }
   function concat(t1, t2){
    if(typeof t1 === "number")
     var t = t2;
    else{
     if(typeof t2 !== "number"){
      var _be_ = remove_min_elt(t2);
      return join(t1, min_elt_exn(t2), _be_);
     }
     var t = t1;
    }
    return t;
   }
   function split(t, x, compare_elt){
    function split(t){
     if(typeof t === "number") return _o_;
     if(0 === t[0]){
      var v = t[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? [0, 0, [0, v], 0]
              : 0 <= c ? [0, [0, v], 0, 0] : [0, 0, 0, [0, v]];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) return [0, l, [0, v$0], r];
     if(0 <= c$0){
      var
       match = split(r),
       rr = match[3],
       maybe_elt = match[2],
       lr = match[1];
      return [0, join(l, v$0, lr), maybe_elt, rr];
     }
     var
      match$0 = split(l),
      rl = match$0[3],
      maybe_elt$0 = match$0[2],
      ll = match$0[1];
     return [0, ll, maybe_elt$0, join(rl, v$0, r)];
    }
    return split(t);
   }
   function split_le_gt(t, x, compare_elt){
    if(typeof t === "number") return _p_;
    if(0 === t[0]){
     var v = t[1];
     return 0 <= caml_call2(compare_elt, x, v)
             ? [0, [0, v], 0]
             : [0, 0, [0, v]];
    }
    var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
    if(0 === c) return [0, add_max(l, v$0), r];
    if(0 <= c){
     var match = split_le_gt(r, x, compare_elt), rr = match[2], lr = match[1];
     return [0, join(l, v$0, lr), rr];
    }
    var
     match$0 = split_le_gt(l, x, compare_elt),
     rl = match$0[2],
     ll = match$0[1];
    return [0, ll, join(rl, v$0, r)];
   }
   function split_lt_ge(t, x, compare_elt){
    if(typeof t === "number") return _q_;
    if(0 === t[0]){
     var v = t[1];
     return 0 < caml_call2(compare_elt, x, v)
             ? [0, [0, v], 0]
             : [0, 0, [0, v]];
    }
    var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
    if(0 === c) return [0, l, add_min(v$0, r)];
    if(0 <= c){
     var match = split_lt_ge(r, x, compare_elt), rr = match[2], lr = match[1];
     return [0, join(l, v$0, lr), rr];
    }
    var
     match$0 = split_lt_ge(l, x, compare_elt),
     rl = match$0[2],
     ll = match$0[1];
    return [0, ll, join(rl, v$0, r)];
   }
   var empty_without_value_restrictio = 0;
   function mem(t, x, compare_elt){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[1], c = caml_call2(compare_elt, x, v);
      return 0 === c ? 1 : 0;
     }
     var
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c$0 = caml_call2(compare_elt, x, v$0),
      _bd_ = 0 === c$0 ? 1 : 0;
     if(_bd_) return _bd_;
     var r$0 = 0 <= c$0 ? r : l, t$0 = r$0;
    }
   }
   function remove(t, x, compare_elt){
    function aux(t){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Same);
     if(0 === t[0]){
      var v = t[1];
      return 0 === caml_call2(compare_elt, x, v)
              ? 0
              : caml_call1(Base_Exn[6], Same);
     }
     var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
     return 0 === c
             ? merge(l, r)
             : 0 <= c ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var _bb_ = aux(t); return _bb_;}
    catch(_bc_){
     var _ba_ = caml_wrap_exception(_bc_);
     if(_ba_ === Same) return t;
     throw caml_maybe_attach_backtrace(_ba_, 0);
    }
   }
   function remove_index(t, i, param){
    function aux(t, i){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Same);
     if(0 === t[0]) return 0 === i ? 0 : caml_call1(Base_Exn[6], Same);
     var
      r = t[3],
      v = t[2],
      l = t[1],
      l_size = length(l),
      c = caml_int_compare(i, l_size);
     if(0 === c) return merge(l, r);
     if(0 > c) return bal(aux(l, i), v, r);
     var _a$_ = caml_call2(Base_Import[93], i, l_size);
     return bal(l, v, aux(r, caml_call2(Base_Import[93], _a$_, 1)));
    }
    try{var _a9_ = aux(t, i); return _a9_;}
    catch(_a__){
     var _a8_ = caml_wrap_exception(_a__);
     if(_a8_ === Same) return t;
     throw caml_maybe_attach_backtrace(_a8_, 0);
    }
   }
   function union(s1, s2, compare_elt){
    function union(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(s1$0 === s2$0) return s1$0;
      if(typeof s1$0 === "number")
       var t = s2$0;
      else{
       if(1 === s1$0[0]){
        var h1 = s1$0[4], r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
        if(typeof s2$0 !== "number"){
         if(0 === s2$0[0]){
          var v2 = s2$0[1], s2$1 = [1, 0, v2, 0, 1, 1], s2$0 = s2$1;
          continue;
         }
         var h2 = s2$0[4], r2 = s2$0[3], v2$0 = s2$0[2], l2 = s2$0[1];
         if(h2 <= h1){
          if(1 === h2) return add(s1$0, v2$0, compare_elt);
          var
           match = split(s2$0, v1$0, compare_elt),
           r2$0 = match[3],
           l2$0 = match[1],
           _a6_ = union(r1, r2$0);
          return join(union(l1, l2$0), v1$0, _a6_);
         }
         if(1 === h1) return add(s2$0, v1$0, compare_elt);
         var
          match$0 = split(s1$0, v2$0, compare_elt),
          r1$0 = match$0[3],
          l1$0 = match$0[1],
          _a7_ = union(r1$0, r2);
         return join(union(l1$0, l2), v2$0, _a7_);
        }
       }
       if(typeof s2$0 !== "number"){
        var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1], s1$0 = s1$1;
        continue;
       }
       var t = s1$0;
      }
      return t;
     }
    }
    return union(s1, s2);
   }
   function union_list(comparator, to_tree, xs){
    var compare_elt = comparator[1];
    function _a5_(ac, x){
     return union(ac, caml_call1(to_tree, x), compare_elt);
    }
    return caml_call3(Base_List[20], xs, empty_without_value_restrictio, _a5_);
   }
   function inter(s1, s2, compare_elt){
    function inter(s1, s2){
     if(s1 === s2) return s1;
     if(typeof s1 !== "number" && typeof s2 !== "number"){
      a:
      {
       if(typeof s1 !== "number" && 0 !== s1[0]){
        if(typeof s2 !== "number" && 0 !== s2[0]){
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          _a2_ = split(s2, v1, compare_elt),
          match = _a2_[2],
          l2 = _a2_[1];
         if(match){
          var r2 = _a2_[3], v1$0 = match[1], _a3_ = inter(r1, r2);
          return join(inter(l1, l2), v1$0, _a3_);
         }
         var r2$0 = _a2_[3], _a4_ = inter(r1, r2$0);
         return concat(inter(l1, l2), _a4_);
        }
        var other_set = s1, singleton = s2, elt = s2[1];
        break a;
       }
       var other_set = s2, singleton = s1, elt = s1[1];
      }
      return mem(other_set, elt, compare_elt) ? singleton : 0;
     }
     return 0;
    }
    return inter(s1, s2);
   }
   function diff(s1, s2, compare_elt){
    function diff(s1, s2){
     var s1$0 = s1;
     for(;;){
      if(s1$0 === s2) return 0;
      if(typeof s1$0 === "number") return 0;
      if(typeof s2 === "number") return s1$0;
      if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
       var
        r1 = s1$0[3],
        v1$0 = s1$0[2],
        l1 = s1$0[1],
        _aZ_ = split(s2, v1$0, compare_elt),
        l2 = _aZ_[1];
       if(_aZ_[2]){
        var r2 = _aZ_[3], _a0_ = diff(r1, r2);
        return concat(diff(l1, l2), _a0_);
       }
       var r2$0 = _aZ_[3], _a1_ = diff(r1, r2$0);
       return join(diff(l1, l2), v1$0, _a1_);
      }
      var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1], s1$0 = s1$1;
     }
    }
    return diff(s1, s2);
   }
   function cons(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      e$1 = [0, v$0, r, e$0],
      s$0 = l,
      e$0 = e$1;
    }
   }
   function cons_right(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      e$1 = [0, v$0, l, e$0],
      s$0 = r,
      e$0 = e$1;
    }
   }
   function of_set(s){return cons(s, 0);}
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var enum$0 = param$0[3], tree = param$0[2], a = param$0[1];
     caml_call1(f, a);
     var param$0 = cons(tree, enum$0);
    }
   }
   function symmetric_diff(t1, t2, compare_elt){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var enum$0 = match[3], tree = match[2], elt$0 = match[1];
      return [1, [1, elt$0], [0, 0, cons(tree, enum$0)]];
     }
     var right = state[2], enum1 = left[3], tree1 = left[2], elt = left[1];
     if(! right) return [1, [0, elt], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[3],
      tree2 = right[2],
      a2 = right[1],
      compare_result = caml_call2(compare_elt, elt, a2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1, [1, a2], [0, left, cons(tree2, enum2)]]
              : [1, [0, elt], [0, cons(tree1, enum1), right]];
     if(tree1 === tree2)
      var next_state = [0, enum1, enum2];
     else
      var
       _aY_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _aY_];
     return [0, next_state];
    }
    var _aW_ = of_set(t2), _aX_ = [0, of_set(t1), _aW_];
    return caml_call2(Base_Sequence[44], _aX_, step);
   }
   function to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    function inclusive_bound(side, t, bound){
     var
      compare_elt = comparator[1],
      match = split(t, bound, compare_elt),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var elt = maybe[1];
     return add(t$0, elt, compare_elt);
    }
    if(608542111 <= order){
     var
      _aO_ = Base_Import[125],
      _aP_ = function(_aU_, _aV_){return inclusive_bound(_aO_, _aU_, _aV_);},
      t$4 = caml_call3(Base_Option[34], less_or_equal_to, t$3, _aP_),
      next =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[3], t = enum$0[2], k = enum$0[1];
         return [1, k, cons(t, e)];
        };
     if(greater_or_equal_to){
      var
       key = greater_or_equal_to[1],
       compare = comparator[1],
       t = t$4,
       e = 0;
      for(;;){
       if(typeof t === "number"){var init = e; break;}
       if(0 === t[0])
        var v = t[1], t$0 = [1, 0, v, 0, 1, 1], t = t$0;
       else{
        var l = t[1], r = t[3], v$0 = t[2];
        if(0 <= caml_call2(compare, v$0, key))
         var r$0 = t[3], v$1 = t[2], e$0 = [0, v$1, r$0, e], t = l, e = e$0;
        else
         var t = r;
       }
      }
     }
     else
      var init = of_set(t$4);
     return caml_call2(Base_Sequence[44], init, next);
    }
    var _aQ_ = Base_Import[127];
    function _aR_(_aS_, _aT_){return inclusive_bound(_aQ_, _aS_, _aT_);}
    var t$5 = caml_call3(Base_Option[34], greater_or_equal_to, t$3, _aR_);
    function next$0(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[3], t = enum$0[2], k = enum$0[1];
     return [1, k, cons_right(t, e)];
    }
    if(less_or_equal_to){
     var
      key$0 = less_or_equal_to[1],
      compare$0 = comparator[1],
      t$1 = t$5,
      e$1 = 0;
     for(;;){
      if(typeof t$1 === "number"){var init$0 = e$1; break;}
      if(0 === t$1[0])
       var v$2 = t$1[1], t$2 = [1, 0, v$2, 0, 1, 1], t$1 = t$2;
      else{
       var l$0 = t$1[1], v$3 = t$1[2];
       if(0 < caml_call2(compare$0, v$3, key$0))
        var t$1 = l$0;
       else
        var
         r$1 = t$1[3],
         v$4 = t$1[2],
         e$2 = [0, v$4, l$0, e$1],
         t$1 = r$1,
         e$1 = e$2;
      }
     }
    }
    else
     var init$0 = cons_right(t$5, 0);
    return caml_call2(Base_Sequence[44], init$0, next$0);
   }
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, v$0];
     }
     var t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, v$0];
     }
     var t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;})
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;})
               : find_first_satisfying
                 (t,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      elt =
        find_last_satisfying
         (t, function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;});
     if(elt){var x = elt[1]; if(0 === caml_call2(compare, x, v)) return elt;}
     return 0;
    }
    var
     elt$0 =
       find_first_satisfying
        (t, function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(elt$0){
     var x$0 = elt$0[1];
     if(0 === caml_call2(compare, x$0, v)) return elt$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function merge_to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$0, t){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    var
     _aL_ =
       608542111 <= order
        ? comparator[1]
        : caml_call1(Base_Fn[6], comparator[1]),
     _aM_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t),
     _aN_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t$0);
    return caml_call3(Base_Sequence[58], _aN_, _aM_, _aL_);
   }
   function compare(compare_elt, s1, s2){
    var e2$2 = of_set(s2), e1$2 = of_set(s1), e1 = e1$2, e2 = e2$2;
    for(;;){
     if(! e1) return e2 ? -1 : 0;
     if(! e2) return 1;
     var
      e2$0 = e2[3],
      r2 = e2[2],
      v2 = e2[1],
      e1$0 = e1[3],
      r1 = e1[2],
      v1 = e1[1],
      c = caml_call2(compare_elt, v1, v2);
     if(0 !== c) return c;
     if(r1 === r2)
      var e1 = e1$0, e2 = e2$0;
     else
      var e2$1 = cons(r2, e2$0), e1$1 = cons(r1, e1$0), e1 = e1$1, e2 = e2$1;
    }
   }
   function iter2(s1, s2, compare_elt, f){
    var t2$2 = of_set(s2), t1$2 = of_set(s1), t1 = t1$2, t2 = t2$2;
    for(;;){
     if(! t1)
      return t2
              ? iter
                (function(a){return caml_call1(f, [0, -57574468, a]);}, t2)
              : 0;
     if(! t2)
      return iter(function(a){return caml_call1(f, [0, 847852583, a]);}, t1);
     var
      enum2 = t2[3],
      tree2 = t2[2],
      a2 = t2[1],
      enum1 = t1[3],
      tree1 = t1[2],
      a1 = t1[1],
      compare_result = caml_call2(compare_elt, a1, a2);
     if(0 === compare_result){
      caml_call1(f, [0, 737457313, [0, a1, a2]]);
      var
       t2$0 = cons(tree2, enum2),
       t1$0 = cons(tree1, enum1),
       t1 = t1$0,
       t2 = t2$0;
     }
     else if(0 <= compare_result){
      caml_call1(f, [0, -57574468, a2]);
      var t2$1 = cons(tree2, enum2), t2 = t2$1;
     }
     else{
      caml_call1(f, [0, 847852583, a1]);
      var t1$1 = cons(tree1, enum1), t1 = t1$1;
     }
    }
   }
   function equal(s1, s2, compare_elt){
    return 0 === compare(compare_elt, s1, s2) ? 1 : 0;
   }
   function is_subset(s1, s2, compare_elt){
    function is_subset(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(typeof s1$0 === "number") return 1;
      if(1 === s1$0[0]){
       var r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
       if(typeof s2$0 !== "number"){
        if(0 === s2$0[0]){
         var v2 = s2$0[1];
         if(typeof l1 === "number" && typeof r1 === "number")
          return 0 === caml_call2(compare_elt, v1$0, v2) ? 1 : 0;
         return 0;
        }
        var
         r2 = s2$0[3],
         v2$0 = s2$0[2],
         l2 = s2$0[1],
         c = caml_call2(compare_elt, v1$0, v2$0);
        if(0 !== c){
         if(0 <= c){
          var _aJ_ = is_subset([1, 0, v1$0, r1, 0, 0], r2);
          if(! _aJ_) return _aJ_;
          var s1$0 = l1;
          continue;
         }
         var _aK_ = is_subset([1, l1, v1$0, 0, 0, 0], l2);
         if(! _aK_) return _aK_;
         var s1$0 = r1;
         continue;
        }
        var _aG_ = s1$0 === s2$0 ? 1 : 0;
        if(_aG_)
         var _aH_ = _aG_;
        else{
         var _aI_ = is_subset(l1, l2);
         if(_aI_){var s1$0 = r1, s2$0 = r2; continue;}
         var _aH_ = _aI_;
        }
        return _aH_;
       }
      }
      if(typeof s2$0 === "number") return 0;
      var v1 = s1$0[1];
      return mem(s2$0, v1, compare_elt);
     }
    }
    return is_subset(s1, s2);
   }
   function are_disjoint(s1, s2, compare_elt){
    var s1$0 = s1, s2$0 = s2;
    for(;;){
     if(typeof s1$0 !== "number" && typeof s2$0 !== "number"){
      a:
      {
       if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
        if(typeof s2$0 !== "number" && 0 !== s2$0[0]){
         var r1 = s1$0[3], v1 = s1$0[2], l1 = s1$0[1];
         if(s1$0 === s2$0) return 0;
         var _aE_ = split(s2$0, v1, compare_elt), l2 = _aE_[1];
         if(_aE_[2]) return 0;
         var r2 = _aE_[3], _aF_ = are_disjoint(l1, l2, compare_elt);
         if(! _aF_) return _aF_;
         var s1$0 = r1, s2$0 = r2;
         continue;
        }
        var other_set = s1$0, elt = s2$0[1];
        break a;
       }
       var other_set = s2$0, elt = s1$0[1];
      }
      return 1 - mem(other_set, elt, compare_elt);
     }
     return 1;
    }
   }
   function iter$0(t, f){
    function iter(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return 0;
      if(0 === param$0[0]){var v = param$0[1]; return caml_call1(f, v);}
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      iter(l);
      caml_call1(f, v$0);
      var param$0 = r;
     }
    }
    return iter(t);
   }
   function fold(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, accu$0, v);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, fold(l, accu$0, f), v$0),
      s$0 = r,
      accu$0 = accu$1;
    }
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function fold_right(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, v, accu$0);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, v$0, fold_right(r, accu$0, f)),
      s$0 = l,
      accu$0 = accu$1;
    }
   }
   function for_all(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _aB_ = caml_call1(p, v$0);
     if(_aB_){
      var _aC_ = for_all(l, p);
      if(_aC_){var t$0 = r; continue;}
      var _aD_ = _aC_;
     }
     else
      var _aD_ = _aB_;
     return _aD_;
    }
   }
   function exists(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _ay_ = caml_call1(p, v$0);
     if(_ay_)
      var _az_ = _ay_;
     else{
      var _aA_ = exists(l, p);
      if(! _aA_){var t$0 = r; continue;}
      var _az_ = _aA_;
     }
     return _az_;
    }
   }
   function filter(s, p){
    function filt(t){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return caml_call1(p, v) ? t : 0;}
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      l$0 = filt(l),
      keep_v = caml_call1(p, v$0),
      r$0 = filt(r);
     if(keep_v && l === l$0 && r === r$0) return t;
     return keep_v ? join(l$0, v$0, r$0) : concat(l$0, r$0);
    }
    return filt(s);
   }
   function filter_map(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1], match = caml_call1(p, v);
       if(! match) return accu$0;
       var v$0 = match[1];
       return add(accu$0, v$0, compare_elt);
      }
      var
       r = param$0[3],
       v$1 = param$0[2],
       l = param$0[1],
       match$0 = caml_call1(p, v$1);
      if(match$0)
       var v$2 = match$0[1], _ax_ = add(accu$0, v$2, compare_elt);
      else
       var _ax_ = accu$0;
      var accu$1 = filt(_ax_, l), accu$0 = accu$1, param$0 = r;
     }
    }
    return filt(0, s);
   }
   function partition_tf(s, p){
    function loop(t){
     if(typeof t === "number") return _r_;
     if(0 === t[0]){
      var v = t[1];
      return caml_call1(p, v) ? [0, t, 0] : [0, 0, t];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      match = loop(l),
      l_f = match[2],
      l_t = match[1],
      keep_v_t = caml_call1(p, v$0),
      match$0 = loop(r),
      r_f = match$0[2],
      r_t = match$0[1];
     function mk(keep_v, l$0, r$0){
      if(keep_v && l === l$0 && r === r$0) return t;
      return keep_v ? join(l$0, v$0, r$0) : concat(l$0, r$0);
     }
     var _aw_ = mk(1 - keep_v_t, l_f, r_f);
     return [0, mk(keep_v_t, l_t, r_t), _aw_];
    }
    return loop(s);
   }
   function elements_aux(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return accu$0;
     if(0 === param$0[0]){var v = param$0[1]; return [0, v, accu$0];}
     var
      r = param$0[3],
      v$0 = param$0[2],
      l = param$0[1],
      accu$1 = [0, v$0, elements_aux(accu$0, r)],
      accu$0 = accu$1,
      param$0 = l;
    }
   }
   function elements(s){return elements_aux(0, s);}
   function choose(t){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var v = t[1]; return [0, v];}
    var v$0 = t[2];
    return [0, v$0];
   }
   var not_found = [0, Base_Import[297], _s_];
   function choose_exn(t){
    var match = choose(t);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var v = match[1];
    return v;
   }
   function of_list(lst, compare_elt){
    function _av_(t, x){return add(t, x, compare_elt);}
    return caml_call3
            (Base_List[20], lst, empty_without_value_restrictio, _av_);
   }
   function of_sequence(sequence, compare_elt){
    function _au_(t, x){return add(t, x, compare_elt);}
    return caml_call3
            (Base_Sequence[11],
             sequence,
             empty_without_value_restrictio,
             _au_);
   }
   function to_list(s){return elements(s);}
   function of_array(a, compare_elt){
    function _at_(t, x){return add(t, x, compare_elt);}
    return caml_call3(Base_Array[21], a, empty_without_value_restrictio, _at_);
   }
   function to_array(param){
    if(typeof param === "number") return [0];
    if(0 === param[0]){var v = param[1]; return [0, v];}
    var
     s = param[5],
     r = param[3],
     v$0 = param[2],
     l = param[1],
     res = caml_call2(Base_Array[48], s, v$0),
     pos_ref = [0, 0];
    function loop(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return;
      if(0 === param$0[0]){
       var v = param$0[1], _ar_ = pos_ref[1];
       caml_check_bound(res, _ar_)[1 + _ar_] = v;
       pos_ref[1]++;
       return;
      }
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      loop(l);
      var _as_ = pos_ref[1];
      caml_check_bound(res, _as_)[1 + _as_] = v$0;
      pos_ref[1]++;
      var param$0 = r;
     }
    }
    loop(l);
    pos_ref[1]++;
    loop(r);
    return res;
   }
   function map(t, f, compare_elt){
    return fold
            (t,
             empty_without_value_restrictio,
             function(t, x){return add(t, caml_call1(f, x), compare_elt);});
   }
   function group_by(set, equiv){
    var set$0 = set, equiv_classes = 0;
    for(;;){
     if(is_empty(set$0)) return equiv_classes;
     var
      x = choose_exn(set$0),
      match =
        partition_tf
         (set$0,
          function(x){
            return function(elt){
             var _aq_ = x === elt ? 1 : 0;
             return _aq_ ? _aq_ : caml_call2(equiv, x, elt);};
           }
           (x)),
      not_equiv_x = match[2],
      equiv_x = match[1],
      equiv_classes$0 = [0, equiv_x, equiv_classes],
      set$0 = not_equiv_x,
      equiv_classes = equiv_classes$0;
    }
   }
   function find(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)) return [0, v$0];
     var r$0 = find(l, f);
     if(r$0) return r$0;
     var t$0 = r;
    }
   }
   function find_map(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], r$0 = caml_call1(f, v$0);
     if(r$0) return r$0;
     var r$1 = find_map(l, f);
     if(r$1) return r$1;
     var t$0 = r;
    }
   }
   function find_exn(t, f){
    var match = find(t, f);
    if(! match)
     return caml_call1(Base_Import[124], cst_Set_find_exn_failed_to_fin);
    var e = match[1];
    return e;
   }
   function nth(t, i){
    var t$0 = t, i$0 = i;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return 0 === i$0 ? [0, v] : 0;}
     var s = t$0[5], r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(s <= i$0) return 0;
     var l_size = length(l), c = caml_int_compare(i$0, l_size);
     if(0 <= c){
      if(0 === c) return [0, v$0];
      var
       _ap_ = caml_call2(Base_Import[93], i$0, l_size),
       i$1 = caml_call2(Base_Import[93], _ap_, 1),
       t$0 = r,
       i$0 = i$1;
     }
     else
      var t$0 = l;
    }
   }
   function stable_dedup_list(xs, compare_elt){
    var
     xs$0 = xs,
     leftovers = 0,
     already_seen = empty_without_value_restrictio;
    for(;;){
     if(! xs$0) return caml_call1(Base_List[63], leftovers);
     var tl = xs$0[2], hd = xs$0[1];
     if(mem(already_seen, hd, compare_elt))
      var xs$0 = tl;
     else
      var
       already_seen$0 = add(already_seen, hd, compare_elt),
       leftovers$0 = [0, hd, leftovers],
       xs$0 = tl,
       leftovers = leftovers$0,
       already_seen = already_seen$0;
    }
   }
   function t_of_sexp_direct(a_of_sexp, sexp, compare_elt){
    if(0 === sexp[0])
     return caml_call2(Base_Import[156], cst_Set_t_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     elt_lst = caml_call2(Base_List[53], lst, a_of_sexp),
     set = of_list(elt_lst, compare_elt),
     _an_ = caml_call1(Base_List[45], lst);
    if(length(set) === _an_) return set;
    var set$0 = [0, empty_without_value_restrictio];
    function _ao_(el_sexp, el){
     return mem(set$0[1], el, compare_elt)
             ? caml_call2
               (Base_Import[156], cst_Set_t_of_sexp_duplicate_el, el_sexp)
             : (set$0[1] = add(set$0[1], el, compare_elt), 0);
    }
    caml_call3(Base_List[67], lst, elt_lst, _ao_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
   }
   function sexp_of_t(sexp_of_a, t){
    return [1,
            fold_right
             (t,
              0,
              function(el, acc){return [0, caml_call1(sexp_of_a, el), acc];})];
   }
   function is_subset$0(subset, superset, sexp_of_elt, compare_elt){
    var invalid_elements = diff(subset[1], superset[1], compare_elt);
    if(is_empty(invalid_elements)) return _u_;
    var
     invalid_elements_sexp = sexp_of_t(sexp_of_elt, invalid_elements),
     _ak_ = caml_call2(Base_Import[112], cst_is_not_a_subset_of, superset[2]),
     _al_ = caml_call2(Base_Import[112], subset[2], _ak_),
     _am_ =
       caml_call2
        (Base_Sexp[10],
         _al_,
         [0, [0, cst_invalid_elements, invalid_elements_sexp], 0]);
    return caml_call1(Base_Or_error[39], _am_);
   }
   function like(param, tree){
    var comparator = param[1];
    return [0, comparator, tree];
   }
   function like_maybe_no_op(old_t, tree){
    var old_tree = old_t[2], comparator = old_t[1];
    return old_tree === tree ? old_t : [0, comparator, tree];
   }
   function compare_elt(t){return t[1][1];}
   function comparator(t){return t[1];}
   function comparator_s(t){return caml_call1(Base_Comparator[5], t[1]);}
   function invariants$0(t){
    var _aj_ = compare_elt(t);
    return invariants(t[2], _aj_);
   }
   function length$0(t){return length(t[2]);}
   function is_empty$0(t){return is_empty(t[2]);}
   function elements$0(t){return elements(t[2]);}
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function choose$0(t){return choose(t[2]);}
   function choose_exn$0(t){return choose_exn(t[2]);}
   function to_list$0(t){return to_list(t[2]);}
   function to_array$0(t){return to_array(t[2]);}
   function fold$0(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f, finish){
    return fold_until(t[2], init, f, finish);
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold$0, init, f, t);
   }
   function iter$1(t, f){return iter$0(t[2], f);}
   function iter2$0(a, b, f){
    var _ai_ = compare_elt(a);
    return iter2(a[2], b[2], _ai_, f);
   }
   function exists$0(t, f){return exists(t[2], f);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function find$0(t, f){return find(t[2], f);}
   function find_exn$0(t, f){return find_exn(t[2], f);}
   function find_map$0(t, f){return find_map(t[2], f);}
   function mem$0(t, a){var _ah_ = compare_elt(t); return mem(t[2], a, _ah_);}
   function filter$0(t, f){return like_maybe_no_op(t, filter(t[2], f));}
   function add$0(t, a){
    var _ag_ = compare_elt(t);
    return like(t, add(t[2], a, _ag_));
   }
   function remove$0(t, a){
    var _af_ = compare_elt(t);
    return like(t, remove(t[2], a, _af_));
   }
   function union$0(t1, t2){
    var _ae_ = compare_elt(t1);
    return like(t1, union(t1[2], t2[2], _ae_));
   }
   function inter$0(t1, t2){
    var _ad_ = compare_elt(t1);
    return like(t1, inter(t1[2], t2[2], _ad_));
   }
   function diff$0(t1, t2){
    var _ac_ = compare_elt(t1);
    return like(t1, diff(t1[2], t2[2], _ac_));
   }
   function symmetric_diff$0(t1, t2){
    var _ab_ = compare_elt(t1);
    return symmetric_diff(t1[2], t2[2], _ab_);
   }
   function compare_direct(t1, t2){
    var _$_ = t2[2], _aa_ = t1[2];
    return compare(compare_elt(t1), _aa_, _$_);
   }
   function equal$0(t1, t2){
    var ___ = compare_elt(t1);
    return equal(t1[2], t2[2], ___);
   }
   function is_subset$1(t, of){
    var _Z_ = compare_elt(t);
    return is_subset(t[2], of[2], _Z_);
   }
   function are_disjoint$0(t1, t2){
    var _Y_ = compare_elt(t1);
    return are_disjoint(t1[2], t2[2], _Y_);
   }
   function to_named_tree(named){return [0, named[1][2], named[2]];}
   function is_subset$2(subset, superset){
    var
     _V_ = compare_elt(subset[1]),
     _W_ = subset[1][1][2],
     _X_ = to_named_tree(superset);
    return is_subset$0(to_named_tree(subset), _X_, _W_, _V_);
   }
   function equal$1(t1, t2){
    var
     _T_ = [0, is_subset$2(t2, t1), 0],
     _U_ = [0, is_subset$2(t1, t2), _T_];
    return caml_call1(Base_Or_error[51], _U_);
   }
   function partition_tf$0(t, f){
    var
     match = partition_tf(t[2], f),
     tree_f = match[2],
     tree_t = match[1],
     _S_ = like_maybe_no_op(t, tree_f);
    return [0, like_maybe_no_op(t, tree_t), _S_];
   }
   function split$0(t, a){
    var
     _Q_ = compare_elt(t),
     match = split(t[2], a, _Q_),
     tree2 = match[3],
     b = match[2],
     tree1 = match[1],
     _R_ = like(t, tree2);
    return [0, like(t, tree1), b, _R_];
   }
   function split_le_gt$0(t, a){
    var
     _O_ = compare_elt(t),
     match = split_le_gt(t[2], a, _O_),
     tree2 = match[2],
     tree1 = match[1],
     _P_ = like(t, tree2);
    return [0, like(t, tree1), _P_];
   }
   function split_lt_ge$0(t, a){
    var
     _M_ = compare_elt(t),
     match = split_lt_ge(t[2], a, _M_),
     tree2 = match[2],
     tree1 = match[1],
     _N_ = like(t, tree2);
    return [0, like(t, tree1), _N_];
   }
   function group_by$0(t, equiv){
    function _J_(_L_){return like(t, _L_);}
    var _K_ = group_by(t[2], equiv);
    return caml_call2(Base_List[53], _K_, _J_);
   }
   function nth$0(t, i){return nth(t[2], i);}
   function remove_index$0(t, i){
    var _I_ = compare_elt(t);
    return like(t, remove_index(t[2], i, _I_));
   }
   function sexp_of_t$0(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t[2]);
   }
   function to_sequence$0(order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (t[1], order, greater_or_equal_to, less_or_equal_to, t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function merge_to_sequence$0
   (order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (t$0[1],
             order,
             greater_or_equal_to,
             less_or_equal_to,
             t$0[2],
             t[2]);
   }
   function hash_fold_direct(hash_fold_elem, state, t){
    var t$0 = t[2], _H_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[206], state, _H_), hash_fold_elem);
   }
   function compare$0(param, _G_, t1, t2){return compare_direct(t1, t2);}
   function t_of_sexp_direct$0(comparator, a_of_sexp, sexp){
    return t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
   }
   function empty(param){return empty_without_value_restrictio;}
   function singleton(param, e){return [0, e];}
   function length$1(t){return length(t);}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function elements$1(t){return elements(t);}
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function choose$1(t){return choose(t);}
   function choose_exn$1(t){return choose_exn(t);}
   function to_list$1(t){return to_list(t);}
   function to_array$1(t){return to_array(t);}
   function iter$2(t, f){return iter$0(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function for_all$1(t, f){return for_all(t, f);}
   function count$1(t, f){return count(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function find$1(t, f){return find(t, f);}
   function find_exn$1(t, f){return find_exn(t, f);}
   function find_map$1(t, f){return find_map(t, f);}
   function fold$1(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function map$0(comparator, t, f){return map(t, f, comparator[1]);}
   function filter$1(t, f){return filter(t, f);}
   function filter_map$0(comparator, t, f){
    return filter_map(t, f, comparator[1]);
   }
   function partition_tf$1(t, f){return partition_tf(t, f);}
   function iter2$1(comparator, a, b, f){
    return iter2(a, b, comparator[1], f);
   }
   function mem$1(comparator, t, a){return mem(t, a, comparator[1]);}
   function add$1(comparator, t, a){return add(t, a, comparator[1]);}
   function remove$1(comparator, t, a){return remove(t, a, comparator[1]);}
   function union$1(comparator, t1, t2){return union(t1, t2, comparator[1]);}
   function inter$1(comparator, t1, t2){return inter(t1, t2, comparator[1]);}
   function diff$1(comparator, t1, t2){return diff(t1, t2, comparator[1]);}
   function symmetric_diff$1(comparator, t1, t2){
    return symmetric_diff(t1, t2, comparator[1]);
   }
   function compare_direct$0(comparator, t1, t2){return compare(comparator[1], t1, t2);
   }
   function equal$2(comparator, t1, t2){return equal(t1, t2, comparator[1]);}
   function is_subset$3(comparator, t, of){
    return is_subset(t, of, comparator[1]);
   }
   function are_disjoint$1(comparator, t1, t2){
    return are_disjoint(t1, t2, comparator[1]);
   }
   function of_list$0(comparator, l){return of_list(l, comparator[1]);}
   function of_sequence$0(comparator, s){
    return of_sequence(s, comparator[1]);
   }
   function of_array$0(comparator, a){return of_array(a, comparator[1]);}
   function of_sorted_array_unchecked$0(comparator, a){
    return of_sorted_array_unchecked(a, comparator[1]);
   }
   function of_increasing_iterator_uncheck$0(param, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_sorted_array$0(comparator, a){
    return of_sorted_array(a, comparator[1]);
   }
   function union_list$0(comparator, l){
    return union_list(comparator, function(_F_){return _F_;}, l);
   }
   function stable_dedup_list$0(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function group_by$1(t, equiv){return group_by(t, equiv);}
   function split$1(comparator, t, a){return split(t, a, comparator[1]);}
   function split_le_gt$1(comparator, t, a){
    return split_le_gt(t, a, comparator[1]);
   }
   function split_lt_ge$1(comparator, t, a){
    return split_lt_ge(t, a, comparator[1]);
   }
   function nth$1(t, i){return nth(t, i);}
   function remove_index$1(comparator, t, i){
    return remove_index(t, i, comparator[1]);
   }
   function sexp_of_t$1(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t);}
   function to_tree(t){return t;}
   function of_tree(param, t){return t;}
   function to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function merge_to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t);
   }
   function fold_result$0(t, init, f){
    return caml_call4(Base_Container[8], fold$1, init, f, t);
   }
   function is_subset$4(comparator, t1, t2){
    return is_subset$0(t1, t2, comparator[2], comparator[1]);
   }
   function equal$3(comparator, t1, t2){
    var
     compare_elt = comparator[1],
     sexp_of_elt = comparator[2],
     _D_ = [0, is_subset$0(t2, t1, sexp_of_elt, compare_elt), 0],
     _E_ = [0, is_subset$0(t1, t2, sexp_of_elt, compare_elt), _D_];
    return caml_call1(Base_Or_error[51], _E_);
   }
   var Named = [0, is_subset$4, equal$3];
   function to_tree$0(t){return t[2];}
   function of_tree$0(comparator, tree){return [0, comparator, tree];}
   function t_of_sexp_direct$1(comparator, a_of_sexp, sexp){
    return [0, comparator, t_of_sexp_direct(a_of_sexp, sexp, comparator[1])];
   }
   function empty$0(comparator){
    return [0, comparator, empty_without_value_restrictio];
   }
   function Empty_without_value_restrictio(Elt){
    var empty = [0, Elt[1], empty_without_value_restrictio];
    return [0, empty];
   }
   function singleton$0(comparator, e){return [0, comparator, [0, e]];}
   function union_list$1(comparator, l){
    return [0, comparator, union_list(comparator, to_tree$0, l)];
   }
   function of_sorted_array_unchecked$1(comparator, array){
    var tree = of_sorted_array_unchecked(array, comparator[1]);
    return [0, comparator, tree];
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    return [0, comparator, of_increasing_iterator_uncheck(len, f)];
   }
   function of_sorted_array$1(comparator, array){
    function _B_(tree){return [0, comparator, tree];}
    var _C_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[21][2], _C_, _B_);
   }
   function of_list$1(comparator, l){
    return [0, comparator, of_list(l, comparator[1])];
   }
   function of_sequence$1(comparator, s){
    return [0, comparator, of_sequence(s, comparator[1])];
   }
   function of_array$1(comparator, a){
    return [0, comparator, of_array(a, comparator[1])];
   }
   function stable_dedup_list$1(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function map$1(comparator, t, f){
    return [0, comparator, map(t[2], f, comparator[1])];
   }
   function filter_map$1(comparator, t, f){
    return [0, comparator, filter_map(t[2], f, comparator[1])];
   }
   var to_comparator = Base_Comparator[4];
   function empty$1(m){return empty$0(caml_call1(to_comparator, m));}
   function singleton$1(m, a){
    return singleton$0(caml_call1(to_comparator, m), a);
   }
   function union_list$2(m, a){
    return union_list$1(caml_call1(to_comparator, m), a);
   }
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(caml_call1(to_comparator, m), a);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1
            (caml_call1(to_comparator, m), len, f);
   }
   function of_sorted_array$2(m, a){
    return of_sorted_array$1(caml_call1(to_comparator, m), a);
   }
   function of_list$2(m, a){
    return of_list$1(caml_call1(to_comparator, m), a);
   }
   function of_sequence$2(m, a){
    return of_sequence$1(caml_call1(to_comparator, m), a);
   }
   function of_array$2(m, a){
    return of_array$1(caml_call1(to_comparator, m), a);
   }
   function stable_dedup_list$2(m, a){
    return stable_dedup_list$1(caml_call1(to_comparator, m), a);
   }
   function map$2(m, a, f){return map$1(caml_call1(to_comparator, m), a, f);}
   function filter_map$2(m, a, f){
    return filter_map$1(caml_call1(to_comparator, m), a, f);
   }
   function of_tree$1(m, t){return [0, caml_call1(to_comparator, m), t];}
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt, t){
    function _A_(param){return _v_;}
    return sexp_of_t$0(Elt[1], _A_, t);
   }
   function m_t_of_sexp(Elt, sexp){
    return t_of_sexp_direct$1(Elt[2], Elt[1], sexp);
   }
   function m_t_sexp_grammar(Elt){
    var _z_ = caml_call1(Base_Import[194], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _z_);
   }
   function compare_m_t(param, t1, t2){return compare_direct(t1, t2);}
   function equal_m_t(param, t1, t2){return equal$0(t1, t2);}
   function hash_fold_m_t(Elt, state){
    var _x_ = Elt[1];
    return function(_y_){return hash_fold_direct(_x_, state, _y_);};
   }
   function hash_m_t(folder, t){
    var state = hash_fold_m_t(folder, caml_call2(Base_Hash[11], 0, 0))(t);
    return caml_call1(Base_Hash[9], state);
   }
   var
    comparator$0 = Base_Comparator[2][1],
    include = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$2 = include[1];
   function singleton$2(a){return singleton$0(comparator$0, a);}
   function union_list$3(a){return union_list$1(comparator$0, a);}
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_list$3(a){return of_list$1(comparator$0, a);}
   function of_sequence$3(a){return of_sequence$1(comparator$0, a);}
   function of_array$3(a){return of_array$1(comparator$0, a);}
   function stable_dedup_list$3(a){
    return stable_dedup_list$1(comparator$0, a);
   }
   function map$3(a, f){return map$1(comparator$0, a, f);}
   function filter_map$3(a, f){return filter_map$1(comparator$0, a, f);}
   function of_tree$2(tree){return [0, comparator$0, tree];}
   function to_tree$1(t){return t[2];}
   var
    _w_ = Base_Sequence[57],
    Base_Set =
      [0,
       compare$0,
       invariants$0,
       comparator_s,
       comparator,
       empty$1,
       singleton$1,
       length$0,
       is_empty$0,
       mem$0,
       add$0,
       remove$0,
       union$0,
       union_list$2,
       inter$0,
       diff$0,
       symmetric_diff$0,
       compare_direct,
       hash_fold_direct,
       equal$0,
       exists$0,
       for_all$0,
       count$0,
       sum$0,
       find$0,
       find_map$0,
       find_exn$0,
       nth$0,
       remove_index$0,
       is_subset$1,
       are_disjoint$0,
       [0, is_subset$2, equal$1],
       of_list$2,
       of_sequence$2,
       of_array$2,
       to_list$0,
       to_array$0,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       stable_dedup_list$2,
       map$2,
       filter_map$2,
       filter$0,
       fold$0,
       fold_result,
       fold_until$0,
       fold_right$0,
       iter$1,
       iter2$0,
       partition_tf$0,
       elements$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       choose$0,
       choose_exn$0,
       split$0,
       split_le_gt$0,
       split_lt_ge$0,
       group_by$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       [0, _w_[1], _w_[6], _w_[7]],
       merge_to_sequence$0,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       hash_m_t,
       [0,
        sexp_of_t$0,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$1,
         t_of_sexp_direct$0,
         length$1,
         is_empty$1,
         iter$2,
         fold$1,
         fold_result$0,
         exists$1,
         for_all$1,
         count$1,
         sum$1,
         find$1,
         find_map$1,
         to_list$1,
         to_array$1,
         invariants$1,
         mem$1,
         add$1,
         remove$1,
         union$1,
         inter$1,
         diff$1,
         symmetric_diff$1,
         compare_direct$0,
         equal$2,
         is_subset$3,
         are_disjoint$1,
         Named,
         fold_until$1,
         fold_right$1,
         iter2$1,
         filter$1,
         partition_tf$1,
         elements$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         choose$1,
         choose_exn$1,
         split$1,
         split_le_gt$1,
         split_lt_ge$1,
         group_by$1,
         find_exn$1,
         nth$1,
         remove_index$1,
         to_tree,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         merge_to_sequence$1,
         empty,
         singleton,
         union_list$0,
         of_list$0,
         of_sequence$0,
         of_array$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         stable_dedup_list$0,
         map$0,
         filter_map$0,
         of_tree,
         empty_without_value_restrictio],
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list$0,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        split_le_gt$0,
        split_lt_ge$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$0,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$0,
        singleton$0,
        union_list$1,
        of_list$1,
        of_sequence$1,
        of_array$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        stable_dedup_list$1,
        map$1,
        filter_map$1,
        of_tree$0,
        comparator_s,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio],
       to_tree$0,
       of_tree$1,
       [0,
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list$0,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        split_le_gt$0,
        split_lt_ge$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$1,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$2,
        singleton$2,
        union_list$3,
        of_list$3,
        of_sequence$3,
        of_array$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        stable_dedup_list$3,
        map$3,
        filter_map$3,
        of_tree$2]];
   runtime.caml_register_global(48, Base_Set, "Base__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ref
//# unitInfo: Requires: Base__Exn, Base__Import, Base__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Exn = global_data.Base__Exn,
    Base_List = global_data.Base__List,
    Base_Import = global_data.Base__Import,
    compare_local = Base_Import[266],
    compare = Base_Import[238],
    equal_local = Base_Import[280],
    equal = Base_Import[252],
    globalize = Base_Import[296],
    t_of_sexp = Base_Import[168],
    sexp_of_t = Base_Import[144];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[191], a_sexp_grammar);
   }
   function swap(t1, t2){
    var tmp = t1[1];
    t1[1] = t2[1];
    t2[1] = tmp;
    return 0;
   }
   function replace(t, f){t[1] = caml_call1(f, t[1]); return 0;}
   function set_temporarily(t, a, f){
    var restore_to = t[1];
    t[1] = a;
    function _b_(param){t[1] = restore_to; return 0;}
    return caml_call2(Base_Exn[13], f, _b_);
   }
   function set(param){var a = param[2], r = param[1]; r[1] = a; return 0;}
   function sets(ts){return caml_call2(Base_List[19], ts, set);}
   function snapshot(param){var r = param[1]; return [0, r, r[1]];}
   function sets_temporarily(and_values, f){
    var restore_to = caml_call2(Base_List[53], and_values, snapshot);
    sets(and_values);
    function _a_(param){return sets(restore_to);}
    return caml_call2(Base_Exn[13], f, _a_);
   }
   var
    Base_Ref =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       swap,
       replace,
       set_temporarily,
       [0, set, sets, snapshot],
       sets_temporarily];
   runtime.caml_register_global(3, Base_Ref, "Base__Ref");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Queue_intf = [0];
   runtime.caml_register_global(0, Base_Queue_intf, "Base__Queue_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue
//# unitInfo: Requires: Base__Array, Base__Error, Base__Import, Base__Indexed_container, Base__Int, Base__List, Base__Option_array, Base__Sexp, Sexplib0__Sexp_grammar, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_length$2 = "length",
    cst_src_queue_ml = "src/queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Array = global_data.Base__Array,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Base_Indexed_container = global_data.Base__Indexed_container,
    _q_ = [0, 1],
    cst_length$1 = cst_length$2,
    cst_Queue_init_negative_length = "Queue.init: negative length",
    _p_ = [0, cst_src_queue_ml, 507, 2],
    cst_length$0 = cst_length$2,
    cst_Queue_blit_transfer_negati = "Queue.blit_transfer: negative length",
    _o_ = [0, cst_src_queue_ml, 212, 2],
    cst_capacity = "capacity",
    cst_cannot_have_queue_with_neg =
      "cannot have queue with negative capacity",
    _n_ = [0, cst_src_queue_ml, 171, 2],
    _m_ = [0, cst_src_queue_ml, 172, 2],
    _l_ = [0, cst_src_queue_ml, 174, 2],
    _k_ = [0, cst_src_queue_ml, 175, 2],
    _j_ = [0, cst_src_queue_ml, 176, 2],
    _i_ = [0, cst_src_queue_ml, 177, 2],
    _h_ = [0, cst_src_queue_ml, 178, 2],
    _g_ = [0, cst_src_queue_ml, 184, 9],
    _f_ = [0, "_"],
    cst_mutation_of_queue_during_i = "mutation of queue during iteration",
    cst_length = cst_length$2,
    cst_index = "index",
    cst_Queue_index_out_of_bounds = "Queue index out of bounds",
    _a_ = [0, "elts"],
    _b_ = [0, cst_length$2],
    _c_ = [0, "mask"],
    _d_ = [0, "front"],
    _e_ = [0, "num_mutations"];
   function globalize(param, t){
    var _a9_ = caml_call1(Base_Option_array[58], t[5]);
    return [0, t[1], t[2], t[3], t[4], _a9_];
   }
   function inc_num_mutations(t){
    t[1] = caml_call2(Base_Import[91], t[1], 1);
    return;
   }
   function capacity(t){return caml_call2(Base_Import[91], t[3], 1);}
   function elts_index(t, i){
    var _a7_ = t[3], _a8_ = caml_call2(Base_Import[91], t[2], i);
    return caml_call2(Base_Import[116], _a8_, _a7_);
   }
   function unsafe_get(t, i){
    var _a6_ = elts_index(t, i);
    return caml_call2(Base_Option_array[40], t[5], _a6_);
   }
   function unsafe_set(t, i, a){
    var _a5_ = elts_index(t, i);
    return caml_call3(Base_Option_array[51], t[5], _a5_, a);
   }
   function check_index_exn(t, i){
    var _a0_ = i < 0 ? 1 : 0, _a1_ = _a0_ || (t[4] <= i ? 1 : 0);
    if(! _a1_) return _a1_;
    var
     _a2_ = [0, [0, cst_length, caml_call1(Base_Int[10], t[4])], 0],
     _a3_ = [0, [0, cst_index, caml_call1(Base_Int[10], i)], _a2_],
     _a4_ = caml_call2(Base_Sexp[10], cst_Queue_index_out_of_bounds, _a3_);
    return caml_call1(Base_Error[32], _a4_);
   }
   function get(t, i){check_index_exn(t, i); return unsafe_get(t, i);}
   function set(t, i, a){
    check_index_exn(t, i);
    inc_num_mutations(t);
    return unsafe_set(t, i, a);
   }
   function is_empty(t){return 0 === t[4] ? 1 : 0;}
   function length(param){var length = param[4]; return length;}
   function ensure_no_mutation(t, num_mutations){
    var _aZ_ = t[1] !== num_mutations ? 1 : 0;
    if(! _aZ_) return _aZ_;
    var param = globalize(0, t), _aX_ = 0;
    function of_a_001(param){return _f_;}
    var
     num_mutations_003 = param[1],
     front_005 = param[2],
     mask_007 = param[3],
     length_009 = param[4],
     elts_011 = param[5],
     arg_012 = caml_call2(Base_Option_array[2], of_a_001, elts_011),
     bnds_002 = [0, [1, [0, _a_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[139], length_009),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_010, 0]]], bnds_002],
     arg_008 = caml_call1(Base_Import[139], mask_007),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_008, 0]]], bnds_002$0],
     arg_006 = caml_call1(Base_Import[139], front_005),
     bnds_002$2 = [0, [1, [0, _d_, [0, arg_006, 0]]], bnds_002$1],
     arg_004 = caml_call1(Base_Import[139], num_mutations_003),
     bnds_002$3 = [0, [1, [0, _e_, [0, arg_004, 0]]], bnds_002$2],
     _aY_ =
       caml_call2
        (Base_Sexp[10],
         cst_mutation_of_queue_during_i,
         [0, [0, cst, [1, bnds_002$3]], _aX_]);
    return caml_call1(Base_Error[32], _aY_);
   }
   function compare_local(compare_elt, t1, t2){
    if(t1 === t2) return 0;
    var mut2 = t2[1], mut1 = t1[1], len2 = t2[4], len1 = t1[4], pos = 0;
    for(;;){
     var match = pos === len2 ? 1 : 0;
     if(pos === len1) return match ? 0 : -1;
     if(match) return 1;
     var
      _aW_ = unsafe_get(t2, pos),
      x = caml_call2(compare_elt, unsafe_get(t1, pos), _aW_);
     ensure_no_mutation(t1, mut1);
     ensure_no_mutation(t2, mut2);
     if(0 !== x) return x;
     var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
    }
   }
   function compare(compare_elt, t1, t2){
    return compare_local(compare_elt, t1, t2);
   }
   function equal_local(equal_elt, t1, t2){
    var _aT_ = t1 === t2 ? 1 : 0;
    if(_aT_)
     var _aU_ = _aT_;
    else{
     var len1 = t1[4], len2 = t2[4], _aV_ = len1 === len2 ? 1 : 0;
     if(_aV_){
      var mut2 = t2[1], mut1 = t1[1], pos = 0;
      for(;;){
       var _aQ_ = pos === len1 ? 1 : 0;
       if(_aQ_)
        var _aR_ = _aQ_;
       else{
        var
         _aS_ = unsafe_get(t2, pos),
         b = caml_call2(equal_elt, unsafe_get(t1, pos), _aS_);
        ensure_no_mutation(t1, mut1);
        ensure_no_mutation(t2, mut2);
        if(b){
         var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
         continue;
        }
        var _aR_ = b;
       }
       return _aR_;
      }
     }
     var _aU_ = _aV_;
    }
    return _aU_;
   }
   function equal(equal_elt, t1, t2){return equal_local(equal_elt, t1, t2);}
   function invariant(invariant_a, t){
    var num_mutations = t[1], front = t[2], length = t[4], elts = t[5];
    if(0 > front)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    if(front >= capacity(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    var capacity$0 = capacity(t);
    if(capacity$0 !== caml_call1(Base_Option_array[28], elts))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(1 > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    if(! caml_call1(Base_Int[72], capacity$0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    if(0 > length)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
    if(length > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var _aO_ = caml_call2(Base_Import[93], capacity$0, 1), _aN_ = 0;
    if(_aO_ >= 0){
     var i = _aN_;
     for(;;){
      if(i < t[4]){
       caml_call1(invariant_a, unsafe_get(t, i));
       ensure_no_mutation(t, num_mutations);
      }
      else{
       var _aM_ = elts_index(t, i);
       if(caml_call2(Base_Option_array[42], t[5], _aM_))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      var _aP_ = i + 1 | 0;
      if(_aO_ === i) break;
      var i = _aP_;
     }
    }
    return 0;
   }
   function create(capacity, param){
    if(capacity){
     var capacity$0 = capacity[1];
     if(0 <= capacity$0)
      var _aI_ = 0 === capacity$0 ? 1 : caml_call1(Base_Int[68], capacity$0);
     else
      var
       _aK_ = [0, [0, cst_capacity, caml_call1(Base_Int[10], capacity$0)], 0],
       _aL_ = caml_call2(Base_Sexp[10], cst_cannot_have_queue_with_neg, _aK_),
       _aI_ = caml_call1(Base_Error[32], _aL_);
     var capacity$1 = _aI_;
    }
    else
     var capacity$1 = 2;
    var _aJ_ = caml_call1(Base_Option_array[5], capacity$1);
    return [0, 0, 0, caml_call2(Base_Import[93], capacity$1, 1), 0, _aJ_];
   }
   function blit_to_array(src, dst){
    var _aE_ = caml_call1(Base_Option_array[28], dst);
    if(src[4] > _aE_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var
     _aF_ = src[2],
     _aG_ = capacity(src),
     _aH_ = caml_call2(Base_Import[93], _aG_, _aF_),
     front_len = caml_call2(Base_Int[15], src[4], _aH_),
     rest_len = caml_call2(Base_Import[93], src[4], front_len);
    caml_call5(Base_Option_array[53], src[5], src[2], dst, 0, front_len);
    return caml_call5
            (Base_Option_array[53], src[5], 0, dst, front_len, rest_len);
   }
   function set_capacity_internal(t, new_capacity){
    var dst = caml_call1(Base_Option_array[5], new_capacity);
    blit_to_array(t, dst);
    t[2] = 0;
    t[3] = caml_call2(Base_Import[93], new_capacity, 1);
    t[5] = dst;
    return 0;
   }
   function set_capacity(t, desired_capacity){
    inc_num_mutations(t);
    var
     _aB_ = caml_call2(Base_Import[100], desired_capacity, t[4]),
     _aC_ = caml_call2(Base_Import[100], 1, _aB_),
     new_capacity = caml_call1(Base_Int[68], _aC_),
     _aD_ = new_capacity !== capacity(t) ? 1 : 0;
    return _aD_ ? set_capacity_internal(t, new_capacity) : _aD_;
   }
   function enqueue(t, a){
    inc_num_mutations(t);
    var _aA_ = capacity(t);
    if(t[4] === _aA_)
     set_capacity_internal(t, caml_call2(Base_Import[88], 2, t[4]));
    unsafe_set(t, t[4], a);
    t[4] = caml_call2(Base_Import[91], t[4], 1);
    return 0;
   }
   function enqueue_front(t, a){
    inc_num_mutations(t);
    var _ax_ = capacity(t);
    if(t[4] === _ax_)
     set_capacity_internal(t, caml_call2(Base_Import[88], 2, t[4]));
    var
     _ay_ = t[3],
     _az_ = caml_call2(Base_Import[93], t[2], 1),
     front = caml_call2(Base_Import[116], _az_, _ay_);
    t[2] = front;
    t[4] = caml_call2(Base_Import[91], t[4], 1);
    return unsafe_set(t, 0, a);
   }
   function dequeue_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     front = t[2],
     res = caml_call2(Base_Option_array[36], elts, front);
    caml_call2(Base_Option_array[45], elts, front);
    t[2] = elts_index(t, 1);
    t[4] = caml_call2(Base_Import[93], t[4], 1);
    return res;
   }
   function back_index(t){
    return elts_index(t, caml_call2(Base_Import[93], t[4], 1));
   }
   function dequeue_back_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     back = back_index(t),
     res = caml_call2(Base_Option_array[36], elts, back);
    caml_call2(Base_Option_array[45], elts, back);
    t[4] = caml_call2(Base_Import[93], t[4], 1);
    return res;
   }
   function dequeue_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_nonempty(t);
   }
   function dequeue(t){return is_empty(t) ? 0 : [0, dequeue_nonempty(t)];}
   function dequeue_and_ignore_exn(t){dequeue_exn(t); return 0;}
   function dequeue_back_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_back_nonempty(t);
   }
   function dequeue_back(t){
    return is_empty(t) ? 0 : [0, dequeue_back_nonempty(t)];
   }
   function front_nonempty(t){
    return caml_call2(Base_Option_array[40], t[5], t[2]);
   }
   function back_nonempty(t){
    var _aw_ = back_index(t);
    return caml_call2(Base_Option_array[40], t[5], _aw_);
   }
   function last_nonempty(t){
    return unsafe_get(t, caml_call2(Base_Import[93], t[4], 1));
   }
   function peek(t){return is_empty(t) ? 0 : [0, front_nonempty(t)];}
   function peek_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return front_nonempty(t);
   }
   function peek_back(t){return is_empty(t) ? 0 : [0, back_nonempty(t)];}
   function peek_back_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return back_nonempty(t);
   }
   function last(t){return is_empty(t) ? 0 : [0, last_nonempty(t)];}
   function last_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return last_nonempty(t);
   }
   function drain(t, f, while$0){
    for(;;){
     if(! is_empty(t) && caml_call1(while$0, front_nonempty(t))){caml_call1(f, dequeue_nonempty(t)); continue;}
     return 0;
    }
   }
   function clear(t){
    inc_num_mutations(t);
    var _ar_ = 0 < t[4] ? 1 : 0;
    if(_ar_){
     var _at_ = caml_call2(Base_Import[93], t[4], 1), _as_ = 0;
     if(_at_ >= 0){
      var i = _as_;
      for(;;){
       var _aq_ = elts_index(t, i);
       caml_call2(Base_Option_array[52], t[5], _aq_);
       var _av_ = i + 1 | 0;
       if(_at_ === i) break;
       var i = _av_;
      }
     }
     t[4] = 0;
     t[2] = 0;
     var _au_ = 0;
    }
    else
     var _au_ = _ar_;
    return _au_;
   }
   function blit_transfer(src, dst, len, param){
    inc_num_mutations(src);
    inc_num_mutations(dst);
    if(len){
     var len$0 = len[1];
     if(len$0 < 0){
      var
       _aa_ = [0, [0, cst_length$0, caml_call1(Base_Int[10], len$0)], 0],
       _ab_ = caml_call2(Base_Sexp[10], cst_Queue_blit_transfer_negati, _aa_);
      caml_call1(Base_Error[32], _ab_);
     }
     var len$1 = caml_call2(Base_Import[101], len$0, src[4]);
    }
    else
     var len$1 = src[4];
    var _ac_ = 0 < len$1 ? 1 : 0;
    if(_ac_){
     var
      _ad_ = caml_call2(Base_Import[91], dst[4], len$1),
      _ae_ = capacity(dst);
     set_capacity(dst, caml_call2(Base_Import[100], _ae_, _ad_));
     var
      dst_start = caml_call2(Base_Import[91], dst[2], dst[4]),
      _ag_ = caml_call2(Base_Import[93], len$1, 1),
      _af_ = 0;
     if(_ag_ >= 0){
      var i = _af_;
      for(;;){
       var
        _ak_ = src[3],
        _al_ = caml_call2(Base_Import[91], src[2], i),
        src_i = caml_call2(Base_Import[116], _al_, _ak_),
        _am_ = dst[3],
        _an_ = caml_call2(Base_Import[91], dst_start, i),
        dst_i = caml_call2(Base_Import[116], _an_, _am_),
        _ao_ = caml_call2(Base_Option_array[40], src[5], src_i);
       caml_call3(Base_Option_array[51], dst[5], dst_i, _ao_);
       caml_call2(Base_Option_array[52], src[5], src_i);
       var _ap_ = i + 1 | 0;
       if(_ag_ === i) break;
       var i = _ap_;
      }
     }
     dst[4] = caml_call2(Base_Import[91], dst[4], len$1);
     var _ah_ = src[3], _ai_ = caml_call2(Base_Import[91], src[2], len$1);
     src[2] = caml_call2(Base_Import[116], _ai_, _ah_);
     src[4] = caml_call2(Base_Import[93], src[4], len$1);
     var _aj_ = 0;
    }
    else
     var _aj_ = _ac_;
    return _aj_;
   }
   function enqueue_all(t, l){
    var
     _Y_ = caml_call1(Base_List[45], l),
     _Z_ = caml_call2(Base_Import[91], t[4], _Y_),
     ___ = capacity(t);
    set_capacity(t, caml_call2(Base_Int[16], ___, _Z_));
    function _$_(x){return enqueue(t, x);}
    return caml_call2(Base_List[19], l, _$_);
   }
   function fold(t, init, f){
    if(0 === t[4]) return init;
    var
     num_mutations = t[1],
     r = [0, init],
     _V_ = caml_call2(Base_Import[93], t[4], 1),
     _U_ = 0;
    if(_V_ >= 0){
     var i = _U_;
     for(;;){
      var _W_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _W_);
      ensure_no_mutation(t, num_mutations);
      var _X_ = i + 1 | 0;
      if(_V_ === i) break;
      var i = _X_;
     }
    }
    return r[1];
   }
   function foldi(t, init, f){
    var i = [0, 0];
    return fold
            (t,
             init,
             function(acc, a){
              var acc$0 = caml_call3(f, i[1], acc, a);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return acc$0;
             });
   }
   function iter(t, f){
    var
     num_mutations = t[1],
     _S_ = caml_call2(Base_Import[93], t[4], 1),
     _R_ = 0;
    if(_S_ >= 0){
     var i = _R_;
     for(;;){
      caml_call1(f, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _T_ = i + 1 | 0;
      if(_S_ === i) break;
      var i = _T_;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var
     num_mutations = t[1],
     _P_ = caml_call2(Base_Import[93], t[4], 1),
     _O_ = 0;
    if(_P_ >= 0){
     var i = _O_;
     for(;;){
      caml_call2(f, i, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _Q_ = i + 1 | 0;
      if(_P_ === i) break;
      var i = _Q_;
     }
    }
    return 0;
   }
   function to_list(t){
    var result = [0, 0], _L_ = caml_call2(Base_Import[93], t[4], 1);
    if(_L_ >= 0){
     var i = _L_;
     for(;;){
      var _M_ = result[1];
      result[1] = [0, unsafe_get(t, i), _M_];
      var _N_ = i - 1 | 0;
      if(0 === i) break;
      var i = _N_;
     }
    }
    return result[1];
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    foldi$0 = [0, -198771759, foldi],
    iteri$0 = [0, -198771759, iteri],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, iteri$0, foldi$0]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    for_alli = C[21];
   function concat_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       function _J_(b){return enqueue(t_result, b);}
       var _K_ = caml_call1(f, a);
       return caml_call2(Base_List[19], _K_, _J_);
      });
    return t_result;
   }
   function concat_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       function _H_(b){return enqueue(t_result, b);}
       var _I_ = caml_call2(f, i, a);
       return caml_call2(Base_List[19], _I_, _H_);
      });
    return t_result;
   }
   function filter_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var _G_ = caml_call1(f, a);
       return _G_ ? enqueue(t_result, a) : _G_;
      });
    return t_result;
   }
   function filteri(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var _F_ = caml_call2(f, i, a);
       return _F_ ? enqueue(t_result, a) : _F_;
      });
    return t_result;
   }
   function filter_inplace(t, f){
    var t2 = filter(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function filteri_inplace(t, f){
    var t2 = filteri(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function copy(src){
    var dst = create([0, src[4]], 0);
    blit_to_array(src, dst[5]);
    dst[4] = src[4];
    return dst;
   }
   function of_list(l){
    var t = create([0, caml_call1(Base_List[45], l)], 0);
    function _E_(x){return enqueue(t, x);}
    caml_call2(Base_List[19], l, _E_);
    return t;
   }
   function init(len, f){
    if(len < 0){
     var
      _y_ = [0, [0, cst_length$1, caml_call1(Base_Int[10], len)], 0],
      _z_ = caml_call2(Base_Sexp[10], cst_Queue_init_negative_length, _y_);
     caml_call1(Base_Error[32], _z_);
    }
    var t = create([0, len], 0);
    if(len > caml_call1(Base_Option_array[28], t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _B_ = caml_call2(Base_Import[93], len, 1), _A_ = 0;
    if(_B_ >= 0){
     var i = _A_;
     for(;;){
      var _C_ = caml_call1(f, i);
      caml_call3(Base_Option_array[51], t[5], i, _C_);
      var _D_ = i + 1 | 0;
      if(_B_ === i) break;
      var i = _D_;
     }
    }
    t[4] = len;
    return t;
   }
   function of_array(a){
    return init(a.length - 1, function(_x_){return a[1 + _x_];});
   }
   function to_array(t){
    function _w_(i){return unsafe_get(t, i);}
    return caml_call2(Base_Array[41], t[4], _w_);
   }
   function map(ta, f){
    var num_mutations = ta[1], tb = create([0, ta[4]], 0);
    tb[4] = ta[4];
    var _u_ = caml_call2(Base_Import[93], ta[4], 1), _t_ = 0;
    if(_u_ >= 0){
     var i = _t_;
     for(;;){
      var b = caml_call1(f, unsafe_get(ta, i));
      ensure_no_mutation(ta, num_mutations);
      caml_call3(Base_Option_array[51], tb[5], i, b);
      var _v_ = i + 1 | 0;
      if(_u_ === i) break;
      var i = _v_;
     }
    }
    return tb;
   }
   function mapi(t, f){
    var i = [0, 0];
    return map
            (t,
             function(a){
              var result = caml_call2(f, i[1], a);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return result;
             });
   }
   function singleton(x){var t = create(_q_, 0); enqueue(t, x); return t;}
   function sexp_of_t(sexp_of_a, t){
    var _s_ = to_list(t);
    return caml_call1(caml_call1(Base_List[6], sexp_of_a), _s_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[5], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _r_ = caml_call1(Base_List[7], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _r_);
   }
   function start(q){return q[1];}
   function assert_no_mutation_since_start(t, q){return ensure_no_mutation(q, t);
   }
   var
    Iteration = [0, start, assert_no_mutation_since_start],
    Base_Queue =
      [0,
       compare,
       compare_local,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       dequeue_and_ignore_exn,
       drain,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       equal,
       equal_local,
       invariant,
       create,
       last,
       last_exn,
       enqueue_front,
       dequeue_back,
       dequeue_back_exn,
       peek_back,
       peek_back_exn,
       blit_transfer,
       get,
       set,
       capacity,
       set_capacity,
       Iteration];
   runtime.caml_register_global(39, Base_Queue, "Base__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nothing
//# unitInfo: Requires: Base__Identifiable, Base__Import, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [4, 0],
    module_name = "Base.Nothing",
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Match_failure = global_data.Match_failure,
    Base_Identifiable = global_data.Base__Identifiable,
    cst_Base_Nothing_of_string_not = "Base.Nothing.of_string: not supported",
    cst_Base_Nothing_t = "Base.Nothing.t",
    _a_ = [0, "src/nothing.ml", 6, 31];
   function unreachable_code_local(param){
    throw caml_maybe_attach_backtrace([0, Match_failure, _a_], 1);
   }
   function unreachable_code(x){return unreachable_code_local(x);}
   var all = 0;
   function hash_fold_t(param, t){return unreachable_code(t);}
   function compare(a, param){return unreachable_code(a);}
   function compare_local(a, param){return unreachable_code(a);}
   function equal_local(a, param){return unreachable_code(a);}
   function t_of_sexp(sexp){
    return caml_call2(Sexplib0_Sexp_conv_error[30], cst_Base_Nothing_t, sexp);
   }
   function of_string(param){
    return caml_call1(Base_Import[124], cst_Base_Nothing_of_string_not);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         unreachable_code,
         t_of_sexp,
         unreachable_code,
         of_string,
         unreachable_code,
         module_name]),
    hash_fold_t$0 = include[1],
    hash = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t = include[4],
    of_string$0 = include[5],
    to_string = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function must_be_none(param){return 0;}
   function must_be_empty(param){return 0;}
   function must_be_ok(param){var ok = param[1]; return ok;}
   function must_be_error(param){var error = param[1]; return error;}
   function must_be_first(param){var first = param[1]; return first;}
   function must_be_second(param){var second = param[1]; return second;}
   var
    Base_Nothing =
      [0,
       all,
       unreachable_code,
       t_sexp_grammar,
       unreachable_code,
       unreachable_code_local,
       hash_fold_t$0,
       hash,
       t_of_sexp$0,
       sexp_of_t,
       of_string$0,
       to_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       equal_local,
       compare_local,
       must_be_none,
       must_be_empty,
       must_be_ok,
       must_be_error,
       must_be_first,
       must_be_second];
   runtime.caml_register_global(9, Base_Nothing, "Base__Nothing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nativeint
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Word_size, Stdlib__Nativeint, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_nx = "%nx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Nativeint.Hex",
    module_name$0 = "Base.Nativeint",
    Base_Int_math = global_data.Base__Int_math,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Printf = global_data.Base__Printf,
    Base_Float0 = global_data.Base__Float0,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Word_size = global_data.Base__Word_size,
    Base_Error = global_data.Base__Error,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    include = Base_Import[104],
    compare = include[9],
    globalize = Base_Import[287],
    hash_fold_t = Base_Import[202],
    func = Base_Import[216],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _f_ = [0, "src/nativeint.ml", 206, 2],
    cst_Nativeint_ceil_log2_got_in = "[Nativeint.ceil_log2] got invalid input",
    cst_Nativeint_floor_log2_got_i =
      "[Nativeint.floor_log2] got invalid input",
    _e_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    _d_ =
      [0,
       [11,
        "Nativeint.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Nativeint.of_float: argument (%f) is out of range or NaN"],
    _c_ = [0, [6, 6, 0, 0, 0], cst_nx],
    _b_ = [0, [6, 6, 0, 0, 0], cst_nx];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[167],
    sexp_of_t = Base_Import[143],
    t_sexp_grammar = Base_Import[189],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[104][9],
    to_string = Stdlib_Nativeint[15],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib_Nativeint[14],
    comparator = caml_call1(Base_Comparator[7], [0, compare$0, sexp_of_t])[1],
    zero = Stdlib_Nativeint[1],
    _a_ = caml_call1(Base_Comparable[14], [0, compare$0, sexp_of_t, zero]),
    is_positive = _a_[1],
    is_non_negative = _a_[2],
    is_negative = _a_[3],
    is_non_positive = _a_[4],
    sign = _a_[5],
    include$0 = caml_call1(Base_Int_string_conversions[1], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$0 = include$0[2],
    compare_local = Base_Import[259];
   function compare$1(a, b){return caml_call2(compare_local, a, b);}
   var hash_fold_t$0 = Base_Import[202], func$0 = Base_Import[216];
   function hash$0(x){return caml_call1(func$0, x);}
   var zero$0 = Stdlib_Nativeint[1];
   function neg(___){return - ___ | 0;}
   var symbol = Base_Import[104][1];
   function to_string$0(i){return caml_call2(Base_Printf[2], _b_, i);}
   function of_string$0(s){
    function _Y_(_Z_){return _Z_;}
    return caml_call3(Stdlib_Scanf[5], s, _c_, _Y_);
   }
   var
    include$1 =
      caml_call1
       (Base_Int_string_conversions[2],
        [0,
         compare$1,
         compare_local,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero$0,
         symbol,
         neg,
         module_name]),
    Hex = include$1[1],
    include$2 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$2[1];
   function invariant(param){return 0;}
   var
    num_bits = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    float_lower_bound = caml_call1(Base_Float0[26], num_bits),
    float_upper_bound = caml_call1(Base_Float0[24], num_bits);
   function shift_right_logical(_X_, _W_){return _X_ >>> _W_ | 0;}
   function shift_right(_V_, _U_){return _V_ >> _U_;}
   function shift_left(_T_, _S_){return _T_ << _S_;}
   var bit_not = Stdlib_Nativeint[12];
   function bit_xor(_R_, _Q_){return _R_ ^ _Q_;}
   function bit_or(_P_, _O_){return _P_ | _O_;}
   function bit_and(_N_, _M_){return _N_ & _M_;}
   var
    min_value = Stdlib_Nativeint[11],
    max_value = Stdlib_Nativeint[10],
    abs = Stdlib_Nativeint[8],
    pred = Stdlib_Nativeint[7],
    succ = Stdlib_Nativeint[6],
    rem = runtime.caml_mod;
   function symbol$0(_L_){return - _L_ | 0;}
   var
    minus_one = Stdlib_Nativeint[3],
    one = Stdlib_Nativeint[2],
    zero$1 = Stdlib_Nativeint[1];
   function to_float(_K_){return _K_;}
   function of_float_unchecked(_J_){return _J_ | 0;}
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound) return f | 0;
    var _I_ = caml_call1(Base_Float0[29], f);
    return caml_call3(Base_Printf[7], _d_, _I_, 0);
   }
   var raise_s = Base_Error[32];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _e_, 0);
   }
   function lsr(_H_, _G_){return _H_ >>> _G_ | 0;}
   function land(_F_, _E_){return _F_ & _E_;}
   function ceil_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Nativeint[7], x),
     x$1 = x$0 | x$0 >>> 1 | 0,
     x$2 = x$1 | x$1 >>> 2 | 0,
     x$3 = x$2 | x$2 >>> 4 | 0,
     x$4 = x$3 | x$3 >>> 8 | 0,
     x$5 = x$4 | x$4 >>> 16 | 0,
     x$6 = x$5 | x$5 >>> 32 | 0;
    return caml_call1(Stdlib_Nativeint[6], x$6);
   }
   function floor_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var
     x$0 = x | x >>> 1 | 0,
     x$1 = x$0 | x$0 >>> 2 | 0,
     x$2 = x$1 | x$1 >>> 4 | 0,
     x$3 = x$2 | x$2 >>> 8 | 0,
     x$4 = x$3 | x$3 >>> 16 | 0,
     x$5 = x$4 | x$4 >>> 32 | 0;
    return x$5 - (x$5 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var _D_ = x & caml_call1(Stdlib_Nativeint[7], x);
    return caml_call2(Base_Import[104][4], _D_, 0);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _A_ = [0, [0, cst, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Nativeint_floor_log2_got_i, _A_));
    }
    var
     _B_ = runtime.Base_int_math_nativeint_clz(i),
     _C_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _C_, _B_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _y_ = [0, [0, cst$0, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Nativeint_ceil_log2_got_in, _y_));
    }
    if(caml_call2(Stdlib_Nativeint[18], i, Stdlib_Nativeint[2])) return 0;
    var
     _z_ =
       runtime.Base_int_math_nativeint_clz(caml_call1(Stdlib_Nativeint[7], i));
    return caml_call2(Base_Import[93], num_bits, _z_);
   }
   function between(t, low, high){
    var _x_ = caml_call2(Base_Import[104][2], low, t);
    return _x_ ? caml_call2(Base_Import[104][2], t, high) : _x_;
   }
   function clamp_unchecked(t, min, max){
    var _w_ = caml_call2(Base_Import[104][14], t, max);
    return caml_call1(caml_call1(Base_Import[104][13], min), _w_);
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[104][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[104][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _t_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _u_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _t_],
     _v_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _u_);
    return caml_call1(Base_Or_error[39], _v_);
   }
   var symbol$1 = runtime.caml_div, symbol$2 = runtime.caml_mul;
   function symbol$3(_s_, _r_){return _s_ - _r_ | 0;}
   function symbol$4(_q_, _p_){return _q_ + _p_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_nativeint(t){return t;}
   function to_nativeint(t){return t;}
   var
    popcount = Base_Popcount[4],
    of_int_exn = Base_Int_conversions[5],
    to_int = Base_Int_conversions[23],
    to_int_exn = Base_Int_conversions[24],
    to_int_trunc = Base_Int_conversions[25],
    of_int32 = Base_Int_conversions[10],
    to_int32 = Base_Int_conversions[26],
    to_int32_exn = Base_Int_conversions[27],
    of_int64 = Base_Int_conversions[18],
    of_int64_exn = Base_Int_conversions[19],
    of_int64_trunc = Base_Int_conversions[20],
    to_int64 = Base_Int_conversions[29];
   function pow(b, e){
    var _n_ = caml_call1(to_int_exn, e), _o_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _o_, _n_));
   }
   function symbol$5(b, e){return pow(b, e);}
   var compare_local$0 = Base_Import[259];
   function compare$2(a, b){return caml_call2(compare_local$0, a, b);}
   var equal_local = Base_Import[273];
   function equal(a, b){return caml_call2(equal_local, a, b);}
   var hash_fold_t$1 = Base_Import[202], func$1 = Base_Import[216];
   function hash$1(x){return caml_call1(func$1, x);}
   function clz(_m_){return runtime.Base_int_math_nativeint_clz(_m_);}
   var
    Binary =
      caml_call1
        (Base_Int_string_conversions[3],
         [0,
          compare$2,
          compare_local$0,
          equal,
          equal_local,
          hash_fold_t$1,
          hash$1,
          clz,
          lsr,
          land,
          to_int_exn,
          num_bits,
          one,
          zero$1])
       [1],
    _g_ = Base_Import[104],
    symbol$6 = _g_[3],
    symbol$7 = _g_[1],
    symbol$8 = _g_[5],
    symbol$9 = _g_[4],
    symbol$10 = _g_[2],
    symbol$11 = _g_[6],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$4,
         symbol$3,
         symbol$2,
         symbol$1,
         symbol$0,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$0,
         zero$1,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[104],
    symbol$15 = include$4[1],
    symbol$16 = include$4[2],
    symbol$17 = include$4[3],
    symbol$18 = include$4[4],
    symbol$19 = include$4[5],
    symbol$20 = include$4[6],
    ascending = include$4[7],
    descending = include$4[8],
    compare$3 = include$4[9],
    compare_local$1 = include$4[10],
    equal$0 = include$4[11],
    equal_local$0 = include$4[12],
    max = include$4[13],
    min = include$4[14],
    _h_ = runtime.caml_int32_bswap,
    _i_ =
      [0,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$1,
       symbol$0,
       symbol$5,
       symbol$11,
       symbol$10,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       abs,
       symbol$0,
       zero$1,
       symbol$12,
       symbol$13,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical];
   function _j_(_l_){return runtime.Base_int_math_nativeint_ctz(_l_);}
   var
    Base_Nativeint =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$20,
       symbol$16,
       symbol$18,
       symbol$19,
       symbol$15,
       symbol$17,
       equal$0,
       compare$3,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       compare_local$1,
       equal_local$0,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       zero$1,
       one,
       minus_one,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$5,
       symbol$0,
       symbol$0,
       symbol$13,
       symbol$12,
       symbol$1,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_k_){return runtime.Base_int_math_nativeint_clz(_k_);},
       _j_,
       _i_,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       to_int_trunc,
       of_int64_trunc,
       _h_];
   runtime.caml_register_global(35, Base_Nativeint, "Base__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map
//# unitInfo: Requires: Base__Comparator, Base__Error, Base__Exn, Base__Import, Base__List0, Base__Map_intf, Base__Maybe_bound, Base__Option, Base__Or_error, Base__Result, Base__Sequence, Base__Sexp, Base__Uniform_array, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    cst_Map_of$1 = "Map.of_",
    cst_key$1 = "key",
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_map_ml = "src/map.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    name = "alist",
    name$0 = "sequence",
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Comparator = global_data.Base__Comparator,
    Base_Result = global_data.Base__Result,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_List0 = global_data.Base__List0,
    Assert_failure = global_data.Assert_failure,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Maybe_bound = global_data.Base__Maybe_bound,
    Base_Map_intf = global_data.Base__Map_intf,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Symmetric_diff_element = Base_Map_intf[5],
    include = Base_Map_intf[8],
    compare = include[1],
    all = include[2],
    equal = include[3],
    sexp_of_t = include[4],
    _x_ = [1, 0],
    _y_ = [1, 0],
    _z_ = [1, 0],
    _w_ = [0, "_"],
    _v_ = [0, "Map.Build_increasing.add: non-increasing key"],
    _h_ = [0, 0, 0, 0],
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _s_ = [0, 0],
    cst_key$0 = cst_key$1,
    cst_Map_map_keys_exn_duplicate = "Map.map_keys_exn: duplicate key",
    cst_Map_t_of_sexp_direct_dupli = "Map.t_of_sexp_direct: duplicate key",
    _u_ = [0, cst_src_map_ml, 1967, 6],
    cst_Map_of_iteri_exn_duplicate = "Map.of_iteri_exn: duplicate key",
    _t_ = [0, 0],
    cst_Map_merge_disjoint_exn_dup = "Map.merge_disjoint_exn: duplicate key",
    cst_Map_of_list_with_key_exn_d = "Map.of_list_with_key_exn: duplicate key",
    cst_Map_of_list_with_key_or_er =
      "Map.of_list_with_key_or_error: duplicate key",
    cst_exn_duplicate_key = "_exn: duplicate key",
    cst_Map_of$0 = cst_Map_of$1,
    cst_or_error_duplicate_key = "_or_error: duplicate key",
    cst_Map_of = cst_Map_of$1,
    _r_ = [0, cst_src_map_ml, 1145, 17],
    _q_ = [0, 0, 0],
    _o_ = [0, "map.ml.Tree0.Map_max_elt_exn_of_empty_map"],
    _p_ = [0, cst_src_map_ml, 677, 13],
    _l_ = [0, "map.ml.Tree0.Map_min_elt_exn_of_empty_map"],
    _m_ = [0, cst_src_map_ml, 664, 13],
    _j_ = [0, "Map.find_exn: not found"],
    _i_ = [0, cst_src_map_ml, 578, 4],
    cst_of_increasing_sequence_non =
      "of_increasing_sequence: non-increasing key",
    _g_ = [0, cst_src_map_ml, 480, 21],
    _f_ = [1, 0],
    cst_key = cst_key$1,
    cst_Map_add_exn_got_key_alread = "[Map.add_exn] got key already present",
    cst_Map_bal = cst_Map_bal$3,
    _d_ = [0, cst_src_map_ml, 248, 18],
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    _e_ = [0, cst_src_map_ml, 263, 18],
    cst_Map_bal$2 = cst_Map_bal$3,
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    _b_ = [0, "map.ml.Duplicate"],
    _c_ = [0, cst_src_map_ml, 67, 11],
    cst_Base_Map_Duplicate = "Base__Map.Duplicate",
    cst_Base_Map_Tree0_Map_min_elt =
      "Base__Map.Tree0.Map_min_elt_exn_of_empty_map",
    cst_Base_Map_Tree0_Map_max_elt =
      "Base__Map.Tree0.Map_max_elt_exn_of_empty_map";
   function of_continue_or_stop(_dV_){return _dV_;}
   function to_continue_or_stop(_dU_){return _dU_;}
   var
    Finished_or_unfinished =
      [0,
       compare,
       all,
       equal,
       sexp_of_t,
       of_continue_or_stop,
       to_continue_or_stop],
    include$0 = Base_Map_intf[6],
    compare$0 = include$0[1],
    equal$0 = include$0[2],
    sexp_of_t$0 = include$0[3];
   function left(param){
    var _dT_ = param[1];
    if(737457313 === _dT_)
     var left = param[2][1];
    else{if(847852583 > _dT_) return 0; var left = param[2];}
    return [0, left];
   }
   function right(param){
    var _dS_ = param[1];
    if(737457313 === _dS_)
     var right = param[2][2];
    else{if(847852583 <= _dS_) return 0; var right = param[2];}
    return [0, right];
   }
   function left_value(t, default$0){
    var _dR_ = t[1];
    if(737457313 === _dR_)
     var left = t[2][1];
    else{if(847852583 > _dR_) return default$0; var left = t[2];}
    return left;
   }
   function right_value(t, default$0){
    var _dQ_ = t[1];
    if(737457313 === _dQ_)
     var right = t[2][2];
    else{if(847852583 <= _dQ_) return default$0; var right = t[2];}
    return right;
   }
   function values(t, left_default, right_default){
    var _dP_ = t[1];
    if(737457313 === _dP_){
     var match = t[2], right = match[2], left = match[1];
     return [0, left, right];
    }
    if(847852583 <= _dP_){
     var left$0 = t[2];
     return [0, left$0, right_default];
    }
    var right$0 = t[2];
    return [0, left_default, right$0];
   }
   var
    Merge_element =
      [0,
       compare$0,
       equal$0,
       sexp_of_t$0,
       left,
       right,
       left_value,
       right_value,
       values],
    with_return = Base_With_return[1],
    Duplicate = [248, cst_Base_Map_Duplicate, caml_fresh_oo_id(0)];
   function _a_(param){
    if(param === Duplicate) return _b_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Duplicate, _a_);
   function globalize(param){
    var length = param[2], tree = param[1];
    return [0, tree, length];
   }
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[5];
    return h;
   }
   function in_range(lower, upper, compare_key, k){
    if(lower)
     var
      lower$0 = lower[1],
      _dN_ = caml_call2(compare_key, lower$0, k) < 0 ? 1 : 0;
    else
     var _dN_ = 1;
    if(_dN_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_key, k, upper$0) < 0 ? 1 : 0;
     }
     var _dO_ = 1;
    }
    else
     var _dO_ = _dN_;
    return _dO_;
   }
   function loop(lower, upper, compare_key, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var k = t$0[1];
      return in_range(lower$0, upper, compare_key, k);
     }
     var
      h = t$0[5],
      r = t$0[4],
      k$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _dG_ = caml_call2(Base_Import[93], hl, hr),
      _dH_ = caml_call1(Base_Import[123], _dG_) <= 2 ? 1 : 0;
     if(_dH_){
      var
       _dI_ = caml_call2(Base_Import[100], hl, hr),
       _dJ_ = h === caml_call2(Base_Import[91], _dI_, 1) ? 1 : 0;
      if(_dJ_){
       var _dK_ = in_range(lower$0, upper, compare_key, k$0);
       if(_dK_){
        var _dL_ = loop(lower$0, [0, k$0], compare_key, l);
        if(_dL_){
         var lower$1 = [0, k$0], lower$0 = lower$1, t$0 = r;
         continue;
        }
        var _dM_ = _dL_;
       }
       else
        var _dM_ = _dK_;
      }
      else
       var _dM_ = _dJ_;
     }
     else
      var _dM_ = _dH_;
     return _dM_;
    }
   }
   function invariants(t, compare_key){return loop(0, 0, compare_key, t);}
   function create_with_heights(hl, hr, l, x, d, r){
    if(0 === hl && 0 === hr) return [0, x, d];
    var
     _dF_ =
       hr <= hl
        ? caml_call2(Base_Import[91], hl, 1)
        : caml_call2(Base_Import[91], hr, 1);
    return [1, l, x, d, r, _dF_];
   }
   function create(l, x, d, r){
    var _dE_ = height(r);
    return create_with_heights(height(l), _dE_, l, x, d, r);
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var match$0 = caml_call1(f, i), v$0 = match$0[2], k$0 = match$0[1];
         return [0, k$0, v$0];
        case 2:
         var
          match$1 = caml_call1(f, i),
          vl = match$1[2],
          kl = match$1[1],
          match$2 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          v$1 = match$2[2],
          k$1 = match$2[1];
         return [1, [0, kl, vl], k$1, v$1, 0, 2];
        default:
         var
          match$3 = caml_call1(f, i),
          vl$0 = match$3[2],
          kl$0 = match$3[1],
          match$4 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          v$2 = match$4[2],
          k$2 = match$4[1],
          match$5 = caml_call1(f, caml_call2(Base_Import[91], i, 2)),
          vr = match$5[2],
          kr = match$5[1];
         return [1, [0, kl$0, vl$0], k$2, v$2, [0, kr, vr], 2];
      }
     var
      left_length = caml_call2(Base_Import[120], n, 1),
      _dC_ = caml_call2(Base_Import[93], n, left_length),
      right_length = caml_call2(Base_Import[93], _dC_, 1),
      left = loop(left_length, f, i),
      match = caml_call1(f, caml_call2(Base_Import[91], i, left_length)),
      v = match[2],
      k = match[1],
      _dD_ = caml_call2(Base_Import[91], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[91], _dD_, 1));
     return create(left, k, v, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_key){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var
       k0 = caml_check_bound(array, 0)[1][1],
       k1 = caml_check_bound(array, 1)[2][1];
      if(caml_call2(compare_key, k0, k1) >= 0){
       var
        next =
          function(i){
           var
            _dA_ = caml_call2(Base_Import[93], array_length, 1),
            _dB_ = caml_call2(Base_Import[93], _dA_, i);
           return caml_check_bound(array, _dB_)[1 + _dB_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return [0,
            of_increasing_iterator_uncheck(array_length, next),
            array_length];
   }
   function of_sorted_array(array, compare_key){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _dq_ = caml_check_bound(array, 1)[2],
                _dr_ = caml_call1(Base_Import[125], _dq_),
                _ds_ = caml_check_bound(array, 0)[1],
                i =
                  caml_call2
                   (compare_key, caml_call1(Base_Import[125], _ds_), _dr_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[40], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _du_ = caml_call2(Base_Import[93], array.length - 1, 2),
                _dt_ = 1;
               if(_du_ >= 1){
                var i$0 = _dt_;
                for(;;){
                 var
                  _dv_ = caml_call2(Base_Import[91], i$0, 1),
                  _dw_ = caml_check_bound(array, _dv_)[1 + _dv_],
                  _dx_ = caml_call1(Base_Import[125], _dw_),
                  _dy_ = caml_check_bound(array, i$0)[1 + i$0],
                  i$1 =
                    caml_call2
                     (compare_key, caml_call1(Base_Import[125], _dy_), _dx_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[40], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[40], cst_of_sorted_array_elements_a));
                 var _dz_ = i$0 + 1 | 0;
                 if(_du_ === i$0) break;
                 var i$0 = _dz_;
                }
               }
               return [0,
                       globalize(of_sorted_array_unchecked(array, compare_key))];
              });
    return [0, globalize(of_sorted_array_unchecked(array, compare_key))];
   }
   function bal(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(caml_call2(Base_Import[91], hr, 2) < hl){
     if(typeof l === "number")
      return caml_call1(Base_Import[126], cst_Map_bal);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _dk_ = height(lr);
     if(_dk_ <= height(ll)) return create(ll, lv, ld, create(lr, x, d, r));
     if(typeof lr === "number")
      return caml_call1(Base_Import[126], cst_Map_bal$0);
     if(0 === lr[0]){
      var lrd = lr[2], lrv = lr[1], _dl_ = create(0, x, d, r);
      return create(create(ll, lv, ld, 0), lrv, lrd, _dl_);
     }
     var
      lrr = lr[4],
      lrd$0 = lr[3],
      lrv$0 = lr[2],
      lrl = lr[1],
      _dm_ = create(lrr, x, d, r);
     return create(create(ll, lv, ld, lrl), lrv$0, lrd$0, _dm_);
    }
    if(caml_call2(Base_Import[91], hl, 2) >= hr)
     return create_with_heights(hl, hr, l, x, d, r);
    if(typeof r === "number")
     return caml_call1(Base_Import[126], cst_Map_bal$1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _dn_ = height(rl);
    if(_dn_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
    if(typeof rl === "number")
     return caml_call1(Base_Import[126], cst_Map_bal$2);
    if(0 === rl[0]){
     var rld = rl[2], rlv = rl[1], _do_ = create(0, rv, rd, rr);
     return create(create(l, x, d, 0), rlv, rld, _do_);
    }
    var
     rlr = rl[4],
     rld$0 = rl[3],
     rlv$0 = rl[2],
     rll = rl[1],
     _dp_ = create(rlr, rv, rd, rr);
    return create(create(l, x, d, rll), rlv$0, rld$0, _dp_);
   }
   var empty_without_value_restrictio = 0;
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function raise_key_already_present(key, sexp_of_key){
    var
     _di_ = [0, [0, cst_key, caml_call1(sexp_of_key, key)], 0],
     _dj_ = caml_call2(Base_Sexp[10], cst_Map_add_exn_got_key_alread, _di_);
    return caml_call1(Base_Error[32], _dj_);
   }
   function find_and_add_or_set
   (t, length, x, data, compare_key, sexp_of_key, add_or_set){
    if(typeof t === "number")
     return [0, [0, x, data], caml_call2(Base_Import[91], length, 1)];
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, x, v);
     if(0 === c)
      switch(add_or_set){
        case 0:
         return caml_call1(Base_Exn[6], Duplicate);
        case 1:
         return raise_key_already_present(x, sexp_of_key);
        default: return [0, [0, x, data], length];
      }
     return 0 <= c
             ? [0,
               [1, 0, v, d, [0, x, data], 2],
               caml_call2(Base_Import[91], length, 1)]
             : [0,
               [1, [0, x, data], v, d, 0, 2],
               caml_call2(Base_Import[91], length, 1)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     c$0 = caml_call2(compare_key, x, v$0);
    if(0 === c$0)
     switch(add_or_set){
       case 0:
        return caml_call1(Base_Exn[6], Duplicate);
       case 1:
        return raise_key_already_present(x, sexp_of_key);
       default: return [0, [1, l, x, data, r, h], length];
     }
    if(0 <= c$0)
     var
      match =
        find_and_add_or_set
         (r, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$0 = match[2],
      r$0 = match[1],
      length$1 = length$0,
      r$1 = r$0,
      l$0 = l;
    else
     var
      match$0 =
        find_and_add_or_set
         (l, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$2 = match$0[2],
      l$1 = match$0[1],
      length$1 = length$2,
      r$1 = r,
      l$0 = l$1;
    return [0, bal(l$0, v$0, d$0, r$1), length$1];
   }
   function set_min(key, data, t){
    if(typeof t === "number") return [0, key, data];
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [1, [0, key, data], v, d, 0, 2];
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = set_min(key, data, l);
    return bal(l$0, v$0, d$0, r);
   }
   function set_max(t, key, data){
    if(typeof t === "number") return [0, key, data];
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [1, 0, v, d, [0, key, data], 2];
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     r$0 = set_max(r, key, data);
    return bal(l, v$0, d$0, r$0);
   }
   function add_exn(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 1);
   }
   function add_exn_internal(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 0);
   }
   function set(t, length, key, data, compare_key){
    var _dh_ = 2;
    return find_and_add_or_set
            (t,
             length,
             key,
             data,
             compare_key,
             function(param){return _f_;},
             _dh_);
   }
   var empty = 0;
   function max_key(param){
    if(! param) return 0;
    var key = param[1][1];
    return [0, key];
   }
   function add_unchecked(t, key, data){return [0, [0, key, data], t];}
   function to_tree_unchecked(list){
    if(! list) return 0;
    if(list[2]){
     var
      len = caml_call1(Base_List0[5], list),
      list$0 = [0, list],
      loop =
        function(len){
         var _c__ = list$0[1], switcher = len - 1 | 0;
         if(2 >= switcher >>> 0)
          switch(switcher){
            case 0:
             if(_c__){
              var
               tail$0 = _c__[2],
               match$0 = _c__[1],
               data = match$0[2],
               key = match$0[1];
              list$0[1] = tail$0;
              return [0, key, data];
             }
             break;
            case 1:
             if(_c__){
              var _db_ = _c__[2];
              if(_db_){
               var
                tail$1 = _db_[2],
                _dc_ = _db_[1],
                d1 = _dc_[2],
                k1 = _dc_[1],
                match$1 = _c__[1],
                d2 = match$1[2],
                k2 = match$1[1];
               list$0[1] = tail$1;
               return [1, 0, k1, d1, [0, k2, d2], 2];
              }
             }
             break;
            default:
             if(_c__){
              var _dd_ = _c__[2];
              if(_dd_){
               var _de_ = _dd_[2];
               if(_de_){
                var
                 tail$2 = _de_[2],
                 _df_ = _de_[1],
                 d1$0 = _df_[2],
                 k1$0 = _df_[1],
                 _dg_ = _dd_[1],
                 d2$0 = _dg_[2],
                 k2$0 = _dg_[1],
                 match$2 = _c__[1],
                 d3 = match$2[2],
                 k3 = match$2[1];
                list$0[1] = tail$2;
                return [1, [0, k1$0, d1$0], k2$0, d2$0, [0, k3, d3], 2];
               }
              }
             }
          }
         var
          nr = caml_call2(Base_Import[95], len, 2),
          _c$_ = caml_call2(Base_Import[93], len, nr),
          nl = caml_call2(Base_Import[93], _c$_, 1),
          r = loop(nr),
          _da_ = list$0[1];
         if(! _da_)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
         var tail = _da_[2], match = _da_[1], d = match[2], k = match[1];
         list$0[1] = tail;
         var l = loop(nl);
         return create(l, k, d, r);
        };
     return loop(len);
    }
    var match = list[1], data = match[2], key = match[1];
    return [0, key, data];
   }
   function of_increasing_sequence(seq, compare_key){
    return caml_call1
            (with_return,
             function(param){
              function _c7_(param$0, _c8_){
               var
                data = _c8_[2],
                key = _c8_[1],
                length = param$0[2],
                builder = param$0[1],
                match = max_key(builder);
               if(match){
                var prev_key = match[1];
                if(0 <= caml_call2(compare_key, prev_key, key))
                 return caml_call1
                         (param,
                          caml_call1
                           (Base_Or_error[40], cst_of_increasing_sequence_non));
               }
               var _c9_ = caml_call2(Base_Import[91], length, 1);
               return [0, add_unchecked(builder, key, data), _c9_];
              }
              var
               match = caml_call3(Base_Sequence[11], seq, [0, empty, 0], _c7_),
               length = match[2],
               builder = match[1];
              return [0, [0, to_tree_unchecked(builder), length]];
             });
   }
   function join(l, k, d, r){
    if(typeof l === "number") return set_min(k, d, r);
    if(1 === l[0]){
     var lh = l[5], lr = l[4], ld$0 = l[3], lk$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rd = r[2], rk = r[1];
       return set_max(set_max(l, k, d), rk, rd);
      }
      var rh = r[5], rr = r[4], rd$0 = r[3], rk$0 = r[2], rl = r[1];
      if(caml_call2(Base_Import[91], rh, 3) < lh)
       var r$0 = join(lr, k, d, r), d$0 = ld$0, k$0 = lk$0, l$0 = ll;
      else if(caml_call2(Base_Import[91], lh, 3) < rh)
       var r$0 = rr, d$0 = rd$0, k$0 = rk$0, l$0 = join(l, k, d, rl);
      else
       var r$0 = r, d$0 = d, k$0 = k, l$0 = l;
      return bal(l$0, k$0, d$0, r$0);
     }
    }
    if(typeof r === "number") return set_max(l, k, d);
    var ld = l[2], lk = l[1];
    return set_min(lk, ld, set_min(k, d, r));
   }
   function split_gen(t, x, compare_key){
    if(typeof t === "number") return _h_;
    if(0 === t[0]){
     var d = t[2], k = t[1], cmp = caml_call1(compare_key, k);
     return 0 === cmp
             ? [0, 0, [0, [0, k, d]], 0]
             : 0 <= cmp ? [0, t, 0, 0] : [0, 0, 0, t];
    }
    var
     r = t[4],
     d$0 = t[3],
     k$0 = t[2],
     l = t[1],
     cmp$0 = caml_call1(compare_key, k$0);
    if(0 === cmp$0) return [0, l, [0, [0, k$0, d$0]], r];
    if(0 <= cmp$0){
     var
      match = split_gen(r, x, compare_key),
      rr = match[3],
      maybe = match[2],
      rl = match[1];
     return [0, join(l, k$0, d$0, rl), maybe, rr];
    }
    var
     match$0 = split_gen(l, x, compare_key),
     lr = match$0[3],
     maybe$0 = match$0[2],
     ll = match$0[1];
    return [0, ll, maybe$0, join(lr, k$0, d$0, r)];
   }
   function split(t, x, compare_key){
    return split_gen(t, x, function(y){return caml_call2(compare_key, x, y);});
   }
   function split_and_reinsert_boundary(t, into, x, compare_key){
    var
     _c6_ =
       847852583 <= into
        ? function
         (y){
          var res = caml_call2(compare_key, x, y);
          return 0 === res ? 1 : res;
         }
        : function
         (y){
          var res = caml_call2(compare_key, x, y);
          return 0 === res ? -1 : res;
         },
     match = split_gen(t, x, _c6_),
     right = match[3],
     boundary_opt = match[2],
     left = match[1];
    if(caml_call1(Base_Option[52], boundary_opt)) return [0, left, right];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   }
   function split_range(t, lower_bound, upper_bound, compare_key){
    if
     (caml_call3(Base_Maybe_bound[10], lower_bound, upper_bound, compare_key))
     return [0,
             empty_without_value_restrictio,
             empty_without_value_restrictio,
             empty_without_value_restrictio];
    if(typeof lower_bound === "number")
     var mid_and_right = t, left = empty_without_value_restrictio;
    else if(0 === lower_bound[0])
     var
      lb$1 = lower_bound[1],
      _c4_ = split_and_reinsert_boundary(t, -57574468, lb$1, compare_key),
      mid_and_right = _c4_[2],
      left = _c4_[1];
    else
     var
      lb$2 = lower_bound[1],
      _c5_ = split_and_reinsert_boundary(t, 847852583, lb$2, compare_key),
      mid_and_right$0 = _c5_[2],
      left$0 = _c5_[1],
      mid_and_right = mid_and_right$0,
      left = left$0;
    if(typeof upper_bound === "number")
     var right = empty_without_value_restrictio, mid = mid_and_right;
    else if(0 === upper_bound[0])
     var
      lb = upper_bound[1],
      _c2_ =
        split_and_reinsert_boundary(mid_and_right, 847852583, lb, compare_key),
      right = _c2_[2],
      mid = _c2_[1];
    else
     var
      lb$0 = upper_bound[1],
      _c3_ =
        split_and_reinsert_boundary
         (mid_and_right, -57574468, lb$0, compare_key),
      right$0 = _c3_[2],
      mid$0 = _c3_[1],
      right = right$0,
      mid = mid$0;
    return [0, left, mid, right];
   }
   function find(t, x, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v) ? [0, d] : 0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return [0, d$0];
     var r$0 = 0 <= c ? r : l, t$0 = r$0;
    }
   }
   function add_multi(t, length, key, data, compare_key){
    var
     _c1_ = find(t, key, compare_key),
     data$0 = [0, data, caml_call2(Base_Option[30], _c1_, 0)];
    return set(t, length, key, data$0, compare_key);
   }
   function find_multi(t, x, compare_key){
    var match = find(t, x, compare_key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function if_not_found(key, sexp_of_key){
    var _c0_ = [1, [0, _j_, [0, caml_call1(sexp_of_key, key), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _c0_], 1);
   }
   function find_exn(t, x, compare_key, sexp_of_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return if_not_found(x, sexp_of_key);
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v)
              ? d
              : if_not_found(x, sexp_of_key);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return d$0;
     var r$0 = 0 <= c ? r : l, t$0 = r$0;
    }
   }
   function mem(t, x, compare_key){
    var _cZ_ = find(t, x, compare_key);
    return caml_call1(Base_Option[53], _cZ_);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     var l = param$0[1];
     if(typeof l === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var param$0 = l;
    }
   }
   var
    Map_min_elt_exn_of_empty_map =
      [248, cst_Base_Map_Tree0_Map_min_elt, caml_fresh_oo_id(0)];
   function _k_(param){
    if(param === Map_min_elt_exn_of_empty_map) return _l_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Map_min_elt_exn_of_empty_map, _k_);
   var
    Map_max_elt_exn_of_empty_map =
      [248, cst_Base_Map_Tree0_Map_max_elt, caml_fresh_oo_id(0)];
   function _n_(param){
    if(param === Map_max_elt_exn_of_empty_map) return _o_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Map_max_elt_exn_of_empty_map, _n_);
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_min_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     if(typeof param$0[4] === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var r = param$0[4], param$0 = r;
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_max_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(t){
    if(typeof t === "number")
     return caml_call1(Base_Import[126], cst_Map_remove_min_elt);
    if(0 === t[0]) return 0;
    var l = t[1];
    if(typeof l === "number"){var r = t[4]; return r;}
    var r$0 = t[4], d = t[3], x = t[2];
    return bal(remove_min_elt(l), x, d, r$0);
   }
   function append(lower_part, upper_part, compare_key){
    var match = max_elt(lower_part), match$0 = min_elt(upper_part);
    if(! match) return [0, 17724, upper_part];
    if(! match$0) return [0, 17724, lower_part];
    var
     _cY_ = match$0[1],
     v = _cY_[2],
     min_upper = _cY_[1],
     max_lower = match[1][1];
    if(0 <= caml_call2(compare_key, max_lower, min_upper)) return 838882908;
    var upper_part_without_min = remove_min_elt(upper_part);
    return [0, 17724, join(lower_part, min_upper, v, upper_part_without_min)];
   }
   function go(t, min, max, init, f, compare_key){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 === t$0[0]){
      var d = t$0[2], k = t$0[1];
      if
       (0 <= caml_call2(compare_key, k, min)
        && 0 >= caml_call2(compare_key, k, max))
       return caml_call3(f, k, d, init$0);
      return init$0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      k$0 = t$0[2],
      l = t$0[1],
      c_min = caml_call2(compare_key, k$0, min);
     if(0 <= c_min)
      if(0 === c_min)
       var init$1 = caml_call3(f, k$0, d$0, init$0), t$0 = r, init$0 = init$1;
      else{
       var
        z = go(l, min, max, init$0, f, compare_key),
        c_max = caml_call2(compare_key, k$0, max);
       if(0 < c_max) return z;
       var init$2 = caml_call3(f, k$0, d$0, z);
       if(0 === c_max) return init$2;
       var t$0 = r, init$0 = init$2;
      }
     else
      var t$0 = r;
    }
   }
   function fold_range_inclusive(t, min, max, init, f, compare_key){
    return 0 < caml_call2(compare_key, min, max)
            ? init
            : go(t, min, max, init, f, compare_key);
   }
   function range_to_alist(t, min, max, compare_key){
    var
     _cX_ =
       fold_range_inclusive
        (t,
         min,
         max,
         0,
         function(key, data, l){return [0, [0, key, data], l];},
         compare_key);
    return caml_call1(Base_List0[19], _cX_);
   }
   function concat_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return bal(t1, x, d, remove_min_elt(t2));
   }
   function concat_and_balance_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return join(t1, x, d, remove_min_elt(t2));
   }
   function remove(t, x, length, compare_key){
    if(typeof t === "number") return [0, t, length];
    if(0 === t[0]){
     var v = t[1];
     return 0 === caml_call2(compare_key, x, v)
             ? [0, 0, caml_call2(Base_Import[93], length, 1)]
             : [0, t, length];
    }
    var
     r = t[4],
     d = t[3],
     v$0 = t[2],
     l = t[1],
     c = caml_call2(compare_key, x, v$0);
    if(0 === c){
     var _cW_ = caml_call2(Base_Import[93], length, 1);
     return [0, concat_unchecked(l, r), _cW_];
    }
    if(0 <= c)
     var
      match = remove(r, x, length, compare_key),
      length$0 = match[2],
      r$0 = match[1],
      length$1 = length$0,
      r$1 = r$0,
      l$0 = l;
    else
     var
      match$0 = remove(l, x, length, compare_key),
      length$2 = match$0[2],
      l$1 = match$0[1],
      length$1 = length$2,
      r$1 = r,
      l$0 = l$1;
    return length === length$1
            ? [0, t, length]
            : [0, bal(l$0, v$0, d, r$1), length$1];
   }
   function change(t, key, f, length, compare_key){
    if(typeof t === "number"){
     var match = caml_call1(f, 0);
     if(! match) return [0, 0, length];
     var data = match[1];
     return [0, [0, key, data], caml_call2(Base_Import[91], length, 1)];
    }
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
     if(0 === c){
      var match$0 = caml_call1(f, [0, d]);
      if(! match$0) return [0, 0, caml_call2(Base_Import[93], length, 1)];
      var d$0 = match$0[1];
      return [0, [0, v, d$0], length];
     }
     if(0 <= c){
      var
       match$1 = change(0, key, f, length, compare_key),
       length$0 = match$1[2],
       r = match$1[1];
      return r === t ? [0, t, length$0] : [0, bal(0, v, d, r), length$0];
     }
     var
      match$2 = change(0, key, f, length, compare_key),
      length$1 = match$2[2],
      l = match$2[1];
     return l === t ? [0, t, length$1] : [0, bal(l, v, d, 0), length$1];
    }
    var
     h = t[5],
     r$0 = t[4],
     d$1 = t[3],
     v$0 = t[2],
     l$0 = t[1],
     c$0 = caml_call2(compare_key, key, v$0);
    if(0 === c$0){
     var match$3 = caml_call1(f, [0, d$1]);
     if(match$3){
      var data$0 = match$3[1];
      return [0, [1, l$0, key, data$0, r$0, h], length];
     }
     var _cV_ = caml_call2(Base_Import[93], length, 1);
     return [0, concat_unchecked(l$0, r$0), _cV_];
    }
    if(0 <= c$0){
     var
      match$4 = change(r$0, key, f, length, compare_key),
      length$2 = match$4[2],
      r$1 = match$4[1];
     return r$1 === r$0
             ? [0, t, length$2]
             : [0, bal(l$0, v$0, d$1, r$1), length$2];
    }
    var
     match$5 = change(l$0, key, f, length, compare_key),
     length$3 = match$5[2],
     l$1 = match$5[1];
    return l$1 === l$0
            ? [0, t, length$3]
            : [0, bal(l$1, v$0, d$1, r$0), length$3];
   }
   function update(t, key, f, length, compare_key){
    if(typeof t === "number"){
     var data = caml_call1(f, 0);
     return [0, [0, key, data], caml_call2(Base_Import[91], length, 1)];
    }
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
     if(0 === c){
      var d$0 = caml_call1(f, [0, d]);
      return [0, [0, v, d$0], length];
     }
     if(0 <= c){
      var
       match = update(0, key, f, length, compare_key),
       length$0 = match[2],
       r = match[1];
      return [0, bal(0, v, d, r), length$0];
     }
     var
      match$0 = update(0, key, f, length, compare_key),
      length$1 = match$0[2],
      l = match$0[1];
     return [0, bal(l, v, d, 0), length$1];
    }
    var
     h = t[5],
     r$0 = t[4],
     d$1 = t[3],
     v$0 = t[2],
     l$0 = t[1],
     c$0 = caml_call2(compare_key, key, v$0);
    if(0 === c$0){
     var data$0 = caml_call1(f, [0, d$1]);
     return [0, [1, l$0, key, data$0, r$0, h], length];
    }
    if(0 <= c$0){
     var
      match$1 = update(r$0, key, f, length, compare_key),
      length$2 = match$1[2],
      r$1 = match$1[1];
     return [0, bal(l$0, v$0, d$1, r$1), length$2];
    }
    var
     match$2 = update(l$0, key, f, length, compare_key),
     length$3 = match$2[2],
     l$1 = match$2[1];
    return [0, bal(l$1, v$0, d$1, r$0), length$3];
   }
   function remove_multi(t, key, length, compare_key){
    return change
            (t,
             key,
             function(param){
              if(param){
               var _cU_ = param[1];
               if(_cU_){
                var non_empty_tail = _cU_[2];
                if(non_empty_tail) return [0, non_empty_tail];
               }
              }
              return 0;
             },
             length,
             compare_key);
   }
   function iter_keys(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[4], v$0 = t$0[2], l = t$0[1];
     iter_keys(l, f);
     caml_call1(f, v$0);
     var t$0 = r;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2]; return caml_call1(f, d);}
     var r = t$0[4], d$0 = t$0[3], l = t$0[1];
     iter(l, f);
     caml_call1(f, d$0);
     var t$0 = r;
    }
   }
   function iteri(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     iteri(l, f);
     caml_call2(f, v$0, d$0);
     var t$0 = r;
    }
   }
   function iteri_until_loop(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(iteri_until_loop(l, f)) return 1;
     if(caml_call2(f, v$0, d$0)) return 1;
     var t$0 = r;
    }
   }
   function iteri_until(t, f){
    var _cT_ = iteri_until_loop(t, f);
    return caml_call1(Finished_or_unfinished[5], _cT_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var d = t[2], v = t[1]; return [0, v, caml_call1(f, d)];}
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = map(l, f),
     d$1 = caml_call1(f, d$0),
     r$0 = map(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function mapi(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [0, v, caml_call2(f, v, d)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = mapi(l, f),
     d$1 = caml_call2(f, v$0, d$0),
     r$0 = mapi(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function fold(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold(l, accu$0, f)),
      t$0 = r,
      accu$0 = accu$1;
    }
   }
   function fold_until(t, init, f, finish){
    function fold_until_loop(t, acc, f){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var d = t$0[2], v = t$0[1];
       return caml_call3(f, v, d, acc$0);
      }
      var
       r = t$0[4],
       d$0 = t$0[3],
       v$0 = t$0[2],
       l = t$0[1],
       match = fold_until_loop(l, acc$0, f);
      if(0 !== match[0]){var final$1 = match[1]; return [1, final$1];}
      var acc$1 = match[1], match$0 = caml_call3(f, v$0, d$0, acc$1);
      if(0 !== match$0[0]){var final$0 = match$0[1]; return [1, final$0];}
      var acc$2 = match$0[1], t$0 = r, acc$0 = acc$2;
     }
    }
    var match = fold_until_loop(t, init, f);
    if(0 === match[0]){var acc = match[1]; return caml_call1(finish, acc);}
    var stop = match[1];
    return stop;
   }
   function fold_right(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold_right(r, accu$0, f)),
      t$0 = l,
      accu$0 = accu$1;
    }
   }
   function filter_mapi(t, f, len){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1], match = caml_call2(f, v, d);
     if(match){var new_data = match[1]; return [0, v, new_data];}
     len[1] += -1;
     return 0;
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = filter_mapi(l, f, len),
     new_data$0 = caml_call2(f, v$0, d$0),
     r$0 = filter_mapi(r, f, len);
    if(new_data$0){
     var new_data$1 = new_data$0[1];
     return join(l$0, v$0, new_data$1, r$0);
    }
    len[1] += -1;
    return concat_and_balance_unchecked(l$0, r$0);
   }
   function filteri(t, f, len){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return caml_call2(f, v, d) ? t : (len[1] += -1, 0);
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = filteri(l, f, len),
     keep_data = caml_call2(f, v$0, d$0),
     r$0 = filteri(r, f, len);
    if(l === l$0 && keep_data && r === r$0) return t;
    return keep_data
            ? join(l$0, v$0, d$0, r$0)
            : (len[1] += -1, concat_and_balance_unchecked(l$0, r$0));
   }
   function filter(t, f, len){
    return filteri(t, function(param, data){return caml_call1(f, data);}, len);
   }
   function filter_keys(t, f, len){
    return filteri(t, function(key, param){return caml_call1(f, key);}, len);
   }
   function filter_map(t, f, len){
    return filter_mapi
            (t, function(param, data){return caml_call1(f, data);}, len);
   }
   function partition_mapi(t, f){
    var
     match =
       fold
        (t,
         [0, empty, empty],
         function(key, data, param){
          var t2 = param[2], t1 = param[1], match = caml_call2(f, key, data);
          if(0 === match[0]){
           var x = match[1];
           return [0, add_unchecked(t1, key, x), t2];
          }
          var y = match[1];
          return [0, t1, add_unchecked(t2, key, y)];
         }),
     t2 = match[2],
     t1 = match[1],
     _cS_ = to_tree_unchecked(t2);
    return [0, to_tree_unchecked(t1), _cS_];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    function loop(t, f){
     if(typeof t === "number") return _q_;
     if(0 === t[0]){
      var d = t[2], v = t[1];
      return caml_call2(f, v, d) ? [0, t, 0] : [0, 0, t];
     }
     var
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      match = loop(l, f),
      l_f = match[2],
      l_t = match[1],
      keep_data_t = caml_call2(f, v$0, d$0),
      match$0 = loop(r, f),
      r_f = match$0[2],
      r_t = match$0[1];
     function mk(l$0, keep_data, r$0){
      if(l === l$0 && keep_data && r === r$0) return t;
      return keep_data
              ? join(l$0, v$0, d$0, r$0)
              : concat_and_balance_unchecked(l$0, r$0);
     }
     var _cR_ = mk(l_f, 1 - keep_data_t, r_f);
     return [0, mk(l_t, keep_data_t, r_t), _cR_];
    }
    return loop(t, f);
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function cons(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, r, e$0],
      t$0 = l,
      e$0 = e$1;
    }
   }
   function cons_right(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, l, e$0],
      t$0 = r,
      e$0 = e$1;
    }
   }
   function of_tree(tree){return cons(tree, 0);}
   function step_deeper_exn(tree, e){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
    if(0 === tree[0]){
     var d = tree[2], v = tree[1];
     return [0, 0, [0, v, d, 0, e]];
    }
    var r = tree[4], d$0 = tree[3], v$0 = tree[2], l = tree[1];
    return [0, l, [0, v$0, d$0, r, e]];
   }
   function drop_phys_equal_prefix(tree1, acc1, tree2, acc2){
    var tree1$0 = tree1, acc1$0 = acc1, tree2$0 = tree2, acc2$0 = acc2;
    for(;;){
     if(tree1$0 === tree2$0) return [0, acc1$0, acc2$0];
     var h2 = height(tree2$0), h1 = height(tree1$0);
     if(h2 === h1)
      var
       match = step_deeper_exn(tree1$0, acc1$0),
       acc1$1 = match[2],
       tree1$1 = match[1],
       match$0 = step_deeper_exn(tree2$0, acc2$0),
       acc2$1 = match$0[2],
       tree2$1 = match$0[1],
       tree1$0 = tree1$1,
       acc1$0 = acc1$1,
       tree2$0 = tree2$1,
       acc2$0 = acc2$1;
     else if(h1 < h2)
      var
       match$1 = step_deeper_exn(tree2$0, acc2$0),
       acc2$2 = match$1[2],
       tree2$2 = match$1[1],
       tree2$0 = tree2$2,
       acc2$0 = acc2$2;
     else
      var
       match$2 = step_deeper_exn(tree1$0, acc1$0),
       acc1$2 = match$2[2],
       tree1$2 = match$2[1],
       tree1$0 = tree1$2,
       acc1$0 = acc1$2;
    }
   }
   function fold$0(init, f, param){
    var init$0 = init, param$0 = param;
    for(;;){
     if(! param$0) return init$0;
     var
      enum$0 = param$0[4],
      tree = param$0[3],
      data = param$0[2],
      key = param$0[1],
      next = caml_call3(f, key, data, init$0),
      init$0 = next,
      param$0 = cons(tree, enum$0);
    }
   }
   function fold2(compare_key, t1, t2, init, f){
    var t1$0 = t1, t2$0 = t2, curr = init;
    for(;;){
     if(! t1$0)
      return t2$0
              ? fold$0
                (curr,
                 function(key, data, acc){
                  return caml_call3(f, key, [0, -57574468, data], acc);
                 },
                 t2$0)
              : curr;
     if(! t2$0)
      return fold$0
              (curr,
               function(key, data, acc){
                return caml_call3(f, key, [0, 847852583, data], acc);
               },
               t1$0);
     var
      enum2 = t2$0[4],
      tree2 = t2$0[3],
      v2 = t2$0[2],
      k2 = t2$0[1],
      enum1 = t1$0[4],
      tree1 = t1$0[3],
      v1 = t1$0[2],
      k1 = t1$0[1],
      compare_result = caml_call2(compare_key, k1, k2);
     if(0 === compare_result)
      var
       next = caml_call3(f, k1, [0, 737457313, [0, v1, v2]], curr),
       t2$1 = cons(tree2, enum2),
       t1$1 = cons(tree1, enum1),
       t1$0 = t1$1,
       t2$0 = t2$1,
       curr = next;
     else if(0 <= compare_result)
      var
       next$0 = caml_call3(f, k2, [0, -57574468, v2], curr),
       t2$2 = cons(tree2, enum2),
       t2$0 = t2$2,
       curr = next$0;
     else
      var
       next$1 = caml_call3(f, k1, [0, 847852583, v1], curr),
       t1$2 = cons(tree1, enum1),
       t1$0 = t1$2,
       curr = next$1;
    }
   }
   function symmetric_diff(t1, t2, compare_key, data_equal){
    function step(state){
     var left = state[1];
     if(left){
      var
       right = state[2],
       enum1 = left[4],
       tree1 = left[3],
       data = left[2],
       key = left[1];
      if(! right)
       return [1, [0, key, [0, 847852583, data]], [0, cons(tree1, enum1), 0]];
      var
       enum2 = right[4],
       tree2 = right[3],
       v2 = right[2],
       k2 = right[1],
       compare_result = caml_call2(compare_key, key, k2);
      if(0 !== compare_result)
       return 0 <= compare_result
               ? [1,
                 [0, k2, [0, -57574468, v2]],
                 [0, left, cons(tree2, enum2)]]
               : [1,
                 [0, key, [0, 847852583, data]],
                 [0, cons(tree1, enum1), right]];
      var next_state = drop_phys_equal_prefix(tree1, enum1, tree2, enum2);
      return caml_call2(data_equal, data, v2)
              ? [0, next_state]
              : [1, [0, key, [0, 1013247643, [0, data, v2]]], next_state];
     }
     var match = state[2];
     if(! match) return 0;
     var
      enum$0 = match[4],
      tree = match[3],
      data$0 = match[2],
      key$0 = match[1];
     return [1,
             [0, key$0, [0, -57574468, data$0]],
             [0, 0, cons(tree, enum$0)]];
    }
    var _cQ_ = drop_phys_equal_prefix(t1, 0, t2, 0);
    return caml_call2(Base_Sequence[44], _cQ_, step);
   }
   function to_sequence
   (comparator, opt, keys_greater_or_equal_to, keys_less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = -542431297;
    function inclusive_bound(side, t, bound){
     var
      compare_key = comparator[1],
      match = split(t, bound, compare_key),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var match$0 = maybe[1], data = match$0[2], key = match$0[1];
     return set(t$0, 0, key, data, compare_key)[1];
    }
    if(511974747 <= order){
     var
      _cI_ = Base_Import[127],
      _cJ_ = function(_cO_, _cP_){return inclusive_bound(_cI_, _cO_, _cP_);},
      tree = caml_call3(Base_Option[34], keys_greater_or_equal_to, t$3, _cJ_),
      next$0 =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
         return [1, [0, k, v], cons_right(t, e)];
        };
     if(keys_less_or_equal_to){
      var
       key$0 = keys_less_or_equal_to[1],
       compare$0 = comparator[1],
       t$1 = tree,
       e$1 = 0;
      for(;;){
       if(typeof t$1 === "number"){var init$0 = e$1; break;}
       if(0 === t$1[0])
        var
         d$1 = t$1[2],
         v$2 = t$1[1],
         t$2 = [1, 0, v$2, d$1, 0, 1],
         t$1 = t$2;
       else{
        var l$0 = t$1[1], v$3 = t$1[2];
        if(0 < caml_call2(compare$0, v$3, key$0))
         var t$1 = l$0;
        else
         var
          r$1 = t$1[4],
          d$2 = t$1[3],
          v$4 = t$1[2],
          e$2 = [0, v$4, d$2, l$0, e$1],
          t$1 = r$1,
          e$1 = e$2;
       }
      }
     }
     else
      var init$0 = cons_right(tree, 0);
     return caml_call2(Base_Sequence[44], init$0, next$0);
    }
    var _cK_ = Base_Import[125];
    function _cL_(_cM_, _cN_){return inclusive_bound(_cK_, _cM_, _cN_);}
    var t$4 = caml_call3(Base_Option[34], keys_less_or_equal_to, t$3, _cL_);
    function next(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
     return [1, [0, k, v], cons(t, e)];
    }
    if(keys_greater_or_equal_to){
     var
      key = keys_greater_or_equal_to[1],
      compare = comparator[1],
      t = t$4,
      e = 0;
     for(;;){
      if(typeof t === "number"){var init = e; break;}
      if(0 === t[0])
       var d = t[2], v = t[1], t$0 = [1, 0, v, d, 0, 1], t = t$0;
      else{
       var l = t[1], r = t[4], v$0 = t[2];
       if(0 <= caml_call2(compare, v$0, key))
        var
         r$0 = t[4],
         d$0 = t[3],
         v$1 = t[2],
         e$0 = [0, v$1, d$0, r$0, e],
         t = l,
         e = e$0;
       else
        var t = r;
      }
     }
    }
    else
     var init = of_tree(t$4);
    return caml_call2(Base_Sequence[44], init, next);
   }
   function compare$1(compare_key, compare_data, t1$0, t2$0){
    var
     match$0 = drop_phys_equal_prefix(t1$0, 0, t2$0, 0),
     e2$1 = match$0[2],
     e1$1 = match$0[1],
     t1 = e1$1,
     t2 = e2$1;
    for(;;){
     if(! t1) return t2 ? -1 : 0;
     if(! t2) return 1;
     var
      e2 = t2[4],
      r2 = t2[3],
      d2 = t2[2],
      v2 = t2[1],
      e1 = t1[4],
      r1 = t1[3],
      d1 = t1[2],
      v1 = t1[1],
      c = caml_call2(compare_key, v1, v2);
     if(0 !== c) return c;
     var c$0 = caml_call2(compare_data, d1, d2);
     if(0 !== c$0) return c$0;
     var
      match = drop_phys_equal_prefix(r1, e1, r2, e2),
      e2$0 = match[2],
      e1$0 = match[1],
      t1 = e1$0,
      t2 = e2$0;
    }
   }
   function equal$1(compare_key, compare_data, t1$0, t2$0){
    var
     match$0 = drop_phys_equal_prefix(t1$0, 0, t2$0, 0),
     e2$1 = match$0[2],
     e1$1 = match$0[1],
     t1 = e1$1,
     t2 = e2$1;
    for(;;){
     if(t1){
      if(t2){
       var
        e2 = t2[4],
        r2 = t2[3],
        d2 = t2[2],
        v2 = t2[1],
        e1 = t1[4],
        r1 = t1[3],
        d1 = t1[2],
        v1 = t1[1],
        _cF_ = 0 === caml_call2(compare_key, v1, v2) ? 1 : 0;
       if(_cF_){
        var _cG_ = caml_call2(compare_data, d1, d2);
        if(_cG_){
         var
          match = drop_phys_equal_prefix(r1, e1, r2, e2),
          e2$0 = match[2],
          e1$0 = match[1],
          t1 = e1$0,
          t2 = e2$0;
         continue;
        }
        var _cH_ = _cG_;
       }
       else
        var _cH_ = _cF_;
       return _cH_;
      }
     }
     else if(! t2) return 1;
     return 0;
    }
   }
   function iter2(t1, t2, f, compare_key){
    function _cD_(key, data, param){return caml_call2(f, key, data);}
    var _cE_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _cE_, 0, _cD_);
   }
   function fold2$0(t1, t2, init, f, compare_key){
    var _cC_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _cC_, init, f);
   }
   function fold_symmetric_diff(t1, t2, compare_key, data_equal, init, f){
    function add(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
    }
    function remove(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
    }
    function delta(acc, k, v$0, v){
     return caml_call2(data_equal, v$0, v)
             ? acc
             : caml_call2(f, acc, [0, k, [0, 1013247643, [0, v$0, v]]]);
    }
    function loop(t$0, t, acc$3){
     var t1 = t$0, t2 = t, init = acc$3;
     for(;;){
      if(t1 === t2) return init;
      if(typeof t1 === "number")
       return fold
               (t2,
                init,
                function(key, data, acc){return add(acc, key, data);});
      a:
      {
       if(0 === t1[0]){
        var v = t1[2], k = t1[1];
        if(typeof t2 === "number") break a;
        if(0 === t2[0]){
         var v$0 = t2[2], k$0 = t2[1], x = caml_call2(compare_key, k, k$0);
         if(0 === x) return delta(init, k, v, v$0);
         if(0 <= x){
          var acc$4 = add(init, k$0, v$0);
          return remove(acc$4, k, v);
         }
         var acc$5 = remove(init, k, v);
         return add(acc$5, k$0, v$0);
        }
       }
       else{
        var r = t1[4], v$1 = t1[3], k$1 = t1[2], l = t1[1];
        if(typeof t2 === "number") break a;
        if(0 !== t2[0]){
         var r$0 = t2[4], v$2 = t2[3], k$2 = t2[2], l$0 = t2[1];
         if(0 === caml_call2(compare_key, k$1, k$2)){
          var
           acc$6 = loop(l, l$0, init),
           acc$7 = delta(acc$6, k$1, v$1, v$2),
           t1 = r,
           t2 = r$0,
           init = acc$7;
          continue;
         }
        }
       }
       var
        add$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
          },
        remove$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
          },
        match$0 = drop_phys_equal_prefix(t1, 0, t2, 0),
        right$1 = match$0[2],
        left$1 = match$0[1],
        left = left$1,
        right = right$1,
        acc = init;
       for(;;){
        if(! left)
         return fold$0
                 (acc,
                  function(key, data, acc){return add$0(acc, key, data);},
                  right);
        if(! right)
         return fold$0
                 (acc,
                  function(key, data, acc){return remove$0(acc, key, data);},
                  left);
        var
         enum2 = right[4],
         tree2 = right[3],
         v2 = right[2],
         k2 = right[1],
         enum1 = left[4],
         tree1 = left[3],
         v1 = left[2],
         k1 = left[1],
         compare_result = caml_call2(compare_key, k1, k2);
        if(0 === compare_result)
         var
          acc$0 =
            caml_call2(data_equal, v1, v2)
             ? acc
             : caml_call2(f, acc, [0, k1, [0, 1013247643, [0, v1, v2]]]),
          match = drop_phys_equal_prefix(tree1, enum1, tree2, enum2),
          enum2$0 = match[2],
          enum1$0 = match[1],
          left = enum1$0,
          right = enum2$0,
          acc = acc$0;
        else if(0 <= compare_result)
         var
          acc$1 = add$0(acc, k2, v2),
          right$0 = cons(tree2, enum2),
          right = right$0,
          acc = acc$1;
        else
         var
          acc$2 = remove$0(acc, k1, v1),
          left$0 = cons(tree1, enum1),
          left = left$0,
          acc = acc$2;
       }
      }
      return fold
              (t1,
               init,
               function(key, data, acc){return remove(acc, key, data);});
     }
    }
    return loop(t1, t2, init);
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var
     r = param[4],
     l = param[1],
     _cz_ = length(r),
     _cA_ = length(l),
     _cB_ = caml_call2(Base_Import[91], _cA_, _cz_);
    return caml_call2(Base_Import[91], _cB_, 1);
   }
   function keys(t){
    return fold_right
            (t, 0, function(key, param, list){return [0, key, list];});
   }
   function data(t){
    return fold_right
            (t, 0, function(param, data, list){return [0, data, list];});
   }
   function of_foldable(fold, foldable, init, f, compare_key){
    return caml_call3
            (fold,
             foldable,
             [0, empty_without_value_restrictio, 0],
             function(param, _cy_){
              var
               data = _cy_[2],
               key = _cy_[1],
               length = param[2],
               accum = param[1],
               match = find(accum, key, compare_key);
              if(match)
               var prev = match[1], prev_data = prev;
              else
               var prev_data = init;
              var data$0 = caml_call2(f, prev_data, data);
              return globalize(set(accum, length, key, data$0, compare_key));
             });
   }
   function Of_foldable(M){
    function of_foldable_fold(foldable, init, f, compare_key){
     return of_foldable(M[2], foldable, init, f, compare_key);
    }
    function of_foldable_reduce(foldable, f, compare_key){
     function _cw_(param, _cx_){
      var
       data = _cx_[2],
       key = _cx_[1],
       length = param[2],
       accum = param[1],
       match = find(accum, key, compare_key);
      if(match)
       var prev = match[1], new_data = caml_call2(f, prev, data);
      else
       var new_data = data;
      return globalize(set(accum, length, key, new_data, compare_key));
     }
     return caml_call3
             (M[2], foldable, [0, empty_without_value_restrictio, 0], _cw_);
    }
    function of_foldable$0(foldable, compare_key){
     return caml_call1
             (with_return,
              function(r){
               function _cu_(param, _cv_){
                var
                 data = _cv_[2],
                 key = _cv_[1],
                 length = param[2],
                 t = param[1],
                 acc = set(t, length, key, data, compare_key),
                 length$0 = acc[2];
                return length === length$0
                        ? caml_call1(r, [0, -1048878709, key])
                        : globalize(acc);
               }
               var
                map =
                  caml_call3
                   (M[2],
                    foldable,
                    [0, empty_without_value_restrictio, 0],
                    _cu_);
               return [0, 17724, map];
              });
    }
    function of_foldable_or_error(foldable, comparator){
     var match = of_foldable$0(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return [0, x];}
     var
      key = match[2],
      _cr_ = comparator[2],
      _cs_ = caml_call2(Base_Import[112], M[1], cst_or_error_duplicate_key),
      _ct_ = caml_call2(Base_Import[112], cst_Map_of, _cs_);
     return caml_call5(Base_Or_error[38], 0, 0, _ct_, key, _cr_);
    }
    function of_foldable_exn(foldable, comparator){
     var match = of_foldable$0(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return x;}
     var
      key = match[2],
      _cn_ = comparator[2],
      _co_ = caml_call2(Base_Import[112], M[1], cst_exn_duplicate_key),
      _cp_ = caml_call2(Base_Import[112], cst_Map_of$0, _co_),
      _cq_ = caml_call5(Base_Error[19], 0, 0, _cp_, key, _cn_);
     return caml_call1(Base_Error[31], _cq_);
    }
    function of_foldable_multi(foldable, compare_key){
     function _cl_(l, x){return [0, x, l];}
     var alist = caml_call3(M[2], foldable, 0, _cl_);
     function _cm_(l, x){return [0, x, l];}
     return of_foldable(Base_List0[8], alist, 0, _cm_, compare_key);
    }
    return [0,
            of_foldable_fold,
            of_foldable_reduce,
            of_foldable$0,
            of_foldable_or_error,
            of_foldable_exn,
            of_foldable_multi];
   }
   var
    fold$1 = Base_List0[8],
    Of_alist = Of_foldable([0, name, fold$1]),
    of_alist_fold = Of_alist[1],
    of_alist_reduce = Of_alist[2],
    of_alist = Of_alist[3],
    of_alist_or_error = Of_alist[4],
    of_alist_exn = Of_alist[5],
    of_alist_multi = Of_alist[6],
    fold$2 = Base_Sequence[11],
    Of_sequence = Of_foldable([0, name$0, fold$2]),
    of_sequence_fold = Of_sequence[1],
    of_sequence_reduce = Of_sequence[2],
    of_sequence = Of_sequence[3],
    of_sequence_or_error = Of_sequence[4],
    of_sequence_exn = Of_sequence[5],
    of_sequence_multi = Of_sequence[6];
   function of_list_with_key(list, get_key, compare_key){
    return caml_call1
            (with_return,
             function(r){
              function _ck_(param, data){
               var
                length = param[2],
                t = param[1],
                key = caml_call1(get_key, data),
                acc = set(t, length, key, data, compare_key),
                new_length = acc[2];
               return length === new_length
                       ? caml_call1(r, [0, -1048878709, key])
                       : globalize(acc);
              }
              var
               map =
                 caml_call3
                  (Base_List0[8],
                   list,
                   [0, empty_without_value_restrictio, 0],
                   _ck_);
              return [0, 17724, map];
             });
   }
   function of_list_with_key_or_error(list, get_key, comparator){
    var match = of_list_with_key(list, get_key, comparator[1]);
    if(17724 <= match[1]){var x = match[2]; return [0, x];}
    var key = match[2];
    return caml_call5
            (Base_Or_error[38],
             0,
             0,
             cst_Map_of_list_with_key_or_er,
             key,
             comparator[2]);
   }
   function of_list_with_key_exn(list, get_key, comparator){
    var match = of_list_with_key(list, get_key, comparator[1]);
    if(17724 <= match[1]){var x = match[2]; return x;}
    var
     key = match[2],
     _cj_ =
       caml_call5
        (Base_Error[19],
         0,
         0,
         cst_Map_of_list_with_key_exn_d,
         key,
         comparator[2]);
    return caml_call1(Base_Error[31], _cj_);
   }
   function of_list_with_key_multi(list, get_key, compare_key){
    var list$0 = caml_call1(Base_List0[19], list);
    function _ci_(param, data){
     var length = param[2], t = param[1], key = caml_call1(get_key, data);
     return globalize
             (update
               (t,
                key,
                function(option){
                 var list = caml_call2(Base_Option[30], option, 0);
                 return [0, data, list];
                },
                length,
                compare_key));
    }
    return caml_call3
            (Base_List0[8],
             list$0,
             [0, empty_without_value_restrictio, 0],
             _ci_);
   }
   function of_list_with_key_fold(list, get_key, init, f, compare_key){
    function _ch_(param, data){
     var length = param[2], t = param[1], key = caml_call1(get_key, data);
     return globalize
             (update
               (t,
                key,
                function(param){
                 if(! param) return caml_call2(f, init, data);
                 var prev = param[1];
                 return caml_call2(f, prev, data);
                },
                length,
                compare_key));
    }
    return caml_call3
            (Base_List0[8],
             list,
             [0, empty_without_value_restrictio, 0],
             _ch_);
   }
   function of_list_with_key_reduce(list, get_key, f, compare_key){
    function _cg_(param, data){
     var length = param[2], t = param[1], key = caml_call1(get_key, data);
     return globalize
             (update
               (t,
                key,
                function(param){
                 if(! param) return data;
                 var prev = param[1];
                 return caml_call2(f, prev, data);
                },
                length,
                compare_key));
    }
    return caml_call3
            (Base_List0[8],
             list,
             [0, empty_without_value_restrictio, 0],
             _cg_);
   }
   function for_all(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _cf_ = 1 - caml_call1(f, data);
                 return _cf_ ? caml_call1(r, 0) : _cf_;
                });
              return 1;
             });
   }
   function for_alli(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _ce_ = 1 - caml_call2(f, key, data);
                 return _ce_ ? caml_call1(r, 0) : _ce_;
                });
              return 1;
             });
   }
   function exists(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _cd_ = caml_call1(f, data);
                 return _cd_ ? caml_call1(r, 1) : _cd_;
                });
              return 0;
             });
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _cc_ = caml_call2(f, key, data);
                 return _cc_ ? caml_call1(r, 1) : _cc_;
                });
              return 0;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function sum(M, t, f){
    function _ca_(param, data, acc){
     var _cb_ = caml_call1(f, data);
     return caml_call2(M[2], _cb_, acc);
    }
    return fold(t, M[1], _ca_);
   }
   function sumi(M, t, f){
    function _b__(key, data, acc){
     var _b$_ = caml_call2(f, key, data);
     return caml_call2(M[2], _b$_, acc);
    }
    return fold(t, M[1], _b__);
   }
   function to_alist(opt, t){
    if(opt) var sth = opt[1], key_order = sth; else var key_order = 608542111;
    return 608542111 <= key_order
            ? fold_right
              (t, 0, function(key, data, x){return [0, [0, key, data], x];})
            : fold
              (t, 0, function(key, data, x){return [0, [0, key, data], x];});
   }
   function merge(t1, t2, f, compare_key){
    var
     _b7_ = length(t2),
     _b8_ = length(t1),
     _b9_ = caml_call2(Base_Import[91], _b8_, _b7_),
     elts = caml_call1(Base_Uniform_array[62], _b9_),
     i = [0, 0];
    iter2
     (t1,
      t2,
      function(key, values){
       var match = caml_call2(f, key, values);
       if(! match) return 0;
       var value = match[1];
       caml_call3(Base_Uniform_array[15], elts, i[1], [0, key, value]);
       i[1]++;
       return 0;
      },
      compare_key);
    var len = i[1];
    function get(i){return caml_call2(Base_Uniform_array[12], elts, i);}
    var tree = of_increasing_iterator_uncheck(len, get);
    return [0, tree, len];
   }
   function merge_large_first
   (length_large, t_large, t_small, call, combine, compare_key){
    return fold
            (t_small,
             [0, t_large, length_large],
             function(key, data, param){
              var length = param[2], t = param[1];
              return globalize
                      (update
                        (t,
                         key,
                         function(param){
                          if(! param) return data;
                          var data$0 = param[1];
                          return caml_call4(call, combine, key, data$0, data);
                         },
                         length,
                         compare_key));
             });
   }
   function call(f, key, x, y){return caml_call3(f, key, x, y);}
   function swap(f, key, x, y){return caml_call3(f, key, y, x);}
   function merge_skewed(t1, t2, length1, length2, combine, compare_key){
    return length2 <= length1
            ? merge_large_first(length1, t1, t2, call, combine, compare_key)
            : merge_large_first(length2, t2, t1, swap, combine, compare_key);
   }
   function merge_disjoint_exn(t1, t2, length1, length2, comparator){
    var _b4_ = comparator[1];
    return merge_skewed
            (t1,
             t2,
             length1,
             length2,
             function(key, param, _b5_){
              var
               _b6_ =
                 caml_call5
                  (Base_Error[19],
                   0,
                   0,
                   cst_Map_merge_disjoint_exn_dup,
                   key,
                   comparator[2]);
              return caml_call1(Base_Error[31], _b6_);
             },
             _b4_);
   }
   function repackage(marker, k, v){return marker ? [0, [0, k, v]] : 0;}
   function closest_key(t$0, dir, k$0, compare_key){
    var t = t$0, found_marker = 0, found_key = 0, found_value = 0;
    for(;;){
     if(typeof t === "number")
      return repackage(found_marker, found_key, found_value);
     if(0 === t[0]) break;
     var
      r = t[4],
      found_value$0 = t[3],
      found_key$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_key, found_key$0, k$0);
     if(0 === c$0)
      return -640801497 === dir
              ? is_empty
                 (l)
                ? repackage(found_marker, found_key, found_value)
                : max_elt(l)
              : -779285465
                <= dir
                ? [0, [0, found_key$0, found_value$0]]
                : is_empty
                   (r)
                  ? repackage(found_marker, found_key, found_value)
                  : min_elt(r);
     if(-640801497 !== dir && 927731004 > dir){
      if(0 < c$0){
       var
        t = l,
        found_marker = 1,
        found_key = found_key$0,
        found_value = found_value$0;
       continue;
      }
      var t = r;
      continue;
     }
     if(0 <= c$0)
      var t = l;
     else
      var
       t = r,
       found_marker = 1,
       found_key = found_key$0,
       found_value = found_value$0;
    }
    var
     v = t[2],
     k = t[1],
     c = caml_call2(compare_key, k, k$0),
     _b3_ =
       521507869 <= dir
        ? 927731004 <= dir ? c <= 0 ? 1 : 0 : 0 <= c ? 1 : 0
        : -640801497 <= dir ? c < 0 ? 1 : 0 : 0 < c ? 1 : 0;
    return _b3_
            ? [0, [0, k, v]]
            : repackage(found_marker, found_key, found_value);
   }
   function rank(t, k, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var k$0 = t$0[1];
      return 0 === caml_call2(compare_key, k$0, k) ? _s_ : 0;
     }
     var
      r = t$0[4],
      k$1 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, k$1, k);
     if(0 === c) return [0, length(l)];
     if(0 >= c){
      var
       _bZ_ =
         function(rank){
          var _b1_ = length(l), _b2_ = caml_call2(Base_Import[91], rank, 1);
          return caml_call2(Base_Import[91], _b2_, _b1_);
         },
       _b0_ = rank(r, k, compare_key);
      return caml_call2(Base_Option[24], _b0_, _bZ_);
     }
     var t$0 = l;
    }
   }
   function nth(num_to_search, param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var v = param$0[2], k = param$0[1];
      return 0 === num_to_search[1]
              ? [0, [0, k, v]]
              : (num_to_search[1] += -1, 0);
     }
     var
      r = param$0[4],
      v$0 = param$0[3],
      k$0 = param$0[2],
      l = param$0[1],
      some = nth(num_to_search, l);
     if(some) return some;
     if(0 === num_to_search[1]) return [0, [0, k$0, v$0]];
     num_to_search[1] += -1;
     var param$0 = r;
    }
   }
   function nth$0(t, n){return nth([0, n], t);}
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     var t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     var t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
                  })
               : find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) < 0 ? 1 : 0;
                  })
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
                  })
               : find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 < caml_call3(compare, key, data, v) ? 1 : 0;
                  });
    if(-1055410545 <= how){
     var
      pair =
        find_last_satisfying
         (t,
          function(key, data){
           return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
          });
     if(pair){
      var match = pair[1], data = match[2], key = match[1];
      if(0 === caml_call3(compare, key, data, v)) return pair;
     }
     return 0;
    }
    var
     pair$0 =
       find_first_satisfying
        (t,
         function(key, data){
          return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
         });
    if(pair$0){
     var match$0 = pair$0[1], data$0 = match$0[2], key$0 = match$0[1];
     if(0 === caml_call3(compare, key$0, data$0, v)) return pair$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(key, data){
     return 847852583 <= caml_call2(segment_of, key, data) ? 1 : 0;
    }
    function is_right(key, data){return 1 - is_left(key, data);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function binary_search_one_sided_bound
   (t, maybe_bound, compare, if_exclusive, if_inclusive){
    function find_bound(t, how, bound, compare){
     var match = binary_search(t, compare, how, bound);
     if(! match) return 0;
     var bound$0 = match[1][1];
     return [0, [0, bound$0]];
    }
    if(typeof maybe_bound === "number") return _t_;
    if(0 === maybe_bound[0]){
     var bound = maybe_bound[1];
     return find_bound(t, if_inclusive, bound, compare);
    }
    var bound$0 = maybe_bound[1];
    return find_bound(t, if_exclusive, bound$0, compare);
   }
   function binary_search_two_sided_bounds
   (t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_one_sided_bound
        (t, lower_bound, compare, -839473056, 926943384);
    if(! match) return 0;
    var
     lower_bound$0 = match[1],
     match$0 =
       binary_search_one_sided_bound
        (t, upper_bound, compare, 200870407, -253007807);
    if(! match$0) return 0;
    var upper_bound$0 = match$0[1];
    return [0, [0, lower_bound$0, upper_bound$0]];
   }
   function of_iteri(iteri, compare_key){
    var acc = [0, 0, [0, empty_without_value_restrictio, 0]];
    caml_call1
     (iteri,
      function(key, data){
       var
        match = acc[2],
        length = match[2],
        map = match[1],
        pair = set(map, length, key, data, compare_key),
        length$0 = pair[2];
       if(length === length$0 && caml_call1(Base_Option[52], acc[1])){acc[1] = [0, key]; return 0;}
       acc[2] = globalize(pair);
       return 0;
      });
    var match = acc[1];
    if(! match) return [0, 17724, acc[2]];
    var key = match[1];
    return [0, -1048878709, key];
   }
   function of_iteri_exn(iteri, comparator){
    var match = of_iteri(iteri, comparator[1]);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     key = match[2],
     _bY_ =
       caml_call5
        (Base_Error[19],
         0,
         0,
         cst_Map_of_iteri_exn_duplicate,
         key,
         comparator[2]);
    return caml_call1(Base_Error[31], _bY_);
   }
   function t_of_sexp_direct(key_of_sexp, value_of_sexp, sexp, comparator){
    var
     _bO_ = caml_call2(Base_Import[171], key_of_sexp, value_of_sexp),
     alist = caml_call2(Base_Import[173], _bO_, sexp),
     compare_key = comparator[1],
     match = of_alist(alist, compare_key);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var k = match[2];
    function _bP_(_bX_){return _bX_;}
    function _bQ_(_bW_){return _bW_;}
    var
     _bR_ = caml_call2(Base_Import[171], _bQ_, _bP_),
     alist_sexps = caml_call2(Base_Import[173], _bR_, sexp),
     found_first_k = [0, 0];
    function _bS_(param, _bT_){
     var
      k2_sexp = _bT_[1],
      k2 = param[1],
      _bU_ = 0 === caml_call2(compare_key, k, k2) ? 1 : 0;
     if(_bU_){
      if(found_first_k[1])
       return caml_call2
               (Base_Import[156], cst_Map_t_of_sexp_direct_dupli, k2_sexp);
      found_first_k[1] = 1;
      var _bV_ = 0;
     }
     else
      var _bV_ = _bU_;
     return _bV_;
    }
    caml_call3(Base_List0[13], alist, alist_sexps, _bS_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
   }
   function sexp_of_t$1(sexp_of_key, sexp_of_value, t){
    function f(key, data, acc){
     var _bN_ = [0, caml_call1(sexp_of_value, data), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, key), _bN_]], acc];
    }
    return [1, fold_right(t, 0, f)];
   }
   function combine_errors(t, sexp_of_key){
    var
     match = partition_map(t, Base_Result[38]),
     errors = match[2],
     oks = match[1];
    if(is_empty(errors)) return [0, oks];
    var _bM_ = sexp_of_t$1(sexp_of_key, Base_Error[9], errors);
    return caml_call1(Base_Or_error[39], _bM_);
   }
   function unzip(t){
    var _bL_ = map(t, Base_Import[127]);
    return [0, map(t, Base_Import[125]), _bL_];
   }
   function map_keys(t1, f, param){
    var sexp_of_key = param[2], compare_key = param[1];
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      17724,
                      fold
                       (t1,
                        [0, empty_without_value_restrictio, 0],
                        function(key, data, param$0){
                         var
                          length = param$0[2],
                          t2 = param$0[1],
                          key$0 = caml_call1(f, key);
                         try{
                          var
                           _bJ_ =
                             globalize
                              (add_exn_internal
                                (t2, length, key$0, data, compare_key, sexp_of_key));
                          return _bJ_;
                         }
                         catch(_bK_){
                          var _bI_ = caml_wrap_exception(_bK_);
                          if(_bI_ === Duplicate)
                           return caml_call1(param, [0, -1048878709, key$0]);
                          throw caml_maybe_attach_backtrace(_bI_, 0);
                         }
                        })];
             });
   }
   function map_keys_exn(t, f, comparator){
    var match = map_keys(t, f, comparator);
    if(17724 <= match[1]){var result = match[2]; return result;}
    var
     key = match[2],
     sexp_of_key = comparator[2],
     _bG_ = [0, [0, cst_key$0, caml_call1(sexp_of_key, key)], 0],
     _bH_ = caml_call2(Base_Sexp[10], cst_Map_map_keys_exn_duplicate, _bG_);
    return caml_call1(Base_Error[32], _bH_);
   }
   function transpose_keys(outer_comparator, inner_comparator, outer_t){
    return fold
            (outer_t,
             [0, empty_without_value_restrictio, 0],
             function(outer_key, inner_t, acc){
              return fold
                      (inner_t,
                       acc,
                       function(inner_key, data, param){
                        var
                         acc_len = param[2],
                         acc = param[1],
                         _bF_ = inner_comparator[1];
                        return globalize
                                (update
                                  (acc,
                                   inner_key,
                                   function(param){
                                    if(! param) return [0, [0, outer_key, data], 1];
                                    var match = param[1], elt_len = match[2], elt = match[1];
                                    return globalize
                                            (set(elt, elt_len, outer_key, data, outer_comparator[1]));
                                   },
                                   acc_len,
                                   _bF_));
                       });
             });
   }
   function Make_applicative_traversals(A){
    function mapi(t, f){
     if(typeof t === "number") return caml_call1(A[1], 0);
     if(0 === t[0]){
      var
       d = t[2],
       v = t[1],
       _bA_ = function(new_data){return [0, v, new_data];},
       _bB_ = caml_call2(f, v, d);
      return caml_call2(A[2], _bB_, _bA_);
     }
     var h = t[5], r = t[4], d$0 = t[3], v$0 = t[2], l = t[1];
     function _bC_(param){return mapi(l, f);}
     var l$0 = caml_call1(A[14], _bC_), d$1 = caml_call2(f, v$0, d$0);
     function _bD_(param){return mapi(r, f);}
     var r$0 = caml_call1(A[14], _bD_);
     function _bE_(l, d, r){return [1, l, v$0, d, r, h];}
     return caml_call4(A[10], l$0, d$1, r$0, _bE_);
    }
    function filter_mapi(t, f){
     function tree_filter_mapi(t, f){
      if(typeof t === "number") return caml_call1(A[1], [0, 0, 0]);
      if(0 === t[0]){
       var
        d = t[2],
        v = t[1],
        _bo_ =
          function(param){
           if(! param) return [0, 0, 0];
           var new_data = param[1];
           return [0, [0, v, new_data], 1];
          },
        _bp_ = caml_call2(f, v, d);
       return caml_call2(A[2], _bp_, _bo_);
      }
      var r = t[4], d$0 = t[3], v$0 = t[2], l = t[1];
      function _bq_(param, new_data, _bw_){
       var r_len = _bw_[2], r = _bw_[1], l_len = param[2], l = param[1];
       if(new_data){
        var
         new_data$0 = new_data[1],
         _bx_ = caml_call2(Base_Import[91], l_len, r_len),
         _by_ = caml_call2(Base_Import[91], _bx_, 1);
        return [0, join(l, v$0, new_data$0, r), _by_];
       }
       var _bz_ = caml_call2(Base_Import[91], l_len, r_len);
       return [0, concat_and_balance_unchecked(l, r), _bz_];
      }
      function _br_(param){return tree_filter_mapi(r, f);}
      var _bs_ = caml_call1(A[14], _br_), _bt_ = caml_call2(f, v$0, d$0);
      function _bu_(param){return tree_filter_mapi(l, f);}
      var _bv_ = caml_call1(A[14], _bu_);
      return caml_call4(A[10], _bv_, _bt_, _bs_, _bq_);
     }
     return tree_filter_mapi(t, f);
    }
    return [0, mapi, filter_mapi];
   }
   function compare_key(t){return t[1][1];}
   function like(param, _bn_){
    var length = _bn_[2], tree = _bn_[1], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function like_maybe_no_op(old_t, param){
    var
     length = param[2],
     tree = param[1],
     old_tree = old_t[2],
     comparator = old_t[1];
    return old_tree === tree ? old_t : [0, comparator, tree, length];
   }
   function with_same_length(param, tree){
    var length = param[3], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function of_like_tree(t, tree){
    var _bm_ = length(tree);
    return [0, t[1], tree, _bm_];
   }
   function of_like_tree_maybe_no_op(t, tree){
    if(t[2] === tree) return t;
    var _bl_ = length(tree);
    return [0, t[1], tree, _bl_];
   }
   function of_tree$0(comparator, tree){
    return [0, comparator, tree, length(tree)];
   }
   function comparator(t){return t[1];}
   function to_tree(t){return t[2];}
   function invariants$0(t){
    var _bh_ = compare_key(t), _bi_ = invariants(t[2], _bh_);
    if(_bi_)
     var _bj_ = t[3], _bk_ = length(t[2]) === _bj_ ? 1 : 0;
    else
     var _bk_ = _bi_;
    return _bk_;
   }
   function is_empty$0(t){return is_empty(t[2]);}
   function length$0(t){return t[3];}
   function set$0(t, key, data){
    var _bg_ = compare_key(t);
    return like(t, set(t[2], t[3], key, data, _bg_));
   }
   function add_exn$0(t, key, data){
    var _be_ = t[1][2], _bf_ = compare_key(t);
    return like(t, add_exn(t[2], t[3], key, data, _bf_, _be_));
   }
   function add(t, key, data){
    try{
     var
      _ba_ = t[1][2],
      _bb_ = compare_key(t),
      result = like(t, add_exn_internal(t[2], t[3], key, data, _bb_, _ba_));
    }
    catch(_bd_){
     var _bc_ = caml_wrap_exception(_bd_);
     if(_bc_ === Duplicate) return -1024851605;
     throw caml_maybe_attach_backtrace(_bc_, 0);
    }
    return [0, 17724, result];
   }
   function add_multi$0(t, key, data){
    var _a$_ = compare_key(t);
    return like(t, add_multi(t[2], t[3], key, data, _a$_));
   }
   function remove_multi$0(t, key){
    var _a__ = compare_key(t);
    return like(t, remove_multi(t[2], key, t[3], _a__));
   }
   function find_multi$0(t, key){
    var _a9_ = compare_key(t);
    return find_multi(t[2], key, _a9_);
   }
   function change$0(t, key, f){
    var _a8_ = compare_key(t);
    return like(t, change(t[2], key, f, t[3], _a8_));
   }
   function update$0(t, key, f){
    var _a7_ = compare_key(t);
    return like(t, update(t[2], key, f, t[3], _a7_));
   }
   function find_exn$0(t, key){
    var _a5_ = t[1][2], _a6_ = compare_key(t);
    return find_exn(t[2], key, _a6_, _a5_);
   }
   function find$0(t, key){
    var _a4_ = compare_key(t);
    return find(t[2], key, _a4_);
   }
   function remove$0(t, key){
    var _a3_ = compare_key(t);
    return like_maybe_no_op(t, remove(t[2], key, t[3], _a3_));
   }
   function mem$0(t, key){
    var _a2_ = compare_key(t);
    return mem(t[2], key, _a2_);
   }
   function iter_keys$0(t, f){return iter_keys(t[2], f);}
   function iter$0(t, f){return iter(t[2], f);}
   function iteri$0(t, f){return iteri(t[2], f);}
   function iteri_until$0(t, f){return iteri_until(t[2], f);}
   function iter2$0(t1, t2, f){
    var _a1_ = compare_key(t1);
    return iter2(t1[2], t2[2], f, _a1_);
   }
   function map$0(t, f){return with_same_length(t, map(t[2], f));}
   function mapi$0(t, f){return with_same_length(t, mapi(t[2], f));}
   function fold$3(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f, finish){
    return fold_until(t[2], init, f, finish);
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold2$1(t1, t2, init, f){
    var _a0_ = compare_key(t1);
    return fold2$0(t1[2], t2[2], init, f, _a0_);
   }
   function filter_keys$0(t, f){
    var len = [0, t[3]], tree = filter_keys(t[2], f, len);
    return like_maybe_no_op(t, [0, tree, len[1]]);
   }
   function filter$0(t, f){
    var len = [0, t[3]], tree = filter(t[2], f, len);
    return like_maybe_no_op(t, [0, tree, len[1]]);
   }
   function filteri$0(t, f){
    var len = [0, t[3]], tree = filteri(t[2], f, len);
    return like_maybe_no_op(t, [0, tree, len[1]]);
   }
   function filter_map$0(t, f){
    var len = [0, t[3]], tree = filter_map(t[2], f, len);
    return like(t, [0, tree, len[1]]);
   }
   function filter_mapi$0(t, f){
    var len = [0, t[3]], tree = filter_mapi(t[2], f, len);
    return like(t, [0, tree, len[1]]);
   }
   function of_like_tree2(t, param){
    var t2 = param[2], t1 = param[1], _aZ_ = of_like_tree(t, t2);
    return [0, of_like_tree(t, t1), _aZ_];
   }
   function of_like_tree2_maybe_no_op(t, param){
    var t2 = param[2], t1 = param[1], _aY_ = of_like_tree_maybe_no_op(t, t2);
    return [0, of_like_tree_maybe_no_op(t, t1), _aY_];
   }
   function partition_mapi$0(t, f){
    return of_like_tree2(t, partition_mapi(t[2], f));
   }
   function partition_map$0(t, f){
    return of_like_tree2(t, partition_map(t[2], f));
   }
   function partitioni_tf$0(t, f){
    return of_like_tree2_maybe_no_op(t, partitioni_tf(t[2], f));
   }
   function partition_tf$0(t, f){
    return of_like_tree2_maybe_no_op(t, partition_tf(t[2], f));
   }
   function combine_errors$0(t){
    function _aV_(_aX_){return of_like_tree(t, _aX_);}
    var _aW_ = combine_errors(t[2], t[1][2]);
    return caml_call2(Base_Or_error[47], _aW_, _aV_);
   }
   function unzip$0(t){return of_like_tree2(t, unzip(t[2]));}
   function compare_direct(compare_data, t1, t2){
    var _aT_ = t2[2], _aU_ = t1[2];
    return compare$1(compare_key(t1), compare_data, _aU_, _aT_);
   }
   function equal$2(compare_data, t1, t2){
    var _aR_ = t2[2], _aS_ = t1[2];
    return equal$1(compare_key(t1), compare_data, _aS_, _aR_);
   }
   function keys$0(t){return keys(t[2]);}
   function data$0(t){return data(t[2]);}
   function to_alist$0(key_order, t){return to_alist(key_order, t[2]);}
   function symmetric_diff$0(t1, t2, data_equal){
    var _aQ_ = compare_key(t1);
    return symmetric_diff(t1[2], t2[2], _aQ_, data_equal);
   }
   function fold_symmetric_diff$0(t1, t2, data_equal, init, f){
    var _aP_ = compare_key(t1);
    return fold_symmetric_diff(t1[2], t2[2], _aP_, data_equal, init, f);
   }
   function merge$0(t1, t2, f){
    var _aO_ = compare_key(t1);
    return like(t1, merge(t1[2], t2[2], f, _aO_));
   }
   function merge_disjoint_exn$0(t1, t2){
    return like(t1, merge_disjoint_exn(t1[2], t2[2], t1[3], t2[3], t1[1]));
   }
   function merge_skewed$0(t1, t2, combine){
    var
     _aM_ = compare_key(t1),
     _aN_ = merge_skewed(t1[2], t2[2], t1[3], t2[3], combine, _aM_),
     t1$0 = t2[3] <= t1[3] ? t1 : t2;
    return like_maybe_no_op(t1$0, _aN_);
   }
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function for_alli$0(t, f){return for_alli(t[2], f);}
   function exists$0(t, f){return exists(t[2], f);}
   function existsi$0(t, f){return existsi(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function counti$0(t, f){return counti(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function sumi$0(m, t, f){return sumi(m, t[2], f);}
   function split$0(t, k){
    var
     _aK_ = compare_key(t),
     match = split(t[2], k, _aK_),
     r = match[3],
     maybe = match[2],
     l = match[1],
     comparator = t[1],
     both_len =
       caml_call1(Base_Option[53], maybe)
        ? caml_call2(Base_Import[93], t[3], 1)
        : t[3],
     _aL_ = height(r);
    if(height(l) < _aL_){
     var l$0 = of_tree$0(comparator, l);
     return [0,
             l$0,
             maybe,
             [0, comparator, r, caml_call2(Base_Import[93], both_len, l$0[3])]];
    }
    var r$0 = of_tree$0(comparator, r);
    return [0,
            [0, comparator, l, caml_call2(Base_Import[93], both_len, r$0[3])],
            maybe,
            r$0];
   }
   function split_and_reinsert_boundary$0(t, into, k){
    var
     _aI_ = compare_key(t),
     match = split_and_reinsert_boundary(t[2], into, k, _aI_),
     r = match[2],
     l = match[1],
     comparator = t[1],
     _aJ_ = height(r);
    if(height(l) < _aJ_){
     var l$0 = of_tree$0(comparator, l);
     return [0,
             l$0,
             [0, comparator, r, caml_call2(Base_Import[93], t[3], l$0[3])]];
    }
    var r$0 = of_tree$0(comparator, r);
    return [0,
            [0, comparator, l, caml_call2(Base_Import[93], t[3], r$0[3])],
            r$0];
   }
   function split_le_gt(t, k){
    return split_and_reinsert_boundary$0(t, 847852583, k);
   }
   function split_lt_ge(t, k){
    return split_and_reinsert_boundary$0(t, -57574468, k);
   }
   function subrange(t, lower_bound, upper_bound){
    var
     _aE_ = compare_key(t),
     match = split_range(t[2], lower_bound, upper_bound, _aE_),
     right = match[3],
     mid = match[2],
     left = match[1],
     h_l = height(left),
     h_r = height(right),
     outer_joined_height =
       h_l === h_r
        ? caml_call2(Base_Import[91], h_l, 1)
        : caml_call2(Base_Import[100], h_l, h_r);
    if(outer_joined_height >= height(mid)) return of_tree$0(t[1], mid);
    var
     _aF_ = length(right),
     _aG_ = length(left),
     _aH_ = caml_call2(Base_Import[91], _aG_, _aF_),
     mid_length = caml_call2(Base_Import[93], t[3], _aH_);
    return [0, t[1], mid, mid_length];
   }
   function append$0(lower_part, upper_part){
    var
     _aC_ = compare_key(lower_part),
     match = append(lower_part[2], upper_part[2], _aC_);
    if(typeof match === "number") return 838882908;
    var
     tree = match[2],
     _aD_ = caml_call2(Base_Import[91], lower_part[3], upper_part[3]);
    return [0, 17724, [0, lower_part[1], tree, _aD_]];
   }
   function fold_range_inclusive$0(t, min, max, init, f){
    var _aB_ = compare_key(t);
    return fold_range_inclusive(t[2], min, max, init, f, _aB_);
   }
   function range_to_alist$0(t, min, max){
    var _aA_ = compare_key(t);
    return range_to_alist(t[2], min, max, _aA_);
   }
   function closest_key$0(t, dir, key){
    var _az_ = compare_key(t);
    return closest_key(t[2], dir, key, _az_);
   }
   function nth$1(t, n){return nth$0(t[2], n);}
   function nth_exn(t, n){
    var _ay_ = nth$1(t, n);
    return caml_call4(Base_Option[31], 0, 0, 0, _ay_);
   }
   function rank$0(t, key){
    var _ax_ = compare_key(t);
    return rank(t[2], key, _ax_);
   }
   function sexp_of_t$2(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t[2]);
   }
   function to_sequence$0
   (order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (t[1],
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function hash_fold_direct(hash_fold_key, hash_fold_data, state, t){
    var t$0 = t[2];
    function _av_(key, data, state){
     return caml_call2
             (hash_fold_data, caml_call2(hash_fold_key, state, key), data);
    }
    var _aw_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[206], state, _aw_), _av_);
   }
   function binary_search_subrange(t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t[2], compare, lower_bound, upper_bound);
    if(! match) return like_maybe_no_op(t, [0, 0, 0]);
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange(t, lower_bound$0, upper_bound$0);
   }
   function Make_applicative_traversals$0(A){
    var Tree_traversals = Make_applicative_traversals(A);
    function mapi(t, f){
     function _at_(new_tree){return with_same_length(t, new_tree);}
     var _au_ = Tree_traversals[1].call(null, t[2], f);
     return caml_call2(A[2], _au_, _at_);
    }
    function filter_mapi(t, f){
     function _ar_(new_tree_with_length){
      return like(t, new_tree_with_length);
     }
     var _as_ = Tree_traversals[2].call(null, t[2], f);
     return caml_call2(A[2], _as_, _ar_);
    }
    return [0, , mapi, filter_mapi];
   }
   function empty$0(param){return empty_without_value_restrictio;}
   function of_tree$1(param, tree){return tree;}
   function singleton(param, k, v){return [0, k, v];}
   function of_sorted_array_unchecked$0(comparator, array){
    return of_sorted_array_unchecked(array, comparator[1])[1];
   }
   function of_sorted_array$0(comparator, array){
    var
     _ap_ = of_sorted_array(array, comparator[1]),
     _aq_ = Base_Or_error[47];
    return caml_call2(_aq_, _ap_, function(x){return x[1];});
   }
   function of_alist$0(comparator, alist){
    var d = of_alist(alist, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_alist_or_error$0(comparator, alist){
    var _an_ = of_alist_or_error(alist, comparator), _ao_ = Base_Or_error[47];
    return caml_call2(_ao_, _an_, function(x){return x[1];});
   }
   function of_alist_exn$0(comparator, alist){
    return of_alist_exn(alist, comparator)[1];
   }
   function of_alist_multi$0(comparator, alist){
    return of_alist_multi(alist, comparator[1])[1];
   }
   function of_alist_fold$0(comparator, alist, init, f){
    return of_alist_fold(alist, init, f, comparator[1])[1];
   }
   function of_alist_reduce$0(comparator, alist, f){
    return of_alist_reduce(alist, f, comparator[1])[1];
   }
   function of_iteri$0(comparator, iteri){
    var d = of_iteri(iteri, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_iteri_exn$0(comparator, iteri){
    return of_iteri_exn(iteri, comparator)[1];
   }
   function of_increasing_iterator_uncheck$0(required_by_intf, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_increasing_sequence$0(comparator, seq){
    function _al_(x){return x[1];}
    var _am_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[47], _am_, _al_);
   }
   function of_sequence$0(comparator, seq){
    var d = of_sequence(seq, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_sequence_or_error$0(comparator, seq){
    var
     _aj_ = of_sequence_or_error(seq, comparator),
     _ak_ = Base_Or_error[47];
    return caml_call2(_ak_, _aj_, function(x){return x[1];});
   }
   function of_sequence_exn$0(comparator, seq){
    return of_sequence_exn(seq, comparator)[1];
   }
   function of_sequence_multi$0(comparator, seq){
    return of_sequence_multi(seq, comparator[1])[1];
   }
   function of_sequence_fold$0(comparator, seq, init, f){
    return of_sequence_fold(seq, init, f, comparator[1])[1];
   }
   function of_sequence_reduce$0(comparator, seq, f){
    return of_sequence_reduce(seq, f, comparator[1])[1];
   }
   function of_list_with_key$0(comparator, list, get_key){
    var d = of_list_with_key(list, get_key, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_list_with_key_or_error$0(comparator, list, get_key){
    var
     _ah_ = of_list_with_key_or_error(list, get_key, comparator),
     _ai_ = Base_Or_error[47];
    return caml_call2(_ai_, _ah_, function(x){return x[1];});
   }
   function of_list_with_key_exn$0(comparator, list, get_key){
    return of_list_with_key_exn(list, get_key, comparator)[1];
   }
   function of_list_with_key_multi$0(comparator, list, get_key){
    return of_list_with_key_multi(list, get_key, comparator[1])[1];
   }
   function of_list_with_key_fold$0(comparator, list, get_key, init, f){
    return of_list_with_key_fold(list, get_key, init, f, comparator[1])[1];
   }
   function of_list_with_key_reduce$0(comparator, list, get_key, f){
    return of_list_with_key_reduce(list, get_key, f, comparator[1])[1];
   }
   function to_tree$0(t){return t;}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function length$1(t){return length(t);}
   function set$1(comparator, t, key, data){
    return set(t, 0, key, data, comparator[1])[1];
   }
   function add_exn$1(comparator, t, key, data){
    return add_exn(t, 0, key, data, comparator[1], comparator[2])[1];
   }
   function add$0(comparator, t, key, data){
    try{
     var
      _af_ =
        [0,
         17724,
         add_exn_internal(t, 0, key, data, comparator[1], comparator[2])[1]];
     return _af_;
    }
    catch(_ag_){return -1024851605;}
   }
   function add_multi$1(comparator, t, key, data){
    return add_multi(t, 0, key, data, comparator[1])[1];
   }
   function remove_multi$1(comparator, t, key){
    return remove_multi(t, key, 0, comparator[1])[1];
   }
   function find_multi$1(comparator, t, key){
    return find_multi(t, key, comparator[1]);
   }
   function change$1(comparator, t, key, f){
    return change(t, key, f, 0, comparator[1])[1];
   }
   function update$1(comparator, t, key, f){
    return change$1
            (comparator,
             t,
             key,
             function(data){return [0, caml_call1(f, data)];});
   }
   function find_exn$1(comparator, t, key){
    return find_exn(t, key, comparator[1], comparator[2]);
   }
   function find$1(comparator, t, key){return find(t, key, comparator[1]);}
   function remove$1(comparator, t, key){
    return remove(t, key, 0, comparator[1])[1];
   }
   function mem$1(comparator, t, key){return mem(t, key, comparator[1]);}
   function iter_keys$1(t, f){return iter_keys(t, f);}
   function iter$1(t, f){return iter(t, f);}
   function iteri$1(t, f){return iteri(t, f);}
   function iteri_until$1(t, f){return iteri_until(t, f);}
   function iter2$1(comparator, t1, t2, f){
    return iter2(t1, t2, f, comparator[1]);
   }
   function map$1(t, f){return map(t, f);}
   function mapi$1(t, f){return mapi(t, f);}
   function fold$4(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function fold2$2(comparator, t1, t2, init, f){
    return fold2$0(t1, t2, init, f, comparator[1]);
   }
   function filter_keys$1(t, f){return filter_keys(t, f, [0, 0]);}
   function filter$1(t, f){return filter(t, f, [0, 0]);}
   function filteri$1(t, f){return filteri(t, f, [0, 0]);}
   function filter_map$1(t, f){return filter_map(t, f, [0, 0]);}
   function filter_mapi$1(t, f){return filter_mapi(t, f, [0, 0]);}
   function partition_mapi$1(t, f){return partition_mapi(t, f);}
   function partition_map$1(t, f){return partition_map(t, f);}
   function partitioni_tf$1(t, f){return partitioni_tf(t, f);}
   function partition_tf$1(t, f){return partition_tf(t, f);}
   function combine_errors$1(comparator, t){
    return combine_errors(t, comparator[2]);
   }
   function compare_direct$0(comparator, compare_data, t1, t2){return compare$1(comparator[1], compare_data, t1, t2);
   }
   function equal$3(comparator, compare_data, t1, t2){
    return equal$1(comparator[1], compare_data, t1, t2);
   }
   function keys$1(t){return keys(t);}
   function data$1(t){return data(t);}
   function to_alist$1(key_order, t){return to_alist(key_order, t);}
   function symmetric_diff$1(comparator, t1, t2, data_equal){
    return symmetric_diff(t1, t2, comparator[1], data_equal);
   }
   function fold_symmetric_diff$1(comparator, t1, t2, data_equal, init, f){
    return fold_symmetric_diff(t1, t2, comparator[1], data_equal, init, f);
   }
   function merge$1(comparator, t1, t2, f){
    return merge(t1, t2, f, comparator[1])[1];
   }
   function merge_disjoint_exn$1(comparator, t1, t2){
    var _ae_ = length$1(t2);
    return merge_disjoint_exn(t1, t2, length$1(t1), _ae_, comparator)[1];
   }
   function merge_skewed$1(comparator, t1, t2, combine){
    var _ac_ = comparator[1], _ad_ = length$1(t2);
    return merge_skewed(t1, t2, length$1(t1), _ad_, combine, _ac_)[1];
   }
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function for_all$1(t, f){return for_all(t, f);}
   function for_alli$1(t, f){return for_alli(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function existsi$1(t, f){return existsi(t, f);}
   function count$1(t, f){return count(t, f);}
   function counti$1(t, f){return counti(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function sumi$1(m, t, f){return sumi(m, t, f);}
   function split$1(comparator, t, k){return split(t, k, comparator[1]);}
   function split_le_gt$0(comparator, t, k){
    return split_and_reinsert_boundary(t, 847852583, k, comparator[1]);
   }
   function split_lt_ge$0(comparator, t, k){
    return split_and_reinsert_boundary(t, -57574468, k, comparator[1]);
   }
   function append$1(comparator, lower_part, upper_part){
    return append(lower_part, upper_part, comparator[1]);
   }
   function subrange$0(comparator, t, lower_bound, upper_bound){
    var ret = split_range(t, lower_bound, upper_bound, comparator[1])[2];
    return ret;
   }
   function fold_range_inclusive$1(comparator, t, min, max, init, f){
    return fold_range_inclusive(t, min, max, init, f, comparator[1]);
   }
   function range_to_alist$1(comparator, t, min, max){
    return range_to_alist(t, min, max, comparator[1]);
   }
   function closest_key$1(comparator, t, dir, key){
    return closest_key(t, dir, key, comparator[1]);
   }
   function nth$2(t, n){return nth$0(t, n);}
   function nth_exn$0(t, n){
    var _ab_ = nth$2(t, n);
    return caml_call4(Base_Option[31], 0, 0, 0, _ab_);
   }
   function rank$1(comparator, t, key){return rank(t, key, comparator[1]);}
   function sexp_of_t$3(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t);
   }
   function t_of_sexp_direct$0(comparator, k_of_sexp, v_of_sexp, sexp){
    return t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator)[1];
   }
   function to_sequence$1
   (comparator, order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (comparator,
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function binary_search_subrange$0
   (comparator, t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t, compare, lower_bound, upper_bound);
    if(! match) return 0;
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange$0(comparator, t, lower_bound$0, upper_bound$0);
   }
   function map_keys$0(comparator, t, f){
    var dup = map_keys(t, f, comparator);
    if(17724 > dup[1]) return dup;
    var t$0 = dup[2][1];
    return [0, 17724, t$0];
   }
   function map_keys_exn$0(comparator, t, f){
    return map_keys_exn(t, f, comparator)[1];
   }
   function transpose_keys$0(outer_comparator, inner_comparator, t){
    var _aa_ = transpose_keys(outer_comparator, inner_comparator, t)[1];
    return map$1(_aa_, function(x){return x[1];});
   }
   function add_exn$2(t, comparator, key, data){
    var match = max_key(t);
    if(match){
     var prev_key = match[1];
     if(0 <= caml_call2(comparator[1], prev_key, key))
      return caml_call1(Base_Error[32], _v_);
    }
    return add_unchecked(t, key, data);
   }
   function to_tree$1(t){return to_tree_unchecked(t);}
   var Build_increasing = [0, empty, add_exn$2, to_tree$1];
   function empty$1(comparator){
    return [0, comparator, empty_without_value_restrictio, 0];
   }
   function singleton$0(comparator, k, v){return [0, comparator, [0, k, v], 1];
   }
   function of_tree0(comparator, param){
    var length = param[2], tree = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$2(comparator, tree){
    return of_tree0(comparator, [0, tree, length(tree)]);
   }
   function of_sorted_array_unchecked$1(comparator, array){
    return of_tree0
            (comparator, of_sorted_array_unchecked(array, comparator[1]));
   }
   function of_sorted_array$1(comparator, array){
    function ___(tree){return of_tree0(comparator, tree);}
    var _$_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[47], _$_, ___);
   }
   function of_alist$1(comparator, alist){
    var z = of_alist(alist, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_alist_or_error$1(comparator, alist){
    function _Y_(tree){return of_tree0(comparator, tree);}
    var _Z_ = of_alist_or_error(alist, comparator);
    return caml_call2(Base_Result[33], _Z_, _Y_);
   }
   function of_alist_exn$1(comparator, alist){
    return of_tree0(comparator, of_alist_exn(alist, comparator));
   }
   function of_alist_multi$1(comparator, alist){
    return of_tree0(comparator, of_alist_multi(alist, comparator[1]));
   }
   function of_alist_fold$1(comparator, alist, init, f){
    return of_tree0(comparator, of_alist_fold(alist, init, f, comparator[1]));
   }
   function of_alist_reduce$1(comparator, alist, f){
    return of_tree0(comparator, of_alist_reduce(alist, f, comparator[1]));
   }
   function of_iteri$1(comparator, iteri){
    var z = of_iteri(iteri, comparator[1]);
    if(17724 > z[1]) return z;
    var tree_length = z[2];
    return [0, 17724, of_tree0(comparator, tree_length)];
   }
   function of_iteri_exn$1(comparator, iteri){
    return of_tree0(comparator, of_iteri_exn(iteri, comparator));
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    return of_tree0
            (comparator, [0, of_increasing_iterator_uncheck(len, f), len]);
   }
   function of_increasing_sequence$1(comparator, seq){
    function _W_(x){return of_tree0(comparator, x);}
    var _X_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[47], _X_, _W_);
   }
   function of_sequence$1(comparator, seq){
    var z = of_sequence(seq, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_sequence_or_error$1(comparator, seq){
    function _U_(tree){return of_tree0(comparator, tree);}
    var _V_ = of_sequence_or_error(seq, comparator);
    return caml_call2(Base_Result[33], _V_, _U_);
   }
   function of_sequence_exn$1(comparator, seq){
    return of_tree0(comparator, of_sequence_exn(seq, comparator));
   }
   function of_sequence_multi$1(comparator, seq){
    return of_tree0(comparator, of_sequence_multi(seq, comparator[1]));
   }
   function of_sequence_fold$1(comparator, seq, init, f){
    return of_tree0(comparator, of_sequence_fold(seq, init, f, comparator[1]));
   }
   function of_sequence_reduce$1(comparator, seq, f){
    return of_tree0(comparator, of_sequence_reduce(seq, f, comparator[1]));
   }
   function of_list_with_key$1(comparator, list, get_key){
    var z = of_list_with_key(list, get_key, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_list_with_key_or_error$1(comparator, list, get_key){
    function _S_(tree){return of_tree0(comparator, tree);}
    var _T_ = of_list_with_key_or_error(list, get_key, comparator);
    return caml_call2(Base_Result[33], _T_, _S_);
   }
   function of_list_with_key_exn$1(comparator, list, get_key){
    return of_tree0
            (comparator, of_list_with_key_exn(list, get_key, comparator));
   }
   function of_list_with_key_multi$1(comparator, list, get_key){
    return of_tree0
            (comparator, of_list_with_key_multi(list, get_key, comparator[1]));
   }
   function of_list_with_key_fold$1(comparator, list, get_key, init, f){
    return of_tree0
            (comparator,
             of_list_with_key_fold(list, get_key, init, f, comparator[1]));
   }
   function of_list_with_key_reduce$1(comparator, list, get_key, f){
    return of_tree0
            (comparator,
             of_list_with_key_reduce(list, get_key, f, comparator[1]));
   }
   function t_of_sexp_direct$1(comparator, k_of_sexp, v_of_sexp, sexp){
    return of_tree0
            (comparator,
             t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator));
   }
   function map_keys$1(comparator, t, f){
    var dup = map_keys(t[2], f, comparator);
    if(17724 > dup[1]) return dup;
    var pair = dup[2];
    return [0, 17724, of_tree0(comparator, pair)];
   }
   function map_keys_exn$1(comparator, t, f){
    return of_tree0(comparator, map_keys_exn(t[2], f, comparator));
   }
   function transpose_keys$1(inner_comparator, t){
    var
     outer_comparator = t[1],
     _R_ =
       of_tree0
        (inner_comparator,
         transpose_keys
          (outer_comparator, inner_comparator, map(t[2], to_tree)));
    return map$0(_R_, function(x){return of_tree0(outer_comparator, x);});
   }
   function Empty_without_value_restrictio(K){
    var empty = [0, K[1], empty_without_value_restrictio, 0];
    return [0, empty];
   }
   function comparator_s(t){return caml_call1(Base_Comparator[5], t[1]);}
   var to_comparator = Base_Comparator[4];
   function of_tree$3(m, tree){
    return of_tree$0(caml_call1(to_comparator, m), tree);
   }
   function empty$2(m){return empty$1(caml_call1(to_comparator, m));}
   function singleton$1(m, a){
    var _P_ = caml_call1(to_comparator, m);
    return function(_Q_){return singleton$0(_P_, a, _Q_);};
   }
   function of_alist$2(m, a){
    return of_alist$1(caml_call1(to_comparator, m), a);
   }
   function of_alist_or_error$2(m, a){
    return of_alist_or_error$1(caml_call1(to_comparator, m), a);
   }
   function of_alist_exn$2(m, a){
    return of_alist_exn$1(caml_call1(to_comparator, m), a);
   }
   function of_alist_multi$2(m, a){
    return of_alist_multi$1(caml_call1(to_comparator, m), a);
   }
   function of_alist_fold$2(m, a, init, f){
    return of_alist_fold$1(caml_call1(to_comparator, m), a, init, f);
   }
   function of_alist_reduce$2(m, a, f){
    return of_alist_reduce$1(caml_call1(to_comparator, m), a, f);
   }
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(caml_call1(to_comparator, m), a);
   }
   function of_sorted_array$2(m, a){
    return of_sorted_array$1(caml_call1(to_comparator, m), a);
   }
   function of_iteri$2(m, iteri){
    return of_iteri$1(caml_call1(to_comparator, m), iteri);
   }
   function of_iteri_exn$2(m, iteri){
    return of_iteri_exn$1(caml_call1(to_comparator, m), iteri);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1
            (caml_call1(to_comparator, m), len, f);
   }
   function of_increasing_sequence$2(m, seq){
    return of_increasing_sequence$1(caml_call1(to_comparator, m), seq);
   }
   function of_sequence$2(m, s){
    return of_sequence$1(caml_call1(to_comparator, m), s);
   }
   function of_sequence_or_error$2(m, s){
    return of_sequence_or_error$1(caml_call1(to_comparator, m), s);
   }
   function of_sequence_exn$2(m, s){
    return of_sequence_exn$1(caml_call1(to_comparator, m), s);
   }
   function of_sequence_multi$2(m, s){
    return of_sequence_multi$1(caml_call1(to_comparator, m), s);
   }
   function of_sequence_fold$2(m, s, init, f){
    return of_sequence_fold$1(caml_call1(to_comparator, m), s, init, f);
   }
   function of_sequence_reduce$2(m, s, f){
    return of_sequence_reduce$1(caml_call1(to_comparator, m), s, f);
   }
   function of_list_with_key$2(m, l, get_key){
    return of_list_with_key$1(caml_call1(to_comparator, m), l, get_key);
   }
   function of_list_with_key_or_error$2(m, l, get_key){
    return of_list_with_key_or_error$1
            (caml_call1(to_comparator, m), l, get_key);
   }
   function of_list_with_key_exn$2(m, l, get_key){
    return of_list_with_key_exn$1(caml_call1(to_comparator, m), l, get_key);
   }
   function of_list_with_key_multi$2(m, l, get_key){
    return of_list_with_key_multi$1(caml_call1(to_comparator, m), l, get_key);
   }
   function of_list_with_key_fold$2(m, l, get_key, init, f){
    return of_list_with_key_fold$1
            (caml_call1(to_comparator, m), l, get_key, init, f);
   }
   function of_list_with_key_reduce$2(m, l, get_key, f){
    return of_list_with_key_reduce$1
            (caml_call1(to_comparator, m), l, get_key, f);
   }
   function map_keys$2(m, t, f){
    return map_keys$1(caml_call1(to_comparator, m), t, f);
   }
   function map_keys_exn$2(m, t, f){
    return map_keys_exn$1(caml_call1(to_comparator, m), t, f);
   }
   function transpose_keys$2(m, t){
    return transpose_keys$1(caml_call1(to_comparator, m), t);
   }
   function M(K){return [0];}
   function sexp_of_m_t(K, sexp_of_v, t){
    function _O_(param){return _w_;}
    return sexp_of_t$2(K[1], sexp_of_v, _O_, t);
   }
   function m_t_of_sexp(K, v_of_sexp, sexp){
    return t_of_sexp_direct$1(K[2], K[1], v_of_sexp, sexp);
   }
   function m_t_sexp_grammar(K, v_grammar){
    return [5,
            [0,
             Sexplib0_Sexp_grammar[5],
             _z_,
             [2,
              [1,
               [2,
                [0,
                 [5, [0, Sexplib0_Sexp_grammar[6], _y_, K[1]]],
                 [0, [5, [0, Sexplib0_Sexp_grammar[7], _x_, v_grammar]], 0]]]]]]];
   }
   function compare_m_t(param, compare_v, t1, t2){return compare_direct(compare_v, t1, t2);
   }
   function equal_m_t(param, equal_v, t1, t2){return equal$2(equal_v, t1, t2);
   }
   function hash_fold_m_t(K, hash_fold_v, state){
    var _M_ = K[1];
    return function(_N_){
     return hash_fold_direct(_M_, hash_fold_v, state, _N_);};
   }
   var comparator$0 = Base_Comparator[2][1];
   function of_tree$4(tree){return [0, comparator$0, tree, length(tree)];}
   var
    include$1 = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$3 = include$1[1];
   function singleton$2(a){
    return function(_L_){return singleton$0(comparator$0, a, _L_);};
   }
   function of_alist$3(a){return of_alist$1(comparator$0, a);}
   function of_alist_or_error$3(a){
    return of_alist_or_error$1(comparator$0, a);
   }
   function of_alist_exn$3(a){return of_alist_exn$1(comparator$0, a);}
   function of_alist_multi$3(a){return of_alist_multi$1(comparator$0, a);}
   function of_alist_fold$3(a, init, f){
    return of_alist_fold$1(comparator$0, a, init, f);
   }
   function of_alist_reduce$3(a, f){
    return of_alist_reduce$1(comparator$0, a, f);
   }
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_iteri$3(iteri){return of_iteri$1(comparator$0, iteri);}
   function of_iteri_exn$3(iteri){return of_iteri_exn$1(comparator$0, iteri);}
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_increasing_sequence$3(seq){
    return of_increasing_sequence$1(comparator$0, seq);
   }
   function of_sequence$3(s){return of_sequence$1(comparator$0, s);}
   function of_sequence_or_error$3(s){
    return of_sequence_or_error$1(comparator$0, s);
   }
   function of_sequence_exn$3(s){return of_sequence_exn$1(comparator$0, s);}
   function of_sequence_multi$3(s){
    return of_sequence_multi$1(comparator$0, s);
   }
   function of_sequence_fold$3(s, init, f){
    return of_sequence_fold$1(comparator$0, s, init, f);
   }
   function of_sequence_reduce$3(s, f){
    return of_sequence_reduce$1(comparator$0, s, f);
   }
   function of_list_with_key$3(l, get_key){
    return of_list_with_key$1(comparator$0, l, get_key);
   }
   function of_list_with_key_or_error$3(l, get_key){
    return of_list_with_key_or_error$1(comparator$0, l, get_key);
   }
   function of_list_with_key_exn$3(l, get_key){
    return of_list_with_key_exn$1(comparator$0, l, get_key);
   }
   function of_list_with_key_multi$3(l, get_key){
    return of_list_with_key_multi$1(comparator$0, l, get_key);
   }
   function of_list_with_key_fold$3(l, get_key, init, f){
    return of_list_with_key_fold$1(comparator$0, l, get_key, init, f);
   }
   function of_list_with_key_reduce$3(l, get_key, f){
    return of_list_with_key_reduce$1(comparator$0, l, get_key, f);
   }
   function map_keys$3(t, f){return map_keys$1(comparator$0, t, f);}
   function map_keys_exn$3(t, f){return map_keys_exn$1(comparator$0, t, f);}
   function transpose_keys$3(t){return transpose_keys$1(comparator$0, t);}
   var
    _A_ =
      [0,
       empty$3,
       singleton$2,
       map_keys$3,
       map_keys_exn$3,
       transpose_keys$3,
       of_sorted_array$3,
       of_sorted_array_unchecked$3,
       of_increasing_iterator_uncheck$3,
       of_alist$3,
       of_alist_or_error$3,
       of_alist_exn$3,
       of_alist_multi$3,
       of_alist_fold$3,
       of_alist_reduce$3,
       of_increasing_sequence$3,
       of_sequence$3,
       of_sequence_or_error$3,
       of_sequence_exn$3,
       of_sequence_multi$3,
       of_sequence_fold$3,
       of_sequence_reduce$3,
       of_list_with_key$3,
       of_list_with_key_or_error$3,
       of_list_with_key_exn$3,
       of_list_with_key_multi$3,
       of_list_with_key_fold$3,
       of_list_with_key_reduce$3,
       of_iteri$3,
       of_iteri_exn$3,
       of_tree$4,
       invariants$0,
       is_empty$0,
       length$0,
       add,
       add_exn$0,
       set$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       unzip$0,
       compare_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_disjoint_exn$0,
       merge_skewed$0,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       sum$0,
       sumi$0,
       split$0,
       split_le_gt,
       split_lt_ge,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_tree,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       function(_J_){
        var _K_ = Make_applicative_traversals$0(_J_);
        return [0, _K_[2], _K_[3]];
       }];
   function _B_(_H_){
    var _I_ = Make_applicative_traversals$0(_H_);
    return [0, _I_[2], _I_[3]];
   }
   var
    _C_ =
      [0,
       sexp_of_t$2,
       t_of_sexp_direct$1,
       [0,
        sexp_of_t$3,
        t_of_sexp_direct$0,
        empty$0,
        singleton,
        map_keys$0,
        map_keys_exn$0,
        transpose_keys$0,
        of_sorted_array$0,
        of_sorted_array_unchecked$0,
        of_increasing_iterator_uncheck$0,
        of_alist$0,
        of_alist_or_error$0,
        of_alist_exn$0,
        of_alist_multi$0,
        of_alist_fold$0,
        of_alist_reduce$0,
        of_increasing_sequence$0,
        of_sequence$0,
        of_sequence_or_error$0,
        of_sequence_exn$0,
        of_sequence_multi$0,
        of_sequence_fold$0,
        of_sequence_reduce$0,
        of_list_with_key$0,
        of_list_with_key_or_error$0,
        of_list_with_key_exn$0,
        of_list_with_key_multi$0,
        of_list_with_key_fold$0,
        of_list_with_key_reduce$0,
        of_iteri$0,
        of_iteri_exn$0,
        of_tree$1,
        invariants$1,
        is_empty$1,
        length$1,
        add$0,
        add_exn$1,
        set$1,
        add_multi$1,
        remove_multi$1,
        find_multi$1,
        change$1,
        update$1,
        find$1,
        find_exn$1,
        remove$1,
        mem$1,
        iter_keys$1,
        iter$1,
        iteri$1,
        iteri_until$1,
        iter2$1,
        map$1,
        mapi$1,
        fold$4,
        fold_until$1,
        fold_right$1,
        fold2$2,
        filter_keys$1,
        filter$1,
        filteri$1,
        filter_map$1,
        filter_mapi$1,
        partition_mapi$1,
        partition_map$1,
        partitioni_tf$1,
        partition_tf$1,
        combine_errors$1,
        unzip,
        compare_direct$0,
        equal$3,
        keys$1,
        data$1,
        to_alist$1,
        merge$1,
        merge_disjoint_exn$1,
        merge_skewed$1,
        symmetric_diff$1,
        fold_symmetric_diff$1,
        min_elt$1,
        min_elt_exn$1,
        max_elt$1,
        max_elt_exn$1,
        for_all$1,
        for_alli$1,
        exists$1,
        existsi$1,
        count$1,
        counti$1,
        sum$1,
        sumi$1,
        split$1,
        split_le_gt$0,
        split_lt_ge$0,
        append$1,
        subrange$0,
        fold_range_inclusive$1,
        range_to_alist$1,
        closest_key$1,
        nth$2,
        nth_exn$0,
        rank$1,
        to_tree$0,
        to_sequence$1,
        binary_search$1,
        binary_search_segmented$1,
        binary_search_subrange$0,
        function(A){
         var Tree0_traversals = Make_applicative_traversals(A);
         function mapi(t, f){return Tree0_traversals[1].call(null, t, f);}
         function filter_mapi(t, f){
          function _F_(x){return x[1];}
          var _G_ = Tree0_traversals[2].call(null, t, f);
          return caml_call2(A[2], _G_, _F_);
         }
         return [0, mapi, filter_mapi];
        },
        empty_without_value_restrictio,
        Build_increasing],
       empty$1,
       singleton$0,
       map_keys$1,
       map_keys_exn$1,
       transpose_keys$1,
       of_sorted_array$1,
       of_sorted_array_unchecked$1,
       of_increasing_iterator_uncheck$1,
       of_alist$1,
       of_alist_or_error$1,
       of_alist_exn$1,
       of_alist_multi$1,
       of_alist_fold$1,
       of_alist_reduce$1,
       of_increasing_sequence$1,
       of_sequence$1,
       of_sequence_or_error$1,
       of_sequence_exn$1,
       of_sequence_multi$1,
       of_sequence_fold$1,
       of_sequence_reduce$1,
       of_list_with_key$1,
       of_list_with_key_or_error$1,
       of_list_with_key_exn$1,
       of_list_with_key_multi$1,
       of_list_with_key_fold$1,
       of_list_with_key_reduce$1,
       of_iteri$1,
       of_iteri_exn$1,
       of_tree$2,
       invariants$0,
       is_empty$0,
       length$0,
       add,
       add_exn$0,
       set$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       unzip$0,
       compare_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_disjoint_exn$0,
       merge_skewed$0,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       sum$0,
       sumi$0,
       split$0,
       split_le_gt,
       split_lt_ge,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_tree,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       _B_,
       comparator,
       hash_fold_direct,
       Empty_without_value_restrictio],
    Base_Map =
      [0,
       Finished_or_unfinished,
       Merge_element,
       invariants$0,
       comparator_s,
       comparator,
       empty$2,
       singleton$1,
       of_alist$2,
       of_alist_or_error$2,
       of_alist_exn$2,
       of_alist_multi$2,
       of_alist_fold$2,
       of_alist_reduce$2,
       of_iteri$2,
       of_iteri_exn$2,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       of_increasing_sequence$2,
       of_sequence$2,
       of_sequence_or_error$2,
       of_sequence_exn$2,
       of_sequence_multi$2,
       of_sequence_fold$2,
       of_sequence_reduce$2,
       of_list_with_key$2,
       of_list_with_key_or_error$2,
       of_list_with_key_exn$2,
       of_list_with_key_multi$2,
       of_list_with_key_fold$2,
       of_list_with_key_reduce$2,
       is_empty$0,
       length$0,
       set$0,
       add,
       add_exn$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       map_keys$2,
       map_keys_exn$2,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       unzip$0,
       compare_direct,
       hash_fold_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_disjoint_exn$0,
       merge_skewed$0,
       Symmetric_diff_element,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       transpose_keys$2,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       sum$0,
       sumi$0,
       split$0,
       split_le_gt,
       split_lt_ge,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       function(_D_){
        var _E_ = Make_applicative_traversals$0(_D_);
        return [0, _E_[2], _E_[3]];
       },
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       _C_,
       _A_,
       of_tree$3,
       to_tree];
   runtime.caml_register_global(67, Base_Map, "Base__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue0
//# unitInfo: Requires: Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Queue = global_data.Stdlib__Queue,
    create = Stdlib_Queue[2],
    clear = Stdlib_Queue[11],
    copy = Stdlib_Queue[12],
    is_empty = Stdlib_Queue[13],
    length = Stdlib_Queue[14],
    peek = Stdlib_Queue[8],
    pop = Stdlib_Queue[7],
    push = Stdlib_Queue[4],
    transfer = Stdlib_Queue[17];
   function iter(t, f){
    var caml_iter = Stdlib_Queue[15];
    return caml_call2(caml_iter, f, t);
   }
   function fold(t, init, f){
    var caml_fold = Stdlib_Queue[16];
    return caml_call3(caml_fold, f, init, t);
   }
   var
    Base_Linked_queue0 =
      [0,
       create,
       clear,
       copy,
       is_empty,
       length,
       peek,
       pop,
       push,
       transfer,
       iter,
       fold];
   runtime.caml_register_global(1, Base_Linked_queue0, "Base__Linked_queue0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue
//# unitInfo: Requires: Base__Array, Base__Import, Base__Indexed_container, Base__Linked_queue0, Base__List, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Array = global_data.Base__Array,
    Base_Linked_queue0 = global_data.Base__Linked_queue0,
    Base_Indexed_container = global_data.Base__Indexed_container,
    create = Base_Linked_queue0[1],
    clear = Base_Linked_queue0[2],
    copy = Base_Linked_queue0[3],
    is_empty = Base_Linked_queue0[4],
    length = Base_Linked_queue0[5],
    iter = Base_Linked_queue0[10],
    fold = Base_Linked_queue0[11];
   function enqueue(t, x){return caml_call2(Base_Linked_queue0[8], x, t);}
   function dequeue(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[7], t)];
   }
   var dequeue_exn = Base_Linked_queue0[7];
   function dequeue_and_ignore_exn(t){caml_call1(dequeue_exn, t); return 0;}
   function peek(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[6], t)];
   }
   var peek_exn = Base_Linked_queue0[6];
   function drain(t, f, while$0){
    for(;;){
     if
      (!
       caml_call1(is_empty, t)
       && caml_call1(while$0, caml_call1(peek_exn, t))){
      caml_call1(f, caml_call1(dequeue_exn, t));
      continue;
     }
     return 0;
    }
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, -304398144, -304398144]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    to_list = C[14],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    foldi = C[18],
    for_alli = C[21],
    iteri = C[19];
   function transfer(src, dst){
    return caml_call2(Base_Linked_queue0[9], src, dst);
   }
   function concat_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       function _o_(b){return enqueue(res, b);}
       var _p_ = caml_call1(f, a);
       return caml_call2(Base_List[19], _p_, _o_);
      });
    return res;
   }
   function concat_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       function _m_(b){return enqueue(res, b);}
       var _n_ = caml_call2(f, i, a);
       return caml_call2(Base_List[19], _n_, _m_);
      });
    return res;
   }
   function filter_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var _l_ = caml_call1(f, a);
       return _l_ ? enqueue(res, a) : _l_;
      });
    return res;
   }
   function filteri(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var _k_ = caml_call2(f, i, a);
       return _k_ ? enqueue(res, a) : _k_;
      });
    return res;
   }
   function map(t, f){
    var res = caml_call1(create, 0);
    caml_call2(iter, t, function(a){return enqueue(res, caml_call1(f, a));});
    return res;
   }
   function mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri, t, function(i, a){return enqueue(res, caml_call2(f, i, a));});
    return res;
   }
   function filter_inplace(q, f){
    var q$0 = filter(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function filteri_inplace(q, f){
    var q$0 = filteri(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function enqueue_all(t, list){
    function _j_(x){return enqueue(t, x);}
    return caml_call2(Base_List[19], list, _j_);
   }
   function of_list(list){
    var t = caml_call1(create, 0);
    function _i_(x){return enqueue(t, x);}
    caml_call2(Base_List[19], list, _i_);
    return t;
   }
   function of_array(array){
    var t = caml_call1(create, 0);
    function _h_(x){return enqueue(t, x);}
    caml_call2(Base_Array[20], array, _h_);
    return t;
   }
   function init(len, f){
    var
     t = caml_call1(create, 0),
     _f_ = caml_call2(Base_Import[93], len, 1),
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      enqueue(t, caml_call1(f, i));
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      var i = _g_;
     }
    }
    return t;
   }
   function to_array(t){
    var len = caml_call1(length, t);
    if(0 === len) return [0];
    var
     _c_ = caml_call1(peek_exn, t),
     arr = caml_call2(Base_Array[48], len, _c_),
     i = [0, 0];
    caml_call2
     (iter,
      t,
      function(v){
       var _d_ = i[1];
       runtime.caml_check_bound(arr, _d_)[1 + _d_] = v;
       i[1]++;
       return 0;
      });
    return arr;
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_Import[173], a_of_sexp, sexp));
   }
   function sexp_of_t(sexp_of_a, t){
    var _b_ = caml_call1(to_list, t);
    return caml_call2(Base_Import[149], sexp_of_a, _b_);
   }
   function t_sexp_grammar(grammar){
    var _a_ = caml_call1(Base_List[7], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _a_);
   }
   function singleton(a){
    var t = caml_call1(create, 0);
    enqueue(t, a);
    return t;
   }
   var
    Base_Linked_queue =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       dequeue_and_ignore_exn,
       drain,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       create,
       transfer];
   runtime.caml_register_global(6, Base_Linked_queue, "Base__Linked_queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int64
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int64, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Lx = "%Lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int64.Hex",
    module_name$0 = "Base.Int64",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    globalize = Base_Import[286],
    hash_fold_t = Base_Import[203],
    func = Base_Import[217],
    _e_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    _d_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    cst_Int64_ceil_log2_got_invali = "[Int64.ceil_log2] got invalid input",
    cst_Int64_floor_log2_got_inval = "[Int64.floor_log2] got invalid input",
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, "src/int64.ml", 115, 2],
    _a_ =
      [0,
       [11,
        "Int64.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int64.of_float: argument (%f) is out of range or NaN"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[166],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[188],
    hashable = [0, hash, Stdlib_Int64[15], sexp_of_t];
   function compare(_I_, _H_){return caml_int64_compare(_I_, _H_);}
   var
    to_string = Stdlib_Int64[14],
    of_string = runtime.caml_int64_of_string,
    of_string_opt = Stdlib_Int64[13],
    include = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t]),
    comparator = include[1],
    float_lower_bound = caml_call1(Base_Float0[26], 64),
    float_upper_bound = caml_call1(Base_Float0[24], 64),
    shift_right_logical = caml_int64_shift_right_unsigne,
    shift_right = runtime.caml_int64_shift_right,
    shift_left = runtime.caml_int64_shift_left,
    bit_not = Stdlib_Int64[11],
    bit_xor = runtime.caml_int64_xor,
    bit_or = caml_int64_or,
    bit_and = caml_int64_and,
    min_value = Stdlib_Int64[10],
    max_value = Stdlib_Int64[9],
    abs = Stdlib_Int64[8],
    pred = Stdlib_Int64[7],
    succ = Stdlib_Int64[6],
    symbol = Base_Int_math[2][2],
    rem = runtime.caml_int64_mod,
    neg = caml_int64_neg,
    minus_one = Stdlib_Int64[3],
    one = Stdlib_Int64[2],
    zero = Stdlib_Int64[1],
    to_float = runtime.caml_int64_to_float,
    of_float_unchecked = caml_int64_of_float,
    num_bits = 64;
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound)
     return caml_int64_of_float(f);
    var _G_ = caml_call1(Base_Float0[29], f);
    return caml_call3(Base_Printf[7], _a_, _G_, 0);
   }
   function bswap16(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 48);
   }
   function bswap32(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 32);
   }
   function bswap48(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 16);
   }
   var
    include$0 = caml_call1(Base_Comparable[14], [0, compare, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5];
   function invariant(param){return 0;}
   function between(t, low, high){
    var
     _E_ = caml_lessequal(low, t),
     _F_ = _E_ ? caml_lessequal(t, high) : _E_;
    return _F_;
   }
   function clamp_unchecked(t, min, max){
    var _D_ = caml_call2(Base_Import[103][4], t, max);
    return caml_call1(caml_call1(Base_Import[103][3], min), _D_);
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _A_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _B_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _A_],
     _C_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _B_);
    return caml_call1(Base_Or_error[39], _C_);
   }
   function incr(r){r[1] = caml_int64_add(r[1], one); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one); return 0;}
   function of_int64_exn(_z_){return _z_;}
   function to_int64(t){return t;}
   var
    popcount = Base_Popcount[3],
    of_int_exn = caml_int64_of_int32,
    to_int = Base_Int_conversions[12],
    to_int_exn = Base_Int_conversions[13],
    of_int32_exn = caml_int64_of_int32,
    to_int32 = Base_Int_conversions[15],
    to_int32_exn = Base_Int_conversions[16],
    of_nativeint_exn = caml_int64_of_int32,
    to_nativeint = Base_Int_conversions[18],
    to_nativeint_exn = Base_Int_conversions[19],
    raise_s = Base_Error[32];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   var lsr = caml_int64_shift_right_unsigne, land = caml_int64_and;
   function ceil_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int64[7], x),
     x$1 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$2 = caml_int64_or(x$1, caml_int64_shift_right_unsigne(x$1, 2)),
     x$3 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 4)),
     x$4 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 8)),
     x$5 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 16)),
     x$6 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 32));
    return caml_call1(Stdlib_Int64[6], x$6);
   }
   function floor_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_int64_or(x, caml_int64_shift_right_unsigne(x, 1)),
     x$1 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 2)),
     x$2 = caml_int64_or(x$1, caml_int64_shift_right_unsigne(x$1, 4)),
     x$3 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 8)),
     x$4 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$5 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 32));
    return caml_int64_sub(x$5, caml_int64_shift_right_unsigne(x$5, 1));
   }
   function is_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var _y_ = Stdlib_Int64[1];
    return caml_equal(caml_int64_and(x, caml_call1(Stdlib_Int64[7], x)), _y_);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _v_ = [0, [0, cst, caml_call1(Base_Import[142], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int64_floor_log2_got_inval, _v_));
    }
    var
     _w_ = runtime.Base_int_math_int64_clz(i),
     _x_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _x_, _w_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _t_ = [0, [0, cst$0, caml_call1(Base_Import[142], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int64_ceil_log2_got_invali, _t_));
    }
    if(caml_call2(Stdlib_Int64[17], i, Stdlib_Int64[2])) return 0;
    var _u_ = runtime.Base_int_math_int64_clz(caml_call1(Stdlib_Int64[7], i));
    return caml_call2(Base_Import[93], num_bits, _u_);
   }
   var
    include$1 = caml_call1(Base_Int_string_conversions[1], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare_local = Base_Import[258];
   function compare$0(a, b){return caml_call2(compare_local, a, b);}
   var hash_fold_t$0 = Base_Import[203], func$0 = Base_Import[217];
   function hash$0(x){return caml_call1(func$0, x);}
   var symbol$0 = caml_lessthan;
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    function _r_(_s_){return _s_;}
    return caml_call3(Stdlib_Scanf[5], s, _e_, _r_);
   }
   var
    include$2 =
      caml_call1
       (Base_Int_string_conversions[2],
        [0,
         compare$0,
         compare_local,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$0,
         neg,
         module_name]),
    Hex = include$2[1],
    compare_local$0 = Base_Import[258];
   function compare$1(a, b){return caml_call2(compare_local$0, a, b);}
   var equal_local = Base_Import[272];
   function equal(a, b){return caml_call2(equal_local, a, b);}
   var hash_fold_t$1 = Base_Import[203], func$1 = Base_Import[217];
   function hash$1(x){return caml_call1(func$1, x);}
   function clz(_q_){return runtime.Base_int_math_int64_clz(_q_);}
   var
    include$3 =
      caml_call1
       (Base_Int_string_conversions[3],
        [0,
         compare$1,
         compare_local$0,
         equal,
         equal_local,
         hash_fold_t$1,
         hash$1,
         clz,
         lsr,
         land,
         to_int_exn,
         num_bits,
         one,
         zero]),
    Binary = include$3[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$4 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         caml_int64_add,
         caml_int64_sub,
         runtime.caml_int64_mul,
         runtime.caml_int64_div,
         caml_int64_neg,
         runtime.caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         runtime.caml_notequal,
         abs,
         caml_int64_neg,
         zero,
         of_int_exn,
         rem]),
    symbol$1 = include$4[1],
    symbol$2 = include$4[2],
    symbol$3 = include$4[3],
    round = include$4[4],
    round_towards_zero = include$4[5],
    round_down = include$4[6],
    round_up = include$4[7],
    round_nearest = include$4[8],
    include$5 = Base_Import[103],
    ascending = include$5[1],
    descending = include$5[2],
    max = include$5[3],
    min = include$5[4],
    _f_ = [0, symbol, bit_not, abs, zero, symbol$1, symbol$2, symbol$3];
   function _g_(_p_){return runtime.Base_int_math_int64_ctz(_p_);}
   function _h_(_o_){return runtime.Base_int_math_int64_clz(_o_);}
   var _i_ = caml_equal;
   function _j_(_n_, _m_){return caml_int64_compare(_n_, _m_);}
   var
    Base_Int64 =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       caml_equal,
       function(_l_, _k_){return caml_int64_compare(_l_, _k_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       _j_,
       _i_,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       symbol,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       _h_,
       _g_,
       _f_,
       symbol,
       bit_not,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       to_int,
       to_int32,
       to_nativeint,
       bswap16,
       bswap32,
       bswap48];
   runtime.caml_register_global(30, Base_Int64, "Base__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63_emul
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Float0, Base__Import, Base__Int64, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_int63_emul_ml = "src/int63_emul.ml",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_string = runtime.caml_int64_of_string,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    mask = runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
    module_name = "Base.Int63.Hex",
    module_name$0 = "Base.Int63",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Int64 = global_data.Base__Int64,
    Base_String = global_data.Base__String,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Popcount = global_data.Base__Popcount,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    include = Base_Import[103],
    max = include[3],
    min = include[4],
    compare_local = Base_Import[258],
    cst_0x = "0x",
    _l_ = [0, [7, 6, 0, 0, 0], "%Lx"],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _k_ = [0, cst_src_int63_emul_ml, 334, 2],
    _i_ =
      [0,
       [11,
        "Int63.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int63.of_float: argument (%f) is out of range or NaN"],
    _h_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ =
      [0,
       [11, "Int63.of_string: invalid input ", [3, 0, 0]],
       "Int63.of_string: invalid input %S"],
    _e_ = [0, cst_src_int63_emul_ml, 117, 20],
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _a_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0);
   function compare(a, b){return caml_call2(compare_local, a, b);}
   var
    globalize = Base_Import[286],
    hash_fold_t = Base_Import[203],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[188],
    include$0 = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t]),
    comparator = include$0[1];
   function wrap_exn(x){
    caml_call1(Base_Int_conversions[21], x);
    return caml_int64_mul(x, _a_);
   }
   function wrap_modulo(x){return caml_int64_mul(x, _c_);}
   function unwrap(x){return caml_int64_shift_right(x, 1);}
   function m(x){return caml_int64_and(x, mask);}
   function invariant(t){
    if(caml_equal(m(t), t)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   var
    symbol = caml_int64_add,
    symbol$0 = caml_int64_sub,
    symbol$1 = caml_int64_neg;
   function abs(x){return caml_call1(Stdlib_Int64[8], x);}
   var one = wrap_exn(_f_);
   function succ(a){return caml_int64_add(a, one);}
   function pred(a){return caml_int64_sub(a, one);}
   var min_value = m(Stdlib_Int64[10]), max_value = m(Stdlib_Int64[9]);
   function bit_not(x){return m(caml_call1(Stdlib_Int64[11], x));}
   var
    bit_and = caml_int64_and,
    bit_xor = runtime.caml_int64_xor,
    bit_or = runtime.caml_int64_or,
    shift_left = runtime.caml_int64_shift_left;
   function shift_right(x, i){return m(caml_int64_shift_right(x, i));}
   function shift_right_logical(x, i){
    return m(caml_int64_shift_right_unsigne(x, i));
   }
   var f = Base_Int_math[2][3];
   function pow(a, b){
    return caml_int64_mul
            (caml_call2
              (f, caml_int64_shift_right(a, 1), caml_int64_shift_right(b, 1)),
             _d_);
   }
   function symbol$2(a, b){
    return caml_int64_mul(a, caml_int64_shift_right(b, 1));
   }
   function symbol$3(a, b){return wrap_modulo(runtime.caml_int64_div(a, b));}
   var rem = runtime.caml_int64_mod;
   function popcount(x){return caml_call1(Base_Popcount[3], x);}
   function to_int64(t){return caml_int64_shift_right(t, 1);}
   function of_int64(t){
    return caml_call1(Base_Int_conversions[22], t)
            ? [0, caml_int64_mul(t, _b_)]
            : 0;
   }
   function of_int64_exn(t){return wrap_exn(t);}
   function of_int64_trunc(t){return wrap_modulo(t);}
   function t_of_sexp(x){return wrap_exn(caml_call1(Base_Import[166], x));}
   function sexp_of_t$0(x){
    return caml_call1(Base_Import[142], caml_int64_shift_right(x, 1));
   }
   function compare$0(x, y){return compare(x, y);}
   function compare_local$0(x, y){return caml_call2(compare_local, x, y);}
   var equal_local = caml_equal;
   function is_pow2(x){
    return caml_call1(Base_Int64[72], caml_int64_shift_right(x, 1));
   }
   function clz(x){return caml_call1(Base_Int64[73], x);}
   function ctz(x){
    return caml_call1(Base_Int64[74], caml_int64_shift_right(x, 1));
   }
   function floor_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[69], caml_int64_shift_right(x, 1)));
   }
   function ceil_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[69], caml_int64_shift_right(x, 1)));
   }
   function floor_log2(x){
    return caml_call1(Base_Int64[71], caml_int64_shift_right(x, 1));
   }
   function ceil_log2(x){
    return caml_call1(Base_Int64[70], caml_int64_shift_right(x, 1));
   }
   function hash(x){return caml_call1(Base_Import[85][105][28], x);}
   var hashable = [0, hash, compare$0, sexp_of_t$0];
   function invalid_str(x){return caml_call3(Base_Printf[6], _g_, x, 0);}
   function to_string(x){
    return caml_call1(Stdlib_Int64[14], caml_int64_shift_right(x, 1));
   }
   function of_string_raw(str){
    var len = caml_ml_string_length(str);
    a:
    if(0 < len){
     var switcher = caml_string_get(str, 0) - 43 | 0;
     if(2 >= switcher >>> 0)
      switch(switcher){
        case 0:
         var sign = 4003188, pos = 1; break a;
        case 1: break;
        default: var sign = 3901488, pos = 1; break a;
      }
     var sign = 4003188, pos = 0;
    }
    else
     var sign = 4003188, pos = 0;
    if(caml_call2(Base_Import[91], pos, 2) < len)
     var
      c1 = caml_string_get(str, pos),
      c2 = caml_string_get(str, caml_call2(Base_Import[91], pos, 1)),
      match = 48 === c1 ? 9 < c2 - 48 >>> 0 ? [0, , 0] : [0, , 1] : [0, , 1];
    else
     var match = [0, , 1];
    var signedness = match[2];
    if(signedness) return of_int64_exn(caml_int64_of_string(str));
    if(4003188 <= sign)
     var pos_str = str;
    else
     var
      _E_ = caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
      pos_str = caml_call3(Base_String[3], str, 1, _E_);
    var int64 = caml_int64_of_string(pos_str);
    if(caml_lessthan(int64, _h_)) invalid_str(str);
    var int63 = wrap_modulo(int64);
    return 4003188 <= sign ? int63 : caml_int64_neg(int63);
   }
   function of_string(str){
    try{var _C_ = of_string_raw(str); return _C_;}
    catch(_D_){return invalid_str(str);}
   }
   function of_string_opt(str){
    try{var t = of_string_raw(str);}catch(_B_){return 0;}
    return [0, t];
   }
   function bswap16(t){
    return wrap_modulo
            (caml_call1(Base_Int64[86], caml_int64_shift_right(t, 1)));
   }
   function bswap32(t){
    return wrap_modulo
            (caml_call1(Base_Int64[87], caml_int64_shift_right(t, 1)));
   }
   function bswap48(t){
    return wrap_modulo
            (caml_call1(Base_Int64[88], caml_int64_shift_right(t, 1)));
   }
   var
    float_lower_bound = caml_call1(Base_Float0[26], 63),
    float_upper_bound = caml_call1(Base_Float0[24], 63),
    minus_one = wrap_exn(Stdlib_Int64[3]),
    one$0 = wrap_exn(Stdlib_Int64[2]),
    zero = wrap_exn(Stdlib_Int64[1]),
    num_bits = 63;
   function to_float(x){
    return runtime.caml_int64_to_float(caml_int64_shift_right(x, 1));
   }
   function of_float_unchecked(x){return wrap_modulo(caml_int64_of_float(x));}
   function of_float(t){
    if(float_lower_bound <= t && t <= float_upper_bound)
     return wrap_modulo(caml_int64_of_float(t));
    var _A_ = caml_call1(Base_Float0[29], t);
    return caml_call3(Base_Printf[7], _i_, _A_, 0);
   }
   var
    _j_ = caml_call1(Base_Comparable[14], [0, compare$0, sexp_of_t$0, zero]),
    is_positive = _j_[1],
    is_non_negative = _j_[2],
    is_negative = _j_[3],
    is_non_positive = _j_[4],
    sign = _j_[5];
   function between(t, low, high){
    var
     _y_ = caml_lessequal(low, t),
     _z_ = _y_ ? caml_lessequal(t, high) : _y_;
    return _z_;
   }
   function clamp_unchecked(t, min$0, max$0){
    var _x_ = caml_call2(min, t, max$0);
    return caml_call1(caml_call1(max, min$0), _x_);
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _u_ = [0, [0, cst_max, sexp_of_t$0(max)], 0],
     _v_ = [0, [0, cst_min, sexp_of_t$0(min)], _u_],
     _w_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _v_);
    return caml_call1(Base_Or_error[39], _w_);
   }
   function symbol$4(b, e){return pow(b, e);}
   function incr(r){r[1] = caml_int64_add(r[1], one$0); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one$0); return 0;}
   function of_int(x){
    return wrap_exn(caml_call1(Base_Int_conversions[4], x));
   }
   function of_int_exn(x){return of_int(x);}
   function to_int(x){
    return caml_call1(Base_Int_conversions[12], caml_int64_shift_right(x, 1));
   }
   function to_int_exn(x){
    return caml_call1(Base_Int_conversions[13], caml_int64_shift_right(x, 1));
   }
   function to_int_trunc(x){
    return caml_call1(Base_Int_conversions[14], caml_int64_shift_right(x, 1));
   }
   function of_int32(x){
    return wrap_exn(caml_call1(Base_Int_conversions[9], x));
   }
   function of_int32_exn(x){return of_int32(x);}
   function to_int32(x){
    return caml_call1(Base_Int_conversions[15], caml_int64_shift_right(x, 1));
   }
   function to_int32_exn(x){
    return caml_call1(Base_Int_conversions[16], caml_int64_shift_right(x, 1));
   }
   function to_int32_trunc(x){
    return caml_call1(Base_Int_conversions[17], caml_int64_shift_right(x, 1));
   }
   function of_nativeint(x){
    return of_int64(caml_call1(Base_Int_conversions[29], x));
   }
   function of_nativeint_exn(x){
    return wrap_exn(caml_call1(Base_Int_conversions[29], x));
   }
   function of_nativeint_trunc(x){
    return of_int64_trunc(caml_call1(Base_Int_conversions[29], x));
   }
   function to_nativeint(x){
    return caml_call1(Base_Int_conversions[18], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_exn(x){
    return caml_call1(Base_Int_conversions[19], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_trunc(x){
    return caml_call1(Base_Int_conversions[20], caml_int64_shift_right(x, 1));
   }
   var
    include$1 = caml_call1(Base_Int_string_conversions[1], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$1 = include$1[2];
   function compare$1(a, b){return compare_local$0(a, b);}
   function hash$0(x){return hash(x);}
   var symbol$5 = caml_lessthan;
   function to_string$0(i){
    return caml_call2
            (Base_Printf[2], _l_, caml_int64_shift_right_unsigne(i, 1));
   }
   function of_string$0(s){
    return of_string(caml_call2(Base_Import[112], cst_0x, s));
   }
   var
    include$2 =
      caml_call1
       (Base_Int_string_conversions[2],
        [0,
         compare$1,
         compare_local$0,
         hash_fold_t,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$5,
         symbol$1,
         module_name]),
    Hex = include$2[1];
   function to_string$1(x){return to_string(x);}
   var
    pp =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string$1])[1],
    symbol$6 = caml_notequal,
    symbol$7 = caml_lessthan,
    symbol$8 = caml_greaterthan,
    symbol$9 = caml_equal,
    symbol$10 = caml_lessequal,
    symbol$11 = caml_greaterequal,
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol,
         symbol$0,
         symbol$2,
         symbol$3,
         symbol$1,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$1,
         zero,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8];
   function compare$2(a, b){return compare_local$0(a, b);}
   var equal = caml_equal;
   function hash$1(x){return hash(x);}
   var
    include$4 =
      caml_call1
       (Base_Int_string_conversions[3],
        [0,
         compare$2,
         compare_local$0,
         equal,
         equal_local,
         hash_fold_t,
         hash$1,
         clz,
         shift_right_logical,
         bit_and,
         to_int_exn,
         num_bits,
         one$0,
         zero]),
    Binary = include$4[1],
    Repr = [0],
    include$5 = Base_Import[103],
    ascending = include$5[1],
    descending = include$5[2],
    max$0 = include$5[3],
    min$0 = include$5[4],
    repr = 1,
    _m_ = [0, wrap_exn, unwrap],
    _n_ =
      [0,
       symbol,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol$1,
       symbol$4,
       symbol$11,
       symbol$10,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       abs,
       symbol$1,
       zero,
       symbol$12,
       symbol$13,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical],
    _o_ = caml_equal;
   function _p_(_t_, _s_){return caml_int64_compare(_t_, _s_);}
   var
    Base_Int63_emul =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       to_string,
       caml_greaterequal,
       caml_lessequal,
       caml_equal,
       caml_greaterthan,
       caml_lessthan,
       caml_notequal,
       caml_equal,
       function(_r_, _q_){return caml_int64_compare(_r_, _q_);},
       min$0,
       max$0,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       _p_,
       _o_,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       zero,
       one$0,
       minus_one,
       symbol,
       symbol$0,
       symbol$2,
       symbol$4,
       symbol$1,
       symbol$1,
       symbol$13,
       symbol$12,
       symbol$3,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       clz,
       ctz,
       _n_,
       of_int,
       to_int,
       to_int_trunc,
       of_int32,
       to_int32,
       to_int32_trunc,
       of_int64,
       of_int64_trunc,
       of_nativeint,
       to_nativeint,
       of_nativeint_trunc,
       to_nativeint_trunc,
       bswap16,
       bswap32,
       bswap48,
       _m_,
       Repr,
       repr];
   runtime.caml_register_global(34, Base_Int63_emul, "Base__Int63_emul");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int32
//# unitInfo: Requires: Base__Bool0, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int32, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_lx = "%lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int32.Hex",
    module_name$0 = "Base.Int32",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Int_math = global_data.Base__Int_math,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    globalize = Base_Import[285],
    hash_fold_t = Base_Import[204],
    func = Base_Import[218],
    _e_ = [0, [5, 6, 0, 0, 0], cst_lx],
    _d_ = [0, [5, 6, 0, 0, 0], cst_lx],
    cst_Int32_ceil_log2_got_invali = "[Int32.ceil_log2] got invalid input",
    cst_Int32_floor_log2_got_inval = "[Int32.floor_log2] got invalid input",
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, "src/int32.ml", 103, 4],
    _a_ =
      [0,
       [11,
        "Int32.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int32.of_float: argument (%f) is out of range or NaN"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[165],
    sexp_of_t = Base_Import[141],
    t_sexp_grammar = Base_Import[187],
    hashable = [0, hash, Stdlib_Int32[15], sexp_of_t];
   function ascending(x, y){return caml_call2(Stdlib_Int32[15], x, y);}
   var
    to_string = Stdlib_Int32[14],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib_Int32[13],
    include = caml_call1(Base_Comparator[7], [0, ascending, sexp_of_t]),
    comparator = include[1],
    float_lower_bound = caml_call1(Base_Float0[26], 32),
    float_upper_bound = caml_call1(Base_Float0[24], 32),
    float_of_bits = runtime.caml_int32_float_of_bits,
    bits_of_float = runtime.caml_int32_bits_of_float,
    num_bits = 32;
   function shift_right_logical(_X_, _W_){return _X_ >>> _W_ | 0;}
   function shift_right(_V_, _U_){return _V_ >> _U_;}
   function shift_left(_T_, _S_){return _T_ << _S_;}
   var bit_not = Stdlib_Int32[11];
   function bit_xor(_R_, _Q_){return _R_ ^ _Q_;}
   function bit_or(_P_, _O_){return _P_ | _O_;}
   function bit_and(_N_, _M_){return _N_ & _M_;}
   var
    min_value = Stdlib_Int32[10],
    max_value = Stdlib_Int32[9],
    abs = Stdlib_Int32[8],
    pred = Stdlib_Int32[7],
    succ = Stdlib_Int32[6],
    rem = runtime.caml_mod;
   function symbol(_L_){return - _L_ | 0;}
   var
    minus_one = Stdlib_Int32[3],
    one = Stdlib_Int32[2],
    zero = Stdlib_Int32[1],
    compare_local = runtime.caml_compare;
   function to_float(_K_){return _K_;}
   function of_float_unchecked(_J_){return _J_ | 0;}
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound) return f | 0;
    var _I_ = caml_call1(Base_Float0[29], f);
    return caml_call3(Base_Printf[7], _a_, _I_, 0);
   }
   var
    include$0 =
      caml_call1(Base_Comparable[14], [0, ascending, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    symbol$0 = caml_greaterequal,
    symbol$1 = caml_lessequal,
    symbol$2 = caml_equal,
    symbol$3 = caml_greaterthan,
    symbol$4 = runtime.caml_lessthan,
    symbol$5 = runtime.caml_notequal;
   function descending(x, y){return ascending(y, x);}
   function min(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   function max(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   var equal = caml_equal, equal_local = caml_equal;
   function between(t, low, high){
    var _H_ = caml_lessequal(low, t);
    return _H_ ? caml_lessequal(t, high) : _H_;
   }
   function clamp_unchecked(t, min$0, max$0){return max(min$0, min(t, max$0));
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _E_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _F_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _E_],
     _G_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _F_);
    return caml_call1(Base_Or_error[39], _G_);
   }
   function invariant(param){return 0;}
   var symbol$6 = runtime.caml_div, symbol$7 = runtime.caml_mul;
   function symbol$8(_D_, _C_){return _D_ - _C_ | 0;}
   function symbol$9(_B_, _A_){return _B_ + _A_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_int32(t){return t;}
   function to_int32(t){return t;}
   var
    popcount = Base_Popcount[2],
    of_int = Base_Int_conversions[1],
    of_int_exn = Base_Int_conversions[2],
    of_int_trunc = Base_Int_conversions[3],
    to_int = Base_Int_conversions[6],
    to_int_exn = Base_Int_conversions[7],
    to_int_trunc = Base_Int_conversions[8],
    of_int64 = Base_Int_conversions[15],
    of_int64_exn = Base_Int_conversions[16],
    of_int64_trunc = Base_Int_conversions[17],
    to_int64 = Base_Int_conversions[9],
    of_nativeint = Base_Int_conversions[26],
    of_nativeint_exn = Base_Int_conversions[27],
    of_nativeint_trunc = Base_Int_conversions[28],
    to_nativeint = Base_Int_conversions[10];
   function pow(b, e){
    var _y_ = caml_call1(to_int_exn, e), _z_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _z_, _y_));
   }
   function symbol$10(b, e){return pow(b, e);}
   function bswap16(x){return caml_int32_bswap(x) >>> 16 | 0;}
   var raise_s = Base_Error[32];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function lsr(_x_, _w_){return _x_ >>> _w_ | 0;}
   function land(_v_, _u_){return _v_ & _u_;}
   function ceil_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int32[7], x),
     x$1 = x$0 | x$0 >>> 1 | 0,
     x$2 = x$1 | x$1 >>> 2 | 0,
     x$3 = x$2 | x$2 >>> 4 | 0,
     x$4 = x$3 | x$3 >>> 8 | 0,
     x$5 = x$4 | x$4 >>> 16 | 0;
    return caml_call1(Stdlib_Int32[6], x$5);
   }
   function floor_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = x | x >>> 1 | 0,
     x$1 = x$0 | x$0 >>> 2 | 0,
     x$2 = x$1 | x$1 >>> 4 | 0,
     x$3 = x$2 | x$2 >>> 8 | 0,
     x$4 = x$3 | x$3 >>> 16 | 0;
    return x$4 - (x$4 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var _s_ = Stdlib_Int32[1], _t_ = x & caml_call1(Stdlib_Int32[7], x);
    return caml_call2(Base_Import[102][4], _t_, _s_);
   }
   function floor_log2(i){
    if(caml_call2(Base_Import[102][2], i, Stdlib_Int32[1])){
     var _p_ = [0, [0, cst, caml_call1(Base_Import[141], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int32_floor_log2_got_inval, _p_));
    }
    var
     _q_ = runtime.Base_int_math_int32_clz(i),
     _r_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _r_, _q_);
   }
   function ceil_log2(i){
    if(caml_call2(Base_Import[102][2], i, Stdlib_Int32[1])){
     var _n_ = [0, [0, cst$0, caml_call1(Base_Import[141], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int32_ceil_log2_got_invali, _n_));
    }
    if(caml_call2(Stdlib_Int32[17], i, Stdlib_Int32[2])) return 0;
    var _o_ = runtime.Base_int_math_int32_clz(caml_call1(Stdlib_Int32[7], i));
    return caml_call2(Base_Import[93], num_bits, _o_);
   }
   var
    include$1 = caml_call1(Base_Int_string_conversions[1], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare_local$0 = Base_Import[257];
   function compare(a, b){return caml_call2(compare_local$0, a, b);}
   var hash_fold_t$0 = Base_Import[204], func$0 = Base_Import[218];
   function hash$0(x){return caml_call1(func$0, x);}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    function _l_(_m_){return _m_;}
    return caml_call3(Stdlib_Scanf[5], s, _e_, _l_);
   }
   var
    include$2 =
      caml_call1
       (Base_Int_string_conversions[2],
        [0,
         compare,
         compare_local$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$4,
         symbol,
         module_name]),
    Hex = include$2[1],
    compare_local$1 = Base_Import[257];
   function compare$0(a, b){return caml_call2(compare_local$1, a, b);}
   var equal_local$0 = Base_Import[271];
   function equal$0(a, b){return caml_call2(equal_local$0, a, b);}
   var hash_fold_t$1 = Base_Import[204], func$1 = Base_Import[218];
   function hash$1(x){return caml_call1(func$1, x);}
   function clz(_k_){return runtime.Base_int_math_int32_clz(_k_);}
   var
    include$3 =
      caml_call1
       (Base_Int_string_conversions[3],
        [0,
         compare$0,
         compare_local$1,
         equal$0,
         equal_local$0,
         hash_fold_t$1,
         hash$1,
         clz,
         lsr,
         land,
         to_int_exn,
         num_bits,
         one,
         zero]),
    Binary = include$3[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$4 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         symbol$5,
         abs,
         symbol,
         zero,
         of_int_exn,
         rem]),
    symbol$11 = include$4[1],
    symbol$12 = include$4[2],
    symbol$13 = include$4[3],
    round = include$4[4],
    round_towards_zero = include$4[5],
    round_down = include$4[6],
    round_up = include$4[7],
    round_nearest = include$4[8],
    _f_ = caml_int32_bswap,
    _g_ =
      [0,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       symbol,
       symbol$10,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       abs,
       symbol,
       zero,
       symbol$11,
       symbol$12,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical];
   function _h_(_j_){return runtime.Base_int_math_int32_ctz(_j_);}
   var
    Base_Int32 =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       ascending,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       compare_local,
       equal_local,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       zero,
       one,
       minus_one,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$10,
       symbol,
       symbol,
       symbol$12,
       symbol$11,
       symbol$6,
       rem,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_i_){return runtime.Base_int_math_int32_clz(_i_);},
       _h_,
       _g_,
       of_int,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       of_int_trunc,
       to_int_trunc,
       of_nativeint_trunc,
       of_int64_trunc,
       bits_of_float,
       float_of_bits,
       bswap16,
       _f_];
   runtime.caml_register_global(30, Base_Int32, "Base__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63
//# unitInfo: Requires: Base__Bool, Base__Error, Base__Import, Base__Int, Base__Int63_emul, Base__Int64, Base__Random, Base__Sexp, Base__Sys0, Base__Word_size
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_product$1 = "product",
    cst_t$3 = "t",
    cst_u$3 = "u",
    caml_div = runtime.caml_div,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Word_size = global_data.Base__Word_size,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Int64 = global_data.Base__Int64,
    Base_Error = global_data.Base__Error,
    Base_Int63_emul = global_data.Base__Int63_emul,
    Base_Sys0 = global_data.Base__Sys0,
    Assert_failure = global_data.Assert_failure,
    raise_s = Base_Error[32],
    include = caml_call1(caml_call1(Base_Sys0[19], [0]), [0]),
    t_sexp_grammar = Base_Int[2],
    of_float = Base_Int[3],
    to_float = Base_Int[4],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash_fold_t = Base_Int[7],
    hash = Base_Int[8],
    t_of_sexp = Base_Int[9],
    sexp_of_t = Base_Int[10],
    of_string = Base_Int[11],
    to_string = Base_Int[12],
    equal = Base_Int[13],
    compare = Base_Int[14],
    min = Base_Int[15],
    max = Base_Int[16],
    ascending = Base_Int[17],
    descending = Base_Int[18],
    between = Base_Int[19],
    clamp_exn = Base_Int[20],
    clamp = Base_Int[21],
    comparator = Base_Int[22],
    pp = Base_Int[23],
    hashable = Base_Int[24],
    is_positive = Base_Int[25],
    is_non_negative = Base_Int[26],
    is_negative = Base_Int[27],
    is_non_positive = Base_Int[28],
    sign = Base_Int[29],
    compare_local = Base_Int[30],
    equal_local = Base_Int[31],
    invariant = Base_Int[32],
    Hex = Base_Int[33],
    Binary = Base_Int[34],
    of_string_opt = Base_Int[35],
    to_string_hum = Base_Int[36],
    one = Base_Int[37],
    minus_one = Base_Int[38],
    rem = Base_Int[39],
    round = Base_Int[40],
    round_towards_zero = Base_Int[41],
    round_down = Base_Int[42],
    round_up = Base_Int[43],
    round_nearest = Base_Int[44],
    succ = Base_Int[45],
    pred = Base_Int[46],
    pow = Base_Int[47],
    bit_and = Base_Int[48],
    bit_or = Base_Int[49],
    bit_xor = Base_Int[50],
    bit_not = Base_Int[51],
    popcount = Base_Int[52],
    shift_left = Base_Int[53],
    shift_right = Base_Int[54],
    decr = Base_Int[55],
    incr = Base_Int[56],
    of_int32_exn = Base_Int[57],
    to_int32_exn = Base_Int[58],
    of_int64_exn = Base_Int[59],
    to_int64 = Base_Int[60],
    of_nativeint_exn = Base_Int[61],
    to_nativeint_exn = Base_Int[62],
    of_float_unchecked = Base_Int[63],
    num_bits = Base_Int[64],
    max_value = Base_Int[65],
    min_value = Base_Int[66],
    shift_right_logical = Base_Int[67],
    ceil_pow2 = Base_Int[68],
    floor_pow2 = Base_Int[69],
    ceil_log2 = Base_Int[70],
    is_pow2 = Base_Int[72],
    clz = Base_Int[73],
    ctz = Base_Int[74],
    O = Base_Int[75],
    symbol = Base_Int[76],
    lnot = Base_Int[77],
    abs = Base_Int[78],
    zero = Base_Int[79],
    symbol$0 = Base_Int[80],
    symbol$1 = Base_Int[81],
    symbol$2 = Base_Int[82],
    of_int = Base_Int[84],
    to_int32 = Base_Int[87],
    of_int64 = Base_Int[88],
    of_nativeint = Base_Int[89],
    _b_ = Base_Int[90],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_neg_overflow = "neg overflow",
    cst_abs_overflow = "abs overflow",
    cst_product$0 = cst_product$1,
    cst_u$2 = cst_u$3,
    cst_t$2 = cst_t$3,
    cst_overflow$2 = "( / ) overflow",
    cst_product = cst_product$1,
    cst_u$1 = cst_u$3,
    cst_t$1 = cst_t$3,
    cst_overflow$1 = "( * ) overflow",
    cst_diff = "diff",
    cst_u$0 = cst_u$3,
    cst_t$0 = cst_t$3,
    cst_overflow$0 = "( - ) overflow",
    cst_sum = "sum",
    cst_u = cst_u$3,
    cst_t = cst_t$3,
    cst_overflow = "( + ) overflow",
    _c_ = [0, "src/int63.ml", 110, 9],
    _a_ = include[1];
   function to_int(x){return [0, x];}
   function to_int_trunc(x){return x;}
   function to_nativeint_trunc(x){return caml_call1(_b_, x);}
   function to_nativeint(x){return [0, caml_call1(_b_, x)];}
   var repr = 0;
   function bswap32(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[87], caml_int64_of_int32(t)));
   }
   function bswap48(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[88], caml_int64_of_int32(t)));
   }
   if(_a_)
    var
     include$0 =
       [0,
        Base_Int63_emul[2],
        Base_Int63_emul[3],
        Base_Int63_emul[4],
        Base_Int63_emul[5],
        Base_Int63_emul[6],
        Base_Int63_emul[7],
        Base_Int63_emul[8],
        Base_Int63_emul[9],
        Base_Int63_emul[10],
        Base_Int63_emul[11],
        Base_Int63_emul[12],
        Base_Int63_emul[13],
        Base_Int63_emul[14],
        Base_Int63_emul[15],
        Base_Int63_emul[16],
        Base_Int63_emul[17],
        Base_Int63_emul[18],
        Base_Int63_emul[19],
        Base_Int63_emul[20],
        Base_Int63_emul[21],
        Base_Int63_emul[22],
        Base_Int63_emul[23],
        Base_Int63_emul[24],
        Base_Int63_emul[25],
        Base_Int63_emul[26],
        Base_Int63_emul[27],
        Base_Int63_emul[28],
        Base_Int63_emul[29],
        Base_Int63_emul[30],
        Base_Int63_emul[31],
        Base_Int63_emul[32],
        Base_Int63_emul[33],
        Base_Int63_emul[34],
        Base_Int63_emul[35],
        Base_Int63_emul[36],
        Base_Int63_emul[37],
        Base_Int63_emul[38],
        Base_Int63_emul[39],
        Base_Int63_emul[40],
        Base_Int63_emul[41],
        Base_Int63_emul[42],
        Base_Int63_emul[43],
        Base_Int63_emul[44],
        Base_Int63_emul[45],
        Base_Int63_emul[46],
        Base_Int63_emul[47],
        Base_Int63_emul[48],
        Base_Int63_emul[49],
        Base_Int63_emul[50],
        Base_Int63_emul[51],
        Base_Int63_emul[52],
        Base_Int63_emul[53],
        Base_Int63_emul[54],
        Base_Int63_emul[55],
        Base_Int63_emul[56],
        Base_Int63_emul[57],
        Base_Int63_emul[58],
        Base_Int63_emul[59],
        Base_Int63_emul[60],
        Base_Int63_emul[61],
        Base_Int63_emul[62],
        Base_Int63_emul[63],
        Base_Int63_emul[64],
        Base_Int63_emul[65],
        Base_Int63_emul[66],
        Base_Int63_emul[67],
        Base_Int63_emul[68],
        Base_Int63_emul[69],
        Base_Int63_emul[70],
        Base_Int63_emul[71],
        Base_Int63_emul[72],
        Base_Int63_emul[73],
        Base_Int63_emul[74],
        Base_Int63_emul[75],
        Base_Int63_emul[76],
        Base_Int63_emul[77],
        Base_Int63_emul[78],
        Base_Int63_emul[79],
        Base_Int63_emul[80],
        Base_Int63_emul[81],
        Base_Int63_emul[82],
        Base_Int63_emul[83],
        Base_Int63_emul[84],
        Base_Int63_emul[85],
        Base_Int63_emul[86],
        Base_Int63_emul[88],
        Base_Int63_emul[89],
        Base_Int63_emul[90],
        Base_Int63_emul[91],
        Base_Int63_emul[92],
        Base_Int63_emul[93],
        Base_Int63_emul[94],
        Base_Int63_emul[95],
        ,
        Base_Int63_emul[97],
        Base_Int63_emul[98],
        Base_Int63_emul[99],
        Base_Int63_emul[100],
        Base_Int63_emul[101],
        Base_Int63_emul[102],
        Base_Int63_emul[103],
        Base_Int63_emul[104],
        Base_Int63_emul[105],
        Base_Int63_emul[106],
        Base_Int63_emul[107],
        Base_Int63_emul[108],
        Base_Int63_emul[109],
        Base_Int63_emul[110],
        Base_Int63_emul[111],
        Base_Int63_emul[112],
        Base_Int63_emul[87],
        Base_Int63_emul[118],
        Base_Int63_emul[113],
        Base_Int63_emul[114],
        Base_Int63_emul[115]];
   else
    var
     _d_ = runtime.caml_bswap16,
     _e_ = function(_bp_){return _bp_;},
     _f_ = caml_int64_to_int32,
     _g_ = function(_bo_){return _bo_;},
     _h_ = function(_bn_, _bm_){return _bn_ >>> _bm_ | 0;},
     _i_ = function(_bl_, _bk_){return _bl_ >> _bk_;},
     _j_ = function(_bj_, _bi_){return _bj_ << _bi_;},
     _k_ = O[2],
     _l_ = function(_bh_, _bg_){return _bh_ ^ _bg_;},
     _m_ = function(_bf_, _be_){return _bf_ | _be_;},
     _n_ = function(_bd_, _bc_){return _bd_ & _bc_;},
     _o_ = O[7],
     _p_ = O[6],
     _q_ = O[5],
     _r_ = O[4],
     _s_ = function(_bb_){return - _bb_ | 0;},
     _t_ = O[3],
     _u_ = function(_ba_, _a$_){return _ba_ !== _a$_ ? 1 : 0;},
     _v_ = function(_a__, _a9_){return _a__ < _a9_ ? 1 : 0;},
     _w_ = function(_a8_, _a7_){return _a7_ < _a8_ ? 1 : 0;},
     _x_ = function(_a6_, _a5_){return _a6_ === _a5_ ? 1 : 0;},
     _y_ = function(_a4_, _a3_){return _a4_ <= _a3_ ? 1 : 0;},
     _z_ = function(_a2_, _a1_){return _a1_ <= _a2_ ? 1 : 0;},
     _A_ = O[1],
     _B_ = function(_a0_){return - _a0_ | 0;},
     _C_ = caml_div,
     _D_ = caml_mul,
     _E_ = function(_aZ_, _aY_){return _aZ_ - _aY_ | 0;},
     _F_ =
       [0,
        function(_aX_, _aW_){return _aX_ + _aW_ | 0;},
        _E_,
        _D_,
        _C_,
        _B_,
        _A_,
        _z_,
        _y_,
        _x_,
        _w_,
        _v_,
        _u_,
        _t_,
        _s_,
        _r_,
        _q_,
        _p_,
        _o_,
        _n_,
        _m_,
        _l_,
        _k_,
        _j_,
        _i_,
        _h_],
     _G_ = function(_aV_, _aU_){return _aV_ >>> _aU_ | 0;},
     _H_ = function(_aT_, _aS_){return _aT_ >> _aS_;},
     _I_ = function(_aR_, _aQ_){return _aR_ << _aQ_;},
     _J_ = function(_aP_, _aO_){return _aP_ ^ _aO_;},
     _K_ = function(_aN_, _aM_){return _aN_ | _aM_;},
     _L_ = function(_aL_, _aK_){return _aL_ & _aK_;},
     _M_ = caml_div,
     _N_ = function(_aJ_){return - _aJ_ | 0;},
     _O_ = function(_aI_){return - _aI_ | 0;},
     _P_ = caml_mul,
     _Q_ = function(_aH_, _aG_){return _aH_ - _aG_ | 0;},
     _R_ = function(_aF_, _aE_){return _aF_ + _aE_ | 0;},
     _S_ = function(_aD_, _aC_){return _aD_ !== _aC_ ? 1 : 0;},
     _T_ = function(_aB_, _aA_){return _aB_ < _aA_ ? 1 : 0;},
     _U_ = function(_az_, _ay_){return _ay_ < _az_ ? 1 : 0;},
     _V_ = function(_ax_, _aw_){return _ax_ === _aw_ ? 1 : 0;},
     _W_ = function(_av_, _au_){return _av_ <= _au_ ? 1 : 0;},
     include$0 =
       [0,
        t_sexp_grammar,
        of_float,
        to_float,
        of_int_exn,
        to_int_exn,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        function(_at_, _as_){return _as_ <= _at_ ? 1 : 0;},
        _W_,
        _V_,
        _U_,
        _T_,
        _S_,
        equal,
        compare,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        is_positive,
        is_non_negative,
        is_negative,
        is_non_positive,
        sign,
        compare_local,
        equal_local,
        invariant,
        Hex,
        Binary,
        of_string_opt,
        to_string_hum,
        zero,
        one,
        minus_one,
        _R_,
        _Q_,
        _P_,
        symbol,
        _O_,
        _N_,
        symbol$1,
        symbol$0,
        _M_,
        rem,
        symbol$2,
        _L_,
        _K_,
        _J_,
        lnot,
        _I_,
        _H_,
        round,
        round_towards_zero,
        round_down,
        round_up,
        round_nearest,
        abs,
        succ,
        pred,
        pow,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        popcount,
        shift_left,
        shift_right,
        decr,
        incr,
        of_int32_exn,
        to_int32_exn,
        of_int64_exn,
        to_int64,
        of_nativeint_exn,
        to_nativeint_exn,
        num_bits,
        max_value,
        min_value,
        _G_,
        shift_right_logical,
        ceil_pow2,
        floor_pow2,
        ceil_log2,
        ,
        is_pow2,
        clz,
        ctz,
        _F_,
        of_int,
        to_int,
        to_int_trunc,
        of_int32_exn,
        to_int32,
        _g_,
        of_int64,
        _f_,
        of_nativeint,
        to_nativeint,
        _e_,
        to_nativeint_trunc,
        of_float_unchecked,
        repr,
        _d_,
        bswap32,
        bswap48];
   var
    t_sexp_grammar$0 = include$0[1],
    of_float$0 = include$0[2],
    to_float$0 = include$0[3],
    of_int_exn$0 = include$0[4],
    to_int_exn$0 = include$0[5],
    hash_fold_t$0 = include$0[6],
    hash$0 = include$0[7],
    t_of_sexp$0 = include$0[8],
    sexp_of_t$0 = include$0[9],
    of_string$0 = include$0[10],
    to_string$0 = include$0[11],
    symbol$3 = include$0[12],
    symbol$4 = include$0[13],
    symbol$5 = include$0[14],
    symbol$6 = include$0[15],
    symbol$7 = include$0[16],
    symbol$8 = include$0[17],
    equal$0 = include$0[18],
    compare$0 = include$0[19],
    min$0 = include$0[20],
    max$0 = include$0[21],
    ascending$0 = include$0[22],
    descending$0 = include$0[23],
    between$0 = include$0[24],
    clamp_exn$0 = include$0[25],
    clamp$0 = include$0[26],
    comparator$0 = include$0[27],
    pp$0 = include$0[28],
    hashable$0 = include$0[29],
    is_positive$0 = include$0[30],
    is_non_negative$0 = include$0[31],
    is_negative$0 = include$0[32],
    is_non_positive$0 = include$0[33],
    sign$0 = include$0[34],
    compare_local$0 = include$0[35],
    equal_local$0 = include$0[36],
    invariant$0 = include$0[37],
    Hex$0 = include$0[38],
    Binary$0 = include$0[39],
    of_string_opt$0 = include$0[40],
    to_string_hum$0 = include$0[41],
    zero$0 = include$0[42],
    one$0 = include$0[43],
    minus_one$0 = include$0[44],
    symbol$9 = include$0[45],
    symbol$10 = include$0[46],
    symbol$11 = include$0[47],
    symbol$12 = include$0[48],
    neg = include$0[49],
    symbol$13 = include$0[50],
    symbol$14 = include$0[51],
    symbol$15 = include$0[52],
    symbol$16 = include$0[53],
    rem$0 = include$0[54],
    symbol$17 = include$0[55],
    land = include$0[56],
    lor = include$0[57],
    lxor = include$0[58],
    lnot$0 = include$0[59],
    lsl = include$0[60],
    asr = include$0[61],
    round$0 = include$0[62],
    round_towards_zero$0 = include$0[63],
    round_down$0 = include$0[64],
    round_up$0 = include$0[65],
    round_nearest$0 = include$0[66],
    abs$0 = include$0[67],
    succ$0 = include$0[68],
    pred$0 = include$0[69],
    pow$0 = include$0[70],
    bit_and$0 = include$0[71],
    bit_or$0 = include$0[72],
    bit_xor$0 = include$0[73],
    bit_not$0 = include$0[74],
    popcount$0 = include$0[75],
    shift_left$0 = include$0[76],
    shift_right$0 = include$0[77],
    decr$0 = include$0[78],
    incr$0 = include$0[79],
    of_int32_exn$0 = include$0[80],
    to_int32_exn$0 = include$0[81],
    of_int64_exn$0 = include$0[82],
    to_int64$0 = include$0[83],
    of_nativeint_exn$0 = include$0[84],
    to_nativeint_exn$0 = include$0[85],
    num_bits$0 = include$0[86],
    max_value$0 = include$0[87],
    min_value$0 = include$0[88],
    lsr = include$0[89],
    shift_right_logical$0 = include$0[90],
    ceil_pow2$0 = include$0[91],
    floor_pow2$0 = include$0[92],
    ceil_log2$0 = include$0[93],
    is_pow2$0 = include$0[95],
    clz$0 = include$0[96],
    ctz$0 = include$0[97],
    O$0 = include$0[98],
    of_int$0 = include$0[99],
    to_int$0 = include$0[100],
    to_int_trunc$0 = include$0[101],
    of_int32 = include$0[102],
    to_int32$0 = include$0[103],
    to_int32_trunc = include$0[104],
    of_int64$0 = include$0[105],
    of_int64_trunc = include$0[106],
    of_nativeint$0 = include$0[107],
    to_nativeint$0 = include$0[108],
    of_nativeint_trunc = include$0[109],
    to_nativeint_trunc$0 = include$0[110],
    of_float_unchecked$0 = include$0[111],
    repr$0 = include$0[112],
    bswap16 = include$0[113],
    bswap32$0 = include$0[114],
    bswap48$0 = include$0[115];
   function symbol$18(t, u){
    var
     sum = caml_call2(symbol$9, t, u),
     _ao_ = caml_call2(bit_xor$0, t, caml_call1(bit_not$0, sum));
    if
     (caml_call2
       (symbol$7,
        caml_call2(bit_or$0, caml_call2(bit_xor$0, t, u), _ao_),
        zero$0))
     return sum;
    var
     _ap_ = [0, [0, cst_sum, caml_call1(sexp_of_t$0, sum)], 0],
     _aq_ = [0, [0, cst_u, caml_call1(sexp_of_t$0, u)], _ap_],
     _ar_ = [0, [0, cst_t, caml_call1(sexp_of_t$0, t)], _aq_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[10], cst_overflow, _ar_));
   }
   function symbol$19(t, u){
    var
     diff = caml_call2(symbol$10, t, u),
     pos_diff = caml_call2(symbol$6, t, u);
    if(caml_call2(symbol$8, t, u)){
     var _ak_ = caml_call1(is_positive$0, diff);
     if(caml_call2(Base_Bool[15], pos_diff, _ak_)){
      var
       _al_ = [0, [0, cst_diff, caml_call1(sexp_of_t$0, diff)], 0],
       _am_ = [0, [0, cst_u$0, caml_call1(sexp_of_t$0, u)], _al_],
       _an_ = [0, [0, cst_t$0, caml_call1(sexp_of_t$0, t)], _am_];
      return caml_call1
              (raise_s, caml_call2(Base_Sexp[10], cst_overflow$0, _an_));
     }
    }
    return diff;
   }
   var negative_one = caml_call1(of_int$0, -1);
   function div_would_overflow(t, u){
    var _aj_ = caml_call2(symbol$5, t, min_value$0);
    return _aj_ ? caml_call2(symbol$5, u, negative_one) : _aj_;
   }
   function symbol$20(t, u){
    var product = caml_call2(symbol$11, t, u);
    a:
    if(caml_call2(symbol$8, u, zero$0)){
     if
      (!
       div_would_overflow(product, u)
       && ! caml_call2(symbol$8, caml_call2(symbol$16, product, u), t))
      break a;
     var
      _ag_ = [0, [0, cst_product, caml_call1(sexp_of_t$0, product)], 0],
      _ah_ = [0, [0, cst_u$1, caml_call1(sexp_of_t$0, u)], _ag_],
      _ai_ = [0, [0, cst_t$1, caml_call1(sexp_of_t$0, t)], _ah_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[10], cst_overflow$1, _ai_));
    }
    return product;
   }
   function symbol$21(t, u){
    if(! div_would_overflow(t, u)) return caml_call2(symbol$16, t, u);
    var
     _ad_ =
       [0,
        [0,
         cst_product$0,
         caml_call1(sexp_of_t$0, caml_call2(symbol$16, t, u))],
        0],
     _ae_ = [0, [0, cst_u$2, caml_call1(sexp_of_t$0, u)], _ad_],
     _af_ = [0, [0, cst_t$2, caml_call1(sexp_of_t$0, t)], _ae_];
    return caml_call1
            (raise_s, caml_call2(Base_Sexp[10], cst_overflow$2, _af_));
   }
   function abs$1(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[124], cst_abs_overflow)
            : caml_call1(abs$0, t);
   }
   function neg$0(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[124], cst_neg_overflow)
            : caml_call1(neg, t);
   }
   if(63 !== num_bits$0)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   function random_of_int(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[19][1];
    var _ac_ = caml_call1(to_int_exn$0, bound);
    return caml_call1(of_int$0, caml_call2(Base_Random[19][7], state, _ac_));
   }
   function random_of_int64(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[19][1];
    var _ab_ = caml_call1(to_int64$0, bound);
    return caml_call1
            (of_int64_exn$0, caml_call2(Base_Random[19][10], state, _ab_));
   }
   var random_of_int$0 = Base_Word_size[3] ? random_of_int : random_of_int64;
   function random_incl_of_int(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[19][1];
    var
     _$_ = caml_call1(to_int_exn$0, hi),
     _aa_ = caml_call1(to_int_exn$0, lo);
    return caml_call1
            (of_int$0, caml_call3(Base_Random[19][12], state, _aa_, _$_));
   }
   function random_incl_of_int64(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[19][1];
    var _Z_ = caml_call1(to_int64$0, hi), ___ = caml_call1(to_int64$0, lo);
    return caml_call1
            (of_int64_exn$0, caml_call3(Base_Random[19][15], state, ___, _Z_));
   }
   var
    random_incl =
      Base_Word_size[3] ? random_incl_of_int : random_incl_of_int64;
   function floor_log2(t){
    if(Base_Word_size[3]){
     var _X_ = caml_call1(to_int_exn$0, t);
     return caml_call1(Base_Int[71], _X_);
    }
    if(caml_call2(symbol$4, t, zero$0)){
     var _Y_ = [0, [0, cst, caml_call1(sexp_of_t$0, t)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int_floor_log2_got_invalid, _Y_));
    }
    var floor_log2 = [0, num_bits$0 - 2 | 0];
    for(;;){
     if
      (!
       caml_call2
        (equal$0,
         zero$0,
         caml_call2
          (bit_and$0, t, caml_call2(shift_left$0, one$0, floor_log2[1]))))
      return floor_log2[1];
     floor_log2[1] = floor_log2[1] - 1 | 0;
    }
   }
   var
    Base_Int63 =
      [0,
       t_sexp_grammar$0,
       of_float$0,
       to_float$0,
       of_int_exn$0,
       to_int_exn$0,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       equal$0,
       compare$0,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       pp$0,
       hashable$0,
       is_positive$0,
       is_non_negative$0,
       is_negative$0,
       is_non_positive$0,
       sign$0,
       compare_local$0,
       equal_local$0,
       invariant$0,
       Hex$0,
       Binary$0,
       of_string_opt$0,
       to_string_hum$0,
       zero$0,
       one$0,
       minus_one$0,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       neg,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       rem$0,
       symbol$17,
       land,
       lor,
       lxor,
       lnot$0,
       lsl,
       asr,
       round$0,
       round_towards_zero$0,
       round_down$0,
       round_up$0,
       round_nearest$0,
       abs$0,
       succ$0,
       pred$0,
       pow$0,
       bit_and$0,
       bit_or$0,
       bit_xor$0,
       bit_not$0,
       popcount$0,
       shift_left$0,
       shift_right$0,
       decr$0,
       incr$0,
       of_int32_exn$0,
       to_int32_exn$0,
       of_int64_exn$0,
       to_int64$0,
       of_nativeint_exn$0,
       to_nativeint_exn$0,
       of_float_unchecked$0,
       num_bits$0,
       max_value$0,
       min_value$0,
       lsr,
       shift_right_logical$0,
       ceil_pow2$0,
       floor_pow2$0,
       ceil_log2$0,
       is_pow2$0,
       clz$0,
       ctz$0,
       O$0,
       [0, symbol$18, symbol$19, symbol$20, symbol$21, abs$1, neg$0],
       of_int$0,
       to_int$0,
       of_int32,
       to_int32$0,
       of_int64$0,
       of_nativeint$0,
       to_nativeint$0,
       to_int_trunc$0,
       to_int32_trunc,
       of_int64_trunc,
       of_nativeint_trunc,
       to_nativeint_trunc$0,
       bswap16,
       bswap32$0,
       bswap48$0,
       random_of_int$0,
       random_incl,
       floor_log2,
       [0, Base_Int63_emul[117], repr$0]];
   runtime.caml_register_global(32, Base_Int63, "Base__Int63");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_mutable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Merge_into_action = [0],
    Definitions = [0, Merge_into_action],
    Base_Dictionary_mutable_intf = [0, Definitions];
   runtime.caml_register_global
    (0, Base_Dictionary_mutable_intf, "Base__Dictionary_mutable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_mutable
//# unitInfo: Requires: Base__Dictionary_mutable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Dictionary_mutable = [0];
   runtime.caml_register_global
    (0, Base_Dictionary_mutable, "Base__Dictionary_mutable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Key = [0],
    Base_Hashtbl_intf = [0, Key];
   runtime.caml_register_global(0, Base_Hashtbl_intf, "Base__Hashtbl_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Avltree
//# unitInfo: Requires: Base__Error, Base__Import, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_avltree_ml = "src/avltree.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[32],
    cst_Avltree_choose_exn_of_empt = "[Avltree.choose_exn] of empty hashtbl",
    _j_ = [0, cst_src_avltree_ml, 389, 15],
    _k_ = [0, cst_src_avltree_ml, 406, 20],
    _g_ = [0, cst_src_avltree_ml, 129, 30],
    _f_ = [0, cst_src_avltree_ml, 110, 26],
    _i_ = [0, cst_src_avltree_ml, 163, 30],
    _h_ = [0, cst_src_avltree_ml, 145, 26],
    _e_ = [0, cst_src_avltree_ml, 87, 22],
    _d_ = [0, cst_src_avltree_ml, 66, 6],
    _c_ = [0, cst_src_avltree_ml, 67, 6],
    _b_ = [0, cst_src_avltree_ml, 56, 6],
    _a_ = [0, cst_src_avltree_ml, 50, 6];
   function max(x, y){return y < x ? x : y;}
   var empty = 0;
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function height(param){
    if(typeof param === "number") return 0;
    if(0 !== param[0]) return 1;
    var height = param[4];
    return height;
   }
   function invariant(t, compare){
    function inv(param){
     if(typeof param !== "number" && 0 === param[0]){
      var
       left = param[1],
       key = param[2],
       h = param[4],
       right = param[5],
       hr = height(right),
       hl = height(left);
      inv(left);
      inv(right);
      if(typeof left !== "number"){
       var left_key = 0 === left[0] ? left[2] : left[1];
       if(0 <= caml_call2(compare, left_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      if(typeof right !== "number"){
       var right_key = 0 === right[0] ? right[2] : right[1];
       if(0 >= caml_call2(compare, right_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      }
      var _E_ = max(hl, hr);
      if(h !== caml_call2(Base_Import[91], _E_, 1))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var _F_ = caml_call2(Base_Import[93], hl, hr);
      if(2 < caml_call1(Base_Import[123], _F_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
      return 0;
     }
     return 0;
    }
    return inv(t);
   }
   function update_height(x){
    if(typeof x !== "number" && 0 === x[0]){
     var
      left = x[1],
      old_height = x[4],
      right = x[5],
      _C_ = height(right),
      _D_ = max(height(left), _C_),
      new_height = caml_call2(Base_Import[91], _D_, 1);
     if(new_height !== old_height) x[4] = new_height;
     return;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function balance(root_node){
    if(typeof root_node !== "number" && 0 === root_node[0]){
     var
      left_node = root_node[1],
      right_node = root_node[5],
      hl = height(left_node),
      hr = height(right_node);
     if(caml_call2(Base_Import[91], hr, 2) < hl){
      if(typeof left_node !== "number" && 0 === left_node[0]){
       var
        left_node_left = left_node[1],
        left_node_right = left_node[5],
        _A_ = height(left_node_right);
       if(_A_ <= height(left_node_left)){
        root_node[1] = left_node_right;
        left_node[5] = root_node;
        update_height(root_node);
        update_height(left_node);
        return left_node;
       }
       if(typeof left_node_right !== "number" && 0 === left_node_right[0]){
        var lr_left = left_node_right[1], lr_right = left_node_right[5];
        left_node[5] = lr_left;
        root_node[1] = lr_right;
        left_node_right[5] = root_node;
        left_node_right[1] = left_node;
        update_height(left_node);
        update_height(root_node);
        update_height(left_node_right);
        return left_node_right;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     if(caml_call2(Base_Import[91], hl, 2) >= hr){update_height(root_node); return root_node;
     }
     if(typeof right_node !== "number" && 0 === right_node[0]){
      var
       right_node_left = right_node[1],
       right_node_right = right_node[5],
       _B_ = height(right_node_left);
      if(_B_ <= height(right_node_right)){
       root_node[5] = right_node_left;
       right_node[1] = root_node;
       update_height(root_node);
       update_height(right_node);
       return right_node;
      }
      if(typeof right_node_left !== "number" && 0 === right_node_left[0]){
       var rl_left = right_node_left[1], rl_right = right_node_left[5];
       right_node[1] = rl_right;
       root_node[5] = rl_left;
       right_node_left[1] = root_node;
       right_node_left[5] = right_node;
       update_height(right_node);
       update_height(root_node);
       update_height(right_node_left);
       return right_node_left;
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    }
    return root_node;
   }
   function add(t, replace, compare, added, k, v){
    if(typeof t === "number"){added[1] = 1; return [1, k, v];}
    if(0 !== t[0]){
     var k$1 = t[1], c$0 = caml_call2(compare, k$1, k);
     if(0 !== c$0){
      added[1] = 1;
      return 0 <= c$0 ? [0, 0, k, v, 2, t] : [0, t, k, v, 2, 0];
     }
     added[1] = 0;
     if(replace) t[2] = v;
     return t;
    }
    var
     left = t[1],
     k$0 = t[2],
     right = t[5],
     c = caml_call2(compare, k, k$0);
    if(0 === c){added[1] = 0; if(replace) t[3] = v; return t;}
    if(0 <= c){
     var right$0 = add(right, replace, compare, added, k, v);
     if(1 - (right$0 === right ? 1 : 0)) t[5] = right$0;
    }
    else{
     var left$0 = add(left, replace, compare, added, k, v);
     if(1 - (left$0 === left ? 1 : 0)) t[1] = left$0;
    }
    return added[1] ? balance(t) : t;
   }
   function first(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var l = t$0[1];
      if(typeof l !== "number"){var t$0 = l; continue;}
      var v = t$0[3], k = t$0[2];
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function last(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var _y_ = t$0[2], _z_ = t$0[3];
      if(typeof t$0[5] !== "number"){var r = t$0[5], t$0 = r; continue;}
      var v = _z_, k = _y_;
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function findi_and_call_impl
   (t,
    compare,
    k,
    arg1,
    arg2,
    call_if_found,
    call_if_not_found,
    if_found,
    if_not_found){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number")
      return caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     if(0 !== t$0[0]){
      var k$1 = t$0[1], v$0 = t$0[2];
      return 0 === caml_call2(compare, k, k$1)
              ? caml_call5(call_if_found, if_found, k$1, v$0, arg1, arg2)
              : caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     }
     var
      left = t$0[1],
      k$0 = t$0[2],
      v = t$0[3],
      right = t$0[5],
      c = caml_call2(compare, k, k$0);
     if(0 === c)
      return caml_call5(call_if_found, if_found, k$0, v, arg1, arg2);
     var right$0 = 0 <= c ? right : left, t$0 = right$0;
    }
   }
   function call_if_found(if_found, param, data, _x_, _w_){return caml_call1(if_found, data);
   }
   function call_if_not_found(if_not_found, key, param, _v_){return caml_call1(if_not_found, key);
   }
   function find_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found,
             call_if_not_found,
             if_found,
             if_not_found);
   }
   function call_if_found$0(if_found, key, data, param, _u_){return caml_call2(if_found, key, data);
   }
   function call_if_not_found$0(if_not_found, key, param, _t_){return caml_call1(if_not_found, key);
   }
   function findi_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found$0,
             call_if_not_found$0,
             if_found,
             if_not_found);
   }
   function call_if_found$1(if_found, param, data, arg, _s_){return caml_call2(if_found, data, arg);
   }
   function call_if_not_found$1(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function find_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$1,
             call_if_not_found$1,
             if_found,
             if_not_found);
   }
   function call_if_found$2(if_found, key, data, arg, param){return caml_call3(if_found, key, data, arg);
   }
   function call_if_not_found$2(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function findi_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$2,
             call_if_not_found$2,
             if_found,
             if_not_found);
   }
   function call_if_found$3(if_found, param, data, arg1, arg2){return caml_call3(if_found, data, arg1, arg2);
   }
   function call_if_not_found$3(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function find_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$3,
             call_if_not_found$3,
             if_found,
             if_not_found);
   }
   function call_if_found$4(if_found, key, data, arg1, arg2){return caml_call4(if_found, key, data, arg1, arg2);
   }
   function call_if_not_found$4(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function findi_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$4,
             call_if_not_found$4,
             if_found,
             if_not_found);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, compare, k){
    return find_and_call(t, compare, k, if_found, if_not_found);
   }
   function if_found$0(param){return 1;}
   function if_not_found$0(param){return 0;}
   function mem(t, compare, k){
    return find_and_call(t, compare, k, if_found$0, if_not_found$0);
   }
   var
    remove =
      function _r_(_n_, _o_, _p_, _q_){return _r_.fun(_n_, _o_, _p_, _q_);};
   function remove_min_elt(tree){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    if(0 !== tree[0]) return 0;
    var left = tree[1];
    if(typeof left === "number"){var right = tree[5]; return right;}
    if(1 === left[0]){
     var k = tree[2], v = tree[3];
     if(typeof tree[5] === "number") return [1, k, v];
    }
    tree[1] = remove_min_elt(left);
    return balance(tree);
   }
   runtime.caml_update_dummy
    (remove,
     function(t, removed, compare, k$0){
      if(typeof t === "number"){removed[1] = 0; return 0;}
      if(0 !== t[0]){
       var k$2 = t[1];
       return 0 === caml_call2(compare, k$0, k$2)
               ? (removed[1] = 1, 0)
               : (removed[1] = 0, t);
      }
      var
       left$0 = t[1],
       k$1 = t[2],
       right = t[5],
       c = caml_call2(compare, k$0, k$1);
      if(0 !== c){
       if(0 <= c){
        var right$0 = caml_call4(remove, right, removed, compare, k$0);
        if(1 - (right$0 === right ? 1 : 0)) t[5] = right$0;
       }
       else{
        var left$1 = caml_call4(remove, left$0, removed, compare, k$0);
        if(1 - (left$1 === left$0 ? 1 : 0)) t[1] = left$1;
       }
       return removed[1] ? balance(t) : t;
      }
      removed[1] = 1;
      if(typeof left$0 === "number") return right;
      if(typeof right === "number") return left$0;
      var tree = right;
      for(;;){
       if(typeof tree === "number")
        var tree$0 = 0;
       else if(0 === tree[0]){
        var left = tree[1];
        if(typeof left !== "number"){var tree = left; continue;}
        var tree$0 = tree;
       }
       else
        var tree$0 = tree;
       if(typeof tree$0 === "number")
        throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
       if(0 === tree$0[0]){
        tree$0[5] = remove_min_elt(right);
        tree$0[1] = left$0;
        var tree$1 = tree$0;
       }
       else
        var
         k = tree$0[1],
         v = tree$0[2],
         t2 = remove_min_elt(right),
         _l_ = height(t2),
         _m_ = max(height(left$0), _l_),
         tree$1 = [0, left$0, k, v, caml_call2(Base_Import[91], _m_, 1), t2];
       return balance(tree$1);
      }
     });
   function fold(t, init, f){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 !== t$0[0]){
      var key$4 = t$0[1], data$4 = t$0[2];
      return caml_call3(f, key$4, data$4, init$0);
     }
     var left = t$0[1];
     if(typeof left === "number"){
      var key = t$0[2], data = t$0[3], match = t$0[5];
      if(typeof match !== "number" && 0 !== match[0]){
       var rkey = match[1], rdata = match[2];
       return caml_call3(f, rkey, rdata, caml_call3(f, key, data, init$0));
      }
     }
     else{
      if(0 === left[0]){
       var key$1 = t$0[2], data$1 = t$0[3], match$0 = t$0[5];
       if(typeof match$0 !== "number" && 0 !== match$0[0]){
        var rkey$0 = match$0[1], rdata$0 = match$0[2];
        return caml_call3
                (f,
                 rkey$0,
                 rdata$0,
                 caml_call3(f, key$1, data$1, fold(left, init$0, f)));
       }
      }
      else{
       var
        lkey$0 = left[1],
        ldata$0 = left[2],
        key$3 = t$0[2],
        data$3 = t$0[3],
        match$1 = t$0[5];
       if(typeof match$1 === "number")
        return caml_call3
                (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0));
       if(0 !== match$1[0]){
        var rkey$1 = match$1[1], rdata$1 = match$1[2];
        return caml_call3
                (f,
                 rkey$1,
                 rdata$1,
                 caml_call3
                  (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0)));
       }
      }
      if(typeof left !== "number" && 1 === left[0]){
       var
        lkey = left[1],
        ldata = left[2],
        key$2 = t$0[2],
        data$2 = t$0[3],
        right$0 = t$0[5],
        init$2 =
          caml_call3(f, key$2, data$2, caml_call3(f, lkey, ldata, init$0)),
        t$0 = right$0,
        init$0 = init$2;
       continue;
      }
     }
     var
      key$0 = t$0[2],
      data$0 = t$0[3],
      right = t$0[5],
      init$1 = caml_call3(f, key$0, data$0, fold(left, init$0, f)),
      t$0 = right,
      init$0 = init$1;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], data$0 = t$0[2];
      return caml_call2(f, key$0, data$0);
     }
     var left = t$0[1], key = t$0[2], data = t$0[3], right = t$0[5];
     iter(left, f);
     caml_call2(f, key, data);
     var t$0 = right;
    }
   }
   function mapi_inplace(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], value$0 = t$0[2];
      t$0[2] = caml_call2(f, key$0, value$0);
      return 0;
     }
     var left = t$0[1], key = t$0[2], value = t$0[3], right = t$0[5];
     mapi_inplace(left, f);
     t$0[3] = caml_call2(f, key, value);
     var t$0 = right;
    }
   }
   function choose_exn(param){
    if(typeof param === "number")
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[10], cst_Avltree_choose_exn_of_empt, 0));
    if(0 === param[0])
     var value = param[3], key = param[2];
    else
     var key$0 = param[1], value$0 = param[2], value = value$0, key = key$0;
    return [0, key, value];
   }
   var
    Base_Avltree =
      [0,
       empty,
       is_empty,
       invariant,
       add,
       first,
       last,
       find,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       mem,
       remove,
       fold,
       iter,
       mapi_inplace,
       choose_exn];
   runtime.caml_register_global(16, Base_Avltree, "Base__Avltree");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl
//# unitInfo: Requires: Base__Array, Base__Avltree, Base__Error, Base__Hashable, Base__Hashtbl_intf, Base__Import, Base__Int, Base__List, Base__Option, Base__Or_error, Base__Random, Base__Sexp, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_hashtbl_ml = "src/hashtbl.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Avltree = global_data.Base__Avltree,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Array = global_data.Base__Array,
    Base_List = global_data.Base__List,
    Base_Or_error = global_data.Base__Or_error,
    Base_Sexp = global_data.Base__Sexp,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Random = global_data.Base__Random,
    Base_Int = global_data.Base__Int,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1],
    hash_param = Base_Hashable[5],
    hash = Base_Hashable[6],
    raise_s = Base_Error[32],
    cst_Hashtbl_merge_different_ha =
      "Hashtbl.merge: different 'hashable' values",
    cst_keys = "keys",
    cst_Hashtbl_create_with_key_du = "Hashtbl.create_with_key: duplicate keys",
    cst_Hashtbl_t_of_sexp_duplicat = "Hashtbl.t_of_sexp: duplicate key",
    _c_ = [0, cst_src_hashtbl_ml, 582, 4],
    cst_Hashtbl_of_alist_exn_dupli = "Hashtbl.of_alist_exn: duplicate key",
    _b_ = [0, "Hashtbl.find_exn: not found"],
    _a_ = [0, cst_src_hashtbl_ml, 333, 2],
    cst_Hashtbl_choose_randomly_ex =
      "[Hashtbl.choose_randomly_exn] of empty hashtbl",
    cst_Hashtbl_choose_exn_of_empt = "[Hashtbl.choose_exn] of empty hashtbl",
    cst_Hashtbl_add_exn_got_key_al = "Hashtbl.add_exn got key already present",
    cst_Hashtbl_mutation_not_allow =
      "Hashtbl: mutation not allowed during iteration";
   function sexp_of_key(t){return t[4][3];}
   function compare_key(t){return t[4][2];}
   function ensure_mutation_allowed(t){
    var _aM_ = 1 - t[5];
    return _aM_
            ? caml_call1(Base_Import[124], cst_Hashtbl_mutation_not_allow)
            : _aM_;
   }
   function without_mutating(t, f){
    if(! t[5]) return caml_call1(f, 0);
    t[5] = 0;
    try{var x = caml_call1(f, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = 1;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = 1;
    return x;
   }
   var max_table_length = caml_call1(Base_Int[69], Base_Array[47]);
   function create(opt, _aK_, hashable, param){
    if(opt)
     var sth = opt[1], growth_allowed = sth;
    else
     var growth_allowed = 1;
    if(_aK_) var sth$0 = _aK_[1], size = sth$0; else var size = 0;
    var
     _aL_ = caml_call2(Base_Int[16], 1, size),
     size$0 = caml_call2(Base_Int[15], _aL_, max_table_length),
     size$1 = caml_call1(Base_Int[68], size$0);
    return [0,
            caml_call2(Base_Array[48], size$1, Base_Avltree[1]),
            0,
            growth_allowed,
            hashable,
            1];
   }
   function slot(t, key){
    var
     hash = caml_call1(t[4][1], key),
     _aJ_ = caml_call2(Base_Import[93], t[1].length - 1, 1);
    return caml_call2(Base_Import[116], hash, _aJ_);
   }
   function add_worker(t, replace, key, data){
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added = [0, 0],
     _aI_ = compare_key(t),
     new_root =
       caml_call6(Base_Avltree[4], root, replace, _aI_, added, key, data);
    if(added[1]) t[2] = caml_call2(Base_Import[91], t[2], 1);
    if(1 - (new_root === root ? 1 : 0))
     caml_check_bound(t[1], i)[1 + i] = new_root;
    return added[1];
   }
   function maybe_resize_table(t){
    var
     len = t[1].length - 1,
     should_grow = len < t[2] ? 1 : 0,
     _az_ = should_grow ? t[3] : should_grow;
    if(_az_){
     var
      _aA_ = caml_call2(Base_Import[88], len, 2),
      new_array_length = caml_call2(Base_Int[15], _aA_, max_table_length),
      _aB_ = len < new_array_length ? 1 : 0;
     if(_aB_){
      var
       new_table =
         caml_call2(Base_Array[48], new_array_length, Base_Avltree[1]),
       old_table = t[1];
      t[1] = new_table;
      t[2] = 0;
      var
       f = function(key, data){add_worker(t, 1, key, data); return 0;},
       _aD_ = caml_call2(Base_Import[93], old_table.length - 1, 1),
       _aC_ = 0;
      if(_aD_ >= 0){
       var i = _aC_;
       for(;;){
        var _aG_ = caml_check_bound(old_table, i)[1 + i];
        caml_call2(Base_Avltree[17], _aG_, f);
        var _aH_ = i + 1 | 0;
        if(_aD_ === i) break;
        var i = _aH_;
       }
      }
      var _aE_ = 0;
     }
     else
      var _aE_ = _aB_;
     var _aF_ = _aE_;
    }
    else
     var _aF_ = _az_;
    return _aF_;
   }
   function capacity(t){return t[1].length - 1;}
   function set(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 1, key, data);
    return maybe_resize_table(t);
   }
   function add(t, key, data){
    ensure_mutation_allowed(t);
    var added = add_worker(t, 0, key, data);
    return added ? (maybe_resize_table(t), 17724) : -1024851605;
   }
   function add_exn(t, key, data){
    if(17724 <= add(t, key, data)) return 0;
    var
     sexp_of_key$0 = sexp_of_key(t),
     error =
       caml_call5
        (Base_Error[19],
         0,
         0,
         cst_Hashtbl_add_exn_got_key_al,
         key,
         sexp_of_key$0);
    return caml_call1(Base_Error[31], error);
   }
   function clear(t){
    ensure_mutation_allowed(t);
    var _aw_ = caml_call2(Base_Import[93], t[1].length - 1, 1), _av_ = 0;
    if(_aw_ >= 0){
     var i = _av_;
     for(;;){
      var _ax_ = Base_Avltree[1];
      caml_check_bound(t[1], i)[1 + i] = _ax_;
      var _ay_ = i + 1 | 0;
      if(_aw_ === i) break;
      var i = _ay_;
     }
    }
    t[2] = 0;
    return 0;
   }
   function find_and_call(t, key, if_found, if_not_found){
    var _at_ = slot(t, key), tree = caml_check_bound(t[1], _at_)[1 + _at_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _au_ = compare_key(t);
     return caml_call5
             (Base_Avltree[8], tree, _au_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call1(if_found, v)
            : caml_call1(if_not_found, key);
   }
   function find_and_call1(t, key, a, if_found, if_not_found){
    var _ar_ = slot(t, key), tree = caml_check_bound(t[1], _ar_)[1 + _ar_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _as_ = compare_key(t);
     return caml_call6
             (Base_Avltree[9], tree, _as_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function find_and_call2(t, key, a, b, if_found, if_not_found){
    var _ap_ = slot(t, key), tree = caml_check_bound(t[1], _ap_)[1 + _ap_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _aq_ = compare_key(t);
     return caml_call7
             (Base_Avltree[10], tree, _aq_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function findi_and_call(t, key, if_found, if_not_found){
    var _an_ = slot(t, key), tree = caml_check_bound(t[1], _an_)[1 + _an_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _ao_ = compare_key(t);
     return caml_call5
             (Base_Avltree[11], tree, _ao_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, k, v)
            : caml_call1(if_not_found, key);
   }
   function findi_and_call1(t, key, a, if_found, if_not_found){
    var _al_ = slot(t, key), tree = caml_check_bound(t[1], _al_)[1 + _al_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _am_ = compare_key(t);
     return caml_call6
             (Base_Avltree[12], tree, _am_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, k, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function findi_and_call2(t, key, a, b, if_found, if_not_found){
    var _aj_ = slot(t, key), tree = caml_check_bound(t[1], _aj_)[1 + _aj_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _ak_ = compare_key(t);
     return caml_call7
             (Base_Avltree[13], tree, _ak_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call4(if_found, k, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, key){
    return find_and_call(t, key, if_found, if_not_found);
   }
   function mem(t, key){
    var _ah_ = slot(t, key), tree = caml_check_bound(t[1], _ah_)[1 + _ah_];
    if(typeof tree === "number") return 0;
    if(0 === tree[0]){
     var _ai_ = compare_key(t);
     return caml_call3(Base_Avltree[14], tree, _ai_, key);
    }
    var k = tree[1];
    return 0 === caml_call2(compare_key(t), k, key) ? 1 : 0;
   }
   function remove(t, key){
    ensure_mutation_allowed(t);
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     removed = [0, 0],
     _ae_ = compare_key(t),
     new_root = caml_call4(Base_Avltree[15], root, removed, _ae_, key);
    if(1 - (root === new_root ? 1 : 0))
     caml_check_bound(t[1], i)[1 + i] = new_root;
    var
     _af_ = removed[1],
     _ag_ = _af_ ? (t[2] = caml_call2(Base_Import[93], t[2], 1), 0) : _af_;
    return _ag_;
   }
   function length(t){return t[2];}
   function is_empty(t){return 0 === t[2] ? 1 : 0;}
   function fold(t, init, f){
    if(0 === t[2]) return init;
    var n = t[1].length - 1, acc = [0, init], m = t[5];
    try{
     t[5] = 0;
     var _ac_ = caml_call2(Base_Import[93], n, 1), _ab_ = 0;
     if(_ac_ >= 0){
      var i = _ab_;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         acc[1] = caml_call3(Base_Avltree[16], bucket, acc[1], f);
        else{
         var key = bucket[1], data = bucket[2];
         acc[1] = caml_call3(f, key, data, acc[1]);
        }
       var _ad_ = i + 1 | 0;
       if(_ac_ === i) break;
       var i = _ad_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = m;
    return acc[1];
   }
   function iteri(t, f){
    if(0 === t[2]) return 0;
    var n = t[1].length - 1, m = t[5];
    try{
     t[5] = 0;
     var _$_ = caml_call2(Base_Import[93], n, 1), ___ = 0;
     if(_$_ >= 0){
      var i = ___;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         caml_call2(Base_Avltree[17], bucket, f);
        else{var key = bucket[1], data = bucket[2]; caml_call2(f, key, data);}
       var _aa_ = i + 1 | 0;
       if(_$_ === i) break;
       var i = _aa_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = m;
    return 0;
   }
   function iter(t, f){
    return iteri(t, function(param, data){return caml_call1(f, data);});
   }
   function iter_keys(t, f){
    return iteri(t, function(key, param){return caml_call1(f, key);});
   }
   function choose_nonempty(table, i){
    var i$0 = i;
    for(;;){
     var avltree = table[1 + i$0];
     if(! caml_call1(Base_Avltree[2], avltree))
      return caml_call1(Base_Avltree[19], avltree);
     var
      _Y_ = caml_call2(Base_Import[93], table.length - 1, 1),
      _Z_ = caml_call2(Base_Import[91], i$0, 1),
      i$1 = caml_call2(Base_Import[116], _Z_, _Y_),
      i$0 = i$1;
    }
   }
   function choose_exn(t){
    if(0 === t[2])
     caml_call1
      (raise_s, caml_call2(Base_Sexp[10], cst_Hashtbl_choose_exn_of_empt, 0));
    return choose_nonempty(t[1], 0);
   }
   function choose(t){return is_empty(t) ? 0 : [0, choose_nonempty(t[1], 0)];}
   function choose_randomly_nonempty(random_state, t){
    var
     start_idx = caml_call2(Base_Random[19][7], random_state, t[1].length - 1);
    return choose_nonempty(t[1], start_idx);
   }
   function choose_randomly(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    return is_empty(t) ? 0 : [0, choose_randomly_nonempty(random_state, t)];
   }
   function choose_randomly_exn(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    if(0 === t[2])
     caml_call1
      (raise_s, caml_call2(Base_Sexp[10], cst_Hashtbl_choose_randomly_ex, 0));
    return choose_randomly_nonempty(random_state, t);
   }
   function invariant(invariant_key, invariant_data, t){
    var _U_ = caml_call2(Base_Import[93], t[1].length - 1, 1), _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      var _V_ = compare_key(t), _W_ = caml_check_bound(t[1], i)[1 + i];
      caml_call2(Base_Avltree[3], _W_, _V_);
      var _X_ = i + 1 | 0;
      if(_U_ === i) break;
      var i = _X_;
     }
    }
    var
     real_len =
       fold
        (t,
         0,
         function(key, data, i){
          caml_call1(invariant_key, key);
          caml_call1(invariant_data, data);
          return caml_call2(Base_Import[91], i, 1);
         });
    if(real_len === t[2]) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function if_found$0(v, param){return v;}
   function if_not_found$0(k, t){
    var _S_ = [1, [0, _b_, [0, caml_call1(t[4][3], k), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _S_], 1);
   }
   function find_exn(t, key){
    return find_and_call1(t, key, t, if_found$0, if_not_found$0);
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _R_ = caml_call2(f, key, data);
                 return _R_ ? caml_call1(r, 1) : _R_;
                });
              return 0;
             });
   }
   function exists(t, f){
    return existsi(t, function(param, data){return caml_call1(f, data);});
   }
   function for_alli(t, f){
    return 1
           -
            existsi
             (t, function(key, data){return 1 - caml_call2(f, key, data);});
   }
   function for_all(t, f){
    return 1
           -
            existsi(t, function(param, data){return 1 - caml_call1(f, data);});
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function mapi(t, f){
    var new_t = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){return set(new_t, key, caml_call2(f, key, data));});
    return new_t;
   }
   function map(t, f){
    return mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function copy(t){return map(t, function(_Q_){return _Q_;});}
   function filter_mapi(t, f){
    var new_t = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(! match) return 0;
       var new_data = match[1];
       return set(new_t, key, new_data);
      });
    return new_t;
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function filteri(t, f){
    return filter_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : 0;
             });
   }
   function filter(t, f){
    return filteri(t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(t, f){
    return filteri(t, function(key, param){return caml_call1(f, key);});
   }
   function partition_mapi(t, f){
    var
     t0 = create([0, t[3]], [0, t[2]], t[4], 0),
     t1 = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(0 === match[0]){
        var new_data = match[1];
        return set(t0, key, new_data);
       }
       var new_data$0 = match[1];
       return set(t1, key, new_data$0);
      });
    return [0, t0, t1];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             });
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function find_or_add(t, id, default$0){
    function _P_(key){
     var default$1 = caml_call1(default$0, 0);
     set(t, key, default$1);
     return default$1;
    }
    return find_and_call(t, id, function(data){return data;}, _P_);
   }
   function findi_or_add(t, id, default$0){
    function _O_(key){
     var default$1 = caml_call1(default$0, key);
     set(t, key, default$1);
     return default$1;
    }
    return find_and_call(t, id, function(data){return data;}, _O_);
   }
   function find_and_remove(t, id){
    var result = find(t, id);
    if(caml_call1(Base_Option[53], result)) remove(t, id);
    return result;
   }
   function change(t, id, f){
    var match = caml_call1(f, find(t, id));
    if(! match) return remove(t, id);
    var data = match[1];
    return set(t, id, data);
   }
   function update_and_return(t, id, f){
    var data = caml_call1(f, find(t, id));
    set(t, id, data);
    return data;
   }
   function update(t, id, f){update_and_return(t, id, f); return 0;}
   function incr_by(remove_if_zero, t, key, by){
    return remove_if_zero
            ? change
              (t,
               key,
               function(opt){
                var
                 _N_ = caml_call2(Base_Option[30], opt, 0),
                 n = caml_call2(Base_Import[91], by, _N_);
                return 0 === n ? 0 : [0, n];
               })
            : update
              (t,
               key,
               function(param){
                if(! param) return by;
                var i = param[1];
                return caml_call2(Base_Import[91], by, i);
               });
   }
   function incr(opt, _M_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_M_)
     var sth$0 = _M_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, by);
   }
   function decr(opt, _L_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_L_)
     var sth$0 = _L_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, caml_call1(Base_Import[113], by));
   }
   function add_multi(t, key, data){
    return update
            (t,
             key,
             function(param){
              if(! param) return [0, data, 0];
              var l = param[1];
              return [0, data, l];
             });
   }
   function remove_multi(t, key){
    var match = find(t, key);
    if(! match) return 0;
    var _K_ = match[1];
    if(_K_ && _K_[2]){var tl = _K_[2]; return set(t, key, tl);}
    return remove(t, key);
   }
   function find_multi(t, key){
    var match = find(t, key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function create_mapped
   (growth_allowed, size, hashable, get_key, get_data, rows){
    if(size)
     var s = size[1], size$0 = s;
    else
     var size$0 = caml_call1(Base_List[45], rows);
    var
     res = create(growth_allowed, [0, size$0], hashable, 0),
     dupes = [0, 0];
    function _J_(r){
     var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
     return mem(res, key)
             ? (dupes[1] = [0, key, dupes[1]], 0)
             : set(res, key, data);
    }
    caml_call2(Base_List[19], rows, _J_);
    var keys = dupes[1];
    return keys
            ? [0, 175765640, caml_call2(Base_List[126], keys, hashable[2])]
            : [0, 17724, res];
   }
   function of_alist(growth_allowed, size, hashable, lst){
    var
     match =
       create_mapped
        (growth_allowed,
         size,
         hashable,
         Base_Import[125],
         Base_Import[127],
         lst);
    if(175765640 <= match[1]){
     var k = match[2];
     return [0, -1048878709, caml_call1(Base_List[88], k)];
    }
    var t = match[2];
    return [0, 17724, t];
   }
   function of_alist_report_all_dups(growth_allowed, size, hashable, lst){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             Base_Import[125],
             Base_Import[127],
             lst);
   }
   function of_alist_or_error(growth_allowed, size, hashable, lst){
    var match = of_alist(growth_allowed, size, hashable, lst);
    if(17724 <= match[1]){var v = match[2]; return [0, v];}
    var key = match[2], sexp_of_key = hashable[3];
    return caml_call5
            (Base_Or_error[38],
             0,
             0,
             cst_Hashtbl_of_alist_exn_dupli,
             key,
             sexp_of_key);
   }
   function of_alist_exn(growth_allowed, size, hashable, lst){
    var match = of_alist_or_error(growth_allowed, size, hashable, lst);
    if(0 === match[0]){var v = match[1]; return v;}
    var e = match[1];
    return caml_call1(Base_Error[31], e);
   }
   function of_alist_multi(growth_allowed, size$0, hashable, rows){
    var get_data = Base_Import[127], get_key = Base_Import[125];
    if(size$0)
     var s = size$0[1], size = s;
    else
     var size = caml_call1(Base_List[45], rows);
    var res = create(growth_allowed, [0, size], hashable, 0);
    function _I_(r){
     var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
     return add_multi(res, key, data);
    }
    caml_call2(Base_List[19], rows, _I_);
    return res;
   }
   function to_alist(t){
    return fold
            (t,
             0,
             function(key, data, list){return [0, [0, key, data], list];});
   }
   function sexp_of_t(sexp_of_key, sexp_of_data, t){
    var
     _D_ = to_alist(t),
     _E_ = Base_List[83],
     _F_ =
       caml_call2
        (_E_,
         _D_,
         function(param, _H_){
          var k2 = _H_[1], k1 = param[1];
          return caml_call2(t[4][2], k1, k2);
         }),
     _G_ = caml_call2(Base_Import[147], sexp_of_key, sexp_of_data);
    return caml_call1(caml_call1(Base_Import[149], _G_), _F_);
   }
   function t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp){
    var
     _t_ = caml_call2(Base_Import[171], k_of_sexp, d_of_sexp),
     alist = caml_call2(Base_Import[173], _t_, sexp),
     match =
       of_alist(0, [0, caml_call1(Base_List[45], alist)], hashable, alist);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var k = match[2];
    function _u_(_C_){return _C_;}
    function _v_(_B_){return _B_;}
    var
     _w_ = caml_call2(Base_Import[171], _v_, _u_),
     alist_sexps = caml_call2(Base_Import[173], _w_, sexp),
     found_first_k = [0, 0];
    function _x_(param, _y_){
     var
      k2_sexp = _y_[1],
      k2 = param[1],
      _z_ = 0 === caml_call2(hashable[2], k, k2) ? 1 : 0;
     if(_z_){
      if(found_first_k[1])
       return caml_call2
               (Base_Import[156], cst_Hashtbl_t_of_sexp_duplicat, k2_sexp);
      found_first_k[1] = 1;
      var _A_ = 0;
     }
     else
      var _A_ = _z_;
     return _A_;
    }
    caml_call3(Base_List[67], alist, alist_sexps, _x_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function t_sexp_grammar(k_grammar, v_grammar){
    var _s_ = caml_call2(Base_List[137][3], k_grammar, v_grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _s_);
   }
   function keys(t){
    return fold(t, 0, function(key, param, acc){return [0, key, acc];});
   }
   function data(t){
    return fold(t, 0, function(param, data, list){return [0, data, list];});
   }
   function group
   (growth_allowed, size, hashable, get_key, get_data, combine, rows){
    var groups = create(growth_allowed, size, hashable, 0);
    function _r_(row){
     var
      key = caml_call1(get_key, row),
      data = caml_call1(get_data, row),
      match = find(groups, key);
     if(match)
      var old = match[1], data$0 = caml_call2(combine, old, data);
     else
      var data$0 = data;
     return set(groups, key, data$0);
    }
    caml_call2(Base_List[19], rows, _r_);
    return groups;
   }
   function create_with_key(growth_allowed, size, hashable, get_key, rows){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             get_key,
             function(_q_){return _q_;},
             rows);
   }
   function create_with_key_or_error
   (growth_allowed, size, hashable, get_key, rows){
    var
     match = create_with_key(growth_allowed, size, hashable, get_key, rows);
    if(175765640 <= match[1]){
     var
      keys = match[2],
      sexp_of_key = hashable[3],
      _o_ =
        [0, [0, cst_keys, caml_call2(Base_Import[149], sexp_of_key, keys)], 0],
      _p_ = caml_call2(Base_Sexp[10], cst_Hashtbl_create_with_key_du, _o_);
     return caml_call1(Base_Or_error[39], _p_);
    }
    var t = match[2];
    return [0, t];
   }
   function create_with_key_exn(growth_allowed, size, hashable, get_key, rows){
    var
     _n_ =
       create_with_key_or_error(growth_allowed, size, hashable, get_key, rows);
    return caml_call1(Base_Or_error[34], _n_);
   }
   function maybe_set(t, key, f, d){
    var match = caml_call2(f, key, d);
    if(! match) return 0;
    var v = match[1];
    return set(t, key, v);
   }
   function merge(t_left, t_right, f){
    if(1 - caml_call2(Base_Hashable[1], t_left[4], t_right[4]))
     caml_call1(Base_Import[126], cst_Hashtbl_merge_different_ha);
    var new_t = create([0, t_left[3]], [0, t_left[2]], t_left[4], 0);
    without_mutating
     (t_left,
      function(param){
       return without_mutating
               (t_right,
                function(param){
                 iteri
                  (t_left,
                   function(key, left){
                    var match = find(t_right, key);
                    if(! match)
                     return maybe_set(new_t, key, f, [0, 847852583, left]);
                    var right = match[1];
                    return maybe_set
                            (new_t, key, f, [0, 737457313, [0, left, right]]);
                   });
                 return iteri
                         (t_right,
                          function(key, right){
                           return find(t_left, key)
                                   ? 0
                                   : maybe_set(new_t, key, f, [0, -57574468, right]);
                          });
                });
      });
    return new_t;
   }
   function merge_into(src, dst, f){
    return iteri
            (src,
             function(key, data){
              var
               dst_data = find(dst, key),
               action =
                 without_mutating
                  (dst,
                   function(param){return caml_call3(f, key, data, dst_data);});
              if(! action) return remove(dst, key);
              var data$0 = action[1];
              if(! dst_data) return set(dst, key, data$0);
              var
               dst_data$0 = dst_data[1],
               _m_ = 1 - (dst_data$0 === data$0 ? 1 : 0);
              return _m_ ? set(dst, key, data$0) : _m_;
             });
   }
   function filteri_inplace(t, f){
    var
     to_remove =
       fold
        (t,
         0,
         function(key, data, ac){
          return caml_call2(f, key, data) ? ac : [0, key, ac];
         });
    function _l_(key){return remove(t, key);}
    return caml_call2(Base_List[19], to_remove, _l_);
   }
   function filter_inplace(t, f){
    return filteri_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys_inplace(t, f){
    return filteri_inplace
            (t, function(key, param){return caml_call1(f, key);});
   }
   function filter_mapi_inplace(t, f){
    var
     map_results =
       fold
        (t,
         0,
         function(key, data, ac){
          return [0, [0, key, caml_call2(f, key, data)], ac];
         });
    function _k_(param){
     var result = param[2], key = param[1];
     if(! result) return remove(t, key);
     var data = result[1];
     return set(t, key, data);
    }
    return caml_call2(Base_List[19], map_results, _k_);
   }
   function filter_map_inplace(t, f){
    return filter_mapi_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function mapi_inplace(t, f){
    ensure_mutation_allowed(t);
    return without_mutating
            (t,
             function(param){
              var _h_ = Base_Avltree[18];
              function _i_(_j_){return caml_call2(_h_, _j_, f);}
              return caml_call2(Base_Array[20], t[1], _i_);
             });
   }
   function map_inplace(t, f){
    return mapi_inplace(t, function(param, data){return caml_call1(f, data);});
   }
   function similar(equal, t$0, t){
    var _f_ = t$0[2] === t[2] ? 1 : 0;
    return _f_
            ? caml_call1
              (with_return,
               function(r){
                without_mutating
                 (t,
                  function(param){
                   return iteri
                           (t$0,
                            function(key, data){
                             var match = find(t, key);
                             if(! match) return caml_call1(r, 0);
                             var
                              data$0 = match[1],
                              _g_ = 1 - caml_call2(equal, data, data$0);
                             return _g_ ? caml_call1(r, 0) : _g_;
                            });
                  });
                return 1;
               })
            : _f_;
   }
   function Creators(Key){
    var hashable = Key[1];
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, hashable, 0);
    }
    function of_alist$0(growth_allowed, size, l){
     return of_alist(growth_allowed, size, hashable, l);
    }
    function of_alist_report_all_dups$0(growth_allowed, size, l){
     return of_alist_report_all_dups(growth_allowed, size, hashable, l);
    }
    function of_alist_or_error$0(growth_allowed, size, l){
     return of_alist_or_error(growth_allowed, size, hashable, l);
    }
    function of_alist_exn$0(growth_allowed, size, l){
     return of_alist_exn(growth_allowed, size, hashable, l);
    }
    function t_of_sexp$0(k_of_sexp, d_of_sexp, sexp){
     return t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp);
    }
    function of_alist_multi$0(growth_allowed, size, l){
     return of_alist_multi(growth_allowed, size, hashable, l);
    }
    function create_mapped$0(growth_allowed, size, get_key, get_data, l){
     return create_mapped
             (growth_allowed, size, hashable, get_key, get_data, l);
    }
    function create_with_key$0(growth_allowed, size, get_key, l){
     return create_with_key(growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_or_error$0(growth_allowed, size, get_key, l){
     return create_with_key_or_error
             (growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_exn$0(growth_allowed, size, get_key, l){
     return create_with_key_exn(growth_allowed, size, hashable, get_key, l);
    }
    function group$0(growth_allowed, size, get_key, get_data, combine, l){
     return group
             (growth_allowed, size, hashable, get_key, get_data, combine, l);
    }
    return [0,
            t_of_sexp$0,
            create$0,
            of_alist$0,
            of_alist_report_all_dups$0,
            of_alist_or_error$0,
            of_alist_exn$0,
            of_alist_multi$0,
            create_mapped$0,
            create_with_key$0,
            create_with_key_or_error$0,
            create_with_key_exn$0,
            group$0];
   }
   var
    hashable = Base_Hashable[2],
    _d_ = Creators([0, hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_alist$0 = _d_[3],
    of_alist_report_all_dups$0 = _d_[4],
    of_alist_or_error$0 = _d_[5],
    of_alist_exn$0 = _d_[6],
    of_alist_multi$0 = _d_[7],
    create_mapped$0 = _d_[8],
    create_with_key$0 = _d_[9],
    create_with_key_or_error$0 = _d_[10],
    create_with_key_exn$0 = _d_[11],
    group$0 = _d_[12];
   function hashable$0(t){return t[4];}
   var Private = [0, hashable$0];
   function create$1(growth_allowed, size, m){
    return create(growth_allowed, size, caml_call1(Base_Hashable[3], m), 0);
   }
   function of_alist$1(growth_allowed, size, m, l){
    return of_alist(growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_report_all_dups$1(growth_allowed, size, m, l){
    return of_alist_report_all_dups
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_or_error$1(growth_allowed, size, m, l){
    return of_alist_or_error
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_exn$1(growth_allowed, size, m, l){
    return of_alist_exn
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_multi$1(growth_allowed, size, m, l){
    return of_alist_multi
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function create_mapped$1(growth_allowed, size, m, get_key, get_data, l){
    return create_mapped
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             l);
   }
   function create_with_key$1(growth_allowed, size, m, get_key, l){
    return create_with_key
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_or_error$1(growth_allowed, size, m, get_key, l){
    return create_with_key_or_error
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_exn$1(growth_allowed, size, m, get_key, l){
    return create_with_key_exn
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function group$1(growth_allowed, size, m, get_key, get_data, combine, l){
    return group
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             combine,
             l);
   }
   function hashable_s(t){return caml_call1(Base_Hashable[4], t[4]);}
   function M(K){return [0];}
   function sexp_of_m_t(K, sexp_of_v, t){
    return sexp_of_t(K[1], sexp_of_v, t);
   }
   function m_t_of_sexp(K, v_of_sexp, sexp){
    var _e_ = K[1];
    return t_of_sexp
            (caml_call1(Base_Hashable[3], [0, K[2], K[3], K[4]]),
             _e_,
             v_of_sexp,
             sexp);
   }
   function m_t_sexp_grammar(K, v_grammar){
    return t_sexp_grammar(K[1], v_grammar);
   }
   function equal_m_t(param, equal_v, t1, t2){return similar(equal_v, t1, t2);
   }
   var
    Base_Hashtbl =
      [0,
       hash,
       hash_param,
       sexp_of_t,
       create$1,
       of_alist$1,
       of_alist_report_all_dups$1,
       of_alist_or_error$1,
       of_alist_exn$1,
       of_alist_multi$1,
       create_mapped$1,
       create_with_key$1,
       create_with_key_or_error$1,
       create_with_key_exn$1,
       group$1,
       sexp_of_key,
       clear,
       copy,
       fold,
       iter_keys,
       iter,
       iteri,
       existsi,
       exists,
       for_alli,
       for_all,
       counti,
       count,
       length,
       capacity,
       is_empty,
       mem,
       remove,
       choose,
       choose_exn,
       choose_randomly,
       choose_randomly_exn,
       set,
       add,
       add_exn,
       change,
       update,
       update_and_return,
       map,
       mapi,
       filter_map,
       filter_mapi,
       filter_keys,
       filter,
       filteri,
       partition_map,
       partition_mapi,
       partition_tf,
       partitioni_tf,
       find_or_add,
       findi_or_add,
       find,
       find_exn,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       find_and_remove,
       merge,
       merge_into,
       keys,
       data,
       filter_keys_inplace,
       filter_inplace,
       filteri_inplace,
       map_inplace,
       mapi_inplace,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist,
       incr,
       decr,
       add_multi,
       remove_multi,
       find_multi,
       hashable_s,
       invariant,
       Creators,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        hashable,
        invariant,
        create$0,
        of_alist$0,
        of_alist_report_all_dups$0,
        of_alist_or_error$0,
        of_alist_exn$0,
        of_alist_multi$0,
        create_mapped$0,
        create_with_key$0,
        create_with_key_or_error$0,
        create_with_key_exn$0,
        group$0,
        sexp_of_key,
        clear,
        copy,
        fold,
        iter_keys,
        iter,
        iteri,
        existsi,
        exists,
        for_alli,
        for_all,
        counti,
        count,
        length,
        capacity,
        is_empty,
        mem,
        remove,
        choose,
        choose_exn,
        choose_randomly,
        choose_randomly_exn,
        set,
        add,
        add_exn,
        change,
        update,
        update_and_return,
        map,
        mapi,
        filter_map,
        filter_mapi,
        filter_keys,
        filter,
        filteri,
        partition_map,
        partition_mapi,
        partition_tf,
        partitioni_tf,
        find_or_add,
        findi_or_add,
        find,
        find_exn,
        find_and_call,
        find_and_call1,
        find_and_call2,
        findi_and_call,
        findi_and_call1,
        findi_and_call2,
        find_and_remove,
        merge,
        merge_into,
        keys,
        data,
        filter_keys_inplace,
        filter_inplace,
        filteri_inplace,
        map_inplace,
        mapi_inplace,
        filter_map_inplace,
        filter_mapi_inplace,
        similar,
        similar,
        to_alist,
        incr,
        decr,
        add_multi,
        remove_multi,
        find_multi],
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(26, Base_Hashtbl, "Base__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_set_intf = [0];
   runtime.caml_register_global(0, Base_Hash_set_intf, "Base__Hash_set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set
//# unitInfo: Requires: Base__Array, Base__Container, Base__Hash_set_intf, Base__Hashable, Base__Hashtbl, Base__Import, Base__List, Base__Or_error, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Base_Hashable = global_data.Base__Hashable,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base_Array = global_data.Base__Array,
    Base_Container = global_data.Base__Container,
    Base_Or_error = global_data.Base__Or_error,
    Base_With_return = global_data.Base__With_return,
    hashable_s = Base_Hashtbl[84],
    hashable = Base_Hashtbl[93][1],
    poly_hashable = Base_Hashtbl[87][4],
    with_return = Base_With_return[1],
    clear = Base_Hashtbl[16],
    length = Base_Hashtbl[28],
    mem = Base_Hashtbl[31],
    cst_Hash_set_t_of_sexp_got_a_d =
      "Hash_set.t_of_sexp got a duplicate element",
    cst_Hash_set_t_of_sexp_require = "Hash_set.t_of_sexp requires a list",
    _c_ = [0, 0],
    _b_ = [0, 0],
    cst_element_not_in_set = "element not in set",
    cst_element_already_exists = "element already exists",
    _a_ = [0, 0];
   function is_empty(t){return caml_call1(Base_Hashtbl[30], t);}
   function find_map(t, f){
    return caml_call1
            (with_return,
             function(r){
              function _C_(elt){
               var o = caml_call1(f, elt);
               return o ? caml_call1(r, o) : 0;
              }
              caml_call2(Base_Hashtbl[19], t, _C_);
              return 0;
             });
   }
   function find(t, f){
    return find_map(t, function(a){return caml_call1(f, a) ? [0, a] : 0;});
   }
   function add(t, k){return caml_call3(Base_Hashtbl[37], t, k, 0);}
   function strict_add(t, k){
    return caml_call2(mem, t, k)
            ? caml_call1(Base_Or_error[40], cst_element_already_exists)
            : (caml_call3(Base_Hashtbl[37], t, k, 0), _a_);
   }
   function strict_add_exn(t, k){
    var _B_ = strict_add(t, k);
    return caml_call1(Base_Or_error[34], _B_);
   }
   var remove = Base_Hashtbl[32];
   function strict_remove(t, k){
    if(caml_call2(mem, t, k)){caml_call2(remove, t, k); return _b_;}
    var _A_ = caml_call1(Base_Hashtbl[15], t);
    return caml_call5(Base_Or_error[38], 0, 0, cst_element_not_in_set, k, _A_);
   }
   function strict_remove_exn(t, k){
    var _z_ = strict_remove(t, k);
    return caml_call1(Base_Or_error[34], _z_);
   }
   function fold(t, init, f){
    function _y_(key, param, acc){return caml_call2(f, acc, key);}
    return caml_call3(Base_Hashtbl[18], t, init, _y_);
   }
   function iter(t, f){return caml_call2(Base_Hashtbl[19], t, f);}
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   var to_list = Base_Hashtbl[67];
   function sexp_of_t(sexp_of_e, t){
    var
     _w_ = caml_call1(to_list, t),
     func = Base_List[83],
     _x_ = caml_call2(func, _w_, caml_call1(hashable, t)[2]);
    return caml_call2(Base_Import[149], sexp_of_e, _x_);
   }
   function to_array(t){
    var
     len = caml_call1(length, t),
     index = [0, caml_call2(Base_Import[93], len, 1)];
    return fold
            (t,
             [0],
             function(acc, key){
              if(0 === acc.length - 1)
               return caml_call2(Base_Array[48], len, key);
              index[1] = caml_call2(Base_Import[93], index[1], 1);
              var _v_ = index[1];
              runtime.caml_check_bound(acc, _v_)[1 + _v_] = key;
              return acc;
             });
   }
   function exists(t, f){
    function _u_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[22], t, _u_);
   }
   function for_all(t, f){
    function _t_(key, param){return 1 - caml_call1(f, key);}
    return 1 - caml_call2(Base_Hashtbl[22], t, _t_);
   }
   function equal(t1, t2){
    function _r_(param, _s_){return 1;}
    return caml_call3(Base_Hashtbl[76], _r_, t1, t2);
   }
   function copy(t){return caml_call1(Base_Hashtbl[17], t);}
   function filter(t, f){
    function _q_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[49], t, _q_);
   }
   function union(t1, t2){
    function _o_(param, _p_){return _c_;}
    return caml_call3(Base_Hashtbl[65], t1, t2, _o_);
   }
   function diff(t1, t2){
    return filter
            (t1,
             function(key){return 1 - caml_call2(Base_Hashtbl[31], t2, key);});
   }
   function inter(t1, t2){
    var _m_ = caml_call1(length, t2);
    if(_m_ < caml_call1(length, t1))
     var larger = t1, smaller = t2;
    else
     var larger = t2, smaller = t1;
    function _n_(key, param){
     return caml_call2(Base_Hashtbl[31], larger, key);
    }
    return caml_call2(Base_Hashtbl[49], smaller, _n_);
   }
   function filter_inplace(t, f){
    var
     to_remove =
       fold(t, 0, function(ac, x){return caml_call1(f, x) ? ac : [0, x, ac];});
    function _l_(x){return caml_call2(remove, t, x);}
    return caml_call2(Base_List[19], to_remove, _l_);
   }
   function of_hashtbl_keys(hashtbl){
    function _j_(_k_){return 0;}
    return caml_call2(Base_Hashtbl[43], hashtbl, _j_);
   }
   function to_hashtbl(t, f){
    function _i_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[44], t, _i_);
   }
   function create(growth_allowed, size, m){
    return caml_call3(Base_Hashtbl[4], growth_allowed, size, m);
   }
   function of_list(growth_allowed, size, m, l){
    if(size)
     var x = size[1], size$0 = x;
    else
     var size$0 = caml_call1(Base_List[45], l);
    var t = caml_call3(Base_Hashtbl[4], growth_allowed, [0, size$0], m);
    function _h_(k){return add(t, k);}
    caml_call2(Base_List[19], l, _h_);
    return t;
   }
   function t_of_sexp(m, e_of_sexp, sexp){
    if(0 === sexp[0])
     return caml_call2(Base_Import[156], cst_Hash_set_t_of_sexp_require, sexp);
    var
     list = sexp[1],
     t = create(0, [0, caml_call1(Base_List[45], list)], m);
    function _g_(sexp){
     var e = caml_call1(e_of_sexp, sexp);
     return 0 === strict_add(t, e)[0]
             ? 0
             : caml_call2
               (Base_Import[156], cst_Hash_set_t_of_sexp_got_a_d, sexp);
    }
    caml_call2(Base_List[19], list, _g_);
    return t;
   }
   function Creators(Elt){
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]));
    }
    function of_list$0(growth_allowed, size, l){
     return of_list
             (growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]), l);
    }
    function t_of_sexp$0(e_of_sexp, sexp){
     return t_of_sexp(caml_call1(Base_Hashable[4], Elt[1]), e_of_sexp, sexp);
    }
    return [0, t_of_sexp$0, create$0, of_list$0];
   }
   var
    _d_ = Creators([0, poly_hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_list$0 = _d_[3];
   function t_sexp_grammar(grammar){
    var _f_ = caml_call1(Base_List[7], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _f_);
   }
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt, t){return sexp_of_t(Elt[1], t);}
   function m_t_of_sexp(Elt, sexp){
    return t_of_sexp([0, Elt[2], Elt[3], Elt[4]], Elt[1], sexp);
   }
   function m_t_sexp_grammar(Elt){
    var _e_ = caml_call1(Base_Import[194], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _e_);
   }
   function equal_m_t(param, t1, t2){return equal(t1, t2);}
   var
    hashable$0 = Base_Hashtbl[93][1],
    Private = [0, hashable$0],
    Base_Hash_set =
      [0,
       sexp_of_t,
       create,
       of_list,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       mem,
       copy,
       add,
       strict_add,
       strict_add_exn,
       remove,
       strict_remove,
       strict_remove_exn,
       clear,
       equal,
       filter,
       filter_inplace,
       inter,
       union,
       diff,
       of_hashtbl_keys,
       to_hashtbl,
       hashable_s,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        create$0,
        of_list$0,
        length,
        is_empty,
        iter,
        fold,
        fold_result,
        fold_until,
        exists,
        for_all,
        count,
        sum,
        find,
        find_map,
        to_list,
        to_array,
        min_elt,
        max_elt,
        mem,
        copy,
        add,
        strict_add,
        strict_add_exn,
        remove,
        strict_remove,
        strict_remove_exn,
        clear,
        equal,
        filter,
        filter_inplace,
        inter,
        union,
        diff,
        of_hashtbl_keys,
        to_hashtbl],
       Creators,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(16, Base_Hash_set, "Base__Hash_set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int, Base__Int63, Base__Int64, Base__Int_string_conversions, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Base__Word_size, Sexplib0__Sexp_conv_error, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_out_of_range_0 = " out of range [0, ",
    cst_s_1e = "%s%.1e",
    cst_is_too_large = ") is too large",
    cst_is_too_small_or_NaN = ") is too small or NaN",
    cst$5 = ".",
    cst_Float_int63_round_down_exn = "Float.int63_round_down_exn: argument (",
    cst_Float_int63_round_nearest_ =
      "Float.int63_round_nearest_portable_alloc_exn: argument (",
    cst_Float_int63_round_up_exn_a = "Float.int63_round_up_exn: argument (",
    cst_Float_iround_down_exn_argu = "Float.iround_down_exn: argument (",
    cst_Float_iround_nearest_exn_a = "Float.iround_nearest_exn: argument (",
    cst_Float_iround_nearest_exn_a$0 =
      "Float.iround_nearest_exn: argument (%f) is too large",
    cst_Float_iround_up_exn_argume = "Float.iround_up_exn: argument (",
    cst_Infinite = "Infinite",
    cst_Nan = "Nan",
    cst_Normal = "Normal",
    cst_Subnormal = "Subnormal",
    cst_Zero = "Zero",
    cst_infinite = "infinite",
    cst_nan$1 = "nan",
    cst_normal = "normal",
    cst_src_float_ml = "src/float.ml",
    cst_subnormal = "subnormal",
    cst_zero = "zero",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_float_compare = runtime.caml_float_compare,
    caml_format_float = runtime.caml_format_float,
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_or = runtime.caml_int64_or,
    caml_int_compare = runtime.caml_int_compare,
    caml_log10_float = runtime.caml_log10_float,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = "-",
    cst$0 = cst$5,
    cst = cst$5,
    all = [0, 0, [0, 1, [0, 2, [0, 3, [0, 4, 0]]]]],
    error_source_007 = "float.ml.Class.t",
    t_sexp_grammar$0 =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Infinite, 0]],
         [0,
          [1, [0, cst_Nan, 0]],
          [0,
           [1, [0, cst_Normal, 0]],
           [0, [1, [0, cst_Subnormal, 0]], [0, [1, [0, cst_Zero, 0]], 0]]]]]]],
    module_name = "Base.Float",
    Base_Printf = global_data.Base__Printf,
    Base_Or_error = global_data.Base__Or_error,
    Base_Int = global_data.Base__Int,
    Base_Int63 = global_data.Base__Int63,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Int64 = global_data.Base__Int64,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_String = global_data.Base__String,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Char = global_data.Base__Char,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Word_size = global_data.Base__Word_size,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    round_up = Base_Float0[1],
    round_down = Base_Float0[2],
    mod_float = Base_Float0[3],
    modf = Base_Float0[4],
    float_of_string = Base_Float0[5],
    float_of_string_opt = Base_Float0[6],
    nan = Base_Float0[7],
    max_value = Base_Float0[8],
    neg_infinity = Base_Float0[9],
    max_finite_value = Base_Float0[10],
    epsilon_float = Base_Float0[11],
    classify_float = Base_Float0[12],
    abs_float = Base_Float0[13],
    is_integer = Base_Float0[14],
    symbol = Base_Float0[15],
    symbol$0 = Base_Float0[16],
    frexp = Base_Float0[17],
    ldexp = Base_Float0[18],
    is_nan = Base_Float0[19],
    to_int64_preserve_order = Base_Float0[20],
    to_int64_preserve_order_exn = Base_Float0[21],
    of_int64_preserve_order = Base_Float0[22],
    one_ulp = Base_Float0[23],
    upper_bound_for_int = Base_Float0[24],
    lower_bound_for_int = Base_Float0[26],
    clamp_unchecked = Base_Float0[28],
    box = Base_Float0[29],
    raise_s = Base_Error[32],
    hash_fold_t = Base_Import[209],
    func = Base_Import[223],
    _R_ = [0, [8, [0, 0, 4], 0, [0, 8], 0], "%.8G"],
    _P_ =
      [0,
       [11,
        "exponent ",
        [4, 0, 0, 0, [11, cst_out_of_range_0, [4, 0, 0, 0, [12, 93, 0]]]]],
       "exponent %d out of range [0, %d]"],
    _Q_ =
      [0,
       [11,
        "mantissa ",
        [2, 0, [11, cst_out_of_range_0, [2, 0, [12, 93, 0]]]]],
       "mantissa %s out of range [0, %s]"],
    cst_Float_sign_exn_of_NAN = "Float.sign_exn of NAN",
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _L_ = [0, cst_src_float_ml, 865, 2],
    _K_ =
      [0,
       [11,
        "Float.round_significant: invalid argument significant_digits:",
        [4, 0, 0, 0, 0]],
       "Float.round_significant: invalid argument significant_digits:%d"],
    _J_ = [0, [8, [0, 0, 3], 0, 1, 0], "%.*g"],
    _I_ = [0, "p"],
    cst_t = "t",
    cst_g = "g",
    cst_m = "m",
    cst_k = "k",
    _F_ = [0, cst_src_float_ml, 703, 8],
    _E_ = [0, cst_src_float_ml, 706, 8],
    _A_ = [0, cst_src_float_ml, 713, 8],
    _B_ = [0, cst_src_float_ml, 714, 8],
    _C_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [12, 32, 0]]]], "%s%d%s "],
    _D_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [4, 0, 0, 0, 0]]]], "%s%d%s%d"],
    _z_ = [0, cst_src_float_ml, 690, 8],
    cst_0 = ".0",
    _G_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    _H_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    cst_inf$1 = "-inf  ",
    cst_inf$2 = "inf  ",
    cst_nan$0 = "nan  ",
    cst_sexp = "sexp",
    cst_sexp_of_float_produced_str = "[sexp_of_float] produced strange sexp",
    _w_ =
      [0,
       [11, "to_string_hum: invalid argument ~decimals=", [4, 0, 0, 0, 0]],
       "to_string_hum: invalid argument ~decimals=%d"],
    _x_ = [0, [8, [0, 1, 0], 0, 1, 0], "%+.*f"],
    _y_ = [0, [8, [0, 0, 0], 0, 1, 0], "%.*f"],
    cst_inf = "inf",
    cst_inf$0 = "-inf",
    cst_nan = cst_nan$1,
    _r_ = [0, cst_Infinite],
    _s_ = [0, cst_Nan],
    _t_ = [0, cst_Normal],
    _u_ = [0, cst_Subnormal],
    _v_ = [0, cst_Zero],
    _p_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large"],
    _q_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN"],
    _n_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too large"],
    _o_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too small or NaN"],
    _l_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too large"],
    _m_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too small or NaN"],
    _j_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _k_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small or NaN"],
    _h_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _i_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, ") is too small", 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small"],
    _f_ =
      [0,
       [11,
        "Float.iround_towards_zero_exn: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Float.iround_towards_zero_exn: argument (%f) is out of range or NaN"],
    _d_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_down_exn: argument (%f) is too large"],
    _e_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_down_exn: argument (%f) is too small or NaN"],
    _b_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_up_exn: argument (%f) is too large"],
    _c_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_up_exn: argument (%f) is too small or NaN"],
    _a_ = [0, [11, "Float.of_string ", [2, 0, 0]], "Float.of_string %s"];
   function hash(x){return caml_call1(func, x);}
   var
    globalize = Base_Import[283],
    t_of_sexp = Base_Import[164],
    sexp_of_t = Base_Import[140],
    t_sexp_grammar = Base_Import[186],
    hashable = [0, hash, caml_float_compare, sexp_of_t],
    compare = caml_float_compare,
    include = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function to_float(x){return x;}
   function of_float(x){return x;}
   function of_string(s){
    try{var _a3_ = caml_call1(float_of_string, s); return _a3_;}
    catch(_a4_){return caml_call3(Base_Printf[7], _a_, s, 0);}
   }
   function to_string(x){
    var
     y = caml_format_float("%.15g", x),
     y$0 =
       caml_call1(float_of_string, y) == x ? y : caml_format_float("%.17g", x),
     l = runtime.caml_ml_string_length(y$0),
     i = 0;
    for(;;){
     if(l <= i) return caml_call2(Base_Import[112], y$0, cst);
     var match = runtime.caml_string_get(y$0, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return y$0;
     }
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   var
    min_positive_subnormal_value = caml_call2(symbol, 2., -1074.),
    min_positive_normal_value = caml_call2(symbol, 2., -1022.),
    of_int = Base_Int[4],
    to_int = Base_Int[3],
    zero = 0.,
    one = 1.,
    minus_one = -1.,
    pi = 3.141592653589793,
    sqrt_pi = 1.772453850905516,
    sqrt_2pi = 2.5066282746310007,
    euler = 0.5772156649015329;
   function of_int63(i){return caml_call1(Base_Int63[3], i);}
   var
    of_int64 = runtime.caml_int64_to_float,
    to_int64 = runtime.caml_int64_of_float,
    iround_lbound = caml_call1(lower_bound_for_int, Base_Int[64]),
    iround_ubound = caml_call1(upper_bound_for_int, Base_Int[64]);
   function iround_up(t){
    if(! (0. < t))
     return iround_lbound <= t ? [0, caml_call1(Base_Int[63], t)] : 0;
    var t$0 = caml_call1(round_up, t);
    return t$0 <= iround_ubound ? [0, caml_call1(Base_Int[63], t$0)] : 0;
   }
   function iround_up_exn(t){
    if(0. < t){
     var t$0 = caml_call1(round_up, t);
     if(t$0 <= iround_ubound) return caml_call1(Base_Int[63], t$0);
     var _a1_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _b_, _a1_, 0);
    }
    if(iround_lbound <= t) return caml_call1(Base_Int[63], t);
    var _a2_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _c_, _a2_, 0);
   }
   function iround_down(t){
    if(0. <= t)
     return t <= iround_ubound ? [0, caml_call1(Base_Int[63], t)] : 0;
    var t$0 = caml_call1(round_down, t);
    return iround_lbound <= t$0 ? [0, caml_call1(Base_Int[63], t$0)] : 0;
   }
   function iround_down_exn(t){
    if(0. <= t){
     if(t <= iround_ubound) return caml_call1(Base_Int[63], t);
     var _aZ_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _d_, _aZ_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(iround_lbound <= t$0) return caml_call1(Base_Int[63], t$0);
    var _a0_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _e_, _a0_, 0);
   }
   function iround_towards_zero(t){
    if(iround_lbound <= t && t <= iround_ubound)
     return [0, caml_call1(Base_Int[63], t)];
    return 0;
   }
   function iround_towards_zero_exn(t){
    if(iround_lbound <= t && t <= iround_ubound)
     return caml_call1(Base_Int[63], t);
    var _aY_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _f_, _aY_, 0);
   }
   var
    _g_ = caml_call2(symbol, 2., 52.),
    round_nearest_lb = caml_call1(Base_Import[114], _g_),
    round_nearest_ub = caml_call2(symbol, 2., 52.),
    one_ulp_less_than_half = caml_call2(one_ulp, 759637122, 0.5);
   function add_half_for_round_nearest(t){
    var _aX_ = t == one_ulp_less_than_half ? one_ulp_less_than_half : 0.5;
    return caml_call2(Base_Import[92], t, _aX_);
   }
   function iround_nearest_32(t){
    if(0. <= t){
     var t$0 = add_half_for_round_nearest(t);
     return t$0 <= iround_ubound ? [0, caml_call1(Base_Int[63], t$0)] : 0;
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    return iround_lbound <= t$1 ? [0, caml_call1(Base_Int[63], t$1)] : 0;
   }
   function iround_nearest_64(t){
    if(0. <= t){
     if(! (t < round_nearest_ub))
      return t <= iround_ubound ? [0, caml_call1(Base_Int[63], t)] : 0;
     var _aV_ = add_half_for_round_nearest(t);
     return [0, caml_call1(Base_Int[63], _aV_)];
    }
    if(! (round_nearest_lb < t))
     return iround_lbound <= t ? [0, caml_call1(Base_Int[63], t)] : 0;
    var _aW_ = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    return [0, caml_call1(Base_Int[63], _aW_)];
   }
   var
    iround_nearest_64$0 =
      Base_Word_size[3] ? iround_nearest_64 : iround_nearest_32;
   function iround_nearest_exn_32(t){
    if(0. <= t){
     var t$0 = add_half_for_round_nearest(t);
     if(t$0 <= iround_ubound) return caml_call1(Base_Int[63], t$0);
     var _aT_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _h_, _aT_, 0);
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    if(iround_lbound <= t$1) return caml_call1(Base_Int[63], t$1);
    var _aU_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _i_, _aU_, 0);
   }
   function iround_nearest_exn_64(t){
    if(0. <= t){
     if(t < round_nearest_ub){
      var _aP_ = add_half_for_round_nearest(t);
      return caml_call1(Base_Int[63], _aP_);
     }
     if(t <= iround_ubound) return caml_call1(Base_Int[63], t);
     var _aQ_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _j_, _aQ_, 0);
    }
    if(round_nearest_lb < t){
     var _aR_ = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
     return caml_call1(Base_Int[63], _aR_);
    }
    if(iround_lbound <= t) return caml_call1(Base_Int[63], t);
    var _aS_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _k_, _aS_, 0);
   }
   var
    iround_nearest_exn =
      Base_Word_size[3] ? iround_nearest_exn_64 : iround_nearest_exn_32;
   function iround_exn(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? iround_towards_zero_exn(t)
              : iround_nearest_exn(t)
            : 759637122 <= dir ? iround_down_exn(t) : iround_up_exn(t);
   }
   function iround(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    try{var _aN_ = [0, iround_exn([0, dir], t)]; return _aN_;}
    catch(_aO_){return 0;}
   }
   function is_inf(t){
    return caml_call2(Base_Import[96], 1., t) == 0. ? 1 : 0;
   }
   function is_finite(t){
    return caml_call2(Base_Import[94], t, t) == 0. ? 1 : 0;
   }
   function min_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1(is_nan, x) ? y : x < y ? x : y;
   }
   function max_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1(is_nan, x) ? y : y < x ? x : y;
   }
   var
    add = Base_Import[92],
    sub = Base_Import[94],
    neg = Base_Import[114],
    scale = Base_Import[90];
   function square(x){return caml_call2(Base_Import[90], x, x);}
   function fractional(t){return caml_call1(Base_Import[125], t);}
   function integral(t){return caml_call1(Base_Import[127], t);}
   function round_towards_zero(t){
    return 0. <= t ? caml_call1(round_down, t) : caml_call1(round_up, t);
   }
   function round_nearest_inline(t){
    if(round_nearest_lb < t && t < round_nearest_ub)
     return caml_call1(round_down, add_half_for_round_nearest(t));
    return caml_call2(Base_Import[92], t, 0.);
   }
   function round_nearest(t){return round_nearest_inline(t);}
   function round_nearest_half_to_even(t){
    if(! (t <= round_nearest_lb) && ! (round_nearest_ub <= t)){
     var
      floor = caml_call1(round_down, t),
      ceil_or_succ = caml_call2(Base_Import[92], floor, 1.),
      diff_floor = caml_call2(Base_Import[94], t, floor),
      diff_ceil = caml_call2(Base_Import[94], ceil_or_succ, t);
     return diff_floor < diff_ceil
             ? floor
             : diff_ceil
               < diff_floor
               ? ceil_or_succ
               : caml_call2(mod_float, floor, 2.) == 0. ? floor : ceil_or_succ;
    }
    return caml_call2(Base_Import[92], t, 0.);
   }
   var
    int63_round_lbound = caml_call1(lower_bound_for_int, Base_Int63[87]),
    int63_round_ubound = caml_call1(upper_bound_for_int, Base_Int63[87]);
   function int63_round_up_exn(t){
    if(0. < t){
     var t$0 = caml_call1(round_up, t);
     if(t$0 <= int63_round_ubound) return caml_call1(Base_Int63[86], t$0);
     var _aL_ = caml_call1(Base_Float0[29], t);
     return caml_call3(Base_Printf[7], _l_, _aL_, 0);
    }
    if(int63_round_lbound <= t) return caml_call1(Base_Int63[86], t);
    var _aM_ = caml_call1(Base_Float0[29], t);
    return caml_call3(Base_Printf[7], _m_, _aM_, 0);
   }
   function int63_round_down_exn(t){
    if(0. <= t){
     if(t <= int63_round_ubound) return caml_call1(Base_Int63[86], t);
     var _aJ_ = caml_call1(Base_Float0[29], t);
     return caml_call3(Base_Printf[7], _n_, _aJ_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(int63_round_lbound <= t$0) return caml_call1(Base_Int63[86], t$0);
    var _aK_ = caml_call1(Base_Float0[29], t);
    return caml_call3(Base_Printf[7], _o_, _aK_, 0);
   }
   function int63_round_nearest_portable_a(t0){
    var t = round_nearest_inline(t0);
    if(0. < t){
     if(t <= int63_round_ubound) return caml_call1(Base_Int63[86], t);
     var _aH_ = caml_call1(box, t0);
     return caml_call3(Base_Printf[7], _p_, _aH_, 0);
    }
    if(int63_round_lbound <= t) return caml_call1(Base_Int63[86], t);
    var _aI_ = caml_call1(box, t0);
    return caml_call3(Base_Printf[7], _q_, _aI_, 0);
   }
   function int63_round_nearest_arch64_noa(f){
    var _aG_ = iround_nearest_exn(f);
    return caml_call1(Base_Int63[100], _aG_);
   }
   var
    int63_round_nearest_exn =
      Base_Word_size[3]
       ? int63_round_nearest_arch64_noa
       : int63_round_nearest_portable_a;
   function round(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192 <= dir ? round_towards_zero(t) : round_nearest(t)
            : 759637122
              <= dir
              ? caml_call1(round_down, t)
              : caml_call1(round_up, t);
   }
   var compare_local = caml_int_compare, compare$0 = caml_int_compare;
   function t_of_sexp$0(sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var _aA_ = sexp_008[1], _aB_ = caml_string_compare(_aA_, cst_infinite);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          if(0 <= _aB_){
           if(0 < _aB_){
            if(! caml_string_notequal(_aA_, cst_nan$1)) break e;
            if(! caml_string_notequal(_aA_, cst_normal)) break d;
            if(! caml_string_notequal(_aA_, cst_subnormal)) break c;
            if(caml_string_notequal(_aA_, cst_zero)) break a;
            break b;
           }
          }
          else if(caml_string_notequal(_aA_, cst_Infinite)){
           if(! caml_string_notequal(_aA_, cst_Nan)) break e;
           if(! caml_string_notequal(_aA_, cst_Normal)) break d;
           if(! caml_string_notequal(_aA_, cst_Subnormal)) break c;
           if(caml_string_notequal(_aA_, cst_Zero)) break a;
           break b;
          }
          return 0;
         }
         return 1;
        }
        return 2;
       }
       return 3;
      }
      return 4;
     }
     var _aC_ = sexp_008[1];
     if(! _aC_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_007, sexp_008);
     var _aD_ = _aC_[1];
     if(0 !== _aD_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_007, sexp_008);
     var _aE_ = _aD_[1], _aF_ = caml_string_compare(_aE_, cst_infinite);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         if(0 <= _aF_){
          if(0 < _aF_){
           if(! caml_string_notequal(_aE_, cst_nan$1)) break e;
           if(! caml_string_notequal(_aE_, cst_normal)) break d;
           if(! caml_string_notequal(_aE_, cst_subnormal)) break c;
           if(caml_string_notequal(_aE_, cst_zero)) break a;
           break b;
          }
         }
         else if(caml_string_notequal(_aE_, cst_Infinite)){
          if(! caml_string_notequal(_aE_, cst_Nan)) break e;
          if(! caml_string_notequal(_aE_, cst_Normal)) break d;
          if(! caml_string_notequal(_aE_, cst_Subnormal)) break c;
          if(caml_string_notequal(_aE_, cst_Zero)) break a;
          break b;
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_007, sexp_008);
   }
   function sexp_of_t$0(param){
    switch(param){
      case 0:
       return _r_;
      case 1:
       return _s_;
      case 2:
       return _t_;
      case 3:
       return _u_;
      default: return _v_;
    }
   }
   function to_string$0(t){
    var _az_ = sexp_of_t$0(t);
    return caml_call1(Base_Import[160], _az_);
   }
   function of_string$0(s){
    return t_of_sexp$0(caml_call1(Base_Import[136], s));
   }
   function classify(t){
    switch(caml_call1(classify_float, t)){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      case 3:
       return 0;
      default: return 1;
    }
   }
   function insert_underscores(opt, _aw_, string){
    if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
    if(_aw_) var sth$0 = _aw_[1], strip_zero = sth$0; else var strip_zero = 0;
    var match = caml_call2(Base_String[100], string, 46);
    if(! match)
     return caml_call2(Base_Int_string_conversions[6], string, delimiter);
    var
     match$0 = match[1],
     right = match$0[2],
     left = match$0[1],
     left$0 = caml_call2(Base_Int_string_conversions[6], left, delimiter);
    if(strip_zero)
     var
      _ax_ = [0, function(c){return caml_call2(Base_Char[12], c, 48);}],
      right$0 = caml_call2(Base_String[108], _ax_, right);
    else
     var right$0 = right;
    if(! caml_string_notequal(right$0, cst$4)) return left$0;
    var _ay_ = caml_call2(Base_Import[112], cst$0, right$0);
    return caml_call2(Base_Import[112], left$0, _ay_);
   }
   function to_string_hum(delimiter, opt, strip_zero, _av_, f){
    if(opt) var sth = opt[1], decimals = sth; else var decimals = 3;
    if(_av_)
     var sth$0 = _av_[1], explicit_plus = sth$0;
    else
     var explicit_plus = 0;
    if(decimals < 0) caml_call3(Base_Printf[7], _w_, decimals, 0);
    var match = classify(f);
    if(1 === match) return cst_nan;
    if(! match) return 0. < f ? cst_inf : cst_inf$0;
    var
     s =
       explicit_plus
        ? caml_call3(Base_Printf[2], _x_, decimals, f)
        : caml_call3(Base_Printf[2], _y_, decimals, f);
    return insert_underscores(delimiter, strip_zero, s);
   }
   function sexp_of_t$1(t){
    var sexp = caml_call1(sexp_of_t, t);
    if(1009018843 <= Base_Sexp[19][1]) return sexp;
    if(0 === sexp[0]){
     var string = sexp[1];
     return caml_call4(Base_String[70], 0, 0, string, 69)
             ? sexp
             : [0, insert_underscores(0, 0, string)];
    }
    var _au_ = [0, [0, cst_sexp, caml_call1(Base_Sexp[5], sexp)], 0];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[10], cst_sexp_of_float_produced_str, _au_));
   }
   function to_padded_compact_string_custo
   (t, opt, kilo, mega, giga, tera, peta, param){
    if(opt) var sth = opt[1], prefix = sth; else var prefix = cst$2;
    var match = classify(t);
    if(1 === match) return cst_nan$0;
    if(! match) return t < 0. ? cst_inf$1 : cst_inf$2;
    function go(t){
     function conv(mag, numerator, denominator){
      a:
      {
       if(denominator == 100. && 999.95 <= numerator) break a;
       if
        (100000. <= denominator
         &&
          round_nearest(caml_call2(Base_Import[90], denominator, 9.9995))
          <= numerator)
        break a;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
      }
      if
       (!
        (numerator
        < round_nearest(caml_call2(Base_Import[90], denominator, 9999.5))))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
      var
       k =
         caml_call1
          (round_down, caml_call2(Base_Import[96], numerator, denominator)),
       lower = caml_call2(Base_Import[90], denominator, k),
       _at_ = caml_call2(Base_Import[92], k, 1.),
       higher = caml_call2(Base_Import[90], denominator, _at_),
       diff_right = caml_call2(Base_Import[94], higher, numerator),
       diff_left = caml_call2(Base_Import[94], numerator, lower),
       k$0 = iround_nearest_exn(k),
       k$1 =
         diff_right < diff_left
          ? caml_call2(Base_Import[91], k$0, 1)
          : diff_left
            < diff_right
            ? k$0
            : 0
              === caml_call2(Base_Import[122], k$0, 2)
              ? k$0
              : caml_call2(Base_Import[91], k$0, 1),
       d = caml_call2(Base_Import[122], k$1, 10),
       i = caml_call2(Base_Import[95], k$1, 10);
      if(0 <= i && 1000 > i){
       if(0 <= d && 10 > d)
        return 0 === d
                ? caml_call4(Base_Printf[2], _C_, prefix, i, mag)
                : caml_call5(Base_Printf[2], _D_, prefix, i, mag, d);
       throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     }
     if(! (t < 999.95)){
      if(t < 999950.) return conv(kilo, t, 100.);
      if(t < 999950000.) return conv(mega, t, 100000.);
      if(t < 999950000000.) return conv(giga, t, 100000000.);
      if(t < 999950000000000.) return conv(tera, t, 100000000000.);
      if(! peta) return caml_call3(Base_Printf[2], _H_, prefix, t);
      var peta$0 = peta[1];
      return t < 999950000000000000.
              ? conv(peta$0, t, 100000000000000.)
              : caml_call3(Base_Printf[2], _G_, prefix, t);
     }
     if(0. <= t && t < 999.95){
      var
       x = caml_call2(Base_Import[112], prefix, caml_format_float("%.1f", t));
      if(! caml_call2(Base_String[96], x, cst_0)) return x;
      var
       x$0 = caml_call1(Base_Bytes0[21], x),
       n = runtime.caml_ml_bytes_length(x$0);
      caml_bytes_set(x$0, caml_call2(Base_Import[93], n, 1), 32);
      caml_bytes_set(x$0, caml_call2(Base_Import[93], n, 2), 32);
      return runtime.caml_string_of_bytes(x$0);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    }
    if(0. <= t) return go(t);
    var _as_ = go(caml_call1(Base_Import[114], t));
    return caml_call2(Base_Import[112], cst$1, _as_);
   }
   function to_padded_compact_string(t){
    return to_padded_compact_string_custo
            (t, 0, cst_k, cst_m, cst_g, cst_t, _I_, 0);
   }
   function int_pow(x, n){
    if(0 === n) return 1.;
    var
     x$0 = [0, caml_call2(Base_Import[92], x, -0.)],
     n$0 = [0, n],
     accum = [0, 1.];
    if(n$0[1] < 0){
     x$0[1] = caml_call2(Base_Import[96], 1., x$0[1]);
     n$0[1] = caml_call1(Base_Import[113], n$0[1]);
     if(n$0[1] < 0){accum[1] = x$0[1]; n$0[1] += -1;}
    }
    for(;;){
     if(1 >= n$0[1]) return caml_call2(Base_Import[90], x$0[1], accum[1]);
     if(0 !== caml_call2(Base_Import[116], n$0[1], 1))
      accum[1] = caml_call2(Base_Import[90], x$0[1], accum[1]);
     x$0[1] = caml_call2(Base_Import[90], x$0[1], x$0[1]);
     n$0[1] = caml_call2(Base_Import[120], n$0[1], 1);
    }
   }
   function round_gen(x, how){
    if(x == 0.) return 0.;
    if(! is_finite(x)) return x;
    if(555917426 <= how[1])
     var
      sd = how[2],
      _ao_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      dd = caml_call2(Base_Import[93], sd, _ao_),
      dd$0 = dd,
      sd$0 = sd;
    else
     var
      dd$1 = how[2],
      _ar_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      sd$1 = caml_call2(Base_Import[91], dd$1, _ar_),
      dd$0 = dd$1,
      sd$0 = sd$1;
    if(0 > sd$0) return 0.;
    if(17 <= sd$0) return x;
    var abs_dd = caml_call1(Base_Int[78], dd$0);
    if(22 >= abs_dd && 16 > sd$0){
     var order = int_pow(10., abs_dd);
     if(0 <= dd$0){
      var
       _ap_ =
         round_nearest_half_to_even(caml_call2(Base_Import[90], x, order));
      return caml_call2(Base_Import[96], _ap_, order);
     }
     var
      _aq_ = round_nearest_half_to_even(caml_call2(Base_Import[96], x, order));
     return caml_call2(Base_Import[90], _aq_, order);
    }
    return of_string(caml_call3(Base_Printf[2], _J_, sd$0, x));
   }
   function round_significant(x, significant_digits){
    return 0 < significant_digits
            ? round_gen(x, [0, 555917426, significant_digits])
            : caml_call3(Base_Printf[7], _K_, significant_digits, 0);
   }
   function round_decimal(x, decimal_digits){
    return round_gen(x, [0, -352548012, decimal_digits]);
   }
   function between(t, low, high){
    var _am_ = low <= t ? 1 : 0, _an_ = _am_ ? t <= high ? 1 : 0 : _am_;
    return _an_;
   }
   function clamp_exn(t, min, max){
    if(min <= max) return caml_call3(clamp_unchecked, t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
   }
   function clamp(t, min, max){
    if(min <= max) return [0, caml_call3(clamp_unchecked, t, min, max)];
    var
     _aj_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _ak_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _aj_],
     _al_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _ak_);
    return caml_call1(Base_Or_error[39], _al_);
   }
   var
    symbol$1 = Base_Import[92],
    symbol$2 = Base_Import[94],
    symbol$3 = Base_Import[90],
    symbol$4 = Base_Import[96],
    symbol$5 = Base_Import[114];
   function sign_exn(t){
    if(0. < t) return 2;
    if(t < 0.) return 0;
    if(t == 0.) return 1;
    var
     _ah_ = [0, [0, cst$3, sexp_of_t$1(t)], 0],
     _ai_ = caml_call2(Base_Sexp[10], cst_Float_sign_exn_of_NAN, _ah_);
    return caml_call1(Base_Error[32], _ai_);
   }
   function sign_or_nan(t){return 0. < t ? 2 : t < 0. ? 0 : t == 0. ? 1 : 3;}
   function ieee_negative(t){
    var bits = caml_int64_bits_of_float(t);
    return runtime.caml_lessthan(bits, Stdlib_Int64[1]);
   }
   var
    _M_ = Base_Int64[37],
    exponent_mask64 =
      runtime.caml_int64_sub
       (caml_call2(Base_Int64[53], Base_Int64[37], 11), _M_),
    exponent_mask = caml_call1(Base_Int64[6], exponent_mask64),
    _N_ = Base_Int63[43],
    _O_ = caml_call2(Base_Int63[76], Base_Int63[43], 52),
    mantissa_mask = caml_call2(Base_Int63[46], _O_, _N_),
    mantissa_mask64 = caml_call1(Base_Int63[83], mantissa_mask),
    mantissa_bits = 52;
   function ieee_exponent(t){
    var
     bits = caml_int64_bits_of_float(t),
     _ag_ = caml_call2(Base_Int64[67], bits, mantissa_bits);
    return runtime.caml_int64_to_int32
            (caml_call2(Base_Int64[48], _ag_, exponent_mask64));
   }
   function ieee_mantissa(t){
    var bits = caml_int64_bits_of_float(t);
    return caml_call1
            (Base_Int63[109], runtime.caml_int64_and(bits, mantissa_mask64));
   }
   function create_ieee_exn(negative, exponent, mantissa){
    if(caml_call2(Base_Int[48], exponent, exponent_mask) !== exponent)
     return caml_call4(Base_Printf[6], _P_, exponent, exponent_mask, 0);
    var _ad_ = caml_call2(Base_Int63[71], mantissa, mantissa_mask);
    if(caml_call2(Base_Int63[17], _ad_, mantissa)){
     var
      _ae_ = caml_call1(Base_Int63[11], mantissa_mask),
      _af_ = caml_call1(Base_Int63[11], mantissa);
     return caml_call4(Base_Printf[6], _Q_, _af_, _ae_, 0);
    }
    var
     sign_bits = negative ? Stdlib_Int64[10] : Stdlib_Int64[1],
     expt_bits =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_of_int32(exponent), 52),
     mant_bits = caml_call1(Base_Int63[83], mantissa),
     bits = caml_int64_or(sign_bits, caml_int64_or(expt_bits, mant_bits));
    return runtime.caml_int64_float_of_bits(bits);
   }
   function create_ieee(negative, exponent, mantissa){
    function _ac_(param){
     return create_ieee_exn(negative, exponent, mantissa);
    }
    return caml_call2(Base_Or_error[31], 0, _ac_);
   }
   function to_string$1(x){return caml_call2(Base_Printf[2], _R_, x);}
   function sexp_of_t$2(x){return [0, to_string$1(x)];}
   function of_string$1(x){return of_string(x);}
   var
    include$0 = caml_call1(Base_Comparable[14], [0, compare, sexp_of_t, zero]),
    sign = include$0[5];
   function is_positive(t){return 0. < t ? 1 : 0;}
   function is_non_negative(t){return 0. <= t ? 1 : 0;}
   function is_negative(t){return t < 0. ? 1 : 0;}
   function is_non_positive(t){return t <= 0. ? 1 : 0;}
   var
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$1[1];
   function symbol$6(_ab_, _aa_){return _ab_ != _aa_ ? 1 : 0;}
   function symbol$7(_$_, ___){return _$_ < ___ ? 1 : 0;}
   function symbol$8(_Z_, _Y_){return _Y_ < _Z_ ? 1 : 0;}
   function symbol$9(_X_, _W_){return _X_ == _W_ ? 1 : 0;}
   function symbol$10(_V_, _U_){return _V_ <= _U_ ? 1 : 0;}
   function symbol$11(_T_, _S_){return _S_ <= _T_ ? 1 : 0;}
   function of_float$0(x){return x;}
   var
    specialized_hash = Base_Import[223],
    Private =
      [0,
       box,
       clamp_unchecked,
       lower_bound_for_int,
       upper_bound_for_int,
       specialized_hash,
       one_ulp_less_than_half,
       int63_round_nearest_portable_a,
       int63_round_nearest_arch64_noa,
       iround_nearest_exn_64],
    include$2 = Base_Import[108],
    ascending = include$2[1],
    descending = include$2[2],
    compare_local$0 = include$2[3],
    equal_local = include$2[4];
   function min(x, y){
    if(! (x < y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   function max(x, y){
    if(! (y < x) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   var
    Base_Float =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       float_of_string_opt,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       equal_local,
       compare_local$0,
       invariant,
       min,
       max,
       nan,
       max_value,
       neg_infinity,
       max_value,
       neg_infinity,
       zero,
       one,
       minus_one,
       pi,
       sqrt_pi,
       sqrt_2pi,
       euler,
       epsilon_float,
       max_finite_value,
       min_positive_subnormal_value,
       min_positive_normal_value,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       of_int,
       to_int,
       of_int63,
       of_int64,
       to_int64,
       round,
       iround,
       iround_exn,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       round_nearest_half_to_even,
       iround_towards_zero,
       iround_down,
       iround_up,
       iround_nearest_64$0,
       iround_towards_zero_exn,
       iround_down_exn,
       iround_up_exn,
       iround_nearest_exn,
       int63_round_down_exn,
       int63_round_up_exn,
       int63_round_nearest_exn,
       iround_lbound,
       iround_ubound,
       int63_round_lbound,
       int63_round_ubound,
       round_significant,
       round_decimal,
       is_nan,
       is_inf,
       is_finite,
       is_integer,
       min_inan,
       max_inan,
       symbol$1,
       symbol$2,
       symbol$4,
       symbol$0,
       symbol$3,
       symbol,
       symbol$5,
       [0, fractional, integral],
       modf,
       mod_float,
       add,
       sub,
       neg,
       scale,
       abs_float,
       [0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$0,
        symbol,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs_float,
        neg,
        zero,
        of_int,
        of_float$0],
       [0, symbol$1, symbol$2, symbol$3, symbol$4, symbol$0, symbol, symbol$5],
       to_string,
       to_string_hum,
       to_padded_compact_string,
       to_padded_compact_string_custo,
       int_pow,
       square,
       ldexp,
       frexp,
       [0,
        compare$0,
        compare_local,
        all,
        t_of_sexp$0,
        sexp_of_t$0,
        t_sexp_grammar$0,
        of_string$0,
        to_string$0],
       classify,
       sign,
       sign_exn,
       sign_or_nan,
       create_ieee,
       create_ieee_exn,
       ieee_negative,
       ieee_exponent,
       ieee_mantissa,
       [0, t_of_sexp, sexp_of_t$2, t_sexp_grammar, of_string$1, to_string$1],
       Private];
   runtime.caml_register_global(191, Base_Float, "Base__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fieldslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Fieldslib = [0];
   runtime.caml_register_global(0, Base_Fieldslib, "Base__Fieldslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Buffer_intf = [0];
   runtime.caml_register_global(0, Base_Buffer_intf, "Base__Buffer_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer
//# unitInfo: Requires: Base__Blit, Base__Buffer_intf, Base__Bytes, Base__Import, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Bytes = global_data.Base__Bytes,
    Base_Import = global_data.Base__Import,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Blit = global_data.Base__Blit,
    create = Stdlib_Buffer[1],
    contents = Stdlib_Buffer[2],
    to_bytes = Stdlib_Buffer[3],
    nth = Stdlib_Buffer[6],
    length = Stdlib_Buffer[7],
    clear = Stdlib_Buffer[8],
    reset = Stdlib_Buffer[9],
    add_char = Stdlib_Buffer[12],
    add_string = Stdlib_Buffer[16],
    add_bytes = Stdlib_Buffer[17],
    add_buffer = Stdlib_Buffer[21],
    _a_ = Stdlib_Buffer[18],
    _b_ = Stdlib_Buffer[19];
   function add_substring(t, s, pos, len){
    return caml_call4(_a_, t, s, pos, len);
   }
   function add_subbytes(t, s, pos, len){
    return caml_call4(_b_, t, s, pos, len);
   }
   function sexp_of_t(t){
    var _c_ = caml_call1(contents, t);
    return caml_call1(Base_Import[136], _c_);
   }
   var
    caml_buffer_length = Stdlib_Buffer[7],
    caml_buffer_blit = Stdlib_Buffer[5];
   function create$0(len){return caml_call1(Base_Bytes[34], len);}
   var length$0 = runtime.caml_ml_bytes_length;
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    return caml_call5(caml_buffer_blit, src, src_pos, dst, dst_pos, len);
   }
   var
    To_bytes =
      caml_call1
       (caml_call1(Base_Blit[2], [0, caml_buffer_length]),
        [0, length$0, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes),
    Base_Buffer =
      [0,
       sexp_of_t,
       create,
       contents,
       to_bytes,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       To_string,
       nth,
       length,
       clear,
       reset,
       add_char,
       add_string,
       add_substring,
       add_bytes,
       add_subbytes,
       add_buffer];
   runtime.caml_register_global(4, Base_Buffer, "Base__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Backtrace
//# unitInfo: Requires: Base__Exn, Base__Int, Base__List, Base__String, Base__Sys0, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    elided_message = "<backtrace elided in test>",
    Base_Exn = global_data.Base__Exn,
    Base_Sys0 = global_data.Base__Sys0,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int = global_data.Base__Int,
    elide = [0, 0],
    cst_b = "b",
    cst_OCAMLRUNPARAM = "OCAMLRUNPARAM";
   function get(opt, param){
    if(opt)
     var sth = opt[1], at_most_num_frames = sth;
    else
     var at_most_num_frames = Base_Int[65];
    return runtime.caml_get_current_callstack(at_most_num_frames);
   }
   function to_string(t){
    return elide[1] ? elided_message : caml_call1(Stdlib_Printexc[14], t);
   }
   function to_string_list(t){
    var _i_ = to_string(t);
    return caml_call1(Base_String[104], _i_);
   }
   function sexp_of_t(t){
    function _g_(x){return [0, x];}
    var _h_ = to_string_list(t);
    return [1, caml_call2(Base_List[53], _h_, _g_)];
   }
   var set_recording = Stdlib_Printexc[7], am_recording = Stdlib_Printexc[8];
   function most_recent(param){return caml_call1(Stdlib_Printexc[12], 0);}
   function most_recent_for_exn(exn){
    return caml_call1(Base_Exn[18], exn) ? [0, most_recent(0)] : 0;
   }
   function with_recording(b, f){
    var saved = caml_call1(am_recording, 0);
    caml_call1(set_recording, b);
    function _f_(param){return caml_call1(set_recording, saved);}
    return caml_call2(Base_Exn[13], f, _f_);
   }
   function initialize_module(param){
    var match = caml_call1(Base_Sys0[21], cst_OCAMLRUNPARAM);
    if(match)
     var
      x = match[1],
      _a_ = Base_String[97],
      _b_ = function(_e_){return caml_call2(_a_, _e_, cst_b);},
      _c_ = caml_call2(Base_String[102], x, 44),
      ocamlrunparam_mentions_backtra = caml_call2(Base_List[23], _c_, _b_);
    else
     var ocamlrunparam_mentions_backtra = 0;
    var _d_ = 1 - ocamlrunparam_mentions_backtra;
    return _d_ ? caml_call1(set_recording, 1) : _d_;
   }
   var
    Base_Backtrace =
      [0,
       sexp_of_t,
       get,
       to_string,
       to_string_list,
       elide,
       [0,
        am_recording,
        set_recording,
        with_recording,
        most_recent,
        most_recent_for_exn],
       initialize_module];
   runtime.caml_register_global(9, Base_Backtrace, "Base__Backtrace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base
//# unitInfo: Requires: Base__Array, Base__Backtrace, Base__Bool, Base__Bytes, Base__Char, Base__Container_intf, Base__Error, Base__Exn, Base__Float, Base__Import, Base__Int, Base__Int32, Base__Int64, Base__Int_conversions, Base__Int_string_conversions, Base__List, Base__Nativeint, Base__Option, Base__Ref, Base__Sexp_with_comparable, Base__String, Base__T, Base__Unit, Shadow_stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ref = global_data.Base__Ref,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Array = global_data.Base__Array,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Base_Sexp_with_comparable = global_data.Base__Sexp_with_comparable,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Exn = global_data.Base__Exn,
    Base_Float = global_data.Base__Float,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    Base_Unit = global_data.Base__Unit,
    Base_Error = global_data.Base__Error,
    Base_Container_intf = global_data.Base__Container_intf,
    Base_Backtrace = global_data.Base__Backtrace,
    Exit = Shadow_stdlib[3],
    Not_found = Shadow_stdlib[4],
    max_int = Shadow_stdlib[8],
    min_int = Shadow_stdlib[9],
    infinity = Shadow_stdlib[11],
    neg_infinity = Shadow_stdlib[12],
    nan = Shadow_stdlib[13],
    max_float = Shadow_stdlib[14],
    min_float = Shadow_stdlib[15],
    epsilon_float = Shadow_stdlib[16],
    char_of_int = Shadow_stdlib[18],
    string_of_bool = Shadow_stdlib[19],
    bool_of_string_opt = Shadow_stdlib[20],
    bool_of_string = Shadow_stdlib[21],
    string_of_int = Shadow_stdlib[22],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_float = Shadow_stdlib[24],
    float_of_string_opt = Shadow_stdlib[25],
    stdin = Shadow_stdlib[27],
    stdout = Shadow_stdlib[28],
    stderr = Shadow_stdlib[29],
    print_char = Shadow_stdlib[30],
    print_string = Shadow_stdlib[31],
    print_bytes = Shadow_stdlib[32],
    print_int = Shadow_stdlib[33],
    print_float = Shadow_stdlib[34],
    print_endline = Shadow_stdlib[35],
    print_newline = Shadow_stdlib[36],
    prerr_char = Shadow_stdlib[37],
    prerr_string = Shadow_stdlib[38],
    prerr_bytes = Shadow_stdlib[39],
    prerr_int = Shadow_stdlib[40],
    prerr_float = Shadow_stdlib[41],
    prerr_endline = Shadow_stdlib[42],
    prerr_newline = Shadow_stdlib[43],
    read_line = Shadow_stdlib[44],
    read_int_opt = Shadow_stdlib[45],
    read_int = Shadow_stdlib[46],
    read_float_opt = Shadow_stdlib[47],
    read_float = Shadow_stdlib[48],
    open_out = Shadow_stdlib[49],
    open_out_bin = Shadow_stdlib[50],
    open_out_gen = Shadow_stdlib[51],
    flush = Shadow_stdlib[52],
    flush_all = Shadow_stdlib[53],
    output_char = Shadow_stdlib[54],
    output_string = Shadow_stdlib[55],
    output_bytes = Shadow_stdlib[56],
    output = Shadow_stdlib[57],
    output_substring = Shadow_stdlib[58],
    output_byte = Shadow_stdlib[59],
    output_binary_int = Shadow_stdlib[60],
    output_value = Shadow_stdlib[61],
    seek_out = Shadow_stdlib[62],
    pos_out = Shadow_stdlib[63],
    out_channel_length = Shadow_stdlib[64],
    close_out = Shadow_stdlib[65],
    close_out_noerr = Shadow_stdlib[66],
    set_binary_mode_out = Shadow_stdlib[67],
    open_in = Shadow_stdlib[68],
    open_in_bin = Shadow_stdlib[69],
    open_in_gen = Shadow_stdlib[70],
    input_char = Shadow_stdlib[71],
    input_line = Shadow_stdlib[72],
    input = Shadow_stdlib[73],
    really_input = Shadow_stdlib[74],
    really_input_string = Shadow_stdlib[75],
    input_byte = Shadow_stdlib[76],
    input_binary_int = Shadow_stdlib[77],
    input_value = Shadow_stdlib[78],
    seek_in = Shadow_stdlib[79],
    pos_in = Shadow_stdlib[80],
    in_channel_length = Shadow_stdlib[81],
    close_in = Shadow_stdlib[82],
    close_in_noerr = Shadow_stdlib[83],
    set_binary_mode_in = Shadow_stdlib[84],
    string_of_format = Shadow_stdlib[85],
    symbol = Shadow_stdlib[86],
    exit = Shadow_stdlib[87],
    at_exit = Shadow_stdlib[88],
    valid_float_lexem = Shadow_stdlib[89],
    unsafe_really_input = Shadow_stdlib[90],
    do_at_exit = Shadow_stdlib[91],
    do_domain_local_at_exit = Shadow_stdlib[92],
    globalize = Base_Sexp_with_comparable[1],
    hash_fold_t = Base_Sexp_with_comparable[2],
    hash = Base_Sexp_with_comparable[3],
    t_of_sexp = Base_Sexp_with_comparable[4],
    sexp_of_t = Base_Sexp_with_comparable[5],
    Not_found_s = Base_Sexp_with_comparable[6],
    Of_sexp_error = Base_Sexp_with_comparable[7],
    message = Base_Sexp_with_comparable[8],
    default_indent = Base_Sexp_with_comparable[9],
    pp_hum = Base_Sexp_with_comparable[10],
    pp_hum_indent = Base_Sexp_with_comparable[11],
    pp_mach = Base_Sexp_with_comparable[12],
    pp = Base_Sexp_with_comparable[13],
    to_string_hum = Base_Sexp_with_comparable[14],
    to_string_mach = Base_Sexp_with_comparable[15],
    to_string = Base_Sexp_with_comparable[16],
    of_float_style = Base_Sexp_with_comparable[17],
    of_int_style = Base_Sexp_with_comparable[18],
    t_sexp_grammar = Base_Sexp_with_comparable[19],
    invariant = Base_Sexp_with_comparable[20],
    of_string = Base_Sexp_with_comparable[21],
    symbol$0 = Base_Sexp_with_comparable[22],
    symbol$1 = Base_Sexp_with_comparable[23],
    symbol$2 = Base_Sexp_with_comparable[24],
    symbol$3 = Base_Sexp_with_comparable[25],
    symbol$4 = Base_Sexp_with_comparable[26],
    symbol$5 = Base_Sexp_with_comparable[27],
    equal = Base_Sexp_with_comparable[28],
    compare = Base_Sexp_with_comparable[29],
    min = Base_Sexp_with_comparable[30],
    max = Base_Sexp_with_comparable[31],
    ascending = Base_Sexp_with_comparable[32],
    descending = Base_Sexp_with_comparable[33],
    between = Base_Sexp_with_comparable[34],
    clamp_exn = Base_Sexp_with_comparable[35],
    clamp = Base_Sexp_with_comparable[36],
    comparator = Base_Sexp_with_comparable[37],
    compare_local = Base_Sexp_with_comparable[38],
    equal_local = Base_Sexp_with_comparable[39],
    Sexp =
      [0,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local],
    int_to_int32 = Base_Int_conversions[1],
    int_to_int32_exn = Base_Int_conversions[2],
    int_to_int32_trunc = Base_Int_conversions[3],
    int_to_int64 = Base_Int_conversions[4],
    int_to_nativeint = Base_Int_conversions[5],
    int32_to_int = Base_Int_conversions[6],
    int32_to_int_exn = Base_Int_conversions[7],
    int32_to_int_trunc = Base_Int_conversions[8],
    int32_to_int64 = Base_Int_conversions[9],
    int32_to_nativeint = Base_Int_conversions[10],
    int32_is_representable_as_int = Base_Int_conversions[11],
    int64_to_int = Base_Int_conversions[12],
    int64_to_int_exn = Base_Int_conversions[13],
    int64_to_int_trunc = Base_Int_conversions[14],
    int64_to_int32 = Base_Int_conversions[15],
    int64_to_int32_exn = Base_Int_conversions[16],
    int64_to_int32_trunc = Base_Int_conversions[17],
    int64_to_nativeint = Base_Int_conversions[18],
    int64_to_nativeint_exn = Base_Int_conversions[19],
    int64_to_nativeint_trunc = Base_Int_conversions[20],
    int64_fit_on_int63_exn = Base_Int_conversions[21],
    int64_is_representable_as_int6 = Base_Int_conversions[22],
    nativeint_to_int = Base_Int_conversions[23],
    nativeint_to_int_exn = Base_Int_conversions[24],
    nativeint_to_int_trunc = Base_Int_conversions[25],
    nativeint_to_int32 = Base_Int_conversions[26],
    nativeint_to_int32_exn = Base_Int_conversions[27],
    nativeint_to_int32_trunc = Base_Int_conversions[28],
    nativeint_to_int64 = Base_Int_conversions[29],
    num_bits_int = Base_Int_conversions[30],
    num_bits_int32 = Base_Int_conversions[31],
    num_bits_int64 = Base_Int_conversions[32],
    num_bits_nativeint = Base_Int_conversions[33],
    Make = Base_Int_string_conversions[1],
    Make_hex = Base_Int_string_conversions[2],
    Make_binary = Base_Int_string_conversions[3],
    sexp_of_int_style = Base_Int_string_conversions[4],
    insert_delimiter_every = Base_Int_string_conversions[5],
    insert_delimiter = Base_Int_string_conversions[6],
    insert_underscores = Base_Int_string_conversions[7],
    Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int32_is_representable_as_int,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint,
       Make,
       Make_hex,
       Make_binary,
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores],
    am_testing = Base_Import[129],
    Exported_for_specific_uses = [0, am_testing],
    compare_array_local = Base_Array[2],
    compare_array = Base_Array[1],
    equal_array_local = Base_Array[106],
    equal_array = Base_Array[105],
    globalize_array = Base_Array[3],
    array_of_sexp = Base_Array[4],
    sexp_of_array = Base_Array[5];
   function array_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Array[6], a_sexp_grammar);
   }
   var compare_bool_local = Base_Bool[28];
   function compare_bool(a, b){return caml_call2(compare_bool_local, a, b);}
   var equal_bool_local = Base_Bool[29];
   function equal_bool(a, b){return caml_call2(equal_bool_local, a, b);}
   var
    globalize_bool = Base_Bool[2],
    hash_fold_bool = Base_Bool[4],
    func = Base_Bool[5];
   function hash_bool(x){return caml_call1(func, x);}
   var
    bool_of_sexp = Base_Bool[6],
    sexp_of_bool = Base_Bool[7],
    bool_sexp_grammar = Base_Bool[3],
    compare_char_local = Base_Char[29];
   function compare_char(a, b){return caml_call2(compare_char_local, a, b);}
   var equal_char_local = Base_Char[28];
   function equal_char(a, b){return caml_call2(equal_char_local, a, b);}
   var
    globalize_char = Base_Char[2],
    hash_fold_char = Base_Char[4],
    func$0 = Base_Char[5];
   function hash_char(x){return caml_call1(func$0, x);}
   var
    char_of_sexp = Base_Char[6],
    sexp_of_char = Base_Char[7],
    char_sexp_grammar = Base_Char[3],
    sexp_of_exn = Base_Exn[1],
    compare_float_local = Base_Float[24];
   function compare_float(a, b){return caml_call2(compare_float_local, a, b);}
   var equal_float_local = Base_Float[23];
   function equal_float(a, b){return caml_call2(equal_float_local, a, b);}
   var
    globalize_float = Base_Float[1],
    hash_fold_float = Base_Float[5],
    func$1 = Base_Float[6];
   function hash_float(x){return caml_call1(func$1, x);}
   var
    float_of_sexp = Base_Float[7],
    sexp_of_float = Base_Float[8],
    float_sexp_grammar = Base_Float[2],
    compare_int_local = Base_Int[30];
   function compare_int(a, b){return caml_call2(compare_int_local, a, b);}
   var equal_int_local = Base_Int[31];
   function equal_int(a, b){return caml_call2(equal_int_local, a, b);}
   var
    globalize_int = Base_Int[1],
    hash_fold_int = Base_Int[7],
    func$2 = Base_Int[8];
   function hash_int(x){return caml_call1(func$2, x);}
   var
    int_of_sexp = Base_Int[9],
    sexp_of_int = Base_Int[10],
    int_sexp_grammar = Base_Int[2],
    compare_int32_local = Base_Int32[36];
   function compare_int32(a, b){return caml_call2(compare_int32_local, a, b);}
   var equal_int32_local = Base_Int32[37];
   function equal_int32(a, b){return caml_call2(equal_int32_local, a, b);}
   var
    globalize_int32 = Base_Int32[1],
    hash_fold_int32 = Base_Int32[7],
    func$3 = Base_Int32[8];
   function hash_int32(x){return caml_call1(func$3, x);}
   var
    int32_of_sexp = Base_Int32[9],
    sexp_of_int32 = Base_Int32[10],
    int32_sexp_grammar = Base_Int32[2],
    compare_int64_local = Base_Int64[30];
   function compare_int64(a, b){return caml_call2(compare_int64_local, a, b);}
   var equal_int64_local = Base_Int64[31];
   function equal_int64(a, b){return caml_call2(equal_int64_local, a, b);}
   var
    globalize_int64 = Base_Int64[1],
    hash_fold_int64 = Base_Int64[7],
    func$4 = Base_Int64[8];
   function hash_int64(x){return caml_call1(func$4, x);}
   var
    int64_of_sexp = Base_Int64[9],
    sexp_of_int64 = Base_Int64[10],
    int64_sexp_grammar = Base_Int64[2],
    compare_list_local = Base_List[2],
    compare_list = Base_List[1],
    equal_list_local = Base_List[155],
    equal_list = Base_List[154],
    globalize_list = Base_List[3],
    hash_fold_list = Base_List[4],
    list_of_sexp = Base_List[5],
    sexp_of_list = Base_List[6];
   function list_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_List[7], a_sexp_grammar);
   }
   var compare_nativeint_local = Base_Nativeint[36];
   function compare_nativeint(a, b){
    return caml_call2(compare_nativeint_local, a, b);
   }
   var equal_nativeint_local = Base_Nativeint[37];
   function equal_nativeint(a, b){
    return caml_call2(equal_nativeint_local, a, b);
   }
   var
    globalize_nativeint = Base_Nativeint[1],
    hash_fold_nativeint = Base_Nativeint[7],
    func$5 = Base_Nativeint[8];
   function hash_nativeint(x){return caml_call1(func$5, x);}
   var
    nativeint_of_sexp = Base_Nativeint[9],
    sexp_of_nativeint = Base_Nativeint[10],
    nativeint_sexp_grammar = Base_Nativeint[2],
    compare_option_local = Base_Option[2],
    compare_option = Base_Option[1],
    equal_option_local = Base_Option[7],
    equal_option = Base_Option[6],
    globalize_option = Base_Option[3],
    hash_fold_option = Base_Option[4],
    option_of_sexp = Base_Option[9],
    sexp_of_option = Base_Option[10];
   function option_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Option[5], a_sexp_grammar);
   }
   var
    compare_ref_local = Base_Ref[2],
    compare_ref = Base_Ref[1],
    equal_ref_local = Base_Ref[4],
    equal_ref = Base_Ref[3],
    globalize_ref = Base_Ref[5],
    ref_of_sexp = Base_Ref[6],
    sexp_of_ref = Base_Ref[7];
   function ref_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Ref[8], a_sexp_grammar);
   }
   var compare_string_local = Base_String[62];
   function compare_string(a, b){
    return caml_call2(compare_string_local, a, b);
   }
   var equal_string_local = Base_String[135];
   function equal_string(a, b){return caml_call2(equal_string_local, a, b);}
   var globalize_string = Base_String[1], hash_fold_string = Base_String[40];
   function hash_string(x){return runtime.Base_hash_string(x);}
   var
    string_of_sexp = Base_String[41],
    sexp_of_string = Base_String[42],
    string_sexp_grammar = Base_String[2],
    compare_bytes_local = Base_Bytes[26];
   function compare_bytes(a, b){return caml_call2(compare_bytes_local, a, b);}
   var equal_bytes_local = Base_Bytes[27];
   function equal_bytes(a, b){return caml_call2(equal_bytes_local, a, b);}
   var
    globalize_bytes = Base_Bytes[1],
    bytes_of_sexp = Base_Bytes[2],
    sexp_of_bytes = Base_Bytes[3],
    bytes_sexp_grammar = Base_Bytes[4],
    compare_unit_local = Base_Unit[29];
   function compare_unit(a, b){return caml_call2(compare_unit_local, a, b);}
   var equal_unit_local = Base_Unit[28];
   function equal_unit(a, b){return caml_call2(equal_unit_local, a, b);}
   var
    globalize_unit = Base_Unit[2],
    hash_fold_unit = Base_Unit[4],
    func$6 = Base_Unit[5];
   function hash_unit(x){return caml_call1(func$6, x);}
   var
    unit_of_sexp = Base_Unit[6],
    sexp_of_unit = Base_Unit[7],
    unit_sexp_grammar = Base_Unit[3],
    symbol$6 = Base_List[156][1],
    _a_ = Base_Int[75],
    symbol$7 = _a_[1],
    lnot = _a_[2],
    abs = _a_[3],
    zero = _a_[4],
    symbol$8 = _a_[5],
    symbol$9 = _a_[6],
    symbol$10 = _a_[7],
    _b_ = Base_Import[97],
    ascending$0 = _b_[1],
    descending$0 = _b_[2],
    max$0 = _b_[3],
    min$0 = _b_[4],
    include = Base_Float[100],
    symbol$11 = include[1],
    symbol$12 = include[2],
    symbol$13 = include[3],
    symbol$14 = include[4],
    symbol$15 = include[5],
    symbol$16 = include[6],
    symbol$17 = include[7],
    symbol$18 = Base_String[67],
    fst = Base_Import[125],
    snd = Base_Import[127],
    failwith = Base_Import[124],
    invalid_arg = Base_Import[126],
    raise_s = Base_Error[32],
    Export =
      [0,
       compare_array_local,
       compare_array,
       equal_array_local,
       equal_array,
       globalize_array,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar,
       compare_bool_local,
       compare_bool,
       equal_bool_local,
       equal_bool,
       globalize_bool,
       hash_fold_bool,
       hash_bool,
       bool_of_sexp,
       sexp_of_bool,
       bool_sexp_grammar,
       compare_char_local,
       compare_char,
       equal_char_local,
       equal_char,
       globalize_char,
       hash_fold_char,
       hash_char,
       char_of_sexp,
       sexp_of_char,
       char_sexp_grammar,
       sexp_of_exn,
       compare_float_local,
       compare_float,
       equal_float_local,
       equal_float,
       globalize_float,
       hash_fold_float,
       hash_float,
       float_of_sexp,
       sexp_of_float,
       float_sexp_grammar,
       compare_int_local,
       compare_int,
       equal_int_local,
       equal_int,
       globalize_int,
       hash_fold_int,
       hash_int,
       int_of_sexp,
       sexp_of_int,
       int_sexp_grammar,
       compare_int32_local,
       compare_int32,
       equal_int32_local,
       equal_int32,
       globalize_int32,
       hash_fold_int32,
       hash_int32,
       int32_of_sexp,
       sexp_of_int32,
       int32_sexp_grammar,
       compare_int64_local,
       compare_int64,
       equal_int64_local,
       equal_int64,
       globalize_int64,
       hash_fold_int64,
       hash_int64,
       int64_of_sexp,
       sexp_of_int64,
       int64_sexp_grammar,
       compare_list_local,
       compare_list,
       equal_list_local,
       equal_list,
       globalize_list,
       hash_fold_list,
       list_of_sexp,
       sexp_of_list,
       list_sexp_grammar,
       compare_nativeint_local,
       compare_nativeint,
       equal_nativeint_local,
       equal_nativeint,
       globalize_nativeint,
       hash_fold_nativeint,
       hash_nativeint,
       nativeint_of_sexp,
       sexp_of_nativeint,
       nativeint_sexp_grammar,
       compare_option_local,
       compare_option,
       equal_option_local,
       equal_option,
       globalize_option,
       hash_fold_option,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar,
       compare_ref_local,
       compare_ref,
       equal_ref_local,
       equal_ref,
       globalize_ref,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar,
       compare_string_local,
       compare_string,
       equal_string_local,
       equal_string,
       globalize_string,
       hash_fold_string,
       hash_string,
       string_of_sexp,
       sexp_of_string,
       string_sexp_grammar,
       compare_bytes_local,
       compare_bytes,
       equal_bytes_local,
       equal_bytes,
       globalize_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit_local,
       compare_unit,
       equal_unit_local,
       equal_unit,
       globalize_unit,
       hash_fold_unit,
       hash_unit,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$6,
       symbol$7,
       lnot,
       abs,
       zero,
       symbol$8,
       symbol$9,
       symbol$10,
       ascending$0,
       descending$0,
       max$0,
       min$0,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       fst,
       snd,
       failwith,
       invalid_arg,
       raise_s],
    compare_array_local$0 = Export[1],
    compare_array$0 = Export[2],
    equal_array_local$0 = Export[3],
    equal_array$0 = Export[4],
    globalize_array$0 = Export[5],
    array_of_sexp$0 = Export[6],
    sexp_of_array$0 = Export[7],
    array_sexp_grammar$0 = Export[8],
    compare_bool_local$0 = Export[9],
    compare_bool$0 = Export[10],
    equal_bool_local$0 = Export[11],
    equal_bool$0 = Export[12],
    globalize_bool$0 = Export[13],
    hash_fold_bool$0 = Export[14],
    hash_bool$0 = Export[15],
    bool_of_sexp$0 = Export[16],
    sexp_of_bool$0 = Export[17],
    bool_sexp_grammar$0 = Export[18],
    compare_char_local$0 = Export[19],
    compare_char$0 = Export[20],
    equal_char_local$0 = Export[21],
    equal_char$0 = Export[22],
    globalize_char$0 = Export[23],
    hash_fold_char$0 = Export[24],
    hash_char$0 = Export[25],
    char_of_sexp$0 = Export[26],
    sexp_of_char$0 = Export[27],
    char_sexp_grammar$0 = Export[28],
    sexp_of_exn$0 = Export[29],
    compare_float_local$0 = Export[30],
    compare_float$0 = Export[31],
    equal_float_local$0 = Export[32],
    equal_float$0 = Export[33],
    globalize_float$0 = Export[34],
    hash_fold_float$0 = Export[35],
    hash_float$0 = Export[36],
    float_of_sexp$0 = Export[37],
    sexp_of_float$0 = Export[38],
    float_sexp_grammar$0 = Export[39],
    compare_int_local$0 = Export[40],
    compare_int$0 = Export[41],
    equal_int_local$0 = Export[42],
    equal_int$0 = Export[43],
    globalize_int$0 = Export[44],
    hash_fold_int$0 = Export[45],
    hash_int$0 = Export[46],
    int_of_sexp$0 = Export[47],
    sexp_of_int$0 = Export[48],
    int_sexp_grammar$0 = Export[49],
    compare_int32_local$0 = Export[50],
    compare_int32$0 = Export[51],
    equal_int32_local$0 = Export[52],
    equal_int32$0 = Export[53],
    globalize_int32$0 = Export[54],
    hash_fold_int32$0 = Export[55],
    hash_int32$0 = Export[56],
    int32_of_sexp$0 = Export[57],
    sexp_of_int32$0 = Export[58],
    int32_sexp_grammar$0 = Export[59],
    compare_int64_local$0 = Export[60],
    compare_int64$0 = Export[61],
    equal_int64_local$0 = Export[62],
    equal_int64$0 = Export[63],
    globalize_int64$0 = Export[64],
    hash_fold_int64$0 = Export[65],
    hash_int64$0 = Export[66],
    int64_of_sexp$0 = Export[67],
    sexp_of_int64$0 = Export[68],
    int64_sexp_grammar$0 = Export[69],
    compare_list_local$0 = Export[70],
    compare_list$0 = Export[71],
    equal_list_local$0 = Export[72],
    equal_list$0 = Export[73],
    globalize_list$0 = Export[74],
    hash_fold_list$0 = Export[75],
    list_of_sexp$0 = Export[76],
    sexp_of_list$0 = Export[77],
    list_sexp_grammar$0 = Export[78],
    compare_nativeint_local$0 = Export[79],
    compare_nativeint$0 = Export[80],
    equal_nativeint_local$0 = Export[81],
    equal_nativeint$0 = Export[82],
    globalize_nativeint$0 = Export[83],
    hash_fold_nativeint$0 = Export[84],
    hash_nativeint$0 = Export[85],
    nativeint_of_sexp$0 = Export[86],
    sexp_of_nativeint$0 = Export[87],
    nativeint_sexp_grammar$0 = Export[88],
    compare_option_local$0 = Export[89],
    compare_option$0 = Export[90],
    equal_option_local$0 = Export[91],
    equal_option$0 = Export[92],
    globalize_option$0 = Export[93],
    hash_fold_option$0 = Export[94],
    option_of_sexp$0 = Export[95],
    sexp_of_option$0 = Export[96],
    option_sexp_grammar$0 = Export[97],
    compare_ref_local$0 = Export[98],
    compare_ref$0 = Export[99],
    equal_ref_local$0 = Export[100],
    equal_ref$0 = Export[101],
    globalize_ref$0 = Export[102],
    ref_of_sexp$0 = Export[103],
    sexp_of_ref$0 = Export[104],
    ref_sexp_grammar$0 = Export[105],
    compare_string_local$0 = Export[106],
    compare_string$0 = Export[107],
    equal_string_local$0 = Export[108],
    equal_string$0 = Export[109],
    globalize_string$0 = Export[110],
    hash_fold_string$0 = Export[111],
    hash_string$0 = Export[112],
    string_of_sexp$0 = Export[113],
    sexp_of_string$0 = Export[114],
    string_sexp_grammar$0 = Export[115],
    compare_bytes_local$0 = Export[116],
    compare_bytes$0 = Export[117],
    equal_bytes_local$0 = Export[118],
    equal_bytes$0 = Export[119],
    globalize_bytes$0 = Export[120],
    bytes_of_sexp$0 = Export[121],
    sexp_of_bytes$0 = Export[122],
    bytes_sexp_grammar$0 = Export[123],
    compare_unit_local$0 = Export[124],
    compare_unit$0 = Export[125],
    equal_unit_local$0 = Export[126],
    equal_unit$0 = Export[127],
    globalize_unit$0 = Export[128],
    hash_fold_unit$0 = Export[129],
    hash_unit$0 = Export[130],
    unit_of_sexp$0 = Export[131],
    sexp_of_unit$0 = Export[132],
    unit_sexp_grammar$0 = Export[133],
    symbol$19 = Export[134],
    symbol$20 = Export[135],
    lnot$0 = Export[136],
    abs$0 = Export[137],
    zero$0 = Export[138],
    symbol$21 = Export[139],
    symbol$22 = Export[140],
    symbol$23 = Export[141],
    ascending$1 = Export[142],
    descending$1 = Export[143],
    max$1 = Export[144],
    min$1 = Export[145],
    symbol$24 = Export[146],
    symbol$25 = Export[147],
    symbol$26 = Export[148],
    symbol$27 = Export[149],
    symbol$28 = Export[150],
    symbol$29 = Export[151],
    symbol$30 = Export[152],
    symbol$31 = Export[153],
    fst$0 = Export[154],
    snd$0 = Export[155],
    failwith$0 = Export[156],
    invalid_arg$0 = Export[157],
    raise_s$0 = Export[158],
    include$0 = Base_Container_intf[1],
    Continue_or_stop = include$0[1],
    Not_found_s$0 = Base_Import[297];
   caml_call1(Base_Backtrace[7], 0);
   var
    Caml = [0],
    Base =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Sexp,
       Int_conversions,
       Exported_for_specific_uses,
       Export,
       compare_array_local$0,
       compare_array$0,
       equal_array_local$0,
       equal_array$0,
       globalize_array$0,
       array_of_sexp$0,
       sexp_of_array$0,
       array_sexp_grammar$0,
       compare_bool_local$0,
       compare_bool$0,
       equal_bool_local$0,
       equal_bool$0,
       globalize_bool$0,
       hash_fold_bool$0,
       hash_bool$0,
       bool_of_sexp$0,
       sexp_of_bool$0,
       bool_sexp_grammar$0,
       compare_char_local$0,
       compare_char$0,
       equal_char_local$0,
       equal_char$0,
       globalize_char$0,
       hash_fold_char$0,
       hash_char$0,
       char_of_sexp$0,
       sexp_of_char$0,
       char_sexp_grammar$0,
       sexp_of_exn$0,
       compare_float_local$0,
       compare_float$0,
       equal_float_local$0,
       equal_float$0,
       globalize_float$0,
       hash_fold_float$0,
       hash_float$0,
       float_of_sexp$0,
       sexp_of_float$0,
       float_sexp_grammar$0,
       compare_int_local$0,
       compare_int$0,
       equal_int_local$0,
       equal_int$0,
       globalize_int$0,
       hash_fold_int$0,
       hash_int$0,
       int_of_sexp$0,
       sexp_of_int$0,
       int_sexp_grammar$0,
       compare_int32_local$0,
       compare_int32$0,
       equal_int32_local$0,
       equal_int32$0,
       globalize_int32$0,
       hash_fold_int32$0,
       hash_int32$0,
       int32_of_sexp$0,
       sexp_of_int32$0,
       int32_sexp_grammar$0,
       compare_int64_local$0,
       compare_int64$0,
       equal_int64_local$0,
       equal_int64$0,
       globalize_int64$0,
       hash_fold_int64$0,
       hash_int64$0,
       int64_of_sexp$0,
       sexp_of_int64$0,
       int64_sexp_grammar$0,
       compare_list_local$0,
       compare_list$0,
       equal_list_local$0,
       equal_list$0,
       globalize_list$0,
       hash_fold_list$0,
       list_of_sexp$0,
       sexp_of_list$0,
       list_sexp_grammar$0,
       compare_nativeint_local$0,
       compare_nativeint$0,
       equal_nativeint_local$0,
       equal_nativeint$0,
       globalize_nativeint$0,
       hash_fold_nativeint$0,
       hash_nativeint$0,
       nativeint_of_sexp$0,
       sexp_of_nativeint$0,
       nativeint_sexp_grammar$0,
       compare_option_local$0,
       compare_option$0,
       equal_option_local$0,
       equal_option$0,
       globalize_option$0,
       hash_fold_option$0,
       option_of_sexp$0,
       sexp_of_option$0,
       option_sexp_grammar$0,
       compare_ref_local$0,
       compare_ref$0,
       equal_ref_local$0,
       equal_ref$0,
       globalize_ref$0,
       ref_of_sexp$0,
       sexp_of_ref$0,
       ref_sexp_grammar$0,
       compare_string_local$0,
       compare_string$0,
       equal_string_local$0,
       equal_string$0,
       globalize_string$0,
       hash_fold_string$0,
       hash_string$0,
       string_of_sexp$0,
       sexp_of_string$0,
       string_sexp_grammar$0,
       compare_bytes_local$0,
       compare_bytes$0,
       equal_bytes_local$0,
       equal_bytes$0,
       globalize_bytes$0,
       bytes_of_sexp$0,
       sexp_of_bytes$0,
       bytes_sexp_grammar$0,
       compare_unit_local$0,
       compare_unit$0,
       equal_unit_local$0,
       equal_unit$0,
       globalize_unit$0,
       hash_fold_unit$0,
       hash_unit$0,
       unit_of_sexp$0,
       sexp_of_unit$0,
       unit_sexp_grammar$0,
       symbol$19,
       symbol$20,
       lnot$0,
       abs$0,
       zero$0,
       symbol$21,
       symbol$22,
       symbol$23,
       ascending$1,
       descending$1,
       max$1,
       min$1,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol$30,
       symbol$31,
       fst$0,
       snd$0,
       failwith$0,
       invalid_arg$0,
       raise_s$0,
       Continue_or_stop,
       Not_found_s$0,
       Caml];
   runtime.caml_register_global(23, Base, "Base");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJnbG9iYWxpemVfYm9vbCIsImIiLCJnbG9iYWxpemVfY2hhciIsImMiLCJnbG9iYWxpemVfdW5pdCIsInUiLCJnbG9iYWxpemVfYXJyYXkiLCJhIiwiZ2xvYmFsaXplX2xpc3QiLCJmIiwieHMiLCJ4IiwiZ2xvYmFsaXplX29wdGlvbiIsImdsb2JhbGl6ZV9yZXN1bHQiLCJnbG9iYWxpemVfYSIsImdsb2JhbGl6ZV9iIiwidCIsImdsb2JhbGl6ZV9yZWYiLCJyIiwiZ2xvYmFsaXplX2xhenlfdCIsImRlc2NlbmRpbmciLCJ5IiwibWF4IiwibWluIiwibWF4X2ludCIsIm1pbl9pbnQiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb25fZmxvYXQiLCJjaGFyX29mX2ludCIsInN0cmluZ19vZl9ib29sIiwiYm9vbF9vZl9zdHJpbmdfb3B0IiwiYm9vbF9vZl9zdHJpbmciLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0Iiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50X29wdCIsInJlYWRfaW50IiwicmVhZF9mbG9hdF9vcHQiLCJyZWFkX2Zsb2F0Iiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJvcGVuX291dF9nZW4iLCJmbHVzaCIsImZsdXNoX2FsbCIsIm91dHB1dF9jaGFyIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dF9ieXRlcyIsIm91dHB1dCIsIm91dHB1dF9zdWJzdHJpbmciLCJvdXRwdXRfYnl0ZSIsIm91dHB1dF9iaW5hcnlfaW50Iiwib3V0cHV0X3ZhbHVlIiwic2Vla19vdXQiLCJwb3Nfb3V0Iiwib3V0X2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2Vfb3V0IiwiY2xvc2Vfb3V0X25vZXJyIiwic2V0X2JpbmFyeV9tb2RlX291dCIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsIm9wZW5faW5fZ2VuIiwiaW5wdXRfY2hhciIsImlucHV0X2xpbmUiLCJpbnB1dCIsInJlYWxseV9pbnB1dCIsInJlYWxseV9pbnB1dF9zdHJpbmciLCJpbnB1dF9ieXRlIiwiaW5wdXRfYmluYXJ5X2ludCIsImlucHV0X3ZhbHVlIiwic2Vla19pbiIsInBvc19pbiIsImluX2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2VfaW4iLCJjbG9zZV9pbl9ub2VyciIsInNldF9iaW5hcnlfbW9kZV9pbiIsInN0cmluZ19vZl9mb3JtYXQiLCJzeW1ib2wiLCJleGl0IiwiYXRfZXhpdCIsInZhbGlkX2Zsb2F0X2xleGVtIiwidW5zYWZlX3JlYWxseV9pbnB1dCIsImRvX2F0X2V4aXQiLCJkb19kb21haW5fbG9jYWxfYXRfZXhpdCIsImJvb2xfdG9faW50Iiwic3ltYm9sJDMiLCJzeW1ib2wkNCIsInN5bWJvbCQ1Iiwic3ltYm9sJDYiLCJzeW1ib2wkNyIsInN5bWJvbCQ4Iiwic3ltYm9sJDkiLCJzeW1ib2wkMTAiLCJzeW1ib2wkMTEiLCJzeW1ib2wkMTIiLCJhc2NlbmRpbmciLCJtYXgkMCIsIm1pbiQwIiwiYXNjZW5kaW5nJDAiLCJkZXNjZW5kaW5nJDAiLCJtYXgkMSIsIm1pbiQxIiwic3ltYm9sJDEzIiwic3ltYm9sJDE0Iiwic3ltYm9sJDE1Iiwic3ltYm9sJDE2Iiwic3ltYm9sJDE3Iiwic3ltYm9sJDE4IiwiYXNjZW5kaW5nJDEiLCJkZXNjZW5kaW5nJDEiLCJjb21wYXJlIiwiY29tcGFyZV9sb2NhbCIsImVxdWFsIiwiZXF1YWxfbG9jYWwiLCJtYXgkMiIsIm1pbiQyIiwiYXNjZW5kaW5nJDIiLCJkZXNjZW5kaW5nJDIiLCJtYXgkMyIsIm1pbiQzIiwic3ltYm9sJDE5Iiwic3ltYm9sJDIwIiwic3ltYm9sJDIxIiwic3ltYm9sJDIyIiwic3ltYm9sJDIzIiwic3ltYm9sJDI0IiwiYXNjZW5kaW5nJDMiLCJkZXNjZW5kaW5nJDMiLCJjb21wYXJlJDAiLCJjb21wYXJlX2xvY2FsJDAiLCJlcXVhbCQwIiwiZXF1YWxfbG9jYWwkMCIsIm1heCQ0IiwibWluJDQiLCJzeW1ib2wkMjUiLCJzeW1ib2wkMjYiLCJzeW1ib2wkMjciLCJzeW1ib2wkMjgiLCJzeW1ib2wkMjkiLCJzeW1ib2wkMzAiLCJhc2NlbmRpbmckNCIsImRlc2NlbmRpbmckNCIsImNvbXBhcmUkMSIsImNvbXBhcmVfbG9jYWwkMSIsImVxdWFsJDEiLCJlcXVhbF9sb2NhbCQxIiwibWF4JDUiLCJtaW4kNSIsInN5bWJvbCQzMSIsInN5bWJvbCQzMiIsInN5bWJvbCQzMyIsInN5bWJvbCQzNCIsInN5bWJvbCQzNSIsInN5bWJvbCQzNiIsImFzY2VuZGluZyQ1IiwiZGVzY2VuZGluZyQ1IiwiY29tcGFyZSQyIiwiY29tcGFyZV9sb2NhbCQyIiwiZXF1YWwkMiIsImVxdWFsX2xvY2FsJDIiLCJtYXgkNiIsIm1pbiQ2Iiwic3ltYm9sJDM3Iiwic3ltYm9sJDM4Iiwic3ltYm9sJDM5Iiwic3ltYm9sJDQwIiwic3ltYm9sJDQxIiwic3ltYm9sJDQyIiwiYXNjZW5kaW5nJDYiLCJkZXNjZW5kaW5nJDYiLCJjb21wYXJlJDMiLCJlcXVhbCQzIiwiY29tcGFyZV9sb2NhbCQzIiwiZXF1YWxfbG9jYWwkMyIsIm1heCQ3IiwibWluJDciLCJhc2NlbmRpbmckNyIsImRlc2NlbmRpbmckNyIsImNvbXBhcmVfbG9jYWwkNCIsImVxdWFsX2xvY2FsJDQiLCJtYXgkOCIsIm1pbiQ4Iiwic3ltYm9sJDQzIiwic3ltYm9sJDQ0Iiwic3ltYm9sJDQ1Iiwic3ltYm9sJDQ2Iiwic3ltYm9sJDQ3Iiwic3ltYm9sJDQ4IiwiYXNjZW5kaW5nJDgiLCJkZXNjZW5kaW5nJDgiLCJjb21wYXJlJDQiLCJjb21wYXJlX2xvY2FsJDUiLCJlcXVhbCQ0IiwiZXF1YWxfbG9jYWwkNSIsIm1heCQ5IiwibWluJDkiLCJzeW1ib2wkNDkiLCJzeW1ib2wkNTAiLCJzeW1ib2wkNTEiLCJzeW1ib2wkNTIiLCJzeW1ib2wkNTMiLCJzeW1ib2wkNTQiLCJhc2NlbmRpbmckOSIsImRlc2NlbmRpbmckOSIsImNvbXBhcmUkNSIsImNvbXBhcmVfbG9jYWwkNiIsImVxdWFsJDUiLCJlcXVhbF9sb2NhbCQ2IiwibWF4JDEwIiwibWluJDEwIiwic3ltYm9sJDU1Iiwic3ltYm9sJDU2Iiwic3ltYm9sJDU3Iiwic3ltYm9sJDU4IiwiYXNyIiwibGFuZCIsImxub3QkMCIsImxvciIsImxzbCIsImxzciIsImx4b3IiLCJtb2QiLCJhYnMkMCIsImZhaWx3aXRoJDAiLCJmc3QiLCJpbnZhbGlkX2FyZyQwIiwic25kIiwiZmxvYXRfb2Zfc3RyaW5nIiwiYW1fdGVzdGluZyIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJ0b19mbG9hdCIsIm9mX2Zsb2F0IiwibWF4X3ZhbHVlIiwibWluX3ZhbHVlIiwic3VjYyIsInByZWQiLCJmYWlsd2l0aGYiLCJmbXQiLCJzIiwiaW52YWxpZF9hcmdmIiwiYmFja2VuZF90eXBlIiwiaW50ZXJhY3RpdmUiLCJvc190eXBlIiwidW5peCIsIndpbjMyIiwiY3lnd2luIiwid29yZF9zaXplX2luX2JpdHMiLCJpbnRfc2l6ZV9pbl9iaXRzIiwiYmlnX2VuZGlhbiIsIm1heF9zdHJpbmdfbGVuZ3RoIiwibWF4X2FycmF5X2xlbmd0aCIsInJ1bnRpbWVfdmFyaWFudCIsInJ1bnRpbWVfcGFyYW1ldGVycyIsImFyZ3YiLCJnZXRfYXJndiIsIm9jYW1sX3ZlcnNpb24iLCJlbmFibGVfcnVudGltZV93YXJuaW5ncyIsInJ1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCIsImdldGVudl9leG4iLCJ2YXIkMCIsImdldGVudiIsIm1heF9sZW5ndGgiLCJjcmVhdGUiLCJsZW4iLCJjcmVhdGVfbG9jYWwiLCJjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCIsImFwcGVuZCIsImJsaXQiLCJjb25jYXQiLCJjb3B5IiwiZmlsbCIsImluaXQiLCJyZXMiLCJpIiwibWFrZV9tYXRyaXgiLCJvZl9saXN0Iiwic3ViIiwidG9fbGlzdCIsImZvbGQiLCJmb2xkX3JpZ2h0IiwiaXRlciIsIml0ZXJpIiwibWFwIiwibWFwaSIsInN0YWJsZV9zb3J0Iiwic3dhcCIsImoiLCJlbHRfaSIsImVsdF9qIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsInRvX2ludCIsInVuc2FmZV9vZl9pbnQiLCJ1cHBlcmNhc2UiLCJpbnRfaXNfb2siLCJvZl9pbnQiLCJvZl9pbnRfZXhuIiwidDEiLCJ0MiIsImhkX2V4biIsInJldl9hcHBlbmQiLCJ0bF9leG4iLCJ1bnppcCIsImxlbmd0aCIsImwkMCIsImwiLCJleGlzdHMiLCJ0JDAiLCJleGlzdHMyX29rIiwibDEiLCJsMiIsImwxJDAiLCJsMiQwIiwibDIkMSIsImEyIiwibDEkMSIsImExIiwiaW5pdCQwIiwiaW5pdCQxIiwiZm9sZDJfb2siLCJmb3JfYWxsIiwiZm9yX2FsbDJfb2siLCJpdGVyMl9vayIsIm5vbnRhaWxfbWFwIiwibm9udGFpbF9tYXBpIiwicGFydGl0aW9uIiwicmV2X21hcCIsImFjY3UiLCJyZXZfbWFwMl9vayIsImFjY3UkMCIsInJldiIsInJlc3QiLCJmb2xkX3JpZ2h0Ml9vayIsImhhc2hfZm9sZF91bml0IiwiaGFzaF9mb2xkX2ludCIsImhhc2hfZm9sZF9pbnQ2NCIsImhhc2hfZm9sZF9mbG9hdCIsImhhc2hfZm9sZF9zdHJpbmciLCJhc19pbnQiLCJoYXNoX2ZvbGRfaW50MzIiLCJoYXNoX2ZvbGRfY2hhciIsImhhc2hfZm9sZF9ib29sIiwiaGFzaF9mb2xkX25hdGl2ZWludCIsImhhc2hfZm9sZF9vcHRpb24iLCJoYXNoX2ZvbGRfZWxlbSIsImhhc2hfZm9sZF9saXN0IiwicyQxIiwibGlzdCQxIiwicyQyIiwibGlzdCIsImxpc3QkMCIsInMkMCIsImhhc2hfZm9sZF9sYXp5X3QiLCJoYXNoX2ZvbGRfcmVmX2Zyb3plbiIsImhhc2hfZm9sZF9hcnJheV9mcm96ZW4iLCJhcnJheSIsImUiLCJpJDAiLCJoYXNoX25hdGl2ZWludCIsImhhc2hfaW50NjQiLCJoYXNoX2ludDMyIiwiaGFzaF9jaGFyIiwiaGFzaF9pbnQiLCJoYXNoX2Jvb2wiLCJoYXNoX3N0cmluZyIsImhhc2hfZmxvYXQiLCJoYXNoX3VuaXQiLCJzZWVkIiwib2ZfZm9sZCIsImhhc2hfZm9sZF90IiwicnVuIiwiZm9sZGVyIiwib3B0Iiwic3RoIiwiY29tcGFyZV9zdGF0ZSIsInN0YXRlX3RvX3N0cmluZyIsInN0YXRlIiwidCQxIiwidCQyIiwidCQzIiwidCQ0IiwidCQ1IiwiY29tcGFyZV9hYnN0cmFjdCIsInR5cGVfbmFtZSIsImVxdWFsX2Fic3RyYWN0IiwiY29tcGFyZV9ib29sIiwiY29tcGFyZV9ib29sX2xvY2FsIiwiY29tcGFyZV9jaGFyIiwiY29tcGFyZV9jaGFyX2xvY2FsIiwiY29tcGFyZV9mbG9hdCIsImNvbXBhcmVfZmxvYXRfbG9jYWwiLCJjb21wYXJlX2ludCIsImNvbXBhcmVfaW50X2xvY2FsIiwiY29tcGFyZV9pbnQzMiIsImNvbXBhcmVfaW50MzJfbG9jYWwiLCJjb21wYXJlX2ludDY0IiwiY29tcGFyZV9pbnQ2NF9sb2NhbCIsImNvbXBhcmVfbmF0aXZlaW50IiwiY29tcGFyZV9uYXRpdmVpbnRfbG9jYWwiLCJjb21wYXJlX3N0cmluZyIsImNvbXBhcmVfc3RyaW5nX2xvY2FsIiwiY29tcGFyZV9ieXRlcyIsImNvbXBhcmVfYnl0ZXNfbG9jYWwiLCJjb21wYXJlX3VuaXQiLCJjb21wYXJlX3VuaXRfbG9jYWwiLCJjb21wYXJlX2FycmF5X2xvY2FsIiwiY29tcGFyZV9lbHQiLCJsZW5fYSIsImxlbl9iIiwicmV0IiwiY29tcGFyZV9hcnJheSIsImNvbXBhcmVfbGlzdCIsImEkMCIsImIkMCIsInlzIiwiY29tcGFyZV9saXN0X2xvY2FsIiwiY29tcGFyZV9lbHRfbG9jYWwiLCJjb21wYXJlX29wdGlvbiIsImNvbXBhcmVfb3B0aW9uX2xvY2FsIiwiY29tcGFyZV9yZWYiLCJjb21wYXJlX3JlZl9sb2NhbCIsImVxdWFsX2Jvb2wiLCJlcXVhbF9ib29sX2xvY2FsIiwiZXF1YWxfY2hhciIsImVxdWFsX2NoYXJfbG9jYWwiLCJlcXVhbF9pbnQiLCJlcXVhbF9pbnRfbG9jYWwiLCJlcXVhbF9pbnQzMiIsImVxdWFsX2ludDMyX2xvY2FsIiwiZXF1YWxfaW50NjQiLCJlcXVhbF9pbnQ2NF9sb2NhbCIsImVxdWFsX25hdGl2ZWludCIsImVxdWFsX25hdGl2ZWludF9sb2NhbCIsImVxdWFsX3N0cmluZyIsImVxdWFsX3N0cmluZ19sb2NhbCIsImVxdWFsX2J5dGVzIiwiZXF1YWxfYnl0ZXNfbG9jYWwiLCJlcXVhbF91bml0IiwiZXF1YWxfdW5pdF9sb2NhbCIsImVxdWFsX2Zsb2F0IiwiZXF1YWxfZmxvYXRfbG9jYWwiLCJlcXVhbF9hcnJheV9sb2NhbCIsImVxdWFsX2VsdCIsImVxdWFsX2FycmF5IiwiZXF1YWxfbGlzdCIsImVxdWFsX2xpc3RfbG9jYWwiLCJlcXVhbF9lbHRfbG9jYWwiLCJlcXVhbF9vcHRpb24iLCJlcXVhbF9vcHRpb25fbG9jYWwiLCJlcXVhbF9yZWYiLCJlcXVhbF9yZWZfbG9jYWwiLCJhXzAwMSIsImJfMDAyIiwiYV8wMDMiLCJiXzAwNCIsImFfMDA1IiwiYl8wMDYiLCJnbG9iYWxpemUiLCJ4XzAwOSIsImFyZ18wMTAiLCJhcmdfMDExIiwiaGFzaCIsImhzdiIsImFyZyIsImEwIiwiaHN2JDAiLCJhMCQwIiwiaHN2JDEiLCJ0X3NleHBfZ3JhbW1hciIsImludmFyaWFudCIsInNleHBfb2ZfdCIsIm51bV9iaXRzIiwid29yZF9zaXplIiwiYWxsIiwicmVnaXN0ZXIiLCJwIiwicHAiLCJtb2R1bGVfbmFtZSIsImZvcm1hdHRlciIsImFyZzFfMDAyIiwiYXJnMF8wMDEiLCJyZXMwXzAwMyIsInJlczFfMDA0IiwiYXJnMV8wMDYiLCJhcmcwXzAwNSIsInJlczBfMDA3IiwicmVzMV8wMDgiLCJjcmVhdGVfcyIsInNleHAiLCJyYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInJlcmFpc2UiLCJleG4iLCJzdHIiLCJleG4kMCIsImJ0IiwicmVyYWlzZWYiLCJleGMiLCJmb3JtYXQiLCJ0b19zdHJpbmdfbWFjaCIsInNleHBfb2ZfdCQwIiwicHJvdGVjdHgiLCJmaW5hbGx5JDAiLCJmaW5hbF9leG4kMCIsImZpbmFsX2V4biIsInByb3RlY3QiLCJkb2VzX3JhaXNlIiwicHBmIiwicHJpbnRfd2l0aF9iYWNrdHJhY2UiLCJyYXdfYmFja3RyYWNlIiwiaGFuZGxlX3VuY2F1Z2h0X2F1eCIsImV4YyQwIiwiaGFuZGxlX3VuY2F1Z2h0X2FuZF9leGl0IiwiaGFuZGxlX3VuY2F1Z2h0IiwibXVzdF9leGl0IiwiZXhpdCQwIiwicmVyYWlzZV91bmNhdWdodCIsImZ1bmMiLCJyYWlzZV93aXRob3V0X2JhY2t0cmFjZSIsImluaXRpYWxpemVfbW9kdWxlIiwiY2xlYXJfYmFja3RyYWNlIiwid2l0aF9yZXR1cm4iLCJpc19hbGl2ZSIsInJldHVybiQwIiwid2l0aF9yZXR1cm5fb3B0aW9uIiwicHJlcGVuZCIsInBhcmFtIiwiY29uc3QkMCIsIm5vbiIsImZvcmV2ZXIiLCJlJDAiLCJjb21wb3NlIiwiZyIsImZsaXAiLCJhcHBseV9uX3RpbWVzIiwibiIsIm4kMCIsIngkMCIsIngkMSIsIm4kMSIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsImJpbmQiLCJqb2luIiwiaWdub3JlX20iLCJhbGxfdW5pdCIsIm1hcF92aWFfYmluZCIsIm1hIiwic3ltYm9sX2JpbmQkMCIsInN5bWJvbF9tYXAkMCIsInN5bWJvbF9iaW5kJDEiLCJzeW1ib2xfbWFwJDEiLCJib3RoIiwibG9vcCIsInZzIiwidHMiLCJ2IiwidG9fbW9uYWQiLCJvZl9tb25hZCIsImRlcml2ZWRfbWFwIiwibWFwMiIsInRhIiwidGIiLCJtYXAzIiwidGMiLCJzeW1ib2wkMCIsInN5bWJvbCQxIiwidGYiLCJmYWIiLCJtYXAkMCIsImFwcGx5IiwibWYiLCJteCIsInR4IiwiY3VzdG9tX21hcCIsInJldHVybiQxIiwiYXBwbHkkMCIsIm1hcDIkMCIsIm9mX21vZHVsZSIsIk0iLCJ0b19tb2R1bGUiLCJtYWtlIiwiY29tcGFyYXRvciIsImVycm9yX3NvdXJjZV8wMTciLCJjbXBfZiIsImNtcF9zIiwiYV8wMDciLCJiXzAwOCIsImFfMDA5IiwiYl8wMTAiLCJhXzAxMSIsImJfMDEyIiwiaGFzaF9mb2xkX2YiLCJoYXNoX2ZvbGRfcyIsInRfb2Zfc2V4cCIsIm9mX2ZfMDEzIiwib2Zfc18wMTQiLCJzZXhwXzAxOSIsInRhZ18wMjAiLCJzZXhwX2FyZ3NfMDI2IiwiYXJnMF8wMjciLCJyZXMwXzAyOCIsInNleHBfYXJnc18wMjEiLCJhcmcwXzAyMiIsInJlczBfMDIzIiwib2ZfZl8wMzEiLCJvZl9zXzAzMiIsImFyZzBfMDMzIiwicmVzMF8wMzQiLCJhcmcwXzAzNSIsInJlczBfMDM2IiwiZl9zZXhwX2dyYW1tYXIiLCJzX3NleHBfZ3JhbW1hciIsIm9wYXF1ZV9pZGVudGl0eSIsIm5hbWUiLCJnZXQiLCJmc2V0Iiwic2V0dGVyIiwidXBkYXRlciIsImZpZWxkIiwiY29udmVydF9mYWlsdXJlIiwibnVtX2JpdHNfaW50IiwibnVtX2JpdHNfbmF0aXZlaW50IiwibnVtX2JpdHNfaW50MzIiLCJudW1fYml0c19pbnQ2NCIsIm1pbl9pbnQzMiIsIm1heF9pbnQzMiIsIm1pbl9pbnQ2NCIsIm1heF9pbnQ2NCIsIm1pbl9uYXRpdmVpbnQiLCJtYXhfbmF0aXZlaW50IiwiaW50NjRfdG9fc3RyaW5nIiwibmF0aXZlaW50X3RvX3N0cmluZyIsImludDMyX3RvX2ludF90cnVuYyIsImludF90b19pbnQzMl90cnVuYyIsImludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIiwiaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQiLCJpbnRfdG9faW50MzIiLCJpbnQzMl90b19pbnQiLCJpbnRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9faW50X2V4biIsImludF90b19pbnQ2NCIsImludDY0X3RvX2ludF90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IiwiaW50NjRfdG9faW50IiwiaW50NjRfdG9faW50X2V4biIsImludF90b19uYXRpdmVpbnQiLCJuYXRpdmVpbnRfdG9faW50X3RydW5jIiwibmF0aXZlaW50X3RvX2ludCIsIm5hdGl2ZWludF90b19pbnRfZXhuIiwiaW50MzJfdG9faW50NjQiLCJpbnQ2NF90b19pbnQzMl90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MyIsImludDY0X3RvX2ludDMyIiwiaW50NjRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9fbmF0aXZlaW50IiwibmF0aXZlaW50X3RvX2ludDMyX3RydW5jIiwibmF0aXZlaW50X3RvX2ludDMyIiwibmF0aXZlaW50X3RvX2ludDMyX2V4biIsImludDY0X3RvX25hdGl2ZWludF90cnVuYyIsIm5hdGl2ZWludF90b19pbnQ2NCIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aSIsImludDY0X3RvX25hdGl2ZWludCIsImludDY0X3RvX25hdGl2ZWludF9leG4iLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYiLCJpbnQ2NF9maXRfb25faW50NjNfZXhuIiwiY2FwaXRhbGl6ZSIsInVuY2FwaXRhbGl6ZSIsImlzX3ZhbGlkX3V0Zl84IiwiaXNfdmFsaWRfdXRmXzE2bGUiLCJpc192YWxpZF91dGZfMTZiZSIsImdldF91dGZfOF91Y2hhciIsImJ5dGVfcG9zIiwiZ2V0X3V0Zl8xNmxlX3VjaGFyIiwiZ2V0X3V0Zl8xNmJlX3VjaGFyIiwiZ2V0X3V0Zl8zMl91Y2hhciIsImdldF9pbnQzMiIsImJ5dGVzX3JlYWQiLCJpbnQzMiIsImludCQwIiwiZ2V0X3V0Zl8zMmxlX3VjaGFyIiwiZ2V0X3V0Zl8zMmJlX3VjaGFyIiwic2VwIiwiYmFja191cF9hdF9uZXdsaW5lIiwicG9zIiwiZW9sIiwic3BsaXRfbGluZXMiLCJhYyIsInN0YXJ0IiwiaHN2JDIiLCJwb3NfY251bV8wMTAiLCJwb3NfYm9sXzAwOCIsInBvc19sbnVtXzAwNiIsInBvc19mbmFtZV8wMDQiLCJibmRzXzAwMyIsImFyZ18wMDkiLCJibmRzXzAwMyQwIiwiYXJnXzAwNyIsImJuZHNfMDAzJDEiLCJhcmdfMDA1IiwiYm5kc18wMDMkMiIsImhhc2hfZm9sZF90JDAiLCJoYXNoJDAiLCJtYWtlX2xvY2F0aW9uX3N0cmluZyIsInBvc19mbmFtZSIsInBvc19sbnVtIiwicG9zX2NudW0iLCJwb3NfYm9sIiwiaXNfZW1wdHkiLCJwYXJ0aXRpb25fbWFwIiwiZnN0JDAiLCJ5JDAiLCJzbmQkMCIsImVycm9yX3NvdXJjZV8wMDUiLCJvZl9hXzAwMSIsIm9mX2JfMDAyIiwic2V4cF8wMDciLCJ0YWdfMDA4Iiwic2V4cF9hcmdzXzAwOSIsImFyZzBfMDEwIiwicmVzMF8wMTEiLCJzZXhwX2FyZ3NfMDE0IiwiYXJnMF8wMTUiLCJyZXMwXzAxNiIsIm9mX2FfMDE5Iiwib2ZfYl8wMjAiLCJhcmcwXzAyMSIsInJlczBfMDIyIiwiYXJnMF8wMjMiLCJyZXMwXzAyNCIsImFfc2V4cF9ncmFtbWFyIiwiYl9zZXhwX2dyYW1tYXIiLCJjbXBfYSIsImNtcF9iIiwiYV8wMzMiLCJiXzAzNCIsImFfMDM1IiwiYl8wMzYiLCJhXzAzNyIsImJfMDM4IiwiYV8wMjciLCJiXzAyOCIsImFfMDI5IiwiYl8wMzAiLCJhXzAzMSIsImJfMDMyIiwiYV8wNDUiLCJiXzA0NiIsImFfMDQ3IiwiYl8wNDgiLCJhXzA0OSIsImJfMDUwIiwiYV8wMzkiLCJiXzA0MCIsImFfMDQxIiwiYl8wNDIiLCJhXzA0MyIsImJfMDQ0IiwiaGFzaF9mb2xkX2EiLCJoYXNoX2ZvbGRfYiIsImNoZWNrX29rIiwiY2hlY2tfZXJyb3IiLCJvayIsImVycm9yIiwiZmFpbCIsImZhaWxmIiwibWFwX2Vycm9yIiwiYmluZCQxIiwibWFwJDEiLCJyZXR1cm4kMiIsImlzX29rIiwiaXNfZXJyb3IiLCJvZl9vcHRpb24iLCJpdGVyX2Vycm9yIiwidG9fZWl0aGVyIiwib2ZfZWl0aGVyIiwib2tfaWZfdHJ1ZSIsImJvb2wiLCJ0cnlfd2l0aCIsIm9rX2V4biIsIm9rX29yX2ZhaWx3aXRoIiwiY29tYmluZSIsImVyciIsIm9rMSIsIm9rMiIsImVycjEiLCJlcnIyIiwiY29tYmluZV9lcnJvcnMiLCJlcnJzIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImNvdW50Iiwic3VtIiwiZm9sZF9yZXN1bHQiLCJhY2MiLCJpdGVtIiwiZm9sZF91bnRpbCIsImZpbmlzaCIsIm1pbl9lbHQiLCJlbHQiLCJtYXhfZWx0IiwibWVtIiwiZmluZF9tYXAiLCJmaW5kIiwidG9fYXJyYXkiLCJpdGVyJDAiLCJpdGVyJDEiLCJsZW5ndGgkMCIsImxlbmd0aCQxIiwiaXNfZW1wdHkkMCIsIm1lbSQwIiwic3VtJDAiLCJtIiwiY291bnQkMCIsImV4aXN0cyQwIiwiZm9yX2FsbCQwIiwiZmluZF9tYXAkMCIsImZpbmQkMCIsInRvX2xpc3QkMCIsInRvX2FycmF5JDAiLCJtaW5fZWx0JDAiLCJtYXhfZWx0JDAiLCJmb2xkX3Jlc3VsdCQwIiwiZm9sZF91bnRpbCQwIiwib2ZfYXJyYXkiLCJjb25jYXRfb2ZfYXJyYXkiLCJjb25jYXRfbWFwIiwiZmlsdGVyX21hcCIsImZpbHRlciIsImVpdGhlciIsInBhcnRpdGlvbl90ZiIsImZvbGQkMCIsIm9mX2xpc3QkMCIsIm9mX2FycmF5JDAiLCJjb25jYXQkMCIsImZvbGRpIiwiYWNjJDAiLCJjb3VudGkiLCJleGlzdHNpIiwiZm9yX2FsbGkiLCJmaW5kX21hcGkiLCJmaW5kaSIsIml0ZXJpJDAiLCJpdGVyaSQxIiwiZm9sZGkkMCIsImZvbGRpJDEiLCJjb3VudGkkMCIsImV4aXN0c2kkMCIsImZvcl9hbGxpJDAiLCJmaW5kX21hcGkkMCIsImZpbmRpJDAiLCJkZXJpdmVkX2luaXQiLCJkZXJpdmVkX2luaXQkMCIsImRlcml2ZWRfY29uY2F0X21hcGkiLCJjb25jYXRfbWFwaSIsImNvbmNhdF9tYXBpJDAiLCJmaWx0ZXJfbWFwaSIsImZpbHRlcmkiLCJjb21wYXJlX2EiLCJlcXVhbF9hIiwicGVlayIsInNleHBfb2ZfYSIsInNsb3dfY2hlY2tfcG9zX2xlbl9leG4iLCJ0b3RhbF9sZW5ndGgiLCJjaGVja19wb3NfbGVuX2V4biIsInN0b3AiLCJnZXRfcG9zX2xlbl9leG4iLCJsZW4kMCIsIm9mX3N0YXRlIiwiYXNzaWduIiwiZHN0Iiwic3JjIiwic3BsaXRfZnJvbV9wYXJlbnQiLCJtYWtlX2xhenkiLCJnZXRfc3RhdGUiLCJmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMiLCJhbGxvd19pbl90ZXN0cyIsImJpdHMiLCJiaXRzNjQiLCJpbnQ2NCIsIm5hdGl2ZWludCIsImNoYXIkMCIsImFzY2lpIiwibWFrZV9zZWxmX2luaXQiLCJkZWZhdWx0JDAiLCJpbnRfb25fNjRiaXRzIiwiYm91bmQiLCJpbnRfb25fMzJiaXRzIiwiaW50JDEiLCJiaXRzJDAiLCJmdWxsX3JhbmdlX2ludDY0IiwiYml0cyQxIiwiZnVsbF9yYW5nZV9pbnQzMiIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyQwIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnQiLCJyYWlzZV9jcm9zc2VkX2JvdW5kcyIsImxvd2VyX2JvdW5kIiwidXBwZXJfYm91bmQiLCJzdHJpbmdfb2ZfYm91bmQiLCJpbnRfaW5jbCIsImxvIiwiaGkiLCJkaWZmIiwiaW50MzJfaW5jbCIsIm5hdGl2ZWludF9pbmNsIiwiaW50NjRfaW5jbCIsImZsb2F0JDAiLCJyMSIsInIyIiwicmVzdWx0IiwiZmxvYXRfcmFuZ2UiLCJiaXRzJDIiLCJiaXRzNjQkMCIsImludCQyIiwiaW50MzIkMCIsIm5hdGl2ZWludCQwIiwiaW50NjQkMCIsImZsb2F0JDEiLCJpbnRfaW5jbCQwIiwiaW50MzJfaW5jbCQwIiwibmF0aXZlaW50X2luY2wkMCIsImludDY0X2luY2wkMCIsImZsb2F0X3JhbmdlJDAiLCJib29sJDAiLCJjaGFyJDEiLCJhc2NpaSQwIiwiZnVsbF9pbml0Iiwic2VsZl9pbml0Iiwic2V0X3N0YXRlIiwicGVybXV0ZSIsInJhbmRvbV9zdGF0ZSIsInN0aCQwIiwibnVtX3N3YXBzIiwidGhpc19pIiwicmFuZG9tX2kiLCJzZXhwXzAwNiIsImVycm9yX3NvdXJjZV8wMzYiLCJhXzAxNCIsImJfMDE1IiwiYV8wMTYiLCJiXzAxNyIsImFfMDEwIiwiYl8wMTEiLCJhXzAxMiIsImJfMDEzIiwib2ZfYV8wMTgiLCJhcmcwXzAxOSIsInJlczBfMDIwIiwic2luZ2xldG9uIiwicmFuZ2UiLCJzdHJpZGUiLCJzdGFydF9pIiwic3RvcF9pIiwibmV4dF9pIiwib3JkZXIiLCJyYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW0iLCJpbml0aWFsX3N0cmlkZV9vcmRlciIsInN0YXJ0X2kkMCIsImlfdG9fc3RvcF9vcmRlciIsIm5leHRfaSQwIiwicmFuZ2UkMCIsInN0aCQxIiwiaGQiLCJ0bCIsIm50aCIsIm50aF9leG4iLCJ1bm9yZGVyZWRfYXBwZW5kIiwib2ZfbGlzdHMiLCJzaGFyZWRfbGVuZ3RoIiwic2hhcmVkX2xlbmd0aCQwIiwiY2hlY2tfbGVuZ3RoMl9leG4iLCJ0YWlsX29mX2IiLCJ0YWlsX29mX2EiLCJjaGVja19sZW5ndGgyIiwib2ZfbGlzdHMkMCIsImwzIiwiYyQwIiwiY2hlY2tfbGVuZ3RoM19leG4iLCJ0YWlsX29mX2MiLCJuMSIsIm4yIiwibjMiLCJjaGVja19sZW5ndGgzIiwiaXRlcjIiLCJpdGVyMl9leG4iLCJyZXZfbWFwMiIsInJldl9tYXAyX2V4biIsImZvbGQyIiwiZm9sZDJfZXhuIiwiZm9sZF9yaWdodDIiLCJmb2xkX3JpZ2h0Ml9leG4iLCJmb3JfYWxsMiIsImZvcl9hbGwyX2V4biIsImV4aXN0czIiLCJleGlzdHMyX2V4biIsImJzIiwicmV2X2ZpbHRlciIsIm5vdF9mb3VuZCIsImZpbmRfbWFwX2V4biIsIm5vdF9mb3VuZCQwIiwiZmluZF9leG4iLCJub3RfZm91bmQkMSIsImZpbmRpX2V4biIsIm5vdF9mb3VuZCQyIiwiZmluZF9tYXBpX2V4biIsIngxIiwieDIiLCJ4MyIsIng0IiwieDUiLCJmb2xkaW5nX21hcCIsIm5ld19hY2MiLCJmb2xkX21hcCIsIm1hcDJfb2siLCJtYXAyX2V4biIsInJldl9tYXAzX29rIiwibDMkMCIsImwzJDEiLCJhYyQwIiwicmV2X21hcDMiLCJyZXZfbWFwM19leG4iLCJtYXAzX29rIiwibWFwM19leG4iLCJyZXZfbWFwX2FwcGVuZCIsImgiLCJsaXN0JDIiLCJ1bnppcDMiLCJ6IiwiemlwX2V4biIsInppcCIsInJldl9tYXBpIiwiaSQyIiwiZm9sZGluZ19tYXBpIiwiZm9sZF9tYXBpIiwicG9zJDEiLCJyZWR1Y2UiLCJyZWR1Y2VfZXhuIiwicmVkdWNlX2JhbGFuY2VkIiwic3RlcF9hY2N1bSIsIm51bSIsIm51bSQwIiwiYWNjJDEiLCJudW0kMSIsInJlZHVjZV9iYWxhbmNlZF9leG4iLCJncm91cGkiLCJicmVhayQwIiwidGFrZV9ncm91cCIsImdyb3VwIiwibWVyZ2UiLCJoMiIsImgxIiwiY21wIiwic29ydCIsInRsJDEiLCJ4MiQwIiwieDEkMCIsInJldl9zb3J0IiwiczEiLCJ0bCQwIiwiczIiLCJhY2N1JDEiLCJzb3J0X2FuZF9ncm91cCIsImRlZHVwX2FuZF9zb3J0IiwiYyQxIiwiYyQyIiwiYyQzIiwiYyQ0IiwiYyQ1IiwiYyQ2Iiwic3RhYmxlX2RlZHVwIiwiZGVkdXBzIiwidW5pcXVlIiwiZGVkdXAiLCJwb3MkMCIsIm1hcDMkMCIsInN5bWJvbCQyIiwibGFzdF9leG4iLCJsYXN0IiwiaXNfcHJlZml4IiwicHJlZml4IiwicHJlZml4JDAiLCJwcmVmaXgkMSIsImhkJDAiLCJmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSIsImExJDAiLCJyZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyIsIndoaWNoX3RvX2tlZXAiLCJ0b19rZWVwJDIiLCJ0b19rZWVwIiwiYWNjdW0iLCJ0b19rZWVwJDAiLCJ0b19rZWVwJDEiLCJmaW5kX2FfZHVwIiwic29ydGVkIiwiaGQyIiwiaGQxIiwiY29udGFpbnNfZHVwIiwibHN0IiwiZmluZF9hbGxfZHVwcyIsInNvcnRlZCQ0IiwicHJldiQzIiwic29ydGVkJDAiLCJwcmV2IiwiYWxyZWFkeV9yZWNvcmRlZCIsInNvcnRlZCQxIiwicHJldiQwIiwiYWxsX2VxdWFsIiwieHMkMCIsImlkeCIsImFjY3VtJDAiLCJyZXZfZmlsdGVyX21hcCIsInJldl9maWx0ZXJfbWFwaSIsImkkMSIsImZpbHRlcl9vcHQiLCJwYXJ0aXRpb24zX21hcCIsInRyZCIsInRyZCQwIiwieSQxIiwiZiQwIiwicGFydGl0aW9uX3Jlc3VsdCIsInRfb2Zfc2V4cCQwIiwib2ZfYV8wMjgiLCJvZl9iXzAyOSIsInhfMDM3Iiwic2V4cF8wMzUiLCJhcmcxXzAzMiIsImFyZzBfMDMxIiwicmVzMF8wMzMiLCJyZXMxXzAzNCIsInNleHBfb2ZfdCQxIiwib2ZfYV8wMzgiLCJvZl9iXzAzOSIsInhfMDQ0IiwiYXJnMV8wNDEiLCJhcmcwXzA0MCIsInJlczBfMDQyIiwicmVzMV8wNDMiLCJ0X3NleHBfZ3JhbW1hciQwIiwicGFpcl9vZl9ncm91cCIsImsiLCJncm91cCQwIiwiYWxpc3QiLCJzb3J0X2FuZF9ncm91cCQwIiwia2V5Iiwia2V5JDAiLCJub3RfZm91bmQkMyIsImZpbmRfZXhuJDAiLCJ2YWx1ZSIsInJlbW92ZSIsImFkZCIsImludmVyc2UiLCJtYXAkMiIsInNwbGl0X24iLCJ0X29yaWciLCJ0YWtlIiwiZHJvcCIsImNodW5rc19vZiIsImwkMSIsInN1Ymxpc3QiLCJzcGxpdF93aGlsZSIsInRha2Vfd2hpbGUiLCJkcm9wX3doaWxlIiwiZHJvcF9sYXN0IiwiZHJvcF9sYXN0X2V4biIsImNhcnRlc2lhbl9wcm9kdWN0IiwibGlzdDEiLCJsaXN0MiIsImNvbmNhdF9ub19vcmRlciIsImNvbnMiLCJpc19zb3J0ZWQiLCJpc19zb3J0ZWRfc3RyaWN0bHkiLCJhcnIiLCJyYW5kb21fZWxlbWVudF9leG4iLCJyYW5kb21fZWxlbWVudCIsImVxdWFsX3dpdGhfbG9jYWxfY2xvc3VyZSIsInQxJDAiLCJ0MiQwIiwidDIkMSIsInQxJDEiLCJlcXVhbF9hX2xvY2FsIiwidHJhbnNwb3NlIiwicm93cyQwIiwicm93cyIsImNvbHVtbnMiLCJkb19yZXYiLCJjb2x1bW5fYWNjIiwidHJpbW1lZF9yb3dzIiwiZm91bmRfZW1wdHkiLCJ0cmltbWVkIiwiY29sdW1uX2FjYyQwIiwiY29sdW1uIiwiZG9fcmV2JDAiLCJjb2x1bW5zJDAiLCJhcmcwXzA0NSIsInJlczBfMDQ2IiwidHJhbnNwb3NlX2V4biIsImludGVyc3BlcnNlIiwiaXNfc3VmZml4Iiwic3VmZml4IiwibGlzdF9sZW4iLCJzdWZmaXhfbGVuIiwicmVzMF8wMDIiLCJhcmcwXzAwMyIsInJlczBfMDA0IiwicmVzMF8wMDYiLCJhcmcwXzAwNyIsInJlczBfMDA4IiwiYXJnMl8wMTEiLCJhcmcxXzAxMCIsImFyZzBfMDA5IiwicmVzMF8wMTIiLCJyZXMxXzAxMyIsInJlczJfMDE0IiwiYXJnMV8wMTYiLCJyZXMwXzAxNyIsInJlczFfMDE4IiwiYXJnMl8wMjEiLCJhcmcxXzAyMCIsInJlczFfMDIzIiwicmVzMl8wMjQiLCJhcmcxXzAyNiIsImFyZzBfMDI1IiwicmVzMF8wMjciLCJyZXMxXzAyOCIsImFyZzFfMDMwIiwiYXJnMF8wMjkiLCJyZXMwXzAzMSIsInJlczFfMDMyIiwidG9fc2V4cHNfaHVtIiwic3RyaW5nIiwiaGVyZSIsInNleHAkMCIsInRhZyIsImhlcmUkMCIsInRhZyQwIiwic2V4cCQxIiwidGFnJDEiLCJib2R5IiwidG9fc2V4cF9odW0iLCJzZXhwcyIsImdsb2JhbGl6ZV9pbmZvIiwiY29tcHV0ZV9pbmZvJDAiLCJpbmZvIiwic3RhY2siLCJpbmZvJDAiLCJzdGFjayQwIiwiY29tcHV0ZV9tZXNzYWdlIiwibWVzc2FnZSIsInN0YWNrJDEiLCJsYXp5X2luZm8iLCJpbmZvJDEiLCJpbmZvcyIsImNvbXB1dGVfaW5mb19saXN0IiwiaW5mbyQyIiwic3RhY2skMiIsImluZm8kMyIsInN0YWNrJDMiLCJmd2RfcHJlZml4IiwicmV2X3N1ZmZpeCIsImZ3ZF9wcmVmaXgkMCIsInRhaWwiLCJtZXNzYWdlcyIsIm1lc3NhZ2UkMCIsIm1lc3NhZ2UkMSIsIm1lc3NhZ2UkMiIsInN0YWNrJDQiLCJjb21wdXRlX2luZm8iLCJ0b19tZXNzYWdlIiwib2ZfbWVzc2FnZSIsIm9mX2NvbnMiLCJvZl9sYXp5X2NvbnMiLCJsYXp5X2NvbnMiLCJvZl9sYXp5X21lc3NhZ2UiLCJsYXp5X21lc3NhZ2UiLCJ0b19zdHJpbmdfaHVtIiwib2ZfbGF6eSIsIm9mX2xhenlfc2V4cCIsIm9mX2xhenlfdCIsImNyZWF0ZWYiLCJvZl90aHVuayIsInN0cmljdCIsInNleHBfb2ZfeCIsInRhZ19zX2xhenkiLCJ0YWdfcyIsInRhZ19hcmciLCJ0b19leG4iLCJvZl9leG4iLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwiYmFja3RyYWNlJDIiLCJyYWlzZSIsInJhaXNlX3MiLCJ0b19pbmZvIiwib2ZfaW5mbyIsImNoZWNrX2ZpZWxkIiwiYV8wMTkiLCJiXzAyMCIsImFfMDEzIiwiYl8wMTQiLCJnbG9iYWxpemVfYV8wMjYiLCJ4XzAyNyIsIm9mX2FfMDMwIiwieF8wMzIiLCJvZl9hXzAzMyIsInhfMDM0IiwiaW52YXJpYW50X2EiLCJlMSIsImUyIiwidHJ5X3dpdGhfam9pbiIsIm9mX2V4bl9yZXN1bHQiLCJlcnJvcl9zIiwiZXJyb3Jfc3RyaW5nIiwiZXJyb3JmIiwidW5pbXBsZW1lbnRlZCIsImNvbWJpbmVfaW50ZXJuYWwiLCJvbl9vayIsIm9uX2Vycm9yIiwiaWdub3JlX3VuaXRfbGlzdCIsImVycm9yX29mX2xpc3RfaWZfbmVjZXNzYXJ5IiwiZmlsdGVyX29rX2F0X2xlYXN0X29uZSIsImZpbmRfb2siLCJmaW5kX21hcF9vayIsImVycm9yX3NvdXJjZV8wMDMiLCJzZXhwXzAwNCIsImdlcSIsImxlcSIsImJldHdlZW4iLCJsb3ciLCJoaWdoIiwiY2xhbXBfdW5jaGVja2VkIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJsZXhpY29ncmFwaGljIiwiY21wcyIsImNtcHMkMCIsImxpZnQiLCJyZXZlcnNlIiwiY29tcGFyZV9yZXZlcnNlZCIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwiaGFzaF9wYXJhbSIsInBvbHkiLCJvZl9rZXkiLCJLZXkiLCJ0b19rZXkiLCJoYXNoX3BhcmFtJDAiLCJwb2x5JDAiLCJvZl9rZXkkMCIsInRvX2tleSQwIiwiaGFzaGFibGUiLCJnZXRfcG9zX2xlbiIsImZpbmRfZmlyc3Rfc2F0aXNmeWluZyIsImhpJDAiLCJsbyQxIiwibWlkIiwibG8kMiIsImxvJDAiLCJmaW5kX2xhc3Rfc2F0aXNmeWluZyIsImJpbmFyeV9zZWFyY2giLCJob3ciLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCIsInNlZ21lbnRfb2YiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJhbGwkMCIsImJsaXRfc3RyaW5nIiwic2V0X3VjaGFyX3V0Zl84Iiwic2V0X3VjaGFyX3V0Zl8xNmxlIiwic2V0X3VjaGFyX3V0Zl8xNmJlIiwic2V0X3V0Zl8zMl91Y2hhciIsInNldF9pbnQzMiIsImJ5dGVzIiwidWNoYXIiLCJzZXRfdWNoYXJfdXRmXzMybGUiLCJzZXRfdWNoYXJfdXRmXzMyYmUiLCJ1bnNhZmVfYmxpdCIsInNyY19wb3MiLCJkc3RfcG9zIiwiYmxpdG8iLCJzcmNfbGVuIiwic3VibyIsImNyZWF0ZV9saWtlIiwidW5zYWZlX2JsaXQkMCIsImlzX2ZpcnN0IiwiaXNfc2Vjb25kIiwidmFsdWVfbWFwIiwiZmlyc3QiLCJzZWNvbmQiLCJlcTEiLCJlcTIiLCJsb2NhbF9lcXVhbCIsIm90aGVyIiwiZm9jdXMiLCJjb21iaW5lX2FsbCIsInRzJDEiLCJ0cyQwIiwibWF0Y2gkMCIsIm1hdGNoIiwiY29tYmluZV9hbGxfdW5pdCIsInRvX29wdGlvbiIsImZvY3VzJDAiLCJjb21iaW5lJDAiLCJiaW5kJDAiLCJpc19ub25lIiwiaXNfc29tZSIsIm8iLCJjYWxsIiwidmFsdWVfZXhuIiwiZXJyb3IkMCIsIm0kMCIsIm0kMSIsInZhbHVlX29yX3RodW5rIiwic29tZSIsImZpcnN0X3NvbWUiLCJzb21lX2lmIiwiY29uZCIsImVycm9yX3NvdXJjZV8wNTciLCJvZl9zXzAwMiIsInN0YXRlXzAwNCIsInN0YXRlXzAwOSIsInZhbHVlXzAwNyIsImJuZHNfMDA2IiwiYXJnXzAwOCIsImJuZHNfMDA2JDAiLCJuZXh0IiwidmlldyIsIm5leHRfc3RlcCIsImRlbGF5ZWRfZm9sZF9zdGVwIiwidW5mb2xkX3N0ZXAiLCJ1bmZvbGQiLCJ1bmZvbGRfd2l0aCIsInNlZWQkMCIsInNlZWQkMSIsInVuZm9sZF93aXRoX2FuZF9maW5pc2giLCJydW5uaW5nX3N0ZXAiLCJpbm5lcl9maW5pc2hlZCIsImZpbmlzaGluZ19zdGVwIiwic3RhdGUkMCIsInN0YXRlJDEiLCJzdGF0ZSQyIiwiaW5uZXJfc3RhdGUiLCJzdGF0ZSQzIiwiaW5uZXJfc3RhdGUkMCIsImlubmVyX3N0YXRlJDEiLCJzdGF0ZSQ0Iiwic3RhdGUkNSIsInNlZWQkMiIsInYkMCIsInRvX2xpc3RfcmV2Iiwic3RhcnRfdiIsInN0b3BfdiIsInN0ZXAiLCJ0X2xhenkiLCJsJDIiLCJzb21lX2IiLCJlbXB0eSIsIm5leHQkMCIsInMkMyIsImFfMDIzIiwiYl8wMjQiLCJhXzAyNSIsImJfMDI2IiwiYV8wMTUiLCJiXzAxNiIsImFfMDE3IiwiYl8wMTgiLCJhXzAyMSIsImJfMDIyIiwiYV8wNTEiLCJiXzA1MiIsImEwJDEiLCJoc3YkMyIsIm9mX2FfMDUzIiwib2ZfYl8wNTQiLCJzZXhwXzA1OSIsInRhZ18wNjAiLCJzZXhwX2FyZ3NfMDY2IiwiYXJnMF8wNjciLCJyZXMwXzA2OCIsInNleHBfYXJnc18wNjEiLCJhcmcwXzA2MiIsInJlczBfMDYzIiwic2V4cF9hcmdzXzA3MSIsImFyZzFfMDczIiwiYXJnMF8wNzIiLCJyZXMwXzA3NCIsInJlczFfMDc1Iiwib2ZfYV8wNzgiLCJvZl9iXzA3OSIsImFyZzBfMDgwIiwicmVzMF8wODEiLCJhcmcwXzA4MiIsInJlczBfMDgzIiwiYXJnMV8wODUiLCJhcmcwXzA4NCIsInJlczBfMDg2IiwicmVzMV8wODciLCJtZXJnZV93aXRoX2R1cGxpY2F0ZXMiLCJuZXh0MiIsIm5leHQxIiwiczIkMCIsInMyJDEiLCJzMSQwIiwiczIkMiIsInMxJDEiLCJzMiQzIiwiY29tcGFyaXNvbiIsIm1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZCIsIm1lcmdlX3NvcnRlZCIsInRsX2VhZ2VybHlfZXhuIiwibGlmdF9pZGVudGl0eSIsImNodW5rc19leG4iLCJ6aXBfZnVsbCIsImJvdW5kZWRfbGVuZ3RoIiwiYXRfbW9zdCIsImxlbmd0aF9pc19ib3VuZGVkX2J5IiwiY3VyIiwiY3VyJDAiLCJsYXN0X2VsdCIsImxhc3RfZWx0JDAiLCJzaGlmdF9yaWdodCIsInNoaWZ0X3JpZ2h0X3dpdGhfbGlzdCIsInMkNSIsImEkMSIsInMkNCIsInJlcGVhdCIsImN5Y2xlX2xpc3RfZXhuIiwic2EiLCJzYiIsImRlbGF5ZWRfZm9sZCIsIm9wdGlvbiIsImZvbGRfbSIsIml0ZXJfbSIsImZvcmNlX2VhZ2VybHkiLCJtZW1vaXplIiwiZHJvcF9lYWdlcmx5IiwiZHJvcF93aGlsZV9vcHRpb24iLCJza2lwX2xvb3AiLCJuZXh0X3IiLCJzX3IkMSIsIm5leHRfbCIsInNfbCQxIiwic19sIiwic19yIiwiciQwIiwic19yJDAiLCJzX2wkMCIsImNvbXBhcmVfYV9sb2NhbCIsInJvdW5kX3JvYmluIiwiZG9uZV9zdGFjayIsInRvZG9fc3RhY2siLCJ0b2RvX3N0YWNrJDAiLCJpbnRlcmxlYXZlIiwiZjEiLCJmMiIsImludGVybGVhdmVkX2NhcnRlc2lhbl9wcm9kdWN0Iiwib2Zfc2VxIiwic2VxIiwidG9fc2VxIiwieWllbGQkMCIsIm9mX3NlcXVlbmNlIiwic2VxdWVuY2UiLCJ0aHVuayIsImFfb2Zfc2V4cCIsImJfb2Zfc2V4cCIsInNleHBfb2ZfYiIsImNfb2Zfc2V4cCIsInNleHBfb2ZfYyIsInNldCIsInRtcCIsImxlZnQiLCJyaWdodCIsImZpbmFsX3BvcyIsImlfbmV4dCIsImhlYXBpZnkiLCJyb290Iiwicm9vdCQwIiwicmVsYXRpdmVfcm9vdCIsImxlZnRfY2hpbGQiLCJyaWdodF9jaGlsZCIsImxhcmdlc3QiLCJsYXJnZXN0JDAiLCJzb3J0JDAiLCJmaXZlX2VsZW1lbnRfc29ydCIsIm0xIiwibTIiLCJtMyIsIm00IiwibTUiLCJjb21wYXJlX2FuZF9zd2FwIiwiaW50cm9fc29ydCIsIm1heF9kZXB0aCIsIm1heF9kZXB0aCQwIiwibGVmdCQwIiwibWF4X2RlcHRoJDEiLCJzaXh0aCIsIm0yX3ZhbCIsIm0zX3ZhbCIsIm00X3ZhbCIsIm1pZGRsZV9zb3J0ZWQiLCJwaXZvdDIiLCJwaXZvdDEiLCJwJDEiLCJyJDIiLCJwdiIsInIkMSIsInAkMCIsImxlZnQkMSIsInNvcnQkMSIsInNvcnQkMiIsImVsdF9pX21pbnVzXzEiLCJtZXJnZWQiLCJhMV9pbmRleCIsImEyX2luZGV4IiwidXNlX2ExIiwiY29weV9tYXRyaXgiLCJleHRyZW1hbF9lbGVtZW50Iiwia2VlcF9sZWZ0X2lmIiwiY29tcGFyZV9yZXN1bHQiLCJyZXZfaW5wbGFjZSIsIm9mX2xpc3RfcmV2Iiwib2ZfbGlzdF9tYXAiLCJvZl9saXN0X21hcGkiLCJvZl9saXN0X3Jldl9tYXAiLCJvZl9saXN0X3Jldl9tYXBpIiwiZm9yX2FsbDJfbG9jYWxfZXhuIiwibWFwX2lucGxhY2UiLCJmaW5kaV9pbnRlcm5hbCIsImlmX2ZvdW5kIiwiaWZfbm90X2ZvdW5kIiwiZm91bmQiLCJ2YWx1ZV9mb3VuZCIsInJlczEiLCJyZXMyIiwic29ydGVkX2NvcHkiLCJwYXJ0aXRpb25fbWFwaSIsImZpcnN0cyIsInNlY29uZHMiLCJwYXJ0aXRpb25pX3RmIiwidG9fc2VxdWVuY2VfbXV0YWJsZSIsInRvX3NlcXVlbmNlIiwiaTEiLCJpMiIsInR0Iiwid2lkdGgiLCJkZXB0aCIsImQiLCJ3IiwidHQkMCIsImdldCQwIiwiY2VpbCIsImZsb29yIiwibW9kX2Zsb2F0IiwibW9kZiIsIm1heF9maW5pdGVfdmFsdWUiLCJjbGFzc2lmeV9mbG9hdCIsImFic19mbG9hdCIsImlzX2ludGVnZXIiLCJmcmV4cCIsImxkZXhwIiwiaXNfbmFuIiwidG9faW50NjRfcHJlc2VydmVfb3JkZXIiLCJ0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlcl9leG4iLCJvZl9pbnQ2NF9wcmVzZXJ2ZV9vcmRlciIsIm9uZV91bHAiLCJkaXIiLCJ1cHBlcl9ib3VuZF9mb3JfaW50IiwiZXhwIiwiaXNfeF9taW51c19vbmVfZXhhY3QiLCJsb3dlcl9ib3VuZF9mb3JfaW50IiwibWluX2ludF9hc19mbG9hdCIsInRvX2NsYW1wX21heWJlX25hbiIsIm1pbl93aGljaF9pc19ub3RfbmFuIiwibWF4X3doaWNoX2lzX25vdF9uYW4iLCJ0X21heWJlX25hbiIsImJveCIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQ2M19vbl9pbiIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQ2NF92YWx1ZSIsImludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsIm92ZXJmbG93X2JvdW5kX21heF9pbnRfdmFsdWUiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50MzJfdmFsdWUiLCJpbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwiaW50NjNfb25faW50NjRfcG9zaXRpdmVfb3ZlcmZsIiwiaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwiaW50NjRfbmVnYXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwibmVnYXRpdmVfZXhwb25lbnQiLCJvdmVyZmxvdyIsImludF9wb3ciLCJiYXNlIiwiZXhwb25lbnQiLCJpbnQ2NF9wb3ciLCJpbnQ2M19wb3dfb25faW50NjQiLCJydmFsIiwib25lIiwicm91bmRfZG93biIsIm1vZHVsdXMiLCJyb3VuZF91cCIsInJlbWFpbmRlciIsInJvdW5kX3Rvd2FyZHNfemVybyIsInRvX211bHRpcGxlX29mIiwicm91bmRfbmVhcmVzdCIsIm1vZHVsdXNfbWludXNfcmVtYWluZGVyIiwicm91bmQiLCJzdGFnZSIsInVuc3RhZ2UiLCJpc19sb3dlcmNhc2UiLCJpc191cHBlcmNhc2UiLCJpc19wcmludCIsImlzX3doaXRlc3BhY2UiLCJpc19kaWdpdCIsImlzX2FscGhhIiwiaXNfYWxwaGFudW0iLCJnZXRfZGlnaXRfdW5zYWZlIiwiZ2V0X2RpZ2l0X2V4biIsImdldF9kaWdpdCIsImlzX2hleF9kaWdpdCIsImlzX2hleF9kaWdpdF9sb3dlciIsImlzX2hleF9kaWdpdF91cHBlciIsImdldF9oZXhfZGlnaXRfZXhuIiwiZ2V0X2hleF9kaWdpdCIsInRfb2Zfc2V4cCQxIiwiYzEiLCJjMiIsImhhc2hfZm9sZF90JDEiLCJoYXNoJDEiLCJ0cl9jcmVhdGVfbWFwIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0cl9tYXAiLCJpJDMiLCJpbmRleCQwIiwibGFzdF9yZXBsYWNlbWVudCIsImluZGV4IiwiZmlyc3RfdGFyZ2V0IiwiY29kZWNfbmFtZSIsImNvZGVjX25hbWUkMCIsIm1vZHVsZV9uYW1lJDAiLCJjb2RlY19uYW1lJDEiLCJtb2R1bGVfbmFtZSQxIiwiY29kZWNfbmFtZSQyIiwibW9kdWxlX25hbWUkMiIsImNvZGVjX25hbWUkMyIsIm1vZHVsZV9uYW1lJDMiLCJ1bnNhZmVfc3ViIiwiY29udGFpbnMiLCJlbmQiLCJpbmRleF9mcm9tX2ludGVybmFsIiwiaW5kZXhfZXhuIiwiaW5kZXhfZnJvbSIsImluZGV4X2Zyb21fZXhuIiwicmluZGV4X2Zyb21faW50ZXJuYWwiLCJyaW5kZXgiLCJyaW5kZXhfZXhuIiwicmluZGV4X2Zyb20iLCJyaW5kZXhfZnJvbV9leG4iLCJjYXNlX3NlbnNpdGl2ZSIsInBhdHRlcm4iLCJrbXBfaW50ZXJuYWxfbG9vcCIsIm1hdGNoZWRfY2hhcnMiLCJuZXh0X3RleHRfY2hhciIsImttcF9hcnJheSIsImNoYXJfZXF1YWwiLCJtYXRjaGVkX2NoYXJzJDAiLCJnZXRfY2hhcl9lcXVhbCIsImluZGV4X2ludGVybmFsIiwidGV4dCIsIm1hdGNoZXMiLCJpbiQwIiwiaW5kZXhfZXhuJDAiLCJpbmRleF9hbGwiLCJtYXlfb3ZlcmxhcCIsInJlcGxhY2VfZmlyc3QiLCJ3aXRoJDAiLCJsZW5fcyIsImxlbl90IiwibGVuX3dpdGgiLCJyZXBsYWNlX2FsbCIsIm51bV9tYXRjaGVzIiwibmV4dF9kc3RfcG9zIiwibmV4dF9zcmNfcG9zIiwic3BsaXRfb24iLCJwYXR0ZXJuX2xlbiIsImttcF9hcnJheV8wMTIiLCJjYXNlX3NlbnNpdGl2ZV8wMTAiLCJwYXR0ZXJuXzAwOCIsImFyZ18wMTMiLCJibmRzXzAwNyIsImJuZHNfMDA3JDAiLCJibmRzXzAwNyQxIiwicmVwcmVzZW50YXRpb24iLCJzdWJzdHJfaW5kZXhfZ2VuIiwic3Vic3RyX2luZGV4X2V4bl9nZW4iLCJzdWJzdHJfaW5kZXhfYWxsX2dlbiIsInN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiIsInN1YnN0cl9yZXBsYWNlX2FsbF9nZW4iLCJpc19zdWJzdHJpbmdfZ2VuIiwic3Vic3RyaW5nIiwic3Vic3RyX2luZGV4Iiwic3Vic3RyX2luZGV4X2V4biIsInN1YnN0cl9pbmRleF9hbGwiLCJzdWJzdHJfcmVwbGFjZV9maXJzdCIsInN1YnN0cl9yZXBsYWNlX2FsbCIsImlzX3N1YnN0cmluZyIsImlzX3N1YnN0cmluZ19hdF9nZW4iLCJzdHJfcG9zJDEiLCJzdHJfbGVuIiwic3ViX2xlbiIsInN0cl9wb3MiLCJzdWJfcG9zIiwic3ViX3BvcyQwIiwic3RyX3BvcyQwIiwiaXNfc3VmZml4X2dlbiIsInN0cmluZ19sZW4iLCJpc19wcmVmaXhfZ2VuIiwicHJlZml4X2xlbiIsInNleHBfb2ZfdCQyIiwic3RyaW5nMSIsInN0cmluZzIiLCJsZW4yIiwibGVuMSIsInN1YnN0cl9pbmRleCQwIiwic3Vic3RyX2luZGV4X2V4biQwIiwic3Vic3RyX2luZGV4X2FsbCQwIiwic3Vic3RyX3JlcGxhY2VfZmlyc3QkMCIsInN1YnN0cl9yZXBsYWNlX2FsbCQwIiwiaXNfc3Vic3RyaW5nJDAiLCJpc19zdWJzdHJpbmdfYXQiLCJsc3BsaXQyX2V4biIsImxpbmUiLCJkZWxpbSIsInJzcGxpdDJfZXhuIiwibHNwbGl0MiIsIm9uIiwicnNwbGl0MiIsImNoYXJfbGlzdF9tZW0iLCJzcGxpdF9nZW4iLCJpc19kZWxpbSIsImxhc3RfcG9zIiwibGFzdF9wb3MkMSIsImxhc3RfcG9zJDAiLCJwb3MxIiwic3ViX3N0ciIsInNwbGl0Iiwic3BsaXRfb25fY2hhcnMiLCJjaGFycyIsImlzX3N1ZmZpeCQwIiwiaXNfcHJlZml4JDAiLCJpc19zdWJzdHJpbmdfYXQkMCIsIndyYXBfc3ViX24iLCJkcm9wX3ByZWZpeCIsImRyb3Bfc3VmZml4IiwibGZpbmRpIiwicmZpbmRpIiwibGFzdF9ub25fZHJvcCIsInJzdHJpcCIsImZpcnN0X25vbl9kcm9wIiwibHN0cmlwIiwic3RyaXAiLCJ0ciIsInRyX211bHRpIiwiY29uY2F0X2FycmF5IiwiYXIiLCJjb25jYXRfbGluZXMiLCJsaW5lcyQzIiwiY3JsZiIsIm5ld2xpbmVfbGVuIiwibGluZXMiLCJsaW5lcyQwIiwiYnVmIiwibGluZXMkMSIsIndyaXR0ZW4iLCJsaW5lcyQyIiwibGluZSQwIiwib3V0Iiwib3V0X3BvcyIsIm91dCQwIiwiY2hvcF9wcmVmaXgiLCJjaG9wX3ByZWZpeF9pZl9leGlzdHMiLCJjaG9wX3ByZWZpeF9leG4iLCJjaG9wX3N1ZmZpeCIsImNob3Bfc3VmZml4X2lmX2V4aXN0cyIsImNob3Bfc3VmZml4X2V4biIsInNob3J0ZXIiLCJzaG9ydGVzdCIsInBvc19mcm9tX2xlZnQiLCJwb3NfZnJvbV9yaWdodCIsImNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCIsImdldF9wb3MiLCJtYXhfbGVuIiwibGVuX3NvX2ZhciIsImxlbl9zb19mYXIkMCIsImxlbl9zb19mYXIkMSIsImNvbW1vbl9nZW5lcmljMl9sZW5ndGgiLCJjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCIsImZpcnN0JDAiLCJtYXhfbGVuJDAiLCJtYXhfbGVuJDEiLCJjb21tb25fZ2VuZXJpY19sZW5ndGgiLCJjb21tb25fZ2VuZXJpYzIiLCJjb21tb25fZ2VuZXJpYyIsImNvbW1vbl9wcmVmaXgiLCJjb21tb25fc3VmZml4IiwiY29tbW9uX3ByZWZpeDIiLCJjb21tb25fc3VmZml4MiIsImNvbW1vbl9wcmVmaXhfbGVuZ3RoIiwiY29tbW9uX3N1ZmZpeF9sZW5ndGgiLCJjb21tb25fcHJlZml4Ml9sZW5ndGgiLCJjb21tb25fc3VmZml4Ml9sZW5ndGgiLCJvZl9jaGFyIiwib2ZfY2hhcl9saXN0IiwicGFkX3JpZ2h0IiwicGFkX2xlZnQiLCJsb2NhbF9jb3B5X3ByZWZpeCIsImJ1ZmZlcl9sZW4iLCJsb2NhbF9jb3B5X3RvX3N0cmluZyIsInNyY19wb3MkMCIsImRzdF9wb3MkMCIsInBhcnRpdGlvbl9tYXBfZGlmZmVyZW5jZSIsImZzdF9wb3MkMCIsInNuZF9wb3MkMCIsImZzdHMiLCJzbmRzIiwic25kX3BvcyQxIiwiZnN0X3BvcyQxIiwic25kX3BvcyQyIiwic3JjX3BvcyQxIiwiZnN0X3BvcyIsInNuZF9wb3MiLCJjMSQxIiwiZWl0aGVyJDEiLCJjMiQxIiwiYzIkMiIsImMxJDAiLCJlaXRoZXIkMCIsImMyJDAiLCJwb3MkMiIsImVkaXRfZGlzdGFuY2UiLCJ0YWJsZSIsImF0IiwiZGVsIiwiYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoIiwiZXNjYXBld29ydGh5X21hcCIsImVzY2FwZV9jaGFyIiwiZXNjYXBld29ydGh5X21hcCQwIiwidmFscyIsImNfdG8iLCJjX2Zyb20iLCJrJDAiLCJlc2NhcGVfZ2VuIiwiZXNjYXBld29ydGh5IiwidG9fZXNjYXBlX2xlbiIsInRvX2VzY2FwZSIsImxhc3RfaWR4IiwibGFzdF9kc3RfcG9zIiwibGFzdF9pZHgkMCIsImxhc3RfZHN0X3BvcyQwIiwidG9fZXNjYXBlJDAiLCJlc2NhcGVkX2NoYXIiLCJsYXN0X2lkeCQxIiwibGFzdF9kc3RfcG9zJDEiLCJlc2NhcGVfZ2VuX2V4biIsImVzY2FwZSIsInVuZXNjYXBlX2dlbiIsInN0YXR1cyIsInRvX3VuZXNjYXBlIiwic3RhdHVzJDAiLCJ0b191bmVzY2FwZSQwIiwidW5lc2NhcGVfZ2VuX2V4biIsInVuZXNjYXBlIiwicHJlY2VkaW5nX2VzY2FwZV9jaGFycyIsImNudCIsImNudCQwIiwidXBkYXRlX2VzY2FwZV9zdGF0dXMiLCJlc2NhcGVfc3RhdHVzIiwib2RkIiwiY2hlY2tfYm91bmQiLCJmdW5jdGlvbl9uYW1lIiwiaXNfY2hhcl9lc2NhcGluZyIsImlzX2NoYXJfZXNjYXBlZCIsImlzX2NoYXJfbGl0ZXJhbCIsImluZGV4X2Zyb20kMCIsInN0YXR1cyQxIiwiaW5kZXhfZnJvbV9leG4kMCIsImluZGV4JDEiLCJpbmRleF9leG4kMSIsInJpbmRleF9mcm9tJDAiLCJlc2NhcGVfY2hhcnMiLCJyaW5kZXhfZnJvbV9leG4kMCIsInJpbmRleCQwIiwicmluZGV4X2V4biQwIiwic3BsaXRfZ2VuJDAiLCJzcGxpdCQwIiwic3BsaXRfb25fY2hhcnMkMCIsInNwbGl0X2F0IiwibHNwbGl0MiQwIiwicnNwbGl0MiQwIiwibHNwbGl0Ml9leG4kMCIsInJzcGxpdDJfZXhuJDAiLCJsYXN0X25vbl9kcm9wX2xpdGVyYWwiLCJmaXJzdF9ub25fZHJvcF9saXRlcmFsIiwicnN0cmlwX2xpdGVyYWwiLCJsc3RyaXBfbGl0ZXJhbCIsInN0cmlwX2xpdGVyYWwiLCJiZXR3ZWVuJDAiLCJjbGFtcF9leG4kMCIsImNsYW1wJDAiLCJjcmVhdGUkMCIsImlzX3ZhbGlkIiwicmFpc2VfZ2V0X21lc3NhZ2UiLCJyYWlzZV9nZXQiLCJkZWNvZGUiLCJvZl9zdHJpbmdfdW5jaGVja2VkIiwicmFpc2Vfb2Zfc3RyaW5nX21lc3NhZ2UiLCJyYWlzZV9vZl9zdHJpbmciLCJieXRlX3BvcyQwIiwic2FuaXRpemUiLCJ1Y2hhcnMiLCJ1bnRpbCIsInN0YXJ0JDEiLCJ1bnRpbCQwIiwiYnl0ZV9sZW5ndGgiLCJieXRlX2xlbmd0aCQwIiwic2V0JDAiLCJieXRlX2xlbmd0aCQxIiwic2V0JDEiLCJnZXRfZGVjb2RlX3Jlc3VsdCIsInNldCQyIiwic2V0JDMiLCJjcmVhdGUkMSIsIm1hcGkkMCIsIm9jYW1sX2xleF90YWJsZXMiLCJwYXJzZV9oZXgiLCJsZXhidWYiLCJvY2FtbF9sZXhfc3RhdGUiLCJvY2FtbF9sZXhfc3RhdGUkMCIsImluc2VydF9kZWxpbWl0ZXJfZXZlcnkiLCJkZWxpbWl0ZXIiLCJjaGFyc19wZXJfZGVsaW1pdGVyIiwiaW5wdXRfbGVuZ3RoIiwiaGFzX3NpZ24iLCJudW1fZGlnaXRzIiwibnVtX2RlbGltaXRlcnMiLCJvdXRwdXRfbGVuZ3RoIiwiaW5wdXRfcG9zIiwib3V0cHV0X3BvcyIsIm51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIiLCJmaXJzdF9kaWdpdF9wb3MiLCJpbnNlcnRfZGVsaW1pdGVyIiwiaW5zZXJ0X3VuZGVyc2NvcmVzIiwic2V4cF9vZl9pbnRfc3R5bGUiLCJ0b19zdHJpbmdfc3VmZml4IiwiY2hhcl9pbmRleCIsImJpdF9pbmRleCIsImJpdCIsImRlbGltaXRlciQwIiwibWFrZV9zdWZmaXgiLCJ0b19zdHJpbmckMCIsImludmFsaWQiLCJvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIiLCJsZXgiLCJib2R5JDAiLCJoMDEiLCJtYXNrIiwiaW50NjRfcG9wY291bnQiLCJ4JDIiLCJpbnQzMl9wb3Bjb3VudCIsIm5hdGl2ZWludF9wb3Bjb3VudCIsIm9mX3N0cmluZyQwIiwiZmxvYXRfbG93ZXJfYm91bmQiLCJmbG9hdF91cHBlcl9ib3VuZCIsIm9mX2Zsb2F0X3VuY2hlY2tlZCIsInplcm8iLCJtaW51c19vbmUiLCJmdW5jJDAiLCJuZWciLCJvZl9zdHJpbmckMSIsIm9mX2ludDMyIiwib2ZfaW50MzJfZXhuIiwidG9faW50MzIiLCJ0b19pbnQzMl9leG4iLCJvZl9pbnQ2NCIsIm9mX2ludDY0X2V4biIsInRvX2ludDY0Iiwib2ZfbmF0aXZlaW50Iiwib2ZfbmF0aXZlaW50X2V4biIsInRvX25hdGl2ZWludCIsIm1heF92YWx1ZV8zMF9iaXRzIiwiYWJzIiwicmVtIiwiaW5jciIsImRlY3IiLCJzaGlmdF9yaWdodF9sb2dpY2FsIiwic2hpZnRfbGVmdCIsImJpdF9ub3QiLCJiaXRfb3IiLCJiaXRfYW5kIiwiYml0X3hvciIsInBvdyIsIm5vbl9wb3NpdGl2ZV9hcmd1bWVudCIsImNlaWxfcG93MiIsIngkMyIsIngkNCIsIngkNSIsIngkNiIsImZsb29yX3BvdzIiLCJpc19wb3cyIiwiZmxvb3JfbG9nMiIsImNlaWxfbG9nMiIsInBvcGNvdW50IiwiZnVuYyQxIiwiY2x6IiwibG5vdCIsInNpemUiLCJzdGFja19vcl9oZWFwX29mX3NleHAiLCJzZXhwX29mX3N0YWNrX29yX2hlYXAiLCJjb21wYXJlX3N0YWNrX29yX2hlYXAiLCJzdGFja19vcl9oZWFwIiwicmVwciIsInplcm9fb2JqIiwiY3JlYXRlX3plcm8iLCJ1bnNhZmVfZ2V0IiwidW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5Iiwib2JqIiwic2V0X3dpdGhfY2FtbF9tb2RpZnkiLCJ1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW4iLCJvbGRfb2JqIiwidW5zYWZlX3NldCIsInVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZSIsInVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5XyIsInVuc2FmZV9zZXRfaW50IiwidW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIiLCJ1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQiLCJjcmVhdGVfb2JqX2FycmF5IiwidW5zYWZlX2dldF9sb2NhbCIsInVuc2FmZV90b19hcnJheV9pbnBsYWNlX3Byb21pcyIsInRvdGFsX2xlbiIsInNvX2ZhciIsInJpZ2h0X2lkeCIsImxlZnRfaWR4IiwiZGF0YSIsInRyaW0iLCJncmFtbWFyIiwibW9kdWxlX25hbWUkNCIsInRvX3N0cmluZ19pbnRlcm5hbCIsInN1Y2NfZXhuIiwibXNnIiwicHJlZF9leG4iLCJvZl9zY2FsYXIiLCJvZl9zY2FsYXJfZXhuIiwidG9fc2NhbGFyIiwidG9fY2hhciIsInRvX2NoYXJfZXhuIiwiaXNfdmFsaWQkMCIsImJ5dGVzX2NvbnN1bWVkIiwidWNoYXJfb3JfcmVwbGFjZW1lbnRfY2hhciIsInVjaGFyX2V4biIsIm9mX3N0cmluZ19tZXNzYWdlIiwiZGVjb2RlX2xlbiIsImdldF9kZWNvZGVfcmVzdWx0JDAiLCJnZXRfZGVjb2RlX3Jlc3VsdCQxIiwiZ2V0X2RlY29kZV9yZXN1bHQkMiIsImdldF9kZWNvZGVfcmVzdWx0JDMiLCJyZWZsIiwic3ltIiwidHJhbnMiLCJjb252IiwiZGV0dXBsZTIiLCJ0dXBsZTIiLCJhcmcxXzAxNCIsImFyZzBfMDEzIiwicmVzMF8wMTUiLCJyZXMxXzAxNiIsImFyZ3MiLCJ1aWQiLCJBIiwidG9fc2V4cCIsInNhbWVfd2l0bmVzcyIsIkIiLCJzYW1lX3dpdG5lc3NfZXhuIiwic2FtZSIsIlQwIiwiaWRfbmFtZSIsImlkX3NleHAiLCJ0eXBlX2VxdWFsIiwib3RoZXJrZXkiLCJ0eXBlX2VxdWFsX2lkIiwiQyIsInR5cGVfa2V5IiwiY2tleSIsImJrZXkiLCJha2V5Iiwibm9uZV9zdWJzdGl0dXRlIiwibm9uZSIsInZhbHVlX3Vuc2FmZSIsIm9mX3NleHBhYmxlIiwidG9fc2V4cGFibGUiLCJ4XzAwMyIsIm9mX2FfMDA0IiwieF8wMDUiLCJpbml0X3NvbWUiLCJnZXRfbG9jYWwiLCJnZXRfc29tZV9leG4iLCJpc19ub25lJDAiLCJpc19zb21lJDAiLCJzZXRfc29tZSIsInNldF9ub25lIiwidW5zYWZlX2dldF9zb21lX2V4biIsInVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIiwidW5zYWZlX2lzX3NvbWUiLCJ1bnNhZmVfc2V0X3NvbWUiLCJ1bnNhZmVfc2V0X25vbmUiLCJjbGVhciIsImVsZW0iLCJtYXBfc29tZSIsIm9mX2FycmF5X3NvbWUiLCJjYXBhY2l0eSIsImVsdHMiLCJsZW5ndGhfMDAzIiwiZWx0c18wMDUiLCJhcmdfMDA2IiwiYm5kc18wMDIiLCJhcmdfMDA0IiwiYm5kc18wMDIkMCIsInJlc2l6ZSIsInNldF9jYXBhY2l0eSIsIm5ld19jYXBhY2l0eSIsIm5ld19jYXBhY2l0eSQwIiwicHVzaCIsInBvcF9ub25lbXB0eSIsInBvcF9lcnJvciIsInBvcCIsInBvcF9leG4iLCJ0b3Bfbm9uZW1wdHkiLCJ0b3BfZXJyb3IiLCJ0b3AiLCJ0b3BfZXhuIiwidW50aWxfZW1wdHkiLCJ0X3Jlc3VsdCIsImZpbHRlcl9pbnBsYWNlIiwid3JpdGVfaW5kZXgiLCJyZWFkX2luZGV4IiwiaGFzaF9vdmVycmlkZSIsIm9mX3BvcyIsIm9mX3NpZ24iLCJ0b19zaWduX2V4biIsInRvX2ludF9leG4iLCJlcnJvcl9zb3VyY2VfMDA2IiwiZXJyb3Jfc291cmNlXzAzMyIsImludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbSIsImFsbF9vZl9hIiwiZW51bWVyYXRlXzAwMiIsImVudW1lcmF0ZV8wMDEiLCJhY2MkMiIsIm9mX2FfMDAzIiwic2V4cF8wMDgiLCJ0YWdfMDA5Iiwic2V4cF9hcmdzXzAxMCIsImFyZzBfMDExIiwic2V4cF9hcmdzXzAxNSIsImFyZzBfMDE2IiwiYXJnMF8wMjAiLCJyZXMwXzAyMSIsImFyZ18wMjkiLCJhcmdfMDMwIiwiaW50ZXJ2YWxfY29tcGFyaXNvbl9vZl9zZXhwIiwic2V4cF8wMzQiLCJzZXhwX29mX2ludGVydmFsX2NvbXBhcmlzb24iLCJjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb25fbG8iLCJjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb24iLCJoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImhhc2hfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImluY2wiLCJleGNsIiwiaXNfbG93ZXJfYm91bmQiLCJpc191cHBlcl9ib3VuZCIsImJvdW5kc19jcm9zc2VkIiwibG93ZXIiLCJ1cHBlciIsImxvd2VyJDAiLCJ1cHBlciQwIiwiY29tcGFyZV90b19pbnRlcnZhbF9leG4iLCJpbnRlcnZhbF9jb250YWluc19leG4iLCJyaWdodF8wMDQiLCJsZWZ0XzAwMyIsInJpZ2h0XzAwOCIsImxlZnRfMDA3Iiwib2ZfYV8wMDkiLCJ2XzAxMCIsImNtcF9rIiwiY21wX3YiLCJ0XzAxNCIsInRfMDEzIiwidF8wMTYiLCJ0XzAxNSIsInJpZ2h0XzAxOCIsImxlZnRfMDE3IiwicmlnaHRfMDIyIiwibGVmdF8wMjEiLCJ0XzAyNCIsInRfMDIzIiwidF8wMjYiLCJ0XzAyNSIsInJpZ2h0XzAyMCIsImxlZnRfMDE5IiwidF8wMzAiLCJ0XzAyOSIsInRfMDMyIiwidF8wMzEiLCJyaWdodF8wMzQiLCJsZWZ0XzAzMyIsInJpZ2h0XzAzOCIsImxlZnRfMDM3IiwidF8wNDAiLCJ0XzAzOSIsInRfMDQyIiwidF8wNDEiLCJyaWdodF8wMzYiLCJsZWZ0XzAzNSIsIm9mX2tfMDQzIiwib2Zfdl8wNDQiLCJzZXhwXzA3MSIsImFyZzFfMDY4IiwicmVzMF8wNjkiLCJhdG9tXzA0NyIsInNleHBfYXJnc18wNTAiLCJhdG9tXzA0NyQwIiwiYXJnMF8wNTgiLCJhcmcxXzA1MyIsImFyZzBfMDUyIiwicmVzMF8wNTQiLCJyZXMxXzA1NSIsInJlczBfMDU5IiwiYXJnMF8wNjEiLCJyZXMwXzA2MiIsImFyZzBfMDY0IiwicmVzMF8wNjUiLCJyZXMxXzA3MCIsIm9mX2tfMDcyIiwib2Zfdl8wNzMiLCJhcmcxXzA4MiIsImFyZzBfMDgxIiwidl8wNzQiLCJyZXMxXzA4NCIsInZfMDc2IiwiYXJnMV8wNzgiLCJhcmcwXzA3NyIsInJlczBfMDc5IiwicmVzMV8wODAiLCJ2XzA3NSIsImtfc2V4cF9ncmFtbWFyIiwidl9zZXhwX2dyYW1tYXIiLCJjbXBfbGVmdCIsImNtcF9yaWdodCIsImFfMDg1IiwiYl8wODYiLCJyaWdodF8wOTIiLCJsZWZ0XzA5MSIsInRfMDk0IiwidF8wOTMiLCJ0XzA5NiIsInRfMDk1IiwicmlnaHRfMDg4IiwibGVmdF8wODciLCJyaWdodF8wOTAiLCJsZWZ0XzA4OSIsImFfMDk3IiwiYl8wOTgiLCJyaWdodF8xMDQiLCJsZWZ0XzEwMyIsInRfMTA2IiwidF8xMDUiLCJ0XzEwOCIsInRfMTA3IiwicmlnaHRfMTAwIiwibGVmdF8wOTkiLCJyaWdodF8xMDIiLCJsZWZ0XzEwMSIsIm9mX2xlZnRfMTA5Iiwib2ZfcmlnaHRfMTEwIiwidl8xMTMiLCJhcmcxXzExNSIsImFyZzBfMTE0IiwicmVzMF8xMTYiLCJyZXMxXzExNyIsInZfMTExIiwidl8xMTIiLCJzZXhwX29mX3QkMyIsImhlaWdodCIsImluX3JhbmdlIiwiaGwiLCJociIsImxvd2VyJDEiLCJpbnZhcmlhbnRzIiwic2wiLCJzciIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayIsImtsIiwiayQxIiwia2wkMCIsImskMiIsImtyIiwibGVmdF9sZW5ndGgiLCJyaWdodF9sZW5ndGgiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIiwiYXJyYXlfbGVuZ3RoIiwib2Zfc29ydGVkX2FycmF5IiwiaW5jcmVhc2luZyIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiQwIiwibHJsIiwibHJ2IiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2JDAiLCJybGwiLCJybHYiLCJhdXgiLCJhZGRfbWluIiwiYWRkX21heCIsImxoIiwibHYkMCIsInJoIiwicnYkMCIsIm1pbl9lbHRfZXhuIiwiZm9sZF91bnRpbF9oZWxwZXIiLCJ2YWx1ZSQwIiwibWF4X2VsdF9leG4iLCJyZW1vdmVfbWluX2VsdCIsIm1heWJlX2VsdCIsIm1heWJlX2VsdCQwIiwic3BsaXRfbGVfZ3QiLCJzcGxpdF9sdF9nZSIsImVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsInJlbW92ZV9pbmRleCIsImxfc2l6ZSIsInVuaW9uIiwidjEkMCIsInYyIiwidjIkMCIsInIyJDAiLCJyMSQwIiwidjEiLCJ1bmlvbl9saXN0IiwidG9fdHJlZSIsImludGVyIiwib3RoZXJfc2V0IiwiZSQxIiwiY29uc19yaWdodCIsIm9mX3NldCIsImVudW0kMCIsInRyZWUiLCJzeW1tZXRyaWNfZGlmZiIsImVsdCQwIiwiZW51bTEiLCJ0cmVlMSIsImVudW0yIiwidHJlZTIiLCJuZXh0X3N0YXRlIiwiZ3JlYXRlcl9vcl9lcXVhbF90byIsImxlc3Nfb3JfZXF1YWxfdG8iLCJpbmNsdXNpdmVfYm91bmQiLCJzaWRlIiwibWF5YmUiLCJ2JDEiLCJ2JDIiLCJ2JDMiLCJ2JDQiLCJlJDIiLCJtZXJnZV90b19zZXF1ZW5jZSIsImUyJDIiLCJlMSQyIiwiZTIkMCIsImUxJDAiLCJlMiQxIiwiZTEkMSIsInQyJDIiLCJ0MSQyIiwiaXNfc3Vic2V0IiwiYXJlX2Rpc2pvaW50IiwiZmlsdCIsImtlZXBfdiIsImxfZiIsImxfdCIsImtlZXBfdl90Iiwicl9mIiwicl90IiwibWsiLCJlbGVtZW50c19hdXgiLCJlbGVtZW50cyIsImNob29zZSIsImNob29zZV9leG4iLCJwb3NfcmVmIiwiZ3JvdXBfYnkiLCJlcXVpdiIsImVxdWl2X2NsYXNzZXMiLCJub3RfZXF1aXZfeCIsImVxdWl2X3giLCJlcXVpdl9jbGFzc2VzJDAiLCJzdGFibGVfZGVkdXBfbGlzdCIsImxlZnRvdmVycyIsImFscmVhZHlfc2VlbiIsImFscmVhZHlfc2VlbiQwIiwibGVmdG92ZXJzJDAiLCJ0X29mX3NleHBfZGlyZWN0IiwiZWx0X2xzdCIsImVsX3NleHAiLCJlbCIsImlzX3N1YnNldCQwIiwic3Vic2V0Iiwic3VwZXJzZXQiLCJzZXhwX29mX2VsdCIsImludmFsaWRfZWxlbWVudHMiLCJpbnZhbGlkX2VsZW1lbnRzX3NleHAiLCJsaWtlIiwibGlrZV9tYXliZV9ub19vcCIsIm9sZF90Iiwib2xkX3RyZWUiLCJjb21wYXJhdG9yX3MiLCJpbnZhcmlhbnRzJDAiLCJlbGVtZW50cyQwIiwibWluX2VsdF9leG4kMCIsIm1heF9lbHRfZXhuJDAiLCJjaG9vc2UkMCIsImNob29zZV9leG4kMCIsImZvbGRfcmlnaHQkMCIsIml0ZXIyJDAiLCJmaWx0ZXIkMCIsImFkZCQwIiwicmVtb3ZlJDAiLCJ1bmlvbiQwIiwiaW50ZXIkMCIsImRpZmYkMCIsInN5bW1ldHJpY19kaWZmJDAiLCJjb21wYXJlX2RpcmVjdCIsImlzX3N1YnNldCQxIiwib2YiLCJhcmVfZGlzam9pbnQkMCIsInRvX25hbWVkX3RyZWUiLCJuYW1lZCIsImlzX3N1YnNldCQyIiwicGFydGl0aW9uX3RmJDAiLCJ0cmVlX2YiLCJ0cmVlX3QiLCJzcGxpdF9sZV9ndCQwIiwic3BsaXRfbHRfZ2UkMCIsImdyb3VwX2J5JDAiLCJudGgkMCIsInJlbW92ZV9pbmRleCQwIiwidG9fc2VxdWVuY2UkMCIsImJpbmFyeV9zZWFyY2gkMCIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkJDAiLCJtZXJnZV90b19zZXF1ZW5jZSQwIiwiaGFzaF9mb2xkX2RpcmVjdCIsInRfb2Zfc2V4cF9kaXJlY3QkMCIsImludmFyaWFudHMkMSIsImlzX2VtcHR5JDEiLCJlbGVtZW50cyQxIiwibWluX2VsdCQxIiwibWluX2VsdF9leG4kMSIsIm1heF9lbHQkMSIsIm1heF9lbHRfZXhuJDEiLCJjaG9vc2UkMSIsImNob29zZV9leG4kMSIsInRvX2xpc3QkMSIsInRvX2FycmF5JDEiLCJpdGVyJDIiLCJleGlzdHMkMSIsImZvcl9hbGwkMSIsImNvdW50JDEiLCJzdW0kMSIsImZpbmQkMSIsImZpbmRfZXhuJDEiLCJmaW5kX21hcCQxIiwiZm9sZCQxIiwiZm9sZF91bnRpbCQxIiwiZm9sZF9yaWdodCQxIiwiZmlsdGVyJDEiLCJmaWx0ZXJfbWFwJDAiLCJwYXJ0aXRpb25fdGYkMSIsIml0ZXIyJDEiLCJtZW0kMSIsImFkZCQxIiwicmVtb3ZlJDEiLCJ1bmlvbiQxIiwiaW50ZXIkMSIsImRpZmYkMSIsInN5bW1ldHJpY19kaWZmJDEiLCJjb21wYXJlX2RpcmVjdCQwIiwiaXNfc3Vic2V0JDMiLCJhcmVfZGlzam9pbnQkMSIsIm9mX3NlcXVlbmNlJDAiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDAiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2skMCIsIm9mX3NvcnRlZF9hcnJheSQwIiwidW5pb25fbGlzdCQwIiwic3RhYmxlX2RlZHVwX2xpc3QkMCIsImdyb3VwX2J5JDEiLCJzcGxpdCQxIiwic3BsaXRfbGVfZ3QkMSIsInNwbGl0X2x0X2dlJDEiLCJudGgkMSIsInJlbW92ZV9pbmRleCQxIiwib2ZfdHJlZSIsInRvX3NlcXVlbmNlJDEiLCJiaW5hcnlfc2VhcmNoJDEiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQxIiwibWVyZ2VfdG9fc2VxdWVuY2UkMSIsImlzX3N1YnNldCQ0IiwidG9fdHJlZSQwIiwib2ZfdHJlZSQwIiwidF9vZl9zZXhwX2RpcmVjdCQxIiwiZW1wdHkkMCIsInNpbmdsZXRvbiQwIiwidW5pb25fbGlzdCQxIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCQxIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDEiLCJvZl9zb3J0ZWRfYXJyYXkkMSIsIm9mX2xpc3QkMSIsIm9mX3NlcXVlbmNlJDEiLCJvZl9hcnJheSQxIiwic3RhYmxlX2RlZHVwX2xpc3QkMSIsImZpbHRlcl9tYXAkMSIsInRvX2NvbXBhcmF0b3IiLCJlbXB0eSQxIiwic2luZ2xldG9uJDEiLCJ1bmlvbl9saXN0JDIiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDIiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2skMiIsIm9mX3NvcnRlZF9hcnJheSQyIiwib2ZfbGlzdCQyIiwib2Zfc2VxdWVuY2UkMiIsIm9mX2FycmF5JDIiLCJzdGFibGVfZGVkdXBfbGlzdCQyIiwiZmlsdGVyX21hcCQyIiwib2ZfdHJlZSQxIiwic2V4cF9vZl9tX3QiLCJFbHQiLCJtX3Rfb2Zfc2V4cCIsIm1fdF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX21fdCIsImVxdWFsX21fdCIsImhhc2hfZm9sZF9tX3QiLCJoYXNoX21fdCIsImNvbXBhcmF0b3IkMCIsImVtcHR5JDIiLCJzaW5nbGV0b24kMiIsInVuaW9uX2xpc3QkMyIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMyIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQzIiwib2Zfc29ydGVkX2FycmF5JDMiLCJvZl9saXN0JDMiLCJvZl9zZXF1ZW5jZSQzIiwib2ZfYXJyYXkkMyIsInN0YWJsZV9kZWR1cF9saXN0JDMiLCJtYXAkMyIsImZpbHRlcl9tYXAkMyIsIm9mX3RyZWUkMiIsInRvX3RyZWUkMSIsInJlcGxhY2UiLCJzZXRfdGVtcG9yYXJpbHkiLCJyZXN0b3JlX3RvIiwic2V0cyIsInNuYXBzaG90Iiwic2V0c190ZW1wb3JhcmlseSIsImFuZF92YWx1ZXMiLCJpbmNfbnVtX211dGF0aW9ucyIsImVsdHNfaW5kZXgiLCJjaGVja19pbmRleF9leG4iLCJlbnN1cmVfbm9fbXV0YXRpb24iLCJudW1fbXV0YXRpb25zIiwibnVtX211dGF0aW9uc18wMDMiLCJmcm9udF8wMDUiLCJtYXNrXzAwNyIsImxlbmd0aF8wMDkiLCJlbHRzXzAxMSIsImFyZ18wMTIiLCJibmRzXzAwMiQxIiwiYm5kc18wMDIkMiIsImJuZHNfMDAyJDMiLCJtdXQyIiwibXV0MSIsImZyb250IiwiY2FwYWNpdHkkMCIsImNhcGFjaXR5JDEiLCJibGl0X3RvX2FycmF5IiwiZnJvbnRfbGVuIiwicmVzdF9sZW4iLCJzZXRfY2FwYWNpdHlfaW50ZXJuYWwiLCJkZXNpcmVkX2NhcGFjaXR5IiwiZW5xdWV1ZSIsImVucXVldWVfZnJvbnQiLCJkZXF1ZXVlX25vbmVtcHR5IiwiYmFja19pbmRleCIsImRlcXVldWVfYmFja19ub25lbXB0eSIsImJhY2siLCJkZXF1ZXVlX2V4biIsImRlcXVldWUiLCJkZXF1ZXVlX2FuZF9pZ25vcmVfZXhuIiwiZGVxdWV1ZV9iYWNrX2V4biIsImRlcXVldWVfYmFjayIsImZyb250X25vbmVtcHR5IiwiYmFja19ub25lbXB0eSIsImxhc3Rfbm9uZW1wdHkiLCJwZWVrX2V4biIsInBlZWtfYmFjayIsInBlZWtfYmFja19leG4iLCJkcmFpbiIsIndoaWxlJDAiLCJibGl0X3RyYW5zZmVyIiwibGVuJDEiLCJkc3Rfc3RhcnQiLCJzcmNfaSIsImRzdF9pIiwiZW5xdWV1ZV9hbGwiLCJmaWx0ZXJpX2lucGxhY2UiLCJxIiwiYXNzZXJ0X25vX211dGF0aW9uX3NpbmNlX3N0YXJ0IiwidW5yZWFjaGFibGVfY29kZV9sb2NhbCIsInVucmVhY2hhYmxlX2NvZGUiLCJtdXN0X2JlX25vbmUiLCJtdXN0X2JlX2VtcHR5IiwibXVzdF9iZV9vayIsIm11c3RfYmVfZXJyb3IiLCJtdXN0X2JlX2ZpcnN0IiwibXVzdF9iZV9zZWNvbmQiLCJ6ZXJvJDAiLCJ6ZXJvJDEiLCJ0b19pbnRfdHJ1bmMiLCJvZl9pbnQ2NF90cnVuYyIsIm5hbWUkMCIsIm9mX2NvbnRpbnVlX29yX3N0b3AiLCJ0b19jb250aW51ZV9vcl9zdG9wIiwibGVmdF92YWx1ZSIsInJpZ2h0X3ZhbHVlIiwidmFsdWVzIiwibGVmdF9kZWZhdWx0IiwicmlnaHRfZGVmYXVsdCIsInJpZ2h0JDAiLCJjb21wYXJlX2tleSIsImNyZWF0ZV93aXRoX2hlaWdodHMiLCJ2bCIsInZsJDAiLCJ2ciIsImswIiwiazEiLCJsZCIsImxyZCIsImxyZCQwIiwicmQiLCJybGQiLCJybGQkMCIsInJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQiLCJzZXhwX29mX2tleSIsImZpbmRfYW5kX2FkZF9vcl9zZXQiLCJhZGRfb3Jfc2V0IiwiZCQwIiwibGVuZ3RoJDIiLCJzZXRfbWluIiwic2V0X21heCIsImFkZF9leG4iLCJhZGRfZXhuX2ludGVybmFsIiwibWF4X2tleSIsImFkZF91bmNoZWNrZWQiLCJ0b190cmVlX3VuY2hlY2tlZCIsInRhaWwkMCIsInRhaWwkMSIsImQxIiwiZDIiLCJrMiIsInRhaWwkMiIsImQxJDAiLCJrMSQwIiwiZDIkMCIsImsyJDAiLCJkMyIsImszIiwibnIiLCJubCIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UiLCJidWlsZGVyIiwicHJldl9rZXkiLCJsZCQwIiwibGskMCIsInJrIiwicmQkMCIsInJrJDAiLCJsayIsImNtcCQwIiwibWF5YmUkMCIsInNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSIsImludG8iLCJib3VuZGFyeV9vcHQiLCJzcGxpdF9yYW5nZSIsIm1pZF9hbmRfcmlnaHQiLCJsYiQxIiwibGIkMiIsIm1pZF9hbmRfcmlnaHQkMCIsImxiIiwibGIkMCIsIm1pZCQwIiwiYWRkX211bHRpIiwiZGF0YSQwIiwiZmluZF9tdWx0aSIsImxvd2VyX3BhcnQiLCJ1cHBlcl9wYXJ0IiwibWluX3VwcGVyIiwibWF4X2xvd2VyIiwidXBwZXJfcGFydF93aXRob3V0X21pbiIsImdvIiwiY19taW4iLCJjX21heCIsImluaXQkMiIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlIiwicmFuZ2VfdG9fYWxpc3QiLCJjb25jYXRfdW5jaGVja2VkIiwiY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCIsImNoYW5nZSIsImQkMSIsImxlbmd0aCQzIiwidXBkYXRlIiwicmVtb3ZlX211bHRpIiwibm9uX2VtcHR5X3RhaWwiLCJpdGVyX2tleXMiLCJpdGVyaV91bnRpbF9sb29wIiwiaXRlcmlfdW50aWwiLCJmb2xkX3VudGlsX2xvb3AiLCJmaW5hbCQxIiwiZmluYWwkMCIsIm5ld19kYXRhIiwibmV3X2RhdGEkMCIsIm5ld19kYXRhJDEiLCJrZWVwX2RhdGEiLCJmaWx0ZXJfa2V5cyIsImtlZXBfZGF0YV90Iiwic3RlcF9kZWVwZXJfZXhuIiwiZHJvcF9waHlzX2VxdWFsX3ByZWZpeCIsImFjYzEiLCJhY2MyIiwidHJlZTEkMCIsImFjYzEkMCIsInRyZWUyJDAiLCJhY2MyJDAiLCJhY2MxJDEiLCJ0cmVlMSQxIiwiYWNjMiQxIiwidHJlZTIkMSIsImFjYzIkMiIsInRyZWUyJDIiLCJhY2MxJDIiLCJ0cmVlMSQyIiwiY3VyciIsIm5leHQkMSIsImRhdGFfZXF1YWwiLCJrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8iLCJrZXlzX2xlc3Nfb3JfZXF1YWxfdG8iLCJkJDIiLCJjb21wYXJlX2RhdGEiLCJmb2xkMiQwIiwiZm9sZF9zeW1tZXRyaWNfZGlmZiIsImRlbHRhIiwiYWNjJDMiLCJhY2MkNCIsImFjYyQ1IiwiYWNjJDYiLCJhY2MkNyIsInJpZ2h0JDEiLCJlbnVtMiQwIiwiZW51bTEkMCIsImtleXMiLCJvZl9mb2xkYWJsZSIsImZvbGRhYmxlIiwicHJldl9kYXRhIiwib2ZfZm9sZGFibGVfZm9sZCIsIm9mX2ZvbGRhYmxlX3JlZHVjZSIsIm9mX2ZvbGRhYmxlJDAiLCJvZl9mb2xkYWJsZV9vcl9lcnJvciIsIm9mX2ZvbGRhYmxlX2V4biIsIm9mX2ZvbGRhYmxlX211bHRpIiwib2ZfYWxpc3RfZm9sZCIsIm9mX2FsaXN0X3JlZHVjZSIsIm9mX2FsaXN0Iiwib2ZfYWxpc3Rfb3JfZXJyb3IiLCJvZl9hbGlzdF9leG4iLCJvZl9hbGlzdF9tdWx0aSIsImZvbGQkMiIsIm9mX3NlcXVlbmNlX2ZvbGQiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UiLCJvZl9zZXF1ZW5jZV9vcl9lcnJvciIsIm9mX3NlcXVlbmNlX2V4biIsIm9mX3NlcXVlbmNlX211bHRpIiwib2ZfbGlzdF93aXRoX2tleSIsImdldF9rZXkiLCJuZXdfbGVuZ3RoIiwib2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciIsIm9mX2xpc3Rfd2l0aF9rZXlfZXhuIiwib2ZfbGlzdF93aXRoX2tleV9tdWx0aSIsIm9mX2xpc3Rfd2l0aF9rZXlfZm9sZCIsIm9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlIiwic3VtaSIsInRvX2FsaXN0Iiwia2V5X29yZGVyIiwibWVyZ2VfbGFyZ2VfZmlyc3QiLCJsZW5ndGhfbGFyZ2UiLCJ0X2xhcmdlIiwidF9zbWFsbCIsIm1lcmdlX3NrZXdlZCIsImxlbmd0aDEiLCJsZW5ndGgyIiwibWVyZ2VfZGlzam9pbnRfZXhuIiwicmVwYWNrYWdlIiwibWFya2VyIiwiY2xvc2VzdF9rZXkiLCJmb3VuZF9tYXJrZXIiLCJmb3VuZF9rZXkiLCJmb3VuZF92YWx1ZSIsImZvdW5kX3ZhbHVlJDAiLCJmb3VuZF9rZXkkMCIsInJhbmsiLCJudW1fdG9fc2VhcmNoIiwicGFpciIsInBhaXIkMCIsImJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kIiwibWF5YmVfYm91bmQiLCJpZl9leGNsdXNpdmUiLCJpZl9pbmNsdXNpdmUiLCJmaW5kX2JvdW5kIiwiYm91bmQkMCIsImJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyIsImxvd2VyX2JvdW5kJDAiLCJ1cHBlcl9ib3VuZCQwIiwib2ZfaXRlcmkiLCJvZl9pdGVyaV9leG4iLCJrZXlfb2Zfc2V4cCIsInZhbHVlX29mX3NleHAiLCJhbGlzdF9zZXhwcyIsImZvdW5kX2ZpcnN0X2siLCJrMl9zZXhwIiwic2V4cF9vZl92YWx1ZSIsImVycm9ycyIsIm9rcyIsIm1hcF9rZXlzIiwibWFwX2tleXNfZXhuIiwidHJhbnNwb3NlX2tleXMiLCJvdXRlcl9jb21wYXJhdG9yIiwiaW5uZXJfY29tcGFyYXRvciIsIm91dGVyX3QiLCJvdXRlcl9rZXkiLCJpbm5lcl90IiwiaW5uZXJfa2V5IiwiYWNjX2xlbiIsImVsdF9sZW4iLCJ0cmVlX2ZpbHRlcl9tYXBpIiwicl9sZW4iLCJsX2xlbiIsIndpdGhfc2FtZV9sZW5ndGgiLCJvZl9saWtlX3RyZWUiLCJvZl9saWtlX3RyZWVfbWF5YmVfbm9fb3AiLCJhZGRfZXhuJDAiLCJhZGRfbXVsdGkkMCIsInJlbW92ZV9tdWx0aSQwIiwiZmluZF9tdWx0aSQwIiwiY2hhbmdlJDAiLCJ1cGRhdGUkMCIsIml0ZXJfa2V5cyQwIiwiaXRlcmlfdW50aWwkMCIsImZvbGQkMyIsImZvbGQyJDEiLCJmaWx0ZXJfa2V5cyQwIiwiZmlsdGVyaSQwIiwiZmlsdGVyX21hcGkkMCIsIm9mX2xpa2VfdHJlZTIiLCJvZl9saWtlX3RyZWUyX21heWJlX25vX29wIiwicGFydGl0aW9uX21hcGkkMCIsInBhcnRpdGlvbl9tYXAkMCIsInBhcnRpdGlvbmlfdGYkMCIsImNvbWJpbmVfZXJyb3JzJDAiLCJ1bnppcCQwIiwia2V5cyQwIiwidG9fYWxpc3QkMCIsImZvbGRfc3ltbWV0cmljX2RpZmYkMCIsIm1lcmdlJDAiLCJtZXJnZV9kaXNqb2ludF9leG4kMCIsIm1lcmdlX3NrZXdlZCQwIiwic3VtaSQwIiwiYm90aF9sZW4iLCJzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkkMCIsInN1YnJhbmdlIiwiaF9sIiwiaF9yIiwib3V0ZXJfam9pbmVkX2hlaWdodCIsIm1pZF9sZW5ndGgiLCJhcHBlbmQkMCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlJDAiLCJyYW5nZV90b19hbGlzdCQwIiwiY2xvc2VzdF9rZXkkMCIsInJhbmskMCIsInNleHBfb2ZfayIsInNleHBfb2ZfdiIsImhhc2hfZm9sZF9rZXkiLCJoYXNoX2ZvbGRfZGF0YSIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UiLCJuZXdfdHJlZSIsIm5ld190cmVlX3dpdGhfbGVuZ3RoIiwib2ZfYWxpc3QkMCIsIm9mX2FsaXN0X29yX2Vycm9yJDAiLCJvZl9hbGlzdF9leG4kMCIsIm9mX2FsaXN0X211bHRpJDAiLCJvZl9hbGlzdF9mb2xkJDAiLCJvZl9hbGlzdF9yZWR1Y2UkMCIsIm9mX2l0ZXJpJDAiLCJvZl9pdGVyaV9leG4kMCIsInJlcXVpcmVkX2J5X2ludGYiLCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlJDAiLCJvZl9zZXF1ZW5jZV9vcl9lcnJvciQwIiwib2Zfc2VxdWVuY2VfZXhuJDAiLCJvZl9zZXF1ZW5jZV9tdWx0aSQwIiwib2Zfc2VxdWVuY2VfZm9sZCQwIiwib2Zfc2VxdWVuY2VfcmVkdWNlJDAiLCJvZl9saXN0X3dpdGhfa2V5JDAiLCJvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yJDAiLCJvZl9saXN0X3dpdGhfa2V5X2V4biQwIiwib2ZfbGlzdF93aXRoX2tleV9tdWx0aSQwIiwib2ZfbGlzdF93aXRoX2tleV9mb2xkJDAiLCJvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSQwIiwiYWRkX2V4biQxIiwiYWRkX211bHRpJDEiLCJyZW1vdmVfbXVsdGkkMSIsImZpbmRfbXVsdGkkMSIsImNoYW5nZSQxIiwidXBkYXRlJDEiLCJpdGVyX2tleXMkMSIsIml0ZXJpX3VudGlsJDEiLCJtYXBpJDEiLCJmb2xkJDQiLCJmb2xkMiQyIiwiZmlsdGVyX2tleXMkMSIsImZpbHRlcmkkMSIsImZpbHRlcl9tYXBpJDEiLCJwYXJ0aXRpb25fbWFwaSQxIiwicGFydGl0aW9uX21hcCQxIiwicGFydGl0aW9uaV90ZiQxIiwiY29tYmluZV9lcnJvcnMkMSIsImtleXMkMSIsImRhdGEkMSIsInRvX2FsaXN0JDEiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDEiLCJtZXJnZSQxIiwibWVyZ2VfZGlzam9pbnRfZXhuJDEiLCJtZXJnZV9za2V3ZWQkMSIsImZvcl9hbGxpJDEiLCJleGlzdHNpJDEiLCJjb3VudGkkMSIsInN1bWkkMSIsImFwcGVuZCQxIiwic3VicmFuZ2UkMCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlJDEiLCJyYW5nZV90b19hbGlzdCQxIiwiY2xvc2VzdF9rZXkkMSIsIm50aCQyIiwibnRoX2V4biQwIiwicmFuayQxIiwia19vZl9zZXhwIiwidl9vZl9zZXhwIiwiYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSQwIiwibWFwX2tleXMkMCIsImR1cCIsIm1hcF9rZXlzX2V4biQwIiwidHJhbnNwb3NlX2tleXMkMCIsImFkZF9leG4kMiIsIm9mX3RyZWUwIiwib2ZfYWxpc3QkMSIsIm9mX2FsaXN0X29yX2Vycm9yJDEiLCJvZl9hbGlzdF9leG4kMSIsIm9mX2FsaXN0X211bHRpJDEiLCJvZl9hbGlzdF9mb2xkJDEiLCJvZl9hbGlzdF9yZWR1Y2UkMSIsIm9mX2l0ZXJpJDEiLCJ0cmVlX2xlbmd0aCIsIm9mX2l0ZXJpX2V4biQxIiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQxIiwib2Zfc2VxdWVuY2Vfb3JfZXJyb3IkMSIsIm9mX3NlcXVlbmNlX2V4biQxIiwib2Zfc2VxdWVuY2VfbXVsdGkkMSIsIm9mX3NlcXVlbmNlX2ZvbGQkMSIsIm9mX3NlcXVlbmNlX3JlZHVjZSQxIiwib2ZfbGlzdF93aXRoX2tleSQxIiwib2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciQxIiwib2ZfbGlzdF93aXRoX2tleV9leG4kMSIsIm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkkMSIsIm9mX2xpc3Rfd2l0aF9rZXlfZm9sZCQxIiwib2ZfbGlzdF93aXRoX2tleV9yZWR1Y2UkMSIsIm1hcF9rZXlzJDEiLCJtYXBfa2V5c19leG4kMSIsInRyYW5zcG9zZV9rZXlzJDEiLCJvZl90cmVlJDMiLCJvZl9hbGlzdCQyIiwib2ZfYWxpc3Rfb3JfZXJyb3IkMiIsIm9mX2FsaXN0X2V4biQyIiwib2ZfYWxpc3RfbXVsdGkkMiIsIm9mX2FsaXN0X2ZvbGQkMiIsIm9mX2FsaXN0X3JlZHVjZSQyIiwib2ZfaXRlcmkkMiIsIm9mX2l0ZXJpX2V4biQyIiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQyIiwib2Zfc2VxdWVuY2Vfb3JfZXJyb3IkMiIsIm9mX3NlcXVlbmNlX2V4biQyIiwib2Zfc2VxdWVuY2VfbXVsdGkkMiIsIm9mX3NlcXVlbmNlX2ZvbGQkMiIsIm9mX3NlcXVlbmNlX3JlZHVjZSQyIiwib2ZfbGlzdF93aXRoX2tleSQyIiwib2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciQyIiwib2ZfbGlzdF93aXRoX2tleV9leG4kMiIsIm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkkMiIsIm9mX2xpc3Rfd2l0aF9rZXlfZm9sZCQyIiwib2ZfbGlzdF93aXRoX2tleV9yZWR1Y2UkMiIsIm1hcF9rZXlzJDIiLCJtYXBfa2V5c19leG4kMiIsInRyYW5zcG9zZV9rZXlzJDIiLCJLIiwidl9ncmFtbWFyIiwiY29tcGFyZV92IiwiZXF1YWxfdiIsImhhc2hfZm9sZF92Iiwib2ZfdHJlZSQ0IiwiZW1wdHkkMyIsIm9mX2FsaXN0JDMiLCJvZl9hbGlzdF9vcl9lcnJvciQzIiwib2ZfYWxpc3RfZXhuJDMiLCJvZl9hbGlzdF9tdWx0aSQzIiwib2ZfYWxpc3RfZm9sZCQzIiwib2ZfYWxpc3RfcmVkdWNlJDMiLCJvZl9pdGVyaSQzIiwib2ZfaXRlcmlfZXhuJDMiLCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlJDMiLCJvZl9zZXF1ZW5jZV9vcl9lcnJvciQzIiwib2Zfc2VxdWVuY2VfZXhuJDMiLCJvZl9zZXF1ZW5jZV9tdWx0aSQzIiwib2Zfc2VxdWVuY2VfZm9sZCQzIiwib2Zfc2VxdWVuY2VfcmVkdWNlJDMiLCJvZl9saXN0X3dpdGhfa2V5JDMiLCJvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yJDMiLCJvZl9saXN0X3dpdGhfa2V5X2V4biQzIiwib2ZfbGlzdF93aXRoX2tleV9tdWx0aSQzIiwib2ZfbGlzdF93aXRoX2tleV9mb2xkJDMiLCJvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSQzIiwibWFwX2tleXMkMyIsIm1hcF9rZXlzX2V4biQzIiwidHJhbnNwb3NlX2tleXMkMyIsInRyYW5zZmVyIiwiY2FtbF9pdGVyIiwiY2FtbF9mb2xkIiwicSQwIiwiYnN3YXAxNiIsImJzd2FwMzIiLCJic3dhcDQ4IiwidG9fbmF0aXZlaW50X2V4biIsIndyYXBfZXhuIiwid3JhcF9tb2R1bG8iLCJ1bndyYXAiLCJjdHoiLCJpbnZhbGlkX3N0ciIsIm9mX3N0cmluZ19yYXciLCJzaWduZWRuZXNzIiwicG9zX3N0ciIsImludDYzIiwib25lJDAiLCJ0b19pbnQzMl90cnVuYyIsIm9mX25hdGl2ZWludF90cnVuYyIsInRvX25hdGl2ZWludF90cnVuYyIsInRvX3N0cmluZyQxIiwiZmxvYXRfb2ZfYml0cyIsImJpdHNfb2ZfZmxvYXQiLCJvZl9pbnRfdHJ1bmMiLCJpbmNsdWRlJDAiLCJvZl9mbG9hdCQwIiwidG9fZmxvYXQkMCIsIm9mX2ludF9leG4kMCIsInRvX2ludF9leG4kMCIsInBwJDAiLCJoYXNoYWJsZSQwIiwiaXNfcG9zaXRpdmUkMCIsImlzX25vbl9uZWdhdGl2ZSQwIiwiaXNfbmVnYXRpdmUkMCIsImlzX25vbl9wb3NpdGl2ZSQwIiwic2lnbiQwIiwiaW52YXJpYW50JDAiLCJvZl9zdHJpbmdfb3B0JDAiLCJ0b19zdHJpbmdfaHVtJDAiLCJtaW51c19vbmUkMCIsInJlbSQwIiwicm91bmQkMCIsInJvdW5kX3Rvd2FyZHNfemVybyQwIiwicm91bmRfZG93biQwIiwicm91bmRfdXAkMCIsInJvdW5kX25lYXJlc3QkMCIsInN1Y2MkMCIsInByZWQkMCIsInBvdyQwIiwiYml0X2FuZCQwIiwiYml0X29yJDAiLCJiaXRfeG9yJDAiLCJiaXRfbm90JDAiLCJwb3Bjb3VudCQwIiwic2hpZnRfbGVmdCQwIiwic2hpZnRfcmlnaHQkMCIsImRlY3IkMCIsImluY3IkMCIsIm9mX2ludDMyX2V4biQwIiwidG9faW50MzJfZXhuJDAiLCJvZl9pbnQ2NF9leG4kMCIsInRvX2ludDY0JDAiLCJvZl9uYXRpdmVpbnRfZXhuJDAiLCJ0b19uYXRpdmVpbnRfZXhuJDAiLCJudW1fYml0cyQwIiwibWF4X3ZhbHVlJDAiLCJtaW5fdmFsdWUkMCIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwkMCIsImNlaWxfcG93MiQwIiwiZmxvb3JfcG93MiQwIiwiY2VpbF9sb2cyJDAiLCJpc19wb3cyJDAiLCJjbHokMCIsImN0eiQwIiwib2ZfaW50JDAiLCJ0b19pbnQkMCIsInRvX2ludF90cnVuYyQwIiwidG9faW50MzIkMCIsIm9mX2ludDY0JDAiLCJvZl9uYXRpdmVpbnQkMCIsInRvX25hdGl2ZWludCQwIiwidG9fbmF0aXZlaW50X3RydW5jJDAiLCJvZl9mbG9hdF91bmNoZWNrZWQkMCIsInJlcHIkMCIsImJzd2FwMzIkMCIsImJzd2FwNDgkMCIsInBvc19kaWZmIiwibmVnYXRpdmVfb25lIiwiZGl2X3dvdWxkX292ZXJmbG93IiwicHJvZHVjdCIsImFicyQxIiwibmVnJDAiLCJyYW5kb21fb2ZfaW50IiwicmFuZG9tX29mX2ludDY0IiwicmFuZG9tX29mX2ludCQwIiwicmFuZG9tX2luY2xfb2ZfaW50IiwicmFuZG9tX2luY2xfb2ZfaW50NjQiLCJyYW5kb21faW5jbCIsImludiIsImxlZnRfa2V5IiwicmlnaHRfa2V5IiwidXBkYXRlX2hlaWdodCIsIm9sZF9oZWlnaHQiLCJuZXdfaGVpZ2h0IiwiYmFsYW5jZSIsInJvb3Rfbm9kZSIsImxlZnRfbm9kZSIsInJpZ2h0X25vZGUiLCJsZWZ0X25vZGVfbGVmdCIsImxlZnRfbm9kZV9yaWdodCIsImxyX2xlZnQiLCJscl9yaWdodCIsInJpZ2h0X25vZGVfbGVmdCIsInJpZ2h0X25vZGVfcmlnaHQiLCJybF9sZWZ0IiwicmxfcmlnaHQiLCJhZGRlZCIsImZpbmRpX2FuZF9jYWxsX2ltcGwiLCJhcmcxIiwiYXJnMiIsImNhbGxfaWZfZm91bmQiLCJjYWxsX2lmX25vdF9mb3VuZCIsImZpbmRfYW5kX2NhbGwiLCJjYWxsX2lmX2ZvdW5kJDAiLCJjYWxsX2lmX25vdF9mb3VuZCQwIiwiZmluZGlfYW5kX2NhbGwiLCJjYWxsX2lmX2ZvdW5kJDEiLCJjYWxsX2lmX25vdF9mb3VuZCQxIiwiZmluZF9hbmRfY2FsbDEiLCJjYWxsX2lmX2ZvdW5kJDIiLCJjYWxsX2lmX25vdF9mb3VuZCQyIiwiZmluZGlfYW5kX2NhbGwxIiwiY2FsbF9pZl9mb3VuZCQzIiwiY2FsbF9pZl9ub3RfZm91bmQkMyIsImZpbmRfYW5kX2NhbGwyIiwiY2FsbF9pZl9mb3VuZCQ0IiwiY2FsbF9pZl9ub3RfZm91bmQkNCIsImZpbmRpX2FuZF9jYWxsMiIsImlmX2ZvdW5kJDAiLCJpZl9ub3RfZm91bmQkMCIsInJlbW92ZWQiLCJ0cmVlJDAiLCJ0cmVlJDEiLCJrZXkkNCIsImRhdGEkNCIsInJrZXkiLCJyZGF0YSIsImtleSQxIiwicmtleSQwIiwicmRhdGEkMCIsImxrZXkkMCIsImxkYXRhJDAiLCJrZXkkMyIsImRhdGEkMyIsInJrZXkkMSIsInJkYXRhJDEiLCJsa2V5IiwibGRhdGEiLCJrZXkkMiIsImRhdGEkMiIsIm1hcGlfaW5wbGFjZSIsImVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIiwid2l0aG91dF9tdXRhdGluZyIsIm1heF90YWJsZV9sZW5ndGgiLCJncm93dGhfYWxsb3dlZCIsInNpemUkMCIsInNpemUkMSIsInNsb3QiLCJhZGRfd29ya2VyIiwibmV3X3Jvb3QiLCJtYXliZV9yZXNpemVfdGFibGUiLCJzaG91bGRfZ3JvdyIsIm5ld19hcnJheV9sZW5ndGgiLCJuZXdfdGFibGUiLCJvbGRfdGFibGUiLCJzZXhwX29mX2tleSQwIiwiYnVja2V0IiwiY2hvb3NlX25vbmVtcHR5IiwiYXZsdHJlZSIsImNob29zZV9yYW5kb21seV9ub25lbXB0eSIsInN0YXJ0X2lkeCIsImNob29zZV9yYW5kb21seSIsImNob29zZV9yYW5kb21seV9leG4iLCJpbnZhcmlhbnRfa2V5IiwiaW52YXJpYW50X2RhdGEiLCJyZWFsX2xlbiIsIm5ld190IiwidDAiLCJmaW5kX29yX2FkZCIsImlkIiwiZGVmYXVsdCQxIiwiZmluZGlfb3JfYWRkIiwiZmluZF9hbmRfcmVtb3ZlIiwidXBkYXRlX2FuZF9yZXR1cm4iLCJpbmNyX2J5IiwicmVtb3ZlX2lmX3plcm8iLCJieSIsImNyZWF0ZV9tYXBwZWQiLCJnZXRfZGF0YSIsImR1cGVzIiwib2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIiwic2V4cF9vZl9kYXRhIiwiZF9vZl9zZXhwIiwia19ncmFtbWFyIiwiZ3JvdXBzIiwicm93Iiwib2xkIiwiY3JlYXRlX3dpdGhfa2V5IiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIiwiY3JlYXRlX3dpdGhfa2V5X2V4biIsIm1heWJlX3NldCIsInRfbGVmdCIsInRfcmlnaHQiLCJtZXJnZV9pbnRvIiwiZHN0X2RhdGEiLCJhY3Rpb24iLCJkc3RfZGF0YSQwIiwidG9fcmVtb3ZlIiwiZmlsdGVyX2tleXNfaW5wbGFjZSIsImZpbHRlcl9tYXBpX2lucGxhY2UiLCJtYXBfcmVzdWx0cyIsImZpbHRlcl9tYXBfaW5wbGFjZSIsInNpbWlsYXIiLCJvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMkMCIsImNyZWF0ZV9tYXBwZWQkMCIsImNyZWF0ZV93aXRoX2tleSQwIiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yJDAiLCJjcmVhdGVfd2l0aF9rZXlfZXhuJDAiLCJvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMkMSIsImNyZWF0ZV9tYXBwZWQkMSIsImNyZWF0ZV93aXRoX2tleSQxIiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yJDEiLCJjcmVhdGVfd2l0aF9rZXlfZXhuJDEiLCJncm91cCQxIiwiaGFzaGFibGVfcyIsInBvbHlfaGFzaGFibGUiLCJzdHJpY3RfYWRkIiwic3RyaWN0X2FkZF9leG4iLCJzdHJpY3RfcmVtb3ZlIiwic3RyaWN0X3JlbW92ZV9leG4iLCJzZXhwX29mX2UiLCJsYXJnZXIiLCJzbWFsbGVyIiwib2ZfaGFzaHRibF9rZXlzIiwiaGFzaHRibCIsInRvX2hhc2h0YmwiLCJlX29mX3NleHAiLCJlcnJvcl9zb3VyY2VfMDA3IiwibWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSIsIm1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUiLCJwaSIsInNxcnRfcGkiLCJzcXJ0XzJwaSIsImV1bGVyIiwib2ZfaW50NjMiLCJpcm91bmRfbGJvdW5kIiwiaXJvdW5kX3Vib3VuZCIsImlyb3VuZF91cCIsImlyb3VuZF91cF9leG4iLCJpcm91bmRfZG93biIsImlyb3VuZF9kb3duX2V4biIsImlyb3VuZF90b3dhcmRzX3plcm8iLCJpcm91bmRfdG93YXJkc196ZXJvX2V4biIsInJvdW5kX25lYXJlc3RfbGIiLCJyb3VuZF9uZWFyZXN0X3ViIiwib25lX3VscF9sZXNzX3RoYW5faGFsZiIsImFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IiwiaXJvdW5kX25lYXJlc3RfMzIiLCJpcm91bmRfbmVhcmVzdF82NCIsImlyb3VuZF9uZWFyZXN0XzY0JDAiLCJpcm91bmRfbmVhcmVzdF9leG5fMzIiLCJpcm91bmRfbmVhcmVzdF9leG5fNjQiLCJpcm91bmRfbmVhcmVzdF9leG4iLCJpcm91bmRfZXhuIiwiaXJvdW5kIiwiaXNfaW5mIiwiaXNfZmluaXRlIiwibWluX2luYW4iLCJtYXhfaW5hbiIsInNjYWxlIiwic3F1YXJlIiwiZnJhY3Rpb25hbCIsImludGVncmFsIiwicm91bmRfbmVhcmVzdF9pbmxpbmUiLCJyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiIsImNlaWxfb3Jfc3VjYyIsImRpZmZfZmxvb3IiLCJkaWZmX2NlaWwiLCJpbnQ2M19yb3VuZF9sYm91bmQiLCJpbnQ2M19yb3VuZF91Ym91bmQiLCJpbnQ2M19yb3VuZF91cF9leG4iLCJpbnQ2M19yb3VuZF9kb3duX2V4biIsImludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYSIsImludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYSIsImludDYzX3JvdW5kX25lYXJlc3RfZXhuIiwiY2xhc3NpZnkiLCJzdHJpcF96ZXJvIiwiZGVjaW1hbHMiLCJleHBsaWNpdF9wbHVzIiwidG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nX2N1c3RvIiwia2lsbyIsIm1lZ2EiLCJnaWdhIiwidGVyYSIsInBldGEiLCJtYWciLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImhpZ2hlciIsImRpZmZfcmlnaHQiLCJkaWZmX2xlZnQiLCJwZXRhJDAiLCJ0b19wYWRkZWRfY29tcGFjdF9zdHJpbmciLCJyb3VuZF9nZW4iLCJzZCIsImRkIiwiZGQkMCIsInNkJDAiLCJkZCQxIiwic2QkMSIsImFic19kZCIsInJvdW5kX3NpZ25pZmljYW50Iiwic2lnbmlmaWNhbnRfZGlnaXRzIiwicm91bmRfZGVjaW1hbCIsImRlY2ltYWxfZGlnaXRzIiwic2lnbl9leG4iLCJzaWduX29yX25hbiIsImllZWVfbmVnYXRpdmUiLCJleHBvbmVudF9tYXNrNjQiLCJleHBvbmVudF9tYXNrIiwibWFudGlzc2FfbWFzayIsIm1hbnRpc3NhX21hc2s2NCIsIm1hbnRpc3NhX2JpdHMiLCJpZWVlX2V4cG9uZW50IiwiaWVlZV9tYW50aXNzYSIsImNyZWF0ZV9pZWVlX2V4biIsIm5lZ2F0aXZlIiwibWFudGlzc2EiLCJzaWduX2JpdHMiLCJleHB0X2JpdHMiLCJtYW50X2JpdHMiLCJjcmVhdGVfaWVlZSIsInNwZWNpYWxpemVkX2hhc2giLCJhZGRfc3Vic3RyaW5nIiwiYWRkX3N1YmJ5dGVzIiwiY2FtbF9idWZmZXJfbGVuZ3RoIiwiY2FtbF9idWZmZXJfYmxpdCIsImVsaWRlZF9tZXNzYWdlIiwiZWxpZGUiLCJhdF9tb3N0X251bV9mcmFtZXMiLCJ0b19zdHJpbmdfbGlzdCIsInNldF9yZWNvcmRpbmciLCJhbV9yZWNvcmRpbmciLCJtb3N0X3JlY2VudCIsIm1vc3RfcmVjZW50X2Zvcl9leG4iLCJ3aXRoX3JlY29yZGluZyIsInNhdmVkIiwib2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhIiwiYXJyYXlfb2Zfc2V4cCIsInNleHBfb2ZfYXJyYXkiLCJhcnJheV9zZXhwX2dyYW1tYXIiLCJib29sX29mX3NleHAiLCJzZXhwX29mX2Jvb2wiLCJib29sX3NleHBfZ3JhbW1hciIsImNoYXJfb2Zfc2V4cCIsInNleHBfb2ZfY2hhciIsImNoYXJfc2V4cF9ncmFtbWFyIiwic2V4cF9vZl9leG4iLCJnbG9iYWxpemVfZmxvYXQiLCJmbG9hdF9vZl9zZXhwIiwic2V4cF9vZl9mbG9hdCIsImZsb2F0X3NleHBfZ3JhbW1hciIsImdsb2JhbGl6ZV9pbnQiLCJmdW5jJDIiLCJpbnRfb2Zfc2V4cCIsInNleHBfb2ZfaW50IiwiaW50X3NleHBfZ3JhbW1hciIsImdsb2JhbGl6ZV9pbnQzMiIsImZ1bmMkMyIsImludDMyX29mX3NleHAiLCJzZXhwX29mX2ludDMyIiwiaW50MzJfc2V4cF9ncmFtbWFyIiwiZ2xvYmFsaXplX2ludDY0IiwiZnVuYyQ0IiwiaW50NjRfb2Zfc2V4cCIsInNleHBfb2ZfaW50NjQiLCJpbnQ2NF9zZXhwX2dyYW1tYXIiLCJsaXN0X29mX3NleHAiLCJzZXhwX29mX2xpc3QiLCJsaXN0X3NleHBfZ3JhbW1hciIsImdsb2JhbGl6ZV9uYXRpdmVpbnQiLCJmdW5jJDUiLCJuYXRpdmVpbnRfb2Zfc2V4cCIsInNleHBfb2ZfbmF0aXZlaW50IiwibmF0aXZlaW50X3NleHBfZ3JhbW1hciIsIm9wdGlvbl9vZl9zZXhwIiwic2V4cF9vZl9vcHRpb24iLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwicmVmX29mX3NleHAiLCJzZXhwX29mX3JlZiIsInJlZl9zZXhwX2dyYW1tYXIiLCJnbG9iYWxpemVfc3RyaW5nIiwic3RyaW5nX29mX3NleHAiLCJzZXhwX29mX3N0cmluZyIsInN0cmluZ19zZXhwX2dyYW1tYXIiLCJnbG9iYWxpemVfYnl0ZXMiLCJieXRlc19vZl9zZXhwIiwic2V4cF9vZl9ieXRlcyIsImJ5dGVzX3NleHBfZ3JhbW1hciIsImZ1bmMkNiIsInVuaXRfb2Zfc2V4cCIsInNleHBfb2ZfdW5pdCIsInVuaXRfc2V4cF9ncmFtbWFyIiwiZmFpbHdpdGgiLCJpbnZhbGlkX2FyZyIsImNvbXBhcmVfYXJyYXlfbG9jYWwkMCIsImNvbXBhcmVfYXJyYXkkMCIsImVxdWFsX2FycmF5X2xvY2FsJDAiLCJlcXVhbF9hcnJheSQwIiwiZ2xvYmFsaXplX2FycmF5JDAiLCJhcnJheV9vZl9zZXhwJDAiLCJzZXhwX29mX2FycmF5JDAiLCJhcnJheV9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfYm9vbF9sb2NhbCQwIiwiY29tcGFyZV9ib29sJDAiLCJlcXVhbF9ib29sX2xvY2FsJDAiLCJlcXVhbF9ib29sJDAiLCJnbG9iYWxpemVfYm9vbCQwIiwiaGFzaF9mb2xkX2Jvb2wkMCIsImhhc2hfYm9vbCQwIiwiYm9vbF9vZl9zZXhwJDAiLCJzZXhwX29mX2Jvb2wkMCIsImJvb2xfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2NoYXJfbG9jYWwkMCIsImNvbXBhcmVfY2hhciQwIiwiZXF1YWxfY2hhcl9sb2NhbCQwIiwiZXF1YWxfY2hhciQwIiwiZ2xvYmFsaXplX2NoYXIkMCIsImhhc2hfZm9sZF9jaGFyJDAiLCJoYXNoX2NoYXIkMCIsImNoYXJfb2Zfc2V4cCQwIiwic2V4cF9vZl9jaGFyJDAiLCJjaGFyX3NleHBfZ3JhbW1hciQwIiwic2V4cF9vZl9leG4kMCIsImNvbXBhcmVfZmxvYXRfbG9jYWwkMCIsImNvbXBhcmVfZmxvYXQkMCIsImVxdWFsX2Zsb2F0X2xvY2FsJDAiLCJlcXVhbF9mbG9hdCQwIiwiZ2xvYmFsaXplX2Zsb2F0JDAiLCJoYXNoX2ZvbGRfZmxvYXQkMCIsImhhc2hfZmxvYXQkMCIsImZsb2F0X29mX3NleHAkMCIsInNleHBfb2ZfZmxvYXQkMCIsImZsb2F0X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9pbnRfbG9jYWwkMCIsImNvbXBhcmVfaW50JDAiLCJlcXVhbF9pbnRfbG9jYWwkMCIsImVxdWFsX2ludCQwIiwiZ2xvYmFsaXplX2ludCQwIiwiaGFzaF9mb2xkX2ludCQwIiwiaGFzaF9pbnQkMCIsImludF9vZl9zZXhwJDAiLCJzZXhwX29mX2ludCQwIiwiaW50X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9pbnQzMl9sb2NhbCQwIiwiY29tcGFyZV9pbnQzMiQwIiwiZXF1YWxfaW50MzJfbG9jYWwkMCIsImVxdWFsX2ludDMyJDAiLCJnbG9iYWxpemVfaW50MzIkMCIsImhhc2hfZm9sZF9pbnQzMiQwIiwiaGFzaF9pbnQzMiQwIiwiaW50MzJfb2Zfc2V4cCQwIiwic2V4cF9vZl9pbnQzMiQwIiwiaW50MzJfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2ludDY0X2xvY2FsJDAiLCJjb21wYXJlX2ludDY0JDAiLCJlcXVhbF9pbnQ2NF9sb2NhbCQwIiwiZXF1YWxfaW50NjQkMCIsImdsb2JhbGl6ZV9pbnQ2NCQwIiwiaGFzaF9mb2xkX2ludDY0JDAiLCJoYXNoX2ludDY0JDAiLCJpbnQ2NF9vZl9zZXhwJDAiLCJzZXhwX29mX2ludDY0JDAiLCJpbnQ2NF9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfbGlzdF9sb2NhbCQwIiwiY29tcGFyZV9saXN0JDAiLCJlcXVhbF9saXN0X2xvY2FsJDAiLCJlcXVhbF9saXN0JDAiLCJnbG9iYWxpemVfbGlzdCQwIiwiaGFzaF9mb2xkX2xpc3QkMCIsImxpc3Rfb2Zfc2V4cCQwIiwic2V4cF9vZl9saXN0JDAiLCJsaXN0X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9uYXRpdmVpbnRfbG9jYWwkMCIsImNvbXBhcmVfbmF0aXZlaW50JDAiLCJlcXVhbF9uYXRpdmVpbnRfbG9jYWwkMCIsImVxdWFsX25hdGl2ZWludCQwIiwiZ2xvYmFsaXplX25hdGl2ZWludCQwIiwiaGFzaF9mb2xkX25hdGl2ZWludCQwIiwiaGFzaF9uYXRpdmVpbnQkMCIsIm5hdGl2ZWludF9vZl9zZXhwJDAiLCJzZXhwX29mX25hdGl2ZWludCQwIiwibmF0aXZlaW50X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9vcHRpb25fbG9jYWwkMCIsImNvbXBhcmVfb3B0aW9uJDAiLCJlcXVhbF9vcHRpb25fbG9jYWwkMCIsImVxdWFsX29wdGlvbiQwIiwiZ2xvYmFsaXplX29wdGlvbiQwIiwiaGFzaF9mb2xkX29wdGlvbiQwIiwib3B0aW9uX29mX3NleHAkMCIsInNleHBfb2Zfb3B0aW9uJDAiLCJvcHRpb25fc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX3JlZl9sb2NhbCQwIiwiY29tcGFyZV9yZWYkMCIsImVxdWFsX3JlZl9sb2NhbCQwIiwiZXF1YWxfcmVmJDAiLCJnbG9iYWxpemVfcmVmJDAiLCJyZWZfb2Zfc2V4cCQwIiwic2V4cF9vZl9yZWYkMCIsInJlZl9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfc3RyaW5nX2xvY2FsJDAiLCJjb21wYXJlX3N0cmluZyQwIiwiZXF1YWxfc3RyaW5nX2xvY2FsJDAiLCJlcXVhbF9zdHJpbmckMCIsImdsb2JhbGl6ZV9zdHJpbmckMCIsImhhc2hfZm9sZF9zdHJpbmckMCIsImhhc2hfc3RyaW5nJDAiLCJzdHJpbmdfb2Zfc2V4cCQwIiwic2V4cF9vZl9zdHJpbmckMCIsInN0cmluZ19zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfYnl0ZXNfbG9jYWwkMCIsImNvbXBhcmVfYnl0ZXMkMCIsImVxdWFsX2J5dGVzX2xvY2FsJDAiLCJlcXVhbF9ieXRlcyQwIiwiZ2xvYmFsaXplX2J5dGVzJDAiLCJieXRlc19vZl9zZXhwJDAiLCJzZXhwX29mX2J5dGVzJDAiLCJieXRlc19zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfdW5pdF9sb2NhbCQwIiwiY29tcGFyZV91bml0JDAiLCJlcXVhbF91bml0X2xvY2FsJDAiLCJlcXVhbF91bml0JDAiLCJnbG9iYWxpemVfdW5pdCQwIiwiaGFzaF9mb2xkX3VuaXQkMCIsImhhc2hfdW5pdCQwIiwidW5pdF9vZl9zZXhwJDAiLCJzZXhwX29mX3VuaXQkMCIsInVuaXRfc2V4cF9ncmFtbWFyJDAiLCJyYWlzZV9zJDAiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2Jhc2VfXy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvZ2xvYmFsaXplLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9wb2x5MC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvaW1wb3J0MC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvaW50MC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvcHJpbnRmLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9zeXMwLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9hcnJheTAubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2NoYXIwLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9saXN0MC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvaGFzaC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvcHB4X2NvbXBhcmVfbGliLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9wcHhfaGFzaF9saWIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3NleHAubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3dvcmRfc2l6ZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvcHJldHR5X3ByaW50ZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2V4bi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2Uvd2l0aF9yZXR1cm4ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2ZuLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9tb25hZF9pbnRmLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9tb25hZC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvYXBwbGljYXRpdmUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2NvbXBhcmF0b3IubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2VpdGhlcjAubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2ZpZWxkLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9pbnRfY29udmVyc2lvbnMubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3N0cmluZzAubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3NvdXJjZV9jb2RlX3Bvc2l0aW9uMC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvbGlzdDEubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3Jlc3VsdC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvY29udGFpbmVyX2ludGYubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2NvbnRhaW5lci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvaW5kZXhlZF9jb250YWluZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2xhenkubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL29yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9yYW5kb21fcmVwci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvcmFuZG9tLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9hcnJheV9wZXJtdXRlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9vcmRlcmluZy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvbGlzdC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvaW5mby5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvZXJyb3IubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2ludmFyaWFudC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2Uvb3JfZXJyb3IubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3NpZ24wLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9jb21wYXJhYmxlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9oYXNoYWJsZV9pbnRmLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9pZGVudGlmaWFibGUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3VuaXQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL29yZGVyZWRfY29sbGVjdGlvbl9jb21tb24ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2JpbmFyeV9zZWFyY2gubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2JpbmFyeV9zZWFyY2hhYmxlX2ludGYubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2JpbmFyeV9zZWFyY2hhYmxlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9ieXRlczAubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2JsaXQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2Jvb2wubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2VpdGhlci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2Uvb3B0aW9uLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9wcHhfZW51bWVyYXRlX2xpYi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2Uvc2VxdWVuY2UubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3NleHBhYmxlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9hcnJheS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvZmxvYXQwLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9wb3dfb3ZlcmZsb3dfYm91bmRzLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9pbnRfbWF0aC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2Uvc3RhZ2VkLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9jaGFyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9ieXRlc190ci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2Uvc3RyaW5nLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9ieXRlcy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvaGV4X2xleGVyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9pbnRfc3RyaW5nX2NvbnZlcnNpb25zLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9wb3Bjb3VudC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2Uvc2lnbi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvaW50Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9vYmpfbG9jYWwubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL29ial9hcnJheS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvdW5pZm9ybV9hcnJheS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvdWNoYXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3R5cGVfZXF1YWxfaW50Zi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvdHlwZV9lcXVhbC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2Uvb3B0aW9uX2FycmF5Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9zdGFjay5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2Uvc291cmNlX2NvZGVfcG9zaXRpb24ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3NpZ25fb3JfbmFuLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9kaWN0aW9uYXJ5X2ltbXV0YWJsZV9pbnRmLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9tYXliZV9ib3VuZC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvbWFwX2ludGYubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3NldF9pbnRmLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9zZXQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL3JlZi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvcXVldWUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL25vdGhpbmcubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL25hdGl2ZWludC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvbWFwLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9saW5rZWRfcXVldWUwLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9saW5rZWRfcXVldWUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2ludDY0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9pbnQ2M19lbXVsLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9pbnQzMi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvaW50NjMubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2RpY3Rpb25hcnlfbXV0YWJsZV9pbnRmLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9oYXNodGJsX2ludGYubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2F2bHRyZWUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2hhc2h0YmwubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2hhc2hfc2V0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9mbG9hdC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2Jhc2UvYnVmZmVyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYmFzZS9iYWNrdHJhY2UubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlL2Jhc2UubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FrYmdCLHVDQUFBOzs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7Rzs7Ozs7WUM3YVpBLGVBQ0FDLEdBQXVCLE9BQXZCQSxFQUF3QjtZQUd4QkMsZUFDQUMsR0FBeUIsT0FBekJBLEVBQTBCO1lBVzFCQyxlQUFlQyxHQUFZLE9BQVpBLEVBQWE7WUFJNUJDLHVCQUFrQkMsR0FBSSxPQUFKQSxVQUFzQjtZQUVwQ0MsZUFBZUM7SSxZQUNiO0lBQ1ksSUFBYkMsZUFBTEMsY0FBa0IsTUFGZEgsZUFBZUMsR0FFZEM7SUFBTSxXQUFBLFdBRlFELEdBRW5CRTs7WUFHQUMsaUJBQWlCSDtJLFlBQ1Q7UUFDSEU7SUFBSyxXQUFLLFdBRkVGLEdBRVpFOztZQUdMRSxpQkFBaUJDLGFBQVlDLGFBQVlDO0lBQzNDLFNBRDJDQSxVQUV0Q1QsSUFGc0NTLE1BRWpDLFdBQUcsV0FGTUYsYUFFZFA7UUFDR04sSUFIbUNlO0lBRzlCLFdBQU0sV0FIWUQsYUFHdkJkO0dBQTBCO1lBSWhDZ0IscUJBQWdCQyxHQUFJLFdBQUpBLE1BQW9CO1lBSXBDQyx3QkFBbUJILEdBQUksT0FBSkEsRUFBMkI7Ozs7Ozs7OztPQTNDOUNoQjtPQUlBRTs7cUI7Ozs7OztPQVlBRTtPQUlBRTtPQXVCQWE7T0FyQklYO09BS0pJO09BS0FDO09BT0FJOzs7RTs7Ozs7Ozs7O1lDNUJBRyxXQUFXVCxHQUFFVSxHQUFJLE9BQUEsYUFBSkEsR0FBRlYsR0FBaUI7WUFDNUJXLElBQUlYLEdBQUVVO0lBQUksT0FBQSx3QkFBYSwwQkFBbkJWLEdBQUVVLElBQUZWLEdBQUVVO0dBQTZCO1lBQ25DRSxJQUFJWixHQUFFVTtJQUFJLE9BQUEsd0JBQWEsdUJBQW5CVixHQUFFVSxJQUFGVixHQUFFVTtHQUE2QjtzQ0FGbkNELFlBRUFHLEtBREFEOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHQzZCWTs7Ozs7Ozs7SUF4Q1pFO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF3Q1k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFlWkMsWUFBYS9GLEdBQWtCLE9BQWxCQSxFQUFvQztZQUtqRGdHLG1CO09BQ0FDO1lBQ0FDLG1CO1lBQ0FDLG1CO1lBQ0FDLG1CO1lBQ0FDLG1CO1lBQ0FDLG1CO1lBQ0FDLG9CO09BQ0FDO1lBQ0FDLG9CO09Ba0JFQztZQUNBakcsV0FB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akc7T0FDREM7T0FDQUM7T0FDQ0M7T0FRRDdsRztPQUNBRDtPQUNBbUM7T0FDQUQ7T0FDQ3pjO09BRUFpVztPQUtBaUM7T0FLRHFvRztPQUNBQztPQUNDQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQ0Q1NEc7T0FZQXFIO09BQ0FFO09BT0FzeEc7T0FDQUM7T0FDQXp1RTtJQTVlQTB1RTtJQUlBQztJQUVBQztJQUlBQztJQUVBQztJQUtBQztJQUlBQztJQUlBQztJQVlBQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQUVBQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQVFEQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQUVBQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQU1EQztJQVFBQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQUVBQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQVFEQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQUVBQztJQUdBQztJQUtEQztJQUNBQztJQUNDQztJQVFEQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQUVBQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQVFEQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQUVBQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQVFEQztJQUlBQztJQUVBQztJQUlBQztJQUVBQztJQUtBQztJQVVBQztJQUlBQztJQUlBQztJQVlBQztJQUlBQztJQUlBQztJQUVBQztJQUlDQztJQUlBQztJQUtBQztJQUtEQztJQUNBQztJQUVDQztJQVVEQztJQUlBQztJQUlBQztJQUlBQztJQUlBQztJQUtBQztJQVVBQztJQUlBQztJQUlBQztJQVdBQztJQUlBQztJQUVBQztJQUlBQztJQUVBQztJQUtBQztJQUlBQztJQUlBQztJQVVBQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQUVBQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQU9EQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQUNEQztJQUNBQztJQUNDQztJQVFEQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQUVBQztJQUtBQztJQUtEQztJQUNBQztJQUNDQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwQ0QxK0c7SUFZQW9qQjtJQUNBRTtJQU9BM2U7SUFDQUU7SUFDQTg1Rzs7OztHQW1CRztHQUVLO0lBQUE7Ozs7O09BdnFCVjduSDtPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQzs7Ozs7T0FzS0V1Nkc7T0FJQUM7T0FFQUM7T0FJQUM7T0FFQUM7T0FLQUM7T0FJQUM7T0FJQUM7T0FZQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQ0M7T0FFQUM7T0FLQUM7T0FLREM7T0FDQUM7T0FDQ0M7T0FRREM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQ0M7T0FFQUM7T0FLQUM7T0FLREM7T0FDQUM7T0FDQ0M7T0FNREM7T0FRQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQ0M7T0FFQUM7T0FLQUM7T0FLREM7T0FDQUM7T0FDQ0M7T0FRREM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQ0M7T0FFQUM7T0FHQUM7T0FLREM7T0FDQUM7T0FDQ0M7T0FRREM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQ0M7T0FFQUM7T0FLQUM7T0FLREM7T0FDQUM7T0FDQ0M7T0FRREM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQ0M7T0FFQUM7T0FLQUM7T0FLREM7T0FDQUM7T0FDQ0M7T0FRREM7T0FJQUM7T0FFQUM7T0FJQUM7T0FFQUM7T0FLQUM7T0FVQUM7T0FJQUM7T0FJQUM7T0FZQUM7T0FJQUM7T0FJQUM7T0FFQUM7T0FJQ0M7T0FJQUM7T0FLQUM7T0FLREM7T0FDQUM7T0FFQ0M7T0FVREM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FLQUM7T0FVQUM7T0FJQUM7T0FJQUM7T0FXQUM7T0FJQUM7T0FFQUM7T0FJQUM7T0FFQUM7T0FLQUM7T0FJQUM7T0FJQUM7T0FVQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQ0M7T0FFQUM7T0FLQUM7T0FLREM7T0FDQUM7T0FDQ0M7T0FPREM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQ0M7T0FDREM7T0FDQUM7T0FDQ0M7T0FRREM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQ0M7T0FFQUM7T0FLQUM7T0FLREM7T0FDQUM7T0FDQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMENEMStHO09BWUFvakI7T0FDQUU7T0FPQTNlO09BQ0FFO09BQ0E4NUc7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5BcHBsaWNhdGl2ZSAqKVxubW9kdWxlIEFwcGxpY2F0aXZlID0gQmFzZV9fQXBwbGljYXRpdmVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5BcHBsaWNhdGl2ZV9pbnRmICopXG5tb2R1bGUgQXBwbGljYXRpdmVfaW50ZiA9IEJhc2VfX0FwcGxpY2F0aXZlX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5BcnJheSAqKVxubW9kdWxlIEFycmF5ID0gQmFzZV9fQXJyYXlcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5BcnJheTAgKilcbm1vZHVsZSBBcnJheTAgPSBCYXNlX19BcnJheTBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5BcnJheV9wZXJtdXRlICopXG5tb2R1bGUgQXJyYXlfcGVybXV0ZSA9IEJhc2VfX0FycmF5X3Blcm11dGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Bdmx0cmVlICopXG5tb2R1bGUgQXZsdHJlZSA9IEJhc2VfX0F2bHRyZWVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CYWNrdHJhY2UgKilcbm1vZHVsZSBCYWNrdHJhY2UgPSBCYXNlX19CYWNrdHJhY2VcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CaW5hcnlfc2VhcmNoICopXG5tb2R1bGUgQmluYXJ5X3NlYXJjaCA9IEJhc2VfX0JpbmFyeV9zZWFyY2hcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CaW5hcnlfc2VhcmNoYWJsZSAqKVxubW9kdWxlIEJpbmFyeV9zZWFyY2hhYmxlID0gQmFzZV9fQmluYXJ5X3NlYXJjaGFibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CaW5hcnlfc2VhcmNoYWJsZV9pbnRmICopXG5tb2R1bGUgQmluYXJ5X3NlYXJjaGFibGVfaW50ZiA9IEJhc2VfX0JpbmFyeV9zZWFyY2hhYmxlX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CbGl0ICopXG5tb2R1bGUgQmxpdCA9IEJhc2VfX0JsaXRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CbGl0X2ludGYgKilcbm1vZHVsZSBCbGl0X2ludGYgPSBCYXNlX19CbGl0X2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Cb29sICopXG5tb2R1bGUgQm9vbCA9IEJhc2VfX0Jvb2xcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Cb29sMCAqKVxubW9kdWxlIEJvb2wwID0gQmFzZV9fQm9vbDBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CdWZmZXIgKilcbm1vZHVsZSBCdWZmZXIgPSBCYXNlX19CdWZmZXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CdWZmZXJfaW50ZiAqKVxubW9kdWxlIEJ1ZmZlcl9pbnRmID0gQmFzZV9fQnVmZmVyX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CeXRlcyAqKVxubW9kdWxlIEJ5dGVzID0gQmFzZV9fQnl0ZXNcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CeXRlczAgKilcbm1vZHVsZSBCeXRlczAgPSBCYXNlX19CeXRlczBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CeXRlc19pbnRmICopXG5tb2R1bGUgQnl0ZXNfaW50ZiA9IEJhc2VfX0J5dGVzX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5CeXRlc190ciAqKVxubW9kdWxlIEJ5dGVzX3RyID0gQmFzZV9fQnl0ZXNfdHJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5DaGFyICopXG5tb2R1bGUgQ2hhciA9IEJhc2VfX0NoYXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5DaGFyMCAqKVxubW9kdWxlIENoYXIwID0gQmFzZV9fQ2hhcjBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Db21wYXJhYmxlICopXG5tb2R1bGUgQ29tcGFyYWJsZSA9IEJhc2VfX0NvbXBhcmFibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Db21wYXJhYmxlX2ludGYgKilcbm1vZHVsZSBDb21wYXJhYmxlX2ludGYgPSBCYXNlX19Db21wYXJhYmxlX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Db21wYXJhdG9yICopXG5tb2R1bGUgQ29tcGFyYXRvciA9IEJhc2VfX0NvbXBhcmF0b3JcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Db21wYXJpc29ucyAqKVxubW9kdWxlIENvbXBhcmlzb25zID0gQmFzZV9fQ29tcGFyaXNvbnNcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Db250YWluZXIgKilcbm1vZHVsZSBDb250YWluZXIgPSBCYXNlX19Db250YWluZXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Db250YWluZXJfaW50ZiAqKVxubW9kdWxlIENvbnRhaW5lcl9pbnRmID0gQmFzZV9fQ29udGFpbmVyX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5EaWN0aW9uYXJ5X2ltbXV0YWJsZSAqKVxubW9kdWxlIERpY3Rpb25hcnlfaW1tdXRhYmxlID0gQmFzZV9fRGljdGlvbmFyeV9pbW11dGFibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5EaWN0aW9uYXJ5X2ltbXV0YWJsZV9pbnRmICopXG5tb2R1bGUgRGljdGlvbmFyeV9pbW11dGFibGVfaW50ZiA9IEJhc2VfX0RpY3Rpb25hcnlfaW1tdXRhYmxlX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5EaWN0aW9uYXJ5X211dGFibGUgKilcbm1vZHVsZSBEaWN0aW9uYXJ5X211dGFibGUgPSBCYXNlX19EaWN0aW9uYXJ5X211dGFibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5EaWN0aW9uYXJ5X211dGFibGVfaW50ZiAqKVxubW9kdWxlIERpY3Rpb25hcnlfbXV0YWJsZV9pbnRmID0gQmFzZV9fRGljdGlvbmFyeV9tdXRhYmxlX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5FaXRoZXIgKilcbm1vZHVsZSBFaXRoZXIgPSBCYXNlX19FaXRoZXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5FaXRoZXIwICopXG5tb2R1bGUgRWl0aGVyMCA9IEJhc2VfX0VpdGhlcjBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5FaXRoZXJfaW50ZiAqKVxubW9kdWxlIEVpdGhlcl9pbnRmID0gQmFzZV9fRWl0aGVyX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5FcXVhbCAqKVxubW9kdWxlIEVxdWFsID0gQmFzZV9fRXF1YWxcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5FcnJvciAqKVxubW9kdWxlIEVycm9yID0gQmFzZV9fRXJyb3JcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5FeG4gKilcbm1vZHVsZSBFeG4gPSBCYXNlX19FeG5cblxuKCoqIEBjYW5vbmljYWwgQmFzZS5GaWVsZCAqKVxubW9kdWxlIEZpZWxkID0gQmFzZV9fRmllbGRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5GaWVsZHNsaWIgKilcbm1vZHVsZSBGaWVsZHNsaWIgPSBCYXNlX19GaWVsZHNsaWJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5GbG9hdCAqKVxubW9kdWxlIEZsb2F0ID0gQmFzZV9fRmxvYXRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5GbG9hdDAgKilcbm1vZHVsZSBGbG9hdDAgPSBCYXNlX19GbG9hdDBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5GbG9hdGFibGUgKilcbm1vZHVsZSBGbG9hdGFibGUgPSBCYXNlX19GbG9hdGFibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5GbiAqKVxubW9kdWxlIEZuID0gQmFzZV9fRm5cblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Gb3JtYXR0ZXIgKilcbm1vZHVsZSBGb3JtYXR0ZXIgPSBCYXNlX19Gb3JtYXR0ZXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5HbG9iYWxpemUgKilcbm1vZHVsZSBHbG9iYWxpemUgPSBCYXNlX19HbG9iYWxpemVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoICopXG5tb2R1bGUgSGFzaCA9IEJhc2VfX0hhc2hcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoX2ludGYgKilcbm1vZHVsZSBIYXNoX2ludGYgPSBCYXNlX19IYXNoX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoX3NldCAqKVxubW9kdWxlIEhhc2hfc2V0ID0gQmFzZV9fSGFzaF9zZXRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoX3NldF9pbnRmICopXG5tb2R1bGUgSGFzaF9zZXRfaW50ZiA9IEJhc2VfX0hhc2hfc2V0X2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoYWJsZSAqKVxubW9kdWxlIEhhc2hhYmxlID0gQmFzZV9fSGFzaGFibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoYWJsZV9pbnRmICopXG5tb2R1bGUgSGFzaGFibGVfaW50ZiA9IEJhc2VfX0hhc2hhYmxlX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoZXIgKilcbm1vZHVsZSBIYXNoZXIgPSBCYXNlX19IYXNoZXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNodGJsICopXG5tb2R1bGUgSGFzaHRibCA9IEJhc2VfX0hhc2h0YmxcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNodGJsX2ludGYgKilcbm1vZHVsZSBIYXNodGJsX2ludGYgPSBCYXNlX19IYXNodGJsX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IZXhfbGV4ZXIgKilcbm1vZHVsZSBIZXhfbGV4ZXIgPSBCYXNlX19IZXhfbGV4ZXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JZGVudGlmaWFibGUgKilcbm1vZHVsZSBJZGVudGlmaWFibGUgPSBCYXNlX19JZGVudGlmaWFibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JZGVudGlmaWFibGVfaW50ZiAqKVxubW9kdWxlIElkZW50aWZpYWJsZV9pbnRmID0gQmFzZV9fSWRlbnRpZmlhYmxlX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbXBvcnQgKilcbm1vZHVsZSBJbXBvcnQgPSBCYXNlX19JbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbXBvcnQwICopXG5tb2R1bGUgSW1wb3J0MCA9IEJhc2VfX0ltcG9ydDBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbmRleGVkX2NvbnRhaW5lciAqKVxubW9kdWxlIEluZGV4ZWRfY29udGFpbmVyID0gQmFzZV9fSW5kZXhlZF9jb250YWluZXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbmRleGVkX2NvbnRhaW5lcl9pbnRmICopXG5tb2R1bGUgSW5kZXhlZF9jb250YWluZXJfaW50ZiA9IEJhc2VfX0luZGV4ZWRfY29udGFpbmVyX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbmZvICopXG5tb2R1bGUgSW5mbyA9IEJhc2VfX0luZm9cblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbmZvX2ludGYgKilcbm1vZHVsZSBJbmZvX2ludGYgPSBCYXNlX19JbmZvX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnQgKilcbm1vZHVsZSBJbnQgPSBCYXNlX19JbnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnQwICopXG5tb2R1bGUgSW50MCA9IEJhc2VfX0ludDBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnQzMiAqKVxubW9kdWxlIEludDMyID0gQmFzZV9fSW50MzJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnQ2MyAqKVxubW9kdWxlIEludDYzID0gQmFzZV9fSW50NjNcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnQ2M19lbXVsICopXG5tb2R1bGUgSW50NjNfZW11bCA9IEJhc2VfX0ludDYzX2VtdWxcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnQ2NCAqKVxubW9kdWxlIEludDY0ID0gQmFzZV9fSW50NjRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnRfY29udmVyc2lvbnMgKilcbm1vZHVsZSBJbnRfY29udmVyc2lvbnMgPSBCYXNlX19JbnRfY29udmVyc2lvbnNcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnRfaW50ZiAqKVxubW9kdWxlIEludF9pbnRmID0gQmFzZV9fSW50X2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnRfbWF0aCAqKVxubW9kdWxlIEludF9tYXRoID0gQmFzZV9fSW50X21hdGhcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnRfc3RyaW5nX2NvbnZlcnNpb25zICopXG5tb2R1bGUgSW50X3N0cmluZ19jb252ZXJzaW9ucyA9IEJhc2VfX0ludF9zdHJpbmdfY29udmVyc2lvbnNcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnRhYmxlICopXG5tb2R1bGUgSW50YWJsZSA9IEJhc2VfX0ludGFibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnZhcmlhbnQgKilcbm1vZHVsZSBJbnZhcmlhbnQgPSBCYXNlX19JbnZhcmlhbnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5JbnZhcmlhbnRfaW50ZiAqKVxubW9kdWxlIEludmFyaWFudF9pbnRmID0gQmFzZV9fSW52YXJpYW50X2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5MYXp5ICopXG5tb2R1bGUgTGF6eSA9IEJhc2VfX0xhenlcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5MaW5rZWRfcXVldWUgKilcbm1vZHVsZSBMaW5rZWRfcXVldWUgPSBCYXNlX19MaW5rZWRfcXVldWVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5MaW5rZWRfcXVldWUwICopXG5tb2R1bGUgTGlua2VkX3F1ZXVlMCA9IEJhc2VfX0xpbmtlZF9xdWV1ZTBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5MaXN0ICopXG5tb2R1bGUgTGlzdCA9IEJhc2VfX0xpc3RcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5MaXN0MCAqKVxubW9kdWxlIExpc3QwID0gQmFzZV9fTGlzdDBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5MaXN0MSAqKVxubW9kdWxlIExpc3QxID0gQmFzZV9fTGlzdDFcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5NYXAgKilcbm1vZHVsZSBNYXAgPSBCYXNlX19NYXBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5NYXBfaW50ZiAqKVxubW9kdWxlIE1hcF9pbnRmID0gQmFzZV9fTWFwX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5NYXliZV9ib3VuZCAqKVxubW9kdWxlIE1heWJlX2JvdW5kID0gQmFzZV9fTWF5YmVfYm91bmRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Nb25hZCAqKVxubW9kdWxlIE1vbmFkID0gQmFzZV9fTW9uYWRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Nb25hZF9pbnRmICopXG5tb2R1bGUgTW9uYWRfaW50ZiA9IEJhc2VfX01vbmFkX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5OYXRpdmVpbnQgKilcbm1vZHVsZSBOYXRpdmVpbnQgPSBCYXNlX19OYXRpdmVpbnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Ob3RoaW5nICopXG5tb2R1bGUgTm90aGluZyA9IEJhc2VfX05vdGhpbmdcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5PYmpfYXJyYXkgKilcbm1vZHVsZSBPYmpfYXJyYXkgPSBCYXNlX19PYmpfYXJyYXlcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5PYmpfbG9jYWwgKilcbm1vZHVsZSBPYmpfbG9jYWwgPSBCYXNlX19PYmpfbG9jYWxcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5PcHRpb24gKilcbm1vZHVsZSBPcHRpb24gPSBCYXNlX19PcHRpb25cblxuKCoqIEBjYW5vbmljYWwgQmFzZS5PcHRpb25fYXJyYXkgKilcbm1vZHVsZSBPcHRpb25fYXJyYXkgPSBCYXNlX19PcHRpb25fYXJyYXlcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Pcl9lcnJvciAqKVxubW9kdWxlIE9yX2Vycm9yID0gQmFzZV9fT3JfZXJyb3JcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uICopXG5tb2R1bGUgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbiA9IEJhc2VfX09yZGVyZWRfY29sbGVjdGlvbl9jb21tb25cblxuKCoqIEBjYW5vbmljYWwgQmFzZS5PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMCAqKVxubW9kdWxlIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wID0gQmFzZV9fT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5PcmRlcmluZyAqKVxubW9kdWxlIE9yZGVyaW5nID0gQmFzZV9fT3JkZXJpbmdcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Qb2x5MCAqKVxubW9kdWxlIFBvbHkwID0gQmFzZV9fUG9seTBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Qb3Bjb3VudCAqKVxubW9kdWxlIFBvcGNvdW50ID0gQmFzZV9fUG9wY291bnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Qb3dfb3ZlcmZsb3dfYm91bmRzICopXG5tb2R1bGUgUG93X292ZXJmbG93X2JvdW5kcyA9IEJhc2VfX1Bvd19vdmVyZmxvd19ib3VuZHNcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5QcHhfY29tcGFyZV9saWIgKilcbm1vZHVsZSBQcHhfY29tcGFyZV9saWIgPSBCYXNlX19QcHhfY29tcGFyZV9saWJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5QcHhfZW51bWVyYXRlX2xpYiAqKVxubW9kdWxlIFBweF9lbnVtZXJhdGVfbGliID0gQmFzZV9fUHB4X2VudW1lcmF0ZV9saWJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5QcHhfaGFzaF9saWIgKilcbm1vZHVsZSBQcHhfaGFzaF9saWIgPSBCYXNlX19QcHhfaGFzaF9saWJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5QcmV0dHlfcHJpbnRlciAqKVxubW9kdWxlIFByZXR0eV9wcmludGVyID0gQmFzZV9fUHJldHR5X3ByaW50ZXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5QcmludGYgKilcbm1vZHVsZSBQcmludGYgPSBCYXNlX19QcmludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5RdWV1ZSAqKVxubW9kdWxlIFF1ZXVlID0gQmFzZV9fUXVldWVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5RdWV1ZV9pbnRmICopXG5tb2R1bGUgUXVldWVfaW50ZiA9IEJhc2VfX1F1ZXVlX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5SYW5kb20gKilcbm1vZHVsZSBSYW5kb20gPSBCYXNlX19SYW5kb21cblxuKCoqIEBjYW5vbmljYWwgQmFzZS5SYW5kb21fcmVwciAqKVxubW9kdWxlIFJhbmRvbV9yZXByID0gQmFzZV9fUmFuZG9tX3JlcHJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5SZWYgKilcbm1vZHVsZSBSZWYgPSBCYXNlX19SZWZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5SZXN1bHQgKilcbm1vZHVsZSBSZXN1bHQgPSBCYXNlX19SZXN1bHRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TZXF1ZW5jZSAqKVxubW9kdWxlIFNlcXVlbmNlID0gQmFzZV9fU2VxdWVuY2VcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TZXQgKilcbm1vZHVsZSBTZXQgPSBCYXNlX19TZXRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TZXRfaW50ZiAqKVxubW9kdWxlIFNldF9pbnRmID0gQmFzZV9fU2V0X2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TZXhwICopXG5tb2R1bGUgU2V4cCA9IEJhc2VfX1NleHBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TZXhwX3dpdGhfY29tcGFyYWJsZSAqKVxubW9kdWxlIFNleHBfd2l0aF9jb21wYXJhYmxlID0gQmFzZV9fU2V4cF93aXRoX2NvbXBhcmFibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TZXhwYWJsZSAqKVxubW9kdWxlIFNleHBhYmxlID0gQmFzZV9fU2V4cGFibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TaWduICopXG5tb2R1bGUgU2lnbiA9IEJhc2VfX1NpZ25cblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TaWduMCAqKVxubW9kdWxlIFNpZ24wID0gQmFzZV9fU2lnbjBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TaWduX29yX25hbiAqKVxubW9kdWxlIFNpZ25fb3JfbmFuID0gQmFzZV9fU2lnbl9vcl9uYW5cblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Tb3VyY2VfY29kZV9wb3NpdGlvbiAqKVxubW9kdWxlIFNvdXJjZV9jb2RlX3Bvc2l0aW9uID0gQmFzZV9fU291cmNlX2NvZGVfcG9zaXRpb25cblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Tb3VyY2VfY29kZV9wb3NpdGlvbjAgKilcbm1vZHVsZSBTb3VyY2VfY29kZV9wb3NpdGlvbjAgPSBCYXNlX19Tb3VyY2VfY29kZV9wb3NpdGlvbjBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TdGFjayAqKVxubW9kdWxlIFN0YWNrID0gQmFzZV9fU3RhY2tcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TdGFja19pbnRmICopXG5tb2R1bGUgU3RhY2tfaW50ZiA9IEJhc2VfX1N0YWNrX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TdGFnZWQgKilcbm1vZHVsZSBTdGFnZWQgPSBCYXNlX19TdGFnZWRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TdHJpbmcgKilcbm1vZHVsZSBTdHJpbmcgPSBCYXNlX19TdHJpbmdcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TdHJpbmcwICopXG5tb2R1bGUgU3RyaW5nMCA9IEJhc2VfX1N0cmluZzBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TdHJpbmdfaW50ZiAqKVxubW9kdWxlIFN0cmluZ19pbnRmID0gQmFzZV9fU3RyaW5nX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TdHJpbmdhYmxlICopXG5tb2R1bGUgU3RyaW5nYWJsZSA9IEJhc2VfX1N0cmluZ2FibGVcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TeXMgKilcbm1vZHVsZSBTeXMgPSBCYXNlX19TeXNcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5TeXMwICopXG5tb2R1bGUgU3lzMCA9IEJhc2VfX1N5czBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5UICopXG5tb2R1bGUgVCA9IEJhc2VfX1RcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5UeXBlX2VxdWFsICopXG5tb2R1bGUgVHlwZV9lcXVhbCA9IEJhc2VfX1R5cGVfZXF1YWxcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5UeXBlX2VxdWFsX2ludGYgKilcbm1vZHVsZSBUeXBlX2VxdWFsX2ludGYgPSBCYXNlX19UeXBlX2VxdWFsX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5VY2hhciAqKVxubW9kdWxlIFVjaGFyID0gQmFzZV9fVWNoYXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5VY2hhcjAgKilcbm1vZHVsZSBVY2hhcjAgPSBCYXNlX19VY2hhcjBcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5VY2hhcl9pbnRmICopXG5tb2R1bGUgVWNoYXJfaW50ZiA9IEJhc2VfX1VjaGFyX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Vbmlmb3JtX2FycmF5ICopXG5tb2R1bGUgVW5pZm9ybV9hcnJheSA9IEJhc2VfX1VuaWZvcm1fYXJyYXlcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Vbml0ICopXG5tb2R1bGUgVW5pdCA9IEJhc2VfX1VuaXRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5WYXJpYW50ICopXG5tb2R1bGUgVmFyaWFudCA9IEJhc2VfX1ZhcmlhbnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5WYXJpYW50c2xpYiAqKVxubW9kdWxlIFZhcmlhbnRzbGliID0gQmFzZV9fVmFyaWFudHNsaWJcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5XaXRoX3JldHVybiAqKVxubW9kdWxlIFdpdGhfcmV0dXJuID0gQmFzZV9fV2l0aF9yZXR1cm5cblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Xb3JkX3NpemUgKilcbm1vZHVsZSBXb3JkX3NpemUgPSBCYXNlX19Xb3JkX3NpemVcblxubW9kdWxlIEJhc2VfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwiKCogVGhlIFtnbG9iYWxpemVfe2Jvb2wsY2hhcix1bml0fV0gZnVuY3Rpb25zIGFyZSB3cml0dGVuIGFzIG1hdGNoZXMgcGx1cyB0aGUgaWRlbnRpdHlcbiAgIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIHR5cGUgY2hlY2tlciBjYW4gZ2l2ZSB0aGVtIHRoZSBkZXNpcmVkIHR5cGUsIHdpdGhvdXQgaGF2aW5nIHRvIGRvXG4gICBhbnl0aGluZyBzcGVjaWFsLiAgSG93ZXZlciwgW2dsb2JhbGl6ZV9pbnRdIGNhbm5vdCBiZSB3cml0dGVuIHRoaXMgd2F5LCBzbyB3ZSByZXNvcnQgdG9cbiAgIHVzaW5nIGFuIFtleHRlcm5hbF0uICopXG5cbmxldCBnbG9iYWxpemVfYm9vbCA9IGZ1bmN0aW9uXG4gIHwgKHRydWUgfCBmYWxzZSkgYXMgYiAtPiBiXG47O1xuXG5sZXQgZ2xvYmFsaXplX2NoYXIgPSBmdW5jdGlvblxuICB8ICdcXHgwMCcgLi4gJ1xceEZGJyBhcyBjIC0+IGNcbjs7XG5cbmV4dGVybmFsIGdsb2JhbGl6ZV9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX2ludCA6IGludCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnbG9iYWxpemVfaW50MzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiY2FtbF9vYmpfZHVwXCJcbmV4dGVybmFsIGdsb2JhbGl6ZV9pbnQ2NCA6IGludDY0IC0+IGludDY0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCBnbG9iYWxpemVfYnl0ZXMgOiBieXRlcyAtPiBieXRlcyA9IFwiY2FtbF9vYmpfZHVwXCJcbmV4dGVybmFsIGdsb2JhbGl6ZV9zdHJpbmcgOiBzdHJpbmcgLT4gc3RyaW5nID0gXCJjYW1sX29ial9kdXBcIlxuXG5sZXQgZ2xvYmFsaXplX3VuaXQgKCgpIGFzIHUpID0gdVxuXG5leHRlcm5hbCBnbG9iYWxpemVfYXJyYXknIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfb2JqX2R1cFwiXG5cbmxldCBnbG9iYWxpemVfYXJyYXkgXyBhID0gZ2xvYmFsaXplX2FycmF5JyBhXG5cbmxldCByZWMgZ2xvYmFsaXplX2xpc3QgZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCB4IDo6IHhzIC0+IGYgeCA6OiBnbG9iYWxpemVfbGlzdCBmIHhzXG47O1xuXG5sZXQgZ2xvYmFsaXplX29wdGlvbiBmID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHggLT4gU29tZSAoZiB4KVxuOztcblxubGV0IGdsb2JhbGl6ZV9yZXN1bHQgZ2xvYmFsaXplX2EgZ2xvYmFsaXplX2IgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIGEgLT4gT2sgKGdsb2JhbGl6ZV9hIGEpXG4gIHwgRXJyb3IgYiAtPiBFcnJvciAoZ2xvYmFsaXplX2IgYilcbjs7XG5cbmxldCBnbG9iYWxpemVfcmVmJyByID0gcmVmICFyXG5sZXQgZ2xvYmFsaXplX3JlZiBfIHIgPSBnbG9iYWxpemVfcmVmJyByXG5cbmV4dGVybmFsIGdsb2JhbGl6ZV9sYXp5X3RfbW9ubyA6ICdhIGxhenlfdCAtPiAnYSBsYXp5X3QgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBnbG9iYWxpemVfbGF6eV90IF8gdCA9IGdsb2JhbGl6ZV9sYXp5X3RfbW9ubyB0XG4iLCIoKiogUHJpbWl0aXZlcyBmb3IgcG9seW1vcnBoaWMgY29tcGFyZS4gKilcblxuKCpfIFBvbHltb3JwaGljIGNvbXBpbGVyIHByaW1pdGl2ZXMgY2FuJ3QgYmUgYWxpYXNlcyBhcyB0aGlzIGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAgaW5saW5pbmcuIChJZiBhbGlhc2VkIHdpdGhvdXQgYSB0eXBlIGFubm90YXRpb24sIHRoZSBjb21waWxlciB3b3VsZCBpbXBsZW1lbnQgdGhlbVxuICB1c2luZyB0aGUgZ2VuZXJpYyBjb2RlIGRvaW5nIGEgQyBjYWxsLCBhbmQgaXQncyB0aGlzIGNvZGUgdGhhdCB3b3VsZCBiZSBpbmxpbmVkLikgQXMgYVxuICByZXN1bHQgd2UgaGF2ZSB0byBjb3B5IHRoZSBbZXh0ZXJuYWwgLi4uXSBkZWNsYXJhdGlvbiBoZXJlLiAqKVxuZXh0ZXJuYWwgKCA8ICkgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA9ICkgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPiApIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoID49ICkgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBhc2NlbmRpbmcgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBjb21wYXJlIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuZXh0ZXJuYWwgZXF1YWwgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxubGV0IGRlc2NlbmRpbmcgeCB5ID0gY29tcGFyZSB5IHhcbmxldCBtYXggeCB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxubGV0IG1pbiB4IHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG4iLCIoKiBUaGlzIG1vZHVsZSBpcyBpbmNsdWRlZCBpbiBbSW1wb3J0XS4gIEl0IGlzIGFpbWVkIGF0IG1vZHVsZXMgdGhhdCBkZWZpbmUgdGhlIHN0YW5kYXJkXG4gICBjb21iaW5hdG9ycyBmb3IgW3NleHBfb2ZdLCBbb2Zfc2V4cF0sIFtjb21wYXJlXSBhbmQgW2hhc2hdIGFuZCBhcmUgaW5jbHVkZWQgaW5cbiAgIFtJbXBvcnRdLiAqKVxuXG5pbmNsdWRlIChcbiAgU2hhZG93X3N0ZGxpYiA6XG4gICAgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgICBpbmNsdWRlIFNoYWRvd19zdGRsaWJcbiAgICBlbmRcbiAgICB3aXRoIHR5cGUgJ2EgcmVmIDo9ICdhIHJlZlxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0IDo9ICgnYSwgJ2IsICdjKSBmb3JtYXRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0IDo9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA6PSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAgICgqIFRoZXNlIG1vZHVsZXMgYXJlIHJlZGVmaW5lZCBpbiBCYXNlICopXG4gICAgd2l0aCBtb2R1bGUgQXJyYXkgOj0gU2hhZG93X3N0ZGxpYi5BcnJheVxuICAgIHdpdGggbW9kdWxlIEF0b21pYyA6PSBTaGFkb3dfc3RkbGliLkF0b21pY1xuICAgIHdpdGggbW9kdWxlIEJvb2wgOj0gU2hhZG93X3N0ZGxpYi5Cb29sXG4gICAgd2l0aCBtb2R1bGUgQnVmZmVyIDo9IFNoYWRvd19zdGRsaWIuQnVmZmVyXG4gICAgd2l0aCBtb2R1bGUgQnl0ZXMgOj0gU2hhZG93X3N0ZGxpYi5CeXRlc1xuICAgIHdpdGggbW9kdWxlIENoYXIgOj0gU2hhZG93X3N0ZGxpYi5DaGFyXG4gICAgd2l0aCBtb2R1bGUgRWl0aGVyIDo9IFNoYWRvd19zdGRsaWIuRWl0aGVyXG4gICAgd2l0aCBtb2R1bGUgRmxvYXQgOj0gU2hhZG93X3N0ZGxpYi5GbG9hdFxuICAgIHdpdGggbW9kdWxlIEhhc2h0YmwgOj0gU2hhZG93X3N0ZGxpYi5IYXNodGJsXG4gICAgd2l0aCBtb2R1bGUgSW50IDo9IFNoYWRvd19zdGRsaWIuSW50XG4gICAgd2l0aCBtb2R1bGUgSW50MzIgOj0gU2hhZG93X3N0ZGxpYi5JbnQzMlxuICAgIHdpdGggbW9kdWxlIEludDY0IDo9IFNoYWRvd19zdGRsaWIuSW50NjRcbiAgICB3aXRoIG1vZHVsZSBMYXp5IDo9IFNoYWRvd19zdGRsaWIuTGF6eVxuICAgIHdpdGggbW9kdWxlIExpc3QgOj0gU2hhZG93X3N0ZGxpYi5MaXN0XG4gICAgd2l0aCBtb2R1bGUgTWFwIDo9IFNoYWRvd19zdGRsaWIuTWFwXG4gICAgd2l0aCBtb2R1bGUgTmF0aXZlaW50IDo9IFNoYWRvd19zdGRsaWIuTmF0aXZlaW50XG4gICAgd2l0aCBtb2R1bGUgT3B0aW9uIDo9IFNoYWRvd19zdGRsaWIuT3B0aW9uXG4gICAgd2l0aCBtb2R1bGUgUHJpbnRmIDo9IFNoYWRvd19zdGRsaWIuUHJpbnRmXG4gICAgd2l0aCBtb2R1bGUgUXVldWUgOj0gU2hhZG93X3N0ZGxpYi5RdWV1ZVxuICAgIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICAgIHdpdGggbW9kdWxlIFJlc3VsdCA6PSBTaGFkb3dfc3RkbGliLlJlc3VsdFxuICAgIHdpdGggbW9kdWxlIFNldCA6PSBTaGFkb3dfc3RkbGliLlNldFxuICAgIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgICB3aXRoIG1vZHVsZSBTdHJpbmcgOj0gU2hhZG93X3N0ZGxpYi5TdHJpbmdcbiAgICB3aXRoIG1vZHVsZSBTeXMgOj0gU2hhZG93X3N0ZGxpYi5TeXNcbiAgICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gICAgd2l0aCBtb2R1bGUgVW5pdCA6PSBTaGFkb3dfc3RkbGliLlVuaXQpXG5bQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG50eXBlICdhIHJlZiA9ICdhIFN0ZGxpYi5yZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5cbigqIFJlc2h1ZmZsZSBbU3RkbGliXSBzbyB0aGF0IHdlIGNob29zZSB0aGUgbW9kdWxlcyB1c2luZyBsYWJlbHMgd2hlbiBhdmFpbGFibGUuICopXG5tb2R1bGUgU3RkbGliID0gc3RydWN0XG4gIGluY2x1ZGUgU3RkbGliXG4gIGluY2x1ZGUgU3RkbGliLlN0ZExhYmVsc1xuICBpbmNsdWRlIFN0ZGxpYi5Nb3JlTGFiZWxzXG5lbmRcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCgnYSAtPiAnYilbQGxvY2FsX29wdF0pIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuXG4oKiBUaGVzZSBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGdldCB0aGUgbGF6eSBiZWhhdmlvciAqKVxuZXh0ZXJuYWwgKCAmJiApIDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IChib29sW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiAoYm9vbFtAbG9jYWxfb3B0XSkgLT4gKGJvb2xbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgbm90IDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVib29sbm90XCJcblxuKCogV2UgdXNlIFtPYmoubWFnaWNdIGhlcmUgYXMgb3RoZXIgaW1wbGVtZW50YXRpb25zIGdlbmVyYXRlIGEgY29uZGl0aW9uYWwganVtcCBhbmQgdGhlXG4gICBwZXJmb3JtYW5jZSBkaWZmZXJlbmNlIGlzIG5vdGljZWFibGUuICopXG5sZXQgYm9vbF90b19pbnQgKHggOiBib29sKSA6IGludCA9IFN0ZGxpYi5PYmoubWFnaWMgeFxuXG4oKiBUaGlzIG5lZWRzIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIGZvciB0aGUgd2FybmluZ3MgdG8gd29yayBwcm9wZXJseSAqKVxuZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxubGV0ICggIT0gKSA9IFN0ZGxpYi4oICE9IClcbmxldCAoICogKSA9IFN0ZGxpYi4oICogKVxubGV0ICggKiogKSA9IFN0ZGxpYi4oICoqIClcbmxldCAoICouICkgPSBTdGRsaWIuKCAqLiApXG5sZXQgKCArICkgPSBTdGRsaWIuKCArIClcbmxldCAoICsuICkgPSBTdGRsaWIuKCArLiApXG5sZXQgKCAtICkgPSBTdGRsaWIuKCAtIClcbmxldCAoIC0uICkgPSBTdGRsaWIuKCAtLiApXG5sZXQgKCAvICkgPSBTdGRsaWIuKCAvIClcbmxldCAoIC8uICkgPSBTdGRsaWIuKCAvLiApXG5cbm1vZHVsZSBQb2x5ID0gUG9seTAgKCoqIEBjYW5vbmljYWwgQmFzZS5Qb2x5ICopXG5cbm1vZHVsZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4gIGV4dGVybmFsICggPD4gKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG4gIGV4dGVybmFsICggPCApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoIDw9ICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbiAgZXh0ZXJuYWwgKCA+PSApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbiAgZXh0ZXJuYWwgY29tcGFyZV9fbG9jYWwgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbiAgZXh0ZXJuYWwgZXF1YWwgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuICBleHRlcm5hbCBlcXVhbF9fbG9jYWwgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBpbnQpIHkgPSBjb21wYXJlIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IGludCkgeSA9IGNvbXBhcmUgeSB4XG4gIGxldCBtYXggKHggOiBpbnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBpbnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxuaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBlcXVhbF9fbG9jYWwgKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgKCogRGVjbGFyZWQgYXMgZXh0ZXJuYWxzIHNvIHRoYXQgdGhlIGNvbXBpbGVyIHNraXBzIHRoZSBjYW1sX2FwcGx5X1ggd3JhcHBpbmcgZXZlbiB3aGVuXG4gICAgIGNvbXBpbGluZyB3aXRob3V0IGNyb3NzIGxpYnJhcnkgaW5saW5pbmcuICopXG4gIGV4dGVybmFsICggPSApXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgKCA8PiApXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVub3RlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgKCA8IClcbiAgICA6ICAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGJvb2xcbiAgICA9IFwiJWxlc3N0aGFuXCJcblxuICBleHRlcm5hbCAoID4gKVxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlZ3JlYXRlcnRoYW5cIlxuXG4gIGV4dGVybmFsICggPD0gKVxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlbGVzc2VxdWFsXCJcblxuICBleHRlcm5hbCAoID49IClcbiAgICA6ICAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGJvb2xcbiAgICA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgY29tcGFyZVxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gaW50XG4gICAgPSBcIiVjb21wYXJlXCJcblxuICBleHRlcm5hbCBjb21wYXJlX19sb2NhbFxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gaW50XG4gICAgPSBcIiVjb21wYXJlXCJcblxuICBleHRlcm5hbCBlcXVhbFxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlZXF1YWxcIlxuXG4gIGV4dGVybmFsIGVxdWFsX19sb2NhbFxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlZXF1YWxcIlxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBTdGRsaWIuSW50NjQudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IFN0ZGxpYi5JbnQ2NC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgbWF4ICh4IDogU3RkbGliLkludDY0LnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBTdGRsaWIuSW50NjQudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBib29sKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGJvb2wpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBib29sKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGJvb2wpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IGJvb2wpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGJvb2wpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogYm9vbCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBib29sKSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogYm9vbCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGNoYXIpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBjaGFyKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGNoYXIpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IGNoYXIpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGNoYXIpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogY2hhcikgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBjaGFyKSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogY2hhcikgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIG9wZW4gc3RydWN0XG4gICAgZXh0ZXJuYWwgaSA6IChTdGRsaWIuVWNoYXIudFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuICBlbmRcblxuICBsZXQgKCA8ICkgKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPD0gKSAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPD4gKSAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw+ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPSApICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChpIHgpIChpIHkpXG4gIGxldCAoID4gKSAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID4gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA+PSApICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSAoaSB4KSAoaSB5KVxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5hc2NlbmRpbmcgKGkgeCkgKGkgeSlcbiAgOztcblxuICBsZXQgZGVzY2VuZGluZyAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID1cbiAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmRlc2NlbmRpbmcgKGkgeCkgKGkgeSlcbiAgOztcblxuICBsZXQgY29tcGFyZSAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlIChpIHgpIChpIHkpXG4gIGxldCBlcXVhbCAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCAoaSB4KSAoaSB5KVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID1cbiAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVfX2xvY2FsIChpIHgpIChpIHkpXG4gIDs7XG5cbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID1cbiAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsX19sb2NhbCAoaSB4KSAoaSB5KVxuICA7O1xuXG4gIGxldCBtYXggKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCA8ICkgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA8PSApIDogKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuICBleHRlcm5hbCAoIDw+ICkgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA9ICkgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+PSApIDogKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuICBleHRlcm5hbCBlcXVhbCA6IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuICBleHRlcm5hbCBjb21wYXJlIDogKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBmbG9hdCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IGZsb2F0KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZV9fbG9jYWwgKHggOiBmbG9hdCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IGZsb2F0KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGZsb2F0KSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogZmxvYXQpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxubW9kdWxlIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IHN0cmluZykgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IHN0cmluZykgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IHN0cmluZykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogc3RyaW5nKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IHN0cmluZykgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBzdHJpbmcpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBzdHJpbmcpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxubW9kdWxlIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogYnl0ZXMpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBieXRlcykgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBieXRlcykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogYnl0ZXMpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGJ5dGVzKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IGJ5dGVzKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGJ5dGVzKSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogYnl0ZXMpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxuKCogVGhpcyBuZWVkcyB0byBiZSBkZWZpbmVkIGFzIGFuIGV4dGVybmFsIHNvIHRoYXQgdGhlIGNvbXBpbGVyIGNhbiBzcGVjaWFsaXplIGl0IGFzIGFcbiAgIGRpcmVjdCBzZXQgb3IgY2FtbF9tb2RpZnkuICopXG5leHRlcm5hbCAoIDo9ICkgOiAoJ2EgcmVmW0Bsb2NhbF9vcHRdKSAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcblxuKCogVGhlc2UgbmVlZCB0byBiZSBkZWZpbmVkIGFzIGFuIGV4dGVybmFsIG90aGVyd2lzZSB0aGUgY29tcGlsZXIgd29uJ3QgdW5ib3hcbiAgIHJlZmVyZW5jZXMuICopXG5leHRlcm5hbCAoICEgKSA6ICgnYSByZWZbQGxvY2FsX29wdF0pIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHJlZiA6ICdhIC0+ICgnYSByZWZbQGxvY2FsX29wdF0pID0gXCIlbWFrZW11dGFibGVcIlxuXG5sZXQgKCBAICkgPSBTdGRsaWIuKCBAIClcbmxldCAoIF4gKSA9IFN0ZGxpYi4oIF4gKVxubGV0ICggfi0gKSA9IFN0ZGxpYi4oIH4tIClcbmxldCAoIH4tLiApID0gU3RkbGliLiggfi0uIClcbmxldCAoIGFzciApID0gU3RkbGliLiggYXNyIClcbmxldCAoIGxhbmQgKSA9IFN0ZGxpYi4oIGxhbmQgKVxubGV0IGxub3QgPSBTdGRsaWIubG5vdFxubGV0ICggbG9yICkgPSBTdGRsaWIuKCBsb3IgKVxubGV0ICggbHNsICkgPSBTdGRsaWIuKCBsc2wgKVxubGV0ICggbHNyICkgPSBTdGRsaWIuKCBsc3IgKVxubGV0ICggbHhvciApID0gU3RkbGliLiggbHhvciApXG5sZXQgKCBtb2QgKSA9IFN0ZGxpYi4oIG1vZCApXG5sZXQgYWJzID0gU3RkbGliLmFic1xubGV0IGZhaWx3aXRoID0gU3RkbGliLmZhaWx3aXRoXG5sZXQgZnN0ID0gU3RkbGliLmZzdFxubGV0IGludmFsaWRfYXJnID0gU3RkbGliLmludmFsaWRfYXJnXG5sZXQgc25kID0gU3RkbGliLnNuZFxuXG4oKiBbcmFpc2VdIG5lZWRzIHRvIGJlIGRlZmluZWQgYXMgYW4gZXh0ZXJuYWwgYXMgdGhlIGNvbXBpbGVyIGF1dG9tYXRpY2FsbHkgcmVwbGFjZXNcbiAgICclcmFpc2UnIGJ5ICclcmVyYWlzZScgd2hlbiBhcHByb3ByaWF0ZS4gKilcbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+IF8gPSBcIiVyYWlzZVwiXG5leHRlcm5hbCBwaHlzX2VxdWFsIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCBkZWNyIDogKGludCByZWZbQGxvY2FsX29wdF0pIC0+IHVuaXQgPSBcIiVkZWNyXCJcbmV4dGVybmFsIGluY3IgOiAoaW50IHJlZltAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWluY3JcIlxuXG4oKiBVc2VkIGJ5IHNleHBfY29udiwgd2hpY2ggZmxvYXQwIGRlcGVuZHMgb24gdGhyb3VnaCBvcHRpb24uICopXG5sZXQgZmxvYXRfb2Zfc3RyaW5nID0gU3RkbGliLmZsb2F0X29mX3N0cmluZ1xuXG4oKiBbYW1fdGVzdGluZ10gaXMgdXNlZCBpbiBhIGZldyBwbGFjZXMgdG8gYmVoYXZlIGRpZmZlcmVudGx5IHdoZW4gaW4gdGVzdGluZyBtb2RlLCBzdWNoXG4gICBhcyBpbiBbcmFuZG9tLm1sXS4gIFthbV90ZXN0aW5nXSBpcyBpbXBsZW1lbnRlZCB1c2luZyBbQmFzZV9hbV90ZXN0aW5nXSwgYSB3ZWFrIEMvanNcbiAgIHByaW1pdGl2ZSB0aGF0IHJldHVybnMgW2ZhbHNlXSwgYnV0IHdoZW4gbGlua2luZyBhbiBpbmxpbmUtdGVzdC1ydW5uZXIgZXhlY3V0YWJsZSwgaXNcbiAgIG92ZXJyaWRkZW4gYnkgYW5vdGhlciBwcmltaXRpdmUgdGhhdCByZXR1cm5zIFt0cnVlXS4gKilcbmV4dGVybmFsIGFtX3Rlc3RpbmcgOiB1bml0IC0+IGJvb2wgPSBcIkJhc2VfYW1fdGVzdGluZ1wiXG5cbmxldCBhbV90ZXN0aW5nID0gYW1fdGVzdGluZyAoKVxuIiwiKCogW0ludDBdIGRlZmluZXMgaW50ZWdlciBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5XG4gICBkZWZpbmVkIGluIHRlcm1zIG9mIFtTdGRsaWJdLiBbSW50MF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZVxuICAgcGFydCBvZiBbU3RkbGliXSB0aGF0IFtCYXNlXSB1c2VzIGZvciBpbnRlZ2VycyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXJcbiAgIHRoYW4gaW50MC5tbCBzaG91bGQgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0aHJvdWdoIFtTdGRsaWJdLiBbSW50MF0gaGFzXG4gICBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci5cblxuICAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBpbnRzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5JbnRdIGluIGJ1aWxkXG4gICBvcmRlciBzaG91bGQgZG86XG5cbiAgIHtbXG4gICAgIG1vZHVsZSBJbnQgID0gSW50MFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBJbnQgPSBJbnQwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzIG9jYW1sZGVwXG4gICBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkludF0uICopXG5cbmxldCB0b19zdHJpbmcgPSBTdGRsaWIuc3RyaW5nX29mX2ludFxubGV0IG9mX3N0cmluZyA9IFN0ZGxpYi5pbnRfb2Zfc3RyaW5nXG5sZXQgb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5pbnRfb2Zfc3RyaW5nX29wdFxubGV0IHRvX2Zsb2F0ID0gU3RkbGliLmZsb2F0X29mX2ludFxubGV0IG9mX2Zsb2F0ID0gU3RkbGliLmludF9vZl9mbG9hdFxubGV0IG1heF92YWx1ZSA9IFN0ZGxpYi5tYXhfaW50XG5sZXQgbWluX3ZhbHVlID0gU3RkbGliLm1pbl9pbnRcbmxldCBzdWNjID0gU3RkbGliLnN1Y2NcbmxldCBwcmVkID0gU3RkbGliLnByZWRcbiIsIm9wZW4hIEltcG9ydDBcbmluY2x1ZGUgU3RkbGliLlByaW50ZlxuXG4oKiogZmFpbHdpdGgsIGludmFsaWRfYXJnLCBhbmQgZXhpdCBhY2NlcHRpbmcgcHJpbnRmJ3MgZm9ybWF0LiAqKVxuXG5sZXRbQGlubGluZSBuZXZlcl0gW0B6ZXJvX2FsbG9jIGFzc3VtZSBuZXZlcl9yZXR1cm5zX25vcm1hbGx5XSBmYWlsd2l0aGYgZm10ID1cbiAga3NwcmludGYgKGZ1biBzICgpIC0+IGZhaWx3aXRoIHMpIGZtdFxuOztcblxubGV0W0BpbmxpbmUgbmV2ZXJdIFtAemVyb19hbGxvYyBhc3N1bWUgbmV2ZXJfcmV0dXJuc19ub3JtYWxseV0gaW52YWxpZF9hcmdmIGZtdCA9XG4gIGtzcHJpbnRmIChmdW4gcyAoKSAtPiBpbnZhbGlkX2FyZyBzKSBmbXRcbjs7XG4iLCIoKiBbU3lzMF0gZGVmaW5lcyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW5cbiAgIHRlcm1zIG9mIFtTdGRsaWIuU3lzXS4gIFtTeXMwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtTdGRsaWIuU3lzXSB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIHN5cy5tbFxuICAgc2hvdWxkIHVzZSBbU3RkbGliLlN5c10uIFtTeXMwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZVxuICAgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSB0aGVzZVxuICAgZnVuY3Rpb25zIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5TeXNdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBTeXMgPSBTeXMwXS4gIERlZmluaW5nIFttb2R1bGUgU3lzID0gU3lzMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZVxuICAgaXQgcHJldmVudHMgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5TeXNdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbnR5cGUgYmFja2VuZF90eXBlID0gU3RkbGliLlN5cy5iYWNrZW5kX3R5cGUgPVxuICB8IE5hdGl2ZVxuICB8IEJ5dGVjb2RlXG4gIHwgT3RoZXIgb2Ygc3RyaW5nXG5cbmxldCBiYWNrZW5kX3R5cGUgPSBTdGRsaWIuU3lzLmJhY2tlbmRfdHlwZVxubGV0IGludGVyYWN0aXZlID0gU3RkbGliLlN5cy5pbnRlcmFjdGl2ZVxubGV0IG9zX3R5cGUgPSBTdGRsaWIuU3lzLm9zX3R5cGVcbmxldCB1bml4ID0gU3RkbGliLlN5cy51bml4XG5sZXQgd2luMzIgPSBTdGRsaWIuU3lzLndpbjMyXG5sZXQgY3lnd2luID0gU3RkbGliLlN5cy5jeWd3aW5cbmxldCB3b3JkX3NpemVfaW5fYml0cyA9IFN0ZGxpYi5TeXMud29yZF9zaXplXG5sZXQgaW50X3NpemVfaW5fYml0cyA9IFN0ZGxpYi5TeXMuaW50X3NpemVcbmxldCBiaWdfZW5kaWFuID0gU3RkbGliLlN5cy5iaWdfZW5kaWFuXG5sZXQgbWF4X3N0cmluZ19sZW5ndGggPSBTdGRsaWIuU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgbWF4X2FycmF5X2xlbmd0aCA9IFN0ZGxpYi5TeXMubWF4X2FycmF5X2xlbmd0aFxubGV0IHJ1bnRpbWVfdmFyaWFudCA9IFN0ZGxpYi5TeXMucnVudGltZV92YXJpYW50XG5sZXQgcnVudGltZV9wYXJhbWV0ZXJzID0gU3RkbGliLlN5cy5ydW50aW1lX3BhcmFtZXRlcnNcbmxldCBhcmd2ID0gU3RkbGliLlN5cy5hcmd2XG5sZXQgZ2V0X2FyZ3YgKCkgPSBTdGRsaWIuU3lzLmFyZ3ZcbmxldCBvY2FtbF92ZXJzaW9uID0gU3RkbGliLlN5cy5vY2FtbF92ZXJzaW9uXG5sZXQgZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgPSBTdGRsaWIuU3lzLmVuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG5sZXQgcnVudGltZV93YXJuaW5nc19lbmFibGVkID0gU3RkbGliLlN5cy5ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcblxubW9kdWxlIE1ha2VfaW1tZWRpYXRlNjRcbiAgKEltbSA6IFN0ZGxpYi5TeXMuSW1tZWRpYXRlNjQuSW1tZWRpYXRlKVxuICAoTm9uX2ltbSA6IFN0ZGxpYi5TeXMuSW1tZWRpYXRlNjQuTm9uX2ltbWVkaWF0ZSkgPVxuICBTdGRsaWIuU3lzLkltbWVkaWF0ZTY0Lk1ha2UgKEltbSkgKE5vbl9pbW0pXG5cbmxldCBnZXRlbnZfZXhuIHZhciA9XG4gIHRyeSBTdGRsaWIuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IFN0ZGxpYi5Ob3RfZm91bmQgLT5cbiAgICBQcmludGYuZmFpbHdpdGhmIFwiU3lzLmdldGVudl9leG46IGVudmlyb25tZW50IHZhcmlhYmxlICVzIGlzIG5vdCBzZXRcIiB2YXIgKClcbjs7XG5cbmxldCBnZXRlbnYgdmFyID1cbiAgbWF0Y2ggU3RkbGliLlN5cy5nZXRlbnYgdmFyIHdpdGhcbiAgfCB4IC0+IFNvbWUgeFxuICB8IGV4Y2VwdGlvbiBTdGRsaWIuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmV4dGVybmFsIG9wYXF1ZV9pZGVudGl0eSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSA9IFwiJW9wYXF1ZVwiXG5leHRlcm5hbCBvcGFxdWVfaWRlbnRpdHlfZ2xvYmFsIDogJ2EgLT4gJ2EgPSBcIiVvcGFxdWVcIlxuXG5leGNlcHRpb24gQnJlYWsgPSBTdGRsaWIuU3lzLkJyZWFrXG4iLCIoKiBbQXJyYXkwXSBkZWZpbmVzIGFycmF5IGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpbiB0ZXJtc1xuICAgb2YgW1N0ZGxpYi5BcnJheV0uICBbQXJyYXkwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW1N0ZGxpYi5BcnJheV1cbiAgIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gYXJyYXkwLm1sIHNob3VsZCB1c2UgW1N0ZGxpYi5BcnJheV0uXG4gICBbQXJyYXkwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGxcbiAgIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBhcnJheXMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkFycmF5XSBpbiBidWlsZCBvcmRlciBzaG91bGRcbiAgIGRvIFttb2R1bGUgQXJyYXkgPSBBcnJheTBdLiAgVGhpcyBpbmNsdWRlcyB1c2VzIG9mIHN1YnNjcmlwdCBzeW50YXggKFt4LihpKV0sIFt4LihpKSA8LVxuICAgZV0pLCB3aGljaCB0aGUgT0NhbWwgcGFyc2VyIGRlc3VnYXJzIGludG8gY2FsbHMgdG8gW0FycmF5LmdldF0gYW5kIFtBcnJheS5zZXRdLlxuICAgRGVmaW5pbmcgW21vZHVsZSBBcnJheSA9IEFycmF5MF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tXG4gICBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5BcnJheV0uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBBcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlX2xvY2FsIDogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG4gIGV4dGVybmFsIGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG4gIGV4dGVybmFsIGdldCA6ICgnYSBhcnJheVtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6ICgnYSBhcnJheVtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlYXJyYXlfbGVuZ3RoXCJcblxuICBleHRlcm5hbCBzZXRcbiAgICA6ICAoJ2EgYXJyYXlbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAnYVxuICAgIC0+IHVuaXRcbiAgICA9IFwiJWFycmF5X3NhZmVfc2V0XCJcblxuICBleHRlcm5hbCB1bnNhZmVfZ2V0XG4gICAgOiAgKCdhIGFycmF5W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gJ2FcbiAgICA9IFwiJWFycmF5X3Vuc2FmZV9nZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRcbiAgICA6ICAoJ2EgYXJyYXlbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAnYVxuICAgIC0+IHVuaXRcbiAgICA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0XG4gICAgOiAgc3JjOignYSBhcnJheVtAbG9jYWxfb3B0XSlcbiAgICAtPiBzcmNfcG9zOmludFxuICAgIC0+IGRzdDooJ2EgYXJyYXlbQGxvY2FsX29wdF0pXG4gICAgLT4gZHN0X3BvczppbnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gdW5pdFxuICAgID0gXCJjYW1sX2FycmF5X2JsaXRcIlxuZW5kXG5cbmluY2x1ZGUgQXJyYXlcblxubGV0IG1heF9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aFxuXG5sZXQgY3JlYXRlIH5sZW4geCA9XG4gIHRyeSBjcmVhdGUgbGVuIHggd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBpbnZhbGlkX2FyZ2YgXCJBcnJheS5jcmVhdGUgfmxlbjolZDogaW52YWxpZCBsZW5ndGhcIiBsZW4gKClcbjs7XG5cbmxldCBjcmVhdGVfbG9jYWwgfmxlbiB4ID1cbiAgdHJ5IGNyZWF0ZV9sb2NhbCBsZW4geCB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IGludmFsaWRfYXJnZiBcIkFycmF5LmNyZWF0ZV9sb2NhbCB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIH5sZW4gPVxuICB0cnkgY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgbGVuIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT5cbiAgICBpbnZhbGlkX2FyZ2YgXCJBcnJheS5jcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGFwcGVuZCA9IFN0ZGxpYi5BcnJheS5hcHBlbmRcbmxldCBibGl0ID0gU3RkbGliLkFycmF5LmJsaXRcbmxldCBjb25jYXQgPSBTdGRsaWIuQXJyYXkuY29uY2F0XG5sZXQgY29weSA9IFN0ZGxpYi5BcnJheS5jb3B5XG5sZXQgZmlsbCA9IFN0ZGxpYi5BcnJheS5maWxsXG5cbmxldCBpbml0IGxlbiB+KGYgOiBfIC0+IF8pID1cbiAgaWYgbGVuID0gMFxuICB0aGVuIFt8fF1cbiAgZWxzZSBpZiBsZW4gPCAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5pbml0XCJcbiAgZWxzZSAoXG4gICAgbGV0IHJlcyA9IGNyZWF0ZSB+bGVuIChmIDApIGluXG4gICAgZm9yIGkgPSAxIHRvIEludDAucHJlZCBsZW4gZG9cbiAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICBkb25lO1xuICAgIHJlcylcbjs7XG5cbmxldCBtYWtlX21hdHJpeCA9IFN0ZGxpYi5BcnJheS5tYWtlX21hdHJpeFxubGV0IG9mX2xpc3QgPSBTdGRsaWIuQXJyYXkub2ZfbGlzdFxubGV0IHN1YiA9IFN0ZGxpYi5BcnJheS5zdWJcbmxldCB0b19saXN0ID0gU3RkbGliLkFycmF5LnRvX2xpc3RcblxubGV0IGZvbGQgdCB+aW5pdCB+KGYgOiBfIC0+IF8gLT4gXykgPVxuICBsZXQgciA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lO1xuICAhclxuOztcblxubGV0IGZvbGRfcmlnaHQgdCB+KGYgOiBfIC0+IF8gLT4gXykgfmluaXQgPVxuICBsZXQgciA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gbGVuZ3RoIHQgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IHQgaSkgIXJcbiAgZG9uZTtcbiAgIXJcbjs7XG5cbmxldCBpdGVyIHQgfihmIDogXyAtPiBfKSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBmICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIHQgfihmIDogXyAtPiBfIC0+IF8pID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmVcbjs7XG5cbmxldCBtYXAgdCB+KGYgOiBfIC0+IF8pID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbiA9IDBcbiAgdGhlbiBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCByID0gY3JlYXRlIH5sZW4gKGYgKHVuc2FmZV9nZXQgdCAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbGVuIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgdCBpKSlcbiAgICBkb25lO1xuICAgIHIpXG47O1xuXG5sZXQgbWFwaSB0IH4oZiA6IF8gLT4gXyAtPiBfKSA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICBpZiBsZW4gPSAwXG4gIHRoZW4gW3x8XVxuICBlbHNlIChcbiAgICBsZXQgciA9IGNyZWF0ZSB+bGVuIChmIDAgKHVuc2FmZV9nZXQgdCAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbGVuIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCB0IGkpKVxuICAgIGRvbmU7XG4gICAgcilcbjs7XG5cbmxldCBzdGFibGVfc29ydCB0IH5jb21wYXJlID0gU3RkbGliLkFycmF5LnN0YWJsZV9zb3J0IHQgfmNtcDpjb21wYXJlXG5cbmxldCBzd2FwIHQgaSBqID1cbiAgbGV0IGVsdF9pID0gdC4oaSkgaW5cbiAgbGV0IGVsdF9qID0gdC4oaikgaW5cbiAgdW5zYWZlX3NldCB0IGkgZWx0X2o7XG4gIHVuc2FmZV9zZXQgdCBqIGVsdF9pXG47O1xuIiwiKCogW0NoYXIwXSBkZWZpbmVzIGNoYXIgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICBbU3RkbGliLkNoYXJdLiAgW0NoYXIwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW1N0ZGxpYi5DaGFyXSB0aGF0XG4gICBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBjaGFyMC5tbCBzaG91bGQgdXNlIFtTdGRsaWIuQ2hhcl0uXG4gICBbQ2hhcjBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGNoYXJzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5DaGFyXSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cbiAgIFttb2R1bGUgQ2hhciA9IENoYXIwXS4gIERlZmluaW5nIFttb2R1bGUgQ2hhciA9IENoYXIwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0XG4gICBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkNoYXJdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbmxldCBmYWlsd2l0aGYgPSBQcmludGYuZmFpbHdpdGhmXG5sZXQgZXNjYXBlZCA9IFN0ZGxpYi5DaGFyLmVzY2FwZWRcbmxldCBsb3dlcmNhc2UgPSBTdGRsaWIuQ2hhci5sb3dlcmNhc2VfYXNjaWlcbmxldCB0b19pbnQgPSBTdGRsaWIuQ2hhci5jb2RlXG5sZXQgdW5zYWZlX29mX2ludCA9IFN0ZGxpYi5DaGFyLnVuc2FmZV9jaHJcbmxldCB1cHBlcmNhc2UgPSBTdGRsaWIuQ2hhci51cHBlcmNhc2VfYXNjaWlcblxuKCogV2UgdXNlIG91ciBvd24gcmFuZ2UgdGVzdCB3aGVuIGNvbnZlcnRpbmcgaW50ZWdlcnMgdG8gY2hhcnMgcmF0aGVyIHRoYW5cbiAgIGNhbGxpbmcgW1N0ZGxpYi5DaGFyLmNocl0gYmVjYXVzZSBpdCdzIHNpbXBsZSBhbmQgaXQgc2F2ZXMgdXMgYSBmdW5jdGlvbiBjYWxsXG4gICBhbmQgdGhlIHRyeS13aXRoIChleGNlcHRpb25zIGNvc3QsIGVzcGVjaWFsbHkgaW4gdGhlIHdvcmxkIHdpdGggYmFja3RyYWNlcykuICopXG5sZXQgaW50X2lzX29rIGkgPSAwIDw9IGkgJiYgaSA8PSAyNTVcbmxldCBtaW5fdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDBcbmxldCBtYXhfdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDI1NVxubGV0IG9mX2ludCBpID0gaWYgaW50X2lzX29rIGkgdGhlbiBTb21lICh1bnNhZmVfb2ZfaW50IGkpIGVsc2UgTm9uZVxuXG5sZXQgb2ZfaW50X2V4biBpID1cbiAgaWYgaW50X2lzX29rIGlcbiAgdGhlbiB1bnNhZmVfb2ZfaW50IGlcbiAgZWxzZSBmYWlsd2l0aGYgXCJDaGFyLm9mX2ludF9leG4gZ290IGludGVnZXIgb3V0IG9mIHJhbmdlOiAlZFwiIGkgKClcbjs7XG5cbmxldCBlcXVhbCAodDEgOiBjaGFyKSB0MiA9IFBvbHkuZXF1YWwgdDEgdDJcbiIsIigqIFtMaXN0MF0gZGVmaW5lcyBsaXN0IGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpbiB0ZXJtcyBvZlxuICAgW1N0ZGxpYi5MaXN0XS4gIFtMaXN0MF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtTdGRsaWIuTGlzdF0gdGhhdFxuICAgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gbGlzdDAubWwgc2hvdWxkIHVzZSBbU3RkbGliLkxpc3RdLlxuICAgW0xpc3QwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGxcbiAgIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBsaXN0cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuTGlzdF0gaW4gYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG4gICBbbW9kdWxlIExpc3QgPSBMaXN0MF0uICBEZWZpbmluZyBbbW9kdWxlIExpc3QgPSBMaXN0MF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdFxuICAgcHJldmVudHMgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5MaXN0XS4gKilcblxub3BlbiEgSW1wb3J0MFxuXG5sZXQgaGRfZXhuID0gU3RkbGliLkxpc3QuaGRcbmxldCByZXZfYXBwZW5kID0gU3RkbGliLkxpc3QucmV2X2FwcGVuZFxubGV0IHRsX2V4biA9IFN0ZGxpYi5MaXN0LnRsXG5sZXQgdW56aXAgPSBTdGRsaWIuTGlzdC5zcGxpdFxuXG4oKiBTb21lIG9mIHRoZXNlIGFyZSBldGEgZXhwYW5kZWQgaW4gb3JkZXIgdG8gcGVybXV0ZSBwYXJhbWV0ZXIgb3JkZXIgdG8gZm9sbG93IEJhc2VcbiAgIGNvbnZlbnRpb25zLiAqKVxuXG5sZXQgbGVuZ3RoID1cbiAgbGV0IHJlYyBsZW5ndGhfYXV4IGxlbiA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBsZW5cbiAgICB8IF8gOjogbCAtPiBsZW5ndGhfYXV4IChsZW4gKyAxKSBsXG4gIGluXG4gIGZ1biBsIC0+IGxlbmd0aF9hdXggMCBsXG47O1xuXG5sZXQgcmVjIGV4aXN0cyB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gZmFsc2VcbiAgfCB4IDo6IHhzIC0+IGlmIGYgeCB0aGVuIHRydWUgZWxzZSBleGlzdHMgeHMgfmZcbjs7XG5cbmxldCByZWMgZXhpc3RzMl9vayBsMSBsMiB+KGYgOiBfIC0+IF8gLT4gXykgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiBmYWxzZVxuICB8IGExIDo6IGwxLCBhMiA6OiBsMiAtPiBmIGExIGEyIHx8IGV4aXN0czJfb2sgbDEgbDIgfmZcbiAgfCBfLCBfIC0+IGludmFsaWRfYXJnIFwiTGlzdC5leGlzdHMyXCJcbjs7XG5cbmxldCByZWMgZm9sZCB0IH5pbml0IH4oZiA6IF8gLT4gXyAtPiBfKSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IGluaXRcbiAgfCBhIDo6IGwgLT4gZm9sZCBsIH5pbml0OihmIGluaXQgYSkgfmZcbjs7XG5cbmxldCByZWMgZm9sZDJfb2sgbDEgbDIgfmluaXQgfihmIDogXyAtPiBfIC0+IF8gLT4gXykgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiBpbml0XG4gIHwgYTEgOjogbDEsIGEyIDo6IGwyIC0+IGZvbGQyX29rIGwxIGwyIH5mIH5pbml0OihmIGluaXQgYTEgYTIpXG4gIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9sZWZ0MlwiXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID0gbm90IChleGlzdHMgdCB+ZjooZnVuIHggLT4gbm90IChmIHgpKSlcblxubGV0IHJlYyBmb3JfYWxsMl9vayBsMSBsMiB+KGYgOiBfIC0+IF8gLT4gXykgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiB0cnVlXG4gIHwgYTEgOjogbDEsIGEyIDo6IGwyIC0+IGYgYTEgYTIgJiYgZm9yX2FsbDJfb2sgbDEgbDIgfmZcbiAgfCBfLCBfIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb3JfYWxsMlwiXG47O1xuXG5sZXQgcmVjIGl0ZXIgdCB+KGYgOiBfIC0+IF8pID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCBhIDo6IGwgLT5cbiAgICBmIGE7XG4gICAgaXRlciBsIH5mXG47O1xuXG5sZXQgcmVjIGl0ZXIyX29rIGwxIGwyIH4oZiA6IF8gLT4gXyAtPiB1bml0KSA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+ICgpXG4gIHwgYTEgOjogbDEsIGEyIDo6IGwyIC0+XG4gICAgZiBhMSBhMjtcbiAgICBpdGVyMl9vayBsMSBsMiB+ZlxuICB8IF8sIF8gLT4gaW52YWxpZF9hcmcgXCJMaXN0Lml0ZXIyXCJcbjs7XG5cbmxldCByZWMgbm9udGFpbF9tYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgeCA6OiB4cyAtPlxuICAgIGxldCB5ID0gZiB4IGluXG4gICAgeSA6OiBub250YWlsX21hcCB4cyB+ZlxuOztcblxubGV0IG5vbnRhaWxfbWFwaSB0IH5mID0gU3RkbGliLkxpc3QubWFwaSB0IH5mXG5sZXQgcGFydGl0aW9uIHQgfmYgPSBTdGRsaWIuTGlzdC5wYXJ0aXRpb24gdCB+ZlxuXG5sZXQgcmV2X21hcCA9XG4gIGxldCByZWMgcm1hcF9mIGYgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCBhIDo6IGwgLT4gcm1hcF9mIGYgKGYgYSA6OiBhY2N1KSBsXG4gIGluXG4gIGZ1biBsIH5mIC0+IHJtYXBfZiBmIFtdIGxcbjs7XG5cbmxldCByZXZfbWFwMl9vayA9XG4gIGxldCByZWMgcm1hcDJfZiBmIGFjY3UgbDEgbDIgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgW10gLT4gYWNjdVxuICAgIHwgYTEgOjogbDEsIGEyIDo6IGwyIC0+IHJtYXAyX2YgZiAoZiBhMSBhMiA6OiBhY2N1KSBsMSBsMlxuICAgIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmV2X21hcDJcIlxuICBpblxuICBmdW4gbDEgbDIgfihmIDogXyAtPiBfIC0+IF8pIC0+IHJtYXAyX2YgZiBbXSBsMSBsMlxuOztcblxubGV0IHJldiA9IGZ1bmN0aW9uXG4gIHwgKFtdIHwgWyBfIF0pIGFzIHJlcyAtPiByZXNcbiAgfCB4IDo6IHkgOjogcmVzdCAtPiByZXZfYXBwZW5kIHJlc3QgWyB5OyB4IF1cbjs7XG5cbmxldCBmb2xkX3JpZ2h0IGwgfihmIDogXyAtPiBfIC0+IF8pIH5pbml0ID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gaW5pdCAoKiBhdm9pZCB0aGUgYWxsb2NhdGlvbiBvZiBbfmZdIGJlbG93ICopXG4gIHwgXyAtPiBmb2xkIH5mOihmdW4gYSBiIC0+IGYgYiBhKSB+aW5pdCAocmV2IGwpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX3JpZ2h0Ml9vayBsMSBsMiB+KGYgOiBfIC0+IF8gLT4gXyAtPiBfKSB+aW5pdCA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IGluaXQgKCogYXZvaWQgdGhlIGFsbG9jYXRpb24gb2YgW35mXSBiZWxvdyAqKVxuICB8IF8sIF8gLT4gZm9sZDJfb2sgfmY6KGZ1biBhIGIgYyAtPiBmIGIgYyBhKSB+aW5pdCAocmV2IGwxKSAocmV2IGwyKSBbQG5vbnRhaWxdXG47O1xuIiwiKCpcbiAgIFRoaXMgaXMgdGhlIGludGVyZmFjZSB0byB0aGUgcnVudGltZSBzdXBwb3J0IGZvciBbcHB4X2hhc2hdLlxuXG4gICBUaGUgW3BweF9oYXNoXSBzeW50YXggZXh0ZW5zaW9uIHN1cHBvcnRzOiBbQEBkZXJpdmluZyBoYXNoXSBhbmQgWyVoYXNoX2ZvbGQ6IFRZUEVdIGFuZFxuICAgWyVoYXNoOiBUWVBFXVxuXG4gICBGb3IgdHlwZSBbdF0gYSBmdW5jdGlvbiBbaGFzaF9mb2xkX3RdIG9mIHR5cGUgW0hhc2guc3RhdGUgLT4gdCAtPiBIYXNoLnN0YXRlXSBpc1xuICAgZ2VuZXJhdGVkLlxuXG4gICBUaGUgZ2VuZXJhdGVkIFtoYXNoX2ZvbGRfPFQ+XSBmdW5jdGlvbiBpcyBjb21wb3NpdGlvbmFsLCBmb2xsb3dpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGVcbiAgIHR5cGU7IGFsbG93aW5nIHVzZXIgb3ZlcnJpZGVzIGF0IGV2ZXJ5IGxldmVsLiBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIG9jYW1sJ3MgYnVpbHRpblxuICAgcG9seW1vcnBoaWMgaGFzaGluZyBbSGFzaHRibC5oYXNoXSB3aGljaCBpZ25vcmVzIHVzZXIgb3ZlcnJpZGVzLlxuXG4gICBUaGUgZ2VuZXJhdG9yIGFsc28gcHJvdmlkZXMgYSBkaXJlY3QgaGFzaC1mdW5jdGlvbiBbaGFzaF0gKG5hbWVkIFtoYXNoXzxUPl0gd2hlbiA8VD4gIT1cbiAgIFwidFwiKSBvZiB0eXBlOiBbdCAtPiBIYXNoLmhhc2hfdmFsdWVdLlxuXG4gICBUaGUgZm9sZGluZyBoYXNoIGZ1bmN0aW9uIGNhbiBiZSBhY2Nlc3NlZCBhcyBbJWhhc2hfZm9sZDogVFlQRV1cbiAgIFRoZSBkaXJlY3QgaGFzaCBmdW5jdGlvbiBjYW4gYmUgYWNjZXNzZWQgYXMgWyVoYXNoOiBUWVBFXVxuKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgQ2hhciA9IENoYXIwXG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBIYXNoX2ludGZcblxuKCoqIEJ1aWx0aW4gZm9sZGluZy1zdHlsZSBoYXNoIGZ1bmN0aW9ucywgYWJzdHJhY3RlZCBvdmVyIFtIYXNoX2ludGYuU10gKilcbm1vZHVsZSBGb2xkaW5nIChIYXNoIDogSGFzaF9pbnRmLlMpIDpcbiAgSGFzaF9pbnRmLkJ1aWx0aW5faW50ZlxuICAgIHdpdGggdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgICAgYW5kIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZSA9IHN0cnVjdFxuICB0eXBlIHN0YXRlID0gSGFzaC5zdGF0ZVxuICB0eXBlIGhhc2hfdmFsdWUgPSBIYXNoLmhhc2hfdmFsdWVcbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBoYXNoX2ZvbGRfdW5pdCBzICgpID0gc1xuICBsZXQgaGFzaF9mb2xkX2ludCA9IEhhc2guZm9sZF9pbnRcbiAgbGV0IGhhc2hfZm9sZF9pbnQ2NCA9IEhhc2guZm9sZF9pbnQ2NFxuICBsZXQgaGFzaF9mb2xkX2Zsb2F0ID0gSGFzaC5mb2xkX2Zsb2F0XG4gIGxldCBoYXNoX2ZvbGRfc3RyaW5nID0gSGFzaC5mb2xkX3N0cmluZ1xuICBsZXQgYXNfaW50IGYgcyB4ID0gaGFzaF9mb2xkX2ludCBzIChmIHgpXG5cbiAgKCogVGhpcyBpZ25vcmVzIHRoZSBzaWduIGJpdCBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgdW5saWtlbHkgdG8gbGVhZCB0b1xuICAgICBmcmVxdWVudCBjb2xsaXNpb25zIChtaW5fdmFsdWUgY29sbGlkaW5nIHdpdGggMCBpcyB0aGUgbW9zdCBsaWtlbHkgb25lKS4gICopXG4gIGxldCBoYXNoX2ZvbGRfaW50MzIgPSBhc19pbnQgU3RkbGliLkludDMyLnRvX2ludFxuICBsZXQgaGFzaF9mb2xkX2NoYXIgPSBhc19pbnQgQ2hhci50b19pbnRcblxuICBsZXQgaGFzaF9mb2xkX2Jvb2wgPVxuICAgIGFzX2ludCAoZnVuY3Rpb25cbiAgICAgIHwgdHJ1ZSAtPiAxXG4gICAgICB8IGZhbHNlIC0+IDApXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9uYXRpdmVpbnQgcyB4ID0gaGFzaF9mb2xkX2ludDY0IHMgKFN0ZGxpYi5JbnQ2NC5vZl9uYXRpdmVpbnQgeClcblxuICBsZXQgaGFzaF9mb2xkX29wdGlvbiBoYXNoX2ZvbGRfZWxlbSBzID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gaGFzaF9mb2xkX2ludCBzIDBcbiAgICB8IFNvbWUgeCAtPiBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2ludCBzIDEpIHhcbiAgOztcblxuICBsZXQgcmVjIGhhc2hfZm9sZF9saXN0X2JvZHkgaGFzaF9mb2xkX2VsZW0gcyBsaXN0ID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IHNcbiAgICB8IHggOjogeHMgLT4gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2VsZW0gcyB4KSB4c1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfbGlzdCBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgPVxuICAgICgqIFRoZSBbbGVuZ3RoXSBvZiB0aGUgbGlzdCBtdXN0IGJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBoYXNoLXN0YXRlIHNvIHZhbHVlcyBvZlxuICAgICAgIHR5cGVzIHN1Y2ggYXMgW3VuaXQgbGlzdF0gLSAoW10sIFsoKV0sIFsoKTsoKV0sLi4pIGFyZSBoYXNoZWQgZGlmZmVyZW50bHkuICopXG4gICAgKCogVGhlIFtsZW5ndGhdIG11c3QgY29tZSBiZWZvcmUgdGhlIGVsZW1lbnRzIHRvIGF2b2lkIGEgdmlvbGF0aW9uIG9mIHRoZSBydWxlXG4gICAgICAgZW5mb3JjZWQgYnkgUGVyZmVjdF9oYXNoLiAqKVxuICAgIGxldCBzID0gaGFzaF9mb2xkX2ludCBzIChMaXN0Lmxlbmd0aCBsaXN0KSBpblxuICAgIGxldCBzID0gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgaW5cbiAgICBzXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9sYXp5X3QgaGFzaF9mb2xkX2VsZW0gcyB4ID0gaGFzaF9mb2xkX2VsZW0gcyAoU3RkbGliLkxhenkuZm9yY2UgeClcbiAgbGV0IGhhc2hfZm9sZF9yZWZfZnJvemVuIGhhc2hfZm9sZF9lbGVtIHMgeCA9IGhhc2hfZm9sZF9lbGVtIHMgIXhcblxuICBsZXQgcmVjIGhhc2hfZm9sZF9hcnJheV9mcm96ZW5faSBoYXNoX2ZvbGRfZWxlbSBzIGFycmF5IGkgPVxuICAgIGlmIGkgPSBBcnJheS5sZW5ndGggYXJyYXlcbiAgICB0aGVuIHNcbiAgICBlbHNlIChcbiAgICAgIGxldCBlID0gQXJyYXkudW5zYWZlX2dldCBhcnJheSBpIGluXG4gICAgICBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuX2kgaGFzaF9mb2xkX2VsZW0gKGhhc2hfZm9sZF9lbGVtIHMgZSkgYXJyYXkgKGkgKyAxKSlcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2FycmF5X2Zyb3plbiBoYXNoX2ZvbGRfZWxlbSBzIGFycmF5ID1cbiAgICBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuX2lcbiAgICAgICgqIFtsZW5ndGhdIG11c3QgYmUgaW5jb3Jwb3JhdGVkIGZvciBhcnJheXMsIGFzIGl0IGlzIGZvciBsaXN0cy4gU2VlIGNvbW1lbnQgYWJvdmUgKilcbiAgICAgIGhhc2hfZm9sZF9lbGVtXG4gICAgICAoaGFzaF9mb2xkX2ludCBzIChBcnJheS5sZW5ndGggYXJyYXkpKVxuICAgICAgYXJyYXlcbiAgICAgIDBcbiAgOztcblxuICAoKiB0aGUgZHVwbGljYXRpb24gaGVyZSBpcyBiZWNhdXNlIHdlIHRoaW5rXG4gICAgIG9jYW1sIGNhbid0IGVsaW1pbmF0ZSBpbmRpcmVjdCBmdW5jdGlvbiBjYWxscyBvdGhlcndpc2UuICopXG4gIGxldCBoYXNoX25hdGl2ZWludCB4ID1cbiAgICBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfbmF0aXZlaW50IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgOztcblxuICBsZXQgaGFzaF9pbnQ2NCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2ludDY0IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfaW50MzIgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9pbnQzMiAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2NoYXIgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9jaGFyIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfaW50IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfaW50IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfYm9vbCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2Jvb2wgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuXG4gIGxldCBoYXNoX3N0cmluZyB4ID1cbiAgICBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfc3RyaW5nIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgOztcblxuICBsZXQgaGFzaF9mbG9hdCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2Zsb2F0IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfdW5pdCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3VuaXQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuZW5kXG5cbm1vZHVsZSBGIChIYXNoIDogSGFzaF9pbnRmLlMpIDpcbiAgSGFzaF9pbnRmLkZ1bGxcbiAgICB3aXRoIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZVxuICAgICBhbmQgdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgICAgYW5kIHR5cGUgc2VlZCA9IEhhc2guc2VlZCA9IHN0cnVjdFxuICBpbmNsdWRlIEhhc2hcblxuICB0eXBlICdhIGZvbGRlciA9IHN0YXRlIC0+ICdhIC0+IHN0YXRlXG5cbiAgbGV0IGNyZWF0ZSA/c2VlZCAoKSA9IHJlc2V0ID9zZWVkIChhbGxvYyAoKSlcbiAgbGV0IG9mX2ZvbGQgaGFzaF9mb2xkX3QgdCA9IGdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfdCAoY3JlYXRlICgpKSB0KVxuXG4gIG1vZHVsZSBCdWlsdGluID0gRm9sZGluZyAoSGFzaClcblxuICBsZXQgcnVuID9zZWVkIGZvbGRlciB4ID1cbiAgICBIYXNoLmdldF9oYXNoX3ZhbHVlIChmb2xkZXIgKEhhc2gucmVzZXQgP3NlZWQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBJbnRlcm5hbGhhc2ggOiBzaWdcbiAgaW5jbHVkZVxuICAgIEhhc2hfaW50Zi5TXG4gICAgICB3aXRoIHR5cGUgc3RhdGUgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5zdGF0ZVxuICAgICAgKCogV2UgZ2l2ZSBhIGNvbmNyZXRlIHR5cGUgZm9yIFtzdGF0ZV0sIGFsYmVpdCBvbmx5IHBhcnRpYWxseSBleHBvc2VkIChzZWVcbiAgICAgICAgQmFzZV9pbnRlcm5hbGhhc2hfdHlwZXMpLCBzbyB0aGF0IGl0IHVuaWZpZXMgd2l0aCB0aGUgc2FtZSB0eXBlIGluIFtCYXNlX2Jvb3RdLFxuICAgICAgICBhbmQgdG8gYWxsb3cgb3B0aW1pemF0aW9ucyBmb3IgdGhlIGltbWVkaWF0ZSB0eXBlLiAqKVxuICAgICAgIGFuZCB0eXBlIHNlZWQgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5zZWVkXG4gICAgICAgYW5kIHR5cGUgaGFzaF92YWx1ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLmhhc2hfdmFsdWVcblxuICBleHRlcm5hbCBmb2xkX2ludDY0XG4gICAgOiAgc3RhdGVcbiAgICAtPiAoaW50NjRbQHVuYm94ZWRdKVxuICAgIC0+IHN0YXRlXG4gICAgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjRcIiBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjRfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBmb2xkX2ludCA6IHN0YXRlIC0+IGludCAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnRcIiBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfZmxvYXRcbiAgICA6ICBzdGF0ZVxuICAgIC0+IChmbG9hdFtAdW5ib3hlZF0pXG4gICAgLT4gc3RhdGVcbiAgICA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdFwiIFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdF91bmJveGVkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfc3RyaW5nIDogc3RhdGUgLT4gc3RyaW5nIC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX3N0cmluZ1wiXG4gICAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBnZXRfaGFzaF92YWx1ZSA6IHN0YXRlIC0+IGhhc2hfdmFsdWUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2dldF9oYXNoX3ZhbHVlXCJcbiAgICBbQEBub2FsbG9jXVxuZW5kID0gc3RydWN0XG4gIGxldCBkZXNjcmlwdGlvbiA9IFwiaW50ZXJuYWxoYXNoXCJcblxuICBpbmNsdWRlIEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzXG5cbiAgbGV0IGFsbG9jICgpID0gY3JlYXRlX3NlZWRlZCAwXG4gIGxldCByZXNldCA/KHNlZWQgPSAwKSBfdCA9IGNyZWF0ZV9zZWVkZWQgc2VlZFxuXG4gIG1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcGFyZV9zdGF0ZSAoYSA6IHN0YXRlKSAoYiA6IHN0YXRlKSA9IGNvbXBhcmUgKGEgOj4gaW50KSAoYiA6PiBpbnQpXG4gICAgbGV0IHN0YXRlX3RvX3N0cmluZyAoc3RhdGUgOiBzdGF0ZSkgPSBJbnQudG9fc3RyaW5nIChzdGF0ZSA6PiBpbnQpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIGluY2x1ZGUgSW50ZXJuYWxoYXNoXG5cbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgP3NlZWQgKCkgPSByZXNldCA/c2VlZCAoYWxsb2MgKCkpXG4gIGxldCBydW4gP3NlZWQgZm9sZGVyIHggPSBnZXRfaGFzaF92YWx1ZSAoZm9sZGVyIChyZXNldCA/c2VlZCAoYWxsb2MgKCkpKSB4KVxuICBsZXQgb2ZfZm9sZCBoYXNoX2ZvbGRfdCB0ID0gZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF90IChjcmVhdGUgKCkpIHQpXG5cbiAgbW9kdWxlIEJ1aWx0aW4gPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRm9sZGluZyA9IEZvbGRpbmcgKEludGVybmFsaGFzaClcbiAgICBpbmNsdWRlIEZvbGRpbmdcblxuICAgICgqIFtGb2xkaW5nXSBwcm92aWRlcyBzb21lIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIGZvciB0aGUgW2hhc2hfKl0gZnVuY3Rpb25zIGJlbG93LFxuICAgICAgIGJ1dCB0aGV5IGFyZSBpbmVmZmljaWVudCBmb3Igc29tZSB1c2UtY2FzZXMgYmVjYXVzZSBvZiB0aGUgdXNlIG9mIHRoZSBbaGFzaF9mb2xkXVxuICAgICAgIGZ1bmN0aW9ucy4gQXQgdGhpcyBwb2ludCwgdGhlIFtoYXNoX3ZhbHVlXSB0eXBlIGhhcyBiZWVuIGZpeGVkIHRvIFtpbnRdLCBzbyB0aGlzXG4gICAgICAgbW9kdWxlIGNhbiBwcm92aWRlIHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9ucy4gKilcblxuICAgIGxldCBoYXNoX2NoYXIgPSBDaGFyMC50b19pbnRcblxuICAgICgqIFRoaXMgaGFzaCB3YXMgY2hvc2VuIGZyb20gaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFkYm95LzYyNjc3NDNcblxuICAgICAgIEl0IGF0dGVtcHRzIHRvIGZ1bGZpbGwgdGhlIHByaW1hcnkgZ29hbHMgb2YgYSBub24tY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uOlxuXG4gICAgICAgLSBhIGJpdCBjaGFuZ2UgaW4gdGhlIGlucHV0IHNob3VsZCBjaGFuZ2UgfjEvMiBvZiB0aGUgb3V0cHV0IGJpdHNcbiAgICAgICAtIHRoZSBvdXRwdXQgc2hvdWxkIGJlIHVuaWZvcm1seSBkaXN0cmlidXRlZCBhY3Jvc3MgdGhlIG91dHB1dCByYW5nZVxuICAgICAgIC0gaW5wdXRzIHRoYXQgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXIgc2hvdWxkbid0IGxlYWQgdG8gb3V0cHV0cyB0aGF0IGFyZSBjbG9zZSB0b1xuICAgICAgICAgZWFjaCBvdGhlci5cbiAgICAgICAtIGFsbCBiaXRzIG9mIHRoZSBpbnB1dCBhcmUgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBvdXRwdXRcblxuICAgICAgIEluIG91ciBjYXNlIHdlIGFsc28gd2FudCBpdCB0byBiZSBmYXN0LCBub24tYWxsb2NhdGluZywgYW5kIGlubGluYWJsZS4gICopXG4gICAgbGV0W0BpbmxpbmUgYWx3YXlzXSBoYXNoX2ludCAodCA6IGludCkgPVxuICAgICAgbGV0IHQgPSBsbm90IHQgKyAodCBsc2wgMjEpIGluXG4gICAgICBsZXQgdCA9IHQgbHhvciAodCBsc3IgMjQpIGluXG4gICAgICBsZXQgdCA9IHQgKyAodCBsc2wgMykgKyAodCBsc2wgOCkgaW5cbiAgICAgIGxldCB0ID0gdCBseG9yICh0IGxzciAxNCkgaW5cbiAgICAgIGxldCB0ID0gdCArICh0IGxzbCAyKSArICh0IGxzbCA0KSBpblxuICAgICAgbGV0IHQgPSB0IGx4b3IgKHQgbHNyIDI4KSBpblxuICAgICAgdCArICh0IGxzbCAzMSlcbiAgICA7O1xuXG4gICAgbGV0IGhhc2hfYm9vbCB4ID0gaWYgeCB0aGVuIDEgZWxzZSAwXG5cbiAgICBleHRlcm5hbCBoYXNoX2Zsb2F0XG4gICAgICA6ICAoZmxvYXRbQHVuYm94ZWRdKVxuICAgICAgLT4gaW50XG4gICAgICA9IFwiQmFzZV9oYXNoX2RvdWJsZVwiIFwiQmFzZV9oYXNoX2RvdWJsZV91bmJveGVkXCJcbiAgICAgIFtAQG5vYWxsb2NdXG5cbiAgICBsZXQgaGFzaF91bml0ICgpID0gMFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIFRcbiIsIm9wZW4gSW1wb3J0MFxuXG5sZXQgY29tcGFyZV9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJDb21wYXJlIGNhbGxlZCBvbiB0aGUgdHlwZSAlcywgd2hpY2ggaXMgYWJzdHJhY3QgaW4gYW4gaW1wbGVtZW50YXRpb24uXCJcbiAgICB0eXBlX25hbWVcbjs7XG5cbmxldCBlcXVhbF9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJFcXVhbCBjYWxsZWQgb24gdGhlIHR5cGUgJXMsIHdoaWNoIGlzIGFic3RyYWN0IGluIGFuIGltcGxlbWVudGF0aW9uLlwiXG4gICAgdHlwZV9uYW1lXG47O1xuXG50eXBlICdhIGNvbXBhcmUgPSAnYSAtPiAnYSAtPiBpbnRcbnR5cGUgJ2EgY29tcGFyZV9fbG9jYWwgPSAnYSAtPiAnYSAtPiBpbnRcbnR5cGUgJ2EgZXF1YWwgPSAnYSAtPiAnYSAtPiBib29sXG50eXBlICdhIGVxdWFsX19sb2NhbCA9ICdhIC0+ICdhIC0+IGJvb2xcblxubW9kdWxlIENvbXBhcmFibGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiB0IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgY29tcGFyZSAtPiAnYSB0IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgY29tcGFyZSAtPiAnYiBjb21wYXJlIC0+ICgnYSwgJ2IpIHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgY29tcGFyZSAtPiAnYiBjb21wYXJlIC0+ICdjIGNvbXBhcmUgLT4gKCdhLCAnYiwgJ2MpIHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTX2xvY2FsID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY29tcGFyZV9fbG9jYWwgOiB0IGNvbXBhcmVfX2xvY2FsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFNfbG9jYWwxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgY29tcGFyZV9fbG9jYWwgOiAnYSBjb21wYXJlX19sb2NhbCAtPiAnYSB0IGNvbXBhcmVfX2xvY2FsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFNfbG9jYWwyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcGFyZV9fbG9jYWxcbiAgICAgIDogICdhIGNvbXBhcmVfX2xvY2FsXG4gICAgICAtPiAnYiBjb21wYXJlX19sb2NhbFxuICAgICAgLT4gKCdhLCAnYikgdCBjb21wYXJlX19sb2NhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTX2xvY2FsMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wYXJlX19sb2NhbFxuICAgICAgOiAgJ2EgY29tcGFyZV9fbG9jYWxcbiAgICAgIC0+ICdiIGNvbXBhcmVfX2xvY2FsXG4gICAgICAtPiAnYyBjb21wYXJlX19sb2NhbFxuICAgICAgLT4gKCdhLCAnYiwgJ2MpIHQgY29tcGFyZV9fbG9jYWxcbiAgZW5kXG5lbmRcblxubW9kdWxlIEVxdWFsID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbCA6IHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdhIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdiIGVxdWFsIC0+ICgnYSwgJ2IpIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgZXF1YWwgOiAnYSBlcXVhbCAtPiAnYiBlcXVhbCAtPiAnYyBlcXVhbCAtPiAoJ2EsICdiLCAnYykgdCBlcXVhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTX2xvY2FsID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgZXF1YWxfX2xvY2FsIDogdCBlcXVhbF9fbG9jYWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgU19sb2NhbDEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBlcXVhbF9fbG9jYWwgOiAnYSBlcXVhbF9fbG9jYWwgLT4gJ2EgdCBlcXVhbF9fbG9jYWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgU19sb2NhbDIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBlcXVhbF9fbG9jYWwgOiAnYSBlcXVhbF9fbG9jYWwgLT4gJ2IgZXF1YWxfX2xvY2FsIC0+ICgnYSwgJ2IpIHQgZXF1YWxfX2xvY2FsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFNfbG9jYWwzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGVxdWFsX19sb2NhbFxuICAgICAgOiAgJ2EgZXF1YWxfX2xvY2FsXG4gICAgICAtPiAnYiBlcXVhbF9fbG9jYWxcbiAgICAgIC0+ICdjIGVxdWFsX19sb2NhbFxuICAgICAgLT4gKCdhLCAnYiwgJ2MpIHQgZXF1YWxfX2xvY2FsXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBCdWlsdGluID0gc3RydWN0XG4gIGxldCBjb21wYXJlX2Jvb2wgOiBib29sIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfYm9vbF9fbG9jYWwgOiBib29sIGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2NoYXIgOiBjaGFyIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfY2hhcl9fbG9jYWwgOiBjaGFyIGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2Zsb2F0IDogZmxvYXQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9mbG9hdF9fbG9jYWwgOiBmbG9hdCBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQgOiBpbnQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnRfX2xvY2FsIDogaW50IGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludDMyIDogaW50MzIgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQzMl9fbG9jYWwgOiBpbnQzMiBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQ2NCA6IGludDY0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfaW50NjRfX2xvY2FsIDogaW50NjQgY29tcGFyZV9fbG9jYWwgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50IDogbmF0aXZlaW50IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50X19sb2NhbCA6IG5hdGl2ZWludCBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9zdHJpbmcgOiBzdHJpbmcgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9zdHJpbmdfX2xvY2FsIDogc3RyaW5nIGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2J5dGVzIDogYnl0ZXMgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9ieXRlc19fbG9jYWwgOiBieXRlcyBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV91bml0IDogdW5pdCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX3VuaXRfX2xvY2FsIDogdW5pdCBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuXG4gIGxldCBjb21wYXJlX2FycmF5X19sb2NhbCBjb21wYXJlX2VsdCBhIGIgPVxuICAgIGlmIHBoeXNfZXF1YWwgYSBiXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbGVuX2EgPSBBcnJheTAubGVuZ3RoIGEgaW5cbiAgICAgIGxldCBsZW5fYiA9IEFycmF5MC5sZW5ndGggYiBpblxuICAgICAgbGV0IHJldCA9IGNvbXBhcmUgbGVuX2EgbGVuX2IgaW5cbiAgICAgIGlmIHJldCA8PiAwXG4gICAgICB0aGVuIHJldFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgICAgICBpZiBpID0gbGVuX2FcbiAgICAgICAgICB0aGVuIDBcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBsID0gQXJyYXkwLnVuc2FmZV9nZXQgYSBpXG4gICAgICAgICAgICBhbmQgciA9IEFycmF5MC51bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgICAgICAgbGV0IHJlcyA9IGNvbXBhcmVfZWx0IGwgciBpblxuICAgICAgICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBsb29wIChpICsgMSkpXG4gICAgICAgIGluXG4gICAgICAgIGxvb3AgMCBbQG5vbnRhaWxdKSlcbiAgOztcblxuICBsZXQgY29tcGFyZV9hcnJheSBjb21wYXJlX2VsdCBhIGIgPSBjb21wYXJlX2FycmF5X19sb2NhbCBjb21wYXJlX2VsdCBhIGJcblxuICBsZXQgcmVjIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IDBcbiAgICB8IFtdLCBfIC0+IC0xXG4gICAgfCBfLCBbXSAtPiAxXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgeCB5IGluXG4gICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCB4cyB5c1xuICA7O1xuXG4gIGxldCByZWMgY29tcGFyZV9saXN0X19sb2NhbCBjb21wYXJlX2VsdF9fbG9jYWwgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IFtdLCBbXSAtPiAwXG4gICAgfCBbXSwgXyAtPiAtMVxuICAgIHwgXywgW10gLT4gMVxuICAgIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgICAgbGV0IHJlcyA9IGNvbXBhcmVfZWx0X19sb2NhbCB4IHkgaW5cbiAgICAgIGlmIHJlcyA8PiAwIHRoZW4gcmVzIGVsc2UgY29tcGFyZV9saXN0X19sb2NhbCBjb21wYXJlX2VsdF9fbG9jYWwgeHMgeXNcbiAgOztcblxuICBsZXQgY29tcGFyZV9vcHRpb24gY29tcGFyZV9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gMFxuICAgIHwgTm9uZSwgU29tZSBfIC0+IC0xXG4gICAgfCBTb21lIF8sIE5vbmUgLT4gMVxuICAgIHwgU29tZSBhLCBTb21lIGIgLT4gY29tcGFyZV9lbHQgYSBiXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfb3B0aW9uX19sb2NhbCBjb21wYXJlX2VsdF9fbG9jYWwgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gMFxuICAgIHwgTm9uZSwgU29tZSBfIC0+IC0xXG4gICAgfCBTb21lIF8sIE5vbmUgLT4gMVxuICAgIHwgU29tZSBhLCBTb21lIGIgLT4gY29tcGFyZV9lbHRfX2xvY2FsIGEgYlxuICA7O1xuXG4gIGxldCBjb21wYXJlX3JlZiBjb21wYXJlX2VsdCBhIGIgPSBjb21wYXJlX2VsdCAhYSAhYlxuICBsZXQgY29tcGFyZV9yZWZfX2xvY2FsIGNvbXBhcmVfZWx0IGEgYiA9IGNvbXBhcmVfZWx0ICFhICFiXG4gIGxldCBlcXVhbF9ib29sIDogYm9vbCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2Jvb2xfX2xvY2FsIDogYm9vbCBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9jaGFyIDogY2hhciBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2NoYXJfX2xvY2FsIDogY2hhciBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQgOiBpbnQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnRfX2xvY2FsIDogaW50IGVxdWFsX19sb2NhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2ludDMyIDogaW50MzIgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQzMl9fbG9jYWwgOiBpbnQzMiBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQ2NCA6IGludDY0IGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50NjRfX2xvY2FsIDogaW50NjQgZXF1YWxfX2xvY2FsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfbmF0aXZlaW50IDogbmF0aXZlaW50IGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfbmF0aXZlaW50X19sb2NhbCA6IG5hdGl2ZWludCBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9zdHJpbmcgOiBzdHJpbmcgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9zdHJpbmdfX2xvY2FsIDogc3RyaW5nIGVxdWFsX19sb2NhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2J5dGVzIDogYnl0ZXMgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9ieXRlc19fbG9jYWwgOiBieXRlcyBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF91bml0IDogdW5pdCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3VuaXRfX2xvY2FsIDogdW5pdCBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG5cbiAgKCogW1BvbHkuZXF1YWxdIGlzIElFRUUgY29tcGxpYW50LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50IGhlcmUuICopXG4gIGxldCBlcXVhbF9mbG9hdCB4IHkgPSBlcXVhbF9pbnQgKGNvbXBhcmVfZmxvYXQgeCB5KSAwXG4gIGxldCBlcXVhbF9mbG9hdF9fbG9jYWwgeCB5ID0gZXF1YWxfaW50IChjb21wYXJlX2Zsb2F0X19sb2NhbCB4IHkpIDBcblxuICBsZXQgZXF1YWxfYXJyYXlfX2xvY2FsIGVxdWFsX2VsdCBhIGIgPVxuICAgIHBoeXNfZXF1YWwgYSBiXG4gICAgfHxcbiAgICBsZXQgbGVuX2EgPSBBcnJheTAubGVuZ3RoIGEgaW5cbiAgICBsZXQgbGVuX2IgPSBBcnJheTAubGVuZ3RoIGIgaW5cbiAgICBlcXVhbCBsZW5fYSBsZW5fYlxuICAgICYmXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaSA9IGxlbl9hXG4gICAgICB8fFxuICAgICAgbGV0IGwgPSBBcnJheTAudW5zYWZlX2dldCBhIGlcbiAgICAgIGFuZCByID0gQXJyYXkwLnVuc2FmZV9nZXQgYiBpIGluXG4gICAgICBlcXVhbF9lbHQgbCByICYmIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZXF1YWxfYXJyYXkgZXF1YWxfZWx0IGEgYiA9IGVxdWFsX2FycmF5X19sb2NhbCBlcXVhbF9lbHQgYSBiXG5cbiAgbGV0IHJlYyBlcXVhbF9saXN0IGVxdWFsX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IFtdLCBfIHwgXywgW10gLT4gZmFsc2VcbiAgICB8IHggOjogeHMsIHkgOjogeXMgLT4gZXF1YWxfZWx0IHggeSAmJiBlcXVhbF9saXN0IGVxdWFsX2VsdCB4cyB5c1xuICA7O1xuXG4gIGxldCByZWMgZXF1YWxfbGlzdF9fbG9jYWwgZXF1YWxfZWx0X19sb2NhbCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IFtdLCBfIHwgXywgW10gLT4gZmFsc2VcbiAgICB8IHggOjogeHMsIHkgOjogeXMgLT4gZXF1YWxfZWx0X19sb2NhbCB4IHkgJiYgZXF1YWxfbGlzdF9fbG9jYWwgZXF1YWxfZWx0X19sb2NhbCB4cyB5c1xuICA7O1xuXG4gIGxldCBlcXVhbF9vcHRpb24gZXF1YWxfZWx0IGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBOb25lLCBOb25lIC0+IHRydWVcbiAgICB8IE5vbmUsIFNvbWUgXyB8IFNvbWUgXywgTm9uZSAtPiBmYWxzZVxuICAgIHwgU29tZSBhLCBTb21lIGIgLT4gZXF1YWxfZWx0IGEgYlxuICA7O1xuXG4gIGxldCBlcXVhbF9vcHRpb25fX2xvY2FsIGVxdWFsX2VsdF9fbG9jYWwgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICAgIHwgTm9uZSwgU29tZSBfIHwgU29tZSBfLCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBlcXVhbF9lbHRfX2xvY2FsIGEgYlxuICA7O1xuXG4gIGxldCBlcXVhbF9yZWYgZXF1YWxfZWx0IGEgYiA9IGVxdWFsX2VsdCAhYSAhYlxuICBsZXQgZXF1YWxfcmVmX19sb2NhbCBlcXVhbF9lbHQgYSBiID0gZXF1YWxfZWx0ICFhICFiXG5lbmRcbiIsIigqKiBUaGlzIG1vZHVsZSBpcyBmb3IgdXNlIGJ5IHBweF9oYXNoLCBhbmQgaXMgdGh1cyBub3QgaW4gdGhlIGludGVyZmFjZSBvZiBCYXNlLiAqKVxubW9kdWxlIFN0ZCA9IHN0cnVjdFxuICBtb2R1bGUgSGFzaCA9IEhhc2ggKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoICopXG5lbmRcblxudHlwZSAnYSBoYXNoX2ZvbGQgPSBTdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBTdGQuSGFzaC5zdGF0ZVxuXG5tb2R1bGUgSGFzaGFibGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGhhc2hfZm9sZF90IDogdCBoYXNoX2ZvbGRcbiAgICB2YWwgaGFzaCA6IHQgLT4gU3RkLkhhc2guaGFzaF92YWx1ZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGhhc2hfZm9sZF90IDogJ2EgaGFzaF9mb2xkIC0+ICdhIHQgaGFzaF9mb2xkXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3QgOiAnYSBoYXNoX2ZvbGQgLT4gJ2IgaGFzaF9mb2xkIC0+ICgnYSwgJ2IpIHQgaGFzaF9mb2xkXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGhhc2hfZm9sZF90XG4gICAgICA6ICAnYSBoYXNoX2ZvbGRcbiAgICAgIC0+ICdiIGhhc2hfZm9sZFxuICAgICAgLT4gJ2MgaGFzaF9mb2xkXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdCBoYXNoX2ZvbGRcbiAgZW5kXG5lbmRcbiIsIm9wZW4gR2xvYmFsaXplXG5vcGVuIEhhc2guQnVpbHRpblxub3BlbiBQcHhfY29tcGFyZV9saWIuQnVpbHRpblxuaW5jbHVkZSBTZXhwbGliMC5TZXhwXG5cbigqKiBUeXBlIG9mIFMtZXhwcmVzc2lvbnMgKilcbnR5cGUgdCA9IFNleHBsaWIwLlNleHAudCA9XG4gIHwgQXRvbSBvZiBzdHJpbmdcbiAgfCBMaXN0IG9mIHQgbGlzdFxuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2hdXG5cbmxldCByZWMgY29tcGFyZV9fbG9jYWwgPVxuICAoZnVuIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwMV8gYl9fMDAyX1xuICAgICB0aGVuIDBcbiAgICAgZWxzZSAoXG4gICAgICAgbWF0Y2ggYV9fMDAxXywgYl9fMDAyXyB3aXRoXG4gICAgICAgfCBBdG9tIF9hX18wMDNfLCBBdG9tIF9iX18wMDRfIC0+IGNvbXBhcmVfc3RyaW5nX19sb2NhbCBfYV9fMDAzXyBfYl9fMDA0X1xuICAgICAgIHwgQXRvbSBfLCBfIC0+IC0xXG4gICAgICAgfCBfLCBBdG9tIF8gLT4gMVxuICAgICAgIHwgTGlzdCBfYV9fMDA1XywgTGlzdCBfYl9fMDA2XyAtPlxuICAgICAgICAgY29tcGFyZV9saXN0X19sb2NhbCBjb21wYXJlX19sb2NhbCBfYV9fMDA1XyBfYl9fMDA2XylcbiAgICA6IHQgLT4gdCAtPiBpbnQpXG47O1xuXG5sZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG5cbmxldCByZWMgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPVxuICAoZnVuIHhfXzAwOV8gLT5cbiAgICAgbWF0Y2ggeF9fMDA5XyB3aXRoXG4gICAgIHwgQXRvbSBhcmdfXzAxMF8gLT4gQXRvbSAoZ2xvYmFsaXplX3N0cmluZyBhcmdfXzAxMF8pXG4gICAgIHwgTGlzdCBhcmdfXzAxMV8gLT4gTGlzdCAoZ2xvYmFsaXplX2xpc3QgZ2xvYmFsaXplIGFyZ19fMDExXylcbiAgICA6IHQgLT4gdClcbjs7XG5cbmxldCByZWMgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gIChmdW4gaHN2IGFyZyAtPlxuICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICB8IEF0b20gX2EwIC0+XG4gICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMCBpblxuICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICBoYXNoX2ZvbGRfc3RyaW5nIGhzdiBfYTBcbiAgICAgfCBMaXN0IF9hMCAtPlxuICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgaGFzaF9mb2xkX2xpc3QgaGFzaF9mb2xkX3QgaHN2IF9hMFxuICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuXG5hbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbltAQEBlbmRdXG5cbmxldCB0X3NleHBfZ3JhbW1hciA9IFNleHBsaWIwLlNleHBfY29udi5zZXhwX3Rfc2V4cF9ncmFtbWFyXG5sZXQgb2Zfc3RyaW5nID0gKClcbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgZXF1YWxfX2xvY2FsIGEgYiA9IGNvbXBhcmVfX2xvY2FsIGEgYiA9IDBcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIFN5cyA9IFN5czBcblxudHlwZSB0ID1cbiAgfCBXMzJcbiAgfCBXNjRcbltAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90ID1cbiAgKGZ1bmN0aW9uXG4gICB8IFczMiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJXMzJcIlxuICAgfCBXNjQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVzY0XCJcbiAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxuW0BAQGVuZF1cblxubGV0IG51bV9iaXRzID0gZnVuY3Rpb25cbiAgfCBXMzIgLT4gMzJcbiAgfCBXNjQgLT4gNjRcbjs7XG5cbmxldCB3b3JkX3NpemUgPVxuICBtYXRjaCBTeXMud29yZF9zaXplX2luX2JpdHMgd2l0aFxuICB8IDMyIC0+IFczMlxuICB8IDY0IC0+IFc2NFxuICB8IF8gLT4gZmFpbHdpdGggXCJ1bmtub3duIHdvcmQgc2l6ZVwiXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbmxldCByID0gcmVmIFsgXCJCYXNlLlNleHAucHBfaHVtXCIgXVxubGV0IGFsbCAoKSA9ICFyXG5sZXQgcmVnaXN0ZXIgcCA9IHIgOj0gcCA6OiAhclxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBwcCA6IEZvcm1hdHRlci50IC0+IHQgLT4gdW5pdFxuZW5kXG5cbm1vZHVsZSBSZWdpc3Rlcl9wcCAoTSA6IHNpZ1xuICBpbmNsdWRlIFNcblxuICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbmVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIGxldCAoKSA9IHJlZ2lzdGVyIChNLm1vZHVsZV9uYW1lIF4gXCIucHBcIilcbmVuZFxuXG5tb2R1bGUgUmVnaXN0ZXIgKE0gOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIG1vZHVsZV9uYW1lIDogc3RyaW5nXG4gIHZhbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZ1xuZW5kKSA9XG5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIGxldCBwcCBmb3JtYXR0ZXIgdCA9IFN0ZGxpYi5Gb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZvcm1hdHRlciAoTS50b19zdHJpbmcgdClcbmVuZClcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBleG4gW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9leG4gOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuW0BAQGVuZF1cblxubGV0IGV4aXQgPSBTdGRsaWIuZXhpdFxuXG5leGNlcHRpb24gRmluYWxseSBvZiB0ICogdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEZpbmFsbHldIChmdW5jdGlvblxuICAgIHwgRmluYWxseSAoYXJnMF9fMDAxXywgYXJnMV9fMDAyXykgLT5cbiAgICAgIGxldCByZXMwX18wMDNfID0gc2V4cF9vZl90IGFyZzBfXzAwMV9cbiAgICAgIGFuZCByZXMxX18wMDRfID0gc2V4cF9vZl90IGFyZzFfXzAwMl8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImV4bi5tbC5GaW5hbGx5XCI7IHJlczBfXzAwM187IHJlczFfXzAwNF8gXVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5leGNlcHRpb24gUmVyYWlzZWQgb2Ygc3RyaW5nICogdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFJlcmFpc2VkXSAoZnVuY3Rpb25cbiAgICB8IFJlcmFpc2VkIChhcmcwX18wMDVfLCBhcmcxX18wMDZfKSAtPlxuICAgICAgbGV0IHJlczBfXzAwN18gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDVfXG4gICAgICBhbmQgcmVzMV9fMDA4XyA9IHNleHBfb2ZfdCBhcmcxX18wMDZfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJleG4ubWwuUmVyYWlzZWRcIjsgcmVzMF9fMDA3XzsgcmVzMV9fMDA4XyBdXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbmV4Y2VwdGlvbiBTZXhwIG9mIFNleHAudFxuXG4oKiBXZSBpbnN0YWxsIGEgY3VzdG9tIGV4bi1jb252ZXJ0ZXIgcmF0aGVyIHRoYW4gdXNlOlxuXG4gICB7W1xuICAgICBleGNlcHRpb24gU2V4cCBvZiBTZXhwLnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG4gICAgICgqIC4uLiAqKVxuICAgICBbQEBAZW5kXVxuICAgXX1cblxuICAgdG8gZWxpbWluYXRlIHRoZSBleHRyYSB3cmFwcGluZyBvZiBbKFNleHAgLi4uKV0uICopXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgU2V4cF0gKGZ1bmN0aW9uXG4gICAgfCBTZXhwIHQgLT4gdFxuICAgIHwgXyAtPlxuICAgICAgKCogUmVhY2hpbmcgdGhpcyBicmFuY2ggaW5kaWNhdGVzIGEgYnVnIGluIHNleHBsaWIuICopXG4gICAgICBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgY3JlYXRlX3Mgc2V4cCA9IFNleHAgc2V4cFxuXG5sZXQgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgdCBiYWNrdHJhY2UgPVxuICBTdGRsaWIuUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgdCBiYWNrdHJhY2Vcbjs7XG5cbmV4dGVybmFsIGlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgOiB0IC0+IGJvb2wgPSBcIkJhc2VfY2FtbF9leG5faXNfbW9zdF9yZWNlbnRfZXhuXCJcblxubGV0IHJlcmFpc2UgZXhuIHN0ciA9XG4gIGxldCBleG4nID0gUmVyYWlzZWQgKHN0ciwgZXhuKSBpblxuICBpZiBpc19waHlzX2VxdWFsX21vc3RfcmVjZW50IGV4blxuICB0aGVuIChcbiAgICBsZXQgYnQgPSBTdGRsaWIuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSBleG4nIGJ0KVxuICBlbHNlIHJhaXNlIGV4bidcbjs7XG5cbmxldCByZXJhaXNlZiBleGMgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIChmdW4gc3RyICgpIC0+IHJlcmFpc2UgZXhjIHN0cikgZm9ybWF0XG5sZXQgdG9fc3RyaW5nIGV4YyA9IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgKHNleHBfb2ZfZXhuIGV4YylcbmxldCB0b19zdHJpbmdfbWFjaCBleGMgPSBTZXhwLnRvX3N0cmluZ19tYWNoIChzZXhwX29mX2V4biBleGMpXG5sZXQgc2V4cF9vZl90ID0gc2V4cF9vZl9leG5cblxubGV0IHByb3RlY3R4IH5mIHggfihmaW5hbGx5IDogXyAtPiB1bml0KSA9XG4gIG1hdGNoIGYgeCB3aXRoXG4gIHwgcmVzIC0+XG4gICAgZmluYWxseSB4O1xuICAgIHJlc1xuICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICBsZXQgYnQgPSBTdGRsaWIuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAobWF0Y2ggZmluYWxseSB4IHdpdGhcbiAgICAgfCAoKSAtPiByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSBleG4gYnRcbiAgICAgfCBleGNlcHRpb24gZmluYWxfZXhuIC0+XG4gICAgICAgKCogVW5mb3J0dW5hdGVseSwgdGhlIGJhY2t0cmFjZSBvZiB0aGUgW2ZpbmFsX2V4bl0gaXMgZGlzY2FyZGVkIGhlcmUuICopXG4gICAgICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgKEZpbmFsbHkgKGV4biwgZmluYWxfZXhuKSkgYnQpXG47O1xuXG5sZXQgcHJvdGVjdCB+ZiB+ZmluYWxseSA9IHByb3RlY3R4IH5mICgpIH5maW5hbGx5XG5cbmxldCBkb2VzX3JhaXNlICh0eXBlIGEpIChmIDogdW5pdCAtPiBhKSA9XG4gIHRyeVxuICAgIGlnbm9yZSAoZiAoKSA6IGEpO1xuICAgIGZhbHNlXG4gIHdpdGhcbiAgfCBfIC0+IHRydWVcbjs7XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICB0eXBlIHQgPSBleG5cblxuICBsZXQgcHAgcHBmIHQgPVxuICAgIG1hdGNoIHNleHBfb2ZfZXhuX29wdCB0IHdpdGhcbiAgICB8IFNvbWUgc2V4cCAtPiBTZXhwLnBwX2h1bSBwcGYgc2V4cFxuICAgIHwgTm9uZSAtPiBTdGRsaWIuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKFN0ZGxpYi5QcmludGV4Yy50b19zdHJpbmcgdClcbiAgOztcblxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuRXhuXCJcbmVuZClcblxubGV0IHByaW50X3dpdGhfYmFja3RyYWNlIGV4YyByYXdfYmFja3RyYWNlID1cbiAgU3RkbGliLkZvcm1hdC5lcHJpbnRmIFwiQFs8Mj5VbmNhdWdodCBleGNlcHRpb246QFxcbkBcXG5AWyVhQF1AXUBcXG5ALlwiIHBwIGV4YztcbiAgaWYgU3RkbGliLlByaW50ZXhjLmJhY2t0cmFjZV9zdGF0dXMgKClcbiAgdGhlbiBTdGRsaWIuUHJpbnRleGMucHJpbnRfcmF3X2JhY2t0cmFjZSBTdGRsaWIuc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gIFN0ZGxpYi5mbHVzaCBTdGRsaWIuc3RkZXJyXG47O1xuXG5sZXQgc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyICgpID1cbiAgU3RkbGliLlByaW50ZXhjLnNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBwcmludF93aXRoX2JhY2t0cmFjZVxuOztcblxubGV0IGhhbmRsZV91bmNhdWdodF9hdXggfmRvX2F0X2V4aXQgfmV4aXQgZiA9XG4gIHRyeSBmICgpIHdpdGhcbiAgfCBleGMgLT5cbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9IFN0ZGxpYi5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICgqIE9uZSByZWFzb24gdG8gcnVuIFtkb19hdF9leGl0XSBoYW5kbGVycyBiZWZvcmUgcHJpbnRpbmcgb3V0IHRoZSBlcnJvciBtZXNzYWdlIGlzXG4gICAgICAgdGhhdCBpdCBoZWxwcyBjdXJzZXMgYXBwbGljYXRpb25zIGJyaW5nIHRoZSB0ZXJtaW5hbCBpbiBhIGdvb2Qgc3RhdGUsIG90aGVyd2lzZSB0aGVcbiAgICAgICBlcnJvciBtZXNzYWdlIG1pZ2h0IGdldCBjb3JydXB0ZWQuICBBbHNvLCB0aGUgT0NhbWwgdG9wLWxldmVsIHVuY2F1Z2h0IGV4Y2VwdGlvblxuICAgICAgIGhhbmRsZXIgZG9lcyB0aGUgc2FtZS4gKilcbiAgICBpZiBkb19hdF9leGl0XG4gICAgdGhlbiAoXG4gICAgICB0cnkgU3RkbGliLmRvX2F0X2V4aXQgKCkgd2l0aFxuICAgICAgfCBfIC0+ICgpKTtcbiAgICAodHJ5IHByaW50X3dpdGhfYmFja3RyYWNlIGV4YyByYXdfYmFja3RyYWNlIHdpdGhcbiAgICAgfCBfIC0+XG4gICAgICAgKHRyeVxuICAgICAgICAgIFN0ZGxpYi5QcmludGYuZXByaW50ZiBcIkV4bi5oYW5kbGVfdW5jYXVnaHQgY291bGQgbm90IHByaW50OyBleGl0aW5nIGFueXdheVxcbiUhXCJcbiAgICAgICAgd2l0aFxuICAgICAgICB8IF8gLT4gKCkpKTtcbiAgICBleGl0IDFcbjs7XG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfYW5kX2V4aXQgZiA9IGhhbmRsZV91bmNhdWdodF9hdXggZiB+ZXhpdCB+ZG9fYXRfZXhpdDp0cnVlXG5cbmxldCBoYW5kbGVfdW5jYXVnaHQgfmV4aXQ6bXVzdF9leGl0IGYgPVxuICBoYW5kbGVfdW5jYXVnaHRfYXV4IGYgfmV4aXQ6KGlmIG11c3RfZXhpdCB0aGVuIGV4aXQgZWxzZSBpZ25vcmUpIH5kb19hdF9leGl0Om11c3RfZXhpdFxuOztcblxubGV0IHJlcmFpc2VfdW5jYXVnaHQgc3RyIGZ1bmMgPVxuICB0cnkgZnVuYyAoKSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgbGV0IGJ0ID0gU3RkbGliLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgKFJlcmFpc2VkIChzdHIsIGV4bikpIGJ0XG47O1xuXG5leHRlcm5hbCBjbGVhcl9iYWNrdHJhY2UgOiB1bml0IC0+IHVuaXQgPSBcIkJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zXCIgW0BAbm9hbGxvY11cblxubGV0IHJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIGUgPVxuICAoKiBXZSBjbGVhciB0aGUgYmFja3RyYWNlIHRvIHJlZHVjZSBjb25mdXNpb24sIHNvIHRoYXQgcGVvcGxlIGRvbid0IHRoaW5rIHdoYXRldmVyXG4gICAgIGlzIHN0b3JlZCBjb3JyZXNwb25kcyB0byB0aGlzIHJhaXNlLiAqKVxuICBjbGVhcl9iYWNrdHJhY2UgKCk7XG4gIFN0ZGxpYi5yYWlzZV9ub3RyYWNlIGVcbjs7XG5cbmxldCBpbml0aWFsaXplX21vZHVsZSAoKSA9IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciAoKVxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgY2xlYXJfYmFja3RyYWNlID0gY2xlYXJfYmFja3RyYWNlXG5lbmRcbiIsIigqIGJlbG9uZ3MgaW4gQ29tbW9uLCBidXQgbW92ZWQgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgKilcblxub3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgcmV0dXJuID0geyByZXR1cm4gOiAnYi4gJ2EgLT4gJ2IgfSBbQEB1bmJveGVkXVxuXG5sZXQgd2l0aF9yZXR1cm4gKHR5cGUgYSkgZiA9XG4gICgqIFJhaXNlZCB0byBpbmRpY2F0ZSB+cmV0dXJuIHdhcyBjYWxsZWQuICBMb2NhbCBzbyB0aGF0IHRoZSBleGNlcHRpb24gaXMgdGllZCB0byBhXG4gICAgIHBhcnRpY3VsYXIgY2FsbCBvZiBbd2l0aF9yZXR1cm5dLiAqKVxuICBsZXQgZXhjZXB0aW9uIFJldHVybiBvZiBhIGluXG4gIGxldCBpc19hbGl2ZSA9IHJlZiB0cnVlIGluXG4gIGxldCByZXR1cm4gYSA9XG4gICAgaWYgbm90ICFpc19hbGl2ZVxuICAgIHRoZW4gZmFpbHdpdGggXCJ1c2Ugb2YgW3JldHVybl0gZnJvbSBhIFt3aXRoX3JldHVybl0gdGhhdCBhbHJlYWR5IHJldHVybmVkXCI7XG4gICAgRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIChSZXR1cm4gYSlcbiAgaW5cbiAgdHJ5XG4gICAgbGV0IGEgPSBmIHsgcmV0dXJuIH0gaW5cbiAgICBpc19hbGl2ZSA6PSBmYWxzZTtcbiAgICBhXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICBpc19hbGl2ZSA6PSBmYWxzZTtcbiAgICAobWF0Y2ggZXhuIHdpdGhcbiAgICAgfCBSZXR1cm4gYSAtPiBhXG4gICAgIHwgXyAtPiByYWlzZSBleG4pXG47O1xuXG5sZXQgd2l0aF9yZXR1cm5fb3B0aW9uIGYgPVxuICB3aXRoX3JldHVybiAoZnVuIHJldHVybiAtPlxuICAgIGYgeyByZXR1cm4gPSAoZnVuIGEgLT4gcmV0dXJuLnJldHVybiAoU29tZSBhKSkgfTtcbiAgICBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcHJlcGVuZCB7IHJldHVybiB9IH5mID0geyByZXR1cm4gPSAoZnVuIHggLT4gcmV0dXJuIChmIHgpKSB9XG4iLCJvcGVuISBJbXBvcnRcblxubGV0IGNvbnN0IGMgXyA9IGNcblxuZXh0ZXJuYWwgaWdub3JlIDogKF9bQGxvY2FsX29wdF0pIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiB0aGlzIGhhcyB0aGUgc2FtZSBiZWhhdmlvciBhcyBbU3RkbGliLmlnbm9yZV0gKilcblxubGV0IG5vbiBmIHggPSBub3QgKGYgeClcblxubGV0IGZvcmV2ZXIgZiA9XG4gIGxldCByZWMgZm9yZXZlciAoKSA9XG4gICAgZiAoKTtcbiAgICBmb3JldmVyICgpXG4gIGluXG4gIHRyeSBmb3JldmVyICgpIHdpdGhcbiAgfCBlIC0+IGVcbjs7XG5cbmV4dGVybmFsIGlkIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCgnYSAtPiAnYilbQGxvY2FsX29wdF0pIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuXG4oKiBUaGUgdHlwaWNhbCB1c2UgY2FzZSBmb3IgdGhlc2UgZnVuY3Rpb25zIGlzIHRvIHBhc3MgaW4gZnVuY3Rpb25hbCBhcmd1bWVudHMgYW5kIGdldFxuICAgZnVuY3Rpb25zIGFzIGEgcmVzdWx0LiAqKVxubGV0IGNvbXBvc2UgZiBnIHggPSBmIChnIHgpXG5sZXQgZmxpcCBmIHggeSA9IGYgeSB4XG5sZXQgcmVjIGFwcGx5X25fdGltZXMgfm4gZiB4ID0gaWYgbiA8PSAwIHRoZW4geCBlbHNlIGFwcGx5X25fdGltZXMgfm46KG4gLSAxKSBmIChmIHgpXG4iLCJvcGVuISBJbXBvcnRcblxubW9kdWxlIHR5cGUgQmFzaWNfZ2VuID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mblxuXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCwgJ2IgdCkgZl9sYWJlbGVkX2ZuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG5cbiAgKCoqIFRoZSBmb2xsb3dpbmcgaWRlbnRpdGllcyBvdWdodCB0byBob2xkIChmb3Igc29tZSB2YWx1ZSBvZiA9KTpcblxuICAgICAgLSBbcmV0dXJuIHggPj49IGYgPSBmIHhdXG4gICAgICAtIFt0ID4+PSBmdW4geCAtPiByZXR1cm4geCA9IHRdXG4gICAgICAtIFsodCA+Pj0gZikgPj49IGcgPSB0ID4+PSBmdW4geCAtPiAoZiB4ID4+PSBnKV1cblxuICAgICAgTm90ZTogWz4+PV0gaXMgdGhlIGluZml4IG5vdGF0aW9uIGZvciBbYmluZF0pICopXG5cbiAgKCoqIFRoZSBbbWFwXSBhcmd1bWVudCB0byBbTW9uYWQuTWFrZV0gc2F5cyBob3cgdG8gaW1wbGVtZW50IHRoZSBtb25hZCdzIFttYXBdIGZ1bmN0aW9uLlxuICAgICAgW2BEZWZpbmVfdXNpbmdfYmluZF0gbWVhbnMgdG8gZGVmaW5lIFttYXAgdCB+ZiA9IGJpbmQgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChmIGEpKV0uXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC5cblxuICAgICAgU29tZSBvdGhlciBmdW5jdGlvbnMgcmV0dXJuZWQgYnkgW01vbmFkLk1ha2VdIGFyZSBkZWZpbmVkIGluIHRlcm1zIG9mIFttYXBdLCBzb1xuICAgICAgcGFzc2luZyBpbiBhIG1vcmUgZWZmaWNpZW50IFttYXBdIHdpbGwgaW1wcm92ZSB0aGVpciBlZmZpY2llbmN5IGFzIHdlbGwuICopXG4gIHZhbCBtYXAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZCB8IGBDdXN0b20gb2YgJ2EgdCAtPiAoJ2EgLT4gJ2IsICdiIHQpIGZfbGFiZWxlZF9mbiBdXG5lbmRcblxubW9kdWxlIHR5cGUgQmFzaWMgPSBCYXNpY19nZW4gd2l0aCB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mbiA6PSBmOidhIC0+ICdiXG5tb2R1bGUgdHlwZSBCYXNpY19sb2NhbCA9IEJhc2ljX2dlbiB3aXRoIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuIDo9IGY6J2EgLT4gJ2JcblxubW9kdWxlIHR5cGUgSW5maXhfZ2VuID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICgnYSwgJ2IpIGZuXG5cbiAgKCoqIFt0ID4+PSBmXSByZXR1cm5zIGEgY29tcHV0YXRpb24gdGhhdCBzZXF1ZW5jZXMgdGhlIGNvbXB1dGF0aW9ucyByZXByZXNlbnRlZCBieSB0d29cbiAgICAgIG1vbmFkIGVsZW1lbnRzLiAgVGhlIHJlc3VsdGluZyBjb21wdXRhdGlvbiBmaXJzdCBkb2VzIFt0XSB0byB5aWVsZCBhIHZhbHVlIFt2XSwgYW5kXG4gICAgICB0aGVuIHJ1bnMgdGhlIGNvbXB1dGF0aW9uIHJldHVybmVkIGJ5IFtmIHZdLiAqKVxuICB2YWwgKCA+Pj0gKSA6ICdhIHQgLT4gKCdhIC0+ICdiIHQsICdiIHQpIGZuXG5cbiAgKCoqIFt0ID4+fCBmXSBpcyBbdCA+Pj0gKGZ1biBhIC0+IHJldHVybiAoZiBhKSldLiAqKVxuICB2YWwgKCA+PnwgKSA6ICdhIHQgLT4gKCdhIC0+ICdiLCAnYiB0KSBmblxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4ID0gSW5maXhfZ2VuIHdpdGggdHlwZSAoJ2EsICdiKSBmbiA6PSAnYSAtPiAnYlxubW9kdWxlIHR5cGUgSW5maXhfbG9jYWwgPSBJbmZpeF9nZW4gd2l0aCB0eXBlICgnYSwgJ2IpIGZuIDo9ICdhIC0+ICdiXG5cbm1vZHVsZSB0eXBlIFN5bnRheF9nZW4gPSBzaWdcbiAgKCoqIE9wZW5pbmcgYSBtb2R1bGUgb2YgdGhpcyB0eXBlIGFsbG93cyBvbmUgdG8gdXNlIHRoZSBbJWJpbmRdIGFuZCBbJW1hcF0gc3ludGF4XG4gICAgICBleHRlbnNpb25zIGRlZmluZWQgYnkgcHB4X2xldCwgYW5kIGJyaW5ncyBbcmV0dXJuXSBpbnRvIHNjb3BlLiAqKVxuXG4gIHR5cGUgJ2EgdFxuICB0eXBlICgnYSwgJ2IpIGZuXG4gIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuXG5cbiAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAoKiogVGhlc2UgYXJlIGNvbnZlbmllbnQgdG8gaGF2ZSBpbiBzY29wZSB3aGVuIHByb2dyYW1taW5nIHdpdGggYSBtb25hZDogKilcblxuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG5cbiAgICBpbmNsdWRlIEluZml4X2dlbiB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0IGFuZCB0eXBlICgnYSwgJ2IpIGZuIDo9ICgnYSwgJ2IpIGZuXG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcbiAgICAgIHZhbCBiaW5kIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCwgJ2IgdCkgZl9sYWJlbGVkX2ZuXG4gICAgICB2YWwgbWFwIDogJ2EgdCAtPiAoJ2EgLT4gJ2IsICdiIHQpIGZfbGFiZWxlZF9mblxuICAgICAgdmFsIGJvdGggOiAnYSB0IC0+ICdiIHQgLT4gKCdhICogJ2IpIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXggPVxuICBTeW50YXhfZ2VuXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIGZuIDo9ICdhIC0+ICdiXG4gICAgIGFuZCB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mbiA6PSBmOidhIC0+ICdiXG5cbm1vZHVsZSB0eXBlIFN5bnRheF9sb2NhbCA9XG4gIFN5bnRheF9nZW5cbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgZm4gOj0gJ2EgLT4gJ2JcbiAgICAgYW5kIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuIDo9IGY6J2EgLT4gJ2JcblxubW9kdWxlIHR5cGUgU193aXRob3V0X3N5bnRheF9nZW4gPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgKCdhLCAnYikgZm5cbiAgdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm5cblxuICBpbmNsdWRlIEluZml4X2dlbiB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0IGFuZCB0eXBlICgnYSwgJ2IpIGZuIDo9ICgnYSwgJ2IpIGZuXG5cbiAgbW9kdWxlIE1vbmFkX2luZml4IDpcbiAgICBJbmZpeF9nZW4gd2l0aCB0eXBlICdhIHQgOj0gJ2EgdCBhbmQgdHlwZSAoJ2EsICdiKSBmbiA6PSAoJ2EsICdiKSBmblxuXG4gICgqKiBbYmluZCB0IH5mXSA9IFt0ID4+PSBmXSAqKVxuICB2YWwgYmluZCA6ICdhIHQgLT4gKCdhIC0+ICdiIHQsICdiIHQpIGZfbGFiZWxlZF9mblxuXG4gICgqKiBbcmV0dXJuIHZdIHJldHVybnMgdGhlICh0cml2aWFsKSBjb21wdXRhdGlvbiB0aGF0IHJldHVybnMgdi4gKilcbiAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcblxuICAoKiogW21hcCB0IH5mXSBpcyB0ID4+fCBmLiAqKVxuICB2YWwgbWFwIDogJ2EgdCAtPiAoJ2EgLT4gJ2IsICdiIHQpIGZfbGFiZWxlZF9mblxuXG4gICgqKiBbam9pbiB0XSBpcyBbdCA+Pj0gKGZ1biB0JyAtPiB0JyldLiAqKVxuICB2YWwgam9pbiA6ICdhIHQgdCAtPiAnYSB0XG5cbiAgKCoqIFtpZ25vcmVfbSB0XSBpcyBbbWFwIHQgfmY6KGZ1biBfIC0+ICgpKV0uICBbaWdub3JlX21dIHVzZWQgdG8gYmUgY2FsbGVkIFtpZ25vcmVdLFxuICAgICAgYnV0IHdlIGRlY2lkZWQgdGhhdCB3YXMgYSBiYWQgbmFtZSwgYmVjYXVzZSBpdCBzaGFkb3dlZCB0aGUgd2lkZWx5IHVzZWRcbiAgICAgIFtTdGRsaWIuaWdub3JlXS4gIFNvbWUgbW9uYWRzIHN0aWxsIGRvIFtsZXQgaWdub3JlID0gaWdub3JlX21dIGZvciBoaXN0b3JpY2FsXG4gICAgICByZWFzb25zLiAqKVxuICB2YWwgaWdub3JlX20gOiAnYSB0IC0+IHVuaXQgdFxuXG4gIHZhbCBhbGwgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG5cbiAgKCoqIExpa2UgW2FsbF0sIGJ1dCBlbnN1cmVzIHRoYXQgZXZlcnkgbW9uYWRpYyB2YWx1ZSBpbiB0aGUgbGlzdCBwcm9kdWNlcyBhIHVuaXQgdmFsdWUsXG4gICAgICBhbGwgb2Ygd2hpY2ggYXJlIGRpc2NhcmRlZCByYXRoZXIgdGhhbiBiZWluZyBjb2xsZWN0ZWQgaW50byBhIGxpc3QuICopXG4gIHZhbCBhbGxfdW5pdCA6IHVuaXQgdCBsaXN0IC0+IHVuaXQgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfd2l0aG91dF9zeW50YXggPVxuICBTX3dpdGhvdXRfc3ludGF4X2dlblxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm4gOj0gZjonYSAtPiAnYlxuICAgICBhbmQgdHlwZSAoJ2EsICdiKSBmbiA6PSAnYSAtPiAnYlxuXG5tb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3ludGF4X2xvY2FsID1cbiAgU193aXRob3V0X3N5bnRheF9nZW5cbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuIDo9IGY6J2EgLT4gJ2JcbiAgICAgYW5kIHR5cGUgKCdhLCAnYikgZm4gOj0gJ2EgLT4gJ2JcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlICdhIHRcblxuICBpbmNsdWRlIFNfd2l0aG91dF9zeW50YXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFN5bnRheCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU19sb2NhbCA9IHNpZ1xuICB0eXBlICdhIHRcblxuICBpbmNsdWRlIFNfd2l0aG91dF9zeW50YXhfbG9jYWwgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFN5bnRheF9sb2NhbCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQmFzaWMyX2dlbiA9IHNpZ1xuICAoKiogTXVsdGkgcGFyYW1ldGVyIG1vbmFkLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBnZXRzIHVuaWZpZWQgYWNyb3NzIGFsbCB0aGUgY29tcHV0YXRpb24uXG4gICAgICBUaGlzIGlzIHVzZWQgdG8gZW5jb2RlIG1vbmFkcyB3b3JraW5nIG9uIGEgbXVsdGkgcGFyYW1ldGVyIGRhdGEgc3RydWN0dXJlIGxpa2VcbiAgICAgIChbKCdhLCdiKSByZXN1bHRdKS4gKilcblxuICB0eXBlICgnYSwgJ2UpIHRcbiAgdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm5cblxuICB2YWwgYmluZCA6ICgnYSwgJ2UpIHQgLT4gKCdhIC0+ICgnYiwgJ2UpIHQsICgnYiwgJ2UpIHQpIGZfbGFiZWxlZF9mblxuXG4gIHZhbCBtYXBcbiAgICA6IFsgYERlZmluZV91c2luZ19iaW5kXG4gICAgICB8IGBDdXN0b20gb2YgKCdhLCAnZSkgdCAtPiAoJ2EgLT4gJ2IsICgnYiwgJ2UpIHQpIGZfbGFiZWxlZF9mblxuICAgICAgXVxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCYXNpYzIgPSBCYXNpYzJfZ2VuIHdpdGggdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm4gOj0gZjonYSAtPiAnYlxubW9kdWxlIHR5cGUgQmFzaWMyX2xvY2FsID0gQmFzaWMyX2dlbiB3aXRoIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuIDo9IGY6J2EgLT4gJ2JcblxubW9kdWxlIHR5cGUgSW5maXgyX2dlbiA9IHNpZ1xuICAoKiogU2FtZSBhcyB7IUluZml4fSwgZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0d28gYXJndW1lbnRzLiBUaGUgc2Vjb25kIGlzIGFsd2F5cyBqdXN0XG4gICAgICBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2UpIHRcbiAgdHlwZSAoJ2EsICdiKSBmblxuXG4gIHZhbCAoID4+PSApIDogKCdhLCAnZSkgdCAtPiAoJ2EgLT4gKCdiLCAnZSkgdCwgKCdiLCAnZSkgdCkgZm5cbiAgdmFsICggPj58ICkgOiAoJ2EsICdlKSB0IC0+ICgnYSAtPiAnYiwgKCdiLCAnZSkgdCkgZm5cbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmZpeDIgPSBJbmZpeDJfZ2VuIHdpdGggdHlwZSAoJ2EsICdiKSBmbiA6PSAnYSAtPiAnYlxubW9kdWxlIHR5cGUgSW5maXgyX2xvY2FsID0gSW5maXgyX2dlbiB3aXRoIHR5cGUgKCdhLCAnYikgZm4gOj0gJ2EgLT4gJ2JcblxubW9kdWxlIHR5cGUgU3ludGF4Ml9nZW4gPSBzaWdcbiAgdHlwZSAoJ2EsICdlKSB0XG4gIHR5cGUgKCdhLCAnYikgZm5cbiAgdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm5cblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcblxuICAgIGluY2x1ZGVcbiAgICAgIEluZml4Ml9nZW4gd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdCBhbmQgdHlwZSAoJ2EsICdiKSBmbiA6PSAoJ2EsICdiKSBmblxuXG4gICAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbiAgICAgIHZhbCBiaW5kIDogKCdhLCAnZSkgdCAtPiAoJ2EgLT4gKCdiLCAnZSkgdCwgKCdiLCAnZSkgdCkgZl9sYWJlbGVkX2ZuXG4gICAgICB2YWwgbWFwIDogKCdhLCAnZSkgdCAtPiAoJ2EgLT4gJ2IsICgnYiwgJ2UpIHQpIGZfbGFiZWxlZF9mblxuICAgICAgdmFsIGJvdGggOiAoJ2EsICdlKSB0IC0+ICgnYiwgJ2UpIHQgLT4gKCdhICogJ2IsICdlKSB0XG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA6IHNpZyBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgU3ludGF4MiA9XG4gIFN5bnRheDJfZ2VuXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIGZuIDo9ICdhIC0+ICdiXG4gICAgIGFuZCB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mbiA6PSBmOidhIC0+ICdiXG5cbm1vZHVsZSB0eXBlIFN5bnRheDJfbG9jYWwgPVxuICBTeW50YXgyX2dlblxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSBmbiA6PSAnYSAtPiAnYlxuICAgICBhbmQgdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm4gOj0gZjonYSAtPiAnYlxuXG5tb2R1bGUgdHlwZSBTMl9nZW4gPSBzaWdcbiAgKCoqIFRoZSBzYW1lIGFzIHshU30gZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0d28gYXJndW1lbnRzLiBUaGUgc2Vjb25kIGlzIGFsd2F5cyBqdXN0XG4gICAgICBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2UpIHRcbiAgdHlwZSAoJ2EsICdiKSBmblxuICB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mblxuXG4gIGluY2x1ZGVcbiAgICBJbmZpeDJfZ2VuIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHQgYW5kIHR5cGUgKCdhLCAnYikgZm4gOj0gKCdhLCAnYikgZm5cblxuICBpbmNsdWRlXG4gICAgU3ludGF4Ml9nZW5cbiAgICAgIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHRcbiAgICAgICBhbmQgdHlwZSAoJ2EsICdiKSBmbiA6PSAoJ2EsICdiKSBmblxuICAgICAgIGFuZCB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mbiA6PSAoJ2EsICdiKSBmX2xhYmVsZWRfZm5cblxuICBtb2R1bGUgTW9uYWRfaW5maXggOlxuICAgIEluZml4Ml9nZW4gd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdCBhbmQgdHlwZSAoJ2EsICdiKSBmbiA6PSAoJ2EsICdiKSBmblxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZSkgdCAtPiAoJ2EgLT4gKCdiLCAnZSkgdCwgKCdiLCAnZSkgdCkgZl9sYWJlbGVkX2ZuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbiAgdmFsIG1hcCA6ICgnYSwgJ2UpIHQgLT4gKCdhIC0+ICdiLCAoJ2IsICdlKSB0KSBmX2xhYmVsZWRfZm5cbiAgdmFsIGpvaW4gOiAoKCdhLCAnZSkgdCwgJ2UpIHQgLT4gKCdhLCAnZSkgdFxuICB2YWwgaWdub3JlX20gOiAoXywgJ2UpIHQgLT4gKHVuaXQsICdlKSB0XG4gIHZhbCBhbGwgOiAoJ2EsICdlKSB0IGxpc3QgLT4gKCdhIGxpc3QsICdlKSB0XG4gIHZhbCBhbGxfdW5pdCA6ICh1bml0LCAnZSkgdCBsaXN0IC0+ICh1bml0LCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMyID1cbiAgUzJfZ2VuIHdpdGggdHlwZSAoJ2EsICdiKSBmbiA6PSAnYSAtPiAnYiBhbmQgdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm4gOj0gZjonYSAtPiAnYlxuXG5tb2R1bGUgdHlwZSBTMl9sb2NhbCA9XG4gIFMyX2dlbiB3aXRoIHR5cGUgKCdhLCAnYikgZm4gOj0gJ2EgLT4gJ2IgYW5kIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuIDo9IGY6J2EgLT4gJ2JcblxubW9kdWxlIHR5cGUgQmFzaWMzID0gc2lnXG4gICgqKiBNdWx0aSBwYXJhbWV0ZXIgbW9uYWQuIFRoZSBzZWNvbmQgYW5kIHRoaXJkIHBhcmFtZXRlcnMgZ2V0IHVuaWZpZWQgYWNyb3NzIGFsbCB0aGVcbiAgICAgIGNvbXB1dGF0aW9uLiAqKVxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2QsICdlKSB0KSAtPiAoJ2IsICdkLCAnZSkgdFxuXG4gIHZhbCBtYXBcbiAgICA6IFsgYERlZmluZV91c2luZ19iaW5kIHwgYEN1c3RvbSBvZiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnZCwgJ2UpIHQgXVxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmZpeDMgPSBzaWdcbiAgKCoqIFNhbWUgYXMgSW5maXgsIGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdGhyZWUgYXJndW1lbnRzLiBUaGUgc2Vjb25kIGFuZCB0aGlyZCBhcmVcbiAgICAgIGFsd2F5cyBqdXN0IHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHRcblxuICB2YWwgKCA+Pj0gKSA6ICgnYSwgJ2QsICdlKSB0IC0+ICgnYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgdmFsICggPj58ICkgOiAoJ2EsICdkLCAnZSkgdCAtPiAoJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU3ludGF4MyA9IHNpZ1xuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfLCBfKSB0XG5cbiAgICBpbmNsdWRlIEluZml4MyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIHRcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfLCBfKSB0XG4gICAgICB2YWwgYmluZCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2QsICdlKSB0KSAtPiAoJ2IsICdkLCAnZSkgdFxuICAgICAgdmFsIG1hcCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdFxuICAgICAgdmFsIGJvdGggOiAoJ2EsICdkLCAnZSkgdCAtPiAoJ2IsICdkLCAnZSkgdCAtPiAoJ2EgKiAnYiwgJ2QsICdlKSB0XG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA6IHNpZyBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgKCoqIFRoZSBzYW1lIGFzIHshU30gZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmRcbiAgICAgIGFuZCB0aGlyZCBhcmUgYWx3YXlzIGp1c3QgcGFzc2VkIHRocm91Z2guICopXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIGluY2x1ZGUgSW5maXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuICBpbmNsdWRlIFN5bnRheDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG4gIG1vZHVsZSBNb25hZF9pbmZpeCA6IEluZml4MyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2QsICdlKSB0KSAtPiAoJ2IsICdkLCAnZSkgdFxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfLCBfKSB0XG4gIHZhbCBtYXAgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgdmFsIGpvaW4gOiAoKCdhLCAnZCwgJ2UpIHQsICdkLCAnZSkgdCAtPiAoJ2EsICdkLCAnZSkgdFxuICB2YWwgaWdub3JlX20gOiAoXywgJ2QsICdlKSB0IC0+ICh1bml0LCAnZCwgJ2UpIHRcbiAgdmFsIGFsbCA6ICgnYSwgJ2QsICdlKSB0IGxpc3QgLT4gKCdhIGxpc3QsICdkLCAnZSkgdFxuICB2YWwgYWxsX3VuaXQgOiAodW5pdCwgJ2QsICdlKSB0IGxpc3QgLT4gKHVuaXQsICdkLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJhc2ljX2luZGV4ZWQgPSBzaWdcbiAgKCoqIEluZGV4ZWQgbW9uYWQsIGluIHRoZSBzdHlsZSBvZiBBdGtleS4gVGhlIHNlY29uZCBhbmQgdGhpcmQgcGFyYW1ldGVycyBhcmUgY29tcG9zZWRcbiAgICAgIGFjcm9zcyBhbGwgY29tcHV0YXRpb24uIFRvIHNlZSB0aGlzIG1vcmUgY2xlYXJseSwgeW91IGNhbiBsb29rIGF0IHRoZSB0eXBlIG9mIGJpbmQ6XG5cbiAgICAgIHtbXG4gICAgICAgIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gICAgICBdfVxuXG4gICAgICBhbmQgaXNvbGF0ZSBzb21lIG9mIHRoZSB0eXBlIHZhcmlhYmxlcyB0byBzZWUgdGhlaXIgaW5kaXZpZHVhbCBiZWhhdmlvcnM6XG5cbiAgICAgIHtbXG4gICAgICAgIHZhbCBiaW5kIDogJ2EgICAgICAgICAgICAgLT4gZjooJ2EgLT4gICdiICAgICAgICAgICApIC0+ICAnYlxuICAgICAgICB2YWwgYmluZCA6ICAgICAgJ2ksICdqICAgIC0+ICAgICAgICAgICAgICAgJ2osICdrICAgICAtPiAgICAgJ2ksICdrXG4gICAgICBdfVxuXG4gICAgICBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBBdGtleS1zdHlsZSBpbmRleGVkIG1vbmFkcywgc2VlOlxuXG4gICAgICB7dlxuICAgICAgICBQYXJhbWV0ZXJpc2VkIE5vdGlvbnMgb2YgQ29tcHV0YXRpb25cbiAgICAgICAgUm9iZXJ0IEF0a2V5XG4gICAgICAgIGh0dHA6Ly9iZW50bmliLm9yZy9wYXJhbW5vdGlvbnMtamZwLnBkZlxuICAgICAgdn0gKilcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcblxuICB2YWwgbWFwXG4gICAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZCB8IGBDdXN0b20gb2YgKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqKSB0IF1cblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2kpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmZpeF9pbmRleGVkID0gc2lnXG4gICgqKiBTYW1lIGFzIHshSW5maXh9LCBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBhbmRcbiAgICAgIHRoaXJkIGFyZSBjb21wb3NlZCBhY3Jvc3MgYWxsIGNvbXB1dGF0aW9uLiAqKVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICB2YWwgKCA+Pj0gKSA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgdmFsICggPj58ICkgOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU3ludGF4X2luZGV4ZWQgPSBzaWdcbiAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpKSB0XG5cbiAgICBpbmNsdWRlIEluZml4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpKSB0XG4gICAgICB2YWwgYmluZCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuICAgICAgdmFsIG1hcCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaikgdFxuICAgICAgdmFsIGJvdGggOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2IsICdqLCAnaykgdCAtPiAoJ2EgKiAnYiwgJ2ksICdrKSB0XG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA6IHNpZyBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgU19pbmRleGVkID0gc2lnXG4gICgqKiBUaGUgc2FtZSBhcyB7IVN9IGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdGhyZWUgYXJndW1lbnRzLiBUaGUgc2Vjb25kIGFuZFxuICAgICAgdGhpcmQgYXJlIGNvbXBvc2VkIGFjcm9zcyBhbGwgY29tcHV0YXRpb24uICopXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gIGluY2x1ZGUgSW5maXhfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIHRcbiAgaW5jbHVkZSBTeW50YXhfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIHRcbiAgbW9kdWxlIE1vbmFkX2luZml4IDogSW5maXhfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2kpIHRcbiAgdmFsIG1hcCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaikgdFxuICB2YWwgam9pbiA6ICgoJ2EsICdqLCAnaykgdCwgJ2ksICdqKSB0IC0+ICgnYSwgJ2ksICdrKSB0XG4gIHZhbCBpZ25vcmVfbSA6IChfLCAnaSwgJ2opIHQgLT4gKHVuaXQsICdpLCAnaikgdFxuICB2YWwgYWxsIDogKCdhLCAnaSwgJ2kpIHQgbGlzdCAtPiAoJ2EgbGlzdCwgJ2ksICdpKSB0XG4gIHZhbCBhbGxfdW5pdCA6ICh1bml0LCAnaSwgJ2kpIHQgbGlzdCAtPiAodW5pdCwgJ2ksICdpKSB0XG5lbmRcblxubW9kdWxlIFNfdG9fUzIgKFggOiBTKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TMyAoWCA6IFMyKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG5lbmRcblxubW9kdWxlIFNfdG9fU19pbmRleGVkIChYIDogUykgOiBTX2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0ID0gJ2EgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHQgPSAnYSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUyAoWCA6IFMyKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAoJ2EsIHVuaXQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICdhIHQgPSAoJ2EsIHVuaXQpIFgudFxuZW5kXG5cbm1vZHVsZSBTM190b19TMiAoWCA6IFMzKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgdW5pdCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsIHVuaXQpIFgudFxuZW5kXG5cbm1vZHVsZSBTX2luZGV4ZWRfdG9fUzIgKFggOiBTX2luZGV4ZWQpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlLCAnZSkgWC50ID1cbnN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlLCAnZSkgWC50XG5lbmRcblxubW9kdWxlIHR5cGUgTW9uYWQgPSBzaWdcbiAgKCoqIEEgbW9uYWQgaXMgYW4gYWJzdHJhY3Rpb24gb2YgdGhlIGNvbmNlcHQgb2Ygc2VxdWVuY2luZyBvZiBjb21wdXRhdGlvbnMuICBBIHZhbHVlIG9mXG4gICAgICB0eXBlIFsnYSBtb25hZF0gcmVwcmVzZW50cyBhIGNvbXB1dGF0aW9uIHRoYXQgcmV0dXJucyBhIHZhbHVlIG9mIHR5cGUgWydhXS4gKilcblxuICBtb2R1bGUgdHlwZSBCYXNpYyA9IEJhc2ljXG4gIG1vZHVsZSB0eXBlIEJhc2ljMiA9IEJhc2ljMlxuICBtb2R1bGUgdHlwZSBCYXNpYzMgPSBCYXNpYzNcbiAgbW9kdWxlIHR5cGUgQmFzaWNfaW5kZXhlZCA9IEJhc2ljX2luZGV4ZWRcbiAgbW9kdWxlIHR5cGUgQmFzaWNfbG9jYWwgPSBCYXNpY19sb2NhbFxuICBtb2R1bGUgdHlwZSBCYXNpYzJfbG9jYWwgPSBCYXNpYzJfbG9jYWxcbiAgbW9kdWxlIHR5cGUgSW5maXggPSBJbmZpeFxuICBtb2R1bGUgdHlwZSBJbmZpeDIgPSBJbmZpeDJcbiAgbW9kdWxlIHR5cGUgSW5maXgzID0gSW5maXgzXG4gIG1vZHVsZSB0eXBlIEluZml4X2luZGV4ZWQgPSBJbmZpeF9pbmRleGVkXG4gIG1vZHVsZSB0eXBlIEluZml4X2xvY2FsID0gSW5maXhfbG9jYWxcbiAgbW9kdWxlIHR5cGUgSW5maXgyX2xvY2FsID0gSW5maXgyX2xvY2FsXG4gIG1vZHVsZSB0eXBlIFN5bnRheCA9IFN5bnRheFxuICBtb2R1bGUgdHlwZSBTeW50YXgyID0gU3ludGF4MlxuICBtb2R1bGUgdHlwZSBTeW50YXgzID0gU3ludGF4M1xuICBtb2R1bGUgdHlwZSBTeW50YXhfaW5kZXhlZCA9IFN5bnRheF9pbmRleGVkXG4gIG1vZHVsZSB0eXBlIFN5bnRheF9sb2NhbCA9IFN5bnRheF9sb2NhbFxuICBtb2R1bGUgdHlwZSBTeW50YXgyX2xvY2FsID0gU3ludGF4Ml9sb2NhbFxuICBtb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3ludGF4ID0gU193aXRob3V0X3N5bnRheFxuICBtb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3ludGF4X2xvY2FsID0gU193aXRob3V0X3N5bnRheF9sb2NhbFxuICBtb2R1bGUgdHlwZSBTID0gU1xuICBtb2R1bGUgdHlwZSBTMiA9IFMyXG4gIG1vZHVsZSB0eXBlIFMzID0gUzNcbiAgbW9kdWxlIHR5cGUgU19pbmRleGVkID0gU19pbmRleGVkXG4gIG1vZHVsZSB0eXBlIFNfbG9jYWwgPSBTX2xvY2FsXG4gIG1vZHVsZSB0eXBlIFMyX2xvY2FsID0gUzJfbG9jYWxcblxuICBtb2R1bGUgTWFrZSAoWCA6IEJhc2ljKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50XG4gIG1vZHVsZSBNYWtlMiAoWCA6IEJhc2ljMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBYLnRcbiAgbW9kdWxlIE1ha2UzIChYIDogQmFzaWMzKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50XG5cbiAgbW9kdWxlIE1ha2VfaW5kZXhlZCAoWCA6IEJhc2ljX2luZGV4ZWQpIDpcbiAgICBTX2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnRcblxuICBtb2R1bGUgTWFrZV9sb2NhbCAoWCA6IEJhc2ljX2xvY2FsKSA6IFNfbG9jYWwgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50XG4gIG1vZHVsZSBNYWtlMl9sb2NhbCAoWCA6IEJhc2ljMl9sb2NhbCkgOiBTMl9sb2NhbCB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBYLnRcblxuICAoKiogRGVmaW5lIGEgbW9uYWQgdGhyb3VnaCBhbiBpc29tb3JwaGlzbSB3aXRoIGFuIGV4aXN0aW5nIG1vbmFkLiBGb3IgZXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSAnYSB0ID0geyB2YWx1ZSA6ICdhIH1cblxuICAgICAgICBpbmNsdWRlIE1vbmFkLk9mX21vbmFkIChNb25hZC5JZGVudCkgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgICAgICAgbGV0IHRvX21vbmFkIHsgdmFsdWUgfSA9IHZhbHVlXG4gICAgICAgICAgICBsZXQgb2ZfbW9uYWQgdmFsdWUgPSB7IHZhbHVlIH1cbiAgICAgICAgICBlbmQpXG4gICAgICBdfSAqKVxuICBtb2R1bGUgT2ZfbW9uYWRcbiAgICAoTW9uYWQgOiBTKSAoTSA6IHNpZ1xuICAgICAgdHlwZSAnYSB0XG5cbiAgICAgIHZhbCB0b19tb25hZCA6ICdhIHQgLT4gJ2EgTW9uYWQudFxuICAgICAgdmFsIG9mX21vbmFkIDogJ2EgTW9uYWQudCAtPiAnYSB0XG4gICAgZW5kKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50XG5cbiAgbW9kdWxlIE9mX21vbmFkMlxuICAgIChNb25hZCA6IFMyKSAoTSA6IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgTW9uYWQudFxuICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYikgTW9uYWQudCAtPiAoJ2EsICdiKSB0XG4gICAgZW5kKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIE0udFxuXG4gIG1vZHVsZSBPZl9tb25hZDNcbiAgICAoTW9uYWQgOiBTMykgKE0gOiBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIE1vbmFkLnRcbiAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2IsICdjKSBNb25hZC50IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgZW5kKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgTS50XG5cbiAgbW9kdWxlIE9mX21vbmFkX2luZGV4ZWRcbiAgICAoTW9uYWQgOiBTX2luZGV4ZWQpIChNIDogc2lnXG4gICAgICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdpLCAnaikgTW9uYWQudCAtPiAoJ2EsICdpLCAnaikgdFxuICAgIGVuZCkgOiBTX2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSBNLnRcblxuICAoKiogQW4gZWFnZXIgaWRlbnRpdHkgbW9uYWQgd2l0aCBmdW5jdGlvbnMgaGVhdmlseSBhbm5vdGF0ZWQgd2l0aFxuICAgICAgW0BpbmxpbmVkXSBvciBbQGlubGluZSBoaW50XS5cblxuICAgICAgVGhlIGltcGxlbWVudGF0aW9uIGlzIG1hbnVhbGx5IHdyaXR0ZW4sIHJhdGhlciB0aGFuIGJlaW5nXG4gICAgICBjb25zdHJ1Y3RlZCBieSBbTW9uYWQuTWFrZV0uIFRoaXMgZ2l2ZXMgYmV0dGVyIGlubGluaW5nXG4gICAgICBndWFyYW50ZWVzLlxuICAqKVxuICBtb2R1bGUgSWRlbnQgOiBTX2xvY2FsIHdpdGggdHlwZSAnYSB0ID0gJ2FcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIE1vbmFkX2ludGZcblxubW9kdWxlIHR5cGUgQmFzaWNfZ2VuZXJhbCA9IHNpZ1xuICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcblxuICB2YWwgYmluZFxuICAgIDogICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAtPiBmOignYSAtPiAoJ2IsICdqLCAnaywgJ2QsICdlKSB0KVxuICAgIC0+ICgnYiwgJ2ksICdrLCAnZCwgJ2UpIHRcblxuICB2YWwgbWFwXG4gICAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZFxuICAgICAgfCBgQ3VzdG9tIG9mICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAgIF1cblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2ksICdkLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlbmVyYWwgKE0gOiBCYXNpY19nZW5lcmFsKSA9IHN0cnVjdFxuICBsZXQgYmluZCA9IE0uYmluZFxuICBsZXQgcmV0dXJuID0gTS5yZXR1cm5cbiAgbGV0IG1hcF92aWFfYmluZCBtYSB+ZiA9IE0uYmluZCBtYSB+ZjooZnVuIGEgLT4gTS5yZXR1cm4gKGYgYSkpXG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggTS5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19iaW5kIC0+IG1hcF92aWFfYmluZFxuICAgIHwgYEN1c3RvbSB4IC0+IHhcbiAgOztcblxuICBtb2R1bGUgTW9uYWRfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+Pj0gKSB0IGYgPSBiaW5kIHQgfmZcbiAgICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBlbmRcblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG4gICAgICBsZXQgYm90aCBhIGIgPSBhID4+PSBmdW4gYSAtPiBiID4+fCBmdW4gYiAtPiBhLCBiXG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbGV0IGpvaW4gdCA9IHQgPj49IGZ1biB0JyAtPiB0J1xuICBsZXQgaWdub3JlX20gdCA9IG1hcCB0IH5mOihmdW4gXyAtPiAoKSlcblxuICBsZXQgYWxsID1cbiAgICBsZXQgcmVjIGxvb3AgdnMgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKExpc3QucmV2IHZzKVxuICAgICAgfCB0IDo6IHRzIC0+IHQgPj49IGZ1biB2IC0+IGxvb3AgKHYgOjogdnMpIHRzXG4gICAgaW5cbiAgICBmdW4gdHMgLT4gbG9vcCBbXSB0c1xuICA7O1xuXG4gIGxldCByZWMgYWxsX3VuaXQgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV0dXJuICgpXG4gICAgfCB0IDo6IHRzIC0+IHQgPj49IGZ1biAoKSAtPiBhbGxfdW5pdCB0c1xuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX2luZGV4ZWQgKE0gOiBCYXNpY19pbmRleGVkKSA6XG4gIFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIE0udCA9IE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqKSBNLnRcbmVuZClcblxubW9kdWxlIE1ha2UzIChNIDogQmFzaWMzKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgTS50ID1cbk1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QsICdlKSBNLnRcbmVuZClcblxubW9kdWxlIE1ha2UyIChNIDogQmFzaWMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdkKSB0IDo9ICgnYSwgJ2QpIE0udCA9IE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QpIE0udFxuZW5kKVxuXG5tb2R1bGUgTWFrZSAoTSA6IEJhc2ljKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID0gTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gJ2EgTS50XG5lbmQpXG5cbm1vZHVsZSBNYWtlMl9sb2NhbCAoTSA6IEJhc2ljMl9sb2NhbCkgPSBzdHJ1Y3RcbiAgbGV0IGJpbmQgPSBNLmJpbmRcbiAgbGV0IHJldHVybiA9IE0ucmV0dXJuXG5cbiAgbGV0IG1hcF92aWFfYmluZCBtYSB+ZiA9XG4gICAgbGV0IHJlcyA9IE0uYmluZCBtYSB+ZjooZnVuIGEgLT4gTS5yZXR1cm4gKGYgYSkpIGluXG4gICAgcmVzXG4gIDs7XG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggTS5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19iaW5kIC0+IG1hcF92aWFfYmluZFxuICAgIHwgYEN1c3RvbSB4IC0+IHhcbiAgOztcblxuICBtb2R1bGUgTW9uYWRfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+Pj0gKSB0IGYgPSBiaW5kIHQgfmZcbiAgICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBlbmRcblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG5cbiAgICAgIGxldCBib3RoIGEgYiA9XG4gICAgICAgIGxldCByZXMgPVxuICAgICAgICAgIGJpbmQgYSB+ZjooZnVuIGEgLT5cbiAgICAgICAgICAgIGxldCByZXMgPSBtYXAgYiB+ZjooZnVuIGIgLT4gYSwgYikgaW5cbiAgICAgICAgICAgIHJlcylcbiAgICAgICAgaW5cbiAgICAgICAgcmVzXG4gICAgICA7O1xuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGxldCBqb2luIHQgPSB0ID4+PSBGbi5pZFxuXG4gIGxldCBpZ25vcmVfbSB0ID1cbiAgICBsZXQgcmVzID0gbWFwIHQgfmY6KGZ1biBfIC0+ICgpKSBpblxuICAgIHJlc1xuICA7O1xuXG4gIGxldCBhbGwgPVxuICAgIGxldCByZWMgbG9vcCB2cyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiAoTGlzdC5yZXYgdnMpXG4gICAgICB8IHQgOjogdHMgLT4gdCA+Pj0gZnVuIHYgLT4gbG9vcCAodiA6OiB2cykgdHNcbiAgICBpblxuICAgIGZ1biB0cyAtPiBsb29wIFtdIHRzXG4gIDs7XG5cbiAgbGV0IHJlYyBhbGxfdW5pdCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXR1cm4gKClcbiAgICB8IHQgOjogdHMgLT4gdCA+Pj0gZnVuICgpIC0+IGFsbF91bml0IHRzXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2VfbG9jYWwgKE0gOiBCYXNpY19sb2NhbCkgOiBTX2xvY2FsIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9XG5NYWtlMl9sb2NhbCAoc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICdhIE0udFxuZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWRfZ2VuZXJhbCAoTW9uYWQgOiBzaWdcbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmRcbiAgICA6ICAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2ssICdkLCAnZSkgdClcbiAgICAtPiAoJ2IsICdpLCAnaywgJ2QsICdlKSB0XG5cbiAgdmFsIG1hcCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpLCAnZCwgJ2UpIHRcbmVuZCkgKE0gOiBzaWdcbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5cbiAgdmFsIHRvX21vbmFkIDogKCdhLCAnaSwgJ2osICdkLCAnZSkgdCAtPiAoJ2EsICdpLCAnaiwgJ2QsICdlKSBNb25hZC50XG4gIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIE1vbmFkLnQgLT4gKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuZW5kKSA9XG5NYWtlX2dlbmVyYWwgKHN0cnVjdFxuICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaiwgJ2QsICdlKSBNLnRcblxuICBsZXQgcmV0dXJuIGEgPSBNLm9mX21vbmFkIChNb25hZC5yZXR1cm4gYSlcbiAgbGV0IGJpbmQgdCB+ZiA9IE0ub2ZfbW9uYWQgKE1vbmFkLmJpbmQgKE0udG9fbW9uYWQgdCkgfmY6KGZ1biBhIC0+IE0udG9fbW9uYWQgKGYgYSkpKVxuICBsZXQgbWFwID0gYEN1c3RvbSAoZnVuIHQgfmYgLT4gTS5vZl9tb25hZCAoTW9uYWQubWFwIChNLnRvX21vbmFkIHQpIH5mKSlcbmVuZClcblxubW9kdWxlIE9mX21vbmFkX2luZGV4ZWRcbiAgKE1vbmFkIDogU19pbmRleGVkKSAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgdmFsIG9mX21vbmFkIDogKCdhLCAnaSwgJ2opIE1vbmFkLnQgLT4gKCdhLCAnaSwgJ2opIHRcbiAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaikgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQzXG4gIChNb25hZCA6IFMzKSAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSBNb25hZC50XG4gICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYiwgJ2MpIE1vbmFkLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QsICdlKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQyXG4gIChNb25hZCA6IFMyKSAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSBNb25hZC50XG4gICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYikgTW9uYWQudCAtPiAoJ2EsICdiKSB0XG4gIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZFxuICAoTW9uYWQgOiBTKSAoTSA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHRvX21vbmFkIDogJ2EgdCAtPiAnYSBNb25hZC50XG4gICAgdmFsIG9mX21vbmFkIDogJ2EgTW9uYWQudCAtPiAnYSB0XG4gIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAnYSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAnYSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBJZGVudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYVxuXG4gIGxldFtAaW5saW5lXSBiaW5kIGEgfmYgPSAoZiBbQGlubGluZWQgaGludF0pIGFcbiAgbGV0W0BpbmxpbmVdIG1hcCBhIH5mID0gKGYgW0BpbmxpbmVkIGhpbnRdKSBhXG5cbiAgZXh0ZXJuYWwgcmV0dXJuIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pID0gXCIlaWRlbnRpdHlcIlxuXG4gIG1vZHVsZSBNb25hZF9pbmZpeCA9IHN0cnVjdFxuICAgIGxldFtAaW5saW5lXSAoID4+fCApIGEgZiA9IG1hcCBhIH5mXG4gICAgbGV0W0BpbmxpbmVdICggPj49ICkgYSBmID0gYmluZCBhIH5mXG4gIGVuZFxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cblxuICAgIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBtYXBcbiAgICAgIGxldFtAaW5saW5lXSBib3RoIGEgYiA9IGEsIGJcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICAgIGVuZFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICBlbmRcblxuICBleHRlcm5hbCBqb2luIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pID0gXCIlaWRlbnRpdHlcIlxuICBleHRlcm5hbCBpZ25vcmVfbSA6IChfW0Bsb2NhbF9vcHRdKSAtPiB1bml0ID0gXCIlaWdub3JlXCJcbiAgZXh0ZXJuYWwgYWxsX3VuaXQgOiAodW5pdCBsaXN0W0Bsb2NhbF9vcHRdKSAtPiB1bml0ID0gXCIlaWdub3JlXCJcbiAgZXh0ZXJuYWwgYWxsIDogKCdhIGxpc3RbQGxvY2FsX29wdF0pIC0+ICgnYSBsaXN0W0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFwcGxpY2F0aXZlX2ludGZcbm1vZHVsZSBMaXN0ID0gTGlzdDBcblxuKCoqIFRoaXMgbW9kdWxlIHNlcnZlcyBtb3N0bHkgYXMgYSBwYXJ0aWFsIGNoZWNrIHRoYXQgW1MyXSBhbmQgW1NdIGFyZSBpbiBzeW5jLCBidXRcbiAgICBhY3R1YWxseSBjYWxsaW5nIGl0IGlzIG9jY2FzaW9uYWxseSB1c2VmdWwuICopXG5tb2R1bGUgU190b19TMiAoWCA6IFMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MgKFQgOiBULlQpIChYIDogUzIpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICgnYSwgVC50KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAnYSB0ID0gKCdhLCBULnQpIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TMyAoWCA6IFMyKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG5lbmRcblxubW9kdWxlIFMzX3RvX1MyIChUIDogVC5UKSAoWCA6IFMzKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdkKSB0ID0gKCdhLCAnZCwgVC50KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkKSB0ID0gKCdhLCAnZCwgVC50KSBYLnRcbmVuZFxuXG5tb2R1bGUgUzNfdG9fUyAoVDEgOiBULlQpIChUMiA6IFQuVCkgKFggOiBTMykgOiBTIHdpdGggdHlwZSAnYSB0ID0gKCdhLCBUMS50LCBUMi50KSBYLnQgPVxuc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgJ2EgdCA9ICgnYSwgVDEudCwgVDIudCkgWC50XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogQmFzaWMzKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIGxldCAoIDwqPiApID0gYXBwbHlcbiAgbGV0IGRlcml2ZWRfbWFwIHQgfmYgPSByZXR1cm4gZiA8Kj4gdFxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIFgubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfYXBwbHkgLT4gZGVyaXZlZF9tYXBcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgbGV0IG1hcDIgdGEgdGIgfmYgPSBtYXAgfmYgdGEgPCo+IHRiXG4gIGxldCBtYXAzIHRhIHRiIHRjIH5mID0gbWFwIH5mIHRhIDwqPiB0YiA8Kj4gdGNcbiAgbGV0IGFsbCB0cyA9IExpc3QuZm9sZF9yaWdodCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjoobWFwMiB+ZjooZnVuIHggeHMgLT4geCA6OiB4cykpXG4gIGxldCBib3RoIHRhIHRiID0gbWFwMiB0YSB0YiB+ZjooZnVuIGEgYiAtPiBhLCBiKVxuICBsZXQgKCAqPiApIHUgdiA9IHJldHVybiAoZnVuICgpIHkgLT4geSkgPCo+IHUgPCo+IHZcbiAgbGV0ICggPCogKSB1IHYgPSByZXR1cm4gKGZ1biB4ICgpIC0+IHgpIDwqPiB1IDwqPiB2XG4gIGxldCBhbGxfdW5pdCB0cyA9IExpc3QuZm9sZCB0cyB+aW5pdDoocmV0dXJuICgpKSB+ZjooICo+IClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICBsZXQgKCAqPiApID0gKCAqPiApXG4gICAgbGV0ICggPCogKSA9ICggPCogKVxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZTIgKFggOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50ID0gTWFrZTMgKHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG5lbmQpXG5cbm1vZHVsZSBNYWtlIChYIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPSBNYWtlMiAoc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudFxuZW5kKVxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4M1xuICAoWCA6IEZvcl9sZXRfc3ludGF4MykgKEludGYgOiBzaWdcbiAgICBtb2R1bGUgdHlwZSBTXG4gIGVuZClcbiAgKEltcGwgOiBJbnRmLlMpID1cbnN0cnVjdFxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gSW1wbFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4MlxuICAoWCA6IEZvcl9sZXRfc3ludGF4MikgKEludGYgOiBzaWdcbiAgICBtb2R1bGUgdHlwZSBTXG4gIGVuZClcbiAgKEltcGwgOiBJbnRmLlMpID1cbiAgTWFrZV9sZXRfc3ludGF4M1xuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuXG4gICAgICB0eXBlICgnYSwgJ2QsIF8pIHQgPSAoJ2EsICdkKSBYLnRcbiAgICBlbmQpXG4gICAgKEludGYpXG4gICAgKEltcGwpXG5cbm1vZHVsZSBNYWtlX2xldF9zeW50YXhcbiAgKFggOiBGb3JfbGV0X3N5bnRheCkgKEludGYgOiBzaWdcbiAgICBtb2R1bGUgdHlwZSBTXG4gIGVuZClcbiAgKEltcGwgOiBJbnRmLlMpID1cbiAgTWFrZV9sZXRfc3ludGF4MlxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuXG4gICAgICB0eXBlICgnYSwgXykgdCA9ICdhIFgudFxuICAgIGVuZClcbiAgICAoSW50ZilcbiAgICAoSW1wbClcblxuKCoqIFRoaXMgZnVuY3RvciBjbG9zZWx5IHJlc2VtYmxlcyBbTWFrZTNdLCBhbmQgaW5kZWVkIGl0IGNvdWxkIGJlIGltcGxlbWVudGVkXG4gICAgbXVjaCBzaG9ydGVyIGluIHRlcm1zIG9mIFtNYWtlM10uIEhvd2V2ZXIsIHdlIGltcGxlbWVudCBpdCBieSBoYW5kIHNvIHRoYXRcbiAgICB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9ucyBhcmUgbW9yZSBlZmZpY2llbnQsIGUuZy4gdXNpbmcgW21hcDJdIGRpcmVjdGx5IGluc3RlYWQgb2ZcbiAgICBkZWZpbmluZyBbYXBwbHldIGluIHRlcm1zIG9mIGl0IGFuZCB0aGVuIFttYXAyXSBpbiB0ZXJtcyBvZiB0aGF0LiBGb3IgbW9zdFxuICAgIGFwcGxpY2F0aXZlcyB0aGlzIGRvZXMgbm90IG1hdHRlciwgYnV0IGZvciBzb21lIChzdWNoIGFzIEJvbnNhaS5WYWx1ZS50KSwgaXQgaGFzIGFcbiAgICBsYXJnZXIgaW1wYWN0LiAqKVxubW9kdWxlIE1ha2UzX3VzaW5nX21hcDIgKFggOiBCYXNpYzNfdXNpbmdfbWFwMikgOlxuICBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICBsZXQgYXBwbHkgdGYgdGEgPSBtYXAyIHRmIHRhIH5mOihmdW4gZiBhIC0+IGYgYSlcbiAgbGV0ICggPCo+ICkgPSBhcHBseVxuICBsZXQgZGVyaXZlZF9tYXAgdCB+ZiA9IHJldHVybiBmIDwqPiB0XG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggWC5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19tYXAyIC0+IGRlcml2ZWRfbWFwXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGxldCBib3RoIHRhIHRiID0gbWFwMiB0YSB0YiB+ZjooZnVuIGEgYiAtPiBhLCBiKVxuICBsZXQgbWFwMyB0YSB0YiB0YyB+ZiA9IG1hcDIgKG1hcDIgdGEgdGIgfmYpIHRjIH5mOihmdW4gZmFiIGMgLT4gZmFiIGMpXG4gIGxldCBhbGwgdHMgPSBMaXN0LmZvbGRfcmlnaHQgdHMgfmluaXQ6KHJldHVybiBbXSkgfmY6KG1hcDIgfmY6KGZ1biB4IHhzIC0+IHggOjogeHMpKVxuICBsZXQgKCAqPiApIHUgdiA9IG1hcDIgdSB2IH5mOihmdW4gKCkgeSAtPiB5KVxuICBsZXQgKCA8KiApIHUgdiA9IG1hcDIgdSB2IH5mOihmdW4geCAoKSAtPiB4KVxuICBsZXQgYWxsX3VuaXQgdHMgPSBMaXN0LmZvbGQgdHMgfmluaXQ6KHJldHVybiAoKSkgfmY6KCAqPiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPCo+ICkgPSAoIDwqPiApXG4gICAgbGV0ICggKj4gKSA9ICggKj4gKVxuICAgIGxldCAoIDwqICkgPSAoIDwqIClcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2UyX3VzaW5nX21hcDIgKFggOiBCYXNpYzJfdXNpbmdfbWFwMikgOlxuICBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBYLnQgPSBNYWtlM191c2luZ19tYXAyIChzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuZW5kKVxuXG5tb2R1bGUgTWFrZV91c2luZ19tYXAyIChYIDogQmFzaWNfdXNpbmdfbWFwMikgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudCA9XG5NYWtlMl91c2luZ19tYXAyIChzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmQpXG5cbm1vZHVsZSBNYWtlM191c2luZ19tYXAyX2xvY2FsIChYIDogQmFzaWMzX3VzaW5nX21hcDJfbG9jYWwpIDpcbiAgUzNfbG9jYWwgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgbGV0IGFwcGx5IHRmIHRhID0gbWFwMiB0ZiB0YSB+ZjooZnVuIGYgYSAtPiBmIGEpXG4gIGxldCAoIDwqPiApID0gYXBwbHlcbiAgbGV0IGRlcml2ZWRfbWFwIHQgfmYgPSBtYXAyIH5mOihmdW4gKCkgLT4gZikgKHJldHVybiAoKSkgdCBbQG5vbnRhaWxdXG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggWC5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19tYXAyIC0+IGRlcml2ZWRfbWFwXG4gICAgfCBgQ3VzdG9tIG1hcCAtPiBtYXBcbiAgOztcblxuICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBsZXQgYm90aCB0YSB0YiA9IG1hcDIgdGEgdGIgfmY6KGZ1biBhIGIgLT4gYSwgYilcblxuICBsZXQgbWFwMyB0YSB0YiB0YyB+ZiA9XG4gICAgbGV0IHJlcyA9IG1hcDIgKGJvdGggdGEgdGIpIHRjIH5mOihmdW4gKGEsIGIpIGMgLT4gZiBhIGIgYykgaW5cbiAgICByZXNcbiAgOztcblxuICBsZXQgYWxsIHRzID0gTGlzdC5mb2xkX3JpZ2h0IHRzIH5pbml0OihyZXR1cm4gW10pIH5mOihtYXAyIH5mOihmdW4geCB4cyAtPiB4IDo6IHhzKSlcbiAgbGV0ICggKj4gKSB1IHYgPSBtYXAyIHUgdiB+ZjooZnVuICgpIHkgLT4geSlcbiAgbGV0ICggPCogKSB1IHYgPSBtYXAyIHUgdiB+ZjooZnVuIHggKCkgLT4geClcbiAgbGV0IGFsbF91bml0IHRzID0gTGlzdC5mb2xkIHRzIH5pbml0OihyZXR1cm4gKCkpIH5mOiggKj4gKVxuXG4gIG1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoIDwqPiApID0gKCA8Kj4gKVxuICAgIGxldCAoICo+ICkgPSAoICo+IClcbiAgICBsZXQgKCA8KiApID0gKCA8KiApXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBNYWtlMl91c2luZ19tYXAyX2xvY2FsIChYIDogQmFzaWMyX3VzaW5nX21hcDJfbG9jYWwpIDpcbiAgUzJfbG9jYWwgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50ID0gTWFrZTNfdXNpbmdfbWFwMl9sb2NhbCAoc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbmVuZClcblxubW9kdWxlIE1ha2VfdXNpbmdfbWFwMl9sb2NhbCAoWCA6IEJhc2ljX3VzaW5nX21hcDJfbG9jYWwpIDpcbiAgU19sb2NhbCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPSBNYWtlMl91c2luZ19tYXAyX2xvY2FsIChzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmQpXG5cbm1vZHVsZSBPZl9tb25hZDIgKE0gOiBNb25hZC5TMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBNLnQgPSBNYWtlMiAoc3RydWN0XG4gIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UpIE0udFxuXG4gIGxldCByZXR1cm4gPSBNLnJldHVyblxuICBsZXQgYXBwbHkgbWYgbXggPSBNLmJpbmQgbWYgfmY6KGZ1biBmIC0+IE0ubWFwIG14IH5mKVxuICBsZXQgbWFwID0gYEN1c3RvbSBNLm1hcFxuZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQgKE0gOiBNb25hZC5TKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID0gT2ZfbW9uYWQyIChzdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSAoJ2EsIF8pIHQgPSAnYSBNLnRcbmVuZClcblxubW9kdWxlIENvbXBvc2UgKEYgOiBTKSAoRyA6IFMpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICdhIEYudCBHLnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgRi50IEcudFxuXG4gIGluY2x1ZGUgTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4gYSA9IEcucmV0dXJuIChGLnJldHVybiBhKVxuICAgIGxldCBhcHBseSB0ZiB0eCA9IEcuYXBwbHkgKEcubWFwIH5mOkYuYXBwbHkgdGYpIHR4XG4gICAgbGV0IGN1c3RvbV9tYXAgdCB+ZiA9IEcubWFwIH5mOihGLm1hcCB+ZikgdFxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIGN1c3RvbV9tYXBcbiAgZW5kKVxuZW5kXG5cbm1vZHVsZSBQYWlyIChGIDogUykgKEcgOiBTKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAnYSBGLnQgKiAnYSBHLnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgRi50ICogJ2EgRy50XG5cbiAgaW5jbHVkZSBNYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiBhID0gRi5yZXR1cm4gYSwgRy5yZXR1cm4gYVxuICAgIGxldCBhcHBseSB0ZiB0eCA9IEYuYXBwbHkgKGZzdCB0ZikgKGZzdCB0eCksIEcuYXBwbHkgKHNuZCB0ZikgKHNuZCB0eClcbiAgICBsZXQgY3VzdG9tX21hcCB0IH5mID0gRi5tYXAgfmYgKGZzdCB0KSwgRy5tYXAgfmYgKHNuZCB0KVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIGN1c3RvbV9tYXBcbiAgZW5kKVxuZW5kXG5cbm1vZHVsZSBJZGVudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYVxuXG4gIGluY2x1ZGUgTWFrZV91c2luZ19tYXAyX2xvY2FsIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IEZuLmlkXG4gICAgbGV0IG1hcDIgYSBiIH5mID0gZiBhIGJcbiAgICBsZXQgbWFwID0gYEN1c3RvbSAoZnVuIGEgfmYgLT4gZiBhKVxuICBlbmQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICgnYSwgJ3dpdG5lc3MpIHQgPVxuICB7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgfVxuXG50eXBlICgnYSwgJ2IpIGNvbXBhcmF0b3IgPSAoJ2EsICdiKSB0XG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAodCwgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EgdCwgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIHR5cGUgU19mYyA9IHNpZ1xuICB0eXBlIGNvbXBhcmFibGVfdFxuXG4gIGluY2x1ZGUgUyB3aXRoIHR5cGUgdCA6PSBjb21wYXJhYmxlX3RcbmVuZFxuXG5tb2R1bGUgTW9kdWxlID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9IChtb2R1bGUgUyB3aXRoIHR5cGUgdCA9ICdhIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdiKVxuZW5kXG5cbmxldCBvZl9tb2R1bGUgKHR5cGUgYSBiKSAoKG1vZHVsZSBNKSA6IChhLCBiKSBNb2R1bGUudCkgPSBNLmNvbXBhcmF0b3JcblxubGV0IHRvX21vZHVsZSAodHlwZSBhIGIpIHQgOiAoYSwgYikgTW9kdWxlLnQgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIHR5cGUgdCA9IGFcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGJcblxuICAgIGxldCBjb21wYXJhdG9yID0gdFxuICBlbmQpXG47O1xuXG5sZXQgbWFrZSAodHlwZSB0KSB+Y29tcGFyZSB+c2V4cF9vZl90ID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICB0eXBlIGNvbXBhcmFibGVfdCA9IHRcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGVuZCA6IFNfZmNcbiAgICB3aXRoIHR5cGUgY29tcGFyYWJsZV90ID0gdClcbjs7XG5cbm1vZHVsZSBTX3RvX1MxIChTIDogUykgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gUy50XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gUy5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBvcGVuIFNcblxuICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgTWFrZSAoTSA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IE0ueyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoTSA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgY29tcGFyZSA6ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgdmFsIHNleHBfb2ZfdCA6ICdhIHQgLT4gU2V4cC50XG5lbmQpID1cbnN0cnVjdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gTS57IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2FcblxuICBpbmNsdWRlIE1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYVxuXG4gICAgbGV0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgICBsZXQgc2V4cF9vZl90IF8gPSBTZXhwLkF0b20gXCJfXCJcbiAgZW5kKVxuZW5kXG5cbm1vZHVsZSB0eXBlIERlcml2ZWQgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgISdjbXAgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsICdjbXApIGNvbXBhcmF0b3IgLT4gKCdhIHQsICdjbXAgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWQgKE0gOiBzaWdcbiAgdHlwZSAnYSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmQpID1cbnN0cnVjdFxuICB0eXBlICEnY21wIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmU7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoISdjbXBfYSwgISdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3JcbiAgICA6ICAoJ2EsICdjbXBfYSkgY29tcGFyYXRvclxuICAgIC0+ICgnYiwgJ2NtcF9iKSBjb21wYXJhdG9yXG4gICAgLT4gKCgnYSwgJ2IpIHQsICgnY21wX2EsICdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWQyIChNIDogc2lnXG4gIHR5cGUgKCdhLCAnYikgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICB2YWwgc2V4cF9vZl90XG4gICAgOiAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAoISdjbXBfYSwgISdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSBiID1cbiAgICB7IGNvbXBhcmUgPSBNLmNvbXBhcmUgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgIDsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgYi5zZXhwX29mX3RcbiAgICB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZF9waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdjbXAgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3JcbiAgICA6ICAoJ2EsICdjbXApIGNvbXBhcmF0b3JcbiAgICAtPiAoKCdhLCBfKSB0LCAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkX3BoYW50b20gKE0gOiBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgdmFsIGNvbXBhcmUgOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cC50KSAtPiAoJ2EsIF8pIHQgLT4gU2V4cC50XG5lbmQpID1cbnN0cnVjdFxuICB0eXBlICdjbXBfYSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciBhID1cbiAgICB7IGNvbXBhcmUgPSBNLmNvbXBhcmUgYS5jb21wYXJlOyBzZXhwX29mX3QgPSBNLnNleHBfb2ZfdCBhLnNleHBfb2ZfdCB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZDJfcGhhbnRvbSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjKSB0XG4gIHR5cGUgKCEnY21wX2EsICEnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yXG4gICAgOiAgKCdhLCAnY21wX2EpIGNvbXBhcmF0b3JcbiAgICAtPiAoJ2IsICdjbXBfYikgY29tcGFyYXRvclxuICAgIC0+ICgoJ2EsICdiLCBfKSB0LCAoJ2NtcF9hLCAnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkMl9waGFudG9tIChNIDogc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICB2YWwgY29tcGFyZVxuICAgIDogICgnYSAtPiAnYSAtPiBpbnQpXG4gICAgLT4gKCdiIC0+ICdiIC0+IGludClcbiAgICAtPiAoJ2EsICdiLCAnYykgdFxuICAgIC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgLT4gaW50XG5cbiAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwLnQpIC0+ICgnYiAtPiBTZXhwLnQpIC0+ICgnYSwgJ2IsIF8pIHQgLT4gU2V4cC50XG5lbmQpID1cbnN0cnVjdFxuICB0eXBlICghJ2NtcF9hLCAhJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciBhIGIgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgOyBzZXhwX29mX3QgPSBNLnNleHBfb2ZfdCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdFxuICAgIH1cbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdmLCAncykgdCA9XG4gIHwgRmlyc3Qgb2YgJ2ZcbiAgfCBTZWNvbmQgb2YgJ3NcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZV9fbG9jYWwgOlxuICAgICAgJ2YgJ3MuICgnZiAtPiAnZiAtPiBpbnQpIC0+ICgncyAtPiAncyAtPiBpbnQpIC0+ICgnZiwgJ3MpIHQgLT4gKCdmLCAncykgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fZiBfY21wX19zIGFfXzAwN18gYl9fMDA4XyAtPlxuICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwN18gYl9fMDA4X1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDA3XywgYl9fMDA4XyB3aXRoXG4gICAgfCBGaXJzdCBfYV9fMDA5XywgRmlyc3QgX2JfXzAxMF8gLT4gX2NtcF9fZiBfYV9fMDA5XyBfYl9fMDEwX1xuICAgIHwgRmlyc3QgXywgXyAtPiAtMVxuICAgIHwgXywgRmlyc3QgXyAtPiAxXG4gICAgfCBTZWNvbmQgX2FfXzAxMV8sIFNlY29uZCBfYl9fMDEyXyAtPiBfY21wX19zIF9hX18wMTFfIF9iX18wMTJfKVxuOztcblxubGV0IGNvbXBhcmUgOlxuICAgICAgJ2YgJ3MuICgnZiAtPiAnZiAtPiBpbnQpIC0+ICgncyAtPiAncyAtPiBpbnQpIC0+ICgnZiwgJ3MpIHQgLT4gKCdmLCAncykgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fZiBfY21wX19zIGFfXzAwMV8gYl9fMDAyXyAtPlxuICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwMV8gYl9fMDAyX1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDAxXywgYl9fMDAyXyB3aXRoXG4gICAgfCBGaXJzdCBfYV9fMDAzXywgRmlyc3QgX2JfXzAwNF8gLT4gX2NtcF9fZiBfYV9fMDAzXyBfYl9fMDA0X1xuICAgIHwgRmlyc3QgXywgXyAtPiAtMVxuICAgIHwgXywgRmlyc3QgXyAtPiAxXG4gICAgfCBTZWNvbmQgX2FfXzAwNV8sIFNlY29uZCBfYl9fMDA2XyAtPiBfY21wX19zIF9hX18wMDVfIF9iX18wMDZfKVxuOztcblxubGV0IGhhc2hfZm9sZF90XG4gIDogdHlwZSBmIHMuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBmIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHMgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+IChmLCBzKSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfZiBfaGFzaF9mb2xkX3MgaHN2IGFyZyAtPlxuICBtYXRjaCBhcmcgd2l0aFxuICB8IEZpcnN0IF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9mIGhzdiBfYTBcbiAgfCBTZWNvbmQgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX3MgaHN2IF9hMFxuOztcblxubGV0IHRfb2Zfc2V4cCA6XG4gICAgICAnZiAncy5cbiAgICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2YpIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ3MpIC0+IFNleHBsaWIwLlNleHAudCAtPiAoJ2YsICdzKSB0XG4gID1cbiAgZnVuICh0eXBlIGZfXzAyOV8gc19fMDMwXylcbiAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBmX18wMjlfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IHNfXzAzMF8pIC0+IFNleHBsaWIwLlNleHAudFxuICAgIC0+IChmX18wMjlfLCBzX18wMzBfKSB0KSAtPlxuICBsZXQgZXJyb3Jfc291cmNlX18wMTdfID0gXCJlaXRoZXIwLm1sLnRcIiBpblxuICBmdW4gX29mX2ZfXzAxM18gX29mX3NfXzAxNF8gLT4gZnVuY3Rpb25cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJmaXJzdFwiIHwgXCJGaXJzdFwiKSBhcyBfdGFnX18wMjBfKSA6OiBzZXhwX2FyZ3NfXzAyMV8pIGFzXG4gICAgICBfc2V4cF9fMDE5XyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDIxXyB3aXRoXG4gICAgICAgfCBhcmcwX18wMjJfIDo6IFtdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDIzXyA9IF9vZl9mX18wMTNfIGFyZzBfXzAyMl8gaW5cbiAgICAgICAgIEZpcnN0IHJlczBfXzAyM19cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMTdfXG4gICAgICAgICAgIF90YWdfXzAyMF9cbiAgICAgICAgICAgX3NleHBfXzAxOV8pXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwic2Vjb25kXCIgfCBcIlNlY29uZFwiKSBhcyBfdGFnX18wMjVfKSA6OiBzZXhwX2FyZ3NfXzAyNl8pIGFzXG4gICAgICBfc2V4cF9fMDI0XyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDI2XyB3aXRoXG4gICAgICAgfCBhcmcwX18wMjdfIDo6IFtdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDI4XyA9IF9vZl9zX18wMTRfIGFyZzBfXzAyN18gaW5cbiAgICAgICAgIFNlY29uZCByZXMwX18wMjhfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDE3X1xuICAgICAgICAgICBfdGFnX18wMjVfXG4gICAgICAgICAgIF9zZXhwX18wMjRfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImZpcnN0XCIgfCBcIkZpcnN0XCIpIGFzIHNleHBfXzAxOF8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMTdfIHNleHBfXzAxOF9cbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzZWNvbmRcIiB8IFwiU2Vjb25kXCIpIGFzIHNleHBfXzAxOF8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMTdfIHNleHBfXzAxOF9cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDE2XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDE3XyBzZXhwX18wMTZfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDE2XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMTdfIHNleHBfXzAxNl9cbiAgICB8IHNleHBfXzAxNl8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAxN18gc2V4cF9fMDE2X1xuOztcblxubGV0IHNleHBfb2ZfdCA6XG4gICAgICAnZiAncy5cbiAgICAgICgnZiAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgncyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnZiwgJ3MpIHQgLT4gU2V4cGxpYjAuU2V4cC50XG4gID1cbiAgZnVuICh0eXBlIGZfXzAzN18gc19fMDM4XylcbiAgICA6ICAoKGZfXzAzN18gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoc19fMDM4XyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKGZfXzAzN18sIHNfXzAzOF8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICBmdW4gX29mX2ZfXzAzMV8gX29mX3NfXzAzMl8gLT4gZnVuY3Rpb25cbiAgfCBGaXJzdCBhcmcwX18wMzNfIC0+XG4gICAgbGV0IHJlczBfXzAzNF8gPSBfb2ZfZl9fMDMxXyBhcmcwX18wMzNfIGluXG4gICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRmlyc3RcIjsgcmVzMF9fMDM0XyBdXG4gIHwgU2Vjb25kIGFyZzBfXzAzNV8gLT5cbiAgICBsZXQgcmVzMF9fMDM2XyA9IF9vZl9zX18wMzJfIGFyZzBfXzAzNV8gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTZWNvbmRcIjsgcmVzMF9fMDM2XyBdXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOlxuICAgICAgJ2YgJ3MuXG4gICAgICAnZiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gJ3MgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgIC0+ICgnZiwgJ3MpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBmdW4gXydmX3NleHBfZ3JhbW1hciBfJ3Nfc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJGaXJzdFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nZl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiU2Vjb25kXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydzX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5bQEBAZW5kXVxuIiwiKCogVGhlIHR5cGUgW3RdIHNob3VsZCBiZSBhYnN0cmFjdCB0byBtYWtlIHRoZSBmc2V0IGFuZCBzZXQgZnVuY3Rpb25zIHVuYXZhaWxhYmxlXG4gICBmb3IgcHJpdmF0ZSB0eXBlcyBhdCB0aGUgbGV2ZWwgb2YgdHlwZXMgKGFuZCBub3QgYnkgcHV0dGluZyBOb25lIGluIHRoZSBmaWVsZCkuXG4gICBVbmZvcnR1bmF0ZWx5LCBtYWtpbmcgdGhlIHR5cGUgYWJzdHJhY3QgbWVhbnMgdGhhdCB3aGVuIGNyZWF0aW5nIGZpZWxkcyAodGhyb3VnaFxuICAgYSBbY3JlYXRlXSBmdW5jdGlvbikgdmFsdWUgcmVzdHJpY3Rpb24ga2lja3MgaW4uIFRoaXMgaXMgd29ya2VkIGFyb3VuZCBieSBpbnN0ZWFkXG4gICBub3QgbWFraW5nIHRoZSB0eXBlIGFic3RyYWN0LCBidXQgZm9yY2luZyBhbnlvbmUgYnJlYWtpbmcgdGhlIGFic3RyYWN0aW9uIHRvIHVzZVxuICAgdGhlIFtGb3JfZ2VuZXJhdGVkX2NvZGVdIG1vZHVsZSwgbWFraW5nIGl0IG9idmlvdXMgdG8gYW55IHJlYWRlciB0aGF0IHNvbWV0aGluZyB1Z2x5XG4gICBpcyBnb2luZyBvbi5cbiAgIHRfd2l0aF9wZXJtIChhbmQgZGVyaXZhdGl2ZXMpIGlzIHRoZSB0eXBlIHRoYXQgdXNlcnMgcmVhbGx5IHVzZS4gSXQgaXMgYSBjb25zdHJ1Y3RvclxuICAgYmVjYXVzZTpcbiAgIDEuIGl0IG1ha2VzIHR5cGUgZXJyb3JzIG1vcmUgcmVhZGFibGUgKGxlc3MgYWxpYXNpbmcpXG4gICAyLiB0aGUgdHlwZXIgaW4gb2NhbWwgNC4wMSBhbGxvd3MgdGhpczpcblxuICAge1tcbiAgICAgbW9kdWxlIEEgPSBzdHJ1Y3RcbiAgICAgICB0eXBlIHQgPSB7YSA6IGludH1cbiAgICAgZW5kXG4gICAgIHR5cGUgdCA9IEEudFxuICAgICBsZXQgZiAoeCA6IHQpID0geC5hXG4gICBdfVxuXG4gICAoYWx0aG91Z2ggd2l0aCBXYXJuaW5nIDQwOiBhIGlzIHVzZWQgb3V0IG9mIHNjb3BlKVxuICAgd2hpY2ggbWVhbnMgdGhhdCBpZiBbdF93aXRoX3Blcm1dIHdhcyByZWFsbHkgYW4gYWxpYXMgb24gW0Zvcl9nZW5lcmF0ZWRfY29kZS50XSxcbiAgIHBlb3BsZSBjb3VsZCBzYXkgW3Quc2V0dGVyXSBhbmQgYnJlYWsgdGhlIGFic3RyYWN0aW9uIHdpdGggbm8gaW5kaWNhdGlvbiB0aGF0XG4gICBzb21ldGhpbmcgdWdseSBpcyBnb2luZyBvbiBpbiB0aGUgc291cmNlIGNvZGUuXG4gICBUaGUgd2FybmluZyBpcyAoSSB0aGluaykgZm9yIHBlb3BsZSB3aG8gd2FudCB0byBtYWtlIHRoZWlyIGNvZGUgY29tcGF0aWJsZSB3aXRoXG4gICBwcmV2aW91cyB2ZXJzaW9ucyBvZiBvY2FtbCwgc28gd2UgbWF5IHZlcnkgd2VsbCB0dXJuIGl0IG9mZi5cblxuICAgVGhlIHR5cGUgdF93aXRoX3Blcm0gY291bGQgYWxzbyBoYXZlIGJlZW4gYSBbdW5pdCAtPiBGb3JfZ2VuZXJhdGVkX2NvZGUudF0gdG8gd29ya1xuICAgYXJvdW5kIHZhbHVlIHJlc3RyaWN0aW9uIGFuZCB0aGVuIFtGb3JfZ2VuZXJhdGVkX2NvZGUudF0gd291bGQgaGF2ZSBiZWVuIGEgcHJvcGVyXG4gICBhYnN0cmFjdCB0eXBlLCBidXQgaXQgbG9va3MgbGlrZSBpdCBjb3VsZCBpbXBhY3QgcGVyZm9ybWFuY2UgKGZvciBleGFtcGxlLCBhIGZvbGQgb24gYVxuICAgcmVjb3JkIHR5cGUgd2l0aCA0MCBmaWVsZHMgd291bGQgYWN0dWFsbHkgYWxsb2NhdGUgdGhlIDQwIFtGb3JfZ2VuZXJhdGVkX2NvZGUudF0ncyBhdFxuICAgZXZlcnkgc2luZ2xlIGZvbGQuKSAqKVxuXG5tb2R1bGUgRm9yX2dlbmVyYXRlZF9jb2RlID0gc3RydWN0XG4gIHR5cGUgKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIHQgPVxuICAgIHsgZm9yY2VfdmFyaWFuY2UgOiAncGVybSAtPiB1bml0XG4gICAgOyAoKiBmb3JjZSBbdF0gdG8gYmUgY29udHJhdmFyaWFudCBpbiBbJ3Blcm1dLCBiZWNhdXNlIHBoYW50b20gdHlwZSB2YXJpYWJsZXMgb25cbiAgICAgICAgIGNvbmNyZXRlIHR5cGVzIGRvbid0IHdvcmsgdGhhdCB3ZWxsIG90aGVyd2lzZSAodXNpbmcgOj4gY2FuIHJlbW92ZSB0aGVtIGVhc2lseSkgKilcbiAgICAgIG5hbWUgOiBzdHJpbmdcbiAgICA7IHNldHRlciA6ICgncmVjb3JkIC0+ICdmaWVsZCAtPiB1bml0KSBvcHRpb25cbiAgICA7IGdldHRlciA6ICdyZWNvcmQgLT4gJ2ZpZWxkXG4gICAgOyBmc2V0IDogJ3JlY29yZCAtPiAnZmllbGQgLT4gJ3JlY29yZFxuICAgIH1cblxuICBsZXQgb3BhcXVlX2lkZW50aXR5ID0gU3lzMC5vcGFxdWVfaWRlbnRpdHlcbmVuZFxuXG50eXBlICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybSA9XG4gIHwgRmllbGQgb2YgKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIEZvcl9nZW5lcmF0ZWRfY29kZS50XG5bQEB1bmJveGVkXVxuXG50eXBlICgncmVjb3JkLCAnZmllbGQpIHQgPSAoWyBgUmVhZCB8IGBTZXRfYW5kX2NyZWF0ZSBdLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtXG50eXBlICgncmVjb3JkLCAnZmllbGQpIHJlYWRvbmx5X3QgPSAoWyBgUmVhZCBdLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtXG5cbmxldCBuYW1lIChGaWVsZCBmaWVsZCkgPSBmaWVsZC5uYW1lXG5sZXQgZ2V0IChGaWVsZCBmaWVsZCkgciA9IGZpZWxkLmdldHRlciByXG5sZXQgZnNldCAoRmllbGQgZmllbGQpIHIgdiA9IGZpZWxkLmZzZXQgciB2XG5sZXQgc2V0dGVyIChGaWVsZCBmaWVsZCkgPSBmaWVsZC5zZXR0ZXJcblxudHlwZSAoJ3Blcm0sICdyZWNvcmQsICdyZXN1bHQpIHVzZXIgPVxuICB7IGYgOiAnZmllbGQuICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybSAtPiAncmVzdWx0IH1cblxubGV0IG1hcCAoRmllbGQgZmllbGQpIHIgfmYgPSBmaWVsZC5mc2V0IHIgKGYgKGZpZWxkLmdldHRlciByKSlcblxubGV0IHVwZGF0ZXIgKEZpZWxkIGZpZWxkKSA9XG4gIG1hdGNoIGZpZWxkLnNldHRlciB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBzZXR0ZXIgLT4gU29tZSAoZnVuIHIgfmYgLT4gc2V0dGVyIHIgKGYgKGZpZWxkLmdldHRlciByKSkpXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN5cyA9IFN5czBcblxubGV0IGNvbnZlcnRfZmFpbHVyZSB4IGEgYiB0b19zdHJpbmcgPVxuICBQcmludGYuZmFpbHdpdGhmXG4gICAgXCJjb252ZXJzaW9uIGZyb20gJXMgdG8gJXMgZmFpbGVkOiAlcyBpcyBvdXQgb2YgcmFuZ2VcIlxuICAgIGFcbiAgICBiXG4gICAgKHRvX3N0cmluZyB4KVxuICAgICgpXG4gIFtAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgbnVtX2JpdHNfaW50ID0gU3lzLmludF9zaXplX2luX2JpdHNcbmxldCBudW1fYml0c19pbnQzMiA9IDMyXG5sZXQgbnVtX2JpdHNfaW50NjQgPSA2NFxubGV0IG51bV9iaXRzX25hdGl2ZWludCA9IFdvcmRfc2l6ZS5udW1fYml0cyBXb3JkX3NpemUud29yZF9zaXplXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA9IDYzIHx8IG51bV9iaXRzX2ludCA9IDMxIHx8IG51bV9iaXRzX2ludCA9IDMyKVxubGV0IG1pbl9pbnQzMiA9IFN0ZGxpYi5JbnQzMi5taW5faW50XG5sZXQgbWF4X2ludDMyID0gU3RkbGliLkludDMyLm1heF9pbnRcbmxldCBtaW5faW50NjQgPSBTdGRsaWIuSW50NjQubWluX2ludFxubGV0IG1heF9pbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5tYXhfaW50XG5sZXQgbWluX25hdGl2ZWludCA9IFN0ZGxpYi5OYXRpdmVpbnQubWluX2ludFxubGV0IG1heF9uYXRpdmVpbnQgPSBTdGRsaWIuTmF0aXZlaW50Lm1heF9pbnRcbmxldCBpbnRfdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9pbnRcbmxldCBpbnQzMl90b19zdHJpbmcgPSBTdGRsaWIuSW50MzIudG9fc3RyaW5nXG5sZXQgaW50NjRfdG9fc3RyaW5nID0gU3RkbGliLkludDY0LnRvX3N0cmluZ1xubGV0IG5hdGl2ZWludF90b19zdHJpbmcgPSBTdGRsaWIuTmF0aXZlaW50LnRvX3N0cmluZ1xuXG4oKiBpbnQgPC0+IGludDMyICopXG5cbmxldCBpbnRfdG9faW50MzJfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnRcIiBcImludDMyXCIgaW50X3RvX3N0cmluZ1xubGV0IGludDMyX3RvX2ludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDMyXCIgXCJpbnRcIiBpbnQzMl90b19zdHJpbmdcbmxldCBpbnQzMl90b19pbnRfdHJ1bmMgPSBTdGRsaWIuSW50MzIudG9faW50XG5sZXQgaW50X3RvX2ludDMyX3RydW5jID0gU3RkbGliLkludDMyLm9mX2ludFxuXG5sZXQgaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgPVxuICBpZiBudW1fYml0c19pbnQgPD0gbnVtX2JpdHNfaW50MzJcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnQzMl90b19pbnRfdHJ1bmMgbWluX2ludDMyIGluXG4gICAgbGV0IG1heCA9IGludDMyX3RvX2ludF90cnVuYyBtYXhfaW50MzIgaW5cbiAgICBmdW4geCAtPiBjb21wYXJlX2ludCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50IHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBpZiBudW1fYml0c19pbnQzMiA8PSBudW1fYml0c19pbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnRfdG9faW50MzJfdHJ1bmMgSW50Lm1pbl92YWx1ZSBpblxuICAgIGxldCBtYXggPSBpbnRfdG9faW50MzJfdHJ1bmMgSW50Lm1heF92YWx1ZSBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50MzIgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDMyIHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50X3RvX2ludDMyIHggPVxuICBpZiBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gU29tZSAoaW50X3RvX2ludDMyX3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDMyX3RvX2ludCB4ID1cbiAgaWYgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKGludDMyX3RvX2ludF90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnRfdG9faW50MzJfZXhuIHggPVxuICBpZiBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gaW50X3RvX2ludDMyX3RydW5jIHggZWxzZSBpbnRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG5sZXQgaW50MzJfdG9faW50X2V4biB4ID1cbiAgaWYgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIGludDMyX3RvX2ludF90cnVuYyB4IGVsc2UgaW50MzJfdG9faW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50IDwtPiBpbnQ2NCAqKVxuXG5sZXRbQGNvbGRdIGludDY0X3RvX2ludF9mYWlsdXJlIHggPVxuICBjb252ZXJ0X2ZhaWx1cmVcbiAgICAoU3RkbGliLkludDY0LmFkZCB4IDBMICgqIGZvcmNlIGludDY0IGJveGluZyB0byBiZSBoZXJlIHVuZGVyIGZsYW1iZGEyICopKVxuICAgIFwiaW50NjRcIlxuICAgIFwiaW50XCJcbiAgICBpbnQ2NF90b19zdHJpbmdcbjs7XG5cbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50IDwgbnVtX2JpdHNfaW50NjQpXG5sZXQgaW50X3RvX2ludDY0ID0gU3RkbGliLkludDY0Lm9mX2ludFxubGV0IGludDY0X3RvX2ludF90cnVuYyA9IFN0ZGxpYi5JbnQ2NC50b19pbnRcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50ID1cbiAgbGV0IG1pbiA9IGludF90b19pbnQ2NCBJbnQubWluX3ZhbHVlIGluXG4gIGxldCBtYXggPSBpbnRfdG9faW50NjQgSW50Lm1heF92YWx1ZSBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfdG9faW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAoaW50NjRfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX2ludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBpbnQ2NF90b19pbnRfdHJ1bmMgeCBlbHNlIGludDY0X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBuYXRpdmVpbnRfdG9faW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwibmF0aXZlaW50XCIgXCJpbnRcIiBuYXRpdmVpbnRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA8PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50X3RvX25hdGl2ZWludCA9IFN0ZGxpYi5OYXRpdmVpbnQub2ZfaW50XG5sZXQgbmF0aXZlaW50X3RvX2ludF90cnVuYyA9IFN0ZGxpYi5OYXRpdmVpbnQudG9faW50XG5cbmxldCBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBpZiBudW1fYml0c19uYXRpdmVpbnQgPD0gbnVtX2JpdHNfaW50XG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50X3RvX25hdGl2ZWludCBJbnQubWluX3ZhbHVlIGluXG4gICAgbGV0IG1heCA9IGludF90b19uYXRpdmVpbnQgSW50Lm1heF92YWx1ZSBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfbmF0aXZlaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9uYXRpdmVpbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50IHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnRfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgbmF0aXZlaW50X3RvX2ludF9leG4geCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludF90cnVuYyB4XG4gIGVsc2UgbmF0aXZlaW50X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludDMyIDwtPiBpbnQ2NCAqKVxuXG5sZXQgaW50NjRfdG9faW50MzJfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50MzJcIiBpbnQ2NF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50MzIgPCBudW1fYml0c19pbnQ2NClcbmxldCBpbnQzMl90b19pbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5vZl9pbnQzMlxubGV0IGludDY0X3RvX2ludDMyX3RydW5jID0gU3RkbGliLkludDY0LnRvX2ludDMyXG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgbGV0IG1pbiA9IGludDMyX3RvX2ludDY0IG1pbl9pbnQzMiBpblxuICBsZXQgbWF4ID0gaW50MzJfdG9faW50NjQgbWF4X2ludDMyIGluXG4gIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDBcbjs7XG5cbmxldCBpbnQ2NF90b19pbnQzMiB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gU29tZSAoaW50NjRfdG9faW50MzJfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50NjRfdG9faW50MzJfZXhuIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHhcbiAgdGhlbiBpbnQ2NF90b19pbnQzMl90cnVuYyB4XG4gIGVsc2UgaW50NjRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQzMiA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzJfZmFpbHVyZSB4ID1cbiAgY29udmVydF9mYWlsdXJlIHggXCJuYXRpdmVpbnRcIiBcImludDMyXCIgbmF0aXZlaW50X3RvX3N0cmluZ1xuOztcblxubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQzMiA8PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50MzJfdG9fbmF0aXZlaW50ID0gU3RkbGliLk5hdGl2ZWludC5vZl9pbnQzMlxubGV0IG5hdGl2ZWludF90b19pbnQzMl90cnVuYyA9IFN0ZGxpYi5OYXRpdmVpbnQudG9faW50MzJcblxubGV0IG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgaWYgbnVtX2JpdHNfbmF0aXZlaW50IDw9IG51bV9iaXRzX2ludDMyXG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50MzJfdG9fbmF0aXZlaW50IG1pbl9pbnQzMiBpblxuICAgIGxldCBtYXggPSBpbnQzMl90b19uYXRpdmVpbnQgbWF4X2ludDMyIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9uYXRpdmVpbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX25hdGl2ZWludCB4IG1heCA8PSAwKVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQzMiB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnQzMl90cnVuYyB4KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzJfZXhuIHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludDMyX3RydW5jIHhcbiAgZWxzZSBuYXRpdmVpbnRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQ2NCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwibmF0aXZlaW50XCIgaW50NjRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludDY0ID49IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgPSBTdGRsaWIuSW50NjQudG9fbmF0aXZlaW50XG5sZXQgbmF0aXZlaW50X3RvX2ludDY0ID0gU3RkbGliLkludDY0Lm9mX25hdGl2ZWludFxuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19uYXRpdmVpbnQgPVxuICBpZiBudW1fYml0c19pbnQ2NCA8PSBudW1fYml0c19uYXRpdmVpbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBuYXRpdmVpbnRfdG9faW50NjQgbWluX25hdGl2ZWludCBpblxuICAgIGxldCBtYXggPSBuYXRpdmVpbnRfdG9faW50NjQgbWF4X25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGl2ZWludCB4XG4gIHRoZW4gU29tZSAoaW50NjRfdG9fbmF0aXZlaW50X3RydW5jIHgpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX25hdGl2ZWludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aXZlaW50IHhcbiAgdGhlbiBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgeFxuICBlbHNlIGludDY0X3RvX25hdGl2ZWludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludDY0IDwtPiBpbnQ2MyAqKVxuXG5sZXQgaW50NjRfdG9faW50NjNfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50NjNcIiBpbnQ2NF90b19zdHJpbmdcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgPVxuICBsZXQgbWluID0gU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0IG1pbl9pbnQ2NCAxIGluXG4gIGxldCBtYXggPSBTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgbWF4X2ludDY0IDEgaW5cbiAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMFxuOztcblxubGV0IGludDY0X2ZpdF9vbl9pbnQ2M19leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgeCB0aGVuICgpIGVsc2UgaW50NjRfdG9faW50NjNfZmFpbHVyZSB4XG47O1xuIiwiKCogW1N0cmluZzBdIGRlZmluZXMgc3RyaW5nIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpblxuICAgdGVybXMgb2YgW1N0ZGxpYi5TdHJpbmddLiBbU3RyaW5nMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mXG4gICBbU3RkbGliLlN0cmluZ10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBzdHJpbmcwLm1sIHNob3VsZFxuICAgdXNlIFtTdGRsaWIuU3RyaW5nXS4gIFtTdHJpbmcwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3NcbiAgIGJ1aWxkIG9yZGVyLlxuXG4gICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIHN0cmluZ3MsIGluY2x1ZGluZyB0aGUgc3Vic2NyaXB0IHN5bnRheCBbeC5baV1dIHdoaWNoXG4gICB0aGUgT0NhbWwgcGFyc2VyIGRlc3VnYXJzIGludG8gY2FsbHMgdG8gW1N0cmluZ10sIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5TdHJpbmddIGluXG4gICBidWlsZCBvcmRlciBzaG91bGQgZG9cblxuICAge1tcbiAgICAgbW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgU3RyaW5nID0gU3RyaW5nMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50c1xuICAgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5TdHJpbmddLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbm9wZW4gc3RydWN0XG4gIG1vZHVsZSBTeXMgPSBTeXMwXG4gIG1vZHVsZSBVY2hhciA9IFVjaGFyMFxuZW5kXG5cbm1vZHVsZSBTdHJpbmcgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgZ2V0IDogKHN0cmluZ1tAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IChzdHJpbmdbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRcbiAgICA6ICAoc3RyaW5nW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gY2hhclxuICAgID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZW5kXG5cbmluY2x1ZGUgU3RyaW5nXG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgKCBeICkgPSAoIF4gKVxubGV0IGNhcGl0YWxpemUgPSBTdGRsaWIuU3RyaW5nLmNhcGl0YWxpemVfYXNjaWlcbmxldCBjb21wYXJlID0gU3RkbGliLlN0cmluZy5jb21wYXJlXG5sZXQgZXNjYXBlZCA9IFN0ZGxpYi5TdHJpbmcuZXNjYXBlZFxubGV0IGxvd2VyY2FzZSA9IFN0ZGxpYi5TdHJpbmcubG93ZXJjYXNlX2FzY2lpXG5sZXQgbWFrZSA9IFN0ZGxpYi5TdHJpbmcubWFrZVxubGV0IHN1YiA9IFN0ZGxpYi5TdHJpbmcuc3ViXG5sZXQgdW5jYXBpdGFsaXplID0gU3RkbGliLlN0cmluZy51bmNhcGl0YWxpemVfYXNjaWlcbmxldCB1cHBlcmNhc2UgPSBTdGRsaWIuU3RyaW5nLnVwcGVyY2FzZV9hc2NpaVxubGV0IGlzX3ZhbGlkX3V0Zl84ID0gU3RkbGliLlN0cmluZy5pc192YWxpZF91dGZfOFxubGV0IGlzX3ZhbGlkX3V0Zl8xNmxlID0gU3RkbGliLlN0cmluZy5pc192YWxpZF91dGZfMTZsZVxubGV0IGlzX3ZhbGlkX3V0Zl8xNmJlID0gU3RkbGliLlN0cmluZy5pc192YWxpZF91dGZfMTZiZVxubGV0IGdldF91dGZfOF91Y2hhciB0IH5ieXRlX3BvcyA9IFN0ZGxpYi5TdHJpbmcuZ2V0X3V0Zl84X3VjaGFyIHQgYnl0ZV9wb3NcbmxldCBnZXRfdXRmXzE2bGVfdWNoYXIgdCB+Ynl0ZV9wb3MgPSBTdGRsaWIuU3RyaW5nLmdldF91dGZfMTZsZV91Y2hhciB0IGJ5dGVfcG9zXG5sZXQgZ2V0X3V0Zl8xNmJlX3VjaGFyIHQgfmJ5dGVfcG9zID0gU3RkbGliLlN0cmluZy5nZXRfdXRmXzE2YmVfdWNoYXIgdCBieXRlX3Bvc1xuXG5vcGVuIHN0cnVjdFxuICBsZXQgZ2V0X3V0Zl8zMl91Y2hhciB+Z2V0X2ludDMyIHQgfmJ5dGVfcG9zID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCB0IGluXG4gICAgbWF0Y2ggYnl0ZV9wb3MgPj0gMCAmJiBieXRlX3BvcyA8IGxlbiB3aXRoXG4gICAgfCBmYWxzZSAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcImluZGV4IG91dCBvZiBib3VuZHNcIilcbiAgICB8IHRydWUgLT5cbiAgICAgIChtYXRjaCBsZW4gLSBieXRlX3BvcyB3aXRoXG4gICAgICAgfCAoMSB8IDIgfCAzKSBhcyBieXRlc19yZWFkIC0+XG4gICAgICAgICAoKiBGZXdlciB0aGFuIDQgYnl0ZXMgcmVtYWluIGluIFt0XSwgc28gd2Uga25vdyB0aGUgZGVjb2RpbmcgaXMgaW52YWxpZC4gKilcbiAgICAgICAgIFVjaGFyLnV0Zl9kZWNvZGVfaW52YWxpZCBieXRlc19yZWFkXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBsZXQgaW50MzIgPSBnZXRfaW50MzIgdCBieXRlX3BvcyBpblxuICAgICAgICAgKG1hdGNoIEludF9jb252ZXJzaW9ucy5pbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCBpbnQzMiB3aXRoXG4gICAgICAgICAgfCBmYWxzZSAtPiBVY2hhci51dGZfZGVjb2RlX2ludmFsaWQgNFxuICAgICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgICAgbGV0IGludCA9IEludF9jb252ZXJzaW9ucy5pbnQzMl90b19pbnRfdHJ1bmMgaW50MzIgaW5cbiAgICAgICAgICAgIChtYXRjaCBVY2hhci5pc192YWxpZCBpbnQgd2l0aFxuICAgICAgICAgICAgIHwgdHJ1ZSAtPiBVY2hhci51dGZfZGVjb2RlIDQgKFVjaGFyLnVuc2FmZV9vZl9pbnQgaW50KVxuICAgICAgICAgICAgIHwgZmFsc2UgLT4gVWNoYXIudXRmX2RlY29kZV9pbnZhbGlkIDQpKSlcbiAgOztcbmVuZFxuXG5sZXQgZ2V0X3V0Zl8zMmxlX3VjaGFyIHQgfmJ5dGVfcG9zID1cbiAgZ2V0X3V0Zl8zMl91Y2hhciB0IH5ieXRlX3BvcyB+Z2V0X2ludDMyOlN0ZGxpYi5TdHJpbmcuZ2V0X2ludDMyX2xlXG47O1xuXG5sZXQgZ2V0X3V0Zl8zMmJlX3VjaGFyIHQgfmJ5dGVfcG9zID1cbiAgZ2V0X3V0Zl8zMl91Y2hhciB0IH5ieXRlX3BvcyB+Z2V0X2ludDMyOlN0ZGxpYi5TdHJpbmcuZ2V0X2ludDMyX2JlXG47O1xuXG5sZXQgY29uY2F0ID8oc2VwID0gXCJcIikgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiXCJcbiAgKCogVGhlIHN0ZGxpYiBkb2VzIG5vdCBzcGVjaWFsaXplIHRoaXMgY2FzZSBiZWNhdXNlIGl0IGNvdWxkIGJyZWFrIGV4aXN0aW5nIHByb2plY3RzLiAqKVxuICB8IFsgeCBdIC0+IHhcbiAgfCBsIC0+IFN0ZGxpYi5TdHJpbmcuY29uY2F0IH5zZXAgbFxuOztcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBmICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZVxuOztcblxubGV0IHNwbGl0X2xpbmVzID1cbiAgbGV0IGJhY2tfdXBfYXRfbmV3bGluZSB+dCB+cG9zIH5lb2wgPVxuICAgIHBvcyA6PSAhcG9zIC0gaWYgIXBvcyA+IDAgJiYgQ2hhcjAuZXF1YWwgdC5bIXBvcyAtIDFdICdcXHInIHRoZW4gMiBlbHNlIDE7XG4gICAgZW9sIDo9ICFwb3MgKyAxXG4gIGluXG4gIGZ1biB0IC0+XG4gICAgbGV0IG4gPSBsZW5ndGggdCBpblxuICAgIGlmIG4gPSAwXG4gICAgdGhlbiBbXVxuICAgIGVsc2UgKFxuICAgICAgKCogSW52YXJpYW50OiBbLTEgPD0gcG9zIDwgZW9sXS4gKilcbiAgICAgIGxldCBwb3MgPSByZWYgKG4gLSAxKSBpblxuICAgICAgbGV0IGVvbCA9IHJlZiBuIGluXG4gICAgICBsZXQgYWMgPSByZWYgW10gaW5cbiAgICAgICgqIFdlIHRyZWF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZyBzcGVjaWFsbHksIGJlY2F1c2UgaWYgdGhlIHN0cmluZyBlbmRzIHdpdGggYVxuICAgICAgICAgbmV3bGluZSwgd2UgZG9uJ3Qgd2FudCBhbiBleHRyYSBlbXB0eSBzdHJpbmcgYXQgdGhlIGVuZCBvZiB0aGUgb3V0cHV0LiAqKVxuICAgICAgaWYgQ2hhcjAuZXF1YWwgdC5bIXBvc10gJ1xcbicgdGhlbiBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sO1xuICAgICAgd2hpbGUgIXBvcyA+PSAwIGRvXG4gICAgICAgIGlmIG5vdCAoQ2hhcjAuZXF1YWwgdC5bIXBvc10gJ1xcbicpXG4gICAgICAgIHRoZW4gZGVjciBwb3NcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogQmVjYXVzZSBbcG9zIDwgZW9sXSwgd2Uga25vdyB0aGF0IFtzdGFydCA8PSBlb2xdLiAqKVxuICAgICAgICAgIGxldCBzdGFydCA9ICFwb3MgKyAxIGluXG4gICAgICAgICAgYWMgOj0gc3ViIHQgfnBvczpzdGFydCB+bGVuOighZW9sIC0gc3RhcnQpIDo6ICFhYztcbiAgICAgICAgICBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sKVxuICAgICAgZG9uZTtcbiAgICAgIHN1YiB0IH5wb3M6MCB+bGVuOiFlb2wgOjogIWFjKVxuOztcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IFN0ZGxpYi5MZXhpbmcucG9zaXRpb24gPVxuICAgIHsgcG9zX2ZuYW1lIDogc3RyaW5nXG4gICAgOyBwb3NfbG51bSA6IGludFxuICAgIDsgcG9zX2JvbCA6IGludFxuICAgIDsgcG9zX2NudW0gOiBpbnRcbiAgICB9XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPVxuICAgIChmdW4gYV9fMDAxXyBiX18wMDJfIC0+XG4gICAgICAgaWYgU3RkbGliLiggPT0gKSBhX18wMDFfIGJfXzAwMl9cbiAgICAgICB0aGVuIDBcbiAgICAgICBlbHNlIChcbiAgICAgICAgIG1hdGNoIGNvbXBhcmVfc3RyaW5nX19sb2NhbCBhX18wMDFfLnBvc19mbmFtZSBiX18wMDJfLnBvc19mbmFtZSB3aXRoXG4gICAgICAgICB8IDAgLT5cbiAgICAgICAgICAgKG1hdGNoIGNvbXBhcmVfaW50X19sb2NhbCBhX18wMDFfLnBvc19sbnVtIGJfXzAwMl8ucG9zX2xudW0gd2l0aFxuICAgICAgICAgICAgfCAwIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBjb21wYXJlX2ludF9fbG9jYWwgYV9fMDAxXy5wb3NfYm9sIGJfXzAwMl8ucG9zX2JvbCB3aXRoXG4gICAgICAgICAgICAgICB8IDAgLT4gY29tcGFyZV9pbnRfX2xvY2FsIGFfXzAwMV8ucG9zX2NudW0gYl9fMDAyXy5wb3NfY251bVxuICAgICAgICAgICAgICAgfCBuIC0+IG4pXG4gICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgOiB0IC0+IHQgLT4gaW50KVxuICA7O1xuXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgZnVuIGhzdiBhcmcgLT5cbiAgICBsZXQgaHN2ID1cbiAgICAgIGxldCBoc3YgPVxuICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgICAgaGFzaF9mb2xkX3N0cmluZyBoc3YgYXJnLnBvc19mbmFtZVxuICAgICAgICBpblxuICAgICAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2xudW1cbiAgICAgIGluXG4gICAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2JvbFxuICAgIGluXG4gICAgaGFzaF9mb2xkX2ludCBoc3YgYXJnLnBvc19jbnVtXG4gIDs7XG5cbiAgbGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jIGFyZyA9XG4gICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICAgIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1biB7IHBvc19mbmFtZSA9IHBvc19mbmFtZV9fMDA0X1xuICAgICAgICAgOyBwb3NfbG51bSA9IHBvc19sbnVtX18wMDZfXG4gICAgICAgICA7IHBvc19ib2wgPSBwb3NfYm9sX18wMDhfXG4gICAgICAgICA7IHBvc19jbnVtID0gcG9zX2NudW1fXzAxMF9cbiAgICAgICAgIH0gLT5cbiAgICAgICBsZXQgYm5kc19fMDAzXyA9IChbXSA6IF8gU3RkbGliLkxpc3QudCkgaW5cbiAgICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgICBsZXQgYXJnX18wMTFfID0gc2V4cF9vZl9pbnQgcG9zX2NudW1fXzAxMF8gaW5cbiAgICAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfY251bVwiOyBhcmdfXzAxMV8gXSA6OiBibmRzX18wMDNfXG4gICAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgIGluXG4gICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICAgbGV0IGFyZ19fMDA5XyA9IHNleHBfb2ZfaW50IHBvc19ib2xfXzAwOF8gaW5cbiAgICAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfYm9sXCI7IGFyZ19fMDA5XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgaW5cbiAgICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgICBsZXQgYXJnX18wMDdfID0gc2V4cF9vZl9pbnQgcG9zX2xudW1fXzAwNl8gaW5cbiAgICAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfbG51bVwiOyBhcmdfXzAwN18gXSA6OiBibmRzX18wMDNfXG4gICAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgIGluXG4gICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICAgbGV0IGFyZ19fMDA1XyA9IHNleHBfb2Zfc3RyaW5nIHBvc19mbmFtZV9fMDA0XyBpblxuICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19mbmFtZVwiOyBhcmdfXzAwNV8gXSA6OiBibmRzX18wMDNfXG4gICAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwM19cbiAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG4oKiBUaGlzIGlzIHRoZSBzYW1lIGZ1bmN0aW9uIGFzIFBweF9oZXJlLmxpZnRfcG9zaXRpb25fYXNfc3RyaW5nLiAqKVxubGV0IG1ha2VfbG9jYXRpb25fc3RyaW5nIH5wb3NfZm5hbWUgfnBvc19sbnVtIH5wb3NfY251bSB+cG9zX2JvbCA9XG4gIFN0cmluZy5jb25jYXRcbiAgICBbIHBvc19mbmFtZTsgXCI6XCI7IEludC50b19zdHJpbmcgcG9zX2xudW07IFwiOlwiOyBJbnQudG9fc3RyaW5nIChwb3NfY251bSAtIHBvc19ib2wpIF1cbjs7XG5cbmxldCB0b19zdHJpbmcgeyBTdGRsaWIuTGV4aW5nLnBvc19mbmFtZTsgcG9zX2xudW07IHBvc19jbnVtOyBwb3NfYm9sIH0gPVxuICBtYWtlX2xvY2F0aW9uX3N0cmluZyB+cG9zX2ZuYW1lIH5wb3NfbG51bSB+cG9zX2NudW0gfnBvc19ib2xcbjs7XG5cbmxldCBzZXhwX29mX3QgdCA9IFNleHAuQXRvbSAodG9fc3RyaW5nIHQpXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgTGlzdDBcblxubGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB0IGZzdCBzbmQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gcmV2IGZzdCwgcmV2IHNuZFxuICAgIHwgeCA6OiB0IC0+XG4gICAgICAobWF0Y2ggKGYgeCA6IF8gRWl0aGVyMC50KSB3aXRoXG4gICAgICAgfCBGaXJzdCB5IC0+IGxvb3AgdCAoeSA6OiBmc3QpIHNuZFxuICAgICAgIHwgU2Vjb25kIHkgLT4gbG9vcCB0IGZzdCAoeSA6OiBzbmQpKVxuICBpblxuICBsb29wIHQgW10gW10gW0Bub250YWlsXVxuOztcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEVpdGhlciA9IEVpdGhlcjBcblxudHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgU3RkbGliLnJlc3VsdCA9XG4gIHwgT2sgb2YgJ2FcbiAgfCBFcnJvciBvZiAnYlxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgaGFzaF1cblxubGV0IHRfb2Zfc2V4cCA6XG4gICAgICAnYSAnYi5cbiAgICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpIC0+IFNleHBsaWIwLlNleHAudCAtPiAoJ2EsICdiKSB0XG4gID1cbiAgZnVuICh0eXBlIGFfXzAxN18gYl9fMDE4XylcbiAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBhX18wMTdfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IGJfXzAxOF8pIC0+IFNleHBsaWIwLlNleHAudFxuICAgIC0+IChhX18wMTdfLCBiX18wMThfKSB0KSAtPlxuICBsZXQgZXJyb3Jfc291cmNlX18wMDVfID0gXCJyZXN1bHQubWwudFwiIGluXG4gIGZ1biBfb2ZfYV9fMDAxXyBfb2ZfYl9fMDAyXyAtPiBmdW5jdGlvblxuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcIm9rXCIgfCBcIk9rXCIpIGFzIF90YWdfXzAwOF8pIDo6IHNleHBfYXJnc19fMDA5XykgYXNcbiAgICAgIF9zZXhwX18wMDdfIC0+XG4gICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMDlfIHdpdGhcbiAgICAgICB8IFsgYXJnMF9fMDEwXyBdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDExXyA9IF9vZl9hX18wMDFfIGFyZzBfXzAxMF8gaW5cbiAgICAgICAgIE9rIHJlczBfXzAxMV9cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDVfXG4gICAgICAgICAgIF90YWdfXzAwOF9cbiAgICAgICAgICAgX3NleHBfXzAwN18pXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiZXJyb3JcIiB8IFwiRXJyb3JcIikgYXMgX3RhZ19fMDEzXykgOjogc2V4cF9hcmdzX18wMTRfKSBhc1xuICAgICAgX3NleHBfXzAxMl8gLT5cbiAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxNF8gd2l0aFxuICAgICAgIHwgWyBhcmcwX18wMTVfIF0gLT5cbiAgICAgICAgIGxldCByZXMwX18wMTZfID0gX29mX2JfXzAwMl8gYXJnMF9fMDE1XyBpblxuICAgICAgICAgRXJyb3IgcmVzMF9fMDE2X1xuICAgICAgIHwgXyAtPlxuICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNV9cbiAgICAgICAgICAgX3RhZ19fMDEzX1xuICAgICAgICAgICBfc2V4cF9fMDEyXylcbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJva1wiIHwgXCJPa1wiKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZXJyb3JcIiB8IFwiRXJyb3JcIikgYXMgc2V4cF9fMDA2XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgIHwgc2V4cF9fMDA0XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG47O1xuXG5sZXQgc2V4cF9vZl90IDpcbiAgICAgICdhICdiLlxuICAgICAgKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDI1XyBiX18wMjZfKVxuICAgIDogICgoYV9fMDI1XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChiX18wMjZfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoYV9fMDI1XywgYl9fMDI2XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gIGZ1biBfb2ZfYV9fMDE5XyBfb2ZfYl9fMDIwXyAtPiBmdW5jdGlvblxuICB8IE9rIGFyZzBfXzAyMV8gLT5cbiAgICBsZXQgcmVzMF9fMDIyXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMV8gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPa1wiOyByZXMwX18wMjJfIF1cbiAgfCBFcnJvciBhcmcwX18wMjNfIC0+XG4gICAgbGV0IHJlczBfXzAyNF8gPSBfb2ZfYl9fMDIwXyBhcmcwX18wMjNfIGluXG4gICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXJyb3JcIjsgcmVzMF9fMDI0XyBdXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOlxuICAgICAgJ2EgJ2IuXG4gICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJPa1wiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRXJyb3JcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlX19sb2NhbCA6XG4gICAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGludCkgLT4gKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDMzXyBiX18wMzRfIC0+XG4gIGlmIFN0ZGxpYi4oID09ICkgYV9fMDMzXyBiX18wMzRfXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMzNfLCBiX18wMzRfIHdpdGhcbiAgICB8IE9rIF9hX18wMzVfLCBPayBfYl9fMDM2XyAtPiBfY21wX19hIF9hX18wMzVfIF9iX18wMzZfXG4gICAgfCBPayBfLCBfIC0+IC0xXG4gICAgfCBfLCBPayBfIC0+IDFcbiAgICB8IEVycm9yIF9hX18wMzdfLCBFcnJvciBfYl9fMDM4XyAtPiBfY21wX19iIF9hX18wMzdfIF9iX18wMzhfKVxuOztcblxubGV0IGNvbXBhcmUgOlxuICAgICAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAyN18gYl9fMDI4XyAtPlxuICBpZiBTdGRsaWIuKCA9PSApIGFfXzAyN18gYl9fMDI4X1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDI3XywgYl9fMDI4XyB3aXRoXG4gICAgfCBPayBfYV9fMDI5XywgT2sgX2JfXzAzMF8gLT4gX2NtcF9fYSBfYV9fMDI5XyBfYl9fMDMwX1xuICAgIHwgT2sgXywgXyAtPiAtMVxuICAgIHwgXywgT2sgXyAtPiAxXG4gICAgfCBFcnJvciBfYV9fMDMxXywgRXJyb3IgX2JfXzAzMl8gLT4gX2NtcF9fYiBfYV9fMDMxXyBfYl9fMDMyXylcbjs7XG5cbmxldCBlcXVhbF9fbG9jYWwgOlxuICAgICAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBib29sKSAtPiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgPVxuICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzA0NV8gYl9fMDQ2XyAtPlxuICBpZiBTdGRsaWIuKCA9PSApIGFfXzA0NV8gYl9fMDQ2X1xuICB0aGVuIHRydWVcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDQ1XywgYl9fMDQ2XyB3aXRoXG4gICAgfCBPayBfYV9fMDQ3XywgT2sgX2JfXzA0OF8gLT4gX2NtcF9fYSBfYV9fMDQ3XyBfYl9fMDQ4X1xuICAgIHwgT2sgXywgXyAtPiBmYWxzZVxuICAgIHwgXywgT2sgXyAtPiBmYWxzZVxuICAgIHwgRXJyb3IgX2FfXzA0OV8sIEVycm9yIF9iX18wNTBfIC0+IF9jbXBfX2IgX2FfXzA0OV8gX2JfXzA1MF8pXG47O1xuXG5sZXQgZXF1YWwgOlxuICAgICAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBib29sKSAtPiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgPVxuICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAzOV8gYl9fMDQwXyAtPlxuICBpZiBTdGRsaWIuKCA9PSApIGFfXzAzOV8gYl9fMDQwX1xuICB0aGVuIHRydWVcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDM5XywgYl9fMDQwXyB3aXRoXG4gICAgfCBPayBfYV9fMDQxXywgT2sgX2JfXzA0Ml8gLT4gX2NtcF9fYSBfYV9fMDQxXyBfYl9fMDQyX1xuICAgIHwgT2sgXywgXyAtPiBmYWxzZVxuICAgIHwgXywgT2sgXyAtPiBmYWxzZVxuICAgIHwgRXJyb3IgX2FfXzA0M18sIEVycm9yIF9iX18wNDRfIC0+IF9jbXBfX2IgX2FfXzA0M18gX2JfXzA0NF8pXG47O1xuXG5sZXQgaGFzaF9mb2xkX3RcbiAgOiB0eXBlIGEgYi5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGEgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gKGEsIGIpIHRcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgPVxuICBmdW4gX2hhc2hfZm9sZF9hIF9oYXNoX2ZvbGRfYiBoc3YgYXJnIC0+XG4gIG1hdGNoIGFyZyB3aXRoXG4gIHwgT2sgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMCBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICB8IEVycm9yIF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9iIGhzdiBfYTBcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBnbG9iYWxpemUgPSBnbG9iYWxpemVfcmVzdWx0XG5cbmluY2x1ZGUgTW9uYWQuTWFrZTJfbG9jYWwgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gIGxldCBiaW5kIHggfmYgPVxuICAgIG1hdGNoIHggd2l0aFxuICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICB8IE9rIHggLT4gZiB4XG4gIDs7XG5cbiAgbGV0IG1hcCB4IH5mID1cbiAgICBtYXRjaCB4IHdpdGhcbiAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgfCBPayB4IC0+IE9rIChmIHgpXG4gIDs7XG5cbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGxldCByZXR1cm4geCA9IE9rIHhcbmVuZClcblxubGV0IGludmFyaWFudCBjaGVja19vayBjaGVja19lcnJvciB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgT2sgb2sgLT4gY2hlY2tfb2sgb2tcbiAgfCBFcnJvciBlcnJvciAtPiBjaGVja19lcnJvciBlcnJvclxuOztcblxubGV0IGZhaWwgeCA9IEVycm9yIHhcbmxldCBmYWlsZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgZmFpbCBmb3JtYXRcblxubGV0IG1hcF9lcnJvciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgT2sgXyBhcyB4IC0+IHhcbiAgfCBFcnJvciB4IC0+IEVycm9yIChmIHgpXG47O1xuXG5tb2R1bGUgRXJyb3IgPSBNb25hZC5NYWtlMl9sb2NhbCAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2IsICdhKSB0XG5cbiAgbGV0IGJpbmQgeCB+ZiA9XG4gICAgbWF0Y2ggeCB3aXRoXG4gICAgfCBPayBfIGFzIG9rIC0+IG9rXG4gICAgfCBFcnJvciBlIC0+IGYgZVxuICA7O1xuXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcF9lcnJvclxuICBsZXQgcmV0dXJuIGUgPSBFcnJvciBlXG5lbmQpXG5cbmxldCBpc19vayA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiB0cnVlXG4gIHwgRXJyb3IgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2Vycm9yID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IGZhbHNlXG4gIHwgRXJyb3IgXyAtPiB0cnVlXG47O1xuXG5sZXQgb2sgPSBmdW5jdGlvblxuICB8IE9rIHggLT4gU29tZSB4XG4gIHwgRXJyb3IgXyAtPiBOb25lXG47O1xuXG5sZXQgZXJyb3IgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gTm9uZVxuICB8IEVycm9yIHggLT4gU29tZSB4XG47O1xuXG5sZXQgb2Zfb3B0aW9uIG9wdCB+ZXJyb3IgPVxuICBtYXRjaCBvcHQgd2l0aFxuICB8IFNvbWUgeCAtPiBPayB4XG4gIHwgTm9uZSAtPiBFcnJvciBlcnJvclxuOztcblxubGV0IGl0ZXIgdiB+ZiA9XG4gIG1hdGNoIHYgd2l0aFxuICB8IE9rIHggLT4gZiB4XG4gIHwgRXJyb3IgXyAtPiAoKVxuOztcblxubGV0IGl0ZXJfZXJyb3IgdiB+ZiA9XG4gIG1hdGNoIHYgd2l0aFxuICB8IE9rIF8gLT4gKClcbiAgfCBFcnJvciB4IC0+IGYgeFxuOztcblxubGV0IHRvX2VpdGhlciA6IF8gdCAtPiBfIEVpdGhlci50ID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IEZpcnN0IHhcbiAgfCBFcnJvciB4IC0+IFNlY29uZCB4XG47O1xuXG5sZXQgb2ZfZWl0aGVyIDogXyBFaXRoZXIudCAtPiBfIHQgPSBmdW5jdGlvblxuICB8IEZpcnN0IHggLT4gT2sgeFxuICB8IFNlY29uZCB4IC0+IEVycm9yIHhcbjs7XG5cbmxldCBva19pZl90cnVlIGJvb2wgfmVycm9yID0gaWYgYm9vbCB0aGVuIE9rICgpIGVsc2UgRXJyb3IgZXJyb3JcblxubGV0IHRyeV93aXRoIGYgPVxuICB0cnkgT2sgKGYgKCkpIHdpdGhcbiAgfCBleG4gLT4gRXJyb3IgZXhuXG47O1xuXG5sZXQgb2tfZXhuID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBleG4gLT4gcmFpc2UgZXhuXG47O1xuXG5sZXQgb2tfb3JfZmFpbHdpdGggPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIHN0ciAtPiBmYWlsd2l0aCBzdHJcbjs7XG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ29rLCAnZXJyKSBfcmVzdWx0ID0gKCdvaywgJ2VycikgdCA9XG4gICAgfCBPayBvZiAnb2tcbiAgICB8IEVycm9yIG9mICdlcnJcblxuICBsZXQgaXNfZXJyb3IgPSBpc19lcnJvclxuICBsZXQgaXNfb2sgPSBpc19va1xuZW5kXG5cbmxldCBjb21iaW5lIHQxIHQyIH5vayB+ZXJyID1cbiAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgfCBPayBfLCBFcnJvciBlIHwgRXJyb3IgZSwgT2sgXyAtPiBFcnJvciBlXG4gIHwgT2sgb2sxLCBPayBvazIgLT4gT2sgKG9rIG9rMSBvazIpXG4gIHwgRXJyb3IgZXJyMSwgRXJyb3IgZXJyMiAtPiBFcnJvciAoZXJyIGVycjEgZXJyMilcbjs7XG5cbmxldCBjb21iaW5lX2Vycm9ycyBsID1cbiAgbGV0IG9rLCBlcnJzID0gTGlzdDEucGFydGl0aW9uX21hcCBsIH5mOnRvX2VpdGhlciBpblxuICBtYXRjaCBlcnJzIHdpdGhcbiAgfCBbXSAtPiBPayBva1xuICB8IF8gOjogXyAtPiBFcnJvciBlcnJzXG47O1xuXG5sZXQgY29tYmluZV9lcnJvcnNfdW5pdCBsID0gbWFwIChjb21iaW5lX2Vycm9ycyBsKSB+ZjooZnVuIChfIDogdW5pdCBsaXN0KSAtPiAoKSlcbiIsIigqKiBQcm92aWRlcyBnZW5lcmljIHNpZ25hdHVyZXMgZm9yIGNvbnRhaW5lciBkYXRhIHN0cnVjdHVyZXMuXG5cbiAgICBUaGVzZSBzaWduYXR1cmVzIGluY2x1ZGUgZnVuY3Rpb25zIChbaXRlcl0sIFtmb2xkXSwgW2V4aXN0c10sIFtmb3JfYWxsXSwgLi4uKSB0aGF0XG4gICAgeW91IHdvdWxkIGV4cGVjdCB0byBmaW5kIGluIGFueSBjb250YWluZXIuIFVzZWQgYnkgaW5jbHVkaW5nIFtDb250YWluZXIuUzBdIG9yXG4gICAgW0NvbnRhaW5lci5TMV0gaW4gdGhlIHNpZ25hdHVyZSBmb3IgZXZlcnkgY29udGFpbmVyLWxpa2UgZGF0YSBzdHJ1Y3R1cmUgKFtBcnJheV0sXG4gICAgW0xpc3RdLCBbU3RyaW5nXSwgLi4uKSB0byBlbnN1cmUgYSBjb25zaXN0ZW50IGludGVyZmFjZS4gKilcblxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgKCoqIFtDb250aW51ZV9vcl9zdG9wLnRdIGlzIHVzZWQgYnkgdGhlIFtmXSBhcmd1bWVudCB0byBbZm9sZF91bnRpbF0gaW4gb3JkZXIgdG9cbiAgICAgIGluZGljYXRlIHdoZXRoZXIgZm9sZGluZyBzaG91bGQgY29udGludWUsIG9yIHN0b3AgZWFybHkuXG5cbiAgICAgIEBjYW5vbmljYWwgQmFzZS5Db250YWluZXIuQ29udGludWVfb3Jfc3RvcFxuICAqKVxuICBtb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgICB8IENvbnRpbnVlIG9mICdhXG4gICAgICB8IFN0b3Agb2YgJ2JcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBFeHBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Db250YWluZXIuU3VtbWFibGUgKilcbm1vZHVsZSB0eXBlIFN1bW1hYmxlID0gc2lnXG4gIHR5cGUgdFxuXG4gICgqKiBUaGUgcmVzdWx0IG9mIHN1bW1pbmcgbm8gdmFsdWVzLiAqKVxuICB2YWwgemVybyA6IHRcblxuICAoKiogQW4gb3BlcmF0aW9uIHRoYXQgY29tYmluZXMgdHdvIFt0XSdzIGFuZCBoYW5kbGVzIFt6ZXJvICsgeF0gYnkganVzdCByZXR1cm5pbmcgW3hdLFxuICAgICAgYXMgd2VsbCBhcyBpbiB0aGUgc3ltbWV0cmljIGNhc2UuICopXG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG5lbmRcblxuKCoqIFNpZ25hdHVyZSBmb3IgbW9ub21vcnBoaWMgY29udGFpbmVyIC0gYSBjb250YWluZXIgZm9yIGEgc3BlY2lmaWMgZWxlbWVudCB0eXBlLCBlLmcuLFxuICAgIHN0cmluZywgd2hpY2ggaXMgYSBjb250YWluZXIgb2YgY2hhcmFjdGVycyAoW3R5cGUgZWx0ID0gY2hhcl0pIGFuZCBuZXZlciBvZiBhbnl0aGluZ1xuICAgIGVsc2UuICopXG5tb2R1bGUgdHlwZSBTMCA9IHNpZ1xuICB0eXBlIHRcbiAgdHlwZSBlbHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIGVxdWFsaXR5IG9uIFtlbHRdcy4gKilcbiAgdmFsIG1lbSA6IHQgLT4gZWx0IC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogdCAtPiBib29sXG5cbiAgKCoqIFtpdGVyXSBtdXN0IGFsbG93IGV4Y2VwdGlvbnMgcmFpc2VkIGluIFtmXSB0byBlc2NhcGUsIHRlcm1pbmF0aW5nIHRoZSBpdGVyYXRpb25cbiAgICAgIGNsZWFubHkuICBUaGUgc2FtZSBob2xkcyBmb3IgYWxsIGZ1bmN0aW9ucyBiZWxvdyB0YWtpbmcgYW4gW2ZdLiAqKVxuICB2YWwgaXRlciA6IHQgLT4gZjooZWx0IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0uICopXG4gIHZhbCBmb2xkIDogdCAtPiBpbml0OidhY2MgLT4gZjooJ2FjYyAtPiBlbHQgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gZWx0IC0+ICgnYWNjLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2MsICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgaXMgY29tcHV0ZWQgYnkgW2ZpbmlzaF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgbWF5YmVfbmVnYXRpdmUgPVxuICAgICAgICAgIHwgRm91bmRfbmVnYXRpdmUgb2YgaW50XG4gICAgICAgICAgfCBBbGxfbm9ubmVnYXRpdmUgb2YgeyBzdW0gOiBpbnQgfVxuXG4gICAgICAgICgqKiBbZmlyc3RfbmVnX29yX3N1bSBsaXN0XSByZXR1cm5zIHRoZSBmaXJzdCBuZWdhdGl2ZSBudW1iZXIgaW4gW2xpc3RdLCBpZiBhbnksXG4gICAgICAgICAgICBvdGhlcndpc2UgcmV0dXJucyB0aGUgc3VtIG9mIHRoZSBsaXN0LiAqKVxuICAgICAgICBsZXQgZmlyc3RfbmVnX29yX3N1bSA9XG4gICAgICAgICAgTGlzdC5mb2xkX3VudGlsIH5pbml0OjBcbiAgICAgICAgICAgIH5mOihmdW4gc3VtIHggLT5cbiAgICAgICAgICAgICAgaWYgeCA8IDBcbiAgICAgICAgICAgICAgdGhlbiBTdG9wIChGb3VuZF9uZWdhdGl2ZSB4KVxuICAgICAgICAgICAgICBlbHNlIENvbnRpbnVlIChzdW0gKyB4KSlcbiAgICAgICAgICAgIH5maW5pc2g6KGZ1biBzdW0gLT4gQWxsX25vbm5lZ2F0aXZlIHsgc3VtIH0pXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHggPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAzOyA0OyA1XVxuICAgICAgICB2YWwgeCA6IG1heWJlX25lZ2F0aXZlID0gQWxsX25vbm5lZ2F0aXZlIHtzdW0gPSAxNX1cblxuICAgICAgICBsZXQgeSA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IC0zOyA0OyA1XVxuICAgICAgICB2YWwgeSA6IG1heWJlX25lZ2F0aXZlID0gRm91bmRfbmVnYXRpdmUgLTNcbiAgICAgIF19ICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gZWx0IC0+ICgnYWNjLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGNvdW50IDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiAqKVxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+IHQgLT4gZjooZWx0IC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdCBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiB0IC0+IGY6KGVsdCAtPiAnYSBvcHRpb24pIC0+ICdhIG9wdGlvblxuXG4gIHZhbCB0b19saXN0IDogdCAtPiBlbHQgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiB0IC0+IGVsdCBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwLiBtYXgpIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgW2NvbXBhcmVdXG4gICAgICBmdW5jdGlvbi4gSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0IGVsZW1lbnQgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGVcbiAgICAgIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIFtmb2xkXSBzbyBpdCBoYXMgdGhlIHNhbWVcbiAgICAgIGNvbXBsZXhpdHkgYXMgW2ZvbGRdLiBSZXR1cm5zIFtOb25lXSBpZmYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICopXG4gIHZhbCBtaW5fZWx0IDogdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0IDogdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMwX3BoYW50b20gPSBzaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSAnYSB0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBlcXVhbGl0eSBvbiBbZWx0XXMuICopXG4gIHZhbCBtZW0gOiBfIHQgLT4gZWx0IC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiBfIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6IF8gdCAtPiBmOihlbHQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XS4gKilcbiAgdmFsIGZvbGQgOiBfIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gZWx0IC0+ICdhY2MpIC0+ICdhY2NcblxuICAoKiogW2ZvbGRfcmVzdWx0IHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXSB0aGF0IHJ1bnMgaW4gdGhlXG4gICAgICBbUmVzdWx0XSBtb25hZC4gIElmIFtmXSByZXR1cm5zIGFuIFtFcnJvciBfXSwgdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0IGFueVxuICAgICAgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyBvZiBbZl0uICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogIF8gdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gZWx0IC0+ICgnYWNjLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2MsICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgaXMgY29tcHV0ZWQgYnkgW2ZpbmlzaF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgbWF5YmVfbmVnYXRpdmUgPVxuICAgICAgICAgIHwgRm91bmRfbmVnYXRpdmUgb2YgaW50XG4gICAgICAgICAgfCBBbGxfbm9ubmVnYXRpdmUgb2YgeyBzdW0gOiBpbnQgfVxuXG4gICAgICAgICgqKiBbZmlyc3RfbmVnX29yX3N1bSBsaXN0XSByZXR1cm5zIHRoZSBmaXJzdCBuZWdhdGl2ZSBudW1iZXIgaW4gW2xpc3RdLCBpZiBhbnksXG4gICAgICAgICAgICBvdGhlcndpc2UgcmV0dXJucyB0aGUgc3VtIG9mIHRoZSBsaXN0LiAqKVxuICAgICAgICBsZXQgZmlyc3RfbmVnX29yX3N1bSA9XG4gICAgICAgICAgTGlzdC5mb2xkX3VudGlsIH5pbml0OjBcbiAgICAgICAgICAgIH5mOihmdW4gc3VtIHggLT5cbiAgICAgICAgICAgICAgaWYgeCA8IDBcbiAgICAgICAgICAgICAgdGhlbiBTdG9wIChGb3VuZF9uZWdhdGl2ZSB4KVxuICAgICAgICAgICAgICBlbHNlIENvbnRpbnVlIChzdW0gKyB4KSlcbiAgICAgICAgICAgIH5maW5pc2g6KGZ1biBzdW0gLT4gQWxsX25vbm5lZ2F0aXZlIHsgc3VtIH0pXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHggPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAzOyA0OyA1XVxuICAgICAgICB2YWwgeCA6IG1heWJlX25lZ2F0aXZlID0gQWxsX25vbm5lZ2F0aXZlIHtzdW0gPSAxNX1cblxuICAgICAgICBsZXQgeSA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IC0zOyA0OyA1XVxuICAgICAgICB2YWwgeSA6IG1heWJlX25lZ2F0aXZlID0gRm91bmRfbmVnYXRpdmUgLTNcbiAgICAgIF19ICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgXyB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiBlbHQgLT4gKCdhY2MsICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjYyAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogXyB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZVxuICAgICAgZWxlbWVudHMgd2lsbCBiZSBzdW1tZWQgaXMgdW5zcGVjaWZpZWQuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gXyB0IC0+IGY6KGVsdCAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdCBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiBfIHQgLT4gZjooZWx0IC0+ICdhIG9wdGlvbikgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiBfIHQgLT4gZWx0IGxpc3RcbiAgdmFsIHRvX2FycmF5IDogXyB0IC0+IGVsdCBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwIG1heCkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBbY29tcGFyZV1cbiAgICAgIGZ1bmN0aW9uLCBvciBbTm9uZV0gaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGUgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gKilcbiAgdmFsIG1pbl9lbHQgOiBfIHQgLT4gY29tcGFyZTooZWx0IC0+IGVsdCAtPiBpbnQpIC0+IGVsdCBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6IF8gdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuZW5kXG5cbigqKiBTaWduYXR1cmUgZm9yIHBvbHltb3JwaGljIGNvbnRhaW5lciwgZS5nLiwgWydhIGxpc3RdIG9yIFsnYSBhcnJheV0uICopXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIFtlcXVhbF0uICopXG4gIHZhbCBtZW0gOiAnYSB0IC0+ICdhIC0+IGVxdWFsOignYSAtPiAnYSAtPiBib29sKSAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6ICdhIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICdhIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XSAgKilcbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+ICdhIC0+ICdhY2MpIC0+ICdhY2NcblxuICAoKiogW2ZvbGRfcmVzdWx0IHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXSB0aGF0IHJ1bnMgaW4gdGhlXG4gICAgICBbUmVzdWx0XSBtb25hZC4gIElmIFtmXSByZXR1cm5zIGFuIFtFcnJvciBfXSwgdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0IGFueVxuICAgICAgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyBvZiBbZl0uICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICdhIC0+ICgnYWNjLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2MsICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgaXMgY29tcHV0ZWQgYnkgW2ZpbmlzaF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgbWF5YmVfbmVnYXRpdmUgPVxuICAgICAgICAgIHwgRm91bmRfbmVnYXRpdmUgb2YgaW50XG4gICAgICAgICAgfCBBbGxfbm9ubmVnYXRpdmUgb2YgeyBzdW0gOiBpbnQgfVxuXG4gICAgICAgICgqKiBbZmlyc3RfbmVnX29yX3N1bSBsaXN0XSByZXR1cm5zIHRoZSBmaXJzdCBuZWdhdGl2ZSBudW1iZXIgaW4gW2xpc3RdLCBpZiBhbnksXG4gICAgICAgICAgICBvdGhlcndpc2UgcmV0dXJucyB0aGUgc3VtIG9mIHRoZSBsaXN0LiAqKVxuICAgICAgICBsZXQgZmlyc3RfbmVnX29yX3N1bSA9XG4gICAgICAgICAgTGlzdC5mb2xkX3VudGlsIH5pbml0OjBcbiAgICAgICAgICAgIH5mOihmdW4gc3VtIHggLT5cbiAgICAgICAgICAgICAgaWYgeCA8IDBcbiAgICAgICAgICAgICAgdGhlbiBTdG9wIChGb3VuZF9uZWdhdGl2ZSB4KVxuICAgICAgICAgICAgICBlbHNlIENvbnRpbnVlIChzdW0gKyB4KSlcbiAgICAgICAgICAgIH5maW5pc2g6KGZ1biBzdW0gLT4gQWxsX25vbm5lZ2F0aXZlIHsgc3VtIH0pXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHggPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAzOyA0OyA1XVxuICAgICAgICB2YWwgeCA6IG1heWJlX25lZ2F0aXZlID0gQWxsX25vbm5lZ2F0aXZlIHtzdW0gPSAxNX1cblxuICAgICAgICBsZXQgeSA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IC0zOyA0OyA1XVxuICAgICAgICB2YWwgeSA6IG1heWJlX25lZ2F0aXZlID0gRm91bmRfbmVnYXRpdmUgLTNcbiAgICAgIF19ICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gJ2EgLT4gKCdhY2MsICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjYyAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gKilcblxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+ICdhIHQgLT4gZjooJ2EgLT4gJ3N1bSkgLT4gJ3N1bVxuXG4gICgqKiBSZXR1cm5zIGFzIGFuIFtvcHRpb25dIHRoZSBmaXJzdCBlbGVtZW50IGZvciB3aGljaCBbZl0gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiAnYSB0IC0+ICdhIGxpc3RcbiAgdmFsIHRvX2FycmF5IDogJ2EgdCAtPiAnYSBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluaW11bSAocmVzcCBtYXhpbXVtKSBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24gdXNpbmcgdGhlIHByb3ZpZGVkXG4gICAgICBbY29tcGFyZV0gZnVuY3Rpb24sIG9yIFtOb25lXSBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0XG4gICAgICBlbGVtZW50IGVuY291bnRlcmVkIHdoaWxlIHRyYXZlcnNpbmcgdGhlIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuIFRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAgdXNlcyBbZm9sZF0gc28gaXQgaGFzIHRoZSBzYW1lIGNvbXBsZXhpdHkgYXMgW2ZvbGRdLiAqKVxuICB2YWwgbWluX2VsdCA6ICdhIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6ICdhIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBTMV9waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCAncGhhbnRvbSkgdFxuXG4gICgqKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgZWxlbWVudCBpcyB0aGVyZSwgdXNpbmcgW2VxdWFsXS4gKilcbiAgdmFsIG1lbSA6ICgnYSwgXykgdCAtPiAnYSAtPiBlcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gIHZhbCBsZW5ndGggOiAoXywgXykgdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICgnYSwgXykgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIFtmb2xkIHQgfmluaXQgfmZdIHJldHVybnMgW2YgKC4uLiBmIChmIChmIGluaXQgZTEpIGUyKSBlMyAuLi4pIGVuXSwgd2hlcmUgW2UxLi5lbl1cbiAgICAgIGFyZSB0aGUgZWxlbWVudHMgb2YgW3RdLiAqKVxuICB2YWwgZm9sZCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2MgLT4gZjooJ2FjYyAtPiAnYSAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgKCoqIFtmb2xkX3Jlc3VsdCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0gdGhhdCBydW5zIGluIHRoZVxuICAgICAgW1Jlc3VsdF0gbW9uYWQuICBJZiBbZl0gcmV0dXJucyBhbiBbRXJyb3IgX10sIHRoYXQgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dCBhbnlcbiAgICAgIGFkZGl0aW9uYWwgaW52b2NhdGlvbnMgb2YgW2ZdLiAqKVxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICdhIC0+ICgnYWNjLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2MsICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgaXMgY29tcHV0ZWQgYnkgW2ZpbmlzaF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgbWF5YmVfbmVnYXRpdmUgPVxuICAgICAgICAgIHwgRm91bmRfbmVnYXRpdmUgb2YgaW50XG4gICAgICAgICAgfCBBbGxfbm9ubmVnYXRpdmUgb2YgeyBzdW0gOiBpbnQgfVxuXG4gICAgICAgICgqKiBbZmlyc3RfbmVnX29yX3N1bSBsaXN0XSByZXR1cm5zIHRoZSBmaXJzdCBuZWdhdGl2ZSBudW1iZXIgaW4gW2xpc3RdLCBpZiBhbnksXG4gICAgICAgICAgICBvdGhlcndpc2UgcmV0dXJucyB0aGUgc3VtIG9mIHRoZSBsaXN0LiAqKVxuICAgICAgICBsZXQgZmlyc3RfbmVnX29yX3N1bSA9XG4gICAgICAgICAgTGlzdC5mb2xkX3VudGlsIH5pbml0OjBcbiAgICAgICAgICAgIH5mOihmdW4gc3VtIHggLT5cbiAgICAgICAgICAgICAgaWYgeCA8IDBcbiAgICAgICAgICAgICAgdGhlbiBTdG9wIChGb3VuZF9uZWdhdGl2ZSB4KVxuICAgICAgICAgICAgICBlbHNlIENvbnRpbnVlIChzdW0gKyB4KSlcbiAgICAgICAgICAgIH5maW5pc2g6KGZ1biBzdW0gLT4gQWxsX25vbm5lZ2F0aXZlIHsgc3VtIH0pXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHggPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAzOyA0OyA1XVxuICAgICAgICB2YWwgeCA6IG1heWJlX25lZ2F0aXZlID0gQWxsX25vbm5lZ2F0aXZlIHtzdW0gPSAxNX1cblxuICAgICAgICBsZXQgeSA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IC0zOyA0OyA1XVxuICAgICAgICB2YWwgeSA6IG1heWJlX25lZ2F0aXZlID0gRm91bmRfbmVnYXRpdmUgLTNcbiAgICAgIF19ICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiAnYSAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBwcm92aWRlZFxuICAgICAgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXS4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGV4aXN0cyA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZm9yX2FsbCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiAqKVxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+ICgnYSwgXykgdCAtPiBmOignYSAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIGZpcnN0IGV2YWx1YXRpb24gb2YgW2ZdIHRoYXQgcmV0dXJucyBbU29tZV0sIGFuZCByZXR1cm5zIFtOb25lXSBpZiB0aGVyZVxuICAgICAgaXMgbm8gc3VjaCBlbGVtZW50LiAgKilcbiAgdmFsIGZpbmRfbWFwIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiAoJ2EsIF8pIHQgLT4gJ2EgYXJyYXlcblxuICAoKiogUmV0dXJucyBhIG1pbiAocmVzcCBtYXgpIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgW2NvbXBhcmVdXG4gICAgICBmdW5jdGlvbi4gSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0IGVsZW1lbnQgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGVcbiAgICAgIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIFtmb2xkXSBzbyBpdCBoYXMgdGhlIHNhbWUgY29tcGxleGl0eVxuICAgICAgYXMgW2ZvbGRdLiBSZXR1cm5zIFtOb25lXSBpZmYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICopXG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBHZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdFxuICB0eXBlICdhIGVsdFxuXG4gIHZhbCBsZW5ndGggOiAoXywgXywgXykgdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbWVtIDogKCdhLCBfLCBfKSB0IC0+ICdhIGVsdCAtPiBlcXVhbDooJ2EgZWx0IC0+ICdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBpdGVyIDogKCdhLCBfLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBmb2xkIDogKCdhLCBfLCBfKSB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+ICdhIGVsdCAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgKCdhLCBfLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiAnYSBlbHQgLT4gKCdhY2MsICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjYywgJ2UpIFJlc3VsdC50XG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8sIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICdhIGVsdCAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZXhpc3RzIDogKCdhLCBfLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsIDogKCdhLCBfLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnYSwgXywgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHN1bVxuICAgIDogIChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICgnYSwgXywgXykgdFxuICAgIC0+IGY6KCdhIGVsdCAtPiAnc3VtKVxuICAgIC0+ICdzdW1cblxuICB2YWwgZmluZCA6ICgnYSwgXywgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgZmluZF9tYXAgOiAoJ2EsIF8sIF8pIHQgLT4gZjooJ2EgZWx0IC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG4gIHZhbCB0b19saXN0IDogKCdhLCBfLCBfKSB0IC0+ICdhIGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICgnYSwgXywgXykgdCAtPiAnYSBlbHQgYXJyYXlcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8sIF8pIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8sIF8pIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBTMF93aXRoX2NyZWF0b3JzID0gc2lnXG4gIGluY2x1ZGUgUzBcblxuICB2YWwgb2ZfbGlzdCA6IGVsdCBsaXN0IC0+IHRcbiAgdmFsIG9mX2FycmF5IDogZWx0IGFycmF5IC0+IHRcblxuICAoKiogRS5nLiwgW2FwcGVuZCAob2ZfbGlzdCBbYTsgYl0pIChvZl9saXN0IFtjOyBkOyBlXSldIGlzIFtvZl9saXN0IFthOyBiOyBjOyBkOyBlXV0gKilcbiAgdmFsIGFwcGVuZCA6IHQgLT4gdCAtPiB0XG5cbiAgKCoqIENvbmNhdGVuYXRlcyBhIG5lc3RlZCBjb250YWluZXIuIFRoZSBlbGVtZW50cyBvZiB0aGUgaW5uZXIgY29udGFpbmVycyBhcmVcbiAgICAgIGNvbmNhdGVuYXRlZCB0b2dldGhlciBpbiBvcmRlciB0byBnaXZlIHRoZSByZXN1bHQuICopXG4gIHZhbCBjb25jYXQgOiB0IGxpc3QgLT4gdFxuXG4gICgqKiBbbWFwIGYgKG9mX2xpc3QgW2ExOyAuLi47IGFuXSldIGFwcGxpZXMgW2ZdIHRvIFthMV0sIFthMl0sIC4uLiwgW2FuXSwgaW4gb3JkZXIsIGFuZFxuICAgICAgYnVpbGRzIGEgcmVzdWx0IGVxdWl2YWxlbnQgdG8gW29mX2xpc3QgW2YgYTE7IC4uLjsgZiBhbl1dLiAqKVxuICB2YWwgbWFwIDogdCAtPiBmOihlbHQgLT4gZWx0KSAtPiB0XG5cbiAgKCoqIFtmaWx0ZXIgdCB+Zl0gcmV0dXJucyBhbGwgdGhlIGVsZW1lbnRzIG9mIFt0XSB0aGF0IHNhdGlzZnkgdGhlIHByZWRpY2F0ZSBbZl0uICopXG4gIHZhbCBmaWx0ZXIgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiB0XG5cbiAgKCoqIFtmaWx0ZXJfbWFwIHQgfmZdIGFwcGxpZXMgW2ZdIHRvIGV2ZXJ5IFt4XSBpbiBbdF0uIFRoZSByZXN1bHQgY29udGFpbnMgZXZlcnkgW3ldIGZvclxuICAgICAgd2hpY2ggW2YgeF0gcmV0dXJucyBbU29tZSB5XS4gKilcbiAgdmFsIGZpbHRlcl9tYXAgOiB0IC0+IGY6KGVsdCAtPiBlbHQgb3B0aW9uKSAtPiB0XG5cbiAgKCoqIFtjb25jYXRfbWFwIHQgfmZdIGlzIGVxdWl2YWxlbnQgdG8gW2NvbmNhdCAobWFwIHQgfmYpXS4gKilcbiAgdmFsIGNvbmNhdF9tYXAgOiB0IC0+IGY6KGVsdCAtPiB0KSAtPiB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fdGYgdCB+Zl0gcmV0dXJucyBhIHBhaXIgW3QxLCB0Ml0sIHdoZXJlIFt0MV0gaXMgYWxsIGVsZW1lbnRzIG9mIFt0XSB0aGF0XG4gICAgICBzYXRpc2Z5IFtmXSwgYW5kIFt0Ml0gaXMgYWxsIGVsZW1lbnRzIG9mIFt0XSB0aGF0IGRvIG5vdCBzYXRpc2Z5IFtmXS4gVGhlIFwidGZcIlxuICAgICAgc3VmZml4IGlzIG1uZW1vbmljIHRvIHJlbWluZCByZWFkZXJzIHRoYXQgdGhlIHJlc3VsdCBpcyAodHJ1ZXMsIGZhbHNlcykuICopXG4gIHZhbCBwYXJ0aXRpb25fdGYgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiB0ICogdFxuXG4gICgqKiBbcGFydGl0aW9uX21hcCB0IH5mXSBwYXJ0aXRpb25zIFt0XSBhY2NvcmRpbmcgdG8gW2ZdLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcCA6IHQgLT4gZjooZWx0IC0+IChlbHQsIGVsdCkgRWl0aGVyMC50KSAtPiB0ICogdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxX3dpdGhfY3JlYXRvcnMgPSBzaWdcbiAgaW5jbHVkZSBTMVxuXG4gIHZhbCBvZl9saXN0IDogJ2EgbGlzdCAtPiAnYSB0XG4gIHZhbCBvZl9hcnJheSA6ICdhIGFycmF5IC0+ICdhIHRcblxuICAoKiogRS5nLiwgW2FwcGVuZCAob2ZfbGlzdCBbMTsgMl0pIChvZl9saXN0IFszOyA0OyA1XSldIGlzIFtvZl9saXN0IFsxOyAyOyAzOyA0OyA1XV0gKilcbiAgdmFsIGFwcGVuZCA6ICdhIHQgLT4gJ2EgdCAtPiAnYSB0XG5cbiAgKCoqIENvbmNhdGVuYXRlcyBhIG5lc3RlZCBjb250YWluZXIuIFRoZSBlbGVtZW50cyBvZiB0aGUgaW5uZXIgY29udGFpbmVycyBhcmVcbiAgICAgIGNvbmNhdGVuYXRlZCB0b2dldGhlciBpbiBvcmRlciB0byBnaXZlIHRoZSByZXN1bHQuICopXG4gIHZhbCBjb25jYXQgOiAnYSB0IHQgLT4gJ2EgdFxuXG4gICgqKiBbbWFwIGYgKG9mX2xpc3QgW2ExOyAuLi47IGFuXSldIGFwcGxpZXMgW2ZdIHRvIFthMV0sIFthMl0sIC4uLiwgW2FuXSwgaW4gb3JkZXIsIGFuZFxuICAgICAgYnVpbGRzIGEgcmVzdWx0IGVxdWl2YWxlbnQgdG8gW29mX2xpc3QgW2YgYTE7IC4uLjsgZiBhbl1dLiAqKVxuICB2YWwgbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuXG4gICgqKiBbZmlsdGVyIHQgfmZdIHJldHVybnMgYWxsIHRoZSBlbGVtZW50cyBvZiBbdF0gdGhhdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUgW2ZdLiAqKVxuICB2YWwgZmlsdGVyIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0XG5cbiAgKCoqIFtmaWx0ZXJfbWFwIHQgfmZdIGFwcGxpZXMgW2ZdIHRvIGV2ZXJ5IFt4XSBpbiBbdF0uIFRoZSByZXN1bHQgY29udGFpbnMgZXZlcnkgW3ldIGZvclxuICAgICAgd2hpY2ggW2YgeF0gcmV0dXJucyBbU29tZSB5XS4gKilcbiAgdmFsIGZpbHRlcl9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2IgdFxuXG4gICgqKiBbY29uY2F0X21hcCB0IH5mXSBpcyBlcXVpdmFsZW50IHRvIFtjb25jYXQgKG1hcCB0IH5mKV0uICopXG4gIHZhbCBjb25jYXRfbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYiB0KSAtPiAnYiB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fdGYgdCB+Zl0gcmV0dXJucyBhIHBhaXIgW3QxLCB0Ml0sIHdoZXJlIFt0MV0gaXMgYWxsIGVsZW1lbnRzIG9mIFt0XSB0aGF0XG4gICAgICBzYXRpc2Z5IFtmXSwgYW5kIFt0Ml0gaXMgYWxsIGVsZW1lbnRzIG9mIFt0XSB0aGF0IGRvIG5vdCBzYXRpc2Z5IFtmXS4gVGhlIFwidGZcIlxuICAgICAgc3VmZml4IGlzIG1uZW1vbmljIHRvIHJlbWluZCByZWFkZXJzIHRoYXQgdGhlIHJlc3VsdCBpcyAodHJ1ZXMsIGZhbHNlcykuICopXG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIHQgKiAnYSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fbWFwIHQgfmZdIHBhcnRpdGlvbnMgW3RdIGFjY29yZGluZyB0byBbZl0uICopXG4gIHZhbCBwYXJ0aXRpb25fbWFwIDogJ2EgdCAtPiBmOignYSAtPiAoJ2IsICdjKSBFaXRoZXIwLnQpIC0+ICdiIHQgKiAnYyB0XG5lbmRcblxubW9kdWxlIHR5cGUgR2VuZXJpY193aXRoX2NyZWF0b3JzID0gc2lnXG4gIHR5cGUgKF8sIF8sIF8pIGNvbmNhdFxuXG4gIGluY2x1ZGUgR2VuZXJpY1xuXG4gIHZhbCBvZl9saXN0IDogJ2EgZWx0IGxpc3QgLT4gKCdhLCBfLCBfKSB0XG4gIHZhbCBvZl9hcnJheSA6ICdhIGVsdCBhcnJheSAtPiAoJ2EsIF8sIF8pIHRcbiAgdmFsIGFwcGVuZCA6ICgnYSwgJ3AxLCAncDIpIHQgLT4gKCdhLCAncDEsICdwMikgdCAtPiAoJ2EsICdwMSwgJ3AyKSB0XG4gIHZhbCBjb25jYXQgOiAoKCdhLCAncDEsICdwMikgdCwgJ3AxLCAncDIpIGNvbmNhdCAtPiAoJ2EsICdwMSwgJ3AyKSB0XG4gIHZhbCBtYXAgOiAoJ2EsICdwMSwgJ3AyKSB0IC0+IGY6KCdhIGVsdCAtPiAnYiBlbHQpIC0+ICgnYiwgJ3AxLCAncDIpIHRcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ3AxLCAncDIpIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ3AxLCAncDIpIHRcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsICdwMSwgJ3AyKSB0IC0+IGY6KCdhIGVsdCAtPiAnYiBlbHQgb3B0aW9uKSAtPiAoJ2IsICdwMSwgJ3AyKSB0XG4gIHZhbCBjb25jYXRfbWFwIDogKCdhLCAncDEsICdwMikgdCAtPiBmOignYSBlbHQgLT4gKCdiLCAncDEsICdwMikgdCkgLT4gKCdiLCAncDEsICdwMikgdFxuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICAoJ2EsICdwMSwgJ3AyKSB0XG4gICAgLT4gZjooJ2EgZWx0IC0+IGJvb2wpXG4gICAgLT4gKCdhLCAncDEsICdwMikgdCAqICgnYSwgJ3AxLCAncDIpIHRcblxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogICgnYSwgJ3AxLCAncDIpIHRcbiAgICAtPiBmOignYSBlbHQgLT4gKCdiIGVsdCwgJ2MgZWx0KSBFaXRoZXIwLnQpXG4gICAgLT4gKCdiLCAncDEsICdwMikgdCAqICgnYywgJ3AxLCAncDIpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlX2dlbl9hcmcgPSBzaWdcbiAgdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGZvbGRcbiAgICA6ICAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiAnYSBlbHQgLT4gJ2FjYylcbiAgICAtPiAnYWNjXG5cbiAgKCoqIFRoZSBbaXRlcl0gYXJndW1lbnQgdG8gW0NvbnRhaW5lci5NYWtlXSBzcGVjaWZpZXMgaG93IHRvIGltcGxlbWVudCB0aGVcbiAgICAgIGNvbnRhaW5lcidzIFtpdGVyXSBmdW5jdGlvbi4gIFtgRGVmaW5lX3VzaW5nX2ZvbGRdIG1lYW5zIHRvIGRlZmluZSBbaXRlcl1cbiAgICAgIHZpYTpcblxuICAgICAge1tcbiAgICAgICAgaXRlciB0IH5mID0gQ29udGFpbmVyLml0ZXIgfmZvbGQgdCB+ZlxuICAgICAgXX1cblxuICAgICAgW2BDdXN0b21dIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgcHJlc3VtYWJseSB3aXRoIHNvbWV0aGluZyBtb3JlXG4gICAgICBlZmZpY2llbnQuICBTZXZlcmFsIG90aGVyIGZ1bmN0aW9ucyByZXR1cm5lZCBieSBbQ29udGFpbmVyLk1ha2VdIGFyZSBkZWZpbmVkIGluXG4gICAgICB0ZXJtcyBvZiBbaXRlcl0sIHNvIHBhc3NpbmcgaW4gYSBtb3JlIGVmZmljaWVudCBbaXRlcl0gd2lsbCBpbXByb3ZlIHRoZWlyIGVmZmljaWVuY3lcbiAgICAgIGFzIHdlbGwuICopXG4gIHZhbCBpdGVyXG4gICAgOiBbIGBEZWZpbmVfdXNpbmdfZm9sZFxuICAgICAgfCBgQ3VzdG9tIG9mICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHQgLT4gZjooJ2EgZWx0IC0+IHVuaXQpIC0+IHVuaXRcbiAgICAgIF1cblxuICAoKiogVGhlIFtsZW5ndGhdIGFyZ3VtZW50IHRvIFtDb250YWluZXIuTWFrZV0gc3BlY2lmaWVzIGhvdyB0byBpbXBsZW1lbnQgdGhlXG4gICAgICBjb250YWluZXIncyBbbGVuZ3RoXSBmdW5jdGlvbi4gIFtgRGVmaW5lX3VzaW5nX2ZvbGRdIG1lYW5zIHRvIGRlZmluZVxuICAgICAgW2xlbmd0aF0gdmlhOlxuXG4gICAgICB7W1xuICAgICAgICBsZW5ndGggdCB+ZiA9IENvbnRhaW5lci5sZW5ndGggfmZvbGQgdCB+ZlxuICAgICAgXX1cblxuICAgICAgW2BDdXN0b21dIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgcHJlc3VtYWJseSB3aXRoIHNvbWV0aGluZyBtb3JlXG4gICAgICBlZmZpY2llbnQuICBTZXZlcmFsIG90aGVyIGZ1bmN0aW9ucyByZXR1cm5lZCBieSBbQ29udGFpbmVyLk1ha2VdIGFyZSBkZWZpbmVkIGluXG4gICAgICB0ZXJtcyBvZiBbbGVuZ3RoXSwgc28gcGFzc2luZyBpbiBhIG1vcmUgZWZmaWNpZW50IFtsZW5ndGhdIHdpbGwgaW1wcm92ZSB0aGVpclxuICAgICAgZWZmaWNpZW5jeSBhcyB3ZWxsLiAqKVxuICB2YWwgbGVuZ3RoIDogWyBgRGVmaW5lX3VzaW5nX2ZvbGQgfCBgQ3VzdG9tIG9mICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHQgLT4gaW50IF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlX2FyZyA9IHNpZ1xuICB0eXBlICdhIHRcblxuICBpbmNsdWRlIE1ha2VfZ2VuX2FyZyB3aXRoIHR5cGUgKCdhLCBfLCBfKSB0IDo9ICdhIHQgYW5kIHR5cGUgJ2EgZWx0IDo9ICdhXG5lbmRcblxubW9kdWxlIHR5cGUgTWFrZTBfYXJnID0gc2lnXG4gIG1vZHVsZSBFbHQgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sXG4gIGVuZFxuXG4gIHR5cGUgdFxuXG4gIGluY2x1ZGUgTWFrZV9nZW5fYXJnIHdpdGggdHlwZSAoJ2EsIF8sIF8pIHQgOj0gdCBhbmQgdHlwZSAnYSBlbHQgOj0gRWx0LnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlX2NvbW1vbl93aXRoX2NyZWF0b3JzX2FyZyA9IHNpZ1xuICBpbmNsdWRlIE1ha2VfZ2VuX2FyZ1xuXG4gIHR5cGUgKF8sIF8sIF8pIGNvbmNhdFxuXG4gIHZhbCBvZl9saXN0IDogJ2EgZWx0IGxpc3QgLT4gKCdhLCBfLCBfKSB0XG4gIHZhbCBvZl9hcnJheSA6ICdhIGVsdCBhcnJheSAtPiAoJ2EsIF8sIF8pIHRcbiAgdmFsIGNvbmNhdCA6ICgoJ2EsIF8sIF8pIHQsIF8sIF8pIGNvbmNhdCAtPiAoJ2EsIF8sIF8pIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlX2dlbl93aXRoX2NyZWF0b3JzX2FyZyA9IHNpZ1xuICBpbmNsdWRlIE1ha2VfY29tbW9uX3dpdGhfY3JlYXRvcnNfYXJnXG5cbiAgdmFsIGNvbmNhdF9vZl9hcnJheSA6ICdhIGFycmF5IC0+ICgnYSwgXywgXykgY29uY2F0XG5lbmRcblxubW9kdWxlIHR5cGUgTWFrZV93aXRoX2NyZWF0b3JzX2FyZyA9IHNpZ1xuICB0eXBlICdhIHRcblxuICBpbmNsdWRlXG4gICAgTWFrZV9jb21tb25fd2l0aF9jcmVhdG9yc19hcmdcbiAgICAgIHdpdGggdHlwZSAoJ2EsIF8sIF8pIHQgOj0gJ2EgdFxuICAgICAgIGFuZCB0eXBlICdhIGVsdCA6PSAnYVxuICAgICAgIGFuZCB0eXBlICgnYSwgXywgXykgY29uY2F0IDo9ICdhIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlMF93aXRoX2NyZWF0b3JzX2FyZyA9IHNpZ1xuICBtb2R1bGUgRWx0IDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICBlbmRcblxuICB0eXBlIHRcblxuICBpbmNsdWRlXG4gICAgTWFrZV9jb21tb25fd2l0aF9jcmVhdG9yc19hcmdcbiAgICAgIHdpdGggdHlwZSAoJ2EsIF8sIF8pIHQgOj0gdFxuICAgICAgIGFuZCB0eXBlICdhIGVsdCA6PSBFbHQudFxuICAgICAgIGFuZCB0eXBlICgnYSwgXywgXykgY29uY2F0IDo9ICdhIGxpc3RcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkID0gc2lnXG4gICgqKiBHZW5lcmljIGRlZmluaXRpb25zIG9mIGNvbnRhaW5lciBvcGVyYXRpb25zIGluIHRlcm1zIG9mIFtmb2xkXS5cblxuICAgICAgRS5nLjogW2l0ZXIgfmZvbGQgdCB+ZiA9IGZvbGQgdCB+aW5pdDooKSB+ZjooZnVuICgpIGEgLT4gZiBhKV0uICopXG5cbiAgdHlwZSAoJ3QsICdhLCAnYWNjKSBmb2xkID0gJ3QgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gJ2EgLT4gJ2FjYykgLT4gJ2FjY1xuICB0eXBlICgndCwgJ2EpIGl0ZXIgPSAndCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHR5cGUgJ3QgbGVuZ3RoID0gJ3QgLT4gaW50XG5cbiAgdmFsIGl0ZXIgOiBmb2xkOigndCwgJ2EsIHVuaXQpIGZvbGQgLT4gKCd0LCAnYSkgaXRlclxuICB2YWwgY291bnQgOiBmb2xkOigndCwgJ2EsIGludCkgZm9sZCAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgbWluX2VsdFxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ2Egb3B0aW9uKSBmb2xkXG4gICAgLT4gJ3RcbiAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1heF9lbHRcbiAgICA6ICBmb2xkOigndCwgJ2EsICdhIG9wdGlvbikgZm9sZFxuICAgIC0+ICd0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBsZW5ndGggOiBmb2xkOigndCwgXywgaW50KSBmb2xkIC0+ICd0IC0+IGludFxuICB2YWwgdG9fbGlzdCA6IGZvbGQ6KCd0LCAnYSwgJ2EgbGlzdCkgZm9sZCAtPiAndCAtPiAnYSBsaXN0XG5cbiAgdmFsIHN1bVxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ3N1bSkgZm9sZFxuICAgIC0+IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICd0XG4gICAgLT4gZjooJ2EgLT4gJ3N1bSlcbiAgICAtPiAnc3VtXG5cbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYWNjKSBmb2xkXG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiAnYSAtPiAoJ2FjYywgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICd0XG4gICAgLT4gKCdhY2MsICdlKSBSZXN1bHQudFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYWNjKSBmb2xkXG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiAnYSAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAndFxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBHZW5lcmljIGRlZmluaXRpb25zIG9mIGNvbnRhaW5lciBvcGVyYXRpb25zIGluIHRlcm1zIG9mIFtpdGVyXSBhbmQgW2xlbmd0aF0uICopXG5cbiAgdmFsIGlzX2VtcHR5IDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGJvb2xcbiAgdmFsIG1lbSA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiAnYSAtPiBlcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGwgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZmluZCA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cbiAgdmFsIGZpbmRfbWFwIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG4gIHZhbCB0b19hcnJheSA6IGxlbmd0aDondCBsZW5ndGggLT4gaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+ICdhIGFycmF5XG5lbmRcblxubW9kdWxlIHR5cGUgQ29udGFpbmVyID0gc2lnXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBFeHBvcnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzAgPSBTMFxuICBtb2R1bGUgdHlwZSBTMF9waGFudG9tID0gUzBfcGhhbnRvbVxuICBtb2R1bGUgdHlwZSBTMF93aXRoX2NyZWF0b3JzID0gUzBfd2l0aF9jcmVhdG9yc1xuICBtb2R1bGUgdHlwZSBTMSA9IFMxXG4gIG1vZHVsZSB0eXBlIFMxX3BoYW50b20gPSBTMV9waGFudG9tXG4gIG1vZHVsZSB0eXBlIFMxX3dpdGhfY3JlYXRvcnMgPSBTMV93aXRoX2NyZWF0b3JzXG4gIG1vZHVsZSB0eXBlIERlcml2ZWQgPSBEZXJpdmVkXG4gIG1vZHVsZSB0eXBlIEdlbmVyaWMgPSBHZW5lcmljXG4gIG1vZHVsZSB0eXBlIEdlbmVyaWNfd2l0aF9jcmVhdG9ycyA9IEdlbmVyaWNfd2l0aF9jcmVhdG9yc1xuICBtb2R1bGUgdHlwZSBTdW1tYWJsZSA9IFN1bW1hYmxlXG5cbiAgaW5jbHVkZSBEZXJpdmVkXG5cbiAgKCoqIFRoZSBpZGlvbSBmb3IgdXNpbmcgW0NvbnRhaW5lci5NYWtlXSBpcyB0byBiaW5kIHRoZSByZXN1bHRpbmcgbW9kdWxlIGFuZCB0b1xuICAgICAgZXhwbGljaXRseSBpbXBvcnQgZWFjaCBvZiB0aGUgZnVuY3Rpb25zIHRoYXQgb25lIHdhbnRzOlxuXG4gICAgICB7W1xuICAgICAgICBtb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlIChzdHJ1Y3QgLi4uIGVuZClcbiAgICAgICAgbGV0IGNvdW50ICAgID0gQy5jb3VudFxuICAgICAgICBsZXQgZXhpc3RzICAgPSBDLmV4aXN0c1xuICAgICAgICBsZXQgZmluZCAgICAgPSBDLmZpbmRcbiAgICAgICAgKCogLi4uICopXG4gICAgICBdfVxuXG4gICAgICBUaGlzIGlzIHByZWZlcmFibGUgdG86XG5cbiAgICAgIHtbXG4gICAgICAgIGluY2x1ZGUgQ29udGFpbmVyLk1ha2UgKHN0cnVjdCAuLi4gZW5kKVxuICAgICAgXX1cblxuICAgICAgYmVjYXVzZSB0aGUgW2luY2x1ZGVdIG1ha2VzIGl0IHRvbyBlYXN5IHRvIHNoYWRvdyBzcGVjaWFsaXplZCBpbXBsZW1lbnRhdGlvbnMgb2ZcbiAgICAgIGNvbnRhaW5lciBmdW5jdGlvbnMgKFtsZW5ndGhdIGJlaW5nIGEgY29tbW9uIG9uZSkuXG5cbiAgICAgIFtDb250YWluZXIuTWFrZTBdIGlzIGxpa2UgW0NvbnRhaW5lci5NYWtlXSwgYnV0IGZvciBtb25vbW9ycGhpYyBjb250YWluZXJzIGxpa2VcbiAgICAgIFtzdHJpbmddLiAqKVxuICBtb2R1bGUgTWFrZSAoVCA6IE1ha2VfYXJnKSA6IFMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudFxuXG4gIG1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgOiBTMCB3aXRoIHR5cGUgdCA6PSBULnQgYW5kIHR5cGUgZWx0IDo9IFQuRWx0LnRcblxuICBtb2R1bGUgTWFrZV9nZW4gKFQgOiBNYWtlX2dlbl9hcmcpIDpcbiAgICBHZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdCA6PSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBULnRcbiAgICAgICBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHRcblxuICBtb2R1bGUgTWFrZV93aXRoX2NyZWF0b3JzIChUIDogTWFrZV93aXRoX2NyZWF0b3JzX2FyZykgOlxuICAgIFMxX3dpdGhfY3JlYXRvcnMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50XG5cbiAgbW9kdWxlIE1ha2UwX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlMF93aXRoX2NyZWF0b3JzX2FyZykgOlxuICAgIFMwX3dpdGhfY3JlYXRvcnMgd2l0aCB0eXBlIHQgOj0gVC50IGFuZCB0eXBlIGVsdCA6PSBULkVsdC50XG5cbiAgbW9kdWxlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlX2dlbl93aXRoX2NyZWF0b3JzX2FyZykgOlxuICAgIEdlbmVyaWNfd2l0aF9jcmVhdG9yc1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHQgOj0gKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgVC50XG4gICAgICAgYW5kIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0XG4gICAgICAgYW5kIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgY29uY2F0IDo9ICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIFQuY29uY2F0XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgRWl0aGVyID0gRWl0aGVyMFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBDb250YWluZXJfaW50ZlxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG50eXBlICgndCwgJ2EsICdhY2N1bSkgZm9sZCA9ICd0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxudHlwZSAoJ3QsICdhKSBpdGVyID0gJ3QgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxudHlwZSAndCBsZW5ndGggPSAndCAtPiBpbnRcblxubGV0IGl0ZXIgfihmb2xkIDogKF8sIF8sIF8pIGZvbGQpIHQgfmYgPSBmb2xkIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBhIC0+IGYgYSkgW0Bub250YWlsXVxubGV0IGNvdW50IH5mb2xkIHQgfmYgPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIG4gYSAtPiBpZiBmIGEgdGhlbiBuICsgMSBlbHNlIG4pIFtAbm9udGFpbF1cblxubGV0IHN1bSAodHlwZSBhKSB+Zm9sZCAobW9kdWxlIE0gOiBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9IGEpIHQgfmYgPVxuICBmb2xkIHQgfmluaXQ6TS56ZXJvIH5mOihmdW4gbiBhIC0+IE0uKCArICkgbiAoZiBhKSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHQgPVxuICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICBSZXN1bHQuT2tcbiAgICAgIChmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgaXRlbSAtPlxuICAgICAgICAgbWF0Y2ggZiBhY2MgaXRlbSB3aXRoXG4gICAgICAgICB8IFJlc3VsdC5PayB4IC0+IHhcbiAgICAgICAgIHwgRXJyb3IgXyBhcyBlIC0+IHJldHVybiBlKSkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIH5maW5pc2ggdCA9XG4gIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIGZpbmlzaFxuICAgICAgKGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBpdGVtIC0+XG4gICAgICAgICBtYXRjaCBmIGFjYyBpdGVtIHdpdGhcbiAgICAgICAgIHwgQ29udGludWVfb3Jfc3RvcC5Db250aW51ZSB4IC0+IHhcbiAgICAgICAgIHwgU3RvcCB4IC0+IHJldHVybiB4KSkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtaW5fZWx0IH5mb2xkIHQgfmNvbXBhcmUgPVxuICBmb2xkIHQgfmluaXQ6Tm9uZSB+ZjooZnVuIGFjYyBlbHQgLT5cbiAgICBtYXRjaCBhY2Mgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIGVsdFxuICAgIHwgU29tZSBtaW4gLT4gaWYgY29tcGFyZSBtaW4gZWx0ID4gMCB0aGVuIFNvbWUgZWx0IGVsc2UgYWNjKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlID1cbiAgZm9sZCB0IH5pbml0Ok5vbmUgfmY6KGZ1biBhY2MgZWx0IC0+XG4gICAgbWF0Y2ggYWNjIHdpdGhcbiAgICB8IE5vbmUgLT4gU29tZSBlbHRcbiAgICB8IFNvbWUgbWF4IC0+IGlmIGNvbXBhcmUgbWF4IGVsdCA8IDAgdGhlbiBTb21lIGVsdCBlbHNlIGFjYykgW0Bub250YWlsXVxuOztcblxubGV0IGxlbmd0aCB+Zm9sZCBjID0gZm9sZCBjIH5pbml0OjAgfmY6KGZ1biBhY2MgXyAtPiBhY2MgKyAxKVxuXG5sZXQgaXNfZW1wdHkgfml0ZXIgYyA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIF8gLT4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgbWVtIH5pdGVyIGMgeCB+ZXF1YWwgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB5IC0+IGlmIGVxdWFsIHggeSB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgIGZhbHNlKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZXhpc3RzIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgIGZhbHNlKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9yX2FsbCB+aXRlciBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4geCAtPiBpZiBub3QgKGYgeCkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgdHJ1ZSkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmRfbWFwIH5pdGVyIHQgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIHQgfmY6KGZ1biB4IC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gci5yZXR1cm4gcmVzKTtcbiAgICBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZCB+aXRlciBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiByLnJldHVybiAoU29tZSB4KSk7XG4gICAgTm9uZSkgW0Bub250YWlsXVxuOztcblxubGV0IHRvX2xpc3QgfmZvbGQgYyA9IExpc3QucmV2IChmb2xkIGMgfmluaXQ6W10gfmY6KGZ1biBhY2MgeCAtPiB4IDo6IGFjYykpXG5cbmxldCB0b19hcnJheSB+bGVuZ3RoIH5pdGVyIGMgPVxuICBsZXQgYXJyYXkgPSByZWYgW3x8XSBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGl0ZXIgYyB+ZjooZnVuIHggLT5cbiAgICBpZiAhaSA9IDAgdGhlbiBhcnJheSA6PSBBcnJheS5jcmVhdGUgfmxlbjoobGVuZ3RoIGMpIHg7XG4gICAgIWFycmF5LighaSkgPC0geDtcbiAgICBpbmNyIGkpO1xuICAhYXJyYXlcbjs7XG5cbm1vZHVsZSBNYWtlX2dlbiAoVCA6IE1ha2VfZ2VuX2FyZykgOlxuICBHZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHQgOj0gKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgVC50XG4gICAgIGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdCA9IHN0cnVjdFxuICBsZXQgZm9sZCA9IFQuZm9sZFxuXG4gIGxldCBpdGVyID1cbiAgICBtYXRjaCBULml0ZXIgd2l0aFxuICAgIHwgYEN1c3RvbSBpdGVyIC0+IGl0ZXJcbiAgICB8IGBEZWZpbmVfdXNpbmdfZm9sZCAtPiBmdW4gdCB+ZiAtPiBpdGVyIH5mb2xkIHQgfmZcbiAgOztcblxuICBsZXQgbGVuZ3RoID1cbiAgICBtYXRjaCBULmxlbmd0aCB3aXRoXG4gICAgfCBgQ3VzdG9tIGxlbmd0aCAtPiBsZW5ndGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfZm9sZCAtPiBmdW4gdCAtPiBsZW5ndGggfmZvbGQgdFxuICA7O1xuXG4gIGxldCBpc19lbXB0eSB0ID0gaXNfZW1wdHkgfml0ZXIgdFxuICBsZXQgbWVtIHQgeCB+ZXF1YWwgPSBtZW0gfml0ZXIgdCB4IH5lcXVhbFxuICBsZXQgc3VtIG0gdCA9IHN1bSB+Zm9sZCBtIHRcbiAgbGV0IGNvdW50IHQgfmYgPSBjb3VudCB+Zm9sZCB0IH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IGV4aXN0cyB+aXRlciB0IH5mXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsIH5pdGVyIHQgfmZcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcCB+aXRlciB0IH5mXG4gIGxldCBmaW5kIHQgfmYgPSBmaW5kIH5pdGVyIHQgfmZcbiAgbGV0IHRvX2xpc3QgdCA9IHRvX2xpc3QgfmZvbGQgdFxuICBsZXQgdG9fYXJyYXkgdCA9IHRvX2FycmF5IH5sZW5ndGggfml0ZXIgdFxuICBsZXQgbWluX2VsdCB0IH5jb21wYXJlID0gbWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBtYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBmb2xkX3Jlc3VsdCB0IH5mb2xkIH5pbml0IH5mXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IGZvbGRfdW50aWwgdCB+Zm9sZCB+aW5pdCB+ZiB+ZmluaXNoXG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICB0eXBlICgnYSwgXywgXykgdCA9ICdhIFQudFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgZW5kKVxuZW5kXG5cbm1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICB0eXBlICgnYSwgXywgXykgdCA9IFQudFxuICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICBlbmQpXG5cbiAgbGV0IG1lbSB0IHggPSBtZW0gdCB4IH5lcXVhbDpULkVsdC5lcXVhbFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlbl93aXRoX2NyZWF0b3JzIChUIDogTWFrZV9nZW5fd2l0aF9jcmVhdG9yc19hcmcpIDpcbiAgR2VuZXJpY193aXRoX2NyZWF0b3JzXG4gICAgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHQgOj0gKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgVC50XG4gICAgIGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdFxuICAgICBhbmQgdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBjb25jYXQgOj0gKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgVC5jb25jYXQgPVxuc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW4gKFQpXG5cbiAgbGV0IG9mX2xpc3QgPSBULm9mX2xpc3RcbiAgbGV0IG9mX2FycmF5ID0gVC5vZl9hcnJheVxuICBsZXQgY29uY2F0ID0gVC5jb25jYXRcbiAgbGV0IGNvbmNhdF9vZl9hcnJheSA9IFQuY29uY2F0X29mX2FycmF5XG4gIGxldCBhcHBlbmQgYSBiID0gY29uY2F0IChjb25jYXRfb2ZfYXJyYXkgW3wgYTsgYiB8XSlcbiAgbGV0IGNvbmNhdF9tYXAgdCB+ZiA9IGNvbmNhdCAoY29uY2F0X29mX2FycmF5IChBcnJheS5tYXAgKHRvX2FycmF5IHQpIH5mKSlcblxuICBsZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgICBjb25jYXRfbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBOb25lIC0+IG9mX2FycmF5IFt8fF1cbiAgICAgIHwgU29tZSB5IC0+IG9mX2FycmF5IFt8IHkgfF0pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgbWFwIHQgfmYgPSBmaWx0ZXJfbWFwIHQgfmY6KGZ1biB4IC0+IFNvbWUgKGYgeCkpIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlciB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKSBbQG5vbnRhaWxdXG5cbiAgbGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9XG4gICAgbGV0IGFycmF5ID0gQXJyYXkubWFwICh0b19hcnJheSB0KSB+ZiBpblxuICAgIGxldCB4cyA9XG4gICAgICBBcnJheS5mb2xkX3JpZ2h0IGFycmF5IH5pbml0OltdIH5mOihmdW4gZWl0aGVyIGFjYyAtPlxuICAgICAgICBtYXRjaCAoZWl0aGVyIDogXyBFaXRoZXIudCkgd2l0aFxuICAgICAgICB8IEZpcnN0IHggLT4geCA6OiBhY2NcbiAgICAgICAgfCBTZWNvbmQgXyAtPiBhY2MpXG4gICAgaW5cbiAgICBsZXQgeXMgPVxuICAgICAgQXJyYXkuZm9sZF9yaWdodCBhcnJheSB+aW5pdDpbXSB+ZjooZnVuIGVpdGhlciBhY2MgLT5cbiAgICAgICAgbWF0Y2ggKGVpdGhlciA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgfCBGaXJzdCBfIC0+IGFjY1xuICAgICAgICB8IFNlY29uZCB4IC0+IHggOjogYWNjKVxuICAgIGluXG4gICAgb2ZfbGlzdCB4cywgb2ZfbGlzdCB5c1xuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gICAgcGFydGl0aW9uX21hcCB0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBGaXJzdCB4IGVsc2UgU2Vjb25kIHgpIFtAbm9udGFpbF1cbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV93aXRoX2NyZWF0b3JzIChUIDogTWFrZV93aXRoX2NyZWF0b3JzX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbl93aXRoX2NyZWF0b3JzIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIHR5cGUgKCdhLCBfLCBfKSB0ID0gJ2EgVC50XG4gICAgdHlwZSAnYSBlbHQgPSAnYVxuICAgIHR5cGUgKCdhLCBfLCBfKSBjb25jYXQgPSAnYSBULnRcblxuICAgIGxldCBjb25jYXRfb2ZfYXJyYXkgPSBvZl9hcnJheVxuICBlbmQpXG5lbmRcblxubW9kdWxlIE1ha2UwX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlMF93aXRoX2NyZWF0b3JzX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbl93aXRoX2NyZWF0b3JzIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIHR5cGUgKCdhLCBfLCBfKSB0ID0gVC50XG4gICAgdHlwZSAnYSBlbHQgPSBULkVsdC50XG4gICAgdHlwZSAoJ2EsIF8sIF8pIGNvbmNhdCA9ICdhIGxpc3RcblxuICAgIGxldCBjb25jYXRfb2ZfYXJyYXkgPSBBcnJheS50b19saXN0XG4gIGVuZClcblxuICBsZXQgbWVtIHQgeCA9IG1lbSB0IHggfmVxdWFsOlQuRWx0LmVxdWFsXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5pbmNsdWRlIEluZGV4ZWRfY29udGFpbmVyX2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxubGV0W0BpbmxpbmUgYWx3YXlzXSBpdGVyaSB+Zm9sZCB0IH5mID1cbiAgaWdub3JlXG4gICAgKGZvbGQgdCB+aW5pdDowIH5mOihmdW4gaSB4IC0+XG4gICAgICAgZiBpIHg7XG4gICAgICAgaSArIDEpXG4gICAgICA6IGludClcbjs7XG5cbmxldCBmb2xkaSB+Zm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgdiAtPlxuICAgIGxldCBhY2MgPSBmICFpIGFjYyB2IGluXG4gICAgaSA6PSAhaSArIDE7XG4gICAgYWNjKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgY291bnRpIH5mb2xkaSB0IH5mID1cbiAgZm9sZGkgdCB+aW5pdDowIH5mOihmdW4gaSBuIGEgLT4gaWYgZiBpIGEgdGhlbiBuICsgMSBlbHNlIG4pIFtAbm9udGFpbF1cbjs7XG5cbmxldCBleGlzdHNpIH5pdGVyaSBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgYyB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgIGZhbHNlKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9yX2FsbGkgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIG5vdCAoZiBpIHgpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kX21hcGkgfml0ZXJpIHQgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBtYXRjaCBmIGkgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByLnJldHVybiByZXMpO1xuICAgIE5vbmUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kaSB+aXRlcmkgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIGMgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiByLnJldHVybiAoU29tZSAoaSwgeCkpKTtcbiAgICBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG4oKiBBbGxvd3MgW01ha2VfZ2VuXSB0byBzaGFyZSBhIFtDb250YWluZXIuR2VuZXJpY10gaW1wbGVtZW50YXRpb24gd2l0aCwgZS5nLixcbiAgIFtDb250YWluZXIuTWFrZV9nZW5fd2l0aF9jcmVhdG9yc10uICopXG5tb2R1bGUgTWFrZV9nZW5fd2l0aF9jb250YWluZXJcbiAgKFQgOiBNYWtlX2dlbl9hcmcpXG4gIChDIDogQ29udGFpbmVyLkdlbmVyaWNcbiAgICAgICAgIHdpdGggdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSB0IDo9ICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIFQudFxuICAgICAgICAgIGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdCkgOlxuICBHZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHQgOj0gKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgVC50XG4gICAgIGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdCA9IHN0cnVjdFxuICBpbmNsdWRlIENcblxuICBsZXQgaXRlcmkgPVxuICAgIG1hdGNoIFQuaXRlcmkgd2l0aFxuICAgIHwgYEN1c3RvbSBpdGVyaSAtPiBpdGVyaVxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5mIC0+IGl0ZXJpIH5mb2xkIHQgfmZcbiAgOztcblxuICBsZXQgZm9sZGkgPVxuICAgIG1hdGNoIFQuZm9sZGkgd2l0aFxuICAgIHwgYEN1c3RvbSBmb2xkaSAtPiBmb2xkaVxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5pbml0IH5mIC0+IGZvbGRpIH5mb2xkIHQgfmluaXQgfmZcbiAgOztcblxuICBsZXQgY291bnRpIHQgfmYgPSBjb3VudGkgfmZvbGRpIHQgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IGV4aXN0c2kgfml0ZXJpIHQgfmZcbiAgbGV0IGZvcl9hbGxpIHQgfmYgPSBmb3JfYWxsaSB+aXRlcmkgdCB+ZlxuICBsZXQgZmluZF9tYXBpIHQgfmYgPSBmaW5kX21hcGkgfml0ZXJpIHQgfmZcbiAgbGV0IGZpbmRpIHQgfmYgPSBmaW5kaSB+aXRlcmkgdCB+ZlxuZW5kXG5bQEBpbmxpbmUgYWx3YXlzXVxuXG5tb2R1bGUgTWFrZV9nZW4gKFQgOiBNYWtlX2dlbl9hcmcpIDpcbiAgR2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSB0IDo9ICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIFQudFxuICAgICBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHQgPSBzdHJ1Y3RcbiAgbW9kdWxlIEMgPSBDb250YWluZXIuTWFrZV9nZW4gKFQpXG4gIGluY2x1ZGUgQ1xuICBpbmNsdWRlIE1ha2VfZ2VuX3dpdGhfY29udGFpbmVyIChUKSAoQylcbmVuZFxuW0BAaW5saW5lIGFsd2F5c11cblxubW9kdWxlIE1ha2UgKFQgOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICB0eXBlICgnYSwgXywgXykgdCA9ICdhIFQudFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgZW5kKVxuZW5kXG5bQEBpbmxpbmUgYWx3YXlzXVxuXG5tb2R1bGUgTWFrZTAgKFQgOiBNYWtlMF9hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAoXywgXywgXykgdCA9IFQudFxuICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICBlbmQpXG5cbiAgbGV0IG1lbSB0IHggPSBtZW0gdCB4IH5lcXVhbDpULkVsdC5lcXVhbFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlbl93aXRoX2NyZWF0b3JzIChUIDogTWFrZV9nZW5fd2l0aF9jcmVhdG9yc19hcmcpIDpcbiAgR2VuZXJpY193aXRoX2NyZWF0b3JzXG4gICAgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHQgOj0gKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgVC50XG4gICAgIGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdFxuICAgICBhbmQgdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBjb25jYXQgOj0gKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgVC5jb25jYXQgPVxuc3RydWN0XG4gIG1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKFQpXG4gIGluY2x1ZGUgQ1xuICBpbmNsdWRlIE1ha2VfZ2VuX3dpdGhfY29udGFpbmVyIChUKSAoQylcblxuICBsZXQgZGVyaXZlZF9pbml0IG4gfmYgPSBvZl9hcnJheSAoQXJyYXkuaW5pdCBuIH5mKVxuXG4gIGxldCBpbml0ID1cbiAgICBtYXRjaCBULmluaXQgd2l0aFxuICAgIHwgYEN1c3RvbSBpbml0IC0+IGluaXRcbiAgICB8IGBEZWZpbmVfdXNpbmdfb2ZfYXJyYXkgLT4gZGVyaXZlZF9pbml0XG4gIDs7XG5cbiAgbGV0IGRlcml2ZWRfY29uY2F0X21hcGkgdCB+ZiA9IGNvbmNhdCAoVC5jb25jYXRfb2ZfYXJyYXkgKEFycmF5Lm1hcGkgKHRvX2FycmF5IHQpIH5mKSlcblxuICBsZXQgY29uY2F0X21hcGkgPVxuICAgIG1hdGNoIFQuY29uY2F0X21hcGkgd2l0aFxuICAgIHwgYEN1c3RvbSBjb25jYXRfbWFwaSAtPiBjb25jYXRfbWFwaVxuICAgIHwgYERlZmluZV91c2luZ19jb25jYXQgLT4gZGVyaXZlZF9jb25jYXRfbWFwaVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgICBjb25jYXRfbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBtYXRjaCBmIGkgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gb2ZfYXJyYXkgW3x8XVxuICAgICAgfCBTb21lIHkgLT4gb2ZfYXJyYXkgW3wgeSB8XSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBtYXBpIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gaSB4IC0+IFNvbWUgKGYgaSB4KSkgW0Bub250YWlsXVxuXG4gIGxldCBmaWx0ZXJpIHQgfmYgPVxuICAgIGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiBTb21lIHggZWxzZSBOb25lKSBbQG5vbnRhaWxdXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2Vfd2l0aF9jcmVhdG9ycyAoVCA6IE1ha2Vfd2l0aF9jcmVhdG9yc19hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW5fd2l0aF9jcmVhdG9ycyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICB0eXBlICgnYSwgXywgXykgdCA9ICdhIFQudFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgICB0eXBlICgnYSwgXywgXykgY29uY2F0ID0gJ2EgVC50XG5cbiAgICBsZXQgY29uY2F0X29mX2FycmF5ID0gb2ZfYXJyYXlcbiAgZW5kKVxuZW5kXG5cbm1vZHVsZSBNYWtlMF93aXRoX2NyZWF0b3JzIChUIDogTWFrZTBfd2l0aF9jcmVhdG9yc19hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW5fd2l0aF9jcmVhdG9ycyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICB0eXBlIChfLCBfLCBfKSB0ID0gVC50XG4gICAgdHlwZSAnYSBlbHQgPSBULkVsdC50XG4gICAgdHlwZSAoJ2EsIF8sIF8pIGNvbmNhdCA9ICdhIGxpc3RcblxuICAgIGxldCBjb25jYXRfb2ZfYXJyYXkgPSBBcnJheS50b19saXN0XG4gIGVuZClcblxuICBsZXQgbWVtIHQgeCA9IG1lbSB0IHggfmVxdWFsOlQuRWx0LmVxdWFsXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTdGRsaWIuTGF6eVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3QgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGxhenlfdF9vZl9zZXhwXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9sYXp5X3RcblxubGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBsYXp5X3Rfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbjs7XG5cbltAQEBlbmRdXG5cbmV4dGVybmFsIGZvcmNlIDogKCdhIHRbQGxvY2FsX29wdF0pIC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5cbmxldCBnbG9iYWxpemUgPSBHbG9iYWxpemUuZ2xvYmFsaXplX2xhenlfdFxubGV0IG1hcCB0IH5mID0gbGF6eSAoZiAoZm9yY2UgdCkpXG5cbmxldCBjb21wYXJlX19sb2NhbCBjb21wYXJlX2EgdDEgdDIgPVxuICBpZiBwaHlzX2VxdWFsIHQxIHQyIHRoZW4gMCBlbHNlIGNvbXBhcmVfYSAoZm9yY2UgdDEpIChmb3JjZSB0Milcbjs7XG5cbmxldCBjb21wYXJlIGNvbXBhcmVfYSB0MSB0MiA9IGNvbXBhcmVfX2xvY2FsIGNvbXBhcmVfYSB0MSB0MlxuXG5sZXQgZXF1YWxfX2xvY2FsIGVxdWFsX2EgdDEgdDIgPVxuICBpZiBwaHlzX2VxdWFsIHQxIHQyIHRoZW4gdHJ1ZSBlbHNlIGVxdWFsX2EgKGZvcmNlIHQxKSAoZm9yY2UgdDIpXG47O1xuXG5sZXQgZXF1YWwgZXF1YWxfYSB0MSB0MiA9IGVxdWFsX19sb2NhbCBlcXVhbF9hIHQxIHQyXG5sZXQgaGFzaF9mb2xkX3QgPSBIYXNoLkJ1aWx0aW4uaGFzaF9mb2xkX2xhenlfdFxubGV0IHBlZWsgdCA9IGlmIGlzX3ZhbCB0IHRoZW4gU29tZSAoZm9yY2UgdCkgZWxzZSBOb25lXG5cbmluY2x1ZGUgTW9uYWQuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IHJldHVybiB4ID0gZnJvbV92YWwgeFxuICBsZXQgYmluZCB0IH5mID0gbGF6eSAoZm9yY2UgKGYgKGZvcmNlIHQpKSlcbiAgbGV0IG1hcCA9IG1hcFxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbmVuZClcblxubW9kdWxlIFRfdW5mb3JjaW5nID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgaWYgaXNfdmFsIHQgdGhlbiBzZXhwX29mX2EgKGZvcmNlIHQpIGVsc2Ugc2V4cF9vZl9zdHJpbmcgXCI8dW5mb3JjZWQgbGF6eT5cIlxuICA7O1xuZW5kXG4iLCIoKiBTcGxpdCBvZmYgdG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSB3aXRoIFtPcl9lcnJvcl0uICopXG5cbm9wZW4hIEltcG9ydFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5sZXQgc2xvd19jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aCA9XG4gIGlmIHBvcyA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJOZWdhdGl2ZSBwb3NpdGlvbjogJWRcIiBwb3MgKCk7XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJOZWdhdGl2ZSBsZW5ndGg6ICVkXCIgbGVuICgpO1xuICAoKiBXZSB1c2UgW3BvcyA+IHRvdGFsX2xlbmd0aCAtIGxlbl0gcmF0aGVyIHRoYW4gW3BvcyArIGxlbiA+IHRvdGFsX2xlbmd0aF0gdG8gYXZvaWQgdGhlXG4gICAgIHBvc3NpYmlsaXR5IG9mIG92ZXJmbG93LiAqKVxuICBpZiBwb3MgPiB0b3RhbF9sZW5ndGggLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJwb3MgKyBsZW4gcGFzdCBlbmQ6ICVkICsgJWQgPiAlZFwiIHBvcyBsZW4gdG90YWxfbGVuZ3RoICgpXG4gIFtAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGggPVxuICAoKiBUaGlzIGlzIGJldHRlciB0aGFuIFtzbG93X2NoZWNrX3Bvc19sZW5fZXhuXSBmb3IgdHdvIHJlYXNvbnM6XG5cbiAgICAgLSBtdWNoIGxlc3MgaW5saW5lZCBjb2RlXG4gICAgIC0gb25seSBvbmUgY29uZGl0aW9uYWwganVtcFxuXG4gICAgIFRoZSByZWFzb24gaXQgd29ya3MgaXMgdGhhdCBjaGVja2luZyBbPCAwXSBpcyB0ZXN0aW5nIHRoZSBoaWdoZXN0IG9yZGVyIGJpdCwgc29cbiAgICAgW2EgPCAwIHx8IGIgPCAwXSBpcyB0aGUgc2FtZSBhcyBbYSBsb3IgYiA8IDBdLlxuXG4gICAgIFtwb3MgKyBsZW5dIGNhbiBvdmVyZmxvdywgc28gW3BvcyA+IHRvdGFsX2xlbmd0aCAtIGxlbl0gaXMgbm90IGVxdWl2YWxlbnQgdG9cbiAgICAgW3RvdGFsX2xlbmd0aCAtIGxlbiAtIHBvcyA8IDBdLCB3ZSBuZWVkIHRvIHRlc3QgZm9yIFtwb3MgKyBsZW5dIG92ZXJmbG93IGFzXG4gICAgIHdlbGwuICopXG4gIGxldCBzdG9wID0gcG9zICsgbGVuIGluXG4gIGlmIHBvcyBsb3IgbGVuIGxvciBzdG9wIGxvciAodG90YWxfbGVuZ3RoIC0gc3RvcCkgPCAwXG4gIHRoZW4gc2xvd19jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aFxuICBbQEBpbmxpbmUgYWx3YXlzXVxuOztcblxubGV0IGdldF9wb3NfbGVuX2V4biA/KHBvcyA9IDApID9sZW4gKCkgfnRvdGFsX2xlbmd0aCA9XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBTb21lIGkgLT4gaVxuICAgIHwgTm9uZSAtPiB0b3RhbF9sZW5ndGggLSBwb3NcbiAgaW5cbiAgY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIHBvcywgbGVuXG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgc2xvd19jaGVja19wb3NfbGVuX2V4biA9IHNsb3dfY2hlY2tfcG9zX2xlbl9leG5cbmVuZFxuIiwiXG50eXBlIHQgPSBTdGRsaWIuUmFuZG9tLlN0YXRlLnQgU3RkbGliLkRvbWFpbi5ETFMua2V5XG5cbm1vZHVsZSBSZXByID0gc3RydWN0XG4gIG9wZW4gU3RkbGliLkJpZ2FycmF5XG5cbiAgdHlwZSB0ID0gKGludDY0LCBpbnQ2NF9lbHQsIGNfbGF5b3V0KSBBcnJheTEudFxuXG4gIGxldCBvZl9zdGF0ZSA6IFN0ZGxpYi5SYW5kb20uU3RhdGUudCAtPiB0ID0gU3RkbGliLk9iai5tYWdpY1xuZW5kXG5cbmxldCBhc3NpZ24gdCBzdGF0ZSA9XG4gIGxldCBkc3QgPSBSZXByLm9mX3N0YXRlIChTdGRsaWIuRG9tYWluLkRMUy5nZXQgdCkgaW5cbiAgbGV0IHNyYyA9IFJlcHIub2Zfc3RhdGUgc3RhdGUgaW5cbiAgU3RkbGliLkJpZ2FycmF5LkFycmF5MS5ibGl0IHNyYyBkc3Rcbjs7XG5cbmxldCBtYWtlIHN0YXRlID1cbiAgbGV0IHNwbGl0X2Zyb21fcGFyZW50IHYgPSBTdGRsaWIuUmFuZG9tLlN0YXRlLnNwbGl0IHYgaW5cbiAgbGV0IHQgPSBTdGRsaWIuRG9tYWluLkRMUy5uZXdfa2V5IH5zcGxpdF9mcm9tX3BhcmVudCAoZnVuICgpIC0+IHN0YXRlKSBpblxuICBTdGRsaWIuRG9tYWluLkRMUy5nZXQgdCB8PiBpZ25vcmU7XG4gIHRcbjs7XG5cbmxldCBtYWtlX2xhenkgfmYgPVxuICBsZXQgc3BsaXRfZnJvbV9wYXJlbnQgdiA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuc3BsaXQgdiBpblxuICBTdGRsaWIuRG9tYWluLkRMUy5uZXdfa2V5IH5zcGxpdF9mcm9tX3BhcmVudCBmXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGdldF9zdGF0ZSB0ID0gU3RkbGliLkRvbWFpbi5ETFMuZ2V0IHRcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBDaGFyID0gQ2hhcjBcblxuKCogVW5mb3J0dW5hdGVseSwgYmVjYXVzZSB0aGUgc3RhbmRhcmQgbGlicmFyeSBkb2VzIG5vdCBleHBvc2VcbiAgIFtTdGRsaWIuUmFuZG9tLlN0YXRlLmRlZmF1bHRdLCB3ZSBoYXZlIHRvIGNvbnN0cnVjdCBvdXIgb3duLiAgV2UgdGhlbiBidWlsZCB0aGVcbiAgIFtTdGRsaWIuUmFuZG9tLmludF0sIFtTdGRsaWIuUmFuZG9tLmJvb2xdIGZ1bmN0aW9ucyBhbmQgZnJpZW5kcyB1c2luZyB0aGF0IGRlZmF1bHQgc3RhdGUgaW5cbiAgIGV4YWN0bHkgdGhlIHNhbWUgd2F5IGFzIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LiAqKVxuXG4oKiBSZWdyZXNzaW9uIHRlc3RzIG91Z2h0IHRvIGJlIGRldGVybWluaXN0aWMgYmVjYXVzZSB0aGF0IHdheSBhbnlvbmUgd2hvIGJyZWFrcyB0aGUgdGVzdFxuICAga25vd3MgdGhhdCBpdCdzIHRoZWlyIGNvZGUgdGhhdCBicm9rZSB0aGUgdGVzdC4gIElmIHRlc3RzIGFyZSBub25kZXRlcm1pbmlzdGljLCBhIHRlc3RcbiAgIGZhaWx1cmUgbWF5IGluc3RlYWQgaGFwcGVuIGJlY2F1c2UgdGhlIHRlc3QgcnVubmVyIGdvdCB1bmx1Y2t5IGFuZCB1bmNvdmVyZWQgYW5cbiAgIGV4aXN0aW5nIGJ1ZyBpbiB0aGUgY29kZSBzdXBwb3NlZGx5IGJlaW5nIFwicHJvdGVjdGVkXCIgYnkgdGhlIHRlc3QgaW4gcXVlc3Rpb24uICopXG5sZXQgZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIH5hbGxvd19pbl90ZXN0cyA9XG4gIGlmIGFtX3Rlc3RpbmdcbiAgdGhlbiAoXG4gICAgbWF0Y2ggYWxsb3dfaW5fdGVzdHMgd2l0aFxuICAgIHwgU29tZSB0cnVlIC0+ICgpXG4gICAgfCBOb25lIHwgU29tZSBmYWxzZSAtPlxuICAgICAgZmFpbHdpdGhcbiAgICAgICAgXCJpbml0aWFsaXppbmcgUmFuZG9tIHdpdGggYSBub25kZXRlcm1pbmlzdGljIHNlZWQgaXMgZm9yYmlkZGVuIGluIGlubGluZSB0ZXN0c1wiKVxuOztcblxuZXh0ZXJuYWwgcmFuZG9tX3NlZWQgOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5sZXQgcmFuZG9tX3NlZWQgP2FsbG93X2luX3Rlc3RzICgpID1cbiAgZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIH5hbGxvd19pbl90ZXN0cztcbiAgcmFuZG9tX3NlZWQgKClcbjs7XG5cbm1vZHVsZSBSZXByID0gUmFuZG9tX3JlcHJcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG4gIHR5cGUgdCA9IFJlcHIudFxuXG4gIGxldCBiaXRzIHQgPSBTdGRsaWIuUmFuZG9tLlN0YXRlLmJpdHMgKFJlcHIuZ2V0X3N0YXRlIHQpXG4gIGxldCBiaXRzNjQgdCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuYml0czY0IChSZXByLmdldF9zdGF0ZSB0KVxuICBsZXQgYm9vbCB0ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5ib29sIChSZXByLmdldF9zdGF0ZSB0KVxuICBsZXQgaW50IHQgeCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuaW50IChSZXByLmdldF9zdGF0ZSB0KSB4XG4gIGxldCBpbnQzMiB0IHggPSBTdGRsaWIuUmFuZG9tLlN0YXRlLmludDMyIChSZXByLmdldF9zdGF0ZSB0KSB4XG4gIGxldCBpbnQ2NCB0IHggPSBTdGRsaWIuUmFuZG9tLlN0YXRlLmludDY0IChSZXByLmdldF9zdGF0ZSB0KSB4XG4gIGxldCBuYXRpdmVpbnQgdCB4ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5uYXRpdmVpbnQgKFJlcHIuZ2V0X3N0YXRlIHQpIHhcbiAgbGV0IG1ha2Ugc2VlZCA9IFJlcHIubWFrZSAoU3RkbGliLlJhbmRvbS5TdGF0ZS5tYWtlIHNlZWQpXG4gIGxldCBjb3B5IHQgPSBSZXByLm1ha2UgKFN0ZGxpYi5SYW5kb20uU3RhdGUuY29weSAoUmVwci5nZXRfc3RhdGUgdCkpXG4gIGxldCBjaGFyIHQgPSBpbnQgdCAyNTYgfD4gQ2hhci51bnNhZmVfb2ZfaW50XG4gIGxldCBhc2NpaSB0ID0gaW50IHQgMTI4IHw+IENoYXIudW5zYWZlX29mX2ludFxuXG4gIGxldCBtYWtlX3NlbGZfaW5pdCA/YWxsb3dfaW5fdGVzdHMgKCkgPVxuICAgIGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHM7XG4gICAgUmVwci5tYWtlX2xhenkgfmY6U3RkbGliLlJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdFxuICA7O1xuXG4gIGxldCBhc3NpZ24gPSBSZXByLmFzc2lnblxuICBsZXQgZnVsbF9pbml0IHQgc2VlZCA9IGFzc2lnbiB0IChTdGRsaWIuUmFuZG9tLlN0YXRlLm1ha2Ugc2VlZClcblxuICBsZXQgZGVmYXVsdCA9XG4gICAgaWYgYW1fdGVzdGluZ1xuICAgIHRoZW4gKFxuICAgICAgKCogV2UgZGVmaW5lIEJhc2UncyBkZWZhdWx0IHJhbmRvbSBzdGF0ZSBhcyBhIGNvcHkgb2YgT0NhbWwncyBkZWZhdWx0IHJhbmRvbSBzdGF0ZS5cbiAgICAgICAgIFRoaXMgbWVhbnMgdGhhdCBwcm9ncmFtcyB0aGF0IHVzZSBCYXNlLlJhbmRvbSB3aWxsIHNlZSB0aGUgc2FtZSBzZXF1ZW5jZSBvZlxuICAgICAgICAgcmFuZG9tIGJpdHMgYXMgaWYgdGhleSBoYWQgdXNlZCBTdGRsaWIuUmFuZG9tLiBIb3dldmVyLCBiZWNhdXNlIFtnZXRfc3RhdGVdIHJldHVybnNcbiAgICAgICAgIGEgY29weSwgQmFzZS5SYW5kb20gYW5kIE9DYW1sLlJhbmRvbSBhcmUgbm90IHVzaW5nIHRoZSBzYW1lIHN0YXRlLiBJZiBhIHByb2dyYW1cbiAgICAgICAgIHVzZWQgYm90aCwgZWFjaCBvZiB0aGVtIHdvdWxkIGdvIHRocm91Z2ggdGhlIHNhbWUgc2VxdWVuY2Ugb2YgcmFuZG9tIGJpdHMuIFRvXG4gICAgICAgICBhdm9pZCB0aGF0LCB3ZSByZXNldCBPQ2FtbCdzIHJhbmRvbSBzdGF0ZSB0byBhIGRpZmZlcmVudCBzZWVkLCBnaXZpbmcgaXQgYVxuICAgICAgICAgZGlmZmVyZW50IHNlcXVlbmNlLiAqKVxuICAgICAgbGV0IHQgPSBTdGRsaWIuUmFuZG9tLmdldF9zdGF0ZSAoKSBpblxuICAgICAgU3RkbGliLlJhbmRvbS5pbml0IDEzNztcbiAgICAgIFJlcHIubWFrZSB0KVxuICAgIGVsc2VcbiAgICAgICgqIE91dHNpZGUgb2YgdGVzdHMsIHdlIGluaXRpYWxpemUgcmFuZG9tIHN0YXRlIG5vbmRldGVybWluaXN0aWNhbGx5IGFuZCBsYXppbHkuXG4gICAgICAgICBXZSBmb3JjZSB0aGUgcmFuZG9tIGluaXRpYWxpemF0aW9uIHRvIGJlIGxhenkgc28gdGhhdCB3ZSBkbyBub3QgcGF5IGFueSBjb3N0XG4gICAgICAgICBmb3IgaXQgaW4gcHJvZ3JhbXMgdGhhdCBkbyBub3QgdXNlIHJhbmRvbW5lc3MuICopXG4gICAgICBtYWtlX3NlbGZfaW5pdCAoKVxuICA7O1xuXG4gIGxldCBpbnRfb25fNjRiaXRzIHQgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDB4M0ZGRkZGRkYgKCogKDEgbHNsIDMwKSAtIDEgKilcbiAgICB0aGVuIGludCB0IGJvdW5kXG4gICAgZWxzZSBTdGRsaWIuSW50NjQudG9faW50IChpbnQ2NCB0IChTdGRsaWIuSW50NjQub2ZfaW50IGJvdW5kKSlcbiAgOztcblxuICBsZXQgaW50X29uXzMyYml0cyB0IGJvdW5kID1cbiAgICAoKiBOb3QgYWx3YXlzIHRydWUgd2l0aCB0aGUgSmF2YVNjcmlwdCBiYWNrZW5kLiAqKVxuICAgIGlmIGJvdW5kIDw9IDB4M0ZGRkZGRkYgKCogKDEgbHNsIDMwKSAtIDEgKilcbiAgICB0aGVuIGludCB0IGJvdW5kXG4gICAgZWxzZSBTdGRsaWIuSW50MzIudG9faW50IChpbnQzMiB0IChTdGRsaWIuSW50MzIub2ZfaW50IGJvdW5kKSlcbiAgOztcblxuICBsZXQgaW50ID1cbiAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICB8IFc2NCAtPiBpbnRfb25fNjRiaXRzXG4gICAgfCBXMzIgLT4gaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludDY0ID1cbiAgICBsZXQgb3BlbiBTdGRsaWIuSW50NjQgaW5cbiAgICBsZXQgYml0cyBzdGF0ZSA9IG9mX2ludCAoYml0cyBzdGF0ZSkgaW5cbiAgICBmdW4gc3RhdGUgLT5cbiAgICAgIGxvZ3hvclxuICAgICAgICAoYml0cyBzdGF0ZSlcbiAgICAgICAgKGxvZ3hvciAoc2hpZnRfbGVmdCAoYml0cyBzdGF0ZSkgMzApIChzaGlmdF9sZWZ0IChiaXRzIHN0YXRlKSA2MCkpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfaW50MzIgPVxuICAgIGxldCBvcGVuIFN0ZGxpYi5JbnQzMiBpblxuICAgIGxldCBiaXRzIHN0YXRlID0gb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGZ1biBzdGF0ZSAtPiBsb2d4b3IgKGJpdHMgc3RhdGUpIChzaGlmdF9sZWZ0IChiaXRzIHN0YXRlKSAzMClcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9pbnRfb25fNjRiaXRzIHN0YXRlID0gU3RkbGliLkludDY0LnRvX2ludCAoZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSlcbiAgbGV0IGZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyBzdGF0ZSA9IFN0ZGxpYi5JbnQzMi50b19pbnQgKGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUpXG5cbiAgbGV0IGZ1bGxfcmFuZ2VfaW50ID1cbiAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICB8IFc2NCAtPiBmdWxsX3JhbmdlX2ludF9vbl82NGJpdHNcbiAgICB8IFczMiAtPiBmdWxsX3JhbmdlX2ludF9vbl8zMmJpdHNcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzIHN0YXRlID1cbiAgICBTdGRsaWIuSW50NjQudG9fbmF0aXZlaW50IChmdWxsX3JhbmdlX2ludDY0IHN0YXRlKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl8zMmJpdHMgc3RhdGUgPVxuICAgIFN0ZGxpYi5OYXRpdmVpbnQub2ZfaW50MzIgKGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50ID1cbiAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICB8IFc2NCAtPiBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl82NGJpdHNcbiAgICB8IFczMiAtPiBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl8zMmJpdHNcbiAgOztcblxuICBsZXQgcmFpc2VfY3Jvc3NlZF9ib3VuZHMgbmFtZSBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZCBzdHJpbmdfb2ZfYm91bmQgPVxuICAgIFByaW50Zi5mYWlsd2l0aGZcbiAgICAgIFwiUmFuZG9tLiVzOiBjcm9zc2VkIGJvdW5kcyBbJXMgPiAlc11cIlxuICAgICAgbmFtZVxuICAgICAgKHN0cmluZ19vZl9ib3VuZCBsb3dlcl9ib3VuZClcbiAgICAgIChzdHJpbmdfb2ZfYm91bmQgdXBwZXJfYm91bmQpXG4gICAgICAoKVxuICAgIFtAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG4gIDs7XG5cbiAgbGV0IGludF9pbmNsID1cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludCBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBmdW4gc3RhdGUgbG8gaGkgLT5cbiAgICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcImludFwiIGxvIGhpIEludC50b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IGhpIC0gbG8gaW5cbiAgICAgIGlmIGRpZmYgPSBJbnQubWF4X3ZhbHVlXG4gICAgICB0aGVuIGxvICsgKGZ1bGxfcmFuZ2VfaW50IHN0YXRlIGxhbmQgSW50Lm1heF92YWx1ZSlcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwXG4gICAgICB0aGVuIGxvICsgaW50IHN0YXRlIChJbnQuc3VjYyBkaWZmKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBpbnQzMl9pbmNsID1cbiAgICBsZXQgb3BlbiBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludDMyIHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIFN0ZGxpYi5JbnQzMiBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50MzJcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUpIG1heF9pbnQpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMGxcbiAgICAgIHRoZW4gYWRkIGxvIChpbnQzMiBzdGF0ZSAoc3VjYyBkaWZmKSlcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICBsZXQgbmF0aXZlaW50X2luY2wgPVxuICAgIGxldCBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX25hdGl2ZWludCBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBsZXQgb3BlbiBTdGRsaWIuTmF0aXZlaW50IGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJuYXRpdmVpbnRcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfbmF0aXZlaW50IHN0YXRlKSBtYXhfaW50KVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBuXG4gICAgICB0aGVuIGFkZCBsbyAobmF0aXZlaW50IHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBpbnQ2NF9pbmNsID1cbiAgICBsZXQgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludDY0IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIFN0ZGxpYi5JbnQ2NCBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50NjRcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpIG1heF9pbnQpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMExcbiAgICAgIHRoZW4gYWRkIGxvIChpbnQ2NCBzdGF0ZSAoc3VjYyBkaWZmKSlcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICAoKiBSZXR1cm4gYSB1bmlmb3JtbHkgcmFuZG9tIGZsb2F0IGluIFswLCAxKS4gKilcbiAgbGV0IHJlYyByYXdmbG9hdCBzdGF0ZSA9XG4gICAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHNjYWxlID0gMHgxcC0zMCBpblxuICAgICgqIDJeLTMwICopXG4gICAgbGV0IHIxID0gU3RkbGliLmZsb2F0X29mX2ludCAoYml0cyBzdGF0ZSkgaW5cbiAgICBsZXQgcjIgPSBTdGRsaWIuZmxvYXRfb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGxldCByZXN1bHQgPSAoKHIxICouIHNjYWxlKSArLiByMikgKi4gc2NhbGUgaW5cbiAgICAoKiBXaXRoIHZlcnkgc21hbGwgcHJvYmFiaWxpdHksIHJlc3VsdCBjYW4gcm91bmQgdXAgdG8gMS4wLCBzbyBpbiB0aGF0IGNhc2UsIHdlIGp1c3RcbiAgICAgICB0cnkgYWdhaW4uICopXG4gICAgaWYgcmVzdWx0IDwgMS4wIHRoZW4gcmVzdWx0IGVsc2UgcmF3ZmxvYXQgc3RhdGVcbiAgOztcblxuICBsZXQgZmxvYXQgc3RhdGUgaGkgPSByYXdmbG9hdCBzdGF0ZSAqLiBoaVxuXG4gIGxldCBmbG9hdF9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiZmxvYXRcIiBsbyBoaSBTdGRsaWIuc3RyaW5nX29mX2Zsb2F0O1xuICAgIGxvICsuIGZsb2F0IHN0YXRlIChoaSAtLiBsbylcbiAgOztcbmVuZFxuXG5sZXQgZGVmYXVsdCA9IFN0YXRlLmRlZmF1bHRcbmxldCBiaXRzICgpID0gU3RhdGUuYml0cyBkZWZhdWx0XG5sZXQgYml0czY0ICgpID0gU3RhdGUuYml0czY0IGRlZmF1bHRcbmxldCBpbnQgeCA9IFN0YXRlLmludCBkZWZhdWx0IHhcbmxldCBpbnQzMiB4ID0gU3RhdGUuaW50MzIgZGVmYXVsdCB4XG5sZXQgbmF0aXZlaW50IHggPSBTdGF0ZS5uYXRpdmVpbnQgZGVmYXVsdCB4XG5sZXQgaW50NjQgeCA9IFN0YXRlLmludDY0IGRlZmF1bHQgeFxubGV0IGZsb2F0IHggPSBTdGF0ZS5mbG9hdCBkZWZhdWx0IHhcbmxldCBpbnRfaW5jbCB4IHkgPSBTdGF0ZS5pbnRfaW5jbCBkZWZhdWx0IHggeVxubGV0IGludDMyX2luY2wgeCB5ID0gU3RhdGUuaW50MzJfaW5jbCBkZWZhdWx0IHggeVxubGV0IG5hdGl2ZWludF9pbmNsIHggeSA9IFN0YXRlLm5hdGl2ZWludF9pbmNsIGRlZmF1bHQgeCB5XG5sZXQgaW50NjRfaW5jbCB4IHkgPSBTdGF0ZS5pbnQ2NF9pbmNsIGRlZmF1bHQgeCB5XG5sZXQgZmxvYXRfcmFuZ2UgeCB5ID0gU3RhdGUuZmxvYXRfcmFuZ2UgZGVmYXVsdCB4IHlcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5sZXQgY2hhciAoKSA9IFN0YXRlLmNoYXIgZGVmYXVsdFxubGV0IGFzY2lpICgpID0gU3RhdGUuYXNjaWkgZGVmYXVsdFxubGV0IGZ1bGxfaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgc2VlZFxubGV0IGluaXQgc2VlZCA9IGZ1bGxfaW5pdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ID9hbGxvd19pbl90ZXN0cyAoKSA9IGZ1bGxfaW5pdCAocmFuZG9tX3NlZWQgP2FsbG93X2luX3Rlc3RzICgpKVxubGV0IHNldF9zdGF0ZSBzID0gU3RhdGUuYXNzaWduIGRlZmF1bHQgKFJlcHIuZ2V0X3N0YXRlIHMpXG4iLCIoKiogQW4gaW50ZXJuYWwtb25seSBtb2R1bGUgZmFjdG9yZWQgb3V0IGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBjb3JlX2FycmF5XG4gICAgYW5kIGNvcmVfbGlzdC4gIENvbnRhaW5zIGNvZGUgZm9yIHBlcm11dGluZyBhbiBhcnJheS4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFycmF5MFxuXG5sZXQgcGVybXV0ZSA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSA/KHBvcyA9IDApID9sZW4gdCA9XG4gICgqIENvcGllZCBmcm9tIFtPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMF0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlIHdoZW4gY29tcGlsaW5nXG4gICAgIHdpdGhvdXQgZmxhbWJkYS4gKilcbiAgbGV0IHRvdGFsX2xlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBTb21lIGwgLT4gbFxuICAgIHwgTm9uZSAtPiB0b3RhbF9sZW5ndGggLSBwb3NcbiAgaW5cbiAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjAuY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIGxldCBudW1fc3dhcHMgPSBsZW4gLSAxIGluXG4gIGZvciBpID0gbnVtX3N3YXBzIGRvd250byAxIGRvXG4gICAgbGV0IHRoaXNfaSA9IHBvcyArIGkgaW5cbiAgICAoKiBbcmFuZG9tX2ldIGlzIGRyYXduIGZyb20gW3Bvcyx0aGlzX2ldICopXG4gICAgbGV0IHJhbmRvbV9pID0gcG9zICsgUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGkgKyAxKSBpblxuICAgIHN3YXAgdCB0aGlzX2kgcmFuZG9tX2lcbiAgZG9uZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPVxuICB8IExlc3NcbiAgfCBFcXVhbFxuICB8IEdyZWF0ZXJcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaCwgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlX19sb2NhbCA9IChTdGRsaWIuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5sZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG5cbmxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludFxuICAgICAgIGhzdlxuICAgICAgIChtYXRjaCBhcmcgd2l0aFxuICAgICAgICB8IExlc3MgLT4gMFxuICAgICAgICB8IEVxdWFsIC0+IDFcbiAgICAgICAgfCBHcmVhdGVyIC0+IDIpXG4gICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbmxldCBhbGwgPSAoWyBMZXNzOyBFcXVhbDsgR3JlYXRlciBdIDogdCBsaXN0KVxuXG5sZXQgdF9vZl9zZXhwID1cbiAgKGxldCBlcnJvcl9zb3VyY2VfXzAwNV8gPSBcIm9yZGVyaW5nLm1sLnRcIiBpblxuICAgZnVuY3Rpb25cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlc3NcIiB8IFwiTGVzc1wiKSAtPiBMZXNzXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcXVhbFwiIHwgXCJFcXVhbFwiKSAtPiBFcXVhbFxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZ3JlYXRlclwiIHwgXCJHcmVhdGVyXCIpIC0+IEdyZWF0ZXJcbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibGVzc1wiIHwgXCJMZXNzXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcXVhbFwiIHwgXCJFcXVhbFwiKSA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiZ3JlYXRlclwiIHwgXCJHcmVhdGVyXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICB8IHNleHBfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG47O1xuXG5sZXQgc2V4cF9vZl90ID1cbiAgKGZ1bmN0aW9uXG4gICB8IExlc3MgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVzc1wiXG4gICB8IEVxdWFsIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkVxdWFsXCJcbiAgIHwgR3JlYXRlciAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJHcmVhdGVyXCJcbiAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJMZXNzXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJFcXVhbFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiR3JlYXRlclwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgZXF1YWwgYSBiID0gY29tcGFyZSBhIGIgPSAwXG5sZXQgZXF1YWxfX2xvY2FsIGEgYiA9IGNvbXBhcmVfX2xvY2FsIGEgYiA9IDBcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICB0eXBlIF9vcmRlcmluZyA9IHQgPVxuICAgIHwgTGVzc1xuICAgIHwgRXF1YWxcbiAgICB8IEdyZWF0ZXJcbmVuZFxuXG5sZXQgb2ZfaW50IG4gPSBpZiBuIDwgMCB0aGVuIExlc3MgZWxzZSBpZiBuID0gMCB0aGVuIEVxdWFsIGVsc2UgR3JlYXRlclxuXG5sZXQgdG9faW50ID0gZnVuY3Rpb25cbiAgfCBMZXNzIC0+IC0xXG4gIHwgRXF1YWwgLT4gMFxuICB8IEdyZWF0ZXIgLT4gMVxuOztcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgRWl0aGVyID0gRWl0aGVyMFxuaW5jbHVkZSBMaXN0MVxuXG4oKiBUaGlzIGl0c2VsZiBpbmNsdWRlcyBbTGlzdDBdLiAqKVxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBsaXN0IFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgZ2xvYmFsaXplIDogJ2EuICgnYSAtPiAnYSkgLT4gJ2EgdCAtPiAnYSB0ID1cbiAgICBmdW4gKHR5cGUgYV9fMDAxXykgOiAoKGFfXzAwMV8gLT4gYV9fMDAxXykgLT4gYV9fMDAxXyB0IC0+IGFfXzAwMV8gdCkgLT5cbiAgICBnbG9iYWxpemVfbGlzdFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSBsaXN0X29mX3NleHBcbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfbGlzdFxuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBsaXN0X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgT3JfdW5lcXVhbF9sZW5ndGhzID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBPayBvZiAnYVxuICAgIHwgVW5lcXVhbF9sZW5ndGhzXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gICAgZnVuIF9jbXBfX2EgYV9fMDE0XyBiX18wMTVfIC0+XG4gICAgaWYgU3RkbGliLiggPT0gKSBhX18wMTRfIGJfXzAxNV9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAxNF8sIGJfXzAxNV8gd2l0aFxuICAgICAgfCBPayBfYV9fMDE2XywgT2sgX2JfXzAxN18gLT4gX2NtcF9fYSBfYV9fMDE2XyBfYl9fMDE3X1xuICAgICAgfCBPayBfLCBfIC0+IC0xXG4gICAgICB8IF8sIE9rIF8gLT4gMVxuICAgICAgfCBVbmVxdWFsX2xlbmd0aHMsIFVuZXF1YWxfbGVuZ3RocyAtPiAwKVxuICA7O1xuXG4gIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICAgIGZ1biBfY21wX19hIGFfXzAxMF8gYl9fMDExXyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDEwXyBiX18wMTFfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMTBfLCBiX18wMTFfIHdpdGhcbiAgICAgIHwgT2sgX2FfXzAxMl8sIE9rIF9iX18wMTNfIC0+IF9jbXBfX2EgX2FfXzAxMl8gX2JfXzAxM19cbiAgICAgIHwgT2sgXywgXyAtPiAtMVxuICAgICAgfCBfLCBPayBfIC0+IDFcbiAgICAgIHwgVW5lcXVhbF9sZW5ndGhzLCBVbmVxdWFsX2xlbmd0aHMgLT4gMClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBmdW4gKHR5cGUgYV9fMDIxXykgOiAoKGFfXzAyMV8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiBhX18wMjFfIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfYV9fMDE4XyAtPiBmdW5jdGlvblxuICAgIHwgT2sgYXJnMF9fMDE5XyAtPlxuICAgICAgbGV0IHJlczBfXzAyMF8gPSBfb2ZfYV9fMDE4XyBhcmcwX18wMTlfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPa1wiOyByZXMwX18wMjBfIF1cbiAgICB8IFVuZXF1YWxfbGVuZ3RocyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmVxdWFsX2xlbmd0aHNcIlxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBpbnZhcmlhbnQgZiB0ID0gaXRlciB0IH5mXG5sZXQgb2ZfbGlzdCB0ID0gdFxubGV0IHNpbmdsZXRvbiB4ID0gWyB4IF1cblxubGV0IHJhbmdlJyB+Y29tcGFyZSB+c3RyaWRlID8oc3RhcnQgPSBgaW5jbHVzaXZlKSA/KHN0b3AgPSBgZXhjbHVzaXZlKSBzdGFydF9pIHN0b3BfaSA9XG4gIGxldCBuZXh0X2kgPSBzdHJpZGUgc3RhcnRfaSBpblxuICBsZXQgb3JkZXIgeCB5ID0gT3JkZXJpbmcub2ZfaW50IChjb21wYXJlIHggeSkgaW5cbiAgbGV0IHJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbWVfdmFsdWUgKCkgPVxuICAgIGludmFsaWRfYXJnIFwiTGlzdC5yYW5nZSc6IHN0cmlkZSBmdW5jdGlvbiBjYW5ub3QgcmV0dXJuIHRoZSBzYW1lIHZhbHVlXCJcbiAgaW5cbiAgbGV0IGluaXRpYWxfc3RyaWRlX29yZGVyID1cbiAgICBtYXRjaCBvcmRlciBzdGFydF9pIG5leHRfaSB3aXRoXG4gICAgfCBFcXVhbCAtPiByYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW1lX3ZhbHVlICgpXG4gICAgfCBMZXNzIC0+IGBMZXNzXG4gICAgfCBHcmVhdGVyIC0+IGBHcmVhdGVyXG4gIGluXG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGxvb3AgaSA9XG4gICAgbGV0IGlfdG9fc3RvcF9vcmRlciA9IG9yZGVyIGkgc3RvcF9pIGluXG4gICAgbWF0Y2ggaV90b19zdG9wX29yZGVyLCBpbml0aWFsX3N0cmlkZV9vcmRlciB3aXRoXG4gICAgfCBMZXNzLCBgTGVzcyB8IEdyZWF0ZXIsIGBHcmVhdGVyIC0+XG4gICAgICAoKiBoYXZlbid0IHlldCByZWFjaGVkIFtzdG9wX2ldLiBDb250aW51ZS4gKilcbiAgICAgIGxldCBuZXh0X2kgPSBzdHJpZGUgaSBpblxuICAgICAgKG1hdGNoIG9yZGVyIGkgbmV4dF9pLCBpbml0aWFsX3N0cmlkZV9vcmRlciB3aXRoXG4gICAgICAgfCBFcXVhbCwgXyAtPiAocmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSBbQHRhaWxjYWxsIGZhbHNlXSkgKClcbiAgICAgICB8IExlc3MsIGBHcmVhdGVyIHwgR3JlYXRlciwgYExlc3MgLT5cbiAgICAgICAgIGludmFsaWRfYXJnIFwiTGlzdC5yYW5nZSc6IHN0cmlkZSBmdW5jdGlvbiBjYW5ub3QgY2hhbmdlIGRpcmVjdGlvblwiXG4gICAgICAgfCBMZXNzLCBgTGVzcyB8IEdyZWF0ZXIsIGBHcmVhdGVyIC0+IGkgOjogbG9vcCBuZXh0X2kpXG4gICAgfCBMZXNzLCBgR3JlYXRlciB8IEdyZWF0ZXIsIGBMZXNzIC0+XG4gICAgICAoKiBzdGVwcGVkIHBhc3QgW3N0b3BfaV0uICBGaW5pc2hlZC4gKilcbiAgICAgIFtdXG4gICAgfCBFcXVhbCwgXyAtPlxuICAgICAgKCogcmVhY2hlZCBbc3RvcF9pXS4gIEZpbmlzaGVkLiAqKVxuICAgICAgKG1hdGNoIHN0b3Agd2l0aFxuICAgICAgIHwgYGluY2x1c2l2ZSAtPiBbIGkgXVxuICAgICAgIHwgYGV4Y2x1c2l2ZSAtPiBbXSlcbiAgaW5cbiAgbGV0IHN0YXJ0X2kgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IGBpbmNsdXNpdmUgLT4gc3RhcnRfaVxuICAgIHwgYGV4Y2x1c2l2ZSAtPiBuZXh0X2lcbiAgaW5cbiAgbG9vcCBzdGFydF9pIFtAbm9udGFpbF1cbjs7XG5cbmxldCByYW5nZSA/KHN0cmlkZSA9IDEpID8oc3RhcnQgPSBgaW5jbHVzaXZlKSA/KHN0b3AgPSBgZXhjbHVzaXZlKSBzdGFydF9pIHN0b3BfaSA9XG4gIGlmIHN0cmlkZSA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QucmFuZ2U6IHN0cmlkZSBtdXN0IGJlIG5vbi16ZXJvXCI7XG4gIHJhbmdlJyB+Y29tcGFyZSB+c3RyaWRlOihmdW4geCAtPiB4ICsgc3RyaWRlKSB+c3RhcnQgfnN0b3Agc3RhcnRfaSBzdG9wX2lcbjs7XG5cbmxldCBoZCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogXyAtPiBTb21lIHhcbjs7XG5cbmxldCB0bCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IF8gOjogdCcgLT4gU29tZSB0J1xuOztcblxubGV0IG50aCB0IG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBudGhfYXV4IHQgbiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgfCBhIDo6IHQgLT4gaWYgbiA9IDAgdGhlbiBTb21lIGEgZWxzZSBudGhfYXV4IHQgKG4gLSAxKVxuICAgIGluXG4gICAgbnRoX2F1eCB0IG4pXG47O1xuXG5sZXQgbnRoX2V4biB0IG4gPVxuICBtYXRjaCBudGggdCBuIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnZiBcIkxpc3QubnRoX2V4biAlZCBjYWxsZWQgb24gbGlzdCBvZiBsZW5ndGggJWRcIiBuIChsZW5ndGggdCkgKClcbiAgfCBTb21lIGEgLT4gYVxuOztcblxubGV0IHVub3JkZXJlZF9hcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsIHwgbCwgW10gLT4gbFxuICB8IF8gLT4gcmV2X2FwcGVuZCBsMSBsMlxuOztcblxubW9kdWxlIENoZWNrX2xlbmd0aDIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB8IFNhbWVfbGVuZ3RoIG9mIGludFxuICAgIHwgVW5lcXVhbF9sZW5ndGhzIG9mXG4gICAgICAgIHsgc2hhcmVkX2xlbmd0aCA6IGludFxuICAgICAgICA7IHRhaWxfb2ZfYSA6ICdhIGxpc3RcbiAgICAgICAgOyB0YWlsX29mX2IgOiAnYiBsaXN0XG4gICAgICAgIH1cblxuICAoKiBJbiB0aGUgW1VuZXF1YWxfbGVuZ3Roc10gY2FzZSwgYXQgbGVhc3Qgb25lIG9mIHRoZSB0YWlscyB3aWxsIGJlIG5vbi1lbXB0eS4gKilcbiAgbGV0IG9mX2xpc3RzIGwxIGwyID1cbiAgICBsZXQgcmVjIGxvb3AgYSBiIHNoYXJlZF9sZW5ndGggPVxuICAgICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgICB8IFtdLCBbXSAtPiBTYW1lX2xlbmd0aCBzaGFyZWRfbGVuZ3RoXG4gICAgICB8IF8gOjogYSwgXyA6OiBiIC0+IGxvb3AgYSBiIChzaGFyZWRfbGVuZ3RoICsgMSlcbiAgICAgIHwgW10sIF8gfCBfLCBbXSAtPiBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2EgPSBhOyB0YWlsX29mX2IgPSBiIH1cbiAgICBpblxuICAgIGxvb3AgbDEgbDIgMFxuICA7O1xuZW5kXG5cbmxldCBjaGVja19sZW5ndGgyX2V4biBuYW1lIGwxIGwyID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMi5vZl9saXN0cyBsMSBsMiB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiAoKVxuICB8IFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYTsgdGFpbF9vZl9iIH0gLT5cbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwibGVuZ3RoIG1pc21hdGNoIGluICVzOiAlZCA8PiAlZFwiXG4gICAgICBuYW1lXG4gICAgICAoc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2EpXG4gICAgICAoc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2IpXG4gICAgICAoKVxuOztcblxubGV0IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmYgPVxuICBtYXRjaCBDaGVja19sZW5ndGgyLm9mX2xpc3RzIGwxIGwyIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+IE9yX3VuZXF1YWxfbGVuZ3Rocy5PayAoZiBsMSBsMilcbiAgfCBVbmVxdWFsX2xlbmd0aHMgXyAtPiBVbmVxdWFsX2xlbmd0aHNcbjs7XG5cbm1vZHVsZSBDaGVja19sZW5ndGgzID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPVxuICAgIHwgU2FtZV9sZW5ndGggb2YgaW50XG4gICAgfCBVbmVxdWFsX2xlbmd0aHMgb2ZcbiAgICAgICAgeyBzaGFyZWRfbGVuZ3RoIDogaW50XG4gICAgICAgIDsgdGFpbF9vZl9hIDogJ2EgbGlzdFxuICAgICAgICA7IHRhaWxfb2ZfYiA6ICdiIGxpc3RcbiAgICAgICAgOyB0YWlsX29mX2MgOiAnYyBsaXN0XG4gICAgICAgIH1cblxuICAoKiBJbiB0aGUgW1VuZXF1YWxfbGVuZ3Roc10gY2FzZSwgYXQgbGVhc3Qgb25lIG9mIHRoZSB0YWlscyB3aWxsIGJlIG5vbi1lbXB0eS4gKilcbiAgbGV0IG9mX2xpc3RzIGwxIGwyIGwzID1cbiAgICBsZXQgcmVjIGxvb3AgYSBiIGMgc2hhcmVkX2xlbmd0aCA9XG4gICAgICBtYXRjaCBhLCBiLCBjIHdpdGhcbiAgICAgIHwgW10sIFtdLCBbXSAtPiBTYW1lX2xlbmd0aCBzaGFyZWRfbGVuZ3RoXG4gICAgICB8IF8gOjogYSwgXyA6OiBiLCBfIDo6IGMgLT4gbG9vcCBhIGIgYyAoc2hhcmVkX2xlbmd0aCArIDEpXG4gICAgICB8IFtdLCBfLCBfIHwgXywgW10sIF8gfCBfLCBfLCBbXSAtPlxuICAgICAgICBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2EgPSBhOyB0YWlsX29mX2IgPSBiOyB0YWlsX29mX2MgPSBjIH1cbiAgICBpblxuICAgIGxvb3AgbDEgbDIgbDMgMFxuICA7O1xuZW5kXG5cbmxldCBjaGVja19sZW5ndGgzX2V4biBuYW1lIGwxIGwyIGwzID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMy5vZl9saXN0cyBsMSBsMiBsMyB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiAoKVxuICB8IFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYTsgdGFpbF9vZl9iOyB0YWlsX29mX2MgfSAtPlxuICAgIGxldCBuMSA9IHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9hIGluXG4gICAgbGV0IG4yID0gc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2IgaW5cbiAgICBsZXQgbjMgPSBzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYyBpblxuICAgIGludmFsaWRfYXJnZiBcImxlbmd0aCBtaXNtYXRjaCBpbiAlczogJWQgPD4gJWQgfHwgJWQgPD4gJWRcIiBuYW1lIG4xIG4yIG4yIG4zICgpXG47O1xuXG5sZXQgY2hlY2tfbGVuZ3RoMyBsMSBsMiBsMyB+ZiA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDMub2ZfbGlzdHMgbDEgbDIgbDMgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gT3JfdW5lcXVhbF9sZW5ndGhzLk9rIChmIGwxIGwyIGwzKVxuICB8IFVuZXF1YWxfbGVuZ3RocyBfIC0+IFVuZXF1YWxfbGVuZ3Roc1xuOztcblxubGV0IGl0ZXIyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooaXRlcjJfb2sgfmYpIFtAbm9udGFpbF1cblxubGV0IGl0ZXIyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiaXRlcjJfZXhuXCIgbDEgbDI7XG4gIGl0ZXIyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgcmV2X21hcDIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihyZXZfbWFwMl9vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgcmV2X21hcDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJyZXZfbWFwMl9leG5cIiBsMSBsMjtcbiAgcmV2X21hcDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBmb2xkMiBsMSBsMiB+aW5pdCB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGZvbGQyX29rIH5pbml0IH5mKSBbQG5vbnRhaWxdXG5cbmxldCBmb2xkMl9leG4gbDEgbDIgfmluaXQgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImZvbGQyX2V4blwiIGwxIGwyO1xuICBmb2xkMl9vayBsMSBsMiB+aW5pdCB+ZlxuOztcblxubGV0IGZvbGRfcmlnaHQyIGwxIGwyIH5mIH5pbml0ID1cbiAgY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZm9sZF9yaWdodDJfb2sgfmYgfmluaXQpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX3JpZ2h0Ml9leG4gbDEgbDIgfmYgfmluaXQgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImZvbGRfcmlnaHQyX2V4blwiIGwxIGwyO1xuICBmb2xkX3JpZ2h0Ml9vayBsMSBsMiB+ZiB+aW5pdFxuOztcblxubGV0IGZvcl9hbGwyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZm9yX2FsbDJfb2sgfmYpIFtAbm9udGFpbF1cblxubGV0IGZvcl9hbGwyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiZm9yX2FsbDJfZXhuXCIgbDEgbDI7XG4gIGZvcl9hbGwyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgZXhpc3RzMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGV4aXN0czJfb2sgfmYpIFtAbm9udGFpbF1cblxubGV0IGV4aXN0czJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJleGlzdHMyX2V4blwiIGwxIGwyO1xuICBleGlzdHMyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgZXF1YWwgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBmYWxzZVxuICAgIHwgYiA6OiBicyAtPiBlcXVhbCBhIGIgfHwgbG9vcCBlcXVhbCBhIGJzXG4gIGluXG4gIGxvb3AgZXF1YWwgYSB0XG47O1xuXG4oKiBUaGlzIGlzIGEgY29weSBvZiB0aGUgY29kZSBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LCB3aXRoIGFuIGV4dHJhIGV0YS1leHBhbnNpb24gdG9cbiAgIGF2b2lkIGNyZWF0aW5nIHBhcnRpYWwgY2xvc3VyZXMgKHNob3dlZCB1cCBmb3IgW2ZpbHRlcl0pIGluIHByb2ZpbGluZykuICopXG5sZXQgcmV2X2ZpbHRlciB0IH5mID1cbiAgbGV0IHJlYyBmaW5kIH5mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgeCA6OiBsIC0+IGlmIGYgeCB0aGVuIGZpbmQgfmYgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgfmYgYWNjdSBsXG4gIGluXG4gIGZpbmQgfmYgW10gdFxuOztcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgZmlsdGVyIGwgfmYgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IGhkIDo6IHRsIC0+IGlmIGYgaGQgdGhlbiBoZCA6OiBmaWx0ZXIgdGwgfmYgZWxzZSBmaWx0ZXIgdGwgfmZcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPlxuICAgICAgKG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBOb25lIC0+IGxvb3AgbFxuICAgICAgIHwgU29tZSBfIGFzIHIgLT4gcilcbiAgaW5cbiAgbG9vcCB0IFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kX21hcF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfbWFwX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcF9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXAgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcF9leG5cbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIGxvb3AgbFxuICBpblxuICBsb29wIHQgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmRfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCByZWMgZmluZF9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IHggOjogdCAtPiBpZiBmIHggdGhlbiB4IGVsc2UgZmluZF9leG4gdCB+ZlxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfZXhuXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+IGlmIGYgaSB4IHRoZW4gU29tZSAoaSwgeCkgZWxzZSBsb29wIChpICsgMSkgbFxuICBpblxuICBsb29wIDAgdCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZGlfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gIGZpbmRpX2V4blxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgIChtYXRjaCBmIGkgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgbClcbiAgaW5cbiAgbG9vcCAwIHQgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmRfbWFwaV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfbWFwaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBpX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcGlfZXhuXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gdHJ1ZVxuICAgIHwgaGQgOjogdGwgLT4gZiBpIGhkICYmIGxvb3AgKGkgKyAxKSB0bFxuICBpblxuICBsb29wIDAgdCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBmYWxzZVxuICAgIHwgaGQgOjogdGwgLT4gZiBpIGhkIHx8IGxvb3AgKGkgKyAxKSB0bFxuICBpblxuICBsb29wIDAgdCBbQG5vbnRhaWxdXG47O1xuXG4oKiogRm9yIHRoZSBjb250YWluZXIgaW50ZXJmYWNlLiAqKVxubGV0IGZvbGRfbGVmdCA9IGZvbGRcblxubGV0IG9mX2FycmF5ID0gQXJyYXkudG9fbGlzdFxubGV0IHRvX2FycmF5ID0gQXJyYXkub2ZfbGlzdFxubGV0IHRvX2xpc3QgdCA9IHRcblxuKCoqIFRhaWwgcmVjdXJzaXZlIHZlcnNpb25zIG9mIHN0YW5kYXJkIFtMaXN0XSBtb2R1bGUgKilcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgYXBwZW5kX2xvb3AgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gIHwgW10gLT4gbDJcbiAgfCBbIHgxIF0gLT4geDEgOjogbDJcbiAgfCBbIHgxOyB4MiBdIC0+IHgxIDo6IHgyIDo6IGwyXG4gIHwgWyB4MTsgeDI7IHgzIF0gLT4geDEgOjogeDIgOjogeDMgOjogbDJcbiAgfCBbIHgxOyB4MjsgeDM7IHg0IF0gLT4geDEgOjogeDIgOjogeDMgOjogeDQgOjogbDJcbiAgfCB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB0bCAtPlxuICAgIHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IHg1IDo6IChhcHBlbmRfbG9vcCBbQHRhaWxjYWxsXSkgdGwgbDJcbjs7XG5cbmxldCBhcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMiB3aXRoXG4gIHwgW10gLT4gbDFcbiAgfCBfIDo6IF8gLT4gYXBwZW5kX2xvb3AgbDEgbDJcbjs7XG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIG1hcCBsIH5mID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCB4IDo6IHRsIC0+IGYgeCA6OiAobWFwIFtAdGFpbGNhbGxdKSB0bCB+ZlxuOztcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcCB0IH5mOihmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCAoID4+fCApIGwgZiA9IG1hcCBsIH5mXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIG1hcDJfb2sgbDEgbDIgfmYgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiBbXVxuICB8IHgxIDo6IGwxLCB4MiA6OiBsMiAtPiBmIHgxIHgyIDo6IG1hcDJfb2sgbDEgbDIgfmZcbiAgfCBfLCBfIC0+IGludmFsaWRfYXJnIFwiTGlzdC5tYXAyXCJcbjs7XG5cbmxldCBtYXAyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjoobWFwMl9vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgbWFwMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIm1hcDJfZXhuXCIgbDEgbDI7XG4gIG1hcDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCByZXZfbWFwM19vayBsMSBsMiBsMyB+ZiA9XG4gIGxldCByZWMgbG9vcCBsMSBsMiBsMyBhYyA9XG4gICAgbWF0Y2ggbDEsIGwyLCBsMyB3aXRoXG4gICAgfCBbXSwgW10sIFtdIC0+IGFjXG4gICAgfCB4MSA6OiBsMSwgeDIgOjogbDIsIHgzIDo6IGwzIC0+IGxvb3AgbDEgbDIgbDMgKGYgeDEgeDIgeDMgOjogYWMpXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICBpblxuICBsb29wIGwxIGwyIGwzIFtdIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZXZfbWFwMyBsMSBsMiBsMyB+ZiA9IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmY6KHJldl9tYXAzX29rIH5mKSBbQG5vbnRhaWxdXG5cbmxldCByZXZfbWFwM19leG4gbDEgbDIgbDMgfmYgPVxuICBjaGVja19sZW5ndGgzX2V4biBcInJldl9tYXAzX2V4blwiIGwxIGwyIGwzO1xuICByZXZfbWFwM19vayBsMSBsMiBsMyB+ZlxuOztcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgbWFwM19vayBsMSBsMiBsMyB+ZiA9XG4gIG1hdGNoIGwxLCBsMiwgbDMgd2l0aFxuICB8IFtdLCBbXSwgW10gLT4gW11cbiAgfCB4MSA6OiBsMSwgeDIgOjogbDIsIHgzIDo6IGwzIC0+IGYgeDEgeDIgeDMgOjogbWFwM19vayBsMSBsMiBsMyB+ZlxuICB8IF8sIF8sIF8gLT4gaW52YWxpZF9hcmcgXCJMaXN0Lm1hcDNcIlxuOztcblxubGV0IG1hcDMgbDEgbDIgbDMgfmYgPSBjaGVja19sZW5ndGgzIGwxIGwyIGwzIH5mOihtYXAzX29rIH5mKSBbQG5vbnRhaWxdXG5cbmxldCBtYXAzX2V4biBsMSBsMiBsMyB+ZiA9XG4gIGNoZWNrX2xlbmd0aDNfZXhuIFwibWFwM19leG5cIiBsMSBsMiBsMztcbiAgbWFwM19vayBsMSBsMiBsMyB+ZlxuOztcblxubGV0IHJlYyByZXZfbWFwX2FwcGVuZCBsMSBsMiB+ZiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgfCBbXSAtPiBsMlxuICB8IGggOjogdCAtPiByZXZfbWFwX2FwcGVuZCB+ZiB0IChmIGggOjogbDIpXG47O1xuXG5sZXQgdW56aXAgbGlzdCA9XG4gIGxldCByZWMgbG9vcCBsaXN0IGwxIGwyID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IGwxLCBsMlxuICAgIHwgKHgsIHkpIDo6IHRsIC0+IGxvb3AgdGwgKHggOjogbDEpICh5IDo6IGwyKVxuICBpblxuICBsb29wIChyZXYgbGlzdCkgW10gW11cbjs7XG5cbmxldCB1bnppcDMgbGlzdCA9XG4gIGxldCByZWMgbG9vcCBsaXN0IGwxIGwyIGwzID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IGwxLCBsMiwgbDNcbiAgICB8ICh4LCB5LCB6KSA6OiB0bCAtPiBsb29wIHRsICh4IDo6IGwxKSAoeSA6OiBsMikgKHogOjogbDMpXG4gIGluXG4gIGxvb3AgKHJldiBsaXN0KSBbXSBbXSBbXVxuOztcblxubGV0IHppcF9leG4gbDEgbDIgPVxuICB0cnkgbWFwMl9vayB+ZjooZnVuIGEgYiAtPiBhLCBiKSBsMSBsMiB3aXRoXG4gIHwgXyAtPiBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gemlwX2V4bjogJWQgPD4gJWRcIiAobGVuZ3RoIGwxKSAobGVuZ3RoIGwyKSAoKVxuOztcblxubGV0IHppcCBsMSBsMiA9IG1hcDIgfmY6KGZ1biBhIGIgLT4gYSwgYikgbDEgbDJcblxuKCoqIEFkZGl0aW9uYWwgbGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZXZfbWFwaSBsIH5mID1cbiAgbGV0IHJlYyBsb29wIGkgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaCA6OiB0IC0+IGxvb3AgKGkgKyAxKSAoZiBpIGggOjogYWNjKSB0XG4gIGluXG4gIGxvb3AgMCBbXSBsIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXBpIGwgfmYgPVxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBsb29wIGkgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IGggOjogdCAtPiBmIGkgaCA6OiBsb29wIChpICsgMSkgdFxuICBpblxuICBsb29wIDAgbCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0IGl0ZXJpIGwgfmYgPVxuICBpZ25vcmVcbiAgICAoZm9sZCBsIH5pbml0OjAgfmY6KGZ1biBpIHggLT5cbiAgICAgICBmIGkgeDtcbiAgICAgICBpICsgMSlcbiAgICAgIDogaW50KVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBzbmQgKGZvbGQgdCB+aW5pdDooMCwgaW5pdCkgfmY6KGZ1biAoaSwgYWNjKSB2IC0+IGkgKyAxLCBmIGkgYWNjIHYpKVxuOztcblxubGV0IGZpbHRlcmkgbCB+ZiA9XG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGxvb3AgcG9zIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gW11cbiAgICB8IGhkIDo6IHRsIC0+IGlmIGYgcG9zIGhkIHRoZW4gaGQgOjogbG9vcCAocG9zICsgMSkgdGwgZWxzZSBsb29wIChwb3MgKyAxKSB0bFxuICBpblxuICBsb29wIDAgbCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmVkdWNlIGwgfmYgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgaGQgOjogdGwgLT4gU29tZSAoZm9sZCB+aW5pdDpoZCB+ZiB0bClcbjs7XG5cbmxldCByZWR1Y2VfZXhuIGwgfmYgPVxuICBtYXRjaCByZWR1Y2UgbCB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmVkdWNlX2V4blwiXG4gIHwgU29tZSB2IC0+IHZcbjs7XG5cbmxldCByZWR1Y2VfYmFsYW5jZWQgbCB+ZiA9XG4gICgqIENhbGwgdGhlIFwic2l6ZVwiIG9mIGEgdmFsdWUgdGhlIG51bWJlciBvZiBsaXN0IGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNvbWJpbmVkIGludG9cbiAgICAgaXQgdmlhIGNhbGxzIHRvIFtmXS4gIFdlIHByb2NlZWQgYnkgdXNpbmcgW2ZdIHRvIGNvbWJpbmUgZWxlbWVudHMgaW4gdGhlIGFjY3VtdWxhdG9yXG4gICAgIG9mIHRoZSBzYW1lIHNpemUgdW50aWwgd2UgY2FuJ3QgY29tYmluZSBhbnkgbW9yZSwgdGhlbiBnZXR0aW5nIGEgbmV3IGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgaW5wdXQgbGlzdCBhbmQgcmVwZWF0aW5nLlxuXG4gICAgIFdpdGggdGhpcyBzdHJhdGVneSwgaW4gdGhlIGFjY3VtdWxhdG9yOlxuICAgICAtIHdlIG9ubHkgZXZlciBoYXZlIGVsZW1lbnRzIG9mIHNpemVzIGEgcG93ZXIgb2YgdHdvXG4gICAgIC0gd2UgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gb25lIGVsZW1lbnQgb2YgZWFjaCBzaXplXG4gICAgIC0gdGhlIHN1bSBvZiBhbGwgdGhlIGVsZW1lbnQgc2l6ZXMgaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBlbGVtZW50cyBjb25zdW1lZFxuXG4gICAgIFRoZXNlIGNvbmRpdGlvbnMgZW5mb3JjZSB0aGF0IGxpc3Qgb2YgZWxlbWVudHMgb2YgZWFjaCBzaXplIGlzIHByZWNpc2VseSB0aGUgYmluYXJ5XG4gICAgIGV4cGFuc2lvbiBvZiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnN1bWVkOiBpZiB5b3UndmUgY29uc3VtZWQgMTMgPSAwYjExMDFcbiAgICAgZWxlbWVudHMsIHlvdSBoYXZlIG9uZSBlbGVtZW50IG9mIHNpemUgOCwgb25lIG9mIHNpemUgNCwgYW5kIG9uZSBvZiBzaXplIDEuICBIZW5jZVxuICAgICB3aGVuIGEgbmV3IGVsZW1lbnQgY29tZXMgYWxvbmcsIHRoZSBudW1iZXIgb2YgY29tYmluaW5ncyB5b3UgbmVlZCB0byBkbyBpcyB0aGUgbnVtYmVyXG4gICAgIG9mIHRyYWlsaW5nIDFzIGluIHRoZSBiaW5hcnkgZXhwYW5zaW9uIG9mIFtudW1dLCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgaGF2ZVxuICAgICBhbHJlYWR5IGdvbmUgaW50byB0aGUgYWNjdW11bGF0b3IuICBUaGUgYWNjdW11bGF0b3IgaXMgaW4gYXNjZW5kaW5nIG9yZGVyIG9mIHNpemUsIHNvXG4gICAgIHRoZSBuZXh0IGVsZW1lbnQgdG8gY29tYmluZSB3aXRoIGlzIGFsd2F5cyB0aGUgaGVhZCBvZiB0aGUgbGlzdC4gKilcbiAgbGV0IHJlYyBzdGVwX2FjY3VtIG51bSBhY2MgeCA9XG4gICAgaWYgbnVtIGxhbmQgMSA9IDBcbiAgICB0aGVuIHggOjogYWNjXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhY2Mgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICgqIE5ldyBlbGVtZW50cyBmcm9tIGxhdGVyIGluIHRoZSBpbnB1dCBsaXN0IGdvIG9uIHRoZSBmcm9udCBvZiB0aGUgYWNjdW11bGF0b3IsIHNvXG4gICAgICAgICB0aGUgYWNjdW11bGF0b3IgaXMgaW4gcmV2ZXJzZSBvcmRlciB3cnQgdGhlIG9yaWdpbmFsIGxpc3Qgb3JkZXIsIGhlbmNlIFtmIHkgeF1cbiAgICAgICAgIGluc3RlYWQgb2YgW2YgeCB5XS4gKilcbiAgICAgIHwgeSA6OiB5cyAtPiBzdGVwX2FjY3VtIChudW0gYXNyIDEpIHlzIChmIHkgeCkpXG4gIGluXG4gICgqIEV4cGVyaW1lbnRhbGx5LCBpbmxpbmluZyBbZm9sZGldIGFuZCB1bnJvbGxpbmcgdGhpcyBsb29wIGEgZmV3IHRpbWVzIGNhbiByZWR1Y2VcbiAgICAgcnVudGltZSBkb3duIHRvIGEgdGhpcmQgYW5kIGFsbG9jYXRpb24gdG8gMS8xNnRoIG9yIHNvIGluIHRoZSBtaWNyb2JlbmNobWFya3MgYmVsb3cuXG4gICAgIEhvd2V2ZXIsIGluIG1vc3QgdXNlIGNhc2VzIFtmXSBpcyBsaWtlbHkgdG8gYmUgZXhwZW5zaXZlIChvdGhlcndpc2Ugd2h5IGRvIHlvdSBjYXJlXG4gICAgIGFib3V0IHRoZSBvcmRlciBvZiByZWR1Y3Rpb24/KSBzbyB0aGUgb3ZlcmhlYWQgb2YgdGhpcyBmdW5jdGlvbiBpdHNlbGYgZG9lc24ndCByZWFsbHlcbiAgICAgbWF0dGVyLiBJZiB5b3UgY29tZSB1cCB3aXRoIGEgdXNlLWNhc2Ugd2hlcmUgaXQgZG9lcywgdGhlbiB0aGF0J3Mgc29tZXRoaW5nIHlvdSBtaWdodFxuICAgICB3YW50IHRvIHRyeTogc2VlIGhnIGxvZyAtcHIgNDllZjA2NWY0MjlkLiAqKVxuICBtYXRjaCBmb2xkaSBsIH5pbml0OltdIH5mOnN0ZXBfYWNjdW0gd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IHhzIC0+IFNvbWUgKGZvbGQgeHMgfmluaXQ6eCB+ZjooZnVuIHggeSAtPiBmIHkgeCkpXG47O1xuXG5sZXQgcmVkdWNlX2JhbGFuY2VkX2V4biBsIH5mID1cbiAgbWF0Y2ggcmVkdWNlX2JhbGFuY2VkIGwgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJlZHVjZV9iYWxhbmNlZF9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgZ3JvdXBpIGwgfmJyZWFrID1cbiAgKCogV2UgYWxsb2NhdGUgc2hhcmVkIHBvc2l0aW9uIGFuZCBsaXN0IHJlZmVyZW5jZXMgc28gd2UgY2FuIG1ha2UgdGhlIGlubmVyIGxvb3AgdXNlXG4gICAgIFtbQHRhaWxfbW9kX2NvbnNdXSwgYW5kIHN0aWxsIHJldHVybiBiYWNrIGluZm9ybWF0aW9uIGFib3V0IHBvc2l0aW9uIGFuZCB3aGVyZSBpbiB0aGVcbiAgICAgbGlzdCB3ZSBsZWZ0IG9mZi4gKilcbiAgbGV0IHBvcyA9IHJlZiAwIGluXG4gIGxldCBsID0gcmVmIGwgaW5cbiAgKCogQXMgYSByZXN1bHQgb2YgdXNpbmcgbG9jYWwgcmVmZXJlbmNlcywgb3VyIGlubmVyIGxvb3AgZG9lcyBub3QgbmVlZCBhcmd1bWVudHMuICopXG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIHRha2VfZ3JvdXAgKCkgPVxuICAgIG1hdGNoICFsIHdpdGhcbiAgICB8IChbXSB8IFsgXyBdKSBhcyBncm91cCAtPlxuICAgICAgbCA6PSBbXTtcbiAgICAgIGdyb3VwXG4gICAgfCB4IDo6ICh5IDo6IF8gYXMgdGwpIC0+XG4gICAgICBwb3MgOj0gIXBvcyArIDE7XG4gICAgICBsIDo9IHRsO1xuICAgICAgaWYgYnJlYWsgIXBvcyB4IHkgdGhlbiBbIHggXSBlbHNlIHggOjogdGFrZV9ncm91cCAoKVxuICBpblxuICAoKiBPdXIgb3V0ZXIgbG9vcCBkb2VzIG5vdCBuZWVkIGFyZ3VtZW50cywgZWl0aGVyLiAqKVxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBncm91cHMgKCkgPVxuICAgIGlmIGlzX2VtcHR5ICFsXG4gICAgdGhlbiBbXVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGdyb3VwID0gdGFrZV9ncm91cCAoKSBpblxuICAgICAgZ3JvdXAgOjogZ3JvdXBzICgpKVxuICBpblxuICBncm91cHMgKCkgW0Bub250YWlsXVxuOztcblxubGV0IGdyb3VwIGwgfmJyZWFrID0gZ3JvdXBpIGwgfmJyZWFrOihmdW4gXyB4IHkgLT4gYnJlYWsgeCB5KSBbQG5vbnRhaWxdXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIG1lcmdlIGwxIGwyIH5jb21wYXJlID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbDIgLT4gbDJcbiAgfCBsMSwgW10gLT4gbDFcbiAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICBpZiBjb21wYXJlIGgxIGgyIDw9IDAgdGhlbiBoMSA6OiBtZXJnZSB0MSBsMiB+Y29tcGFyZSBlbHNlIGgyIDo6IG1lcmdlIGwxIHQyIH5jb21wYXJlXG47O1xuXG5sZXQgc3RhYmxlX3NvcnQgbCB+Y29tcGFyZTpjbXAgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBjbXAgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gcmV2X21lcmdlIGNtcCB0MSBsMiAoaDEgOjogYWNjdSlcbiAgICAgIGVsc2UgcmV2X21lcmdlIGNtcCBsMSB0MiAoaDIgOjogYWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGNtcCBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICB0aGVuIHJldl9tZXJnZV9yZXYgY21wIHQxIGwyIChoMSA6OiBhY2N1KVxuICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGNtcCBsMSB0MiAoaDIgOjogYWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuIFsgeDE7IHgyIF0gZWxzZSBbIHgyOyB4MSBdIGluXG4gICAgICBzLCB0bFxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgIGxldCBzID1cbiAgICAgICAgaWYgY21wIHgxIHgyIDw9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwXG4gICAgICAgICAgdGhlbiBbIHgxOyB4MjsgeDMgXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDBcbiAgICAgICAgICB0aGVuIFsgeDE7IHgzOyB4MiBdXG4gICAgICAgICAgZWxzZSBbIHgzOyB4MTsgeDIgXVxuICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwXG4gICAgICAgIHRoZW4gWyB4MjsgeDE7IHgzIF1cbiAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMFxuICAgICAgICB0aGVuIFsgeDI7IHgzOyB4MSBdXG4gICAgICAgIGVsc2UgWyB4MzsgeDI7IHgxIF1cbiAgICAgIGluXG4gICAgICBzLCB0bFxuICAgIHwgbiwgbCAtPlxuICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICByZXZfbWVyZ2VfcmV2IGNtcCBzMSBzMiBbXSwgdGxcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPiAwIHRoZW4gWyB4MTsgeDIgXSBlbHNlIFsgeDI7IHgxIF0gaW5cbiAgICAgIHMsIHRsXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgbGV0IHMgPVxuICAgICAgICBpZiBjbXAgeDEgeDIgPiAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiBjbXAgeDIgeDMgPiAwXG4gICAgICAgICAgdGhlbiBbIHgxOyB4MjsgeDMgXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMFxuICAgICAgICAgIHRoZW4gWyB4MTsgeDM7IHgyIF1cbiAgICAgICAgICBlbHNlIFsgeDM7IHgxOyB4MiBdXG4gICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMFxuICAgICAgICB0aGVuIFsgeDI7IHgxOyB4MyBdXG4gICAgICAgIGVsc2UgaWYgY21wIHgyIHgzID4gMFxuICAgICAgICB0aGVuIFsgeDI7IHgzOyB4MSBdXG4gICAgICAgIGVsc2UgWyB4MzsgeDI7IHgxIF1cbiAgICAgIGluXG4gICAgICBzLCB0bFxuICAgIHwgbiwgbCAtPlxuICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgcmV2X21lcmdlIGNtcCBzMSBzMiBbXSwgdGxcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuOztcblxubGV0IHNvcnQgPSBzdGFibGVfc29ydFxuXG5sZXQgc29ydF9hbmRfZ3JvdXAgbCB+Y29tcGFyZSA9XG4gIChsIHw+IHN0YWJsZV9zb3J0IH5jb21wYXJlIHw+IGdyb3VwIH5icmVhazooZnVuIHggeSAtPiBjb21wYXJlIHggeSA8PiAwKSkgW0Bub250YWlsXVxuOztcblxubGV0IGRlZHVwX2FuZF9zb3J0IGwgfmNvbXBhcmU6Y21wID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgY21wIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIChtYXRjaCBjbXAgaDEgaDIgd2l0aFxuICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IHJldl9tZXJnZSBjbXAgdDEgbDIgKGgxIDo6IGFjY3UpXG4gICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gcmV2X21lcmdlIGNtcCBsMSB0MiAoaDIgOjogYWNjdSlcbiAgICAgICB8IF8gLT4gcmV2X21lcmdlIGNtcCB0MSBsMiBhY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgY21wIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIChtYXRjaCBjbXAgaDEgaDIgd2l0aFxuICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IHJldl9tZXJnZV9yZXYgY21wIHQxIGwyIChoMSA6OiBhY2N1KVxuICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IHJldl9tZXJnZV9yZXYgY21wIGwxIHQyIChoMiA6OiBhY2N1KVxuICAgICAgIHwgXyAtPiByZXZfbWVyZ2VfcmV2IGNtcCB0MSBsMiBhY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICBsZXQgcyA9XG4gICAgICAgIG1hdGNoIGNtcCB4MSB4MiB3aXRoXG4gICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IFsgeDE7IHgyIF1cbiAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gWyB4MjsgeDEgXVxuICAgICAgICB8IF8gLT4gWyB4MiBdXG4gICAgICBpblxuICAgICAgcywgdGxcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICBsZXQgcyA9XG4gICAgICAgIG1hdGNoIGNtcCB4MSB4MiB3aXRoXG4gICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+XG4gICAgICAgICAgKG1hdGNoIGNtcCB4MiB4MyB3aXRoXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IFsgeDE7IHgyOyB4MyBdXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+XG4gICAgICAgICAgICAgKG1hdGNoIGNtcCB4MSB4MyB3aXRoXG4gICAgICAgICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IFsgeDE7IHgzOyB4MiBdXG4gICAgICAgICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IFsgeDM7IHgxOyB4MiBdXG4gICAgICAgICAgICAgIHwgXyAtPiBbIHgzOyB4MiBdKVxuICAgICAgICAgICB8IF8gLT4gWyB4MTsgeDMgXSlcbiAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT5cbiAgICAgICAgICAobWF0Y2ggY21wIHgxIHgzIHdpdGhcbiAgICAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gWyB4MjsgeDE7IHgzIF1cbiAgICAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT5cbiAgICAgICAgICAgICAobWF0Y2ggY21wIHgyIHgzIHdpdGhcbiAgICAgICAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gWyB4MjsgeDM7IHgxIF1cbiAgICAgICAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gWyB4MzsgeDI7IHgxIF1cbiAgICAgICAgICAgICAgfCBfIC0+IFsgeDM7IHgxIF0pXG4gICAgICAgICAgIHwgXyAtPiBbIHgyOyB4MyBdKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAobWF0Y2ggY21wIHgyIHgzIHdpdGhcbiAgICAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gWyB4MjsgeDMgXVxuICAgICAgICAgICB8IGMgd2hlbiBjID4gMCAtPiBbIHgzOyB4MiBdXG4gICAgICAgICAgIHwgXyAtPiBbIHgzIF0pXG4gICAgICBpblxuICAgICAgcywgdGxcbiAgICB8IG4sIGwgLT5cbiAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgcmV2X21lcmdlX3JldiBjbXAgczEgczIgW10sIHRsXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgIGxldCBzID1cbiAgICAgICAgbWF0Y2ggY21wIHgxIHgyIHdpdGhcbiAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gWyB4MTsgeDIgXVxuICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiBbIHgyOyB4MSBdXG4gICAgICAgIHwgXyAtPiBbIHgyIF1cbiAgICAgIGluXG4gICAgICBzLCB0bFxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgIGxldCBzID1cbiAgICAgICAgbWF0Y2ggY21wIHgxIHgyIHdpdGhcbiAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT5cbiAgICAgICAgICAobWF0Y2ggY21wIHgyIHgzIHdpdGhcbiAgICAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gWyB4MTsgeDI7IHgzIF1cbiAgICAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT5cbiAgICAgICAgICAgICAobWF0Y2ggY21wIHgxIHgzIHdpdGhcbiAgICAgICAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gWyB4MTsgeDM7IHgyIF1cbiAgICAgICAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gWyB4MzsgeDE7IHgyIF1cbiAgICAgICAgICAgICAgfCBfIC0+IFsgeDM7IHgyIF0pXG4gICAgICAgICAgIHwgXyAtPiBbIHgxOyB4MyBdKVxuICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPlxuICAgICAgICAgIChtYXRjaCBjbXAgeDEgeDMgd2l0aFxuICAgICAgICAgICB8IGMgd2hlbiBjID4gMCAtPiBbIHgyOyB4MTsgeDMgXVxuICAgICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPlxuICAgICAgICAgICAgIChtYXRjaCBjbXAgeDIgeDMgd2l0aFxuICAgICAgICAgICAgICB8IGMgd2hlbiBjID4gMCAtPiBbIHgyOyB4MzsgeDEgXVxuICAgICAgICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiBbIHgzOyB4MjsgeDEgXVxuICAgICAgICAgICAgICB8IF8gLT4gWyB4MzsgeDEgXSlcbiAgICAgICAgICAgfCBfIC0+IFsgeDI7IHgzIF0pXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIChtYXRjaCBjbXAgeDIgeDMgd2l0aFxuICAgICAgICAgICB8IGMgd2hlbiBjID4gMCAtPiBbIHgyOyB4MyBdXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IFsgeDM7IHgyIF1cbiAgICAgICAgICAgfCBfIC0+IFsgeDMgXSlcbiAgICAgIGluXG4gICAgICBzLCB0bFxuICAgIHwgbiwgbCAtPlxuICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgcmV2X21lcmdlIGNtcCBzMSBzMiBbXSwgdGxcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuOztcblxubGV0IHN0YWJsZV9kZWR1cCBsaXN0IH5jb21wYXJlID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgW10gfCBbIF8gXSAtPiBsaXN0ICgqIHNwZWNpYWwgY2FzZSBmb3IgcGVyZm9ybWFuY2UgKilcbiAgfCBfIDo6IF8gOjogXyAtPlxuICAgIGxldCBvcGVuIHN0cnVjdFxuICAgICAgdHlwZSAnYSBkZWR1cCA9XG4gICAgICAgIHsgZWx0IDogJ2FcbiAgICAgICAgOyBtdXRhYmxlIGR1cCA6IGJvb2xcbiAgICAgICAgfVxuICAgIGVuZCBpblxuICAgICgqIFtzdGFibGVfZGVkdXBdIGtlZXBzIHRoZSBmaXJzdCBvZiBlYWNoIHNldCBvZiBkdXBsaWNhdGVzLiBbZGVkdXBfYW5kX3NvcnRdIGtlZXBzXG4gICAgICAgdGhlIGxhc3QuIFdlIGRlZmluZSBvbmUgaW4gdGVybXMgb2YgdGhlIG90aGVyIGJ5IHBhc3NpbmcgdGhlIHZhbHVlcyBpbiByZXZlcnNlXG4gICAgICAgb3JkZXIsIGhlbmNlIHRoZSBbcmV2X21hcF0gaW4gdGhlIGRlZmluaXRpb24gb2YgW2RlZHVwc10uIFdlIHJlc3RvcmUgdGhlIG9yZGVyIGluXG4gICAgICAgdGhlIGZpbmFsIFtmb2xkXS4gKilcbiAgICBsZXQgZGVkdXBzID0gcmV2X21hcCBsaXN0IH5mOihmdW4gZWx0IC0+IHsgZWx0OyBkdXAgPSB0cnVlIH0pIGluXG4gICAgbGV0IHVuaXF1ZSA9IGRlZHVwX2FuZF9zb3J0IGRlZHVwcyB+Y29tcGFyZTooZnVuIHggeSAtPiBjb21wYXJlIHguZWx0IHkuZWx0KSBpblxuICAgIGl0ZXIgdW5pcXVlIH5mOihmdW4gZGVkdXAgLT4gZGVkdXAuZHVwIDwtIGZhbHNlKTtcbiAgICBmb2xkIGRlZHVwcyB+aW5pdDpbXSB+ZjooZnVuIGFjYyBkZWR1cCAtPiBpZiBkZWR1cC5kdXAgdGhlbiBhY2MgZWxzZSBkZWR1cC5lbHQgOjogYWNjKVxuOztcblxubGV0IGNvbmNhdF9tYXBpIGwgfmYgPVxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBvdXRlcl9sb29wIHBvcyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgWyBoZCBdIC0+IChmIFtAdGFpbGNhbGwgZmFsc2VdKSBwb3MgaGRcbiAgICB8IGhkIDo6IChfIDo6IF8gYXMgdGwpIC0+IGlubmVyX2xvb3AgKHBvcyArIDEpIChmIHBvcyBoZCkgdGxcbiAgYW5kW0B0YWlsX21vZF9jb25zXSBpbm5lcl9sb29wIHBvcyBsMSBsMiA9XG4gICAgbWF0Y2ggbDEgd2l0aFxuICAgIHwgW10gLT4gb3V0ZXJfbG9vcCBwb3MgbDJcbiAgICB8IFsgeDEgXSAtPiB4MSA6OiBvdXRlcl9sb29wIHBvcyBsMlxuICAgIHwgWyB4MTsgeDIgXSAtPiB4MSA6OiB4MiA6OiBvdXRlcl9sb29wIHBvcyBsMlxuICAgIHwgWyB4MTsgeDI7IHgzIF0gLT4geDEgOjogeDIgOjogeDMgOjogb3V0ZXJfbG9vcCBwb3MgbDJcbiAgICB8IFsgeDE7IHgyOyB4MzsgeDQgXSAtPiB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiBvdXRlcl9sb29wIHBvcyBsMlxuICAgIHwgeDEgOjogeDIgOjogeDMgOjogeDQgOjogeDUgOjogdGwgLT5cbiAgICAgIHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IHg1IDo6IGlubmVyX2xvb3AgcG9zIHRsIGwyXG4gIGluXG4gIG91dGVyX2xvb3AgMCBsIFtAbm9udGFpbF1cbjs7XG5cbmxldCBjb25jYXRfbWFwIGwgfmYgPSBjb25jYXRfbWFwaSBsIH5mOihmdW4gXyB4IC0+IGYgeCkgW0Bub250YWlsXVxuXG5tb2R1bGUgQ2FydGVzaWFuX3Byb2R1Y3QgPSBzdHJ1Y3RcbiAgKCogV2UgYXJlIGV4cGxpY2l0IGFib3V0IHdoYXQgd2UgZXhwb3J0IGZyb20gZnVuY3RvcnMgc28gdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHlcbiAgICAgcmViaW5kIG1vcmUgZWZmaWNpZW50IGxpc3Qtc3BlY2lmaWMgZnVuY3Rpb25zLiAqKVxuXG4gIGxldCBiaW5kID0gY29uY2F0X21hcFxuICBsZXQgbWFwID0gbWFwXG4gIGxldCBtYXAyIGEgYiB+ZiA9IGNvbmNhdF9tYXAgYSB+ZjooZnVuIHggLT4gbWFwIGIgfmY6KGZ1biB5IC0+IGYgeCB5KSlcbiAgbGV0IHJldHVybiA9IHNpbmdsZXRvblxuICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgbGV0ICggPj49ICkgdCBmID0gYmluZCB0IH5mXG5cbiAgb3BlbiBzdHJ1Y3RcbiAgICBtb2R1bGUgQXBwbGljYXRpdmUgPSBBcHBsaWNhdGl2ZS5NYWtlX3VzaW5nX21hcDIgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICAgIGxldCBtYXAyID0gbWFwMlxuICAgIGVuZClcblxuICAgIG1vZHVsZSBNb25hZCA9IE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgIGVuZClcbiAgZW5kXG5cbiAgbGV0IGFsbCA9IE1vbmFkLmFsbFxuICBsZXQgYWxsX3VuaXQgPSBNb25hZC5hbGxfdW5pdFxuICBsZXQgaWdub3JlX20gPSBNb25hZC5pZ25vcmVfbVxuICBsZXQgam9pbiA9IE1vbmFkLmpvaW5cblxuICBtb2R1bGUgTW9uYWRfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBsZXQgKCA+Pj0gKSA9ICggPj49IClcbiAgZW5kXG5cbiAgbGV0IGFwcGx5ID0gQXBwbGljYXRpdmUuYXBwbHlcbiAgbGV0IGJvdGggPSBBcHBsaWNhdGl2ZS5ib3RoXG4gIGxldCBtYXAzID0gQXBwbGljYXRpdmUubWFwM1xuICBsZXQgKCA8Kj4gKSA9IEFwcGxpY2F0aXZlLiggPCo+IClcbiAgbGV0ICggKj4gKSA9IEFwcGxpY2F0aXZlLiggKj4gKVxuICBsZXQgKCA8KiApID0gQXBwbGljYXRpdmUuKCA8KiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPCo+ICkgPSBBcHBsaWNhdGl2ZS4oIDwqPiApXG4gICAgbGV0ICggKj4gKSA9IEFwcGxpY2F0aXZlLiggKj4gKVxuICAgIGxldCAoIDwqICkgPSBBcHBsaWNhdGl2ZS4oIDwqIClcbiAgZW5kXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPj49ICkgPSAoID4+PSApXG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG4gICAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIChDYXJ0ZXNpYW5fcHJvZHVjdCA6IE1vbmFkLlNfbG9jYWwgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdClcblxuKCoqIHJldHVybnMgZmluYWwgZWxlbWVudCBvZiBsaXN0ICopXG5sZXQgcmVjIGxhc3RfZXhuIGxpc3QgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbIHggXSAtPiB4XG4gIHwgXyA6OiB0bCAtPiBsYXN0X2V4biB0bFxuICB8IFtdIC0+IGludmFsaWRfYXJnIFwiTGlzdC5sYXN0XCJcbjs7XG5cbigqKiBvcHRpb25hbGx5IHJldHVybnMgZmluYWwgZWxlbWVudCBvZiBsaXN0ICopXG5sZXQgcmVjIGxhc3QgbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFsgeCBdIC0+IFNvbWUgeFxuICB8IF8gOjogdGwgLT4gbGFzdCB0bFxuICB8IFtdIC0+IE5vbmVcbjs7XG5cbmxldCByZWMgaXNfcHJlZml4IGxpc3QgfnByZWZpeCB+ZXF1YWwgPVxuICBtYXRjaCBwcmVmaXggd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCBoZCA6OiB0bCAtPlxuICAgIChtYXRjaCBsaXN0IHdpdGhcbiAgICAgfCBbXSAtPiBmYWxzZVxuICAgICB8IGhkJyA6OiB0bCcgLT4gZXF1YWwgaGQgaGQnICYmIGlzX3ByZWZpeCB0bCcgfnByZWZpeDp0bCB+ZXF1YWwpXG47O1xuXG5sZXQgZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUgdCB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgYTEgOjogdCAtPlxuICAgIGxldCByZWMgbG9vcCBhMSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiBOb25lXG4gICAgICB8IGEyIDo6IHQgLT4gaWYgZXF1YWwgYTEgYTIgdGhlbiBTb21lIChhMSwgYTIpIGVsc2UgbG9vcCBhMiB0XG4gICAgaW5cbiAgICBsb29wIGExIHQgW0Bub250YWlsXVxuOztcblxuKCogcmV0dXJucyBsaXN0IHdpdGhvdXQgYWRqYWNlbnQgZHVwbGljYXRlcyAqKVxubGV0IHJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzID8od2hpY2hfdG9fa2VlcCA9IGBMYXN0KSBsaXN0IH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCB0b19rZWVwIGFjY3VtID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHRvX2tlZXAgOjogYWNjdW1cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICBpZiBlcXVhbCBoZCB0b19rZWVwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHRvX2tlZXAgPVxuICAgICAgICAgIG1hdGNoIHdoaWNoX3RvX2tlZXAgd2l0aFxuICAgICAgICAgIHwgYEZpcnN0IC0+IHRvX2tlZXBcbiAgICAgICAgICB8IGBMYXN0IC0+IGhkXG4gICAgICAgIGluXG4gICAgICAgIGxvb3AgdG9fa2VlcCBhY2N1bSB0bClcbiAgICAgIGVsc2UgbG9vcCBoZCAodG9fa2VlcCA6OiBhY2N1bSkgdGxcbiAgaW5cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBoZCA6OiB0bCAtPiByZXYgKGxvb3AgaGQgW10gdGwpXG47O1xuXG5sZXQgZmluZF9hX2R1cCBsIH5jb21wYXJlID1cbiAgbGV0IHNvcnRlZCA9IHNvcnQgbCB+Y29tcGFyZSBpblxuICBsZXQgcmVjIGxvb3AgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSB8IFsgXyBdIC0+IE5vbmVcbiAgICB8IGhkMSA6OiAoaGQyIDo6IF8gYXMgdGwpIC0+IGlmIGNvbXBhcmUgaGQxIGhkMiA9IDAgdGhlbiBTb21lIGhkMSBlbHNlIGxvb3AgdGxcbiAgaW5cbiAgbG9vcCBzb3J0ZWQgW0Bub250YWlsXVxuOztcblxubGV0IGNvbnRhaW5zX2R1cCBsc3QgfmNvbXBhcmUgPVxuICBtYXRjaCBmaW5kX2FfZHVwIGxzdCB+Y29tcGFyZSB3aXRoXG4gIHwgU29tZSBfIC0+IHRydWVcbiAgfCBOb25lIC0+IGZhbHNlXG47O1xuXG5sZXQgZmluZF9hbGxfZHVwcyBsIH5jb21wYXJlID1cbiAgbGV0IHNvcnRlZCA9IHNvcnQgfmNvbXBhcmUgbCBpblxuICAoKiBXYWxrIHRoZSBsaXN0IGFuZCByZWNvcmQgdGhlIGZpcnN0IG9mIGVhY2ggY29uc2VjdXRpdmUgcnVuIG9mIGlkZW50aWNhbCBlbGVtZW50cyAqKVxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBsb29wIHNvcnRlZCBwcmV2IH5hbHJlYWR5X3JlY29yZGVkID1cbiAgICBtYXRjaCBzb3J0ZWQgd2l0aFxuICAgIHwgW10gLT4gW11cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICBpZiBjb21wYXJlIHByZXYgaGQgPD4gMFxuICAgICAgdGhlbiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOmZhbHNlXG4gICAgICBlbHNlIGlmIGFscmVhZHlfcmVjb3JkZWRcbiAgICAgIHRoZW4gbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDp0cnVlXG4gICAgICBlbHNlIGhkIDo6IGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6dHJ1ZVxuICBpblxuICBtYXRjaCBzb3J0ZWQgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT4gbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDpmYWxzZSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmVjIGFsbF9lcXVhbF90byB0IHYgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IHggOjogeHMgLT4gZXF1YWwgeCB2ICYmIGFsbF9lcXVhbF90byB4cyB2IH5lcXVhbFxuOztcblxubGV0IGFsbF9lcXVhbCB0IH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IHhzIC0+IGlmIGFsbF9lcXVhbF90byB4cyB4IH5lcXVhbCB0aGVuIFNvbWUgeCBlbHNlIE5vbmVcbjs7XG5cbmxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG5sZXQgY291bnRpIHQgfmYgPVxuICBmb2xkaSB0IH5pbml0OjAgfmY6KGZ1biBpZHggY291bnQgYSAtPiBpZiBmIGlkeCBhIHRoZW4gY291bnQgKyAxIGVsc2UgY291bnQpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBpbml0IG4gfmYgPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIkxpc3QuaW5pdCAlZFwiIG4gKCk7XG4gIGxldCByZWMgbG9vcCBpIGFjY3VtID1cbiAgICBhc3NlcnQgKGkgPj0gMCk7XG4gICAgaWYgaSA9IDAgdGhlbiBhY2N1bSBlbHNlIGxvb3AgKGkgLSAxKSAoZiAoaSAtIDEpIDo6IGFjY3VtKVxuICBpblxuICBsb29wIG4gW10gW0Bub250YWlsXVxuOztcblxubGV0IHJldl9maWx0ZXJfbWFwIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgbCBhY2N1bSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBhY2N1bVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIChtYXRjaCBmIGhkIHdpdGhcbiAgICAgICB8IFNvbWUgeCAtPiBsb29wIHRsICh4IDo6IGFjY3VtKVxuICAgICAgIHwgTm9uZSAtPiBsb29wIHRsIGFjY3VtKVxuICBpblxuICBsb29wIGwgW10gW0Bub250YWlsXVxuOztcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgZmlsdGVyX21hcCBsIH5mID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBoZCA6OiB0bCAtPlxuICAgIChtYXRjaCBmIGhkIHdpdGhcbiAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgdGwgfmZcbiAgICAgfCBTb21lIHggLT4geCA6OiBmaWx0ZXJfbWFwIHRsIH5mKVxuOztcblxubGV0IHJldl9maWx0ZXJfbWFwaSBsIH5mID1cbiAgbGV0IHJlYyBsb29wIGkgbCBhY2N1bSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBhY2N1bVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIChtYXRjaCBmIGkgaGQgd2l0aFxuICAgICAgIHwgU29tZSB4IC0+IGxvb3AgKGkgKyAxKSB0bCAoeCA6OiBhY2N1bSlcbiAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIHRsIGFjY3VtKVxuICBpblxuICBsb29wIDAgbCBbXSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgbCB+ZiA9XG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGxvb3AgcG9zIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gW11cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAobWF0Y2ggZiBwb3MgaGQgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIChwb3MgKyAxKSB0bFxuICAgICAgIHwgU29tZSB4IC0+IHggOjogbG9vcCAocG9zICsgMSkgdGwpXG4gIGluXG4gIGxvb3AgMCBsIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaWx0ZXJfb3B0IGwgPSBmaWx0ZXJfbWFwIGwgfmY6Rm4uaWRcblxubGV0IHBhcnRpdGlvbjNfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCBmc3Qgc25kIHRyZCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByZXYgZnN0LCByZXYgc25kLCByZXYgdHJkXG4gICAgfCB4IDo6IHQgLT5cbiAgICAgIChtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgYEZzdCB5IC0+IGxvb3AgdCAoeSA6OiBmc3QpIHNuZCB0cmRcbiAgICAgICB8IGBTbmQgeSAtPiBsb29wIHQgZnN0ICh5IDo6IHNuZCkgdHJkXG4gICAgICAgfCBgVHJkIHkgLT4gbG9vcCB0IGZzdCBzbmQgKHkgOjogdHJkKSlcbiAgaW5cbiAgbG9vcCB0IFtdIFtdIFtdIFtAbm9udGFpbF1cbjs7XG5cbmxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gIGxldCBmIHggOiBfIEVpdGhlci50ID0gaWYgZiB4IHRoZW4gRmlyc3QgeCBlbHNlIFNlY29uZCB4IGluXG4gIHBhcnRpdGlvbl9tYXAgdCB+ZiBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcGFydGl0aW9uX3Jlc3VsdCB0ID0gcGFydGl0aW9uX21hcCB0IH5mOlJlc3VsdC50b19laXRoZXJcblxubW9kdWxlIEFzc29jID0gc3RydWN0XG4gIHR5cGUgJ2Ega2V5ID0gKCdhW0B0YWcgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX2tleV90YWcgPSBMaXN0IFtdXSlcbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQga2V5X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIGtleSA9XG4gICAgZnVuIF9vZl9hX18wMjJfIC0+IF9vZl9hX18wMjJfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2Zfa2V5IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIGtleSAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biBfb2ZfYV9fMDI0XyAtPiBfb2ZfYV9fMDI0X1xuICA7O1xuXG4gIGxldCBrZXlfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIGtleSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBUYWdnZWRcbiAgICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY19rZXlfdGFnXG4gICAgICAgICAgOyB2YWx1ZSA9IExpc3QgW11cbiAgICAgICAgICA7IGdyYW1tYXIgPSBfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAnYSB2YWx1ZSA9ICgnYVtAdGFnIFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY192YWx1ZV90YWcgPSBMaXN0IFtdXSlcbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgdmFsdWVfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdmFsdWUgPVxuICAgIGZ1biBfb2ZfYV9fMDI1XyAtPiBfb2ZfYV9fMDI1X1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3ZhbHVlIDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHZhbHVlIC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgZnVuIF9vZl9hX18wMjdfIC0+IF9vZl9hX18wMjdfXG4gIDs7XG5cbiAgbGV0IHZhbHVlX3NleHBfZ3JhbW1hciA6XG4gICAgICAgICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB2YWx1ZSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPlxuICAgIHsgdW50eXBlZCA9XG4gICAgICAgIFRhZ2dlZFxuICAgICAgICAgIHsga2V5ID0gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX3ZhbHVlX3RhZ1xuICAgICAgICAgIDsgdmFsdWUgPSBMaXN0IFtdXG4gICAgICAgICAgOyBncmFtbWFyID0gXydhX3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgfVxuICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgKCgnYSBrZXkgKiAnYiB2YWx1ZSkgbGlzdFtAdGFnIFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY190YWcgPSBMaXN0IFtdXSlcbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAgICAgJ2EgJ2IuXG4gICAgICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpXG4gICAgICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpXG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgICAgICAtPiAoJ2EsICdiKSB0XG4gICAgPVxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzAzNl8gPSBcImxpc3QubWwuQXNzb2MudFwiIGluXG4gICAgZnVuIF9vZl9hX18wMjhfIF9vZl9iX18wMjlfIHhfXzAzN18gLT5cbiAgICAgIGxpc3Rfb2Zfc2V4cFxuICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFsgYXJnMF9fMDMxXzsgYXJnMV9fMDMyXyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMzNfID0ga2V5X29mX3NleHAgX29mX2FfXzAyOF8gYXJnMF9fMDMxX1xuICAgICAgICAgICBhbmQgcmVzMV9fMDM0XyA9IHZhbHVlX29mX3NleHAgX29mX2JfXzAyOV8gYXJnMV9fMDMyXyBpblxuICAgICAgICAgICByZXMwX18wMzNfLCByZXMxX18wMzRfXG4gICAgICAgICB8IHNleHBfXzAzNV8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnR1cGxlX29mX3NpemVfbl9leHBlY3RlZFxuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDM2X1xuICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICBzZXhwX18wMzVfKVxuICAgICAgICB4X18wMzdfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgICAgICdhICdiLlxuICAgICAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2EsICdiKSB0XG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gX29mX2FfXzAzOF8gX29mX2JfXzAzOV8geF9fMDQ0XyAtPlxuICAgIHNleHBfb2ZfbGlzdFxuICAgICAgKGZ1biAoYXJnMF9fMDQwXywgYXJnMV9fMDQxXykgLT5cbiAgICAgICAgbGV0IHJlczBfXzA0Ml8gPSBzZXhwX29mX2tleSBfb2ZfYV9fMDM4XyBhcmcwX18wNDBfXG4gICAgICAgIGFuZCByZXMxX18wNDNfID0gc2V4cF9vZl92YWx1ZSBfb2ZfYl9fMDM5XyBhcmcxX18wNDFfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzA0Ml87IHJlczFfXzA0M18gXSlcbiAgICAgIHhfXzA0NF9cbiAgOztcblxuICBsZXQgdF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAnYSAnYi5cbiAgICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVGFnZ2VkXG4gICAgICAgICAgeyBrZXkgPSBTZXhwbGliMC5TZXhwX2dyYW1tYXIuYXNzb2NfdGFnXG4gICAgICAgICAgOyB2YWx1ZSA9IExpc3QgW11cbiAgICAgICAgICA7IGdyYW1tYXIgPVxuICAgICAgICAgICAgICAobGlzdF9zZXhwX2dyYW1tYXJcbiAgICAgICAgICAgICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICAgICAgICAgICAgIExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCAoa2V5X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyKS51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICwgQ29ucyAoKHZhbHVlX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyKS51bnR5cGVkLCBFbXB0eSkgKSlcbiAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudW50eXBlZFxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgcGFpcl9vZl9ncm91cCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IChrLCBfKSA6OiBfIGFzIGxpc3QgLT4gaywgbWFwIGxpc3QgfmY6c25kXG4gIDs7XG5cbiAgbGV0IGdyb3VwIGFsaXN0IH5lcXVhbCA9XG4gICAgZ3JvdXAgYWxpc3QgfmJyZWFrOihmdW4gKHgsIF8pICh5LCBfKSAtPiBub3QgKGVxdWFsIHggeSkpIHw+IG1hcCB+ZjpwYWlyX29mX2dyb3VwXG4gIDs7XG5cbiAgbGV0IHNvcnRfYW5kX2dyb3VwIGFsaXN0IH5jb21wYXJlID1cbiAgICBzb3J0X2FuZF9ncm91cCBhbGlzdCB+Y29tcGFyZTooZnVuICh4LCBfKSAoeSwgXykgLT4gY29tcGFyZSB4IHkpXG4gICAgfD4gbWFwIH5mOnBhaXJfb2ZfZ3JvdXBcbiAgOztcblxuICBsZXQgZmluZCB0IH5lcXVhbCBrZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZjooZnVuIChrZXknLCBfKSAtPiBlcXVhbCBrZXkga2V5Jykgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gU29tZSAoc25kIHgpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuID1cbiAgICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LkFzc29jLmZpbmRfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgICBsZXQgcmVjIGZpbmRfZXhuIHQgfmVxdWFsIGtleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgICB8IChrZXknLCB2YWx1ZSkgOjogdCAtPiBpZiBlcXVhbCBrZXkga2V5JyB0aGVuIHZhbHVlIGVsc2UgZmluZF9leG4gdCB+ZXF1YWwga2V5XG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgZmluZF9leG5cbiAgOztcblxuICBsZXQgbWVtIHQgfmVxdWFsIGtleSA9XG4gICAgbWF0Y2ggZmluZCB0IH5lcXVhbCBrZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgIHwgU29tZSBfIC0+IHRydWVcbiAgOztcblxuICBsZXQgcmVtb3ZlIHQgfmVxdWFsIGtleSA9IGZpbHRlciB0IH5mOihmdW4gKGtleScsIF8pIC0+IG5vdCAoZXF1YWwga2V5IGtleScpKSBbQG5vbnRhaWxdXG5cbiAgbGV0IGFkZCB0IH5lcXVhbCBrZXkgdmFsdWUgPVxuICAgICgqIHRoZSByZW1vdmUgZG9lc24ndCBjaGFuZ2UgdGhlIG1hcCBzZW1hbnRpY3MsIGJ1dCBrZWVwcyB0aGUgbGlzdCBzbWFsbCAqKVxuICAgIChrZXksIHZhbHVlKSA6OiByZW1vdmUgdCB+ZXF1YWwga2V5XG4gIDs7XG5cbiAgbGV0IGludmVyc2UgdCA9IG1hcCB0IH5mOihmdW4gKHgsIHkpIC0+IHksIHgpXG4gIGxldCBtYXAgdCB+ZiA9IG1hcCB0IH5mOihmdW4gKGtleSwgdmFsdWUpIC0+IGtleSwgZiB2YWx1ZSkgW0Bub250YWlsXVxuZW5kXG5cbmxldCBzdWIgbCB+cG9zIH5sZW4gPVxuICAoKiBXZSB1c2UgW3BvcyA+IGxlbmd0aCBsIC0gbGVuXSByYXRoZXIgdGhhbiBbcG9zICsgbGVuID4gbGVuZ3RoIGxdIHRvIGF2b2lkIHRoZVxuICAgICBwb3NzaWJpbGl0eSBvZiBvdmVyZmxvdy4gKilcbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IGxlbmd0aCBsIC0gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LnN1YlwiO1xuICBsZXQgc3RvcCA9IHBvcyArIGxlbiBpblxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBsb29wIGkgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIGlmIGkgPCBwb3MgdGhlbiBsb29wIChpICsgMSkgdGwgZWxzZSBpZiBpIDwgc3RvcCB0aGVuIGhkIDo6IGxvb3AgKGkgKyAxKSB0bCBlbHNlIFtdXG4gIGluXG4gIGxvb3AgMCBsIFtAbm9udGFpbF1cbjs7XG5cbmxldCBzcGxpdF9uIHRfb3JpZyBuID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gW10sIHRfb3JpZ1xuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgbiB0IGFjY3VtID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiB0X29yaWcsIFtdICgqIGluIHRoaXMgY2FzZSwgdF9vcmlnID0gcmV2IGFjY3VtICopXG4gICAgICB8IGhkIDo6IHRsIC0+IGlmIG4gPSAwIHRoZW4gcmV2IGFjY3VtLCB0IGVsc2UgbG9vcCAobiAtIDEpIHRsIChoZCA6OiBhY2N1bSlcbiAgICBpblxuICAgIGxvb3AgbiB0X29yaWcgW10pXG47O1xuXG4oKiBjb3BpZWQgZnJvbSBbc3BsaXRfbl0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlICopXG5sZXQgdGFrZSB0X29yaWcgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIFtdXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbG9vcCBuIHQgYWNjdW0gPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IHRfb3JpZ1xuICAgICAgfCBoZCA6OiB0bCAtPiBpZiBuID0gMCB0aGVuIHJldiBhY2N1bSBlbHNlIGxvb3AgKG4gLSAxKSB0bCAoaGQgOjogYWNjdW0pXG4gICAgaW5cbiAgICBsb29wIG4gdF9vcmlnIFtdKVxuOztcblxubGV0IHJlYyBkcm9wIHQgbiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IF8gOjogdGwgd2hlbiBuID4gMCAtPiBkcm9wIHRsIChuIC0gMSlcbiAgfCB0IC0+IHRcbjs7XG5cbmxldCBjaHVua3Nfb2YgbCB+bGVuZ3RoID1cbiAgaWYgbGVuZ3RoIDw9IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJMaXN0LmNodW5rc19vZjogRXhwZWN0ZWQgbGVuZ3RoID4gMCwgZ290ICVkXCIgbGVuZ3RoICgpO1xuICBsZXQgcmVjIGF1eCBsZW5ndGggYWNjIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgXyA6OiBfIC0+XG4gICAgICBsZXQgc3VibGlzdCwgbCA9IHNwbGl0X24gbCBsZW5ndGggaW5cbiAgICAgIGF1eCBsZW5ndGggKHN1Ymxpc3QgOjogYWNjKSBsXG4gIGluXG4gIGF1eCBsZW5ndGggW10gbFxuOztcblxubGV0IHNwbGl0X3doaWxlIHhzIH5mID1cbiAgbGV0IHJlYyBsb29wIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCB3aGVuIGYgaGQgLT4gbG9vcCAoaGQgOjogYWNjKSB0bFxuICAgIHwgdCAtPiByZXYgYWNjLCB0XG4gIGluXG4gIGxvb3AgW10geHMgW0Bub250YWlsXVxuOztcblxuKCogY29waWVkIGZyb20gW3NwbGl0X3doaWxlXSB0byBhdm9pZCBhbGxvY2F0aW5nIGEgdHVwbGUgKilcbmxldCB0YWtlX3doaWxlIHhzIH5mID1cbiAgbGV0IHJlYyBsb29wIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCB3aGVuIGYgaGQgLT4gbG9vcCAoaGQgOjogYWNjKSB0bFxuICAgIHwgXyAtPiByZXYgYWNjXG4gIGluXG4gIGxvb3AgW10geHMgW0Bub250YWlsXVxuOztcblxubGV0IHJlYyBkcm9wX3doaWxlIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBoZCA6OiB0bCB3aGVuIGYgaGQgLT4gZHJvcF93aGlsZSB0bCB+ZlxuICB8IHQgLT4gdFxuOztcblxubGV0IGRyb3BfbGFzdCB0ID1cbiAgbWF0Y2ggcmV2IHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBfIDo6IGxzdCAtPiBTb21lIChyZXYgbHN0KVxuOztcblxubGV0IGRyb3BfbGFzdF9leG4gdCA9XG4gIG1hdGNoIGRyb3BfbGFzdCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiTGlzdC5kcm9wX2xhc3RfZXhuOiBlbXB0eSBsaXN0XCJcbiAgfCBTb21lIGxzdCAtPiBsc3Rcbjs7XG5cbmxldCBjYXJ0ZXNpYW5fcHJvZHVjdCBsaXN0MSBsaXN0MiA9XG4gIGlmIGlzX2VtcHR5IGxpc3QyXG4gIHRoZW4gW11cbiAgZWxzZSAoXG4gICAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgb3V0ZXJfbG9vcCBsMSA9XG4gICAgICBtYXRjaCBsMSB3aXRoXG4gICAgICB8IFtdIC0+IFtdXG4gICAgICB8IHgxIDo6IGwxIC0+IGlubmVyX2xvb3AgeDEgbDEgbGlzdDJcbiAgICBhbmRbQHRhaWxfbW9kX2NvbnNdIGlubmVyX2xvb3AgeDEgbDEgbDIgPVxuICAgICAgbWF0Y2ggbDIgd2l0aFxuICAgICAgfCBbXSAtPiBvdXRlcl9sb29wIGwxXG4gICAgICB8IHgyIDo6IGwyIC0+ICh4MSwgeDIpIDo6IGlubmVyX2xvb3AgeDEgbDEgbDJcbiAgICBpblxuICAgIG91dGVyX2xvb3AgbGlzdDEgW0Bub250YWlsXSlcbjs7XG5cbmxldCBjb25jYXQgbCA9IGZvbGRfcmlnaHQgbCB+aW5pdDpbXSB+ZjphcHBlbmRcbmxldCBjb25jYXRfbm9fb3JkZXIgbCA9IGZvbGQgbCB+aW5pdDpbXSB+ZjooZnVuIGFjYyBsIC0+IHJldl9hcHBlbmQgbCBhY2MpXG5sZXQgY29ucyB4IGwgPSB4IDo6IGxcblxubGV0IGlzX3NvcnRlZCBsIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiB0cnVlXG4gICAgfCB4MSA6OiAoeDIgOjogXyBhcyByZXN0KSAtPiBjb21wYXJlIHgxIHgyIDw9IDAgJiYgbG9vcCByZXN0XG4gIGluXG4gIGxvb3AgbCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgaXNfc29ydGVkX3N0cmljdGx5IGwgfmNvbXBhcmUgPVxuICBsZXQgcmVjIGxvb3AgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSB8IFsgXyBdIC0+IHRydWVcbiAgICB8IHgxIDo6ICh4MiA6OiBfIGFzIHJlc3QpIC0+IGNvbXBhcmUgeDEgeDIgPCAwICYmIGxvb3AgcmVzdFxuICBpblxuICBsb29wIGwgW0Bub250YWlsXVxuOztcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGxldCAoIEAgKSA9IGFwcGVuZFxuZW5kXG5cbmxldCBwZXJtdXRlID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxpc3QgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgKCogc3BlY2lhbCBjYXNlcyB0byBzcGVlZCB0aGluZ3MgdXAgaW4gdHJpdmlhbCBjYXNlcyAqKVxuICB8IFtdIHwgWyBfIF0gLT4gbGlzdFxuICB8IFsgeDsgeSBdIC0+IGlmIFJhbmRvbS5TdGF0ZS5ib29sIHJhbmRvbV9zdGF0ZSB0aGVuIFsgeTsgeCBdIGVsc2UgbGlzdFxuICB8IF8gLT5cbiAgICBsZXQgYXJyID0gQXJyYXkub2ZfbGlzdCBsaXN0IGluXG4gICAgQXJyYXlfcGVybXV0ZS5wZXJtdXRlIGFyciB+cmFuZG9tX3N0YXRlO1xuICAgIEFycmF5LnRvX2xpc3QgYXJyXG47O1xuXG5sZXQgcmFuZG9tX2VsZW1lbnRfZXhuID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxpc3QgPVxuICBpZiBpc19lbXB0eSBsaXN0XG4gIHRoZW4gZmFpbHdpdGggXCJMaXN0LnJhbmRvbV9lbGVtZW50X2V4bjogZW1wdHkgbGlzdFwiXG4gIGVsc2UgbnRoX2V4biBsaXN0IChSYW5kb20uU3RhdGUuaW50IHJhbmRvbV9zdGF0ZSAobGVuZ3RoIGxpc3QpKVxuOztcblxubGV0IHJhbmRvbV9lbGVtZW50ID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxpc3QgPVxuICB0cnkgU29tZSAocmFuZG9tX2VsZW1lbnRfZXhuIH5yYW5kb21fc3RhdGUgbGlzdCkgd2l0aFxuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IHJlYyBjb21wYXJlIGNtcCBhIGIgPVxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfIC0+IC0xXG4gIHwgXywgW10gLT4gMVxuICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICBsZXQgbiA9IGNtcCB4IHkgaW5cbiAgICBpZiBuID0gMCB0aGVuIGNvbXBhcmUgY21wIHhzIHlzIGVsc2UgblxuOztcblxubGV0IHJlYyBjb21wYXJlX19sb2NhbCBjbXAgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgbGV0IG4gPSBjbXAgeCB5IGluXG4gICAgaWYgbiA9IDAgdGhlbiBjb21wYXJlX19sb2NhbCBjbXAgeHMgeXMgZWxzZSBuXG47O1xuXG5sZXQgaGFzaF9mb2xkX3QgPSBoYXNoX2ZvbGRfbGlzdFxuXG5sZXQgZXF1YWxfd2l0aF9sb2NhbF9jbG9zdXJlIChlcXVhbCA6IF8gLT4gXyAtPiBfKSB0MSB0MiA9XG4gIGxldCByZWMgbG9vcCB+ZXF1YWwgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgeDEgOjogdDEsIHgyIDo6IHQyIC0+IGVxdWFsIHgxIHgyICYmIGxvb3AgfmVxdWFsIHQxIHQyXG4gICAgfCBfIC0+IGZhbHNlXG4gIGluXG4gIGxvb3AgfmVxdWFsIHQxIHQyXG47O1xuXG5sZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID1cbiAgZnVuIGYgeCB5IC0+IGVxdWFsX3dpdGhfbG9jYWxfY2xvc3VyZSBmIHggeVxuOztcblxubGV0IGVxdWFsX19sb2NhbCBlcXVhbF9hX19sb2NhbCB0MSB0MiA9XG4gIGxldCByZWMgbG9vcCB+ZXF1YWxfYV9fbG9jYWwgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgeDEgOjogdDEsIHgyIDo6IHQyIC0+IGVxdWFsX2FfX2xvY2FsIHgxIHgyICYmIGxvb3AgfmVxdWFsX2FfX2xvY2FsIHQxIHQyXG4gICAgfCBfIC0+IGZhbHNlXG4gIGluXG4gIGxvb3AgfmVxdWFsX2FfX2xvY2FsIHQxIHQyIFtAbm9udGFpbF1cbjs7XG5cbmxldCB0cmFuc3Bvc2UgPVxuICBsZXQgcmVjIHNwbGl0X29mZl9maXJzdF9jb2x1bW4gdCBjb2x1bW5fYWNjIHRyaW1tZWQgZm91bmRfZW1wdHkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gY29sdW1uX2FjYywgdHJpbW1lZCwgZm91bmRfZW1wdHlcbiAgICB8IFtdIDo6IHRsIC0+IHNwbGl0X29mZl9maXJzdF9jb2x1bW4gdGwgY29sdW1uX2FjYyB0cmltbWVkIHRydWVcbiAgICB8ICh4IDo6IHhzKSA6OiB0bCAtPlxuICAgICAgc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiB0bCAoeCA6OiBjb2x1bW5fYWNjKSAoeHMgOjogdHJpbW1lZCkgZm91bmRfZW1wdHlcbiAgaW5cbiAgbGV0IHNwbGl0X29mZl9maXJzdF9jb2x1bW4gcm93cyA9IHNwbGl0X29mZl9maXJzdF9jb2x1bW4gcm93cyBbXSBbXSBmYWxzZSBpblxuICBsZXQgcmVjIGxvb3Agcm93cyBjb2x1bW5zIGRvX3JldiA9XG4gICAgbWF0Y2ggc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiByb3dzIHdpdGhcbiAgICB8IFtdLCBbXSwgXyAtPiBTb21lIChyZXYgY29sdW1ucylcbiAgICB8IGNvbHVtbiwgdHJpbW1lZF9yb3dzLCBmb3VuZF9lbXB0eSAtPlxuICAgICAgaWYgZm91bmRfZW1wdHlcbiAgICAgIHRoZW4gTm9uZVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBjb2x1bW4gPSBpZiBkb19yZXYgdGhlbiByZXYgY29sdW1uIGVsc2UgY29sdW1uIGluXG4gICAgICAgIGxvb3AgdHJpbW1lZF9yb3dzIChjb2x1bW4gOjogY29sdW1ucykgKG5vdCBkb19yZXYpKVxuICBpblxuICBmdW4gdCAtPiBsb29wIHQgW10gdHJ1ZVxuOztcblxuZXhjZXB0aW9uIFRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHMgb2YgaW50IGxpc3QgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZFxuICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHNdXG4gICAgKGZ1bmN0aW9uXG4gICAgfCBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIGFyZzBfXzA0NV8gLT5cbiAgICAgIGxldCByZXMwX18wNDZfID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfaW50IGFyZzBfXzA0NV8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxpc3QubWwuVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3Roc1wiXG4gICAgICAgIDsgcmVzMF9fMDQ2X1xuICAgICAgICBdXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbmxldCB0cmFuc3Bvc2VfZXhuIGwgPVxuICBtYXRjaCB0cmFuc3Bvc2UgbCB3aXRoXG4gIHwgU29tZSBsIC0+IGxcbiAgfCBOb25lIC0+IHJhaXNlIChUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIChtYXAgbCB+ZjoobGVuZ3RoIDo+IF8gLT4gXykpKVxuOztcblxubGV0IGludGVyc3BlcnNlIHQgfnNlcCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgeCA6OiB4cyAtPiB4IDo6IGZvbGRfcmlnaHQgeHMgfmluaXQ6W10gfmY6KGZ1biB5IGFjYyAtPiBzZXAgOjogeSA6OiBhY2MpXG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0IH5maW5pc2hcblxubGV0IGlzX3N1ZmZpeCBsaXN0IH5zdWZmaXggfmVxdWFsOihlcXVhbF9lbHQgOiBfIC0+IF8gLT4gXykgPVxuICBsZXQgbGlzdF9sZW4gPSBsZW5ndGggbGlzdCBpblxuICBsZXQgc3VmZml4X2xlbiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgbGlzdF9sZW4gPj0gc3VmZml4X2xlblxuICAmJiBlcXVhbF93aXRoX2xvY2FsX2Nsb3N1cmUgZXF1YWxfZWx0IChkcm9wIGxpc3QgKGxpc3RfbGVuIC0gc3VmZml4X2xlbikpIHN1ZmZpeFxuOztcbiIsIigqIFRoaXMgbW9kdWxlIGlzIHRyeWluZyB0byBtaW5pbWl6ZSBkZXBlbmRlbmNpZXMgb24gbW9kdWxlcyBpbiBDb3JlLCBzbyBhcyB0byBhbGxvd1xuICAgW0luZm9dLCBbRXJyb3JdLCBhbmQgW09yX2Vycm9yXSB0byBiZSB1c2VkIGluIGFzIG1hbnkgcGxhY2VzIGFzIHBvc3NpYmxlLiBQbGVhc2UgYXZvaWRcbiAgIGFkZGluZyBuZXcgZGVwZW5kZW5jaWVzLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW5mb19pbnRmXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuXG5tb2R1bGUgTWVzc2FnZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBvZiBTZXhwLnRcbiAgICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgICB8IEV4biBvZiBleG5cbiAgICB8IFNleHAgb2YgU2V4cC50XG4gICAgfCBUYWdfc2V4cCBvZiBzdHJpbmcgKiBTZXhwLnQgKiBTb3VyY2VfY29kZV9wb3NpdGlvbjAudCBvcHRpb25cbiAgICB8IFRhZ190IG9mIHN0cmluZyAqIHRcbiAgICB8IFRhZ19hcmcgb2Ygc3RyaW5nICogU2V4cC50ICogdFxuICAgIHwgT2ZfbGlzdCBvZiBpbnQgb3B0aW9uICogdCBsaXN0XG4gICAgfCBXaXRoX2JhY2t0cmFjZSBvZiB0ICogc3RyaW5nICgqIGJhY2t0cmFjZSAqKVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgcmVjIHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBhcmcwX18wMDFfIC0+XG4gICAgICAgbGV0IHJlczBfXzAwMl8gPSBTZXhwLnNleHBfb2ZfdCBhcmcwX18wMDFfIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQ291bGRfbm90X2NvbnN0cnVjdFwiOyByZXMwX18wMDJfIF1cbiAgICAgfCBTdHJpbmcgYXJnMF9fMDAzXyAtPlxuICAgICAgIGxldCByZXMwX18wMDRfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDAzXyBpblxuICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlN0cmluZ1wiOyByZXMwX18wMDRfIF1cbiAgICAgfCBFeG4gYXJnMF9fMDA1XyAtPlxuICAgICAgIGxldCByZXMwX18wMDZfID0gc2V4cF9vZl9leG4gYXJnMF9fMDA1XyBpblxuICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkV4blwiOyByZXMwX18wMDZfIF1cbiAgICAgfCBTZXhwIGFyZzBfXzAwN18gLT5cbiAgICAgICBsZXQgcmVzMF9fMDA4XyA9IFNleHAuc2V4cF9vZl90IGFyZzBfXzAwN18gaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTZXhwXCI7IHJlczBfXzAwOF8gXVxuICAgICB8IFRhZ19zZXhwIChhcmcwX18wMDlfLCBhcmcxX18wMTBfLCBhcmcyX18wMTFfKSAtPlxuICAgICAgIGxldCByZXMwX18wMTJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDA5X1xuICAgICAgIGFuZCByZXMxX18wMTNfID0gU2V4cC5zZXhwX29mX3QgYXJnMV9fMDEwX1xuICAgICAgIGFuZCByZXMyX18wMTRfID0gc2V4cF9vZl9vcHRpb24gU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdCBhcmcyX18wMTFfIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ19zZXhwXCI7IHJlczBfXzAxMl87IHJlczFfXzAxM187IHJlczJfXzAxNF8gXVxuICAgICB8IFRhZ190IChhcmcwX18wMTVfLCBhcmcxX18wMTZfKSAtPlxuICAgICAgIGxldCByZXMwX18wMTdfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDE1X1xuICAgICAgIGFuZCByZXMxX18wMThfID0gc2V4cF9vZl90IGFyZzFfXzAxNl8gaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUYWdfdFwiOyByZXMwX18wMTdfOyByZXMxX18wMThfIF1cbiAgICAgfCBUYWdfYXJnIChhcmcwX18wMTlfLCBhcmcxX18wMjBfLCBhcmcyX18wMjFfKSAtPlxuICAgICAgIGxldCByZXMwX18wMjJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDE5X1xuICAgICAgIGFuZCByZXMxX18wMjNfID0gU2V4cC5zZXhwX29mX3QgYXJnMV9fMDIwX1xuICAgICAgIGFuZCByZXMyX18wMjRfID0gc2V4cF9vZl90IGFyZzJfXzAyMV8gaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVGFnX2FyZ1wiOyByZXMwX18wMjJfOyByZXMxX18wMjNfOyByZXMyX18wMjRfIF1cbiAgICAgfCBPZl9saXN0IChhcmcwX18wMjVfLCBhcmcxX18wMjZfKSAtPlxuICAgICAgIGxldCByZXMwX18wMjdfID0gc2V4cF9vZl9vcHRpb24gc2V4cF9vZl9pbnQgYXJnMF9fMDI1X1xuICAgICAgIGFuZCByZXMxX18wMjhfID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfdCBhcmcxX18wMjZfIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2ZfbGlzdFwiOyByZXMwX18wMjdfOyByZXMxX18wMjhfIF1cbiAgICAgfCBXaXRoX2JhY2t0cmFjZSAoYXJnMF9fMDI5XywgYXJnMV9fMDMwXykgLT5cbiAgICAgICBsZXQgcmVzMF9fMDMxXyA9IHNleHBfb2ZfdCBhcmcwX18wMjlfXG4gICAgICAgYW5kIHJlczFfXzAzMl8gPSBzZXhwX29mX3N0cmluZyBhcmcxX18wMzBfIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiV2l0aF9iYWNrdHJhY2VcIjsgcmVzMF9fMDMxXzsgcmVzMV9fMDMyXyBdXG4gICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHJlYyB0b19zZXhwc19odW0gdCBhYyA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IF8gYXMgdCAtPiBzZXhwX29mX3QgdCA6OiBhY1xuICAgIHwgU3RyaW5nIHN0cmluZyAtPiBBdG9tIHN0cmluZyA6OiBhY1xuICAgIHwgRXhuIGV4biAtPiBFeG4uc2V4cF9vZl90IGV4biA6OiBhY1xuICAgIHwgU2V4cCBzZXhwIC0+IHNleHAgOjogYWNcbiAgICB8IFRhZ19zZXhwICh0YWcsIHNleHAsIGhlcmUpIC0+XG4gICAgICBMaXN0XG4gICAgICAgIChBdG9tIHRhZ1xuICAgICAgICAgOjogc2V4cFxuICAgICAgICAgOjpcbiAgICAgICAgIChtYXRjaCBoZXJlIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgICB8IFNvbWUgaGVyZSAtPiBbIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgaGVyZSBdKSlcbiAgICAgIDo6IGFjXG4gICAgfCBUYWdfdCAodGFnLCB0KSAtPiBMaXN0IChBdG9tIHRhZyA6OiB0b19zZXhwc19odW0gdCBbXSkgOjogYWNcbiAgICB8IFRhZ19hcmcgKHRhZywgc2V4cCwgdCkgLT5cbiAgICAgIGxldCBib2R5ID0gc2V4cCA6OiB0b19zZXhwc19odW0gdCBbXSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCB0YWcgPSAwIHRoZW4gTGlzdCBib2R5IDo6IGFjIGVsc2UgTGlzdCAoQXRvbSB0YWcgOjogYm9keSkgOjogYWNcbiAgICB8IFdpdGhfYmFja3RyYWNlICh0LCBiYWNrdHJhY2UpIC0+XG4gICAgICBTZXhwLkxpc3RcbiAgICAgICAgWyB0b19zZXhwX2h1bSB0OyBzZXhwX29mX2xpc3Qgc2V4cF9vZl9zdHJpbmcgKFN0cmluZy5zcGxpdF9saW5lcyBiYWNrdHJhY2UpIF1cbiAgICAgIDo6IGFjXG4gICAgfCBPZl9saXN0IChfLCB0cykgLT5cbiAgICAgIExpc3QuZm9sZCAoTGlzdC5yZXYgdHMpIH5pbml0OmFjIH5mOihmdW4gYWMgdCAtPiB0b19zZXhwc19odW0gdCBhYylcblxuICBhbmQgdG9fc2V4cF9odW0gdCA9XG4gICAgbWF0Y2ggdG9fc2V4cHNfaHVtIHQgW10gd2l0aFxuICAgIHwgWyBzZXhwIF0gLT4gc2V4cFxuICAgIHwgc2V4cHMgLT4gU2V4cC5MaXN0IHNleHBzXG4gIDs7XG5lbmRcblxub3BlbiBNZXNzYWdlXG5cbm1vZHVsZSBDb21wdXRlZCA9IHN0cnVjdFxuICAoKiBNZW1vaXplZCwgbGF6aWx5LWNvbXB1dGVkIHJlcHJlc2VudGF0aW9uIG9mIG1lc3NhZ2VzLiBNYWludGFpbnMgaXRzIG93biBzdGF0ZSB0b1xuICAgICBhdm9pZCBzdGFjayBvdmVyZmxvdyBmcm9tIG5lc3RlZCBbTGF6eS50XS4gKilcblxuICAoKiBXZSB1c2UgYSBnbG9iYWwgW3N0YXRlIHJlZl0gc28gd2UgY2FuIG11dGF0ZSBbc3RhdGVdLCBidXQgc3RpbGwgW2dsb2JhbGl6ZV0gd2l0aCBub1xuICAgICBjb3N0IGFuZCB3aXRob3V0IGR1cGxpY2F0aW5nIHN0YXRlLiAqKVxuICB0eXBlIGluZm8gPSB7IHN0YXRlIDogc3RhdGUgcmVmIH0gW0BAdW5ib3hlZF1cblxuICAoKiBBbiBbaW5mb10gc3RhcnRzIGFzIGEgW2NvbnN0cnVjdG9yXS4gV2hlbiBmb3JjZWQsIGl0IGlzIG1hcmtlZCBbQ29tcHV0aW5nXSB0byBhdm9pZFxuICAgICBjeWNsZXMuIFdoZW4gZmluaXNoZWQsIHRoZSBmaW5hbCBbbWVzc2FnZV0gaXMgcmVjb3JkZWQuICopXG4gIGFuZCBzdGF0ZSA9XG4gICAgfCBJbml0aWFsIG9mIGNvbnN0cnVjdG9yXG4gICAgfCBDb21wdXRpbmdcbiAgICB8IEZpbmFsIG9mIE1lc3NhZ2UudFxuXG4gICgqIFJlY3Vyc2l2ZSBjb25zdHJ1Y3RvcnMgZm9yIFtJbmZvLnRdLiBPdGhlcnMgY2FuIGJlIGJ1aWx0IGRpcmVjdGx5IGFzIFtNZXNzYWdlLnRdLiAqKVxuICBhbmQgY29uc3RydWN0b3IgPVxuICAgIHwgQ29uc19sYXp5X2luZm8gb2YgaW5mbyBMYXp5LnRcbiAgICB8IENvbnNfbGlzdCBvZiBpbmZvIGxpc3RcbiAgICB8IENvbnNfdGFnX2FyZyBvZiBzdHJpbmcgKiBTZXhwLnQgKiBpbmZvXG4gICAgfCBDb25zX3RhZ190IG9mIHN0cmluZyAqIGluZm9cblxuICAoKiBUaGlzIGlzIGEgbm8tb3AsIHNpbmNlIFtpbmZvXSBpcyB1bmJveGVkLiAqKVxuICBsZXQgZ2xvYmFsaXplX2luZm8geyBzdGF0ZSB9ID0geyBzdGF0ZSB9XG5cbiAgKCogV2Uga2VlcCBhIGxpc3Qgb2Ygc3RhY2tfZnJhbWVzIHdoaWxlIGNvbXB1dGluZywgcmF0aGVyIHRoYW4gdXNpbmcgdGhlIGNhbGwgc3RhY2suICopXG4gIHR5cGUgc3RhY2tfZnJhbWUgPVxuICAgIHwgSW5faW5mbyBvZiBpbmZvXG4gICAgfCBJbl90YWdfYXJnIG9mIHN0cmluZyAqIFNleHAudFxuICAgIHwgSW5fdGFnX3Qgb2Ygc3RyaW5nXG4gICAgfCBJbl9saXN0IG9mXG4gICAgICAgIHsgZndkX3ByZWZpeCA6IGluZm8gbGlzdFxuICAgICAgICA7IHJldl9zdWZmaXggOiBNZXNzYWdlLnQgbGlzdFxuICAgICAgICB9XG5cbiAgKCogVGhlIGZvbGxvd2luZyBtdXR1YWxseS1yZWN1cnNpdmUgZnVuY3Rpb25zIGNvbXB1dGUgYSBbTWVzc2FnZS50XSBmcm9tIGFuIFtpbmZvXS5cbiAgICAgQWxsIGNhbGxzIGJlbG93IGFyZSB0YWlsIGNhbGxzOiB3ZSB3YW50IHRvIGF2b2lkIHVzaW5nIHRoZSBjYWxsIHN0YWNrIGluIGZhdm9yXG4gICAgIG9mIG91ciBvd24gbWFudWFsIHN0YWNrLiAqKVxuICBsZXQgcmVjIGNvbXB1dGVfaW5mbyBpbmZvIHN0YWNrID1cbiAgICBtYXRjaCAhKGluZm8uc3RhdGUpIHdpdGhcbiAgICB8IEluaXRpYWwgY29ucyAtPlxuICAgICAgaW5mby5zdGF0ZSA6PSBDb21wdXRpbmc7XG4gICAgICBjb21wdXRlX2NvbnN0cnVjdG9yIGNvbnMgKEluX2luZm8gaW5mbyA6OiBzdGFjaylcbiAgICB8IENvbXB1dGluZyAtPlxuICAgICAgY29tcHV0ZV9tZXNzYWdlIChDb3VsZF9ub3RfY29uc3RydWN0IChBdG9tIFwiY3ljbGUgd2hpbGUgY29tcHV0aW5nIG1lc3NhZ2VcIikpIHN0YWNrXG4gICAgfCBGaW5hbCBtZXNzYWdlIC0+IGNvbXB1dGVfbWVzc2FnZSBtZXNzYWdlIHN0YWNrXG5cbiAgYW5kIGNvbXB1dGVfaW5mb19saXN0IH5md2RfcHJlZml4IH5yZXZfc3VmZml4IHN0YWNrID1cbiAgICBtYXRjaCBmd2RfcHJlZml4IHdpdGhcbiAgICB8IGluZm8gOjogZndkX3ByZWZpeCAtPiBjb21wdXRlX2luZm8gaW5mbyAoSW5fbGlzdCB7IGZ3ZF9wcmVmaXg7IHJldl9zdWZmaXggfSA6OiBzdGFjaylcbiAgICB8IFtdIC0+XG4gICAgICBsZXQgaW5mb3MgPVxuICAgICAgICBMaXN0LmZvbGQgcmV2X3N1ZmZpeCB+aW5pdDpbXSB+ZjooZnVuIHRhaWwgbWVzc2FnZSAtPlxuICAgICAgICAgIG1hdGNoIG1lc3NhZ2Ugd2l0aFxuICAgICAgICAgIHwgT2ZfbGlzdCAoXywgbWVzc2FnZXMpIC0+IG1lc3NhZ2VzIEAgdGFpbFxuICAgICAgICAgIHwgXyAtPiBtZXNzYWdlIDo6IHRhaWwpXG4gICAgICBpblxuICAgICAgY29tcHV0ZV9tZXNzYWdlIChPZl9saXN0IChOb25lLCBpbmZvcykpIHN0YWNrXG5cbiAgYW5kIGNvbXB1dGVfY29uc3RydWN0b3IgY29ucyBzdGFjayA9XG4gICAgbWF0Y2ggY29ucyB3aXRoXG4gICAgfCBDb25zX3RhZ19hcmcgKHRhZywgYXJnLCBpbmZvKSAtPiBjb21wdXRlX2luZm8gaW5mbyAoSW5fdGFnX2FyZyAodGFnLCBhcmcpIDo6IHN0YWNrKVxuICAgIHwgQ29uc190YWdfdCAodGFnLCBpbmZvKSAtPiBjb21wdXRlX2luZm8gaW5mbyAoSW5fdGFnX3QgdGFnIDo6IHN0YWNrKVxuICAgIHwgQ29uc19saXN0IGluZm9zIC0+IGNvbXB1dGVfaW5mb19saXN0IH5md2RfcHJlZml4OmluZm9zIH5yZXZfc3VmZml4OltdIHN0YWNrXG4gICAgfCBDb25zX2xhenlfaW5mbyBsYXp5X2luZm8gLT5cbiAgICAgIChtYXRjaCBMYXp5LmZvcmNlIGxhenlfaW5mbyB3aXRoXG4gICAgICAgfCBpbmZvIC0+IGNvbXB1dGVfaW5mbyBpbmZvIHN0YWNrXG4gICAgICAgfCBleGNlcHRpb24gZXhuIC0+IGNvbXB1dGVfbWVzc2FnZSAoQ291bGRfbm90X2NvbnN0cnVjdCAoRXhuLnNleHBfb2ZfdCBleG4pKSBzdGFjaylcblxuICBhbmQgY29tcHV0ZV9tZXNzYWdlIG1lc3NhZ2Ugc3RhY2sgPVxuICAgIG1hdGNoIHN0YWNrIHdpdGhcbiAgICB8IFtdIC0+IG1lc3NhZ2VcbiAgICB8IEluX2luZm8gaW5mbyA6OiBzdGFjayAtPlxuICAgICAgaW5mby5zdGF0ZSA6PSBGaW5hbCBtZXNzYWdlO1xuICAgICAgY29tcHV0ZV9tZXNzYWdlIG1lc3NhZ2Ugc3RhY2tcbiAgICB8IEluX3RhZ19hcmcgKHRhZywgYXJnKSA6OiBzdGFjayAtPlxuICAgICAgY29tcHV0ZV9tZXNzYWdlIChUYWdfYXJnICh0YWcsIGFyZywgbWVzc2FnZSkpIHN0YWNrXG4gICAgfCBJbl90YWdfdCB0YWcgOjogc3RhY2sgLT4gY29tcHV0ZV9tZXNzYWdlIChUYWdfdCAodGFnLCBtZXNzYWdlKSkgc3RhY2tcbiAgICB8IEluX2xpc3QgeyBmd2RfcHJlZml4OyByZXZfc3VmZml4IH0gOjogc3RhY2sgLT5cbiAgICAgIGNvbXB1dGVfaW5mb19saXN0IH5md2RfcHJlZml4IH5yZXZfc3VmZml4OihtZXNzYWdlIDo6IHJldl9zdWZmaXgpIHN0YWNrXG4gIDs7XG5cbiAgKCogSGVscGVyIGZ1bmN0aW9ucyBmb3IgY29udmVydGluZyBhbmQgY29uc3RydWN0aW5nIFtpbmZvXS4gKilcblxuICBsZXQgdG9fbWVzc2FnZSBpbmZvID0gY29tcHV0ZV9pbmZvIGluZm8gW11cbiAgbGV0IG9mX21lc3NhZ2UgbWVzc2FnZSA9IHsgc3RhdGUgPSByZWYgKEZpbmFsIG1lc3NhZ2UpIH1cblxuICBsZXQgaXNfY29tcHV0ZWQgaW5mbyA9XG4gICAgbWF0Y2ggIShpbmZvLnN0YXRlKSB3aXRoXG4gICAgfCBJbml0aWFsIF8gfCBDb21wdXRpbmcgLT4gZmFsc2VcbiAgICB8IEZpbmFsIF8gLT4gdHJ1ZVxuICA7O1xuXG4gIGxldCBvZl9jb25zIGNvbnMgPSB7IHN0YXRlID0gcmVmIChJbml0aWFsIGNvbnMpIH1cbiAgbGV0IG9mX2xhenlfaW5mbyBsYXp5X2luZm8gPSBvZl9jb25zIChDb25zX2xhenlfaW5mbyBsYXp5X2luZm8pXG5cbiAgbGV0IG9mX2xhenlfY29ucyBsYXp5X2NvbnMgPVxuICAgIG9mX2NvbnMgKENvbnNfbGF6eV9pbmZvIChsYXp5IChvZl9jb25zIChMYXp5LmZvcmNlIGxhenlfY29ucykpKSlcbiAgOztcblxuICBsZXQgb2ZfbGF6eV9tZXNzYWdlIGxhenlfbWVzc2FnZSA9XG4gICAgb2ZfY29ucyAoQ29uc19sYXp5X2luZm8gKGxhenkgKG9mX21lc3NhZ2UgKExhenkuZm9yY2UgbGF6eV9tZXNzYWdlKSkpKVxuICA7O1xuZW5kXG5cbm9wZW4gQ29tcHV0ZWRcblxudHlwZSB0ID0gQ29tcHV0ZWQuaW5mb1xuXG5sZXQgZ2xvYmFsaXplID0gQ29tcHV0ZWQuZ2xvYmFsaXplX2luZm9cbmxldCBpbnZhcmlhbnQgXyA9ICgpXG5cbigqIEl0IGlzIE9LIHRvIHVzZSBbTWVzc2FnZS50b19zZXhwX2h1bV0sIHdoaWNoIGlzIG5vdCBzdGFibGUsIGJlY2F1c2UgW3Rfb2Zfc2V4cF0gYmVsb3dcbiAgIGNhbiBoYW5kbGUgYW55IHNleHAuICopXG5sZXQgc2V4cF9vZl90IHQgPSBNZXNzYWdlLnRvX3NleHBfaHVtICh0b19tZXNzYWdlIHQpXG5sZXQgdF9vZl9zZXhwIHNleHAgPSBvZl9tZXNzYWdlIChNZXNzYWdlLlNleHAgc2V4cClcbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHsgdW50eXBlZCA9IEFueSBcIkluZm8udFwiIH1cbmxldCBjb21wYXJlIHQxIHQyID0gU2V4cC5jb21wYXJlIChzZXhwX29mX3QgdDEpIChzZXhwX29mX3QgdDIpXG5sZXQgY29tcGFyZV9fbG9jYWwgdDEgdDIgPSBjb21wYXJlIChnbG9iYWxpemUgdDEpIChnbG9iYWxpemUgdDIpXG5sZXQgZXF1YWwgdDEgdDIgPSBTZXhwLmVxdWFsIChzZXhwX29mX3QgdDEpIChzZXhwX29mX3QgdDIpXG5sZXQgZXF1YWxfX2xvY2FsIHQxIHQyID0gZXF1YWwgKGdsb2JhbGl6ZSB0MSkgKGdsb2JhbGl6ZSB0MilcbmxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gU2V4cC5oYXNoX2ZvbGRfdCBzdGF0ZSAoc2V4cF9vZl90IHQpXG5sZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuXG5sZXQgdG9fc3RyaW5nX2h1bSB0ID1cbiAgbWF0Y2ggdG9fbWVzc2FnZSB0IHdpdGhcbiAgfCBTdHJpbmcgcyAtPiBzXG4gIHwgbWVzc2FnZSAtPiBTZXhwLnRvX3N0cmluZ19odW0gKE1lc3NhZ2UudG9fc2V4cF9odW0gbWVzc2FnZSlcbjs7XG5cbmxldCB0b19zdHJpbmdfbWFjaCB0ID0gU2V4cC50b19zdHJpbmdfbWFjaCAoc2V4cF9vZl90IHQpXG5sZXQgb2ZfbGF6eSBsID0gb2ZfbGF6eV9tZXNzYWdlIChsYXp5IChTdHJpbmcgKExhenkuZm9yY2UgbCkpKVxubGV0IG9mX2xhenlfc2V4cCBsID0gb2ZfbGF6eV9tZXNzYWdlIChsYXp5IChTZXhwIChMYXp5LmZvcmNlIGwpKSlcbmxldCBvZl9sYXp5X3QgbGF6eV90ID0gb2ZfbGF6eV9pbmZvIGxhenlfdFxubGV0IG9mX3N0cmluZyBtZXNzYWdlID0gb2ZfbWVzc2FnZSAoU3RyaW5nIG1lc3NhZ2UpXG5sZXQgY3JlYXRlZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgb2Zfc3RyaW5nIGZvcm1hdFxubGV0IG9mX3RodW5rIGYgPSBvZl9sYXp5X21lc3NhZ2UgKGxhenkgKFN0cmluZyAoZiAoKSkpKVxuXG5sZXQgY3JlYXRlID9oZXJlID9zdHJpY3QgdGFnIHggc2V4cF9vZl94ID1cbiAgbWF0Y2ggc3RyaWN0IHdpdGhcbiAgfCBOb25lIC0+IG9mX2xhenlfbWVzc2FnZSAobGF6eSAoVGFnX3NleHAgKHRhZywgc2V4cF9vZl94IHgsIGhlcmUpKSlcbiAgfCBTb21lICgpIC0+IG9mX21lc3NhZ2UgKFRhZ19zZXhwICh0YWcsIHNleHBfb2ZfeCB4LCBoZXJlKSlcbjs7XG5cbmxldCBjcmVhdGVfcyBzZXhwID0gb2ZfbWVzc2FnZSAoU2V4cCBzZXhwKVxubGV0IHRhZyB0IH50YWcgPSBvZl9jb25zIChDb25zX3RhZ190ICh0YWcsIHQpKVxubGV0IHRhZ19zX2xhenkgdCB+dGFnID0gb2ZfbGF6eV9jb25zIChsYXp5IChDb25zX3RhZ19hcmcgKFwiXCIsIExhenkuZm9yY2UgdGFnLCB0KSkpXG5sZXQgdGFnX3MgdCB+dGFnID0gb2ZfY29ucyAoQ29uc190YWdfYXJnIChcIlwiLCB0YWcsIHQpKVxubGV0IHRhZ19hcmcgdCB0YWcgeCBzZXhwX29mX3ggPSBvZl9sYXp5X2NvbnMgKGxhenkgKENvbnNfdGFnX2FyZyAodGFnLCBzZXhwX29mX3ggeCwgdCkpKVxubGV0IG9mX2xpc3QgdHMgPSBvZl9jb25zIChDb25zX2xpc3QgdHMpXG5cbmV4Y2VwdGlvbiBFeG4gb2YgdFxuXG5sZXQgKCkgPVxuICAoKiBXZSBpbnN0YWxsIGEgY3VzdG9tIGV4bi1jb252ZXJ0ZXIgcmF0aGVyIHRoYW4gdXNlXG4gICAgIFtleGNlcHRpb24gRXhuIG9mIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdIC4uLiBbQEBAZW5kXV0gdG8gZWxpbWluYXRlIHRoZSBleHRyYVxuICAgICB3cmFwcGluZyBvZiBcIihFeG4gLi4uKVwiLiAqKVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRXhuXSAoZnVuY3Rpb25cbiAgICB8IEV4biB0IC0+IHNleHBfb2ZfdCB0XG4gICAgfCBfIC0+XG4gICAgICAoKiBSZWFjaGluZyB0aGlzIGJyYW5jaCBpbmRpY2F0ZXMgYSBidWcgaW4gc2V4cGxpYi4gKilcbiAgICAgIGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCB0b19leG4gdCA9XG4gIGlmIG5vdCAoaXNfY29tcHV0ZWQgdClcbiAgdGhlbiBFeG4gdFxuICBlbHNlIChcbiAgICBtYXRjaCB0b19tZXNzYWdlIHQgd2l0aFxuICAgIHwgTWVzc2FnZS5FeG4gZXhuIC0+IGV4blxuICAgIHwgXyAtPiBFeG4gdClcbjs7XG5cbmxldCBvZl9leG4gP2JhY2t0cmFjZSBleG4gPVxuICBsZXQgYmFja3RyYWNlID1cbiAgICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGBHZXQgLT4gU29tZSAoU3RkbGliLlByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkpXG4gICAgfCBTb21lIChgVGhpcyBzKSAtPiBTb21lIHNcbiAgaW5cbiAgbWF0Y2ggZXhuLCBiYWNrdHJhY2Ugd2l0aFxuICB8IEV4biB0LCBOb25lIC0+IHRcbiAgfCBFeG4gdCwgU29tZSBiYWNrdHJhY2UgLT5cbiAgICBvZl9sYXp5X21lc3NhZ2UgKGxhenkgKFdpdGhfYmFja3RyYWNlICh0b19tZXNzYWdlIHQsIGJhY2t0cmFjZSkpKVxuICB8IF8sIE5vbmUgLT4gb2ZfbWVzc2FnZSAoTWVzc2FnZS5FeG4gZXhuKVxuICB8IF8sIFNvbWUgYmFja3RyYWNlIC0+XG4gICAgb2ZfbGF6eV9tZXNzYWdlIChsYXp5IChXaXRoX2JhY2t0cmFjZSAoU2V4cCAoRXhuLnNleHBfb2ZfdCBleG4pLCBiYWNrdHJhY2UpKSlcbjs7XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbmZvXCJcbiAgbGV0IHBwIHBwZiB0ID0gU3RkbGliLkZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmICh0b19zdHJpbmdfaHVtIHQpXG5lbmQpXG5cbm1vZHVsZSBJbnRlcm5hbF9yZXByID0gc3RydWN0XG4gIGluY2x1ZGUgTWVzc2FnZVxuXG4gIGxldCB0b19pbmZvID0gb2ZfbWVzc2FnZVxuICBsZXQgb2ZfaW5mbyA9IHRvX21lc3NhZ2VcbmVuZFxuIiwiKCogVGhpcyBtb2R1bGUgaXMgdHJ5aW5nIHRvIG1pbmltaXplIGRlcGVuZGVuY2llcyBvbiBtb2R1bGVzIGluIENvcmUsIHNvIGFzIHRvIGFsbG93XG4gICBbRXJyb3JdIGFuZCBbT3JfZXJyb3JdIHRvIGJlIHVzZWQgaW4gdmFyaW91cyBwbGFjZXMuICBQbGVhc2UgYXZvaWQgYWRkaW5nIG5ld1xuICAgZGVwZW5kZW5jaWVzLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW5mb1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQW55IFwiRXJyb3IudFwiIH1cbmxldFtAY29sZF0gcmFpc2UgdCA9IHJhaXNlICh0b19leG4gdClcbmxldFtAY29sZF0gcmFpc2VfcyBzZXhwID0gcmFpc2UgKGNyZWF0ZV9zIHNleHApXG5sZXQgdG9faW5mbyB0ID0gdFxubGV0IG9mX2luZm8gdCA9IHRcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkVycm9yXCJcbiAgbGV0IHBwID0gcHBcbmVuZClcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnZhcmlhbnRfaW50ZlxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubGV0IGludmFyaWFudCBoZXJlIHQgc2V4cF9vZl90IGYgOiB1bml0ID1cbiAgdHJ5IGYgKCkgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiaW52YXJpYW50IGZhaWxlZFwiXG4gICAgICAgICBbIFwiXCIsIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgaGVyZVxuICAgICAgICAgOyBcImV4blwiLCBzZXhwX29mX2V4biBleG5cbiAgICAgICAgIDsgXCJcIiwgc2V4cF9vZl90IHRcbiAgICAgICAgIF0pXG47O1xuXG5sZXQgY2hlY2tfZmllbGQgdCBmIGZpZWxkID1cbiAgdHJ5IGYgKEZpZWxkLmdldCBmaWVsZCB0KSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJwcm9ibGVtIHdpdGggZmllbGRcIlxuICAgICAgICAgWyBcImZpZWxkXCIsIHNleHBfb2Zfc3RyaW5nIChGaWVsZC5uYW1lIGZpZWxkKTsgXCJleG5cIiwgc2V4cF9vZl9leG4gZXhuIF0pXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdCA9ICgnYSwgRXJyb3IudCkgUmVzdWx0LnRcbltAQGRlcml2aW5nX2lubGluZVxuICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmVfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICBmdW4gX2NtcF9fYSBhX18wMDdfIGJfXzAwOF8gLT5cbiAgUmVzdWx0LmNvbXBhcmVfX2xvY2FsIF9jbXBfX2EgRXJyb3IuY29tcGFyZV9fbG9jYWwgYV9fMDA3XyBiX18wMDhfXG47O1xuXG5sZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgZnVuIF9jbXBfX2EgYV9fMDAxXyBiX18wMDJfIC0+IFJlc3VsdC5jb21wYXJlIF9jbXBfX2EgRXJyb3IuY29tcGFyZSBhX18wMDFfIGJfXzAwMl9cbjs7XG5cbmxldCBlcXVhbF9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID1cbiAgZnVuIF9jbXBfX2EgYV9fMDE5XyBiX18wMjBfIC0+XG4gIFJlc3VsdC5lcXVhbF9fbG9jYWwgX2NtcF9fYSBFcnJvci5lcXVhbF9fbG9jYWwgYV9fMDE5XyBiX18wMjBfXG47O1xuXG5sZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID1cbiAgZnVuIF9jbXBfX2EgYV9fMDEzXyBiX18wMTRfIC0+IFJlc3VsdC5lcXVhbCBfY21wX19hIEVycm9yLmVxdWFsIGFfXzAxM18gYl9fMDE0X1xuOztcblxubGV0IGdsb2JhbGl6ZSA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIHQgLT4gJ2EgdCA9XG4gIGZ1biAodHlwZSBhX18wMjVfKSA6ICgoYV9fMDI1XyAtPiBhX18wMjVfKSAtPiBhX18wMjVfIHQgLT4gYV9fMDI1XyB0KSAtPlxuICBmdW4gX2dsb2JhbGl6ZV9hX18wMjZfIHhfXzAyN18gLT5cbiAgUmVzdWx0Lmdsb2JhbGl6ZSBfZ2xvYmFsaXplX2FfXzAyNl8gRXJyb3IuZ2xvYmFsaXplIHhfXzAyN19cbjs7XG5cbmxldCBoYXNoX2ZvbGRfdCA6XG4gICAgICAnYS5cbiAgICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgICAtPiAnYSB0XG4gICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgPVxuICBmdW4gX2hhc2hfZm9sZF9hIGhzdiBhcmcgLT4gUmVzdWx0Lmhhc2hfZm9sZF90IF9oYXNoX2ZvbGRfYSBFcnJvci5oYXNoX2ZvbGRfdCBoc3YgYXJnXG47O1xuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgZnVuIF9vZl9hX18wMzBfIHhfXzAzMl8gLT4gUmVzdWx0LnRfb2Zfc2V4cCBfb2ZfYV9fMDMwXyBFcnJvci50X29mX3NleHAgeF9fMDMyX1xuOztcblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDMzXyB4X18wMzRfIC0+IFJlc3VsdC5zZXhwX29mX3QgX29mX2FfXzAzM18gRXJyb3Iuc2V4cF9vZl90IHhfXzAzNF9cbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gUmVzdWx0LnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXIgRXJyb3IudF9zZXhwX2dyYW1tYXJcbjs7XG5cbltAQEBlbmRdXG5cbmxldCAoID4+PSApID0gUmVzdWx0LiggPj49IClcbmxldCAoID4+fCApID0gUmVzdWx0LiggPj58IClcbmxldCBiaW5kID0gUmVzdWx0LmJpbmRcbmxldCBpZ25vcmVfbSA9IFJlc3VsdC5pZ25vcmVfbVxubGV0IGpvaW4gPSBSZXN1bHQuam9pblxubGV0IG1hcCA9IFJlc3VsdC5tYXBcbmxldCByZXR1cm4gPSBSZXN1bHQucmV0dXJuXG5cbm1vZHVsZSBNb25hZF9pbmZpeCA9IFJlc3VsdC5Nb25hZF9pbmZpeFxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBhIC0+IGludmFyaWFudF9hIGFcbiAgfCBFcnJvciBlcnJvciAtPiBFcnJvci5pbnZhcmlhbnQgZXJyb3Jcbjs7XG5cbmxldCBtYXAyIGEgYiB+ZiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IE9rIHgsIE9rIHkgLT4gT2sgKGYgeCB5KVxuICB8IE9rIF8sIChFcnJvciBfIGFzIGUpIHwgKEVycm9yIF8gYXMgZSksIE9rIF8gLT4gZVxuICB8IEVycm9yIGUxLCBFcnJvciBlMiAtPiBFcnJvciAoRXJyb3Iub2ZfbGlzdCBbIGUxOyBlMiBdKVxuOztcblxubW9kdWxlIEZvcl9hcHBsaWNhdGl2ZSA9IEFwcGxpY2F0aXZlLk1ha2VfdXNpbmdfbWFwMl9sb2NhbCAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IHJldHVybiA9IHJldHVyblxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgbGV0IG1hcDIgPSBtYXAyXG5lbmQpXG5cbmxldCAoICo+ICkgPSBGb3JfYXBwbGljYXRpdmUuKCAqPiApXG5sZXQgKCA8KiApID0gRm9yX2FwcGxpY2F0aXZlLiggPCogKVxubGV0ICggPCo+ICkgPSBGb3JfYXBwbGljYXRpdmUuKCA8Kj4gKVxubGV0IGFwcGx5ID0gRm9yX2FwcGxpY2F0aXZlLmFwcGx5XG5sZXQgYm90aCA9IEZvcl9hcHBsaWNhdGl2ZS5ib3RoXG5sZXQgbWFwMyA9IEZvcl9hcHBsaWNhdGl2ZS5tYXAzXG5cbm1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IEZvcl9hcHBsaWNhdGl2ZS5BcHBsaWNhdGl2ZV9pbmZpeFxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgPSBtYXBcbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgICgqIGZyb20gQXBwbGljYXRpdmUuTWFrZSAqKVxuICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgZW5kXG5lbmRcblxubGV0IG9rID0gUmVzdWx0Lm9rXG5sZXQgaXNfb2sgPSBSZXN1bHQuaXNfb2tcbmxldCBpc19lcnJvciA9IFJlc3VsdC5pc19lcnJvclxuXG5sZXQgdHJ5X3dpdGggPyhiYWNrdHJhY2UgPSBmYWxzZSkgZiA9XG4gIHRyeSBPayAoZiAoKSkgd2l0aFxuICB8IGV4biAtPiBFcnJvciAoRXJyb3Iub2ZfZXhuIGV4biA/YmFja3RyYWNlOihpZiBiYWNrdHJhY2UgdGhlbiBTb21lIGBHZXQgZWxzZSBOb25lKSlcbjs7XG5cbmxldCB0cnlfd2l0aF9qb2luID9iYWNrdHJhY2UgZiA9IGpvaW4gKHRyeV93aXRoID9iYWNrdHJhY2UgZilcblxubGV0IG9rX2V4biA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3IgZXJyIC0+IEVycm9yLnJhaXNlIGVyclxuOztcblxubGV0IG9mX2V4biA/YmFja3RyYWNlIGV4biA9IEVycm9yIChFcnJvci5vZl9leG4gP2JhY2t0cmFjZSBleG4pXG5cbmxldCBvZl9leG5fcmVzdWx0ID9iYWNrdHJhY2UgPSBmdW5jdGlvblxuICB8IE9rIF8gYXMgeiAtPiB6XG4gIHwgRXJyb3IgZXhuIC0+IG9mX2V4biA/YmFja3RyYWNlIGV4blxuOztcblxubGV0IG9mX29wdGlvbiA9IFJlc3VsdC5vZl9vcHRpb25cblxubGV0IGVycm9yID9oZXJlID9zdHJpY3QgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIEVycm9yIChFcnJvci5jcmVhdGUgP2hlcmUgP3N0cmljdCBtZXNzYWdlIGEgc2V4cF9vZl9hKVxuOztcblxubGV0IGVycm9yX3Mgc2V4cCA9IEVycm9yIChFcnJvci5jcmVhdGVfcyBzZXhwKVxubGV0IGVycm9yX3N0cmluZyBtZXNzYWdlID0gRXJyb3IgKEVycm9yLm9mX3N0cmluZyBtZXNzYWdlKVxubGV0IGVycm9yZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgZXJyb3Jfc3RyaW5nIGZvcm1hdFxubGV0IHRhZyB0IH50YWcgPSBSZXN1bHQubWFwX2Vycm9yIHQgfmY6KEVycm9yLnRhZyB+dGFnKVxubGV0IHRhZ19zIHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnX3MgfnRhZylcbmxldCB0YWdfc19sYXp5IHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnX3NfbGF6eSB+dGFnKVxuXG5sZXQgdGFnX2FyZyB0IG1lc3NhZ2UgYSBzZXhwX29mX2EgPVxuICBSZXN1bHQubWFwX2Vycm9yIHQgfmY6KGZ1biBlIC0+IEVycm9yLnRhZ19hcmcgZSBtZXNzYWdlIGEgc2V4cF9vZl9hKVxuOztcblxubGV0IHVuaW1wbGVtZW50ZWQgcyA9IGVycm9yIFwidW5pbXBsZW1lbnRlZFwiIHMgc2V4cF9vZl9zdHJpbmdcblxubGV0IGNvbWJpbmVfaW50ZXJuYWwgbGlzdCB+b25fb2sgfm9uX2Vycm9yID1cbiAgbWF0Y2ggUmVzdWx0LmNvbWJpbmVfZXJyb3JzIGxpc3Qgd2l0aFxuICB8IE9rIHggLT4gT2sgKG9uX29rIHgpXG4gIHwgRXJyb3IgZXJycyAtPiBFcnJvciAob25fZXJyb3IgZXJycylcbjs7XG5cbmxldCBpZ25vcmVfdW5pdF9saXN0IChfIDogdW5pdCBsaXN0KSA9ICgpXG5cbmxldCBlcnJvcl9vZl9saXN0X2lmX25lY2Vzc2FyeSA9IGZ1bmN0aW9uXG4gIHwgWyBlIF0gLT4gZVxuICB8IGxpc3QgLT4gRXJyb3Iub2ZfbGlzdCBsaXN0XG47O1xuXG5sZXQgYWxsIGxpc3QgPSBjb21iaW5lX2ludGVybmFsIGxpc3Qgfm9uX29rOkZuLmlkIH5vbl9lcnJvcjplcnJvcl9vZl9saXN0X2lmX25lY2Vzc2FyeVxuXG5sZXQgYWxsX3VuaXQgbGlzdCA9XG4gIGNvbWJpbmVfaW50ZXJuYWwgbGlzdCB+b25fb2s6aWdub3JlX3VuaXRfbGlzdCB+b25fZXJyb3I6ZXJyb3Jfb2ZfbGlzdF9pZl9uZWNlc3Nhcnlcbjs7XG5cbmxldCBjb21iaW5lX2Vycm9ycyBsaXN0ID0gY29tYmluZV9pbnRlcm5hbCBsaXN0IH5vbl9vazpGbi5pZCB+b25fZXJyb3I6RXJyb3Iub2ZfbGlzdFxuXG5sZXQgY29tYmluZV9lcnJvcnNfdW5pdCBsaXN0ID1cbiAgY29tYmluZV9pbnRlcm5hbCBsaXN0IH5vbl9vazppZ25vcmVfdW5pdF9saXN0IH5vbl9lcnJvcjpFcnJvci5vZl9saXN0XG47O1xuXG5sZXQgZmlsdGVyX29rX2F0X2xlYXN0X29uZSBsID1cbiAgbGV0IG9rLCBlcnJzID0gTGlzdC5wYXJ0aXRpb25fbWFwIGwgfmY6UmVzdWx0LnRvX2VpdGhlciBpblxuICBtYXRjaCBvayB3aXRoXG4gIHwgW10gLT4gRXJyb3IgKEVycm9yLm9mX2xpc3QgZXJycylcbiAgfCBfIC0+IE9rIG9rXG47O1xuXG5sZXQgZmluZF9vayBsID1cbiAgbWF0Y2ggTGlzdC5maW5kX21hcCBsIH5mOlJlc3VsdC5vayB3aXRoXG4gIHwgU29tZSB4IC0+IE9rIHhcbiAgfCBOb25lIC0+XG4gICAgRXJyb3JcbiAgICAgIChFcnJvci5vZl9saXN0XG4gICAgICAgICAoTGlzdC5tYXAgbCB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgfCBPayBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICB8IEVycm9yIGVyciAtPiBlcnIpKSlcbjs7XG5cbmxldCBmaW5kX21hcF9vayBsIH5mID1cbiAgV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgRXJyb3JcbiAgICAgIChFcnJvci5vZl9saXN0XG4gICAgICAgICAoTGlzdC5tYXAgbCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICAgICAgbWF0Y2ggZiBlbHQgd2l0aFxuICAgICAgICAgICAgfCBPayBfIGFzIHggLT4gcmV0dXJuIHhcbiAgICAgICAgICAgIHwgRXJyb3IgZXJyIC0+IGVycikpKSkgW0Bub250YWlsXVxuOztcblxubGV0IG1hcCA9IFJlc3VsdC5tYXBcbmxldCBpdGVyID0gUmVzdWx0Lml0ZXJcbmxldCBpdGVyX2Vycm9yID0gUmVzdWx0Lml0ZXJfZXJyb3JcbiIsIigqIFRoaXMgaXMgYnJva2VuIG9mZiB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gU2lnbiBhbmQgQ29tcGFyYWJsZS4gKilcblxub3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTmVnXG4gIHwgWmVyb1xuICB8IFBvc1xuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSB+bG9jYWxpemUsIGhhc2gsIGVudW1lcmF0ZV1cblxubGV0IHRfb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMDNfID0gXCJzaWduMC5tbC50XCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIC0+IE5lZ1xuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIC0+IFplcm9cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgLT4gUG9zXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDAyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBzZXhwX18wMDJfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuOztcblxubGV0IHNleHBfb2ZfdCA9XG4gIChmdW5jdGlvblxuICAgfCBOZWcgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmVnXCJcbiAgIHwgWmVybyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJaZXJvXCJcbiAgIHwgUG9zIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlBvc1wiXG4gICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTmVnXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJQb3NcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmVfX2xvY2FsID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcbmxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxubGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50XG4gICAgICAgaHN2XG4gICAgICAgKG1hdGNoIGFyZyB3aXRoXG4gICAgICAgIHwgTmVnIC0+IDBcbiAgICAgICAgfCBaZXJvIC0+IDFcbiAgICAgICAgfCBQb3MgLT4gMilcbiAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbjs7XG5cbmxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxubGV0IGFsbCA9IChbIE5lZzsgWmVybzsgUG9zIF0gOiB0IGxpc3QpXG5cbltAQEBlbmRdXG5cbm1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogdCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiB0KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiB0KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IHQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiB0KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IHQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IHQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiB0KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IHQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IHQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogdCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IHQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbmxldCB0b19zdHJpbmcgdCA9IHN0cmluZ19vZl9zZXhwIChzZXhwX29mX3QgdClcblxubGV0IHRvX2ludCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IC0xXG4gIHwgWmVybyAtPiAwXG4gIHwgUG9zIC0+IDFcbjs7XG5cbmxldCBfID0gaGFzaFxuXG4oKiBJZ25vcmUgdGhlIGhhc2ggZnVuY3Rpb24gcHJvZHVjZWQgYnkgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2hdICopXG5sZXQgaGFzaCA9IHRvX2ludFxubGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlNpZ25cIlxubGV0IG9mX2ludCBuID0gaWYgbiA8IDAgdGhlbiBOZWcgZWxzZSBpZiBuID0gMCB0aGVuIFplcm8gZWxzZSBQb3NcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBDb21wYXJhYmxlX2ludGZcblxubW9kdWxlIFdpdGhfemVybyAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICBbQEBAZW5kXVxuXG4gIHZhbCB6ZXJvIDogdFxuZW5kKSA9XG5zdHJ1Y3RcbiAgb3BlbiBUXG5cbiAgbGV0IGlzX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA+IDBcbiAgbGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPj0gMFxuICBsZXQgaXNfbmVnYXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvIDwgMFxuICBsZXQgaXNfbm9uX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA8PSAwXG4gIGxldCBzaWduIHQgPSBTaWduMC5vZl9pbnQgKGNvbXBhcmUgdCB6ZXJvKVxuZW5kXG5cbm1vZHVsZSBQb2x5IChUIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFQudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIGxldCBzZXhwX29mX3QgPSAoVC5zZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIFBvbHlcbiAgZW5kXG5cbiAgaW5jbHVkZSBQb2x5XG5cbiAgbGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG4gIGxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbiAgbGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbiAgOztcblxuICBsZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heFxuICAgIHRoZW5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIDs7XG5cbiAgbW9kdWxlIEMgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlKVxuICBlbmRcblxuICBpbmNsdWRlIENcbmVuZFxuXG5sZXQgZ3QgY21wIGEgYiA9IGNtcCBhIGIgPiAwXG5sZXQgbHQgY21wIGEgYiA9IGNtcCBhIGIgPCAwXG5sZXQgZ2VxIGNtcCBhIGIgPSBjbXAgYSBiID49IDBcbmxldCBsZXEgY21wIGEgYiA9IGNtcCBhIGIgPD0gMFxubGV0IGVxdWFsIGNtcCBhIGIgPSBjbXAgYSBiID0gMFxubGV0IG5vdF9lcXVhbCBjbXAgYSBiID0gY21wIGEgYiA8PiAwXG5sZXQgbWluIGNtcCB0IHQnID0gaWYgbGVxIGNtcCB0IHQnIHRoZW4gdCBlbHNlIHQnXG5sZXQgbWF4IGNtcCB0IHQnID0gaWYgZ2VxIGNtcCB0IHQnIHRoZW4gdCBlbHNlIHQnXG5cbm1vZHVsZSBJbmZpeCAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICBbQEBAZW5kXVxuZW5kKSA6IEluZml4IHdpdGggdHlwZSB0IDo9IFQudCA9IHN0cnVjdFxuICBsZXQgKCA+ICkgYSBiID0gZ3QgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA8ICkgYSBiID0gbHQgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA+PSApIGEgYiA9IGdlcSBULmNvbXBhcmUgYSBiXG4gIGxldCAoIDw9ICkgYSBiID0gbGVxIFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPSApIGEgYiA9IGVxdWFsIFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPD4gKSBhIGIgPSBub3RfZXF1YWwgVC5jb21wYXJlIGEgYlxuZW5kXG5bQEBpbmxpbmUgYWx3YXlzXVxuXG5tb2R1bGUgQ29tcGFyaXNvbnMgKFQgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgW0BAQGVuZF1cbmVuZCkgOiBDb21wYXJpc29ucyB3aXRoIHR5cGUgdCA6PSBULnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbmZpeCAoVClcblxuICBsZXQgY29tcGFyZSA9IFQuY29tcGFyZVxuICBsZXQgZXF1YWwgPSAoID0gKVxuICBsZXQgbWluIHQgdCcgPSBtaW4gY29tcGFyZSB0IHQnXG4gIGxldCBtYXggdCB0JyA9IG1heCBjb21wYXJlIHQgdCdcbmVuZFxuW0BAaW5saW5lIGFsd2F5c11cblxubW9kdWxlIE1ha2VfdXNpbmdfY29tcGFyYXRvciAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmQpIDogUyB3aXRoIHR5cGUgdCA6PSBULnQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gVC5jb21wYXJhdG9yX3dpdG5lc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBjb21wYXJlID0gY29tcGFyYXRvci5jb21wYXJlXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBtb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gQ29tcGFyaXNvbnMgKFQpXG4gIGluY2x1ZGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IGFzY2VuZGluZyA9IGNvbXBhcmVcbiAgbGV0IGRlc2NlbmRpbmcgdCB0JyA9IGNvbXBhcmUgdCcgdFxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kKSA9XG5NYWtlX3VzaW5nX2NvbXBhcmF0b3IgW0BpbmxpbmVkIGhpbnRdIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuZW5kKVxuXG5tb2R1bGUgSW5oZXJpdCAoQyA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICBbQEBAZW5kXVxuZW5kKSAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cblxuICB2YWwgY29tcG9uZW50IDogdCAtPiBDLnRcbmVuZCkgPVxuTWFrZSAoc3RydWN0XG4gIHR5cGUgdCA9IFQudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgc2V4cF9vZl90ID0gKFQuc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgY29tcGFyZSB0IHQnID0gQy5jb21wYXJlIChULmNvbXBvbmVudCB0KSAoVC5jb21wb25lbnQgdCcpXG5lbmQpXG5cbigqIGNvbXBhcmUgW3hdIGFuZCBbeV0gbGV4aWNvZ3JhcGhpY2FsbHkgdXNpbmcgZnVuY3Rpb25zIGluIHRoZSBsaXN0IFtjbXBzXSAqKVxubGV0IGxleGljb2dyYXBoaWMgY21wcyB4IHkgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgY21wIDo6IGNtcHMgLT5cbiAgICAgIGxldCByZXMgPSBjbXAgeCB5IGluXG4gICAgICBpZiByZXMgPSAwIHRoZW4gbG9vcCBjbXBzIGVsc2UgcmVzXG4gICAgfCBbXSAtPiAwXG4gIGluXG4gIGxvb3AgY21wc1xuOztcblxubGV0IGxpZnQgY21wIH5mIHggeSA9IGNtcCAoZiB4KSAoZiB5KVxubGV0IHJldmVyc2UgY21wIHggeSA9IGNtcCB5IHhcblxudHlwZSAnYSByZXZlcnNlZCA9ICdhXG5cbmxldCBjb21wYXJlX3JldmVyc2VkIGNtcCB4IHkgPSBjbXAgeSB4XG4iLCJvcGVuISBJbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoYWJsZS5LZXkgKilcbm1vZHVsZSB0eXBlIEtleSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuXG4gICgqKiBWYWx1ZXMgcmV0dXJuZWQgYnkgW2hhc2hdIG11c3QgYmUgbm9uLW5lZ2F0aXZlLiAgQW4gZXhjZXB0aW9uIHdpbGwgYmUgcmFpc2VkIGluIHRoZVxuICAgICAgY2FzZSB0aGF0IFtoYXNoXSByZXR1cm5zIGEgbmVnYXRpdmUgdmFsdWUuICopXG4gIHZhbCBoYXNoIDogdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgSGFzaGFibGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IGhhc2ggOiAnYSAtPiBpbnRcbiAgICA7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgICA7IHNleHBfb2ZfdCA6ICdhIC0+IFNleHAudFxuICAgIH1cblxuICAoKiogVGhpcyBmdW5jdGlvbiBpcyBzb3VuZCBidXQgbm90IGNvbXBsZXRlLCBtZWFuaW5nIHRoYXQgaWYgaXQgcmV0dXJucyBbdHJ1ZV0gdGhlbiBpdCdzXG4gICAgICBzYWZlIHRvIHVzZSB0aGUgdHdvIGludGVyY2hhbmdlYWJseS4gIElmIGl0J3MgW2ZhbHNlXSwgeW91IGhhdmUgbm8gZ3VhcmFudGVlcy4gIEZvclxuICAgICAgZXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgPiB1dG9wXG4gICAgICAgIG9wZW4gQ29yZTs7XG4gICAgICAgIGxldCBlcXVhbCAoYSA6ICdhIEhhc2h0YmxfaW50Zi5IYXNoYWJsZS50KSBiID1cbiAgICAgICAgICBwaHlzX2VxdWFsIGEgYlxuICAgICAgICAgIHx8IChwaHlzX2VxdWFsIGEuaGFzaCBiLmhhc2hcbiAgICAgICAgICAgICAgJiYgcGh5c19lcXVhbCBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgICAgICAgICAgICYmIHBoeXNfZXF1YWwgYS5zZXhwX29mX3QgYi5zZXhwX29mX3QpXG4gICAgICAgIDs7XG4gICAgICAgIGxldCBhID0gSGFzaHRibF9pbnRmLkhhc2hhYmxlLnsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90ID0gSW50LnNleHBfb2ZfdCB9OztcbiAgICAgICAgbGV0IGIgPSBIYXNodGJsX2ludGYuSGFzaGFibGUueyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgPSBJbnQuc2V4cF9vZl90IH07O1xuICAgICAgICBlcXVhbCBhIGI7OyAgKCogZmFsc2U/ISAqKVxuICAgICAgXX1cbiAgKilcbiAgbGV0IGVxdWFsIGEgYiA9XG4gICAgcGh5c19lcXVhbCBhIGJcbiAgICB8fCAocGh5c19lcXVhbCBhLmhhc2ggYi5oYXNoXG4gICAgICAgICYmIHBoeXNfZXF1YWwgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgICAgICAmJiBwaHlzX2VxdWFsIGEuc2V4cF9vZl90IGIuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBoYXNoX3BhcmFtID0gU3RkbGliLkhhc2h0YmwuaGFzaF9wYXJhbVxuICBsZXQgaGFzaCA9IFN0ZGxpYi5IYXNodGJsLmhhc2hcbiAgbGV0IHBvbHkgPSB7IGhhc2g7IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmU7IHNleHBfb2ZfdCA9IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIH1cblxuICBsZXQgb2Zfa2V5ICh0eXBlIGEpIChtb2R1bGUgS2V5IDogS2V5IHdpdGggdHlwZSB0ID0gYSkgPVxuICAgIHsgaGFzaCA9IEtleS5oYXNoOyBjb21wYXJlID0gS2V5LmNvbXBhcmU7IHNleHBfb2ZfdCA9IEtleS5zZXhwX29mX3QgfVxuICA7O1xuXG4gIGxldCB0b19rZXkgKHR5cGUgYSkgeyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfSA9XG4gICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IGFcblxuICAgICAgbGV0IGhhc2ggPSBoYXNoXG4gICAgICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbiAgICAgIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgICBlbmQgOiBLZXlcbiAgICAgIHdpdGggdHlwZSB0ID0gYSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIEhhc2hhYmxlXG5cbm1vZHVsZSB0eXBlIEhhc2hhYmxlID0gc2lnXG4gIHR5cGUgJ2EgdCA9ICdhIEhhc2hhYmxlLnQgPVxuICAgIHsgaGFzaCA6ICdhIC0+IGludFxuICAgIDsgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludFxuICAgIDsgc2V4cF9vZl90IDogJ2EgLT4gU2V4cC50XG4gICAgfVxuXG4gIHZhbCBlcXVhbCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gIHZhbCBwb2x5IDogJ2EgdFxuICB2YWwgb2Zfa2V5IDogKG1vZHVsZSBLZXkgd2l0aCB0eXBlIHQgPSAnYSkgLT4gJ2EgdFxuICB2YWwgdG9fa2V5IDogJ2EgdCAtPiAobW9kdWxlIEtleSB3aXRoIHR5cGUgdCA9ICdhKVxuICB2YWwgaGFzaF9wYXJhbSA6IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50XG4gIHZhbCBoYXNoIDogJ2EgLT4gaW50XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJZGVudGlmaWFibGVfaW50ZlxuXG5tb2R1bGUgTWFrZSAoVCA6IEFyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuICBpbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChUKVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuXG5tb2R1bGUgTWFrZV91c2luZ19jb21wYXJhdG9yIChUIDogQXJnX3dpdGhfY29tcGFyYXRvcikgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlX3VzaW5nX2NvbXBhcmF0b3IgKFQpXG4gIGluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKFQpXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gdW5pdCBbQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgYWxsID0gKFsgKCkgXSA6IHQgbGlzdClcbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV91bml0IDogdCAtPiB0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfdW5pdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfdW5pdCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAodW5pdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl91bml0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHVuaXRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgY29tcGFyZSBfIF8gPSAwXG4gIGxldCBjb21wYXJlX19sb2NhbCBfIF8gPSAwXG4gIGxldCBlcXVhbF9fbG9jYWwgXyBfID0gdHJ1ZVxuXG4gIGxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgXCIoKVwiIC0+ICgpXG4gICAgfCBfIC0+IGZhaWx3aXRoIFwiQmFzZS5Vbml0Lm9mX3N0cmluZzogKCkgZXhwZWN0ZWRcIlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVuaXRcIlxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoVClcblxubGV0IGludmFyaWFudCAoKSA9ICgpXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjBcblxubGV0IGdldF9wb3NfbGVuID9wb3MgP2xlbiAoKSB+dG90YWxfbGVuZ3RoID1cbiAgdHJ5IFJlc3VsdC5PayAoZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoKSB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBzIC0+IEVycm9yIChFcnJvci5vZl9zdHJpbmcgcylcbjs7XG4iLCJvcGVuISBJbXBvcnRcbm9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4oKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IGEgc2VhcmNoIGZvciB0aGUgZmlyc3QgKHJlc3AuIGxhc3QpIGVsZW1lbnRcbiAgIHNhdGlzZnlpbmcgYSBwcmVkaWNhdGUsIGFzc3VtaW5nIHRoYXQgdGhlIHByZWRpY2F0ZSBpcyBpbmNyZWFzaW5nIG9uXG4gICB0aGUgY29udGFpbmVyLCBtZWFuaW5nIHRoYXQsIGlmIHRoZSBjb250YWluZXIgaXMgW3UxLi4udW5dLCB0aGVyZSBleGlzdHMgYVxuICAgayBzdWNoIHRoYXQgcCh1MSk9Li4uLj1wKHVrKSA9IGZhbHNlIGFuZCBwKHVrKzEpPS4uLi49cCh1bik9IHRydWUuXG4gICBJZiB0aGlzIGsgPSAxIChyZXNwIG4pLCBmaW5kX2xhc3Rfbm90X3NhdGlzZnlpbmcgKHJlc3AgZmluZF9maXJzdF9zYXRpc2Z5aW5nKVxuICAgd2lsbCByZXR1cm4gTm9uZS4gKilcblxubGV0IHJlYyBsaW5lYXJfc2VhcmNoX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWQgPVxuICBpZiBsbyA+IGhpXG4gIHRoZW4gTm9uZVxuICBlbHNlIGlmIHByZWQgKGdldCB0IGxvKVxuICB0aGVuIFNvbWUgbG9cbiAgZWxzZSBsaW5lYXJfc2VhcmNoX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbzoobG8gKyAxKSB+aGkgfnByZWRcbjs7XG5cbigqIFRha2VzIGEgY29udGFpbmVyIFt0XSwgYSBwcmVkaWNhdGUgW3ByZWRdIGFuZCB0d28gaW5kaWNlcyBbbG8gPCBoaV0sIHN1Y2ggdGhhdFxuICAgW3ByZWRdIGlzIGluY3JlYXNpbmcgb24gW3RdIGJldHdlZW4gW2xvXSBhbmQgW2hpXS5cblxuICAgcmV0dXJuIGEgcmFuZ2UgKGxvLCBoaSkgd2hlcmU6XG4gICAtIGxvIGFuZCBoaSBhcmUgY2xvc2UgZW5vdWdoIHRvZ2V0aGVyIGZvciBhIGxpbmVhciBzZWFyY2hcbiAgIC0gSWYgW3ByZWRdIGlzIG5vdCBjb25zdGFudGx5IFtmYWxzZV0gb24gW3RdIGJldHdlZW4gW2xvXSBhbmQgW2hpXSwgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgb24gd2hpY2ggW3ByZWRdIGlzIFt0cnVlXSBpcyBiZXR3ZWVuIFtsb10gYW5kIFtoaV0uICopXG4oKiBJbnZhcmlhbnQ6IHRoZSBmaXJzdCBlbGVtZW50IHNhdGlzZnlpbmcgW3ByZWRdLCBpZiBpdCBleGlzdHMgaXMgYmV0d2VlbiBbbG9dIGFuZCBbaGldICopXG5sZXQgcmVjIGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkID1cbiAgKCogV2FybmluZzogdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCB0ZXJtaW5hdGUgaWYgdGhlIGNvbnN0YW50IChjdXJyZW50bHkgOCkgaXNcbiAgICAgc2V0IDw9IDEgKilcbiAgaWYgaGkgLSBsbyA8PSA4XG4gIHRoZW4gbG8sIGhpXG4gIGVsc2UgKFxuICAgIGxldCBtaWQgPSBsbyArICgoaGkgLSBsbykgLyAyKSBpblxuICAgIGlmIHByZWQgKGdldCB0IG1pZClcbiAgICAgICAoKiBJTlZBUklBTlQgY2hlY2s6IGl0IG1lYW5zIHRoZSBmaXJzdCBzYXRpc2Z5aW5nIGVsZW1lbnQgaXMgYmV0d2VlbiBbbG9dIGFuZCBbbWlkXSAqKVxuICAgIHRoZW5cbiAgICAgIGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpOm1pZCB+cHJlZFxuICAgICAgKCogSU5WQVJJQU5UIGNoZWNrOiBpdCBtZWFucyB0aGUgZmlyc3Qgc2F0aXNmeWluZyBlbGVtZW50LCBpZiBpdCBleGlzdHMsXG4gICAgICAgICBpcyBiZXR3ZWVuIFttaWQrMV0gYW5kIFtoaV0gKilcbiAgICBlbHNlIGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG86KG1pZCArIDEpIH5oaSB+cHJlZClcbjs7XG5cbmxldCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkID1cbiAgbGV0IHBvcywgbGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHQpXG4gIGluXG4gIGxldCBsbyA9IHBvcyBpblxuICBsZXQgaGkgPSBwb3MgKyBsZW4gLSAxIGluXG4gIGxldCBsbywgaGkgPSBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZCBpblxuICBsaW5lYXJfc2VhcmNoX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWRcbjs7XG5cbigqIFRha2VzIGFuIGFycmF5IHdpdGggc2hhcGUgW3RydWUsLi4udHJ1ZSxmYWxzZSwuLi5mYWxzZV0gKGkuZS4sIHRoZSBfcmV2ZXJzZV8gb2Ygd2hhdFxuICAgaXMgZGVzY3JpYmVkIGFib3ZlKSBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdHJ1ZSBvciBOb25lIGlmIHRoZXJlIGFyZSBub1xuICAgdHJ1ZSopXG5sZXQgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfnByZWQgfmdldCB+bGVuZ3RoID1cbiAgbGV0IHBvcywgbGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHQpXG4gIGluXG4gIGlmIGxlbiA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgICgqIFRoZSBsYXN0IHNhdGlzZnlpbmcgaXMgdGhlIG9uZSBqdXN0IGJlZm9yZSB0aGUgZmlyc3Qgbm90IHNhdGlzZnlpbmcgKilcbiAgICBtYXRjaFxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIH5wb3MgfmxlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gbm90IChwcmVkIHgpKVxuICAgIHdpdGhcbiAgICB8IE5vbmUgLT4gU29tZSAocG9zICsgbGVuIC0gMSlcbiAgICAoKiBUaGlzIG1lYW5zIHRoYXQgYWxsIGVsZW1lbnRzIHNhdGlzZnkgcHJlZC5cbiAgICAgICBUaGVyZSBpcyBhdCBsZWFzdCBhbiBlbGVtZW50IGFzIChsZW4gPiAwKSAqKVxuICAgIHwgU29tZSBpIHdoZW4gaSA9IHBvcyAtPiBOb25lICgqIG5vIGVsZW1lbnQgc2F0aXNmaWVzIHByZWQgKilcbiAgICB8IFNvbWUgaSAtPiBTb21lIChpIC0gMSkpXG47O1xuXG5sZXQgYmluYXJ5X3NlYXJjaFxuICA/cG9zXG4gID9sZW5cbiAgdFxuICB+KGxlbmd0aCA6IF8gLT4gXylcbiAgfihnZXQgOiBfIC0+IF8gLT4gXylcbiAgfihjb21wYXJlIDogXyAtPiBfIC0+IF8pXG4gIGhvd1xuICB2XG4gID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gLT5cbiAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDwgMCkgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMCkgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgfCBgRmlyc3RfZXF1YWxfdG8gLT5cbiAgICAobWF0Y2hcbiAgICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKVxuICAgICB3aXRoXG4gICAgIHwgU29tZSB4IHdoZW4gY29tcGFyZSAoZ2V0IHQgeCkgdiA9IDAgLT4gU29tZSB4XG4gICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICB8IGBMYXN0X2VxdWFsX3RvIC0+XG4gICAgKG1hdGNoXG4gICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKVxuICAgICB3aXRoXG4gICAgIHwgU29tZSB4IHdoZW4gY29tcGFyZSAoZ2V0IHQgeCkgdiA9IDAgLT4gU29tZSB4XG4gICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuIC0+XG4gICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPiAwKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuOztcblxubGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+c2VnbWVudF9vZiBob3cgPVxuICBsZXQgaXNfbGVmdCB4ID1cbiAgICBtYXRjaCBzZWdtZW50X29mIHggd2l0aFxuICAgIHwgYExlZnQgLT4gdHJ1ZVxuICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gIGluXG4gIGxldCBpc19yaWdodCB4ID0gbm90IChpc19sZWZ0IHgpIGluXG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYExhc3Rfb25fbGVmdCAtPlxuICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+cHJlZDppc19sZWZ0IFtAbm9udGFpbF1cbiAgfCBgRmlyc3Rfb25fcmlnaHQgLT5cbiAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5wcmVkOmlzX3JpZ2h0IFtAbm9udGFpbF1cbjs7XG4iLCIoKiogTW9kdWxlIHR5cGVzIGZvciBhIFtiaW5hcnlfc2VhcmNoXSBmdW5jdGlvbiBmb3IgYSBzZXF1ZW5jZSwgYW5kIGZ1bmN0b3JzIGZvciBidWlsZGluZ1xuICAgIFtiaW5hcnlfc2VhcmNoXSBmdW5jdGlvbnMuICopXG5cbm9wZW4hIEltcG9ydFxuXG4oKiogQW4gW0luZGV4YWJsZV0gdHlwZSBpcyBhIGZpbml0ZSBzZXF1ZW5jZSBvZiBlbGVtZW50cyBpbmRleGVkIGJ5IGNvbnNlY3V0aXZlIGludGVnZXJzXG4gICAgWzBdIC4uLiBbbGVuZ3RoIHQgLSAxXS4gIFtnZXRdIGFuZCBbbGVuZ3RoXSBtdXN0IGJlIE8oMSkgZm9yIHRoZSByZXN1bHRpbmdcbiAgICBbYmluYXJ5X3NlYXJjaF0gdG8gYmUgbGcobikuICopXG5tb2R1bGUgdHlwZSBJbmRleGFibGUgPSBzaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSB0XG5cbiAgdmFsIGdldCA6IHQgLT4gaW50IC0+IGVsdFxuICB2YWwgbGVuZ3RoIDogdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmRleGFibGUxID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBXaGljaF90YXJnZXRfYnlfa2V5ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gKCoqICAgICAgICB7diB8IDwgZWx0IFggfCAgICAgICAgICAgICAgICAgICAgICAgdn0gKilcbiAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAoKiogICAgIHt2IHwgICAgICA8PSBlbHQgICAgICAgWCB8ICAgICAgICAgICB2fSAqKVxuICAgIHwgYExhc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgICA9IGVsdCBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgfCBgRmlyc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCBYID0gZWx0ICAgfCAgICAgICAgICAgdn0gKilcbiAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gKCoqIHt2ICAgICAgICAgICB8IFggICAgICAgPj0gZWx0ICAgICAgfCB2fSAqKVxuICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAoKiogICAge3YgICAgICAgICAgICAgICAgICAgICAgIHwgWCA+IGVsdCB8IHZ9ICopXG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlXVxuXG4gIGxldCBhbGwgPVxuICAgIChbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhblxuICAgICA7IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90b1xuICAgICA7IGBMYXN0X2VxdWFsX3RvXG4gICAgIDsgYEZpcnN0X2VxdWFsX3RvXG4gICAgIDsgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90b1xuICAgICA7IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW5cbiAgICAgXVxuICAgICAgOiB0IGxpc3QpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBMYXN0X29uX2xlZnRcbiAgICB8IGBGaXJzdF9vbl9yaWdodFxuICAgIF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGVudW1lcmF0ZV1cblxuICBsZXQgYWxsID0gKFsgYExhc3Rfb25fbGVmdDsgYEZpcnN0X29uX3JpZ2h0IF0gOiB0IGxpc3QpXG5cbiAgW0BAQGVuZF1cbmVuZFxuXG50eXBlICgndCwgJ2VsdCwgJ2tleSkgYmluYXJ5X3NlYXJjaCA9XG4gID9wb3M6aW50XG4gIC0+ID9sZW46aW50XG4gIC0+ICd0XG4gIC0+IGNvbXBhcmU6KCdlbHQgLT4gJ2tleSAtPiBpbnQpXG4gIC0+IFdoaWNoX3RhcmdldF9ieV9rZXkudFxuICAtPiAna2V5XG4gIC0+IGludCBvcHRpb25cblxudHlwZSAoJ3QsICdlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID1cbiAgP3BvczppbnRcbiAgLT4gP2xlbjppbnRcbiAgLT4gJ3RcbiAgLT4gc2VnbWVudF9vZjooJ2VsdCAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gIC0+IFdoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgLT4gaW50IG9wdGlvblxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZWx0XG4gIHR5cGUgdFxuXG4gICgqKiBTZWUgW0JpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaF0gaW4gYmluYXJ5X3NlYXJjaC5tbCAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaCA6ICh0LCBlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2hcblxuICAoKiogU2VlIFtCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSBpbiBiaW5hcnlfc2VhcmNoLm1sICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA6ICh0LCBlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2ggOiAoJ2EgdCwgJ2EsICdrZXkpIGJpbmFyeV9zZWFyY2hcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIDogKCdhIHQsICdhKSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJpbmFyeV9zZWFyY2hhYmxlID0gc2lnXG4gIG1vZHVsZSB0eXBlIFMgPSBTXG4gIG1vZHVsZSB0eXBlIFMxID0gUzFcbiAgbW9kdWxlIHR5cGUgSW5kZXhhYmxlID0gSW5kZXhhYmxlXG4gIG1vZHVsZSB0eXBlIEluZGV4YWJsZTEgPSBJbmRleGFibGUxXG5cbiAgbW9kdWxlIFdoaWNoX3RhcmdldF9ieV9rZXkgPSBXaGljaF90YXJnZXRfYnlfa2V5XG4gIG1vZHVsZSBXaGljaF90YXJnZXRfYnlfc2VnbWVudCA9IFdoaWNoX3RhcmdldF9ieV9zZWdtZW50XG5cbiAgdHlwZSBub25yZWMgKCd0LCAnZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoID0gKCd0LCAnZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoXG4gIHR5cGUgbm9ucmVjICgndCwgJ2VsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgPSAoJ3QsICdlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG5cbiAgbW9kdWxlIE1ha2UgKFQgOiBJbmRleGFibGUpIDogUyB3aXRoIHR5cGUgdCA6PSBULnQgd2l0aCB0eXBlIGVsdCA6PSBULmVsdFxuICBtb2R1bGUgTWFrZTEgKFQgOiBJbmRleGFibGUxKSA6IFMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmluYXJ5X3NlYXJjaGFibGVfaW50ZlxuXG5tb2R1bGUgdHlwZSBBcmcgPSBzaWdcbiAgdHlwZSAnYSBlbHRcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIGVsdFxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlbiAoVCA6IEFyZykgPSBzdHJ1Y3RcbiAgbGV0IGdldCA9IFQuZ2V0XG4gIGxldCBsZW5ndGggPSBULmxlbmd0aFxuXG4gIGxldCBiaW5hcnlfc2VhcmNoID9wb3MgP2xlbiB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2ggP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5jb21wYXJlIGhvdyB2XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBJbmRleGFibGUpID0gTWFrZV9nZW4gKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICB0eXBlICdhIGVsdCA9IFQuZWx0XG4gIHR5cGUgJ2EgdCA9IFQudFxuZW5kKVxuXG5tb2R1bGUgTWFrZTEgKFQgOiBJbmRleGFibGUxKSA9IE1ha2VfZ2VuIChzdHJ1Y3RcbiAgdHlwZSAnYSBlbHQgPSAnYVxuICB0eXBlICdhIHQgPSAnYSBULnRcblxuICBsZXQgZ2V0ID0gVC5nZXRcbiAgbGV0IGxlbmd0aCA9IFQubGVuZ3RoXG5lbmQpXG4iLCIoKiBbQnl0ZXMwXSBkZWZpbmVzIHN0cmluZyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5XG4gICBkZWZpbmVkIGluIHRlcm1zIG9mIFtTdGRsaWIuQnl0ZXNdLiBbQnl0ZXMwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3NcbiAgIHRoZSBwYXJ0IG9mIFtTdGRsaWIuQnl0ZXNdIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyXG4gICB0aGFuIGJ5dGVzMC5tbCBzaG91bGQgdXNlIFtTdGRsaWIuQnl0ZXNdLiBbQnl0ZXMwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kXG4gICBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLlxuXG4gICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIHN0cmluZ3MgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkJ5dGVzXSBpblxuICAgYnVpbGQgb3JkZXIgc2hvdWxkIGRvOlxuXG4gICB7W1xuICAgICBtb2R1bGUgQnl0ZXMgID0gQnl0ZXMwXG4gICBdfVxuXG4gICBEZWZpbmluZyBbbW9kdWxlIEJ5dGVzID0gQnl0ZXMwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzXG4gICBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkJ5dGVzXS4gKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIFVjaGFyID0gVWNoYXIwXG5tb2R1bGUgU3lzID0gU3lzMFxuXG5tb2R1bGUgUHJpbWl0aXZlcyA9IHN0cnVjdFxuICBleHRlcm5hbCBnZXQgOiAoYnl0ZXNbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IChieXRlc1tAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcblxuICBleHRlcm5hbCB1bnNhZmVfZ2V0XG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gY2hhclxuICAgID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5cbiAgZXh0ZXJuYWwgc2V0XG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGNoYXJbQGxvY2FsX29wdF0pXG4gICAgLT4gdW5pdFxuICAgID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoY2hhcltAbG9jYWxfb3B0XSlcbiAgICAtPiB1bml0XG4gICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcblxuICAoKiBbdW5zYWZlX2JsaXRfc3RyaW5nXSBpcyBub3QgZXhwb3J0ZWQgaW4gdGhlIFtzdGRsaWJdIHNvIHdlIGV4cG9ydCBpdCBoZXJlICopXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZ1xuICAgIDogIHNyYzooc3RyaW5nW0Bsb2NhbF9vcHRdKVxuICAgIC0+IHNyY19wb3M6aW50XG4gICAgLT4gZHN0OihieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiBkc3RfcG9zOmludFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiB1bml0XG4gICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2dldF9pbnQ2NFxuICAgIDogIChieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGludDY0XG4gICAgPSBcIiVjYW1sX2J5dGVzX2dldDY0dVwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ2NFxuICAgIDogIChieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnQ2NFtAbG9jYWxfb3B0XSlcbiAgICAtPiB1bml0XG4gICAgPSBcIiVjYW1sX2J5dGVzX3NldDY0dVwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2dldF9pbnQzMlxuICAgIDogIChieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGludDMyXG4gICAgPSBcIiVjYW1sX2J5dGVzX2dldDMydVwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQzMlxuICAgIDogIChieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnQzMltAbG9jYWxfb3B0XSlcbiAgICAtPiB1bml0XG4gICAgPSBcIiVjYW1sX2J5dGVzX3NldDMydVwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2dldF9pbnQxNlxuICAgIDogIChieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGludFxuICAgID0gXCIlY2FtbF9ieXRlc19nZXQxNnVcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRfaW50MTZcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IHVuaXRcbiAgICA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZ1XCJcbmVuZFxuXG5pbmNsdWRlIFByaW1pdGl2ZXNcblxubGV0IG1heF9sZW5ndGggPSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbmxldCBibGl0ID0gU3RkbGliLkJ5dGVzLmJsaXRcbmxldCBibGl0X3N0cmluZyA9IFN0ZGxpYi5CeXRlcy5ibGl0X3N0cmluZ1xubGV0IGNvbXBhcmUgPSBTdGRsaWIuQnl0ZXMuY29tcGFyZVxubGV0IGNvcHkgPSBTdGRsaWIuQnl0ZXMuY29weVxubGV0IGNyZWF0ZSA9IFN0ZGxpYi5CeXRlcy5jcmVhdGVcbmxldCBzZXRfdWNoYXJfdXRmXzggPSBTdGRsaWIuQnl0ZXMuc2V0X3V0Zl84X3VjaGFyXG5sZXQgc2V0X3VjaGFyX3V0Zl8xNmxlID0gU3RkbGliLkJ5dGVzLnNldF91dGZfMTZsZV91Y2hhclxubGV0IHNldF91Y2hhcl91dGZfMTZiZSA9IFN0ZGxpYi5CeXRlcy5zZXRfdXRmXzE2YmVfdWNoYXJcblxubGV0IHNldF91dGZfMzJfdWNoYXIgfnNldF9pbnQzMiBieXRlcyBpZHggdWNoYXIgPVxuICBVY2hhci50b19pbnQgdWNoYXJcbiAgfD4gSW50X2NvbnZlcnNpb25zLmludF90b19pbnQzMl90cnVuYyAoKiBzaG91bGQgbmV2ZXIgaGF2ZSBhbnl0aGluZyB0byB0cnVuY2F0ZSAqKVxuICB8PiBzZXRfaW50MzIgYnl0ZXMgaWR4O1xuICA0XG47O1xuXG5sZXQgc2V0X3VjaGFyX3V0Zl8zMmxlID0gc2V0X3V0Zl8zMl91Y2hhciB+c2V0X2ludDMyOlN0ZGxpYi5CeXRlcy5zZXRfaW50MzJfbGVcbmxldCBzZXRfdWNoYXJfdXRmXzMyYmUgPSBzZXRfdXRmXzMyX3VjaGFyIH5zZXRfaW50MzI6U3RkbGliLkJ5dGVzLnNldF9pbnQzMl9iZVxuXG5leHRlcm5hbCB1bnNhZmVfY3JlYXRlX2xvY2FsIDogaW50IC0+IGJ5dGVzID0gXCJCYXNlX3Vuc2FmZV9jcmVhdGVfbG9jYWxfYnl0ZXNcIiBcblxubGV0IGNyZWF0ZV9sb2NhbCBsZW4gPVxuICBpZiBsZW4gPiBTeXMwLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gaW52YWxpZF9hcmcgXCJCeXRlcy5jcmVhdGVfbG9jYWxcIjtcbiAgdW5zYWZlX2NyZWF0ZV9sb2NhbCBsZW5cbjs7XG5cbmxldCBmaWxsID0gU3RkbGliLkJ5dGVzLmZpbGxcbmxldCBtYWtlID0gU3RkbGliLkJ5dGVzLm1ha2VcblxubGV0IG1hcCB0IH4oZiA6IF8gLT4gXykgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGlmIGwgPSAwXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCB0IGkpKVxuICAgIGRvbmU7XG4gICAgcilcbjs7XG5cbmxldCBtYXBpIHQgfihmIDogXyAtPiBfIC0+IF8pID1cbiAgbGV0IGwgPSBsZW5ndGggdCBpblxuICBpZiBsID0gMFxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCB0IGkpKVxuICAgIGRvbmU7XG4gICAgcilcbjs7XG5cbmxldCBzdWIgPSBTdGRsaWIuQnl0ZXMuc3ViXG5cbmV4dGVybmFsIHVuc2FmZV9ibGl0XG4gIDogIHNyYzooYnl0ZXNbQGxvY2FsX29wdF0pXG4gIC0+IHNyY19wb3M6aW50XG4gIC0+IGRzdDooYnl0ZXNbQGxvY2FsX29wdF0pXG4gIC0+IGRzdF9wb3M6aW50XG4gIC0+IGxlbjppbnRcbiAgLT4gdW5pdFxuICA9IFwiY2FtbF9ibGl0X2J5dGVzXCJcbiAgW0BAbm9hbGxvY11cblxubGV0IHRvX3N0cmluZyA9IFN0ZGxpYi5CeXRlcy50b19zdHJpbmdcbmxldCBvZl9zdHJpbmcgPSBTdGRsaWIuQnl0ZXMub2Zfc3RyaW5nXG5cbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmdcbiAgOiAgbm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTooYnl0ZXNbQGxvY2FsX29wdF0pXG4gIC0+IChzdHJpbmdbQGxvY2FsX29wdF0pXG4gID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcblxuZXh0ZXJuYWwgdW5zYWZlX29mX3N0cmluZ19wcm9taXNlX25vX211dGF0aW9uXG4gIDogIChzdHJpbmdbQGxvY2FsX29wdF0pXG4gIC0+IChieXRlc1tAbG9jYWxfb3B0XSlcbiAgPSBcIiVieXRlc19vZl9zdHJpbmdcIlxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEJsaXRfaW50ZlxuXG5tb2R1bGUgdHlwZSBTZXF1ZW5jZV9nZW4gPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW5cbiAgKFNyYyA6IFNlcXVlbmNlX2dlbikgKERzdCA6IHNpZ1xuICAgIGluY2x1ZGUgU2VxdWVuY2VfZ2VuXG5cbiAgICB2YWwgY3JlYXRlX2xpa2UgOiBsZW46aW50IC0+ICdhIFNyYy50IC0+ICdhIHRcbiAgICB2YWwgdW5zYWZlX2JsaXQgOiAoJ2EgU3JjLnQsICdhIHQpIGJsaXRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IHVuc2FmZV9ibGl0ID0gRHN0LnVuc2FmZV9ibGl0XG5cbiAgbGV0IGJsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG5cbiAgICAgIH5wb3M6c3JjX3Bvc1xuICAgICAgfmxlblxuICAgICAgfnRvdGFsX2xlbmd0aDooU3JjLmxlbmd0aCBzcmMpO1xuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG5cbiAgICAgIH5wb3M6ZHN0X3Bvc1xuICAgICAgfmxlblxuICAgICAgfnRvdGFsX2xlbmd0aDooRHN0Lmxlbmd0aCBkc3QpO1xuICAgIGlmIGxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlblxuICA7O1xuXG4gIGxldCBibGl0b1xuICAgIH5zcmNcbiAgICA/KHNyY19wb3MgPSAwKVxuICAgID8oc3JjX2xlbiA9IFNyYy5sZW5ndGggc3JjIC0gc3JjX3BvcylcbiAgICB+ZHN0XG4gICAgPyhkc3RfcG9zID0gMClcbiAgICAoKVxuICAgID1cbiAgICBibGl0IH5zcmMgfnNyY19wb3MgfmxlbjpzcmNfbGVuIH5kc3QgfmRzdF9wb3NcbiAgOztcblxuICAoKiBbc3ViXSBhbmQgW3N1Ym9dIGVuc3VyZSB0aGF0IGV2ZXJ5IHBvc2l0aW9uIG9mIHRoZSBjcmVhdGVkIHNlcXVlbmNlIGlzIHBvcHVsYXRlZCBieVxuICAgICBhbiBlbGVtZW50IG9mIHRoZSBzb3VyY2UgYXJyYXkuICBUaHVzIGV2ZXJ5IGVsZW1lbnQgb2YgW2RzdF0gYmVsb3cgaXMgd2VsbFxuICAgICBkZWZpbmVkLiAqKVxuICBsZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg6KFNyYy5sZW5ndGggc3JjKTtcbiAgICBsZXQgZHN0ID0gRHN0LmNyZWF0ZV9saWtlIH5sZW4gc3JjIGluXG4gICAgaWYgbGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IH5zcmMgfnNyY19wb3M6cG9zIH5kc3QgfmRzdF9wb3M6MCB+bGVuO1xuICAgIGRzdFxuICA7O1xuXG4gIGxldCBzdWJvID8ocG9zID0gMCkgP2xlbiBzcmMgPVxuICAgIHN1YlxuICAgICAgc3JjXG4gICAgICB+cG9zXG4gICAgICB+bGVuOlxuICAgICAgICAobWF0Y2ggbGVuIHdpdGhcbiAgICAgICAgIHwgU29tZSBpIC0+IGlcbiAgICAgICAgIHwgTm9uZSAtPiBTcmMubGVuZ3RoIHNyYyAtIHBvcylcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZTEgKFNlcXVlbmNlIDogc2lnXG4gIGluY2x1ZGUgU2VxdWVuY2VfZ2VuXG5cbiAgdmFsIGNyZWF0ZV9saWtlIDogbGVuOmludCAtPiAnYSB0IC0+ICdhIHRcbiAgdmFsIHVuc2FmZV9ibGl0IDogKCdhIHQsICdhIHQpIGJsaXRcbmVuZCkgPVxuICBNYWtlX2dlbiAoU2VxdWVuY2UpIChTZXF1ZW5jZSlcblxubW9kdWxlIE1ha2UxX2dlbmVyaWMgKFNlcXVlbmNlIDogU2VxdWVuY2UxKSA9IE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuXG5tb2R1bGUgTWFrZSAoU2VxdWVuY2UgOiBzaWdcbiAgaW5jbHVkZSBTZXF1ZW5jZVxuXG4gIHZhbCBjcmVhdGUgOiBsZW46aW50IC0+IHRcbiAgdmFsIHVuc2FmZV9ibGl0IDogKHQsIHQpIGJsaXRcbmVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBTZXF1ZW5jZSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9IFNlcXVlbmNlLnRcblxuICAgIG9wZW4gU2VxdWVuY2VcblxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmRcblxuICBpbmNsdWRlIE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuZW5kXG5cbm1vZHVsZSBNYWtlX2Rpc3RpbmN0XG4gIChTcmMgOiBTZXF1ZW5jZSkgKERzdCA6IHNpZ1xuICAgIGluY2x1ZGUgU2VxdWVuY2VcblxuICAgIHZhbCBjcmVhdGUgOiBsZW46aW50IC0+IHRcbiAgICB2YWwgdW5zYWZlX2JsaXQgOiAoU3JjLnQsIHQpIGJsaXRcbiAgZW5kKSA9XG4gIE1ha2VfZ2VuXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gU3JjLnRcblxuICAgICAgb3BlbiBTcmNcblxuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBEc3QudFxuXG4gICAgICBvcGVuIERzdFxuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiBfID0gY3JlYXRlIH5sZW5cbiAgICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gICAgZW5kKVxuXG5tb2R1bGUgTWFrZV90b19zdHJpbmcgKFQgOiBzaWdcbiAgdHlwZSB0XG5lbmQpXG4oVG9fYnl0ZXMgOiBTX2Rpc3RpbmN0IHdpdGggdHlwZSBzcmMgOj0gVC50IHdpdGggdHlwZSBkc3QgOj0gYnl0ZXMpID1cbnN0cnVjdFxuICBvcGVuIFRvX2J5dGVzXG5cbiAgbGV0IHN1YiBzcmMgfnBvcyB+bGVuID1cbiAgICBCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTooc3ViIHNyYyB+cG9zIH5sZW4pXG4gIDs7XG5cbiAgbGV0IHN1Ym8gP3BvcyA/bGVuIHNyYyA9XG4gICAgQnl0ZXMwLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6KHN1Ym8gP3BvcyA/bGVuIHNyYylcbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEJvb2wwXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGJvb2xcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9ib29sIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIGZhbHNlOyB0cnVlIF0gOiB0IGxpc3QpXG4gIGxldCAoZ2xvYmFsaXplIDogdCAtPiB0KSA9IChnbG9iYWxpemVfYm9vbCA6IHQgLT4gdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2Jvb2xcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2Jvb2wgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGJvb2xfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfYm9vbCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBib29sX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuXG4gIGxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICAgIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gICAgfCBzIC0+IGludmFsaWRfYXJnZiBcIkJvb2wub2Zfc3RyaW5nOiBleHBlY3RlZCB0cnVlIG9yIGZhbHNlIGJ1dCBnb3QgJXNcIiBzICgpXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IFN0ZGxpYi5zdHJpbmdfb2ZfYm9vbFxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkJvb2xcIlxuZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBCb29sX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0IHRvX2ludCB4ID0gYm9vbF90b19pbnQgeFxuXG5tb2R1bGUgTm9uX3Nob3J0X2NpcmN1aXRpbmcgPSBzdHJ1Y3RcbiAgKCogV2UgZG9uJ3QgZXhwb3NlIHRoaXMsIHNpbmNlIHdlIGRvbid0IHdhbnQgdG8gYnJlYWsgdGhlIGludmFyaWFudCBtZW50aW9uZWQgYmVsb3cgb2ZcbiAgICAgKHRvX2ludCB0cnVlID0gMSkgYW5kICh0b19pbnQgZmFsc2UgPSAwKS4gKilcbiAgbGV0IHVuc2FmZV9vZl9pbnQgKHggOiBpbnQpIDogYm9vbCA9IFN0ZGxpYi5PYmoubWFnaWMgeFxuICBsZXQgKCB8fCApIGEgYiA9IHVuc2FmZV9vZl9pbnQgKHRvX2ludCBhIGxvciB0b19pbnQgYilcbiAgbGV0ICggJiYgKSBhIGIgPSB1bnNhZmVfb2ZfaW50ICh0b19pbnQgYSBsYW5kIHRvX2ludCBiKVxuZW5kXG5cbigqIFdlIGRvIHRoaXMgYXMgYSBkaXJlY3QgYXNzZXJ0IG9uIHRoZSB0aGVvcnkgdGhhdCBpdCdzIGEgY2hlYXAgdGhpbmcgdG8gdGVzdCBhbmQgYVxuICAgcmVhbGx5IGNvcmUgaW52YXJpYW50IHRoYXQgd2UgbmV2ZXIgZXhwZWN0IHRvIGJyZWFrLCBhbmQgd2Ugc2hvdWxkIGJlIGhhcHB5IGZvciBhXG4gICBwcm9ncmFtIHRvIGZhaWwgaW1tZWRpYXRlbHkgaWYgdGhpcyBpcyB2aW9sYXRlZC4gKilcbmxldCAoKSA9IGFzc2VydCAoUG9seS4oID0gKSAodG9faW50IHRydWUpIDEgJiYgUG9seS4oID0gKSAodG9faW50IGZhbHNlKSAwKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBFaXRoZXJfaW50ZlxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBFaXRoZXIwXG5cbmxldCBzd2FwID0gZnVuY3Rpb25cbiAgfCBGaXJzdCB4IC0+IFNlY29uZCB4XG4gIHwgU2Vjb25kIHggLT4gRmlyc3QgeFxuOztcblxubGV0IGlzX2ZpcnN0ID0gZnVuY3Rpb25cbiAgfCBGaXJzdCBfIC0+IHRydWVcbiAgfCBTZWNvbmQgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3NlY29uZCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgXyAtPiBmYWxzZVxuICB8IFNlY29uZCBfIC0+IHRydWVcbjs7XG5cbmxldCB2YWx1ZSAoRmlyc3QgeCB8IFNlY29uZCB4KSA9IHhcblxubGV0IHZhbHVlX21hcCB0IH5maXJzdCB+c2Vjb25kID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRmlyc3QgeCAtPiBmaXJzdCB4XG4gIHwgU2Vjb25kIHggLT4gc2Vjb25kIHhcbjs7XG5cbmxldCBpdGVyID0gdmFsdWVfbWFwXG5cbmxldCBtYXAgdCB+Zmlyc3QgfnNlY29uZCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEZpcnN0IHggLT4gRmlyc3QgKGZpcnN0IHgpXG4gIHwgU2Vjb25kIHggLT4gU2Vjb25kIChzZWNvbmQgeClcbjs7XG5cbmxldCBmaXJzdCB4ID0gRmlyc3QgeFxubGV0IHNlY29uZCB4ID0gU2Vjb25kIHhcblxubGV0IGVxdWFsIGVxMSBlcTIgdDEgdDIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gZXExIHggeVxuICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBlcTIgeCB5XG4gIHwgRmlyc3QgXywgU2Vjb25kIF8gfCBTZWNvbmQgXywgRmlyc3QgXyAtPiBmYWxzZVxuOztcblxubGV0IGxvY2FsX2VxdWFsIGVxMSBlcTIgdDEgdDIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gZXExIHggeVxuICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBlcTIgeCB5XG4gIHwgRmlyc3QgXywgU2Vjb25kIF8gfCBTZWNvbmQgXywgRmlyc3QgXyAtPiBmYWxzZVxuOztcblxubGV0IGludmFyaWFudCBmIHMgPSBmdW5jdGlvblxuICB8IEZpcnN0IHggLT4gZiB4XG4gIHwgU2Vjb25kIHkgLT4gcyB5XG47O1xuXG5tb2R1bGUgRm9jdXMgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB8IEZvY3VzIG9mIHsgdmFsdWUgOiAnYSB9XG4gICAgfCBPdGhlciBvZiB7IHZhbHVlIDogJ2IgfVxuZW5kXG5cbm1vZHVsZSBNYWtlX2ZvY3VzZWQgKE0gOiBzaWdcbiAgdHlwZSAoKydhLCArJ2IpIHRcblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG4gIHZhbCBvdGhlciA6ICdiIC0+IChfLCAnYikgdFxuICB2YWwgZm9jdXMgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIEZvY3VzLnRcblxuICB2YWwgY29tYmluZVxuICAgIDogICgnYSwgJ2QpIHRcbiAgICAtPiAoJ2IsICdkKSB0XG4gICAgLT4gZjooJ2EgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gb3RoZXI6KCdkIC0+ICdkIC0+ICdkKVxuICAgIC0+ICgnYywgJ2QpIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2EgLT4gKCdjLCAnYikgdCkgLT4gKCdjLCAnYikgdFxuZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG4gIG9wZW4gV2l0aF9yZXR1cm5cblxuICBsZXQgbWFwIHQgfmYgPVxuICAgIGxldCByZXMgPSBiaW5kIHQgfmY6KGZ1biB4IC0+IHJldHVybiAoZiB4KSkgaW5cbiAgICByZXNcbiAgOztcblxuICBpbmNsdWRlIE1vbmFkLk1ha2UyX2xvY2FsIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbiAgbW9kdWxlIEFwcCA9IEFwcGxpY2F0aXZlLk1ha2UyX3VzaW5nX21hcDJfbG9jYWwgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG5cbiAgICBsZXQgbWFwMiA6ICgnYSwgJ3gpIHQgLT4gKCdiLCAneCkgdCAtPiBmOignYSAtPiAnYiAtPiAnYykgLT4gKCdjLCAneCkgdCA9XG4gICAgICBmdW4gdDEgdDIgfmYgLT5cbiAgICAgIGJpbmQgdDEgfmY6KGZ1biB4IC0+IGJpbmQgdDIgfmY6KGZ1biB5IC0+IHJldHVybiAoZiB4IHkpKSBbQG5vbnRhaWxdKSBbQG5vbnRhaWxdXG4gICAgOztcbiAgZW5kKVxuXG4gIGluY2x1ZGUgQXBwXG5cbiAgbGV0IGNvbWJpbmVfYWxsID1cbiAgICBsZXQgcmVjIG90aGVyX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBvdGhlciBhY2NcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICAobWF0Y2ggZm9jdXMgdCB3aXRoXG4gICAgICAgICB8IEZvY3VzIF8gLT4gb3RoZXJfbG9vcCBmIGFjYyB0c1xuICAgICAgICAgfCBPdGhlciBvIC0+IG90aGVyX2xvb3AgZiAoZiBhY2Mgby52YWx1ZSkgdHMpXG4gICAgaW5cbiAgICBsZXQgcmVjIHJldHVybl9sb29wIGYgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiBhY2MpXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgKG1hdGNoIGZvY3VzIHQgd2l0aFxuICAgICAgICAgfCBGb2N1cyB4IC0+IHJldHVybl9sb29wIGYgKHgudmFsdWUgOjogYWNjKSB0c1xuICAgICAgICAgfCBPdGhlciBvIC0+IG90aGVyX2xvb3AgZiBvLnZhbHVlIHRzKVxuICAgIGluXG4gICAgZnVuIHRzIH5mIC0+IHJldHVybl9sb29wIGYgW10gdHNcbiAgOztcblxuICBsZXQgY29tYmluZV9hbGxfdW5pdCA9XG4gICAgbGV0IHJlYyBvdGhlcl9sb29wIGYgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gb3RoZXIgYWNjXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgKG1hdGNoIGZvY3VzIHQgd2l0aFxuICAgICAgICAgfCBGb2N1cyBfIC0+IG90aGVyX2xvb3AgZiBhY2MgdHNcbiAgICAgICAgIHwgT3RoZXIgbyAtPiBvdGhlcl9sb29wIGYgKGYgYWNjIG8udmFsdWUpIHRzKVxuICAgIGluXG4gICAgbGV0IHJlYyByZXR1cm5fbG9vcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuICgpXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgKG1hdGNoIGZvY3VzIHQgd2l0aFxuICAgICAgICAgfCBGb2N1cyB7IHZhbHVlID0gKCkgfSAtPiByZXR1cm5fbG9vcCBmIHRzXG4gICAgICAgICB8IE90aGVyIHsgdmFsdWUgPSBvIH0gLT4gb3RoZXJfbG9vcCBmIG8gdHMpXG4gICAgaW5cbiAgICBmdW4gdHMgfmYgLT4gcmV0dXJuX2xvb3AgZiB0c1xuICA7O1xuXG4gIGxldCB0b19vcHRpb24gdCA9XG4gICAgbWF0Y2ggZm9jdXMgdCB3aXRoXG4gICAgfCBGb2N1cyB4IC0+IFNvbWUgeC52YWx1ZVxuICAgIHwgT3RoZXIgXyAtPiBOb25lXG4gIDs7XG5cbiAgbGV0IHZhbHVlIHQgfmRlZmF1bHQgPVxuICAgIG1hdGNoIGZvY3VzIHQgd2l0aFxuICAgIHwgRm9jdXMgeCAtPiB4LnZhbHVlXG4gICAgfCBPdGhlciBfIC0+IGRlZmF1bHRcbiAgOztcblxuICBsZXQgd2l0aF9yZXR1cm4gZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByZXQgLT4gb3RoZXIgKGYgKFdpdGhfcmV0dXJuLnByZXBlbmQgcmV0IH5mOnJldHVybikpKSBbQG5vbnRhaWxdXG4gIDs7XG5lbmRcblxubW9kdWxlIEZpcnN0ID0gTWFrZV9mb2N1c2VkIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICBsZXQgcmV0dXJuID0gZmlyc3RcbiAgbGV0IG90aGVyID0gc2Vjb25kXG5cbiAgbGV0IGZvY3VzIHQgOiBfIEZvY3VzLnQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRmlyc3QgeCAtPiBGb2N1cyB7IHZhbHVlID0geCB9XG4gICAgfCBTZWNvbmQgeSAtPiBPdGhlciB7IHZhbHVlID0geSB9XG4gIDs7XG5cbiAgbGV0IGNvbWJpbmUgdDEgdDIgfmYgfm90aGVyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRmlyc3QgeCwgRmlyc3QgeSAtPiBGaXJzdCAoZiB4IHkpXG4gICAgfCBTZWNvbmQgeCwgU2Vjb25kIHkgLT4gU2Vjb25kIChvdGhlciB4IHkpXG4gICAgfCBTZWNvbmQgeCwgXyB8IF8sIFNlY29uZCB4IC0+IFNlY29uZCB4XG4gIDs7XG5cbiAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBGaXJzdCB4IC0+IGYgeFxuICAgICgqIFJldXNlIHRoZSB2YWx1ZSBpbiBvcmRlciB0byBhdm9pZCBhbGxvY2F0aW9uLiAqKVxuICAgIHwgU2Vjb25kIF8gYXMgeSAtPiB5XG4gIDs7XG5lbmQpXG5cbm1vZHVsZSBTZWNvbmQgPSBNYWtlX2ZvY3VzZWQgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdiLCAnYSkgdFxuXG4gIGxldCByZXR1cm4gPSBzZWNvbmRcbiAgbGV0IG90aGVyID0gZmlyc3RcblxuICBsZXQgZm9jdXMgdCA6IF8gRm9jdXMudCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBTZWNvbmQgeCAtPiBGb2N1cyB7IHZhbHVlID0geCB9XG4gICAgfCBGaXJzdCB5IC0+IE90aGVyIHsgdmFsdWUgPSB5IH1cbiAgOztcblxuICBsZXQgY29tYmluZSB0MSB0MiB+ZiB+b3RoZXIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBTZWNvbmQgeCwgU2Vjb25kIHkgLT4gU2Vjb25kIChmIHggeSlcbiAgICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gRmlyc3QgKG90aGVyIHggeSlcbiAgICB8IEZpcnN0IHgsIF8gfCBfLCBGaXJzdCB4IC0+IEZpcnN0IHhcbiAgOztcblxuICBsZXQgYmluZCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFNlY29uZCB4IC0+IGYgeFxuICAgICgqIFJldXNlIHRoZSB2YWx1ZSBpbiBvcmRlciB0byBhdm9pZCBhbGxvY2F0aW9uLCBsaWtlIFtGaXJzdC5iaW5kXSBhYm92ZS4gKilcbiAgICB8IEZpcnN0IF8gYXMgeSAtPiB5XG4gIDs7XG5lbmQpXG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2YsICdzKSBfZWl0aGVyID0gKCdmLCAncykgdCA9XG4gICAgfCBGaXJzdCBvZiAnZlxuICAgIHwgU2Vjb25kIG9mICdzXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5pbmNsdWRlIChcbiAgc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCBjb21wYXJlX19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgICAgIGNvbXBhcmVfb3B0aW9uX19sb2NhbFxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9vcHRpb25cblxuICAgIGxldCBnbG9iYWxpemUgOiAnYS4gKCdhIC0+ICdhKSAtPiAnYSB0IC0+ICdhIHQgPVxuICAgICAgZnVuICh0eXBlIGFfXzAwOV8pIDogKChhX18wMDlfIC0+IGFfXzAwOV8pIC0+IGFfXzAwOV8gdCAtPiBhX18wMDlfIHQpIC0+XG4gICAgICBnbG9iYWxpemVfb3B0aW9uXG4gICAgOztcblxuICAgIGxldCBoYXNoX2ZvbGRfdCA6XG4gICAgICAgICAgJ2EuXG4gICAgICAgICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgICAgICAgLT4gJ2EgdFxuICAgICAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgICAgPVxuICAgICAgaGFzaF9mb2xkX29wdGlvblxuICAgIDs7XG5cbiAgICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgICAgIG9wdGlvbl9vZl9zZXhwXG4gICAgOztcblxuICAgIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgICAgc2V4cF9vZl9vcHRpb25cbiAgICA7O1xuXG4gICAgbGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICAgICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gb3B0aW9uX3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gICAgOztcblxuICAgIFtAQEBlbmRdXG4gIGVuZCA6XG4gICAgc2lnXG4gICAgICB0eXBlICdhIHQgPSAnYSBvcHRpb25cbiAgICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICAgICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TX2xvY2FsMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICAgIHZhbCBnbG9iYWxpemUgOiAoJ2EgLT4gJ2EpIC0+ICdhIHQgLT4gJ2EgdFxuXG4gICAgICBpbmNsdWRlIFBweF9oYXNoX2xpYi5IYXNoYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gICAgICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgICAgdmFsIHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgICBbQEBAZW5kXVxuICAgIGVuZClcblxudHlwZSAnYSB0ID0gJ2Egb3B0aW9uID1cbiAgfCBOb25lXG4gIHwgU29tZSBvZiAnYVxuXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3NvbWUgPSBmdW5jdGlvblxuICB8IFNvbWUgXyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHZhbHVlX21hcCBvIH5kZWZhdWx0IH5mID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgU29tZSB4IC0+IGYgeFxuICB8IE5vbmUgLT4gZGVmYXVsdFxuOztcblxubGV0IGl0ZXIgbyB+ZiA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGEgLT4gZiBhXG47O1xuXG5sZXQgaW52YXJpYW50IGYgdCA9IGl0ZXIgdCB+ZlxuXG5sZXQgY2FsbCB4IH5mID1cbiAgbWF0Y2ggZiB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZiAtPiBmIHhcbjs7XG5cbmxldCB2YWx1ZSB0IH5kZWZhdWx0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBkZWZhdWx0XG4gIHwgU29tZSB4IC0+IHhcbjs7XG5cbmxldCB2YWx1ZV9leG4gP2hlcmUgP2Vycm9yID9tZXNzYWdlIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTb21lIHggLT4geFxuICB8IE5vbmUgLT5cbiAgICBsZXQgZXJyb3IgPVxuICAgICAgbWF0Y2ggaGVyZSwgZXJyb3IsIG1lc3NhZ2Ugd2l0aFxuICAgICAgfCBOb25lLCBOb25lLCBOb25lIC0+IEVycm9yLm9mX3N0cmluZyBcIk9wdGlvbi52YWx1ZV9leG4gTm9uZVwiXG4gICAgICB8IE5vbmUsIE5vbmUsIFNvbWUgbSAtPiBFcnJvci5vZl9zdHJpbmcgbVxuICAgICAgfCBOb25lLCBTb21lIGUsIE5vbmUgLT4gZVxuICAgICAgfCBOb25lLCBTb21lIGUsIFNvbWUgbSAtPiBFcnJvci50YWcgZSB+dGFnOm1cbiAgICAgIHwgU29tZSBwLCBOb25lLCBOb25lIC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZSBcIk9wdGlvbi52YWx1ZV9leG5cIiBwIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3RcbiAgICAgIHwgU29tZSBwLCBOb25lLCBTb21lIG0gLT4gRXJyb3IuY3JlYXRlIG0gcCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90XG4gICAgICB8IFNvbWUgcCwgU29tZSBlLCBfIC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZVxuICAgICAgICAgICh2YWx1ZSBtZXNzYWdlIH5kZWZhdWx0OlwiXCIpXG4gICAgICAgICAgKGUsIHApXG4gICAgICAgICAgKHNleHBfb2ZfcGFpciBFcnJvci5zZXhwX29mX3QgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdClcbiAgICBpblxuICAgIEVycm9yLnJhaXNlIGVycm9yXG47O1xuXG5sZXQgdmFsdWVfb3JfdGh1bmsgbyB+ZGVmYXVsdCA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IFNvbWUgeCAtPiB4XG4gIHwgTm9uZSAtPiBkZWZhdWx0ICgpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gW3x8XVxuICB8IFNvbWUgeCAtPiBbfCB4IHxdXG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgeCAtPiBbIHggXVxuOztcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gdHJ1ZVxuICB8IFNvbWUgeCAtPiBmIHhcbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gZmFsc2VcbiAgfCBTb21lIHggLT4gZiB4XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhbHNlXG4gIHwgU29tZSBhJyAtPiBlcXVhbCBhIGEnXG47O1xuXG5sZXQgbGVuZ3RoIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIF8gLT4gMVxuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gaW5pdFxuICB8IFNvbWUgeCAtPiBmIGluaXQgeFxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgeCAtPiBpZiBmIHggdGhlbiB0IGVsc2UgTm9uZVxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGEgLT4gZiBhXG47O1xuXG5sZXQgZXF1YWwgZiB0IHQnID1cbiAgbWF0Y2ggdCwgdCcgd2l0aFxuICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICB8IFNvbWUgeCwgU29tZSB4JyAtPiBmIHggeCdcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgZXF1YWxfX2xvY2FsIGYgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOb25lLCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHgsIFNvbWUgeCcgLT4gZiB4IHgnXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHNvbWUgeCA9IFNvbWUgeFxuXG5sZXQgZmlyc3Rfc29tZSB4IHkgPVxuICBtYXRjaCB4IHdpdGhcbiAgfCBTb21lIF8gLT4geFxuICB8IE5vbmUgLT4geVxuOztcblxubGV0IHNvbWVfaWYgY29uZCB4ID0gaWYgY29uZCB0aGVuIFNvbWUgeCBlbHNlIE5vbmVcblxubGV0IG1lcmdlIGEgYiB+ZiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IE5vbmUsIHggfCB4LCBOb25lIC0+IHhcbiAgfCBTb21lIGEsIFNvbWUgYiAtPiBTb21lIChmIGEgYilcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNvbWUgdiBhcyBvIHdoZW4gZiB2IC0+IG9cbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCB0cnlfd2l0aCBmID1cbiAgbWF0Y2ggZiAoKSB3aXRoXG4gIHwgeCAtPiBTb21lIHhcbiAgfCBleGNlcHRpb24gXyAtPiBOb25lXG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbiBmID1cbiAgbWF0Y2ggZiAoKSB3aXRoXG4gIHwgeCAtPiB4XG4gIHwgZXhjZXB0aW9uIF8gLT4gTm9uZVxuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhIC0+IFNvbWUgKGYgYSlcbjs7XG5cbm1vZHVsZSBNb25hZF9hcmcgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG5cbiAgbGV0IHJldHVybiB4ID0gU29tZSB4XG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuXG4gIGxldCBiaW5kIG8gfmYgPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gZiB4XG4gIDs7XG5lbmRcblxuaW5jbHVkZSBNb25hZC5NYWtlX2xvY2FsIChNb25hZF9hcmcpXG5cbm1vZHVsZSBBcHBsaWNhdGl2ZV9hcmcgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG5cbiAgbGV0IHJldHVybiB4ID0gU29tZSB4XG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuXG4gIGxldCBtYXAyIHggeSB+ZiA9XG4gICAgbWF0Y2ggeCwgeSB3aXRoXG4gICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHgsIFNvbWUgeSAtPiBTb21lIChmIHggeSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIEFwcGxpY2F0aXZlLk1ha2VfdXNpbmdfbWFwMl9sb2NhbCAoQXBwbGljYXRpdmVfYXJnKVxuIiwibW9kdWxlIExpc3QgPSBMaXN0XG5cbm1vZHVsZSBFbnVtZXJhYmxlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBhbGwgOiB0IGxpc3RcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBhbGwgOiAnYSBsaXN0IC0+ICdhIHQgbGlzdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGFsbCA6ICdhIGxpc3QgLT4gJ2IgbGlzdCAtPiAoJ2EsICdiKSB0IGxpc3RcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgYWxsIDogJ2EgbGlzdCAtPiAnYiBsaXN0IC0+ICdjIGxpc3QgLT4gKCdhLCAnYiwgJ2MpIHQgbGlzdFxuICBlbmRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5vcGVuIENvbnRhaW5lcl9pbnRmLkV4cG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgTGlzdCA9IExpc3QxXG5cbm1vZHVsZSBTdGVwID0gc3RydWN0XG4gICgqICdhIGlzIGFuIGl0ZW0gaW4gdGhlIHNlcXVlbmNlLCAncyBpcyB0aGUgc3RhdGUgdGhhdCB3aWxsIHByb2R1Y2UgdGhlIHJlbWFpbmRlciBvZlxuICAgICB0aGUgc2VxdWVuY2UgKilcbiAgdHlwZSAoJ2EsICdzKSB0ID1cbiAgICB8IERvbmVcbiAgICB8IFNraXAgb2YgeyBzdGF0ZSA6ICdzIH1cbiAgICB8IFlpZWxkIG9mXG4gICAgICAgIHsgdmFsdWUgOiAnYVxuICAgICAgICA7IHN0YXRlIDogJ3NcbiAgICAgICAgfVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAgICAgJ2EgJ3MuXG4gICAgICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgncyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnYSwgJ3MpIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wMTFfIHNfXzAxMl8pXG4gICAgICA6ICAoKGFfXzAxMV8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoc19fMDEyXyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoYV9fMDExXywgc19fMDEyXykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgZnVuIF9vZl9hX18wMDFfIF9vZl9zX18wMDJfIC0+IGZ1bmN0aW9uXG4gICAgfCBEb25lIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkRvbmVcIlxuICAgIHwgU2tpcCB7IHN0YXRlID0gc3RhdGVfXzAwNF8gfSAtPlxuICAgICAgbGV0IGJuZHNfXzAwM18gPSAoW10gOiBfIFN0ZGxpYi5MaXN0LnQpIGluXG4gICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgIGxldCBhcmdfXzAwNV8gPSBfb2Zfc19fMDAyXyBzdGF0ZV9fMDA0XyBpblxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwic3RhdGVcIjsgYXJnX18wMDVfIF0gOjogYm5kc19fMDAzX1xuICAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIFwiU2tpcFwiIDo6IGJuZHNfXzAwM18pXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gdmFsdWVfXzAwN187IHN0YXRlID0gc3RhdGVfXzAwOV8gfSAtPlxuICAgICAgbGV0IGJuZHNfXzAwNl8gPSAoW10gOiBfIFN0ZGxpYi5MaXN0LnQpIGluXG4gICAgICBsZXQgYm5kc19fMDA2XyA9XG4gICAgICAgIGxldCBhcmdfXzAxMF8gPSBfb2Zfc19fMDAyXyBzdGF0ZV9fMDA5XyBpblxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwic3RhdGVcIjsgYXJnX18wMTBfIF0gOjogYm5kc19fMDA2X1xuICAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgaW5cbiAgICAgIGxldCBibmRzX18wMDZfID1cbiAgICAgICAgbGV0IGFyZ19fMDA4XyA9IF9vZl9hX18wMDFfIHZhbHVlX18wMDdfIGluXG4gICAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJ2YWx1ZVwiOyBhcmdfXzAwOF8gXSA6OiBibmRzX18wMDZfXG4gICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gXCJZaWVsZFwiIDo6IGJuZHNfXzAwNl8pXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5vcGVuIFN0ZXBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgKCogJ2EgaXMgYW4gaXRlbSBpbiB0aGUgc2VxdWVuY2UsICdzIGlzIHRoZSBzdGF0ZSB0aGF0IHdpbGwgcHJvZHVjZSB0aGUgcmVtYWluZGVyIG9mIHRoZVxuICAgICBzZXF1ZW5jZSAqKVxuICB0eXBlICtfIHQgPVxuICAgIHwgU2VxdWVuY2UgOlxuICAgICAgICB7IHN0YXRlIDogJ3NcbiAgICAgICAgOyBuZXh0IDogJ3MgLT4gKCdhLCAncykgU3RlcC50XG4gICAgICAgIH1cbiAgICAgICAgLT4gJ2EgdFxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgZ2xvYmFsaXplIF8gKFNlcXVlbmNlIHsgc3RhdGU7IG5leHQgfSkgPSBTZXF1ZW5jZSB7IHN0YXRlOyBuZXh0IH1cblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBtb2R1bGUgVmlldyA9IFRcblxuICBsZXQgdmlldyB0ID0gdFxuXG4gIGxldCBuZXh0X3N0ZXAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0ID0gZiB9KSA9XG4gICAgbWF0Y2ggZiBzIHdpdGhcbiAgICB8IERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0ID0gZiB9IH1cbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgPSBmIH0gfVxuICA7O1xuXG4gIGxldCBkZWxheWVkX2ZvbGRfc3RlcCBzIH5pbml0IH5mIH5maW5pc2ggPVxuICAgIGxldCByZWMgbG9vcCBzIG5leHQgZmluaXNoIGYgYWNjID1cbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gZmluaXNoIGFjY1xuICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gZiBhY2MgTm9uZSB+azoobG9vcCBzIG5leHQgZmluaXNoIGYpXG4gICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBmIGFjYyAoU29tZSBhKSB+azoobG9vcCBzIG5leHQgZmluaXNoIGYpXG4gICAgaW5cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCBzIG5leHQgZmluaXNoIGYgaW5pdFxuICA7O1xuZW5kXG5cbmxldCB1bmZvbGRfc3RlcCB+aW5pdCB+ZiA9IFNlcXVlbmNlIHsgc3RhdGUgPSBpbml0OyBuZXh0ID0gZiB9XG5cbmxldCB1bmZvbGQgfmluaXQgfmYgPVxuICB1bmZvbGRfc3RlcCB+aW5pdCB+ZjooZnVuIHMgLT5cbiAgICBtYXRjaCBmIHMgd2l0aFxuICAgIHwgTm9uZSAtPiBTdGVwLkRvbmVcbiAgICB8IFNvbWUgKGEsIHMpIC0+IFN0ZXAuWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9KVxuOztcblxubGV0IHVuZm9sZF93aXRoIHMgfmluaXQgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBpbml0LCBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gKHNlZWQsIHMpIC0+XG4gICAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IHNlZWQsIHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGYgc2VlZCBhIHdpdGhcbiAgICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHNlZWQgfSAtPiBTa2lwIHsgc3RhdGUgPSBzZWVkLCBzIH1cbiAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gc2VlZCB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHNlZWQsIHMgfSkpXG4gICAgICB9XG47O1xuXG5sZXQgdW5mb2xkX3dpdGhfYW5kX2ZpbmlzaCBzIH5pbml0IH5ydW5uaW5nX3N0ZXAgfmlubmVyX2ZpbmlzaGVkIH5maW5pc2hpbmdfc3RlcCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IGBJbm5lcl9ydW5uaW5nIChpbml0LCBzKVxuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIHN0YXRlIC0+XG4gICAgICAgICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBuZXh0IGlubmVyX3N0YXRlIHdpdGhcbiAgICAgICAgICAgICAgIHwgRG9uZSAtPiBTa2lwIHsgc3RhdGUgPSBgSW5uZXJfZmluaXNoZWQgKGlubmVyX2ZpbmlzaGVkIHN0YXRlKSB9XG4gICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IGlubmVyX3N0YXRlIH0gLT5cbiAgICAgICAgICAgICAgICAgU2tpcCB7IHN0YXRlID0gYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkgfVxuICAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBpbm5lcl9zdGF0ZSB9IC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBydW5uaW5nX3N0ZXAgc3RhdGUgeCB3aXRoXG4gICAgICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgfSAtPiBTa2lwIHsgc3RhdGUgPSBgSW5uZXJfcnVubmluZyAoc3RhdGUsIGlubmVyX3N0YXRlKSB9XG4gICAgICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSB5OyBzdGF0ZSB9IC0+XG4gICAgICAgICAgICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSB5OyBzdGF0ZSA9IGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpIH0pKVxuICAgICAgICAgICAgfCBgSW5uZXJfZmluaXNoZWQgc3RhdGUgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGZpbmlzaGluZ19zdGVwIHN0YXRlIHdpdGhcbiAgICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSB9IC0+IFNraXAgeyBzdGF0ZSA9IGBJbm5lcl9maW5pc2hlZCBzdGF0ZSB9XG4gICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSB5OyBzdGF0ZSB9IC0+XG4gICAgICAgICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSB5OyBzdGF0ZSA9IGBJbm5lcl9maW5pc2hlZCBzdGF0ZSB9KSlcbiAgICAgIH1cbjs7XG5cbmxldCBvZl9saXN0IGwgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDpsIH5mOihmdW5jdGlvblxuICAgIHwgW10gLT4gRG9uZVxuICAgIHwgeCA6OiBsIC0+IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IGwgfSlcbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3Agc2VlZCB2IG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICB8IERvbmUgLT4gdlxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyB2IG5leHQgZlxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyAoZiB2IGEpIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBpbml0IG5leHQgZlxuOztcblxubGV0IHRvX2xpc3RfcmV2IHQgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biBsIHggLT4geCA6OiBsKVxuXG5sZXQgdG9fbGlzdCAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkgPVxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyB0b19saXN0IHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gW11cbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiAodG9fbGlzdCBbQHRhaWxjYWxsXSkgcyBuZXh0XG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gYSA6OiAodG9fbGlzdCBbQHRhaWxjYWxsXSkgcyBuZXh0XG4gIGluXG4gIHRvX2xpc3QgcyBuZXh0XG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfYSAodG9fbGlzdCB0KVxuXG5sZXQgcmFuZ2UgPyhzdHJpZGUgPSAxKSA/KHN0YXJ0ID0gYGluY2x1c2l2ZSkgPyhzdG9wID0gYGV4Y2x1c2l2ZSkgc3RhcnRfdiBzdG9wX3YgPVxuICBsZXQgc3RlcCA9XG4gICAgbWF0Y2ggc3RvcCB3aXRoXG4gICAgfCBgaW5jbHVzaXZlIHdoZW4gc3RyaWRlID49IDAgLT5cbiAgICAgIGZ1biBpIC0+IGlmIGkgPiBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgeyB2YWx1ZSA9IGk7IHN0YXRlID0gaSArIHN0cmlkZSB9XG4gICAgfCBgaW5jbHVzaXZlIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpIDwgc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIHsgdmFsdWUgPSBpOyBzdGF0ZSA9IGkgKyBzdHJpZGUgfVxuICAgIHwgYGV4Y2x1c2l2ZSB3aGVuIHN0cmlkZSA+PSAwIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpID49IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCB7IHZhbHVlID0gaTsgc3RhdGUgPSBpICsgc3RyaWRlIH1cbiAgICB8IGBleGNsdXNpdmUgLT5cbiAgICAgIGZ1biBpIC0+IGlmIGkgPD0gc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIHsgdmFsdWUgPSBpOyBzdGF0ZSA9IGkgKyBzdHJpZGUgfVxuICBpblxuICBsZXQgaW5pdCA9XG4gICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgIHwgYGluY2x1c2l2ZSAtPiBzdGFydF92XG4gICAgfCBgZXhjbHVzaXZlIC0+IHN0YXJ0X3YgKyBzdHJpZGVcbiAgaW5cbiAgdW5mb2xkX3N0ZXAgfmluaXQgfmY6c3RlcFxuOztcblxubGV0IG9mX2xhenkgdF9sYXp5ID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6dF9sYXp5IH5mOihmdW4gdF9sYXp5IC0+XG4gICAgbGV0IChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSA9IExhenkuZm9yY2UgdF9sYXp5IGluXG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+XG4gICAgICBTa2lwXG4gICAgICAgIHsgc3RhdGUgPVxuICAgICAgICAgICAgKGxldCB2ID0gU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSBpblxuICAgICAgICAgICAgIGxhenkgdilcbiAgICAgICAgfVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gcyB9IC0+XG4gICAgICBZaWVsZFxuICAgICAgICB7IHZhbHVlID0geFxuICAgICAgICA7IHN0YXRlID1cbiAgICAgICAgICAgIChsZXQgdiA9IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gaW5cbiAgICAgICAgICAgICBsYXp5IHYpXG4gICAgICAgIH0pXG47O1xuXG5sZXQgbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBzZWVkXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gc2VlZCAtPlxuICAgICAgICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBmIGE7IHN0YXRlID0gcyB9KVxuICAgICAgfVxuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IDAsIHNcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biAoaSwgcykgLT5cbiAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gaSwgcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gZiBpIGE7IHN0YXRlID0gaSArIDEsIHMgfSlcbiAgICAgIH1cbjs7XG5cbmxldCBmb2xkaW5nX21hcCB0IH5pbml0IH5mID1cbiAgdW5mb2xkX3dpdGggdCB+aW5pdCB+ZjooZnVuIGFjYyB4IC0+XG4gICAgbGV0IGFjYywgeCA9IGYgYWNjIHggaW5cbiAgICBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBhY2MgfSlcbjs7XG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIHVuZm9sZF93aXRoIHQgfmluaXQ6KDAsIGluaXQpIH5mOihmdW4gKGksIGFjYykgeCAtPlxuICAgIGxldCBhY2MsIHggPSBmIGkgYWNjIHggaW5cbiAgICBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBpICsgMSwgYWNjIH0pXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBzZWVkXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gc2VlZCAtPlxuICAgICAgICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IHdoZW4gZiBhIC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gcyB9KVxuICAgICAgfVxuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIG1hcCB+ZjpzbmQgKGZpbHRlciAobWFwaSB0IH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcykpXG47O1xuXG5sZXQgbGVuZ3RoIHQgPVxuICBsZXQgcmVjIGxvb3AgaSBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGlcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIGkgcyBuZXh0XG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gbG9vcCAoaSArIDEpIHMgbmV4dFxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3AgMCBzZWVkIG5leHRcbjs7XG5cbmxldCB0b19saXN0X3Jldl93aXRoX2xlbmd0aCB0ID0gZm9sZCB0IH5pbml0OihbXSwgMCkgfmY6KGZ1biAobCwgaSkgeCAtPiB4IDo6IGwsIGkgKyAxKVxuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIGxldCBsLCBsZW4gPSB0b19saXN0X3Jldl93aXRoX2xlbmd0aCB0IGluXG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCB4IDo6IGwgLT5cbiAgICBsZXQgYSA9IEFycmF5LmNyZWF0ZSB+bGVuIHggaW5cbiAgICBsZXQgcmVjIGxvb3AgaSBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSAtMSlcbiAgICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIGEuKGkpIDwtIHg7XG4gICAgICAgIGxvb3AgKGkgLSAxKSBsXG4gICAgaW5cbiAgICBsb29wIChsZW4gLSAyKSBsO1xuICAgIGFcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IF8gfSB3aGVuIGYgYSAtPiBTb21lIGFcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgKG1hdGNoIGYgYSB3aXRoXG4gICAgICAgfCBOb25lIC0+IGxvb3AgcyBuZXh0IGZcbiAgICAgICB8IHNvbWVfYiAtPiBzb21lX2IpXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBpID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIChtYXRjaCBmIGkgYSB3aXRoXG4gICAgICAgfCBOb25lIC0+IGxvb3AgcyBuZXh0IGYgKGkgKyAxKVxuICAgICAgIHwgc29tZV9iIC0+IHNvbWVfYilcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIGlcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmIDBcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IHRydWVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IF8gfSB3aGVuIG5vdCAoZiBhKSAtPiBmYWxzZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBpID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBfIH0gd2hlbiBub3QgKGYgaSBhKSAtPiBmYWxzZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGYgKGkgKyAxKVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IGYgMFxuOztcblxubGV0IGV4aXN0cyB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gXyB9IHdoZW4gZiBhIC0+IHRydWVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBpID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gXyB9IHdoZW4gZiBpIGEgLT4gdHJ1ZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGYgKGkgKyAxKVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IGYgMFxuOztcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzZWVkIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICB8IERvbmUgLT4gKClcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIGYgYTtcbiAgICAgIGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgaXNfZW1wdHkgdCA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IHRydWVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgXyAtPiBmYWxzZVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGEgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZhbHNlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBfIH0gd2hlbiBlcXVhbCBhIGIgLT4gdHJ1ZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGFcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBhIFtAbm9udGFpbF1cbjs7XG5cbmxldCBlbXB0eSA9IFNlcXVlbmNlIHsgc3RhdGUgPSAoKTsgbmV4dCA9IChmdW4gKCkgLT4gRG9uZSkgfVxuXG5sZXQgYmluZCB0IH5mID1cbiAgdW5mb2xkX3N0ZXBcbiAgICB+ZjooZnVuY3Rpb25cbiAgICAgIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSwgcmVzdCAtPlxuICAgICAgICAobWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgIHwgRG9uZSAtPlxuICAgICAgICAgICAobWF0Y2ggcmVzdCB3aXRoXG4gICAgICAgICAgICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT5cbiAgICAgICAgICAgICAgKG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT5cbiAgICAgICAgICAgICAgICAgU2tpcCB7IHN0YXRlID0gZW1wdHksIFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gfVxuICAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgICAgICAgICAgICAgU2tpcCB7IHN0YXRlID0gZiBhLCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IH0pKVxuICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSwgcmVzdCB9XG4gICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgICBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9LCByZXN0IH0pKVxuICAgIH5pbml0OihlbXB0eSwgdClcbjs7XG5cbmxldCByZXR1cm4geCA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OihTb21lIHgpIH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBEb25lXG4gICAgfCBTb21lIHggLT4gWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gTm9uZSB9KVxuOztcblxuaW5jbHVkZSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgbGV0IGJpbmQgPSBiaW5kXG4gIGxldCByZXR1cm4gPSByZXR1cm5cbmVuZClcblxubGV0IG50aCBzIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIGkgcyBuZXh0ID1cbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gTm9uZVxuICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBpIHMgbmV4dFxuICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgICAgaWYgcGh5c19lcXVhbCBpIDAgdGhlbiBTb21lIGEgZWxzZSBsb29wIChpIC0gMSkgcyBuZXh0XG4gICAgaW5cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCBuIHMgbmV4dClcbjs7XG5cbmxldCBudGhfZXhuIHMgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTZXF1ZW5jZS5udGhcIlxuICBlbHNlIChcbiAgICBtYXRjaCBudGggcyBuIHdpdGhcbiAgICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXF1ZW5jZS5udGhcIlxuICAgIHwgU29tZSB4IC0+IHgpXG47O1xuXG5tb2R1bGUgTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB8IExlZnQgb2YgJ2FcbiAgICB8IFJpZ2h0IG9mICdiXG4gICAgfCBCb3RoIG9mICdhICogJ2JcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgOlxuICAgICAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGludCkgLT4gKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAyM18gYl9fMDI0XyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDIzXyBiX18wMjRfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMjNfLCBiX18wMjRfIHdpdGhcbiAgICAgIHwgTGVmdCBfYV9fMDI1XywgTGVmdCBfYl9fMDI2XyAtPiBfY21wX19hIF9hX18wMjVfIF9iX18wMjZfXG4gICAgICB8IExlZnQgXywgXyAtPiAtMVxuICAgICAgfCBfLCBMZWZ0IF8gLT4gMVxuICAgICAgfCBSaWdodCBfYV9fMDI3XywgUmlnaHQgX2JfXzAyOF8gLT4gX2NtcF9fYiBfYV9fMDI3XyBfYl9fMDI4X1xuICAgICAgfCBSaWdodCBfLCBfIC0+IC0xXG4gICAgICB8IF8sIFJpZ2h0IF8gLT4gMVxuICAgICAgfCBCb3RoIChfYV9fMDI5XywgX2FfXzAzMV8pLCBCb3RoIChfYl9fMDMwXywgX2JfXzAzMl8pIC0+XG4gICAgICAgIChtYXRjaCBfY21wX19hIF9hX18wMjlfIF9iX18wMzBfIHdpdGhcbiAgICAgICAgIHwgMCAtPiBfY21wX19iIF9hX18wMzFfIF9iX18wMzJfXG4gICAgICAgICB8IG4gLT4gbikpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGludCkgLT4gKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAxM18gYl9fMDE0XyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDEzXyBiX18wMTRfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMTNfLCBiX18wMTRfIHdpdGhcbiAgICAgIHwgTGVmdCBfYV9fMDE1XywgTGVmdCBfYl9fMDE2XyAtPiBfY21wX19hIF9hX18wMTVfIF9iX18wMTZfXG4gICAgICB8IExlZnQgXywgXyAtPiAtMVxuICAgICAgfCBfLCBMZWZ0IF8gLT4gMVxuICAgICAgfCBSaWdodCBfYV9fMDE3XywgUmlnaHQgX2JfXzAxOF8gLT4gX2NtcF9fYiBfYV9fMDE3XyBfYl9fMDE4X1xuICAgICAgfCBSaWdodCBfLCBfIC0+IC0xXG4gICAgICB8IF8sIFJpZ2h0IF8gLT4gMVxuICAgICAgfCBCb3RoIChfYV9fMDE5XywgX2FfXzAyMV8pLCBCb3RoIChfYl9fMDIwXywgX2JfXzAyMl8pIC0+XG4gICAgICAgIChtYXRjaCBfY21wX19hIF9hX18wMTlfIF9iX18wMjBfIHdpdGhcbiAgICAgICAgIHwgMCAtPiBfY21wX19iIF9hX18wMjFfIF9iX18wMjJfXG4gICAgICAgICB8IG4gLT4gbikpXG4gIDs7XG5cbiAgbGV0IGVxdWFsX19sb2NhbCA6XG4gICAgICAgICdhICdiLlxuICAgICAgICAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBib29sXG4gICAgPVxuICAgIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDQzXyBiX18wNDRfIC0+XG4gICAgaWYgU3RkbGliLiggPT0gKSBhX18wNDNfIGJfXzA0NF9cbiAgICB0aGVuIHRydWVcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzA0M18sIGJfXzA0NF8gd2l0aFxuICAgICAgfCBMZWZ0IF9hX18wNDVfLCBMZWZ0IF9iX18wNDZfIC0+IF9jbXBfX2EgX2FfXzA0NV8gX2JfXzA0Nl9cbiAgICAgIHwgTGVmdCBfLCBfIC0+IGZhbHNlXG4gICAgICB8IF8sIExlZnQgXyAtPiBmYWxzZVxuICAgICAgfCBSaWdodCBfYV9fMDQ3XywgUmlnaHQgX2JfXzA0OF8gLT4gX2NtcF9fYiBfYV9fMDQ3XyBfYl9fMDQ4X1xuICAgICAgfCBSaWdodCBfLCBfIC0+IGZhbHNlXG4gICAgICB8IF8sIFJpZ2h0IF8gLT4gZmFsc2VcbiAgICAgIHwgQm90aCAoX2FfXzA0OV8sIF9hX18wNTFfKSwgQm90aCAoX2JfXzA1MF8sIF9iX18wNTJfKSAtPlxuICAgICAgICBTdGRsaWIuKCAmJiApIChfY21wX19hIF9hX18wNDlfIF9iX18wNTBfKSAoX2NtcF9fYiBfYV9fMDUxXyBfYl9fMDUyXykpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIDpcbiAgICAgICAgJ2EgJ2IuXG4gICAgICAgICgnYSAtPiAnYSAtPiBib29sKSAtPiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgICA9XG4gICAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wMzNfIGJfXzAzNF8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAzM18gYl9fMDM0X1xuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDMzXywgYl9fMDM0XyB3aXRoXG4gICAgICB8IExlZnQgX2FfXzAzNV8sIExlZnQgX2JfXzAzNl8gLT4gX2NtcF9fYSBfYV9fMDM1XyBfYl9fMDM2X1xuICAgICAgfCBMZWZ0IF8sIF8gLT4gZmFsc2VcbiAgICAgIHwgXywgTGVmdCBfIC0+IGZhbHNlXG4gICAgICB8IFJpZ2h0IF9hX18wMzdfLCBSaWdodCBfYl9fMDM4XyAtPiBfY21wX19iIF9hX18wMzdfIF9iX18wMzhfXG4gICAgICB8IFJpZ2h0IF8sIF8gLT4gZmFsc2VcbiAgICAgIHwgXywgUmlnaHQgXyAtPiBmYWxzZVxuICAgICAgfCBCb3RoIChfYV9fMDM5XywgX2FfXzA0MV8pLCBCb3RoIChfYl9fMDQwXywgX2JfXzA0Ml8pIC0+XG4gICAgICAgIFN0ZGxpYi4oICYmICkgKF9jbXBfX2EgX2FfXzAzOV8gX2JfXzA0MF8pIChfY21wX19iIF9hX18wNDFfIF9iX18wNDJfKSlcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX3RcbiAgICA6IHR5cGUgYSBiLlxuICAgICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAgIC0+IChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAgIC0+IChhLCBiKSB0XG4gICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICA9XG4gICAgZnVuIF9oYXNoX2ZvbGRfYSBfaGFzaF9mb2xkX2IgaHN2IGFyZyAtPlxuICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgfCBMZWZ0IF9hMCAtPlxuICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMCBpblxuICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgICB8IFJpZ2h0IF9hMCAtPlxuICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgX2hhc2hfZm9sZF9iIGhzdiBfYTBcbiAgICB8IEJvdGggKF9hMCwgX2ExKSAtPlxuICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMiBpblxuICAgICAgbGV0IGhzdiA9XG4gICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgICAgIGluXG4gICAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMVxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgOlxuICAgICAgICAnYSAnYi5cbiAgICAgICAgKFNleHBsaWIwLlNleHAudCAtPiAnYSlcbiAgICAgICAgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYilcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgICAgIC0+ICgnYSwgJ2IpIHRcbiAgICA9XG4gICAgZnVuICh0eXBlIGFfXzA3Nl8gYl9fMDc3XylcbiAgICAgIDogICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzA3Nl8pIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gYl9fMDc3XykgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgICAtPiAoYV9fMDc2XywgYl9fMDc3XykgdCkgLT5cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wNTdfID0gXCJzZXF1ZW5jZS5tbC5NZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudC50XCIgaW5cbiAgICBmdW4gX29mX2FfXzA1M18gX29mX2JfXzA1NF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwibGVmdFwiIHwgXCJMZWZ0XCIpIGFzIF90YWdfXzA2MF8pIDo6IHNleHBfYXJnc19fMDYxXykgYXNcbiAgICAgICAgX3NleHBfXzA1OV8gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDYxXyB3aXRoXG4gICAgICAgICB8IGFyZzBfXzA2Ml8gOjogW10gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzA2M18gPSBfb2ZfYV9fMDUzXyBhcmcwX18wNjJfIGluXG4gICAgICAgICAgIExlZnQgcmVzMF9fMDYzX1xuICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICBfdGFnX18wNjBfXG4gICAgICAgICAgICAgX3NleHBfXzA1OV8pXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcInJpZ2h0XCIgfCBcIlJpZ2h0XCIpIGFzIF90YWdfXzA2NV8pIDo6IHNleHBfYXJnc19fMDY2XykgYXNcbiAgICAgICAgX3NleHBfXzA2NF8gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDY2XyB3aXRoXG4gICAgICAgICB8IGFyZzBfXzA2N18gOjogW10gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzA2OF8gPSBfb2ZfYl9fMDU0XyBhcmcwX18wNjdfIGluXG4gICAgICAgICAgIFJpZ2h0IHJlczBfXzA2OF9cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgX3RhZ19fMDY1X1xuICAgICAgICAgICAgIF9zZXhwX18wNjRfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJib3RoXCIgfCBcIkJvdGhcIikgYXMgX3RhZ19fMDcwXykgOjogc2V4cF9hcmdzX18wNzFfKSBhc1xuICAgICAgICBfc2V4cF9fMDY5XyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wNzFfIHdpdGhcbiAgICAgICAgIHwgWyBhcmcwX18wNzJfOyBhcmcxX18wNzNfIF0gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzA3NF8gPSBfb2ZfYV9fMDUzXyBhcmcwX18wNzJfXG4gICAgICAgICAgIGFuZCByZXMxX18wNzVfID0gX29mX2JfXzA1NF8gYXJnMV9fMDczXyBpblxuICAgICAgICAgICBCb3RoIChyZXMwX18wNzRfLCByZXMxX18wNzVfKVxuICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICBfdGFnX18wNzBfXG4gICAgICAgICAgICAgX3NleHBfXzA2OV8pXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJsZWZ0XCIgfCBcIkxlZnRcIikgYXMgc2V4cF9fMDU4XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBzZXhwX18wNThfXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJyaWdodFwiIHwgXCJSaWdodFwiKSBhcyBzZXhwX18wNThfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIHNleHBfXzA1OF9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImJvdGhcIiB8IFwiQm90aFwiKSBhcyBzZXhwX18wNThfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIHNleHBfXzA1OF9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wNTZfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzA1N18gc2V4cF9fMDU2X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDU2XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzA1N18gc2V4cF9fMDU2X1xuICAgICAgfCBzZXhwX18wNTZfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wNTdfIHNleHBfXzA1Nl9cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAgICAgJ2EgJ2IuXG4gICAgICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wODhfIGJfXzA4OV8pXG4gICAgICA6ICAoKGFfXzA4OF8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoYl9fMDg5XyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoYV9fMDg4XywgYl9fMDg5XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgZnVuIF9vZl9hX18wNzhfIF9vZl9iX18wNzlfIC0+IGZ1bmN0aW9uXG4gICAgfCBMZWZ0IGFyZzBfXzA4MF8gLT5cbiAgICAgIGxldCByZXMwX18wODFfID0gX29mX2FfXzA3OF8gYXJnMF9fMDgwXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVmdFwiOyByZXMwX18wODFfIF1cbiAgICB8IFJpZ2h0IGFyZzBfXzA4Ml8gLT5cbiAgICAgIGxldCByZXMwX18wODNfID0gX29mX2JfXzA3OV8gYXJnMF9fMDgyXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiUmlnaHRcIjsgcmVzMF9fMDgzXyBdXG4gICAgfCBCb3RoIChhcmcwX18wODRfLCBhcmcxX18wODVfKSAtPlxuICAgICAgbGV0IHJlczBfXzA4Nl8gPSBfb2ZfYV9fMDc4XyBhcmcwX18wODRfXG4gICAgICBhbmQgcmVzMV9fMDg3XyA9IF9vZl9iX18wNzlfIGFyZzFfXzA4NV8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkJvdGhcIjsgcmVzMF9fMDg2XzsgcmVzMV9fMDg3XyBdXG4gIDs7XG5cbiAgbGV0IHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgJ2EgJ2IuXG4gICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICAgIHsgdW50eXBlZCA9XG4gICAgICAgIFZhcmlhbnRcbiAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiTGVmdFwiXG4gICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiQm90aFwiXG4gICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubGV0IG1lcmdlX3dpdGhfZHVwbGljYXRlc1xuICAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMxOyBuZXh0ID0gbmV4dDEgfSlcbiAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMjsgbmV4dCA9IG5leHQyIH0pXG4gIH5jb21wYXJlXG4gID1cbiAgbGV0IHVuc2hhZG93ZWRfY29tcGFyZSA9IGNvbXBhcmUgaW5cbiAgbGV0IG9wZW4gTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnQgaW5cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgU2tpcCB7IHN0YXRlID0gczEgfSwgczIgLT4gU2tpcCB7IHN0YXRlID0gbmV4dDEgczEsIHMyIH1cbiAgICB8IHMxLCBTa2lwIHsgc3RhdGUgPSBzMiB9IC0+IFNraXAgeyBzdGF0ZSA9IHMxLCBuZXh0MiBzMiB9XG4gICAgfCAoWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczEnIH0gYXMgczEpLCAoWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gczInIH0gYXMgczIpXG4gICAgICAtPlxuICAgICAgbGV0IGNvbXBhcmlzb24gPSB1bnNoYWRvd2VkX2NvbXBhcmUgYSBiIGluXG4gICAgICBpZiBjb21wYXJpc29uIDwgMFxuICAgICAgdGhlbiBZaWVsZCB7IHZhbHVlID0gTGVmdCBhOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxJyB9LCBzMiB9XG4gICAgICBlbHNlIGlmIGNvbXBhcmlzb24gPSAwXG4gICAgICB0aGVuXG4gICAgICAgIFlpZWxkIHsgdmFsdWUgPSBCb3RoIChhLCBiKTsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMScgfSwgU2tpcCB7IHN0YXRlID0gczInIH0gfVxuICAgICAgZWxzZSBZaWVsZCB7IHZhbHVlID0gUmlnaHQgYjsgc3RhdGUgPSBzMSwgU2tpcCB7IHN0YXRlID0gczInIH0gfVxuICAgIHwgRG9uZSwgRG9uZSAtPiBEb25lXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMSB9LCBEb25lIC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gTGVmdCBhOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIERvbmUgfVxuICAgIHwgRG9uZSwgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gczIgfSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IFJpZ2h0IGI7IHN0YXRlID0gRG9uZSwgU2tpcCB7IHN0YXRlID0gczIgfSB9XG4gIGluXG4gIFNlcXVlbmNlIHsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBTa2lwIHsgc3RhdGUgPSBzMiB9OyBuZXh0IH1cbjs7XG5cbmxldCBtZXJnZV9kZWR1cGVkX2FuZF9zb3J0ZWQgczEgczIgfmNvbXBhcmUgPVxuICBtYXAgKG1lcmdlX3dpdGhfZHVwbGljYXRlcyBzMSBzMiB+Y29tcGFyZSkgfmY6KGZ1bmN0aW9uXG4gICAgfCBMZWZ0IHggfCBSaWdodCB4IHwgQm90aCAoeCwgXykgLT4geClcbjs7XG5cbmxldCBtZXJnZV9zb3J0ZWRcbiAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMTsgbmV4dCA9IG5leHQxIH0pXG4gIChTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBuZXh0MiB9KVxuICB+Y29tcGFyZVxuICA9XG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMxIH0sIHMyIC0+IFNraXAgeyBzdGF0ZSA9IG5leHQxIHMxLCBzMiB9XG4gICAgfCBzMSwgU2tpcCB7IHN0YXRlID0gczIgfSAtPiBTa2lwIHsgc3RhdGUgPSBzMSwgbmV4dDIgczIgfVxuICAgIHwgKFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxJyB9IGFzIHMxKSwgKFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyJyB9IGFzIHMyKVxuICAgICAgLT5cbiAgICAgIGxldCBjb21wYXJpc29uID0gY29tcGFyZSBhIGIgaW5cbiAgICAgIGlmIGNvbXBhcmlzb24gPD0gMFxuICAgICAgdGhlbiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMScgfSwgczIgfVxuICAgICAgZWxzZSBZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBzMSwgU2tpcCB7IHN0YXRlID0gczInIH0gfVxuICAgIHwgRG9uZSwgRG9uZSAtPiBEb25lXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMSB9LCBEb25lIC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBEb25lIH1cbiAgICB8IERvbmUsIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IERvbmUsIFNraXAgeyBzdGF0ZSA9IHMyIH0gfVxuICBpblxuICBTZXF1ZW5jZSB7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEgfSwgU2tpcCB7IHN0YXRlID0gczIgfTsgbmV4dCB9XG47O1xuXG5sZXQgaGQgcyA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gXyB9IC0+IFNvbWUgYVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgcyBuZXh0XG47O1xuXG5sZXQgaGRfZXhuIHMgPVxuICBtYXRjaCBoZCBzIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiaGRfZXhuXCJcbiAgfCBTb21lIGEgLT4gYVxuOztcblxubGV0IHRsIHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IGEgfSAtPiBTb21lIGFcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIChtYXRjaCBsb29wIHMgbmV4dCB3aXRoXG4gICAgIHwgTm9uZSAtPiBOb25lXG4gICAgIHwgU29tZSBzIC0+IFNvbWUgKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pKVxuOztcblxubGV0IHRsX2VhZ2VybHlfZXhuIHMgPVxuICBtYXRjaCB0bCBzIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UudGxfZXhuXCJcbiAgfCBTb21lIHMgLT4gc1xuOztcblxubGV0IGxpZnRfaWRlbnRpdHkgbmV4dCBzID1cbiAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgfCBEb25lIC0+IERvbmVcbiAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gYElkZW50aXR5IHMgfVxuICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBgSWRlbnRpdHkgcyB9XG47O1xuXG5sZXQgbmV4dCBzID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gU29tZSAoYSwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSlcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPiBsb29wIHMgbmV4dFxuOztcblxubGV0IGZpbHRlcl9vcHQgcyA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IHNcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biBzIC0+XG4gICAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gTm9uZTsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBTb21lIGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSlcbiAgICAgIH1cbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHMgfmYgPSBmaWx0ZXJfb3B0IChtYXAgcyB+ZilcbmxldCBmaWx0ZXJfbWFwaSBzIH5mID0gZmlsdGVyX21hcCAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcylcblxubGV0IHNwbGl0X24gcyBuID1cbiAgbGV0IHJlYyBsb29wIHMgaSBhY2N1bSBuZXh0ID1cbiAgICBpZiBpIDw9IDBcbiAgICB0aGVuIExpc3QucmV2IGFjY3VtLCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9XG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IExpc3QucmV2IGFjY3VtLCBlbXB0eVxuICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIGkgYWNjdW0gbmV4dFxuICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIChpIC0gMSkgKGEgOjogYWNjdW0pIG5leHQpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCBzIG4gW10gbmV4dFxuOztcblxubGV0IGNodW5rc19leG4gdCBuID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTZXF1ZW5jZS5jaHVua3NfZXhuXCJcbiAgZWxzZVxuICAgIHVuZm9sZF9zdGVwIH5pbml0OnQgfmY6KGZ1biB0IC0+XG4gICAgICBtYXRjaCBzcGxpdF9uIHQgbiB3aXRoXG4gICAgICB8IFtdLCBfZW1wdHkgLT4gRG9uZVxuICAgICAgfCAoXyA6OiBfIGFzIHhzKSwgdCAtPiBZaWVsZCB7IHZhbHVlID0geHM7IHN0YXRlID0gdCB9KVxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGkgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gXyB9IHdoZW4gZiBpIGEgLT4gU29tZSAoaSwgYSlcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCAoaSArIDEpIGZcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBpIGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCAwIGZcbjs7XG5cbmxldCBmaW5kX2V4biBzIH5mID1cbiAgbWF0Y2ggZmluZCBzIH5mIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UuZmluZF9leG5cIlxuICB8IFNvbWUgeCAtPiB4XG47O1xuXG5sZXQgYXBwZW5kIHMxIHMyID1cbiAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczE7IG5leHQgPSBuZXh0MSB9LCBTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBuZXh0MiB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBgRmlyc3RfbGlzdCBzMVxuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgfCBgRmlyc3RfbGlzdCBzMSAtPlxuICAgICAgICAgICAgIChtYXRjaCBuZXh0MSBzMSB3aXRoXG4gICAgICAgICAgICAgIHwgRG9uZSAtPiBTa2lwIHsgc3RhdGUgPSBgU2Vjb25kX2xpc3QgczIgfVxuICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMxIH0gLT4gU2tpcCB7IHN0YXRlID0gYEZpcnN0X2xpc3QgczEgfVxuICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxIH0gLT5cbiAgICAgICAgICAgICAgICBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBgRmlyc3RfbGlzdCBzMSB9KVxuICAgICAgICAgICB8IGBTZWNvbmRfbGlzdCBzMiAtPlxuICAgICAgICAgICAgIChtYXRjaCBuZXh0MiBzMiB3aXRoXG4gICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gczIgfSAtPiBTa2lwIHsgc3RhdGUgPSBgU2Vjb25kX2xpc3QgczIgfVxuICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgICAgICAgICAgICBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBgU2Vjb25kX2xpc3QgczIgfSkpXG4gICAgICB9XG47O1xuXG5sZXQgY29uY2F0X21hcCBzIH5mID0gYmluZCBzIH5mXG5sZXQgY29uY2F0IHMgPSBjb25jYXRfbWFwIHMgfmY6Rm4uaWRcbmxldCBjb25jYXRfbWFwaSBzIH5mID0gY29uY2F0X21hcCAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcylcblxubGV0IHppcCAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMxOyBuZXh0ID0gbmV4dDEgfSkgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMjsgbmV4dCA9IG5leHQyIH0pID1cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczEgfSwgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gczIgfSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IGEsIGI7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEgfSwgU2tpcCB7IHN0YXRlID0gczIgfSB9XG4gICAgfCBEb25lLCBfIHwgXywgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzMSB9LCBzMiAtPiBTa2lwIHsgc3RhdGUgPSBuZXh0MSBzMSwgczIgfVxuICAgIHwgczEsIFNraXAgeyBzdGF0ZSA9IHMyIH0gLT4gU2tpcCB7IHN0YXRlID0gczEsIG5leHQyIHMyIH1cbiAgaW5cbiAgU2VxdWVuY2UgeyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIFNraXAgeyBzdGF0ZSA9IHMyIH07IG5leHQgfVxuOztcblxubGV0IHppcF9mdWxsXG4gIChTZXF1ZW5jZSB7IHN0YXRlID0gczE7IG5leHQgPSBuZXh0MSB9KVxuICAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gbmV4dDIgfSlcbiAgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMSB9LCBZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gYEJvdGggKGEsIGIpOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIFNraXAgeyBzdGF0ZSA9IHMyIH0gfVxuICAgIHwgRG9uZSwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzMSB9LCBzMiAtPiBTa2lwIHsgc3RhdGUgPSBuZXh0MSBzMSwgczIgfVxuICAgIHwgczEsIFNraXAgeyBzdGF0ZSA9IHMyIH0gLT4gU2tpcCB7IHN0YXRlID0gczEsIG5leHQyIHMyIH1cbiAgICB8IERvbmUsIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBgUmlnaHQgYjsgc3RhdGUgPSBEb25lLCBuZXh0MiBzMiB9XG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMSB9LCBEb25lIC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gYExlZnQgYTsgc3RhdGUgPSBuZXh0MSBzMSwgRG9uZSB9XG4gIGluXG4gIFNlcXVlbmNlIHsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBTa2lwIHsgc3RhdGUgPSBzMiB9OyBuZXh0IH1cbjs7XG5cbmxldCBib3VuZGVkX2xlbmd0aCAoU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSkgfmF0X21vc3QgPVxuICBsZXQgcmVjIGxvb3AgaSBzZWVkIG5leHQgPVxuICAgIGlmIGkgPiBhdF9tb3N0XG4gICAgdGhlbiBgR3JlYXRlclxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBgSXMgaVxuICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzZWVkIH0gLT4gbG9vcCBpIHNlZWQgbmV4dFxuICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzZWVkIH0gLT4gbG9vcCAoaSArIDEpIHNlZWQgbmV4dClcbiAgaW5cbiAgbG9vcCAwIHNlZWQgbmV4dFxuOztcblxubGV0IGxlbmd0aF9pc19ib3VuZGVkX2J5ID8obWluID0gLTEpID9tYXggdCA9XG4gIGxldCBsZW5ndGhfaXNfYXRfbGVhc3QgKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pID1cbiAgICBsZXQgcmVjIGxvb3AgcyBhY2MgPVxuICAgICAgaWYgYWNjID49IG1pblxuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IGZhbHNlXG4gICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBhY2NcbiAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIChhY2MgKyAxKSlcbiAgICBpblxuICAgIGxvb3AgcyAwXG4gIGluXG4gIG1hdGNoIG1heCB3aXRoXG4gIHwgTm9uZSAtPiBsZW5ndGhfaXNfYXRfbGVhc3QgdFxuICB8IFNvbWUgbWF4IC0+XG4gICAgKG1hdGNoIGJvdW5kZWRfbGVuZ3RoIHQgfmF0X21vc3Q6bWF4IHdpdGhcbiAgICAgfCBgSXMgbGVuIHdoZW4gbGVuID49IG1pbiAtPiB0cnVlXG4gICAgIHwgXyAtPiBmYWxzZSlcbjs7XG5cbmxldCBpdGVyaSBzIH5mID0gaXRlciAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcykgW0Bub250YWlsXVxuXG5sZXQgZm9sZGkgcyB+aW5pdCB+ZiA9XG4gIGZvbGQgfmluaXQgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biBhY2MgKGksIHMpIC0+IGYgaSBhY2MgcykgW0Bub250YWlsXVxuOztcblxubGV0IHJlZHVjZSBzIH5mID1cbiAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIChhLCBzKSAtPiBTb21lIChmb2xkIHMgfmluaXQ6YSB+Zilcbjs7XG5cbmxldCByZWR1Y2VfZXhuIHMgfmYgPVxuICBtYXRjaCByZWR1Y2UgcyB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLnJlZHVjZV9leG5cIlxuICB8IFNvbWUgcmVzIC0+IHJlc1xuOztcblxubGV0IGdyb3VwIChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSB+YnJlYWsgPVxuICB1bmZvbGRfc3RlcFxuICAgIH5pbml0OihTb21lIChbXSwgcykpXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gRG9uZVxuICAgICAgfCBTb21lIChhY2MsIHMpIC0+XG4gICAgICAgIChtYXRjaCBhY2MsIG5leHQgcyB3aXRoXG4gICAgICAgICB8IF8sIFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBTb21lIChhY2MsIHMpIH1cbiAgICAgICAgIHwgW10sIERvbmUgLT4gRG9uZVxuICAgICAgICAgfCBhY2MsIERvbmUgLT4gWWllbGQgeyB2YWx1ZSA9IExpc3QucmV2IGFjYzsgc3RhdGUgPSBOb25lIH1cbiAgICAgICAgIHwgW10sIFlpZWxkIHsgdmFsdWUgPSBjdXI7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IFNvbWUgKFsgY3VyIF0sIHMpIH1cbiAgICAgICAgIHwgKHByZXYgOjogXyBhcyBhY2MpLCBZaWVsZCB7IHZhbHVlID0gY3VyOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgICBpZiBicmVhayBwcmV2IGN1clxuICAgICAgICAgICB0aGVuIFlpZWxkIHsgdmFsdWUgPSBMaXN0LnJldiBhY2M7IHN0YXRlID0gU29tZSAoWyBjdXIgXSwgcykgfVxuICAgICAgICAgICBlbHNlIFNraXAgeyBzdGF0ZSA9IFNvbWUgKGN1ciA6OiBhY2MsIHMpIH0pKVxuOztcblxubGV0IGZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgbGFzdF9lbHQgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgbGFzdF9lbHQgc1xuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAobWF0Y2ggbGFzdF9lbHQgd2l0aFxuICAgICAgIHwgU29tZSBiIHdoZW4gZXF1YWwgYSBiIC0+IFNvbWUgKGIsIGEpXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IGxvb3AgKFNvbWUgYSkgcylcbiAgaW5cbiAgbG9vcCBOb25lIHMgW0Bub250YWlsXVxuOztcblxubGV0IHJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzIHMgfmVxdWFsID1cbiAgdW5mb2xkX3dpdGggcyB+aW5pdDpOb25lIH5mOihmdW4gcHJldiBhIC0+XG4gICAgbWF0Y2ggcHJldiB3aXRoXG4gICAgfCBTb21lIGIgd2hlbiBlcXVhbCBhIGIgLT4gU2tpcCB7IHN0YXRlID0gU29tZSBhIH1cbiAgICB8IE5vbmUgfCBTb21lIF8gLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gU29tZSBhIH0pXG47O1xuXG5sZXQgY291bnQgcyB+ZiA9IGZvbGQgcyB+aW5pdDowIH5mOihmdW4gYWNjIGVsdCAtPiBhY2MgKyBCb29sLnRvX2ludCAoZiBlbHQpKSBbQG5vbnRhaWxdXG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGkgYWNjIGVsdCAtPiBhY2MgKyBCb29sLnRvX2ludCAoZiBpIGVsdCkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG5sZXQgaW5pdCBuIH5mID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6MCB+ZjooZnVuIGkgLT5cbiAgICBpZiBpID49IG4gdGhlbiBEb25lIGVsc2UgWWllbGQgeyB2YWx1ZSA9IGYgaTsgc3RhdGUgPSBpICsgMSB9KVxuOztcblxubGV0IHN1YiBzIH5wb3MgfmxlbiA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2Uuc3ViXCI7XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IDAsIHNcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biAoaSwgcykgLT5cbiAgICAgICAgICAgIGlmIGkgLSBwb3MgPj0gbGVuXG4gICAgICAgICAgICB0aGVuIERvbmVcbiAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBpLCBzIH1cbiAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gd2hlbiBpID49IHBvcyAtPlxuICAgICAgICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGkgKyAxLCBzIH1cbiAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gaSArIDEsIHMgfSkpXG4gICAgICB9XG47O1xuXG5sZXQgdGFrZSBzIGxlbiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLnRha2VcIjtcbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gMCwgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIChpLCBzKSAtPlxuICAgICAgICAgICAgaWYgaSA+PSBsZW5cbiAgICAgICAgICAgIHRoZW4gRG9uZVxuICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGksIHMgfVxuICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBpICsgMSwgcyB9KSlcbiAgICAgIH1cbjs7XG5cbmxldCBkcm9wIHMgbGVuID1cbiAgaWYgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2UuZHJvcFwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSAwLCBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gKGksIHMpIC0+XG4gICAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGksIHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gd2hlbiBpID49IGxlbiAtPlxuICAgICAgICAgICAgICBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBpICsgMSwgcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBpICsgMSwgcyB9KVxuICAgICAgfVxuOztcblxubGV0IHRha2Vfd2hpbGUgcyB+ZiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IHNcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biBzIC0+XG4gICAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gd2hlbiBmIGEgLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IF8gfSAtPiBEb25lKVxuICAgICAgfVxuOztcblxubGV0IGRyb3Bfd2hpbGUgcyB+ZiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IGBEcm9wcGluZyBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW5jdGlvblxuICAgICAgICAgICB8IGBEcm9wcGluZyBzIC0+XG4gICAgICAgICAgICAgKG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGBEcm9wcGluZyBzIH1cbiAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gd2hlbiBmIGEgLT4gU2tpcCB7IHN0YXRlID0gYERyb3BwaW5nIHMgfVxuICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBgSWRlbnRpdHkgcyB9KVxuICAgICAgICAgICB8IGBJZGVudGl0eSBzIC0+IGxpZnRfaWRlbnRpdHkgbmV4dCBzKVxuICAgICAgfVxuOztcblxubGV0IHNoaWZ0X3JpZ2h0IHMgeCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IGBDb25zaW5nIChzZWVkLCB4KVxuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgfCBgQ29uc2luZyAoc2VlZCwgeCkgLT4gWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gYElkZW50aXR5IHNlZWQgfVxuICAgICAgICAgICB8IGBJZGVudGl0eSBzIC0+IGxpZnRfaWRlbnRpdHkgbmV4dCBzKVxuICAgICAgfVxuOztcblxubGV0IHNoaWZ0X3JpZ2h0X3dpdGhfbGlzdCBzIGwgPSBhcHBlbmQgKG9mX2xpc3QgbCkgc1xubGV0IHNoaWZ0X2xlZnQgPSBkcm9wXG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKCBAICkgPSBhcHBlbmRcbmVuZFxuXG5sZXQgaW50ZXJzcGVyc2UgcyB+c2VwID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gYEluaXQgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgfCBgSW5pdCBzIC0+XG4gICAgICAgICAgICAgKG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGBJbml0IHMgfVxuICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBgUnVubmluZyBzIH0pXG4gICAgICAgICAgIHwgYFJ1bm5pbmcgcyAtPlxuICAgICAgICAgICAgIChtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBgUnVubmluZyBzIH1cbiAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgICAgICAgICAgICBZaWVsZCB7IHZhbHVlID0gc2VwOyBzdGF0ZSA9IGBQdXR0aW5nIChhLCBzKSB9KVxuICAgICAgICAgICB8IGBQdXR0aW5nIChhLCBzKSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBgUnVubmluZyBzIH0pXG4gICAgICB9XG47O1xuXG5sZXQgcmVwZWF0IHggPSB1bmZvbGRfc3RlcCB+aW5pdDp4IH5mOihmdW4geCAtPiBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSB4IH0pXG5cbmxldCBjeWNsZV9saXN0X2V4biB4cyA9XG4gIGlmIExpc3QuaXNfZW1wdHkgeHMgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLmN5Y2xlX2xpc3RfZXhuXCI7XG4gIGxldCBzID0gb2ZfbGlzdCB4cyBpblxuICBjb25jYXRfbWFwIH5mOihmdW4gKCkgLT4gcykgKHJlcGVhdCAoKSlcbjs7XG5cbmxldCBjYXJ0ZXNpYW5fcHJvZHVjdCBzYSBzYiA9IGNvbmNhdF9tYXAgc2EgfmY6KGZ1biBhIC0+IHppcCAocmVwZWF0IGEpIHNiKVxubGV0IHNpbmdsZXRvbiB4ID0gcmV0dXJuIHhcblxubGV0IGRlbGF5ZWRfZm9sZCBzIH5pbml0IH5mIH5maW5pc2ggPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXAgcyB+aW5pdCB+ZmluaXNoIH5mOihmdW4gYWNjIG9wdGlvbiB+ayAtPlxuICAgIG1hdGNoIG9wdGlvbiB3aXRoXG4gICAgfCBOb25lIC0+IGsgYWNjXG4gICAgfCBTb21lIGEgLT4gZiBhY2MgYSB+aylcbjs7XG5cbmxldCBmb2xkX20gfmJpbmQgfnJldHVybiB0IH5pbml0IH5mID1cbiAgRXhwZXJ0LmRlbGF5ZWRfZm9sZF9zdGVwXG4gICAgdFxuICAgIH5pbml0XG4gICAgfmY6KGZ1biBhY2Mgb3B0aW9uIH5rIC0+XG4gICAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgICAgfCBOb25lIC0+IGJpbmQgKHJldHVybiBhY2MpIH5mOmtcbiAgICAgIHwgU29tZSBhIC0+IGJpbmQgKGYgYWNjIGEpIH5mOmspXG4gICAgfmZpbmlzaDpyZXR1cm5cbjs7XG5cbmxldCBpdGVyX20gfmJpbmQgfnJldHVybiB0IH5mID1cbiAgRXhwZXJ0LmRlbGF5ZWRfZm9sZF9zdGVwXG4gICAgdFxuICAgIH5pbml0OigpXG4gICAgfmY6KGZ1biAoKSBvcHRpb24gfmsgLT5cbiAgICAgIG1hdGNoIG9wdGlvbiB3aXRoXG4gICAgICB8IE5vbmUgLT4gYmluZCAocmV0dXJuICgpKSB+ZjprXG4gICAgICB8IFNvbWUgYSAtPiBiaW5kIChmIGEpIH5mOmspXG4gICAgfmZpbmlzaDpyZXR1cm5cbjs7XG5cbmxldCBmb2xkX3VudGlsIHMgfmluaXQgfmYgfmZpbmlzaCA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBhY2MgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZpbmlzaCBhY2NcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIGFjY1xuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAobWF0Y2ggKGYgYWNjIGEgOiAoJ2EsICdiKSBDb250aW51ZV9vcl9zdG9wLnQpIHdpdGhcbiAgICAgICB8IFN0b3AgeCAtPiB4XG4gICAgICAgfCBDb250aW51ZSBhY2MgLT4gbG9vcCBzIG5leHQgZiBhY2MpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCBzIG5leHQgZiBpbml0IFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX3Jlc3VsdCBzIH5pbml0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGFjYyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gUmVzdWx0LnJldHVybiBhY2NcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIGFjY1xuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAobWF0Y2ggKGYgYWNjIGEgOiAoXywgXykgUmVzdWx0LnQpIHdpdGhcbiAgICAgICB8IEVycm9yIF8gYXMgZSAtPiBlXG4gICAgICAgfCBPayBhY2MgLT4gbG9vcCBzIG5leHQgZiBhY2MpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCBzIG5leHQgZiBpbml0XG47O1xuXG5sZXQgZm9yY2VfZWFnZXJseSB0ID0gb2ZfbGlzdCAodG9fbGlzdCB0KVxuXG5sZXQgbWVtb2l6ZSAodHlwZSBhKSAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkgPVxuICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBUIG9mIChhLCB0KSBTdGVwLnQgTGF6eS50XG4gIGVuZFxuICBpblxuICBsZXQgcmVjIG1lbW9pemUgcyA9IE0uVCAobGF6eSAoZmluZF9zdGVwIHMpKVxuICBhbmQgZmluZF9zdGVwIHMgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBmaW5kX3N0ZXAgc1xuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IG1lbW9pemUgcyB9XG4gIGluXG4gIFNlcXVlbmNlIHsgc3RhdGUgPSBtZW1vaXplIHM7IG5leHQgPSAoZnVuIChNLlQgbCkgLT4gTGF6eS5mb3JjZSBsKSB9XG47O1xuXG5sZXQgZHJvcF9lYWdlcmx5IHMgbGVuID1cbiAgbGV0IHJlYyBsb29wIGkgfmxlbiBzIG5leHQgPVxuICAgIGlmIGkgPj0gbGVuXG4gICAgdGhlbiBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9XG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IGVtcHR5XG4gICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIGkgfmxlbiBzIG5leHRcbiAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IC0+IGxvb3AgKGkgKyAxKSB+bGVuIHMgbmV4dClcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPiBsb29wIDAgfmxlbiBzIG5leHRcbjs7XG5cbmxldCBkcm9wX3doaWxlX29wdGlvbiAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3Agc1xuICAgIHwgWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gcyB9IC0+XG4gICAgICBpZiBmIHggdGhlbiBsb29wIHMgZWxzZSBTb21lICh4LCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KVxuICBpblxuICBsb29wIHMgW0Bub250YWlsXVxuOztcblxubGV0IHJlYyBza2lwX2xvb3AgcyBuZXh0ID1cbiAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgfCBTa2lwIHsgc3RhdGUgfSAtPiBza2lwX2xvb3Agc3RhdGUgbmV4dFxuICB8IChEb25lIHwgWWllbGQgXykgYXMgbmV4dCAtPiBuZXh0XG47O1xuXG5sZXQgY29tcGFyZSBjb21wYXJlX2EgKFNlcXVlbmNlIGwpIChTZXF1ZW5jZSByKSA9XG4gIGxldCByZWMgbG9vcCBjb21wYXJlX2Egc19sIG5leHRfbCBzX3IgbmV4dF9yID1cbiAgICBtYXRjaCBza2lwX2xvb3Agc19sIG5leHRfbCwgc2tpcF9sb29wIHNfciBuZXh0X3Igd2l0aFxuICAgIHwgRG9uZSwgRG9uZSAtPiAwXG4gICAgfCBEb25lLCBZaWVsZCBfIC0+IC0xXG4gICAgfCBZaWVsZCBfLCBEb25lIC0+IDFcbiAgICB8IFlpZWxkIGwsIFlpZWxkIHIgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9hIGwudmFsdWUgci52YWx1ZSBpblxuICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlIGxvb3AgY29tcGFyZV9hIGwuc3RhdGUgbmV4dF9sIHIuc3RhdGUgbmV4dF9yXG4gICAgfCBTa2lwIF8sIF8gfCBfLCBTa2lwIF8gLT4gZmFpbHdpdGggXCJCdWc6IFRoaXMgYnJhbmNoIHNob3VsZCBiZSB1bnJlYWNoYWJsZVwiXG4gIGluXG4gIGxvb3AgY29tcGFyZV9hIGwuc3RhdGUgbC5uZXh0IHIuc3RhdGUgci5uZXh0XG47O1xuXG5sZXQgY29tcGFyZV9fbG9jYWwgY29tcGFyZV9hX19sb2NhbCB0MSB0MiA9XG4gIGNvbXBhcmUgKGZ1biB4IHkgLT4gY29tcGFyZV9hX19sb2NhbCB4IHkpIChnbG9iYWxpemUgKCkgdDEpIChnbG9iYWxpemUgKCkgdDIpXG47O1xuXG5sZXQgZXF1YWwgZXF1YWxfYSB0MSB0MiA9XG4gIGZvcl9hbGwgKHppcF9mdWxsIHQxIHQyKSB+ZjooZnVuY3Rpb25cbiAgICB8IGBCb3RoIChhMSwgYTIpIC0+IGVxdWFsX2EgYTEgYTJcbiAgICB8IGBMZWZ0IF8gfCBgUmlnaHQgXyAtPiBmYWxzZSlcbjs7XG5cbmxldCBlcXVhbF9fbG9jYWwgZXF1YWxfYV9fbG9jYWwgdDEgdDIgPVxuICBlcXVhbCAoZnVuIHggeSAtPiBlcXVhbF9hX19sb2NhbCB4IHkpIChnbG9iYWxpemUgKCkgdDEpIChnbG9iYWxpemUgKCkgdDIpXG47O1xuXG5sZXQgcm91bmRfcm9iaW4gbGlzdCA9XG4gIGxldCBuZXh0ICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrKSA9XG4gICAgbWF0Y2ggdG9kb19zdGFjayB3aXRoXG4gICAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCA9IGYgfSA6OiB0b2RvX3N0YWNrIC0+XG4gICAgICAobWF0Y2ggZiBzIHdpdGhcbiAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgWWllbGRcbiAgICAgICAgICAgeyB2YWx1ZSA9IHhcbiAgICAgICAgICAgOyBzdGF0ZSA9IHRvZG9fc3RhY2ssIFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0ID0gZiB9IDo6IGRvbmVfc3RhY2tcbiAgICAgICAgICAgfVxuICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICBTa2lwIHsgc3RhdGUgPSBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCA9IGYgfSA6OiB0b2RvX3N0YWNrLCBkb25lX3N0YWNrIH1cbiAgICAgICB8IERvbmUgLT4gU2tpcCB7IHN0YXRlID0gdG9kb19zdGFjaywgZG9uZV9zdGFjayB9KVxuICAgIHwgW10gLT5cbiAgICAgIGlmIExpc3QuaXNfZW1wdHkgZG9uZV9zdGFjayB0aGVuIERvbmUgZWxzZSBTa2lwIHsgc3RhdGUgPSBMaXN0LnJldiBkb25lX3N0YWNrLCBbXSB9XG4gIGluXG4gIGxldCBzdGF0ZSA9IGxpc3QsIFtdIGluXG4gIFNlcXVlbmNlIHsgc3RhdGU7IG5leHQgfVxuOztcblxubGV0IGludGVybGVhdmUgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMTsgbmV4dCA9IGYxIH0pID1cbiAgbGV0IG5leHQgKHRvZG9fc3RhY2ssIGRvbmVfc3RhY2ssIHMxKSA9XG4gICAgbWF0Y2ggdG9kb19zdGFjayB3aXRoXG4gICAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBmMiB9IDo6IHRvZG9fc3RhY2sgLT5cbiAgICAgIChtYXRjaCBmMiBzMiB3aXRoXG4gICAgICAgfCBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICAgICBZaWVsZFxuICAgICAgICAgICB7IHZhbHVlID0geFxuICAgICAgICAgICA7IHN0YXRlID0gdG9kb19zdGFjaywgU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gZjIgfSA6OiBkb25lX3N0YWNrLCBzMVxuICAgICAgICAgICB9XG4gICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICAgICBTa2lwIHsgc3RhdGUgPSB0b2RvX3N0YWNrLCBTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBmMiB9IDo6IGRvbmVfc3RhY2ssIHMxIH1cbiAgICAgICB8IERvbmUgLT4gU2tpcCB7IHN0YXRlID0gdG9kb19zdGFjaywgZG9uZV9zdGFjaywgczEgfSlcbiAgICB8IFtdIC0+XG4gICAgICAobWF0Y2ggZjEgczEsIGRvbmVfc3RhY2sgd2l0aFxuICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IHQ7IHN0YXRlID0gczEgfSwgXyAtPlxuICAgICAgICAgU2tpcCB7IHN0YXRlID0gTGlzdC5yZXYgKHQgOjogZG9uZV9zdGFjayksIFtdLCBzMSB9XG4gICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzMSB9LCBfIC0+IFNraXAgeyBzdGF0ZSA9IExpc3QucmV2IGRvbmVfc3RhY2ssIFtdLCBzMSB9XG4gICAgICAgfCBEb25lLCBfIDo6IF8gLT4gU2tpcCB7IHN0YXRlID0gTGlzdC5yZXYgZG9uZV9zdGFjaywgW10sIHMxIH1cbiAgICAgICB8IERvbmUsIFtdIC0+IERvbmUpXG4gIGluXG4gIGxldCBzdGF0ZSA9IFtdLCBbXSwgczEgaW5cbiAgU2VxdWVuY2UgeyBzdGF0ZTsgbmV4dCB9XG47O1xuXG5sZXQgaW50ZXJsZWF2ZWRfY2FydGVzaWFuX3Byb2R1Y3QgczEgczIgPVxuICBtYXAgczEgfmY6KGZ1biB4MSAtPiBtYXAgczIgfmY6KGZ1biB4MiAtPiB4MSwgeDIpKSB8PiBpbnRlcmxlYXZlXG47O1xuXG5sZXQgb2Zfc2VxIChzZXEgOiBfIFN0ZGxpYi5TZXEudCkgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDpzZXEgfmY6KGZ1biBzZXEgLT5cbiAgICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IERvbmVcbiAgICB8IENvbnMgKGhkLCB0bCkgLT4gWWllbGQgeyB2YWx1ZSA9IGhkOyBzdGF0ZSA9IHRsIH0pXG47O1xuXG5sZXQgdG9fc2VxIChTZXF1ZW5jZSB7IHN0YXRlOyBuZXh0IH0pID1cbiAgbGV0IHJlYyBsb29wIHN0YXRlID1cbiAgICBtYXRjaCBuZXh0IHN0YXRlIHdpdGhcbiAgICB8IERvbmUgLT4gU3RkbGliLlNlcS5OaWxcbiAgICB8IFNraXAgeyBzdGF0ZSB9IC0+IGxvb3Agc3RhdGVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBoZDsgc3RhdGUgfSAtPiBTdGRsaWIuU2VxLkNvbnMgKGhkLCBmdW4gKCkgLT4gbG9vcCBzdGF0ZSlcbiAgaW5cbiAgZnVuICgpIC0+IGxvb3Agc3RhdGVcbjs7XG5cbm1vZHVsZSBHZW5lcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSAnZWx0IHN0ZXBzID0gV3JhcCBvZiAoJ2VsdCwgdW5pdCAtPiAnZWx0IHN0ZXBzKSBTdGVwLnRcblxuICBsZXQgdW53cmFwIChXcmFwIHN0ZXApID0gc3RlcFxuXG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdlbHQpIHQgPSAoJ2EgLT4gJ2VsdCBzdGVwcykgLT4gJ2VsdCBzdGVwc1xuXG4gICAgbGV0IHJldHVybiB4IGsgPSBrIHhcblxuICAgIGxldCBiaW5kIG0gfmYgayA9XG4gICAgICBtIChmdW4gYSAtPlxuICAgICAgICBsZXQgbScgPSBmIGEgaW5cbiAgICAgICAgbScgaylcbiAgICA7O1xuXG4gICAgbGV0IG1hcCBtIH5mIGsgPSBtIChmdW4gYSAtPiBrIChmIGEpKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBNb25hZC5NYWtlMiAoVClcblxuICBsZXQgeWllbGQgZSBrID0gV3JhcCAoWWllbGQgeyB2YWx1ZSA9IGU7IHN0YXRlID0gayB9KVxuICBsZXQgdG9fc3RlcHMgdCA9IHQgKGZ1biAoKSAtPiBXcmFwIERvbmUpXG5cbiAgbGV0IG9mX3NlcXVlbmNlIHNlcXVlbmNlID1cbiAgICBkZWxheWVkX2ZvbGRcbiAgICAgIHNlcXVlbmNlXG4gICAgICB+aW5pdDooKVxuICAgICAgfmY6KGZ1biAoKSB4IH5rIGYgLT4gV3JhcCAoWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gKGZ1biAoKSAtPiBrICgpIGYpIH0pKVxuICAgICAgfmZpbmlzaDpyZXR1cm5cbiAgOztcblxuICBsZXQgcnVuIHQgPVxuICAgIGxldCBpbml0ICgpID0gdG9fc3RlcHMgdCBpblxuICAgIGxldCBmIHRodW5rID0gdW53cmFwICh0aHVuayAoKSkgaW5cbiAgICB1bmZvbGRfc3RlcCB+aW5pdCB+ZlxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGVcblxubW9kdWxlIE9mX3NleHBhYmxlXG4gIChTZXhwYWJsZSA6IFMpIChNIDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgdG9fc2V4cGFibGUgOiB0IC0+IFNleHBhYmxlLnRcbiAgICB2YWwgb2Zfc2V4cGFibGUgOiBTZXhwYWJsZS50IC0+IHRcbiAgZW5kKSA6IFMgd2l0aCB0eXBlIHQgOj0gTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB0ID0gU2V4cGFibGUuc2V4cF9vZl90IChNLnRvX3NleHBhYmxlIHQpXG5lbmRcblxubW9kdWxlIE9mX3NleHBhYmxlMVxuICAoU2V4cGFibGUgOiBTMSkgKE0gOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCB0b19zZXhwYWJsZSA6ICdhIHQgLT4gJ2EgU2V4cGFibGUudFxuICAgIHZhbCBvZl9zZXhwYWJsZSA6ICdhIFNleHBhYmxlLnQgLT4gJ2EgdFxuICBlbmQpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgYV9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gU2V4cGFibGUuc2V4cF9vZl90IHNleHBfb2ZfYSAoTS50b19zZXhwYWJsZSB0KVxuZW5kXG5cbm1vZHVsZSBPZl9zZXhwYWJsZTJcbiAgKFNleHBhYmxlIDogUzIpIChNIDogc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgdG9fc2V4cGFibGUgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIFNleHBhYmxlLnRcbiAgICB2YWwgb2Zfc2V4cGFibGUgOiAoJ2EsICdiKSBTZXhwYWJsZS50IC0+ICgnYSwgJ2IpIHRcbiAgZW5kKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2IgdCA9XG4gICAgU2V4cGFibGUuc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2IgKE0udG9fc2V4cGFibGUgdClcbiAgOztcbmVuZFxuXG5tb2R1bGUgT2Zfc2V4cGFibGUzXG4gIChTZXhwYWJsZSA6IFMzKSAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCB0b19zZXhwYWJsZSA6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSBTZXhwYWJsZS50XG4gICAgdmFsIG9mX3NleHBhYmxlIDogKCdhLCAnYiwgJ2MpIFNleHBhYmxlLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgZW5kKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBjX29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBjX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIHNleHBfb2ZfYyB0ID1cbiAgICBTZXhwYWJsZS5zZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiBzZXhwX29mX2MgKE0udG9fc2V4cGFibGUgdClcbiAgOztcbmVuZFxuXG5tb2R1bGUgT2Zfc3RyaW5nYWJsZSAoTSA6IFN0cmluZ2FibGUuUykgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBTIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxud2l0aCB0eXBlIHQgOj0gTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkF0b20gcyAtPlxuICAgICAgKHRyeSBNLm9mX3N0cmluZyBzIHdpdGhcbiAgICAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cClcbiAgICB8IFNleHAuTGlzdCBfIC0+XG4gICAgICBvZl9zZXhwX2Vycm9yXG4gICAgICAgIFwiU2V4cGFibGUuT2Zfc3RyaW5nYWJsZS50X29mX3NleHAgZXhwZWN0ZWQgYW4gYXRvbSwgYnV0IGdvdCBhIGxpc3RcIlxuICAgICAgICBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5BdG9tIChNLnRvX3N0cmluZyB0KVxuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6IE0udCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gICAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSBzdHJpbmdfc2V4cF9ncmFtbWFyXG4gIDs7XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBBcnJheTBcblxudHlwZSAnYSB0ID0gJ2EgYXJyYXkgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmVfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX2FycmF5X19sb2NhbFxubGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfYXJyYXlcblxubGV0IGdsb2JhbGl6ZSA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIHQgLT4gJ2EgdCA9XG4gIGZ1biAodHlwZSBhX18wMDlfKSA6ICgoYV9fMDA5XyAtPiBhX18wMDlfKSAtPiBhX18wMDlfIHQgLT4gYV9fMDA5XyB0KSAtPiBnbG9iYWxpemVfYXJyYXlcbjs7XG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSBhcnJheV9vZl9zZXhwXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9hcnJheVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGFycmF5X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG47O1xuXG5bQEBAZW5kXVxuXG4oKiBUaGlzIG1vZHVsZSBpbXBsZW1lbnRzIGEgbmV3IGluLXBsYWNlLCBjb25zdGFudCBoZWFwIHNvcnRpbmcgYWxnb3JpdGhtIHRvIHJlcGxhY2UgdGhlXG4gICBvbmUgdXNlZCBieSB0aGUgc3RhbmRhcmQgbGlicmFyaWVzLiAgSXRzIG9ubHkgcHVycG9zZSBpcyB0byBiZSBmYXN0ZXIgKGhvcGVmdWxseVxuICAgc3RyaWN0bHkgZmFzdGVyKSB0aGFuIHRoZSBiYXNlIHNvcnQgYW5kIHN0YWJsZV9zb3J0LlxuXG4gICBBdCBhIGhpZ2ggbGV2ZWwgdGhlIGFsZ29yaXRobSBpczpcbiAgIC0gcGljayB0d28gcGl2b3QgcG9pbnRzIGJ5OlxuICAgLSBwaWNrIDUgYXJiaXRyYXJ5IGVsZW1lbnRzIGZyb20gdGhlIGFycmF5XG4gICAtIHNvcnQgdGhlbSB3aXRoaW4gdGhlIGFycmF5XG4gICAtIHRha2UgdGhlIGVsZW1lbnRzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBtaWRkbGUgZWxlbWVudCBvZiB0aGUgc29ydCBhcyB0aGUgcGl2b3RzXG4gICAtIHNvcnQgdGhlIGFycmF5IHdpdGg6XG4gICAtIGFsbCBlbGVtZW50cyBsZXNzIHRoYW4gcGl2b3QxIHRvIHRoZSBsZWZ0IChyYW5nZSAxKVxuICAgLSBhbGwgZWxlbWVudHMgPj0gcGl2b3QxIGFuZCA8PSBwaXZvdDIgaW4gdGhlIG1pZGRsZSAocmFuZ2UgMilcbiAgIC0gYWxsIGVsZW1lbnRzID4gcGl2b3QyIHRvIHRoZSByaWdodCAocmFuZ2UgMylcbiAgIC0gaWYgcGl2b3QxIGFuZCBwaXZvdDIgYXJlIGVxdWFsLCB0aGVuIHRoZSBtaWRkbGUgcmFuZ2UgaXMgc29ydGVkLCBzbyBpZ25vcmUgaXRcbiAgIC0gcmVjdXJzZSBpbnRvIHJhbmdlIDEsIDIgKGlmIHBpdm90MSBhbmQgcGl2b3QyIGFyZSB1bmVxdWFsKSwgYW5kIDNcbiAgIC0gZHVyaW5nIHJlY3Vyc2lvbiB0aGVyZSBhcmUgdHdvIGluZmxlY3Rpb24gcG9pbnRzOlxuICAgLSBpZiB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudCByYW5nZSBpcyBzbWFsbCwgdXNlIGluc2VydGlvbiBzb3J0IHRvIHNvcnQgaXRcbiAgIC0gaWYgdGhlIHN0YWNrIGRlcHRoIGlzIGxhcmdlLCBzb3J0IHRoZSByYW5nZSB3aXRoIGhlYXAtc29ydCB0byBhdm9pZCBuXjIgd29yc3QtY2FzZVxuICAgICBiZWhhdmlvclxuXG4gICBTZWUgdGhlIGZvbGxvd2luZyBmb3IgbW9yZSBpbmZvcm1hdGlvbjpcbiAgIC0gXCJEdWFsLVBpdm90IFF1aWNrc29ydFwiIGJ5IFZsYWRpbWlyIFlhcm9zbGF2c2tpeS5cbiAgICAgQXZhaWxhYmxlIGF0XG4gICAgIGh0dHA6Ly93d3cua3JpY2hlLmNvbS5hci9yb290L3Byb2dyYW1taW5nL3NwYWNlVGltZUNvbXBsZXhpdHkvRHVhbFBpdm90UXVpY2tzb3J0LnBkZlxuICAgLSBcIlF1aWNrc29ydCBpcyBPcHRpbWFsXCIgYnkgU2VkZ2V3aWNrIGFuZCBCZW50bGV5LlxuICAgICBTbGlkZXMgYXQgaHR0cDovL3d3dy5jcy5wcmluY2V0b24uZWR1L35ycy90YWxrcy9RdWlja3NvcnRJc09wdGltYWwucGRmXG4gICAtIGh0dHA6Ly93d3cuc29ydGluZy1hbGdvcml0aG1zLmNvbS9xdWljay1zb3J0LTMtd2F5ICopXG5cbm1vZHVsZSBTb3J0ZXIgKFMgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCBzZXQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBTXG5cbiAgbGV0IHN3YXAgYXJyIGkgaiA9XG4gICAgbGV0IHRtcCA9IGdldCBhcnIgaSBpblxuICAgIHNldCBhcnIgaSAoZ2V0IGFyciBqKTtcbiAgICBzZXQgYXJyIGogdG1wXG4gIDs7XG5cbiAgbW9kdWxlIHR5cGUgU29ydCA9IHNpZ1xuICAgIHZhbCBzb3J0XG4gICAgICA6ICAnYSB0XG4gICAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgICAtPiBsZWZ0OmludCAoKiBsZWZ0bW9zdCBpbmRleCBvZiBzdWItYXJyYXkgdG8gc29ydCAqKVxuICAgICAgLT4gcmlnaHQ6aW50ICgqIHJpZ2h0bW9zdCBpbmRleCBvZiBzdWItYXJyYXkgdG8gc29ydCAqKVxuICAgICAgLT4gdW5pdFxuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0luc2VydGlvbl9zb3J0ICopXG4gIG1vZHVsZSBJbnNlcnRpb25fc29ydCA6IFNvcnQgPSBzdHJ1Y3RcbiAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgMS4gIHRoZSBzdWJhcnJheSBhcnJbbGVmdCAuLiBpLTFdIGlzIHNvcnRlZFxuICAgICAgIDIuICB0aGUgc3ViYXJyYXkgYXJyW2krMSAuLiBwb3NdIGlzIHNvcnRlZCBhbmQgY29udGFpbnMgb25seSBlbGVtZW50cyA+IHZcbiAgICAgICAzLiAgYXJyW2ldIG1heSBiZSB0aG91Z2h0IG9mIGFzIGNvbnRhaW5pbmcgdlxuICAgICopXG4gICAgbGV0IHJlYyBpbnNlcnRfbG9vcCBhcnIgfmxlZnQgfmNvbXBhcmUgaSB2ID1cbiAgICAgIGxldCBpX25leHQgPSBpIC0gMSBpblxuICAgICAgaWYgaV9uZXh0ID49IGxlZnQgJiYgY29tcGFyZSAoZ2V0IGFyciBpX25leHQpIHYgPiAwXG4gICAgICB0aGVuIChcbiAgICAgICAgc2V0IGFyciBpIChnZXQgYXJyIGlfbmV4dCk7XG4gICAgICAgIGluc2VydF9sb29wIGFyciB+bGVmdCB+Y29tcGFyZSBpX25leHQgdilcbiAgICAgIGVsc2UgaVxuICAgIDs7XG5cbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgICgqIGxvb3AgaW52YXJpYW50OlxuICAgICAgICAgW2Fycl0gaXMgc29ydGVkIGZyb20gW2xlZnRdIHRvIFtwb3MgLSAxXSwgaW5jbHVzaXZlICopXG4gICAgICBmb3IgcG9zID0gbGVmdCArIDEgdG8gcmlnaHQgZG9cbiAgICAgICAgbGV0IHYgPSBnZXQgYXJyIHBvcyBpblxuICAgICAgICBsZXQgZmluYWxfcG9zID0gaW5zZXJ0X2xvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIHBvcyB2IGluXG4gICAgICAgIHNldCBhcnIgZmluYWxfcG9zIHZcbiAgICAgIGRvbmVcbiAgICA7O1xuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlYXBzb3J0ICopXG4gIG1vZHVsZSBIZWFwX3NvcnQgOiBTb3J0ID0gc3RydWN0XG4gICAgKCogbG9vcCBpbnZhcmlhbnQ6XG4gICAgICAgcm9vdCdzIGNoaWxkcmVuIGFyZSBib3RoIGVpdGhlciByb290cyBvZiBtYXgtaGVhcHMgb3IgPiByaWdodCAqKVxuICAgIGxldCByZWMgaGVhcGlmeSBhcnIgfmNvbXBhcmUgcm9vdCB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IHJlbGF0aXZlX3Jvb3QgPSByb290IC0gbGVmdCBpblxuICAgICAgbGV0IGxlZnRfY2hpbGQgPSAoMiAqIHJlbGF0aXZlX3Jvb3QpICsgbGVmdCArIDEgaW5cbiAgICAgIGxldCByaWdodF9jaGlsZCA9ICgyICogcmVsYXRpdmVfcm9vdCkgKyBsZWZ0ICsgMiBpblxuICAgICAgbGV0IGxhcmdlc3QgPVxuICAgICAgICBpZiBsZWZ0X2NoaWxkIDw9IHJpZ2h0ICYmIGNvbXBhcmUgKGdldCBhcnIgbGVmdF9jaGlsZCkgKGdldCBhcnIgcm9vdCkgPiAwXG4gICAgICAgIHRoZW4gbGVmdF9jaGlsZFxuICAgICAgICBlbHNlIHJvb3RcbiAgICAgIGluXG4gICAgICBsZXQgbGFyZ2VzdCA9XG4gICAgICAgIGlmIHJpZ2h0X2NoaWxkIDw9IHJpZ2h0ICYmIGNvbXBhcmUgKGdldCBhcnIgcmlnaHRfY2hpbGQpIChnZXQgYXJyIGxhcmdlc3QpID4gMFxuICAgICAgICB0aGVuIHJpZ2h0X2NoaWxkXG4gICAgICAgIGVsc2UgbGFyZ2VzdFxuICAgICAgaW5cbiAgICAgIGlmIGxhcmdlc3QgPD4gcm9vdFxuICAgICAgdGhlbiAoXG4gICAgICAgIHN3YXAgYXJyIHJvb3QgbGFyZ2VzdDtcbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgbGFyZ2VzdCB+bGVmdCB+cmlnaHQpXG4gICAgOztcblxuICAgIGxldCBidWlsZF9oZWFwIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgKCogRWxlbWVudHMgaW4gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSBhcnJheSBhcmUgYWxyZWFkeSBoZWFwcyBvZiBzaXplIDEuICBXZSBtb3ZlXG4gICAgICAgICB0aHJvdWdoIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSBhcnJheSBmcm9tIGJhY2sgdG8gZnJvbnQgZXhhbWluaW5nIHRoZSBlbGVtZW50IGF0XG4gICAgICAgICBoYW5kLCBhbmQgdGhlIGxlZnQgYW5kIHJpZ2h0IGNoaWxkcmVuLCBmaXhpbmcgdGhlIGhlYXAgcHJvcGVydHkgYXMgd2UgZ28uICopXG4gICAgICBmb3IgaSA9IChsZWZ0ICsgcmlnaHQpIC8gMiBkb3dudG8gbGVmdCBkb1xuICAgICAgICBoZWFwaWZ5IGFyciB+Y29tcGFyZSBpIH5sZWZ0IH5yaWdodFxuICAgICAgZG9uZVxuICAgIDs7XG5cbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGJ1aWxkX2hlYXAgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodDtcbiAgICAgICgqIGxvb3AgaW52YXJpYW50czpcbiAgICAgICAgIDEuICB0aGUgc3ViYXJyYXkgYXJyW2xlZnQgLi4uIGldIGlzIGEgbWF4LWhlYXAgSFxuICAgICAgICAgMi4gIHRoZSBzdWJhcnJheSBhcnJbaSsxIC4uLiByaWdodF0gaXMgc29ydGVkIChjYWxsIGl0IFMpXG4gICAgICAgICAzLiAgZXZlcnkgZWxlbWVudCBvZiBIIGlzIGxlc3MgdGhhbiBldmVyeSBlbGVtZW50IG9mIFMgKilcbiAgICAgIGZvciBpID0gcmlnaHQgZG93bnRvIGxlZnQgKyAxIGRvXG4gICAgICAgIHN3YXAgYXJyIGxlZnQgaTtcbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgbGVmdCB+bGVmdCB+cmlnaHQ6KGkgLSAxKVxuICAgICAgZG9uZVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50cm9zb3J0ICopXG4gIG1vZHVsZSBJbnRyb19zb3J0IDogc2lnXG4gICAgaW5jbHVkZSBTb3J0XG5cbiAgICB2YWwgZml2ZV9lbGVtZW50X3NvcnRcbiAgICAgIDogICdhIHRcbiAgICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludClcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiB1bml0XG4gIGVuZCA9IHN0cnVjdFxuICAgIGxldCBmaXZlX2VsZW1lbnRfc29ydCBhcnIgfihjb21wYXJlIDogXyAtPiBfIC0+IF8pIG0xIG0yIG0zIG00IG01ID1cbiAgICAgIGxldCBjb21wYXJlX2FuZF9zd2FwIGkgaiA9XG4gICAgICAgIGlmIGNvbXBhcmUgKGdldCBhcnIgaSkgKGdldCBhcnIgaikgPiAwIHRoZW4gc3dhcCBhcnIgaSBqXG4gICAgICBpblxuICAgICAgKCogT3B0aW1hbCA1LWVsZW1lbnQgc29ydGluZyBuZXR3b3JrOlxuXG4gICAgICAgICB7dlxuICAgICAgICAgICAgMS0tby0tLS0tby0tLS0tby0tLS0tLS0tLS0tLS0tMVxuICAgICAgICAgICAgICAgfCAgICAgfCAgICAgfFxuICAgICAgICAgICAgMi0tby0tLS0tfC0tby0tfC0tLS0tby0tby0tLS0tMlxuICAgICAgICAgICAgICAgICAgICAgfCAgfCAgfCAgICAgfCAgfFxuICAgICAgICAgICAgMy0tLS0tLS0tby0tby0tfC0tby0tfC0tby0tLS0tM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgfFxuICAgICAgICAgICAgNC0tLS0tby0tLS0tLS0tby0tby0tfC0tLS0tby0tNFxuICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgfFxuICAgICAgICAgICAgNS0tLS0tby0tLS0tLS0tLS0tLS0tby0tLS0tby0tNVxuICAgICAgICAgIHZ9ICopXG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0xIG0yO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtNCBtNTtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTEgbTM7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG0zO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMSBtNDtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTMgbTQ7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG01O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMiBtMztcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTQgbTUgW0Bub250YWlsXVxuICAgIDs7XG5cbiAgICAoKiBjaG9vc2UgcGl2b3RzIGZvciB0aGUgYXJyYXkgYnkgc29ydGluZyA1IGVsZW1lbnRzIGFuZCBleGFtaW5pbmcgdGhlIGNlbnRlciB0aHJlZVxuICAgICAgIGVsZW1lbnRzLiAgVGhlIGdvYWwgaXMgdG8gY2hvb3NlIHR3byBwaXZvdHMgdGhhdCB3aWxsIGVpdGhlcjpcbiAgICAgICAtIGJyZWFrIHRoZSByYW5nZSB1cCBpbnRvIDMgZXZlbiBwYXJ0aXRpb25zXG4gICAgICAgICBvclxuICAgICAgIC0gZWxpbWluYXRlIGEgY29tbW9ubHkgYXBwZWFyaW5nIGVsZW1lbnQgYnkgc29ydGluZyBpdCBpbnRvIHRoZSBjZW50ZXIgcGFydGl0aW9uXG4gICAgICAgICBieSBpdHNlbGZcbiAgICAgICAgIFRvIHRoaXMgZW5kIHdlIGxvb2sgYXQgdGhlIGNlbnRlciAzIGVsZW1lbnRzIG9mIHRoZSA1IGFuZCByZXR1cm4gcGFpcnMgb2YgZXF1YWxcbiAgICAgICAgIGVsZW1lbnRzIG9yIHRoZSB3aWRlc3QgcmFuZ2UgKilcbiAgICBsZXQgY2hvb3NlX3Bpdm90cyBhcnIgfihjb21wYXJlIDogXyAtPiBfIC0+IF8pIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgc2l4dGggPSAocmlnaHQgLSBsZWZ0KSAvIDYgaW5cbiAgICAgIGxldCBtMSA9IGxlZnQgKyBzaXh0aCBpblxuICAgICAgbGV0IG0yID0gbTEgKyBzaXh0aCBpblxuICAgICAgbGV0IG0zID0gbTIgKyBzaXh0aCBpblxuICAgICAgbGV0IG00ID0gbTMgKyBzaXh0aCBpblxuICAgICAgbGV0IG01ID0gbTQgKyBzaXh0aCBpblxuICAgICAgZml2ZV9lbGVtZW50X3NvcnQgYXJyIH5jb21wYXJlIG0xIG0yIG0zIG00IG01O1xuICAgICAgbGV0IG0yX3ZhbCA9IGdldCBhcnIgbTIgaW5cbiAgICAgIGxldCBtM192YWwgPSBnZXQgYXJyIG0zIGluXG4gICAgICBsZXQgbTRfdmFsID0gZ2V0IGFyciBtNCBpblxuICAgICAgaWYgY29tcGFyZSBtMl92YWwgbTNfdmFsID0gMFxuICAgICAgdGhlbiBtMl92YWwsIG0zX3ZhbCwgdHJ1ZVxuICAgICAgZWxzZSBpZiBjb21wYXJlIG0zX3ZhbCBtNF92YWwgPSAwXG4gICAgICB0aGVuIG0zX3ZhbCwgbTRfdmFsLCB0cnVlXG4gICAgICBlbHNlIG0yX3ZhbCwgbTRfdmFsLCBmYWxzZVxuICAgIDs7XG5cbiAgICBsZXQgZHVhbF9waXZvdF9wYXJ0aXRpb24gYXJyIH4oY29tcGFyZSA6IF8gLT4gXyAtPiBfKSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IHBpdm90MSwgcGl2b3QyLCBwaXZvdHNfZXF1YWwgPSBjaG9vc2VfcGl2b3RzIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgaW5cbiAgICAgICgqIGxvb3AgaW52YXJpYW50czpcbiAgICAgICAgIDEuICBsZWZ0IDw9IGwgPCByIDw9IHJpZ2h0XG4gICAgICAgICAyLiAgbCA8PSBwIDw9IHJcbiAgICAgICAgIDMuICBsIDw9IHggPCBwICAgICBpbXBsaWVzIGFyclt4XSA+PSBwaXZvdDFcbiAgICAgICAgIGFuZCBhcnJbeF0gPD0gcGl2b3QyXG4gICAgICAgICA0LiAgbGVmdCA8PSB4IDwgbCAgaW1wbGllcyBhcnJbeF0gPCBwaXZvdDFcbiAgICAgICAgIDUuICByIDwgeCA8PSByaWdodCBpbXBsaWVzIGFyclt4XSA+IHBpdm90MiAqKVxuICAgICAgbGV0IHJlYyBsb29wIGwgcCByID1cbiAgICAgICAgbGV0IHB2ID0gZ2V0IGFyciBwIGluXG4gICAgICAgIGlmIGNvbXBhcmUgcHYgcGl2b3QxIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBzd2FwIGFyciBwIGw7XG4gICAgICAgICAgY29udCAobCArIDEpIChwICsgMSkgcilcbiAgICAgICAgZWxzZSBpZiBjb21wYXJlIHB2IHBpdm90MiA+IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOiAgc2FtZSBhcyB0aG9zZSBvZiB0aGUgb3V0ZXIgbG9vcCAqKVxuICAgICAgICAgIGxldCByZWMgc2Nhbl9iYWNrd2FyZHMgciA9XG4gICAgICAgICAgICBpZiByID4gcCAmJiBjb21wYXJlIChnZXQgYXJyIHIpIHBpdm90MiA+IDAgdGhlbiBzY2FuX2JhY2t3YXJkcyAociAtIDEpIGVsc2UgclxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHIgPSBzY2FuX2JhY2t3YXJkcyByIGluXG4gICAgICAgICAgc3dhcCBhcnIgciBwO1xuICAgICAgICAgIGNvbnQgbCBwIChyIC0gMSkpXG4gICAgICAgIGVsc2UgY29udCBsIChwICsgMSkgclxuICAgICAgYW5kIGNvbnQgbCBwIHIgPSBpZiBwID4gciB0aGVuIGwsIHIgZWxzZSBsb29wIGwgcCByIGluXG4gICAgICBsZXQgbCwgciA9IGNvbnQgbGVmdCBsZWZ0IHJpZ2h0IGluXG4gICAgICBsLCByLCBwaXZvdHNfZXF1YWxcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgbGVuID0gcmlnaHQgLSBsZWZ0ICsgMSBpblxuICAgICAgKCogVGhpcyB0YWtlcyBjYXJlIG9mIHNvbWUgZWRnZSBjYXNlcywgc3VjaCBhcyBsZWZ0ID4gcmlnaHQgb3IgdmVyeSBzaG9ydCBhcnJheXMsXG4gICAgICAgICBzaW5jZSBJbnNlcnRpb25fc29ydC5zb3J0IGhhbmRsZXMgdGhlc2UgY2FzZXMgcHJvcGVybHkuICBUaHVzIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgIG1ha2Ugc3VyZSB0aGF0IGxlZnQgYW5kIHJpZ2h0IGFyZSB2YWxpZCBpbiByZWN1cnNpdmUgY2FsbHMuICopXG4gICAgICBpZiBsZW4gPD0gMzJcbiAgICAgIHRoZW4gSW5zZXJ0aW9uX3NvcnQuc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgICBlbHNlIGlmIG1heF9kZXB0aCA8IDBcbiAgICAgIHRoZW4gSGVhcF9zb3J0LnNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBtYXhfZGVwdGggPSBtYXhfZGVwdGggLSAxIGluXG4gICAgICAgIGxldCBsLCByLCBtaWRkbGVfc29ydGVkID0gZHVhbF9waXZvdF9wYXJ0aXRpb24gYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCBpblxuICAgICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0IH5yaWdodDoobCAtIDEpO1xuICAgICAgICBpZiBub3QgbWlkZGxlX3NvcnRlZCB0aGVuIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQ6bCB+cmlnaHQ6cjtcbiAgICAgICAgaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdDoociArIDEpIH5yaWdodClcbiAgICA7O1xuXG4gICAgbGV0IHNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgaGVhcF9zb3J0X3N3aXRjaF9kZXB0aCA9XG4gICAgICAgICgqIFdlIGJhaWwgb3V0IHRvIGhlYXAgc29ydCBhdCBhIHJlY3Vyc2lvbiBkZXB0aCBvZiAzMi4gR05VIGludHJvc29ydCB1c2VzIDJsZyhuKS5cbiAgICAgICAgICAgVGhlIGV4cGVjdGVkIHJlY3Vyc2lvbiBkZXB0aCBmb3IgcGVyZmVjdCAzLXdheSBzcGxpdHMgaXMgbG9nXzMobikuXG5cbiAgICAgICAgICAgVXNpbmcgMzIgbWVhbnMgYSBiYWxhbmNlZCAzLXdheSBzcGxpdCB3b3VsZCB3b3JrIHVwIHRvIDNeMzIgZWxlbWVudHMgKHJvdWdobHlcbiAgICAgICAgICAgMl41MCBvciAxMF4xNSkuIEdOVSByZWFjaGVzIGEgZGVwdGggb2YgMzIgYXQgNjU1MzYgZWxlbWVudHMuXG5cbiAgICAgICAgICAgRm9yIHNtYWxsIGFycmF5cywgdGhpcyBtYWtlcyB1cyBsZXNzIGxpa2VseSB0byBiYWlsIG91dCB0byBoZWFwIHNvcnQsIGJ1dCB0aGVcbiAgICAgICAgICAgMzIqTiBjb3N0IGJlZm9yZSB3ZSBkbyBpcyBub3QgdGhhdCBtdWNoLlxuXG4gICAgICAgICAgIEZvciBsYXJnZSBhcnJheXMsIHRoaXMgbWVhbnMgd2UgYXJlIG1vcmUgbGlrZWx5IHRvIGJhaWwgb3V0IHRvIGhlYXAgc29ydCBhdFxuICAgICAgICAgICBzb21lIHBvaW50IGlmIHdlIGdldCBzb21lIGJhZCBzcGxpdHMgb3IgaWYgdGhlIGFycmF5IGlzIGh1Z2UuIEJ1dCB0aGF0J3Mgb25seSBhXG4gICAgICAgICAgIGNvbnN0YW50IGZhY3RvciBjb3N0IGluIHRoZSBmaW5hbCBzdGFnZXMgb2YgcmVjdXJzaW9uLlxuXG4gICAgICAgICAgIEFsbCBpbiBhbGwsIHRoaXMgc2VlbXMgdG8gYmUgYSBzbWFsbCB0cmFkZW9mZiBhbmQgYXZvaWRzIHBheWluZyBhIGNvc3QgdG9cbiAgICAgICAgICAgY29tcHV0ZSBhIGxvZ2FyaXRobSBhdCB0aGUgc3RhcnQuICopXG4gICAgICAgIDMyXG4gICAgICBpblxuICAgICAgaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aDpoZWFwX3NvcnRfc3dpdGNoX2RlcHRoIH5jb21wYXJlIH5sZWZ0IH5yaWdodFxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBzb3J0ID9wb3MgP2xlbiBhcnIgfihjb21wYXJlIDogXyAtPiBfIC0+IF8pID1cbiAgICBsZXQgcG9zLCBsZW4gPVxuICAgICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCBhcnIpXG4gICAgaW5cbiAgICBJbnRyb19zb3J0LnNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0OnBvcyB+cmlnaHQ6KHBvcyArIGxlbiAtIDEpXG4gIDs7XG5lbmRcbltAQGlubGluZV1cblxubW9kdWxlIFNvcnQgPSBTb3J0ZXIgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0XG4gIGxldCBsZW5ndGggPSBsZW5ndGhcbmVuZClcblxubGV0IHNvcnQgPSBTb3J0LnNvcnRcbmxldCBvZl9hcnJheSB0ID0gdFxubGV0IHRvX2FycmF5IHQgPSB0XG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXQgaXNfc29ydGVkIHQgfmNvbXBhcmUgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPiAwICYmICFyZXN1bHQgZG9cbiAgICBsZXQgZWx0X2kgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICBsZXQgZWx0X2lfbWludXNfMSA9IHVuc2FmZV9nZXQgdCAoIWkgLSAxKSBpblxuICAgIGlmIGNvbXBhcmUgZWx0X2lfbWludXNfMSBlbHRfaSA+IDAgdGhlbiByZXN1bHQgOj0gZmFsc2U7XG4gICAgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBpc19zb3J0ZWRfc3RyaWN0bHkgdCB+Y29tcGFyZSA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+IDAgJiYgIXJlc3VsdCBkb1xuICAgIGxldCBlbHRfaSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgIGxldCBlbHRfaV9taW51c18xID0gdW5zYWZlX2dldCB0ICghaSAtIDEpIGluXG4gICAgaWYgY29tcGFyZSBlbHRfaV9taW51c18xIGVsdF9pID49IDAgdGhlbiByZXN1bHQgOj0gZmFsc2U7XG4gICAgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBtZXJnZSBhMSBhMiB+Y29tcGFyZSA9XG4gIGxldCBsMSA9IEFycmF5Lmxlbmd0aCBhMSBpblxuICBsZXQgbDIgPSBBcnJheS5sZW5ndGggYTIgaW5cbiAgaWYgbDEgPSAwXG4gIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGwyID0gMFxuICB0aGVuIGNvcHkgYTFcbiAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEyIDApICh1bnNhZmVfZ2V0IGExIChsMSAtIDEpKSA+PSAwXG4gIHRoZW4gYXBwZW5kIGExIGEyXG4gIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhMSAwKSAodW5zYWZlX2dldCBhMiAobDIgLSAxKSkgPiAwXG4gIHRoZW4gYXBwZW5kIGEyIGExXG4gIGVsc2UgKFxuICAgIGxldCBsZW4gPSBsMSArIGwyIGluXG4gICAgbGV0IG1lcmdlZCA9IGNyZWF0ZSB+bGVuICh1bnNhZmVfZ2V0IGExIDApIGluXG4gICAgbGV0IGExX2luZGV4ID0gcmVmIDAgaW5cbiAgICBsZXQgYTJfaW5kZXggPSByZWYgMCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgdXNlX2ExID1cbiAgICAgICAgaWYgbDEgPSAhYTFfaW5kZXhcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGlmIGwyID0gIWEyX2luZGV4XG4gICAgICAgIHRoZW4gdHJ1ZVxuICAgICAgICBlbHNlIGNvbXBhcmUgKHVuc2FmZV9nZXQgYTEgIWExX2luZGV4KSAodW5zYWZlX2dldCBhMiAhYTJfaW5kZXgpIDw9IDBcbiAgICAgIGluXG4gICAgICBpZiB1c2VfYTFcbiAgICAgIHRoZW4gKFxuICAgICAgICB1bnNhZmVfc2V0IG1lcmdlZCBpICh1bnNhZmVfZ2V0IGExICFhMV9pbmRleCk7XG4gICAgICAgIGExX2luZGV4IDo9ICFhMV9pbmRleCArIDEpXG4gICAgICBlbHNlIChcbiAgICAgICAgdW5zYWZlX3NldCBtZXJnZWQgaSAodW5zYWZlX2dldCBhMiAhYTJfaW5kZXgpO1xuICAgICAgICBhMl9pbmRleCA6PSAhYTJfaW5kZXggKyAxKVxuICAgIGRvbmU7XG4gICAgbWVyZ2VkKVxuOztcblxubGV0IGNvcHlfbWF0cml4ID0gbWFwIH5mOmNvcHlcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcCB0IH5mOihmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbmxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHQgfmZpbmlzaFxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxuXG5sZXRbQGlubGluZSBhbHdheXNdIGV4dHJlbWFsX2VsZW1lbnQgdCB+Y29tcGFyZSB+a2VlcF9sZWZ0X2lmID1cbiAgaWYgaXNfZW1wdHkgdFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlc3VsdCA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IHQgaSBpblxuICAgICAgcmVzdWx0IDo9IEJvb2wuc2VsZWN0ICgoa2VlcF9sZWZ0X2lmIFtAaW5saW5lZF0pIChjb21wYXJlIHggIXJlc3VsdCkpIHggIXJlc3VsdFxuICAgIGRvbmU7XG4gICAgU29tZSAhcmVzdWx0KVxuOztcblxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9XG4gIChleHRyZW1hbF9lbGVtZW50IFtAaW5saW5lZF0pIHQgfmNvbXBhcmUgfmtlZXBfbGVmdF9pZjooZnVuIGNvbXBhcmVfcmVzdWx0IC0+XG4gICAgY29tcGFyZV9yZXN1bHQgPCAwKVxuOztcblxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9XG4gIChleHRyZW1hbF9lbGVtZW50IFtAaW5saW5lZF0pIHQgfmNvbXBhcmUgfmtlZXBfbGVmdF9pZjooZnVuIGNvbXBhcmVfcmVzdWx0IC0+XG4gICAgY29tcGFyZV9yZXN1bHQgPiAwKVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGFjYyA6PSBmIGkgIWFjYyAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmU7XG4gICFhY2Ncbjs7XG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgaSAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF9tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbGV0IHJlc3VsdCA9XG4gICAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBsZXQgbmV3X2FjYywgeSA9IGYgaSAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgY291bnQgdCB+ZiA9XG4gIGxldCByZXN1bHQgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQgLSAxIGRvXG4gICAgcmVzdWx0IDo9ICFyZXN1bHQgKyAoZiAoQXJyYXkudW5zYWZlX2dldCB0IGkpIHw+IEJvb2wudG9faW50KVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgY291bnRpIHQgfmYgPVxuICBsZXQgcmVzdWx0ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0IC0gMSBkb1xuICAgIHJlc3VsdCA6PSAhcmVzdWx0ICsgKGYgaSAoQXJyYXkudW5zYWZlX2dldCB0IGkpIHw+IEJvb2wudG9faW50KVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgY29uY2F0X21hcCB0IH5mID0gY29uY2F0ICh0b19saXN0IChtYXAgfmYgdCkpXG5sZXQgY29uY2F0X21hcGkgdCB+ZiA9IGNvbmNhdCAodG9fbGlzdCAobWFwaSB+ZiB0KSlcblxubGV0IHJldl9pbnBsYWNlIHQgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIHdoaWxlICFpIDwgIWogZG9cbiAgICBzd2FwIHQgIWkgIWo7XG4gICAgaW5jciBpO1xuICAgIGRlY3IgalxuICBkb25lXG47O1xuXG5sZXQgcmV2IHQgPVxuICBsZXQgdCA9IGNvcHkgdCBpblxuICByZXZfaW5wbGFjZSB0O1xuICB0XG47O1xuXG5sZXQgb2ZfbGlzdF9yZXYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCBhIDo6IGwgLT5cbiAgICBsZXQgbGVuID0gMSArIExpc3QubGVuZ3RoIGwgaW5cbiAgICBsZXQgdCA9IGNyZWF0ZSB+bGVuIGEgaW5cbiAgICBsZXQgciA9IHJlZiBsIGluXG4gICAgKCogV2Ugc3RhcnQgYXQgW2xlbiAtIDJdIGJlY2F1c2Ugd2UgYWxyZWFkeSBwdXQgW2FdIGF0IFt0LihsZW4gLSAxKV0uICopXG4gICAgZm9yIGkgPSBsZW4gLSAyIGRvd250byAwIGRvXG4gICAgICBtYXRjaCAhciB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBhIDo6IGwgLT5cbiAgICAgICAgdC4oaSkgPC0gYTtcbiAgICAgICAgciA6PSBsXG4gICAgZG9uZTtcbiAgICB0XG47O1xuXG4oKiBbb2ZfbGlzdF9tYXBdIGFuZCBbb2ZfbGlzdF9yZXZfbWFwXSBhcmUgYmFzZWQgb24gZnVuY3Rpb25zIGZyb20gdGhlIE9DYW1sXG4gICBkaXN0cmlidXRpb24uICopXG5cbmxldCBvZl9saXN0X21hcCB4cyB+ZiA9XG4gIG1hdGNoIHhzIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgaGQgOjogdGwgLT5cbiAgICBsZXQgYSA9IGNyZWF0ZSB+bGVuOigxICsgTGlzdC5sZW5ndGggdGwpIChmIGhkKSBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gYVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICB1bnNhZmVfc2V0IGEgaSAoZiBoZCk7XG4gICAgICAgIGZpbGwgKGkgKyAxKSB0bFxuICAgIGluXG4gICAgZmlsbCAxIHRsIFtAbm9udGFpbF1cbjs7XG5cbmxldCBvZl9saXN0X21hcGkgeHMgfmYgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGhkIDo6IHRsIC0+XG4gICAgbGV0IGEgPSBjcmVhdGUgfmxlbjooMSArIExpc3QubGVuZ3RoIHRsKSAoZiAwIGhkKSBpblxuICAgIGxldCByZWMgZmlsbCBhIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBhXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIHVuc2FmZV9zZXQgYSBpIChmIGkgaGQpO1xuICAgICAgICBmaWxsIGEgKGkgKyAxKSB0bFxuICAgIGluXG4gICAgZmlsbCBhIDEgdGwgW0Bub250YWlsXVxuOztcblxubGV0IG9mX2xpc3RfcmV2X21hcCB4cyB+ZiA9XG4gIGxldCB0ID0gb2ZfbGlzdF9tYXAgeHMgfmYgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IG9mX2xpc3RfcmV2X21hcGkgeHMgfmYgPVxuICBsZXQgdCA9IG9mX2xpc3RfbWFwaSB4cyB+ZiBpblxuICByZXZfaW5wbGFjZSB0O1xuICB0XG47O1xuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCByID0gcmVmIFt8fF0gaW5cbiAgbGV0IGsgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgbWF0Y2ggZiBpICh1bnNhZmVfZ2V0IHQgaSkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBhIC0+XG4gICAgICBpZiAhayA9IDAgdGhlbiByIDo9IGNyZWF0ZSB+bGVuOihsZW5ndGggdCkgYTtcbiAgICAgIHVuc2FmZV9zZXQgIXIgIWsgYTtcbiAgICAgIGluY3Iga1xuICBkb25lO1xuICBpZiAhayA9IGxlbmd0aCB0IHRoZW4gIXIgZWxzZSBpZiAhayA+IDAgdGhlbiBzdWIgfnBvczowIH5sZW46IWsgIXIgZWxzZSBbfHxdXG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIF9pIGEgLT4gZiBhKSBbQG5vbnRhaWxdXG5sZXQgZmlsdGVyX29wdCB0ID0gZmlsdGVyX21hcCB0IH5mOkZuLmlkXG5cbmxldCByYWlzZV9sZW5ndGhfbWlzbWF0Y2ggbmFtZSBuMSBuMiA9XG4gIGludmFsaWRfYXJnZiBcImxlbmd0aCBtaXNtYXRjaCBpbiAlczogJWQgPD4gJWRcIiBuYW1lIG4xIG4yICgpXG4gIFtAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgY2hlY2tfbGVuZ3RoMl9leG4gbmFtZSB0MSB0MiA9XG4gIGxldCBuMSA9IGxlbmd0aCB0MSBpblxuICBsZXQgbjIgPSBsZW5ndGggdDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiByYWlzZV9sZW5ndGhfbWlzbWF0Y2ggbmFtZSBuMSBuMlxuOztcblxubGV0IGl0ZXIyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuaXRlcjJfZXhuXCIgdDEgdDI7XG4gIGl0ZXJpIHQxIH5mOihmdW4gaSB4MSAtPiBmIHgxICh1bnNhZmVfZ2V0IHQyIGkpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWFwMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5Lm1hcDJfZXhuXCIgdDEgdDI7XG4gIGluaXQgKGxlbmd0aCB0MSkgfmY6KGZ1biBpIC0+IGYgKHVuc2FmZV9nZXQgdDEgaSkgKHVuc2FmZV9nZXQgdDIgaSkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkMl9leG4gdDEgdDIgfmluaXQgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5LmZvbGQyX2V4blwiIHQxIHQyO1xuICBmb2xkaSB0MSB+aW5pdCB+ZjooZnVuIGkgYWMgeCAtPiBmIGFjIHggKHVuc2FmZV9nZXQgdDIgaSkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSkgW0Bub250YWlsXVxubGV0IGZpbHRlcmkgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiBTb21lIHggZWxzZSBOb25lKSBbQG5vbnRhaWxdXG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgKHVuc2FmZV9nZXQgdCAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiBmYWxzZSBpblxuICB3aGlsZSAhaSA+PSAwICYmIG5vdCAhcmVzdWx0IGRvXG4gICAgaWYgZiAhaSAodW5zYWZlX2dldCB0ICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9IGV4aXN0cyB0IH5mOihlcXVhbCBhKSBbQG5vbnRhaWxdXG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiAhcmVzdWx0IGRvXG4gICAgaWYgbm90IChmICh1bnNhZmVfZ2V0IHQgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAhaSAodW5zYWZlX2dldCB0ICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGV4aXN0czJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5leGlzdHMyX2V4blwiIHQxIHQyO1xuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQxIC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiBmYWxzZSBpblxuICB3aGlsZSAhaSA+PSAwICYmIG5vdCAhcmVzdWx0IGRvXG4gICAgaWYgZiAodW5zYWZlX2dldCB0MSAhaSkgKHVuc2FmZV9nZXQgdDIgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGZvcl9hbGwyX2xvY2FsX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZm9yX2FsbDJfZXhuXCIgdDEgdDI7XG4gIGxldCBpID0gcmVmIChsZW5ndGggdDEgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiAhcmVzdWx0IGRvXG4gICAgaWYgbm90IChmICh1bnNhZmVfZ2V0IHQxICFpKSAodW5zYWZlX2dldCB0MiAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsMl9leG4gdDEgdDIgfmYgPSBmb3JfYWxsMl9sb2NhbF9leG4gdDEgdDIgfmZcbmxldCBlcXVhbF9fbG9jYWwgZXF1YWwgdDEgdDIgPSBsZW5ndGggdDEgPSBsZW5ndGggdDIgJiYgZm9yX2FsbDJfbG9jYWxfZXhuIHQxIHQyIH5mOmVxdWFsXG5sZXQgZXF1YWwgZXF1YWwgdDEgdDIgPSBlcXVhbF9fbG9jYWwgZXF1YWwgdDEgdDJcblxubGV0IG1hcF9pbnBsYWNlIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgdW5zYWZlX3NldCB0IGkgKGYgKHVuc2FmZV9nZXQgdCBpKSlcbiAgZG9uZVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBmaW5kaV9pbnRlcm5hbCB0IH5mIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBpZl9ub3RfZm91bmQgKClcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBmb3VuZCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgd2hpbGUgKG5vdCAhZm91bmQpICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIGlmIGYgIWkgdmFsdWVcbiAgICAgIHRoZW4gKFxuICAgICAgICB2YWx1ZV9mb3VuZCA6PSB2YWx1ZTtcbiAgICAgICAgZm91bmQgOj0gdHJ1ZSlcbiAgICAgIGVsc2UgaW5jciBpXG4gICAgZG9uZTtcbiAgICBpZiAhZm91bmQgdGhlbiBpZl9mb3VuZCB+aTohaSB+dmFsdWU6IXZhbHVlX2ZvdW5kIGVsc2UgaWZfbm90X2ZvdW5kICgpKVxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZlxuICAgIH5pZl9mb3VuZDooZnVuIH5pIH52YWx1ZSAtPiBTb21lIChpLCB2YWx1ZSkpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuICgpIC0+IE5vbmUpXG47O1xuXG5sZXQgZmluZGlfZXhuIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZlxuICAgIH5pZl9mb3VuZDooZnVuIH5pIH52YWx1ZSAtPiBpLCB2YWx1ZSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4gKCkgLT4gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZGlfZXhuOiBub3QgZm91bmRcIikpKVxuOztcblxubGV0IGZpbmRfZXhuIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZjooZnVuIF9pIHggLT4gZiB4KVxuICAgIH5pZl9mb3VuZDooZnVuIH5pOl8gfnZhbHVlIC0+IHZhbHVlKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biAoKSAtPiByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kX2V4bjogbm90IGZvdW5kXCIpKSlcbiAgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmQgdCB+ZiA9IE9wdGlvbi5tYXAgKGZpbmRpIHQgfmY6KGZ1biBfaSB4IC0+IGYgeCkpIH5mOihmdW4gKF9pLCB4KSAtPiB4KVxuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmIE5vbmUgaW5cbiAgICB3aGlsZSBPcHRpb24uaXNfbm9uZSAhdmFsdWVfZm91bmQgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgdmFsdWVfZm91bmQgOj0gZiB2YWx1ZTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgIXZhbHVlX2ZvdW5kKVxuOztcblxubGV0IGZpbmRfbWFwX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRfbWFwX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcF9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXAgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcF9leG5cbjs7XG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmIE5vbmUgaW5cbiAgICB3aGlsZSBPcHRpb24uaXNfbm9uZSAhdmFsdWVfZm91bmQgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgdmFsdWVfZm91bmQgOj0gZiAhaSB2YWx1ZTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgIXZhbHVlX2ZvdW5kKVxuOztcblxubGV0IGZpbmRfbWFwaV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kX21hcGlfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXBpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBpX2V4blxuOztcblxubGV0IGZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIHQgfmVxdWFsID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBpZiBuIDw9IDFcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByZXN1bHQgPSByZWYgTm9uZSBpblxuICAgIGxldCBpID0gcmVmIDEgaW5cbiAgICBsZXQgcHJldiA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgd2hpbGUgIWkgPCBuIGRvXG4gICAgICBsZXQgY3VyID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICBpZiBlcXVhbCBjdXIgIXByZXZcbiAgICAgIHRoZW4gKFxuICAgICAgICByZXN1bHQgOj0gU29tZSAoIXByZXYsIGN1cik7XG4gICAgICAgIGkgOj0gbilcbiAgICAgIGVsc2UgKFxuICAgICAgICBwcmV2IDo9IGN1cjtcbiAgICAgICAgaW5jciBpKVxuICAgIGRvbmU7XG4gICAgIXJlc3VsdClcbjs7XG5cbmxldCByZWR1Y2UgdCB+ZiA9XG4gIGlmIGxlbmd0aCB0ID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHIgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIGZvciBpID0gMSB0byBsZW5ndGggdCAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpXG4gICAgZG9uZTtcbiAgICBTb21lICFyKVxuOztcblxubGV0IHJlZHVjZV9leG4gdCB+ZiA9XG4gIG1hdGNoIHJlZHVjZSB0IH5mIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiQXJyYXkucmVkdWNlX2V4blwiXG4gIHwgU29tZSB2IC0+IHZcbjs7XG5cbmxldCBwZXJtdXRlID0gQXJyYXlfcGVybXV0ZS5wZXJtdXRlXG5cbmxldCByYW5kb21fZWxlbWVudF9leG4gPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgdCA9XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiBmYWlsd2l0aCBcIkFycmF5LnJhbmRvbV9lbGVtZW50X2V4bjogZW1wdHkgYXJyYXlcIlxuICBlbHNlIHQuKFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChsZW5ndGggdCkpXG47O1xuXG5sZXQgcmFuZG9tX2VsZW1lbnQgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgdCA9XG4gIHRyeSBTb21lIChyYW5kb21fZWxlbWVudF9leG4gfnJhbmRvbV9zdGF0ZSB0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgemlwIHQxIHQyID1cbiAgaWYgbGVuZ3RoIHQxIDw+IGxlbmd0aCB0MiB0aGVuIE5vbmUgZWxzZSBTb21lIChtYXAyX2V4biB0MSB0MiB+ZjooZnVuIHgxIHgyIC0+IHgxLCB4MikpXG47O1xuXG5sZXQgemlwX2V4biB0MSB0MiA9XG4gIGlmIGxlbmd0aCB0MSA8PiBsZW5ndGggdDJcbiAgdGhlbiBmYWlsd2l0aCBcIkFycmF5LnppcF9leG5cIlxuICBlbHNlIG1hcDJfZXhuIHQxIHQyIH5mOihmdW4geDEgeDIgLT4geDEsIHgyKVxuOztcblxubGV0IHVuemlwIHQgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gW3x8XSwgW3x8XVxuICBlbHNlIChcbiAgICBsZXQgeCwgeSA9IHQuKDApIGluXG4gICAgbGV0IHJlczEgPSBjcmVhdGUgfmxlbjpuIHggaW5cbiAgICBsZXQgcmVzMiA9IGNyZWF0ZSB+bGVuOm4geSBpblxuICAgIGZvciBpID0gMSB0byBuIC0gMSBkb1xuICAgICAgbGV0IHgsIHkgPSB0LihpKSBpblxuICAgICAgcmVzMS4oaSkgPC0geDtcbiAgICAgIHJlczIuKGkpIDwtIHlcbiAgICBkb25lO1xuICAgIHJlczEsIHJlczIpXG47O1xuXG5sZXQgc29ydGVkX2NvcHkgdCB+Y29tcGFyZSA9XG4gIGxldCB0MSA9IGNvcHkgdCBpblxuICBzb3J0IHQxIH5jb21wYXJlO1xuICB0MVxuOztcblxubGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPVxuICBsZXQgKGJvdGggOiBfIEVpdGhlci50IHQpID0gbWFwaSB0IH5mIGluXG4gIGxldCBmaXJzdHMgPVxuICAgIGZpbHRlcl9tYXAgYm90aCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgeCAtPiBTb21lIHhcbiAgICAgIHwgU2Vjb25kIF8gLT4gTm9uZSlcbiAgaW5cbiAgbGV0IHNlY29uZHMgPVxuICAgIGZpbHRlcl9tYXAgYm90aCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgXyAtPiBOb25lXG4gICAgICB8IFNlY29uZCB4IC0+IFNvbWUgeClcbiAgaW5cbiAgZmlyc3RzLCBzZWNvbmRzXG47O1xuXG5sZXQgcGFydGl0aW9uaV90ZiB0IH5mID1cbiAgcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIEZpcnN0IHggZWxzZSBTZWNvbmQgeCkgW0Bub250YWlsXVxuOztcblxubGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9IHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biBfIHggLT4gZiB4KSBbQG5vbnRhaWxdXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biBfIHggLT4gZiB4KSBbQG5vbnRhaWxdXG5sZXQgbGFzdCB0ID0gdC4obGVuZ3RoIHQgLSAxKVxuXG4oKiBDb252ZXJ0IHRvIGEgc2VxdWVuY2UgYnV0IGRvZXMgbm90IGF0dGVtcHQgdG8gcHJvdGVjdCBhZ2FpbnN0IG1vZGlmaWNhdGlvblxuICAgaW4gdGhlIGFycmF5LiAqKVxubGV0IHRvX3NlcXVlbmNlX211dGFibGUgdCA9XG4gIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OjAgfmY6KGZ1biBpIC0+XG4gICAgaWYgaSA+PSBsZW5ndGggdFxuICAgIHRoZW4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgZWxzZSBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSB0LihpKTsgc3RhdGUgPSBpICsgMSB9KVxuOztcblxubGV0IHRvX3NlcXVlbmNlIHQgPSB0b19zZXF1ZW5jZV9tdXRhYmxlIChjb3B5IHQpXG5cbmxldCBjYXJ0ZXNpYW5fcHJvZHVjdCB0MSB0MiA9XG4gIGlmIGlzX2VtcHR5IHQxIHx8IGlzX2VtcHR5IHQyXG4gIHRoZW4gW3x8XVxuICBlbHNlIChcbiAgICBsZXQgbjEgPSBsZW5ndGggdDEgaW5cbiAgICBsZXQgbjIgPSBsZW5ndGggdDIgaW5cbiAgICBsZXQgdCA9IGNyZWF0ZSB+bGVuOihuMSAqIG4yKSAodDEuKDApLCB0Mi4oMCkpIGluXG4gICAgbGV0IHIgPSByZWYgMCBpblxuICAgIGZvciBpMSA9IDAgdG8gbjEgLSAxIGRvXG4gICAgICBmb3IgaTIgPSAwIHRvIG4yIC0gMSBkb1xuICAgICAgICB0LighcikgPC0gdDEuKGkxKSwgdDIuKGkyKTtcbiAgICAgICAgaW5jciByXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICB0KVxuOztcblxubGV0IHRyYW5zcG9zZSB0dCA9XG4gIGlmIGxlbmd0aCB0dCA9IDBcbiAgdGhlbiBTb21lIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IHdpZHRoID0gbGVuZ3RoIHR0IGluXG4gICAgbGV0IGRlcHRoID0gbGVuZ3RoIHR0LigwKSBpblxuICAgIGlmIGV4aXN0cyB0dCB+ZjooZnVuIHQgLT4gbGVuZ3RoIHQgPD4gZGVwdGgpXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSBTb21lIChpbml0IGRlcHRoIH5mOihmdW4gZCAtPiBpbml0IHdpZHRoIH5mOihmdW4gdyAtPiB0dC4odykuKGQpKSkpKVxuOztcblxubGV0IHRyYW5zcG9zZV9leG4gdHQgPVxuICBtYXRjaCB0cmFuc3Bvc2UgdHQgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJBcnJheS50cmFuc3Bvc2VfZXhuXCJcbiAgfCBTb21lIHR0JyAtPiB0dCdcbjs7XG5cbmluY2x1ZGUgQmluYXJ5X3NlYXJjaGFibGUuTWFrZTEgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBnZXQgPSBnZXRcbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuZW5kKVxuXG5pbmNsdWRlIEJsaXQuTWFrZTEgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBsZW5ndGggPSBsZW5ndGhcblxuICBsZXQgY3JlYXRlX2xpa2UgfmxlbiB0ID1cbiAgICBpZiBsZW4gPSAwXG4gICAgdGhlbiBbfHxdXG4gICAgZWxzZSAoXG4gICAgICBhc3NlcnQgKGxlbmd0aCB0ID4gMCk7XG4gICAgICBjcmVhdGUgfmxlbiB0LigwKSlcbiAgOztcblxuICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuZW5kKVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBpdGVyIHQgfmY6aW52YXJpYW50X2FcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFNvcnQgPSBTb3J0XG4gIG1vZHVsZSBTb3J0ZXIgPSBTb3J0ZXJcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgY2VpbCA9IFN0ZGxpYi5jZWlsXG5sZXQgZmxvb3IgPSBTdGRsaWIuZmxvb3JcbmxldCBtb2RfZmxvYXQgPSBTdGRsaWIubW9kX2Zsb2F0XG5sZXQgbW9kZiA9IFN0ZGxpYi5tb2RmXG5sZXQgZmxvYXRfb2Zfc3RyaW5nID0gU3RkbGliLmZsb2F0X29mX3N0cmluZ1xubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgPSBTdGRsaWIuZmxvYXRfb2Zfc3RyaW5nX29wdFxubGV0IG5hbiA9IFN0ZGxpYi5uYW5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBtYXhfZmluaXRlX3ZhbHVlID0gU3RkbGliLm1heF9mbG9hdFxubGV0IGVwc2lsb25fZmxvYXQgPSBTdGRsaWIuZXBzaWxvbl9mbG9hdFxubGV0IGNsYXNzaWZ5X2Zsb2F0ID0gU3RkbGliLmNsYXNzaWZ5X2Zsb2F0XG5sZXQgYWJzX2Zsb2F0ID0gU3RkbGliLmFic19mbG9hdFxubGV0IGlzX2ludGVnZXIgPSBTdGRsaWIuRmxvYXQuaXNfaW50ZWdlclxubGV0ICggKiogKSA9IFN0ZGxpYi4oICoqIClcblxubGV0ICggJS4gKSBhIGIgPVxuICAoKiBSYWlzZSBpbiBjYXNlIG9mIGEgbmVnYXRpdmUgbW9kdWx1cywgYXMgZG9lcyBJbnQuKCAlICkuICopXG4gIGlmIGIgPCAwLlxuICB0aGVuIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCIlZiAlJSAlZiBpbiBmbG9hdDAubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCIgYSBiICgpO1xuICBsZXQgbSA9IFN0ZGxpYi5tb2RfZmxvYXQgYSBiIGluXG4gICgqIFByb2R1Y2UgYSBub24tbmVnYXRpdmUgcmVzdWx0IGluIGFuYWxvZ3kgd2l0aCBJbnQuKCAlICkuICopXG4gIGlmIG0gPCAwLiB0aGVuIG0gKy4gYiBlbHNlIG1cbjs7XG5cbigqIFRoZSBiaXRzIG9mIElOUklBJ3MgW1N0ZGxpYl0gdGhhdCB3ZSBqdXN0IHdhbnQgdG8gZXhwb3NlIGluIFtGbG9hdF0uIE1vc3QgYXJlXG4gICBhbHJlYWR5IGRlcHJlY2F0ZWQgaW4gW1N0ZGxpYl0sIGFuZCBldmVudHVhbGx5IGFsbCBvZiB0aGVtIHNob3VsZCBiZS4gKilcbmluY2x1ZGUgKFxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIFN0ZGxpYlxuICAgIGluY2x1ZGUgU3RkbGliLkZsb2F0XG4gIGVuZCA6XG4gICAgc2lnXG4gICAgICBleHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcblxuICAgICAgZXh0ZXJuYWwgbGRleHBcbiAgICAgICAgOiAgKGZsb2F0W0B1bmJveGVkXSlcbiAgICAgICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgICAgICAtPiAoZmxvYXRbQHVuYm94ZWRdKVxuICAgICAgICA9IFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCJcbiAgICAgICAgW0BAbm9hbGxvY11cblxuICAgICAgZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBsb2cyIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMl9mbG9hdFwiIFwiY2FtbF9sb2cyXCJcbiAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgICAgZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgICAgZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgICAgZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgICAgZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgICAgZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgICAgZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgICAgZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBhY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NoX2Zsb2F0XCIgXCJjYW1sX2Fjb3NoXCJcbiAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgICAgZXh0ZXJuYWwgYXNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luaF9mbG9hdFwiIFwiY2FtbF9hc2luaFwiXG4gICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGF0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbmhfZmxvYXRcIiBcImNhbWxfYXRhbmhcIlxuICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIlxuICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZW5kKVxuXG4oKiBXZSBuZWVkIHRoaXMgaW5kaXJlY3Rpb24gYmVjYXVzZSB0aGVzZSBhcmUgZXhwb3NlZCBhcyBcInZhbFwiIGluc3RlYWQgb2YgXCJleHRlcm5hbFwiICopXG5sZXQgZnJleHAgPSBmcmV4cFxubGV0IGxkZXhwID0gbGRleHBcbmxldCBpc19uYW4geCA9ICh4IDogZmxvYXQpIDw+IHhcblxuKCogQW4gb3JkZXItcHJlc2VydmluZyBiaWplY3Rpb24gYmV0d2VlbiBhbGwgZmxvYXRzIGV4Y2VwdCBmb3IgTmFOcywgYW5kIDk5Ljk1JSBvZlxuICAgaW50NjRzLlxuXG4gICBOb3RlIHdlIGRvbid0IGRpc3Rpbmd1aXNoIDAuIGFuZCAtMC4gYXMgc2VwYXJhdGUgdmFsdWVzIGhlcmUsIHRoZXkgYm90aCBtYXAgdG8gMEwsIHdoaWNoXG4gICBtYXBzIGJhY2sgdG8gMC5cblxuICAgVGhpcyBzaG91bGQgd29yayBib3RoIG9uIGxpdHRsZS1lbmRpYW4gYW5kIGhpZ2gtZW5kaWFuIENQVXMuICBXaWtpcGVkaWEgc2F5czogXCJvblxuICAgbW9kZXJuIHN0YW5kYXJkIGNvbXB1dGVycyAoaS5lLiwgaW1wbGVtZW50aW5nIElFRUUgNzU0KSwgb25lIG1heSBpbiBwcmFjdGljZSBzYWZlbHlcbiAgIGFzc3VtZSB0aGF0IHRoZSBlbmRpYW5uZXNzIGlzIHRoZSBzYW1lIGZvciBmbG9hdGluZyBwb2ludCBudW1iZXJzIGFzIGZvciBpbnRlZ2Vyc1wiXG4gICAoaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbmRpYW5uZXNzI0Zsb2F0aW5nLXBvaW50X2FuZF9lbmRpYW5uZXNzKS5cbiopXG5sZXQgdG9faW50NjRfcHJlc2VydmVfb3JkZXIgdCA9XG4gIGlmIGlzX25hbiB0XG4gIHRoZW4gTm9uZVxuICBlbHNlIGlmIHQgPSAwLlxuICB0aGVuICgqIGFsc28gaW5jbHVkZXMgLTAuICopXG4gICAgU29tZSAwTFxuICBlbHNlIGlmIHQgPiAwLlxuICB0aGVuIFNvbWUgKFN0ZGxpYi5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQpXG4gIGVsc2UgU29tZSAoU3RkbGliLkludDY0Lm5lZyAoU3RkbGliLkludDY0LmJpdHNfb2ZfZmxvYXQgKC0udCkpKVxuOztcblxubGV0IHRvX2ludDY0X3ByZXNlcnZlX29yZGVyX2V4biB4ID0gT3B0aW9uLnZhbHVlX2V4biAodG9faW50NjRfcHJlc2VydmVfb3JkZXIgeClcblxubGV0IG9mX2ludDY0X3ByZXNlcnZlX29yZGVyIHggPVxuICBpZiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIHggMExcbiAgdGhlbiBTdGRsaWIuSW50NjQuZmxvYXRfb2ZfYml0cyB4XG4gIGVsc2Ugfi0uKFN0ZGxpYi5JbnQ2NC5mbG9hdF9vZl9iaXRzIChTdGRsaWIuSW50NjQubmVnIHgpKVxuOztcblxubGV0IG9uZV91bHAgZGlyIHQgPVxuICBtYXRjaCB0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB0IHdpdGhcbiAgfCBOb25lIC0+IFN0ZGxpYi5uYW5cbiAgfCBTb21lIHggLT5cbiAgICBvZl9pbnQ2NF9wcmVzZXJ2ZV9vcmRlclxuICAgICAgKFN0ZGxpYi5JbnQ2NC5hZGRcbiAgICAgICAgIHhcbiAgICAgICAgIChtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgIHwgYFVwIC0+IDFMXG4gICAgICAgICAgfCBgRG93biAtPiAtMUwpKVxuOztcblxuKCogW3VwcGVyX2JvdW5kX2Zvcl9pbnRdIGFuZCBbbG93ZXJfYm91bmRfZm9yX2ludF0gYXJlIGZvciBjYWxjdWxhdGluZyB0aGUgbWF4L21pbiBmbG9hdFxuICAgdGhhdCBmaXRzIGluIGEgZ2l2ZW4tc2l6ZSBpbnRlZ2VyIHdoZW4gcm91bmRlZCB0b3dhcmRzIDAgKHVzaW5nIFtpbnRfb2ZfZmxvYXRdKS5cblxuICAgbWF4X2ludC9taW5faW50IGRlcGVuZCBvbiBbbnVtX2JpdHNdLCBlLmcuICsvLSAyXjMwLCArLy0gMl42MiBpZiAzMS1iaXQsIDYzLWJpdFxuICAgKHJlc3BlY3RpdmVseSkgd2hpbGUgZmxvYXQgaXMgSUVFRSBzdGFuZGFyZCBmb3IgZG91YmxlICg1MiBzaWduaWZpY2FudCBiaXRzKS5cblxuICAgSW4gYWxsIGNhc2VzLCB3ZSB3YW50IHRvIGd1YXJhbnRlZSB0aGF0XG4gICBbbG93ZXJfYm91bmRfZm9yX2ludCA8PSB4IDw9IHVwcGVyX2JvdW5kX2Zvcl9pbnRdXG4gICBpZmYgW2ludF9vZl9mbG9hdCB4XSBmaXRzIGluIGFuIGludCB3aXRoIFtudW1fYml0c10gYml0cy5cblxuICAgWzIgKiogKG51bV9iaXRzIC0gMSldIGlzIHRoZSBmaXJzdCBmbG9hdCBncmVhdGVyIHRoYXQgbWF4X2ludCwgd2UgdXNlIHRoZSBwcmVjZWRpbmdcbiAgIGZsb2F0IGFzIHVwcGVyIGJvdW5kLlxuXG4gICBbLSAoMiAqKiAobnVtX2JpdHMgLSAxKSldIGlzIGVxdWFsIHRvIG1pbl9pbnQuXG4gICBGb3IgbG93ZXIgYm91bmQgd2UgbG9vayBmb3IgdGhlIHNtYWxsZXN0IGZsb2F0IFtmXSBzYXRpc2Z5aW5nIFtmID4gbWluX2ludCAtIDFdIHNvIHRoYXRcbiAgIFtmXSByb3VuZHMgdG93YXJkIHplcm8gdG8gW21pbl9pbnRdXG5cbiAgIFNvIGluIHBhcnRpY3VsYXIgd2Ugd2lsbCBoYXZlOlxuICAgW2xvd2VyX2JvdW5kX2Zvcl9pbnQgeCA8PSAtICgyICoqICgxLXgpKV1cbiAgIFt1cHBlcl9ib3VuZF9mb3JfaW50IHggIDwgICAgMiAqKiAoMS14KSBdXG4qKVxubGV0IHVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHMgPVxuICBsZXQgZXhwID0gU3RkbGliLmZsb2F0X29mX2ludCAobnVtX2JpdHMgLSAxKSBpblxuICBvbmVfdWxwIGBEb3duICgyLiAqKiBleHApXG47O1xuXG5sZXQgaXNfeF9taW51c19vbmVfZXhhY3QgeCA9XG4gICgqIFt4ID0geCAtLiAxLl0gZG9lcyBub3Qgd29yayB3aXRoIHg4NyBmbG9hdGluZyBwb2ludCBhcml0aG1ldGljIGJhY2tlbmQgKHdoaWNoIGlzIHVzZWRcbiAgICAgb24gMzItYml0IG9jYW1sKSBiZWNhdXNlIG9mIDgwLWJpdCByZWdpc3RlciBwcmVjaXNpb24gb2YgaW50ZXJtZWRpYXRlIGNvbXB1dGF0aW9ucy5cblxuICAgICBBbiBhbHRlcm5hdGl2ZSB3YXkgb2YgY29tcHV0aW5nIHRoaXM6IFt4IC0uIG9uZV91bHAgYERvd24geCA8PSAxLl0gaXMgYWxzbyBwcm9uZSB0b1xuICAgICB0aGUgc2FtZSBwcmVjaXNpb24gaXNzdWVzOiB5b3UgbmVlZCB0byBtYWtlIHN1cmUgW3hdIGlzIDY0LWJpdC5cbiAgKilcbiAgbGV0IG9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIG5vdCAoU3RkbGliLkludDY0LmJpdHNfb2ZfZmxvYXQgeCA9IFN0ZGxpYi5JbnQ2NC5iaXRzX29mX2Zsb2F0ICh4IC0uIDEuKSlcbjs7XG5cbmxldCBsb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzID1cbiAgbGV0IGV4cCA9IFN0ZGxpYi5mbG9hdF9vZl9pbnQgKG51bV9iaXRzIC0gMSkgaW5cbiAgbGV0IG1pbl9pbnRfYXNfZmxvYXQgPSB+LS4oMi4gKiogZXhwKSBpblxuICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIG51bV9iaXRzIC0gMSA8IDUzICgqIDUzID0gI2JpdHMgaW4gdGhlIGZsb2F0J3MgbWFudGlzc2Egd2l0aCBzaWduIGluY2x1ZGVkICopXG4gIHRoZW4gKFxuICAgICgqIFRoZSBzbWFsbGVzdCBmbG9hdCB0aGF0IHJvdW5kcyB0b3dhcmRzIHplcm8gdG8gW21pbl9pbnRdIGlzXG4gICAgICAgW21pbl9pbnQgLSAxICsgZXBzaWxvbl0gKilcbiAgICBhc3NlcnQgKGlzX3hfbWludXNfb25lX2V4YWN0IG1pbl9pbnRfYXNfZmxvYXQpO1xuICAgIG9uZV91bHAgYFVwIChtaW5faW50X2FzX2Zsb2F0IC0uIDEuKSlcbiAgZWxzZSAoXG4gICAgKCogW21pbl9pbnRfYXNfZmxvYXRdIGlzIGFscmVhZHkgdGhlIHNtYWxsZXN0IGZsb2F0IFtmXSBzYXRpc2Z5aW5nIFtmID4gbWluX2ludCAtIDFdLiAqKVxuICAgIGFzc2VydCAobm90IChpc194X21pbnVzX29uZV9leGFjdCBtaW5faW50X2FzX2Zsb2F0KSk7XG4gICAgbWluX2ludF9hc19mbG9hdClcbjs7XG5cbigqIFg4NiBkb2NzIHNheTpcblxuICAgSWYgb25seSBvbmUgdmFsdWUgaXMgYSBOYU4gKFNOYU4gb3IgUU5hTikgZm9yIHRoaXMgaW5zdHJ1Y3Rpb24sIHRoZSBzZWNvbmQgc291cmNlXG4gICBvcGVyYW5kLCBlaXRoZXIgYSBOYU4gb3IgYSB2YWxpZCBmbG9hdGluZy1wb2ludCB2YWx1ZVxuICAgaXMgd3JpdHRlbiB0byB0aGUgcmVzdWx0LlxuXG4gICBTbyB3ZSBoYXZlIHRvIGJlIFZFUlkgY2FyZWZ1bCBob3cgd2UgdXNlIHRoZXNlIVxuXG4gICBUaGVzZSBpbnRyaW5zaWNzIHdlcmUgY29waWVkIGZyb20gW09jYW1sX2ludHJpbnNpY3NdIHRvIGF2b2lkIGJ1aWxkIGRlcHMgd2UgZG9uJ3Qgd2FudFxuKilcbm1vZHVsZSBJbnRyaW5zaWNzX3dpdGhfd2VpcmRfbmFuX2JlaGF2aW9yID0gc3RydWN0XG4gIGxldFtAaW5saW5lIGFsd2F5c10gbWluIGEgYiA9IE9jYW1sX2ludHJpbnNpY3Nfa2VybmVsLkZsb2F0Lm1pbiBhIGJcbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBtYXggYSBiID0gT2NhbWxfaW50cmluc2ljc19rZXJuZWwuRmxvYXQubWF4IGEgYlxuZW5kXG5cbmxldCBjbGFtcF91bmNoZWNrZWRcbiAgfih0b19jbGFtcF9tYXliZV9uYW4gOiBmbG9hdClcbiAgfm1pbl93aGljaF9pc19ub3RfbmFuXG4gIH5tYXhfd2hpY2hfaXNfbm90X25hblxuICA9XG4gICgqIFdlIHdhbnQgdG8gcHJvcGFnYXRlIG5hbnM7IGFzIHBlciB0aGUgeDg2IGRvY3MsIHRoaXMgbWVhbnMgd2UgaGF2ZSB0byB1c2UgdGhlbSBhcyB0aGVcbiAgICAgX3NlY29uZF8gYXJndW1lbnQuICopXG4gIGxldCB0X21heWJlX25hbiA9XG4gICAgSW50cmluc2ljc193aXRoX3dlaXJkX25hbl9iZWhhdmlvci5tYXggbWluX3doaWNoX2lzX25vdF9uYW4gdG9fY2xhbXBfbWF5YmVfbmFuXG4gIGluXG4gIEludHJpbnNpY3Nfd2l0aF93ZWlyZF9uYW5fYmVoYXZpb3IubWluIG1heF93aGljaF9pc19ub3RfbmFuIHRfbWF5YmVfbmFuXG47O1xuXG5sZXQgYm94ID1cbiAgKCogUHJldmVudCBwb3RlbnRpYWwgY29uc3RhbnQgZm9sZGluZyBvZiBbKy4gMC5dIGluIHRoZSBuZWFyIG9jYW1sb3B0IGZ1dHVyZS4gKilcbiAgbGV0IHggPSBTeXMwLm9wYXF1ZV9pZGVudGl0eSAwLiBpblxuICBmdW4gZiAtPiBmICsuIHhcbjs7XG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIigqIFRoaXMgZmlsZSB3YXMgYXV0b2dlbmVyYXRlZCBieSAuLi9nZW5lcmF0ZS9nZW5lcmF0ZV9wb3dfb3ZlcmZsb3dfYm91bmRzLmV4ZSAqKVxuXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG4oKiBXZSBoYXZlIHRvIHVzZSBJbnQ2NC50b19pbnRfZXhuIGluc3RlYWQgb2YgaW50IGNvbnN0YW50cyB0byBtYWtlXG4gICBzdXJlIHRoYXQgZmlsZSBjYW4gYmUgcHJlcHJvY2Vzc2VkIG9uIDMyLWJpdCBtYWNoaW5lcy4gKilcblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnQzMl92YWx1ZSA6IGludDMyID0gMjE0NzQ4MzY0N2xcblxubGV0IGludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDMyIGFycmF5ID1cbiAgW3wgMjE0NzQ4MzY0N2xcbiAgIDsgMjE0NzQ4MzY0N2xcbiAgIDsgNDYzNDBsXG4gICA7IDEyOTBsXG4gICA7IDIxNWxcbiAgIDsgNzNsXG4gICA7IDM1bFxuICAgOyAyMWxcbiAgIDsgMTRsXG4gICA7IDEwbFxuICAgOyA4bFxuICAgOyA3bFxuICAgOyA1bFxuICAgOyA1bFxuICAgOyA0bFxuICAgOyA0bFxuICAgOyAzbFxuICAgOyAzbFxuICAgOyAzbFxuICAgOyAzbFxuICAgOyAybFxuICAgOyAybFxuICAgOyAybFxuICAgOyAybFxuICAgOyAybFxuICAgOyAybFxuICAgOyAybFxuICAgOyAybFxuICAgOyAybFxuICAgOyAybFxuICAgOyAybFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICAgOyAxbFxuICB8XVxuOztcblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnRfdmFsdWUgOiBpbnQgPSAtMSBsc3IgMVxuXG5sZXQgaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludCBhcnJheSA9XG4gIG1hdGNoIEludF9jb252ZXJzaW9ucy5udW1fYml0c19pbnQgd2l0aFxuICB8IDMyIC0+IEFycmF5Lm1hcCBpbnQzMl9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgfmY6U3RkbGliLkludDMyLnRvX2ludFxuICB8IDYzIC0+XG4gICAgW3wgU3RkbGliLkludDY0LnRvX2ludCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgICA7IFN0ZGxpYi5JbnQ2NC50b19pbnQgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgICAgOyBTdGRsaWIuSW50NjQudG9faW50IDIxNDc0ODM2NDdMXG4gICAgIDsgMTY2NDUxMFxuICAgICA7IDQ2MzQwXG4gICAgIDsgNTQwNFxuICAgICA7IDEyOTBcbiAgICAgOyA0NjNcbiAgICAgOyAyMTVcbiAgICAgOyAxMThcbiAgICAgOyA3M1xuICAgICA7IDQ5XG4gICAgIDsgMzVcbiAgICAgOyAyN1xuICAgICA7IDIxXG4gICAgIDsgMTdcbiAgICAgOyAxNFxuICAgICA7IDEyXG4gICAgIDsgMTBcbiAgICAgOyA5XG4gICAgIDsgOFxuICAgICA7IDdcbiAgICAgOyA3XG4gICAgIDsgNlxuICAgICA7IDVcbiAgICAgOyA1XG4gICAgIDsgNVxuICAgICA7IDRcbiAgICAgOyA0XG4gICAgIDsgNFxuICAgICA7IDRcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDNcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICB8XVxuICB8IDMxIC0+XG4gICAgW3wgMTA3Mzc0MTgyM1xuICAgICA7IDEwNzM3NDE4MjNcbiAgICAgOyAzMjc2N1xuICAgICA7IDEwMjNcbiAgICAgOyAxODFcbiAgICAgOyA2M1xuICAgICA7IDMxXG4gICAgIDsgMTlcbiAgICAgOyAxM1xuICAgICA7IDEwXG4gICAgIDsgN1xuICAgICA7IDZcbiAgICAgOyA1XG4gICAgIDsgNFxuICAgICA7IDRcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgfF1cbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnQ2M19vbl9pbnQ2NF92YWx1ZSA6IGludDY0ID0gNDYxMTY4NjAxODQyNzM4NzkwM0xcblxubGV0IGludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDY0IGFycmF5ID1cbiAgW3wgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgIDsgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgIDsgMjE0NzQ4MzY0N0xcbiAgIDsgMTY2NDUxMExcbiAgIDsgNDYzNDBMXG4gICA7IDU0MDRMXG4gICA7IDEyOTBMXG4gICA7IDQ2M0xcbiAgIDsgMjE1TFxuICAgOyAxMThMXG4gICA7IDczTFxuICAgOyA0OUxcbiAgIDsgMzVMXG4gICA7IDI3TFxuICAgOyAyMUxcbiAgIDsgMTdMXG4gICA7IDE0TFxuICAgOyAxMkxcbiAgIDsgMTBMXG4gICA7IDlMXG4gICA7IDhMXG4gICA7IDdMXG4gICA7IDdMXG4gICA7IDZMXG4gICA7IDVMXG4gICA7IDVMXG4gICA7IDVMXG4gICA7IDRMXG4gICA7IDRMXG4gICA7IDRMXG4gICA7IDRMXG4gICA7IDNMXG4gICA7IDNMXG4gICA7IDNMXG4gICA7IDNMXG4gICA7IDNMXG4gICA7IDNMXG4gICA7IDNMXG4gICA7IDNMXG4gICA7IDNMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDJMXG4gICA7IDFMXG4gICA7IDFMXG4gIHxdXG47O1xuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDY0X3ZhbHVlIDogaW50NjQgPSA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuXG5sZXQgaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50NjQgYXJyYXkgPVxuICBbfCA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICAgOyA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICAgOyAzMDM3MDAwNDk5TFxuICAgOyAyMDk3MTUxTFxuICAgOyA1NTEwOExcbiAgIDsgNjIwOExcbiAgIDsgMTQ0OExcbiAgIDsgNTExTFxuICAgOyAyMzRMXG4gICA7IDEyN0xcbiAgIDsgNzhMXG4gICA7IDUyTFxuICAgOyAzOExcbiAgIDsgMjhMXG4gICA7IDIyTFxuICAgOyAxOExcbiAgIDsgMTVMXG4gICA7IDEzTFxuICAgOyAxMUxcbiAgIDsgOUxcbiAgIDsgOExcbiAgIDsgN0xcbiAgIDsgN0xcbiAgIDsgNkxcbiAgIDsgNkxcbiAgIDsgNUxcbiAgIDsgNUxcbiAgIDsgNUxcbiAgIDsgNExcbiAgIDsgNExcbiAgIDsgNExcbiAgIDsgNExcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMUxcbiAgfF1cbjs7XG5cbmxldCBpbnQ2NF9uZWdhdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQ2NCBhcnJheSA9XG4gIFt8IC05MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICAgOyAtOTIyMzM3MjAzNjg1NDc3NTgwN0xcbiAgIDsgLTMwMzcwMDA0OTlMXG4gICA7IC0yMDk3MTUxTFxuICAgOyAtNTUxMDhMXG4gICA7IC02MjA4TFxuICAgOyAtMTQ0OExcbiAgIDsgLTUxMUxcbiAgIDsgLTIzNExcbiAgIDsgLTEyN0xcbiAgIDsgLTc4TFxuICAgOyAtNTJMXG4gICA7IC0zOExcbiAgIDsgLTI4TFxuICAgOyAtMjJMXG4gICA7IC0xOExcbiAgIDsgLTE1TFxuICAgOyAtMTNMXG4gICA7IC0xMUxcbiAgIDsgLTlMXG4gICA7IC04TFxuICAgOyAtN0xcbiAgIDsgLTdMXG4gICA7IC02TFxuICAgOyAtNkxcbiAgIDsgLTVMXG4gICA7IC01TFxuICAgOyAtNUxcbiAgIDsgLTRMXG4gICA7IC00TFxuICAgOyAtNExcbiAgIDsgLTRMXG4gICA7IC0zTFxuICAgOyAtM0xcbiAgIDsgLTNMXG4gICA7IC0zTFxuICAgOyAtM0xcbiAgIDsgLTNMXG4gICA7IC0zTFxuICAgOyAtM0xcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMUxcbiAgfF1cbjs7XG4iLCJvcGVuISBJbXBvcnRcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcbmxldCBuZWdhdGl2ZV9leHBvbmVudCAoKSA9IFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJleHBvbmVudCBjYW4gbm90IGJlIG5lZ2F0aXZlXCIgKClcbmxldCBvdmVyZmxvdyAoKSA9IFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJpbnRlZ2VyIG92ZXJmbG93IGluIHBvd1wiICgpXG5cbigqIFRvIGltcGxlbWVudCBbaW50NjRfcG93XSwgd2UgdXNlIEMgY29kZSByYXRoZXIgdGhhbiBPQ2FtbCB0byBlbGltaW5hdGUgYWxsb2NhdGlvbi4gKilcbmV4dGVybmFsIGludF9tYXRoX2ludF9wb3cgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfcG93X3N0dWJcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBpbnRfbWF0aF9pbnQ2NF9wb3dcbiAgOiAgaW50NjRcbiAgLT4gaW50NjRcbiAgLT4gaW50NjRcbiAgPSBcIkJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWJcIiBcIkJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWJfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCBpbnRfcG93IGJhc2UgZXhwb25lbnQgPVxuICBpZiBleHBvbmVudCA8IDAgdGhlbiBuZWdhdGl2ZV9leHBvbmVudCAoKTtcbiAgaWYgYWJzIGJhc2UgPiAxXG4gICAgICYmIChleHBvbmVudCA+IDYzXG4gICAgICAgICB8fCBhYnMgYmFzZSA+IFBvd19vdmVyZmxvd19ib3VuZHMuaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcy4oZXhwb25lbnQpKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnRfcG93IGJhc2UgZXhwb25lbnRcbjs7XG5cbm1vZHVsZSBJbnQ2NF93aXRoX2NvbXBhcmlzb25zID0gc3RydWN0XG4gIGluY2x1ZGUgU3RkbGliLkludDY0XG5cbiAgZXh0ZXJuYWwgKCA8ICkgOiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+PSApIDogKGludDY0W0Bsb2NhbF9vcHRdKSAtPiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZW5kXG5cbigqIHdlIGRvbid0IGRvIFthYnNdIGluIGludDY0IGNhc2UgdG8gYXZvaWQgYWxsb2NhdGlvbiAqKVxubGV0IGludDY0X3BvdyBiYXNlIGV4cG9uZW50ID1cbiAgbGV0IG9wZW4gSW50NjRfd2l0aF9jb21wYXJpc29ucyBpblxuICBpZiBleHBvbmVudCA8IDBMIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIChiYXNlID4gMUwgfHwgYmFzZSA8IC0xTClcbiAgICAgJiYgKGV4cG9uZW50ID4gNjNMXG4gICAgICAgICB8fCAoYmFzZSA+PSAwTFxuICAgICAgICAgICAgICYmIGJhc2VcbiAgICAgICAgICAgICAgICA+IFBvd19vdmVyZmxvd19ib3VuZHMuaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzLih0b19pbnQgZXhwb25lbnQpKVxuICAgICAgICAgfHwgKGJhc2UgPCAwTFxuICAgICAgICAgICAgICYmIGJhc2VcbiAgICAgICAgICAgICAgICA8IFBvd19vdmVyZmxvd19ib3VuZHMuaW50NjRfbmVnYXRpdmVfb3ZlcmZsb3dfYm91bmRzLih0b19pbnQgZXhwb25lbnQpKSlcbiAgdGhlbiBvdmVyZmxvdyAoKTtcbiAgaW50X21hdGhfaW50NjRfcG93IGJhc2UgZXhwb25lbnRcbjs7XG5cbmxldCBpbnQ2M19wb3dfb25faW50NjQgYmFzZSBleHBvbmVudCA9XG4gIGxldCBvcGVuIEludDY0X3dpdGhfY29tcGFyaXNvbnMgaW5cbiAgaWYgZXhwb25lbnQgPCAwTCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiBhYnMgYmFzZSA+IDFMXG4gICAgICYmIChleHBvbmVudCA+IDYzTFxuICAgICAgICAgfHwgYWJzIGJhc2VcbiAgICAgICAgICAgID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2M19vbl9pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudClcbiAgICAgICAgKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnQ2NF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubW9kdWxlIHR5cGUgTWFrZV9hcmcgPSBzaWdcbiAgdHlwZSB0XG5cbiAgaW5jbHVkZSBGbG9hdGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgU3RyaW5nYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgKCArICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAtICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAqICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAvICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCB+LSApIDogdCAtPiB0XG5cbiAgaW5jbHVkZSBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIGFicyA6IHQgLT4gdFxuICB2YWwgbmVnIDogdCAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgb2ZfaW50X2V4biA6IGludCAtPiB0XG4gIHZhbCByZW0gOiB0IC0+IHQgLT4gdFxuZW5kXG5cbm1vZHVsZSBNYWtlIChYIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIG9wZW4gWFxuXG4gIGxldCAoICUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIiVzICUlICVzIGluIGNvcmVfaW50Lm1sOiBtb2R1bHVzIHNob3VsZCBiZSBwb3NpdGl2ZVwiXG4gICAgICAgICh0b19zdHJpbmcgeClcbiAgICAgICAgKHRvX3N0cmluZyB5KVxuICAgICAgICAoKTtcbiAgICBsZXQgcnZhbCA9IFgucmVtIHggeSBpblxuICAgIGlmIHJ2YWwgPCB6ZXJvIHRoZW4gcnZhbCArIHkgZWxzZSBydmFsXG4gIDs7XG5cbiAgbGV0IG9uZSA9IG9mX2ludF9leG4gMVxuXG4gIGxldCAoIC8lICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAvJSUgJXMgaW4gY29yZV9pbnQubWw6IGRpdmlzb3Igc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGlmIHggPCB6ZXJvIHRoZW4gKCh4ICsgb25lKSAvIHkpIC0gb25lIGVsc2UgeCAvIHlcbiAgOztcblxuICAoKiogZmxvYXQgZGl2aXNpb24gb2YgaW50ZWdlcnMgKilcbiAgbGV0ICggLy8gKSB4IHkgPSB0b19mbG9hdCB4IC8uIHRvX2Zsb2F0IHlcblxuICBsZXQgcm91bmRfZG93biBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID0gaSAtIChpICUgbW9kdWx1cylcblxuICBsZXQgcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2Y6bW9kdWx1cyA9XG4gICAgbGV0IHJlbWFpbmRlciA9IGkgJSBtb2R1bHVzIGluXG4gICAgaWYgcmVtYWluZGVyID0gemVybyB0aGVuIGkgZWxzZSBpICsgbW9kdWx1cyAtIHJlbWFpbmRlclxuICA7O1xuXG4gIGxldCByb3VuZF90b3dhcmRzX3plcm8gaSB+dG9fbXVsdGlwbGVfb2YgPVxuICAgIGlmIGkgPSB6ZXJvXG4gICAgdGhlbiB6ZXJvXG4gICAgZWxzZSBpZiBpID4gemVyb1xuICAgIHRoZW4gcm91bmRfZG93biBpIH50b19tdWx0aXBsZV9vZlxuICAgIGVsc2Ugcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgOztcblxuICBsZXQgcm91bmRfbmVhcmVzdCBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID1cbiAgICBsZXQgcmVtYWluZGVyID0gaSAlIG1vZHVsdXMgaW5cbiAgICBsZXQgbW9kdWx1c19taW51c19yZW1haW5kZXIgPSBtb2R1bHVzIC0gcmVtYWluZGVyIGluXG4gICAgaWYgbW9kdWx1c19taW51c19yZW1haW5kZXIgPD0gcmVtYWluZGVyXG4gICAgdGhlbiBpICsgbW9kdWx1c19taW51c19yZW1haW5kZXJcbiAgICBlbHNlIGkgLSByZW1haW5kZXJcbiAgOztcblxuICBsZXRbQGlubGluZSBhbHdheXNdIHJvdW5kID8oZGlyID0gYE5lYXJlc3QpIGkgfnRvX211bHRpcGxlX29mID1cbiAgICBtYXRjaCBkaXIgd2l0aFxuICAgIHwgYE5lYXJlc3QgLT4gcm91bmRfbmVhcmVzdCBpIH50b19tdWx0aXBsZV9vZlxuICAgIHwgYERvd24gLT4gcm91bmRfZG93biBpIH50b19tdWx0aXBsZV9vZlxuICAgIHwgYFVwIC0+IHJvdW5kX3VwIGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgWmVybyAtPiByb3VuZF90b3dhcmRzX3plcm8gaSB+dG9fbXVsdGlwbGVfb2ZcbiAgOztcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgaW50X3BvdyA9IGludF9wb3dcbiAgbGV0IGludDY0X3BvdyA9IGludDY0X3Bvd1xuICBsZXQgaW50NjNfcG93X29uX2ludDY0ID0gaW50NjNfcG93X29uX2ludDY0XG5cbiAgbW9kdWxlIFBvd19vdmVyZmxvd19ib3VuZHMgPSBQb3dfb3ZlcmZsb3dfYm91bmRzXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHQgPSAnYVxuXG5sZXQgc3RhZ2UgPSBGbi5pZFxubGV0IHVuc3RhZ2UgPSBGbi5pZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5pbmNsdWRlIENoYXIwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGNoYXIgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlID0gKGNvbXBhcmVfY2hhciA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9jaGFyXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9jaGFyIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9jaGFyIDogdCAtPiB0KVxuICBsZXQgdF9vZl9zZXhwID0gKGNoYXJfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfY2hhciA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBjaGFyX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHRvX3N0cmluZyB0ID0gU3RyaW5nLm1ha2UgMSB0XG5cbiAgbGV0IG9mX3N0cmluZyBzID1cbiAgICBtYXRjaCBTdHJpbmcubGVuZ3RoIHMgd2l0aFxuICAgIHwgMSAtPiBzLlswXVxuICAgIHwgXyAtPiBmYWlsd2l0aGYgXCJDaGFyLm9mX3N0cmluZzogJVNcIiBzICgpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBUXG5cbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuQ2hhclwiXG5lbmQpXG5cbmxldCBwcCBmbXQgYyA9IFN0ZGxpYi5Gb3JtYXQuZnByaW50ZiBmbXQgXCIlQ1wiIGNcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBhbGwgPSBBcnJheS5pbml0IDI1NiB+Zjp1bnNhZmVfb2ZfaW50IHw+IEFycmF5LnRvX2xpc3RcblxubGV0IGlzX2xvd2VyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3VwcGVyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3ByaW50ID0gZnVuY3Rpb25cbiAgfCAnICcgLi4gJ34nIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfd2hpdGVzcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXDAxMScgKCogdmVydGljYWwgdGFiICopIHwgJ1xcMDEyJyAoKiBmb3JtIGZlZWQgKikgfCAnXFxyJyB8ICcgJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfYWxwaGEgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG4oKiBXcml0aW5nIHRoZXNlIG91dCwgaW5zdGVhZCBvZiBjYWxsaW5nIFtpc19hbHBoYV0gYW5kIFtpc19kaWdpdF0sIHJlZHVjZXNcbiAgIHJ1bnRpbWUgYnkgYXBwcm94LiAzMCUgKilcbmxldCBpc19hbHBoYW51bSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgZ2V0X2RpZ2l0X3Vuc2FmZSB0ID0gdG9faW50IHQgLSB0b19pbnQgJzAnXG5cbmxldCBnZXRfZGlnaXRfZXhuIHQgPVxuICBpZiBpc19kaWdpdCB0XG4gIHRoZW4gZ2V0X2RpZ2l0X3Vuc2FmZSB0XG4gIGVsc2UgZmFpbHdpdGhmIFwiQ2hhci5nZXRfZGlnaXRfZXhuICVDOiBub3QgYSBkaWdpdFwiIHQgKClcbjs7XG5cbmxldCBnZXRfZGlnaXQgdCA9IGlmIGlzX2RpZ2l0IHQgdGhlbiBTb21lIChnZXRfZGlnaXRfdW5zYWZlIHQpIGVsc2UgTm9uZVxuXG5sZXQgaXNfaGV4X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19oZXhfZGlnaXRfbG93ZXIgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfaGV4X2RpZ2l0X3VwcGVyID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGdldF9oZXhfZGlnaXRfZXhuID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJzAnXG4gIHwgJ2EnIC4uICdmJyBhcyB0IC0+IHRvX2ludCB0IC0gdG9faW50ICdhJyArIDEwXG4gIHwgJ0EnIC4uICdGJyBhcyB0IC0+IHRvX2ludCB0IC0gdG9faW50ICdBJyArIDEwXG4gIHwgdCAtPlxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiQ2hhci5nZXRfaGV4X2RpZ2l0X2V4bjogbm90IGEgaGV4YWRlY2ltYWwgZGlnaXRcIlxuICAgICAgICAgWyBcImNoYXJcIiwgc2V4cF9vZl90IHQgXSlcbjs7XG5cbmxldCBnZXRfaGV4X2RpZ2l0IHQgPSBpZiBpc19oZXhfZGlnaXQgdCB0aGVuIFNvbWUgKGdldF9oZXhfZGlnaXRfZXhuIHQpIGVsc2UgTm9uZVxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBsZXQgKCA+PSApID0gKCA+PSApXG4gIGxldCAoIDw9ICkgPSAoIDw9IClcbiAgbGV0ICggPSApID0gKCA9IClcbiAgbGV0ICggPiApID0gKCA+IClcbiAgbGV0ICggPCApID0gKCA8IClcbiAgbGV0ICggPD4gKSA9ICggPD4gKVxuZW5kXG5cbm1vZHVsZSBDYXNlbGVzcyA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IGNoYXIgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCB0X29mX3NleHAgPSAoY2hhcl9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gICAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2NoYXIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBjaGFyX3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjb21wYXJlIGMxIGMyID0gY29tcGFyZSAobG93ZXJjYXNlIGMxKSAobG93ZXJjYXNlIGMyKVxuICAgIGxldCBjb21wYXJlX19sb2NhbCBjMSBjMiA9IGNvbXBhcmUgYzEgYzJcbiAgICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9IGhhc2hfZm9sZF9jaGFyIHN0YXRlIChsb3dlcmNhc2UgdClcbiAgICBsZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG5cbiAgbGV0IGVxdWFsX19sb2NhbCB0MSB0MiA9IGVxdWFsX2ludCAoY29tcGFyZV9fbG9jYWwgdDEgdDIpIDBcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydDAuSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuXG4oKiBDb25zdHJ1Y3QgYSBieXRlIHN0cmluZyBvZiBsZW5ndGggMjU2LCBtYXBwaW5nIGV2ZXJ5IGlucHV0IGNoYXJhY3RlciBjb2RlIHRvXG4gICBpdHMgY29ycmVzcG9uZGluZyBvdXRwdXQgY2hhcmFjdGVyLlxuXG4gICBCZW5jaG1hcmtzIGluZGljYXRlIHRoYXQgdGhpcyBpcyBmYXN0ZXIgdGhhbiB0aGUgbGFtYmRhIChpbmNsdWRpbmcgY29zdCBvZlxuICAgdGhpcyBmdW5jdGlvbiksIGV2ZW4gaWYgdGFyZ2V0L3JlcGxhY2VtZW50IGFyZSBqdXN0IDIgY2hhcmFjdGVycyBlYWNoLlxuXG4gICBSZXR1cm4gTm9uZSBpZiB0aGUgdHJhbnNsYXRpb24gbWFwIGlzIGVxdWl2YWxlbnQgdG8ganVzdCB0aGUgaWRlbnRpdHkuICopXG5sZXQgdHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGxldCB0cl9tYXAgPSBCeXRlcy5jcmVhdGUgMjU2IGluXG4gIGZvciBpID0gMCB0byAyNTUgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpIChDaGFyLm9mX2ludF9leG4gaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG1pbiAoU3RyaW5nLmxlbmd0aCB0YXJnZXQpIChTdHJpbmcubGVuZ3RoIHJlcGxhY2VtZW50KSAtIDEgZG9cbiAgICBsZXQgaW5kZXggPSBDaGFyLnRvX2ludCAoU3RyaW5nLnVuc2FmZV9nZXQgdGFyZ2V0IGkpIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0cl9tYXAgaW5kZXggKFN0cmluZy51bnNhZmVfZ2V0IHJlcGxhY2VtZW50IGkpXG4gIGRvbmU7XG4gIGxldCBsYXN0X3JlcGxhY2VtZW50ID0gU3RyaW5nLnVuc2FmZV9nZXQgcmVwbGFjZW1lbnQgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQgLSAxKSBpblxuICBmb3JcbiAgICBpID0gbWluIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIHRvIFN0cmluZy5sZW5ndGggdGFyZ2V0IC0gMVxuICBkb1xuICAgIGxldCBpbmRleCA9IENoYXIudG9faW50IChTdHJpbmcudW5zYWZlX2dldCB0YXJnZXQgaSkgaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpbmRleCBsYXN0X3JlcGxhY2VtZW50XG4gIGRvbmU7XG4gIGxldCByZWMgaGF2ZV9hbnlfZGlmZmVyZW50IHRyX21hcCBpID1cbiAgICBpZiBpID0gMjU2XG4gICAgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgQ2hhci4oIDw+ICkgKEJ5dGVzMC51bnNhZmVfZ2V0IHRyX21hcCBpKSAoQ2hhci5vZl9pbnRfZXhuIGkpXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIChpICsgMSlcbiAgaW5cbiAgKCogcXVpY2sgY2hlY2sgb24gdGhlIGZpcnN0IHRhcmdldCBjaGFyYWN0ZXIgd2hpY2ggd2lsbCA5OSUgYmUgdHJ1ZSAqKVxuICBsZXQgZmlyc3RfdGFyZ2V0ID0gdGFyZ2V0LlswXSBpblxuICBpZiBDaGFyLiggPD4gKSAoQnl0ZXMwLnVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBmaXJzdF90YXJnZXQpKSBmaXJzdF90YXJnZXRcbiAgICAgfHwgaGF2ZV9hbnlfZGlmZmVyZW50IHRyX21hcCAwXG4gIHRoZW4gU29tZSAoQnl0ZXMwLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dHJfbWFwKVxuICBlbHNlIE5vbmVcbjs7XG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFVjaGFyID0gVWNoYXIwXG5pbmNsdWRlIFN0cmluZzBcbmluY2x1ZGUgU3RyaW5nX2ludGZcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xubGV0IHN0YWdlID0gU3RhZ2VkLnN0YWdlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZyBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9zdHJpbmcgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9zdHJpbmdcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX3N0cmluZyBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoc3RyaW5nX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX3N0cmluZyA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBzdHJpbmdfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gY29tcGFyZVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbnR5cGUgZWx0ID0gY2hhclxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuXG4oKiBUaGlzIGlzIGNvcGllZC9hZGFwdGVkIGZyb20gJ2JsaXQubWwnLlxuICAgW3N1Yl0sIFtzdWJvXSBjb3VsZCBiZSBpbXBsZW1lbnRlZCB1c2luZyBbQmxpdC5NYWtlKEJ5dGVzKV0gcGx1cyB1bnNhZmUgY2FzdHMgdG8vZnJvbVxuICAgc3RyaW5nIGJ1dCB3ZXJlIGlubGluZWQgaGVyZSB0byBhdm9pZCB1c2luZyBbQnl0ZXMudW5zYWZlX29mX3N0cmluZ10gYXMgbXVjaCBhcyBwb3NzaWJsZS5cbiopXG5sZXQgdW5zYWZlX3N1YiBzcmMgfnBvcyB+bGVuID1cbiAgaWYgbGVuID0gMFxuICB0aGVuIFwiXCJcbiAgZWxzZSAoXG4gICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3Bvczpwb3MgfmRzdCB+ZHN0X3BvczowIH5sZW47XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3QpXG47O1xuXG5sZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICBpZiBwb3MgPSAwICYmIGxlbiA9IFN0cmluZy5sZW5ndGggc3JjXG4gIHRoZW4gc3JjXG4gIGVsc2UgKFxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCBzcmMpO1xuICAgIHVuc2FmZV9zdWIgc3JjIH5wb3Mgfmxlbilcbjs7XG5cbmxldCBzdWJvID8ocG9zID0gMCkgP2xlbiBzcmMgPVxuICBzdWJcbiAgICBzcmNcbiAgICB+cG9zXG4gICAgfmxlbjpcbiAgICAgIChtYXRjaCBsZW4gd2l0aFxuICAgICAgIHwgU29tZSBpIC0+IGlcbiAgICAgICB8IE5vbmUgLT4gbGVuZ3RoIHNyYyAtIHBvcylcbjs7XG5cbmxldCByZWMgY29udGFpbnNfdW5zYWZlIHQgfnBvcyB+ZW5kXyBjaGFyID1cbiAgcG9zIDwgZW5kX1xuICAmJiAoQ2hhci5lcXVhbCAodW5zYWZlX2dldCB0IHBvcykgY2hhciB8fCBjb250YWluc191bnNhZmUgdCB+cG9zOihwb3MgKyAxKSB+ZW5kXyBjaGFyKVxuOztcblxubGV0IGNvbnRhaW5zID8ocG9zID0gMCkgP2xlbiB0IGNoYXIgPVxuICBsZXQgdG90YWxfbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCB0IGluXG4gIGxldCBsZW4gPSBPcHRpb24udmFsdWUgbGVuIH5kZWZhdWx0Oih0b3RhbF9sZW5ndGggLSBwb3MpIGluXG4gIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIGNvbnRhaW5zX3Vuc2FmZSB0IH5wb3MgfmVuZF86KHBvcyArIGxlbikgY2hhclxuOztcblxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0W0BpbmxpbmVdIGluZGV4X2Zyb21faW50ZXJuYWwgc3RyaW5nIH5sZW4gfm5vdF9mb3VuZCB+Zm91bmQgY2hhciB+cG9zID1cbiAgbGV0IHJlYyBsb29wIH5wb3MgPVxuICAgIGlmIHBvcyA+PSBsZW5cbiAgICB0aGVuIG5vdF9mb3VuZCAoKVxuICAgIGVsc2UgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzdHJpbmcgcG9zKSBjaGFyXG4gICAgdGhlbiBmb3VuZCBwb3NcbiAgICBlbHNlIGxvb3AgfnBvczoocG9zICsgMSlcbiAgaW5cbiAgbG9vcCB+cG9zIFtAbm9udGFpbF1cbjs7XG5cbmxldCBpbmRleCB0IGNoYXIgPVxuICBpbmRleF9mcm9tX2ludGVybmFsXG4gICAgdFxuICAgIGNoYXJcbiAgICB+cG9zOjBcbiAgICB+bGVuOihsZW5ndGggdClcbiAgICB+Zm91bmQ6T3B0aW9uLnNvbWVcbiAgICB+bm90X2ZvdW5kOihmdW4gKCkgLT4gTm9uZSkgW0Bub250YWlsXVxuOztcblxubGV0IGluZGV4X2V4biB0IGNoYXIgPVxuICBpbmRleF9mcm9tX2ludGVybmFsXG4gICAgdFxuICAgIH5wb3M6MFxuICAgIH5sZW46KGxlbmd0aCB0KVxuICAgIH5mb3VuZDpGbi5pZFxuICAgIH5ub3RfZm91bmQ6KGZ1biAoKSAtPiByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcuaW5kZXhfZXhuOiBub3QgZm91bmRcIikpKVxuICAgIGNoYXIgW0Bub250YWlsXVxuOztcblxubGV0IGluZGV4X2Zyb20gdCBwb3MgY2hhciA9XG4gIGluZGV4X2Zyb21faW50ZXJuYWwgdCBjaGFyIH5wb3MgfmxlbjoobGVuZ3RoIHQpIH5mb3VuZDpPcHRpb24uc29tZSB+bm90X2ZvdW5kOihmdW4gKCkgLT5cbiAgICBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgaW5kZXhfZnJvbV9leG4gPVxuICBsZXQgbm90X2ZvdW5kICgpID0gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIikpIGluXG4gIGxldCBpbmRleF9mcm9tX2V4biB0IHBvcyBjaGFyID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBpZiBwb3MgPCAwIHx8IHBvcyA+IGxlblxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9leG5cIlxuICAgIGVsc2UgaW5kZXhfZnJvbV9pbnRlcm5hbCB0IH5wb3MgfmxlbiB+bm90X2ZvdW5kIH5mb3VuZDpGbi5pZCBjaGFyXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgaW5kZXhfZnJvbV9leG5cbjs7XG5cbmxldFtAaW5saW5lXSByaW5kZXhfZnJvbV9pbnRlcm5hbCBzdHJpbmcgY2hhciB+Zm91bmQgfm5vdF9mb3VuZCB+cG9zID1cbiAgbGV0IHJlYyBsb29wIH5wb3MgPVxuICAgIGlmIHBvcyA8IDBcbiAgICB0aGVuIG5vdF9mb3VuZCAoKVxuICAgIGVsc2UgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzdHJpbmcgcG9zKSBjaGFyXG4gICAgdGhlbiBmb3VuZCBwb3NcbiAgICBlbHNlIGxvb3AgfnBvczoocG9zIC0gMSlcbiAgaW5cbiAgbG9vcCB+cG9zIFtAbm9udGFpbF1cbjs7XG5cbmxldCByaW5kZXggdCBjaGFyID1cbiAgcmluZGV4X2Zyb21faW50ZXJuYWxcbiAgICB0XG4gICAgY2hhclxuICAgIH5wb3M6KGxlbmd0aCB0IC0gMSlcbiAgICB+Zm91bmQ6T3B0aW9uLnNvbWVcbiAgICB+bm90X2ZvdW5kOihmdW4gKCkgLT4gTm9uZSkgW0Bub250YWlsXVxuOztcblxubGV0IHJpbmRleF9leG4gdCBjaGFyID1cbiAgcmluZGV4X2Zyb21faW50ZXJuYWxcbiAgICB0XG4gICAgY2hhclxuICAgIH5wb3M6KGxlbmd0aCB0IC0gMSlcbiAgICB+Zm91bmQ6Rm4uaWRcbiAgICB+bm90X2ZvdW5kOihmdW4gKCkgLT4gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJpbmRleF9leG46IG5vdCBmb3VuZFwiKSkpXG4gIFtAbm9udGFpbF1cbjs7XG5cbmxldCByaW5kZXhfZnJvbSB0IHBvcyBjaGFyID1cbiAgcmluZGV4X2Zyb21faW50ZXJuYWwgdCBjaGFyIH5wb3MgfmZvdW5kOk9wdGlvbi5zb21lIH5ub3RfZm91bmQ6KGZ1biAoKSAtPiBOb25lKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbjs7XG5cbmxldCByaW5kZXhfZnJvbV9leG4gPVxuICBsZXQgbm90X2ZvdW5kICgpID0gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCIpKSBpblxuICBsZXQgcmluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIgPVxuICAgIGlmIHBvcyA8IC0xIHx8IHBvcyA+PSBsZW5ndGggdFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fZXhuXCJcbiAgICBlbHNlIHJpbmRleF9mcm9tX2ludGVybmFsIHQgfnBvcyB+bm90X2ZvdW5kIH5mb3VuZDpGbi5pZCBjaGFyXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcmluZGV4X2Zyb21fZXhuXG47O1xuXG5tb2R1bGUgU2VhcmNoX3BhdHRlcm4wID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBwYXR0ZXJuIDogc3RyaW5nXG4gICAgOyBjYXNlX3NlbnNpdGl2ZSA6IGJvb2xcbiAgICA7IGttcF9hcnJheSA6IGludCBhcnJheVxuICAgIH1cblxuICBsZXQgc2V4cF9vZl90IHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSA9IF8gfSA6IFNleHAudCA9XG4gICAgTGlzdFxuICAgICAgWyBMaXN0IFsgQXRvbSBcInBhdHRlcm5cIjsgc2V4cF9vZl9zdHJpbmcgcGF0dGVybiBdXG4gICAgICA7IExpc3QgWyBBdG9tIFwiY2FzZV9zZW5zaXRpdmVcIjsgc2V4cF9vZl9ib29sIGNhc2Vfc2Vuc2l0aXZlIF1cbiAgICAgIF1cbiAgOztcblxuICBsZXQgcGF0dGVybiB0ID0gdC5wYXR0ZXJuXG4gIGxldCBjYXNlX3NlbnNpdGl2ZSB0ID0gdC5jYXNlX3NlbnNpdGl2ZVxuXG4gICgqIEZpbmQgbWF4IG51bWJlciBvZiBtYXRjaGVkIGNoYXJhY3RlcnMgYXQgW25leHRfdGV4dF9jaGFyXSwgZ2l2ZW4gdGhlIGN1cnJlbnRcbiAgICAgW21hdGNoZWRfY2hhcnNdLiBUcnkgdG8gZXh0ZW5kIHRoZSBjdXJyZW50IG1hdGNoLCBpZiBjaGFycyBkb24ndCBtYXRjaCwgdHJ5IHRvIG1hdGNoXG4gICAgIGZld2VyIGNoYXJzLiBJZiBjaGFycyBtYXRjaCB0aGVuIGV4dGVuZCB0aGUgbWF0Y2guICopXG4gIGxldCBrbXBfaW50ZXJuYWxfbG9vcCB+bWF0Y2hlZF9jaGFycyB+bmV4dF90ZXh0X2NoYXIgfnBhdHRlcm4gfmttcF9hcnJheSB+Y2hhcl9lcXVhbCA9XG4gICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgbWF0Y2hlZF9jaGFycyBpblxuICAgIHdoaWxlXG4gICAgICAhbWF0Y2hlZF9jaGFycyA+IDBcbiAgICAgICYmIG5vdCAoY2hhcl9lcXVhbCBuZXh0X3RleHRfY2hhciAodW5zYWZlX2dldCBwYXR0ZXJuICFtYXRjaGVkX2NoYXJzKSlcbiAgICBkb1xuICAgICAgbWF0Y2hlZF9jaGFycyA6PSBBcnJheS51bnNhZmVfZ2V0IGttcF9hcnJheSAoIW1hdGNoZWRfY2hhcnMgLSAxKVxuICAgIGRvbmU7XG4gICAgaWYgY2hhcl9lcXVhbCBuZXh0X3RleHRfY2hhciAodW5zYWZlX2dldCBwYXR0ZXJuICFtYXRjaGVkX2NoYXJzKVxuICAgIHRoZW4gbWF0Y2hlZF9jaGFycyA6PSAhbWF0Y2hlZF9jaGFycyArIDE7XG4gICAgIW1hdGNoZWRfY2hhcnNcbiAgOztcblxuICBsZXQgZ2V0X2NoYXJfZXF1YWwgfmNhc2Vfc2Vuc2l0aXZlID1cbiAgICBtYXRjaCBjYXNlX3NlbnNpdGl2ZSB3aXRoXG4gICAgfCB0cnVlIC0+IENoYXIuZXF1YWxcbiAgICB8IGZhbHNlIC0+IENoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgOztcblxuICAoKiBDbGFzc2ljIEtNUCBwcmUtcHJvY2Vzc2luZyBvZiB0aGUgcGF0dGVybjogYnVpbGQgdGhlIGludCBhcnJheSwgd2hpY2gsIGZvciBlYWNoIGksXG4gICAgIGNvbnRhaW5zIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlc3Qgbm9uLXRyaXZpYWwgcHJlZml4IG9mIHMgd2hpY2ggaXMgZXF1YWwgdG8gYSBzdWZmaXhcbiAgICAgZW5kaW5nIGF0IHMuW2ldICopXG4gIGxldCBjcmVhdGUgcGF0dGVybiB+Y2FzZV9zZW5zaXRpdmUgPVxuICAgIGxldCBuID0gbGVuZ3RoIHBhdHRlcm4gaW5cbiAgICBsZXQga21wX2FycmF5ID0gQXJyYXkuY3JlYXRlIH5sZW46biAoLTEpIGluXG4gICAgaWYgbiA+IDBcbiAgICB0aGVuIChcbiAgICAgIGxldCBjaGFyX2VxdWFsID0gZ2V0X2NoYXJfZXF1YWwgfmNhc2Vfc2Vuc2l0aXZlIGluXG4gICAgICBBcnJheS51bnNhZmVfc2V0IGttcF9hcnJheSAwIDA7XG4gICAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiAwIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgICAgbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgICB+bWF0Y2hlZF9jaGFyczohbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgICAgfm5leHRfdGV4dF9jaGFyOih1bnNhZmVfZ2V0IHBhdHRlcm4gaSlcbiAgICAgICAgICAgICAgIH5wYXR0ZXJuXG4gICAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgICB+Y2hhcl9lcXVhbDtcbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCBrbXBfYXJyYXkgaSAhbWF0Y2hlZF9jaGFyc1xuICAgICAgZG9uZSk7XG4gICAgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5IH1cbiAgOztcblxuICAoKiBDbGFzc2ljIEtNUDogdXNlIHRoZSBwcmUtcHJvY2Vzc2VkIHBhdHRlcm4gdG8gb3B0aW1pemUgbG9vay1iZWhpbmRzIG9uIG5vbi1tYXRjaGVzLlxuICAgICBXZSByZXR1cm4gaW50IHRvIGF2b2lkIGFsbG9jYXRpb24gaW4gW2luZGV4X2V4bl0uIC0xIG1lYW5zIG5vIG1hdGNoLiAqKVxuICBsZXQgaW5kZXhfaW50ZXJuYWwgPyhwb3MgPSAwKSB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgfSB+aW5fOnRleHQgPVxuICAgIGlmIHBvcyA8IDAgfHwgcG9zID4gbGVuZ3RoIHRleHQgLSBsZW5ndGggcGF0dGVyblxuICAgIHRoZW4gLTFcbiAgICBlbHNlIChcbiAgICAgIGxldCBjaGFyX2VxdWFsID0gZ2V0X2NoYXJfZXF1YWwgfmNhc2Vfc2Vuc2l0aXZlIGluXG4gICAgICBsZXQgaiA9IHJlZiBwb3MgaW5cbiAgICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIDAgaW5cbiAgICAgIGxldCBrID0gbGVuZ3RoIHBhdHRlcm4gaW5cbiAgICAgIGxldCBuID0gbGVuZ3RoIHRleHQgaW5cbiAgICAgIHdoaWxlICFqIDwgbiAmJiAhbWF0Y2hlZF9jaGFycyA8IGsgZG9cbiAgICAgICAgbGV0IG5leHRfdGV4dF9jaGFyID0gdW5zYWZlX2dldCB0ZXh0ICFqIGluXG4gICAgICAgIG1hdGNoZWRfY2hhcnNcbiAgICAgICAgICA6PSBrbXBfaW50ZXJuYWxfbG9vcFxuICAgICAgICAgICAgICAgfm1hdGNoZWRfY2hhcnM6IW1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgICAgIH5uZXh0X3RleHRfY2hhclxuICAgICAgICAgICAgICAgfnBhdHRlcm5cbiAgICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICAgIH5jaGFyX2VxdWFsO1xuICAgICAgICBqIDo9ICFqICsgMVxuICAgICAgZG9uZTtcbiAgICAgIGlmICFtYXRjaGVkX2NoYXJzID0gayB0aGVuICFqIC0gayBlbHNlIC0xKVxuICA7O1xuXG4gIGxldCBtYXRjaGVzIHQgc3RyID0gaW5kZXhfaW50ZXJuYWwgdCB+aW5fOnN0ciA+PSAwXG5cbiAgbGV0IGluZGV4ID9wb3MgdCB+aW5fID1cbiAgICBsZXQgcCA9IGluZGV4X2ludGVybmFsID9wb3MgdCB+aW5fIGluXG4gICAgaWYgcCA8IDAgdGhlbiBOb25lIGVsc2UgU29tZSBwXG4gIDs7XG5cbiAgbGV0IGluZGV4X2V4biA/cG9zIHQgfmluXyA9XG4gICAgbGV0IHAgPSBpbmRleF9pbnRlcm5hbCA/cG9zIHQgfmluXyBpblxuICAgIGlmIHAgPj0gMFxuICAgIHRoZW4gcFxuICAgIGVsc2VcbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIlN1YnN0cmluZyBub3QgZm91bmRcIiBbIFwic3Vic3RyaW5nXCIsIHNleHBfb2Zfc3RyaW5nIHQucGF0dGVybiBdKVxuICA7O1xuXG4gIGxldCBpbmRleF9hbGwgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5IH0gfm1heV9vdmVybGFwIH5pbl86dGV4dCA9XG4gICAgaWYgbGVuZ3RoIHBhdHRlcm4gPSAwXG4gICAgdGhlbiBMaXN0LmluaXQgKDEgKyBsZW5ndGggdGV4dCkgfmY6Rm4uaWRcbiAgICBlbHNlIChcbiAgICAgIGxldCBjaGFyX2VxdWFsID0gZ2V0X2NoYXJfZXF1YWwgfmNhc2Vfc2Vuc2l0aXZlIGluXG4gICAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiAwIGluXG4gICAgICBsZXQgayA9IGxlbmd0aCBwYXR0ZXJuIGluXG4gICAgICBsZXQgbiA9IGxlbmd0aCB0ZXh0IGluXG4gICAgICBsZXQgZm91bmQgPSByZWYgW10gaW5cbiAgICAgIGZvciBqID0gMCB0byBuIGRvXG4gICAgICAgIGlmICFtYXRjaGVkX2NoYXJzID0ga1xuICAgICAgICB0aGVuIChcbiAgICAgICAgICBmb3VuZCA6PSAoaiAtIGspIDo6ICFmb3VuZDtcbiAgICAgICAgICAoKiB3ZSBqdXN0IGZvdW5kIGEgbWF0Y2ggaW4gdGhlIHByZXZpb3VzIGl0ZXJhdGlvbiAqKVxuICAgICAgICAgIG1hdGNoIG1heV9vdmVybGFwIHdpdGhcbiAgICAgICAgICB8IHRydWUgLT4gbWF0Y2hlZF9jaGFycyA6PSBBcnJheS51bnNhZmVfZ2V0IGttcF9hcnJheSAoayAtIDEpXG4gICAgICAgICAgfCBmYWxzZSAtPiBtYXRjaGVkX2NoYXJzIDo9IDApO1xuICAgICAgICBpZiBqIDwgblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbmV4dF90ZXh0X2NoYXIgPSB1bnNhZmVfZ2V0IHRleHQgaiBpblxuICAgICAgICAgIG1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgICAgIH5tYXRjaGVkX2NoYXJzOiFtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgICAgICAgIH5uZXh0X3RleHRfY2hhclxuICAgICAgICAgICAgICAgICB+cGF0dGVyblxuICAgICAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgICAgIH5jaGFyX2VxdWFsKVxuICAgICAgZG9uZTtcbiAgICAgIExpc3QucmV2ICFmb3VuZClcbiAgOztcblxuICBsZXQgcmVwbGFjZV9maXJzdCA/cG9zIHQgfmluXzpzIH53aXRoXyA9XG4gICAgbWF0Y2ggaW5kZXggP3BvcyB0IH5pbl86cyB3aXRoXG4gICAgfCBOb25lIC0+IHNcbiAgICB8IFNvbWUgaSAtPlxuICAgICAgbGV0IGxlbl9zID0gbGVuZ3RoIHMgaW5cbiAgICAgIGxldCBsZW5fdCA9IGxlbmd0aCB0LnBhdHRlcm4gaW5cbiAgICAgIGxldCBsZW5fd2l0aCA9IGxlbmd0aCB3aXRoXyBpblxuICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSAobGVuX3MgKyBsZW5fd2l0aCAtIGxlbl90KSBpblxuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzpzIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczowIH5sZW46aTtcbiAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6d2l0aF8gfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOmkgfmxlbjpsZW5fd2l0aDtcbiAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nXG4gICAgICAgIH5zcmM6c1xuICAgICAgICB+c3JjX3BvczooaSArIGxlbl90KVxuICAgICAgICB+ZHN0XG4gICAgICAgIH5kc3RfcG9zOihpICsgbGVuX3dpdGgpXG4gICAgICAgIH5sZW46KGxlbl9zIC0gaSAtIGxlbl90KTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0XG4gIDs7XG5cbiAgbGV0IHJlcGxhY2VfYWxsIHQgfmluXzpzIH53aXRoXyA9XG4gICAgbGV0IG1hdGNoZXMgPSBpbmRleF9hbGwgdCB+bWF5X292ZXJsYXA6ZmFsc2UgfmluXzpzIGluXG4gICAgbWF0Y2ggbWF0Y2hlcyB3aXRoXG4gICAgfCBbXSAtPiBzXG4gICAgfCBfIDo6IF8gLT5cbiAgICAgIGxldCBsZW5fcyA9IGxlbmd0aCBzIGluXG4gICAgICBsZXQgbGVuX3QgPSBsZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgICBsZXQgbGVuX3dpdGggPSBsZW5ndGggd2l0aF8gaW5cbiAgICAgIGxldCBudW1fbWF0Y2hlcyA9IExpc3QubGVuZ3RoIG1hdGNoZXMgaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbl9zICsgKChsZW5fd2l0aCAtIGxlbl90KSAqIG51bV9tYXRjaGVzKSkgaW5cbiAgICAgIGxldCBuZXh0X2RzdF9wb3MgPSByZWYgMCBpblxuICAgICAgbGV0IG5leHRfc3JjX3BvcyA9IHJlZiAwIGluXG4gICAgICBMaXN0Lml0ZXIgbWF0Y2hlcyB+ZjooZnVuIGkgLT5cbiAgICAgICAgbGV0IGxlbiA9IGkgLSAhbmV4dF9zcmNfcG9zIGluXG4gICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+c3JjX3BvczohbmV4dF9zcmNfcG9zIH5kc3QgfmRzdF9wb3M6IW5leHRfZHN0X3BvcyB+bGVuO1xuICAgICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICAgIH5zcmM6d2l0aF9cbiAgICAgICAgICB+c3JjX3BvczowXG4gICAgICAgICAgfmRzdFxuICAgICAgICAgIH5kc3RfcG9zOighbmV4dF9kc3RfcG9zICsgbGVuKVxuICAgICAgICAgIH5sZW46bGVuX3dpdGg7XG4gICAgICAgIG5leHRfZHN0X3BvcyA6PSAhbmV4dF9kc3RfcG9zICsgbGVuICsgbGVuX3dpdGg7XG4gICAgICAgIG5leHRfc3JjX3BvcyA6PSAhbmV4dF9zcmNfcG9zICsgbGVuICsgbGVuX3QpO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgfnNyYzpzXG4gICAgICAgIH5zcmNfcG9zOiFuZXh0X3NyY19wb3NcbiAgICAgICAgfmRzdFxuICAgICAgICB+ZHN0X3BvczohbmV4dF9kc3RfcG9zXG4gICAgICAgIH5sZW46KGxlbl9zIC0gIW5leHRfc3JjX3Bvcyk7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdFxuICA7O1xuXG4gIGxldCBzcGxpdF9vbiB0IHMgPVxuICAgIGxldCBwYXR0ZXJuX2xlbiA9IFN0cmluZy5sZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgbGV0IG1hdGNoZXMgPSBpbmRleF9hbGwgdCB+bWF5X292ZXJsYXA6ZmFsc2UgfmluXzpzIGluXG4gICAgTGlzdC5tYXAyX2V4blxuICAgICAgKC1wYXR0ZXJuX2xlbiA6OiBtYXRjaGVzKVxuICAgICAgKG1hdGNoZXMgQCBbIFN0cmluZy5sZW5ndGggcyBdKVxuICAgICAgfmY6KGZ1biBpIGogLT4gc3ViIHMgfnBvczooaSArIHBhdHRlcm5fbGVuKSB+bGVuOihqIC0gaSAtIHBhdHRlcm5fbGVuKSlcbiAgOztcblxuICBtb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICAgIHR5cGUgcHVibGljID0gdFxuXG4gICAgdHlwZSBub25yZWMgdCA9IHQgPVxuICAgICAgeyBwYXR0ZXJuIDogc3RyaW5nXG4gICAgICA7IGNhc2Vfc2Vuc2l0aXZlIDogYm9vbFxuICAgICAgOyBrbXBfYXJyYXkgOiBpbnQgYXJyYXlcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgZXF1YWwgfmxvY2FsaXplLCBzZXhwX29mXVxuXG4gICAgbGV0IGVxdWFsX19sb2NhbCA9XG4gICAgICAoZnVuIGFfXzAwM18gYl9fMDA0XyAtPlxuICAgICAgICAgaWYgU3RkbGliLiggPT0gKSBhX18wMDNfIGJfXzAwNF9cbiAgICAgICAgIHRoZW4gdHJ1ZVxuICAgICAgICAgZWxzZVxuICAgICAgICAgICBTdGRsaWIuKCAmJiApXG4gICAgICAgICAgICAgKGVxdWFsX3N0cmluZ19fbG9jYWwgYV9fMDAzXy5wYXR0ZXJuIGJfXzAwNF8ucGF0dGVybilcbiAgICAgICAgICAgICAoU3RkbGliLiggJiYgKVxuICAgICAgICAgICAgICAgIChlcXVhbF9ib29sX19sb2NhbCBhX18wMDNfLmNhc2Vfc2Vuc2l0aXZlIGJfXzAwNF8uY2FzZV9zZW5zaXRpdmUpXG4gICAgICAgICAgICAgICAgKGVxdWFsX2FycmF5X19sb2NhbCBlcXVhbF9pbnRfX2xvY2FsIGFfXzAwM18ua21wX2FycmF5IGJfXzAwNF8ua21wX2FycmF5KSlcbiAgICAgICAgOiB0IC0+IHQgLT4gYm9vbClcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsID0gKGZ1biBhIGIgLT4gZXF1YWxfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBib29sKVxuXG4gICAgbGV0IHNleHBfb2ZfdCA9XG4gICAgICAoZnVuIHsgcGF0dGVybiA9IHBhdHRlcm5fXzAwOF9cbiAgICAgICAgICAgOyBjYXNlX3NlbnNpdGl2ZSA9IGNhc2Vfc2Vuc2l0aXZlX18wMTBfXG4gICAgICAgICAgIDsga21wX2FycmF5ID0ga21wX2FycmF5X18wMTJfXG4gICAgICAgICAgIH0gLT5cbiAgICAgICAgIGxldCBibmRzX18wMDdfID0gKFtdIDogXyBTdGRsaWIuTGlzdC50KSBpblxuICAgICAgICAgbGV0IGJuZHNfXzAwN18gPVxuICAgICAgICAgICBsZXQgYXJnX18wMTNfID0gc2V4cF9vZl9hcnJheSBzZXhwX29mX2ludCBrbXBfYXJyYXlfXzAxMl8gaW5cbiAgICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImttcF9hcnJheVwiOyBhcmdfXzAxM18gXSA6OiBibmRzX18wMDdfXG4gICAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IGJuZHNfXzAwN18gPVxuICAgICAgICAgICBsZXQgYXJnX18wMTFfID0gc2V4cF9vZl9ib29sIGNhc2Vfc2Vuc2l0aXZlX18wMTBfIGluXG4gICAgICAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJjYXNlX3NlbnNpdGl2ZVwiOyBhcmdfXzAxMV8gXVxuICAgICAgICAgICAgOjogYm5kc19fMDA3X1xuICAgICAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBibmRzX18wMDdfID1cbiAgICAgICAgICAgbGV0IGFyZ19fMDA5XyA9IHNleHBfb2Zfc3RyaW5nIHBhdHRlcm5fXzAwOF8gaW5cbiAgICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBhdHRlcm5cIjsgYXJnX18wMDlfIF0gOjogYm5kc19fMDA3X1xuICAgICAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgICAgaW5cbiAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDdfXG4gICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgcmVwcmVzZW50YXRpb24gPSBGbi5pZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgU2VhcmNoX3BhdHRlcm5faGVscGVyID0gc3RydWN0XG4gIG1vZHVsZSBTZWFyY2hfcGF0dGVybiA9IFNlYXJjaF9wYXR0ZXJuMFxuZW5kXG5cbm9wZW4gU2VhcmNoX3BhdHRlcm5faGVscGVyXG5cbmxldCBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZSA/cG9zIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5pbmRleCA/cG9zIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9pbmRleF9leG5fZ2VuIH5jYXNlX3NlbnNpdGl2ZSA/cG9zIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5pbmRleF9leG4gP3BvcyAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfaW5kZXhfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmUgdCB+bWF5X292ZXJsYXAgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5pbmRleF9hbGxcbiAgICAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKVxuICAgIH5tYXlfb3ZlcmxhcFxuICAgIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiB+Y2FzZV9zZW5zaXRpdmUgP3BvcyB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4ucmVwbGFjZV9maXJzdCA/cG9zIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9yZXBsYWNlX2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5yZXBsYWNlX2FsbCAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBpc19zdWJzdHJpbmdfZ2VuIH5jYXNlX3NlbnNpdGl2ZSB0IH5zdWJzdHJpbmcgPVxuICBPcHRpb24uaXNfc29tZSAoc3Vic3RyX2luZGV4X2dlbiB0IH5wYXR0ZXJuOnN1YnN0cmluZyB+Y2FzZV9zZW5zaXRpdmUpXG47O1xuXG5sZXQgc3Vic3RyX2luZGV4ID0gc3Vic3RyX2luZGV4X2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9pbmRleF9leG4gPSBzdWJzdHJfaW5kZXhfZXhuX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9pbmRleF9hbGwgPSBzdWJzdHJfaW5kZXhfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9yZXBsYWNlX2ZpcnN0ID0gc3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX3JlcGxhY2VfYWxsID0gc3Vic3RyX3JlcGxhY2VfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IGlzX3N1YnN0cmluZyA9IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcblxubGV0IGlzX3N1YnN0cmluZ19hdF9nZW4gPVxuICBsZXQgcmVjIGxvb3AgfnN0ciB+c3RyX3BvcyB+c3ViIH5zdWJfcG9zIH5zdWJfbGVuIH5jaGFyX2VxdWFsID1cbiAgICBpZiBzdWJfcG9zID0gc3ViX2xlblxuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgY2hhcl9lcXVhbCAodW5zYWZlX2dldCBzdHIgc3RyX3BvcykgKHVuc2FmZV9nZXQgc3ViIHN1Yl9wb3MpXG4gICAgdGhlbiBsb29wIH5zdHIgfnN0cl9wb3M6KHN0cl9wb3MgKyAxKSB+c3ViIH5zdWJfcG9zOihzdWJfcG9zICsgMSkgfnN1Yl9sZW4gfmNoYXJfZXF1YWxcbiAgICBlbHNlIGZhbHNlXG4gIGluXG4gIGZ1biBzdHIgfnBvczpzdHJfcG9zIH5zdWJzdHJpbmc6c3ViIH5jaGFyX2VxdWFsIC0+XG4gICAgbGV0IHN0cl9sZW4gPSBsZW5ndGggc3RyIGluXG4gICAgbGV0IHN1Yl9sZW4gPSBsZW5ndGggc3ViIGluXG4gICAgaWYgc3RyX3BvcyA8IDAgfHwgc3RyX3BvcyA+IHN0cl9sZW5cbiAgICB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJTdHJpbmcuaXNfc3Vic3RyaW5nX2F0OiBpbnZhbGlkIGluZGV4ICVkIGZvciBzdHJpbmcgb2YgbGVuZ3RoICVkXCJcbiAgICAgICAgc3RyX3Bvc1xuICAgICAgICBzdHJfbGVuXG4gICAgICAgICgpO1xuICAgIHN0cl9wb3MgKyBzdWJfbGVuIDw9IHN0cl9sZW5cbiAgICAmJiBsb29wIH5zdHIgfnN0cl9wb3MgfnN1YiB+c3ViX3BvczowIH5zdWJfbGVuIH5jaGFyX2VxdWFsXG47O1xuXG5sZXQgaXNfc3VmZml4X2dlbiBzdHJpbmcgfnN1ZmZpeCB+Y2hhcl9lcXVhbCA9XG4gIGxldCBzdHJpbmdfbGVuID0gbGVuZ3RoIHN0cmluZyBpblxuICBsZXQgc3VmZml4X2xlbiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgc3RyaW5nX2xlbiA+PSBzdWZmaXhfbGVuXG4gICYmIGlzX3N1YnN0cmluZ19hdF9nZW5cbiAgICAgICBzdHJpbmdcbiAgICAgICB+cG9zOihzdHJpbmdfbGVuIC0gc3VmZml4X2xlbilcbiAgICAgICB+c3Vic3RyaW5nOnN1ZmZpeFxuICAgICAgIH5jaGFyX2VxdWFsXG47O1xuXG5sZXQgaXNfcHJlZml4X2dlbiBzdHJpbmcgfnByZWZpeCB+Y2hhcl9lcXVhbCA9XG4gIGxldCBzdHJpbmdfbGVuID0gbGVuZ3RoIHN0cmluZyBpblxuICBsZXQgcHJlZml4X2xlbiA9IGxlbmd0aCBwcmVmaXggaW5cbiAgc3RyaW5nX2xlbiA+PSBwcmVmaXhfbGVuXG4gICYmIGlzX3N1YnN0cmluZ19hdF9nZW4gc3RyaW5nIH5wb3M6MCB+c3Vic3RyaW5nOnByZWZpeCB+Y2hhcl9lcXVhbFxuOztcblxubW9kdWxlIENhc2VsZXNzID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID0gc3RyaW5nIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgdF9vZl9zZXhwID0gKHN0cmluZ19vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gICAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX3N0cmluZyA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHN0cmluZ19zZXhwX2dyYW1tYXJcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY2hhcl9jb21wYXJlX2Nhc2VsZXNzIGMxIGMyID0gQ2hhci5jb21wYXJlIChDaGFyLmxvd2VyY2FzZSBjMSkgKENoYXIubG93ZXJjYXNlIGMyKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2xvb3AgfnBvcyB+c3RyaW5nMSB+bGVuMSB+c3RyaW5nMiB+bGVuMiA9XG4gICAgICBpZiBwb3MgPSBsZW4xXG4gICAgICB0aGVuIGlmIHBvcyA9IGxlbjIgdGhlbiAwIGVsc2UgLTFcbiAgICAgIGVsc2UgaWYgcG9zID0gbGVuMlxuICAgICAgdGhlbiAxXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGMgPSBjaGFyX2NvbXBhcmVfY2FzZWxlc3MgKHVuc2FmZV9nZXQgc3RyaW5nMSBwb3MpICh1bnNhZmVfZ2V0IHN0cmluZzIgcG9zKSBpblxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAwIC0+IGNvbXBhcmVfbG9vcCB+cG9zOihwb3MgKyAxKSB+c3RyaW5nMSB+bGVuMSB+c3RyaW5nMiB+bGVuMlxuICAgICAgICB8IF8gLT4gYylcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmVfX2xvY2FsIHN0cmluZzEgc3RyaW5nMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHN0cmluZzEgc3RyaW5nMlxuICAgICAgdGhlbiAwXG4gICAgICBlbHNlXG4gICAgICAgIGNvbXBhcmVfbG9vcFxuICAgICAgICAgIH5wb3M6MFxuICAgICAgICAgIH5zdHJpbmcxXG4gICAgICAgICAgfmxlbjE6KFN0cmluZy5sZW5ndGggc3RyaW5nMSlcbiAgICAgICAgICB+c3RyaW5nMlxuICAgICAgICAgIH5sZW4yOihTdHJpbmcubGVuZ3RoIHN0cmluZzIpXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIGEgYiA9IGNvbXBhcmVfX2xvY2FsIGEgYlxuXG4gICAgbGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPVxuICAgICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgICBsZXQgc3RhdGUgPSByZWYgKGhhc2hfZm9sZF9pbnQgc3RhdGUgbGVuKSBpblxuICAgICAgZm9yIHBvcyA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBzdGF0ZSA6PSBoYXNoX2ZvbGRfY2hhciAhc3RhdGUgKENoYXIubG93ZXJjYXNlICh1bnNhZmVfZ2V0IHQgcG9zKSlcbiAgICAgIGRvbmU7XG4gICAgICAhc3RhdGVcbiAgICA7O1xuXG4gICAgbGV0IGhhc2ggdCA9IEhhc2gucnVuIGhhc2hfZm9sZF90IHRcbiAgICBsZXQgaXNfc3VmZml4IHMgfnN1ZmZpeCA9IGlzX3N1ZmZpeF9nZW4gcyB+c3VmZml4IH5jaGFyX2VxdWFsOkNoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgICBsZXQgaXNfcHJlZml4IHMgfnByZWZpeCA9IGlzX3ByZWZpeF9nZW4gcyB+cHJlZml4IH5jaGFyX2VxdWFsOkNoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgICBsZXQgc3Vic3RyX2luZGV4ID0gc3Vic3RyX2luZGV4X2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX2luZGV4X2V4biA9IHN1YnN0cl9pbmRleF9leG5fZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfaW5kZXhfYWxsID0gc3Vic3RyX2luZGV4X2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9yZXBsYWNlX2ZpcnN0ID0gc3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfcmVwbGFjZV9hbGwgPSBzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBpc19zdWJzdHJpbmcgPSBpc19zdWJzdHJpbmdfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBpc19zdWJzdHJpbmdfYXQgPSBpc19zdWJzdHJpbmdfYXRfZ2VuIH5jaGFyX2VxdWFsOkNoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuZW5kXG5cbmxldCBvZl9zdHJpbmcgPSBGbi5pZFxubGV0IHRvX3N0cmluZyA9IEZuLmlkXG5cbmxldCBpbml0IG4gfmYgPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIlN0cmluZy5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHQgPSBCeXRlcy5jcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICBCeXRlcy5zZXQgdCBpIChmIGkpXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dFxuOztcblxubGV0IHRvX2xpc3QgcyA9XG4gIGxldCByZWMgbG9vcCBhY2MgaSA9IGlmIGkgPCAwIHRoZW4gYWNjIGVsc2UgbG9vcCAocy5baV0gOjogYWNjKSAoaSAtIDEpIGluXG4gIGxvb3AgW10gKGxlbmd0aCBzIC0gMSlcbjs7XG5cbmxldCB0b19saXN0X3JldiBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBhY2MgaSA9IGlmIGkgPSBsZW4gdGhlbiBhY2MgZWxzZSBsb29wIChzLltpXSA6OiBhY2MpIChpICsgMSkgaW5cbiAgbG9vcCBbXSAwXG47O1xuXG5sZXQgcmV2IHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlcyBpICh1bnNhZmVfZ2V0IHQgKGxlbiAtIDEgLSBpKSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpyZXNcbjs7XG5cbigqKiBFZmZpY2llbnQgc3RyaW5nIHNwbGl0dGluZyAqKVxuXG5sZXQgbHNwbGl0Ml9leG4gPVxuICBsZXQgbm90X2ZvdW5kICgpID0gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmxzcGxpdDJfZXhuOiBub3QgZm91bmRcIikpIGluXG4gIGxldCBsc3BsaXQyX2V4biBsaW5lIH5vbjpkZWxpbSA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCBsaW5lIGluXG4gICAgbGV0IHBvcyA9IGluZGV4X2Zyb21faW50ZXJuYWwgbGluZSB+cG9zOjAgfmxlbiB+bm90X2ZvdW5kIH5mb3VuZDpGbi5pZCBkZWxpbSBpblxuICAgIHN1YiBsaW5lIH5wb3M6MCB+bGVuOnBvcywgc3ViIGxpbmUgfnBvczoocG9zICsgMSkgfmxlbjoobGVuIC0gcG9zIC0gMSlcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBsc3BsaXQyX2V4blxuOztcblxubGV0IHJzcGxpdDJfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCAoKSA9IHJhaXNlIChOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5yc3BsaXQyX2V4bjogbm90IGZvdW5kXCIpKSBpblxuICBsZXQgcnNwbGl0Ml9leG4gbGluZSB+b246ZGVsaW0gPVxuICAgIGxldCBsZW4gPSBsZW5ndGggbGluZSBpblxuICAgIGxldCBwb3MgPSByaW5kZXhfZnJvbV9pbnRlcm5hbCBsaW5lIH5wb3M6KGxlbiAtIDEpIH5ub3RfZm91bmQgfmZvdW5kOkZuLmlkIGRlbGltIGluXG4gICAgc3ViIGxpbmUgfnBvczowIH5sZW46cG9zLCBzdWIgbGluZSB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW4gLSBwb3MgLSAxKVxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIHJzcGxpdDJfZXhuXG47O1xuXG5sZXQgbHNwbGl0MiBsaW5lIH5vbiA9XG4gIHRyeSBTb21lIChsc3BsaXQyX2V4biBsaW5lIH5vbikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBTdGRsaWIuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmxldCByc3BsaXQyIGxpbmUgfm9uID1cbiAgdHJ5IFNvbWUgKHJzcGxpdDJfZXhuIGxpbmUgfm9uKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJlYyBjaGFyX2xpc3RfbWVtIGwgKGMgOiBjaGFyKSA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IGZhbHNlXG4gIHwgaGQgOjogdGwgLT4gQ2hhci5lcXVhbCBoZCBjIHx8IGNoYXJfbGlzdF9tZW0gdGwgY1xuOztcblxubGV0IHNwbGl0X2dlbiBzdHIgfm9uID1cbiAgbGV0IGlzX2RlbGltID1cbiAgICBtYXRjaCBvbiB3aXRoXG4gICAgfCBgY2hhciBjJyAtPiBmdW4gYyAtPiBDaGFyLmVxdWFsIGMgYydcbiAgICB8IGBjaGFyX2xpc3QgbCAtPiBmdW4gYyAtPiBjaGFyX2xpc3RfbWVtIGwgY1xuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIHN0ciBpblxuICBsZXQgcmVjIGxvb3AgYWNjIGxhc3RfcG9zIHBvcyA9XG4gICAgaWYgcG9zID0gLTFcbiAgICB0aGVuIHN1YiBzdHIgfnBvczowIH5sZW46bGFzdF9wb3MgOjogYWNjXG4gICAgZWxzZSBpZiBpc19kZWxpbSBzdHIuW3Bvc11cbiAgICB0aGVuIChcbiAgICAgIGxldCBwb3MxID0gcG9zICsgMSBpblxuICAgICAgbGV0IHN1Yl9zdHIgPSBzdWIgc3RyIH5wb3M6cG9zMSB+bGVuOihsYXN0X3BvcyAtIHBvczEpIGluXG4gICAgICBsb29wIChzdWJfc3RyIDo6IGFjYykgcG9zIChwb3MgLSAxKSlcbiAgICBlbHNlIGxvb3AgYWNjIGxhc3RfcG9zIChwb3MgLSAxKVxuICBpblxuICBsb29wIFtdIGxlbiAobGVuIC0gMSlcbjs7XG5cbmxldCBzcGxpdCBzdHIgfm9uID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyIG9uKVxubGV0IHNwbGl0X29uX2NoYXJzIHN0ciB+b246Y2hhcnMgPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXJfbGlzdCBjaGFycylcbmxldCBpc19zdWZmaXggcyB+c3VmZml4ID0gaXNfc3VmZml4X2dlbiBzIH5zdWZmaXggfmNoYXJfZXF1YWw6Q2hhci5lcXVhbFxubGV0IGlzX3ByZWZpeCBzIH5wcmVmaXggPSBpc19wcmVmaXhfZ2VuIHMgfnByZWZpeCB+Y2hhcl9lcXVhbDpDaGFyLmVxdWFsXG5cbmxldCBpc19zdWJzdHJpbmdfYXQgcyB+cG9zIH5zdWJzdHJpbmcgPVxuICBpc19zdWJzdHJpbmdfYXRfZ2VuIHMgfnBvcyB+c3Vic3RyaW5nIH5jaGFyX2VxdWFsOkNoYXIuZXF1YWxcbjs7XG5cbmxldCB3cmFwX3N1Yl9uIHQgbiB+bmFtZSB+cG9zIH5sZW4gfm9uX2Vycm9yID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyAobmFtZSBeIFwiIGV4cGVjdGluZyBub25uZWdhdGl2ZSBhcmd1bWVudFwiKVxuICBlbHNlIChcbiAgICB0cnkgc3ViIHQgfnBvcyB+bGVuIHdpdGhcbiAgICB8IF8gLT4gb25fZXJyb3IpXG47O1xuXG5sZXQgZHJvcF9wcmVmaXggdCBuID1cbiAgd3JhcF9zdWJfbiB+bmFtZTpcImRyb3BfcHJlZml4XCIgdCBuIH5wb3M6biB+bGVuOihsZW5ndGggdCAtIG4pIH5vbl9lcnJvcjpcIlwiXG47O1xuXG5sZXQgZHJvcF9zdWZmaXggdCBuID1cbiAgd3JhcF9zdWJfbiB+bmFtZTpcImRyb3Bfc3VmZml4XCIgdCBuIH5wb3M6MCB+bGVuOihsZW5ndGggdCAtIG4pIH5vbl9lcnJvcjpcIlwiXG47O1xuXG5sZXQgcHJlZml4IHQgbiA9IHdyYXBfc3ViX24gfm5hbWU6XCJwcmVmaXhcIiB0IG4gfnBvczowIH5sZW46biB+b25fZXJyb3I6dFxubGV0IHN1ZmZpeCB0IG4gPSB3cmFwX3N1Yl9uIH5uYW1lOlwic3VmZml4XCIgdCBuIH5wb3M6KGxlbmd0aCB0IC0gbikgfmxlbjpuIH5vbl9lcnJvcjp0XG5cbmxldCBsZmluZGkgPyhwb3MgPSAwKSB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVjIGxvb3AgaSA9IGlmIGkgPSBuIHRoZW4gTm9uZSBlbHNlIGlmIGYgaSB0LltpXSB0aGVuIFNvbWUgaSBlbHNlIGxvb3AgKGkgKyAxKSBpblxuICBsb29wIHBvcyBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbWF0Y2ggbGZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gZiBjKSB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBpIC0+IFNvbWUgdC5baV1cbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG5cbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGYgdC5baV0gd2l0aFxuICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgfCBTb21lIF8gYXMgcmVzIC0+IHJlcylcbiAgaW5cbiAgbG9vcCAwIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZmluZGkgP3BvcyB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgPSBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZSBpZiBmIGkgdC5baV0gdGhlbiBTb21lIGkgZWxzZSBsb29wIChpIC0gMSkgaW5cbiAgbGV0IHBvcyA9XG4gICAgbWF0Y2ggcG9zIHdpdGhcbiAgICB8IFNvbWUgcG9zIC0+IHBvc1xuICAgIHwgTm9uZSAtPiBsZW5ndGggdCAtIDFcbiAgaW5cbiAgbG9vcCBwb3MgW0Bub250YWlsXVxuOztcblxubGV0IGxhc3Rfbm9uX2Ryb3AgfmRyb3AgdCA9IHJmaW5kaSB0IH5mOihmdW4gXyBjIC0+IG5vdCAoZHJvcCBjKSkgW0Bub250YWlsXVxuXG5sZXQgcnN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIG1hdGNoIGxhc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gIHwgTm9uZSAtPiBcIlwiXG4gIHwgU29tZSBpIC0+IGlmIGkgPSBsZW5ndGggdCAtIDEgdGhlbiB0IGVsc2UgcHJlZml4IHQgKGkgKyAxKVxuOztcblxubGV0IGZpcnN0X25vbl9kcm9wIH5kcm9wIHQgPSBsZmluZGkgdCB+ZjooZnVuIF8gYyAtPiBub3QgKGRyb3AgYykpIFtAbm9udGFpbF1cblxubGV0IGxzdHJpcCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgPVxuICBtYXRjaCBmaXJzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgfCBOb25lIC0+IFwiXCJcbiAgfCBTb21lIDAgLT4gdFxuICB8IFNvbWUgbiAtPiBkcm9wX3ByZWZpeCB0IG5cbjs7XG5cbigqIFtzdHJpcCB0XSBjb3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBbbHN0cmlwIChyc3RyaXAgdCldLiAgVGhlIGltcGxlbWVudGF0aW9uXG4gICBiZWxvdyBzYXZlcyAoYXQgbGVhc3QpIGEgZmFjdG9yIG9mIHR3byBhbGxvY2F0aW9uLCBieSBvbmx5IGFsbG9jYXRpbmcgdGhlXG4gICBmaW5hbCByZXN1bHQuICBUaGlzIGFsc28gc2F2ZXMgc29tZSBhbW91bnQgb2YgdGltZS4gKilcbmxldCBzdHJpcCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMCB8fCBub3QgKGRyb3AgdC5bMF0gfHwgZHJvcCB0LltsZW5ndGggLSAxXSlcbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgfCBTb21lIGZpcnN0IC0+XG4gICAgICAobWF0Y2ggbGFzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgfCBTb21lIGxhc3QgLT4gc3ViIHQgfnBvczpmaXJzdCB+bGVuOihsYXN0IC0gZmlyc3QgKyAxKSkpXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IGwgPSBsZW5ndGggdCBpblxuICBsZXQgdCcgPSBCeXRlcy5jcmVhdGUgbCBpblxuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHQnIGkgKGYgaSB0LltpXSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0J1xuOztcblxuKCogcmVwZWF0ZWQgY29kZSB0byBhdm9pZCByZXF1aXJpbmcgYW4gZXh0cmEgYWxsb2NhdGlvbiBmb3IgYSBjbG9zdXJlIG9uIGVhY2ggY2FsbC4gKilcbmxldCBtYXAgdCB+ZiA9XG4gIGxldCBsID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHQnID0gQnl0ZXMuY3JlYXRlIGwgaW5cbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0JyBpIChmIHQuW2ldKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnQnXG47O1xuXG5sZXQgdG9fYXJyYXkgcyA9IEFycmF5LmluaXQgKGxlbmd0aCBzKSB+ZjooZnVuIGkgLT4gcy5baV0pXG5cbmxldCBleGlzdHMgPVxuICBsZXQgcmVjIGxvb3AgcyBpIH5sZW4gfmYgPSBpIDwgbGVuICYmIChmIHMuW2ldIHx8IGxvb3AgcyAoaSArIDEpIH5sZW4gfmYpIGluXG4gIGZ1biBzIH5mIC0+IGxvb3AgcyAwIH5sZW46KGxlbmd0aCBzKSB+ZlxuOztcblxubGV0IGZvcl9hbGwgPVxuICBsZXQgcmVjIGxvb3AgcyBpIH5sZW4gfmYgPSBpID0gbGVuIHx8IChmIHMuW2ldICYmIGxvb3AgcyAoaSArIDEpIH5sZW4gfmYpIGluXG4gIGZ1biBzIH5mIC0+IGxvb3AgcyAwIH5sZW46KGxlbmd0aCBzKSB+ZlxuOztcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGxvb3AgdCBpIGFjIH5mIH5sZW4gPVxuICAgIGlmIGkgPSBsZW4gdGhlbiBhYyBlbHNlIGxvb3AgdCAoaSArIDEpIChmIGFjIHQuW2ldKSB+ZiB+bGVuXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCAwIGluaXQgfmYgfmxlbjoobGVuZ3RoIHQpXG47O1xuXG5sZXQgZm9sZGkgPVxuICBsZXQgcmVjIGxvb3AgdCBpIGFjIH5mIH5sZW4gPVxuICAgIGlmIGkgPSBsZW4gdGhlbiBhYyBlbHNlIGxvb3AgdCAoaSArIDEpIChmIGkgYWMgdC5baV0pIH5mIH5sZW5cbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IDAgaW5pdCB+ZiB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCBpdGVyaSB0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmVcbjs7XG5cbmxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0XG5sZXQgbWF4X2VsdCB0ID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdFxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdCB+ZmluaXNoXG5sZXQgZmluZF9tYXBpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5maW5kX21hcGkgfml0ZXJpIHQgfmZcbmxldCBmaW5kaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZmluZGkgfml0ZXJpIHQgfmZcbmxldCBjb3VudGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmNvdW50aSB+Zm9sZGkgdCB+ZlxubGV0IGZvcl9hbGxpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5mb3JfYWxsaSB+aXRlcmkgdCB+ZlxubGV0IGV4aXN0c2kgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmV4aXN0c2kgfml0ZXJpIHQgfmZcblxubGV0IG1lbSA9XG4gIGxldCByZWMgbG9vcCB0IGMgfnBvczppIH5sZW4gPVxuICAgIGkgPCBsZW4gJiYgKENoYXIuZXF1YWwgYyAodW5zYWZlX2dldCB0IGkpIHx8IGxvb3AgdCBjIH5wb3M6KGkgKyAxKSB+bGVuKVxuICBpblxuICBmdW4gdCBjIC0+IGxvb3AgdCBjIH5wb3M6MCB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCB0ciB+dGFyZ2V0IH5yZXBsYWNlbWVudCBzID1cbiAgaWYgQ2hhci5lcXVhbCB0YXJnZXQgcmVwbGFjZW1lbnRcbiAgdGhlbiBzXG4gIGVsc2UgaWYgbWVtIHMgdGFyZ2V0XG4gIHRoZW4gbWFwIHMgfmY6KGZ1biBjIC0+IGlmIENoYXIuZXF1YWwgYyB0YXJnZXQgdGhlbiByZXBsYWNlbWVudCBlbHNlIGMpXG4gIGVsc2Ugc1xuOztcblxubGV0IHRyX211bHRpIH50YXJnZXQgfnJlcGxhY2VtZW50ID1cbiAgaWYgaXNfZW1wdHkgdGFyZ2V0XG4gIHRoZW4gc3RhZ2UgRm4uaWRcbiAgZWxzZSBpZiBpc19lbXB0eSByZXBsYWNlbWVudFxuICB0aGVuIGludmFsaWRfYXJnIFwidHJfbXVsdGkgcmVwbGFjZW1lbnQgaXMgZW1wdHkgc3RyaW5nXCJcbiAgZWxzZSAoXG4gICAgbWF0Y2ggQnl0ZXNfdHIudHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCB3aXRoXG4gICAgfCBOb25lIC0+IHN0YWdlIEZuLmlkXG4gICAgfCBTb21lIHRyX21hcCAtPlxuICAgICAgc3RhZ2UgKGZ1biBzIC0+XG4gICAgICAgIGlmIGV4aXN0cyBzIH5mOihmdW4gYyAtPiBDaGFyLiggPD4gKSBjICh1bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgYykpKVxuICAgICAgICB0aGVuIG1hcCBzIH5mOihmdW4gYyAtPiB1bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgYykpXG4gICAgICAgIGVsc2UgcykpXG47O1xuXG4oKiBmYXN0IHZlcnNpb24sIGlmIHdlIGV2ZXIgbmVlZCBpdDpcbiAgIHtbXG4gICAgIGxldCBjb25jYXRfYXJyYXkgfnNlcCBhciA9XG4gICAgICAgbGV0IGFyX2xlbiA9IEFycmF5Lmxlbmd0aCBhciBpblxuICAgICAgIGlmIGFyX2xlbiA9IDAgdGhlbiBcIlwiXG4gICAgICAgZWxzZVxuICAgICAgICAgbGV0IHNlcF9sZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICBsZXQgcmVzX2xlbl9yZWYgPSByZWYgKHNlcF9sZW4gKiAoYXJfbGVuIC0gMSkpIGluXG4gICAgICAgICBmb3IgaSA9IDAgdG8gYXJfbGVuIC0gMSBkb1xuICAgICAgICAgICByZXNfbGVuX3JlZiA6PSAhcmVzX2xlbl9yZWYgKyBsZW5ndGggYXIuKGkpXG4gICAgICAgICBkb25lO1xuICAgICAgICAgbGV0IHJlcyA9IGNyZWF0ZSAhcmVzX2xlbl9yZWYgaW5cbiAgICAgICAgIGxldCBzdHJfMCA9IGFyLigwKSBpblxuICAgICAgICAgbGV0IGxlbl8wID0gbGVuZ3RoIHN0cl8wIGluXG4gICAgICAgICBibGl0IH5zcmM6c3RyXzAgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczowIH5sZW46bGVuXzA7XG4gICAgICAgICBsZXQgcG9zX3JlZiA9IHJlZiBsZW5fMCBpblxuICAgICAgICAgZm9yIGkgPSAxIHRvIGFyX2xlbiAtIDEgZG9cbiAgICAgICAgICAgbGV0IHBvcyA9ICFwb3NfcmVmIGluXG4gICAgICAgICAgIGJsaXQgfnNyYzpzZXAgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3Bvczpwb3MgfmxlbjpzZXBfbGVuO1xuICAgICAgICAgICBsZXQgbmV3X3BvcyA9IHBvcyArIHNlcF9sZW4gaW5cbiAgICAgICAgICAgbGV0IHN0cl9pID0gYXIuKGkpIGluXG4gICAgICAgICAgIGxldCBsZW5faSA9IGxlbmd0aCBzdHJfaSBpblxuICAgICAgICAgICBibGl0IH5zcmM6c3RyX2kgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczpuZXdfcG9zIH5sZW46bGVuX2k7XG4gICAgICAgICAgIHBvc19yZWYgOj0gbmV3X3BvcyArIGxlbl9pXG4gICAgICAgICBkb25lO1xuICAgICAgICAgcmVzXG4gICBdfSAqKVxuXG5sZXQgY29uY2F0X2FycmF5ID9zZXAgYXIgPSBjb25jYXQgP3NlcCAoQXJyYXkudG9fbGlzdCBhcilcbmxldCBjb25jYXRfbWFwID9zZXAgcyB+ZiA9IGNvbmNhdF9hcnJheSA/c2VwIChBcnJheS5tYXAgKHRvX2FycmF5IHMpIH5mKVxubGV0IGNvbmNhdF9tYXBpID9zZXAgdCB+ZiA9IGNvbmNhdF9hcnJheSA/c2VwIChBcnJheS5tYXBpICh0b19hcnJheSB0KSB+ZilcblxubGV0IGNvbmNhdF9saW5lcyA9XG4gIGxldCByZWMgbGluZV9sZW5ndGhzIH5saW5lcyB+bmV3bGluZV9sZW4gfnN1bSA9XG4gICAgbWF0Y2ggbGluZXMgd2l0aFxuICAgIHwgW10gLT4gc3VtXG4gICAgfCBsaW5lIDo6IGxpbmVzIC0+XG4gICAgICBsZXQgc3VtID0gc3VtICsgU3RyaW5nLmxlbmd0aCBsaW5lICsgbmV3bGluZV9sZW4gaW5cbiAgICAgIGxpbmVfbGVuZ3RocyB+bGluZXMgfm5ld2xpbmVfbGVuIH5zdW1cbiAgaW5cbiAgbGV0IHJlYyB3cml0ZV9saW5lcyB+YnVmIH5saW5lcyB+Y3JsZiB+cG9zID1cbiAgICBtYXRjaCBsaW5lcyB3aXRoXG4gICAgfCBbXSAtPiBwb3NcbiAgICB8IGxpbmUgOjogbGluZXMgLT5cbiAgICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZ1xuICAgICAgICB+c3JjOmxpbmVcbiAgICAgICAgfnNyY19wb3M6MFxuICAgICAgICB+ZHN0OmJ1ZlxuICAgICAgICB+ZHN0X3Bvczpwb3NcbiAgICAgICAgfmxlbjooU3RyaW5nLmxlbmd0aCBsaW5lKTtcbiAgICAgIGxldCBwb3MgPSBwb3MgKyBTdHJpbmcubGVuZ3RoIGxpbmUgaW5cbiAgICAgIGxldCBwb3MgPVxuICAgICAgICBpZiBjcmxmXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgYnVmIHBvcyAnXFxyJztcbiAgICAgICAgICBwb3MgKyAxKVxuICAgICAgICBlbHNlIHBvc1xuICAgICAgaW5cbiAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgYnVmIHBvcyAnXFxuJztcbiAgICAgIGxldCBwb3MgPSBwb3MgKyAxIGluXG4gICAgICB3cml0ZV9saW5lcyB+YnVmIH5saW5lcyB+Y3JsZiB+cG9zXG4gIGluXG4gIGZ1biA/KGNybGYgPSBmYWxzZSkgbGluZXMgLT5cbiAgICBsZXQgbmV3bGluZV9sZW4gPSBpZiBjcmxmIHRoZW4gMiBlbHNlIDEgaW5cbiAgICBsZXQgbGVuID0gbGluZV9sZW5ndGhzIH5uZXdsaW5lX2xlbiB+bGluZXMgfnN1bTowIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgd3JpdHRlbiA9IHdyaXRlX2xpbmVzIH5idWYgfmxpbmVzIH5jcmxmIH5wb3M6MCBpblxuICAgIGFzc2VydCAod3JpdHRlbiA9IGxlbik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpidWZcbjs7XG5cbigqIFtmaWx0ZXIgdCBmXSBpcyBpbXBsZW1lbnRlZCBieSB0aGUgZm9sbG93aW5nIGFsZ29yaXRobS5cblxuICAgTGV0IFtuID0gbGVuZ3RoIHRdLlxuXG4gICAxLiBGaW5kIHRoZSBsb3dlc3QgW2ldIHN1Y2ggdGhhdCBbbm90IChmIHQuW2ldKV0uXG5cbiAgIDIuIElmIHRoZXJlIGlzIG5vIHN1Y2ggW2ldLCB0aGVuIHJldHVybiBbdF0uXG5cbiAgIDMuIElmIHRoZXJlIGlzIHN1Y2ggYW4gW2ldLCBhbGxvY2F0ZSBhIHN0cmluZywgW291dF0sIHRvIGhvbGQgdGhlIHJlc3VsdC4gIFtvdXRdIGhhc1xuICAgbGVuZ3RoIFtuIC0gMV0sIHdoaWNoIGlzIHRoZSBtYXhpbXVtIHBvc3NpYmxlIG91dHB1dCBzaXplIGdpdmVuIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3RcbiAgIG9uZSBjaGFyYWN0ZXIgbm90IHNhdGlzZnlpbmcgW2ZdLlxuXG4gICA0LiBDb3B5IGNoYXJhY3RlcnMgYXQgaW5kaWNlcyAwIC4uLiBbaSAtIDFdIGZyb20gW3RdIHRvIFtvdXRdLlxuXG4gICA1LiBXYWxrIHRocm91Z2ggY2hhcmFjdGVycyBhdCBpbmRpY2VzIFtpKzFdIC4uLiBbbi0xXSBvZiBbdF0sIGNvcHlpbmcgdGhvc2UgdGhhdFxuICAgc2F0aXNmeSBbZl0gZnJvbSBbdF0gdG8gW291dF0uXG5cbiAgIDYuIElmIHdlIGNvbXBsZXRlbHkgZmlsbGVkIFtvdXRdLCB0aGVuIHJldHVybiBpdC4gIElmIG5vdCwgcmV0dXJuIHRoZSBwcmVmaXggb2YgW291dF1cbiAgIHRoYXQgd2UgZGlkIGZpbGwgaW4uXG5cbiAgIFRoaXMgYWxnb3JpdGhtIGhhcyB0aGUgcHJvcGVydHkgdGhhdCBpdCBkb2Vzbid0IGFsbG9jYXRlIGEgbmV3IHN0cmluZyBpZiB0aGVyZSdzXG4gICBub3RoaW5nIHRvIGZpbHRlciwgd2hpY2ggaXMgYSBjb21tb24gY2FzZS4gKilcbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IG4gJiYgZiB0LlshaV0gZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgaWYgIWkgPSBuXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBsZXQgb3V0ID0gQnl0ZXMuY3JlYXRlIChuIC0gMSkgaW5cbiAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnQgfnNyY19wb3M6MCB+ZHN0Om91dCB+ZHN0X3BvczowIH5sZW46IWk7XG4gICAgbGV0IG91dF9wb3MgPSByZWYgIWkgaW5cbiAgICBpbmNyIGk7XG4gICAgd2hpbGUgIWkgPCBuIGRvXG4gICAgICBsZXQgYyA9IHQuWyFpXSBpblxuICAgICAgaWYgZiBjXG4gICAgICB0aGVuIChcbiAgICAgICAgQnl0ZXMuc2V0IG91dCAhb3V0X3BvcyBjO1xuICAgICAgICBpbmNyIG91dF9wb3MpO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICBsZXQgb3V0ID0gQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpvdXQgaW5cbiAgICBpZiAhb3V0X3BvcyA9IG4gLSAxIHRoZW4gb3V0IGVsc2Ugc3ViIG91dCB+cG9zOjAgfmxlbjohb3V0X3Bvcylcbjs7XG5cbigqIHJlcGVhdGVkIGNvZGUgdG8gYXZvaWQgcmVxdWlyaW5nIGFuIGV4dHJhIGFsbG9jYXRpb24gZm9yIGEgY2xvc3VyZSBvbiBlYWNoIGNhbGwuICopXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbiAmJiBmICFpIHQuWyFpXSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBpZiAhaSA9IG5cbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIGxldCBvdXQgPSBCeXRlcy5jcmVhdGUgKG4gLSAxKSBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6dCB+c3JjX3BvczowIH5kc3Q6b3V0IH5kc3RfcG9zOjAgfmxlbjohaTtcbiAgICBsZXQgb3V0X3BvcyA9IHJlZiAhaSBpblxuICAgIGluY3IgaTtcbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjID0gdC5bIWldIGluXG4gICAgICBpZiBmICFpIGNcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0ICFvdXRfcG9zIGM7XG4gICAgICAgIGluY3Igb3V0X3Bvcyk7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgIGxldCBvdXQgPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOm91dCBpblxuICAgIGlmICFvdXRfcG9zID0gbiAtIDEgdGhlbiBvdXQgZWxzZSBzdWIgb3V0IH5wb3M6MCB+bGVuOiFvdXRfcG9zKVxuOztcblxubGV0IGNob3BfcHJlZml4IHMgfnByZWZpeCA9XG4gIGlmIGlzX3ByZWZpeCBzIH5wcmVmaXggdGhlbiBTb21lIChkcm9wX3ByZWZpeCBzIChsZW5ndGggcHJlZml4KSkgZWxzZSBOb25lXG47O1xuXG5sZXQgY2hvcF9wcmVmaXhfaWZfZXhpc3RzIHMgfnByZWZpeCA9XG4gIGlmIGlzX3ByZWZpeCBzIH5wcmVmaXggdGhlbiBkcm9wX3ByZWZpeCBzIChsZW5ndGggcHJlZml4KSBlbHNlIHNcbjs7XG5cbmxldCBjaG9wX3ByZWZpeF9leG4gcyB+cHJlZml4ID1cbiAgbWF0Y2ggY2hvcF9wcmVmaXggcyB+cHJlZml4IHdpdGhcbiAgfCBTb21lIHN0ciAtPiBzdHJcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnZiBcIlN0cmluZy5jaG9wX3ByZWZpeF9leG4gJVMgJVNcIiBzIHByZWZpeCAoKVxuOztcblxubGV0IGNob3Bfc3VmZml4IHMgfnN1ZmZpeCA9XG4gIGlmIGlzX3N1ZmZpeCBzIH5zdWZmaXggdGhlbiBTb21lIChkcm9wX3N1ZmZpeCBzIChsZW5ndGggc3VmZml4KSkgZWxzZSBOb25lXG47O1xuXG5sZXQgY2hvcF9zdWZmaXhfaWZfZXhpc3RzIHMgfnN1ZmZpeCA9XG4gIGlmIGlzX3N1ZmZpeCBzIH5zdWZmaXggdGhlbiBkcm9wX3N1ZmZpeCBzIChsZW5ndGggc3VmZml4KSBlbHNlIHNcbjs7XG5cbmxldCBjaG9wX3N1ZmZpeF9leG4gcyB+c3VmZml4ID1cbiAgbWF0Y2ggY2hvcF9zdWZmaXggcyB+c3VmZml4IHdpdGhcbiAgfCBTb21lIHN0ciAtPiBzdHJcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnZiBcIlN0cmluZy5jaG9wX3N1ZmZpeF9leG4gJVMgJVNcIiBzIHN1ZmZpeCAoKVxuOztcblxubW9kdWxlIEZvcl9jb21tb25fcHJlZml4X2FuZF9zdWZmaXggPSBzdHJ1Y3RcbiAgKCogV2hlbiB0YWtpbmcgYSBzdHJpbmcgcHJlZml4IG9yIHN1ZmZpeCwgd2UgZXh0cmFjdCBmcm9tIHRoZSBzaG9ydGVzdCBpbnB1dCBhdmFpbGFibGVcbiAgICAgaW4gY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gb25lIG9mIG91ciBpbnB1dHMgd2l0aG91dCBhbGxvY2F0aW5nIGEgbmV3IHN0cmluZy4gKilcblxuICBsZXQgc2hvcnRlciBhIGIgPSBpZiBsZW5ndGggYSA8PSBsZW5ndGggYiB0aGVuIGEgZWxzZSBiXG5cbiAgbGV0IHNob3J0ZXN0IGxpc3QgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gXCJcIlxuICAgIHwgZmlyc3QgOjogcmVzdCAtPiBMaXN0LmZvbGQgcmVzdCB+aW5pdDpmaXJzdCB+ZjpzaG9ydGVyXG4gIDs7XG5cbiAgKCogT3VyIGdlbmVyaWMgYWNjZXNzb3JzIGZvciBjb21tb24gcHJlZml4L3N1ZmZpeCBhYnN0cmFjdCBvdmVyIFtnZXRfcG9zXSwgd2hpY2ggaXNcbiAgICAgZWl0aGVyIFtwb3NfZnJvbV9sZWZ0XSBvciBbcG9zX2Zyb21fcmlnaHRdLiAqKVxuXG4gIGxldCBwb3NfZnJvbV9sZWZ0IChfIDogdCkgKGkgOiBpbnQpID0gaVxuICBsZXQgcG9zX2Zyb21fcmlnaHQgdCBpID0gbGVuZ3RoIHQgLSBpIC0gMVxuXG4gIGxldCByZWMgY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGEgYiB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhciA9XG4gICAgaWYgbGVuX3NvX2ZhciA+PSBtYXhfbGVuXG4gICAgdGhlbiBtYXhfbGVuXG4gICAgZWxzZSBpZiBDaGFyLmVxdWFsXG4gICAgICAgICAgICAgICh1bnNhZmVfZ2V0IGEgKGdldF9wb3MgYSBsZW5fc29fZmFyKSlcbiAgICAgICAgICAgICAgKHVuc2FmZV9nZXQgYiAoZ2V0X3BvcyBiIGxlbl9zb19mYXIpKVxuICAgIHRoZW4gY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGEgYiB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhcjoobGVuX3NvX2ZhciArIDEpXG4gICAgZWxzZSBsZW5fc29fZmFyXG4gIDs7XG5cbiAgbGV0IGNvbW1vbl9nZW5lcmljMl9sZW5ndGggYSBiIH5nZXRfcG9zID1cbiAgICBsZXQgbWF4X2xlbiA9IG1pbiAobGVuZ3RoIGEpIChsZW5ndGggYikgaW5cbiAgICBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyOjBcbiAgOztcblxuICBsZXQgcmVjIGNvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wIGZpcnN0IGxpc3QgfmdldF9wb3Mgfm1heF9sZW4gPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gbWF4X2xlblxuICAgIHwgc2Vjb25kIDo6IHJlc3QgLT5cbiAgICAgIGxldCBtYXhfbGVuID1cbiAgICAgICAgKCogV2UgY2FsbCBbY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wXSByYXRoZXIgdGhhbiBbY29tbW9uX2dlbmVyaWMyX2xlbmd0aF0gc29cbiAgICAgICAgICAgdGhhdCBbbWF4X2xlbl0gbGltaXRzIG91ciB0cmF2ZXJzYWwgb2YgW2ZpcnN0XSBhbmQgW3NlY29uZF0uICopXG4gICAgICAgIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBmaXJzdCBzZWNvbmQgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXI6MFxuICAgICAgaW5cbiAgICAgIGNvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wIHNlY29uZCByZXN0IH5nZXRfcG9zIH5tYXhfbGVuXG4gIDs7XG5cbiAgbGV0IGNvbW1vbl9nZW5lcmljX2xlbmd0aCBsaXN0IH5nZXRfcG9zID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IDBcbiAgICB8IGZpcnN0IDo6IHJlc3QgLT5cbiAgICAgICgqIFByZWNvbXB1dGluZyBbbWF4X2xlbl0gYmFzZWQgb24gW3Nob3J0ZXN0IGxpc3RdIHNhdmVzIHVzIHdvcmsgaW4gbG9uZ2VyIHN0cmluZ3MsXG4gICAgICAgICBhdCB0aGUgY29zdCBvZiBhbiBleHRyYSBwYXNzIG92ZXIgdGhlIHNwaW5lIG9mIFtsaXN0XS5cblxuICAgICAgICAgRm9yIGV4YW1wbGUsIGlmIHlvdSdyZSBsb29raW5nIGZvciB0aGUgbG9uZ2VzdCBwcmVmaXggb2YgdGhlIHN0cmluZ3M6XG5cbiAgICAgICAgIHt2XG4gICAgICAgICAgICBsZXQgbG9uZ19hID0gTGlzdC5pbml0IDEwMDAgfmY6KEZuLmNvbnN0ICdhJylcbiAgICAgICAgICAgIFsgbG9uZ19hOyBsb25nX2E7ICdhYScgXVxuICAgICAgICAgdn1cblxuICAgICAgICAgdGhlIGFwcHJvYWNoIGJlbG93IHdpbGwganVzdCBjaGVjayB0aGUgZmlyc3QgdHdvIGNoYXJhY3RlcnMgb2YgYWxsIHRoZSBzdHJpbmdzLlxuICAgICAgKilcbiAgICAgIGxldCBtYXhfbGVuID0gbGVuZ3RoIChzaG9ydGVzdCBsaXN0KSBpblxuICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgcmVzdCB+Z2V0X3BvcyB+bWF4X2xlblxuICA7O1xuXG4gICgqIE91ciBnZW5lcmljIGFjY2Vzc29ycyB0aGF0IHByb2R1Y2UgYSBzdHJpbmcgYWJzdHJhY3Qgb3ZlciBbdGFrZV0sIHdoaWNoIGlzIGVpdGhlclxuICAgICBbcHJlZml4XSBvciBbc3VmZml4XS4gKilcblxuICBsZXQgY29tbW9uX2dlbmVyaWMyIGEgYiB+Z2V0X3BvcyB+dGFrZSA9XG4gICAgbGV0IGxlbiA9IGNvbW1vbl9nZW5lcmljMl9sZW5ndGggYSBiIH5nZXRfcG9zIGluXG4gICAgKCogVXNlIHRoZSBzaG9ydGVyIG9mIHRoZSB0d28gc3RyaW5ncywgc28gdGhhdCBpZiB0aGUgc2hvcnRlciBvbmUgaXMgdGhlIHNoYXJlZFxuICAgICAgIHByZWZpeCwgW3Rha2VdIHdvbid0IGFsbG9jYXRlIGFub3RoZXIgc3RyaW5nLiAqKVxuICAgIHRha2UgKHNob3J0ZXIgYSBiKSBsZW5cbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWMgbGlzdCB+Z2V0X3BvcyB+dGFrZSA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBcIlwiXG4gICAgfCBmaXJzdCA6OiByZXN0IC0+XG4gICAgICAoKiBBcyB3aXRoIFtjb21tb25fZ2VuZXJpY19sZW5ndGhdLCB3ZSBiYXNlIFttYXhfbGVuXSBvbiBbc2hvcnRlc3QgbGlzdF0uIFdlIGFsc29cbiAgICAgICAgIHVzZSB0aGlzIHJlc3VsdCBmb3IgW3Rha2VdLCBiZWxvdywgdG8gcG90ZW50aWFsbHkgYXZvaWQgYWxsb2NhdGluZyBhIHN0cmluZy4gKilcbiAgICAgIGxldCBzID0gc2hvcnRlc3QgbGlzdCBpblxuICAgICAgbGV0IG1heF9sZW4gPSBsZW5ndGggcyBpblxuICAgICAgaWYgbWF4X2xlbiA9IDBcbiAgICAgIHRoZW4gXCJcIlxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsZW4gPVxuICAgICAgICAgICgqIFdlIGNhbGwgZGlyZWN0bHkgaW50byBbY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3BdIHJhdGhlciB0aGFuXG4gICAgICAgICAgICAgW2NvbW1vbl9nZW5lcmljX2xlbmd0aF0gdG8gYXZvaWQgcmVjb21wdXRpbmcgW3Nob3J0ZXN0IGxpc3RdLiAqKVxuICAgICAgICAgIGNvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wIGZpcnN0IHJlc3QgfmdldF9wb3Mgfm1heF9sZW5cbiAgICAgICAgaW5cbiAgICAgICAgdGFrZSBzIGxlbilcbiAgOztcbmVuZFxuXG5pbmNsdWRlIHN0cnVjdFxuICBvcGVuIEZvcl9jb21tb25fcHJlZml4X2FuZF9zdWZmaXhcblxuICBsZXQgY29tbW9uX3ByZWZpeCBsaXN0ID0gY29tbW9uX2dlbmVyaWMgbGlzdCB+dGFrZTpwcmVmaXggfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeCBsaXN0ID0gY29tbW9uX2dlbmVyaWMgbGlzdCB+dGFrZTpzdWZmaXggfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXgyIGEgYiA9IGNvbW1vbl9nZW5lcmljMiBhIGIgfnRha2U6cHJlZml4IH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXgyIGEgYiA9IGNvbW1vbl9nZW5lcmljMiBhIGIgfnRha2U6c3VmZml4IH5nZXRfcG9zOnBvc19mcm9tX3JpZ2h0XG4gIGxldCBjb21tb25fcHJlZml4X2xlbmd0aCBsaXN0ID0gY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeF9sZW5ndGggbGlzdCA9IGNvbW1vbl9nZW5lcmljX2xlbmd0aCBsaXN0IH5nZXRfcG9zOnBvc19mcm9tX3JpZ2h0XG4gIGxldCBjb21tb25fcHJlZml4Ml9sZW5ndGggYSBiID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeDJfbGVuZ3RoIGEgYiA9IGNvbW1vbl9nZW5lcmljMl9sZW5ndGggYSBiIH5nZXRfcG9zOnBvc19mcm9tX3JpZ2h0XG5lbmRcblxuKCogVGhlcmUgdXNlZCB0byBiZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB0aGF0IHdhcyBmYXN0ZXIgZm9yIHZlcnkgc2hvcnQgc3RyaW5nc1xuICAgKHBlYWtpbmcgYXQgNDAlIGZhc3RlciBmb3IgNC02IGNoYXIgbG9uZyBzdHJpbmdzKS5cbiAgIFRoaXMgbmV3IGZ1bmN0aW9uIGlzIGFyb3VuZCAyMCUgZmFzdGVyIHRoYW4gdGhlIGRlZmF1bHQgaGFzaCBmdW5jdGlvbiwgYnV0IHNsb3dlclxuICAgdGhhbiB0aGUgcHJldmlvdXMgY3VzdG9tIGltcGxlbWVudGF0aW9uLiBIb3dldmVyLCB0aGUgbmV3IE9DYW1sIGZ1bmN0aW9uIGlzIHdlbGxcbiAgIGJlaGF2ZWQsIGFuZCB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGxlc3MgbGlrZWx5IHRvIGRpdmVyZ2UgZnJvbSB0aGUgZGVmYXVsdCBPQ2FtbFxuICAgaW1wbGVtZW50YXRpb24gZG9lcywgd2hpY2ggaXMgYSBkZXNpcmFibGUgcHJvcGVydHkuIChUaGUgb25seSB3YXkgdG8gYXZvaWQgdGhlXG4gICBkaXZlcmdlbmNlIGlzIHRvIGV4cG9zZSB0aGUgbWFjcm8gcmVkZWZpbmVkIGluIGhhc2hfc3R1YnMuYyBpbiB0aGUgaGFzaC5oIGhlYWRlciBvZlxuICAgdGhlIE9DYW1sIGNvbXBpbGVyLikgKilcbm1vZHVsZSBIYXNoID0gc3RydWN0XG4gIGV4dGVybmFsIGhhc2ggOiBzdHJpbmcgLT4gaW50ID0gXCJCYXNlX2hhc2hfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmVuZFxuXG4oKiBbaW5jbHVkZSBIYXNoXSB0byBtYWtlIHRoZSBbZXh0ZXJuYWxdIHZlcnNpb24gb3ZlcnJpZGUgdGhlIFtoYXNoXSBmcm9tXG4gICBbSGFzaGFibGUuTWFrZV9iaW5hYmxlXSwgc28gdGhhdCB3ZSBnZXQgYSBsaXR0bGUgYml0IG9mIGEgc3BlZWR1cCBieSBleHBvc2luZyBpdCBhc1xuICAgZXh0ZXJuYWwgaW4gdGhlIG1saS4gKilcbmxldCBfID0gaGFzaFxuXG5pbmNsdWRlIEhhc2hcblxuKCogZm9yIGludGVyYWN0aXZlIHRvcC1sZXZlbHMgLS0gbW9kdWxlcyBkZXJpdmluZyBmcm9tIFN0cmluZyBzaG91bGQgaGF2ZSBTdHJpbmcncyBwcmV0dHlcbiAgIHByaW50ZXIuICopXG5sZXQgcHAgcHBmIHN0cmluZyA9IFN0ZGxpYi5Gb3JtYXQuZnByaW50ZiBwcGYgXCIlU1wiIHN0cmluZ1xubGV0IG9mX2NoYXIgYyA9IG1ha2UgMSBjXG5cbmxldCBvZl9jaGFyX2xpc3QgbCA9XG4gIGxldCB0ID0gQnl0ZXMuY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIGMgLT4gQnl0ZXMuc2V0IHQgaSBjKTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0XG47O1xuXG5sZXQgb2ZfbGlzdCA9IG9mX2NoYXJfbGlzdFxubGV0IG9mX2FycmF5IGEgPSBpbml0IChBcnJheS5sZW5ndGggYSkgfmY6KEFycmF5LmdldCBhKVxuXG5sZXQgdG9fc2VxdWVuY2UgdCA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdDowIH5mOihmdW4gcG9zIC0+XG4gICAgaWYgcG9zID49IGxlbiB0aGVuIERvbmUgZWxzZSBZaWVsZCB7IHZhbHVlID0gdW5zYWZlX2dldCB0IHBvczsgc3RhdGUgPSBwb3MgKyAxIH0pXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2UgcyA9IG9mX2xpc3QgKFNlcXVlbmNlLnRvX2xpc3QgcylcbmxldCBhcHBlbmQgPSAoIF4gKVxuXG5sZXQgcGFkX3JpZ2h0ID8oY2hhciA9ICcgJykgcyB+bGVuID1cbiAgbGV0IHNyY19sZW4gPSBsZW5ndGggcyBpblxuICBpZiBzcmNfbGVuID49IGxlblxuICB0aGVuIHNcbiAgZWxzZSAoXG4gICAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnMgfmRzdDpyZXMgfnNyY19wb3M6MCB+ZHN0X3BvczowIH5sZW46c3JjX2xlbjtcbiAgICBCeXRlcy5maWxsIH5wb3M6c3JjX2xlbiB+bGVuOihsZW4gLSBzcmNfbGVuKSByZXMgY2hhcjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnJlcylcbjs7XG5cbmxldCBwYWRfbGVmdCA/KGNoYXIgPSAnICcpIHMgfmxlbiA9XG4gIGxldCBzcmNfbGVuID0gbGVuZ3RoIHMgaW5cbiAgaWYgc3JjX2xlbiA+PSBsZW5cbiAgdGhlbiBzXG4gIGVsc2UgKFxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzpzIH5kc3Q6cmVzIH5zcmNfcG9zOjAgfmRzdF9wb3M6KGxlbiAtIHNyY19sZW4pIH5sZW46c3JjX2xlbjtcbiAgICBCeXRlcy5maWxsIH5wb3M6MCB+bGVuOihsZW4gLSBzcmNfbGVuKSByZXMgY2hhcjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnJlcylcbjs7XG5cbigqIENhbGxlZCB1cG9uIGZpcnN0IGRpZmZlcmVuY2UgZ2VuZXJhdGVkIGJ5IGZpbHRlcmluZy4gQWxsb2NhdGVzIFtidWZmZXJfbGVuXSBieXRlc1xuICAgZm9yIG5ldyByZXN1bHQsIGFuZCBjb3BpZXMgW3ByZWZpeF9sZW5dIHVuY2hhbmdlZCBjaGFyYWN0ZXJzIGZyb20gW3NyY10uXG4gICBBbHdheXMgcmV0dXJucyBhIGxvY2FsIGJ1ZmZlci4gKilcbmxldCBsb2NhbF9jb3B5X3ByZWZpeCBzcmMgfnByZWZpeF9sZW4gfmJ1ZmZlcl9sZW4gPVxuICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlX2xvY2FsIGJ1ZmZlcl9sZW4gaW5cbiAgQnl0ZXMuUHJpbWl0aXZlcy51bnNhZmVfYmxpdF9zdHJpbmcgfnNyYyB+ZHN0IH5zcmNfcG9zOjAgfmRzdF9wb3M6MCB+bGVuOnByZWZpeF9sZW47XG4gIGRzdFxuOztcblxuKCogQ29waWVzIGEgcGVyaGFwcy1sb2NhbCBidWZmZXIgaW50byBhIGRlZmluaXRlbHktZ2xvYmFsIHN0cmluZy4gKilcbmxldCBsb2NhbF9jb3B5X3RvX3N0cmluZyBidWYgfnBvcyA9XG4gIGxldCBzdHIgPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmJ1ZiBpblxuICB1bnNhZmVfc3ViIHN0ciB+cG9zOjAgfmxlbjpwb3MgW0Bub250YWlsXVxuOztcblxuaW5jbHVkZSBzdHJ1Y3RcbiAgb3BlbiBzdHJ1Y3RcbiAgICAoKiBmaWx0ZXJfbWFwIGhlbHBlcnMgKilcblxuICAgICgqIEZpbHRlcnMgZnJvbSBzdHJpbmcgW3NyY10gaW50byBhbiBhbGxvY2F0ZWQgYnVmZmVyIFtkc3RdO1xuICAgICAgIGNvcGllcyB0aGUgYWxsb2NhdGVkIGJ1ZmZlciB0byBhIGhlYXAtYWxsb2NhdGVkIHJlc3VsdCBzdHJpbmcuXG5cbiAgICAgICBQcmUtY29uZGl0aW9uczpcbiAgICAgICBbc3JjX2xlbiA9IGxlbmd0aCBzcmNdXG4gICAgICAgW3NyYyAhPSBkc3RdXG4gICAgICAgWzAgPD0gc3JjX3BvcyA8IHNyY19sZW5dXG4gICAgICAgWzAgPD0gZHN0X3BvcyA8IGxlbmd0aCBkc3RdXG4gICAgKilcbiAgICBsZXQgZmlsdGVyX21hcGlfaW50byBzcmMgZHN0IH5mIH5zcmNfcG9zIH5kc3RfcG9zIH5zcmNfbGVuID1cbiAgICAgIGxldCBkc3RfcG9zID0gcmVmIGRzdF9wb3MgaW5cbiAgICAgIGZvciBzcmNfcG9zID0gc3JjX3BvcyB0byBzcmNfbGVuIC0gMSBkb1xuICAgICAgICBtYXRjaCBmIHNyY19wb3MgKHVuc2FmZV9nZXQgc3JjIHNyY19wb3MpIHdpdGhcbiAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgIHwgU29tZSBjIC0+XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBkc3QgIWRzdF9wb3MgYztcbiAgICAgICAgICBpbmNyIGRzdF9wb3NcbiAgICAgIGRvbmU7XG4gICAgICBsb2NhbF9jb3B5X3RvX3N0cmluZyBkc3QgfnBvczohZHN0X3Bvc1xuICAgIDs7XG5cbiAgICAoKiBGaWx0ZXJzIFt0XS4gSWYgdGhlIHJlc3VsdCB0dXJucyBvdXQgdG8gYmUgaWRlbnRpY2FsIHRvIHRoZSBpbnB1dCwgcmV0dXJucyBbdF1cbiAgICAgICBkaXJlY3RseSB3aXRob3V0IG5lZWRpbmcgdG8gYWxsb2NhdGUgYSBidWZmZXIgYW5kIHRyYXZlcnNlIHRoZSBzdHJpbmcgdHdpY2UuXG5cbiAgICAgICBQcmUtY29uZGl0aW9uOiBbbGVuID09IGxlbmd0aCB0XVxuICAgICAgIFByZS1jb25kaXRpb246IFswIDw9IHBvcyA8PSBsZW5dICopXG4gICAgbGV0IHJlYyBmaWx0ZXJfbWFwaV9tYXliZV9pZCB0IH5mIH5wb3MgfmxlbiA9XG4gICAgICBpZiBwb3MgPSBsZW5cbiAgICAgIHRoZW4gdFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBjMSA9IHVuc2FmZV9nZXQgdCBwb3MgaW5cbiAgICAgICAgbGV0IG5leHQgPSBJbnQuc3VjYyBwb3MgaW5cbiAgICAgICAgbWF0Y2ggZiBwb3MgYzEgd2l0aFxuICAgICAgICB8IFNvbWUgYzIgd2hlbiBDaGFyLmVxdWFsIGMxIGMyIC0+XG4gICAgICAgICAgKCogaWYgbm90aGluZyBoYXMgY2hhbmdlZCwgY29udGludWUgKilcbiAgICAgICAgICBmaWx0ZXJfbWFwaV9tYXliZV9pZCB0IH5mIH5wb3M6bmV4dCB+bGVuXG4gICAgICAgIHwgb3B0aW9uIC0+XG4gICAgICAgICAgKCogSWYgYSBjaGFyYWN0ZXIgaGFzIGJlZW4gY2hhbmdlZCBvciBkcm9wcGVkLCBiZWdpbiBhbiBvdXRwdXQgYnVmZmVyIHVwIHRvXG4gICAgICAgICAgICAgW3Bvc10sIGFuZCB3cml0ZSB0aGUgbmV3IGNoYXJhY3RlciBpbnRvIGl0LiAqKVxuICAgICAgICAgIGxldCBjb3B5ID0gbG9jYWxfY29weV9wcmVmaXggdCB+cHJlZml4X2xlbjpwb3MgfmJ1ZmZlcl9sZW46bGVuIGluXG4gICAgICAgICAgbGV0IGRzdF9wb3MgPVxuICAgICAgICAgICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBwb3NcbiAgICAgICAgICAgIHwgU29tZSBjIC0+XG4gICAgICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgY29weSBwb3MgYztcbiAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgIGluXG4gICAgICAgICAgZmlsdGVyX21hcGlfaW50byB0IGNvcHkgfmYgfnNyY19wb3M6bmV4dCB+ZHN0X3BvcyB+c3JjX2xlbjpsZW4gW0Bub250YWlsXSlcbiAgICA7O1xuICBlbmRcblxuICAoKiBmaWx0ZXJfbWFwIGZ1bmN0aW9ucyAqKVxuXG4gIGxldCBmaWx0ZXJfbWFwaSB0IH5mID0gZmlsdGVyX21hcGlfbWF5YmVfaWQgdCB+ZiB+cG9zOjAgfmxlbjoobGVuZ3RoIHQpXG4gIGxldCBmaWx0ZXJfbWFwIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gXyBjIC0+IGYgYykgW0Bub250YWlsXVxuZW5kXG5cbmluY2x1ZGUgc3RydWN0XG4gIG9wZW4gc3RydWN0XG4gICAgKCogcGFydGl0aW9uIGhlbHBlcnMgKilcblxuICAgIGxldCBwYXJ0aXRpb25fbWFwX2ludG8gc3JjIH5mc3RzIH5zbmRzIH5mIH5sZW4gfnNyY19wb3MgfmZzdF9wb3MgfnNuZF9wb3MgPVxuICAgICAgbGV0IGZzdF9wb3MgPSByZWYgZnN0X3BvcyBpblxuICAgICAgbGV0IHNuZF9wb3MgPSByZWYgc25kX3BvcyBpblxuICAgICAgZm9yIHNyY19wb3MgPSBzcmNfcG9zIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbWF0Y2ggKGYgKHVuc2FmZV9nZXQgc3JjIHNyY19wb3MpIDogKF8sIF8pIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgYyAtPlxuICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgZnN0cyAhZnN0X3BvcyBjO1xuICAgICAgICAgIGluY3IgZnN0X3Bvc1xuICAgICAgICB8IFNlY29uZCBjIC0+XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzbmRzICFzbmRfcG9zIGM7XG4gICAgICAgICAgaW5jciBzbmRfcG9zXG4gICAgICBkb25lO1xuICAgICAgbG9jYWxfY29weV90b19zdHJpbmcgZnN0cyB+cG9zOiFmc3RfcG9zLCBsb2NhbF9jb3B5X3RvX3N0cmluZyBzbmRzIH5wb3M6IXNuZF9wb3NcbiAgICA7O1xuXG4gICAgbGV0IHBhcnRpdGlvbl9tYXBfZGlmZmVyZW5jZSBzcmMgfmYgfmxlbiB+cG9zOnNyY19wb3MgfmZzdF9wb3MgfnNuZF9wb3MgZWl0aGVyID1cbiAgICAgIGxldCBmc3RzID0gbG9jYWxfY29weV9wcmVmaXggc3JjIH5wcmVmaXhfbGVuOmZzdF9wb3MgfmJ1ZmZlcl9sZW46bGVuIGluXG4gICAgICBsZXQgc25kcyA9IGxvY2FsX2NvcHlfcHJlZml4IHNyYyB+cHJlZml4X2xlbjpzbmRfcG9zIH5idWZmZXJfbGVuOmxlbiBpblxuICAgICAgbGV0IGZzdF9wb3MsIHNuZF9wb3MgPVxuICAgICAgICBtYXRjaCAoZWl0aGVyIDogKF8sIF8pIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgYyAtPlxuICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgZnN0cyBmc3RfcG9zIGM7XG4gICAgICAgICAgZnN0X3BvcyArIDEsIHNuZF9wb3NcbiAgICAgICAgfCBTZWNvbmQgYyAtPlxuICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgc25kcyBzbmRfcG9zIGM7XG4gICAgICAgICAgZnN0X3Bvcywgc25kX3BvcyArIDFcbiAgICAgIGluXG4gICAgICBwYXJ0aXRpb25fbWFwX2ludG9cbiAgICAgICAgc3JjXG4gICAgICAgIH5mc3RzXG4gICAgICAgIH5zbmRzXG4gICAgICAgIH5mXG4gICAgICAgIH5sZW5cbiAgICAgICAgfnNyY19wb3M6KHNyY19wb3MgKyAxKVxuICAgICAgICB+ZnN0X3Bvc1xuICAgICAgICB+c25kX3BvcyBbQG5vbnRhaWxdXG4gICAgOztcblxuICAgIGxldCByZWMgcGFydGl0aW9uX21hcF9maXJzdF9tYXliZV9pZCBzcmMgfmYgfnBvcyB+bGVuID1cbiAgICAgIGlmIHBvcyA9IGxlblxuICAgICAgdGhlbiBzcmMsIFwiXCJcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYzEgPSB1bnNhZmVfZ2V0IHNyYyBwb3MgaW5cbiAgICAgICAgbWF0Y2ggKGYgYzEgOiAoXywgXykgRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgfCBGaXJzdCBjMiB3aGVuIENoYXIuZXF1YWwgYzEgYzIgLT5cbiAgICAgICAgICBwYXJ0aXRpb25fbWFwX2ZpcnN0X21heWJlX2lkIHNyYyB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpXG4gICAgICAgIHwgZWl0aGVyIC0+XG4gICAgICAgICAgcGFydGl0aW9uX21hcF9kaWZmZXJlbmNlXG4gICAgICAgICAgICBzcmNcbiAgICAgICAgICAgIH5mXG4gICAgICAgICAgICB+bGVuXG4gICAgICAgICAgICB+cG9zXG4gICAgICAgICAgICB+ZnN0X3Bvczpwb3NcbiAgICAgICAgICAgIH5zbmRfcG9zOjBcbiAgICAgICAgICAgIGVpdGhlciBbQG5vbnRhaWxdKVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbl9tYXBfc2Vjb25kX21heWJlX2lkIHNyYyB+ZiB+cG9zIH5sZW4gPVxuICAgICAgaWYgcG9zID0gbGVuXG4gICAgICB0aGVuIFwiXCIsIHNyY1xuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBjMSA9IHVuc2FmZV9nZXQgc3JjIHBvcyBpblxuICAgICAgICBtYXRjaCAoZiBjMSA6IChfLCBfKSBFaXRoZXIudCkgd2l0aFxuICAgICAgICB8IFNlY29uZCBjMiB3aGVuIENoYXIuZXF1YWwgYzEgYzIgLT5cbiAgICAgICAgICBwYXJ0aXRpb25fbWFwX3NlY29uZF9tYXliZV9pZCBzcmMgfmYgfmxlbiB+cG9zOihwb3MgKyAxKVxuICAgICAgICB8IGVpdGhlciAtPlxuICAgICAgICAgIHBhcnRpdGlvbl9tYXBfZGlmZmVyZW5jZVxuICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICB+ZlxuICAgICAgICAgICAgfmxlblxuICAgICAgICAgICAgfnBvc1xuICAgICAgICAgICAgfmZzdF9wb3M6MFxuICAgICAgICAgICAgfnNuZF9wb3M6cG9zXG4gICAgICAgICAgICBlaXRoZXIgW0Bub250YWlsXSlcbiAgICA7O1xuICBlbmRcblxuICAoKiBwYXJ0aXRpb24gZnVuY3Rpb25zICopXG5cbiAgbGV0IHBhcnRpdGlvbl9tYXAgc3JjIH5mID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHNyYyBpblxuICAgIGlmIGxlbiA9IDBcbiAgICB0aGVuIFwiXCIsIFwiXCJcbiAgICBlbHNlIChcbiAgICAgIGxldCBjMSA9IHVuc2FmZV9nZXQgc3JjIDAgaW5cbiAgICAgIG1hdGNoIChmIGMxIDogKF8sIF8pIEVpdGhlci50KSB3aXRoXG4gICAgICB8IEZpcnN0IGMyIHdoZW4gQ2hhci5lcXVhbCBjMSBjMiAtPiBwYXJ0aXRpb25fbWFwX2ZpcnN0X21heWJlX2lkIHNyYyB+ZiB+bGVuIH5wb3M6MVxuICAgICAgfCBTZWNvbmQgYzIgd2hlbiBDaGFyLmVxdWFsIGMxIGMyIC0+XG4gICAgICAgIHBhcnRpdGlvbl9tYXBfc2Vjb25kX21heWJlX2lkIHNyYyB+ZiB+bGVuIH5wb3M6MVxuICAgICAgfCBlaXRoZXIgLT5cbiAgICAgICAgcGFydGl0aW9uX21hcF9kaWZmZXJlbmNlXG4gICAgICAgICAgc3JjXG4gICAgICAgICAgfmZcbiAgICAgICAgICB+bGVuXG4gICAgICAgICAgfnBvczowXG4gICAgICAgICAgfmZzdF9wb3M6MFxuICAgICAgICAgIH5zbmRfcG9zOjBcbiAgICAgICAgICBlaXRoZXIgW0Bub250YWlsXSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICAgIHBhcnRpdGlvbl9tYXAgdCB+ZjooZnVuIGMgLT4gaWYgZiBjIHRoZW4gRmlyc3QgYyBlbHNlIFNlY29uZCBjKSBbQG5vbnRhaWxdXG4gIDs7XG5lbmRcblxubGV0IGVkaXRfZGlzdGFuY2UgczEgczIgPVxuICAoKiBXZSBtYWludGFpbiBhIHRhYmxlIG9mIGVkaXQgZGlzdGFuY2UgYmV0d2VlbiBhbGwgaW5kaWNlcyBvZiB0aGUgc2hvcnRlciBzdHJpbmcsIGFuZFxuICAgICB0aGUgY3VycmVudCBhbmQgcHJldmlvdXMgaW5kaWNlcyBvZiB0aGUgbG9uZ2VyIHN0cmluZy4gKilcbiAgbGV0IHMxLCBzMiA9IGlmIFN0cmluZy5sZW5ndGggczEgPD0gU3RyaW5nLmxlbmd0aCBzMiB0aGVuIHMxLCBzMiBlbHNlIHMyLCBzMSBpblxuICBsZXQgdGFibGUgPSBBcnJheS5jcmVhdGVfbG9jYWwgfmxlbjooMiAqICgxICsgU3RyaW5nLmxlbmd0aCBzMSkpIDAgaW5cbiAgbGV0IGF0IGkgaiA9IChpICogMikgKyAoaiBtb2QgMikgaW5cbiAgZm9yIGkgPSAxIHRvIFN0cmluZy5sZW5ndGggczEgZG9cbiAgICAoKiBJbnNlcnQgW2ldIGNoYXJhY3RlcnMgd2hlbiBbaj0wXS4gKilcbiAgICB0YWJsZS4oYXQgaSAwKSA8LSBpXG4gIGRvbmU7XG4gIGZvciBqID0gMSB0byBTdHJpbmcubGVuZ3RoIHMyIGRvXG4gICAgKCogSW5zZXJ0IFtqXSBjaGFyYWN0ZXJzIHdoZW4gW2k9MF0uICopXG4gICAgdGFibGUuKGF0IDAgaikgPC0gajtcbiAgICBmb3IgaSA9IDEgdG8gU3RyaW5nLmxlbmd0aCBzMSBkb1xuICAgICAgaWYgQ2hhci5lcXVhbCBzMS5baSAtIDFdIHMyLltqIC0gMV1cbiAgICAgIHRoZW5cbiAgICAgICAgKCogTm90aGluZyB0byBlZGl0IGZvciB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG4gICAgICAgIHRhYmxlLihhdCBpIGopIDwtIHRhYmxlLihhdCAoaSAtIDEpIChqIC0gMSkpXG4gICAgICBlbHNlIChcbiAgICAgICAgKCogRWRpdCB0aGUgY3VycmVudCBjaGFyYWN0ZXIgYnkgc3Vic3RpdHV0aW9uLCBhZGRpdGlvbiwgb3IgZGVsZXRpb24uICopXG4gICAgICAgIGxldCBzdWIgPSB0YWJsZS4oYXQgKGkgLSAxKSAoaiAtIDEpKSBpblxuICAgICAgICBsZXQgYWRkID0gdGFibGUuKGF0IChpIC0gMSkgaikgaW5cbiAgICAgICAgbGV0IGRlbCA9IHRhYmxlLihhdCBpIChqIC0gMSkpIGluXG4gICAgICAgIHRhYmxlLihhdCBpIGopIDwtIDEgKyBtaW4gc3ViIChtaW4gYWRkIGRlbCkpXG4gICAgZG9uZVxuICBkb25lO1xuICAoKiBSZXR1cm4gdGhlIGZpbmFsIHJlc3VsdC4gKilcbiAgdGFibGUuKGF0IChTdHJpbmcubGVuZ3RoIHMxKSAoU3RyaW5nLmxlbmd0aCBzMikpXG47O1xuXG5tb2R1bGUgRXNjYXBpbmcgPSBzdHJ1Y3RcbiAgKCogSWYgdGhpcyBpcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdG8gdXBkYXRlIFtlc2NhcGVdLCB3aGljaCBhdHRlbXB0cyB0byBlbnN1cmUgYWxsIHRoZVxuICAgICBpbnZhcmlhbnRzIGNoZWNrZWQgaGVyZS4gICopXG4gIGxldCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGZ1bmMgPVxuICAgIGxldCBlc2NhcGV3b3J0aHlfbWFwID1cbiAgICAgIGlmIExpc3QuQXNzb2MubWVtIGVzY2FwZXdvcnRoeV9tYXAgfmVxdWFsOkNoYXIuZXF1YWwgZXNjYXBlX2NoYXJcbiAgICAgIHRoZW4gZXNjYXBld29ydGh5X21hcFxuICAgICAgZWxzZSAoZXNjYXBlX2NoYXIsIGVzY2FwZV9jaGFyKSA6OiBlc2NhcGV3b3J0aHlfbWFwXG4gICAgaW5cbiAgICBsZXQgYXJyID0gQXJyYXkuY3JlYXRlIH5sZW46MjU2ICgtMSkgaW5cbiAgICBsZXQgdmFscyA9IEFycmF5LmNyZWF0ZSB+bGVuOjI1NiBmYWxzZSBpblxuICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IE9rIGFyclxuICAgICAgfCAoY19mcm9tLCBjX3RvKSA6OiBsIC0+XG4gICAgICAgIGxldCBrLCB2ID1cbiAgICAgICAgICBtYXRjaCBmdW5jIHdpdGhcbiAgICAgICAgICB8IGBFc2NhcGUgLT4gQ2hhci50b19pbnQgY19mcm9tLCBjX3RvXG4gICAgICAgICAgfCBgVW5lc2NhcGUgLT4gQ2hhci50b19pbnQgY190bywgY19mcm9tXG4gICAgICAgIGluXG4gICAgICAgIGlmIGFyci4oaykgPD4gLTEgfHwgdmFscy4oQ2hhci50b19pbnQgdilcbiAgICAgICAgdGhlblxuICAgICAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICAgIFwiZXNjYXBld29ydGh5X21hcCBub3Qgb25lLXRvLW9uZVwiXG4gICAgICAgICAgICAgICBbIFwiY19mcm9tXCIsIHNleHBfb2ZfY2hhciBjX2Zyb21cbiAgICAgICAgICAgICAgIDsgXCJjX3RvXCIsIHNleHBfb2ZfY2hhciBjX3RvXG4gICAgICAgICAgICAgICA7ICggXCJlc2NhcGV3b3J0aHlfbWFwXCJcbiAgICAgICAgICAgICAgICAgLCBzZXhwX29mX2xpc3QgKHNleHBfb2ZfcGFpciBzZXhwX29mX2NoYXIgc2V4cF9vZl9jaGFyKSBlc2NhcGV3b3J0aHlfbWFwXG4gICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgIF0pXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGFyci4oaykgPC0gQ2hhci50b19pbnQgdjtcbiAgICAgICAgICB2YWxzLihDaGFyLnRvX2ludCB2KSA8LSB0cnVlO1xuICAgICAgICAgIGxvb3AgbClcbiAgICBpblxuICAgIGxvb3AgZXNjYXBld29ydGh5X21hcFxuICA7O1xuXG4gIGxldCBlc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoeV9tYXAgZXNjYXBld29ydGh5X21hcCBlc2NhcGVfY2hhciBgRXNjYXBlIHdpdGhcbiAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgfCBPayBlc2NhcGV3b3J0aHkgLT5cbiAgICAgIE9rXG4gICAgICAgIChmdW4gc3JjIC0+XG4gICAgICAgICAgKCogY2FsY3VsYXRlIGEgbGlzdCBvZiAoaW5kZXggb2YgY2hhciB0byBlc2NhcGUgKiBlc2NhcGVkIGNoYXIpIGZpcnN0LCB0aGUgb3JkZXJcbiAgICAgICAgICAgICAgaXMgZnJvbSB0YWlsIHRvIGhlYWQgKilcbiAgICAgICAgICBsZXQgdG9fZXNjYXBlX2xlbiA9IHJlZiAwIGluXG4gICAgICAgICAgbGV0IHRvX2VzY2FwZSA9XG4gICAgICAgICAgICBmb2xkaSBzcmMgfmluaXQ6W10gfmY6KGZ1biBpIGFjYyBjIC0+XG4gICAgICAgICAgICAgIG1hdGNoIGVzY2FwZXdvcnRoeS4oQ2hhci50b19pbnQgYykgd2l0aFxuICAgICAgICAgICAgICB8IC0xIC0+IGFjY1xuICAgICAgICAgICAgICB8IG4gLT5cbiAgICAgICAgICAgICAgICAoKiAoaW5kZXggb2YgY2hhciB0byBlc2NhcGUgKiBlc2NhcGVkIGNoYXIpICopXG4gICAgICAgICAgICAgICAgaW5jciB0b19lc2NhcGVfbGVuO1xuICAgICAgICAgICAgICAgIChpLCBDaGFyLnVuc2FmZV9vZl9pbnQgbikgOjogYWNjKVxuICAgICAgICAgIGluXG4gICAgICAgICAgbWF0Y2ggdG9fZXNjYXBlIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IHNyY1xuICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgKCogW3RvX2VzY2FwZV0gZGl2aWRlIFtzcmNdIHRvIFtMaXN0Lmxlbmd0aCB0b19lc2NhcGUgKyAxXSBwaWVjZXMgc2VwYXJhdGVkIGJ5XG4gICAgICAgICAgICAgICAgdGhlIGNoYXJzIHRvIGVzY2FwZS5cblxuICAgICAgICAgICAgICAgIExldHMgdGFrZVxuICAgICAgICAgICAgICAgIHtbXG4gICAgICAgICAgICAgICAgICBlc2NhcGVfZ2VuX2V4blxuICAgICAgICAgICAgICAgICAgICB+ZXNjYXBld29ydGh5X21hcDpbKCdhJywgJ0EnKTsgKCdiJywgJ0InKTsgKCdjJywgJ0MnKV1cbiAgICAgICAgICAgICAgICAgICAgfmVzY2FwZV9jaGFyOidfJ1xuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUsIGFuZCBhc3N1bWUgdGhlIHN0cmluZyB0byBlc2NhcGUgaXNcblxuICAgICAgICAgICAgICAgIFwiMDAwYTExMWIyMjJjMzMzXCJcblxuICAgICAgICAgICAgICAgIHRoZW4gW3RvX2VzY2FwZV0gaXMgWygxMSwgJ0MnKTsgKDcsICdCJyk7ICgzLCAnQScpXS5cblxuICAgICAgICAgICAgICAgIFRoZW4gd2UgY3JlYXRlIGEgW2RzdF0gb2YgbGVuZ3RoIFtsZW5ndGggc3JjICsgM10gdG8gc3RvcmUgdGhlXG4gICAgICAgICAgICAgICAgcmVzdWx0LCBjb3B5IHBpZWNlIFwiMzMzXCIgdG8gW2RzdF0gZGlyZWN0bHksIHRoZW4gY29weSAnXycgYW5kICdDJyB0byBbZHN0XTtcbiAgICAgICAgICAgICAgICB0aGVuIG1vdmUgb24gdG8gbmV4dDsgYWZ0ZXIgMyBpdGVyYXRpb25zLCBjb3B5IHBpZWNlIFwiMDAwXCIgYW5kIHdlIGFyZSBkb25lLlxuXG4gICAgICAgICAgICAgICAgRmluYWxseSB0aGUgcmVzdWx0IHdpbGwgYmVcblxuICAgICAgICAgICAgICAgIFwiMDAwX0ExMTFfQjIyMl9DMzMzXCIgKilcbiAgICAgICAgICAgIGxldCBzcmNfbGVuID0gbGVuZ3RoIHNyYyBpblxuICAgICAgICAgICAgbGV0IGRzdF9sZW4gPSBzcmNfbGVuICsgIXRvX2VzY2FwZV9sZW4gaW5cbiAgICAgICAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgZHN0X2xlbiBpblxuICAgICAgICAgICAgbGV0IHJlYyBsb29wIGxhc3RfaWR4IGxhc3RfZHN0X3BvcyA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgIHwgW10gLT5cbiAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMDAwXCIgYXQgbGFzdCAqKVxuICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjpsYXN0X2lkeFxuICAgICAgICAgICAgICB8IChpZHgsIGVzY2FwZWRfY2hhcikgOjogdG9fZXNjYXBlIC0+XG4gICAgICAgICAgICAgICAgKCpbaWR4XSA9IHRoZSBjaGFyIHRvIGVzY2FwZSopXG4gICAgICAgICAgICAgICAgKCogdGFrZSBmaXJzdCBpdGVyYXRpb24gZm9yIGV4YW1wbGUgKilcbiAgICAgICAgICAgICAgICAoKiBjYWxjdWxhdGUgbGVuZ3RoIG9mIFwiMzMzXCIsIG1pbnVzIDEgYmVjYXVzZSB3ZSBkb24ndCBjb3B5ICdjJyAqKVxuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBsYXN0X2lkeCAtIGlkeCAtIDEgaW5cbiAgICAgICAgICAgICAgICAoKiBzZXQgdGhlIGRzdF9wb3MgdG8gY29weSB0byAqKVxuICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gbGFzdF9kc3RfcG9zIC0gbGVuIGluXG4gICAgICAgICAgICAgICAgKCogY29weSBcIjMzM1wiLCBzZXQgW3NyY19wb3NdIHRvIFtpZHggKyAxXSB0byBza2lwICdjJyAqKVxuICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6KGlkeCArIDEpIH5kc3QgfmRzdF9wb3MgfmxlbjtcbiAgICAgICAgICAgICAgICAoKiBiYWNrb2ZmIFtkc3RfcG9zXSBieSAyIHRvIGNvcHkgJ18nIGFuZCAnQycgKilcbiAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGRzdF9wb3MgLSAyIGluXG4gICAgICAgICAgICAgICAgQnl0ZXMuc2V0IGRzdCBkc3RfcG9zIGVzY2FwZV9jaGFyO1xuICAgICAgICAgICAgICAgIEJ5dGVzLnNldCBkc3QgKGRzdF9wb3MgKyAxKSBlc2NhcGVkX2NoYXI7XG4gICAgICAgICAgICAgICAgbG9vcCBpZHggZHN0X3BvcyB0b19lc2NhcGVcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICAoKiBzZXQgW2xhc3RfZHN0X3Bvc10gYW5kIFtsYXN0X2lkeF0gdG8gbGVuZ3RoIG9mIFtkc3RdIGFuZCBbc3JjXSBmaXJzdCAqKVxuICAgICAgICAgICAgbG9vcCBzcmNfbGVuIGRzdF9sZW4gdG9fZXNjYXBlO1xuICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3QpXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgT3JfZXJyb3Iub2tfZXhuIChlc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhcikgfD4gc3RhZ2VcbiAgOztcblxuICBsZXQgZXNjYXBlIH5lc2NhcGV3b3J0aHkgfmVzY2FwZV9jaGFyID1cbiAgICAoKiBGb3IgW2VzY2FwZV9nZW5fZXhuXSwgd2UgZG9uJ3Qga25vdyBob3cgdG8gZml4IGludmFsaWQgZXNjYXBld29ydGh5X21hcCBzbyB3ZSBoYXZlXG4gICAgICAgdG8gcmFpc2UgZXhjZXB0aW9uOyBidXQgaW4gdGhpcyBjYXNlLCB3ZSBrbm93IGhvdyB0byBmaXggZHVwbGljYXRlZCBlbGVtZW50cyBpblxuICAgICAgIGVzY2FwZXdvcnRoeSBsaXN0LCBzbyB3ZSBqdXN0IGZpeCBpdCBpbnN0ZWFkIG9mIHJhaXNpbmcgZXhjZXB0aW9uIHRvIG1ha2UgdGhpc1xuICAgICAgIGZ1bmN0aW9uIGVhc2llciB0byB1c2UuICAqKVxuICAgIGxldCBlc2NhcGV3b3J0aHlfbWFwID1cbiAgICAgIGVzY2FwZXdvcnRoeVxuICAgICAgfD4gTGlzdC5kZWR1cF9hbmRfc29ydCB+Y29tcGFyZTpDaGFyLmNvbXBhcmVcbiAgICAgIHw+IExpc3QubWFwIH5mOihmdW4gYyAtPiBjLCBjKVxuICAgIGluXG4gICAgZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyXG4gIDs7XG5cbiAgKCogSW4gYW4gZXNjYXBlZCBzdHJpbmcsIGFueSBjaGFyIGlzIGVpdGhlciBgRXNjYXBpbmcsIGBFc2NhcGVkIG9yIGBMaXRlcmFsLiBGb3JcbiAgICAgZXhhbXBsZSwgdGhlIGVzY2FwZSBzdGF0dXNlcyBvZiBjaGFycyBpbiBzdHJpbmcgXCJhX2FfX1wiIHdpdGggZXNjYXBlX2NoYXIgPSAnXycgYXJlXG5cbiAgICAgYSA6IGBMaXRlcmFsXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgYSA6IGBFc2NhcGVkXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgXyA6IGBFc2NhcGVkXG5cbiAgICAgW3VwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSBwcmV2aW91c19zdGF0dXNdIGdldHMgZXNjYXBlIHN0YXR1cyBvZlxuICAgICBzdHIuW2ldIGJhc2luZyBvbiBlc2NhcGUgc3RhdHVzIG9mIHN0ci5baSAtIDFdICopXG4gIGxldCB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgPSBmdW5jdGlvblxuICAgIHwgYEVzY2FwaW5nIC0+IGBFc2NhcGVkXG4gICAgfCBgTGl0ZXJhbCB8IGBFc2NhcGVkIC0+XG4gICAgICBpZiBDaGFyLmVxdWFsIHN0ci5baV0gZXNjYXBlX2NoYXIgdGhlbiBgRXNjYXBpbmcgZWxzZSBgTGl0ZXJhbFxuICA7O1xuXG4gIGxldCB1bmVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGBVbmVzY2FwZSB3aXRoXG4gICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgIHwgT2sgZXNjYXBld29ydGh5IC0+XG4gICAgICBPa1xuICAgICAgICAoZnVuIHNyYyAtPlxuICAgICAgICAgICgqIENvbnRpbnVlIHRoZSBleGFtcGxlIGluIFtlc2NhcGVfZ2VuX2V4bl0sIG5vdyB3ZSB1bmVzY2FwZVxuXG4gICAgICAgICAgICAgIFwiMDAwX0ExMTFfQjIyMl9DMzMzXCJcblxuICAgICAgICAgICAgICBiYWNrIHRvXG5cbiAgICAgICAgICAgICAgXCIwMDBhMTExYjIyMmMzMzNcIlxuXG4gICAgICAgICAgICAgIFRoZW4gW3RvX3VuZXNjYXBlXSBpcyBbMTQ7IDk7IDRdLCB3aGljaCBpcyBpbmRleGVzIG9mICdfJ3MuXG5cbiAgICAgICAgICAgICAgVGhlbiB3ZSBjcmVhdGUgYSBzdHJpbmcgW2RzdF0gdG8gc3RvcmUgdGhlIHJlc3VsdCwgY29weSBcIjMzM1wiIHRvIGl0LCB0aGVuIGNvcHlcbiAgICAgICAgICAgICAgJ2MnLCB0aGVuIG1vdmUgb24gdG8gbmV4dCBpdGVyYXRpb24uIEFmdGVyIDMgaXRlcmF0aW9ucyBjb3B5IFwiMDAwXCIgYW5kIHdlIGFyZVxuICAgICAgICAgICAgICBkb25lLiAgKilcbiAgICAgICAgICAoKiBpbmRleGVzIG9mIGVzY2FwZSBjaGFycyAqKVxuICAgICAgICAgIGxldCB0b191bmVzY2FwZSA9XG4gICAgICAgICAgICBsZXQgcmVjIGxvb3AgaSBzdGF0dXMgYWNjID1cbiAgICAgICAgICAgICAgaWYgaSA+PSBsZW5ndGggc3JjXG4gICAgICAgICAgICAgIHRoZW4gYWNjXG4gICAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICAgIGxldCBzdGF0dXMgPSB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzcmMgfmVzY2FwZV9jaGFyIGkgc3RhdHVzIGluXG4gICAgICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICAgICAgKGkgKyAxKVxuICAgICAgICAgICAgICAgICAgc3RhdHVzXG4gICAgICAgICAgICAgICAgICAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IGBFc2NhcGluZyAtPiBpIDo6IGFjY1xuICAgICAgICAgICAgICAgICAgIHwgYEVzY2FwZWQgfCBgTGl0ZXJhbCAtPiBhY2MpKVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxvb3AgMCBgTGl0ZXJhbCBbXVxuICAgICAgICAgIGluXG4gICAgICAgICAgbWF0Y2ggdG9fdW5lc2NhcGUgd2l0aFxuICAgICAgICAgIHwgW10gLT4gc3JjXG4gICAgICAgICAgfCBpZHggOjogdG9fdW5lc2NhcGUnIC0+XG4gICAgICAgICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIChsZW5ndGggc3JjIC0gTGlzdC5sZW5ndGggdG9fdW5lc2NhcGUpIGluXG4gICAgICAgICAgICBsZXQgcmVjIGxvb3AgbGFzdF9pZHggbGFzdF9kc3RfcG9zID0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICAgICAgICgqIGNvcHkgXCIwMDBcIiBhdCBsYXN0ICopXG4gICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmxhc3RfaWR4XG4gICAgICAgICAgICAgIHwgaWR4IDo6IHRvX3VuZXNjYXBlIC0+XG4gICAgICAgICAgICAgICAgKCogW2lkeF0gPSBpbmRleCBvZiBlc2NhcGluZyBjaGFyICopXG4gICAgICAgICAgICAgICAgKCogdGFrZSAxc3QgaXRlcmF0aW9uIGFzIGV4YW1wbGUsIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIFwiMzMzXCIsIG1pbnVzIDIgdG9cbiAgICAgICAgICAgICAgICAgICAgc2tpcCAnX0MnICopXG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IGxhc3RfaWR4IC0gaWR4IC0gMiBpblxuICAgICAgICAgICAgICAgICgqIHBvaW50IFtkc3RfcG9zXSB0byB0aGUgcG9zaXRpb24gdG8gY29weSBcIjMzM1wiIHRvICopXG4gICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBsYXN0X2RzdF9wb3MgLSBsZW4gaW5cbiAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMzMzXCIgKilcbiAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOihpZHggKyAyKSB+ZHN0IH5kc3RfcG9zIH5sZW47XG4gICAgICAgICAgICAgICAgKCogYmFja29mZiBbZHN0X3Bvc10gYnkgMSB0byBjb3B5ICdjJyAqKVxuICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gZHN0X3BvcyAtIDEgaW5cbiAgICAgICAgICAgICAgICBCeXRlcy5zZXRcbiAgICAgICAgICAgICAgICAgIGRzdFxuICAgICAgICAgICAgICAgICAgZHN0X3Bvc1xuICAgICAgICAgICAgICAgICAgKG1hdGNoIGVzY2FwZXdvcnRoeS4oQ2hhci50b19pbnQgc3JjLltpZHggKyAxXSkgd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgLTEgLT4gc3JjLltpZHggKyAxXVxuICAgICAgICAgICAgICAgICAgIHwgbiAtPiBDaGFyLnVuc2FmZV9vZl9pbnQgbik7XG4gICAgICAgICAgICAgICAgKCogdXBkYXRlIFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdICopXG4gICAgICAgICAgICAgICAgbG9vcCBpZHggZHN0X3BvcyB0b191bmVzY2FwZVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGlmIGlkeCA8IGxlbmd0aCBzcmMgLSAxXG4gICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICgqIHNldCBbbGFzdF9kc3RfcG9zXSBhbmQgW2xhc3RfaWR4XSB0byBsZW5ndGggb2YgW2RzdF0gYW5kIFtzcmNdICopXG4gICAgICAgICAgICAgIGxvb3AgKGxlbmd0aCBzcmMpIChCeXRlcy5sZW5ndGggZHN0KSB0b191bmVzY2FwZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAoKiBmb3IgZXNjYXBlZCBzdHJpbmcgZW5kaW5nIHdpdGggYW4gZXNjYXBpbmcgY2hhciBsaWtlIFwiMDAwX1wiLCBqdXN0IGlnbm9yZVxuICAgICAgICAgICAgICAgICAgdGhlIGxhc3QgZXNjYXBpbmcgY2hhciAqKVxuICAgICAgICAgICAgICBsb29wIChsZW5ndGggc3JjIC0gMSkgKEJ5dGVzLmxlbmd0aCBkc3QpIHRvX3VuZXNjYXBlJztcbiAgICAgICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0KVxuICA7O1xuXG4gIGxldCB1bmVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgT3JfZXJyb3Iub2tfZXhuICh1bmVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyKSB8PiBzdGFnZVxuICA7O1xuXG4gIGxldCB1bmVzY2FwZSB+ZXNjYXBlX2NoYXIgPSB1bmVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwOltdIH5lc2NhcGVfY2hhclxuXG4gIGxldCBwcmVjZWRpbmdfZXNjYXBlX2NoYXJzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBsZXQgcmVjIGxvb3AgcCBjbnQgPVxuICAgICAgaWYgcCA8IDAgfHwgQ2hhci4oIDw+ICkgc3RyLltwXSBlc2NhcGVfY2hhciB0aGVuIGNudCBlbHNlIGxvb3AgKHAgLSAxKSAoY250ICsgMSlcbiAgICBpblxuICAgIGxvb3AgKHBvcyAtIDEpIDBcbiAgOztcblxuICAoKiBJbiBhbiBlc2NhcGVkIHN0cmluZywgYW55IGNoYXIgaXMgZWl0aGVyIGBFc2NhcGluZywgYEVzY2FwZWQgb3IgYExpdGVyYWwuIEZvclxuICAgICBleGFtcGxlLCB0aGUgZXNjYXBlIHN0YXR1c2VzIG9mIGNoYXJzIGluIHN0cmluZyBcImFfYV9fXCIgd2l0aCBlc2NhcGVfY2hhciA9ICdfJyBhcmVcblxuICAgICBhIDogYExpdGVyYWxcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBhIDogYEVzY2FwZWRcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBfIDogYEVzY2FwZWRcblxuICAgICBbdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHByZXZpb3VzX3N0YXR1c10gZ2V0cyBlc2NhcGUgc3RhdHVzIG9mXG4gICAgIHN0ci5baV0gYmFzaW5nIG9uIGVzY2FwZSBzdGF0dXMgb2Ygc3RyLltpIC0gMV0gKilcbiAgbGV0IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSA9IGZ1bmN0aW9uXG4gICAgfCBgRXNjYXBpbmcgLT4gYEVzY2FwZWRcbiAgICB8IGBMaXRlcmFsIHwgYEVzY2FwZWQgLT5cbiAgICAgIGlmIENoYXIuZXF1YWwgc3RyLltpXSBlc2NhcGVfY2hhciB0aGVuIGBFc2NhcGluZyBlbHNlIGBMaXRlcmFsXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGxldCBvZGQgPSBwcmVjZWRpbmdfZXNjYXBlX2NoYXJzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIG1vZCAyID0gMSBpblxuICAgIG1hdGNoIG9kZCwgQ2hhci5lcXVhbCBzdHIuW3Bvc10gZXNjYXBlX2NoYXIgd2l0aFxuICAgIHwgdHJ1ZSwgKHRydWUgfCBmYWxzZSkgLT4gYEVzY2FwZWRcbiAgICB8IGZhbHNlLCB0cnVlIC0+IGBFc2NhcGluZ1xuICAgIHwgZmFsc2UsIGZhbHNlIC0+IGBMaXRlcmFsXG4gIDs7XG5cbiAgbGV0IGNoZWNrX2JvdW5kIHN0ciBwb3MgZnVuY3Rpb25fbmFtZSA9XG4gICAgaWYgcG9zID49IGxlbmd0aCBzdHIgfHwgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIiVzOiBvdXQgb2YgYm91bmRzXCIgZnVuY3Rpb25fbmFtZSAoKVxuICA7O1xuXG4gIGxldCBpc19jaGFyX2VzY2FwaW5nIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaXNfY2hhcl9lc2NhcGluZ1wiO1xuICAgIG1hdGNoIGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgd2l0aFxuICAgIHwgYEVzY2FwaW5nIC0+IHRydWVcbiAgICB8IGBFc2NhcGVkIHwgYExpdGVyYWwgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaXNfY2hhcl9lc2NhcGVkIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaXNfY2hhcl9lc2NhcGVkXCI7XG4gICAgbWF0Y2ggZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyB3aXRoXG4gICAgfCBgRXNjYXBlZCAtPiB0cnVlXG4gICAgfCBgRXNjYXBpbmcgfCBgTGl0ZXJhbCAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBpc19jaGFyX2xpdGVyYWwgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2xpdGVyYWxcIjtcbiAgICBtYXRjaCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHdpdGhcbiAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICB8IGBFc2NhcGVkIHwgYEVzY2FwaW5nIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImluZGV4X2Zyb21cIjtcbiAgICBsZXQgcmVjIGxvb3AgaSBzdGF0dXMgPVxuICAgICAgaWYgaSA+PSBwb3NcbiAgICAgICAgICYmIChtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgICAgIHwgYExpdGVyYWwgLT4gdHJ1ZVxuICAgICAgICAgICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2UpXG4gICAgICAgICAmJiBDaGFyLmVxdWFsIHN0ci5baV0gY2hhclxuICAgICAgdGhlbiBTb21lIGlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgaSA9IGkgKyAxIGluXG4gICAgICAgIGlmIGkgPj0gbGVuZ3RoIHN0clxuICAgICAgICB0aGVuIE5vbmVcbiAgICAgICAgZWxzZSBsb29wIGkgKHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSBzdGF0dXMpKVxuICAgIGluXG4gICAgbG9vcCBwb3MgKGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3MpXG4gIDs7XG5cbiAgbGV0IGluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIG1hdGNoIGluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCJcbiAgICAgICAgICAgWyBcInN0clwiLCBzZXhwX29mX3Qgc3RyXG4gICAgICAgICAgIDsgXCJlc2NhcGVfY2hhclwiLCBzZXhwX29mX2NoYXIgZXNjYXBlX2NoYXJcbiAgICAgICAgICAgOyBcInBvc1wiLCBzZXhwX29mX2ludCBwb3NcbiAgICAgICAgICAgOyBcImNoYXJcIiwgc2V4cF9vZl9jaGFyIGNoYXJcbiAgICAgICAgICAgXSlcbiAgICB8IFNvbWUgcG9zIC0+IHBvc1xuICA7O1xuXG4gIGxldCBpbmRleCBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPSBpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgMCBjaGFyXG4gIGxldCBpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBjaGFyID0gaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciAwIGNoYXJcblxuICBsZXQgcmluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcInJpbmRleF9mcm9tXCI7XG4gICAgKCogaWYgdGhlIHRhcmdldCBjaGFyIGlzIHRoZSBzYW1lIGFzIFtlc2NhcGVfY2hhcl0sIHdlIGhhdmUgbm8gd2F5IHRvIGRldGVybWluZSB3aGljaFxuICAgICAgIGVzY2FwZV9jaGFyIGlzIGxpdGVyYWwsIHNvIGp1c3QgcmV0dXJuIE5vbmUgKilcbiAgICBpZiBDaGFyLmVxdWFsIGNoYXIgZXNjYXBlX2NoYXJcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCBwb3MgPVxuICAgICAgICBpZiBwb3MgPCAwXG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgZXNjYXBlX2NoYXJzID0gcHJlY2VkaW5nX2VzY2FwZV9jaGFycyBzdHIgfmVzY2FwZV9jaGFyIHBvcyBpblxuICAgICAgICAgIGlmIGVzY2FwZV9jaGFycyBtb2QgMiA9IDAgJiYgQ2hhci5lcXVhbCBzdHIuW3Bvc10gY2hhclxuICAgICAgICAgIHRoZW4gU29tZSBwb3NcbiAgICAgICAgICBlbHNlIGxvb3AgKHBvcyAtIGVzY2FwZV9jaGFycyAtIDEpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgcG9zKVxuICA7O1xuXG4gIGxldCByaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgbWF0Y2ggcmluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJyaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiXG4gICAgICAgICAgIFsgXCJzdHJcIiwgc2V4cF9vZl90IHN0clxuICAgICAgICAgICA7IFwiZXNjYXBlX2NoYXJcIiwgc2V4cF9vZl9jaGFyIGVzY2FwZV9jaGFyXG4gICAgICAgICAgIDsgXCJwb3NcIiwgc2V4cF9vZl9pbnQgcG9zXG4gICAgICAgICAgIDsgXCJjaGFyXCIsIHNleHBfb2ZfY2hhciBjaGFyXG4gICAgICAgICAgIF0pXG4gICAgfCBTb21lIHBvcyAtPiBwb3NcbiAgOztcblxuICBsZXQgcmluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9XG4gICAgaWYgaXNfZW1wdHkgc3RyIHRoZW4gTm9uZSBlbHNlIHJpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgKGxlbmd0aCBzdHIgLSAxKSBjaGFyXG4gIDs7XG5cbiAgbGV0IHJpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBjaGFyID1cbiAgICByaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciAobGVuZ3RoIHN0ciAtIDEpIGNoYXJcbiAgOztcblxuICAoKiBbc3BsaXRfZ2VuIHN0ciB+ZXNjYXBlX2NoYXIgfm9uXSB3b3JrcyBzaW1pbGFybHkgdG8gW1N0cmluZy5zcGxpdF9nZW5dLCB3aXRoIGFuXG4gICAgIGFkZGl0aW9uYWwgcmVxdWlyZW1lbnQ6IG9ubHkgc3BsaXQgb24gbGl0ZXJhbCBjaGFycywgbm90IGVzY2FwaW5nIG9yIGVzY2FwZWQgKilcbiAgbGV0IHNwbGl0X2dlbiBzdHIgfmVzY2FwZV9jaGFyIH5vbiA9XG4gICAgbGV0IGlzX2RlbGltID1cbiAgICAgIG1hdGNoIG9uIHdpdGhcbiAgICAgIHwgYGNoYXIgYycgLT4gZnVuIGMgLT4gQ2hhci5lcXVhbCBjIGMnXG4gICAgICB8IGBjaGFyX2xpc3QgbCAtPiBmdW4gYyAtPiBjaGFyX2xpc3RfbWVtIGwgY1xuICAgIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBzdHIgaW5cbiAgICBsZXQgcmVjIGxvb3AgYWNjIHN0YXR1cyBsYXN0X3BvcyBwb3MgPVxuICAgICAgaWYgcG9zID0gbGVuXG4gICAgICB0aGVuIExpc3QucmV2IChzdWIgc3RyIH5wb3M6bGFzdF9wb3MgfmxlbjoobGVuIC0gbGFzdF9wb3MpIDo6IGFjYylcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgc3RhdHVzID0gdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgc3RhdHVzIGluXG4gICAgICAgIGlmIChtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgICAgfCBgTGl0ZXJhbCAtPiB0cnVlXG4gICAgICAgICAgICB8IGBFc2NhcGVkIHwgYEVzY2FwaW5nIC0+IGZhbHNlKVxuICAgICAgICAgICAmJiBpc19kZWxpbSBzdHIuW3Bvc11cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHN1Yl9zdHIgPSBzdWIgc3RyIH5wb3M6bGFzdF9wb3MgfmxlbjoocG9zIC0gbGFzdF9wb3MpIGluXG4gICAgICAgICAgbG9vcCAoc3ViX3N0ciA6OiBhY2MpIHN0YXR1cyAocG9zICsgMSkgKHBvcyArIDEpKVxuICAgICAgICBlbHNlIGxvb3AgYWNjIHN0YXR1cyBsYXN0X3BvcyAocG9zICsgMSkpXG4gICAgaW5cbiAgICBsb29wIFtdIGBMaXRlcmFsIDAgMFxuICA7O1xuXG4gIGxldCBzcGxpdCBzdHIgfm9uID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyIG9uKVxuICBsZXQgc3BsaXRfb25fY2hhcnMgc3RyIH5vbjpjaGFycyA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhcl9saXN0IGNoYXJzKVxuXG4gIGxldCBzcGxpdF9hdCBzdHIgcG9zID1cbiAgICBzdWIgc3RyIH5wb3M6MCB+bGVuOnBvcywgc3ViIHN0ciB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW5ndGggc3RyIC0gcG9zIC0gMSlcbiAgOztcblxuICBsZXQgbHNwbGl0MiBzdHIgfm9uIH5lc2NhcGVfY2hhciA9XG4gICAgT3B0aW9uLm1hcCAoaW5kZXggc3RyIH5lc2NhcGVfY2hhciBvbikgfmY6KGZ1biB4IC0+IHNwbGl0X2F0IHN0ciB4KVxuICA7O1xuXG4gIGxldCByc3BsaXQyIHN0ciB+b24gfmVzY2FwZV9jaGFyID1cbiAgICBPcHRpb24ubWFwIChyaW5kZXggc3RyIH5lc2NhcGVfY2hhciBvbikgfmY6KGZ1biB4IC0+IHNwbGl0X2F0IHN0ciB4KVxuICA7O1xuXG4gIGxldCBsc3BsaXQyX2V4biBzdHIgfm9uIH5lc2NhcGVfY2hhciA9IHNwbGl0X2F0IHN0ciAoaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgb24pXG4gIGxldCByc3BsaXQyX2V4biBzdHIgfm9uIH5lc2NhcGVfY2hhciA9IHNwbGl0X2F0IHN0ciAocmluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIG9uKVxuXG4gICgqIFtsYXN0X25vbl9kcm9wX2xpdGVyYWxdIGFuZCBbZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbF0gYXJlIGVpdGhlciBib3RoIFtOb25lXSBvciBib3RoXG4gICAgIFtTb21lXS4gSWYgW1NvbWVdLCB0aGVuIHRoZSBmb3JtZXIgaXMgPj0gdGhlIGxhdHRlci4gKilcbiAgbGV0IGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB+ZHJvcCB+ZXNjYXBlX2NoYXIgdCA9XG4gICAgcmZpbmRpIHQgfmY6KGZ1biBpIGMgLT5cbiAgICAgIChub3QgKGRyb3AgYykpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwaW5nIHQgfmVzY2FwZV9jaGFyIGlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBlZCB0IH5lc2NhcGVfY2hhciBpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgfmRyb3AgfmVzY2FwZV9jaGFyIHQgPVxuICAgIGxmaW5kaSB0IH5mOihmdW4gaSBjIC0+XG4gICAgICAobm90IChkcm9wIGMpKVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGluZyB0IH5lc2NhcGVfY2hhciBpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwZWQgdCB+ZXNjYXBlX2NoYXIgaSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCByc3RyaXBfbGl0ZXJhbCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBsYXN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgfCBTb21lIGkgLT4gaWYgaSA9IGxlbmd0aCB0IC0gMSB0aGVuIHQgZWxzZSBwcmVmaXggdCAoaSArIDEpXG4gIDs7XG5cbiAgbGV0IGxzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgfCBTb21lIDAgLT4gdFxuICAgIHwgU29tZSBuIC0+IGRyb3BfcHJlZml4IHQgblxuICA7O1xuXG4gICgqIFtzdHJpcCB0XSBjb3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBbbHN0cmlwIChyc3RyaXAgdCldLiAgVGhlIGltcGxlbWVudGF0aW9uXG4gICAgIGJlbG93IHNhdmVzIChhdCBsZWFzdCkgYSBmYWN0b3Igb2YgdHdvIGFsbG9jYXRpb24sIGJ5IG9ubHkgYWxsb2NhdGluZyB0aGVcbiAgICAgZmluYWwgcmVzdWx0LiAgVGhpcyBhbHNvIHNhdmVzIHNvbWUgYW1vdW50IG9mIHRpbWUuICopXG4gIGxldCBzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICAgICgqIHBlcmZvcm1hbmNlIGhhY2s6IGF2b2lkIGNvcHlpbmcgW3RdIGluIGNvbW1vbiBjYXNlcyAqKVxuICAgIGlmIGxlbmd0aCA9IDAgfHwgbm90IChkcm9wIHQuWzBdIHx8IGRyb3AgdC5bbGVuZ3RoIC0gMV0pXG4gICAgdGhlbiB0XG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBmaXJzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgICB8IFNvbWUgZmlyc3QgLT5cbiAgICAgICAgKG1hdGNoIGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICB8IFNvbWUgbGFzdCAtPiBzdWIgdCB+cG9zOmZpcnN0IH5sZW46KGxhc3QgLSBmaXJzdCArIDEpKSlcbiAgOztcbmVuZFxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbigqIE92ZXJyaWRlIFtTZWFyY2hfcGF0dGVybl0gd2l0aCBkZWZhdWx0IGNhc2Utc2Vuc2l0aXZpdHkgYXJndW1lbnQgYXQgdGhlIGVuZCBvZiB0aGVcbiAgIGZpbGUsIHNvIHRoYXQgY2FsbCBzaXRlcyBhYm92ZSBhcmUgZm9yY2VkIHRvIHN1cHBseSBjYXNlLXNlbnNpdGl2aXR5IGV4cGxpY2l0bHkuICopXG5tb2R1bGUgU2VhcmNoX3BhdHRlcm4gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTZWFyY2hfcGF0dGVybjBcblxuICBsZXQgY3JlYXRlID8oY2FzZV9zZW5zaXRpdmUgPSB0cnVlKSBwYXR0ZXJuID0gY3JlYXRlIHBhdHRlcm4gfmNhc2Vfc2Vuc2l0aXZlXG5lbmRcblxubW9kdWxlIE1ha2VfdXRmIChGb3JtYXQgOiBzaWdcbiAgdmFsIGNvZGVjX25hbWUgOiBzdHJpbmdcbiAgdmFsIG1vZHVsZV9uYW1lIDogc3RyaW5nXG4gIHZhbCBpc192YWxpZCA6IHQgLT4gYm9vbFxuICB2YWwgYnl0ZV9sZW5ndGggOiBVY2hhci50IC0+IGludFxuICB2YWwgZ2V0X2RlY29kZV9yZXN1bHQgOiB0IC0+IGJ5dGVfcG9zOmludCAtPiBVY2hhci51dGZfZGVjb2RlXG4gIHZhbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gVWNoYXIudCAtPiBpbnRcbmVuZCkgPVxuc3RydWN0XG4gIHR5cGUgZWx0ID0gVWNoYXIudFxuICB0eXBlIHQgPSBzdHJpbmdcblxuICBsZXQgY29kZWNfbmFtZSA9IEZvcm1hdC5jb2RlY19uYW1lXG4gIGxldCBpc192YWxpZCA9IEZvcm1hdC5pc192YWxpZFxuXG4gIGxldCByYWlzZV9nZXRfbWVzc2FnZSA9XG4gICAgbGF6eVxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcIiVzLmdldDogaW52YWxpZCAlcyBlbmNvZGluZyBhdCBnaXZlbiBwb3NpdGlvblwiXG4gICAgICAgICBGb3JtYXQubW9kdWxlX25hbWVcbiAgICAgICAgIEZvcm1hdC5jb2RlY19uYW1lKVxuICA7O1xuXG4gIGxldFtAY29sZF0gcmFpc2VfZ2V0IHQgcG9zID1cbiAgICByYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlIChMYXp5LmZvcmNlIHJhaXNlX2dldF9tZXNzYWdlKSBbIFwiXCIsIEF0b20gdDsgXCJwb3NcIiwgc2V4cF9vZl9pbnQgcG9zIF0pXG4gIDs7XG5cbiAgbGV0IGdldCB0IH5ieXRlX3BvcyA9XG4gICAgKCogRXZlbiBpZiBbdF0gaXMgdmFsaWRhdGVkLCB3ZSBuZWVkIHRvIHZhbGlkYXRlIFtwb3NdLCBzbyB3ZSBjaGVjayB0aGUgZGVjb2RpbmcgKilcbiAgICBsZXQgZGVjb2RlID0gRm9ybWF0LmdldF9kZWNvZGVfcmVzdWx0IHQgfmJ5dGVfcG9zIGluXG4gICAgaWYgVWNoYXIudXRmX2RlY29kZV9pc192YWxpZCBkZWNvZGVcbiAgICB0aGVuIFVjaGFyLnV0Zl9kZWNvZGVfdWNoYXIgZGVjb2RlXG4gICAgZWxzZSByYWlzZV9nZXQgdCBieXRlX3Bvc1xuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSBGbi5pZFxuICBsZXQgb2Zfc3RyaW5nX3VuY2hlY2tlZCA9IEZuLmlkXG5cbiAgbGV0IHJhaXNlX29mX3N0cmluZ19tZXNzYWdlID1cbiAgICBjb25jYXQgWyBGb3JtYXQubW9kdWxlX25hbWU7IFwiLm9mX3N0cmluZzogaW52YWxpZCBcIjsgY29kZWNfbmFtZSBdXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9vZl9zdHJpbmcgc3RyaW5nID1cbiAgICByYWlzZV9zIChTZXhwLm1lc3NhZ2UgcmFpc2Vfb2Zfc3RyaW5nX21lc3NhZ2UgWyBcIlwiLCBBdG9tIHN0cmluZyBdKVxuICA7O1xuXG4gIGxldCBvZl9zdHJpbmcgc3RyaW5nID1cbiAgICBtYXRjaCBpc192YWxpZCBzdHJpbmcgd2l0aFxuICAgIHwgdHJ1ZSAtPiBzdHJpbmdcbiAgICB8IGZhbHNlIC0+IHJhaXNlX29mX3N0cmluZyBzdHJpbmdcbiAgOztcblxuICBpbmNsdWRlIFNleHBhYmxlLk9mX3N0cmluZ2FibGUgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBlbmQpXG5cbiAgaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgIGxldCBoYXNoID0gaGFzaFxuICAgIGxldCBoYXNoX2ZvbGRfdCA9IGhhc2hfZm9sZF90XG4gICAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gICAgbGV0IHRfb2Zfc2V4cCA9IHRfb2Zfc2V4cFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IEZvcm1hdC5tb2R1bGVfbmFtZVxuICBlbmQpXG5cbiAgbGV0IHRvX3NlcXVlbmNlIHQgPVxuICAgIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGQgfmluaXQ6MCB+ZjooZnVuIGJ5dGVfcG9zIC0+XG4gICAgICBpZiBieXRlX3BvcyA+PSBsZW5cbiAgICAgIHRoZW4gTm9uZVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBkZWNvZGUgPSBGb3JtYXQuZ2V0X2RlY29kZV9yZXN1bHQgdCB+Ynl0ZV9wb3MgaW5cbiAgICAgICAgU29tZSAoVWNoYXIudXRmX2RlY29kZV91Y2hhciBkZWNvZGUsIGJ5dGVfcG9zICsgVWNoYXIudXRmX2RlY29kZV9sZW5ndGggZGVjb2RlKSkpXG4gIDs7XG5cbiAgbGV0IGZvbGQgdCB+aW5pdDphY2MgfmYgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGxldCByZWMgbG9vcCBieXRlX3BvcyBhY2MgPVxuICAgICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBieXRlX3BvcyBsZW5cbiAgICAgIHRoZW4gYWNjXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGRlY29kZSA9IEZvcm1hdC5nZXRfZGVjb2RlX3Jlc3VsdCB0IH5ieXRlX3BvcyBpblxuICAgICAgICBsb29wXG4gICAgICAgICAgKGJ5dGVfcG9zICsgVWNoYXIudXRmX2RlY29kZV9sZW5ndGggZGVjb2RlKVxuICAgICAgICAgIChmIGFjYyAoVWNoYXIudXRmX2RlY29kZV91Y2hhciBkZWNvZGUpKSlcbiAgICBpblxuICAgIGxvb3AgMCBhY2MgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBzYW5pdGl6ZSB0ID1cbiAgICBsZXQgbGVuID0gZm9sZCB0IH5pbml0OjAgfmY6KGZ1biBwb3MgdWNoYXIgLT4gcG9zICsgRm9ybWF0LmJ5dGVfbGVuZ3RoIHVjaGFyKSBpblxuICAgIGxldCBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcG9zID0gZm9sZCB0IH5pbml0OjAgfmY6KGZ1biBwb3MgdWNoYXIgLT4gcG9zICsgRm9ybWF0LnNldCBieXRlcyBwb3MgdWNoYXIpIGluXG4gICAgYXNzZXJ0IChJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIHBvcyBsZW4pO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6Ynl0ZXNcbiAgOztcblxuICBsZXQgb2ZfbGlzdCB1Y2hhcnMgPVxuICAgIGxldCBsZW4gPSBMaXN0LmZvbGQgdWNoYXJzIH5pbml0OjAgfmY6KGZ1biBuIHUgLT4gbiArIEZvcm1hdC5ieXRlX2xlbmd0aCB1KSBpblxuICAgIGxldCBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcG9zID1cbiAgICAgIExpc3QuZm9sZCB1Y2hhcnMgfmluaXQ6MCB+ZjooZnVuIHBvcyB1Y2hhciAtPiBwb3MgKyBGb3JtYXQuc2V0IGJ5dGVzIHBvcyB1Y2hhcilcbiAgICBpblxuICAgIGFzc2VydCAoSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBwb3MgbGVuKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmJ5dGVzXG4gIDs7XG5cbiAgbGV0IG9mX2FycmF5IHVjaGFycyA9XG4gICAgbGV0IGxlbiA9IHJlZiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB1Y2hhcnMgLSAxIGRvXG4gICAgICBsZW4gOj0gIWxlbiArIEZvcm1hdC5ieXRlX2xlbmd0aCB1Y2hhcnMuKGkpXG4gICAgZG9uZTtcbiAgICBsZXQgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgIWxlbiBpblxuICAgIGxldCBwb3MgPSByZWYgMCBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdWNoYXJzIC0gMSBkb1xuICAgICAgcG9zIDo9ICFwb3MgKyBGb3JtYXQuc2V0IGJ5dGVzICFwb3MgdWNoYXJzLihpKVxuICAgIGRvbmU7XG4gICAgYXNzZXJ0IChJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsICFwb3MgIWxlbik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpieXRlc1xuICA7O1xuXG4gIGxldCBjb25jYXQgbGlzdCA9IGNvbmNhdCB+c2VwOlwiXCIgbGlzdFxuXG4gIGxldCBzcGxpdCB0IH5vbiA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgbG9vcCB+c3RhcnQgfnVudGlsID1cbiAgICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgdW50aWwgbGVuXG4gICAgICB0aGVuIFsgc3ViIHQgfnBvczpzdGFydCB+bGVuOih1bnRpbCAtIHN0YXJ0KSBdXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHVjaGFyID0gZ2V0IHQgfmJ5dGVfcG9zOnVudGlsIGluXG4gICAgICAgIGxldCBuZXh0ID0gdW50aWwgKyBGb3JtYXQuYnl0ZV9sZW5ndGggdWNoYXIgaW5cbiAgICAgICAgaWYgVWNoYXIuZXF1YWwgdWNoYXIgb25cbiAgICAgICAgdGhlbiBzdWIgdCB+cG9zOnN0YXJ0IH5sZW46KHVudGlsIC0gc3RhcnQpIDo6IGxvb3AgfnN0YXJ0Om5leHQgfnVudGlsOm5leHRcbiAgICAgICAgZWxzZSBsb29wIH5zdGFydCB+dW50aWw6bmV4dClcbiAgICBpblxuICAgIGxvb3AgfnN0YXJ0OjAgfnVudGlsOjAgW0Bub250YWlsXVxuICA7O1xuXG4gIG1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZTBfd2l0aF9jcmVhdG9ycyAoc3RydWN0XG4gICAgbW9kdWxlIEVsdCA9IFVjaGFyXG5cbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGNvbmNhdCA9IGNvbmNhdFxuICAgIGxldCBvZl9saXN0ID0gb2ZfbGlzdFxuICAgIGxldCBvZl9hcnJheSA9IG9mX2FycmF5XG4gICAgbGV0IGluaXQgPSBgRGVmaW5lX3VzaW5nX29mX2FycmF5XG4gICAgbGV0IGxlbmd0aCA9IGBEZWZpbmVfdXNpbmdfZm9sZFxuICAgIGxldCBmb2xkaSA9IGBEZWZpbmVfdXNpbmdfZm9sZFxuICAgIGxldCBpdGVyID0gYERlZmluZV91c2luZ19mb2xkXG4gICAgbGV0IGl0ZXJpID0gYERlZmluZV91c2luZ19mb2xkXG4gICAgbGV0IGNvbmNhdF9tYXBpID0gYERlZmluZV91c2luZ19jb25jYXRcbiAgZW5kKVxuXG4gIGxldCBhcHBlbmQgPSBDLmFwcGVuZFxuICBsZXQgY29uY2F0X21hcCA9IEMuY29uY2F0X21hcFxuICBsZXQgY29uY2F0X21hcGkgPSBDLmNvbmNhdF9tYXBpXG4gIGxldCBjb3VudCA9IEMuY291bnRcbiAgbGV0IGNvdW50aSA9IEMuY291bnRpXG4gIGxldCBleGlzdHMgPSBDLmV4aXN0c1xuICBsZXQgZXhpc3RzaSA9IEMuZXhpc3RzaVxuICBsZXQgZmlsdGVyID0gQy5maWx0ZXJcbiAgbGV0IGZpbHRlcl9tYXAgPSBDLmZpbHRlcl9tYXBcbiAgbGV0IGZpbHRlcl9tYXBpID0gQy5maWx0ZXJfbWFwaVxuICBsZXQgZmlsdGVyaSA9IEMuZmlsdGVyaVxuICBsZXQgZmluZCA9IEMuZmluZFxuICBsZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG4gIGxldCBmaW5kX21hcGkgPSBDLmZpbmRfbWFwaVxuICBsZXQgZmluZGkgPSBDLmZpbmRpXG4gIGxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbiAgbGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcbiAgbGV0IGZvbGRpID0gQy5mb2xkaVxuICBsZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxuICBsZXQgZm9yX2FsbGkgPSBDLmZvcl9hbGxpXG4gIGxldCBpbml0ID0gQy5pbml0XG4gIGxldCBpc19lbXB0eSA9IEMuaXNfZW1wdHlcbiAgbGV0IGl0ZXIgPSBDLml0ZXJcbiAgbGV0IGl0ZXJpID0gQy5pdGVyaVxuICBsZXQgbGVuZ3RoID0gQy5sZW5ndGhcbiAgbGV0IG1hcCA9IEMubWFwXG4gIGxldCBtYXBpID0gQy5tYXBpXG4gIGxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG4gIGxldCBtZW0gPSBDLm1lbVxuICBsZXQgbWluX2VsdCA9IEMubWluX2VsdFxuICBsZXQgcGFydGl0aW9uX21hcCA9IEMucGFydGl0aW9uX21hcFxuICBsZXQgcGFydGl0aW9uX3RmID0gQy5wYXJ0aXRpb25fdGZcbiAgbGV0IHN1bSA9IEMuc3VtXG4gIGxldCB0b19hcnJheSA9IEMudG9fYXJyYXlcbiAgbGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbiAgbGV0IGxlbmd0aF9pbl91Y2hhcnMgPSBsZW5ndGhcbmVuZFxuXG5tb2R1bGUgVXRmOCA9IE1ha2VfdXRmIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi04XCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlN0cmluZy5VdGY4XCJcbiAgbGV0IGlzX3ZhbGlkID0gaXNfdmFsaWRfdXRmXzhcbiAgbGV0IGJ5dGVfbGVuZ3RoID0gVWNoYXIudXRmXzhfYnl0ZV9sZW5ndGhcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gZ2V0X3V0Zl84X3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzhcbmVuZClcblxubW9kdWxlIFV0ZjE2bGUgPSBNYWtlX3V0ZiAoc3RydWN0XG4gIGxldCBjb2RlY19uYW1lID0gXCJVVEYtMTZMRVwiXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5TdHJpbmcuVXRmMTZsZVwiXG4gIGxldCBpc192YWxpZCA9IGlzX3ZhbGlkX3V0Zl8xNmxlXG4gIGxldCBieXRlX2xlbmd0aCA9IFVjaGFyLnV0Zl8xNl9ieXRlX2xlbmd0aFxuICBsZXQgZ2V0X2RlY29kZV9yZXN1bHQgPSBnZXRfdXRmXzE2bGVfdWNoYXJcbiAgbGV0IHNldCA9IEJ5dGVzLnNldF91Y2hhcl91dGZfMTZsZVxuZW5kKVxuXG5tb2R1bGUgVXRmMTZiZSA9IE1ha2VfdXRmIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0xNkJFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlN0cmluZy5VdGYxNmJlXCJcbiAgbGV0IGlzX3ZhbGlkID0gaXNfdmFsaWRfdXRmXzE2YmVcbiAgbGV0IGJ5dGVfbGVuZ3RoID0gVWNoYXIudXRmXzE2X2J5dGVfbGVuZ3RoXG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IGdldF91dGZfMTZiZV91Y2hhclxuICBsZXQgc2V0ID0gQnl0ZXMuc2V0X3VjaGFyX3V0Zl8xNmJlXG5lbmQpXG5cbm1vZHVsZSBNYWtlX3V0ZjMyIChGb3JtYXQgOiBzaWdcbiAgdmFsIGNvZGVjX25hbWUgOiBzdHJpbmdcbiAgdmFsIG1vZHVsZV9uYW1lIDogc3RyaW5nXG4gIHZhbCBnZXRfZGVjb2RlX3Jlc3VsdCA6IHQgLT4gYnl0ZV9wb3M6aW50IC0+IFVjaGFyLnV0Zl9kZWNvZGVcbiAgdmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBVY2hhci50IC0+IGludFxuZW5kKSA9XG5NYWtlX3V0ZiAoc3RydWN0XG4gIG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCBieXRlX2xlbmd0aCBfID0gNFxuICBsZXQgY29kZWNfbmFtZSA9IEZvcm1hdC5jb2RlY19uYW1lXG4gIGxldCBtb2R1bGVfbmFtZSA9IEZvcm1hdC5tb2R1bGVfbmFtZVxuICBsZXQgc2V0ID0gRm9ybWF0LnNldFxuICBsZXQgZ2V0X2RlY29kZV9yZXN1bHQgPSBGb3JtYXQuZ2V0X2RlY29kZV9yZXN1bHRcblxuICBsZXQgaXNfdmFsaWQgdCA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggdCBpblxuICAgIG1hdGNoIGxlbiBtb2QgNCB3aXRoXG4gICAgfCAwIC0+XG4gICAgICBsZXQgcmVjIGxvb3AgYnl0ZV9wb3MgPVxuICAgICAgICBtYXRjaCBieXRlX3BvcyA8IGxlbiB3aXRoXG4gICAgICAgIHwgZmFsc2UgLT4gdHJ1ZVxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICBsZXQgcmVzdWx0ID0gRm9ybWF0LmdldF9kZWNvZGVfcmVzdWx0IHQgfmJ5dGVfcG9zIGluXG4gICAgICAgICAgVWNoYXIudXRmX2RlY29kZV9pc192YWxpZCByZXN1bHQgJiYgbG9vcCAoYnl0ZV9wb3MgKyA0KVxuICAgICAgaW5cbiAgICAgIGxvb3AgMCBbQG5vbnRhaWxdXG4gICAgfCBfIC0+IGZhbHNlXG4gIDs7XG5lbmQpXG5cbm1vZHVsZSBVdGYzMmxlID0gTWFrZV91dGYzMiAoc3RydWN0XG4gIGxldCBjb2RlY19uYW1lID0gXCJVVEYtMzJMRVwiXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5TdHJpbmcuVXRmMzJsZVwiXG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IGdldF91dGZfMzJsZV91Y2hhclxuICBsZXQgc2V0ID0gQnl0ZXMuc2V0X3VjaGFyX3V0Zl8zMmxlXG5lbmQpXG5cbm1vZHVsZSBVdGYzMmJlID0gTWFrZV91dGYzMiAoc3RydWN0XG4gIGxldCBjb2RlY19uYW1lID0gXCJVVEYtMzJCRVwiXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5TdHJpbmcuVXRmMzJiZVwiXG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IGdldF91dGZfMzJiZV91Y2hhclxuICBsZXQgc2V0ID0gQnl0ZXMuc2V0X3VjaGFyX3V0Zl8zMmJlXG5lbmQpXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuaW5jbHVkZSBCeXRlc19pbnRmXG5cbmxldCBzdGFnZSA9IFN0YWdlZC5zdGFnZVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBieXRlcyBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9ieXRlcyA6IHQgLT4gdClcbiAgbGV0IHRfb2Zfc2V4cCA9IChieXRlc19vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9ieXRlcyA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBieXRlc19zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQnl0ZXMwXG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkJ5dGVzXCJcbiAgbGV0IHBwIGZtdCB0ID0gU3RkbGliLkZvcm1hdC5mcHJpbnRmIGZtdCBcIiVTXCIgKHRvX3N0cmluZyB0KVxuZW5kXG5cbmluY2x1ZGUgVFxuXG5tb2R1bGUgVG9fYnl0ZXMgPSBCbGl0Lk1ha2UgKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgY3JlYXRlIH5sZW4gPSBjcmVhdGUgbGVuXG5lbmQpXG5cbmluY2x1ZGUgVG9fYnl0ZXNcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoVClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgQnl0ZXNfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5tb2R1bGUgVG9fc3RyaW5nID0gQmxpdC5NYWtlX3RvX3N0cmluZyAoVCkgKFRvX2J5dGVzKVxuXG5tb2R1bGUgRnJvbV9zdHJpbmcgPVxuICBCbGl0Lk1ha2VfZGlzdGluY3RcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBzdHJpbmdcblxuICAgICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGhcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgbGV0IGNyZWF0ZSB+bGVuID0gY3JlYXRlIGxlblxuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRfc3RyaW5nXG4gICAgZW5kKVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuXG5sZXQgaW5pdCBuIH5mID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBuIDBcbiAgdGhlbiBQcmludGYuaW52YWxpZF9hcmdmIFwiQnl0ZXMuaW5pdCAlZFwiIG4gKCk7XG4gIGxldCB0ID0gY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCB0IGkgKGYgaSlcbiAgZG9uZTtcbiAgdFxuOztcblxubGV0IG9mX2NoYXJfbGlzdCBsID1cbiAgbGV0IHQgPSBjcmVhdGUgKExpc3QubGVuZ3RoIGwpIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgYyAtPiBzZXQgdCBpIGMpO1xuICB0XG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbGV0IHJlYyBsb29wIHQgaSBhY2MgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgaSAwXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIGxvb3AgdCAoaSAtIDEpICh1bnNhZmVfZ2V0IHQgaSA6OiBhY2MpXG4gIGluXG4gIGxvb3AgdCAobGVuZ3RoIHQgLSAxKSBbXVxuOztcblxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IChsZW5ndGggdCkgfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxubGV0IG1hcCB0IH5mID0gbWFwIHQgfmZcbmxldCBtYXBpIHQgfmYgPSBtYXBpIHQgfmZcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGxvb3AgdCB+ZiB+bGVuIH5wb3MgYWNjID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIHBvcyBsZW5cbiAgICB0aGVuIGFjY1xuICAgIGVsc2UgbG9vcCB0IH5mIH5sZW4gfnBvczoocG9zICsgMSkgKGYgYWNjICh1bnNhZmVfZ2V0IHQgcG9zKSlcbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IH5mIH5sZW46KGxlbmd0aCB0KSB+cG9zOjAgaW5pdFxuOztcblxubGV0IGZvbGRpID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgfmxlbiB+cG9zIGFjYyA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBwb3MgbGVuXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIGxvb3AgdCB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpIChmIHBvcyBhY2MgKHVuc2FmZV9nZXQgdCBwb3MpKVxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgfmYgfmxlbjoobGVuZ3RoIHQpIH5wb3M6MCBpbml0XG47O1xuXG5sZXQgdHIgfnRhcmdldCB+cmVwbGFjZW1lbnQgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHMgaSkgdGFyZ2V0IHRoZW4gdW5zYWZlX3NldCBzIGkgcmVwbGFjZW1lbnRcbiAgZG9uZVxuOztcblxubGV0IHRyX211bHRpIH50YXJnZXQgfnJlcGxhY2VtZW50ID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoU3RyaW5nLmxlbmd0aCB0YXJnZXQpIDBcbiAgdGhlbiBzdGFnZSBpZ25vcmVcbiAgZWxzZSBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChTdHJpbmcubGVuZ3RoIHJlcGxhY2VtZW50KSAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJ0cl9tdWx0aTogcmVwbGFjZW1lbnQgaXMgdGhlIGVtcHR5IHN0cmluZ1wiXG4gIGVsc2UgKFxuICAgIG1hdGNoIEJ5dGVzX3RyLnRyX2NyZWF0ZV9tYXAgfnRhcmdldCB+cmVwbGFjZW1lbnQgd2l0aFxuICAgIHwgTm9uZSAtPiBzdGFnZSBpZ25vcmVcbiAgICB8IFNvbWUgdHJfbWFwIC0+XG4gICAgICBzdGFnZSAoZnVuIHMgLT5cbiAgICAgICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgcyBpIChTdHJpbmcudW5zYWZlX2dldCB0cl9tYXAgKENoYXIudG9faW50ICh1bnNhZmVfZ2V0IHMgaSkpKVxuICAgICAgICBkb25lKSlcbjs7XG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCBjb250YWlucyA/cG9zID9sZW4gdCBjaGFyID1cbiAgbGV0IHBvcywgbGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHQpXG4gIGluXG4gIGxldCBsYXN0ID0gcG9zICsgbGVuIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGkgbGFzdFxuICAgICYmIChDaGFyLmVxdWFsIChnZXQgdCBpKSBjaGFyIHx8IGxvb3AgKGkgKyAxKSlcbiAgaW5cbiAgbG9vcCBwb3Ncbjs7XG5cbm1vZHVsZSBVdGY4ID0gc3RydWN0XG4gIGxldCBzZXQgPSBzZXRfdWNoYXJfdXRmXzhcbmVuZFxuXG5tb2R1bGUgVXRmMTZsZSA9IHN0cnVjdFxuICBsZXQgc2V0ID0gc2V0X3VjaGFyX3V0Zl8xNmxlXG5lbmRcblxubW9kdWxlIFV0ZjE2YmUgPSBzdHJ1Y3RcbiAgbGV0IHNldCA9IHNldF91Y2hhcl91dGZfMTZiZVxuZW5kXG5cbm1vZHVsZSBVdGYzMmxlID0gc3RydWN0XG4gIGxldCBzZXQgPSBzZXRfdWNoYXJfdXRmXzMybGVcbmVuZFxuXG5tb2R1bGUgVXRmMzJiZSA9IHN0cnVjdFxuICBsZXQgc2V0ID0gc2V0X3VjaGFyX3V0Zl8zMmJlXG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwiIyAxIFwic3JjL2hleF9sZXhlci5tbGxcIlxuIFxudHlwZSByZXN1bHQgPVxufCBOZWcgb2Ygc3RyaW5nXG58IFBvcyBvZiBzdHJpbmdcblxuIyA4IFwic3JjL2hleF9sZXhlci5tbFwiXG5sZXQgX19vY2FtbF9sZXhfdGFibGVzID0ge1xuICBMZXhpbmcubGV4X2Jhc2UgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDBcXDAwMVxcMDAwXFwwMDJcXDAwMFxcMDI3XFwwMDBcXDA4MlxcMDAwXFwxMDVcXDAwMFxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfYmFja3RyayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMVxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0ID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X3RyYW5zID1cbiAgIFwiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA0XFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcIjtcbiAgTGV4aW5nLmxleF9jaGVjayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAxXFwwMDBcXDAwM1xcMDAwXFwwMDVcXDAwMFxcMjU1XFwyNTVcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XCI7XG4gIExleGluZy5sZXhfYmFzZV9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfYmFja3Rya19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfZGVmYXVsdF9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfdHJhbnNfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NoZWNrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jb2RlID1cbiAgIFwiXCI7XG59XG5cbmxldCByZWMgcGFyc2VfaGV4IGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiAwXG5hbmQgX19vY2FtbF9sZXhfcGFyc2VfaGV4X3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG5sZXRcbiMgOCBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlcbiMgMTM1IFwic3JjL2hleF9sZXhlci5tbFwiXG49IExleGluZy5zdWJfbGV4ZW1lIGxleGJ1ZiAobGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcG9zICsgMykgbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wb3MgaW5cbiMgMTQgXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggTmVnIGJvZHkgKVxuIyAxMzkgXCJzcmMvaGV4X2xleGVyLm1sXCJcblxuICB8IDEgLT5cbmxldFxuIyA4IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keVxuIyAxNDUgXCJzcmMvaGV4X2xleGVyLm1sXCJcbj0gTGV4aW5nLnN1Yl9sZXhlbWUgbGV4YnVmIChsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgKyAyKSBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3BvcyBpblxuIyAxNSBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBQb3MgYm9keSApXG4jIDE0OSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG47O1xuXG4iLCJvcGVuISBJbXBvcnRcblxuKCogc3RyaW5nIGNvbnZlcnNpb25zICopXG5cbmxldCBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IGlucHV0IH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXIgPVxuICBsZXQgaW5wdXRfbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCBpbnB1dCBpblxuICBpZiBpbnB1dF9sZW5ndGggPD0gY2hhcnNfcGVyX2RlbGltaXRlclxuICB0aGVuIGlucHV0XG4gIGVsc2UgKFxuICAgIGxldCBoYXNfc2lnbiA9XG4gICAgICBtYXRjaCBpbnB1dC5bMF0gd2l0aFxuICAgICAgfCAnKycgfCAnLScgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgbnVtX2RpZ2l0cyA9IGlmIGhhc19zaWduIHRoZW4gaW5wdXRfbGVuZ3RoIC0gMSBlbHNlIGlucHV0X2xlbmd0aCBpblxuICAgIGxldCBudW1fZGVsaW1pdGVycyA9IChudW1fZGlnaXRzIC0gMSkgLyBjaGFyc19wZXJfZGVsaW1pdGVyIGluXG4gICAgbGV0IG91dHB1dF9sZW5ndGggPSBpbnB1dF9sZW5ndGggKyBudW1fZGVsaW1pdGVycyBpblxuICAgIGxldCBvdXRwdXQgPSBCeXRlcy5jcmVhdGUgb3V0cHV0X2xlbmd0aCBpblxuICAgIGxldCBpbnB1dF9wb3MgPSByZWYgKGlucHV0X2xlbmd0aCAtIDEpIGluXG4gICAgbGV0IG91dHB1dF9wb3MgPSByZWYgKG91dHB1dF9sZW5ndGggLSAxKSBpblxuICAgIGxldCBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyID0gcmVmIGNoYXJzX3Blcl9kZWxpbWl0ZXIgaW5cbiAgICBsZXQgZmlyc3RfZGlnaXRfcG9zID0gaWYgaGFzX3NpZ24gdGhlbiAxIGVsc2UgMCBpblxuICAgIHdoaWxlICFpbnB1dF9wb3MgPj0gZmlyc3RfZGlnaXRfcG9zIGRvXG4gICAgICBpZiAhbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0cHV0ICFvdXRwdXRfcG9zIGRlbGltaXRlcjtcbiAgICAgICAgZGVjciBvdXRwdXRfcG9zO1xuICAgICAgICBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyIDo9IGNoYXJzX3Blcl9kZWxpbWl0ZXIpO1xuICAgICAgQnl0ZXMuc2V0IG91dHB1dCAhb3V0cHV0X3BvcyBpbnB1dC5bIWlucHV0X3Bvc107XG4gICAgICBkZWNyIGlucHV0X3BvcztcbiAgICAgIGRlY3Igb3V0cHV0X3BvcztcbiAgICAgIGRlY3IgbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlclxuICAgIGRvbmU7XG4gICAgaWYgaGFzX3NpZ24gdGhlbiBCeXRlcy5zZXQgb3V0cHV0IDAgaW5wdXQuWzBdO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0cHV0KVxuOztcblxubGV0IGluc2VydF9kZWxpbWl0ZXIgaW5wdXQgfmRlbGltaXRlciA9XG4gIGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgaW5wdXQgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlcjozXG47O1xuXG5sZXQgaW5zZXJ0X3VuZGVyc2NvcmVzIGlucHV0ID0gaW5zZXJ0X2RlbGltaXRlciBpbnB1dCB+ZGVsaW1pdGVyOidfJ1xubGV0IHNleHBfb2ZfaW50X3N0eWxlID0gU2V4cC5vZl9pbnRfc3R5bGVcblxubW9kdWxlIE1ha2UgKEkgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG5lbmQpID1cbnN0cnVjdFxuICBvcGVuIElcblxuICBsZXQgY2hhcnNfcGVyX2RlbGltaXRlciA9IDNcblxuICBsZXQgdG9fc3RyaW5nX2h1bSA/KGRlbGltaXRlciA9ICdfJykgdCA9XG4gICAgaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAodG9fc3RyaW5nIHQpIH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPVxuICAgIGxldCBzID0gdG9fc3RyaW5nIHQgaW5cbiAgICBTZXhwLkF0b21cbiAgICAgIChtYXRjaCAhc2V4cF9vZl9pbnRfc3R5bGUgd2l0aFxuICAgICAgIHwgYFVuZGVyc2NvcmVzIC0+IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgcyB+Y2hhcnNfcGVyX2RlbGltaXRlciB+ZGVsaW1pdGVyOidfJ1xuICAgICAgIHwgYE5vX3VuZGVyc2NvcmVzIC0+IHMpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2VfaGV4IChJIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGhhc2hdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TX2xvY2FsIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgW0BAQGVuZF1cblxuICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgdmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgKCA8ICkgOiB0IC0+IHQgLT4gYm9vbFxuICB2YWwgbmVnIDogdCAtPiB0XG4gIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFRfaGV4ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gSS50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlX19sb2NhbCA9IChJLmNvbXBhcmVfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgICBsZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBJLmhhc2hfZm9sZF90XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IEkuaGFzaCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY2hhcnNfcGVyX2RlbGltaXRlciA9IDRcblxuICAgIGxldCB0b19zdHJpbmcnID9kZWxpbWl0ZXIgdCA9XG4gICAgICBsZXQgbWFrZV9zdWZmaXggPVxuICAgICAgICBtYXRjaCBkZWxpbWl0ZXIgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gSS50b19zdHJpbmdcbiAgICAgICAgfCBTb21lIGRlbGltaXRlciAtPlxuICAgICAgICAgIGZ1biB0IC0+IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgKEkudG9fc3RyaW5nIHQpIH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgICAgIGluXG4gICAgICBpZiBJLiggPCApIHQgSS56ZXJvIHRoZW4gXCItMHhcIiBeIG1ha2Vfc3VmZml4IChJLm5lZyB0KSBlbHNlIFwiMHhcIiBeIG1ha2Vfc3VmZml4IHRcbiAgICA7O1xuXG4gICAgbGV0IHRvX3N0cmluZyB0ID0gdG9fc3RyaW5nJyB0ID9kZWxpbWl0ZXI6Tm9uZVxuICAgIGxldCB0b19zdHJpbmdfaHVtID8oZGVsaW1pdGVyID0gJ18nKSB0ID0gdG9fc3RyaW5nJyB0IH5kZWxpbWl0ZXJcblxuICAgIGxldCBpbnZhbGlkIHN0ciA9XG4gICAgICBQcmludGYuZmFpbHdpdGhmIFwiJXMub2Zfc3RyaW5nOiBpbnZhbGlkIGlucHV0ICVTXCIgSS5tb2R1bGVfbmFtZSBzdHIgKClcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBzdHIgPVxuICAgICAgSS5vZl9zdHJpbmcgKFN0cmluZy5maWx0ZXIgc3RyIH5mOihmdW4gYyAtPiBDaGFyLiggPD4gKSBjICdfJykpXG4gICAgOztcblxuICAgIGxldCBvZl9zdHJpbmcgc3RyID1cbiAgICAgIGxldCBtb2R1bGUgTCA9IEhleF9sZXhlciBpblxuICAgICAgbGV0IGxleCA9IFN0ZGxpYi5MZXhpbmcuZnJvbV9zdHJpbmcgc3RyIGluXG4gICAgICBsZXQgcmVzdWx0ID0gT3B0aW9uLnRyeV93aXRoIChmdW4gKCkgLT4gTC5wYXJzZV9oZXggbGV4KSBpblxuICAgICAgaWYgbGV4LmxleF9jdXJyX3BvcyA9IGxleC5sZXhfYnVmZmVyX2xlblxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBpbnZhbGlkIHN0clxuICAgICAgICB8IFNvbWUgKE5lZyBib2R5KSAtPiBJLm5lZyAob2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIGJvZHkpXG4gICAgICAgIHwgU29tZSAoUG9zIGJvZHkpIC0+IG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBib2R5KVxuICAgICAgZWxzZSBpbnZhbGlkIHN0clxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBIZXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRfaGV4XG4gICAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zdHJpbmdhYmxlIChUX2hleClcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2VfYmluYXJ5IChJIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlNfbG9jYWwgd2l0aCB0eXBlIHQgOj0gdFxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuU19sb2NhbCB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgUHB4X2hhc2hfbGliLkhhc2hhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIFtAQEBlbmRdXG5cbiAgdmFsIGNseiA6IHQgLT4gaW50XG4gIHZhbCAoIGxzciApIDogdCAtPiBpbnQgLT4gdFxuICB2YWwgKCBsYW5kICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgdG9faW50X2V4biA6IHQgLT4gaW50XG4gIHZhbCBudW1fYml0cyA6IGludFxuICB2YWwgemVybyA6IHRcbiAgdmFsIG9uZSA6IHRcbmVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBCaW5hcnkgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBJLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKEkuY29tcGFyZV9fbG9jYWwgOiB0IC0+IHQgLT4gaW50KVxuICAgIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIEkuaGFzaF9mb2xkX3RcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gSS5oYXNoIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBiaXRzIHQgPSBpZiBJLmVxdWFsX19sb2NhbCB0IEkuemVybyB0aGVuIDAgZWxzZSBJLm51bV9iaXRzIC0gSS5jbHogdFxuXG4gICAgbGV0IHRvX3N0cmluZ19zdWZmaXggKHQgOiB0KSA9XG4gICAgICBsZXQgYml0cyA9IGJpdHMgdCBpblxuICAgICAgaWYgYml0cyA9IDBcbiAgICAgIHRoZW4gXCIwXCJcbiAgICAgIGVsc2VcbiAgICAgICAgU3RyaW5nLmluaXQgYml0cyB+ZjooZnVuIGNoYXJfaW5kZXggLT5cbiAgICAgICAgICBsZXQgYml0X2luZGV4ID0gYml0cyAtIGNoYXJfaW5kZXggLSAxIGluXG4gICAgICAgICAgbGV0IGJpdCA9IEkuKCh0IGxzciBiaXRfaW5kZXgpIGxhbmQgb25lKSBpblxuICAgICAgICAgIENoYXIudW5zYWZlX29mX2ludCAoQ2hhci50b19pbnQgJzAnICsgSS50b19pbnRfZXhuIGJpdCkpXG4gICAgOztcblxuICAgIGxldCB0b19zdHJpbmcgKHQgOiB0KSA9IFwiMGJcIiBeIHRvX3N0cmluZ19zdWZmaXggdFxuXG4gICAgbGV0IHRvX3N0cmluZ19odW0gPyhkZWxpbWl0ZXIgPSAnXycpIHQgPVxuICAgICAgXCIwYlwiIF4gaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAodG9fc3RyaW5nX3N1ZmZpeCB0KSB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyOjRcbiAgICA7O1xuXG4gICAgbGV0IHNleHBfb2ZfdCAodCA6IHQpIDogU2V4cC50ID0gQXRvbSAodG9fc3RyaW5nX2h1bSB0KVxuICBlbmRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbigqIEMgc3R1YiBmb3IgaW50IHBvcGNvdW50IHRvIHVzZSB0aGUgUE9QQ05UIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG5leHRlcm5hbCBpbnRfcG9wY291bnQgOiBpbnQgLT4gaW50ID0gXCJCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudFwiIFtAQG5vYWxsb2NdXG5cbigqIFRvIG1haW50YWluIGphdmFzY3JpcHQgY29tcGF0aWJpbGl0eSBhbmQgZW5hYmxlIHVuYm94aW5nLCB3ZSBpbXBsZW1lbnQgcG9wY291bnQgaW5cbiAgIE9DYW1sIHJhdGhlciB0aGFuIHVzZSBDIHN0dWJzLiBJbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb206XG4gICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYW1taW5nX3dlaWdodCNFZmZpY2llbnRfaW1wbGVtZW50YXRpb24gKilcbmxldCBpbnQ2NF9wb3Bjb3VudCA9XG4gIGxldCBvcGVuIFN0ZGxpYi5JbnQ2NCBpblxuICBsZXQgKCArICkgPSBhZGQgaW5cbiAgbGV0ICggLSApID0gc3ViIGluXG4gIGxldCAoICogKSA9IG11bCBpblxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgaW5cbiAgbGV0ICggbGFuZCApID0gbG9nYW5kIGluXG4gIGxldCBtMSA9IDB4NTU1NTU1NTU1NTU1NTU1NUwgaW5cbiAgKCogMGIwMTAxMDEwMS4uLiAqKVxuICBsZXQgbTIgPSAweDMzMzMzMzMzMzMzMzMzMzNMIGluXG4gICgqIDBiMDAxMTAwMTEuLi4gKilcbiAgbGV0IG00ID0gMHgwZjBmMGYwZjBmMGYwZjBmTCBpblxuICAoKiAwYjAwMDAxMTExLi4uICopXG4gIGxldCBoMDEgPSAweDAxMDEwMTAxMDEwMTAxMDFMIGluXG4gICgqIDEgYml0IHNldCBwZXIgYnl0ZSAqKVxuICBmdW4gW0BpbmxpbmVdIHggLT5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgcGFpciBvZiBiaXRzICopXG4gICAgbGV0IHggPSB4IC0gKCh4IGxzciAxKSBsYW5kIG0xKSBpblxuICAgICgqIGdhdGhlciB0aGUgYml0IGNvdW50IGZvciBldmVyeSA0IGJpdHMgKilcbiAgICBsZXQgeCA9ICh4IGxhbmQgbTIpICsgKCh4IGxzciAyKSBsYW5kIG0yKSBpblxuICAgICgqIGdhdGhlciB0aGUgYml0IGNvdW50IGZvciBldmVyeSBieXRlICopXG4gICAgbGV0IHggPSAoeCArICh4IGxzciA0KSkgbGFuZCBtNCBpblxuICAgICgqIHN1bSB0aGUgYml0IGNvdW50cyBpbiB0aGUgdG9wIGJ5dGUgYW5kIHNoaWZ0IGl0IGRvd24gKilcbiAgICB0b19pbnQgKCh4ICogaDAxKSBsc3IgNTYpXG47O1xuXG5sZXQgaW50MzJfcG9wY291bnQgPVxuICAoKiBPbiA2NC1iaXQgc3lzdGVtcywgdGhpcyBpcyBmYXN0ZXIgdGhhbiBpbXBsZW1lbnRpbmcgdXNpbmcgW2ludDMyXSBhcml0aG1ldGljLiAqKVxuICBsZXQgbWFzayA9IDB4ZmZmZl9mZmZmTCBpblxuICBmdW4gW0BpbmxpbmVdIHggLT4gaW50NjRfcG9wY291bnQgKFN0ZGxpYi5JbnQ2NC5sb2dhbmQgKFN0ZGxpYi5JbnQ2NC5vZl9pbnQzMiB4KSBtYXNrKVxuOztcblxubGV0IG5hdGl2ZWludF9wb3Bjb3VudCA9XG4gIG1hdGNoIFN0ZGxpYi5OYXRpdmVpbnQuc2l6ZSB3aXRoXG4gIHwgMzIgLT4gZnVuIFtAaW5saW5lXSB4IC0+IGludDMyX3BvcGNvdW50IChTdGRsaWIuTmF0aXZlaW50LnRvX2ludDMyIHgpXG4gIHwgNjQgLT4gZnVuIFtAaW5saW5lXSB4IC0+IGludDY0X3BvcGNvdW50IChTdGRsaWIuSW50NjQub2ZfbmF0aXZlaW50IHgpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU2lnbjBcbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKFNpZ24wKVxuXG4oKiBPcGVuIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9ucyBzb1xuICAgdGhleSBkbyBub3Qgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zXG4gICBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IHRvX3N0cmluZ19odW0gPSBmdW5jdGlvblxuICB8IE5lZyAtPiBcIm5lZ2F0aXZlXCJcbiAgfCBaZXJvIC0+IFwiemVyb1wiXG4gIHwgUG9zIC0+IFwicG9zaXRpdmVcIlxuOztcblxubGV0IHRvX2Zsb2F0ID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gLTEuXG4gIHwgWmVybyAtPiAwLlxuICB8IFBvcyAtPiAxLlxuOztcblxubGV0IGZsaXAgPSBmdW5jdGlvblxuICB8IE5lZyAtPiBQb3NcbiAgfCBaZXJvIC0+IFplcm9cbiAgfCBQb3MgLT4gTmVnXG47O1xuXG5sZXQgKCAqICkgdCB0JyA9IG9mX2ludCAodG9faW50IHQgKiB0b19pbnQgdCcpXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGF0IHRoZSBlbmQsIGFmdGVyIGFueVxuICAgZnVuY3RvciBhcHBsaWNhdGlvbnMgdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc29cbiAgIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpc1xuICAgbW9kdWxlLiAqKVxuaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnRfaW50ZlxuaW5jbHVkZSBJbnQwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9pbnQgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoaW50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlIHggeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZSB4IHlcblxuICBsZXQgb2Zfc3RyaW5nIHMgPVxuICAgIHRyeSBvZl9zdHJpbmcgcyB3aXRoXG4gICAgfCBfIC0+IFByaW50Zi5mYWlsd2l0aGYgXCJJbnQub2Zfc3RyaW5nOiAlU1wiIHMgKClcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG5lbmRcblxubGV0IG51bV9iaXRzID0gSW50X2NvbnZlcnNpb25zLm51bV9iaXRzX2ludFxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgdG9fZmxvYXQgPSBTdGRsaWIuZmxvYXRfb2ZfaW50XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gU3RkbGliLmludF9vZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAgICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBTdGRsaWIuaW50X29mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50Lm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5sZXQgemVybyA9IDBcbmxldCBvbmUgPSAxXG5sZXQgbWludXNfb25lID0gLTFcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCB6ZXJvID0gemVyb1xuZW5kKVxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2UgKFQpXG5cbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlX2hleCAoc3RydWN0XG4gIG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGhhc2hdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKGNvbXBhcmVfaW50X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG5lZyA9ICggfi0gKVxuICBsZXQgKCA8ICkgPSAoIDwgKVxuICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiV4XCIgaVxuICBsZXQgb2Zfc3RyaW5nIHMgPSBTdGRsaWIuU2NhbmYuc3NjYW5mIHMgXCIleFwiIEZuLmlkXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQuSGV4XCJcbmVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50XCJcbmVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc29cbiAgIHRoZXkgZG8gbm90IHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbjptaW5fIH5tYXg6bWF4XyA9IG1pbiB0IG1heF8gfD4gbWF4IG1pbl9cblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmV4dGVybmFsIHRvX2ludDMyX3RydW5jIDogKHRbQGxvY2FsX29wdF0pIC0+IChpbnQzMltAbG9jYWxfb3B0XSkgPSBcIiVpbnQzMl9vZl9pbnRcIlxuZXh0ZXJuYWwgb2ZfaW50MzJfdHJ1bmMgOiAoaW50MzJbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVpbnQzMl90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfaW50NjRfdHJ1bmMgOiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50X3RydW5jIDogKG5hdGl2ZWludFtAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuXG5sZXQgcHJlZCBpID0gaSAtIDFcbmxldCBzdWNjIGkgPSBpICsgMVxubGV0IHRvX2ludCBpID0gaVxubGV0IHRvX2ludF9leG4gPSB0b19pbnRcbmxldCBvZl9pbnQgaSA9IGlcbmxldCBvZl9pbnRfZXhuID0gb2ZfaW50XG5sZXQgbWF4X3ZhbHVlID0gU3RkbGliLm1heF9pbnRcbmxldCBtaW5fdmFsdWUgPSBTdGRsaWIubWluX2ludFxubGV0IG1heF92YWx1ZV8zMF9iaXRzID0gMHgzRkZGX0ZGRkZcbmxldCBvZl9pbnQzMiA9IENvbnYuaW50MzJfdG9faW50XG5sZXQgb2ZfaW50MzJfZXhuID0gQ29udi5pbnQzMl90b19pbnRfZXhuXG5sZXQgdG9faW50MzIgPSBDb252LmludF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYuaW50X3RvX2ludDMyX2V4blxubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19pbnRcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX2ludF9leG5cbmxldCB0b19pbnQ2NCA9IENvbnYuaW50X3RvX2ludDY0XG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50XG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludF9leG5cbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludF90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgYWJzIHggPSBhYnMgeFxuXG4oKiBub3RlIHRoYXQgcmVtIGlzIG5vdCBzYW1lIGFzICUgKilcbmxldCByZW0gYSBiID0gYSBtb2QgYlxubGV0IGluY3IgPSBTdGRsaWIuaW5jclxubGV0IGRlY3IgPSBTdGRsaWIuZGVjclxubGV0IHNoaWZ0X3JpZ2h0IGEgYiA9IGEgYXNyIGJcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsIGEgYiA9IGEgbHNyIGJcbmxldCBzaGlmdF9sZWZ0IGEgYiA9IGEgbHNsIGJcbmxldCBiaXRfbm90IGEgPSBsbm90IGFcbmxldCBiaXRfb3IgYSBiID0gYSBsb3IgYlxubGV0IGJpdF9hbmQgYSBiID0gYSBsYW5kIGJcbmxldCBiaXRfeG9yIGEgYiA9IGEgbHhvciBiXG5sZXQgcG93ID0gSW50X21hdGguUHJpdmF0ZS5pbnRfcG93XG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IC0gMSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgKCogVGhlIG5leHQgbGluZSBpcyBzdXBlcmZsdW91cyBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgZmFzdGVyIHRvIGRvIGl0XG4gICAgICAgYW55d2F5IHRoYW4gdG8gYnJhbmNoICopXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgeCArIDFcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gMCB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIHggLSAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kICh4IC0gMSkgPSAwXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogICgqIE5vdGUgdGhhdCB3ZSBwYXNzIHRoZSB0YWdnZWQgaW50IGhlcmUuIFNlZSBpbnRfbWF0aF9zdHVicy5jIGZvciBkZXRhaWxzIG9uIHdoeVxuICAgICAgICAgIHRoaXMgaXMgY29ycmVjdC4gKilcbiAgICAgICBpbnRcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50X2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnRfY2x6X3VudGFnZ2VkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChpbnRbQHVudGFnZ2VkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9pbnRfY3R6X3VudGFnZ2VkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBpIDw9IDBcbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQgaSBdKTtcbiAgICBpZiBpID0gMSB0aGVuIDAgZWxzZSBudW1fYml0cyAtIGNseiAoaSAtIDEpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5cbmxldCBzaWduID0gU2lnbi5vZl9pbnRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludF9wb3Bjb3VudFxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9iaW5hcnkgKHN0cnVjdFxuICB0eXBlIHQgPSBpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGhhc2hdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKGNvbXBhcmVfaW50X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGVxdWFsX19sb2NhbCA9IChlcXVhbF9pbnRfX2xvY2FsIDogdCAtPiB0IC0+IGJvb2wpXG4gIGxldCBlcXVhbCA9IChmdW4gYSBiIC0+IGVxdWFsX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgKCBsYW5kICkgPSAoIGxhbmQgKVxuICBsZXQgKCBsc3IgKSA9ICggbHNyIClcbiAgbGV0IGNseiA9IGNselxuICBsZXQgbnVtX2JpdHMgPSBudW1fYml0c1xuICBsZXQgb25lID0gb25lXG4gIGxldCB0b19pbnRfZXhuID0gdG9faW50X2V4blxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGV4dGVybmFsICggKyApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlYWRkaW50XCJcbiAgZXh0ZXJuYWwgKCAtICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVzdWJpbnRcIlxuICBleHRlcm5hbCAoICogKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJW11bGludFwiXG4gIGV4dGVybmFsICggLyApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlZGl2aW50XCJcbiAgZXh0ZXJuYWwgKCB+LSApIDogKHRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVuZWdpbnRcIlxuXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYWJzID0gYWJzXG5cbiAgZXh0ZXJuYWwgbmVnIDogKHRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVuZWdpbnRcIlxuXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgbW9kdWxlIEYgPSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgbGV0IHJlbSA9IHJlbVxuICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgZW5kKVxuXG4gIGluY2x1ZGUgRlxuXG4gIGV4dGVybmFsIGJzd2FwMTYgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVic3dhcDE2XCJcblxuICAoKiBUaGVzZSBpbmxpbmVkIHZlcnNpb25zIG9mICglKSwgKC8lKSwgYW5kICgvLykgcGVyZm9ybSBiZXR0ZXIgdGhhbiB0aGVpciBmdW5jdG9yaXplZFxuICAgICBjb3VudGVycGFydHMgaW4gW0ZdIChzZWUgYmVuY2htYXJrcyBiZWxvdykuXG5cbiAgICAgVGhlIHJlYXNvbiB0aGVzZSBmdW5jdGlvbnMgYXJlIGlubGluZWQgaW4gW0ludF0gYnV0IG5vdCBpbiBhbnkgb2YgdGhlIG90aGVyIGludGVnZXJcbiAgICAgbW9kdWxlcyBpcyB0aGF0IHRoZXkgZXhpc3RlZCBpbiBbSW50XSBhbmQgW0ludF0gYWxvbmUgcHJpb3IgdG8gdGhlIGludHJvZHVjdGlvbiBvZlxuICAgICB0aGUgW0ludF9tYXRoLk1ha2VdIGZ1bmN0b3IsIGFuZCB3ZSBkaWRuJ3Qgd2FudCB0byBkZWdyYWRlIHRoZWlyIHBlcmZvcm1hbmNlLlxuXG4gICAgIFdlIHdvbid0IHByZS1lbXB0aXZlbHkgZG8gdGhlIHNhbWUgZm9yIG5ldyBmdW5jdGlvbnMsIHVubGVzcyBzb21lb25lIGNhcmVzLCBvbiBhIGNhc2VcbiAgICAgYnkgY2FzZSBmYXNoaW9uLiAgKilcblxuICBsZXQgKCAlICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgJSUgJXMgaW4gY29yZV9pbnQubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGxldCBydmFsID0gcmVtIHggeSBpblxuICAgIGlmIHJ2YWwgPCB6ZXJvIHRoZW4gcnZhbCArIHkgZWxzZSBydmFsXG4gIDs7XG5cbiAgbGV0ICggLyUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAvJSUgJXMgaW4gY29yZV9pbnQubWw6IGRpdmlzb3Igc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGlmIHggPCB6ZXJvIHRoZW4gKCh4ICsgb25lKSAvIHkpIC0gb25lIGVsc2UgeCAvIHlcbiAgOztcblxuICBsZXQgKCAvLyApIHggeSA9IHRvX2Zsb2F0IHggLy4gdG9fZmxvYXQgeVxuXG4gIGV4dGVybmFsICggbGFuZCApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlYW5kaW50XCJcbiAgZXh0ZXJuYWwgKCBsb3IgKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJW9yaW50XCJcbiAgZXh0ZXJuYWwgKCBseG9yICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG4gIGxldCBsbm90ID0gbG5vdFxuXG4gIGV4dGVybmFsICggbHNsICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuICBleHRlcm5hbCAoIGxzciApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlbHNyaW50XCJcbiAgZXh0ZXJuYWwgKCBhc3IgKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWFzcmludFwiXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnRdIGFuZCBbSW50Lk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIE9fRiA9IE8uRlxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlciBpbmNsdWRpbmcgZnVuY3RvclxuICAgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnNcbiAgIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBTdGRsaWIuT2JqLnRcbnR5cGUgcmF3X2RhdGEgPSBTdGRsaWIuT2JqLnJhd19kYXRhXG5cbmV4dGVybmFsIG1hZ2ljIDogKF9bQGxvY2FsX29wdF0pIC0+IChfW0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHJlcHIgOiAoX1tAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgb2JqIDogKHRbQGxvY2FsX29wdF0pIC0+IChfW0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHNpemUgOiAodFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuXG5sZXRbQGlubGluZSBhbHdheXNdIHNpemUgdCA9IHNpemUgKFN5cy5vcGFxdWVfaWRlbnRpdHkgdClcblxuZXh0ZXJuYWwgaXNfaW50IDogKHRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVvYmpfaXNfaW50XCJcblxuKCogVGhlIHJlc3VsdCBkb2Vzbid0IG5lZWQgdG8gYmUgbWFya2VkIGxvY2FsIGJlY2F1c2UgdGhlIGRhdGEgaXMgY29waWVkIGludG8gYSBmcmVzaFxuICAgbmF0aXZlaW50IGJsb2NrIHJlZ2FyZGxlc3MuICopXG5leHRlcm5hbCByYXdfZmllbGQgOiAodFtAbG9jYWxfb3B0XSkgLT4gaW50IC0+IHJhd19kYXRhID0gXCJjYW1sX29ial9yYXdfZmllbGRcIlxuXG5leHRlcm5hbCBzZXRfcmF3X2ZpZWxkXG4gIDogICh0W0Bsb2NhbF9vcHRdKVxuICAtPiBpbnRcbiAgLT4gcmF3X2RhdGFcbiAgLT4gdW5pdFxuICA9IFwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZFwiXG5cbmV4dGVybmFsIHRhZyA6ICh0W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcImNhbWxfb2JqX3RhZ1wiIFtAQG5vYWxsb2NdXG5cbigqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgb24gdGhlIGxvY2FsIHN0YWNrLiBSZXR1cm5zIFtmYWxzZV0gZm9yIGltbWVkaWF0ZXMuICopXG5leHRlcm5hbCBpc19zdGFjayA6ICh0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCJjYW1sX2R1bW15X29ial9pc19zdGFja1wiXG5cbnR5cGUgc3RhY2tfb3JfaGVhcCA9XG4gIHwgSW1tZWRpYXRlXG4gIHwgU3RhY2tcbiAgfCBIZWFwXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgY29tcGFyZV1cblxubGV0IHN0YWNrX29yX2hlYXBfb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMDNfID0gXCJvYmpfbG9jYWwubWwuc3RhY2tfb3JfaGVhcFwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiaW1tZWRpYXRlXCIgfCBcIkltbWVkaWF0ZVwiKSAtPiBJbW1lZGlhdGVcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInN0YWNrXCIgfCBcIlN0YWNrXCIpIC0+IFN0YWNrXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJoZWFwXCIgfCBcIkhlYXBcIikgLT4gSGVhcFxuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbW1lZGlhdGVcIiB8IFwiSW1tZWRpYXRlXCIpIDo6IF8pIGFzXG4gICAgIHNleHBfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJzdGFja1wiIHwgXCJTdGFja1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiaGVhcFwiIHwgXCJIZWFwXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICB8IHNleHBfXzAwMl8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHN0YWNrX29yX2hlYXApXG47O1xuXG5sZXQgc2V4cF9vZl9zdGFja19vcl9oZWFwID1cbiAgKGZ1bmN0aW9uXG4gICB8IEltbWVkaWF0ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJJbW1lZGlhdGVcIlxuICAgfCBTdGFjayAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJTdGFja1wiXG4gICB8IEhlYXAgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSGVhcFwiXG4gICAgOiBzdGFja19vcl9oZWFwIC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCBjb21wYXJlX3N0YWNrX29yX2hlYXAgPSAoU3RkbGliLmNvbXBhcmUgOiBzdGFja19vcl9oZWFwIC0+IHN0YWNrX29yX2hlYXAgLT4gaW50KVxuXG5bQEBAZW5kXVxuXG5sZXQgc3RhY2tfb3JfaGVhcCByZXByID1cbiAgaWYgaXNfaW50IHJlcHJcbiAgdGhlbiBJbW1lZGlhdGVcbiAgZWxzZSAoXG4gICAgbWF0Y2ggU3lzLmJhY2tlbmRfdHlwZSB3aXRoXG4gICAgfCBTeXMuTmF0aXZlIC0+IGlmIGlzX3N0YWNrIHJlcHIgdGhlbiBTdGFjayBlbHNlIEhlYXBcbiAgICB8IFN5cy5CeXRlY29kZSAtPiBIZWFwXG4gICAgfCBTeXMuT3RoZXIgXyAtPiBIZWFwKVxuOztcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxuKCogV2UgbWFpbnRhaW4gdGhlIHByb3BlcnR5IHRoYXQgYWxsIHZhbHVlcyBvZiB0eXBlIFt0XSBkbyBub3QgaGF2ZSB0aGUgdGFnXG4gICBbZG91YmxlX2FycmF5X3RhZ10uICBTb21lIGZ1bmN0aW9ucyBiZWxvdyBhc3N1bWUgdGhpcyBpbiBvcmRlciB0byBhdm9pZCB0ZXN0aW5nIHRoZVxuICAgdGFnLCBhbmQgd2lsbCBzZWdmYXVsdCBpZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgaG9sZC4gKilcbnR5cGUgdCA9IFN0ZGxpYi5PYmoudCBhcnJheVxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBhc3NlcnQgKFN0ZGxpYi5PYmoudGFnIChTdGRsaWIuT2JqLnJlcHIgdCkgPD4gU3RkbGliLk9iai5kb3VibGVfYXJyYXlfdGFnKVxuOztcblxubGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCAoKiB3b3VsZCBjaGVjayBmb3IgZmxvYXQgYXJyYXlzIGluIDMyIGJpdCwgYnV0IHdoYXRldmVyICopXG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIFNleHAuQXRvbVxuICAgIChTdHJpbmcuY29uY2F0IH5zZXA6XCJcIiBbIFwiPE9ial9hcnJheS50IG9mIGxlbmd0aCBcIjsgSW50LnRvX3N0cmluZyAobGVuZ3RoIHQpOyBcIj5cIiBdKVxuOztcblxubGV0IHplcm9fb2JqID0gU3RkbGliLk9iai5yZXByICgwIDogaW50KVxuXG4oKiBXZSBjYWxsIFtBcnJheS5jcmVhdGVdIHdpdGggYSB2YWx1ZSB0aGF0IGlzIG5vdCBhIGZsb2F0IHNvIHRoYXQgdGhlIGFycmF5IGRvZXNuJ3QgZ2V0XG4gICB0YWdnZWQgd2l0aCBbRG91YmxlX2FycmF5X3RhZ10uICopXG5sZXQgY3JlYXRlX3plcm8gfmxlbiA9IEFycmF5LmNyZWF0ZSB+bGVuIHplcm9fb2JqXG5sZXQgZW1wdHkgPSBbfHxdXG5cbnR5cGUgbm90X2FfZmxvYXQgPVxuICB8IE5vdF9hX2Zsb2F0XzBcbiAgfCBOb3RfYV9mbG9hdF8xIG9mIGludFxuXG5sZXQgX25vdF9hX2Zsb2F0XzAgPSBOb3RfYV9mbG9hdF8wXG5sZXQgX25vdF9hX2Zsb2F0XzEgPSBOb3RfYV9mbG9hdF8xIDQyXG5cbmxldCBnZXQgdCBpID1cbiAgKCogTWFrZSB0aGUgY29tcGlsZXIgYmVsaWV2ZSBbdF0gaXMgYW4gYXJyYXkgbm90IGNvbnRhaW5pbmcgZmxvYXRzIHNvIGl0IGRvZXMgbm90IGNoZWNrXG4gICAgIGlmIFt0XSBpcyB0YWdnZWQgd2l0aCBbRG91YmxlX2FycmF5X3RhZ10uICBJdCBpcyBOT1Qgb2sgdG8gdXNlIFtpbnQgYXJyYXldIHNpbmNlIChpZlxuICAgICB0aGlzIGZ1bmN0aW9uIGlzIGlubGluZWQgYW5kIHRoZSBhcnJheSBjb250YWlucyBpbi1oZWFwIGJveGVkIHZhbHVlcykgd3JvbmcgcmVnaXN0ZXJcbiAgICAgdHlwaW5nIG1heSByZXN1bHQsIGxlYWRpbmcgdG8gYSBmYWlsdXJlIHRvIHJlZ2lzdGVyIG5lY2Vzc2FyeSBHQyByb290cy4gKilcbiAgU3RkbGliLk9iai5yZXByXG4gICAgKCogW1N5cy5vcGFxdWVfaWRlbnRpdHldIGlzIHJlcXVpcmVkIG9uIHRoZSBhcnJheSBiZWNhdXNlIHRoaXMgY29kZSBicmVha3MgdGhlIHVzdWFsXG4gICAgICAgYXNzdW1wdGlvbnMgYWJvdXQgYXJyYXkga2luZHMgdGhhdCB0aGUgRmxhbWJkYSAyIG9wdGltaXNlciBjYW4gc2VlLiAqKVxuICAgICgoU3lzLm9wYXF1ZV9pZGVudGl0eSAoU3RkbGliLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpKS4oaSlcbiAgICAgIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9nZXQgdCBpID1cbiAgKCogTWFrZSB0aGUgY29tcGlsZXIgYmVsaWV2ZSBbdF0gaXMgYW4gYXJyYXkgbm90IGNvbnRhaW5pbmcgZmxvYXRzIHNvIGl0IGRvZXMgbm90IGNoZWNrXG4gICAgIGlmIFt0XSBpcyB0YWdnZWQgd2l0aCBbRG91YmxlX2FycmF5X3RhZ10uICopXG4gIFN0ZGxpYi5PYmoucmVwclxuICAgIChBcnJheS51bnNhZmVfZ2V0XG4gICAgICAgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKE9ial9sb2NhbC5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpKVxuICAgICAgIGlcbiAgICAgIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqID1cbiAgKCogU2FtZSBjb21tZW50IGFzIFt1bnNhZmVfZ2V0XS4gU3lzLm9wYXF1ZV9pZGVudGl0eSBwcmV2ZW50cyB0aGUgY29tcGlsZXIgZnJvbVxuICAgICBwb3RlbnRpYWxseSB3cm9uZ2x5IGd1ZXNzaW5nIHRoZSB0eXBlIG9mIHRoZSBhcnJheSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBlbGVtZW50LCB0aGF0XG4gICAgIGlzIHByZXZlbnQgdGhlIGltcGxpY2F0aW9uOiAoT2JqLnRhZyBvYmogPSBPYmouZG91YmxlX3RhZykgPT4gKE9iai50YWcgdCA9XG4gICAgIE9iai5kb3VibGVfYXJyYXlfdGFnKSB3aGljaCBmbGFtYmRhIGhhcyB0cmllZCBpbiB0aGUgcGFzdCAoYXQgbGVhc3QgdGhhdCdzIGFzc3VtaW5nXG4gICAgIHRoZSBjb21waWxlciByZXNwZWN0cyBTeXMub3BhcXVlX2lkZW50aXR5LCB3aGljaCBpcyBub3QgYWx3YXlzIHRoZSBjYXNlKS4gKilcbiAgQXJyYXkudW5zYWZlX3NldFxuICAgIChTeXMub3BhcXVlX2lkZW50aXR5IChPYmpfbG9jYWwubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KSlcbiAgICBpXG4gICAgKFN0ZGxpYi5PYmoub2JqIChTeXMub3BhcXVlX2lkZW50aXR5IG9iaikgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9iaiA9XG4gICgqIHNhbWUgYXMgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IGJ1dCBzYWZlICopXG4gIChTeXMub3BhcXVlX2lkZW50aXR5IChTdGRsaWIuT2JqLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkpLihpKVxuICAgIDwtIChTdGRsaWIuT2JqLm9iaiAoU3lzLm9wYXF1ZV9pZGVudGl0eSBvYmopIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIGludCA9XG4gICgqIFRoaXMgc2tpcHMgW2NhbWxfbW9kaWZ5XSwgd2hpY2ggaXMgT0sgaWYgYm90aCB0aGUgb2xkIGFuZCBuZXcgdmFsdWVzIGFyZSBpbnRlZ2Vycy4gKilcbiAgQXJyYXkudW5zYWZlX3NldFxuICAgIChTeXMub3BhcXVlX2lkZW50aXR5IChPYmpfbG9jYWwubWFnaWMgKHQgOiB0KSA6IGludCBhcnJheSkpXG4gICAgaVxuICAgIChTeXMub3BhcXVlX2lkZW50aXR5IGludClcbjs7XG5cbigqIEZvciBbc2V0XSBhbmQgW3Vuc2FmZV9zZXRdLCBpZiBhIHBvaW50ZXIgaXMgaW52b2x2ZWQsIHdlIGZpcnN0IGRvIGEgcGh5c2ljYWwtZXF1YWxpdHlcbiAgIHRlc3QgdG8gc2VlIGlmIHRoZSBwb2ludGVyIGlzIGNoYW5naW5nLiAgSWYgbm90LCB3ZSBkb24ndCBuZWVkIHRvIGRvIHRoZSBbc2V0XSwgd2hpY2hcbiAgIHNhdmVzIGEgY2FsbCB0byBbY2FtbF9tb2RpZnldLiAgV2UgdGhpbmsgdGhpcyBwaHlzaWNhbC1lcXVhbGl0eSB0ZXN0IGlzIHdvcnRoIGl0XG4gICBiZWNhdXNlIGl0IGlzIHZlcnkgY2hlYXAgKGJvdGggdmFsdWVzIGFyZSBhbHJlYWR5IGF2YWlsYWJsZSBmcm9tIHRoZSBbaXNfaW50XSB0ZXN0KVxuICAgYW5kIGJlY2F1c2UgW2NhbWxfbW9kaWZ5XSBpcyBleHBlbnNpdmUuICopXG5cbmxldCBzZXQgdCBpIG9iaiA9XG4gICgqIFdlIHVzZSBbZ2V0XSBmaXJzdCBidXQgdGhlbiB3ZSB1c2UgW0FycmF5LnVuc2FmZV9zZXRdIHNpbmNlIHdlIGtub3cgdGhhdCBbaV0gaXNcbiAgICAgdmFsaWQuICopXG4gIGxldCBvbGRfb2JqID0gZ2V0IHQgaSBpblxuICBpZiBTdGRsaWIuT2JqLmlzX2ludCBvbGRfb2JqICYmIFN0ZGxpYi5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChTdGRsaWIuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgaWYgbm90IChwaHlzX2VxdWFsIG9sZF9vYmogb2JqKVxuICB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXQgdCBpIG9iaiA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgU3RkbGliLk9iai5pc19pbnQgb2xkX29iaiAmJiBTdGRsaWIuT2JqLmlzX2ludCBvYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSAoU3RkbGliLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlIGlmIG5vdCAocGh5c19lcXVhbCBvbGRfb2JqIG9iailcbiAgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgb2JqID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBTdGRsaWIuT2JqLmlzX2ludCBvbGRfb2JqICYmIFN0ZGxpYi5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChTdGRsaWIuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldCBzd2FwIHQgaSBqID1cbiAgbGV0IGEgPSBnZXQgdCBpIGluXG4gIGxldCBiID0gZ2V0IHQgaiBpblxuICB1bnNhZmVfc2V0IHQgaSBiO1xuICB1bnNhZmVfc2V0IHQgaiBhXG47O1xuXG5sZXQgY3JlYXRlIH5sZW4geCA9XG4gICgqIElmIHdlIGNhbiwgdXNlIFtBcnJheS5jcmVhdGVdIGRpcmVjdGx5LiBFdmVuIHRob3VnaCBbaXNfaW50XSBjaGVjayBpcyBzdWJzdW1lZCBieVxuICAgICB0aGUgdGFnIGNoZWNrLCBjaGVja2luZyBpdCBpcyBtdWNoIGZhc3Rlciwgc2luY2UgaXQgYXZvaWRzIGEgQyBmdW5jdGlvbiBjYWxsLiAgKilcbiAgaWYgU3RkbGliLk9iai5pc19pbnQgeCB8fCBTdGRsaWIuT2JqLnRhZyB4IDw+IFN0ZGxpYi5PYmouZG91YmxlX3RhZ1xuICB0aGVuIEFycmF5LmNyZWF0ZSB+bGVuIHhcbiAgZWxzZSAoXG4gICAgKCogT3RoZXJ3aXNlIHVzZSBbY3JlYXRlX3plcm9dIGFuZCBzZXQgdGhlIGNvbnRlbnRzICopXG4gICAgbGV0IHQgPSBjcmVhdGVfemVybyB+bGVuIGluXG4gICAgbGV0IHggPSBTeXMub3BhcXVlX2lkZW50aXR5IHggaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSB4XG4gICAgZG9uZTtcbiAgICB0KVxuOztcblxubGV0IHNpbmdsZXRvbiBvYmogPSBjcmVhdGUgfmxlbjoxIG9ialxuXG4oKiBQcmUtY29uZGl0aW9uOiB0LihpKSBpcyBhbiBpbnRlZ2VyLiAqKVxubGV0IHVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgb2JqID1cbiAgaWYgU3RkbGliLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKFN0ZGxpYi5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZVxuICAgICgqIFt0LihpKV0gaXMgYW4gaW50ZWdlciBhbmQgW29ial0gaXMgbm90LCBzbyB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayBpZiB0aGV5IGFyZVxuICAgICAgIGVxdWFsLiAqKVxuICAgIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXQgdW5zYWZlX3NldF9pbnQgdCBpIGludCA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgU3RkbGliLk9iai5pc19pbnQgb2xkX29ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIGludFxuICBlbHNlIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKFN0ZGxpYi5PYmoucmVwciBpbnQpXG47O1xuXG5sZXQgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgdCBpID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBub3QgKFN0ZGxpYi5PYmouaXNfaW50IG9sZF9vYmopXG4gIHRoZW4gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoU3RkbGliLk9iai5yZXByIDApXG47O1xuXG4oKiogW3Vuc2FmZV9ibGl0XSBpcyBsaWtlIFtBcnJheS5ibGl0XSwgZXhjZXB0IGl0IHVzZXMgb3VyIG93biBmb3ItbG9vcCB0byBhdm9pZFxuICAgIGNhbWxfbW9kaWZ5IHdoZW4gcG9zc2libGUuICBJdHMgcGVyZm9ybWFuY2UgaXMgc3RpbGwgbm90IGNvbXBhcmFibGUgdG8gYSBtZW1jcHkuICopXG5sZXQgdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAoKiBXaGVuIFtwaHlzX2VxdWFsIHNyYyBkc3RdLCB3ZSBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgW2RzdF9wb3MgPCBzcmNfcG9zXSBhbmQgaGF2ZSB0aGVcbiAgICAgZm9yIGxvb3AgZ28gaW4gdGhlIHJpZ2h0IGRpcmVjdGlvbiBzbyB0aGF0IHdlIGRvbid0IG92ZXJ3cml0ZSBkYXRhIHRoYXQgd2Ugc3RpbGwgbmVlZFxuICAgICB0byByZWFkLiAgV2hlbiBbbm90IChwaHlzX2VxdWFsIHNyYyBkc3QpXSwgZG9pbmcgdGhpcyBpcyBoYXJtbGVzcy4gIEZyb20gYVxuICAgICBtZW1vcnktcGVyZm9ybWFuY2UgcGVyc3BlY3RpdmUsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgb25lIGxvb3BzIHVwIG9yIGRvd24uXG4gICAgIENvbnN0YW50LXN0cmlkZSBhY2Nlc3MsIGZvcndhcmQgb3IgYmFja3dhcmQsIHNob3VsZCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSAoYXQgbGVhc3Qgb25cbiAgICAgYW4gaW50ZWwgaTcpLiAgU28sIHdlIGRvbid0IGRvIGEgY2hlY2sgZm9yIFtwaHlzX2VxdWFsIHNyYyBkc3RdIGFuZCBhbHdheXMgbG9vcCB1cCBpblxuICAgICB0aGF0IGNhc2UuICopXG4gIGlmIGRzdF9wb3MgPCBzcmNfcG9zXG4gIHRoZW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCBkc3QgKGRzdF9wb3MgKyBpKSAodW5zYWZlX2dldCBzcmMgKHNyY19wb3MgKyBpKSlcbiAgICBkb25lXG4gIGVsc2VcbiAgICBmb3IgaSA9IGxlbiAtIDEgZG93bnRvIDAgZG9cbiAgICAgIHVuc2FmZV9zZXQgZHN0IChkc3RfcG9zICsgaSkgKHVuc2FmZV9nZXQgc3JjIChzcmNfcG9zICsgaSkpXG4gICAgZG9uZVxuOztcblxuaW5jbHVkZSBCbGl0Lk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCBjcmVhdGUgPSBjcmVhdGVfemVyb1xuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG5lbmQpXG5cbmxldCBjb3B5IHNyYyA9XG4gIGxldCBkc3QgPSBjcmVhdGVfemVybyB+bGVuOihsZW5ndGggc3JjKSBpblxuICBibGl0byB+c3JjIH5kc3QgKCk7XG4gIGRzdFxuOztcblxubGV0IHN1YiA9IEFycmF5LnN1YlxuIiwib3BlbiEgSW1wb3J0XG5cbigqIFdBUk5JTkc6XG4gICBXZSB1c2Ugbm9uLW1lbW9yeS1zYWZlIHRoaW5ncyB0aHJvdWdob3V0IHRoZSBbVHJ1c3RlZF0gbW9kdWxlLlxuICAgTW9zdCBvZiBpdCBpcyBvbmx5IHNhZmUgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgdHlwZSBzaWduYXR1cmUgKGUuZy4gZXhwb3NpbmdcbiAgIFt2YWwgY29weSA6ICdhIHQgLT4gJ2IgdF0gd291bGQgYmUgYSBiaWcgbWlzdGFrZSkuICopXG5tb2R1bGUgVHJ1c3RlZCA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgZW1wdHkgOiAnYSB0XG4gIHZhbCB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgOiBsZW46aW50IC0+ICdhIHRcbiAgdmFsIGNyZWF0ZV9vYmpfYXJyYXkgOiBsZW46aW50IC0+ICdhIHRcbiAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gJ2EgLT4gJ2EgdFxuICB2YWwgc2luZ2xldG9uIDogJ2EgLT4gJ2EgdFxuICB2YWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2FcbiAgdmFsIHNldCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHN3YXAgOiBfIHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gIHZhbCB1bnNhZmVfZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2FcbiAgdmFsIHVuc2FmZV9nZXRfbG9jYWwgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgdW5zYWZlX3NldCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9pbnQgOiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCA6ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfdG9fYXJyYXlfaW5wbGFjZV9fcHJvbWlzZV9ub3RfYV9mbG9hdCA6ICdhIHQgLT4gJ2EgYXJyYXlcbiAgdmFsIHNldF93aXRoX2NhbWxfbW9kaWZ5IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIHVuc2FmZV9ibGl0IDogKCdhIHQsICdhIHQpIEJsaXQuYmxpdFxuICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgOiBfIHQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHN1YiA6ICdhIHQgLT4gcG9zOmludCAtPiBsZW46aW50IC0+ICdhIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSBPYmpfYXJyYXkudFxuXG4gIGxldCBlbXB0eSA9IE9ial9hcnJheS5lbXB0eVxuICBsZXQgdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW4gPSBPYmpfYXJyYXkuY3JlYXRlX3plcm8gfmxlblxuICBsZXQgY3JlYXRlX29ial9hcnJheSB+bGVuID0gT2JqX2FycmF5LmNyZWF0ZV96ZXJvIH5sZW5cbiAgbGV0IGNyZWF0ZSB+bGVuIHggPSBPYmpfYXJyYXkuY3JlYXRlIH5sZW4gKFN0ZGxpYi5PYmoucmVwciB4KVxuICBsZXQgc2luZ2xldG9uIHggPSBPYmpfYXJyYXkuc2luZ2xldG9uIChTdGRsaWIuT2JqLnJlcHIgeClcbiAgbGV0IHN3YXAgdCBpIGogPSBPYmpfYXJyYXkuc3dhcCB0IGkgalxuICBsZXQgZ2V0IGFyciBpID0gU3RkbGliLk9iai5vYmogKE9ial9hcnJheS5nZXQgYXJyIGkpXG4gIGxldCBzZXQgYXJyIGkgeCA9IE9ial9hcnJheS5zZXQgYXJyIGkgKFN0ZGxpYi5PYmoucmVwciB4KVxuICBsZXQgdW5zYWZlX2dldF9sb2NhbCBhcnIgaSA9IFN0ZGxpYi5PYmoub2JqIChPYmpfYXJyYXkudW5zYWZlX2dldCBhcnIgaSlcbiAgbGV0IHVuc2FmZV9nZXQgYXJyIGkgPSB1bnNhZmVfZ2V0X2xvY2FsIGFyciBpXG4gIGxldCB1bnNhZmVfc2V0IGFyciBpIHggPSBPYmpfYXJyYXkudW5zYWZlX3NldCBhcnIgaSAoU3RkbGliLk9iai5yZXByIHgpXG4gIGxldCB1bnNhZmVfc2V0X2ludCBhcnIgaSB4ID0gT2JqX2FycmF5LnVuc2FmZV9zZXRfaW50IGFyciBpIHhcblxuICBsZXQgdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSB4XG4gIDs7XG5cbiAgbGV0IHVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIChTdGRsaWIuT2JqLnJlcHIgeClcbiAgOztcblxuICAoKiBbdF0gaXMganVzdCBhbiBhcnJheSB1bmRlciB0aGUgaG9vZCwgaXQganVzdCBoYXMgc3BlY2lhbCBjb25zaWRlcmF0aW9ucyBhYm91dCBbdF0gbm90XG4gICAgIGJlaW5nIGEgZmxvYXQuICopXG4gIGxldCB1bnNhZmVfdG9fYXJyYXlfaW5wbGFjZV9fcHJvbWlzZV9ub3RfYV9mbG9hdCBhcnIgPSBTdGRsaWIuT2JqLm1hZ2ljIGFyclxuICBsZXQgbGVuZ3RoID0gT2JqX2FycmF5Lmxlbmd0aFxuICBsZXQgdW5zYWZlX2JsaXQgPSBPYmpfYXJyYXkudW5zYWZlX2JsaXRcbiAgbGV0IGNvcHkgPSBPYmpfYXJyYXkuY29weVxuXG4gIGxldCB1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIHQgaSAoU3RkbGliLk9iai5yZXByIHgpXG4gIDs7XG5cbiAgbGV0IHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKFN0ZGxpYi5PYmoucmVwciB4KVxuICA7O1xuXG4gIGxldCBzZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgeCA9IE9ial9hcnJheS5zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKFN0ZGxpYi5PYmoucmVwciB4KVxuICBsZXQgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgPSBPYmpfYXJyYXkudW5zYWZlX2NsZWFyX2lmX3BvaW50ZXJcbiAgbGV0IHN1YiA9IE9ial9hcnJheS5zdWJcbmVuZFxuXG5pbmNsdWRlIFRydXN0ZWRcblxubGV0IGludmFyaWFudCB0ID1cbiAgYXNzZXJ0IChTdGRsaWIuT2JqLnRhZyAoU3RkbGliLk9iai5yZXByIHQpIDw+IFN0ZGxpYi5PYmouZG91YmxlX2FycmF5X3RhZylcbjs7XG5cbmxldCBpbml0IGwgfmYgPVxuICBpZiBsIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIFwiVW5pZm9ybV9hcnJheS5pbml0XCJcbiAgZWxzZSAoXG4gICAgbGV0IHJlcyA9IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuOmwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICBkb25lO1xuICAgIHJlcylcbjs7XG5cbmxldCBvZl9hcnJheSBhcnIgPSBpbml0IH5mOihBcnJheS51bnNhZmVfZ2V0IGFycikgKEFycmF5Lmxlbmd0aCBhcnIpIFtAbm9udGFpbF1cbmxldCBtYXAgYSB+ZiA9IGluaXQgfmY6KGZ1biBpIC0+IGYgKHVuc2FmZV9nZXQgYSBpKSkgKGxlbmd0aCBhKSBbQG5vbnRhaWxdXG5sZXQgbWFwaSBhIH5mID0gaW5pdCB+ZjooZnVuIGkgLT4gZiBpICh1bnNhZmVfZ2V0IGEgaSkpIChsZW5ndGggYSkgW0Bub250YWlsXVxuXG5sZXQgaXRlciBhIH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIGYgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgYSB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lXG47O1xuXG5sZXQgZm9sZGkgYSB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgYWNjIDo9IGYgaSAhYWNjICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIWFjY1xuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCByID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmU7XG4gICFyXG47O1xuXG5sZXQgdG9fbGlzdCB0ID0gTGlzdC5pbml0IH5mOihnZXQgdCkgKGxlbmd0aCB0KVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgbGV0IHJlcyA9IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgeCAtPiBzZXQgcmVzIGkgeCk7XG4gIHJlc1xuOztcblxubGV0IG9mX2xpc3RfcmV2IGwgPVxuICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICBsZXQgcmVzID0gdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW4gaW5cbiAgTGlzdC5pdGVyaSBsIH5mOihmdW4gaSB4IC0+IHNldCByZXMgKGxlbiAtIGkgLSAxKSB4KTtcbiAgcmVzXG47O1xuXG4oKiBJdCBpcyBub3Qgc2FmZSBmb3IgW3RvX2FycmF5XSB0byBiZSB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYmVjYXVzZSB3ZSBoYXZlIGNvZGUgdGhhdFxuICAgcmVsaWVzIG9uIFtmbG9hdCBhcnJheV1zIGJlaW5nIHVuYm94ZWQsIGZvciBleGFtcGxlIGluIFtiaW5fd3JpdGVfYXJyYXldLiAqKVxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IChsZW5ndGggdCkgfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICh1bnNhZmVfZ2V0IHQgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAodW5zYWZlX2dldCB0ICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IHIgPSByZWYgZW1wdHkgaW5cbiAgbGV0IGsgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgbWF0Y2ggZiBpICh1bnNhZmVfZ2V0IHQgaSkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBhIC0+XG4gICAgICBpZiAhayA9IDAgdGhlbiByIDo9IGNyZWF0ZSB+bGVuOihsZW5ndGggdCkgYTtcbiAgICAgIHVuc2FmZV9zZXQgIXIgIWsgYTtcbiAgICAgIGluY3Iga1xuICBkb25lO1xuICBpZiAhayA9IGxlbmd0aCB0IHRoZW4gIXIgZWxzZSBpZiAhayA+IDAgdGhlbiBzdWIgfnBvczowIH5sZW46IWsgIXIgZWxzZSBlbXB0eVxuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiBTb21lIHggZWxzZSBOb25lKSBbQG5vbnRhaWxdXG5sZXQgZmlsdGVyX21hcCB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIF9pIGEgLT4gZiBhKSBbQG5vbnRhaWxdXG5sZXQgZmlsdGVyIHQgfmYgPSBmaWx0ZXJfbWFwIHQgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpIFtAbm9udGFpbF1cblxubGV0IGZvbGQyX2V4biB0MSB0MiB+aW5pdCB+ZiA9XG4gIGxldCBsZW4gPSBsZW5ndGggdDEgaW5cbiAgaWYgbGVuZ3RoIHQyIDw+IGxlbiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZm9sZDJfZXhuXCI7XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGFjYyA6PSBmICFhY2MgKHVuc2FmZV9nZXQgdDEgaSkgKHVuc2FmZV9nZXQgdDIgaSlcbiAgZG9uZTtcbiAgIWFjY1xuOztcblxubGV0IG1hcDJfZXhuIHQxIHQyIH5mID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0MSBpblxuICBpZiBsZW5ndGggdDIgPD4gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyX2V4blwiO1xuICBpbml0IGxlbiB+ZjooZnVuIGkgLT4gZiAodW5zYWZlX2dldCB0MSBpKSAodW5zYWZlX2dldCB0MiBpKSkgW0Bub250YWlsXVxuOztcblxubGV0IGNvbmNhdCB0cyA9XG4gIGxldCB0b3RhbF9sZW4gPSBMaXN0LnN1bSAobW9kdWxlIEludCkgdHMgfmY6KGZ1biB0IC0+IGxlbmd0aCB0KSBpblxuICBsZXQgcmVzID0gdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW46dG90YWxfbGVuIGluXG4gIGlnbm9yZVxuICAgIChMaXN0LmZvbGQgdHMgfmluaXQ6MCB+ZjooZnVuIHNvX2ZhciB0IC0+XG4gICAgICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgIHNldCByZXMgKHNvX2ZhciArIGkpIChnZXQgdCBpKVxuICAgICAgIGRvbmU7XG4gICAgICAgc29fZmFyICsgbGVuKVxuICAgICAgOiBpbnQpO1xuICByZXNcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB0IH5mID0gdG9fbGlzdCB0IHw+IExpc3QubWFwaSB+ZiB8PiBjb25jYXRcbmxldCBjb25jYXRfbWFwIHQgfmYgPSB0b19saXN0IHQgfD4gTGlzdC5tYXAgfmYgfD4gY29uY2F0XG5cbmxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPVxuICBsZXQgbGVmdCwgcmlnaHQgPSByZWYgZW1wdHksIHJlZiBlbXB0eSBpblxuICBsZXQgbGVmdF9pZHgsIHJpZ2h0X2lkeCA9IHJlZiAwLCByZWYgMCBpblxuICBsZXQgYXBwZW5kIGRhdGEgaWR4IHZhbHVlID1cbiAgICBpZiAhaWR4ID0gMCB0aGVuIGRhdGEgOj0gY3JlYXRlIH5sZW46KGxlbmd0aCB0KSB2YWx1ZTtcbiAgICB1bnNhZmVfc2V0ICFkYXRhICFpZHggdmFsdWU7XG4gICAgaW5jciBpZHhcbiAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIG1hdGNoIChmICh1bnNhZmVfZ2V0IHQgaSkgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBhIC0+IGFwcGVuZCBsZWZ0IGxlZnRfaWR4IGFcbiAgICB8IFNlY29uZCBhIC0+IGFwcGVuZCByaWdodCByaWdodF9pZHggYVxuICBkb25lO1xuICBsZXQgdHJpbSBkYXRhIGlkeCA9XG4gICAgaWYgIWlkeCA9IGxlbmd0aCB0XG4gICAgdGhlbiAhZGF0YVxuICAgIGVsc2UgaWYgIWlkeCA+IDBcbiAgICB0aGVuIHN1YiB+cG9zOjAgfmxlbjohaWR4ICFkYXRhXG4gICAgZWxzZSBlbXB0eVxuICBpblxuICB0cmltIGxlZnQgbGVmdF9pZHgsIHRyaW0gcmlnaHQgcmlnaHRfaWR4XG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmIE5vbmUgaW5cbiAgICB3aGlsZSBPcHRpb24uaXNfbm9uZSAhdmFsdWVfZm91bmQgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgdmFsdWVfZm91bmQgOj0gZiB2YWx1ZTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgIXZhbHVlX2ZvdW5kKVxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgTm9uZSBpblxuICAgIHdoaWxlIE9wdGlvbi5pc19ub25lICF2YWx1ZV9mb3VuZCAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICB2YWx1ZV9mb3VuZCA6PSBmICFpIHZhbHVlO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhdmFsdWVfZm91bmQpXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGZvdW5kID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICB3aGlsZSAobm90ICFmb3VuZCkgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgaWYgZiAhaSB2YWx1ZVxuICAgICAgdGhlbiAoXG4gICAgICAgIHZhbHVlX2ZvdW5kIDo9IHZhbHVlO1xuICAgICAgICBmb3VuZCA6PSB0cnVlKVxuICAgICAgZWxzZSBpbmNyIGlcbiAgICBkb25lO1xuICAgIGlmICFmb3VuZCB0aGVuIFNvbWUgKCFpLCAhdmFsdWVfZm91bmQpIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaW5kIHQgfmYgPSBPcHRpb24ubWFwIChmaW5kaSB0IH5mOihmdW4gX2kgeCAtPiBmIHgpKSB+ZjooZnVuIChfaSwgeCkgLT4geClcblxubGV0IGZpbmRpIHQgfmYgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHJlYyBsb29wIGYgaSA9XG4gICAgaWYgaSA+PSBsZW5cbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgICAgIG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgIHwgZmFsc2UgLT4gbG9vcCBmIChpICsgMSlcbiAgICAgIHwgdHJ1ZSAtPiBTb21lIChpLCB4KSlcbiAgaW5cbiAgbG9vcCBmIDBcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBlbHQpIChncmFtbWFyIDogZWx0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGVsdCB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoQXJyYXkudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbmluY2x1ZGVcbiAgU2V4cGFibGUuT2Zfc2V4cGFibGUxXG4gICAgKEFycmF5KVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX2FycmF5XG4gICAgICBsZXQgb2Zfc2V4cGFibGUgPSBvZl9hcnJheVxuICAgIGVuZClcblxuaW5jbHVkZSBCbGl0Lk1ha2UxIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG5cbiAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gdCA9XG4gICAgaWYgbGVuID0gMFxuICAgIHRoZW4gZW1wdHlcbiAgICBlbHNlIChcbiAgICAgIGFzc2VydCAobGVuZ3RoIHQgPiAwKTtcbiAgICAgIGNyZWF0ZSB+bGVuIChnZXQgdCAwKSlcbiAgOztcblxuICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuZW5kKVxuXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxuKCogVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgcHB4X2NvbXBhcmUgW2NvbXBhcmVfYXJyYXldIGJ1dCB1c2VzIG91ciBbdW5zYWZlX2dldF0gYW5kIFtsZW5ndGhdLiAqKVxubGV0IGNvbXBhcmVfX2xvY2FsIGNvbXBhcmVfZWx0IGEgYiA9XG4gIGlmIHBoeXNfZXF1YWwgYSBiXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBsZXQgbGVuX2EgPSBsZW5ndGggYSBpblxuICAgIGxldCBsZW5fYiA9IGxlbmd0aCBiIGluXG4gICAgbGV0IHJldCA9IGNvbXBhcmUgbGVuX2EgbGVuX2IgaW5cbiAgICBpZiByZXQgPD4gMFxuICAgIHRoZW4gcmV0XG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICAgIGlmIGkgPSBsZW5fYVxuICAgICAgICB0aGVuIDBcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IGwgPSB1bnNhZmVfZ2V0X2xvY2FsIGEgaVxuICAgICAgICAgIGFuZCByID0gdW5zYWZlX2dldF9sb2NhbCBiIGkgaW5cbiAgICAgICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgbCByIGluXG4gICAgICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBsb29wIChpICsgMSkpXG4gICAgICBpblxuICAgICAgbG9vcCAwIFtAbm9udGFpbF0pKVxuOztcblxubGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgYSBiID0gY29tcGFyZV9fbG9jYWwgY29tcGFyZV9lbHQgYSBiXG5cbm1vZHVsZSBTb3J0ID0gQXJyYXkuUHJpdmF0ZS5Tb3J0ZXIgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRcbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRcbmVuZClcblxubGV0IHNvcnQgPSBTb3J0LnNvcnRcblxuaW5jbHVkZSBCaW5hcnlfc2VhcmNoYWJsZS5NYWtlMSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldFxuZW5kKVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5pbmNsdWRlIFVjaGFyX2ludGZcblxubGV0IGZhaWx3aXRoZiA9IFByaW50Zi5mYWlsd2l0aGZcblxuaW5jbHVkZSBVY2hhcjBcblxubGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVjaGFyXCJcbmxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gSGFzaC5mb2xkX2ludCBzdGF0ZSAodG9faW50IHQpXG5sZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuXG4oKiBOb3QgZm9yIGV4cG9ydC4gU3RyaW5nIGZvcm1hdHMgZXhwb3J0ZWQgdmlhIFtVdGYqXSBtb2R1bGVzIGJlbG93LiAqKVxubGV0IHRvX3N0cmluZ19pbnRlcm5hbCB0ID0gUHJpbnRmLnNwcmludGYgXCJVKyUwNFhcIiAodG9faW50IHQpXG5sZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKHRvX3N0cmluZ19pbnRlcm5hbCB0KVxuXG5sZXQgdF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBTZXhwLkxpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiVWNoYXIudF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbiAgfCBTZXhwLkF0b20gcyAtPlxuICAgICh0cnkgU3RkbGliLlNjYW5mLnNzY2FuZiBzIFwiVSslWFwiIChmdW4gaSAtPiBVY2hhcjAub2ZfaW50IGkpIHdpdGhcbiAgICAgfCBfIC0+IG9mX3NleHBfZXJyb3IgXCJVY2hhci50X29mX3NleHA6IGF0b20gb2YgdGhlIGZvcm0gVStYWFhYIG5lZWRlZFwiIHNleHApXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSBzdHJpbmdfc2V4cF9ncmFtbWFyXG47O1xuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgbW9kdWxlX25hbWUgPSBtb2R1bGVfbmFtZVxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nX2ludGVybmFsXG5lbmQpXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbiAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBVY2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBpbnRfaXNfc2NhbGFyID0gaXNfdmFsaWRcblxubGV0IHN1Y2NfZXhuIGMgPVxuICB0cnkgVWNoYXIwLnN1Y2MgYyB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT4gZmFpbHdpdGhmIFwiVWNoYXIuc3VjY19leG46ICVzXCIgbXNnICgpXG47O1xuXG5sZXQgc3VjYyBjID1cbiAgdHJ5IFNvbWUgKFVjaGFyMC5zdWNjIGMpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuOztcblxubGV0IHByZWRfZXhuIGMgPVxuICB0cnkgVWNoYXIwLnByZWQgYyB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT4gZmFpbHdpdGhmIFwiVWNoYXIucHJlZF9leG46ICVzXCIgbXNnICgpXG47O1xuXG5sZXQgcHJlZCBjID1cbiAgdHJ5IFNvbWUgKFVjaGFyMC5wcmVkIGMpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuOztcblxubGV0IG9mX3NjYWxhciBpID0gaWYgaW50X2lzX3NjYWxhciBpIHRoZW4gU29tZSAodW5zYWZlX29mX2ludCBpKSBlbHNlIE5vbmVcblxubGV0IG9mX3NjYWxhcl9leG4gaSA9XG4gIGlmIGludF9pc19zY2FsYXIgaVxuICB0aGVuIHVuc2FmZV9vZl9pbnQgaVxuICBlbHNlIGZhaWx3aXRoZiBcIlVjaGFyLm9mX2ludF9leG4gZ290IGEgaW52YWxpZCBVbmljb2RlIHNjYWxhciB2YWx1ZTogJTA0WFwiIGkgKClcbjs7XG5cbmxldCB0b19zY2FsYXIgdCA9IFVjaGFyMC50b19pbnQgdFxubGV0IHRvX2NoYXIgYyA9IGlmIGlzX2NoYXIgYyB0aGVuIFNvbWUgKHVuc2FmZV90b19jaGFyIGMpIGVsc2UgTm9uZVxuXG5sZXQgdG9fY2hhcl9leG4gYyA9XG4gIGlmIGlzX2NoYXIgY1xuICB0aGVuIHVuc2FmZV90b19jaGFyIGNcbiAgZWxzZSBmYWlsd2l0aGYgXCJVY2hhci50b19jaGFyX2V4biBnb3QgYSBub24gbGF0aW4tMSBjaGFyYWN0ZXI6IFUrJTA0WFwiICh0b19pbnQgYykgKClcbjs7XG5cbm1vZHVsZSBEZWNvZGVfcmVzdWx0ID0gc3RydWN0XG4gIHR5cGUgdCA9IFVjaGFyMC51dGZfZGVjb2RlXG5cbiAgbGV0IGNvbXBhcmUgOiB0IC0+IHQgLT4gaW50ID0gUG9seS5jb21wYXJlXG4gIGxldCBlcXVhbCA6IHQgLT4gdCAtPiBib29sID0gUG9seS5lcXVhbFxuXG4gIGxldCBoYXNoX2ZvbGRfdCA6IEhhc2guc3RhdGUgLT4gdCAtPiBIYXNoLnN0YXRlID1cbiAgICBmdW4gc3RhdGUgdCAtPiBoYXNoX2ZvbGRfaW50IHN0YXRlIChIYXNoYWJsZS5oYXNoIHQpXG4gIDs7XG5cbiAgbGV0IGhhc2ggOiB0IC0+IGludCA9IEhhc2hhYmxlLmhhc2hcbiAgbGV0IGlzX3ZhbGlkID0gVWNoYXIwLnV0Zl9kZWNvZGVfaXNfdmFsaWRcbiAgbGV0IGJ5dGVzX2NvbnN1bWVkID0gVWNoYXIwLnV0Zl9kZWNvZGVfbGVuZ3RoXG4gIGxldCB1Y2hhcl9vcl9yZXBsYWNlbWVudF9jaGFyID0gVWNoYXIwLnV0Zl9kZWNvZGVfdWNoYXJcbiAgbGV0IHNleHBfb2ZfdCB0ID0gc2V4cF9vZl90ICh1Y2hhcl9vcl9yZXBsYWNlbWVudF9jaGFyIHQpXG5cbiAgbGV0IHVjaGFyIHQgPVxuICAgIG1hdGNoIGlzX3ZhbGlkIHQgd2l0aFxuICAgIHwgdHJ1ZSAtPiBTb21lICh1Y2hhcl9vcl9yZXBsYWNlbWVudF9jaGFyIHQpXG4gICAgfCBmYWxzZSAtPiBOb25lXG4gIDs7XG5cbiAgbGV0W0B6ZXJvX2FsbG9jXSB1Y2hhcl9leG4gdCA9XG4gICAgbWF0Y2ggaXNfdmFsaWQgdCB3aXRoXG4gICAgfCB0cnVlIC0+IHVjaGFyX29yX3JlcGxhY2VtZW50X2NoYXIgdFxuICAgIHwgZmFsc2UgLT5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgKEF0b20gXCJVY2hhci5EZWNvZGVfcmVzdWx0LnVjaGFyX2V4biB3YXMgY2FsbGVkIG9uIGFuIGludmFsaWQgZGVjb2RlIHJlc3VsdFwiKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX3V0ZiAoRm9ybWF0IDogc2lnXG4gIHZhbCBjb2RlY19uYW1lIDogc3RyaW5nXG4gIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuICB2YWwgYnl0ZV9sZW5ndGggOiB0IC0+IGludFxuICB2YWwgZ2V0X2RlY29kZV9yZXN1bHQgOiBzdHJpbmcgLT4gYnl0ZV9wb3M6aW50IC0+IERlY29kZV9yZXN1bHQudFxuICB2YWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IHQgLT4gaW50XG5lbmQpIDogVXRmID0gc3RydWN0XG4gIGxldCBjb2RlY19uYW1lID0gRm9ybWF0LmNvZGVjX25hbWVcbiAgbGV0IGJ5dGVfbGVuZ3RoID0gRm9ybWF0LmJ5dGVfbGVuZ3RoXG5cbiAgbGV0IHRvX3N0cmluZyB0ID1cbiAgICBsZXQgbGVuID0gYnl0ZV9sZW5ndGggdCBpblxuICAgIGxldCBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcG9zID0gRm9ybWF0LnNldCBieXRlcyAwIHQgaW5cbiAgICBhc3NlcnQgKEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlbik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpieXRlc1xuICA7O1xuXG4gIGxldCBvZl9zdHJpbmdfbWVzc2FnZSA9XG4gICAgRm9ybWF0Lm1vZHVsZV9uYW1lIF4gXCIub2Zfc3RyaW5nOiBleHBlY3RlZCBhIHNpbmdsZSBVbmljb2RlIGNoYXJhY3RlclwiXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9vZl9zdHJpbmcgc3RyaW5nID1cbiAgICBFcnJvci5yYWlzZV9zIChTZXhwLm1lc3NhZ2Ugb2Zfc3RyaW5nX21lc3NhZ2UgWyBcInN0cmluZ1wiLCBBdG9tIHN0cmluZyBdKVxuICA7O1xuXG4gIGxldCBvZl9zdHJpbmcgc3RyaW5nID1cbiAgICBsZXQgZGVjb2RlID0gRm9ybWF0LmdldF9kZWNvZGVfcmVzdWx0IHN0cmluZyB+Ynl0ZV9wb3M6MCBpblxuICAgIGxldCBzdHJpbmdfbGVuID0gU3RyaW5nLmxlbmd0aCBzdHJpbmcgaW5cbiAgICBsZXQgZGVjb2RlX2xlbiA9IERlY29kZV9yZXN1bHQuYnl0ZXNfY29uc3VtZWQgZGVjb2RlIGluXG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBzdHJpbmdfbGVuIGRlY29kZV9sZW5cbiAgICAgICAmJiBEZWNvZGVfcmVzdWx0LmlzX3ZhbGlkIGRlY29kZVxuICAgIHRoZW4gRGVjb2RlX3Jlc3VsdC51Y2hhcl9vcl9yZXBsYWNlbWVudF9jaGFyIGRlY29kZVxuICAgIGVsc2UgcmFpc2Vfb2Zfc3RyaW5nIHN0cmluZ1xuICA7O1xuZW5kXG5cbm1vZHVsZSBVdGY4ID0gTWFrZV91dGYgKHN0cnVjdFxuICBsZXQgY29kZWNfbmFtZSA9IFwiVVRGLThcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVWNoYXIuVXRmOFwiXG4gIGxldCBieXRlX2xlbmd0aCA9IHV0Zl84X2J5dGVfbGVuZ3RoXG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IFN0cmluZy5nZXRfdXRmXzhfdWNoYXJcbiAgbGV0IHNldCA9IEJ5dGVzLnNldF91Y2hhcl91dGZfOFxuZW5kKVxuXG5tb2R1bGUgVXRmMTZsZSA9IE1ha2VfdXRmIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0xNkxFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVjaGFyLlV0ZjE2bGVcIlxuICBsZXQgYnl0ZV9sZW5ndGggPSB1dGZfMTZfYnl0ZV9sZW5ndGhcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gU3RyaW5nLmdldF91dGZfMTZsZV91Y2hhclxuICBsZXQgc2V0ID0gQnl0ZXMuc2V0X3VjaGFyX3V0Zl8xNmxlXG5lbmQpXG5cbm1vZHVsZSBVdGYxNmJlID0gTWFrZV91dGYgKHN0cnVjdFxuICBsZXQgY29kZWNfbmFtZSA9IFwiVVRGLTE2QkVcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVWNoYXIuVXRmMTZiZVwiXG4gIGxldCBieXRlX2xlbmd0aCA9IHV0Zl8xNl9ieXRlX2xlbmd0aFxuICBsZXQgZ2V0X2RlY29kZV9yZXN1bHQgPSBTdHJpbmcuZ2V0X3V0Zl8xNmJlX3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzE2YmVcbmVuZClcblxubW9kdWxlIFV0ZjMybGUgPSBNYWtlX3V0ZiAoc3RydWN0XG4gIGxldCBjb2RlY19uYW1lID0gXCJVVEYtMzJMRVwiXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5VY2hhci5VdGYzMmxlXCJcbiAgbGV0IGJ5dGVfbGVuZ3RoIF8gPSA0XG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IFN0cmluZy5nZXRfdXRmXzMybGVfdWNoYXJcbiAgbGV0IHNldCA9IEJ5dGVzLnNldF91Y2hhcl91dGZfMzJsZVxuZW5kKVxuXG5tb2R1bGUgVXRmMzJiZSA9IE1ha2VfdXRmIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0zMkJFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVjaGFyLlV0ZjMyYmVcIlxuICBsZXQgYnl0ZV9sZW5ndGggXyA9IDRcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gU3RyaW5nLmdldF91dGZfMzJiZV91Y2hhclxuICBsZXQgc2V0ID0gQnl0ZXMuc2V0X3VjaGFyX3V0Zl8zMmJlXG5lbmQpXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBVY2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIigqKiBUaGUgcHVycG9zZSBvZiBbVHlwZV9lcXVhbF0gaXMgdG8gcmVwcmVzZW50IHR5cGUgZXF1YWxpdGllcyB0aGF0IHRoZSB0eXBlIGNoZWNrZXJcbiAgICBvdGhlcndpc2Ugd291bGQgbm90IGtub3csIHBlcmhhcHMgYmVjYXVzZSB0aGUgdHlwZSBlcXVhbGl0eSBkZXBlbmRzIG9uIGR5bmFtaWMgZGF0YSxcbiAgICBvciBwZXJoYXBzIGJlY2F1c2UgdGhlIHR5cGUgc3lzdGVtIGlzbid0IHBvd2VyZnVsIGVub3VnaC5cblxuICAgIEEgdmFsdWUgb2YgdHlwZSBbKGEsIGIpIFR5cGVfZXF1YWwudF0gcmVwcmVzZW50cyB0aGF0IHR5cGVzIFthXSBhbmQgW2JdIGFyZSBlcXVhbC5cbiAgICBPbmUgY2FuIHRoaW5rIG9mIHN1Y2ggYSB2YWx1ZSBhcyBhIHByb29mIG9mIHR5cGUgZXF1YWxpdHkuICBUaGUgW1R5cGVfZXF1YWxdIG1vZHVsZVxuICAgIGhhcyBvcGVyYXRpb25zIGZvciBjb25zdHJ1Y3RpbmcgYW5kIG1hbmlwdWxhdGluZyBzdWNoIHByb29mcy4gIEZvciBleGFtcGxlLCB0aGVcbiAgICBmdW5jdGlvbnMgW3JlZmxdLCBbc3ltXSwgYW5kIFt0cmFuc10gZXhwcmVzcyB0aGUgdXN1YWwgcHJvcGVydGllcyBvZiByZWZsZXhpdml0eSxcbiAgICBzeW1tZXRyeSwgYW5kIHRyYW5zaXRpdml0eSBvZiBlcXVhbGl0eS5cblxuICAgIElmIG9uZSBoYXMgYSB2YWx1ZSBbdCA6IChhLCBiKSBUeXBlX2VxdWFsLnRdIHRoYXQgcHJvdmVzIHR5cGVzIFthXSBhbmQgW2JdIGFyZSBlcXVhbCxcbiAgICB0aGVyZSBhcmUgdHdvIHdheXMgdG8gdXNlIFt0XSB0byBzYWZlbHkgY29udmVydCBhIHZhbHVlIG9mIHR5cGUgW2FdIHRvIGEgdmFsdWUgb2YgdHlwZVxuICAgIFtiXTogW1R5cGVfZXF1YWwuY29udl0gb3IgcGF0dGVybiBtYXRjaGluZyBvbiBbVHlwZV9lcXVhbC5UXTpcblxuICAgIHtbXG4gICAgICBsZXQgZiAodHlwZSBhKSAodHlwZSBiKSAodCA6IChhLCBiKSBUeXBlX2VxdWFsLnQpIChhIDogYSkgOiBiID1cbiAgICAgICAgVHlwZV9lcXVhbC5jb252IHQgYVxuXG4gICAgICBsZXQgZiAodHlwZSBhKSAodHlwZSBiKSAodCA6IChhLCBiKSBUeXBlX2VxdWFsLnQpIChhIDogYSkgOiBiID1cbiAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IHQgaW4gYVxuICAgIF19XG5cbiAgICBBdCBydW50aW1lLCBjb252ZXJzaW9uIGJ5IGVpdGhlciBtZWFucyBpcyBqdXN0IHRoZSBpZGVudGl0eSAtLSBub3RoaW5nIGlzIGNoYW5naW5nXG4gICAgYWJvdXQgdGhlIHZhbHVlLiAgQ29uc2lzdGVudCB3aXRoIHRoaXMsIGEgdmFsdWUgb2YgdHlwZSBbVHlwZV9lcXVhbC50XSBpcyBhbHdheXMganVzdFxuICAgIGEgY29uc3RydWN0b3IgW1R5cGVfZXF1YWwuVF07IHRoZSB2YWx1ZSBoYXMgbm8gaW50ZXJlc3Rpbmcgc2VtYW50aWMgY29udGVudC5cbiAgICBbVHlwZV9lcXVhbF0gZ2V0cyBpdHMgcG93ZXIgZnJvbSB0aGUgYWJpbGl0eSB0bywgaW4gYSB0eXBlLXNhZmUgd2F5LCBwcm92ZSB0byB0aGUgdHlwZVxuICAgIGNoZWNrZXIgdGhhdCB0d28gdHlwZXMgYXJlIGVxdWFsLiAgVGhlIFtUeXBlX2VxdWFsLnRdIHZhbHVlIHRoYXQgaXMgcGFzc2VkIGlzXG4gICAgbmVjZXNzYXJ5IGZvciB0aGUgdHlwZS1jaGVja2VyJ3MgcnVsZXMgdG8gYmUgY29ycmVjdCwgYnV0IHRoZSBjb21waWxlciBjb3VsZCwgaW5cbiAgICBwcmluY2lwbGUsIG5vdCBwYXNzIGFyb3VuZCB2YWx1ZXMgb2YgdHlwZSBbVHlwZV9lcXVhbC50XSBhdCBydW50aW1lLlxuKilcblxub3BlbiEgSW1wb3J0XG5vcGVuIFRcblxuKCoqLyoqKVxuXG5tb2R1bGUgVHlwZV9lcXVhbF9kZWZucyAoVHlwZV9lcXVhbCA6IFQuVDIpID0gc3RydWN0XG4gICgqKiBUaGUgW0xpZnQqXSBtb2R1bGUgdHlwZXMgYXJlIHVzZWQgYnkgdGhlIFtMaWZ0Kl0gZnVuY3RvcnMuIFNlZSBiZWxvdy4gKilcblxuICBtb2R1bGUgdHlwZSBMaWZ0ID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgbGlmdCA6ICgnYSwgJ2IpIFR5cGVfZXF1YWwudCAtPiAoJ2EgdCwgJ2IgdCkgVHlwZV9lcXVhbC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIExpZnQyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgbGlmdFxuICAgICAgOiAgKCdhMSwgJ2IxKSBUeXBlX2VxdWFsLnRcbiAgICAgIC0+ICgnYTIsICdiMikgVHlwZV9lcXVhbC50XG4gICAgICAtPiAoKCdhMSwgJ2EyKSB0LCAoJ2IxLCAnYjIpIHQpIFR5cGVfZXF1YWwudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBMaWZ0MyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBsaWZ0XG4gICAgICA6ICAoJ2ExLCAnYjEpIFR5cGVfZXF1YWwudFxuICAgICAgLT4gKCdhMiwgJ2IyKSBUeXBlX2VxdWFsLnRcbiAgICAgIC0+ICgnYTMsICdiMykgVHlwZV9lcXVhbC50XG4gICAgICAtPiAoKCdhMSwgJ2EyLCAnYTMpIHQsICgnYjEsICdiMiwgJ2IzKSB0KSBUeXBlX2VxdWFsLnRcbiAgZW5kXG5cbiAgKCoqIFtJbmplY3RpdmVdIGlzIGFuIGludGVyZmFjZSB0aGF0IHN0YXRlcyB0aGF0IGEgdHlwZSBpcyBpbmplY3RpdmUsIHdoZXJlIHRoZSB0eXBlIGlzXG4gICAgICB2aWV3ZWQgYXMgYSBmdW5jdGlvbiBmcm9tIHR5cGVzIHRvIG90aGVyIHR5cGVzLiBJdCBwcmVkYXRlcyBPQ2FtbCdzIHN1cHBvcnQgZm9yXG4gICAgICBleHBsaWNpdCBpbmplY3Rpdml0eSBhbm5vdGF0aW9ucyBpbiB0aGUgdHlwZSBzeXN0ZW0uXG5cbiAgICAgIFRoZSB0eXBpY2FsIHByaW9yIHVzYWdlIHdhczpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSAnYSB0XG4gICAgICAgIGluY2x1ZGUgSW5qZWN0aXZlIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICAgIF19XG5cbiAgICAgIEZvciBleGFtcGxlLCBbJ2EgbGlzdF0gaXMgYW4gaW5qZWN0aXZlIHR5cGUsIGJlY2F1c2Ugd2hlbmV2ZXIgWydhIGxpc3QgPSAnYiBsaXN0XSxcbiAgICAgIHdlIGtub3cgdGhhdCBbJ2FdID0gWydiXS4gT24gdGhlIG90aGVyIGhhbmQsIGlmIHdlIGRlZmluZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSAnYSB0ID0gdW5pdFxuICAgICAgXX1cblxuICAgICAgdGhlbiBjbGVhcmx5IFt0XSBpc24ndCBpbmplY3RpdmUsIGJlY2F1c2UsIGUuZy4sIFtpbnQgdCA9IGJvb2wgdF0sIGJ1dFxuICAgICAgW2ludCA8PiBib29sXS5cblxuICAgICAgSWYgW21vZHVsZSBNIDogSW5qZWN0aXZlXSwgdGhlbiBbTS5zdHJpcF0gcHJvdmlkZXMgYSB3YXkgdG8gZ2V0IGEgcHJvb2YgdGhhdCB0d29cbiAgICAgIHR5cGVzIGFyZSBlcXVhbCBmcm9tIGEgcHJvb2YgdGhhdCBib3RoIHR5cGVzIHRyYW5zZm9ybWVkIGJ5IFtNLnRdIGFyZSBlcXVhbC4gQVxuICAgICAgdHlwaWNhbCBpbXBsZW1lbnRhdGlvbiBsb29rZWQgbGlrZSB0aGlzOlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgc3RyaXAgKHR5cGUgYSkgKHR5cGUgYilcbiAgICAgICAgICAgICAgKFR5cGVfZXF1YWwuVCA6IChhIHQsIGIgdCkgVHlwZV9lcXVhbC50KSA6IChhLCBiKSBUeXBlX2VxdWFsLnQgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuVFxuICAgICAgXX1cblxuICAgICAgVGhpcyB3aWxsIG5vdCB0eXBlIGNoZWNrIGZvciBhbGwgdHlwZSBjb25zdHJ1Y3RvcnMgKGNlcnRhaW5seSBub3QgZm9yIG5vbi1pbmplY3RpdmVcbiAgICAgIG9uZXMhKSwgYnV0IGl0J3MgYWx3YXlzIHNhZmUgdG8gdHJ5IHRoZSBhYm92ZSBpbXBsZW1lbnRhdGlvbiBpZiB5b3UgYXJlIHVuc3VyZS4gSWZcbiAgICAgIE9DYW1sIGFjY2VwdHMgdGhpcyBkZWZpbml0aW9uLCB0aGVuIHRoZSB0eXBlIGlzIGluamVjdGl2ZS4gT24gdGhlIG90aGVyIGhhbmQsIGlmXG4gICAgICBPQ2FtbCBkb2Vzbid0LCB0aGVuIHRoZSB0eXBlIG1heSBvciBtYXkgbm90IGJlIGluamVjdGl2ZS4gRm9yIGV4YW1wbGUsIGlmIHRoZVxuICAgICAgZGVmaW5pdGlvbiBvZiB0aGUgdHlwZSBkZXBlbmRzIG9uIGFic3RyYWN0IHR5cGVzIHRoYXQgbWF0Y2ggW0luamVjdGl2ZV0sIE9DYW1sIHdpbGxcbiAgICAgIG5vdCBhdXRvbWF0aWNhbGx5IHVzZSB0aGVpciBpbmplY3Rpdml0eSwgYW5kIG9uZSB3aWxsIGhhdmUgdG8gd3JpdGUgYSBtb3JlXG4gICAgICBjb21wbGljYXRlZCBkZWZpbml0aW9uIG9mIFtzdHJpcF0gdGhhdCBjYXVzZXMgT0NhbWwgdG8gdXNlIHRoYXQgZmFjdC4gRm9yIGV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIG1vZHVsZSBGIChNIDogVHlwZV9lcXVhbC5JbmplY3RpdmUpIDogVHlwZV9lcXVhbC5JbmplY3RpdmUgPSBzdHJ1Y3RcbiAgICAgICAgICB0eXBlICdhIHQgPSAnYSBNLnQgKiBpbnRcblxuICAgICAgICAgIGxldCBzdHJpcCAodHlwZSBhKSAodHlwZSBiKVxuICAgICAgICAgICAgICAgIChlIDogKGEgdCwgYiB0KSBUeXBlX2VxdWFsLnQpIDogKGEsIGIpIFR5cGVfZXF1YWwudCA9XG4gICAgICAgICAgICBsZXQgZTEsIF8gPSBUeXBlX2VxdWFsLmRldHVwbGUyIGUgaW5cbiAgICAgICAgICAgIE0uc3RyaXAgZTFcbiAgICAgICAgICA7O1xuICAgICAgICBlbmRcbiAgICAgIF19XG5cbiAgICAgIElmIGluIHRoZSBkZWZpbml0aW9uIG9mIFtGXSB3ZSBoYWQgd3JpdHRlbiB0aGUgc2ltcGxlciBpbXBsZW1lbnRhdGlvbiBvZiBbc3RyaXBdIHRoYXRcbiAgICAgIGRpZG4ndCB1c2UgW00uc3RyaXBdLCB0aGVuIE9DYW1sIHdvdWxkIGhhdmUgcmVwb3J0ZWQgYSB0eXBlIGVycm9yLlxuICAqKVxuICBtb2R1bGUgdHlwZSBJbmplY3RpdmUgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBzdHJpcCA6ICgnYSB0LCAnYiB0KSBUeXBlX2VxdWFsLnQgLT4gKCdhLCAnYikgVHlwZV9lcXVhbC50XG4gIGVuZFxuICBbQEBkZXByZWNhdGVkXG4gICAgXCJbc2luY2UgMjAyMy0wOF0gT0NhbWwgbm93IHN1cHBvcnRzIGluamVjdGl2aXR5IGFubm90YXRpb25zLiBbdHlwZSAhJ2EgdF0gZGVjbGFyZXMgXFxcbiAgICAgdGhhdCBbJ2EgdF0gaXMgaW5qZWN0aXZlIHdpdGggcmVzcGVjdCB0byBbJ2FdLlwiXVxuXG4gICgqKiBbSW5qZWN0aXZlMl0gaXMgZm9yIGEgYmluYXJ5IHR5cGUgdGhhdCBpcyBpbmplY3RpdmUgaW4gYm90aCB0eXBlIGFyZ3VtZW50cy4gKilcbiAgbW9kdWxlIHR5cGUgSW5qZWN0aXZlMiA9IHNpZ1xuICAgIHR5cGUgKCdhMSwgJ2EyKSB0XG5cbiAgICB2YWwgc3RyaXBcbiAgICAgIDogICgoJ2ExLCAnYTIpIHQsICgnYjEsICdiMikgdCkgVHlwZV9lcXVhbC50XG4gICAgICAtPiAoJ2ExLCAnYjEpIFR5cGVfZXF1YWwudCAqICgnYTIsICdiMikgVHlwZV9lcXVhbC50XG4gIGVuZFxuICBbQEBkZXByZWNhdGVkXG4gICAgXCJbc2luY2UgMjAyMy0wOF0gT0NhbWwgbm93IHN1cHBvcnRzIGluamVjdGl2aXR5IGFubm90YXRpb25zLiBbdHlwZSAhJ2EgdF0gZGVjbGFyZXMgXFxcbiAgICAgdGhhdCBbJ2EgdF0gaXMgaW5qZWN0aXZlIHdpdGggcmVzcGVjdCB0byBbJ2FdLlwiXVxuXG4gICgqKiBbQ29tcG9zaXRpb25fcHJlc2VydmVzX2luamVjdGl2aXR5XSBpcyBhIGZ1bmN0b3IgdGhhdCBwcm92ZXMgdGhhdCBjb21wb3NpdGlvbiBvZlxuICAgICAgaW5qZWN0aXZlIHR5cGVzIGlzIGluamVjdGl2ZS4gKilcbiAgbW9kdWxlIENvbXBvc2l0aW9uX3ByZXNlcnZlc19pbmplY3Rpdml0eSAoTTEgOiBJbmplY3RpdmUpIChNMiA6IEluamVjdGl2ZSkgOlxuICAgIEluamVjdGl2ZSB3aXRoIHR5cGUgJ2EgdCA9ICdhIE0xLnQgTTIudCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIE0xLnQgTTIudFxuXG4gICAgbGV0IHN0cmlwIGUgPSBNMS5zdHJpcCAoTTIuc3RyaXAgZSlcbiAgZW5kXG4gIFtAQGFsZXJ0IFwiLWRlcHJlY2F0ZWRcIl1cbiAgW0BAZGVwcmVjYXRlZFxuICAgIFwiW3NpbmNlIDIwMjMtMDhdIE9DYW1sIG5vdyBzdXBwb3J0cyBpbmplY3Rpdml0eSBhbm5vdGF0aW9ucy4gW3R5cGUgISdhIHRdIGRlY2xhcmVzIFxcXG4gICAgIHRoYXQgWydhIHRdIGlzIGluamVjdGl2ZSB3aXRoIHJlc3BlY3QgdG8gWydhXS5cIl1cbmVuZFxuXG5tb2R1bGUgVHlwZV9lcXVhbF9pZF9kZWZucyAoSWQgOiBzaWdcbiAgdHlwZSAnYSB0XG5lbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgdHlwZSBBcmcwID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIG5hbWUgOiBzdHJpbmdcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQXJnMSA9IHNpZ1xuICAgIHR5cGUgISdhIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgbmFtZSA6IHN0cmluZ1xuICBlbmRcblxuICBtb2R1bGUgdHlwZSBBcmcyID0gc2lnXG4gICAgdHlwZSAoISdhLCAhJ2IpIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEFyZzMgPSBzaWdcbiAgICB0eXBlICghJ2EsICEnYiwgISdjKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2MgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMwID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgdHlwZV9lcXVhbF9pZCA6IHQgSWQudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHR5cGVfZXF1YWxfaWQgOiAnYSBJZC50IC0+ICdhIHQgSWQudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIHR5cGVfZXF1YWxfaWQgOiAnYSBJZC50IC0+ICdiIElkLnQgLT4gKCdhLCAnYikgdCBJZC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIHR5cGVfZXF1YWxfaWQgOiAnYSBJZC50IC0+ICdiIElkLnQgLT4gJ2MgSWQudCAtPiAoJ2EsICdiLCAnYykgdCBJZC50XG4gIGVuZFxuZW5kXG5cbigqKi8qKilcblxubW9kdWxlIHR5cGUgVHlwZV9lcXVhbCA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHQgPSBUIDogKCdhLCAnYSkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90XG4gICAgOiAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuXG4gICgqKiBqdXN0IGFuIGFsaWFzLCBuZWVkZWQgd2hlbiBbdF0gZ2V0cyBzaGFkb3dlZCBiZWxvdyAqKVxuICB0eXBlICgnYSwgJ2IpIGVxdWFsIDo9ICgnYSwgJ2IpIHRcblxuICAoKiogQGlubGluZSAqKVxuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIFR5cGVfZXF1YWxfZGVmbnMgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIGVxdWFsXG4gIGVuZClcblxuICAoKiogW3JlZmxdLCBbc3ltXSwgYW5kIFt0cmFuc10gY29uc3RydWN0IHByb29mcyB0aGF0IHR5cGUgZXF1YWxpdHkgaXMgcmVmbGV4aXZlLFxuICAgICAgc3ltbWV0cmljLCBhbmQgdHJhbnNpdGl2ZS4gKilcblxuICB2YWwgcmVmbCA6ICgnYSwgJ2EpIHRcbiAgdmFsIHN5bSA6ICgnYSwgJ2IpIHQgLT4gKCdiLCAnYSkgdFxuICB2YWwgdHJhbnMgOiAoJ2EsICdiKSB0IC0+ICgnYiwgJ2MpIHQgLT4gKCdhLCAnYykgdFxuXG4gICgqKiBbY29udiB0IHhdIHVzZXMgdGhlIHR5cGUgZXF1YWxpdHkgW3QgOiAoYSwgYikgdF0gYXMgZXZpZGVuY2UgdG8gc2FmZWx5IGNhc3QgW3hdXG4gICAgICBmcm9tIHR5cGUgW2FdIHRvIHR5cGUgW2JdLiAgW2NvbnZdIGlzIHNlbWFudGljYWxseSBqdXN0IHRoZSBpZGVudGl0eSBmdW5jdGlvbi5cblxuICAgICAgSW4gYSBwcm9ncmFtIHRoYXQgaGFzIFt0IDogKGEsIGIpIHRdIHdoZXJlIG9uZSBoYXMgYSB2YWx1ZSBvZiB0eXBlIFthXSB0aGF0IG9uZVxuICAgICAgd2FudHMgdG8gdHJlYXQgYXMgYSB2YWx1ZSBvZiB0eXBlIFtiXSwgaXQgaXMgb2Z0ZW4gc3VmZmljaWVudCB0byBwYXR0ZXJuIG1hdGNoIG9uXG4gICAgICBbVHlwZV9lcXVhbC5UXSByYXRoZXIgdGhhbiB1c2UgW2NvbnZdLiBIb3dldmVyLCB0aGVyZSBhcmUgc2l0dWF0aW9ucyB3aGVyZSBPQ2FtbCdzXG4gICAgICB0eXBlIGNoZWNrZXIgd2lsbCBub3QgdXNlIHRoZSB0eXBlIGVxdWFsaXR5IFthID0gYl0sIGFuZCBvbmUgbXVzdCB1c2UgW2NvbnZdLiBGb3JcbiAgICAgIGV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIG1vZHVsZSBGIChNMSA6IHNpZyB0eXBlIHQgZW5kKSAoTTIgOiBzaWcgdHlwZSB0IGVuZCkgOiBzaWdcbiAgICAgICAgICB2YWwgZiA6IChNMS50LCBNMi50KSBlcXVhbCAtPiBNMS50IC0+IE0yLnRcbiAgICAgICAgZW5kID0gc3RydWN0XG4gICAgICAgICAgbGV0IGYgZXF1YWwgKG0xIDogTTEudCkgPSBjb252IGVxdWFsIG0xXG4gICAgICAgIGVuZFxuICAgICAgXX1cblxuICAgICAgSWYgb25lIHdyb3RlIHRoZSBib2R5IG9mIFtGXSB1c2luZyBwYXR0ZXJuIG1hdGNoaW5nIG9uIFtUXTpcblxuICAgICAge1tcbiAgICAgICAgbGV0IGYgKFQgOiAoTTEudCwgTTIudCkgZXF1YWwpIChtMSA6IE0xLnQpID0gKG0xIDogTTIudClcbiAgICAgIF19XG5cbiAgICAgIHRoaXMgd291bGQgZ2l2ZSBhIHR5cGUgZXJyb3IuICopXG4gIHZhbCBjb252IDogKCdhLCAnYikgdCAtPiAnYSAtPiAnYlxuXG4gICgqKiBJdCBpcyBhbHdheXMgc2FmZSB0byBjb25jbHVkZSB0aGF0IGlmIHR5cGUgW2FdIGVxdWFscyBbYl0sIHRoZW4gZm9yIGFueSB0eXBlIFsnYSB0XSxcbiAgICAgIHR5cGUgW2EgdF0gZXF1YWxzIFtiIHRdLiBUaGUgT0NhbWwgdHlwZSBjaGVja2VyIHVzZXMgdGhpcyBmYWN0IHdoZW4gaXQgY2FuLiBIb3dldmVyLFxuICAgICAgc29tZXRpbWVzLCBlLmcuLCB3aGVuIHVzaW5nIFtjb252XSwgb25lIG5lZWRzIHRvIGV4cGxpY2l0bHkgdXNlIHRoaXMgZmFjdCB0b1xuICAgICAgY29uc3RydWN0IGFuIGFwcHJvcHJpYXRlIFtUeXBlX2VxdWFsLnRdLiBUaGUgW0xpZnQqXSBmdW5jdG9ycyBkbyB0aGlzLiAqKVxuXG4gIG1vZHVsZSBMaWZ0IChUIDogVDEpIDogTGlmdCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnRcbiAgbW9kdWxlIExpZnQyIChUIDogVDIpIDogTGlmdDIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgVC50XG4gIG1vZHVsZSBMaWZ0MyAoVCA6IFQzKSA6IExpZnQzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgVC50XG5cbiAgKCoqIFt0dXBsZTJdIGFuZCBbZGV0dXBsZTJdIGNvbnZlcnQgYmV0d2VlbiBlcXVhbGl0eSBvbiBhIDItdHVwbGUgYW5kIGl0cyBjb21wb25lbnRzLiAqKVxuXG4gIHZhbCBkZXR1cGxlMiA6ICgnYTEgKiAnYTIsICdiMSAqICdiMikgdCAtPiAoJ2ExLCAnYjEpIHQgKiAoJ2EyLCAnYjIpIHRcbiAgdmFsIHR1cGxlMiA6ICgnYTEsICdiMSkgdCAtPiAoJ2EyLCAnYjIpIHQgLT4gKCdhMSAqICdhMiwgJ2IxICogJ2IyKSB0XG5cbiAgKCoqIFtJZF0gcHJvdmlkZXMgaWRlbnRpZmllcnMgZm9yIHR5cGVzLCBhbmQgdGhlIGFiaWxpdHkgdG8gdGVzdCAodmlhIFtJZC5zYW1lXSkgYXRcbiAgICAgIHJ1bnRpbWUgaWYgdHdvIGlkZW50aWZpZXJzIGFyZSBlcXVhbCwgYW5kIGlmIHNvIHRvIGdldCBhIHByb29mIG9mIGVxdWFsaXR5IG9mIHRoZWlyXG4gICAgICB0eXBlcy4gIFVubGlrZSB2YWx1ZXMgb2YgdHlwZSBbVHlwZV9lcXVhbC50XSwgdmFsdWVzIG9mIHR5cGUgW0lkLnRdIGRvIGhhdmUgc2VtYW50aWNcbiAgICAgIGNvbnRlbnQgYW5kIG11c3QgaGF2ZSBhIG5vbnRyaXZpYWwgcnVudGltZSByZXByZXNlbnRhdGlvbi4gKilcbiAgbW9kdWxlIElkIDogc2lnXG4gICAgdHlwZSAnYSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgKCoqIEBpbmxpbmUgKilcbiAgICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIFR5cGVfZXF1YWxfaWRfZGVmbnMgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcbiAgICBlbmQpXG5cbiAgICAoKiogRXZlcnkgW0lkLnRdIGNvbnRhaW5zIGEgdW5pcXVlIGlkIHRoYXQgaXMgZGlzdGluY3QgZnJvbSB0aGUgW1VpZC50XSBpbiBhbnkgb3RoZXJcbiAgICAgICAgW0lkLnRdLiAqKVxuICAgIG1vZHVsZSBVaWQgOiBzaWdcbiAgICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cF9vZl1cblxuICAgICAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgICBbQEBAZW5kXVxuXG4gICAgICBpbmNsdWRlIENvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gICAgZW5kXG5cbiAgICB2YWwgdWlkIDogXyB0IC0+IFVpZC50XG5cbiAgICAoKiogW2NyZWF0ZSB+bmFtZV0gZGVmaW5lcyBhIG5ldyB0eXBlIGlkZW50aXR5LiBUd28gY2FsbHMgdG8gW2NyZWF0ZV0gd2lsbCByZXN1bHQgaW5cbiAgICAgICAgdHdvIGRpc3RpbmN0IGlkZW50aWZpZXJzLCBldmVuIGZvciB0aGUgc2FtZSBhcmd1bWVudHMgd2l0aCB0aGUgc2FtZSB0eXBlLiBJZiB0aGVcbiAgICAgICAgdHlwZSBbJ2FdIGRvZXNuJ3Qgc3VwcG9ydCBzZXhwIGNvbnZlcnNpb24sIHRoZW4gYSBnb29kIHByYWN0aWNlIGlzIHRvIGhhdmUgdGhlXG4gICAgICAgIGNvbnZlcnRlciBiZSBbWyVzZXhwX29mOiBfXV0sIChvciBbc2V4cF9vZl9vcGFxdWVdLCBpZiBub3QgdXNpbmcgcHB4X3NleHBfY29udikuXG4gICAgKilcbiAgICB2YWwgY3JlYXRlIDogbmFtZTpzdHJpbmcgLT4gKCdhIC0+IFNleHAudCkgLT4gJ2EgdFxuXG4gICAgKCoqIEFjY2Vzc29ycyAqKVxuXG4gICAgdmFsIGhhc2ggOiBfIHQgLT4gaW50XG4gICAgdmFsIG5hbWUgOiBfIHQgLT4gc3RyaW5nXG4gICAgdmFsIHRvX3NleHAgOiAnYSB0IC0+ICdhIC0+IFNleHAudFxuICAgIHZhbCBoYXNoX2ZvbGRfdCA6IEhhc2guc3RhdGUgLT4gXyB0IC0+IEhhc2guc3RhdGVcblxuICAgICgqKiBbc2FtZV93aXRuZXNzIHQxIHQyXSBhbmQgW3NhbWVfd2l0bmVzc19leG4gdDEgdDJdIHJldHVybiBhIHR5cGUgZXF1YWxpdHkgcHJvb2YgaWZmXG4gICAgICAgIHRoZSB0d28gaWRlbnRpZmllcnMgYXJlIHRoZSBzYW1lIChpLmUuLCBwaHlzaWNhbGx5IGVxdWFsLCByZXN1bHRpbmcgZnJvbSB0aGUgc2FtZVxuICAgICAgICBjYWxsIHRvIFtjcmVhdGVdKS4gIFRoaXMgaXMgYSB1c2VmdWwgd2F5IHRvIGFjaGlldmUgYSBzb3J0IG9mIGR5bmFtaWMgdHlwaW5nLlxuICAgICAgICBbc2FtZV93aXRuZXNzXSBkb2VzIG5vdCBhbGxvY2F0ZSBhIFtTb21lXSBldmVyeSB0aW1lIGl0IGlzIGNhbGxlZC5cblxuICAgICAgICBbc2FtZSB0MSB0MiA9IGlzX3NvbWUgKHNhbWVfd2l0bmVzcyB0MSB0MildLlxuICAgICopXG5cbiAgICB2YWwgc2FtZSA6IF8gdCAtPiBfIHQgLT4gYm9vbFxuICAgIHZhbCBzYW1lX3dpdG5lc3MgOiAnYSB0IC0+ICdiIHQgLT4gKCdhLCAnYikgZXF1YWwgb3B0aW9uXG4gICAgdmFsIHNhbWVfd2l0bmVzc19leG4gOiAnYSB0IC0+ICdiIHQgLT4gKCdhLCAnYikgZXF1YWxcblxuICAgIG1vZHVsZSBDcmVhdGUwIChUIDogQXJnMCkgOiBTMCB3aXRoIHR5cGUgdCA6PSBULnRcbiAgICBtb2R1bGUgQ3JlYXRlMSAoVCA6IEFyZzEpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50XG4gICAgbW9kdWxlIENyZWF0ZTIgKFQgOiBBcmcyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIFQudFxuICAgIG1vZHVsZSBDcmVhdGUzIChUIDogQXJnMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIFQudFxuICBlbmRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdhLCAnYikgdCA9IFQgOiAoJ2EsICdhKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90IDpcbiAgICAgICdhICdiLlxuICAgICAgKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDAzXyBiX18wMDRfKVxuICAgIDogICgoYV9fMDAzXyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChiX18wMDRfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoYV9fMDAzXywgYl9fMDA0XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gIGZ1biBfb2ZfYV9fMDAxXyBfb2ZfYl9fMDAyXyBUIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlRcIlxuOztcblxuW0BAQGVuZF1cblxudHlwZSAoJ2EsICdiKSBlcXVhbCA9ICgnYSwgJ2IpIHRcblxuaW5jbHVkZSBUeXBlX2VxdWFsX2ludGYuVHlwZV9lcXVhbF9kZWZucyAoc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIGVxdWFsXG5lbmQpXG5cbmxldCByZWZsID0gVFxubGV0IHN5bSAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGIsIGEpIHQgPSBUXG5sZXQgdHJhbnMgKHR5cGUgYSBiIGMpIChUIDogKGEsIGIpIHQpIChUIDogKGIsIGMpIHQpIDogKGEsIGMpIHQgPSBUXG5sZXQgY29udiAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIChhIDogYSkgOiBiID0gYVxuXG5tb2R1bGUgTGlmdCAoWCA6IHNpZ1xuICB0eXBlICdhIHRcbmVuZCkgPVxuc3RydWN0XG4gIGxldCBsaWZ0ICh0eXBlIGEgYikgKFQgOiAoYSwgYikgdCkgOiAoYSBYLnQsIGIgWC50KSB0ID0gVFxuZW5kXG5cbm1vZHVsZSBMaWZ0MiAoWCA6IHNpZ1xuICB0eXBlICgnYTEsICdhMikgdFxuZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYTEgYjEgYTIgYjIpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KVxuICAgIDogKChhMSwgYTIpIFgudCwgKGIxLCBiMikgWC50KSB0XG4gICAgPVxuICAgIFRcbiAgOztcbmVuZFxuXG5tb2R1bGUgTGlmdDMgKFggOiBzaWdcbiAgdHlwZSAoJ2ExLCAnYTIsICdhMykgdFxuZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYTEgYjEgYTIgYjIgYTMgYjMpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KSAoVCA6IChhMywgYjMpIHQpXG4gICAgOiAoKGExLCBhMiwgYTMpIFgudCwgKGIxLCBiMiwgYjMpIFgudCkgdFxuICAgID1cbiAgICBUXG4gIDs7XG5lbmRcblxubGV0IGRldHVwbGUyICh0eXBlIGExIGEyIGIxIGIyKSAoVCA6IChhMSAqIGEyLCBiMSAqIGIyKSB0KSA6IChhMSwgYjEpIHQgKiAoYTIsIGIyKSB0ID1cbiAgVCwgVFxuOztcblxubGV0IHR1cGxlMiAodHlwZSBhMSBhMiBiMSBiMikgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpIDogKGExICogYTIsIGIxICogYjIpIHQgPSBUXG5cbm1vZHVsZSBJZCA9IHN0cnVjdFxuICAoKiBba2V5XSBpcyBhbiBleHRlbnNpYmxlIEdBRFQgdXNlZCB0byBtaW50LCBhbmQgcGF0dGVybiBtYXRjaCBvbiwgdHlwZSB3aXRuZXNzZXMuICopXG4gIHR5cGUgXyBrZXkgPSAuLlxuXG4gIG1vZHVsZSBVaWQgPSBzdHJ1Y3RcbiAgICAoKiBBIHVuaXF1ZSBpZCBjb250YWlucyBhbiBbaW50XSByZXByZXNlbnRpbmcgYSAocG9zc2libHkgcGFyYW1ldGVyaXplZCkgdHlwZSwgYW5kIGFcbiAgICAgICBsaXN0IG9mIHVpZHMgZm9yIHRoZSBwYXJhbWV0ZXJzIHRvIHRoYXQgdHlwZS4gKilcbiAgICB0eXBlIHQgPSBUIG9mIGludCAqIHQgbGlzdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cF9vZl1cblxuICAgIGxldCByZWMgY29tcGFyZSA9XG4gICAgICAoZnVuIGFfXzAwNV8gYl9fMDA2XyAtPlxuICAgICAgICAgaWYgU3RkbGliLiggPT0gKSBhX18wMDVfIGJfXzAwNl9cbiAgICAgICAgIHRoZW4gMFxuICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgIG1hdGNoIGFfXzAwNV8sIGJfXzAwNl8gd2l0aFxuICAgICAgICAgICB8IFQgKF9hX18wMDdfLCBfYV9fMDA5XyksIFQgKF9iX18wMDhfLCBfYl9fMDEwXykgLT5cbiAgICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9pbnQgX2FfXzAwN18gX2JfXzAwOF8gd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gY29tcGFyZV9saXN0IGNvbXBhcmUgX2FfXzAwOV8gX2JfXzAxMF9cbiAgICAgICAgICAgICAgfCBuIC0+IG4pKVxuICAgICAgICA6IHQgLT4gdCAtPiBpbnQpXG4gICAgOztcblxuICAgIGxldCByZWMgKGhhc2hfZm9sZF90IDpcbiAgICAgICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgPVxuICAgICAgKGZ1biBoc3YgYXJnIC0+XG4gICAgICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgICAgfCBUIChfYTAsIF9hMSkgLT5cbiAgICAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgICAgICAgaGFzaF9mb2xkX2ludCBoc3YgX2EwXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGhhc2hfZm9sZF9saXN0IGhhc2hfZm9sZF90IGhzdiBfYTFcbiAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyBhcmcgPVxuICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgICAgIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBzZXhwX29mX3QgPVxuICAgICAgKGZ1biAoVCAoYXJnMF9fMDEzXywgYXJnMV9fMDE0XykpIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDE1XyA9IHNleHBfb2ZfaW50IGFyZzBfXzAxM19cbiAgICAgICAgIGFuZCByZXMxX18wMTZfID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfdCBhcmcxX18wMTRfIGluXG4gICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUXCI7IHJlczBfXzAxNV87IHJlczFfXzAxNl8gXVxuICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gICAgICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gICAgZW5kKVxuXG4gICAgKCogV2UgdXNlIHRoZSBleHRlbnNpb24gY29uc3RydWN0b3IgaWQgZm9yIGEgW2tleV0gYXMgdGhlIHVuaXF1ZSBpZCBmb3IgaXRzIHR5cGUuICopXG4gICAgbGV0IGNyZWF0ZSAoa2V5IDogXyBrZXkpIGFyZ3MgPVxuICAgICAgbGV0IHRhZyA9XG4gICAgICAgIFN0ZGxpYi5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkIChTdGRsaWIuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwga2V5KVxuICAgICAgaW5cbiAgICAgIFQgKHRhZywgYXJncylcbiAgICA7O1xuICBlbmRcblxuICAoKiBFdmVyeSB0eXBlLWVxdWFsIGlkIG11c3Qgc3VwcG9ydCB0aGVzZSBvcGVyYXRpb25zLiAqKVxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICAoKiBIb3cgdG8gcmVuZGVyIHZhbHVlcyBvZiB0aGUgdHlwZS4gKilcbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwLnRcblxuICAgICgqIEEgdW5pcXVlIGlkIGZvciB0aGlzIHR5cGUuICopXG4gICAgdmFsIHVpZCA6IFVpZC50XG5cbiAgICAoKiBOYW1lIG9mIHRoZSB0eXBlLWVxdWFsIGlkLiAqKVxuICAgIHZhbCBpZF9uYW1lIDogc3RyaW5nXG5cbiAgICAoKiBTZXhwIG9mIHRoZSB0eXBlLWVxdWFsIGlkLiAqKVxuICAgIHZhbCBpZF9zZXhwIDogU2V4cC50XG5cbiAgICAoKiBba2V5XSB2YWx1ZSBmb3IgdGhlIHR5cGUuICopXG4gICAgdmFsIHR5cGVfa2V5IDogdCBrZXlcblxuICAgICgqIHR5cGUgZXF1YWxpdHk6IGdpdmVuIGFub3RoZXIga2V5LCBwcm9kdWNlIGFuIFtlcXVhbF0gaWYgdGhleSByZXByZXNlbnQgdGhlIHNhbWVcbiAgICAgICB0eXBlIGluc3RhbmNlICopXG4gICAgdmFsIHR5cGVfZXF1YWwgOiAnYSBrZXkgLT4gKHQsICdhKSBlcXVhbCBvcHRpb25cbiAgZW5kXG5cbiAgKCogQW4gW0lkLnRdIGlzIGEgZmlyc3QtY2xhc3MgbW9kdWxlIGltcGxlbWVudGluZyB0aGUgYWJvdmUgb3BlcmF0aW9ucy4gKilcbiAgdHlwZSAnYSB0ID0gKG1vZHVsZSBTIHdpdGggdHlwZSB0ID0gJ2EpXG5cbiAgbGV0IHVpZCAodHlwZSBhKSAoKG1vZHVsZSBBKSA6IGEgdCkgPSBBLnVpZFxuICBsZXQgbmFtZSAodHlwZSBhKSAoKG1vZHVsZSBBKSA6IGEgdCkgPSBBLmlkX25hbWVcbiAgbGV0IHNleHBfb2ZfdCAodHlwZSBhKSBfICgobW9kdWxlIEEpIDogYSB0KSA9IEEuaWRfc2V4cFxuICBsZXQgdG9fc2V4cCAodHlwZSBhKSAoKG1vZHVsZSBBKSA6IGEgdCkgPSBBLnNleHBfb2ZfdFxuICBsZXQgaGFzaCB0ID0gVWlkLmhhc2ggKHVpZCB0KVxuICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9IFVpZC5oYXNoX2ZvbGRfdCBzdGF0ZSAodWlkIHQpXG5cbiAgbGV0IHNhbWVfd2l0bmVzcyAodHlwZSBhIGIpICgobW9kdWxlIEEpIDogYSB0KSAoKG1vZHVsZSBCKSA6IGIgdCkgPVxuICAgIEEudHlwZV9lcXVhbCBCLnR5cGVfa2V5XG4gIDs7XG5cbiAgbGV0IHNhbWVfd2l0bmVzc19leG4gdDEgdDIgPVxuICAgIG1hdGNoIHNhbWVfd2l0bmVzcyB0MSB0MiB3aXRoXG4gICAgfCBTb21lIGVxdWFsIC0+IGVxdWFsXG4gICAgfCBOb25lIC0+XG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJUeXBlX2VxdWFsLklkLnNhbWVfd2l0bmVzc19leG4gZ290IGRpZmZlcmVudCBpZHNcIlxuICAgICAgICAgICBbICggXCJcIlxuICAgICAgICAgICAgICwgc2V4cF9vZl9wYWlyIChzZXhwX29mX3Qgc2V4cF9vZl9vcGFxdWUpIChzZXhwX29mX3Qgc2V4cF9vZl9vcGFxdWUpICh0MSwgdDIpXG4gICAgICAgICAgICAgKVxuICAgICAgICAgICBdKVxuICA7O1xuXG4gIGxldCBzYW1lIHQxIHQyID1cbiAgICBtYXRjaCBzYW1lX3dpdG5lc3MgdDEgdDIgd2l0aFxuICAgIHwgU29tZSBfIC0+IHRydWVcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgOztcblxuICBpbmNsdWRlIFR5cGVfZXF1YWxfaW50Zi5UeXBlX2VxdWFsX2lkX2RlZm5zIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuICBlbmQpXG5cbiAgbW9kdWxlIENyZWF0ZTAgKFQgOiBBcmcwKSA9IHN0cnVjdFxuICAgIHR5cGUgXyBrZXkgKz0gVDAgOiBULnQga2V5XG5cbiAgICBsZXQgdHlwZV9lcXVhbF9pZCA6IFQudCB0ID1cbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IFQudFxuXG4gICAgICAgIGxldCBpZF9uYW1lID0gVC5uYW1lXG4gICAgICAgIGxldCBpZF9zZXhwID0gU2V4cC5BdG9tIGlkX25hbWVcbiAgICAgICAgbGV0IHNleHBfb2ZfdCA9IFQuc2V4cF9vZl90XG4gICAgICAgIGxldCB0eXBlX2tleSA9IFQwXG4gICAgICAgIGxldCB1aWQgPSBVaWQuY3JlYXRlIHR5cGVfa2V5IFtdXG5cbiAgICAgICAgbGV0IHR5cGVfZXF1YWwgKHR5cGUgb3RoZXIpIChvdGhlcmtleSA6IG90aGVyIGtleSkgOiAodCwgb3RoZXIpIGVxdWFsIG9wdGlvbiA9XG4gICAgICAgICAgbWF0Y2ggb3RoZXJrZXkgd2l0aFxuICAgICAgICAgIHwgVDAgLT4gU29tZSBUXG4gICAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgICAgOztcbiAgICAgIGVuZClcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgQ3JlYXRlMSAoVCA6IEFyZzEpID0gc3RydWN0XG4gICAgdHlwZSBfIGtleSArPSBUMSA6ICdhIGtleSAtPiAnYSBULnQga2V5XG5cbiAgICBsZXQgdHlwZV9lcXVhbF9pZCAodHlwZSBhKSAoKG1vZHVsZSBBKSA6IGEgdCkgOiBhIFQudCB0ID1cbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEEudCBULnRcblxuICAgICAgICBsZXQgaWRfbmFtZSA9IFQubmFtZVxuICAgICAgICBsZXQgaWRfc2V4cCA9IFNleHAuTGlzdCBbIEF0b20gaWRfbmFtZTsgQS5pZF9zZXhwIF1cbiAgICAgICAgbGV0IHNleHBfb2ZfdCB0ID0gVC5zZXhwX29mX3QgQS5zZXhwX29mX3QgdFxuICAgICAgICBsZXQgdHlwZV9rZXkgPSBUMSBBLnR5cGVfa2V5XG4gICAgICAgIGxldCB1aWQgPSBVaWQuY3JlYXRlIHR5cGVfa2V5IFsgQS51aWQgXVxuXG4gICAgICAgIGxldCB0eXBlX2VxdWFsICh0eXBlIG90aGVyKSAob3RoZXJrZXkgOiBvdGhlciBrZXkpIDogKHQsIG90aGVyKSBlcXVhbCBvcHRpb24gPVxuICAgICAgICAgIG1hdGNoIG90aGVya2V5IHdpdGhcbiAgICAgICAgICB8IFQxIGFrZXkgLT5cbiAgICAgICAgICAgIChtYXRjaCBBLnR5cGVfZXF1YWwgYWtleSB3aXRoXG4gICAgICAgICAgICAgfCBTb21lIFQgLT4gU29tZSBUXG4gICAgICAgICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgICAgOztcbiAgICAgIGVuZClcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgQ3JlYXRlMiAoVCA6IEFyZzIpID0gc3RydWN0XG4gICAgdHlwZSBfIGtleSArPSBUMiA6ICdhIGtleSAqICdiIGtleSAtPiAoJ2EsICdiKSBULnQga2V5XG5cbiAgICBsZXQgdHlwZV9lcXVhbF9pZCAodHlwZSBhIGIpICgobW9kdWxlIEEpIDogYSB0KSAoKG1vZHVsZSBCKSA6IGIgdCkgOiAoYSwgYikgVC50IHQgPVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gKEEudCwgQi50KSBULnRcblxuICAgICAgICBsZXQgaWRfbmFtZSA9IFQubmFtZVxuICAgICAgICBsZXQgaWRfc2V4cCA9IFNleHAuTGlzdCBbIEF0b20gaWRfbmFtZTsgQS5pZF9zZXhwOyBCLmlkX3NleHAgXVxuICAgICAgICBsZXQgc2V4cF9vZl90IHQgPSBULnNleHBfb2ZfdCBBLnNleHBfb2ZfdCBCLnNleHBfb2ZfdCB0XG4gICAgICAgIGxldCB0eXBlX2tleSA9IFQyIChBLnR5cGVfa2V5LCBCLnR5cGVfa2V5KVxuICAgICAgICBsZXQgdWlkID0gVWlkLmNyZWF0ZSB0eXBlX2tleSBbIEEudWlkOyBCLnVpZCBdXG5cbiAgICAgICAgbGV0IHR5cGVfZXF1YWwgKHR5cGUgb3RoZXIpIChvdGhlcmtleSA6IG90aGVyIGtleSkgOiAodCwgb3RoZXIpIGVxdWFsIG9wdGlvbiA9XG4gICAgICAgICAgbWF0Y2ggb3RoZXJrZXkgd2l0aFxuICAgICAgICAgIHwgVDIgKGFrZXksIGJrZXkpIC0+XG4gICAgICAgICAgICAobWF0Y2ggQS50eXBlX2VxdWFsIGFrZXksIEIudHlwZV9lcXVhbCBia2V5IHdpdGhcbiAgICAgICAgICAgICB8IFNvbWUgVCwgU29tZSBUIC0+IFNvbWUgVFxuICAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgICA7O1xuICAgICAgZW5kKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBDcmVhdGUzIChUIDogQXJnMykgPSBzdHJ1Y3RcbiAgICB0eXBlIF8ga2V5ICs9IFQzIDogJ2Ega2V5ICogJ2Iga2V5ICogJ2Mga2V5IC0+ICgnYSwgJ2IsICdjKSBULnQga2V5XG5cbiAgICBsZXQgdHlwZV9lcXVhbF9pZFxuICAgICAgKHR5cGUgYSBiIGMpXG4gICAgICAoKG1vZHVsZSBBKSA6IGEgdClcbiAgICAgICgobW9kdWxlIEIpIDogYiB0KVxuICAgICAgKChtb2R1bGUgQykgOiBjIHQpXG4gICAgICA6IChhLCBiLCBjKSBULnQgdFxuICAgICAgPVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gKEEudCwgQi50LCBDLnQpIFQudFxuXG4gICAgICAgIGxldCBpZF9uYW1lID0gVC5uYW1lXG4gICAgICAgIGxldCBpZF9zZXhwID0gU2V4cC5MaXN0IFsgQXRvbSBpZF9uYW1lOyBBLmlkX3NleHA7IEIuaWRfc2V4cDsgQy5pZF9zZXhwIF1cbiAgICAgICAgbGV0IHNleHBfb2ZfdCB0ID0gVC5zZXhwX29mX3QgQS5zZXhwX29mX3QgQi5zZXhwX29mX3QgQy5zZXhwX29mX3QgdFxuICAgICAgICBsZXQgdHlwZV9rZXkgPSBUMyAoQS50eXBlX2tleSwgQi50eXBlX2tleSwgQy50eXBlX2tleSlcbiAgICAgICAgbGV0IHVpZCA9IFVpZC5jcmVhdGUgdHlwZV9rZXkgWyBBLnVpZDsgQi51aWQ7IEMudWlkIF1cblxuICAgICAgICBsZXQgdHlwZV9lcXVhbCAodHlwZSBvdGhlcikgKG90aGVya2V5IDogb3RoZXIga2V5KSA6ICh0LCBvdGhlcikgZXF1YWwgb3B0aW9uID1cbiAgICAgICAgICBtYXRjaCBvdGhlcmtleSB3aXRoXG4gICAgICAgICAgfCBUMyAoYWtleSwgYmtleSwgY2tleSkgLT5cbiAgICAgICAgICAgIChtYXRjaCBBLnR5cGVfZXF1YWwgYWtleSwgQi50eXBlX2VxdWFsIGJrZXksIEMudHlwZV9lcXVhbCBja2V5IHdpdGhcbiAgICAgICAgICAgICB8IFNvbWUgVCwgU29tZSBULCBTb21lIFQgLT4gU29tZSBUXG4gICAgICAgICAgICAgfCBOb25lLCBfLCBfIHwgXywgTm9uZSwgXyB8IF8sIF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgICA7O1xuICAgICAgZW5kKVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBjcmVhdGUgKHR5cGUgYSkgfm5hbWUgc2V4cF9vZl90ID1cbiAgICBsZXQgbW9kdWxlIFQgPVxuICAgICAgQ3JlYXRlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IGFcblxuICAgICAgICBsZXQgbmFtZSA9IG5hbWVcbiAgICAgICAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICAgICAgZW5kKVxuICAgIGluXG4gICAgVC50eXBlX2VxdWFsX2lkXG4gIDs7XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiogWydhIENoZWFwX29wdGlvbi50XSBpcyBsaWtlIFsnYSBvcHRpb25dLCBidXQgaXQgZG9lc24ndCBib3ggW3NvbWUgX10gdmFsdWVzLlxuXG4gICAgVGhlcmUgYXJlIHNldmVyYWwgdGhpbmdzIHRoYXQgYXJlIHVuc2FmZSBhYm91dCBpdDpcblxuICAgIC0gW2Zsb2F0IHQgYXJyYXldIChvciBhbnkgYXJyYXktYmFja2VkIGNvbnRhaW5lcikgaXMgbm90IG1lbW9yeS1zYWZlXG4gICAgICBiZWNhdXNlIGZsb2F0IGFycmF5IG9wdGltaXphdGlvbiBpcyBpbmNvbXBhdGlibGUgd2l0aCB1bmJveGVkIG9wdGlvblxuICAgICAgb3B0aW1pemF0aW9uLiBZb3UgaGF2ZSB0byB1c2UgW1VuaWZvcm1fYXJyYXkudF0gaW5zdGVhZCBvZiBbYXJyYXldLlxuXG4gICAgLSBOZXN0ZWQgb3B0aW9ucyAoWydhIHQgdF0pIGRvbid0IHdvcmsuIFRoZXkgYXJlIGJlbGlldmVkIHRvIGJlXG4gICAgICBtZW1vcnktc2FmZSwgYnV0IG5vdCBwYXJhbWV0cmljLlxuXG4gICAgLSBBIHJlY29yZCB3aXRoIFtmbG9hdCB0XXMgaW4gaXQgc2hvdWxkIGJlIHNhZmUsIGJ1dCBpdCdzIG9ubHkgW3RdIGJlaW5nXG4gICAgICBhYnN0cmFjdCB0aGF0IGdpdmVzIHlvdSBzYWZldHkuIElmIHRoZSBjb21waWxlciB3YXMgc21hcnQgZW5vdWdoIHRvIHBlZWtcbiAgICAgIHRocm91Z2ggdGhlIG1vZHVsZSBzaWduYXR1cmUgdGhlbiBpdCBjb3VsZCBkZWNpZGUgdG8gY29uc3RydWN0IGEgZmxvYXRcbiAgICAgIGFycmF5IGluc3RlYWQuICopXG5tb2R1bGUgQ2hlYXBfb3B0aW9uID0gc3RydWN0XG4gICgqIFRoaXMgaXMgdGFrZW4gZnJvbSBjb3JlLiBSYXRoZXIgdGhhbiBleHBvc2UgaXQgaW4gdGhlIHB1YmxpYyBpbnRlcmZhY2Ugb2YgYmFzZSwganVzdFxuICAgICBrZWVwIGEgY29weSBhcm91bmQgaGVyZS4gKilcbiAgbGV0IHBoeXNfc2FtZSAodHlwZSBhIGIpIChhIDogYSkgKGIgOiBiKSA9IHBoeXNfZXF1YWwgYSAoU3RkbGliLk9iai5tYWdpYyBiIDogYSlcblxuICBtb2R1bGUgVDAgOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBub25lIDogXyB0XG4gICAgdmFsIHNvbWUgOiAnYSAtPiAnYSB0XG4gICAgdmFsIGlzX25vbmUgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCBpc19zb21lIDogXyB0IC0+IGJvb2xcbiAgICB2YWwgdmFsdWVfZXhuIDogJ2EgdCAtPiAnYVxuICAgIHZhbCB2YWx1ZV91bnNhZmUgOiAnYSB0IC0+ICdhXG4gICAgdmFsIGl0ZXJfc29tZSA6ICdhIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICsnYSB0XG5cbiAgICAoKiBCZWluZyBhIHBvaW50ZXIsIG5vIG9uZSBvdXRzaWRlIHRoaXMgbW9kdWxlIGNhbiBjb25zdHJ1Y3QgYSB2YWx1ZSB0aGF0IGlzXG4gICAgICAgW3BoeXNfc2FtZV0gYXMgdGhpcyBvbmUuXG5cbiAgICAgICBJdCB3b3VsZCBiZSBzaW1wbGVyIHRvIHVzZSB0aGlzIHZhbHVlIGFzIFtub25lXSwgYnV0IHdlIHVzZSBhbiBpbW1lZGlhdGUgaW5zdGVhZFxuICAgICAgIGJlY2F1c2UgaXQgbGV0cyB1cyBhdm9pZCBjYW1sX21vZGlmeSB3aGVuIHNldHRpbmcgdG8gW25vbmVdLCBtYWtpbmcgY2VydGFpblxuICAgICAgIGJlbmNobWFya3Mgc2lnbmlmaWNhbnRseSBmYXN0ZXIgKGUuZy4gLi4vYmVuY2gvYXJyYXlfcXVldWUuZXhlKS5cblxuICAgICAgIHRoaXMgY29kZSBpcyBkdXBsaWNhdGVkIGluIE1vcHRpb24sIGFuZCBpZiB3ZSBmaW5kIHlldCBhbm90aGVyIHBsYWNlIHdoZXJlIHdlIHdhbnRcbiAgICAgICBpdCB3ZSBzaG91bGQgcmVjb25zaWRlciBtYWtpbmcgaXQgc2hhcmVkLiAqKVxuICAgIGxldCBub25lX3N1YnN0aXR1dGUgOiBfIHQgPVxuICAgICAgU3RkbGliLk9iai5vYmogKFN0ZGxpYi5PYmoubmV3X2Jsb2NrIFN0ZGxpYi5PYmouYWJzdHJhY3RfdGFnIDEpXG4gICAgOztcblxuICAgIGxldCBub25lIDogXyB0ID1cbiAgICAgICgqIFRoZSBudW1iZXIgd2FzIHByb2R1Y2VkIGJ5XG4gICAgICAgICBbPCAvZGV2L3VyYW5kb20gdHIgLWMgLWQgJzEyMzQ1Njc4OTBhYmNkZWYnIHwgaGVhZCAtYyAxNl0uXG5cbiAgICAgICAgIFRoZSBpZGVhIGlzIHRoYXQgYSByYW5kb20gbnVtYmVyIHdpbGwgaGF2ZSBsb3dlciBwcm9iYWJpbGl0eSB0byBjb2xsaWRlIHdpdGhcbiAgICAgICAgIGFueXRoaW5nIHRoYW4gYW55IG51bWJlciB3ZSBjYW4gY2hvb3NlIG91cnNlbHZlcy5cblxuICAgICAgICAgV2UgYXJlIHVzaW5nIGEgcG9seW1vcnBoaWMgdmFyaWFudCBpbnN0ZWFkIG9mIGFuIGludGVnZXIgY29uc3RhbnQgYmVjYXVzZSB0aGVyZVxuICAgICAgICAgaXMgYSBjb21waWxlciBidWcgd2hlcmUgaXQgd3JvbmdseSBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdCBvZiBbaWYgXyB0aGVuIGMgZWxzZVxuICAgICAgICAgeV0gaXMgbm90IGEgcG9pbnRlciBpZiBbY10gaXMgYW4gaW50ZWdlciBjb21waWxlLXRpbWUgY29uc3RhbnQuICBUaGlzIGlzIGJlaW5nXG4gICAgICAgICBmaXhlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvcHVsbC81NTUuICBUaGUgXCJtZW1vcnkgY29ycnVwdGlvblwiIHRlc3RcbiAgICAgICAgIGJlbG93IGRlbW9uc3RyYXRlcyB0aGUgaXNzdWUuICAqKVxuICAgICAgU3RkbGliLk9iai5tYWdpYyBgeDZlOGVlMzQ3OGUxZDc0NDlcbiAgICA7O1xuXG4gICAgbGV0IGlzX25vbmUgeCA9IHBoeXNfZXF1YWwgeCBub25lXG4gICAgbGV0IGlzX3NvbWUgeCA9IG5vdCAocGh5c19lcXVhbCB4IG5vbmUpXG5cbiAgICBsZXQgc29tZSAodHlwZSBhKSAoeCA6IGEpIDogYSB0ID1cbiAgICAgIGlmIHBoeXNfc2FtZSB4IG5vbmUgdGhlbiBub25lX3N1YnN0aXR1dGUgZWxzZSBTdGRsaWIuT2JqLm1hZ2ljIHhcbiAgICA7O1xuXG4gICAgbGV0IHZhbHVlX3Vuc2FmZSAodHlwZSBhKSAoeCA6IGEgdCkgOiBhID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgeCBub25lX3N1YnN0aXR1dGUgdGhlbiBTdGRsaWIuT2JqLm1hZ2ljIG5vbmUgZWxzZSBTdGRsaWIuT2JqLm1hZ2ljIHhcbiAgICA7O1xuXG4gICAgbGV0IHZhbHVlX2V4biB4ID1cbiAgICAgIGlmIGlzX3NvbWUgeFxuICAgICAgdGhlbiB2YWx1ZV91bnNhZmUgeFxuICAgICAgZWxzZSBmYWlsd2l0aCBcIk9wdGlvbl9hcnJheS5nZXRfc29tZV9leG46IHRoZSBlbGVtZW50IGlzIFtOb25lXVwiXG4gICAgOztcblxuICAgIGxldCBpdGVyX3NvbWUgdCB+ZiA9IGlmIGlzX3NvbWUgdCB0aGVuIGYgKHZhbHVlX3Vuc2FmZSB0KVxuICBlbmRcblxuICBtb2R1bGUgVDEgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFQwXG5cbiAgICBsZXQgb2Zfb3B0aW9uID0gZnVuY3Rpb25cbiAgICAgIHwgTm9uZSAtPiBub25lXG4gICAgICB8IFNvbWUgeCAtPiBzb21lIHhcbiAgICA7O1xuXG4gICAgbGV0W0BpbmxpbmVdIHRvX29wdGlvbiB4ID0gaWYgaXNfc29tZSB4IHRoZW4gU29tZSAodmFsdWVfdW5zYWZlIHgpIGVsc2UgTm9uZVxuICAgIGxldFtAaW5saW5lXSB0b19vcHRpb25fbG9jYWwgeCA9IGlmIGlzX3NvbWUgeCB0aGVuIFNvbWUgKHZhbHVlX3Vuc2FmZSB4KSBlbHNlIE5vbmVcbiAgICBsZXQgdG9fc2V4cGFibGUgPSB0b19vcHRpb25cbiAgICBsZXQgb2Zfc2V4cGFibGUgPSBvZl9vcHRpb25cblxuICAgIGxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgPVxuICAgICAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoT3B0aW9uLnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG4gICAgOztcbiAgZW5kXG5cbiAgaW5jbHVkZSBUMVxuICBpbmNsdWRlIFNleHBhYmxlLk9mX3NleHBhYmxlMSAoT3B0aW9uKSAoVDEpXG5lbmRcblxudHlwZSAnYSB0ID0gJ2EgQ2hlYXBfb3B0aW9uLnQgVW5pZm9ybV9hcnJheS50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICBmdW4gX29mX2FfXzAwMV8geF9fMDAzXyAtPlxuICBVbmlmb3JtX2FycmF5LnRfb2Zfc2V4cCAoQ2hlYXBfb3B0aW9uLnRfb2Zfc2V4cCBfb2ZfYV9fMDAxXykgeF9fMDAzX1xuOztcblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDA0XyB4X18wMDVfIC0+XG4gIFVuaWZvcm1fYXJyYXkuc2V4cF9vZl90IChDaGVhcF9vcHRpb24uc2V4cF9vZl90IF9vZl9hX18wMDRfKSB4X18wMDVfXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+XG4gIFVuaWZvcm1fYXJyYXkudF9zZXhwX2dyYW1tYXIgKENoZWFwX29wdGlvbi50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyKVxuOztcblxuW0BAQGVuZF1cblxubGV0IGVtcHR5ID0gVW5pZm9ybV9hcnJheS5lbXB0eVxubGV0IGNyZWF0ZSB+bGVuID0gVW5pZm9ybV9hcnJheS5jcmVhdGUgfmxlbiBDaGVhcF9vcHRpb24ubm9uZVxubGV0IGluaXQgbiB+ZiA9IFVuaWZvcm1fYXJyYXkuaW5pdCBuIH5mOihmdW4gaSAtPiBDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIChmIGkpKSBbQG5vbnRhaWxdXG5sZXQgaW5pdF9zb21lIG4gfmYgPSBVbmlmb3JtX2FycmF5LmluaXQgbiB+ZjooZnVuIGkgLT4gQ2hlYXBfb3B0aW9uLnNvbWUgKGYgaSkpIFtAbm9udGFpbF1cbmxldCBsZW5ndGggPSBVbmlmb3JtX2FycmF5Lmxlbmd0aFxubGV0W0BpbmxpbmVdIGdldCB0IGkgPSBDaGVhcF9vcHRpb24udG9fb3B0aW9uIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXRbQGlubGluZV0gZ2V0X2xvY2FsIHQgaSA9IENoZWFwX29wdGlvbi50b19vcHRpb25fbG9jYWwgKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBnZXRfc29tZV9leG4gdCBpID0gQ2hlYXBfb3B0aW9uLnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGlzX25vbmUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX25vbmUgKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBpc19zb21lIHQgaSA9IENoZWFwX29wdGlvbi5pc19zb21lIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgc2V0IHQgaSB4ID0gVW5pZm9ybV9hcnJheS5zZXQgdCBpIChDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIHgpXG5sZXQgc2V0X3NvbWUgdCBpIHggPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgKENoZWFwX29wdGlvbi5zb21lIHgpXG5sZXQgc2V0X25vbmUgdCBpID0gVW5pZm9ybV9hcnJheS5zZXQgdCBpIENoZWFwX29wdGlvbi5ub25lXG5sZXQgc3dhcCB0IGkgaiA9IFVuaWZvcm1fYXJyYXkuc3dhcCB0IGkgalxubGV0IHVuc2FmZV9nZXQgdCBpID0gQ2hlYXBfb3B0aW9uLnRvX29wdGlvbiAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcbmxldCB1bnNhZmVfZ2V0X3NvbWVfZXhuIHQgaSA9IENoZWFwX29wdGlvbi52YWx1ZV9leG4gKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG5cbmxldCB1bnNhZmVfZ2V0X3NvbWVfYXNzdW1pbmdfc29tZSB0IGkgPVxuICBDaGVhcF9vcHRpb24udmFsdWVfdW5zYWZlIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxuOztcblxubGV0IHVuc2FmZV9pc19zb21lIHQgaSA9IENoZWFwX29wdGlvbi5pc19zb21lIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxubGV0IHVuc2FmZV9zZXQgdCBpIHggPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIChDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIHgpXG5sZXQgdW5zYWZlX3NldF9zb21lIHQgaSB4ID0gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLnNvbWUgeClcbmxldCB1bnNhZmVfc2V0X25vbmUgdCBpID0gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgaSBDaGVhcF9vcHRpb24ubm9uZVxuXG5sZXQgY2xlYXIgdCA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICB1bnNhZmVfc2V0X25vbmUgdCBpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSBpbnB1dCB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggaW5wdXQgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IGlucHV0IGkpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyIGlucHV0IH5mID0gaXRlcmkgaW5wdXQgfmY6KGZ1biAoXyA6IGludCkgeCAtPiBmIHgpIFtAbm9udGFpbF1cblxubGV0IGZvbGRpIGlucHV0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGl0ZXJpIGlucHV0IH5mOihmdW4gaSBlbGVtIC0+IGFjYyA6PSBmIGkgIWFjYyBlbGVtKTtcbiAgIWFjY1xuOztcblxubGV0IGZvbGQgaW5wdXQgfmluaXQgfmYgPSBmb2xkaSBpbnB1dCB+aW5pdCB+ZjooZnVuIChfIDogaW50KSBhY2MgeCAtPiBmIGFjYyB4KSBbQG5vbnRhaWxdXG5cbmluY2x1ZGUgSW5kZXhlZF9jb250YWluZXIuTWFrZV9nZW4gKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2EsIF8sIF8pIHQgPSAnYSB0XG4gIHR5cGUgJ2EgZWx0ID0gJ2Egb3B0aW9uXG5cbiAgbGV0IGZvbGQgPSBmb2xkXG4gIGxldCBmb2xkaSA9IGBDdXN0b20gZm9sZGlcbiAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgbGV0IGl0ZXJpID0gYEN1c3RvbSBpdGVyaVxuICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbmVuZClcblxubGV0IGxlbmd0aCA9IFVuaWZvcm1fYXJyYXkubGVuZ3RoXG5cbmxldCBtYXBpIGlucHV0IH5mID1cbiAgbGV0IG91dHB1dCA9IGNyZWF0ZSB+bGVuOihsZW5ndGggaW5wdXQpIGluXG4gIGl0ZXJpIGlucHV0IH5mOihmdW4gaSBlbGVtIC0+IHVuc2FmZV9zZXQgb3V0cHV0IGkgKGYgaSBlbGVtKSk7XG4gIG91dHB1dFxuOztcblxubGV0IG1hcCBpbnB1dCB+ZiA9IG1hcGkgaW5wdXQgfmY6KGZ1biAoXyA6IGludCkgZWxlbSAtPiBmIGVsZW0pIFtAbm9udGFpbF1cblxubGV0IG1hcF9zb21lIGlucHV0IH5mID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBpbnB1dCBpblxuICBsZXQgb3V0cHV0ID0gY3JlYXRlIH5sZW4gaW5cbiAgbGV0ICgpID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IG9wdCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCBpbnB1dCBpIGluXG4gICAgICBDaGVhcF9vcHRpb24uaXRlcl9zb21lIG9wdCB+ZjooZnVuIHggLT4gdW5zYWZlX3NldF9zb21lIG91dHB1dCBpIChmIHgpKVxuICAgIGRvbmVcbiAgaW5cbiAgb3V0cHV0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyYXkgPSBpbml0IChBcnJheS5sZW5ndGggYXJyYXkpIH5mOihmdW4gaSAtPiBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkpXG5cbmxldCBvZl9hcnJheV9zb21lIGFycmF5ID1cbiAgaW5pdF9zb21lIChBcnJheS5sZW5ndGggYXJyYXkpIH5mOihmdW4gaSAtPiBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMV9nZW5lcmljIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICBsZXQgdW5zYWZlX2JsaXQgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9ibGl0XG5lbmQpXG5cbmxldCBjb3B5ID0gVW5pZm9ybV9hcnJheS5jb3B5XG5cbm1vZHVsZSBGb3JfdGVzdGluZyA9IHN0cnVjdFxuICBtb2R1bGUgVW5zYWZlX2NoZWFwX29wdGlvbiA9IENoZWFwX29wdGlvblxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU3RhY2tfaW50ZlxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBzaW1pbGFyIHRvIFtEZXF1ZV0gaW4gdGhhdCBpdCB1c2VzIGFuIGFycmF5IG9mIFsnYV0gYW5kXG4gICBhIG11dGFibGUgW2ludF0gdG8gaW5kaWNhdGUgd2hhdCBpbiB0aGUgYXJyYXkgaXMgdXNlZC4gIFdlIGNob29zZSB0byBpbXBsZW1lbnQgW1N0YWNrXVxuICAgZGlyZWN0bHkgcmF0aGVyIHRoYW4gb24gdG9wIG9mIFtEZXF1ZV0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuICBFLmcuIGEgc2ltcGxlXG4gICBtaWNyb2JlbmNobWFyayBzaG93cyB0aGF0IHB1c2gvcG9wIGlzIGFib3V0IDIwJSBmYXN0ZXIuICopXG50eXBlICdhIHQgPVxuICB7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgbXV0YWJsZSBlbHRzIDogJ2EgT3B0aW9uX2FycmF5LnRcbiAgfVxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwMV8geyBsZW5ndGggPSBsZW5ndGhfXzAwM187IGVsdHMgPSBlbHRzX18wMDVfIH0gLT5cbiAgbGV0IGJuZHNfXzAwMl8gPSAoW10gOiBfIFN0ZGxpYi5MaXN0LnQpIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMDZfID0gT3B0aW9uX2FycmF5LnNleHBfb2ZfdCBfb2ZfYV9fMDAxXyBlbHRzX18wMDVfIGluXG4gICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImVsdHNcIjsgYXJnX18wMDZfIF0gOjogYm5kc19fMDAyX1xuICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMDRfID0gc2V4cF9vZl9pbnQgbGVuZ3RoX18wMDNfIGluXG4gICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxlbmd0aFwiOyBhcmdfXzAwNF8gXSA6OiBibmRzX18wMDJfXG4gICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgaW5cbiAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwMl9cbjs7XG5cbltAQEBlbmRdXG5cbmxldCBzZXhwX29mX3RfaW50ZXJuYWwgPSBzZXhwX29mX3RcbmxldCBzZXhwX29mX3QgPSBgUmVib3VuZF9sYXRlclxubGV0IF8gPSBzZXhwX29mX3RcbmxldCBjYXBhY2l0eSB0ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSAoeyBsZW5ndGg7IGVsdHMgfSBhcyB0KSA6IHVuaXQgPVxuICB0cnlcbiAgICBhc3NlcnQgKDAgPD0gbGVuZ3RoICYmIGxlbmd0aCA8PSBPcHRpb25fYXJyYXkubGVuZ3RoIGVsdHMpO1xuICAgIGZvciBpID0gMCB0byBsZW5ndGggLSAxIGRvXG4gICAgICBpbnZhcmlhbnRfYSAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biBlbHRzIGkpXG4gICAgZG9uZTtcbiAgICAoKiBXZSBtYWludGFpbiB0aGUgaW52YXJpYW50IHRoYXQgdW51c2VkIGVsZW1lbnRzIGFyZSB1bnNldCB0byBhdm9pZCBhIHNwYWNlXG4gICAgICAgbGVhay4gKilcbiAgICBmb3IgaSA9IGxlbmd0aCB0byBPcHRpb25fYXJyYXkubGVuZ3RoIGVsdHMgLSAxIGRvXG4gICAgICBhc3NlcnQgKG5vdCAoT3B0aW9uX2FycmF5LmlzX3NvbWUgZWx0cyBpKSlcbiAgICBkb25lXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIlN0YWNrLmludmFyaWFudCBmYWlsZWRcIlxuICAgICAgICAgWyBcImV4blwiLCBleG4gfD4gRXhuLnNleHBfb2ZfdDsgXCJzdGFja1wiLCB0IHw+IHNleHBfb2ZfdF9pbnRlcm5hbCBzZXhwX29mX29wYXF1ZSBdKVxuOztcblxubGV0IGNyZWF0ZSAodHlwZSBhKSAoKSA6IGEgdCA9IHsgbGVuZ3RoID0gMDsgZWx0cyA9IE9wdGlvbl9hcnJheS5lbXB0eSB9XG5sZXQgbGVuZ3RoIHQgPSB0Lmxlbmd0aFxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxuKCogVGhlIG9yZGVyIGluIHdoaWNoIGVsZW1lbnRzIGFyZSB2aXNpdGVkIGhhcyBiZWVuIGNob3NlbiBzbyBhcyB0byBiZSBiYWNrd2FyZHNcbiAgIGNvbXBhdGlibGUgd2l0aCBbU3RkbGliLlN0YWNrXSAqKVxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCByID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSB0Lmxlbmd0aCAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgIXIgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkpXG4gIGRvbmU7XG4gICFyXG47O1xuXG5sZXQgaXRlciB0IH5mID1cbiAgZm9yIGkgPSB0Lmxlbmd0aCAtIDEgZG93bnRvIDAgZG9cbiAgICBmIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyBpKVxuICBkb25lXG47O1xuXG5tb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgZm9sZCA9IGZvbGRcbiAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG5lbmQpXG5cbmxldCBtZW0gPSBDLm1lbVxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbmxldCB0b19hcnJheSA9IEMudG9fYXJyYXlcbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcblxubGV0IG9mX2xpc3QgKHR5cGUgYSkgKGwgOiBhIGxpc3QpID1cbiAgaWYgTGlzdC5pc19lbXB0eSBsXG4gIHRoZW4gY3JlYXRlICgpXG4gIGVsc2UgKFxuICAgIGxldCBsZW5ndGggPSBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IGVsdHMgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46KDIgKiBsZW5ndGgpIGluXG4gICAgbGV0IHIgPSByZWYgbCBpblxuICAgIGZvciBpID0gbGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgICAgbWF0Y2ggIXIgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgYSA6OiBsIC0+XG4gICAgICAgIE9wdGlvbl9hcnJheS5zZXRfc29tZSBlbHRzIGkgYTtcbiAgICAgICAgciA6PSBsXG4gICAgZG9uZTtcbiAgICB7IGxlbmd0aDsgZWx0cyB9KVxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IExpc3Quc2V4cF9vZl90IHNleHBfb2ZfYSAodG9fbGlzdCB0KVxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IG9mX2xpc3QgKExpc3QudF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwKVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbmxldCByZXNpemUgdCBzaXplID1cbiAgbGV0IGFyciA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpzaXplIGluXG4gIE9wdGlvbl9hcnJheS5ibGl0IH5zcmM6dC5lbHRzIH5kc3Q6YXJyIH5zcmNfcG9zOjAgfmRzdF9wb3M6MCB+bGVuOnQubGVuZ3RoO1xuICB0LmVsdHMgPC0gYXJyXG47O1xuXG5sZXQgc2V0X2NhcGFjaXR5IHQgbmV3X2NhcGFjaXR5ID1cbiAgbGV0IG5ld19jYXBhY2l0eSA9IG1heCBuZXdfY2FwYWNpdHkgKGxlbmd0aCB0KSBpblxuICBpZiBuZXdfY2FwYWNpdHkgPD4gY2FwYWNpdHkgdCB0aGVuIHJlc2l6ZSB0IG5ld19jYXBhY2l0eVxuOztcblxubGV0IHB1c2ggdCBhID1cbiAgaWYgdC5sZW5ndGggPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0cyB0aGVuIHJlc2l6ZSB0ICgyICogKHQubGVuZ3RoICsgMSkpO1xuICBPcHRpb25fYXJyYXkuc2V0X3NvbWUgdC5lbHRzIHQubGVuZ3RoIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IHBvcF9ub25lbXB0eSB0ID1cbiAgbGV0IGkgPSB0Lmxlbmd0aCAtIDEgaW5cbiAgbGV0IHJlc3VsdCA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkgaW5cbiAgT3B0aW9uX2FycmF5LnNldF9ub25lIHQuZWx0cyBpO1xuICB0Lmxlbmd0aCA8LSBpO1xuICByZXN1bHRcbjs7XG5cbmxldCBwb3BfZXJyb3IgPSBFcnJvci5vZl9zdHJpbmcgXCJTdGFjay5wb3Agb2YgZW1wdHkgc3RhY2tcIlxubGV0IHBvcCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChwb3Bfbm9uZW1wdHkgdClcbmxldCBwb3BfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gRXJyb3IucmFpc2UgcG9wX2Vycm9yIGVsc2UgcG9wX25vbmVtcHR5IHRcbmxldCB0b3Bfbm9uZW1wdHkgdCA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzICh0Lmxlbmd0aCAtIDEpXG5sZXQgdG9wX2Vycm9yID0gRXJyb3Iub2Zfc3RyaW5nIFwiU3RhY2sudG9wIG9mIGVtcHR5IHN0YWNrXCJcbmxldCB0b3AgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAodG9wX25vbmVtcHR5IHQpXG5sZXQgdG9wX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIEVycm9yLnJhaXNlIHRvcF9lcnJvciBlbHNlIHRvcF9ub25lbXB0eSB0XG5sZXQgY29weSB7IGxlbmd0aDsgZWx0cyB9ID0geyBsZW5ndGg7IGVsdHMgPSBPcHRpb25fYXJyYXkuY29weSBlbHRzIH1cblxubGV0IGNsZWFyIHQgPVxuICBpZiB0Lmxlbmd0aCA+IDBcbiAgdGhlbiAoXG4gICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgT3B0aW9uX2FycmF5LnNldF9ub25lIHQuZWx0cyBpXG4gICAgZG9uZTtcbiAgICB0Lmxlbmd0aCA8LSAwKVxuOztcblxubGV0IHVudGlsX2VtcHR5IHQgZiA9XG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgaWYgdC5sZW5ndGggPiAwXG4gICAgdGhlbiAoXG4gICAgICBmIChwb3Bfbm9uZW1wdHkgdCk7XG4gICAgICBsb29wICgpKVxuICBpblxuICBsb29wICgpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgIG1hdGNoIGYgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgeCAtPiBwdXNoIHRfcmVzdWx0IHhcbiAgZG9uZTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgbGV0IHggPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyBpIGluXG4gICAgaWYgZiB4IHRoZW4gcHVzaCB0X3Jlc3VsdCB4XG4gIGRvbmU7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB3cml0ZV9pbmRleCA9IHJlZiAwIGluXG4gIEV4bi5wcm90ZWN0XG4gICAgfmY6KGZ1biAoKSAtPlxuICAgICAgZm9yIHJlYWRfaW5kZXggPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgICBsZXQgeCA9IE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfYXNzdW1pbmdfc29tZSB0LmVsdHMgcmVhZF9pbmRleCBpblxuICAgICAgICBpZiBmIHhcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgaWYgIXdyaXRlX2luZGV4IDwgcmVhZF9pbmRleFxuICAgICAgICAgIHRoZW4gT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0LmVsdHMgIXdyaXRlX2luZGV4IHg7XG4gICAgICAgICAgaW5jciB3cml0ZV9pbmRleClcbiAgICAgIGRvbmUpXG4gICAgfmZpbmFsbHk6KGZ1biAoKSAtPlxuICAgICAgZm9yIGkgPSAhd3JpdGVfaW5kZXggdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgdC5lbHRzIGlcbiAgICAgIGRvbmU7XG4gICAgICB0Lmxlbmd0aCA8LSAhd3JpdGVfaW5kZXgpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIHB1c2ggdCB4O1xuICB0XG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbigqIFRoaXMgaXMgbGlmdGVkIG91dCBvZiBbTV0gYmVjYXVzZSBbU291cmNlX2NvZGVfcG9zaXRpb24wXSBleHBvcnRzIFtTdHJpbmcwXVxuICAgYXMgW1N0cmluZ10sIHdoaWNoIGRvZXMgbm90IGV4cG9ydCBhIGhhc2ggZnVuY3Rpb24uICopXG5sZXQgaGFzaF9vdmVycmlkZSB7IFN0ZGxpYi5MZXhpbmcucG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2JvbDsgcG9zX2NudW0gfSA9XG4gIFN0cmluZy5oYXNoIHBvc19mbmFtZVxuICBseG9yIEludC5oYXNoIHBvc19sbnVtXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2JvbFxuICBseG9yIEludC5oYXNoIHBvc19jbnVtXG47O1xuXG5tb2R1bGUgTSA9IHN0cnVjdFxuICBpbmNsdWRlIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMFxuXG4gIGxldCBoYXNoID0gaGFzaF9vdmVycmlkZVxuZW5kXG5cbmluY2x1ZGUgTVxuaW5jbHVkZSBDb21wYXJhYmxlLk1ha2VfdXNpbmdfY29tcGFyYXRvciAoTSlcblxubGV0IGVxdWFsX19sb2NhbCBhIGIgPSBlcXVhbF9pbnQgKGNvbXBhcmVfX2xvY2FsIGEgYikgMFxuXG5sZXQgb2ZfcG9zIChwb3NfZm5hbWUsIHBvc19sbnVtLCBwb3NfY251bSwgXykgPVxuICB7IHBvc19mbmFtZTsgcG9zX2xudW07IHBvc19jbnVtOyBwb3NfYm9sID0gMCB9XG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBOZWdcbiAgICB8IFplcm9cbiAgICB8IFBvc1xuICAgIHwgTmFuXG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXIsIGNvbXBhcmUsIGhhc2gsIGVudW1lcmF0ZV1cblxuICBsZXQgdF9vZl9zZXhwID1cbiAgICAobGV0IGVycm9yX3NvdXJjZV9fMDAzXyA9IFwic2lnbl9vcl9uYW4ubWwuVC50XCIgaW5cbiAgICAgZnVuY3Rpb25cbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSAtPiBOZWdcbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIC0+IFplcm9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSAtPiBQb3NcbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSAtPiBOYW5cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDAyXyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgIHwgc2V4cF9fMDAyXyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgIHwgTmVnIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5lZ1wiXG4gICAgIHwgWmVybyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJaZXJvXCJcbiAgICAgfCBQb3MgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiUG9zXCJcbiAgICAgfCBOYW4gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmFuXCJcbiAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBWYXJpYW50XG4gICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTmVnXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiUG9zXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5hblwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgPSAoU3RkbGliLmNvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnRcbiAgICAgICAgIGhzdlxuICAgICAgICAgKG1hdGNoIGFyZyB3aXRoXG4gICAgICAgICAgfCBOZWcgLT4gMFxuICAgICAgICAgIHwgWmVybyAtPiAxXG4gICAgICAgICAgfCBQb3MgLT4gMlxuICAgICAgICAgIHwgTmFuIC0+IDMpXG4gICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgOztcblxuICBsZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgYXJnID1cbiAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gICAgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgYWxsID0gKFsgTmVnOyBaZXJvOyBQb3M7IE5hbiBdIDogdCBsaXN0KVxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxuICBsZXQgdG9fc3RyaW5nIHQgPSBzdHJpbmdfb2Zfc2V4cCAoc2V4cF9vZl90IHQpXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5TaWduX29yX25hblwiXG5lbmRcblxubW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogVC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogVC50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogVC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogVC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogVC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IFQudCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogVC50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBULnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogVC50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IFQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBULnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoVClcblxuKCogT3BlbiBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBvZl9zaWduID0gZnVuY3Rpb25cbiAgfCBTaWduLk5lZyAtPiBOZWdcbiAgfCBTaWduLlplcm8gLT4gWmVyb1xuICB8IFNpZ24uUG9zIC0+IFBvc1xuOztcblxubGV0IHRvX3NpZ25fZXhuID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gU2lnbi5OZWdcbiAgfCBaZXJvIC0+IFNpZ24uWmVyb1xuICB8IFBvcyAtPiBTaWduLlBvc1xuICB8IE5hbiAtPiBpbnZhbGlkX2FyZyBcIkJhc2UuU2lnbl9vcl9uYW4udG9fc2lnbl9leG46IE5hblwiXG47O1xuXG5sZXQgb2ZfaW50IG4gPSBvZl9zaWduIChTaWduLm9mX2ludCBuKVxubGV0IHRvX2ludF9leG4gdCA9IFNpZ24udG9faW50ICh0b19zaWduX2V4biB0KVxuXG5sZXQgZmxpcCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFBvc1xuICB8IFplcm8gLT4gWmVyb1xuICB8IFBvcyAtPiBOZWdcbiAgfCBOYW4gLT4gTmFuXG47O1xuXG5sZXQgKCAqICkgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOYW4sIF8gfCBfLCBOYW4gLT4gTmFuXG4gIHwgXyAtPiBvZl9zaWduIChTaWduLiggKiApICh0b19zaWduX2V4biB0KSAodG9fc2lnbl9leG4gdCcpKVxuOztcblxubGV0IHRvX3N0cmluZ19odW0gPSBmdW5jdGlvblxuICB8IE5lZyAtPiBcIm5lZ2F0aXZlXCJcbiAgfCBaZXJvIC0+IFwiemVyb1wiXG4gIHwgUG9zIC0+IFwicG9zaXRpdmVcIlxuICB8IE5hbiAtPiBcIm5vdC1hLW51bWJlclwiXG47O1xuXG4oKiBJbmNsdWRlIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyIGFueSBmdW5jdG9yIGFwcGxpY2F0aW9ucyB0aGF0XG4gICBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwiKCoqIEludGVyZmFjZXMgZm9yIGltbXV0YWJsZSBkaWN0aW9uYXJ5IHR5cGVzLCBzdWNoIGFzIFtNYXAudF0uXG5cbiAgICBXZSBkZWZpbmUgc2VwYXJhdGUgaW50ZXJmYWNlcyBmb3IgW0FjY2Vzc29yc10gYW5kIFtDcmVhdG9yc10sIGFsb25nIHdpdGggW1NdIGNvbWJpbmluZ1xuICAgIGJvdGguIFRoZXNlIGludGVyZmFjZXMgYXJlIHdyaXR0ZW4gb25jZSBpbiB0aGVpciBtb3N0IGdlbmVyYWwgZm9ybSwgd2hpY2ggaW52b2x2ZXNcbiAgICBleHRyYSB0eXBlIGRlZmluaXRpb25zIGFuZCB0eXBlIHBhcmFtZXRlcnMgdGhhdCBtb3N0IGluc3RhbmNlcyBkbyBub3QgbmVlZC5cblxuICAgIFdlIHRoZW4gcHJvdmlkZSBpbnN0YW50aWF0aW9ucyBvZiB0aGVzZSBpbnRlcmZhY2VzIHdpdGggMSwgMiwgYW5kIDMgdHlwZSBwYXJhbWV0ZXJzXG4gICAgZm9yIFt0XS4gVGhlc2UgY292ZXIgbW9yZSBjb21tb24gdXNhZ2UgcGF0dGVybnMgZm9yIHRoZSBpbnRlcmZhY2VzLiAqKVxuXG5vcGVuISBJbXBvcnRcblxuKCoqIFRoZXNlIGRlZmluaXRpb25zIGFyZSByZS1leHBvcnRlZCBieSBbRGljdGlvbmFyeV9pbW11dGFibGVdLiAqKVxubW9kdWxlIERlZmluaXRpb25zID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29ycyA9IHNpZ1xuICAgICgqKiBUaGUgdHlwZSBvZiBrZXlzLiBUaGlzIHdpbGwgYmUgWydrZXldIGZvciBwb2x5bW9ycGhpYyBkaWN0aW9uYXJpZXMsIG9yIHNvbWUgZml4ZWRcbiAgICAgICAgdHlwZSBmb3IgZGljdGlvbmFyaWVzIHdpdGggbW9ub21vcnBoaWMga2V5cy4gKilcbiAgICB0eXBlICdrZXkga2V5XG5cbiAgICAoKiogRGljdGlvbmFyaWVzLiBUaGVpciBrZXlzIGhhdmUgdHlwZSBbJ2tleSBrZXldLiBFYWNoIGtleSdzIGFzc29jaWF0ZWQgdmFsdWUgaGFzXG4gICAgICAgIHR5cGUgWydkYXRhXS4gVGhlIGRpY3Rpb25hcnkgbWF5IGJlIGRpc3Rpbmd1aXNoZWQgYnkgYSBbJ3BoYW50b21dIHR5cGUuICopXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG5cbiAgICAoKiogVGhlIHR5cGUgb2YgYWNjZXNzb3IgZnVuY3Rpb25zIFsnZm5dIHRoYXQgb3BlcmF0ZSBvbiBbKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdF0uXG4gICAgICAgIE1heSB0YWtlIGV4dHJhIGFyZ3VtZW50cyBiZWZvcmUgWydmbl0sIHN1Y2ggYXMgYSBjb21wYXJpc29uIGZ1bmN0aW9uLiAqKVxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuXG4gICAgKCoqIFdoZXRoZXIgdGhlIGRpY3Rpb25hcnkgaXMgZW1wdHkuICopXG4gICAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuXG4gICAgKCoqIEhvdyBtYW55IGtleS92YWx1ZSBwYWlycyB0aGUgZGljdGlvbmFyeSBjb250YWlucy4gKilcbiAgICB2YWwgbGVuZ3RoIDogKF8sIF8sIF8pIHQgLT4gaW50XG5cbiAgICAoKiogQWxsIGtleS92YWx1ZSBwYWlycy4gKilcbiAgICB2YWwgdG9fYWxpc3QgOiAoJ2tleSwgJ2RhdGEsIF8pIHQgLT4gKCdrZXkga2V5ICogJ2RhdGEpIGxpc3RcblxuICAgICgqKiBBbGwga2V5cyBpbiB0aGUgZGljdGlvbmFyeSwgaW4gdGhlIHNhbWUgb3JkZXIgYXMgW3RvX2FsaXN0XS4gKilcbiAgICB2YWwga2V5cyA6ICgna2V5LCBfLCBfKSB0IC0+ICdrZXkga2V5IGxpc3RcblxuICAgICgqKiBBbGwgdmFsdWVzIGluIHRoZSBkaWN0aW9uYXJ5LCBpbiB0aGUgc2FtZSBvcmRlciBhcyBbdG9fYWxpc3RdLiAqKVxuICAgIHZhbCBkYXRhIDogKF8sICdkYXRhLCBfKSB0IC0+ICdkYXRhIGxpc3RcblxuICAgICgqKiBMaWtlIFt0b19hbGlzdF0uIFByb2R1Y2VzIGEgc2VxdWVuY2UuICopXG4gICAgdmFsIHRvX3NlcXVlbmNlIDogKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAoJ2tleSBrZXkgKiAnZGF0YSkgU2VxdWVuY2UudFxuXG4gICAgKCoqIFdoZXRoZXIgW2tleV0gaGFzIGEgdmFsdWUuICopXG4gICAgdmFsIG1lbSA6ICgoJ2tleSwgXywgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gYm9vbCwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuXG4gICAgKCoqIFByb2R1Y2VzIHRoZSBjdXJyZW50IHZhbHVlLCBvciBhYnNlbmNlIHRoZXJlb2YsIGZvciBhIGdpdmVuIGtleS4gKilcbiAgICB2YWwgZmluZFxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gJ2RhdGEgb3B0aW9uXG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIExpa2UgW2ZpbmRdLiBSYWlzZXMgaWYgdGhlcmUgaXMgbm8gdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkuICopXG4gICAgdmFsIGZpbmRfZXhuXG4gICAgICA6ICgoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+ICdkYXRhLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG5cbiAgICAoKiogQWRkcyBhIGtleS92YWx1ZSBwYWlyIGZvciBhIGtleSB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBjb250YWluLCBvciByZXBvcnRzIGFcbiAgICAgICAgZHVwbGljYXRlLiAqKVxuICAgIHZhbCBhZGRcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4ga2V5OidrZXkga2V5XG4gICAgICAgICAgLT4gZGF0YTonZGF0YVxuICAgICAgICAgIC0+IFsgYE9rIG9mICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgfCBgRHVwbGljYXRlIF1cbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogTGlrZSBbYWRkXS4gUmFpc2VzIG9uIGR1cGxpY2F0ZXMuICopXG4gICAgdmFsIGFkZF9leG5cbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4ga2V5OidrZXkga2V5XG4gICAgICAgICAgLT4gZGF0YTonZGF0YVxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogQWRkcyBvciByZXBsYWNlcyBhIGtleS92YWx1ZSBwYWlyIGluIHRoZSBkaWN0aW9uYXJ5LiAqKVxuICAgIHZhbCBzZXRcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4ga2V5OidrZXkga2V5XG4gICAgICAgICAgLT4gZGF0YTonZGF0YVxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogUmVtb3ZlcyBhbnkgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkuICopXG4gICAgdmFsIHJlbW92ZVxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBBZGRzLCByZXBsYWNlcywgb3IgcmVtb3ZlcyB0aGUgdmFsdWUgZm9yIGEgZ2l2ZW4ga2V5LCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnRcbiAgICAgICAgdmFsdWUgb3IgbGFjayB0aGVyZW9mLiAqKVxuICAgIHZhbCBjaGFuZ2VcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gJ2tleSBrZXlcbiAgICAgICAgICAtPiBmOignZGF0YSBvcHRpb24gLT4gJ2RhdGEgb3B0aW9uKVxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogQWRkcyBvciByZXBsYWNlcyB0aGUgdmFsdWUgZm9yIGEgZ2l2ZW4ga2V5LCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgdmFsdWUgb3JcbiAgICAgICAgbGFjayB0aGVyZW9mLiAqKVxuICAgIHZhbCB1cGRhdGVcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gJ2tleSBrZXlcbiAgICAgICAgICAtPiBmOignZGF0YSBvcHRpb24gLT4gJ2RhdGEpXG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBBZGRzIFtkYXRhXSB0byB0aGUgZXhpc3Rpbmcga2V5L3ZhbHVlIHBhaXIgZm9yIFtrZXldLiBJbnRlcnByZXRzIGEgbWlzc2luZyBrZXkgYXNcbiAgICAgICAgaGF2aW5nIGFuIGVtcHR5IGxpc3QuICopXG4gICAgdmFsIGFkZF9tdWx0aVxuICAgICAgOiAoICgna2V5LCAnZGF0YSBsaXN0LCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+IGtleTona2V5IGtleVxuICAgICAgICAgIC0+IGRhdGE6J2RhdGFcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEgbGlzdCwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogUmVtb3ZlcyBvbmUgZWxlbWVudCBmcm9tIHRoZSBleGlzdGluZyBrZXkvdmFsdWUgcGFpciBmb3IgW2tleV0uIFJlbW92ZXMgdGhlIGtleVxuICAgICAgICBlbnRpcmVseSBpZiB0aGUgbmV3IGxpc3QgaXMgZW1wdHkuICopXG4gICAgdmFsIHJlbW92ZV9tdWx0aVxuICAgICAgOiAoICgna2V5LCAnZGF0YSBsaXN0LCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiAoJ2tleSwgJ2RhdGEgbGlzdCwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogUHJvZHVjZXMgdGhlIGxpc3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGtleS4gSW50ZXJwcmV0cyBhIG1pc3NpbmdcbiAgICAgICAga2V5IGFzIGhhdmluZyBhbiBlbXB0eSBsaXN0LiAqKVxuICAgIHZhbCBmaW5kX211bHRpXG4gICAgICA6ICggKCdrZXksICdkYXRhIGxpc3QsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+ICdkYXRhIGxpc3RcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogQ29tYmluZXMgZXZlcnkgdmFsdWUgaW4gdGhlIGRpY3Rpb25hcnkuICopXG4gICAgdmFsIGZvbGRcbiAgICAgIDogICgna2V5LCAnZGF0YSwgXykgdFxuICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiAnYWNjIC0+ICdhY2MpXG4gICAgICAtPiAnYWNjXG5cbiAgICAoKiogTGlrZSBbZm9sZF0uIE1heSBzdG9wIGJlZm9yZSBjb21wbGV0aW5nIHRoZSBpdGVyYXRpb24uICopXG4gICAgdmFsIGZvbGRfdW50aWxcbiAgICAgIDogICgna2V5LCAnZGF0YSwgXykgdFxuICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAtPiBmOlxuICAgICAgICAgICAoa2V5OidrZXkga2V5XG4gICAgICAgICAgICAtPiBkYXRhOidkYXRhXG4gICAgICAgICAgICAtPiAnYWNjXG4gICAgICAgICAgICAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAgIC0+ICdmaW5hbFxuXG4gICAgKCoqIFdoZXRoZXIgZXZlcnkgdmFsdWUgc2F0aXNmaWVzIFtmXS4gKilcbiAgICB2YWwgZm9yX2FsbCA6ICgna2V5LCAnZGF0YSwgXykgdCAtPiBmOignZGF0YSAtPiBib29sKSAtPiBib29sXG5cbiAgICAoKiogTGlrZSBbZm9yX2FsbF0uIFRoZSBwcmVkaWNhdGUgbWF5IGFsc28gZGVwZW5kIG9uIHRoZSBhc3NvY2lhdGVkIGtleS4gKilcbiAgICB2YWwgZm9yX2FsbGkgOiAoJ2tleSwgJ2RhdGEsIF8pIHQgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICAgKCoqIFdoZXRoZXIgYXQgbGVhc3Qgb25lIHZhbHVlIHNhdGlzZmllcyBbZl0uICopXG4gICAgdmFsIGV4aXN0cyA6ICgna2V5LCAnZGF0YSwgXykgdCAtPiBmOignZGF0YSAtPiBib29sKSAtPiBib29sXG5cbiAgICAoKiogTGlrZSBbZXhpc3RzXS4gVGhlIHByZWRpY2F0ZSBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBleGlzdHNpIDogKCdrZXksICdkYXRhLCBfKSB0IC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAgICgqKiBIb3cgbWFueSB2YWx1ZXMgc2F0aXNmeSBbZl0uICopXG4gICAgdmFsIGNvdW50IDogKCdrZXksICdkYXRhLCBfKSB0IC0+IGY6KCdkYXRhIC0+IGJvb2wpIC0+IGludFxuXG4gICAgKCoqIExpa2UgW2NvdW50XS4gVGhlIHByZWRpY2F0ZSBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBjb3VudGkgOiAoJ2tleSwgJ2RhdGEsIF8pIHQgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gYm9vbCkgLT4gaW50XG5cbiAgICAoKiogU3VtIHVwIFtmIGRhdGFdIGZvciBhbGwgZGF0YSBpbiB0aGUgZGljdGlvbmFyeS4gKilcbiAgICB2YWwgc3VtXG4gICAgICA6ICAobW9kdWxlIENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgLT4gKCdrZXksICdkYXRhLCBfKSB0XG4gICAgICAtPiBmOignZGF0YSAtPiAnYSlcbiAgICAgIC0+ICdhXG5cbiAgICAoKiogTGlrZSBbc3VtXS4gVGhlIGZ1bmN0aW9uIG1heSBhbHNvIGRlcGVuZCBvbiB0aGUgYXNzb2NpYXRlZCBrZXkuICopXG4gICAgdmFsIHN1bWlcbiAgICAgIDogIChtb2R1bGUgQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICAtPiAoJ2tleSwgJ2RhdGEsIF8pIHRcbiAgICAgIC0+IGY6KGtleTona2V5IC0+IGRhdGE6J2RhdGEgLT4gJ2EpXG4gICAgICAtPiAnYVxuXG4gICAgKCoqIFByb2R1Y2VzIHRoZSBrZXkvdmFsdWUgcGFpciB3aXRoIHRoZSBzbWFsbGVzdCBrZXkgaWYgbm9uLWVtcHR5LiAqKVxuICAgIHZhbCBtaW5fZWx0IDogKCdrZXksICdkYXRhLCBfKSB0IC0+ICgna2V5IGtleSAqICdkYXRhKSBvcHRpb25cblxuICAgICgqKiBMaWtlIFttaW5fZWx0XS4gUmFpc2VzIGlmIGVtcHR5LiAqKVxuICAgIHZhbCBtaW5fZWx0X2V4biA6ICgna2V5LCAnZGF0YSwgXykgdCAtPiAna2V5IGtleSAqICdkYXRhXG5cbiAgICAoKiogUHJvZHVjZXMgdGhlIGtleS92YWx1ZSBwYWlyIHdpdGggdGhlIGxhcmdlc3Qga2V5IGlmIG5vbi1lbXB0eS4gKilcbiAgICB2YWwgbWF4X2VsdCA6ICgna2V5LCAnZGF0YSwgXykgdCAtPiAoJ2tleSBrZXkgKiAnZGF0YSkgb3B0aW9uXG5cbiAgICAoKiogTGlrZSBbbWF4X2VsdF0uIFJhaXNlcyBpZiBlbXB0eS4gKilcbiAgICB2YWwgbWF4X2VsdF9leG4gOiAoJ2tleSwgJ2RhdGEsIF8pIHQgLT4gJ2tleSBrZXkgKiAnZGF0YVxuXG4gICAgKCoqIENhbGxzIFtmXSBmb3IgZXZlcnkga2V5LiAqKVxuICAgIHZhbCBpdGVyX2tleXMgOiAoJ2tleSwgXywgXykgdCAtPiBmOigna2V5IGtleSAtPiB1bml0KSAtPiB1bml0XG5cbiAgICAoKiogQ2FsbHMgW2ZdIGZvciBldmVyeSB2YWx1ZS4gKilcbiAgICB2YWwgaXRlciA6IChfLCAnZGF0YSwgXykgdCAtPiBmOignZGF0YSAtPiB1bml0KSAtPiB1bml0XG5cbiAgICAoKiogQ2FsbHMgW2ZdIGZvciBldmVyeSBrZXkvdmFsdWUgcGFpci4gKilcbiAgICB2YWwgaXRlcmkgOiAoJ2tleSwgJ2RhdGEsIF8pIHQgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICAgKCoqIFRyYW5zZm9ybXMgZXZlcnkgdmFsdWUuICopXG4gICAgdmFsIG1hcFxuICAgICAgOiAgKCdrZXksICdkYXRhMSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KCdkYXRhMSAtPiAnZGF0YTIpXG4gICAgICAtPiAoJ2tleSwgJ2RhdGEyLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIExpa2UgW21hcF0uIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBtYXBpXG4gICAgICA6ICAoJ2tleSwgJ2RhdGExLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGExIC0+ICdkYXRhMilcbiAgICAgIC0+ICgna2V5LCAnZGF0YTIsICdwaGFudG9tKSB0XG5cbiAgICAoKiogUHJvZHVjZXMgb25seSB0aG9zZSBrZXkvdmFsdWUgcGFpcnMgd2hvc2Uga2V5IHNhdGlzZmllcyBbZl0uICopXG4gICAgdmFsIGZpbHRlcl9rZXlzXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOigna2V5IGtleSAtPiBib29sKVxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIFByb2R1Y2VzIG9ubHkgdGhvc2Uga2V5L3ZhbHVlIHBhaXJzIHdob3NlIHZhbHVlIHNhdGlzZmllcyBbZl0uICopXG4gICAgdmFsIGZpbHRlclxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooJ2RhdGEgLT4gYm9vbClcbiAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcblxuICAgICgqKiBQcm9kdWNlcyBvbmx5IHRob3NlIGtleS92YWx1ZSBwYWlycyB3aGljaCBzYXRpc2Z5IFtmXS4gKilcbiAgICB2YWwgZmlsdGVyaVxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gYm9vbClcbiAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcblxuICAgICgqKiBQcm9kdWNlcyBrZXkvdmFsdWUgcGFpcnMgZm9yIHdoaWNoIFtmXSBwcm9kdWNlcyBbU29tZV0uICopXG4gICAgdmFsIGZpbHRlcl9tYXBcbiAgICAgIDogICgna2V5LCAnZGF0YTEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOignZGF0YTEgLT4gJ2RhdGEyIG9wdGlvbilcbiAgICAgIC0+ICgna2V5LCAnZGF0YTIsICdwaGFudG9tKSB0XG5cbiAgICAoKiogTGlrZSBbZmlsdGVyX21hcF0uIFRoZSBuZXcgdmFsdWUgbWF5IGFsc28gZGVwZW5kIG9uIHRoZSBhc3NvY2lhdGVkIGtleS4gKilcbiAgICB2YWwgZmlsdGVyX21hcGlcbiAgICAgIDogICgna2V5LCAnZGF0YTEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YTEgLT4gJ2RhdGEyIG9wdGlvbilcbiAgICAgIC0+ICgna2V5LCAnZGF0YTIsICdwaGFudG9tKSB0XG5cbiAgICAoKiogU3BsaXRzIG9uZSBkaWN0aW9uYXJ5IGludG8gdHdvLiBUaGUgZmlyc3QgY29udGFpbnMga2V5L3ZhbHVlIHBhaXJzIGZvciB3aGljaCB0aGVcbiAgICAgICAgdmFsdWUgc2F0aXNmaWVzIFtmXS4gVGhlIHNlY29uZCBjb250YWlucyB0aGUgcmVtYWluZGVyLiAqKVxuICAgIHZhbCBwYXJ0aXRpb25fdGZcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KCdkYXRhIC0+IGJvb2wpXG4gICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0ICogKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIExpa2UgW3BhcnRpdGlvbl90Zl0uIFRoZSBwcmVkaWNhdGUgbWF5IGFsc28gZGVwZW5kIG9uIHRoZSBhc3NvY2lhdGVkIGtleS4gKilcbiAgICB2YWwgcGFydGl0aW9uaV90ZlxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gYm9vbClcbiAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgKiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG5cbiAgICAoKiogU3BsaXRzIG9uZSBkaWN0aW9uYXJ5IGludG8gdHdvLCBjb3JyZXNwb25kaW5nIHJlc3BlY3RpdmVseSB0byBbRmlyc3QgX10gYW5kXG4gICAgICAgIFtTZWNvbmQgX10gcmVzdWx0cyBmcm9tIFtmXS4gKilcbiAgICB2YWwgcGFydGl0aW9uX21hcFxuICAgICAgOiAgKCdrZXksICdkYXRhMSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KCdkYXRhMSAtPiAoJ2RhdGEyLCAnZGF0YTMpIEVpdGhlci50KVxuICAgICAgLT4gKCdrZXksICdkYXRhMiwgJ3BoYW50b20pIHQgKiAoJ2tleSwgJ2RhdGEzLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIExpa2UgW3BhcnRpdGlvbl9tYXBdLiBUaGUgc3BsaXQgbWF5IGFsc28gZGVwZW5kIG9uIHRoZSBhc3NvY2lhdGVkIGtleS4gKilcbiAgICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICAgIDogICgna2V5LCAnZGF0YTEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YTEgLT4gKCdkYXRhMiwgJ2RhdGEzKSBFaXRoZXIudClcbiAgICAgIC0+ICgna2V5LCAnZGF0YTIsICdwaGFudG9tKSB0ICogKCdrZXksICdkYXRhMywgJ3BoYW50b20pIHRcblxuICAgICgqKiBQcm9kdWNlcyBhbiBlcnJvciBjb21iaW5pbmcgYWxsIGVycm9yIG1lc3NhZ2VzIGZyb20ga2V5L3ZhbHVlIHBhaXJzLCBvciBhXG4gICAgICAgIGRpY3Rpb25hcnkgb2YgYWxsIFtPa10gdmFsdWVzIGlmIG5vbmUgYXJlIFtFcnJvcl0uICopXG4gICAgdmFsIGNvbWJpbmVfZXJyb3JzXG4gICAgICA6ICggKCdrZXksICdkYXRhIE9yX2Vycm9yLnQsICdwaGFudG9tKSB0IC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgT3JfZXJyb3IudFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBTcGxpdHMgdGhlIFtmc3RdIGFuZCBbc25kXSBjb21wb25lbnRzIG9mIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGgga2V5cyBpbnRvIHNlcGFyYXRlXG4gICAgICAgIGRpY3Rpb25hcmllcy4gKilcbiAgICB2YWwgdW56aXBcbiAgICAgIDogICgna2V5LCAnZGF0YTEgKiAnZGF0YTIsICdwaGFudG9tKSB0XG4gICAgICAtPiAoJ2tleSwgJ2RhdGExLCAncGhhbnRvbSkgdCAqICgna2V5LCAnZGF0YTIsICdwaGFudG9tKSB0XG5cbiAgICAoKiogTWVyZ2VzIHR3byBkaWN0aW9uYXJpZXMgYnkgZnVsbHkgdHJhdmVyc2luZyBib3RoLiBOb3Qgc3VpdGFibGUgZm9yIGVmZmljaWVudGx5XG4gICAgICAgIG1lcmdpbmcgbGlzdHMgb2YgZGljdGlvbmFyaWVzLiBTZWUgW21lcmdlX2Rpc2pvaW50X2V4bl0gYW5kIFttZXJnZV9za2V3ZWRdXG4gICAgICAgIGluc3RlYWQuICopXG4gICAgdmFsIG1lcmdlXG4gICAgICA6ICggKCdrZXksICdkYXRhMSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEyLCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+IGY6XG4gICAgICAgICAgICAgICAoa2V5OidrZXkga2V5XG4gICAgICAgICAgICAgICAgLT4gWyBgTGVmdCBvZiAnZGF0YTEgfCBgUmlnaHQgb2YgJ2RhdGEyIHwgYEJvdGggb2YgJ2RhdGExICogJ2RhdGEyIF1cbiAgICAgICAgICAgICAgICAtPiAnZGF0YTMgb3B0aW9uKVxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YTMsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIE1lcmdlcyB0d28gZGljdGlvbmFyaWVzIHdpdGggdGhlIHNhbWUgdHlwZSBvZiBkYXRhIGFuZCBkaXNqb2ludCBzZXRzIG9mIGtleXMuXG4gICAgICAgIFJhaXNlcyBpZiBhbnkga2V5cyBvdmVybGFwLiAqKVxuICAgIHZhbCBtZXJnZV9kaXNqb2ludF9leG5cbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogTWVyZ2VzIHR3byBkaWN0aW9uYXJpZXMgYnkgdHJhdmVyc2luZyBvbmx5IHRoZSBzbWFsbGVyIG9mIHRoZSB0d28uIEFkZHMga2V5L3ZhbHVlXG4gICAgICAgIHBhaXJzIG1pc3NpbmcgZnJvbSB0aGUgbGFyZ2VyIGRpY3Rpb25hcnksIGFuZCBbY29tYmluZV1zIGR1cGxpY2F0ZSB2YWx1ZXMuICopXG4gICAgdmFsIG1lcmdlX3NrZXdlZFxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gY29tYmluZTooa2V5OidrZXkga2V5IC0+ICdkYXRhIC0+ICdkYXRhIC0+ICdkYXRhKVxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogQ29tcHV0ZXMgYSBzZXF1ZW5jZSBvZiBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byBkaWN0aW9uYXJpZXMuICopXG4gICAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiBkYXRhX2VxdWFsOignZGF0YSAtPiAnZGF0YSAtPiBib29sKVxuICAgICAgICAgIC0+ICgna2V5IGtleSAqIFsgYExlZnQgb2YgJ2RhdGEgfCBgUmlnaHQgb2YgJ2RhdGEgfCBgVW5lcXVhbCBvZiAnZGF0YSAqICdkYXRhIF0pXG4gICAgICAgICAgICAgU2VxdWVuY2UudFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBGb2xkcyBvdmVyIHRoZSByZXN1bHQgb2YgW3N5bW1ldHJpY19kaWZmXS4gTWF5IGJlIG1vcmUgcGVyZm9ybWFudC4gKilcbiAgICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gZGF0YV9lcXVhbDooJ2RhdGEgLT4gJ2RhdGEgLT4gYm9vbClcbiAgICAgICAgICAtPiBpbml0OidhY2NcbiAgICAgICAgICAtPiBmOlxuICAgICAgICAgICAgICAgKCdhY2NcbiAgICAgICAgICAgICAgICAtPiAna2V5IGtleVxuICAgICAgICAgICAgICAgICAgICogWyBgTGVmdCBvZiAnZGF0YSB8IGBSaWdodCBvZiAnZGF0YSB8IGBVbmVxdWFsIG9mICdkYXRhICogJ2RhdGEgXVxuICAgICAgICAgICAgICAgIC0+ICdhY2MpXG4gICAgICAgICAgLT4gJ2FjY1xuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnZGF0YSB0XG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIEFjY2Vzc29yc1xuICAgICAgICB3aXRoIHR5cGUgKF8sICdkYXRhLCBfKSB0IDo9ICdkYXRhIHRcbiAgICAgICAgIGFuZCB0eXBlIF8ga2V5IDo9IGtleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgXywgXywgXykgYWNjZXNzb3IgOj0gJ2ZuXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczIgPSBzaWdcbiAgICB0eXBlICgna2V5LCAnZGF0YSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEpIGFjY2Vzc29yXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIEFjY2Vzc29yc1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCBfKSB0IDo9ICgna2V5LCAnZGF0YSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsIF8pIGFjY2Vzc29yIDo9ICgnZm4sICdrZXksICdkYXRhKSBhY2Nlc3NvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMzID0gc2lnXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIEFjY2Vzc29yc1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCA6PSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9ycyA9IHNpZ1xuICAgICgqKiBUaGUgdHlwZSBvZiBrZXlzLiBUaGlzIHdpbGwgYmUgWydrZXldIGZvciBwb2x5bW9ycGhpYyBkaWN0aW9uYXJpZXMsIG9yIHNvbWUgZml4ZWRcbiAgICAgICAgdHlwZSBmb3IgZGljdGlvbmFyaWVzIHdpdGggbW9ub21vcnBoaWMga2V5cy4gKilcbiAgICB0eXBlICdrZXkga2V5XG5cbiAgICAoKiogRGljdGlvbmFyaWVzLiBUaGVpciBrZXlzIGhhdmUgdHlwZSBbJ2tleSBrZXldLiBFYWNoIGtleSdzIGFzc29jaWF0ZWQgdmFsdWUgaGFzXG4gICAgICAgIHR5cGUgWydkYXRhXS4gVGhlIGRpY3Rpb25hcnkgbWF5IGJlIGRpc3Rpbmd1aXNoZWQgYnkgYSBbJ3BoYW50b21dIHR5cGUuICopXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG5cbiAgICAoKiogVGhlIHR5cGUgb2YgY3JlYXRvciBmdW5jdGlvbnMgWydmbl0gdGhhdCBvcGVyYXRlIG9uIFsoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XS5cbiAgICAgICAgTWF5IHRha2UgZXh0cmEgYXJndW1lbnRzIGJlZm9yZSBbJ2ZuXSwgc3VjaCBhcyBhIGNvbXBhcmlzb24gZnVuY3Rpb24uICopXG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGNyZWF0b3JcblxuICAgICgqKiBUaGUgZW1wdHkgZGljdGlvbmFyeS4gKilcbiAgICB2YWwgZW1wdHkgOiAoKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG5cbiAgICAoKiogRGljdGlvbmFyeSB3aXRoIGEgc2luZ2xlIGtleS92YWx1ZSBwYWlyLiAqKVxuICAgIHZhbCBzaW5nbGV0b25cbiAgICAgIDogKCdrZXkga2V5IC0+ICdkYXRhIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQsICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvclxuXG4gICAgKCoqIERpY3Rpb25hcnkgY29udGFpbmluZyB0aGUgZ2l2ZW4ga2V5L3ZhbHVlIHBhaXJzLiBGYWlscyBpZiB0aGVyZSBhcmUgZHVwbGljYXRlXG4gICAgICAgIGtleXMuICopXG4gICAgdmFsIG9mX2FsaXN0XG4gICAgICA6ICggKCdrZXkga2V5ICogJ2RhdGEpIGxpc3RcbiAgICAgICAgICAtPiBbIGBPayBvZiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2tleSBrZXkgXVxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0XS4gUmV0dXJucyBhIFtSZXN1bHQudF0uICopXG4gICAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgICA6ICggKCdrZXkga2V5ICogJ2RhdGEpIGxpc3QgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCBPcl9lcnJvci50XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3RdLiBSYWlzZXMgb24gZHVwbGljYXRlcy4gKilcbiAgICB2YWwgb2ZfYWxpc3RfZXhuXG4gICAgICA6ICggKCdrZXkga2V5ICogJ2RhdGEpIGxpc3QgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIFByb2R1Y2VzIGEgZGljdGlvbmFyeSBtYXBwaW5nIGVhY2gga2V5IHRvIGEgbGlzdCBvZiBhc3NvY2lhdGVkIHZhbHVlcy4gKilcbiAgICB2YWwgb2ZfYWxpc3RfbXVsdGlcbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdCAtPiAoJ2tleSwgJ2RhdGEgbGlzdCwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBQcm9kdWNlcyBhIGRpY3Rpb25hcnkgdXNpbmcgZWFjaCBrZXkvdmFsdWUgcGFpci4gQ29tYmluZXMgYWxsIHZhbHVlcyBmb3IgYSBnaXZlblxuICAgICAgICBrZXkgd2l0aCBbaW5pdF0gdXNpbmcgW2ZdLiAqKVxuICAgIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgICA6ICggKCdrZXkga2V5ICogJ2RhdGEpIGxpc3RcbiAgICAgICAgICAtPiBpbml0OidhY2NcbiAgICAgICAgICAtPiBmOignYWNjIC0+ICdkYXRhIC0+ICdhY2MpXG4gICAgICAgICAgLT4gKCdrZXksICdhY2MsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogUHJvZHVjZXMgYSBkaWN0aW9uYXJ5IHVzaW5nIGVhY2gga2V5L3ZhbHVlIHBhaXIuIENvbWJpbmVzIG11bHRpcGxlIHZhbHVlcyBmb3IgYVxuICAgICAgICBnaXZlbiBrZXkgdXNpbmcgW2ZdLiAqKVxuICAgIHZhbCBvZl9hbGlzdF9yZWR1Y2VcbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdFxuICAgICAgICAgIC0+IGY6KCdkYXRhIC0+ICdkYXRhIC0+ICdkYXRhKVxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF0uIENvbnN1bWVzIGEgc2VxdWVuY2UuICopXG4gICAgdmFsIG9mX3NlcXVlbmNlXG4gICAgICA6ICggKCdrZXkga2V5ICogJ2RhdGEpIFNlcXVlbmNlLnRcbiAgICAgICAgICAtPiBbIGBPayBvZiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2tleSBrZXkgXVxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0X29yX2Vycm9yXS4gQ29uc3VtZXMgYSBzZXF1ZW5jZS4gKilcbiAgICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3JcbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgU2VxdWVuY2UudCAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IE9yX2Vycm9yLnRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF9leG5dLiBDb25zdW1lcyBhIHNlcXVlbmNlLiAqKVxuICAgIHZhbCBvZl9zZXF1ZW5jZV9leG5cbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgU2VxdWVuY2UudCAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3RfbXVsdGldLiBDb25zdW1lcyBhIHNlcXVlbmNlLiAqKVxuICAgIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aVxuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBTZXF1ZW5jZS50IC0+ICgna2V5LCAnZGF0YSBsaXN0LCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0X2ZvbGRdLiBDb25zdW1lcyBhIHNlcXVlbmNlLiAqKVxuICAgIHZhbCBvZl9zZXF1ZW5jZV9mb2xkXG4gICAgICA6ICggKCdrZXkga2V5ICogJ2RhdGEpIFNlcXVlbmNlLnRcbiAgICAgICAgICAtPiBpbml0OidjXG4gICAgICAgICAgLT4gZjooJ2MgLT4gJ2RhdGEgLT4gJ2MpXG4gICAgICAgICAgLT4gKCdrZXksICdjLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0X3JlZHVjZV0uIENvbnN1bWVzIGEgc2VxdWVuY2UuICopXG4gICAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBTZXF1ZW5jZS50XG4gICAgICAgICAgLT4gZjooJ2RhdGEgLT4gJ2RhdGEgLT4gJ2RhdGEpXG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0XS4gQ29uc3VtZSB2YWx1ZXMgZm9yIHdoaWNoIGtleXMgY2FuIGJlIGNvbXB1dGVkLiAqKVxuICAgIHZhbCBvZl9saXN0X3dpdGhfa2V5XG4gICAgICA6ICggJ2RhdGEgbGlzdFxuICAgICAgICAgIC0+IGdldF9rZXk6KCdkYXRhIC0+ICdrZXkga2V5KVxuICAgICAgICAgIC0+IFsgYE9rIG9mICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgfCBgRHVwbGljYXRlX2tleSBvZiAna2V5IGtleSBdXG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3Rfb3JfZXJyb3JdLiBDb25zdW1lIHZhbHVlcyBmb3Igd2hpY2gga2V5cyBjYW4gYmUgY29tcHV0ZWQuICopXG4gICAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3JcbiAgICAgIDogKCAnZGF0YSBsaXN0IC0+IGdldF9rZXk6KCdkYXRhIC0+ICdrZXkga2V5KSAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IE9yX2Vycm9yLnRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF9leG5dLiBDb25zdW1lIHZhbHVlcyBmb3Igd2hpY2gga2V5cyBjYW4gYmUgY29tcHV0ZWQuICopXG4gICAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlfZXhuXG4gICAgICA6ICggJ2RhdGEgbGlzdCAtPiBnZXRfa2V5OignZGF0YSAtPiAna2V5IGtleSkgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0X211bHRpXS4gQ29uc3VtZSB2YWx1ZXMgZm9yIHdoaWNoIGtleXMgY2FuIGJlIGNvbXB1dGVkLiAqKVxuICAgIHZhbCBvZl9saXN0X3dpdGhfa2V5X211bHRpXG4gICAgICA6ICggJ2RhdGEgbGlzdCAtPiBnZXRfa2V5OignZGF0YSAtPiAna2V5IGtleSkgLT4gKCdrZXksICdkYXRhIGxpc3QsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogUHJvZHVjZXMgYSBkaWN0aW9uYXJ5IG9mIGFsbCBrZXkvdmFsdWUgcGFpcnMgdGhhdCBbaXRlcmldIHBhc3NlcyB0byBbfmZdLiBGYWlscyBpZlxuICAgICAgICBhIGR1cGxpY2F0ZSBrZXkgaXMgZm91bmQuICopXG4gICAgdmFsIG9mX2l0ZXJpXG4gICAgICA6ICggaXRlcmk6KGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgICAgICAgLT4gWyBgT2sgb2YgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrZXkga2V5IF1cbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9pdGVyaV0uIFJhaXNlcyBvbiBkdXBsaWNhdGUga2V5LiAqKVxuICAgIHZhbCBvZl9pdGVyaV9leG5cbiAgICAgIDogKCBpdGVyaTooZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMSA9IHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnZGF0YSB0XG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIENyZWF0b3JzXG4gICAgICAgIHdpdGggdHlwZSAoXywgJ2RhdGEsIF8pIHQgOj0gJ2RhdGEgdFxuICAgICAgICAgYW5kIHR5cGUgXyBrZXkgOj0ga2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCBfLCBfLCBfKSBjcmVhdG9yIDo9ICdmblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczIgPSBzaWdcbiAgICB0eXBlICgna2V5LCAnZGF0YSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEpIGNyZWF0b3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgXykgdCA6PSAoJ2tleSwgJ2RhdGEpIHRcbiAgICAgICAgIGFuZCB0eXBlICdrZXkga2V5IDo9ICdrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCBfKSBjcmVhdG9yIDo9ICgnZm4sICdrZXksICdkYXRhKSBjcmVhdG9yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMyA9IHNpZ1xuICAgIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIENyZWF0b3JzXG4gICAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IDo9ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgIGFuZCB0eXBlICdrZXkga2V5IDo9ICdrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSAna2V5IGtleVxuICAgIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIEFjY2Vzc29yc1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCA6PSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5IGtleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgOj0gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleSBrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnZGF0YSB0XG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIFNcbiAgICAgICAgd2l0aCB0eXBlIChfLCAnZGF0YSwgXykgdCA6PSAnZGF0YSB0XG4gICAgICAgICBhbmQgdHlwZSBfIGtleSA6PSBrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sIF8sIF8sIF8pIGFjY2Vzc29yIDo9ICdmblxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgXywgXywgXykgY3JlYXRvciA6PSAnZm5cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgna2V5LCAnZGF0YSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEpIGFjY2Vzc29yXG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSkgY3JlYXRvclxuXG4gICAgKCoqIEBpbmxpbmUgKilcbiAgICBpbmNsdWRlXG4gICAgICBTXG4gICAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsIF8pIHQgOj0gKCdrZXksICdkYXRhKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgXykgYWNjZXNzb3IgOj0gKCdmbiwgJ2tleSwgJ2RhdGEpIGFjY2Vzc29yXG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgXykgY3JlYXRvciA6PSAoJ2ZuLCAna2V5LCAnZGF0YSkgY3JlYXRvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIFNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgOj0gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvclxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBEaWN0aW9uYXJ5X2ltbXV0YWJsZSA9IHNpZ1xuICAoKiogQGlubGluZSAqKVxuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgRGVmaW5pdGlvbnMgKCoqIEBpbmxpbmUgKilcbiAgZW5kXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHQgPVxuICB8IEluY2wgb2YgJ2FcbiAgfCBFeGNsIG9mICdhXG4gIHwgVW5ib3VuZGVkXG5bQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXIsIGdsb2JhbGl6ZV1cblxubGV0IGFsbCA6ICdhLiAnYSBsaXN0IC0+ICdhIHQgbGlzdCA9XG4gIGZ1biBfYWxsX29mX2EgLT5cbiAgUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5hcHBlbmRcbiAgICAobGV0IHJlYyBtYXAgbCBhY2MgPVxuICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgIHwgW10gLT4gUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5yZXYgYWNjXG4gICAgICAgfCBlbnVtZXJhdGVfXzAwMV8gOjogbCAtPiBtYXAgbCAoSW5jbCBlbnVtZXJhdGVfXzAwMV8gOjogYWNjKVxuICAgICBpblxuICAgICBtYXAgX2FsbF9vZl9hIFtdKVxuICAgIChQcHhfZW51bWVyYXRlX2xpYi5MaXN0LmFwcGVuZFxuICAgICAgIChsZXQgcmVjIG1hcCBsIGFjYyA9XG4gICAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LnJldiBhY2NcbiAgICAgICAgICB8IGVudW1lcmF0ZV9fMDAyXyA6OiBsIC0+IG1hcCBsIChFeGNsIGVudW1lcmF0ZV9fMDAyXyA6OiBhY2MpXG4gICAgICAgIGluXG4gICAgICAgIG1hcCBfYWxsX29mX2EgW10pXG4gICAgICAgWyBVbmJvdW5kZWQgXSlcbjs7XG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICBmdW4gKHR5cGUgYV9fMDE4XykgOiAoKFNleHBsaWIwLlNleHAudCAtPiBhX18wMThfKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDE4XyB0KSAtPlxuICBsZXQgZXJyb3Jfc291cmNlX18wMDZfID0gXCJtYXliZV9ib3VuZC5tbC50XCIgaW5cbiAgZnVuIF9vZl9hX18wMDNfIC0+IGZ1bmN0aW9uXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiaW5jbFwiIHwgXCJJbmNsXCIpIGFzIF90YWdfXzAwOV8pIDo6IHNleHBfYXJnc19fMDEwXykgYXNcbiAgICAgIF9zZXhwX18wMDhfIC0+XG4gICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTBfIHdpdGhcbiAgICAgICB8IFsgYXJnMF9fMDExXyBdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDEyXyA9IF9vZl9hX18wMDNfIGFyZzBfXzAxMV8gaW5cbiAgICAgICAgIEluY2wgcmVzMF9fMDEyX1xuICAgICAgIHwgXyAtPlxuICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNl9cbiAgICAgICAgICAgX3RhZ19fMDA5X1xuICAgICAgICAgICBfc2V4cF9fMDA4XylcbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJleGNsXCIgfCBcIkV4Y2xcIikgYXMgX3RhZ19fMDE0XykgOjogc2V4cF9hcmdzX18wMTVfKSBhc1xuICAgICAgX3NleHBfXzAxM18gLT5cbiAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxNV8gd2l0aFxuICAgICAgIHwgWyBhcmcwX18wMTZfIF0gLT5cbiAgICAgICAgIGxldCByZXMwX18wMTdfID0gX29mX2FfXzAwM18gYXJnMF9fMDE2XyBpblxuICAgICAgICAgRXhjbCByZXMwX18wMTdfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA2X1xuICAgICAgICAgICBfdGFnX18wMTRfXG4gICAgICAgICAgIF9zZXhwX18wMTNfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInVuYm91bmRlZFwiIHwgXCJVbmJvdW5kZWRcIikgLT4gVW5ib3VuZGVkXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5jbFwiIHwgXCJJbmNsXCIpIGFzIHNleHBfXzAwN18gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJleGNsXCIgfCBcIkV4Y2xcIikgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwidW5ib3VuZGVkXCIgfCBcIlVuYm91bmRlZFwiKSA6OiBfKSBhc1xuICAgICAgc2V4cF9fMDA3XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNV8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNV8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgfCBzZXhwX18wMDVfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gKHR5cGUgYV9fMDI0XykgOiAoKGFfXzAyNF8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiBhX18wMjRfIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICBmdW4gX29mX2FfXzAxOV8gLT4gZnVuY3Rpb25cbiAgfCBJbmNsIGFyZzBfXzAyMF8gLT5cbiAgICBsZXQgcmVzMF9fMDIxXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMF8gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJJbmNsXCI7IHJlczBfXzAyMV8gXVxuICB8IEV4Y2wgYXJnMF9fMDIyXyAtPlxuICAgIGxldCByZXMwX18wMjNfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIyXyBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkV4Y2xcIjsgcmVzMF9fMDIzXyBdXG4gIHwgVW5ib3VuZGVkIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlVuYm91bmRlZFwiXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJJbmNsXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJFeGNsXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiVW5ib3VuZGVkXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBnbG9iYWxpemUgOiAnYS4gKCdhIC0+ICdhKSAtPiAnYSB0IC0+ICdhIHQgPVxuICBmdW4gKHR5cGUgYV9fMDI1XykgOiAoKGFfXzAyNV8gLT4gYV9fMDI1XykgLT4gYV9fMDI1XyB0IC0+IGFfXzAyNV8gdCkgLT5cbiAgZnVuIF9nbG9iYWxpemVfYV9fMDI2XyB4X18wMjdfIC0+XG4gIG1hdGNoIHhfXzAyN18gd2l0aFxuICB8IFVuYm91bmRlZCBhcyB4X18wMjhfIC0+IHhfXzAyOF9cbiAgfCBJbmNsIGFyZ19fMDI5XyAtPiBJbmNsIChfZ2xvYmFsaXplX2FfXzAyNl8gYXJnX18wMjlfKVxuICB8IEV4Y2wgYXJnX18wMzBfIC0+IEV4Y2wgKF9nbG9iYWxpemVfYV9fMDI2XyBhcmdfXzAzMF8pXG47O1xuXG5bQEBAZW5kXVxuXG50eXBlIGludGVydmFsX2NvbXBhcmlzb24gPVxuICB8IEJlbG93X2xvd2VyX2JvdW5kXG4gIHwgSW5fcmFuZ2VcbiAgfCBBYm92ZV91cHBlcl9ib3VuZFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSB+bG9jYWxpemUsIGhhc2hdXG5cbmxldCBpbnRlcnZhbF9jb21wYXJpc29uX29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDMzXyA9IFwibWF5YmVfYm91bmQubWwuaW50ZXJ2YWxfY29tcGFyaXNvblwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiYmVsb3dfbG93ZXJfYm91bmRcIiB8IFwiQmVsb3dfbG93ZXJfYm91bmRcIikgLT4gQmVsb3dfbG93ZXJfYm91bmRcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluX3JhbmdlXCIgfCBcIkluX3JhbmdlXCIpIC0+IEluX3JhbmdlXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJhYm92ZV91cHBlcl9ib3VuZFwiIHwgXCJBYm92ZV91cHBlcl9ib3VuZFwiKSAtPiBBYm92ZV91cHBlcl9ib3VuZFxuICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImJlbG93X2xvd2VyX2JvdW5kXCIgfCBcIkJlbG93X2xvd2VyX2JvdW5kXCIpIDo6IF8pIGFzIHNleHBfXzAzNF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAzM18gc2V4cF9fMDM0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbl9yYW5nZVwiIHwgXCJJbl9yYW5nZVwiKSA6OiBfKSBhcyBzZXhwX18wMzRfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMzNfIHNleHBfXzAzNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJhYm92ZV91cHBlcl9ib3VuZFwiIHwgXCJBYm92ZV91cHBlcl9ib3VuZFwiKSA6OiBfKSBhcyBzZXhwX18wMzRfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMzNfIHNleHBfXzAzNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMzJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAzM18gc2V4cF9fMDMyX1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDMyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAzM18gc2V4cF9fMDMyX1xuICAgfCBzZXhwX18wMzJfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMzNfIHNleHBfXzAzMl9cbiAgICA6IFNleHBsaWIwLlNleHAudCAtPiBpbnRlcnZhbF9jb21wYXJpc29uKVxuOztcblxubGV0IHNleHBfb2ZfaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIChmdW5jdGlvblxuICAgfCBCZWxvd19sb3dlcl9ib3VuZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJCZWxvd19sb3dlcl9ib3VuZFwiXG4gICB8IEluX3JhbmdlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkluX3JhbmdlXCJcbiAgIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQWJvdmVfdXBwZXJfYm91bmRcIlxuICAgIDogaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5sZXQgKGludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbWFyIDogaW50ZXJ2YWxfY29tcGFyaXNvbiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIkJlbG93X2xvd2VyX2JvdW5kXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJJbl9yYW5nZVwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiQWJvdmVfdXBwZXJfYm91bmRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmVfaW50ZXJ2YWxfY29tcGFyaXNvbl9fbG9jYWwgPVxuICAoU3RkbGliLmNvbXBhcmUgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50KVxuOztcblxubGV0IGNvbXBhcmVfaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIChmdW4gYSBiIC0+IGNvbXBhcmVfaW50ZXJ2YWxfY29tcGFyaXNvbl9fbG9jYWwgYSBiXG4gICAgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50KVxuOztcblxubGV0IChoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiA6XG4gICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludFxuICAgICAgIGhzdlxuICAgICAgIChtYXRjaCBhcmcgd2l0aFxuICAgICAgICB8IEJlbG93X2xvd2VyX2JvdW5kIC0+IDBcbiAgICAgICAgfCBJbl9yYW5nZSAtPiAxXG4gICAgICAgIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gMilcbiAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbjs7XG5cbmxldCAoaGFzaF9pbnRlcnZhbF9jb21wYXJpc29uIDogaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX2ludGVydmFsX2NvbXBhcmlzb24gaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBJbmNsIGluY2wgLT4gSW5jbCAoZiBpbmNsKVxuICB8IEV4Y2wgZXhjbCAtPiBFeGNsIChmIGV4Y2wpXG4gIHwgVW5ib3VuZGVkIC0+IFVuYm91bmRlZFxuOztcblxubGV0IGlzX2xvd2VyX2JvdW5kIHQgfm9mXzphIH5jb21wYXJlID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgSW5jbCBpbmNsIC0+IGNvbXBhcmUgaW5jbCBhIDw9IDBcbiAgfCBFeGNsIGV4Y2wgLT4gY29tcGFyZSBleGNsIGEgPCAwXG4gIHwgVW5ib3VuZGVkIC0+IHRydWVcbjs7XG5cbmxldCBpc191cHBlcl9ib3VuZCB0IH5vZl86YSB+Y29tcGFyZSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEluY2wgaW5jbCAtPiBjb21wYXJlIGEgaW5jbCA8PSAwXG4gIHwgRXhjbCBleGNsIC0+IGNvbXBhcmUgYSBleGNsIDwgMFxuICB8IFVuYm91bmRlZCAtPiB0cnVlXG47O1xuXG5sZXQgYm91bmRzX2Nyb3NzZWQgfmxvd2VyIH51cHBlciB+Y29tcGFyZSA9XG4gIG1hdGNoIGxvd2VyIHdpdGhcbiAgfCBVbmJvdW5kZWQgLT4gZmFsc2VcbiAgfCBJbmNsIGxvd2VyIHwgRXhjbCBsb3dlciAtPlxuICAgIChtYXRjaCB1cHBlciB3aXRoXG4gICAgIHwgVW5ib3VuZGVkIC0+IGZhbHNlXG4gICAgIHwgSW5jbCB1cHBlciB8IEV4Y2wgdXBwZXIgLT4gY29tcGFyZSBsb3dlciB1cHBlciA+IDApXG47O1xuXG5sZXQgY2hlY2tfaW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgfmNvbXBhcmUgPVxuICBpZiBib3VuZHNfY3Jvc3NlZCB+bG93ZXIgfnVwcGVyIH5jb21wYXJlXG4gIHRoZW4gZmFpbHdpdGggXCJNYXliZV9ib3VuZC5jb21wYXJlX3RvX2ludGVydmFsX2V4bjogbG93ZXIgYm91bmQgPiB1cHBlciBib3VuZFwiXG47O1xuXG5sZXQgY29tcGFyZV90b19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciBhIH5jb21wYXJlID1cbiAgY2hlY2tfaW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgfmNvbXBhcmU7XG4gIGlmIG5vdCAoaXNfbG93ZXJfYm91bmQgbG93ZXIgfm9mXzphIH5jb21wYXJlKVxuICB0aGVuIEJlbG93X2xvd2VyX2JvdW5kXG4gIGVsc2UgaWYgbm90IChpc191cHBlcl9ib3VuZCB1cHBlciB+b2ZfOmEgfmNvbXBhcmUpXG4gIHRoZW4gQWJvdmVfdXBwZXJfYm91bmRcbiAgZWxzZSBJbl9yYW5nZVxuOztcblxubGV0IGludGVydmFsX2NvbnRhaW5zX2V4biB+bG93ZXIgfnVwcGVyIGEgfmNvbXBhcmUgPVxuICBtYXRjaCBjb21wYXJlX3RvX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIGEgfmNvbXBhcmUgd2l0aFxuICB8IEluX3JhbmdlIC0+IHRydWVcbiAgfCBCZWxvd19sb3dlcl9ib3VuZCB8IEFib3ZlX3VwcGVyX2JvdW5kIC0+IGZhbHNlXG47O1xuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBUXG5cbm1vZHVsZSBPcl9kdXBsaWNhdGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICBbIGBPayBvZiAnYVxuICAgIHwgYER1cGxpY2F0ZVxuICAgIF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICAgIGZ1biBfY21wX19hIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDAxXyBiX18wMDJfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMDFfLCBiX18wMDJfIHdpdGhcbiAgICAgIHwgYE9rIF9sZWZ0X18wMDNfLCBgT2sgX3JpZ2h0X18wMDRfIC0+IF9jbXBfX2EgX2xlZnRfXzAwM18gX3JpZ2h0X18wMDRfXG4gICAgICB8IGBEdXBsaWNhdGUsIGBEdXBsaWNhdGUgLT4gMFxuICAgICAgfCB4LCB5IC0+IFN0ZGxpYi5jb21wYXJlIHggeSlcbiAgOztcblxuICBsZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMDVfIGJfXzAwNl8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwNV8gYl9fMDA2X1xuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDA1XywgYl9fMDA2XyB3aXRoXG4gICAgICB8IGBPayBfbGVmdF9fMDA3XywgYE9rIF9yaWdodF9fMDA4XyAtPiBfY21wX19hIF9sZWZ0X18wMDdfIF9yaWdodF9fMDA4X1xuICAgICAgfCBgRHVwbGljYXRlLCBgRHVwbGljYXRlIC0+IHRydWVcbiAgICAgIHwgeCwgeSAtPiBTdGRsaWIuKCA9ICkgeCB5KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biBfb2ZfYV9fMDA5XyAtPiBmdW5jdGlvblxuICAgIHwgYE9rIHZfXzAxMF8gLT4gU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgX29mX2FfXzAwOV8gdl9fMDEwXyBdXG4gICAgfCBgRHVwbGljYXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkR1cGxpY2F0ZVwiXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gJ3pcbmVuZFxuXG5tb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gY29tcGFyYXRvcjooJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICd6XG5lbmRcblxubW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gKCdrZXksICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ3pcbmVuZFxuXG5tb2R1bGUgU3ltbWV0cmljX2RpZmZfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnaywgJ3YpIHQgPSAnayAqIFsgYExlZnQgb2YgJ3YgfCBgUmlnaHQgb2YgJ3YgfCBgVW5lcXVhbCBvZiAndiAqICd2IF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICAgICAnayAndi4gKCdrIC0+ICdrIC0+IGludCkgLT4gKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndikgdCAtPiAoJ2ssICd2KSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fayBfY21wX192IGFfXzAxMV8gYl9fMDEyXyAtPlxuICAgIGxldCB0X18wMTNfLCB0X18wMTRfID0gYV9fMDExXyBpblxuICAgIGxldCB0X18wMTVfLCB0X18wMTZfID0gYl9fMDEyXyBpblxuICAgIG1hdGNoIF9jbXBfX2sgdF9fMDEzXyB0X18wMTVfIHdpdGhcbiAgICB8IDAgLT5cbiAgICAgIGlmIFN0ZGxpYi4oID09ICkgdF9fMDE0XyB0X18wMTZfXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0X18wMTRfLCB0X18wMTZfIHdpdGhcbiAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDE3XywgYExlZnQgX3JpZ2h0X18wMThfIC0+IF9jbXBfX3YgX2xlZnRfXzAxN18gX3JpZ2h0X18wMThfXG4gICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wMTlfLCBgUmlnaHQgX3JpZ2h0X18wMjBfIC0+IF9jbXBfX3YgX2xlZnRfXzAxOV8gX3JpZ2h0X18wMjBfXG4gICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAyMV8sIGBVbmVxdWFsIF9yaWdodF9fMDIyXyAtPlxuICAgICAgICAgIGxldCB0X18wMjNfLCB0X18wMjRfID0gX2xlZnRfXzAyMV8gaW5cbiAgICAgICAgICBsZXQgdF9fMDI1XywgdF9fMDI2XyA9IF9yaWdodF9fMDIyXyBpblxuICAgICAgICAgIChtYXRjaCBfY21wX192IHRfXzAyM18gdF9fMDI1XyB3aXRoXG4gICAgICAgICAgIHwgMCAtPiBfY21wX192IHRfXzAyNF8gdF9fMDI2X1xuICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgfCB4LCB5IC0+IFN0ZGxpYi5jb21wYXJlIHggeSlcbiAgICB8IG4gLT4gblxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgICAgICdrICd2LlxuICAgICAgICAoJ2sgLT4gJ2sgLT4gYm9vbCkgLT4gKCd2IC0+ICd2IC0+IGJvb2wpIC0+ICgnaywgJ3YpIHQgLT4gKCdrLCAndikgdCAtPiBib29sXG4gICAgPVxuICAgIGZ1biBfY21wX19rIF9jbXBfX3YgYV9fMDI3XyBiX18wMjhfIC0+XG4gICAgbGV0IHRfXzAyOV8sIHRfXzAzMF8gPSBhX18wMjdfIGluXG4gICAgbGV0IHRfXzAzMV8sIHRfXzAzMl8gPSBiX18wMjhfIGluXG4gICAgU3RkbGliLiggJiYgKVxuICAgICAgKF9jbXBfX2sgdF9fMDI5XyB0X18wMzFfKVxuICAgICAgKGlmIFN0ZGxpYi4oID09ICkgdF9fMDMwXyB0X18wMzJfXG4gICAgICAgdGhlbiB0cnVlXG4gICAgICAgZWxzZSAoXG4gICAgICAgICBtYXRjaCB0X18wMzBfLCB0X18wMzJfIHdpdGhcbiAgICAgICAgIHwgYExlZnQgX2xlZnRfXzAzM18sIGBMZWZ0IF9yaWdodF9fMDM0XyAtPiBfY21wX192IF9sZWZ0X18wMzNfIF9yaWdodF9fMDM0X1xuICAgICAgICAgfCBgUmlnaHQgX2xlZnRfXzAzNV8sIGBSaWdodCBfcmlnaHRfXzAzNl8gLT4gX2NtcF9fdiBfbGVmdF9fMDM1XyBfcmlnaHRfXzAzNl9cbiAgICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAzN18sIGBVbmVxdWFsIF9yaWdodF9fMDM4XyAtPlxuICAgICAgICAgICBsZXQgdF9fMDM5XywgdF9fMDQwXyA9IF9sZWZ0X18wMzdfIGluXG4gICAgICAgICAgIGxldCB0X18wNDFfLCB0X18wNDJfID0gX3JpZ2h0X18wMzhfIGluXG4gICAgICAgICAgIFN0ZGxpYi4oICYmICkgKF9jbXBfX3YgdF9fMDM5XyB0X18wNDFfKSAoX2NtcF9fdiB0X18wNDBfIHRfXzA0Ml8pXG4gICAgICAgICB8IHgsIHkgLT4gU3RkbGliLiggPSApIHggeSkpXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA6XG4gICAgICAgICdrICd2LlxuICAgICAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdrKVxuICAgICAgICAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICd2KVxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgICAgLT4gKCdrLCAndikgdFxuICAgID1cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wNTdfID0gXCJtYXBfaW50Zi5tbC5TeW1tZXRyaWNfZGlmZl9lbGVtZW50LnRcIiBpblxuICAgIGZ1biBfb2Zfa19fMDQzXyBfb2Zfdl9fMDQ0XyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wNjdfOyBhcmcxX18wNjhfIF0gLT5cbiAgICAgICAgbGV0IHJlczBfXzA2OV8gPSBfb2Zfa19fMDQzXyBhcmcwX18wNjdfXG4gICAgICAgIGFuZCByZXMxX18wNzBfID1cbiAgICAgICAgICBsZXQgc2V4cF9fMDY2XyA9IGFyZzFfXzA2OF8gaW5cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIG1hdGNoIHNleHBfXzA2Nl8gd2l0aFxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gYXRvbV9fMDQ3XyBhcyBfc2V4cF9fMDQ5XyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggYXRvbV9fMDQ3XyB3aXRoXG4gICAgICAgICAgICAgICB8IFwiTGVmdFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IFwiUmlnaHRcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBcIlVuZXF1YWxcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5ub192YXJpYW50X21hdGNoICgpKVxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSBhdG9tX18wNDdfIDo6IHNleHBfYXJnc19fMDUwXykgYXNcbiAgICAgICAgICAgICAgX3NleHBfXzA0OV8gLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGF0b21fXzA0N18gd2l0aFxuICAgICAgICAgICAgICAgfCBcIkxlZnRcIiBhcyBfdGFnX18wNjNfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA2NF8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDY1XyA9IF9vZl92X18wNDRfIGFyZzBfXzA2NF8gaW5cbiAgICAgICAgICAgICAgICAgICAgYExlZnQgcmVzMF9fMDY1X1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNjNfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IFwiUmlnaHRcIiBhcyBfdGFnX18wNjBfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA2MV8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDYyXyA9IF9vZl92X18wNDRfIGFyZzBfXzA2MV8gaW5cbiAgICAgICAgICAgICAgICAgICAgYFJpZ2h0IHJlczBfXzA2Ml9cbiAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgX3RhZ19fMDYwX1xuICAgICAgICAgICAgICAgICAgICAgIF9zZXhwX18wNDlfKVxuICAgICAgICAgICAgICAgfCBcIlVuZXF1YWxcIiBhcyBfdGFnX18wNTFfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA1OF8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDU5XyA9XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggYXJnMF9fMDU4XyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wNTJfOyBhcmcxX18wNTNfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNTRfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDUyX1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHJlczFfXzA1NV8gPSBfb2Zfdl9fMDQ0XyBhcmcxX18wNTNfIGluXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMwX18wNTRfLCByZXMxX18wNTVfXG4gICAgICAgICAgICAgICAgICAgICAgfCBzZXhwX18wNTZfIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNleHBfXzA1Nl9cbiAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgYFVuZXF1YWwgcmVzMF9fMDU5X1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNTFfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX3ZhcmlhbnRfbWF0Y2ggKCkpXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDQ4XyAtPlxuICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhclxuICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgIHNleHBfXzA0OF9cbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzA0OF8gLT5cbiAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9wb2x5X3ZhclxuICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgIHNleHBfXzA0OF9cbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuTm9fdmFyaWFudF9tYXRjaCAtPlxuICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmRcbiAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgIHNleHBfXzA2Nl9cbiAgICAgICAgaW5cbiAgICAgICAgcmVzMF9fMDY5XywgcmVzMV9fMDcwX1xuICAgICAgfCBzZXhwX18wNzFfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgZXJyb3Jfc291cmNlX18wNTdfIDIgc2V4cF9fMDcxX1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICAgICAnayAndi5cbiAgICAgICAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdrLCAndikgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuIF9vZl9rX18wNzJfIF9vZl92X18wNzNfIChhcmcwX18wODFfLCBhcmcxX18wODJfKSAtPlxuICAgIGxldCByZXMwX18wODNfID0gX29mX2tfXzA3Ml8gYXJnMF9fMDgxX1xuICAgIGFuZCByZXMxX18wODRfID1cbiAgICAgIG1hdGNoIGFyZzFfXzA4Ml8gd2l0aFxuICAgICAgfCBgTGVmdCB2X18wNzRfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgX29mX3ZfXzA3M18gdl9fMDc0XyBdXG4gICAgICB8IGBSaWdodCB2X18wNzVfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IF9vZl92X18wNzNfIHZfXzA3NV8gXVxuICAgICAgfCBgVW5lcXVhbCB2X18wNzZfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5lcXVhbFwiXG4gICAgICAgICAgOyAobGV0IGFyZzBfXzA3N18sIGFyZzFfXzA3OF8gPSB2X18wNzZfIGluXG4gICAgICAgICAgICAgbGV0IHJlczBfXzA3OV8gPSBfb2Zfdl9fMDczXyBhcmcwX18wNzdfXG4gICAgICAgICAgICAgYW5kIHJlczFfXzA4MF8gPSBfb2Zfdl9fMDczXyBhcmcxX18wNzhfIGluXG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDc5XzsgcmVzMV9fMDgwXyBdKVxuICAgICAgICAgIF1cbiAgICBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzA4M187IHJlczFfXzA4NF8gXVxuICA7O1xuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICdrICd2LlxuICAgICAgICAnayBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgICAtPiAoJ2ssICd2KSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2tfc2V4cF9ncmFtbWFyIF8ndl9zZXhwX2dyYW1tYXIgLT5cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBMaXN0XG4gICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAoIF8na19zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICwgQ29uc1xuICAgICAgICAgICAgICAgICAoIFZhcmlhbnRcbiAgICAgICAgICAgICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiTGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID0gQ29ucyAoXyd2X3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJSaWdodFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID0gQ29ucyAoXyd2X3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJVbmVxdWFsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBFbXB0eSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgLCBFbXB0eSApICkpXG4gICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIE1lcmdlX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2xlZnQsICdyaWdodCkgdCA9XG4gICAgWyBgTGVmdCBvZiAnbGVmdFxuICAgIHwgYFJpZ2h0IG9mICdyaWdodFxuICAgIHwgYEJvdGggb2YgJ2xlZnQgKiAncmlnaHRcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA6XG4gICAgICAgICdsZWZ0ICdyaWdodC5cbiAgICAgICAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGludClcbiAgICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gaW50KVxuICAgICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgICAtPiBpbnRcbiAgICA9XG4gICAgZnVuIF9jbXBfX2xlZnQgX2NtcF9fcmlnaHQgYV9fMDg1XyBiX18wODZfIC0+XG4gICAgaWYgU3RkbGliLiggPT0gKSBhX18wODVfIGJfXzA4Nl9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzA4NV8sIGJfXzA4Nl8gd2l0aFxuICAgICAgfCBgTGVmdCBfbGVmdF9fMDg3XywgYExlZnQgX3JpZ2h0X18wODhfIC0+IF9jbXBfX2xlZnQgX2xlZnRfXzA4N18gX3JpZ2h0X18wODhfXG4gICAgICB8IGBSaWdodCBfbGVmdF9fMDg5XywgYFJpZ2h0IF9yaWdodF9fMDkwXyAtPiBfY21wX19yaWdodCBfbGVmdF9fMDg5XyBfcmlnaHRfXzA5MF9cbiAgICAgIHwgYEJvdGggX2xlZnRfXzA5MV8sIGBCb3RoIF9yaWdodF9fMDkyXyAtPlxuICAgICAgICBsZXQgdF9fMDkzXywgdF9fMDk0XyA9IF9sZWZ0X18wOTFfIGluXG4gICAgICAgIGxldCB0X18wOTVfLCB0X18wOTZfID0gX3JpZ2h0X18wOTJfIGluXG4gICAgICAgIChtYXRjaCBfY21wX19sZWZ0IHRfXzA5M18gdF9fMDk1XyB3aXRoXG4gICAgICAgICB8IDAgLT4gX2NtcF9fcmlnaHQgdF9fMDk0XyB0X18wOTZfXG4gICAgICAgICB8IG4gLT4gbilcbiAgICAgIHwgeCwgeSAtPiBTdGRsaWIuY29tcGFyZSB4IHkpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIDpcbiAgICAgICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICAgICAoJ2xlZnQgLT4gJ2xlZnQgLT4gYm9vbClcbiAgICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gYm9vbClcbiAgICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgICAgLT4gYm9vbFxuICAgID1cbiAgICBmdW4gX2NtcF9fbGVmdCBfY21wX19yaWdodCBhX18wOTdfIGJfXzA5OF8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzA5N18gYl9fMDk4X1xuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDk3XywgYl9fMDk4XyB3aXRoXG4gICAgICB8IGBMZWZ0IF9sZWZ0X18wOTlfLCBgTGVmdCBfcmlnaHRfXzEwMF8gLT4gX2NtcF9fbGVmdCBfbGVmdF9fMDk5XyBfcmlnaHRfXzEwMF9cbiAgICAgIHwgYFJpZ2h0IF9sZWZ0X18xMDFfLCBgUmlnaHQgX3JpZ2h0X18xMDJfIC0+IF9jbXBfX3JpZ2h0IF9sZWZ0X18xMDFfIF9yaWdodF9fMTAyX1xuICAgICAgfCBgQm90aCBfbGVmdF9fMTAzXywgYEJvdGggX3JpZ2h0X18xMDRfIC0+XG4gICAgICAgIGxldCB0X18xMDVfLCB0X18xMDZfID0gX2xlZnRfXzEwM18gaW5cbiAgICAgICAgbGV0IHRfXzEwN18sIHRfXzEwOF8gPSBfcmlnaHRfXzEwNF8gaW5cbiAgICAgICAgU3RkbGliLiggJiYgKSAoX2NtcF9fbGVmdCB0X18xMDVfIHRfXzEwN18pIChfY21wX19yaWdodCB0X18xMDZfIHRfXzEwOF8pXG4gICAgICB8IHgsIHkgLT4gU3RkbGliLiggPSApIHggeSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAgICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICAgICAoJ2xlZnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ3JpZ2h0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2ZfbGVmdF9fMTA5XyBfb2ZfcmlnaHRfXzExMF8gLT4gZnVuY3Rpb25cbiAgICB8IGBMZWZ0IHZfXzExMV8gLT5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgX29mX2xlZnRfXzEwOV8gdl9fMTExXyBdXG4gICAgfCBgUmlnaHQgdl9fMTEyXyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiUmlnaHRcIjsgX29mX3JpZ2h0X18xMTBfIHZfXzExMl8gXVxuICAgIHwgYEJvdGggdl9fMTEzXyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQm90aFwiXG4gICAgICAgIDsgKGxldCBhcmcwX18xMTRfLCBhcmcxX18xMTVfID0gdl9fMTEzXyBpblxuICAgICAgICAgICBsZXQgcmVzMF9fMTE2XyA9IF9vZl9sZWZ0X18xMDlfIGFyZzBfXzExNF9cbiAgICAgICAgICAgYW5kIHJlczFfXzExN18gPSBfb2ZfcmlnaHRfXzExMF8gYXJnMV9fMTE1XyBpblxuICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18xMTZfOyByZXMxX18xMTdfIF0pXG4gICAgICAgIF1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbigqKiBAY2Fub25pY2FsIEJhc2UuTWFwLkNvbnRpbnVlX29yX3N0b3AgKilcbm1vZHVsZSBDb250aW51ZV9vcl9zdG9wID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBDb250aW51ZVxuICAgIHwgU3RvcFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA9IChTdGRsaWIuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBDb250aW51ZTsgU3RvcCBdIDogdCBsaXN0KVxuICBsZXQgZXF1YWwgPSAoU3RkbGliLiggPSApIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgIHwgQ29udGludWUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQ29udGludWVcIlxuICAgICB8IFN0b3AgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3RvcFwiXG4gICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5NYXAuRmluaXNoZWRfb3JfdW5maW5pc2hlZCAqKVxubW9kdWxlIEZpbmlzaGVkX29yX3VuZmluaXNoZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEZpbmlzaGVkXG4gICAgfCBVbmZpbmlzaGVkXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIEZpbmlzaGVkOyBVbmZpbmlzaGVkIF0gOiB0IGxpc3QpXG4gIGxldCBlcXVhbCA9IChTdGRsaWIuKCA9ICkgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgfCBGaW5pc2hlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJGaW5pc2hlZFwiXG4gICAgIHwgVW5maW5pc2hlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmZpbmlzaGVkXCJcbiAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0cmVlXG4gIHR5cGUgJ2Ega2V5XG4gIHR5cGUgJ2NtcCBjbXBcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBhY2Nlc3Nfb3B0aW9uc1xuXG4gICgqKiBAaW5saW5lICopXG4gIGluY2x1ZGVcbiAgICBEaWN0aW9uYXJ5X2ltbXV0YWJsZS5BY2Nlc3NvcnNcbiAgICAgIHdpdGggdHlwZSAna2V5IGtleSA6PSAna2V5IGtleVxuICAgICAgIGFuZCB0eXBlICgna2V5LCAnZGF0YSwgJ2NtcCkgdCA6PSAoJ2tleSwgJ2RhdGEsICdjbXApIHRcbiAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCBfLCAnY21wKSBhY2Nlc3NvciA6PSAoJ2tleSwgJ2NtcCwgJ2ZuKSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2wpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuXG4gIHZhbCBhZGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGFkZF9leG5cbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHNldFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYWRkX211bHRpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgcmVtb3ZlX211bHRpXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBmaW5kX211bHRpIDogKCdrLCAnY21wLCAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2IGxpc3QpIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGNoYW5nZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+IGY6KCd2IG9wdGlvbiAtPiAndiBvcHRpb24pIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgdXBkYXRlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZpbmQgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2IG9wdGlvbikgYWNjZXNzX29wdGlvbnNcbiAgdmFsIGZpbmRfZXhuIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAndikgYWNjZXNzX29wdGlvbnNcbiAgdmFsIHJlbW92ZSA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcbiAgdmFsIG1lbSA6ICgnaywgJ2NtcCwgKCdrLCBfLCAnY21wKSB0IC0+ICdrIGtleSAtPiBib29sKSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgaXRlcl9rZXlzIDogKCdrLCBfLCBfKSB0IC0+IGY6KCdrIGtleSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICd2LCBfKSB0IC0+IGY6KCd2IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgICAgICAtPiB1bml0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG1hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gIHZhbCBtYXBpIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgdmFsIGZvbGRcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiAnYWNjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gKCdhY2MsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0XG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgLT4gJ2FjY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAgIC0+IGluaXQ6J2FjY1xuICAgICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2FjYyAtPiAnYWNjKVxuICAgICAgICAtPiAnYWNjIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZpbHRlcl9rZXlzIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOignayBrZXkgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOigndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOigndjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgY29tYmluZV9lcnJvcnNcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2IE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHVuemlwIDogKCdrLCAndjEgKiAndjIsICdjbXApIHQgLT4gKCdrLCAndjEsICdjbXApIHQgKiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gIHZhbCBjb21wYXJlX2RpcmVjdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgndiAtPiAndiAtPiBpbnQpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgZXF1YWxcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2wgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwga2V5cyA6ICgnaywgXywgXykgdCAtPiAnayBrZXkgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sga2V5ICogJ3YpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgICAgICAtPiBmOihrZXk6J2sga2V5IC0+ICgndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICd2MyBvcHRpb24pXG4gICAgICAgIC0+ICgnaywgJ3YzLCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG1lcmdlX2Rpc2pvaW50X2V4blxuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IGNvbWJpbmU6KGtleTonayBrZXkgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAgICAgLT4gKCdrIGtleSwgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAgIC0+IGY6KCdhY2MgLT4gKCdrIGtleSwgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYWNjKVxuICAgICAgICAtPiAnYWNjIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG1pbl9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIG1heF9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIGZvcl9hbGwgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHN1bVxuICAgIDogIChtb2R1bGUgQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KCd2IC0+ICdhKVxuICAgIC0+ICdhXG5cbiAgdmFsIHN1bWlcbiAgICA6ICAobW9kdWxlIENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdhKVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICB2YWwgc3BsaXRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+ICdrIGtleVxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrIGtleSAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHNwbGl0X2xlX2d0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc3BsaXRfbHRfZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBsb3dlcl9ib3VuZDonayBrZXkgTWF5YmVfYm91bmQudFxuICAgICAgICAtPiB1cHBlcl9ib3VuZDonayBrZXkgTWF5YmVfYm91bmQudFxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBtaW46J2sga2V5XG4gICAgICAgIC0+IG1heDonayBrZXlcbiAgICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgICAgIC0+ICdhY2MgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgcmFuZ2VfdG9fYWxpc3RcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IG1pbjonayBrZXkgLT4gbWF4OidrIGtleSAtPiAoJ2sga2V5ICogJ3YpIGxpc3QgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAgICAgLT4gJ2sga2V5XG4gICAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG50aCA6ICgnaywgJ3YsICdjbXApIHQgLT4gaW50IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIHJhbmsgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCAtPiAnayBrZXkgLT4gaW50IG9wdGlvbikgYWNjZXNzX29wdGlvbnNcbiAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnayBrZXksICd2LCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAgICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonayBrZXlcbiAgICAgICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzonayBrZXlcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gY29tcGFyZTooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAgICAgLT4gJ2tleVxuICAgICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gc2VnbWVudF9vZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBjb21wYXJlOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAgICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAgICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIG1vZHVsZSBNYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMgKEEgOiBBcHBsaWNhdGl2ZS5MYXp5X2FwcGxpY2F0aXZlKSA6IHNpZ1xuICAgIHZhbCBtYXBpXG4gICAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIgQS50KVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgQS50XG5cbiAgICB2YWwgZmlsdGVyX21hcGlcbiAgICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24gQS50KVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgQS50XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2ssICd2LCAnY21wKSB0XG4gIHR5cGUgKCdrLCAndiwgJ2NtcCkgdHJlZVxuICB0eXBlICdrIGtleVxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIGNyZWF0ZV9vcHRpb25zXG4gIHR5cGUgKCdhLCAnY21wLCAneikgYWNjZXNzX29wdGlvbnNcbiAgdHlwZSAnY21wIGNtcFxuXG4gICgqKiBAaW5saW5lICopXG4gIGluY2x1ZGVcbiAgICBEaWN0aW9uYXJ5X2ltbXV0YWJsZS5DcmVhdG9yc1xuICAgICAgd2l0aCB0eXBlICdrZXkga2V5IDo9ICdrZXkga2V5XG4gICAgICAgYW5kIHR5cGUgKCdrZXksICdkYXRhLCAnY21wKSB0IDo9ICgna2V5LCAnZGF0YSwgJ2NtcCkgdFxuICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksIF8sICdjbXApIGNyZWF0b3IgOj0gKCdrZXksICdjbXAsICdmbikgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgZW1wdHkgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcbiAgdmFsIHNpbmdsZXRvbiA6ICgnaywgJ2NtcCwgJ2sga2V5IC0+ICd2IC0+ICgnaywgJ3YsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG1hcF9rZXlzXG4gICAgOiAoICdrMlxuICAgICAgLCAnY21wMlxuICAgICAgLCAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAgICAgLT4gZjooJ2sxIGtleSAtPiAnazIga2V5KVxuICAgICAgICAtPiBbIGBPayBvZiAoJ2syLCAndiwgJ2NtcDIpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnazIga2V5IF0gKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAoICdrMlxuICAgICAgLCAnY21wMlxuICAgICAgLCAoJ2sxLCAndiwgJ2NtcDEpIHQgLT4gZjooJ2sxIGtleSAtPiAnazIga2V5KSAtPiAoJ2syLCAndiwgJ2NtcDIpIHQgKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgdHJhbnNwb3NlX2tleXNcbiAgICA6ICggJ2sxXG4gICAgICAsICdjbXAxXG4gICAgICAsICggJ2syXG4gICAgICAgICwgJ2NtcDJcbiAgICAgICAgLCAoJ2sxLCAoJ2syLCAnYSwgJ2NtcDIpIHQsICdjbXAxKSB0IC0+ICgnazIsICgnazEsICdhLCAnY21wMSkgdCwgJ2NtcDIpIHQgKVxuICAgICAgICBjcmVhdGVfb3B0aW9ucyApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBhcnJheSAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBhcnJheSAtPiAoJ2ssICd2LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogKCdrLCAnY21wLCBsZW46aW50IC0+IGY6KGludCAtPiAnayBrZXkgKiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YxKSBsaXN0IC0+IGluaXQ6J3YyIC0+IGY6KCd2MiAtPiAndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gZjooJ3YgLT4gJ3YgLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sga2V5IF1cbiAgICAgIClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX2V4blxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGlcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndjEpIFNlcXVlbmNlLnRcbiAgICAgICAgLT4gaW5pdDondjJcbiAgICAgICAgLT4gZjooJ3YyIC0+ICd2MSAtPiAndjIpXG4gICAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0IClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiBmOigndiAtPiAndiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgJ3YgbGlzdFxuICAgICAgICAtPiBnZXRfa2V5OigndiAtPiAnayBrZXkpXG4gICAgICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXSApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgJ3YgbGlzdCAtPiBnZXRfa2V5OigndiAtPiAnayBrZXkpIC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X2V4blxuICAgIDogKCdrLCAnY21wLCAndiBsaXN0IC0+IGdldF9rZXk6KCd2IC0+ICdrIGtleSkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9tdWx0aVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICd2IGxpc3QgLT4gZ2V0X2tleTooJ3YgLT4gJ2sga2V5KSAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQgKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9mb2xkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgJ3YgbGlzdFxuICAgICAgICAtPiBnZXRfa2V5OigndiAtPiAnayBrZXkpXG4gICAgICAgIC0+IGluaXQ6J2FjY1xuICAgICAgICAtPiBmOignYWNjIC0+ICd2IC0+ICdhY2MpXG4gICAgICAgIC0+ICgnaywgJ2FjYywgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICd2IGxpc3QgLT4gZ2V0X2tleTooJ3YgLT4gJ2sga2V5KSAtPiBmOigndiAtPiAndiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGl0ZXJpOihmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAgICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2l0ZXJpX2V4blxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGl0ZXJpOihmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdCkgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl90cmVlIDogKCdrLCAnY21wLCAoJ2sga2V5LCAndiwgJ2NtcCkgdHJlZSAtPiAoJ2ssICd2LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWVcbiAgdHlwZSAnYSBrZXlcbiAgdHlwZSAnYSBjbXBcbiAgdHlwZSAoJ2EsICdiLCAnYykgY3JlYXRlX29wdGlvbnNcbiAgdHlwZSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnNcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRyZWVcbiAgICAgIHdpdGggdHlwZSAnYSBrZXkgOj0gJ2Ega2V5XG4gICAgICB3aXRoIHR5cGUgJ2EgY21wIDo9ICdhIGNtcFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgY3JlYXRlX29wdGlvbnNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIGFjY2Vzc19vcHRpb25zXG5cbiAgaW5jbHVkZVxuICAgIEFjY2Vzc29yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdHJlZVxuICAgICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbiAgICAgIHdpdGggdHlwZSAnYSBjbXAgOj0gJ2EgY21wXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGFjY2Vzc19vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoJ2EsICdiKSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG4gICAgICB3aXRoIHR5cGUgJ2sga2V5IDo9ICdrXG4gICAgICB3aXRoIHR5cGUgJ2MgY21wIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aG91dF9jb21wYXJhdG9yLnRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIFdpdGhvdXRfY29tcGFyYXRvci50XG5lbmRcblxubW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICBtb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICAgIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG4gIHZhbCBzZXhwX29mX21fX3RcbiAgICA6ICAobW9kdWxlIFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICgndiAtPiBTZXhwLnQpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IFNleHAudFxuXG4gIHZhbCBtX190X29mX3NleHBcbiAgICA6ICAobW9kdWxlIE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9ICdrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG4gICAgLT4gKFNleHAudCAtPiAndilcbiAgICAtPiBTZXhwLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgOiAgKG1vZHVsZSBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIHZhbCBjb21wYXJlX21fX3RcbiAgICA6ICAobW9kdWxlIENvbXBhcmVfbSlcbiAgICAtPiAoJ3YgLT4gJ3YgLT4gaW50KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gaW50XG5cbiAgdmFsIGVxdWFsX21fX3RcbiAgICA6ICAobW9kdWxlIEVxdWFsX20pXG4gICAgLT4gKCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdmFsIGhhc2hfZm9sZF9tX190XG4gICAgOiAgKG1vZHVsZSBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+IChIYXNoLnN0YXRlIC0+ICd2IC0+IEhhc2guc3RhdGUpXG4gICAgLT4gSGFzaC5zdGF0ZVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiBIYXNoLnN0YXRlXG5lbmRcblxubW9kdWxlIHR5cGUgTWFwID0gc2lnXG4gICgqKiBbTWFwXSBpcyBhIGZ1bmN0aW9uYWwgZGF0YSBzdHJ1Y3R1cmUgKGJhbGFuY2VkIGJpbmFyeSB0cmVlKSBpbXBsZW1lbnRpbmcgZmluaXRlIG1hcHNcbiAgICAgIG92ZXIgYSB0b3RhbGx5LW9yZGVyZWQgZG9tYWluLCBjYWxsZWQgYSBcImtleVwiLiAqKVxuXG4gIHR5cGUgKCEna2V5LCArISd2YWx1ZSwgISdjbXApIHRcblxuICBtb2R1bGUgT3JfZHVwbGljYXRlID0gT3JfZHVwbGljYXRlXG4gIG1vZHVsZSBDb250aW51ZV9vcl9zdG9wID0gQ29udGludWVfb3Jfc3RvcFxuXG4gIG1vZHVsZSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkIDogc2lnXG4gICAgdHlwZSB0ID0gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50ID1cbiAgICAgIHwgRmluaXNoZWRcbiAgICAgIHwgVW5maW5pc2hlZFxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGVxdWFsLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBpbmNsdWRlIFBweF9lbnVtZXJhdGVfbGliLkVudW1lcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICAoKiogTWFwcyBbQ29udGludWVdIHRvIFtGaW5pc2hlZF0gYW5kIFtTdG9wXSB0byBbVW5maW5pc2hlZF0uICopXG4gICAgdmFsIG9mX2NvbnRpbnVlX29yX3N0b3AgOiBDb250aW51ZV9vcl9zdG9wLnQgLT4gdFxuXG4gICAgKCoqIE1hcHMgW0ZpbmlzaGVkXSB0byBbQ29udGludWVdIGFuZCBbVW5maW5pc2hlZF0gdG8gW1N0b3BdLiAqKVxuICAgIHZhbCB0b19jb250aW51ZV9vcl9zdG9wIDogdCAtPiBDb250aW51ZV9vcl9zdG9wLnRcbiAgZW5kXG5cbiAgbW9kdWxlIE1lcmdlX2VsZW1lbnQgOiBzaWdcbiAgICB0eXBlICgnbGVmdCwgJ3JpZ2h0KSB0ID1cbiAgICAgIFsgYExlZnQgb2YgJ2xlZnRcbiAgICAgIHwgYFJpZ2h0IG9mICdyaWdodFxuICAgICAgfCBgQm90aCBvZiAnbGVmdCAqICdyaWdodFxuICAgICAgXVxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICAgIHZhbCBjb21wYXJlXG4gICAgICA6ICAoJ2xlZnQgLT4gJ2xlZnQgLT4gaW50KVxuICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gaW50KVxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBpbnRcblxuICAgIHZhbCBlcXVhbFxuICAgICAgOiAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGJvb2wpXG4gICAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBib29sKVxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBib29sXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2xlZnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdyaWdodCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIGxlZnQgOiAoJ2xlZnQsIF8pIHQgLT4gJ2xlZnQgb3B0aW9uXG4gICAgdmFsIHJpZ2h0IDogKF8sICdyaWdodCkgdCAtPiAncmlnaHQgb3B0aW9uXG4gICAgdmFsIGxlZnRfdmFsdWUgOiAoJ2xlZnQsIF8pIHQgLT4gZGVmYXVsdDonbGVmdCAtPiAnbGVmdFxuICAgIHZhbCByaWdodF92YWx1ZSA6IChfLCAncmlnaHQpIHQgLT4gZGVmYXVsdDoncmlnaHQgLT4gJ3JpZ2h0XG5cbiAgICB2YWwgdmFsdWVzXG4gICAgICA6ICAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gbGVmdF9kZWZhdWx0OidsZWZ0XG4gICAgICAtPiByaWdodF9kZWZhdWx0OidyaWdodFxuICAgICAgLT4gJ2xlZnQgKiAncmlnaHRcbiAgZW5kXG5cbiAgKCoqIFRlc3QgaWYgdGhlIGludmFyaWFudHMgb2YgdGhlIGludGVybmFsIEFWTCBzZWFyY2ggdHJlZSBob2xkLiAqKVxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGZpcnN0LWNsYXNzIG1vZHVsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIG90aGVyIG1hcC9zZXQvZXRjLlxuICAgICAgd2l0aCB0aGUgc2FtZSBub3Rpb24gb2YgY29tcGFyaXNvbi4gKilcbiAgdmFsIGNvbXBhcmF0b3JfcyA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuXG4gICgqKiBUaGUgZW1wdHkgbWFwLiAqKVxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBBIG1hcCB3aXRoIG9uZSAoa2V5LCBkYXRhKSBwYWlyLiAqKVxuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIC0+ICdiIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCB1bmlxdWUga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByZXR1cm5pbmcgYW4gZXJyb3IgaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHBvc3NpYmx5IHJlcGVhdGVkIGtleXMuIFRoZSB2YWx1ZXMgaW5cbiAgICAgIHRoZSBtYXAgZm9yIGEgZ2l2ZW4ga2V5IGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IGRpZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgIGxpc3QuICopXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIGxpc3QgaW50byBhIG1hcCwgZm9sZGluZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuIFRoZSBhY2N1bXVsYXRvciBpcyBwZXIta2V5LlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICAjIChsZXQgbWFwID1cbiAgICAgICAgICAgICBTdHJpbmcuTWFwLm9mX2FsaXN0X2ZvbGRcbiAgICAgICAgICAgICAgIFsgXCJhXCIsIDE7IFwiYVwiLCAxMDsgXCJiXCIsIDI7IFwiYlwiLCAyMDsgXCJiXCIsIDIwMCBdXG4gICAgICAgICAgICAgICB+aW5pdDpJbnQuU2V0LmVtcHR5XG4gICAgICAgICAgICAgICB+ZjpTZXQuYWRkXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIHByaW50X3MgWyVzZXhwIChtYXAgOiBJbnQuU2V0LnQgU3RyaW5nLk1hcC50KV0pOztcbiAgICAgICAgKChhICgxIDEwKSkgKGIgKDIgMjAgMjAwKSkpXG4gICAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIF19XG4gICopXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBsaXN0IGludG8gYSBtYXAsIHJlZHVjaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0X3JlZHVjZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaXRlcmkgfml0ZXJpXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0XSwgZXhjZXB0IHRoYXQgaW5zdGVhZCBvZiB0YWtpbmcgYSBjb25jcmV0ZVxuICAgICAgZGF0YSBzdHJ1Y3R1cmUsIGl0IHRha2VzIGFuIGl0ZXJhdGlvbiBmdW5jdGlvbi4gIEZvciBpbnN0YW5jZSwgdG8gY29udmVydCBhIHN0cmluZyB0YWJsZVxuICAgICAgaW50byBhIG1hcDogW29mX2l0ZXJpIChtb2R1bGUgU3RyaW5nKSB+ZjooSGFzaHRibC5pdGVyaSB0YWJsZSldLiAgSXQgaXMgZmFzdGVyIHRoYW5cbiAgICAgIGFkZGluZyB0aGUgZWxlbWVudHMgb25lIGJ5IG9uZS4gKilcbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICAoKiogTGlrZSBbb2ZfaXRlcmldIGV4Y2VwdCB0aGF0IGl0IHJhaXNlcyBhbiBleGNlcHRpb24gaWYgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9pdGVyaV9leG5cbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhIHNvcnRlZCBhcnJheSBvZiBrZXktZGF0YSBwYWlycy4gVGhlIGlucHV0IGFycmF5IG11c3QgYmUgc29ydGVkXG4gICAgICAoZWl0aGVyIGluIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyKSwgYXMgZ2l2ZW4gYnkgdGhlIHJlbGV2YW50IGNvbXBhcmF0b3IsIGFuZFxuICAgICAgbXVzdCBub3QgY29udGFpbiBkdXBsaWNhdGUga2V5cy4gSWYgZWl0aGVyIG9mIHRoZXNlIGNvbmRpdGlvbnMgZG9lcyBub3QgaG9sZCxcbiAgICAgIGFuIGVycm9yIGlzIHJldHVybmVkLiAgKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBhcnJheVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBMaWtlIFtvZl9zb3J0ZWRfYXJyYXldIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgYSBtYXAgd2l0aCBicm9rZW4gaW52YXJpYW50cyB3aGVuIGFuXG4gICAgICBbRXJyb3JdIHdvdWxkIGhhdmUgYmVlbiByZXR1cm5lZC4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBjIH5sZW4gfmZdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBjXG4gICAgICAoQXJyYXkuaW5pdCBsZW4gfmYpXSwgd2l0aCB0aGUgYWRkaXRpb25hbCByZXN0cmljdGlvbiB0aGF0IGEgZGVjcmVhc2luZyBvcmRlciBpcyBub3RcbiAgICAgIHN1cHBvcnRlZC4gIFRoZSBhZHZhbnRhZ2UgaXMgbm90IHJlcXVpcmluZyB5b3UgdG8gYWxsb2NhdGUgYW4gaW50ZXJtZWRpYXRlIGFycmF5LiAgW2ZdXG4gICAgICB3aWxsIGJlIGNhbGxlZCB3aXRoIDAsIDEsIC4uLiBbbGVuIC0gMV0sIGluIG9yZGVyLiAqKVxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhICogJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9zb3J0ZWRfYXJyYXkgYyAoU2VxdWVuY2UudG9fYXJyYXlcbiAgICAgIHNlcSldLCBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBhcnJheS5cblxuICAgICAgVGhlIHNlcXVlbmNlIHdpbGwgYmUgZm9sZGVkIG92ZXIgb25jZSwgYW5kIHRoZSBhZGRpdGlvbmFsIHRpbWUgY29tcGxleGl0eSBpcyB7ZSBPKG4pfS5cbiAgKilcbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2VcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sgKiAndikgU2VxdWVuY2UudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0IGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG5cbiAgICAgIElmIHlvdXIgc2VxdWVuY2UgaXMgaW5jcmVhc2luZywgdXNlIFtvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXS5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cywgcmV0dXJuaW5nIGFuIGVycm9yIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC5cblxuICAgICAgW29mX3NlcXVlbmNlX29yX2Vycm9yIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X29yX2Vycm9yIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV1cbiAgICAgIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvclxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9leG4gYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZXhuIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG5cbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggcG9zc2libHkgcmVwZWF0ZWQga2V5cy4gVGhlIHZhbHVlcyBpblxuICAgICAgdGhlIG1hcCBmb3IgYSBnaXZlbiBrZXkgYXBwZWFyIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgZGlkIGluIHRoZSBhc3NvY2lhdGlvblxuICAgICAgbGlzdC5cblxuICAgICAgW29mX3NlcXVlbmNlX211bHRpIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2V4biBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSBpbnRvIGEgbWFwLCBmb2xkaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlX2ZvbGQgYyBzZXEgfmluaXQgfmZdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZm9sZCBjIChTZXF1ZW5jZS50b19saXN0IHNlcSkgfmluaXQgfmZdXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gc2VxdWVuY2UgaW50byBhIG1hcCwgcmVkdWNpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfcmVkdWNlIGMgc2VxIH5mXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X3JlZHVjZSBjIChTZXF1ZW5jZS50b19saXN0IHNlcSkgfmZdXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDb25zdHJ1Y3RzIGEgbWFwIGZyb20gYSBsaXN0IG9mIHZhbHVlcywgd2hlcmUgW2dldF9rZXldIGV4dHJhY3RzIGEga2V5IGZyb20gYSB2YWx1ZS5cbiAgKilcbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBsaXN0XG4gICAgLT4gZ2V0X2tleTooJ3YgLT4gJ2spXG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIF1cblxuICAoKiogTGlrZSBbb2ZfbGlzdF93aXRoX2tleV07IHJldHVybnMgW0Vycm9yXSBvbiBkdXBsaWNhdGUga2V5LiAqKVxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvclxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICd2IGxpc3RcbiAgICAtPiBnZXRfa2V5OigndiAtPiAnaylcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogTGlrZSBbb2ZfbGlzdF93aXRoX2tleV07IHJhaXNlcyBvbiBkdXBsaWNhdGUga2V5LiAqKVxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9leG5cbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBsaXN0XG4gICAgLT4gZ2V0X2tleTooJ3YgLT4gJ2spXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtvZl9saXN0X3dpdGhfa2V5XTsgcHJvZHVjZXMgbGlzdHMgb2YgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZWFjaCBrZXkuICopXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X211bHRpXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ3YgbGlzdFxuICAgIC0+IGdldF9rZXk6KCd2IC0+ICdrKVxuICAgIC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtvZl9saXN0X3dpdGhfa2V5XTsgcmVzb2x2ZXMgZHVwbGljYXRlIGtleXMgdGhlIHNhbWUgd2F5IFtvZl9hbGlzdF9mb2xkXSBkb2VzLiAqKVxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9mb2xkXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ3YgbGlzdFxuICAgIC0+IGdldF9rZXk6KCd2IC0+ICdrKVxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gJ3YgLT4gJ2FjYylcbiAgICAtPiAoJ2ssICdhY2MsICdjbXApIHRcblxuICAoKiogTGlrZSBbb2ZfbGlzdF93aXRoX2tleV07IHJlc29sdmVzIGR1cGxpY2F0ZSBrZXlzIHRoZSBzYW1lIHdheSBbb2ZfYWxpc3RfcmVkdWNlXSBkb2VzLiAqKVxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9yZWR1Y2VcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBsaXN0XG4gICAgLT4gZ2V0X2tleTooJ3YgLT4gJ2spXG4gICAgLT4gZjooJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBUZXN0cyB3aGV0aGVyIGEgbWFwIGlzIGVtcHR5LiAqKVxuICB2YWwgaXNfZW1wdHkgOiAoXywgXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFtsZW5ndGggbWFwXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gW21hcF0uICBPKDEpLCBidXQgW1RyZWUubGVuZ3RoXSBpc1xuICAgICAgTyhuKS4gKilcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIHRoZSBzcGVjaWZpZWQgbmV3IGJpbmRpbmc7IGlmIHRoZSBrZXkgd2FzIGFscmVhZHkgYm91bmQsIGl0c1xuICAgICAgcHJldmlvdXMgYmluZGluZyBkaXNhcHBlYXJzLiAqKVxuICB2YWwgc2V0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFthZGQgdCB+a2V5IH5kYXRhXSBhZGRzIGEgbmV3IGVudHJ5IHRvIFt0XSBtYXBwaW5nIFtrZXldIHRvIFtkYXRhXSBhbmQgcmV0dXJucyBbYE9rXVxuICAgICAgd2l0aCB0aGUgbmV3IG1hcCwgb3IgaWYgW2tleV0gaXMgYWxyZWFkeSBwcmVzZW50IGluIFt0XSwgcmV0dXJucyBbYER1cGxpY2F0ZV0uICopXG4gIHZhbCBhZGQgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZHVwbGljYXRlLnRcblxuICB2YWwgYWRkX2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBJZiBba2V5XSBpcyBub3QgcHJlc2VudCB0aGVuIGFkZCBhIHNpbmdsZXRvbiBsaXN0LCBvdGhlcndpc2UsIGNvbnMgZGF0YSBvbnRvIHRoZVxuICAgICAgaGVhZCBvZiB0aGUgZXhpc3RpbmcgbGlzdC4gKilcbiAgdmFsIGFkZF9tdWx0aSA6ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHRcblxuICAoKiogSWYgdGhlIGtleSBpcyBwcmVzZW50LCB0aGVuIHJlbW92ZSBpdHMgaGVhZCBlbGVtZW50OyBpZiB0aGUgcmVzdWx0IGlzIGVtcHR5LCByZW1vdmVcbiAgICAgIHRoZSBrZXkuICopXG4gIHZhbCByZW1vdmVfbXVsdGkgOiAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgdGhlIHZhbHVlIGJvdW5kIHRvIHRoZSBnaXZlbiBrZXksIG9yIHRoZSBlbXB0eSBsaXN0IGlmIHRoZXJlIGlzIG5vbmUuICopXG4gIHZhbCBmaW5kX211bHRpIDogKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIC0+ICd2IGxpc3RcblxuICAoKiogW2NoYW5nZSB0IGtleSB+Zl0gcmV0dXJucyBhIG5ldyBtYXAgW21dIHRoYXQgaXMgdGhlIHNhbWUgYXMgW3RdIG9uIGFsbCBrZXlzIGV4Y2VwdFxuICAgICAgZm9yIFtrZXldLCBhbmQgd2hvc2UgdmFsdWUgZm9yIFtrZXldIGlzIGRlZmluZWQgYnkgW2ZdLCBpLmUuLCBbZmluZCBtIGtleSA9IGYgKGZpbmRcbiAgICAgIHQga2V5KV0uICopXG4gIHZhbCBjaGFuZ2UgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+IGY6KCd2IG9wdGlvbiAtPiAndiBvcHRpb24pIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW3VwZGF0ZSB0IGtleSB+Zl0gaXMgW2NoYW5nZSB0IGtleSB+ZjooZnVuIG8gLT4gU29tZSAoZiBvKSldLiAqKVxuICB2YWwgdXBkYXRlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiBmOigndiBvcHRpb24gLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogUmV0dXJucyBbU29tZSB2YWx1ZV0gYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgb3IgW05vbmVdIGlmIG5vbmUgZXhpc3RzLiAqKVxuICB2YWwgZmluZCA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gJ3Ygb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIHZhbHVlIGJvdW5kIHRvIHRoZSBnaXZlbiBrZXksIHJhaXNpbmcgW1N0ZGxpYi5Ob3RfZm91bmRdIG9yIFtOb3RfZm91bmRfc11cbiAgICAgIGlmIG5vbmUgZXhpc3RzLiAqKVxuICB2YWwgZmluZF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+ICd2XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggYW55IGJpbmRpbmcgZm9yIHRoZSBrZXkgaW4gcXVlc3Rpb24gcmVtb3ZlZC4gKilcbiAgdmFsIHJlbW92ZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbbWVtIG1hcCBrZXldIHRlc3RzIHdoZXRoZXIgW21hcF0gY29udGFpbnMgYSBiaW5kaW5nIGZvciBba2V5XS4gKilcbiAgdmFsIG1lbSA6ICgnaywgXywgJ2NtcCkgdCAtPiAnayAtPiBib29sXG5cbiAgdmFsIGl0ZXJfa2V5cyA6ICgnaywgXywgXykgdCAtPiBmOignayAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICd2LCBfKSB0IC0+IGY6KCd2IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIEl0ZXJhdGVzIHVudGlsIHRoZSBmaXJzdCB0aW1lIFtmXSByZXR1cm5zIFtTdG9wXS4gSWYgW2ZdIHJldHVybnMgW1N0b3BdLCB0aGUgZmluYWxcbiAgICAgIHJlc3VsdCBpcyBbVW5maW5pc2hlZF0uIE90aGVyd2lzZSwgdGhlIGZpbmFsIHJlc3VsdCBpcyBbRmluaXNoZWRdLiAqKVxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gICgqKiBJdGVyYXRlcyB0d28gbWFwcyBzaWRlIGJ5IHNpZGUuIFRoZSBjb21wbGV4aXR5IG9mIHRoaXMgZnVuY3Rpb24gaXMgTyhNICsgTikuICBJZiB0d29cbiAgICAgIGlucHV0cyBhcmUgW1soMCwgYSk7ICgxLCBhKV1dIGFuZCBbWygxLCBiKTsgKDIsIGIpXV0sIFtmXSB3aWxsIGJlIGNhbGxlZCB3aXRoIFtbKDAsXG4gICAgICBgTGVmdCBhKTsgKDEsIGBCb3RoIChhLCBiKSk7ICgyLCBgUmlnaHQgYildXS4gKilcbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGJvdW5kIHZhbHVlcyByZXBsYWNlZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmQgdmFsdWVzLiopXG4gIHZhbCBtYXAgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFttYXBdLCBidXQgdGhlIHBhc3NlZCBmdW5jdGlvbiB0YWtlcyBib3RoIFtrZXldIGFuZCBbZGF0YV0gYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgbWFwaSA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIENvbnZlcnQgbWFwIHdpdGgga2V5cyBvZiB0eXBlIFsnazJdIHRvIGEgbWFwIHdpdGgga2V5cyBvZiB0eXBlIFsnazJdIHVzaW5nIFtmXS4gKilcbiAgdmFsIG1hcF9rZXlzXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+IFsgYE9rIG9mICgnazIsICd2LCAnY21wMikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBdXG5cbiAgKCoqIExpa2UgW21hcF9rZXlzXSwgYnV0IHJhaXNlcyBvbiBkdXBsaWNhdGUga2V5LiAqKVxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+ICgnazIsICd2LCAnY21wMikgdFxuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLiAqKVxuICB2YWwgZm9sZCA6ICgnaywgJ3YsIF8pIHQgLT4gaW5pdDonYWNjIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLCB1bnRpbCB0aGUgZmlyc3RcbiAgICAgIHRpbWUgdGhhdCBbZl0gcmV0dXJucyBbU3RvcCBfXS4gSWYgW2ZdIHJldHVybnMgW1N0b3AgZmluYWxdLCB0aGlzIGZ1bmN0aW9uIHJldHVybnNcbiAgICAgIGltbWVkaWF0ZWx5IHdpdGggdGhlIHZhbHVlIFtmaW5hbF0uIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCBhbmQgdGhlIGZpbmFsXG4gICAgICBjYWxsIHRvIFtmXSByZXR1cm5zIFtDb250aW51ZSBsYXN0XSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIFtmaW5pc2ggbGFzdF0uICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gKCdhY2MsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBkZWNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLiAqKVxuICB2YWwgZm9sZF9yaWdodFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgLT4gJ2FjY1xuXG4gICgqKiBGb2xkcyBvdmVyIHR3byBtYXBzIHNpZGUgYnkgc2lkZSwgbGlrZSBbaXRlcjJdLiAqKVxuICB2YWwgZm9sZDJcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ICdhY2NcblxuICAoKiogW2ZpbHRlcl0sIFtmaWx0ZXJpXSwgW2ZpbHRlcl9rZXlzXSwgW2ZpbHRlcl9tYXBdLCBhbmQgW2ZpbHRlcl9tYXBpXSBydW4gaW4gTyhuKVxuICAgICAgdGltZS5cblxuICAgICAgW2ZpbHRlcl0sIFtmaWx0ZXJpXSwgW2ZpbHRlcl9rZXlzXSwgW3BhcnRpdGlvbl90Zl0gYW5kIFtwYXJ0aXRpb25pX3RmXSBrZWVwIGEgbG90XG4gICAgICBvZiBzaGFyaW5nIGJldHdlZW4gdGhlaXIgcmVzdWx0IGFuZCB0aGUgb3JpZ2luYWwgbWFwLiAgRHJvcHBpbmcgb3Iga2VlcGluZyBhIHJ1biBvZlxuICAgICAgW2tdIGNvbnNlY3V0aXZlIGVsZW1lbnRzIGNvc3RzIFtPKGxvZyhrKSldIGV4dHJhIG1lbW9yeS4gS2VlcGluZyB0aGUgZW50aXJlIG1hcFxuICAgICAgY29zdHMgbm8gZXh0cmEgbWVtb3J5IGF0IGFsbDogW2ZpbHRlciB+ZjooZnVuIF8gLT4gdHJ1ZSldIHJldHVybnMgdGhlIG9yaWdpbmFsIG1hcC5cbiAgKilcbiAgdmFsIGZpbHRlcl9rZXlzIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOignayAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlciA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyaSA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGJvdW5kIHZhbHVlcyBmaWx0ZXJlZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmQgdmFsdWVzLiAqKVxuICB2YWwgZmlsdGVyX21hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtmaWx0ZXJfbWFwXSwgYnV0IHRoZSBwYXNzZWQgZnVuY3Rpb24gdGFrZXMgYm90aCBba2V5XSBhbmQgW2RhdGFdIGFzXG4gICAgICBhcmd1bWVudHMuICopXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24pXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXBpIHQgfmZdIHJldHVybnMgdHdvIG5ldyBbdF1zLCB3aXRoIGVhY2gga2V5IGluIFt0XSBhcHBlYXJpbmcgaW5cbiAgICAgIGV4YWN0bHkgb25lIG9mIHRoZSByZXN1bHRpbmcgbWFwcyBkZXBlbmRpbmcgb24gaXRzIG1hcHBpbmcgaW4gW2ZdLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXAgdCB+ZiA9IHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKV0gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKipcbiAgICAge1tcbiAgICAgICBwYXJ0aXRpb25pX3RmIHQgfmZcbiAgICAgICA9XG4gICAgICAgcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgIGlmIGYgfmtleSB+ZGF0YVxuICAgICAgICAgdGhlbiBGaXJzdCBkYXRhXG4gICAgICAgICBlbHNlIFNlY29uZCBkYXRhKVxuICAgICBdfSAqKVxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXSAqKVxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogUHJvZHVjZXMgW09rXSBvZiBhIG1hcCBpbmNsdWRpbmcgYWxsIGtleXMgaWYgYWxsIGRhdGEgaXMgW09rXSwgb3IgYW4gW0Vycm9yXVxuICAgICAgaW5jbHVkaW5nIGFsbCBlcnJvcnMgb3RoZXJ3aXNlLiAqKVxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAoJ2ssICd2IE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIEdpdmVuIGEgbWFwIG9mIHR1cGxlcywgcHJvZHVjZXMgYSB0dXBsZSBvZiBtYXBzLiBFcXVpdmFsZW50IHRvOlxuICAgICAgW21hcCB0IH5mOmZzdCwgbWFwIHQgfmY6c25kXSAqKVxuICB2YWwgdW56aXAgOiAoJ2ssICd2MSAqICd2MiwgJ2NtcCkgdCAtPiAoJ2ssICd2MSwgJ2NtcCkgdCAqICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgYSB0b3RhbCBvcmRlcmluZyBiZXR3ZWVuIG1hcHMuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHRvdGFsIG9yZGVyaW5nIHVzZWRcbiAgICAgIHRvIGNvbXBhcmUgZGF0YSBhc3NvY2lhdGVkIHdpdGggZXF1YWwga2V5cyBpbiB0aGUgdHdvIG1hcHMuICopXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgndiAtPiAndiAtPiBpbnQpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnRcblxuICAoKiogSGFzaCBmdW5jdGlvbjogYSBidWlsZGluZyBibG9jayB0byB1c2Ugd2hlbiBoYXNoaW5nIGRhdGEgc3RydWN0dXJlcyBjb250YWluaW5nIG1hcHMgaW5cbiAgICAgIHRoZW0uIFtoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbY29tcGFyZV9kaXJlY3RdIGlmZlxuICAgICAgW2hhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbKGNvbXBhcmF0b3IgbSkuY29tcGFyZV0gb2YgdGhlIG1hcCBbbV0gYmVpbmdcbiAgICAgIGhhc2hlZC4gKilcbiAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnayBIYXNoLmZvbGRlciAtPiAndiBIYXNoLmZvbGRlciAtPiAoJ2ssICd2LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgKCoqIFtlcXVhbCBjbXAgbTEgbTJdIHRlc3RzIHdoZXRoZXIgdGhlIG1hcHMgW20xXSBhbmQgW20yXSBhcmUgZXF1YWwsIHRoYXQgaXMsIGNvbnRhaW5cbiAgICAgIHRoZSBzYW1lIGtleXMgYW5kIGFzc29jaWF0ZSBlYWNoIGtleSB3aXRoIHRoZSBzYW1lIHZhbHVlLiAgW2NtcF0gaXMgdGhlIGVxdWFsaXR5XG4gICAgICBwcmVkaWNhdGUgdXNlZCB0byBjb21wYXJlIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlzLiAqKVxuICB2YWwgZXF1YWwgOiAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGtleXMgaW4gdGhlIGdpdmVuIG1hcC4gKilcbiAgdmFsIGtleXMgOiAoJ2ssIF8sIF8pIHQgLT4gJ2sgbGlzdFxuXG4gICgqKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gbWFwLiAqKVxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgKCoqIENyZWF0ZXMgYW4gYXNzb2NpYXRpb24gbGlzdCBmcm9tIHRoZSBnaXZlbiBtYXAuICopXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF0gKCoqIGRlZmF1bHQgaXMgW2BJbmNyZWFzaW5nXSAqKVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sgKiAndikgbGlzdFxuXG4gICgqKiB7MiBBZGRpdGlvbmFsIG9wZXJhdGlvbnMgb24gbWFwc30gKilcblxuICAoKiogTWVyZ2VzIHR3byBtYXBzLiBUaGUgcnVudGltZSBpcyBPKGxlbmd0aCh0MSkgKyBsZW5ndGgodDIpKS4gWW91IHNob3VsZG4ndCB1c2UgdGhpc1xuICAgICAgZnVuY3Rpb24gdG8gbWVyZ2UgYSBsaXN0IG9mIG1hcHM7IGNvbnNpZGVyIHVzaW5nIFttZXJnZV9kaXNqb2luX2V4bl0gb3JcbiAgICAgIFttZXJnZV9za2V3ZWRdIGluc3RlYWQuICopXG4gIHZhbCBtZXJnZVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gKCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAtPiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKiBNZXJnZXMgdHdvIGRpY3Rpb25hcmllcyB3aXRoIHRoZSBzYW1lIHR5cGUgb2YgZGF0YSBhbmQgZGlzam9pbnQgc2V0cyBvZiBrZXlzLlxuICAgICAgUmFpc2VzIGlmIGFueSBrZXlzIG92ZXJsYXAuICopXG4gIHZhbCBtZXJnZV9kaXNqb2ludF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBBIHNwZWNpYWwgY2FzZSBvZiBbbWVyZ2VdLCBbbWVyZ2Vfc2tld2VkIHQxIHQyXSBpcyBhIG1hcCBjb250YWluaW5nIGFsbCB0aGVcbiAgICAgIGJpbmRpbmdzIG9mIFt0MV0gYW5kIFt0Ml0uIEJpbmRpbmdzIHRoYXQgYXBwZWFyIGluIGJvdGggW3QxXSBhbmQgW3QyXSBhcmVcbiAgICAgIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgdmFsdWUgdXNpbmcgdGhlIFtjb21iaW5lXSBmdW5jdGlvbi4gSW4gYSBjYWxsXG4gICAgICBbY29tYmluZSB+a2V5IHYxIHYyXSwgdGhlIHZhbHVlIFt2MV0gY29tZXMgZnJvbSBbdDFdIGFuZCBbdjJdIGZyb20gW3QyXS5cblxuICAgICAgVGhlIHJ1bnRpbWUgb2YgW21lcmdlX3NrZXdlZF0gaXMgW08obWluKGwxLCBsMikgKiBsb2cobWF4KGwxLCBsMikpKV0sIHdoZXJlIFtsMV0gaXNcbiAgICAgIHRoZSBsZW5ndGggb2YgW3QxXSBhbmQgW2wyXSB0aGUgbGVuZ3RoIG9mIFt0Ml0uIFRoaXMgaXMgbGlrZWx5IHRvIGJlIGZhc3RlciB0aGFuXG4gICAgICBbbWVyZ2VdIHdoZW4gb25lIG9mIHRoZSBtYXBzIGlzIGEgbG90IHNtYWxsZXIsIG9yIHdoZW4geW91IG1lcmdlIGEgbGlzdCBvZiBtYXBzLiAqKVxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIG1vZHVsZSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2ssICd2KSB0ID0gJ2sgKiBbIGBMZWZ0IG9mICd2IHwgYFJpZ2h0IG9mICd2IHwgYFVuZXF1YWwgb2YgJ3YgKiAndiBdXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2ssICd2KSB0IDo9ICgnaywgJ3YpIHRcbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG4gICAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXJcbiAgICAgIDogICdrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgKCoqIFtzeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbF0gcmV0dXJucyBhIGxpc3Qgb2YgY2hhbmdlcyBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0uXG4gICAgICBJdCBpcyBpbnRlbmRlZCB0byBiZSBlZmZpY2llbnQgaW4gdGhlIGNhc2Ugd2hlcmUgW3QxXSBhbmQgW3QyXSBzaGFyZSBhIGxhcmdlIGFtb3VudFxuICAgICAgb2Ygc3RydWN0dXJlLiBUaGUga2V5cyBpbiB0aGUgb3V0cHV0IHNlcXVlbmNlIHdpbGwgYmUgaW4gc29ydGVkIG9yZGVyLlxuXG4gICAgICBJdCBpcyBhc3N1bWVkIHRoYXQgW2RhdGFfZXF1YWxdIGlzIGF0IGxlYXN0IGFzIGVxdWF0aW5nIGFzIHBoeXNpY2FsIGVxdWFsaXR5OiB0aGF0XG4gICAgICBbcGh5c19lcXVhbCB4IHldIGltcGxpZXMgW2RhdGFfZXF1YWwgeCB5XS4gT3RoZXJ3aXNlLCBbc3ltbWV0cmljX2RpZmZdIG1heSBiZWhhdmUgaW5cbiAgICAgIHVuZXhwZWN0ZWQgd2F5cy4gRm9yIGV4YW1wbGUsIHdpdGggW35kYXRhX2VxdWFsOihmdW4gXyBfIC0+IGZhbHNlKV0gaXQgaXMgTk9UXG4gICAgICBuZWNlc3NhcmlseSB0aGUgY2FzZSB0aGUgcmVzdWx0aW5nIGNoYW5nZSBzZXF1ZW5jZSB3aWxsIGNvbnRhaW4gYW4gZWxlbWVudFxuICAgICAgWyhrLCBgVW5lcXVhbCBfKV0gZm9yIGV2ZXJ5IGtleSBba10gc2hhcmVkIGJ5IGJvdGggbWFwcy5cblxuICAgICAgV2FybmluZzogRmxvYXQgZXF1YWxpdHkgdmlvbGF0ZXMgdGhpcyBwcm9wZXJ0eSEgW3BoeXNfZXF1YWwgRmxvYXQubmFuIEZsb2F0Lm5hbl0gaXNcbiAgICAgIHRydWUsIGJ1dCBbRmxvYXQuKD0pIEZsb2F0Lm5hbiBGbG9hdC5uYW5dIGlzIGZhbHNlLiAqKVxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICAoKiogW2ZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWxdIGZvbGRzIGFjcm9zcyBhbiBpbXBsaWNpdCBzZXF1ZW5jZSBvZiBjaGFuZ2VzXG4gICAgICBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0sIGluIHNvcnRlZCBvcmRlciBieSBrZXlzLiBFcXVpdmFsZW50IHRvXG4gICAgICBbU2VxdWVuY2UuZm9sZCAoc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwpXSwgYW5kIG1vcmUgZWZmaWNpZW50LiAqKVxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICgnaywgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYWNjKVxuICAgIC0+ICdhY2NcblxuICAoKiogW21pbl9lbHQgbWFwXSByZXR1cm5zIFtTb21lIChrZXksIGRhdGEpXSBwYWlyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1pbmltdW0ga2V5IGluXG4gICAgICBbbWFwXSwgb3IgW05vbmVdIGlmIGVtcHR5LiAqKVxuICB2YWwgbWluX2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sgKiAndlxuXG4gICgqKiBbbWF4X2VsdCBtYXBdIHJldHVybnMgW1NvbWUgKGtleSwgZGF0YSldIHBhaXIgY29ycmVzcG9uZGluZyB0byB0aGUgbWF4aW11bSBrZXkgaW5cbiAgICAgIFttYXBdLCBvciBbTm9uZV0gaWYgW21hcF0gaXMgZW1wdHkuICopXG4gIHZhbCBtYXhfZWx0IDogKCdrLCAndiwgXykgdCAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayAqICd2XG5cbiAgKCoqIFN3YXAgdGhlIGlubmVyIGFuZCBvdXRlciBrZXlzIG9mIG5lc3RlZCBtYXBzLiBJZiBbdHJhbnNwb3NlX2tleXMgbSBhID0gYl0sIHRoZW5cbiAgICAgIFtmaW5kX2V4biAoZmluZF9leG4gYSBpKSBqID0gZmluZF9leG4gKGZpbmRfZXhuIGIgaikgaV0uICopXG4gIHZhbCB0cmFuc3Bvc2Vfa2V5c1xuICAgIDogICgnazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrMSwgKCdrMiwgJ3YsICdjbXAyKSB0LCAnY21wMSkgdFxuICAgIC0+ICgnazIsICgnazEsICd2LCAnY21wMSkgdCwgJ2NtcDIpIHRcblxuICAoKiogVGhlc2UgZnVuY3Rpb25zIGhhdmUgdGhlIHNhbWUgc2VtYW50aWNzIGFzIHNpbWlsYXIgZnVuY3Rpb25zIGluIFtMaXN0XS4gKilcblxuICB2YWwgZm9yX2FsbCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3VtXG4gICAgOiAgKG1vZHVsZSBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gZjooJ3YgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICB2YWwgc3VtaVxuICAgIDogIChtb2R1bGUgQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhKVxuICAgIC0+ICdhXG5cbiAgKCoqIFtzcGxpdCB0IGtleV0gcmV0dXJucyBhIG1hcCBvZiBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiBba2V5XSwgdGhlIG1hcHBpbmcgb2YgW2tleV0gaWZcbiAgICAgIGFueSwgYW5kIGEgbWFwIG9mIGtleXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIFtrZXldLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgc21hbGxlciBvZiB0aGUgdHdvIG91dHB1dCBtYXBzLiAgVGhlIE8obSkgdGVybSBpcyBkdWUgdG8gdGhlIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgbWFwcy4gKilcbiAgdmFsIHNwbGl0XG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICdrXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnayAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtzcGxpdF9sZV9ndCB0IGtleV0gcmV0dXJucyBhIG1hcCBvZiBrZXlzIHRoYXQgYXJlIGxlc3Mgb3IgZXF1YWwgdG8gW2tleV0gYW5kIGFcbiAgICAgIG1hcCBvZiBrZXlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiBba2V5XS5cblxuICAgICAgUnVudGltZSBpcyBPKG0gKyBsb2cgbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGlucHV0IG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZlxuICAgICAgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBvdXRwdXQgbWFwcy4gIFRoZSBPKG0pIHRlcm0gaXMgZHVlIHRvIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IG1hcHMuICopXG4gIHZhbCBzcGxpdF9sZV9ndCA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW3NwbGl0X2x0X2dlIHQga2V5XSByZXR1cm5zIGEgbWFwIG9mIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIFtrZXldIGFuZCBhIG1hcCBvZlxuICAgICAga2V5cyB0aGF0IGFyZSBncmVhdGVyIG9yIGVxdWFsIHRvIFtrZXldLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgc21hbGxlciBvZiB0aGUgdHdvIG91dHB1dCBtYXBzLiAgVGhlIE8obSkgdGVybSBpcyBkdWUgdG8gdGhlIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgbWFwcy4gKilcbiAgdmFsIHNwbGl0X2x0X2dlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0XSByZXR1cm5zIFtgT2sgbWFwXSB3aGVyZSBbbWFwXSBjb250YWlucyBhbGwgdGhlXG4gICAgICBbKGtleSwgdmFsdWUpXSBwYWlycyBmcm9tIHRoZSB0d28gaW5wdXQgbWFwcyBpZiBhbGwgdGhlIGtleXMgZnJvbSBbbG93ZXJfcGFydF0gYXJlXG4gICAgICBsZXNzIHRoYW4gYWxsIHRoZSBrZXlzIGZyb20gW3VwcGVyX3BhcnRdLiAgT3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgIFtgT3ZlcmxhcHBpbmdfa2V5X3Jhbmdlc10uXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhsb2cgbikgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VyIGlucHV0IG1hcC4gIFRoaXMgY2FuIGJlXG4gICAgICBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIFtNYXAubWVyZ2VdIG9yIHJlcGVhdGVkIFtNYXAuYWRkXS5cblxuICAgICAge1tcbiAgICAgICAgYXNzZXJ0IChtYXRjaCBNYXAuYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IHdpdGhcbiAgICAgICAgICB8IGBPayB3aG9sZV9tYXAgLT5cbiAgICAgICAgICAgIE1hcC50b19hbGlzdCB3aG9sZV9tYXBcbiAgICAgICAgICAgID0gTGlzdC5hcHBlbmQgKHRvX2FsaXN0IGxvd2VyX3BhcnQpICh0b19hbGlzdCB1cHBlcl9wYXJ0KVxuICAgICAgICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT4gdHJ1ZSk7XG4gICAgICBdfSAqKVxuICB2YWwgYXBwZW5kXG4gICAgOiAgbG93ZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICAoKiogW3N1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZF0gcmV0dXJucyBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUgZW50cmllcyBmcm9tXG4gICAgICBbdF0gd2hvc2Uga2V5cyBsaWUgaW5zaWRlIHRoZSBpbnRlcnZhbCBpbmRpY2F0ZWQgYnkgW35sb3dlcl9ib3VuZF0gYW5kXG4gICAgICBbfnVwcGVyX2JvdW5kXS4gIElmIHRoaXMgaW50ZXJ2YWwgaXMgZW1wdHksIGFuIGVtcHR5IG1hcCBpcyByZXR1cm5lZC5cblxuICAgICAgUnVudGltZSBpcyBPKG0gKyBsb2cgbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGlucHV0IG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZlxuICAgICAgdGhlIG91dHB1dCBtYXAuICBUaGUgTyhtKSB0ZXJtIGlzIGR1ZSB0byB0aGUgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgIG91dHB1dCBtYXAuICopXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW2ZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQgfm1pbiB+bWF4IH5pbml0IH5mXSBmb2xkcyBbZl0gKHdpdGggaW5pdGlhbCB2YWx1ZSBbfmluaXRdKVxuICAgICAgb3ZlciBhbGwga2V5cyAoYW5kIHRoZWlyIGFzc29jaWF0ZWQgdmFsdWVzKSB0aGF0IGFyZSBpbiB0aGUgcmFuZ2UgW1ttaW4sIG1heF1dXG4gICAgICAoaW5jbHVzaXZlKS4gICopXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBtaW46J2tcbiAgICAtPiBtYXg6J2tcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgLT4gJ2FjY1xuXG4gICgqKiBbcmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXhdIHJldHVybnMgYW4gYXNzb2NpYXRpdmUgbGlzdCBvZiB0aGUgZWxlbWVudHMgd2hvc2Uga2V5c1xuICAgICAgbGllIGluIFtbbWluLCBtYXhdXSAoaW5jbHVzaXZlKSwgd2l0aCB0aGUgc21hbGxlc3Qga2V5IGJlaW5nIGF0IHRoZSBoZWFkIG9mIHRoZVxuICAgICAgbGlzdC4gKilcbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiBtaW46J2sgLT4gbWF4OidrIC0+ICgnayAqICd2KSBsaXN0XG5cbiAgKCoqIFtjbG9zZXN0X2tleSB0IGRpciBrXSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIGluIFt0XSB3aXRoIFtrZXldIGNsb3Nlc3QgdG9cbiAgICAgIFtrXSB0aGF0IHNhdGlzZmllcyB0aGUgZ2l2ZW4gaW5lcXVhbGl0eSBib3VuZC5cblxuICAgICAgRm9yIGV4YW1wbGUsIFtjbG9zZXN0X2tleSB0IGBMZXNzX3RoYW4ga10gd291bGQgYmUgdGhlIHBhaXIgd2l0aCB0aGUgY2xvc2VzdCBrZXkgdG9cbiAgICAgIFtrXSB3aGVyZSBba2V5IDwga10uXG5cbiAgICAgIFt0b19zZXF1ZW5jZV0gY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSBzYW1lIHJlc3VsdHMgYXMgW2Nsb3Nlc3Rfa2V5XS4gIEl0IGlzIGxlc3NcbiAgICAgIGVmZmljaWVudCBmb3IgaW5kaXZpZHVhbCBsb29rdXBzIGJ1dCBtb3JlIGVmZmljaWVudCBmb3IgZmluZGluZyBtYW55IGVsZW1lbnRzIHN0YXJ0aW5nXG4gICAgICBhdCBzb21lIHZhbHVlLiAqKVxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdrXG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbbnRoIHQgbl0gZmluZHMgdGhlIChrZXksIHZhbHVlKSBwYWlyIG9mIHJhbmsgbiAoaS5lLiwgc3VjaCB0aGF0IHRoZXJlIGFyZSBleGFjdGx5IG5cbiAgICAgIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIHRoZSBmb3VuZCBrZXkpLCBpZiBvbmUgZXhpc3RzLiAgTyhsb2cobGVuZ3RoIHQpICsgbikgdGltZS4gKilcbiAgdmFsIG50aCA6ICgnaywgJ3YsIF8pIHQgLT4gaW50IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbnRoX2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gaW50IC0+ICdrICogJ3ZcblxuICAoKiogW3JhbmsgdCBrXSBJZiBba10gaXMgaW4gW3RdLCByZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gW2tdIGluXG4gICAgICBbdF0sIGFuZCBbTm9uZV0gb3RoZXJ3aXNlLiAqKVxuICB2YWwgcmFuayA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gaW50IG9wdGlvblxuXG4gICgqKiBbdG9fc2VxdWVuY2UgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0XVxuICAgICAgZ2l2ZXMgYSBzZXF1ZW5jZSBvZiBrZXktdmFsdWUgcGFpcnMgYmV0d2VlbiBba2V5c19sZXNzX29yX2VxdWFsX3RvXSBhbmRcbiAgICAgIFtrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9dIGluY2x1c2l2ZSwgcHJlc2VudGVkIGluIFtvcmRlcl0uICBJZlxuICAgICAgW2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA+IGtleXNfbGVzc19vcl9lcXVhbF90b10sIHRoZSBzZXF1ZW5jZSBpc1xuICAgICAgZW1wdHkuXG5cbiAgICAgIFdoZW4gbmVpdGhlciBba2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXSBub3IgW2tleXNfbGVzc19vcl9lcXVhbF90b10gYXJlXG4gICAgICBwcm92aWRlZCwgdGhlIGNvc3QgaXMgTyhsb2cgbikgdXAgZnJvbnQgYW5kIGFtb3J0aXplZCBPKDEpIHRvIHByb2R1Y2VcbiAgICAgIGVhY2ggZWxlbWVudC4gSWYgZWl0aGVyIGlzIHByb3ZpZGVkIChhbmQgaXMgdXNlZCBieSB0aGUgb3JkZXIgcGFyYW1ldGVyXG4gICAgICBwcm92aWRlZCksIHRoZW4gdGhlIHRoZSBjb3N0IGlzIE8obikgdXAgZnJvbnQsIGFuZCBhbW9ydGl6ZWQgTygxKSB0b1xuICAgICAgcHJvZHVjZSBlYWNoIGVsZW1lbnQuICopXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSAoKiogZGVmYXVsdCAqKSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzona1xuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2tcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcblxuICAoKiogW2JpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSB3aGljaCBlbHRdIHJldHVybnMgdGhlIFsoa2V5LCB2YWx1ZSldIHBhaXIgaW4gW3RdXG4gICAgICBzcGVjaWZpZWQgYnkgW2NvbXBhcmVdIGFuZCBbd2hpY2hdLCBpZiBvbmUgZXhpc3RzLlxuXG4gICAgICBbdF0gbXVzdCBiZSBzb3J0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciBhY2NvcmRpbmcgdG8gW2NvbXBhcmVdLCB3aGVyZSBbY29tcGFyZV0gYW5kXG4gICAgICBbZWx0XSBkaXZpZGUgW3RdIGludG8gdGhyZWUgKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCAgPCBlbHQgIHwgID0gZWx0ICB8ICA+IGVsdCAgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIHJldHVybnMgYW4gZWxlbWVudCBvbiB0aGUgYm91bmRhcnkgb2Ygc2VnbWVudHMgYXMgc3BlY2lmaWVkIGJ5XG4gICAgICBbd2hpY2hdLiAgU2VlIHRoZSBkaWFncmFtIGJlbG93IG5leHQgdG8gdGhlIFt3aGljaF0gdmFyaWFudHMuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtjb21wYXJlXSBvcmRlcnMgW3RdLCBhbmQgYmVoYXZpb3IgaXNcbiAgICAgIHVuc3BlY2lmaWVkIGlmIFtjb21wYXJlXSBkb2Vzbid0IG9yZGVyIFt0XS4gIEJlaGF2aW9yIGlzIGFsc28gdW5zcGVjaWZpZWQgaWZcbiAgICAgIFtjb21wYXJlXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gWyBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gKCoqICAgICAgICB7diB8IDwgZWx0IFggfCAgICAgICAgICAgICAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAoKiogICAgIHt2IHwgICAgICA8PSBlbHQgICAgICAgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgICA9IGVsdCBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCBYID0gZWx0ICAgfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gKCoqIHt2ICAgICAgICAgICB8IFggICAgICAgPj0gZWx0ICAgICAgfCB2fSAqKVxuICAgICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAoKiogICAge3YgICAgICAgICAgICAgICAgICAgICAgIHwgWCA+IGVsdCB8IHZ9ICopXG4gICAgICAgXVxuICAgIC0+ICdrZXlcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIHdoaWNoXSB0YWtlcyBhIFtzZWdtZW50X29mXSBmdW5jdGlvbiB0aGF0XG4gICAgICBkaXZpZGVzIFt0XSBpbnRvIHR3byAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8IHNlZ21lbnRfb2YgZWx0ID0gYExlZnQgfCBzZWdtZW50X29mIGVsdCA9IGBSaWdodCB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIHJldHVybnMgdGhlIFsoa2V5LCB2YWx1ZSldIHBhaXIgb24gdGhlIGJvdW5kYXJ5IG9mIHRoZVxuICAgICAgc2VnbWVudHMgYXMgc3BlY2lmaWVkIGJ5IFt3aGljaF06IFtgTGFzdF9vbl9sZWZ0XSB5aWVsZHMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGVcbiAgICAgIGxlZnQgc2VnbWVudCwgd2hpbGUgW2BGaXJzdF9vbl9yaWdodF0geWllbGRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSByaWdodCBzZWdtZW50LlxuICAgICAgSXQgcmV0dXJucyBbTm9uZV0gaWYgdGhlIHNlZ21lbnQgaXMgZW1wdHkuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gZG9lcyBub3QgY2hlY2sgdGhhdCBbc2VnbWVudF9vZl0gc2VnbWVudHMgW3RdIGFzIGluIHRoZVxuICAgICAgZGlhZ3JhbSwgYW5kIGJlaGF2aW9yIGlzIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBkb2Vzbid0IHNlZ21lbnQgW3RdLiAgQmVoYXZpb3JcbiAgICAgIGlzIGFsc28gdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IFsgYExhc3Rfb25fbGVmdCB8IGBGaXJzdF9vbl9yaWdodCBdXG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaF9zdWJyYW5nZV0gdGFrZXMgYSBbY29tcGFyZV0gZnVuY3Rpb24gdGhhdCBkaXZpZGVzIFt0XSBpbnRvIHRocmVlXG4gICAgICAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzIHdpdGggcmVzcGVjdCB0byBbbG93ZXJfYm91bmRdIGFuZCBbdXBwZXJfYm91bmRdOlxuXG4gICAgICB7dlxuICAgICAgICB8IEJlbG93X2xvd2VyX2JvdW5kIHwgSW5fcmFuZ2UgfCBBYm92ZV91cHBlcl9ib3VuZCB8XG4gICAgICB2fVxuXG4gICAgICBhbmQgcmV0dXJucyBhIG1hcCBvZiB0aGUgW0luX3JhbmdlXSBzZWdtZW50LlxuXG4gICAgICBSdW50aW1lIGlzIE8obG9nIG0gKyBuKSB3aGVyZSBbbV0gaXMgdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgbWFwIGFuZCBbbl0gaXMgdGhlXG4gICAgICBsZW5ndGggb2YgdGhlIG91dHB1dC4gVGhlIGxpbmVhciB0ZXJtIGluIFtuXSBpcyB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dC5cblxuICAgICAgQmVoYXZpb3IgaXMgdW5kZWZpbmVkIGlmIFtjb21wYXJlXSBkb2VzIG5vdCBzZWdtZW50IFt0XSBhcyBzaG93biBhYm92ZSwgb3IgaWZcbiAgICAgIFtjb21wYXJlXSBtdXRhdGVzIGl0cyBpbnB1dHMuICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyB0cmF2ZXJzYWxzIHRvIHJlY29uc3RydWN0IGEgbWFwIHdpdGhpbiBhbiBhcHBsaWNhdGl2ZS4gVXNlc1xuICAgICAgW0xhenlfYXBwbGljYXRpdmVdIHNvIHRoYXQgdGhlIG1hcCBjYW4gYmUgdHJhdmVyc2VkIHdpdGhpbiB0aGUgYXBwbGljYXRpdmUsIHJhdGhlclxuICAgICAgdGhhbiBuZWVkaW5nIHRvIGJlIHRyYXZlcnNlZCBhbGwgYXQgb25jZSwgb3V0c2lkZSB0aGUgYXBwbGljYXRpdmUuICopXG4gIG1vZHVsZSBNYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMgKEEgOiBBcHBsaWNhdGl2ZS5MYXp5X2FwcGxpY2F0aXZlKSA6IHNpZ1xuICAgIHZhbCBtYXBpXG4gICAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MiBBLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCBBLnRcblxuICAgIHZhbCBmaWx0ZXJfbWFwaVxuICAgICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uIEEudClcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0IEEudFxuICBlbmRcblxuICAoKiogW01dIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBPQ2FtbCBhcHBsaWNhdGl2ZSBmdW5jdG9yIHR5cGVzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfbWFwID0gaW50IE1hcC5NKFN0cmluZykudFxuICAgICAgXX1cblxuICAgICAgd2hpY2ggc3RhbmRzIGZvcjpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X21hcCA9IChTdHJpbmcudCwgaW50LCBTdHJpbmcuY29tcGFyYXRvcl93aXRuZXNzKSBNYXAudFxuICAgICAgXX1cblxuICAgICAgVGhlIHBvaW50IGlzIHRoYXQgW2ludCBNYXAuTShTdHJpbmcpLnRdIHN1cHBvcnRzIGRlcml2aW5nLCB3aGVyZWFzIHRoZSBzZWNvbmQgc3ludGF4XG4gICAgICBkb2Vzbid0IChiZWNhdXNlIHRoZXJlIGlzIG5vIHN1Y2ggdGhpbmcgYXMsIHNheSwgW1N0cmluZy5zZXhwX29mX2NvbXBhcmF0b3Jfd2l0bmVzc11cbiAgICAgIC0tIGluc3RlYWQgeW91IHdvdWxkIHdhbnQgdG8gcGFzcyB0aGUgY29tcGFyYXRvciBkaXJlY3RseSkuXG5cbiAgICAgIEluIGFkZGl0aW9uLCB3aGVuIHVzaW5nIFtAQGRlcml2aW5nXSwgdGhlIHJlcXVpcmVtZW50cyBvbiB0aGUga2V5IG1vZHVsZSBhcmUgb25seVxuICAgICAgdGhvc2UgbmVlZGVkIHRvIHNhdGlzZnkgd2hhdCB5b3UgYXJlIHRyeWluZyB0byBkZXJpdmUgb24gdGhlIG1hcCBpdHNlbGYuIFNheSB5b3VcbiAgICAgIHdyaXRlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHQgPSBpbnQgTWFwLk0oWCkudCBbQEBkZXJpdmluZyBoYXNoXVxuICAgICAgXX1cblxuICAgICAgdGhlbiB0aGlzIHdpbGwgYmUgd2VsbCB0eXBlZCBleGFjdGx5IGlmIFtYXSBjb250YWlucyBhdCBsZWFzdDpcbiAgICAgIC0gYSB0eXBlIFt0XSB3aXRoIG5vIHBhcmFtZXRlcnNcbiAgICAgIC0gYSBjb21wYXJhdG9yIHdpdG5lc3NcbiAgICAgIC0gYSBbaGFzaF9mb2xkX3RdIGZ1bmN0aW9uIHdpdGggdGhlIHJpZ2h0IHR5cGUgKilcbiAgbW9kdWxlIE0gKEsgOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICBlbmQpIDogc2lnXG4gICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICBlbmRcblxuICBpbmNsdWRlIEZvcl9kZXJpdmluZyB3aXRoIHR5cGUgKCdrZXksICd2YWx1ZSwgJ2NtcCkgdCA6PSAoJ2tleSwgJ3ZhbHVlLCAnY21wKSB0XG5cbiAgKCoqIFtVc2luZ19jb21wYXJhdG9yXSBpcyBhIHNpbWlsYXIgaW50ZXJmYWNlIGFzIHRoZSB0b3BsZXZlbCBvZiBbTWFwXSwgZXhjZXB0IHRoZVxuICAgICAgZnVuY3Rpb25zIHRha2UgYSBbfmNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRdLCB3aGVyZWFzIHRoZSBmdW5jdGlvbnMgYXQgdGhlXG4gICAgICB0b3BsZXZlbCBvZiBbTWFwXSB0YWtlIGEgWygnaywgJ2NtcCkgY29tcGFyYXRvcl0uICopXG4gIG1vZHVsZSBVc2luZ19jb21wYXJhdG9yIDogc2lnXG4gICAgdHlwZSBub25yZWMgKCdrLCArJ3YsICdjbXApIHQgPSAoJ2ssICd2LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgndiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKFNleHAudCAtPiAnaylcbiAgICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgICAtPiBTZXhwLnRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAgIG1vZHVsZSBUcmVlIDogc2lnXG4gICAgICB0eXBlICgrJ2ssICsndiwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgdmFsIHNleHBfb2ZfdFxuICAgICAgICA6ICAoJ2sgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ3YgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgICAgLT4gKFNleHAudCAtPiAnaylcbiAgICAgICAgLT4gKFNleHAudCAtPiAndilcbiAgICAgICAgLT4gU2V4cC50XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAgICAgaW5jbHVkZVxuICAgICAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWNcbiAgICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICB3aXRoIHR5cGUgJ2sga2V5IDo9ICdrXG4gICAgICAgICAgd2l0aCB0eXBlICdjIGNtcCA6PSAnY1xuICAgICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgY3JlYXRlX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIFdpdGhfY29tcGFyYXRvci50XG4gICAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aF9jb21wYXJhdG9yLnRcblxuICAgICAgdmFsIGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gOiAoXywgXywgXykgdFxuXG4gICAgICAoKiogW0J1aWxkX2luY3JlYXNpbmddIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIG1hcCBpbmNyZW1lbnRhbGx5IGZyb20gYVxuICAgICAgICAgIHNlcXVlbmNlIHRoYXQgaXMga25vd24gdG8gYmUgaW5jcmVhc2luZy5cblxuICAgICAgICAgIFRoZSB0b3RhbCB0aW1lIGNvbXBsZXhpdHkgb2YgY29uc3RydWN0aW5nIGEgbWFwIHRoaXMgd2F5IGlzIE8obiksIHdoaWNoIGlzIG1vcmVcbiAgICAgICAgICBlZmZpY2llbnQgdGhhbiB1c2luZyBbTWFwLmFkZF0gYnkgYSBsb2dhcml0aG1pYyBmYWN0b3IuXG5cbiAgICAgICAgICBUaGlzIGludGVyZmFjZSBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIGR1YWwgb2YgW3RvX3NlcXVlbmNlXSwgYnV0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICBhbiBlcXVhbGx5IG5lYXQgaWRpb20gZm9yIHRoZSBkdWFscyBvZiBzZXF1ZW5jZXMgKFtvZl9zZXF1ZW5jZV0gaXMgbXVjaCBsZXNzXG4gICAgICAgICAgZ2VuZXJhbCBiZWNhdXNlIGl0IGRvZXMgbm90IGFsbG93IHRoZSBzZXF1ZW5jZSB0byBiZSBwcm9kdWNlZCBhc3luY2hyb25vdXNseSkuICopXG4gICAgICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA6IHNpZ1xuICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgIHR5cGUgKCdrLCAndiwgJ3cpIHRcblxuICAgICAgICB2YWwgZW1wdHkgOiAoJ2ssICd2LCAndykgdFxuXG4gICAgICAgICgqKiBUaW1lIGNvbXBsZXhpdHkgb2YgW2FkZF9leG5dIGlzIGFtb3J0aXplZCBjb25zdGFudC10aW1lIChpZiBbdF0gaXMgdXNlZFxuICAgICAgICAgICAgbGluZWFybHkpLCB3aXRoIGEgd29yc3QtY2FzZSBPKGxvZyhuKSkgdGltZS4gKilcbiAgICAgICAgdmFsIGFkZF9leG5cbiAgICAgICAgICA6ICAoJ2ssICd2LCAndykgdFxuICAgICAgICAgIC0+IGNvbXBhcmF0b3I6KCdrLCAndykgQ29tcGFyYXRvci50XG4gICAgICAgICAgLT4ga2V5OidrXG4gICAgICAgICAgLT4gZGF0YTondlxuICAgICAgICAgIC0+ICgnaywgJ3YsICd3KSB0XG5cbiAgICAgICAgKCoqIFRpbWUgY29tcGxleGl0eSBpcyBPKGxvZyhuKSkuICopXG4gICAgICAgIHZhbCB0b190cmVlIDogKCdrLCAndiwgJ3cpIHQgLT4gKCdrLCAndiwgJ3cpIHRyZWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuICAgICAgICB3aXRoIHR5cGUgJ2sga2V5IDo9ICdrXG4gICAgICAgIHdpdGggdHlwZSAnYyBjbXAgOj0gJ2NcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aG91dF9jb21wYXJhdG9yLnRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aF9jb21wYXJhdG9yLnRcblxuICAgIHZhbCBjb21wYXJhdG9yIDogKCdhLCBfLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG5cbiAgICB2YWwgaGFzaF9mb2xkX2RpcmVjdFxuICAgICAgOiAgJ2sgSGFzaC5mb2xkZXJcbiAgICAgIC0+ICd2IEhhc2guZm9sZGVyXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgICAoKiogVG8gZ2V0IGFyb3VuZCB0aGUgdmFsdWUgcmVzdHJpY3Rpb24sIGFwcGx5IHRoZSBmdW5jdG9yIGFuZCBpbmNsdWRlIGl0LiBZb3VcbiAgICAgICAgY2FuIHNlZSBhbiBleGFtcGxlIG9mIHRoaXMgaW4gdGhlIFtQb2x5XSBzdWJtb2R1bGUgYmVsb3cuICopXG4gICAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEsgOiBDb21wYXJhdG9yLlMxKSA6IHNpZ1xuICAgICAgdmFsIGVtcHR5IDogKCdhIEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgZW5kXG4gIGVuZFxuXG4gICgqKiBBIHBvbHltb3JwaGljIE1hcC4gKilcbiAgbW9kdWxlIFBvbHkgOlxuICAgIFNfcG9seVxuICAgICAgd2l0aCB0eXBlICgna2V5LCArJ3ZhbHVlKSB0ID0gKCdrZXksICd2YWx1ZSwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgICAgIGFuZCB0eXBlICgna2V5LCArJ3ZhbHVlKSB0cmVlID1cbiAgICAgICAgKCdrZXksICd2YWx1ZSwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcbiAgICAgICBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgKCoqIENyZWF0ZSBhIG1hcCBmcm9tIGEgdHJlZSB1c2luZyB0aGUgZ2l2ZW4gY29tcGFyYXRvci4gKilcbiAgdmFsIG9mX3RyZWVcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogRXh0cmFjdCBhIHRyZWUgZnJvbSBhIG1hcC4gKilcbiAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG5cbiAgKCoqIHsyIE1vZHVsZXMgYW5kIG1vZHVsZSB0eXBlcyBmb3IgZXh0ZW5kaW5nIFtNYXBdfVxuXG4gICAgICBGb3IgdXNlIGluIGV4dGVuc2lvbnMgb2YgQmFzZSwgbGlrZSBbQ29yZV0uICopXG5cbiAgbW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IFdpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgV2l0aF9maXJzdF9jbGFzc19tb2R1bGUgPSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZVxuICBtb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gV2l0aG91dF9jb21wYXJhdG9yXG5cbiAgbW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gRm9yX2Rlcml2aW5nXG4gIG1vZHVsZSB0eXBlIFNfcG9seSA9IFNfcG9seVxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IEFjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gQ3JlYXRvcnNfZ2VuZXJpY1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFRcblxubW9kdWxlIHR5cGUgRWx0X3BsYWluID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IE1hcF9pbnRmLldpdGhvdXRfY29tcGFyYXRvclxubW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IE1hcF9pbnRmLldpdGhfY29tcGFyYXRvclxubW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gTWFwX2ludGYuV2l0aF9maXJzdF9jbGFzc19tb2R1bGVcbm1vZHVsZSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50ID0gU2VxdWVuY2UuTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnRcblxubW9kdWxlIE5hbWVkID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBzZXQgOiAnYVxuICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgIH1cbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgdFxuXG4gIGluY2x1ZGUgQ29udGFpbmVyLkdlbmVyaWMgd2l0aCB0eXBlICgnYSwgJ2NtcCwgXykgdCA6PSAoJ2EsICdjbXApIHRcblxuICB0eXBlICgnYSwgJ2NtcCkgdHJlZVxuXG4gICgqKiBUaGUgW2FjY2Vzc19vcHRpb25zXSB0eXBlIGlzIHVzZWQgdG8gbWFrZSBbQWNjZXNzb3JzX2dlbmVyaWNdIGZsZXhpYmxlIGFzIHRvIHdoZXRoZXJcbiAgICAgIGEgY29tcGFyYXRvciBpcyByZXF1aXJlZCB0byBiZSBwYXNzZWQgdG8gY2VydGFpbiBmdW5jdGlvbnMuICopXG4gIHR5cGUgKCdhLCAnY21wLCAneikgYWNjZXNzX29wdGlvbnNcblxuICB0eXBlICdjbXAgY21wXG5cbiAgdmFsIGludmFyaWFudHMgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBib29sKSBhY2Nlc3Nfb3B0aW9uc1xuXG4gICgqKiBvdmVycmlkZSBbQ29udGFpbmVyXSdzIFttZW1dICopXG4gIHZhbCBtZW0gOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAnYSBlbHQgLT4gYm9vbCkgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYWRkIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCB1bmlvbiA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCBpbnRlciA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCBkaWZmIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSBlbHQsICdhIGVsdCkgRWl0aGVyLnQgU2VxdWVuY2UudCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBpbnQpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sKSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiBib29sKSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgYXJlX2Rpc2pvaW50IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2wpIGFjY2Vzc19vcHRpb25zXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldFxuICAgICAgOiAoICdhXG4gICAgICAgICwgJ2NtcFxuICAgICAgICAsICgnYSwgJ2NtcCkgdCBOYW1lZC50IC0+IG9mXzooJ2EsICdjbXApIHQgTmFtZWQudCAtPiB1bml0IE9yX2Vycm9yLnQgKVxuICAgICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gICAgdmFsIGVxdWFsXG4gICAgICA6ICggJ2FcbiAgICAgICAgLCAnY21wXG4gICAgICAgICwgKCdhLCAnY21wKSB0IE5hbWVkLnQgLT4gKCdhLCAnY21wKSB0IE5hbWVkLnQgLT4gdW5pdCBPcl9lcnJvci50IClcbiAgICAgICAgYWNjZXNzX29wdGlvbnNcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICdhIGVsdCAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjYyAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhIGVsdCAtPiAnYWNjIC0+ICdhY2MpIC0+ICdhY2NcblxuICB2YWwgaXRlcjJcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHRcbiAgICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgZWx0IHwgYFJpZ2h0IG9mICdhIGVsdCB8IGBCb3RoIG9mICdhIGVsdCAqICdhIGVsdCBdIC0+IHVuaXQpXG4gICAgICAgIC0+IHVuaXQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgZmlsdGVyIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHBhcnRpdGlvbl90ZiA6ICgnYSwgJ2NtcCkgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0XG4gIHZhbCBlbGVtZW50cyA6ICgnYSwgXykgdCAtPiAnYSBlbHQgbGlzdFxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYSBlbHRcbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0XG4gIHZhbCBjaG9vc2UgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgY2hvb3NlX2V4biA6ICgnYSwgXykgdCAtPiAnYSBlbHRcblxuICB2YWwgc3BsaXRcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCAqICdhIGVsdCBvcHRpb24gKiAoJ2EsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc3BsaXRfbGVfZ3RcbiAgICA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHQpIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHNwbGl0X2x0X2dlXG4gICAgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAnYSBlbHQgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0KSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBncm91cF9ieSA6ICgnYSwgJ2NtcCkgdCAtPiBlcXVpdjooJ2EgZWx0IC0+ICdhIGVsdCAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgbGlzdFxuICB2YWwgZmluZF9leG4gOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICdhIGVsdFxuICB2YWwgbnRoIDogKCdhLCBfKSB0IC0+IGludCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCByZW1vdmVfaW5kZXggOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhLCAnY21wKSB0KSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAgICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgLT4gJ2EgZWx0IFNlcXVlbmNlLnQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdFxuICAgICAgICAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2tleSAtPiBpbnQpXG4gICAgICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgICAgICAtPiAna2V5XG4gICAgICAgIC0+ICdhIGVsdCBvcHRpb24gKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHRcbiAgICAgICAgLT4gc2VnbWVudF9vZjooJ2EgZWx0IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgICAgICAtPiAnYSBlbHQgb3B0aW9uIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYSBlbHRcbiAgICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAtPiAoJ2EgZWx0LCAnYSBlbHQpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG4gIHR5cGUgJ2EgZWx0XG4gIHR5cGUgKCdhLCAnY21wLCAneikgY3JlYXRlX29wdGlvbnNcbiAgdHlwZSAnY21wIGNtcFxuXG4gIHZhbCBlbXB0eSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wLCAnYSBlbHQgLT4gKCdhLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuICB2YWwgdW5pb25fbGlzdCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IGxpc3QgLT4gKCdhLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuICB2YWwgb2ZfbGlzdCA6ICgnYSwgJ2NtcCwgJ2EgZWx0IGxpc3QgLT4gKCdhLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuICB2YWwgb2Zfc2VxdWVuY2UgOiAoJ2EsICdjbXAsICdhIGVsdCBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcbiAgdmFsIG9mX2FycmF5IDogKCdhLCAnY21wLCAnYSBlbHQgYXJyYXkgLT4gKCdhLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogKCdhLCAnY21wLCAnYSBlbHQgYXJyYXkgLT4gKCdhLCAnY21wKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogKCdhLCAnY21wLCAnYSBlbHQgYXJyYXkgLT4gKCdhLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogKCdhLCAnY21wLCBsZW46aW50IC0+IGY6KGludCAtPiAnYSBlbHQpIC0+ICgnYSwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiAoJ2EsIF8sICdhIGVsdCBsaXN0IC0+ICdhIGVsdCBsaXN0KSBjcmVhdGVfb3B0aW9uc1xuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAyMy0wNF0gVXNlIFtMaXN0LnN0YWJsZV9kZWR1cF0gaW5zdGVhZC5cIl1cblxuICAoKiogVGhlIHR5cGVzIG9mIFttYXBdIGFuZCBbZmlsdGVyX21hcF0gYXJlIHN1YnRsZS4gIFRoZSBpbnB1dCBzZXQsIFsoJ2EsIF8pIHNldF0sXG4gICAgICByZWZsZWN0cyB0aGUgZmFjdCB0aGF0IHRoZXNlIGZ1bmN0aW9ucyB0YWtlIGEgc2V0IG9mICphbnkqIHR5cGUsIHdpdGggYW55XG4gICAgICBjb21wYXJhdG9yLCB3aGlsZSB0aGUgb3V0cHV0IHNldCwgWygnYiwgJ2NtcCkgdF0sIHJlZmxlY3RzIHRoYXQgdGhlIG91dHB1dCBzZXQgaGFzXG4gICAgICB0aGUgcGFydGljdWxhciBbJ2NtcF0gb2YgdGhlIGNyZWF0aW9uIGZ1bmN0aW9uLiAgVGhlIGNvbXBhcmF0b3IgY2FuIGNvbWUgaW4gb25lIG9mXG4gICAgICB0aHJlZSB3YXlzLCBkZXBlbmRpbmcgb24gd2hpY2ggc2V0IG1vZHVsZSBpcyB1c2VkXG5cbiAgICAgIC0gW1NldC5tYXBdIC0tIGNvbXBhcmF0b3IgY29tZXMgYXMgYW4gYXJndW1lbnRcbiAgICAgIC0gW1NldC5Qb2x5Lm1hcF0gLS0gY29tcGFyYXRvciBpcyBwb2x5bW9ycGhpYyBjb21wYXJpc29uXG4gICAgICAtIFtGb28uU2V0Lm1hcF0gLS0gY29tcGFyYXRvciBpcyBbRm9vLmNvbXBhcmF0b3JdICopXG4gIHZhbCBtYXAgOiAoJ2IsICdjbXAsICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiIGVsdCkgLT4gKCdiLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAoJ2IsICdjbXAsICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiIGVsdCBvcHRpb24pIC0+ICgnYiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfdHJlZSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0cmVlIC0+ICgnYSwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2VsdCwgJ2NtcCkgc2V0XG4gIHR5cGUgKCdlbHQsICdjbXApIHRcbiAgdHlwZSAoJ2VsdCwgJ2NtcCkgdHJlZVxuICB0eXBlICdlbHQgZWx0XG4gIHR5cGUgJ2NtcCBjbXBcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzX2dlbmVyaWNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRyZWVcbiAgICAgIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgZWx0XG4gICAgICB3aXRoIHR5cGUgJ2NtcCBjbXAgOj0gJ2NtcCBjbXBcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHNldCA6PSAoJ2EsICdiKSBzZXRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRyZWVcbiAgICAgIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgZWx0XG4gICAgICB3aXRoIHR5cGUgJ2NtcCBjbXAgOj0gJ2NtcCBjbXBcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3BvbHkgPSBzaWdcbiAgdHlwZSAoJ2VsdCwgJ2NtcCkgc2V0XG4gIHR5cGUgJ2VsdCB0XG4gIHR5cGUgJ2VsdCB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICAgd2l0aCB0eXBlICgnZWx0LCAnY21wKSBzZXQgOj0gKCdlbHQsICdjbXApIHNldFxuICAgICAgd2l0aCB0eXBlICgnZWx0LCAnY21wKSB0IDo9ICdlbHQgdFxuICAgICAgd2l0aCB0eXBlICgnZWx0LCAnY21wKSB0cmVlIDo9ICdlbHQgdHJlZVxuICAgICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYVxuICAgICAgd2l0aCB0eXBlICdjIGNtcCA6PSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgY3JlYXRlX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIFdpdGhvdXRfY29tcGFyYXRvci50XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGFjY2Vzc19vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBXaXRob3V0X2NvbXBhcmF0b3IudFxuZW5kXG5cbm1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcblxuICBtb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICAgIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG4gIHZhbCBzZXhwX29mX21fX3QgOiAobW9kdWxlIFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9ICdlbHQpIC0+ICgnZWx0LCAnY21wKSB0IC0+IFNleHAudFxuXG4gIHZhbCBtX190X29mX3NleHBcbiAgICA6ICAobW9kdWxlIE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9ICdlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcbiAgICAtPiBTZXhwLnRcbiAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gIHZhbCBtX190X3NleHBfZ3JhbW1hclxuICAgIDogIChtb2R1bGUgTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSAnZWx0KVxuICAgIC0+ICgnZWx0LCAnY21wKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgdmFsIGNvbXBhcmVfbV9fdCA6IChtb2R1bGUgQ29tcGFyZV9tKSAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiBpbnRcbiAgdmFsIGVxdWFsX21fX3QgOiAobW9kdWxlIEVxdWFsX20pIC0+ICgnZWx0LCAnY21wKSB0IC0+ICgnZWx0LCAnY21wKSB0IC0+IGJvb2xcblxuICB2YWwgaGFzaF9mb2xkX21fX3RcbiAgICA6ICAobW9kdWxlIEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gJ2VsdClcbiAgICAtPiBIYXNoLnN0YXRlXG4gICAgLT4gKCdlbHQsIF8pIHRcbiAgICAtPiBIYXNoLnN0YXRlXG5cbiAgdmFsIGhhc2hfbV9fdCA6IChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnZWx0KSAtPiAoJ2VsdCwgXykgdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXQgPSBzaWdcbiAgKCoqIFNldHMgYmFzZWQgb24geyFDb21wYXJhdG9yLlN9LlxuXG4gICAgICBDcmVhdG9ycyByZXF1aXJlIGEgY29tcGFyYXRvciBhcmd1bWVudCB0byBiZSBwYXNzZWQgaW4sIHdoZXJlYXMgYWNjZXNzb3JzIHVzZSB0aGVcbiAgICAgIGNvbXBhcmF0b3IgcHJvdmlkZWQgYnkgdGhlIGlucHV0IHNldC4gKilcblxuICAoKiogVGhlIHR5cGUgb2YgYSBzZXQuICBUaGUgZmlyc3QgdHlwZSBwYXJhbWV0ZXIgaWRlbnRpZmllcyB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudCwgYW5kXG4gICAgICB0aGUgc2Vjb25kIGlkZW50aWZpZXMgdGhlIGNvbXBhcmF0b3IsIHdoaWNoIGRldGVybWluZXMgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gdGhhdFxuICAgICAgaXMgdXNlZCBmb3Igb3JkZXJpbmcgZWxlbWVudHMgaW4gdGhpcyBzZXQuICBNYW55IG9wZXJhdGlvbnMgKGUuZy4sIHshdW5pb259KSxcbiAgICAgIHJlcXVpcmUgdGhhdCB0aGV5IGJlIHBhc3NlZCBzZXRzIHdpdGggdGhlIHNhbWUgZWxlbWVudCB0eXBlIGFuZCB0aGUgc2FtZSBjb21wYXJhdG9yXG4gICAgICB0eXBlLiAqKVxuICB0eXBlICghJ2VsdCwgISdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCEnZWx0LCAhJ2NtcCkgdCA6PSAoJ2VsdCwgJ2NtcCkgdFxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIFRlc3RzIGludGVybmFsIGludmFyaWFudHMgb2YgdGhlIHNldCBkYXRhIHN0cnVjdHVyZS4gIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLiAqKVxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGZpcnN0LWNsYXNzIG1vZHVsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIG90aGVyIG1hcC9zZXQvZXRjXG4gICAgICB3aXRoIHRoZSBzYW1lIG5vdGlvbiBvZiBjb21wYXJpc29uLiAqKVxuICB2YWwgY29tcGFyYXRvcl9zIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG5cbiAgKCoqIENyZWF0ZXMgYW4gZW1wdHkgc2V0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb21wYXJhdG9yLiAqKVxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IgdGhhdCBjb250YWlucyBvbmx5IHRoZSBwcm92aWRlZFxuICAgICAgZWxlbWVudC4gKilcbiAgdmFsIHNpbmdsZXRvbiA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogUmV0dXJucyB0aGUgY2FyZGluYWxpdHkgb2YgdGhlIHNldC4gW08oMSldLiAqKVxuICB2YWwgbGVuZ3RoIDogKF8sIF8pIHQgLT4gaW50XG5cbiAgKCoqIFtpc19lbXB0eSB0XSBpcyBbdHJ1ZV0gaWZmIFt0XSBpcyBlbXB0eS4gIFtPKDEpXS4gKilcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuXG4gICgqKiBbbWVtIHQgYV0gcmV0dXJucyBbdHJ1ZV0gaWZmIFthXSBpcyBpbiBbdF0uICBbTyhsb2cgbildLiAqKVxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIC0+IGJvb2xcblxuICAoKiogW2FkZCB0IGFdIHJldHVybnMgYSBuZXcgc2V0IHdpdGggW2FdIGFkZGVkIHRvIFt0XSwgb3IgcmV0dXJucyBbdF0gaWYgW21lbSB0IGFdLlxuICAgICAgW08obG9nIG4pXS4gKilcbiAgdmFsIGFkZCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3JlbW92ZSB0IGFdIHJldHVybnMgYSBuZXcgc2V0IHdpdGggW2FdIHJlbW92ZWQgZnJvbSBbdF0gaWYgW21lbSB0IGFdLCBvciByZXR1cm5zIFt0XVxuICAgICAgb3RoZXJ3aXNlLiAgW08obG9nIG4pXS4gKilcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3VuaW9uIHQxIHQyXSByZXR1cm5zIHRoZSB1bmlvbiBvZiB0aGUgdHdvIHNldHMuICBbTyhsZW5ndGggdDEgKyBsZW5ndGggdDIpXS4gKilcbiAgdmFsIHVuaW9uIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3VuaW9uX2xpc3QgYyBsaXN0XSByZXR1cm5zIHRoZSB1bmlvbiBvZiBhbGwgdGhlIHNldHMgaW4gW2xpc3RdLiAgVGhlXG4gICAgICBbY29tcGFyYXRvcl0gYXJndW1lbnQgaXMgcmVxdWlyZWQgZm9yIHRoZSBjYXNlIHdoZXJlIFtsaXN0XSBpcyBlbXB0eS5cbiAgICAgIFtPKG1heChMaXN0Lmxlbmd0aCBsaXN0LCBuIGxvZyBuKSldLCB3aGVyZSBbbl0gaXMgdGhlIHN1bSBvZiBzaXplcyBvZiB0aGUgaW5wdXQgc2V0cy4gKilcbiAgdmFsIHVuaW9uX2xpc3QgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnY21wKSB0IGxpc3QgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtpbnRlciB0MSB0Ml0gY29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiBzZXRzIFt0MV0gYW5kIFt0Ml0uICBbTyhsZW5ndGggdDEgK1xuICAgICAgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCBpbnRlciA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtkaWZmIHQxIHQyXSBjb21wdXRlcyB0aGUgc2V0IGRpZmZlcmVuY2UgW3QxIC0gdDJdLCBpLmUuLCB0aGUgc2V0IGNvbnRhaW5pbmcgYWxsXG4gICAgICBlbGVtZW50cyBpbiBbdDFdIHRoYXQgYXJlIG5vdCBpbiBbdDJdLiAgW08obGVuZ3RoIHQxICsgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCBkaWZmIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3N5bW1ldHJpY19kaWZmIHQxIHQyXSByZXR1cm5zIGEgc2VxdWVuY2Ugb2YgY2hhbmdlcyBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0uIEl0IGlzXG4gICAgICBpbnRlbmRlZCB0byBiZSBlZmZpY2llbnQgaW4gdGhlIGNhc2Ugd2hlcmUgW3QxXSBhbmQgW3QyXSBzaGFyZSBhIGxhcmdlIGFtb3VudCBvZlxuICAgICAgc3RydWN0dXJlLiAqKVxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2EpIEVpdGhlci50IFNlcXVlbmNlLnRcblxuICAoKiogW2NvbXBhcmVfZGlyZWN0IHQxIHQyXSBjb21wYXJlcyB0aGUgc2V0cyBbdDFdIGFuZCBbdDJdLiAgSXQgcmV0dXJucyB0aGUgc2FtZSByZXN1bHRcbiAgICAgIGFzIFtjb21wYXJlXSwgYnV0IHVubGlrZSBjb21wYXJlLCBkb2Vzbid0IHJlcXVpcmUgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCBpbiBmb3IgdGhlXG4gICAgICB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIHNldC4gIFtPKGxlbmd0aCB0MSArIGxlbmd0aCB0MildLiAqKVxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGludFxuXG4gICgqKiBIYXNoIGZ1bmN0aW9uOiBhIGJ1aWxkaW5nIGJsb2NrIHRvIHVzZSB3aGVuIGhhc2hpbmcgZGF0YSBzdHJ1Y3R1cmVzIGNvbnRhaW5pbmcgc2V0cyBpblxuICAgICAgdGhlbS4gW2hhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleV0gaXMgY29tcGF0aWJsZSB3aXRoIFtjb21wYXJlX2RpcmVjdF0gaWZmXG4gICAgICBbaGFzaF9mb2xkX2tleV0gaXMgY29tcGF0aWJsZSB3aXRoIFsoY29tcGFyYXRvciBzKS5jb21wYXJlXSBvZiB0aGUgc2V0IFtzXSBiZWluZ1xuICAgICAgaGFzaGVkLiAqKVxuICB2YWwgaGFzaF9mb2xkX2RpcmVjdCA6ICdhIEhhc2guZm9sZGVyIC0+ICgnYSwgJ2NtcCkgdCBIYXNoLmZvbGRlclxuXG4gICgqKiBbZXF1YWwgdDEgdDJdIHJldHVybnMgW3RydWVdIGlmZiB0aGUgdHdvIHNldHMgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cy4gIFtPKGxlbmd0aCB0MSArXG4gICAgICBsZW5ndGggdDIpXSAqKVxuICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogW2V4aXN0cyB0IH5mXSByZXR1cm5zIFt0cnVlXSBpZmYgdGhlcmUgZXhpc3RzIGFuIFthXSBpbiBbdF0gZm9yIHdoaWNoIFtmIGFdLiAgW08obildLFxuICAgICAgYnV0IHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhbiBbYV0gZm9yIHdoaWNoIFtmIGFdLiAqKVxuICB2YWwgZXhpc3RzIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogW2Zvcl9hbGwgdCB+Zl0gcmV0dXJucyBbdHJ1ZV0gaWZmIGZvciBhbGwgW2FdIGluIFt0XSwgW2YgYV0uICBbTyhuKV0sIGJ1dCByZXR1cm5zIGFzXG4gICAgICBzb29uIGFzIGl0IGZpbmRzIGFuIFthXSBmb3Igd2hpY2ggW25vdCAoZiBhKV0uICopXG4gIHZhbCBmb3JfYWxsIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogW2NvdW50IHRdIHJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBbdF0gZm9yIHdoaWNoIFtmXSByZXR1cm5zIFt0cnVlXS5cbiAgICAgIFtPKG4pXS4gKilcbiAgdmFsIGNvdW50IDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBbc3VtIHRdIHJldHVybnMgdGhlIHN1bSBvZiBbZiB0XSBmb3IgZWFjaCBbdF0gaW4gdGhlIHNldC5cbiAgICAgIFtPKG4pXS4gKilcbiAgdmFsIHN1bVxuICAgIDogIChtb2R1bGUgQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSlcbiAgICAtPiAoJ2EsIF8pIHRcbiAgICAtPiBmOignYSAtPiAnc3VtKVxuICAgIC0+ICdzdW1cblxuICAoKiogW2ZpbmQgdCBmXSByZXR1cm5zIGFuIGVsZW1lbnQgb2YgW3RdIGZvciB3aGljaCBbZl0gcmV0dXJucyB0cnVlLCB3aXRoIG5vIGd1YXJhbnRlZSBhc1xuICAgICAgdG8gd2hpY2ggZWxlbWVudCBpcyByZXR1cm5lZC4gIFtPKG4pXSwgYnV0IHJldHVybnMgYXMgc29vbiBhcyBhIHN1aXRhYmxlIGVsZW1lbnQgaXNcbiAgICAgIGZvdW5kLiAqKVxuICB2YWwgZmluZCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cblxuICAoKiogW2ZpbmRfbWFwIHQgZl0gcmV0dXJucyBbYl0gZm9yIHNvbWUgW2FdIGluIFt0XSBmb3Igd2hpY2ggW2YgYSA9IFNvbWUgYl0uICBJZiBubyBzdWNoXG4gICAgICBbYV0gZXhpc3RzLCB0aGVuIFtmaW5kXSByZXR1cm5zIFtOb25lXS4gIFtPKG4pXSwgYnV0IHJldHVybnMgYXMgc29vbiBhcyBhIHN1aXRhYmxlXG4gICAgICBlbGVtZW50IGlzIGZvdW5kLiAqKVxuICB2YWwgZmluZF9tYXAgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cblxuICAoKiogTGlrZSBbZmluZF0sIGJ1dCB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIGZhaWx1cmUuICopXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYVxuXG4gICgqKiBbbnRoIHQgaV0gcmV0dXJucyB0aGUgW2lddGggc21hbGxlc3QgZWxlbWVudCBvZiBbdF0sIGluIFtPKGxvZyBuKV0gdGltZS4gIFRoZVxuICAgICAgc21hbGxlc3QgZWxlbWVudCBoYXMgW2kgPSAwXS4gIFJldHVybnMgW05vbmVdIGlmIFtpIDwgMF0gb3IgW2kgPj0gbGVuZ3RoIHRdLiAqKVxuICB2YWwgbnRoIDogKCdhLCBfKSB0IC0+IGludCAtPiAnYSBvcHRpb25cblxuICAoKiogW3JlbW92ZV9pbmRleCB0IGldIHJldHVybnMgYSB2ZXJzaW9uIG9mIFt0XSB3aXRoIHRoZSBbaV10aCBzbWFsbGVzdCBlbGVtZW50IHJlbW92ZWQsXG4gICAgICBpbiBbTyhsb2cgbildIHRpbWUuICBUaGUgc21hbGxlc3QgZWxlbWVudCBoYXMgW2kgPSAwXS4gIFJldHVybnMgW3RdIGlmIFtpIDwgMF0gb3JcbiAgICAgIFtpID49IGxlbmd0aCB0XS4gKilcbiAgdmFsIHJlbW92ZV9pbmRleCA6ICgnYSwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtpc19zdWJzZXQgdDEgfm9mXzp0Ml0gcmV0dXJucyB0cnVlIGlmZiBbdDFdIGlzIGEgc3Vic2V0IG9mIFt0Ml0uICopXG4gIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiBib29sXG5cbiAgKCoqIFthcmVfZGlzam9pbnQgdDEgdDJdIHJldHVybnMgW3RydWVdIGlmZiBbaXNfZW1wdHkgKGludGVyIHQxIHQyKV0sIGJ1dCBpcyBtb3JlXG4gICAgICBlZmZpY2llbnQuICopXG4gIHZhbCBhcmVfZGlzam9pbnQgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogW05hbWVkXSBhbGxvd3MgdGhlIHZhbGlkYXRpb24gb2Ygc3Vic2V0IGFuZCBlcXVhbGl0eSByZWxhdGlvbnNoaXBzIGJldHdlZW4gc2V0cy4gIEFcbiAgICAgIFtOYW1lZC50XSBpcyBhIHJlY29yZCBvZiBhIHNldCBhbmQgYSBuYW1lLCB3aGVyZSB0aGUgbmFtZSBpcyB1c2VkIGluIGVycm9yIG1lc3NhZ2VzLFxuICAgICAgYW5kIFtOYW1lZC5pc19zdWJzZXRdIGFuZCBbTmFtZWQuZXF1YWxdIHZhbGlkYXRlIHN1YnNldCBhbmQgZXF1YWxpdHkgcmVsYXRpb25zaGlwc1xuICAgICAgcmVzcGVjdGl2ZWx5LlxuXG4gICAgICBUaGUgZXJyb3IgbWVzc2FnZSBmb3IsIGUuZy4sXG4gICAgICB7W1xuICAgICAgICBOYW1lZC5pc19zdWJzZXQgeyBzZXQgPSBzZXQxOyBuYW1lID0gXCJzZXQxXCIgfSB+b2ZfOntzZXQgPSBzZXQyOyBuYW1lID0gXCJzZXQyXCIgfVxuICAgICAgXX1cblxuICAgICAgbG9va3MgbGlrZVxuICAgICAge3ZcbiAgICAgICAgKFwic2V0MSBpcyBub3QgYSBzdWJzZXQgb2Ygc2V0MlwiIChpbnZhbGlkX2VsZW1lbnRzICguLi5lbGVtZW50cyBvZiBzZXQxIC0gc2V0Mi4uLikpKVxuICAgICAgIHZ9XG5cbiAgICAgIHNvIFtuYW1lXSBzaG91bGQgYmUgYSBub3VuIHBocmFzZSB0aGF0IGRvZXNuJ3Qgc291bmQgYXdrd2FyZCBpbiB0aGUgYWJvdmUgZXJyb3JcbiAgICAgIG1lc3NhZ2UuICBFdmVuIHRob3VnaCBpdCBhZGRzIHZlcmJvc2l0eSwgY2hvb3NpbmcgW25hbWVdcyB0aGF0IHN0YXJ0IHdpdGggdGhlIHBocmFzZVxuICAgICAgXCJ0aGUgc2V0IG9mXCIgb2Z0ZW4gbWFrZXMgdGhlIGVycm9yIG1lc3NhZ2Ugc291bmQgbW9yZSBuYXR1cmFsLlxuICAqKVxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2NtcCkgc2V0IDo9ICgnYSwgJ2NtcCkgdFxuXG4gICAgdHlwZSAnYSB0ID0gJ2EgTmFtZWQudCA9XG4gICAgICB7IHNldCA6ICdhXG4gICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgIH1cblxuICAgICgqKiBbaXNfc3Vic2V0IHQxIH5vZl86dDJdIHJldHVybnMgW09rICgpXSBpZiBbdDFdIGlzIGEgc3Vic2V0IG9mIFt0Ml0gYW5kIGFcbiAgICAgICAgaHVtYW4tcmVhZGFibGUgZXJyb3Igb3RoZXJ3aXNlLiAgKilcbiAgICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wKSBzZXQgdCAtPiBvZl86KCdhLCAnY21wKSBzZXQgdCAtPiB1bml0IE9yX2Vycm9yLnRcblxuICAgICgqKiBbZXF1YWwgdDEgdDJdIHJldHVybnMgW09rICgpXSBpZiBbdDFdIGlzIGVxdWFsIHRvIFt0Ml0gYW5kIGEgaHVtYW4tcmVhZGFibGVcbiAgICAgICAgZXJyb3Igb3RoZXJ3aXNlLiAgKilcbiAgICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIHNldCB0IC0+ICgnYSwgJ2NtcCkgc2V0IHQgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gICgqKiBUaGUgbGlzdCBvciBhcnJheSBnaXZlbiB0byBbb2ZfbGlzdF0gYW5kIFtvZl9hcnJheV0gbmVlZCBub3QgYmUgc29ydGVkLiAqKVxuICB2YWwgb2ZfbGlzdCA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfYXJyYXkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgYXJyYXkgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFt0b19saXN0XSBhbmQgW3RvX2FycmF5XSBwcm9kdWNlIHNlcXVlbmNlcyBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGFjY29yZGluZyB0byB0aGVcbiAgICAgIGNvbXBhcmF0b3IuICopXG4gIHZhbCB0b19saXN0IDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcblxuICB2YWwgdG9fYXJyYXkgOiAoJ2EsIF8pIHQgLT4gJ2EgYXJyYXlcblxuICAoKiogQ3JlYXRlIHNldCBmcm9tIHNvcnRlZCBhcnJheS4gIFRoZSBpbnB1dCBtdXN0IGJlIHNvcnRlZCAoZWl0aGVyIGluIGFzY2VuZGluZyBvclxuICAgICAgZGVzY2VuZGluZyBvcmRlciBhcyBnaXZlbiBieSB0aGUgY29tcGFyYXRvcikgYW5kIGNvbnRhaW4gbm8gZHVwbGljYXRlcywgb3RoZXJ3aXNlIHRoZVxuICAgICAgcmVzdWx0IGlzIGFuIGVycm9yLiAgVGhlIGNvbXBsZXhpdHkgb2YgdGhpcyBmdW5jdGlvbiBpcyBbTyhuKV0uICopXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAnYSBhcnJheVxuICAgIC0+ICgnYSwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIFNpbWlsYXIgdG8gW29mX3NvcnRlZF9hcnJheV0sIGJ1dCB3aXRob3V0IGNoZWNraW5nIHRoZSBpbnB1dCBhcnJheS4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAnYSBhcnJheVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgYyB+bGVuIH5mXSBiZWhhdmVzIGxpa2UgW29mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgY1xuICAgICAgKEFycmF5LmluaXQgbGVuIH5mKV0sIHdpdGggdGhlIGFkZGl0aW9uYWwgcmVzdHJpY3Rpb24gdGhhdCBhIGRlY3JlYXNpbmcgb3JkZXIgaXMgbm90XG4gICAgICBzdXBwb3J0ZWQuICBUaGUgYWR2YW50YWdlIGlzIG5vdCByZXF1aXJpbmcgeW91IHRvIGFsbG9jYXRlIGFuIGludGVybWVkaWF0ZSBhcnJheS4gIFtmXVxuICAgICAgd2lsbCBiZSBjYWxsZWQgd2l0aCAwLCAxLCAuLi4gW2xlbiAtIDFdLCBpbiBvcmRlci4gKilcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IGY6KGludCAtPiAnYSlcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3N0YWJsZV9kZWR1cF9saXN0XSBpcyBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBbTGlzdF0gbW9kdWxlIGJlY2F1c2UgdGhlXG4gICAgICBpbXBsZW1lbnRhdGlvbiByZWxpZXMgY3J1Y2lhbGx5IG9uIHNldHMsIGFuZCBiZWNhdXNlIGRvaW5nIHNvIGFsbG93cyBvbmUgdG8gYXZvaWQgdXNlc1xuICAgICAgb2YgcG9seW1vcnBoaWMgY29tcGFyaXNvbiBieSBpbnN0YW50aWF0aW5nIHRoZSBmdW5jdG9yIGF0IGEgZGlmZmVyZW50IGltcGxlbWVudGF0aW9uXG4gICAgICBvZiBbQ29tcGFyYXRvcl0gYW5kIHVzaW5nIHRoZSByZXN1bHRpbmcgW3N0YWJsZV9kZWR1cF9saXN0XS4gKilcbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogKCdhLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIGxpc3QgLT4gJ2EgbGlzdFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAyMy0wNF0gVXNlIFtMaXN0LnN0YWJsZV9kZWR1cF0gaW5zdGVhZC5cIl1cblxuICAoKiogW21hcCBjIHQgfmZdIHJldHVybnMgYSBuZXcgc2V0IGNyZWF0ZWQgYnkgYXBwbHlpbmcgW2ZdIHRvIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICAgIFt0XS4gIFRoZSByZXR1cm5lZCBzZXQgaXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIFtjb21wYXJhdG9yXS4gIFtPKG4gbG9nIG4pXS4gKilcbiAgdmFsIG1hcCA6ICgnYiwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIHshbWFwfSwgZXhjZXB0IGVsZW1lbnRzIGZvciB3aGljaCBbZl0gcmV0dXJucyBbTm9uZV0gd2lsbCBiZSBkcm9wcGVkLiAgKilcbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICAoJ2IsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EsIF8pIHRcbiAgICAtPiBmOignYSAtPiAnYiBvcHRpb24pXG4gICAgLT4gKCdiLCAnY21wKSB0XG5cbiAgKCoqIFtmaWx0ZXIgdCB+Zl0gcmV0dXJucyB0aGUgc3Vic2V0IG9mIFt0XSBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAgW08obiBsb2dcbiAgICAgIG4pXS4gKilcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2NtcCkgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gZm9sZHMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHNldCBmcm9tIHNtYWxsZXN0IHRvIGxhcmdlc3QuICopXG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+ICdhIC0+ICdhY2MpIC0+ICdhY2NcblxuICAoKiogW2ZvbGRfcmVzdWx0IH5pbml0IH5mXSBmb2xkcyBvdmVyIHRoZSBlbGVtZW50cyBvZiB0aGUgc2V0IGZyb20gc21hbGxlc3QgdG9cbiAgICAgIGxhcmdlc3QsIHNob3J0IGNpcmN1aXRpbmcgdGhlIGZvbGQgaWYgW2YgYWNjdW0geF0gaXMgYW4gW0Vycm9yIF9dICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gJ2EgLT4gKCdhY2MsICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjYywgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gJ2EgLT4gKCdhY2MsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBMaWtlIHshZm9sZH0sIGV4Y2VwdCB0aGF0IGl0IGdvZXMgZnJvbSB0aGUgbGFyZ2VzdCB0byB0aGUgc21hbGxlc3QgZWxlbWVudC4gKilcbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhIC0+ICdhY2MgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICgqKiBbaXRlciB0IH5mXSBjYWxscyBbZl0gb24gZXZlcnkgZWxlbWVudCBvZiBbdF0sIGdvaW5nIGluIG9yZGVyIGZyb20gdGhlIHNtYWxsZXN0IHRvXG4gICAgICBsYXJnZXN0LiAgKilcbiAgdmFsIGl0ZXIgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBJdGVyYXRlIHR3byBzZXRzIHNpZGUgYnkgc2lkZS4gIENvbXBsZXhpdHkgaXMgW08obStuKV0gd2hlcmUgW21dIGFuZCBbbl0gYXJlIHRoZSBzaXplc1xuICAgICAgb2YgdGhlIHR3byBpbnB1dCBzZXRzLiAgQXMgYW4gZXhhbXBsZSwgd2l0aCB0aGUgaW5wdXRzIFswOyAxXSBhbmQgWzE7IDJdLCBbZl0gd2lsbCBiZVxuICAgICAgY2FsbGVkIHdpdGggW2BMZWZ0IDBdOyBbYEJvdGggKDEsIDEpXTsgYW5kIFtgUmlnaHQgMl0uICopXG4gIHZhbCBpdGVyMlxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2EgfCBgQm90aCBvZiAnYSAqICdhIF0gLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgKCoqIGlmIFthLCBiID0gcGFydGl0aW9uX3RmIHNldCB+Zl0gdGhlbiBbYV0gaXMgdGhlIGVsZW1lbnRzIG9uIHdoaWNoIFtmXSBwcm9kdWNlZCBbdHJ1ZV0sXG4gICAgICBhbmQgW2JdIGlzIHRoZSBlbGVtZW50cyBvbiB3aGljaCBbZl0gcHJvZHVjZXMgW2ZhbHNlXS4gKilcbiAgdmFsIHBhcnRpdGlvbl90ZiA6ICgnYSwgJ2NtcCkgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHRcblxuICAoKiogU2FtZSBhcyB7IXRvX2xpc3R9LiAqKVxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBzZXQuICBbTyhsb2cgbildLiAqKVxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cblxuICAoKiogTGlrZSB7IW1pbl9lbHR9LCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGdpdmVuIGFuIGVtcHR5IHNldC4gKilcbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgKCoqIFJldHVybnMgdGhlIGxhcmdlc3QgZWxlbWVudCBvZiB0aGUgc2V0LiAgW08obG9nIG4pXS4gICopXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuXG4gICgqKiBMaWtlIHshbWF4X2VsdH0sIGJ1dCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gZ2l2ZW4gYW4gZW1wdHkgc2V0LiAqKVxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcblxuICAoKiogcmV0dXJucyBhbiBhcmJpdHJhcnkgZWxlbWVudCwgb3IgW05vbmVdIGlmIHRoZSBzZXQgaXMgZW1wdHkuICopXG4gIHZhbCBjaG9vc2UgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIExpa2UgeyFjaG9vc2V9LCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiBhbiBlbXB0eSBzZXQuICopXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgKCoqIFtzcGxpdCB0IHhdIHByb2R1Y2VzIGEgdHJpcGxlIFsodDEsIG1heWJlX3gsIHQyKV0uXG5cbiAgICAgIFt0MV0gaXMgdGhlIHNldCBvZiBlbGVtZW50cyBzdHJpY3RseSBsZXNzIHRoYW4gW3hdLFxuICAgICAgW21heWJlX3hdIGlzIHRoZSBtZW1iZXIgKGlmIGFueSkgb2YgW3RdIHdoaWNoIGNvbXBhcmVzIGVxdWFsIHRvIFt4XSxcbiAgICAgIFt0Ml0gaXMgdGhlIHNldCBvZiBlbGVtZW50cyBzdHJpY3RseSBsYXJnZXIgdGhhbiBbeF0uICopXG4gIHZhbCBzcGxpdCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHQgKiAnYSBvcHRpb24gKiAoJ2EsICdjbXApIHRcblxuICAoKiogW3NwbGl0X2xlX2d0IHQgeF0gcHJvZHVjZXMgYSBwYWlyIFsodDEsIHQyKV0uXG5cbiAgICAgIFt0MV0gaXMgdGhlIHNldCBvZiBlbGVtZW50cyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gW3hdLFxuICAgICAgW3QyXSBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiBbeF0uICopXG4gIHZhbCBzcGxpdF9sZV9ndCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHRcblxuICAoKiogW3NwbGl0X2x0X2dlIHQgeF0gcHJvZHVjZXMgYSBwYWlyIFsodDEsIHQyKV0uXG5cbiAgICAgIFt0MV0gaXMgdGhlIHNldCBvZiBlbGVtZW50cyBzdHJpY3RseSBsZXNzIHRoYW4gW3hdLFxuICAgICAgW3QyXSBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBbeF0uICopXG4gIHZhbCBzcGxpdF9sdF9nZSA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHRcblxuICAoKiogaWYgW2VxdWl2XSBpcyBhbiBlcXVpdmFsZW5jZSBwcmVkaWNhdGUsIHRoZW4gW2dyb3VwX2J5IHNldCB+ZXF1aXZdIHByb2R1Y2VzIGEgbGlzdFxuICAgICAgb2YgZXF1aXZhbGVuY2UgY2xhc3NlcyAoaS5lLiwgYSBzZXQtdGhlb3JldGljIHF1b3RpZW50KS4gIEUuZy4sXG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBjaGFycyA9IFNldC5vZl9saXN0IFsnQSc7ICdhJzsgJ2InOyAnYyddIGluXG4gICAgICAgIGxldCBlcXVpdiBjIGMnID0gQ2hhci5lcXVhbCAoQ2hhci51cHBlcmNhc2UgYykgKENoYXIudXBwZXJjYXNlIGMnKSBpblxuICAgICAgICBncm91cF9ieSBjaGFycyB+ZXF1aXZcbiAgICAgIF19XG5cbiAgICAgIHByb2R1Y2VzOlxuXG4gICAgICB7W1xuICAgICAgICBbU2V0Lm9mX2xpc3QgWydBJzsnYSddOyBTZXQuc2luZ2xldG9uICdiJzsgU2V0LnNpbmdsZXRvbiAnYyddXG4gICAgICBdfVxuXG4gICAgICBbZ3JvdXBfYnldIHJ1bnMgaW4gTyhuXjIpIHRpbWUsIHNvIGlmIHlvdSBoYXZlIGEgY29tcGFyaXNvbiBmdW5jdGlvbiwgaXQncyB1c3VhbGx5XG4gICAgICBtdWNoIGZhc3RlciB0byB1c2UgW1NldC5vZl9saXN0XS4gKilcbiAgdmFsIGdyb3VwX2J5IDogKCdhLCAnY21wKSB0IC0+IGVxdWl2OignYSAtPiAnYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgbGlzdFxuXG4gICgqKiBbdG9fc2VxdWVuY2UgdF0gY29udmVydHMgdGhlIHNldCBbdF0gdG8gYSBzZXF1ZW5jZSBvZiB0aGUgZWxlbWVudHMgYmV0d2VlblxuICAgICAgW2dyZWF0ZXJfb3JfZXF1YWxfdG9dIGFuZCBbbGVzc19vcl9lcXVhbF90b10gaW5jbHVzaXZlIGluIHRoZSBvcmRlciBpbmRpY2F0ZWQgYnlcbiAgICAgIFtvcmRlcl0uICBJZiBbZ3JlYXRlcl9vcl9lcXVhbF90byA+IGxlc3Nfb3JfZXF1YWxfdG9dIHRoZSBzZXF1ZW5jZSBpcyBlbXB0eS4gIENvc3QgaXNcbiAgICAgIE8obG9nIG4pIHVwIGZyb250IGFuZCBhbW9ydGl6ZWQgTygxKSBmb3IgZWFjaCBlbGVtZW50IHByb2R1Y2VkLiAqKVxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyAoKiogZGVmYXVsdCAqKSB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gJ2EgU2VxdWVuY2UudFxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIHdoaWNoIGVsdF0gcmV0dXJucyB0aGUgZWxlbWVudCBpbiBbdF0gc3BlY2lmaWVkIGJ5XG4gICAgICBbY29tcGFyZV0gYW5kIFt3aGljaF0sIGlmIG9uZSBleGlzdHMuXG5cbiAgICAgIFt0XSBtdXN0IGJlIHNvcnRlZCBpbiBpbmNyZWFzaW5nIG9yZGVyIGFjY29yZGluZyB0byBbY29tcGFyZV0sIHdoZXJlIFtjb21wYXJlXSBhbmRcbiAgICAgIFtlbHRdIGRpdmlkZSBbdF0gaW50byB0aHJlZSAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8ICA8IGVsdCAgfCAgPSBlbHQgIHwgID4gZWx0ICB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gcmV0dXJucyBhbiBlbGVtZW50IG9uIHRoZSBib3VuZGFyeSBvZiBzZWdtZW50cyBhcyBzcGVjaWZpZWQgYnlcbiAgICAgIFt3aGljaF0uICBTZWUgdGhlIGRpYWdyYW0gYmVsb3cgbmV4dCB0byB0aGUgW3doaWNoXSB2YXJpYW50cy5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIGRvZXMgbm90IGNoZWNrIHRoYXQgW2NvbXBhcmVdIG9yZGVycyBbdF0sIGFuZCBiZWhhdmlvciBpc1xuICAgICAgdW5zcGVjaWZpZWQgaWYgW2NvbXBhcmVdIGRvZXNuJ3Qgb3JkZXIgW3RdLiAgQmVoYXZpb3IgaXMgYWxzbyB1bnNwZWNpZmllZCBpZlxuICAgICAgW2NvbXBhcmVdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuICgqKiAgICAgICAge3YgfCA8IGVsdCBYIHwgICAgICAgICAgICAgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gKCoqICAgICB7diB8ICAgICAgPD0gZWx0ICAgICAgIFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8ICAgPSBlbHQgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgWCA9IGVsdCAgIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvICgqKiB7diAgICAgICAgICAgfCBYICAgICAgID49IGVsdCAgICAgIHwgdn0gKilcbiAgICAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gKCoqICAgIHt2ICAgICAgICAgICAgICAgICAgICAgICB8IFggPiBlbHQgfCB2fSAqKVxuICAgICAgIF1cbiAgICAtPiAna2V5XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIHdoaWNoXSB0YWtlcyBhIFtzZWdtZW50X29mXSBmdW5jdGlvbiB0aGF0XG4gICAgICBkaXZpZGVzIFt0XSBpbnRvIHR3byAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8IHNlZ21lbnRfb2YgZWx0ID0gYExlZnQgfCBzZWdtZW50X29mIGVsdCA9IGBSaWdodCB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIHJldHVybnMgdGhlIGVsZW1lbnQgb24gdGhlIGJvdW5kYXJ5IG9mIHRoZSBzZWdtZW50cyBhc1xuICAgICAgc3BlY2lmaWVkIGJ5IFt3aGljaF06IFtgTGFzdF9vbl9sZWZ0XSB5aWVsZHMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbGVmdCBzZWdtZW50LFxuICAgICAgd2hpbGUgW2BGaXJzdF9vbl9yaWdodF0geWllbGRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSByaWdodCBzZWdtZW50LiAgSXQgcmV0dXJuc1xuICAgICAgW05vbmVdIGlmIHRoZSBzZWdtZW50IGlzIGVtcHR5LlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIGRvZXMgbm90IGNoZWNrIHRoYXQgW3NlZ21lbnRfb2ZdIHNlZ21lbnRzIFt0XSBhcyBpbiB0aGVcbiAgICAgIGRpYWdyYW0sIGFuZCBiZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gZG9lc24ndCBzZWdtZW50IFt0XS4gIEJlaGF2aW9yXG4gICAgICBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooJ2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IFsgYExhc3Rfb25fbGVmdCB8IGBGaXJzdF9vbl9yaWdodCBdXG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFByb2R1Y2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgdHdvIHNldHMgYmV0d2VlbiBbZ3JlYXRlcl9vcl9lcXVhbF90b10gYW5kXG4gICAgICBbbGVzc19vcl9lcXVhbF90b10gaW4gW29yZGVyXSwgbm90aW5nIHdoZXRoZXIgZWFjaCBlbGVtZW50IGFwcGVhcnMgaW4gdGhlIGxlZnQgc2V0LFxuICAgICAgdGhlIHJpZ2h0IHNldCwgb3IgYm90aC4gIEluIHRoZSBib3RoIGNhc2UsIGJvdGggZWxlbWVudHMgYXJlIHJldHVybmVkLCBpbiBjYXNlIHRoZVxuICAgICAgY2FsbGVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuIGVsZW1lbnRzIHRoYXQgYXJlIGVxdWFsIHRvIHRoZSBzZXRzJyBjb21wYXJhdG9yLiAgUnVuc1xuICAgICAgaW4gTyhsZW5ndGggdCArIGxlbmd0aCB0JykuICopXG4gIG1vZHVsZSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgU2VxdWVuY2UuTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnQudCA9XG4gICAgICB8IExlZnQgb2YgJ2FcbiAgICAgIHwgUmlnaHQgb2YgJ2JcbiAgICAgIHwgQm90aCBvZiAnYSAqICdiXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nICgqKiBkZWZhdWx0ICopIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdhKSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gICgqKiBbTV0gaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIE9DYW1sIGFwcGxpY2F0aXZlIGZ1bmN0b3IgdHlwZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3NldCA9IFNldC5NKFN0cmluZykudFxuICAgICAgXX1cblxuICAgICAgd2hpY2ggc3RhbmRzIGZvcjpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfc2V0ID0gKFN0cmluZy50LCBTdHJpbmcuY29tcGFyYXRvcl93aXRuZXNzKSBTZXQudFxuICAgICAgXX1cblxuICAgICAgVGhlIHBvaW50IGlzIHRoYXQgW1NldC5NKFN0cmluZykudF0gc3VwcG9ydHMgZGVyaXZpbmcsIHdoZXJlYXMgdGhlIHNlY29uZCBzeW50YXhcbiAgICAgIGRvZXNuJ3QgKGJlY2F1c2UgdGhlcmUgaXMgbm8gc3VjaCB0aGluZyBhcywgc2F5LCBTdHJpbmcuc2V4cF9vZl9jb21wYXJhdG9yX3dpdG5lc3MsXG4gICAgICBpbnN0ZWFkIHlvdSB3b3VsZCB3YW50IHRvIHBhc3MgdGhlIGNvbXBhcmF0b3IgZGlyZWN0bHkpLiAqKVxuICBtb2R1bGUgTSAoRWx0IDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgZW5kKSA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjIHQgPSAoRWx0LnQsIEVsdC5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBGb3JfZGVyaXZpbmcgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICgqKiBVc2luZyBjb21wYXJhdG9yIGlzIGEgc2ltaWxhciBpbnRlcmZhY2UgYXMgdGhlIHRvcGxldmVsIG9mIFtTZXRdLCBleGNlcHQgdGhlIGZ1bmN0aW9uc1xuICAgICAgdGFrZSBhIFt+Y29tcGFyYXRvcjooJ2VsdCwgJ2NtcCkgQ29tcGFyYXRvci50XSB3aGVyZSB0aGUgZnVuY3Rpb25zIGF0IHRoZSB0b3BsZXZlbCBvZlxuICAgICAgW1NldF0gdGFrZXMgYSBbKCdlbHQsICdjbXApIGNvbXBhcmF0b3JdLiAqKVxuICBtb2R1bGUgVXNpbmdfY29tcGFyYXRvciA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSB0ID0gKCdlbHQsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2VsdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgIDogIGNvbXBhcmF0b3I6KCdlbHQsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKFNleHAudCAtPiAnZWx0KVxuICAgICAgLT4gU2V4cC50XG4gICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gICAgbW9kdWxlIFRyZWUgOiBzaWdcbiAgICAgICgqKiBBIFtUcmVlLnRdIGNvbnRhaW5zIGp1c3QgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBhIHNldCBpcyBiYXNlZCBvbiwgd2l0aG91dFxuICAgICAgICAgIGluY2x1ZGluZyB0aGUgY29tcGFyYXRvci4gIEFjY29yZGluZ2x5LCBhbnkgb3BlcmF0aW9uIG9uIGEgW1RyZWUudF0gbXVzdCBhbHNvIHRha2VcbiAgICAgICAgICBhcyBhbiBhcmd1bWVudCB0aGUgY29ycmVzcG9uZGluZyBjb21wYXJhdG9yLiAqKVxuICAgICAgdHlwZSAoJ2EsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICAgIHZhbCBzZXhwX29mX3RcbiAgICAgICAgOiAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICAgIDogIGNvbXBhcmF0b3I6KCdlbHQsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAtPiAoU2V4cC50IC0+ICdlbHQpXG4gICAgICAgIC0+IFNleHAudFxuICAgICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gICAgICBpbmNsdWRlXG4gICAgICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSBzZXQgOj0gKCdhLCAnYikgdFxuICAgICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSB0XG4gICAgICAgICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYVxuICAgICAgICAgIHdpdGggdHlwZSAnYyBjbXAgOj0gJ2NcbiAgICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGNyZWF0ZV9vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBXaXRoX2NvbXBhcmF0b3IudFxuICAgICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIFdpdGhfY29tcGFyYXRvci50XG5cbiAgICAgIHZhbCBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIDogKF8sIF8pIHRcbiAgICBlbmRcblxuICAgIGluY2x1ZGVcbiAgICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIFRyZWUudFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgc2V0IDo9ICgnYSwgJ2IpIHRcbiAgICAgICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYVxuICAgICAgICB3aXRoIHR5cGUgJ2MgY21wIDo9ICdjXG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIFdpdGhvdXRfY29tcGFyYXRvci50XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgY3JlYXRlX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIFdpdGhfY29tcGFyYXRvci50XG5cbiAgICB2YWwgY29tcGFyYXRvcl9zIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIHZhbCBjb21wYXJhdG9yIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnZWx0IEhhc2guZm9sZGVyIC0+ICgnZWx0LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoRWx0IDogQ29tcGFyYXRvci5TMSkgOiBzaWdcbiAgICAgIHZhbCBlbXB0eSA6ICgnYSBFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZFxuICBlbmRcblxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG5cbiAgdmFsIG9mX3RyZWVcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIEEgcG9seW1vcnBoaWMgU2V0LiAqKVxuICBtb2R1bGUgUG9seSA6XG4gICAgU19wb2x5XG4gICAgICB3aXRoIHR5cGUgJ2VsdCB0ID0gKCdlbHQsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICAgIHdpdGggdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgOj0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgICAgd2l0aCB0eXBlICdlbHQgdHJlZSA6PVxuICAgICAgICAoJ2VsdCwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcbiAgICAgIHdpdGggdHlwZSAoJ2VsdCwgJ2NtcCkgc2V0IDo9ICgnZWx0LCAnY21wKSB0XG5cbiAgKCoqIHsyIE1vZHVsZXMgYW5kIG1vZHVsZSB0eXBlcyBmb3IgZXh0ZW5kaW5nIFtTZXRdfVxuXG4gICAgICBGb3IgdXNlIGluIGV4dGVuc2lvbnMgb2YgQmFzZSwgbGlrZSBbQ29yZV0uICopXG5cbiAgbW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IFdpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgV2l0aF9maXJzdF9jbGFzc19tb2R1bGUgPSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZVxuICBtb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gV2l0aG91dF9jb21wYXJhdG9yXG5cbiAgbW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gRm9yX2Rlcml2aW5nXG4gIG1vZHVsZSB0eXBlIFNfcG9seSA9IFNfcG9seVxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IEFjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBFbHRfcGxhaW4gPSBFbHRfcGxhaW5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqKVxuKCogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqKVxuKCogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIDIuMCBsaWNlbnNlLiBTZWUgLi4vVEhJUkQtUEFSVFkudHh0ICAqKVxuKCogIGZvciBkZXRhaWxzLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTZXRzIG92ZXIgb3JkZXJlZCB0eXBlcyAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgU2V0X2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxubW9kdWxlIFRyZWUwID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBFbXB0eVxuICAgICgqIExlYWYgaXMgdGhlIHNhbWUgYXMgTm9kZSB3aXRoIGVtcHR5IGNoaWxkcmVuIGJ1dCB1c2VzIGxlc3Mgc3BhY2UuICopXG4gICAgfCBMZWFmIG9mIHsgZWx0IDogJ2EgfVxuICAgIHwgTm9kZSBvZlxuICAgICAgICB7IGxlZnQgOiAnYSB0XG4gICAgICAgIDsgZWx0IDogJ2FcbiAgICAgICAgOyByaWdodCA6ICdhIHRcbiAgICAgICAgOyBoZWlnaHQgOiBpbnRcbiAgICAgICAgOyBzaXplIDogaW50XG4gICAgICAgIH1cblxuICB0eXBlICdhIHRyZWUgPSAnYSB0XG5cbiAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGUgY2hpbGRyZW4gZGlmZmVyIGJ5XG4gICAgIGF0IG1vc3QgMi4gKilcbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBoZWlnaHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiB7IGVsdCA9IF8gfSAtPiAxXG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGVsdCA9IF87IHJpZ2h0ID0gXzsgaGVpZ2h0ID0gaDsgc2l6ZSA9IF8gfSAtPiBoXG4gIDs7XG5cbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBsZW5ndGggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiB7IGVsdCA9IF8gfSAtPiAxXG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGVsdCA9IF87IHJpZ2h0ID0gXzsgaGVpZ2h0ID0gXzsgc2l6ZSA9IHMgfSAtPiBzXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudHMgPVxuICAgIGxldCBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2VsdCB2ID1cbiAgICAgIChtYXRjaCBsb3dlciB3aXRoXG4gICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICB8IFNvbWUgbG93ZXIgLT4gY29tcGFyZV9lbHQgbG93ZXIgdiA8IDApXG4gICAgICAmJlxuICAgICAgbWF0Y2ggdXBwZXIgd2l0aFxuICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgIHwgU29tZSB1cHBlciAtPiBjb21wYXJlX2VsdCB2IHVwcGVyIDwgMFxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2VsdCB2XG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBoOyBzaXplID0gbiB9IC0+XG4gICAgICAgIGxldCBobCA9IGhlaWdodCBsXG4gICAgICAgIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICAgIGFicyAoaGwgLSBocikgPD0gMlxuICAgICAgICAmJiBoID0gbWF4IGhsIGhyICsgMVxuICAgICAgICAmJiBuID0gbGVuZ3RoIGwgKyBsZW5ndGggciArIDFcbiAgICAgICAgJiYgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdlxuICAgICAgICAmJiBsb29wIGxvd2VyIChTb21lIHYpIGNvbXBhcmVfZWx0IGxcbiAgICAgICAgJiYgbG9vcCAoU29tZSB2KSB1cHBlciBjb21wYXJlX2VsdCByXG4gICAgaW5cbiAgICBmdW4gdCB+Y29tcGFyZV9lbHQgLT4gbG9vcCBOb25lIE5vbmUgY29tcGFyZV9lbHQgdFxuICA7O1xuXG4gIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgfCBMZWFmIHsgZWx0ID0gXyB9IHwgTm9kZSBfIC0+IGZhbHNlXG4gIDs7XG5cbiAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gIGxldFtAaW5saW5lIGFsd2F5c10gY3JlYXRlIGwgdiByID1cbiAgICBsZXQgaGwgPSAoaGVpZ2h0IFtAaW5saW5lZF0pIGwgaW5cbiAgICBsZXQgaHIgPSAoaGVpZ2h0IFtAaW5saW5lZF0pIHIgaW5cbiAgICBsZXQgaCA9IGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxIGluXG4gICAgaWYgaCA9IDFcbiAgICB0aGVuIExlYWYgeyBlbHQgPSB2IH1cbiAgICBlbHNlIChcbiAgICAgIGxldCBzbCA9IChsZW5ndGggW0BpbmxpbmVkXSkgbCBpblxuICAgICAgbGV0IHNyID0gKGxlbmd0aCBbQGlubGluZWRdKSByIGluXG4gICAgICBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaDsgc2l6ZSA9IHNsICsgc3IgKyAxIH0pXG4gIDs7XG5cbiAgKCogV2UgbXVzdCBjYWxsIFtmXSB3aXRoIGluY3JlYXNpbmcgaW5kZXhlcywgYmVjYXVzZSB0aGUgYmluX3Byb3QgcmVhZGVyIGluXG4gICAgIENvcmUuU2V0IG5lZWRzIGl0LiAqKVxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgbGV0IHJlYyBsb29wIG4gfmYgaSA9XG4gICAgICBtYXRjaCBuIHdpdGhcbiAgICAgIHwgMCAtPiBFbXB0eVxuICAgICAgfCAxIC0+XG4gICAgICAgIGxldCBrID0gZiBpIGluXG4gICAgICAgIExlYWYgeyBlbHQgPSBrIH1cbiAgICAgIHwgMiAtPlxuICAgICAgICBsZXQga2wgPSBmIGkgaW5cbiAgICAgICAgbGV0IGsgPSBmIChpICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIChMZWFmIHsgZWx0ID0ga2wgfSkgayBFbXB0eVxuICAgICAgfCAzIC0+XG4gICAgICAgIGxldCBrbCA9IGYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyAxKSBpblxuICAgICAgICBsZXQga3IgPSBmIChpICsgMikgaW5cbiAgICAgICAgY3JlYXRlIChMZWFmIHsgZWx0ID0ga2wgfSkgayAoTGVhZiB7IGVsdCA9IGtyIH0pXG4gICAgICB8IG4gLT5cbiAgICAgICAgbGV0IGxlZnRfbGVuZ3RoID0gbiBsc3IgMSBpblxuICAgICAgICBsZXQgcmlnaHRfbGVuZ3RoID0gbiAtIGxlZnRfbGVuZ3RoIC0gMSBpblxuICAgICAgICBsZXQgbGVmdCA9IGxvb3AgbGVmdF9sZW5ndGggfmYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyBsZWZ0X2xlbmd0aCkgaW5cbiAgICAgICAgbGV0IHJpZ2h0ID0gbG9vcCByaWdodF9sZW5ndGggfmYgKGkgKyBsZWZ0X2xlbmd0aCArIDEpIGluXG4gICAgICAgIGNyZWF0ZSBsZWZ0IGsgcmlnaHRcbiAgICBpblxuICAgIGxvb3AgbGVuIH5mIDBcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCBhcnJheV9sZW5ndGggPSBBcnJheS5sZW5ndGggYXJyYXkgaW5cbiAgICBsZXQgbmV4dCA9XG4gICAgICAoKiBXZSBkb24ndCBjaGVjayBpZiB0aGUgYXJyYXkgaXMgc29ydGVkIG9yIGtleXMgYXJlIGR1cGxpY2F0ZWQsIGJlY2F1c2UgdGhhdFxuICAgICAgICAgY2hlY2tpbmcgaXMgc2xvd2VyIHRoYW4gdGhlIHdob2xlIFtvZl9zb3J0ZWRfYXJyYXldIGZ1bmN0aW9uICopXG4gICAgICBpZiBhcnJheV9sZW5ndGggPCAyIHx8IGNvbXBhcmVfZWx0IGFycmF5LigwKSBhcnJheS4oMSkgPCAwXG4gICAgICB0aGVuIGZ1biBpIC0+IGFycmF5LihpKVxuICAgICAgZWxzZSBmdW4gaSAtPiBhcnJheS4oYXJyYXlfbGVuZ3RoIC0gMSAtIGkpXG4gICAgaW5cbiAgICBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuOmFycmF5X2xlbmd0aCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIGFycmF5IHdpdGhcbiAgICB8IFt8fF0gfCBbfCBfIHxdIC0+IFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQpXG4gICAgfCBfIC0+XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IGluY3JlYXNpbmcgPVxuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfZWx0IGFycmF5LigwKSBhcnJheS4oMSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+IGkgPCAwXG4gICAgICAgIGluXG4gICAgICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAyIGRvXG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9lbHQgYXJyYXkuKGkpIGFycmF5LihpICsgMSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+XG4gICAgICAgICAgICBpZiBQb2x5LiggPD4gKSAoaSA8IDApIGluY3JlYXNpbmdcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgci5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZWxlbWVudHMgYXJlIG5vdCBvcmRlcmVkXCIpXG4gICAgICAgIGRvbmU7XG4gICAgICAgIFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQpKVxuICA7O1xuXG4gICgqIFNhbWUgYXMgY3JlYXRlLCBidXQgcGVyZm9ybXMgb25lIHN0ZXAgb2YgcmViYWxhbmNpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuICopXG5cbiAgbGV0IGJhbCBsIHYgciA9XG4gICAgbGV0IGhsID0gKGhlaWdodCBbQGlubGluZWRdKSBsIGluXG4gICAgbGV0IGhyID0gKGhlaWdodCBbQGlubGluZWRdKSByIGluXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTGVhZiB7IGVsdCA9IF8gfSAtPiBhc3NlcnQgZmFsc2UgKCogYmVjYXVzZSBoKGwpPmgocikrMiBhbmQgaChsZWFmKT0xICopXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbGw7IGVsdCA9IGx2OyByaWdodCA9IGxyOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHJcbiAgICAgICAgdGhlbiBjcmVhdGUgbGwgbHYgKGNyZWF0ZSBsciB2IHIpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTGVhZiB7IGVsdCA9IGxydiB9IC0+XG4gICAgICAgICAgICBhc3NlcnQgKGlzX2VtcHR5IGxsKTtcbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IEVtcHR5KSBscnYgKGNyZWF0ZSBFbXB0eSB2IHIpXG4gICAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGxybDsgZWx0ID0gbHJ2OyByaWdodCA9IGxycjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbHJsKSBscnYgKGNyZWF0ZSBscnIgdiByKSkpXG4gICAgZWxzZSBpZiBociA+IGhsICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IGFzc2VydCBmYWxzZSAoKiBiZWNhdXNlIGgocik+aChsKSsyIGFuZCBoKGxlYWYpPTEgKilcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBybDsgZWx0ID0gcnY7IHJpZ2h0ID0gcnI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybFxuICAgICAgICB0aGVuIGNyZWF0ZSAoY3JlYXRlIGwgdiBybCkgcnYgcnJcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBMZWFmIHsgZWx0ID0gcmx2IH0gLT5cbiAgICAgICAgICAgIGFzc2VydCAoaXNfZW1wdHkgcnIpO1xuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IEVtcHR5KSBybHYgKGNyZWF0ZSBFbXB0eSBydiBycilcbiAgICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gcmxsOyBlbHQgPSBybHY7IHJpZ2h0ID0gcmxyOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpKSlcbiAgICBlbHNlIChjcmVhdGUgW0BpbmxpbmVkXSkgbCB2IHJcbiAgOztcblxuICAoKiBJbnNlcnRpb24gb2Ygb25lIGVsZW1lbnQgKilcblxuICBleGNlcHRpb24gU2FtZVxuXG4gIGxldCBhZGQgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBhdXggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBMZWFmIHsgZWx0ID0geCB9XG4gICAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgU2FtZVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gY3JlYXRlIChMZWFmIHsgZWx0ID0geCB9KSB2IEVtcHR5XG4gICAgICAgIGVsc2UgY3JlYXRlIEVtcHR5IHYgKExlYWYgeyBlbHQgPSB4IH0pXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFNhbWVcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIGJhbCAoYXV4IGwpIHYgclxuICAgICAgICBlbHNlIGJhbCBsIHYgKGF1eCByKVxuICAgIGluXG4gICAgdHJ5IGF1eCB0IHdpdGhcbiAgICB8IFNhbWUgLT4gdFxuICA7O1xuXG4gICgqIHNwZWNpYWxpemF0aW9uIG9mIFthZGRdIHRoYXQgYXNzdW1lcyB0aGF0IFt4XSBpcyBsZXNzIHRoYW4gYWxsIGV4aXN0aW5nIGVsZW1lbnRzICopXG4gIGxldCByZWMgYWRkX21pbiB4IHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTGVhZiB7IGVsdCA9IHggfVxuICAgIHwgTGVhZiB7IGVsdCA9IF8gfSAtPiBOb2RlIHsgbGVmdCA9IEVtcHR5OyBlbHQgPSB4OyByaWdodCA9IHQ7IGhlaWdodCA9IDI7IHNpemUgPSAyIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+IGJhbCAoYWRkX21pbiB4IGwpIHYgclxuICA7O1xuXG4gICgqIHNwZWNpYWxpemF0aW9uIG9mIFthZGRdIHRoYXQgYXNzdW1lcyB0aGF0IFt4XSBpcyBncmVhdGVyIHRoYW4gYWxsIGV4aXN0aW5nIGVsZW1lbnRzICopXG4gIGxldCByZWMgYWRkX21heCB0IHggPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTGVhZiB7IGVsdCA9IHggfVxuICAgIHwgTGVhZiB7IGVsdCA9IF8gfSAtPiBOb2RlIHsgbGVmdCA9IHQ7IGVsdCA9IHg7IHJpZ2h0ID0gRW1wdHk7IGhlaWdodCA9IDI7IHNpemUgPSAyIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+IGJhbCBsIHYgKGFkZF9tYXggciB4KVxuICA7O1xuXG4gICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGUgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZFxuICAgICByLiAqKVxuICBsZXQgcmVjIGpvaW4gbCB2IHIgPVxuICAgIG1hdGNoIGwsIHIgd2l0aFxuICAgIHwgRW1wdHksIF8gLT4gYWRkX21pbiB2IHJcbiAgICB8IF8sIEVtcHR5IC0+IGFkZF9tYXggbCB2XG4gICAgfCBMZWFmIHsgZWx0ID0gbHYgfSwgXyAtPiBhZGRfbWluIGx2IChhZGRfbWluIHYgcilcbiAgICB8IF8sIExlYWYgeyBlbHQgPSBydiB9IC0+IGFkZF9tYXggKGFkZF9tYXggbCB2KSBydlxuICAgIHwgKCBOb2RlIHsgbGVmdCA9IGxsOyBlbHQgPSBsdjsgcmlnaHQgPSBscjsgaGVpZ2h0ID0gbGg7IHNpemUgPSBfIH1cbiAgICAgICwgTm9kZSB7IGxlZnQgPSBybDsgZWx0ID0gcnY7IHJpZ2h0ID0gcnI7IGhlaWdodCA9IHJoOyBzaXplID0gXyB9ICkgLT5cbiAgICAgIGlmIGxoID4gcmggKyAyXG4gICAgICB0aGVuIGJhbCBsbCBsdiAoam9pbiBsciB2IHIpXG4gICAgICBlbHNlIGlmIHJoID4gbGggKyAyXG4gICAgICB0aGVuIGJhbCAoam9pbiBsIHYgcmwpIHJ2IHJyXG4gICAgICBlbHNlIGNyZWF0ZSBsIHYgclxuICA7O1xuXG4gICgqIFNtYWxsZXN0IGFuZCBncmVhdGVzdCBlbGVtZW50IG9mIGEgc2V0ICopXG4gIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsgZWx0ID0gdjsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9XG4gICAgICAtPiBTb21lIHZcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gXzsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+IG1pbl9lbHQgbFxuICA7O1xuXG4gIGV4Y2VwdGlvbiBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICB8IFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXQgLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwic2V0Lm1sLlRyZWUwLlNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRcIlxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGV4Y2VwdGlvbiBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0XVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICB8IFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXQgLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwic2V0Lm1sLlRyZWUwLlNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRcIlxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBtaW5fZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtaW5fZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBmb2xkX3VudGlsX2hlbHBlciB+ZiB0IGFjYyA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AuQ29udGludWUgYWNjXG4gICAgICB8IExlYWYgeyBlbHQgPSB2YWx1ZSB9IC0+IGYgYWNjIHZhbHVlIFtAbm9udGFpbF1cbiAgICAgIHwgTm9kZSB7IGxlZnQ7IGVsdCA9IHZhbHVlOyByaWdodDsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICAobWF0Y2ggZm9sZF91bnRpbF9oZWxwZXIgfmYgbGVmdCBhY2Mgd2l0aFxuICAgICAgICAgfCBTdG9wIF9hIGFzIHggLT4geFxuICAgICAgICAgfCBDb250aW51ZSBhY2MgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgYWNjIHZhbHVlIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCBfYSBhcyB4IC0+IHhcbiAgICAgICAgICAgIHwgQ29udGludWUgYSAtPiBmb2xkX3VudGlsX2hlbHBlciB+ZiByaWdodCBhKSlcbiAgICBpblxuICAgIG1hdGNoIGZvbGRfdW50aWxfaGVscGVyIH5mIHQgaW5pdCB3aXRoXG4gICAgfCBDb250aW51ZSB4IC0+IGZpbmlzaCB4IFtAbm9udGFpbF1cbiAgICB8IFN0b3AgeCAtPiB4XG4gIDs7XG5cbiAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gfCBOb2RlIHsgbGVmdCA9IF87IGVsdCA9IHY7IHJpZ2h0ID0gRW1wdHk7IGhlaWdodCA9IF87IHNpemUgPSBfIH1cbiAgICAgIC0+IFNvbWUgdlxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBlbHQgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT4gbWF4X2VsdCByXG4gIDs7XG5cbiAgbGV0IG1heF9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1heF9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgKCogUmVtb3ZlIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBzZXQgKilcblxuICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LnJlbW92ZV9taW5fZWx0XCJcbiAgICB8IExlYWYgeyBlbHQgPSBfIH0gLT4gRW1wdHlcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IF87IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPiByXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcbiAgOztcblxuICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS4gIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG4gIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT4gYmFsIHQxIChtaW5fZWx0X2V4biB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLiAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG4gIGxldCBjb25jYXQgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT4gam9pbiB0MSAobWluX2VsdF9leG4gdDIpIChyZW1vdmVfbWluX2VsdCB0MilcbiAgOztcblxuICBsZXQgc3BsaXQgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBzcGxpdCB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBFbXB0eSwgTm9uZSwgRW1wdHlcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIEVtcHR5LCBTb21lIHYsIEVtcHR5XG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBFbXB0eSwgTm9uZSwgTGVhZiB7IGVsdCA9IHYgfVxuICAgICAgICBlbHNlIExlYWYgeyBlbHQgPSB2IH0sIE5vbmUsIEVtcHR5XG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gbCwgU29tZSB2LCByXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGxsLCBtYXliZV9lbHQsIHJsID0gc3BsaXQgbCBpblxuICAgICAgICAgIGxsLCBtYXliZV9lbHQsIGpvaW4gcmwgdiByKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgbHIsIG1heWJlX2VsdCwgcnIgPSBzcGxpdCByIGluXG4gICAgICAgICAgam9pbiBsIHYgbHIsIG1heWJlX2VsdCwgcnIpXG4gICAgaW5cbiAgICBzcGxpdCB0XG4gIDs7XG5cbiAgbGV0IHJlYyBzcGxpdF9sZV9ndCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5LCBFbXB0eVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPlxuICAgICAgaWYgY29tcGFyZV9lbHQgeCB2ID49IDAgdGhlbiBMZWFmIHsgZWx0ID0gdiB9LCBFbXB0eSBlbHNlIEVtcHR5LCBMZWFmIHsgZWx0ID0gdiB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIGFkZF9tYXggbCB2LCByXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGxsLCBybCA9IHNwbGl0X2xlX2d0IGwgeCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgbGwsIGpvaW4gcmwgdiByKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsciwgcnIgPSBzcGxpdF9sZV9ndCByIHggfmNvbXBhcmVfZWx0IGluXG4gICAgICAgIGpvaW4gbCB2IGxyLCBycilcbiAgOztcblxuICBsZXQgcmVjIHNwbGl0X2x0X2dlIHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHksIEVtcHR5XG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+XG4gICAgICBpZiBjb21wYXJlX2VsdCB4IHYgPiAwIHRoZW4gTGVhZiB7IGVsdCA9IHYgfSwgRW1wdHkgZWxzZSBFbXB0eSwgTGVhZiB7IGVsdCA9IHYgfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiBsLCBhZGRfbWluIHYgclxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBsbCwgcmwgPSBzcGxpdF9sdF9nZSBsIHggfmNvbXBhcmVfZWx0IGluXG4gICAgICAgIGxsLCBqb2luIHJsIHYgcilcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbHIsIHJyID0gc3BsaXRfbHRfZ2UgciB4IH5jb21wYXJlX2VsdCBpblxuICAgICAgICBqb2luIGwgdiBsciwgcnIpXG4gIDs7XG5cbiAgKCogSW1wbGVtZW50YXRpb24gb2YgdGhlIHNldCBvcGVyYXRpb25zICopXG5cbiAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICBsZXQgcmVjIG1lbSB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGZhbHNlXG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgYyA9IDBcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgYyA9IDAgfHwgbWVtIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2VsdFxuICA7O1xuXG4gIGxldCBzaW5nbGV0b24geCA9IExlYWYgeyBlbHQgPSB4IH1cblxuICBsZXQgcmVtb3ZlIHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgYXV4IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBTYW1lXG4gICAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgICAgaWYgY29tcGFyZV9lbHQgeCB2ID0gMCB0aGVuIEVtcHR5IGVsc2UgRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFNhbWVcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHIgZWxzZSBpZiBjIDwgMCB0aGVuIGJhbCAoYXV4IGwpIHYgciBlbHNlIGJhbCBsIHYgKGF1eCByKVxuICAgIGluXG4gICAgdHJ5IGF1eCB0IHdpdGhcbiAgICB8IFNhbWUgLT4gdFxuICA7O1xuXG4gIGxldCByZW1vdmVfaW5kZXggdCBpIH5jb21wYXJlX2VsdDpfID1cbiAgICBsZXQgcmVjIGF1eCB0IGkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBTYW1lXG4gICAgICB8IExlYWYgeyBlbHQgPSBfIH0gLT4gaWYgaSA9IDAgdGhlbiBFbXB0eSBlbHNlIEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBTYW1lXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgIGxldCBsX3NpemUgPSBsZW5ndGggbCBpblxuICAgICAgICBsZXQgYyA9IFBvbHkuY29tcGFyZSBpIGxfc2l6ZSBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIG1lcmdlIGwgclxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gYmFsIChhdXggbCBpKSB2IHJcbiAgICAgICAgZWxzZSBiYWwgbCB2IChhdXggciAoaSAtIGxfc2l6ZSAtIDEpKVxuICAgIGluXG4gICAgdHJ5IGF1eCB0IGkgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgbGV0IHVuaW9uIHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHMxIHMyXG4gICAgICB0aGVuIHMxXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICAgICAgfCBFbXB0eSwgdCB8IHQsIEVtcHR5IC0+IHRcbiAgICAgICAgfCBMZWFmIHsgZWx0ID0gdjEgfSwgXyAtPlxuICAgICAgICAgIHVuaW9uIChOb2RlIHsgbGVmdCA9IEVtcHR5OyBlbHQgPSB2MTsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMTsgc2l6ZSA9IDEgfSkgczJcbiAgICAgICAgfCBfLCBMZWFmIHsgZWx0ID0gdjIgfSAtPlxuICAgICAgICAgIHVuaW9uIHMxIChOb2RlIHsgbGVmdCA9IEVtcHR5OyBlbHQgPSB2MjsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMTsgc2l6ZSA9IDEgfSlcbiAgICAgICAgfCAoIE5vZGUgeyBsZWZ0ID0gbDE7IGVsdCA9IHYxOyByaWdodCA9IHIxOyBoZWlnaHQgPSBoMTsgc2l6ZSA9IF8gfVxuICAgICAgICAgICwgTm9kZSB7IGxlZnQgPSBsMjsgZWx0ID0gdjI7IHJpZ2h0ID0gcjI7IGhlaWdodCA9IGgyOyBzaXplID0gXyB9ICkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMlxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMVxuICAgICAgICAgICAgdGhlbiBhZGQgczEgdjIgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgbGV0IGwyLCBfLCByMiA9IHNwbGl0IHMyIHYxIH5jb21wYXJlX2VsdCBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjEgKHVuaW9uIHIxIHIyKSlcbiAgICAgICAgICBlbHNlIGlmIGgxID0gMVxuICAgICAgICAgIHRoZW4gYWRkIHMyIHYxIH5jb21wYXJlX2VsdFxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGwxLCBfLCByMSA9IHNwbGl0IHMxIHYyIH5jb21wYXJlX2VsdCBpblxuICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYyICh1bmlvbiByMSByMikpKVxuICAgIGluXG4gICAgdW5pb24gczEgczJcbiAgOztcblxuICBsZXQgdW5pb25fbGlzdCB+Y29tcGFyYXRvciB+dG9fdHJlZSB4cyA9XG4gICAgbGV0IGNvbXBhcmVfZWx0ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICBMaXN0LmZvbGQgeHMgfmluaXQ6ZW1wdHkgfmY6KGZ1biBhYyB4IC0+IHVuaW9uIGFjICh0b190cmVlIHgpIH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgaW50ZXIgczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gczFcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCBfIHwgXywgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCAoTGVhZiB7IGVsdCB9IGFzIHNpbmdsZXRvbiksIG90aGVyX3NldCB8IG90aGVyX3NldCwgKExlYWYgeyBlbHQgfSBhcyBzaW5nbGV0b24pXG4gICAgICAgICAgLT4gaWYgbWVtIG90aGVyX3NldCBlbHQgfmNvbXBhcmVfZWx0IHRoZW4gc2luZ2xldG9uIGVsc2UgRW1wdHlcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGwxOyBlbHQgPSB2MTsgcmlnaHQgPSByMTsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSwgdDIgLT5cbiAgICAgICAgICAobWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT4gY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgICB8IGwyLCBTb21lIHYxLCByMiAtPiBqb2luIChpbnRlciBsMSBsMikgdjEgKGludGVyIHIxIHIyKSkpXG4gICAgaW5cbiAgICBpbnRlciBzMSBzMlxuICA7O1xuXG4gIGxldCBkaWZmIHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gRW1wdHlcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCBfIC0+IEVtcHR5XG4gICAgICAgIHwgdDEsIEVtcHR5IC0+IHQxXG4gICAgICAgIHwgTGVhZiB7IGVsdCA9IHYxIH0sIHQyIC0+XG4gICAgICAgICAgZGlmZiAoTm9kZSB7IGxlZnQgPSBFbXB0eTsgZWx0ID0gdjE7IHJpZ2h0ID0gRW1wdHk7IGhlaWdodCA9IDE7IHNpemUgPSAxIH0pIHQyXG4gICAgICAgIHwgTm9kZSB7IGxlZnQgPSBsMTsgZWx0ID0gdjE7IHJpZ2h0ID0gcjE7IGhlaWdodCA9IF87IHNpemUgPSBfIH0sIHQyIC0+XG4gICAgICAgICAgKG1hdGNoIHNwbGl0IHQyIHYxIH5jb21wYXJlX2VsdCB3aXRoXG4gICAgICAgICAgIHwgbDIsIE5vbmUsIHIyIC0+IGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKVxuICAgICAgICAgICB8IGwyLCBTb21lIF8sIHIyIC0+IGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpKSlcbiAgICBpblxuICAgIGRpZmYgczEgczJcbiAgOztcblxuICBtb2R1bGUgRW51bSA9IHN0cnVjdFxuICAgIHR5cGUgaW5jcmVhc2luZ1xuICAgIHR5cGUgZGVjcmVhc2luZ1xuXG4gICAgdHlwZSAoJ2EsICdkaXJlY3Rpb24pIHQgPVxuICAgICAgfCBFbmRcbiAgICAgIHwgTW9yZSBvZiAnYSAqICdhIHRyZWUgKiAoJ2EsICdkaXJlY3Rpb24pIHRcblxuICAgIGxldCByZWMgY29ucyBzIChlIDogKF8sIGluY3JlYXNpbmcpIHQpIDogKF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBNb3JlICh2LCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgY29ucyBsIChNb3JlICh2LCByLCBlKSlcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBjb25zX3JpZ2h0IHMgKGUgOiAoXywgZGVjcmVhc2luZykgdCkgOiAoXywgZGVjcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IE1vcmUgKHYsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICBjb25zX3JpZ2h0IHIgKE1vcmUgKHYsIGwsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc2V0IHMgOiAoXywgaW5jcmVhc2luZykgdCA9IGNvbnMgcyBFbmRcbiAgICBsZXQgb2Zfc2V0X3JpZ2h0IHMgOiAoXywgZGVjcmVhc2luZykgdCA9IGNvbnNfcmlnaHQgcyBFbmRcblxuICAgIGxldCBzdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmUgOiAoXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgdCBlID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgICAgICBsb29wIChOb2RlIHsgbGVmdCA9IEVtcHR5OyBlbHQgPSB2OyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAxOyBzaXplID0gMSB9KSBlXG4gICAgICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH1cbiAgICAgICAgICB3aGVuIGNvbXBhcmUgdiBrZXkgPCAwIC0+IGxvb3AgciBlXG4gICAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgICBsb29wIGwgKE1vcmUgKHYsIHIsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPlxuICAgICAgICAgIGxvb3AgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHY7IHJpZ2h0ID0gRW1wdHk7IGhlaWdodCA9IDE7IHNpemUgPSAxIH0pIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gXzsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfVxuICAgICAgICAgIHdoZW4gY29tcGFyZSB2IGtleSA+IDAgLT4gbG9vcCBsIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICAgIGxvb3AgciAoTW9yZSAodiwgbCwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZSBjb21wYXJlX2VsdCBlMSBlMiA9XG4gICAgICBsZXQgcmVjIGxvb3AgZTEgZTIgPVxuICAgICAgICBtYXRjaCBlMSwgZTIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IDBcbiAgICAgICAgfCBFbmQsIF8gLT4gLTFcbiAgICAgICAgfCBfLCBFbmQgLT4gMVxuICAgICAgICB8IE1vcmUgKHYxLCByMSwgZTEpLCBNb3JlICh2MiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGlmIHBoeXNfZXF1YWwgcjEgcjJcbiAgICAgICAgICB0aGVuIGxvb3AgZTEgZTJcbiAgICAgICAgICBlbHNlIGxvb3AgKGNvbnMgcjEgZTEpIChjb25zIHIyIGUyKVxuICAgICAgaW5cbiAgICAgIGxvb3AgZTEgZTJcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBpdGVyIH5mID0gZnVuY3Rpb25cbiAgICAgIHwgRW5kIC0+ICgpXG4gICAgICB8IE1vcmUgKGEsIHRyZWUsIGVudW0pIC0+XG4gICAgICAgIGYgYTtcbiAgICAgICAgaXRlciAoY29ucyB0cmVlIGVudW0pIH5mXG4gICAgOztcblxuICAgIGxldCBpdGVyMiBjb21wYXJlX2VsdCB0MSB0MiB+ZiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+ICgpXG4gICAgICAgIHwgRW5kLCBfIC0+IGl0ZXIgdDIgfmY6KGZ1biBhIC0+IGYgKGBSaWdodCBhKSkgW0Bub250YWlsXVxuICAgICAgICB8IF8sIEVuZCAtPiBpdGVyIHQxIH5mOihmdW4gYSAtPiBmIChgTGVmdCBhKSkgW0Bub250YWlsXVxuICAgICAgICB8IE1vcmUgKGExLCB0cmVlMSwgZW51bTEpLCBNb3JlIChhMiwgdHJlZTIsIGVudW0yKSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfZWx0IGExIGEyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBmIChgQm90aCAoYTEsIGEyKSk7XG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSAoY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGYgKGBMZWZ0IGExKTtcbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIHQyKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgZiAoYFJpZ2h0IGEyKTtcbiAgICAgICAgICAgIGxvb3AgdDEgKGNvbnMgdHJlZTIgZW51bTIpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDIgW0Bub250YWlsXVxuICAgIDs7XG5cbiAgICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfZWx0ID1cbiAgICAgIGxldCBzdGVwIHN0YXRlIDogKChfLCBfKSBFaXRoZXIudCwgXykgU2VxdWVuY2UuU3RlcC50ID1cbiAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IERvbmVcbiAgICAgICAgfCBFbmQsIE1vcmUgKGVsdCwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgICBZaWVsZCB7IHZhbHVlID0gU2Vjb25kIGVsdDsgc3RhdGUgPSBFbmQsIGNvbnMgdHJlZSBlbnVtIH1cbiAgICAgICAgfCBNb3JlIChlbHQsIHRyZWUsIGVudW0pLCBFbmQgLT5cbiAgICAgICAgICBZaWVsZCB7IHZhbHVlID0gRmlyc3QgZWx0OyBzdGF0ZSA9IGNvbnMgdHJlZSBlbnVtLCBFbmQgfVxuICAgICAgICB8IChNb3JlIChhMSwgdHJlZTEsIGVudW0xKSBhcyBsZWZ0KSwgKE1vcmUgKGEyLCB0cmVlMiwgZW51bTIpIGFzIHJpZ2h0KSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfZWx0IGExIGEyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dF9zdGF0ZSA9XG4gICAgICAgICAgICAgIGlmIHBoeXNfZXF1YWwgdHJlZTEgdHJlZTJcbiAgICAgICAgICAgICAgdGhlbiBlbnVtMSwgZW51bTJcbiAgICAgICAgICAgICAgZWxzZSBjb25zIHRyZWUxIGVudW0xLCBjb25zIHRyZWUyIGVudW0yXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgU2tpcCB7IHN0YXRlID0gbmV4dF9zdGF0ZSB9KVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiBZaWVsZCB7IHZhbHVlID0gRmlyc3QgYTE7IHN0YXRlID0gY29ucyB0cmVlMSBlbnVtMSwgcmlnaHQgfVxuICAgICAgICAgIGVsc2UgWWllbGQgeyB2YWx1ZSA9IFNlY29uZCBhMjsgc3RhdGUgPSBsZWZ0LCBjb25zIHRyZWUyIGVudW0yIH1cbiAgICAgIGluXG4gICAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdDoob2Zfc2V0IHQxLCBvZl9zZXQgdDIpIH5mOnN0ZXBcbiAgICA7O1xuICBlbmRcblxuICBsZXQgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdCB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB0LCBlKSAtPiBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrOyBzdGF0ZSA9IEVudW0uY29ucyB0IGUgfVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9lbHQgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2Zfc2V0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdCwgZSkgLT5cbiAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0gazsgc3RhdGUgPSBFbnVtLmNvbnNfcmlnaHQgdCBlIH1cbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fZWx0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3NldF9yaWdodCB0XG4gICAgICB8IFNvbWUga2V5IC0+IEVudW0uc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQgfmY6bmV4dFxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZVxuICAgIGNvbXBhcmF0b3JcbiAgICA/KG9yZGVyID0gYEluY3JlYXNpbmcpXG4gICAgP2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgIHRcbiAgICA9XG4gICAgbGV0IGluY2x1c2l2ZV9ib3VuZCBzaWRlIHQgYm91bmQgPVxuICAgICAgbGV0IGNvbXBhcmVfZWx0ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICAgIGxldCBsLCBtYXliZSwgciA9IHNwbGl0IHQgYm91bmQgfmNvbXBhcmVfZWx0IGluXG4gICAgICBsZXQgdCA9IHNpZGUgKGwsIHIpIGluXG4gICAgICBtYXRjaCBtYXliZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gdFxuICAgICAgfCBTb21lIGVsdCAtPiBhZGQgdCBlbHQgfmNvbXBhcmVfZWx0XG4gICAgaW5cbiAgICBtYXRjaCBvcmRlciB3aXRoXG4gICAgfCBgSW5jcmVhc2luZyAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBsZXNzX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBmc3QpIGluXG4gICAgICB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0OmdyZWF0ZXJfb3JfZXF1YWxfdG8gdFxuICAgIHwgYERlY3JlYXNpbmcgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQgZ3JlYXRlcl9vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgc25kKSBpblxuICAgICAgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdDpsZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gaWYgZiB2IHRoZW4gU29tZSB2IGVsc2UgTm9uZVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIGlmIGYgdlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgdlxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyByIH5mXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gaWYgZiB2IHRoZW4gU29tZSB2IGVsc2UgTm9uZVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIGlmIGYgdlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHIgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSB2XG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9sYXN0X3NhdGlzZnlpbmcgbCB+ZlxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPVxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gLT5cbiAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDwgMCkgW0Bub250YWlsXVxuICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKSBbQG5vbnRhaWxdXG4gICAgfCBgRmlyc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMCkgd2l0aFxuICAgICAgIHwgU29tZSB4IGFzIGVsdCB3aGVuIGNvbXBhcmUgeCB2ID0gMCAtPiBlbHRcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBMYXN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMCkgd2l0aFxuICAgICAgIHwgU29tZSB4IGFzIGVsdCB3aGVuIGNvbXBhcmUgeCB2ID0gMCAtPiBlbHRcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKSBbQG5vbnRhaWxdXG4gICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPiAwKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBsZXQgaXNfbGVmdCB4ID1cbiAgICAgIG1hdGNoIHNlZ21lbnRfb2YgeCB3aXRoXG4gICAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgaXNfcmlnaHQgeCA9IG5vdCAoaXNfbGVmdCB4KSBpblxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9vbl9sZWZ0IC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfbGVmdCBbQG5vbnRhaWxdXG4gICAgfCBgRmlyc3Rfb25fcmlnaHQgLT4gZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfcmlnaHQgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIGNvbXBhcmF0b3JcbiAgICA/KG9yZGVyID0gYEluY3JlYXNpbmcpXG4gICAgP2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgIHRcbiAgICB0J1xuICAgID1cbiAgICBTZXF1ZW5jZS5tZXJnZV93aXRoX2R1cGxpY2F0ZXNcbiAgICAgICh0b19zZXF1ZW5jZSBjb21wYXJhdG9yIH5vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0KVxuICAgICAgKHRvX3NlcXVlbmNlIGNvbXBhcmF0b3Igfm9yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQnKVxuICAgICAgfmNvbXBhcmU6XG4gICAgICAgIChtYXRjaCBvcmRlciB3aXRoXG4gICAgICAgICB8IGBJbmNyZWFzaW5nIC0+IGNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgICAgfCBgRGVjcmVhc2luZyAtPiBGbi5mbGlwIGNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgY29tcGFyZSBjb21wYXJlX2VsdCBzMSBzMiA9XG4gICAgRW51bS5jb21wYXJlIGNvbXBhcmVfZWx0IChFbnVtLm9mX3NldCBzMSkgKEVudW0ub2Zfc2V0IHMyKVxuICA7O1xuXG4gIGxldCBpdGVyMiBzMSBzMiB+Y29tcGFyZV9lbHQgfmYgPVxuICAgIEVudW0uaXRlcjIgY29tcGFyZV9lbHQgKEVudW0ub2Zfc2V0IHMxKSAoRW51bS5vZl9zZXQgczIpIH5mXG4gIDs7XG5cbiAgbGV0IGVxdWFsIHMxIHMyIH5jb21wYXJlX2VsdCA9IGNvbXBhcmUgY29tcGFyZV9lbHQgczEgczIgPSAwXG5cbiAgbGV0IGlzX3N1YnNldCBzMSB+b2ZfOnMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBpc19zdWJzZXQgczEgfm9mXzpzMiA9XG4gICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgfCBFbXB0eSwgXyAtPiB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IExlYWYgeyBlbHQgPSB2MSB9LCB0MiAtPiBtZW0gdDIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDE7IGVsdCA9IHYxOyByaWdodCA9IHIxOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9LCBMZWFmIHsgZWx0ID0gdjIgfVxuICAgICAgICAtPlxuICAgICAgICAobWF0Y2ggbDEsIHIxIHdpdGhcbiAgICAgICAgIHwgRW1wdHksIEVtcHR5IC0+XG4gICAgICAgICAgICgqIFRoaXMgY2FzZSBzaG91bGRuJ3Qgb2NjdXIgaW4gcHJhY3RpY2UgYmVjYXVzZSB3ZSBzaG91bGQgaGF2ZSBjb25zdHJ1Y3RlZFxuICAgICAgICAgICAgICBhIExlYWYge2VsdD1yYXRoZXJ9IHRoYW4gYSBOb2RlIHdpdGggdHdvIEVtcHR5IHN1YnRyZWVzICopXG4gICAgICAgICAgIGNvbXBhcmVfZWx0IHYxIHYyID0gMFxuICAgICAgICAgfCBfLCBfIC0+IGZhbHNlKVxuICAgICAgfCAoIE5vZGUgeyBsZWZ0ID0gbDE7IGVsdCA9IHYxOyByaWdodCA9IHIxOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9XG4gICAgICAgICwgKE5vZGUgeyBsZWZ0ID0gbDI7IGVsdCA9IHYyOyByaWdodCA9IHIyOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IGFzIHQyKSApIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgdjEgdjIgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIHBoeXNfZXF1YWwgczEgczIgfHwgKGlzX3N1YnNldCBsMSB+b2ZfOmwyICYmIGlzX3N1YnNldCByMSB+b2ZfOnIyKVxuICAgICAgICAgICgqIE5vdGUgdGhhdCBoZWlnaHQgYW5kIHNpemUgZG9uJ3QgbWF0dGVyIGhlcmUuICopXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIGlzX3N1YnNldFxuICAgICAgICAgICAgKE5vZGUgeyBsZWZ0ID0gbDE7IGVsdCA9IHYxOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAwOyBzaXplID0gMCB9KVxuICAgICAgICAgICAgfm9mXzpsMlxuICAgICAgICAgICYmIGlzX3N1YnNldCByMSB+b2ZfOnQyXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpc19zdWJzZXRcbiAgICAgICAgICAgIChOb2RlIHsgbGVmdCA9IEVtcHR5OyBlbHQgPSB2MTsgcmlnaHQgPSByMTsgaGVpZ2h0ID0gMDsgc2l6ZSA9IDAgfSlcbiAgICAgICAgICAgIH5vZl86cjJcbiAgICAgICAgICAmJiBpc19zdWJzZXQgbDEgfm9mXzp0MlxuICAgIGluXG4gICAgaXNfc3Vic2V0IHMxIH5vZl86czJcbiAgOztcblxuICBsZXQgcmVjIGFyZV9kaXNqb2ludCBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgfCBFbXB0eSwgXyB8IF8sIEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgeyBlbHQgfSwgb3RoZXJfc2V0IHwgb3RoZXJfc2V0LCBMZWFmIHsgZWx0IH0gLT5cbiAgICAgIG5vdCAobWVtIG90aGVyX3NldCBlbHQgfmNvbXBhcmVfZWx0KVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsMTsgZWx0ID0gdjE7IHJpZ2h0ID0gcjE7IGhlaWdodCA9IF87IHNpemUgPSBfIH0sIHQyIC0+XG4gICAgICBpZiBwaHlzX2VxdWFsIHMxIHMyXG4gICAgICB0aGVuIGZhbHNlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT5cbiAgICAgICAgICBhcmVfZGlzam9pbnQgbDEgbDIgfmNvbXBhcmVfZWx0ICYmIGFyZV9kaXNqb2ludCByMSByMiB+Y29tcGFyZV9lbHRcbiAgICAgICAgfCBfLCBTb21lIF8sIF8gLT4gZmFsc2UpXG4gIDs7XG5cbiAgbGV0IGl0ZXIgdCB+ZiA9XG4gICAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBmIHZcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgaXRlciBsO1xuICAgICAgICBmIHY7XG4gICAgICAgIGl0ZXIgclxuICAgIGluXG4gICAgaXRlciB0IFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgPSBFbnVtLnN5bW1ldHJpY19kaWZmXG5cbiAgbGV0IHJlYyBmb2xkIHMgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IGYgYWNjdSB2XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgZm9sZCB+ZiByIH5pbml0OihmIChmb2xkIH5mIGwgfmluaXQ6YWNjdSkgdilcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9lbGVtIHN0YXRlIHQgPVxuICAgIGZvbGQgdCB+aW5pdDooaGFzaF9mb2xkX2ludCBzdGF0ZSAobGVuZ3RoIHQpKSB+ZjpoYXNoX2ZvbGRfZWxlbVxuICA7O1xuXG4gIGxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxuXG4gIGxldCByZWMgZm9sZF9yaWdodCBzIH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBmIHYgYWNjdVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIGZvbGRfcmlnaHQgfmYgbCB+aW5pdDooZiB2IChmb2xkX3JpZ2h0IH5mIHIgfmluaXQ6YWNjdSkpXG4gIDs7XG5cbiAgbGV0IHJlYyBmb3JfYWxsIHQgfmY6cCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IHAgdlxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIHAgdiAmJiBmb3JfYWxsIH5mOnAgbCAmJiBmb3JfYWxsIH5mOnAgclxuICA7O1xuXG4gIGxldCByZWMgZXhpc3RzIHQgfmY6cCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBmYWxzZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBwIHZcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBwIHYgfHwgZXhpc3RzIH5mOnAgbCB8fCBleGlzdHMgfmY6cCByXG4gIDs7XG5cbiAgbGV0IGZpbHRlciBzIH5mOnAgPVxuICAgIGxldCByZWMgZmlsdCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IExlYWYgeyBlbHQgPSB2IH0gYXMgdCAtPiBpZiBwIHYgdGhlbiB0IGVsc2UgRW1wdHlcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gYXMgdCAtPlxuICAgICAgICBsZXQgbCcgPSBmaWx0IGwgaW5cbiAgICAgICAgbGV0IGtlZXBfdiA9IHAgdiBpblxuICAgICAgICBsZXQgcicgPSBmaWx0IHIgaW5cbiAgICAgICAgaWYga2VlcF92ICYmIHBoeXNfZXF1YWwgbCBsJyAmJiBwaHlzX2VxdWFsIHIgcidcbiAgICAgICAgdGhlbiB0XG4gICAgICAgIGVsc2UgaWYga2VlcF92XG4gICAgICAgIHRoZW4gam9pbiBsJyB2IHInXG4gICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG4gICAgaW5cbiAgICBmaWx0IHMgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIHMgfmY6cCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgZmlsdCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+XG4gICAgICAgIChtYXRjaCBwIHYgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IGFjY3VcbiAgICAgICAgIHwgU29tZSB2IC0+IGFkZCBhY2N1IHYgfmNvbXBhcmVfZWx0KVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICBmaWx0XG4gICAgICAgICAgKGZpbHRcbiAgICAgICAgICAgICAobWF0Y2ggcCB2IHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGFjY3VcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQpXG4gICAgICAgICAgICAgbClcbiAgICAgICAgICByXG4gICAgaW5cbiAgICBmaWx0IEVtcHR5IHMgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgcyB+ZjpwID1cbiAgICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eSwgRW1wdHlcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSBhcyB0IC0+IGlmIHAgdiB0aGVuIHQsIEVtcHR5IGVsc2UgRW1wdHksIHRcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gYXMgdCAtPlxuICAgICAgICBsZXQgbCd0LCBsJ2YgPSBsb29wIGwgaW5cbiAgICAgICAgbGV0IGtlZXBfdl90ID0gcCB2IGluXG4gICAgICAgIGxldCByJ3QsIHInZiA9IGxvb3AgciBpblxuICAgICAgICBsZXQgbWsga2VlcF92IGwnIHInID1cbiAgICAgICAgICBpZiBrZWVwX3YgJiYgcGh5c19lcXVhbCBsIGwnICYmIHBoeXNfZXF1YWwgciByJ1xuICAgICAgICAgIHRoZW4gdFxuICAgICAgICAgIGVsc2UgaWYga2VlcF92XG4gICAgICAgICAgdGhlbiBqb2luIGwnIHYgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuICAgICAgICBpblxuICAgICAgICBtayBrZWVwX3ZfdCBsJ3Qgcid0LCBtayAobm90IGtlZXBfdl90KSBsJ2YgcidmXG4gICAgaW5cbiAgICBsb29wIHMgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiB2IDo6IGFjY3VcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBlbGVtZW50c19hdXggKHYgOjogZWxlbWVudHNfYXV4IGFjY3UgcikgbFxuICA7O1xuXG4gIGxldCBlbGVtZW50cyBzID0gZWxlbWVudHNfYXV4IFtdIHNcblxuICBsZXQgY2hvb3NlIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBTb21lIHZcbiAgICB8IE5vZGUgeyBsZWZ0ID0gXzsgZWx0ID0gdjsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+IFNvbWUgdlxuICA7O1xuXG4gIGxldCBjaG9vc2VfZXhuID1cbiAgICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTZXQuY2hvb3NlX2V4bjogZW1wdHkgc2V0XCIpIGluXG4gICAgbGV0IGNob29zZV9leG4gdCA9XG4gICAgICBtYXRjaCBjaG9vc2UgdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgICB8IFNvbWUgdiAtPiB2XG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgY2hvb3NlX2V4blxuICA7O1xuXG4gIGxldCBvZl9saXN0IGxzdCB+Y29tcGFyZV9lbHQgPVxuICAgIExpc3QuZm9sZCBsc3QgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgeCB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIHNlcXVlbmNlIH5jb21wYXJlX2VsdCA9XG4gICAgU2VxdWVuY2UuZm9sZCBzZXF1ZW5jZSB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCB4IH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgdG9fbGlzdCBzID0gZWxlbWVudHMgc1xuXG4gIGxldCBvZl9hcnJheSBhIH5jb21wYXJlX2VsdCA9XG4gICAgQXJyYXkuZm9sZCBhIH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IHggfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gICgqIGZhc3RlciBidXQgZXF1aXZhbGVudCB0byBbQXJyYXkub2ZfbGlzdCAodG9fbGlzdCB0KV0gKilcbiAgbGV0IHRvX2FycmF5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IFt8fF1cbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gW3wgdiB8XVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBzIH0gLT5cbiAgICAgIGxldCByZXMgPSBBcnJheS5jcmVhdGUgfmxlbjpzIHYgaW5cbiAgICAgIGxldCBwb3NfcmVmID0gcmVmIDAgaW5cbiAgICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICAgICgqIEludmFyaWFudDogb24gZW50cnkgYW5kIG9uIGV4aXQgdG8gW2xvb3BdLCAhcG9zX3JlZiBpcyB0aGUgbmV4dFxuICAgICAgICAgICBhdmFpbGFibGUgY2VsbCBpbiB0aGUgYXJyYXkuICopXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+XG4gICAgICAgICAgcmVzLighcG9zX3JlZikgPC0gdjtcbiAgICAgICAgICBpbmNyIHBvc19yZWZcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICAgIGxvb3AgbDtcbiAgICAgICAgICByZXMuKCFwb3NfcmVmKSA8LSB2O1xuICAgICAgICAgIGluY3IgcG9zX3JlZjtcbiAgICAgICAgICBsb29wIHJcbiAgICAgIGluXG4gICAgICBsb29wIGw7XG4gICAgICAoKiByZXMuKCFwb3NfcmVmKSBpcyBhbHJlYWR5IGluaXRpYWxpemVkIChieSBBcnJheS5jcmVhdGUgfmxlbjphYm92ZSkuICopXG4gICAgICBpbmNyIHBvc19yZWY7XG4gICAgICBsb29wIHI7XG4gICAgICByZXNcbiAgOztcblxuICBsZXQgbWFwIHQgfmYgfmNvbXBhcmVfZWx0ID1cbiAgICBmb2xkIHQgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgKGYgeCkgfmNvbXBhcmVfZWx0KSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGdyb3VwX2J5IHNldCB+ZXF1aXYgPVxuICAgIGxldCByZWMgbG9vcCBzZXQgZXF1aXZfY2xhc3NlcyA9XG4gICAgICBpZiBpc19lbXB0eSBzZXRcbiAgICAgIHRoZW4gZXF1aXZfY2xhc3Nlc1xuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCB4ID0gY2hvb3NlX2V4biBzZXQgaW5cbiAgICAgICAgbGV0IGVxdWl2X3gsIG5vdF9lcXVpdl94ID1cbiAgICAgICAgICBwYXJ0aXRpb25fdGYgc2V0IH5mOihmdW4gZWx0IC0+IHBoeXNfZXF1YWwgeCBlbHQgfHwgZXF1aXYgeCBlbHQpXG4gICAgICAgIGluXG4gICAgICAgIGxvb3Agbm90X2VxdWl2X3ggKGVxdWl2X3ggOjogZXF1aXZfY2xhc3NlcykpXG4gICAgaW5cbiAgICBsb29wIHNldCBbXSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIFNvbWUgdlxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGZpbmQgbCB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaW5kIHIgfmZcbiAgICAgICAgfCBTb21lIF8gYXMgciAtPiByKVxuICA7O1xuXG4gIGxldCByZWMgZmluZF9tYXAgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IGYgdlxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIChtYXRjaCBmIHYgd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHIgLT4gclxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgKG1hdGNoIGZpbmRfbWFwIGwgfmYgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcCByIH5mXG4gICAgICAgICAgfCBTb21lIF8gYXMgciAtPiByKSlcbiAgOztcblxuICBsZXQgZmluZF9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZCB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXQuZmluZF9leG4gZmFpbGVkIHRvIGZpbmQgYSBtYXRjaGluZyBlbGVtZW50XCJcbiAgICB8IFNvbWUgZSAtPiBlXG4gIDs7XG5cbiAgbGV0IHJlYyBudGggdCBpID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gaWYgaSA9IDAgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IHMgfSAtPlxuICAgICAgaWYgaSA+PSBzXG4gICAgICB0aGVuIE5vbmVcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbF9zaXplID0gbGVuZ3RoIGwgaW5cbiAgICAgICAgbGV0IGMgPSBQb2x5LmNvbXBhcmUgaSBsX3NpemUgaW5cbiAgICAgICAgaWYgYyA8IDAgdGhlbiBudGggbCBpIGVsc2UgaWYgYyA9IDAgdGhlbiBTb21lIHYgZWxzZSBudGggciAoaSAtIGxfc2l6ZSAtIDEpKVxuICA7O1xuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB4cyB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgbG9vcCB4cyBsZWZ0b3ZlcnMgYWxyZWFkeV9zZWVuID1cbiAgICAgIG1hdGNoIHhzIHdpdGhcbiAgICAgIHwgW10gLT4gTGlzdC5yZXYgbGVmdG92ZXJzXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGlmIG1lbSBhbHJlYWR5X3NlZW4gaGQgfmNvbXBhcmVfZWx0XG4gICAgICAgIHRoZW4gbG9vcCB0bCBsZWZ0b3ZlcnMgYWxyZWFkeV9zZWVuXG4gICAgICAgIGVsc2UgbG9vcCB0bCAoaGQgOjogbGVmdG92ZXJzKSAoYWRkIGFscmVhZHlfc2VlbiBoZCB+Y29tcGFyZV9lbHQpXG4gICAgaW5cbiAgICBsb29wIHhzIFtdIGVtcHR5XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgYV9vZl9zZXhwIHNleHAgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuTGlzdCBsc3QgLT5cbiAgICAgIGxldCBlbHRfbHN0ID0gTGlzdC5tYXAgbHN0IH5mOmFfb2Zfc2V4cCBpblxuICAgICAgbGV0IHNldCA9IG9mX2xpc3QgZWx0X2xzdCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgIGlmIGxlbmd0aCBzZXQgPSBMaXN0Lmxlbmd0aCBsc3RcbiAgICAgIHRoZW4gc2V0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHNldCA9IHJlZiBlbXB0eSBpblxuICAgICAgICBMaXN0Lml0ZXIyX2V4biBsc3QgZWx0X2xzdCB+ZjooZnVuIGVsX3NleHAgZWwgLT5cbiAgICAgICAgICBpZiBtZW0gIXNldCBlbCB+Y29tcGFyZV9lbHRcbiAgICAgICAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJTZXQudF9vZl9zZXhwOiBkdXBsaWNhdGUgZWxlbWVudCBpbiBzZXRcIiBlbF9zZXhwXG4gICAgICAgICAgZWxzZSBzZXQgOj0gYWRkICFzZXQgZWwgfmNvbXBhcmVfZWx0KTtcbiAgICAgICAgYXNzZXJ0IGZhbHNlKVxuICAgIHwgc2V4cCAtPiBvZl9zZXhwX2Vycm9yIFwiU2V0LnRfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgU2V4cC5MaXN0IChmb2xkX3JpZ2h0IHQgfmluaXQ6W10gfmY6KGZ1biBlbCBhY2MgLT4gc2V4cF9vZl9hIGVsIDo6IGFjYykpXG4gIDs7XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgbGV0IGlzX3N1YnNldFxuICAgICAgKHN1YnNldCA6IF8gTmFtZWQudClcbiAgICAgIH5vZl86KHN1cGVyc2V0IDogXyBOYW1lZC50KVxuICAgICAgfnNleHBfb2ZfZWx0XG4gICAgICB+Y29tcGFyZV9lbHRcbiAgICAgID1cbiAgICAgIGxldCBpbnZhbGlkX2VsZW1lbnRzID0gZGlmZiBzdWJzZXQuc2V0IHN1cGVyc2V0LnNldCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgIGlmIGlzX2VtcHR5IGludmFsaWRfZWxlbWVudHNcbiAgICAgIHRoZW4gT2sgKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgaW52YWxpZF9lbGVtZW50c19zZXhwID0gc2V4cF9vZl90IHNleHBfb2ZfZWx0IGludmFsaWRfZWxlbWVudHMgaW5cbiAgICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICAoc3Vic2V0Lm5hbWUgXiBcIiBpcyBub3QgYSBzdWJzZXQgb2YgXCIgXiBzdXBlcnNldC5uYW1lKVxuICAgICAgICAgICAgIFsgXCJpbnZhbGlkX2VsZW1lbnRzXCIsIGludmFsaWRfZWxlbWVudHNfc2V4cCBdKSlcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIHMxIHMyIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHQgPVxuICAgICAgT3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdFxuICAgICAgICBbIGlzX3N1YnNldCBzMSB+b2ZfOnMyIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHRcbiAgICAgICAgOyBpc19zdWJzZXQgczIgfm9mXzpzMSB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0XG4gICAgICAgIF1cbiAgICA7O1xuICBlbmRcbmVuZFxuXG50eXBlICgnYSwgJ2NvbXBhcmF0b3IpIHQgPVxuICB7ICgqIFtjb21wYXJhdG9yXSBpcyB0aGUgZmlyc3QgZmllbGQgc28gdGhhdCBwb2x5bW9ycGhpYyBlcXVhbGl0eSBmYWlscyBvbiBhIG1hcCBkdWVcbiAgICAgICB0byB0aGUgZnVuY3Rpb25hbCB2YWx1ZSBpbiB0aGUgY29tcGFyYXRvci5cbiAgICAgICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgcG9seW1vcnBoaWMgW2NvbXBhcmVdOiB0aGF0IHN0aWxsIHByb2R1Y2VzXG4gICAgICAgbm9uc2Vuc2UuICopXG4gICAgY29tcGFyYXRvciA6ICgnYSwgJ2NvbXBhcmF0b3IpIENvbXBhcmF0b3IudFxuICA7IHRyZWUgOiAnYSBUcmVlMC50XG4gIH1cblxudHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0cmVlID0gJ2EgVHJlZTAudFxuXG5sZXQgbGlrZSB7IHRyZWUgPSBfOyBjb21wYXJhdG9yIH0gdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvciB9XG5cbmxldCBsaWtlX21heWJlX25vX29wICh7IHRyZWUgPSBvbGRfdHJlZTsgY29tcGFyYXRvciB9IGFzIG9sZF90KSB0cmVlID1cbiAgaWYgcGh5c19lcXVhbCBvbGRfdHJlZSB0cmVlIHRoZW4gb2xkX3QgZWxzZSB7IHRyZWU7IGNvbXBhcmF0b3IgfVxuOztcblxubGV0IGNvbXBhcmVfZWx0IHQgPSB0LmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmF0b3IgdCA9IHQuY29tcGFyYXRvclxuICBsZXQgY29tcGFyYXRvcl9zIHQgPSBDb21wYXJhdG9yLnRvX21vZHVsZSB0LmNvbXBhcmF0b3JcbiAgbGV0IGludmFyaWFudHMgdCA9IFRyZWUwLmludmFyaWFudHMgdC50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdClcbiAgbGV0IGxlbmd0aCB0ID0gVHJlZTAubGVuZ3RoIHQudHJlZVxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHQudHJlZVxuICBsZXQgZWxlbWVudHMgdCA9IFRyZWUwLmVsZW1lbnRzIHQudHJlZVxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0LnRyZWVcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0LnRyZWVcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdC50cmVlXG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdC50cmVlXG4gIGxldCBjaG9vc2UgdCA9IFRyZWUwLmNob29zZSB0LnRyZWVcbiAgbGV0IGNob29zZV9leG4gdCA9IFRyZWUwLmNob29zZV9leG4gdC50cmVlXG4gIGxldCB0b19saXN0IHQgPSBUcmVlMC50b19saXN0IHQudHJlZVxuICBsZXQgdG9fYXJyYXkgdCA9IFRyZWUwLnRvX2FycmF5IHQudHJlZVxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZCB0LnRyZWUgfmluaXQgfmZcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gVHJlZTAuZm9sZF91bnRpbCB0LnRyZWUgfmluaXQgfmYgfmZpbmlzaFxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0LnRyZWUgfmluaXQgfmZcbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0LnRyZWUgfmZcbiAgbGV0IGl0ZXIyIGEgYiB+ZiA9IFRyZWUwLml0ZXIyIGEudHJlZSBiLnRyZWUgfmYgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCBhKVxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdC50cmVlIH5mXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQudHJlZSB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQudHJlZSB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IFRyZWUwLnN1bSBtIHQudHJlZSB+ZlxuICBsZXQgZmluZCB0IH5mID0gVHJlZTAuZmluZCB0LnRyZWUgfmZcbiAgbGV0IGZpbmRfZXhuIHQgfmYgPSBUcmVlMC5maW5kX2V4biB0LnRyZWUgfmZcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBUcmVlMC5maW5kX21hcCB0LnRyZWUgfmZcbiAgbGV0IG1lbSB0IGEgPSBUcmVlMC5tZW0gdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuICBsZXQgZmlsdGVyIHQgfmYgPSBsaWtlX21heWJlX25vX29wIHQgKFRyZWUwLmZpbHRlciB0LnRyZWUgfmYpXG4gIGxldCBhZGQgdCBhID0gbGlrZSB0IChUcmVlMC5hZGQgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IHJlbW92ZSB0IGEgPSBsaWtlIHQgKFRyZWUwLnJlbW92ZSB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgdW5pb24gdDEgdDIgPSBsaWtlIHQxIChUcmVlMC51bmlvbiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSkpXG4gIGxldCBpbnRlciB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLmludGVyIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcbiAgbGV0IGRpZmYgdDEgdDIgPSBsaWtlIHQxIChUcmVlMC5kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB0MSB0MiA9IFRyZWUwLmNvbXBhcmUgKGNvbXBhcmVfZWx0IHQxKSB0MS50cmVlIHQyLnRyZWVcbiAgbGV0IGVxdWFsIHQxIHQyID0gVHJlZTAuZXF1YWwgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIGxldCBpc19zdWJzZXQgdCB+b2ZfID0gVHJlZTAuaXNfc3Vic2V0IHQudHJlZSB+b2ZfOm9mXy50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdClcblxuICBsZXQgYXJlX2Rpc2pvaW50IHQxIHQyID1cbiAgICBUcmVlMC5hcmVfZGlzam9pbnQgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIDs7XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgbGV0IHRvX25hbWVkX3RyZWUgKG5hbWVkIDogKF8sIF8pIHQgTmFtZWQudCkgPSB7IG5hbWVkIHdpdGggc2V0ID0gbmFtZWQuc2V0LnRyZWUgfVxuXG4gICAgbGV0IGlzX3N1YnNldCBzdWJzZXQgfm9mXzpzdXBlcnNldCA9XG4gICAgICBUcmVlMC5OYW1lZC5pc19zdWJzZXRcbiAgICAgICAgKHRvX25hbWVkX3RyZWUgc3Vic2V0KVxuICAgICAgICB+b2ZfOih0b19uYW1lZF90cmVlIHN1cGVyc2V0KVxuICAgICAgICB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHN1YnNldC5zZXQpXG4gICAgICAgIH5zZXhwX29mX2VsdDpzdWJzZXQuc2V0LmNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcblxuICAgIGxldCBlcXVhbCB0MSB0MiA9XG4gICAgICBPcl9lcnJvci5jb21iaW5lX2Vycm9yc191bml0IFsgaXNfc3Vic2V0IHQxIH5vZl86dDI7IGlzX3N1YnNldCB0MiB+b2ZfOnQxIF1cbiAgICA7O1xuXG4gICAgaW5jbHVkZSBOYW1lZFxuICBlbmRcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICAgIGxldCB0cmVlX3QsIHRyZWVfZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0LnRyZWUgfmYgaW5cbiAgICBsaWtlX21heWJlX25vX29wIHQgdHJlZV90LCBsaWtlX21heWJlX25vX29wIHQgdHJlZV9mXG4gIDs7XG5cbiAgbGV0IHNwbGl0IHQgYSA9XG4gICAgbGV0IHRyZWUxLCBiLCB0cmVlMiA9IFRyZWUwLnNwbGl0IHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkgaW5cbiAgICBsaWtlIHQgdHJlZTEsIGIsIGxpa2UgdCB0cmVlMlxuICA7O1xuXG4gIGxldCBzcGxpdF9sZV9ndCB0IGEgPVxuICAgIGxldCB0cmVlMSwgdHJlZTIgPSBUcmVlMC5zcGxpdF9sZV9ndCB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpIGluXG4gICAgbGlrZSB0IHRyZWUxLCBsaWtlIHQgdHJlZTJcbiAgOztcblxuICBsZXQgc3BsaXRfbHRfZ2UgdCBhID1cbiAgICBsZXQgdHJlZTEsIHRyZWUyID0gVHJlZTAuc3BsaXRfbHRfZ2UgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSBpblxuICAgIGxpa2UgdCB0cmVlMSwgbGlrZSB0IHRyZWUyXG4gIDs7XG5cbiAgbGV0IGdyb3VwX2J5IHQgfmVxdWl2ID0gTGlzdC5tYXAgKFRyZWUwLmdyb3VwX2J5IHQudHJlZSB+ZXF1aXYpIH5mOihsaWtlIHQpXG4gIGxldCBudGggdCBpID0gVHJlZTAubnRoIHQudHJlZSBpXG4gIGxldCByZW1vdmVfaW5kZXggdCBpID0gbGlrZSB0IChUcmVlMC5yZW1vdmVfaW5kZXggdC50cmVlIGkgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfYSB0LnRyZWVcblxuICBsZXQgdG9fc2VxdWVuY2UgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlIHQuY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdC50cmVlIH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0LnRyZWUgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0IHQnID1cbiAgICBUcmVlMC5tZXJnZV90b19zZXF1ZW5jZVxuICAgICAgdC5jb21wYXJhdG9yXG4gICAgICA/b3JkZXJcbiAgICAgID9ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgICAgdC50cmVlXG4gICAgICB0Jy50cmVlXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleSBzdGF0ZSB0ID1cbiAgICBUcmVlMC5oYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBzdGF0ZSB0LnRyZWVcbiAgOztcbmVuZFxuXG5pbmNsdWRlIEFjY2Vzc29yc1xuXG5sZXQgY29tcGFyZSBfIF8gdDEgdDIgPSBjb21wYXJlX2RpcmVjdCB0MSB0MlxuXG5tb2R1bGUgVHJlZSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2NvbXBhcmF0b3IpIHQgPSAoJ2EsICdjb21wYXJhdG9yKSB0cmVlXG5cbiAgbGV0IGNlIGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGFfb2Zfc2V4cCBzZXhwID1cbiAgICBUcmVlMC50X29mX3NleHBfZGlyZWN0IH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcikgYV9vZl9zZXhwIHNleHBcbiAgOztcblxuICBsZXQgZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiA9IFRyZWUwLmVtcHR5XG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvcjpfID0gZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvblxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yOl8gZSA9IFRyZWUwLnNpbmdsZXRvbiBlXG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0XG4gIGxldCBpbnZhcmlhbnRzIH5jb21wYXJhdG9yIHQgPSBUcmVlMC5pbnZhcmlhbnRzIHQgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHRcbiAgbGV0IGVsZW1lbnRzIHQgPSBUcmVlMC5lbGVtZW50cyB0XG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHRcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0XG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHRcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0XG4gIGxldCBjaG9vc2UgdCA9IFRyZWUwLmNob29zZSB0XG4gIGxldCBjaG9vc2VfZXhuIHQgPSBUcmVlMC5jaG9vc2VfZXhuIHRcbiAgbGV0IHRvX2xpc3QgdCA9IFRyZWUwLnRvX2xpc3QgdFxuICBsZXQgdG9fYXJyYXkgdCA9IFRyZWUwLnRvX2FycmF5IHRcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdCB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdCB+ZlxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0IH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IFRyZWUwLnN1bSBtIHQgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IFRyZWUwLmZpbmQgdCB+ZlxuICBsZXQgZmluZF9leG4gdCB+ZiA9IFRyZWUwLmZpbmRfZXhuIHQgfmZcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBUcmVlMC5maW5kX21hcCB0IH5mXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQgfmluaXQgfmZcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gVHJlZTAuZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdCB+aW5pdCB+ZlxuICBsZXQgbWFwIH5jb21wYXJhdG9yIHQgfmYgPSBUcmVlMC5tYXAgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBmaWx0ZXIgdCB+ZiA9IFRyZWUwLmZpbHRlciB0IH5mXG4gIGxldCBmaWx0ZXJfbWFwIH5jb21wYXJhdG9yIHQgfmYgPSBUcmVlMC5maWx0ZXJfbWFwIHQgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBUcmVlMC5wYXJ0aXRpb25fdGYgdCB+ZlxuICBsZXQgaXRlcjIgfmNvbXBhcmF0b3IgYSBiIH5mID0gVHJlZTAuaXRlcjIgYSBiIH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG1lbSB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5tZW0gdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGFkZCB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5hZGQgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHJlbW92ZSB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5yZW1vdmUgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHVuaW9uIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAudW5pb24gdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaW50ZXIgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5pbnRlciB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBkaWZmIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuZGlmZiB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuY29tcGFyZSAoY2UgY29tcGFyYXRvcikgdDEgdDJcbiAgbGV0IGVxdWFsIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuZXF1YWwgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaXNfc3Vic2V0IH5jb21wYXJhdG9yIHQgfm9mXyA9IFRyZWUwLmlzX3N1YnNldCB0IH5vZl8gfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBhcmVfZGlzam9pbnQgfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgIFRyZWUwLmFyZV9kaXNqb2ludCB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgfmNvbXBhcmF0b3IgbCA9IFRyZWUwLm9mX2xpc3QgbCB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzID0gVHJlZTAub2Zfc2VxdWVuY2UgcyB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBvZl9hcnJheSB+Y29tcGFyYXRvciBhID0gVHJlZTAub2ZfYXJyYXkgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYSA9XG4gICAgVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3I6XyB+bGVuIH5mID1cbiAgICBUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhID0gVHJlZTAub2Zfc29ydGVkX2FycmF5IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgdW5pb25fbGlzdCB+Y29tcGFyYXRvciBsID0gVHJlZTAudW5pb25fbGlzdCBsIH50b190cmVlOkZuLmlkIH5jb21wYXJhdG9yXG5cbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIHhzID1cbiAgICBUcmVlMC5zdGFibGVfZGVkdXBfbGlzdCB4cyB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IGdyb3VwX2J5IHQgfmVxdWl2ID0gVHJlZTAuZ3JvdXBfYnkgdCB+ZXF1aXZcbiAgbGV0IHNwbGl0IH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLnNwbGl0IHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBzcGxpdF9sZV9ndCB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5zcGxpdF9sZV9ndCB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgc3BsaXRfbHRfZ2UgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAuc3BsaXRfbHRfZ2UgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG50aCB0IGkgPSBUcmVlMC5udGggdCBpXG4gIGxldCByZW1vdmVfaW5kZXggfmNvbXBhcmF0b3IgdCBpID0gVHJlZTAucmVtb3ZlX2luZGV4IHQgaSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2EgdFxuICBsZXQgdG9fdHJlZSB0ID0gdFxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvcjpfIHQgPSB0XG5cbiAgbGV0IHRvX3NlcXVlbmNlIH5jb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZSBjb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggfmNvbXBhcmF0b3I6XyB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIH5jb21wYXJhdG9yOl8gdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlIH5jb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0IHQnID1cbiAgICBUcmVlMC5tZXJnZV90b19zZXF1ZW5jZSBjb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0IHQnXG4gIDs7XG5cbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxuXG4gIG1vZHVsZSBOYW1lZCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVHJlZTAuTmFtZWRcblxuICAgIGxldCBpc19zdWJzZXQgfmNvbXBhcmF0b3IgdDEgfm9mXzp0MiA9XG4gICAgICBUcmVlMC5OYW1lZC5pc19zdWJzZXRcbiAgICAgICAgdDFcbiAgICAgICAgfm9mXzp0MlxuICAgICAgICB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gICAgICAgIH5zZXhwX29mX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcblxuICAgIGxldCBlcXVhbCB+Y29tcGFyYXRvciB0MSB0MiA9XG4gICAgICBUcmVlMC5OYW1lZC5lcXVhbFxuICAgICAgICB0MVxuICAgICAgICB0MlxuICAgICAgICB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gICAgICAgIH5zZXhwX29mX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcbiAgZW5kXG5lbmRcblxubW9kdWxlIFVzaW5nX2NvbXBhcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdlbHQsICdjbXApIHQgPSAoJ2VsdCwgJ2NtcCkgdFxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHRvX3RyZWUgdCA9IHQudHJlZVxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID0geyBjb21wYXJhdG9yOyB0cmVlIH1cblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBhX29mX3NleHAgc2V4cCA9XG4gICAgb2ZfdHJlZVxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC50X29mX3NleHBfZGlyZWN0IH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLmNvbXBhcmUgYV9vZl9zZXhwIHNleHApXG4gIDs7XG5cbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuZW1wdHkgfVxuXG4gIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChFbHQgOiBDb21wYXJhdG9yLlMxKSA9IHN0cnVjdFxuICAgIGxldCBlbXB0eSA9IHsgY29tcGFyYXRvciA9IEVsdC5jb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuZW1wdHkgfVxuICBlbmRcblxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yIGUgPSB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5zaW5nbGV0b24gZSB9XG5cbiAgbGV0IHVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgbCA9XG4gICAgb2ZfdHJlZSB+Y29tcGFyYXRvciAoVHJlZTAudW5pb25fbGlzdCB+Y29tcGFyYXRvciB+dG9fdHJlZSBsKVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBsZXQgdHJlZSA9XG4gICAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgeyBjb21wYXJhdG9yOyB0cmVlIH1cbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3IgfmxlbiB+ZiA9XG4gICAgb2ZfdHJlZSB+Y29tcGFyYXRvciAoVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZilcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBPcl9lcnJvci5Nb25hZF9pbmZpeC4oXG4gICAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICA+PnwgZnVuIHRyZWUgLT4geyBjb21wYXJhdG9yOyB0cmVlIH0pXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgfmNvbXBhcmF0b3IgbCA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAub2ZfbGlzdCBsIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHMgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX3NlcXVlbmNlIHMgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgb2ZfYXJyYXkgfmNvbXBhcmF0b3IgYSA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAub2ZfYXJyYXkgYSB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvciB4cyA9XG4gICAgVHJlZTAuc3RhYmxlX2RlZHVwX2xpc3QgeHMgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IG1hcCB+Y29tcGFyYXRvciB0IH5mID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5tYXAgdC50cmVlIH5mIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgeyBjb21wYXJhdG9yXG4gICAgOyB0cmVlID0gVHJlZTAuZmlsdGVyX21hcCB0LnRyZWUgfmYgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfVxuICA7O1xuXG4gIG1vZHVsZSBUcmVlID0gVHJlZVxuZW5kXG5cbmxldCB0b19jb21wYXJhdG9yID0gQ29tcGFyYXRvci5vZl9tb2R1bGVcbmxldCBlbXB0eSBtID0gVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxubGV0IHNpbmdsZXRvbiBtIGEgPSBVc2luZ19jb21wYXJhdG9yLnNpbmdsZXRvbiB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgdW5pb25fbGlzdCBtIGEgPSBVc2luZ19jb21wYXJhdG9yLnVuaW9uX2xpc3QgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuOztcblxubGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIG0gfmxlbiB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgfmxlbiB+ZlxuOztcblxubGV0IG9mX3NvcnRlZF9hcnJheSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfbGlzdCBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3QgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX3NlcXVlbmNlIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYXJyYXkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgc3RhYmxlX2RlZHVwX2xpc3QgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5zdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgbWFwIG0gYSB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcbmxldCBmaWx0ZXJfbWFwIG0gYSB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IuZmlsdGVyX21hcCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhIH5mXG5sZXQgdG9fdHJlZSA9IFVzaW5nX2NvbXBhcmF0b3IudG9fdHJlZVxubGV0IG9mX3RyZWUgbSB0ID0gVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHRcblxubW9kdWxlIE0gKEVsdCA6IHNpZ1xuICB0eXBlIHRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZCkgPVxuc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSAoRWx0LnQsIEVsdC5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBlbHQpIHQgPVxuICBzZXhwX29mX3QgRWx0LnNleHBfb2ZfdCAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwXG4gICh0eXBlIGVsdCBjbXApXG4gIChtb2R1bGUgRWx0IDogTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gZWx0IGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcClcbiAgc2V4cFxuICA9XG4gIFVzaW5nX2NvbXBhcmF0b3IudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvcjpFbHQuY29tcGFyYXRvciBFbHQudF9vZl9zZXhwIHNleHBcbjs7XG5cbmxldCBtX190X3NleHBfZ3JhbW1hciAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBlbHQpXG4gIDogKGVsdCwgXykgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKGxpc3Rfc2V4cF9ncmFtbWFyIEVsdC50X3NleHBfZ3JhbW1hcilcbjs7XG5cbmxldCBjb21wYXJlX21fX3QgKG1vZHVsZSBfIDogQ29tcGFyZV9tKSB0MSB0MiA9IGNvbXBhcmVfZGlyZWN0IHQxIHQyXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSB0MSB0MiA9IGVxdWFsIHQxIHQyXG5cbmxldCBoYXNoX2ZvbGRfbV9fdCAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSBlbHQpIHN0YXRlID1cbiAgaGFzaF9mb2xkX2RpcmVjdCBFbHQuaGFzaF9mb2xkX3Qgc3RhdGVcbjs7XG5cbmxldCBoYXNoX21fX3QgZm9sZGVyIHQgPVxuICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfbV9fdCBmb2xkZXIgKEhhc2guY3JlYXRlICgpKSB0IGluXG4gIEhhc2guZ2V0X2hhc2hfdmFsdWUgc3RhdGVcbjs7XG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzc1xuICB0eXBlIG5vbnJlYyAnZWx0IHQgPSAoJ2VsdCwgY29tcGFyYXRvcl93aXRuZXNzKSB0XG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgY29tcGFyYXRvciA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yXG5cbiAgaW5jbHVkZSBVc2luZ19jb21wYXJhdG9yLkVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKENvbXBhcmF0b3IuUG9seSlcblxuICBsZXQgc2luZ2xldG9uIGEgPSBVc2luZ19jb21wYXJhdG9yLnNpbmdsZXRvbiB+Y29tcGFyYXRvciBhXG4gIGxldCB1bmlvbl9saXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLnVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgYVxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGEgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3IgfmxlbiB+ZlxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2xpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdCB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9zZXF1ZW5jZSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hcnJheSB+Y29tcGFyYXRvciBhXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci5zdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvciBhXG4gIGxldCBtYXAgYSB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwIH5jb21wYXJhdG9yIGEgfmZcbiAgbGV0IGZpbHRlcl9tYXAgYSB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IuZmlsdGVyX21hcCB+Y29tcGFyYXRvciBhIH5mXG4gIGxldCBvZl90cmVlIHRyZWUgPSB7IGNvbXBhcmF0b3I7IHRyZWUgfVxuICBsZXQgdG9fdHJlZSB0ID0gdC50cmVlXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5pbmNsdWRlIChcbiAgc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgcmVmXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IGNvbXBhcmVfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX3JlZl9fbG9jYWxcbiAgICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9yZWZcbiAgICBsZXQgZXF1YWxfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9IGVxdWFsX3JlZl9fbG9jYWxcbiAgICBsZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID0gZXF1YWxfcmVmXG5cbiAgICBsZXQgZ2xvYmFsaXplIDogJ2EuICgnYSAtPiAnYSkgLT4gJ2EgdCAtPiAnYSB0ID1cbiAgICAgIGZ1biAodHlwZSBhX18wMTdfKSA6ICgoYV9fMDE3XyAtPiBhX18wMTdfKSAtPiBhX18wMTdfIHQgLT4gYV9fMDE3XyB0KSAtPlxuICAgICAgZ2xvYmFsaXplX3JlZlxuICAgIDs7XG5cbiAgICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gcmVmX29mX3NleHBcbiAgICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9yZWZcblxuICAgIGxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IHJlZl9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuICBlbmQgOlxuICAgIHNpZ1xuICAgICAgdHlwZSAnYSB0ID0gJ2EgcmVmXG4gICAgICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICAgICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICAgICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TX2xvY2FsMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gICAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gICAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TX2xvY2FsMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICAgIHZhbCBnbG9iYWxpemUgOiAoJ2EgLT4gJ2EpIC0+ICdhIHQgLT4gJ2EgdFxuXG4gICAgICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgICAgdmFsIHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgICBbQEBAZW5kXVxuICAgIGVuZClcblxuKCogSW4gdGhlIGRlZmluaXRpb24gb2YgW3RdLCB3ZSBkbyBub3QgaGF2ZSBbW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1dIGJlY2F1c2VcbiAgIGluIGdlbmVyYWwsIHN5bnRheCBleHRlbnNpb25zIHRlbmQgdG8gdXNlIHRoZSBpbXBsZW1lbnRhdGlvbiB3aGVuIGF2YWlsYWJsZSByYXRoZXIgdGhhblxuICAgdXNpbmcgdGhlIGFsaWFzLiAgSGVyZSB0aGF0IHdvdWxkIGxlYWQgdG8gdXNlIHRoZSByZWNvcmQgcmVwcmVzZW50YXRpb24gWyB7IG11dGFibGVcbiAgIGNvbnRlbnRzIDogJ2EgfSBdIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBkaWZmZXJlbnQgKGFuZCB1bndhbnRlZCkgYmVoYXZpb3IuICAqKVxudHlwZSAnYSB0ID0gJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuXG5leHRlcm5hbCBjcmVhdGUgOiAnYSAtPiAoJ2EgdFtAbG9jYWxfb3B0XSkgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICgnYSB0W0Bsb2NhbF9vcHRdKSAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAoJ2EgdFtAbG9jYWxfb3B0XSkgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbmxldCBzd2FwIHQxIHQyID1cbiAgbGV0IHRtcCA9ICF0MSBpblxuICB0MSA6PSAhdDI7XG4gIHQyIDo9IHRtcFxuOztcblxubGV0IHJlcGxhY2UgdCBmID0gdCA6PSBmICF0XG5cbmxldCBzZXRfdGVtcG9yYXJpbHkgdCBhIH5mID1cbiAgbGV0IHJlc3RvcmVfdG8gPSAhdCBpblxuICB0IDo9IGE7XG4gIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gdCA6PSByZXN0b3JlX3RvKVxuOztcblxubW9kdWxlIEFuZF92YWx1ZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBUIDogJ2EgcmVmICogJ2EgLT4gdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBzZXQgKFQgKHIsIGEpKSA9IHIgOj0gYVxuICBsZXQgc2V0cyB0cyA9IExpc3QuaXRlciB0cyB+ZjpzZXRcbiAgbGV0IHNuYXBzaG90IChUIChyLCBfKSkgPSBUIChyLCAhcilcbiAgbGV0IHNuYXBzaG90cyB0cyA9IExpc3QubWFwIHRzIH5mOnNuYXBzaG90XG5lbmRcblxubGV0IHNldHNfdGVtcG9yYXJpbHkgYW5kX3ZhbHVlcyB+ZiA9XG4gIGxldCByZXN0b3JlX3RvID0gQW5kX3ZhbHVlLnNuYXBzaG90cyBhbmRfdmFsdWVzIGluXG4gIEFuZF92YWx1ZS5zZXRzIGFuZF92YWx1ZXM7XG4gIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gQW5kX3ZhbHVlLnNldHMgcmVzdG9yZV90bylcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuKCogW3RdIHN0b3JlcyB0aGUgW3QubGVuZ3RoXSBxdWV1ZSBlbGVtZW50cyBhdCBjb25zZWN1dGl2ZSBpbmNyZWFzaW5nIGluZGljZXMgb2YgW3QuZWx0c10sXG4gICBtb2QgdGhlIGNhcGFjaXR5IG9mIFt0XSwgd2hpY2ggaXMgW09wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzXS4gIFRoZSBjYXBhY2l0eSBpc1xuICAgcmVxdWlyZWQgdG8gYmUgYSBwb3dlciBvZiB0d28gKHVzZXItcmVxdWVzdGVkIGNhcGFjaXRpZXMgYXJlIHJvdW5kZWQgdXAgdG8gdGhlIG5lYXJlc3RcbiAgIHBvd2VyKSwgc28gdGhhdCBtb2QgY2FuIHF1aWNrbHkgYmUgY29tcHV0ZWQgdXNpbmcgW2xhbmQgdC5tYXNrXSwgd2hlcmUgW3QubWFzayA9XG4gICBjYXBhY2l0eSB0IC0gMV0uICBTbywgcXVldWUgZWxlbWVudCBbaV0gaXMgYXQgW3QuZWx0cy4oICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2sgKV0uXG5cbiAgIFtudW1fbXV0YXRpb25zXSBpcyB1c2VkIHRvIGRldGVjdCBtb2RpZmljYXRpb24gZHVyaW5nIGl0ZXJhdGlvbi4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgbXV0YWJsZSBudW1fbXV0YXRpb25zIDogaW50XG4gIDsgbXV0YWJsZSBmcm9udCA6IGludFxuICA7IG11dGFibGUgbWFzayA6IGludFxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgbXV0YWJsZSBlbHRzIDogJ2EgT3B0aW9uX2FycmF5LnRcbiAgfVxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwMV9cbiAgICAgIHsgbnVtX211dGF0aW9ucyA9IG51bV9tdXRhdGlvbnNfXzAwM19cbiAgICAgIDsgZnJvbnQgPSBmcm9udF9fMDA1X1xuICAgICAgOyBtYXNrID0gbWFza19fMDA3X1xuICAgICAgOyBsZW5ndGggPSBsZW5ndGhfXzAwOV9cbiAgICAgIDsgZWx0cyA9IGVsdHNfXzAxMV9cbiAgICAgIH0gLT5cbiAgbGV0IGJuZHNfXzAwMl8gPSAoW10gOiBfIFN0ZGxpYi5MaXN0LnQpIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMTJfID0gT3B0aW9uX2FycmF5LnNleHBfb2ZfdCBfb2ZfYV9fMDAxXyBlbHRzX18wMTFfIGluXG4gICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImVsdHNcIjsgYXJnX18wMTJfIF0gOjogYm5kc19fMDAyX1xuICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMTBfID0gc2V4cF9vZl9pbnQgbGVuZ3RoX18wMDlfIGluXG4gICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxlbmd0aFwiOyBhcmdfXzAxMF8gXSA6OiBibmRzX18wMDJfXG4gICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwOF8gPSBzZXhwX29mX2ludCBtYXNrX18wMDdfIGluXG4gICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIm1hc2tcIjsgYXJnX18wMDhfIF0gOjogYm5kc19fMDAyX1xuICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMDZfID0gc2V4cF9vZl9pbnQgZnJvbnRfXzAwNV8gaW5cbiAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZnJvbnRcIjsgYXJnX18wMDZfIF0gOjogYm5kc19fMDAyX1xuICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMDRfID0gc2V4cF9vZl9pbnQgbnVtX211dGF0aW9uc19fMDAzXyBpblxuICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJudW1fbXV0YXRpb25zXCI7IGFyZ19fMDA0XyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICBpblxuICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAyX1xuOztcblxuW0BAQGVuZF1cblxubGV0IGdsb2JhbGl6ZSBfIHQgPVxuICB7IG51bV9tdXRhdGlvbnMgPSB0Lm51bV9tdXRhdGlvbnNcbiAgOyBmcm9udCA9IHQuZnJvbnRcbiAgOyBtYXNrID0gdC5tYXNrXG4gIDsgbGVuZ3RoID0gdC5sZW5ndGhcbiAgOyBlbHRzID0gT3B0aW9uX2FycmF5LmNvcHkgdC5lbHRzXG4gIH1cbjs7XG5cbm1vZHVsZSB0eXBlIFMgPSBRdWV1ZV9pbnRmLlNcblxubGV0IGluY19udW1fbXV0YXRpb25zIHQgPSB0Lm51bV9tdXRhdGlvbnMgPC0gdC5udW1fbXV0YXRpb25zICsgMVxubGV0IGNhcGFjaXR5IHQgPSB0Lm1hc2sgKyAxXG5sZXQgZWx0c19pbmRleCB0IGkgPSAodC5mcm9udCArIGkpIGxhbmQgdC5tYXNrXG5sZXQgdW5zYWZlX2dldCB0IGkgPSBPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKVxubGV0IHVuc2FmZV9pc19zZXQgdCBpID0gT3B0aW9uX2FycmF5LnVuc2FmZV9pc19zb21lIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpXG5sZXQgdW5zYWZlX3NldCB0IGkgYSA9IE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSkgYVxubGV0IHVuc2FmZV91bnNldCB0IGkgPSBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9ub25lIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpXG5cbmxldCBjaGVja19pbmRleF9leG4gdCBpID1cbiAgaWYgaSA8IDAgfHwgaSA+PSB0Lmxlbmd0aFxuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJRdWV1ZSBpbmRleCBvdXQgb2YgYm91bmRzXCJcbiAgICAgICAgIFsgXCJpbmRleFwiLCBpIHw+IEludC5zZXhwX29mX3Q7IFwibGVuZ3RoXCIsIHQubGVuZ3RoIHw+IEludC5zZXhwX29mX3QgXSlcbjs7XG5cbmxldCBnZXQgdCBpID1cbiAgY2hlY2tfaW5kZXhfZXhuIHQgaTtcbiAgdW5zYWZlX2dldCB0IGlcbjs7XG5cbmxldCBzZXQgdCBpIGEgPVxuICBjaGVja19pbmRleF9leG4gdCBpO1xuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICB1bnNhZmVfc2V0IHQgaSBhXG47O1xuXG5sZXQgaXNfZW1wdHkgdCA9IHQubGVuZ3RoID0gMFxubGV0IGxlbmd0aCB7IGxlbmd0aDsgXyB9ID0gbGVuZ3RoXG5cbmxldFtAY29sZF0gW0BpbmxpbmUgbmV2ZXJdIHJhaXNlX211dGF0aW9uX2R1cmluZ19pdGVyYXRpb24gdCA9XG4gIEVycm9yLnJhaXNlX3NcbiAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgXCJtdXRhdGlvbiBvZiBxdWV1ZSBkdXJpbmcgaXRlcmF0aW9uXCJcbiAgICAgICBbIFwiXCIsIHQgfD4gZ2xvYmFsaXplICgpIHw+IHNleHBfb2ZfdCAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSBdKVxuOztcblxubGV0IGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnMgPVxuICBpZiB0Lm51bV9tdXRhdGlvbnMgPD4gbnVtX211dGF0aW9ucyB0aGVuIHJhaXNlX211dGF0aW9uX2R1cmluZ19pdGVyYXRpb24gdFxuOztcblxubGV0IGNvbXBhcmVfX2xvY2FsID1cbiAgbGV0IHJlYyB1bnNhZmVfY29tcGFyZV9mcm9tIGNvbXBhcmVfZWx0IHBvcyB+dDEgfnQyIH5sZW4xIH5sZW4yIH5tdXQxIH5tdXQyID1cbiAgICBtYXRjaCBwb3MgPSBsZW4xLCBwb3MgPSBsZW4yIHdpdGhcbiAgICB8IHRydWUsIHRydWUgLT4gMFxuICAgIHwgdHJ1ZSwgZmFsc2UgLT4gLTFcbiAgICB8IGZhbHNlLCB0cnVlIC0+IDFcbiAgICB8IGZhbHNlLCBmYWxzZSAtPlxuICAgICAgbGV0IHggPSBjb21wYXJlX2VsdCAodW5zYWZlX2dldCB0MSBwb3MpICh1bnNhZmVfZ2V0IHQyIHBvcykgaW5cbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MSBtdXQxO1xuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQyIG11dDI7XG4gICAgICAobWF0Y2ggeCB3aXRoXG4gICAgICAgfCAwIC0+IHVuc2FmZV9jb21wYXJlX2Zyb20gY29tcGFyZV9lbHQgKHBvcyArIDEpIH50MSB+dDIgfmxlbjEgfmxlbjIgfm11dDEgfm11dDJcbiAgICAgICB8IG4gLT4gbilcbiAgaW5cbiAgZnVuIGNvbXBhcmVfZWx0IHQxIHQyIC0+XG4gICAgaWYgcGh5c19lcXVhbCB0MSB0MlxuICAgIHRoZW4gMFxuICAgIGVsc2VcbiAgICAgIHVuc2FmZV9jb21wYXJlX2Zyb21cbiAgICAgICAgY29tcGFyZV9lbHRcbiAgICAgICAgMFxuICAgICAgICB+dDFcbiAgICAgICAgfnQyXG4gICAgICAgIH5sZW4xOnQxLmxlbmd0aFxuICAgICAgICB+bGVuMjp0Mi5sZW5ndGhcbiAgICAgICAgfm11dDE6dDEubnVtX211dGF0aW9uc1xuICAgICAgICB+bXV0Mjp0Mi5udW1fbXV0YXRpb25zXG47O1xuXG5sZXQgY29tcGFyZSBjb21wYXJlX2VsdCB0MSB0MiA9IGNvbXBhcmVfX2xvY2FsIGNvbXBhcmVfZWx0IHQxIHQyXG5cbmxldCBlcXVhbF9fbG9jYWwgPVxuICBsZXQgcmVjIHVuc2FmZV9lcXVhbF9mcm9tIGVxdWFsX2VsdCBwb3MgfnQxIH50MiB+bXV0MSB+bXV0MiB+bGVuID1cbiAgICBwb3MgPSBsZW5cbiAgICB8fFxuICAgIGxldCBiID0gZXF1YWxfZWx0ICh1bnNhZmVfZ2V0IHQxIHBvcykgKHVuc2FmZV9nZXQgdDIgcG9zKSBpblxuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MSBtdXQxO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MiBtdXQyO1xuICAgIGIgJiYgdW5zYWZlX2VxdWFsX2Zyb20gZXF1YWxfZWx0IChwb3MgKyAxKSB+dDEgfnQyIH5tdXQxIH5tdXQyIH5sZW5cbiAgaW5cbiAgZnVuIGVxdWFsX2VsdCB0MSB0MiAtPlxuICAgIHBoeXNfZXF1YWwgdDEgdDJcbiAgICB8fFxuICAgIGxldCBsZW4xID0gdDEubGVuZ3RoIGluXG4gICAgbGV0IGxlbjIgPSB0Mi5sZW5ndGggaW5cbiAgICBsZW4xID0gbGVuMlxuICAgICYmIHVuc2FmZV9lcXVhbF9mcm9tXG4gICAgICAgICBlcXVhbF9lbHRcbiAgICAgICAgIDBcbiAgICAgICAgIH50MVxuICAgICAgICAgfnQyXG4gICAgICAgICB+bGVuOmxlbjFcbiAgICAgICAgIH5tdXQxOnQxLm51bV9tdXRhdGlvbnNcbiAgICAgICAgIH5tdXQyOnQyLm51bV9tdXRhdGlvbnNcbjs7XG5cbmxldCBlcXVhbCBlcXVhbF9lbHQgdDEgdDIgPSBlcXVhbF9fbG9jYWwgZXF1YWxfZWx0IHQxIHQyXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIGxldCB7IG51bV9tdXRhdGlvbnM7IG1hc2sgPSBfOyBlbHRzOyBmcm9udDsgbGVuZ3RoIH0gPSB0IGluXG4gIGFzc2VydCAoZnJvbnQgPj0gMCk7XG4gIGFzc2VydCAoZnJvbnQgPCBjYXBhY2l0eSB0KTtcbiAgbGV0IGNhcGFjaXR5ID0gY2FwYWNpdHkgdCBpblxuICBhc3NlcnQgKGNhcGFjaXR5ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCBlbHRzKTtcbiAgYXNzZXJ0IChjYXBhY2l0eSA+PSAxKTtcbiAgYXNzZXJ0IChJbnQuaXNfcG93MiBjYXBhY2l0eSk7XG4gIGFzc2VydCAobGVuZ3RoID49IDApO1xuICBhc3NlcnQgKGxlbmd0aCA8PSBjYXBhY2l0eSk7XG4gIGZvciBpID0gMCB0byBjYXBhY2l0eSAtIDEgZG9cbiAgICBpZiBpIDwgdC5sZW5ndGhcbiAgICB0aGVuIChcbiAgICAgIGludmFyaWFudF9hICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zKVxuICAgIGVsc2UgYXNzZXJ0IChub3QgKHVuc2FmZV9pc19zZXQgdCBpKSlcbiAgZG9uZVxuOztcblxubGV0IGNyZWF0ZSAodHlwZSBhKSA/Y2FwYWNpdHkgKCkgOiBhIHQgPVxuICBsZXQgY2FwYWNpdHkgPVxuICAgIG1hdGNoIGNhcGFjaXR5IHdpdGhcbiAgICB8IE5vbmUgLT4gMlxuICAgIHwgU29tZSBjYXBhY2l0eSAtPlxuICAgICAgaWYgY2FwYWNpdHkgPCAwXG4gICAgICB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgXCJjYW5ub3QgaGF2ZSBxdWV1ZSB3aXRoIG5lZ2F0aXZlIGNhcGFjaXR5XCJcbiAgICAgICAgICAgICBbIFwiY2FwYWNpdHlcIiwgY2FwYWNpdHkgfD4gSW50LnNleHBfb2ZfdCBdKVxuICAgICAgZWxzZSBpZiBjYXBhY2l0eSA9IDBcbiAgICAgIHRoZW4gMVxuICAgICAgZWxzZSBJbnQuY2VpbF9wb3cyIGNhcGFjaXR5XG4gIGluXG4gIHsgbnVtX211dGF0aW9ucyA9IDBcbiAgOyBmcm9udCA9IDBcbiAgOyBtYXNrID0gY2FwYWNpdHkgLSAxXG4gIDsgbGVuZ3RoID0gMFxuICA7IGVsdHMgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46Y2FwYWNpdHlcbiAgfVxuOztcblxubGV0IGJsaXRfdG9fYXJyYXkgfnNyYyBkc3QgPVxuICBhc3NlcnQgKHNyYy5sZW5ndGggPD0gT3B0aW9uX2FycmF5Lmxlbmd0aCBkc3QpO1xuICBsZXQgZnJvbnRfbGVuID0gSW50Lm1pbiBzcmMubGVuZ3RoIChjYXBhY2l0eSBzcmMgLSBzcmMuZnJvbnQpIGluXG4gIGxldCByZXN0X2xlbiA9IHNyYy5sZW5ndGggLSBmcm9udF9sZW4gaW5cbiAgT3B0aW9uX2FycmF5LmJsaXQgfmxlbjpmcm9udF9sZW4gfnNyYzpzcmMuZWx0cyB+c3JjX3BvczpzcmMuZnJvbnQgfmRzdCB+ZHN0X3BvczowO1xuICBPcHRpb25fYXJyYXkuYmxpdCB+bGVuOnJlc3RfbGVuIH5zcmM6c3JjLmVsdHMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOmZyb250X2xlblxuOztcblxubGV0IHNldF9jYXBhY2l0eV9pbnRlcm5hbCB0IG5ld19jYXBhY2l0eSA9XG4gIGxldCBkc3QgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46bmV3X2NhcGFjaXR5IGluXG4gIGJsaXRfdG9fYXJyYXkgfnNyYzp0IGRzdDtcbiAgdC5mcm9udCA8LSAwO1xuICB0Lm1hc2sgPC0gbmV3X2NhcGFjaXR5IC0gMTtcbiAgdC5lbHRzIDwtIGRzdFxuOztcblxubGV0IHNldF9jYXBhY2l0eSB0IGRlc2lyZWRfY2FwYWNpdHkgPVxuICAoKiBXZSBhbGxvdyBhcmd1bWVudHMgbGVzcyB0aGFuIDEgdG8gW3NldF9jYXBhY2l0eV0sIGJ1dCB0cmFuc2xhdGUgdGhlbSB0byAxIHRvIHNpbXBsaWZ5XG4gICAgIHRoZSBjb2RlIHRoYXQgcmVsaWVzIG9uIHRoZSBhcnJheSBsZW5ndGggYmVpbmcgYSBwb3dlciBvZiAyLiAqKVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBsZXQgbmV3X2NhcGFjaXR5ID0gSW50LmNlaWxfcG93MiAobWF4IDEgKG1heCBkZXNpcmVkX2NhcGFjaXR5IHQubGVuZ3RoKSkgaW5cbiAgaWYgbmV3X2NhcGFjaXR5IDw+IGNhcGFjaXR5IHQgdGhlbiBzZXRfY2FwYWNpdHlfaW50ZXJuYWwgdCBuZXdfY2FwYWNpdHlcbjs7XG5cbmxldCBlbnF1ZXVlIHQgYSA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGlmIHQubGVuZ3RoID0gY2FwYWNpdHkgdCB0aGVuIHNldF9jYXBhY2l0eV9pbnRlcm5hbCB0ICgyICogdC5sZW5ndGgpO1xuICB1bnNhZmVfc2V0IHQgdC5sZW5ndGggYTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxXG47O1xuXG5sZXQgZW5xdWV1ZV9mcm9udCB0IGEgPVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBpZiB0Lmxlbmd0aCA9IGNhcGFjaXR5IHQgdGhlbiBzZXRfY2FwYWNpdHlfaW50ZXJuYWwgdCAoMiAqIHQubGVuZ3RoKTtcbiAgbGV0IGZyb250ID0gKHQuZnJvbnQgLSAxKSBsYW5kIHQubWFzayBpblxuICB0LmZyb250IDwtIGZyb250O1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDE7XG4gIHVuc2FmZV9zZXQgdCAwIGFcbjs7XG5cbmxldCBkZXF1ZXVlX25vbmVtcHR5IHQgPVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBsZXQgZWx0cyA9IHQuZWx0cyBpblxuICBsZXQgZnJvbnQgPSB0LmZyb250IGluXG4gIGxldCByZXMgPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIGVsdHMgZnJvbnQgaW5cbiAgT3B0aW9uX2FycmF5LnNldF9ub25lIGVsdHMgZnJvbnQ7XG4gIHQuZnJvbnQgPC0gZWx0c19pbmRleCB0IDE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMTtcbiAgcmVzXG47O1xuXG5sZXQgYmFja19pbmRleCB0ID0gZWx0c19pbmRleCB0ICh0Lmxlbmd0aCAtIDEpXG5cbmxldCBkZXF1ZXVlX2JhY2tfbm9uZW1wdHkgdCA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGxldCBlbHRzID0gdC5lbHRzIGluXG4gIGxldCBiYWNrID0gYmFja19pbmRleCB0IGluXG4gIGxldCByZXMgPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIGVsdHMgYmFjayBpblxuICBPcHRpb25fYXJyYXkuc2V0X25vbmUgZWx0cyBiYWNrO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gIHJlc1xuOztcblxubGV0IGRlcXVldWVfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgU3RkbGliLlF1ZXVlLkVtcHR5IGVsc2UgZGVxdWV1ZV9ub25lbXB0eSB0XG5sZXQgZGVxdWV1ZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChkZXF1ZXVlX25vbmVtcHR5IHQpXG5sZXQgZGVxdWV1ZV9hbmRfaWdub3JlX2V4biAodHlwZSBlbHQpICh0IDogZWx0IHQpID0gaWdub3JlIChkZXF1ZXVlX2V4biB0IDogZWx0KVxuXG5sZXQgZGVxdWV1ZV9iYWNrX2V4biB0ID1cbiAgaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIFN0ZGxpYi5RdWV1ZS5FbXB0eSBlbHNlIGRlcXVldWVfYmFja19ub25lbXB0eSB0XG47O1xuXG5sZXQgZGVxdWV1ZV9iYWNrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGRlcXVldWVfYmFja19ub25lbXB0eSB0KVxubGV0IGZyb250X25vbmVtcHR5IHQgPSBPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biB0LmVsdHMgdC5mcm9udFxubGV0IGJhY2tfbm9uZW1wdHkgdCA9IE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHQuZWx0cyAoYmFja19pbmRleCB0KVxubGV0IGxhc3Rfbm9uZW1wdHkgdCA9IHVuc2FmZV9nZXQgdCAodC5sZW5ndGggLSAxKVxubGV0IHBlZWsgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoZnJvbnRfbm9uZW1wdHkgdClcbmxldCBwZWVrX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIFN0ZGxpYi5RdWV1ZS5FbXB0eSBlbHNlIGZyb250X25vbmVtcHR5IHRcbmxldCBwZWVrX2JhY2sgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoYmFja19ub25lbXB0eSB0KVxubGV0IHBlZWtfYmFja19leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBTdGRsaWIuUXVldWUuRW1wdHkgZWxzZSBiYWNrX25vbmVtcHR5IHRcbmxldCBsYXN0IHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGxhc3Rfbm9uZW1wdHkgdClcbmxldCBsYXN0X2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIFN0ZGxpYi5RdWV1ZS5FbXB0eSBlbHNlIGxhc3Rfbm9uZW1wdHkgdFxuXG5sZXQgZHJhaW4gdCB+ZiB+d2hpbGVfID1cbiAgd2hpbGUgKG5vdCAoaXNfZW1wdHkgdCkpICYmIHdoaWxlXyAoZnJvbnRfbm9uZW1wdHkgdCkgZG9cbiAgICBmIChkZXF1ZXVlX25vbmVtcHR5IHQpXG4gIGRvbmVcbjs7XG5cbmxldCBjbGVhciB0ID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgaWYgdC5sZW5ndGggPiAwXG4gIHRoZW4gKFxuICAgIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgIHVuc2FmZV91bnNldCB0IGlcbiAgICBkb25lO1xuICAgIHQubGVuZ3RoIDwtIDA7XG4gICAgdC5mcm9udCA8LSAwKVxuOztcblxubGV0IGJsaXRfdHJhbnNmZXIgfnNyYyB+ZHN0ID9sZW4gKCkgPVxuICBpbmNfbnVtX211dGF0aW9ucyBzcmM7XG4gIGluY19udW1fbXV0YXRpb25zIGRzdDtcbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IE5vbmUgLT4gc3JjLmxlbmd0aFxuICAgIHwgU29tZSBsZW4gLT5cbiAgICAgIGlmIGxlbiA8IDBcbiAgICAgIHRoZW5cbiAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICBcIlF1ZXVlLmJsaXRfdHJhbnNmZXI6IG5lZ2F0aXZlIGxlbmd0aFwiXG4gICAgICAgICAgICAgWyBcImxlbmd0aFwiLCBsZW4gfD4gSW50LnNleHBfb2ZfdCBdKTtcbiAgICAgIG1pbiBsZW4gc3JjLmxlbmd0aFxuICBpblxuICBpZiBsZW4gPiAwXG4gIHRoZW4gKFxuICAgIHNldF9jYXBhY2l0eSBkc3QgKG1heCAoY2FwYWNpdHkgZHN0KSAoZHN0Lmxlbmd0aCArIGxlbikpO1xuICAgIGxldCBkc3Rfc3RhcnQgPSBkc3QuZnJvbnQgKyBkc3QubGVuZ3RoIGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICgqIFRoaXMgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiBzaW1wbHkgW2VucXVldWUgZHN0IChkZXF1ZXVlX25vbmVtcHR5IHNyYyldICopXG4gICAgICBsZXQgc3JjX2kgPSAoc3JjLmZyb250ICsgaSkgbGFuZCBzcmMubWFzayBpblxuICAgICAgbGV0IGRzdF9pID0gKGRzdF9zdGFydCArIGkpIGxhbmQgZHN0Lm1hc2sgaW5cbiAgICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWVcbiAgICAgICAgZHN0LmVsdHNcbiAgICAgICAgZHN0X2lcbiAgICAgICAgKE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHNyYy5lbHRzIHNyY19pKTtcbiAgICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgc3JjLmVsdHMgc3JjX2lcbiAgICBkb25lO1xuICAgIGRzdC5sZW5ndGggPC0gZHN0Lmxlbmd0aCArIGxlbjtcbiAgICBzcmMuZnJvbnQgPC0gKHNyYy5mcm9udCArIGxlbikgbGFuZCBzcmMubWFzaztcbiAgICBzcmMubGVuZ3RoIDwtIHNyYy5sZW5ndGggLSBsZW4pXG47O1xuXG5sZXQgZW5xdWV1ZV9hbGwgdCBsID1cbiAgKCogVHJhdmVyc2luZyB0aGUgbGlzdCB1cCBmcm9udCB0byBjb21wdXRlIGl0cyBsZW5ndGggaXMgcHJvYmFibHkgKGJ1dCBub3QgZGVmaW5pdGVseSlcbiAgICAgYmV0dGVyIHRoYW4gZG91YmxpbmcgdGhlIHVuZGVybHlpbmcgYXJyYXkgc2l6ZSBzZXZlcmFsIHRpbWVzIGZvciBsYXJnZSBxdWV1ZXMuICopXG4gIHNldF9jYXBhY2l0eSB0IChJbnQubWF4IChjYXBhY2l0eSB0KSAodC5sZW5ndGggKyBMaXN0Lmxlbmd0aCBsKSk7XG4gIExpc3QuaXRlciBsIH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeClcbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBpZiB0Lmxlbmd0aCA9IDBcbiAgdGhlbiBpbml0XG4gIGVsc2UgKFxuICAgIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gICAgbGV0IHIgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpO1xuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICAgIGRvbmU7XG4gICAgIXIpXG47O1xuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIGEgLT5cbiAgICBsZXQgYWNjID0gZiAhaSBhY2MgYSBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIGFjYykgW0Bub250YWlsXVxuOztcblxuKCogW2l0ZXJdIGlzIGltcGxlbWVudGVkIGRpcmVjdGx5IGJlY2F1c2UgaW1wbGVtZW50aW5nIGl0IGluIHRlcm1zIG9mIFtmb2xkXSBpc1xuICAgc2xvd2VyLiAqKVxubGV0IGl0ZXIgdCB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICBmICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zXG4gIGRvbmVcbjs7XG5cbmxldCB0b19saXN0IHQgPVxuICBsZXQgcmVzdWx0ID0gcmVmIFtdIGluXG4gIGZvciBpID0gdC5sZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgcmVzdWx0IDo9IHVuc2FmZV9nZXQgdCBpIDo6ICFyZXN1bHRcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubW9kdWxlIEMgPSBJbmRleGVkX2NvbnRhaW5lci5NYWtlIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgZm9sZCA9IGZvbGRcbiAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gIGxldCBmb2xkaSA9IGBDdXN0b20gZm9sZGlcbiAgbGV0IGl0ZXJpID0gYEN1c3RvbSBpdGVyaVxuZW5kKVxuXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxubGV0IGZvcl9hbGwgPSBDLmZvcl9hbGxcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgbWVtID0gQy5tZW1cbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgc3VtID0gQy5zdW1cbmxldCBjb3VudGkgPSBDLmNvdW50aVxubGV0IGV4aXN0c2kgPSBDLmV4aXN0c2lcbmxldCBmaW5kX21hcGkgPSBDLmZpbmRfbWFwaVxubGV0IGZpbmRpID0gQy5maW5kaVxubGV0IGZvcl9hbGxpID0gQy5mb3JfYWxsaVxuXG4oKiBGb3IgW2NvbmNhdF9tYXBdLCBbZmlsdGVyX21hcF0sIGFuZCBbZmlsdGVyXSwgd2UgZG9uJ3QgY3JlYXRlIFt0X3Jlc3VsdF0gd2l0aCBbdF0nc1xuICAgY2FwYWNpdHkgYmVjYXVzZSB3ZSBoYXZlIG5vIGlkZWEgaG93IG1hbnkgZWxlbWVudHMgW3RfcmVzdWx0XSB3aWxsIHVsdGltYXRlbHkgaG9sZC4gKilcbmxldCBjb25jYXRfbWFwIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBMaXN0Lml0ZXIgKGYgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgdF9yZXN1bHQgYikpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBMaXN0Lml0ZXIgKGYgaSBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT5cbiAgICBtYXRjaCBmIGEgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBiIC0+IGVucXVldWUgdF9yZXN1bHQgYik7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+XG4gICAgbWF0Y2ggZiBpIGEgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBiIC0+IGVucXVldWUgdF9yZXN1bHQgYik7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBpZiBmIGEgdGhlbiBlbnF1ZXVlIHRfcmVzdWx0IGEpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IGlmIGYgaSBhIHRoZW4gZW5xdWV1ZSB0X3Jlc3VsdCBhKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID1cbiAgbGV0IHQyID0gZmlsdGVyIHQgfmYgaW5cbiAgY2xlYXIgdDtcbiAgYmxpdF90cmFuc2ZlciB+c3JjOnQyIH5kc3Q6dCAoKVxuOztcblxubGV0IGZpbHRlcmlfaW5wbGFjZSB0IH5mID1cbiAgbGV0IHQyID0gZmlsdGVyaSB0IH5mIGluXG4gIGNsZWFyIHQ7XG4gIGJsaXRfdHJhbnNmZXIgfnNyYzp0MiB+ZHN0OnQgKClcbjs7XG5cbmxldCBjb3B5IHNyYyA9XG4gIGxldCBkc3QgPSBjcmVhdGUgfmNhcGFjaXR5OnNyYy5sZW5ndGggKCkgaW5cbiAgYmxpdF90b19hcnJheSB+c3JjIGRzdC5lbHRzO1xuICBkc3QubGVuZ3RoIDwtIHNyYy5sZW5ndGg7XG4gIGRzdFxuOztcblxubGV0IG9mX2xpc3QgbCA9XG4gICgqIFRyYXZlcnNpbmcgdGhlIGxpc3QgdXAgZnJvbnQgdG8gY29tcHV0ZSBpdHMgbGVuZ3RoIGlzIHByb2JhYmx5IChidXQgbm90IGRlZmluaXRlbHkpXG4gICAgIGJldHRlciB0aGFuIGRvdWJsaW5nIHRoZSB1bmRlcmx5aW5nIGFycmF5IHNpemUgc2V2ZXJhbCB0aW1lcyBmb3IgbGFyZ2UgcXVldWVzLiAqKVxuICBsZXQgdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6KExpc3QubGVuZ3RoIGwpICgpIGluXG4gIExpc3QuaXRlciBsIH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeCk7XG4gIHRcbjs7XG5cbigqIFRoZSBxdWV1ZSBbdF0gcmV0dXJuZWQgYnkgW2NyZWF0ZV0gd2lsbCBoYXZlIFt0Lmxlbmd0aCA9IDBdLCBbdC5mcm9udCA9IDBdLCBhbmRcbiAgIFtjYXBhY2l0eSB0ID0gSW50LmNlaWxfcG93MiBsZW5dLiAgU28sIHdlIG9ubHkgaGF2ZSB0byBzZXQgW3QubGVuZ3RoXSB0byBbbGVuXSBhZnRlclxuICAgdGhlIGJsaXQgdG8gbWFpbnRhaW4gYWxsIHRoZSBpbnZhcmlhbnRzOiBbdC5sZW5ndGhdIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZWxlbWVudHNcbiAgIGluIHRoZSBxdWV1ZSwgW3QuZnJvbnRdIGlzIHRoZSBhcnJheSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgcXVldWUsIGFuZFxuICAgW2NhcGFjaXR5IHQgPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0c10uICopXG5sZXQgaW5pdCBsZW4gfmYgPVxuICBpZiBsZW4gPCAwXG4gIHRoZW5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlIFwiUXVldWUuaW5pdDogbmVnYXRpdmUgbGVuZ3RoXCIgWyBcImxlbmd0aFwiLCBsZW4gfD4gSW50LnNleHBfb2ZfdCBdKTtcbiAgbGV0IHQgPSBjcmVhdGUgfmNhcGFjaXR5OmxlbiAoKSBpblxuICBhc3NlcnQgKE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzID49IGxlbik7XG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0LmVsdHMgaSAoZiBpKVxuICBkb25lO1xuICB0Lmxlbmd0aCA8LSBsZW47XG4gIHRcbjs7XG5cbmxldCBvZl9hcnJheSBhID0gaW5pdCAoQXJyYXkubGVuZ3RoIGEpIH5mOihBcnJheS51bnNhZmVfZ2V0IGEpXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgdC5sZW5ndGggfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxuXG5sZXQgbWFwIHRhIH5mID1cbiAgbGV0IG51bV9tdXRhdGlvbnMgPSB0YS5udW1fbXV0YXRpb25zIGluXG4gIGxldCB0YiA9IGNyZWF0ZSB+Y2FwYWNpdHk6dGEubGVuZ3RoICgpIGluXG4gIHRiLmxlbmd0aCA8LSB0YS5sZW5ndGg7XG4gIGZvciBpID0gMCB0byB0YS5sZW5ndGggLSAxIGRvXG4gICAgbGV0IGIgPSBmICh1bnNhZmVfZ2V0IHRhIGkpIGluXG4gICAgZW5zdXJlX25vX211dGF0aW9uIHRhIG51bV9tdXRhdGlvbnM7XG4gICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0Yi5lbHRzIGkgYlxuICBkb25lO1xuICB0YlxuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgbWFwIHQgfmY6KGZ1biBhIC0+XG4gICAgbGV0IHJlc3VsdCA9IGYgIWkgYSBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIHJlc3VsdCkgW0Bub250YWlsXVxuOztcblxubGV0IHNpbmdsZXRvbiB4ID1cbiAgbGV0IHQgPSBjcmVhdGUgfmNhcGFjaXR5OjEgKCkgaW5cbiAgZW5xdWV1ZSB0IHg7XG4gIHRcbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSB0b19saXN0IHQgfD4gTGlzdC5zZXhwX29mX3Qgc2V4cF9vZl9hXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gTGlzdC50X29mX3NleHAgYV9vZl9zZXhwIHNleHAgfD4gb2ZfbGlzdFxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbm1vZHVsZSBJdGVyYXRpb24gPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50XG5cbiAgbGV0IHN0YXJ0IHEgPSBxLm51bV9tdXRhdGlvbnNcbiAgbGV0IGFzc2VydF9ub19tdXRhdGlvbl9zaW5jZV9zdGFydCB0IHEgPSBlbnN1cmVfbm9fbXV0YXRpb24gcSB0XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSB8XG5cbiAgbGV0IHVucmVhY2hhYmxlX2NvZGVfbG9jYWwgPSBmdW5jdGlvblxuICAgIHwgKF8gOiB0KSAtPiAuXG4gIDs7XG5cbiAgbGV0IHVucmVhY2hhYmxlX2NvZGUgeCA9IHVucmVhY2hhYmxlX2NvZGVfbG9jYWwgeFxuICBsZXQgYWxsID0gW11cbiAgbGV0IGhhc2hfZm9sZF90IF8gdCA9IHVucmVhY2hhYmxlX2NvZGUgdFxuICBsZXQgaGFzaCA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IGNvbXBhcmUgYSBfID0gdW5yZWFjaGFibGVfY29kZSBhXG4gIGxldCBjb21wYXJlX19sb2NhbCBhIF8gPSB1bnJlYWNoYWJsZV9jb2RlIGFcbiAgbGV0IGVxdWFsX19sb2NhbCBhIF8gPSB1bnJlYWNoYWJsZV9jb2RlIGFcbiAgbGV0IHNleHBfb2ZfdCA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID0gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X3R5cGUgXCJCYXNlLk5vdGhpbmcudFwiIHNleHBcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0geyB1bnR5cGVkID0gVW5pb24gW10gfVxuICBsZXQgdG9fc3RyaW5nID0gdW5yZWFjaGFibGVfY29kZVxuICBsZXQgb2Zfc3RyaW5nIChfIDogc3RyaW5nKSA9IGZhaWx3aXRoIFwiQmFzZS5Ob3RoaW5nLm9mX3N0cmluZzogbm90IHN1cHBvcnRlZFwiXG4gIGxldCBnbG9iYWxpemUgPSB1bnJlYWNoYWJsZV9jb2RlXG5lbmRcblxuaW5jbHVkZSBUXG5cbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTm90aGluZ1wiXG5lbmQpXG5cbmxldCBtdXN0X2JlX25vbmUgOiB0IG9wdGlvbiAtPiB1bml0ID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBfIC0+IC5cbjs7XG5cbmxldCBtdXN0X2JlX2VtcHR5IDogdCBsaXN0IC0+IHVuaXQgPSBmdW5jdGlvblxuICB8IFtdIC0+ICgpXG4gIHwgXyA6OiBfIC0+IC5cbjs7XG5cbmxldCBtdXN0X2JlX29rIDogKCdvaywgdCkgUmVzdWx0LnQgLT4gJ29rID0gZnVuY3Rpb25cbiAgfCBPayBvayAtPiBva1xuICB8IEVycm9yIF8gLT4gLlxuOztcblxubGV0IG11c3RfYmVfZXJyb3IgOiAodCwgJ2VycikgUmVzdWx0LnQgLT4gJ2VyciA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiAuXG4gIHwgRXJyb3IgZXJyb3IgLT4gZXJyb3Jcbjs7XG5cbmxldCBtdXN0X2JlX2ZpcnN0IDogKCdmaXJzdCwgdCkgRWl0aGVyLnQgLT4gJ2ZpcnN0ID0gZnVuY3Rpb25cbiAgfCBGaXJzdCBmaXJzdCAtPiBmaXJzdFxuICB8IFNlY29uZCBfIC0+IC5cbjs7XG5cbmxldCBtdXN0X2JlX3NlY29uZCA6ICh0LCAnc2Vjb25kKSBFaXRoZXIudCAtPiAnc2Vjb25kID0gZnVuY3Rpb25cbiAgfCBGaXJzdCBfIC0+IC5cbiAgfCBTZWNvbmQgc2Vjb25kIC0+IHNlY29uZFxuOztcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgU3RkbGliLk5hdGl2ZWludFxuaW5jbHVkZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IG5hdGl2ZWludCBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9uYXRpdmVpbnQgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9uYXRpdmVpbnRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAobmF0aXZlaW50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX25hdGl2ZWludCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBuYXRpdmVpbnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nX29wdCA9IG9mX3N0cmluZ19vcHRcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZSAoVClcblxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2VfaGV4IChzdHJ1Y3RcbiAgb3BlbiBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgdHlwZSB0ID0gbmF0aXZlaW50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoY29tcGFyZV9uYXRpdmVpbnRfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfbmF0aXZlaW50XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9uYXRpdmVpbnQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCAoIDwgKSA9ICggPCApXG4gIGxldCB0b19zdHJpbmcgaSA9IFByaW50Zi5zcHJpbnRmIFwiJW54XCIgaVxuICBsZXQgb2Zfc3RyaW5nIHMgPSBTdGRsaWIuU2NhbmYuc3NjYW5mIHMgXCIlbnhcIiBGbi5pZFxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTmF0aXZlaW50LkhleFwiXG5lbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLk5hdGl2ZWludFwiXG5lbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBudW1fYml0cyA9IFdvcmRfc2l6ZS5udW1fYml0cyBXb3JkX3NpemUud29yZF9zaXplXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBsb2dub3RcbmxldCBiaXRfeG9yID0gbG9neG9yXG5sZXQgYml0X29yID0gbG9nb3JcbmxldCBiaXRfYW5kID0gbG9nYW5kXG5sZXQgbWluX3ZhbHVlID0gbWluX2ludFxubGV0IG1heF92YWx1ZSA9IG1heF9pbnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWludXNfb25lID0gbWludXNfb25lXG5sZXQgb25lID0gb25lXG5sZXQgemVybyA9IHplcm9cbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gb2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgICAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gb2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJOYXRpdmVpbnQub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cbiAgbGV0ICggbG9yICkgPSBTdGRsaWIuTmF0aXZlaW50LmxvZ29yXG4gIGxldCAoIGxzciApID0gU3RkbGliLk5hdGl2ZWludC5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IFN0ZGxpYi5OYXRpdmVpbnQubG9nYW5kXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyICh4IDogbmF0aXZlaW50KSA9XG4gICAgaWYgeCA8PSAwbiB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IFN0ZGxpYi5OYXRpdmVpbnQucHJlZCB4IGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICAoKiBUaGUgbmV4dCBsaW5lIGlzIHN1cGVyZmx1b3VzIG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyBmYXN0ZXIgdG8gZG8gaXRcbiAgICAgICBhbnl3YXkgdGhhbiB0byBicmFuY2ggKilcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBTdGRsaWIuTmF0aXZlaW50LnN1Y2MgeFxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwbiB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIFN0ZGxpYi5OYXRpdmVpbnQuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwbiB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgU3RkbGliLk5hdGl2ZWludC5wcmVkIHggPSAwblxuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIG5hdGl2ZWludCBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAobmF0aXZlaW50W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2NselwiIFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6X3VuYm94ZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKG5hdGl2ZWludFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHpcIiBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0el91bmJveGVkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBTdGRsaWIuTmF0aXZlaW50Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJbTmF0aXZlaW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCJcbiAgICAgICAgICAgWyBcIlwiLCBzZXhwX29mX25hdGl2ZWludCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIFBvbHkuKCA8PSApIGkgU3RkbGliLk5hdGl2ZWludC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiW05hdGl2ZWludC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCJcbiAgICAgICAgICAgWyBcIlwiLCBzZXhwX29mX25hdGl2ZWludCBpIF0pO1xuICAgIGlmIFN0ZGxpYi5OYXRpdmVpbnQuZXF1YWwgaSBTdGRsaWIuTmF0aXZlaW50Lm9uZVxuICAgIHRoZW4gMFxuICAgIGVsc2UgbnVtX2JpdHMgLSBjbHogKFN0ZGxpYi5OYXRpdmVpbnQucHJlZCBpKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluOm1pbl8gfm1heDptYXhfID0gbWluIHQgbWF4XyB8PiBtYXggbWluX1xuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0ICggLyApID0gZGl2XG5sZXQgKCAqICkgPSBtdWxcbmxldCAoIC0gKSA9IHN1YlxubGV0ICggKyApID0gYWRkXG5sZXQgKCB+LSApID0gbmVnXG5sZXQgaW5jciByID0gciA6PSAhciArIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gIXIgLSBvbmVcbmxldCBvZl9uYXRpdmVpbnQgdCA9IHRcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gb2ZfbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50IHQgPSB0XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IHRvX25hdGl2ZWludFxubGV0IHBvcGNvdW50ID0gUG9wY291bnQubmF0aXZlaW50X3BvcGNvdW50XG5sZXQgb2ZfaW50ID0gQ29udi5pbnRfdG9fbmF0aXZlaW50XG5sZXQgb2ZfaW50X2V4biA9IG9mX2ludFxubGV0IHRvX2ludCA9IENvbnYubmF0aXZlaW50X3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnRfZXhuXG5sZXQgdG9faW50X3RydW5jID0gQ29udi5uYXRpdmVpbnRfdG9faW50X3RydW5jXG5sZXQgb2ZfaW50MzIgPSBDb252LmludDMyX3RvX25hdGl2ZWludFxubGV0IG9mX2ludDMyX2V4biA9IG9mX2ludDMyXG5sZXQgdG9faW50MzIgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX2V4blxuXG5leHRlcm5hbCB0b19pbnQzMl90cnVuY1xuICA6ICAobmF0aXZlaW50W0Bsb2NhbF9vcHRdKVxuICAtPiAoaW50MzJbQGxvY2FsX29wdF0pXG4gID0gXCIlbmF0aXZlaW50X3RvX2ludDMyXCJcblxubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X3RydW5jXG5sZXQgdG9faW50NjQgPSBDb252Lm5hdGl2ZWludF90b19pbnQ2NFxubGV0IHBvdyBiIGUgPSBvZl9pbnRfZXhuIChJbnRfbWF0aC5Qcml2YXRlLmludF9wb3cgKHRvX2ludF9leG4gYikgKHRvX2ludF9leG4gZSkpXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2VfYmluYXJ5IChzdHJ1Y3RcbiAgdHlwZSB0ID0gbmF0aXZlaW50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChjb21wYXJlX25hdGl2ZWludF9fbG9jYWwgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBlcXVhbF9fbG9jYWwgPSAoZXF1YWxfbmF0aXZlaW50X19sb2NhbCA6IHQgLT4gdCAtPiBib29sKVxuICBsZXQgZXF1YWwgPSAoZnVuIGEgYiAtPiBlcXVhbF9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9uYXRpdmVpbnRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0ICggbGFuZCApID0gKCBsYW5kIClcbiAgbGV0ICggbHNyICkgPSAoIGxzciApXG4gIGxldCBjbHogPSBjbHpcbiAgbGV0IG51bV9iaXRzID0gbnVtX2JpdHNcbiAgbGV0IG9uZSA9IG9uZVxuICBsZXQgdG9faW50X2V4biA9IHRvX2ludF9leG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBpbmNsdWRlIFByZV9PXG5cbiAgICBsZXQgcmVtID0gcmVtXG4gICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW05hdGl2ZWludF0gYW5kIFtOYXRpdmVpbnQuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5leHRlcm5hbCBic3dhcCA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVic3dhcF9uYXRpdmVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqKVxuKCogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqKVxuKCogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIDIuMCBsaWNlbnNlLiBTZWUgLi4vVEhJUkQtUEFSVFkudHh0ICAqKVxuKCogIGZvciBkZXRhaWxzLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgTWFwX2ludGZcblxubW9kdWxlIEZpbmlzaGVkX29yX3VuZmluaXNoZWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYXBfaW50Zi5GaW5pc2hlZF9vcl91bmZpbmlzaGVkXG5cbiAgKCogVGhlc2UgdHdvIGZ1bmN0aW9ucyBhcmUgdGVzdGVkIGluIFt0ZXN0X21hcC5tbF0gdG8gbWFrZSBzdXJlIG91ciB1c2Ugb2ZcbiAgICAgW1N0ZGxpYi5PYmoubWFnaWNdIGlzIGNvcnJlY3QgYW5kIHNhZmUuICopXG4gIGxldCBvZl9jb250aW51ZV9vcl9zdG9wIDogQ29udGludWVfb3Jfc3RvcC50IC0+IHQgPSBTdGRsaWIuT2JqLm1hZ2ljXG4gIGxldCB0b19jb250aW51ZV9vcl9zdG9wIDogdCAtPiBDb250aW51ZV9vcl9zdG9wLnQgPSBTdGRsaWIuT2JqLm1hZ2ljXG5lbmRcblxubW9kdWxlIE1lcmdlX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYXBfaW50Zi5NZXJnZV9lbGVtZW50XG5cbiAgbGV0IGxlZnQgPSBmdW5jdGlvblxuICAgIHwgYFJpZ2h0IF8gLT4gTm9uZVxuICAgIHwgYExlZnQgbGVmdCB8IGBCb3RoIChsZWZ0LCBfKSAtPiBTb21lIGxlZnRcbiAgOztcblxuICBsZXQgcmlnaHQgPSBmdW5jdGlvblxuICAgIHwgYExlZnQgXyAtPiBOb25lXG4gICAgfCBgUmlnaHQgcmlnaHQgfCBgQm90aCAoXywgcmlnaHQpIC0+IFNvbWUgcmlnaHRcbiAgOztcblxuICBsZXQgbGVmdF92YWx1ZSB0IH5kZWZhdWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IGBSaWdodCBfIC0+IGRlZmF1bHRcbiAgICB8IGBMZWZ0IGxlZnQgfCBgQm90aCAobGVmdCwgXykgLT4gbGVmdFxuICA7O1xuXG4gIGxldCByaWdodF92YWx1ZSB0IH5kZWZhdWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IGBMZWZ0IF8gLT4gZGVmYXVsdFxuICAgIHwgYFJpZ2h0IHJpZ2h0IHwgYEJvdGggKF8sIHJpZ2h0KSAtPiByaWdodFxuICA7O1xuXG4gIGxldCB2YWx1ZXMgdCB+bGVmdF9kZWZhdWx0IH5yaWdodF9kZWZhdWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IGBMZWZ0IGxlZnQgLT4gbGVmdCwgcmlnaHRfZGVmYXVsdFxuICAgIHwgYFJpZ2h0IHJpZ2h0IC0+IGxlZnRfZGVmYXVsdCwgcmlnaHRcbiAgICB8IGBCb3RoIChsZWZ0LCByaWdodCkgLT4gbGVmdCwgcmlnaHRcbiAgOztcbmVuZFxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG5leGNlcHRpb24gRHVwbGljYXRlIFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRHVwbGljYXRlXSAoZnVuY3Rpb25cbiAgICB8IER1cGxpY2F0ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuRHVwbGljYXRlXCJcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxuKCogW1dpdGhfbGVuZ3RoLnRdIGFsbG93cyB1cyB0byBzdG9yZSBsZW5ndGggaW5mb3JtYXRpb24gb24gdGhlIHN0YWNrIHdoaWxlXG4gICBrZWVwaW5nIHRoZSB0cmVlIGdsb2JhbC4gVGhpcyBzYXZlcyB1cCB0byBPKGxvZyBuKSBibG9ja3Mgb2YgaGVhcCBhbGxvY2F0aW9uLiAqKVxubW9kdWxlIFdpdGhfbGVuZ3RoIDogc2lnXG4gIHR5cGUgJ2EgdCA9IHByaXZhdGVcbiAgICB7IHRyZWUgOiAnYVxuICAgIDsgbGVuZ3RoIDogaW50XG4gICAgfVxuXG4gIHZhbCB3aXRoX2xlbmd0aCA6ICdhIC0+IGludCAtPiAnYSB0XG4gIHZhbCB3aXRoX2xlbmd0aF9nbG9iYWwgOiAnYSAtPiBpbnQgLT4gJ2EgdFxuICB2YWwgZ2xvYmFsaXplIDogJ2EgdCAtPiAnYSB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IHRyZWUgOiAnYVxuICAgIDsgbGVuZ3RoIDogaW50XG4gICAgfVxuXG4gIGxldCB3aXRoX2xlbmd0aCB0cmVlIGxlbmd0aCA9IHsgdHJlZTsgbGVuZ3RoIH1cbiAgbGV0IHdpdGhfbGVuZ3RoX2dsb2JhbCB0cmVlIGxlbmd0aCA9IHsgdHJlZTsgbGVuZ3RoIH1cbiAgbGV0IGdsb2JhbGl6ZSB7IHRyZWU7IGxlbmd0aCB9ID0geyB0cmVlOyBsZW5ndGggfVxuZW5kXG5cbm9wZW4gV2l0aF9sZW5ndGhcblxubW9kdWxlIFRyZWUwID0gc3RydWN0XG4gIHR5cGUgKCdrLCAndikgdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgTGVhZiBvZlxuICAgICAgICB7IGtleSA6ICdrXG4gICAgICAgIDsgZGF0YSA6ICd2XG4gICAgICAgIH1cbiAgICB8IE5vZGUgb2ZcbiAgICAgICAgeyBsZWZ0IDogKCdrLCAndikgdFxuICAgICAgICA7IGtleSA6ICdrXG4gICAgICAgIDsgZGF0YSA6ICd2XG4gICAgICAgIDsgcmlnaHQgOiAoJ2ssICd2KSB0XG4gICAgICAgIDsgaGVpZ2h0IDogaW50XG4gICAgICAgIH1cblxuICB0eXBlICgnaywgJ3YpIHRyZWUgPSAoJ2ssICd2KSB0XG5cbiAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyBkYXRhID0gXzsgcmlnaHQgPSBfOyBoZWlnaHQgPSBoIH0gLT4gaFxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnRzID1cbiAgICBsZXQgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkgayA9XG4gICAgICAobWF0Y2ggbG93ZXIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICAgfCBTb21lIGxvd2VyIC0+IGNvbXBhcmVfa2V5IGxvd2VyIGsgPCAwKVxuICAgICAgJiZcbiAgICAgIG1hdGNoIHVwcGVyIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICB8IFNvbWUgdXBwZXIgLT4gY29tcGFyZV9rZXkgayB1cHBlciA8IDBcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBsb3dlciB1cHBlciBjb21wYXJlX2tleSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgICB8IExlYWYgeyBrZXkgPSBrOyBkYXRhID0gXyB9IC0+IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IGtcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrOyBkYXRhID0gXzsgcmlnaHQgPSByOyBoZWlnaHQgPSBoIH0gLT5cbiAgICAgICAgbGV0IGhsID0gaGVpZ2h0IGxcbiAgICAgICAgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgICAgYWJzIChobCAtIGhyKSA8PSAyXG4gICAgICAgICYmIGggPSBtYXggaGwgaHIgKyAxXG4gICAgICAgICYmIGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IGtcbiAgICAgICAgJiYgbG9vcCBsb3dlciAoU29tZSBrKSBjb21wYXJlX2tleSBsXG4gICAgICAgICYmIGxvb3AgKFNvbWUgaykgdXBwZXIgY29tcGFyZV9rZXkgclxuICAgIGluXG4gICAgZnVuIHQgfmNvbXBhcmVfa2V5IC0+IGxvb3AgTm9uZSBOb25lIGNvbXBhcmVfa2V5IHRcbiAgOztcblxuICAoKiBwcmVjb25kaXRpb25zOiB8aGVpZ2h0KGwpIC0gaGVpZ2h0KHIpfCA8PSAyLCBobCA9IGhlaWdodChsKSwgaHIgPSBoZWlnaHQocikgKilcbiAgbGV0W0BpbmxpbmVdIGNyZWF0ZV93aXRoX2hlaWdodHMgfmhsIH5ociBsIHggZCByID1cbiAgICBpZiBobCA9IDAgJiYgaHIgPSAwXG4gICAgdGhlbiBMZWFmIHsga2V5ID0geDsgZGF0YSA9IGQgfVxuICAgIGVsc2VcbiAgICAgIE5vZGVcbiAgICAgICAgeyBsZWZ0ID0gbFxuICAgICAgICA7IGtleSA9IHhcbiAgICAgICAgOyBkYXRhID0gZFxuICAgICAgICA7IHJpZ2h0ID0gclxuICAgICAgICA7IGhlaWdodCA9IChpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSlcbiAgICAgICAgfVxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsKSAtIGhlaWdodChyKXwgPD0gMiAqKVxuICBsZXQgY3JlYXRlIGwgeCBkIHIgPSBjcmVhdGVfd2l0aF9oZWlnaHRzIH5obDooaGVpZ2h0IGwpIH5ocjooaGVpZ2h0IHIpIGwgeCBkIHJcbiAgbGV0IHNpbmdsZXRvbiBrZXkgZGF0YSA9IExlYWYgeyBrZXk7IGRhdGEgfVxuXG4gICgqIFdlIG11c3QgY2FsbCBbZl0gd2l0aCBpbmNyZWFzaW5nIGluZGV4ZXMsIGJlY2F1c2UgdGhlIGJpbl9wcm90IHJlYWRlciBpblxuICAgICBDb3JlLk1hcCBuZWVkcyBpdC4gKilcbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIGxldCByZWMgbG9vcCBuIH5mIGkgOiAoXywgXykgdCA9XG4gICAgICBtYXRjaCBuIHdpdGhcbiAgICAgIHwgMCAtPiBFbXB0eVxuICAgICAgfCAxIC0+XG4gICAgICAgIGxldCBrLCB2ID0gZiBpIGluXG4gICAgICAgIExlYWYgeyBrZXkgPSBrOyBkYXRhID0gdiB9XG4gICAgICB8IDIgLT5cbiAgICAgICAgbGV0IGtsLCB2bCA9IGYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyAxKSBpblxuICAgICAgICBOb2RlXG4gICAgICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGtsOyBkYXRhID0gdmwgfVxuICAgICAgICAgIDsga2V5ID0ga1xuICAgICAgICAgIDsgZGF0YSA9IHZcbiAgICAgICAgICA7IHJpZ2h0ID0gRW1wdHlcbiAgICAgICAgICA7IGhlaWdodCA9IDJcbiAgICAgICAgICB9XG4gICAgICB8IDMgLT5cbiAgICAgICAgbGV0IGtsLCB2bCA9IGYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyAxKSBpblxuICAgICAgICBsZXQga3IsIHZyID0gZiAoaSArIDIpIGluXG4gICAgICAgIE5vZGVcbiAgICAgICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0ga2w7IGRhdGEgPSB2bCB9XG4gICAgICAgICAgOyBrZXkgPSBrXG4gICAgICAgICAgOyBkYXRhID0gdlxuICAgICAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0ga3I7IGRhdGEgPSB2ciB9XG4gICAgICAgICAgOyBoZWlnaHQgPSAyXG4gICAgICAgICAgfVxuICAgICAgfCBuIC0+XG4gICAgICAgIGxldCBsZWZ0X2xlbmd0aCA9IG4gbHNyIDEgaW5cbiAgICAgICAgbGV0IHJpZ2h0X2xlbmd0aCA9IG4gLSBsZWZ0X2xlbmd0aCAtIDEgaW5cbiAgICAgICAgbGV0IGxlZnQgPSBsb29wIGxlZnRfbGVuZ3RoIH5mIGkgaW5cbiAgICAgICAgbGV0IGssIHYgPSBmIChpICsgbGVmdF9sZW5ndGgpIGluXG4gICAgICAgIGxldCByaWdodCA9IGxvb3AgcmlnaHRfbGVuZ3RoIH5mIChpICsgbGVmdF9sZW5ndGggKyAxKSBpblxuICAgICAgICBjcmVhdGUgbGVmdCBrIHYgcmlnaHRcbiAgICBpblxuICAgIGxvb3AgbGVuIH5mIDBcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBhcnJheV9sZW5ndGggPSBBcnJheS5sZW5ndGggYXJyYXkgaW5cbiAgICBsZXQgbmV4dCA9XG4gICAgICBpZiBhcnJheV9sZW5ndGggPCAyXG4gICAgICAgICB8fFxuICAgICAgICAgbGV0IGswLCBfID0gYXJyYXkuKDApIGluXG4gICAgICAgICBsZXQgazEsIF8gPSBhcnJheS4oMSkgaW5cbiAgICAgICAgIGNvbXBhcmVfa2V5IGswIGsxIDwgMFxuICAgICAgdGhlbiBmdW4gaSAtPiBhcnJheS4oaSlcbiAgICAgIGVsc2UgZnVuIGkgLT4gYXJyYXkuKGFycmF5X2xlbmd0aCAtIDEgLSBpKVxuICAgIGluXG4gICAgd2l0aF9sZW5ndGggKG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW46YXJyYXlfbGVuZ3RoIH5mOm5leHQpIGFycmF5X2xlbmd0aFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBhcnJheSB3aXRoXG4gICAgfCBbfHxdIHwgW3wgXyB8XSAtPlxuICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSB8PiBnbG9iYWxpemUpXG4gICAgfCBfIC0+XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IGluY3JlYXNpbmcgPVxuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfa2V5IChmc3QgYXJyYXkuKDApKSAoZnN0IGFycmF5LigxKSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+IGkgPCAwXG4gICAgICAgIGluXG4gICAgICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAyIGRvXG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9rZXkgKGZzdCBhcnJheS4oaSkpIChmc3QgYXJyYXkuKGkgKyAxKSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+XG4gICAgICAgICAgICBpZiBQb2x5LiggPD4gKSAoaSA8IDApIGluY3JlYXNpbmdcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgci5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZWxlbWVudHMgYXJlIG5vdCBvcmRlcmVkXCIpXG4gICAgICAgIGRvbmU7XG4gICAgICAgIFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXkgfD4gZ2xvYmFsaXplKSlcbiAgOztcblxuICAoKiBwcmVjb25kaXRpb246IHxoZWlnaHQobCkgLSBoZWlnaHQocil8IDw9IDMgKilcbiAgbGV0W0BpbmxpbmVdIGJhbCBsIHggZCByID1cbiAgICBsZXQgaGwgPSBoZWlnaHQgbCBpblxuICAgIGxldCBociA9IGhlaWdodCByIGluXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGhlaWdodChMZWFmKSA9IDEgJiYgMSBpcyBub3QgbGFyZ2VyIHRoYW4gaHIgKyAyICopXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbGw7IGtleSA9IGx2OyBkYXRhID0gbGQ7IHJpZ2h0ID0gbHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyXG4gICAgICAgIHRoZW4gY3JlYXRlIGxsIGx2IGxkIChjcmVhdGUgbHIgeCBkIHIpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgfCBMZWFmIHsga2V5ID0gbHJ2OyBkYXRhID0gbHJkIH0gLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIEVtcHR5KSBscnYgbHJkIChjcmVhdGUgRW1wdHkgeCBkIHIpXG4gICAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGxybDsga2V5ID0gbHJ2OyBkYXRhID0gbHJkOyByaWdodCA9IGxycjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpKSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgIHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZSAoKiBoZWlnaHQoTGVhZikgPSAxICYmIDEgaXMgbm90IGxhcmdlciB0aGFuIGhsICsgMiAqKVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IHJsOyBrZXkgPSBydjsgZGF0YSA9IHJkOyByaWdodCA9IHJyOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybFxuICAgICAgICB0aGVuIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgIHwgTGVhZiB7IGtleSA9IHJsdjsgZGF0YSA9IHJsZCB9IC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBFbXB0eSkgcmx2IHJsZCAoY3JlYXRlIEVtcHR5IHJ2IHJkIHJyKVxuICAgICAgICAgIHwgTm9kZSB7IGxlZnQgPSBybGw7IGtleSA9IHJsdjsgZGF0YSA9IHJsZDsgcmlnaHQgPSBybHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKSkpXG4gICAgZWxzZSBjcmVhdGVfd2l0aF9oZWlnaHRzIH5obCB+aHIgbCB4IGQgclxuICA7O1xuXG4gIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcbiAgOztcblxuICBsZXQgcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5IH5zZXhwX29mX2tleSA9XG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZSBcIltNYXAuYWRkX2V4bl0gZ290IGtleSBhbHJlYWR5IHByZXNlbnRcIiBbIFwia2V5XCIsIGtleSB8PiBzZXhwX29mX2tleSBdKVxuICA7O1xuXG4gIG1vZHVsZSBBZGRfb3Jfc2V0ID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbFxuICAgICAgfCBBZGRfZXhuXG4gICAgICB8IFNldFxuICBlbmRcblxuICBsZXQgcmVjIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICB0XG4gICAgfmxlbmd0aFxuICAgIH5rZXk6eFxuICAgIH5kYXRhXG4gICAgfmNvbXBhcmVfa2V5XG4gICAgfnNleHBfb2Zfa2V5XG4gICAgfihhZGRfb3Jfc2V0IDogQWRkX29yX3NldC50KVxuICAgID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IHdpdGhfbGVuZ3RoIChMZWFmIHsga2V5ID0geDsgZGF0YSB9KSAobGVuZ3RoICsgMSlcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBhZGRfb3Jfc2V0IHdpdGhcbiAgICAgICAgfCBBZGRfZXhuX2ludGVybmFsIC0+IEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBEdXBsaWNhdGVcbiAgICAgICAgfCBBZGRfZXhuIC0+IHJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQgfmtleTp4IH5zZXhwX29mX2tleVxuICAgICAgICB8IFNldCAtPiB3aXRoX2xlbmd0aCAoTGVhZiB7IGtleSA9IHg7IGRhdGEgfSkgbGVuZ3RoKVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlblxuICAgICAgICB3aXRoX2xlbmd0aFxuICAgICAgICAgIChOb2RlXG4gICAgICAgICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IHg7IGRhdGEgfVxuICAgICAgICAgICAgIDsga2V5ID0gdlxuICAgICAgICAgICAgIDsgZGF0YSA9IGRcbiAgICAgICAgICAgICA7IHJpZ2h0ID0gRW1wdHlcbiAgICAgICAgICAgICA7IGhlaWdodCA9IDJcbiAgICAgICAgICAgICB9KVxuICAgICAgICAgIChsZW5ndGggKyAxKVxuICAgICAgZWxzZVxuICAgICAgICB3aXRoX2xlbmd0aFxuICAgICAgICAgIChOb2RlXG4gICAgICAgICAgICAgeyBsZWZ0ID0gRW1wdHlcbiAgICAgICAgICAgICA7IGtleSA9IHZcbiAgICAgICAgICAgICA7IGRhdGEgPSBkXG4gICAgICAgICAgICAgOyByaWdodCA9IExlYWYgeyBrZXkgPSB4OyBkYXRhIH1cbiAgICAgICAgICAgICA7IGhlaWdodCA9IDJcbiAgICAgICAgICAgICB9KVxuICAgICAgICAgIChsZW5ndGggKyAxKVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBoIH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGFkZF9vcl9zZXQgd2l0aFxuICAgICAgICB8IEFkZF9leG5faW50ZXJuYWwgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIER1cGxpY2F0ZVxuICAgICAgICB8IEFkZF9leG4gLT4gcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5OnggfnNleHBfb2Zfa2V5XG4gICAgICAgIHwgU2V0IC0+XG4gICAgICAgICAgd2l0aF9sZW5ndGggKE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0geDsgZGF0YTsgcmlnaHQgPSByOyBoZWlnaHQgPSBoIH0pIGxlbmd0aClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbCwgciwgbGVuZ3RoID1cbiAgICAgICAgICBpZiBjIDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IHsgdHJlZSA9IGw7IGxlbmd0aCB9ID1cbiAgICAgICAgICAgICAgZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgICAgICAgICAgIH5sZW5ndGhcbiAgICAgICAgICAgICAgICB+a2V5OnhcbiAgICAgICAgICAgICAgICB+ZGF0YVxuICAgICAgICAgICAgICAgIGxcbiAgICAgICAgICAgICAgICB+Y29tcGFyZV9rZXlcbiAgICAgICAgICAgICAgICB+c2V4cF9vZl9rZXlcbiAgICAgICAgICAgICAgICB+YWRkX29yX3NldFxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGwsIHIsIGxlbmd0aClcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCB7IHRyZWUgPSByOyBsZW5ndGggfSA9XG4gICAgICAgICAgICAgIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICAgICAgICAgICAgICB+bGVuZ3RoXG4gICAgICAgICAgICAgICAgfmtleTp4XG4gICAgICAgICAgICAgICAgfmRhdGFcbiAgICAgICAgICAgICAgICByXG4gICAgICAgICAgICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICAgICAgICAgICAgfnNleHBfb2Zfa2V5XG4gICAgICAgICAgICAgICAgfmFkZF9vcl9zZXRcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsLCByLCBsZW5ndGgpXG4gICAgICAgIGluXG4gICAgICAgIHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgcikgbGVuZ3RoKVxuICA7O1xuXG4gICgqIHNwZWNpYWxpemF0aW9uIG9mIFtzZXQnXSBmb3IgdGhlIGNhc2Ugd2hlbiBba2V5XSBpcyBsZXNzIHRoYW4gYWxsIHRoZSBleGlzdGluZyBrZXlzICopXG4gIGxldCByZWMgc2V0X21pbiBrZXkgZGF0YSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IExlYWYgeyBrZXk7IGRhdGEgfVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgIE5vZGUgeyBsZWZ0ID0gTGVhZiB7IGtleTsgZGF0YSB9OyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMiB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgbGV0IGwgPSBzZXRfbWluIGtleSBkYXRhIGwgaW5cbiAgICAgIGJhbCBsIHYgZCByXG4gIDs7XG5cbiAgKCogc3BlY2lhbGl6YXRpb24gb2YgW3NldCddIGZvciB0aGUgY2FzZSB3aGVuIFtrZXldIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlXG4gICAgIGV4aXN0aW5nIGtleXMgICopXG4gIGxldCByZWMgc2V0X21heCB0IGtleSBkYXRhID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IExlYWYgeyBrZXk7IGRhdGEgfVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgIE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IExlYWYgeyBrZXk7IGRhdGEgfTsgaGVpZ2h0ID0gMiB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgbGV0IHIgPSBzZXRfbWF4IHIga2V5IGRhdGEgaW5cbiAgICAgIGJhbCBsIHYgZCByXG4gIDs7XG5cbiAgbGV0IGFkZF9leG4gdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgZmluZF9hbmRfYWRkX29yX3NldCB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IH5hZGRfb3Jfc2V0OkFkZF9leG5cbiAgOztcblxuICBsZXQgYWRkX2V4bl9pbnRlcm5hbCB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICB0XG4gICAgICB+bGVuZ3RoXG4gICAgICB+a2V5XG4gICAgICB+ZGF0YVxuICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICB+c2V4cF9vZl9rZXlcbiAgICAgIH5hZGRfb3Jfc2V0OkFkZF9leG5faW50ZXJuYWxcbiAgOztcblxuICBsZXQgc2V0IHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSA9XG4gICAgZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgdFxuICAgICAgfmxlbmd0aFxuICAgICAgfmtleVxuICAgICAgfmRhdGFcbiAgICAgIH5jb21wYXJlX2tleVxuICAgICAgfnNleHBfb2Zfa2V5OihmdW4gXyAtPiBMaXN0IFtdKVxuICAgICAgfmFkZF9vcl9zZXQ6U2V0XG4gIDs7XG5cbiAgbGV0IHNldCcgdCBrZXkgZGF0YSB+Y29tcGFyZV9rZXkgPSAoc2V0IHQgfmxlbmd0aDowIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5KS50cmVlXG5cbiAgbW9kdWxlIEJ1aWxkX2luY3JlYXNpbmcgOiBzaWdcbiAgICB0eXBlICgnaywgJ2QpIHRcblxuICAgIHZhbCBlbXB0eSA6ICgnaywgJ2QpIHRcbiAgICB2YWwgbWF4X2tleSA6ICgnaywgJ2QpIHQgLT4gJ2sgb3B0aW9uXG4gICAgdmFsIGFkZF91bmNoZWNrZWQgOiAoJ2ssICdkKSB0IC0+IGtleTonayAtPiBkYXRhOidkIC0+ICgnaywgJ2QpIHRcbiAgICB2YWwgdG9fdHJlZV91bmNoZWNrZWQgOiAoJ2ssICdkKSB0IC0+ICgnaywgJ2QpIHRyZWVcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSAoJ2ssICdkKSB0ID0gKCdrICogJ2QpIGxpc3RcblxuICAgIGxldCBlbXB0eSA9IFtdXG5cbiAgICBsZXQgbWF4X2tleSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgKGtleSwgXykgOjogXyAtPiBTb21lIGtleVxuICAgIDs7XG5cbiAgICBsZXQgYWRkX3VuY2hlY2tlZCB0IH5rZXkgfmRhdGEgPSAoa2V5LCBkYXRhKSA6OiB0XG5cbiAgICBsZXQgdG9fdHJlZV91bmNoZWNrZWQgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBFbXB0eVxuICAgICAgfCBbIChrZXksIGRhdGEpIF0gLT4gTGVhZiB7IGtleTsgZGF0YSB9XG4gICAgICB8IGxpc3QgLT5cbiAgICAgICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGxpc3QgaW5cbiAgICAgICAgbGV0IGxpc3QgPSByZWYgbGlzdCBpblxuICAgICAgICBsZXQgcmVjIGxvb3AgbGVuID1cbiAgICAgICAgICBtYXRjaCBsZW4sICFsaXN0IHdpdGhcbiAgICAgICAgICB8IDEsIChrZXksIGRhdGEpIDo6IHRhaWwgLT5cbiAgICAgICAgICAgIGxpc3QgOj0gdGFpbDtcbiAgICAgICAgICAgIExlYWYgeyBrZXk7IGRhdGEgfVxuICAgICAgICAgIHwgMiwgKGsyLCBkMikgOjogKGsxLCBkMSkgOjogdGFpbCAtPlxuICAgICAgICAgICAgbGlzdCA6PSB0YWlsO1xuICAgICAgICAgICAgTm9kZVxuICAgICAgICAgICAgICB7IGxlZnQgPSBFbXB0eVxuICAgICAgICAgICAgICA7IGtleSA9IGsxXG4gICAgICAgICAgICAgIDsgZGF0YSA9IGQxXG4gICAgICAgICAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gazI7IGRhdGEgPSBkMiB9XG4gICAgICAgICAgICAgIDsgaGVpZ2h0ID0gMlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfCAzLCAoazMsIGQzKSA6OiAoazIsIGQyKSA6OiAoazEsIGQxKSA6OiB0YWlsIC0+XG4gICAgICAgICAgICBsaXN0IDo9IHRhaWw7XG4gICAgICAgICAgICBOb2RlXG4gICAgICAgICAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBrMTsgZGF0YSA9IGQxIH1cbiAgICAgICAgICAgICAgOyBrZXkgPSBrMlxuICAgICAgICAgICAgICA7IGRhdGEgPSBkMlxuICAgICAgICAgICAgICA7IHJpZ2h0ID0gTGVhZiB7IGtleSA9IGszOyBkYXRhID0gZDMgfVxuICAgICAgICAgICAgICA7IGhlaWdodCA9IDJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIHwgXywgXyAtPlxuICAgICAgICAgICAgbGV0IG5yID0gbGVuIC8gMiBpblxuICAgICAgICAgICAgbGV0IG5sID0gbGVuIC0gbnIgLSAxIGluXG4gICAgICAgICAgICBsZXQgciA9IGxvb3AgbnIgaW5cbiAgICAgICAgICAgIChtYXRjaCAhbGlzdCB3aXRoXG4gICAgICAgICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgICB8IChrLCBkKSA6OiB0YWlsIC0+XG4gICAgICAgICAgICAgICBsaXN0IDo9IHRhaWw7XG4gICAgICAgICAgICAgICBsZXQgbCA9IGxvb3AgbmwgaW5cbiAgICAgICAgICAgICAgIGNyZWF0ZSBsIGsgZCByKVxuICAgICAgICBpblxuICAgICAgICBsb29wIGxlbiBbQG5vbnRhaWxdXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleSA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICBsZXQgeyB0cmVlID0gYnVpbGRlcjsgbGVuZ3RoIH0gPVxuICAgICAgICBTZXF1ZW5jZS5mb2xkXG4gICAgICAgICAgc2VxXG4gICAgICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBCdWlsZF9pbmNyZWFzaW5nLmVtcHR5IDApXG4gICAgICAgICAgfmY6KGZ1biB7IHRyZWUgPSBidWlsZGVyOyBsZW5ndGggfSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgIG1hdGNoIEJ1aWxkX2luY3JlYXNpbmcubWF4X2tleSBidWlsZGVyIHdpdGhcbiAgICAgICAgICB8IFNvbWUgcHJldl9rZXkgd2hlbiBjb21wYXJlX2tleSBwcmV2X2tleSBrZXkgPj0gMCAtPlxuICAgICAgICAgICAgcmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlOiBub24taW5jcmVhc2luZyBrZXlcIilcbiAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIHdpdGhfbGVuZ3RoX2dsb2JhbFxuICAgICAgICAgICAgICAoQnVpbGRfaW5jcmVhc2luZy5hZGRfdW5jaGVja2VkIGJ1aWxkZXIgfmtleSB+ZGF0YSlcbiAgICAgICAgICAgICAgKGxlbmd0aCArIDEpKVxuICAgICAgaW5cbiAgICAgIE9rICh3aXRoX2xlbmd0aF9nbG9iYWwgKEJ1aWxkX2luY3JlYXNpbmcudG9fdHJlZV91bmNoZWNrZWQgYnVpbGRlcikgbGVuZ3RoKSlcbiAgOztcblxuICAoKiBMaWtlIFtiYWxdIGJ1dCBhbGxvd3MgYW55IGRpZmZlcmVuY2UgaW4gaGVpZ2h0IGJldHdlZW4gW2xdIGFuZCBbcl0uXG5cbiAgICAgTyh8aGVpZ2h0IGwgLSBoZWlnaHQgcnwpICopXG4gIGxldCByZWMgam9pbiBsIGsgZCByID1cbiAgICBtYXRjaCBsLCByIHdpdGhcbiAgICB8IEVtcHR5LCBfIC0+IHNldF9taW4gayBkIHJcbiAgICB8IF8sIEVtcHR5IC0+IHNldF9tYXggbCBrIGRcbiAgICB8IExlYWYgeyBrZXkgPSBsazsgZGF0YSA9IGxkIH0sIF8gLT4gc2V0X21pbiBsayBsZCAoc2V0X21pbiBrIGQgcilcbiAgICB8IF8sIExlYWYgeyBrZXkgPSByazsgZGF0YSA9IHJkIH0gLT4gc2V0X21heCAoc2V0X21heCBsIGsgZCkgcmsgcmRcbiAgICB8ICggTm9kZSB7IGxlZnQgPSBsbDsga2V5ID0gbGs7IGRhdGEgPSBsZDsgcmlnaHQgPSBscjsgaGVpZ2h0ID0gbGggfVxuICAgICAgLCBOb2RlIHsgbGVmdCA9IHJsOyBrZXkgPSByazsgZGF0YSA9IHJkOyByaWdodCA9IHJyOyBoZWlnaHQgPSByaCB9ICkgLT5cbiAgICAgIGxldCBsLCBrLCBkLCByID1cbiAgICAgICAgKCogW2JhbF0gcmVxdWlyZXMgaGVpZ2h0IGRpZmZlcmVuY2UgPD0gMy4gKilcbiAgICAgICAgaWYgbGggPiByaCArIDNcbiAgICAgICAgICAgKCogW2hlaWdodCBsciA+PSBoZWlnaHQgcl0sXG4gICAgICAgICAgIHRoZXJlZm9yZSBbaGVpZ2h0IChqb2luIGxyIGsgZCByIC4uLildIGlzIFtoZWlnaHQgcmwgKyAxXSBvciBbaGVpZ2h0IHJsXVxuICAgICAgICAgICB0aGVyZWZvcmUgdGhlIGhlaWdodCBkaWZmZXJlbmNlIHdpdGggW2xsXSB3aWxsIGJlIDw9IDMgKilcbiAgICAgICAgdGhlbiBsbCwgbGssIGxkLCBqb2luIGxyIGsgZCByXG4gICAgICAgIGVsc2UgaWYgcmggPiBsaCArIDNcbiAgICAgICAgdGhlbiBqb2luIGwgayBkIHJsLCByaywgcmQsIHJyXG4gICAgICAgIGVsc2UgbCwgaywgZCwgclxuICAgICAgaW5cbiAgICAgIGJhbCBsIGsgZCByXG4gIDs7XG5cbiAgbGV0W0BpbmxpbmVdIHJlYyBzcGxpdF9nZW4gdCB4IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eSwgTm9uZSwgRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSBrOyBkYXRhID0gZCB9IC0+XG4gICAgICBsZXQgY21wID0gY29tcGFyZV9rZXkgayBpblxuICAgICAgaWYgY21wID0gMFxuICAgICAgdGhlbiBFbXB0eSwgU29tZSAoaywgZCksIEVtcHR5XG4gICAgICBlbHNlIGlmIGNtcCA8IDBcbiAgICAgIHRoZW4gRW1wdHksIE5vbmUsIHRcbiAgICAgIGVsc2UgdCwgTm9uZSwgRW1wdHlcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gazsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBsZXQgY21wID0gY29tcGFyZV9rZXkgayBpblxuICAgICAgaWYgY21wID0gMFxuICAgICAgdGhlbiBsLCBTb21lIChrLCBkKSwgclxuICAgICAgZWxzZSBpZiBjbXAgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGxsLCBtYXliZSwgbHIgPSBzcGxpdF9nZW4gbCB4IH5jb21wYXJlX2tleSBpblxuICAgICAgICBsbCwgbWF5YmUsIGpvaW4gbHIgayBkIHIpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJsLCBtYXliZSwgcnIgPSBzcGxpdF9nZW4gciB4IH5jb21wYXJlX2tleSBpblxuICAgICAgICBqb2luIGwgayBkIHJsLCBtYXliZSwgcnIpXG4gIDs7XG5cbiAgbGV0IHNwbGl0IHQgeCB+Y29tcGFyZV9rZXkgPSBzcGxpdF9nZW4gdCB4IH5jb21wYXJlX2tleTooZnVuIHkgLT4gY29tcGFyZV9rZXkgeCB5KVxuXG4gICgqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmVhbGx5IHJlaW5zZXJ0IFt4XSwgYnV0IGp1c3QgYXJyYW5nZXMgc28gdGhhdCBbc3BsaXRdXG4gICAgIHByb2R1Y2VzIHRoZSBlcXVpdmFsZW50IHRyZWUgaW4gdGhlIGZpcnN0IHBsYWNlLiAqKVxuICBsZXQgc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG8geCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBsZWZ0LCBib3VuZGFyeV9vcHQsIHJpZ2h0ID1cbiAgICAgIHNwbGl0X2dlblxuICAgICAgICB0XG4gICAgICAgIHhcbiAgICAgICAgfmNvbXBhcmVfa2V5OlxuICAgICAgICAgIChtYXRjaCBpbnRvIHdpdGhcbiAgICAgICAgICAgfCBgTGVmdCAtPlxuICAgICAgICAgICAgIGZ1biB5IC0+XG4gICAgICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9rZXkgeCB5IHdpdGhcbiAgICAgICAgICAgICAgICB8IDAgLT4gMVxuICAgICAgICAgICAgICAgIHwgcmVzIC0+IHJlcylcbiAgICAgICAgICAgfCBgUmlnaHQgLT5cbiAgICAgICAgICAgICBmdW4geSAtPlxuICAgICAgICAgICAgICAgKG1hdGNoIGNvbXBhcmVfa2V5IHggeSB3aXRoXG4gICAgICAgICAgICAgICAgfCAwIC0+IC0xXG4gICAgICAgICAgICAgICAgfCByZXMgLT4gcmVzKSlcbiAgICBpblxuICAgIGFzc2VydCAoT3B0aW9uLmlzX25vbmUgYm91bmRhcnlfb3B0KTtcbiAgICBsZWZ0LCByaWdodFxuICA7O1xuXG4gIGxldCBzcGxpdF9yYW5nZVxuICAgIHRcbiAgICB+KGxvd2VyX2JvdW5kIDogJ2EgTWF5YmVfYm91bmQudClcbiAgICB+KHVwcGVyX2JvdW5kIDogJ2EgTWF5YmVfYm91bmQudClcbiAgICB+Y29tcGFyZV9rZXlcbiAgICA9XG4gICAgaWYgTWF5YmVfYm91bmQuYm91bmRzX2Nyb3NzZWRcbiAgICAgICAgIH5jb21wYXJlOmNvbXBhcmVfa2V5XG4gICAgICAgICB+bG93ZXI6bG93ZXJfYm91bmRcbiAgICAgICAgIH51cHBlcjp1cHBlcl9ib3VuZFxuICAgIHRoZW4gZW1wdHksIGVtcHR5LCBlbXB0eVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGxlZnQsIG1pZF9hbmRfcmlnaHQgPVxuICAgICAgICBtYXRjaCBsb3dlcl9ib3VuZCB3aXRoXG4gICAgICAgIHwgVW5ib3VuZGVkIC0+IGVtcHR5LCB0XG4gICAgICAgIHwgSW5jbCBsYiAtPiBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YFJpZ2h0IHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICAgIHwgRXhjbCBsYiAtPiBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YExlZnQgdCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgIGluXG4gICAgICBsZXQgbWlkLCByaWdodCA9XG4gICAgICAgIG1hdGNoIHVwcGVyX2JvdW5kIHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQgLT4gbWlkX2FuZF9yaWdodCwgZW1wdHlcbiAgICAgICAgfCBJbmNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgTGVmdCBtaWRfYW5kX3JpZ2h0IGxiIH5jb21wYXJlX2tleVxuICAgICAgICB8IEV4Y2wgbGIgLT5cbiAgICAgICAgICBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YFJpZ2h0IG1pZF9hbmRfcmlnaHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICBpblxuICAgICAgbGVmdCwgbWlkLCByaWdodClcbiAgOztcblxuICBsZXQgcmVjIGZpbmQgdCB4IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPiBpZiBjb21wYXJlX2tleSB4IHYgPSAwIHRoZW4gU29tZSBkIGVsc2UgTm9uZVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICBpZiBjID0gMCB0aGVuIFNvbWUgZCBlbHNlIGZpbmQgKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBkYXRhID0gZGF0YSA6OiBPcHRpb24udmFsdWUgKGZpbmQgdCBrZXkgfmNvbXBhcmVfa2V5KSB+ZGVmYXVsdDpbXSBpblxuICAgIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgdCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgZmluZF9tdWx0aSB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBmaW5kIHQgeCB+Y29tcGFyZV9rZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBbXVxuICAgIHwgU29tZSBsIC0+IGxcbiAgOztcblxuICBsZXQgZmluZF9leG4gPVxuICAgIGxldCBpZl9ub3RfZm91bmQga2V5IH5zZXhwX29mX2tleSA9XG4gICAgICByYWlzZSAoTm90X2ZvdW5kX3MgKExpc3QgWyBBdG9tIFwiTWFwLmZpbmRfZXhuOiBub3QgZm91bmRcIjsgc2V4cF9vZl9rZXkga2V5IF0pKVxuICAgIGluXG4gICAgbGV0IHJlYyBmaW5kX2V4biB0IHggfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaWZfbm90X2ZvdW5kIHggfnNleHBfb2Zfa2V5XG4gICAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+XG4gICAgICAgIGlmIGNvbXBhcmVfa2V5IHggdiA9IDAgdGhlbiBkIGVsc2UgaWZfbm90X2ZvdW5kIHggfnNleHBfb2Zfa2V5XG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gZCBlbHNlIGZpbmRfZXhuIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXlcbiAgICBpblxuICAgICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgICBmaW5kX2V4blxuICA7O1xuXG4gIGxldCBtZW0gdCB4IH5jb21wYXJlX2tleSA9IE9wdGlvbi5pc19zb21lIChmaW5kIHQgeCB+Y29tcGFyZV9rZXkpXG5cbiAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBrZXkgPSBrOyBkYXRhID0gZCB9IC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBrOyBkYXRhID0gZDsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfIH0gLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gXzsgZGF0YSA9IF87IHJpZ2h0ID0gXzsgaGVpZ2h0ID0gXyB9IC0+IG1pbl9lbHQgbFxuICA7O1xuXG4gIGV4Y2VwdGlvbiBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwIFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwXVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICB8IE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXAgLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFwLm1sLlRyZWUwLk1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBcIlxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGV4Y2VwdGlvbiBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwIFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwXVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICB8IE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXAgLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFwLm1sLlRyZWUwLk1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXBcIlxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBtaW5fZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtaW5fZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwXG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsga2V5ID0gazsgZGF0YSA9IGQgfSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBrOyBkYXRhID0gZDsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gXyB9IC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IF87IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPiBtYXhfZWx0IHJcbiAgOztcblxuICBsZXQgbWF4X2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWF4X2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0IHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAucmVtb3ZlX21pbl9lbHRcIlxuICAgIHwgTGVhZiBfIC0+IEVtcHR5XG4gICAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBfOyBkYXRhID0gXzsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT4gclxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB4OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgeCBkIHJcbiAgOztcblxuICBsZXQgYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggbWF4X2VsdCBsb3dlcl9wYXJ0LCBtaW5fZWx0IHVwcGVyX3BhcnQgd2l0aFxuICAgIHwgTm9uZSwgXyAtPiBgT2sgdXBwZXJfcGFydFxuICAgIHwgXywgTm9uZSAtPiBgT2sgbG93ZXJfcGFydFxuICAgIHwgU29tZSAobWF4X2xvd2VyLCBfKSwgU29tZSAobWluX3VwcGVyLCB2KSB3aGVuIGNvbXBhcmVfa2V5IG1heF9sb3dlciBtaW5fdXBwZXIgPCAwIC0+XG4gICAgICBsZXQgdXBwZXJfcGFydF93aXRob3V0X21pbiA9IHJlbW92ZV9taW5fZWx0IHVwcGVyX3BhcnQgaW5cbiAgICAgIGBPayAoam9pbiBsb3dlcl9wYXJ0IG1pbl91cHBlciB2IHVwcGVyX3BhcnRfd2l0aG91dF9taW4pXG4gICAgfCBfIC0+IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzXG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlID1cbiAgICAoKiBUaGlzIGFzc3VtZXMgdGhhdCBtaW4gPD0gbWF4LCB3aGljaCBpcyBjaGVja2VkIGJ5IHRoZSBvdXRlciBmdW5jdGlvbi4gKilcbiAgICBsZXQgcmVjIGdvIHQgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaW5pdFxuICAgICAgfCBMZWFmIHsga2V5ID0gazsgZGF0YSA9IGQgfSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSBrIG1pbiA8IDAgfHwgY29tcGFyZV9rZXkgayBtYXggPiAwXG4gICAgICAgIHRoZW4gKCogayA8IG1pbiB8fCBrID4gbWF4ICopXG4gICAgICAgICAgaW5pdFxuICAgICAgICBlbHNlIGYgfmtleTprIH5kYXRhOmQgaW5pdFxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IGs7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICBsZXQgY19taW4gPSBjb21wYXJlX2tleSBrIG1pbiBpblxuICAgICAgICBpZiBjX21pbiA8IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIGlmIGsgPCBtaW4sIHRoZW4gdGhpcyBub2RlIGFuZCBpdHMgbGVmdCBicmFuY2ggYXJlIG91dHNpZGUgb3VyIHJhbmdlICopXG4gICAgICAgICAgZ28gciB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5XG4gICAgICAgIGVsc2UgaWYgY19taW4gPSAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICAoKiBpZiBrID0gbWluLCB0aGVuIHRoaXMgbm9kZSdzIGxlZnQgYnJhbmNoIGlzIG91dHNpZGUgb3VyIHJhbmdlICopXG4gICAgICAgICAgZ28gciB+bWluIH5tYXggfmluaXQ6KGYgfmtleTprIH5kYXRhOmQgaW5pdCkgfmYgfmNvbXBhcmVfa2V5XG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGsgPiBtaW4gKilcbiAgICAgICAgICBsZXQgeiA9IGdvIGwgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSBpblxuICAgICAgICAgIGxldCBjX21heCA9IGNvbXBhcmVfa2V5IGsgbWF4IGluXG4gICAgICAgICAgKCogaWYgayA+IG1heCwgd2UncmUgZG9uZSAqKVxuICAgICAgICAgIGlmIGNfbWF4ID4gMFxuICAgICAgICAgIHRoZW4gelxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IHogPSBmIH5rZXk6ayB+ZGF0YTpkIHogaW5cbiAgICAgICAgICAgICgqIGlmIGsgPSBtYXgsIHRoZW4gd2UgZm9sZCBpbiB0aGlzIG9uZSBsYXN0IHZhbHVlIGFuZCB3ZSdyZSBkb25lICopXG4gICAgICAgICAgICBpZiBjX21heCA9IDAgdGhlbiB6IGVsc2UgZ28gciB+bWluIH5tYXggfmluaXQ6eiB+ZiB+Y29tcGFyZV9rZXkpKVxuICAgIGluXG4gICAgZnVuIHQgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSAtPlxuICAgICAgaWYgY29tcGFyZV9rZXkgbWluIG1heCA8PSAwIHRoZW4gZ28gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IGVsc2UgaW5pdFxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCB+Y29tcGFyZV9rZXkgPVxuICAgIExpc3QucmV2XG4gICAgICAoZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICAgICAgIHRcbiAgICAgICAgIH5taW5cbiAgICAgICAgIH5tYXhcbiAgICAgICAgIH5pbml0OltdXG4gICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgbCAtPiAoa2V5LCBkYXRhKSA6OiBsKVxuICAgICAgICAgfmNvbXBhcmVfa2V5KVxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbnM6XG4gICAgIC0gYWxsIGVsZW1lbnRzIGluIHQxIGFyZSBsZXNzIHRoYW4gZWxlbWVudHMgaW4gdDJcbiAgICAgLSB8aGVpZ2h0KHQxKSAtIGhlaWdodCh0Mil8IDw9IDIgKilcbiAgbGV0IGNvbmNhdF91bmNoZWNrZWQgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCAtPiB0XG4gICAgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+XG4gICAgICBsZXQgeCwgZCA9IG1pbl9lbHRfZXhuIHQyIGluXG4gICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2VsdCB0MilcbiAgOztcblxuICAoKiBzaW1pbGFyIHRvIFtjb25jYXRfdW5jaGVja2VkXSwgYW5kIGJhbGFuY2VzIHRyZWVzIG9mIGFyYml0cmFyeSBoZWlnaHQgZGlmZmVyZW5jZXMgKilcbiAgbGV0IGNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCAtPiB0XG4gICAgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+XG4gICAgICBsZXQgeCwgZCA9IG1pbl9lbHRfZXhuIHQyIGluXG4gICAgICBqb2luIHQxIHggZCAocmVtb3ZlX21pbl9lbHQgdDIpXG4gIDs7XG5cbiAgbGV0IHJlYyByZW1vdmUgdCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IHdpdGhfbGVuZ3RoIHQgbGVuZ3RoXG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IF8gfSAtPlxuICAgICAgaWYgY29tcGFyZV9rZXkgeCB2ID0gMCB0aGVuIHdpdGhfbGVuZ3RoIEVtcHR5IChsZW5ndGggLSAxKSBlbHNlIHdpdGhfbGVuZ3RoIHQgbGVuZ3RoXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIHdpdGhfbGVuZ3RoIChjb25jYXRfdW5jaGVja2VkIGwgcikgKGxlbmd0aCAtIDEpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGwsIHIsIGxlbmd0aCcgPVxuICAgICAgICAgIGlmIGMgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgeyB0cmVlID0gbDsgbGVuZ3RoID0gbGVuZ3RoJyB9ID0gcmVtb3ZlIGwgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICAgICAgbCwgciwgbGVuZ3RoJylcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCB7IHRyZWUgPSByOyBsZW5ndGggPSBsZW5ndGgnIH0gPSByZW1vdmUgciB4IH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgICBsLCByLCBsZW5ndGgnKVxuICAgICAgICBpblxuICAgICAgICBpZiBsZW5ndGggPSBsZW5ndGgnXG4gICAgICAgIHRoZW4gd2l0aF9sZW5ndGggdCBsZW5ndGhcbiAgICAgICAgZWxzZSB3aXRoX2xlbmd0aCAoYmFsIGwgdiBkIHIpIGxlbmd0aCcpXG4gIDs7XG5cbiAgbGV0IHJlYyBjaGFuZ2UgdCBrZXkgfmYgfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT5cbiAgICAgIChtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgIHwgTm9uZSAtPiB3aXRoX2xlbmd0aCBFbXB0eSBsZW5ndGhcbiAgICAgICB8IFNvbWUgZGF0YSAtPiB3aXRoX2xlbmd0aCAoTGVhZiB7IGtleTsgZGF0YSB9KSAobGVuZ3RoICsgMSkpXG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHdpdGhfbGVuZ3RoIEVtcHR5IChsZW5ndGggLSAxKVxuICAgICAgICB8IFNvbWUgZCcgLT4gd2l0aF9sZW5ndGggKExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCcgfSkgbGVuZ3RoKVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB7IHRyZWUgPSBsJzsgbGVuZ3RoIH0gPSBjaGFuZ2UgRW1wdHkga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGlmIHBoeXNfZXF1YWwgbCcgdFxuICAgICAgICB0aGVuIHdpdGhfbGVuZ3RoIHQgbGVuZ3RoXG4gICAgICAgIGVsc2Ugd2l0aF9sZW5ndGggKGJhbCBsJyB2IGQgRW1wdHkpIGxlbmd0aClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgeyB0cmVlID0gcic7IGxlbmd0aCB9ID0gY2hhbmdlIEVtcHR5IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICBpZiBwaHlzX2VxdWFsIHInIHRcbiAgICAgICAgdGhlbiB3aXRoX2xlbmd0aCB0IGxlbmd0aFxuICAgICAgICBlbHNlIHdpdGhfbGVuZ3RoIChiYWwgRW1wdHkgdiBkIHInKSBsZW5ndGgpXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHdpdGhfbGVuZ3RoIChjb25jYXRfdW5jaGVja2VkIGwgcikgKGxlbmd0aCAtIDEpXG4gICAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgd2l0aF9sZW5ndGggKE5vZGUgeyBsZWZ0ID0gbDsga2V5OyBkYXRhOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSkgbGVuZ3RoKVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB7IHRyZWUgPSBsJzsgbGVuZ3RoIH0gPSBjaGFuZ2UgbCBrZXkgfmYgfmxlbmd0aCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgaWYgcGh5c19lcXVhbCBsJyBsXG4gICAgICAgIHRoZW4gd2l0aF9sZW5ndGggdCBsZW5ndGhcbiAgICAgICAgZWxzZSB3aXRoX2xlbmd0aCAoYmFsIGwnIHYgZCByKSBsZW5ndGgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHsgdHJlZSA9IHInOyBsZW5ndGggfSA9IGNoYW5nZSByIGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICBpZiBwaHlzX2VxdWFsIHInIHJcbiAgICAgICAgdGhlbiB3aXRoX2xlbmd0aCB0IGxlbmd0aFxuICAgICAgICBlbHNlIHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgcicpIGxlbmd0aClcbiAgOztcblxuICBsZXQgcmVjIHVwZGF0ZSB0IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgbGV0IGRhdGEgPSBmIE5vbmUgaW5cbiAgICAgIHdpdGhfbGVuZ3RoIChMZWFmIHsga2V5OyBkYXRhIH0pIChsZW5ndGggKyAxKVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGQnID0gZiAoU29tZSBkKSBpblxuICAgICAgICB3aXRoX2xlbmd0aCAoTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkJyB9KSBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHsgdHJlZSA9IGw7IGxlbmd0aCB9ID0gdXBkYXRlIEVtcHR5IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICB3aXRoX2xlbmd0aCAoYmFsIGwgdiBkIEVtcHR5KSBsZW5ndGgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHsgdHJlZSA9IHI7IGxlbmd0aCB9ID0gdXBkYXRlIEVtcHR5IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICB3aXRoX2xlbmd0aCAoYmFsIEVtcHR5IHYgZCByKSBsZW5ndGgpXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgZGF0YSA9IGYgKFNvbWUgZCkgaW5cbiAgICAgICAgd2l0aF9sZW5ndGggKE5vZGUgeyBsZWZ0ID0gbDsga2V5OyBkYXRhOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSkgbGVuZ3RoKVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB7IHRyZWUgPSBsOyBsZW5ndGggfSA9IHVwZGF0ZSBsIGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICB3aXRoX2xlbmd0aCAoYmFsIGwgdiBkIHIpIGxlbmd0aClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgeyB0cmVlID0gcjsgbGVuZ3RoIH0gPSB1cGRhdGUgciBrZXkgfmYgfmxlbmd0aCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgd2l0aF9sZW5ndGggKGJhbCBsIHYgZCByKSBsZW5ndGgpXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9tdWx0aSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgY2hhbmdlIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5IH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIHwgU29tZSAoW10gfCBbIF8gXSkgLT4gTm9uZVxuICAgICAgfCBTb21lIChfIDo6IChfIDo6IF8gYXMgbm9uX2VtcHR5X3RhaWwpKSAtPiBTb21lIG5vbl9lbXB0eV90YWlsKVxuICA7O1xuXG4gIGxldCByZWMgaXRlcl9rZXlzIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gXyB9IC0+IGYgdlxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gXzsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGl0ZXJfa2V5cyB+ZiBsO1xuICAgICAgZiB2O1xuICAgICAgaXRlcl9rZXlzIH5mIHJcbiAgOztcblxuICBsZXQgcmVjIGl0ZXIgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiB7IGtleSA9IF87IGRhdGEgPSBkIH0gLT4gZiBkXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IF87IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgaXRlciB+ZiBsO1xuICAgICAgZiBkO1xuICAgICAgaXRlciB+ZiByXG4gIDs7XG5cbiAgbGV0IHJlYyBpdGVyaSB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPiBmIH5rZXk6diB+ZGF0YTpkXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgaXRlcmkgfmYgbDtcbiAgICAgIGYgfmtleTp2IH5kYXRhOmQ7XG4gICAgICBpdGVyaSB+ZiByXG4gIDs7XG5cbiAgbGV0IGl0ZXJpX3VudGlsID1cbiAgICBsZXQgcmVjIGl0ZXJpX3VudGlsX2xvb3AgdCB+ZiA6IENvbnRpbnVlX29yX3N0b3AudCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQ29udGludWVcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT4gZiB+a2V5OnYgfmRhdGE6ZFxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICAobWF0Y2ggaXRlcmlfdW50aWxfbG9vcCB+ZiBsIHdpdGhcbiAgICAgICAgIHwgU3RvcCAtPiBTdG9wXG4gICAgICAgICB8IENvbnRpbnVlIC0+XG4gICAgICAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCAtPiBTdG9wXG4gICAgICAgICAgICB8IENvbnRpbnVlIC0+IGl0ZXJpX3VudGlsX2xvb3AgfmYgcikpXG4gICAgaW5cbiAgICBmdW4gdCB+ZiAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLm9mX2NvbnRpbnVlX29yX3N0b3AgKGl0ZXJpX3VudGlsX2xvb3AgdCB+ZilcbiAgOztcblxuICBsZXQgcmVjIG1hcCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPiBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGYgZCB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSAtPlxuICAgICAgbGV0IGwnID0gbWFwIH5mIGwgaW5cbiAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgbGV0IHInID0gbWFwIH5mIHIgaW5cbiAgICAgIE5vZGUgeyBsZWZ0ID0gbCc7IGtleSA9IHY7IGRhdGEgPSBkJzsgcmlnaHQgPSByJzsgaGVpZ2h0ID0gaCB9XG4gIDs7XG5cbiAgbGV0IHJlYyBtYXBpIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZiB+a2V5OnYgfmRhdGE6ZCB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSAtPlxuICAgICAgbGV0IGwnID0gbWFwaSB+ZiBsIGluXG4gICAgICBsZXQgZCcgPSBmIH5rZXk6diB+ZGF0YTpkIGluXG4gICAgICBsZXQgcicgPSBtYXBpIH5mIHIgaW5cbiAgICAgIE5vZGUgeyBsZWZ0ID0gbCc7IGtleSA9IHY7IGRhdGEgPSBkJzsgcmlnaHQgPSByJzsgaGVpZ2h0ID0gaCB9XG4gIDs7XG5cbiAgbGV0IHJlYyBmb2xkIHQgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY3VcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBmb2xkIH5mIHIgfmluaXQ6KGYgfmtleTp2IH5kYXRhOmQgKGZvbGQgfmYgbCB+aW5pdDphY2N1KSlcbiAgOztcblxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPVxuICAgIGxldCByZWMgZm9sZF91bnRpbF9sb29wIHQgfmFjYyB+ZiA6IChfLCBfKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250aW51ZSBhY2NcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT4gZiB+a2V5OnYgfmRhdGE6ZCBhY2NcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgICAgKG1hdGNoIGZvbGRfdW50aWxfbG9vcCBsIH5hY2MgfmYgd2l0aFxuICAgICAgICAgfCBTdG9wIGZpbmFsIC0+IFN0b3AgZmluYWxcbiAgICAgICAgIHwgQ29udGludWUgYWNjIC0+XG4gICAgICAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIGFjYyB3aXRoXG4gICAgICAgICAgICB8IFN0b3AgZmluYWwgLT4gU3RvcCBmaW5hbFxuICAgICAgICAgICAgfCBDb250aW51ZSBhY2MgLT4gZm9sZF91bnRpbF9sb29wIHIgfmFjYyB+ZikpXG4gICAgaW5cbiAgICBtYXRjaCBmb2xkX3VudGlsX2xvb3AgdCB+YWNjOmluaXQgfmYgd2l0aFxuICAgIHwgQ29udGludWUgYWNjIC0+IGZpbmlzaCBhY2MgW0Bub250YWlsXVxuICAgIHwgU3RvcCBzdG9wIC0+IHN0b3BcbiAgOztcblxuICBsZXQgcmVjIGZvbGRfcmlnaHQgdCB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IGYgfmtleTp2IH5kYXRhOmQgYWNjdVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGZvbGRfcmlnaHQgfmYgbCB+aW5pdDooZiB+a2V5OnYgfmRhdGE6ZCAoZm9sZF9yaWdodCB+ZiByIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCByZWMgZmlsdGVyX21hcGkgdCB+ZiB+bGVuID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgd2l0aFxuICAgICAgIHwgU29tZSBuZXdfZGF0YSAtPiBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IG5ld19kYXRhIH1cbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIGRlY3IgbGVuO1xuICAgICAgICAgRW1wdHkpXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgbGV0IGwnID0gZmlsdGVyX21hcGkgbCB+ZiB+bGVuIGluXG4gICAgICBsZXQgbmV3X2RhdGEgPSBmIH5rZXk6diB+ZGF0YTpkIGluXG4gICAgICBsZXQgcicgPSBmaWx0ZXJfbWFwaSByIH5mIH5sZW4gaW5cbiAgICAgIChtYXRjaCBuZXdfZGF0YSB3aXRoXG4gICAgICAgfCBTb21lIG5ld19kYXRhIC0+IGpvaW4gbCcgdiBuZXdfZGF0YSByJ1xuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgZGVjciBsZW47XG4gICAgICAgICBjb25jYXRfYW5kX2JhbGFuY2VfdW5jaGVja2VkIGwnIHInKVxuICA7O1xuXG4gIGxldCByZWMgZmlsdGVyaSB0IH5mIH5sZW4gPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+XG4gICAgICAobWF0Y2ggZiB+a2V5OnYgfmRhdGE6ZCB3aXRoXG4gICAgICAgfCB0cnVlIC0+IHRcbiAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICBkZWNyIGxlbjtcbiAgICAgICAgIEVtcHR5KVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGxldCBsJyA9IGZpbHRlcmkgbCB+ZiB+bGVuIGluXG4gICAgICBsZXQga2VlcF9kYXRhID0gZiB+a2V5OnYgfmRhdGE6ZCBpblxuICAgICAgbGV0IHInID0gZmlsdGVyaSByIH5mIH5sZW4gaW5cbiAgICAgIGlmIHBoeXNfZXF1YWwgbCBsJyAmJiBrZWVwX2RhdGEgJiYgcGh5c19lcXVhbCByIHInXG4gICAgICB0aGVuIHRcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBrZWVwX2RhdGEgd2l0aFxuICAgICAgICB8IHRydWUgLT4gam9pbiBsJyB2IGQgcidcbiAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgIGRlY3IgbGVuO1xuICAgICAgICAgIGNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQgbCcgcicpXG4gIDs7XG5cbiAgbGV0IGZpbHRlciB0IH5mIH5sZW4gPSBmaWx0ZXJpIHQgfmxlbiB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlcl9rZXlzIHQgfmYgfmxlbiA9IGZpbHRlcmkgdCB+bGVuIH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5KSBbQG5vbnRhaWxdXG4gIGxldCBmaWx0ZXJfbWFwIHQgfmYgfmxlbiA9IGZpbHRlcl9tYXBpIHQgfmxlbiB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxuICBsZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9XG4gICAgbGV0IHQxLCB0MiA9XG4gICAgICBmb2xkXG4gICAgICAgIHRcbiAgICAgICAgfmluaXQ6KEJ1aWxkX2luY3JlYXNpbmcuZW1wdHksIEJ1aWxkX2luY3JlYXNpbmcuZW1wdHkpXG4gICAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSAodDEsIHQyKSAtPlxuICAgICAgICBtYXRjaCAoZiB+a2V5IH5kYXRhIDogXyBFaXRoZXIudCkgd2l0aFxuICAgICAgICB8IEZpcnN0IHggLT4gQnVpbGRfaW5jcmVhc2luZy5hZGRfdW5jaGVja2VkIHQxIH5rZXkgfmRhdGE6eCwgdDJcbiAgICAgICAgfCBTZWNvbmQgeSAtPiB0MSwgQnVpbGRfaW5jcmVhc2luZy5hZGRfdW5jaGVja2VkIHQyIH5rZXkgfmRhdGE6eSlcbiAgICBpblxuICAgIEJ1aWxkX2luY3JlYXNpbmcudG9fdHJlZV91bmNoZWNrZWQgdDEsIEJ1aWxkX2luY3JlYXNpbmcudG9fdHJlZV91bmNoZWNrZWQgdDJcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcCB0IH5mID0gcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxuICBsZXQgcGFydGl0aW9uaV90ZiB0IH5mID1cbiAgICBsZXQgcmVjIGxvb3AgdCB+ZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gRW1wdHksIEVtcHR5XG4gICAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+XG4gICAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIHdpdGhcbiAgICAgICAgIHwgdHJ1ZSAtPiB0LCBFbXB0eVxuICAgICAgICAgfCBmYWxzZSAtPiBFbXB0eSwgdClcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgICAgbGV0IGwndCwgbCdmID0gbG9vcCBsIH5mIGluXG4gICAgICAgIGxldCBrZWVwX2RhdGFfdCA9IGYgfmtleTp2IH5kYXRhOmQgaW5cbiAgICAgICAgbGV0IHIndCwgcidmID0gbG9vcCByIH5mIGluXG4gICAgICAgIGxldCBtayBsJyBrZWVwX2RhdGEgcicgPVxuICAgICAgICAgIGlmIHBoeXNfZXF1YWwgbCBsJyAmJiBrZWVwX2RhdGEgJiYgcGh5c19lcXVhbCByIHInXG4gICAgICAgICAgdGhlbiB0XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBtYXRjaCBrZWVwX2RhdGEgd2l0aFxuICAgICAgICAgICAgfCB0cnVlIC0+IGpvaW4gbCcgdiBkIHInXG4gICAgICAgICAgICB8IGZhbHNlIC0+IGNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQgbCcgcicpXG4gICAgICAgIGluXG4gICAgICAgIG1rIGwndCBrZWVwX2RhdGFfdCByJ3QsIG1rIGwnZiAobm90IGtlZXBfZGF0YV90KSByJ2ZcbiAgICBpblxuICAgIGxvb3AgdCB+ZlxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxuICBtb2R1bGUgRW51bSA9IHN0cnVjdFxuICAgIHR5cGUgaW5jcmVhc2luZ1xuICAgIHR5cGUgZGVjcmVhc2luZ1xuXG4gICAgdHlwZSAoJ2ssICd2LCAnZGlyZWN0aW9uKSB0ID1cbiAgICAgIHwgRW5kXG4gICAgICB8IE1vcmUgb2YgJ2sgKiAndiAqICgnaywgJ3YpIHRyZWUgKiAoJ2ssICd2LCAnZGlyZWN0aW9uKSB0XG5cbiAgICBsZXQgcmVjIGNvbnMgdCAoZSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0KSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IE1vcmUgKHYsIGQsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICBjb25zIGwgKE1vcmUgKHYsIGQsIHIsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGNvbnNfcmlnaHQgdCAoZSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0KSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IE1vcmUgKHYsIGQsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICBjb25zX3JpZ2h0IHIgKE1vcmUgKHYsIGQsIGwsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfdHJlZSB0cmVlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPSBjb25zIHRyZWUgRW5kXG4gICAgbGV0IG9mX3RyZWVfcmlnaHQgdHJlZSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0ID0gY29uc19yaWdodCB0cmVlIEVuZFxuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgICAgICBsb29wIChOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMSB9KSBlXG4gICAgICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSB2OyBkYXRhID0gXzsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH1cbiAgICAgICAgICB3aGVuIGNvbXBhcmUgdiBrZXkgPCAwIC0+IGxvb3AgciBlXG4gICAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgICAgICBsb29wIGwgKE1vcmUgKHYsIGQsIHIsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgICAgICBsb29wIChOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMSB9KSBlXG4gICAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gXzsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfIH1cbiAgICAgICAgICB3aGVuIGNvbXBhcmUgdiBrZXkgPiAwIC0+IGxvb3AgbCBlXG4gICAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgICAgICBsb29wIHIgKE1vcmUgKHYsIGQsIGwsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IHN0ZXBfZGVlcGVyX2V4biB0cmVlIGUgPVxuICAgICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPiBFbXB0eSwgTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+IGwsIE1vcmUgKHYsIGQsIHIsIGUpXG4gICAgOztcblxuICAgICgqIFtkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMl0gZHJvcHMgdGhlIGxhcmdlc3QgcGh5c2ljYWxseS1lcXVhbFxuICAgICAgIHByZWZpeCBvZiB0cmVlMSBhbmQgdHJlZTIgdGhhdCB0aGV5IHNoYXJlLCBhbmQgdGhlbiBwcmVwZW5kcyB0aGUgcmVtYWluaW5nIGRhdGFcbiAgICAgICBpbnRvIGFjYzEgYW5kIGFjYzIsIHJlc3BlY3RpdmVseS5cbiAgICAgICBUaGlzIGNhbiBiZSBhc3ltcHRvdGljYWxseSBmYXN0ZXIgdGhhbiBbY29uc10gZXZlbiBpZiBpdCBza2lwcyBhIHNtYWxsIHByb3BvcnRpb25cbiAgICAgICBvZiB0aGUgdHJlZSBiZWNhdXNlIFtjb25zXSBpcyBhbHdheXMgTyhsb2cobikpIGluIHRoZSBzaXplIG9mIHRoZSB0cmVlLCB3aGlsZVxuICAgICAgIHRoaXMgZnVuY3Rpb24gaXMgTyhsb2cobi9tKSkgd2hlcmUgW21dIGlzIHRoZSBzaXplIG9mIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIHRoYXRcbiAgICAgICBpcyBza2lwcGVkLiAqKVxuICAgIGxldCByZWMgZHJvcF9waHlzX2VxdWFsX3ByZWZpeCB0cmVlMSBhY2MxIHRyZWUyIGFjYzIgPVxuICAgICAgaWYgcGh5c19lcXVhbCB0cmVlMSB0cmVlMlxuICAgICAgdGhlbiBhY2MxLCBhY2MyXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGgyID0gaGVpZ2h0IHRyZWUyIGluXG4gICAgICAgIGxldCBoMSA9IGhlaWdodCB0cmVlMSBpblxuICAgICAgICBpZiBoMiA9IGgxXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCB0cmVlMSwgYWNjMSA9IHN0ZXBfZGVlcGVyX2V4biB0cmVlMSBhY2MxIGluXG4gICAgICAgICAgbGV0IHRyZWUyLCBhY2MyID0gc3RlcF9kZWVwZXJfZXhuIHRyZWUyIGFjYzIgaW5cbiAgICAgICAgICBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMilcbiAgICAgICAgZWxzZSBpZiBoMiA+IGgxXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCB0cmVlMiwgYWNjMiA9IHN0ZXBfZGVlcGVyX2V4biB0cmVlMiBhY2MyIGluXG4gICAgICAgICAgZHJvcF9waHlzX2VxdWFsX3ByZWZpeCB0cmVlMSBhY2MxIHRyZWUyIGFjYzIpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCB0cmVlMSwgYWNjMSA9IHN0ZXBfZGVlcGVyX2V4biB0cmVlMSBhY2MxIGluXG4gICAgICAgICAgZHJvcF9waHlzX2VxdWFsX3ByZWZpeCB0cmVlMSBhY2MxIHRyZWUyIGFjYzIpKVxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiAwXG4gICAgICAgIHwgRW5kLCBfIC0+IC0xXG4gICAgICAgIHwgXywgRW5kIC0+IDFcbiAgICAgICAgfCBNb3JlICh2MSwgZDEsIHIxLCBlMSksIE1vcmUgKHYyLCBkMiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBjID0gY29tcGFyZV9kYXRhIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgIGxldCBlMSwgZTIgPSBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHIxIGUxIHIyIGUyIGluXG4gICAgICAgICAgICAgIGxvb3AgZTEgZTIpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIGNvbXBhcmVfa2V5IGRhdGFfZXF1YWwgdDEgdDIgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiB0cnVlXG4gICAgICAgIHwgRW5kLCBfIHwgXywgRW5kIC0+IGZhbHNlXG4gICAgICAgIHwgTW9yZSAodjEsIGQxLCByMSwgZTEpLCBNb3JlICh2MiwgZDIsIHIyLCBlMikgLT5cbiAgICAgICAgICBjb21wYXJlX2tleSB2MSB2MiA9IDBcbiAgICAgICAgICAmJiBkYXRhX2VxdWFsIGQxIGQyXG4gICAgICAgICAgJiZcbiAgICAgICAgICBsZXQgZTEsIGUyID0gZHJvcF9waHlzX2VxdWFsX3ByZWZpeCByMSBlMSByMiBlMiBpblxuICAgICAgICAgIGxvb3AgZTEgZTJcbiAgICAgIGluXG4gICAgICBsb29wIHQxIHQyXG4gICAgOztcblxuICAgIGxldCByZWMgZm9sZCB+aW5pdCB+ZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVuZCAtPiBpbml0XG4gICAgICB8IE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgbGV0IG5leHQgPSBmIH5rZXkgfmRhdGEgaW5pdCBpblxuICAgICAgICBmb2xkIChjb25zIHRyZWUgZW51bSkgfmluaXQ6bmV4dCB+ZlxuICAgIDs7XG5cbiAgICBsZXQgZm9sZDIgY29tcGFyZV9rZXkgdDEgdDIgfmluaXQgfmYgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyIGN1cnIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IGN1cnJcbiAgICAgICAgfCBFbmQsIF8gLT5cbiAgICAgICAgICBmb2xkIHQyIH5pbml0OmN1cnIgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBmIH5rZXkgfmRhdGE6KGBSaWdodCBkYXRhKSBhY2MpIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgIHwgXywgRW5kIC0+XG4gICAgICAgICAgZm9sZCB0MSB+aW5pdDpjdXJyIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gZiB+a2V5IH5kYXRhOihgTGVmdCBkYXRhKSBhY2MpIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgfCBNb3JlIChrMSwgdjEsIHRyZWUxLCBlbnVtMSksIE1vcmUgKGsyLCB2MiwgdHJlZTIsIGVudW0yKSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfa2V5IGsxIGsyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGYgfmtleTprMSB+ZGF0YTooYEJvdGggKHYxLCB2MikpIGN1cnIgaW5cbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIChjb25zIHRyZWUyIGVudW0yKSBuZXh0KVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGYgfmtleTprMSB+ZGF0YTooYExlZnQgdjEpIGN1cnIgaW5cbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIHQyIG5leHQpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGYgfmtleTprMiB+ZGF0YTooYFJpZ2h0IHYyKSBjdXJyIGluXG4gICAgICAgICAgICBsb29wIHQxIChjb25zIHRyZWUyIGVudW0yKSBuZXh0KVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDIgaW5pdCBbQG5vbnRhaWxdXG4gICAgOztcblxuICAgIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgPVxuICAgICAgbGV0IHN0ZXAgc3RhdGUgPVxuICAgICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICAgIHwgRW5kLCBNb3JlIChrZXksIGRhdGEsIHRyZWUsIGVudW0pIC0+XG4gICAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0ga2V5LCBgUmlnaHQgZGF0YTsgc3RhdGUgPSBFbmQsIGNvbnMgdHJlZSBlbnVtIH1cbiAgICAgICAgfCBNb3JlIChrZXksIGRhdGEsIHRyZWUsIGVudW0pLCBFbmQgLT5cbiAgICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrZXksIGBMZWZ0IGRhdGE7IHN0YXRlID0gY29ucyB0cmVlIGVudW0sIEVuZCB9XG4gICAgICAgIHwgKE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSBhcyBsZWZ0KSwgKE1vcmUgKGsyLCB2MiwgdHJlZTIsIGVudW0yKSBhcyByaWdodCkgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2tleSBrMSBrMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHRfc3RhdGUgPSBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGVudW0xIHRyZWUyIGVudW0yIGluXG4gICAgICAgICAgICBpZiBkYXRhX2VxdWFsIHYxIHYyXG4gICAgICAgICAgICB0aGVuIFNlcXVlbmNlLlN0ZXAuU2tpcCB7IHN0YXRlID0gbmV4dF9zdGF0ZSB9XG4gICAgICAgICAgICBlbHNlIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGsxLCBgVW5lcXVhbCAodjEsIHYyKTsgc3RhdGUgPSBuZXh0X3N0YXRlIH0pXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrMSwgYExlZnQgdjE7IHN0YXRlID0gY29ucyB0cmVlMSBlbnVtMSwgcmlnaHQgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGsyLCBgUmlnaHQgdjI7IHN0YXRlID0gbGVmdCwgY29ucyB0cmVlMiBlbnVtMiB9XG4gICAgICBpblxuICAgICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQ6KGRyb3BfcGh5c19lcXVhbF9wcmVmaXggdDEgRW5kIHQyIEVuZCkgfmY6c3RlcFxuICAgIDs7XG5cbiAgICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgICAgbGV0IGFkZCBhY2MgayB2ID0gZiBhY2MgKGssIGBSaWdodCB2KSBpblxuICAgICAgbGV0IHJlbW92ZSBhY2MgayB2ID0gZiBhY2MgKGssIGBMZWZ0IHYpIGluXG4gICAgICBsZXQgcmVjIGxvb3AgbGVmdCByaWdodCBhY2MgPVxuICAgICAgICBtYXRjaCBsZWZ0LCByaWdodCB3aXRoXG4gICAgICAgIHwgRW5kLCBlbnVtIC0+XG4gICAgICAgICAgZm9sZCBlbnVtIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCBhY2Mga2V5IGRhdGEpIFtAbm9udGFpbF1cbiAgICAgICAgfCBlbnVtLCBFbmQgLT5cbiAgICAgICAgICBmb2xkIGVudW0gfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIGFjYyBrZXkgZGF0YSkgW0Bub250YWlsXVxuICAgICAgICB8IChNb3JlIChrMSwgdjEsIHRyZWUxLCBlbnVtMSkgYXMgbGVmdCksIChNb3JlIChrMiwgdjIsIHRyZWUyLCBlbnVtMikgYXMgcmlnaHQpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9rZXkgazEgazIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBhY2MgPSBpZiBkYXRhX2VxdWFsIHYxIHYyIHRoZW4gYWNjIGVsc2UgZiBhY2MgKGsxLCBgVW5lcXVhbCAodjEsIHYyKSkgaW5cbiAgICAgICAgICAgIGxldCBlbnVtMSwgZW51bTIgPSBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGVudW0xIHRyZWUyIGVudW0yIGluXG4gICAgICAgICAgICBsb29wIGVudW0xIGVudW0yIGFjYylcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgazEgdjEgaW5cbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIHJpZ2h0IGFjYylcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBhY2MgPSBhZGQgYWNjIGsyIHYyIGluXG4gICAgICAgICAgICBsb29wIGxlZnQgKGNvbnMgdHJlZTIgZW51bTIpIGFjYylcbiAgICAgIGluXG4gICAgICBsZXQgbGVmdCwgcmlnaHQgPSBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHQxIEVuZCB0MiBFbmQgaW5cbiAgICAgIGxvb3AgbGVmdCByaWdodCBpbml0IFtAbm9udGFpbF1cbiAgICA7O1xuICBlbmRcblxuICBsZXQgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2tleSB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB2LCB0LCBlKSAtPlxuICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrLCB2OyBzdGF0ZSA9IEVudW0uY29ucyB0IGUgfVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9rZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2ZfdHJlZSB0XG4gICAgICB8IFNvbWUga2V5IC0+IEVudW0uc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQgfmY6bmV4dFxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHYsIHQsIGUpIC0+XG4gICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGssIHY7IHN0YXRlID0gRW51bS5jb25zX3JpZ2h0IHQgZSB9XG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2tleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl90cmVlX3JpZ2h0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlXG4gICAgY29tcGFyYXRvclxuICAgID8ob3JkZXIgPSBgSW5jcmVhc2luZ19rZXkpXG4gICAgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b1xuICAgID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG9cbiAgICB0XG4gICAgPVxuICAgIGxldCBpbmNsdXNpdmVfYm91bmQgc2lkZSB0IGJvdW5kID1cbiAgICAgIGxldCBjb21wYXJlX2tleSA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgICBsZXQgbCwgbWF5YmUsIHIgPSBzcGxpdCB0IGJvdW5kIH5jb21wYXJlX2tleSBpblxuICAgICAgbGV0IHQgPSBzaWRlIChsLCByKSBpblxuICAgICAgbWF0Y2ggbWF5YmUgd2l0aFxuICAgICAgfCBOb25lIC0+IHRcbiAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSAtPiBzZXQnIHQga2V5IGRhdGEgfmNvbXBhcmVfa2V5XG4gICAgaW5cbiAgICBtYXRjaCBvcmRlciB3aXRoXG4gICAgfCBgSW5jcmVhc2luZ19rZXkgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQga2V5c19sZXNzX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBmc3QpIGluXG4gICAgICB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5OmtleXNfZ3JlYXRlcl9vcl9lcXVhbF90byB0XG4gICAgfCBgRGVjcmVhc2luZ19rZXkgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQga2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBzbmQpIGluXG4gICAgICB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5OmtleXNfbGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBsZXQgZTEsIGUyID0gRW51bS5kcm9wX3BoeXNfZXF1YWxfcHJlZml4IHQxIEVuZCB0MiBFbmQgaW5cbiAgICBFbnVtLmNvbXBhcmUgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIGUxIGUyXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgbGV0IGUxLCBlMiA9IEVudW0uZHJvcF9waHlzX2VxdWFsX3ByZWZpeCB0MSBFbmQgdDIgRW5kIGluXG4gICAgRW51bS5lcXVhbCBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgZTEgZTJcbiAgOztcblxuICBsZXQgaXRlcjIgdDEgdDIgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBFbnVtLmZvbGQyXG4gICAgICBjb21wYXJlX2tleVxuICAgICAgKEVudW0ub2ZfdHJlZSB0MSlcbiAgICAgIChFbnVtLm9mX3RyZWUgdDIpXG4gICAgICB+aW5pdDooKVxuICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhICgpIC0+IGYgfmtleSB+ZGF0YSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmb2xkMiB0MSB0MiB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIEVudW0uZm9sZDIgY29tcGFyZV9rZXkgKEVudW0ub2ZfdHJlZSB0MSkgKEVudW0ub2ZfdHJlZSB0MikgfmYgfmluaXRcbiAgOztcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgPSBFbnVtLnN5bW1ldHJpY19kaWZmXG5cbiAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICAoKiBbRW51bS5mb2xkX2RpZmZzXSBpcyBhIGNvcnJlY3QgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiwgYnV0IGlzIGNvbnNpZGVyYWJseVxuICAgICAgIHNsb3dlciwgYXMgd2UgaGF2ZSB0byBhbGxvY2F0ZSBxdWl0ZSBhIGxvdCBvZiBzdGF0ZSB0byB0cmFjayBlbnVtZXJhdGlvbiBvZiBhIHRyZWUuXG4gICAgICAgQXZvaWQgaWYgd2UgY2FuLlxuICAgICopXG4gICAgbGV0IHNsb3cgeCB5IH5pbml0ID0gRW51bS5mb2xkX3N5bW1ldHJpY19kaWZmIHggeSB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmYgfmluaXQgaW5cbiAgICBsZXQgYWRkIGFjYyBrIHYgPSBmIGFjYyAoaywgYFJpZ2h0IHYpIGluXG4gICAgbGV0IHJlbW92ZSBhY2MgayB2ID0gZiBhY2MgKGssIGBMZWZ0IHYpIGluXG4gICAgbGV0IGRlbHRhIGFjYyBrIHYgdicgPSBpZiBkYXRhX2VxdWFsIHYgdicgdGhlbiBhY2MgZWxzZSBmIGFjYyAoaywgYFVuZXF1YWwgKHYsIHYnKSkgaW5cbiAgICAoKiBJZiB0d28gdHJlZXMgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXQgdGhlIHJvb3QgKGFuZCB0aGUgc2FtZSBrZXksIGlmIHRoZXkncmVcbiAgICAgICBbTm9kZV1zKSB3ZSBjYW4gdHJpdmlhbGx5IGRpZmYgZWFjaCBzdWJwYXJ0IGluIG9idmlvdXMgd2F5cy4gKilcbiAgICBsZXQgcmVjIGxvb3AgdCB0JyBhY2MgPVxuICAgICAgaWYgcGh5c19lcXVhbCB0IHQnXG4gICAgICB0aGVuIGFjY1xuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHQsIHQnIHdpdGhcbiAgICAgICAgfCBFbXB0eSwgbmV3X3ZhbHMgLT5cbiAgICAgICAgICBmb2xkIG5ld192YWxzIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCBhY2Mga2V5IGRhdGEpIFtAbm9udGFpbF1cbiAgICAgICAgfCBvbGRfdmFscywgRW1wdHkgLT5cbiAgICAgICAgICBmb2xkIG9sZF92YWxzIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IHJlbW92ZSBhY2Mga2V5IGRhdGEpIFtAbm9udGFpbF1cbiAgICAgICAgfCBMZWFmIHsga2V5ID0gazsgZGF0YSA9IHYgfSwgTGVhZiB7IGtleSA9IGsnOyBkYXRhID0gdicgfSAtPlxuICAgICAgICAgIChtYXRjaCBjb21wYXJlX2tleSBrIGsnIHdpdGhcbiAgICAgICAgICAgfCB4IHdoZW4geCA9IDAgLT4gZGVsdGEgYWNjIGsgdiB2J1xuICAgICAgICAgICB8IHggd2hlbiB4IDwgMCAtPlxuICAgICAgICAgICAgIGxldCBhY2MgPSByZW1vdmUgYWNjIGsgdiBpblxuICAgICAgICAgICAgIGFkZCBhY2MgaycgdidcbiAgICAgICAgICAgfCBfICgqIHdoZW4geCA+IDAgKikgLT5cbiAgICAgICAgICAgICBsZXQgYWNjID0gYWRkIGFjYyBrJyB2JyBpblxuICAgICAgICAgICAgIHJlbW92ZSBhY2MgayB2KVxuICAgICAgICB8ICggTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrOyBkYXRhID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH1cbiAgICAgICAgICAsIE5vZGUgeyBsZWZ0ID0gbCc7IGtleSA9IGsnOyBkYXRhID0gdic7IHJpZ2h0ID0gcic7IGhlaWdodCA9IF8gfSApXG4gICAgICAgICAgd2hlbiBjb21wYXJlX2tleSBrIGsnID0gMCAtPlxuICAgICAgICAgIGxldCBhY2MgPSBsb29wIGwgbCcgYWNjIGluXG4gICAgICAgICAgbGV0IGFjYyA9IGRlbHRhIGFjYyBrIHYgdicgaW5cbiAgICAgICAgICBsb29wIHIgcicgYWNjXG4gICAgICAgICgqIE91ciByb290cyBhcmVuJ3QgdGhlIHNhbWUga2V5LiBGYWxsYmFjayB0byB0aGUgc2xvdyBtb2RlLiBUcmVlcyB3aXRoIHNtYWxsXG4gICAgICAgICAgIGRpZmZzIHdpbGwgb25seSBkbyB0aGlzIG9uIHZlcnkgc21hbGwgcGFydHMgb2YgdGhlIHRyZWUgKGhvcGVmdWxseSAtIGlmIHRoZVxuICAgICAgICAgICBvdmVyYWxsIHJvb3QgaXMgcmViYWxhbmNlZCwgd2UnbGwgZWF0IHRoZSB3aG9sZSBjb3N0LCB1bmZvcnR1bmF0ZWx5LikgKilcbiAgICAgICAgfCBOb2RlIF8sIE5vZGUgXyB8IE5vZGUgXywgTGVhZiBfIHwgTGVhZiBfLCBOb2RlIF8gLT4gc2xvdyB0IHQnIH5pbml0OmFjYylcbiAgICBpblxuICAgIGxvb3AgdDEgdDIgaW5pdCBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHJlYyBsZW5ndGggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gXzsgZGF0YSA9IF87IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBsZW5ndGggbCArIGxlbmd0aCByICsgMVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0ID1cbiAgICBmb2xkXG4gICAgICB0XG4gICAgICB+aW5pdDooaGFzaF9mb2xkX2ludCBzdGF0ZSAobGVuZ3RoIHQpKVxuICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhIHN0YXRlIC0+IGhhc2hfZm9sZF9kYXRhIChoYXNoX2ZvbGRfa2V5IHN0YXRlIGtleSkgZGF0YSlcbiAgOztcblxuICBsZXQga2V5cyB0ID0gZm9sZF9yaWdodCB+ZjooZnVuIH5rZXkgfmRhdGE6XyBsaXN0IC0+IGtleSA6OiBsaXN0KSB0IH5pbml0OltdXG4gIGxldCBkYXRhIHQgPSBmb2xkX3JpZ2h0IH5mOihmdW4gfmtleTpfIH5kYXRhIGxpc3QgLT4gZGF0YSA6OiBsaXN0KSB0IH5pbml0OltdXG5cbiAgbW9kdWxlIHR5cGUgRm9sZGFibGUgPSBzaWdcbiAgICB2YWwgbmFtZSA6IHN0cmluZ1xuXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gJ2EgLT4gJ2FjYykgLT4gJ2FjY1xuICBlbmRcblxuICBsZXRbQGlubGluZSBhbHdheXNdIG9mX2ZvbGRhYmxlJyB+Zm9sZCBmb2xkYWJsZSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIChmb2xkIFtAaW5saW5lZCBoaW50XSlcbiAgICAgIGZvbGRhYmxlXG4gICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApXG4gICAgICB+ZjooZnVuIHsgdHJlZSA9IGFjY3VtOyBsZW5ndGggfSAoa2V5LCBkYXRhKSAtPlxuICAgICAgbGV0IHByZXZfZGF0YSA9XG4gICAgICAgIG1hdGNoIGZpbmQgYWNjdW0ga2V5IH5jb21wYXJlX2tleSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBpbml0XG4gICAgICAgIHwgU29tZSBwcmV2IC0+IHByZXZcbiAgICAgIGluXG4gICAgICBsZXQgZGF0YSA9IGYgcHJldl9kYXRhIGRhdGEgaW5cbiAgICAgIChzZXQgYWNjdW0gfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbiAgOztcblxuICBtb2R1bGUgT2ZfZm9sZGFibGUgKE0gOiBGb2xkYWJsZSkgPSBzdHJ1Y3RcbiAgICBsZXQgb2ZfZm9sZGFibGVfZm9sZCBmb2xkYWJsZSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgICAgb2ZfZm9sZGFibGUnIH5mb2xkOk0uZm9sZCBmb2xkYWJsZSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXlcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlX3JlZHVjZSBmb2xkYWJsZSB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgICAgTS5mb2xkXG4gICAgICAgIGZvbGRhYmxlXG4gICAgICAgIH5pbml0Oih3aXRoX2xlbmd0aF9nbG9iYWwgZW1wdHkgMClcbiAgICAgICAgfmY6KGZ1biB7IHRyZWUgPSBhY2N1bTsgbGVuZ3RoIH0gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgbGV0IG5ld19kYXRhID1cbiAgICAgICAgICBtYXRjaCBmaW5kIGFjY3VtIGtleSB+Y29tcGFyZV9rZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBkYXRhXG4gICAgICAgICAgfCBTb21lIHByZXYgLT4gZiBwcmV2IGRhdGFcbiAgICAgICAgaW5cbiAgICAgICAgKHNldCBhY2N1bSB+bGVuZ3RoIH5rZXkgfmRhdGE6bmV3X2RhdGEgfmNvbXBhcmVfa2V5IHw+IGdsb2JhbGl6ZSkgW0Bub250YWlsXSkgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGUgZm9sZGFibGUgfmNvbXBhcmVfa2V5ID1cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgbWFwID1cbiAgICAgICAgICBNLmZvbGRcbiAgICAgICAgICAgIGZvbGRhYmxlXG4gICAgICAgICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApXG4gICAgICAgICAgICB+ZjooZnVuIHsgdHJlZSA9IHQ7IGxlbmd0aCB9IChrZXksIGRhdGEpIC0+XG4gICAgICAgICAgICBsZXQgKHsgdHJlZSA9IF87IGxlbmd0aCA9IGxlbmd0aCcgfSBhcyBhY2MpID1cbiAgICAgICAgICAgICAgc2V0IH5sZW5ndGggfmtleSB+ZGF0YSB0IH5jb21wYXJlX2tleVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGlmIGxlbmd0aCA9IGxlbmd0aCdcbiAgICAgICAgICAgIHRoZW4gci5yZXR1cm4gKGBEdXBsaWNhdGVfa2V5IGtleSlcbiAgICAgICAgICAgIGVsc2UgZ2xvYmFsaXplIGFjYyBbQG5vbnRhaWxdKVxuICAgICAgICBpblxuICAgICAgICBgT2sgbWFwKVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfb3JfZXJyb3IgZm9sZGFibGUgfmNvbXBhcmF0b3IgPVxuICAgICAgbWF0Y2ggb2ZfZm9sZGFibGUgZm9sZGFibGUgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICAgIHwgYE9rIHggLT4gUmVzdWx0Lk9rIHhcbiAgICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICAgIE9yX2Vycm9yLmVycm9yXG4gICAgICAgICAgKFwiTWFwLm9mX1wiIF4gTS5uYW1lIF4gXCJfb3JfZXJyb3I6IGR1cGxpY2F0ZSBrZXlcIilcbiAgICAgICAgICBrZXlcbiAgICAgICAgICBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfZXhuIGZvbGRhYmxlIH5jb21wYXJhdG9yID1cbiAgICAgIG1hdGNoIG9mX2ZvbGRhYmxlIGZvbGRhYmxlIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgICB8IGBPayB4IC0+IHhcbiAgICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZSAoXCJNYXAub2ZfXCIgXiBNLm5hbWUgXiBcIl9leG46IGR1cGxpY2F0ZSBrZXlcIikga2V5IGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgICAgIHw+IEVycm9yLnJhaXNlXG4gICAgOztcblxuICAgICgqIFJldmVyc2UgdGhlIGlucHV0LCB0aGVuIGZvbGQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBUaGUgcmVzdWx0aW5nIG1hcCB1c2VzIHRoZSBmaXJzdFxuICAgICAgIGluc3RhbmNlIG9mIGVhY2gga2V5IGZyb20gdGhlIGlucHV0IGxpc3QuIFRoZSByZWxhdGl2ZSBvcmRlcmluZyBvZiBlbGVtZW50cyBpbiBlYWNoXG4gICAgICAgb3V0cHV0IGxpc3QgaXMgdGhlIHNhbWUgYXMgaW4gdGhlIGlucHV0IGxpc3QuICopXG4gICAgbGV0IG9mX2ZvbGRhYmxlX211bHRpIGZvbGRhYmxlIH5jb21wYXJlX2tleSA9XG4gICAgICBsZXQgYWxpc3QgPSBNLmZvbGQgZm9sZGFibGUgfmluaXQ6W10gfmY6KGZ1biBsIHggLT4geCA6OiBsKSBpblxuICAgICAgb2ZfZm9sZGFibGUnIGFsaXN0IH5mb2xkOkxpc3QuZm9sZCB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpIH5jb21wYXJlX2tleVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBPZl9hbGlzdCA9IE9mX2ZvbGRhYmxlIChzdHJ1Y3RcbiAgICBsZXQgbmFtZSA9IFwiYWxpc3RcIlxuXG4gICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgbGV0IGZvbGQgPSBMaXN0LmZvbGRcbiAgZW5kKVxuXG4gIGxldCBvZl9hbGlzdF9mb2xkID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfZm9sZFxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfcmVkdWNlXG4gIGxldCBvZl9hbGlzdCA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX29yX2Vycm9yXG4gIGxldCBvZl9hbGlzdF9leG4gPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9leG5cbiAgbGV0IG9mX2FsaXN0X211bHRpID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfbXVsdGlcblxuICBtb2R1bGUgT2Zfc2VxdWVuY2UgPSBPZl9mb2xkYWJsZSAoc3RydWN0XG4gICAgbGV0IG5hbWUgPSBcInNlcXVlbmNlXCJcblxuICAgIHR5cGUgJ2EgdCA9ICdhIFNlcXVlbmNlLnRcblxuICAgIGxldCBmb2xkID0gU2VxdWVuY2UuZm9sZFxuICBlbmQpXG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9mb2xkXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9yZWR1Y2VcbiAgbGV0IG9mX3NlcXVlbmNlID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVcbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfb3JfZXJyb3JcbiAgbGV0IG9mX3NlcXVlbmNlX2V4biA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX2V4blxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9tdWx0aVxuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5IGxpc3QgfmdldF9rZXkgfmNvbXBhcmVfa2V5ID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGxldCBtYXAgPVxuICAgICAgICBMaXN0LmZvbGRcbiAgICAgICAgICBsaXN0XG4gICAgICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKVxuICAgICAgICAgIH5mOihmdW4geyB0cmVlID0gdDsgbGVuZ3RoIH0gZGF0YSAtPlxuICAgICAgICAgIGxldCBrZXkgPSBnZXRfa2V5IGRhdGEgaW5cbiAgICAgICAgICBsZXQgKHsgdHJlZSA9IF87IGxlbmd0aCA9IG5ld19sZW5ndGggfSBhcyBhY2MpID1cbiAgICAgICAgICAgIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgdCB+Y29tcGFyZV9rZXlcbiAgICAgICAgICBpblxuICAgICAgICAgIGlmIGxlbmd0aCA9IG5ld19sZW5ndGhcbiAgICAgICAgICB0aGVuIHIucmV0dXJuIChgRHVwbGljYXRlX2tleSBrZXkpXG4gICAgICAgICAgZWxzZSBnbG9iYWxpemUgYWNjIFtAbm9udGFpbF0pXG4gICAgICBpblxuICAgICAgYE9rIG1hcCkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIGxpc3QgfmdldF9rZXkgfmNvbXBhcmF0b3IgPVxuICAgIG1hdGNoIG9mX2xpc3Rfd2l0aF9rZXkgbGlzdCB+Z2V0X2tleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHggLT4gUmVzdWx0Lk9rIHhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgT3JfZXJyb3IuZXJyb3JcbiAgICAgICAgXCJNYXAub2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvcjogZHVwbGljYXRlIGtleVwiXG4gICAgICAgIGtleVxuICAgICAgICBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2V4biBsaXN0IH5nZXRfa2V5IH5jb21wYXJhdG9yID1cbiAgICBtYXRjaCBvZl9saXN0X3dpdGhfa2V5IGxpc3QgfmdldF9rZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayB4IC0+IHhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgRXJyb3IuY3JlYXRlIFwiTWFwLm9mX2xpc3Rfd2l0aF9rZXlfZXhuOiBkdXBsaWNhdGUga2V5XCIga2V5IGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgICB8PiBFcnJvci5yYWlzZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X211bHRpIGxpc3QgfmdldF9rZXkgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgbGlzdCA9IExpc3QucmV2IGxpc3QgaW5cbiAgICBMaXN0LmZvbGQgbGlzdCB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApIH5mOihmdW4geyB0cmVlID0gdDsgbGVuZ3RoIH0gZGF0YSAtPlxuICAgICAgbGV0IGtleSA9IGdldF9rZXkgZGF0YSBpblxuICAgICAgKHVwZGF0ZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuIG9wdGlvbiAtPlxuICAgICAgICAgbGV0IGxpc3QgPSBPcHRpb24udmFsdWUgb3B0aW9uIH5kZWZhdWx0OltdIGluXG4gICAgICAgICBkYXRhIDo6IGxpc3QpXG4gICAgICAgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZm9sZCBsaXN0IH5nZXRfa2V5IH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgTGlzdC5mb2xkIGxpc3QgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKSB+ZjooZnVuIHsgdHJlZSA9IHQ7IGxlbmd0aCB9IGRhdGEgLT5cbiAgICAgIGxldCBrZXkgPSBnZXRfa2V5IGRhdGEgaW5cbiAgICAgICh1cGRhdGUgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICB8IE5vbmUgLT4gZiBpbml0IGRhdGFcbiAgICAgICAgIHwgU29tZSBwcmV2IC0+IGYgcHJldiBkYXRhKVxuICAgICAgIHw+IGdsb2JhbGl6ZSkgW0Bub250YWlsXSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSBsaXN0IH5nZXRfa2V5IH5mIH5jb21wYXJlX2tleSA9XG4gICAgTGlzdC5mb2xkIGxpc3QgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKSB+ZjooZnVuIHsgdHJlZSA9IHQ7IGxlbmd0aCB9IGRhdGEgLT5cbiAgICAgIGxldCBrZXkgPSBnZXRfa2V5IGRhdGEgaW5cbiAgICAgICh1cGRhdGUgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICB8IE5vbmUgLT4gZGF0YVxuICAgICAgICAgfCBTb21lIHByZXYgLT4gZiBwcmV2IGRhdGEpXG4gICAgICAgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGwgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyIHQgfmY6KGZ1biBkYXRhIC0+IGlmIG5vdCAoZiBkYXRhKSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICAgIHRydWUpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBub3QgKGYgfmtleSB+ZGF0YSkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgICB0cnVlKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGV4aXN0cyB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXIgdCB+ZjooZnVuIGRhdGEgLT4gaWYgZiBkYXRhIHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgICBmYWxzZSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBleGlzdHNpIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgICBmYWxzZSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBjb3VudCB0IH5mID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBhY2MgLT4gaWYgZiBkYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYykgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBjb3VudGkgdCB+ZiA9XG4gICAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICA7O1xuXG4gIGxldCBzdW0gKHR5cGUgYSkgKG1vZHVsZSBNIDogQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gYSkgdCB+ZiA9XG4gICAgZm9sZCB0IH5pbml0Ok0uemVybyB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBhY2MgLT4gTS4oICsgKSAoZiBkYXRhKSBhY2MpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgc3VtaSAodHlwZSBhKSAobW9kdWxlIE0gOiBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSBhKSB0IH5mID1cbiAgICBmb2xkIHQgfmluaXQ6TS56ZXJvIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gTS4oICsgKSAoZiB+a2V5IH5kYXRhKSBhY2MpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgdG9fYWxpc3QgPyhrZXlfb3JkZXIgPSBgSW5jcmVhc2luZykgdCA9XG4gICAgbWF0Y2gga2V5X29yZGVyIHdpdGhcbiAgICB8IGBJbmNyZWFzaW5nIC0+IGZvbGRfcmlnaHQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgeCAtPiAoa2V5LCBkYXRhKSA6OiB4KVxuICAgIHwgYERlY3JlYXNpbmcgLT4gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSB4IC0+IChrZXksIGRhdGEpIDo6IHgpXG4gIDs7XG5cbiAgbGV0IG1lcmdlIHQxIHQyIH5mIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGVsdHMgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuOihsZW5ndGggdDEgKyBsZW5ndGggdDIpIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGl0ZXIyIHQxIHQyIH5jb21wYXJlX2tleSB+ZjooZnVuIH5rZXkgfmRhdGE6dmFsdWVzIC0+XG4gICAgICBtYXRjaCBmIH5rZXkgdmFsdWVzIHdpdGhcbiAgICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgICBVbmlmb3JtX2FycmF5LnNldCBlbHRzICFpIChrZXksIHZhbHVlKTtcbiAgICAgICAgaW5jciBpXG4gICAgICB8IE5vbmUgLT4gKCkpO1xuICAgIGxldCBsZW4gPSAhaSBpblxuICAgIGxldCBnZXQgaSA9IFVuaWZvcm1fYXJyYXkuZ2V0IGVsdHMgaSBpblxuICAgIGxldCB0cmVlID0gb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZjpnZXQgaW5cbiAgICB3aXRoX2xlbmd0aCB0cmVlIGxlblxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgPVxuICAgIGxldCBtZXJnZV9sYXJnZV9maXJzdCBsZW5ndGhfbGFyZ2UgdF9sYXJnZSB0X3NtYWxsIH5jYWxsIH5jb21iaW5lIH5jb21wYXJlX2tleSA9XG4gICAgICBmb2xkXG4gICAgICAgIHRfc21hbGxcbiAgICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCB0X2xhcmdlIGxlbmd0aF9sYXJnZSlcbiAgICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhOmRhdGEnIHsgdHJlZSA9IHQ7IGxlbmd0aCB9IC0+XG4gICAgICAgICh1cGRhdGUgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgIHwgTm9uZSAtPiBkYXRhJ1xuICAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBjYWxsIGNvbWJpbmUgfmtleSBkYXRhIGRhdGEnKVxuICAgICAgICAgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKSBbQG5vbnRhaWxdXG4gICAgaW5cbiAgICBsZXQgY2FsbCBmIH5rZXkgeCB5ID0gZiB+a2V5IHggeSBpblxuICAgIGxldCBzd2FwIGYgfmtleSB4IHkgPSBmIH5rZXkgeSB4IGluXG4gICAgZnVuIHQxIHQyIH5sZW5ndGgxIH5sZW5ndGgyIH5jb21iaW5lIH5jb21wYXJlX2tleSAtPlxuICAgICAgaWYgbGVuZ3RoMiA8PSBsZW5ndGgxXG4gICAgICB0aGVuIG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aDEgdDEgdDIgfmNhbGwgfmNvbWJpbmUgfmNvbXBhcmVfa2V5XG4gICAgICBlbHNlIG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aDIgdDIgdDEgfmNhbGw6c3dhcCB+Y29tYmluZSB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgbWVyZ2VfZGlzam9pbnRfZXhuIHQxIHQyIH5sZW5ndGgxIH5sZW5ndGgyIH4oY29tcGFyYXRvciA6IF8gQ29tcGFyYXRvci50KSA9XG4gICAgbWVyZ2Vfc2tld2VkXG4gICAgICB0MVxuICAgICAgdDJcbiAgICAgIH5sZW5ndGgxXG4gICAgICB+bGVuZ3RoMlxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgfmNvbWJpbmU6KGZ1biB+a2V5IF8gXyAtPlxuICAgICAgRXJyb3IuY3JlYXRlIFwiTWFwLm1lcmdlX2Rpc2pvaW50X2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgICAgfD4gRXJyb3IucmFpc2UpXG4gIDs7XG5cbiAgbW9kdWxlIENsb3Nlc3Rfa2V5X2ltcGwgPSBzdHJ1Y3RcbiAgICAoKiBbbWFya2VyXSBhbmQgW3JlcGFja2FnZV0gYWxsb3cgdXMgdG8gY3JlYXRlIFwibG9naWNhbFwiIG9wdGlvbnMgd2l0aG91dCBhY3R1YWxseVxuICAgICAgIGFsbG9jYXRpbmcgYW55IG9wdGlvbnMuIFBhc3NpbmcgW0ZvdW5kIGtleSB2YWx1ZV0gdG8gYSBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgcGFzc2luZyBbU29tZSAoa2V5LCB2YWx1ZSldOyBwYXNzaW5nIFtNaXNzaW5nICgpICgpXSBpcyBlcXVpdmFsZW50IHRvIHBhc3NpbmdcbiAgICAgICBbTm9uZV0uICopXG4gICAgdHlwZSAoJ2ssICd2LCAna19vcHQsICd2X29wdCkgbWFya2VyID1cbiAgICAgIHwgTWlzc2luZyA6ICgnaywgJ3YsIHVuaXQsIHVuaXQpIG1hcmtlclxuICAgICAgfCBGb3VuZCA6ICgnaywgJ3YsICdrLCAndikgbWFya2VyXG5cbiAgICBsZXQgcmVwYWNrYWdlXG4gICAgICAodHlwZSBrIHYga19vcHQgdl9vcHQpXG4gICAgICAobWFya2VyIDogKGssIHYsIGtfb3B0LCB2X29wdCkgbWFya2VyKVxuICAgICAgKGsgOiBrX29wdClcbiAgICAgICh2IDogdl9vcHQpXG4gICAgICA6IChrICogdikgb3B0aW9uXG4gICAgICA9XG4gICAgICBtYXRjaCBtYXJrZXIgd2l0aFxuICAgICAgfCBNaXNzaW5nIC0+IE5vbmVcbiAgICAgIHwgRm91bmQgLT4gU29tZSAoaywgdilcbiAgICA7O1xuXG4gICAgKCogVGhlIHR5cGUgc2lnbmF0dXJlIGlzIGV4cGxpY2l0IGhlcmUgdG8gYWxsb3cgcG9seW1vcnBoaWMgcmVjdXJzaW9uLiAqKVxuICAgIGxldCByZWMgbG9vcCA6XG4gICAgICAgICAgICAgICdrICd2ICdrX29wdCAndl9vcHQuXG4gICAgICAgICAgICAgICgnaywgJ3YpIHRyZWVcbiAgICAgICAgICAgICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgICAgICAgICAgICAtPiAna1xuICAgICAgICAgICAgICAtPiBjb21wYXJlX2tleTooJ2sgLT4gJ2sgLT4gaW50KVxuICAgICAgICAgICAgICAtPiAoJ2ssICd2LCAna19vcHQsICd2X29wdCkgbWFya2VyXG4gICAgICAgICAgICAgIC0+ICdrX29wdFxuICAgICAgICAgICAgICAtPiAndl9vcHRcbiAgICAgICAgICAgICAgLT4gKCdrICogJ3YpIG9wdGlvblxuICAgICAgPVxuICAgICAgZnVuIHQgZGlyIGsgfmNvbXBhcmVfa2V5IGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWUgLT5cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZVxuICAgICAgfCBMZWFmIHsga2V5ID0gayc7IGRhdGEgPSB2JyB9IC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgaycgayBpblxuICAgICAgICBpZiBtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgICB8IGBHcmVhdGVyX29yX2VxdWFsX3RvIC0+IGMgPj0gMFxuICAgICAgICAgICB8IGBHcmVhdGVyX3RoYW4gLT4gYyA+IDBcbiAgICAgICAgICAgfCBgTGVzc19vcl9lcXVhbF90byAtPiBjIDw9IDBcbiAgICAgICAgICAgfCBgTGVzc190aGFuIC0+IGMgPCAwXG4gICAgICAgIHRoZW4gU29tZSAoaycsIHYnKVxuICAgICAgICBlbHNlIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gayc7IGRhdGEgPSB2JzsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgICgqIFRoaXMgaXMgYSBiYXNlIGNhc2UgKG5vIHJlY3Vyc2l2ZSBjYWxsKS4gKilcbiAgICAgICAgICBtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgTGVzc19vcl9lcXVhbF90byAtPiBTb21lIChrJywgdicpXG4gICAgICAgICAgfCBgR3JlYXRlcl90aGFuIC0+XG4gICAgICAgICAgICBpZiBpc19lbXB0eSByIHRoZW4gcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWUgZWxzZSBtaW5fZWx0IHJcbiAgICAgICAgICB8IGBMZXNzX3RoYW4gLT5cbiAgICAgICAgICAgIGlmIGlzX2VtcHR5IGwgdGhlbiByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSBlbHNlIG1heF9lbHQgbClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogV2UgYXJlIGd1YXJhbnRlZWQgaGVyZSB0aGF0IGsnIDw+IGsuICopXG4gICAgICAgICAgKCogVGhpcyBpcyB0aGUgb25seSByZWN1cnNpdmUgY2FzZS4gKilcbiAgICAgICAgICBtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIC0+XG4gICAgICAgICAgICBpZiBjID4gMFxuICAgICAgICAgICAgdGhlbiBsb29wIGwgZGlyIGsgfmNvbXBhcmVfa2V5IEZvdW5kIGsnIHYnXG4gICAgICAgICAgICBlbHNlIGxvb3AgciBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZVxuICAgICAgICAgIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIC0+XG4gICAgICAgICAgICBpZiBjIDwgMFxuICAgICAgICAgICAgdGhlbiBsb29wIHIgZGlyIGsgfmNvbXBhcmVfa2V5IEZvdW5kIGsnIHYnXG4gICAgICAgICAgICBlbHNlIGxvb3AgbCBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSlcbiAgICA7O1xuXG4gICAgbGV0IGNsb3Nlc3Rfa2V5IHQgZGlyIGsgfmNvbXBhcmVfa2V5ID0gbG9vcCB0IGRpciBrIH5jb21wYXJlX2tleSBNaXNzaW5nICgpICgpXG4gIGVuZFxuXG4gIGxldCBjbG9zZXN0X2tleSA9IENsb3Nlc3Rfa2V5X2ltcGwuY2xvc2VzdF9rZXlcblxuICBsZXQgcmVjIHJhbmsgdCBrIH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsga2V5ID0gayc7IGRhdGEgPSBfIH0gLT4gaWYgY29tcGFyZV9rZXkgaycgayA9IDAgdGhlbiBTb21lIDAgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IGsnOyBkYXRhID0gXzsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgaycgayBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gU29tZSAobGVuZ3RoIGwpXG4gICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICB0aGVuIHJhbmsgbCBrIH5jb21wYXJlX2tleVxuICAgICAgZWxzZSBPcHRpb24ubWFwIChyYW5rIHIgayB+Y29tcGFyZV9rZXkpIH5mOihmdW4gcmFuayAtPiByYW5rICsgMSArIGxlbmd0aCBsKVxuICA7O1xuXG4gICgqIHRoaXMgY291bGQgYmUgaW1wbGVtZW50ZWQgdXNpbmcgW1NlcXVlbmNlXSBpbnRlcmZhY2UgYnV0IHRoZSBmb2xsb3dpbmcgaW1wbGVtZW50YXRpb25cbiAgICAgYWxsb2NhdGVzIG9ubHkgMiB3b3JkcyBhbmQgZG9lc24ndCByZXF1aXJlIHdyaXRlLWJhcnJpZXIgKilcbiAgbGV0IHJlYyBudGgnIG51bV90b19zZWFyY2ggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSB2IH0gLT5cbiAgICAgIGlmICFudW1fdG9fc2VhcmNoID0gMFxuICAgICAgdGhlbiBTb21lIChrLCB2KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGRlY3IgbnVtX3RvX3NlYXJjaDtcbiAgICAgICAgTm9uZSlcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gazsgZGF0YSA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAobWF0Y2ggbnRoJyBudW1fdG9fc2VhcmNoIGwgd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gc29tZVxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgaWYgIW51bV90b19zZWFyY2ggPSAwXG4gICAgICAgICB0aGVuIFNvbWUgKGssIHYpXG4gICAgICAgICBlbHNlIChcbiAgICAgICAgICAgZGVjciBudW1fdG9fc2VhcmNoO1xuICAgICAgICAgICBudGgnIG51bV90b19zZWFyY2ggcikpXG4gIDs7XG5cbiAgbGV0IG50aCB0IG4gPSBudGgnIChyZWYgbikgdFxuXG4gIGxldCByZWMgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSB2IH0gLT4gaWYgZiB+a2V5OmsgfmRhdGE6diB0aGVuIFNvbWUgKGssIHYpIGVsc2UgTm9uZVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrOyBkYXRhID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGlmIGYgfmtleTprIH5kYXRhOnZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgbCB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIChrLCB2KVxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyByIH5mXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBrZXkgPSBrOyBkYXRhID0gdiB9IC0+IGlmIGYgfmtleTprIH5kYXRhOnYgdGhlbiBTb21lIChrLCB2KSBlbHNlIE5vbmVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gazsgZGF0YSA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBpZiBmIH5rZXk6ayB+ZGF0YTp2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgciB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIChrLCB2KVxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIGwgfmZcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuIC0+XG4gICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA8IDApIFtAbm9udGFpbF1cbiAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPD0gMCkgW0Bub250YWlsXVxuICAgIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2ID49IDApIHdpdGhcbiAgICAgICB8IFNvbWUgKGtleSwgZGF0YSkgYXMgcGFpciB3aGVuIGNvbXBhcmUgfmtleSB+ZGF0YSB2ID0gMCAtPiBwYWlyXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2IDw9IDApIHdpdGhcbiAgICAgICB8IFNvbWUgKGtleSwgZGF0YSkgYXMgcGFpciB3aGVuIGNvbXBhcmUgfmtleSB+ZGF0YSB2ID0gMCAtPiBwYWlyXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPj0gMCkgW0Bub250YWlsXVxuICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2ID4gMCkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgbGV0IGlzX2xlZnQgfmtleSB+ZGF0YSA9XG4gICAgICBtYXRjaCBzZWdtZW50X29mIH5rZXkgfmRhdGEgd2l0aFxuICAgICAgfCBgTGVmdCAtPiB0cnVlXG4gICAgICB8IGBSaWdodCAtPiBmYWxzZVxuICAgIGluXG4gICAgbGV0IGlzX3JpZ2h0IH5rZXkgfmRhdGEgPSBub3QgKGlzX2xlZnQgfmtleSB+ZGF0YSkgaW5cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfb25fbGVmdCAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOmlzX2xlZnQgW0Bub250YWlsXVxuICAgIHwgYEZpcnN0X29uX3JpZ2h0IC0+IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOmlzX3JpZ2h0IFtAbm9udGFpbF1cbiAgOztcblxuICAoKiBbYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmRdIGZpbmRzIHRoZSBrZXkgaW4gW3RdIHdoaWNoIHNhdGlzZmllcyBbbWF5YmVfYm91bmRdXG4gICAgIGFuZCB0aGUgcmVsZXZhbnQgb25lIG9mIFtpZl9leGNsdXNpdmVdIG9yIFtpZl9pbmNsdXNpdmVdLCBhcyBqdWRnZWQgYnkgW2NvbXBhcmVdLiAqKVxuICBsZXQgYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmQgdCBtYXliZV9ib3VuZCB+Y29tcGFyZSB+aWZfZXhjbHVzaXZlIH5pZl9pbmNsdXNpdmUgPVxuICAgIGxldCBmaW5kX2JvdW5kIHQgaG93IGJvdW5kIH5jb21wYXJlIDogXyBNYXliZV9ib3VuZC50IG9wdGlvbiA9XG4gICAgICBtYXRjaCBiaW5hcnlfc2VhcmNoIHQgaG93IGJvdW5kIH5jb21wYXJlIHdpdGhcbiAgICAgIHwgU29tZSAoYm91bmQsIF8pIC0+IFNvbWUgKEluY2wgYm91bmQpXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgIGluXG4gICAgbWF0Y2ggKG1heWJlX2JvdW5kIDogXyBNYXliZV9ib3VuZC50KSB3aXRoXG4gICAgfCBFeGNsIGJvdW5kIC0+IGZpbmRfYm91bmQgdCBpZl9leGNsdXNpdmUgYm91bmQgfmNvbXBhcmVcbiAgICB8IEluY2wgYm91bmQgLT4gZmluZF9ib3VuZCB0IGlmX2luY2x1c2l2ZSBib3VuZCB+Y29tcGFyZVxuICAgIHwgVW5ib3VuZGVkIC0+IFNvbWUgVW5ib3VuZGVkXG4gIDs7XG5cbiAgKCogW2JpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kc10gZmluZHMgdGhlIChub3QgbmVjZXNzYXJpbHkgZGlzdGluY3QpIGtleXMgaW4gW3RdXG4gICAgIHdoaWNoIG1vc3QgY2xvc2VseSBhcHByb2FjaCAoYnV0IGRvIG5vdCBjcm9zcykgW2xvd2VyX2JvdW5kXSBhbmQgW3VwcGVyX2JvdW5kXSwgYXNcbiAgICAganVkZ2VkIGJ5IFtjb21wYXJlXS4gSXQgcmV0dXJucyBbTm9uZV0gaWYgbm8ga2V5cyBpbiBbdF0gYXJlIHdpdGhpbiB0aGF0IHJhbmdlLiAqKVxuICBsZXQgYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzIHQgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbGV0IGZpbmRfbG93ZXJfYm91bmQgdCBtYXliZV9ib3VuZCB+Y29tcGFyZSA9XG4gICAgICBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZFxuICAgICAgICB0XG4gICAgICAgIG1heWJlX2JvdW5kXG4gICAgICAgIH5jb21wYXJlXG4gICAgICAgIH5pZl9leGNsdXNpdmU6YEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhblxuICAgICAgICB+aWZfaW5jbHVzaXZlOmBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG9cbiAgICBpblxuICAgIGxldCBmaW5kX3VwcGVyX2JvdW5kIHQgbWF5YmVfYm91bmQgfmNvbXBhcmUgPVxuICAgICAgYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmRcbiAgICAgICAgdFxuICAgICAgICBtYXliZV9ib3VuZFxuICAgICAgICB+Y29tcGFyZVxuICAgICAgICB+aWZfZXhjbHVzaXZlOmBMYXN0X3N0cmljdGx5X2xlc3NfdGhhblxuICAgICAgICB+aWZfaW5jbHVzaXZlOmBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90b1xuICAgIGluXG4gICAgbWF0Y2ggZmluZF9sb3dlcl9ib3VuZCB0IGxvd2VyX2JvdW5kIH5jb21wYXJlIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBsb3dlcl9ib3VuZCAtPlxuICAgICAgKG1hdGNoIGZpbmRfdXBwZXJfYm91bmQgdCB1cHBlcl9ib3VuZCB+Y29tcGFyZSB3aXRoXG4gICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICB8IFNvbWUgdXBwZXJfYm91bmQgLT4gU29tZSAobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSlcbiAgOztcblxuICB0eXBlICgnaywgJ3YpIGFjYyA9XG4gICAgeyBtdXRhYmxlIGJhZF9rZXkgOiAnayBvcHRpb25cbiAgICA7IG11dGFibGUgbWFwX2xlbmd0aCA6ICgnaywgJ3YpIHQgV2l0aF9sZW5ndGgudFxuICAgIH1cblxuICBsZXQgb2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFjYyA9IHsgYmFkX2tleSA9IE5vbmU7IG1hcF9sZW5ndGggPSB3aXRoX2xlbmd0aF9nbG9iYWwgZW1wdHkgMCB9IGluXG4gICAgaXRlcmkgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICBsZXQgeyB0cmVlID0gbWFwOyBsZW5ndGggfSA9IGFjYy5tYXBfbGVuZ3RoIGluXG4gICAgICBsZXQgKHsgdHJlZSA9IF87IGxlbmd0aCA9IGxlbmd0aCcgfSBhcyBwYWlyKSA9XG4gICAgICAgIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgbWFwIH5jb21wYXJlX2tleVxuICAgICAgaW5cbiAgICAgIGlmIGxlbmd0aCA9IGxlbmd0aCcgJiYgT3B0aW9uLmlzX25vbmUgYWNjLmJhZF9rZXlcbiAgICAgIHRoZW4gYWNjLmJhZF9rZXkgPC0gU29tZSBrZXlcbiAgICAgIGVsc2UgYWNjLm1hcF9sZW5ndGggPC0gZ2xvYmFsaXplIHBhaXIpO1xuICAgIG1hdGNoIGFjYy5iYWRfa2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gYE9rIGFjYy5tYXBfbGVuZ3RoXG4gICAgfCBTb21lIGtleSAtPiBgRHVwbGljYXRlX2tleSBrZXlcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5pdGVyaSB+KGNvbXBhcmF0b3IgOiBfIENvbXBhcmF0b3IudCkgPVxuICAgIG1hdGNoIG9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayB2IC0+IHZcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgRXJyb3IuY3JlYXRlIFwiTWFwLm9mX2l0ZXJpX2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgICAgfD4gRXJyb3IucmFpc2VcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCBrZXlfb2Zfc2V4cCB2YWx1ZV9vZl9zZXhwIHNleHAgfihjb21wYXJhdG9yIDogXyBDb21wYXJhdG9yLnQpID1cbiAgICBsZXQgYWxpc3QgPSBsaXN0X29mX3NleHAgKHBhaXJfb2Zfc2V4cCBrZXlfb2Zfc2V4cCB2YWx1ZV9vZl9zZXhwKSBzZXhwIGluXG4gICAgbGV0IGNvbXBhcmVfa2V5ID0gY29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgbWF0Y2ggb2ZfYWxpc3QgYWxpc3QgfmNvbXBhcmVfa2V5IHdpdGhcbiAgICB8IGBPayB2IC0+IHZcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGsgLT5cbiAgICAgICgqIGZpbmQgdGhlIHNleHAgb2YgYSBkdXBsaWNhdGUga2V5LCBzbyB0aGUgZXJyb3IgaXMgbmFycm93ZWQgdG8gYSBrZXkgYW5kIG5vdFxuICAgICAgICAgdGhlIHdob2xlIG1hcCAqKVxuICAgICAgbGV0IGFsaXN0X3NleHBzID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAgRm4uaWQgRm4uaWQpIHNleHAgaW5cbiAgICAgIGxldCBmb3VuZF9maXJzdF9rID0gcmVmIGZhbHNlIGluXG4gICAgICBMaXN0Lml0ZXIyX29rIGFsaXN0IGFsaXN0X3NleHBzIH5mOihmdW4gKGsyLCBfKSAoazJfc2V4cCwgXykgLT5cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgayBrMiA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIGlmICFmb3VuZF9maXJzdF9rXG4gICAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiTWFwLnRfb2Zfc2V4cF9kaXJlY3Q6IGR1cGxpY2F0ZSBrZXlcIiBrMl9zZXhwXG4gICAgICAgICAgZWxzZSBmb3VuZF9maXJzdF9rIDo9IHRydWUpO1xuICAgICAgYXNzZXJ0IGZhbHNlXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX3ZhbHVlIHQgPVxuICAgIGxldCBmIH5rZXkgfmRhdGEgYWNjID0gU2V4cC5MaXN0IFsgc2V4cF9vZl9rZXkga2V5OyBzZXhwX29mX3ZhbHVlIGRhdGEgXSA6OiBhY2MgaW5cbiAgICBTZXhwLkxpc3QgKGZvbGRfcmlnaHQgfmYgdCB+aW5pdDpbXSlcbiAgOztcblxuICBsZXQgY29tYmluZV9lcnJvcnMgdCB+c2V4cF9vZl9rZXkgPVxuICAgIGxldCBva3MsIGVycm9ycyA9IHBhcnRpdGlvbl9tYXAgdCB+ZjpSZXN1bHQudG9fZWl0aGVyIGluXG4gICAgaWYgaXNfZW1wdHkgZXJyb3JzXG4gICAgdGhlbiBPayBva3NcbiAgICBlbHNlIE9yX2Vycm9yLmVycm9yX3MgKHNleHBfb2ZfdCBzZXhwX29mX2tleSBFcnJvci5zZXhwX29mX3QgZXJyb3JzKVxuICA7O1xuXG4gIGxldCB1bnppcCB0ID0gbWFwIHQgfmY6ZnN0LCBtYXAgdCB+ZjpzbmRcblxuICBsZXQgbWFwX2tleXNcbiAgICB0MVxuICAgIH5mXG4gICAgfmNvbXBhcmF0b3I6KHsgY29tcGFyZSA9IGNvbXBhcmVfa2V5OyBzZXhwX29mX3QgPSBzZXhwX29mX2tleSB9IDogXyBDb21wYXJhdG9yLnQpXG4gICAgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgICAgYE9rXG4gICAgICAgIChmb2xkXG4gICAgICAgICAgIHQxXG4gICAgICAgICAgIH5pbml0Oih3aXRoX2xlbmd0aF9nbG9iYWwgZW1wdHkgMClcbiAgICAgICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhIHsgdHJlZSA9IHQyOyBsZW5ndGggfSAtPlxuICAgICAgICAgICBsZXQga2V5ID0gZiBrZXkgaW5cbiAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgYWRkX2V4bl9pbnRlcm5hbCB0MiB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSB8PiBnbG9iYWxpemVcbiAgICAgICAgICAgd2l0aFxuICAgICAgICAgICB8IER1cGxpY2F0ZSAtPiByZXR1cm4gKGBEdXBsaWNhdGVfa2V5IGtleSkpKSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gdCB+ZiB+Y29tcGFyYXRvciA9XG4gICAgbWF0Y2ggbWFwX2tleXMgdCB+ZiB+Y29tcGFyYXRvciB3aXRoXG4gICAgfCBgT2sgcmVzdWx0IC0+IHJlc3VsdFxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBsZXQgc2V4cF9vZl9rZXkgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90IGluXG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJNYXAubWFwX2tleXNfZXhuOiBkdXBsaWNhdGUga2V5XCIgWyBcImtleVwiLCBrZXkgfD4gc2V4cF9vZl9rZXkgXSlcbiAgOztcblxuICBsZXQgdHJhbnNwb3NlX2tleXMgfm91dGVyX2NvbXBhcmF0b3IgfmlubmVyX2NvbXBhcmF0b3Igb3V0ZXJfdCA9XG4gICAgZm9sZFxuICAgICAgb3V0ZXJfdFxuICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKVxuICAgICAgfmY6KGZ1biB+a2V5Om91dGVyX2tleSB+ZGF0YTppbm5lcl90IGFjYyAtPlxuICAgICAgZm9sZFxuICAgICAgICBpbm5lcl90XG4gICAgICAgIH5pbml0OmFjY1xuICAgICAgICB+ZjooZnVuIH5rZXk6aW5uZXJfa2V5IH5kYXRhIHsgdHJlZSA9IGFjYzsgbGVuZ3RoID0gYWNjX2xlbiB9IC0+XG4gICAgICAgICh1cGRhdGVcbiAgICAgICAgICAgYWNjXG4gICAgICAgICAgIGlubmVyX2tleVxuICAgICAgICAgICB+bGVuZ3RoOmFjY19sZW5cbiAgICAgICAgICAgfmNvbXBhcmVfa2V5OmlubmVyX2NvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgICAgIH5mOihmdW5jdGlvblxuICAgICAgICAgICB8IE5vbmUgLT4gd2l0aF9sZW5ndGhfZ2xvYmFsIChzaW5nbGV0b24gb3V0ZXJfa2V5IGRhdGEpIDFcbiAgICAgICAgICAgfCBTb21lIHsgdHJlZSA9IGVsdDsgbGVuZ3RoID0gZWx0X2xlbiB9IC0+XG4gICAgICAgICAgICAgKHNldFxuICAgICAgICAgICAgICAgIGVsdFxuICAgICAgICAgICAgICAgIH5rZXk6b3V0ZXJfa2V5XG4gICAgICAgICAgICAgICAgfmRhdGFcbiAgICAgICAgICAgICAgICB+bGVuZ3RoOmVsdF9sZW5cbiAgICAgICAgICAgICAgICB+Y29tcGFyZV9rZXk6b3V0ZXJfY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgICAgICAgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKVxuICAgICAgICAgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKSlcbiAgOztcblxuICBtb2R1bGUgTWFrZV9hcHBsaWNhdGl2ZV90cmF2ZXJzYWxzIChBIDogQXBwbGljYXRpdmUuTGF6eV9hcHBsaWNhdGl2ZSkgPSBzdHJ1Y3RcbiAgICBsZXQgcmVjIG1hcGkgdCB+ZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQS5yZXR1cm4gRW1wdHlcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgICAgQS5tYXAgKGYgfmtleTp2IH5kYXRhOmQpIH5mOihmdW4gbmV3X2RhdGEgLT4gTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBuZXdfZGF0YSB9KVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSAtPlxuICAgICAgICBsZXQgbCcgPSBBLm9mX3RodW5rIChmdW4gKCkgLT4gbWFwaSB+ZiBsKSBpblxuICAgICAgICBsZXQgZCcgPSBmIH5rZXk6diB+ZGF0YTpkIGluXG4gICAgICAgIGxldCByJyA9IEEub2ZfdGh1bmsgKGZ1biAoKSAtPiBtYXBpIH5mIHIpIGluXG4gICAgICAgIEEubWFwMyBsJyBkJyByJyB+ZjooZnVuIGwnIGQnIHInIC0+XG4gICAgICAgICAgTm9kZSB7IGxlZnQgPSBsJzsga2V5ID0gdjsgZGF0YSA9IGQnOyByaWdodCA9IHInOyBoZWlnaHQgPSBoIH0pXG4gICAgOztcblxuICAgICgqIEluIHRoZW9yeSB0aGUgY29tcHV0YXRpb24gb2YgbGVuZ3RoIG9uLXRoZS1mbHkgaXMgbm90IG5lY2Vzc2FyeSBoZXJlIGJlY2F1c2UgaXQgY2FuXG4gICAgICAgYmUgZG9uZSBieSB3cmFwcGluZyB0aGUgYXBwbGljYXRpdmUgW0FdIHdpdGggbGVuZ3RoLWNvbXB1dGluZyBsb2dpYy4gSG93ZXZlcixcbiAgICAgICBpbnRyb2R1Y2luZyBhbiBhcHBsaWNhdGl2ZSB0cmFuc2Zvcm1lciBsaWtlIHRoYXQgbWFrZXMgdGhlIG1hcCBiZW5jaG1hcmtzIGluXG4gICAgICAgYXN5bmNfa2VybmVsL2JlbmNoL3NyYy9iZW5jaF9kZWZlcnJlZF9tYXAubWwgbm90aWNlYWJseSBzbG93ZXIuICopXG4gICAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICAgICAgbGV0IHJlYyB0cmVlX2ZpbHRlcl9tYXBpIHQgfmYgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBBLnJldHVybiAod2l0aF9sZW5ndGhfZ2xvYmFsIEVtcHR5IDApXG4gICAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgICAgICBBLm1hcCAoZiB+a2V5OnYgfmRhdGE6ZCkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgICB8IFNvbWUgbmV3X2RhdGEgLT4gd2l0aF9sZW5ndGhfZ2xvYmFsIChMZWFmIHsga2V5ID0gdjsgZGF0YSA9IG5ld19kYXRhIH0pIDFcbiAgICAgICAgICAgIHwgTm9uZSAtPiB3aXRoX2xlbmd0aF9nbG9iYWwgRW1wdHkgMClcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICAgIEEubWFwM1xuICAgICAgICAgICAgKEEub2ZfdGh1bmsgKGZ1biAoKSAtPiB0cmVlX2ZpbHRlcl9tYXBpIGwgfmYpKVxuICAgICAgICAgICAgKGYgfmtleTp2IH5kYXRhOmQpXG4gICAgICAgICAgICAoQS5vZl90aHVuayAoZnVuICgpIC0+IHRyZWVfZmlsdGVyX21hcGkgciB+ZikpXG4gICAgICAgICAgICB+ZjpcbiAgICAgICAgICAgICAgKGZ1blxuICAgICAgICAgICAgICAgIHsgdHJlZSA9IGwnOyBsZW5ndGggPSBsX2xlbiB9IG5ld19kYXRhIHsgdHJlZSA9IHInOyBsZW5ndGggPSByX2xlbiB9IC0+XG4gICAgICAgICAgICAgIG1hdGNoIG5ld19kYXRhIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIG5ld19kYXRhIC0+XG4gICAgICAgICAgICAgICAgd2l0aF9sZW5ndGhfZ2xvYmFsIChqb2luIGwnIHYgbmV3X2RhdGEgcicpIChsX2xlbiArIHJfbGVuICsgMSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgd2l0aF9sZW5ndGhfZ2xvYmFsIChjb25jYXRfYW5kX2JhbGFuY2VfdW5jaGVja2VkIGwnIHInKSAobF9sZW4gKyByX2xlbikpXG4gICAgICBpblxuICAgICAgdHJlZV9maWx0ZXJfbWFwaSB0IH5mXG4gICAgOztcbiAgZW5kXG5lbmRcblxudHlwZSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdCA9XG4gIHsgKCogW2NvbXBhcmF0b3JdIGlzIHRoZSBmaXJzdCBmaWVsZCBzbyB0aGF0IHBvbHltb3JwaGljIGVxdWFsaXR5IGZhaWxzIG9uIGEgbWFwIGR1ZVxuICAgICAgIHRvIHRoZSBmdW5jdGlvbmFsIHZhbHVlIGluIHRoZSBjb21wYXJhdG9yLlxuICAgICAgIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFmZmVjdCBwb2x5bW9ycGhpYyBbY29tcGFyZV06IHRoYXQgc3RpbGwgcHJvZHVjZXNcbiAgICAgICBub25zZW5zZS4gKilcbiAgICBjb21wYXJhdG9yIDogKCdrLCAnY29tcGFyYXRvcikgQ29tcGFyYXRvci50XG4gIDsgdHJlZSA6ICgnaywgJ3YpIFRyZWUwLnRcbiAgOyBsZW5ndGggOiBpbnRcbiAgfVxuXG50eXBlICgnaywgJ3YsICdjb21wYXJhdG9yKSB0cmVlID0gKCdrLCAndikgVHJlZTAudFxuXG5sZXQgY29tcGFyZV9rZXkgdCA9IHQuY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxubGV0IGxpa2UgeyB0cmVlID0gXzsgbGVuZ3RoID0gXzsgY29tcGFyYXRvciB9ICh7IHRyZWU7IGxlbmd0aCB9IDogXyBXaXRoX2xlbmd0aC50KSA9XG4gIHsgdHJlZTsgbGVuZ3RoOyBjb21wYXJhdG9yIH1cbjs7XG5cbmxldCBsaWtlX21heWJlX25vX29wXG4gICh7IHRyZWUgPSBvbGRfdHJlZTsgbGVuZ3RoID0gXzsgY29tcGFyYXRvciB9IGFzIG9sZF90KVxuICAoeyB0cmVlOyBsZW5ndGggfSA6IF8gV2l0aF9sZW5ndGgudClcbiAgPVxuICBpZiBwaHlzX2VxdWFsIG9sZF90cmVlIHRyZWUgdGhlbiBvbGRfdCBlbHNlIHsgdHJlZTsgbGVuZ3RoOyBjb21wYXJhdG9yIH1cbjs7XG5cbmxldCB3aXRoX3NhbWVfbGVuZ3RoIHsgdHJlZSA9IF87IGNvbXBhcmF0b3I7IGxlbmd0aCB9IHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCB9XG5sZXQgb2ZfbGlrZV90cmVlIHQgdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvciA9IHQuY29tcGFyYXRvcjsgbGVuZ3RoID0gVHJlZTAubGVuZ3RoIHRyZWUgfVxuXG5sZXQgb2ZfbGlrZV90cmVlX21heWJlX25vX29wIHQgdHJlZSA9XG4gIGlmIHBoeXNfZXF1YWwgdC50cmVlIHRyZWVcbiAgdGhlbiB0XG4gIGVsc2UgeyB0cmVlOyBjb21wYXJhdG9yID0gdC5jb21wYXJhdG9yOyBsZW5ndGggPSBUcmVlMC5sZW5ndGggdHJlZSB9XG47O1xuXG5sZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggPSBUcmVlMC5sZW5ndGggdHJlZSB9XG5cbigqIEV4cG9zaW5nIHRoaXMgZnVuY3Rpb24gd291bGQgbWFrZSBpdCB2ZXJ5IGVhc3kgZm9yIHRoZSBpbnZhcmlhbnRzXG4gICBvZiB0aGlzIG1vZHVsZSB0byBiZSBicm9rZW4uICopXG5sZXQgb2ZfdHJlZV91bnNhZmUgfmNvbXBhcmF0b3Igfmxlbmd0aCB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggfVxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBjb21wYXJhdG9yIHQgPSB0LmNvbXBhcmF0b3JcbiAgbGV0IHRvX3RyZWUgdCA9IHQudHJlZVxuXG4gIGxldCBpbnZhcmlhbnRzIHQgPVxuICAgIFRyZWUwLmludmFyaWFudHMgdC50cmVlIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkgJiYgVHJlZTAubGVuZ3RoIHQudHJlZSA9IHQubGVuZ3RoXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0LnRyZWVcbiAgbGV0IGxlbmd0aCB0ID0gdC5sZW5ndGhcblxuICBsZXQgc2V0IHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLnNldCB0LnRyZWUgfmxlbmd0aDp0Lmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gICAgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBhZGRfZXhuIHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLmFkZF9leG5cbiAgICAgICAgIHQudHJlZVxuICAgICAgICAgfmxlbmd0aDp0Lmxlbmd0aFxuICAgICAgICAgfmtleVxuICAgICAgICAgfmRhdGFcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90KSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGFkZF9leG5faW50ZXJuYWwgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX2V4bl9pbnRlcm5hbFxuICAgICAgICAgdC50cmVlXG4gICAgICAgICB+bGVuZ3RoOnQubGVuZ3RoXG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3QpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgYWRkIHQgfmtleSB+ZGF0YSA9XG4gICAgbWF0Y2ggYWRkX2V4bl9pbnRlcm5hbCB0IH5rZXkgfmRhdGEgd2l0aFxuICAgIHwgcmVzdWx0IC0+IGBPayByZXN1bHRcbiAgICB8IGV4Y2VwdGlvbiBEdXBsaWNhdGUgLT4gYER1cGxpY2F0ZVxuICA7O1xuXG4gIGxldCBhZGRfbXVsdGkgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX211bHRpIHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgICBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9tdWx0aSB0IGtleSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLnJlbW92ZV9tdWx0aSB0LnRyZWUgfmxlbmd0aDp0Lmxlbmd0aCBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgICBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbmRfbXVsdGkgdCBrZXkgPSBUcmVlMC5maW5kX211bHRpIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuXG4gIGxldCBjaGFuZ2UgdCBrZXkgfmYgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5jaGFuZ2UgdC50cmVlIGtleSB+ZiB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gICAgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCB1cGRhdGUgdCBrZXkgfmYgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC51cGRhdGUgdC50cmVlIGtleSB+ZiB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gICAgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9leG5cbiAgICAgIHQudHJlZVxuICAgICAga2V5XG4gICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBmaW5kIHQga2V5ID0gVHJlZTAuZmluZCB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcblxuICBsZXQgcmVtb3ZlIHQga2V5ID1cbiAgICBsaWtlX21heWJlX25vX29wXG4gICAgICB0XG4gICAgICAoVHJlZTAucmVtb3ZlIHQudHJlZSBrZXkgfmxlbmd0aDp0Lmxlbmd0aCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG1lbSB0IGtleSA9IFRyZWUwLm1lbSB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgbGV0IGl0ZXJfa2V5cyB0IH5mID0gVHJlZTAuaXRlcl9rZXlzIHQudHJlZSB+ZlxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0LnRyZWUgfmZcbiAgbGV0IGl0ZXJpIHQgfmYgPSBUcmVlMC5pdGVyaSB0LnRyZWUgfmZcbiAgbGV0IGl0ZXJpX3VudGlsIHQgfmYgPSBUcmVlMC5pdGVyaV91bnRpbCB0LnRyZWUgfmZcbiAgbGV0IGl0ZXIyIHQxIHQyIH5mID0gVHJlZTAuaXRlcjIgdDEudHJlZSB0Mi50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gIGxldCBtYXAgdCB+ZiA9IHdpdGhfc2FtZV9sZW5ndGggdCAoVHJlZTAubWFwIHQudHJlZSB+ZilcbiAgbGV0IG1hcGkgdCB+ZiA9IHdpdGhfc2FtZV9sZW5ndGggdCAoVHJlZTAubWFwaSB0LnRyZWUgfmYpXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQudHJlZSB+ZiB+aW5pdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQudHJlZSB+aW5pdCB+ZiB+ZmluaXNoXG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQudHJlZSB+ZiB+aW5pdFxuXG4gIGxldCBmb2xkMiB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZDIgdDEudHJlZSB0Mi50cmVlIH5pbml0IH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9rZXlzIHQgfmYgPVxuICAgIGxldCBsZW4gPSByZWYgdC5sZW5ndGggaW5cbiAgICBsZXQgdHJlZSA9IFRyZWUwLmZpbHRlcl9rZXlzIHQudHJlZSB+ZiB+bGVuIGluXG4gICAgbGlrZV9tYXliZV9ub19vcCB0ICh3aXRoX2xlbmd0aCB0cmVlICFsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlsdGVyIHQgfmYgPVxuICAgIGxldCBsZW4gPSByZWYgdC5sZW5ndGggaW5cbiAgICBsZXQgdHJlZSA9IFRyZWUwLmZpbHRlciB0LnRyZWUgfmYgfmxlbiBpblxuICAgIGxpa2VfbWF5YmVfbm9fb3AgdCAod2l0aF9sZW5ndGggdHJlZSAhbGVuKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbHRlcmkgdCB+ZiA9XG4gICAgbGV0IGxlbiA9IHJlZiB0Lmxlbmd0aCBpblxuICAgIGxldCB0cmVlID0gVHJlZTAuZmlsdGVyaSB0LnRyZWUgfmYgfmxlbiBpblxuICAgIGxpa2VfbWF5YmVfbm9fb3AgdCAod2l0aF9sZW5ndGggdHJlZSAhbGVuKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gICAgbGV0IGxlbiA9IHJlZiB0Lmxlbmd0aCBpblxuICAgIGxldCB0cmVlID0gVHJlZTAuZmlsdGVyX21hcCB0LnRyZWUgfmYgfmxlbiBpblxuICAgIGxpa2UgdCAod2l0aF9sZW5ndGggdHJlZSAhbGVuKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICAgIGxldCBsZW4gPSByZWYgdC5sZW5ndGggaW5cbiAgICBsZXQgdHJlZSA9IFRyZWUwLmZpbHRlcl9tYXBpIHQudHJlZSB+ZiB+bGVuIGluXG4gICAgbGlrZSB0ICh3aXRoX2xlbmd0aCB0cmVlICFsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgb2ZfbGlrZV90cmVlMiB0ICh0MSwgdDIpID0gb2ZfbGlrZV90cmVlIHQgdDEsIG9mX2xpa2VfdHJlZSB0IHQyXG5cbiAgbGV0IG9mX2xpa2VfdHJlZTJfbWF5YmVfbm9fb3AgdCAodDEsIHQyKSA9XG4gICAgb2ZfbGlrZV90cmVlX21heWJlX25vX29wIHQgdDEsIG9mX2xpa2VfdHJlZV9tYXliZV9ub19vcCB0IHQyXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPSBvZl9saWtlX3RyZWUyIHQgKFRyZWUwLnBhcnRpdGlvbl9tYXBpIHQudHJlZSB+ZilcbiAgbGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9IG9mX2xpa2VfdHJlZTIgdCAoVHJlZTAucGFydGl0aW9uX21hcCB0LnRyZWUgfmYpXG4gIGxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPSBvZl9saWtlX3RyZWUyX21heWJlX25vX29wIHQgKFRyZWUwLnBhcnRpdGlvbmlfdGYgdC50cmVlIH5mKVxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBvZl9saWtlX3RyZWUyX21heWJlX25vX29wIHQgKFRyZWUwLnBhcnRpdGlvbl90ZiB0LnRyZWUgfmYpXG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIHQgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6KG9mX2xpa2VfdHJlZSB0KVxuICAgICAgKFRyZWUwLmNvbWJpbmVfZXJyb3JzIHQudHJlZSB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgdW56aXAgdCA9IG9mX2xpa2VfdHJlZTIgdCAoVHJlZTAudW56aXAgdC50cmVlKVxuXG4gIGxldCBjb21wYXJlX2RpcmVjdCBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmNvbXBhcmUgKGNvbXBhcmVfa2V5IHQxKSBjb21wYXJlX2RhdGEgdDEudHJlZSB0Mi50cmVlXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGNvbXBhcmVfZGF0YSB0MSB0MiA9IFRyZWUwLmVxdWFsIChjb21wYXJlX2tleSB0MSkgY29tcGFyZV9kYXRhIHQxLnRyZWUgdDIudHJlZVxuICBsZXQga2V5cyB0ID0gVHJlZTAua2V5cyB0LnRyZWVcbiAgbGV0IGRhdGEgdCA9IFRyZWUwLmRhdGEgdC50cmVlXG4gIGxldCB0b19hbGlzdCA/a2V5X29yZGVyIHQgPSBUcmVlMC50b19hbGlzdCA/a2V5X29yZGVyIHQudHJlZVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbCA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpIH5kYXRhX2VxdWFsXG4gIDs7XG5cbiAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgIHQxLnRyZWVcbiAgICAgIHQyLnRyZWVcbiAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gICAgICB+ZGF0YV9lcXVhbFxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gIDs7XG5cbiAgbGV0IG1lcmdlIHQxIHQyIH5mID1cbiAgICBsaWtlIHQxIChUcmVlMC5tZXJnZSB0MS50cmVlIHQyLnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgbWVyZ2VfZGlzam9pbnRfZXhuIHQxIHQyID1cbiAgICBsaWtlXG4gICAgICB0MVxuICAgICAgKFRyZWUwLm1lcmdlX2Rpc2pvaW50X2V4blxuICAgICAgICAgdDEudHJlZVxuICAgICAgICAgdDIudHJlZVxuICAgICAgICAgfmxlbmd0aDE6dDEubGVuZ3RoXG4gICAgICAgICB+bGVuZ3RoMjp0Mi5sZW5ndGhcbiAgICAgICAgIH5jb21wYXJhdG9yOnQxLmNvbXBhcmF0b3IpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgbWVyZ2Vfc2tld2VkIHQxIHQyIH5jb21iaW5lID1cbiAgICAoKiBUaGlzIGlzIG9ubHkgYSBuby1vcCBpbiB0aGUgY2FzZSB3aGVyZSBhdCBsZWFzdCBvbmUgb2YgdGhlIG1hcHMgaXMgZW1wdHkuICopXG4gICAgbGlrZV9tYXliZV9ub19vcFxuICAgICAgKGlmIHQyLmxlbmd0aCA8PSB0MS5sZW5ndGggdGhlbiB0MSBlbHNlIHQyKVxuICAgICAgKFRyZWUwLm1lcmdlX3NrZXdlZFxuICAgICAgICAgdDEudHJlZVxuICAgICAgICAgdDIudHJlZVxuICAgICAgICAgfmxlbmd0aDE6dDEubGVuZ3RoXG4gICAgICAgICB+bGVuZ3RoMjp0Mi5sZW5ndGhcbiAgICAgICAgIH5jb21iaW5lXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKSlcbiAgOztcblxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0LnRyZWVcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0LnRyZWVcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdC50cmVlXG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdC50cmVlXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQudHJlZSB+ZlxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9IFRyZWUwLmZvcl9hbGxpIHQudHJlZSB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdC50cmVlIH5mXG4gIGxldCBleGlzdHNpIHQgfmYgPSBUcmVlMC5leGlzdHNpIHQudHJlZSB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQudHJlZSB+ZlxuICBsZXQgY291bnRpIHQgfmYgPSBUcmVlMC5jb3VudGkgdC50cmVlIH5mXG4gIGxldCBzdW0gbSB0IH5mID0gVHJlZTAuc3VtIG0gdC50cmVlIH5mXG4gIGxldCBzdW1pIG0gdCB+ZiA9IFRyZWUwLnN1bWkgbSB0LnRyZWUgfmZcblxuICBsZXQgc3BsaXQgdCBrID1cbiAgICBsZXQgbCwgbWF5YmUsIHIgPSBUcmVlMC5zcGxpdCB0LnRyZWUgayB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpIGluXG4gICAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yIHQgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgbGV0IGJvdGhfbGVuID0gaWYgT3B0aW9uLmlzX3NvbWUgbWF5YmUgdGhlbiB0Lmxlbmd0aCAtIDEgZWxzZSB0Lmxlbmd0aCBpblxuICAgIGlmIFRyZWUwLmhlaWdodCBsIDwgVHJlZTAuaGVpZ2h0IHJcbiAgICB0aGVuIChcbiAgICAgIGxldCBsID0gb2ZfdHJlZSBsIH5jb21wYXJhdG9yIGluXG4gICAgICBsLCBtYXliZSwgb2ZfdHJlZV91bnNhZmUgciB+Y29tcGFyYXRvciB+bGVuZ3RoOihib3RoX2xlbiAtIGxlbmd0aCBsKSlcbiAgICBlbHNlIChcbiAgICAgIGxldCByID0gb2ZfdHJlZSByIH5jb21wYXJhdG9yIGluXG4gICAgICBvZl90cmVlX3Vuc2FmZSBsIH5jb21wYXJhdG9yIH5sZW5ndGg6KGJvdGhfbGVuIC0gbGVuZ3RoIHIpLCBtYXliZSwgcilcbiAgOztcblxuICBsZXQgc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG8gayA9XG4gICAgbGV0IGwsIHIgPVxuICAgICAgVHJlZTAuc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQudHJlZSB+aW50byBrIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICBpblxuICAgIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvciB0IGluXG4gICAgKCogVHJ5IHRvIHRyYXZlcnNlIHRoZSBsZWFzdCBhbW91bnQgcG9zc2libGUgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGgsXG4gICAgICAgdXNpbmcgaGVpZ2h0IGFzIGEgaGV1cmlzdGljLiAqKVxuICAgIGlmIFRyZWUwLmhlaWdodCBsIDwgVHJlZTAuaGVpZ2h0IHJcbiAgICB0aGVuIChcbiAgICAgIGxldCBsID0gb2ZfdHJlZSBsIH5jb21wYXJhdG9yIGluXG4gICAgICBsLCBvZl90cmVlX3Vuc2FmZSByIH5jb21wYXJhdG9yIH5sZW5ndGg6KHQubGVuZ3RoIC0gbGVuZ3RoIGwpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHIgPSBvZl90cmVlIHIgfmNvbXBhcmF0b3IgaW5cbiAgICAgIG9mX3RyZWVfdW5zYWZlIGwgfmNvbXBhcmF0b3Igfmxlbmd0aDoodC5sZW5ndGggLSBsZW5ndGggciksIHIpXG4gIDs7XG5cbiAgbGV0IHNwbGl0X2xlX2d0IHQgayA9IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB0IH5pbnRvOmBMZWZ0IGtcbiAgbGV0IHNwbGl0X2x0X2dlIHQgayA9IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB0IH5pbnRvOmBSaWdodCBrXG5cbiAgbGV0IHN1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbGV0IGxlZnQsIG1pZCwgcmlnaHQgPVxuICAgICAgVHJlZTAuc3BsaXRfcmFuZ2UgdC50cmVlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgIGluXG4gICAgKCogVHJ5IHRvIHRyYXZlcnNlIHRoZSBsZWFzdCBhbW91bnQgcG9zc2libGUgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGgsXG4gICAgICAgdXNpbmcgaGVpZ2h0IGFzIGEgaGV1cmlzdGljLiAqKVxuICAgIGxldCBvdXRlcl9qb2luZWRfaGVpZ2h0ID1cbiAgICAgIGxldCBoX2wgPSBUcmVlMC5oZWlnaHQgbGVmdFxuICAgICAgYW5kIGhfciA9IFRyZWUwLmhlaWdodCByaWdodCBpblxuICAgICAgaWYgaF9sID0gaF9yIHRoZW4gaF9sICsgMSBlbHNlIG1heCBoX2wgaF9yXG4gICAgaW5cbiAgICBpZiBvdXRlcl9qb2luZWRfaGVpZ2h0IDwgVHJlZTAuaGVpZ2h0IG1pZFxuICAgIHRoZW4gKFxuICAgICAgbGV0IG1pZF9sZW5ndGggPSB0Lmxlbmd0aCAtIChUcmVlMC5sZW5ndGggbGVmdCArIFRyZWUwLmxlbmd0aCByaWdodCkgaW5cbiAgICAgIG9mX3RyZWVfdW5zYWZlIG1pZCB+Y29tcGFyYXRvcjooY29tcGFyYXRvciB0KSB+bGVuZ3RoOm1pZF9sZW5ndGgpXG4gICAgZWxzZSBvZl90cmVlIG1pZCB+Y29tcGFyYXRvcjooY29tcGFyYXRvciB0KVxuICA7O1xuXG4gIGxldCBhcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5hcHBlbmRcbiAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSBsb3dlcl9wYXJ0KVxuICAgICAgICB+bG93ZXJfcGFydDpsb3dlcl9wYXJ0LnRyZWVcbiAgICAgICAgfnVwcGVyX3BhcnQ6dXBwZXJfcGFydC50cmVlXG4gICAgd2l0aFxuICAgIHwgYE9rIHRyZWUgLT5cbiAgICAgIGBPa1xuICAgICAgICAob2ZfdHJlZV91bnNhZmVcbiAgICAgICAgICAgdHJlZVxuICAgICAgICAgICB+Y29tcGFyYXRvcjooY29tcGFyYXRvciBsb3dlcl9wYXJ0KVxuICAgICAgICAgICB+bGVuZ3RoOihsb3dlcl9wYXJ0Lmxlbmd0aCArIHVwcGVyX3BhcnQubGVuZ3RoKSlcbiAgICB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIC0+IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzXG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQgfm1pbiB+bWF4IH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3JhbmdlX2luY2x1c2l2ZSB0LnRyZWUgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgOztcblxuICBsZXQgcmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXggPVxuICAgIFRyZWUwLnJhbmdlX3RvX2FsaXN0IHQudHJlZSB+bWluIH5tYXggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCBjbG9zZXN0X2tleSB0IGRpciBrZXkgPVxuICAgIFRyZWUwLmNsb3Nlc3Rfa2V5IHQudHJlZSBkaXIga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IFRyZWUwLm50aCB0LnRyZWUgblxuICBsZXQgbnRoX2V4biB0IG4gPSBPcHRpb24udmFsdWVfZXhuIChudGggdCBuKVxuICBsZXQgcmFuayB0IGtleSA9IFRyZWUwLnJhbmsgdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9rIHNleHBfb2ZfdiBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9rIHNleHBfb2ZfdiB0LnRyZWVcblxuICBsZXQgdG9fc2VxdWVuY2UgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZVxuICAgICAgdC5jb21wYXJhdG9yXG4gICAgICA/b3JkZXJcbiAgICAgID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgIHQudHJlZVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQudHJlZSB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdC50cmVlIH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXkgaGFzaF9mb2xkX2RhdGEgc3RhdGUgdCA9XG4gICAgVHJlZTAuaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9rZXkgaGFzaF9mb2xkX2RhdGEgc3RhdGUgdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc3VicmFuZ2UgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBtYXRjaFxuICAgICAgVHJlZTAuYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzIHQudHJlZSB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXG4gICAgd2l0aFxuICAgIHwgU29tZSAobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSAtPiBzdWJyYW5nZSB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB8IE5vbmUgLT4gbGlrZV9tYXliZV9ub19vcCB0ICh3aXRoX2xlbmd0aCBUcmVlMC5FbXB0eSAwKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbW9kdWxlIE1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyAoQSA6IEFwcGxpY2F0aXZlLkxhenlfYXBwbGljYXRpdmUpID0gc3RydWN0XG4gICAgbW9kdWxlIFRyZWVfdHJhdmVyc2FscyA9IFRyZWUwLk1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyAoQSlcblxuICAgIGxldCBtYXBpIHQgfmYgPVxuICAgICAgQS5tYXAgKFRyZWVfdHJhdmVyc2Fscy5tYXBpIHQudHJlZSB+ZikgfmY6KGZ1biBuZXdfdHJlZSAtPlxuICAgICAgICB3aXRoX3NhbWVfbGVuZ3RoIHQgbmV3X3RyZWUpXG4gICAgOztcblxuICAgIGxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgICAgIEEubWFwIChUcmVlX3RyYXZlcnNhbHMuZmlsdGVyX21hcGkgdC50cmVlIH5mKSB+ZjooZnVuIG5ld190cmVlX3dpdGhfbGVuZ3RoIC0+XG4gICAgICAgIGxpa2UgdCBuZXdfdHJlZV93aXRoX2xlbmd0aClcbiAgICA7O1xuICBlbmRcbmVuZFxuXG4oKiBbMF0gaXMgdXNlZCBhcyB0aGUgW2xlbmd0aF0gYXJndW1lbnQgZXZlcnl3aGVyZSBpbiB0aGlzIG1vZHVsZSwgc2luY2UgdHJlZXMgZG8gbm90XG4gICBoYXZlIHRoZWlyIGxlbmd0aHMgc3RvcmVkIGF0IHRoZSByb290LCB1bmxpa2UgbWFwcy4gVGhlIHZhbHVlcyBhcmUgZGlzY2FyZGVkIGFsd2F5cy4gKilcbm1vZHVsZSBUcmVlID0gc3RydWN0XG4gIHR5cGUgKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHQgPSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdHJlZVxuXG4gIGxldCBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uID0gVHJlZTAuZW1wdHlcbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yOl8gPSBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uXG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yOl8gdHJlZSA9IHRyZWVcbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvcjpfIGsgdiA9IFRyZWUwLnNpbmdsZXRvbiBrIHZcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgKFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgICAgLnRyZWVcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfD4gT3JfZXJyb3IubWFwIH5mOihmdW4gKHggOiAoJ2ssICd2KSBUcmVlMC50IFdpdGhfbGVuZ3RoLnQpIC0+IHgudHJlZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3QgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2FsaXN0IGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGQgLT4gZFxuICAgIHwgYE9rIHsgdHJlZTsgbGVuZ3RoID0gXyB9IC0+IGBPayB0cmVlXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBUcmVlMC5vZl9hbGlzdF9vcl9lcnJvciBhbGlzdCB+Y29tcGFyYXRvclxuICAgIHw+IE9yX2Vycm9yLm1hcCB+ZjooZnVuICh4IDogKCdrLCAndikgVHJlZTAudCBXaXRoX2xlbmd0aC50KSAtPiB4LnRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhbGlzdCA9IChUcmVlMC5vZl9hbGlzdF9leG4gYWxpc3QgfmNvbXBhcmF0b3IpLnRyZWVcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIChUcmVlMC5vZl9hbGlzdF9tdWx0aSBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvciBhbGlzdCB+aW5pdCB+ZiA9XG4gICAgKFRyZWUwLm9mX2FsaXN0X2ZvbGQgYWxpc3QgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKS50cmVlXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhbGlzdCB+ZiA9XG4gICAgKFRyZWUwLm9mX2FsaXN0X3JlZHVjZSBhbGlzdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgb2ZfaXRlcmkgfmNvbXBhcmF0b3Igfml0ZXJpID1cbiAgICBtYXRjaCBUcmVlMC5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayB7IHRyZWU7IGxlbmd0aCA9IF8gfSAtPiBgT2sgdHJlZVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5jb21wYXJhdG9yIH5pdGVyaSA9IChUcmVlMC5vZl9pdGVyaV9leG4gfml0ZXJpIH5jb21wYXJhdG9yKS50cmVlXG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yOl9yZXF1aXJlZF9ieV9pbnRmIH5sZW4gfmYgPVxuICAgIFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmZcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICAgICAgKFRyZWUwLm9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBtYXRjaCBUcmVlMC5vZl9zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gICAgfCBgT2sgeyB0cmVlOyBsZW5ndGggPSBfIH0gLT4gYE9rIHRyZWVcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBUcmVlMC5vZl9zZXF1ZW5jZV9vcl9lcnJvciBzZXEgfmNvbXBhcmF0b3JcbiAgICB8PiBPcl9lcnJvci5tYXAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3Igc2VxID0gKFRyZWUwLm9mX3NlcXVlbmNlX2V4biBzZXEgfmNvbXBhcmF0b3IpLnRyZWVcblxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3Igc2VxID1cbiAgICAoVHJlZTAub2Zfc2VxdWVuY2VfbXVsdGkgc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHNlcSB+aW5pdCB+ZiA9XG4gICAgKFRyZWUwLm9mX3NlcXVlbmNlX2ZvbGQgc2VxIH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3Igc2VxIH5mID1cbiAgICAoVHJlZTAub2Zfc2VxdWVuY2VfcmVkdWNlIHNlcSB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleSB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICBtYXRjaFxuICAgICAgVHJlZTAub2ZfbGlzdF93aXRoX2tleSBsaXN0IH5nZXRfa2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIHdpdGhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gICAgfCBgT2sgeyB0cmVlOyBsZW5ndGggPSBfIH0gLT4gYE9rIHRyZWVcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICBUcmVlMC5vZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIGxpc3QgfmdldF9rZXkgfmNvbXBhcmF0b3JcbiAgICB8PiBPcl9lcnJvci5tYXAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2V4biB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICAoVHJlZTAub2ZfbGlzdF93aXRoX2tleV9leG4gbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvcikudHJlZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X211bHRpIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIChUcmVlMC5vZl9saXN0X3dpdGhfa2V5X211bHRpXG4gICAgICAgbGlzdFxuICAgICAgIH5nZXRfa2V5XG4gICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgICAgLnRyZWVcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9mb2xkIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgfmluaXQgfmYgPVxuICAgIChUcmVlMC5vZl9saXN0X3dpdGhfa2V5X2ZvbGRcbiAgICAgICBsaXN0XG4gICAgICAgfmdldF9rZXlcbiAgICAgICB+aW5pdFxuICAgICAgIH5mXG4gICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgICAgLnRyZWVcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9yZWR1Y2UgfmNvbXBhcmF0b3IgbGlzdCB+Z2V0X2tleSB+ZiA9XG4gICAgKFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlXG4gICAgICAgbGlzdFxuICAgICAgIH5nZXRfa2V5XG4gICAgICAgfmZcbiAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCB0b190cmVlIHQgPSB0XG5cbiAgbGV0IGludmFyaWFudHMgfmNvbXBhcmF0b3IgdCA9XG4gICAgVHJlZTAuaW52YXJpYW50cyB0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdFxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdFxuXG4gIGxldCBzZXQgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICAoVHJlZTAuc2V0IHQgfmtleSB+ZGF0YSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKS50cmVlXG4gIDs7XG5cbiAgbGV0IGFkZF9leG4gfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICAoVHJlZTAuYWRkX2V4blxuICAgICAgIHRcbiAgICAgICB+a2V5XG4gICAgICAgfmRhdGFcbiAgICAgICB+bGVuZ3RoOjBcbiAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5zZXhwX29mX3QpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBhZGRfZXhuX2ludGVybmFsIH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgKFRyZWUwLmFkZF9leG5faW50ZXJuYWxcbiAgICAgICB0XG4gICAgICAgfmtleVxuICAgICAgIH5kYXRhXG4gICAgICAgfmxlbmd0aDowXG4gICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICAgICAgLnRyZWVcbiAgOztcblxuICBsZXQgYWRkIH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgdHJ5IGBPayAoYWRkX2V4bl9pbnRlcm5hbCB0IH5jb21wYXJhdG9yIH5rZXkgfmRhdGEpIHdpdGhcbiAgICB8IF8gLT4gYER1cGxpY2F0ZVxuICA7O1xuXG4gIGxldCBhZGRfbXVsdGkgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICAoVHJlZTAuYWRkX211bHRpIHQgfmtleSB+ZGF0YSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgICAgLnRyZWVcbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICAoVHJlZTAucmVtb3ZlX211bHRpIHQga2V5IH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgZmluZF9tdWx0aSB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9tdWx0aSB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgY2hhbmdlIH5jb21wYXJhdG9yIHQga2V5IH5mID1cbiAgICAoVHJlZTAuY2hhbmdlIHQga2V5IH5mIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgdXBkYXRlIH5jb21wYXJhdG9yIHQga2V5IH5mID1cbiAgICBjaGFuZ2UgfmNvbXBhcmF0b3IgdCBrZXkgfmY6KGZ1biBkYXRhIC0+IFNvbWUgKGYgZGF0YSkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmluZF9leG4gfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIFRyZWUwLmZpbmRfZXhuXG4gICAgICB0XG4gICAgICBrZXlcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgZmluZCB+Y29tcGFyYXRvciB0IGtleSA9IFRyZWUwLmZpbmQgdCBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbiAgbGV0IHJlbW92ZSB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgKFRyZWUwLnJlbW92ZSB0IGtleSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKS50cmVlXG4gIDs7XG5cbiAgbGV0IG1lbSB+Y29tcGFyYXRvciB0IGtleSA9IFRyZWUwLm1lbSB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgbGV0IGl0ZXJfa2V5cyB0IH5mID0gVHJlZTAuaXRlcl9rZXlzIHQgfmZcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdCB+ZlxuICBsZXQgaXRlcmkgdCB+ZiA9IFRyZWUwLml0ZXJpIHQgfmZcbiAgbGV0IGl0ZXJpX3VudGlsIHQgfmYgPSBUcmVlMC5pdGVyaV91bnRpbCB0IH5mXG5cbiAgbGV0IGl0ZXIyIH5jb21wYXJhdG9yIHQxIHQyIH5mID1cbiAgICBUcmVlMC5pdGVyMiB0MSB0MiB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgbWFwIHQgfmYgPSBUcmVlMC5tYXAgdCB+ZlxuICBsZXQgbWFwaSB0IH5mID0gVHJlZTAubWFwaSB0IH5mXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQgfmYgfmluaXRcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gVHJlZTAuZm9sZF91bnRpbCB0IH5mIH5pbml0IH5maW5pc2hcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdCB+ZiB+aW5pdFxuXG4gIGxldCBmb2xkMiB+Y29tcGFyYXRvciB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZDIgdDEgdDIgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9rZXlzIHQgfmYgPSBUcmVlMC5maWx0ZXJfa2V5cyB0IH5mIH5sZW46KHJlZiAwKSBbQG5vbnRhaWxdXG4gIGxldCBmaWx0ZXIgdCB+ZiA9IFRyZWUwLmZpbHRlciB0IH5mIH5sZW46KHJlZiAwKSBbQG5vbnRhaWxdXG4gIGxldCBmaWx0ZXJpIHQgfmYgPSBUcmVlMC5maWx0ZXJpIHQgfmYgfmxlbjoocmVmIDApIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiA9IFRyZWUwLmZpbHRlcl9tYXAgdCB+ZiB+bGVuOihyZWYgMCkgW0Bub250YWlsXVxuICBsZXQgZmlsdGVyX21hcGkgdCB+ZiA9IFRyZWUwLmZpbHRlcl9tYXBpIHQgfmYgfmxlbjoocmVmIDApIFtAbm9udGFpbF1cbiAgbGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPSBUcmVlMC5wYXJ0aXRpb25fbWFwaSB0IH5mXG4gIGxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPSBUcmVlMC5wYXJ0aXRpb25fbWFwIHQgfmZcbiAgbGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbmlfdGYgdCB+ZlxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBUcmVlMC5wYXJ0aXRpb25fdGYgdCB+ZlxuXG4gIGxldCBjb21iaW5lX2Vycm9ycyB+Y29tcGFyYXRvciB0ID1cbiAgICBUcmVlMC5jb21iaW5lX2Vycm9ycyB0IH5zZXhwX29mX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IHVuemlwID0gVHJlZTAudW56aXBcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgfmNvbXBhcmF0b3IgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBUcmVlMC5jb21wYXJlIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGNvbXBhcmVfZGF0YSB0MSB0MlxuICA7O1xuXG4gIGxldCBlcXVhbCB+Y29tcGFyYXRvciBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmVxdWFsIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGNvbXBhcmVfZGF0YSB0MSB0MlxuICA7O1xuXG4gIGxldCBrZXlzIHQgPSBUcmVlMC5rZXlzIHRcbiAgbGV0IGRhdGEgdCA9IFRyZWUwLmRhdGEgdFxuICBsZXQgdG9fYWxpc3QgP2tleV9vcmRlciB0ID0gVHJlZTAudG9fYWxpc3QgP2tleV9vcmRlciB0XG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyIH5kYXRhX2VxdWFsID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfmRhdGFfZXF1YWxcbiAgOztcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB+Y29tcGFyYXRvciB0MSB0MiB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgdDFcbiAgICAgIHQyXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgOztcblxuICBsZXQgbWVyZ2UgfmNvbXBhcmF0b3IgdDEgdDIgfmYgPVxuICAgIChUcmVlMC5tZXJnZSB0MSB0MiB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgbWVyZ2VfZGlzam9pbnRfZXhuIH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICAoVHJlZTAubWVyZ2VfZGlzam9pbnRfZXhuIHQxIHQyIH5sZW5ndGgxOihsZW5ndGggdDEpIH5sZW5ndGgyOihsZW5ndGggdDIpIH5jb21wYXJhdG9yKVxuICAgICAgLnRyZWVcbiAgOztcblxuICBsZXQgbWVyZ2Vfc2tld2VkIH5jb21wYXJhdG9yIHQxIHQyIH5jb21iaW5lID1cbiAgICAoKiBMZW5ndGggY29tcHV0YXRpb24gbWFrZXMgdGhpcyBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIFttZXJnZV9za2V3ZWRdIG9uIGEgbWFwXG4gICAgICAgd2l0aCBhIFtsZW5ndGhdIGZpZWxkLCBidXQgZG9lcyBwcmVzZXJ2ZSBhbW91bnQgb2YgYWxsb2NhdGlvbi4gKilcbiAgICAoVHJlZTAubWVyZ2Vfc2tld2VkXG4gICAgICAgdDFcbiAgICAgICB0MlxuICAgICAgIH5sZW5ndGgxOihsZW5ndGggdDEpXG4gICAgICAgfmxlbmd0aDI6KGxlbmd0aCB0MilcbiAgICAgICB+Y29tYmluZVxuICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgICAgIC50cmVlXG4gIDs7XG5cbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdFxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHRcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdFxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHRcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdCB+ZlxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9IFRyZWUwLmZvcl9hbGxpIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IFRyZWUwLmV4aXN0c2kgdCB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQgfmZcbiAgbGV0IGNvdW50aSB0IH5mID0gVHJlZTAuY291bnRpIHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0IH5mXG4gIGxldCBzdW1pIG0gdCB+ZiA9IFRyZWUwLnN1bWkgbSB0IH5mXG4gIGxldCBzcGxpdCB+Y29tcGFyYXRvciB0IGsgPSBUcmVlMC5zcGxpdCB0IGsgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbiAgbGV0IHNwbGl0X2xlX2d0IH5jb21wYXJhdG9yIHQgayA9XG4gICAgVHJlZTAuc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5XG4gICAgICB0XG4gICAgICB+aW50bzpgTGVmdFxuICAgICAga1xuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IHNwbGl0X2x0X2dlIH5jb21wYXJhdG9yIHQgayA9XG4gICAgVHJlZTAuc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5XG4gICAgICB0XG4gICAgICB+aW50bzpgUmlnaHRcbiAgICAgIGtcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBhcHBlbmQgfmNvbXBhcmF0b3Igfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgPVxuICAgIFRyZWUwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgXywgcmV0LCBfID1cbiAgICAgIFRyZWUwLnNwbGl0X3JhbmdlXG4gICAgICAgIHRcbiAgICAgICAgfmxvd2VyX2JvdW5kXG4gICAgICAgIH51cHBlcl9ib3VuZFxuICAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIHJldFxuICA7O1xuXG4gIGxldCBmb2xkX3JhbmdlX2luY2x1c2l2ZSB+Y29tcGFyYXRvciB0IH5taW4gfm1heCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICAgIHRcbiAgICAgIH5taW5cbiAgICAgIH5tYXhcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IHJhbmdlX3RvX2FsaXN0IH5jb21wYXJhdG9yIHQgfm1pbiB+bWF4ID1cbiAgICBUcmVlMC5yYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgY2xvc2VzdF9rZXkgfmNvbXBhcmF0b3IgdCBkaXIga2V5ID1cbiAgICBUcmVlMC5jbG9zZXN0X2tleSB0IGRpciBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IG50aCB0IG4gPSBUcmVlMC5udGggdCBuXG4gIGxldCBudGhfZXhuIHQgbiA9IE9wdGlvbi52YWx1ZV9leG4gKG50aCB0IG4pXG4gIGxldCByYW5rIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAucmFuayB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IHRcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgPVxuICAgIChUcmVlMC50X29mX3NleHBfZGlyZWN0IGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCB+Y29tcGFyYXRvcikudHJlZVxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlIGNvbXBhcmF0b3IgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggfmNvbXBhcmF0b3I6XyB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIH5jb21wYXJhdG9yOl8gdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBtYXRjaCBUcmVlMC5iaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIHdpdGhcbiAgICB8IFNvbWUgKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkgLT4gc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXG4gICAgfCBOb25lIC0+IEVtcHR5XG4gIDs7XG5cbiAgbW9kdWxlIE1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyAoQSA6IEFwcGxpY2F0aXZlLkxhenlfYXBwbGljYXRpdmUpID0gc3RydWN0XG4gICAgbW9kdWxlIFRyZWUwX3RyYXZlcnNhbHMgPSBUcmVlMC5NYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMgKEEpXG5cbiAgICBsZXQgbWFwaSB0IH5mID0gVHJlZTBfdHJhdmVyc2Fscy5tYXBpIHQgfmZcblxuICAgIGxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgICAgIEEubWFwXG4gICAgICAgIChUcmVlMF90cmF2ZXJzYWxzLmZpbHRlcl9tYXBpIHQgfmYpXG4gICAgICAgIH5mOihmdW4gKHggOiAoJ2ssICd2KSBUcmVlMC50IFdpdGhfbGVuZ3RoLnQpIC0+IHgudHJlZSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgbWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbWF0Y2ggVHJlZTAubWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiB3aXRoXG4gICAgfCBgT2sgeyB0cmVlID0gdDsgbGVuZ3RoID0gXyB9IC0+IGBPayB0XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGR1cCAtPiBkdXBcbiAgOztcblxuICBsZXQgbWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmYgPSAoVHJlZTAubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmYpLnRyZWVcblxuICAoKiBUaGlzIGNhbGxpbmcgY29udmVudGlvbiBvZiBbfmNvbXBhcmF0b3IgfmNvbXBhcmF0b3JdIGlzIGNvbmZ1c2luZy4gSXQgaXMgcmVxdWlyZWRcbiAgICAgYmVjYXVzZSBbYWNjZXNzX29wdGlvbnNdIGFuZCBbY3JlYXRlX29wdGlvbnNdIGJvdGggZGVtYW5kIGEgW35jb21wYXJhdG9yXSBhcmd1bWVudCBpblxuICAgICBbTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZV0uXG5cbiAgICAgTWFraW5nIGl0IGxlc3MgY29uZnVzaW5nIHdvdWxkIHJlcXVpcmUgc29tZSB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5IGluIHNpZ25hdHVyZXMuXG4gICAgIEJldHRlciB0byBqdXN0IGxpdmUgd2l0aCBhbiB1bmRlc2lyYWJsZSBpbnRlcmZhY2UgaW4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvYmFibHlcbiAgICAgbmV2ZXIgYmUgY2FsbGVkIGRpcmVjdGx5LiAqKVxuICBsZXQgdHJhbnNwb3NlX2tleXMgfmNvbXBhcmF0b3I6b3V0ZXJfY29tcGFyYXRvciB+Y29tcGFyYXRvcjppbm5lcl9jb21wYXJhdG9yIHQgPVxuICAgIChUcmVlMC50cmFuc3Bvc2Vfa2V5cyB+b3V0ZXJfY29tcGFyYXRvciB+aW5uZXJfY29tcGFyYXRvciB0KS50cmVlXG4gICAgfD4gbWFwIH5mOihmdW4gKHggOiAoJ2ssICd2KSBUcmVlMC50IFdpdGhfbGVuZ3RoLnQpIC0+IHgudHJlZSlcbiAgOztcblxuICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA9IHN0cnVjdFxuICAgIHR5cGUgKCdrLCAndiwgJ3cpIHQgPSAoJ2ssICd2KSBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLnRcblxuICAgIGxldCBlbXB0eSA9IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcuZW1wdHlcblxuICAgIGxldCBhZGRfZXhuIHQgfmNvbXBhcmF0b3IgfmtleSB+ZGF0YSA9XG4gICAgICBtYXRjaCBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLm1heF9rZXkgdCB3aXRoXG4gICAgICB8IFNvbWUgcHJldl9rZXkgd2hlbiBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBwcmV2X2tleSBrZXkgPj0gMCAtPlxuICAgICAgICBFcnJvci5yYWlzZV9zIChTZXhwLkF0b20gXCJNYXAuQnVpbGRfaW5jcmVhc2luZy5hZGQ6IG5vbi1pbmNyZWFzaW5nIGtleVwiKVxuICAgICAgfCBfIC0+IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcuYWRkX3VuY2hlY2tlZCB0IH5rZXkgfmRhdGFcbiAgICA7O1xuXG4gICAgbGV0IHRvX3RyZWUgdCA9IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcudG9fdHJlZV91bmNoZWNrZWQgdFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgVXNpbmdfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2LCAnY21wKSB0ID0gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yID0geyB0cmVlID0gVHJlZTAuZW1wdHk7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IDAgfVxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yIGsgdiA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLnNpbmdsZXRvbiBrIHY7IGxlbmd0aCA9IDEgfVxuXG4gIGxldCBvZl90cmVlMCB+Y29tcGFyYXRvciAoeyB0cmVlOyBsZW5ndGggfSA6IF8gV2l0aF9sZW5ndGgudCkgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgOztcblxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAod2l0aF9sZW5ndGggdHJlZSAoVHJlZTAubGVuZ3RoIHRyZWUpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHRvX3RyZWUgPSB0b190cmVlXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIChUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgICAgfmY6KGZ1biB0cmVlIC0+IG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0IH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBtYXRjaCBUcmVlMC5vZl9hbGlzdCBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHsgdHJlZTsgbGVuZ3RoIH0gLT4gYE9rIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBSZXN1bHQubWFwIChUcmVlMC5vZl9hbGlzdF9vcl9lcnJvciBhbGlzdCB+Y29tcGFyYXRvcikgfmY6KGZ1biB0cmVlIC0+XG4gICAgICBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9hbGlzdF9leG4gYWxpc3QgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9hbGlzdF9tdWx0aSBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3IgYWxpc3QgfmluaXQgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X2ZvbGQgYWxpc3QgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3IgYWxpc3QgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X3JlZHVjZSBhbGlzdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpIH5jb21wYXJhdG9yIH5pdGVyaSA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfaXRlcmkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH5pdGVyaSB3aXRoXG4gICAgfCBgT2sgdHJlZV9sZW5ndGggLT4gYE9rIChvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlX2xlbmd0aClcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpX2V4biB+Y29tcGFyYXRvciB+aXRlcmkgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9pdGVyaV9leG4gfmNvbXBhcmF0b3Igfml0ZXJpKVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgICh3aXRoX2xlbmd0aCAoVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZikgbGVuKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIH5mOihmdW4geCAtPiBvZl90cmVlMCB+Y29tcGFyYXRvciB4KVxuICAgICAgKFRyZWUwLm9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBtYXRjaCBUcmVlMC5vZl9zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayB7IHRyZWU7IGxlbmd0aCB9IC0+IGBPayB7IGNvbXBhcmF0b3I7IHRyZWU7IGxlbmd0aCB9XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIHogLT4gelxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzZXEgPVxuICAgIFJlc3VsdC5tYXAgKFRyZWUwLm9mX3NlcXVlbmNlX29yX2Vycm9yIHNlcSB+Y29tcGFyYXRvcikgfmY6KGZ1biB0cmVlIC0+XG4gICAgICBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3Igc2VxID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2Zfc2VxdWVuY2VfZXhuIHNlcSB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9tdWx0aSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHNlcSB+aW5pdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc2VxdWVuY2VfZm9sZCBzZXEgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3Igc2VxIH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9yZWR1Y2Ugc2VxIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleSB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICBtYXRjaFxuICAgICAgVHJlZTAub2ZfbGlzdF93aXRoX2tleSBsaXN0IH5nZXRfa2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIHdpdGhcbiAgICB8IGBPayB7IHRyZWU7IGxlbmd0aCB9IC0+IGBPayB7IGNvbXBhcmF0b3I7IHRyZWU7IGxlbmd0aCB9XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIHogLT4gelxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIFJlc3VsdC5tYXAgKFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvcikgfmY6KGZ1biB0cmVlIC0+XG4gICAgICBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2V4biB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2ZfbGlzdF93aXRoX2tleV9leG4gbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9tdWx0aSB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICBUcmVlMC5vZl9saXN0X3dpdGhfa2V5X211bHRpIGxpc3QgfmdldF9rZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfD4gb2ZfdHJlZTAgfmNvbXBhcmF0b3JcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9mb2xkIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgfmluaXQgfmYgPVxuICAgIFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfZm9sZFxuICAgICAgbGlzdFxuICAgICAgfmdldF9rZXlcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfD4gb2ZfdHJlZTAgfmNvbXBhcmF0b3JcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9yZWR1Y2UgfmNvbXBhcmF0b3IgbGlzdCB+Z2V0X2tleSB+ZiA9XG4gICAgVHJlZTAub2ZfbGlzdF93aXRoX2tleV9yZWR1Y2VcbiAgICAgIGxpc3RcbiAgICAgIH5nZXRfa2V5XG4gICAgICB+ZlxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfD4gb2ZfdHJlZTAgfmNvbXBhcmF0b3JcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC50X29mX3NleHBfZGlyZWN0IGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgbWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbWF0Y2ggVHJlZTAubWFwX2tleXMgdC50cmVlIH5mIH5jb21wYXJhdG9yIHdpdGhcbiAgICB8IGBPayBwYWlyIC0+IGBPayAob2ZfdHJlZTAgfmNvbXBhcmF0b3IgcGFpcilcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZHVwIC0+IGR1cFxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm1hcF9rZXlzX2V4biB0LnRyZWUgfmYgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IHRyYW5zcG9zZV9rZXlzIH5jb21wYXJhdG9yOmlubmVyX2NvbXBhcmF0b3IgdCA9XG4gICAgbGV0IG91dGVyX2NvbXBhcmF0b3IgPSB0LmNvbXBhcmF0b3IgaW5cbiAgICBUcmVlMC50cmFuc3Bvc2Vfa2V5cyB+b3V0ZXJfY29tcGFyYXRvciB+aW5uZXJfY29tcGFyYXRvciAoVHJlZTAubWFwIHQudHJlZSB+Zjp0b190cmVlKVxuICAgIHw+IG9mX3RyZWUwIH5jb21wYXJhdG9yOmlubmVyX2NvbXBhcmF0b3JcbiAgICB8PiBtYXAgfmY6KGZ1biB4IC0+IG9mX3RyZWUwIH5jb21wYXJhdG9yOm91dGVyX2NvbXBhcmF0b3IgeClcbiAgOztcblxuICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoSyA6IENvbXBhcmF0b3IuUzEpID0gc3RydWN0XG4gICAgbGV0IGVtcHR5ID0geyB0cmVlID0gVHJlZTAuZW1wdHk7IGNvbXBhcmF0b3IgPSBLLmNvbXBhcmF0b3I7IGxlbmd0aCA9IDAgfVxuICBlbmRcblxuICBtb2R1bGUgVHJlZSA9IFRyZWVcbmVuZFxuXG5pbmNsdWRlIEFjY2Vzc29yc1xuXG5sZXQgY29tcGFyYXRvcl9zIHQgPSBDb21wYXJhdG9yLnRvX21vZHVsZSB0LmNvbXBhcmF0b3JcbmxldCB0b19jb21wYXJhdG9yID0gQ29tcGFyYXRvci5vZl9tb2R1bGVcbmxldCBvZl90cmVlIG0gdHJlZSA9IG9mX3RyZWUgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdHJlZVxubGV0IGVtcHR5IG0gPSBVc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5sZXQgc2luZ2xldG9uIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9hbGlzdCBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IG9mX2FsaXN0X29yX2Vycm9yIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuOztcblxubGV0IG9mX2FsaXN0X2V4biBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2V4biB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYWxpc3RfbXVsdGkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9hbGlzdF9mb2xkIG0gYSB+aW5pdCB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhIH5pbml0IH5mXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVkdWNlIG0gYSB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcbjs7XG5cbmxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9pdGVyaSBtIH5pdGVyaSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5cbmxldCBvZl9pdGVyaV9leG4gbSB+aXRlcmkgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbjs7XG5cbmxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBtIH5sZW4gfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbjs7XG5cbmxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIG0gc2VxID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNlcVxuOztcblxubGV0IG9mX3NlcXVlbmNlIG0gcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuXG5sZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgbSBzID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2VfZXhuIG0gcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcblxubGV0IG9mX3NlcXVlbmNlX211bHRpIG0gcyA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuOztcblxubGV0IG9mX3NlcXVlbmNlX2ZvbGQgbSBzIH5pbml0IH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHMgfmluaXQgfmZcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgbSBzIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgcyB+ZlxuOztcblxubGV0IG9mX2xpc3Rfd2l0aF9rZXkgbSBsIH5nZXRfa2V5ID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9saXN0X3dpdGhfa2V5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGwgfmdldF9rZXlcbjs7XG5cbmxldCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIG0gbCB+Z2V0X2tleSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBsIH5nZXRfa2V5XG47O1xuXG5sZXQgb2ZfbGlzdF93aXRoX2tleV9leG4gbSBsIH5nZXRfa2V5ID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9saXN0X3dpdGhfa2V5X2V4biB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBsIH5nZXRfa2V5XG47O1xuXG5sZXQgb2ZfbGlzdF93aXRoX2tleV9tdWx0aSBtIGwgfmdldF9rZXkgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgbCB+Z2V0X2tleVxuOztcblxubGV0IG9mX2xpc3Rfd2l0aF9rZXlfZm9sZCBtIGwgfmdldF9rZXkgfmluaXQgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfZm9sZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBsIH5nZXRfa2V5IH5pbml0IH5mXG47O1xuXG5sZXQgb2ZfbGlzdF93aXRoX2tleV9yZWR1Y2UgbSBsIH5nZXRfa2V5IH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9saXN0X3dpdGhfa2V5X3JlZHVjZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBsIH5nZXRfa2V5IH5mXG47O1xuXG5sZXQgbWFwX2tleXMgbSB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5cyB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB0IH5mXG5sZXQgbWFwX2tleXNfZXhuIG0gdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHQgfmZcbmxldCB0cmFuc3Bvc2Vfa2V5cyBtIHQgPSBVc2luZ19jb21wYXJhdG9yLnRyYW5zcG9zZV9rZXlzIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHRcblxubW9kdWxlIE0gKEsgOiBzaWdcbiAgdHlwZSB0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5lbmQpID1cbnN0cnVjdFxuICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmRcblxubW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgQ29tcGFyZV9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEhhc2hfZm9sZF9tID0gSGFzaGVyLlNcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBrKSBzZXhwX29mX3YgdCA9XG4gIHNleHBfb2ZfdCBLLnNleHBfb2ZfdCBzZXhwX29mX3YgKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cFxuICAodHlwZSBrIGNtcClcbiAgKG1vZHVsZSBLIDogTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApXG4gIHZfb2Zfc2V4cFxuICBzZXhwXG4gID1cbiAgVXNpbmdfY29tcGFyYXRvci50X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yOksuY29tcGFyYXRvciBLLnRfb2Zfc2V4cCB2X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyXG4gICh0eXBlIGspXG4gIChtb2R1bGUgSyA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gaylcbiAgKHZfZ3JhbW1hciA6IF8gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogXyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBUYWdnZWRcbiAgICAgICAgeyBrZXkgPSBTZXhwbGliMC5TZXhwX2dyYW1tYXIuYXNzb2NfdGFnXG4gICAgICAgIDsgdmFsdWUgPSBMaXN0IFtdXG4gICAgICAgIDsgZ3JhbW1hciA9XG4gICAgICAgICAgICBMaXN0XG4gICAgICAgICAgICAgIChNYW55XG4gICAgICAgICAgICAgICAgIChMaXN0XG4gICAgICAgICAgICAgICAgICAgIChDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICggVGFnZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY19rZXlfdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA7IHZhbHVlID0gTGlzdCBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBncmFtbWFyID0gSy50X3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICwgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBUYWdnZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY192YWx1ZV90YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IHZhbHVlID0gTGlzdCBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgZ3JhbW1hciA9IHZfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBFbXB0eSApICkpKSlcbiAgICAgICAgfVxuICB9XG47O1xuXG5sZXQgY29tcGFyZV9tX190IChtb2R1bGUgXyA6IENvbXBhcmVfbSkgY29tcGFyZV92IHQxIHQyID0gY29tcGFyZV9kaXJlY3QgY29tcGFyZV92IHQxIHQyXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSBlcXVhbF92IHQxIHQyID0gZXF1YWwgZXF1YWxfdiB0MSB0MlxuXG5sZXQgaGFzaF9mb2xkX21fX3QgKHR5cGUgaykgKG1vZHVsZSBLIDogSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSBrKSBoYXNoX2ZvbGRfdiBzdGF0ZSA9XG4gIGhhc2hfZm9sZF9kaXJlY3QgSy5oYXNoX2ZvbGRfdCBoYXNoX2ZvbGRfdiBzdGF0ZVxuOztcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdrLCAndikgdCA9ICgnaywgJ3YsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgdHlwZSBub25yZWMgKCdrLCAndikgdHJlZSA9ICgnaywgJ3YpIFRyZWUwLnRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgY29tcGFyYXRvciA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yXG4gIGxldCBvZl90cmVlIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IFRyZWUwLmxlbmd0aCB0cmVlIH1cblxuICBpbmNsdWRlIFVzaW5nX2NvbXBhcmF0b3IuRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoQ29tcGFyYXRvci5Qb2x5KVxuXG4gIGxldCBzaW5nbGV0b24gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X2V4biBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfZm9sZCBhIH5pbml0IH5mID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yIGEgfmluaXQgfmZcbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3IgYSB+ZlxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGEgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfaXRlcmkgfml0ZXJpID0gVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmF0b3JcbiAgbGV0IG9mX2l0ZXJpX2V4biB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3JcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mIH5jb21wYXJhdG9yXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxID0gVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcVxuICBsZXQgb2Zfc2VxdWVuY2UgcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc1xuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3Igc1xuICBsZXQgb2Zfc2VxdWVuY2VfZXhuIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzXG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgcyB+aW5pdCB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHMgfmluaXQgfmZcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIHMgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzIH5mXG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXkgbCB+Z2V0X2tleSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9saXN0X3dpdGhfa2V5IH5jb21wYXJhdG9yIGwgfmdldF9rZXlcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciBsIH5nZXRfa2V5ID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgfmNvbXBhcmF0b3IgbCB+Z2V0X2tleVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2V4biBsIH5nZXRfa2V5ID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfZXhuIH5jb21wYXJhdG9yIGwgfmdldF9rZXlcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9tdWx0aSBsIH5nZXRfa2V5ID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgfmNvbXBhcmF0b3IgbCB+Z2V0X2tleVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2ZvbGQgbCB+Z2V0X2tleSB+aW5pdCB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9saXN0X3dpdGhfa2V5X2ZvbGQgfmNvbXBhcmF0b3IgbCB+Z2V0X2tleSB+aW5pdCB+ZlxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSBsIH5nZXRfa2V5IH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlIH5jb21wYXJhdG9yIGwgfmdldF9rZXkgfmZcbiAgOztcblxuICBsZXQgbWFwX2tleXMgdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZlxuICBsZXQgbWFwX2tleXNfZXhuIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mXG4gIGxldCB0cmFuc3Bvc2Vfa2V5cyB0ID0gVXNpbmdfY29tcGFyYXRvci50cmFuc3Bvc2Vfa2V5cyB+Y29tcGFyYXRvciB0XG5lbmRcbiIsIm9wZW4hIEltcG9ydDBcblxudHlwZSAnYSB0ID0gJ2EgU3RkbGliLlF1ZXVlLnRcblxubGV0IGNyZWF0ZSA9IFN0ZGxpYi5RdWV1ZS5jcmVhdGVcbmxldCBjbGVhciA9IFN0ZGxpYi5RdWV1ZS5jbGVhclxubGV0IGNvcHkgPSBTdGRsaWIuUXVldWUuY29weVxubGV0IGlzX2VtcHR5ID0gU3RkbGliLlF1ZXVlLmlzX2VtcHR5XG5sZXQgbGVuZ3RoID0gU3RkbGliLlF1ZXVlLmxlbmd0aFxubGV0IHBlZWsgPSBTdGRsaWIuUXVldWUucGVla1xubGV0IHBvcCA9IFN0ZGxpYi5RdWV1ZS5wb3BcbmxldCBwdXNoID0gU3RkbGliLlF1ZXVlLnB1c2hcbmxldCB0cmFuc2ZlciA9IFN0ZGxpYi5RdWV1ZS50cmFuc2ZlclxuXG5sZXQgaXRlciB0IH4oZiA6IF8gLT4gXykgPVxuICBsZXQgY2FtbF9pdGVyIDogKCdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdCA9XG4gICAgU3RkbGliLk9iai5tYWdpYyAoU3RkbGliLlF1ZXVlLml0ZXIgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0KVxuICBpblxuICBjYW1sX2l0ZXIgZiB0XG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH4oZiA6IF8gLT4gXyAtPiBfKSA9XG4gIGxldCBjYW1sX2ZvbGQgOiAoJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiIC0+ICdhIHQgLT4gJ2IgPVxuICAgIFN0ZGxpYi5PYmoubWFnaWMgKFN0ZGxpYi5RdWV1ZS5mb2xkIDogKCdiIC0+ICdhIC0+ICdiKSAtPiAnYiAtPiAnYSB0IC0+ICdiKVxuICBpblxuICBjYW1sX2ZvbGQgZiBpbml0IHRcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgTGlua2VkX3F1ZXVlMFxuXG5sZXQgZW5xdWV1ZSB0IHggPSBMaW5rZWRfcXVldWUwLnB1c2ggeCB0XG5sZXQgZGVxdWV1ZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChMaW5rZWRfcXVldWUwLnBvcCB0KVxubGV0IGRlcXVldWVfZXhuID0gTGlua2VkX3F1ZXVlMC5wb3BcbmxldCBkZXF1ZXVlX2FuZF9pZ25vcmVfZXhuICh0eXBlIGVsdCkgKHQgOiBlbHQgdCkgPSBpZ25vcmUgKGRlcXVldWVfZXhuIHQgOiBlbHQpXG5sZXQgcGVlayB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChMaW5rZWRfcXVldWUwLnBlZWsgdClcbmxldCBwZWVrX2V4biA9IExpbmtlZF9xdWV1ZTAucGVla1xuXG5sZXQgZHJhaW4gdCB+ZiB+d2hpbGVfID1cbiAgd2hpbGUgKG5vdCAoaXNfZW1wdHkgdCkpICYmIHdoaWxlXyAocGVla19leG4gdCkgZG9cbiAgICBmIChkZXF1ZXVlX2V4biB0KVxuICBkb25lXG47O1xuXG5tb2R1bGUgQyA9IEluZGV4ZWRfY29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBmb2xkID0gZm9sZFxuICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbiAgbGV0IGZvbGRpID0gYERlZmluZV91c2luZ19mb2xkXG4gIGxldCBpdGVyaSA9IGBEZWZpbmVfdXNpbmdfZm9sZFxuZW5kKVxuXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxubGV0IGZvcl9hbGwgPSBDLmZvcl9hbGxcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgbWVtID0gQy5tZW1cbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgc3VtID0gQy5zdW1cbmxldCB0b19saXN0ID0gQy50b19saXN0XG5sZXQgY291bnRpID0gQy5jb3VudGlcbmxldCBleGlzdHNpID0gQy5leGlzdHNpXG5sZXQgZmluZF9tYXBpID0gQy5maW5kX21hcGlcbmxldCBmaW5kaSA9IEMuZmluZGlcbmxldCBmb2xkaSA9IEMuZm9sZGlcbmxldCBmb3JfYWxsaSA9IEMuZm9yX2FsbGlcbmxldCBpdGVyaSA9IEMuaXRlcmlcbmxldCB0cmFuc2ZlciB+c3JjIH5kc3QgPSBMaW5rZWRfcXVldWUwLnRyYW5zZmVyIHNyYyBkc3RcblxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBMaXN0Lml0ZXIgKGYgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgcmVzIGIpKTtcbiAgcmVzXG47O1xuXG5sZXQgY29uY2F0X21hcGkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBMaXN0Lml0ZXIgKGYgaSBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSByZXMgYikpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT5cbiAgICBtYXRjaCBmIGEgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBiIC0+IGVucXVldWUgcmVzIGIpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+XG4gICAgbWF0Y2ggZiBpIGEgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBiIC0+IGVucXVldWUgcmVzIGIpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBpZiBmIGEgdGhlbiBlbnF1ZXVlIHJlcyBhKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IGlmIGYgaSBhIHRoZW4gZW5xdWV1ZSByZXMgYSk7XG4gIHJlc1xuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IGVucXVldWUgcmVzIChmIGEpKTtcbiAgcmVzXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IGVucXVldWUgcmVzIChmIGkgYSkpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXJfaW5wbGFjZSBxIH5mID1cbiAgbGV0IHEnID0gZmlsdGVyIHEgfmYgaW5cbiAgY2xlYXIgcTtcbiAgdHJhbnNmZXIgfnNyYzpxJyB+ZHN0OnFcbjs7XG5cbmxldCBmaWx0ZXJpX2lucGxhY2UgcSB+ZiA9XG4gIGxldCBxJyA9IGZpbHRlcmkgcSB+ZiBpblxuICBjbGVhciBxO1xuICB0cmFuc2ZlciB+c3JjOnEnIH5kc3Q6cVxuOztcblxubGV0IGVucXVldWVfYWxsIHQgbGlzdCA9IExpc3QuaXRlciBsaXN0IH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeClcblxubGV0IG9mX2xpc3QgbGlzdCA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIExpc3QuaXRlciBsaXN0IH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeCk7XG4gIHRcbjs7XG5cbmxldCBvZl9hcnJheSBhcnJheSA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIEFycmF5Lml0ZXIgYXJyYXkgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KTtcbiAgdFxuOztcblxubGV0IGluaXQgbGVuIH5mID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBlbnF1ZXVlIHQgKGYgaSlcbiAgZG9uZTtcbiAgdFxuOztcblxubGV0IHRvX2FycmF5IHQgPVxuICBtYXRjaCBsZW5ndGggdCB3aXRoXG4gIHwgMCAtPiBbfHxdXG4gIHwgbGVuIC0+XG4gICAgbGV0IGFyciA9IEFycmF5LmNyZWF0ZSB+bGVuIChwZWVrX2V4biB0KSBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBpdGVyIHQgfmY6KGZ1biB2IC0+XG4gICAgICBhcnIuKCFpKSA8LSB2O1xuICAgICAgaW5jciBpKTtcbiAgICBhcnJcbjs7XG5cbmxldCB0X29mX3NleHAgYV9vZl9zZXhwIHNleHAgPSBvZl9saXN0IChsaXN0X29mX3NleHAgYV9vZl9zZXhwIHNleHApXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfYSAodG9fbGlzdCB0KVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbmxldCBzaW5nbGV0b24gYSA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIGVucXVldWUgdCBhO1xuICB0XG47O1xuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBTdGRsaWIuSW50NjRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50NjQgW0BAZGVyaXZpbmdfaW5saW5lIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoZ2xvYmFsaXplIDogdCAtPiB0KSA9IChnbG9iYWxpemVfaW50NjQgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnQ2NFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50NjQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludDY0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludDY0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDY0X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSA9IEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nX29wdCA9IG9mX3N0cmluZ19vcHRcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5sZXQgbnVtX2JpdHMgPSA2NFxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5cbmV4dGVybmFsIGZsb2F0X29mX2JpdHNcbiAgOiAgKGludDY0W0Bsb2NhbF9vcHRdKVxuICAtPiAoZmxvYXRbQGxvY2FsX29wdF0pXG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdFxuICA6ICAoZmxvYXRbQGxvY2FsX29wdF0pXG4gIC0+IChpbnQ2NFtAbG9jYWxfb3B0XSlcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHBvdyA9IEludF9tYXRoLlByaXZhdGUuaW50NjRfcG93XG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWludXNfb25lID0gbWludXNfb25lXG5sZXQgb25lID0gb25lXG5sZXQgemVybyA9IHplcm9cbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gU3RkbGliLkludDY0Lm9mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICAgICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIFN0ZGxpYi5JbnQ2NC5vZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludDY0Lm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG4oKiBOb3QgZXRhLWV4cGFuZGluZyBoZXJlIGNhbiBsZWFkIHRvIGxlc3MgYWxsb2NhdGlvbnM6IHRoZSBmdW5jdGlvbiBjYWxsIHNpdGVzIGNhbiBhdm9pZFxuICAgYm94aW5nIHRoZSBpbnQ2NHMgbW9yZSBvZnRlbi4gKilcbmxldCAoICoqICkgPSBwb3dcblxuZXh0ZXJuYWwgYnN3YXA2NCA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldFtAaW5saW5lIGFsd2F5c10gYnN3YXAxNiB4ID0gU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwNjQgeCkgNDhcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBic3dhcDMyIHggPVxuICAoKiBUaGlzIGlzIHN0cmljdGx5IGJldHRlciB0aGFuIGNvZXJjaW5nIHRvIGFuIGludDMyIHRvIHBlcmZvcm0gYnl0ZXN3YXAuIENvZXJjaW5nXG4gICAgIGZyb20gYW4gaW50MzIgd2lsbCBhZGQgdW5uZWNlc3Nhcnkgc2hpZnQgb3BlcmF0aW9ucyB0byBzaWduIGV4dGVuZCB0aGUgbnVtYmVyXG4gICAgIGFwcHJvcHJpYXRlbHkuXG4gICopXG4gIFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDMyXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGJzd2FwNDggeCA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDE2XG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW46bWluXyB+bWF4Om1heF8gPSBtaW4gdCBtYXhfIHw+IG1heCBtaW5fXG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgaW5jciByID0gciA6PSBhZGQgIXIgb25lXG5sZXQgZGVjciByID0gciA6PSBzdWIgIXIgb25lXG5cbmV4dGVybmFsIG9mX2ludDY0IDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcblxubGV0IG9mX2ludDY0X2V4biA9IG9mX2ludDY0XG5sZXQgdG9faW50NjQgdCA9IHRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludDY0X3BvcGNvdW50XG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbmV4dGVybmFsIHRvX2ludF90cnVuYyA6ICh0W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgdG9faW50MzJfdHJ1bmMgOiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IChpbnQzMltAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5cbmV4dGVybmFsIHRvX25hdGl2ZWludF90cnVuY1xuICA6ICAoaW50NjRbQGxvY2FsX29wdF0pXG4gIC0+IChuYXRpdmVpbnRbQGxvY2FsX29wdF0pXG4gID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxuZXh0ZXJuYWwgb2ZfaW50IDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29mX2ludFwiXG5leHRlcm5hbCBvZl9pbnQzMiA6IChpbnQzMltAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29mX2ludDMyXCJcblxubGV0IG9mX2ludF9leG4gPSBvZl9pbnRcbmxldCB0b19pbnQgPSBDb252LmludDY0X3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252LmludDY0X3RvX2ludF9leG5cbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyID0gQ29udi5pbnQ2NF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuXG5cbmV4dGVybmFsIG9mX25hdGl2ZWludCA6IChuYXRpdmVpbnRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29mX25hdGl2ZWludFwiXG5cbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gb2ZfbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfZXhuXG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IFN0ZGxpYi5JbnQ2NC5sb2dvclxuICBsZXQgKCBsc3IgKSA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IFN0ZGxpYi5JbnQ2NC5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBTdGRsaWIuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IFN0ZGxpYi5JbnQ2NC5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIFN0ZGxpYi5JbnQ2NC5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gU3RkbGliLkludDY0Lnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBTdGRsaWIuSW50NjQuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBTdGRsaWIuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgU3RkbGliLkludDY0LnByZWQgeCA9IFN0ZGxpYi5JbnQ2NC56ZXJvXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHpfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAoaW50NjRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHpcIiBcIkJhc2VfaW50X21hdGhfaW50NjRfY3R6X3VuYm94ZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBpIDw9IFN0ZGxpYi5JbnQ2NC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiW0ludDY0LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDY0IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBTdGRsaWIuSW50NjQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQ2NC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDY0IGkgXSk7XG4gICAgaWYgU3RkbGliLkludDY0LmVxdWFsIGkgU3RkbGliLkludDY0Lm9uZVxuICAgIHRoZW4gMFxuICAgIGVsc2UgbnVtX2JpdHMgLSBjbHogKFN0ZGxpYi5JbnQ2NC5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZSAoVClcblxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2VfaGV4IChzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50NjQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChjb21wYXJlX2ludDY0X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0ICggPCApID0gKCA8IClcbiAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlTHhcIiBpXG4gIGxldCBvZl9zdHJpbmcgcyA9IFN0ZGxpYi5TY2FuZi5zc2NhbmYgcyBcIiVMeFwiIEZuLmlkXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2NC5IZXhcIlxuZW5kKVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9iaW5hcnkgKHN0cnVjdFxuICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoY29tcGFyZV9pbnQ2NF9fbG9jYWwgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBlcXVhbF9fbG9jYWwgPSAoZXF1YWxfaW50NjRfX2xvY2FsIDogdCAtPiB0IC0+IGJvb2wpXG4gIGxldCBlcXVhbCA9IChmdW4gYSBiIC0+IGVxdWFsX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0ICggbGFuZCApID0gKCBsYW5kIClcbiAgbGV0ICggbHNyICkgPSAoIGxzciApXG4gIGxldCBjbHogPSBjbHpcbiAgbGV0IG51bV9iaXRzID0gbnVtX2JpdHNcbiAgbGV0IG9uZSA9IG9uZVxuICBsZXQgdG9faW50X2V4biA9IHRvX2ludF9leG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDY0XCJcbmVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGV4dGVybmFsICggKyApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF9hZGRcIlxuICBleHRlcm5hbCAoIC0gKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfc3ViXCJcbiAgZXh0ZXJuYWwgKCAqICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X211bFwiXG4gIGV4dGVybmFsICggLyApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF9kaXZcIlxuICBleHRlcm5hbCAoIH4tICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfbmVnXCJcblxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYWJzID0gYWJzXG5cbiAgZXh0ZXJuYWwgbmVnIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X25lZ1wiXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBpbmNsdWRlIFByZV9PXG5cbiAgICBsZXQgcmVtID0gcmVtXG4gICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICBlbmQpXG5cbiAgZXh0ZXJuYWwgKCBsYW5kICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X2FuZFwiXG4gIGV4dGVybmFsICggbG9yICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29yXCJcbiAgZXh0ZXJuYWwgKCBseG9yICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X3hvclwiXG5cbiAgbGV0IGxub3QgPSBiaXRfbm90XG5cbiAgZXh0ZXJuYWwgKCBsc2wgKVxuICAgIDogICh0W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKHRbQGxvY2FsX29wdF0pXG4gICAgPSBcIiVpbnQ2NF9sc2xcIlxuXG4gIGV4dGVybmFsICggYXNyIClcbiAgICA6ICAodFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+ICh0W0Bsb2NhbF9vcHRdKVxuICAgID0gXCIlaW50NjRfYXNyXCJcblxuICBleHRlcm5hbCAoIGxzciApXG4gICAgOiAgKHRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAodFtAbG9jYWxfb3B0XSlcbiAgICA9IFwiJWludDY0X2xzclwiXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQ2NF0gYW5kIFtJbnQ2NC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIigqIEEgNjNiaXQgaW50ZWdlciBpcyBhIDY0Yml0IGludGVnZXIgd2l0aCBpdHMgYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0XG4gICBhbmQgaXRzIGxvd2VzdCBiaXQgc2V0IHRvIDAuXG4gICBUaGlzIGlzIHRoZSBzYW1lIGtpbmQgb2YgZW5jb2RpbmcgYXMgT0NhbWwgaW50IG9uIDY0Yml0IGFyY2hpdGVjdHVyZS5cbiAgIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmVpbmcgdGhlIGxvd2VzdCBiaXQgKGltbWVkaWF0ZSBiaXQpIHNldCB0byAxLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBUMCA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IGludDY0XG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCBjb21wYXJlX19sb2NhbCA9IChjb21wYXJlX2ludDY0X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gICAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuICAgIGxldCAoZ2xvYmFsaXplIDogdCAtPiB0KSA9IChnbG9iYWxpemVfaW50NjQgOiB0IC0+IHQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50NjRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIGxldCB0X29mX3NleHAgPSAoaW50NjRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQ2NCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDY0X3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuZW5kXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbm1vZHVsZSBXIDogc2lnXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBUMFxuICBlbmRcblxuICB0eXBlIHQgPSBpbnQ2NFxuXG4gIHZhbCB3cmFwX2V4biA6IFN0ZGxpYi5JbnQ2NC50IC0+IHRcbiAgdmFsIHdyYXBfbW9kdWxvIDogU3RkbGliLkludDY0LnQgLT4gdFxuICB2YWwgdW53cmFwIDogdCAtPiBTdGRsaWIuSW50NjQudFxuXG4gICgqKiBSZXR1cm5zIGEgbm9uLW5lZ2F0aXZlIGludDY0IHRoYXQgaXMgZXF1YWwgdG8gdGhlIGlucHV0IGludDYzIG1vZHVsbyAyXjYzLiAqKVxuICB2YWwgdW53cmFwX3Vuc2lnbmVkIDogdCAtPiBTdGRsaWIuSW50NjQudFxuXG4gIHZhbCBpbnZhcmlhbnQgOiB0IC0+IHVuaXRcbiAgdmFsIGFkZCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBzdWIgOiB0IC0+IHQgLT4gdFxuICB2YWwgbmVnIDogdCAtPiB0XG4gIHZhbCBhYnMgOiB0IC0+IHRcbiAgdmFsIHN1Y2MgOiB0IC0+IHRcbiAgdmFsIHByZWQgOiB0IC0+IHRcbiAgdmFsIG11bCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3cgOiB0IC0+IHQgLT4gdFxuICB2YWwgZGl2IDogdCAtPiB0IC0+IHRcbiAgdmFsIHJlbSA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3Bjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBiaXRfbm90IDogdCAtPiB0XG4gIHZhbCBiaXRfeG9yIDogdCAtPiB0IC0+IHRcbiAgdmFsIGJpdF9vciA6IHQgLT4gdCAtPiB0XG4gIHZhbCBiaXRfYW5kIDogdCAtPiB0IC0+IHRcbiAgdmFsIHNoaWZ0X2xlZnQgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBzaGlmdF9yaWdodCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBtaW5fdmFsdWUgOiB0XG4gIHZhbCBtYXhfdmFsdWUgOiB0XG4gIHZhbCB0b19pbnQ2NCA6IHQgLT4gU3RkbGliLkludDY0LnRcbiAgdmFsIG9mX2ludDY0IDogU3RkbGliLkludDY0LnQgLT4gdCBvcHRpb25cbiAgdmFsIG9mX2ludDY0X2V4biA6IFN0ZGxpYi5JbnQ2NC50IC0+IHRcbiAgdmFsIG9mX2ludDY0X3RydW5jIDogU3RkbGliLkludDY0LnQgLT4gdFxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGNvbXBhcmVfX2xvY2FsIDogdCAtPiB0IC0+IGludFxuICB2YWwgZXF1YWxfX2xvY2FsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIGNlaWxfcG93MiA6IHQgLT4gdFxuICB2YWwgZmxvb3JfcG93MiA6IHQgLT4gdFxuICB2YWwgY2VpbF9sb2cyIDogdCAtPiBpbnRcbiAgdmFsIGZsb29yX2xvZzIgOiB0IC0+IGludFxuICB2YWwgaXNfcG93MiA6IHQgLT4gYm9vbFxuICB2YWwgY2x6IDogdCAtPiBpbnRcbiAgdmFsIGN0eiA6IHQgLT4gaW50XG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUMFxuXG4gIHR5cGUgdCA9IGludDY0XG5cbiAgbGV0IHdyYXBfZXhuIHggPVxuICAgICgqIFJhaXNlcyBpZiB0aGUgaW50NjQgdmFsdWUgZG9lcyBub3QgZml0IG9uIGludDYzLiAqKVxuICAgIENvbnYuaW50NjRfZml0X29uX2ludDYzX2V4biB4O1xuICAgIFN0ZGxpYi5JbnQ2NC5tdWwgeCAyTFxuICA7O1xuXG4gIGxldCB3cmFwIHggPVxuICAgIGlmIENvbnYuaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyB4IHRoZW4gU29tZSAoU3RkbGliLkludDY0Lm11bCB4IDJMKSBlbHNlIE5vbmVcbiAgOztcblxuICBsZXQgd3JhcF9tb2R1bG8geCA9IFN0ZGxpYi5JbnQ2NC5tdWwgeCAyTFxuICBsZXQgdW53cmFwIHggPSBTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgeCAxXG4gIGxldCB1bndyYXBfdW5zaWduZWQgeCA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIHggMVxuXG4gICgqIFRoaXMgZG9lcyBub3QgdXNlIHdyYXAgb3IgdW53cmFwIHRvIGF2b2lkIGdlbmVyYXRpbmcgZXhjZXB0aW9ucyBpbiB0aGUgY2FzZSBvZlxuICAgICBvdmVyZmxvd3MuIFRoaXMgaXMgdG8gcHJlc2VydmUgdGhlIHNlbWFudGljcyBvZiBpbnQgdHlwZSBvbiA2NCBiaXQgYXJjaGl0ZWN0dXJlLiAqKVxuICBsZXQgZjIgZiBhIGIgPVxuICAgIFN0ZGxpYi5JbnQ2NC5tdWwgKGYgKFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodCBhIDEpIChTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgYiAxKSkgMkxcbiAgOztcblxuICBsZXQgbWFzayA9IDB4ZmZmZl9mZmZmX2ZmZmZfZmZmZUxcbiAgbGV0IG0geCA9IFN0ZGxpYi5JbnQ2NC5sb2dhbmQgeCBtYXNrXG4gIGxldCBpbnZhcmlhbnQgdCA9IGFzc2VydCAobSB0ID0gdClcbiAgbGV0IGFkZCB4IHkgPSBTdGRsaWIuSW50NjQuYWRkIHggeVxuICBsZXQgc3ViIHggeSA9IFN0ZGxpYi5JbnQ2NC5zdWIgeCB5XG4gIGxldCBuZWcgeCA9IFN0ZGxpYi5JbnQ2NC5uZWcgeFxuICBsZXQgYWJzIHggPSBTdGRsaWIuSW50NjQuYWJzIHhcbiAgbGV0IG9uZSA9IHdyYXBfZXhuIDFMXG4gIGxldCBzdWNjIGEgPSBhZGQgYSBvbmVcbiAgbGV0IHByZWQgYSA9IHN1YiBhIG9uZVxuICBsZXQgbWluX3ZhbHVlID0gbSBTdGRsaWIuSW50NjQubWluX2ludFxuICBsZXQgbWF4X3ZhbHVlID0gbSBTdGRsaWIuSW50NjQubWF4X2ludFxuICBsZXQgYml0X25vdCB4ID0gbSAoU3RkbGliLkludDY0LmxvZ25vdCB4KVxuICBsZXQgYml0X2FuZCA9IFN0ZGxpYi5JbnQ2NC5sb2dhbmRcbiAgbGV0IGJpdF94b3IgPSBTdGRsaWIuSW50NjQubG9neG9yXG4gIGxldCBiaXRfb3IgPSBTdGRsaWIuSW50NjQubG9nb3JcbiAgbGV0IHNoaWZ0X2xlZnQgeCBpID0gU3RkbGliLkludDY0LnNoaWZ0X2xlZnQgeCBpXG4gIGxldCBzaGlmdF9yaWdodCB4IGkgPSBtIChTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgeCBpKVxuICBsZXQgc2hpZnRfcmlnaHRfbG9naWNhbCB4IGkgPSBtIChTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCB4IGkpXG4gIGxldCBwb3cgPSBmMiBJbnRfbWF0aC5Qcml2YXRlLmludDYzX3Bvd19vbl9pbnQ2NFxuICBsZXQgbXVsIGEgYiA9IFN0ZGxpYi5JbnQ2NC5tdWwgYSAoU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0IGIgMSlcbiAgbGV0IGRpdiBhIGIgPSB3cmFwX21vZHVsbyAoU3RkbGliLkludDY0LmRpdiBhIGIpXG4gIGxldCByZW0gYSBiID0gU3RkbGliLkludDY0LnJlbSBhIGJcbiAgbGV0IHBvcGNvdW50IHggPSBQb3Bjb3VudC5pbnQ2NF9wb3Bjb3VudCB4XG4gIGxldCB0b19pbnQ2NCB0ID0gdW53cmFwIHRcbiAgbGV0IG9mX2ludDY0IHQgPSB3cmFwIHRcbiAgbGV0IG9mX2ludDY0X2V4biB0ID0gd3JhcF9leG4gdFxuICBsZXQgb2ZfaW50NjRfdHJ1bmMgdCA9IHdyYXBfbW9kdWxvIHRcbiAgbGV0IHRfb2Zfc2V4cCB4ID0gd3JhcF9leG4gKGludDY0X29mX3NleHAgeClcbiAgbGV0IHNleHBfb2ZfdCB4ID0gc2V4cF9vZl9pbnQ2NCAodW53cmFwIHgpXG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IGNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IHQpIHkgPSBjb21wYXJlX19sb2NhbCB4IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IHQpIHkgPSBlcXVhbF9fbG9jYWwgeCB5XG4gIGxldCBpc19wb3cyIHggPSBJbnQ2NC5pc19wb3cyICh1bndyYXAgeClcblxuICBsZXQgY2x6IHggPVxuICAgICgqIFdlIHJ1biBJbnQ2NC5jbHogZGlyZWN0bHkgb24gdGhlIHdyYXBwZWQgaW50NjMgdmFsdWUuIFRoaXMgaXMgY29ycmVjdCBiZWNhdXNlIHRoZVxuICAgICAgIGJpdHMgb2YgdGhlIGludDYzX2VtdWwgYXJlIGxlZnQtYWxpZ25lZCBpbiB0aGUgSW50NjQuICopXG4gICAgSW50NjQuY2x6IHhcbiAgOztcblxuICBsZXQgY3R6IHggPSBJbnQ2NC5jdHogKHVud3JhcCB4KVxuICBsZXQgZmxvb3JfcG93MiB4ID0gSW50NjQuZmxvb3JfcG93MiAodW53cmFwIHgpIHw+IHdyYXBfZXhuXG4gIGxldCBjZWlsX3BvdzIgeCA9IEludDY0LmZsb29yX3BvdzIgKHVud3JhcCB4KSB8PiB3cmFwX2V4blxuICBsZXQgZmxvb3JfbG9nMiB4ID0gSW50NjQuZmxvb3JfbG9nMiAodW53cmFwIHgpXG4gIGxldCBjZWlsX2xvZzIgeCA9IEludDY0LmNlaWxfbG9nMiAodW53cmFwIHgpXG5lbmRcblxub3BlbiBXXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IFcudCBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKFcuZ2xvYmFsaXplIDogdCAtPiB0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBXLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gVy5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChXLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKFcuc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IFcudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gVy5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IFcuY29tcGFyYXRvclxuICBsZXQgY29tcGFyZSA9IFcuY29tcGFyZVxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSBXLmNvbXBhcmVfX2xvY2FsXG4gIGxldCBlcXVhbF9fbG9jYWwgPSBXLmVxdWFsX19sb2NhbFxuICBsZXQgaW52YXJpYW50ID0gVy5pbnZhcmlhbnRcblxuICAoKiBXZSBkb24ndCBleHBlY3QgW2hhc2hdIHRvIGZvbGxvdyB0aGUgYmVoYXZpb3Igb2YgaW50IGluIDY0Yml0IGFyY2hpdGVjdHVyZSAqKVxuICBsZXQgXyA9IGhhc2hcbiAgbGV0IGhhc2ggKHggOiB0KSA9IFN0ZGxpYi5IYXNodGJsLmhhc2ggeFxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBpbnZhbGlkX3N0ciB4ID0gUHJpbnRmLmZhaWx3aXRoZiBcIkludDYzLm9mX3N0cmluZzogaW52YWxpZCBpbnB1dCAlU1wiIHggKClcblxuICAoKlxuICAgICBcInNpZ25cIiByZWZlcnMgdG8gd2hldGhlciB0aGUgbnVtYmVyIHN0YXJ0cyB3aXRoIGEgJy0nXG4gICAgIFwic2lnbmVkbmVzcyA9IGZhbHNlXCIgbWVhbnMgdGhlIHJlc3Qgb2YgdGhlIG51bWJlciBpcyBwYXJzZWQgYXMgdW5zaWduZWQgYW5kIHRoZW4gY2FzdFxuICAgICB0byBzaWduZWQgd2l0aCB3cmFwLWFyb3VuZCBtb2R1bG8gMl5pXG4gICAgIFwic2lnbmVkbmVzcyA9IHRydWVcIiBtZWFucyBubyBzdWNoIGNyYXppbmVzcyBoYXBwZW5zXG5cbiAgICAgVGhlIHRlcm1pbm9sb2d5IGFuZCB0aGUgbG9naWMgaXMgZHVlIHRvIHRoZSBjb2RlIGluIGJ5dGVydW4vaW50cy5jIGluIG9jYW1sIDQuMDNcbiAgICAgKFtwYXJzZV9zaWduX2FuZF9iYXNlXSBmdW5jdGlvbikuXG5cbiAgICAgU2lnbmVkbmVzcyBlcXVhbHMgdHJ1ZSBmb3IgcGxhaW4gZGVjaW1hbCBudW1iZXIgKGUuZy4gMTIzNSwgLTY3ODkpXG5cbiAgICAgU2lnbmVkbmVzcyBlcXVhbHMgZmFsc2UgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgLSBbMHhmZmZmXSwgWy0weGZmZmZdIChoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbilcbiAgICAgLSBbMGIwMTAxXSwgWy0wYjAxMDFdIChiaW5hcnkgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzBvMTIzN10sIFstMG8xMjM3XSAob2N0YWwgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzB1OTgxMl0sIFstMHU5ODEyXSAodW5zaWduZWQgZGVjaW1hbCByZXByZXNlbnRhdGlvbiAtIGF2YWlsYWJsZSBmcm9tIE9DYW1sIDQuMDMpICopXG4gIGxldCBzaWduX2FuZF9zaWduZWRuZXNzIHggPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHggaW5cbiAgICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHBvcywgc2lnbiA9XG4gICAgICBpZiAwIDwgbGVuXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggeC5bMF0gd2l0aFxuICAgICAgICB8ICctJyAtPiAxLCBgTmVnXG4gICAgICAgIHwgJysnIC0+IDEsIGBQb3NcbiAgICAgICAgfCBfIC0+IDAsIGBQb3MpXG4gICAgICBlbHNlIDAsIGBQb3NcbiAgICBpblxuICAgIGlmIHBvcyArIDIgPCBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBjMSA9IHguW3Bvc10gaW5cbiAgICAgIGxldCBjMiA9IHguW3BvcyArIDFdIGluXG4gICAgICBtYXRjaCBjMSwgYzIgd2l0aFxuICAgICAgfCAnMCcsICcwJyAuLiAnOScgLT4gc2lnbiwgdHJ1ZVxuICAgICAgfCAnMCcsIF8gLT4gc2lnbiwgZmFsc2VcbiAgICAgIHwgXyAtPiBzaWduLCB0cnVlKVxuICAgIGVsc2Ugc2lnbiwgdHJ1ZVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgeCA9IFN0ZGxpYi5JbnQ2NC50b19zdHJpbmcgKHVud3JhcCB4KVxuXG4gIGxldCBvZl9zdHJpbmdfcmF3IHN0ciA9XG4gICAgbGV0IHNpZ24sIHNpZ25lZG5lc3MgPSBzaWduX2FuZF9zaWduZWRuZXNzIHN0ciBpblxuICAgIGlmIHNpZ25lZG5lc3NcbiAgICB0aGVuIG9mX2ludDY0X2V4biAoU3RkbGliLkludDY0Lm9mX3N0cmluZyBzdHIpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcG9zX3N0ciA9XG4gICAgICAgIG1hdGNoIHNpZ24gd2l0aFxuICAgICAgICB8IGBOZWcgLT4gU3RyaW5nLnN1YiBzdHIgfnBvczoxIH5sZW46KFN0cmluZy5sZW5ndGggc3RyIC0gMSlcbiAgICAgICAgfCBgUG9zIC0+IHN0clxuICAgICAgaW5cbiAgICAgIGxldCBpbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5vZl9zdHJpbmcgcG9zX3N0ciBpblxuICAgICAgKCogdW5zaWduZWQgNjMtYml0IGludCBtdXN0IHBhcnNlIGFzIGEgcG9zaXRpdmUgc2lnbmVkIDY0LWJpdCBpbnQgKilcbiAgICAgIGlmIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpbnQ2NCAwTCB0aGVuIGludmFsaWRfc3RyIHN0cjtcbiAgICAgIGxldCBpbnQ2MyA9IHdyYXBfbW9kdWxvIGludDY0IGluXG4gICAgICBtYXRjaCBzaWduIHdpdGhcbiAgICAgIHwgYE5lZyAtPiBuZWcgaW50NjNcbiAgICAgIHwgYFBvcyAtPiBpbnQ2MylcbiAgOztcblxuICBsZXQgb2Zfc3RyaW5nIHN0ciA9XG4gICAgdHJ5IG9mX3N0cmluZ19yYXcgc3RyIHdpdGhcbiAgICB8IF8gLT4gaW52YWxpZF9zdHIgc3RyXG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZ19vcHQgc3RyID1cbiAgICBtYXRjaCBvZl9zdHJpbmdfcmF3IHN0ciB3aXRoXG4gICAgfCB0IC0+IFNvbWUgdFxuICAgIHwgZXhjZXB0aW9uIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCBic3dhcDE2IHQgPSB3cmFwX21vZHVsbyAoSW50NjQuYnN3YXAxNiAodW53cmFwIHQpKVxuICBsZXQgYnN3YXAzMiB0ID0gd3JhcF9tb2R1bG8gKEludDY0LmJzd2FwMzIgKHVud3JhcCB0KSlcbiAgbGV0IGJzd2FwNDggdCA9IHdyYXBfbW9kdWxvIChJbnQ2NC5ic3dhcDQ4ICh1bndyYXAgdCkpXG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBudW1fYml0cyA9IDYzXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBiaXRfbm90XG5sZXQgYml0X3hvciA9IGJpdF94b3JcbmxldCBiaXRfb3IgPSBiaXRfb3JcbmxldCBiaXRfYW5kID0gYml0X2FuZFxubGV0IHBvcGNvdW50ID0gcG9wY291bnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcG93ID0gcG93XG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWF4X3ZhbHVlID0gbWF4X3ZhbHVlXG5sZXQgbWluX3ZhbHVlID0gbWluX3ZhbHVlXG5sZXQgbWludXNfb25lID0gd3JhcF9leG4gU3RkbGliLkludDY0Lm1pbnVzX29uZVxubGV0IG9uZSA9IHdyYXBfZXhuIFN0ZGxpYi5JbnQ2NC5vbmVcbmxldCB6ZXJvID0gd3JhcF9leG4gU3RkbGliLkludDY0Lnplcm9cbmxldCBpc19wb3cyID0gaXNfcG93MlxubGV0IGZsb29yX3BvdzIgPSBmbG9vcl9wb3cyXG5sZXQgY2VpbF9wb3cyID0gY2VpbF9wb3cyXG5sZXQgZmxvb3JfbG9nMiA9IGZsb29yX2xvZzJcbmxldCBjZWlsX2xvZzIgPSBjZWlsX2xvZzJcbmxldCBjbHogPSBjbHpcbmxldCBjdHogPSBjdHpcbmxldCB0b19mbG9hdCB4ID0gU3RkbGliLkludDY0LnRvX2Zsb2F0ICh1bndyYXAgeClcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgeCA9IHdyYXBfbW9kdWxvIChTdGRsaWIuSW50NjQub2ZfZmxvYXQgeClcblxubGV0IG9mX2Zsb2F0IHQgPVxuICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgaWYgdCA+PSBmbG9hdF9sb3dlcl9ib3VuZCAmJiB0IDw9IGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gd3JhcF9tb2R1bG8gKFN0ZGxpYi5JbnQ2NC5vZl9mbG9hdCB0KVxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQ2My5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAoKVxuOztcblxubGV0IG9mX2ludDY0ID0gb2ZfaW50NjRcbmxldCBvZl9pbnQ2NF9leG4gPSBvZl9pbnQ2NF9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IG9mX2ludDY0X3RydW5jXG5sZXQgdG9faW50NjQgPSB0b19pbnQ2NFxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW46bWluXyB+bWF4Om1heF8gPSBtaW4gdCBtYXhfIHw+IG1heCBtaW5fXG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5cbigqIFdlIGNhbiByZXVzZSBjb252ZXJzaW9uIGZ1bmN0aW9uIGZyb20vdG8gaW50NjQgaGVyZS4gKilcbmxldCBvZl9pbnQgeCA9IHdyYXBfZXhuIChDb252LmludF90b19pbnQ2NCB4KVxubGV0IG9mX2ludF9leG4geCA9IG9mX2ludCB4XG5sZXQgdG9faW50IHggPSBDb252LmludDY0X3RvX2ludCAodW53cmFwIHgpXG5sZXQgdG9faW50X2V4biB4ID0gQ29udi5pbnQ2NF90b19pbnRfZXhuICh1bndyYXAgeClcbmxldCB0b19pbnRfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9faW50X3RydW5jICh1bndyYXAgeClcbmxldCBvZl9pbnQzMiB4ID0gd3JhcF9leG4gKENvbnYuaW50MzJfdG9faW50NjQgeClcbmxldCBvZl9pbnQzMl9leG4geCA9IG9mX2ludDMyIHhcbmxldCB0b19pbnQzMiB4ID0gQ29udi5pbnQ2NF90b19pbnQzMiAodW53cmFwIHgpXG5sZXQgdG9faW50MzJfZXhuIHggPSBDb252LmludDY0X3RvX2ludDMyX2V4biAodW53cmFwIHgpXG5sZXQgdG9faW50MzJfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9faW50MzJfdHJ1bmMgKHVud3JhcCB4KVxubGV0IG9mX25hdGl2ZWludCB4ID0gb2ZfaW50NjQgKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfbmF0aXZlaW50X2V4biB4ID0gd3JhcF9leG4gKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfbmF0aXZlaW50X3RydW5jIHggPSBvZl9pbnQ2NF90cnVuYyAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCB0b19uYXRpdmVpbnQgeCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50ICh1bndyYXAgeClcbmxldCB0b19uYXRpdmVpbnRfZXhuIHggPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG4gKHVud3JhcCB4KVxubGV0IHRvX25hdGl2ZWludF90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgKHVud3JhcCB4KVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZSAoVClcblxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2VfaGV4IChzdHJ1Y3RcbiAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoVC5jb21wYXJlX19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgVC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBuZWcgPSAoIH4tIClcbiAgbGV0ICggPCApID0gKCA8IClcblxuICBsZXQgdG9fc3RyaW5nIGkgPVxuICAgICgqIHRoZSB1c2Ugb2YgW3Vud3JhcF91bnNpZ25lZF0gaGVyZSBpcyBpbXBvcnRhbnQgZm9yIHRoZSBjYXNlIG9mIFttaW5fdmFsdWVdICopXG4gICAgUHJpbnRmLnNwcmludGYgXCIlTHhcIiAodW53cmFwX3Vuc2lnbmVkIGkpXG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZyBzID0gb2Zfc3RyaW5nIChcIjB4XCIgXiBzKVxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjMuSGV4XCJcbmVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRvX3N0cmluZyB4ID0gdG9fc3RyaW5nIHhcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDYzXCJcbmVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgbGV0IHJlbSA9IHJlbVxuICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgZW5kKVxuXG4gIGxldCAoIGxhbmQgKSA9IGJpdF9hbmRcbiAgbGV0ICggbG9yICkgPSBiaXRfb3JcbiAgbGV0ICggbHhvciApID0gYml0X3hvclxuICBsZXQgbG5vdCA9IGJpdF9ub3RcbiAgbGV0ICggbHNsICkgPSBzaGlmdF9sZWZ0XG4gIGxldCAoIGFzciApID0gc2hpZnRfcmlnaHRcbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5lbmRcblxuaW5jbHVkZSBPXG5cbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlX2JpbmFyeSAoc3RydWN0XG4gIHR5cGUgdCA9IFQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoVC5jb21wYXJlX19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGVxdWFsX19sb2NhbCA9IChULmVxdWFsX19sb2NhbCA6IHQgLT4gdCAtPiBib29sKVxuICBsZXQgZXF1YWwgPSAoZnVuIGEgYiAtPiBlcXVhbF9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIFQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBULmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCAoIGxhbmQgKSA9ICggbGFuZCApXG4gIGxldCAoIGxzciApID0gKCBsc3IgKVxuICBsZXQgY2x6ID0gY2x6XG4gIGxldCBudW1fYml0cyA9IG51bV9iaXRzXG4gIGxldCBvbmUgPSBvbmVcbiAgbGV0IHRvX2ludF9leG4gPSB0b19pbnRfZXhuXG4gIGxldCB6ZXJvID0gemVyb1xuZW5kKVxuXG4oKiBbSW50NjNdIGFuZCBbSW50NjMuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG5tb2R1bGUgUmVwciA9IHN0cnVjdFxuICB0eXBlIGVtdWxhdGVkID0gdFxuXG4gIHR5cGUgKCd1bmRlcmx5aW5nX3R5cGUsICdpbnRlcm1lZGlhdGVfdHlwZSkgdCA9XG4gICAgfCBJbnQgOiAoaW50LCBpbnQpIHRcbiAgICB8IEludDY0IDogKGludDY0LCBlbXVsYXRlZCkgdFxuZW5kXG5cbmxldCByZXByID0gUmVwci5JbnQ2NFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFN0ZGxpYi5JbnQzMlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQzMiBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9pbnQzMiA6IHQgLT4gdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDMyXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoaW50MzJfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50MzIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50MzJfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IGNvbXBhcmUgeCB5XG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nX29wdCA9IG9mX3N0cmluZ19vcHRcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5sZXQgbnVtX2JpdHMgPSAzMlxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfb2ZfYml0cyA9IGZsb2F0X29mX2JpdHNcbmxldCBiaXRzX29mX2Zsb2F0ID0gYml0c19vZl9mbG9hdFxubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGxvZ25vdFxubGV0IGJpdF94b3IgPSBsb2d4b3JcbmxldCBiaXRfb3IgPSBsb2dvclxubGV0IGJpdF9hbmQgPSBsb2dhbmRcbmxldCBtaW5fdmFsdWUgPSBtaW5faW50XG5sZXQgbWF4X3ZhbHVlID0gbWF4X2ludFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtaW51c19vbmUgPSBtaW51c19vbmVcbmxldCBvbmUgPSBvbmVcbmxldCB6ZXJvID0gemVyb1xubGV0IGNvbXBhcmUgPSBjb21wYXJlXG5sZXQgY29tcGFyZV9fbG9jYWwgPSBTdGRsaWIuY29tcGFyZVxubGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBvZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAgICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBvZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludDMyLm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbm1vZHVsZSBJbmZpeF9jb21wYXJlID0gc3RydWN0XG4gIG9wZW4gUG9seVxuXG4gIGxldCAoID49ICkgKHggOiB0KSB5ID0geCA+PSB5XG4gIGxldCAoIDw9ICkgKHggOiB0KSB5ID0geCA8PSB5XG4gIGxldCAoID0gKSAoeCA6IHQpIHkgPSB4ID0geVxuICBsZXQgKCA+ICkgKHggOiB0KSB5ID0geCA+IHlcbiAgbGV0ICggPCApICh4IDogdCkgeSA9IHggPCB5XG4gIGxldCAoIDw+ICkgKHggOiB0KSB5ID0geCA8PiB5XG5lbmRcblxubW9kdWxlIENvbXBhcmUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbmZpeF9jb21wYXJlXG5cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IGNvbXBhcmVfX2xvY2FsXG4gIGxldCBhc2NlbmRpbmcgPSBjb21wYXJlXG4gIGxldCBkZXNjZW5kaW5nIHggeSA9IGNvbXBhcmUgeSB4XG4gIGxldCBtaW4geCB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuICBsZXQgbWF4IHggeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IGVxdWFsICh4IDogdCkgeSA9IHggPSB5XG4gIGxldCBlcXVhbF9fbG9jYWwgKHggOiB0KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG4gIGxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluOm1pbl8gfm1heDptYXhfID0gbWluIHQgbWF4XyB8PiBtYXggbWluX1xuXG4gIGxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAgIGFzc2VydCAobWluIDw9IG1heCk7XG4gICAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG4gIDs7XG5cbiAgbGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgICBpZiBtaW4gPiBtYXhcbiAgICB0aGVuXG4gICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gICAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgQ29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0ICggLyApID0gZGl2XG5sZXQgKCAqICkgPSBtdWxcbmxldCAoIC0gKSA9IHN1YlxubGV0ICggKyApID0gYWRkXG5sZXQgKCB+LSApID0gbmVnXG5sZXQgaW5jciByID0gciA6PSAhciArIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gIXIgLSBvbmVcbmxldCBvZl9pbnQzMiB0ID0gdFxubGV0IG9mX2ludDMyX2V4biA9IG9mX2ludDMyXG5sZXQgdG9faW50MzIgdCA9IHRcbmxldCB0b19pbnQzMl9leG4gPSB0b19pbnQzMlxubGV0IHBvcGNvdW50ID0gUG9wY291bnQuaW50MzJfcG9wY291bnRcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcblxubGV0IG9mX2ludCA9IENvbnYuaW50X3RvX2ludDMyXG5sZXQgb2ZfaW50X2V4biA9IENvbnYuaW50X3RvX2ludDMyX2V4blxubGV0IG9mX2ludF90cnVuYyA9IENvbnYuaW50X3RvX2ludDMyX3RydW5jXG5sZXQgdG9faW50ID0gQ29udi5pbnQzMl90b19pbnRcbmxldCB0b19pbnRfZXhuID0gQ29udi5pbnQzMl90b19pbnRfZXhuXG5sZXQgdG9faW50X3RydW5jID0gQ29udi5pbnQzMl90b19pbnRfdHJ1bmNcbmxldCBvZl9pbnQ2NCA9IENvbnYuaW50NjRfdG9faW50MzJcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX2ludDMyX2V4blxubGV0IG9mX2ludDY0X3RydW5jID0gQ29udi5pbnQ2NF90b19pbnQzMl90cnVuY1xubGV0IHRvX2ludDY0ID0gQ29udi5pbnQzMl90b19pbnQ2NFxubGV0IG9mX25hdGl2ZWludCA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyXG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX2V4blxubGV0IG9mX25hdGl2ZWludF90cnVuYyA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX3RydW5jXG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnQzMl90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgcG93IGIgZSA9IG9mX2ludF9leG4gKEludF9tYXRoLlByaXZhdGUuaW50X3BvdyAodG9faW50X2V4biBiKSAodG9faW50X2V4biBlKSlcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5leHRlcm5hbCBic3dhcDMyIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWJzd2FwX2ludDMyXCJcblxubGV0IGJzd2FwMTYgeCA9IFN0ZGxpYi5JbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDMyIHgpIDE2XG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIEludDMyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IFN0ZGxpYi5JbnQzMi5sb2dvclxuICBsZXQgKCBsc3IgKSA9IFN0ZGxpYi5JbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IFN0ZGxpYi5JbnQzMi5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBTdGRsaWIuSW50MzIuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IFN0ZGxpYi5JbnQzMi5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIFN0ZGxpYi5JbnQzMi5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gU3RkbGliLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBTdGRsaWIuSW50MzIuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBTdGRsaWIuSW50MzIuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgU3RkbGliLkludDMyLnByZWQgeCA9IFN0ZGxpYi5JbnQzMi56ZXJvXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50MzIgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKGludDMyW0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50MzJfY2x6XCIgXCJCYXNlX2ludF9tYXRoX2ludDMyX2Nsel91bmJveGVkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChpbnQzMltAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDMyX2N0elwiIFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIGkgPD0gU3RkbGliLkludDMyLnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJbSW50MzIuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50MzIgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBpIDw9IFN0ZGxpYi5JbnQzMi56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludDMyLmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50MzIgaSBdKTtcbiAgICAoKiBUaGUgW2kgPSAxXSBjaGVjayBpcyBuZWVkZWQgYmVjYXVzZSBjbHooMCkgaXMgdW5kZWZpbmVkICopXG4gICAgaWYgU3RkbGliLkludDMyLmVxdWFsIGkgU3RkbGliLkludDMyLm9uZVxuICAgIHRoZW4gMFxuICAgIGVsc2UgbnVtX2JpdHMgLSBjbHogKFN0ZGxpYi5JbnQzMi5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZSAoVClcblxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2VfaGV4IChzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50MzIgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChjb21wYXJlX2ludDMyX19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDMyXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBuZWcgPSAoIH4tIClcbiAgbGV0ICggPCApID0gKCA8IClcbiAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlbHhcIiBpXG4gIGxldCBvZl9zdHJpbmcgcyA9IFN0ZGxpYi5TY2FuZi5zc2NhbmYgcyBcIiVseFwiIEZuLmlkXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQzMi5IZXhcIlxuZW5kKVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9iaW5hcnkgKHN0cnVjdFxuICB0eXBlIHQgPSBpbnQzMiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoY29tcGFyZV9pbnQzMl9fbG9jYWwgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBlcXVhbF9fbG9jYWwgPSAoZXF1YWxfaW50MzJfX2xvY2FsIDogdCAtPiB0IC0+IGJvb2wpXG4gIGxldCBlcXVhbCA9IChmdW4gYSBiIC0+IGVxdWFsX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDMyXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0ICggbGFuZCApID0gKCBsYW5kIClcbiAgbGV0ICggbHNyICkgPSAoIGxzciApXG4gIGxldCBjbHogPSBjbHpcbiAgbGV0IG51bV9iaXRzID0gbnVtX2JpdHNcbiAgbGV0IG9uZSA9IG9uZVxuICBsZXQgdG9faW50X2V4biA9IHRvX2ludF9leG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDMyXCJcbmVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKENvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGluY2x1ZGUgUHJlX09cblxuICAgIGxldCByZW0gPSByZW1cbiAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gIGVuZClcblxuICBsZXQgKCBsYW5kICkgPSBiaXRfYW5kXG4gIGxldCAoIGxvciApID0gYml0X29yXG4gIGxldCAoIGx4b3IgKSA9IGJpdF94b3JcbiAgbGV0IGxub3QgPSBiaXRfbm90XG4gIGxldCAoIGxzbCApID0gc2hpZnRfbGVmdFxuICBsZXQgKCBhc3IgKSA9IHNoaWZ0X3JpZ2h0XG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbFxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbSW50MzJdIGFuZCBbSW50MzIuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuIiwib3BlbiEgSW1wb3J0XG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgUmVwciA9IEludDYzX2VtdWwuUmVwclxuaW5jbHVkZSBTeXMwLk1ha2VfaW1tZWRpYXRlNjQgKEludCkgKEludDYzX2VtdWwpXG5cbm1vZHVsZSBCYWNrZW5kID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIGluY2x1ZGUgSW50X2ludGYuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgICB2YWwgdG9faW50IDogdCAtPiBpbnQgb3B0aW9uXG4gICAgdmFsIHRvX2ludF90cnVuYyA6IHQgLT4gaW50XG4gICAgdmFsIG9mX2ludDMyIDogaW50MzIgLT4gdFxuICAgIHZhbCB0b19pbnQzMiA6IHQgLT4gSW50MzIudCBvcHRpb25cbiAgICB2YWwgdG9faW50MzJfdHJ1bmMgOiB0IC0+IEludDMyLnRcbiAgICB2YWwgb2ZfaW50NjQgOiBJbnQ2NC50IC0+IHQgb3B0aW9uXG4gICAgdmFsIG9mX2ludDY0X3RydW5jIDogSW50NjQudCAtPiB0XG4gICAgdmFsIG9mX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiB0IG9wdGlvblxuICAgIHZhbCB0b19uYXRpdmVpbnQgOiB0IC0+IG5hdGl2ZWludCBvcHRpb25cbiAgICB2YWwgb2ZfbmF0aXZlaW50X3RydW5jIDogbmF0aXZlaW50IC0+IHRcbiAgICB2YWwgdG9fbmF0aXZlaW50X3RydW5jIDogdCAtPiBuYXRpdmVpbnRcbiAgICB2YWwgb2ZfZmxvYXRfdW5jaGVja2VkIDogZmxvYXQgLT4gdFxuICAgIHZhbCByZXByIDogKHQsIHQpIEludDYzX2VtdWwuUmVwci50XG4gICAgdmFsIGJzd2FwMTYgOiB0IC0+IHRcbiAgICB2YWwgYnN3YXAzMiA6IHQgLT4gdFxuICAgIHZhbCBic3dhcDQ4IDogdCAtPiB0XG4gIGVuZFxuICB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgbW9kdWxlIE5hdGl2ZSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgSW50XG5cbiAgICBsZXQgdG9faW50IHggPSBTb21lIHhcbiAgICBsZXQgdG9faW50X3RydW5jIHggPSB4XG5cbiAgICAoKiBbb2ZfaW50MzJfZXhuXSBpcyBhIHNhZmUgb3BlcmF0aW9uIG9uIHBsYXRmb3JtcyB3aXRoIDY0LWJpdCB3b3JkIHNpemVzLiAqKVxuICAgIGxldCBvZl9pbnQzMiA9IG9mX2ludDMyX2V4blxuICAgIGxldCB0b19uYXRpdmVpbnRfdHJ1bmMgeCA9IHRvX25hdGl2ZWludCB4XG4gICAgbGV0IHRvX25hdGl2ZWludCB4ID0gU29tZSAodG9fbmF0aXZlaW50IHgpXG4gICAgbGV0IHJlcHIgPSBJbnQ2M19lbXVsLlJlcHIuSW50XG4gICAgbGV0IGJzd2FwMzIgdCA9IEludDY0LnRvX2ludF90cnVuYyAoSW50NjQuYnN3YXAzMiAoSW50NjQub2ZfaW50IHQpKVxuICAgIGxldCBic3dhcDQ4IHQgPSBJbnQ2NC50b19pbnRfdHJ1bmMgKEludDY0LmJzd2FwNDggKEludDY0Lm9mX2ludCB0KSlcbiAgZW5kXG5cbiAgbGV0IGltcGwgOiAobW9kdWxlIFMpID1cbiAgICBtYXRjaCByZXByIHdpdGhcbiAgICB8IEltbWVkaWF0ZSAtPiAobW9kdWxlIE5hdGl2ZSA6IFMpXG4gICAgfCBOb25faW1tZWRpYXRlIC0+IChtb2R1bGUgSW50NjNfZW11bCA6IFMpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSAodmFsIEJhY2tlbmQuaW1wbCA6IEJhY2tlbmQuUylcblxubW9kdWxlIE92ZXJmbG93X2V4biA9IHN0cnVjdFxuICBsZXQgKCArICkgdCB1ID1cbiAgICBsZXQgc3VtID0gdCArIHUgaW5cbiAgICBpZiBiaXRfb3IgKGJpdF94b3IgdCB1KSAoYml0X3hvciB0IChiaXRfbm90IHN1bSkpIDwgemVyb1xuICAgIHRoZW4gc3VtXG4gICAgZWxzZVxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCArICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcInN1bVwiLCBzZXhwX29mX3Qgc3VtIF0pXG4gIDs7XG5cbiAgbGV0ICggLSApIHQgdSA9XG4gICAgbGV0IGRpZmYgPSB0IC0gdSBpblxuICAgIGxldCBwb3NfZGlmZiA9IHQgPiB1IGluXG4gICAgaWYgdCA8PiB1ICYmIEJvb2wuKCA8PiApIHBvc19kaWZmIChpc19wb3NpdGl2ZSBkaWZmKVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggLSApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJkaWZmXCIsIHNleHBfb2ZfdCBkaWZmIF0pXG4gICAgZWxzZSBkaWZmXG4gIDs7XG5cbiAgbGV0IG5lZ2F0aXZlX29uZSA9IG9mX2ludCAoLTEpXG4gIGxldCBkaXZfd291bGRfb3ZlcmZsb3cgdCB1ID0gdCA9IG1pbl92YWx1ZSAmJiB1ID0gbmVnYXRpdmVfb25lXG5cbiAgbGV0ICggKiApIHQgdSA9XG4gICAgbGV0IHByb2R1Y3QgPSB0ICogdSBpblxuICAgIGlmIHUgPD4gemVybyAmJiAoZGl2X3dvdWxkX292ZXJmbG93IHByb2R1Y3QgdSB8fCBwcm9kdWN0IC8gdSA8PiB0KVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggKiApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJwcm9kdWN0XCIsIHNleHBfb2ZfdCBwcm9kdWN0IF0pXG4gICAgZWxzZSBwcm9kdWN0XG4gIDs7XG5cbiAgbGV0ICggLyApIHQgdSA9XG4gICAgaWYgZGl2X3dvdWxkX292ZXJmbG93IHQgdVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggLyApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJwcm9kdWN0XCIsIHNleHBfb2ZfdCAodCAvIHUpIF0pXG4gICAgZWxzZSB0IC8gdVxuICA7O1xuXG4gIGxldCBhYnMgdCA9IGlmIHQgPSBtaW5fdmFsdWUgdGhlbiBmYWlsd2l0aCBcImFicyBvdmVyZmxvd1wiIGVsc2UgYWJzIHRcbiAgbGV0IG5lZyB0ID0gaWYgdCA9IG1pbl92YWx1ZSB0aGVuIGZhaWx3aXRoIFwibmVnIG92ZXJmbG93XCIgZWxzZSBuZWcgdFxuZW5kXG5cbmxldCAoKSA9IGFzc2VydCAoSW50LiggPSApIG51bV9iaXRzIDYzKVxuXG5sZXQgcmFuZG9tX29mX2ludCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGJvdW5kID1cbiAgb2ZfaW50IChSYW5kb20uU3RhdGUuaW50IHN0YXRlICh0b19pbnRfZXhuIGJvdW5kKSlcbjs7XG5cbmxldCByYW5kb21fb2ZfaW50NjQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBib3VuZCA9XG4gIG9mX2ludDY0X2V4biAoUmFuZG9tLlN0YXRlLmludDY0IHN0YXRlICh0b19pbnQ2NCBib3VuZCkpXG47O1xuXG5sZXQgcmFuZG9tID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IHJhbmRvbV9vZl9pbnRcbiAgfCBXMzIgLT4gcmFuZG9tX29mX2ludDY0XG47O1xuXG5sZXQgcmFuZG9tX2luY2xfb2ZfaW50ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbG8gaGkgPVxuICBvZl9pbnQgKFJhbmRvbS5TdGF0ZS5pbnRfaW5jbCBzdGF0ZSAodG9faW50X2V4biBsbykgKHRvX2ludF9leG4gaGkpKVxuOztcblxubGV0IHJhbmRvbV9pbmNsX29mX2ludDY0ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbG8gaGkgPVxuICBvZl9pbnQ2NF9leG4gKFJhbmRvbS5TdGF0ZS5pbnQ2NF9pbmNsIHN0YXRlICh0b19pbnQ2NCBsbykgKHRvX2ludDY0IGhpKSlcbjs7XG5cbmxldCByYW5kb21faW5jbCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiByYW5kb21faW5jbF9vZl9pbnRcbiAgfCBXMzIgLT4gcmFuZG9tX2luY2xfb2ZfaW50NjRcbjs7XG5cbmxldCBmbG9vcl9sb2cyIHQgPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gdCB8PiB0b19pbnRfZXhuIHw+IEludC5mbG9vcl9sb2cyXG4gIHwgVzMyIC0+XG4gICAgaWYgdCA8PSB6ZXJvXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX3QgdCBdKTtcbiAgICBsZXQgZmxvb3JfbG9nMiA9IHJlZiAoSW50LiggLSApIG51bV9iaXRzIDIpIGluXG4gICAgd2hpbGUgZXF1YWwgemVybyAoYml0X2FuZCB0IChzaGlmdF9sZWZ0IG9uZSAhZmxvb3JfbG9nMikpIGRvXG4gICAgICBmbG9vcl9sb2cyIDo9IEludC4oIC0gKSAhZmxvb3JfbG9nMiAxXG4gICAgZG9uZTtcbiAgICAhZmxvb3JfbG9nMlxuOztcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFJlcHIgPSBSZXByXG5cbiAgbGV0IHJlcHIgPSByZXByXG5cbiAgbW9kdWxlIEVtdWwgPSBJbnQ2M19lbXVsXG5lbmRcbiIsIigqKiBJbnRlcmZhY2VzIGZvciBtdXRhYmxlIGRpY3Rpb25hcnkgdHlwZXMsIHN1Y2ggYXMgW0hhc2h0YmwudF0uXG5cbiAgICBXZSBkZWZpbmUgc2VwYXJhdGUgaW50ZXJmYWNlcyBmb3IgW0FjY2Vzc29yc10gYW5kIFtDcmVhdG9yc10sIGFsb25nIHdpdGggW1NdIGNvbWJpbmluZ1xuICAgIGJvdGguIFRoZXNlIGludGVyZmFjZXMgYXJlIHdyaXR0ZW4gb25jZSBpbiB0aGVpciBtb3N0IGdlbmVyYWwgZm9ybSwgd2hpY2ggaW52b2x2ZXNcbiAgICBleHRyYSB0eXBlIGRlZmluaXRpb25zIGFuZCB0eXBlIHBhcmFtZXRlcnMgdGhhdCBtb3N0IGluc3RhbmNlcyBkbyBub3QgbmVlZC5cblxuICAgIFdlIHRoZW4gcHJvdmlkZSBpbnN0YW50aWF0aW9ucyBvZiB0aGVzZSBpbnRlcmZhY2VzIHdpdGggMSwgMiwgYW5kIDMgdHlwZSBwYXJhbWV0ZXJzXG4gICAgZm9yIFt0XS4gVGhlc2UgY292ZXIgbW9yZSBjb21tb24gdXNhZ2UgcGF0dGVybnMgZm9yIHRoZSBpbnRlcmZhY2VzLiAqKVxuXG5vcGVuISBJbXBvcnRcblxuKCoqIFRoZXNlIGRlZmluaXRpb25zIGFyZSByZS1leHBvcnRlZCBieSBbRGljdGlvbmFyeV9tdXRhYmxlXS4gKilcbm1vZHVsZSBEZWZpbml0aW9ucyA9IHN0cnVjdFxuICAoKiogQGNhbm9uaWNhbCBCYXNlLkRpY3Rpb25hcnlfbXV0YWJsZS5NZXJnZV9pbnRvX2FjdGlvbiAqKVxuICBtb2R1bGUgTWVyZ2VfaW50b19hY3Rpb24gPSBzdHJ1Y3RcbiAgICB0eXBlICdkYXRhIHQgPVxuICAgICAgfCBSZW1vdmVcbiAgICAgIHwgU2V0X3RvIG9mICdkYXRhXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29ycyA9IHNpZ1xuICAgICgqKiBUaGUgdHlwZSBvZiBrZXlzLiBUaGlzIHdpbGwgYmUgWydrZXldIGZvciBwb2x5bW9ycGhpYyBkaWN0aW9uYXJpZXMsIG9yIHNvbWUgZml4ZWRcbiAgICAgICAgdHlwZSBmb3IgZGljdGlvbmFyaWVzIHdpdGggbW9ub21vcnBoaWMga2V5cy4gKilcbiAgICB0eXBlICdrZXkga2V5XG5cbiAgICAoKiogRGljdGlvbmFyaWVzLiBUaGVpciBrZXlzIGhhdmUgdHlwZSBbJ2tleSBrZXldLiBFYWNoIGtleSdzIGFzc29jaWF0ZWQgdmFsdWUgaGFzXG4gICAgICAgIHR5cGUgWydkYXRhXS4gVGhlIGRpY3Rpb25hcnkgbWF5IGJlIGRpc3Rpbmd1aXNoZWQgYnkgYSBbJ3BoYW50b21dIHR5cGUuICopXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG5cbiAgICAoKiogVGhlIHR5cGUgb2YgYWNjZXNzb3IgZnVuY3Rpb25zIFsnZm5dIHRoYXQgb3BlcmF0ZSBvbiBbKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdF0uXG4gICAgICAgIE1heSB0YWtlIGV4dHJhIGFyZ3VtZW50cyBiZWZvcmUgWydmbl0sIHN1Y2ggYXMgYSBjb21wYXJpc29uIGZ1bmN0aW9uLiAqKVxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuXG4gICAgKCoqIFdoZXRoZXIgdGhlIGRpY3Rpb25hcnkgaXMgZW1wdHkuICopXG4gICAgdmFsIGlzX2VtcHR5IDogKF8sIF8sICdwaGFudG9tKSB0IC0+IGJvb2xcblxuICAgICgqKiBIb3cgbWFueSBrZXkvdmFsdWUgcGFpcnMgdGhlIGRpY3Rpb25hcnkgY29udGFpbnMuICopXG4gICAgdmFsIGxlbmd0aCA6IChfLCBfLCAncGhhbnRvbSkgdCAtPiBpbnRcblxuICAgICgqKiBBbGwga2V5L3ZhbHVlIHBhaXJzLiAqKVxuICAgIHZhbCB0b19hbGlzdCA6ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gKCdrZXkga2V5ICogJ2RhdGEpIGxpc3RcblxuICAgICgqKiBBbGwga2V5cyBpbiB0aGUgZGljdGlvbmFyeSwgaW4gdGhlIHNhbWUgb3JkZXIgYXMgW3RvX2FsaXN0XS4gKilcbiAgICB2YWwga2V5cyA6ICgna2V5LCBfLCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSBsaXN0XG5cbiAgICAoKiogQWxsIHZhbHVlcyBpbiB0aGUgZGljdGlvbmFyeSwgaW4gdGhlIHNhbWUgb3JkZXIgYXMgW3RvX2FsaXN0XS4gKilcbiAgICB2YWwgZGF0YSA6IChfLCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gJ2RhdGEgbGlzdFxuXG4gICAgKCoqIFJlbW92ZXMgYWxsIGtleS92YWx1ZSBwYWlycyBmcm9tIHRoZSBkaWN0aW9uYXJ5LiAqKVxuICAgIHZhbCBjbGVhciA6IChfLCBfLCAncGhhbnRvbSkgdCAtPiB1bml0XG5cbiAgICAoKiogQSBuZXcgZGljdGlvbmFyeSBjb250YWluaW5nIHRoZSBzYW1lIGtleS92YWx1ZSBwYWlycy4gKilcbiAgICB2YWwgY29weSA6ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIFdoZXRoZXIgW2tleV0gaGFzIGEgdmFsdWUuICopXG4gICAgdmFsIG1lbVxuICAgICAgOiAoKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiBib29sLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG5cbiAgICAoKiogUHJvZHVjZXMgdGhlIGN1cnJlbnQgdmFsdWUsIG9yIGFic2VuY2UgdGhlcmVvZiwgZm9yIGEgZ2l2ZW4ga2V5LiAqKVxuICAgIHZhbCBmaW5kXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiAnZGF0YSBvcHRpb25cbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogTGlrZSBbZmluZF0uIFJhaXNlcyBpZiB0aGVyZSBpcyBubyB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleS4gKilcbiAgICB2YWwgZmluZF9leG5cbiAgICAgIDogKCgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gJ2RhdGEsICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcblxuICAgICgqKiBMaWtlIFtmaW5kXS4gQWRkcyB0aGUgdmFsdWUgW2RlZmF1bHQgKCldIGlmIG5vbmUgZXhpc3RzLCB0aGVuIHJldHVybnMgaXQuICopXG4gICAgdmFsIGZpbmRfb3JfYWRkXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiBkZWZhdWx0Oih1bml0IC0+ICdkYXRhKSAtPiAnZGF0YVxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBMaWtlIFtmaW5kXS4gQWRkcyBbZGVmYXVsdCBrZXldIGlmIG5vIHZhbHVlIGV4aXN0cy4gKilcbiAgICB2YWwgZmluZGlfb3JfYWRkXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiBkZWZhdWx0Oigna2V5IGtleSAtPiAnZGF0YSkgLT4gJ2RhdGFcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogTGlrZSBbZmluZF0uIENhbGxzIFtpZl9mb3VuZCBkYXRhXSBpZiBhIHZhbHVlIGV4aXN0cywgb3IgW2lmX25vdF9mb3VuZCBrZXldXG4gICAgICAgIG90aGVyd2lzZS4gQXZvaWRzIGFsbG9jYXRpb24gW1NvbWVdLiAqKVxuICAgIHZhbCBmaW5kX2FuZF9jYWxsXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+ICdrZXkga2V5XG4gICAgICAgICAgLT4gaWZfZm91bmQ6KCdkYXRhIC0+ICdjKVxuICAgICAgICAgIC0+IGlmX25vdF9mb3VuZDooJ2tleSBrZXkgLT4gJ2MpXG4gICAgICAgICAgLT4gJ2NcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogTGlrZSBbZmluZGldLiBDYWxscyBbaWZfZm91bmQgfmtleSB+ZGF0YV0gaWYgYSB2YWx1ZSBleGlzdHMuICopXG4gICAgdmFsIGZpbmRpX2FuZF9jYWxsXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+ICdrZXkga2V5XG4gICAgICAgICAgLT4gaWZfZm91bmQ6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+ICdjKVxuICAgICAgICAgIC0+IGlmX25vdF9mb3VuZDooJ2tleSBrZXkgLT4gJ2MpXG4gICAgICAgICAgLT4gJ2NcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogTGlrZSBbZmluZF0uIFJlbW92ZXMgdGhlIHZhbHVlIGZvciBba2V5XSwgaWYgYW55LCBmcm9tIHRoZSBkaWN0aW9uYXJ5IGJlZm9yZVxuICAgICAgICByZXR1cm5pbmcgaXQuICopXG4gICAgdmFsIGZpbmRfYW5kX3JlbW92ZVxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gJ2RhdGEgb3B0aW9uXG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIEFkZHMgYSBrZXkvdmFsdWUgcGFpciBmb3IgYSBrZXkgdGhlIGRpY3Rpb25hcnkgZG9lcyBub3QgY29udGFpbiwgb3IgcmVwb3J0cyBhXG4gICAgICAgIGR1cGxpY2F0ZS4gKilcbiAgICB2YWwgYWRkXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiBrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiBbIGBPayB8IGBEdXBsaWNhdGUgXVxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBMaWtlIFthZGRdLiBSYWlzZXMgb24gZHVwbGljYXRlcy4gKilcbiAgICB2YWwgYWRkX2V4blxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4ga2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gdW5pdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBBZGRzIG9yIHJlcGxhY2VzIGEga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIGRpY3Rpb25hcnkuICopXG4gICAgdmFsIHNldFxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4ga2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gdW5pdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBSZW1vdmVzIGFueSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleS4gKilcbiAgICB2YWwgcmVtb3ZlXG4gICAgICA6ICgoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+IHVuaXQsICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcblxuICAgICgqKiBBZGRzLCByZXBsYWNlcywgb3IgcmVtb3ZlcyB0aGUgdmFsdWUgZm9yIGEgZ2l2ZW4ga2V5LCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnRcbiAgICAgICAgdmFsdWUgb3IgbGFjayB0aGVyZW9mLiAqKVxuICAgIHZhbCBjaGFuZ2VcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+IGY6KCdkYXRhIG9wdGlvbiAtPiAnZGF0YSBvcHRpb24pIC0+IHVuaXRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogQWRkcyBvciByZXBsYWNlcyB0aGUgdmFsdWUgZm9yIGEgZ2l2ZW4ga2V5LCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgdmFsdWUgb3JcbiAgICAgICAgbGFjayB0aGVyZW9mLiAqKVxuICAgIHZhbCB1cGRhdGVcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+IGY6KCdkYXRhIG9wdGlvbiAtPiAnZGF0YSkgLT4gdW5pdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBMaWtlIFt1cGRhdGVdLiBSZXR1cm5zIHRoZSBuZXcgdmFsdWUuICopXG4gICAgdmFsIHVwZGF0ZV9hbmRfcmV0dXJuXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiAna2V5IGtleVxuICAgICAgLT4gZjooJ2RhdGEgb3B0aW9uIC0+ICdkYXRhKVxuICAgICAgLT4gJ2RhdGFcblxuICAgICgqKiBBZGRzIFtieV0gdG8gdGhlIHZhbHVlIGZvciBba2V5XSwgZGVmYXVsdCAwIGlmIFtrZXldIGlzIGFic2VudC4gTWF5IHJlbW92ZSBba2V5XVxuICAgICAgICBpZiB0aGUgcmVzdWx0IGlzIFswXSwgZGVwZW5kaW5nIG9uIFtyZW1vdmVfaWZfemVyb10uICopXG4gICAgdmFsIGluY3JcbiAgICAgIDogKCA/Ynk6aW50ICgqKiBkZWZhdWx0OiAxICopXG4gICAgICAgICAgLT4gP3JlbW92ZV9pZl96ZXJvOmJvb2wgKCoqIGRlZmF1bHQ6IGZhbHNlICopXG4gICAgICAgICAgLT4gKCdrZXksIGludCwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiAna2V5IGtleVxuICAgICAgICAgIC0+IHVuaXRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogU3VidHJhY3RzIFtieV0gZnJvbSB0aGUgdmFsdWUgZm9yIFtrZXldLCBkZWZhdWx0IDAgaWYgW2tleV0gaXMgYWJzZW50LiBNYXkgcmVtb3ZlXG4gICAgICAgIFtrZXldIGlmIHRoZSByZXN1bHQgaXMgWzBdLCBkZXBlbmRpbmcgb24gW3JlbW92ZV9pZl96ZXJvXS4gKilcbiAgICB2YWwgZGVjclxuICAgICAgOiAoID9ieTppbnQgKCoqIGRlZmF1bHQ6IDEgKilcbiAgICAgICAgICAtPiA/cmVtb3ZlX2lmX3plcm86Ym9vbCAoKiogZGVmYXVsdDogZmFsc2UgKilcbiAgICAgICAgICAtPiAoJ2tleSwgaW50LCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+ICdrZXkga2V5XG4gICAgICAgICAgLT4gdW5pdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBBZGRzIFtkYXRhXSB0byB0aGUgZXhpc3Rpbmcga2V5L3ZhbHVlIHBhaXIgZm9yIFtrZXldLiBJbnRlcnByZXRzIGEgbWlzc2luZyBrZXkgYXNcbiAgICAgICAgaGF2aW5nIGFuIGVtcHR5IGxpc3QuICopXG4gICAgdmFsIGFkZF9tdWx0aVxuICAgICAgOiAoICgna2V5LCAnZGF0YSBsaXN0LCAncGhhbnRvbSkgdCAtPiBrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiB1bml0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIFJlbW92ZXMgb25lIGVsZW1lbnQgZnJvbSB0aGUgZXhpc3Rpbmcga2V5L3ZhbHVlIHBhaXIgZm9yIFtrZXldLiBSZW1vdmVzIHRoZSBrZXlcbiAgICAgICAgZW50aXJlbHkgaWYgdGhlIG5ldyBsaXN0IGlzIGVtcHR5LiAqKVxuICAgIHZhbCByZW1vdmVfbXVsdGlcbiAgICAgIDogKCgna2V5LCBfIGxpc3QsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+IHVuaXQsICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcblxuICAgICgqKiBQcm9kdWNlcyB0aGUgbGlzdCBhc3NvY2lhdGVkIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcga2V5LiBJbnRlcnByZXRzIGEgbWlzc2luZ1xuICAgICAgICBrZXkgYXMgaGF2aW5nIGFuIGVtcHR5IGxpc3QuICopXG4gICAgdmFsIGZpbmRfbXVsdGlcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEgbGlzdCwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gJ2RhdGEgbGlzdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBDb21iaW5lcyBldmVyeSB2YWx1ZSBpbiB0aGUgZGljdGlvbmFyeS4gKilcbiAgICB2YWwgZm9sZFxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiAnYWNjIC0+ICdhY2MpXG4gICAgICAtPiAnYWNjXG5cbiAgICAoKiogV2hldGhlciBldmVyeSB2YWx1ZSBzYXRpc2ZpZXMgW2ZdLiAqKVxuICAgIHZhbCBmb3JfYWxsIDogKF8sICdkYXRhLCAncGhhbnRvbSkgdCAtPiBmOignZGF0YSAtPiBib29sKSAtPiBib29sXG5cbiAgICAoKiogTGlrZSBbZm9yX2FsbF0uIFRoZSBwcmVkaWNhdGUgbWF5IGFsc28gZGVwZW5kIG9uIHRoZSBhc3NvY2lhdGVkIGtleS4gKilcbiAgICB2YWwgZm9yX2FsbGlcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+IGJvb2wpXG4gICAgICAtPiBib29sXG5cbiAgICAoKiogV2hldGhlciBhdCBsZWFzdCBvbmUgdmFsdWUgc2F0aXNmaWVzIFtmXS4gKilcbiAgICB2YWwgZXhpc3RzIDogKF8sICdkYXRhLCAncGhhbnRvbSkgdCAtPiBmOignZGF0YSAtPiBib29sKSAtPiBib29sXG5cbiAgICAoKiogTGlrZSBbZXhpc3RzXS4gVGhlIHByZWRpY2F0ZSBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBleGlzdHNpXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiBib29sKVxuICAgICAgLT4gYm9vbFxuXG4gICAgKCoqIEhvdyBtYW55IHZhbHVlcyBzYXRpc2Z5IFtmXS4gKilcbiAgICB2YWwgY291bnQgOiAoXywgJ2RhdGEsICdwaGFudG9tKSB0IC0+IGY6KCdkYXRhIC0+IGJvb2wpIC0+IGludFxuXG4gICAgKCoqIExpa2UgW2NvdW50XS4gVGhlIHByZWRpY2F0ZSBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBjb3VudGlcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+IGJvb2wpXG4gICAgICAtPiBpbnRcblxuICAgICgqKiBBcmJpdHJhcnksIGRldGVybWluaXN0aWMga2V5L3ZhbHVlIHBhaXIgaWYgbm9uLWVtcHR5LiAqKVxuICAgIHZhbCBjaG9vc2UgOiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICgna2V5IGtleSAqICdkYXRhKSBvcHRpb25cblxuICAgICgqKiBMaWtlIFtjaG9vc2VdLiBSYWlzZXMgaWYgZW1wdHkuICopXG4gICAgdmFsIGNob29zZV9leG4gOiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5ICogJ2RhdGFcblxuICAgICgqKiBBcmJpdHJhcnksIHBzZXVkby1yYW5kb20ga2V5L3ZhbHVlIHBhaXIgaWYgbm9uLWVtcHR5LiAqKVxuICAgIHZhbCBjaG9vc2VfcmFuZG9tbHlcbiAgICAgIDogID9yYW5kb21fc3RhdGU6UmFuZG9tLlN0YXRlLnRcbiAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+ICgna2V5IGtleSAqICdkYXRhKSBvcHRpb25cblxuICAgICgqKiBMaWtlIFtjaG9vc2VfcmFuZG9tbHldLiBSYWlzZXMgaWYgZW1wdHkuICopXG4gICAgdmFsIGNob29zZV9yYW5kb21seV9leG5cbiAgICAgIDogID9yYW5kb21fc3RhdGU6UmFuZG9tLlN0YXRlLnRcbiAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+ICdrZXkga2V5ICogJ2RhdGFcblxuICAgICgqKiBDYWxscyBbZl0gZm9yIGV2ZXJ5IGtleS4gKilcbiAgICB2YWwgaXRlcl9rZXlzIDogKCdrZXksIF8sICdwaGFudG9tKSB0IC0+IGY6KCdrZXkga2V5IC0+IHVuaXQpIC0+IHVuaXRcblxuICAgICgqKiBDYWxscyBbZl0gZm9yIGV2ZXJ5IHZhbHVlLiAqKVxuICAgIHZhbCBpdGVyIDogKF8sICdkYXRhLCAncGhhbnRvbSkgdCAtPiBmOignZGF0YSAtPiB1bml0KSAtPiB1bml0XG5cbiAgICAoKiogQ2FsbHMgW2ZdIGZvciBldmVyeSBrZXkvdmFsdWUgcGFpci4gKilcbiAgICB2YWwgaXRlcmlcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+IHVuaXQpXG4gICAgICAtPiB1bml0XG5cbiAgICAoKiogVHJhbnNmb3JtcyBldmVyeSB2YWx1ZS4gKilcbiAgICB2YWwgbWFwIDogKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiBmOignZGF0YSAtPiAnYykgLT4gKCdrZXksICdjLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIExpa2UgW21hcF0uIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBtYXBpXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiAnYylcbiAgICAgIC0+ICgna2V5LCAnYywgJ3BoYW50b20pIHRcblxuICAgICgqKiBMaWtlIFttYXBdLiBNb2RpZmllcyB0aGUgaW5wdXQuICopXG4gICAgdmFsIG1hcF9pbnBsYWNlIDogKF8sICdkYXRhLCAncGhhbnRvbSkgdCAtPiBmOignZGF0YSAtPiAnZGF0YSkgLT4gdW5pdFxuXG4gICAgKCoqIExpa2UgW21hcGldLiBNb2RpZmllcyB0aGUgaW5wdXQuICopXG4gICAgdmFsIG1hcGlfaW5wbGFjZVxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gJ2RhdGEpXG4gICAgICAtPiB1bml0XG5cbiAgICAoKiogUHJvZHVjZXMgb25seSB0aG9zZSBrZXkvdmFsdWUgcGFpcnMgd2hvc2Uga2V5IHNhdGlzZmllcyBbZl0uICopXG4gICAgdmFsIGZpbHRlcl9rZXlzXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOigna2V5IGtleSAtPiBib29sKVxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIFByb2R1Y2VzIG9ubHkgdGhvc2Uga2V5L3ZhbHVlIHBhaXJzIHdob3NlIHZhbHVlIHNhdGlzZmllcyBbZl0uICopXG4gICAgdmFsIGZpbHRlclxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooJ2RhdGEgLT4gYm9vbClcbiAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcblxuICAgICgqKiBQcm9kdWNlcyBvbmx5IHRob3NlIGtleS92YWx1ZSBwYWlycyB3aGljaCBzYXRpc2Z5IFtmXS4gKilcbiAgICB2YWwgZmlsdGVyaVxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gYm9vbClcbiAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcblxuICAgICgqKiBMaWtlIFtmaWx0ZXJfa2V5c10uIE1vZGlmaWVzIHRoZSBpbnB1dC4gKilcbiAgICB2YWwgZmlsdGVyX2tleXNfaW5wbGFjZSA6ICgna2V5LCBfLCAncGhhbnRvbSkgdCAtPiBmOigna2V5IGtleSAtPiBib29sKSAtPiB1bml0XG5cbiAgICAoKiogTGlrZSBbZmlsdGVyXS4gTW9kaWZpZXMgdGhlIGlucHV0LiAqKVxuICAgIHZhbCBmaWx0ZXJfaW5wbGFjZSA6IChfLCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gZjooJ2RhdGEgLT4gYm9vbCkgLT4gdW5pdFxuXG4gICAgKCoqIExpa2UgW2ZpbHRlcmldLiBNb2RpZmllcyB0aGUgaW5wdXQuICopXG4gICAgdmFsIGZpbHRlcmlfaW5wbGFjZVxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gYm9vbClcbiAgICAgIC0+IHVuaXRcblxuICAgICgqKiBQcm9kdWNlcyBrZXkvdmFsdWUgcGFpcnMgZm9yIHdoaWNoIFtmXSBwcm9kdWNlcyBbU29tZV0uICopXG4gICAgdmFsIGZpbHRlcl9tYXBcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KCdkYXRhIC0+ICdjIG9wdGlvbilcbiAgICAgIC0+ICgna2V5LCAnYywgJ3BoYW50b20pIHRcblxuICAgICgqKiBMaWtlIFtmaWx0ZXJfbWFwXS4gVGhlIG5ldyB2YWx1ZSBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBmaWx0ZXJfbWFwaVxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gJ2Mgb3B0aW9uKVxuICAgICAgLT4gKCdrZXksICdjLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIExpa2UgW2ZpbHRlcl9tYXBdLiBNb2RpZmllcyB0aGUgaW5wdXQuICopXG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZSA6IChfLCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gZjooJ2RhdGEgLT4gJ2RhdGEgb3B0aW9uKSAtPiB1bml0XG5cbiAgICAoKiogTGlrZSBbZmlsdGVyX21hcGldLiBNb2RpZmllcyB0aGUgaW5wdXQuICopXG4gICAgdmFsIGZpbHRlcl9tYXBpX2lucGxhY2VcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+ICdkYXRhIG9wdGlvbilcbiAgICAgIC0+IHVuaXRcblxuICAgICgqKiBTcGxpdHMgb25lIGRpY3Rpb25hcnkgaW50byB0d28uIFRoZSBmaXJzdCBjb250YWlucyBrZXkvdmFsdWUgcGFpcnMgZm9yIHdoaWNoIHRoZVxuICAgICAgICB2YWx1ZSBzYXRpc2ZpZXMgW2ZdLiBUaGUgc2Vjb25kIGNvbnRhaW5zIHRoZSByZW1haW5kZXIuICopXG4gICAgdmFsIHBhcnRpdGlvbl90ZlxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooJ2RhdGEgLT4gYm9vbClcbiAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgKiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG5cbiAgICAoKiogTGlrZSBbcGFydGl0aW9uX3RmXS4gVGhlIHByZWRpY2F0ZSBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiBib29sKVxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAqICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcblxuICAgICgqKiBTcGxpdHMgb25lIGRpY3Rpb25hcnkgaW50byB0d28sIGNvcnJlc3BvbmRpbmcgcmVzcGVjdGl2ZWx5IHRvIFtGaXJzdCBfXSBhbmRcbiAgICAgICAgW1NlY29uZCBfXSByZXN1bHRzIGZyb20gW2ZdLiAqKVxuICAgIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOignZGF0YSAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAgIC0+ICgna2V5LCAnYywgJ3BoYW50b20pIHQgKiAoJ2tleSwgJ2QsICdwaGFudG9tKSB0XG5cbiAgICAoKiogTGlrZSBbcGFydGl0aW9uX21hcF0uIFRoZSBzcGxpdCBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgICAtPiAoJ2tleSwgJ2MsICdwaGFudG9tKSB0ICogKCdrZXksICdkLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIE1lcmdlcyB0d28gZGljdGlvbmFyaWVzIGJ5IGZ1bGx5IHRyYXZlcnNpbmcgYm90aC4gTm90IHN1aXRhYmxlIGZvciBlZmZpY2llbnRseVxuICAgICAgICBtZXJnaW5nIGxpc3RzIG9mIGRpY3Rpb25hcmllcy4gU2VlIFttZXJnZV9pbnRvXSBpbnN0ZWFkLiAqKVxuICAgIHZhbCBtZXJnZVxuICAgICAgOiAoICgna2V5LCAnZGF0YTEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhMiwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiBmOlxuICAgICAgICAgICAgICAgKGtleTona2V5IGtleVxuICAgICAgICAgICAgICAgIC0+IFsgYExlZnQgb2YgJ2RhdGExIHwgYFJpZ2h0IG9mICdkYXRhMiB8IGBCb3RoIG9mICdkYXRhMSAqICdkYXRhMiBdXG4gICAgICAgICAgICAgICAgLT4gJ2RhdGEzIG9wdGlvbilcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEzLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YTNcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogTWVyZ2VzIHR3byBkaWN0aW9uYXJpZXMgYnkgdHJhdmVyc2luZyBbc3JjXSBhbmQgYWRkaW5nIHRvIFtkc3RdLiBDb21wdXRlcyB0aGVcbiAgICAgICAgZWZmZWN0IG9uIFtkc3RdIG9mIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gW3NyY10gdXNpbmcgW2ZdLiAqKVxuICAgIHZhbCBtZXJnZV9pbnRvXG4gICAgICA6ICggc3JjOigna2V5LCAnZGF0YTEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gZHN0Oigna2V5LCAnZGF0YTIsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+ICdkYXRhMSAtPiAnZGF0YTIgb3B0aW9uIC0+ICdkYXRhMiBNZXJnZV9pbnRvX2FjdGlvbi50KVxuICAgICAgICAgIC0+IHVuaXRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczEgPSBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgJ2RhdGEgdFxuXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzXG4gICAgICAgIHdpdGggdHlwZSAoXywgJ2RhdGEsIF8pIHQgOj0gJ2RhdGEgdFxuICAgICAgICAgYW5kIHR5cGUgXyBrZXkgOj0ga2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCBfLCBfLCBfKSBhY2Nlc3NvciA6PSAnZm5cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IHNpZ1xuICAgIHR5cGUgKCdrZXksICdkYXRhKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSkgYWNjZXNzb3JcblxuICAgIGluY2x1ZGVcbiAgICAgIEFjY2Vzc29yc1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCBfKSB0IDo9ICgna2V5LCAnZGF0YSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsIF8pIGFjY2Vzc29yIDo9ICgnZm4sICdrZXksICdkYXRhKSBhY2Nlc3NvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMzID0gc2lnXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG5cbiAgICBpbmNsdWRlXG4gICAgICBBY2Nlc3NvcnNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgOj0gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMgPSBzaWdcbiAgICAoKiogVGhlIHR5cGUgb2Yga2V5cy4gVGhpcyB3aWxsIGJlIFsna2V5XSBmb3IgcG9seW1vcnBoaWMgZGljdGlvbmFyaWVzLCBvciBzb21lIGZpeGVkXG4gICAgICAgIHR5cGUgZm9yIGRpY3Rpb25hcmllcyB3aXRoIG1vbm9tb3JwaGljIGtleXMuICopXG4gICAgdHlwZSAna2V5IGtleVxuXG4gICAgKCoqIERpY3Rpb25hcmllcy4gVGhlaXIga2V5cyBoYXZlIHR5cGUgWydrZXkga2V5XS4gRWFjaCBrZXkncyBhc3NvY2lhdGVkIHZhbHVlIGhhc1xuICAgICAgICB0eXBlIFsnZGF0YV0uIFRoZSBkaWN0aW9uYXJ5IG1heSBiZSBkaXN0aW5ndWlzaGVkIGJ5IGEgWydwaGFudG9tXSB0eXBlLiAqKVxuICAgIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIFRoZSB0eXBlIG9mIGNyZWF0b3IgZnVuY3Rpb25zIFsnZm5dIHRoYXQgb3BlcmF0ZSBvbiBbKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdF0uXG4gICAgICAgIE1heSB0YWtlIGV4dHJhIGFyZ3VtZW50cyBiZWZvcmUgWydmbl0sIHN1Y2ggYXMgYSBjb21wYXJpc29uIGZ1bmN0aW9uLiAqKVxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG5cbiAgICAoKiogQ3JlYXRlcyBhIG5ldyBlbXB0eSBkaWN0aW9uYXJ5LiAqKVxuICAgIHZhbCBjcmVhdGUgOiAodW5pdCAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0LCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGNyZWF0b3JcblxuICAgICgqKiBEaWN0aW9uYXJ5IGNvbnRhaW5pbmcgdGhlIGdpdmVuIGtleS92YWx1ZSBwYWlycy4gRmFpbHMgaWYgdGhlcmUgYXJlIGR1cGxpY2F0ZVxuICAgICAgICBrZXlzLiAqKVxuICAgIHZhbCBvZl9hbGlzdFxuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBsaXN0XG4gICAgICAgICAgLT4gWyBgT2sgb2YgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrZXkga2V5IF1cbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF0uIE9uIGZhaWx1cmUsIHByb3ZpZGVzIGFsbCBkdXBsaWNhdGUga2V5cyBpbnN0ZWFkIG9mIGEgc2luZ2xlXG4gICAgICAgIHJlcHJlc2VudGF0aXZlLiAqKVxuICAgIHZhbCBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHNcbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdFxuICAgICAgICAgIC0+IFsgYE9rIG9mICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2tleSBrZXkgbGlzdCBdXG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3RdLiBSZXR1cm5zIGEgW1Jlc3VsdC50XS4gKilcbiAgICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdCAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IE9yX2Vycm9yLnRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF0uIFJhaXNlcyBvbiBkdXBsaWNhdGVzLiAqKVxuICAgIHZhbCBvZl9hbGlzdF9leG5cbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdCAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogUHJvZHVjZXMgYSBkaWN0aW9uYXJ5IG1hcHBpbmcgZWFjaCBrZXkgdG8gYSBsaXN0IG9mIGFzc29jaWF0ZWQgdmFsdWVzLiAqKVxuICAgIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBsaXN0IC0+ICgna2V5LCAnZGF0YSBsaXN0LCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YSBsaXN0XG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3RdLiBDb25zdW1lIGEgbGlzdCBvZiBlbGVtZW50cyBmb3Igd2hpY2gga2V5L3ZhbHVlIHBhaXJzIGNhbiBiZVxuICAgICAgICBjb21wdXRlZC4gKilcbiAgICB2YWwgY3JlYXRlX21hcHBlZFxuICAgICAgOiAoIGdldF9rZXk6KCdhIC0+ICdrZXkga2V5KVxuICAgICAgICAgIC0+IGdldF9kYXRhOignYSAtPiAnZGF0YSlcbiAgICAgICAgICAtPiAnYSBsaXN0XG4gICAgICAgICAgLT4gWyBgT2sgb2YgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAna2V5IGtleSBsaXN0IF1cbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF0uIENvbnN1bWUgdmFsdWVzIGZvciB3aGljaCBrZXlzIGNhbiBiZSBjb21wdXRlZC4gKilcbiAgICB2YWwgY3JlYXRlX3dpdGhfa2V5XG4gICAgICA6ICggZ2V0X2tleTooJ2RhdGEgLT4gJ2tleSBrZXkpXG4gICAgICAgICAgLT4gJ2RhdGEgbGlzdFxuICAgICAgICAgIC0+IFsgYE9rIG9mICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2tleSBrZXkgbGlzdCBdXG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3Rfb3JfZXJyb3JdLiBDb25zdW1lIHZhbHVlcyBmb3Igd2hpY2gga2V5cyBjYW4gYmUgY29tcHV0ZWQuICopXG4gICAgdmFsIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvclxuICAgICAgOiAoIGdldF9rZXk6KCdkYXRhIC0+ICdrZXkga2V5KSAtPiAnZGF0YSBsaXN0IC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgT3JfZXJyb3IudFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0X2V4bl0uIENvbnN1bWUgdmFsdWVzIGZvciB3aGljaCBrZXlzIGNhbiBiZSBjb21wdXRlZC4gKilcbiAgICB2YWwgY3JlYXRlX3dpdGhfa2V5X2V4blxuICAgICAgOiAoIGdldF9rZXk6KCdkYXRhIC0+ICdrZXkga2V5KSAtPiAnZGF0YSBsaXN0IC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtjcmVhdGVfbWFwcGVkXS4gTXVsdGlwbGUgdmFsdWVzIGZvciBhIGtleSBhcmUgW2NvbWJpbmVdZCByYXRoZXIgdGhhblxuICAgICAgICBwcm9kdWNpbmcgYW4gZXJyb3IuICopXG4gICAgdmFsIGdyb3VwXG4gICAgICA6ICggZ2V0X2tleTooJ2EgLT4gJ2tleSBrZXkpXG4gICAgICAgICAgLT4gZ2V0X2RhdGE6KCdhIC0+ICdkYXRhKVxuICAgICAgICAgIC0+IGNvbWJpbmU6KCdkYXRhIC0+ICdkYXRhIC0+ICdkYXRhKVxuICAgICAgICAgIC0+ICdhIGxpc3RcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMSA9IHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnZGF0YSB0XG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIENyZWF0b3JzXG4gICAgICAgIHdpdGggdHlwZSAoXywgJ2RhdGEsIF8pIHQgOj0gJ2RhdGEgdFxuICAgICAgICAgYW5kIHR5cGUgXyBrZXkgOj0ga2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCBfLCBfLCBfKSBjcmVhdG9yIDo9ICdmblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczIgPSBzaWdcbiAgICB0eXBlICgna2V5LCAnZGF0YSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEpIGNyZWF0b3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgXykgdCA6PSAoJ2tleSwgJ2RhdGEpIHRcbiAgICAgICAgIGFuZCB0eXBlICdrZXkga2V5IDo9ICdrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCBfKSBjcmVhdG9yIDo9ICgnZm4sICdrZXksICdkYXRhKSBjcmVhdG9yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMyA9IHNpZ1xuICAgIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIENyZWF0b3JzXG4gICAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IDo9ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgIGFuZCB0eXBlICdrZXkga2V5IDo9ICdrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSAna2V5IGtleVxuICAgIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIEFjY2Vzc29yc1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCA6PSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5IGtleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgOj0gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleSBrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnZGF0YSB0XG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIFNcbiAgICAgICAgd2l0aCB0eXBlIChfLCAnZGF0YSwgXykgdCA6PSAnZGF0YSB0XG4gICAgICAgICBhbmQgdHlwZSBfIGtleSA6PSBrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sIF8sIF8sIF8pIGFjY2Vzc29yIDo9ICdmblxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgXywgXywgXykgY3JlYXRvciA6PSAnZm5cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgna2V5LCAnZGF0YSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEpIGFjY2Vzc29yXG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSkgY3JlYXRvclxuXG4gICAgKCoqIEBpbmxpbmUgKilcbiAgICBpbmNsdWRlXG4gICAgICBTXG4gICAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsIF8pIHQgOj0gKCdrZXksICdkYXRhKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgXykgYWNjZXNzb3IgOj0gKCdmbiwgJ2tleSwgJ2RhdGEpIGFjY2Vzc29yXG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgXykgY3JlYXRvciA6PSAoJ2ZuLCAna2V5LCAnZGF0YSkgY3JlYXRvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuICAgIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIFNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgOj0gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvciA6PVxuICAgICAgICAgICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvclxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBEaWN0aW9uYXJ5X211dGFibGUgPSBzaWdcbiAgKCoqIEBpbmxpbmUgKilcbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIERlZmluaXRpb25zICgqKiBAaW5saW5lICopXG4gIGVuZFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNodGJsLktleSAqKVxubW9kdWxlIEtleSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgICgqKiBUd28gW3RdcyB0aGF0IFtjb21wYXJlXSBlcXVhbCBtdXN0IGhhdmUgZXF1YWwgaGFzaGVzIGZvciB0aGUgaGFzaHRhYmxlXG4gICAgICAgIHRvIGJlaGF2ZSBwcm9wZXJseS4gKilcbiAgICB2YWwgaGFzaCA6IHQgLT4gaW50XG4gIGVuZFxuXG4gIHR5cGUgJ2EgdCA9IChtb2R1bGUgUyB3aXRoIHR5cGUgdCA9ICdhKVxuZW5kXG5cbm1vZHVsZSBNZXJnZV9pbnRvX2FjdGlvbiA9IERpY3Rpb25hcnlfbXV0YWJsZS5NZXJnZV9pbnRvX2FjdGlvblxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMgPSBzaWdcbiAgKCoqIHsyIEFjY2Vzc29yc30gKilcblxuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXlcblxuICAoKiogQGlubGluZSAqKVxuICBpbmNsdWRlXG4gICAgRGljdGlvbmFyeV9tdXRhYmxlLkFjY2Vzc29yc1xuICAgICAgd2l0aCB0eXBlICdrZXkga2V5IDo9ICdrZXkga2V5XG4gICAgICAgYW5kIHR5cGUgKCdrZXksICdkYXRhLCBfKSB0IDo9ICgna2V5LCAnZGF0YSkgdFxuICAgICAgIGFuZCB0eXBlICgnZm4sIF8sIF8sIF8pIGFjY2Vzc29yIDo9ICdmblxuXG4gIHZhbCBzZXhwX29mX2tleSA6ICgnYSwgXykgdCAtPiAnYSBrZXkgLT4gU2V4cC50XG4gIHZhbCBjbGVhciA6IChfLCBfKSB0IC0+IHVuaXRcbiAgdmFsIGNvcHkgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHRcblxuICAoKiogQXR0ZW1wdGluZyB0byBtb2RpZnkgKFtzZXRdLCBbcmVtb3ZlXSwgZXRjLikgdGhlIGhhc2h0YWJsZSBkdXJpbmcgaXRlcmF0aW9uIChbZm9sZF0sXG4gICAgICBbaXRlcl0sIFtpdGVyX2tleXNdLCBbaXRlcmldKSB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbi4gKilcbiAgdmFsIGZvbGQgOiAoJ2EsICdiKSB0IC0+IGluaXQ6J2FjYyAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2FjYyAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgdmFsIGl0ZXJfa2V5cyA6ICgnYSwgXykgdCAtPiBmOignYSBrZXkgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAnYikgdCAtPiBmOignYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIEl0ZXJhdGVzIG92ZXIgYm90aCBrZXlzIGFuZCB2YWx1ZXMuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaCA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDQpOyAoNSwgNildIGluXG4gICAgICBIYXNodGJsLml0ZXJpIGggfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgIHByaW50X2VuZGxpbmUgKFByaW50Zi5zcHJpbnRmIFwiJWQtJWRcIiBrZXkgZGF0YSkpOztcbiAgICAgIDEtNFxuICAgICAgNS02XG4gICAgICAtIDogdW5pdCA9ICgpXG4gICAgICB2fSAqKVxuICB2YWwgaXRlcmkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGV4aXN0c2kgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50aSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnQgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBsZW5ndGggOiAoXywgXykgdCAtPiBpbnRcbiAgdmFsIGNhcGFjaXR5IDogXyB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBtZW0gOiAoJ2EsIF8pIHQgLT4gJ2Ega2V5IC0+IGJvb2xcbiAgdmFsIHJlbW92ZSA6ICgnYSwgXykgdCAtPiAnYSBrZXkgLT4gdW5pdFxuXG4gICgqKiBDaG9vc2UgYW4gYXJiaXRyYXJ5IGtleS92YWx1ZSBwYWlyIG9mIGEgaGFzaCB0YWJsZS4gUmV0dXJucyBbTm9uZV0gaWYgW3RdIGlzIGVtcHR5LlxuXG4gICAgICBUaGUgY2hvaWNlIGlzIGRldGVybWluaXN0aWMuIENhbGxpbmcgW2Nob29zZV0gbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWUgdGFibGVcbiAgICAgIHJldHVybnMgdGhlIHNhbWUga2V5L3ZhbHVlIHBhaXIsIHNvIGxvbmcgYXMgdGhlIHRhYmxlIGlzIG5vdCBtdXRhdGVkIGluIGJldHdlZW4uXG4gICAgICBCZXlvbmQgZGV0ZXJtaW5pc20sIG5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgaG93IHRoZSBjaG9pY2UgaXMgbWFkZS4gRXhwZWN0XG4gICAgICBiaWFzIHRvd2FyZCBjZXJ0YWluIGhhc2ggdmFsdWVzLlxuXG4gICAgICBUaGlzIGhhc2ggYmlhcyBjYW4gbGVhZCB0byBkZWdlbmVyYXRlIHBlcmZvcm1hbmNlIGluIHNvbWUgY2FzZXMsIHN1Y2ggYXMgY2xlYXJpbmdcbiAgICAgIGEgaGFzaCB0YWJsZSB1c2luZyByZXBlYXRlZCBbY2hvb3NlXSBhbmQgW3JlbW92ZV0uIEF0IGVhY2ggaXRlcmF0aW9uLCBmaW5kaW5nIHRoZVxuICAgICAgbmV4dCBlbGVtZW50IG1heSBoYXZlIHRvIHNjYW4gZmFydGhlciBmcm9tIGl0cyBpbml0aWFsIGhhc2ggdmFsdWUuICopXG4gIHZhbCBjaG9vc2UgOiAoJ2EsICdiKSB0IC0+ICgnYSBrZXkgKiAnYikgb3B0aW9uXG5cbiAgKCoqIExpa2UgW2Nob29zZV0uIFJhaXNlcyBpZiBbdF0gaXMgZW1wdHkuICopXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgKiAnYlxuXG4gICgqKiBDaG9vc2VzIGEgcmFuZG9tIGtleS92YWx1ZSBwYWlyIG9mIGEgaGFzaCB0YWJsZS4gUmV0dXJucyBbTm9uZV0gaWYgW3RdIGlzIGVtcHR5LlxuXG4gICAgICBUaGUgY2hvaWNlIGlzIGRpc3RyaWJ1dGVkIHVuaWZvcm1seSBhY3Jvc3MgaGFzaCB2YWx1ZXMsIHJhdGhlciB0aGFuIGFjcm9zcyBrZXlzXG4gICAgICB0aGVtc2VsdmVzLiBBcyBhIGNvbnNlcXVlbmNlLCB0aGUgY2xvc2VyIHRoZSBrZXlzIGFyZSB0byBldmVubHkgc3BhY2VkIG91dCBpbiB0aGVcbiAgICAgIHRhYmxlLCB0aGUgY2xvc2VyIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSB0byBhIHVuaWZvcm0gY2hvaWNlIG9mIGtleXMuXG5cbiAgICAgIFRoaXMgZnVuY3Rpb24gbWF5IGJlIHByZWZlcmFibGUgdG8gW2Nob29zZV0gd2hlbiBub25kZXRlcm1pbmlzdGljIGNob2ljZSBpc1xuICAgICAgYWNjZXB0YWJsZSwgYW5kIGJpYXMgdG93YXJkIGNlcnRhaW4gaGFzaCB2YWx1ZXMgaXMgdW5kZXNpcmFibGUuICopXG4gIHZhbCBjaG9vc2VfcmFuZG9tbHlcbiAgICA6ICA/cmFuZG9tX3N0YXRlOlJhbmRvbS5TdGF0ZS50ICgqKiBkZWZhdWx0OiBbUmFuZG9tLlN0YXRlLmRlZmF1bHRdICopXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+ICgnYSBrZXkgKiAnYikgb3B0aW9uXG5cbiAgKCoqIExpa2UgW2Nob29zZV9yYW5kb21seV0uIFJhaXNlcyBpZiBbdF0gaXMgZW1wdHkuICopXG4gIHZhbCBjaG9vc2VfcmFuZG9tbHlfZXhuXG4gICAgOiAgP3JhbmRvbV9zdGF0ZTpSYW5kb20uU3RhdGUudCAoKiogZGVmYXVsdDogW1JhbmRvbS5TdGF0ZS5kZWZhdWx0XSAqKVxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXkgKiAnYlxuXG4gICgqKiBTZXRzIHRoZSBnaXZlbiBba2V5XSB0byBbZGF0YV0uICopXG4gIHZhbCBzZXQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiB1bml0XG5cbiAgKCoqIFthZGRdIGFuZCBbYWRkX2V4bl0gbGVhdmUgdGhlIHRhYmxlIHVuY2hhbmdlZCBpZiB0aGUga2V5IHdhcyBhbHJlYWR5IHByZXNlbnQuICopXG4gIHZhbCBhZGQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBbIGBPayB8IGBEdXBsaWNhdGUgXVxuXG4gIHZhbCBhZGRfZXhuIDogKCdhLCAnYikgdCAtPiBrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gdW5pdFxuXG4gICgqKiBbY2hhbmdlIHQga2V5IH5mXSBjaGFuZ2VzIFt0XSdzIHZhbHVlIGZvciBba2V5XSB0byBiZSBbZiAoZmluZCB0IGtleSldLiAqKVxuICB2YWwgY2hhbmdlIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZjooJ2Igb3B0aW9uIC0+ICdiIG9wdGlvbikgLT4gdW5pdFxuXG4gICgqKiBbdXBkYXRlIHQga2V5IH5mXSBpcyBbY2hhbmdlIHQga2V5IH5mOihmdW4gbyAtPiBTb21lIChmIG8pKV0uICopXG4gIHZhbCB1cGRhdGUgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiBmOignYiBvcHRpb24gLT4gJ2IpIC0+IHVuaXRcblxuICAoKiogW3VwZGF0ZV9hbmRfcmV0dXJuIHQga2V5IH5mXSBpcyBbdXBkYXRlXSwgYnV0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBbZiBvXS4gKilcbiAgdmFsIHVwZGF0ZV9hbmRfcmV0dXJuIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKSAtPiAnYlxuXG4gICgqKiBbbWFwIHQgZl0gcmV0dXJucyBhIG5ldyB0YWJsZSB3aXRoIHZhbHVlcyByZXBsYWNlZCBieSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIFtmXVxuICAgICAgdG8gdGhlIGN1cnJlbnQgdmFsdWVzLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgbGV0IGggPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA0KTsgKDUsIDYpXSBpblxuICAgICAgbGV0IGgnID0gSGFzaHRibC5tYXAgaCB+ZjoobG9jYWxfIChmdW4geCAtPiB4ICogMikpIGluXG4gICAgICBIYXNodGJsLnRvX2FsaXN0IGgnOztcbiAgICAgIC0gOiAoaW50ICogaW50KSBsaXN0ID0gWyg1LCAxMik7ICgxLCA4KV1cbiAgICAgIHZ9ICopXG4gIHZhbCBtYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG5cbiAgKCoqIExpa2UgW21hcF0sIGJ1dCB0aGUgZnVuY3Rpb24gW2ZdIHRha2VzIGJvdGgga2V5IGFuZCBkYXRhIGFzIGFyZ3VtZW50cy4gKilcbiAgdmFsIG1hcGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYykgLT4gKCdhLCAnYykgdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IHRhYmxlIGJ5IGZpbHRlcmluZyB0aGUgZ2l2ZW4gdGFibGUncyB2YWx1ZXMgYnkgW2ZdOiB0aGUga2V5cyBmb3Igd2hpY2hcbiAgICAgIFtmXSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHZhbHVlIHJldHVybnMgW1NvbWVdIGFyZSBrZXB0LCBhbmQgdGhvc2UgZm9yIHdoaWNoIGl0XG4gICAgICByZXR1cm5zIFtOb25lXSBhcmUgZGlzY2FyZGVkLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgbGV0IGggPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA0KTsgKDUsIDYpXSBpblxuICAgICAgSGFzaHRibC5maWx0ZXJfbWFwIGggfmY6KGxvY2FsXyAoZnVuIHggLT4gaWYgeCA+IDUgdGhlbiBTb21lIHggZWxzZSBOb25lKSlcbiAgICAgIHw+IEhhc2h0YmwudG9fYWxpc3Q7O1xuICAgICAgLSA6IChpbnQgKiBpbnQpIGxpc3QgPSBbKDUsIDYpXVxuICAgICAgdn0gKilcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICdjIG9wdGlvbikgLT4gKCdhLCAnYykgdFxuXG4gICgqKiBMaWtlIFtmaWx0ZXJfbWFwXSwgYnV0IHRoZSBmdW5jdGlvbiBbZl0gdGFrZXMgYm90aCBrZXkgYW5kIGRhdGEgYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgZmlsdGVyX21hcGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MpIHRcblxuICB2YWwgZmlsdGVyX2tleXMgOiAoJ2EsICdiKSB0IC0+IGY6KCdhIGtleSAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGZpbHRlcmkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG5cbiAgKCoqIFJldHVybnMgbmV3IHRhYmxlcyB3aXRoIGJvdW5kIHZhbHVlcyBwYXJ0aXRpb25lZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmRcbiAgICAgIHZhbHVlcy4gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICgnYywgJ2QpIEVpdGhlci50KSAtPiAoJ2EsICdjKSB0ICogKCdhLCAnZCkgdFxuXG4gICgqKiBMaWtlIFtwYXJ0aXRpb25fbWFwXSwgYnV0IHRoZSBmdW5jdGlvbiBbZl0gdGFrZXMgYm90aCBrZXkgYW5kIGRhdGEgYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgIC0+ICgnYSwgJ2MpIHQgKiAoJ2EsICdkKSB0XG5cbiAgKCoqIFJldHVybnMgYSBwYWlyIG9mIHRhYmxlcyBbKHQxLCB0MildLCB3aGVyZSBbdDFdIGNvbnRhaW5zIGFsbCB0aGUgZWxlbWVudHMgb2YgdGhlXG4gICAgICBpbml0aWFsIHRhYmxlIHdoaWNoIHNhdGlzZnkgdGhlIHByZWRpY2F0ZSBbZl0sIGFuZCBbdDJdIGNvbnRhaW5zIHRoZSByZXN0LiAqKVxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0ICogKCdhLCAnYikgdFxuXG4gICgqKiBMaWtlIFtwYXJ0aXRpb25fdGZdLCBidXQgdGhlIGZ1bmN0aW9uIFtmXSB0YWtlcyBib3RoIGtleSBhbmQgZGF0YSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IpIHQgKiAoJ2EsICdiKSB0XG5cbiAgKCoqIFtmaW5kX29yX2FkZCB0IGsgfmRlZmF1bHRdIHJldHVybnMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGtleSBba10gaWYgaXQgaXMgaW4gdGhlXG4gICAgICB0YWJsZSBbdF0sIGFuZCBvdGhlcndpc2UgYXNzaWducyBba10gdGhlIHZhbHVlIHJldHVybmVkIGJ5IFtkZWZhdWx0ICgpXS4gKilcbiAgdmFsIGZpbmRfb3JfYWRkIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZGVmYXVsdDoodW5pdCAtPiAnYikgLT4gJ2JcblxuICAoKiogTGlrZSBbZmluZF9vcl9hZGRdIGJ1dCBbZGVmYXVsdF0gdGFrZXMgdGhlIGtleSBhcyBhbiBhcmd1bWVudC4gKilcbiAgdmFsIGZpbmRpX29yX2FkZCA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+IGRlZmF1bHQ6KCdhIGtleSAtPiAnYikgLT4gJ2JcblxuICAoKiogW2ZpbmQgdCBrXSByZXR1cm5zIFtTb21lXSAodGhlIGN1cnJlbnQgYmluZGluZykgb2YgW2tdIGluIFt0XSwgb3IgW05vbmVdIGlmIG5vIHN1Y2hcbiAgICAgIGJpbmRpbmcgZXhpc3RzLiAqKVxuICB2YWwgZmluZCA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+ICdiIG9wdGlvblxuXG4gICgqKiBbZmluZF9leG4gdCBrXSByZXR1cm5zIHRoZSBjdXJyZW50IGJpbmRpbmcgb2YgW2tdIGluIFt0XSwgb3IgcmFpc2VzIFtTdGRsaWIuTm90X2ZvdW5kXVxuICAgICAgb3IgW05vdF9mb3VuZF9zXSBpZiBubyBzdWNoIGJpbmRpbmcgZXhpc3RzLiAqKVxuICB2YWwgZmluZF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiAnYlxuXG4gICgqKiBbZmluZF9hbmRfY2FsbCB0IGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRdXG5cbiAgICAgIGlzIGVxdWl2YWxlbnQgdG86XG5cbiAgICAgIFttYXRjaCBmaW5kIHQgayB3aXRoIFNvbWUgdiAtPiBpZl9mb3VuZCB2IHwgTm9uZSAtPiBpZl9ub3RfZm91bmQga11cblxuICAgICAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhbGxvY2F0ZSB0aGUgb3B0aW9uLiAqKVxuICB2YWwgZmluZF9hbmRfY2FsbFxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBpZl9mb3VuZDooJ2IgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICAoKiogSnVzdCBsaWtlIFtmaW5kX2FuZF9jYWxsXSwgYnV0IHRha2VzIGFuIGV4dHJhIGFyZ3VtZW50IHdoaWNoIGlzIHBhc3NlZCB0byBbaWZfZm91bmRdXG4gICAgICBhbmQgW2lmX25vdF9mb3VuZF0sIHNvIHRoYXQgdGhlIGNsaWVudCBjb2RlIGNhbiBhdm9pZCBhbGxvY2F0aW5nIGNsb3N1cmVzIG9yIHVzaW5nXG4gICAgICByZWZzIHRvIHBhc3MgdGhpcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLiAgVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWZ1bCBpbiBjb2RlXG4gICAgICB3aGljaCB0cmllcyB0byBtaW5pbWl6ZSBoZWFwIGFsbG9jYXRpb24uICopXG4gIHZhbCBmaW5kX2FuZF9jYWxsMVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBhOidkXG4gICAgLT4gaWZfZm91bmQ6KCdiIC0+ICdkIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdkIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbmRfYW5kX2NhbGwyXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGE6J2RcbiAgICAtPiBiOidlXG4gICAgLT4gaWZfZm91bmQ6KCdiIC0+ICdkIC0+ICdlIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdkIC0+ICdlIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbmRpX2FuZF9jYWxsXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGlmX2ZvdW5kOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgZmluZGlfYW5kX2NhbGwxXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGE6J2RcbiAgICAtPiBpZl9mb3VuZDooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdkIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdkIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbmRpX2FuZF9jYWxsMlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBhOidkXG4gICAgLT4gYjonZVxuICAgIC0+IGlmX2ZvdW5kOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2QgLT4gJ2UgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2QgLT4gJ2UgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICAoKiogW2ZpbmRfYW5kX3JlbW92ZSB0IGtdIHJldHVybnMgU29tZSAodGhlIGN1cnJlbnQgYmluZGluZykgb2YgayBpbiB0IGFuZCByZW1vdmVzIGl0LFxuICAgICAgb3IgTm9uZSBpcyBubyBzdWNoIGJpbmRpbmcgZXhpc3RzLiAqKVxuICB2YWwgZmluZF9hbmRfcmVtb3ZlIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gJ2Igb3B0aW9uXG5cbiAgKCoqIE1lcmdlcyB0d28gaGFzaHRhYmxlcy5cblxuICAgICAgVGhlIHJlc3VsdCBvZiBbbWVyZ2UgZiBoMSBoMl0gaGFzIGFzIGtleXMgdGhlIHNldCBvZiBhbGwgW2tdIGluIHRoZSB1bmlvbiBvZiB0aGVcbiAgICAgIHNldHMgb2Yga2V5cyBvZiBbaDFdIGFuZCBbaDJdIGZvciB3aGljaCBbZChrKV0gaXMgbm90IE5vbmUsIHdoZXJlOlxuXG4gICAgICBkKGspID1cbiAgICAgIC0gW2YgfmtleTprIChgTGVmdCBkMSldXG4gICAgICAgIGlmIFtrXSBpbiBbaDFdIG1hcHMgdG8gZDEsIGFuZCBbaDJdIGRvZXMgbm90IGhhdmUgZGF0YSBmb3IgW2tdO1xuXG4gICAgICAtIFtmIH5rZXk6ayAoYFJpZ2h0IGQyKV1cbiAgICAgICAgaWYgW2tdIGluIFtoMl0gbWFwcyB0byBkMiwgYW5kIFtoMV0gZG9lcyBub3QgaGF2ZSBkYXRhIGZvciBba107XG5cbiAgICAgIC0gW2YgfmtleTprIChgQm90aCAoZDEsIGQyKSldXG4gICAgICAgIG90aGVyd2lzZSwgd2hlcmUgW2tdIGluIFtoMV0gbWFwcyB0byBbZDFdIGFuZCBba10gaW4gW2gyXSBtYXBzIHRvIFtkMl0uXG5cbiAgICAgIEVhY2gga2V5IFtrXSBpcyBtYXBwZWQgdG8gYSBzaW5nbGUgcGllY2Ugb2YgZGF0YSBbeF0sIHdoZXJlIFtkKGspID0gU29tZSB4XS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgIGxldCBoMSA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDUpOyAoMiwgMzIzMildIGluXG4gICAgICBsZXQgaDIgPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCAzKV0gaW5cbiAgICAgIEhhc2h0YmwubWVyZ2UgaDEgaDIgfmY6KGZ1biB+a2V5Ol8gLT4gZnVuY3Rpb25cbiAgICAgICAgfCBgTGVmdCB4IC0+IFNvbWUgKGBMZWZ0IHgpXG4gICAgICAgIHwgYFJpZ2h0IHggLT4gU29tZSAoYFJpZ2h0IHgpXG4gICAgICAgIHwgYEJvdGggKHgsIHkpIC0+IGlmIHg9eSB0aGVuIE5vbmUgZWxzZSBTb21lIChgQm90aCAoeCx5KSlcbiAgICAgICkgfD4gSGFzaHRibC50b19hbGlzdDs7XG4gICAgICAtIDogKGludCAqIFs+IGBCb3RoIG9mIGludCAqIGludCB8IGBMZWZ0IG9mIGludCB8IGBSaWdodCBvZiBpbnQgXSkgbGlzdCA9XG4gICAgICBbKDIsIGBMZWZ0IDMyMzIpOyAoMSwgYEJvdGggKDUsIDMpKV1cbiAgICAgIHZ9ICopXG4gIHZhbCBtZXJnZVxuICAgIDogICgnaywgJ2EpIHRcbiAgICAtPiAoJ2ssICdiKSB0XG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdiIHwgYEJvdGggb2YgJ2EgKiAnYiBdIC0+ICdjIG9wdGlvbilcbiAgICAtPiAoJ2ssICdjKSB0XG5cbiAgKCoqIEV2ZXJ5IFtrZXldIGluIFtzcmNdIHdpbGwgYmUgcmVtb3ZlZCBvciBzZXQgaW4gW2RzdF0gYWNjb3JkaW5nIHRvIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgIG9mIFtmXS4gKilcbiAgdmFsIG1lcmdlX2ludG9cbiAgICA6ICBzcmM6KCdrLCAnYSkgdFxuICAgIC0+IGRzdDooJ2ssICdiKSB0XG4gICAgLT4gZjooa2V5OidrIGtleSAtPiAnYSAtPiAnYiBvcHRpb24gLT4gJ2IgRGljdGlvbmFyeV9tdXRhYmxlLk1lcmdlX2ludG9fYWN0aW9uLnQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCBrZXlzIGZvciBnaXZlbiBoYXNodGFibGUuICopXG4gIHZhbCBrZXlzIDogKCdhLCBfKSB0IC0+ICdhIGtleSBsaXN0XG5cbiAgKCoqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGRhdGEgZm9yIGdpdmVuIGhhc2h0YWJsZS4gKilcbiAgdmFsIGRhdGEgOiAoXywgJ2IpIHQgLT4gJ2IgbGlzdFxuXG4gICgqKiBbZmlsdGVyX2lucGxhY2UgdCB+Zl0gcmVtb3ZlcyBhbGwgdGhlIGVsZW1lbnRzIGZyb20gW3RdIHRoYXQgZG9uJ3Qgc2F0aXNmeSBbZl0uICopXG4gIHZhbCBmaWx0ZXJfa2V5c19pbnBsYWNlIDogKCdhLCBfKSB0IC0+IGY6KCdhIGtleSAtPiBib29sKSAtPiB1bml0XG5cbiAgdmFsIGZpbHRlcl9pbnBsYWNlIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IHVuaXRcbiAgdmFsIGZpbHRlcmlfaW5wbGFjZSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IHVuaXRcblxuICAoKiogW21hcF9pbnBsYWNlIHQgfmZdIGFwcGxpZXMgW2ZdIHRvIGFsbCBlbGVtZW50cyBpbiBbdF0sIHRyYW5zZm9ybWluZyB0aGVtIGluXG4gICAgICBwbGFjZS4gKilcbiAgdmFsIG1hcF9pbnBsYWNlIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+ICdiKSAtPiB1bml0XG5cbiAgdmFsIG1hcGlfaW5wbGFjZSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdiKSAtPiB1bml0XG5cbiAgKCoqIFtmaWx0ZXJfbWFwX2lucGxhY2VdIGNvbWJpbmVzIHRoZSBlZmZlY3RzIG9mIFttYXBfaW5wbGFjZV0gYW5kIFtmaWx0ZXJfaW5wbGFjZV0uICopXG4gIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2UgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gJ2Igb3B0aW9uKSAtPiB1bml0XG5cbiAgdmFsIGZpbHRlcl9tYXBpX2lucGxhY2UgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYiBvcHRpb24pIC0+IHVuaXRcblxuICAoKiogW2VxdWFsIGYgdDEgdDJdIGFuZCBbc2ltaWxhciBmIHQxIHQyXSBib3RoIHJldHVybiB0cnVlIGlmZiBbdDFdIGFuZCBbdDJdIGhhdmUgdGhlXG4gICAgICBzYW1lIGtleXMgYW5kIGZvciBhbGwga2V5cyBba10sIFtmIChmaW5kX2V4biB0MSBrKSAoZmluZF9leG4gdDIgayldLiAgW2VxdWFsXSBhbmRcbiAgICAgIFtzaW1pbGFyXSBvbmx5IGRpZmZlciBpbiB0aGVpciB0eXBlcy4gKilcbiAgdmFsIGVxdWFsIDogKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBib29sXG5cbiAgdmFsIHNpbWlsYXIgOiAoJ2IxIC0+ICdiMiAtPiBib29sKSAtPiAoJ2EsICdiMSkgdCAtPiAoJ2EsICdiMikgdCAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIChrZXksIGRhdGEpIHBhaXJzIGZvciBnaXZlbiBoYXNodGFibGUuICopXG4gIHZhbCB0b19hbGlzdCA6ICgnYSwgJ2IpIHQgLT4gKCdhIGtleSAqICdiKSBsaXN0XG5cbiAgKCoqIFtyZW1vdmVfaWZfemVyb10ncyBkZWZhdWx0IGlzIFtmYWxzZV0uICopXG4gIHZhbCBpbmNyIDogP2J5OmludCAtPiA/cmVtb3ZlX2lmX3plcm86Ym9vbCAtPiAoJ2EsIGludCkgdCAtPiAnYSBrZXkgLT4gdW5pdFxuXG4gIHZhbCBkZWNyIDogP2J5OmludCAtPiA/cmVtb3ZlX2lmX3plcm86Ym9vbCAtPiAoJ2EsIGludCkgdCAtPiAnYSBrZXkgLT4gdW5pdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE11bHRpID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdhIGtleVxuXG4gICgqKiBbYWRkX211bHRpIHQgfmtleSB+ZGF0YV0gaWYgW2tleV0gaXMgcHJlc2VudCBpbiB0aGUgdGFibGUgdGhlbiBjb25zXG4gICAgICBbZGF0YV0gb24gdGhlIGxpc3QsIG90aGVyd2lzZSBhZGQgW2tleV0gd2l0aCBhIHNpbmdsZSBlbGVtZW50IGxpc3QuICopXG4gIHZhbCBhZGRfbXVsdGkgOiAoJ2EsICdiIGxpc3QpIHQgLT4ga2V5OidhIGtleSAtPiBkYXRhOidiIC0+IHVuaXRcblxuICAoKiogW3JlbW92ZV9tdWx0aSB0IGtleV0gdXBkYXRlcyB0aGUgdGFibGUsIHJlbW92aW5nIHRoZSBoZWFkIG9mIHRoZSBsaXN0IGJvdW5kIHRvXG4gICAgICBba2V5XS4gSWYgdGhlIGxpc3QgaGFzIG9ubHkgb25lIGVsZW1lbnQgKG9yIGlzIGVtcHR5KSB0aGVuIHRoZSBiaW5kaW5nIGlzXG4gICAgICByZW1vdmVkLiAqKVxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdhLCBfIGxpc3QpIHQgLT4gJ2Ega2V5IC0+IHVuaXRcblxuICAoKiogW2ZpbmRfbXVsdGkgdCBrZXldIHJldHVybnMgdGhlIGVtcHR5IGxpc3QgaWYgW2tleV0gaXMgbm90IHByZXNlbnQgaW4gdGhlIHRhYmxlLFxuICAgICAgcmV0dXJucyBbdF0ncyB2YWx1ZXMgZm9yIFtrZXldIG90aGVyd2lzZS4gKilcbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2EsICdiIGxpc3QpIHQgLT4gJ2Ega2V5IC0+ICdiIGxpc3RcbmVuZFxuXG50eXBlICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zID1cbiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgLT4gJ2tleSBLZXkudFxuICAtPiAnelxuXG50eXBlICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlID1cbiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgLT4gJ3pcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXlcbiAgdHlwZSAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc1xuXG4gICgqKiBAaW5saW5lICopXG4gIGluY2x1ZGVcbiAgICBEaWN0aW9uYXJ5X211dGFibGUuQ3JlYXRvcnNcbiAgICAgIHdpdGggdHlwZSAna2V5IGtleSA6PSAna2V5IGtleVxuICAgICAgIGFuZCB0eXBlICgna2V5LCAnZGF0YSwgXykgdCA6PSAoJ2tleSwgJ2RhdGEpIHRcbiAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgXykgY3JlYXRvciA6PSAoJ2tleSBrZXksICdkYXRhLCAnZm4pIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIGNyZWF0ZSA6ICgnYSBrZXksICdiLCB1bml0IC0+ICgnYSwgJ2IpIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnYlxuICAgICAgLCAoJ2Ega2V5ICogJ2IpIGxpc3QgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIGtleSBdIClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwc1xuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ2JcbiAgICAgICwgKCdhIGtleSAqICdiKSBsaXN0IC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2Ega2V5IGxpc3QgXSApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogKCdhIGtleSwgJ2IsICgnYSBrZXkgKiAnYikgbGlzdCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnYSBrZXksICdiLCAoJ2Ega2V5ICogJ2IpIGxpc3QgLT4gKCdhLCAnYikgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfbXVsdGlcbiAgICA6ICgnYSBrZXksICdiIGxpc3QsICgnYSBrZXkgKiAnYikgbGlzdCAtPiAoJ2EsICdiIGxpc3QpIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgKCoqIHtbIGNyZWF0ZV9tYXBwZWQgZ2V0X2tleSBnZXRfZGF0YSBbeDEsLi4uLHhuXVxuICAgICAgICAgPSBvZl9hbGlzdCBbZ2V0X2tleSB4MSwgZ2V0X2RhdGEgeDE7IC4uLjsgZ2V0X2tleSB4biwgZ2V0X2RhdGEgeG5dIF19ICopXG4gIHZhbCBjcmVhdGVfbWFwcGVkXG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnYlxuICAgICAgLCBnZXRfa2V5OignciAtPiAnYSBrZXkpXG4gICAgICAgIC0+IGdldF9kYXRhOignciAtPiAnYilcbiAgICAgICAgLT4gJ3IgbGlzdFxuICAgICAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdhIGtleSBsaXN0IF0gKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICAoKioge1sgY3JlYXRlX3dpdGhfa2V5IH5nZXRfa2V5IFt4MSwuLi4seG5dXG4gICAgICAgICA9IG9mX2FsaXN0IFtnZXRfa2V5IHgxLCB4MTsgLi4uOyBnZXRfa2V5IHhuLCB4bl0gXX0gKilcbiAgdmFsIGNyZWF0ZV93aXRoX2tleVxuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ3JcbiAgICAgICwgZ2V0X2tleTooJ3IgLT4gJ2Ega2V5KVxuICAgICAgICAtPiAnciBsaXN0XG4gICAgICAgIC0+IFsgYE9rIG9mICgnYSwgJ3IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2Ega2V5IGxpc3QgXSApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3JcbiAgICA6ICggJ2Ega2V5XG4gICAgICAsICdyXG4gICAgICAsIGdldF9rZXk6KCdyIC0+ICdhIGtleSkgLT4gJ3IgbGlzdCAtPiAoJ2EsICdyKSB0IE9yX2Vycm9yLnQgKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgY3JlYXRlX3dpdGhfa2V5X2V4blxuICAgIDogKCdhIGtleSwgJ3IsIGdldF9rZXk6KCdyIC0+ICdhIGtleSkgLT4gJ3IgbGlzdCAtPiAoJ2EsICdyKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBncm91cFxuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ2JcbiAgICAgICwgZ2V0X2tleTooJ3IgLT4gJ2Ega2V5KVxuICAgICAgICAtPiBnZXRfZGF0YTooJ3IgLT4gJ2IpXG4gICAgICAgIC0+IGNvbWJpbmU6KCdiIC0+ICdiIC0+ICdiKVxuICAgICAgICAtPiAnciBsaXN0XG4gICAgICAgIC0+ICgnYSwgJ2IpIHQgKVxuICAgICAgY3JlYXRlX29wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9ycyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcblxuICAoKiogezIgQ3JlYXRvcnN9ICopXG5cbiAgKCoqIFRoZSBtb2R1bGUgeW91IHBhc3MgdG8gW2NyZWF0ZV0gbXVzdCBoYXZlIGEgdHlwZSB0aGF0IGlzIGhhc2hhYmxlLCBzZXhwYWJsZSwgYW5kXG4gICAgICBjb21wYXJhYmxlLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgICBIYXNodGJsLmNyZWF0ZSAobW9kdWxlIEludCk7O1xuICAgICAgICAtIDogKGludCwgJ19hKSBIYXNodGJsLnQgPSA8YWJzdHI+OztcbiAgICAgIHZ9ICopXG4gIHZhbCBjcmVhdGVcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EsICdiKSB0XG5cbiAgKCoqIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICAgICBIYXNodGJsLm9mX2FsaXN0IChtb2R1bGUgSW50KSBbKDMsIFwic29tZXRoaW5nXCIpOyAoMiwgXCJ3aGF0ZXZlclwiKV1cbiAgICAgICAgIC0gOiBbIGBEdXBsaWNhdGVfa2V5IG9mIGludCB8IGBPayBvZiAoaW50LCBzdHJpbmcpIEhhc2h0YmwudCBdID0gYE9rIDxhYnN0cj5cbiAgICAgIHZ9ICopXG4gIHZhbCBvZl9hbGlzdFxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICAoKiogV2hlcmVhcyBbb2ZfYWxpc3RdIHdpbGwgcmVwb3J0IFtEdXBsaWNhdGVfa2V5XSBubyBtYXR0ZXIgaG93IG1hbnkgZHVwcyB0aGVyZSBhcmUgaW5cbiAgICAgIHlvdXIgbGlzdCwgW29mX2FsaXN0X3JlcG9ydF9hbGxfZHVwc10gd2lsbCByZXBvcnQgZWFjaCBhbmQgZXZlcnkgZHVwbGljYXRlIGVudHJ5LlxuXG4gICAgICBGb3IgZXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgICAgSGFzaHRibC5vZl9hbGlzdCAobW9kdWxlIEludCkgWygxLCBcImZvb1wiKTsgKDEsIFwiYmFyXCIpOyAoMiwgXCJmb29cIik7ICgyLCBcImJhclwiKV07O1xuICAgICAgICAtIDogWyBgRHVwbGljYXRlX2tleSBvZiBpbnQgfCBgT2sgb2YgKGludCwgc3RyaW5nKSBIYXNodGJsLnQgXSA9IGBEdXBsaWNhdGVfa2V5IDFcblxuICAgICAgICBIYXNodGJsLm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyAobW9kdWxlIEludCkgWygxLCBcImZvb1wiKTsgKDEsIFwiYmFyXCIpOyAoMiwgXCJmb29cIik7ICgyLCBcImJhclwiKV07O1xuICAgICAgICAtIDogWyBgRHVwbGljYXRlX2tleXMgb2YgaW50IGxpc3QgfCBgT2sgb2YgKGludCwgc3RyaW5nKSBIYXNodGJsLnQgXSA9IGBEdXBsaWNhdGVfa2V5cyBbMTsgMl1cbiAgICAgIHZ9ICopXG4gIHZhbCBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHNcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2EgbGlzdCBdXG5cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2ZfYWxpc3RfZXhuXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSB7eyFNdWx0aX0gXCJtdWx0aVwifSBoYXNodGFibGUsIGkuZS4sIGEgaGFzaHRhYmxlIHdoZXJlIGVhY2gga2V5IHBvaW50cyB0byBhXG4gICAgICBsaXN0IHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgbXVsdGlwbGUgdmFsdWVzLiBTbyBpbnN0ZWFkIG9mIHNob3J0LWNpcmN1aXRpbmcgd2l0aCBhXG4gICAgICBbYER1cGxpY2F0ZV9rZXldIHZhcmlhbnQgb24gZHVwbGljYXRlcywgYXMgaW4gW29mX2FsaXN0XSwgW29mX2FsaXN0X211bHRpXSBmb2xkc1xuICAgICAgdGhvc2UgdmFsdWVzIGludG8gYSBsaXN0IGZvciB0aGUgZ2l2ZW4ga2V5OlxuXG4gICAgICB7dlxuICAgICAgbGV0IGggPSBIYXNodGJsLm9mX2FsaXN0X211bHRpIChtb2R1bGUgSW50KSBbKDEsIFwiYVwiKTsgKDEsIFwiYlwiKTsgKDIsIFwiY1wiKTsgKDIsIFwiZFwiKV07O1xuICAgICAgdmFsIGggOiAoaW50LCBzdHJpbmcgbGlzdCkgSGFzaHRibC50ID0gPGFic3RyPlxuXG4gICAgICBIYXNodGJsLmZpbmRfZXhuIGggMTs7XG4gICAgICAtIDogc3RyaW5nIGxpc3QgPSBbXCJiXCI7IFwiYVwiXVxuICAgICAgdn0gKilcbiAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiIGxpc3QpIHRcblxuICAoKiogQXBwbGllcyB0aGUgW2dldF9rZXldIGFuZCBbZ2V0X2RhdGFdIGZ1bmN0aW9ucyB0byB0aGUgWydyIGxpc3RdIHRvIGNyZWF0ZSB0aGVcbiAgICAgIGluaXRpYWwga2V5cyBhbmQgdmFsdWVzLCByZXNwZWN0aXZlbHksIGZvciB0aGUgbmV3IGhhc2h0YWJsZS5cblxuICAgICAge1sgY3JlYXRlX21hcHBlZCBnZXRfa2V5IGdldF9kYXRhIFt4MTsuLi47eG5dXG4gICAgICAgICA9IG9mX2FsaXN0IFtnZXRfa2V5IHgxLCBnZXRfZGF0YSB4MTsgLi4uOyBnZXRfa2V5IHhuLCBnZXRfZGF0YSB4bl1cbiAgICAgIF19XG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICAgIGxldCBoID1cbiAgICAgICAgICBIYXNodGJsLmNyZWF0ZV9tYXBwZWQgKG1vZHVsZSBJbnQpXG4gICAgICAgICAgICB+Z2V0X2tleToobG9jYWxfIChmdW4geCAtPiB4KSlcbiAgICAgICAgICAgIH5nZXRfZGF0YToobG9jYWxfIChmdW4geCAtPiB4ICsgMSkpXG4gICAgICAgICAgIFsxOyAyOyAzXTs7XG4gICAgICAgIHZhbCBoIDogWyBgRHVwbGljYXRlX2tleXMgb2YgaW50IGxpc3QgfCBgT2sgb2YgKGludCwgaW50KSBIYXNodGJsLnQgXSA9IGBPayA8YWJzdHI+XG5cbiAgICAgICAgbGV0IGggPVxuICAgICAgICAgIG1hdGNoIGggd2l0aFxuICAgICAgICAgIHwgYE9rIHggLT4geFxuICAgICAgICAgIHwgYER1cGxpY2F0ZV9rZXlzIF8gLT4gZmFpbHdpdGggXCJcIlxuICAgICAgICBpblxuICAgICAgICBIYXNodGJsLmZpbmRfZXhuIGggMTs7XG4gICAgICAgIC0gOiBpbnQgPSAyXG4gICAgICB2fSAqKVxuICB2YWwgY3JlYXRlX21hcHBlZFxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+IGdldF9rZXk6KCdyIC0+ICdhKVxuICAgIC0+IGdldF9kYXRhOignciAtPiAnYilcbiAgICAtPiAnciBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBsaXN0IF1cblxuICAoKioge1sgY3JlYXRlX3dpdGhfa2V5IH5nZXRfa2V5IFt4MTsuLi47eG5dXG4gICAgICAgICA9IG9mX2FsaXN0IFtnZXRfa2V5IHgxLCB4MTsgLi4uOyBnZXRfa2V5IHhuLCB4bl0gXX0gKilcbiAgdmFsIGNyZWF0ZV93aXRoX2tleVxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+IGdldF9rZXk6KCdyIC0+ICdhKVxuICAgIC0+ICdyIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdyKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdhIGxpc3QgXVxuXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3JcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiBnZXRfa2V5OignciAtPiAnYSlcbiAgICAtPiAnciBsaXN0XG4gICAgLT4gKCdhLCAncikgdCBPcl9lcnJvci50XG5cbiAgdmFsIGNyZWF0ZV93aXRoX2tleV9leG5cbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiBnZXRfa2V5OignciAtPiAnYSlcbiAgICAtPiAnciBsaXN0XG4gICAgLT4gKCdhLCAncikgdFxuXG4gICgqKiBMaWtlIFtjcmVhdGVfbWFwcGVkXSwgYXBwbGllcyB0aGUgW2dldF9rZXldIGFuZCBbZ2V0X2RhdGFdIGZ1bmN0aW9ucyB0byB0aGUgWydyXG4gICAgICBsaXN0XSB0byBjcmVhdGUgdGhlIGluaXRpYWwga2V5cyBhbmQgdmFsdWVzLCByZXNwZWN0aXZlbHksIGZvciB0aGUgbmV3IGhhc2h0YWJsZSAtLVxuICAgICAgYW5kIHRoZW4sIGxpa2UgW2FkZF9tdWx0aV0sIGZvbGRzIHRvZ2V0aGVyIHZhbHVlcyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUga2V5cy4gSGVyZSxcbiAgICAgIHRob3VnaCwgdGhlIGZ1bmN0aW9uIHVzZWQgZm9yIHRoZSBmb2xkaW5nIGlzIGdpdmVuIGJ5IFtjb21iaW5lXSAoaW5zdGVhZCBvZiBqdXN0XG4gICAgICBiZWluZyBhIFtjb25zXSkuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICAgICBIYXNodGJsLmdyb3VwIChtb2R1bGUgSW50KVxuICAgICAgICAgICB+Z2V0X2tleToobG9jYWxfIChmdW4geCAtPiB4IC8gMikpXG4gICAgICAgICAgIH5nZXRfZGF0YToobG9jYWxfIChmdW4geCAtPiB4KSlcbiAgICAgICAgICAgfmNvbWJpbmU6KGxvY2FsXyAoZnVuIHggeSAtPiB4ICogeSkpXG4gICAgICAgICAgICBbIDE7IDI7IDM7IDRdXG4gICAgICAgICB8PiBIYXNodGJsLnRvX2FsaXN0OztcbiAgICAgICAgIC0gOiAoaW50ICogaW50KSBsaXN0ID0gWygyLCA0KTsgKDEsIDYpOyAoMCwgMSldXG4gICAgICAgdn0gKilcbiAgdmFsIGdyb3VwXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZ2V0X2tleTooJ3IgLT4gJ2EpXG4gICAgLT4gZ2V0X2RhdGE6KCdyIC0+ICdiKVxuICAgIC0+IGNvbWJpbmU6KCdiIC0+ICdiIC0+ICdiKVxuICAgIC0+ICdyIGxpc3RcbiAgICAtPiAoJ2EsICdiKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU193aXRob3V0X3N1Ym1vZHVsZXMgPSBzaWdcbiAgdmFsIGhhc2ggOiAnYSAtPiBpbnRcbiAgdmFsIGhhc2hfcGFyYW0gOiBpbnQgLT4gaW50IC0+ICdhIC0+IGludFxuXG4gIHR5cGUgKCEnYSwgISdiKSB0XG5cbiAgKCoqIFdlIHByb3ZpZGUgYSBbc2V4cF9vZl90XSBidXQgbm90IGEgW3Rfb2Zfc2V4cF0gZm9yIHRoaXMgdHlwZSBiZWNhdXNlIG9uZSBuZWVkcyB0byBiZVxuICAgICAgZXhwbGljaXQgYWJvdXQgdGhlIGhhc2ggYW5kIGNvbXBhcmlzb24gZnVuY3Rpb25zIHVzZWQgd2hlbiBjcmVhdGluZyBhIGhhc2h0YWJsZS5cbiAgICAgIE5vdGUgdGhhdCBbSGFzaHRibC5Qb2x5LnRdIGRvZXMgaGF2ZSBbW0BAZGVyaXZpbmcgc2V4cF1dLCBhbmQgdXNlcyBPQ2FtbCdzIGJ1aWx0LWluXG4gICAgICBwb2x5bW9ycGhpYyBjb21wYXJpc29uIGFuZCBhbmQgcG9seW1vcnBoaWMgaGFzaGluZy4gKilcbiAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwLnQpIC0+ICgnYiAtPiBTZXhwLnQpIC0+ICgnYSwgJ2IpIHQgLT4gU2V4cC50XG5cbiAgaW5jbHVkZSBDcmVhdG9ycyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0ICgqKiBAaW5saW5lICopXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnMgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCB3aXRoIHR5cGUgJ2Ega2V5ID0gJ2FcbiAgKCoqIEBpbmxpbmUgKilcblxuICBpbmNsdWRlIE11bHRpIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbiAgKCoqIEBpbmxpbmUgKilcblxuICB2YWwgaGFzaGFibGVfcyA6ICgna2V5LCBfKSB0IC0+ICdrZXkgS2V5LnRcblxuICBpbmNsdWRlIEludmFyaWFudC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU19wb2x5ID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hclxuICAgIDogICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAoJ2EsICdiKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cblxuICB2YWwgaGFzaGFibGUgOiAnYSBIYXNoYWJsZS50XG5cbiAgaW5jbHVkZSBJbnZhcmlhbnQuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICB3aXRoIHR5cGUgJ2Ega2V5ID0gJ2FcbiAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgICAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbiAgaW5jbHVkZSBNdWx0aSB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0IHdpdGggdHlwZSAnYSBrZXkgOj0gJ2Ega2V5XG5lbmRcblxubW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gc2lnXG4gIHR5cGUgKCdrLCAndikgdFxuXG4gIG1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBLZXkuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuXG4gIHZhbCBzZXhwX29mX21fX3RcbiAgICA6ICAobW9kdWxlIFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICgndiAtPiBTZXhwLnQpXG4gICAgLT4gKCdrLCAndikgdFxuICAgIC0+IFNleHAudFxuXG4gIHZhbCBtX190X29mX3NleHBcbiAgICA6ICAobW9kdWxlIE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgLT4gU2V4cC50XG4gICAgLT4gKCdrLCAndikgdFxuXG4gIHZhbCBtX190X3NleHBfZ3JhbW1hclxuICAgIDogIChtb2R1bGUgTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICgnaywgJ3YpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICB2YWwgZXF1YWxfbV9fdFxuICAgIDogIChtb2R1bGUgRXF1YWxfbSlcbiAgICAtPiAoJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gKCdrLCAndikgdFxuICAgIC0+IGJvb2xcbmVuZFxuXG5tb2R1bGUgdHlwZSBIYXNodGJsID0gc2lnXG4gICgqKiBBIGhhc2ggdGFibGUgaXMgYSBtdXRhYmxlIGRhdGEgc3RydWN0dXJlIGltcGxlbWVudGluZyBhIG1hcCBiZXR3ZWVuIGtleXMgYW5kIHZhbHVlcy5cbiAgICAgIEl0IHN1cHBvcnRzIGNvbnN0YW50LXRpbWUgbG9va3VwIGFuZCBpbi1wbGFjZSBtb2RpZmljYXRpb24uXG5cbiAgICAgIHsxIFVzYWdlfVxuXG4gICAgICBBcyBhIHNpbXBsZSBleGFtcGxlLCB3ZSdsbCBjcmVhdGUgYSBoYXNoIHRhYmxlIHdpdGggc3RyaW5nIGtleXMgdXNpbmcgdGhlXG4gICAgICB7eyFjcmVhdGV9W2NyZWF0ZV19IGNvbnN0cnVjdG9yLCB3aGljaCBleHBlY3RzIGEgbW9kdWxlIGRlZmluaW5nIHRoZSBrZXkncyB0eXBlOlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgaCA9IEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgU3RyaW5nKTs7XG4gICAgICAgIHZhbCBoIDogKHN0cmluZywgJ19hKSBIYXNodGJsLnQgPSA8YWJzdHI+XG4gICAgICBdfVxuXG4gICAgICBXZSBjYW4gc2V0IHRoZSB2YWx1ZXMgb2YgaW5kaXZpZHVhbCBrZXlzIHdpdGgge3shc2V0fVtzZXRdfS4gSWYgdGhlIGtleSBhbHJlYWR5IGhhc1xuICAgICAgYSB2YWx1ZSwgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi5cblxuICAgICAge3ZcbiAgICAgIEhhc2h0Ymwuc2V0IGggfmtleTpcImZvb1wiIH5kYXRhOjU7O1xuICAgICAgLSA6IHVuaXQgPSAoKVxuXG4gICAgICBIYXNodGJsLnNldCBoIH5rZXk6XCJmb29cIiB+ZGF0YTo2OztcbiAgICAgIC0gOiB1bml0ID0gKClcblxuICAgICAgSGFzaHRibC5zZXQgaCB+a2V5OlwiYmFyXCIgfmRhdGE6Njs7XG4gICAgICAtIDogdW5pdCA9ICgpXG4gICAgICB2fVxuXG4gICAgICBXZSBjYW4gYWNjZXNzIHZhbHVlcyBieSBrZXksIG9yIGR1bXAgYWxsIG9mIHRoZSBoYXNoIHRhYmxlJ3MgZGF0YTpcblxuICAgICAge3ZcbiAgICAgIEhhc2h0YmwuZmluZCBoIFwiZm9vXCI7O1xuICAgICAgLSA6IGludCBvcHRpb24gPSBTb21lIDZcblxuICAgICAgSGFzaHRibC5maW5kX2V4biBoIFwiZm9vXCI7O1xuICAgICAgLSA6IGludCA9IDZcblxuICAgICAgSGFzaHRibC50b19hbGlzdCBoOztcbiAgICAgIC0gOiAoc3RyaW5nICogaW50KSBsaXN0ID0gWyhcImZvb1wiLCA2KTsgKFwiYmFyXCIsIDYpXVxuICAgICAgdn1cblxuICAgICAge3shY2hhbmdlfVtjaGFuZ2VdfSBsZXRzIHVzIGNoYW5nZSBhIGtleSdzIHZhbHVlIGJ5IGFwcGx5aW5nIHRoZSBnaXZlbiBmdW5jdGlvbjpcblxuICAgICAge3ZcbiAgICAgIEhhc2h0YmwuY2hhbmdlIGggXCJmb29cIiAoZnVuIHggLT5cbiAgICAgICBtYXRjaCB4IHdpdGhcbiAgICAgICB8IFNvbWUgeCAtPiBTb21lICh4ICogMilcbiAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgKTs7XG4gICAgICAtIDogdW5pdCA9ICgpXG5cbiAgICAgIEhhc2h0YmwudG9fYWxpc3QgaDs7XG4gICAgICAtIDogKHN0cmluZyAqIGludCkgbGlzdCA9IFsoXCJmb29cIiwgMTIpOyAoXCJiYXJcIiwgNildXG4gICAgICB2fVxuXG5cbiAgICAgIFdlIGNhbiB1c2Uge3shbWVyZ2V9W21lcmdlXX0gdG8gbWVyZ2UgdHdvIGhhc2h0YWJsZXMgd2l0aCBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyXG4gICAgICBob3cgd2UgY2hvb3NlIHZhbHVlcyB3aGVuIGEga2V5IGlzIHByZXNlbnQgaW4gdGhlIGZpcnN0IChcImxlZnRcIikgaGFzaHRhYmxlLCB0aGVcbiAgICAgIHNlY29uZCAoXCJyaWdodFwiKSwgb3IgYm90aC4gSGVyZSwgd2UnbGwgY29ucyB0aGUgdmFsdWVzIHdoZW4gYm90aCBoYXNodGFibGVzIGhhdmUgYVxuICAgICAga2V5OlxuXG4gICAgICB7dlxuICAgICAgbGV0IGgxID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgNSk7ICgyLCAzMjMyKV0gaW5cbiAgICAgIGxldCBoMiA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDMpXSBpblxuICAgICAgSGFzaHRibC5tZXJnZSBoMSBoMiB+ZjooZnVuIH5rZXk6XyAtPiBmdW5jdGlvblxuICAgICAgICB8IGBMZWZ0IHggLT4gU29tZSAoYExlZnQgeClcbiAgICAgICAgfCBgUmlnaHQgeCAtPiBTb21lIChgUmlnaHQgeClcbiAgICAgICAgfCBgQm90aCAoeCwgeSkgLT4gaWYgeD15IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGBCb3RoICh4LHkpKVxuICAgICAgKSB8PiBIYXNodGJsLnRvX2FsaXN0OztcbiAgICAgIC0gOiAoaW50ICogWz4gYEJvdGggb2YgaW50ICogaW50IHwgYExlZnQgb2YgaW50IHwgYFJpZ2h0IG9mIGludCBdKSBsaXN0ID1cbiAgICAgIFsoMiwgYExlZnQgMzIzMik7ICgxLCBgQm90aCAoNSwgMykpXVxuICAgICAgdn1cblxuICAgICAgezEgSW50ZXJmYWNlfSAqKVxuXG4gIGluY2x1ZGUgU193aXRob3V0X3N1Ym1vZHVsZXMgKCoqIEBpbmxpbmUgKilcblxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMgPSBBY2Nlc3NvcnNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMgPSBDcmVhdG9yc1xuICBtb2R1bGUgdHlwZSBNdWx0aSA9IE11bHRpXG4gIG1vZHVsZSB0eXBlIFNfcG9seSA9IFNfcG9seVxuICBtb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3VibW9kdWxlcyA9IFNfd2l0aG91dF9zdWJtb2R1bGVzXG4gIG1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IEZvcl9kZXJpdmluZ1xuXG4gIG1vZHVsZSBLZXkgPSBLZXlcbiAgbW9kdWxlIE1lcmdlX2ludG9fYWN0aW9uID0gTWVyZ2VfaW50b19hY3Rpb25cblxuICB0eXBlIG5vbnJlYyAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9ucyA9ICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zXG5cbiAgbW9kdWxlIENyZWF0b3JzIChLZXkgOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBoYXNoYWJsZSA6ICdhIHQgSGFzaGFibGUudFxuICBlbmQpIDogc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XyA9ICgnYSBLZXkudCwgJ2IpIHRcblxuICAgIHZhbCB0X29mX3NleHAgOiAoU2V4cC50IC0+ICdhIEtleS50KSAtPiAoU2V4cC50IC0+ICdiKSAtPiBTZXhwLnQgLT4gKCdhLCAnYikgdF9cblxuICAgIGluY2x1ZGVcbiAgICAgIENyZWF0b3JzX2dlbmVyaWNcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdF9cbiAgICAgICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBLZXkudFxuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICAgICAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuICBlbmRcblxuICBtb2R1bGUgUG9seSA6IFNfcG9seSB3aXRoIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAoKiogW01dIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBPQ2FtbCBhcHBsaWNhdGl2ZSBmdW5jdG9yIHR5cGVzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfdGFibGUgPSBpbnQgSGFzaHRibC5NKFN0cmluZykudFxuICAgICAgXX1cblxuICAgICAgd2hpY2ggc3RhbmRzIGZvcjpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X3RhYmxlID0gKFN0cmluZy50LCBpbnQpIEhhc2h0YmwudFxuICAgICAgXX1cblxuICAgICAgVGhlIHBvaW50IGlzIHRoYXQgW2ludCBIYXNodGJsLk0oU3RyaW5nKS50XSBzdXBwb3J0cyBkZXJpdmluZywgd2hlcmVhcyB0aGUgc2Vjb25kXG4gICAgICBzeW50YXggZG9lc24ndCAoYmVjYXVzZSBbdF9vZl9zZXhwXSBkb2Vzbid0IGtub3cgd2hhdCBjb21wYXJpc29uL2hhc2ggZnVuY3Rpb24gdG9cbiAgICAgIHVzZSkuICopXG4gIG1vZHVsZSBNIChLIDogVC5UKSA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndikgdFxuICBlbmRcblxuICBpbmNsdWRlIEZvcl9kZXJpdmluZyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgKCoqLyoqKVxuXG4gICgqXyBTZWUgdGhlIEphbmUgU3RyZWV0IFN0eWxlIEd1aWRlIGZvciBhbiBleHBsYW5hdGlvbiBvZiBbUHJpdmF0ZV0gc3VibW9kdWxlczpcblxuICAgIGh0dHBzOi8vb3BlbnNvdXJjZS5qYW5lc3RyZWV0LmNvbS9zdGFuZGFyZHMvI3ByaXZhdGUtc3VibW9kdWxlcyAqKVxuICBtb2R1bGUgUHJpdmF0ZSA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG5cbiAgICB0eXBlIG5vbnJlYyAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZSA9XG4gICAgICAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuXG4gICAgdmFsIGhhc2hhYmxlIDogKCdrZXksIF8pIHQgLT4gJ2tleSBIYXNoYWJsZS50XG4gIGVuZFxuZW5kXG4iLCIoKiBBIGZldyBzbWFsbCB0aGluZ3MgY29waWVkIGZyb20gb3RoZXIgcGFydHMgb2YgQmFzZSBiZWNhdXNlIHRoZXkgZGVwZW5kIG9uIHVzLCBzbyB3ZVxuICAgY2FuJ3QgdXNlIHRoZW0uICopXG5cbm9wZW4hIEltcG9ydFxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubW9kdWxlIEludCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgbWF4ICh4IDogdCkgeSA9IGlmIHggPiB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG4oKiBJdHMgaW1wb3J0YW50IHRoYXQgRW1wdHkgaGF2ZSBubyBhcmdzLiBJdCdzIHRlbXB0aW5nIHRvIG1ha2UgdGhpcyB0eXBlIGEgcmVjb3JkXG4gICAoZS5nLiB0byBob2xkIHRoZSBjb21wYXJlIGZ1bmN0aW9uKSwgYnV0IGEgbG90IG9mIG1lbW9yeSBpcyBzYXZlZCBieSBFbXB0eSBiZWluZyBhblxuICAgaW1tZWRpYXRlLCBzaW5jZSBhbGwgdW51c2VkIGJ1Y2tldHMgaW4gdGhlIGhhc2h0YmwgZG9uJ3QgdXNlIGFueSBtZW1vcnkgKGJlc2lkZXMgdGhlXG4gICBhcnJheSBjZWxsKSAqKVxudHlwZSAoJ2ssICd2KSB0ID1cbiAgfCBFbXB0eVxuICB8IE5vZGUgb2ZcbiAgICAgIHsgbXV0YWJsZSBsZWZ0IDogKCdrLCAndikgdFxuICAgICAgOyBrZXkgOiAna1xuICAgICAgOyBtdXRhYmxlIHZhbHVlIDogJ3ZcbiAgICAgIDsgbXV0YWJsZSBoZWlnaHQgOiBpbnRcbiAgICAgIDsgbXV0YWJsZSByaWdodCA6ICgnaywgJ3YpIHRcbiAgICAgIH1cbiAgfCBMZWFmIG9mXG4gICAgICB7IGtleSA6ICdrXG4gICAgICA7IG11dGFibGUgdmFsdWUgOiAndlxuICAgICAgfVxuXG5sZXQgZW1wdHkgPSBFbXB0eVxuXG5sZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IHRydWVcbiAgfCBMZWFmIF8gfCBOb2RlIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBoZWlnaHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IDBcbiAgfCBMZWFmIF8gLT4gMVxuICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQ7IHJpZ2h0ID0gXyB9IC0+IGhlaWdodFxuOztcblxubGV0IGludmFyaWFudCBjb21wYXJlID1cbiAgbGV0IGxlZ2FsX2xlZnRfa2V5IGtleSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiB7IGtleSA9IGxlZnRfa2V5OyB2YWx1ZSA9IF8gfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBsZWZ0X2tleTsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPlxuICAgICAgYXNzZXJ0IChjb21wYXJlIGxlZnRfa2V5IGtleSA8IDApXG4gIGluXG4gIGxldCBsZWdhbF9yaWdodF9rZXkga2V5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gcmlnaHRfa2V5OyB2YWx1ZSA9IF8gfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSByaWdodF9rZXk7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT5cbiAgICAgIGFzc2VydCAoY29tcGFyZSByaWdodF9rZXkga2V5ID4gMClcbiAgaW5cbiAgbGV0IHJlYyBpbnYgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gKClcbiAgICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBrOyB2YWx1ZSA9IF87IGhlaWdodCA9IGg7IHJpZ2h0IH0gLT5cbiAgICAgIGxldCBobCwgaHIgPSBoZWlnaHQgbGVmdCwgaGVpZ2h0IHJpZ2h0IGluXG4gICAgICBpbnYgbGVmdDtcbiAgICAgIGludiByaWdodDtcbiAgICAgIGxlZ2FsX2xlZnRfa2V5IGsgbGVmdDtcbiAgICAgIGxlZ2FsX3JpZ2h0X2tleSBrIHJpZ2h0O1xuICAgICAgYXNzZXJ0IChoID0gSW50Lm1heCBobCBociArIDEpO1xuICAgICAgYXNzZXJ0IChhYnMgKGhsIC0gaHIpIDw9IDIpXG4gIGluXG4gIGludlxuOztcblxubGV0IGludmFyaWFudCB0IH5jb21wYXJlID0gaW52YXJpYW50IGNvbXBhcmUgdFxuXG4oKiBJbiB0aGUgZm9sbG93aW5nIGNvbW1lbnRzLFxuICAgJ3QgaXMgYmFsYW5jZWQnIG1lYW5zIHRoYXQgJ2ludmFyaWFudCB0JyBkb2VzIG5vdFxuICAgcmFpc2UgYW4gZXhjZXB0aW9uLiAgVGhpcyBpbXBsaWVzIG9mIGNvdXJzZSB0aGF0IGVhY2ggbm9kZSdzIGhlaWdodCBmaWVsZCBpc1xuICAgY29ycmVjdC5cbiAgICd0IGlzIGJhbGFuY2VhYmxlJyBtZWFucyB0aGF0IGhlaWdodCBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgb2YgdFxuICAgZGlmZmVyIGJ5IGF0IG1vc3QgMy4gKilcblxuKCogQHByZTogbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgaGF2ZSBjb3JyZWN0IGhlaWdodHNcbiAgIEBwb3N0OiBvdXRwdXQgaGFzIHRoZSBjb3JyZWN0IGhlaWdodCAqKVxubGV0IHVwZGF0ZV9oZWlnaHQgPSBmdW5jdGlvblxuICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBvbGRfaGVpZ2h0OyByaWdodCB9IGFzIHgpIC0+XG4gICAgbGV0IG5ld19oZWlnaHQgPSBJbnQubWF4IChoZWlnaHQgbGVmdCkgKGhlaWdodCByaWdodCkgKyAxIGluXG4gICAgaWYgbmV3X2hlaWdodCA8PiBvbGRfaGVpZ2h0IHRoZW4geC5oZWlnaHQgPC0gbmV3X2hlaWdodFxuICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxuKCogQHByZTogbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgYXJlIGJhbGFuY2VkXG4gICBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcG9zdDogb3V0cHV0IGlzIGJhbGFuY2VkIChpbiBwYXJ0aWN1bGFyLCBoZWlnaHQgaXMgY29ycmVjdCkgKilcbmxldCBiYWxhbmNlIHRyZWUgPVxuICBtYXRjaCB0cmVlIHdpdGhcbiAgfCBFbXB0eSB8IExlYWYgXyAtPiB0cmVlXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgcm9vdF9ub2RlKSAtPlxuICAgIGxldCBobCA9IGhlaWdodCBsZWZ0XG4gICAgYW5kIGhyID0gaGVpZ2h0IHJpZ2h0IGluXG4gICAgKCogKyAyIGlzIGNyaXRpY2FsbHkgaW1wb3J0YW50LCBsb3dlcmluZyBpdCB0byAxIHdpbGwgYnJlYWsgdGhlIExlYWZcbiAgICAgICBhc3N1bXB0aW9ucyBpbiB0aGUgY29kZSBiZWxvdywgYW5kIHdpbGwgZm9yY2UgdXMgdG8gcHJvbW90ZSBsZWFmIG5vZGVzIGluXG4gICAgICAgdGhlIGJhbGFuY2Ugcm91dGluZS4gSXQncyBhbHNvIGZhc3Rlciwgc2luY2UgaXQgd2lsbCBiYWxhbmNlIGxlc3Mgb2Z0ZW4uXG4gICAgICAgTm90ZSB0aGF0IHRoZSBmb2xsb3dpbmcgY29kZSBpcyBkZWxpY2F0ZS4gIFRoZSB1cGRhdGVfaGVpZ2h0IGNhbGxzIG11c3RcbiAgICAgICBvY2N1ciBpbiB0aGUgY29ycmVjdCBvcmRlciwgc2luY2UgdXBkYXRlX2hlaWdodCBhc3N1bWVzIGl0cyBjaGlsZHJlbiBoYXZlXG4gICAgICAgdGhlIGNvcnJlY3QgaGVpZ2h0cy4gICopXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGxlZnQgd2l0aFxuICAgICAgKCogSXQgY2Fubm90IGJlIGEgbGVhZiwgYmVjYXVzZSBldmVuIGlmIHJpZ2h0IGlzIGVtcHR5LCBhIGxlYWZcbiAgICAgICAgIGlzIG9ubHkgaGVpZ2h0IDEgKilcbiAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IE5vZGVcbiAgICAgICAgICAoeyBsZWZ0ID0gbGVmdF9ub2RlX2xlZnRcbiAgICAgICAgICAgOyBrZXkgPSBfXG4gICAgICAgICAgIDsgdmFsdWUgPSBfXG4gICAgICAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgICAgICA7IHJpZ2h0ID0gbGVmdF9ub2RlX3JpZ2h0XG4gICAgICAgICAgIH0gYXMgbGVmdF9ub2RlKSAtPlxuICAgICAgICBpZiBoZWlnaHQgbGVmdF9ub2RlX2xlZnQgPj0gaGVpZ2h0IGxlZnRfbm9kZV9yaWdodFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByb290X25vZGUubGVmdCA8LSBsZWZ0X25vZGVfcmlnaHQ7XG4gICAgICAgICAgbGVmdF9ub2RlLnJpZ2h0IDwtIHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdDtcbiAgICAgICAgICBsZWZ0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBpZiByaWdodCBpcyBhIGxlYWYsIHRoZW4gbGVmdCBtdXN0IGJlIGVtcHR5LiBUaGF0IG1lYW5zXG4gICAgICAgICAgICAgaGVpZ2h0IGlzIDIuIEV2ZW4gaWYgaHIgaXMgZW1wdHkgd2Ugc3RpbGwgY2FuJ3QgZ2V0IGhlcmUuICopXG4gICAgICAgICAgbWF0Y2ggbGVmdF9ub2RlX3JpZ2h0IHdpdGhcbiAgICAgICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTm9kZVxuICAgICAgICAgICAgICAoeyBsZWZ0ID0gbHJfbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IGxyX3JpZ2h0IH0gYXNcbiAgICAgICAgICAgICAgbHJfbm9kZSkgLT5cbiAgICAgICAgICAgIGxlZnRfbm9kZS5yaWdodCA8LSBscl9sZWZ0O1xuICAgICAgICAgICAgcm9vdF9ub2RlLmxlZnQgPC0gbHJfcmlnaHQ7XG4gICAgICAgICAgICBscl9ub2RlLnJpZ2h0IDwtIHRyZWU7XG4gICAgICAgICAgICBscl9ub2RlLmxlZnQgPC0gbGVmdDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdF9ub2RlX3JpZ2h0O1xuICAgICAgICAgICAgbGVmdF9ub2RlX3JpZ2h0KSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICAoKiBzZWUgYWJvdmUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSByaWdodCBjYW5ub3QgYmUgYSBsZWFmICopXG4gICAgICBtYXRjaCByaWdodCB3aXRoXG4gICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBOb2RlXG4gICAgICAgICAgKHsgbGVmdCA9IHJpZ2h0X25vZGVfbGVmdFxuICAgICAgICAgICA7IGtleSA9IF9cbiAgICAgICAgICAgOyB2YWx1ZSA9IF9cbiAgICAgICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICAgICAgIDsgcmlnaHQgPSByaWdodF9ub2RlX3JpZ2h0XG4gICAgICAgICAgIH0gYXMgcmlnaHRfbm9kZSkgLT5cbiAgICAgICAgaWYgaGVpZ2h0IHJpZ2h0X25vZGVfcmlnaHQgPj0gaGVpZ2h0IHJpZ2h0X25vZGVfbGVmdFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByb290X25vZGUucmlnaHQgPC0gcmlnaHRfbm9kZV9sZWZ0O1xuICAgICAgICAgIHJpZ2h0X25vZGUubGVmdCA8LSB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0O1xuICAgICAgICAgIHJpZ2h0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBzZWUgYWJvdmUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIGNhbm5vdCBiZSBhIGxlYWYgKilcbiAgICAgICAgICBtYXRjaCByaWdodF9ub2RlX2xlZnQgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBOb2RlXG4gICAgICAgICAgICAgICh7IGxlZnQgPSBybF9sZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gcmxfcmlnaHQgfSBhc1xuICAgICAgICAgICAgICBybF9ub2RlKSAtPlxuICAgICAgICAgICAgcmlnaHRfbm9kZS5sZWZ0IDwtIHJsX3JpZ2h0O1xuICAgICAgICAgICAgcm9vdF9ub2RlLnJpZ2h0IDwtIHJsX2xlZnQ7XG4gICAgICAgICAgICBybF9ub2RlLmxlZnQgPC0gdHJlZTtcbiAgICAgICAgICAgIHJsX25vZGUucmlnaHQgPC0gcmlnaHQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCByaWdodF9ub2RlX2xlZnQ7XG4gICAgICAgICAgICByaWdodF9ub2RlX2xlZnQpKVxuICAgIGVsc2UgKFxuICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgdHJlZSlcbjs7XG5cbigqIEBwcmU6IHQgaXMgYmFsYW5jZWQuXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VkLCB3aXRoIG5ldyBub2RlIGluc2VydGVkXG4gICBAcG9zdDogIWFkZGVkID0gdHJ1ZSBpZmYgdGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0cmVlIGNoYW5nZWQuICAqKVxubGV0IHJlYyBhZGQgdCB+cmVwbGFjZSB+Y29tcGFyZSB+YWRkZWQgfmtleTprIH5kYXRhOnYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPlxuICAgIGFkZGVkIDo9IHRydWU7XG4gICAgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gIHwgTGVhZiAoeyBrZXkgPSBrJzsgdmFsdWUgPSBfIH0gYXMgcikgLT5cbiAgICBsZXQgYyA9IGNvbXBhcmUgaycgayBpblxuICAgICgqIFRoaXMgY29tcGFyZSBpcyByZXZlcnNlZCBvbiBwdXJwb3NlLCB3ZSBhcmUgcHJldGVuZGluZ1xuICAgICAgIHRoYXQgdGhlIGxlYWYgd2FzIGp1c3QgaW5zZXJ0ZWQgaW5zdGVhZCBvZiB0aGUgb3RoZXIgd2F5XG4gICAgICAgcm91bmQsIHRoYXQgd2F5IHdlIG9ubHkgYWxsb2NhdGUgb25lIG5vZGUuICopXG4gICAgaWYgYyA9IDBcbiAgICB0aGVuIChcbiAgICAgIGFkZGVkIDo9IGZhbHNlO1xuICAgICAgaWYgcmVwbGFjZSB0aGVuIHIudmFsdWUgPC0gdjtcbiAgICAgIHQpXG4gICAgZWxzZSAoXG4gICAgICBhZGRlZCA6PSB0cnVlO1xuICAgICAgaWYgYyA8IDBcbiAgICAgIHRoZW4gTm9kZSB7IGxlZnQgPSB0OyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IDI7IHJpZ2h0ID0gRW1wdHkgfVxuICAgICAgZWxzZSBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IDI7IHJpZ2h0ID0gdCB9KVxuICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByKSAtPlxuICAgIGxldCBjID0gY29tcGFyZSBrIGsnIGluXG4gICAgaWYgYyA9IDBcbiAgICB0aGVuIChcbiAgICAgIGFkZGVkIDo9IGZhbHNlO1xuICAgICAgaWYgcmVwbGFjZSB0aGVuIHIudmFsdWUgPC0gdjtcbiAgICAgIHQpXG4gICAgZWxzZSAoXG4gICAgICBpZiBjIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBsZWZ0JyA9IGFkZCBsZWZ0IH5yZXBsYWNlIH5hZGRlZCB+Y29tcGFyZSB+a2V5OmsgfmRhdGE6diBpblxuICAgICAgICBpZiBub3QgKHBoeXNfZXF1YWwgbGVmdCcgbGVmdCkgdGhlbiByLmxlZnQgPC0gbGVmdCcpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJpZ2h0JyA9IGFkZCByaWdodCB+cmVwbGFjZSB+YWRkZWQgfmNvbXBhcmUgfmtleTprIH5kYXRhOnYgaW5cbiAgICAgICAgaWYgbm90IChwaHlzX2VxdWFsIHJpZ2h0JyByaWdodCkgdGhlbiByLnJpZ2h0IDwtIHJpZ2h0Jyk7XG4gICAgICBpZiAhYWRkZWQgdGhlbiBiYWxhbmNlIHQgZWxzZSB0KVxuOztcblxubGV0IHJlYyBmaXJzdCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gU29tZSAoaywgdilcbiAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gZmlyc3QgbFxuOztcblxubGV0IHJlYyBsYXN0IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0ID0gRW1wdHkgfSAtPiBTb21lIChrLCB2KVxuICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IHIgfSAtPiBsYXN0IHJcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gcmVjIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgdFxuICB+Y29tcGFyZVxuICBrXG4gIGFyZzFcbiAgYXJnMlxuICB+Y2FsbF9pZl9mb3VuZFxuICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgfmlmX2ZvdW5kXG4gIH5pZl9ub3RfZm91bmRcbiAgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGsgYXJnMSBhcmcyXG4gIHwgTGVhZiB7IGtleSA9IGsnOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmUgayBrJyA9IDBcbiAgICB0aGVuIGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6aycgfmRhdGE6diBhcmcxIGFyZzJcbiAgICBlbHNlIGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQgayBhcmcxIGFyZzJcbiAgfCBOb2RlIHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGxldCBjID0gY29tcGFyZSBrIGsnIGluXG4gICAgaWYgYyA9IDBcbiAgICB0aGVuIGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6aycgfmRhdGE6diBhcmcxIGFyZzJcbiAgICBlbHNlXG4gICAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICAgIChpZiBjIDwgMCB0aGVuIGxlZnQgZWxzZSByaWdodClcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAga1xuICAgICAgICBhcmcxXG4gICAgICAgIGFyZzJcbiAgICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICAgIH5pZl9mb3VuZFxuICAgICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbCA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5Ol8gfmRhdGEgKCkgKCkgPSBpZl9mb3VuZCBkYXRhIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSAoKSAoKSA9IGlmX25vdF9mb3VuZCBrZXkgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICAoKVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgKCkgKCkgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSAoKSAoKSA9IGlmX25vdF9mb3VuZCBrZXkgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICAoKVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwxID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSBhcmcgKCkgPSBpZl9mb3VuZCBkYXRhIGFyZyBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnICgpID0gaWZfbm90X2ZvdW5kIGtleSBhcmcgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwxID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnICgpID0gaWZfZm91bmQgfmtleSB+ZGF0YSBhcmcgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZyAoKSA9IGlmX25vdF9mb3VuZCBrZXkgYXJnIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwyID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSBhcmcxIGFyZzIgPSBpZl9mb3VuZCBkYXRhIGFyZzEgYXJnMiBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyID0gaWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICBiXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDIgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleSB+ZGF0YSBhcmcxIGFyZzIgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGFyZzEgYXJnMiBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyID0gaWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICBiXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kID1cbiAgbGV0IGlmX2ZvdW5kIHYgPSBTb21lIHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gTm9uZSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIC0+IGZpbmRfYW5kX2NhbGwgdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgbWVtID1cbiAgbGV0IGlmX2ZvdW5kIF8gPSB0cnVlIGluXG4gIGxldCBpZl9ub3RfZm91bmQgXyA9IGZhbHNlIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgLT4gZmluZF9hbmRfY2FsbCB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCByZWMgcmVtb3ZlID1cbiAgbGV0IHJlYyBtaW5fZWx0IHRyZWUgPVxuICAgIG1hdGNoIHRyZWUgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgXyAtPiB0cmVlXG4gICAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IHRyZWVcbiAgICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IG1pbl9lbHQgbGVmdFxuICBpblxuICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0IHRyZWUgPVxuICAgIG1hdGNoIHRyZWUgd2l0aFxuICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBMZWFmIF8gLT4gRW1wdHlcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPiByaWdodFxuICAgIHwgTm9kZSB7IGxlZnQgPSBMZWFmIF87IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBFbXB0eSB9IC0+XG4gICAgICBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSBhcyByKSAtPlxuICAgICAgci5sZWZ0IDwtIHJlbW92ZV9taW5fZWx0IGxlZnQ7XG4gICAgICBiYWxhbmNlIHRyZWVcbiAgaW5cbiAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgLT4gdFxuICAgIHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPlxuICAgICAgbGV0IHRyZWUgPSBtaW5fZWx0IHQyIGluXG4gICAgICBiYWxhbmNlXG4gICAgICAgIChtYXRjaCB0cmVlIHdpdGhcbiAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICB8IExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgICAgICAgICBsZXQgdDIgPSByZW1vdmVfbWluX2VsdCB0MiBpblxuICAgICAgICAgICBOb2RlXG4gICAgICAgICAgICAgeyBsZWZ0ID0gdDFcbiAgICAgICAgICAgICA7IGtleSA9IGtcbiAgICAgICAgICAgICA7IHZhbHVlID0gdlxuICAgICAgICAgICAgIDsgaGVpZ2h0ID0gSW50Lm1heCAoaGVpZ2h0IHQxKSAoaGVpZ2h0IHQyKSArIDFcbiAgICAgICAgICAgICA7IHJpZ2h0ID0gdDJcbiAgICAgICAgICAgICB9XG4gICAgICAgICB8IE5vZGUgciAtPlxuICAgICAgICAgICByLnJpZ2h0IDwtIHJlbW92ZV9taW5fZWx0IHQyO1xuICAgICAgICAgICByLmxlZnQgPC0gdDE7XG4gICAgICAgICAgIHRyZWUpXG4gIGluXG4gIGZ1biB0IH5yZW1vdmVkIH5jb21wYXJlIGsgLT5cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICByZW1vdmVkIDo9IGZhbHNlO1xuICAgICAgRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSBrJzsgdmFsdWUgPSBfIH0gLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrJyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICByZW1vdmVkIDo9IHRydWU7XG4gICAgICAgIEVtcHR5KVxuICAgICAgZWxzZSAoXG4gICAgICAgIHJlbW92ZWQgOj0gZmFsc2U7XG4gICAgICAgIHQpXG4gICAgfCBOb2RlICh7IGxlZnQ7IGtleSA9IGsnOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgcikgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBrIGsnIGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlbW92ZWQgOj0gdHJ1ZTtcbiAgICAgICAgbWVyZ2UgbGVmdCByaWdodClcbiAgICAgIGVsc2UgKFxuICAgICAgICBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbGVmdCcgPSByZW1vdmUgbGVmdCB+cmVtb3ZlZCB+Y29tcGFyZSBrIGluXG4gICAgICAgICAgaWYgbm90IChwaHlzX2VxdWFsIGxlZnQnIGxlZnQpIHRoZW4gci5sZWZ0IDwtIGxlZnQnKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgcmlnaHQnID0gcmVtb3ZlIHJpZ2h0IH5yZW1vdmVkIH5jb21wYXJlIGsgaW5cbiAgICAgICAgICBpZiBub3QgKHBoeXNfZXF1YWwgcmlnaHQnIHJpZ2h0KSB0aGVuIHIucmlnaHQgPC0gcmlnaHQnKTtcbiAgICAgICAgaWYgIXJlbW92ZWQgdGhlbiBiYWxhbmNlIHQgZWxzZSB0KVxuOztcblxubGV0IHJlYyBmb2xkIHQgfmluaXQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBpbml0XG4gIHwgTGVhZiB7IGtleTsgdmFsdWUgPSBkYXRhIH0gLT4gZiB+a2V5IH5kYXRhIGluaXRcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0gbGtleTsgdmFsdWUgPSBsZGF0YSB9XG4gICAgICA7IGtleVxuICAgICAgOyB2YWx1ZSA9IGRhdGFcbiAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgOyByaWdodCA9IExlYWYgeyBrZXkgPSBya2V5OyB2YWx1ZSA9IHJkYXRhIH1cbiAgICAgIH0gLT4gZiB+a2V5OnJrZXkgfmRhdGE6cmRhdGEgKGYgfmtleSB+ZGF0YSAoZiB+a2V5OmxrZXkgfmRhdGE6bGRhdGEgaW5pdCkpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGxrZXk7IHZhbHVlID0gbGRhdGEgfVxuICAgICAgOyBrZXlcbiAgICAgIDsgdmFsdWUgPSBkYXRhXG4gICAgICA7IGhlaWdodCA9IF9cbiAgICAgIDsgcmlnaHQgPSBFbXB0eVxuICAgICAgfSAtPiBmIH5rZXkgfmRhdGEgKGYgfmtleTpsa2V5IH5kYXRhOmxkYXRhIGluaXQpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gRW1wdHlcbiAgICAgIDsga2V5XG4gICAgICA7IHZhbHVlID0gZGF0YVxuICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICA7IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHJrZXk7IHZhbHVlID0gcmRhdGEgfVxuICAgICAgfSAtPiBmIH5rZXk6cmtleSB+ZGF0YTpyZGF0YSAoZiB+a2V5IH5kYXRhIGluaXQpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBMZWFmIHsga2V5ID0gcmtleTsgdmFsdWUgPSByZGF0YSB9IH1cbiAgICAtPiBmIH5rZXk6cmtleSB+ZGF0YTpyZGF0YSAoZiB+a2V5IH5kYXRhIChmb2xkIGxlZnQgfmluaXQgfmYpKVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBsa2V5OyB2YWx1ZSA9IGxkYXRhIH07IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCB9XG4gICAgLT4gZm9sZCByaWdodCB+aW5pdDooZiB+a2V5IH5kYXRhIChmIH5rZXk6bGtleSB+ZGF0YTpsZGF0YSBpbml0KSkgfmZcbiAgfCBOb2RlIHsgbGVmdDsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICBmb2xkIHJpZ2h0IH5pbml0OihmIH5rZXkgfmRhdGEgKGZvbGQgbGVmdCB+aW5pdCB+ZikpIH5mXG47O1xuXG5sZXQgcmVjIGl0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+ICgpXG4gIHwgTGVhZiB7IGtleTsgdmFsdWUgPSBkYXRhIH0gLT4gZiB+a2V5IH5kYXRhXG4gIHwgTm9kZSB7IGxlZnQ7IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCB9IC0+XG4gICAgaXRlciBsZWZ0IH5mO1xuICAgIGYgfmtleSB+ZGF0YTtcbiAgICBpdGVyIHJpZ2h0IH5mXG47O1xuXG5sZXQgcmVjIG1hcGlfaW5wbGFjZSB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gKClcbiAgfCBMZWFmICh7IGtleTsgdmFsdWUgfSBhcyB0KSAtPiB0LnZhbHVlIDwtIGYgfmtleSB+ZGF0YTp2YWx1ZVxuICB8IE5vZGUgKHsgbGVmdDsga2V5OyB2YWx1ZTsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyB0KSAtPlxuICAgIG1hcGlfaW5wbGFjZSB+ZiBsZWZ0O1xuICAgIHQudmFsdWUgPC0gZiB+a2V5IH5kYXRhOnZhbHVlO1xuICAgIG1hcGlfaW5wbGFjZSB+ZiByaWdodFxuOztcblxubGV0IGNob29zZV9leG4gPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltBdmx0cmVlLmNob29zZV9leG5dIG9mIGVtcHR5IGhhc2h0YmxcIiBbXSlcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZTsgXyB9IHwgTm9kZSB7IGtleTsgdmFsdWU7IF8gfSAtPiBrZXksIHZhbHVlXG47O1xuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEhhc2h0YmxfaW50ZlxuXG5tb2R1bGUgdHlwZSBLZXkgPSBLZXkuU1xuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxubGV0IGhhc2hfcGFyYW0gPSBIYXNoYWJsZS5oYXNoX3BhcmFtXG5sZXQgaGFzaCA9IEhhc2hhYmxlLmhhc2hcbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG50eXBlICgnaywgJ3YpIHQgPVxuICB7IG11dGFibGUgdGFibGUgOiAoJ2ssICd2KSBBdmx0cmVlLnQgYXJyYXlcbiAgOyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICA7IGdyb3d0aF9hbGxvd2VkIDogYm9vbFxuICA7IGhhc2hhYmxlIDogJ2sgSGFzaGFibGUudFxuICA7IG11dGFibGUgbXV0YXRpb25fYWxsb3dlZCA6IGJvb2wgKCogU2V0IGR1cmluZyBhbGwgaXRlcmF0aW9uIG9wZXJhdGlvbnMgKilcbiAgfVxuXG50eXBlICdhIGtleSA9ICdhXG5cbmxldCBzZXhwX29mX2tleSB0ID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5zZXhwX29mX3RcbmxldCBjb21wYXJlX2tleSB0ID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5jb21wYXJlXG5cbmxldCBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0ID1cbiAgaWYgbm90IHQubXV0YXRpb25fYWxsb3dlZCB0aGVuIGZhaWx3aXRoIFwiSGFzaHRibDogbXV0YXRpb24gbm90IGFsbG93ZWQgZHVyaW5nIGl0ZXJhdGlvblwiXG47O1xuXG5sZXQgd2l0aG91dF9tdXRhdGluZyB0IGYgPVxuICBpZiB0Lm11dGF0aW9uX2FsbG93ZWRcbiAgdGhlbiAoXG4gICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgIG1hdGNoIGYgKCkgd2l0aFxuICAgIHwgeCAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIHRydWU7XG4gICAgICB4XG4gICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gdHJ1ZTtcbiAgICAgIHJhaXNlIGV4bilcbiAgZWxzZSBmICgpXG47O1xuXG4oKiogSW50ZXJuYWxseSB1c2UgYSBtYXhpbXVtIHNpemUgdGhhdCBpcyBhIHBvd2VyIG9mIDIuIFJldmVyc2VzIHRoZSBhYm92ZSB0byBmaW5kIHRoZVxuICAgIGZsb29yIHBvd2VyIG9mIDIgYmVsb3cgdGhlIHN5c3RlbSBtYXggYXJyYXkgbGVuZ3RoICopXG5sZXQgbWF4X3RhYmxlX2xlbmd0aCA9IEludC5mbG9vcl9wb3cyIEFycmF5Lm1heF9sZW5ndGhcblxuKCogVGhlIGRlZmF1bHQgc2l6ZSBpcyBjaG9zZW4gdG8gYmUgMCAoYXMgb3Bwb3NlZCB0byAxMjggYXMgaXQgd2FzIGJlZm9yZSkgYmVjYXVzZTpcbiAgIC0gMTI4IGNhbiBjcmVhdGUgc3Vic3RhbnRpYWwgbWVtb3J5IG92ZXJoZWFkICh4MTApIHdoZW4gY3JlYXRpbmcgbWFueSB0YWJsZXMsIG1vc3RcbiAgICAgb2Ygd2hpY2ggYXJlIG5vdCBiaWcgKHNheSwgaWYgeW91IGhhdmUgYSBoYXNodGJsIG9mIGhhc2h0YmwpLiBBbmQgbWVtb3J5IG92ZXJoZWFkIGlzXG4gICAgIG5vdCB0aGF0IGVhc3kgdG8gcHJvZmlsZS5cbiAgIC0gaWYgYSBoYXNodGJsIGlzIGdvaW5nIHRvIGdyb3csIGl0J3Mgbm90IGNsZWFyIHdoeSAxMjggaXMgbWFya2VkbHkgYmV0dGVyIHRoYW4gb3RoZXJcbiAgICAgc2l6ZXMgKGlmIHlvdSBnb2luZyB0byBzdGljayAxMDAwIGVsZW1lbnRzLCB5b3UncmUgZ29pbmcgdG8gZ3JvdyB0aGUgaGFzaHRhYmxlIG9uY2VcbiAgICAgb3IgdHdpY2UgYW55d2F5KVxuICAgLSBpbiBvdGhlciBsYW5ndWFnZXMgKGxpa2UgcnVzdCwgcHl0aG9uLCBhbmQgYXBwYXJlbnRseSBnbyksIHRoZSBkZWZhdWx0IGlzIGFsc28gYVxuICAgICBzbWFsbCBzaXplLiAqKVxubGV0IGNyZWF0ZSA/KGdyb3d0aF9hbGxvd2VkID0gdHJ1ZSkgPyhzaXplID0gMCkgfmhhc2hhYmxlICgpID1cbiAgbGV0IHNpemUgPSBJbnQubWluIChJbnQubWF4IDEgc2l6ZSkgbWF4X3RhYmxlX2xlbmd0aCBpblxuICBsZXQgc2l6ZSA9IEludC5jZWlsX3BvdzIgc2l6ZSBpblxuICB7IHRhYmxlID0gQXJyYXkuY3JlYXRlIH5sZW46c2l6ZSBBdmx0cmVlLmVtcHR5XG4gIDsgbGVuZ3RoID0gMFxuICA7IGdyb3d0aF9hbGxvd2VkXG4gIDsgaGFzaGFibGVcbiAgOyBtdXRhdGlvbl9hbGxvd2VkID0gdHJ1ZVxuICB9XG47O1xuXG4oKiogU3VwcGxlbWVudGFsIGhhc2guIFRoaXMgbWF5IG5vdCBiZSBuZWNlc3NhcnksIGl0IGlzIGludGVuZGVkIGFzIGEgZGVmZW5zZSBhZ2FpbnN0IHBvb3JcbiAgICBoYXNoIGZ1bmN0aW9ucywgZm9yIHdoaWNoIHRoZSBwb3dlciBvZiAyIHNpemVkIHRhYmxlIHdpbGwgYmUgZXNwZWNpYWxseSBzZW5zaXRpdmUuXG4gICAgV2l0aCBzb21lIHRlc3Rpbmcgd2UgbWF5IGNob29zZSB0byBhZGQgaXQsIGJ1dCB0aGlzIHRhYmxlIGlzIGRlc2lnbmVkIHRvIGJlIHJvYnVzdCB0b1xuICAgIGNvbGxpc2lvbnMsIGFuZCBpbiBtb3N0IG9mIG15IHRlc3RpbmcgdGhpcyBkZWdyYWRlcyBwZXJmb3JtYW5jZS4gKilcbmxldCBfc3VwcGxlbWVudGFsX2hhc2ggaCA9XG4gIGxldCBoID0gaCBseG9yICgoaCBsc3IgMjApIGx4b3IgKGggbHNyIDEyKSkgaW5cbiAgaCBseG9yIChoIGxzciA3KSBseG9yIChoIGxzciA0KVxuOztcblxubGV0IHNsb3QgdCBrZXkgPVxuICBsZXQgaGFzaCA9IHQuaGFzaGFibGUuSGFzaGFibGUuaGFzaCBrZXkgaW5cbiAgKCogdGhpcyBpcyBhbHdheXMgbm9uLW5lZ2F0aXZlIGJlY2F1c2Ugd2UgZG8gW2xhbmRdIHdpdGggbm9uLW5lZ2F0aXZlIG51bWJlciAqKVxuICBoYXNoIGxhbmQgKEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSlcbjs7XG5cbmxldCBhZGRfd29ya2VyIHQgfnJlcGxhY2UgfmtleSB+ZGF0YSA9XG4gIGxldCBpID0gc2xvdCB0IGtleSBpblxuICBsZXQgcm9vdCA9IHQudGFibGUuKGkpIGluXG4gIGxldCBhZGRlZCA9IHJlZiBmYWxzZSBpblxuICBsZXQgbmV3X3Jvb3QgPVxuICAgICgqIFRoZSBhdmwgdHJlZSBtaWdodCByZXBsYWNlIHRoZSB2YWx1ZSBbcmVwbGFjZT10cnVlXSBvciBkbyBub3RoaW5nIFtyZXBsYWNlPWZhbHNlXVxuICAgICAgIHRvIHRoZSBlbnRyeSwgaW4gdGhhdCBjYXNlIHRoZSB0YWJsZSBkaWQgbm90IGdldCBiaWdnZXIsIHNvIHdlIHNob3VsZCBub3RcbiAgICAgICBpbmNyZW1lbnQgbGVuZ3RoLCB3ZSBwYXNzIGluIHRoZSBib29sIHJlZiB0LmFkZGVkIHNvIHRoYXQgaXQgY2FuIHRlbGwgdXMgd2hldGhlclxuICAgICAgIGl0IGFkZGVkIG9yIHJlcGxhY2VkLiBXZSBkbyBpdCB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uLiBTaW5jZSB0aGUgYm9vbFxuICAgICAgIGlzIGFuIGltbWVkaWF0ZSBpdCBkb2VzIG5vdCBnbyB0aHJvdWdoIHRoZSB3cml0ZSBiYXJyaWVyLiAqKVxuICAgIEF2bHRyZWUuYWRkIH5yZXBsYWNlIHJvb3QgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIH5hZGRlZCB+a2V5IH5kYXRhXG4gIGluXG4gIGlmICFhZGRlZCB0aGVuIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMTtcbiAgKCogVGhpcyBsaXR0bGUgb3B0aW1pemF0aW9uIHNhdmVzIGEgY2FtbF9tb2RpZnkgd2hlbiB0aGUgdHJlZVxuICAgICBoYXNuJ3QgYmVlbiByZWJhbGFuY2VkLiAqKVxuICBpZiBub3QgKHBoeXNfZXF1YWwgbmV3X3Jvb3Qgcm9vdCkgdGhlbiB0LnRhYmxlLihpKSA8LSBuZXdfcm9vdDtcbiAgIWFkZGVkXG47O1xuXG5sZXQgbWF5YmVfcmVzaXplX3RhYmxlIHQgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgbGV0IHNob3VsZF9ncm93ID0gdC5sZW5ndGggPiBsZW4gaW5cbiAgaWYgc2hvdWxkX2dyb3cgJiYgdC5ncm93dGhfYWxsb3dlZFxuICB0aGVuIChcbiAgICBsZXQgbmV3X2FycmF5X2xlbmd0aCA9IEludC5taW4gKGxlbiAqIDIpIG1heF90YWJsZV9sZW5ndGggaW5cbiAgICBpZiBuZXdfYXJyYXlfbGVuZ3RoID4gbGVuXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbmV3X3RhYmxlID0gQXJyYXkuY3JlYXRlIH5sZW46bmV3X2FycmF5X2xlbmd0aCBBdmx0cmVlLmVtcHR5IGluXG4gICAgICBsZXQgb2xkX3RhYmxlID0gdC50YWJsZSBpblxuICAgICAgdC50YWJsZSA8LSBuZXdfdGFibGU7XG4gICAgICB0Lmxlbmd0aCA8LSAwO1xuICAgICAgbGV0IGYgfmtleSB+ZGF0YSA9IGlnbm9yZSAoYWRkX3dvcmtlciB+cmVwbGFjZTp0cnVlIHQgfmtleSB+ZGF0YSA6IGJvb2wpIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIG9sZF90YWJsZSAtIDEgZG9cbiAgICAgICAgQXZsdHJlZS5pdGVyIG9sZF90YWJsZS4oaSkgfmZcbiAgICAgIGRvbmUpKVxuOztcblxubGV0IGNhcGFjaXR5IHQgPSBBcnJheS5sZW5ndGggdC50YWJsZVxuXG5sZXQgc2V0IHQgfmtleSB+ZGF0YSA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGlnbm9yZSAoYWRkX3dvcmtlciB+cmVwbGFjZTp0cnVlIHQgfmtleSB+ZGF0YSA6IGJvb2wpO1xuICBtYXliZV9yZXNpemVfdGFibGUgdFxuOztcblxubGV0IGFkZCB0IH5rZXkgfmRhdGEgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBsZXQgYWRkZWQgPSBhZGRfd29ya2VyIH5yZXBsYWNlOmZhbHNlIHQgfmtleSB+ZGF0YSBpblxuICBpZiBhZGRlZFxuICB0aGVuIChcbiAgICBtYXliZV9yZXNpemVfdGFibGUgdDtcbiAgICBgT2spXG4gIGVsc2UgYER1cGxpY2F0ZVxuOztcblxubGV0IGFkZF9leG4gdCB+a2V5IH5kYXRhID1cbiAgbWF0Y2ggYWRkIHQgfmtleSB+ZGF0YSB3aXRoXG4gIHwgYE9rIC0+ICgpXG4gIHwgYER1cGxpY2F0ZSAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5IHQgaW5cbiAgICBsZXQgZXJyb3IgPSBFcnJvci5jcmVhdGUgXCJIYXNodGJsLmFkZF9leG4gZ290IGtleSBhbHJlYWR5IHByZXNlbnRcIiBrZXkgc2V4cF9vZl9rZXkgaW5cbiAgICBFcnJvci5yYWlzZSBlcnJvclxuOztcblxubGV0IGNsZWFyIHQgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgdC50YWJsZS4oaSkgPC0gQXZsdHJlZS5lbXB0eVxuICBkb25lO1xuICB0Lmxlbmd0aCA8LSAwXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gICgqIHdpdGggYSBnb29kIGhhc2ggZnVuY3Rpb24gdGhlc2UgZmlyc3QgdHdvIGNhc2VzIHdpbGwgYmUgdGhlIG92ZXJ3aGVsbWluZyBtYWpvcml0eSxcbiAgICAgYW5kIEF2bHRyZWUuZmluZCBpcyByZWN1cnNpdmUsIHNvIGl0IGNhbid0IGJlIGlubGluZWQsIHNvIGRvaW5nIHRoaXMgYXZvaWRzIGFcbiAgICAgZnVuY3Rpb24gY2FsbCBpbiBtb3N0IGNhc2VzLiAqKVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5XG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgZWxzZSBpZl9ub3RfZm91bmQga2V5XG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZF9hbmRfY2FsbCB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMSB0IGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB2IGEgZWxzZSBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsMSB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMiB0IGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgYSBiIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsMiB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gICgqIHdpdGggYSBnb29kIGhhc2ggZnVuY3Rpb24gdGhlc2UgZmlyc3QgdHdvIGNhc2VzIHdpbGwgYmUgdGhlIG92ZXJ3aGVsbWluZyBtYWpvcml0eSxcbiAgICAgYW5kIEF2bHRyZWUuZmluZCBpcyByZWN1cnNpdmUsIHNvIGl0IGNhbid0IGJlIGlubGluZWQsIHNvIGRvaW5nIHRoaXMgYXZvaWRzIGFcbiAgICAgZnVuY3Rpb24gY2FsbCBpbiBtb3N0IGNhc2VzLiAqKVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5XG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGVsc2UgaWZfbm90X2ZvdW5kIGtleVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRpX2FuZF9jYWxsIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMSB0IGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB+a2V5OmsgfmRhdGE6diBhIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwxIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMiB0IGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGEgYiBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwyXG4gICAgICB0cmVlXG4gICAgICB+Y29tcGFyZTooY29tcGFyZV9rZXkgdClcbiAgICAgIGtleVxuICAgICAgfmFcbiAgICAgIH5iXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kID1cbiAgbGV0IGlmX2ZvdW5kIHYgPSBTb21lIHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gTm9uZSBpblxuICBmdW4gdCBrZXkgLT4gZmluZF9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IG1lbSB0IGtleSA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGZhbHNlXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSBfIH0gLT4gY29tcGFyZV9rZXkgdCBrIGtleSA9IDBcbiAgfCB0cmVlIC0+IEF2bHRyZWUubWVtIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleVxuOztcblxubGV0IHJlbW92ZSB0IGtleSA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGxldCBpID0gc2xvdCB0IGtleSBpblxuICBsZXQgcm9vdCA9IHQudGFibGUuKGkpIGluXG4gIGxldCByZW1vdmVkID0gcmVmIGZhbHNlIGluXG4gIGxldCBuZXdfcm9vdCA9IEF2bHRyZWUucmVtb3ZlIHJvb3QgfnJlbW92ZWQgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSBpblxuICBpZiBub3QgKHBoeXNfZXF1YWwgcm9vdCBuZXdfcm9vdCkgdGhlbiB0LnRhYmxlLihpKSA8LSBuZXdfcm9vdDtcbiAgaWYgIXJlbW92ZWQgdGhlbiB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDFcbjs7XG5cbmxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgaWYgbGVuZ3RoIHQgPSAwXG4gIHRoZW4gaW5pdFxuICBlbHNlIChcbiAgICBsZXQgbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gICAgbGV0IG0gPSB0Lm11dGF0aW9uX2FsbG93ZWQgaW5cbiAgICBtYXRjaFxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoIEFycmF5LnVuc2FmZV9nZXQgdC50YWJsZSBpIHdpdGhcbiAgICAgICAgfCBBdmx0cmVlLkVtcHR5IC0+ICgpXG4gICAgICAgIHwgQXZsdHJlZS5MZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBhY2MgOj0gZiB+a2V5IH5kYXRhICFhY2NcbiAgICAgICAgfCBidWNrZXQgLT4gYWNjIDo9IEF2bHRyZWUuZm9sZCBidWNrZXQgfmluaXQ6IWFjYyB+ZlxuICAgICAgZG9uZVxuICAgIHdpdGhcbiAgICB8ICgpIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbTtcbiAgICAgICFhY2NcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgcmFpc2UgZXhuKVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBpZiB0Lmxlbmd0aCA9IDBcbiAgdGhlbiAoKVxuICBlbHNlIChcbiAgICBsZXQgbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG0gPSB0Lm11dGF0aW9uX2FsbG93ZWQgaW5cbiAgICBtYXRjaFxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoIEFycmF5LnVuc2FmZV9nZXQgdC50YWJsZSBpIHdpdGhcbiAgICAgICAgfCBBdmx0cmVlLkVtcHR5IC0+ICgpXG4gICAgICAgIHwgQXZsdHJlZS5MZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGFcbiAgICAgICAgfCBidWNrZXQgLT4gQXZsdHJlZS5pdGVyIGJ1Y2tldCB+ZlxuICAgICAgZG9uZVxuICAgIHdpdGhcbiAgICB8ICgpIC0+IHQubXV0YXRpb25fYWxsb3dlZCA8LSBtXG4gICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbTtcbiAgICAgIHJhaXNlIGV4bilcbjs7XG5cbmxldCBpdGVyIHQgfmYgPSBpdGVyaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxubGV0IGl0ZXJfa2V5cyB0IH5mID0gaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSkgW0Bub250YWlsXVxuXG5sZXQgcmVjIGNob29zZV9ub25lbXB0eSB0YWJsZSBpID1cbiAgbGV0IGF2bHRyZWUgPSBBcnJheS51bnNhZmVfZ2V0IHRhYmxlIGkgaW5cbiAgaWYgQXZsdHJlZS5pc19lbXB0eSBhdmx0cmVlXG4gIHRoZW4gY2hvb3NlX25vbmVtcHR5IHRhYmxlICgoaSArIDEpIGxhbmQgKEFycmF5Lmxlbmd0aCB0YWJsZSAtIDEpKVxuICBlbHNlIEF2bHRyZWUuY2hvb3NlX2V4biBhdmx0cmVlXG47O1xuXG5sZXQgY2hvb3NlX2V4biB0ID1cbiAgaWYgdC5sZW5ndGggPSAwIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0hhc2h0YmwuY2hvb3NlX2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKTtcbiAgY2hvb3NlX25vbmVtcHR5IHQudGFibGUgMFxuOztcblxubGV0IGNob29zZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChjaG9vc2Vfbm9uZW1wdHkgdC50YWJsZSAwKVxuXG5sZXQgY2hvb3NlX3JhbmRvbWx5X25vbmVtcHR5IH5yYW5kb21fc3RhdGUgdCA9XG4gIGxldCBzdGFydF9pZHggPSBSYW5kb20uU3RhdGUuaW50IHJhbmRvbV9zdGF0ZSAoQXJyYXkubGVuZ3RoIHQudGFibGUpIGluXG4gIGNob29zZV9ub25lbXB0eSB0LnRhYmxlIHN0YXJ0X2lkeFxuOztcblxubGV0IGNob29zZV9yYW5kb21seSA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChjaG9vc2VfcmFuZG9tbHlfbm9uZW1wdHkgfnJhbmRvbV9zdGF0ZSB0KVxuOztcblxubGV0IGNob29zZV9yYW5kb21seV9leG4gPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgdCA9XG4gIGlmIHQubGVuZ3RoID0gMFxuICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltIYXNodGJsLmNob29zZV9yYW5kb21seV9leG5dIG9mIGVtcHR5IGhhc2h0YmxcIiBbXSk7XG4gIGNob29zZV9yYW5kb21seV9ub25lbXB0eSB+cmFuZG9tX3N0YXRlIHRcbjs7XG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2tleSBpbnZhcmlhbnRfZGF0YSB0ID1cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgIEF2bHRyZWUuaW52YXJpYW50IHQudGFibGUuKGkpIH5jb21wYXJlOihjb21wYXJlX2tleSB0KVxuICBkb25lO1xuICBsZXQgcmVhbF9sZW4gPVxuICAgIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleSB+ZGF0YSBpIC0+XG4gICAgICBpbnZhcmlhbnRfa2V5IGtleTtcbiAgICAgIGludmFyaWFudF9kYXRhIGRhdGE7XG4gICAgICBpICsgMSlcbiAgaW5cbiAgYXNzZXJ0IChyZWFsX2xlbiA9IHQubGVuZ3RoKVxuOztcblxubGV0IGZpbmRfZXhuID1cbiAgbGV0IGlmX2ZvdW5kIHYgXyA9IHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBrIHQgPVxuICAgIHJhaXNlXG4gICAgICAoTm90X2ZvdW5kX3MgKExpc3QgWyBBdG9tIFwiSGFzaHRibC5maW5kX2V4bjogbm90IGZvdW5kXCI7IHQuaGFzaGFibGUuc2V4cF9vZl90IGsgXSkpXG4gIGluXG4gIGxldCBmaW5kX2V4biB0IGtleSA9IGZpbmRfYW5kX2NhbGwxIHQga2V5IH5hOnQgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX2V4blxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgIGZhbHNlKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5sZXQgZm9yX2FsbGkgdCB+ZiA9IG5vdCAoZXhpc3RzaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBub3QgKGYgfmtleSB+ZGF0YSkpKVxubGV0IGZvcl9hbGwgdCB+ZiA9IG5vdCAoZXhpc3RzaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IG5vdCAoZiBkYXRhKSkpXG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYykgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG47O1xuXG5sZXQgY291bnQgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleTpfIH5kYXRhIGFjYyAtPiBpZiBmIGRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IG5ld190ID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gc2V0IG5ld190IH5rZXkgfmRhdGE6KGYgfmtleSB+ZGF0YSkpO1xuICBuZXdfdFxuOztcblxubGV0IG1hcCB0IH5mID0gbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxubGV0IGNvcHkgdCA9IG1hcCB0IH5mOkZuLmlkXG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IG5ld190ID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBtYXRjaCBmIH5rZXkgfmRhdGEgd2l0aFxuICAgIHwgU29tZSBuZXdfZGF0YSAtPiBzZXQgbmV3X3QgfmtleSB+ZGF0YTpuZXdfZGF0YVxuICAgIHwgTm9uZSAtPiAoKSk7XG4gIG5ld190XG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIFNvbWUgZGF0YSBlbHNlIE5vbmUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcmkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cbmxldCBmaWx0ZXJfa2V5cyB0IH5mID0gZmlsdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5KSBbQG5vbnRhaWxdXG5cbmxldCBwYXJ0aXRpb25fbWFwaSB0IH5mID1cbiAgbGV0IHQwID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgbGV0IHQxID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBtYXRjaCAoZiB+a2V5IH5kYXRhIDogXyBFaXRoZXIudCkgd2l0aFxuICAgIHwgRmlyc3QgbmV3X2RhdGEgLT4gc2V0IHQwIH5rZXkgfmRhdGE6bmV3X2RhdGFcbiAgICB8IFNlY29uZCBuZXdfZGF0YSAtPiBzZXQgdDEgfmtleSB+ZGF0YTpuZXdfZGF0YSk7XG4gIHQwLCB0MVxuOztcblxubGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9IHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5cbmxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBGaXJzdCBkYXRhIGVsc2UgU2Vjb25kIGRhdGEpIFxuICBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5cbmxldCBmaW5kX29yX2FkZCB0IGlkIH5kZWZhdWx0ID1cbiAgZmluZF9hbmRfY2FsbFxuICAgIHRcbiAgICBpZFxuICAgIH5pZl9mb3VuZDooZnVuIGRhdGEgLT4gZGF0YSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4ga2V5IC0+XG4gICAgICBsZXQgZGVmYXVsdCA9IGRlZmF1bHQgKCkgaW5cbiAgICAgIHNldCB0IH5rZXkgfmRhdGE6ZGVmYXVsdDtcbiAgICAgIGRlZmF1bHQpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kaV9vcl9hZGQgdCBpZCB+ZGVmYXVsdCA9XG4gIGZpbmRfYW5kX2NhbGxcbiAgICB0XG4gICAgaWRcbiAgICB+aWZfZm91bmQ6KGZ1biBkYXRhIC0+IGRhdGEpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuIGtleSAtPlxuICAgICAgbGV0IGRlZmF1bHQgPSBkZWZhdWx0IGtleSBpblxuICAgICAgc2V0IHQgfmtleSB+ZGF0YTpkZWZhdWx0O1xuICAgICAgZGVmYXVsdCkgW0Bub250YWlsXVxuOztcblxuKCogU29tZSBoYXNodGJsIGltcGxlbWVudGF0aW9ucyBtYXkgYmUgYWJsZSB0byBwZXJmb3JtIHRoaXMgbW9yZSBlZmZpY2llbnRseSB0aGFuIHR3b1xuICAgc2VwYXJhdGUgbG9va3VwcyAqKVxubGV0IGZpbmRfYW5kX3JlbW92ZSB0IGlkID1cbiAgbGV0IHJlc3VsdCA9IGZpbmQgdCBpZCBpblxuICBpZiBPcHRpb24uaXNfc29tZSByZXN1bHQgdGhlbiByZW1vdmUgdCBpZDtcbiAgcmVzdWx0XG47O1xuXG5sZXQgY2hhbmdlIHQgaWQgfmYgPVxuICBtYXRjaCBmIChmaW5kIHQgaWQpIHdpdGhcbiAgfCBOb25lIC0+IHJlbW92ZSB0IGlkXG4gIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXk6aWQgfmRhdGFcbjs7XG5cbmxldCB1cGRhdGVfYW5kX3JldHVybiB0IGlkIH5mID1cbiAgbGV0IGRhdGEgPSBmIChmaW5kIHQgaWQpIGluXG4gIHNldCB0IH5rZXk6aWQgfmRhdGE7XG4gIGRhdGFcbjs7XG5cbmxldCB1cGRhdGUgdCBpZCB+ZiA9IGlnbm9yZSAodXBkYXRlX2FuZF9yZXR1cm4gdCBpZCB+ZiA6IF8pXG5cbmxldCBpbmNyX2J5IH5yZW1vdmVfaWZfemVybyB0IGtleSBieSA9XG4gIGlmIHJlbW92ZV9pZl96ZXJvXG4gIHRoZW5cbiAgICBjaGFuZ2UgdCBrZXkgfmY6KGZ1biBvcHQgLT5cbiAgICAgIG1hdGNoIGJ5ICsgT3B0aW9uLnZhbHVlIG9wdCB+ZGVmYXVsdDowIHdpdGhcbiAgICAgIHwgMCAtPiBOb25lXG4gICAgICB8IG4gLT4gU29tZSBuKVxuICBlbHNlXG4gICAgdXBkYXRlIHQga2V5IH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IGJ5XG4gICAgICB8IFNvbWUgaSAtPiBieSArIGkpXG47O1xuXG5sZXQgaW5jciA/KGJ5ID0gMSkgPyhyZW1vdmVfaWZfemVybyA9IGZhbHNlKSB0IGtleSA9IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5IGJ5XG5sZXQgZGVjciA/KGJ5ID0gMSkgPyhyZW1vdmVfaWZfemVybyA9IGZhbHNlKSB0IGtleSA9IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5ICgtYnkpXG5cbmxldCBhZGRfbXVsdGkgdCB+a2V5IH5kYXRhID1cbiAgdXBkYXRlIHQga2V5IH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBbIGRhdGEgXVxuICAgIHwgU29tZSBsIC0+IGRhdGEgOjogbClcbjs7XG5cbmxldCByZW1vdmVfbXVsdGkgdCBrZXkgPVxuICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBbXSB8IFNvbWUgWyBfIF0gLT4gcmVtb3ZlIHQga2V5XG4gIHwgU29tZSAoXyA6OiB0bCkgLT4gc2V0IHQgfmtleSB+ZGF0YTp0bFxuOztcblxubGV0IGZpbmRfbXVsdGkgdCBrZXkgPVxuICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBsIC0+IGxcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIHJvd3MgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHMgLT4gc1xuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCByb3dzXG4gIGluXG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSB+c2l6ZSAoKSBpblxuICBsZXQgZHVwZXMgPSByZWYgW10gaW5cbiAgTGlzdC5pdGVyIHJvd3MgfmY6KGZ1biByIC0+XG4gICAgbGV0IGtleSA9IGdldF9rZXkgciBpblxuICAgIGxldCBkYXRhID0gZ2V0X2RhdGEgciBpblxuICAgIGlmIG1lbSByZXMga2V5IHRoZW4gZHVwZXMgOj0ga2V5IDo6ICFkdXBlcyBlbHNlIHNldCByZXMgfmtleSB+ZGF0YSk7XG4gIG1hdGNoICFkdXBlcyB3aXRoXG4gIHwgW10gLT4gYE9rIHJlc1xuICB8IGtleXMgLT4gYER1cGxpY2F0ZV9rZXlzIChMaXN0LmRlZHVwX2FuZF9zb3J0IH5jb21wYXJlOmhhc2hhYmxlLkhhc2hhYmxlLmNvbXBhcmUga2V5cylcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkX211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIHJvd3MgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHMgLT4gc1xuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCByb3dzXG4gIGluXG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5zaXplIH5oYXNoYWJsZSAoKSBpblxuICBMaXN0Lml0ZXIgcm93cyB+ZjooZnVuIHIgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByIGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByIGluXG4gICAgYWRkX211bHRpIHJlcyB+a2V5IH5kYXRhKTtcbiAgcmVzXG47O1xuXG5sZXQgb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBtYXRjaCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXk6ZnN0IH5nZXRfZGF0YTpzbmQgbHN0IHdpdGhcbiAgfCBgT2sgdCAtPiBgT2sgdFxuICB8IGBEdXBsaWNhdGVfa2V5cyBrIC0+IGBEdXBsaWNhdGVfa2V5IChMaXN0LmhkX2V4biBrKVxuOztcblxubGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Rcbjs7XG5cbmxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0IHdpdGhcbiAgfCBgT2sgdiAtPiBSZXN1bHQuT2sgdlxuICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IGhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdCBpblxuICAgIE9yX2Vycm9yLmVycm9yIFwiSGFzaHRibC5vZl9hbGlzdF9leG46IGR1cGxpY2F0ZSBrZXlcIiBrZXkgc2V4cF9vZl9rZXlcbjs7XG5cbmxldCBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBtYXRjaCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCB3aXRoXG4gIHwgUmVzdWx0Lk9rIHYgLT4gdlxuICB8IFJlc3VsdC5FcnJvciBlIC0+IEVycm9yLnJhaXNlIGVcbjs7XG5cbmxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIGNyZWF0ZV9tYXBwZWRfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Rcbjs7XG5cbmxldCB0b19hbGlzdCB0ID0gZm9sZCB+ZjooZnVuIH5rZXkgfmRhdGEgbGlzdCAtPiAoa2V5LCBkYXRhKSA6OiBsaXN0KSB+aW5pdDpbXSB0XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9rZXkgc2V4cF9vZl9kYXRhIHQgPVxuICB0XG4gIHw+IHRvX2FsaXN0XG4gIHw+IExpc3Quc29ydCB+Y29tcGFyZTooZnVuIChrMSwgXykgKGsyLCBfKSAtPiB0Lmhhc2hhYmxlLmNvbXBhcmUgazEgazIpXG4gIHw+IHNleHBfb2ZfbGlzdCAoc2V4cF9vZl9wYWlyIHNleHBfb2Zfa2V5IHNleHBfb2ZfZGF0YSlcbjs7XG5cbmxldCB0X29mX3NleHAgfmhhc2hhYmxlIGtfb2Zfc2V4cCBkX29mX3NleHAgc2V4cCA9XG4gIGxldCBhbGlzdCA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIGtfb2Zfc2V4cCBkX29mX3NleHApIHNleHAgaW5cbiAgbWF0Y2ggb2ZfYWxpc3Qgfmhhc2hhYmxlIGFsaXN0IH5zaXplOihMaXN0Lmxlbmd0aCBhbGlzdCkgd2l0aFxuICB8IGBPayB2IC0+IHZcbiAgfCBgRHVwbGljYXRlX2tleSBrIC0+XG4gICAgKCogZmluZCB0aGUgc2V4cCBvZiBhIGR1cGxpY2F0ZSBrZXksIHNvIHRoZSBlcnJvciBpcyBuYXJyb3dlZCB0byBhIGtleSBhbmQgbm90XG4gICAgICAgdGhlIHdob2xlIG1hcCAqKVxuICAgIGxldCBhbGlzdF9zZXhwcyA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIEZuLmlkIEZuLmlkKSBzZXhwIGluXG4gICAgbGV0IGZvdW5kX2ZpcnN0X2sgPSByZWYgZmFsc2UgaW5cbiAgICBMaXN0Lml0ZXIyX2V4biBhbGlzdCBhbGlzdF9zZXhwcyB+ZjooZnVuIChrMiwgXykgKGsyX3NleHAsIF8pIC0+XG4gICAgICBpZiBoYXNoYWJsZS5jb21wYXJlIGsgazIgPSAwXG4gICAgICB0aGVuXG4gICAgICAgIGlmICFmb3VuZF9maXJzdF9rXG4gICAgICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcIkhhc2h0YmwudF9vZl9zZXhwOiBkdXBsaWNhdGUga2V5XCIgazJfc2V4cFxuICAgICAgICBlbHNlIGZvdW5kX2ZpcnN0X2sgOj0gdHJ1ZSk7XG4gICAgYXNzZXJ0IGZhbHNlXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXJcbiAgKHR5cGUgayB2KVxuICAoa19ncmFtbWFyIDogayBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgKHZfZ3JhbW1hciA6IHYgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogKGssIHYpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LkFzc29jLnRfc2V4cF9ncmFtbWFyIGtfZ3JhbW1hciB2X2dyYW1tYXIpXG47O1xuXG5sZXQga2V5cyB0ID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YTpfIGFjYyAtPiBrZXkgOjogYWNjKVxubGV0IGRhdGEgdCA9IGZvbGQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgbGlzdCAtPiBkYXRhIDo6IGxpc3QpIH5pbml0OltdIHRcblxubGV0IGFkZF90b19ncm91cHMgZ3JvdXBzIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSB+cm93cyA9XG4gIExpc3QuaXRlciByb3dzIH5mOihmdW4gcm93IC0+XG4gICAgbGV0IGtleSA9IGdldF9rZXkgcm93IGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByb3cgaW5cbiAgICBsZXQgZGF0YSA9XG4gICAgICBtYXRjaCBmaW5kIGdyb3VwcyBrZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IGRhdGFcbiAgICAgIHwgU29tZSBvbGQgLT4gY29tYmluZSBvbGQgZGF0YVxuICAgIGluXG4gICAgc2V0IGdyb3VwcyB+a2V5IH5kYXRhKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgcm93cyA9XG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSAoKSBpblxuICBhZGRfdG9fZ3JvdXBzIHJlcyB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgfnJvd3M7XG4gIHJlc1xuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MgPVxuICBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhOkZuLmlkIHJvd3Ncbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzID1cbiAgbWF0Y2ggY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyB3aXRoXG4gIHwgYE9rIHQgLT4gUmVzdWx0Lk9rIHRcbiAgfCBgRHVwbGljYXRlX2tleXMga2V5cyAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IGhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdCBpblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiSGFzaHRibC5jcmVhdGVfd2l0aF9rZXk6IGR1cGxpY2F0ZSBrZXlzXCJcbiAgICAgICAgIFsgXCJrZXlzXCIsIHNleHBfb2ZfbGlzdCBzZXhwX29mX2tleSBrZXlzIF0pXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MgPVxuICBPcl9lcnJvci5va19leG4gKGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MpXG47O1xuXG5sZXQgbWVyZ2UgPVxuICBsZXQgbWF5YmVfc2V0IHQgfmtleSB+ZiBkID1cbiAgICBtYXRjaCBmIH5rZXkgZCB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIHYgLT4gc2V0IHQgfmtleSB+ZGF0YTp2XG4gIGluXG4gIGZ1biB0X2xlZnQgdF9yaWdodCB+ZiAtPlxuICAgIGlmIG5vdCAoSGFzaGFibGUuZXF1YWwgdF9sZWZ0Lmhhc2hhYmxlIHRfcmlnaHQuaGFzaGFibGUpXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIkhhc2h0YmwubWVyZ2U6IGRpZmZlcmVudCAnaGFzaGFibGUnIHZhbHVlc1wiO1xuICAgIGxldCBuZXdfdCA9XG4gICAgICBjcmVhdGVcbiAgICAgICAgfmdyb3d0aF9hbGxvd2VkOnRfbGVmdC5ncm93dGhfYWxsb3dlZFxuICAgICAgICB+aGFzaGFibGU6dF9sZWZ0Lmhhc2hhYmxlXG4gICAgICAgIH5zaXplOnRfbGVmdC5sZW5ndGhcbiAgICAgICAgKClcbiAgICBpblxuICAgIHdpdGhvdXRfbXV0YXRpbmcgdF9sZWZ0IChmdW4gKCkgLT5cbiAgICAgIHdpdGhvdXRfbXV0YXRpbmcgdF9yaWdodCAoZnVuICgpIC0+XG4gICAgICAgIGl0ZXJpIHRfbGVmdCB+ZjooZnVuIH5rZXkgfmRhdGE6bGVmdCAtPlxuICAgICAgICAgIG1hdGNoIGZpbmQgdF9yaWdodCBrZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBtYXliZV9zZXQgbmV3X3QgfmtleSB+ZiAoYExlZnQgbGVmdClcbiAgICAgICAgICB8IFNvbWUgcmlnaHQgLT4gbWF5YmVfc2V0IG5ld190IH5rZXkgfmYgKGBCb3RoIChsZWZ0LCByaWdodCkpKTtcbiAgICAgICAgaXRlcmkgdF9yaWdodCB+ZjooZnVuIH5rZXkgfmRhdGE6cmlnaHQgLT5cbiAgICAgICAgICBtYXRjaCBmaW5kIHRfbGVmdCBrZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBtYXliZV9zZXQgbmV3X3QgfmtleSB+ZiAoYFJpZ2h0IHJpZ2h0KVxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgICAgKCogYWxyZWFkeSBkb25lIGFib3ZlICopKSBbQG5vbnRhaWxdKSBbQG5vbnRhaWxdKTtcbiAgICBuZXdfdFxuOztcblxubGV0IG1lcmdlX2ludG8gfnNyYyB+ZHN0IH5mID1cbiAgaXRlcmkgc3JjIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIGxldCBkc3RfZGF0YSA9IGZpbmQgZHN0IGtleSBpblxuICAgIGxldCBhY3Rpb24gPSB3aXRob3V0X211dGF0aW5nIGRzdCAoZnVuICgpIC0+IGYgfmtleSBkYXRhIGRzdF9kYXRhKSBpblxuICAgIG1hdGNoIChhY3Rpb24gOiBfIE1lcmdlX2ludG9fYWN0aW9uLnQpIHdpdGhcbiAgICB8IFJlbW92ZSAtPiByZW1vdmUgZHN0IGtleVxuICAgIHwgU2V0X3RvIGRhdGEgLT5cbiAgICAgIChtYXRjaCBkc3RfZGF0YSB3aXRoXG4gICAgICAgfCBOb25lIC0+IHNldCBkc3QgfmtleSB+ZGF0YVxuICAgICAgIHwgU29tZSBkc3RfZGF0YSAtPiBpZiBub3QgKHBoeXNfZXF1YWwgZHN0X2RhdGEgZGF0YSkgdGhlbiBzZXQgZHN0IH5rZXkgfmRhdGEpKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdG9fcmVtb3ZlID1cbiAgICBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIGFjIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGFjIGVsc2Uga2V5IDo6IGFjKVxuICBpblxuICBMaXN0Lml0ZXIgdG9fcmVtb3ZlIH5mOihmdW4ga2V5IC0+IHJlbW92ZSB0IGtleSlcbjs7XG5cbmxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID0gZmlsdGVyaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5sZXQgZmlsdGVyX2tleXNfaW5wbGFjZSB0IH5mID0gZmlsdGVyaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpIFtAbm9udGFpbF1cblxubGV0IGZpbHRlcl9tYXBpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCBtYXBfcmVzdWx0cyA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWMgLT4gKGtleSwgZiB+a2V5IH5kYXRhKSA6OiBhYykgaW5cbiAgTGlzdC5pdGVyIG1hcF9yZXN1bHRzIH5mOihmdW4gKGtleSwgcmVzdWx0KSAtPlxuICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgfCBOb25lIC0+IHJlbW92ZSB0IGtleVxuICAgIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXkgfmRhdGEpXG47O1xuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIHQgfmYgPVxuICBmaWx0ZXJfbWFwaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICB3aXRob3V0X211dGF0aW5nIHQgKGZ1biAoKSAtPlxuICAgIEFycmF5Lml0ZXIgdC50YWJsZSB+ZjooQXZsdHJlZS5tYXBpX2lucGxhY2UgfmYpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXBfaW5wbGFjZSB0IH5mID0gbWFwaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5cbmxldCBlcXVhbCBlcXVhbCB0IHQnID1cbiAgbGVuZ3RoIHQgPSBsZW5ndGggdCdcbiAgJiYgKHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICB3aXRob3V0X211dGF0aW5nIHQnIChmdW4gKCkgLT5cbiAgICAgICAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgICAgbWF0Y2ggZmluZCB0JyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHIucmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB8IFNvbWUgZGF0YScgLT4gaWYgbm90IChlcXVhbCBkYXRhIGRhdGEnKSB0aGVuIHIucmV0dXJuIGZhbHNlKSBbQG5vbnRhaWxdKTtcbiAgICAgICAgdHJ1ZSkgW0Bub250YWlsXSlcbjs7XG5cbmxldCBzaW1pbGFyID0gZXF1YWxcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG4gIGxldCBjaG9vc2UgPSBjaG9vc2VcbiAgbGV0IGNob29zZV9leG4gPSBjaG9vc2VfZXhuXG4gIGxldCBjaG9vc2VfcmFuZG9tbHkgPSBjaG9vc2VfcmFuZG9tbHlcbiAgbGV0IGNob29zZV9yYW5kb21seV9leG4gPSBjaG9vc2VfcmFuZG9tbHlfZXhuXG4gIGxldCBjbGVhciA9IGNsZWFyXG4gIGxldCBjb3B5ID0gY29weVxuICBsZXQgcmVtb3ZlID0gcmVtb3ZlXG4gIGxldCBzZXQgPSBzZXRcbiAgbGV0IGFkZCA9IGFkZFxuICBsZXQgYWRkX2V4biA9IGFkZF9leG5cbiAgbGV0IGNoYW5nZSA9IGNoYW5nZVxuICBsZXQgdXBkYXRlID0gdXBkYXRlXG4gIGxldCB1cGRhdGVfYW5kX3JldHVybiA9IHVwZGF0ZV9hbmRfcmV0dXJuXG4gIGxldCBhZGRfbXVsdGkgPSBhZGRfbXVsdGlcbiAgbGV0IHJlbW92ZV9tdWx0aSA9IHJlbW92ZV9tdWx0aVxuICBsZXQgZmluZF9tdWx0aSA9IGZpbmRfbXVsdGlcbiAgbGV0IG1lbSA9IG1lbVxuICBsZXQgaXRlcl9rZXlzID0gaXRlcl9rZXlzXG4gIGxldCBpdGVyID0gaXRlclxuICBsZXQgaXRlcmkgPSBpdGVyaVxuICBsZXQgZXhpc3RzID0gZXhpc3RzXG4gIGxldCBleGlzdHNpID0gZXhpc3RzaVxuICBsZXQgZm9yX2FsbCA9IGZvcl9hbGxcbiAgbGV0IGZvcl9hbGxpID0gZm9yX2FsbGlcbiAgbGV0IGNvdW50ID0gY291bnRcbiAgbGV0IGNvdW50aSA9IGNvdW50aVxuICBsZXQgZm9sZCA9IGZvbGRcbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBsZXQgaXNfZW1wdHkgPSBpc19lbXB0eVxuICBsZXQgbWFwID0gbWFwXG4gIGxldCBtYXBpID0gbWFwaVxuICBsZXQgZmlsdGVyX21hcCA9IGZpbHRlcl9tYXBcbiAgbGV0IGZpbHRlcl9tYXBpID0gZmlsdGVyX21hcGlcbiAgbGV0IGZpbHRlcl9rZXlzID0gZmlsdGVyX2tleXNcbiAgbGV0IGZpbHRlciA9IGZpbHRlclxuICBsZXQgZmlsdGVyaSA9IGZpbHRlcmlcbiAgbGV0IHBhcnRpdGlvbl9tYXAgPSBwYXJ0aXRpb25fbWFwXG4gIGxldCBwYXJ0aXRpb25fbWFwaSA9IHBhcnRpdGlvbl9tYXBpXG4gIGxldCBwYXJ0aXRpb25fdGYgPSBwYXJ0aXRpb25fdGZcbiAgbGV0IHBhcnRpdGlvbmlfdGYgPSBwYXJ0aXRpb25pX3RmXG4gIGxldCBmaW5kX29yX2FkZCA9IGZpbmRfb3JfYWRkXG4gIGxldCBmaW5kaV9vcl9hZGQgPSBmaW5kaV9vcl9hZGRcbiAgbGV0IGZpbmQgPSBmaW5kXG4gIGxldCBmaW5kX2V4biA9IGZpbmRfZXhuXG4gIGxldCBmaW5kX2FuZF9jYWxsID0gZmluZF9hbmRfY2FsbFxuICBsZXQgZmluZF9hbmRfY2FsbDEgPSBmaW5kX2FuZF9jYWxsMVxuICBsZXQgZmluZF9hbmRfY2FsbDIgPSBmaW5kX2FuZF9jYWxsMlxuICBsZXQgZmluZGlfYW5kX2NhbGwgPSBmaW5kaV9hbmRfY2FsbFxuICBsZXQgZmluZGlfYW5kX2NhbGwxID0gZmluZGlfYW5kX2NhbGwxXG4gIGxldCBmaW5kaV9hbmRfY2FsbDIgPSBmaW5kaV9hbmRfY2FsbDJcbiAgbGV0IGZpbmRfYW5kX3JlbW92ZSA9IGZpbmRfYW5kX3JlbW92ZVxuICBsZXQgdG9fYWxpc3QgPSB0b19hbGlzdFxuICBsZXQgbWVyZ2UgPSBtZXJnZVxuICBsZXQgbWVyZ2VfaW50byA9IG1lcmdlX2ludG9cbiAgbGV0IGtleXMgPSBrZXlzXG4gIGxldCBkYXRhID0gZGF0YVxuICBsZXQgZmlsdGVyX2tleXNfaW5wbGFjZSA9IGZpbHRlcl9rZXlzX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9pbnBsYWNlID0gZmlsdGVyX2lucGxhY2VcbiAgbGV0IGZpbHRlcmlfaW5wbGFjZSA9IGZpbHRlcmlfaW5wbGFjZVxuICBsZXQgbWFwX2lucGxhY2UgPSBtYXBfaW5wbGFjZVxuICBsZXQgbWFwaV9pbnBsYWNlID0gbWFwaV9pbnBsYWNlXG4gIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9tYXBpX2lucGxhY2UgPSBmaWx0ZXJfbWFwaV9pbnBsYWNlXG4gIGxldCBlcXVhbCA9IGVxdWFsXG4gIGxldCBzaW1pbGFyID0gc2ltaWxhclxuICBsZXQgaW5jciA9IGluY3JcbiAgbGV0IGRlY3IgPSBkZWNyXG4gIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5XG5lbmRcblxubW9kdWxlIENyZWF0b3JzIChLZXkgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGhhc2hhYmxlIDogJ2EgdCBIYXNoYWJsZS50XG5lbmQpIDogc2lnXG4gIHR5cGUgKCdhLCAnYikgdF8gPSAoJ2EgS2V5LnQsICdiKSB0XG5cbiAgdmFsIHRfb2Zfc2V4cCA6IChTZXhwLnQgLT4gJ2EgS2V5LnQpIC0+IChTZXhwLnQgLT4gJ2IpIC0+IFNleHAudCAtPiAoJ2EsICdiKSB0X1xuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0X1xuICAgICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBLZXkudFxuICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ2EpIGNyZWF0ZV9vcHRpb25zIDo9XG4gICAgICAgICgna2V5LCAnZGF0YSwgJ2EpIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGhhc2hhYmxlID0gS2V5Lmhhc2hhYmxlXG5cbiAgdHlwZSAoJ2EsICdiKSB0XyA9ICgnYSBLZXkudCwgJ2IpIHRcblxuICBsZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKSA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlICgpXG4gIGxldCBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuXG4gIGxldCBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcbiAgOztcblxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIGtfb2Zfc2V4cCBkX29mX3NleHAgc2V4cCA9IHRfb2Zfc2V4cCB+aGFzaGFibGUga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwXG5cbiAgbGV0IG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcbiAgOztcblxuICBsZXQgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIGwgPVxuICAgIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGwgPVxuICAgIGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsID1cbiAgICBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV93aXRoX2tleV9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGwgPVxuICAgIGNyZWF0ZV93aXRoX2tleV9leG4gP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSBsXG4gIDs7XG5cbiAgbGV0IGdyb3VwID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgbCA9XG4gICAgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgbFxuICA7O1xuZW5kXG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2Ega2V5ID0gJ2FcblxuICBsZXQgaGFzaGFibGUgPSBIYXNoYWJsZS5wb2x5XG4gIGxldCBjYXBhY2l0eSA9IGNhcGFjaXR5XG5cbiAgaW5jbHVkZSBDcmVhdG9ycyAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgIGxldCBoYXNoYWJsZSA9IGhhc2hhYmxlXG4gIGVuZClcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgbGV0IHRfc2V4cF9ncmFtbWFyID0gdF9zZXhwX2dyYW1tYXJcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gQ3JlYXRvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBIYXNoYWJsZSA9IEhhc2hhYmxlLkhhc2hhYmxlXG5cbiAgdHlwZSBub25yZWMgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGUgPVxuICAgICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5cbiAgbGV0IGhhc2hhYmxlIHQgPSB0Lmhhc2hhYmxlXG5lbmRcblxubGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSA9XG4gIGNyZWF0ZSB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKClcbjs7XG5cbmxldCBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3Qgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9vcl9lcnJvciB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfZXhuIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X211bHRpIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSB+Z2V0X2RhdGEgbCA9XG4gIGNyZWF0ZV9tYXBwZWQgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSBsXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IGwgPVxuICBjcmVhdGVfd2l0aF9rZXkgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGxcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgbCA9XG4gIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgbCA9XG4gIGNyZWF0ZV93aXRoX2tleV9leG4gfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGxcbjs7XG5cbmxldCBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgbCA9XG4gIGdyb3VwIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgbFxuOztcblxubGV0IGhhc2hhYmxlX3MgdCA9IEhhc2hhYmxlLnRvX2tleSB0Lmhhc2hhYmxlXG5cbm1vZHVsZSBNIChLIDogVC5UKSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgS2V5LlMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgaykgKG1vZHVsZSBLIDogU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gaykgc2V4cF9vZl92IHQgPVxuICBzZXhwX29mX3QgSy5zZXhwX29mX3Qgc2V4cF9vZl92IHRcbjs7XG5cbmxldCBtX190X29mX3NleHAgKHR5cGUgaykgKG1vZHVsZSBLIDogTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gaykgdl9vZl9zZXhwIHNleHAgPVxuICB0X29mX3NleHAgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgKG1vZHVsZSBLKSkgSy50X29mX3NleHAgdl9vZl9zZXhwIHNleHBcbjs7XG5cbmxldCBtX190X3NleHBfZ3JhbW1hciAodHlwZSBrKSAobW9kdWxlIEsgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGspIHZfZ3JhbW1hciA9XG4gIHRfc2V4cF9ncmFtbWFyIEsudF9zZXhwX2dyYW1tYXIgdl9ncmFtbWFyXG47O1xuXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSBlcXVhbF92IHQxIHQyID0gZXF1YWwgZXF1YWxfdiB0MSB0MlxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEhhc2hfc2V0X2ludGZcblxubGV0IGhhc2hhYmxlX3MgPSBIYXNodGJsLmhhc2hhYmxlX3NcbmxldCBoYXNoYWJsZSA9IEhhc2h0YmwuUHJpdmF0ZS5oYXNoYWJsZVxubGV0IHBvbHlfaGFzaGFibGUgPSBIYXNodGJsLlBvbHkuaGFzaGFibGVcbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cbnR5cGUgJ2EgdCA9ICgnYSwgdW5pdCkgSGFzaHRibC50XG50eXBlICdhIGhhc2hfc2V0ID0gJ2EgdFxudHlwZSAnYSBlbHQgPSAnYVxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBoYXNoYWJsZSA9IGhhc2hhYmxlXG4gIGxldCBjbGVhciA9IEhhc2h0YmwuY2xlYXJcbiAgbGV0IGxlbmd0aCA9IEhhc2h0YmwubGVuZ3RoXG4gIGxldCBtZW0gPSBIYXNodGJsLm1lbVxuICBsZXQgaXNfZW1wdHkgdCA9IEhhc2h0YmwuaXNfZW1wdHkgdFxuXG4gIGxldCBmaW5kX21hcCB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIEhhc2h0YmwuaXRlcl9rZXlzIHQgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgbWF0Y2ggZiBlbHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIF8gYXMgbyAtPiByLnJldHVybiBvKTtcbiAgICAgIE5vbmUpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmluZCB0IH5mID0gZmluZF9tYXAgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gU29tZSBhIGVsc2UgTm9uZSkgW0Bub250YWlsXVxuICBsZXQgYWRkIHQgayA9IEhhc2h0Ymwuc2V0IHQgfmtleTprIH5kYXRhOigpXG5cbiAgbGV0IHN0cmljdF9hZGQgdCBrID1cbiAgICBpZiBtZW0gdCBrXG4gICAgdGhlbiBPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJlbGVtZW50IGFscmVhZHkgZXhpc3RzXCJcbiAgICBlbHNlIChcbiAgICAgIEhhc2h0Ymwuc2V0IHQgfmtleTprIH5kYXRhOigpO1xuICAgICAgUmVzdWx0Lk9rICgpKVxuICA7O1xuXG4gIGxldCBzdHJpY3RfYWRkX2V4biB0IGsgPSBPcl9lcnJvci5va19leG4gKHN0cmljdF9hZGQgdCBrKVxuICBsZXQgcmVtb3ZlID0gSGFzaHRibC5yZW1vdmVcblxuICBsZXQgc3RyaWN0X3JlbW92ZSB0IGsgPVxuICAgIGlmIG1lbSB0IGtcbiAgICB0aGVuIChcbiAgICAgIHJlbW92ZSB0IGs7XG4gICAgICBSZXN1bHQuT2sgKCkpXG4gICAgZWxzZSBPcl9lcnJvci5lcnJvciBcImVsZW1lbnQgbm90IGluIHNldFwiIGsgKEhhc2h0Ymwuc2V4cF9vZl9rZXkgdClcbiAgOztcblxuICBsZXQgc3RyaWN0X3JlbW92ZV9leG4gdCBrID0gT3JfZXJyb3Iub2tfZXhuIChzdHJpY3RfcmVtb3ZlIHQgaylcblxuICBsZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgICBIYXNodGJsLmZvbGQgdCB+aW5pdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgYWNjIC0+IGYgYWNjIGtleSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBpdGVyIHQgfmYgPSBIYXNodGJsLml0ZXJfa2V5cyB0IH5mXG4gIGxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxuICBsZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHQgfmZpbmlzaFxuICBsZXQgdG9fbGlzdCA9IEhhc2h0Ymwua2V5c1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lIHQgPVxuICAgIHNleHBfb2ZfbGlzdCBzZXhwX29mX2UgKHRvX2xpc3QgdCB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6KGhhc2hhYmxlIHQpLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHRvX2FycmF5IHQgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGxldCBpbmRleCA9IHJlZiAobGVuIC0gMSkgaW5cbiAgICBmb2xkIHQgfmluaXQ6W3x8XSB+ZjooZnVuIGFjYyBrZXkgLT5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCBhY2MgPSAwXG4gICAgICB0aGVuIEFycmF5LmNyZWF0ZSB+bGVuIGtleVxuICAgICAgZWxzZSAoXG4gICAgICAgIGluZGV4IDo9ICFpbmRleCAtIDE7XG4gICAgICAgIGFjYy4oIWluZGV4KSA8LSBrZXk7XG4gICAgICAgIGFjYykpXG4gIDs7XG5cbiAgbGV0IGV4aXN0cyB0IH5mID0gSGFzaHRibC5leGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IGYga2V5KSBbQG5vbnRhaWxdXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBub3QgKEhhc2h0YmwuZXhpc3RzaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBub3QgKGYga2V5KSkpXG4gIGxldCBlcXVhbCB0MSB0MiA9IEhhc2h0YmwuZXF1YWwgKGZ1biAoKSAoKSAtPiB0cnVlKSB0MSB0MlxuICBsZXQgY29weSB0ID0gSGFzaHRibC5jb3B5IHRcbiAgbGV0IGZpbHRlciB0IH5mID0gSGFzaHRibC5maWx0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IGYga2V5KSBbQG5vbnRhaWxdXG4gIGxldCB1bmlvbiB0MSB0MiA9IEhhc2h0YmwubWVyZ2UgdDEgdDIgfmY6KGZ1biB+a2V5Ol8gXyAtPiBTb21lICgpKVxuICBsZXQgZGlmZiB0MSB0MiA9IGZpbHRlciB0MSB+ZjooZnVuIGtleSAtPiBub3QgKEhhc2h0YmwubWVtIHQyIGtleSkpXG5cbiAgbGV0IGludGVyIHQxIHQyID1cbiAgICBsZXQgc21hbGxlciwgbGFyZ2VyID0gaWYgbGVuZ3RoIHQxID4gbGVuZ3RoIHQyIHRoZW4gdDIsIHQxIGVsc2UgdDEsIHQyIGluXG4gICAgSGFzaHRibC5maWx0ZXJpIHNtYWxsZXIgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IEhhc2h0YmwubWVtIGxhcmdlciBrZXkpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPVxuICAgIGxldCB0b19yZW1vdmUgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biBhYyB4IC0+IGlmIGYgeCB0aGVuIGFjIGVsc2UgeCA6OiBhYykgaW5cbiAgICBMaXN0Lml0ZXIgdG9fcmVtb3ZlIH5mOihmdW4geCAtPiByZW1vdmUgdCB4KVxuICA7O1xuXG4gIGxldCBvZl9oYXNodGJsX2tleXMgaGFzaHRibCA9IEhhc2h0YmwubWFwIGhhc2h0YmwgfmY6aWdub3JlXG4gIGxldCB0b19oYXNodGJsIHQgfmYgPSBIYXNodGJsLm1hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpIFtAbm9udGFpbF1cbmVuZFxuXG5pbmNsdWRlIEFjY2Vzc29yc1xuXG5sZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtID0gSGFzaHRibC5jcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIG1cblxubGV0IG9mX2xpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgeCAtPiB4XG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIGxcbiAgaW5cbiAgbGV0IHQgPSBIYXNodGJsLmNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfnNpemUgbSBpblxuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIGsgLT4gYWRkIHQgayk7XG4gIHRcbjs7XG5cbmxldCB0X29mX3NleHAgbSBlX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IFNleHAuQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJIYXNoX3NldC50X29mX3NleHAgcmVxdWlyZXMgYSBsaXN0XCIgc2V4cFxuICB8IFNleHAuTGlzdCBsaXN0IC0+XG4gICAgbGV0IHQgPSBjcmVhdGUgbSB+c2l6ZTooTGlzdC5sZW5ndGggbGlzdCkgaW5cbiAgICBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHNleHAgLT5cbiAgICAgIGxldCBlID0gZV9vZl9zZXhwIHNleHAgaW5cbiAgICAgIG1hdGNoIHN0cmljdF9hZGQgdCBlIHdpdGhcbiAgICAgIHwgT2sgKCkgLT4gKClcbiAgICAgIHwgRXJyb3IgXyAtPiBvZl9zZXhwX2Vycm9yIFwiSGFzaF9zZXQudF9vZl9zZXhwIGdvdCBhIGR1cGxpY2F0ZSBlbGVtZW50XCIgc2V4cCk7XG4gICAgdFxuOztcblxubW9kdWxlIENyZWF0b3JzIChFbHQgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGhhc2hhYmxlIDogJ2EgdCBIYXNoYWJsZS50XG5lbmQpIDogc2lnXG4gIHZhbCB0X29mX3NleHAgOiAoU2V4cC50IC0+ICdhIEVsdC50KSAtPiBTZXhwLnQgLT4gJ2EgRWx0LnQgdFxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBFbHQudCB0XG4gICAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgICB3aXRoIHR5cGUgKCdlbHQsICd6KSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgICAoJ2VsdCwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKCkgPVxuICAgIGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKEhhc2hhYmxlLnRvX2tleSBFbHQuaGFzaGFibGUpXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2xpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIChIYXNoYWJsZS50b19rZXkgRWx0Lmhhc2hhYmxlKSBsXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCBlX29mX3NleHAgc2V4cCA9IHRfb2Zfc2V4cCAoSGFzaGFibGUudG9fa2V5IEVsdC5oYXNoYWJsZSkgZV9vZl9zZXhwIHNleHBcbmVuZFxuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBoYXNoX3NldFxuICB0eXBlICdhIGVsdCA9ICdhXG5cbiAgbGV0IGhhc2hhYmxlID0gcG9seV9oYXNoYWJsZVxuXG4gIGluY2x1ZGUgQ3JlYXRvcnMgKHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhXG5cbiAgICBsZXQgaGFzaGFibGUgPSBoYXNoYWJsZVxuICBlbmQpXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gIGxldCB0X3NleHBfZ3JhbW1hciBncmFtbWFyID0gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuZW5kXG5cbm1vZHVsZSBNIChFbHQgOiBULlQpID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSBFbHQudCB0XG5lbmRcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gZWx0KSB0ID1cbiAgc2V4cF9vZl90IEVsdC5zZXhwX29mX3QgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cCAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gZWx0KSBzZXhwID1cbiAgdF9vZl9zZXhwIChtb2R1bGUgRWx0KSBFbHQudF9vZl9zZXhwIHNleHBcbjs7XG5cbmxldCBtX190X3NleHBfZ3JhbW1hciAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBlbHQpID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAobGlzdF9zZXhwX2dyYW1tYXIgRWx0LnRfc2V4cF9ncmFtbWFyKVxuOztcblxubGV0IGVxdWFsX21fX3QgKG1vZHVsZSBfIDogRXF1YWxfbSkgdDEgdDIgPSBlcXVhbCB0MSB0MlxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgaGFzaGFibGUgPSBIYXNodGJsLlByaXZhdGUuaGFzaGFibGVcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBQcmludGZcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxuaW5jbHVkZSBGbG9hdDBcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGZsb2F0IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2Zsb2F0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9mbG9hdCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCAoZ2xvYmFsaXplIDogdCAtPiB0KSA9IChnbG9iYWxpemVfZmxvYXQgOiB0IC0+IHQpXG4gIGxldCB0X29mX3NleHAgPSAoZmxvYXRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfZmxvYXQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gZmxvYXRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IHRvX2Zsb2F0IHggPSB4XG5sZXQgb2ZfZmxvYXQgeCA9IHhcblxubGV0IG9mX3N0cmluZyBzID1cbiAgdHJ5IGZsb2F0X29mX3N0cmluZyBzIHdpdGhcbiAgfCBfIC0+IGludmFsaWRfYXJnZiBcIkZsb2F0Lm9mX3N0cmluZyAlc1wiIHMgKClcbjs7XG5cbmxldCBvZl9zdHJpbmdfb3B0ID0gZmxvYXRfb2Zfc3RyaW5nX29wdFxuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbigqIFN0b2xlbiBmcm9tIFtwZXJ2YXNpdmVzLm1sXS4gIEFkZHMgYSBcIi5cIiBhdCB0aGUgZW5kIGlmIG5lZWRlZC4gIEl0IGlzIGluXG4gICBbcGVydmFzaXZlcy5tbGldLCBidXQgaXQgYWxzbyBzYXlzIG5vdCB0byB1c2UgaXQgZGlyZWN0bHksIHNvIHdlIGNvcHkgYW5kIHBhc3RlIHRoZVxuICAgY29kZS4gSXQgbWFrZXMgdGhlIGFzc3VtcHRpb24gb24gdGhlIHN0cmluZyBwYXNzZWQgaW4gYXJndW1lbnQgdGhhdCBpdCB3YXMgcmV0dXJuZWQgYnlcbiAgIFtmb3JtYXRfZmxvYXRdLiAqKVxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgaSBsXG4gICAgdGhlbiBzIF4gXCIuXCJcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICAgIHwgXyAtPiBzKVxuICBpblxuICBsb29wIDBcbjs7XG5cbigqIExldCBbeV0gYmUgYSBwb3dlciBvZiAyLiAgVGhlbiB0aGUgbmV4dCByZXByZXNlbnRhYmxlIGZsb2F0IGlzOlxuICAgW3ogPSB5ICogKDEgKyAyICoqIC01MildXG4gICBhbmQgdGhlIHByZXZpb3VzIG9uZSBpc1xuICAgW3ggPSB5ICogKDEgLSAyICoqIC01MyldXG5cbiAgIEluIGdlbmVyYWwsIGV2ZXJ5IHR3byBhZGphY2VudCBmbG9hdHMgYXJlIHdpdGhpbiBhIGZhY3RvciBvZiBiZXR3ZWVuIFsxICsgMioqLTUzXVxuICAgYW5kIFsxICsgMioqLTUyXSBmcm9tIGVhY2ggb3RoZXIsIHRoYXQgaXMgd2l0aGluIFsxICsgMS4xZS0xNl0gYW5kIFsxICsgMi4zZS0xNl0uXG5cbiAgIFNvIGlmIHRoZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgZmxvYXQgc3RhcnRzIHdpdGggXCIxXCIsIHRoZW4gaXRzIGFkamFjZW50IGZsb2F0c1xuICAgd2lsbCB1c3VhbGx5IGRpZmZlciBmcm9tIGl0IGJ5IDEsIGFuZCBzb21ldGltZXMgYnkgMiwgYXQgdGhlIDE3dGggc2lnbmlmaWNhbnQgZGlnaXRcbiAgIChjb3VudGluZyBmcm9tIDEpLlxuXG4gICBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgdGhlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gc3RhcnRzIHdpdGggXCI5XCIsIHRoZW4gdGhlIGFkamFjZW50XG4gICBmbG9hdHMgd2lsbCBiZSBvZmYgYnkgbm8gbW9yZSB0aGFuIDIzIGF0IHRoZSAxNnRoIGFuZCAxN3RoIHNpZ25pZmljYW50IGRpZ2l0cy5cblxuICAgRS5nLjpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiAoMTAyNC4gKi4gKDEuIC0uIDIuKiogKC01My4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMVxuICAgICAgICAgICAgICAgICAgIDEyMzQgNTY3ODkwMTIzNDU2N1xuICAgICAtIDogc3RyaW5nID0gXCIxMDIzLjk5OTk5OTk5OTk5OTlcIlxuICAgdn1cbiAgIFByaW50aW5nIGEgY291cGxlIG9mIGV4dHJhIGRpZ2l0cyByZXZlYWxzIHRoYXQgdGhlIGRpZmZlcmVuY2UgaW5kZWVkIGlzIHJvdWdobHkgMTEgYXRcbiAgIGRpZ2l0cyAxN3RoIGFuZCAxOHRoICh0aGF0IGlzLCAxM3RoIGFuZCAxNHRoIGFmdGVyIFwiLlwiKTpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xOWdcIiAoMTAyNC4gKi4gKDEuIC0uIDIuKiogKC01My4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3ODlcbiAgICAgLSA6IHN0cmluZyA9IFwiMTAyMy45OTk5OTk5OTk5OTk4ODZcIlxuICAgdn1cblxuICAgVGhlIHVscCAodGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhZGphY2VudCBmbG9hdHMpIGlzIHR3aWNlIGFzIGJpZyBvbiB0aGUgb3RoZXIgc2lkZSBvZlxuICAgMTAyNC46XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTlnXCIgKDEwMjQuICouICgxLiArLiAyLioqICgtNTIuKSkpOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMVxuICAgICAgICAgICAgICAgICAgIDEyMzQgNTY3ODkwMTIzNDU2Nzg5XG4gICAgIC0gOiBzdHJpbmcgPSBcIjEwMjQuMDAwMDAwMDAwMDAwMjI3XCJcbiAgIHZ9XG5cbiAgIE5vdyB0YWtlIGEgcG93ZXIgb2YgMiB3aGljaCBzdGFydHMgd2l0aCA5OTpcblxuICAge3ZcbiAgICAgIyAyLioqOTMuIDs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExMTFcbiAgICAgICAgICAgICAgICAgMSAyMzQ1Njc4OTAxMjM0NTY3OFxuICAgICAtIDogZmxvYXQgPSA5LjkwMzUyMDMxNDI4MzA0MjJlKzI3XG5cbiAgICAgIyAyLioqOTMuICouICgxLiArLiAyLioqICgtNTIuKSk7O1xuICAgICAtIDogZmxvYXQgPSA5LjkwMzUyMDMxNDI4MzA0NDRlKzI3XG5cbiAgICAgIyAyLioqOTMuICouICgxLiAtLiAyLioqICgtNTMuKSk7O1xuICAgICAtIDogZmxvYXQgPSA5LjkwMzUyMDMxNDI4MzA0MTFlKzI3XG4gICB2fVxuXG4gICBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIDIqKjkzIGFuZCBpdHMgdHdvIG5laWdoYm9ycyBpcyBzbGlnaHRseSBtb3JlIHRoYW4sIHJlc3BlY3RpdmVseSxcbiAgIDEgYW5kIDIgYXQgc2lnbmlmaWNhbnQgZGlnaXQgMTYuXG5cbiAgIFRob3NlIGV4YW1wbGVzIHNob3cgdGhhdDpcbiAgIC0gMTcgc2lnbmlmaWNhbnQgZGlnaXRzIGlzIGFsd2F5cyBzdWZmaWNpZW50IHRvIHJlcHJlc2VudCBhIGZsb2F0IHdpdGhvdXQgYW1iaWd1aXR5XG4gICAtIDE1dGggc2lnbmlmaWNhbnQgZGlnaXQgY2FuIGFsd2F5cyBiZSByZXByZXNlbnRlZCBhY2N1cmF0ZWx5XG4gICAtIGNvbnZlcnRpbmcgYSBkZWNpbWFsIG51bWJlciB3aXRoIDE2IHNpZ25pZmljYW50IGRpZ2l0cyB0byBpdHMgbmVhcmVzdCBmbG9hdCBhbmQgYmFja1xuICAgICBjYW4gY2hhbmdlIHRoZSBsYXN0IGRlY2ltYWwgZGlnaXQgYnkgbm8gbW9yZSB0aGFuIDFcblxuICAgVG8gbWFrZSBzdXJlIHRoYXQgZmxvYXRzIG9idGFpbmVkIGJ5IGNvbnZlcnNpb24gZnJvbSBkZWNpbWFsIGZyYWN0aW9ucyAoZS5nLiBcIjMuMTRcIilcbiAgIGFyZSBwcmludGVkIHdpdGhvdXQgdHJhaWxpbmcgbm9uLXplcm8gZGlnaXRzLCBvbmUgc2hvdWxkIGNob29zZSB0aGUgZmlyc3QgYW1vbmcgdGhlXG4gICAnJS4xNWcnLCAnJS4xNmcnLCBhbmQgJyUuMTdnJyByZXByZXNlbnRhdGlvbnMgd2hpY2ggZG9lcyByb3VuZC10cmlwOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE1Z1wiIDMuMTQ7O1xuICAgICAtIDogc3RyaW5nID0gXCIzLjE0XCIgICAgICAgICAgICAgICAgICAgICAoKiBwaWNrIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTRcIlxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiIDMuMTQ7O1xuICAgICAtIDogc3RyaW5nID0gXCIzLjE0MDAwMDAwMDAwMDAwMDFcIiAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZSAqKVxuXG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4XCIgICAgICAgICAgICAgICAgICAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZS0tZG9lcyBub3Qgcm91bmQtdHJpcCAqKVxuICAgICAjIHNwcmludGYgXCIlLjE2Z1wiIDguMDAwMDAwMDAwMDAwMDAyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOC4wMDAwMDAwMDAwMDAwMDJcIiAgICAgICAgKCogcHJlZmVyIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4LjAwMDAwMDAwMDAwMDAwMThcIiAgICAgICAoKiB0aGlzIG9uZSBoYXMgb25lIGRpZ2l0IG9mIGp1bmsgYXQgdGhlIGVuZCAqKVxuICAgdn1cblxuICAgU2tpcHBpbmcgdGhlICclLjE2ZycgaW4gdGhlIGFib3ZlIHByb2NlZHVyZSBzYXZlcyB1cyBzb21lIHRpbWUsIGJ1dCBpdCBtZWFucyB0aGF0LCBhc1xuICAgc2VlbiBpbiB0aGUgc2Vjb25kIGV4YW1wbGUgYWJvdmUsIG9jY2FzaW9uYWxseSBudW1iZXJzIHdpdGggZXhhY3RseSAxNiBzaWduaWZpY2FudFxuICAgZGlnaXRzIHdpbGwgaGF2ZSBhbiBlcnJvciBpbnRyb2R1Y2VkIGF0IHRoZSAxN3RoIGRpZ2l0LiAgVGhhdCBpcyBwcm9iYWJseSBPSyBmb3JcbiAgIHR5cGljYWwgdXNlLCBiZWNhdXNlIGEgbnVtYmVyIHdpdGggMTYgc2lnbmlmaWNhbnQgZGlnaXRzIGlzIFwidWdseVwiIGFscmVhZHkuICBBZGRpbmcgb25lXG4gICBtb3JlIGRvZXNuJ3QgbWFrZSBpdCBtdWNoIHdvcnNlIGZvciBhIGh1bWFuIHJlYWRlci5cblxuICAgT24gdGhlIG90aGVyIGhhbmQsIHdlIGNhbm5vdCBza2lwICclLjE1ZycgYW5kIG9ubHkgbG9vayBhdCAnJS4xNmcnIGFuZCAnJS4xN2cnLCBzaW5jZVxuICAgdGhlIGluYWNjdXJhY3kgYXQgdGhlIDE2dGggZGlnaXQgbWlnaHQgaW50cm9kdWNlIHRoZSBub2lzZSB3ZSB3YW50IHRvIGF2b2lkOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE1Z1wiIDkuOTkyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOS45OTJcIiAgICAgICAgICAgICAgICAgICAgKCogcGljayB0aGlzIG9uZSAqKVxuICAgICAjIHNwcmludGYgXCIlLjE2Z1wiIDkuOTkyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOS45OTIwMDAwMDAwMDAwMDFcIiAgICAgICAgKCogZG8gbm90IHBpY2sgdGhpcyBvbmUtLWp1bmsgYXQgdGhlIGVuZCAqKVxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiIDkuOTkyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOS45OTIwMDAwMDAwMDAwMDA5XCJcbiAgIHZ9XG4qKVxubGV0IHRvX3N0cmluZyB4ID1cbiAgdmFsaWRfZmxvYXRfbGV4ZW1cbiAgICAobGV0IHkgPSBmb3JtYXRfZmxvYXQgXCIlLjE1Z1wiIHggaW5cbiAgICAgaWYgZmxvYXRfb2Zfc3RyaW5nIHkgPSB4IHRoZW4geSBlbHNlIGZvcm1hdF9mbG9hdCBcIiUuMTdnXCIgeClcbjs7XG5cbmxldCBtYXhfdmFsdWUgPSBpbmZpbml0eVxubGV0IG1pbl92YWx1ZSA9IG5lZ19pbmZpbml0eVxubGV0IG1pbl9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWUgPSAyLiAqKiAtMTA3NC5cbmxldCBtaW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlID0gMi4gKiogLTEwMjIuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBwaSA9IDB4My4yNDNGNkE4ODg1QTMwOEQzMTMxOThBMkUwMzcwNzNcbmxldCBzcXJ0X3BpID0gMHgxLkM1QkY4OTFCNEVGNkFBNzlDM0IwNTIwRDVEQjkzOFxubGV0IHNxcnRfMnBpID0gMHgyLjgxQjI2M0ZFQzRFMEIyQ0FGOTQ4M0Y1Q0U0NTlEQ1xubGV0IGV1bGVyID0gMHgwLjkzQzQ2N0UzN0RCMEM3QTREMUJFM0Y4MTAxNTJDQlxubGV0IG9mX2ludCA9IEludC50b19mbG9hdFxubGV0IHRvX2ludCA9IEludC5vZl9mbG9hdFxubGV0IG9mX2ludDYzIGkgPSBJbnQ2My50b19mbG9hdCBpXG5sZXQgb2ZfaW50NjQgaSA9IFN0ZGxpYi5JbnQ2NC50b19mbG9hdCBpXG5sZXQgdG9faW50NjQgPSBTdGRsaWIuSW50NjQub2ZfZmxvYXRcbmxldCBpcm91bmRfbGJvdW5kID0gbG93ZXJfYm91bmRfZm9yX2ludCBJbnQubnVtX2JpdHNcbmxldCBpcm91bmRfdWJvdW5kID0gdXBwZXJfYm91bmRfZm9yX2ludCBJbnQubnVtX2JpdHNcblxuKCogVGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBcImV4blwiIHJvdW5kaW5nIGZ1bmN0aW9ucyBpcyBpbXBvcnRhbnQsIHNvIHRoZXkgYXJlIHdyaXR0ZW5cbiAgIG91dCBzZXBhcmF0ZWx5LCBhbmQgdHVuZWQgaW5kaXZpZHVhbGx5LiAgKFdlIGNvdWxkIGhhdmUgdGhlIG9wdGlvbiB2ZXJzaW9ucyBjYWxsXG4gICB0aGUgXCJleG5cIiB2ZXJzaW9ucywgYnV0IHRoYXQgaW1wb3NlcyBhcmd1YWJseSBncmF0dWl0b3VzIG92ZXJoZWFkLS0tZXNwZWNpYWxseVxuICAgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgb2YgYmFja3RyYWNlcyBpcyBlbmFibGVkIHVwb24gXCJ3aXRoXCItLS1hbmQgdGhhdCBzZWVtc1xuICAgbm90IHdvcnRoIGl0IHdoZW4gY29tcGFyZWQgdG8gdGhlIHJlbGF0aXZlbHkgc21hbGwgYW1vdW50IG9mIGNvZGUgZHVwbGljYXRpb24uKSAqKVxuXG4oKiBFcnJvciByZXBvcnRpbmcgYmVsb3cgaXMgdmVyeSBjYXJlZnVsbHkgYXJyYW5nZWQgc28gdGhhdCwgZS5nLiwgW2lyb3VuZF9uZWFyZXN0X2V4bl1cbiAgIGl0c2VsZiBjYW4gYmUgaW5saW5lZCBpbnRvIGNhbGxlcnMgc3VjaCB0aGF0IHRoZXkgZG9uJ3QgbmVlZCB0byBhbGxvY2F0ZSBhIGJveCBmb3IgdGhlXG4gICBbZmxvYXRdIGFyZ3VtZW50LiAgVGhpcyBpcyBkb25lIHdpdGggYSBib3ggW2JveF0gZnVuY3Rpb24gY2FyZWZ1bGx5IGNob3NlbiB0byBhbGxvdyB0aGVcbiAgIGNvbXBpbGVyIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIGJveCBmb3IgdGhlIGZsb2F0IG9ubHkgaW4gZXJyb3IgY2FzZXMuICBTZWUsIGUuZy4sXG4gICBbLi4vLi4vemVyby90ZXN0L3ByaWNlX3Rlc3QubWxdIGZvciBhIG1lY2hhbmljYWwgdGVzdCBvZiB0aGlzIHByb3BlcnR5IHdoZW4gYnVpbGRpbmdcbiAgIHdpdGggW1hfTElCUkFSWV9JTkxJTklORz10cnVlXS4gKilcblxubGV0IGlyb3VuZF91cCB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF91cF9leG4gdCA9XG4gIGlmIHQgPiAwLjBcbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gY2VpbCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKClcbjs7XG5cbmxldCBpcm91bmRfZG93biB0ID1cbiAgaWYgdCA+PSAwLjBcbiAgdGhlbiBpZiB0IDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpIGVsc2UgTm9uZVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciB0IGluXG4gICAgaWYgdCcgPj0gaXJvdW5kX2xib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX2Rvd25fZXhuIHQgPVxuICBpZiB0ID49IDAuMFxuICB0aGVuXG4gICAgaWYgdCA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIiAoYm94IHQpICgpKVxuOztcblxubGV0IGlyb3VuZF90b3dhcmRzX3plcm8gdCA9XG4gIGlmIHQgPj0gaXJvdW5kX2xib3VuZCAmJiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfdG93YXJkc196ZXJvX2V4biB0ID1cbiAgaWYgdCA+PSBpcm91bmRfbGJvdW5kICYmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0Lmlyb3VuZF90b3dhcmRzX3plcm9fZXhuOiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKGJveCB0KVxuICAgICAgKClcbjs7XG5cbigqIE91dHNpZGUgb2YgdGhlIHJhbmdlIChyb3VuZF9uZWFyZXN0X2xiLi5yb3VuZF9uZWFyZXN0X3ViKSwgYWxsIHJlcHJlc2VudGFibGUgZG91Ymxlc1xuICAgYXJlIGludGVnZXJzIGluIHRoZSBtYXRoZW1hdGljYWwgc2Vuc2UsIGFuZCBbcm91bmRfbmVhcmVzdF0gc2hvdWxkIGJlIGlkZW50aXR5LlxuXG4gICBIb3dldmVyLCBmb3Igb2RkIG51bWJlcnMgd2l0aCB0aGUgYWJzb2x1dGUgdmFsdWUgYmV0d2VlbiAyKio1MiBhbmQgMioqNTMsIHRoZSBmb3JtdWxhXG4gICBbcm91bmRfbmVhcmVzdCB4ID0gZmxvb3IgKHggKyAwLjUpXSBkb2VzIG5vdCBob2xkOlxuXG4gICB7dlxuICAgICAjIGxldCBuYWl2ZV9yb3VuZF9uZWFyZXN0IHggPSBmbG9vciAoeCArLiAwLjUpOztcbiAgICAgIyBsZXQgeCA9IDIuICoqIDUyLiArLiAxLjs7XG4gICAgIHZhbCB4IDogZmxvYXQgPSA0NTAzNTk5NjI3MzcwNDk3LlxuICAgICAjIG5haXZlX3JvdW5kX25lYXJlc3QgeDs7XG4gICAgIC0gOiAgICAgZmxvYXQgPSA0NTAzNTk5NjI3MzcwNDk4LlxuICAgdn1cbiopXG5cbmxldCByb3VuZF9uZWFyZXN0X2xiID0gLS4oMi4gKiogNTIuKVxubGV0IHJvdW5kX25lYXJlc3RfdWIgPSAyLiAqKiA1Mi5cblxuKCogRm9yIFt4ID0gb25lX3VscCBgRG93biAwLjVdLCB0aGUgZm9ybXVsYSBbZmxvb3IgKHggKy4gMC41KV0gZm9yIHJvdW5kaW5nIHRvIG5lYXJlc3RcbiAgIGRvZXMgbm90IHdvcmssIGJlY2F1c2UgdGhlIGV4YWN0IHJlc3VsdCBpcyBoYWxmd2F5IGJldHdlZW4gW29uZV91bHAgYERvd24gMS5dIGFuZCBbMS5dLFxuICAgYW5kIGl0IGdldHMgcm91bmRlZCB1cCB0byBbMS5dIGR1ZSB0byB0aGUgcm91bmQtdGllcy10by1ldmVuIHJ1bGUuICopXG5sZXQgb25lX3VscF9sZXNzX3RoYW5faGFsZiA9IG9uZV91bHAgYERvd24gMC41XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCA9XG4gIHRcbiAgKy5cbiAgaWYgdCA9IG9uZV91bHBfbGVzc190aGFuX2hhbGZcbiAgdGhlbiBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmICgqIHNpbmNlIHQgPCAwLjUsIG1ha2Ugc3VyZSB0aGUgcmVzdWx0IGlzIDwgMS4wICopXG4gIGVsc2UgMC41XG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfMzIgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yICh0ICsuIDAuNSkgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0XzY0IHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW5cbiAgICBpZiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICAgIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCkpXG4gICAgZWxzZSBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgICBlbHNlIE5vbmVcbiAgZWxzZSBpZiB0ID4gcm91bmRfbmVhcmVzdF9sYlxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGZsb29yICh0ICsuIDAuNSkpKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3QgPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gaXJvdW5kX25lYXJlc3RfNjRcbiAgfCBXMzIgLT4gaXJvdW5kX25lYXJlc3RfMzJcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF9leG5fMzIgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpKVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciAodCArLiAwLjUpIGluXG4gICAgaWYgdCcgPj0gaXJvdW5kX2xib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbFwiIChib3ggdCkgKCkpXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF9uZWFyZXN0X2V4bl82NCB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuXG4gICAgaWYgdCA8IHJvdW5kX25lYXJlc3RfdWJcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQpXG4gICAgZWxzZSBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKClcbiAgZWxzZSBpZiB0ID4gcm91bmRfbmVhcmVzdF9sYlxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGZsb29yICh0ICsuIDAuNSkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKClcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF9leG4gPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gaXJvdW5kX25lYXJlc3RfZXhuXzY0XG4gIHwgVzMyIC0+IGlyb3VuZF9uZWFyZXN0X2V4bl8zMlxuOztcblxuKCogVGhlIGZvbGxvd2luZyBbaXJvdW5kX2V4bl0gYW5kIFtpcm91bmRdIGZ1bmN0aW9ucyBhcmUgc2xvd2VyIHRoYW4gdGhlIG9uZXMgYWJvdmUuXG4gICBUaGVpciBlcXVpdmFsZW5jZSB0byB0aG9zZSBmdW5jdGlvbnMgaXMgdGVzdGVkIGluIHRoZSB1bml0IHRlc3RzIGJlbG93LiAqKVxuXG5sZXRbQGlubGluZV0gaXJvdW5kX2V4biA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgbWF0Y2ggZGlyIHdpdGhcbiAgfCBgWmVybyAtPiBpcm91bmRfdG93YXJkc196ZXJvX2V4biB0XG4gIHwgYE5lYXJlc3QgLT4gaXJvdW5kX25lYXJlc3RfZXhuIHRcbiAgfCBgVXAgLT4gaXJvdW5kX3VwX2V4biB0XG4gIHwgYERvd24gLT4gaXJvdW5kX2Rvd25fZXhuIHRcbjs7XG5cbmxldCBpcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgdCA9XG4gIHRyeSBTb21lIChpcm91bmRfZXhuIH5kaXIgdCkgd2l0aFxuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IGlzX2luZiB0ID0gMS4gLy4gdCA9IDAuXG5sZXQgaXNfZmluaXRlIHQgPSB0IC0uIHQgPSAwLlxuXG5sZXQgbWluX2luYW4gKHggOiB0KSB5ID1cbiAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgaWYgeCA8IHkgdGhlbiB4IGVsc2UgeVxuOztcblxubGV0IG1heF9pbmFuICh4IDogdCkgeSA9XG4gIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIGlmIHggPiB5IHRoZW4geCBlbHNlIHlcbjs7XG5cbmxldCBhZGQgPSAoICsuIClcbmxldCBzdWIgPSAoIC0uIClcbmxldCBuZWcgPSAoIH4tLiApXG5sZXQgYWJzID0gYWJzX2Zsb2F0XG5sZXQgc2NhbGUgPSAoICouIClcbmxldCBzcXVhcmUgeCA9IHggKi4geFxuXG5tb2R1bGUgUGFydHMgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIGZyYWN0aW9uYWwgOiB0IC0+IGZsb2F0XG4gIHZhbCBpbnRlZ3JhbCA6IHQgLT4gZmxvYXRcbiAgdmFsIG1vZGYgOiBmbG9hdCAtPiB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gZmxvYXQgKiBmbG9hdFxuXG4gIGxldCBmcmFjdGlvbmFsIHQgPSBmc3QgdFxuICBsZXQgaW50ZWdyYWwgdCA9IHNuZCB0XG4gIGxldCBtb2RmID0gbW9kZlxuZW5kXG5cbmxldCBtb2RmID0gUGFydHMubW9kZlxubGV0IHJvdW5kX2Rvd24gPSBmbG9vclxubGV0IHJvdW5kX3VwID0gY2VpbFxubGV0IHJvdW5kX3Rvd2FyZHNfemVybyB0ID0gaWYgdCA+PSAwLiB0aGVuIHJvdW5kX2Rvd24gdCBlbHNlIHJvdW5kX3VwIHRcblxuKCogc2VlIHRoZSBjb21tZW50IGFib3ZlIFtyb3VuZF9uZWFyZXN0X2xiXSBhbmQgW3JvdW5kX25lYXJlc3RfdWJdIGZvciBhbiBleHBsYW5hdGlvbiAqKVxubGV0W0BvY2FtbC5pbmxpbmVdIHJvdW5kX25lYXJlc3RfaW5saW5lIHQgPVxuICBpZiB0ID4gcm91bmRfbmVhcmVzdF9sYiAmJiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICB0aGVuIGZsb29yIChhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0KVxuICBlbHNlIHQgKy4gMC5cbjs7XG5cbmxldCByb3VuZF9uZWFyZXN0IHQgPSAocm91bmRfbmVhcmVzdF9pbmxpbmUgW0BvY2FtbC5pbmxpbmVkIGFsd2F5c10pIHRcblxubGV0IHJvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuIHQgPVxuICBpZiB0IDw9IHJvdW5kX25lYXJlc3RfbGIgfHwgdCA+PSByb3VuZF9uZWFyZXN0X3ViXG4gIHRoZW4gdCArLiAwLlxuICBlbHNlIChcbiAgICBsZXQgZmxvb3IgPSBmbG9vciB0IGluXG4gICAgKCogW2NlaWxfb3Jfc3VjYyA9IGlmIHQgaXMgYW4gaW50ZWdlciB0aGVuIHQgKy4gMS4gZWxzZSBjZWlsIHRdLiAgRmFzdGVyIHRoYW4gW2NlaWxdLiAqKVxuICAgIGxldCBjZWlsX29yX3N1Y2MgPSBmbG9vciArLiAxLiBpblxuICAgIGxldCBkaWZmX2Zsb29yID0gdCAtLiBmbG9vciBpblxuICAgIGxldCBkaWZmX2NlaWwgPSBjZWlsX29yX3N1Y2MgLS4gdCBpblxuICAgIGlmIGRpZmZfZmxvb3IgPCBkaWZmX2NlaWxcbiAgICB0aGVuIGZsb29yXG4gICAgZWxzZSBpZiBkaWZmX2Zsb29yID4gZGlmZl9jZWlsXG4gICAgdGhlbiBjZWlsX29yX3N1Y2NcbiAgICBlbHNlIGlmICgqIGV4YWN0IHRpZSwgcGljayB0aGUgZXZlbiAqKVxuICAgICAgICAgICAgbW9kX2Zsb2F0IGZsb29yIDIuID0gMC5cbiAgICB0aGVuIGZsb29yXG4gICAgZWxzZSBjZWlsX29yX3N1Y2MpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbGJvdW5kID0gbG93ZXJfYm91bmRfZm9yX2ludCBJbnQ2My5udW1fYml0c1xubGV0IGludDYzX3JvdW5kX3Vib3VuZCA9IHVwcGVyX2JvdW5kX2Zvcl9pbnQgSW50NjMubnVtX2JpdHNcblxubGV0IGludDYzX3JvdW5kX3VwX2V4biB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpbnQ2M19yb3VuZF91Ym91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKSlcbiAgZWxzZSBpZiB0ID49IGludDYzX3JvdW5kX2xib3VuZFxuICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICgpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfZG93bl9leG4gdCA9XG4gIGlmIHQgPj0gMC4wXG4gIHRoZW5cbiAgICBpZiB0IDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciB0IGluXG4gICAgaWYgdCcgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCJcbiAgICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICAgKCkpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG4gdDAgPVxuICBsZXQgdCA9IChyb3VuZF9uZWFyZXN0X2lubGluZSBbQG9jYW1sLmlubGluZWQgYWx3YXlzXSkgdDAgaW5cbiAgaWYgdCA+IDAuXG4gIHRoZW5cbiAgICBpZiB0IDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIlxuICAgICAgICAoYm94IHQwKVxuICAgICAgICAoKVxuICBlbHNlIGlmIHQgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCJcbiAgICAgIChib3ggdDApXG4gICAgICAoKVxuOztcblxubGV0W0BpbmxpbmVdIGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuIGYgPVxuICBJbnQ2My5vZl9pbnQgKGlyb3VuZF9uZWFyZXN0X2V4biBmKVxuOztcblxubGV0IGludDYzX3JvdW5kX25lYXJlc3RfZXhuID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuXG4gIHwgVzMyIC0+IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuXG47O1xuXG5sZXQgcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgdCA9XG4gIG1hdGNoIGRpciB3aXRoXG4gIHwgYE5lYXJlc3QgLT4gcm91bmRfbmVhcmVzdCB0XG4gIHwgYERvd24gLT4gcm91bmRfZG93biB0XG4gIHwgYFVwIC0+IHJvdW5kX3VwIHRcbiAgfCBgWmVybyAtPiByb3VuZF90b3dhcmRzX3plcm8gdFxuOztcblxubW9kdWxlIENsYXNzID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBJbmZpbml0ZVxuICAgIHwgTmFuXG4gICAgfCBOb3JtYWxcbiAgICB8IFN1Ym5vcm1hbFxuICAgIHwgWmVyb1xuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChTdGRsaWIuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIEluZmluaXRlOyBOYW47IE5vcm1hbDsgU3Vibm9ybWFsOyBaZXJvIF0gOiB0IGxpc3QpXG5cbiAgbGV0IHRfb2Zfc2V4cCA9XG4gICAgKGxldCBlcnJvcl9zb3VyY2VfXzAwN18gPSBcImZsb2F0Lm1sLkNsYXNzLnRcIiBpblxuICAgICBmdW5jdGlvblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbmZpbml0ZVwiIHwgXCJJbmZpbml0ZVwiKSAtPiBJbmZpbml0ZVxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIC0+IE5hblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJub3JtYWxcIiB8IFwiTm9ybWFsXCIpIC0+IE5vcm1hbFxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzdWJub3JtYWxcIiB8IFwiU3Vibm9ybWFsXCIpIC0+IFN1Ym5vcm1hbFxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgLT4gWmVyb1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImluZmluaXRlXCIgfCBcIkluZmluaXRlXCIpIDo6IF8pIGFzXG4gICAgICAgc2V4cF9fMDA4XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDhfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSA6OiBfKSBhcyBzZXhwX18wMDhfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwN18gc2V4cF9fMDA4X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5vcm1hbFwiIHwgXCJOb3JtYWxcIikgOjogXykgYXMgc2V4cF9fMDA4XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwOF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJzdWJub3JtYWxcIiB8IFwiU3Vibm9ybWFsXCIpIDo6IF8pIGFzXG4gICAgICAgc2V4cF9fMDA4XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDhfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIDo6IF8pIGFzIHNleHBfXzAwOF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDhfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDZfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwN18gc2V4cF9fMDA2X1xuICAgICB8IHNleHBfXzAwNl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDZfXG4gICAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICB8IEluZmluaXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkluZmluaXRlXCJcbiAgICAgfCBOYW4gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmFuXCJcbiAgICAgfCBOb3JtYWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTm9ybWFsXCJcbiAgICAgfCBTdWJub3JtYWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3Vibm9ybWFsXCJcbiAgICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIHsgdW50eXBlZCA9XG4gICAgICAgIFZhcmlhbnRcbiAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJJbmZpbml0ZVwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJOYW5cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiTm9ybWFsXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlN1Ym5vcm1hbFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCB0b19zdHJpbmcgdCA9IHN0cmluZ19vZl9zZXhwIChzZXhwX29mX3QgdClcbiAgbGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxuZW5kXG5cbmxldCBjbGFzc2lmeSB0ID1cbiAgbGV0IG1vZHVsZSBDID0gQ2xhc3MgaW5cbiAgbWF0Y2ggY2xhc3NpZnlfZmxvYXQgdCB3aXRoXG4gIHwgRlBfbm9ybWFsIC0+IEMuTm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsIC0+IEMuU3Vibm9ybWFsXG4gIHwgRlBfemVybyAtPiBDLlplcm9cbiAgfCBGUF9pbmZpbml0ZSAtPiBDLkluZmluaXRlXG4gIHwgRlBfbmFuIC0+IEMuTmFuXG47O1xuXG5sZXQgaW5zZXJ0X3VuZGVyc2NvcmVzID8oZGVsaW1pdGVyID0gJ18nKSA/KHN0cmlwX3plcm8gPSBmYWxzZSkgc3RyaW5nID1cbiAgbWF0Y2ggU3RyaW5nLmxzcGxpdDIgc3RyaW5nIH5vbjonLicgd2l0aFxuICB8IE5vbmUgLT4gSW50X3N0cmluZ19jb252ZXJzaW9ucy5pbnNlcnRfZGVsaW1pdGVyIHN0cmluZyB+ZGVsaW1pdGVyXG4gIHwgU29tZSAobGVmdCwgcmlnaHQpIC0+XG4gICAgbGV0IGxlZnQgPSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLmluc2VydF9kZWxpbWl0ZXIgbGVmdCB+ZGVsaW1pdGVyIGluXG4gICAgbGV0IHJpZ2h0ID1cbiAgICAgIGlmIHN0cmlwX3plcm8gdGhlbiBTdHJpbmcucnN0cmlwIHJpZ2h0IH5kcm9wOihmdW4gYyAtPiBDaGFyLiggPSApIGMgJzAnKSBlbHNlIHJpZ2h0XG4gICAgaW5cbiAgICAobWF0Y2ggcmlnaHQgd2l0aFxuICAgICB8IFwiXCIgLT4gbGVmdFxuICAgICB8IF8gLT4gbGVmdCBeIFwiLlwiIF4gcmlnaHQpXG47O1xuXG5sZXQgdG9fc3RyaW5nX2h1bSA/ZGVsaW1pdGVyID8oZGVjaW1hbHMgPSAzKSA/c3RyaXBfemVybyA/KGV4cGxpY2l0X3BsdXMgPSBmYWxzZSkgZiA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgZGVjaW1hbHMgMFxuICB0aGVuIGludmFsaWRfYXJnZiBcInRvX3N0cmluZ19odW06IGludmFsaWQgYXJndW1lbnQgfmRlY2ltYWxzPSVkXCIgZGVjaW1hbHMgKCk7XG4gIG1hdGNoIGNsYXNzaWZ5IGYgd2l0aFxuICB8IENsYXNzLkluZmluaXRlIC0+IGlmIGYgPiAwLiB0aGVuIFwiaW5mXCIgZWxzZSBcIi1pbmZcIlxuICB8IENsYXNzLk5hbiAtPiBcIm5hblwiXG4gIHwgQ2xhc3MuTm9ybWFsIHwgQ2xhc3MuU3Vibm9ybWFsIHwgQ2xhc3MuWmVybyAtPlxuICAgIGxldCBzID1cbiAgICAgIGlmIGV4cGxpY2l0X3BsdXMgdGhlbiBzcHJpbnRmIFwiJSsuKmZcIiBkZWNpbWFscyBmIGVsc2Ugc3ByaW50ZiBcIiUuKmZcIiBkZWNpbWFscyBmXG4gICAgaW5cbiAgICBpbnNlcnRfdW5kZXJzY29yZXMgcyA/ZGVsaW1pdGVyID9zdHJpcF96ZXJvXG47O1xuXG5sZXQgc2V4cF9vZl90IHQgPVxuICBsZXQgc2V4cCA9IHNleHBfb2ZfdCB0IGluXG4gIG1hdGNoICFTZXhwLm9mX2Zsb2F0X3N0eWxlIHdpdGhcbiAgfCBgTm9fdW5kZXJzY29yZXMgLT4gc2V4cFxuICB8IGBVbmRlcnNjb3JlcyAtPlxuICAgIChtYXRjaCBzZXhwIHdpdGhcbiAgICAgfCBMaXN0IF8gLT5cbiAgICAgICByYWlzZV9zXG4gICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICBcIltzZXhwX29mX2Zsb2F0XSBwcm9kdWNlZCBzdHJhbmdlIHNleHBcIlxuICAgICAgICAgICAgWyBcInNleHBcIiwgU2V4cC5zZXhwX29mX3Qgc2V4cCBdKVxuICAgICB8IEF0b20gc3RyaW5nIC0+XG4gICAgICAgaWYgU3RyaW5nLmNvbnRhaW5zIHN0cmluZyAnRScgdGhlbiBzZXhwIGVsc2UgQXRvbSAoaW5zZXJ0X3VuZGVyc2NvcmVzIHN0cmluZykpXG47O1xuXG5sZXQgdG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nX2N1c3RvbSB0ID8ocHJlZml4ID0gXCJcIikgfmtpbG8gfm1lZ2EgfmdpZ2EgfnRlcmEgP3BldGEgKCkgPVxuICAoKiBSb3VuZCBhIHJhdGlvIHRvd2FyZCB0aGUgbmVhcmVzdCBpbnRlZ2VyLCByZXNvbHZpbmcgdGllcyB0b3dhcmQgdGhlIG5lYXJlc3QgZXZlblxuICAgICBudW1iZXIuICBGb3Igc2FuZSBpbnB1dHMgKGluIHBhcnRpY3VsYXIsIHdoZW4gW2Rlbm9taW5hdG9yXSBpcyBhbiBpbnRlZ2VyIGFuZFxuICAgICBbYWJzIG51bWVyYXRvciA8IDJlNTJdKSB0aGlzIHNob3VsZCBiZSBhY2N1cmF0ZS4gIE90aGVyd2lzZSwgdGhlIHJlc3VsdCBtaWdodCBiZSBhXG4gICAgIGxpdHRsZSBiaXQgb2ZmLCBidXQgd2UgZG9uJ3QgcmVhbGx5IHVzZSB0aGF0IGNhc2UuICopXG4gIGxldCBpcm91bmRfcmF0aW9fZXhuIH5udW1lcmF0b3IgfmRlbm9taW5hdG9yID1cbiAgICBsZXQgayA9IGZsb29yIChudW1lcmF0b3IgLy4gZGVub21pbmF0b3IpIGluXG4gICAgKCogaWYgW2FicyBrIDwgMmU1M10sIHRoZW4gYm90aCBba10gYW5kIFtrICsuIDEuXSBhcmUgYWNjdXJhdGVseSByZXByZXNlbnRlZCwgYW5kIGluXG4gICAgICAgcGFydGljdWxhciBbayArLiAxLiA+IGtdLiAgSWYgW2Rlbm9taW5hdG9yXSBpcyBhbHNvIGFuIGludGVnZXIsIGFuZFxuICAgICAgIFthYnMgKGRlbm9taW5hdG9yICouIChrICsuIDEpKSA8IDJlNTNdIChhbmQgaW4gc29tZSBvdGhlciBjYXNlcywgdG9vKSwgdGhlbiBbbG93ZXJdXG4gICAgICAgYW5kIFtoaWdoZXJdIGFyZSBhY3R1YWxseSBib3RoIGFjY3VyYXRlLiAgU2luY2UgKHJvdWdobHkpXG4gICAgICAgW251bWVyYXRvciA9IGRlbm9taW5hdG9yICouIGtdIHRoZW4gZm9yIFthYnMgbnVtZXJhdG9yIDwgMmU1Ml0gd2Ugc2hvdWxkIGJlXG4gICAgICAgZmluZS4gKilcbiAgICBsZXQgbG93ZXIgPSBkZW5vbWluYXRvciAqLiBrIGluXG4gICAgbGV0IGhpZ2hlciA9IGRlbm9taW5hdG9yICouIChrICsuIDEuKSBpblxuICAgICgqIFN1YnRyYWN0aW5nIG51bWJlcnMgd2l0aGluIGEgZmFjdG9yIG9mIHR3byBmcm9tIGVhY2ggb3RoZXIgaXMgYWNjdXJhdGUuXG4gICAgICAgU28gZWl0aGVyIHRoZSB0d28gc3VidHJhY3Rpb25zIGJlbG93IGFyZSBhY2N1cmF0ZSwgb3IgayA9IDAsIG9yIGsgPSAtMS5cbiAgICAgICBJbiBjYXNlIG9mIGEgdGllLCByb3VuZCB0byBldmVuLiAqKVxuICAgIGxldCBkaWZmX3JpZ2h0ID0gaGlnaGVyIC0uIG51bWVyYXRvciBpblxuICAgIGxldCBkaWZmX2xlZnQgPSBudW1lcmF0b3IgLS4gbG93ZXIgaW5cbiAgICBsZXQgayA9IGlyb3VuZF9uZWFyZXN0X2V4biBrIGluXG4gICAgaWYgZGlmZl9yaWdodCA8IGRpZmZfbGVmdFxuICAgIHRoZW4gayArIDFcbiAgICBlbHNlIGlmIGRpZmZfcmlnaHQgPiBkaWZmX2xlZnRcbiAgICB0aGVuIGtcbiAgICBlbHNlIGlmICgqIGEgdGllICopXG4gICAgICAgICAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChrIG1vZCAyKSAwXG4gICAgdGhlbiBrXG4gICAgZWxzZSBrICsgMVxuICBpblxuICBtYXRjaCBjbGFzc2lmeSB0IHdpdGhcbiAgfCBDbGFzcy5JbmZpbml0ZSAtPiBpZiB0IDwgMC4wIHRoZW4gXCItaW5mICBcIiBlbHNlIFwiaW5mICBcIlxuICB8IENsYXNzLk5hbiAtPiBcIm5hbiAgXCJcbiAgfCBDbGFzcy5TdWJub3JtYWwgfCBDbGFzcy5Ob3JtYWwgfCBDbGFzcy5aZXJvIC0+XG4gICAgbGV0IGdvIHQgPVxuICAgICAgbGV0IGNvbnZfb25lIHQgPVxuICAgICAgICBhc3NlcnQgKDAuIDw9IHQgJiYgdCA8IDk5OS45NSk7XG4gICAgICAgIGxldCB4ID0gcHJlZml4IF4gZm9ybWF0X2Zsb2F0IFwiJS4xZlwiIHQgaW5cbiAgICAgICAgKCogRml4IHRoZSBcIi4wXCIgc3VmZml4ICopXG4gICAgICAgIGlmIFN0cmluZy5pc19zdWZmaXggeCB+c3VmZml4OlwiLjBcIlxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgeCA9IEJ5dGVzLm9mX3N0cmluZyB4IGluXG4gICAgICAgICAgbGV0IG4gPSBCeXRlcy5sZW5ndGggeCBpblxuICAgICAgICAgIEJ5dGVzLnNldCB4IChuIC0gMSkgJyAnO1xuICAgICAgICAgIEJ5dGVzLnNldCB4IChuIC0gMikgJyAnO1xuICAgICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6eClcbiAgICAgICAgZWxzZSB4XG4gICAgICBpblxuICAgICAgbGV0IGNvbnYgbWFnIHQgZGVub21pbmF0b3IgPVxuICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgIChkZW5vbWluYXRvciA9IDEwMC4gJiYgdCA+PSA5OTkuOTUpXG4gICAgICAgICAgfHwgKGRlbm9taW5hdG9yID49IDEwMF8wMDAuICYmIHQgPj0gcm91bmRfbmVhcmVzdCAoZGVub21pbmF0b3IgKi4gOS45OTlfNSkpKTtcbiAgICAgICAgYXNzZXJ0ICh0IDwgcm91bmRfbmVhcmVzdCAoZGVub21pbmF0b3IgKi4gOV85OTkuNSkpO1xuICAgICAgICBsZXQgaSwgZCA9XG4gICAgICAgICAgbGV0IGsgPSBpcm91bmRfcmF0aW9fZXhuIH5udW1lcmF0b3I6dCB+ZGVub21pbmF0b3IgaW5cbiAgICAgICAgICAoKiBbbW9kXSBpcyBva2F5IGhlcmUgYmVjYXVzZSB3ZSBrbm93IGkgPj0gMC4gKilcbiAgICAgICAgICBrIC8gMTAsIGsgbW9kIDEwXG4gICAgICAgIGluXG4gICAgICAgIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICAgICAgYXNzZXJ0ICgwIDw9IGkgJiYgaSA8IDEwMDApO1xuICAgICAgICBhc3NlcnQgKDAgPD0gZCAmJiBkIDwgMTApO1xuICAgICAgICBpZiBkID0gMFxuICAgICAgICB0aGVuIHNwcmludGYgXCIlcyVkJXMgXCIgcHJlZml4IGkgbWFnXG4gICAgICAgIGVsc2Ugc3ByaW50ZiBcIiVzJWQlcyVkXCIgcHJlZml4IGkgbWFnIGRcbiAgICAgIGluXG4gICAgICAoKiBXaGlsZSB0aGUgc3RhbmRhcmQgbWV0cmljIHByZWZpeGVzIChlLmcuIGNhcGl0YWwgXCJNXCIgcmF0aGVyIHRoYW4gXCJtXCIsIFsxXSkgYXJlXG4gICAgICAgICBub21pbmFsbHkgbW9yZSBjb3JyZWN0LCB0aGlzIGhpbmRlcnMgcmVhZGFiaWxpdHkgaW4gb3VyIGNhc2UuICBFLmcuLCAxMEc2IGFuZFxuICAgICAgICAgMTA2NiBsb29rIHRvbyBzaW1pbGFyLiAgVGhhdCdzIGFuIGV4dHJlbWUgZXhhbXBsZSwgYnV0IGluIGdlbmVyYWwgayxtLGcsdCxwXG4gICAgICAgICBwcm9iYWJseSBzdGFuZCBvdXQgYmV0dGVyIHRoYW4gSyxNLEcsVCxQIHdoZW4gaW50ZXJzcGVyc2VkIHdpdGggZGlnaXRzLlxuXG4gICAgICAgICBbMV0gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXRyaWNfcHJlZml4ICopXG4gICAgICAoKiBUaGUgdHJpY2sgaGVyZSBpcyB0aGF0OlxuICAgICAgICAgLSB0aGUgZmlyc3QgYm91bmRhcnkgKDk5OS45NSkgYXMgYSBmbG9hdCBpcyBzbGlnaHRseSBvdmVyLXJlcHJlc2VudGVkIChzbyBpdCBpc1xuICAgICAgICAgICBiZXR0ZXIgYXBwcm94aW1hdGVkIGFzIFwiMWtcIiB0aGFuIGFzIFwiOTk5LjlcIiksXG4gICAgICAgICAtIHRoZSBvdGhlciBib3VuZGFyaWVzIGFyZSBhY2N1cmF0ZWx5IHJlcHJlc2VudGVkLCBiZWNhdXNlIHRoZXkgYXJlIGludGVnZXJzLlxuICAgICAgICAgICBUaGF0J3Mgd2h5IHRoZSBzdHJpY3QgZXF1YWxpdGllcyBiZWxvdyBkbyBleGFjdGx5IHdoYXQgd2Ugd2FudC4gKilcbiAgICAgIGlmIHQgPCA5OTkuOTVFMFxuICAgICAgdGhlbiBjb252X29uZSB0XG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFM1xuICAgICAgdGhlbiBjb252IGtpbG8gdCAxMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFNlxuICAgICAgdGhlbiBjb252IG1lZ2EgdCAxMDBfMDAwLlxuICAgICAgZWxzZSBpZiB0IDwgOTk5Ljk1RTlcbiAgICAgIHRoZW4gY29udiBnaWdhIHQgMTAwXzAwMF8wMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFMTJcbiAgICAgIHRoZW4gY29udiB0ZXJhIHQgMTAwXzAwMF8wMDBfMDAwLlxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHBldGEgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gc3ByaW50ZiBcIiVzJS4xZVwiIHByZWZpeCB0XG4gICAgICAgIHwgU29tZSBwZXRhIC0+XG4gICAgICAgICAgaWYgdCA8IDk5OS45NUUxNVxuICAgICAgICAgIHRoZW4gY29udiBwZXRhIHQgMTAwXzAwMF8wMDBfMDAwXzAwMC5cbiAgICAgICAgICBlbHNlIHNwcmludGYgXCIlcyUuMWVcIiBwcmVmaXggdClcbiAgICBpblxuICAgIGlmIHQgPj0gMC4gdGhlbiBnbyB0IGVsc2UgXCItXCIgXiBnbyB+LS50XG47O1xuXG5sZXQgdG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nIHQgPVxuICB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG9tIHQgfmtpbG86XCJrXCIgfm1lZ2E6XCJtXCIgfmdpZ2E6XCJnXCIgfnRlcmE6XCJ0XCIgfnBldGE6XCJwXCIgKClcbjs7XG5cbigqIFBlcmZvcm1hbmNlIG5vdGU6IEluaXRpYWxpemluZyB0aGUgYWNjdW11bGF0b3IgdG8gMSByZXN1bHRzIGluIG9uZSBleHRyYVxuICAgbXVsdGlwbHk7IGUuZy4sIHRvIGNvbXB1dGUgeCAqKiA0LCB3ZSBpbiBwcmluY2lwbGUgb25seSBuZWVkIDIgbXVsdGlwbGllcyxcbiAgIGJ1dCB0aGlzIGZ1bmN0aW9uIHdpbGwgaGF2ZSAzIG11bHRpcGxpZXMuICBIb3dldmVyLCBhdHRlbXB0cyB0byBhdm9pZCB0aGlzXG4gICAobGlrZSBkZWNyZW1lbnRpbmcgbiBhbmQgaW5pdGlhbGl6aW5nIGFjY3VtIHRvIGJlIHgsIG9yIGhhbmRsaW5nIHNtYWxsXG4gICBleHBvbmVudHMgYXMgYSBzcGVjaWFsIGNhc2UpIGhhdmUgbm90IHlpZWxkZWQgYW55dGhpbmcgdGhhdCBpcyBhIG5ldFxuICAgaW1wcm92ZW1lbnQuXG4qKVxubGV0IGludF9wb3cgeCBuID1cbiAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICBpZiBuID0gMFxuICB0aGVuIDEuXG4gIGVsc2UgKFxuICAgICgqIFVzaW5nIFt4ICsuICgtMC4pXSBvbiB0aGUgZm9sbG93aW5nIGxpbmUgY29udmluY2VzIHRoZSBjb21waWxlciB0byBhdm9pZCBhIGNlcnRhaW5cbiAgICAgICBib3hpbmcgKHRoYXQgd291bGQgcmVzdWx0IGluIGFsbG9jYXRpb24gaW4gZWFjaCBpdGVyYXRpb24pLiAgU29vbiwgdGhlIGNvbXBpbGVyXG4gICAgICAgc2hvdWxkbid0IG5lZWQgdGhpcyBcImhpbnRcIiB0byBhdm9pZCB0aGUgYm94aW5nLiAgVGhlIHJlYXNvbiB3ZSBhZGQgLTAgcmF0aGVyIHRoYW4gMFxuICAgICAgIGlzIHRoYXQgW3ggKy4gKC0wLildIGlzIGFwcGFyZW50bHkgYWx3YXlzIHRoZSBzYW1lIGFzIFt4XSwgd2hlcmVhcyBbeCArLiAwLl0gaXNcbiAgICAgICBub3QsIGluIHRoYXQgaXQgc2VuZHMgWy0wLl0gdG8gWzAuXS4gIFRoaXMgbWFrZXMgYSBkaWZmZXJlbmNlIGJlY2F1c2Ugd2Ugd2FudFxuICAgICAgIFtpbnRfcG93ICgtMC4pICgtMSldIHRvIHJldHVybiBuZWdfaW5maW5pdHkganVzdCBsaWtlIFstMC4gKiogLTEuXSB3b3VsZC4gICopXG4gICAgbGV0IHggPSByZWYgKHggKy4gLTAuKSBpblxuICAgIGxldCBuID0gcmVmIG4gaW5cbiAgICBsZXQgYWNjdW0gPSByZWYgMS4gaW5cbiAgICBpZiAhbiA8IDBcbiAgICB0aGVuIChcbiAgICAgICgqIHggKiogbiA9ICgxL3gpICoqIC1uICopXG4gICAgICB4IDo9IDEuIC8uICF4O1xuICAgICAgbiA6PSB+LSAoIW4pO1xuICAgICAgaWYgIW4gPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgKCogbiBtdXN0IGhhdmUgYmVlbiBtaW5faW50LCBzbyBpdCBpcyBub3cgc28gYmlnIHRoYXQgaXQgaGFzIHdyYXBwZWQgYXJvdW5kLlxuICAgICAgICAgICBXZSBkZWNyZW1lbnQgaXQgc28gdGhhdCBpdCBsb29rcyBwb3NpdGl2ZSBhZ2FpbiwgYnV0IGFjY29yZGluZ2x5IGhhdmVcbiAgICAgICAgICAgdG8gcHV0IGFuIGV4dHJhIGZhY3RvciBvZiB4IGluIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgICAgKilcbiAgICAgICAgYWNjdW0gOj0gIXg7XG4gICAgICAgIGRlY3IgbikpO1xuICAgICgqIExldHRpbmcgW2FdIGRlbm90ZSAodGhlIG9yaWdpbmFsIHZhbHVlIG9mKSBbeCAqKiBuXSwgd2UgbWFpbnRhaW5cbiAgICAgICB0aGUgaW52YXJpYW50IHRoYXQgWyh4ICoqIG4pICouIGFjY3VtID0gYV0uICopXG4gICAgd2hpbGUgIW4gPiAxIGRvXG4gICAgICBpZiAhbiBsYW5kIDEgPD4gMCB0aGVuIGFjY3VtIDo9ICF4ICouICFhY2N1bTtcbiAgICAgIHggOj0gIXggKi4gIXg7XG4gICAgICBuIDo9ICFuIGxzciAxXG4gICAgZG9uZTtcbiAgICAoKiBuIGlzIG5lY2Vzc2FyaWx5IDEgYXQgdGhpcyBwb2ludCwgc28gdGhlcmUgaXMgb25lIGFkZGl0aW9uYWxcbiAgICAgICBtdWx0aXBsaWNhdGlvbiBieSB4LiAqKVxuICAgICF4ICouICFhY2N1bSlcbjs7XG5cbmxldCByb3VuZF9nZW4geCB+aG93ID1cbiAgaWYgeCA9IDAuXG4gIHRoZW4gMC5cbiAgZWxzZSBpZiBub3QgKGlzX2Zpbml0ZSB4KVxuICB0aGVuIHhcbiAgZWxzZSAoXG4gICAgKCogU2lnbmlmaWNhbnQgZGlnaXRzIGFuZCBkZWNpbWFsIGRpZ2l0cy4gKilcbiAgICBsZXQgc2QsIGRkID1cbiAgICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgICB8IGBzaWduaWZpY2FudF9kaWdpdHMgc2QgLT5cbiAgICAgICAgbGV0IGRkID0gc2QgLSB0b19pbnQgKHJvdW5kX3VwIChsb2cxMCAoYWJzIHgpKSkgaW5cbiAgICAgICAgc2QsIGRkXG4gICAgICB8IGBkZWNpbWFsX2RpZ2l0cyBkZCAtPlxuICAgICAgICBsZXQgc2QgPSBkZCArIHRvX2ludCAocm91bmRfdXAgKGxvZzEwIChhYnMgeCkpKSBpblxuICAgICAgICBzZCwgZGRcbiAgICBpblxuICAgIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBpZiBzZCA8IDBcbiAgICB0aGVuIDAuXG4gICAgZWxzZSBpZiBzZCA+PSAxN1xuICAgIHRoZW4geFxuICAgIGVsc2UgKFxuICAgICAgKCogQ2hvb3NlIHRoZSBvcmRlciB0aGF0IGlzIGV4YWN0bHkgcmVwcmVzZW50YWJsZSBhcyBhIGZsb2F0LiBTbWFsbCBwb3NpdGl2ZVxuICAgICAgICAgaW50ZWdlcnMgYXJlLCBidXQgdGhlaXIgaW52ZXJzZXMgaW4gbW9zdCBjYXNlcyBhcmUgbm90LiAqKVxuICAgICAgbGV0IGFic19kZCA9IEludC5hYnMgZGQgaW5cbiAgICAgIGlmIGFic19kZCA+IDIyIHx8IHNkID49IDE2XG4gICAgICAgICAoKiAxMCoqMjIgaXMgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQsIGJ1dCAxMCoqMjMgaXMgbm90LCBzbyB1c2UgdGhlIHNsb3dcbiAgICAgICAgIHBhdGguICBTaW1pbGFybHksIGlmIHdlIG5lZWQgMTYgc2lnbmlmaWNhbnQgZGlnaXRzIGluIHRoZSByZXN1bHQsIHRoZW4gdGhlIGludGVnZXJcbiAgICAgICAgIFtyb3VuZF9uZWFyZXN0ICh4IDxvcD4gb3JkZXIpXSBtaWdodCBub3QgYmUgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQsIHNpbmNlXG4gICAgICAgICBmb3Igc29tZSByYW5nZXMgd2Ugb25seSBoYXZlIDE1IGRpZ2l0cyBvZiBwcmVjaXNpb24gZ3VhcmFudGVlZC5cblxuICAgICAgICAgVGhhdCBzYWlkLCB3ZSBhcmUgc3RpbGwgcm91bmRpbmcgdHdpY2UgaGVyZTpcblxuICAgICAgICAgMSkgZmlyc3QgdGltZSB3aGVuIHJvdW5kaW5nIFt4ICouIG9yZGVyXSBvciBbeCAvLiBvcmRlcl0gdG8gdGhlIG5lYXJlc3QgZmxvYXRcbiAgICAgICAgIChqdXN0IHRoZSBub3JtYWwgd2F5IGZsb2F0aW5nLXBvaW50IG11bHRpcGxpY2F0aW9uIG9yIGRpdmlzaW9uIHdvcmtzKSxcblxuICAgICAgICAgMikgc2Vjb25kIHRpbWUgd2hlbiBhcHBseWluZyBbcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW5dIHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICAgICBhYm92ZSBvcGVyYXRpb25cblxuICAgICAgICAgU28gZm9yIGFyZ3VtZW50cyB3aXRoaW4gYW4gdWxwIGZyb20gYSB0aWUgd2UgbWlnaHQgc3RpbGwgcHJvZHVjZSBhbiBvZmYtYnktb25lXG4gICAgICAgICByZXN1bHQuICopXG4gICAgICB0aGVuIG9mX3N0cmluZyAoc3ByaW50ZiBcIiUuKmdcIiBzZCB4KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBvcmRlciA9IGludF9wb3cgMTAuIGFic19kZCBpblxuICAgICAgICBpZiBkZCA+PSAwXG4gICAgICAgIHRoZW4gcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gKHggKi4gb3JkZXIpIC8uIG9yZGVyXG4gICAgICAgIGVsc2Ugcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gKHggLy4gb3JkZXIpICouIG9yZGVyKSkpXG47O1xuXG5sZXQgcm91bmRfc2lnbmlmaWNhbnQgeCB+c2lnbmlmaWNhbnRfZGlnaXRzID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgc2lnbmlmaWNhbnRfZGlnaXRzIDBcbiAgdGhlblxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5yb3VuZF9zaWduaWZpY2FudDogaW52YWxpZCBhcmd1bWVudCBzaWduaWZpY2FudF9kaWdpdHM6JWRcIlxuICAgICAgc2lnbmlmaWNhbnRfZGlnaXRzXG4gICAgICAoKVxuICBlbHNlIHJvdW5kX2dlbiB4IH5ob3c6KGBzaWduaWZpY2FudF9kaWdpdHMgc2lnbmlmaWNhbnRfZGlnaXRzKVxuOztcblxubGV0IHJvdW5kX2RlY2ltYWwgeCB+ZGVjaW1hbF9kaWdpdHMgPSByb3VuZF9nZW4geCB+aG93OihgZGVjaW1hbF9kaWdpdHMgZGVjaW1hbF9kaWdpdHMpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICgqIEFsc28gZmFpbHMgaWYgW21pbl0gb3IgW21heF0gaXMgbmFuICopXG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gICgqIGNsYW1wX3VuY2hlY2tlZCBpcyBpbiBmbG9hdDAubWwgKilcbiAgY2xhbXBfdW5jaGVja2VkXG4gICAgfnRvX2NsYW1wX21heWJlX25hbjp0XG4gICAgfm1pbl93aGljaF9pc19ub3RfbmFuOm1pblxuICAgIH5tYXhfd2hpY2hfaXNfbm90X25hbjptYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICgqIEFsc28gZmFpbHMgaWYgW21pbl0gb3IgW21heF0gaXMgbmFuICopXG4gIGlmIG1pbiA8PSBtYXhcbiAgdGhlblxuICAgIE9rXG4gICAgICAoY2xhbXBfdW5jaGVja2VkXG4gICAgICAgICB+dG9fY2xhbXBfbWF5YmVfbmFuOnRcbiAgICAgICAgIH5taW5fd2hpY2hfaXNfbm90X25hbjptaW5cbiAgICAgICAgIH5tYXhfd2hpY2hfaXNfbm90X25hbjptYXgpXG4gIGVsc2VcbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG47O1xuXG5sZXQgKCArICkgPSAoICsuIClcbmxldCAoIC0gKSA9ICggLS4gKVxubGV0ICggKiApID0gKCAqLiApXG5sZXQgKCAqKiApID0gKCAqKiApXG5sZXQgKCAvICkgPSAoIC8uIClcbmxldCAoICUgKSA9ICggJS4gKVxubGV0ICggfi0gKSA9ICggfi0uIClcblxubGV0W0BpbmxpbmVdIHNpZ25fZXhuIHQgOiBTaWduLnQgPVxuICBpZiB0ID4gMC5cbiAgdGhlbiBQb3NcbiAgZWxzZSBpZiB0IDwgMC5cbiAgdGhlbiBOZWdcbiAgZWxzZSBpZiB0ID0gMC5cbiAgdGhlbiBaZXJvXG4gIGVsc2UgRXJyb3IucmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiRmxvYXQuc2lnbl9leG4gb2YgTkFOXCIgWyBcIlwiLCBzZXhwX29mX3QgdCBdKVxuOztcblxubGV0IHNpZ25fb3JfbmFuIHQgOiBTaWduX29yX25hbi50ID1cbiAgaWYgdCA+IDAuIHRoZW4gUG9zIGVsc2UgaWYgdCA8IDAuIHRoZW4gTmVnIGVsc2UgaWYgdCA9IDAuIHRoZW4gWmVybyBlbHNlIE5hblxuOztcblxubGV0IGllZWVfbmVnYXRpdmUgdCA9XG4gIGxldCBiaXRzID0gU3RkbGliLkludDY0LmJpdHNfb2ZfZmxvYXQgdCBpblxuICBQb2x5LihiaXRzIDwgU3RkbGliLkludDY0Lnplcm8pXG47O1xuXG5sZXQgZXhwb25lbnRfYml0cyA9IDExXG5sZXQgbWFudGlzc2FfYml0cyA9IDUyXG5sZXQgZXhwb25lbnRfbWFzazY0ID0gSW50NjQuKHNoaWZ0X2xlZnQgb25lIGV4cG9uZW50X2JpdHMgLSBvbmUpXG5sZXQgZXhwb25lbnRfbWFzayA9IEludDY0LnRvX2ludF9leG4gZXhwb25lbnRfbWFzazY0XG5sZXQgbWFudGlzc2FfbWFzayA9IEludDYzLihzaGlmdF9sZWZ0IG9uZSBtYW50aXNzYV9iaXRzIC0gb25lKVxubGV0IG1hbnRpc3NhX21hc2s2NCA9IEludDYzLnRvX2ludDY0IG1hbnRpc3NhX21hc2tcblxubGV0IGllZWVfZXhwb25lbnQgdCA9XG4gIGxldCBiaXRzID0gU3RkbGliLkludDY0LmJpdHNfb2ZfZmxvYXQgdCBpblxuICBJbnQ2NC4oYml0X2FuZCAoc2hpZnRfcmlnaHRfbG9naWNhbCBiaXRzIG1hbnRpc3NhX2JpdHMpIGV4cG9uZW50X21hc2s2NClcbiAgfD4gU3RkbGliLkludDY0LnRvX2ludFxuOztcblxubGV0IGllZWVfbWFudGlzc2EgdCA9XG4gIGxldCBiaXRzID0gU3RkbGliLkludDY0LmJpdHNfb2ZfZmxvYXQgdCBpblxuICAoKiBUaGlzIGlzIHNhZmUgYmVjYXVzZSBtYW50aXNzYV9tYXNrNjQgPCBJbnQ2My5tYXhfdmFsdWUgKilcbiAgKEludDYzLm9mX2ludDY0X3RydW5jIFtAaW5saW5lZF0pIFN0ZGxpYi5JbnQ2NC4obG9nYW5kIGJpdHMgbWFudGlzc2FfbWFzazY0KVxuOztcblxubGV0IGNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYSA9XG4gIGlmIEludC4oYml0X2FuZCBleHBvbmVudCBleHBvbmVudF9tYXNrIDw+IGV4cG9uZW50KVxuICB0aGVuIGZhaWx3aXRoZiBcImV4cG9uZW50ICVkIG91dCBvZiByYW5nZSBbMCwgJWRdXCIgZXhwb25lbnQgZXhwb25lbnRfbWFzayAoKVxuICBlbHNlIGlmIEludDYzLihiaXRfYW5kIG1hbnRpc3NhIG1hbnRpc3NhX21hc2sgPD4gbWFudGlzc2EpXG4gIHRoZW5cbiAgICBmYWlsd2l0aGZcbiAgICAgIFwibWFudGlzc2EgJXMgb3V0IG9mIHJhbmdlIFswLCAlc11cIlxuICAgICAgKEludDYzLnRvX3N0cmluZyBtYW50aXNzYSlcbiAgICAgIChJbnQ2My50b19zdHJpbmcgbWFudGlzc2FfbWFzaylcbiAgICAgICgpXG4gIGVsc2UgKFxuICAgIGxldCBzaWduX2JpdHMgPSBpZiBuZWdhdGl2ZSB0aGVuIFN0ZGxpYi5JbnQ2NC5taW5faW50IGVsc2UgU3RkbGliLkludDY0Lnplcm8gaW5cbiAgICBsZXQgZXhwdF9iaXRzID1cbiAgICAgIFN0ZGxpYi5JbnQ2NC5zaGlmdF9sZWZ0IChTdGRsaWIuSW50NjQub2ZfaW50IGV4cG9uZW50KSBtYW50aXNzYV9iaXRzXG4gICAgaW5cbiAgICBsZXQgbWFudF9iaXRzID0gSW50NjMudG9faW50NjQgbWFudGlzc2EgaW5cbiAgICBsZXQgYml0cyA9IFN0ZGxpYi5JbnQ2NC4obG9nb3Igc2lnbl9iaXRzIChsb2dvciBleHB0X2JpdHMgbWFudF9iaXRzKSkgaW5cbiAgICBTdGRsaWIuSW50NjQuZmxvYXRfb2ZfYml0cyBiaXRzKVxuOztcblxubGV0IGNyZWF0ZV9pZWVlIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhID1cbiAgT3JfZXJyb3IudHJ5X3dpdGggKGZ1biAoKSAtPiBjcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2EpXG47O1xuXG5tb2R1bGUgVGVyc2UgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgdF9vZl9zZXhwID0gdF9vZl9zZXhwXG4gIGxldCB0b19zdHJpbmcgeCA9IFByaW50Zi5zcHJpbnRmIFwiJS44R1wiIHhcbiAgbGV0IHNleHBfb2ZfdCB4ID0gU2V4cC5BdG9tICh0b19zdHJpbmcgeClcbiAgbGV0IG9mX3N0cmluZyB4ID0gb2Zfc3RyaW5nIHhcbiAgbGV0IHRfc2V4cF9ncmFtbWFyID0gdF9zZXhwX2dyYW1tYXJcbmVuZFxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbigqIFRoZXNlIGFyZSBwYXJ0bHkgaGVyZSBhcyBhIHBlcmZvcm1hbmNlIGhhY2sgdG8gYXZvaWQgc29tZSBib3hpbmcgd2UncmUgZ2V0dGluZyB3aXRoXG4gICB0aGUgdmVyc2lvbnMgd2UgZ2V0IGZyb20gW1dpdGhfemVyb10uICBUaGV5IGFsc28gbWFrZSBbRmxvYXQuaXNfbmVnYXRpdmUgbmFuXSBhbmRcbiAgIFtGbG9hdC5pc19ub25fcG9zaXRpdmUgbmFuXSByZXR1cm4gW2ZhbHNlXTsgdGhlIHZlcnNpb25zIHdlIGdldCBmcm9tIFtXaXRoX3plcm9dIHJldHVyblxuICAgW3RydWVdLiAqKVxubGV0IGlzX3Bvc2l0aXZlIHQgPSB0ID4gMC5cbmxldCBpc19ub25fbmVnYXRpdmUgdCA9IHQgPj0gMC5cbmxldCBpc19uZWdhdGl2ZSB0ID0gdCA8IDAuXG5sZXQgaXNfbm9uX3Bvc2l0aXZlIHQgPSB0IDw9IDAuXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuRmxvYXRcIlxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG5lbmQpXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoICUgKSA9ICggJSApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50ID0gb2ZfaW50XG4gIGxldCBvZl9mbG9hdCB4ID0geFxuZW5kXG5cbm1vZHVsZSBPX2RvdCA9IHN0cnVjdFxuICBsZXQgKCAqLiApID0gKCAqIClcbiAgbGV0ICggKy4gKSA9ICggKyApXG4gIGxldCAoIC0uICkgPSAoIC0gKVxuICBsZXQgKCAvLiApID0gKCAvIClcbiAgbGV0ICggJS4gKSA9ICggJSApXG4gIGxldCAoIH4tLiApID0gKCB+LSApXG4gIGxldCAoICoqLiApID0gKCAqKiApXG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGJveCA9IGJveFxuICBsZXQgY2xhbXBfdW5jaGVja2VkID0gY2xhbXBfdW5jaGVja2VkXG4gIGxldCBsb3dlcl9ib3VuZF9mb3JfaW50ID0gbG93ZXJfYm91bmRfZm9yX2ludFxuICBsZXQgdXBwZXJfYm91bmRfZm9yX2ludCA9IHVwcGVyX2JvdW5kX2Zvcl9pbnRcbiAgbGV0IHNwZWNpYWxpemVkX2hhc2ggPSBoYXNoX2Zsb2F0XG4gIGxldCBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmID0gb25lX3VscF9sZXNzX3RoYW5faGFsZlxuICBsZXQgaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG4gPSBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4blxuICBsZXQgaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG4gPSBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4blxuICBsZXQgaXJvdW5kX25lYXJlc3RfZXhuXzY0ID0gaXJvdW5kX25lYXJlc3RfZXhuXzY0XG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4oKiBUaGVzZSBmdW5jdGlvbnMgc3BlY2lmaWNhbGx5IHJlcGxhY2UgZGVmYXVsdHMgaW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLlxuXG4gICBUaGUgZGVzaXJlZCBiZWhhdmlvciBoZXJlIGlzIHRvIHByb3BhZ2F0ZSBhIG5hbiBpZiBlaXRoZXIgYXJndW1lbnQgaXMgbmFuLiBCZWNhdXNlIHRoZVxuICAgZmlyc3QgY29tcGFyaXNvbiB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UgaWYgZWl0aGVyIGFyZ3VtZW50IGlzIG5hbiwgaXQgc3VmZmljZXMgdG9cbiAgIGNoZWNrIGlmIHggaXMgbmFuLiBUaGVuLCB3aGVuIHggaXMgbmFuIG9yIGJvdGggeCBhbmQgeSBhcmUgbmFuLCB3ZSByZXR1cm4geCA9IG5hbjsgYW5kXG4gICB3aGVuIHkgaXMgbmFuIGJ1dCBub3QgeCwgd2UgcmV0dXJuIHkgPSBuYW4uXG5cbiAgIFRoZXJlIGFyZSB2YXJpb3VzIHdheXMgdG8gaW1wbGVtZW50IHRoZXNlIGZ1bmN0aW9ucy4gIFRoZSBiZW5jaG1hcmsgYmVsb3cgc2hvd3MgYSBmZXdcbiAgIGRpZmZlcmVudCB2ZXJzaW9ucy4gIFRoaXMgYmVuY2htYXJrIHdhcyBydW4gb3ZlciBhbiBhcnJheSBvZiByYW5kb20gZmxvYXRzIChub25lIG9mXG4gICB3aGljaCBhcmUgbmFuKS5cblxuICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICDilIIgTmFtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgVGltZS9SdW4g4pSCXG4gICDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgIOKUgiBpZiBpc19uYW4geCB0aGVuIHggZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5IOKUgiAgIDIuNDJ1cyDilIJcbiAgIOKUgiBpZiBpc19uYW4geCB8fCB4IDwgeSB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDIuMDJ1cyDilIJcbiAgIOKUgiBpZiB4IDwgeSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDEuODh1cyDilIJcbiAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXG4gICBUaGUgYmVuY2htYXJrIGJlbG93IHdhcyBydW4gd2hlbiB4ID4geSBpcyBhbHdheXMgdHJ1ZSAoYWdhaW4sIG5vIG5hbiB2YWx1ZXMpLlxuXG4gICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgIOKUgiBOYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiBUaW1lL1J1biDilIJcbiAgIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAg4pSCIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIGlmIHggPCB5IHRoZW4geCBlbHNlIHkg4pSCICAgMi44M3VzIOKUglxuICAg4pSCIGlmIGlzX25hbiB4IHx8IHggPCB5IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMS45N3VzIOKUglxuICAg4pSCIGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMS41NnVzIOKUglxuICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4qKVxubGV0IG1pbiAoeCA6IHQpIHkgPSBpZiB4IDwgeSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5XG5sZXQgbWF4ICh4IDogdCkgeSA9IGlmIHggPiB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBCdWZmZXJfaW50ZlxuaW5jbHVkZSBTdGRsaWIuQnVmZmVyXG5cbmxldCBjb250ZW50c19ieXRlcyA9IHRvX2J5dGVzXG5sZXQgYWRkX3N1YnN0cmluZyB0IHMgfnBvcyB+bGVuID0gYWRkX3N1YnN0cmluZyB0IHMgcG9zIGxlblxubGV0IGFkZF9zdWJieXRlcyB0IHMgfnBvcyB+bGVuID0gYWRkX3N1YmJ5dGVzIHQgcyBwb3MgbGVuXG5sZXQgc2V4cF9vZl90IHQgPSBzZXhwX29mX3N0cmluZyAoY29udGVudHMgdClcbmxldCBjYW1sX2J1ZmZlcl9sZW5ndGggPSAoU3RkbGliLk9iai5tYWdpYyAoU3RkbGliLkJ1ZmZlci5sZW5ndGggOiB0IC0+IGludCkgOiB0IC0+IGludClcblxubGV0IGNhbWxfYnVmZmVyX2JsaXQgPVxuICAoU3RkbGliLk9iai5tYWdpY1xuICAgICAoU3RkbGliLkJ1ZmZlci5ibGl0IDogU3RkbGliLkJ1ZmZlci50IC0+IGludCAtPiBCeXRlcy50IC0+IGludCAtPiBpbnQgLT4gdW5pdClcbiAgICA6IFN0ZGxpYi5CdWZmZXIudCAtPiBpbnQgLT4gQnl0ZXMudCAtPiBpbnQgLT4gaW50IC0+IHVuaXQpXG47O1xuXG5tb2R1bGUgVG9fYnl0ZXMgPVxuICBCbGl0Lk1ha2VfZGlzdGluY3RcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBsZXQgbGVuZ3RoID0gY2FtbF9idWZmZXJfbGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IEJ5dGVzLnRcblxuICAgICAgbGV0IGNyZWF0ZSB+bGVuID0gQnl0ZXMuY3JlYXRlIGxlblxuICAgICAgbGV0IGxlbmd0aCA9IEJ5dGVzLmxlbmd0aFxuXG4gICAgICBsZXQgdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAgICAgICBjYW1sX2J1ZmZlcl9ibGl0IHNyYyBzcmNfcG9zIGRzdCBkc3RfcG9zIGxlblxuICAgICAgOztcbiAgICBlbmQpXG5cbmluY2x1ZGUgVG9fYnl0ZXNcbm1vZHVsZSBUb19zdHJpbmcgPSBCbGl0Lk1ha2VfdG9fc3RyaW5nIChTdGRsaWIuQnVmZmVyKSAoVG9fYnl0ZXMpXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbnR5cGUgdCA9IFN0ZGxpYi5QcmludGV4Yy5yYXdfYmFja3RyYWNlXG5cbmxldCBlbGlkZSA9IHJlZiBmYWxzZVxubGV0IGVsaWRlZF9tZXNzYWdlID0gXCI8YmFja3RyYWNlIGVsaWRlZCBpbiB0ZXN0PlwiXG5cbmxldCBnZXQgPyhhdF9tb3N0X251bV9mcmFtZXMgPSBJbnQubWF4X3ZhbHVlKSAoKSA9XG4gIFN0ZGxpYi5QcmludGV4Yy5nZXRfY2FsbHN0YWNrIGF0X21vc3RfbnVtX2ZyYW1lc1xuOztcblxubGV0IHRvX3N0cmluZyB0ID1cbiAgaWYgIWVsaWRlIHRoZW4gZWxpZGVkX21lc3NhZ2UgZWxzZSBTdGRsaWIuUHJpbnRleGMucmF3X2JhY2t0cmFjZV90b19zdHJpbmcgdFxuOztcblxubGV0IHRvX3N0cmluZ19saXN0IHQgPSBTdHJpbmcuc3BsaXRfbGluZXMgKHRvX3N0cmluZyB0KVxubGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5MaXN0IChMaXN0Lm1hcCAodG9fc3RyaW5nX2xpc3QgdCkgfmY6KGZ1biB4IC0+IFNleHAuQXRvbSB4KSlcblxubW9kdWxlIEV4biA9IHN0cnVjdFxuICBsZXQgc2V0X3JlY29yZGluZyA9IFN0ZGxpYi5QcmludGV4Yy5yZWNvcmRfYmFja3RyYWNlXG4gIGxldCBhbV9yZWNvcmRpbmcgPSBTdGRsaWIuUHJpbnRleGMuYmFja3RyYWNlX3N0YXR1c1xuICBsZXQgbW9zdF9yZWNlbnQgKCkgPSBTdGRsaWIuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKClcblxuICBsZXQgbW9zdF9yZWNlbnRfZm9yX2V4biBleG4gPVxuICAgIGlmIEV4bi5pc19waHlzX2VxdWFsX21vc3RfcmVjZW50IGV4biB0aGVuIFNvbWUgKG1vc3RfcmVjZW50ICgpKSBlbHNlIE5vbmVcbiAgOztcblxuICAoKiBXZSB0dXJuIG9uIGJhY2t0cmFjZXMgYnkgZGVmYXVsdCBpZiBPQ0FNTFJVTlBBUkFNIGRvZXNuJ3QgZXhwbGljaXRseSBtZW50aW9uIHRoZW0uICopXG4gIGxldCBtYXliZV9zZXRfcmVjb3JkaW5nICgpID1cbiAgICBsZXQgb2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhY2VzID1cbiAgICAgIG1hdGNoIFN5cy5nZXRlbnYgXCJPQ0FNTFJVTlBBUkFNXCIgd2l0aFxuICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICB8IFNvbWUgeCAtPiBMaXN0LmV4aXN0cyAoU3RyaW5nLnNwbGl0IHggfm9uOicsJykgfmY6KFN0cmluZy5pc19wcmVmaXggfnByZWZpeDpcImJcIilcbiAgICBpblxuICAgIGlmIG5vdCBvY2FtbHJ1bnBhcmFtX21lbnRpb25zX2JhY2t0cmFjZXMgdGhlbiBzZXRfcmVjb3JkaW5nIHRydWVcbiAgOztcblxuICAoKiB0aGUgY2FsbGVyIHNldCBzb21ldGhpbmcsIHRoZXkgYXJlIHJlc3BvbnNpYmxlICopXG5cbiAgbGV0IHdpdGhfcmVjb3JkaW5nIGIgfmYgPVxuICAgIGxldCBzYXZlZCA9IGFtX3JlY29yZGluZyAoKSBpblxuICAgIHNldF9yZWNvcmRpbmcgYjtcbiAgICBFeG4ucHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IHNldF9yZWNvcmRpbmcgc2F2ZWQpXG4gIDs7XG5lbmRcblxubGV0IGluaXRpYWxpemVfbW9kdWxlICgpID0gRXhuLm1heWJlX3NldF9yZWNvcmRpbmcgKClcbiIsIigqKiBUaGlzIG1vZHVsZSBpcyB0aGUgdG9wbGV2ZWwgb2YgdGhlIEJhc2UgbGlicmFyeTsgaXQncyB3aGF0IHlvdSBnZXQgd2hlbiB5b3Ugd3JpdGVcbiAgICBbb3BlbiBCYXNlXS5cblxuICAgIFRoZSBnb2FsIG9mIEJhc2UgaXMgYm90aCB0byBiZSBhIG1vcmUgY29tcGxldGUgc3RhbmRhcmQgbGlicmFyeSwgd2l0aCByaWNoZXIgQVBJcyxcbiAgICBhbmQgdG8gYmUgbW9yZSBjb25zaXN0ZW50IGluIGl0cyBkZXNpZ24uIEZvciBpbnN0YW5jZSwgaW4gdGhlIHN0YW5kYXJkIGxpYnJhcnlcbiAgICBzb21lIHRoaW5ncyBoYXZlIG1vZHVsZXMgYW5kIG90aGVycyBkb24ndDsgaW4gQmFzZSwgZXZlcnl0aGluZyBpcyBhIG1vZHVsZS5cblxuICAgIEJhc2UgZXh0ZW5kcyBzb21lIG1vZHVsZXMgYW5kIGRhdGEgc3RydWN0dXJlcyBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LCBsaWtlIFtBcnJheV0sXG4gICAgW0J1ZmZlcl0sIFtCeXRlc10sIFtDaGFyXSwgW0hhc2h0YmxdLCBbSW50MzJdLCBbSW50NjRdLCBbTGF6eV0sIFtMaXN0XSwgW01hcF0sXG4gICAgW05hdGl2ZWludF0sIFtQcmludGZdLCBbUmFuZG9tXSwgW1NldF0sIFtTdHJpbmddLCBbU3lzXSwgYW5kIFtVY2hhcl0uIE9uZSBrZXlcbiAgICBkaWZmZXJlbmNlIGlzIHRoYXQgQmFzZSBkb2Vzbid0IHVzZSBleGNlcHRpb25zIGFzIG11Y2ggYXMgdGhlIHN0YW5kYXJkIGxpYnJhcnkgYW5kXG4gICAgaW5zdGVhZCBtYWtlcyBoZWF2eSB1c2Ugb2YgdGhlIFtSZXN1bHRdIHR5cGUsIGFzIGluOlxuXG4gICAge1sgdHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2IgXX1cblxuICAgIEJhc2UgYWxzbyBhZGRzIGVudGlyZWx5IG5ldyBtb2R1bGVzLCBtb3N0IG5vdGFibHk6XG5cbiAgICAtIFtDb21wYXJhYmxlXSwgW0NvbXBhcmF0b3JdLCBhbmQgW0NvbXBhcmlzb25zXSBpbiBsaWV1IG9mIHBvbHltb3JwaGljIGNvbXBhcmUuXG4gICAgLSBbQ29udGFpbmVyXSwgd2hpY2ggcHJvdmlkZXMgYSBjb25zaXN0ZW50IGludGVyZmFjZSBhY3Jvc3MgY29udGFpbmVyLWxpa2UgZGF0YVxuICAgICAgc3RydWN0dXJlcyAoYXJyYXlzLCBsaXN0cywgc3RyaW5ncykuXG4gICAgLSBbUmVzdWx0XSwgW0Vycm9yXSwgYW5kIFtPcl9lcnJvcl0sIHN1cHBvcnRpbmcgdGhlIG9yLWVycm9yIHBhdHRlcm4uXG4qKVxuXG4oKl8gV2UgaGlkZSB0aGlzIGZyb20gdGhlIHdlYiBkb2NzIGJlY2F1c2UgdGhlIGxpbmUgd3JhcHBpbmcgaXMgYmFkLCBtYWtpbmcgaXRcbiAgcHJldHR5IG11Y2ggaW5zY3J1dGFibGUuICopXG4oKiovKiopXG5cbigqIFRoZSBpbnRlbnQgaXMgdG8gc2hhZG93IGFsbCBvZiBJTlJJQSdzIHN0YW5kYXJkIGxpYnJhcnkuICBNb2R1bGVzIGJlbG93IHdvdWxkIGNhdXNlXG4gICBjb21waWxhdGlvbiBlcnJvcnMgd2l0aG91dCBiZWluZyByZW1vdmVkIGZyb20gW1NoYWRvd19zdGRsaWJdIGJlZm9yZSBpbmNsdXNpb24uICopXG5cbmluY2x1ZGUgKFxuICBTaGFkb3dfc3RkbGliIDpcbiAgICBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgU2hhZG93X3N0ZGxpYlxuICAgIGVuZFxuICAgICgqIE1vZHVsZXMgZGVmaW5lZCBpbiBCYXNlICopXG4gICAgd2l0aCBtb2R1bGUgQXJyYXkgOj0gU2hhZG93X3N0ZGxpYi5BcnJheVxuICAgIHdpdGggbW9kdWxlIEF0b21pYyA6PSBTaGFkb3dfc3RkbGliLkF0b21pY1xuICAgIHdpdGggbW9kdWxlIEJvb2wgOj0gU2hhZG93X3N0ZGxpYi5Cb29sXG4gICAgd2l0aCBtb2R1bGUgQnVmZmVyIDo9IFNoYWRvd19zdGRsaWIuQnVmZmVyXG4gICAgd2l0aCBtb2R1bGUgQnl0ZXMgOj0gU2hhZG93X3N0ZGxpYi5CeXRlc1xuICAgIHdpdGggbW9kdWxlIENoYXIgOj0gU2hhZG93X3N0ZGxpYi5DaGFyXG4gICAgd2l0aCBtb2R1bGUgQ29uZGl0aW9uIDo9IFNoYWRvd19zdGRsaWIuQ29uZGl0aW9uXG4gICAgd2l0aCBtb2R1bGUgRWl0aGVyIDo9IFNoYWRvd19zdGRsaWIuRWl0aGVyXG4gICAgd2l0aCBtb2R1bGUgRmxvYXQgOj0gU2hhZG93X3N0ZGxpYi5GbG9hdFxuICAgIHdpdGggbW9kdWxlIEhhc2h0YmwgOj0gU2hhZG93X3N0ZGxpYi5IYXNodGJsXG4gICAgd2l0aCBtb2R1bGUgSW5fY2hhbm5lbCA6PSBTaGFkb3dfc3RkbGliLkluX2NoYW5uZWxcbiAgICB3aXRoIG1vZHVsZSBJbnQgOj0gU2hhZG93X3N0ZGxpYi5JbnRcbiAgICB3aXRoIG1vZHVsZSBJbnQzMiA6PSBTaGFkb3dfc3RkbGliLkludDMyXG4gICAgd2l0aCBtb2R1bGUgSW50NjQgOj0gU2hhZG93X3N0ZGxpYi5JbnQ2NFxuICAgIHdpdGggbW9kdWxlIExhenkgOj0gU2hhZG93X3N0ZGxpYi5MYXp5XG4gICAgd2l0aCBtb2R1bGUgTGlzdCA6PSBTaGFkb3dfc3RkbGliLkxpc3RcbiAgICB3aXRoIG1vZHVsZSBNYXAgOj0gU2hhZG93X3N0ZGxpYi5NYXBcbiAgICB3aXRoIG1vZHVsZSBOYXRpdmVpbnQgOj0gU2hhZG93X3N0ZGxpYi5OYXRpdmVpbnRcbiAgICB3aXRoIG1vZHVsZSBPcHRpb24gOj0gU2hhZG93X3N0ZGxpYi5PcHRpb25cbiAgICB3aXRoIG1vZHVsZSBPdXRfY2hhbm5lbCA6PSBTaGFkb3dfc3RkbGliLk91dF9jaGFubmVsXG4gICAgd2l0aCBtb2R1bGUgUHJpbnRmIDo9IFNoYWRvd19zdGRsaWIuUHJpbnRmXG4gICAgd2l0aCBtb2R1bGUgUXVldWUgOj0gU2hhZG93X3N0ZGxpYi5RdWV1ZVxuICAgIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICAgIHdpdGggbW9kdWxlIFJlc3VsdCA6PSBTaGFkb3dfc3RkbGliLlJlc3VsdFxuICAgIHdpdGggbW9kdWxlIFNldCA6PSBTaGFkb3dfc3RkbGliLlNldFxuICAgIHdpdGggbW9kdWxlIFNlbWFwaG9yZSA6PSBTaGFkb3dfc3RkbGliLlNlbWFwaG9yZVxuICAgIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgICB3aXRoIG1vZHVsZSBTdHJpbmcgOj0gU2hhZG93X3N0ZGxpYi5TdHJpbmdcbiAgICB3aXRoIG1vZHVsZSBTeXMgOj0gU2hhZG93X3N0ZGxpYi5TeXNcbiAgICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gICAgd2l0aCBtb2R1bGUgVW5pdCA6PSBTaGFkb3dfc3RkbGliLlVuaXRcbiAgICAoKiBPQ2FtbCA1LXJlbGF0ZWQgbW9kdWxlcyB3ZSBkb24ndCB3YW50IHRvIHN0YXJ0IHNoYWRvd2luZyB5ZXQuICopXG4gICAgd2l0aCBtb2R1bGUgRG9tYWluIDo9IFNoYWRvd19zdGRsaWIuRG9tYWluXG4gICAgd2l0aCBtb2R1bGUgVHlwZSA6PSBTaGFkb3dfc3RkbGliLlR5cGVcbiAgICAoKiBTdXBwb3J0IGZvciBnZW5lcmF0ZWQgbGV4ZXJzICopXG4gICAgd2l0aCBtb2R1bGUgTGV4aW5nIDo9IFNoYWRvd19zdGRsaWIuTGV4aW5nXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgOj0gKCdhLCAnYiwgJ2MpIGZvcm1hdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgOj0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IDo9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gICAgd2l0aCB0eXBlICdhIHJlZiA6PSAnYSByZWYpXG5bQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG4oKiovKiopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIEFwcGxpY2F0aXZlID0gQXBwbGljYXRpdmVcbm1vZHVsZSBBcnJheSA9IEFycmF5XG5tb2R1bGUgQXZsdHJlZSA9IEF2bHRyZWVcbm1vZHVsZSBCYWNrdHJhY2UgPSBCYWNrdHJhY2Vcbm1vZHVsZSBCaW5hcnlfc2VhcmNoID0gQmluYXJ5X3NlYXJjaFxubW9kdWxlIEJpbmFyeV9zZWFyY2hhYmxlID0gQmluYXJ5X3NlYXJjaGFibGVcbm1vZHVsZSBCbGl0ID0gQmxpdFxubW9kdWxlIEJvb2wgPSBCb29sXG5tb2R1bGUgQnVmZmVyID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgPSBCeXRlc1xubW9kdWxlIENoYXIgPSBDaGFyXG5tb2R1bGUgQ29tcGFyYWJsZSA9IENvbXBhcmFibGVcbm1vZHVsZSBDb21wYXJhdG9yID0gQ29tcGFyYXRvclxubW9kdWxlIENvbXBhcmlzb25zID0gQ29tcGFyaXNvbnNcbm1vZHVsZSBDb250YWluZXIgPSBDb250YWluZXJcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXJcbm1vZHVsZSBFcXVhbCA9IEVxdWFsXG5tb2R1bGUgRXJyb3IgPSBFcnJvclxubW9kdWxlIEV4biA9IEV4blxubW9kdWxlIEZpZWxkID0gRmllbGRcbm1vZHVsZSBGbG9hdCA9IEZsb2F0XG5tb2R1bGUgRmxvYXRhYmxlID0gRmxvYXRhYmxlXG5tb2R1bGUgRm4gPSBGblxubW9kdWxlIEZvcm1hdHRlciA9IEZvcm1hdHRlclxubW9kdWxlIEhhc2ggPSBIYXNoXG5tb2R1bGUgSGFzaF9zZXQgPSBIYXNoX3NldFxubW9kdWxlIEhhc2hhYmxlID0gSGFzaGFibGVcbm1vZHVsZSBIYXNoZXIgPSBIYXNoZXJcbm1vZHVsZSBIYXNodGJsID0gSGFzaHRibFxubW9kdWxlIElkZW50aWZpYWJsZSA9IElkZW50aWZpYWJsZVxubW9kdWxlIEluZGV4ZWRfY29udGFpbmVyID0gSW5kZXhlZF9jb250YWluZXJcbm1vZHVsZSBJbmZvID0gSW5mb1xubW9kdWxlIEludCA9IEludFxubW9kdWxlIEludDMyID0gSW50MzJcbm1vZHVsZSBJbnQ2MyA9IEludDYzXG5tb2R1bGUgSW50NjQgPSBJbnQ2NFxubW9kdWxlIEludGFibGUgPSBJbnRhYmxlXG5tb2R1bGUgSW50X21hdGggPSBJbnRfbWF0aFxubW9kdWxlIEludmFyaWFudCA9IEludmFyaWFudFxubW9kdWxlIERpY3Rpb25hcnlfaW1tdXRhYmxlID0gRGljdGlvbmFyeV9pbW11dGFibGVcbm1vZHVsZSBEaWN0aW9uYXJ5X211dGFibGUgPSBEaWN0aW9uYXJ5X211dGFibGVcbm1vZHVsZSBMYXp5ID0gTGF6eVxubW9kdWxlIExpc3QgPSBMaXN0XG5tb2R1bGUgTWFwID0gTWFwXG5tb2R1bGUgTWF5YmVfYm91bmQgPSBNYXliZV9ib3VuZFxubW9kdWxlIE1vbmFkID0gTW9uYWRcbm1vZHVsZSBOYXRpdmVpbnQgPSBOYXRpdmVpbnRcbm1vZHVsZSBOb3RoaW5nID0gTm90aGluZ1xubW9kdWxlIE9wdGlvbiA9IE9wdGlvblxubW9kdWxlIE9wdGlvbl9hcnJheSA9IE9wdGlvbl9hcnJheVxubW9kdWxlIE9yX2Vycm9yID0gT3JfZXJyb3Jcbm1vZHVsZSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uID0gT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vblxubW9kdWxlIE9yZGVyaW5nID0gT3JkZXJpbmdcbm1vZHVsZSBQb2x5ID0gUG9seVxubW9kdWxlIFByZXR0eV9wcmludGVyID0gUHJldHR5X3ByaW50ZXJcbm1vZHVsZSBQcmludGYgPSBQcmludGZcbm1vZHVsZSBMaW5rZWRfcXVldWUgPSBMaW5rZWRfcXVldWVcbm1vZHVsZSBRdWV1ZSA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tID0gUmFuZG9tXG5tb2R1bGUgUmVmID0gUmVmXG5tb2R1bGUgUmVzdWx0ID0gUmVzdWx0XG5tb2R1bGUgU2VxdWVuY2UgPSBTZXF1ZW5jZVxubW9kdWxlIFNldCA9IFNldFxubW9kdWxlIFNleHBhYmxlID0gU2V4cGFibGVcbm1vZHVsZSBTaWduID0gU2lnblxubW9kdWxlIFNpZ25fb3JfbmFuID0gU2lnbl9vcl9uYW5cbm1vZHVsZSBTb3VyY2VfY29kZV9wb3NpdGlvbiA9IFNvdXJjZV9jb2RlX3Bvc2l0aW9uXG5tb2R1bGUgU3RhY2sgPSBTdGFja1xubW9kdWxlIFN0YWdlZCA9IFN0YWdlZFxubW9kdWxlIFN0cmluZyA9IFN0cmluZ1xubW9kdWxlIFN0cmluZ2FibGUgPSBTdHJpbmdhYmxlXG5tb2R1bGUgU3lzID0gU3lzXG5tb2R1bGUgVCA9IFRcbm1vZHVsZSBUeXBlX2VxdWFsID0gVHlwZV9lcXVhbFxubW9kdWxlIFVuaWZvcm1fYXJyYXkgPSBVbmlmb3JtX2FycmF5XG5tb2R1bGUgVW5pdCA9IFVuaXRcbm1vZHVsZSBVY2hhciA9IFVjaGFyXG5tb2R1bGUgVmFyaWFudCA9IFZhcmlhbnRcbm1vZHVsZSBXaXRoX3JldHVybiA9IFdpdGhfcmV0dXJuXG5tb2R1bGUgV29yZF9zaXplID0gV29yZF9zaXplXG5cbigqIEF2b2lkIGEgbGV2ZWwgb2YgaW5kaXJlY3Rpb24gZm9yIHVzZXMgb2YgdGhlIHNpZ25hdHVyZXMgZGVmaW5lZCBpbiBbVF0uICopXG5pbmNsdWRlIFRcblxuKCogVGhpcyBpcyBhIGhhY2sgc28gdGhhdCBvZG9jIGNyZWF0ZXMgYmV0dGVyIGRvY3VtZW50YXRpb24uICopXG5tb2R1bGUgU2V4cCA9IHN0cnVjdFxuICBpbmNsdWRlIFNleHBfd2l0aF9jb21wYXJhYmxlICgqKiBAaW5saW5lICopXG5lbmRcblxuKCogW0ludF9zdHJpbmdfY29udmVyc2lvbnNdIGlzIHNlcGFyYXRlZCBmcm9tIFtJbnRfY29udmVyc2lvbnNdIGZvciBkZXBlbmRlbmN5IHJlYXNvbnMsXG4gICBidXQgdGhpcyBzZXBhcmF0aW9uIGlzIG5vdCBpbXBvcnRhbnQgZm9yIGNsaWVudHMuICopXG5tb2R1bGUgSW50X2NvbnZlcnNpb25zID0gc3RydWN0XG4gIGluY2x1ZGUgSW50X2NvbnZlcnNpb25zXG4gIGluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9uc1xuZW5kXG5cbigqKi8qKilcblxubW9kdWxlIEV4cG9ydGVkX2Zvcl9zcGVjaWZpY191c2VzID0gc3RydWN0XG4gIG1vZHVsZSBGaWVsZHNsaWIgPSBGaWVsZHNsaWJcbiAgbW9kdWxlIEdsb2JhbGl6ZSA9IEdsb2JhbGl6ZVxuICBtb2R1bGUgT2JqX2xvY2FsID0gT2JqX2xvY2FsXG4gIG1vZHVsZSBQcHhfY29tcGFyZV9saWIgPSBQcHhfY29tcGFyZV9saWJcbiAgbW9kdWxlIFBweF9lbnVtZXJhdGVfbGliID0gUHB4X2VudW1lcmF0ZV9saWJcbiAgbW9kdWxlIFBweF9oYXNoX2xpYiA9IFBweF9oYXNoX2xpYlxuICBtb2R1bGUgVmFyaWFudHNsaWIgPSBWYXJpYW50c2xpYlxuXG4gIGxldCBhbV90ZXN0aW5nID0gYW1fdGVzdGluZ1xuZW5kXG5cbigqKi8qKilcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICAoKiBbZGVyaXZpbmcgaGFzaF0gaXMgbWlzc2luZyBmb3IgW2FycmF5XSBhbmQgW3JlZl0gc2luY2UgdGhlc2UgdHlwZXMgYXJlIG11dGFibGUuICopXG4gIHR5cGUgJ2EgYXJyYXkgPSAnYSBBcnJheS50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9hcnJheV9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gaW50ID1cbiAgICBBcnJheS5jb21wYXJlX19sb2NhbFxuICA7O1xuXG4gIGxldCBjb21wYXJlX2FycmF5IDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+IGludCA9IEFycmF5LmNvbXBhcmVcblxuICBsZXQgZXF1YWxfYXJyYXlfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiBib29sID1cbiAgICBBcnJheS5lcXVhbF9fbG9jYWxcbiAgOztcblxuICBsZXQgZXF1YWxfYXJyYXkgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+IGJvb2wgPSBBcnJheS5lcXVhbFxuXG4gIGxldCBnbG9iYWxpemVfYXJyYXkgOiAnYS4gKCdhIC0+ICdhKSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSA9XG4gICAgZnVuICh0eXBlIGFfXzAxN18pIDogKChhX18wMTdfIC0+IGFfXzAxN18pIC0+IGFfXzAxN18gYXJyYXkgLT4gYV9fMDE3XyBhcnJheSkgLT5cbiAgICBBcnJheS5nbG9iYWxpemVcbiAgOztcblxuICBsZXQgYXJyYXlfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgYXJyYXkgPVxuICAgIEFycmF5LnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX2FycmF5IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIGFycmF5IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgQXJyYXkuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IGFycmF5X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBhcnJheSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBBcnJheS50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGJvb2wgPSBCb29sLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfYm9vbF9fbG9jYWwgPSAoQm9vbC5jb21wYXJlX19sb2NhbCA6IGJvb2wgLT4gYm9vbCAtPiBpbnQpXG4gIGxldCBjb21wYXJlX2Jvb2wgPSAoZnVuIGEgYiAtPiBjb21wYXJlX2Jvb2xfX2xvY2FsIGEgYiA6IGJvb2wgLT4gYm9vbCAtPiBpbnQpXG4gIGxldCBlcXVhbF9ib29sX19sb2NhbCA9IChCb29sLmVxdWFsX19sb2NhbCA6IGJvb2wgLT4gYm9vbCAtPiBib29sKVxuICBsZXQgZXF1YWxfYm9vbCA9IChmdW4gYSBiIC0+IGVxdWFsX2Jvb2xfX2xvY2FsIGEgYiA6IGJvb2wgLT4gYm9vbCAtPiBib29sKVxuICBsZXQgKGdsb2JhbGl6ZV9ib29sIDogYm9vbCAtPiBib29sKSA9IChCb29sLmdsb2JhbGl6ZSA6IGJvb2wgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9ib29sIDpcbiAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGJvb2wgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBCb29sLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2Jvb2wgOiBib29sIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBCb29sLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgYm9vbF9vZl9zZXhwID0gKEJvb2wudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGJvb2wpXG4gIGxldCBzZXhwX29mX2Jvb2wgPSAoQm9vbC5zZXhwX29mX3QgOiBib29sIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChib29sX3NleHBfZ3JhbW1hciA6IGJvb2wgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gQm9vbC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBjaGFyID0gQ2hhci50XG4gIFtAQGRlcml2aW5nX2lubGluZVxuICAgIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2NoYXJfX2xvY2FsID0gKENoYXIuY29tcGFyZV9fbG9jYWwgOiBjaGFyIC0+IGNoYXIgLT4gaW50KVxuICBsZXQgY29tcGFyZV9jaGFyID0gKGZ1biBhIGIgLT4gY29tcGFyZV9jaGFyX19sb2NhbCBhIGIgOiBjaGFyIC0+IGNoYXIgLT4gaW50KVxuICBsZXQgZXF1YWxfY2hhcl9fbG9jYWwgPSAoQ2hhci5lcXVhbF9fbG9jYWwgOiBjaGFyIC0+IGNoYXIgLT4gYm9vbClcbiAgbGV0IGVxdWFsX2NoYXIgPSAoZnVuIGEgYiAtPiBlcXVhbF9jaGFyX19sb2NhbCBhIGIgOiBjaGFyIC0+IGNoYXIgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfY2hhciA6IGNoYXIgLT4gY2hhcikgPSAoQ2hhci5nbG9iYWxpemUgOiBjaGFyIC0+IGNoYXIpXG5cbiAgbGV0IChoYXNoX2ZvbGRfY2hhciA6XG4gICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBjaGFyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgQ2hhci5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9jaGFyIDogY2hhciAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gQ2hhci5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGNoYXJfb2Zfc2V4cCA9IChDaGFyLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBjaGFyKVxuICBsZXQgc2V4cF9vZl9jaGFyID0gKENoYXIuc2V4cF9vZl90IDogY2hhciAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoY2hhcl9zZXhwX2dyYW1tYXIgOiBjaGFyIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IENoYXIudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgZXhuID0gRXhuLnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgbGV0IHNleHBfb2ZfZXhuID0gKEV4bi5zZXhwX29mX3QgOiBleG4gLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBmbG9hdCA9IEZsb2F0LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfZmxvYXRfX2xvY2FsID0gKEZsb2F0LmNvbXBhcmVfX2xvY2FsIDogZmxvYXQgLT4gZmxvYXQgLT4gaW50KVxuICBsZXQgY29tcGFyZV9mbG9hdCA9IChmdW4gYSBiIC0+IGNvbXBhcmVfZmxvYXRfX2xvY2FsIGEgYiA6IGZsb2F0IC0+IGZsb2F0IC0+IGludClcbiAgbGV0IGVxdWFsX2Zsb2F0X19sb2NhbCA9IChGbG9hdC5lcXVhbF9fbG9jYWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBib29sKVxuICBsZXQgZXF1YWxfZmxvYXQgPSAoZnVuIGEgYiAtPiBlcXVhbF9mbG9hdF9fbG9jYWwgYSBiIDogZmxvYXQgLT4gZmxvYXQgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCkgPSAoRmxvYXQuZ2xvYmFsaXplIDogZmxvYXQgLT4gZmxvYXQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfZmxvYXQgOlxuICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gZmxvYXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBGbG9hdC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9mbG9hdCA6IGZsb2F0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBGbG9hdC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGZsb2F0X29mX3NleHAgPSAoRmxvYXQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGZsb2F0KVxuICBsZXQgc2V4cF9vZl9mbG9hdCA9IChGbG9hdC5zZXhwX29mX3QgOiBmbG9hdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoZmxvYXRfc2V4cF9ncmFtbWFyIDogZmxvYXQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gRmxvYXQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50ID0gSW50LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50X19sb2NhbCA9IChJbnQuY29tcGFyZV9fbG9jYWwgOiBpbnQgLT4gaW50IC0+IGludClcbiAgbGV0IGNvbXBhcmVfaW50ID0gKGZ1biBhIGIgLT4gY29tcGFyZV9pbnRfX2xvY2FsIGEgYiA6IGludCAtPiBpbnQgLT4gaW50KVxuICBsZXQgZXF1YWxfaW50X19sb2NhbCA9IChJbnQuZXF1YWxfX2xvY2FsIDogaW50IC0+IGludCAtPiBib29sKVxuICBsZXQgZXF1YWxfaW50ID0gKGZ1biBhIGIgLT4gZXF1YWxfaW50X19sb2NhbCBhIGIgOiBpbnQgLT4gaW50IC0+IGJvb2wpXG4gIGxldCAoZ2xvYmFsaXplX2ludCA6IGludCAtPiBpbnQpID0gKEludC5nbG9iYWxpemUgOiBpbnQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX2ludCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgSW50Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2ludCA6IGludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgaW50X29mX3NleHAgPSAoSW50LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQpXG4gIGxldCBzZXhwX29mX2ludCA9IChJbnQuc2V4cF9vZl90IDogaW50IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChpbnRfc2V4cF9ncmFtbWFyIDogaW50IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBpbnQzMiA9IEludDMyLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50MzJfX2xvY2FsID0gKEludDMyLmNvbXBhcmVfX2xvY2FsIDogaW50MzIgLT4gaW50MzIgLT4gaW50KVxuICBsZXQgY29tcGFyZV9pbnQzMiA9IChmdW4gYSBiIC0+IGNvbXBhcmVfaW50MzJfX2xvY2FsIGEgYiA6IGludDMyIC0+IGludDMyIC0+IGludClcbiAgbGV0IGVxdWFsX2ludDMyX19sb2NhbCA9IChJbnQzMi5lcXVhbF9fbG9jYWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBib29sKVxuICBsZXQgZXF1YWxfaW50MzIgPSAoZnVuIGEgYiAtPiBlcXVhbF9pbnQzMl9fbG9jYWwgYSBiIDogaW50MzIgLT4gaW50MzIgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfaW50MzIgOiBpbnQzMiAtPiBpbnQzMikgPSAoSW50MzIuZ2xvYmFsaXplIDogaW50MzIgLT4gaW50MzIpXG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50MzIgOlxuICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50MzIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBJbnQzMi5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9pbnQzMiA6IGludDMyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBJbnQzMi5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGludDMyX29mX3NleHAgPSAoSW50MzIudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGludDMyKVxuICBsZXQgc2V4cF9vZl9pbnQzMiA9IChJbnQzMi5zZXhwX29mX3QgOiBpbnQzMiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoaW50MzJfc2V4cF9ncmFtbWFyIDogaW50MzIgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gSW50MzIudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50NjQgPSBJbnQ2NC50XG4gIFtAQGRlcml2aW5nX2lubGluZVxuICAgIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2ludDY0X19sb2NhbCA9IChJbnQ2NC5jb21wYXJlX19sb2NhbCA6IGludDY0IC0+IGludDY0IC0+IGludClcbiAgbGV0IGNvbXBhcmVfaW50NjQgPSAoZnVuIGEgYiAtPiBjb21wYXJlX2ludDY0X19sb2NhbCBhIGIgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnQ2NF9fbG9jYWwgPSAoSW50NjQuZXF1YWxfX2xvY2FsIDogaW50NjQgLT4gaW50NjQgLT4gYm9vbClcbiAgbGV0IGVxdWFsX2ludDY0ID0gKGZ1biBhIGIgLT4gZXF1YWxfaW50NjRfX2xvY2FsIGEgYiA6IGludDY0IC0+IGludDY0IC0+IGJvb2wpXG4gIGxldCAoZ2xvYmFsaXplX2ludDY0IDogaW50NjQgLT4gaW50NjQpID0gKEludDY0Lmdsb2JhbGl6ZSA6IGludDY0IC0+IGludDY0KVxuXG4gIGxldCAoaGFzaF9mb2xkX2ludDY0IDpcbiAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludDY0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgSW50NjQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfaW50NjQgOiBpbnQ2NCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50NjQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBpbnQ2NF9vZl9zZXhwID0gKEludDY0LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQ2NClcbiAgbGV0IHNleHBfb2ZfaW50NjQgPSAoSW50NjQuc2V4cF9vZl90IDogaW50NjQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGludDY0X3NleHBfZ3JhbW1hciA6IGludDY0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludDY0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIGxpc3QgPSAnYSBMaXN0LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfbGlzdF9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGludCA9XG4gICAgTGlzdC5jb21wYXJlX19sb2NhbFxuICA7O1xuXG4gIGxldCBjb21wYXJlX2xpc3QgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGludCA9IExpc3QuY29tcGFyZVxuXG4gIGxldCBlcXVhbF9saXN0X19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGJvb2wgPVxuICAgIExpc3QuZXF1YWxfX2xvY2FsXG4gIDs7XG5cbiAgbGV0IGVxdWFsX2xpc3QgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIGxpc3QgLT4gJ2EgbGlzdCAtPiBib29sID0gTGlzdC5lcXVhbFxuXG4gIGxldCBnbG9iYWxpemVfbGlzdCA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIGxpc3QgLT4gJ2EgbGlzdCA9XG4gICAgZnVuICh0eXBlIGFfXzA3OF8pIDogKChhX18wNzhfIC0+IGFfXzA3OF8pIC0+IGFfXzA3OF8gbGlzdCAtPiBhX18wNzhfIGxpc3QpIC0+XG4gICAgTGlzdC5nbG9iYWxpemVcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2xpc3QgOlxuICAgICAgICAnYS5cbiAgICAgICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgICAgICAtPiAnYSBsaXN0XG4gICAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBMaXN0Lmhhc2hfZm9sZF90XG4gIDs7XG5cbiAgbGV0IGxpc3Rfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgbGlzdCA9XG4gICAgTGlzdC50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9saXN0IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIGxpc3QgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBMaXN0LnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBsaXN0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBsaXN0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IExpc3QudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBuYXRpdmVpbnQgPSBOYXRpdmVpbnQudFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9uYXRpdmVpbnRfX2xvY2FsID1cbiAgICAoTmF0aXZlaW50LmNvbXBhcmVfX2xvY2FsIDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBpbnQpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50ID1cbiAgICAoZnVuIGEgYiAtPiBjb21wYXJlX25hdGl2ZWludF9fbG9jYWwgYSBiIDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBpbnQpXG4gIDs7XG5cbiAgbGV0IGVxdWFsX25hdGl2ZWludF9fbG9jYWwgPSAoTmF0aXZlaW50LmVxdWFsX19sb2NhbCA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gYm9vbClcblxuICBsZXQgZXF1YWxfbmF0aXZlaW50ID1cbiAgICAoZnVuIGEgYiAtPiBlcXVhbF9uYXRpdmVpbnRfX2xvY2FsIGEgYiA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gYm9vbClcbiAgOztcblxuICBsZXQgKGdsb2JhbGl6ZV9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50KSA9XG4gICAgKE5hdGl2ZWludC5nbG9iYWxpemUgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50KVxuICA7O1xuXG4gIGxldCAoaGFzaF9mb2xkX25hdGl2ZWludCA6XG4gICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBuYXRpdmVpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBOYXRpdmVpbnQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBOYXRpdmVpbnQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBuYXRpdmVpbnRfb2Zfc2V4cCA9IChOYXRpdmVpbnQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IG5hdGl2ZWludClcbiAgbGV0IHNleHBfb2ZfbmF0aXZlaW50ID0gKE5hdGl2ZWludC5zZXhwX29mX3QgOiBuYXRpdmVpbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gIGxldCAobmF0aXZlaW50X3NleHBfZ3JhbW1hciA6IG5hdGl2ZWludCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIE5hdGl2ZWludC50X3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAnYSBvcHRpb24gPSAnYSBPcHRpb24udFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9vcHRpb25fX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gLT4gaW50ID1cbiAgICBPcHRpb24uY29tcGFyZV9fbG9jYWxcbiAgOztcblxuICBsZXQgY29tcGFyZV9vcHRpb24gOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBpbnQgPVxuICAgIE9wdGlvbi5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGVxdWFsX29wdGlvbl9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gLT4gYm9vbCA9XG4gICAgT3B0aW9uLmVxdWFsX19sb2NhbFxuICA7O1xuXG4gIGxldCBlcXVhbF9vcHRpb24gOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gLT4gYm9vbCA9XG4gICAgT3B0aW9uLmVxdWFsXG4gIDs7XG5cbiAgbGV0IGdsb2JhbGl6ZV9vcHRpb24gOiAnYS4gKCdhIC0+ICdhKSAtPiAnYSBvcHRpb24gLT4gJ2Egb3B0aW9uID1cbiAgICBmdW4gKHR5cGUgYV9fMTA5XykgOiAoKGFfXzEwOV8gLT4gYV9fMTA5XykgLT4gYV9fMTA5XyBvcHRpb24gLT4gYV9fMTA5XyBvcHRpb24pIC0+XG4gICAgT3B0aW9uLmdsb2JhbGl6ZVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfb3B0aW9uIDpcbiAgICAgICAgJ2EuXG4gICAgICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAgICAgLT4gJ2Egb3B0aW9uXG4gICAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBPcHRpb24uaGFzaF9mb2xkX3RcbiAgOztcblxuICBsZXQgb3B0aW9uX29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIG9wdGlvbiA9XG4gICAgT3B0aW9uLnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX29wdGlvbiA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBvcHRpb24gLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBPcHRpb24uc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IG9wdGlvbl9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2Egb3B0aW9uIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IE9wdGlvbi50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIHJlZiA9ICdhIFJlZi50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9yZWZfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHJlZiAtPiAnYSByZWYgLT4gaW50ID1cbiAgICBSZWYuY29tcGFyZV9fbG9jYWxcbiAgOztcblxuICBsZXQgY29tcGFyZV9yZWYgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgcmVmIC0+ICdhIHJlZiAtPiBpbnQgPSBSZWYuY29tcGFyZVxuXG4gIGxldCBlcXVhbF9yZWZfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSByZWYgLT4gJ2EgcmVmIC0+IGJvb2wgPVxuICAgIFJlZi5lcXVhbF9fbG9jYWxcbiAgOztcblxuICBsZXQgZXF1YWxfcmVmIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSByZWYgLT4gJ2EgcmVmIC0+IGJvb2wgPSBSZWYuZXF1YWxcblxuICBsZXQgZ2xvYmFsaXplX3JlZiA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIHJlZiAtPiAnYSByZWYgPVxuICAgIGZ1biAodHlwZSBhX18xMzRfKSA6ICgoYV9fMTM0XyAtPiBhX18xMzRfKSAtPiBhX18xMzRfIHJlZiAtPiBhX18xMzRfIHJlZikgLT5cbiAgICBSZWYuZ2xvYmFsaXplXG4gIDs7XG5cbiAgbGV0IHJlZl9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSByZWYgPVxuICAgIFJlZi50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9yZWYgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgcmVmIC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgUmVmLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCByZWZfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHJlZiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gUmVmLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgc3RyaW5nID0gU3RyaW5nLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfc3RyaW5nX19sb2NhbCA9IChTdHJpbmcuY29tcGFyZV9fbG9jYWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGludClcbiAgbGV0IGNvbXBhcmVfc3RyaW5nID0gKGZ1biBhIGIgLT4gY29tcGFyZV9zdHJpbmdfX2xvY2FsIGEgYiA6IHN0cmluZyAtPiBzdHJpbmcgLT4gaW50KVxuICBsZXQgZXF1YWxfc3RyaW5nX19sb2NhbCA9IChTdHJpbmcuZXF1YWxfX2xvY2FsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sKVxuICBsZXQgZXF1YWxfc3RyaW5nID0gKGZ1biBhIGIgLT4gZXF1YWxfc3RyaW5nX19sb2NhbCBhIGIgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wpXG4gIGxldCAoZ2xvYmFsaXplX3N0cmluZyA6IHN0cmluZyAtPiBzdHJpbmcpID0gKFN0cmluZy5nbG9iYWxpemUgOiBzdHJpbmcgLT4gc3RyaW5nKVxuXG4gIGxldCAoaGFzaF9mb2xkX3N0cmluZyA6XG4gICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBzdHJpbmcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBTdHJpbmcuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfc3RyaW5nIDogc3RyaW5nIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBTdHJpbmcuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBzdHJpbmdfb2Zfc2V4cCA9IChTdHJpbmcudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHN0cmluZylcbiAgbGV0IHNleHBfb2Zfc3RyaW5nID0gKFN0cmluZy5zZXhwX29mX3QgOiBzdHJpbmcgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHN0cmluZ19zZXhwX2dyYW1tYXIgOiBzdHJpbmcgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gU3RyaW5nLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGJ5dGVzID0gQnl0ZXMudFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfYnl0ZXNfX2xvY2FsID0gKEJ5dGVzLmNvbXBhcmVfX2xvY2FsIDogYnl0ZXMgLT4gYnl0ZXMgLT4gaW50KVxuICBsZXQgY29tcGFyZV9ieXRlcyA9IChmdW4gYSBiIC0+IGNvbXBhcmVfYnl0ZXNfX2xvY2FsIGEgYiA6IGJ5dGVzIC0+IGJ5dGVzIC0+IGludClcbiAgbGV0IGVxdWFsX2J5dGVzX19sb2NhbCA9IChCeXRlcy5lcXVhbF9fbG9jYWwgOiBieXRlcyAtPiBieXRlcyAtPiBib29sKVxuICBsZXQgZXF1YWxfYnl0ZXMgPSAoZnVuIGEgYiAtPiBlcXVhbF9ieXRlc19fbG9jYWwgYSBiIDogYnl0ZXMgLT4gYnl0ZXMgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfYnl0ZXMgOiBieXRlcyAtPiBieXRlcykgPSAoQnl0ZXMuZ2xvYmFsaXplIDogYnl0ZXMgLT4gYnl0ZXMpXG4gIGxldCBieXRlc19vZl9zZXhwID0gKEJ5dGVzLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBieXRlcylcbiAgbGV0IHNleHBfb2ZfYnl0ZXMgPSAoQnl0ZXMuc2V4cF9vZl90IDogYnl0ZXMgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGJ5dGVzX3NleHBfZ3JhbW1hciA6IGJ5dGVzIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEJ5dGVzLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIHVuaXQgPSBVbml0LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfdW5pdF9fbG9jYWwgPSAoVW5pdC5jb21wYXJlX19sb2NhbCA6IHVuaXQgLT4gdW5pdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlX3VuaXQgPSAoZnVuIGEgYiAtPiBjb21wYXJlX3VuaXRfX2xvY2FsIGEgYiA6IHVuaXQgLT4gdW5pdCAtPiBpbnQpXG4gIGxldCBlcXVhbF91bml0X19sb2NhbCA9IChVbml0LmVxdWFsX19sb2NhbCA6IHVuaXQgLT4gdW5pdCAtPiBib29sKVxuICBsZXQgZXF1YWxfdW5pdCA9IChmdW4gYSBiIC0+IGVxdWFsX3VuaXRfX2xvY2FsIGEgYiA6IHVuaXQgLT4gdW5pdCAtPiBib29sKVxuICBsZXQgKGdsb2JhbGl6ZV91bml0IDogdW5pdCAtPiB1bml0KSA9IChVbml0Lmdsb2JhbGl6ZSA6IHVuaXQgLT4gdW5pdClcblxuICBsZXQgKGhhc2hfZm9sZF91bml0IDpcbiAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHVuaXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBVbml0Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX3VuaXQgOiB1bml0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBVbml0Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdW5pdF9vZl9zZXhwID0gKFVuaXQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHVuaXQpXG4gIGxldCBzZXhwX29mX3VuaXQgPSAoVW5pdC5zZXhwX29mX3QgOiB1bml0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh1bml0X3NleHBfZ3JhbW1hciA6IHVuaXQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gVW5pdC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIEZvcm1hdCBzdHVmZiAqKVxuXG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG5cbiAgKCoqIExpc3Qgb3BlcmF0b3JzICopXG5cbiAgaW5jbHVkZSBMaXN0LkluZml4XG5cbiAgKCoqIEludCBvcGVyYXRvcnMgYW5kIGNvbXBhcmlzb25zICopXG5cbiAgaW5jbHVkZSBJbnQuT1xuICBpbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICAoKiogRmxvYXQgb3BlcmF0b3JzICopXG5cbiAgaW5jbHVkZSBGbG9hdC5PX2RvdFxuXG4gICgqIFRoaXMgaXMgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgdG8gYmUgb3B0aW1pemVkIGF3YXkgaW4gbW9yZSBjb250ZXh0cy4gKilcblxuICAoKiogUmV2ZXJzZSBhcHBsaWNhdGlvbiBvcGVyYXRvci4gW3ggfD4gZyB8PiBmXSBpcyBlcXVpdmFsZW50IHRvIFtmIChnICh4KSldLiAqKVxuICBleHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoKCdhIC0+ICdiKVtAbG9jYWxfb3B0XSkgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5cbiAgKCoqIEFwcGxpY2F0aW9uIG9wZXJhdG9yLiBbZyBAQCBmIEBAIHhdIGlzIGVxdWl2YWxlbnQgdG8gW2cgKGYgKHgpKV0uICopXG4gIGV4dGVybmFsICggQEAgKSA6ICgoJ2EgLT4gJ2IpW0Bsb2NhbF9vcHRdKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuICAoKiogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbiAgKCogVGhlc2UgbmVlZCB0byBiZSBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBnZXQgdGhlIGxhenkgYmVoYXZpb3IgKilcbiAgZXh0ZXJuYWwgKCAmJiApIDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IChib29sW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlc2VxdWFuZFwiXG4gIGV4dGVybmFsICggfHwgKSA6IChib29sW0Bsb2NhbF9vcHRdKSAtPiAoYm9vbFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG4gIGV4dGVybmFsIG5vdCA6IChib29sW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5cbiAgKCogVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIGZvciB0aGUgd2FybmluZ3MgdG8gd29yayBwcm9wZXJseS4gKilcbiAgZXh0ZXJuYWwgaWdub3JlIDogKF9bQGxvY2FsX29wdF0pIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4gICgqKiBDb21tb24gc3RyaW5nIG9wZXJhdGlvbnMgKilcbiAgbGV0ICggXiApID0gU3RyaW5nLiggXiApXG5cbiAgKCoqIFJlZmVyZW5jZSBvcGVyYXRpb25zICopXG5cbiAgKCogRGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWxzIHNvIHRoYXQgdGhlIGNvbXBpbGVyIHNraXBzIHRoZSBjYW1sX21vZGlmeSB3aGVuIHBvc3NpYmxlIGFuZFxuICAgICB0byBrZWVwIHJlZmVyZW5jZSB1bmJveGluZyB3b3JraW5nICopXG4gIGV4dGVybmFsICggISApIDogKCdhIHJlZltAbG9jYWxfb3B0XSkgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuICBleHRlcm5hbCByZWYgOiAnYSAtPiAoJ2EgcmVmW0Bsb2NhbF9vcHRdKSA9IFwiJW1ha2VtdXRhYmxlXCJcbiAgZXh0ZXJuYWwgKCA6PSApIDogKCdhIHJlZltAbG9jYWxfb3B0XSkgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbiAgKCoqIFBhaXIgb3BlcmF0aW9ucyAqKVxuXG4gIGxldCBmc3QgPSBmc3RcbiAgbGV0IHNuZCA9IHNuZFxuXG4gICgqKiBFeGNlcHRpb25zIHN0dWZmICopXG5cbiAgKCogRGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgc28gdGhhdCB0aGUgY29tcGlsZXIgbWF5IHJld3JpdGUgJyVyYWlzZScgYXMgJyVyZXJhaXNlJy4gKilcbiAgZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gXyA9IFwiJXJhaXNlXCJcblxuICBsZXQgZmFpbHdpdGggPSBmYWlsd2l0aFxuICBsZXQgaW52YWxpZF9hcmcgPSBpbnZhbGlkX2FyZ1xuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICAoKiogTWlzYyAqKVxuXG4gIGV4dGVybmFsIHBoeXNfZXF1YWwgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWVxXCJcbiAgZXh0ZXJuYWwgZm9yY2UgOiAoJ2EgTGF6eS50W0Bsb2NhbF9vcHRdKSAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuZW5kXG5cbmluY2x1ZGUgRXhwb3J0XG5cbmluY2x1ZGUgQ29udGFpbmVyX2ludGYuRXhwb3J0ICgqKiBAaW5saW5lICopXG5cbmV4Y2VwdGlvbiBOb3RfZm91bmRfcyA9IE5vdF9mb3VuZF9zXG5cbigqIFdlIHBlcmZvcm0gdGhlc2Ugc2lkZSBlZmZlY3RzIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRoZW0gdG8gcnVuIGZvciBhbnkgY29kZSB0aGF0IHVzZXNcbiAgIFtCYXNlXS4gIElmIHRoaXMgd2VyZSBpbiBhbm90aGVyIG1vZHVsZSBpbiBbQmFzZV0gdGhhdCB3YXMgbm90IHVzZWQgaW4gc29tZSBwcm9ncmFtLFxuICAgdGhlbiB0aGUgc2lkZSBlZmZlY3RzIG1pZ2h0IG5vdCBiZSBydW4gaW4gdGhhdCBwcm9ncmFtLiAgVGhpcyB3aWxsIHJ1biBhcyBsb25nIGFzIHRoZVxuICAgcHJvZ3JhbSByZWZlcnMgdG8gYXQgbGVhc3Qgb25lIHZhbHVlIGRpcmVjdGx5IGluIFtCYXNlXTsgcmVmZXJyaW5nIHRvIHZhbHVlcyBpblxuICAgW0Jhc2UuQm9vbF0sIGZvciBleGFtcGxlLCBpcyBub3Qgc3VmZmljaWVudC4gKilcbmxldCAoKSA9IEJhY2t0cmFjZS5pbml0aWFsaXplX21vZHVsZSAoKVxuXG5tb2R1bGUgQ2FtbCA9IHN0cnVjdCBlbmQgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDIzLTAxXSB1c2UgU3RkbGliIGluc3RlYWQgb2YgQ2FtbFwiXVxuIl19
