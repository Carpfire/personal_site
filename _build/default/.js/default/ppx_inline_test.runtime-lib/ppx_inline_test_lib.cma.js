// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ppx_inline_test_lib
//# unitInfo: Requires: Base, Base__Exn, Base__Int63, Base__List, Base__Random, Base__String, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib, Stdlib__Arg, Stdlib__Array, Stdlib__Filename, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__Random, Stdlib__Result, Stdlib__Scanf, Stdlib__String, Stdlib__Sys, Time_now
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$13 = "",
    cst$14 = "\n",
    cst$15 = " ",
    cst_line = " , line ",
    cst_File = " File ",
    cst_threw = " threw",
    cst_s$0 = "%s",
    cst_s = "%s%!",
    cst$12 = ".\n",
    cst_Ppx_inline_test_lib$0 = "Ppx_inline_test_lib",
    cst_TES = "TES",
    cst_TESTING_FRAMEWORK = "TESTING_FRAMEWORK",
    cst_T_MODULE_at$0 = "T_MODULE at ",
    cst_T_MODULES = "T_MODULES",
    cst_inline_test_runner$0 = "inline-test-runner",
    cst_inline_tests_log$0 = "inline_tests.log",
    cst_ppx_inline_test_error_the_ =
      "ppx_inline_test error: the following -only-test flags matched nothing:",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$11 = cst$13,
    cst$9 = cst$14,
    cst$10 = cst$15,
    cst$7 = cst$14,
    cst$8 = cst$15,
    cst$5 = cst$14,
    cst$6 = "  ",
    cst$3 = cst$14,
    cst$4 = cst$13,
    cst$2 = ".",
    cst$0 = cst$13,
    cst$1 = ": ",
    initial = [0, 0, [0, "disabled", 0]],
    cst = cst$13,
    am_running_env_var = cst_TESTING_FRAMEWORK,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_String = global_data.Stdlib__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Result = global_data.Stdlib__Result,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Random = global_data.Base__Random,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int63 = global_data.Base__Int63,
    Time_now = global_data.Time_now,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    cst_source_tree_root$0 = "source_tree_root",
    cst_diff_path_prefix$0 = "diff_path_prefix",
    cst_diff_command = "diff_command",
    cst_in_place$0 = "in_place",
    cst_use_color = "use_color",
    _O_ =
      [0,
       [11,
        "ppx_inline_test error: attempted to access the [",
        [2, 0, [11, "] config before [init] was called", 0]]],
       "ppx_inline_test error: attempted to access the [%s] config before [init] was called"],
    _N_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    _M_ = [0, 1, [0, 7, 0]],
    _F_ = [0, [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, 0]]]], " %s:%d"],
    _G_ = [0, [12, 32, [2, 0, 0]], " %s"],
    _B_ =
      [0,
       [11,
        "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n",
        [10, 0]],
       "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n%!"],
    _C_ =
      [0,
       [11,
        "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n",
        [10, 0]],
       "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n%!"],
    _D_ =
      [0,
       [4,
        0,
        0,
        0,
        [11,
         " tests ran, ",
         [4, 0, 0, 0, [11, " test_modules ran\n", [10, 0]]]]],
       "%d tests ran, %d test_modules ran\n%!"],
    _E_ =
      [0,
       [11, cst_ppx_inline_test_error_the_, 0],
       cst_ppx_inline_test_error_the_],
    _H_ = [0, [11, cst$12, [10, 0]], ".\n%!"],
    _I_ =
      [0,
       [11, "ppx_inline_test error: no tests have been run.\n", [10, 0]],
       "ppx_inline_test error: no tests have been run.\n%!"],
    _K_ = [0, [11, cst_T_MODULES, 0], cst_T_MODULES],
    _L_ = [0, [11, ", ", [4, 0, 0, 0, [11, " TES", 0]]], ", %d TES"],
    _J_ =
      [0,
       [11,
        "FAILED ",
        [4,
         0,
         0,
         0,
         [11, " / ", [4, 0, 0, 0, [11, " tests", [2, 0, [12, 10, [10, 0]]]]]]]],
       "FAILED %d / %d tests%s\n%!"],
    _z_ =
      [0,
       [11,
        cst_T_MODULE_at$0,
        [2,
         0,
         [11,
          cst_threw,
          [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]]],
       "T_MODULE at %s threw%s%s.\n%s%s\n%!"],
    _A_ = [0, [11, cst_TES, 0], cst_TES],
    cst_ppx_inline_test_cannot_use =
      "ppx_inline_test: cannot use -list-partition or -partition without specifying a partition at preprocessing time",
    _t_ = [0, [2, 0, [12, 10, [2, 0, 0]]], "%s\n%s"],
    _u_ = [0, [2, 0, [10, 0]], cst_s],
    _v_ = [0, 1],
    _w_ =
      [0,
       [11, " (", [8, [0, 0, 0], 0, [0, 3], [11, " sec)\n", [10, 0]]]],
       " (%.3f sec)\n%!"],
    _x_ =
      [0,
       [2, 0, [11, " is false.\n", [2, 0, [12, 10, [10, 0]]]]],
       "%s is false.\n%s\n%!"],
    _y_ =
      [0,
       [2,
        0,
        [11,
         cst_threw,
         [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]],
       "%s threw%s%s.\n%s%s\n%!"],
    _s_ = [0, [2, 0, [10, 0]], cst_s],
    _r_ = [0, [2, 0, [10, 0]], cst_s],
    _q_ = [0, [12, 10, [2, 0, [12, 10, [10, 0]]]], "\n%s\n%!"],
    cst_T_MODULE_at = cst_T_MODULE_at$0,
    cst_in_TES = "  in TES",
    cst_time_without_resetting_ran = "time_without_resetting_random_seeds",
    cst_Ppx_inline_test_lib = cst_Ppx_inline_test_lib$0,
    _l_ = [0, 0],
    _j_ = [0, 0],
    cst_inline_tests_log = cst_inline_tests_log$0,
    _i_ =
      [0,
       [11,
        "Argument ",
        [2,
         0,
         [11, " doesn't fit the format filename[:line_number]\n", [10, 0]]]],
       "Argument %s doesn't fit the format filename[:line_number]\n%!"],
    _h_ =
      [0,
       [2,
        0,
        [11, ": unexpected anonymous argument ", [2, 0, [12, 10, [10, 0]]]]],
       "%s: unexpected anonymous argument %s\n%!"],
    cst_The_inline_test_runner_can =
      "The inline test runner can only be initialized once, and has already been initialized.",
    cst_inline_test_runner = cst_inline_test_runner$0,
    _g_ =
      [0,
       [2, 0, [12, 32, [2, 0, [12, 32, [2, 0, [11, " [args]", 0]]]]]],
       "%s %s %s [args]"],
    cst_Prefix_to_prepend_to_filep =
      " Prefix to prepend to filepaths in test output",
    cst_diff_path_prefix = "-diff-path-prefix",
    cst_Path_to_the_root_of_the_so = " Path to the root of the source tree",
    cst_source_tree_root = "-source-tree-root",
    cst_Diff_command_for_tests_tha =
      " Diff command for tests that require diffing (use - to disable diffing)",
    cst_diff_cmd = "-diff-cmd",
    cst_Update_expect_tests_in_pla = " Update expect tests in place",
    cst_in_place = "-in-place",
    cst_Summarize_tests_without_us = " Summarize tests without using color",
    cst_no_color = "-no-color",
    cst_location_Run_only_the_test =
      'location Run only the tests specified by all the -only-test options.\n                      Locations can be one of these forms:\n                      - file.ml\n                      - file.ml:line_number\n                      - File "file.ml"\n                      - File "file.ml", line 23\n                      - File "file.ml", line 23, characters 2-3',
    cst_only_test = "-only-test",
    cst_substring_Only_run_tests_w =
      "substring Only run tests whose names contain the given substring",
    cst_matching = "-matching",
    cst_tag_Only_run_tests_tagged_ =
      "tag Only run tests tagged with [tag] (overrides previous -drop-tag)",
    cst_require_tag = "-require-tag",
    cst_tag_Only_run_tests_not_tag =
      "tag Only run tests not tagged with [tag] (overrides previous -require-tag)",
    cst_drop_tag = "-drop-tag",
    cst_Log_the_tests_run_in_inlin = " Log the tests run in inline_tests.log",
    cst_log = "-log",
    cst_Show_the_number_of_tests_r = " Show the number of tests ran",
    cst_show_counts = "-show-counts",
    cst_End_with_an_error_if_no_te = " End with an error if no tests were run",
    cst_strict = "-strict",
    cst_Run_tests_only_up_to_the_f =
      " Run tests only up to the first error (doesn't work for expect tests)",
    cst_stop_on_error = "-stop-on-error",
    cst_Show_the_tests_as_they_run = " Show the tests as they run",
    cst_verbose = "-verbose",
    cst_Only_run_the_tests_in_the_ =
      " Only run the tests in the given partition",
    cst_partition = "-partition",
    cst_Lists_all_the_partitions_t =
      " Lists all the partitions that contain at least one test or test_module into FILE",
    cst_list_partitions_into_file = "-list-partitions-into-file",
    cst_Lists_all_the_partitions_t$0 =
      " Lists all the partitions that contain at least one test or test_module",
    cst_list_partitions = "-list-partitions",
    cst_Do_not_run_tests_but_show_ =
      " Do not run tests but show what would have been run",
    cst_list_test_names = "-list-test-names",
    _f_ =
      [0,
       [11,
        cst_File,
        [3,
         0,
         [11,
          cst_line,
          [4,
           0,
           0,
           0,
           [11,
            " , characters ",
            [4, 0, 0, 0, [11, " - ", [4, 0, 0, 0, [12, 32, [10, 0]]]]]]]]]],
       " File %S , line %d , characters %d - %d %!"],
    _e_ =
      [0,
       [11, cst_File, [3, 0, [11, cst_line, [4, 0, 0, 0, [12, 32, [10, 0]]]]]],
       " File %S , line %d %!"],
    _d_ = [0, [11, cst_File, [3, 0, [12, 32, [10, 0]]]], " File %S %!"],
    _c_ =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [2, 0, 0]]]]]]]]],
       "File %S, line %d, characters %d-%d%s"],
    cst_success = "success",
    cst_failure = "failure",
    cst_error = "error",
    _k_ = [0, [2, 0, 0], cst_s$0],
    _R_ = [0, [2, 0, 0], cst_s$0],
    _p_ = [0, 187165616, 545942154],
    _P_ = [0, 187165616, -863538453];
   function to_string(param){
    switch(param){
      case 0:
       return cst_success;
      case 1:
       return cst_failure;
      default: return cst_error;
    }
   }
   function combine(t1, t2){
    a:
    {
     switch(t1){
       case 0:
        if(! t2) return 0; break;
       case 1: break;
       default: break a;
     }
     if(2 !== t2) return 1;
    }
    return 2;
   }
   function combine_all(ts){
    return caml_call3(Stdlib_List[26], combine, 0, ts);
   }
   var
    already_initialized = [0, 0],
    test_modules_ran = [0, 0],
    test_modules_failed = [0, 0],
    tests_ran = [0, 0],
    tests_failed = [0, 0],
    dynamic_lib = [0, 0],
    action = [0, -950194894];
   try{
    caml_sys_getenv("FORCE_DROP_INLINE_TEST");
    var _T_ = 1, force_drop = _T_;
   }
   catch(_cb_){
    var _a_ = caml_wrap_exception(_cb_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    var force_drop = 0;
   }
   function get(param){return force_drop ? -950194894 : action[1];}
   var _b_ = caml_call2(Stdlib_Hashtbl[1], 0, 23), current = [0, cst];
   function found_test(param){
    var
     _b$_ = caml_string_notequal(current[1], cst$13),
     _ca_ = _b$_ ? 1 - caml_call2(Stdlib_Hashtbl[9], _b_, current[1]) : _b$_;
    return _ca_ ? caml_call3(Stdlib_Hashtbl[5], _b_, current[1], 0) : _ca_;
   }
   function is_current(param){
    if(! param) return 1;
    var p = param[1];
    return caml_string_equal(p, current[1]);
   }
   var current$0 = [0, 0];
   function current_tags(param){
    var t = current$0[1];
    function _b9_(m){return m[2];}
    var _b__ = caml_call2(Stdlib_List[20], _b9_, t);
    return caml_call1(Stdlib_List[14], _b__);
   }
   var
    verbose = [0, 0],
    strict = [0, 0],
    show_counts = [0, 0],
    list_test_names = [0, 0],
    delayed_errors = [0, 0],
    stop_on_error = [0, 0],
    log = [0, 0],
    time_sec = [0, 0.],
    use_color = [0, 1],
    in_place = [0, 0],
    diff_command = [0, 0],
    source_tree_root = [0, 0],
    diff_path_prefix = [0, 0];
   function displayed_descr(descr, filename, line, start_pos, end_pos){
    var _b7_ = caml_obj_tag(descr);
    a:
    if(250 === _b7_)
     var descr$0 = descr[1];
    else{
     if(246 !== _b7_ && 244 !== _b7_){var descr$0 = descr; break a;}
     var descr$0 = caml_call1(CamlinternalLazy[2], descr);
    }
    var
     _b8_ =
       caml_string_equal(descr$0, cst$13)
        ? cst$0
        : caml_call2(Stdlib[28], cst$1, descr$0);
    return caml_call6
            (Stdlib_Printf[4], _c_, filename, line, start_pos, end_pos, _b8_);
   }
   function parse_argv(current, args){
    if(args){
     var _bs_ = args[2];
     if(_bs_){
      var name = args[1];
      if(! caml_string_notequal(_bs_[1], cst_inline_test_runner$0)){
       var match = _bs_[2];
       if(match){
        var rest = match[2], lib = match[1];
        if(already_initialized[1])
         throw caml_maybe_attach_backtrace
                ([0, Stdlib_Arg[8], cst_The_inline_test_runner_can], 1);
        already_initialized[1] = 1;
        var
         tests = [0, 0],
         list_partitions = [0, 0],
         partition = [0, 0],
         tag_predicate = [0, initial],
         name_filter = [0, 0],
         _bt_ =
           caml_call4
            (Stdlib_Printf[4], _g_, name, cst_inline_test_runner, lib),
         _bu_ =
           function(anon){
            var _b6_ = caml_call3(Stdlib_Printf[4], _h_, name, anon);
            throw caml_maybe_attach_backtrace([0, Stdlib_Arg[8], _b6_], 1);
           },
         _bv_ = 0,
         _bw_ =
           [0,
            [0,
             cst_diff_path_prefix,
             [4, function(s){diff_path_prefix[1] = [0, s]; return 0;}],
             cst_Prefix_to_prepend_to_filep],
            _bv_],
         _bx_ =
           [0,
            [0,
             cst_source_tree_root,
             [4, function(s){source_tree_root[1] = [0, s]; return 0;}],
             cst_Path_to_the_root_of_the_so],
            _bw_],
         _by_ =
           [0,
            [0, cst_no_color, [3, use_color], cst_Summarize_tests_without_us],
            [0,
             [0, cst_in_place, [2, in_place], cst_Update_expect_tests_in_pla],
             [0,
              [0,
               cst_diff_cmd,
               [4, function(s){diff_command[1] = [0, s]; return 0;}],
               cst_Diff_command_for_tests_tha],
              _bx_]]],
         _bz_ =
           [0,
            [0,
             cst_only_test,
             [4,
              function(str){
               try{
                var
                 _bY_ =
                   function(file, line, start_pos, end_pos){return [0, file, [0, line]];
                   },
                 _bZ_ = [0, caml_call3(Stdlib_Scanf[5], str, _f_, _bY_)],
                 match = _bZ_;
               }
               catch(_b3_){
                try{
                 var
                  _bW_ = function(file, line){return [0, file, [0, line]];},
                  _bX_ = [0, caml_call3(Stdlib_Scanf[5], str, _e_, _bW_)],
                  match = _bX_;
                }
                catch(_b4_){
                 try{
                  var
                   _bU_ = function(file){return [0, file, 0];},
                   _bV_ = [0, caml_call3(Stdlib_Scanf[5], str, _d_, _bU_)],
                   match = _bV_;
                 }
                 catch(_b5_){var match = 0;}
                }
               }
               if(match)
                var
                 match$0 = match[1],
                 index = match$0[2],
                 file = match$0[1],
                 index$0 = index,
                 filename = file;
               else if(caml_call2(Stdlib_String[15], str, 58)){
                var
                 i = caml_call2(Stdlib_String[36], str, 58),
                 filename$0 = caml_call3(Stdlib_String[16], str, 0, i),
                 index_string =
                   caml_call3
                    (Stdlib_String[16],
                     str,
                     i + 1 | 0,
                     (caml_ml_string_length(str) - i | 0) - 1 | 0);
                try{var index$1 = runtime.caml_int_of_string(index_string);}
                catch(_b2_){
                 var _b0_ = caml_wrap_exception(_b2_);
                 if(_b0_[1] !== Stdlib[7])
                  throw caml_maybe_attach_backtrace(_b0_, 0);
                 var _b1_ = caml_call2(Stdlib_Printf[4], _i_, str);
                 throw caml_maybe_attach_backtrace
                        ([0, Stdlib_Arg[8], _b1_], 1);
                }
                var index$0 = [0, index$1], filename = filename$0;
               }
               else
                var index$0 = 0, filename = str;
               tests[1] = [0, [0, filename, index$0, [0, 0]], tests[1]];
               return 0;
              }],
             cst_location_Run_only_the_test],
            _by_],
         _bA_ =
           [0,
            [0,
             cst_matching,
             [4,
              function(s){name_filter[1] = [0, s, name_filter[1]]; return 0;}],
             cst_substring_Only_run_tests_w],
            _bz_],
         _bB_ =
           [0,
            [0,
             cst_require_tag,
             [4,
              function(tag){
               var t = tag_predicate[1], _bQ_ = t[2];
               function _bR_(_bT_){return caml_string_notequal(tag, _bT_);}
               var _bS_ = caml_call2(Stdlib_List[44], _bR_, _bQ_);
               tag_predicate[1] = [0, [0, tag, t[1]], _bS_];
               return 0;
              }],
             cst_tag_Only_run_tests_tagged_],
            _bA_],
         _bC_ =
           [0,
            [0,
             cst_drop_tag,
             [4,
              function(tag){
               var t = tag_predicate[1], _bM_ = [0, tag, t[2]], _bN_ = t[1];
               function _bO_(_bP_){return caml_string_notequal(tag, _bP_);}
               tag_predicate[1] =
                [0, caml_call2(Stdlib_List[44], _bO_, _bN_), _bM_];
               return 0;
              }],
             cst_tag_Only_run_tests_not_tag],
            _bB_],
         _bD_ =
           [0,
            [0, cst_verbose, [2, verbose], cst_Show_the_tests_as_they_run],
            [0,
             [0,
              cst_stop_on_error,
              [2, stop_on_error],
              cst_Run_tests_only_up_to_the_f],
             [0,
              [0, cst_strict, [2, strict], cst_End_with_an_error_if_no_te],
              [0,
               [0,
                cst_show_counts,
                [2, show_counts],
                cst_Show_the_number_of_tests_r],
               [0,
                [0,
                 cst_log,
                 [0,
                  function(param){
                   try{runtime.caml_sys_remove(cst_inline_tests_log$0);}
                   catch(_bL_){}
                   log[1] = [0, caml_call1(Stdlib[60], cst_inline_tests_log)];
                   return 0;
                  }],
                 cst_Log_the_tests_run_in_inlin],
                _bC_]]]]],
         _bE_ =
           [0,
            [0,
             cst_partition,
             [4, function(i){partition[1] = [0, i]; return 0;}],
             cst_Only_run_the_tests_in_the_],
            _bD_],
         _bF_ =
           [0,
            [0,
             cst_list_partitions_into_file,
             [4,
              function(file){list_partitions[1] = [0, [0, file]]; return 0;}],
             cst_Lists_all_the_partitions_t],
            _bE_],
         _bG_ =
           [0,
            [0,
             cst_list_partitions,
             [0, function(param){list_partitions[1] = _j_; return 0;}],
             cst_Lists_all_the_partitions_t$0],
            _bF_],
         _bH_ =
           [0,
            [0,
             cst_list_test_names,
             [0,
              function(param){
               list_test_names[1] = 1;
               verbose[1] = 1;
               return 0;
              }],
             cst_Do_not_run_tests_but_show_],
            _bG_],
         _bI_ = caml_call2(Stdlib_Arg[11], 0, _bH_),
         _bJ_ = caml_call1(Stdlib_Array[10], [0, name, rest]);
        caml_call5(Stdlib_Arg[3], current, _bJ_, _bI_, _bu_, _bt_);
        var match$0 = list_partitions[1];
        if(match$0)
         var
          where_to_list = match$0[1],
          _bK_ = [0, -260537174, where_to_list];
        else
         var _bK_ = [0, 1025081494, partition[1]];
        var
         v =
           [0,
            -753295984,
            [0, [0, lib, tests[1], name_filter[1], tag_predicate[1]], _bK_]];
        action[1] = v;
        return;
       }
      }
     }
    }
    return;
   }
   if(Base[87][1])
    try{
     var _S_ = caml_sys_argv(0);
     parse_argv(0, caml_call1(Stdlib_Array[9], _S_));
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Stdlib_Arg[8]){
      var msg = exn[2];
      caml_call2(Stdlib_Printf[3], _k_, msg);
      caml_call1(Stdlib[99], 1);
     }
     else{
      if(exn[1] !== Stdlib_Arg[7]) throw caml_maybe_attach_backtrace(exn, 0);
      var msg$0 = exn[2];
      caml_call2(Stdlib_Printf[2], _R_, msg$0);
      caml_call1(Stdlib[99], 0);
     }
    }
   function init(args){
    var current = [0, 0];
    try{parse_argv([0, current], args); return _l_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Stdlib_Arg[8]){var msg = exn[2]; return [1, msg];}
     if(exn[1] !== Stdlib_Arg[7]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$0 = exn[2];
     return [0, [0, msg$0]];
    }
   }
   var am_test_runner = typeof get(0) === "number" ? 0 : 1;
   a:
   {
    try{caml_sys_getenv("PPX_INLINE_TEST_LIB_AM_RUNNING_INLINE_TEST");}
    catch(_bq_){
     var _m_ = caml_wrap_exception(_bq_);
     if(_m_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_m_, 0);
     b:
     {
      try{var val = caml_sys_getenv(cst_TESTING_FRAMEWORK);}
      catch(_br_){
       var _n_ = caml_wrap_exception(_br_);
       if(_n_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_n_, 0);
       var _o_ = 0;
       break b;
      }
      var _Q_ = caml_string_notequal(val, "inline-test") ? 0 : 1, _o_ = _Q_;
     }
     var am_running = _o_;
     break a;
    }
    var am_running = 1;
   }
   var testing = am_test_runner ? _p_ : am_running ? _P_ : 822171972;
   function timestamp_ns(param){return caml_call1(Time_now[2], 0);}
   var
    where_to_cut_backtrace =
      [246,
       function(param){
        var
         _bo_ = caml_call2(Stdlib[28], cst$2, cst_time_without_resetting_ran),
         _bp_ = caml_call2(Stdlib[28], cst_Ppx_inline_test_lib, _bo_);
        return caml_call2(Base_String[86][2], 0, _bp_);
       }];
   function time_without_resetting_random_(f){
    var before_ns = timestamp_ns(0);
    try{var _bn_ = [0, caml_call1(f, 0)], res = _bn_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      res = [1, [0, exn, caml_call1(Stdlib_Printexc[6], 0)]];
    }
    var
     _bl_ = timestamp_ns(0),
     _bm_ = caml_call2(Base_Int63[46], _bl_, before_ns);
    time_sec[1] = caml_call1(Base_Int63[3], _bm_) / 1000000000.;
    return res;
   }
   var
    saved_caml_random_state =
      [246,
       function(_bk_){
        return caml_call1(Stdlib_Random[15][1], [0, 100, 200, 300]);
       }],
    saved_base_random_state =
      [246,
       function(_bj_){
        return caml_call1(Base_Random[19][2], [0, 111, 222, 333]);
       }];
   function string_of_module_descr(param){
    var t = current$0[1];
    function _bc_(m){return m[1];}
    var _bd_ = caml_call2(Stdlib_List[20], _bc_, t);
    function _be_(s){
     var
      _bg_ = caml_call1(Stdlib_String[29], s),
      _bh_ = caml_call2(Stdlib[28], _bg_, cst$3),
      _bi_ = caml_call2(Stdlib[28], cst_T_MODULE_at, _bh_);
     return caml_call2(Stdlib[28], cst_in_TES, _bi_);
    }
    var _bf_ = caml_call2(Stdlib_List[20], _be_, _bd_);
    return caml_call2(Stdlib_String[7], cst$4, _bf_);
   }
   function print_delayed_errors(param){
    var delayed_errors$0 = caml_call1(Stdlib_List[10], delayed_errors[1]);
    if(! delayed_errors$0) return;
    var _ba_ = caml_call2(Stdlib_String[1], 70, 61);
    caml_call2(Stdlib_Printf[3], _q_, _ba_);
    function _bb_(message){return caml_call2(Stdlib_Printf[3], _r_, message);}
    return caml_call2(Stdlib_List[18], _bb_, delayed_errors$0);
   }
   function eprintf_or_delay(fmt){
    function _a__(s){
     if(verbose[1])
      delayed_errors[1] = [0, s, delayed_errors[1]];
     else
      caml_call2(Stdlib_Printf[3], _s_, s);
     var _a$_ = stop_on_error[1];
     return _a$_ ? (print_delayed_errors(0), caml_call1(Stdlib[99], 2)) : _a$_;
    }
    return caml_call2(Stdlib_Printf[10], _a__, fmt);
   }
   function add_hooks(C, f, param){
    caml_call1(C[1], 0);
    return caml_call1(f, 0);
   }
   function hum_backtrace(backtrace){
    var
     _a2_ = caml_call1(Base_String[104], backtrace),
     _a3_ = Base_List[141],
     _a4_ =
       caml_call2
        (_a3_,
         _a2_,
         function(str){
          var _a8_ = caml_obj_tag(where_to_cut_backtrace);
          a:
          if(250 === _a8_)
           var _a9_ = where_to_cut_backtrace[1];
          else{
           if(246 !== _a8_ && 244 !== _a8_){
            var _a9_ = where_to_cut_backtrace;
            break a;
           }
           var _a9_ = caml_call1(CamlinternalLazy[2], where_to_cut_backtrace);
          }
          return 1 - caml_call2(Base_String[86][5], _a9_, str);
         }),
     _a5_ = Base_List[53],
     _a6_ =
       caml_call2
        (_a5_,
         _a4_,
         function(str){
          var _a7_ = caml_call2(Base[241], str, cst$5);
          return caml_call2(Base[241], cst$6, _a7_);
         });
    return caml_call2(Base_String[68], 0, _a6_);
   }
   function test_inner
   (config,
    descr,
    tags,
    def_filename,
    def_line_number,
    start_pos,
    end_pos,
    f,
    bool_of_f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _aI_ = match[2],
     what_to_do = _aI_[2],
     match$0 = _aI_[1],
     which_tags = match$0[4],
     name_filter = match$0[3],
     only_test_location = match$0[2],
     libname = match$0[1];
    function f$0(_a1_){return add_hooks(config, f, _a1_);}
    var
     descr$0 =
       [246,
        function(_a0_){
         return displayed_descr
                 (descr, def_filename, def_line_number, start_pos, end_pos);
        }],
     _aJ_ = current_tags(0),
     complete_tags = caml_call2(Stdlib[37], tags, _aJ_),
     _aK_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_aK_){
     if(only_test_location)
      var
       _aG_ =
         function(param){
          var
           used = param[3],
           line_number_opt = param[2],
           filename = param[1],
           position_start =
             caml_ml_string_length(def_filename)
             - caml_ml_string_length(filename)
             | 0,
           _aV_ = 0 <= position_start ? 1 : 0;
          if(_aV_){
           var
            end_of_def_filename =
              caml_call3
               (Stdlib_String[16],
                def_filename,
                position_start,
                caml_ml_string_length(filename)),
            _aW_ = caml_string_equal(end_of_def_filename, filename);
           if(_aW_){
            var
             _aX_ = 0 === position_start ? 1 : 0,
             _aY_ =
               _aX_
               ||
                (47
                  ===
                   runtime.caml_string_get
                    (def_filename, position_start - 1 | 0)
                  ? 1
                  : 0);
            if(_aY_)
             if(line_number_opt)
              var
               line_number = line_number_opt[1],
               _aZ_ = caml_equal(def_line_number, line_number);
             else
              var _aZ_ = 1;
            else
             var _aZ_ = _aY_;
           }
           else
            var _aZ_ = _aW_;
           var found = _aZ_;
          }
          else
           var found = _aV_;
          if(found) used[1] = 1;
          return found;
         },
       _aL_ = caml_call2(Stdlib_List[34], _aG_, only_test_location);
     else
      var _aL_ = 1;
     if(_aL_){
      var
       _ax_ = which_tags[1],
       _ay_ =
         function(req){
          return 1 - caml_call2(Stdlib_List[37], req, complete_tags);
         },
       _az_ = caml_call2(Stdlib_List[34], _ay_, _ax_);
      if(_az_)
       var _aM_ = _az_;
      else
       var
        _aA_ = which_tags[2],
        _aB_ =
          function(dropped){
           return caml_call2(Stdlib_List[37], dropped, complete_tags);
          },
        _aM_ = caml_call2(Stdlib_List[34], _aB_, _aA_);
      var _aN_ = 1 - _aM_;
      if(_aN_){
       var _aO_ = caml_obj_tag(descr$0);
       a:
       if(250 === _aO_)
        var descr$1 = descr$0[1];
       else{
        if(246 !== _aO_ && 244 !== _aO_){var descr$1 = descr$0; break a;}
        var descr$1 = caml_call1(CamlinternalLazy[2], descr$0);
       }
       if(name_filter)
        var
         _aH_ =
           function(substring){
            return caml_call2(Base_String[92], descr$1, substring);
           },
         _aP_ = caml_call2(Stdlib_List[34], _aH_, name_filter);
       else
        var _aP_ = 1;
       var should_run = _aP_;
      }
      else
       var should_run = _aN_;
     }
     else
      var should_run = _aL_;
    }
    else
     var should_run = _aK_;
    if(! should_run) return should_run;
    if(1025081494 > what_to_do[1]) return found_test(0);
    var partition = what_to_do[2], _aQ_ = is_current(partition);
    if(! _aQ_) return _aQ_;
    var _aR_ = caml_obj_tag(descr$0);
    a:
    if(250 === _aR_)
     var descr$2 = descr$0[1];
    else{
     if(246 !== _aR_ && 244 !== _aR_){var descr$2 = descr$0; break a;}
     var descr$2 = caml_call1(CamlinternalLazy[2], descr$0);
    }
    tests_ran[1]++;
    var match$1 = log[1];
    if(match$1){
     var ch = match$1[1], _aS_ = string_of_module_descr(0);
     caml_call4(Stdlib_Printf[1], ch, _t_, descr$2, _aS_);
    }
    if(verbose[1]) caml_call2(Stdlib_Printf[2], _u_, descr$2);
    if(list_test_names[1])
     var result$0 = _v_;
    else{
     var
      caml_random_state = caml_call1(Stdlib_Random[16], 0),
      base_random_state = caml_call1(Base_Random[19][4], Base_Random[19][1]),
      _aC_ = caml_obj_tag(saved_caml_random_state);
     a:
     if(250 === _aC_)
      var _aD_ = saved_caml_random_state[1];
     else{
      if(246 !== _aC_ && 244 !== _aC_){
       var _aD_ = saved_caml_random_state;
       break a;
      }
      var _aD_ = caml_call1(CamlinternalLazy[2], saved_caml_random_state);
     }
     caml_call1(Stdlib_Random[17], _aD_);
     var _aE_ = caml_obj_tag(saved_base_random_state);
     a:
     if(250 === _aE_)
      var _aF_ = saved_base_random_state[1];
     else{
      if(246 !== _aE_ && 244 !== _aE_){
       var _aF_ = saved_base_random_state;
       break a;
      }
      var _aF_ = caml_call1(CamlinternalLazy[2], saved_base_random_state);
     }
     caml_call1(Base_Random[20], _aF_);
     var result = time_without_resetting_random_(f$0);
     caml_call1(Stdlib_Random[17], caml_random_state);
     caml_call1(Base_Random[20], base_random_state);
     var result$0 = caml_call2(Stdlib_Result[8], bool_of_f, result);
    }
    if(verbose[1]) caml_call2(Stdlib_Printf[2], _w_, time_sec[1]);
    if(0 !== result$0[0]){
     var match$2 = result$0[1], backtrace = match$2[2], exn = match$2[1];
     tests_failed[1]++;
     var
      backtrace$0 = hum_backtrace(backtrace),
      exn_str = caml_call1(Sexplib0_Sexp_conv[70], exn),
      sep = caml_call2(Stdlib_String[15], exn_str, 10) ? cst$7 : cst$8,
      _aU_ = string_of_module_descr(0);
     return caml_call5
             (eprintf_or_delay(_y_), descr$2, sep, exn_str, backtrace$0, _aU_);
    }
    if(result$0[1]) return 0;
    tests_failed[1]++;
    var _aT_ = string_of_module_descr(0);
    return caml_call2(eprintf_or_delay(_x_), descr$2, _aT_);
   }
   function set_lib_and_partition(static_lib, partition){
    if(dynamic_lib[1]) return 0;
    dynamic_lib[1] = [0, static_lib];
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     match$0 = match[2],
     what_to_do = match$0[2],
     which_tests = match$0[1],
     _aw_ = caml_string_equal(which_tests[1], static_lib);
    if(! _aw_) return _aw_;
    a:
    {
     if(1025081494 <= what_to_do[1] && ! what_to_do[2]){var requires_partition = 0; break a;}
     var requires_partition = 1;
    }
    if(caml_string_equal(partition, cst$13) && requires_partition)
     return caml_call1(Stdlib[2], cst_ppx_inline_test_cannot_use);
    current[1] = partition;
    return 0;
   }
   function unset_lib(static_lib){
    var match = dynamic_lib[1];
    if(! match) return 0;
    var
     lib = match[1],
     _au_ = caml_string_equal(lib, static_lib),
     _av_ = _au_ ? (dynamic_lib[1] = 0, 0) : _au_;
    return _av_;
   }
   function test
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(b){return b;});
   }
   function test_unit
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(param){return 1;});
   }
   function test_module
   (config, descr, tags, def_filename, def_line_number, start_pos, end_pos, f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _an_ = match[2],
     what_to_do = _an_[2],
     match$0 = _an_[1],
     which_tags = match$0[4],
     libname = match$0[1];
    function f$0(_at_){return add_hooks(config, f, _at_);}
    var
     _ao_ = current_tags(0),
     partial_tags = caml_call2(Stdlib[37], tags, _ao_),
     _ap_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_ap_)
     var
      _al_ = which_tags[2],
      _am_ =
        function(dropped){
         return caml_call2(Stdlib_List[37], dropped, partial_tags);
        },
      should_run = 1 - caml_call2(Stdlib_List[34], _am_, _al_);
    else
     var should_run = _ap_;
    if(! should_run) return should_run;
    if(1025081494 > what_to_do[1]) return found_test(0);
    var partition = what_to_do[2], _aq_ = is_current(partition);
    if(! _aq_) return _aq_;
    test_modules_ran[1]++;
    var
     descr$0 =
       displayed_descr
        (descr, def_filename, def_line_number, start_pos, end_pos),
     prev = current$0[1];
    current$0[1] = [0, [0, descr$0, tags], prev];
    try{var x = time_without_resetting_random_(f$0); current$0[1] = prev;}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     current$0[1] = prev;
     throw caml_maybe_attach_backtrace(e, 0);
    }
    if(0 === x[0]) return 0;
    var match$1 = x[1], backtrace = match$1[2], exn = match$1[1];
    test_modules_failed[1]++;
    var
     backtrace$0 = hum_backtrace(backtrace),
     exn_str = caml_call1(Sexplib0_Sexp_conv[70], exn),
     sep = caml_call2(Stdlib_String[15], exn_str, 10) ? cst$9 : cst$10,
     _ar_ = string_of_module_descr(0),
     _as_ = caml_call1(Stdlib_String[29], descr$0);
    return caml_call5
            (eprintf_or_delay(caml_call2(Stdlib[98], _A_, _z_)),
             _as_,
             sep,
             exn_str,
             backtrace$0,
             _ar_);
   }
   function summarize(param){
    var match = get(0);
    if(typeof match !== "number"){
     var ___ = match[2], match$0 = ___[2], which_tests = ___[1];
     if(1025081494 > match$0[1]){
      var
       where_to_list = match$0[2],
       f =
         function(fout){
          var _ag_ = 0;
          function _ah_(k, param, acc){return [0, k, acc];}
          var
           _ai_ = caml_call3(Stdlib_Hashtbl[14], _ah_, _b_, _ag_),
           _aj_ = caml_call2(Stdlib_List[59], Stdlib_String[10], _ai_),
           _ak_ = caml_call2(Stdlib_Printf[1], fout, _N_);
          return caml_call2(Stdlib_List[18], _ak_, _aj_);
         };
      if(where_to_list){
       var
        file = where_to_list[1],
        _ae_ = caml_call3(Stdlib[62], _M_, 0, file),
        _af_ = caml_call1(Base_Exn[12], f);
       caml_call2(_af_, _ae_, Stdlib[76]);
      }
      else
       f(Stdlib[39]);
      return 0;
     }
     var match$1 = log[1];
     if(match$1){var ch = match$1[1]; caml_call1(Stdlib[76], ch);}
     print_delayed_errors(0);
     var count = tests_failed[1], count_test_modules = test_modules_failed[1];
     if(0 === count && 0 === count_test_modules){
      if(show_counts[1])
       caml_call3(Stdlib_Printf[3], _D_, tests_ran[1], test_modules_ran[1]);
      var
       _$_ = which_tests[2],
       _aa_ = function(param){var used = param[3]; return 1 - used[1];},
       unused_tests = caml_call2(Stdlib_List[44], _aa_, _$_),
       errors = unused_tests ? [0, unused_tests] : 0;
      if(errors){
       var tests = errors[1];
       caml_call1(Stdlib_Printf[3], _E_);
       var
        _ab_ =
          function(param){
           var line_number_opt = param[2], filename = param[1];
           if(! line_number_opt)
            return caml_call2(Stdlib_Printf[3], _G_, filename);
           var line_number = line_number_opt[1];
           return caml_call3(Stdlib_Printf[3], _F_, filename, line_number);
          };
       caml_call2(Stdlib_List[18], _ab_, tests);
       caml_call1(Stdlib_Printf[3], _H_);
       return 2;
      }
      if(0 === tests_ran[1] && strict[1]){
       caml_call1(Stdlib_Printf[3], _I_);
       return 2;
      }
      return 0;
     }
     if(0 === count_test_modules)
      var _ac_ = cst$11;
     else
      var
       _ad_ = caml_call2(Stdlib[98], _L_, _K_),
       _ac_ = caml_call2(Stdlib_Printf[4], _ad_, count_test_modules);
     caml_call4(Stdlib_Printf[3], _J_, count, tests_ran[1], _ac_);
     return 1;
    }
    a:
    {
     if(runtime.caml_notequal(caml_sys_argv(0), [0])){
      var _Z_ = runtime.caml_check_bound(caml_sys_argv(0), 0)[1];
      if
       (caml_string_equal
         (caml_call1(Stdlib_Filename[13], _Z_), "inline_tests_runner.exe")){caml_call1(Stdlib_Printf[3], _B_); break a;}
     }
     caml_call1(Stdlib_Printf[3], _C_);
    }
    return 2;
   }
   function assert_test_configs_initialize(config){
    var _X_ = 1 - already_initialized[1];
    if(! _X_) return _X_;
    var _Y_ = caml_call2(Stdlib_Printf[4], _O_, config);
    return caml_call1(Stdlib[2], _Y_);
   }
   function use_color$0(param){
    assert_test_configs_initialize(cst_use_color);
    return use_color[1];
   }
   function in_place$0(param){
    assert_test_configs_initialize(cst_in_place$0);
    return in_place[1];
   }
   function diff_command$0(param){
    assert_test_configs_initialize(cst_diff_command);
    return diff_command[1];
   }
   function diff_path_prefix$0(param){
    assert_test_configs_initialize(cst_diff_path_prefix$0);
    return diff_path_prefix[1];
   }
   function source_tree_root$0(param){
    assert_test_configs_initialize(cst_source_tree_root$0);
    return source_tree_root[1];
   }
   var evaluators = [0, [0, summarize, 0]];
   function add_evaluator(f){evaluators[1] = [0, f, evaluators[1]]; return 0;}
   function exit(param){
    var _U_ = caml_call1(Stdlib_List[10], evaluators[1]);
    function _V_(f){return caml_call1(f, 0);}
    switch(combine_all(caml_call2(Stdlib_List[20], _V_, _U_))){
      case 0:
       var _W_ = 0; break;
      case 1:
       var _W_ = 2; break;
      default: var _W_ = 1;
    }
    return caml_call1(Stdlib[99], _W_);
   }
   var
    Ppx_inline_test_lib =
      [0,
       am_running,
       am_running_env_var,
       testing,
       init,
       [0, combine, combine_all, to_string],
       set_lib_and_partition,
       unset_lib,
       test,
       test_unit,
       test_module,
       use_color$0,
       in_place$0,
       diff_command$0,
       diff_path_prefix$0,
       source_tree_root$0,
       add_evaluator,
       exit];
   runtime.caml_register_global
    (137, Ppx_inline_test_lib, cst_Ppx_inline_test_lib$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfaW5saW5lX3Rlc3RfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJpbml0aWFsIiwiYW1fcnVubmluZ19lbnZfdmFyIiwidG9fc3RyaW5nIiwiY29tYmluZSIsInQxIiwidDIiLCJjb21iaW5lX2FsbCIsInRzIiwiYWxyZWFkeV9pbml0aWFsaXplZCIsInRlc3RfbW9kdWxlc19yYW4iLCJ0ZXN0X21vZHVsZXNfZmFpbGVkIiwidGVzdHNfcmFuIiwidGVzdHNfZmFpbGVkIiwiZHluYW1pY19saWIiLCJhY3Rpb24iLCJmb3JjZV9kcm9wIiwiZ2V0IiwiY3VycmVudCIsImZvdW5kX3Rlc3QiLCJpc19jdXJyZW50IiwicCIsImN1cnJlbnQkMCIsImN1cnJlbnRfdGFncyIsInQiLCJtIiwidmVyYm9zZSIsInN0cmljdCIsInNob3dfY291bnRzIiwibGlzdF90ZXN0X25hbWVzIiwiZGVsYXllZF9lcnJvcnMiLCJzdG9wX29uX2Vycm9yIiwibG9nIiwidGltZV9zZWMiLCJ1c2VfY29sb3IiLCJpbl9wbGFjZSIsImRpZmZfY29tbWFuZCIsInNvdXJjZV90cmVlX3Jvb3QiLCJkaWZmX3BhdGhfcHJlZml4IiwiZGlzcGxheWVkX2Rlc2NyIiwiZGVzY3IiLCJmaWxlbmFtZSIsImxpbmUiLCJzdGFydF9wb3MiLCJlbmRfcG9zIiwiZGVzY3IkMCIsInBhcnNlX2FyZ3YiLCJhcmdzIiwibmFtZSIsInJlc3QiLCJsaWIiLCJ0ZXN0cyIsImxpc3RfcGFydGl0aW9ucyIsInBhcnRpdGlvbiIsInRhZ19wcmVkaWNhdGUiLCJuYW1lX2ZpbHRlciIsImFub24iLCJzIiwic3RyIiwiZmlsZSIsImluZGV4IiwiaW5kZXgkMCIsImkiLCJmaWxlbmFtZSQwIiwiaW5kZXhfc3RyaW5nIiwiaW5kZXgkMSIsInRhZyIsIndoZXJlX3RvX2xpc3QiLCJ2IiwibXNnIiwibXNnJDAiLCJpbml0IiwiYW1fdGVzdF9ydW5uZXIiLCJhbV9ydW5uaW5nIiwidGVzdGluZyIsInRpbWVzdGFtcF9ucyIsIndoZXJlX3RvX2N1dF9iYWNrdHJhY2UiLCJ0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV8iLCJmIiwiYmVmb3JlX25zIiwicmVzIiwiZXhuJDAiLCJleG4iLCJzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSIsInNhdmVkX2Jhc2VfcmFuZG9tX3N0YXRlIiwic3RyaW5nX29mX21vZHVsZV9kZXNjciIsInByaW50X2RlbGF5ZWRfZXJyb3JzIiwiZGVsYXllZF9lcnJvcnMkMCIsIm1lc3NhZ2UiLCJlcHJpbnRmX29yX2RlbGF5IiwiZm10IiwiYWRkX2hvb2tzIiwiQyIsImh1bV9iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJ0ZXN0X2lubmVyIiwiY29uZmlnIiwidGFncyIsImRlZl9maWxlbmFtZSIsImRlZl9saW5lX251bWJlciIsImJvb2xfb2ZfZiIsIndoYXRfdG9fZG8iLCJ3aGljaF90YWdzIiwib25seV90ZXN0X2xvY2F0aW9uIiwibGlibmFtZSIsImYkMCIsImNvbXBsZXRlX3RhZ3MiLCJ1c2VkIiwibGluZV9udW1iZXJfb3B0IiwicG9zaXRpb25fc3RhcnQiLCJlbmRfb2ZfZGVmX2ZpbGVuYW1lIiwibGluZV9udW1iZXIiLCJmb3VuZCIsInJlcSIsImRyb3BwZWQiLCJkZXNjciQxIiwic3Vic3RyaW5nIiwic2hvdWxkX3J1biIsImRlc2NyJDIiLCJjaCIsInJlc3VsdCQwIiwiY2FtbF9yYW5kb21fc3RhdGUiLCJiYXNlX3JhbmRvbV9zdGF0ZSIsInJlc3VsdCIsImJhY2t0cmFjZSQwIiwiZXhuX3N0ciIsInNlcCIsInNldF9saWJfYW5kX3BhcnRpdGlvbiIsInN0YXRpY19saWIiLCJ3aGljaF90ZXN0cyIsInJlcXVpcmVzX3BhcnRpdGlvbiIsInVuc2V0X2xpYiIsInRlc3QiLCJiIiwidGVzdF91bml0IiwidGVzdF9tb2R1bGUiLCJwYXJ0aWFsX3RhZ3MiLCJwcmV2IiwieCIsImUkMCIsImUiLCJzdW1tYXJpemUiLCJmb3V0IiwiayIsImFjYyIsImNvdW50IiwiY291bnRfdGVzdF9tb2R1bGVzIiwidW51c2VkX3Rlc3RzIiwiZXJyb3JzIiwiYXNzZXJ0X3Rlc3RfY29uZmlnc19pbml0aWFsaXplIiwidXNlX2NvbG9yJDAiLCJpbl9wbGFjZSQwIiwiZGlmZl9jb21tYW5kJDAiLCJkaWZmX3BhdGhfcHJlZml4JDAiLCJzb3VyY2VfdHJlZV9yb290JDAiLCJldmFsdWF0b3JzIiwiYWRkX2V2YWx1YXRvciIsImV4aXQiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9wcHhfaW5saW5lX3Rlc3QvcnVudGltZS1saWIvcHB4X2lubGluZV90ZXN0X2xpYi5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTJETUE7O0lBNFVGQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBM1hFQztJQUFZOztPQUNEOztPQUNBO2VBQ0Y7O0dBQU87WUFHaEJDLFFBQVFDLElBQUdDO0lBQ2I7O1lBRFVEOzthQUFHQyxJQUVTOzs7O2NBRlRBLElBSWdCOztJQURKO0dBQ1c7WUFHbENDLFlBQVlDO0lBQUssT0FBQSw0QkFQakJKLFlBT1lJO0dBQXNDO0dBSzlCO0lBQXRCQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQWdGRUM7O0lBSVE7SUFDUixJQUFBLFNBSEFDOzs7OztRQUFBQTs7WUFRQUMsV0FNRixPQWRFRCwwQkFGQUQsVUFnQnFDO0dBWS9CLElBQUEsTUFBQSxzQ0FDTkc7WUFHQUM7SUFDRjtLQUFHLE9BQUEscUJBSkREO0tBSUMsa0JBQXNCLG1DQUp2QkE7a0JBSXVELG1DQUp2REE7R0FJa0Y7WUFHbEZFO0lBQWEsWUFDTDtRQUNIQztJQUFLLE9BQUEsa0JBQUxBLEdBVExIO0dBU3NCO0dBbUJGLElBQXBCSTtZQWdCQUM7SUFBa0IsSUFuQlhDLElBR1BGO2tCQUhzQ0csR0FBSyxPQUFMQSxLQUFXO0lBQTFCLFdBQUEsa0NBQWhCRDtJQUFnQixPQUFBO0dBbUJVO0dBR3pCO0lBQVZFO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBRUFDLGdCQUFnQkMsT0FBTUMsVUFBU0MsTUFBS0MsV0FBVUM7SUFDaEQsd0JBRGtCSjs7O1NBQ1JLLFVBRFFMOzswQ0FDUkssVUFEUUw7U0FDUkssMENBRFFMOztJQVFaOztPQUFBLGtCQVBJSzs7VUFPb0IsOEJBUHBCQTtJQU9vQixPQUFBO29DQVJOSixVQUFTQyxNQUFLQyxXQUFVQztHQVFMO1lBb0J6Q0UsV0FBWTVCLFNBQVE2QjtJQUN0QixHQURzQkE7Z0JBQUFBOztVQUVwQkMsT0FGb0JEOzs7O1lBS2pCRSxpQkFEQUM7V0EvTUh6QztTQW9ORSxNQUFBOztRQXBORkE7UUF5Tlk7U0FBUjBDO1NBQ0FDO1NBQ0FDO1NBQ0FDLG9CQS9MRnJEO1NBZ01Fc0Q7U0ErRkY7V0FBQTtvQ0EvR0ZQLDhCQUVHRTs7b0JBMEdJTTtZQUVRLFdBQUEsa0NBOUdmUixNQTRHT1E7WUFDSCxNQUFBO1dBQ2lGO1NBRm5GOzs7OzswQkFIdUJDLEdBekl6Qm5CLDBCQXlJeUJtQixhQUErQjs7Ozs7OzswQkFIL0JBLEdBdkl6QnBCLDBCQXVJeUJvQixhQUErQjs7Ozs7a0NBMUl4RHZCOzttQ0FDQUM7Ozs7NEJBc0l5QnNCLEdBckl6QnJCLHNCQXFJeUJxQixhQUEyQjs7Ozs7Ozs7dUJBckNwQ0M7ZUFDSDtnQkFoRmI7OzRCQUlVQyxNQUFLakIsTUFBS0MsV0FBV0MsU0FBWSxXQUFqQ2UsVUFBS2pCO21CQUEyQztpQkFKMUQsV0FDRSw0QkE4RWNnQjs7OztnQkF4RWhCO2lCQUNHO2tDQUFvREMsTUFBS2pCLE1BQVEsV0FBYmlCLFVBQUtqQixPQUF1QjtrQkFBaEYsV0FBSyw0QkF1RVFnQjs7OztpQkFwRWI7a0JBQUs7bUNBQTBDQyxNQUFRLFdBQVJBLFNBQWtCO21CQUE1RCxXQUFLLDRCQW9FR0Q7Ozs7Ozs7OztpQkFHYUU7aUJBQU5EO2lCQUZJRSxVQUVFRDtpQkFGWm5CLFdBRU1rQjt1QkFFSCw4QkFMSkQ7Z0JBT1c7aUJBQUpJLElBQUksOEJBUFhKO2lCQVFPSyxhQUFXLDhCQVJsQkwsUUFPT0k7aUJBRUFFO21CQUNGOztxQkFWTE47cUJBT09JOzRDQVBQSixPQU9PSTtnQkFLSixJQUNNLElBREZHLFVBQ0UsMkJBSkZEOzs7OztpQkFRSyxXQUFBLGtDQWpCWk47aUJBZU8sTUFBQTs7O29CQWRJRyxjQVdKSSxVQVhOeEIsV0FPTXNCOzs7b0JBUElGLGFBQVZwQixXQUREaUI7ZUFsRFpQLG1CQW1EYVYsVUFBVW9CLGtCQW5EdkJWOztjQTRFd0Q7Ozs7Ozs7O3VCQTlCbkNNLEdBMUNyQkYscUJBMENxQkUsR0ExQ3JCRiwwQkEwQzBEOzs7Ozs7Ozt1QkFIckNXO2VBQUssSUEvTnBCMUMsSUF1TE44Qix5QkF2TE05QjtlQUNtQixvQiw0QkE4TkowQztlQTlOUixXQUFBO2VBc0xiWiwyQkF3Q3FCWSxLQS9OZjFDOztjQStOMkU7Ozs7Ozs7O3VCQUo1RDBDO2VBQUssSUFqT3ZCMUMsSUE2TEg4QixrQkE1TGEsV0FnT1FZLEtBak9sQjFDLGNBQUFBO2VBRXVCLG9CLDRCQStOTDBDO2VBcENyQlo7b0JBM0xjOztjQStOZ0U7Ozs7O2lDQS9GbEY1Qjs7OztrQkFLQUs7OztrQ0FKQUo7Ozs7b0JBQ0FDOzs7Ozs7O21CQXdGYSxJQUFLOzttQkFwRmxCSSxhQXNGeUI7O2tCQUE2Qjs7Ozs7OzswQkFiN0I4QixHQXJCckJULG1CQXFCcUJTLGFBQXdCOzs7Ozs7Ozt1QkFKeEJILE1BbEJyQlAsNkJBa0JxQk8saUJBQTJDOzs7Ozs7O2lDQWxCaEVQLG1DQWV1RDs7O1NBUHREOzs7Ozs7ZUE5REx2QjtlQUhBSDs7Y0FxRTRCOzs7U0FMMUIsT0FBQTtTQURBLE9BQUEsaUNBbkJGc0IsTUFHR0M7UUFjSCwwQkFuQlkvQjtzQkFlUmtDOzs7VUE2R1llO2lDQUFBQTs7b0NBNUdaZDtRQW1HRjtTQXROSWU7OztvQkF1R0hsQixLQVVDQyxVQUlBSSxnQkFEQUQ7UUF2SUZ2QyxZQW1CSXFEOzs7Ozs7SUFrT0Q7R0FBRTs7SUFLSjs7S0FwSUh0QixjQXFJZTs7Ozs7VUFDTHVCO01BQ1Isa0NBRFFBO01BRVI7Ozs7VUFDU0M7TUFDVCxrQ0FEU0E7TUFFVDs7O1lBR0ZDLEtBQUt4QjtJQUNPLElBQVY3QjtJQUNKLElBaEpFNEIsZUErSUU1QixVQURHNkIsT0FHTDs7O3NDQUdRc0IsY0FBTyxXQUFQQTs7U0FDQ0M7S0FBTyxlQUFQQTs7R0FBb0I7T0FHN0JFLHdCQXBRRXZEOzs7UUFtUkU7Ozs7OztNQUlKLElBQU8sVUFBQTs7Ozs7Ozs7O1NBTFB3RDs7O1FBQUFBOztPQVdBQyxVQXpCQUYsdUJBY0FDO1lBd0JBRSxvQkFBa0IsT0FBQSwyQkFBeUM7R0FJM0Q7SUFGQUM7OztRQUdpQjtTQUFBLE9BQUE7U0FBZCxPQUFBO1FBQUEsT0FBQTs7WUFHSEMsK0JBQW9DQztJQUN0QixJQUFaQyxZQVRGSjtJQVVGLElBV00sSUFBQSxXQUFHLFdBYjZCRyxRQUVsQ0U7VUFZQUM7O01BQUFDLDBCQUFBRDtNQVpBRCxjQVlBRSxLQUFtQjs7SUFFQztLQUFBLE9BeEJ0QlA7S0F3QnNCLE9BQUEsaUNBZnBCSTtJQTFPRjlDLGNBeVBzQjtJQUN4QixPQWZJK0M7R0FlRDtHQUc4QjtJQUEvQkc7OztRQUF5RCxPQUFBOztJQUN6REM7OztRQUF1RCxPQUFBOztZQWF2REM7SUFDRixJQTFTWTdELElBSVJGO2tCQUowQkcsR0FBSyxPQUFMQSxLQUFZO0lBQTFCLFdBQUEsa0NBQUpEO2tCQTZTRmlDO0tBQUs7TUFBOEIsT0FBQSw4QkFBbkNBO01BQW1DLE9BQUE7TUFBakIsT0FBQTtLQUFBLE9BQUE7SUFBbUQ7SUFEN0UsV0FBQTtJQUFBLE9BQUE7R0FFcUM7WUFnQ3JDNkI7SUFDSSxJQUVKQyxtQkFGSSw0QkFwVEp6RDtTQXNUQXlELGtCQURNO0lBRW9CLFdBQUE7SUFBMUI7a0JBQ2VDLFNBQVcsT0FBQSxrQ0FBWEEsU0FBd0M7SUFEdkQsT0FBQSxrQ0FEQUQ7R0FFdUU7WUFHdkVFLGlCQUFpQkM7a0JBRVpqQztLQUNILEdBbFVGL0I7TUFJQUksd0JBNlRLMkIsR0E3VEwzQjs7TUE4VCtELGtDQUQxRDJCO2dCQTVUTDFCO29CQWtUQXVELHlCQWNJO0lBQ087SUFOYixPQUFBLG9DQURtQkk7R0FRZDtZQUdIQyxVQUFXQyxHQUFxQmQ7SUFDbEMsV0FEYWM7SUFDYixPQUFBLFdBRGtDZDtHQUU5QjtZQUdGZSxjQUFjQztJQUNoQjtLQUNBLE9BQUEsNkJBRmdCQTtLQUVoQjtLQUVzQjtPQUFBOzs7a0JBQUtwQztVQUN0Qix3QkExR0hrQjs7O3NCQUFBQTs7O3VCQUFBQTs7O3NEQUFBQTs7VUEwR08sV0FBQSxxQ0FEa0JsQjtTQUNnRDtLQUgzRTtLQUllO09BQUE7OztrQkFBS0E7VUFBYyxXQUFBLHNCQUFkQTtVQUFjLE9BQUE7U0FBVTtJQUo1QyxPQUFBO0dBS2dCO1lBR0NxQztJQUNoQkM7SUFDQXhEO0lBQ0F5RDtJQUNTQztJQUNHQztJQUNaeEQ7SUFDQUM7SUFDRGtDO0lBQ0FzQjtJQUVNLFlBdGFGbkY7a0NBdWFTOzs7S0FHUG9GOztLQUQ2Q0M7S0FBWS9DO0tBQWhDZ0Q7S0FBVEM7SUFHWixTQW5Hb0JDLFUsT0FtRTVCZCxVQWdCREssUUFPRGxCO0lBV1M7S0FESGpDOzs7U0FBSixPQTdWQU47a0JBNlVEQyxPQUVTMEQsY0FDR0MsaUJBQ1p4RCxXQUNBQzs7S0FjNEIsT0FqWHpCckI7S0EvRzBCbUYsZ0JBZ2VSLHVCQWxCckJUO0tBb0JHLE9BQUEsZUFUa0JPLFVBbmdCcEIxRjtJQTRnQkU7UUFUMkJ5Rjs7OztVQTNFN0I7V0FBaUNJO1dBQWpCQztXQUFWbkU7V0FDQW9FO21DQWdFRVg7ZUFoRU4sc0JBREl6RDs7dUJBQ0FvRTs7V0FLQTtZQURFQztjQUNGOztnQkEyREVaO2dCQWhFRlc7c0NBREFwRTtZQVFGLE9BQUEsa0JBSElxRSxxQkFMRnJFO1dBUUY7OzBCQVBFb0U7Ozs7OzttQkFRd0I7cUJBd0R0QlgsY0FoRUZXOzs7O2dCQURVRDs7ZUFhTEcsY0FiS0g7c0JBYVUsV0FxRGZULGlCQXJEQVk7Ozs7Ozs7O2VBWExDOzs7ZUFBQUE7VUFhSixHQWJJQSxPQUYyQkw7VUFnQi9CLE9BZElLO1NBY0U7Y0FqQlYsa0NBNEUrQlQ7Ozs7TUF4ZDdCO2NBd2RpREQ7O2tCQXhkaENXO1VBQU8sV0FBSSw0QkFBWEEsS0FEV1A7U0FDbUI7T0FBL0MsT0FBQTtNQUFBOzs7O2VBd2RpREo7O21CQXZkN0JZO1dBQVcsbUNBQVhBLFNBRlFSO1VBRXdCO2VBQXJDO01Bb2VMOzsrQkFUTjdEOzs7WUEzRDJCc0UsVUEyRDNCdEU7OzZDQTNEMkJzRSxVQTJEM0J0RTtZQTNEMkJzRSwwQ0EyRDNCdEU7O1VBSnlEVTs7O29CQW5ENUM2RDtZQUFhLE9BQUEsNEJBSkNELFNBSWRDO1dBQXNEO2dCQUF2RSxrQ0FtRDZEN0Q7OztXQVF6RDhEOzs7V0FBQUE7OztVQUFBQTs7O1NBQUFBO0lBUUosS0FSSUEsWUFNQyxPQU5EQTtvQkFQQWhCLGVBa0JzQixPQXRheEJsRjtJQXdhSyxJQURZa0MsWUFuQmZnRCxlQW9CRyxPQXBhTGpGLFdBbWFpQmlDO0lBQ1osV0FBQTs0QkFqQkhSOzs7U0FtQk15RSxVQW5CTnpFOzswQ0FtQk15RSxVQW5CTnpFO1NBbUJNeUUsMENBbkJOekU7O0lBemdCSmpDO2tCQW9LQW9COztLQTRYcUQsSUFBdkN1RixpQkFBdUMsT0FoSHJEbEM7S0FnSG9CLDZCQUFOa0MsU0FKSkQ7O09BOVhWNUYsWUFtWXVCLGtDQUxiNEY7T0EzWFZ6RjtTQWlZVTJGOztLQTVIWTtNQUFwQkMsb0JBQW9CO01BQ3BCQyxvQkFBb0I7MEJBTHRCdkM7OztpQkFBQUE7OztrQkFBQUE7OztpREFBQUE7O0tBTUY7NkJBTEVDOzs7aUJBQUFBOzs7a0JBQUFBOzs7aURBQUFBOztLQU1GO0tBQ2EsSUFBVHVDLFNBNUJGOUMsK0JBdUI0QjRCO0tBTTlCLDhCQUxJZ0I7S0FNSiw0QkFMSUM7U0EySFFGLFdBTUEsNkJBeENacEIsV0F0Rkl1Qjs7T0E1UUZqRyxZQTZZdUIsa0NBdFl2Qk87YUE2WFV1RjttQkFBQUEsYUFlVTFCLHdCQUFMWjtLQWhqQmZyRTtLQWtqQndCO01BQVorRyxjQXRFWi9CLGNBb0VvQkM7TUFHUitCLFVBQVUsbUNBSFAzQztNQUlINEMsTUFBUyw4QkFEVEQ7TUFRRixPQTVJVnhDO0tBNElVLE9BQUE7Y0EvRlZJLHVCQStEVTZCLFNBeUJFUSxLQURBRCxTQURBRDs7T0FqQkZKLGFBV1M7SUE1aUJuQjNHO0lBK2lCc0QsV0FoSXREd0U7SUFnSXNELE9BQUEsV0FuRnRESSx1QkErRFU2Qjs7WUFtQ1ZTLHNCQUFzQkMsWUFBVzNFO0lBQ25DLEdBOWpCRXZDLGdCQWtrQkE7SUFsa0JBQSxxQkE2akJzQmtIO0lBUWYsWUEzZUwvRztrQ0E0ZVk7SUFFUjs7S0FEdUJvRjtLQUFiNEI7S0FDVixPQUFBLGtCQURVQSxnQkFWTUQ7SUFXaEIsV0FBQTs7O3NCQUR1QjNCLG1CQUFBQSxtQkFHcEI2QjtTQUFBQTs7T0FLRCxrQkFsQnlCN0Usc0JBYXhCNkU7S0FPRixPQUFBO0lBcGVMaEgsYUFnZCtCbUM7O0dBdUJVO1lBRzNDOEUsVUFBVUg7SUFDWixZQXhsQkVsSDtnQkE2bEJBO0lBQ2U7S0FBVm9DO0tBQVUsT0FBQSxrQkFBVkEsS0FQSzhFO0tBT0ssZUE5bEJmbEg7O0dBOGxCd0Q7WUFHeERzSDtJQUFNcEMsUUFBUXhELE9BQU95RCxNQUFNeEQsVUFBVXNFLGFBQWFwRSxXQUFXQyxTQUFRa0M7SUFDdkUsT0E3R2lCaUI7YUE0R1RDO2FBQVF4RDthQUFPeUQ7YUFBTXhEO2FBQVVzRTthQUFhcEU7YUFBV0M7YUFBUWtDO3NCQUNXdUQsR0FDaEYsT0FEZ0ZBLEVBQy9FO0dBQUM7WUFHRkM7SUFBV3RDLFFBQVF4RCxPQUFPeUQsTUFBTXhELFVBQVVzRSxhQUFhcEUsV0FBV0MsU0FBUWtDO0lBQzVFLE9BbEhpQmlCO2FBaUhKQzthQUFReEQ7YUFBT3lEO2FBQU14RDthQUFVc0U7YUFBYXBFO2FBQVdDO2FBQVFrQzs2QkFFMUUsU0FBSTtHQUFDO1lBR1V5RDtJQUNoQnZDLFFBQ0F4RCxPQUNBeUQsTUFDU0MsY0FDR0MsaUJBQ1p4RCxXQUNBQyxTQUNEa0M7SUFFTSxZQTNoQkY3RDtrQ0E0aEJTOzs7S0FHUG9GOztLQURrRUM7S0FBbERFO0lBR1osU0FBSkMsVSxPQXJKSmQsVUFzSURLLFFBT0RsQjtJQVU0QjtLQUFBLE9BcGV4QnZEO0tBbkh1Q2lILGVBdWxCdEIsdUJBZnBCdkM7S0FpQkcsT0FBQSxlQVBrQk8sVUF4bkJwQjFGO0lBK25CRTs7YUFQb0V3Rjs7aUJBamxCckRZO1NBQVcsbUNBQVhBLFNBRHdCc0I7UUFDUTtNQXVsQjdDbkIsaUJBdmxCUTs7U0F1bEJSQTtJQVlKLEtBWklBLFlBVUssT0FWTEE7b0JBTEFoQixlQW9Cc0IsT0E3aEJ4QmxGO0lBK2hCSyxJQURZa0MsWUFyQmZnRCxlQXNCRyxPQTNoQkxqRixXQTBoQmlCaUM7SUFDWixXQUFBO0lBbnBCUDNDO0lBZ29CQTtLQXNCVW1DO09BeGVWTjtTQW1jREMsT0FFUzBELGNBQ0dDLGlCQUNaeEQsV0FDQUM7S0F0ZUs2RixPQUhGbkg7SUFBQUEsdUJBeWdCUXVCLFNBcENYb0QsT0FsZUt3QztJQUVKLElBcWdCTSxJQXBnQkFDLElBNlBON0QsK0JBK09JNEIsTUFsZkZuRixlQUdFbUg7VUFPRkU7U0FBQUMsd0JBQUFEO0tBVkFySCxlQUdFbUg7S0FTRixNQUFBLDRCQUZBRzs7YUFKSUYsTUFraEJXO2tCQWxoQlhBLE1BbWhCYzVDLHdCQUFMWjtJQXJxQmZ2RTtJQXVxQndCO0tBQVppSCxjQXpMWi9CLGNBdUxvQkM7S0FHUitCLFVBQVUsbUNBSFAzQztLQUlINEMsTUFBUyw4QkFEVEQ7S0FRRixPQS9QVnhDO0tBMlBVLE9BQUEsOEJBdkJBeEM7SUEyQkEsT0FBQTthQWxOVjRDLGlCQTZNVTs7YUFGRXFDO2FBREFEO2FBREFEOzs7WUFZWmlCO0lBQ0ksWUF2bEJGNUg7OzJDQWtuQjBDZ0g7O01BSDVDO09BVDREOUQ7T0FDdkNXO2tCQVFDZ0U7VUFobEJYO3dCQUE0Q0MsVUFBS0MsS0FBTyxXQUFaRCxHQUFLQyxLQUFlO1VBQXZDO1dBQUEsT0FBQTtXQUFBLE9BQUE7V0FpbEJ4QixPQUFBLDZCQURVRjtVQUNtQixPQUFBO1NBQWtCO1NBVkMzRTtPQU14RDtRQUZLUixPQUptRFE7UUFNeEQsT0FBQSwrQkFGS1I7d0NBSFltQjs7OztPQUFBQTtNQVFyQjs7bUJBdmlCQTlDO3FCQTZpQlF1RixpQkFBTSx1QkFBTkE7S0E1UFJqQztTQWdTRzJELFFBcHZCSHBJLGlCQW92QlVxSSxxQkF0dkJWdkk7Y0FzdkJHc0ksZUFBT0M7U0FybEJWdEg7T0F1akJLLGtDQXZ0QkxoQixjQUZBRjtNQSt0Qk87YUFmcUN1SDs4QkFlekIsSUFBWXRCLDRCQUFBQSxRQUFtQjtPQUR6Q3dDLGVBQ0Y7T0FGQUMsU0FDRUQsbUJBQUFBO01BT04sR0FSSUM7V0FTSWpHLFFBVEppRztPQVVEOzs7O1dBR0UsSUFBZ0J4Qyw0QkFBVm5FO1dBQ0osS0FEY21FO1lBRUosT0FBQSxrQ0FGTm5FO2VBR0dzRSxjQUhPSDtXQUdRLE9BQUEsa0NBSGxCbkUsVUFHR3NFO1VBQTREO09BSnZFLGtDQUhLNUQ7T0FTTDtPQUFBOztlQTd1Qk52QyxnQkErSkFlO09BbWxCUTtPQUFBOztNQUVHOztjQUNEdUg7OztNQU9nQjtPQUFBLE9BQUE7Y0FBZixtQ0FQREE7S0FDUCxrQ0FEQUQsT0FydkJIckk7S0FzdkJHOzs7O0tBakVBLEdBQUE7TUFBc0M7TUFBbEI7UUFBQTtVQUFBLGtFQUVyQjs7S0FLQTs7SUFBQTtHQWlFcUI7WUFHdkJ5SSwrQkFBZ0NyRDtJQUNsQyxjQXB3QkV2Rjs7SUFzd0JBLFVBQUEsa0NBSGdDdUY7SUFHaEMsT0FBQTtHQUlXO1lBR1hzRDtJQVZBRDtXQTFsQkFuSDtHQXNtQlE7WUFHUnFIO0lBZkFGO1dBemxCQWxIO0dBMG1CTztZQUdQcUg7SUFwQkFIO1dBeGxCQWpIO0dBOG1CVztZQUdYcUg7SUF6QkFKO1dBdGxCQS9HO0dBaW5CZTtZQUdmb0g7SUE5QkFMO1dBdmxCQWhIO0dBdW5CZTtHQUdGLElBQWJzSCxxQkFqSEFkO1lBa0hBZSxjQUFlOUUsR0FEZjZFLG9CQUNlN0UsR0FEZjZFLHlCQUNpRDtZQUVqREU7SUFDdUIsVUFBQSw0QkFKdkJGO2lCQUlZN0UsR0FBSyxPQUFBLFdBQUxBLE1BQVM7V0EveUJuQnZFLFlBK3lCSjs7Ozs7OztJQUFBLE9BQUE7R0FHTzs7OztPQTViTGtFO09BUkF2RTtPQW1CQXdFO09BbkNBSDtXQXJXRW5FLFNBT0FHLGFBYkFKO09Bb2xCRjRIO09BMEJBSTtPQVVBQztPQUtBRTtPQUtlQztPQTZKZmU7T0FLQUM7T0FLQUM7T0FLQUM7T0FLQUM7T0FNQUU7T0FFQUM7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBUZXN0X3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgU3VjY2Vzc1xuICAgIHwgRmFpbHVyZVxuICAgIHwgRXJyb3JcblxuICBsZXQgdG9fZXhpdF9jb2RlID0gZnVuY3Rpb25cbiAgICB8IFN1Y2Nlc3MgLT4gMFxuICAgIHwgRmFpbHVyZSAtPiAyXG4gICAgfCBFcnJvciAtPiAxXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBTdWNjZXNzIC0+IFwic3VjY2Vzc1wiXG4gICAgfCBGYWlsdXJlIC0+IFwiZmFpbHVyZVwiXG4gICAgfCBFcnJvciAtPiBcImVycm9yXCJcbiAgOztcblxuICBsZXQgY29tYmluZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IFN1Y2Nlc3MsIFN1Y2Nlc3MgLT4gU3VjY2Vzc1xuICAgIHwgRXJyb3IsIF8gfCBfLCBFcnJvciAtPiBFcnJvclxuICAgIHwgRmFpbHVyZSwgXyB8IF8sIEZhaWx1cmUgLT4gRmFpbHVyZVxuICA7O1xuXG4gIGxldCBjb21iaW5lX2FsbCB0cyA9IExpc3QuZm9sZF9sZWZ0IGNvbWJpbmUgU3VjY2VzcyB0c1xuZW5kXG5cbnR5cGUgZGVzY3IgPSBzdHJpbmdcblxubGV0IGFscmVhZHlfaW5pdGlhbGl6ZWQgPSByZWYgZmFsc2VcbmxldCB0ZXN0X21vZHVsZXNfcmFuID0gcmVmIDBcbmxldCB0ZXN0X21vZHVsZXNfZmFpbGVkID0gcmVmIDBcbmxldCB0ZXN0c19yYW4gPSByZWYgMFxubGV0IHRlc3RzX2ZhaWxlZCA9IHJlZiAwXG5sZXQgZHluYW1pY19saWIgOiBzdHJpbmcgb3B0aW9uIHJlZiA9IHJlZiBOb25lXG5cbnR5cGUgZmlsZW5hbWUgPSBzdHJpbmdcbnR5cGUgbGluZV9udW1iZXIgPSBpbnRcbnR5cGUgc3RhcnRfcG9zID0gaW50XG50eXBlIGVuZF9wb3MgPSBpbnRcbnR5cGUgY29uZmlnID0gKG1vZHVsZSBJbmxpbmVfdGVzdF9jb25maWcuUylcblxudHlwZSAnYSB0ZXN0X2Z1bmN0aW9uX2FyZ3MgPVxuICBjb25maWc6Y29uZmlnXG4gIC0+IGRlc2NyOmRlc2NyIExhenkudFxuICAtPiB0YWdzOnN0cmluZyBsaXN0XG4gIC0+IGZpbGVuYW1lOmZpbGVuYW1lXG4gIC0+IGxpbmVfbnVtYmVyOmxpbmVfbnVtYmVyXG4gIC0+IHN0YXJ0X3BvczpzdGFydF9wb3NcbiAgLT4gZW5kX3BvczplbmRfcG9zXG4gIC0+ICdhXG5cbm1vZHVsZSBUYWdfcHJlZGljYXRlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyByZXF1aXJlZF90YWdzIDogc3RyaW5nIGxpc3RcbiAgICA7IGRyb3BwZWRfdGFncyA6IHN0cmluZyBsaXN0XG4gICAgfVxuXG4gIGxldCBpbml0aWFsID0geyByZXF1aXJlZF90YWdzID0gW107IGRyb3BwZWRfdGFncyA9IFsgXCJkaXNhYmxlZFwiIF0gfVxuXG4gIGxldCBkcm9wIHQgdGFnID1cbiAgICB7IGRyb3BwZWRfdGFncyA9IHRhZyA6OiB0LmRyb3BwZWRfdGFnc1xuICAgIDsgcmVxdWlyZWRfdGFncyA9IExpc3QuZmlsdGVyICgoIDw+ICkgdGFnKSB0LnJlcXVpcmVkX3RhZ3NcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHJlcXVpcmUgdCB0YWcgPVxuICAgIHsgZHJvcHBlZF90YWdzID0gTGlzdC5maWx0ZXIgKCggPD4gKSB0YWcpIHQuZHJvcHBlZF90YWdzXG4gICAgOyByZXF1aXJlZF90YWdzID0gdGFnIDo6IHQucmVxdWlyZWRfdGFnc1xuICAgIH1cbiAgOztcblxuICBsZXQgZW50aXJlX21vZHVsZV9kaXNhYmxlZCB0IH5wYXJ0aWFsX3RhZ3M6dGFncyA9XG4gICAgTGlzdC5leGlzdHMgKGZ1biBkcm9wcGVkIC0+IExpc3QubWVtIGRyb3BwZWQgdGFncykgdC5kcm9wcGVkX3RhZ3NcbiAgOztcblxuICBsZXQgZGlzYWJsZWQgdCB+Y29tcGxldGVfdGFnczp0YWdzID1cbiAgICBMaXN0LmV4aXN0cyAoZnVuIHJlcSAtPiBub3QgKExpc3QubWVtIHJlcSB0YWdzKSkgdC5yZXF1aXJlZF90YWdzXG4gICAgfHwgTGlzdC5leGlzdHMgKGZ1biBkcm9wcGVkIC0+IExpc3QubWVtIGRyb3BwZWQgdGFncykgdC5kcm9wcGVkX3RhZ3NcbiAgOztcbmVuZFxuXG5tb2R1bGUgV2hlcmVfdG9fbGlzdCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgU3Rkb3V0XG4gICAgfCBGaWxlIG9mIHN0cmluZ1xuZW5kXG5cbnR5cGUgd2hpY2hfdGVzdHMgPVxuICB7IGxpYm5hbWUgOiBzdHJpbmdcbiAgOyBvbmx5X3Rlc3RfbG9jYXRpb24gOiAoZmlsZW5hbWUgKiBsaW5lX251bWJlciBvcHRpb24gKiBib29sIHJlZikgbGlzdFxuICA7IG5hbWVfZmlsdGVyIDogc3RyaW5nIGxpc3RcbiAgOyB3aGljaF90YWdzIDogVGFnX3ByZWRpY2F0ZS50XG4gIH1cblxudHlwZSB0ZXN0X21vZGUgPVxuICB7IHdoaWNoX3Rlc3RzIDogd2hpY2hfdGVzdHNcbiAgOyB3aGF0X3RvX2RvIDogWyBgUnVuX3BhcnRpdGlvbiBvZiBzdHJpbmcgb3B0aW9uIHwgYExpc3RfcGFydGl0aW9ucyBvZiBXaGVyZV90b19saXN0LnQgXVxuICB9XG5cbm1vZHVsZSBBY3Rpb24gOiBzaWdcbiAgdHlwZSB0ID1cbiAgICBbIGBJZ25vcmVcbiAgICB8IGBUZXN0X21vZGUgb2YgdGVzdF9tb2RlXG4gICAgXVxuXG4gIHZhbCBnZXQgOiB1bml0IC0+IHRcbiAgdmFsIHNldCA6IHQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgSWdub3JlXG4gICAgfCBgVGVzdF9tb2RlIG9mIHRlc3RfbW9kZVxuICAgIF1cblxuICBsZXQgYWN0aW9uIDogdCByZWYgPSByZWYgYElnbm9yZVxuXG4gIGxldCBmb3JjZV9kcm9wID1cbiAgICB0cnlcbiAgICAgIGlnbm9yZSAoU3lzLmdldGVudiBcIkZPUkNFX0RST1BfSU5MSU5FX1RFU1RcIiA6IHN0cmluZyk7XG4gICAgICB0cnVlXG4gICAgd2l0aFxuICAgIHwgTm90X2ZvdW5kIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGdldCAoKSA9XG4gICAgKCogVGhpcyBpcyB1c2VmdWwgd2hlbiBjb21waWxpbmcgdG8gamF2YXNjcmlwdC5cbiAgICAgICBKc19vZl9vY2FtbCBjYW4gc3RhdGljYWxseSBldmFsdWF0ZSBbU3lzLmdldGVudiBcIkZPUkNFX0RST1BfSU5MSU5FX1RFU1RcIl1cbiAgICAgICBhbmQgaW5saW5lIHRoZSByZXN1bHQgKFtgSWdub3JlXSkgd2hlbmV2ZXIgW2dldCAoKV0gaXMgY2FsbGVkLlxuICAgICAgIFVuaXQgdGVzdHMgY2FuIHRoZW4gYmUgdHJlYXRlZCBhcyBkZWFkY29kZSBzaW5jZSB0aGUgYXJndW1lbnQgW2ZdIG9mIHRoZSBbdGVzdF1cbiAgICAgICBmdW5jdGlvbiBiZWxvdyBpcyBuZXZlciB1c2VkLiAqKVxuICAgIGlmIGZvcmNlX2Ryb3AgdGhlbiBgSWdub3JlIGVsc2UgIWFjdGlvblxuICA7O1xuXG4gIGxldCBzZXQgdiA9IGFjdGlvbiA6PSB2XG5lbmRcblxubW9kdWxlIFBhcnRpdGlvbiA6IHNpZ1xuICB2YWwgZm91bmRfdGVzdCA6IHVuaXQgLT4gdW5pdFxuICB2YWwgc2V0X2N1cnJlbnQgOiBzdHJpbmcgLT4gdW5pdFxuICB2YWwgaXNfY3VycmVudCA6IHN0cmluZyBvcHRpb24gLT4gYm9vbFxuICB2YWwgYWxsIDogdW5pdCAtPiBzdHJpbmcgbGlzdFxuZW5kID0gc3RydWN0XG4gIGxldCBhbGwgPSBIYXNodGJsLmNyZWF0ZSAyM1xuICBsZXQgY3VycmVudCA9IHJlZiBcIlwiXG4gIGxldCBzZXRfY3VycmVudCB4ID0gY3VycmVudCA6PSB4XG5cbiAgbGV0IGZvdW5kX3Rlc3QgKCkgPVxuICAgIGlmICFjdXJyZW50IDw+IFwiXCIgJiYgbm90IChIYXNodGJsLm1lbSBhbGwgIWN1cnJlbnQpIHRoZW4gSGFzaHRibC5hZGQgYWxsICFjdXJyZW50ICgpXG4gIDs7XG5cbiAgbGV0IGlzX2N1cnJlbnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgfCBTb21lIHAgLT4gcCA9ICFjdXJyZW50XG4gIDs7XG5cbiAgbGV0IGFsbCAoKSA9IExpc3Quc29ydCBTdHJpbmcuY29tcGFyZSAoSGFzaHRibC5mb2xkIChmdW4gayAoKSBhY2MgLT4gayA6OiBhY2MpIGFsbCBbXSlcbmVuZFxuXG5tb2R1bGUgTW9kdWxlX2NvbnRleHQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIG9uZV9tb2R1bGUgPVxuICAgICAgeyBkZXNjciA6IHN0cmluZ1xuICAgICAgOyB0YWdzIDogc3RyaW5nIGxpc3RcbiAgICAgIH1cblxuICAgIHR5cGUgdCA9IG9uZV9tb2R1bGUgbGlzdFxuXG4gICAgbGV0IGRlc2NyIHQgPSBMaXN0Lm1hcCAoZnVuIG0gLT4gbS5kZXNjcikgdFxuICAgIGxldCB0YWdzIHQgPSBMaXN0LmNvbmNhdCAoTGlzdC5tYXAgKGZ1biBtIC0+IG0udGFncykgdClcbiAgZW5kXG5cbiAgbGV0IGN1cnJlbnQgOiBULnQgcmVmID0gcmVmIFtdXG5cbiAgbGV0IHdpdGhfIH5kZXNjciB+dGFncyBmID1cbiAgICBsZXQgcHJldiA9ICFjdXJyZW50IGluXG4gICAgY3VycmVudCA6PSB7IFQuZGVzY3I7IHRhZ3MgfSA6OiBwcmV2O1xuICAgIHRyeVxuICAgICAgbGV0IHggPSBmICgpIGluXG4gICAgICBjdXJyZW50IDo9IHByZXY7XG4gICAgICB4XG4gICAgd2l0aFxuICAgIHwgZSAtPlxuICAgICAgY3VycmVudCA6PSBwcmV2O1xuICAgICAgcmFpc2UgZVxuICA7O1xuXG4gIGxldCBjdXJyZW50X2Rlc2NyICgpID0gVC5kZXNjciAhY3VycmVudFxuICBsZXQgY3VycmVudF90YWdzICgpID0gVC50YWdzICFjdXJyZW50XG5lbmRcblxubGV0IHZlcmJvc2UgPSByZWYgZmFsc2VcbmxldCBzdHJpY3QgPSByZWYgZmFsc2VcbmxldCBzaG93X2NvdW50cyA9IHJlZiBmYWxzZVxubGV0IGxpc3RfdGVzdF9uYW1lcyA9IHJlZiBmYWxzZVxubGV0IGRlbGF5ZWRfZXJyb3JzID0gcmVmIFtdXG5sZXQgc3RvcF9vbl9lcnJvciA9IHJlZiBmYWxzZVxubGV0IGxvZyA9IHJlZiBOb25lXG5sZXQgdGltZV9zZWMgPSByZWYgMC5cbmxldCB1c2VfY29sb3IgPSByZWYgdHJ1ZVxubGV0IGluX3BsYWNlID0gcmVmIGZhbHNlXG5sZXQgZGlmZl9jb21tYW5kID0gcmVmIE5vbmVcbmxldCBzb3VyY2VfdHJlZV9yb290ID0gcmVmIE5vbmVcbmxldCBkaWZmX3BhdGhfcHJlZml4ID0gcmVmIE5vbmVcblxubGV0IGRpc3BsYXllZF9kZXNjciBkZXNjciBmaWxlbmFtZSBsaW5lIHN0YXJ0X3BvcyBlbmRfcG9zID1cbiAgbGV0IChsYXp5IGRlc2NyKSA9IGRlc2NyIGluXG4gIFByaW50Zi5zcHJpbnRmXG4gICAgXCJGaWxlICVTLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkJXNcIlxuICAgIGZpbGVuYW1lXG4gICAgbGluZVxuICAgIHN0YXJ0X3Bvc1xuICAgIGVuZF9wb3NcbiAgICAoaWYgZGVzY3IgPSBcIlwiIHRoZW4gXCJcIiBlbHNlIFwiOiBcIiBeIGRlc2NyKVxuOztcblxubGV0IHBhcnNlX2Rlc2NyIHN0ciA9XG4gIHRyeVxuICAgIFNvbWVcbiAgICAgIChTY2FuZi5zc2NhbmZcbiAgICAgICAgIHN0clxuICAgICAgICAgXCIgRmlsZSAlUyAsIGxpbmUgJWQgLCBjaGFyYWN0ZXJzICVkIC0gJWQgJSFcIlxuICAgICAgICAgKGZ1biBmaWxlIGxpbmUgX3N0YXJ0X3BvcyBfZW5kX3BvcyAtPiBmaWxlLCBTb21lIGxpbmUpKVxuICB3aXRoXG4gIHwgXyAtPlxuICAgICh0cnlcbiAgICAgICBTb21lIChTY2FuZi5zc2NhbmYgc3RyIFwiIEZpbGUgJVMgLCBsaW5lICVkICUhXCIgKGZ1biBmaWxlIGxpbmUgLT4gZmlsZSwgU29tZSBsaW5lKSlcbiAgICAgd2l0aFxuICAgICB8IF8gLT5cbiAgICAgICAodHJ5IFNvbWUgKFNjYW5mLnNzY2FuZiBzdHIgXCIgRmlsZSAlUyAlIVwiIChmdW4gZmlsZSAtPiBmaWxlLCBOb25lKSkgd2l0aFxuICAgICAgICB8IF8gLT4gTm9uZSkpXG47O1xuXG5sZXQgcGFyc2VfYXJndiA/Y3VycmVudCBhcmdzID1cbiAgbWF0Y2ggYXJncyB3aXRoXG4gIHwgbmFtZVxuICAgIDo6IFwiaW5saW5lLXRlc3QtcnVubmVyXCIgKCogd2hlbiB3ZSBzZWUgdGhpcyBhcmd1bWVudCwgd2Ugc3dpdGNoIHRvIHRlc3QgbW9kZSAqKVxuICAgIDo6IGxpYlxuICAgIDo6IHJlc3QgLT5cbiAgICAoKiBpbml0aWFsaXphdGlvbiBzaG91bGQgb25seSBvY2N1ciBvbmNlICopXG4gICAgaWYgIWFscmVhZHlfaW5pdGlhbGl6ZWRcbiAgICB0aGVuXG4gICAgICByYWlzZVxuICAgICAgICAoQXJnLkJhZFxuICAgICAgICAgICBcIlRoZSBpbmxpbmUgdGVzdCBydW5uZXIgY2FuIG9ubHkgYmUgaW5pdGlhbGl6ZWQgb25jZSwgYW5kIGhhcyBhbHJlYWR5IGJlZW4gXFxcbiAgICAgICAgICAgIGluaXRpYWxpemVkLlwiKTtcbiAgICBhbHJlYWR5X2luaXRpYWxpemVkIDo9IHRydWU7XG4gICAgbGV0IHRlc3RzID0gcmVmIFtdIGluXG4gICAgbGV0IGxpc3RfcGFydGl0aW9ucyA9IChyZWYgTm9uZSA6IFdoZXJlX3RvX2xpc3QudCBvcHRpb24gcmVmKSBpblxuICAgIGxldCBwYXJ0aXRpb24gPSByZWYgTm9uZSBpblxuICAgIGxldCB0YWdfcHJlZGljYXRlID0gcmVmIFRhZ19wcmVkaWNhdGUuaW5pdGlhbCBpblxuICAgIGxldCBuYW1lX2ZpbHRlciA9IHJlZiBbXSBpblxuICAgIEFyZy5wYXJzZV9hcmd2XG4gICAgICA/Y3VycmVudFxuICAgICAgKEFycmF5Lm9mX2xpc3QgKG5hbWUgOjogcmVzdCkpXG4gICAgICAoQXJnLmFsaWduXG4gICAgICAgICBbICggXCItbGlzdC10ZXN0LW5hbWVzXCJcbiAgICAgICAgICAgLCBBcmcuVW5pdFxuICAgICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICBsaXN0X3Rlc3RfbmFtZXMgOj0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgdmVyYm9zZSA6PSB0cnVlKVxuICAgICAgICAgICAsIFwiIERvIG5vdCBydW4gdGVzdHMgYnV0IHNob3cgd2hhdCB3b3VsZCBoYXZlIGJlZW4gcnVuXCIgKVxuICAgICAgICAgOyAoIFwiLWxpc3QtcGFydGl0aW9uc1wiXG4gICAgICAgICAgICwgQXJnLlVuaXQgKGZ1biAoKSAtPiBsaXN0X3BhcnRpdGlvbnMgOj0gU29tZSBTdGRvdXQpXG4gICAgICAgICAgICwgXCIgTGlzdHMgYWxsIHRoZSBwYXJ0aXRpb25zIHRoYXQgY29udGFpbiBhdCBsZWFzdCBvbmUgdGVzdCBvciB0ZXN0X21vZHVsZVwiIClcbiAgICAgICAgIDsgKCBcIi1saXN0LXBhcnRpdGlvbnMtaW50by1maWxlXCJcbiAgICAgICAgICAgLCBBcmcuU3RyaW5nIChmdW4gZmlsZSAtPiBsaXN0X3BhcnRpdGlvbnMgOj0gU29tZSAoRmlsZSBmaWxlKSlcbiAgICAgICAgICAgLCBcIiBMaXN0cyBhbGwgdGhlIHBhcnRpdGlvbnMgdGhhdCBjb250YWluIGF0IGxlYXN0IG9uZSB0ZXN0IG9yIHRlc3RfbW9kdWxlIFxcXG4gICAgICAgICAgICAgIGludG8gRklMRVwiIClcbiAgICAgICAgIDsgKCBcIi1wYXJ0aXRpb25cIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBpIC0+IHBhcnRpdGlvbiA6PSBTb21lIGkpXG4gICAgICAgICAgICwgXCIgT25seSBydW4gdGhlIHRlc3RzIGluIHRoZSBnaXZlbiBwYXJ0aXRpb25cIiApXG4gICAgICAgICA7IFwiLXZlcmJvc2VcIiwgQXJnLlNldCB2ZXJib3NlLCBcIiBTaG93IHRoZSB0ZXN0cyBhcyB0aGV5IHJ1blwiXG4gICAgICAgICA7ICggXCItc3RvcC1vbi1lcnJvclwiXG4gICAgICAgICAgICwgQXJnLlNldCBzdG9wX29uX2Vycm9yXG4gICAgICAgICAgICwgXCIgUnVuIHRlc3RzIG9ubHkgdXAgdG8gdGhlIGZpcnN0IGVycm9yIChkb2Vzbid0IHdvcmsgZm9yIGV4cGVjdCB0ZXN0cylcIiApXG4gICAgICAgICA7IFwiLXN0cmljdFwiLCBBcmcuU2V0IHN0cmljdCwgXCIgRW5kIHdpdGggYW4gZXJyb3IgaWYgbm8gdGVzdHMgd2VyZSBydW5cIlxuICAgICAgICAgOyBcIi1zaG93LWNvdW50c1wiLCBBcmcuU2V0IHNob3dfY291bnRzLCBcIiBTaG93IHRoZSBudW1iZXIgb2YgdGVzdHMgcmFuXCJcbiAgICAgICAgIDsgKCBcIi1sb2dcIlxuICAgICAgICAgICAsIEFyZy5Vbml0XG4gICAgICAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICh0cnkgU3lzLnJlbW92ZSBcImlubGluZV90ZXN0cy5sb2dcIiB3aXRoXG4gICAgICAgICAgICAgICAgICB8IF8gLT4gKCkpO1xuICAgICAgICAgICAgICAgICBsb2cgOj0gU29tZSAob3Blbl9vdXQgXCJpbmxpbmVfdGVzdHMubG9nXCIpKVxuICAgICAgICAgICAsIFwiIExvZyB0aGUgdGVzdHMgcnVuIGluIGlubGluZV90ZXN0cy5sb2dcIiApXG4gICAgICAgICA7ICggXCItZHJvcC10YWdcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IHRhZ19wcmVkaWNhdGUgOj0gVGFnX3ByZWRpY2F0ZS5kcm9wICF0YWdfcHJlZGljYXRlIHMpXG4gICAgICAgICAgICwgXCJ0YWcgT25seSBydW4gdGVzdHMgbm90IHRhZ2dlZCB3aXRoIFt0YWddIChvdmVycmlkZXMgcHJldmlvdXMgLXJlcXVpcmUtdGFnKVwiXG4gICAgICAgICAgIClcbiAgICAgICAgIDsgKCBcIi1yZXF1aXJlLXRhZ1wiXG4gICAgICAgICAgICwgQXJnLlN0cmluZyAoZnVuIHMgLT4gdGFnX3ByZWRpY2F0ZSA6PSBUYWdfcHJlZGljYXRlLnJlcXVpcmUgIXRhZ19wcmVkaWNhdGUgcylcbiAgICAgICAgICAgLCBcInRhZyBPbmx5IHJ1biB0ZXN0cyB0YWdnZWQgd2l0aCBbdGFnXSAob3ZlcnJpZGVzIHByZXZpb3VzIC1kcm9wLXRhZylcIiApXG4gICAgICAgICA7ICggXCItbWF0Y2hpbmdcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IG5hbWVfZmlsdGVyIDo9IHMgOjogIW5hbWVfZmlsdGVyKVxuICAgICAgICAgICAsIFwic3Vic3RyaW5nIE9ubHkgcnVuIHRlc3RzIHdob3NlIG5hbWVzIGNvbnRhaW4gdGhlIGdpdmVuIHN1YnN0cmluZ1wiIClcbiAgICAgICAgIDsgKCBcIi1vbmx5LXRlc3RcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmdcbiAgICAgICAgICAgICAgIChmdW4gcyAtPlxuICAgICAgICAgICAgICAgICBsZXQgZmlsZW5hbWUsIGluZGV4ID1cbiAgICAgICAgICAgICAgICAgICBtYXRjaCBwYXJzZV9kZXNjciBzIHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IFNvbWUgKGZpbGUsIGluZGV4KSAtPiBmaWxlLCBpbmRleFxuICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgICAgaWYgU3RyaW5nLmNvbnRhaW5zIHMgJzonXG4gICAgICAgICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSBTdHJpbmcuaW5kZXggcyAnOicgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVuYW1lID0gU3RyaW5nLnN1YiBzIDAgaSBpblxuICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXhfc3RyaW5nID1cbiAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcuc3ViIHMgKGkgKyAxKSAoU3RyaW5nLmxlbmd0aCBzIC0gaSAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IGludF9vZl9zdHJpbmcgaW5kZXhfc3RyaW5nIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICB8IEZhaWx1cmUgXyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEFyZy5CYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQXJndW1lbnQgJXMgZG9lc24ndCBmaXQgdGhlIGZvcm1hdCBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWVbOmxpbmVfbnVtYmVyXVxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlIVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMpKVxuICAgICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSwgU29tZSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgIGVsc2UgcywgTm9uZVxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICB0ZXN0cyA6PSAoZmlsZW5hbWUsIGluZGV4LCByZWYgZmFsc2UpIDo6ICF0ZXN0cylcbiAgICAgICAgICAgLCBcImxvY2F0aW9uIFJ1biBvbmx5IHRoZSB0ZXN0cyBzcGVjaWZpZWQgYnkgYWxsIHRoZSAtb25seS10ZXN0IG9wdGlvbnMuXFxuXFxcbiAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICBMb2NhdGlvbnMgY2FuIGJlIG9uZSBvZiB0aGVzZSBmb3JtczpcXG5cXFxuICAgICAgICAgICAgIFxcICAgICAgICAgICAgICAgICAgICAgIC0gZmlsZS5tbFxcblxcXG4gICAgICAgICAgICAgXFwgICAgICAgICAgICAgICAgICAgICAgLSBmaWxlLm1sOmxpbmVfbnVtYmVyXFxuXFxcbiAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiXFxuXFxcbiAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiLCBsaW5lIDIzXFxuXFxcbiAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiLCBsaW5lIDIzLCBjaGFyYWN0ZXJzIDItM1wiIClcbiAgICAgICAgIDsgXCItbm8tY29sb3JcIiwgQXJnLkNsZWFyIHVzZV9jb2xvciwgXCIgU3VtbWFyaXplIHRlc3RzIHdpdGhvdXQgdXNpbmcgY29sb3JcIlxuICAgICAgICAgOyBcIi1pbi1wbGFjZVwiLCBBcmcuU2V0IGluX3BsYWNlLCBcIiBVcGRhdGUgZXhwZWN0IHRlc3RzIGluIHBsYWNlXCJcbiAgICAgICAgIDsgKCBcIi1kaWZmLWNtZFwiXG4gICAgICAgICAgICwgQXJnLlN0cmluZyAoZnVuIHMgLT4gZGlmZl9jb21tYW5kIDo9IFNvbWUgcylcbiAgICAgICAgICAgLCBcIiBEaWZmIGNvbW1hbmQgZm9yIHRlc3RzIHRoYXQgcmVxdWlyZSBkaWZmaW5nICh1c2UgLSB0byBkaXNhYmxlIGRpZmZpbmcpXCIgKVxuICAgICAgICAgOyAoIFwiLXNvdXJjZS10cmVlLXJvb3RcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IHNvdXJjZV90cmVlX3Jvb3QgOj0gU29tZSBzKVxuICAgICAgICAgICAsIFwiIFBhdGggdG8gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZSB0cmVlXCIgKVxuICAgICAgICAgOyAoIFwiLWRpZmYtcGF0aC1wcmVmaXhcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IGRpZmZfcGF0aF9wcmVmaXggOj0gU29tZSBzKVxuICAgICAgICAgICAsIFwiIFByZWZpeCB0byBwcmVwZW5kIHRvIGZpbGVwYXRocyBpbiB0ZXN0IG91dHB1dFwiIClcbiAgICAgICAgIF0pXG4gICAgICAoZnVuIGFub24gLT5cbiAgICAgICAgcmFpc2VcbiAgICAgICAgICAoQXJnLkJhZCAoUHJpbnRmLnNwcmludGYgXCIlczogdW5leHBlY3RlZCBhbm9ueW1vdXMgYXJndW1lbnQgJXNcXG4lIVwiIG5hbWUgYW5vbikpKVxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiJXMgJXMgJXMgW2FyZ3NdXCIgbmFtZSBcImlubGluZS10ZXN0LXJ1bm5lclwiIGxpYik7XG4gICAgQWN0aW9uLnNldFxuICAgICAgKGBUZXN0X21vZGVcbiAgICAgICAgeyB3aGljaF90ZXN0cyA9XG4gICAgICAgICAgICB7IGxpYm5hbWUgPSBsaWJcbiAgICAgICAgICAgIDsgb25seV90ZXN0X2xvY2F0aW9uID0gIXRlc3RzXG4gICAgICAgICAgICA7IHdoaWNoX3RhZ3MgPSAhdGFnX3ByZWRpY2F0ZVxuICAgICAgICAgICAgOyBuYW1lX2ZpbHRlciA9ICFuYW1lX2ZpbHRlclxuICAgICAgICAgICAgfVxuICAgICAgICA7IHdoYXRfdG9fZG8gPVxuICAgICAgICAgICAgKG1hdGNoICFsaXN0X3BhcnRpdGlvbnMgd2l0aFxuICAgICAgICAgICAgIHwgU29tZSB3aGVyZV90b19saXN0IC0+IGBMaXN0X3BhcnRpdGlvbnMgd2hlcmVfdG9fbGlzdFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBgUnVuX3BhcnRpdGlvbiAhcGFydGl0aW9uKVxuICAgICAgICB9KVxuICB8IF8gLT4gKClcbjs7XG5cbmxldCAoKSA9XG4gIGlmIEJhc2UuRXhwb3J0ZWRfZm9yX3NwZWNpZmljX3VzZXMuYW1fdGVzdGluZ1xuICB0aGVuIChcbiAgICB0cnkgcGFyc2VfYXJndiAoQXJyYXkudG9fbGlzdCBTeXMuYXJndikgd2l0aFxuICAgIHwgQXJnLkJhZCBtc2cgLT5cbiAgICAgIFByaW50Zi5lcHJpbnRmIFwiJXNcIiBtc2c7XG4gICAgICBleGl0IDFcbiAgICB8IEFyZy5IZWxwIG1zZyAtPlxuICAgICAgUHJpbnRmLnByaW50ZiBcIiVzXCIgbXNnO1xuICAgICAgZXhpdCAwKVxuOztcblxubGV0IGluaXQgYXJncyA9XG4gIGxldCBjdXJyZW50ID0gcmVmIDAgaW5cbiAgdHJ5XG4gICAgcGFyc2VfYXJndiB+Y3VycmVudCBhcmdzO1xuICAgIE9rIE5vbmVcbiAgd2l0aFxuICB8IEFyZy5CYWQgbXNnIC0+IEVycm9yIG1zZ1xuICB8IEFyZy5IZWxwIG1zZyAtPiBPayAoU29tZSBtc2cpXG47O1xuXG5sZXQgYW1fdGVzdF9ydW5uZXIgPVxuICBtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgfCBgVGVzdF9tb2RlIF8gLT4gdHJ1ZVxuICB8IGBJZ25vcmUgLT4gZmFsc2Vcbjs7XG5cbmxldCBhbV9ydW5uaW5nX2Vudl92YXIgPVxuICAoKiBmb3IgYXBwcm94aW1hdGUgY29tcGF0aWJpbGl0eSwgZ2l2ZW4gdGhhdCB0aGUgdmFyaWFibGUgaXMgbm90IGV4YWN0bHkgZXF1aXZhbGVudFxuICAgICB0byB3aGF0IFBQWF9JTkxJTkVfVEVTVF9MSUJfQU1fUlVOTklOR19JTkxJTkVfVEVTVCB1c2VkIHRvIGJlICopXG4gIFwiVEVTVElOR19GUkFNRVdPUktcIlxuOztcblxuKCogVGhpcyB2YWx1ZSBpcyBkZXByZWNhdGVkIGluIHByaW5jaXBsZSwgaW4gZmF2b3Igb2YgQ29yZS5hbV9ydW5uaW5nX3Rlc3QsIHNvXG4gICB3ZSdyZSBnb2luZyB0byBsaXZlIHdpdGggdGhlIHVnbHkgcGF0dGVybiBtYXRjaC4gKilcbmxldCBhbV9ydW5uaW5nID1cbiAgbWF0Y2ggU3lzLmdldGVudiBcIlBQWF9JTkxJTkVfVEVTVF9MSUJfQU1fUlVOTklOR19JTkxJTkVfVEVTVFwiIHdpdGhcbiAgfCAoXyA6IHN0cmluZykgLT5cbiAgICB0cnVlICgqIGZvciBjb21wYXRpYmlsaXR5IHdpdGggcGVvcGxlIHNldHRpbmcgdGhpcyB2YXJpYWJsZSBkaXJlY3RseSAqKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAobWF0Y2ggU3lzLmdldGVudiBhbV9ydW5uaW5nX2Vudl92YXIgd2l0aFxuICAgICB8IFwiaW5saW5lLXRlc3RcIiAtPiB0cnVlXG4gICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBmYWxzZVxuICAgICB8IF8gLT4gZmFsc2UpXG47O1xuXG5sZXQgdGVzdGluZyA9XG4gIGlmIGFtX3Rlc3RfcnVubmVyXG4gIHRoZW4gYFRlc3RpbmcgYEFtX3Rlc3RfcnVubmVyXG4gIGVsc2UgaWYgYW1fcnVubmluZ1xuICB0aGVuIGBUZXN0aW5nIGBBbV9jaGlsZF9vZl90ZXN0X3J1bm5lclxuICBlbHNlIGBOb3RfdGVzdGluZ1xuOztcblxuKCogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGludDYzIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIG5hbm9zIHNpbmNlXG4gICBzb21lIChmaXhlZCkgYmFzZWxpbmUuICBPbiB1bml4LCB0aGlzIGJhc2VsaW5lIHdpbGwgYmUgdGhlIHVuaXggZXBvY2gsXG4gICBhbmQgaW4gamF2YXNjcmlwdCwgdGhlIGJhc2VsaW5lIHdpbGwgYmUgXCJwcm9ncmFtIGluaXRpYWxpemF0aW9uIHRpbWUuXCJcbiAgIFJlZ2FyZGxlc3MsIGl0J3MgYWx3YXlzIHNhZmUgdG8gc3VidHJhY3QgdHdvIHZhbHVlcyBhbmQgdXNlIHRoZSBkaWZmLFxuICAgd2hpY2ggaXMgYWxsIHRoYXQgcHB4X2lubGluZV90ZXN0X2xpYiB1c2VzIGl0IGZvci4gKilcbmxldCB0aW1lc3RhbXBfbnMgKCkgPSBUaW1lX25vdy5uYW5vc2Vjb25kX2NvdW50ZXJfZm9yX3RpbWluZyAoKVxuXG5sZXQgd2hlcmVfdG9fY3V0X2JhY2t0cmFjZSA9XG4gIGxhenlcbiAgICAoQmFzZS5TdHJpbmcuU2VhcmNoX3BhdHRlcm4uY3JlYXRlXG4gICAgICAgKF9fTU9EVUxFX18gXiBcIi5cIiBeIFwidGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHNcIikpXG47O1xuXG5sZXQgdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHMgZiA9XG4gIGxldCBiZWZvcmVfbnMgPSB0aW1lc3RhbXBfbnMgKCkgaW5cbiAgbGV0IHJlcyA9XG4gICAgKCogVG8gYXZvaWQgbm9pc2UgaW4gYmFja3RyYWNlcywgd2UgZG8gdHdvIHRoaW5ncy5cblxuICAgICAgIFdlIHVzZSBbd2hlcmVfdG9fY3V0X2JhY2t0cmFjZV0gYWJvdmUgdG8gcmVtb3ZlIHRoZSBzdGFjayBmcmFtZXMgZm9yIHRoZSBjdXJyZW50XG4gICAgICAgZnVuY3Rpb24gYW5kIGFueSBmdW5jdGlvbiBpdCBnZXRzIGlubGluZWQgaW50bywgYXMgaXQncyBub3Qgb2YgYW55IGludGVyZXN0IHRvIHRoZVxuICAgICAgIHVzZXIsIHNpbmNlIGl0J3Mgbm90IHRhbGtpbmcgYWJvdXQgdGhlaXIgdGVzdCBidXQgaW5zdGVhZCB0YWxraW5nIGFib3V0IHRoZVxuICAgICAgIHBweF9pbmxpbmVfdGVzdCBtYWNoaW5lcnkuXG5cbiAgICAgICBXZSBhbHNvIGF2b2lkIGluc2VydGluZyBhbnkgY29kZSBiZXR3ZWVuIHRoZSBbZl0gdGhhdCBjb21lcyBmcm9tIHRoZSB1c2VyJ3MgZmlsZVxuICAgICAgIGFuZCBncmFiYmluZyB0aGUgYmFja3RyYWNlIGZyb20gaXRzIGV4Y2VwdGlvbnMgKG5vIHdyYXBwaW5nIG9mIFtmXSB3aXRoIGhpZ2ggb3JkZXJcbiAgICAgICBmdW5jdGlvbnMgbGlrZSBFeG4ucHJvdGVjdCwgb3IgKGZ1biAoKSAtPiBmICgpOyB0cnVlKSkuICopXG4gICAgdHJ5IE9rIChmICgpKSB3aXRoXG4gICAgfCBleG4gLT4gRXJyb3IgKGV4biwgUHJpbnRleGMuZ2V0X2JhY2t0cmFjZSAoKSlcbiAgaW5cbiAgdGltZV9zZWMgOj0gQmFzZS5JbnQ2My4odGltZXN0YW1wX25zICgpIC0gYmVmb3JlX25zIHw+IHRvX2Zsb2F0KSAvLiAxZTk7XG4gIHJlc1xuOztcblxubGV0IHNhdmVkX2NhbWxfcmFuZG9tX3N0YXRlID0gbGF6eSAoU3RkbGliLlJhbmRvbS5TdGF0ZS5tYWtlIFt8IDEwMDsgMjAwOyAzMDAgfF0pXG5sZXQgc2F2ZWRfYmFzZV9yYW5kb21fc3RhdGUgPSBsYXp5IChCYXNlLlJhbmRvbS5TdGF0ZS5tYWtlIFt8IDExMTsgMjIyOyAzMzMgfF0pXG5cbmxldCB0aW1lX2FuZF9yZXNldF9yYW5kb21fc2VlZHMgZiA9XG4gIGxldCBjYW1sX3JhbmRvbV9zdGF0ZSA9IFN0ZGxpYi5SYW5kb20uZ2V0X3N0YXRlICgpIGluXG4gIGxldCBiYXNlX3JhbmRvbV9zdGF0ZSA9IEJhc2UuUmFuZG9tLlN0YXRlLmNvcHkgQmFzZS5SYW5kb20uU3RhdGUuZGVmYXVsdCBpblxuICBTdGRsaWIuUmFuZG9tLnNldF9zdGF0ZSAoTGF6eS5mb3JjZSBzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSk7XG4gIEJhc2UuUmFuZG9tLnNldF9zdGF0ZSAoTGF6eS5mb3JjZSBzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSk7XG4gIGxldCByZXN1bHQgPSB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmIGluXG4gIFN0ZGxpYi5SYW5kb20uc2V0X3N0YXRlIGNhbWxfcmFuZG9tX3N0YXRlO1xuICBCYXNlLlJhbmRvbS5zZXRfc3RhdGUgYmFzZV9yYW5kb21fc3RhdGU7XG4gIHJlc3VsdFxuOztcblxubGV0IHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkgPVxuICBTdHJpbmcuY29uY2F0XG4gICAgXCJcIlxuICAgIChMaXN0Lm1hcFxuICAgICAgIChmdW4gcyAtPiBcIiAgaW4gVEVTXCIgXiBcIlRfTU9EVUxFIGF0IFwiIF4gU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaSBzIF4gXCJcXG5cIilcbiAgICAgICAoTW9kdWxlX2NvbnRleHQuY3VycmVudF9kZXNjciAoKSkpXG47O1xuXG5sZXQgcG9zaXRpb25fbWF0Y2ggZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBsID1cbiAgTGlzdC5leGlzdHNcbiAgICAoZnVuIChmaWxlbmFtZSwgbGluZV9udW1iZXJfb3B0LCB1c2VkKSAtPlxuICAgICAgbGV0IHBvc2l0aW9uX3N0YXJ0ID0gU3RyaW5nLmxlbmd0aCBkZWZfZmlsZW5hbWUgLSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgICBsZXQgZm91bmQgPVxuICAgICAgICBwb3NpdGlvbl9zdGFydCA+PSAwXG4gICAgICAgICYmXG4gICAgICAgIGxldCBlbmRfb2ZfZGVmX2ZpbGVuYW1lID1cbiAgICAgICAgICBTdHJpbmcuc3ViIGRlZl9maWxlbmFtZSBwb3NpdGlvbl9zdGFydCAoU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSlcbiAgICAgICAgaW5cbiAgICAgICAgZW5kX29mX2RlZl9maWxlbmFtZSA9IGZpbGVuYW1lXG4gICAgICAgICYmIChwb3NpdGlvbl9zdGFydCA9IDAgfHwgZGVmX2ZpbGVuYW1lLltwb3NpdGlvbl9zdGFydCAtIDFdID0gJy8nKVxuICAgICAgICAmJlxuICAgICAgICBtYXRjaCBsaW5lX251bWJlcl9vcHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgICB8IFNvbWUgbGluZV9udW1iZXIgLT4gZGVmX2xpbmVfbnVtYmVyID0gbGluZV9udW1iZXJcbiAgICAgIGluXG4gICAgICBpZiBmb3VuZCB0aGVuIHVzZWQgOj0gdHJ1ZTtcbiAgICAgIGZvdW5kKVxuICAgIGxcbjs7XG5cbmxldCBuYW1lX2ZpbHRlcl9tYXRjaCB+bmFtZV9maWx0ZXIgZGVzY3IgPVxuICBtYXRjaCBuYW1lX2ZpbHRlciB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gOjogXyAtPlxuICAgIExpc3QuZXhpc3RzIChmdW4gc3Vic3RyaW5nIC0+IEJhc2UuU3RyaW5nLmlzX3N1YnN0cmluZyB+c3Vic3RyaW5nIGRlc2NyKSBuYW1lX2ZpbHRlclxuOztcblxubGV0IHByaW50X2RlbGF5ZWRfZXJyb3JzICgpID1cbiAgbWF0Y2ggTGlzdC5yZXYgIWRlbGF5ZWRfZXJyb3JzIHdpdGhcbiAgfCBbXSAtPiAoKVxuICB8IF8gOjogXyBhcyBkZWxheWVkX2Vycm9ycyAtPlxuICAgIFByaW50Zi5lcHJpbnRmIFwiXFxuJXNcXG4lIVwiIChTdHJpbmcubWFrZSA3MCAnPScpO1xuICAgIExpc3QuaXRlciAoZnVuIG1lc3NhZ2UgLT4gUHJpbnRmLmVwcmludGYgXCIlcyUhXCIgbWVzc2FnZSkgZGVsYXllZF9lcnJvcnNcbjs7XG5cbmxldCBlcHJpbnRmX29yX2RlbGF5IGZtdCA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIChmdW4gcyAtPlxuICAgICAgaWYgIXZlcmJvc2UgdGhlbiBkZWxheWVkX2Vycm9ycyA6PSBzIDo6ICFkZWxheWVkX2Vycm9ycyBlbHNlIFByaW50Zi5lcHJpbnRmIFwiJXMlIVwiIHM7XG4gICAgICBpZiAhc3RvcF9vbl9lcnJvclxuICAgICAgdGhlbiAoXG4gICAgICAgIHByaW50X2RlbGF5ZWRfZXJyb3JzICgpO1xuICAgICAgICBleGl0IDIpKVxuICAgIGZtdFxuOztcblxubGV0IGFkZF9ob29rcyAoKG1vZHVsZSBDKSA6IGNvbmZpZykgZiAoKSA9XG4gIEMucHJlX3Rlc3RfaG9vayAoKTtcbiAgZiAoKVxuOztcblxubGV0IGh1bV9iYWNrdHJhY2UgYmFja3RyYWNlID1cbiAgbGV0IG9wZW4gQmFzZSBpblxuICBiYWNrdHJhY2VcbiAgfD4gU3RyaW5nLnNwbGl0X2xpbmVzXG4gIHw+IExpc3QudGFrZV93aGlsZSB+ZjooZnVuIHN0ciAtPlxuICAgICAgIG5vdCAoU3RyaW5nLlNlYXJjaF9wYXR0ZXJuLm1hdGNoZXMgKGZvcmNlIHdoZXJlX3RvX2N1dF9iYWNrdHJhY2UpIHN0cikpXG4gIHw+IExpc3QubWFwIH5mOihmdW4gc3RyIC0+IFwiICBcIiBeIHN0ciBeIFwiXFxuXCIpXG4gIHw+IFN0cmluZy5jb25jYXRcbjs7XG5cbmxldFtAaW5saW5lIG5ldmVyXSB0ZXN0X2lubmVyXG4gIH5jb25maWdcbiAgfmRlc2NyXG4gIH50YWdzXG4gIH5maWxlbmFtZTpkZWZfZmlsZW5hbWVcbiAgfmxpbmVfbnVtYmVyOmRlZl9saW5lX251bWJlclxuICB+c3RhcnRfcG9zXG4gIH5lbmRfcG9zXG4gIGZcbiAgYm9vbF9vZl9mXG4gID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBUZXN0X21vZGVcbiAgICAgIHsgd2hpY2hfdGVzdHMgPSB7IGxpYm5hbWU7IG9ubHlfdGVzdF9sb2NhdGlvbjsgd2hpY2hfdGFnczsgbmFtZV9maWx0ZXIgfVxuICAgICAgOyB3aGF0X3RvX2RvXG4gICAgICB9IC0+XG4gICAgbGV0IGYgPSBhZGRfaG9va3MgY29uZmlnIGYgaW5cbiAgICBsZXQgZGVzY3IgPVxuICAgICAgbGF6eSAoZGlzcGxheWVkX2Rlc2NyIGRlc2NyIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgc3RhcnRfcG9zIGVuZF9wb3MpXG4gICAgaW5cbiAgICBsZXQgY29tcGxldGVfdGFncyA9IHRhZ3MgQCBNb2R1bGVfY29udGV4dC5jdXJyZW50X3RhZ3MgKCkgaW5cbiAgICBsZXQgc2hvdWxkX3J1biA9XG4gICAgICBTb21lIGxpYm5hbWUgPSAhZHluYW1pY19saWJcbiAgICAgICYmIChtYXRjaCBvbmx5X3Rlc3RfbG9jYXRpb24gd2l0aFxuICAgICAgICAgIHwgW10gLT4gdHJ1ZVxuICAgICAgICAgIHwgXyA6OiBfIC0+IHBvc2l0aW9uX21hdGNoIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgb25seV90ZXN0X2xvY2F0aW9uKVxuICAgICAgJiYgKG5vdCAoVGFnX3ByZWRpY2F0ZS5kaXNhYmxlZCB3aGljaF90YWdzIH5jb21wbGV0ZV90YWdzKSlcbiAgICAgICYmIG5hbWVfZmlsdGVyX21hdGNoIH5uYW1lX2ZpbHRlciAoTGF6eS5mb3JjZSBkZXNjcilcbiAgICBpblxuICAgIGlmIHNob3VsZF9ydW5cbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHdoYXRfdG9fZG8gd2l0aFxuICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zIF8gLT4gUGFydGl0aW9uLmZvdW5kX3Rlc3QgKClcbiAgICAgIHwgYFJ1bl9wYXJ0aXRpb24gcGFydGl0aW9uIC0+XG4gICAgICAgIGlmIFBhcnRpdGlvbi5pc19jdXJyZW50IHBhcnRpdGlvblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgZGVzY3IgPSBMYXp5LmZvcmNlIGRlc2NyIGluXG4gICAgICAgICAgaW5jciB0ZXN0c19yYW47XG4gICAgICAgICAgKG1hdGNoICFsb2cgd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgfCBTb21lIGNoIC0+IFByaW50Zi5mcHJpbnRmIGNoIFwiJXNcXG4lc1wiIGRlc2NyIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKSk7XG4gICAgICAgICAgaWYgIXZlcmJvc2UgdGhlbiBQcmludGYucHJpbnRmIFwiJXMlIVwiIGRlc2NyO1xuICAgICAgICAgIGxldCByZXN1bHQgPVxuICAgICAgICAgICAgaWYgIWxpc3RfdGVzdF9uYW1lc1xuICAgICAgICAgICAgdGhlbiBPayB0cnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICgqIFNlZSBbdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHNdIGZvciB3aHkgd2UgdXNlIFtib29sX29mX2ZdXG4gICAgICAgICAgICAgICAgIHJhdGhlciBoYXZlIHRoZSBjYWxsZXIgd3JhcCBbZl0gdG8gYWRqdXN0IGl0cyByZXR1cm4gdmFsdWUuICopXG4gICAgICAgICAgICAgIFJlc3VsdC5tYXAgYm9vbF9vZl9mICh0aW1lX2FuZF9yZXNldF9yYW5kb21fc2VlZHMgZilcbiAgICAgICAgICBpblxuICAgICAgICAgICgqIElmICFsaXN0X3Rlc3RfbmFtZXMsIHRoaXMgaXMgaXMgYSBoYXJtbGVzcyB6ZXJvLiAqKVxuICAgICAgICAgIGlmICF2ZXJib3NlIHRoZW4gUHJpbnRmLnByaW50ZiBcIiAoJS4zZiBzZWMpXFxuJSFcIiAhdGltZV9zZWM7XG4gICAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IE9rIHRydWUgLT4gKClcbiAgICAgICAgICB8IE9rIGZhbHNlIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RzX2ZhaWxlZDtcbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXkgXCIlcyBpcyBmYWxzZS5cXG4lc1xcbiUhXCIgZGVzY3IgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RzX2ZhaWxlZDtcbiAgICAgICAgICAgIGxldCBiYWNrdHJhY2UgPSBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSBpblxuICAgICAgICAgICAgbGV0IGV4bl9zdHIgPSBTZXhwbGliMC5TZXhwX2NvbnYucHJpbnRleGNfcHJlZmVyX3NleHAgZXhuIGluXG4gICAgICAgICAgICBsZXQgc2VwID0gaWYgU3RyaW5nLmNvbnRhaW5zIGV4bl9zdHIgJ1xcbicgdGhlbiBcIlxcblwiIGVsc2UgXCIgXCIgaW5cbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXlcbiAgICAgICAgICAgICAgXCIlcyB0aHJldyVzJXMuXFxuJXMlc1xcbiUhXCJcbiAgICAgICAgICAgICAgZGVzY3JcbiAgICAgICAgICAgICAgc2VwXG4gICAgICAgICAgICAgIGV4bl9zdHJcbiAgICAgICAgICAgICAgYmFja3RyYWNlXG4gICAgICAgICAgICAgIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKSkpXG47O1xuXG5sZXQgc2V0X2xpYl9hbmRfcGFydGl0aW9uIHN0YXRpY19saWIgcGFydGl0aW9uID1cbiAgbWF0Y2ggIWR5bmFtaWNfbGliIHdpdGhcbiAgfCBTb21lIF8gLT5cbiAgICAoKiBwb3NzaWJsZSBpZiB0aGUgaW50ZXJmYWNlIGlzIHVzZWQgZXhwbGljaXRseSBvciBpZiB3ZSBoYXBwZW4gdG8gZHlubGluayBzb21ldGhpbmdcbiAgICAgICB0aGF0IGNvbnRhaW4gdGVzdHMgKilcbiAgICAoKVxuICB8IE5vbmUgLT5cbiAgICBkeW5hbWljX2xpYiA6PSBTb21lIHN0YXRpY19saWI7XG4gICAgKG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICAgICB8IGBJZ25vcmUgLT4gKClcbiAgICAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHM7IHdoYXRfdG9fZG8gfSAtPlxuICAgICAgIGlmIHdoaWNoX3Rlc3RzLmxpYm5hbWUgPSBzdGF0aWNfbGliXG4gICAgICAgdGhlbiAoXG4gICAgICAgICBsZXQgcmVxdWlyZXNfcGFydGl0aW9uID1cbiAgICAgICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICAgICAgIHwgYExpc3RfcGFydGl0aW9ucyBfIHwgYFJ1bl9wYXJ0aXRpb24gKFNvbWUgXykgLT4gdHJ1ZVxuICAgICAgICAgICB8IGBSdW5fcGFydGl0aW9uIE5vbmUgLT4gZmFsc2VcbiAgICAgICAgIGluXG4gICAgICAgICBpZiBwYXJ0aXRpb24gPSBcIlwiICYmIHJlcXVpcmVzX3BhcnRpdGlvblxuICAgICAgICAgdGhlblxuICAgICAgICAgICBmYWlsd2l0aFxuICAgICAgICAgICAgIFwicHB4X2lubGluZV90ZXN0OiBjYW5ub3QgdXNlIC1saXN0LXBhcnRpdGlvbiBvciAtcGFydGl0aW9uIHdpdGhvdXQgXFxcbiAgICAgICAgICAgICAgc3BlY2lmeWluZyBhIHBhcnRpdGlvbiBhdCBwcmVwcm9jZXNzaW5nIHRpbWVcIlxuICAgICAgICAgZWxzZSBQYXJ0aXRpb24uc2V0X2N1cnJlbnQgcGFydGl0aW9uKSlcbjs7XG5cbmxldCB1bnNldF9saWIgc3RhdGljX2xpYiA9XG4gIG1hdGNoICFkeW5hbWljX2xpYiB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICgqIG5vdCBnaXZpbmcgYW4gZXJyb3IsIGJlY2F1c2Ugd2hlbiBzb21lIGFubm95aW5nIHBlb3BsZSBwdXQgcGFfb3VuaXQgaW4gdGhlaXIgbGlzdFxuICAgICAgIG9mIHByZXByb2Nlc3NvcnMsIHBhX291bml0IGlzIHNldCB1cCB0d2ljZSBhbmQgd2UgaGF2ZSB0d28gY2FsbHMgdG8gdW5zZXRfbGliIGF0XG4gICAgICAgdGhlIGVuZCBvZiB0aGUgZmlsZSwgYW5kIHRoZSBzZWNvbmQgb25lIGNvbWVzIGluIHRoaXMgYnJhbmNoICopXG4gICAgKClcbiAgfCBTb21lIGxpYiAtPiBpZiBsaWIgPSBzdGF0aWNfbGliIHRoZW4gZHluYW1pY19saWIgOj0gTm9uZVxuOztcblxubGV0IHRlc3QgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lIH5saW5lX251bWJlciB+c3RhcnRfcG9zIH5lbmRfcG9zIGYgPVxuICB0ZXN0X2lubmVyIH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmIChmdW4gYiAtPlxuICAgIGIpXG47O1xuXG5sZXQgdGVzdF91bml0IH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmID1cbiAgdGVzdF9pbm5lciB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3MgZiAoZnVuICgpIC0+XG4gICAgdHJ1ZSlcbjs7XG5cbmxldFtAaW5saW5lIG5ldmVyXSB0ZXN0X21vZHVsZVxuICB+Y29uZmlnXG4gIH5kZXNjclxuICB+dGFnc1xuICB+ZmlsZW5hbWU6ZGVmX2ZpbGVuYW1lXG4gIH5saW5lX251bWJlcjpkZWZfbGluZV9udW1iZXJcbiAgfnN0YXJ0X3Bvc1xuICB+ZW5kX3Bvc1xuICBmXG4gID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBUZXN0X21vZGVcbiAgICAgIHsgd2hpY2hfdGVzdHMgPSB7IGxpYm5hbWU7IG9ubHlfdGVzdF9sb2NhdGlvbiA9IF87IG5hbWVfZmlsdGVyID0gXzsgd2hpY2hfdGFncyB9XG4gICAgICA7IHdoYXRfdG9fZG9cbiAgICAgIH0gLT5cbiAgICBsZXQgZiA9IGFkZF9ob29rcyBjb25maWcgZiBpblxuICAgIGxldCBkZXNjciAoKSA9IGRpc3BsYXllZF9kZXNjciBkZXNjciBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIHN0YXJ0X3BvcyBlbmRfcG9zIGluXG4gICAgbGV0IHBhcnRpYWxfdGFncyA9IHRhZ3MgQCBNb2R1bGVfY29udGV4dC5jdXJyZW50X3RhZ3MgKCkgaW5cbiAgICBsZXQgc2hvdWxkX3J1biA9XG4gICAgICBTb21lIGxpYm5hbWUgPSAhZHluYW1pY19saWJcbiAgICAgICgqIElmLCBubyBtYXR0ZXIgd2hhdCB0YWdzIGEgdGVzdCBkZWZpbmVzLCB3ZSBjZXJ0YWlubHkgd2lsbCBkcm9wIGFsbCB0ZXN0cyB3aXRoaW5cbiAgICAgICAgIHRoaXMgbW9kdWxlLCB0aGVuIGRvbid0IHJ1biB0aGUgbW9kdWxlIGF0IGFsbC4gVGhpcyBtZWFucyBwZW9wbGUgY2FuIHdyaXRlXG4gICAgICAgICB0aGluZ3MgbGlrZSB0aGUgZm9sbG93aW5nIHdpdGhvdXQgYnJlYWtpbmcgdGhlIDMyLWJpdCBidWlsZDpcbiAgICAgICAgIGxldCV0ZXN0X21vZHVsZSBbQHRhZ3MgXCI2NC1iaXRzLW9ubHlcIl0gPSAobW9kdWxlIHN0cnVjdFxuICAgICAgICAgbGV0IGkgPSBJbnQ2NC50b19pbnRfZXhuIC4uLi5cbiAgICAgICAgIGVuZClcbiAgICAgICAgIFdlIGRvbid0IHNob3J0Y3V0IGJhc2VkIG9uIHBvc2l0aW9uLCBhcyB3ZSBjYW4ndCB0ZWxsIHdoYXQgcG9zaXRpb25zIHRoZVxuICAgICAgICAgaW5uZXIgdGVzdHMgd2lsbCBoYXZlLiAqKVxuICAgICAgJiYgbm90IChUYWdfcHJlZGljYXRlLmVudGlyZV9tb2R1bGVfZGlzYWJsZWQgd2hpY2hfdGFncyB+cGFydGlhbF90YWdzKVxuICAgIGluXG4gICAgaWYgc2hvdWxkX3J1blxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICB8IGBMaXN0X3BhcnRpdGlvbnMgXyAtPiBQYXJ0aXRpb24uZm91bmRfdGVzdCAoKVxuICAgICAgfCBgUnVuX3BhcnRpdGlvbiBwYXJ0aXRpb24gLT5cbiAgICAgICAgaWYgUGFydGl0aW9uLmlzX2N1cnJlbnQgcGFydGl0aW9uXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGluY3IgdGVzdF9tb2R1bGVzX3JhbjtcbiAgICAgICAgICBsZXQgZGVzY3IgPSBkZXNjciAoKSBpblxuICAgICAgICAgIG1hdGNoXG4gICAgICAgICAgICBNb2R1bGVfY29udGV4dC53aXRoXyB+ZGVzY3IgfnRhZ3MgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAoKiBXZSBkbyBub3QgcmVzZXQgcmFuZG9tIHN0YXRlcyB1cG9uIGVudGVyaW5nIFtsZXQldGVzdF9tb2R1bGVdLlxuXG4gICAgICAgICAgICAgICAgIENvbjogQ29kZSBpbiB0ZXN0IG1vZHVsZXMgY2FuIGFjY2lkZW50YWxseSBkZXBlbmQgb24gdG9wLWxldmVsIHJhbmRvbVxuICAgICAgICAgICAgICAgICBzdGF0ZSBlZmZlY3RzLlxuXG4gICAgICAgICAgICAgICAgIFByb3M6ICgxKSBXZSBkb24ndCByZXNldCB0byB0aGUgc2FtZSBzZWVkIG9uIGVudGVyaW5nIGEgW2xldCV0ZXN0X21vZHVsZV1cbiAgICAgICAgICAgICAgICAgYW5kIHRoZW4gYSBbbGV0JXRlc3RdIGluc2lkZSB0aGF0IG1vZHVsZSwgd2hpY2ggY291bGQgbGVhZCB0b1xuICAgICAgICAgICAgICAgICBhY2NpZGVudGFsbHkgcmFuZG9tbHkgZ2VuZXJhdGluZyB0aGUgc2FtZSB2YWx1ZXMgaW4gc29tZSB0ZXN0LiAoMikgTW92aW5nXG4gICAgICAgICAgICAgICAgIGNvZGUgaW50byBhbmQgb3V0IG9mIFtsZXQldGVzdF9tb2R1bGVdIGRvZXMgbm90IGNoYW5nZSBpdHMgcmFuZG9tIHNlZWQuXG4gICAgICAgICAgICAgICopXG4gICAgICAgICAgICAgIHRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzIGYpXG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgT2sgKCkgLT4gKClcbiAgICAgICAgICB8IEVycm9yIChleG4sIGJhY2t0cmFjZSkgLT5cbiAgICAgICAgICAgIGluY3IgdGVzdF9tb2R1bGVzX2ZhaWxlZDtcbiAgICAgICAgICAgIGxldCBiYWNrdHJhY2UgPSBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSBpblxuICAgICAgICAgICAgbGV0IGV4bl9zdHIgPSBTZXhwbGliMC5TZXhwX2NvbnYucHJpbnRleGNfcHJlZmVyX3NleHAgZXhuIGluXG4gICAgICAgICAgICBsZXQgc2VwID0gaWYgU3RyaW5nLmNvbnRhaW5zIGV4bl9zdHIgJ1xcbicgdGhlbiBcIlxcblwiIGVsc2UgXCIgXCIgaW5cbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXlcbiAgICAgICAgICAgICAgKFwiVEVTXCIgXl4gXCJUX01PRFVMRSBhdCAlcyB0aHJldyVzJXMuXFxuJXMlc1xcbiUhXCIpXG4gICAgICAgICAgICAgIChTdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpIGRlc2NyKVxuICAgICAgICAgICAgICBzZXBcbiAgICAgICAgICAgICAgZXhuX3N0clxuICAgICAgICAgICAgICBiYWNrdHJhY2VcbiAgICAgICAgICAgICAgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpKSlcbjs7XG5cbmxldCBzdW1tYXJpemUgKCkgPVxuICBtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+XG4gICAgaWYgU3lzLmFyZ3YgPD4gW3x8XSAmJiBGaWxlbmFtZS5iYXNlbmFtZSBTeXMuYXJndi4oMCkgPSBcImlubGluZV90ZXN0c19ydW5uZXIuZXhlXCJcbiAgICB0aGVuXG4gICAgICBQcmludGYuZXByaW50ZlxuICAgICAgICBcImlubGluZV90ZXN0c19ydW5uZXIuZXhlIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBydW4gYnkgaGFuZCwgeW91IFxcblxcXG4gICAgICAgICBzaG91bGQgcnVuIHRoZSBpbmxpbmVfdGVzdHNfcnVubmVyIHNjcmlwdCBpbnN0ZWFkLlxcblxcXG4gICAgICAgICAlIVwiXG4gICAgZWxzZVxuICAgICAgUHJpbnRmLmVwcmludGZcbiAgICAgICAgXCJZb3UgYXJlIGRvaW5nIHNvbWV0aGluZyB1bmV4cGVjdGVkIHdpdGggdGhlIHRlc3RzLiBObyB0ZXN0cyBoYXZlIFxcblxcXG4gICAgICAgICBiZWVuIHJ1bi4gWW91IHNob3VsZCB1c2UgdGhlIGlubGluZV90ZXN0c19ydW5uZXIgc2NyaXB0IHRvIHJ1biBcXG5cXFxuICAgICAgICAgdGVzdHMuXFxuXFxcbiAgICAgICAgICUhXCI7XG4gICAgVGVzdF9yZXN1bHQuRXJyb3JcbiAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHMgPSBfOyB3aGF0X3RvX2RvID0gYExpc3RfcGFydGl0aW9ucyB3aGVyZV90b19saXN0IH0gLT5cbiAgICBsZXQgd2l0aF9vdXRfY2hhbm5lbCBmID1cbiAgICAgIG1hdGNoIHdoZXJlX3RvX2xpc3Qgd2l0aFxuICAgICAgfCBTdGRvdXQgLT4gZiBzdGRvdXRcbiAgICAgIHwgRmlsZSBmaWxlIC0+XG4gICAgICAgICgqIE5vdCBwYXNzaW5nIE9wZW5fY3JlYXQgZW5zdXJlcyB0aGF0IHRoZSBmaWxlIHdlIGFyZSBzdXBwb3NlZCB0byB3cml0ZSB0byBleGlzdHMgKilcbiAgICAgICAgb3Blbl9vdXRfZ2VuIFsgT3Blbl93cm9ubHk7IE9wZW5fdGV4dCBdIDAgZmlsZVxuICAgICAgICB8PiBCYXNlLkV4bi5wcm90ZWN0eCB+ZiB+ZmluYWxseTpjbG9zZV9vdXRcbiAgICBpblxuICAgIHdpdGhfb3V0X2NoYW5uZWwgKGZ1biBmb3V0IC0+XG4gICAgICBMaXN0Lml0ZXIgKFByaW50Zi5mcHJpbnRmIGZvdXQgXCIlc1xcblwiKSAoUGFydGl0aW9uLmFsbCAoKSkpO1xuICAgIFRlc3RfcmVzdWx0LlN1Y2Nlc3NcbiAgfCBgVGVzdF9tb2RlIHsgd2hhdF90b19kbyA9IGBSdW5fcGFydGl0aW9uIF87IHdoaWNoX3Rlc3RzIH0gLT5cbiAgICAobWF0Y2ggIWxvZyB3aXRoXG4gICAgIHwgTm9uZSAtPiAoKVxuICAgICB8IFNvbWUgY2ggLT4gY2xvc2Vfb3V0IGNoKTtcbiAgICBwcmludF9kZWxheWVkX2Vycm9ycyAoKTtcbiAgICAobWF0Y2ggIXRlc3RzX2ZhaWxlZCwgIXRlc3RfbW9kdWxlc19mYWlsZWQgd2l0aFxuICAgICB8IDAsIDAgLT5cbiAgICAgICBpZiAhc2hvd19jb3VudHNcbiAgICAgICB0aGVuXG4gICAgICAgICBQcmludGYuZXByaW50ZlxuICAgICAgICAgICBcIiVkIHRlc3RzIHJhbiwgJWQgdGVzdF9tb2R1bGVzIHJhblxcbiUhXCJcbiAgICAgICAgICAgIXRlc3RzX3JhblxuICAgICAgICAgICAhdGVzdF9tb2R1bGVzX3JhbjtcbiAgICAgICBsZXQgZXJyb3JzID1cbiAgICAgICAgIGxldCB1bnVzZWRfdGVzdHMgPVxuICAgICAgICAgICBMaXN0LmZpbHRlciAoZnVuIChfLCBfLCB1c2VkKSAtPiBub3QgIXVzZWQpIHdoaWNoX3Rlc3RzLm9ubHlfdGVzdF9sb2NhdGlvblxuICAgICAgICAgaW5cbiAgICAgICAgIG1hdGNoIHVudXNlZF90ZXN0cyB3aXRoXG4gICAgICAgICB8IFtdIC0+IE5vbmVcbiAgICAgICAgIHwgXyA6OiBfIC0+IFNvbWUgdW51c2VkX3Rlc3RzXG4gICAgICAgaW5cbiAgICAgICAobWF0Y2ggZXJyb3JzIHdpdGhcbiAgICAgICAgfCBTb21lIHRlc3RzIC0+XG4gICAgICAgICAgUHJpbnRmLmVwcmludGZcbiAgICAgICAgICAgIFwicHB4X2lubGluZV90ZXN0IGVycm9yOiB0aGUgZm9sbG93aW5nIC1vbmx5LXRlc3QgZmxhZ3MgbWF0Y2hlZCBub3RoaW5nOlwiO1xuICAgICAgICAgIExpc3QuaXRlclxuICAgICAgICAgICAgKGZ1biAoZmlsZW5hbWUsIGxpbmVfbnVtYmVyX29wdCwgXykgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggbGluZV9udW1iZXJfb3B0IHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IFByaW50Zi5lcHJpbnRmIFwiICVzXCIgZmlsZW5hbWVcbiAgICAgICAgICAgICAgfCBTb21lIGxpbmVfbnVtYmVyIC0+IFByaW50Zi5lcHJpbnRmIFwiICVzOiVkXCIgZmlsZW5hbWUgbGluZV9udW1iZXIpXG4gICAgICAgICAgICB0ZXN0cztcbiAgICAgICAgICBQcmludGYuZXByaW50ZiBcIi5cXG4lIVwiO1xuICAgICAgICAgIFRlc3RfcmVzdWx0LkVycm9yXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGlmICF0ZXN0c19yYW4gPSAwICYmICFzdHJpY3RcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIFByaW50Zi5lcHJpbnRmIFwicHB4X2lubGluZV90ZXN0IGVycm9yOiBubyB0ZXN0cyBoYXZlIGJlZW4gcnVuLlxcbiUhXCI7XG4gICAgICAgICAgICBUZXN0X3Jlc3VsdC5FcnJvcilcbiAgICAgICAgICBlbHNlIFRlc3RfcmVzdWx0LlN1Y2Nlc3MpXG4gICAgIHwgY291bnQsIGNvdW50X3Rlc3RfbW9kdWxlcyAtPlxuICAgICAgIFByaW50Zi5lcHJpbnRmXG4gICAgICAgICBcIkZBSUxFRCAlZCAvICVkIHRlc3RzJXNcXG4lIVwiXG4gICAgICAgICBjb3VudFxuICAgICAgICAgIXRlc3RzX3JhblxuICAgICAgICAgKGlmIGNvdW50X3Rlc3RfbW9kdWxlcyA9IDBcbiAgICAgICAgICB0aGVuIFwiXCJcbiAgICAgICAgICBlbHNlIFByaW50Zi5zcHJpbnRmIChcIiwgJWQgVEVTXCIgXl4gXCJUX01PRFVMRVNcIikgY291bnRfdGVzdF9tb2R1bGVzKTtcbiAgICAgICBUZXN0X3Jlc3VsdC5GYWlsdXJlKVxuOztcblxubGV0IGFzc2VydF90ZXN0X2NvbmZpZ3NfaW5pdGlhbGl6ZWQgY29uZmlnID1cbiAgaWYgbm90ICFhbHJlYWR5X2luaXRpYWxpemVkXG4gIHRoZW5cbiAgICBQcmludGYuc3ByaW50ZlxuICAgICAgXCJwcHhfaW5saW5lX3Rlc3QgZXJyb3I6IGF0dGVtcHRlZCB0byBhY2Nlc3MgdGhlIFslc10gY29uZmlnIGJlZm9yZSBbaW5pdF0gd2FzIFxcXG4gICAgICAgY2FsbGVkXCJcbiAgICAgIGNvbmZpZ1xuICAgIHw+IGZhaWx3aXRoXG47O1xuXG5sZXQgdXNlX2NvbG9yICgpID1cbiAgYXNzZXJ0X3Rlc3RfY29uZmlnc19pbml0aWFsaXplZCBcInVzZV9jb2xvclwiO1xuICAhdXNlX2NvbG9yXG47O1xuXG5sZXQgaW5fcGxhY2UgKCkgPVxuICBhc3NlcnRfdGVzdF9jb25maWdzX2luaXRpYWxpemVkIFwiaW5fcGxhY2VcIjtcbiAgIWluX3BsYWNlXG47O1xuXG5sZXQgZGlmZl9jb21tYW5kICgpID1cbiAgYXNzZXJ0X3Rlc3RfY29uZmlnc19pbml0aWFsaXplZCBcImRpZmZfY29tbWFuZFwiO1xuICAhZGlmZl9jb21tYW5kXG47O1xuXG5sZXQgZGlmZl9wYXRoX3ByZWZpeCAoKSA9XG4gIGFzc2VydF90ZXN0X2NvbmZpZ3NfaW5pdGlhbGl6ZWQgXCJkaWZmX3BhdGhfcHJlZml4XCI7XG4gICFkaWZmX3BhdGhfcHJlZml4XG47O1xuXG5sZXQgc291cmNlX3RyZWVfcm9vdCAoKSA9XG4gIGFzc2VydF90ZXN0X2NvbmZpZ3NfaW5pdGlhbGl6ZWQgXCJzb3VyY2VfdHJlZV9yb290XCI7XG4gICFzb3VyY2VfdHJlZV9yb290XG47O1xuXG5sZXQgZXZhbHVhdG9ycyA9IHJlZiBbIHN1bW1hcml6ZSBdXG5sZXQgYWRkX2V2YWx1YXRvciB+ZiA9IGV2YWx1YXRvcnMgOj0gZiA6OiAhZXZhbHVhdG9yc1xuXG5sZXQgZXhpdCAoKSA9XG4gIExpc3QubWFwIChmdW4gZiAtPiBmICgpKSAoTGlzdC5yZXYgIWV2YWx1YXRvcnMpXG4gIHw+IFRlc3RfcmVzdWx0LmNvbWJpbmVfYWxsXG4gIHw+IFRlc3RfcmVzdWx0LnRvX2V4aXRfY29kZVxuICB8PiBleGl0XG47O1xuIl19
