// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ascii_table_kernel__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Ascii_table_kernel = [0],
    Ascii_table_kernel$0 = [0, Ascii_table_kernel];
   runtime.caml_register_global
    (0, Ascii_table_kernel$0, "Ascii_table_kernel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Utf8_text_chunks
//# unitInfo: Requires: Core, Core__Char, Core__Int, Core__List, Core__Option, Core__Sequence, Core__Set, Core__String, Core__Uchar, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Uutf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    cst_Ascii_table_kernel_Utf8_te$0 = "Ascii_table_kernel__Utf8_text_chunks",
    cst_ascii_table_kernel_utf8_te = "ascii_table/kernel/utf8_text_chunks.ml",
    cst_ascii_table_kernel$0 = "ascii_table_kernel",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    Core_String = global_data.Core__String,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Core_Set = global_data.Core__Set,
    Core_Option = global_data.Core__Option,
    Core_Uchar = global_data.Core__Uchar,
    Uutf = global_data.Uutf,
    Core_Int = global_data.Core__Int,
    Assert_failure = global_data.Assert_failure,
    Core_Sequence = global_data.Core__Sequence,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Char = global_data.Core__Char;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Utf8_te$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_ascii_table_kernel_utf8_te);
   caml_call2
    (Ppx_inline_test_lib[6], cst_ascii_table_kernel$0, "utf8_text_chunks.ml");
   var
    _a_ = caml_call1(Core_Char[11], 32),
    space_uchar = caml_call1(Core_Uchar[26], _a_),
    _c_ = [0, cst_ascii_table_kernel_utf8_te, 32, 8],
    _b_ = [0, "pos"],
    cst_Not_UTF_8 = "Not UTF-8",
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel_Utf8_te = cst_Ascii_table_kernel_Utf8_te$0,
    assumed_width_per_uchar = 1;
   function of_utf8(utf8, width, prefer_split_on_spaces){
    var utf8$0 = caml_call1(Core_String[175][60], utf8);
    if(! runtime.caml_string_notequal(utf8$0, cst$0))
     return [0, caml_call1(Core_String[175][59], cst), 0];
    var _f_ = 0;
    function _g_(acc, start_pos, param){return [0, start_pos, acc];}
    var
     _h_ = caml_call5(Uutf[22][2], 0, 0, _g_, _f_, utf8$0),
     _i_ =
       caml_call2(Core_List[142], runtime.caml_ml_string_length(utf8$0), _h_),
     _j_ = caml_call1(Core_List[59], _i_),
     uchar_ends_before_pos = caml_call1(Core_List[85], _j_);
    if(prefer_split_on_spaces){
     var
      init = 0,
      _d_ =
        function(init, start_pos, x){
         if(852405675 <= x[1])
          var uchar = x[2], uchar$0 = uchar;
         else
          var
           s = x[2],
           _u_ =
             [0, [1, [0, _b_, [0, caml_call1(Core[389], start_pos), 0]]], 0],
           _v_ = [0, caml_call1(Core[558], s), _u_],
           _w_ =
             [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Not_UTF_8), _v_]],
           uchar$0 = caml_call1(Core[261], _w_);
         return caml_call2(Core_Uchar[40], space_uchar, uchar$0)
                 ? [0, start_pos + 1 | 0, init]
                 : init;
        },
      _e_ = caml_call5(Uutf[22][2], 0, 0, _d_, init, utf8$0),
      ends_of_spaces = caml_call2(Core_Set[34], [0, Core_Int[97]], _e_),
      num_uchars_left$1 = caml_call1(Core_List[45], uchar_ends_before_pos),
      chunks = 0,
      num_uchars_left = num_uchars_left$1,
      uchars_left = uchar_ends_before_pos;
     for(;;){
      if(! uchars_left){
       var chunks$2 = caml_call1(Core_List[59], chunks);
       break;
      }
      if(caml_call2(Core[89], num_uchars_left * 1 | 0, width))
       var
        chunks$0 = [0, uchars_left, chunks],
        chunks = chunks$0,
        num_uchars_left = 0,
        uchars_left = 0;
      else
       var
        _k_ =
          function(param){
           var uchars_after_last_space = param[1];
           return width - uchars_after_last_space | 0;
          },
        _l_ =
          function(param, pos){
           return caml_call2(Core_Set[11], ends_of_spaces, pos);
          },
        _m_ = caml_call2(Core_List[134], uchars_left, width),
        _n_ = caml_call1(Core_List[59], _m_),
        _o_ = caml_call2(Core_List[38], _n_, _l_),
        _p_ = caml_call2(Core_Option[34], _o_, _k_),
        num_uchars_in_chunk = caml_call2(Core_Option[39], _p_, width),
        match = caml_call2(Core_List[78], uchars_left, num_uchars_in_chunk),
        uchars_left$0 = match[2],
        chunk = match[1],
        num_uchars_left$0 = num_uchars_left - num_uchars_in_chunk | 0,
        chunks$1 = [0, chunk, chunks],
        chunks = chunks$1,
        num_uchars_left = num_uchars_left$0,
        uchars_left = uchars_left$0;
     }
    }
    else{
     if(! caml_call2(Core[90], assumed_width_per_uchar, 1))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var chunks$2 = caml_call2(Core_List[115], uchar_ends_before_pos, width);
    }
    var
     _q_ = caml_call2(Core_List[51], chunks$2, Core_List[117]),
     chunk_ends_before_pos = caml_call1(Core_Sequence[111], _q_);
    function _r_(start_at, end_before){
     var
      _t_ =
        caml_call3
         (Core_String[3], utf8$0, start_at, end_before - start_at | 0);
     return [1, caml_call1(Core_String[175][59], _t_), end_before];
    }
    var _s_ = caml_call3(Core_Sequence[53], chunk_ends_before_pos, 0, _r_);
    return caml_call1(Core_Sequence[30], _s_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Utf8_te);
   var Ascii_table_kernel_Utf8_text_c = [0, of_utf8];
   runtime.caml_register_global
    (28, Ascii_table_kernel_Utf8_text_c, cst_Ascii_table_kernel_Utf8_te$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Import
//# unitInfo: Requires: Core, Core__Int, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel_Import$0 = "Ascii_table_kernel__Import",
    cst_ascii_table_kernel$0 = "ascii_table_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Core_Int = global_data.Core__Int,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Import$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "ascii_table/kernel/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_ascii_table_kernel$0, "import.ml");
   var
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel_Import = cst_Ascii_table_kernel_Import$0;
   function list_sum(l, f){
    function _c_(_e_, _d_){return _e_ + _d_ | 0;}
    return caml_call3(Core_List[26], [0, Core_Int[59], _c_], l, f);
   }
   function list_max(f, lst){
    function _a_(a, b){
     var _b_ = caml_call1(f, b);
     return caml_call2(Core[97], a, _b_);
    }
    return caml_call3(Core_List[20], lst, 0, _a_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Import);
   var Ascii_table_kernel_Import = [0, list_sum, list_max];
   runtime.caml_register_global
    (14, Ascii_table_kernel_Import, cst_Ascii_table_kernel_Import$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Table_char
//# unitInfo: Requires: Base__Buffer, Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel_Table_c$0 = "Ascii_table_kernel__Table_char",
    cst_ascii_table_kernel$0 = "ascii_table_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\xe2\x94\xbc",
    cst$0 = "\xe2\x94\xa4",
    cst$1 = "\xe2\x94\x9c",
    cst$2 = "\xe2\x94\x82",
    cst$3 = "\xe2\x94\xb4",
    cst$4 = "\xe2\x94\x98",
    cst$5 = "\xe2\x94\x94",
    cst$6 = "\xe2\x95\xb5",
    cst$7 = "\xe2\x94\xac",
    cst$8 = "\xe2\x94\x90",
    cst$9 = "\xe2\x94\x8c",
    cst$10 = "\xe2\x95\xb7",
    cst$11 = "\xe2\x94\x80",
    cst$12 = "\xe2\x95\xb4",
    cst$13 = "\xe2\x95\xb6",
    utf8 = " ",
    Base_Buffer = global_data.Base__Buffer,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Table_c$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "ascii_table/kernel/table_char.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_ascii_table_kernel$0, "table_char.ml");
   var
    _a_ = [0, "utf8"],
    _b_ = [0, "ascii"],
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel_Table_c = cst_Ascii_table_kernel_Table_c$0;
   function sexp_of_t(param){
    var
     utf8_004 = param[2],
     ascii_002 = param[1],
     arg_005 = caml_call1(Core[558], utf8_004),
     bnds_001 = [0, [1, [0, _a_, [0, arg_005, 0]]], 0],
     arg_003 = caml_call1(Core[345], ascii_002),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_003, 0]]], bnds_001];
    return [1, bnds_001$0];
   }
   function connect(top, bottom, left, right, param){
    var
     right$0 = caml_call1(Core[253], right),
     left$0 = caml_call1(Core[253], left),
     bottom$0 = caml_call1(Core[253], bottom),
     top$0 = caml_call1(Core[253], top);
    if(top$0)
     if(bottom$0)
      if(left$0)
       if(right$0)
        var utf8$0 = cst, ascii = 43;
       else
        var utf8$0 = cst$0, ascii = 124;
      else if(right$0)
       var utf8$0 = cst$1, ascii = 124;
      else
       var utf8$0 = cst$2, ascii = 124;
     else if(left$0)
      if(right$0)
       var utf8$0 = cst$3, ascii = 45;
      else
       var utf8$0 = cst$4, ascii = 124;
     else if(right$0)
      var utf8$0 = cst$5, ascii = 124;
     else
      var utf8$0 = cst$6, ascii = 124;
    else if(bottom$0)
     if(left$0)
      if(right$0)
       var utf8$0 = cst$7, ascii = 45;
      else
       var utf8$0 = cst$8, ascii = 124;
     else if(right$0)
      var utf8$0 = cst$9, ascii = 124;
     else
      var utf8$0 = cst$10, ascii = 124;
    else if(left$0)
     if(right$0)
      var utf8$0 = cst$11, ascii = 45;
     else
      var utf8$0 = cst$12, ascii = 45;
    else if(right$0)
     var utf8$0 = cst$13, ascii = 45;
    else
     var utf8$0 = utf8, ascii = 32;
    return [0, ascii, utf8$0];
   }
   function to_buffer(param, buf, _c_){
    var utf8 = param[2], ascii = param[1];
    return 962246961 <= _c_
            ? caml_call2(Base_Buffer[15], buf, ascii)
            : caml_call2(Base_Buffer[16], buf, utf8);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Table_c);
   var Ascii_table_kernel_Table_char = [0, sexp_of_t, connect, to_buffer];
   runtime.caml_register_global
    (31, Ascii_table_kernel_Table_char, cst_Ascii_table_kernel_Table_c$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Cell_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel_Cell_in = "Ascii_table_kernel__Cell_intf",
    cst_ascii_table_kernel = "ascii_table_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Cell_in);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "ascii_table/kernel/cell_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_ascii_table_kernel, "cell_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Cell_in);
   var Ascii_table_kernel_Cell_intf = [0];
   runtime.caml_register_global
    (11, Ascii_table_kernel_Cell_intf, cst_Ascii_table_kernel_Cell_in);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Cell
//# unitInfo: Requires: Ansi_kernel, Ascii_table_kernel__Cell_intf, Ascii_table_kernel__Import, Ascii_table_kernel__Utf8_text_chunks, Core, Core__List, Core__String, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel_Cell$0 = "Ascii_table_kernel__Cell",
    cst_ascii_table_kernel$0 = "ascii_table_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_String = global_data.Core__String,
    Core_List = global_data.Core__List,
    Core = global_data.Core,
    Ascii_table_kernel_Utf8_text_c =
      global_data.Ascii_table_kernel__Utf8_text_chunks,
    Ascii_table_kernel_Import = global_data.Ascii_table_kernel__Import,
    Ansi_kernel = global_data.Ansi_kernel,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Cell$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "ascii_table/kernel/cell.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_ascii_table_kernel$0, "cell.ml");
   var
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel_Cell = cst_Ascii_table_kernel_Cell$0;
   function sexp_of_t(x_005){
    function _j_(param){
     var
      arg1_002 = param[2],
      arg0_001 = param[1],
      res0_003 = caml_call2(Core[472], Ansi_kernel[2][1], arg0_001),
      res1_004 = caml_call1(Core_String[175][58], arg1_002);
     return [1, [0, res0_003, [0, res1_004, 0]]];
    }
    return caml_call2(Core[472], _j_, x_005);
   }
   function create(entries){
    function _g_(param){
     var str = param[2], attrs = param[1];
     function _h_(line){
      return [0, attrs, caml_call1(Core_String[175][59], line)];
     }
     var _i_ = caml_call1(Core_String[80], str);
     return caml_call2(Core_List[51], _i_, _h_);
    }
    return caml_call2(Core_List[14], entries, _g_);
   }
   var approx_display_width = Core_String[175][47];
   function width(lines){
    function _f_(param){
     var line = param[2];
     return caml_call1(approx_display_width, line);
    }
    return caml_call2(Ascii_table_kernel_Import[2], _f_, lines);
   }
   function lines(_e_){return _e_;}
   function wrap_lines(lines, width, prefer_split_on_spaces){
    function _c_(param){
     var
      line = param[2],
      attrs = param[1],
      chunks =
        caml_call3
         (Ascii_table_kernel_Utf8_text_c[1],
          line,
          width,
          prefer_split_on_spaces);
     function _d_(chunk){return [0, attrs, chunk];}
     return caml_call2(Core_List[51], chunks, _d_);
    }
    return caml_call2(Core_List[14], lines, _c_);
   }
   function height(lines, display_empty_rows, width, prefer_split_on_spaces){
    var
     _b_ = wrap_lines(lines, width, prefer_split_on_spaces),
     height = caml_call1(Core_List[45], _b_);
    return display_empty_rows ? caml_call2(Core[97], height, 1) : height;
   }
   function is_empty(lines){
    function _a_(param){
     var line = param[2];
     return caml_call1(Core_String[175][13], line);
    }
    return caml_call2(Core_List[24], lines, _a_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Cell);
   var
    Ascii_table_kernel_Cell =
      [0, sexp_of_t, create, is_empty, width, lines, wrap_lines, height];
   runtime.caml_register_global
    (17, Ascii_table_kernel_Cell, cst_Ascii_table_kernel_Cell$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Column_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel_Column_$0 = "Ascii_table_kernel__Column_intf",
    cst_ascii_table_kernel$0 = "ascii_table_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Column_$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "ascii_table/kernel/column_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_ascii_table_kernel$0, "column_intf.ml");
   var
    _e_ = [0, "If_not_empty"],
    _f_ = [0, "No"],
    _d_ = [0, "Yes"],
    _a_ = [0, "Left"],
    _b_ = [0, "Right"],
    _c_ = [0, "Center"],
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel_Column_ = cst_Ascii_table_kernel_Column_$0;
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var Align = [0, sexp_of_t];
   function sexp_of_t$0(param){
    return 4448519 === param ? _d_ : 669869343 <= param ? _e_ : _f_;
   }
   var Show = [0, sexp_of_t$0];
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Column_);
   var Ascii_table_kernel_Column_intf = [0, Align, Show];
   runtime.caml_register_global
    (17, Ascii_table_kernel_Column_intf, cst_Ascii_table_kernel_Column_$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Column
//# unitInfo: Requires: Ascii_table_kernel__Cell, Ascii_table_kernel__Column_intf, Ascii_table_kernel__Import, Base__Field, Core, Core__Int, Core__List, Core__Option, Core__String, Core__Uchar, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    cst_Ascii_table_kernel_Column$0 = "Ascii_table_kernel__Column",
    cst_ascii_table_kernel_column_ = "ascii_table/kernel/column.ml",
    cst_ascii_table_kernel$0 = "ascii_table_kernel",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    Base_Field = global_data.Base__Field,
    Core_Option = global_data.Core__Option,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Core_Int = global_data.Core__Int,
    Ascii_table_kernel_Import = global_data.Ascii_table_kernel__Import,
    Core_Uchar = global_data.Core__Uchar,
    Core_String = global_data.Core__String,
    Ascii_table_kernel_Cell = global_data.Ascii_table_kernel__Cell,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ascii_table_kernel_Column_intf =
      global_data.Ascii_table_kernel__Column_intf;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Column$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_ascii_table_kernel_column_);
   caml_call2(Ppx_inline_test_lib[6], cst_ascii_table_kernel$0, "column.ml");
   var
    Align = Ascii_table_kernel_Column_intf[1],
    Show = Ascii_table_kernel_Column_intf[2],
    _m_ = [0, 0, cst$0],
    _l_ = [0, cst_ascii_table_kernel_column_, 126, 6],
    _j_ = [0, "ascii_table/kernel/column.ml.Impossible_table_constraints"],
    _k_ = [0, "_none_", 0, -1],
    _g_ = [0, "min_widths"],
    _h_ = [0, "total_width"],
    _a_ = [0, "show"],
    _b_ = [0, "min_width"],
    _c_ = [0, "align"],
    _d_ = [0, "col_func"],
    _e_ = [0, "header"],
    _f_ = [0, "max_width"],
    cst_Ascii_table_kernel_Column_ =
      "Ascii_table_kernel__Column.Impossible_table_constraints",
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel_Column = cst_Ascii_table_kernel_Column$0;
   function show(r){return r[6];}
   function align(r){return r[4];}
   function sexp_of_t(of_a_001, param){
    var
     show_013 = param[6],
     min_width_011 = param[5],
     align_009 = param[4],
     header_005 = param[2],
     max_width_003 = param[1],
     arg_014 = caml_call1(Show[1], show_013),
     bnds_002 = [0, [1, [0, _a_, [0, arg_014, 0]]], 0],
     arg_012 = caml_call2(Core[515], Core[389], min_width_011),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_012, 0]]], bnds_002],
     arg_010 = caml_call1(Align[1], align_009),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_010, 0]]], bnds_002$0];
    function _ak_(_al_){return 0;}
    var
     arg_008 = caml_call1(Sexplib0_Sexp_conv[24], _ak_),
     bnds_002$2 = [0, [1, [0, _d_, [0, arg_008, 0]]], bnds_002$1],
     arg_006 = caml_call1(Core_String[175][58], header_005),
     bnds_002$3 = [0, [1, [0, _e_, [0, arg_006, 0]]], bnds_002$2],
     arg_004 = caml_call1(Core[389], max_width_003),
     bnds_002$4 = [0, [1, [0, _f_, [0, arg_004, 0]]], bnds_002$3];
    return [1, bnds_002$4];
   }
   function lift(t, f){
    var _af_ = t[6], _ag_ = t[5], _ah_ = t[4];
    function _ai_(x){
     var _aj_ = caml_call1(f, x);
     return caml_call1(t[3], _aj_);
    }
    return [0, t[1], t[2], _ai_, _ah_, _ag_, _af_];
   }
   function header(t){return caml_call1(Core_String[175][60], t[2]);}
   function optional(t){
    var _ab_ = t[6], _ac_ = t[5], _ad_ = t[4];
    function _ae_(param){
     if(! param) return caml_call1(Ascii_table_kernel_Cell[2], 0);
     var x = param[1];
     return caml_call1(t[3], x);
    }
    return [0, t[1], t[2], _ae_, _ad_, _ac_, _ab_];
   }
   function to_data(t, a){
    var
     _$_ = caml_call1(t[3], a),
     tuples = caml_call1(Ascii_table_kernel_Cell[5], _$_);
    function _aa_(param){
     var line = param[2], attrs = param[1];
     return [0, attrs, caml_call1(Core_String[175][60], line)];
    }
    return caml_call2(Core_List[51], tuples, _aa_);
   }
   var
    Impossible_table_constraints =
      [248, cst_Ascii_table_kernel_Column_, runtime.caml_fresh_oo_id(0)];
   function _i_(param){
    if(param[1] !== Impossible_table_constraints)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    var
     arg0_024 = param[2],
     min_widths_018 = arg0_024[2],
     total_width_016 = arg0_024[1],
     bnds_015 = 0;
    function ___(param){
     var
      arg1_021 = param[2],
      arg0_020 = param[1],
      res0_022 = caml_call1(Core_String[175][58], arg0_020),
      res1_023 = caml_call1(Core[389], arg1_021);
     return [1, [0, res0_022, [0, res1_023, 0]]];
    }
    var
     arg_019 = caml_call2(Core[472], ___, min_widths_018),
     bnds_015$0 = [0, [1, [0, _g_, [0, arg_019, 0]]], bnds_015],
     arg_017 = caml_call1(Core[389], total_width_016),
     bnds_015$1 = [0, [1, [0, _h_, [0, arg_017, 0]]], bnds_015$0],
     res0_025 = [1, bnds_015$1];
    return [1, [0, _j_, [0, res0_025, 0]]];
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Impossible_table_constraints, _i_);
   function create_attrs(opt, min_width, _U_, _T_, str, parse_func){
    if(opt) var sth = opt[1], align = sth; else var align = 0;
    if(_U_) var sth$0 = _U_[1], max_width = sth$0; else var max_width = 90;
    if(_T_) var sth$1 = _T_[1], show = sth$1; else var show = 4448519;
    function _V_(_Z_){return 1 + _Z_ | 0;}
    var _W_ = caml_call2(Core_Option[34], min_width, _V_);
    function _X_(x){
     var _Y_ = caml_call1(parse_func, x);
     return caml_call1(Ascii_table_kernel_Cell[2], _Y_);
    }
    return [0,
            max_width,
            caml_call1(Core_String[175][59], str),
            _X_,
            align,
            _W_,
            show];
   }
   function create_attr(align, min_width, max_width, show, str, parse_func){
    return create_attrs
            (align,
             min_width,
             max_width,
             show,
             str,
             function(x){return [0, caml_call1(parse_func, x), 0];});
   }
   function create(align, min_width, max_width, show, str, parse_func){
    return create_attrs
            (align,
             min_width,
             max_width,
             show,
             str,
             function(x){return [0, [0, 0, caml_call1(parse_func, x)], 0];});
   }
   function to_cell(t, value){return caml_call1(t[3], value);}
   function update_header(f, t){
    var
     _N_ = t[6],
     _O_ = t[5],
     _P_ = t[4],
     _Q_ = t[3],
     _R_ = caml_call1(f, header(t)),
     _S_ = caml_call1(Core_String[175][59], _R_);
    return [0, t[1], _S_, _Q_, _P_, _O_, _N_];
   }
   function update_show(f, t){
    var _M_ = caml_call1(f, t[6]);
    return [0, t[1], t[2], t[3], t[4], t[5], _M_];
   }
   function layout(ts, data, spacing, table_width){
    function _r_(t){
     var
      column_data = caml_call2(Core_List[51], data, t[3]),
      _I_ = caml_call1(Core_Uchar[23], 10),
      _J_ = caml_call2(Core_String[175][45], t[2], _I_),
      header_width =
        caml_call2(Ascii_table_kernel_Import[2], Core_String[175][47], _J_),
      _K_ =
        caml_call2
         (Ascii_table_kernel_Import[2],
          Ascii_table_kernel_Cell[4],
          column_data),
      _L_ = caml_call2(Core[97], header_width, _K_);
     return (1 + (2 * spacing | 0) | 0)
            + caml_call2(Core[96], t[1] - (2 * spacing | 0) | 0, _L_)
            | 0;
    }
    var desired_widths = caml_call2(Core_List[51], ts, _r_);
    function _s_(t){return t[5];}
    var
     all_min_width = caml_call2(Core_List[13], ts, _s_),
     _t_ = caml_call1(Core_List[45], all_min_width),
     columns_with_no_min_width = caml_call1(Core_List[45], ts) - _t_ | 0;
    if(caml_call2(Core_Int[86], 0, columns_with_no_min_width))
     var
      _u_ = function(_F_){return _F_;},
      width =
        table_width
        - caml_call2(Ascii_table_kernel_Import[1], all_min_width, _u_)
        | 0,
      generic_min_chars = runtime.caml_div(width, columns_with_no_min_width),
      impossible =
        caml_call2
         (Core[92], generic_min_chars, 1 + (1 + (spacing * 2 | 0) | 0) | 0),
      generic_min_chars$0 = generic_min_chars,
      table_constraints_are_impossib = impossible;
    else
     var
      _B_ = function(_H_, _G_){return _H_ + _G_ | 0;},
      min_total = caml_call3(Core_List[20], all_min_width, 0, _B_),
      extra_per_col = 2 + (spacing * 2 | 0) | 0,
      _C_ =
        min_total
        + runtime.caml_mul(caml_call1(Core_List[45], ts), extra_per_col)
        | 0,
      table_constraints_are_impossib$0 =
        caml_call2(Core[92], table_width, _C_),
      generic_min_chars$0 = 0,
      table_constraints_are_impossib = table_constraints_are_impossib$0;
    if(table_constraints_are_impossib){
     var
      _v_ =
        function(t){
         function _E_(min_width){return [0, t[2], min_width];}
         return caml_call2(Core_Option[34], t[5], _E_);
        };
     throw caml_maybe_attach_backtrace
            ([0,
              Impossible_table_constraints,
              [0, table_width + 1 | 0, caml_call2(Core_List[13], ts, _v_)]],
             0);
    }
    function _w_(_D_){return _D_;}
    var
     left =
       [0,
        caml_call2(Ascii_table_kernel_Import[1], desired_widths, _w_)
        - table_width
        | 0],
     stop = [0, 0],
     desired_widths$0 = desired_widths;
    function _A_(x){return x - (1 + (spacing * 2 | 0) | 0) | 0;}
    for(;;){
     if(stop[1]) return caml_call2(Core_List[51], desired_widths$0, _A_);
     stop[1] = 1;
     var
      _x_ = caml_call1(Core_List[45], desired_widths$0),
      _y_ = caml_call1(Core_List[45], ts);
     if(! caml_call2(Core[90], _y_, _x_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     var
      _z_ =
        function(t, column_width){
         var match = t[5];
         if(match)
          var x = match[1], min_chars = x;
         else
          var min_chars = generic_min_chars$0;
         a:
         {
          if
           (!
            caml_call2(Core[89], column_width, min_chars)
            && ! caml_call2(Core[89], left[1], 0)){
           left[1] = left[1] - 1 | 0;
           stop[1] = 0;
           var width = column_width - 1 | 0;
           break a;
          }
          var width = column_width;
         }
         var match$0 = t[5];
         if(! match$0) return width;
         var min_width = match$0[1];
         return caml_call2(Core[97], width, min_width);
        },
      desired_widths$1 = caml_call3(Core_List[94], ts, desired_widths$0, _z_),
      desired_widths$0 = desired_widths$1;
    }
   }
   function field
   (align, min_width, max_width, show, header, to_string, record_field){
    function _p_(record){
     return caml_call1
             (to_string, caml_call2(Base_Field[3], record_field, record));
    }
    var _q_ = caml_call1(Base_Field[2], record_field);
    return create
            (align,
             min_width,
             max_width,
             show,
             caml_call2(Core_Option[39], header, _q_),
             _p_);
   }
   function field_attr
   (align,
    min_width,
    max_width,
    show,
    header,
    to_string_and_attr,
    record_field){
    function _n_(record){
     return caml_call1
             (to_string_and_attr,
              caml_call2(Base_Field[3], record_field, record));
    }
    var _o_ = caml_call1(Base_Field[2], record_field);
    return create_attr
            (align,
             min_width,
             max_width,
             show,
             caml_call2(Core_Option[39], header, _o_),
             _n_);
   }
   function field_opt
   (align, min_width, max_width, show, header, to_string, record_field){
    return field
            (align,
             min_width,
             max_width,
             show,
             header,
             function(param){
              if(! param) return cst;
              var x = param[1];
              return caml_call1(to_string, x);
             },
             record_field);
   }
   function field_opt_attr
   (align,
    min_width,
    max_width,
    show,
    header,
    to_string_and_attr,
    record_field){
    return field_attr
            (align,
             min_width,
             max_width,
             show,
             header,
             function(param){
              if(! param) return _m_;
              var x = param[1];
              return caml_call1(to_string_and_attr, x);
             },
             record_field);
   }
   var
    Of_field = [0, field, field_attr, field_opt, field_opt_attr],
    Private = [0, layout, to_cell];
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Column);
   var
    Ascii_table_kernel_Column =
      [0,
       sexp_of_t,
       create,
       create_attr,
       create_attrs,
       lift,
       optional,
       align,
       header,
       show,
       to_data,
       update_header,
       update_show,
       Of_field,
       Private];
   runtime.caml_register_global
    (37, Ascii_table_kernel_Column, cst_Ascii_table_kernel_Column$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Screen_intf
//# unitInfo: Requires: Ansi_kernel, Core, Core__Uchar, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel_Screen_$0 = "Ascii_table_kernel__Screen_intf",
    cst_ascii_table_kernel$0 = "ascii_table_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ansi_kernel = global_data.Ansi_kernel,
    Core = global_data.Core,
    Core_Uchar = global_data.Core__Uchar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Screen_$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "ascii_table/kernel/screen_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_ascii_table_kernel$0, "screen_intf.ml");
   var
    _a_ = [0, "Blank"],
    _b_ = [0, "Line"],
    _c_ = [0, "Char"],
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel_Screen_ = cst_Ascii_table_kernel_Screen_$0;
   function compare(a_001, b_002){
    if(a_001 === b_002) return 0;
    if(typeof a_001 === "number"){
     if(! a_001){
      if(typeof b_002 === "number" && ! b_002) return 0;
      return -1;
     }
     if(typeof b_002 !== "number") return -1;
     if(b_002) return 0;
    }
    else{
     var a_005 = a_001[2], a_003 = a_001[1];
     if(typeof b_002 !== "number"){
      var
       b_006 = b_002[2],
       b_004 = b_002[1],
       _d_ =
         function(a_007, b_008){
          return caml_call2(Ansi_kernel[2][2], a_007, b_008);
         },
       n = caml_call3(Core[466], _d_, a_003, b_004);
      return 0 === n ? caml_call2(Core_Uchar[41], a_005, b_006) : n;
     }
     if(b_002) return 1;
    }
    return 1;
   }
   function sexp_of_t(param){
    if(typeof param === "number") return param ? _a_ : _b_;
    var
     arg1_010 = param[2],
     arg0_009 = param[1],
     res0_011 = caml_call2(Core[472], Ansi_kernel[2][1], arg0_009),
     res1_012 = caml_call1(Core_Uchar[10], arg1_010);
    return [1, [0, _c_, [0, res0_011, [0, res1_012, 0]]]];
   }
   var Texel = [0, compare, sexp_of_t];
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Screen_);
   var Ascii_table_kernel_Screen_intf = [0, Texel];
   runtime.caml_register_global
    (17, Ascii_table_kernel_Screen_intf, cst_Ascii_table_kernel_Screen_$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Screen
//# unitInfo: Requires: Ansi_kernel, Ascii_table_kernel__Screen_intf, Ascii_table_kernel__Table_char, Base__Buffer, Core, Core__Array, Core__List, Core__Option, Core__String, Core__Uchar, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Uutf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel_Screen$0 = "Ascii_table_kernel__Screen",
    cst_ascii_table_kernel$0 = "ascii_table_kernel",
    caml_check_bound = runtime.caml_check_bound;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Buffer = global_data.Base__Buffer,
    Ansi_kernel = global_data.Ansi_kernel,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Ascii_table_kernel_Table_char = global_data.Ascii_table_kernel__Table_char,
    Uutf = global_data.Uutf,
    Core_Option = global_data.Core__Option,
    Core_String = global_data.Core__String,
    Core_Uchar = global_data.Core__Uchar,
    Core_Array = global_data.Core__Array,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ascii_table_kernel_Screen_intf =
      global_data.Ascii_table_kernel__Screen_intf;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Screen$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "ascii_table/kernel/screen.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_ascii_table_kernel$0, "screen.ml");
   var
    Texel = Ascii_table_kernel_Screen_intf[1],
    _a_ = [0, "cols"],
    _b_ = [0, "rows"],
    _c_ = [0, "data"],
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel_Screen = cst_Ascii_table_kernel_Screen$0;
   function sexp_of_t(param){
    var
     cols_012 = param[3],
     rows_010 = param[2],
     data_008 = param[1],
     arg_013 = caml_call1(Core[389], cols_012),
     bnds_007 = [0, [1, [0, _a_, [0, arg_013, 0]]], 0],
     arg_011 = caml_call1(Core[389], rows_010),
     bnds_007$0 = [0, [1, [0, _b_, [0, arg_011, 0]]], bnds_007],
     _Q_ = caml_call1(Core[301], Texel[2]),
     arg_009 = caml_call2(Core[301], _Q_, data_008),
     bnds_007$1 = [0, [1, [0, _c_, [0, arg_009, 0]]], bnds_007$0];
    return [1, bnds_007$1];
   }
   function create(rows, cols){
    var
     _P_ = [0, 0, caml_call1(Core_Uchar[23], 32)],
     data = caml_call3(Core_Array[66], rows, cols, _P_);
    return [0, data, rows, cols];
   }
   function set_screen_point(t, texel, row, col){
    var
     prev =
       caml_check_bound(caml_check_bound(t[1], row)[1 + row], col)[1 + col];
    a:
    {
     if(typeof prev === "number" && prev){var _O_ = 1; break a;}
     if(typeof texel === "number" && texel){var _O_ = 1; break a;}
     var _O_ = texel;
    }
    caml_check_bound(caml_check_bound(t[1], row)[1 + row], col)[1 + col] = _O_;
    return;
   }
   function hline(t, texel, row){
    var _M_ = t[3] - 1 | 0, _L_ = 0;
    if(_M_ >= 0){
     var col = _L_;
     for(;;){
      set_screen_point(t, texel, row, col);
      var _N_ = col + 1 | 0;
      if(_M_ === col) break;
      var col = _N_;
     }
    }
    return 0;
   }
   function vline(t, texel, col){
    var _J_ = t[2] - 1 | 0, _I_ = 0;
    if(_J_ >= 0){
     var row = _I_;
     for(;;){
      set_screen_point(t, texel, row, col);
      var _K_ = row + 1 | 0;
      if(_J_ === row) break;
      var row = _K_;
     }
    }
    return 0;
   }
   function char$0(t, attr, char$0, row, col){
    caml_check_bound(caml_check_bound(t[1], row)[1 + row], col)[1 + col] = [0, attr, char$0];
    return 0;
   }
   function string(t, align, attr, text, row, col, width){
    var approx_display_width = Core_String[175][47];
    switch(align){
      case 0:
       var col$0 = col; break;
      case 1:
       var
        col$0 = (col + width | 0) - caml_call1(approx_display_width, text) | 0;
       break;
      default:
       var
        _H_ = width - caml_call1(approx_display_width, text) | 0,
        col$0 = col + (caml_call2(Core[97], 0, _H_) / 2 | 0) | 0;
    }
    function _G_(i, uchar){return char$0(t, attr, uchar, row, col$0 + i | 0);}
    return caml_call2(Core_String[175][29], text, _G_);
   }
   function render(t, bars, output, close){
    var buf = caml_call1(Base_Buffer[2], 1024), current_attr = [0, 0];
    function update_attr(attr){
     function _C_(a_030, b_031){
      return caml_call2(Ansi_kernel[2][2], a_030, b_031);
     }
     var
      x_032 = caml_call2(Core_List[79], attr, _C_),
      x_033 = current_attr[1];
     function _D_(a_036, b_037){
      return caml_call2(Ansi_kernel[2][2], a_036, b_037);
     }
     var _E_ = 0 === caml_call3(Core[466], _D_, x_032, x_033) ? 1 : 0;
     if(1 - _E_){
      var _F_ = caml_call1(Base_Buffer[12], buf);
      if(caml_call2(Core[91], _F_, 0))
       caml_call2(output, current_attr[1], buf);
      current_attr[1] = x_032;
     }
     return;
    }
    var _x_ = t[2] - 1 | 0, _w_ = 0;
    if(_x_ >= 0){
     var row = _w_;
     for(;;){
      var _z_ = t[3] - 1 | 0, _y_ = 0;
      if(_z_ >= 0){
       var col = _y_;
       for(;;){
        var
         match =
           caml_check_bound(caml_check_bound(t[1], row)[1 + row], col)
            [1 + col];
        if(typeof match === "number")
         if(match)
          caml_call2(Base_Buffer[15], buf, 32);
         else{
          update_attr(0);
          var _f_ = caml_call2(Core[91], row, 0);
          if(_f_)
           var
            _g_ = row - 1 | 0,
            x_014 =
              caml_check_bound(caml_check_bound(t[1], _g_)[1 + _g_], col)
               [1 + col],
            _h_ = 0 === caml_call2(Texel[1], x_014, 0) ? 1 : 0,
            top = _h_;
          else
           var top = _f_;
          var _i_ = caml_call2(Core[92], row, t[2] - 1 | 0);
          if(_i_)
           var
            _j_ = row + 1 | 0,
            x_018 =
              caml_check_bound(caml_check_bound(t[1], _j_)[1 + _j_], col)
               [1 + col],
            _k_ = 0 === caml_call2(Texel[1], x_018, 0) ? 1 : 0,
            bottom = _k_;
          else
           var bottom = _i_;
          var _l_ = caml_call2(Core[91], col, 0);
          if(_l_)
           var
            _m_ = col - 1 | 0,
            x_022 =
              caml_check_bound(caml_check_bound(t[1], row)[1 + row], _m_)
               [1 + _m_],
            _n_ = 0 === caml_call2(Texel[1], x_022, 0) ? 1 : 0,
            left = _n_;
          else
           var left = _l_;
          var _o_ = caml_call2(Core[92], col, t[3] - 1 | 0);
          if(_o_)
           var
            _p_ = col + 1 | 0,
            x_026 =
              caml_check_bound(caml_check_bound(t[1], row)[1 + row], _p_)
               [1 + _p_],
            _q_ = 0 === caml_call2(Texel[1], x_026, 0) ? 1 : 0,
            right = _q_;
          else
           var right = _o_;
          var
           _r_ = caml_call2(Core_Option[60], right, 0),
           _s_ = caml_call2(Core_Option[60], left, 0),
           _t_ = caml_call2(Core_Option[60], bottom, 0),
           _u_ = caml_call2(Core_Option[60], top, 0),
           _v_ =
             caml_call5
              (Ascii_table_kernel_Table_char[2], _u_, _t_, _s_, _r_, 0);
          caml_call3(Ascii_table_kernel_Table_char[3], _v_, buf, bars);
         }
        else{
         var uchar = match[2], attr = match[1];
         update_attr(attr);
         caml_call2(Uutf[23][1], buf, uchar);
        }
        var _B_ = col + 1 | 0;
        if(_z_ === col) break;
        var col = _B_;
       }
      }
      update_attr(0);
      caml_call2(Base_Buffer[15], buf, 10);
      var _A_ = row + 1 | 0;
      if(_x_ === row) break;
      var row = _A_;
     }
    }
    caml_call2(output, current_attr[1], buf);
    return caml_call1(close, buf);
   }
   function to_string(t, bars, string_with_attr){
    var buf = caml_call1(Base_Buffer[2], 1024);
    function _d_(param){return caml_call1(Base_Buffer[3], buf);}
    return render
            (t,
             bars,
             function(attr, buf$0){
              var
               _e_ =
                 caml_call2
                  (string_with_attr, attr, caml_call1(Base_Buffer[3], buf$0));
              caml_call2(Base_Buffer[16], buf, _e_);
              return caml_call1(Base_Buffer[13], buf$0);
             },
             _d_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Screen);
   var
    Ascii_table_kernel_Screen =
      [0, sexp_of_t, to_string, render, string, char$0, create, hline, vline];
   runtime.caml_register_global
    (25, Ascii_table_kernel_Screen, cst_Ascii_table_kernel_Screen$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Grid_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel_Grid_in$0 = "Ascii_table_kernel__Grid_intf",
    cst_ascii_table_kernel$0 = "ascii_table_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Grid_in$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "ascii_table/kernel/grid_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_ascii_table_kernel$0, "grid_intf.ml");
   var
    compare = runtime.caml_int_compare,
    _a_ = [0, "Short_box"],
    _b_ = [0, "Tall_box"],
    _c_ = [0, "Line"],
    _d_ = [0, "Blank"],
    _e_ = [0, "Column_titles"],
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel_Grid_in = cst_Ascii_table_kernel_Grid_in$0;
   function sexp_of_t(param){
    switch(param){
      case 0:
       return _a_;
      case 1:
       return _b_;
      case 2:
       return _c_;
      case 3:
       return _d_;
      default: return _e_;
    }
   }
   var Display = [0, compare, sexp_of_t];
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Grid_in);
   var Ascii_table_kernel_Grid_intf = [0, Display];
   runtime.caml_register_global
    (16, Ascii_table_kernel_Grid_intf, cst_Ascii_table_kernel_Grid_in$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Grid
//# unitInfo: Requires: Ascii_table_kernel__Cell, Ascii_table_kernel__Column, Ascii_table_kernel__Column_intf, Ascii_table_kernel__Grid_intf, Ascii_table_kernel__Import, Ascii_table_kernel__Screen, Core, Core__List, Core__Option, Core__Uchar, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel_Grid$0 = "Ascii_table_kernel__Grid",
    cst_ascii_table_kernel_grid_ml = "ascii_table/kernel/grid.ml",
    cst_ascii_table_kernel$0 = "ascii_table_kernel",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ascii_table_kernel_Screen = global_data.Ascii_table_kernel__Screen,
    Ascii_table_kernel_Cell = global_data.Ascii_table_kernel__Cell,
    Core = global_data.Core,
    Core_Uchar = global_data.Core__Uchar,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Ascii_table_kernel_Import = global_data.Ascii_table_kernel__Import,
    Ascii_table_kernel_Column = global_data.Ascii_table_kernel__Column,
    Core_Option = global_data.Core__Option,
    Ascii_table_kernel_Column_intf =
      global_data.Ascii_table_kernel__Column_intf,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ascii_table_kernel_Grid_intf = global_data.Ascii_table_kernel__Grid_intf;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Grid$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_ascii_table_kernel_grid_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_ascii_table_kernel$0, "grid.ml");
   var
    Display = Ascii_table_kernel_Grid_intf[1],
    _h_ = [0, cst_ascii_table_kernel_grid_ml, 65, 2],
    _g_ = [0, cst_ascii_table_kernel_grid_ml, 55, 8],
    _a_ = [0, "display"],
    _b_ = [0, "spacing"],
    _c_ = [0, "aligns"],
    _d_ = [0, "widths"],
    _e_ = [0, "heights"],
    _f_ = [0, "data"],
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel_Grid = cst_Ascii_table_kernel_Grid$0;
   function sexp_of_t(param){
    var
     display_012 = param[6],
     spacing_010 = param[5],
     aligns_008 = param[4],
     widths_006 = param[3],
     heights_004 = param[2],
     data_002 = param[1],
     arg_013 = caml_call1(Display[2], display_012),
     bnds_001 = [0, [1, [0, _a_, [0, arg_013, 0]]], 0],
     arg_011 = caml_call1(Core[389], spacing_010),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_011, 0]]], bnds_001],
     arg_009 =
       caml_call2(Core[472], Ascii_table_kernel_Column_intf[1][1], aligns_008),
     bnds_001$1 = [0, [1, [0, _c_, [0, arg_009, 0]]], bnds_001$0],
     arg_007 = caml_call2(Core[472], Core[389], widths_006),
     bnds_001$2 = [0, [1, [0, _d_, [0, arg_007, 0]]], bnds_001$1],
     arg_005 = caml_call2(Core[472], Core[389], heights_004),
     bnds_001$3 = [0, [1, [0, _e_, [0, arg_005, 0]]], bnds_001$2],
     _ae_ = caml_call1(Core[472], Ascii_table_kernel_Cell[1]),
     arg_003 = caml_call2(Core[472], _ae_, data_002),
     bnds_001$4 = [0, [1, [0, _f_, [0, arg_003, 0]]], bnds_001$3];
    return [1, bnds_001$4];
   }
   function create
   (cols,
    raw_data,
    display,
    display_empty_rows,
    h_attr,
    max_width,
    spacing,
    prefer_split_on_spaces){
    function _H_(value){
     var _ab_ = Ascii_table_kernel_Column[14][2];
     function _ac_(_ad_){return caml_call2(_ab_, _ad_, value);}
     return caml_call2(Core_List[51], cols, _ac_);
    }
    var body = caml_call2(Core_List[51], raw_data, _H_), _I_ = Core_List[94];
    function _J_(is_empty, element){
     return is_empty
             ? caml_call1(Ascii_table_kernel_Cell[3], element)
             : is_empty;
    }
    function _K_(___){
     var _$_ = caml_call1(_I_, ___);
     return function(_aa_){return caml_call2(_$_, _aa_, _J_);};
    }
    function _L_(param){return 1;}
    var
     _M_ = caml_call2(Core_List[51], cols, _L_),
     empty = caml_call3(Core_List[20], body, _M_, _K_);
    function _N_(column, is_empty){
     var match = caml_call1(Ascii_table_kernel_Column[9], column);
     return 4448519 === match ? 1 : 669869343 <= match ? 1 - is_empty : 0;
    }
    var keep = caml_call3(Core_List[94], cols, empty, _N_);
    function filter(l){
     var _Z_ = caml_call3(Core_List[94], keep, l, Core_Option[60]);
     return caml_call1(Core_List[132], _Z_);
    }
    var
     cols$0 = filter(cols),
     body$0 = caml_call2(Core_List[51], body, filter),
     widths =
       caml_call4
        (Ascii_table_kernel_Column[14][1],
         cols$0,
         raw_data,
         spacing,
         max_width - 1 | 0);
    function _O_(column){
     var
      _Y_ =
        [0, [0, h_attr, caml_call1(Ascii_table_kernel_Column[8], column)], 0];
     return caml_call1(Ascii_table_kernel_Cell[2], _Y_);
    }
    var
     grid_data = [0, caml_call2(Core_List[51], cols$0, _O_), body$0],
     _P_ = 0 === caml_call2(Display[1], display, 2) ? 1 : 0;
    if(_P_)
     var
      _Q_ = function(param){return 1;},
      heights = caml_call2(Core_List[51], grid_data, _Q_);
    else
     var
      _R_ =
        function(row){
         var
          _S_ = caml_call1(Core_List[45], row),
          _T_ = caml_call1(Core_List[45], widths);
         if(! caml_call2(Core[90], _T_, _S_))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
         function _U_(width, element){
          return caml_call4
                  (Ascii_table_kernel_Cell[7],
                   element,
                   display_empty_rows,
                   width,
                   prefer_split_on_spaces);
         }
         var _V_ = caml_call3(Core_List[94], widths, row, _U_);
         function _W_(_X_){return _X_;}
         return caml_call2(Ascii_table_kernel_Import[2], _W_, _V_);
        },
      heights = caml_call2(Core_List[51], grid_data, _R_);
    var
     aligns = caml_call2(Core_List[51], cols$0, Ascii_table_kernel_Column[7]);
    return [0, grid_data, heights, widths, aligns, spacing, display];
   }
   function to_screen(t, prefer_split_on_spaces){
    var
     _i_ = caml_call1(Core_List[45], t[2]),
     _j_ = caml_call1(Core_List[45], t[1]);
    if(! caml_call2(Core[90], _j_, _i_))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var
     x_018 = t[6],
     _k_ = 0 === caml_call2(Display[1], x_018, 1) ? 1 : 0,
     mid_row = _k_ ? 1 : 0,
     _l_ = 1 + (t[5] * 2 | 0) | 0;
    function _m_(_G_){return _l_ + _G_ | 0;}
    var
     cols = caml_call2(Ascii_table_kernel_Import[1], t[3], _m_) + 1 | 0,
     _n_ = 2 * mid_row | 0;
    function _o_(_F_){return mid_row + _F_ | 0;}
    var
     rows =
       (caml_call2(Ascii_table_kernel_Import[1], t[2], _o_) + 3 | 0) - _n_ | 0,
     screen = caml_call2(Ascii_table_kernel_Screen[6], rows, cols),
     x_022 = t[6],
     _p_ = 0 === caml_call2(Display[1], x_022, 4) ? 1 : 0,
     texel = _p_ ? 1 : 0;
    caml_call3(Ascii_table_kernel_Screen[7], screen, texel, 0);
    caml_call3(Ascii_table_kernel_Screen[7], screen, texel, rows - 1 | 0);
    var x_026 = t[6], _q_ = 0 === caml_call2(Display[1], x_026, 3) ? 1 : 0;
    if(1 - _q_){
     caml_call3(Ascii_table_kernel_Screen[8], screen, texel, 0);
     var
      _r_ =
        function(col, width){
         var col$0 = ((col + 1 | 0) + width | 0) + (t[5] * 2 | 0) | 0;
         caml_call3(Ascii_table_kernel_Screen[8], screen, texel, col$0);
         return col$0;
        };
     caml_call3(Core_List[20], t[3], 0, _r_);
    }
    function _s_(row, row_elements, height){
     var header_row = caml_call2(Core[90], row, 1);
     function _t_(col, element, param){
      var
       align = param[2],
       width = param[1],
       lines =
         caml_call3
          (Ascii_table_kernel_Cell[6], element, width, prefer_split_on_spaces),
       x_030 = t[6],
       _y_ = 0 === caml_call2(Display[1], x_030, 2) ? 1 : 0;
      if(_y_){
       if(lines){
        var _z_ = lines[1], attr = _z_[1];
        if(lines[2]){
         var line = _z_[2];
         caml_call7
          (Ascii_table_kernel_Screen[4],
           screen,
           align,
           attr,
           line,
           row,
           col,
           width);
         var
          _A_ = col + caml_call2(Core[97], 0, width - 3 | 0) | 0,
          _B_ = (col + width | 0) - 1 | 0;
         if(_B_ >= _A_){
          var col$0 = _A_;
          for(;;){
           var _C_ = caml_call1(Core_Uchar[23], 46);
           caml_call5
            (Ascii_table_kernel_Screen[5], screen, 0, _C_, row, col$0);
           var _D_ = col$0 + 1 | 0;
           if(_B_ === col$0) break;
           var col$0 = _D_;
          }
         }
        }
        else{
         var line$0 = _z_[2];
         caml_call7
          (Ascii_table_kernel_Screen[4],
           screen,
           align,
           attr,
           line$0,
           row,
           col,
           width);
        }
       }
      }
      else{
       var
        _E_ =
          function(row, param){
           var line = param[2], attr = param[1];
           caml_call7
            (Ascii_table_kernel_Screen[4],
             screen,
             align,
             attr,
             line,
             row,
             col,
             width);
           return row + 1 | 0;
          };
       caml_call3(Core_List[20], lines, row, _E_);
      }
      return ((col + 1 | 0) + (t[5] * 2 | 0) | 0) + width | 0;
     }
     var _u_ = 1 + t[5] | 0, _v_ = caml_call2(Core_List[106], t[3], t[4]);
     caml_call4(Core_List[67], row_elements, _v_, _u_, _t_);
     var
      row$0 = row + height | 0,
      x_034 = t[6],
      _w_ = 0 === caml_call2(Display[1], x_034, 1) ? 1 : 0;
     if(! _w_ && ! header_row) return row$0;
     var x_038 = t[6], _x_ = 0 === caml_call2(Display[1], x_038, 3) ? 1 : 0;
     if(1 - _x_) caml_call3(Ascii_table_kernel_Screen[7], screen, 0, row$0);
     return row$0 + 1 | 0;
    }
    caml_call4(Core_List[67], t[1], t[2], 1, _s_);
    return screen;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Grid);
   var Ascii_table_kernel_Grid = [0, sexp_of_t, create, to_screen];
   runtime.caml_register_global
    (30, Ascii_table_kernel_Grid, cst_Ascii_table_kernel_Grid$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel__Ascii_table_kernel_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel_Ascii_t =
      "Ascii_table_kernel__Ascii_table_kernel_intf",
    cst_ascii_table_kernel = "ascii_table_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel_Ascii_t);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel);
   caml_call1
    (Ppx_expect_runtime[1][1],
     "ascii_table/kernel/ascii_table_kernel_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_ascii_table_kernel,
     "ascii_table_kernel_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel_Ascii_t);
   var Ascii_table_kernel_Ascii_table = [0];
   runtime.caml_register_global
    (11, Ascii_table_kernel_Ascii_table, cst_Ascii_table_kernel_Ascii_t);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ascii_table_kernel
//# unitInfo: Requires: Ascii_table_kernel__Ascii_table_kernel_intf, Ascii_table_kernel__Column, Ascii_table_kernel__Grid, Ascii_table_kernel__Screen, Ascii_table_kernel__Table_char, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ascii_table_kernel$0 = "Ascii_table_kernel",
    cst_ascii_table_kernel$0 = "ascii_table_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Option = global_data.Core__Option,
    Ascii_table_kernel_Grid = global_data.Ascii_table_kernel__Grid,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ascii_table_kernel_Screen = global_data.Ascii_table_kernel__Screen,
    Ascii_table_kernel_Table_char = global_data.Ascii_table_kernel__Table_char,
    Ascii_table_kernel_Column = global_data.Ascii_table_kernel__Column;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ascii_table_kernel$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ascii_table_kernel$0);
   caml_call1
    (Ppx_expect_runtime[1][1], "ascii_table/kernel/ascii_table_kernel.ml");
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_ascii_table_kernel$0,
     "ascii_table_kernel.ml");
   var
    render = Ascii_table_kernel_Screen[3],
    to_string = Ascii_table_kernel_Screen[2],
    Screen = [0, render, to_string],
    _a_ = [0, 0],
    cst_ascii_table_kernel = cst_ascii_table_kernel$0,
    cst_Ascii_table_kernel = cst_Ascii_table_kernel$0,
    short_box = 0,
    tall_box = 1,
    line = 2,
    blank = 3,
    column_titles = 4;
   function draw(opt, _k_, _j_, _i_, _h_, prefer_split_on_spaces, cols, data){
    if(opt) var sth = opt[1], display = sth; else var display = short_box;
    if(_k_) var sth$0 = _k_[1], spacing = sth$0; else var spacing = 1;
    if(_j_)
     var sth$1 = _j_[1], limit_width_to = sth$1;
    else
     var limit_width_to = 90;
    if(_i_) var sth$2 = _i_[1], header_attr = sth$2; else var header_attr = 0;
    if(_h_)
     var sth$3 = _h_[1], display_empty_rows = sth$3;
    else
     var display_empty_rows = 0;
    if(! cols) return 0;
    var
     _l_ =
       caml_call8
        (Ascii_table_kernel_Grid[2],
         cols,
         data,
         display,
         display_empty_rows,
         header_attr,
         limit_width_to,
         spacing,
         prefer_split_on_spaces);
    return [0,
            caml_call2
             (Ascii_table_kernel_Grid[3], _l_, prefer_split_on_spaces)];
   }
   function to_string_noattr
   (display,
    spacing,
    limit_width_to,
    display_empty_rows,
    opt,
    cols,
    data,
    bars){
    if(opt)
     var sth = opt[1], prefer_split_on_spaces = sth;
    else
     var prefer_split_on_spaces = 0;
    var _b_ = Screen[2];
    function _c_(attr, s){return s;}
    function _d_(_g_){return caml_call3(_b_, _g_, bars, _c_);}
    var
     _e_ =
       draw
        (display,
         spacing,
         limit_width_to,
         _a_,
         display_empty_rows,
         prefer_split_on_spaces,
         cols,
         data),
     _f_ = caml_call2(Core_Option[34], _e_, _d_);
    return caml_call2(Core_Option[39], _f_, cst);
   }
   var Private = [0];
   caml_call1(Ppx_inline_test_lib[7], cst_ascii_table_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ascii_table_kernel);
   var
    Ascii_table_kernel =
      [0,
       [0, short_box, tall_box, line, blank, column_titles],
       [0,
        Ascii_table_kernel_Column[1],
        Ascii_table_kernel_Column[2],
        Ascii_table_kernel_Column[3],
        Ascii_table_kernel_Column[4],
        Ascii_table_kernel_Column[5],
        Ascii_table_kernel_Column[6],
        Ascii_table_kernel_Column[7],
        Ascii_table_kernel_Column[8],
        Ascii_table_kernel_Column[9],
        Ascii_table_kernel_Column[10],
        Ascii_table_kernel_Column[11],
        Ascii_table_kernel_Column[12]],
       Screen,
       draw,
       to_string_noattr,
       [0, Ascii_table_kernel_Table_char[2]],
       Private];
   runtime.caml_register_global
    (23, Ascii_table_kernel, cst_Ascii_table_kernel$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhc2NpaV90YWJsZV9rZXJuZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInNwYWNlX3VjaGFyIiwiYXNzdW1lZF93aWR0aF9wZXJfdWNoYXIiLCJvZl91dGY4IiwidXRmOCIsIndpZHRoIiwicHJlZmVyX3NwbGl0X29uX3NwYWNlcyIsInV0ZjgkMCIsImFjYyIsInN0YXJ0X3BvcyIsInVjaGFyX2VuZHNfYmVmb3JlX3BvcyIsImluaXQiLCJ4IiwidWNoYXIiLCJ1Y2hhciQwIiwicyIsImVuZHNfb2Zfc3BhY2VzIiwibnVtX3VjaGFyc19sZWZ0JDEiLCJjaHVua3MiLCJudW1fdWNoYXJzX2xlZnQiLCJ1Y2hhcnNfbGVmdCIsImNodW5rcyQyIiwidWNoYXJzX2FmdGVyX2xhc3Rfc3BhY2UiLCJwb3MiLCJudW1fdWNoYXJzX2luX2NodW5rIiwidWNoYXJzX2xlZnQkMCIsImNodW5rIiwibnVtX3VjaGFyc19sZWZ0JDAiLCJjaHVua19lbmRzX2JlZm9yZV9wb3MiLCJzdGFydF9hdCIsImVuZF9iZWZvcmUiLCJsaXN0X3N1bSIsImwiLCJmIiwibGlzdF9tYXgiLCJsc3QiLCJhIiwiYiIsInNleHBfb2ZfdCIsInV0ZjhfMDA0IiwiYXNjaWlfMDAyIiwiYXJnXzAwNSIsImJuZHNfMDAxIiwiYXJnXzAwMyIsImJuZHNfMDAxJDAiLCJjb25uZWN0IiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwicmlnaHQkMCIsImxlZnQkMCIsImJvdHRvbSQwIiwidG9wJDAiLCJhc2NpaSIsInRvX2J1ZmZlciIsImJ1ZiIsInhfMDA1IiwiYXJnMV8wMDIiLCJhcmcwXzAwMSIsInJlczBfMDAzIiwicmVzMV8wMDQiLCJjcmVhdGUiLCJlbnRyaWVzIiwic3RyIiwiYXR0cnMiLCJsaW5lIiwiYXBwcm94X2Rpc3BsYXlfd2lkdGgiLCJsaW5lcyIsIndyYXBfbGluZXMiLCJoZWlnaHQiLCJkaXNwbGF5X2VtcHR5X3Jvd3MiLCJpc19lbXB0eSIsInNleHBfb2ZfdCQwIiwic2hvdyIsInIiLCJhbGlnbiIsIm9mX2FfMDAxIiwic2hvd18wMTMiLCJtaW5fd2lkdGhfMDExIiwiYWxpZ25fMDA5IiwiaGVhZGVyXzAwNSIsIm1heF93aWR0aF8wMDMiLCJhcmdfMDE0IiwiYm5kc18wMDIiLCJhcmdfMDEyIiwiYm5kc18wMDIkMCIsImFyZ18wMTAiLCJibmRzXzAwMiQxIiwiYXJnXzAwOCIsImJuZHNfMDAyJDIiLCJhcmdfMDA2IiwiYm5kc18wMDIkMyIsImFyZ18wMDQiLCJibmRzXzAwMiQ0IiwibGlmdCIsInQiLCJoZWFkZXIiLCJvcHRpb25hbCIsInRvX2RhdGEiLCJ0dXBsZXMiLCJtaW5fd2lkdGhzXzAxOCIsInRvdGFsX3dpZHRoXzAxNiIsImJuZHNfMDE1IiwiYXJnMV8wMjEiLCJhcmcwXzAyMCIsInJlczBfMDIyIiwicmVzMV8wMjMiLCJhcmdfMDE5IiwiYm5kc18wMTUkMCIsImFyZ18wMTciLCJibmRzXzAxNSQxIiwiY3JlYXRlX2F0dHJzIiwib3B0IiwibWluX3dpZHRoIiwicGFyc2VfZnVuYyIsInN0aCIsInN0aCQwIiwibWF4X3dpZHRoIiwic3RoJDEiLCJjcmVhdGVfYXR0ciIsInRvX2NlbGwiLCJ2YWx1ZSIsInVwZGF0ZV9oZWFkZXIiLCJ1cGRhdGVfc2hvdyIsImxheW91dCIsInRzIiwiZGF0YSIsInNwYWNpbmciLCJ0YWJsZV93aWR0aCIsImNvbHVtbl9kYXRhIiwiaGVhZGVyX3dpZHRoIiwiZGVzaXJlZF93aWR0aHMiLCJhbGxfbWluX3dpZHRoIiwiY29sdW1uc193aXRoX25vX21pbl93aWR0aCIsImdlbmVyaWNfbWluX2NoYXJzIiwiaW1wb3NzaWJsZSIsImdlbmVyaWNfbWluX2NoYXJzJDAiLCJ0YWJsZV9jb25zdHJhaW50c19hcmVfaW1wb3NzaWIiLCJtaW5fdG90YWwiLCJleHRyYV9wZXJfY29sIiwidGFibGVfY29uc3RyYWludHNfYXJlX2ltcG9zc2liJDAiLCJzdG9wIiwiZGVzaXJlZF93aWR0aHMkMCIsImNvbHVtbl93aWR0aCIsIm1pbl9jaGFycyIsImRlc2lyZWRfd2lkdGhzJDEiLCJmaWVsZCIsInRvX3N0cmluZyIsInJlY29yZF9maWVsZCIsInJlY29yZCIsImZpZWxkX2F0dHIiLCJ0b19zdHJpbmdfYW5kX2F0dHIiLCJmaWVsZF9vcHQiLCJmaWVsZF9vcHRfYXR0ciIsImNvbXBhcmUiLCJhXzAwMSIsImJfMDAyIiwiYV8wMDUiLCJhXzAwMyIsImJfMDA2IiwiYl8wMDQiLCJhXzAwNyIsImJfMDA4IiwibiIsImFyZzFfMDEwIiwiYXJnMF8wMDkiLCJyZXMwXzAxMSIsInJlczFfMDEyIiwiY29sc18wMTIiLCJyb3dzXzAxMCIsImRhdGFfMDA4IiwiYXJnXzAxMyIsImJuZHNfMDA3IiwiYXJnXzAxMSIsImJuZHNfMDA3JDAiLCJhcmdfMDA5IiwiYm5kc18wMDckMSIsInJvd3MiLCJjb2xzIiwic2V0X3NjcmVlbl9wb2ludCIsInRleGVsIiwicm93IiwiY29sIiwicHJldiIsImhsaW5lIiwidmxpbmUiLCJjaGFyJDAiLCJhdHRyIiwic3RyaW5nIiwidGV4dCIsImNvbCQwIiwiaSIsInJlbmRlciIsImJhcnMiLCJvdXRwdXQiLCJjbG9zZSIsImN1cnJlbnRfYXR0ciIsInVwZGF0ZV9hdHRyIiwiYV8wMzAiLCJiXzAzMSIsInhfMDMyIiwieF8wMzMiLCJhXzAzNiIsImJfMDM3IiwieF8wMTQiLCJ4XzAxOCIsInhfMDIyIiwieF8wMjYiLCJzdHJpbmdfd2l0aF9hdHRyIiwiYnVmJDAiLCJkaXNwbGF5XzAxMiIsInNwYWNpbmdfMDEwIiwiYWxpZ25zXzAwOCIsIndpZHRoc18wMDYiLCJoZWlnaHRzXzAwNCIsImRhdGFfMDAyIiwiYm5kc18wMDEkMSIsImFyZ18wMDciLCJibmRzXzAwMSQyIiwiYm5kc18wMDEkMyIsImJuZHNfMDAxJDQiLCJyYXdfZGF0YSIsImRpc3BsYXkiLCJoX2F0dHIiLCJib2R5IiwiZWxlbWVudCIsImVtcHR5IiwiY29sdW1uIiwia2VlcCIsImZpbHRlciIsImNvbHMkMCIsImJvZHkkMCIsIndpZHRocyIsImdyaWRfZGF0YSIsImhlaWdodHMiLCJhbGlnbnMiLCJ0b19zY3JlZW4iLCJtaWRfcm93Iiwic2NyZWVuIiwicm93X2VsZW1lbnRzIiwiaGVhZGVyX3JvdyIsInhfMDMwIiwibGluZSQwIiwicm93JDAiLCJ4XzAzNCIsInhfMDM4Iiwic2hvcnRfYm94IiwidGFsbF9ib3giLCJibGFuayIsImNvbHVtbl90aXRsZXMiLCJkcmF3IiwibGltaXRfd2lkdGhfdG8iLCJzdGgkMiIsImhlYWRlcl9hdHRyIiwic3RoJDMiLCJ0b19zdHJpbmdfbm9hdHRyIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvdGV4dHV0aWxzL2FzY2lpX3RhYmxlX2tlcm5lbC9hc2NpaV90YWJsZV9rZXJuZWxfXy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3RleHR1dGlscy9hc2NpaV90YWJsZV9rZXJuZWwvdXRmOF90ZXh0X2NodW5rcy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3RleHR1dGlscy9hc2NpaV90YWJsZV9rZXJuZWwvaW1wb3J0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvdGV4dHV0aWxzL2FzY2lpX3RhYmxlX2tlcm5lbC90YWJsZV9jaGFyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvdGV4dHV0aWxzL2FzY2lpX3RhYmxlX2tlcm5lbC9jZWxsLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvdGV4dHV0aWxzL2FzY2lpX3RhYmxlX2tlcm5lbC9jb2x1bW5faW50Zi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3RleHR1dGlscy9hc2NpaV90YWJsZV9rZXJuZWwvY29sdW1uLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvdGV4dHV0aWxzL2FzY2lpX3RhYmxlX2tlcm5lbC9zY3JlZW5faW50Zi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3RleHR1dGlscy9hc2NpaV90YWJsZV9rZXJuZWwvc2NyZWVuLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvdGV4dHV0aWxzL2FzY2lpX3RhYmxlX2tlcm5lbC9ncmlkX2ludGYubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi90ZXh0dXRpbHMvYXNjaWlfdGFibGVfa2VybmVsL2dyaWQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi90ZXh0dXRpbHMvYXNjaWlfdGFibGVfa2VybmVsL2FzY2lpX3RhYmxlX2tlcm5lbC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztHQXNDOEI7O0lBQUE7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0NuQ1E7SUFBQSxNQUFBO0lBQWxDQSxjQUFjOzs7Ozs7SUFEZEM7WUFjQUMsUUFBUUMsTUFBTUMsT0FBT0M7SUFDWixJQVpnQkMsU0FZaEIsaUNBRERIO3NDQVhpQkc7S0FjbkIsV0FBRTs7aUJBR3NCQyxLQUFJQyxrQkFBZSxXQUFmQSxXQUFKRCxLQUFtQztJQUEvRDtLQUFBLE1BQUEsd0NBakJ1QkQ7S0FpQnZCO09BQUEseURBakJ1QkE7S0FpQnZCLE1BQUE7S0FERUcsd0JBQ0Y7SUFNRixHQVpxQko7S0FvQjZCO01BL0J0Qks7O2lCQStCMkJBLE1BQUlGLFdBekI3Q0c7U0FBSyxnQkFBTEE7Y0FITEMsUUFHS0QsTUF5QnVERSxVQTVCNUREOzs7V0FESUUsSUFJQ0g7O3dEQXlCNkNIOzJDQTdCOUNNOzs7V0E2QndERDtnQkFDckQsMkJBbENoQmIsYUFpQ3FFYTt1QkFBVkwsbUJBQUpFO21CQUFBQTtRQXpCSjtNQURyRCxNQUFBLG1DQUw4QkEsTUFBSEo7TUE4QmZTLGlCQUNGO01BeUJBQyxvQkFBYSwwQkF4Q2pCUDtNQTZCK0JRO01BQU9DLGtCQVdsQ0Y7TUFUQUcsY0EvQkpWOztXQStCSVU7V0F4QkpDLFdBdUJVLDBCQURxQkg7OztTQUdwQixxQkFIMkJDLHlCQWxDNUJkO09Bc0M0QjtRQUFBLGVBRmxDZSxhQUYyQkY7UUFBQUE7UUFBT0M7UUFFbENDOztPQVRBOzs7V0FHaUIsSUFBTUU7a0JBOUJqQmpCLFFBOEJpQmlCO1VBQ2M7OzBCQUZiQztXQUFPLE9BQUEseUJBVjdCUCxnQkFVc0JPO1VBQWlDO1FBRnpELE1BQUEsMkJBU0FILGFBcENNZjtRQTJCTixNQUFBO1FBQUEsTUFBQTtRQUFBLE1BQUE7UUFhT21CLHNCQWRULGlDQTFCUW5CO1FBeUNlLFFBQUEsMEJBTHJCZSxhQUlPSTtRQUNPQztRQUFQQztRQUNBQyxvQkFSMkJSLGtCQU0zQks7UUFHbUIsZUFGbkJFLE9BUG9CUjtRQUFBQTtRQUFPQyxrQkFRM0JRO1FBTlBQLGNBS2NLOzs7O0tBMUJYLEtBQUEscUJBN0JYdkI7TUE2QkksTUFBQTtTQUhBbUIsV0FJQSwyQkFYQVgsdUJBTFVMOztJQWdEYztLQUFBLE1BQUEsMEJBcEN4QmdCO0tBb0NBTyx3QkFBd0I7SUFDNUIsYUFDd0NDLFVBQVNDO0tBR3RDOztRQUFBOzBCQWhFY3ZCLFFBNkRlc0IsVUFBU0MsYUFBVEQ7S0FFakMsV0FDSSx1Q0FIc0NDO0lBTXpDO0lBUFIsVUFBQSw4QkFESUY7SUFDSixPQUFBO0dBUW1COzs7Ozs0Q0F6RG5CekI7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNiQTRCLFNBQVNDLEdBQUdDOzJCO0lBQUksT0FBQSxrREFBUEQsR0FBR0M7R0FBOEI7WUFDMUNDLFNBQVVELEdBQUVFO2lCQUFvQ0MsR0FBRUM7S0FBVyxVQUFBLFdBQW5ESixHQUF3Q0k7S0FBVyxPQUFBLHFCQUFiRDtJQUFrQjtJQUF2QixPQUFBLDBCQUEvQkQ7R0FBdUQ7Ozs7O3VDQURuRUosVUFDQUc7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNTUzlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FWYixTQUFBa0M7SUFBQTtLQUVJQztLQURBQztLQUNBQyxVQUFBLHNCQUFBRjtLQUZKRyxnQ0FFSUQ7S0FEQUUsVUFBQSxzQkFBQUg7S0FESkksa0NBQ0lELGVBREpEO0lBQUEsV0FBQUU7R0FJb0I7WUFFaEJDLFFBQVNDLEtBQUtDLFFBQVFDLE1BQU1DO0lBQzlCO0tBQXVCQyxVQUNzQixzQkFGZkQ7S0FDYkUsU0FDYyxzQkFGUEg7S0FDZkksV0FDTSxzQkFGQ0w7S0FDWk0sUUFDRixzQkFGU1A7T0FDUE87UUFBS0Q7U0FBUUQ7VUFBTUQ7WUFHWjNDLGNBQVArQzs7WUFBTy9DLGdCQUFQK0M7Y0FIbUJKO1dBR1ozQyxnQkFBUCtDOztXQUFPL0MsZ0JBQVArQzthQUhhSDtTQUFNRDtXQUdaM0MsZ0JBQVArQzs7V0FBTy9DLGdCQUFQK0M7YUFIbUJKO1VBR1ozQyxnQkFBUCtDOztVQUFPL0MsZ0JBQVArQztZQUhLRjtRQUFRRDtTQUFNRDtXQUdaM0MsZ0JBQVArQzs7V0FBTy9DLGdCQUFQK0M7YUFIbUJKO1VBR1ozQyxnQkFBUCtDOztVQUFPL0MsaUJBQVArQztZQUhhSDtRQUFNRDtVQUdaM0MsaUJBQVArQzs7VUFBTy9DLGlCQUFQK0M7WUFIbUJKO1NBR1ozQyxpQkFBUCtDOztTQUFPL0MsU0FBQUgsTUFBUGtEO0lBbUJKLFdBbkJJQSxPQUFPL0M7R0FtQkk7WUFHYmdELGlCQUEwQkM7UUFBUHBELGlCQUFQa0Q7O2NBQ0YsNEJBRGdCRSxLQUFkRjtjQUVBLDRCQUZjRSxLQUFQcEQ7Ozs7OzsyQ0FoQ3ZCa0MsV0FNSU8sU0EwQkFVOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDL0JKLFNBQUFqQixVQUFBbUI7OztNQUFVQztNQUFBQztNQUFBQyxvREFBQUQ7TUFBQUUsNENBQUFIO29CQUFBRSxjQUFBQzs7SUFBVixPQUFBLDJCQUFBSjtHQUFnRTtZQUU1REssT0FBT0M7SUFDVDtLQUEyQixJQUFhQyxnQkFBUEM7S0FDL0IsYUFBMENDO01BQVEsV0FEbkJELE9BQzBCLGlDQUFmQztLQUF5QztLQUExRSxVQUFBLDRCQUQ2QkY7S0FDRCxPQUFBO0lBQWdEO0lBRDVELE9BQUEsMEJBRGxCRDtHQUU4RTtPQUdyRkk7WUFNQTlELE1BQU0rRDs7S0FBb0IsSUFBU0Y7S0FBUyxPQUFBLFdBTjVDQyxzQkFNbUNEO0lBQW1DO0lBQXhELE9BQUEsOENBQVJFO0dBQXNFO1lBQzVFQSxXO1lBRUFDLFdBQVdELE9BQU8vRCxPQUFPQzs7S0FDRjtNQUFhNEQ7TUFBUEQ7TUFDekIvQztRQUFTOztVQUR1QmdEO1VBRGxCN0Q7VUFBT0M7S0FHekIsYUFBd0JvQixPQUFTLFdBRkp1QyxPQUVMdkMsT0FBcUI7S0FBMUIsT0FBQSwwQkFEZlI7SUFDMkM7SUFGeEIsT0FBQSwwQkFEWmtEO0dBR29DO1lBRy9DRSxPQUFPRixPQUFPRyxvQkFBb0JsRSxPQUFPQztJQUMzQztLQUFhLE1BUFgrRCxXQU1PRCxPQUEyQi9ELE9BQU9DO0tBQ3ZDZ0UsU0FBUztJQUNiLE9BRmdCQyxxQkFFVyxxQkFEdkJELGFBQUFBO0dBQytDO1lBR2pERSxTQUFTSjtJQUFRO0tBQXNCLElBQVNGO0tBQVMsT0FBQSxpQ0FBVEE7SUFBbUM7SUFBNUMsT0FBQSwwQkFBOUJFO0dBQTBFOzs7Ozs7O1VBM0J2RjlCLFdBRUl3QixRQXlCQVUsVUFkQW5FLE9BQ0ErRCxPQUVBQyxZQU1BQzs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0N0QkYsU0FBQWhDO0lBQUEsc0JBQ0UsbUJBQ0Esb0JBQ0E7O0dBQ2tCO0dBTFAsZ0JBQ2JBO0dBUUEsU0FBQW1DO0lBQUE7R0FLb0I7R0FOUixlQUNaQTs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDUkYsU0FNSUMsS0FBQUMsR0FBQSxPQUFBQSxLQUFJO1lBRkpDLE1BQUFELEdBQUEsT0FBQUEsS0FBSztZQUpUckMsVUFBS3VDO0lBQUw7S0FNSUM7S0FEQUM7S0FEQUM7S0FGQUM7S0FEQUM7S0FLQUMsVUFBQSxvQkFBQUw7S0FOSk0sZ0NBTUlEO0tBREFFLFVBQUEsaUNBQUFOO0tBTEpPLGtDQUtJRCxlQUxKRDtLQUlJRyxVQUFBLHFCQUFBUDtLQUpKUSxrQ0FJSUQsZUFKSkQ7d0I7SUFHSTtLQUFBRztLQUhKQyxrQ0FHSUQsZUFISkQ7S0FFSUcsVUFBQSxpQ0FBQVY7S0FGSlcsa0NBRUlELGVBRkpEO0tBQ0lHLFVBQUEsc0JBQUFYO0tBREpZLGtDQUNJRCxlQURKRDtJQUFBLFdBQUFFO0dBUXFDO1lBRWpDQyxLQUFLQyxHQUFHL0Q7SUFBSSxXQUFQK0QsYUFBQUEsYUFBQUE7a0JBQWdDcEY7S0FBZ0IsV0FBQSxXQUE3Q3FCLEdBQTZCckI7S0FBZ0IsT0FBQSxXQUFoRG9GO0lBQXFEO0lBQTlDLFdBQVBBLE1BQUFBO0dBQXdEO1lBQzdEQyxPQUFPRCxHQUFJLHdDQUFKQSxNQUFrQztZQUV6Q0UsU0FBU0Y7SUFDWCxXQURXQSxhQUFBQSxhQUFBQTs7S0FHUCxZQUNXLE9BQUE7U0FDSHBGO0tBQUssT0FBQSxXQUxOb0YsTUFLQ3BGO0lBQWtCO0lBSjlCLFdBRFdvRixNQUFBQTtHQU1WO1lBR0NHLFFBQVFILEdBQUU1RDtJQUNaO0tBQXdCLE1BQUEsV0FEZDRELE1BQUU1RDtLQUNSZ0UsU0FBUztJQUNiO0tBQW1CLElBQWFsQyxpQkFBUEQ7S0FBZ0IsV0FBaEJBLE9BQXVCLGlDQUFoQkM7SUFBMkM7SUFBeEQsT0FBQSwwQkFEZmtDO0dBQ3VFO0dBUzdFOzs7O0k7Ozs7S0FKSUM7S0FEQUM7S0FESkM7OztNQUVrQkM7TUFBQUM7TUFBQUMsNENBQUFEO01BQUFFLGlDQUFBSDtvQkFBQUUsY0FBQUM7O0lBQWQ7S0FBQUMsVUFBQSwyQkFBQVA7S0FGSlEsa0NBRUlELGVBRkpMO0tBQ0lPLFVBQUEsc0JBQUFSO0tBREpTLGtDQUNJRCxlQURKRDtLQUFBLGVBQUFFOzs7OztZQVFJQyxhQUNBQyxLQUNEQyxxQkFHRGxELEtBQ0FtRDtJQUVBLEdBUEVGLFNBQVFHLE1BQVJILFFBQUFyQyxRQUFRd0MsY0FBUnhDO0lBT0YsWUFMY3lDLGdCQUFaQyxZQUFZRCxnQkFBWkM7SUFLRixZQUpTQyxnQkFBUDdDLE9BQU82QyxnQkFBUDdDO0lBU29DLGtCO0lBQXhCLFVBQUEsNEJBWGJ3QztpQkFRaUJ0RztLQUFpQixVQUFBLFdBSm5DdUcsWUFJa0J2RztLQUFpQixPQUFBO0lBQWM7SUFGakQ7WUFMRTBHO1lBTVMsaUNBSlh0RDs7WUFKRVk7O1lBR0FGO0dBV0Q7WUFHQzhDLFlBQWE1QyxPQUFPc0MsV0FBV0ksV0FBVzVDLE1BQUtWLEtBQUltRDtJQUNyRCxPQW5CRUg7YUFrQmFwQzthQUFPc0M7YUFBV0k7YUFBVzVDO2FBQUtWO3NCQUNRcEQsR0FBSyxXQUFFLFdBRFh1RyxZQUNJdkcsT0FBcUI7R0FBQztZQUc3RWtELE9BQVFjLE9BQU9zQyxXQUFXSSxXQUFXNUMsTUFBS1YsS0FBSW1EO0lBQ2hELE9BdkJFSDthQXNCUXBDO2FBQU9zQzthQUFXSTthQUFXNUM7YUFBS1Y7c0JBQ2FwRCxHQUFLLGtCQUFNLFdBRHBCdUcsWUFDU3ZHLFFBQXlCO0dBQUM7WUFHakY2RyxRQUFRekIsR0FBRzBCLE9BQVEsT0FBQSxXQUFYMUIsTUFBRzBCLE9BQXdCO1lBQ25DQyxjQUFlMUYsR0FBRStEO0lBQUk7V0FBSkE7V0FBQUE7V0FBQUE7V0FBQUE7S0FBc0IsTUFBQSxXQUF4Qi9ELEdBbkRmZ0UsT0FtRGlCRDtLQUFzQixNQUFBO0lBQWxCLFdBQUpBO0dBQTZEO1lBQzlFNEIsWUFBYTNGLEdBQUUrRDtJQUFvQixVQUFBLFdBQXRCL0QsR0FBRStEO0lBQUksV0FBSkEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUE7R0FBOEI7WUFtQjdDNkIsT0FBT0MsSUFBR0MsTUFBTUMsU0FBbUJDO0lBQ0QsYUFsQk5qQztLQUNaO01BQWRrQyxjQUFjLDBCQWdCTkgsTUFqQmtCL0I7TUFLRyxNQUFBO01BQS9CLE1BQUEsaUNBTDRCQTtNQUUxQm1DO1FBR0Y7TUFTb0I7UUFBQTs7O1VBYmxCRDtNQWFBLE1BQUEscUJBWkFDO3NCQWVjSDtjQUxoQixxQkFaNEJoQyxZQWlCWmdDOzs7SUFDRyxJQWlDQ0ksaUJBakNELDBCQURaTjtJQUVULGFBQStDOUIsR0FBSyxPQUFMQSxLQUFnQjtJQUEzQztLQUFoQnFDLGdCQUFnQiwwQkFGWFA7S0FNMEMsTUFBQSwwQkFKL0NPO0tBSUVDLDRCQUE0QiwwQkFOekJSO0lBT0osR0FBQSw0QkFEQ1E7S0FFQztNQUFBLG9CQUFBO01BQ0NqSTtRQVQ2QjRIO1VBU1AseUNBUDFCSTs7TUFRSUUscUNBREFsSSxPQUhGaUk7TUFLRUU7UUFBYTtvQkFEYkQsNkJBVlVQO01BS29CUyxzQkFLOUJGO01BTEpHLGlDQU1JRjs7S0FFRDtNQUFBLHlCO01BQ0NHLFlBQVksMEJBWmhCTjtNQWFJTyxxQkFmVVo7O1FBY1ZXO1VBRXdDLGlCQUFBLDBCQWhCdkNiLEtBZURjOztNQVZKQztRQVdpQixxQkFoQmdCWjtNQUtDUTtNQUFsQ0MsaUNBQUFHO09BQUFIO0tBa0JGOztpQkFJb0MxQztzQkFDTWtCLFdBQWEsV0FEbkJsQixNQUNNa0IsV0FBZ0M7U0FBckMsT0FBQSw0QkFERGxCO1FBQ3VDO0tBTDNFLE1BQUE7OztrQkF2Qm1DaUMscUJBMkIxQiwwQkEzQkZIOzs7c0I7SUE4QkU7S0FBUDlFOztRQUFZLHlDQUlNb0Y7VUFsQ2VIOztLQStCakNhO0tBR2tCQyxtQkFBQVg7aUJBNkJMeEgsR0FBSyxPQUFMQSxVQS9EQ29ILDBCQStEMkI7SUE1QjNDO1FBSkVjLFNBZ0NRLE9BQUEsMEJBN0JVQztLQUhsQkQ7S0FReUI7TUFBQSxNQUFBLDBCQUxQQztNQUtWLE1BQUEsMEJBdkNIakI7S0F1Q0UsS0FBQTtNQUFQLE1BQUE7S0FFRTs7aUJBQXlDOUIsR0FBRWdEO1NBQ3hDLFlBRHNDaEQ7O2NBRzdCcEYsY0FGTHFJLFlBRUtySTs7Y0FGTHFJLFlBckN5QlI7OztVQTJDSzs7WUFBN0IscUJBUG1DTyxjQUNwQ0M7aUJBTThCLHFCQWxCdkNqRztXQUFBQSxVQUFBQTtXQUNBOEY7ZUFnQlN6SSxRQU5vQzJJOzs7Y0FNcEMzSSxRQU5vQzJJOztTQWV4QyxjQWZzQ2hEO3VCQWdCNUIsT0FWTjNGO2FBV0c2RztTQUFhLE9BQUEscUJBWGhCN0csT0FXRzZHO1FBQWdDO01BeEIxQmdDLG1CQU9oQiwwQkF6Q0dwQixJQWtDYWlCO01BQUFBLG1CQUFBRzs7R0E2QnVEO1lBSXpFQztJQUFPdkUsT0FBT3NDLFdBQVdJLFdBQVc1QyxNQUFNdUIsUUFBT21ELFdBQVVDO2lCQU90REM7S0FBVSxPQUFVO2NBUHdCRixXQU94QiwwQkFQa0NDLGNBT3REQztJQUFtRDtJQUQxQixVQUFBLDBCQU42QkQ7SUFPM0QsT0FuR0Z2RjthQTRGU2M7YUFBT3NDO2FBQVdJO2FBQVc1QzthQU1wQyw0QkFOMEN1Qjs7R0FPZTtZQUd6RHNEO0lBQ0QzRTtJQUNBc0M7SUFDQUk7SUFDQTVDO0lBQ0F1QjtJQUNEdUQ7SUFDQUg7aUJBUU9DO0tBQVUsT0FBbUI7Y0FUcENFO2NBU29DLDBCQVJwQ0gsY0FRT0M7SUFBNEQ7SUFEbkMsVUFBQSwwQkFQaENEO0lBUUUsT0F6SEY3QjthQTJHQzVDO2FBQ0FzQzthQUNBSTthQUNBNUM7YUFVQyw0QkFURHVCOztHQVVtRTtZQUdsRXdEO0lBQVc3RSxPQUFPc0MsV0FBV0ksV0FBVzVDLE1BQU11QixRQUFPbUQsV0FBVUM7SUFDakUsT0E3QkVGO2FBNEJXdkU7YUFBT3NDO2FBQVdJO2FBQVc1QzthQUFNdUI7O2NBTzlDLFlBQ1c7a0JBQ0hyRjtjQUFLLE9BQUEsV0FUd0N3SSxXQVM3Q3hJO2FBQWlCO2FBVHNDeUk7R0FVbkQ7WUFHWks7SUFDRDlFO0lBQ0FzQztJQUNBSTtJQUNBNUM7SUFDQXVCO0lBQ0R1RDtJQUNBSDtJQUVBLE9BeENFRTthQWdDRDNFO2FBQ0FzQzthQUNBSTthQUNBNUM7YUFDQXVCOztjQVVDLFlBQ1c7a0JBQ0hyRjtjQUFLLE9BQUEsV0FYZjRJLG9CQVdVNUk7YUFBMEI7YUFWcEN5STtHQVdjO0dBNURBO0lBQUEsZUFDWkYsT0FVQUksWUFrQkFFLFdBYUFDO0lBc0JXLGNBbEliN0IsUUFyQkFKOzs7Ozs7OztPQTdESm5GO09BeURJd0I7T0FKQTBEO09BbEJBUjtPQXpCQWpCO09BR0FHO09BVEF0QjtPQU9BcUI7T0FMQXZCO09BZ0JBeUI7T0F3Q0F3QjtPQUNBQzs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQzNERixTQUFBK0IsUUFBQUMsT0FBQUM7SUFBQSxHQUFBRCxVQUFBQyxPQUFBO2NBQUFEO1VBQUFBO01BQUEsVUFBQUMsd0JBQUFBLE9BQ0U7TUFBQTs7ZUFERkEsb0JBRUU7UUFGRkEsT0FFRTs7O1NBQ0FDLFFBSEZGLFVBR0VHLFFBSEZIO2VBQUFDO01BR21CO09BQWpCRyxRQUhGSDtPQUdFSSxRQUhGSjs7a0JBR1lLLE9BQUFDO1VBQUEsT0FBQSw4QkFBQUQsT0FBQUM7U0FBTTtPQUFDQyxJQUFBLDJCQUFqQkwsT0FBQUU7bUJBQWlCRyxJQUFPLDJCQUF4Qk4sT0FBQUUsU0FBaUJJOztRQUhuQlAsT0FFRTs7SUFEQTtHQUcyQjtZQUo3QnZIO0lBQUE7SUFHRTtLQUFBK0g7S0FBQUM7S0FBQUMsV0FBQSx5Q0FBQUQ7S0FBQUUsV0FBQSwyQkFBQUg7SUFBQSx3QkFBQUUsY0FBQUM7R0FDMkI7R0FQaEIsZ0JBR2JiLFNBQUFySDs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDSkZBO0lBQUE7S0FHSW1JO0tBREFDO0tBREFDO0tBRUFDLFVBQUEsc0JBQUFIO0tBSEpJLGdDQUdJRDtLQURBRSxVQUFBLHNCQUFBSjtLQUZKSyxrQ0FFSUQsZUFGSkQ7O0tBQ0lHLFVBQUEsMkJBQUFMO0tBREpNLGtDQUNJRCxlQURKRDtJQUFBLFdBQUFFO0dBSzZCO1lBRXpCbkgsT0FBUW9ILE1BQU1DO0lBQ2hCO0tBQzJDLGFBQVU7S0FEakRwRCxPQUNGLDJCQUZRbUQsTUFBTUM7SUFJaEIsV0FISXBELE1BRE1tRCxNQUFNQztHQUlJO1lBR2xCQyxpQkFBaUJwRixHQUFHcUYsT0FBa0JDLEtBQUtDO0lBQ2xDO0tBQVBDO3lDQURleEYsTUFBcUJzRixTQUFBQSxNQUFLQyxTQUFBQTs7O2VBQ3pDQyxxQkFBQUE7ZUFEa0JILHNCQUFBQTtlQUFBQTs7SUFFdEIsa0NBRm1CckYsTUFBcUJzRixTQUFBQSxNQUFLQyxTQUFBQTtJQUU3QztHQUkwQjtZQUd4QkUsTUFBTXpGLEdBQUVxRixPQUFPQztJQUNqQixVQURRdEYsY0FDUjs7U0FBQXVGOztNQVZFSCxpQkFTTXBGLEdBQUVxRixPQUFPQyxLQUNqQkM7TUFDRSxVQURGQTtpQkFBQUE7VUFBQUE7Ozs7R0FFSTtZQUdGRyxNQUFNMUYsR0FBRXFGLE9BQU9FO0lBQ2pCLFVBRFF2RixjQUNSOztTQUFBc0Y7O01BaEJFRixpQkFlTXBGLEdBQUVxRixPQUNWQyxLQURpQkM7TUFFZixVQURGRDtpQkFBQUE7VUFBQUE7Ozs7R0FFSTtZQUdGSyxPQUFLM0YsR0FBRTRGLE1BQUtELFFBQU1MLEtBQUtDO0lBQU0sa0NBQXhCdkYsTUFBYXNGLFNBQUFBLE1BQUtDLFNBQUFBLFdBQWhCSyxNQUFLRDtJQUFpQjtHQUF1QztZQUVwRUUsT0FBTzdGLEdBQUVwQixPQUFNZ0gsTUFBS0UsTUFBTVIsS0FBS0MsS0FBS2xMO0lBQ3RDLElBQ004RDtJQUtKLE9BUFNTOztXQUNQbUgsUUFENkJSOzs7UUFDN0JRLFNBRDZCUixNQUFLbEwsYUFTWCxXQVByQjhELHNCQUZnQjJIOzs7O2NBQWdCekwsUUFVRixXQVI5QjhELHNCQUZnQjJIO1FBQ2xCQyxRQUQ2QlIsT0FVWjs7aUJBRVVTLEdBQUVuTCxPQUFTLE9BZHhDOEssT0FFTzNGLEdBQVE0RixNQVlnQi9LLE9BWkx5SyxLQUN4QlMsUUFXMkJDLE9BQWdEO0lBQXJELE9BQUEsaUNBWkpGO0dBWTBEO1lBa0I5RUcsT0FBT2pHLEdBQUdrRyxNQUFNQyxRQUFRQztJQUMxQixJQUFJNUksTUFBTSxrQ0FDTjZJO2FBQ0FDLFlBQVlWO0tBQ2QsYUFBeUNXLE9BQUFDO01BQUEsT0FBQSw4QkFBQUQsT0FBQUM7S0FBTTtLQUFwQztNQUNjQyxRQURkLDBCQURHYjtNQUVXYyxRQUh2Qkw7a0JBR3VCTSxPQUFBQztNQUFBLE9BQUEsOEJBQUFELE9BQUFDO0tBQU07cUJBQUMsMkJBQVBILE9BQUFDOztNQUVwQixVQUFBLDRCQU5IbEo7TUFNRyxHQUFBO09BQTJCLFdBUGhCMkksUUFFZEUsaUJBREE3STtNQUNBNkksa0JBR3VCSTs7O0lBR0Y7Y0FSaEJ6Rzs7U0FVVHNGOztNQUNFLFVBWE90RixjQVdQOztXQUFBdUY7O1FBQ1E7OzZDQVpEdkYsTUFVVHNGLFNBQUFBLE1BQ0VDO2lCQUFBQTs7O1VBS2EsNEJBZlgvSDs7VUFFQThJO1VBakJNLFVBQUEscUJBd0JWaEI7VUF4QlU7V0FBcUM7a0JBd0IvQ0E7WUF4QnNDdUI7Z0RBYzdCN0cscUJBV1B1RjtvQkFBQUE7d0JBekJvQyxxQkFBQXNCO1lBQWxDL0o7O2VBQUFBO1VBRUYsVUFBQSxxQkFzQkZ3SSxLQVZTdEY7VUFaUDtXQUE4QztrQkFzQmhEc0Y7WUF0QnVDd0I7Z0RBWTlCOUcscUJBV1B1RjtvQkFBQUE7d0JBdkJxQyxxQkFBQXVCO1lBRG5DL0o7O2VBQUFBO1VBR08sVUFBQSxxQkFxQlR3STtVQXJCUztXQUFxQztrQkFxQjlDQTtZQXJCcUN3QjtnREFVOUIvRyxNQVVUc0YsU0FBQUE7O3dCQXBCdUMscUJBQUF5QjtZQUFuQy9KOztlQUFBQTtVQUNRLFVBQUEscUJBb0JWdUksS0FYT3ZGO1VBVEc7V0FBOEM7a0JBb0J4RHVGO1lBcEIrQ3lCO2dEQVN4Q2hILE1BVVRzRixTQUFBQTs7d0JBbkJpRCxxQkFBQTBCO1lBQTdDL0o7O2VBQUFBO1VBS0s7V0FBQSxNQUFBLDRCQUxMQTtXQUlJLE1BQUEsNEJBTEpEO1dBSU0sTUFBQSw0QkFQTkQ7V0FNRyxNQUFBLDRCQVBIRDtXQU1KO2FBQUE7O1VBMkJNLGtEQWxCRlUsS0FEUTBJOzs7YUFhTXJMLGtCQUFOK0s7U0FWUlUsWUFVUVY7U0FFTix3QkFkRnBJLEtBWWMzQzs7UUFGaEIsVUFBQTBLO21CQUFBQTtZQUFBQTs7O01BUkVlO01BbUJGLDRCQXJCRTlJO01BcUJGLFVBWkY4SDtpQkFBQUE7VUFBQUE7OztJQWNBLFdBeEJrQmEsUUFFZEUsaUJBREE3STtJQXVCSixPQUFBLFdBeEIwQjRJLE9BQ3RCNUk7R0F3Qks7WUFHUDRGLFVBQVVwRCxHQUFHa0csTUFBTWU7SUFDWCxJQUFOekosTUFBTTtJQUNWLG9CQU1tQixPQU5uQiwyQkFESUEsS0FPa0M7SUFBN0IsT0FwQ1B5STthQTRCVWpHO2FBQUdrRztzQkFLQU4sTUFBS3NCO2NBQ007O2lCQUFBO21CQU5MRCxrQkFLTnJCLE1BQ2tDLDJCQUQ3QnNCO2NBQ2hCLDRCQUxBMUo7Y0FLQSxPQUFBLDRCQURnQjBKO2FBRUM7O0dBQ2tCOzs7Ozs7O1VBdkd6QzVLLFdBK0ZJOEcsV0E1QkE2QyxRQTlCQUosUUFGQUYsUUE1QkE3SCxRQWdCQTJILE9BTUFDOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7OztHQzNCRjtJQUFBL0I7Ozs7Ozs7O1lBQUFySDtJQUFBOztPQUNFOztPQUNBOztPQUNBOztPQUNBO2VBQ0E7O0dBQzJCO0dBUGQsa0JBQ2ZxSCxTQUFBckg7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDRkZBO0lBQUE7S0FNSTZLO0tBREFDO0tBREFDO0tBREFDO0tBREFDO0tBREFDO0tBS0E1QyxVQUFBLHVCQUFBdUM7S0FOSnpLLGdDQU1Ja0k7S0FEQUUsVUFBQSxzQkFBQXNDO0tBTEp4SyxrQ0FLSWtJLGVBTEpwSTtLQUlJc0k7T0FBQSw0REFBQXFDO0tBSkpJLGtDQUlJekMsZUFKSnBJO0tBR0k4SyxVQUFBLGlDQUFBSjtLQUhKSyxrQ0FHSUQsZUFISkQ7S0FFSWhMLFVBQUEsaUNBQUE4SztLQUZKSyxrQ0FFSW5MLGVBRkprTDs7S0FDSWhMLFVBQUEsNEJBQUE2SztLQURKSyxrQ0FDSWxMLGVBREppTDtJQUFBLFdBQUFDO0dBUW9CO1lBRWhCL0o7SUFDRnFIO0lBQ0EyQztJQUNDQztJQUNBeEo7SUFDWXlKO0lBQ1oxRztJQUNBVTtJQUNBMUg7aUJBRzJCb0g7S0FBUzt5Qiw4QkFBVEE7S0FBMEIsT0FBQSwwQkFWdER5RDtJQVVxRjtJQUFuRixJQURFOEMsT0FDRiwwQkFURkgsZ0JBU0U7aUJBTTRCdEosVUFBUzBKO0tBQVcsT0FBcEIxSjtzREFBUzBKO2VBQVQxSjtJQUFxRDs7O0tBQTVFLHNCQUFrQixPQUFBOzt3QkFEYSxTQUFJO0lBQWhDO0tBQUEsTUFBQSwwQkFmVjJHO0tBWUlnRCxRQUNGLDBCQUpFRjtJQVNKLGFBQ21DRyxRQUFPNUo7S0FDaEMsWUFBQSx5Q0FEeUI0Sjs2REFBTzVKO0lBSVA7SUFKakMsSUFERTZKLE9BQ0YsMEJBbkJGbEQsTUFZSWdEO0lBYUosU0FBSUcsT0FBT3RNO0tBQW9CLFVBQUEsMEJBUDNCcU0sTUFPT3JNO0tBQW9CLE9BQUE7SUFBd0M7SUFDNUQ7S0FBUHVNLFNBREFELE9BekJKbkQ7S0EyQklxRCxTQUFPLDBCQWxCUFAsTUFnQkFLO0tBS0FHO09BQVM7O1NBSlRGO1NBekJKVDtTQUtDOUY7U0FEQVY7aUJBMkJ1QjhHO0tBQXNCOztnQkE1QmpDSixRQTRCMkMseUNBQWhDSTtLQUFzQixPQUFBO0lBQWdDO0lBQTVFO0tBREVNLGdCQUNGLDBCQU5FSCxjQUNBQztpQkFRa0IsdUJBakNyQlQ7SUFpQ0k7S0FDRTtNQUFBLHNCQUFnQyxTQUFDO01BRnBDWSxVQUVHLDBCQUxIRDs7OztpQkFPMkJwRDtTQUN6QjtVQUE2QixNQUFBLDBCQURKQTtVQUNqQixNQUFBLDBCQVRWbUQ7U0FTUyxLQUFBO1VBQVAsTUFBQTtzQkFDaUNwTyxPQUFNNk47VUFDckM7O21CQURxQ0E7bUJBckM1QzNKO21CQXFDc0NsRTttQkFqQ3RDQztTQWtDNkU7U0FEeEUsVUFBQSwwQkFWRm1PLFFBUTJCbkQ7MkI7U0FFekIsT0FBQTtRQUVvQjtNQVJ0QnFELFVBSUEsMEJBUEFEO0lBYVM7S0FBVEUsU0FBUywwQkFsQlRMO0lBbUJKLFdBZElHLFdBR0FDLFNBSkFGLFFBY0FHLFFBdENINUcsU0FKQStGO0dBMkM4RDtZQUc3RGMsVUFBVTdJLEdBQUcxRjtJQUNmO0tBQTZCLE1BQUEsMEJBRGpCMEY7S0FDSixNQUFBLDBCQURJQTtJQUNMLEtBQUE7S0FBUCxNQUFBO0lBQ2lCO0tBQWlCOEcsUUFGdEI5RztpQkFFc0IsdUJBQUE4RztLQUE5QmdDO2dCQUZROUk7SUFLb0Isa0I7SUFBckI7S0FBUG1GLE9BQU8seUNBTENuRjtlQUVSOEk7SUFJNkIsa0IsT0FKN0JBO0lBS1M7S0FEVDVEO1FBQU8seUNBTkNsRjtLQU9SK0ksU0FBUyx5Q0FEVDdELE1BREFDO0tBSWtCNEIsUUFUVi9HO2lCQVNVLHVCQUFBK0c7S0FEbEIxQjtJQUdKLHlDQUpJMEQsUUFDQTFEO0lBSUoseUNBTEkwRCxRQUNBMUQsT0FGQUg7UUFPcUI4QixRQWJiaEgsa0JBYWEsdUJBQUFnSDs7S0FFdkIseUNBUkUrQixRQUNBMUQ7OztpQkFTb0NFLEtBQUlsTDtTQUNyQyxJQUFJMEwsVUFENkJSLGVBQUlsTCxjQWpCaEMyRjtTQW1CTCx5Q0FaSCtJLFFBQ0ExRCxPQVVPVTtTQUNKLE9BRElBO1FBRUQ7S0FITCwwQkFqQk8vRjs7aUJBdUJ1Q3NGLEtBQUkwRCxjQUFhMUs7S0FDOUMsSUFBYjJLLGFBQWEscUJBRDZCM0Q7a0JBT2pDQyxLQUFJMkM7TUFBVDtPQUF5QnRKO09BQVB2RTtPQUNqQitEO1NBQVE7dUNBREE4SixTQUFTN04sT0E5QmhCQztPQWdDZTRPLFFBaENsQmxKO21CQWdDa0IsdUJBQUFrSjtNQUFqQjtVQURDOUs7a0JBQUFBLFVBS0d3SDtXQUxIeEg7YUFNT0Y7U0FDUDs7V0EvQlY2SztXQXVCa0NuSztXQU1yQmdIO1dBQ0kxSDtXQWQ4Qm9IO1dBT2pDQztXQUFhbEw7O2dCQUFia0wsTUFTWSx3QkFUQ2xMO2lCQUFia0wsTUFBYWxMOztjQVNqQjBMOztXQUN3QixVQUFBO1dBQXRCOzJDQWpDWmdELGdCQWdCK0N6RCxLQWdCckNTO1dBQ0UsVUFERkE7c0JBQUFBO2VBQUFBOzs7OzthQUhTb0Q7U0FBVzs7V0E3QjlCSjtXQXVCa0NuSztXQU1yQmdIO1dBQU11RDtXQWI0QjdEO1dBT2pDQztXQUFhbEw7Ozs7Ozs7bUJBY2tCaUw7V0FBTCxJQUFnQnBILGlCQUFOMEg7V0FDckM7O2FBdENibUQ7YUF1QmtDbks7YUFjZ0JnSDthQUFNMUg7YUFBWG9IO2FBZC9CQzthQUFhbEw7V0FlZCxPQURnQ2lMO1VBRXhCO09BRlYsMEJBYkRsSCxPQVJxQ2tIOztlQU9qQ0MsZ0JBOUJOdkYscUJBOEJtQjNGO0tBa0JhO0tBcEJsQyxjQTVCRTJGLFVBNEJGLE1BQUEsMkJBNUJFQSxNQUFBQTtLQTBCSiwwQkFIK0NnSjs7TUEyQjlDSSxRQTNCMEM5RCxNQUFpQmhIO01BNEIzQytLLFFBbkRicko7a0JBbURhLHVCQUFBcUo7bUJBM0JoQkosWUFnQ0MsT0FOREc7U0FHdUJFLFFBckRwQnRKLGtCQXFEb0IsdUJBQUFzSjtpQkFDcEIseUNBL0NSUCxXQTJDS0s7S0FJRyxPQUpIQTtJQU1JO0lBakNWLDBCQXZCU3BKLE1BQUFBO0lBMERaLE9BbkRJK0k7R0FtREU7Ozs7O3FDQXJIUnpNLFdBVUl3QixRQWlEQStLOzs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDdkNZO0lBTVY1QztJQUNBN0M7SUFQVSxhQU1WNkMsUUFDQTdDOzs7O0lBZEFtRztJQUNBQztJQUNBdEw7SUFDQXVMO0lBQ0FDO1lBYUZDLEtBQ0ExSSx5QkFLRDNHLHdCQUNENkssTUFDQXBEO0lBRUEsR0FURWQsU0FBVUcsTUFBVkgsUUFBQThHLFVBQVUzRyxjQUFWMkcsVUFsQkV3QjtJQTJCSixZQVJZbEksZ0JBQVZXLFVBQVVYLGdCQUFWVztJQVFGO1NBUG1CVCxnQkFBakJxSSxpQkFBaUJySTs7U0FBakJxSTtJQU9GLFlBTmdCQyxnQkFBZEMsY0FBY0QsZ0JBQWRDO0lBTUY7U0FMdUJDLGdCQUFyQnhMLHFCQUFxQndMOztTQUFyQnhMO0lBS0YsS0FIQTRHLE1BSVE7SUFHSDs7T0FBQTs7U0FQTEE7U0FDQXBEO1NBUEVnRztTQUlBeEo7U0FEQXVMO1NBREFGO1NBREE1SDtTQUlEMUg7SUFPQztZQUNFOytDQVJIQTtHQWlCOEM7WUFHN0MwUDtJQUNEakM7SUFDQS9GO0lBQ0E0SDtJQUNBckw7SUFDQzBDO0lBQ0ZrRTtJQUNBcEQ7SUFDQ21FO0lBRUQsR0FMRWpGO1NBQXlCRyxNQUF6QkgsUUFBQTNHLHlCQUF5QjhHOztTQUF6QjlHOztpQkFjOERzTCxNQUFNN0ssR0FBSyxPQUFMQSxFQUFNO3NCQUFqQixPQUFBLHFCQVgxRG1MO0lBRUQ7S0FBQTtPQXBDRXlEO1NBMkJENUI7U0FDQS9GO1NBQ0E0SDs7U0FDQXJMO1NBQ0NqRTtTQUNGNks7U0FDQXBEO0tBR0EsTUFBQTtJQUFBLE9BQUE7R0FVMkI7R0FHWjs7Ozs7Ozs7V0FsRVh3SCxXQUNBQyxVQUNBdEwsTUFDQXVMLE9BQ0FDOzs7Ozs7Ozs7Ozs7Ozs7T0FhRkM7T0EwQkFLOzs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIEFzY2lpX3RhYmxlX2tlcm5lbC5Bc2NpaV90YWJsZV9rZXJuZWxfaW50ZiAqKVxubW9kdWxlIEFzY2lpX3RhYmxlX2tlcm5lbF9pbnRmID0gQXNjaWlfdGFibGVfa2VybmVsX19Bc2NpaV90YWJsZV9rZXJuZWxfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBBc2NpaV90YWJsZV9rZXJuZWwuQ2VsbCAqKVxubW9kdWxlIENlbGwgPSBBc2NpaV90YWJsZV9rZXJuZWxfX0NlbGxcblxuKCoqIEBjYW5vbmljYWwgQXNjaWlfdGFibGVfa2VybmVsLkNlbGxfaW50ZiAqKVxubW9kdWxlIENlbGxfaW50ZiA9IEFzY2lpX3RhYmxlX2tlcm5lbF9fQ2VsbF9pbnRmXG5cbigqKiBAY2Fub25pY2FsIEFzY2lpX3RhYmxlX2tlcm5lbC5Db2x1bW4gKilcbm1vZHVsZSBDb2x1bW4gPSBBc2NpaV90YWJsZV9rZXJuZWxfX0NvbHVtblxuXG4oKiogQGNhbm9uaWNhbCBBc2NpaV90YWJsZV9rZXJuZWwuQ29sdW1uX2ludGYgKilcbm1vZHVsZSBDb2x1bW5faW50ZiA9IEFzY2lpX3RhYmxlX2tlcm5lbF9fQ29sdW1uX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQXNjaWlfdGFibGVfa2VybmVsLkdyaWQgKilcbm1vZHVsZSBHcmlkID0gQXNjaWlfdGFibGVfa2VybmVsX19HcmlkXG5cbigqKiBAY2Fub25pY2FsIEFzY2lpX3RhYmxlX2tlcm5lbC5HcmlkX2ludGYgKilcbm1vZHVsZSBHcmlkX2ludGYgPSBBc2NpaV90YWJsZV9rZXJuZWxfX0dyaWRfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBBc2NpaV90YWJsZV9rZXJuZWwuSW1wb3J0ICopXG5tb2R1bGUgSW1wb3J0ID0gQXNjaWlfdGFibGVfa2VybmVsX19JbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQXNjaWlfdGFibGVfa2VybmVsLlNjcmVlbiAqKVxubW9kdWxlIFNjcmVlbiA9IEFzY2lpX3RhYmxlX2tlcm5lbF9fU2NyZWVuXG5cbigqKiBAY2Fub25pY2FsIEFzY2lpX3RhYmxlX2tlcm5lbC5TY3JlZW5faW50ZiAqKVxubW9kdWxlIFNjcmVlbl9pbnRmID0gQXNjaWlfdGFibGVfa2VybmVsX19TY3JlZW5faW50ZlxuXG4oKiogQGNhbm9uaWNhbCBBc2NpaV90YWJsZV9rZXJuZWwuVGFibGVfY2hhciAqKVxubW9kdWxlIFRhYmxlX2NoYXIgPSBBc2NpaV90YWJsZV9rZXJuZWxfX1RhYmxlX2NoYXJcblxuKCoqIEBjYW5vbmljYWwgQXNjaWlfdGFibGVfa2VybmVsLlV0ZjhfdGV4dF9jaHVua3MgKilcbm1vZHVsZSBVdGY4X3RleHRfY2h1bmtzID0gQXNjaWlfdGFibGVfa2VybmVsX19VdGY4X3RleHRfY2h1bmtzXG5cbm1vZHVsZSBBc2NpaV90YWJsZV9rZXJuZWxfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwib3BlbiBDb3JlXG5cbmxldCBhc3N1bWVkX3dpZHRoX3Blcl91Y2hhciA9IDFcbmxldCBzcGFjZV91Y2hhciA9IFVjaGFyLm9mX3NjYWxhcl9leG4gKENoYXIudG9faW50ICcgJylcblxubGV0IGZvbGRfdXRmOF93aXRoX3N0YXJ0X3BvcyB0IH5pbml0IH5mID1cbiAgbGV0IHJlcXVpcmVfdWNoYXIgcG9zID0gZnVuY3Rpb25cbiAgICB8IGBNYWxmb3JtZWQgcyAtPiByYWlzZV9zIFslbWVzc2FnZSBcIk5vdCBVVEYtOFwiIH5fOihzIDogc3RyaW5nKSAocG9zIDogaW50KV1cbiAgICB8IGBVY2hhciB1Y2hhciAtPiB1Y2hhclxuICBpblxuICBVdXRmLlN0cmluZy5mb2xkX3V0Zl84XG4gICAgKGZ1biBpbml0IHBvcyB4IC0+IGYgaW5pdCBwb3MgKHJlcXVpcmVfdWNoYXIgcG9zIHgpKVxuICAgIGluaXRcbiAgICB0IFtAbm9udGFpbF1cbjs7XG5cbmxldCBvZl91dGY4IHV0ZjggfndpZHRoIH5wcmVmZXJfc3BsaXRfb25fc3BhY2VzID1cbiAgbGV0IHV0ZjggPSBTdHJpbmcuVXRmOC50b19zdHJpbmcgdXRmOCBpblxuICBtYXRjaCB1dGY4IHdpdGhcbiAgfCBcIlwiIC0+IFsgU3RyaW5nLlV0Zjgub2Zfc3RyaW5nIFwiXCIgXVxuICB8IF8gLT5cbiAgICBsZXQgdWNoYXJfZW5kc19iZWZvcmVfcG9zID1cbiAgICAgIFV1dGYuU3RyaW5nLmZvbGRfdXRmXzggKGZ1biBhY2Mgc3RhcnRfcG9zIF8gLT4gc3RhcnRfcG9zIDo6IGFjYykgW10gdXRmOFxuICAgICAgfD4gTGlzdC5jb25zIChTdHJpbmcubGVuZ3RoIHV0ZjgpXG4gICAgICB8PiBMaXN0LnJldlxuICAgICAgfD4gTGlzdC50bF9leG5cbiAgICBpblxuICAgICgqIFdlIGlkZW50aWZ5IHVjaGFycyBieSB0aGUgYnl0ZSBwb3NpdGlvbnMgYWZ0ZXIgdGhlaXIgbGFzdCBieXRlcyAqKVxuICAgIGxldCBjaHVua3MgPVxuICAgICAgbWF0Y2ggcHJlZmVyX3NwbGl0X29uX3NwYWNlcyB3aXRoXG4gICAgICB8IGZhbHNlIC0+XG4gICAgICAgIGFzc2VydCAoYXNzdW1lZF93aWR0aF9wZXJfdWNoYXIgPSAxKTtcbiAgICAgICAgdWNoYXJfZW5kc19iZWZvcmVfcG9zIHw+IExpc3QuY2h1bmtzX29mIH5sZW5ndGg6d2lkdGhcbiAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICBsZXQgZ2V0X251bV91Y2hhcnNfaW5fY2h1bmsgPVxuICAgICAgICAgIGxldCBlbmRzX29mX3NwYWNlcyA9XG4gICAgICAgICAgICBmb2xkX3V0Zjhfd2l0aF9zdGFydF9wb3MgdXRmOCB+aW5pdDpbXSB+ZjooZnVuIGFjYyBzdGFydF9wb3MgdWNoYXIgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggVWNoYXIuZXF1YWwgc3BhY2VfdWNoYXIgdWNoYXIgd2l0aFxuICAgICAgICAgICAgICB8IHRydWUgLT4gKHN0YXJ0X3BvcyArIGFzc3VtZWRfd2lkdGhfcGVyX3VjaGFyKSA6OiBhY2NcbiAgICAgICAgICAgICAgfCBmYWxzZSAtPiBhY2MpXG4gICAgICAgICAgICB8PiBTZXQub2ZfbGlzdCAobW9kdWxlIEludClcbiAgICAgICAgICBpblxuICAgICAgICAgIGZ1biB1Y2hhcnNfbGVmdCAtPlxuICAgICAgICAgICAgTGlzdC50YWtlIHVjaGFyc19sZWZ0IHdpZHRoXG4gICAgICAgICAgICB8PiBMaXN0LnJldlxuICAgICAgICAgICAgfD4gTGlzdC5maW5kaSB+ZjooZnVuIF8gcG9zIC0+IFNldC5tZW0gZW5kc19vZl9zcGFjZXMgcG9zKVxuICAgICAgICAgICAgfD4gT3B0aW9uLm1hcCB+ZjooZnVuICh1Y2hhcnNfYWZ0ZXJfbGFzdF9zcGFjZSwgXykgLT5cbiAgICAgICAgICAgICAgICAgd2lkdGggLSB1Y2hhcnNfYWZ0ZXJfbGFzdF9zcGFjZSlcbiAgICAgICAgICAgIHw+IE9wdGlvbi52YWx1ZSB+ZGVmYXVsdDp3aWR0aFxuICAgICAgICBpblxuICAgICAgICBsZXQgcmVjIGNodW5rc19zcGxpdF9vbl9zcGFjZXMgY2h1bmtzIG51bV91Y2hhcnNfbGVmdCA9IGZ1bmN0aW9uXG4gICAgICAgICAgfCBbXSAtPiBMaXN0LnJldiBjaHVua3NcbiAgICAgICAgICB8IF8gOjogXyBhcyB1Y2hhcnNfbGVmdCAtPlxuICAgICAgICAgICAgKG1hdGNoIG51bV91Y2hhcnNfbGVmdCAqIGFzc3VtZWRfd2lkdGhfcGVyX3VjaGFyIDw9IHdpZHRoIHdpdGhcbiAgICAgICAgICAgICB8IHRydWUgLT4gY2h1bmtzX3NwbGl0X29uX3NwYWNlcyAodWNoYXJzX2xlZnQgOjogY2h1bmtzKSAwIFtdXG4gICAgICAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgICAgICAgbGV0IG51bV91Y2hhcnNfaW5fY2h1bmsgPSBnZXRfbnVtX3VjaGFyc19pbl9jaHVuayB1Y2hhcnNfbGVmdCBpblxuICAgICAgICAgICAgICAgbGV0IGNodW5rLCByZXN0ID0gTGlzdC5zcGxpdF9uIHVjaGFyc19sZWZ0IG51bV91Y2hhcnNfaW5fY2h1bmsgaW5cbiAgICAgICAgICAgICAgIGxldCBudW1fdWNoYXJzX2xlZnQgPSBudW1fdWNoYXJzX2xlZnQgLSBudW1fdWNoYXJzX2luX2NodW5rIGluXG4gICAgICAgICAgICAgICBjaHVua3Nfc3BsaXRfb25fc3BhY2VzIChjaHVuayA6OiBjaHVua3MpIG51bV91Y2hhcnNfbGVmdCByZXN0KVxuICAgICAgICBpblxuICAgICAgICBsZXQgbnVtX3VjaGFycyA9IExpc3QubGVuZ3RoIHVjaGFyX2VuZHNfYmVmb3JlX3BvcyBpblxuICAgICAgICBjaHVua3Nfc3BsaXRfb25fc3BhY2VzIFtdIG51bV91Y2hhcnMgdWNoYXJfZW5kc19iZWZvcmVfcG9zXG4gICAgaW5cbiAgICBsZXQgY2h1bmtfZW5kc19iZWZvcmVfcG9zID0gY2h1bmtzIHw+IExpc3QubWFwIH5mOkxpc3QubGFzdF9leG4gfD4gU2VxdWVuY2Uub2ZfbGlzdCBpblxuICAgIGNodW5rX2VuZHNfYmVmb3JlX3Bvc1xuICAgIHw+IFNlcXVlbmNlLnVuZm9sZF93aXRoIH5pbml0OjAgfmY6KGZ1biBzdGFydF9hdCBlbmRfYmVmb3JlIC0+XG4gICAgICAgICBZaWVsZFxuICAgICAgICAgICB7IHZhbHVlID1cbiAgICAgICAgICAgICAgIFN0cmluZy5zdWIgdXRmOCB+cG9zOnN0YXJ0X2F0IH5sZW46KGVuZF9iZWZvcmUgLSBzdGFydF9hdClcbiAgICAgICAgICAgICAgIHw+IFN0cmluZy5VdGY4Lm9mX3N0cmluZ1xuICAgICAgICAgICA7IHN0YXRlID0gZW5kX2JlZm9yZVxuICAgICAgICAgICB9KVxuICAgIHw+IFNlcXVlbmNlLnRvX2xpc3Rcbjs7XG4iLCJvcGVuISBDb3JlXG5tb2R1bGUgQXR0ciA9IEFuc2lfa2VybmVsLkF0dHJcblxubGV0IGxpc3Rfc3VtIGwgfmYgPSBMaXN0LnN1bSAobW9kdWxlIEludCkgbCB+ZlxubGV0IGxpc3RfbWF4IH5mIGxzdCA9IExpc3QuZm9sZCBsc3QgfmluaXQ6MCB+ZjooZnVuIGEgYiAtPiBtYXggYSAoZiBiKSlcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPVxuICB7IGFzY2lpIDogY2hhclxuICA7IHV0ZjggOiBzdHJpbmdcbiAgfVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGNvbm5lY3QgP3RvcCA/Ym90dG9tID9sZWZ0ID9yaWdodCAoKSA9XG4gIGxldCB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgPVxuICAgIGlzX3NvbWUgdG9wLCBpc19zb21lIGJvdHRvbSwgaXNfc29tZSBsZWZ0LCBpc19zb21lIHJpZ2h0XG4gIGluXG4gIGxldCBhc2NpaSwgdXRmOCA9XG4gICAgbWF0Y2ggdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSAtPiAnLScsIFwiXFwyMjZcXDE0OFxcMTI4XCJcbiAgICB8IHRydWUsIHRydWUsIGZhbHNlLCBmYWxzZSAtPiAnfCcsIFwiXFwyMjZcXDE0OFxcMTMwXCJcbiAgICB8IGZhbHNlLCB0cnVlLCBmYWxzZSwgdHJ1ZSAtPiAnfCcsIFwiXFwyMjZcXDE0OFxcMTQwXCJcbiAgICB8IGZhbHNlLCB0cnVlLCB0cnVlLCBmYWxzZSAtPiAnfCcsIFwiXFwyMjZcXDE0OFxcMTQ0XCJcbiAgICB8IHRydWUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSAtPiAnfCcsIFwiXFwyMjZcXDE0OFxcMTQ4XCJcbiAgICB8IHRydWUsIGZhbHNlLCB0cnVlLCBmYWxzZSAtPiAnfCcsIFwiXFwyMjZcXDE0OFxcMTUyXCJcbiAgICB8IHRydWUsIHRydWUsIGZhbHNlLCB0cnVlIC0+ICd8JywgXCJcXDIyNlxcMTQ4XFwxNTZcIlxuICAgIHwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UgLT4gJ3wnLCBcIlxcMjI2XFwxNDhcXDE2NFwiXG4gICAgfCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSAtPiAnLScsIFwiXFwyMjZcXDE0OFxcMTcyXCJcbiAgICB8IHRydWUsIGZhbHNlLCB0cnVlLCB0cnVlIC0+ICctJywgXCJcXDIyNlxcMTQ4XFwxODBcIlxuICAgIHwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSAtPiAnKycsIFwiXFwyMjZcXDE0OFxcMTg4XCJcbiAgICB8IGZhbHNlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UgLT4gJy0nLCBcIlxcMjI2XFwxNDlcXDE4MFwiXG4gICAgfCB0cnVlLCBmYWxzZSwgZmFsc2UsIGZhbHNlIC0+ICd8JywgXCJcXDIyNlxcMTQ5XFwxODFcIlxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgdHJ1ZSAtPiAnLScsIFwiXFwyMjZcXDE0OVxcMTgyXCJcbiAgICB8IGZhbHNlLCB0cnVlLCBmYWxzZSwgZmFsc2UgLT4gJ3wnLCBcIlxcMjI2XFwxNDlcXDE4M1wiXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSAtPiAnICcsIFwiIFwiXG4gIGluXG4gIHsgYXNjaWk7IHV0ZjggfVxuOztcblxubGV0IHRvX2J1ZmZlciB7IGFzY2lpOyB1dGY4IH0gYnVmID0gZnVuY3Rpb25cbiAgfCBgQXNjaWkgLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiBhc2NpaVxuICB8IGBVbmljb2RlIC0+IEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiB1dGY4XG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIENlbGxfaW50ZlxuXG50eXBlIHQgPSAoQXR0ci50IGxpc3QgKiBTdHJpbmcuVXRmOC50KSBsaXN0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBjcmVhdGUgZW50cmllcyA9XG4gIExpc3QuY29uY2F0X21hcCBlbnRyaWVzIH5mOihmdW4gKGF0dHJzLCBzdHIpIC0+XG4gICAgTGlzdC5tYXAgKFN0cmluZy5zcGxpdF9saW5lcyBzdHIpIH5mOihmdW4gbGluZSAtPiBhdHRycywgU3RyaW5nLlV0Zjgub2Zfc3RyaW5nIGxpbmUpKVxuOztcblxubGV0IGFwcHJveF9kaXNwbGF5X3dpZHRoID1cbiAgKCogU2VlIGRvY3MgZm9yIFtTdHJpbmcuVXRmOC5sZW5ndGhfaW5fdWNoYXJzXSBvbiB0aGUgbGltaXRhdGlvbnMgb2YgYXNzdW1pbmcgdGhhdCB0aGVcbiAgICAgd2lkdGggcGVyIHVjaGFyIGlzIDEuICopXG4gIFN0cmluZy5VdGY4Lmxlbmd0aF9pbl91Y2hhcnNcbjs7XG5cbmxldCB3aWR0aCBsaW5lcyA9IGxpc3RfbWF4IH5mOihmdW4gKF8sIGxpbmUpIC0+IGFwcHJveF9kaXNwbGF5X3dpZHRoIGxpbmUpIGxpbmVzXG5sZXQgbGluZXMgPSBGbi5pZFxuXG5sZXQgd3JhcF9saW5lcyBsaW5lcyB+d2lkdGggfnByZWZlcl9zcGxpdF9vbl9zcGFjZXMgPVxuICBMaXN0LmNvbmNhdF9tYXAgbGluZXMgfmY6KGZ1biAoYXR0cnMsIGxpbmUpIC0+XG4gICAgbGV0IGNodW5rcyA9IFV0ZjhfdGV4dF9jaHVua3Mub2ZfdXRmOCB+d2lkdGggfnByZWZlcl9zcGxpdF9vbl9zcGFjZXMgbGluZSBpblxuICAgIExpc3QubWFwIGNodW5rcyB+ZjooZnVuIGNodW5rIC0+IGF0dHJzLCBjaHVuaykpXG47O1xuXG5sZXQgaGVpZ2h0IGxpbmVzIH5kaXNwbGF5X2VtcHR5X3Jvd3MgfndpZHRoIH5wcmVmZXJfc3BsaXRfb25fc3BhY2VzID1cbiAgbGV0IGhlaWdodCA9IHdyYXBfbGluZXMgbGluZXMgfndpZHRoIH5wcmVmZXJfc3BsaXRfb25fc3BhY2VzIHw+IExpc3QubGVuZ3RoIGluXG4gIGlmIGRpc3BsYXlfZW1wdHlfcm93cyB0aGVuIG1heCBoZWlnaHQgMSBlbHNlIGhlaWdodFxuOztcblxubGV0IGlzX2VtcHR5IGxpbmVzID0gTGlzdC5mb3JfYWxsIGxpbmVzIH5mOihmdW4gKF8sIGxpbmUpIC0+IFN0cmluZy5VdGY4LmlzX2VtcHR5IGxpbmUpXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEFsaWduID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBMZWZ0XG4gICAgfCBSaWdodFxuICAgIHwgQ2VudGVyXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIFNob3cgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBZZXNcbiAgICB8IGBOb1xuICAgIHwgYElmX25vdF9lbXB0eVxuICAgIF1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDb2x1bW4gPSBzaWdcbiAgbW9kdWxlIEFsaWduID0gQWxpZ25cbiAgbW9kdWxlIFNob3cgPSBTaG93XG5cbiAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgKCoqIGNyZWF0ZXMgYSBjb2x1bW4gZ2l2ZW4gdGhlIGhlYWRlciBhbmQgdGhlIHRvLXN0cmluZyBmdW5jdGlvbiAqKVxuICB2YWwgY3JlYXRlXG4gICAgOiAgP2FsaWduOkFsaWduLnQgKCogRGVmYXVsdDogbGVmdCAqKVxuICAgIC0+ID9taW5fd2lkdGg6aW50XG4gICAgLT4gP21heF93aWR0aDppbnRcbiAgICAtPiA/c2hvdzpbIGBZZXMgfCBgTm8gfCBgSWZfbm90X2VtcHR5IF0gKCogRGVmYXVsdDogYFllcyAqKVxuICAgIC0+IHN0cmluZ1xuICAgIC0+ICgnYSAtPiBzdHJpbmcpXG4gICAgLT4gJ2EgdFxuXG4gICgqKiBsaWtlIGNyZWF0ZSwgZXhjZXB0IHRoYXQgdGhlIHRvX3N0cmluZyBmdW5jdGlvbiBtdXN0IHByb3ZpZGUgYSBsaXN0IG9mXG4gICAgICBhdHRyaWJ1dGVzLiAqKVxuICB2YWwgY3JlYXRlX2F0dHJcbiAgICA6ICA/YWxpZ246QWxpZ24udCAoKiBEZWZhdWx0OiBsZWZ0ICopXG4gICAgLT4gP21pbl93aWR0aDppbnRcbiAgICAtPiA/bWF4X3dpZHRoOmludFxuICAgIC0+ID9zaG93OlsgYFllcyB8IGBObyB8IGBJZl9ub3RfZW1wdHkgXSAoKiBEZWZhdWx0OiBgWWVzICopXG4gICAgLT4gc3RyaW5nXG4gICAgLT4gKCdhIC0+IEF0dHIudCBsaXN0ICogc3RyaW5nKVxuICAgIC0+ICdhIHRcblxuICAoKiogbGlrZSBjcmVhdGVfYXR0ciwgZXhjZXB0IHRoYXQgeW91IGNhbiBzcGVjaWZ5IG1hbnkgbGluZXMgd2l0aCBkaWZmZXJlbnRcbiAgICAgIGF0dHJpYnV0ZXMuICopXG4gIHZhbCBjcmVhdGVfYXR0cnNcbiAgICA6ICA/YWxpZ246QWxpZ24udCAoKiBEZWZhdWx0OiBsZWZ0ICopXG4gICAgLT4gP21pbl93aWR0aDppbnRcbiAgICAtPiA/bWF4X3dpZHRoOmludFxuICAgIC0+ID9zaG93OlsgYFllcyB8IGBObyB8IGBJZl9ub3RfZW1wdHkgXSAoKiBEZWZhdWx0OiBgWWVzICopXG4gICAgLT4gc3RyaW5nXG4gICAgLT4gKCdhIC0+IChBdHRyLnQgbGlzdCAqIHN0cmluZykgbGlzdClcbiAgICAtPiAnYSB0XG5cbiAgdmFsIGxpZnQgOiAnYSB0IC0+IGY6KCdiIC0+ICdhKSAtPiAnYiB0XG4gIHZhbCBvcHRpb25hbCA6ICdhIHQgLT4gJ2Egb3B0aW9uIHRcbiAgdmFsIGFsaWduIDogXyB0IC0+IEFsaWduLnRcbiAgdmFsIGhlYWRlciA6ICdhIHQgLT4gc3RyaW5nXG4gIHZhbCBzaG93IDogXyB0IC0+IFNob3cudFxuICB2YWwgdG9fZGF0YSA6ICdhIHQgLT4gJ2EgLT4gKEF0dHIudCBsaXN0ICogc3RyaW5nKSBsaXN0XG4gIHZhbCB1cGRhdGVfaGVhZGVyIDogZjooc3RyaW5nIC0+IHN0cmluZykgLT4gJ2EgdCAtPiAnYSB0XG4gIHZhbCB1cGRhdGVfc2hvdyA6IGY6KFNob3cudCAtPiBTaG93LnQpIC0+ICdhIHQgLT4gJ2EgdFxuXG4gIG1vZHVsZSBPZl9maWVsZCA6IHNpZ1xuICAgICgqKiBUaGlzIG1vZHVsZSBpcyB1c2VkIGZvciBjb25zdHJ1Y3RpbmcgbGlzdHMgb2YgWydhIHRdcyBmcm9tIGEgcmVjb3JkJ3MgZmllbGRzLiBUaGVcbiAgICAgICAgaW50ZW50aW9uIGlzIHRvIHVzZSBbRmllbGRzLnRvX2xpc3RdIHRvIG9idGFpbiBhIGxpc3QuICopXG5cbiAgICAoKiogQ3JlYXRlIGEgY29sdW1uIGJhc2VkIG9uIGEgZmllbGQgb2YgYSByZWNvcmQuICopXG4gICAgdmFsIGZpZWxkXG4gICAgICA6ICA/YWxpZ246QWxpZ24udCAoKiBEZWZhdWx0OiBsZWZ0ICopXG4gICAgICAtPiA/bWluX3dpZHRoOmludFxuICAgICAgLT4gP21heF93aWR0aDppbnRcbiAgICAgIC0+ID9zaG93OlsgYFllcyB8IGBObyB8IGBJZl9ub3RfZW1wdHkgXVxuICAgICAgLT4gP2hlYWRlcjpzdHJpbmcgKCoqIERlZmF1bHRzIHRvIGZpZWxkIG5hbWUgKilcbiAgICAgIC0+ICgnZmllbGQgLT4gc3RyaW5nKVxuICAgICAgLT4gKCdyZWNvcmQsICdmaWVsZCkgRmllbGQudFxuICAgICAgLT4gJ3JlY29yZCB0XG5cbiAgICAoKiogW2ZpZWxkX2F0dHJdIGlzIHRvIFtmaWVsZF0gYXMgW2NyZWF0ZV9hdHRyXSBpcyB0byBbY3JlYXRlXS4gKilcbiAgICB2YWwgZmllbGRfYXR0clxuICAgICAgOiAgP2FsaWduOkFsaWduLnQgKCogRGVmYXVsdDogbGVmdCAqKVxuICAgICAgLT4gP21pbl93aWR0aDppbnRcbiAgICAgIC0+ID9tYXhfd2lkdGg6aW50XG4gICAgICAtPiA/c2hvdzpbIGBZZXMgfCBgTm8gfCBgSWZfbm90X2VtcHR5IF1cbiAgICAgIC0+ID9oZWFkZXI6c3RyaW5nICgqKiBEZWZhdWx0cyB0byBmaWVsZCBuYW1lICopXG4gICAgICAtPiAoJ2ZpZWxkIC0+IEF0dHIudCBsaXN0ICogc3RyaW5nKVxuICAgICAgLT4gKCdyZWNvcmQsICdmaWVsZCkgRmllbGQudFxuICAgICAgLT4gJ3JlY29yZCB0XG5cbiAgICAoKiogTGlrZSBbZmllbGRdLCBidXQgZGVmYXVsdHMgdG8gW1wiXCJdIGlmIFtOb25lXSAqKVxuICAgIHZhbCBmaWVsZF9vcHRcbiAgICAgIDogID9hbGlnbjpBbGlnbi50ICgqIERlZmF1bHQ6IGxlZnQgKilcbiAgICAgIC0+ID9taW5fd2lkdGg6aW50XG4gICAgICAtPiA/bWF4X3dpZHRoOmludFxuICAgICAgLT4gP3Nob3c6WyBgWWVzIHwgYE5vIHwgYElmX25vdF9lbXB0eSBdXG4gICAgICAtPiA/aGVhZGVyOnN0cmluZyAoKiogRGVmYXVsdHMgdG8gZmllbGQgbmFtZSAqKVxuICAgICAgLT4gKCdmaWVsZCAtPiBzdHJpbmcpXG4gICAgICAtPiAoJ3JlY29yZCwgJ2ZpZWxkIG9wdGlvbikgRmllbGQudFxuICAgICAgLT4gJ3JlY29yZCB0XG5cbiAgICAoKiogTGlrZSBbZmllbGRfYXR0cl0sIGJ1dCBkZWZhdWx0cyB0byBbKFtdLCBcIlwiKV0gaWYgW05vbmVdICopXG4gICAgdmFsIGZpZWxkX29wdF9hdHRyXG4gICAgICA6ICA/YWxpZ246QWxpZ24udCAoKiBEZWZhdWx0OiBsZWZ0ICopXG4gICAgICAtPiA/bWluX3dpZHRoOmludFxuICAgICAgLT4gP21heF93aWR0aDppbnRcbiAgICAgIC0+ID9zaG93OlsgYFllcyB8IGBObyB8IGBJZl9ub3RfZW1wdHkgXVxuICAgICAgLT4gP2hlYWRlcjpzdHJpbmcgKCoqIERlZmF1bHRzIHRvIGZpZWxkIG5hbWUgKilcbiAgICAgIC0+ICgnZmllbGQgLT4gQXR0ci50IGxpc3QgKiBzdHJpbmcpXG4gICAgICAtPiAoJ3JlY29yZCwgJ2ZpZWxkIG9wdGlvbikgRmllbGQudFxuICAgICAgLT4gJ3JlY29yZCB0XG4gIGVuZFxuXG4gIG1vZHVsZSBQcml2YXRlIDogc2lnXG4gICAgKCoqIFtsYXlvdXQgdHMgdmFsdWVzIH5zcGFjaW5nIH5tYXhfd2lkdGggPSB3aWR0aHNdIHdoZXJlIHRoZSBudGggaW50IGluIFt3aWR0aHNdIGlzXG4gICAgICAgIHRoZSB3aWR0aCB0byB3aGljaCB0aGUgbnRoIGNvbHVtbiBpbiBbdHNdIHNob3VsZCB3cmFwIGl0cyBjb250ZW50cy5cblxuICAgICAgICBbc3BhY2luZ10gaXMgdGhlIG51bWJlciBvZiBzcGFjZXMgdG8gbGVhdmUgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGNvbnRlbnRzIG9mIGVhY2hcbiAgICAgICAgY2VsbC4gW2xheW91dF0gYWxzbyBsZWF2ZXMgYSBjaGFyYWN0ZXIgcGVyIGNvbHVtbiBmb3IgYSB2ZXJ0aWNhbCBzZXBhcmF0b3IuXG4gICAgICAgIFtsYXlvdXRdIHJhaXNlcyBpZiBhbGwgdGhpcyBjYW5ub3QgZml0IGludG8gW21heF93aWR0aF0uICopXG4gICAgdmFsIGxheW91dCA6ICdhIHQgbGlzdCAtPiAnYSBsaXN0IC0+IHNwYWNpbmc6aW50IC0+IG1heF93aWR0aDppbnQgLT4gaW50IGxpc3RcblxuICAgIHZhbCB0b19jZWxsIDogJ2EgdCAtPiB2YWx1ZTonYSAtPiBDZWxsLnRcbiAgZW5kXG5lbmRcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBDb2x1bW5faW50ZlxuXG50eXBlICdhIHQgPVxuICB7IG1heF93aWR0aCA6IGludFxuICA7IGhlYWRlciA6IFN0cmluZy5VdGY4LnRcbiAgOyBjb2xfZnVuYyA6ICdhIC0+IENlbGwudFxuICA7IGFsaWduIDogQWxpZ24udFxuICA7IG1pbl93aWR0aCA6IGludCBvcHRpb25cbiAgOyBzaG93IDogU2hvdy50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycywgc2V4cF9vZl1cblxubGV0IGxpZnQgdCB+ZiA9IHsgdCB3aXRoIGNvbF9mdW5jID0gKGZ1biB4IC0+IHQuY29sX2Z1bmMgKGYgeCkpIH1cbmxldCBoZWFkZXIgdCA9IFN0cmluZy5VdGY4LnRvX3N0cmluZyB0LmhlYWRlclxuXG5sZXQgb3B0aW9uYWwgdCA9XG4gIHsgdCB3aXRoXG4gICAgY29sX2Z1bmMgPVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgfCBOb25lIC0+IENlbGwuY3JlYXRlIFtdXG4gICAgICAgfCBTb21lIHggLT4gdC5jb2xfZnVuYyB4KVxuICB9XG47O1xuXG5sZXQgdG9fZGF0YSB0IGEgPVxuICBsZXQgdHVwbGVzID0gQ2VsbC5saW5lcyAodC5jb2xfZnVuYyBhKSBpblxuICBMaXN0Lm1hcCB0dXBsZXMgfmY6KGZ1biAoYXR0cnMsIGxpbmUpIC0+IGF0dHJzLCBTdHJpbmcuVXRmOC50b19zdHJpbmcgbGluZSlcbjs7XG5cbnR5cGUgY29uc3RyYWludHMgPVxuICB7IHRvdGFsX3dpZHRoIDogaW50XG4gIDsgbWluX3dpZHRocyA6IChTdHJpbmcuVXRmOC50ICogaW50KSBsaXN0XG4gIH1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmV4Y2VwdGlvbiBJbXBvc3NpYmxlX3RhYmxlX2NvbnN0cmFpbnRzIG9mIGNvbnN0cmFpbnRzIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBjcmVhdGVfYXR0cnNcbiAgPyhhbGlnbiA9IEFsaWduLkxlZnQpXG4gID9taW5fd2lkdGhcbiAgPyhtYXhfd2lkdGggPSA5MClcbiAgPyhzaG93ID0gYFllcylcbiAgc3RyXG4gIHBhcnNlX2Z1bmNcbiAgPVxuICB7IG1heF93aWR0aFxuICA7IGhlYWRlciA9IFN0cmluZy5VdGY4Lm9mX3N0cmluZyBzdHJcbiAgOyBjb2xfZnVuYyA9IChmdW4geCAtPiBDZWxsLmNyZWF0ZSAocGFyc2VfZnVuYyB4KSlcbiAgOyBhbGlnblxuICA7ICgqIFdlIGFkZCBvbmUgZm9yIHRoZSAnfCcgb24gdGhlIGxlZnQuICopXG4gICAgbWluX3dpZHRoID0gT3B0aW9uLm1hcCBtaW5fd2lkdGggfmY6KCggKyApIDEpXG4gIDsgc2hvd1xuICB9XG47O1xuXG5sZXQgY3JlYXRlX2F0dHIgP2FsaWduID9taW5fd2lkdGggP21heF93aWR0aCA/c2hvdyBzdHIgcGFyc2VfZnVuYyA9XG4gIGNyZWF0ZV9hdHRycyA/YWxpZ24gP21pbl93aWR0aCA/bWF4X3dpZHRoID9zaG93IHN0ciAoZnVuIHggLT4gWyBwYXJzZV9mdW5jIHggXSlcbjs7XG5cbmxldCBjcmVhdGUgP2FsaWduID9taW5fd2lkdGggP21heF93aWR0aCA/c2hvdyBzdHIgcGFyc2VfZnVuYyA9XG4gIGNyZWF0ZV9hdHRycyA/YWxpZ24gP21pbl93aWR0aCA/bWF4X3dpZHRoID9zaG93IHN0ciAoZnVuIHggLT4gWyBbXSwgcGFyc2VfZnVuYyB4IF0pXG47O1xuXG5sZXQgdG9fY2VsbCB0IH52YWx1ZSA9IHQuY29sX2Z1bmMgdmFsdWVcbmxldCB1cGRhdGVfaGVhZGVyIH5mIHQgPSB7IHQgd2l0aCBoZWFkZXIgPSBmIChoZWFkZXIgdCkgfD4gU3RyaW5nLlV0Zjgub2Zfc3RyaW5nIH1cbmxldCB1cGRhdGVfc2hvdyB+ZiB0ID0geyB0IHdpdGggc2hvdyA9IGYgdC5zaG93IH1cblxubGV0IGRlc2lyZWRfd2lkdGggfnNwYWNpbmcgZGF0YSB0ID1cbiAgbGV0IGNvbHVtbl9kYXRhID0gTGlzdC5tYXAgZGF0YSB+Zjp0LmNvbF9mdW5jIGluXG4gIGxldCBoZWFkZXJfd2lkdGggPVxuICAgICgqIFNlZSBkb2NzIGZvciBbU3RyaW5nLlV0ZjgubGVuZ3RoX2luX3VjaGFyc10gb24gdGhlIGxpbWl0YXRpb25zIG9mIGFzc3VtaW5nXG4gICAgICAgdGhhdCB0aGUgd2lkdGggcGVyIHVjaGFyIGlzIDEuICopXG4gICAgU3RyaW5nLlV0Zjguc3BsaXQgdC5oZWFkZXIgfm9uOihVY2hhci5vZl9jaGFyICdcXG4nKVxuICAgIHw+IGxpc3RfbWF4IH5mOlN0cmluZy5VdGY4Lmxlbmd0aF9pbl91Y2hhcnNcbiAgaW5cbiAgKCogV2UgbmVlZCB0byBhY2NvdW50IGZvciB0aGUgJ3wnIHRvIHRoZSBsZWZ0LCBzbyB3ZSBhZGQgMSBwbHVzIHRoZSBzcGFjaW5nXG4gICAgIG9uIGVpdGhlciBzaWRlLiAqKVxuICAxXG4gICsgKDIgKiBzcGFjaW5nKVxuICArIG1pblxuICAgICAgKHQubWF4X3dpZHRoIC0gKDIgKiBzcGFjaW5nKSlcbiAgICAgIChtYXggaGVhZGVyX3dpZHRoIChsaXN0X21heCBjb2x1bW5fZGF0YSB+ZjpDZWxsLndpZHRoKSlcbjs7XG5cbmxldCBsYXlvdXQgdHMgZGF0YSB+c3BhY2luZyB+bWF4X3dpZHRoOnRhYmxlX3dpZHRoID1cbiAgbGV0IGRlc2lyZWRfd2lkdGhzID0gTGlzdC5tYXAgdHMgfmY6KGRlc2lyZWRfd2lkdGggfnNwYWNpbmcgZGF0YSkgaW5cbiAgbGV0IGFsbF9taW5fd2lkdGggPSBMaXN0LmZpbHRlcl9tYXAgdHMgfmY6KGZ1biB0IC0+IHQubWluX3dpZHRoKSBpblxuICAoKiBbZ2VuZXJpY19taW5fY2hhcnNdID0gbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBmb3IgYSBjb2x1bW4gdGhhdCBkb2Vzbid0IGhhdmVcbiAgICAgYW4gW21pbl93aWR0aF0gdmFsdWUuICopXG4gIGxldCB0YWJsZV9jb25zdHJhaW50c19hcmVfaW1wb3NzaWJsZSwgZ2VuZXJpY19taW5fY2hhcnMgPVxuICAgIGxldCBjb2x1bW5zX3dpdGhfbm9fbWluX3dpZHRoID0gTGlzdC5sZW5ndGggdHMgLSBMaXN0Lmxlbmd0aCBhbGxfbWluX3dpZHRoIGluXG4gICAgaWYgSW50LiggPD4gKSAwIGNvbHVtbnNfd2l0aF9ub19taW5fd2lkdGggKCogbmVlZCB0byBhdm9pZCBhIGRpdmlkZS1ieS16ZXJvICopXG4gICAgdGhlbiAoXG4gICAgICBsZXQgd2lkdGggPSB0YWJsZV93aWR0aCAtIGxpc3Rfc3VtIGFsbF9taW5fd2lkdGggfmY6Rm4uaWQgaW5cbiAgICAgIGxldCBnZW5lcmljX21pbl9jaGFycyA9IHdpZHRoIC8gY29sdW1uc193aXRoX25vX21pbl93aWR0aCBpblxuICAgICAgbGV0IGltcG9zc2libGUgPSBnZW5lcmljX21pbl9jaGFycyA8IDEgKyAoMSArIChzcGFjaW5nICogMikpIGluXG4gICAgICBpbXBvc3NpYmxlLCBnZW5lcmljX21pbl9jaGFycylcbiAgICBlbHNlIChcbiAgICAgIGxldCBtaW5fdG90YWwgPSBMaXN0LmZvbGQgfmluaXQ6MCBhbGxfbWluX3dpZHRoIH5mOkludC4oICsgKSBpblxuICAgICAgbGV0IGV4dHJhX3Blcl9jb2wgPSAxICsgMSArIChzcGFjaW5nICogMikgaW5cbiAgICAgIGxldCBpbXBvc3NpYmxlID0gdGFibGVfd2lkdGggPCBtaW5fdG90YWwgKyAoTGlzdC5sZW5ndGggdHMgKiBleHRyYV9wZXJfY29sKSBpblxuICAgICAgKCogdGhlIHplcm8gaXMgYSBub25zZW5zZSB2YWx1ZSwgYnV0IHdlIG9ubHkgZ2VuZXJhdGUgaXQgd2hlbiBldmVyeSBjb2x1bW4gaGFzIGFcbiAgICAgICAgIG1pbiB3aWR0aCBhbmQgdGhlcmVmb3JlIHRoaXMgemVybyB3aWxsIG5ldmVyIGJlIHVzZWQuICopXG4gICAgICBpbXBvc3NpYmxlLCAwKVxuICBpblxuICBpZiB0YWJsZV9jb25zdHJhaW50c19hcmVfaW1wb3NzaWJsZVxuICB0aGVuXG4gICAgcmFpc2VcbiAgICAgIChJbXBvc3NpYmxlX3RhYmxlX2NvbnN0cmFpbnRzXG4gICAgICAgICB7IHRvdGFsX3dpZHRoID0gdGFibGVfd2lkdGggKyAxXG4gICAgICAgICA7IG1pbl93aWR0aHMgPVxuICAgICAgICAgICAgIExpc3QuZmlsdGVyX21hcCB0cyB+ZjooZnVuIHQgLT5cbiAgICAgICAgICAgICAgIE9wdGlvbi5tYXAgdC5taW5fd2lkdGggfmY6KGZ1biBtaW5fd2lkdGggLT4gdC5oZWFkZXIsIG1pbl93aWR0aCkpXG4gICAgICAgICB9KTtcbiAgbGV0IGxlZnQgPSByZWYgKGxpc3Rfc3VtIH5mOkZuLmlkIGRlc2lyZWRfd2lkdGhzIC0gdGFibGVfd2lkdGgpIGluXG4gIGxldCBzdG9wID0gcmVmIGZhbHNlIGluXG4gICgqIFRoaXMgbGF5b3V0IGFsZ29yaXRobSBsb29rcyB1bmJlYXJhYmx5IGluZWZmaWNpZW50LCBidXQgaXQnc1xuICAgICBzaW1wbGUgYW5kIHdvcmtzIHJlYXNvbmFibHkgd2VsbCBpbiB0aGUgY29tbW9uIGNhc2UuICopXG4gIGxldCByZWMgZGVjaWRlX3dpZHRocyBkZXNpcmVkX3dpZHRocyA9XG4gICAgaWYgIXN0b3BcbiAgICB0aGVuIGRlc2lyZWRfd2lkdGhzXG4gICAgZWxzZSAoXG4gICAgICBzdG9wIDo9IHRydWU7XG4gICAgICBhc3NlcnQgKExpc3QubGVuZ3RoIHRzID0gTGlzdC5sZW5ndGggZGVzaXJlZF93aWR0aHMpO1xuICAgICAgZGVjaWRlX3dpZHRoc1xuICAgICAgICAoTGlzdC5tYXAyX2V4biB0cyBkZXNpcmVkX3dpZHRocyB+ZjooZnVuIHQgY29sdW1uX3dpZHRoIC0+XG4gICAgICAgICAgIGxldCBtaW5fY2hhcnMgPVxuICAgICAgICAgICAgIG1hdGNoIHQubWluX3dpZHRoIHdpdGhcbiAgICAgICAgICAgICB8IFNvbWUgeCAtPiB4XG4gICAgICAgICAgICAgfCBOb25lIC0+IGdlbmVyaWNfbWluX2NoYXJzXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGxldCB3aWR0aCA9XG4gICAgICAgICAgICAgaWYgY29sdW1uX3dpZHRoIDw9IG1pbl9jaGFycyB8fCAhbGVmdCA8PSAwXG4gICAgICAgICAgICAgdGhlbiBjb2x1bW5fd2lkdGhcbiAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgIGxlZnQgOj0gIWxlZnQgLSAxO1xuICAgICAgICAgICAgICAgc3RvcCA6PSBmYWxzZTtcbiAgICAgICAgICAgICAgIGNvbHVtbl93aWR0aCAtIDEpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgICgqIFJlc3BlY3QgW21pbl93aWR0aF0sIGlmIHNwZWNpZmllZC4gKilcbiAgICAgICAgICAgbWF0Y2ggdC5taW5fd2lkdGggd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT4gd2lkdGhcbiAgICAgICAgICAgfCBTb21lIG1pbl93aWR0aCAtPiBtYXggd2lkdGggbWluX3dpZHRoKSkpXG4gIGluXG4gICgqIFRoZSB3aWR0aHMgdXNlZCBpbiBbbG9vcF0gaW5jbHVkZSB0aGUgJ3wnIHRvIHRoZSBsZWZ0IG9mIGVhY2ggZWxlbWVudCxcbiAgICAgd2hpY2ggaXNuJ3QgaW1wb3J0YW50IGFmdGVyIGxheW91dCwgc28gd2Ugc3VidHJhY3Qgb2ZmIDEgYW5kIHRoZSBzcGFjaW5nXG4gICAgIG9uIGVpdGhlciBzaWRlLiAqKVxuICBMaXN0Lm1hcCB+ZjooZnVuIHggLT4geCAtICgxICsgKHNwYWNpbmcgKiAyKSkpIChkZWNpZGVfd2lkdGhzIGRlc2lyZWRfd2lkdGhzKVxuOztcblxubW9kdWxlIE9mX2ZpZWxkID0gc3RydWN0XG4gIGxldCBmaWVsZCA/YWxpZ24gP21pbl93aWR0aCA/bWF4X3dpZHRoID9zaG93ID9oZWFkZXIgdG9fc3RyaW5nIHJlY29yZF9maWVsZCA9XG4gICAgY3JlYXRlXG4gICAgICA/YWxpZ25cbiAgICAgID9taW5fd2lkdGhcbiAgICAgID9tYXhfd2lkdGhcbiAgICAgID9zaG93XG4gICAgICAoT3B0aW9uLnZhbHVlIGhlYWRlciB+ZGVmYXVsdDooRmllbGQubmFtZSByZWNvcmRfZmllbGQpKVxuICAgICAgKGZ1biByZWNvcmQgLT4gdG9fc3RyaW5nIChGaWVsZC5nZXQgcmVjb3JkX2ZpZWxkIHJlY29yZCkpXG4gIDs7XG5cbiAgbGV0IGZpZWxkX2F0dHJcbiAgICA/YWxpZ25cbiAgICA/bWluX3dpZHRoXG4gICAgP21heF93aWR0aFxuICAgID9zaG93XG4gICAgP2hlYWRlclxuICAgIHRvX3N0cmluZ19hbmRfYXR0clxuICAgIHJlY29yZF9maWVsZFxuICAgID1cbiAgICBjcmVhdGVfYXR0clxuICAgICAgP2FsaWduXG4gICAgICA/bWluX3dpZHRoXG4gICAgICA/bWF4X3dpZHRoXG4gICAgICA/c2hvd1xuICAgICAgKE9wdGlvbi52YWx1ZSBoZWFkZXIgfmRlZmF1bHQ6KEZpZWxkLm5hbWUgcmVjb3JkX2ZpZWxkKSlcbiAgICAgIChmdW4gcmVjb3JkIC0+IHRvX3N0cmluZ19hbmRfYXR0ciAoRmllbGQuZ2V0IHJlY29yZF9maWVsZCByZWNvcmQpKVxuICA7O1xuXG4gIGxldCBmaWVsZF9vcHQgP2FsaWduID9taW5fd2lkdGggP21heF93aWR0aCA/c2hvdyA/aGVhZGVyIHRvX3N0cmluZyByZWNvcmRfZmllbGQgPVxuICAgIGZpZWxkXG4gICAgICA/YWxpZ25cbiAgICAgID9taW5fd2lkdGhcbiAgICAgID9tYXhfd2lkdGhcbiAgICAgID9zaG93XG4gICAgICA/aGVhZGVyXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICB8IE5vbmUgLT4gXCJcIlxuICAgICAgIHwgU29tZSB4IC0+IHRvX3N0cmluZyB4KVxuICAgICAgcmVjb3JkX2ZpZWxkXG4gIDs7XG5cbiAgbGV0IGZpZWxkX29wdF9hdHRyXG4gICAgP2FsaWduXG4gICAgP21pbl93aWR0aFxuICAgID9tYXhfd2lkdGhcbiAgICA/c2hvd1xuICAgID9oZWFkZXJcbiAgICB0b19zdHJpbmdfYW5kX2F0dHJcbiAgICByZWNvcmRfZmllbGRcbiAgICA9XG4gICAgZmllbGRfYXR0clxuICAgICAgP2FsaWduXG4gICAgICA/bWluX3dpZHRoXG4gICAgICA/bWF4X3dpZHRoXG4gICAgICA/c2hvd1xuICAgICAgP2hlYWRlclxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgfCBOb25lIC0+IFtdLCBcIlwiXG4gICAgICAgfCBTb21lIHggLT4gdG9fc3RyaW5nX2FuZF9hdHRyIHgpXG4gICAgICByZWNvcmRfZmllbGRcbiAgOztcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgbGF5b3V0ID0gbGF5b3V0XG4gIGxldCB0b19jZWxsID0gdG9fY2VsbFxuZW5kXG4iLCIoKiogQSBbU2NyZWVuXSBpcyB0d28tZGltZW5zaW9uYWwgZ3JpZCBvZiB0ZXh0IGVsZW1lbnRzIG9udG8gd2hpY2ggd2UgZHJhdyBpbXBlcmF0aXZlbHkuICopXG5cbm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVGV4ZWwgPSBzdHJ1Y3RcbiAgKCoqIEEgW3RleF10IFtlbF1lbWVudCAqKVxuXG4gIHR5cGUgdCA9XG4gICAgfCBMaW5lXG4gICAgfCBCbGFua1xuICAgIHwgQ2hhciBvZiBBdHRyLnQgbGlzdCAqIFVjaGFyLnRcbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cbmVuZFxuXG5tb2R1bGUgdHlwZSBTY3JlZW4gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdmFsIHRvX3N0cmluZ1xuICAgIDogIHRcbiAgICAtPiBiYXJzOlsgYEFzY2lpIHwgYFVuaWNvZGUgXVxuICAgIC0+IHN0cmluZ193aXRoX2F0dHI6KEF0dHIudCBsaXN0IC0+IHN0cmluZyAtPiBzdHJpbmcpXG4gICAgLT4gc3RyaW5nXG5cbiAgdmFsIHJlbmRlclxuICAgIDogIHRcbiAgICAtPiBiYXJzOlsgYEFzY2lpIHwgYFVuaWNvZGUgXVxuICAgIC0+IG91dHB1dDooQXR0ci50IGxpc3QgLT4gQnVmZmVyLnQgLT4gdW5pdClcbiAgICAtPiBjbG9zZTooQnVmZmVyLnQgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICBtb2R1bGUgVGV4ZWwgPSBUZXhlbFxuXG4gICgqKiBbc3RyaW5nIHQgYWxpZ24gYXR0ciBzIH5yb3cgfmNvbCB+d2lkdGhdIHdyaXRlcyBhIHJlZ2lvbiBvbmUgaGlnaCBhbmQgW3dpZHRoXVxuICAgICAgYWNyb3NzLCB3aG9zZSBsZWZ0IGNvcm5lciBpcyBhdCBbcm93LCBjb2xdLiBXaXRoaW4gdGhhdCByZWdpb24sIGl0IHBsYWNlcyBbc10gYXNcbiAgICAgIGRpcmVjdGVkIGJ5IFthbGlnbl0uICopXG4gIHZhbCBzdHJpbmdcbiAgICA6ICB0XG4gICAgLT4gQ29sdW1uLkFsaWduLnRcbiAgICAtPiBBdHRyLnQgbGlzdFxuICAgIC0+IFN0cmluZy5VdGY4LnRcbiAgICAtPiByb3c6aW50XG4gICAgLT4gY29sOmludFxuICAgIC0+IHdpZHRoOmludFxuICAgIC0+IHVuaXRcblxuICAoKiogW2NoYXIgdCBhdHRyIGMgfnJvdyB+Y29sXSB3cml0ZXMgW2NdIGF0IFtyb3csIGNvbF0uICopXG4gIHZhbCBjaGFyIDogdCAtPiBBdHRyLnQgbGlzdCAtPiBVY2hhci50IC0+IHJvdzppbnQgLT4gY29sOmludCAtPiB1bml0XG5cbiAgdmFsIGNyZWF0ZSA6IHJvd3M6aW50IC0+IGNvbHM6aW50IC0+IHRcblxuICAoKiogW2hsaW5lIHQgdGV4ZWwgfnJvd10gc2V0cyB0aGUgZW50aXJlIHdpZHRoIG9mIFtyb3ddIHRvIFt0ZXhlbF0gKilcbiAgdmFsIGhsaW5lIDogdCAtPiBUZXhlbC50IC0+IHJvdzppbnQgLT4gdW5pdFxuXG4gICgqKiBbdmxpbmUgdCB0ZXhlbCB+Y29sXSBzZXRzIHRoZSBlbnRpcmUgaGVpZ2h0IG9mIFtjb2xdIHRvIFt0ZXhlbF0gKilcbiAgdmFsIHZsaW5lIDogdCAtPiBUZXhlbC50IC0+IGNvbDppbnQgLT4gdW5pdFxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgU2NyZWVuX2ludGZcblxudHlwZSB0ID1cbiAgeyBkYXRhIDogVGV4ZWwudCBhcnJheSBhcnJheVxuICA7IHJvd3MgOiBpbnRcbiAgOyBjb2xzIDogaW50XG4gIH1cbltAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbmxldCBjcmVhdGUgfnJvd3MgfmNvbHMgPVxuICBsZXQgZGF0YSA9XG4gICAgQXJyYXkubWFrZV9tYXRyaXggfmRpbXg6cm93cyB+ZGlteTpjb2xzIChDaGFyIChbXSwgVWNoYXIub2ZfY2hhciAnICcpIDogVGV4ZWwudClcbiAgaW5cbiAgeyBkYXRhOyByb3dzOyBjb2xzIH1cbjs7XG5cbmxldCBzZXRfc2NyZWVuX3BvaW50IHQgKHRleGVsIDogVGV4ZWwudCkgfnJvdyB+Y29sID1cbiAgbGV0IHByZXYgPSB0LmRhdGEuKHJvdykuKGNvbCkgaW5cbiAgdC5kYXRhLihyb3cpLihjb2wpXG4gICAgPC0gKG1hdGNoIHByZXYsIHRleGVsIHdpdGhcbiAgICAgICAgfCBCbGFuaywgXyAtPiBCbGFua1xuICAgICAgICB8IF8sIEJsYW5rIC0+IEJsYW5rXG4gICAgICAgIHwgXywgcG9pbnQgLT4gcG9pbnQpXG47O1xuXG5sZXQgaGxpbmUgdCB0ZXhlbCB+cm93ID1cbiAgZm9yIGNvbCA9IDAgdG8gdC5jb2xzIC0gMSBkb1xuICAgIHNldF9zY3JlZW5fcG9pbnQgdCB0ZXhlbCB+cm93IH5jb2xcbiAgZG9uZVxuOztcblxubGV0IHZsaW5lIHQgdGV4ZWwgfmNvbCA9XG4gIGZvciByb3cgPSAwIHRvIHQucm93cyAtIDEgZG9cbiAgICBzZXRfc2NyZWVuX3BvaW50IHQgdGV4ZWwgfnJvdyB+Y29sXG4gIGRvbmVcbjs7XG5cbmxldCBjaGFyIHQgYXR0ciBjaGFyIH5yb3cgfmNvbCA9IHQuZGF0YS4ocm93KS4oY29sKSA8LSBDaGFyIChhdHRyLCBjaGFyKVxuXG5sZXQgc3RyaW5nIHQgYWxpZ24gYXR0ciB0ZXh0IH5yb3cgfmNvbCB+d2lkdGggPVxuICBsZXQgY29sID1cbiAgICBsZXQgYXBwcm94X2Rpc3BsYXlfd2lkdGggPVxuICAgICAgKCogU2VlIGRvY3MgZm9yIFtTdHJpbmcuVXRmOC5sZW5ndGhfaW5fdWNoYXJzXSBvbiB3aHkgaXQgaXMgYSBwb29yIHByb3h5IGZvciBkaXNwbGF5XG4gICAgICAgICB3aWR0aC4gKilcbiAgICAgIFN0cmluZy5VdGY4Lmxlbmd0aF9pbl91Y2hhcnNcbiAgICBpblxuICAgIG1hdGNoIChhbGlnbiA6IENvbHVtbi5BbGlnbi50KSB3aXRoXG4gICAgfCBMZWZ0IC0+IGNvbFxuICAgIHwgUmlnaHQgLT4gY29sICsgd2lkdGggLSBhcHByb3hfZGlzcGxheV93aWR0aCB0ZXh0XG4gICAgfCBDZW50ZXIgLT4gY29sICsgKG1heCAwICh3aWR0aCAtIGFwcHJveF9kaXNwbGF5X3dpZHRoIHRleHQpIC8gMilcbiAgaW5cbiAgU3RyaW5nLlV0ZjguaXRlcmkgdGV4dCB+ZjooZnVuIGkgdWNoYXIgLT4gY2hhciB0IGF0dHIgdWNoYXIgfnJvdyB+Y29sOihjb2wgKyBpKSlcbjs7XG5cbmxldCBnZXRfc3ltYm9sIHQgfnJvdyB+Y29sID1cbiAgbGV0IHRvcCA9IHJvdyA+IDAgJiYgWyVjb21wYXJlLmVxdWFsOiBUZXhlbC50XSB0LmRhdGEuKHJvdyAtIDEpLihjb2wpIExpbmUgaW5cbiAgbGV0IGJvdHRvbSA9XG4gICAgcm93IDwgdC5yb3dzIC0gMSAmJiBbJWNvbXBhcmUuZXF1YWw6IFRleGVsLnRdIHQuZGF0YS4ocm93ICsgMSkuKGNvbCkgTGluZVxuICBpblxuICBsZXQgbGVmdCA9IGNvbCA+IDAgJiYgWyVjb21wYXJlLmVxdWFsOiBUZXhlbC50XSB0LmRhdGEuKHJvdykuKGNvbCAtIDEpIExpbmUgaW5cbiAgbGV0IHJpZ2h0ID0gY29sIDwgdC5jb2xzIC0gMSAmJiBbJWNvbXBhcmUuZXF1YWw6IFRleGVsLnRdIHQuZGF0YS4ocm93KS4oY29sICsgMSkgTGluZSBpblxuICBUYWJsZV9jaGFyLmNvbm5lY3RcbiAgICA/dG9wOihPcHRpb24uc29tZV9pZiB0b3AgKCkpXG4gICAgP2JvdHRvbTooT3B0aW9uLnNvbWVfaWYgYm90dG9tICgpKVxuICAgID9sZWZ0OihPcHRpb24uc29tZV9pZiBsZWZ0ICgpKVxuICAgID9yaWdodDooT3B0aW9uLnNvbWVfaWYgcmlnaHQgKCkpXG4gICAgKClcbjs7XG5cbmxldCByZW5kZXIgdCB+YmFycyB+b3V0cHV0IH5jbG9zZSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDEwMjQgaW5cbiAgbGV0IGN1cnJlbnRfYXR0ciA9IHJlZiBbXSBpblxuICBsZXQgdXBkYXRlX2F0dHIgYXR0ciA9XG4gICAgbGV0IGF0dHIgPSBMaXN0LnNvcnQgfmNvbXBhcmU6WyVjb21wYXJlOiBBdHRyLnRdIGF0dHIgaW5cbiAgICBpZiBub3QgKFslY29tcGFyZS5lcXVhbDogQXR0ci50IGxpc3RdIGF0dHIgIWN1cnJlbnRfYXR0cilcbiAgICB0aGVuIChcbiAgICAgIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuIG91dHB1dCAhY3VycmVudF9hdHRyIGJ1ZjtcbiAgICAgIGN1cnJlbnRfYXR0ciA6PSBhdHRyKVxuICBpblxuICBmb3Igcm93ID0gMCB0byB0LnJvd3MgLSAxIGRvXG4gICAgZm9yIGNvbCA9IDAgdG8gdC5jb2xzIC0gMSBkb1xuICAgICAgbWF0Y2ggdC5kYXRhLihyb3cpLihjb2wpIHdpdGhcbiAgICAgIHwgQ2hhciAoYXR0ciwgdWNoYXIpIC0+XG4gICAgICAgIHVwZGF0ZV9hdHRyIGF0dHI7XG4gICAgICAgIFV1dGYuQnVmZmVyLmFkZF91dGZfOCBidWYgdWNoYXJcbiAgICAgIHwgQmxhbmsgLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnICdcbiAgICAgIHwgTGluZSAtPlxuICAgICAgICB1cGRhdGVfYXR0ciBbXTtcbiAgICAgICAgVGFibGVfY2hhci50b19idWZmZXIgKGdldF9zeW1ib2wgdCB+cm93IH5jb2wpIGJ1ZiBiYXJzXG4gICAgZG9uZTtcbiAgICB1cGRhdGVfYXR0ciBbXTtcbiAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXG4nXG4gIGRvbmU7XG4gIG91dHB1dCAhY3VycmVudF9hdHRyIGJ1ZjtcbiAgY2xvc2UgYnVmXG47O1xuXG5sZXQgdG9fc3RyaW5nIHQgfmJhcnMgfnN0cmluZ193aXRoX2F0dHIgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gIHJlbmRlclxuICAgIHRcbiAgICB+YmFyc1xuICAgIH5vdXRwdXQ6KGZ1biBhdHRyIGJ1ZicgLT5cbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoc3RyaW5nX3dpdGhfYXR0ciBhdHRyIChCdWZmZXIuY29udGVudHMgYnVmJykpO1xuICAgICAgQnVmZmVyLmNsZWFyIGJ1ZicpXG4gICAgfmNsb3NlOihmdW4gXyAtPiBCdWZmZXIuY29udGVudHMgYnVmKVxuOztcbiIsIigqKiBBIGdyaWQgbGF5cyBvdXQgY2VsbHMgd2l0aCBjb25jcmV0ZSBkaW1lbnNpb25zLiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIERpc3BsYXkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IFNob3J0X2JveFxuICAgIHwgVGFsbF9ib3hcbiAgICB8IExpbmVcbiAgICB8IEJsYW5rXG4gICAgfCBDb2x1bW5fdGl0bGVzXG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIHR5cGUgR3JpZCA9IHNpZ1xuICBtb2R1bGUgRGlzcGxheSA9IERpc3BsYXlcblxuICB0eXBlIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB2YWwgY3JlYXRlXG4gICAgOiAgJ2EgQ29sdW1uLnQgbGlzdFxuICAgIC0+ICdhIGxpc3RcbiAgICAtPiBkaXNwbGF5OkRpc3BsYXkudFxuICAgIC0+IGRpc3BsYXlfZW1wdHlfcm93czpib29sXG4gICAgLT4gaGVhZGVyX2F0dHI6QXR0ci50IGxpc3RcbiAgICAtPiBtYXhfd2lkdGg6aW50XG4gICAgLT4gc3BhY2luZzppbnRcbiAgICAtPiBwcmVmZXJfc3BsaXRfb25fc3BhY2VzOmJvb2xcbiAgICAtPiB0XG5cbiAgdmFsIHRvX3NjcmVlbiA6IHQgLT4gcHJlZmVyX3NwbGl0X29uX3NwYWNlczpib29sIC0+IFNjcmVlbi50XG5lbmRcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBHcmlkX2ludGZcblxudHlwZSB0ID1cbiAgeyBkYXRhIDogQ2VsbC50IGxpc3QgbGlzdFxuICA7IGhlaWdodHMgOiBpbnQgbGlzdFxuICA7IHdpZHRocyA6IGludCBsaXN0XG4gIDsgYWxpZ25zIDogQ29sdW1uLkFsaWduLnQgbGlzdFxuICA7IHNwYWNpbmcgOiBpbnRcbiAgOyBkaXNwbGF5IDogRGlzcGxheS50XG4gIH1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBjcmVhdGVcbiAgY29sc1xuICByYXdfZGF0YVxuICB+ZGlzcGxheVxuICB+ZGlzcGxheV9lbXB0eV9yb3dzXG4gIH5oZWFkZXJfYXR0cjpoX2F0dHJcbiAgfm1heF93aWR0aFxuICB+c3BhY2luZ1xuICB+cHJlZmVyX3NwbGl0X29uX3NwYWNlc1xuICA9XG4gIGxldCBib2R5ID1cbiAgICBMaXN0Lm1hcCByYXdfZGF0YSB+ZjooZnVuIHZhbHVlIC0+IExpc3QubWFwIGNvbHMgfmY6KENvbHVtbi5Qcml2YXRlLnRvX2NlbGwgfnZhbHVlKSlcbiAgaW5cbiAgbGV0IGVtcHR5ID1cbiAgICBMaXN0LmZvbGRcbiAgICAgIGJvZHlcbiAgICAgIH5pbml0OihMaXN0Lm1hcCBjb2xzIH5mOihmdW4gXyAtPiB0cnVlKSlcbiAgICAgIH5mOihMaXN0Lm1hcDJfZXhuIH5mOihmdW4gaXNfZW1wdHkgZWxlbWVudCAtPiBpc19lbXB0eSAmJiBDZWxsLmlzX2VtcHR5IGVsZW1lbnQpKVxuICBpblxuICBsZXQga2VlcCA9XG4gICAgTGlzdC5tYXAyX2V4biBjb2xzIGVtcHR5IH5mOihmdW4gY29sdW1uIGlzX2VtcHR5IC0+XG4gICAgICBtYXRjaCBDb2x1bW4uc2hvdyBjb2x1bW4gd2l0aFxuICAgICAgfCBgWWVzIC0+IHRydWVcbiAgICAgIHwgYE5vIC0+IGZhbHNlXG4gICAgICB8IGBJZl9ub3RfZW1wdHkgLT4gbm90IGlzX2VtcHR5KVxuICBpblxuICBsZXQgZmlsdGVyIGwgPSBMaXN0LmZpbHRlcl9vcHQgKExpc3QubWFwMl9leG4ga2VlcCBsIH5mOk9wdGlvbi5zb21lX2lmKSBpblxuICBsZXQgY29scyA9IGZpbHRlciBjb2xzIGluXG4gIGxldCBib2R5ID0gTGlzdC5tYXAgYm9keSB+ZjpmaWx0ZXIgaW5cbiAgKCogV2Ugc3VidHJhY3QgMSBmcm9tIG1heF93aWR0aCBiZWNhdXNlIGxhdGVyIHdlJ3JlIGdvaW5nIHRvIGFkZCBhIGxpbmUgb2ZcbiAgICAgJ3wncyB0byBmb3JtIHRoZSByaWdodCB3YWxsIG9mIHRoZSB0YWJsZS4gKilcbiAgbGV0IHdpZHRocyA9IENvbHVtbi5Qcml2YXRlLmxheW91dCBjb2xzIHJhd19kYXRhIH5zcGFjaW5nIH5tYXhfd2lkdGg6KG1heF93aWR0aCAtIDEpIGluXG4gIGxldCBncmlkX2RhdGEgPVxuICAgIExpc3QubWFwIGNvbHMgfmY6KGZ1biBjb2x1bW4gLT4gQ2VsbC5jcmVhdGUgWyBoX2F0dHIsIENvbHVtbi5oZWFkZXIgY29sdW1uIF0pIDo6IGJvZHlcbiAgaW5cbiAgbGV0IGhlaWdodHMgPVxuICAgIGlmIFslY29tcGFyZS5lcXVhbDogRGlzcGxheS50XSBkaXNwbGF5IExpbmVcbiAgICB0aGVuIExpc3QubWFwIGdyaWRfZGF0YSB+ZjooZnVuIF8gLT4gMSlcbiAgICBlbHNlXG4gICAgICBMaXN0Lm1hcCBncmlkX2RhdGEgfmY6KGZ1biByb3cgLT5cbiAgICAgICAgYXNzZXJ0IChMaXN0Lmxlbmd0aCB3aWR0aHMgPSBMaXN0Lmxlbmd0aCByb3cpO1xuICAgICAgICBMaXN0Lm1hcDJfZXhuIHdpZHRocyByb3cgfmY6KGZ1biB3aWR0aCBlbGVtZW50IC0+XG4gICAgICAgICAgQ2VsbC5oZWlnaHQgZWxlbWVudCB+ZGlzcGxheV9lbXB0eV9yb3dzIH53aWR0aCB+cHJlZmVyX3NwbGl0X29uX3NwYWNlcylcbiAgICAgICAgfD4gbGlzdF9tYXggfmY6Rm4uaWQpXG4gIGluXG4gIGxldCBhbGlnbnMgPSBMaXN0Lm1hcCBjb2xzIH5mOkNvbHVtbi5hbGlnbiBpblxuICB7IGRhdGEgPSBncmlkX2RhdGE7IGhlaWdodHM7IHdpZHRoczsgYWxpZ25zOyBzcGFjaW5nOyBkaXNwbGF5IH1cbjs7XG5cbmxldCB0b19zY3JlZW4gdCB+cHJlZmVyX3NwbGl0X29uX3NwYWNlcyA9XG4gIGFzc2VydCAoTGlzdC5sZW5ndGggdC5kYXRhID0gTGlzdC5sZW5ndGggdC5oZWlnaHRzKTtcbiAgbGV0IG1pZF9yb3cgPSBpZiBbJWNvbXBhcmUuZXF1YWw6IERpc3BsYXkudF0gdC5kaXNwbGF5IFRhbGxfYm94IHRoZW4gMSBlbHNlIDAgaW5cbiAgKCogVGhlIHRvdGFsIHdpZHRoIG9mIHRoZSB0YWJsZSBpbmNsdWRlcyB0aGUgJ3wncyB0byB0aGUgbGVmdCBvZiBlbGVtZW50cywgc28gd2UgYWRkIDFcbiAgICAgYW5kIHRoZSBzcGFjaW5nIG9uIGVpdGhlciBzaWRlIHdoZW4gc3VtbWluZy4gKilcbiAgbGV0IGNvbHMgPSBsaXN0X3N1bSB0LndpZHRocyB+ZjooKCArICkgKDEgKyAodC5zcGFjaW5nICogMikpKSArIDEgaW5cbiAgbGV0IHJvd3MgPSBsaXN0X3N1bSB0LmhlaWdodHMgfmY6KCggKyApIG1pZF9yb3cpICsgMyAtICgyICogbWlkX3JvdykgaW5cbiAgbGV0IHNjcmVlbiA9IFNjcmVlbi5jcmVhdGUgfnJvd3MgfmNvbHMgaW5cbiAgbGV0IHRleGVsIDogU2NyZWVuLlRleGVsLnQgPVxuICAgIGlmIFslY29tcGFyZS5lcXVhbDogRGlzcGxheS50XSB0LmRpc3BsYXkgQ29sdW1uX3RpdGxlcyB0aGVuIEJsYW5rIGVsc2UgTGluZVxuICBpblxuICBTY3JlZW4uaGxpbmUgc2NyZWVuIHRleGVsIH5yb3c6MDtcbiAgU2NyZWVuLmhsaW5lIHNjcmVlbiB0ZXhlbCB+cm93Oihyb3dzIC0gMSk7XG4gIGlmIG5vdCAoWyVjb21wYXJlLmVxdWFsOiBEaXNwbGF5LnRdIHQuZGlzcGxheSBCbGFuaylcbiAgdGhlbiAoXG4gICAgU2NyZWVuLnZsaW5lIHNjcmVlbiB0ZXhlbCB+Y29sOjA7XG4gICAgaWdub3JlXG4gICAgICAoTGlzdC5mb2xkIHQud2lkdGhzIH5pbml0OjAgfmY6KGZ1biBjb2wgd2lkdGggLT5cbiAgICAgICAgIGxldCBjb2wgPSBjb2wgKyAxICsgd2lkdGggKyAodC5zcGFjaW5nICogMikgaW5cbiAgICAgICAgIFNjcmVlbi52bGluZSBzY3JlZW4gdGV4ZWwgfmNvbDtcbiAgICAgICAgIGNvbClcbiAgICAgICAgOiBpbnQpKTtcbiAgaWdub3JlXG4gICAgKExpc3QuZm9sZDJfZXhuIHQuZGF0YSB0LmhlaWdodHMgfmluaXQ6MSB+ZjooZnVuIHJvdyByb3dfZWxlbWVudHMgaGVpZ2h0IC0+XG4gICAgICAgbGV0IGhlYWRlcl9yb3cgPSByb3cgPSAxIGluXG4gICAgICAgaWdub3JlXG4gICAgICAgICAoTGlzdC5mb2xkMl9leG5cbiAgICAgICAgICAgIHJvd19lbGVtZW50c1xuICAgICAgICAgICAgKExpc3QuemlwX2V4biB0LndpZHRocyB0LmFsaWducylcbiAgICAgICAgICAgIH5pbml0OigxICsgdC5zcGFjaW5nKVxuICAgICAgICAgICAgfmY6KGZ1biBjb2wgZWxlbWVudCAod2lkdGgsIGFsaWduKSAtPlxuICAgICAgICAgICAgbGV0IGxpbmVzID0gQ2VsbC53cmFwX2xpbmVzIGVsZW1lbnQgfndpZHRoIH5wcmVmZXJfc3BsaXRfb25fc3BhY2VzIGluXG4gICAgICAgICAgICBpZiBbJWNvbXBhcmUuZXF1YWw6IERpc3BsYXkudF0gdC5kaXNwbGF5IExpbmVcbiAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICBtYXRjaCBsaW5lcyB3aXRoXG4gICAgICAgICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgICAgICAgfCBbIChhdHRyLCBsaW5lKSBdIC0+IFNjcmVlbi5zdHJpbmcgc2NyZWVuIGFsaWduIGF0dHIgbGluZSB+cm93IH5jb2wgfndpZHRoXG4gICAgICAgICAgICAgIHwgKGF0dHIsIGxpbmUpIDo6IF8gLT5cbiAgICAgICAgICAgICAgICBTY3JlZW4uc3RyaW5nIHNjcmVlbiBhbGlnbiBhdHRyIGxpbmUgfnJvdyB+Y29sIH53aWR0aDtcbiAgICAgICAgICAgICAgICBmb3IgY29sID0gY29sICsgbWF4IDAgKHdpZHRoIC0gMykgdG8gY29sICsgd2lkdGggLSAxIGRvXG4gICAgICAgICAgICAgICAgICBTY3JlZW4uY2hhciBzY3JlZW4gW10gKFVjaGFyLm9mX2NoYXIgJy4nKSB+cm93IH5jb2xcbiAgICAgICAgICAgICAgICBkb25lKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAoTGlzdC5mb2xkIGxpbmVzIH5pbml0OnJvdyB+ZjooZnVuIHJvdyAoYXR0ciwgbGluZSkgLT5cbiAgICAgICAgICAgICAgICAgICBTY3JlZW4uc3RyaW5nIHNjcmVlbiBhbGlnbiBhdHRyIGxpbmUgfnJvdyB+Y29sIH53aWR0aDtcbiAgICAgICAgICAgICAgICAgICByb3cgKyAxKVxuICAgICAgICAgICAgICAgICAgOiBpbnQpO1xuICAgICAgICAgICAgY29sICsgMSArICh0LnNwYWNpbmcgKiAyKSArIHdpZHRoKVxuICAgICAgICAgICA6IGludCk7XG4gICAgICAgbGV0IHJvdyA9IHJvdyArIGhlaWdodCBpblxuICAgICAgIGlmIFslY29tcGFyZS5lcXVhbDogRGlzcGxheS50XSB0LmRpc3BsYXkgVGFsbF9ib3ggfHwgaGVhZGVyX3Jvd1xuICAgICAgIHRoZW4gKFxuICAgICAgICAgaWYgbm90IChbJWNvbXBhcmUuZXF1YWw6IERpc3BsYXkudF0gdC5kaXNwbGF5IEJsYW5rKVxuICAgICAgICAgdGhlbiBTY3JlZW4uaGxpbmUgc2NyZWVuIExpbmUgfnJvdztcbiAgICAgICAgIHJvdyArIDEpXG4gICAgICAgZWxzZSByb3cpXG4gICAgICA6IGludCk7XG4gIHNjcmVlblxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBBc2NpaV90YWJsZV9rZXJuZWxfaW50ZlxubW9kdWxlIEFsaWduID0gQ29sdW1uLkFsaWduXG5tb2R1bGUgQXR0ciA9IEF0dHJcbm1vZHVsZSBDb2x1bW4gPSBDb2x1bW5cbm1vZHVsZSBUYWJsZV9jaGFyID0gVGFibGVfY2hhclxuXG5tb2R1bGUgRGlzcGxheSA9IHN0cnVjdFxuICB0eXBlIHQgPSBHcmlkLkRpc3BsYXkudCA9XG4gICAgfCBTaG9ydF9ib3hcbiAgICB8IFRhbGxfYm94XG4gICAgfCBMaW5lXG4gICAgfCBCbGFua1xuICAgIHwgQ29sdW1uX3RpdGxlc1xuICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGxldCBzaG9ydF9ib3ggPSBTaG9ydF9ib3hcbiAgbGV0IHRhbGxfYm94ID0gVGFsbF9ib3hcbiAgbGV0IGxpbmUgPSBMaW5lXG4gIGxldCBibGFuayA9IEJsYW5rXG4gIGxldCBjb2x1bW5fdGl0bGVzID0gQ29sdW1uX3RpdGxlc1xuZW5kXG5cbm1vZHVsZSBTY3JlZW4gPSBzdHJ1Y3RcbiAgKCogW1NjcmVlbl0gaXMgbW9zdGx5IHByaXZhdGUgc3R1ZmYsIHNvIHdlIGV4cGxpY2l0bHkgZXhwb3J0IHRoZSBwdWJsaWMgYml0cyBpbnN0ZWFkIG9mXG4gICAgIHNheWluZyBbUHJpdmF0ZV0gZXZlcnl3aGVyZS4gKilcblxuICB0eXBlIHQgPSBTY3JlZW4udFxuXG4gIGxldCByZW5kZXIgPSBTY3JlZW4ucmVuZGVyXG4gIGxldCB0b19zdHJpbmcgPSBTY3JlZW4udG9fc3RyaW5nXG5lbmRcblxubGV0IGRyYXdcbiAgPyhkaXNwbGF5ID0gRGlzcGxheS5zaG9ydF9ib3gpXG4gID8oc3BhY2luZyA9IDEpXG4gID8obGltaXRfd2lkdGhfdG8gPSA5MClcbiAgPyhoZWFkZXJfYXR0ciA9IFtdKVxuICA/KGRpc3BsYXlfZW1wdHlfcm93cyA9IGZhbHNlKVxuICB+cHJlZmVyX3NwbGl0X29uX3NwYWNlc1xuICBjb2xzXG4gIGRhdGFcbiAgPVxuICBtYXRjaCBjb2xzIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgXyA6OiBfIC0+XG4gICAgU29tZVxuICAgICAgKEdyaWQuY3JlYXRlXG4gICAgICAgICB+c3BhY2luZ1xuICAgICAgICAgfmRpc3BsYXlcbiAgICAgICAgIH5tYXhfd2lkdGg6bGltaXRfd2lkdGhfdG9cbiAgICAgICAgIH5oZWFkZXJfYXR0clxuICAgICAgICAgY29sc1xuICAgICAgICAgZGF0YVxuICAgICAgICAgfmRpc3BsYXlfZW1wdHlfcm93c1xuICAgICAgICAgfnByZWZlcl9zcGxpdF9vbl9zcGFjZXNcbiAgICAgICB8PiBHcmlkLnRvX3NjcmVlbiB+cHJlZmVyX3NwbGl0X29uX3NwYWNlcylcbjs7XG5cbmxldCB0b19zdHJpbmdfbm9hdHRyXG4gID9kaXNwbGF5XG4gID9zcGFjaW5nXG4gID9saW1pdF93aWR0aF90b1xuICA/ZGlzcGxheV9lbXB0eV9yb3dzXG4gID8ocHJlZmVyX3NwbGl0X29uX3NwYWNlcyA9IGZhbHNlKVxuICBjb2xzXG4gIGRhdGFcbiAgfmJhcnNcbiAgPVxuICBkcmF3XG4gICAgP2Rpc3BsYXlcbiAgICA/c3BhY2luZ1xuICAgID9saW1pdF93aWR0aF90b1xuICAgID9kaXNwbGF5X2VtcHR5X3Jvd3NcbiAgICB+aGVhZGVyX2F0dHI6W11cbiAgICBjb2xzXG4gICAgZGF0YVxuICAgIH5wcmVmZXJfc3BsaXRfb25fc3BhY2VzXG4gIHw+IE9wdGlvbi5tYXAgfmY6KFNjcmVlbi50b19zdHJpbmcgfmJhcnMgfnN0cmluZ193aXRoX2F0dHI6KGZ1biBfYXR0ciBzIC0+IHMpKVxuICB8PiBPcHRpb24udmFsdWUgfmRlZmF1bHQ6XCJcIlxuOztcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFV0ZjhfdGV4dF9jaHVua3MgPSBVdGY4X3RleHRfY2h1bmtzXG5lbmRcbiJdfQ==
