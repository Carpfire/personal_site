// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Lwt_features
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Lwt_features =
      [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1];
   runtime.caml_register_global(0, Lwt_features, "Lwt_features");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_config
//# unitInfo: Requires: Lwt_features
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Lwt_features = global_data.Lwt_features,
    android = Lwt_features[1],
    libev_default = Lwt_features[2],
    HAVE_LIBEV = Lwt_features[3],
    HAVE_PTHREAD = Lwt_features[4],
    HAVE_EVENTFD = Lwt_features[5],
    HAVE_FD_PASSING = Lwt_features[6],
    HAVE_GETCPU = Lwt_features[7],
    HAVE_AFFINITY = Lwt_features[8],
    HAVE_GET_CREDENTIALS_LINUX = Lwt_features[9],
    HAVE_GET_CREDENTIALS_NETBSD = Lwt_features[10],
    HAVE_GET_CREDENTIALS_OPENBSD = Lwt_features[11],
    HAVE_GET_CREDENTIALS_FREEBSD = Lwt_features[12],
    HAVE_GETPEEREID = Lwt_features[13],
    HAVE_FDATASYNC = Lwt_features[14],
    HAVE_NETDB_REENTRANT = Lwt_features[15],
    HAVE_REENTRANT_HOSTENT = Lwt_features[16],
    HAVE_ST_MTIM_TV_NSEC = Lwt_features[17],
    HAVE_ST_MTIMESPEC_TV_NSEC = Lwt_features[18],
    HAVE_ST_MTIMENSEC = Lwt_features[19],
    HAVE_BSD_MINCORE = Lwt_features[20],
    HAVE_ACCEPT4 = Lwt_features[21],
    HAVE_GET_CREDENTIALS =
      HAVE_GET_CREDENTIALS_LINUX
      ||
       HAVE_GET_CREDENTIALS_NETBSD
       ||
        HAVE_GET_CREDENTIALS_OPENBSD
        || HAVE_GET_CREDENTIALS_FREEBSD || HAVE_GETPEEREID,
    Lwt_config =
      [0,
       android,
       libev_default,
       HAVE_LIBEV,
       HAVE_PTHREAD,
       HAVE_EVENTFD,
       HAVE_FD_PASSING,
       HAVE_GETCPU,
       HAVE_AFFINITY,
       HAVE_GET_CREDENTIALS_LINUX,
       HAVE_GET_CREDENTIALS_NETBSD,
       HAVE_GET_CREDENTIALS_OPENBSD,
       HAVE_GET_CREDENTIALS_FREEBSD,
       HAVE_GETPEEREID,
       HAVE_FDATASYNC,
       HAVE_NETDB_REENTRANT,
       HAVE_REENTRANT_HOSTENT,
       HAVE_ST_MTIM_TV_NSEC,
       HAVE_ST_MTIMESPEC_TV_NSEC,
       HAVE_ST_MTIMENSEC,
       HAVE_BSD_MINCORE,
       HAVE_ACCEPT4,
       HAVE_GET_CREDENTIALS];
   runtime.caml_register_global(1, Lwt_config, "Lwt_config");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_engine
//# unitInfo: Requires: CamlinternalLazy, CamlinternalOO, Lwt_config, Lwt_pqueue, Lwt_sequence, Stdlib, Stdlib__Format, Stdlib__List, Stdlib__Map, Unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_backend = "backend",
    cst_cleanup = "cleanup",
    cst_destroy = "destroy",
    cst_fake_io = "fake_io",
    cst_fork = "fork",
    cst_forwards_signal = "forwards_signal",
    cst_iter = "iter",
    cst_loop = "loop",
    cst_new_sleeps = "new_sleeps",
    cst_on_readable = "on_readable",
    cst_on_timer = "on_timer",
    cst_on_writable = "on_writable",
    cst_readable_count = "readable_count",
    cst_readables = "readables",
    cst_register_readable = "register_readable",
    cst_register_timer = "register_timer",
    cst_register_writable = "register_writable",
    cst_select = "select",
    cst_sleep_queue = "sleep_queue",
    cst_timer_count = "timer_count",
    cst_timers = "timers",
    cst_transfer = "transfer",
    cst_wait_readable = "wait_readable",
    cst_wait_writable = "wait_writable",
    cst_writable_count = "writable_count",
    cst_writables = "writables",
    caml_equal = runtime.caml_equal,
    caml_get_public_method = runtime.caml_get_public_method,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _a_ =
      [0,
       cst_writable_count,
       cst_transfer,
       cst_timer_count,
       cst_select,
       cst_register_writable,
       cst_register_timer,
       cst_register_readable,
       cst_readable_count,
       cst_on_writable,
       cst_on_timer,
       cst_on_readable,
       cst_iter,
       cst_forwards_signal,
       cst_fork,
       cst_fake_io,
       cst_destroy,
       cst_cleanup],
    _g_ = [0, cst_iter],
    _h_ = [0, cst_writables, cst_timers, cst_readables],
    _j_ =
      [0,
       cst_destroy,
       cst_fake_io,
       cst_fork,
       cst_forwards_signal,
       cst_on_readable,
       cst_on_timer,
       cst_on_writable,
       cst_readable_count,
       cst_timer_count,
       cst_transfer,
       cst_writable_count],
    _k_ =
      [0,
       cst_cleanup,
       cst_destroy,
       cst_fake_io,
       cst_fork,
       cst_forwards_signal,
       cst_on_readable,
       cst_on_timer,
       cst_on_writable,
       cst_readable_count,
       cst_register_readable,
       cst_register_timer,
       cst_register_writable,
       cst_timer_count,
       cst_transfer,
       cst_writable_count],
    _m_ =
      [0,
       cst_register_writable,
       cst_register_timer,
       cst_register_readable,
       cst_iter,
       cst_cleanup],
    _n_ =
      [0,
       cst_writables,
       cst_wait_writable,
       cst_wait_readable,
       cst_timers,
       cst_sleep_queue,
       cst_readables,
       cst_new_sleeps],
    _o_ =
      [0,
       cst_writable_count,
       cst_transfer,
       cst_timer_count,
       cst_register_writable,
       cst_register_timer,
       cst_register_readable,
       cst_readable_count,
       cst_on_writable,
       cst_on_timer,
       cst_on_readable,
       cst_iter,
       cst_forwards_signal,
       cst_fork,
       cst_fake_io,
       cst_destroy,
       cst_cleanup],
    shared = [0, cst_select],
    Unix = global_data.Unix,
    Stdlib = global_data.Stdlib,
    CamlinternalOO = global_data.CamlinternalOO,
    Stdlib_List = global_data.Stdlib__List,
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_Format = global_data.Stdlib__Format,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Lwt_pqueue = global_data.Lwt_pqueue,
    Stdlib_Map = global_data.Stdlib__Map,
    Lwt_config = global_data.Lwt_config,
    cst_EV_DEFAULT = "EV_DEFAULT",
    cst_EV_SELECT = "EV_SELECT",
    cst_EV_POLL = "EV_POLL",
    cst_EV_EPOLL = "EV_EPOLL",
    cst_EV_KQUEUE = "EV_KQUEUE",
    cst_EV_DEVPOLL = "EV_DEVPOLL",
    cst_EV_PORT = "EV_PORT",
    _b_ =
      [0,
       cst_cleanup,
       cst_destroy,
       cst_fake_io,
       cst_fork,
       cst_forwards_signal,
       cst_iter,
       cst_on_readable,
       cst_on_timer,
       cst_on_writable,
       cst_readable_count,
       cst_register_readable,
       cst_register_timer,
       cst_register_writable,
       cst_timer_count,
       cst_transfer,
       cst_writable_count],
    _c_ = [0, cst_readables, cst_writables, cst_timers],
    _d_ =
      [0,
       cst_fork,
       cst_on_readable,
       cst_iter,
       cst_loop,
       cst_writable_count,
       cst_transfer,
       cst_readable_count,
       cst_on_writable,
       cst_timer_count,
       cst_backend,
       cst_forwards_signal,
       cst_destroy,
       cst_on_timer,
       cst_fake_io],
    _e_ = [0, cst_loop],
    _f_ =
      [0,
       cst_sleep_queue,
       cst_new_sleeps,
       cst_wait_readable,
       cst_wait_writable],
    _i_ =
      [0,
       cst_fork,
       cst_on_readable,
       cst_iter,
       cst_writable_count,
       cst_transfer,
       cst_readable_count,
       cst_on_writable,
       cst_timer_count,
       cst_forwards_signal,
       cst_destroy,
       cst_on_timer,
       cst_fake_io],
    _l_ =
      [0,
       cst_writable_count,
       cst_transfer,
       cst_timer_count,
       cst_register_writable,
       cst_register_timer,
       cst_register_readable,
       cst_readable_count,
       "poll",
       cst_on_writable,
       cst_on_timer,
       cst_on_readable,
       cst_iter,
       cst_forwards_signal,
       cst_fork,
       cst_fake_io,
       cst_destroy,
       cst_cleanup],
    _p_ =
      [0,
       cst_writable_count,
       cst_transfer,
       cst_timer_count,
       cst_register_writable,
       cst_register_timer,
       cst_register_readable,
       cst_readable_count,
       cst_on_writable,
       cst_on_timer,
       cst_on_readable,
       cst_loop,
       cst_iter,
       cst_forwards_signal,
       cst_fork,
       cst_fake_io,
       cst_destroy,
       cst_cleanup,
       cst_backend];
   function stop_event(ev){
    var ev$0 = ev[1];
    caml_call1(Lwt_sequence[3], ev$0[2]);
    var _cZ_ = ev$0[1], _c0_ = runtime.caml_obj_tag(_cZ_);
    if(250 === _c0_) return _cZ_[1];
    if(246 !== _c0_ && 244 !== _c0_) return _cZ_;
    return caml_call1(CamlinternalLazy[2], _cZ_);
   }
   var
    _q_ = caml_call1(Lwt_sequence[4], 0),
    fake_event = [0, 0, caml_call2(Lwt_sequence[8], 0, _q_)],
    fake_event$0 = [0, fake_event],
    abstract$0 = [],
    _r_ = 0,
    _s_ = 0;
   caml_update_dummy
    (abstract$0,
     [0,
      0,
      function(_cb_){
       var
        _cc_ = caml_call3(CamlinternalOO[4], _cb_, _o_, _c_),
        _cs_ = _cc_[17],
        _ct_ = _cc_[18],
        _cu_ = _cc_[19],
        _cd_ = _cc_[1],
        _ce_ = _cc_[2],
        _cf_ = _cc_[3],
        _cg_ = _cc_[4],
        _ch_ = _cc_[5],
        _ci_ = _cc_[6],
        _cj_ = _cc_[7],
        _ck_ = _cc_[8],
        _cl_ = _cc_[9],
        _cm_ = _cc_[10],
        _cn_ = _cc_[12],
        _co_ = _cc_[13],
        _cp_ = _cc_[14],
        _cq_ = _cc_[15],
        _cr_ = _cc_[16];
       function _cv_(self_1, signum){return 0;}
       function _cw_(self_1){return 0;}
       function _cx_(self_1){
        return caml_call1(Lwt_sequence[7], self_1[1 + _cu_]);
       }
       function _cy_(self_1){
        return caml_call1(Lwt_sequence[7], self_1[1 + _ct_]);
       }
       function _cz_(self_1){
        return caml_call1(Lwt_sequence[7], self_1[1 + _cs_]);
       }
       function _cA_(self_1, delay, repeat, f){
        var ev = [0, fake_event];
        function g(param){return caml_call1(f, ev);}
        var stop = caml_call4(self_1[1][1 + _ch_], self_1, delay, repeat, g);
        ev[1] =
         [0,
          stop,
          caml_call2
           (Lwt_sequence[9], [0, delay, repeat, f, g, ev], self_1[1 + _cu_])];
        return ev;
       }
       function _cB_(self_1, fd, f){
        var ev = [0, fake_event];
        function g(param){return caml_call1(f, ev);}
        var stop = caml_call3(self_1[1][1 + _cg_], self_1, fd, g);
        ev[1] =
         [0,
          stop,
          caml_call2(Lwt_sequence[9], [0, fd, f, g, ev], self_1[1 + _ct_])];
        return ev;
       }
       function _cC_(self_1, fd, f){
        var ev = [0, fake_event];
        function g(param){return caml_call1(f, ev);}
        var stop = caml_call3(self_1[1][1 + _ci_], self_1, fd, g);
        ev[1] =
         [0,
          stop,
          caml_call2(Lwt_sequence[9], [0, fd, f, g, ev], self_1[1 + _cs_])];
        return ev;
       }
       function _cD_(self_1, fd){
        var _cT_ = self_1[1 + _cs_];
        function _cU_(param){
         var g = param[3], fd$0 = param[1], _cY_ = caml_equal(fd, fd$0);
         return _cY_ ? caml_call1(g, 0) : _cY_;
        }
        caml_call2(Lwt_sequence[17], _cU_, _cT_);
        var _cV_ = self_1[1 + _ct_];
        function _cW_(param){
         var g = param[3], fd$0 = param[1], _cX_ = caml_equal(fd, fd$0);
         return _cX_ ? caml_call1(g, 0) : _cX_;
        }
        return caml_call2(Lwt_sequence[17], _cW_, _cV_);
       }
       function _cE_(self_1, engine){
        var _cN_ = self_1[1 + _cs_];
        function _cO_(param){
         var ev = param[4], f = param[2], fd = param[1];
         stop_event(ev);
         ev[1] =
          caml_call3
            (caml_get_public_method(engine, -980609456, 1), engine, fd, f)
           [1];
         return 0;
        }
        caml_call2(Lwt_sequence[17], _cO_, _cN_);
        var _cP_ = self_1[1 + _ct_];
        function _cQ_(param){
         var ev = param[4], f = param[2], fd = param[1];
         stop_event(ev);
         ev[1] =
          caml_call3
            (caml_get_public_method(engine, -379288640, 2), engine, fd, f)
           [1];
         return 0;
        }
        caml_call2(Lwt_sequence[17], _cQ_, _cP_);
        var _cR_ = self_1[1 + _cu_];
        function _cS_(param){
         var ev = param[5], f = param[3], repeat = param[2], delay = param[1];
         stop_event(ev);
         ev[1] =
          caml_call4
            (caml_get_public_method(engine, 926255461, 3),
             engine,
             delay,
             repeat,
             f)
           [1];
         return 0;
        }
        return caml_call2(Lwt_sequence[17], _cS_, _cR_);
       }
       var
        _cF_ =
          [0,
           _cq_,
           function(self_1){
            var _cH_ = self_1[1 + _cs_];
            function _cI_(param){var ev = param[4]; return stop_event(ev);}
            caml_call2(Lwt_sequence[17], _cI_, _cH_);
            var _cJ_ = self_1[1 + _ct_];
            function _cK_(param){var ev = param[4]; return stop_event(ev);}
            caml_call2(Lwt_sequence[17], _cK_, _cJ_);
            var _cL_ = self_1[1 + _cu_];
            function _cM_(param){var ev = param[5]; return stop_event(ev);}
            caml_call2(Lwt_sequence[17], _cM_, _cL_);
            return caml_call1(self_1[1][1 + _cr_], self_1);
           },
           _ce_,
           _cE_,
           _cp_,
           _cD_,
           _cm_,
           _cC_,
           _ck_,
           _cB_,
           _cl_,
           _cA_,
           _cj_,
           _cz_,
           _cd_,
           _cy_,
           _cf_,
           _cx_,
           _co_,
           _cw_,
           _cn_,
           _cv_];
       caml_call2(CamlinternalOO[11], _cb_, _cF_);
       return function(env, _cG_){
        var self = caml_call2(CamlinternalOO[24], _cG_, _cb_);
        self[1 + _cs_] = caml_call1(Lwt_sequence[4], 0);
        self[1 + _ct_] = caml_call1(Lwt_sequence[4], 0);
        self[1 + _cu_] = caml_call1(Lwt_sequence[4], 0);
        return self;};
      },
      _s_,
      _r_]);
   var
    equal = caml_equal,
    default$0 = 0,
    select = 1,
    poll = 2,
    epoll = 3,
    kqueue = 4,
    devpoll = 5,
    port = 6;
   function pp(fmt, t){
    switch(t){
      case 0:
       var _ca_ = cst_EV_DEFAULT; break;
      case 1:
       var _ca_ = cst_EV_SELECT; break;
      case 2:
       var _ca_ = cst_EV_POLL; break;
      case 3:
       var _ca_ = cst_EV_EPOLL; break;
      case 4:
       var _ca_ = cst_EV_KQUEUE; break;
      case 5:
       var _ca_ = cst_EV_DEVPOLL; break;
      default: var _ca_ = cst_EV_PORT;
    }
    return caml_call2(Stdlib_Format[13], fmt, _ca_);
   }
   function _t_(_bS_){
    var
     _bT_ = caml_call3(CamlinternalOO[4], _bS_, _p_, _e_),
     _b1_ = _bT_[19],
     _bU_ = _bT_[4],
     _bV_ = _bT_[5],
     _bW_ = _bT_[6],
     _bX_ = _bT_[11],
     _bY_ = _bT_[12],
     _bZ_ = _bT_[17],
     _b0_ = _bT_[18],
     _b2_ =
       caml_call6(CamlinternalOO[18], _bS_, _h_, _m_, _j_, abstract$0, 1)[1];
    function _b3_(self_2, delay, repeat, f){
     var
      ev = runtime.lwt_libev_timer_init(self_2[1 + _b1_], delay, repeat, f);
     return [246,
             function(param){
              return runtime.lwt_libev_timer_stop(self_2[1 + _b1_], ev);
             }];
    }
    function _b4_(self_2, fd, f){
     var ev = runtime.lwt_libev_writable_init(self_2[1 + _b1_], fd, f);
     return [246,
             function(param){
              return runtime.lwt_libev_io_stop(self_2[1 + _b1_], ev);
             }];
    }
    function _b5_(self_2, fd, f){
     var ev = runtime.lwt_libev_readable_init(self_2[1 + _b1_], fd, f);
     return [246,
             function(param){
              return runtime.lwt_libev_io_stop(self_2[1 + _b1_], ev);
             }];
    }
    function _b6_(self_2, block){
     try{
      var _b$_ = runtime.lwt_libev_loop(self_2[1 + _b1_], block);
      return _b$_;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      runtime.lwt_libev_unloop(self_2[1 + _b1_]);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    }
    function _b7_(self_2){return runtime.lwt_libev_stop(self_2[1 + _b1_]);}
    function _b8_(self_2){return runtime.lwt_libev_backend(self_2[1 + _b1_]);}
    var
     _b9_ =
       [0,
        _bX_,
        function(self_2){return self_2[1 + _b1_];},
        _b0_,
        _b8_,
        _bZ_,
        _b7_,
        _bY_,
        _b6_,
        _bW_,
        _b5_,
        _bU_,
        _b4_,
        _bV_,
        _b3_];
    caml_call2(CamlinternalOO[11], _bS_, _b9_);
    return function(_b__, self, opt){
     if(opt) var sth = opt[1], sth$0 = sth; else var sth$0 = default$0;
     return function(param){
      var self$0 = caml_call2(CamlinternalOO[24], self, _bS_);
      caml_call1(_b2_, self$0);
      self$0[1 + _b1_] = runtime.lwt_libev_init(sth$0);
      return caml_call3(CamlinternalOO[26], self, self$0, _bS_);};};
   }
   var
    libev = caml_call2(CamlinternalOO[19], _d_, _t_),
    libev_deprecated = [];
   function _u_(_bR_, _bQ_){return caml_call3(_bR_, _bQ_, 0, 0);}
   var _v_ = libev[4], _w_ = libev[3];
   function _x_(_bL_){
    var _bM_ = caml_call1(libev[2], _bL_);
    return function(_bN_){
     var _bO_ = caml_call1(_bM_, _bN_);
     return function(_bP_){return _u_(_bO_, _bP_);};};
   }
   var _y_ = libev[1];
   caml_update_dummy
    (libev_deprecated,
     [0, function(_bK_){return _u_(_y_, _bK_);}, _x_, _w_, _v_]);
   function compare(param){
    var t1 = param[1];
    return function(param){
     var t2 = param[1];
     return runtime.caml_float_compare(t1, t2);};
   }
   var
    Sleep_queue = caml_call1(Lwt_pqueue[1], [0, compare]),
    compare$0 = runtime.caml_compare,
    Fd_map = caml_call1(Stdlib_Map[1], [0, compare$0]);
   function restart_actions(sleep_queue, now){
    var sleep_queue$0 = sleep_queue;
    for(;;){
     var match = caml_call1(Sleep_queue[6], sleep_queue$0);
     if(match){
      var _bJ_ = match[1], time = _bJ_[1];
      if(_bJ_[2]){
       var
        sleep_queue$1 = caml_call1(Sleep_queue[7], sleep_queue$0),
        sleep_queue$0 = sleep_queue$1;
       continue;
      }
      var action = _bJ_[3];
      if(time <= now){
       var sleep_queue$2 = caml_call1(Sleep_queue[7], sleep_queue$0);
       caml_call1(action, 0);
       var sleep_queue$0 = sleep_queue$2;
       continue;
      }
     }
     return sleep_queue$0;
    }
   }
   function get_next_timeout(sleep_queue){
    var sleep_queue$0 = sleep_queue;
    for(;;){
     var match = caml_call1(Sleep_queue[6], sleep_queue$0);
     if(! match) return -1.;
     var _bH_ = match[1], time = _bH_[1];
     if(! _bH_[2]){
      var _bI_ = time - caml_call1(Unix[101], 0);
      return caml_call2(Stdlib[17], 0., _bI_);
     }
     var
      sleep_queue$1 = caml_call1(Sleep_queue[7], sleep_queue$0),
      sleep_queue$0 = sleep_queue$1;
    }
   }
   function bad_fd(fd){
    try{caml_call1(Unix[41], fd); var _bF_ = 0; return _bF_;}
    catch(_bG_){
     var _bE_ = caml_wrap_exception(_bG_);
     if(_bE_[1] === Unix[1]) return 1;
     throw caml_maybe_attach_backtrace(_bE_, 0);
    }
   }
   function invoke_actions(fd, map){
    try{var actions = caml_call2(Fd_map[17], fd, map);}
    catch(_bD_){
     var _bB_ = caml_wrap_exception(_bD_);
     if(_bB_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_bB_, 0);
    }
    function _bC_(f){return caml_call1(f, 0);}
    return caml_call2(Lwt_sequence[17], _bC_, actions);
   }
   var select_or_poll_based = [], _z_ = 0, _A_ = 0;
   caml_update_dummy
    (select_or_poll_based,
     [0,
      0,
      function(_a7_){
       var
        _a8_ = caml_call3(CamlinternalOO[4], _a7_, _o_, _f_),
        _bc_ = _a8_[18],
        _bd_ = _a8_[19],
        _be_ = _a8_[20],
        _a9_ = _a8_[4],
        _a__ = _a8_[5],
        _a$_ = _a8_[6],
        _ba_ = _a8_[16],
        _bb_ = _a8_[17],
        _bf_ =
          caml_call6(CamlinternalOO[18], _a7_, _h_, _m_, _j_, abstract$0, 1)
           [1];
       function _bg_(self_4, fd, f){
        try{
         var
          _bx_ = caml_call2(Fd_map[17], fd, self_4[1 + _be_]),
          actions$0 = _bx_;
        }
        catch(_bA_){
         var _bw_ = caml_wrap_exception(_bA_);
         if(_bw_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_bw_, 0);
         var actions = caml_call1(Lwt_sequence[4], 0);
         self_4[1 + _be_] =
          caml_call3(Fd_map[2], fd, actions, self_4[1 + _be_]);
         var actions$0 = actions;
        }
        var node = caml_call2(Lwt_sequence[8], f, actions$0);
        return [246,
                function(param){
                 caml_call1(Lwt_sequence[3], node);
                 var
                  _by_ = caml_call1(Lwt_sequence[6], actions$0),
                  _bz_ =
                    _by_
                     ? (self_4
                        [1 + _be_]
                       = caml_call2(Fd_map[6], fd, self_4[1 + _be_]),
                       0)
                     : _by_;
                 return _bz_;
                }];
       }
       function _bh_(self_4, fd, f){
        try{
         var
          _bs_ = caml_call2(Fd_map[17], fd, self_4[1 + _bd_]),
          actions$0 = _bs_;
        }
        catch(_bv_){
         var _br_ = caml_wrap_exception(_bv_);
         if(_br_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_br_, 0);
         var actions = caml_call1(Lwt_sequence[4], 0);
         self_4[1 + _bd_] =
          caml_call3(Fd_map[2], fd, actions, self_4[1 + _bd_]);
         var actions$0 = actions;
        }
        var node = caml_call2(Lwt_sequence[8], f, actions$0);
        return [246,
                function(param){
                 caml_call1(Lwt_sequence[3], node);
                 var
                  _bt_ = caml_call1(Lwt_sequence[6], actions$0),
                  _bu_ =
                    _bt_
                     ? (self_4
                        [1 + _bd_]
                       = caml_call2(Fd_map[6], fd, self_4[1 + _bd_]),
                       0)
                     : _bt_;
                 return _bu_;
                }];
       }
       function _bi_(self_4, delay, repeat, f){
        if(repeat){
         var sleeper = [], g = function _bq_(_bp_){return _bq_.fun(_bp_);};
         caml_update_dummy
          (sleeper, [0, caml_call1(Unix[101], 0) + delay, 0, g]);
         caml_update_dummy
          (g,
           function(param){
            sleeper[1] = caml_call1(Unix[101], 0) + delay;
            self_4[1 + _bc_] = [0, sleeper, self_4[1 + _bc_]];
            return caml_call1(f, 0);
           });
         self_4[1 + _bc_] = [0, sleeper, self_4[1 + _bc_]];
         return [246, function(_bo_){sleeper[2] = 1; return 0;}];
        }
        var sleeper$0 = [0, caml_call1(Unix[101], 0) + delay, 0, f];
        self_4[1 + _bc_] = [0, sleeper$0, self_4[1 + _bc_]];
        return [246, function(_bn_){sleeper$0[2] = 1; return 0;}];
       }
       var
        _bj_ =
          [0,
           _ba_,
           function(self_4){return 0;},
           _a__,
           _bi_,
           _a$_,
           _bh_,
           _a9_,
           _bg_];
       caml_call2(CamlinternalOO[11], _a7_, _bj_);
       return function(_bl_, _bk_){
        var _bm_ = caml_call2(CamlinternalOO[24], _bk_, _a7_);
        caml_call1(_bf_, _bm_);
        _bm_[1 + _bb_] = Sleep_queue[1];
        _bm_[1 + _bc_] = 0;
        _bm_[1 + _bd_] = Fd_map[1];
        _bm_[1 + _be_] = Fd_map[1];
        return caml_call3(CamlinternalOO[26], _bk_, _bm_, _a7_);};
      },
      _A_,
      _z_]);
   var select_based = [], _B_ = 0, _C_ = 0;
   caml_update_dummy
    (select_based,
     [0,
      0,
      function(_aB_){
       var
        _aC_ = caml_call2(CamlinternalOO[8], _aB_, _a_),
        _aD_ = _aC_[4],
        _aE_ = _aC_[12],
        _aF_ =
          caml_call6
           (CamlinternalOO[18], _aB_, _n_, _g_, _k_, select_or_poll_based, 1),
        _aH_ = _aF_[8],
        _aI_ = _aF_[6],
        _aJ_ = _aF_[4],
        _aK_ = _aF_[3],
        _aG_ = _aF_[1];
       function _aL_(self_5, block){
        var _aP_ = self_5[1 + _aH_], _aQ_ = self_5[1 + _aI_];
        function _aR_(q, e){return caml_call2(Sleep_queue[3], e, q);}
        self_5[1 + _aI_] = caml_call3(Stdlib_List[26], _aR_, _aQ_, _aP_);
        self_5[1 + _aH_] = 0;
        var _aS_ = 0, _aT_ = self_5[1 + _aJ_];
        function _aU_(fd, param, l){return [0, fd, l];}
        var
         fds_r = caml_call3(Fd_map[24], _aU_, _aT_, _aS_),
         _aV_ = 0,
         _aW_ = self_5[1 + _aK_];
        function _aX_(fd, param, l){return [0, fd, l];}
        var
         fds_w = caml_call3(Fd_map[24], _aX_, _aW_, _aV_),
         timeout = block ? get_next_timeout(self_5[1 + _aI_]) : 0.;
        a:
        try{
         var
          _a3_ =
            caml_call4(self_5[1][1 + _aD_], self_5, fds_r, fds_w, timeout),
          _a4_ = _a3_[2],
          _a5_ = _a3_[1],
          fds_w$1 = _a4_,
          fds_r$0 = _a5_;
        }
        catch(_a6_){
         var _aY_ = caml_wrap_exception(_a6_);
         if(_aY_[1] === Unix[1]){
          var _aZ_ = _aY_[2];
          if(typeof _aZ_ === "number"){
           if(3 === _aZ_){
            var
             fds_w$0 = caml_call2(Stdlib_List[44], bad_fd, fds_w),
             fds_w$1 = fds_w$0,
             fds_r$0 = caml_call2(Stdlib_List[44], bad_fd, fds_r);
            break a;
           }
           if(11 === _aZ_){var fds_w$1 = 0, fds_r$0 = 0; break a;}
          }
         }
         throw caml_maybe_attach_backtrace(_aY_, 0);
        }
        var _a0_ = caml_call1(Unix[101], 0);
        self_5[1 + _aI_] = restart_actions(self_5[1 + _aI_], _a0_);
        function _a1_(fd){return invoke_actions(fd, self_5[1 + _aJ_]);}
        caml_call2(Stdlib_List[18], _a1_, fds_r$0);
        function _a2_(fd){return invoke_actions(fd, self_5[1 + _aK_]);}
        return caml_call2(Stdlib_List[18], _a2_, fds_w$1);
       }
       caml_call3(CamlinternalOO[10], _aB_, _aE_, _aL_);
       return function(_aN_, _aM_){
        var _aO_ = caml_call2(CamlinternalOO[24], _aM_, _aB_);
        caml_call1(_aG_, _aO_);
        return caml_call3(CamlinternalOO[26], _aM_, _aO_, _aB_);};
      },
      _C_,
      _B_]);
   var poll_based = [], _D_ = 0, _E_ = 0;
   caml_update_dummy
    (poll_based,
     [0,
      0,
      function(___){
       var
        _$_ = caml_call2(CamlinternalOO[8], ___, _l_),
        _aa_ = _$_[8],
        _ab_ = _$_[12],
        _ac_ =
          caml_call6
           (CamlinternalOO[18], ___, _n_, _g_, _k_, select_or_poll_based, 1),
        _ae_ = _ac_[8],
        _af_ = _ac_[6],
        _ag_ = _ac_[4],
        _ah_ = _ac_[3],
        _ad_ = _ac_[1];
       function _ai_(self_6, block){
        var _am_ = self_6[1 + _ae_], _an_ = self_6[1 + _af_];
        function _ao_(q, e){return caml_call2(Sleep_queue[3], e, q);}
        self_6[1 + _af_] = caml_call3(Stdlib_List[26], _ao_, _an_, _am_);
        self_6[1 + _ae_] = 0;
        var fds = 0, _ap_ = self_6[1 + _ag_];
        function _aq_(fd, param, l){return [0, [0, fd, 1, 0], l];}
        var
         fds$0 = caml_call3(Fd_map[24], _aq_, _ap_, fds),
         _ar_ = self_6[1 + _ah_];
        function _as_(fd, param, l){return [0, [0, fd, 0, 1], l];}
        var
         fds$1 = caml_call3(Fd_map[24], _as_, _ar_, fds$0),
         timeout = block ? get_next_timeout(self_6[1 + _af_]) : 0.;
        a:
        try{
         var
          _az_ = caml_call3(self_6[1][1 + _aa_], self_6, fds$1, timeout),
          fds$2 = _az_;
        }
        catch(_aA_){
         var _at_ = caml_wrap_exception(_aA_);
         b:
         if(_at_[1] === Unix[1]){
          var _au_ = _at_[2];
          if(typeof _au_ === "number"){
           if(3 === _au_)
            var
             _av_ = function(param){var fd = param[1]; return bad_fd(fd);},
             _aw_ = caml_call2(Stdlib_List[44], _av_, fds$1);
           else{if(11 !== _au_) break b; var _aw_ = 0;}
           var fds$2 = _aw_;
           break a;
          }
         }
         throw caml_maybe_attach_backtrace(_at_, 0);
        }
        var _ax_ = caml_call1(Unix[101], 0);
        self_6[1 + _af_] = restart_actions(self_6[1 + _af_], _ax_);
        function _ay_(param){
         var writable = param[3], readable = param[2], fd = param[1];
         if(readable) invoke_actions(fd, self_6[1 + _ag_]);
         return writable ? invoke_actions(fd, self_6[1 + _ah_]) : writable;
        }
        return caml_call2(Stdlib_List[18], _ay_, fds$2);
       }
       caml_call3(CamlinternalOO[10], ___, _ab_, _ai_);
       return function(_ak_, _aj_){
        var _al_ = caml_call2(CamlinternalOO[24], _aj_, ___);
        caml_call1(_ad_, _al_);
        return caml_call3(CamlinternalOO[26], _aj_, _al_, ___);};
      },
      _E_,
      _D_]);
   function _F_(_T_){
    var
     _U_ = caml_call2(CamlinternalOO[8], _T_, _a_)[4],
     _V_ =
       caml_call6(CamlinternalOO[18], _T_, _n_, shared, _b_, select_based, 1)
        [1];
    function _W_(self_7, fds_r, fds_w, timeout){
     var
      match = caml_call4(Unix[93], fds_r, fds_w, 0, timeout),
      fds_w$0 = match[2],
      fds_r$0 = match[1];
     return [0, fds_r$0, fds_w$0];
    }
    caml_call3(CamlinternalOO[10], _T_, _U_, _W_);
    return function(_Y_, _X_){
     var _Z_ = caml_call2(CamlinternalOO[24], _X_, _T_);
     caml_call1(_V_, _Z_);
     return caml_call3(CamlinternalOO[26], _X_, _Z_, _T_);};
   }
   var select$0 = caml_call2(CamlinternalOO[19], _i_, _F_);
   a:
   {
    if(Lwt_config[3] && Lwt_config[2]){
     var current = [0, caml_call3(libev[1], 0, 0, 0)];
     break a;
    }
    var current = [0, caml_call1(select$0[1], 0)];
   }
   function get(param){return current[1];}
   function set(opt, _Q_, engine){
    if(opt) var sth = opt[1], transfer = sth; else var transfer = 1;
    if(_Q_) var sth$0 = _Q_[1], destroy = sth$0; else var destroy = 1;
    if(transfer){
     var _R_ = current[1];
     caml_call2(caml_get_public_method(_R_, -630345941, 4), _R_, engine);
    }
    if(destroy){
     var _S_ = current[1];
     caml_call1(caml_get_public_method(_S_, 612773114, 5), _S_);
    }
    current[1] = engine;
    return 0;
   }
   function iter(block){
    var _P_ = current[1];
    return caml_call2(caml_get_public_method(_P_, -977287912, 6), _P_, block);
   }
   function on_readable(fd, f){
    var _O_ = current[1];
    return caml_call3(caml_get_public_method(_O_, -980609456, 7), _O_, fd, f);
   }
   function on_writable(fd, f){
    var _N_ = current[1];
    return caml_call3(caml_get_public_method(_N_, -379288640, 8), _N_, fd, f);
   }
   function on_timer(delay, repeat, f){
    var _M_ = current[1];
    return caml_call4
            (caml_get_public_method(_M_, 926255461, 9), _M_, delay, repeat, f);
   }
   function fake_io(fd){
    var _L_ = current[1];
    return caml_call2(caml_get_public_method(_L_, 957768080, 10), _L_, fd);
   }
   function readable_count(param){
    var _K_ = current[1];
    return caml_call1(caml_get_public_method(_K_, -491308032, 11), _K_);
   }
   function writable_count(param){
    var _J_ = current[1];
    return caml_call1(caml_get_public_method(_J_, -691905168, 12), _J_);
   }
   function timer_count(param){
    var _I_ = current[1];
    return caml_call1(caml_get_public_method(_I_, -270668395, 13), _I_);
   }
   function fork(param){
    var _H_ = current[1];
    return caml_call1(caml_get_public_method(_H_, -1010802366, 14), _H_);
   }
   function forwards_signal(n){
    var _G_ = current[1];
    return caml_call2(caml_get_public_method(_G_, 360723129, 15), _G_, n);
   }
   var
    Versioned = [0, libev_deprecated, libev],
    Lwt_engine =
      [0,
       stop_event,
       fake_event$0,
       iter,
       on_readable,
       on_writable,
       on_timer,
       readable_count,
       writable_count,
       timer_count,
       fake_io,
       fork,
       forwards_signal,
       abstract$0,
       [0, default$0, select, poll, epoll, kqueue, devpoll, port, equal, pp],
       libev,
       select$0,
       select_based,
       poll_based,
       get,
       set,
       Versioned];
   runtime.caml_register_global(38, Lwt_engine, "Lwt_engine");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_main
//# unitInfo: Requires: Lwt, Lwt_engine, Lwt_sequence, Stdlib, Stdlib__Mutex, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Nested_calls_to_Lwt_main_r$0 =
      "Nested calls to Lwt_main.run are not allowed",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_Mutex = global_data.Stdlib__Mutex,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Lwt_engine = global_data.Lwt_engine,
    enter_iter_hooks = caml_call1(Lwt_sequence[4], 0),
    leave_iter_hooks = caml_call1(Lwt_sequence[4], 0),
    yield$0 = Lwt[57],
    _a_ = [0, cst_Nested_calls_to_Lwt_main_r$0],
    cst_Lwt_main_run_already_calle = "Lwt_main.run already called from:",
    cst_Nested_calls_to_Lwt_main_r = cst_Nested_calls_to_Lwt_main_r$0,
    _b_ = [0, [2, 0, [12, 10, [2, 0, [12, 10, [2, 0, 0]]]]], "%s\n%s\n%s"];
   function abandon_yielded_and_paused(param){return caml_call1(Lwt[61], 0);}
   var
    run_already_called = [0, 17505],
    run_already_called_mutex = caml_call1(Stdlib_Mutex[1], 0);
   function finished(param){
    caml_call1(Stdlib_Mutex[2], run_already_called_mutex);
    run_already_called[1] = 17505;
    return caml_call1(Stdlib_Mutex[4], run_already_called_mutex);
   }
   function run(p){
    caml_call1(Stdlib_Mutex[2], run_already_called_mutex);
    var match$0 = run_already_called[1];
    if(typeof match$0 === "number")
     var
      error_message_if_call_is_neste =
        17505 <= match$0 ? (run_already_called[1] = -147962306, 0) : _a_;
    else
     var
      backtrace_string = match$0[2],
      error_message_if_call_is_neste =
        [0,
         caml_call4
          (Stdlib_Printf[4],
           _b_,
           cst_Nested_calls_to_Lwt_main_r,
           cst_Lwt_main_run_already_calle,
           backtrace_string)];
    caml_call1(Stdlib_Mutex[4], run_already_called_mutex);
    if(error_message_if_call_is_neste){
     var message = error_message_if_call_is_neste[1];
     caml_call1(Stdlib[2], message);
    }
    try{
     for(;;){
      var match = caml_call1(Lwt[79], p);
      if(match){var result = match[1]; break;}
      var _i_ = function(f){return caml_call1(f, 0);};
      caml_call2(Lwt_sequence[17], _i_, enter_iter_hooks);
      var should_block_waiting_for_io = 0 === caml_call1(Lwt[59], 0) ? 1 : 0;
      caml_call1(Lwt_engine[3], should_block_waiting_for_io);
      caml_call1(Lwt[58], 0);
      var _j_ = function(f){return caml_call1(f, 0);};
      caml_call2(Lwt_sequence[17], _j_, leave_iter_hooks);
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! caml_call1(Lwt[78][4], exn))
      throw caml_maybe_attach_backtrace(exn, 0);
     finished(0);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    finished(0);
    return result;
   }
   var exit_hooks = caml_call1(Lwt_sequence[4], 0);
   function call_hooks(param){
    var match = caml_call1(Lwt_sequence[13], exit_hooks);
    if(! match) return Lwt[36];
    var f = match[1];
    function _e_(param){return call_hooks(0);}
    function _f_(param){return Lwt[36];}
    function _g_(param){return caml_call1(f, 0);}
    var _h_ = caml_call2(Lwt[7], _g_, _f_);
    return caml_call2(Lwt[33][1], _h_, _e_);
   }
   function _c_(param){
    var _d_ = 1 - caml_call1(Lwt_sequence[6], exit_hooks);
    return _d_
            ? (caml_call1(Lwt[85], 0), finished(0), run(call_hooks(0)))
            : _d_;
   }
   caml_call1(Stdlib[100], _c_);
   function at_exit(f){caml_call2(Lwt_sequence[8], f, exit_hooks); return 0;}
   function Wrap_hooks(Sequence){
    function add_first(hook_fn){
     var hook_node = caml_call2(Lwt_sequence[8], hook_fn, Sequence[1]);
     return hook_node;
    }
    function add_last(hook_fn){
     var hook_node = caml_call2(Lwt_sequence[9], hook_fn, Sequence[1]);
     return hook_node;
    }
    function remove(hook_node){return caml_call1(Lwt_sequence[3], hook_node);}
    function remove_all(param){
     return caml_call2(Lwt_sequence[19], Lwt_sequence[3], Sequence[1]);
    }
    return [0, add_first, add_last, remove, remove_all];
   }
   var
    Enter_iter_hooks = Wrap_hooks([0, enter_iter_hooks]),
    Leave_iter_hooks = Wrap_hooks([0, leave_iter_hooks]),
    Exit_hooks = Wrap_hooks([0, exit_hooks]),
    Lwt_main =
      [0,
       run,
       yield$0,
       abandon_yielded_and_paused,
       Enter_iter_hooks,
       Leave_iter_hooks,
       Exit_hooks,
       enter_iter_hooks,
       leave_iter_hooks,
       exit_hooks,
       at_exit];
   runtime.caml_register_global(10, Lwt_main, "Lwt_main");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_unix
//# unitInfo: Requires: CamlinternalLazy, Lwt, Lwt_config, Lwt_engine, Lwt_main, Lwt_mutex, Lwt_sequence, Lwt_stream, Stdlib, Stdlib__Array, Stdlib__Bytes, Stdlib__Filename, Stdlib__Gc, Stdlib__Hashtbl, Stdlib__List, Stdlib__Map, Stdlib__Printexc, Stdlib__Printf, Stdlib__Sys, Unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$6 = "",
    cst$5 = ", ",
    cst_bin_sh$1 = "/bin/sh",
    cst_Lwt_unix_readdir_n$1 = "Lwt_unix.readdir_n",
    cst_Lwt_unix_readv$1 = "Lwt_unix.readv",
    cst_Lwt_unix_writev$1 = "Lwt_unix.writev",
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_notequal = runtime.caml_notequal,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$4 = cst$6,
    cst$3 = cst$6,
    cst$2 = cst$6,
    cst$1 = cst$6,
    cst$0 = cst$6,
    cst = cst$6,
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Unix = global_data.Unix,
    Stdlib = global_data.Stdlib,
    Lwt = global_data.Lwt,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Lwt_config = global_data.Lwt_config,
    Stdlib_List = global_data.Stdlib__List,
    Lwt_engine = global_data.Lwt_engine,
    Lwt_main = global_data.Lwt_main,
    Stdlib_Array = global_data.Stdlib__Array,
    Lwt_mutex = global_data.Lwt_mutex,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Lwt_stream = global_data.Lwt_stream,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    default_async_method_var = [0, 1],
    _f_ = [0, 0, 0, 0],
    _g_ = [0, 0, 0, 0],
    _n_ = [2, 0],
    _o_ = [2, 1],
    cst_E2BIG = "E2BIG",
    cst_EACCES = "EACCES",
    cst_EAGAIN = "EAGAIN",
    cst_EBADF = "EBADF",
    cst_EBUSY = "EBUSY",
    cst_ECHILD = "ECHILD",
    cst_EDEADLK = "EDEADLK",
    cst_EDOM = "EDOM",
    cst_EEXIST = "EEXIST",
    cst_EFAULT = "EFAULT",
    cst_EFBIG = "EFBIG",
    cst_EINTR = "EINTR",
    cst_EINVAL = "EINVAL",
    cst_EIO = "EIO",
    cst_EISDIR = "EISDIR",
    cst_EMFILE = "EMFILE",
    cst_EMLINK = "EMLINK",
    cst_ENAMETOOLONG = "ENAMETOOLONG",
    cst_ENFILE = "ENFILE",
    cst_ENODEV = "ENODEV",
    cst_ENOENT = "ENOENT",
    cst_ENOEXEC = "ENOEXEC",
    cst_ENOLCK = "ENOLCK",
    cst_ENOMEM = "ENOMEM",
    cst_ENOSPC = "ENOSPC",
    cst_ENOSYS = "ENOSYS",
    cst_ENOTDIR = "ENOTDIR",
    cst_ENOTEMPTY = "ENOTEMPTY",
    cst_ENOTTY = "ENOTTY",
    cst_ENXIO = "ENXIO",
    cst_EPERM = "EPERM",
    cst_EPIPE = "EPIPE",
    cst_ERANGE = "ERANGE",
    cst_EROFS = "EROFS",
    cst_ESPIPE = "ESPIPE",
    cst_ESRCH = "ESRCH",
    cst_EXDEV = "EXDEV",
    cst_EWOULDBLOCK = "EWOULDBLOCK",
    cst_EINPROGRESS = "EINPROGRESS",
    cst_EALREADY = "EALREADY",
    cst_ENOTSOCK = "ENOTSOCK",
    cst_EDESTADDRREQ = "EDESTADDRREQ",
    cst_EMSGSIZE = "EMSGSIZE",
    cst_EPROTOTYPE = "EPROTOTYPE",
    cst_ENOPROTOOPT = "ENOPROTOOPT",
    cst_EPROTONOSUPPORT = "EPROTONOSUPPORT",
    cst_ESOCKTNOSUPPORT = "ESOCKTNOSUPPORT",
    cst_EOPNOTSUPP = "EOPNOTSUPP",
    cst_EPFNOSUPPORT = "EPFNOSUPPORT",
    cst_EAFNOSUPPORT = "EAFNOSUPPORT",
    cst_EADDRINUSE = "EADDRINUSE",
    cst_EADDRNOTAVAIL = "EADDRNOTAVAIL",
    cst_ENETDOWN = "ENETDOWN",
    cst_ENETUNREACH = "ENETUNREACH",
    cst_ENETRESET = "ENETRESET",
    cst_ECONNABORTED = "ECONNABORTED",
    cst_ECONNRESET = "ECONNRESET",
    cst_ENOBUFS = "ENOBUFS",
    cst_EISCONN = "EISCONN",
    cst_ENOTCONN = "ENOTCONN",
    cst_ESHUTDOWN = "ESHUTDOWN",
    cst_ETOOMANYREFS = "ETOOMANYREFS",
    cst_ETIMEDOUT = "ETIMEDOUT",
    cst_ECONNREFUSED = "ECONNREFUSED",
    cst_EHOSTDOWN = "EHOSTDOWN",
    cst_EHOSTUNREACH = "EHOSTUNREACH",
    cst_ELOOP = "ELOOP",
    cst_EOVERFLOW = "EOVERFLOW",
    _C_ = [0, [11, "EUNKNOWNERR ", [4, 0, 0, 0, 0]], "EUNKNOWNERR %d"],
    _B_ =
      [0,
       [11,
        "Unix.Unix_error(Unix.",
        [2, 0, [11, cst$5, [3, 0, [11, cst$5, [3, 0, [12, 41, 0]]]]]]],
       "Unix.Unix_error(Unix.%s, %S, %S)"],
    cst_cmd_exe_c = "cmd.exe /c ",
    cst_c = "-c",
    cst_bin_sh = cst_bin_sh$1,
    cst_bin_sh$0 = cst_bin_sh$1,
    _y_ = [254, 0., 0.],
    cst_connect = "connect",
    _u_ = [0, 0],
    _v_ = [0, 0],
    _w_ = [0, 0],
    _s_ = [0, 0],
    _t_ = [0, 0],
    _r_ = [0, 0],
    cst_Lwt_unix_send_msgto = "Lwt_unix.send_msgto",
    cst_Lwt_unix_send_msg = "Lwt_unix.send_msg",
    cst_Lwt_unix_recv_msg = "Lwt_unix.recv_msg",
    cst_Lwt_unix_sendto = "Lwt_unix.sendto",
    cst_Lwt_unix_recvfrom = "Lwt_unix.recvfrom",
    cst_Lwt_unix_send = "Lwt_unix.send",
    cst_Lwt_unix_recv = "Lwt_unix.recv",
    cst_Lwt_unix_closedir = "Lwt_unix.closedir",
    cst_Lwt_unix_rewinddir = "Lwt_unix.rewinddir",
    cst_Lwt_unix_readdir_n$0 = cst_Lwt_unix_readdir_n$1,
    cst_Lwt_unix_readdir_n = cst_Lwt_unix_readdir_n$1,
    cst_Lwt_unix_readdir = "Lwt_unix.readdir",
    cst_Lwt_unix_writev = cst_Lwt_unix_writev$1,
    cst_Lwt_unix_writev$0 = cst_Lwt_unix_writev$1,
    cst_Lwt_unix_readv = cst_Lwt_unix_readv$1,
    cst_Lwt_unix_readv$0 = cst_Lwt_unix_readv$1,
    cst_Lwt_unix_pwrite = "Lwt_unix.pwrite",
    cst_Lwt_unix_write = "Lwt_unix.write",
    cst_Lwt_unix_pread = "Lwt_unix.pread",
    cst_Lwt_unix_read = "Lwt_unix.read",
    cst_check_descriptor = "check_descriptor",
    _e_ = [0, 1],
    _d_ = [0, 2],
    _c_ = [0, 1],
    _b_ = [0, 0],
    _L_ =
      [0,
       [2,
        0,
        [11,
         ": invalid lwt async method: '",
         [2, 0, [11, "', must be 'none', 'detach' or 'switch'\n", [10, 0]]]]],
       "%s: invalid lwt async method: '%s', must be 'none', 'detach' or 'switch'\n%!"],
    cst_Lwt_unix_Timeout = "Lwt_unix.Timeout",
    _h_ = [0, 0],
    _i_ = [0, 1],
    _j_ = [0, 0],
    _k_ = [0, 1],
    _l_ = [0, 0],
    _m_ = [0, 1],
    cst_Lwt_unix_Retry = "Lwt_unix.Retry",
    cst_Lwt_unix_Retry_write = "Lwt_unix.Retry_write",
    cst_Lwt_unix_Retry_read = "Lwt_unix.Retry_read";
   try{
    var str = runtime.caml_sys_getenv("LWT_ASYNC_METHOD");
    if(caml_string_notequal(str, "detach"))
     if(caml_string_notequal(str, "none"))
      if(caml_string_notequal(str, "switch")){
       var _K_ = caml_call1(Stdlib_Filename[13], Stdlib_Sys[1]);
       caml_call3(Stdlib_Printf[3], _L_, _K_, str);
      }
      else
       default_async_method_var[1] = 2;
     else
      default_async_method_var[1] = 0;
    else
     default_async_method_var[1] = 1;
   }
   catch(_fT_){
    var _a_ = caml_wrap_exception(_fT_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
   }
   function default_async_method(param){return default_async_method_var[1];}
   function set_default_async_method(am){
    default_async_method_var[1] = am;
    return 0;
   }
   var async_method_key = caml_call1(Lwt[49], 0);
   function async_method(param){
    var match = caml_call1(Lwt[50], async_method_key);
    if(! match) return default_async_method_var[1];
    var am = match[1];
    return am;
   }
   function with_async_none(f){
    return caml_call3(Lwt[51], async_method_key, _b_, f);
   }
   function with_async_detach(f){
    return caml_call3(Lwt[51], async_method_key, _c_, f);
   }
   function with_async_switch(f){
    return caml_call3(Lwt[51], async_method_key, _d_, f);
   }
   function equal(x, y){return x === y ? 1 : 0;}
   function hash(x){return x;}
   var
    Notifiers = caml_call1(Stdlib_Hashtbl[26], [0, equal, hash]),
    notifiers = caml_call1(Notifiers[1], 1024),
    current_notification_id = [0, 2147482647];
   function make_notification(opt, f){
    if(opt) var sth = opt[1], once = sth; else var once = 0;
    var id$1 = current_notification_id[1] + 1 | 0, id = id$1;
    for(;;){
     if(! caml_call2(Notifiers[11], notifiers, id)){
      current_notification_id[1] = id;
      caml_call3(Notifiers[5], notifiers, id, [0, f, once]);
      return id;
     }
     var id$0 = id + 1 | 0, id = id$0;
    }
   }
   function stop_notification(id){
    return caml_call2(Notifiers[6], notifiers, id);
   }
   function set_notification(id, f){
    var notifier = caml_call2(Notifiers[7], notifiers, id);
    return caml_call3(Notifiers[10], notifiers, id, [0, f, notifier[2]]);
   }
   function call_notification(id){
    try{var notifier = caml_call2(Notifiers[7], notifiers, id);}
    catch(_fS_){
     var _fR_ = caml_wrap_exception(_fS_);
     if(_fR_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_fR_, 0);
    }
    if(notifier[2]) stop_notification(id);
    return caml_call1(notifier[1], 0);
   }
   function sleep(delay){
    var match = caml_call1(Lwt[22], 0), wakener = match[2], waiter = match[1];
    function _fP_(ev){
     caml_call1(Lwt_engine[1], ev);
     return caml_call2(Lwt[52], wakener, 0);
    }
    var ev = caml_call3(Lwt_engine[6], delay, 0, _fP_);
    function _fQ_(param){return caml_call1(Lwt_engine[1], ev);}
    caml_call2(Lwt[24], waiter, _fQ_);
    return waiter;
   }
   var yield$0 = Lwt[57];
   function auto_yield(timeout){
    var limit = [0, caml_call1(Unix[101], 0) + timeout];
    return function(param){
     var current = caml_call1(Unix[101], 0);
     return limit[1] <= current
             ? (limit[1] = current + timeout, caml_call1(yield$0, 0))
             : Lwt[36];};
   }
   function auto_pause(timeout){
    var limit = [0, caml_call1(Unix[101], 0) + timeout];
    return function(param){
     var current = caml_call1(Unix[101], 0);
     return limit[1] <= current
             ? (limit[1] = current + timeout, caml_call1(Lwt[57], 0))
             : Lwt[36];};
   }
   var Timeout = [248, cst_Lwt_unix_Timeout, caml_fresh_oo_id(0)];
   function timeout(d){
    function _fN_(param){throw caml_maybe_attach_backtrace(Timeout, 1);}
    var _fO_ = sleep(d);
    return caml_call2(Lwt[33][1], _fO_, _fN_);
   }
   function with_timeout(d, f){
    var
     _fL_ = [0, caml_call2(Lwt[80], f, 0), 0],
     _fM_ = [0, timeout(d), _fL_];
    return caml_call1(Lwt[16], _fM_);
   }
   var jobs = caml_call1(Lwt_sequence[4], 0);
   function abort_jobs(exn){
    for(;;){
     var match = caml_call1(Lwt_sequence[13], jobs);
     if(! match) return 0;
     var f = match[1][2];
     caml_call1(f, exn);
    }
   }
   function cancel_jobs(param){return abort_jobs(Lwt[21]);}
   function wait_for_jobs(param){
    var _fI_ = 0;
    function _fJ_(param, l){var w = param[1]; return [0, w, l];}
    var _fK_ = caml_call3(Lwt_sequence[21], _fJ_, jobs, _fI_);
    return caml_call1(Lwt[14], _fK_);
   }
   function run_job_aux(async_method, job, result){
    if(runtime.lwt_unix_start_job(job, async_method)){
     var _fA_ = caml_call1(result, job);
     return caml_call1(Lwt[46], _fA_);
    }
    var match = caml_call1(Lwt[1], 0), wakener = match[2], waiter = match[1];
    function _fB_(exn){
     var _fH_ = 0 === caml_call1(Lwt[48], waiter) ? 1 : 0;
     return _fH_ ? caml_call2(Lwt[53], wakener, exn) : _fH_;
    }
    function _fC_(param){return Lwt[36];}
    var
     _fD_ = [0, caml_call2(Lwt[33][1], waiter, _fC_), _fB_],
     node = caml_call2(Lwt_sequence[8], _fD_, jobs),
     id =
       make_notification
        (_e_,
         function(param){
          caml_call1(Lwt_sequence[3], node);
          var
           result$0 = caml_call1(result, job),
           _fG_ = 0 === caml_call1(Lwt[48], waiter) ? 1 : 0;
          return _fG_ ? caml_call2(Lwt[54], wakener, result$0) : _fG_;
         });
    function _fE_(param){
     if(runtime.lwt_unix_check_job(job, id)) call_notification(id);
     return Lwt[36];
    }
    var _fF_ = caml_call1(Lwt[57], 0);
    caml_call2(Lwt[33][1], _fF_, _fE_);
    return waiter;
   }
   function choose_async_method(param){
    if(param){var async_method = param[1]; return async_method;}
    var match = caml_call1(Lwt[50], async_method_key);
    if(! match) return default_async_method_var[1];
    var am = match[1];
    return am;
   }
   function execute_job(async_method, job, result, free){
    var async_method$0 = choose_async_method(async_method);
    return run_job_aux
            (async_method$0,
             job,
             function(job){
              try{var _fz_ = [0, caml_call1(result, job)], x = _fz_;}
              catch(exn$0){
               var exn = caml_wrap_exception(exn$0);
               if(! caml_call1(Lwt[78][4], exn))
                throw caml_maybe_attach_backtrace(exn, 0);
               var x = [1, exn];
              }
              caml_call1(free, job);
              return x;
             });
   }
   function self_result(job){
    try{var _fy_ = [0, runtime.lwt_unix_self_result(job)]; return _fy_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(caml_call1(Lwt[78][4], exn)) return [1, exn];
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var in_retention_test = [0, 0];
   function retained(o){
    var retained = [0, 1];
    function _fv_(param){
     var
      _fw_ = in_retention_test[1],
      _fx_ = _fw_ ? (retained[1] = 0, 0) : _fw_;
     return _fx_;
    }
    caml_call2(Stdlib_Gc[3], _fv_, o);
    in_retention_test[1] = 1;
    return retained;
   }
   function run_job(async_method, job){
    if(in_retention_test[1]){
     runtime.caml_gc_full_major(0);
     in_retention_test[1] = 0;
    }
    var async_method$0 = choose_async_method(async_method);
    if(0 !== async_method$0)
     return run_job_aux(async_method$0, job, self_result);
    try{
     var
      _ft_ = runtime.lwt_unix_run_job_sync(job),
      _fu_ = caml_call1(Lwt[4], _ft_);
     return _fu_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(caml_call1(Lwt[78][4], exn)) return caml_call1(Lwt[5], exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function guess_blocking(fd){
    return run_job(0, runtime.lwt_unix_guess_blocking_job(fd));
   }
   function is_blocking(blocking, opt, fd){
    if(opt) var sth = opt[1], set_flags = sth; else var set_flags = 1;
    if(! Stdlib_Sys[7]){
     if(! blocking)
      return set_flags
              ? [246,
                function(param){
                 function _fq_(param){
                  return param
                          ? (caml_call1(Unix[58], fd), Lwt[39])
                          : (caml_call1(Unix[57], fd), Lwt[40]);
                 }
                 var _fr_ = guess_blocking(fd);
                 return caml_call2(Lwt[33][1], _fr_, _fq_);
                }]
              : [246, function(_fs_){return guess_blocking(fd);}];
     var state$1 = blocking[1];
     return set_flags
             ? state$1
               ? [246,
                 function(param){caml_call1(Unix[58], fd); return Lwt[39];}]
               : [246,
                 function(param){caml_call1(Unix[57], fd); return Lwt[40];}]
             : [246, function(_fp_){return caml_call1(Lwt[4], state$1);}];
    }
    if(runtime.lwt_unix_is_socket(fd)){
     if(! blocking)
      return set_flags
              ? [246,
                function(param){caml_call1(Unix[57], fd); return Lwt[40];}]
              : [250, Lwt[40]];
     var state = blocking[1];
     return set_flags
             ? state
               ? [246,
                 function(param){caml_call1(Unix[58], fd); return Lwt[39];}]
               : [246,
                 function(param){caml_call1(Unix[57], fd); return Lwt[40];}]
             : [246, function(_fo_){return caml_call1(Lwt[4], state);}];
    }
    if(! blocking) return [250, Lwt[39]];
    var state$0 = blocking[1];
    return [246, function(_fn_){return caml_call1(Lwt[4], state$0);}];
   }
   function of_unix_file_descr(blocking, opt, fd){
    if(opt) var sth = opt[1], set_flags = sth; else var set_flags = 1;
    var
     _fl_ = caml_call1(Lwt_sequence[4], 0),
     _fm_ = caml_call1(Lwt_sequence[4], 0);
    return [0,
            fd,
            0,
            set_flags,
            is_blocking(blocking, [0, set_flags], fd),
            0,
            0,
            _fm_,
            _fl_];
   }
   function check_descriptor(ch){
    var match = ch[2];
    if(typeof match !== "number"){
     var e = match[1];
     throw caml_maybe_attach_backtrace(e, 1);
    }
    if(match)
     throw caml_maybe_attach_backtrace
            ([0, Unix[1], 3, cst_check_descriptor, cst], 1);
    return 0;
   }
   function state(ch){return ch[2];}
   function blocking(ch){
    check_descriptor(ch);
    var _fj_ = ch[4], _fk_ = caml_obj_tag(_fj_);
    if(250 === _fk_) return _fj_[1];
    if(246 !== _fk_ && 244 !== _fk_) return _fj_;
    return caml_call1(CamlinternalLazy[2], _fj_);
   }
   function set_blocking(opt, ch, blocking){
    if(opt) var sth = opt[1], set_flags = sth; else var set_flags = 1;
    check_descriptor(ch);
    ch[3] = set_flags;
    ch[4] = is_blocking([0, blocking], [0, set_flags], ch[1]);
    return 0;
   }
   function unix_readable(fd){
    for(;;)
     try{
      var
       _fh_ =
         Stdlib_Sys[7]
          ? caml_notequal(caml_call4(Unix[93], [0, fd, 0], 0, 0, 0.), _f_)
          : runtime.lwt_unix_readable(fd);
      return _fh_;
     }
     catch(_fi_){
      var _ff_ = caml_wrap_exception(_fi_);
      if(_ff_[1] === Unix[1]){
       var _fg_ = _ff_[2];
       if(typeof _fg_ === "number" && 11 === _fg_) continue;
      }
      throw caml_maybe_attach_backtrace(_ff_, 0);
     }
   }
   function unix_writable(fd){
    for(;;)
     try{
      var
       _fd_ =
         Stdlib_Sys[7]
          ? caml_notequal(caml_call4(Unix[93], 0, [0, fd, 0], 0, 0.), _g_)
          : runtime.lwt_unix_writable(fd);
      return _fd_;
     }
     catch(_fe_){
      var _fb_ = caml_wrap_exception(_fe_);
      if(_fb_[1] === Unix[1]){
       var _fc_ = _fb_[2];
       if(typeof _fc_ === "number" && 11 === _fc_) continue;
      }
      throw caml_maybe_attach_backtrace(_fb_, 0);
     }
   }
   function readable(ch){check_descriptor(ch); return unix_readable(ch[1]);}
   function writable(ch){check_descriptor(ch); return unix_writable(ch[1]);}
   function set_state(ch, st){ch[2] = st; return;}
   function clear_events(ch){
    var _e9_ = ch[7];
    function _e__(node){
     caml_call1(Lwt_sequence[3], node);
     return caml_call2(Lwt_sequence[1], node, 0);
    }
    caml_call2(Lwt_sequence[19], _e__, _e9_);
    var _e$_ = ch[8];
    function _fa_(node){
     caml_call1(Lwt_sequence[3], node);
     return caml_call2(Lwt_sequence[1], node, 0);
    }
    caml_call2(Lwt_sequence[19], _fa_, _e$_);
    var match = ch[5];
    if(match){var ev = match[1]; ch[5] = 0; caml_call1(Lwt_engine[1], ev);}
    var match$0 = ch[6];
    if(! match$0) return 0;
    var ev$0 = match$0[1];
    ch[6] = 0;
    return caml_call1(Lwt_engine[1], ev$0);
   }
   function abort(ch, e){
    var _e8_ = 1 !== ch[2] ? 1 : 0;
    return _e8_ ? (set_state(ch, [0, e]), clear_events(ch)) : _e8_;
   }
   function unix_file_descr(ch){return ch[1];}
   var
    stdin = of_unix_file_descr(_i_, _h_, Unix[21]),
    stdout = of_unix_file_descr(_k_, _j_, Unix[22]),
    stderr = of_unix_file_descr(_m_, _l_, Unix[23]),
    Retry = [248, cst_Lwt_unix_Retry, caml_fresh_oo_id(0)],
    Retry_write = [248, cst_Lwt_unix_Retry_write, caml_fresh_oo_id(0)],
    Retry_read = [248, cst_Lwt_unix_Retry_read, caml_fresh_oo_id(0)];
   function stop_events(ch){
    function _e4_(param){
     if(caml_call1(Lwt_sequence[6], ch[7])){
      var match = ch[5];
      if(match){var ev = match[1]; ch[5] = 0; caml_call1(Lwt_engine[1], ev);}
     }
     var _e6_ = caml_call1(Lwt_sequence[6], ch[8]);
     if(_e6_){
      var match$0 = ch[6];
      if(match$0){
       var ev$0 = match$0[1];
       ch[6] = 0;
       return caml_call1(Lwt_engine[1], ev$0);
      }
      var _e7_ = 0;
     }
     else
      var _e7_ = _e6_;
     return _e7_;
    }
    var _e5_ = caml_call1(Lwt[57], 0);
    return caml_call2(Lwt[29], _e5_, _e4_);
   }
   function register_readable(ch){
    var _eZ_ = 0 === ch[5] ? 1 : 0;
    if(_eZ_){
     var
      _e0_ =
        function(param){
         var _e2_ = ch[7];
         function _e3_(f){return caml_call1(f, 0);}
         return caml_call2(Lwt_sequence[17], _e3_, _e2_);
        };
     ch[5] = [0, caml_call2(Lwt_engine[4], ch[1], _e0_)];
     var _e1_ = 0;
    }
    else
     var _e1_ = _eZ_;
    return _e1_;
   }
   function register_writable(ch){
    var _eU_ = 0 === ch[6] ? 1 : 0;
    if(_eU_){
     var
      _eV_ =
        function(param){
         var _eX_ = ch[8];
         function _eY_(f){return caml_call1(f, 0);}
         return caml_call2(Lwt_sequence[17], _eY_, _eX_);
        };
     ch[6] = [0, caml_call2(Lwt_engine[5], ch[1], _eV_)];
     var _eW_ = 0;
    }
    else
     var _eW_ = _eU_;
    return _eW_;
   }
   function retry_syscall(node, event, ch, wakener, action){
    try{
     check_descriptor(ch);
     var _eT_ = [0, caml_call1(action, 0)], res = _eT_;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     a:
     {
      b:
      if(e !== Retry){
       c:
       {
        if(e[1] !== Unix[1]){
         if(e === Stdlib[14]) break b;
         if(e === Retry_read)
          var _eS_ = _n_;
         else{if(e !== Retry_write) break c; var _eS_ = _o_;}
         var _eK_ = _eS_;
         break a;
        }
        var _eQ_ = e[2];
        if(typeof _eQ_ === "number"){
         var _eR_ = _eQ_ - 2 | 0;
         if(9 < _eR_ >>> 0){
          if(35 !== _eR_) break c;
         }
         else if(7 >= _eR_ - 1 >>> 0) break c;
         break b;
        }
       }
       if(! caml_call1(Lwt[78][4], e))
        throw caml_maybe_attach_backtrace(e, 0);
       var _eK_ = [1, e];
       break a;
      }
      var _eK_ = [2, event];
     }
     var res = _eK_;
    }
    switch(res[0]){
      case 0:
       var v = res[1];
       caml_call1(Lwt_sequence[3], node[1]);
       stop_events(ch);
       return caml_call2(Lwt[52], wakener, v);
      case 1:
       var e$0 = res[1];
       caml_call1(Lwt_sequence[3], node[1]);
       stop_events(ch);
       return caml_call2(Lwt[53], wakener, e$0);
      default:
       var event$0 = res[1], _eL_ = event !== event$0 ? 1 : 0;
       if(! _eL_) return _eL_;
       caml_call1(Lwt_sequence[3], node[1]);
       stop_events(ch);
       if(event$0){
        var
         _eM_ = ch[8],
         _eN_ =
           function(param){
            return retry_syscall(node, 1, ch, wakener, action);
           };
        node[1] = caml_call2(Lwt_sequence[9], _eN_, _eM_);
        return register_writable(ch);
       }
       var
        _eO_ = ch[7],
        _eP_ =
          function(param){return retry_syscall(node, 0, ch, wakener, action);};
       node[1] = caml_call2(Lwt_sequence[9], _eP_, _eO_);
       return register_readable(ch);
    }
   }
   var _p_ = caml_call1(Lwt_sequence[4], 0);
   function _q_(_eJ_){return 0;}
   var dummy = caml_call2(Lwt_sequence[9], _q_, _p_);
   function register_action(event, ch, action){
    var match = caml_call1(Lwt[22], 0), wakener = match[2], waiter = match[1];
    if(event){
     var
      node = [0, dummy],
      _eD_ = ch[8],
      _eE_ =
        function(param){return retry_syscall(node, 1, ch, wakener, action);};
     node[1] = caml_call2(Lwt_sequence[9], _eE_, _eD_);
     var
      _eF_ =
        function(param){
         caml_call1(Lwt_sequence[3], node[1]);
         return stop_events(ch);
        };
     caml_call2(Lwt[24], waiter, _eF_);
     register_writable(ch);
     return waiter;
    }
    var node$0 = [0, dummy], _eG_ = ch[7];
    function _eH_(param){
     return retry_syscall(node$0, 0, ch, wakener, action);
    }
    node$0[1] = caml_call2(Lwt_sequence[9], _eH_, _eG_);
    function _eI_(param){
     caml_call1(Lwt_sequence[3], node$0[1]);
     return stop_events(ch);
    }
    caml_call2(Lwt[24], waiter, _eI_);
    register_readable(ch);
    return waiter;
   }
   function wrap_syscall(event, ch, action){
    check_descriptor(ch);
    function _ev_(blocking){
     try{
      a:
      {
       b:
       if(blocking){
        if(0 === event && unix_readable(ch[1])) break b;
        if(1 === event && unix_writable(ch[1])) break b;
        var _eC_ = register_action(event, ch, action);
        break a;
       }
       var _eB_ = caml_call1(action, 0), _eC_ = caml_call1(Lwt[4], _eB_);
      }
      return _eC_;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      a:
      if(e !== Retry){
       b:
       if(e[1] === Unix[1]){
        var _ez_ = e[2];
        if(typeof _ez_ === "number"){
         var _eA_ = _ez_ - 2 | 0;
         if(9 < _eA_ >>> 0){
          if(35 !== _eA_) break b;
         }
         else if(7 >= _eA_ - 1 >>> 0) break b;
         break a;
        }
       }
       else{
        if(e === Stdlib[14]) break a;
        if(e === Retry_read) return register_action(0, ch, action);
        if(e === Retry_write) return register_action(1, ch, action);
       }
       if(caml_call1(Lwt[78][4], e)) throw caml_maybe_attach_backtrace(e, 0);
       throw caml_maybe_attach_backtrace(e, 0);
      }
      return register_action(event, ch, action);
     }
    }
    var _ew_ = ch[4], _ex_ = caml_obj_tag(_ew_);
    a:
    if(250 === _ex_)
     var _ey_ = _ew_[1];
    else{
     if(246 !== _ex_ && 244 !== _ex_){var _ey_ = _ew_; break a;}
     var _ey_ = caml_call1(CamlinternalLazy[2], _ew_);
    }
    return caml_call2(Lwt[33][1], _ey_, _ev_);
   }
   function openfile(name, flags, perms){
    if(Stdlib_Sys[7]){
     var
      _er_ =
        of_unix_file_descr(0, 0, caml_call3(Unix[24], name, flags, perms));
     return caml_call1(Lwt[4], _er_);
    }
    function _es_(param){
     var
      blocking = param[2],
      fd = param[1],
      _eu_ = of_unix_file_descr([0, blocking], 0, fd);
     return caml_call1(Lwt[4], _eu_);
    }
    var _et_ = run_job(0, runtime.lwt_unix_open_job(name, flags, perms));
    return caml_call2(Lwt[33][1], _et_, _es_);
   }
   function close(ch){
    if(1 === ch[2]) check_descriptor(ch);
    set_state(ch, 1);
    clear_events(ch);
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_close_job(ch[1]));
    var _eq_ = caml_call1(Unix[25], ch[1]);
    return caml_call1(Lwt[4], _eq_);
   }
   function wait_read(ch){
    function _em_(_ep_){throw caml_maybe_attach_backtrace(_ep_, 0);}
    function _en_(param){
     return readable(ch)
             ? Lwt[36]
             : register_action(0, ch, function(_eo_){return 0;});
    }
    return caml_call2(Lwt[7], _en_, _em_);
   }
   function read(ch, buf, pos, len){
    if(0 <= pos && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= pos){
     var
      _eg_ =
        function(param){
         if(! param)
          return wrap_syscall
                  (0,
                   ch,
                   function(param){
                    return runtime.lwt_unix_read(ch[1], buf, pos, len);
                   });
         function _ek_(param){
          return run_job(0, runtime.lwt_unix_read_job(ch[1], buf, pos, len));
         }
         var _el_ = wait_read(ch);
         return caml_call2(Lwt[33][1], _el_, _ek_);
        },
      _eh_ = ch[4],
      _ei_ = caml_obj_tag(_eh_);
     a:
     if(250 === _ei_)
      var _ej_ = _eh_[1];
     else{
      if(246 !== _ei_ && 244 !== _ei_){var _ej_ = _eh_; break a;}
      var _ej_ = caml_call1(CamlinternalLazy[2], _eh_);
     }
     return caml_call2(Lwt[33][1], _ej_, _eg_);
    }
    return caml_call1(Stdlib[1], cst_Lwt_unix_read);
   }
   function pread(ch, buf, file_offset, pos, len){
    if(0 <= pos && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= pos){
     var
      _ea_ =
        function(param){
         if(! param)
          return wrap_syscall
                  (0,
                   ch,
                   function(param){
                    return runtime.lwt_unix_pread
                            (ch[1], buf, file_offset, pos, len);
                   });
         function _ee_(param){
          return run_job
                  (0,
                   runtime.lwt_unix_pread_job
                    (ch[1], buf, file_offset, pos, len));
         }
         var _ef_ = wait_read(ch);
         return caml_call2(Lwt[33][1], _ef_, _ee_);
        },
      _eb_ = ch[4],
      _ec_ = caml_obj_tag(_eb_);
     a:
     if(250 === _ec_)
      var _ed_ = _eb_[1];
     else{
      if(246 !== _ec_ && 244 !== _ec_){var _ed_ = _eb_; break a;}
      var _ed_ = caml_call1(CamlinternalLazy[2], _eb_);
     }
     return caml_call2(Lwt[33][1], _ed_, _ea_);
    }
    return caml_call1(Stdlib[1], cst_Lwt_unix_pread);
   }
   function read_bigarray(function_name, fd, buf, pos, len){
    if(0 <= pos && 0 <= len && (caml_ba_dim_1(buf) - len | 0) >= pos){
     var
      _d8_ =
        function(param){
         if(! param)
          return wrap_syscall
                  (0,
                   fd,
                   function(param){
                    return runtime.lwt_unix_bytes_read(fd[1], buf, pos, len);
                   });
         function _d__(param){
          return run_job
                  (0, runtime.lwt_unix_bytes_read_job(fd[1], buf, pos, len));
         }
         var _d$_ = wait_read(fd);
         return caml_call2(Lwt[33][1], _d$_, _d__);
        },
      _d9_ = blocking(fd);
     return caml_call2(Lwt[33][1], _d9_, _d8_);
    }
    return caml_call1(Stdlib[1], function_name);
   }
   function wait_write(ch){
    function _d4_(_d7_){throw caml_maybe_attach_backtrace(_d7_, 0);}
    function _d5_(param){
     return writable(ch)
             ? Lwt[36]
             : register_action(1, ch, function(_d6_){return 0;});
    }
    return caml_call2(Lwt[7], _d5_, _d4_);
   }
   function write(ch, buf, pos, len){
    if(0 <= pos && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= pos){
     var
      _dY_ =
        function(param){
         if(! param)
          return wrap_syscall
                  (1,
                   ch,
                   function(param){
                    return runtime.lwt_unix_write(ch[1], buf, pos, len);
                   });
         function _d2_(param){
          return run_job(0, runtime.lwt_unix_write_job(ch[1], buf, pos, len));
         }
         var _d3_ = wait_write(ch);
         return caml_call2(Lwt[33][1], _d3_, _d2_);
        },
      _dZ_ = ch[4],
      _d0_ = caml_obj_tag(_dZ_);
     a:
     if(250 === _d0_)
      var _d1_ = _dZ_[1];
     else{
      if(246 !== _d0_ && 244 !== _d0_){var _d1_ = _dZ_; break a;}
      var _d1_ = caml_call1(CamlinternalLazy[2], _dZ_);
     }
     return caml_call2(Lwt[33][1], _d1_, _dY_);
    }
    return caml_call1(Stdlib[1], cst_Lwt_unix_write);
   }
   function pwrite(ch, buf, file_offset, pos, len){
    if(0 <= pos && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= pos){
     var
      _dS_ =
        function(param){
         if(! param)
          return wrap_syscall
                  (1,
                   ch,
                   function(param){
                    return runtime.lwt_unix_pwrite
                            (ch[1], buf, file_offset, pos, len);
                   });
         function _dW_(param){
          return run_job
                  (0,
                   runtime.lwt_unix_pwrite_job
                    (ch[1], buf, file_offset, pos, len));
         }
         var _dX_ = wait_write(ch);
         return caml_call2(Lwt[33][1], _dX_, _dW_);
        },
      _dT_ = ch[4],
      _dU_ = caml_obj_tag(_dT_);
     a:
     if(250 === _dU_)
      var _dV_ = _dT_[1];
     else{
      if(246 !== _dU_ && 244 !== _dU_){var _dV_ = _dT_; break a;}
      var _dV_ = caml_call1(CamlinternalLazy[2], _dT_);
     }
     return caml_call2(Lwt[33][1], _dV_, _dS_);
    }
    return caml_call1(Stdlib[1], cst_Lwt_unix_pwrite);
   }
   function write_string(ch, buf, pos, len){
    var buf$0 = caml_call1(Stdlib_Bytes[45], buf);
    return write(ch, buf$0, pos, len);
   }
   function pwrite_string(ch, buf, file_offset, pos, len){
    var buf$0 = caml_call1(Stdlib_Bytes[45], buf);
    return pwrite(ch, buf$0, file_offset, pos, len);
   }
   function write_bigarray(function_name, fd, buf, pos, len){
    if(0 <= pos && 0 <= len && (caml_ba_dim_1(buf) - len | 0) >= pos){
     var
      _dO_ =
        function(param){
         if(! param)
          return wrap_syscall
                  (1,
                   fd,
                   function(param){
                    return runtime.lwt_unix_bytes_write(fd[1], buf, pos, len);
                   });
         function _dQ_(param){
          return run_job
                  (0, runtime.lwt_unix_bytes_write_job(fd[1], buf, pos, len));
         }
         var _dR_ = wait_write(fd);
         return caml_call2(Lwt[33][1], _dR_, _dQ_);
        },
      _dP_ = blocking(fd);
     return caml_call2(Lwt[33][1], _dP_, _dO_);
    }
    return caml_call1(Stdlib[1], function_name);
   }
   function create(param){return [0, 0, 0, 0];}
   function byte_count(param){
    var prefix = param[1], reversed_suffix = param[2], _dL_ = 0;
    function _dM_(acc, param){var length = param[3]; return acc + length | 0;}
    var
     count_buff = caml_call2(Stdlib_List[26], _dM_, _dL_),
     _dN_ = caml_call1(count_buff, reversed_suffix);
    return caml_call1(count_buff, prefix) + _dN_ | 0;
   }
   function append(io_vectors, io_vector){
    io_vectors[2] = [0, io_vector, io_vectors[2]];
    io_vectors[3] = io_vectors[3] + 1 | 0;
    return 0;
   }
   function append_bytes(io_vectors, buffer, offset, length){
    return append(io_vectors, [0, [0, buffer], offset, length]);
   }
   function append_bigarray(io_vectors, buffer, offset, length){
    return append(io_vectors, [0, [1, buffer], offset, length]);
   }
   function flatten(io_vectors){
    if(! io_vectors[2]) return;
    var _dK_ = caml_call1(Stdlib_List[10], io_vectors[2]);
    io_vectors[1] = caml_call2(Stdlib[37], io_vectors[1], _dK_);
    io_vectors[2] = 0;
    return;
   }
   function drop(io_vectors, count){
    flatten(io_vectors);
    var prefix$1 = io_vectors[1], count$0 = count, prefix = prefix$1;
    for(;;){
     if(0 < count$0)
      if(prefix){
       var first = prefix[1], length = first[3], prefix$0 = prefix[2];
       if(length <= count$0){
        io_vectors[3] = io_vectors[3] - 1 | 0;
        var
         count$1 = count$0 - length | 0,
         count$0 = count$1,
         prefix = prefix$0;
        continue;
       }
       first[2] = first[2] + count$0 | 0;
       first[3] = first[3] - count$0 | 0;
       var _dJ_ = prefix;
      }
      else
       var _dJ_ = 0;
     else
      var _dJ_ = prefix;
     io_vectors[1] = _dJ_;
     return 0;
    }
   }
   function is_empty(io_vectors){
    flatten(io_vectors);
    var param = io_vectors[1];
    for(;;){
     if(! param) return 1;
     if(0 !== param[1][3]) return 0;
     var rest = param[2], param = rest;
    }
   }
   var system_limit = Stdlib_Sys[7] ? 0 : runtime.lwt_unix_iov_max(0);
   function check_io_vectors(function_name, io_vectors){
    flatten(io_vectors);
    var _dE_ = io_vectors[1];
    function _dF_(io_vector){
     var match = io_vector[1];
     if(0 === match[0])
      var s = match[1], buffer_length = caml_ml_bytes_length(s);
     else
      var a = match[1], buffer_length = caml_ba_dim_1(a);
     var _dG_ = io_vector[3] < 0 ? 1 : 0;
     if(_dG_)
      var _dH_ = _dG_;
     else
      var
       _dI_ = io_vector[2] < 0 ? 1 : 0,
       _dH_ =
         _dI_ || (buffer_length < (io_vector[2] + io_vector[3] | 0) ? 1 : 0);
     return _dH_ ? caml_call1(Stdlib[1], function_name) : _dH_;
    }
    caml_call2(Stdlib_List[18], _dF_, _dE_);
    if(system_limit){
     var limit = system_limit[1];
     if(limit < io_vectors[3]) return limit;
    }
    return io_vectors[3];
   }
   function readv(fd, io_vectors){
    var count = check_io_vectors(cst_Lwt_unix_readv, io_vectors);
    if(Stdlib_Sys[7]){
     var match = io_vectors[1];
     if(! match) return caml_call1(Lwt[4], 0);
     var first = match[1], match$0 = first[1];
     if(0 === match$0[0]){
      var buffer = match$0[1];
      return read(fd, buffer, first[2], first[3]);
     }
     var buffer$0 = match$0[1];
     return read_bigarray
             (cst_Lwt_unix_readv$0, fd, buffer$0, first[2], first[3]);
    }
    function _dy_(param){
     if(! param)
      return wrap_syscall
              (0,
               fd,
               function(param){
                return runtime.lwt_unix_readv(fd[1], io_vectors[1], count);
               });
     function _dC_(param){
      return run_job(0, runtime.lwt_unix_readv_job(fd[1], io_vectors, count));
     }
     var _dD_ = wait_read(fd);
     return caml_call2(Lwt[33][1], _dD_, _dC_);
    }
    var _dz_ = fd[4], _dA_ = caml_obj_tag(_dz_);
    a:
    if(250 === _dA_)
     var _dB_ = _dz_[1];
    else{
     if(246 !== _dA_ && 244 !== _dA_){var _dB_ = _dz_; break a;}
     var _dB_ = caml_call1(CamlinternalLazy[2], _dz_);
    }
    return caml_call2(Lwt[33][1], _dB_, _dy_);
   }
   function writev(fd, io_vectors){
    var count = check_io_vectors(cst_Lwt_unix_writev, io_vectors);
    if(Stdlib_Sys[7]){
     var match = io_vectors[1];
     if(! match) return caml_call1(Lwt[4], 0);
     var first = match[1], match$0 = first[1];
     if(0 === match$0[0]){
      var buffer = match$0[1];
      return write(fd, buffer, first[2], first[3]);
     }
     var buffer$0 = match$0[1];
     return write_bigarray
             (cst_Lwt_unix_writev$0, fd, buffer$0, first[2], first[3]);
    }
    function _ds_(param){
     if(! param)
      return wrap_syscall
              (1,
               fd,
               function(param){
                return runtime.lwt_unix_writev(fd[1], io_vectors[1], count);
               });
     function _dw_(param){
      return run_job(0, runtime.lwt_unix_writev_job(fd[1], io_vectors, count));
     }
     var _dx_ = wait_write(fd);
     return caml_call2(Lwt[33][1], _dx_, _dw_);
    }
    var _dt_ = fd[4], _du_ = caml_obj_tag(_dt_);
    a:
    if(250 === _du_)
     var _dv_ = _dt_[1];
    else{
     if(246 !== _du_ && 244 !== _du_){var _dv_ = _dt_; break a;}
     var _dv_ = caml_call1(CamlinternalLazy[2], _dt_);
    }
    return caml_call2(Lwt[33][1], _dv_, _ds_);
   }
   function lseek(ch, offset, whence){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_lseek_job(ch[1], offset, whence));
    var _dr_ = caml_call3(Unix[36], ch[1], offset, whence);
    return caml_call1(Lwt[4], _dr_);
   }
   function truncate(name, offset){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_truncate_job(name, offset));
    var _dq_ = caml_call2(Unix[37], name, offset);
    return caml_call1(Lwt[4], _dq_);
   }
   function ftruncate(ch, offset){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_ftruncate_job(ch[1], offset));
    var _dp_ = caml_call2(Unix[38], ch[1], offset);
    return caml_call1(Lwt[4], _dp_);
   }
   function fdatasync(ch){
    check_descriptor(ch);
    return run_job(0, runtime.lwt_unix_fdatasync_job(ch[1]));
   }
   function fsync(ch){
    check_descriptor(ch);
    return run_job(0, runtime.lwt_unix_fsync_job(ch[1]));
   }
   function stat(name){
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_stat_job(name));
    var _do_ = caml_call1(Unix[39], name);
    return caml_call1(Lwt[4], _do_);
   }
   function lstat(name){
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_lstat_job(name));
    var _dn_ = caml_call1(Unix[40], name);
    return caml_call1(Lwt[4], _dn_);
   }
   function fstat(ch){
    check_descriptor(ch);
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_fstat_job(ch[1]));
    var _dm_ = caml_call1(Unix[41], ch[1]);
    return caml_call1(Lwt[4], _dm_);
   }
   function file_exists(name){
    function _dj_(e){
     if(e[1] === Unix[1]) return Lwt[40];
     throw caml_maybe_attach_backtrace(e, 0);
    }
    function _dk_(param){return Lwt[39];}
    function _dl_(param){return stat(name);}
    return caml_call3(Lwt[9], _dl_, _dk_, _dj_);
   }
   function utimes(path, atime, mtime){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_utimes_job(path, atime, mtime));
    var _di_ = caml_call3(Unix[109], path, atime, mtime);
    return caml_call1(Lwt[4], _di_);
   }
   function isatty(ch){
    check_descriptor(ch);
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_isatty_job(ch[1]));
    var _dh_ = caml_call1(Unix[42], ch[1]);
    return caml_call1(Lwt[4], _dh_);
   }
   function lseek$0(ch, offset, whence){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_lseek_64_job(ch[1], offset, whence));
    var _dg_ = caml_call3(Unix[43][1], ch[1], offset, whence);
    return caml_call1(Lwt[4], _dg_);
   }
   function truncate$0(name, offset){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_truncate_64_job(name, offset));
    var _df_ = caml_call2(Unix[43][2], name, offset);
    return caml_call1(Lwt[4], _df_);
   }
   function ftruncate$0(ch, offset){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_ftruncate_64_job(ch[1], offset));
    var _de_ = caml_call2(Unix[43][3], ch[1], offset);
    return caml_call1(Lwt[4], _de_);
   }
   function stat$0(name){
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_stat_64_job(name));
    var _dd_ = caml_call1(Unix[43][4], name);
    return caml_call1(Lwt[4], _dd_);
   }
   function lstat$0(name){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_lstat_64_job(name));
    var _dc_ = caml_call1(Unix[43][5], name);
    return caml_call1(Lwt[4], _dc_);
   }
   function fstat$0(ch){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_fstat_64_job(ch[1]));
    var _db_ = caml_call1(Unix[43][6], ch[1]);
    return caml_call1(Lwt[4], _db_);
   }
   function file_exists$0(name){
    function _c__(e){
     if(e[1] === Unix[1]) return Lwt[40];
     throw caml_maybe_attach_backtrace(e, 0);
    }
    function _c$_(param){return Lwt[39];}
    function _da_(param){return stat$0(name);}
    return caml_call3(Lwt[9], _da_, _c$_, _c__);
   }
   var
    LargeFile =
      [0,
       lseek$0,
       truncate$0,
       ftruncate$0,
       stat$0,
       lstat$0,
       fstat$0,
       file_exists$0];
   function unlink(name){
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_unlink_job(name));
    var _c9_ = caml_call1(Unix[45], name);
    return caml_call1(Lwt[4], _c9_);
   }
   function rename(name1, name2){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_rename_job(name1, name2));
    var _c8_ = caml_call2(Unix[46], name1, name2);
    return caml_call1(Lwt[4], _c8_);
   }
   function link(oldpath, newpath){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_link_job(oldpath, newpath));
    var _c7_ = caml_call3(Unix[47], 0, oldpath, newpath);
    return caml_call1(Lwt[4], _c7_);
   }
   function chmod(name, mode){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_chmod_job(name, mode));
    var _c6_ = caml_call2(Unix[49], name, mode);
    return caml_call1(Lwt[4], _c6_);
   }
   function fchmod(ch, mode){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_fchmod_job(ch[1], mode));
    var _c5_ = caml_call2(Unix[50], ch[1], mode);
    return caml_call1(Lwt[4], _c5_);
   }
   function chown(name, uid, gid){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_chown_job(name, uid, gid));
    var _c4_ = caml_call3(Unix[51], name, uid, gid);
    return caml_call1(Lwt[4], _c4_);
   }
   function fchown(ch, uid, gid){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_fchown_job(ch[1], uid, gid));
    var _c3_ = caml_call3(Unix[52], ch[1], uid, gid);
    return caml_call1(Lwt[4], _c3_);
   }
   function access(name, mode){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_access_job(name, mode));
    var _c2_ = caml_call2(Unix[54], name, mode);
    return caml_call1(Lwt[4], _c2_);
   }
   function dup(cloexec, ch){
    check_descriptor(ch);
    var
     fd = caml_call2(Unix[55], cloexec, ch[1]),
     _cQ_ = caml_call1(Lwt_sequence[4], 0),
     _cR_ = caml_call1(Lwt_sequence[4], 0),
     _cS_ = 0,
     _cT_ = 0,
     _cU_ =
       ch[3]
        ? [246,
          function(_cV_){
           function _cW_(blocking){
            var
             _c0_ = is_blocking([0, blocking], 0, fd),
             _c1_ = caml_obj_tag(_c0_);
            if(250 === _c1_) return _c0_[1];
            if(246 !== _c1_ && 244 !== _c1_) return _c0_;
            return caml_call1(CamlinternalLazy[2], _c0_);
           }
           var _cX_ = ch[4], _cY_ = caml_obj_tag(_cX_);
           a:
           if(250 === _cY_)
            var _cZ_ = _cX_[1];
           else{
            if(246 !== _cY_ && 244 !== _cY_){var _cZ_ = _cX_; break a;}
            var _cZ_ = caml_call1(CamlinternalLazy[2], _cX_);
           }
           return caml_call2(Lwt[33][1], _cZ_, _cW_);
          }]
        : ch[4];
    return [0, fd, 0, ch[3], _cU_, _cT_, _cS_, _cR_, _cQ_];
   }
   function dup2(cloexec, ch1, ch2){
    check_descriptor(ch1);
    caml_call3(Unix[56], cloexec, ch1[1], ch2[1]);
    ch2[3] = ch1[3];
    var
     _cI_ =
       ch2[3]
        ? [246,
          function(_cJ_){
           function _cK_(blocking){
            var
             _cO_ = is_blocking([0, blocking], 0, ch2[1]),
             _cP_ = caml_obj_tag(_cO_);
            if(250 === _cP_) return _cO_[1];
            if(246 !== _cP_ && 244 !== _cP_) return _cO_;
            return caml_call1(CamlinternalLazy[2], _cO_);
           }
           var _cL_ = ch1[4], _cM_ = caml_obj_tag(_cL_);
           a:
           if(250 === _cM_)
            var _cN_ = _cL_[1];
           else{
            if(246 !== _cM_ && 244 !== _cM_){var _cN_ = _cL_; break a;}
            var _cN_ = caml_call1(CamlinternalLazy[2], _cL_);
           }
           return caml_call2(Lwt[33][1], _cN_, _cK_);
          }]
        : ch1[4];
    ch2[4] = _cI_;
    return 0;
   }
   function set_close_on_exec(ch){
    check_descriptor(ch);
    return caml_call1(Unix[59], ch[1]);
   }
   function clear_close_on_exec(ch){
    check_descriptor(ch);
    return caml_call1(Unix[60], ch[1]);
   }
   function mkdir(name, perms){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_mkdir_job(name, perms));
    var _cH_ = caml_call2(Unix[61], name, perms);
    return caml_call1(Lwt[4], _cH_);
   }
   function rmdir(name){
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_rmdir_job(name));
    var _cG_ = caml_call1(Unix[62], name);
    return caml_call1(Lwt[4], _cG_);
   }
   function chdir(name){
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_chdir_job(name));
    var _cF_ = caml_call1(Unix[63], name);
    return caml_call1(Lwt[4], _cF_);
   }
   function getcwd(param){
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_getcwd_job(0));
    var _cE_ = caml_call1(Unix[64], 0);
    return caml_call1(Lwt[4], _cE_);
   }
   function chroot(name){
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_chroot_job(name));
    var _cD_ = caml_call1(Unix[65], name);
    return caml_call1(Lwt[4], _cD_);
   }
   function opendir(name){
    if(! Stdlib_Sys[7]) return run_job(0, runtime.lwt_unix_opendir_job(name));
    var _cC_ = caml_call1(Unix[66], name);
    return caml_call1(Lwt[4], _cC_);
   }
   function readdir(handle){
    if(! Stdlib_Sys[7])
     return runtime.lwt_unix_valid_dir(handle)
             ? run_job(0, runtime.lwt_unix_readdir_job(handle))
             : caml_call1
               (Lwt[5], [0, Unix[1], 3, cst_Lwt_unix_readdir, cst$0]);
    var _cB_ = caml_call1(Unix[67], handle);
    return caml_call1(Lwt[4], _cB_);
   }
   function readdir_n(handle, count){
    if(0 > count)
     return caml_call1(Lwt[5], [0, Stdlib[6], cst_Lwt_unix_readdir_n$0]);
    if(! Stdlib_Sys[7])
     return runtime.lwt_unix_valid_dir(handle)
             ? run_job(0, runtime.lwt_unix_readdir_n_job(handle, count))
             : caml_call1
               (Lwt[5], [0, Unix[1], 3, cst_Lwt_unix_readdir_n, cst$1]);
    var array = runtime.caml_make_vect(count, cst$6), i = 0;
    for(;;){
     if(i === count) return caml_call1(Lwt[4], array);
     try{
      var _cz_ = caml_call1(Unix[67], handle);
      runtime.caml_check_bound(array, i)[1 + i] = _cz_;
     }
     catch(_cA_){
      var _cx_ = caml_wrap_exception(_cA_);
      if(_cx_ !== Stdlib[12]) throw caml_maybe_attach_backtrace(_cx_, 0);
      var _cy_ = caml_call3(Stdlib_Array[5], array, 0, i);
      return caml_call1(Lwt[4], _cy_);
     }
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function rewinddir(handle){
    if(! Stdlib_Sys[7])
     return runtime.lwt_unix_valid_dir(handle)
             ? run_job(0, runtime.lwt_unix_rewinddir_job(handle))
             : caml_call1
               (Lwt[5], [0, Unix[1], 3, cst_Lwt_unix_rewinddir, cst$2]);
    var _cw_ = caml_call1(Unix[68], handle);
    return caml_call1(Lwt[4], _cw_);
   }
   function closedir(handle){
    if(Stdlib_Sys[7]){
     var _ct_ = caml_call1(Unix[69], handle);
     return caml_call1(Lwt[4], _ct_);
    }
    if(! runtime.lwt_unix_valid_dir(handle))
     return caml_call1(Lwt[5], [0, Unix[1], 3, cst_Lwt_unix_closedir, cst$3]);
    function _cu_(param){
     runtime.lwt_unix_invalidate_dir(handle);
     return Lwt[36];
    }
    var _cv_ = run_job(0, runtime.lwt_unix_closedir_job(handle));
    return caml_call2(Lwt[33][1], _cv_, _cu_);
   }
   function cleanup_dir_handle(state){
    var match = state[1];
    if(typeof match === "number") return 0;
    var handle = match[1];
    closedir(handle);
    return 0;
   }
   function files_of_directory(path){
    var state = [0, 0], chunk_size = 1024;
    function _b7_(param){
     var match = state[1];
     if(typeof match !== "number"){
      var
       handle = match[1],
       _b$_ =
         function(entries){
          if(entries.length - 1 < 1024){
           state[1] = 1;
           var
            _cp_ =
              function(param){
               var _cs_ = [0, caml_call1(Lwt_stream[13], entries)];
               return caml_call1(Lwt[4], _cs_);
              },
            _cq_ = closedir(handle);
           return caml_call2(Lwt[33][1], _cq_, _cp_);
          }
          var _cr_ = [0, caml_call1(Lwt_stream[13], entries)];
          return caml_call1(Lwt[4], _cr_);
         },
       _ca_ =
         function(exn){
          function _cn_(param){throw caml_maybe_attach_backtrace(exn, 0);}
          var _co_ = closedir(handle);
          return caml_call2(Lwt[33][1], _co_, _cn_);
         },
       _cb_ = function(param){return readdir_n(handle, chunk_size);},
       _cc_ = caml_call2(Lwt[7], _cb_, _ca_);
      return caml_call2(Lwt[33][1], _cc_, _b$_);
     }
     if(match) return Lwt[37];
     function _b9_(handle){
      function _cd_(entries){
       if(entries.length - 1 < 1024){
        state[1] = 1;
        var
         _cj_ =
           function(param){
            var _cm_ = [0, caml_call1(Lwt_stream[13], entries)];
            return caml_call1(Lwt[4], _cm_);
           },
         _ck_ = closedir(handle);
        return caml_call2(Lwt[33][1], _ck_, _cj_);
       }
       state[1] = [0, handle];
       caml_call2(Stdlib_Gc[3], cleanup_dir_handle, state);
       var _cl_ = [0, caml_call1(Lwt_stream[13], entries)];
       return caml_call1(Lwt[4], _cl_);
      }
      function _ce_(exn){
       function _ch_(param){throw caml_maybe_attach_backtrace(exn, 0);}
       var _ci_ = closedir(handle);
       return caml_call2(Lwt[33][1], _ci_, _ch_);
      }
      function _cf_(param){return readdir_n(handle, chunk_size);}
      var _cg_ = caml_call2(Lwt[7], _cf_, _ce_);
      return caml_call2(Lwt[33][1], _cg_, _cd_);
     }
     var _b__ = opendir(path);
     return caml_call2(Lwt[33][1], _b__, _b9_);
    }
    var _b8_ = caml_call1(Lwt_stream[1], _b7_);
    return caml_call1(Lwt_stream[59], _b8_);
   }
   function pipe(cloexec, param){
    var
     match = caml_call2(Unix[70], cloexec, 0),
     in_fd = match[2],
     out_fd = match[1],
     _b6_ = of_unix_file_descr([0, Stdlib_Sys[7]], 0, in_fd);
    return [0, of_unix_file_descr([0, Stdlib_Sys[7]], 0, out_fd), _b6_];
   }
   function pipe_in(cloexec, param){
    var
     match = caml_call2(Unix[70], cloexec, 0),
     in_fd = match[2],
     out_fd = match[1];
    return [0, of_unix_file_descr([0, Stdlib_Sys[7]], 0, out_fd), in_fd];
   }
   function pipe_out(cloexec, param){
    var
     match = caml_call2(Unix[70], cloexec, 0),
     in_fd = match[2],
     out_fd = match[1];
    return [0, out_fd, of_unix_file_descr([0, Stdlib_Sys[7]], 0, in_fd)];
   }
   function mkfifo(name, perms){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_mkfifo_job(name, perms));
    var _b5_ = caml_call2(Unix[71], name, perms);
    return caml_call1(Lwt[4], _b5_);
   }
   function symlink(to_dir, name1, name2){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_symlink_job(name1, name2));
    var _b4_ = caml_call3(Unix[90], to_dir, name1, name2);
    return caml_call1(Lwt[4], _b4_);
   }
   function readlink(name){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_readlink_job(name));
    var _b3_ = caml_call1(Unix[92], name);
    return caml_call1(Lwt[4], _b3_);
   }
   function lockf(ch, cmd, size){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_lockf_job(ch[1], cmd, size));
    var _b2_ = caml_call3(Unix[94], ch[1], cmd, size);
    return caml_call1(Lwt[4], _b2_);
   }
   function getlogin(param){
    if(! Stdlib_Sys[7] && ! Lwt_config[1])
     return run_job(0, runtime.lwt_unix_getlogin_job(0));
    var _b1_ = caml_call1(Unix[121], 0);
    return caml_call1(Lwt[4], _b1_);
   }
   function getpwnam(name){
    if(! Stdlib_Sys[7] && ! Lwt_config[1])
     return run_job(0, runtime.lwt_unix_getpwnam_job(name));
    var _b0_ = caml_call1(Unix[122], name);
    return caml_call1(Lwt[4], _b0_);
   }
   function getgrnam(name){
    if(! Stdlib_Sys[7] && ! Lwt_config[1])
     return run_job(0, runtime.lwt_unix_getgrnam_job(name));
    var _bZ_ = caml_call1(Unix[123], name);
    return caml_call1(Lwt[4], _bZ_);
   }
   function getpwuid(uid){
    if(! Stdlib_Sys[7] && ! Lwt_config[1])
     return run_job(0, runtime.lwt_unix_getpwuid_job(uid));
    var _bY_ = caml_call1(Unix[124], uid);
    return caml_call1(Lwt[4], _bY_);
   }
   function getgrgid(gid){
    if(! Stdlib_Sys[7] && ! Lwt_config[1])
     return run_job(0, runtime.lwt_unix_getgrgid_job(gid));
    var _bX_ = caml_call1(Unix[125], gid);
    return caml_call1(Lwt[4], _bX_);
   }
   function recv(ch, buf, pos, len, flags){
    if(0 <= pos && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= pos){
     var
      do_recv =
        Stdlib_Sys[7]
         ? Unix[143]
         : function
          (_bW_, _bV_, _bU_, _bT_, _bS_){
           return runtime.lwt_unix_recv(_bW_, _bV_, _bU_, _bT_, _bS_);
          };
     return wrap_syscall
             (0,
              ch,
              function(param){
               return caml_call5(do_recv, ch[1], buf, pos, len, flags);
              });
    }
    return caml_call1(Stdlib[1], cst_Lwt_unix_recv);
   }
   function send(ch, buf, pos, len, flags){
    if(0 <= pos && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= pos){
     var
      do_send =
        Stdlib_Sys[7]
         ? Unix[145]
         : function
          (_bR_, _bQ_, _bP_, _bO_, _bN_){
           return runtime.lwt_unix_send(_bR_, _bQ_, _bP_, _bO_, _bN_);
          };
     return wrap_syscall
             (1,
              ch,
              function(param){
               return caml_call5(do_send, ch[1], buf, pos, len, flags);
              });
    }
    return caml_call1(Stdlib[1], cst_Lwt_unix_send);
   }
   function recvfrom(ch, buf, pos, len, flags){
    if(0 <= pos && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= pos){
     var
      do_recvfrom =
        Stdlib_Sys[7]
         ? Unix[144]
         : function
          (_bM_, _bL_, _bK_, _bJ_, _bI_){
           return runtime.lwt_unix_recvfrom(_bM_, _bL_, _bK_, _bJ_, _bI_);
          };
     return wrap_syscall
             (0,
              ch,
              function(param){
               return caml_call5(do_recvfrom, ch[1], buf, pos, len, flags);
              });
    }
    return caml_call1(Stdlib[1], cst_Lwt_unix_recvfrom);
   }
   function sendto(ch, buf, pos, len, flags, addr){
    if(0 <= pos && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= pos){
     var
      do_sendto =
        Stdlib_Sys[7]
         ? Unix[147]
         : function
          (_bH_, _bG_, _bF_, _bE_, _bD_, _bC_){
           return runtime.lwt_unix_sendto_byte
                   (_bH_, _bG_, _bF_, _bE_, _bD_, _bC_);
          };
     return wrap_syscall
             (1,
              ch,
              function(param){
               return caml_call6(do_sendto, ch[1], buf, pos, len, flags, addr);
              });
    }
    return caml_call1(Stdlib[1], cst_Lwt_unix_sendto);
   }
   function recv_msg(socket, io_vectors){
    var count = check_io_vectors(cst_Lwt_unix_recv_msg, io_vectors);
    return wrap_syscall
            (0,
             socket,
             function(param){
              return runtime.lwt_unix_recv_msg
                      (socket[1], count, io_vectors[1]);
             });
   }
   function send_msg(socket, io_vectors, fds){
    var
     vector_count = check_io_vectors(cst_Lwt_unix_send_msg, io_vectors),
     fd_count = caml_call1(Stdlib_List[1], fds);
    return wrap_syscall
            (1,
             socket,
             function(param){
              return runtime.lwt_unix_send_msg_byte
                      (socket[1], vector_count, io_vectors[1], fd_count, fds, 0);
             });
   }
   function send_msgto(socket, io_vectors, fds, dest){
    var
     vector_count = check_io_vectors(cst_Lwt_unix_send_msgto, io_vectors),
     fd_count = caml_call1(Stdlib_List[1], fds);
    return wrap_syscall
            (1,
             socket,
             function(param){
              return runtime.lwt_unix_send_msg_byte
                      (socket[1],
                       vector_count,
                       io_vectors[1],
                       fd_count,
                       fds,
                       [0, dest]);
             });
   }
   function socket(cloexec, dom, typ, proto){
    var s = caml_call4(Unix[133], cloexec, dom, typ, proto);
    return of_unix_file_descr(_r_, 0, s);
   }
   function shutdown(ch, shutdown_command){
    check_descriptor(ch);
    return caml_call2(Unix[140], ch[1], shutdown_command);
   }
   function socketpair(cloexec, dom, typ, proto){
    a:
    {
     if(Stdlib_Sys[7] && 0 !== dom){
      var match = runtime.lwt_unix_socketpair_stub(cloexec, dom, typ, proto);
      break a;
     }
     var match = caml_call4(Unix[135], cloexec, dom, typ, proto);
    }
    var s2 = match[2], s1 = match[1], _bB_ = of_unix_file_descr(_s_, 0, s2);
    return [0, of_unix_file_descr(_t_, 0, s1), _bB_];
   }
   function accept_and_set_nonblock(cloexec, ch_fd){
    if(Lwt_config[21]){
     var
      match = runtime.lwt_unix_accept4(cloexec, 1, ch_fd),
      addr = match[2],
      fd = match[1];
     return [0, of_unix_file_descr(_v_, _u_, fd), addr];
    }
    var
     match$0 = caml_call2(Unix[136], cloexec, ch_fd),
     addr$0 = match$0[2],
     fd$0 = match$0[1];
    return [0, of_unix_file_descr(_w_, 0, fd$0), addr$0];
   }
   function accept(cloexec, ch){
    return wrap_syscall
            (0,
             ch,
             function(param){return accept_and_set_nonblock(cloexec, ch[1]);});
   }
   function accept_n(cloexec, ch, n){
    var l = [0, 0];
    function _bo_(blocking){
     function _bs_(exn){
      var _bA_ = [0, caml_call1(Stdlib_List[10], l[1]), [0, exn]];
      return caml_call1(Lwt[4], _bA_);
     }
     function _bt_(param){
      return wrap_syscall
              (0,
               ch,
               function(param){
                a:
                try{
                 var _bw_ = 1;
                 if(n >= 1){
                  var i = _bw_;
                  for(;;){
                   var _bx_ = blocking ? 1 - unix_readable(ch[1]) : blocking;
                   if(_bx_) throw caml_maybe_attach_backtrace(Retry, 1);
                   var _by_ = l[1];
                   l[1] = [0, accept_and_set_nonblock(cloexec, ch[1]), _by_];
                   var _bz_ = i + 1 | 0;
                   if(n === i) break;
                   var i = _bz_;
                  }
                 }
                }
                catch(exn$0){
                 var exn = caml_wrap_exception(exn$0);
                 b:
                 {
                  if(exn[1] === Unix[1]){
                   var _bu_ = exn[2];
                   if(typeof _bu_ !== "number") break b;
                   var _bv_ = _bu_ - 2 | 0;
                   if(9 < _bv_ >>> 0){
                    if(35 !== _bv_) break b;
                   }
                   else if(7 >= _bv_ - 1 >>> 0) break b;
                  }
                  else if(exn !== Retry) break b;
                  if(0 !== l[1]) break a;
                 }
                 throw caml_maybe_attach_backtrace(exn, 0);
                }
                return [0, caml_call1(Stdlib_List[10], l[1]), 0];
               });
     }
     return caml_call2(Lwt[7], _bt_, _bs_);
    }
    var _bp_ = ch[4], _bq_ = caml_obj_tag(_bp_);
    a:
    if(250 === _bq_)
     var _br_ = _bp_[1];
    else{
     if(246 !== _bq_ && 244 !== _bq_){var _br_ = _bp_; break a;}
     var _br_ = caml_call1(CamlinternalLazy[2], _bp_);
    }
    return caml_call2(Lwt[33][1], _br_, _bo_);
   }
   function connect(ch, addr){
    if(Stdlib_Sys[7]){
     var in_progress = [0, 0];
     return wrap_syscall
             (1,
              ch,
              function(param){
               if(! in_progress[1])
                try{
                 var _bl_ = caml_call2(Unix[138], ch[1], addr);
                 return _bl_;
                }
                catch(_bn_){
                 var _bj_ = caml_wrap_exception(_bn_);
                 if(_bj_[1] === Unix[1]){
                  var _bk_ = _bj_[2];
                  if(typeof _bk_ === "number" && 37 === _bk_){
                   in_progress[1] = 1;
                   throw caml_maybe_attach_backtrace(Retry, 1);
                  }
                 }
                 throw caml_maybe_attach_backtrace(_bj_, 0);
                }
               if(! writable(ch)) throw caml_maybe_attach_backtrace(Retry, 1);
               try{var _bi_ = caml_call2(Unix[138], ch[1], addr); return _bi_;
               }
               catch(_bm_){
                var _bg_ = caml_wrap_exception(_bm_);
                if(_bg_[1] === Unix[1]){
                 var _bh_ = _bg_[2];
                 if(typeof _bh_ === "number" && 58 === _bh_) return 0;
                }
                throw caml_maybe_attach_backtrace(_bg_, 0);
               }
              });
    }
    var in_progress$0 = [0, 0];
    return wrap_syscall
            (1,
             ch,
             function(param){
              if(! in_progress$0[1])
               try{var _be_ = caml_call2(Unix[138], ch[1], addr); return _be_;
               }
               catch(_bf_){
                var _bc_ = caml_wrap_exception(_bf_);
                if(_bc_[1] === Unix[1]){
                 var _bd_ = _bc_[2];
                 if(typeof _bd_ === "number" && 38 === _bd_){
                  in_progress$0[1] = 1;
                  throw caml_maybe_attach_backtrace(Retry, 1);
                 }
                }
                throw caml_maybe_attach_backtrace(_bc_, 0);
               }
              var match = caml_call1(Unix[157], ch[1]);
              if(! match) return 0;
              var err = match[1];
              throw caml_maybe_attach_backtrace
                     ([0, Unix[1], err, cst_connect, cst$4], 1);
             });
   }
   function bind(fd, addr){
    check_descriptor(fd);
    if(! Stdlib_Sys[7] && 0 === addr[0])
     return run_job(0, runtime.lwt_unix_bind_job(fd[1], addr));
    var _bb_ = caml_call2(Unix[137], fd[1], addr);
    return caml_call1(Lwt[4], _bb_);
   }
   function listen(ch, cnt){
    check_descriptor(ch);
    return caml_call2(Unix[139], ch[1], cnt);
   }
   function getpeername(ch){
    check_descriptor(ch);
    return caml_call1(Unix[142], ch[1]);
   }
   function getsockname(ch){
    check_descriptor(ch);
    return caml_call1(Unix[141], ch[1]);
   }
   function get_credentials(ch){
    check_descriptor(ch);
    return runtime.lwt_unix_get_credentials(ch[1]);
   }
   function getsockopt(ch, opt){
    check_descriptor(ch);
    return caml_call2(Unix[149], ch[1], opt);
   }
   function setsockopt(ch, opt, x){
    check_descriptor(ch);
    return caml_call3(Unix[150], ch[1], opt, x);
   }
   function getsockopt_int(ch, opt){
    check_descriptor(ch);
    return caml_call2(Unix[151], ch[1], opt);
   }
   function setsockopt_int(ch, opt, x){
    check_descriptor(ch);
    return caml_call3(Unix[152], ch[1], opt, x);
   }
   function getsockopt_optint(ch, opt){
    check_descriptor(ch);
    return caml_call2(Unix[153], ch[1], opt);
   }
   function setsockopt_optint(ch, opt, x){
    check_descriptor(ch);
    return caml_call3(Unix[154], ch[1], opt, x);
   }
   function getsockopt_float(ch, opt){
    check_descriptor(ch);
    return caml_call2(Unix[155], ch[1], opt);
   }
   function setsockopt_float(ch, opt, x){
    check_descriptor(ch);
    return caml_call3(Unix[156], ch[1], opt, x);
   }
   function getsockopt_error(ch){
    check_descriptor(ch);
    return caml_call1(Unix[157], ch[1]);
   }
   function mcast_set_loop(ch, flag){
    check_descriptor(ch);
    return runtime.lwt_unix_mcast_set_loop(ch[1], flag);
   }
   function mcast_set_ttl(ch, ttl){
    check_descriptor(ch);
    return runtime.lwt_unix_mcast_set_ttl(ch[1], ttl);
   }
   function mcast_add_membership(ch, opt, addr){
    if(opt) var sth = opt[1], ifname = sth; else var ifname = Unix[128];
    check_descriptor(ch);
    return runtime.lwt_unix_mcast_modify_membership(ch[1], 0, ifname, addr);
   }
   function mcast_drop_membership(ch, opt, addr){
    if(opt) var sth = opt[1], ifname = sth; else var ifname = Unix[128];
    check_descriptor(ch);
    return runtime.lwt_unix_mcast_modify_membership(ch[1], 1, ifname, addr);
   }
   function gethostname(param){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_gethostname_job(0));
    var _ba_ = caml_call1(Unix[161], 0);
    return caml_call1(Lwt[4], _ba_);
   }
   var hostent_mutex = caml_call1(Lwt_mutex[1], 0);
   function gethostbyname(name){
    if(Stdlib_Sys[7]){
     var _a__ = caml_call1(Unix[162], name);
     return caml_call1(Lwt[4], _a__);
    }
    if(Lwt_config[16])
     return run_job(0, runtime.lwt_unix_gethostbyname_job(name));
    function _a$_(param){
     return run_job(0, runtime.lwt_unix_gethostbyname_job(name));
    }
    return caml_call2(Lwt_mutex[6], hostent_mutex, _a$_);
   }
   function gethostbyaddr(addr){
    if(Stdlib_Sys[7]){
     var _a8_ = caml_call1(Unix[163], addr);
     return caml_call1(Lwt[4], _a8_);
    }
    if(Lwt_config[16])
     return run_job(0, runtime.lwt_unix_gethostbyaddr_job(addr));
    function _a9_(param){
     return run_job(0, runtime.lwt_unix_gethostbyaddr_job(addr));
    }
    return caml_call2(Lwt_mutex[6], hostent_mutex, _a9_);
   }
   a:
   {
    if(! Stdlib_Sys[7] && ! Lwt_config[15]){
     var protoent_mutex = caml_call1(Lwt_mutex[1], 0);
     break a;
    }
    var protoent_mutex = hostent_mutex;
   }
   function getprotobyname(name){
    if(Stdlib_Sys[7]){
     var _a6_ = caml_call1(Unix[164], name);
     return caml_call1(Lwt[4], _a6_);
    }
    if(Lwt_config[15])
     return run_job(0, runtime.lwt_unix_getprotobyname_job(name));
    function _a7_(param){
     return run_job(0, runtime.lwt_unix_getprotobyname_job(name));
    }
    return caml_call2(Lwt_mutex[6], protoent_mutex, _a7_);
   }
   function getprotobynumber(number){
    if(Stdlib_Sys[7]){
     var _a4_ = caml_call1(Unix[165], number);
     return caml_call1(Lwt[4], _a4_);
    }
    if(Lwt_config[15])
     return run_job(0, runtime.lwt_unix_getprotobynumber_job(number));
    function _a5_(param){
     return run_job(0, runtime.lwt_unix_getprotobynumber_job(number));
    }
    return caml_call2(Lwt_mutex[6], protoent_mutex, _a5_);
   }
   a:
   if(! Stdlib_Sys[7] && ! Lwt_config[15]){caml_call1(Lwt_mutex[1], 0); break a;}
   function getservbyname(name, x){
    if(Stdlib_Sys[7]){
     var _a2_ = caml_call2(Unix[166], name, x);
     return caml_call1(Lwt[4], _a2_);
    }
    if(Lwt_config[15])
     return run_job(0, runtime.lwt_unix_getservbyname_job(name, x));
    function _a3_(param){
     return run_job(0, runtime.lwt_unix_getservbyname_job(name, x));
    }
    return caml_call2(Lwt_mutex[6], protoent_mutex, _a3_);
   }
   function getservbyport(port, x){
    if(Stdlib_Sys[7]){
     var _a0_ = caml_call2(Unix[167], port, x);
     return caml_call1(Lwt[4], _a0_);
    }
    if(Lwt_config[15])
     return run_job(0, runtime.lwt_unix_getservbyport_job(port, x));
    function _a1_(param){
     return run_job(0, runtime.lwt_unix_getservbyport_job(port, x));
    }
    return caml_call2(Lwt_mutex[6], protoent_mutex, _a1_);
   }
   function getaddrinfo(host, service, opts){
    if(Stdlib_Sys[7]){
     var _aW_ = caml_call3(Unix[168], host, service, opts);
     return caml_call1(Lwt[4], _aW_);
    }
    function _aX_(l){
     var _aZ_ = caml_call1(Stdlib_List[10], l);
     return caml_call1(Lwt[4], _aZ_);
    }
    var
     _aY_ = run_job(0, runtime.lwt_unix_getaddrinfo_job(host, service, opts));
    return caml_call2(Lwt[33][1], _aY_, _aX_);
   }
   function getnameinfo(addr, opts){
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_getnameinfo_job(addr, opts));
    var _aV_ = caml_call2(Unix[169], addr, opts);
    return caml_call1(Lwt[4], _aV_);
   }
   function tcgetattr(ch){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_tcgetattr_job(ch[1]));
    var _aU_ = caml_call1(Unix[170], ch[1]);
    return caml_call1(Lwt[4], _aU_);
   }
   function tcsetattr(ch, when, attrs){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_tcsetattr_job(ch[1], when, attrs));
    var _aT_ = caml_call3(Unix[171], ch[1], when, attrs);
    return caml_call1(Lwt[4], _aT_);
   }
   function tcsendbreak(ch, delay){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_tcsendbreak_job(ch[1], delay));
    var _aS_ = caml_call2(Unix[172], ch[1], delay);
    return caml_call1(Lwt[4], _aS_);
   }
   function tcdrain(ch){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_tcdrain_job(ch[1]));
    var _aR_ = caml_call1(Unix[173], ch[1]);
    return caml_call1(Lwt[4], _aR_);
   }
   function tcflush(ch, q){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_tcflush_job(ch[1], q));
    var _aQ_ = caml_call2(Unix[174], ch[1], q);
    return caml_call1(Lwt[4], _aQ_);
   }
   function tcflow(ch, act){
    check_descriptor(ch);
    if(! Stdlib_Sys[7])
     return run_job(0, runtime.lwt_unix_tcflow_job(ch[1], act));
    var _aP_ = caml_call2(Unix[175], ch[1], act);
    return caml_call1(Lwt[4], _aP_);
   }
   function handle_notifications(param){
    var _aO_ = runtime.lwt_unix_recv_notifications(0);
    return caml_call2(Stdlib_Array[11], call_notification, _aO_);
   }
   var
    _x_ = runtime.lwt_unix_init_notification(0),
    event_notifications =
      [0, caml_call2(Lwt_engine[4], _x_, handle_notifications)];
   runtime.lwt_unix_init_signals(0);
   function set_signal(signum, notification){
    return runtime.lwt_unix_set_signal
            (signum, notification, caml_call1(Lwt_engine[12], signum));
   }
   function compare(a, b){return a - b | 0;}
   var
    Signal_map = caml_call1(Stdlib_Map[1], [0, compare]),
    signals = [0, Signal_map[1]];
   function signal_count(param){
    var _aL_ = 0, _aM_ = signals[1];
    function _aN_(signum, param, len){
     var actions = param[2];
     return len + caml_call1(Lwt_sequence[7], actions) | 0;
    }
    return caml_call3(Signal_map[24], _aN_, _aM_, _aL_);
   }
   function on_signal_full(signum, handler){
    var id = [0, 0];
    try{
     var
      _aI_ = caml_call2(Signal_map[17], signum, signals[1])[2],
      actions$0 = _aI_;
    }
    catch(_aJ_){
     var _aH_ = caml_wrap_exception(_aJ_);
     if(_aH_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_aH_, 0);
     var
      actions = caml_call1(Lwt_sequence[4], 0),
      notification =
        make_notification
         (0,
          function(param){
           function _aK_(f){return caml_call2(f, id, signum);}
           return caml_call2(Lwt_sequence[17], _aK_, actions);
          });
     try{set_signal(signum, notification);}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(! caml_call1(Lwt[78][4], exn))
       throw caml_maybe_attach_backtrace(exn, 0);
      stop_notification(notification);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
     signals[1] =
      caml_call3
       (Signal_map[2], signum, [0, notification, actions], signals[1]);
     var actions$0 = actions;
    }
    var node = caml_call2(Lwt_sequence[9], handler, actions$0);
    id[1] = [0, [0, signum, node]];
    return id;
   }
   function on_signal(signum, f){
    return on_signal_full
            (signum, function(id, num){return caml_call1(f, num);});
   }
   function disable_signal_handler(id){
    var match = id[1];
    if(! match) return 0;
    var sh = match[1];
    id[1] = 0;
    caml_call1(Lwt_sequence[3], sh[2]);
    var
     match$0 = caml_call2(Signal_map[17], sh[1], signals[1]),
     actions = match$0[2],
     notification = match$0[1],
     _aG_ = caml_call1(Lwt_sequence[6], actions);
    if(! _aG_) return _aG_;
    var signum = sh[1];
    runtime.lwt_unix_remove_signal(signum, caml_call1(Lwt_engine[12], signum));
    signals[1] = caml_call2(Signal_map[6], sh[1], signals[1]);
    return stop_notification(notification);
   }
   function reinstall_signal_handler(signum){
    try{var val = caml_call2(Signal_map[17], signum, signals[1]);}
    catch(_aF_){
     var _aE_ = caml_wrap_exception(_aF_);
     if(_aE_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_aE_, 0);
    }
    var notification = val[1];
    return set_signal(signum, notification);
   }
   function fork(param){
    var pid = caml_call1(Unix[13], 0);
    if(0 !== pid) return pid;
    caml_call1(Lwt_engine[11], 0);
    runtime.lwt_unix_reset_after_fork(0);
    caml_call1(Lwt_engine[1], event_notifications[1]);
    var _ay_ = runtime.lwt_unix_init_notification(0);
    event_notifications[1] =
     caml_call2(Lwt_engine[4], _ay_, handle_notifications);
    var _az_ = 0;
    function _aA_(param, l){var f = param[2]; return [0, f, l];}
    var l = caml_call3(Lwt_sequence[21], _aA_, jobs, _az_);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], jobs);
    function _aB_(param){
     function _aD_(f){return caml_call1(f, Lwt[21]);}
     return caml_call2(Stdlib_List[18], _aD_, l);
    }
    var _aC_ = caml_call1(Lwt_main[2], 0);
    caml_call2(Lwt[31], _aC_, _aB_);
    return 0;
   }
   var has_wait4 = 1 - Stdlib_Sys[7];
   function do_wait4(flags, pid){
    if(! Stdlib_Sys[7] && ! Lwt_config[1])
     return runtime.lwt_unix_wait4(flags, pid);
    var
     match = caml_call2(Unix[15], flags, pid),
     status = match[2],
     pid$0 = match[1];
    return [0, pid$0, status, _y_];
   }
   var wait_children = caml_call1(Lwt_sequence[4], 0);
   function wait_count(param){
    return caml_call1(Lwt_sequence[7], wait_children);
   }
   var sigchld_handler_installed = [0, 0];
   function install_sigchld_handler(param){
    var
     _ar_ = 1 - Stdlib_Sys[7],
     _as_ = _ar_ ? 1 - sigchld_handler_installed[1] : _ar_;
    if(_as_){
     sigchld_handler_installed[1] = 1;
     var
      _at_ =
        function(param){
         function _av_(node){
          var
           match = caml_call1(Lwt_sequence[1], node),
           pid = match[3],
           flags = match[2],
           wakener = match[1];
          try{
           var
            v = do_wait4(flags, pid),
            pid$0 = v[1],
            _aw_ = 0 !== pid$0 ? 1 : 0,
            _ax_ =
              _aw_
               ? (caml_call1
                  (Lwt_sequence[3], node),
                 caml_call2(Lwt[52], wakener, v))
               : _aw_;
           return _ax_;
          }
          catch(e$0){
           var e = caml_wrap_exception(e$0);
           if(! caml_call1(Lwt[78][4], e))
            throw caml_maybe_attach_backtrace(e, 0);
           caml_call1(Lwt_sequence[3], node);
           return caml_call2(Lwt[53], wakener, e);
          }
         }
         return caml_call2(Lwt_sequence[19], _av_, wait_children);
        };
     on_signal(Stdlib_Sys[29], _at_);
     var _au_ = 0;
    }
    else
     var _au_ = _as_;
    return _au_;
   }
   function _z_(param){
    function _ap_(param){return install_sigchld_handler(0);}
    var _aq_ = caml_call1(Lwt[57], 0);
    return caml_call2(Lwt[33][2], _aq_, _ap_);
   }
   caml_call1(Lwt[11], _z_);
   function waitpid(flags, pid){
    function _al_(_ao_){throw caml_maybe_attach_backtrace(_ao_, 0);}
    function _am_(param){
     var _an_ = caml_call2(Unix[15], flags, pid);
     return caml_call1(Lwt[4], _an_);
    }
    return caml_call2(Lwt[7], _am_, _al_);
   }
   var
    waitpid$0 =
      Stdlib_Sys[7]
       ? waitpid
       : function
        (flags, pid){
         install_sigchld_handler(0);
         if(caml_call2(Stdlib_List[37], 0, flags)) return waitpid(flags, pid);
         var flags$0 = [0, 0, flags];
         function _ah_(res){
          var pid$0 = res[1];
          if(0 !== pid$0) return caml_call1(Lwt[4], res);
          var
           match = caml_call1(Lwt[22], 0),
           w = match[2],
           res$0 = match[1],
           node =
             caml_call2(Lwt_sequence[8], [0, w, flags$0, pid], wait_children);
          function _aj_(param){return caml_call1(Lwt_sequence[3], node);}
          caml_call2(Lwt[24], res$0, _aj_);
          function _ak_(param){
           var status = param[2], pid = param[1];
           return caml_call1(Lwt[4], [0, pid, status]);
          }
          return caml_call2(Lwt[33][1], res$0, _ak_);
         }
         var _ai_ = waitpid(flags$0, pid);
         return caml_call2(Lwt[33][1], _ai_, _ah_);
        };
   function wait4(flags, pid){
    install_sigchld_handler(0);
    if(! Stdlib_Sys[7] && ! Lwt_config[1]){
     if(caml_call2(Stdlib_List[37], 0, flags)){
      var _af_ = do_wait4(flags, pid);
      return caml_call1(Lwt[4], _af_);
     }
     var
      flags$0 = [0, 0, flags],
      res = do_wait4(flags$0, pid),
      pid$0 = res[1];
     if(0 !== pid$0) return caml_call1(Lwt[4], res);
     var
      match = caml_call1(Lwt[22], 0),
      w = match[2],
      res$0 = match[1],
      node = caml_call2(Lwt_sequence[8], [0, w, flags$0, pid], wait_children),
      _ag_ = function(param){return caml_call1(Lwt_sequence[3], node);};
     caml_call2(Lwt[24], res$0, _ag_);
     return res$0;
    }
    var _ae_ = do_wait4(flags, pid);
    return caml_call1(Lwt[4], _ae_);
   }
   function wait(param){return waitpid$0(0, -1);}
   function system(cmd){
    if(Stdlib_Sys[7]){
     var
      _Z_ = function(code){return caml_call1(Lwt[4], [0, code]);},
      ___ =
        run_job
         (0,
          runtime.lwt_unix_system_job
           (caml_call2(Stdlib[28], cst_cmd_exe_c, cmd)));
     return caml_call2(Lwt[33][1], ___, _Z_);
    }
    var id = fork(0);
    if(0 === id)
     try{
      var
       _$_ = caml_call2(Unix[9], cst_bin_sh$0, [0, cst_bin_sh, cst_c, cmd]);
      return _$_;
     }
     catch(_ad_){return runtime.caml_unix_exit(127);}
    function _aa_(_ac_){return _ac_[2];}
    var _ab_ = waitpid$0(0, id);
    return caml_call2(Lwt[33][2], _ab_, _aa_);
   }
   var run = Lwt_main[1];
   function handle_unix_error(f, x){
    function _V_(exn){
     var _X_ = 0;
     function _Y_(param){throw caml_maybe_attach_backtrace(exn, 1);}
     return caml_call2(Unix[3], _Y_, _X_);
    }
    function _W_(param){return caml_call1(f, x);}
    return caml_call2(Lwt[7], _W_, _V_);
   }
   function get_affinity(opt, param){
    if(opt) var sth = opt[1], pid = sth; else var pid = 0;
    return runtime.lwt_unix_get_affinity(pid);
   }
   function set_affinity(opt, l){
    if(opt) var sth = opt[1], pid = sth; else var pid = 0;
    return runtime.lwt_unix_set_affinity(pid, l);
   }
   function _A_(param){
    if(param[1] !== Unix[1]) return 0;
    var arg = param[4], func = param[3], error = param[2];
    if(typeof error === "number"){
     var _U_ = error;
     if(34 <= _U_)
      switch(_U_){
        case 34:
         var error$0 = cst_ESPIPE; break;
        case 35:
         var error$0 = cst_ESRCH; break;
        case 36:
         var error$0 = cst_EXDEV; break;
        case 37:
         var error$0 = cst_EWOULDBLOCK; break;
        case 38:
         var error$0 = cst_EINPROGRESS; break;
        case 39:
         var error$0 = cst_EALREADY; break;
        case 40:
         var error$0 = cst_ENOTSOCK; break;
        case 41:
         var error$0 = cst_EDESTADDRREQ; break;
        case 42:
         var error$0 = cst_EMSGSIZE; break;
        case 43:
         var error$0 = cst_EPROTOTYPE; break;
        case 44:
         var error$0 = cst_ENOPROTOOPT; break;
        case 45:
         var error$0 = cst_EPROTONOSUPPORT; break;
        case 46:
         var error$0 = cst_ESOCKTNOSUPPORT; break;
        case 47:
         var error$0 = cst_EOPNOTSUPP; break;
        case 48:
         var error$0 = cst_EPFNOSUPPORT; break;
        case 49:
         var error$0 = cst_EAFNOSUPPORT; break;
        case 50:
         var error$0 = cst_EADDRINUSE; break;
        case 51:
         var error$0 = cst_EADDRNOTAVAIL; break;
        case 52:
         var error$0 = cst_ENETDOWN; break;
        case 53:
         var error$0 = cst_ENETUNREACH; break;
        case 54:
         var error$0 = cst_ENETRESET; break;
        case 55:
         var error$0 = cst_ECONNABORTED; break;
        case 56:
         var error$0 = cst_ECONNRESET; break;
        case 57:
         var error$0 = cst_ENOBUFS; break;
        case 58:
         var error$0 = cst_EISCONN; break;
        case 59:
         var error$0 = cst_ENOTCONN; break;
        case 60:
         var error$0 = cst_ESHUTDOWN; break;
        case 61:
         var error$0 = cst_ETOOMANYREFS; break;
        case 62:
         var error$0 = cst_ETIMEDOUT; break;
        case 63:
         var error$0 = cst_ECONNREFUSED; break;
        case 64:
         var error$0 = cst_EHOSTDOWN; break;
        case 65:
         var error$0 = cst_EHOSTUNREACH; break;
        case 66:
         var error$0 = cst_ELOOP; break;
        default: var error$0 = cst_EOVERFLOW;
      }
     else
      switch(_U_){
        case 0:
         var error$0 = cst_E2BIG; break;
        case 1:
         var error$0 = cst_EACCES; break;
        case 2:
         var error$0 = cst_EAGAIN; break;
        case 3:
         var error$0 = cst_EBADF; break;
        case 4:
         var error$0 = cst_EBUSY; break;
        case 5:
         var error$0 = cst_ECHILD; break;
        case 6:
         var error$0 = cst_EDEADLK; break;
        case 7:
         var error$0 = cst_EDOM; break;
        case 8:
         var error$0 = cst_EEXIST; break;
        case 9:
         var error$0 = cst_EFAULT; break;
        case 10:
         var error$0 = cst_EFBIG; break;
        case 11:
         var error$0 = cst_EINTR; break;
        case 12:
         var error$0 = cst_EINVAL; break;
        case 13:
         var error$0 = cst_EIO; break;
        case 14:
         var error$0 = cst_EISDIR; break;
        case 15:
         var error$0 = cst_EMFILE; break;
        case 16:
         var error$0 = cst_EMLINK; break;
        case 17:
         var error$0 = cst_ENAMETOOLONG; break;
        case 18:
         var error$0 = cst_ENFILE; break;
        case 19:
         var error$0 = cst_ENODEV; break;
        case 20:
         var error$0 = cst_ENOENT; break;
        case 21:
         var error$0 = cst_ENOEXEC; break;
        case 22:
         var error$0 = cst_ENOLCK; break;
        case 23:
         var error$0 = cst_ENOMEM; break;
        case 24:
         var error$0 = cst_ENOSPC; break;
        case 25:
         var error$0 = cst_ENOSYS; break;
        case 26:
         var error$0 = cst_ENOTDIR; break;
        case 27:
         var error$0 = cst_ENOTEMPTY; break;
        case 28:
         var error$0 = cst_ENOTTY; break;
        case 29:
         var error$0 = cst_ENXIO; break;
        case 30:
         var error$0 = cst_EPERM; break;
        case 31:
         var error$0 = cst_EPIPE; break;
        case 32:
         var error$0 = cst_ERANGE; break;
        default: var error$0 = cst_EROFS;
      }
    }
    else
     var n = error[1], error$0 = caml_call2(Stdlib_Printf[4], _C_, n);
    return [0, caml_call4(Stdlib_Printf[4], _B_, error$0, func, arg)];
   }
   caml_call1(Stdlib_Printexc[9], _A_);
   function bind_1(ch, addr){
    check_descriptor(ch);
    return caml_call2(Unix[137], ch[1], addr);
   }
   var Versioned = [0, bind_1, bind, recv_msg, send_msg];
   function _D_(_T_){return runtime.lwt_unix_somaxconn(_T_);}
   function _E_(_S_){return runtime.lwt_unix_get_cpu(_S_);}
   function _F_(_R_){return runtime.lwt_unix_thread_waiting_count(_R_);}
   function _G_(_Q_){return runtime.lwt_unix_thread_count(_Q_);}
   function _H_(_P_){return runtime.lwt_unix_set_pool_size(_P_);}
   function _I_(_O_){return runtime.lwt_unix_pool_size(_O_);}
   function _J_(_N_){return runtime.lwt_unix_send_notification_stub(_N_);}
   var
    Lwt_unix =
      [0,
       handle_unix_error,
       sleep,
       yield$0,
       auto_yield,
       auto_pause,
       Timeout,
       timeout,
       with_timeout,
       state,
       unix_file_descr,
       of_unix_file_descr,
       blocking,
       set_blocking,
       abort,
       fork,
       wait,
       waitpid$0,
       wait4,
       wait_count,
       system,
       stdin,
       stdout,
       stderr,
       openfile,
       close,
       read,
       pread,
       write,
       pwrite,
       write_string,
       pwrite_string,
       [0,
        create,
        append_bytes,
        append_bigarray,
        drop,
        is_empty,
        byte_count,
        system_limit],
       readv,
       writev,
       readable,
       writable,
       wait_read,
       wait_write,
       lseek,
       truncate,
       ftruncate,
       fsync,
       fdatasync,
       stat,
       lstat,
       fstat,
       file_exists,
       utimes,
       isatty,
       LargeFile,
       unlink,
       rename,
       link,
       chmod,
       fchmod,
       chown,
       fchown,
       access,
       dup,
       dup2,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir,
       readdir_n,
       rewinddir,
       closedir,
       files_of_directory,
       pipe,
       pipe_in,
       pipe_out,
       mkfifo,
       symlink,
       readlink,
       lockf,
       getlogin,
       getpwnam,
       getgrnam,
       getpwuid,
       getgrgid,
       on_signal,
       on_signal_full,
       disable_signal_handler,
       signal_count,
       reinstall_signal_handler,
       function(_M_){return runtime.lwt_unix_handle_signal(_M_);},
       socket,
       socketpair,
       bind,
       listen,
       accept,
       accept_n,
       connect,
       shutdown,
       getsockname,
       getpeername,
       recv,
       recvfrom,
       send,
       sendto,
       recv_msg,
       send_msg,
       send_msgto,
       get_credentials,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       mcast_set_loop,
       mcast_set_ttl,
       mcast_add_membership,
       mcast_drop_membership,
       gethostname,
       gethostbyname,
       gethostbyaddr,
       getprotobyname,
       getprotobynumber,
       getservbyname,
       getservbyport,
       getaddrinfo,
       getnameinfo,
       tcgetattr,
       tcsetattr,
       tcsendbreak,
       tcdrain,
       tcflush,
       tcflow,
       default_async_method,
       set_default_async_method,
       async_method,
       async_method_key,
       with_async_none,
       with_async_detach,
       with_async_switch,
       Retry,
       Retry_read,
       Retry_write,
       wrap_syscall,
       check_descriptor,
       register_action,
       run_job,
       abort_jobs,
       cancel_jobs,
       wait_for_jobs,
       execute_job,
       make_notification,
       _J_,
       stop_notification,
       call_notification,
       set_notification,
       _I_,
       _H_,
       _G_,
       _F_,
       _E_,
       get_affinity,
       set_affinity,
       Versioned,
       run,
       has_wait4,
       _D_,
       retained,
       read_bigarray,
       write_bigarray];
   runtime.caml_register_global(156, Lwt_unix, "Lwt_unix");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_timeout
//# unitInfo: Requires: Lwt, Lwt_unix, Stdlib, Stdlib__Array
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mod = runtime.caml_mod,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_unix = global_data.Lwt_unix,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    cst_Lwt_timeout_change = "Lwt_timeout.change",
    cst_Lwt_timeout_create = "Lwt_timeout.create";
   function make(delay, action){
    var x = [];
    runtime.caml_update_dummy(x, [0, delay, action, x, x]);
    return x;
   }
   function lst_remove(x){
    var p = x[3], n = x[4];
    p[4] = n;
    n[3] = p;
    x[4] = x;
    x[3] = x;
    return;
   }
   function lst_in_list(x){return x[4] !== x ? 1 : 0;}
   var count = [0, 0], buckets = [0, [0]], curr = [0, 0], stopped = [0, 1];
   function size(l){
    var len = buckets[1].length - 1;
    if(len <= l){
     var
      _k_ = function(param){return make(-1, function(param){return 0;});},
      b = caml_call2(Stdlib_Array[1], l + 1 | 0, _k_);
     caml_call5(Stdlib_Array[8], buckets[1], curr[1], b, 0, len - curr[1] | 0);
     caml_call5(Stdlib_Array[8], buckets[1], 0, b, len - curr[1] | 0, curr[1]);
     buckets[1] = b;
     curr[1] = 0;
    }
    return;
   }
   var handle_exn = [0, function(exn){return caml_call1(Lwt[12][1], exn);}];
   function set_exn_handler(f){handle_exn[1] = f; return 0;}
   function loop(param){
    stopped[1] = 0;
    function _h_(param){
     var _j_ = curr[1], set = caml_check_bound(buckets[1], _j_)[1 + _j_];
     for(;;){
      if(set[4] === set){
       curr[1] = caml_mod(curr[1] + 1 | 0, buckets[1].length - 1);
       return 0 < count[1] ? loop(0) : (stopped[1] = 1, Lwt[36]);
      }
      var x = set[4];
      lst_remove(x);
      count[1] += -1;
      try{caml_call1(x[2], 0);}
      catch(e$0){
       var e = caml_wrap_exception(e$0);
       if(! caml_call1(Lwt[78][4], e))
        throw caml_maybe_attach_backtrace(e, 0);
       caml_call1(handle_exn[1], e);
      }
     }
    }
    var _i_ = caml_call1(Lwt_unix[2], 1.);
    return caml_call2(Lwt[6], _i_, _h_);
   }
   function start(x){
    var
     in_list = lst_in_list(x),
     slot = caml_mod(curr[1] + x[1] | 0, buckets[1].length - 1);
    lst_remove(x);
    var p = caml_check_bound(buckets[1], slot)[1 + slot], n = p[4];
    p[4] = x;
    x[3] = p;
    x[4] = n;
    n[3] = x;
    var _d_ = 1 - in_list;
    if(_d_){
     count[1]++;
     var
      _e_ = 1 === count[1] ? 1 : 0,
      _f_ = _e_ ? stopped[1] : _e_,
      _g_ = _f_ ? (loop(0), 0) : _f_;
    }
    else
     var _g_ = _d_;
    return _g_;
   }
   function create(delay, action){
    if(delay < 1) caml_call1(Stdlib[1], cst_Lwt_timeout_create);
    var x = make(delay, action);
    size(delay);
    return x;
   }
   function stop(x){
    var
     _b_ = lst_in_list(x),
     _c_ = _b_ ? (lst_remove(x), count[1] += -1, 0) : _b_;
    return _c_;
   }
   function change(x, delay){
    if(delay < 1) caml_call1(Stdlib[1], cst_Lwt_timeout_change);
    x[1] = delay;
    size(delay);
    var _a_ = lst_in_list(x);
    return _a_ ? start(x) : _a_;
   }
   var Lwt_timeout = [0, create, start, stop, change, set_exn_handler];
   runtime.caml_register_global(7, Lwt_timeout, "Lwt_timeout");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_throttle
//# unitInfo: Requires: Lwt, Lwt_unix, Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printexc, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Lwt_unix = global_data.Lwt_unix,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    _a_ = [0, 0, 0],
    cst_internal_error = "internal error",
    cst_Lwt_throttle_S_create = "Lwt_throttle.S.create";
   function Make(H){
    var MH = caml_call1(Stdlib_Hashtbl[26], H);
    function create(rate, max, n){
     if(1 <= rate && 1 <= max && 0 <= n)
      return [0, rate, max, 0, caml_call1(MH[1], n), 0];
     return caml_call1(Stdlib[1], cst_Lwt_throttle_S_create);
    }
    function launch_cleaning(t){
     function _f_(param){
      function _h_(exn){
       caml_call1(Stdlib[53], cst_internal_error);
       caml_call1(Stdlib_Printexc[5], Stdlib[40]);
       return Lwt[36];
      }
      function _i_(param){
       var _j_ = t[4];
       function _k_(key, elt, param){
        var to_run = param[2], old_waiting = param[1];
        function update(to_run, i){
         if(0 === i)
          return [0, 0, caml_call1(Stdlib_Queue[14], elt[2]), to_run];
         try{
          var
           to_run$0 = [0, caml_call1(Stdlib_Queue[5], elt[2]), to_run],
           _n_ = update(to_run$0, i - 1 | 0);
          return _n_;
         }
         catch(_o_){
          var _m_ = caml_wrap_exception(_o_);
          if(_m_ === Stdlib_Queue[1]) return [0, i, 0, to_run];
          throw caml_maybe_attach_backtrace(_m_, 0);
         }
        }
        var
         match = update(to_run, t[1]),
         to_run$0 = match[3],
         waiting = match[2],
         not_consumed = match[1],
         consumed = t[1] - not_consumed | 0;
        if(0 === consumed)
         caml_call2(MH[6], t[4], key);
        else
         elt[1] = consumed;
        return [0, old_waiting + waiting | 0, to_run$0];
       }
       var
        match = caml_call3(MH[14], _k_, _j_, _a_),
        to_run = match[2],
        waiting = match[1];
       t[3] = waiting;
       a:
       {
        if(0 === waiting && 0 === to_run){t[5] = 0; break a;}
        launch_cleaning(t);
       }
       function _l_(u){return caml_call2(Lwt[52], u, 1);}
       caml_call2(Stdlib_List[18], _l_, to_run);
       return Lwt[36];
      }
      return caml_call2(Lwt[7], _i_, _h_);
     }
     var
      _g_ = caml_call1(Lwt_unix[2], 1.),
      t$0 = caml_call2(Lwt[33][1], _g_, _f_);
     t[5] = [0, t$0];
     return;
    }
    function wait(t, key){
     try{
      var elt$0 = caml_call2(MH[7], t[4], key);
      if(t[1] <= elt$0[1])
       var
        match = caml_call1(Lwt[22], 0),
        u = match[2],
        w = match[1],
        _c_ =
          t[3] < t[2]
           ? (caml_call2
              (Stdlib_Queue[3], u, elt$0[2]),
             t[3] = t[3] + 1 | 0,
             w)
           : Lwt[40],
        _d_ = _c_;
      else{elt$0[1] = elt$0[1] + 1 | 0; var _d_ = Lwt[39];}
      var res = _d_;
     }
     catch(_e_){
      var _b_ = caml_wrap_exception(_e_);
      if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
      var elt = [0, 1, caml_call1(Stdlib_Queue[2], 0)];
      caml_call3(MH[5], t[4], key, elt);
      var res = Lwt[39];
     }
     if(! t[5]) launch_cleaning(t);
     return res;
    }
    return [0, create, wait];
   }
   var Lwt_throttle = [0, Make];
   runtime.caml_register_global(11, Lwt_throttle, "Lwt_throttle");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_sys
//# unitInfo: Requires: Lwt_config, Stdlib__Callback, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Lwt_config = global_data.Lwt_config,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Not_available =
      [248, "Lwt_sys.Not_available", runtime.caml_fresh_oo_id(0)];
   caml_call2
    (Stdlib_Callback[2], "lwt:not-available", [0, Not_available, cst]);
   var windows = Stdlib_Sys[7];
   function have(param){
    if(640300904 <= param){
     if(650135999 === param) return Lwt_config[7];
     if(991650160 <= param)
      return 1013434963 <= param ? Lwt_config[22] : Lwt_config[6];
     if(757744619 <= param) return Lwt_config[14];
    }
    else{
     if(-185023754 <= param)
      return -113015823 <= param ? Lwt_config[8] : Lwt_config[3];
     if(-940245007 === param){
      var _a_ = Stdlib_Sys[7], _b_ = _a_ || Stdlib_Sys[8];
      return 1 - _b_;
     }
    }
    return 1 - Stdlib_Sys[7];
   }
   var
    byte_order = runtime.lwt_unix_system_byte_order(0),
    Lwt_sys = [0, Not_available, have, byte_order, windows];
   runtime.caml_register_global(6, Lwt_sys, "Lwt_sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_bytes
//# unitInfo: Requires: Lwt, Lwt_unix, Stdlib, Stdlib__Bigarray, Stdlib__Bytes, Stdlib__List, Unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_mod = runtime.caml_mod,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Lwt = global_data.Lwt,
    Lwt_unix = global_data.Lwt_unix,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Unix = global_data.Unix,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    cst_Lwt_bytes_wait_mincore = "Lwt_bytes.wait_mincore",
    cst_Lwt_bytes_mincore = "Lwt_bytes.mincore",
    cst_Lwt_bytes_madvise = "Lwt_bytes.madvise",
    cst_Lwt_bytes_sendto = "Lwt_bytes.sendto",
    cst_Lwt_bytes_recvfrom = "Lwt_bytes.recvfrom",
    cst_Lwt_bytes_send = "Lwt_bytes.send",
    cst_Lwt_bytes_recv = "Lwt_bytes.recv",
    cst_Lwt_bytes_extract = "Lwt_bytes.extract",
    cst_Lwt_bytes_blit = "Lwt_bytes.blit",
    cst_Lwt_bytes_blit_to_bytes = "Lwt_bytes.blit_to_bytes",
    cst_Lwt_bytes_blit_from_bytes = "Lwt_bytes.blit_from_bytes",
    cst_Lwt_bytes_blit_from_string = "Lwt_bytes.blit_from_string",
    cst_Lwt_bytes_fill = "Lwt_bytes.fill",
    cst_Lwt_bytes_read = "Lwt_bytes.read",
    cst_Lwt_bytes_write = "Lwt_bytes.write";
   function create(size){
    return caml_call3
            (Stdlib_Bigarray[19][1],
             Stdlib_Bigarray[13],
             Stdlib_Bigarray[15],
             size);
   }
   var length = caml_ba_dim_1;
   function fill(bytes, ofs, len, ch){
    if(0 <= ofs && 0 <= len && (caml_ba_dim_1(bytes) - len | 0) >= ofs)
     return runtime.lwt_unix_fill_bytes(bytes, ofs, len, ch);
    return caml_call1(Stdlib[1], cst_Lwt_bytes_fill);
   }
   function blit_from_string(src_buf, src_ofs, dst_buf, dst_ofs, len){
    if
     (0 <= len
      &&
       0 <= src_ofs
       &&
        (runtime.caml_ml_string_length(src_buf) - len | 0) >= src_ofs
        && 0 <= dst_ofs && (caml_ba_dim_1(dst_buf) - len | 0) >= dst_ofs)
     return runtime.lwt_unix_blit_from_string
             (src_buf, src_ofs, dst_buf, dst_ofs, len);
    return caml_call1(Stdlib[1], cst_Lwt_bytes_blit_from_string);
   }
   function blit_from_bytes(src_buf, src_ofs, dst_buf, dst_ofs, len){
    if
     (0 <= len
      &&
       0 <= src_ofs
       &&
        (caml_ml_bytes_length(src_buf) - len | 0) >= src_ofs
        && 0 <= dst_ofs && (caml_ba_dim_1(dst_buf) - len | 0) >= dst_ofs)
     return runtime.lwt_unix_blit_from_bytes
             (src_buf, src_ofs, dst_buf, dst_ofs, len);
    return caml_call1(Stdlib[1], cst_Lwt_bytes_blit_from_bytes);
   }
   function blit_to_bytes(src_buf, src_ofs, dst_buf, dst_ofs, len){
    if
     (0 <= len
      &&
       0 <= src_ofs
       &&
        (caml_ba_dim_1(src_buf) - len | 0) >= src_ofs
        &&
         0 <= dst_ofs && (caml_ml_bytes_length(dst_buf) - len | 0) >= dst_ofs)
     return runtime.lwt_unix_blit_to_bytes
             (src_buf, src_ofs, dst_buf, dst_ofs, len);
    return caml_call1(Stdlib[1], cst_Lwt_bytes_blit_to_bytes);
   }
   function blit(src_buf, src_ofs, dst_buf, dst_ofs, len){
    if
     (0 <= len
      &&
       0 <= src_ofs
       &&
        (caml_ba_dim_1(src_buf) - len | 0) >= src_ofs
        && 0 <= dst_ofs && (caml_ba_dim_1(dst_buf) - len | 0) >= dst_ofs)
     return runtime.lwt_unix_blit(src_buf, src_ofs, dst_buf, dst_ofs, len);
    return caml_call1(Stdlib[1], cst_Lwt_bytes_blit);
   }
   function of_bytes(buf){
    var len = caml_ml_bytes_length(buf), bytes = create(len);
    runtime.lwt_unix_blit_from_bytes(buf, 0, bytes, 0, len);
    return bytes;
   }
   function of_string(str){
    return of_bytes(caml_call1(Stdlib_Bytes[45], str));
   }
   function to_bytes(bytes){
    var len = caml_ba_dim_1(bytes), str = runtime.caml_create_bytes(len);
    runtime.lwt_unix_blit_to_bytes(bytes, 0, str, 0, len);
    return str;
   }
   function to_string(bytes){
    var _G_ = to_bytes(bytes);
    return caml_call1(Stdlib_Bytes[44], _G_);
   }
   var proxy = runtime.caml_ba_sub;
   function extract(buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ba_dim_1(buf) - len | 0) >= ofs){
     var buf$0 = create(len);
     blit(buf, ofs, buf$0, 0, len);
     return buf$0;
    }
    return caml_call1(Stdlib[1], cst_Lwt_bytes_extract);
   }
   function copy(buf){
    var len = caml_ba_dim_1(buf), buf$0 = create(len);
    blit(buf, 0, buf$0, 0, len);
    return buf$0;
   }
   var
    read = caml_call1(Lwt_unix[173], cst_Lwt_bytes_read),
    write = caml_call1(Lwt_unix[174], cst_Lwt_bytes_write);
   function recv(fd, buf, pos, len, flags){
    if(0 <= pos && 0 <= len && (caml_ba_dim_1(buf) - len | 0) >= pos){
     var
      _F_ =
        function(param){
         return runtime.lwt_unix_bytes_recv
                 (caml_call1(Lwt_unix[10], fd), buf, pos, len, flags);
        };
     return caml_call3(Lwt_unix[148], 0, fd, _F_);
    }
    return caml_call1(Stdlib[1], cst_Lwt_bytes_recv);
   }
   function send(fd, buf, pos, len, flags){
    if(0 <= pos && 0 <= len && (caml_ba_dim_1(buf) - len | 0) >= pos){
     var
      _E_ =
        function(param){
         return runtime.lwt_unix_bytes_send
                 (caml_call1(Lwt_unix[10], fd), buf, pos, len, flags);
        };
     return caml_call3(Lwt_unix[148], 1, fd, _E_);
    }
    return caml_call1(Stdlib[1], cst_Lwt_bytes_send);
   }
   function io_vector(buffer, offset, length){return [0, buffer, offset, length];
   }
   function convert_io_vectors(old_io_vectors){
    var io_vectors = caml_call1(Lwt_unix[32][1], 0);
    function _D_(param){
     var iov_length = param[3], iov_offset = param[2], iov_buffer = param[1];
     return caml_call4
             (Lwt_unix[32][3], io_vectors, iov_buffer, iov_offset, iov_length);
    }
    caml_call1(caml_call1(Stdlib_List[18], _D_), old_io_vectors);
    return io_vectors;
   }
   function recv_msg(socket, io_vectors){
    var _C_ = convert_io_vectors(io_vectors);
    return caml_call2(Lwt_unix[106], socket, _C_);
   }
   function send_msg(socket, io_vectors, fds){
    var _B_ = convert_io_vectors(io_vectors);
    return caml_call3(Lwt_unix[107], socket, _B_, fds);
   }
   function recvfrom(fd, buf, pos, len, flags){
    if(0 <= pos && 0 <= len && (caml_ba_dim_1(buf) - len | 0) >= pos){
     var
      _A_ =
        function(param){
         return runtime.lwt_unix_bytes_recvfrom
                 (caml_call1(Lwt_unix[10], fd), buf, pos, len, flags);
        };
     return caml_call3(Lwt_unix[148], 0, fd, _A_);
    }
    return caml_call1(Stdlib[1], cst_Lwt_bytes_recvfrom);
   }
   function sendto(fd, buf, pos, len, flags, addr){
    if(0 <= pos && 0 <= len && (caml_ba_dim_1(buf) - len | 0) >= pos){
     var
      _z_ =
        function(param){
         return runtime.lwt_unix_bytes_sendto_byte
                 (caml_call1(Lwt_unix[10], fd), buf, pos, len, flags, addr);
        };
     return caml_call3(Lwt_unix[148], 1, fd, _z_);
    }
    return caml_call1(Stdlib[1], cst_Lwt_bytes_sendto);
   }
   function map_file(fd, pos, shared, opt, param){
    if(opt) var sth = opt[1], size = sth; else var size = -1;
    var
     _y_ =
       caml_call6
        (Unix[44],
         fd,
         pos,
         Stdlib_Bigarray[13],
         Stdlib_Bigarray[15],
         shared,
         [0, size]);
    return caml_call1(Stdlib_Bigarray[23], _y_);
   }
   function madvise(buf, pos, len, advice){
    if(0 <= pos && 0 <= len && (caml_ba_dim_1(buf) - len | 0) >= pos)
     return runtime.lwt_unix_madvise(buf, pos, len, advice);
    return caml_call1(Stdlib[1], cst_Lwt_bytes_madvise);
   }
   var page_size = runtime.lwt_unix_get_page_size(0);
   function mincore(buffer, offset, states){
    if
     (0 === caml_mod(offset, page_size)
      &&
       0 <= offset
       &&
        (caml_ba_dim_1(buffer) - offset | 0)
        >= (caml_mul(states.length - 1 - 1 | 0, page_size) + 1 | 0))
     return runtime.lwt_unix_mincore
             (buffer, offset, caml_mul(states.length - 1, page_size), states);
    return caml_call1(Stdlib[1], cst_Lwt_bytes_mincore);
   }
   function wait_mincore(buffer, offset){
    if(0 <= offset && caml_ba_dim_1(buffer) > offset){
     var state = [0, 0];
     mincore(buffer, offset - caml_mod(offset, page_size) | 0, state);
     if(runtime.caml_check_bound(state, 0)[1]) return Lwt[36];
     var _x_ = runtime.lwt_unix_wait_mincore_job(buffer, offset);
     return caml_call2(Lwt_unix[151], 0, _x_);
    }
    return caml_call1(Stdlib[1], cst_Lwt_bytes_wait_mincore);
   }
   function _a_(_w_, _v_, _u_, _t_, _s_){
    return runtime.lwt_unix_blit_to_bytes(_w_, _v_, _u_, _t_, _s_);
   }
   function _b_(_r_, _q_, _p_, _o_, _n_){
    return runtime.lwt_unix_blit_from_string(_r_, _q_, _p_, _o_, _n_);
   }
   function _c_(_m_, _l_, _k_, _j_, _i_){
    return runtime.lwt_unix_blit_from_bytes(_m_, _l_, _k_, _j_, _i_);
   }
   var
    Lwt_bytes =
      [0,
       create,
       length,
       caml_ba_get_1,
       caml_ba_set_1,
       caml_ba_get_1,
       caml_ba_set_1,
       of_bytes,
       of_string,
       to_bytes,
       to_string,
       blit,
       blit_from_string,
       blit_from_bytes,
       blit_to_bytes,
       function(_h_, _g_, _f_, _e_, _d_){
        return runtime.lwt_unix_blit(_h_, _g_, _f_, _e_, _d_);
       },
       _c_,
       _b_,
       _a_,
       proxy,
       extract,
       copy,
       fill,
       read,
       write,
       recv,
       send,
       recvfrom,
       sendto,
       io_vector,
       recv_msg,
       send_msg,
       map_file,
       madvise,
       page_size,
       mincore,
       wait_mincore];
   runtime.caml_register_global(22, Lwt_bytes, "Lwt_bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_io
//# unitInfo: Requires: CamlinternalLazy, EndianBigstring, Lwt, Lwt_bytes, Lwt_list, Lwt_main, Lwt_sequence, Lwt_stream, Lwt_sys, Lwt_unix, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Filename, Stdlib__Gc, Stdlib__Int32, Stdlib__Int64, Stdlib__List, Stdlib__Marshal, Stdlib__Printf, Stdlib__Random, Stdlib__String, Stdlib__Sys, Stdlib__Weak, Unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst_Lwt_io = "Lwt_io.",
    cst_set_position$1 = "set_position",
    cst_src_unix_lwt_io_ml = "src/unix/lwt_io.ml",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_equal = runtime.caml_string_equal,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$2,
    cst$0 = cst$2,
    cst = cst$2,
    fun_name = "Lwt_io.make",
    Lwt = global_data.Lwt,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Lwt_unix = global_data.Lwt_unix,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Lwt_stream = global_data.Lwt_stream,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Lwt_bytes = global_data.Lwt_bytes,
    Unix = global_data.Unix,
    Stdlib = global_data.Stdlib,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Marshal = global_data.Stdlib__Marshal,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Lwt_sequence = global_data.Lwt_sequence,
    Lwt_list = global_data.Lwt_list,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Weak = global_data.Stdlib__Weak,
    Lwt_main = global_data.Lwt_main,
    EndianBigstring = global_data.EndianBigstring,
    Lwt_sys = global_data.Lwt_sys,
    Channel_closed =
      [248, "Lwt_io.Channel_closed", runtime.caml_fresh_oo_id(0)],
    cst_set_default_buffer_size = "set_default_buffer_size",
    _u_ = [0, 1],
    cst_file_length = "file_length",
    cst_lwt_io_temp_dir = "lwt_io_temp_dir_",
    _t_ = [0, 1, [0, 5, [0, 7, [0, 13, 0]]]],
    cst_lwt_io_temp_file = "lwt_io_temp_file_",
    _s_ = [0, [2, 0, [4, 6, [0, 2, 6], 0, [2, 0, 0]]], "%s%06x%s"],
    _q_ = [0, 1, [0, 5, [0, 6, [0, 3, 0]]]],
    _r_ = [0, 0, [0, 3, 0]],
    cst_length = "length",
    _n_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_set_position = cst_set_position$1,
    cst_set_position$0 = cst_set_position$1,
    _m_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Lwt_io_set_position_out_of = "Lwt_io.set_position: out of bounds",
    _l_ =
      [0,
       [11, cst_Lwt_io, [2, 0, [11, ": seek failed", 0]]],
       "Lwt_io.%s: seek failed"],
    cst_Lwt_io_direct_access_inval =
      "Lwt_io.direct_access: invalid result of [f]",
    cst_Lwt_io_direct_access_da_pe = "Lwt_io.direct_access.da_perform",
    cst_Lwt_io_direct_access = "Lwt_io.direct_access",
    cst_Lwt_io_perform_this_functi =
      "Lwt_io.perform: this function can not be called outside ",
    cst_Lwt_io_block = "Lwt_io.block",
    cst_Lwt_io_write_from_exactly_ = "Lwt_io.write_from_exactly_bigstring",
    cst_Lwt_io_write_from_exactly = "Lwt_io.write_from_exactly",
    cst_Lwt_io_write_from = "Lwt_io.write_from",
    cst_Lwt_io_write_from_bigstrin = "Lwt_io.write_from_bigstring",
    cst_Lwt_io_read_into_exactly = "Lwt_io.read_into_exactly",
    cst_Lwt_io_read_into_exactly_b = "Lwt_io.read_into_exactly_bigstring",
    cst_Lwt_io_read_into = "Lwt_io.read_into",
    cst_Lwt_io_read_into_bigstring = "Lwt_io.read_into_bigstring",
    cst_unread_data = "unread data",
    cst_Lwt_io_resize_buffer_canno =
      "Lwt_io.resize_buffer: cannot decrease buffer size, too much ",
    cst_Lwt_io_resize_buffer_buffe =
      "Lwt_io.resize_buffer: buffer size too small",
    cst_created_with_Lwt_io_of_str = "created with Lwt_io.of_string",
    cst_Lwt_io_resize_buffer_canno$0 =
      "Lwt_io.resize_buffer: cannot resize the buffer of a channel ",
    _k_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _j_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Lwt_io_seek_seek_not_suppo =
      "Lwt_io.seek: seek not supported on this channel",
    cst_Lwt_io_close_cannot_close_ =
      "Lwt_io.close: cannot close a channel obtained via Lwt_io.atomic",
    _i_ = [0, cst_src_unix_lwt_io_ml, 435, 8],
    _h_ = [0, cst_src_unix_lwt_io_ml, 387, 8],
    _g_ = [0, cst_src_unix_lwt_io_ml, 355, 4],
    _f_ = [0, cst_src_unix_lwt_io_ml, 308, 4],
    cst_write = "write",
    cst_read = "read",
    _d_ =
      [0,
       [11,
        "Lwt_io.perform_io: invalid result of the [",
        [2, 0, [11, "] function", 0]]],
       "Lwt_io.perform_io: invalid result of the [%s] function"],
    _e_ = [0, cst_src_unix_lwt_io_ml, 205, 4],
    cst_cannot_flush_a_channel_cre =
      "cannot flush a channel created with Lwt_io.of_string",
    _c_ =
      [0,
       [11, "temporary atomic channel ", [2, 0, [11, " no more valid", 0]]],
       "temporary atomic channel %s no more valid"],
    cst_output = "output",
    cst_input = "input",
    _a_ =
      [0,
       [11, cst_Lwt_io, [2, 0, [11, ": too small buffer size", 0]]],
       "Lwt_io.%s: too small buffer size"],
    _b_ =
      [0,
       [11, cst_Lwt_io, [2, 0, [11, ": too big buffer size", 0]]],
       "Lwt_io.%s: too big buffer size"],
    min_buffer_size = 16;
   function check_buffer_size(fun_name, buffer_size){
    if(buffer_size < 16)
     return caml_call3(Stdlib_Printf[10], Stdlib[1], _a_, fun_name);
    if(Stdlib_Sys[12] < buffer_size)
     return caml_call3(Stdlib_Printf[10], Stdlib[1], _b_, fun_name);
    return;
   }
   var default_buffer_size = [0, 4096], input = 0, output = 1;
   function mode(wrapper){return wrapper[2][10];}
   var index = [0, 0];
   function hash(param){index[1] = index[1] + 1 | 0; return index[1];}
   function equal(_eJ_, _eI_){return _eJ_ === _eI_ ? 1 : 0;}
   var
    Outputs = caml_call1(Stdlib_Weak[9], [0, equal, hash]),
    outputs = caml_call1(Outputs[1], 32);
   function position(wrapper){
    var ch = wrapper[2];
    return ch[10]
            ? caml_int64_add(ch[11], caml_int64_of_int32(ch[3]))
            : caml_int64_sub(ch[11], caml_int64_of_int32(ch[4] - ch[3] | 0));
   }
   function name(ch){return ch[10] ? cst_output : cst_input;}
   function closed_channel(ch){return [0, Channel_closed, name(ch)];}
   function invalid_channel(ch){
    var _eG_ = name(ch), _eH_ = caml_call2(Stdlib_Printf[4], _c_, _eG_);
    return [0, Stdlib[7], _eH_];
   }
   function is_busy(ch){
    var _eF_ = ch[1];
    if(typeof _eF_ === "number" && 2 <= _eF_){
     if(4 <= _eF_)
      throw caml_maybe_attach_backtrace(invalid_channel(ch[2]), 1);
     return 0;
    }
    return 1;
   }
   function flush_partial(ch){
    var _ev_ = ch[8][1];
    if(typeof _ev_ === "number")
     switch(_ev_){
       case 3:
        var _eA_ = closed_channel(ch); return caml_call1(Lwt[5], _eA_);
       case 4:
        var _eB_ = invalid_channel(ch); return caml_call1(Lwt[5], _eB_);
       case 0: break;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     }
    var match = ch[12];
    if(! match)
     return ch[10]
             ? caml_call1
               (Lwt[5], [0, Stdlib[7], cst_cannot_flush_a_channel_cre])
             : caml_call1(Lwt[4], 0);
    var perform = match[1];
    if(ch[10])
     var len = ch[3], ptr = 0;
    else{
     var size = ch[4] - ch[3] | 0;
     if(0 < size) caml_call5(Lwt_bytes[15], ch[1], ch[3], ch[1], 0, size);
     ch[3] = 0;
     ch[4] = size;
     var len$0 = ch[2] - size | 0, len = len$0, ptr = size;
    }
    if(Stdlib_Sys[7])
     var
      _ew_ =
        function(exn){
         if(exn[1] === Unix[1]){
          var _eE_ = exn[2];
          if(typeof _eE_ === "number" && 31 === _eE_)
           return caml_call1(Lwt[4], 0);
         }
         throw caml_maybe_attach_backtrace(exn, 0);
        },
      _ex_ = function(param){return caml_call3(perform, ch[1], ptr, len);},
      perform$0 = caml_call2(Lwt[7], _ex_, _ew_);
    else
     var perform$0 = caml_call3(perform, ch[1], ptr, len);
    function _ey_(n){
     if(0 <= n && len >= n){
      ch[11] = caml_int64_add(ch[11], caml_int64_of_int32(n));
      if(ch[10]){
       var len$0 = len - n | 0;
       caml_call5(Lwt_bytes[15], ch[1], n, ch[1], 0, len$0);
       ch[3] = len$0;
      }
      else
       ch[4] = ch[4] + n | 0;
      return caml_call1(Lwt[4], n);
     }
     var
      _eC_ = ch[10] ? cst_write : cst_read,
      _eD_ = caml_call2(Stdlib_Printf[4], _d_, _eC_);
     return caml_call1(Lwt[5], [0, Stdlib[7], _eD_]);
    }
    var _ez_ = caml_call1(Lwt[16], [0, ch[5], [0, perform$0, 0]]);
    return caml_call2(Lwt[33][1], _ez_, _ey_);
   }
   function flush_total(oc){
    if(0 >= oc[3]) return Lwt[36];
    function _et_(param){return flush_total(oc);}
    var _eu_ = flush_partial(oc);
    return caml_call2(Lwt[33][1], _eu_, _et_);
   }
   function safe_flush_total(oc){
    function _er_(param){return Lwt[36];}
    function _es_(param){return flush_total(oc);}
    return caml_call2(Lwt[7], _es_, _er_);
   }
   function auto_flush(oc){
    function _el_(param){
     var wrapper$1 = oc[8], wrapper = wrapper$1;
     for(;;){
      var match = wrapper[1];
      if(typeof match === "number"){
       var _en_ = wrapper[1];
       if(typeof _en_ !== "number")
        throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
       if(2 !== _en_) return 3 <= _en_ ? Lwt[36] : (oc[7] = 0, Lwt[36]);
       oc[7] = 0;
       wrapper[1] = 0;
       var
        _eo_ =
          function(param){
           if(0 === wrapper[1]) wrapper[1] = 2;
           if(1 - caml_call1(Lwt_sequence[6], wrapper[3])){
            var _eq_ = caml_call1(Lwt_sequence[11], wrapper[3]);
            caml_call2(Lwt[2], _eq_, 0);
           }
           return Lwt[36];
          },
        _ep_ = safe_flush_total(oc);
       return caml_call2(Lwt[33][1], _ep_, _eo_);
      }
      var wrapper$0 = match[1], wrapper = wrapper$0;
     }
    }
    var _em_ = caml_call1(Lwt[57], 0);
    return caml_call2(Lwt[33][1], _em_, _el_);
   }
   function unlock(wrapper){
    var _ed_ = wrapper[1];
    if(typeof _ed_ === "number" && _ed_){
     if(3 > _ed_)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     var _ee_ = 1 - caml_call1(Lwt_sequence[6], wrapper[3]);
     if(! _ee_) return _ee_;
     var _ef_ = caml_call1(Lwt_sequence[11], wrapper[3]);
     return caml_call2(Lwt[2], _ef_, 0);
    }
    if(caml_call1(Lwt_sequence[6], wrapper[3]))
     wrapper[1] = 2;
    else{
     wrapper[1] = 1;
     var _ek_ = caml_call1(Lwt_sequence[11], wrapper[3]);
     caml_call2(Lwt[2], _ek_, 0);
    }
    var ch = wrapper[2], _eg_ = 2 === wrapper[1] ? 1 : 0;
    if(_eg_){
     var _eh_ = ch[10] ? 1 : 0;
     if(_eh_)
      var
       _ei_ = 1 - ch[7],
       _ej_ = _ei_ ? caml_call1(Lwt_sequence[6], wrapper[3]) : _ei_;
     else
      var _ej_ = _eh_;
    }
    else
     var _ej_ = _eg_;
    if(_ej_){ch[7] = 1; auto_flush(ch);}
    return;
   }
   function primitive(f, wrapper){
    var _d3_ = wrapper[1];
    if(typeof _d3_ === "number")
     switch(_d3_){
       case 2:
        wrapper[1] = 0;
        var
         _d6_ = function(param){unlock(wrapper); return Lwt[36];},
         _d7_ = function(param){return caml_call1(f, wrapper[2]);};
        return caml_call2(Lwt[8], _d7_, _d6_);
       case 3:
        var _d8_ = closed_channel(wrapper[2]);
        return caml_call1(Lwt[5], _d8_);
       case 4:
        var _d9_ = invalid_channel(wrapper[2]);
        return caml_call1(Lwt[5], _d9_);
     }
    function _d4_(param){
     var _d__ = wrapper[1];
     if(typeof _d__ === "number")
      switch(_d__){
        case 3:
         unlock(wrapper);
         var _eb_ = closed_channel(wrapper[2]);
         return caml_call1(Lwt[5], _eb_);
        case 4:
         var _ec_ = invalid_channel(wrapper[2]);
         return caml_call1(Lwt[5], _ec_);
        case 0: break;
        default:
         wrapper[1] = 0;
         var
          _d$_ = function(param){unlock(wrapper); return Lwt[36];},
          _ea_ = function(param){return caml_call1(f, wrapper[2]);};
         return caml_call2(Lwt[8], _ea_, _d$_);
      }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    }
    var _d5_ = caml_call1(Lwt[55], wrapper[3]);
    return caml_call2(Lwt[33][1], _d5_, _d4_);
   }
   function atomic(f, wrapper){
    var _dP_ = wrapper[1];
    if(typeof _dP_ === "number")
     switch(_dP_){
       case 2:
        var
         _dS_ = caml_call1(Lwt_sequence[4], 0),
         tmp_wrapper = [0, 2, wrapper[2], _dS_];
        wrapper[1] = [0, tmp_wrapper];
        var
         _dT_ =
           function(param){
            tmp_wrapper[1] = 4;
            unlock(wrapper);
            return Lwt[36];
           },
         _dU_ = function(param){return caml_call1(f, tmp_wrapper);};
        return caml_call2(Lwt[8], _dU_, _dT_);
       case 3:
        var _dV_ = closed_channel(wrapper[2]);
        return caml_call1(Lwt[5], _dV_);
       case 4:
        var _dW_ = invalid_channel(wrapper[2]);
        return caml_call1(Lwt[5], _dW_);
     }
    function _dQ_(param){
     var _dX_ = wrapper[1];
     if(typeof _dX_ === "number")
      switch(_dX_){
        case 3:
         unlock(wrapper);
         var _d1_ = closed_channel(wrapper[2]);
         return caml_call1(Lwt[5], _d1_);
        case 4:
         var _d2_ = invalid_channel(wrapper[2]);
         return caml_call1(Lwt[5], _d2_);
        case 0: break;
        default:
         var
          _dY_ = caml_call1(Lwt_sequence[4], 0),
          tmp_wrapper = [0, 2, wrapper[2], _dY_];
         wrapper[1] = [0, tmp_wrapper];
         var
          _dZ_ =
            function(param){
             tmp_wrapper[1] = 4;
             unlock(wrapper);
             return Lwt[36];
            },
          _d0_ = function(param){return caml_call1(f, tmp_wrapper);};
         return caml_call2(Lwt[8], _d0_, _dZ_);
      }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
    }
    var _dR_ = caml_call1(Lwt[55], wrapper[3]);
    return caml_call2(Lwt[33][1], _dR_, _dQ_);
   }
   function abort(wrapper){
    var wrapper$0 = wrapper;
    for(;;){
     var match = wrapper$0[1];
     if(typeof match === "number"){
      if(3 === match){
       var _dJ_ = wrapper$0[2][9], _dK_ = caml_obj_tag(_dJ_);
       if(250 === _dK_) return _dJ_[1];
       if(246 !== _dK_ && 244 !== _dK_) return _dJ_;
       return caml_call1(CamlinternalLazy[2], _dJ_);
      }
      if(4 <= match){
       var _dL_ = invalid_channel(wrapper$0[2]);
       return caml_call1(Lwt[5], _dL_);
      }
      wrapper$0[1] = 3;
      var _dM_ = closed_channel(wrapper$0[2]);
      caml_call2(Lwt[53], wrapper$0[2][6], _dM_);
      var _dN_ = wrapper$0[2][9], _dO_ = caml_obj_tag(_dN_);
      if(250 === _dO_) return _dN_[1];
      if(246 !== _dO_ && 244 !== _dO_) return _dN_;
      return caml_call1(CamlinternalLazy[2], _dN_);
     }
     var tmp_wrapper = match[1], wrapper$0 = tmp_wrapper;
    }
   }
   function close(wrapper){
    var channel = wrapper[2];
    if(channel[8] !== wrapper)
     return caml_call1(Lwt[5], [0, Stdlib[7], cst_Lwt_io_close_cannot_close_]);
    if(! channel[10]) return abort(wrapper);
    function _dF_(param){return abort(wrapper);}
    function _dG_(param){
     return primitive
             (function(channel){
               function _dH_(param){return abort(wrapper);}
               var _dI_ = safe_flush_total(channel);
               return caml_call2(Lwt[33][1], _dI_, _dH_);
              },
              wrapper);
    }
    return caml_call2(Lwt[7], _dG_, _dF_);
   }
   function is_closed(wrapper){
    var _dE_ = wrapper[1];
    if(typeof _dE_ === "number" && 3 === _dE_) return 1;
    return 0;
   }
   function flush_all(param){
    var _dz_ = 0;
    function _dA_(x, l){return [0, x, l];}
    var wrappers = caml_call3(Outputs[11], _dA_, outputs, _dz_);
    function _dB_(wrapper){
     function _dC_(param){return Lwt[36];}
     function _dD_(param){return primitive(safe_flush_total, wrapper);}
     return caml_call2(Lwt[7], _dD_, _dC_);
    }
    return caml_call2(Lwt_list[2], _dB_, wrappers);
   }
   caml_call1(Lwt_main[10], flush_all);
   function no_seek(pos, cmd){
    return caml_call1(Lwt[5], [0, Stdlib[7], cst_Lwt_io_seek_seek_not_suppo]);
   }
   function make(buffer, opt, _dr_, mode, perform_io){
    if(opt) var sth = opt[1], close = sth; else var close = Lwt[4];
    if(_dr_) var sth$0 = _dr_[1], seek = sth$0; else var seek = no_seek;
    if(buffer){
     var buffer$0 = buffer[1];
     check_buffer_size(fun_name, caml_call1(Lwt_bytes[2], buffer$0));
     var size = caml_call1(Lwt_bytes[2], buffer$0), buffer$1 = buffer$0;
    }
    else
     var
      size$1 = default_buffer_size[1],
      buffer$2 = caml_call1(Lwt_bytes[1], size$1),
      size = size$1,
      buffer$1 = buffer$2;
    var
     match = caml_call1(Lwt[1], 0),
     abort_wakener = match[2],
     abort_waiter = match[1],
     ch = [],
     wrapper = [],
     _ds_ =
       [0,
        perform_io,
        function(pos, cmd){
         try{var _dy_ = caml_call2(seek, pos, cmd); return _dy_;}
         catch(e$0){
          var e = caml_wrap_exception(e$0);
          if(caml_call1(Lwt[78][4], e))
           throw caml_maybe_attach_backtrace(e, 0);
          throw caml_maybe_attach_backtrace(e, 0);
         }
        }],
     _dt_ =
       [246,
        function(_dv_){
         function _dw_(_dx_){throw caml_maybe_attach_backtrace(_dx_, 0);}
         return caml_call2(Lwt[7], close, _dw_);
        }],
     _du_ = 0,
     size$0 = mode ? size : 0;
    caml_update_dummy
     (ch,
      [0,
       buffer$1,
       size,
       0,
       size$0,
       abort_waiter,
       abort_wakener,
       _du_,
       wrapper,
       _dt_,
       mode,
       _j_,
       _ds_]);
    caml_update_dummy(wrapper, [0, 2, ch, caml_call1(Lwt_sequence[4], 0)]);
    if(mode) caml_call2(Outputs[4], outputs, wrapper);
    return wrapper;
   }
   function of_bytes(mode, bytes){
    var
     length = caml_call1(Lwt_bytes[2], bytes),
     match = caml_call1(Lwt[1], 0),
     abort_wakener = match[2],
     abort_waiter = match[1],
     ch = [],
     wrapper = [],
     _dp_ = 0,
     _dq_ = mode ? _k_ : caml_int64_of_int32(length);
    caml_update_dummy
     (ch,
      [0,
       bytes,
       length,
       0,
       length,
       abort_waiter,
       abort_wakener,
       1,
       wrapper,
       [250, Lwt[36]],
       mode,
       _dq_,
       _dp_]);
    caml_update_dummy(wrapper, [0, 2, ch, caml_call1(Lwt_sequence[4], 0)]);
    return wrapper;
   }
   function of_fd(buffer, close, mode, fd){
    var
     perform_io =
       mode ? caml_call1(Lwt_bytes[24], fd) : caml_call1(Lwt_bytes[23], fd),
     _do_ =
       [0,
        function(pos, cmd){return caml_call3(Lwt_unix[50][1], fd, pos, cmd);}];
    if(close)
     var f = close[1], f$0 = f;
    else
     var f$0 = function(param){return caml_call1(Lwt_unix[25], fd);};
    return make(buffer, [0, f$0], _do_, mode, perform_io);
   }
   function of_unix_fd(buffer, close, mode, fd){
    return of_fd(buffer, close, mode, caml_call3(Lwt_unix[11], 0, 0, fd));
   }
   function buffered(ch){
    return ch[2][10] ? ch[2][3] : ch[2][4] - ch[2][3] | 0;
   }
   function buffer_size(ch){return ch[2][2];}
   function resize_buffer(wrapper, len){
    if(len < 16) caml_call1(Stdlib[1], cst_Lwt_io_resize_buffer_buffe);
    if(wrapper[2][12]){
     var
      f =
        function(ch){
         if(ch[10]){
          var
           loop =
             function(param){
              if(len >= ch[3]) return Lwt[36];
              function _dm_(param){return loop(0);}
              var _dn_ = flush_partial(ch);
              return caml_call2(Lwt[33][1], _dn_, _dm_);
             },
           _dj_ =
             function(param){
              var buffer = caml_call1(Lwt_bytes[1], len);
              caml_call5(Lwt_bytes[15], ch[1], 0, buffer, 0, ch[3]);
              ch[1] = buffer;
              ch[2] = len;
              ch[4] = len;
              return Lwt[36];
             },
           _dk_ = loop(0);
          return caml_call2(Lwt[33][1], _dk_, _dj_);
         }
         var unread_count = ch[4] - ch[3] | 0;
         if(len < unread_count){
          var
           _dl_ =
             caml_call2
              (Stdlib[28], cst_Lwt_io_resize_buffer_canno, cst_unread_data);
          return caml_call1(Lwt[5], [0, Stdlib[7], _dl_]);
         }
         var buffer = caml_call1(Lwt_bytes[1], len);
         caml_call5(Lwt_bytes[15], ch[1], ch[3], buffer, 0, unread_count);
         ch[1] = buffer;
         ch[2] = len;
         ch[3] = 0;
         ch[4] = unread_count;
         return Lwt[36];
        };
     return primitive(f, wrapper);
    }
    var
     _di_ =
       caml_call2
        (Stdlib[28],
         cst_Lwt_io_resize_buffer_canno$0,
         cst_created_with_Lwt_io_of_str);
    return caml_call1(Lwt[5], [0, Stdlib[7], _di_]);
   }
   function read_char(ic){
    var ptr = ic[3];
    if(ptr === ic[4]){
     var
      _df_ =
        function(param){
         if(0 === param) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
         return read_char(ic);
        },
      _dg_ = flush_partial(ic);
     return caml_call2(Lwt[33][1], _dg_, _df_);
    }
    ic[3] = ptr + 1 | 0;
    var _dh_ = caml_call2(Lwt_bytes[5], ic[1], ptr);
    return caml_call1(Lwt[4], _dh_);
   }
   function read_char_opt(ic){
    function _db_(exn){
     if(exn === Stdlib[12]) return Lwt[37];
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    function _dc_(param){
     function _dd_(ch){return [0, ch];}
     var _de_ = read_char(ic);
     return caml_call2(Lwt[33][2], _de_, _dd_);
    }
    return caml_call2(Lwt[7], _dc_, _db_);
   }
   function read_line(ic){
    var buf = caml_call1(Stdlib_Buffer[1], 128);
    function loop(cr_read){
     function _c8_(exn){
      if(exn !== Stdlib[12]) throw caml_maybe_attach_backtrace(exn, 0);
      if(cr_read) caml_call2(Stdlib_Buffer[12], buf, 13);
      var _da_ = caml_call1(Stdlib_Buffer[2], buf);
      return caml_call1(Lwt[4], _da_);
     }
     function _c9_(ch){
      if(10 === ch){
       var _c$_ = caml_call1(Stdlib_Buffer[2], buf);
       return caml_call1(Lwt[4], _c$_);
      }
      if(13 === ch){
       if(cr_read) caml_call2(Stdlib_Buffer[12], buf, 13);
       return loop(1);
      }
      if(cr_read) caml_call2(Stdlib_Buffer[12], buf, 13);
      caml_call2(Stdlib_Buffer[12], buf, ch);
      return loop(0);
     }
     function _c__(param){return read_char(ic);}
     return caml_call3(Lwt[9], _c__, _c9_, _c8_);
    }
    function _c6_(ch){
     return 10 === ch
             ? caml_call1(Lwt[4], cst)
             : 13
               === ch
               ? loop(1)
               : (caml_call2(Stdlib_Buffer[12], buf, ch), loop(0));
    }
    var _c7_ = read_char(ic);
    return caml_call2(Lwt[33][1], _c7_, _c6_);
   }
   function read_line_opt(ic){
    function _c2_(exn){
     if(exn === Stdlib[12]) return Lwt[37];
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    function _c3_(param){
     function _c4_(ch){return [0, ch];}
     var _c5_ = read_line(ic);
     return caml_call2(Lwt[33][2], _c5_, _c4_);
    }
    return caml_call2(Lwt[7], _c3_, _c2_);
   }
   function unsafe_read_into(ic, blit, buf, ofs, len){
    var avail = ic[4] - ic[3] | 0;
    if(0 < avail){
     var len$0 = caml_call2(Stdlib[16], len, avail);
     caml_call5(blit, ic[1], ic[3], buf, ofs, len$0);
     ic[3] = ic[3] + len$0 | 0;
     return caml_call1(Lwt[4], len$0);
    }
    function _c0_(n){
     var len$0 = caml_call2(Stdlib[16], len, n);
     caml_call5(blit, ic[1], 0, buf, ofs, len$0);
     ic[3] = len$0;
     ic[4] = n;
     return caml_call1(Lwt[4], len$0);
    }
    var _c1_ = flush_partial(ic);
    return caml_call2(Lwt[33][1], _c1_, _c0_);
   }
   function unsafe_read_into_bigstring(ic, buf, ofs, len){
    return unsafe_read_into(ic, Lwt_bytes[15], buf, ofs, len);
   }
   function unsafe_read_into$0(ic, buf, ofs, len){
    return unsafe_read_into(ic, Lwt_bytes[18], buf, ofs, len);
   }
   function unsafe_read_into_exactly(read_into, ic, buf, ofs, len){
    function loop(ic, buf, ofs, len){
     function _cY_(n){
      if(0 === n) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
      var len$0 = len - n | 0;
      return 0 === len$0 ? Lwt[36] : loop(ic, buf, ofs + n | 0, len$0);
     }
     var _cZ_ = caml_call4(read_into, ic, buf, ofs, len);
     return caml_call2(Lwt[33][1], _cZ_, _cY_);
    }
    return loop(ic, buf, ofs, len);
   }
   function unsafe_read_into_exactly$0(ic, buf, ofs, len){
    return unsafe_read_into_exactly(unsafe_read_into$0, ic, buf, ofs, len);
   }
   function read_all(ic, total_len, acc){
    var len = ic[4] - ic[3] | 0, buf = caml_create_bytes(len);
    caml_call5(Lwt_bytes[18], ic[1], ic[3], buf, 0, len);
    var str = caml_call1(Stdlib_Bytes[44], buf);
    ic[3] = ic[4];
    function _cV_(param){
     if(0 !== param) return read_all(ic, len + total_len | 0, [0, str, acc]);
     var
      l = [0, str, acc],
      len$0 = len + total_len | 0,
      buf = caml_create_bytes(len$0);
     function _cX_(ofs, str){
      var len = runtime.caml_ml_string_length(str), ofs$0 = ofs - len | 0;
      runtime.caml_blit_string(str, 0, buf, ofs$0, len);
      return ofs$0;
     }
     caml_call3(Stdlib_List[26], _cX_, len$0, l);
     return caml_call1(Lwt[4], buf);
    }
    var _cW_ = flush_partial(ic);
    return caml_call2(Lwt[33][1], _cW_, _cV_);
   }
   function read_value(ic){
    var header = caml_create_bytes(Stdlib_Marshal[6]);
    function _cQ_(param){
     var
      bsize = caml_call2(Stdlib_Marshal[7], header, 0),
      buffer = caml_create_bytes(Stdlib_Marshal[6] + bsize | 0);
     runtime.caml_blit_bytes(header, 0, buffer, 0, Stdlib_Marshal[6]);
     function _cS_(param){
      var _cU_ = caml_call2(Stdlib_Marshal[4], buffer, 0);
      return caml_call1(Lwt[4], _cU_);
     }
     var
      _cT_ = unsafe_read_into_exactly$0(ic, buffer, Stdlib_Marshal[6], bsize);
     return caml_call2(Lwt[33][1], _cT_, _cS_);
    }
    var _cR_ = unsafe_read_into_exactly$0(ic, header, 0, Stdlib_Marshal[6]);
    return caml_call2(Lwt[33][1], _cR_, _cQ_);
   }
   function write_char(oc, ch){
    var ptr = oc[3];
    if(ptr < oc[2]){
     oc[3] = ptr + 1 | 0;
     caml_call3(Lwt_bytes[6], oc[1], ptr, ch);
     return Lwt[36];
    }
    function _cO_(param){return write_char(oc, ch);}
    var _cP_ = flush_partial(oc);
    return caml_call2(Lwt[33][1], _cP_, _cO_);
   }
   function unsafe_write_from(blit, oc, str, ofs, len){
    var avail = oc[2] - oc[3] | 0;
    if(len <= avail){
     caml_call5(blit, str, ofs, oc[1], oc[3], len);
     oc[3] = oc[3] + len | 0;
     return caml_call1(Lwt[4], 0);
    }
    caml_call5(blit, str, ofs, oc[1], oc[3], avail);
    oc[3] = oc[2];
    function _cM_(param){
     var len$0 = len - avail | 0;
     return 0 === oc[3]
             ? 0
               === len$0
               ? caml_call1(Lwt[4], 0)
               : unsafe_write_from(blit, oc, str, ofs + avail | 0, len$0)
             : caml_call1(Lwt[4], len$0);
    }
    var _cN_ = flush_partial(oc);
    return caml_call2(Lwt[33][1], _cN_, _cM_);
   }
   function unsafe_write_from_bigstring(oc, bytes, ofs, len){
    return unsafe_write_from(Lwt_bytes[11], oc, bytes, ofs, len);
   }
   function unsafe_write_from$0(oc, str, ofs, len){
    return unsafe_write_from(Lwt_bytes[16], oc, str, ofs, len);
   }
   function write_from(oc, buf, ofs, len){
    if(0 <= ofs && 0 <= len && caml_ml_bytes_length(buf) >= (ofs + len | 0)){
     if(0 === len) return caml_call1(Lwt[4], 0);
     var
      _cK_ =
        function(remaining){return caml_call1(Lwt[4], len - remaining | 0);},
      _cL_ = unsafe_write_from$0(oc, buf, ofs, len);
     return caml_call2(Lwt[33][1], _cL_, _cK_);
    }
    return caml_call1(Lwt[5], [0, Stdlib[6], cst_Lwt_io_write_from]);
   }
   function unsafe_write_from_exactly(write_from, oc, buf, ofs, len){
    function loop(oc, buf, ofs, len){
     function _cI_(n){
      return 0 === n ? Lwt[36] : loop(oc, buf, (ofs + len | 0) - n | 0, n);
     }
     var _cJ_ = caml_call4(write_from, oc, buf, ofs, len);
     return caml_call2(Lwt[33][1], _cJ_, _cI_);
    }
    return loop(oc, buf, ofs, len);
   }
   function unsafe_write_from_exactly$0(oc, buf, ofs, len){
    return unsafe_write_from_exactly(unsafe_write_from$0, oc, buf, ofs, len);
   }
   function write_from_exactly(oc, buf, ofs, len){
    if(0 <= ofs && 0 <= len && caml_ml_bytes_length(buf) >= (ofs + len | 0))
     return 0 === len
             ? Lwt[36]
             : unsafe_write_from_exactly$0(oc, buf, ofs, len);
    return caml_call1(Lwt[5], [0, Stdlib[6], cst_Lwt_io_write_from_exactly]);
   }
   function write(oc, str){
    var buf = caml_call1(Stdlib_Bytes[45], str);
    return unsafe_write_from_exactly$0(oc, buf, 0, caml_ml_bytes_length(buf));
   }
   function read_block_unsafe(ic, size, f){
    if((ic[4] - ic[3] | 0) < size){
     var
      _cG_ =
        function(param){
         if(0 === param) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
         return read_block_unsafe(ic, size, f);
        },
      _cH_ = flush_partial(ic);
     return caml_call2(Lwt[33][1], _cH_, _cG_);
    }
    var ptr = ic[3];
    ic[3] = ptr + size | 0;
    return caml_call2(f, ic[1], ptr);
   }
   function write_block_unsafe(oc, size, f){
    if((oc[4] - oc[3] | 0) < size){
     var
      _cE_ = function(param){return write_block_unsafe(oc, size, f);},
      _cF_ = flush_partial(oc);
     return caml_call2(Lwt[33][1], _cF_, _cE_);
    }
    var ptr = oc[3];
    oc[3] = ptr + size | 0;
    return caml_call2(f, oc[1], ptr);
   }
   function do_seek(fun_name, seek, pos){
    function _cB_(offset){
     if(! runtime.caml_notequal(offset, pos)) return Lwt[36];
     var _cD_ = caml_call2(Stdlib_Printf[4], _l_, fun_name);
     return caml_call1(Lwt[5], [0, Stdlib[7], _cD_]);
    }
    var _cC_ = caml_call2(seek, pos, 0);
    return caml_call2(Lwt[33][1], _cC_, _cB_);
   }
   function length(ch){
    var match = ch[12];
    if(! match) return caml_call1(Lwt[4], caml_int64_of_int32(ch[2]));
    var seek = match[2];
    function _cx_(len){
     function _cz_(param){return caml_call1(Lwt[4], len);}
     var _cA_ = do_seek(cst_length, seek, ch[11]);
     return caml_call2(Lwt[33][1], _cA_, _cz_);
    }
    var _cy_ = caml_call2(seek, _n_, 2);
    return caml_call2(Lwt[33][1], _cy_, _cx_);
   }
   function read_char$0(wrapper){
    var channel = wrapper[2], ptr = channel[3];
    if(2 === wrapper[1] && ptr < channel[4]){
     channel[3] = ptr + 1 | 0;
     var _cw_ = caml_call2(Lwt_bytes[5], channel[1], ptr);
     return caml_call1(Lwt[4], _cw_);
    }
    return primitive(read_char, wrapper);
   }
   function read_char_opt$0(wrapper){
    var channel = wrapper[2], ptr = channel[3];
    if(2 === wrapper[1] && ptr < channel[4]){
     channel[3] = ptr + 1 | 0;
     var _cv_ = [0, caml_call2(Lwt_bytes[5], channel[1], ptr)];
     return caml_call1(Lwt[4], _cv_);
    }
    return primitive(read_char_opt, wrapper);
   }
   function read_line$0(ic){return primitive(read_line, ic);}
   function read_line_opt$0(ic){return primitive(read_line_opt, ic);}
   function read(count, ic){
    return primitive
            (function(ic){
              if(count){
               var
                len = count[1],
                buf = caml_create_bytes(len),
                _co_ =
                  function(real_len){
                   if(real_len < len){
                    var
                     _cs_ = caml_call3(Stdlib_Bytes[7], buf, 0, real_len),
                     _ct_ = caml_call1(Stdlib_Bytes[44], _cs_);
                    return caml_call1(Lwt[4], _ct_);
                   }
                   var _cu_ = caml_call1(Stdlib_Bytes[44], buf);
                   return caml_call1(Lwt[4], _cu_);
                  },
                _cp_ = unsafe_read_into$0(ic, buf, 0, len);
               return caml_call2(Lwt[33][1], _cp_, _co_);
              }
              var _cq_ = Stdlib_Bytes[44], _cr_ = read_all(ic, 0, 0);
              return caml_call2(Lwt[33][2], _cr_, _cq_);
             },
             ic);
   }
   function read_into(ic, str, ofs, len){
    return primitive
            (function(ic){
              if
               (0 <= ofs
                && 0 <= len && caml_ml_bytes_length(str) >= (ofs + len | 0))
               return 0 === len
                       ? caml_call1(Lwt[4], 0)
                       : unsafe_read_into$0(ic, str, ofs, len);
              return caml_call1(Lwt[5], [0, Stdlib[6], cst_Lwt_io_read_into]);
             },
             ic);
   }
   function read_into_exactly(ic, str, ofs, len){
    return primitive
            (function(ic){
              if
               (0 <= ofs
                && 0 <= len && caml_ml_bytes_length(str) >= (ofs + len | 0))
               return 0 === len
                       ? Lwt[36]
                       : unsafe_read_into_exactly$0(ic, str, ofs, len);
              return caml_call1
                      (Lwt[5], [0, Stdlib[6], cst_Lwt_io_read_into_exactly]);
             },
             ic);
   }
   function read_into_bigstring(ic, bytes, ofs, len){
    return primitive
            (function(ic){
              if
               (0 <= ofs
                &&
                 0 <= len
                 && caml_call1(Lwt_bytes[2], bytes) >= (ofs + len | 0))
               return 0 === len
                       ? caml_call1(Lwt[4], 0)
                       : unsafe_read_into_bigstring(ic, bytes, ofs, len);
              return caml_call1
                      (Lwt[5], [0, Stdlib[6], cst_Lwt_io_read_into_bigstring]);
             },
             ic);
   }
   function read_into_exactly_bigstring(ic, bytes, ofs, len){
    return primitive
            (function(ic){
              if
               (0 <= ofs
                &&
                 0 <= len
                 && caml_call1(Lwt_bytes[2], bytes) >= (ofs + len | 0))
               return 0 === len
                       ? Lwt[36]
                       : unsafe_read_into_exactly
                         (unsafe_read_into_bigstring, ic, bytes, ofs, len);
              return caml_call1
                      (Lwt[5], [0, Stdlib[6], cst_Lwt_io_read_into_exactly_b]);
             },
             ic);
   }
   function read_value$0(ic){return primitive(read_value, ic);}
   function flush(oc){return primitive(flush_total, oc);}
   function write_char$0(wrapper, x){
    var channel = wrapper[2], ptr = channel[3];
    if(2 === wrapper[1] && ptr < channel[4]){
     channel[3] = ptr + 1 | 0;
     caml_call3(Lwt_bytes[6], channel[1], ptr, x);
     return channel[7]
             ? Lwt[36]
             : (channel[7] = 1, auto_flush(channel), Lwt[36]);
    }
    return primitive(function(oc){return write_char(oc, x);}, wrapper);
   }
   function write$0(oc, str){
    return primitive(function(oc){return write(oc, str);}, oc);
   }
   function write_line(oc, str){
    return primitive
            (function(oc){
              var buf = caml_call1(Stdlib_Bytes[45], str);
              function _cm_(param){return write_char(oc, 10);}
              var
               _cn_ =
                 unsafe_write_from_exactly$0
                  (oc, buf, 0, caml_ml_bytes_length(buf));
              return caml_call2(Lwt[33][1], _cn_, _cm_);
             },
             oc);
   }
   function write_from$0(oc, str, ofs, len){
    return primitive(function(oc){return write_from(oc, str, ofs, len);}, oc);
   }
   function write_from_bigstring(oc, bytes, ofs, len){
    return primitive
            (function(oc){
              if
               (0 <= ofs
                &&
                 0 <= len
                 && caml_call1(Lwt_bytes[2], bytes) >= (ofs + len | 0)){
               if(0 === len) return caml_call1(Lwt[4], 0);
               var
                _ck_ =
                  function(remaining){
                   return caml_call1(Lwt[4], len - remaining | 0);
                  },
                _cl_ = unsafe_write_from_bigstring(oc, bytes, ofs, len);
               return caml_call2(Lwt[33][1], _cl_, _ck_);
              }
              return caml_call1
                      (Lwt[5], [0, Stdlib[6], cst_Lwt_io_write_from_bigstrin]);
             },
             oc);
   }
   function write_from_string(oc, str, ofs, len){
    return primitive
            (function(oc){
              var buf = caml_call1(Stdlib_Bytes[45], str);
              return write_from(oc, buf, ofs, len);
             },
             oc);
   }
   function write_from_exactly$0(oc, str, ofs, len){
    return primitive
            (function(oc){return write_from_exactly(oc, str, ofs, len);}, oc);
   }
   function write_from_exactly_bigstring(oc, bytes, ofs, len){
    return primitive
            (function(oc){
              if
               (0 <= ofs
                &&
                 0 <= len
                 && caml_call1(Lwt_bytes[2], bytes) >= (ofs + len | 0))
               return 0 === len
                       ? Lwt[36]
                       : unsafe_write_from_exactly
                         (unsafe_write_from_bigstring, oc, bytes, ofs, len);
              return caml_call1
                      (Lwt[5], [0, Stdlib[6], cst_Lwt_io_write_from_exactly_]);
             },
             oc);
   }
   function write_from_string_exactly(oc, str, ofs, len){
    return primitive
            (function(oc){
              var buf = caml_call1(Stdlib_Bytes[45], str);
              return write_from_exactly(oc, buf, ofs, len);
             },
             oc);
   }
   function write_value(oc, flags, x){
    return primitive
            (function(oc){
              if(flags)
               var sth = flags[1], flags$0 = sth;
              else
               var flags$0 = 0;
              return write
                      (oc, runtime.caml_output_value_to_string(x, flags$0));
             },
             oc);
   }
   function block(ch, size, f){
    return primitive
            (function(ch){
              if(0 <= size && 16 >= size){
               if(size > (ch[4] - ch[3] | 0))
                return ch[10]
                        ? write_block_unsafe(ch, size, f)
                        : read_block_unsafe(ch, size, f);
               var ptr = ch[3];
               ch[3] = ptr + size | 0;
               return caml_call2(f, ch[1], ptr);
              }
              return caml_call1(Lwt[5], [0, Stdlib[6], cst_Lwt_io_block]);
             },
             ch);
   }
   function direct_access(ch, f){
    return primitive
            (function(ch){
              var token = [0, 1], da = [];
              function _ce_(param){
               if(! token[1]){
                var
                 _cj_ =
                   caml_call2
                    (Stdlib[28],
                     cst_Lwt_io_perform_this_functi,
                     cst_Lwt_io_direct_access);
                return caml_call1(Lwt[5], [0, Stdlib[7], _cj_]);
               }
               if(da[3] === ch[4] && da[2] >= ch[3] && ch[4] >= da[2]){
                ch[3] = da[2];
                var
                 _ch_ =
                   function(count){
                    da[2] = ch[3];
                    da[3] = ch[4];
                    return caml_call1(Lwt[4], count);
                   },
                 _ci_ = flush_partial(ch);
                return caml_call2(Lwt[33][1], _ci_, _ch_);
               }
               return caml_call1
                       (Lwt[5], [0, Stdlib[6], cst_Lwt_io_direct_access_da_pe]);
              }
              caml_update_dummy(da, [0, ch[1], ch[3], ch[4], _ce_]);
              function _cf_(x){
               token[1] = 0;
               if(da[3] === ch[4] && da[2] >= ch[3] && ch[4] >= da[2]){ch[3] = da[2]; return caml_call1(Lwt[4], x);}
               return caml_call1
                       (Lwt[5], [0, Stdlib[7], cst_Lwt_io_direct_access_inval]);
              }
              var _cg_ = caml_call1(f, da);
              return caml_call2(Lwt[33][1], _cg_, _cf_);
             },
             ch);
   }
   function set_position(ch, pos){
    return primitive
            (function(ch){
              var _b8_ = ch[12], _b9_ = ch[10];
              if(_b8_){
               var seek = _b8_[2];
               if(_b9_){
                var
                 _b__ =
                   function(param){
                    function _cc_(param){ch[11] = pos; return Lwt[36];}
                    var _cd_ = do_seek(cst_set_position, seek, pos);
                    return caml_call2(Lwt[33][1], _cd_, _cc_);
                   },
                 _b$_ = flush_total(ch);
                return caml_call2(Lwt[33][1], _b$_, _b__);
               }
               var
                current =
                  caml_int64_sub
                   (ch[11], caml_int64_of_int32(ch[4] - ch[3] | 0));
               if
                (runtime.caml_greaterequal(pos, current)
                 && runtime.caml_lessequal(pos, ch[11])){
                ch[3] =
                 ch[4] - caml_int64_to_int32(caml_int64_sub(ch[11], pos)) | 0;
                return Lwt[36];
               }
               var
                _ca_ =
                  function(param){
                   ch[11] = pos;
                   ch[3] = 0;
                   ch[4] = 0;
                   return Lwt[36];
                  },
                _cb_ = do_seek(cst_set_position$0, seek, pos);
               return caml_call2(Lwt[33][1], _cb_, _ca_);
              }
              if
               (!
                runtime.caml_lessthan(pos, _m_)
                && ! runtime.caml_greaterthan(pos, caml_int64_of_int32(ch[2]))){ch[3] = caml_int64_to_int32(pos); return Lwt[36];}
              return caml_call1
                      (Lwt[5], [0, Stdlib[7], cst_Lwt_io_set_position_out_of]);
             },
             ch);
   }
   function length$0(ch){return primitive(length, ch);}
   function MakeNumberIO(Endian){
    function read_int(ic){
     return read_block_unsafe
             (ic,
              4,
              function(buffer, ptr){
               var _b7_ = caml_call2(Endian[6], buffer, ptr);
               return caml_call1(Lwt[4], _b7_);
              });
    }
    function read_int16(ic){
     return read_block_unsafe
             (ic,
              2,
              function(buffer, ptr){
               var _b6_ = caml_call2(Endian[5], buffer, ptr);
               return caml_call1(Lwt[4], _b6_);
              });
    }
    function read_int32(ic){
     return read_block_unsafe
             (ic,
              4,
              function(buffer, ptr){
               var _b5_ = caml_call2(Endian[6], buffer, ptr);
               return caml_call1(Lwt[4], _b5_);
              });
    }
    function read_int64(ic){
     return read_block_unsafe
             (ic,
              8,
              function(buffer, ptr){
               var _b4_ = caml_call2(Endian[7], buffer, ptr);
               return caml_call1(Lwt[4], _b4_);
              });
    }
    function read_float32(ic){
     function _b2_(x){
      return caml_call1(Lwt[4], runtime.caml_int32_float_of_bits(x));
     }
     var _b3_ = read_int32(ic);
     return caml_call2(Lwt[33][1], _b3_, _b2_);
    }
    function read_float64(ic){
     function _b0_(x){
      return caml_call1(Lwt[4], runtime.caml_int64_float_of_bits(x));
     }
     var _b1_ = read_int64(ic);
     return caml_call2(Lwt[33][1], _b1_, _b0_);
    }
    function write_int(oc, v){
     return write_block_unsafe
             (oc,
              4,
              function(buffer, ptr){
               caml_call3(Endian[13], buffer, ptr, v);
               return Lwt[36];
              });
    }
    function write_int16(oc, v){
     return write_block_unsafe
             (oc,
              2,
              function(buffer, ptr){
               caml_call3(Endian[12], buffer, ptr, v);
               return Lwt[36];
              });
    }
    function write_int32(oc, v){
     return write_block_unsafe
             (oc,
              4,
              function(buffer, ptr){
               caml_call3(Endian[13], buffer, ptr, v);
               return Lwt[36];
              });
    }
    function write_int64(oc, v){
     return write_block_unsafe
             (oc,
              8,
              function(buffer, ptr){
               caml_call3(Endian[14], buffer, ptr, v);
               return Lwt[36];
              });
    }
    function write_float32(oc, v){
     return write_int32(oc, runtime.caml_int32_bits_of_float(v));
    }
    function write_float64(oc, v){
     return write_int64(oc, runtime.caml_int64_bits_of_float(v));
    }
    var
     Primitives =
       [0,
        read_int,
        read_int16,
        read_int32,
        read_int64,
        read_float32,
        read_float64,
        write_int,
        write_int16,
        write_int32,
        write_int64,
        write_float32,
        write_float64];
    function read_int$0(ic){return primitive(Primitives[1], ic);}
    function read_int16$0(ic){return primitive(Primitives[2], ic);}
    function read_int32$0(ic){return primitive(Primitives[3], ic);}
    function read_int64$0(ic){return primitive(Primitives[4], ic);}
    function read_float32$0(ic){return primitive(Primitives[5], ic);}
    function read_float64$0(ic){return primitive(Primitives[6], ic);}
    function write_int$0(oc, x){
     return primitive
             (function(oc){return Primitives[7].call(null, oc, x);}, oc);
    }
    function write_int16$0(oc, x){
     return primitive
             (function(oc){return Primitives[8].call(null, oc, x);}, oc);
    }
    function write_int32$0(oc, x){
     return primitive
             (function(oc){return Primitives[9].call(null, oc, x);}, oc);
    }
    function write_int64$0(oc, x){
     return primitive
             (function(oc){return Primitives[10].call(null, oc, x);}, oc);
    }
    function write_float32$0(oc, x){
     return primitive
             (function(oc){return Primitives[11].call(null, oc, x);}, oc);
    }
    function write_float64$0(oc, x){
     return primitive
             (function(oc){return Primitives[12].call(null, oc, x);}, oc);
    }
    return [0,
            ,
            read_int$0,
            read_int16$0,
            read_int32$0,
            read_int64$0,
            read_float32$0,
            read_float64$0,
            write_int$0,
            write_int16$0,
            write_int32$0,
            write_int64$0,
            write_float32$0,
            write_float64$0];
   }
   var
    LE = MakeNumberIO(EndianBigstring[4]),
    BE = MakeNumberIO(EndianBigstring[2]),
    system_byte_order = Lwt_sys[3],
    include =
      system_byte_order
       ? [0,
         BE[2],
         BE[3],
         BE[4],
         BE[5],
         BE[6],
         BE[7],
         BE[8],
         BE[9],
         BE[10],
         BE[11],
         BE[12],
         BE[13]]
       : [0,
         LE[2],
         LE[3],
         LE[4],
         LE[5],
         LE[6],
         LE[7],
         LE[8],
         LE[9],
         LE[10],
         LE[11],
         LE[12],
         LE[13]],
    read_int = include[1],
    read_int16 = include[2],
    read_int32 = include[3],
    read_int64 = include[4],
    read_float32 = include[5],
    read_float64 = include[6],
    write_int = include[7],
    write_int16 = include[8],
    write_int32 = include[9],
    write_int64 = include[10],
    write_float32 = include[11],
    write_float64 = include[12];
   function read_chars(ic){
    function _bZ_(param){return read_char_opt$0(ic);}
    return caml_call1(Lwt_stream[1], _bZ_);
   }
   function write_chars(oc, chars){
    function _bY_(char$0){return write_char$0(oc, char$0);}
    return caml_call2(Lwt_stream[51], _bY_, chars);
   }
   function read_lines(ic){
    function _bX_(param){return read_line_opt$0(ic);}
    return caml_call1(Lwt_stream[1], _bX_);
   }
   function write_lines(oc, lines){
    function _bW_(line){return write_line(oc, line);}
    return caml_call2(Lwt_stream[51], _bW_, lines);
   }
   function _o_(str, ofs, len){
    caml_call4(Lwt_bytes[22], str, ofs, len, 0);
    return caml_call1(Lwt[4], len);
   }
   var
    zero =
      make([0, caml_call1(Lwt_bytes[1], min_buffer_size)], 0, 0, input, _o_);
   function _p_(str, ofs, len){return caml_call1(Lwt[4], len);}
   var
    null$0 =
      make([0, caml_call1(Lwt_bytes[1], min_buffer_size)], 0, 0, output, _p_),
    stdin = of_fd(0, 0, input, Lwt_unix[21]),
    stdout = of_fd(0, 0, output, Lwt_unix[22]),
    stderr = of_fd(0, 0, output, Lwt_unix[23]);
   function fprint(oc, txt){return write$0(oc, txt);}
   function fprintl(oc, txt){return write_line(oc, txt);}
   function fprintf(oc, fmt){
    function _bV_(txt){return write$0(oc, txt);}
    return caml_call2(Stdlib_Printf[10], _bV_, fmt);
   }
   function fprintlf(oc, fmt){
    function _bU_(txt){return write_line(oc, txt);}
    return caml_call2(Stdlib_Printf[10], _bU_, fmt);
   }
   function print(txt){return write$0(stdout, txt);}
   function printl(txt){return write_line(stdout, txt);}
   function printf(fmt){return caml_call2(Stdlib_Printf[10], print, fmt);}
   function printlf(fmt){return caml_call2(Stdlib_Printf[10], printl, fmt);}
   function eprint(txt){return write$0(stderr, txt);}
   function eprintl(txt){return write_line(stderr, txt);}
   function eprintf(fmt){return caml_call2(Stdlib_Printf[10], eprint, fmt);}
   function eprintlf(fmt){return caml_call2(Stdlib_Printf[10], eprintl, fmt);}
   function pipe(cloexec, in_buffer, out_buffer, param){
    var
     match = caml_call2(Lwt_unix[74], cloexec, 0),
     fd_w = match[2],
     fd_r = match[1],
     _bT_ = of_fd(out_buffer, 0, output, fd_w);
    return [0, of_fd(in_buffer, 0, input, fd_r), _bT_];
   }
   function open_file(buffer, flags, perm, mode, filename){
    if(flags)
     var l = flags[1], flags$0 = l;
    else
     var flags$0 = mode ? _q_ : _r_;
    if(perm) var p = perm[1], perm$0 = p; else var perm$0 = mode ? 438 : 0;
    function _bQ_(fd){
     var _bS_ = of_fd(buffer, 0, mode, fd);
     return caml_call1(Lwt[4], _bS_);
    }
    var _bR_ = caml_call3(Lwt_unix[24], filename, flags$0, perm$0);
    return caml_call2(Lwt[33][1], _bR_, _bQ_);
   }
   function with_file(buffer, flags, perm, mode, filename, f){
    function _bM_(ic){
     function _bO_(param){return close(ic);}
     function _bP_(param){return caml_call1(f, ic);}
     return caml_call2(Lwt[8], _bP_, _bO_);
    }
    var _bN_ = open_file(buffer, flags, perm, mode, filename);
    return caml_call2(Lwt[33][1], _bN_, _bM_);
   }
   var
    prng = [246, function(_bL_){return caml_call1(Stdlib_Random[15][2], 0);}];
   function temp_file_name(temp_dir, prefix, suffix){
    var _bI_ = caml_obj_tag(prng);
    a:
    {
     var _bH_ = 16777216;
     if(250 === _bI_)
      var _bJ_ = prng[1];
     else{
      if(246 !== _bI_ && 244 !== _bI_){var _bJ_ = prng; break a;}
      var _bJ_ = caml_call1(CamlinternalLazy[2], prng);
     }
    }
    var
     rnd = caml_call2(Stdlib_Random[15][5], _bJ_, _bH_),
     _bK_ = caml_call4(Stdlib_Printf[4], _s_, prefix, rnd, suffix);
    return caml_call2(Stdlib_Filename[4], temp_dir, _bK_);
   }
   function open_temp_file(buffer, flags, perm, temp_dir, prefix, opt, param){
    if(opt) var sth = opt[1], suffix = sth; else var suffix = cst$0;
    if(flags)
     var flags$0 = flags[1], flags$1 = flags$0;
    else
     var flags$1 = _t_;
    if(temp_dir)
     var dirname = temp_dir[1], dir = dirname;
    else
     var dir = caml_call1(Stdlib_Filename[19], 0);
    if(prefix)
     var prefix$0 = prefix[1], prefix$1 = prefix$0;
    else
     var prefix$1 = cst_lwt_io_temp_file;
    function attempt(n){
     var fname = temp_file_name(dir, prefix$1, suffix);
     function _bD_(exn){
      if(exn[1] === Unix[1] && 1000 > n) return attempt(n + 1 | 0);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
     function _bE_(param){
      function _bF_(chan){return caml_call1(Lwt[4], [0, fname, chan]);}
      var _bG_ = open_file(buffer, [0, flags$1], perm, 1, fname);
      return caml_call2(Lwt[33][1], _bG_, _bF_);
     }
     return caml_call2(Lwt[7], _bE_, _bD_);
    }
    return attempt(0);
   }
   function with_temp_file(buffer, flags, perm, temp_dir, prefix, suffix, f){
    function _bx_(param){
     var chan = param[2], fname = param[1];
     function _bz_(param){
      function _bB_(param){return caml_call1(Lwt_unix[51], fname);}
      var _bC_ = close(chan);
      return caml_call2(Lwt[33][1], _bC_, _bB_);
     }
     function _bA_(param){return caml_call1(f, [0, fname, chan]);}
     return caml_call2(Lwt[8], _bA_, _bz_);
    }
    var
     _by_ = open_temp_file(buffer, flags, perm, temp_dir, prefix, suffix, 0);
    return caml_call2(Lwt[33][1], _by_, _bx_);
   }
   function create_temp_dir(opt, _br_, _bq_, _bp_, param){
    if(opt) var sth = opt[1], perm = sth; else var perm = 493;
    if(_br_)
     var sth$0 = _br_[1], parent = sth$0;
    else
     var parent = caml_call1(Stdlib_Filename[19], 0);
    if(_bq_)
     var sth$1 = _bq_[1], prefix = sth$1;
    else
     var prefix = cst_lwt_io_temp_dir;
    if(_bp_) var sth$2 = _bp_[1], suffix = sth$2; else var suffix = cst$1;
    function attempt(n){
     var name = temp_file_name(parent, prefix, suffix);
     function _bs_(exn){
      if(exn[1] === Unix[1]){
       var _bw_ = exn[2];
       if(typeof _bw_ === "number" && 8 === _bw_ && 1000 > n)
        return attempt(n + 1 | 0);
      }
      throw caml_maybe_attach_backtrace(exn, 0);
     }
     function _bt_(param){
      function _bu_(param){return caml_call1(Lwt[4], name);}
      var _bv_ = caml_call2(Lwt_unix[63], name, perm);
      return caml_call2(Lwt[33][1], _bv_, _bu_);
     }
     return caml_call2(Lwt[7], _bt_, _bs_);
    }
    return attempt(0);
   }
   function win32_unlink(fn){
    function _bc_(exn){
     if(exn[1] === Unix[1]){
      var _be_ = exn[2];
      if(typeof _be_ === "number" && 1 === _be_){
       var
        _bf_ = function(param){throw caml_maybe_attach_backtrace(exn, 0);},
        _bg_ =
          function(param){
           function _bh_(param){
            var st_perm = param[4];
            function _bj_(param){
             function _bl_(param){
              function _bn_(param){throw caml_maybe_attach_backtrace(exn, 0);}
              var _bo_ = caml_call2(Lwt_unix[54], fn, st_perm);
              return caml_call2(Lwt[33][1], _bo_, _bn_);
             }
             function _bm_(param){return caml_call1(Lwt_unix[51], fn);}
             return caml_call2(Lwt[7], _bm_, _bl_);
            }
            var _bk_ = caml_call2(Lwt_unix[54], fn, 438);
            return caml_call2(Lwt[33][1], _bk_, _bj_);
           }
           var _bi_ = caml_call1(Lwt_unix[45], fn);
           return caml_call2(Lwt[33][1], _bi_, _bh_);
          };
       return caml_call2(Lwt[7], _bg_, _bf_);
      }
     }
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    function _bd_(param){return caml_call1(Lwt_unix[51], fn);}
    return caml_call2(Lwt[7], _bd_, _bc_);
   }
   var unlink = Stdlib_Sys[7] ? win32_unlink : Lwt_unix[51];
   function delete_recursively(directory){
    function _a6_(param){return caml_call1(Lwt_unix[64], directory);}
    var _a7_ = caml_call1(Lwt_unix[73], directory);
    function _a8_(entry){
     if
      (!
       caml_string_equal(entry, Stdlib_Filename[1])
       && ! caml_string_equal(entry, Stdlib_Filename[2])){
      var
       path = caml_call2(Stdlib_Filename[4], directory, entry),
       _a__ =
         function(param){
          var st_kind = param[3];
          if(1 === st_kind) return delete_recursively(path);
          a:
          if(4 === st_kind){
           if(! Stdlib_Sys[7] && ! Stdlib_Sys[8]) break a;
           var
            _ba_ =
              function(param){
               var st_kind = param[3];
               return 1 === st_kind
                       ? caml_call1(Lwt_unix[64], path)
                       : caml_call1(unlink, path);
              },
            _bb_ = caml_call1(Lwt_unix[44], path);
           return caml_call2(Lwt[33][1], _bb_, _ba_);
          }
          return caml_call1(unlink, path);
         },
       _a$_ = caml_call1(Lwt_unix[45], path);
      return caml_call2(Lwt[33][1], _a$_, _a__);
     }
     return Lwt[36];
    }
    var _a9_ = caml_call1(caml_call1(Lwt_stream[51], _a8_), _a7_);
    return caml_call2(Lwt[33][1], _a9_, _a6_);
   }
   function with_temp_dir(perm, parent, prefix, suffix, f){
    function _a2_(name){
     function _a4_(param){return delete_recursively(name);}
     function _a5_(param){return caml_call1(f, name);}
     return caml_call2(Lwt[8], _a5_, _a4_);
    }
    var _a3_ = create_temp_dir(perm, parent, prefix, suffix, 0);
    return caml_call2(Lwt[33][1], _a3_, _a2_);
   }
   function file_length(filename){
    function _a0_(stat){
     return 1 === stat[3]
             ? caml_call1(Lwt[5], [0, Unix[1], 14, cst_file_length, filename])
             : with_file(0, 0, 0, input, filename, length$0);
    }
    var _a1_ = caml_call1(Lwt_unix[44], filename);
    return caml_call2(Lwt[33][1], _a1_, _a0_);
   }
   function close_socket(fd){
    function _aV_(param){return caml_call1(Lwt_unix[25], fd);}
    function _aW_(param){
     function _aX_(exn){
      if(exn[1] === Unix[1]){
       var _aZ_ = exn[2];
       if(typeof _aZ_ === "number" && 59 === _aZ_) return Lwt[36];
      }
      throw caml_maybe_attach_backtrace(exn, 0);
     }
     function _aY_(param){caml_call2(Lwt_unix[99], fd, 2); return Lwt[36];}
     return caml_call2(Lwt[7], _aY_, _aX_);
    }
    return caml_call2(Lwt[8], _aW_, _aV_);
   }
   function open_connection(fd, in_buffer, out_buffer, sockaddr){
    if(fd)
     var fd$0 = fd[1], fd$1 = fd$0;
    else
     var
      _aF_ = caml_call1(Unix[134], sockaddr),
      fd$1 = caml_call4(Lwt_unix[92], 0, _aF_, 0, 0);
    var close = [246, function(_aU_){return close_socket(fd$1);}];
    function _aD_(exn){
     function _aS_(param){throw caml_maybe_attach_backtrace(exn, 0);}
     var _aT_ = caml_call1(Lwt_unix[25], fd$1);
     return caml_call2(Lwt[33][1], _aT_, _aS_);
    }
    function _aE_(param){
     function _aG_(param){
      try{caml_call1(Lwt_unix[61], fd$1);}
      catch(_aR_){
       var _aI_ = caml_wrap_exception(_aR_);
       if(_aI_[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(_aI_, 0);
      }
      var
       _aJ_ = caml_call1(Lwt_bytes[24], fd$1),
       _aK_ = 0,
       _aL_ =
         make
          (out_buffer,
           [0,
            function(param){
             var _aQ_ = caml_obj_tag(close);
             if(250 === _aQ_) return close[1];
             if(246 !== _aQ_ && 244 !== _aQ_) return close;
             return caml_call1(CamlinternalLazy[2], close);
            }],
           _aK_,
           output,
           _aJ_),
       _aM_ = caml_call1(Lwt_bytes[23], fd$1),
       _aN_ = 0,
       _aO_ =
         [0,
          make
           (in_buffer,
            [0,
             function(param){
              var _aP_ = caml_obj_tag(close);
              if(250 === _aP_) return close[1];
              if(246 !== _aP_ && 244 !== _aP_) return close;
              return caml_call1(CamlinternalLazy[2], close);
             }],
            _aN_,
            input,
            _aM_),
          _aL_];
      return caml_call1(Lwt[4], _aO_);
     }
     var _aH_ = caml_call2(Lwt_unix[98], fd$1, sockaddr);
     return caml_call2(Lwt[33][1], _aH_, _aG_);
    }
    return caml_call2(Lwt[7], _aE_, _aD_);
   }
   function with_close_connection(f, param){
    var oc = param[2], ic = param[1];
    function close_if_not_closed(channel){
     return is_closed(channel) ? Lwt[36] : close(channel);
    }
    function _az_(param){
     var _aB_ = close_if_not_closed(oc), _aC_ = close_if_not_closed(ic);
     return caml_call2(Lwt[33][3], _aC_, _aB_);
    }
    function _aA_(param){return caml_call1(f, [0, ic, oc]);}
    return caml_call2(Lwt[8], _aA_, _az_);
   }
   function with_connection(fd, in_buffer, out_buffer, sockaddr, f){
    function _ax_(channels){return with_close_connection(f, channels);}
    var _ay_ = open_connection(fd, in_buffer, out_buffer, sockaddr);
    return caml_call2(Lwt[33][1], _ay_, _ax_);
   }
   function shutdown_server(server){
    var _av_ = server[1], _aw_ = caml_obj_tag(_av_);
    if(250 === _aw_) return _av_[1];
    if(246 !== _aw_ && 244 !== _aw_) return _av_;
    return caml_call1(CamlinternalLazy[2], _av_);
   }
   function shutdown_server_deprecated(server){
    function _au_(param){return shutdown_server(server);}
    return caml_call1(Lwt[11], _au_);
   }
   function establish_server_generic
   (bind_function,
    preexisting_socket_for_listeni,
    opt,
    listening_address,
    connection_handler_callback){
    if(opt)
     var sth = opt[1], backlog = sth;
    else
     var backlog = caml_call1(Lwt_unix[171], 0);
    if(preexisting_socket_for_listeni)
     var
      socket = preexisting_socket_for_listeni[1],
      listening_socket = socket;
    else
     var
      _ai_ = caml_call1(Unix[134], listening_address),
      listening_socket = caml_call4(Lwt_unix[92], 0, _ai_, 0, 0);
    caml_call3(Lwt_unix[111], listening_socket, 2, 1);
    var
     match = caml_call1(Lwt[1], 0),
     notify_should_stop = match[2],
     should_stop = match[1],
     match$0 = caml_call1(Lwt[1], 0),
     notify_listening_socket_closed = match$0[2],
     wait_until_listening_socket_cl = match$0[1];
    function accept_loop(param){
     function _aj_(e){
      if(e[1] === Unix[1]){
       var _at_ = e[2];
       if(typeof _at_ === "number" && 55 === _at_)
        return caml_call1(Lwt[4], -243866628);
      }
      throw caml_maybe_attach_backtrace(e, 0);
     }
     function _ak_(param){
      function _ar_(x){return [0, 566851975, x];}
      var _as_ = caml_call2(Lwt_unix[96], 0, listening_socket);
      return caml_call2(Lwt[33][2], _as_, _ar_);
     }
     var try_to_accept = caml_call2(Lwt[7], _ak_, _aj_);
     function _al_(param){
      if(typeof param === "number"){
       if(121856686 > param) return accept_loop(0);
       var
        _an_ =
          function(param){
           a:
           if(0 === listening_address[0]){
            var path = listening_address[1];
            if
             (runtime.caml_string_notequal(path, cst$2)
              && 0 !== runtime.caml_string_get(path, 0)){caml_call1(Unix[45], path); break a;}
           }
           caml_call2(Lwt[2], notify_listening_socket_closed, 0);
           return Lwt[36];
          },
        _ao_ = caml_call1(Lwt_unix[25], listening_socket);
       return caml_call2(Lwt[33][1], _ao_, _an_);
      }
      var
       match = param[2],
       client_address = match[2],
       client_socket = match[1];
      try{caml_call1(Lwt_unix[61], client_socket);}
      catch(_aq_){
       var _ap_ = caml_wrap_exception(_aq_);
       if(_ap_[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(_ap_, 0);
      }
      caml_call2(connection_handler_callback, client_address, client_socket);
      return accept_loop(0);
     }
     var _am_ = caml_call1(Lwt[16], [0, try_to_accept, [0, should_stop, 0]]);
     return caml_call2(Lwt[33][1], _am_, _al_);
    }
    var
     server =
       [0,
        [246,
         function(param){
          caml_call2(Lwt[2], notify_should_stop, 121856686);
          return wait_until_listening_socket_cl;
         }]];
    function _ag_(param){
     caml_call2(Lwt_unix[95], listening_socket, backlog);
     caml_call1(Lwt[11], accept_loop);
     return Lwt[36];
    }
    var
     _ah_ = caml_call2(bind_function, listening_socket, listening_address),
     server_has_started = caml_call2(Lwt[33][1], _ah_, _ag_);
    return [0, server, server_has_started];
   }
   function establish_server_with_client_s
   (server_fd, backlog, opt, sockaddr, f){
    if(opt) var sth = opt[1], no_close = sth; else var no_close = 0;
    function handler(client_address, client_socket){
     function _$_(param){
      function _aa_(param){
       if(no_close) return Lwt[36];
       if(1 === caml_call1(Lwt_unix[9], client_socket)) return Lwt[36];
       function _ae_(exn){caml_call1(Lwt[12][1], exn); return Lwt[36];}
       function _af_(param){return close_socket(client_socket);}
       return caml_call2(Lwt[7], _af_, _ae_);
      }
      function _ab_(exn){caml_call1(Lwt[12][1], exn); return Lwt[36];}
      function _ac_(param){
       return caml_call2(f, client_address, client_socket);
      }
      var _ad_ = caml_call2(Lwt[7], _ac_, _ab_);
      return caml_call2(Lwt[33][1], _ad_, _aa_);
     }
     return caml_call1(Lwt[11], _$_);
    }
    var
     match =
       establish_server_generic
        (Lwt_unix[94], server_fd, backlog, sockaddr, handler),
     server_started = match[2],
     server = match[1];
    function ___(param){return caml_call1(Lwt[4], server);}
    return caml_call2(Lwt[33][1], server_started, ___);
   }
   function establish_server_with_client_a
   (bind_function, fd, opt, backlog, _L_, sockaddr, handler){
    if(opt)
     var sth = opt[1], buffer_size = sth;
    else
     var buffer_size = default_buffer_size[1];
    if(_L_) var sth$0 = _L_[1], no_close = sth$0; else var no_close = 0;
    function best_effort_close(channel){
     if(is_closed(channel)) return Lwt[36];
     function _Y_(exn){caml_call1(Lwt[12][1], exn); return Lwt[36];}
     function _Z_(param){return close(channel);}
     return caml_call2(Lwt[7], _Z_, _Y_);
    }
    function handler$0(client_address, client_socket){
     function _M_(param){
      var
       close = [246, function(_X_){return close_socket(client_socket);}],
       _N_ =
         [0,
          function(param){
           var _W_ = caml_obj_tag(close);
           if(250 === _W_) return close[1];
           if(246 !== _W_ && 244 !== _W_) return close;
           return caml_call1(CamlinternalLazy[2], close);
          }],
       input_channel =
         of_fd
          ([0, caml_call1(Lwt_bytes[1], buffer_size)],
           _N_,
           input,
           client_socket),
       _O_ =
         [0,
          function(param){
           var _V_ = caml_obj_tag(close);
           if(250 === _V_) return close[1];
           if(246 !== _V_ && 244 !== _V_) return close;
           return caml_call1(CamlinternalLazy[2], close);
          }],
       output_channel =
         of_fd
          ([0, caml_call1(Lwt_bytes[1], buffer_size)],
           _O_,
           output,
           client_socket);
      function _P_(param){
       if(no_close) return Lwt[36];
       function _T_(param){return best_effort_close(output_channel);}
       var _U_ = best_effort_close(input_channel);
       return caml_call2(Lwt[33][1], _U_, _T_);
      }
      function _Q_(exn){caml_call1(Lwt[12][1], exn); return Lwt[36];}
      function _R_(param){
       return caml_call2
               (handler, client_address, [0, input_channel, output_channel]);
      }
      var _S_ = caml_call2(Lwt[7], _R_, _Q_);
      return caml_call2(Lwt[33][1], _S_, _P_);
     }
     return caml_call1(Lwt[11], _M_);
    }
    return establish_server_generic
            (bind_function, fd, backlog, sockaddr, handler$0);
   }
   function establish_server_with_client_a$0
   (fd, buffer_size, backlog, no_close, sockaddr, handler){
    var
     match =
       establish_server_with_client_a
        (Lwt_unix[94], fd, buffer_size, backlog, no_close, sockaddr, handler),
     server_started = match[2],
     server = match[1];
    function _K_(param){return caml_call1(Lwt[4], server);}
    return caml_call2(Lwt[33][1], server_started, _K_);
   }
   function establish_server(fd, buffer_size, backlog, no_close, sockaddr, f){
    function f$0(addr, c){return caml_call1(f, c);}
    return establish_server_with_client_a$0
            (fd, buffer_size, backlog, no_close, sockaddr, f$0);
   }
   function establish_server_deprecated(fd, buffer_size, backlog, sockaddr, f){
    function blocking_bind(fd, addr){
     var _J_ = caml_call2(Lwt_unix[168][1], fd, addr);
     return caml_call1(Lwt[4], _J_);
    }
    function f$0(addr, c){caml_call1(f, c); return Lwt[36];}
    var
     match =
       establish_server_with_client_a
        (blocking_bind, fd, buffer_size, backlog, _u_, sockaddr, f$0),
     server_started = match[2],
     server = match[1];
    caml_call1(Lwt[77], server_started);
    return server;
   }
   function ignore_close(ch){close(ch); return 0;}
   function make_stream(f, lazy_ic){
    var
     lazy_ic$0 =
       [246,
        function(_F_){
         function _G_(ic){
          caml_call2(Stdlib_Gc[3], ignore_close, ic);
          return caml_call1(Lwt[4], ic);
         }
         var _H_ = caml_obj_tag(lazy_ic);
         a:
         if(250 === _H_)
          var _I_ = lazy_ic[1];
         else{
          if(246 !== _H_ && 244 !== _H_){var _I_ = lazy_ic; break a;}
          var _I_ = caml_call1(CamlinternalLazy[2], lazy_ic);
         }
         return caml_call2(Lwt[33][1], _I_, _G_);
        }];
    function _x_(param){
     function _y_(ic){
      function _B_(x){
       if(0 !== x) return caml_call1(Lwt[4], x);
       function _D_(param){return caml_call1(Lwt[4], x);}
       var _E_ = close(ic);
       return caml_call2(Lwt[33][1], _E_, _D_);
      }
      var _C_ = caml_call1(f, ic);
      return caml_call2(Lwt[33][1], _C_, _B_);
     }
     var _z_ = caml_obj_tag(lazy_ic$0);
     a:
     if(250 === _z_)
      var _A_ = lazy_ic$0[1];
     else{
      if(246 !== _z_ && 244 !== _z_){var _A_ = lazy_ic$0; break a;}
      var _A_ = caml_call1(CamlinternalLazy[2], lazy_ic$0);
     }
     return caml_call2(Lwt[33][1], _A_, _y_);
    }
    return caml_call1(Lwt_stream[1], _x_);
   }
   function lines_of_file(filename){
    return make_stream
            (read_line_opt$0,
             [246, function(_w_){return open_file(0, 0, 0, input, filename);}]);
   }
   function lines_to_file(filename, lines){
    return with_file
            (0,
             0,
             0,
             output,
             filename,
             function(oc){return write_lines(oc, lines);});
   }
   function chars_of_file(filename){
    return make_stream
            (read_char_opt$0,
             [246, function(_v_){return open_file(0, 0, 0, input, filename);}]);
   }
   function chars_to_file(filename, chars){
    return with_file
            (0,
             0,
             0,
             output,
             filename,
             function(oc){return write_chars(oc, chars);});
   }
   function hexdump_stream(oc, stream){
    return write_lines(oc, caml_call1(Lwt_stream[63], stream));
   }
   function hexdump(oc, buf){
    return hexdump_stream(oc, caml_call1(Lwt_stream[14], buf));
   }
   function set_default_buffer_size(size){
    check_buffer_size(cst_set_default_buffer_size, size);
    default_buffer_size[1] = size;
    return 0;
   }
   function default_buffer_size$0(param){return default_buffer_size[1];}
   var
    Versioned =
      [0,
       establish_server_deprecated,
       establish_server,
       shutdown_server_deprecated,
       shutdown_server],
    Lwt_io =
      [0,
       Channel_closed,
       input,
       output,
       mode,
       stdin,
       stdout,
       stderr,
       zero,
       null$0,
       pipe,
       make,
       of_bytes,
       of_fd,
       of_unix_fd,
       close,
       abort,
       atomic,
       file_length,
       buffered,
       flush,
       flush_all,
       buffer_size,
       resize_buffer,
       is_busy,
       is_closed,
       position,
       set_position,
       length$0,
       read_char$0,
       read_char_opt$0,
       read_chars,
       read_line$0,
       read_line_opt$0,
       read_lines,
       read,
       read_into,
       read_into_exactly,
       read_into_bigstring,
       read_into_exactly_bigstring,
       read_value$0,
       write_char$0,
       write_chars,
       write$0,
       write_line,
       write_lines,
       write_from$0,
       write_from_bigstring,
       write_from_string,
       write_from_exactly$0,
       write_from_exactly_bigstring,
       write_from_string_exactly,
       write_value,
       fprint,
       fprintl,
       fprintf,
       fprintlf,
       print,
       printl,
       printf,
       printlf,
       eprint,
       eprintl,
       eprintf,
       eprintlf,
       hexdump_stream,
       hexdump,
       open_file,
       with_file,
       open_temp_file,
       with_temp_file,
       create_temp_dir,
       with_temp_dir,
       delete_recursively,
       open_connection,
       with_connection,
       with_close_connection,
       establish_server_with_client_s,
       establish_server_with_client_a$0,
       shutdown_server,
       lines_of_file,
       lines_to_file,
       chars_of_file,
       chars_to_file,
       [0,
        LE[2],
        LE[3],
        LE[4],
        LE[5],
        LE[6],
        LE[7],
        LE[8],
        LE[9],
        LE[10],
        LE[11],
        LE[12],
        LE[13]],
       [0,
        BE[2],
        BE[3],
        BE[4],
        BE[5],
        BE[6],
        BE[7],
        BE[8],
        BE[9],
        BE[10],
        BE[11],
        BE[12],
        BE[13]],
       read_int,
       read_int16,
       read_int32,
       read_int64,
       read_float32,
       read_float64,
       write_int,
       write_int16,
       write_int32,
       write_int64,
       write_float32,
       write_float64,
       system_byte_order,
       block,
       direct_access,
       default_buffer_size$0,
       set_default_buffer_size,
       establish_server,
       Versioned];
   runtime.caml_register_global(81, Lwt_io, "Lwt_io");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_process
//# unitInfo: Requires: CamlinternalOO, Lwt, Lwt_io, Lwt_stream, Lwt_unix, Stdlib, Stdlib__Array, Stdlib__Bytes, Stdlib__Filename, Stdlib__Gc, Stdlib__List, Stdlib__String, Stdlib__Sys, Unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$14 = "",
    cst_close = "close",
    cst_kill = "kill",
    cst_pid = "pid",
    cst_rusage = "rusage",
    cst_state = "state",
    cst_status = "status",
    cst_stderr = "stderr",
    cst_stdin = "stdin",
    cst_stdout = "stdout",
    cst_terminate = "terminate",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_get_public_method = runtime.caml_get_public_method,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$10 = cst$14,
    cst$11 = cst$14,
    cst$12 = cst$14,
    cst$8 = cst$14,
    cst$9 = cst$14,
    cst$7 = cst$14,
    cst$6 = cst$14,
    cst$2 = cst$14,
    cst$3 = cst$14,
    cst$4 = cst$14,
    cst$5 = cst$14,
    cst$1 = " ",
    cst$13 = cst$14,
    cst = "\0",
    cst$0 = cst$14,
    _g_ =
      [0,
       cst_terminate,
       cst_status,
       cst_state,
       cst_rusage,
       cst_pid,
       cst_kill,
       cst_close],
    _i_ = [0, "closed"],
    _k_ =
      [0,
       cst_close,
       cst_kill,
       cst_pid,
       cst_rusage,
       cst_state,
       cst_status,
       cst_terminate],
    shared =
      [0,
       cst_terminate,
       cst_stdout,
       cst_status,
       cst_state,
       cst_rusage,
       cst_pid,
       cst_kill,
       cst_close],
    Lwt_io = global_data.Lwt_io,
    Lwt = global_data.Lwt,
    Lwt_stream = global_data.Lwt_stream,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Unix = global_data.Unix,
    Stdlib = global_data.Stdlib,
    Lwt_unix = global_data.Lwt_unix,
    CamlinternalOO = global_data.CamlinternalOO,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Filename = global_data.Stdlib__Filename,
    _E_ = [0, 1],
    _F_ = [0, 1],
    _G_ = [0, 1],
    _B_ = [0, 1],
    _C_ = [0, 1],
    _z_ = [0, 1],
    _x_ = [0, 1],
    _o_ = [0, 2, [0, 14, 0]],
    cst_dev_null = "/dev/null",
    _p_ = [0, 0],
    _q_ = [0, 0],
    _r_ = [0, 0],
    _n_ = [254, 0., 0.],
    _m_ = [0, "src/unix/lwt_process.cppo.ml", 97, 56],
    _l_ = [0, 2, [0, 14, 0]],
    cst_nul = "nul",
    cst_c$0 = "-c",
    cst_bin_sh = "/bin/sh",
    cst_c = "/c",
    cst_cmd_exe = "cmd.exe",
    _a_ =
      [0,
       cst_kill,
       cst_close,
       cst_terminate,
       cst_pid,
       cst_state,
       cst_status,
       cst_rusage],
    _b_ =
      [0,
       cst_terminate,
       cst_stdin,
       cst_status,
       cst_state,
       cst_rusage,
       cst_pid,
       cst_kill,
       cst_close],
    _c_ =
      [0,
       cst_kill,
       cst_close,
       cst_terminate,
       cst_pid,
       cst_state,
       cst_stdin,
       cst_status,
       cst_stdout,
       cst_rusage],
    _d_ =
      [0,
       cst_kill,
       cst_close,
       cst_terminate,
       cst_pid,
       cst_state,
       cst_stdin,
       cst_status,
       cst_rusage],
    _e_ =
      [0,
       cst_terminate,
       cst_stdout,
       cst_stdin,
       cst_status,
       cst_state,
       cst_rusage,
       cst_pid,
       cst_kill,
       cst_close],
    _f_ =
      [0,
       cst_terminate,
       cst_stdout,
       cst_stdin,
       cst_stderr,
       cst_status,
       cst_state,
       cst_rusage,
       cst_pid,
       cst_kill,
       cst_close],
    _h_ =
      [0,
       cst_kill,
       cst_close,
       cst_terminate,
       cst_pid,
       cst_state,
       cst_status,
       cst_stdout,
       cst_rusage],
    _j_ =
      [0,
       cst_kill,
       cst_close,
       cst_terminate,
       cst_pid,
       cst_state,
       cst_stdin,
       cst_status,
       cst_stderr,
       cst_stdout,
       cst_rusage],
    shell =
      Stdlib_Sys[7]
       ? function
        (cmd){
         return [0,
                 cst$0,
                 [0, cst_cmd_exe, cst_c, caml_call2(Stdlib[28], cst, cmd)]];
        }
       : function(cmd){return [0, cst$13, [0, cst_bin_sh, cst_c$0, cmd]];};
   function win32_get_fd(fd, redirection){
    if(typeof redirection === "number")
     return -611285096 === redirection
             ? 0
             : 836762789
               <= redirection
               ? [0, fd]
               : [0, caml_call3(Unix[24], cst_nul, _l_, 438)];
    if(177537266 <= redirection[1]){
     var fd$0 = redirection[2];
     return [0, fd$0];
    }
    var fd$1 = redirection[2];
    return [0, fd$1];
   }
   function win32_quote(arg){
    if
     (0 < caml_ml_string_length(arg) && 0 === runtime.caml_string_get(arg, 0))
     return caml_call3
             (Stdlib_String[16], arg, 1, caml_ml_string_length(arg) - 1 | 0);
    return caml_call1(Stdlib_Filename[21], arg);
   }
   function win32_spawn(cwd, opt, _ch_, _cg_, param, env){
    var args = param[2], prog = param[1];
    if(opt) var sth = opt[1], stdin = sth; else var stdin = 836762789;
    if(_ch_) var sth$0 = _ch_[1], stdout = sth$0; else var stdout = 836762789;
    if(_cg_) var sth$1 = _cg_[1], stderr = sth$1; else var stderr = 836762789;
    var
     _ci_ = caml_call1(Stdlib_Array[9], args),
     _cj_ = caml_call2(Stdlib_List[20], win32_quote, _ci_),
     cmdline = caml_call2(Stdlib_String[7], cst$1, _cj_);
    if(env){
     var
      env$0 = env[1],
      _ck_ = 1,
      _cl_ =
        function(len, str){
         return (caml_ml_string_length(str) + len | 0) + 1 | 0;
        },
      len = caml_call3(Stdlib_Array[17], _cl_, _ck_, env$0),
      res = runtime.caml_create_bytes(len),
      _cm_ = 0,
      _cn_ =
        function(ofs, str){
         var len = caml_ml_string_length(str);
         caml_call5(Stdlib_String[6], str, 0, res, ofs, len);
         caml_bytes_set(res, ofs + len | 0, 0);
         return (ofs + len | 0) + 1 | 0;
        },
      ofs = caml_call3(Stdlib_Array[17], _cn_, _cm_, env$0);
     caml_bytes_set(res, ofs, 0);
     var env$1 = [0, caml_call1(Stdlib_Bytes[44], res)];
    }
    else
     var env$1 = 0;
    var
     stdin_fd = win32_get_fd(Unix[21], stdin),
     stdout_fd = win32_get_fd(Unix[22], stdout),
     stderr_fd = win32_get_fd(Unix[23], stderr),
     _co_ = [0, stdin_fd, stdout_fd, stderr_fd],
     _cp_ = caml_string_equal(prog, cst$14) ? 0 : [0, prog],
     proc =
       runtime.lwt_process_create_process(_cp_, cmdline, env$1, cwd, _co_);
    function close(fd$0, fd){
     a:
     {
      if(typeof fd$0 === "number"){
       if(-1013286767 === fd$0) break a;
      }
      else if(177537266 === fd$0[1]) break a;
      return;
     }
     if(! fd) throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     var fd$1 = fd[1];
     return caml_call1(Unix[25], fd$1);
    }
    close(stdin, stdin_fd);
    close(stdout, stdout_fd);
    close(stderr, stderr_fd);
    return proc;
   }
   function win32_waitproc(proc){
    function _cd_(code){
     return caml_call1(Lwt[4], [0, proc[1], [0, code], _n_]);
    }
    var
     _ce_ = runtime.lwt_process_wait_job(proc[2]),
     _cf_ = caml_call2(Lwt_unix[151], 0, _ce_);
    return caml_call2(Lwt[33][1], _cf_, _cd_);
   }
   function win32_terminate(proc){
    return runtime.lwt_process_terminate_process(proc[2], 1);
   }
   function unix_redirect(fd, redirection){
    if(typeof redirection === "number"){
     if(-611285096 === redirection) return caml_call1(Unix[25], fd);
     if(836762789 <= redirection) return;
     var dev_null = caml_call3(Unix[24], cst_dev_null, _o_, 438);
     caml_call3(Unix[56], _p_, dev_null, fd);
     return caml_call1(Unix[25], dev_null);
    }
    if(177537266 <= redirection[1]){
     var fd$0 = redirection[2];
     caml_call3(Unix[56], _q_, fd$0, fd);
     return caml_call1(Unix[25], fd$0);
    }
    var fd$1 = redirection[2];
    return caml_call3(Unix[56], _r_, fd$1, fd);
   }
   function unix_spawn(cwd, opt, _ca_, _b$_, param, env){
    var args = param[2], prog = param[1];
    if(opt) var sth = opt[1], stdin = sth; else var stdin = 836762789;
    if(_ca_) var sth$0 = _ca_[1], stdout = sth$0; else var stdout = 836762789;
    if(_b$_) var sth$1 = _b$_[1], stderr = sth$1; else var stderr = 836762789;
    a:
    {
     if(caml_string_equal(prog, cst$14) && 0 < args.length - 1){
      var prog$0 = runtime.caml_check_bound(args, 0)[1];
      break a;
     }
     var prog$0 = prog;
    }
    var id = caml_call1(Lwt_unix[15], 0);
    if(0 !== id){
     var
      close =
        function(param){
         if(typeof param !== "number" && 177537266 === param[1]){var fd = param[2]; return caml_call1(Unix[25], fd);}
         return;
        };
     close(stdin);
     close(stdout);
     close(stderr);
     return [0, id, Unix[21]];
    }
    unix_redirect(Unix[21], stdin);
    unix_redirect(Unix[22], stdout);
    unix_redirect(Unix[23], stderr);
    try{
     if(cwd){var dir = cwd[1]; runtime.caml_sys_chdir(dir);}
     if(env)
      var env$0 = env[1], _cb_ = caml_call3(Unix[12], prog$0, args, env$0);
     else
      var _cb_ = caml_call2(Unix[11], prog$0, args);
     return _cb_;
    }
    catch(_cc_){return runtime.caml_unix_exit(127);}
   }
   function unix_waitproc(proc){return caml_call2(Lwt_unix[18], 0, proc[1]);}
   function unix_terminate(proc){
    return caml_call2(Unix[95], proc[1], Stdlib_Sys[22]);
   }
   var
    win32_spawn$0 = Stdlib_Sys[7] ? win32_spawn : unix_spawn,
    win32_waitproc$0 = Stdlib_Sys[7] ? win32_waitproc : unix_waitproc,
    terminate = Stdlib_Sys[7] ? win32_terminate : unix_terminate;
   function status(param){var status = param[2]; return status;}
   function rusage(param){var rusage = param[3]; return rusage;}
   var common = [];
   function _s_(chan){caml_call1(Lwt_io[15], chan); return 0;}
   var _t_ = 0, _u_ = 0;
   runtime.caml_update_dummy
    (common,
     [0,
      0,
      function(_bs_){
       var
        _bt_ = caml_call2(CamlinternalOO[3], _bs_, cst$2),
        _bu_ = caml_call2(CamlinternalOO[3], _bs_, cst$3),
        _bv_ = caml_call2(CamlinternalOO[3], _bs_, cst$4),
        _bw_ = caml_call2(CamlinternalOO[3], _bs_, cst$5),
        _bx_ = caml_call3(CamlinternalOO[4], _bs_, _g_, _i_),
        _by_ = _bx_[1],
        _bz_ = _bx_[2],
        _bE_ = _bx_[7],
        _bF_ = _bx_[8],
        _bA_ = _bx_[3],
        _bB_ = _bx_[4],
        _bC_ = _bx_[5],
        _bD_ = _bx_[6];
       function _bG_(self_1){
        var _b__ = caml_call1(Lwt[25], self_1[1 + _bw_]);
        return caml_call2(Lwt[33][2], _b__, rusage);
       }
       function _bH_(self_1){
        var _b9_ = caml_call1(Lwt[25], self_1[1 + _bw_]);
        return caml_call2(Lwt[33][2], _b9_, status);
       }
       function _bI_(self_1){
        if(self_1[1 + _bF_]) return caml_call1(self_1[1][1 + _bz_], self_1);
        self_1[1 + _bF_] = 1;
        function _b5_(param){return caml_call1(self_1[1][1 + _bz_], self_1);}
        var
         _b6_ = caml_call2(Stdlib_List[20], Lwt_io[15], self_1[1 + _bv_]),
         _b7_ = caml_call1(Lwt[14], _b6_),
         _b8_ = caml_call1(Lwt[25], _b7_);
        return caml_call2(Lwt[33][1], _b8_, _b5_);
       }
       function _bJ_(self_1){
        var _b4_ = 0 === caml_call1(Lwt[48], self_1[1 + _bw_]) ? 1 : 0;
        return _b4_ ? terminate(self_1[1 + _bu_]) : _b4_;
       }
       function _bK_(self_1, signum){
        var _b3_ = 0 === caml_call1(Lwt[48], self_1[1 + _bw_]) ? 1 : 0;
        return _b3_ ? caml_call2(Unix[95], self_1[1 + _bu_][1], signum) : _b3_;
       }
       function _bL_(self_1){
        var match = caml_call1(Lwt[79], self_1[1 + _bw_]);
        if(! match) return 0;
        var status = match[1][2];
        return [0, status];
       }
       var
        _bM_ =
          [0,
           _bC_,
           function(self_1){return self_1[1 + _bu_][1];},
           _bA_,
           _bL_,
           _bD_,
           _bK_,
           _by_,
           _bJ_,
           _bE_,
           _bI_,
           _bz_,
           _bH_,
           _bB_,
           _bG_];
       caml_call2(CamlinternalOO[11], _bs_, _bM_);
       function _bN_(self_1){
        var _bQ_ = self_1[1 + _bv_], _bR_ = caml_call1(Stdlib_Gc[3], _s_);
        caml_call2(Stdlib_List[18], _bR_, _bQ_);
        var match = self_1[1 + _bt_];
        if(! match) return 0;
        var dt = match[1];
        function _bS_(param){return Lwt[36];}
        function _bT_(param){
         if(param) return Lwt[36];
         caml_call1(self_1[1][1 + _by_], self_1);
         function _b1_(param){return Lwt[36];}
         var _b2_ = caml_call1(self_1[1][1 + _bE_], self_1);
         return caml_call2(Lwt[33][1], _b2_, _b1_);
        }
        function _bU_(param){
         var _bV_ = 0;
         function _bW_(param){return Lwt[39];}
         var _bX_ = [0, caml_call2(Lwt[33][1], self_1[1 + _bw_], _bW_), _bV_];
         function _bY_(param){return Lwt[40];}
         var
          _bZ_ = caml_call1(Lwt_unix[2], dt),
          _b0_ = [0, caml_call2(Lwt[33][1], _bZ_, _bY_), _bX_];
         return caml_call1(Lwt[17], _b0_);
        }
        caml_call3(Lwt[9], _bU_, _bT_, _bS_);
        return 0;
       }
       caml_call2(CamlinternalOO[14], _bs_, _bN_);
       return function(env, self, timeout, proc, channels){
        var
         _bO_ = win32_waitproc$0(proc),
         _bP_ = caml_call2(CamlinternalOO[24], self, _bs_);
        _bP_[1 + _bw_] = _bO_;
        _bP_[1 + _bv_] = channels;
        _bP_[1 + _bu_] = proc;
        _bP_[1 + _bt_] = timeout;
        _bP_[1 + _bF_] = 0;
        return caml_call3(CamlinternalOO[26], self, _bP_, _bs_);};
      },
      _u_,
      _t_]);
   function _v_(_bn_){
    caml_call2(CamlinternalOO[8], _bn_, _g_);
    var
     _bo_ = caml_call6(CamlinternalOO[18], _bn_, _i_, 0, _k_, common, 1)[1];
    return function(env, self, timeout, _bp_, cwd, stdin, stdout, stderr, cmd){
     var
      _bq_ = win32_spawn$0(cwd, stdin, stdout, stderr, cmd, _bp_),
      _br_ = caml_call2(CamlinternalOO[24], self, _bn_);
     caml_call4(_bo_, _br_, timeout, _bq_, 0);
     return caml_call3(CamlinternalOO[26], self, _br_, _bn_);};
   }
   var process_none = caml_call2(CamlinternalOO[19], _a_, _v_);
   function _w_(_bf_){
    var
     _bg_ = caml_call2(CamlinternalOO[3], _bf_, cst$6),
     _bh_ = caml_call2(CamlinternalOO[8], _bf_, shared)[2],
     _bi_ = caml_call6(CamlinternalOO[18], _bf_, _i_, 0, _k_, common, 1)[1];
    function _bj_(self_3){return self_3[1 + _bg_];}
    caml_call3(CamlinternalOO[10], _bf_, _bh_, _bj_);
    return function(env, self, timeout, _bk_, cwd, stdin, stderr, cmd){
     var
      match = caml_call2(Lwt_unix[75], _x_, 0),
      stdout_w = match[2],
      stdout_r = match[1],
      proc =
        win32_spawn$0
         (cwd, stdin, [0, [0, 177537266, stdout_w]], stderr, cmd, _bk_),
      _bl_ = caml_call4(Lwt_io[13], 0, 0, Lwt_io[2], stdout_r),
      _bm_ = caml_call2(CamlinternalOO[24], self, _bf_);
     _bm_[1 + _bg_] = _bl_;
     caml_call4(_bi_, _bm_, timeout, proc, [0, _bl_, 0]);
     return caml_call3(CamlinternalOO[26], self, _bm_, _bf_);};
   }
   var process_in = caml_call2(CamlinternalOO[19], _h_, _w_);
   function _y_(_a9_){
    var
     _a__ = caml_call2(CamlinternalOO[3], _a9_, cst$7),
     _a$_ = caml_call2(CamlinternalOO[8], _a9_, _b_)[2],
     _ba_ = caml_call6(CamlinternalOO[18], _a9_, _i_, 0, _k_, common, 1)[1];
    function _bb_(self_4){return self_4[1 + _a__];}
    caml_call3(CamlinternalOO[10], _a9_, _a$_, _bb_);
    return function(env, self, timeout, _bc_, cwd, stdout, stderr, cmd){
     var
      match = caml_call2(Lwt_unix[76], _z_, 0),
      stdin_w = match[2],
      stdin_r = match[1],
      proc =
        win32_spawn$0
         (cwd, [0, [0, 177537266, stdin_r]], stdout, stderr, cmd, _bc_),
      _bd_ = caml_call4(Lwt_io[13], 0, 0, Lwt_io[3], stdin_w),
      _be_ = caml_call2(CamlinternalOO[24], self, _a9_);
     _be_[1 + _a__] = _bd_;
     caml_call4(_ba_, _be_, timeout, proc, [0, _bd_, 0]);
     return caml_call3(CamlinternalOO[26], self, _be_, _a9_);};
   }
   var process_out = caml_call2(CamlinternalOO[19], _d_, _y_);
   function _A_(_aX_){
    var
     _aY_ = caml_call2(CamlinternalOO[3], _aX_, cst$8),
     _aZ_ = caml_call2(CamlinternalOO[3], _aX_, cst$9),
     _a0_ = caml_call2(CamlinternalOO[8], _aX_, _e_),
     _a1_ = _a0_[2],
     _a2_ = _a0_[3],
     _a3_ = caml_call6(CamlinternalOO[18], _aX_, _i_, 0, _k_, common, 1)[1];
    function _a4_(self_5){return self_5[1 + _aZ_];}
    var
     _a5_ = [0, _a2_, function(self_5){return self_5[1 + _aY_];}, _a1_, _a4_];
    caml_call2(CamlinternalOO[11], _aX_, _a5_);
    return function(env, self, timeout, _a6_, cwd, stderr, cmd){
     var
      match = caml_call2(Lwt_unix[76], _B_, 0),
      stdin_w = match[2],
      stdin_r = match[1],
      match$0 = caml_call2(Lwt_unix[75], _C_, 0),
      stdout_w = match$0[2],
      stdout_r = match$0[1],
      proc =
        win32_spawn$0
         (cwd,
          [0, [0, 177537266, stdin_r]],
          [0, [0, 177537266, stdout_w]],
          stderr,
          cmd,
          _a6_),
      stdin = caml_call4(Lwt_io[13], 0, 0, Lwt_io[3], stdin_w),
      _a7_ = caml_call4(Lwt_io[13], 0, 0, Lwt_io[2], stdout_r),
      _a8_ = caml_call2(CamlinternalOO[24], self, _aX_);
     _a8_[1 + _aY_] = stdin;
     _a8_[1 + _aZ_] = _a7_;
     caml_call4(_a3_, _a8_, timeout, proc, [0, stdin, [0, _a7_, 0]]);
     return caml_call3(CamlinternalOO[26], self, _a8_, _aX_);};
   }
   var process = caml_call2(CamlinternalOO[19], _c_, _A_);
   function _D_(_aI_){
    var
     _aJ_ = caml_call2(CamlinternalOO[3], _aI_, cst$10),
     _aK_ = caml_call2(CamlinternalOO[3], _aI_, cst$11),
     _aL_ = caml_call2(CamlinternalOO[3], _aI_, cst$12),
     _aM_ = caml_call2(CamlinternalOO[8], _aI_, _f_),
     _aN_ = _aM_[2],
     _aO_ = _aM_[3],
     _aP_ = _aM_[4],
     _aQ_ = caml_call6(CamlinternalOO[18], _aI_, _i_, 0, _k_, common, 1)[1];
    function _aR_(self_6){return self_6[1 + _aL_];}
    function _aS_(self_6){return self_6[1 + _aK_];}
    var
     _aT_ =
       [0,
        _aO_,
        function(self_6){return self_6[1 + _aJ_];},
        _aN_,
        _aS_,
        _aP_,
        _aR_];
    caml_call2(CamlinternalOO[11], _aI_, _aT_);
    return function(env, self, timeout, _aU_, cwd, cmd){
     var
      match = caml_call2(Lwt_unix[76], _E_, 0),
      stdin_w = match[2],
      stdin_r = match[1],
      match$0 = caml_call2(Lwt_unix[75], _F_, 0),
      stdout_w = match$0[2],
      stdout_r = match$0[1],
      match$1 = caml_call2(Lwt_unix[75], _G_, 0),
      stderr_w = match$1[2],
      stderr_r = match$1[1],
      proc =
        win32_spawn$0
         (cwd,
          [0, [0, 177537266, stdin_r]],
          [0, [0, 177537266, stdout_w]],
          [0, [0, 177537266, stderr_w]],
          cmd,
          _aU_),
      stdin = caml_call4(Lwt_io[13], 0, 0, Lwt_io[3], stdin_w),
      stdout = caml_call4(Lwt_io[13], 0, 0, Lwt_io[2], stdout_r),
      _aV_ = caml_call4(Lwt_io[13], 0, 0, Lwt_io[2], stderr_r),
      _aW_ = caml_call2(CamlinternalOO[24], self, _aI_);
     _aW_[1 + _aJ_] = stdin;
     _aW_[1 + _aK_] = stdout;
     _aW_[1 + _aL_] = _aV_;
     caml_call4
      (_aQ_, _aW_, timeout, proc, [0, stdin, [0, stdout, [0, _aV_, 0]]]);
     return caml_call3(CamlinternalOO[26], self, _aW_, _aI_);};
   }
   var process_full = caml_call2(CamlinternalOO[19], _j_, _D_);
   function open_process_none(timeout, env, cwd, stdin, stdout, stderr, cmd){
    return caml_call8
            (process_none[1],
             0,
             timeout,
             env,
             cwd,
             stdin,
             stdout,
             stderr,
             cmd);
   }
   function open_process_in(timeout, env, cwd, stdin, stderr, cmd){
    return caml_call7(process_in[1], 0, timeout, env, cwd, stdin, stderr, cmd);
   }
   function open_process_out(timeout, env, cwd, stdout, stderr, cmd){
    return caml_call7
            (process_out[1], 0, timeout, env, cwd, stdout, stderr, cmd);
   }
   function open_process(timeout, env, cwd, stderr, cmd){
    return caml_call6(process[1], 0, timeout, env, cwd, stderr, cmd);
   }
   function open_process_full(timeout, env, cwd, cmd){
    return caml_call5(process_full[1], 0, timeout, env, cwd, cmd);
   }
   function make_with(backend, timeout, env, cwd, cmd, f){
    var process = caml_call4(backend, timeout, env, cwd, cmd);
    function _aE_(param){
     function _aG_(param){return Lwt[36];}
     var
      _aH_ =
        caml_call1(caml_get_public_method(process, -933029960, 16), process);
     return caml_call2(Lwt[33][1], _aH_, _aG_);
    }
    function _aF_(param){return caml_call1(f, process);}
    return caml_call2(Lwt[8], _aF_, _aE_);
   }
   function with_process_none
   (timeout, env, cwd, stdin, stdout, stderr, cmd, f){
    return make_with
            (function(_aC_, _aB_, _aA_){
              return function(_aD_){
               return open_process_none
                       (_aC_, _aB_, _aA_, stdin, stdout, stderr, _aD_);};
             },
             timeout,
             env,
             cwd,
             cmd,
             f);
   }
   function with_process_in(timeout, env, cwd, stdin, stderr, cmd, f){
    return make_with
            (function(_ay_, _ax_, _aw_){
              return function(_az_){
               return open_process_in(_ay_, _ax_, _aw_, stdin, stderr, _az_);};
             },
             timeout,
             env,
             cwd,
             cmd,
             f);
   }
   function with_process_out(timeout, env, cwd, stdout, stderr, cmd, f){
    return make_with
            (function(_au_, _at_, _as_){
              return function(_av_){
               return open_process_out(_au_, _at_, _as_, stdout, stderr, _av_);};
             },
             timeout,
             env,
             cwd,
             cmd,
             f);
   }
   function with_process(timeout, env, cwd, stderr, cmd, f){
    return make_with
            (function(_aq_, _ap_, _ao_){
              return function(_ar_){
               return open_process(_aq_, _ap_, _ao_, stderr, _ar_);};
             },
             timeout,
             env,
             cwd,
             cmd,
             f);
   }
   function with_process_full(timeout, env, cwd, cmd, f){
    return make_with(open_process_full, timeout, env, cwd, cmd, f);
   }
   function exec(timeout, env, cwd, stdin, stdout, stderr, cmd){
    var
     _an_ = open_process_none(timeout, env, cwd, stdin, stdout, stderr, cmd);
    return caml_call1(caml_get_public_method(_an_, -933029960, 17), _an_);
   }
   function ignore_close(ch){caml_call1(Lwt_io[15], ch); return 0;}
   function read_opt(read, ic){
    function _ai_(exn){
     a:
     {
      if(exn[1] === Unix[1]){
       var _am_ = exn[2];
       if(typeof _am_ !== "number" || 31 !== _am_) break a;
      }
      else if(exn !== Stdlib[12]) break a;
      return Lwt[37];
     }
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    function _aj_(param){
     function _ak_(x){return [0, x];}
     var _al_ = caml_call1(read, ic);
     return caml_call2(Lwt[33][2], _al_, _ak_);
    }
    return caml_call2(Lwt[7], _aj_, _ai_);
   }
   function recv_chars(pr){
    var ic = caml_call1(caml_get_public_method(pr, 133414859, 18), pr);
    caml_call2(Stdlib_Gc[3], ignore_close, ic);
    function _ad_(param){
     function _ae_(x){
      if(0 !== x) return caml_call1(Lwt[4], x);
      function _ag_(param){return caml_call1(Lwt[4], x);}
      var _ah_ = caml_call1(Lwt_io[15], ic);
      return caml_call2(Lwt[33][1], _ah_, _ag_);
     }
     var _af_ = read_opt(Lwt_io[29], ic);
     return caml_call2(Lwt[33][1], _af_, _ae_);
    }
    return caml_call1(Lwt_stream[1], _ad_);
   }
   function recv_lines(pr){
    var ic = caml_call1(caml_get_public_method(pr, 133414859, 19), pr);
    caml_call2(Stdlib_Gc[3], ignore_close, ic);
    function ___(param){
     function _$_(x){
      if(0 !== x) return caml_call1(Lwt[4], x);
      function _ab_(param){return caml_call1(Lwt[4], x);}
      var _ac_ = caml_call1(Lwt_io[15], ic);
      return caml_call2(Lwt[33][1], _ac_, _ab_);
     }
     var _aa_ = read_opt(Lwt_io[32], ic);
     return caml_call2(Lwt[33][1], _aa_, _$_);
    }
    return caml_call1(Lwt_stream[1], ___);
   }
   function recv(pr){
    var ic = caml_call1(caml_get_public_method(pr, 133414859, 20), pr);
    function _Y_(param){return caml_call1(Lwt_io[15], ic);}
    function _Z_(param){return caml_call2(Lwt_io[35], 0, ic);}
    return caml_call2(Lwt[8], _Z_, _Y_);
   }
   function recv_line(pr){
    var ic = caml_call1(caml_get_public_method(pr, 133414859, 21), pr);
    function _W_(param){return caml_call1(Lwt_io[15], ic);}
    function _X_(param){return caml_call1(Lwt_io[32], ic);}
    return caml_call2(Lwt[8], _X_, _W_);
   }
   function send(f, pr, data){
    var oc = caml_call1(caml_get_public_method(pr, 68006728, 22), pr);
    function _U_(param){return caml_call1(Lwt_io[15], oc);}
    function _V_(param){return caml_call2(f, oc, data);}
    return caml_call2(Lwt[8], _V_, _U_);
   }
   function pread(timeout, env, cwd, stdin, stderr, cmd){
    return recv(open_process_in(timeout, env, cwd, stdin, stderr, cmd));
   }
   function pread_chars(timeout, env, cwd, stdin, stderr, cmd){
    return recv_chars(open_process_in(timeout, env, cwd, stdin, stderr, cmd));
   }
   function pread_line(timeout, env, cwd, stdin, stderr, cmd){
    return recv_line(open_process_in(timeout, env, cwd, stdin, stderr, cmd));
   }
   function pread_lines(timeout, env, cwd, stdin, stderr, cmd){
    return recv_lines(open_process_in(timeout, env, cwd, stdin, stderr, cmd));
   }
   function pwrite(timeout, env, cwd, stdout, stderr, cmd, text){
    var _T_ = open_process_out(timeout, env, cwd, stdout, stderr, cmd);
    return send(Lwt_io[43], _T_, text);
   }
   function pwrite_chars(timeout, env, cwd, stdout, stderr, cmd, chars){
    var _S_ = open_process_out(timeout, env, cwd, stdout, stderr, cmd);
    return send(Lwt_io[42], _S_, chars);
   }
   function pwrite_line(timeout, env, cwd, stdout, stderr, cmd, line){
    var _R_ = open_process_out(timeout, env, cwd, stdout, stderr, cmd);
    return send(Lwt_io[44], _R_, line);
   }
   function pwrite_lines(timeout, env, cwd, stdout, stderr, cmd, lines){
    var _Q_ = open_process_out(timeout, env, cwd, stdout, stderr, cmd);
    return send(Lwt_io[45], _Q_, lines);
   }
   function monitor(sender, st){
    function _N_(param){return 0;}
    var sender$0 = caml_call2(Lwt[33][2], sender, _N_), state = [0, 0];
    function _O_(param){
     var match = state[1];
     if(typeof match !== "number"){var t = match[1]; state[1] = 1; return t;}
     if(match) return caml_call1(Lwt_stream[21], st);
     var getter = caml_call2(Lwt[80], Lwt_stream[21], st);
     function result(param){
      var match = caml_call1(Lwt[48], sender$0);
      return typeof match === "number"
              ? getter
              : 0
                === match[0]
                ? (state[1] = 1, getter)
                : (state[1] = [0, getter], sender$0);
     }
     function _P_(param){
      return caml_call1(Lwt[17], [0, sender$0, [0, getter, 0]]);
     }
     return caml_call3(Lwt[9], _P_, result, result);
    }
    return caml_call1(Lwt_stream[1], _O_);
   }
   function pmap(timeout, env, cwd, stderr, cmd, text){
    var
     pr = open_process(timeout, env, cwd, stderr, cmd),
     sender = send(Lwt_io[43], pr, text),
     getter = recv(pr);
    function _K_(exn){
     if(exn !== Lwt[21]) throw caml_maybe_attach_backtrace(exn, 0);
     caml_call1(Lwt[23], getter);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    function _L_(param){
     function _M_(param){return getter;}
     return caml_call2(Lwt[33][1], sender, _M_);
    }
    return caml_call2(Lwt[7], _L_, _K_);
   }
   function pmap_chars(timeout, env, cwd, stderr, cmd, chars){
    var
     pr = open_process(timeout, env, cwd, stderr, cmd),
     sender = send(Lwt_io[42], pr, chars);
    return monitor(sender, recv_chars(pr));
   }
   function pmap_line(timeout, env, cwd, stderr, cmd, line){
    var
     pr = open_process(timeout, env, cwd, stderr, cmd),
     sender = send(Lwt_io[44], pr, line),
     getter = recv_line(pr);
    function _H_(exn){
     if(exn !== Lwt[21]) throw caml_maybe_attach_backtrace(exn, 0);
     caml_call1(Lwt[23], getter);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    function _I_(param){
     function _J_(param){return getter;}
     return caml_call2(Lwt[33][1], sender, _J_);
    }
    return caml_call2(Lwt[7], _I_, _H_);
   }
   function pmap_lines(timeout, env, cwd, stderr, cmd, lines){
    var
     pr = open_process(timeout, env, cwd, stderr, cmd),
     sender = send(Lwt_io[45], pr, lines);
    return monitor(sender, recv_lines(pr));
   }
   var
    Lwt_process =
      [0,
       shell,
       exec,
       pread,
       pread_chars,
       pread_line,
       pread_lines,
       pwrite,
       pwrite_chars,
       pwrite_line,
       pwrite_lines,
       pmap,
       pmap_chars,
       pmap_line,
       pmap_lines,
       process_none,
       open_process_none,
       with_process_none,
       process_in,
       open_process_in,
       with_process_in,
       process_out,
       open_process_out,
       with_process_out,
       process,
       open_process,
       with_process,
       process_full,
       open_process_full,
       with_process_full];
   runtime.caml_register_global(64, Lwt_process, "Lwt_process");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_preemptive
//# unitInfo: Requires: Lwt, Lwt_sequence, Lwt_unix, Stdlib, Stdlib__Condition, Stdlib__Mutex, Stdlib__Queue, Thread
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_unix = global_data.Lwt_unix,
    Lwt = global_data.Lwt,
    Stdlib_Mutex = global_data.Stdlib__Mutex,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Thread = global_data.Thread,
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib = global_data.Stdlib,
    Stdlib_Condition = global_data.Stdlib__Condition,
    min_threads = [0, 0],
    max_threads = [0, 0],
    max_thread_queued = [0, 1000],
    _b_ = [0, 1],
    _a_ = [0, 0, 4],
    cst_Lwt_preemptive_set_bounds = "Lwt_preemptive.set_bounds",
    cst_Lwt_preemptive_set_max_num =
      "Lwt_preemptive.set_max_number_of_threads_queued",
    cst_Lwt_preemptive_detach = "Lwt_preemptive.detach";
   function get_max_number_of_threads_queu(param){return max_thread_queued[1];
   }
   function set_max_number_of_threads_queu(n){
    if(n < 0) caml_call1(Stdlib[1], cst_Lwt_preemptive_set_max_num);
    max_thread_queued[1] = n;
    return 0;
   }
   var threads_count = [0, 0];
   function make(param){
    var _B_ = caml_call1(Stdlib_Condition[1], 0);
    return [0, caml_call1(Stdlib_Mutex[1], 0), _B_, 0];
   }
   function get(t){
    caml_call1(Stdlib_Mutex[2], t[1]);
    for(;;){
     var match = t[3];
     if(match){
      var v = match[1];
      t[3] = 0;
      caml_call1(Stdlib_Mutex[4], t[1]);
      return v;
     }
     caml_call2(Stdlib_Condition[2], t[2], t[1]);
    }
   }
   function set(t, v){
    caml_call1(Stdlib_Mutex[2], t[1]);
    t[3] = [0, v];
    caml_call1(Stdlib_Mutex[4], t[1]);
    return caml_call1(Stdlib_Condition[3], t[2]);
   }
   var
    workers = caml_call1(Stdlib_Queue[2], 0),
    waiters = caml_call1(Lwt_sequence[4], 0);
   function worker_loop(worker){
    for(;;){
     var match = get(worker[1]), task = match[2], id = match[1];
     caml_call1(task, 0);
     if(max_threads[1] < threads_count[1]) worker[3] = 0;
     caml_call1(Lwt_unix[157], id);
     var _A_ = worker[3];
     if(! _A_) return _A_;
    }
   }
   function make_worker(param){
    threads_count[1]++;
    var _z_ = caml_call1(Thread[2], 0), worker = [0, make(0), _z_, 1];
    worker[2] = caml_call2(Thread[1], worker_loop, worker);
    return worker;
   }
   function add_worker(worker){
    var match = caml_call1(Lwt_sequence[13], waiters);
    if(! match) return caml_call2(Stdlib_Queue[3], worker, workers);
    var w = match[1];
    return caml_call2(Lwt[52], w, worker);
   }
   function get_bounds(param){return [0, min_threads[1], max_threads[1]];}
   function set_bounds(param){
    var
     max = param[2],
     min = param[1],
     _v_ = min < 0 ? 1 : 0,
     _w_ = _v_ || (max < min ? 1 : 0);
    if(_w_) caml_call1(Stdlib[1], cst_Lwt_preemptive_set_bounds);
    var diff = min - threads_count[1] | 0;
    min_threads[1] = min;
    max_threads[1] = max;
    var _x_ = 1;
    if(diff >= 1){
     var i = _x_;
     for(;;){
      add_worker(make_worker(0));
      var _y_ = i + 1 | 0;
      if(diff === i) break;
      var i = _y_;
     }
    }
    return 0;
   }
   var initialized = [0, 0];
   function init(min, max, errlog){
    initialized[1] = 1;
    return set_bounds([0, min, max]);
   }
   function simple_init(param){
    var _u_ = 1 - initialized[1];
    return _u_ ? (initialized[1] = 1, set_bounds(_a_)) : _u_;
   }
   function nbthreads(param){return threads_count[1];}
   function nbthreadsqueued(param){
    var _s_ = 0;
    function _t_(param, x){return x + 1 | 0;}
    return caml_call3(Lwt_sequence[21], _t_, waiters, _s_);
   }
   function nbthreadsbusy(param){
    var _r_ = caml_call1(Stdlib_Queue[14], workers);
    return threads_count[1] - _r_ | 0;
   }
   var init_result = [1, [0, Stdlib[7], cst_Lwt_preemptive_detach]];
   function detach(f, args){
    simple_init(0);
    var result = [0, init_result];
    function task(param){
     try{result[1] = [0, caml_call1(f, args)]; var _q_ = 0; return _q_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(! caml_call1(Lwt[78][4], exn))
       throw caml_maybe_attach_backtrace(exn, 0);
      result[1] = [1, exn];
      return 0;
     }
    }
    function _l_(worker){
     var match = caml_call1(Lwt[1], 0), wakener = match[2], waiter = match[1];
     function _n_(param){return caml_call2(Lwt[54], wakener, result[1]);}
     var id = caml_call2(Lwt_unix[156], _b_, _n_);
     function _o_(param){
      if(worker[3])
       add_worker(worker);
      else{threads_count[1] += -1; caml_call1(Thread[7], worker[2]);}
      return Lwt[36];
     }
     function _p_(param){set(worker[1], [0, id, task]); return waiter;}
     return caml_call2(Lwt[8], _p_, _o_);
    }
    if(caml_call1(Stdlib_Queue[13], workers))
     if(threads_count[1] < max_threads[1])
      var _j_ = make_worker(0), _m_ = caml_call1(Lwt[4], _j_);
     else
      var _m_ = caml_call1(Lwt[55], waiters);
    else
     var
      _k_ = caml_call1(Stdlib_Queue[5], workers),
      _m_ = caml_call1(Lwt[4], _k_);
    return caml_call2(Lwt[33][1], _m_, _l_);
   }
   var
    jobs = caml_call1(Stdlib_Queue[2], 0),
    jobs_mutex = caml_call1(Stdlib_Mutex[1], 0);
   function _c_(param){
    caml_call1(Stdlib_Mutex[2], jobs_mutex);
    var thunk = caml_call1(Stdlib_Queue[5], jobs);
    caml_call1(Stdlib_Mutex[4], jobs_mutex);
    caml_call1(thunk, 0);
    return 0;
   }
   var job_notification = caml_call2(Lwt_unix[156], 0, _c_);
   function _d_(f){
    caml_call1(Stdlib_Mutex[2], jobs_mutex);
    caml_call2(Stdlib_Queue[3], f, jobs);
    caml_call1(Stdlib_Mutex[4], jobs_mutex);
    return caml_call1(Lwt_unix[157], job_notification);
   }
   function run_in_main(f){
    var cell = make(0);
    function job(param){
     function _f_(result){set(cell, result); return Lwt[36];}
     function _g_(exn){return caml_call1(Lwt[4], [1, exn]);}
     function _h_(ret){return caml_call1(Lwt[4], [0, ret]);}
     var _i_ = caml_call3(Lwt[9], f, _h_, _g_);
     return caml_call2(Lwt[33][1], _i_, _f_);
    }
    _d_(job);
    var match = get(cell);
    if(0 === match[0]){var ret = match[1]; return ret;}
    var exn = match[1];
    throw caml_maybe_attach_backtrace(exn, 1);
   }
   function run_in_main_dont_wait(f, handler){
    function f$0(param){
     function _e_(exc){caml_call1(handler, exc); return Lwt[36];}
     return caml_call2(Lwt[7], f, _e_);
    }
    return _d_(f$0);
   }
   var
    Lwt_preemptive =
      [0,
       detach,
       run_in_main,
       run_in_main_dont_wait,
       init,
       simple_init,
       get_bounds,
       set_bounds,
       set_max_number_of_threads_queu,
       get_max_number_of_threads_queu,
       nbthreads,
       nbthreadsbusy,
       nbthreadsqueued];
   runtime.caml_register_global(13, Lwt_preemptive, "Lwt_preemptive");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_gc
//# unitInfo: Requires: Lwt, Lwt_main, Lwt_sequence, Lwt_unix, Stdlib__Gc, Stdlib__Weak
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Weak = global_data.Stdlib__Weak,
    Lwt_main = global_data.Lwt_main,
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Lwt = global_data.Lwt,
    Lwt_unix = global_data.Lwt_unix,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, "src/unix/lwt_gc.ml", 38, 11],
    _b_ = [0, 1];
   function finaliser(f){
    var opt = [0, 0];
    function _h_(param){
     var match = opt[1];
     if(! match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var x = match[1];
     opt[1] = 0;
     var t = caml_call1(f, x), _i_ = 0 === caml_call1(Lwt[48], t) ? 1 : 0;
     if(_i_){
      var
       _j_ = Lwt_main[9],
       _k_ = function(param){return t;},
       hook = caml_call2(Lwt_sequence[8], _k_, _j_),
       _l_ =
         function(param){caml_call1(Lwt_sequence[3], hook); return Lwt[36];},
       _m_ = function(param){return t;};
      caml_call2(Lwt[8], _m_, _l_);
      var _n_ = 0;
     }
     else
      var _n_ = _i_;
     return _n_;
    }
    var id = caml_call2(Lwt_unix[156], _b_, _h_);
    return function(x){
     opt[1] = [0, x];
     return caml_call1(Lwt_unix[157], id);};
   }
   function finalise(f, x){
    var _g_ = finaliser(f);
    return caml_call2(Stdlib_Gc[3], _g_, x);
   }
   function finalise_or_exit(f, x){
    var weak = caml_call1(Stdlib_Weak[1], 1);
    caml_call3(Stdlib_Weak[3], weak, 0, [0, x]);
    var called = [0, 0], _d_ = Lwt_main[9];
    function _e_(_f_){
     var match = caml_call2(Stdlib_Weak[4], weak, 0);
     if(! match) return Lwt[36];
     var x = match[1];
     caml_call3(Stdlib_Weak[3], weak, 0, 0);
     return called[1] ? Lwt[36] : (called[1] = 1, caml_call1(f, x));
    }
    var
     hook = caml_call2(Lwt_sequence[8], _e_, _d_),
     _c_ =
       finaliser
        (function(x){
          caml_call1(Lwt_sequence[3], hook);
          return called[1] ? Lwt[36] : (called[1] = 1, caml_call1(f, x));
         });
    return caml_call2(Stdlib_Gc[3], _c_, x);
   }
   var Lwt_gc = [0, finalise, finalise_or_exit];
   runtime.caml_register_global(9, Lwt_gc, "Lwt_gc");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_fmt
//# unitInfo: Requires: Lwt, Lwt_io, Lwt_stream, Stdlib__Format, Stdlib__Gc, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Queue = global_data.Stdlib__Queue,
    Lwt = global_data.Lwt,
    Stdlib_Format = global_data.Stdlib__Format,
    Lwt_io = global_data.Lwt_io,
    Lwt_stream = global_data.Lwt_stream,
    Stdlib_Gc = global_data.Stdlib__Gc,
    _a_ = [0, 0];
   function write_pending(ppft){return caml_call1(ppft[1], 0);}
   function flush(ppft){
    caml_call2(Stdlib_Format[38], ppft[2], 0);
    return caml_call1(ppft[1], 0);
   }
   function make_formatter(commit, fmt, param){return [0, commit, fmt];}
   function get_formatter(x){return x[2];}
   function make_stream(param){
    var
     match = caml_call1(Lwt_stream[4], 0),
     push = match[2],
     stream = match[1];
    function out_string(s, i, j){return caml_call1(push, [0, [0, s, i, j]]);}
    function flush(param){return caml_call1(push, _a_);}
    var fmt = caml_call2(Stdlib_Format[120], out_string, flush);
    function _j_(param){return caml_call1(push, 0);}
    caml_call2(Stdlib_Gc[3], _j_, fmt);
    function commit(param){return Lwt[36];}
    return [0, stream, [0, commit, fmt]];
   }
   function write_order(oc, param){
    if(! param) return caml_call1(Lwt_io[20], oc);
    var j = param[3], i = param[2], s = param[1];
    return caml_call4(Lwt_io[51], oc, s, i, j);
   }
   function write_orders(oc, queue){
    if(caml_call1(Stdlib_Queue[13], queue)) return Lwt[36];
    var o = caml_call1(Stdlib_Queue[7], queue);
    function _h_(param){return write_orders(oc, queue);}
    var _i_ = write_order(oc, o);
    return caml_call2(Lwt[33][1], _i_, _h_);
   }
   function of_channel(oc){
    var q = caml_call1(Stdlib_Queue[2], 0);
    function out_string(s, i, j){
     return caml_call2(Stdlib_Queue[4], [0, s, i, j], q);
    }
    function flush(param){return caml_call2(Stdlib_Queue[4], 0, q);}
    var fmt = caml_call2(Stdlib_Format[120], out_string, flush);
    function commit(param){return write_orders(oc, q);}
    return [0, commit, fmt];
   }
   function kfprintf(k, ppft, fmt){
    var _e_ = ppft[2];
    function _f_(ppf){
     var _g_ = caml_call1(ppft[1], 0);
     return caml_call1(caml_call1(k, ppft), _g_);
    }
    return caml_call3(Stdlib_Format[144], _f_, _e_, fmt);
   }
   function ikfprintf(k, ppft, fmt){
    var _b_ = ppft[2];
    function _c_(ppf){
     var _d_ = Lwt[36];
     return caml_call1(caml_call1(k, ppft), _d_);
    }
    return caml_call3(Stdlib_Format[146], _c_, _b_, fmt);
   }
   function fprintf(ppft, fmt){
    return kfprintf(function(param, t){return t;}, ppft, fmt);
   }
   function ifprintf(ppft, fmt){
    return ikfprintf(function(param, t){return t;}, ppft, fmt);
   }
   var stdout = of_channel(Lwt_io[6]), stderr = of_channel(Lwt_io[7]);
   function printf(fmt){return fprintf(stdout, fmt);}
   function eprintf(fmt){return fprintf(stderr, fmt);}
   var
    Lwt_fmt =
      [0,
       printf,
       eprintf,
       make_stream,
       of_channel,
       stdout,
       stderr,
       make_formatter,
       get_formatter,
       fprintf,
       kfprintf,
       ifprintf,
       ikfprintf,
       flush,
       write_order,
       write_pending];
   runtime.caml_register_global(7, Lwt_fmt, "Lwt_fmt");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJsd3RfdW5peC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic3RvcF9ldmVudCIsImV2IiwiZXYkMCIsImZha2VfZXZlbnQiLCJmYWtlX2V2ZW50JDAiLCJzZWxmXzEiLCJzaWdudW0iLCJkZWxheSIsInJlcGVhdCIsImYiLCJnIiwic3RvcCIsImZkIiwiZmQkMCIsImVuZ2luZSIsImVxdWFsIiwiZGVmYXVsdCQwIiwic2VsZWN0IiwicG9sbCIsImVwb2xsIiwia3F1ZXVlIiwiZGV2cG9sbCIsInBvcnQiLCJwcCIsImZtdCIsInQiLCJzZWxmXzIiLCJibG9jayIsImV4biQwIiwiZXhuIiwib3B0Iiwic3RoIiwic3RoJDAiLCJjb21wYXJlIiwidDEiLCJ0MiIsImNvbXBhcmUkMCIsInJlc3RhcnRfYWN0aW9ucyIsInNsZWVwX3F1ZXVlIiwibm93Iiwic2xlZXBfcXVldWUkMCIsInRpbWUiLCJzbGVlcF9xdWV1ZSQxIiwiYWN0aW9uIiwic2xlZXBfcXVldWUkMiIsImdldF9uZXh0X3RpbWVvdXQiLCJiYWRfZmQiLCJpbnZva2VfYWN0aW9ucyIsIm1hcCIsImFjdGlvbnMiLCJzZWxmXzQiLCJhY3Rpb25zJDAiLCJub2RlIiwic2xlZXBlciIsInNsZWVwZXIkMCIsInNlbGZfNSIsInEiLCJlIiwibCIsImZkc19yIiwiZmRzX3ciLCJ0aW1lb3V0IiwiZmRzX3ckMSIsImZkc19yJDAiLCJzZWxmXzYiLCJmZHMiLCJmZHMkMCIsImZkcyQxIiwiZmRzJDIiLCJ3cml0YWJsZSIsInJlYWRhYmxlIiwic2VsZl83IiwiZmRzX3ckMCIsImN1cnJlbnQiLCJnZXQiLCJzZXQiLCJ0cmFuc2ZlciIsImRlc3Ryb3kiLCJpdGVyIiwib25fcmVhZGFibGUiLCJvbl93cml0YWJsZSIsIm9uX3RpbWVyIiwiZmFrZV9pbyIsInJlYWRhYmxlX2NvdW50Iiwid3JpdGFibGVfY291bnQiLCJ0aW1lcl9jb3VudCIsImZvcmsiLCJmb3J3YXJkc19zaWduYWwiLCJuIiwiZW50ZXJfaXRlcl9ob29rcyIsImxlYXZlX2l0ZXJfaG9va3MiLCJ5aWVsZCQwIiwiYWJhbmRvbl95aWVsZGVkX2FuZF9wYXVzZWQiLCJydW5fYWxyZWFkeV9jYWxsZWQiLCJydW5fYWxyZWFkeV9jYWxsZWRfbXV0ZXgiLCJmaW5pc2hlZCIsInJ1biIsInAiLCJlcnJvcl9tZXNzYWdlX2lmX2NhbGxfaXNfbmVzdGUiLCJiYWNrdHJhY2Vfc3RyaW5nIiwibWVzc2FnZSIsInJlc3VsdCIsInNob3VsZF9ibG9ja193YWl0aW5nX2Zvcl9pbyIsImV4aXRfaG9va3MiLCJjYWxsX2hvb2tzIiwiYXRfZXhpdCIsImFkZF9maXJzdCIsImhvb2tfZm4iLCJob29rX25vZGUiLCJhZGRfbGFzdCIsInJlbW92ZSIsInJlbW92ZV9hbGwiLCJkZWZhdWx0X2FzeW5jX21ldGhvZF92YXIiLCJzdHIiLCJkZWZhdWx0X2FzeW5jX21ldGhvZCIsInNldF9kZWZhdWx0X2FzeW5jX21ldGhvZCIsImFtIiwiYXN5bmNfbWV0aG9kX2tleSIsImFzeW5jX21ldGhvZCIsIndpdGhfYXN5bmNfbm9uZSIsIndpdGhfYXN5bmNfZGV0YWNoIiwid2l0aF9hc3luY19zd2l0Y2giLCJ4IiwieSIsImhhc2giLCJub3RpZmllcnMiLCJjdXJyZW50X25vdGlmaWNhdGlvbl9pZCIsIm1ha2Vfbm90aWZpY2F0aW9uIiwib25jZSIsImlkJDEiLCJpZCIsImlkJDAiLCJzdG9wX25vdGlmaWNhdGlvbiIsInNldF9ub3RpZmljYXRpb24iLCJub3RpZmllciIsImNhbGxfbm90aWZpY2F0aW9uIiwic2xlZXAiLCJ3YWtlbmVyIiwid2FpdGVyIiwiYXV0b195aWVsZCIsImxpbWl0IiwiYXV0b19wYXVzZSIsImQiLCJ3aXRoX3RpbWVvdXQiLCJqb2JzIiwiYWJvcnRfam9icyIsImNhbmNlbF9qb2JzIiwid2FpdF9mb3Jfam9icyIsInciLCJydW5fam9iX2F1eCIsImpvYiIsInJlc3VsdCQwIiwiY2hvb3NlX2FzeW5jX21ldGhvZCIsImV4ZWN1dGVfam9iIiwiZnJlZSIsImFzeW5jX21ldGhvZCQwIiwic2VsZl9yZXN1bHQiLCJpbl9yZXRlbnRpb25fdGVzdCIsInJldGFpbmVkIiwibyIsInJ1bl9qb2IiLCJndWVzc19ibG9ja2luZyIsImlzX2Jsb2NraW5nIiwiYmxvY2tpbmciLCJzZXRfZmxhZ3MiLCJzdGF0ZSQxIiwic3RhdGUiLCJzdGF0ZSQwIiwib2ZfdW5peF9maWxlX2Rlc2NyIiwiY2hlY2tfZGVzY3JpcHRvciIsImNoIiwic2V0X2Jsb2NraW5nIiwidW5peF9yZWFkYWJsZSIsInVuaXhfd3JpdGFibGUiLCJzZXRfc3RhdGUiLCJzdCIsImNsZWFyX2V2ZW50cyIsImFib3J0IiwidW5peF9maWxlX2Rlc2NyIiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJzdG9wX2V2ZW50cyIsInJlZ2lzdGVyX3JlYWRhYmxlIiwicmVnaXN0ZXJfd3JpdGFibGUiLCJyZXRyeV9zeXNjYWxsIiwiZXZlbnQiLCJyZXMiLCJlJDAiLCJ2IiwiZXZlbnQkMCIsImR1bW15IiwicmVnaXN0ZXJfYWN0aW9uIiwibm9kZSQwIiwid3JhcF9zeXNjYWxsIiwib3BlbmZpbGUiLCJuYW1lIiwiZmxhZ3MiLCJwZXJtcyIsImNsb3NlIiwid2FpdF9yZWFkIiwicmVhZCIsImJ1ZiIsInBvcyIsImxlbiIsInByZWFkIiwiZmlsZV9vZmZzZXQiLCJyZWFkX2JpZ2FycmF5IiwiZnVuY3Rpb25fbmFtZSIsIndhaXRfd3JpdGUiLCJ3cml0ZSIsInB3cml0ZSIsIndyaXRlX3N0cmluZyIsImJ1ZiQwIiwicHdyaXRlX3N0cmluZyIsIndyaXRlX2JpZ2FycmF5IiwiY3JlYXRlIiwiYnl0ZV9jb3VudCIsInByZWZpeCIsInJldmVyc2VkX3N1ZmZpeCIsImFjYyIsImxlbmd0aCIsImNvdW50X2J1ZmYiLCJhcHBlbmQiLCJpb192ZWN0b3JzIiwiaW9fdmVjdG9yIiwiYXBwZW5kX2J5dGVzIiwiYnVmZmVyIiwib2Zmc2V0IiwiYXBwZW5kX2JpZ2FycmF5IiwiZmxhdHRlbiIsImRyb3AiLCJjb3VudCIsInByZWZpeCQxIiwiY291bnQkMCIsImZpcnN0IiwicHJlZml4JDAiLCJjb3VudCQxIiwiaXNfZW1wdHkiLCJyZXN0Iiwic3lzdGVtX2xpbWl0IiwiY2hlY2tfaW9fdmVjdG9ycyIsInMiLCJidWZmZXJfbGVuZ3RoIiwiYSIsInJlYWR2IiwiYnVmZmVyJDAiLCJ3cml0ZXYiLCJsc2VlayIsIndoZW5jZSIsInRydW5jYXRlIiwiZnRydW5jYXRlIiwiZmRhdGFzeW5jIiwiZnN5bmMiLCJzdGF0IiwibHN0YXQiLCJmc3RhdCIsImZpbGVfZXhpc3RzIiwidXRpbWVzIiwicGF0aCIsImF0aW1lIiwibXRpbWUiLCJpc2F0dHkiLCJsc2VlayQwIiwidHJ1bmNhdGUkMCIsImZ0cnVuY2F0ZSQwIiwic3RhdCQwIiwibHN0YXQkMCIsImZzdGF0JDAiLCJmaWxlX2V4aXN0cyQwIiwidW5saW5rIiwicmVuYW1lIiwibmFtZTEiLCJuYW1lMiIsImxpbmsiLCJvbGRwYXRoIiwibmV3cGF0aCIsImNobW9kIiwibW9kZSIsImZjaG1vZCIsImNob3duIiwidWlkIiwiZ2lkIiwiZmNob3duIiwiYWNjZXNzIiwiZHVwIiwiY2xvZXhlYyIsImR1cDIiLCJjaDEiLCJjaDIiLCJzZXRfY2xvc2Vfb25fZXhlYyIsImNsZWFyX2Nsb3NlX29uX2V4ZWMiLCJta2RpciIsInJtZGlyIiwiY2hkaXIiLCJnZXRjd2QiLCJjaHJvb3QiLCJvcGVuZGlyIiwicmVhZGRpciIsImhhbmRsZSIsInJlYWRkaXJfbiIsImFycmF5IiwiaSIsImkkMCIsInJld2luZGRpciIsImNsb3NlZGlyIiwiY2xlYW51cF9kaXJfaGFuZGxlIiwiZmlsZXNfb2ZfZGlyZWN0b3J5IiwiY2h1bmtfc2l6ZSIsImVudHJpZXMiLCJwaXBlIiwiaW5fZmQiLCJvdXRfZmQiLCJwaXBlX2luIiwicGlwZV9vdXQiLCJta2ZpZm8iLCJzeW1saW5rIiwidG9fZGlyIiwicmVhZGxpbmsiLCJsb2NrZiIsImNtZCIsInNpemUiLCJnZXRsb2dpbiIsImdldHB3bmFtIiwiZ2V0Z3JuYW0iLCJnZXRwd3VpZCIsImdldGdyZ2lkIiwicmVjdiIsImRvX3JlY3YiLCJzZW5kIiwiZG9fc2VuZCIsInJlY3Zmcm9tIiwiZG9fcmVjdmZyb20iLCJzZW5kdG8iLCJhZGRyIiwiZG9fc2VuZHRvIiwicmVjdl9tc2ciLCJzb2NrZXQiLCJzZW5kX21zZyIsInZlY3Rvcl9jb3VudCIsImZkX2NvdW50Iiwic2VuZF9tc2d0byIsImRlc3QiLCJkb20iLCJ0eXAiLCJwcm90byIsInNodXRkb3duIiwic2h1dGRvd25fY29tbWFuZCIsInNvY2tldHBhaXIiLCJzMiIsInMxIiwiYWNjZXB0X2FuZF9zZXRfbm9uYmxvY2siLCJjaF9mZCIsImFkZHIkMCIsImFjY2VwdCIsImFjY2VwdF9uIiwiY29ubmVjdCIsImluX3Byb2dyZXNzIiwiaW5fcHJvZ3Jlc3MkMCIsImVyciIsImJpbmQiLCJsaXN0ZW4iLCJjbnQiLCJnZXRwZWVybmFtZSIsImdldHNvY2tuYW1lIiwiZ2V0X2NyZWRlbnRpYWxzIiwiZ2V0c29ja29wdCIsInNldHNvY2tvcHQiLCJnZXRzb2Nrb3B0X2ludCIsInNldHNvY2tvcHRfaW50IiwiZ2V0c29ja29wdF9vcHRpbnQiLCJzZXRzb2Nrb3B0X29wdGludCIsImdldHNvY2tvcHRfZmxvYXQiLCJzZXRzb2Nrb3B0X2Zsb2F0IiwiZ2V0c29ja29wdF9lcnJvciIsIm1jYXN0X3NldF9sb29wIiwiZmxhZyIsIm1jYXN0X3NldF90dGwiLCJ0dGwiLCJtY2FzdF9hZGRfbWVtYmVyc2hpcCIsImlmbmFtZSIsIm1jYXN0X2Ryb3BfbWVtYmVyc2hpcCIsImdldGhvc3RuYW1lIiwiaG9zdGVudF9tdXRleCIsImdldGhvc3RieW5hbWUiLCJnZXRob3N0YnlhZGRyIiwicHJvdG9lbnRfbXV0ZXgiLCJnZXRwcm90b2J5bmFtZSIsImdldHByb3RvYnludW1iZXIiLCJudW1iZXIiLCJnZXRzZXJ2YnluYW1lIiwiZ2V0c2VydmJ5cG9ydCIsImdldGFkZHJpbmZvIiwiaG9zdCIsInNlcnZpY2UiLCJvcHRzIiwiZ2V0bmFtZWluZm8iLCJ0Y2dldGF0dHIiLCJ0Y3NldGF0dHIiLCJ3aGVuIiwiYXR0cnMiLCJ0Y3NlbmRicmVhayIsInRjZHJhaW4iLCJ0Y2ZsdXNoIiwidGNmbG93IiwiYWN0IiwiaGFuZGxlX25vdGlmaWNhdGlvbnMiLCJldmVudF9ub3RpZmljYXRpb25zIiwic2V0X3NpZ25hbCIsIm5vdGlmaWNhdGlvbiIsImIiLCJzaWduYWxzIiwic2lnbmFsX2NvdW50Iiwib25fc2lnbmFsX2Z1bGwiLCJoYW5kbGVyIiwib25fc2lnbmFsIiwibnVtIiwiZGlzYWJsZV9zaWduYWxfaGFuZGxlciIsInNoIiwicmVpbnN0YWxsX3NpZ25hbF9oYW5kbGVyIiwicGlkIiwiaGFzX3dhaXQ0IiwiZG9fd2FpdDQiLCJzdGF0dXMiLCJwaWQkMCIsIndhaXRfY2hpbGRyZW4iLCJ3YWl0X2NvdW50Iiwic2lnY2hsZF9oYW5kbGVyX2luc3RhbGxlZCIsImluc3RhbGxfc2lnY2hsZF9oYW5kbGVyIiwid2FpdHBpZCIsIndhaXRwaWQkMCIsImZsYWdzJDAiLCJyZXMkMCIsIndhaXQ0Iiwid2FpdCIsInN5c3RlbSIsImNvZGUiLCJoYW5kbGVfdW5peF9lcnJvciIsImdldF9hZmZpbml0eSIsInNldF9hZmZpbml0eSIsImFyZyIsImZ1bmMiLCJlcnJvciIsImVycm9yJDAiLCJiaW5kXzEiLCJtYWtlIiwibHN0X3JlbW92ZSIsImxzdF9pbl9saXN0IiwiYnVja2V0cyIsImN1cnIiLCJzdG9wcGVkIiwiaGFuZGxlX2V4biIsInNldF9leG5faGFuZGxlciIsImxvb3AiLCJzdGFydCIsImluX2xpc3QiLCJzbG90IiwiY2hhbmdlIiwicmF0ZSIsIm1heCIsImxhdW5jaF9jbGVhbmluZyIsImtleSIsImVsdCIsInRvX3J1biIsIm9sZF93YWl0aW5nIiwidXBkYXRlIiwidG9fcnVuJDAiLCJ3YWl0aW5nIiwibm90X2NvbnN1bWVkIiwiY29uc3VtZWQiLCJ1IiwidCQwIiwiZWx0JDAiLCJ3aW5kb3dzIiwiaGF2ZSIsImJ5dGVfb3JkZXIiLCJmaWxsIiwiYnl0ZXMiLCJvZnMiLCJibGl0X2Zyb21fc3RyaW5nIiwic3JjX2J1ZiIsInNyY19vZnMiLCJkc3RfYnVmIiwiZHN0X29mcyIsImJsaXRfZnJvbV9ieXRlcyIsImJsaXRfdG9fYnl0ZXMiLCJibGl0Iiwib2ZfYnl0ZXMiLCJvZl9zdHJpbmciLCJ0b19ieXRlcyIsInRvX3N0cmluZyIsInByb3h5IiwiZXh0cmFjdCIsImNvcHkiLCJjb252ZXJ0X2lvX3ZlY3RvcnMiLCJvbGRfaW9fdmVjdG9ycyIsImlvdl9sZW5ndGgiLCJpb3Zfb2Zmc2V0IiwiaW92X2J1ZmZlciIsIm1hcF9maWxlIiwic2hhcmVkIiwibWFkdmlzZSIsImFkdmljZSIsInBhZ2Vfc2l6ZSIsIm1pbmNvcmUiLCJzdGF0ZXMiLCJ3YWl0X21pbmNvcmUiLCJmdW5fbmFtZSIsIm1pbl9idWZmZXJfc2l6ZSIsImNoZWNrX2J1ZmZlcl9zaXplIiwiYnVmZmVyX3NpemUiLCJkZWZhdWx0X2J1ZmZlcl9zaXplIiwiaW5wdXQiLCJvdXRwdXQiLCJ3cmFwcGVyIiwiaW5kZXgiLCJvdXRwdXRzIiwicG9zaXRpb24iLCJjbG9zZWRfY2hhbm5lbCIsImludmFsaWRfY2hhbm5lbCIsImlzX2J1c3kiLCJmbHVzaF9wYXJ0aWFsIiwicGVyZm9ybSIsInB0ciIsImxlbiQwIiwicGVyZm9ybSQwIiwiZmx1c2hfdG90YWwiLCJvYyIsInNhZmVfZmx1c2hfdG90YWwiLCJhdXRvX2ZsdXNoIiwid3JhcHBlciQxIiwid3JhcHBlciQwIiwidW5sb2NrIiwicHJpbWl0aXZlIiwiYXRvbWljIiwidG1wX3dyYXBwZXIiLCJjaGFubmVsIiwiaXNfY2xvc2VkIiwiZmx1c2hfYWxsIiwid3JhcHBlcnMiLCJub19zZWVrIiwicGVyZm9ybV9pbyIsInNlZWsiLCJidWZmZXIkMSIsInNpemUkMSIsImJ1ZmZlciQyIiwiYWJvcnRfd2FrZW5lciIsImFib3J0X3dhaXRlciIsInNpemUkMCIsIm9mX2ZkIiwiZiQwIiwib2ZfdW5peF9mZCIsImJ1ZmZlcmVkIiwicmVzaXplX2J1ZmZlciIsInVucmVhZF9jb3VudCIsInJlYWRfY2hhciIsImljIiwicmVhZF9jaGFyX29wdCIsInJlYWRfbGluZSIsImNyX3JlYWQiLCJyZWFkX2xpbmVfb3B0IiwidW5zYWZlX3JlYWRfaW50byIsImF2YWlsIiwidW5zYWZlX3JlYWRfaW50b19iaWdzdHJpbmciLCJ1bnNhZmVfcmVhZF9pbnRvJDAiLCJ1bnNhZmVfcmVhZF9pbnRvX2V4YWN0bHkiLCJyZWFkX2ludG8iLCJ1bnNhZmVfcmVhZF9pbnRvX2V4YWN0bHkkMCIsInJlYWRfYWxsIiwidG90YWxfbGVuIiwib2ZzJDAiLCJyZWFkX3ZhbHVlIiwiaGVhZGVyIiwiYnNpemUiLCJ3cml0ZV9jaGFyIiwidW5zYWZlX3dyaXRlX2Zyb20iLCJ1bnNhZmVfd3JpdGVfZnJvbV9iaWdzdHJpbmciLCJ1bnNhZmVfd3JpdGVfZnJvbSQwIiwid3JpdGVfZnJvbSIsInJlbWFpbmluZyIsInVuc2FmZV93cml0ZV9mcm9tX2V4YWN0bHkiLCJ1bnNhZmVfd3JpdGVfZnJvbV9leGFjdGx5JDAiLCJ3cml0ZV9mcm9tX2V4YWN0bHkiLCJyZWFkX2Jsb2NrX3Vuc2FmZSIsIndyaXRlX2Jsb2NrX3Vuc2FmZSIsImRvX3NlZWsiLCJyZWFkX2NoYXIkMCIsInJlYWRfY2hhcl9vcHQkMCIsInJlYWRfbGluZSQwIiwicmVhZF9saW5lX29wdCQwIiwicmVhbF9sZW4iLCJyZWFkX2ludG9fZXhhY3RseSIsInJlYWRfaW50b19iaWdzdHJpbmciLCJyZWFkX2ludG9fZXhhY3RseV9iaWdzdHJpbmciLCJyZWFkX3ZhbHVlJDAiLCJmbHVzaCIsIndyaXRlX2NoYXIkMCIsIndyaXRlJDAiLCJ3cml0ZV9saW5lIiwid3JpdGVfZnJvbSQwIiwid3JpdGVfZnJvbV9iaWdzdHJpbmciLCJ3cml0ZV9mcm9tX3N0cmluZyIsIndyaXRlX2Zyb21fZXhhY3RseSQwIiwid3JpdGVfZnJvbV9leGFjdGx5X2JpZ3N0cmluZyIsIndyaXRlX2Zyb21fc3RyaW5nX2V4YWN0bHkiLCJ3cml0ZV92YWx1ZSIsImRpcmVjdF9hY2Nlc3MiLCJ0b2tlbiIsImRhIiwic2V0X3Bvc2l0aW9uIiwibGVuZ3RoJDAiLCJyZWFkX2ludCIsInJlYWRfaW50MTYiLCJyZWFkX2ludDMyIiwicmVhZF9pbnQ2NCIsInJlYWRfZmxvYXQzMiIsInJlYWRfZmxvYXQ2NCIsIndyaXRlX2ludCIsIndyaXRlX2ludDE2Iiwid3JpdGVfaW50MzIiLCJ3cml0ZV9pbnQ2NCIsIndyaXRlX2Zsb2F0MzIiLCJ3cml0ZV9mbG9hdDY0IiwicmVhZF9pbnQkMCIsInJlYWRfaW50MTYkMCIsInJlYWRfaW50MzIkMCIsInJlYWRfaW50NjQkMCIsInJlYWRfZmxvYXQzMiQwIiwicmVhZF9mbG9hdDY0JDAiLCJ3cml0ZV9pbnQkMCIsIndyaXRlX2ludDE2JDAiLCJ3cml0ZV9pbnQzMiQwIiwid3JpdGVfaW50NjQkMCIsIndyaXRlX2Zsb2F0MzIkMCIsIndyaXRlX2Zsb2F0NjQkMCIsInN5c3RlbV9ieXRlX29yZGVyIiwicmVhZF9jaGFycyIsIndyaXRlX2NoYXJzIiwiY2hhcnMiLCJjaGFyJDAiLCJyZWFkX2xpbmVzIiwid3JpdGVfbGluZXMiLCJsaW5lcyIsImxpbmUiLCJ6ZXJvIiwibnVsbCQwIiwiZnByaW50IiwidHh0IiwiZnByaW50bCIsImZwcmludGYiLCJmcHJpbnRsZiIsInByaW50IiwicHJpbnRsIiwicHJpbnRmIiwicHJpbnRsZiIsImVwcmludCIsImVwcmludGwiLCJlcHJpbnRmIiwiZXByaW50bGYiLCJpbl9idWZmZXIiLCJvdXRfYnVmZmVyIiwiZmRfdyIsImZkX3IiLCJvcGVuX2ZpbGUiLCJwZXJtIiwiZmlsZW5hbWUiLCJwZXJtJDAiLCJ3aXRoX2ZpbGUiLCJwcm5nIiwidGVtcF9maWxlX25hbWUiLCJ0ZW1wX2RpciIsInN1ZmZpeCIsInJuZCIsIm9wZW5fdGVtcF9maWxlIiwiZmxhZ3MkMSIsImRpcm5hbWUiLCJkaXIiLCJhdHRlbXB0IiwiZm5hbWUiLCJjaGFuIiwid2l0aF90ZW1wX2ZpbGUiLCJjcmVhdGVfdGVtcF9kaXIiLCJwYXJlbnQiLCJzdGgkMSIsInN0aCQyIiwid2luMzJfdW5saW5rIiwiZm4iLCJzdF9wZXJtIiwiZGVsZXRlX3JlY3Vyc2l2ZWx5IiwiZGlyZWN0b3J5IiwiZW50cnkiLCJzdF9raW5kIiwid2l0aF90ZW1wX2RpciIsImZpbGVfbGVuZ3RoIiwiY2xvc2Vfc29ja2V0Iiwib3Blbl9jb25uZWN0aW9uIiwic29ja2FkZHIiLCJmZCQxIiwid2l0aF9jbG9zZV9jb25uZWN0aW9uIiwiY2xvc2VfaWZfbm90X2Nsb3NlZCIsIndpdGhfY29ubmVjdGlvbiIsImNoYW5uZWxzIiwic2h1dGRvd25fc2VydmVyIiwic2VydmVyIiwic2h1dGRvd25fc2VydmVyX2RlcHJlY2F0ZWQiLCJlc3RhYmxpc2hfc2VydmVyX2dlbmVyaWMiLCJiaW5kX2Z1bmN0aW9uIiwicHJlZXhpc3Rpbmdfc29ja2V0X2Zvcl9saXN0ZW5pIiwibGlzdGVuaW5nX2FkZHJlc3MiLCJjb25uZWN0aW9uX2hhbmRsZXJfY2FsbGJhY2siLCJiYWNrbG9nIiwibGlzdGVuaW5nX3NvY2tldCIsIm5vdGlmeV9zaG91bGRfc3RvcCIsInNob3VsZF9zdG9wIiwibm90aWZ5X2xpc3RlbmluZ19zb2NrZXRfY2xvc2VkIiwid2FpdF91bnRpbF9saXN0ZW5pbmdfc29ja2V0X2NsIiwiYWNjZXB0X2xvb3AiLCJ0cnlfdG9fYWNjZXB0IiwiY2xpZW50X2FkZHJlc3MiLCJjbGllbnRfc29ja2V0Iiwic2VydmVyX2hhc19zdGFydGVkIiwiZXN0YWJsaXNoX3NlcnZlcl93aXRoX2NsaWVudF9zIiwic2VydmVyX2ZkIiwibm9fY2xvc2UiLCJzZXJ2ZXJfc3RhcnRlZCIsImVzdGFibGlzaF9zZXJ2ZXJfd2l0aF9jbGllbnRfYSIsImJlc3RfZWZmb3J0X2Nsb3NlIiwiaGFuZGxlciQwIiwiaW5wdXRfY2hhbm5lbCIsIm91dHB1dF9jaGFubmVsIiwiZXN0YWJsaXNoX3NlcnZlcl93aXRoX2NsaWVudF9hJDAiLCJlc3RhYmxpc2hfc2VydmVyIiwiYyIsImVzdGFibGlzaF9zZXJ2ZXJfZGVwcmVjYXRlZCIsImJsb2NraW5nX2JpbmQiLCJpZ25vcmVfY2xvc2UiLCJtYWtlX3N0cmVhbSIsImxhenlfaWMiLCJsYXp5X2ljJDAiLCJsaW5lc19vZl9maWxlIiwibGluZXNfdG9fZmlsZSIsImNoYXJzX29mX2ZpbGUiLCJjaGFyc190b19maWxlIiwiaGV4ZHVtcF9zdHJlYW0iLCJzdHJlYW0iLCJoZXhkdW1wIiwic2V0X2RlZmF1bHRfYnVmZmVyX3NpemUiLCJkZWZhdWx0X2J1ZmZlcl9zaXplJDAiLCJzaGVsbCIsIndpbjMyX2dldF9mZCIsInJlZGlyZWN0aW9uIiwid2luMzJfcXVvdGUiLCJ3aW4zMl9zcGF3biIsImN3ZCIsImVudiIsImFyZ3MiLCJwcm9nIiwiY21kbGluZSIsImVudiQwIiwiZW52JDEiLCJzdGRpbl9mZCIsInN0ZG91dF9mZCIsInN0ZGVycl9mZCIsInByb2MiLCJ3aW4zMl93YWl0cHJvYyIsIndpbjMyX3Rlcm1pbmF0ZSIsInVuaXhfcmVkaXJlY3QiLCJkZXZfbnVsbCIsInVuaXhfc3Bhd24iLCJwcm9nJDAiLCJ1bml4X3dhaXRwcm9jIiwidW5peF90ZXJtaW5hdGUiLCJ3aW4zMl9zcGF3biQwIiwid2luMzJfd2FpdHByb2MkMCIsInRlcm1pbmF0ZSIsInJ1c2FnZSIsImR0Iiwic2VsZl8zIiwic3Rkb3V0X3ciLCJzdGRvdXRfciIsInN0ZGluX3ciLCJzdGRpbl9yIiwic3RkZXJyX3ciLCJzdGRlcnJfciIsIm9wZW5fcHJvY2Vzc19ub25lIiwib3Blbl9wcm9jZXNzX2luIiwib3Blbl9wcm9jZXNzX291dCIsIm9wZW5fcHJvY2VzcyIsIm9wZW5fcHJvY2Vzc19mdWxsIiwibWFrZV93aXRoIiwiYmFja2VuZCIsInByb2Nlc3MiLCJ3aXRoX3Byb2Nlc3Nfbm9uZSIsIndpdGhfcHJvY2Vzc19pbiIsIndpdGhfcHJvY2Vzc19vdXQiLCJ3aXRoX3Byb2Nlc3MiLCJ3aXRoX3Byb2Nlc3NfZnVsbCIsImV4ZWMiLCJyZWFkX29wdCIsInJlY3ZfY2hhcnMiLCJwciIsInJlY3ZfbGluZXMiLCJyZWN2X2xpbmUiLCJkYXRhIiwicHJlYWRfY2hhcnMiLCJwcmVhZF9saW5lIiwicHJlYWRfbGluZXMiLCJ0ZXh0IiwicHdyaXRlX2NoYXJzIiwicHdyaXRlX2xpbmUiLCJwd3JpdGVfbGluZXMiLCJtb25pdG9yIiwic2VuZGVyIiwic2VuZGVyJDAiLCJnZXR0ZXIiLCJwbWFwIiwicG1hcF9jaGFycyIsInBtYXBfbGluZSIsInBtYXBfbGluZXMiLCJtaW5fdGhyZWFkcyIsIm1heF90aHJlYWRzIiwibWF4X3RocmVhZF9xdWV1ZWQiLCJnZXRfbWF4X251bWJlcl9vZl90aHJlYWRzX3F1ZXUiLCJzZXRfbWF4X251bWJlcl9vZl90aHJlYWRzX3F1ZXUiLCJ0aHJlYWRzX2NvdW50Iiwid29ya2VycyIsIndhaXRlcnMiLCJ3b3JrZXJfbG9vcCIsIndvcmtlciIsInRhc2siLCJtYWtlX3dvcmtlciIsImFkZF93b3JrZXIiLCJnZXRfYm91bmRzIiwic2V0X2JvdW5kcyIsIm1pbiIsImRpZmYiLCJpbml0aWFsaXplZCIsImluaXQiLCJlcnJsb2ciLCJzaW1wbGVfaW5pdCIsIm5idGhyZWFkcyIsIm5idGhyZWFkc3F1ZXVlZCIsIm5idGhyZWFkc2J1c3kiLCJpbml0X3Jlc3VsdCIsImRldGFjaCIsImpvYnNfbXV0ZXgiLCJ0aHVuayIsImpvYl9ub3RpZmljYXRpb24iLCJydW5faW5fbWFpbiIsImNlbGwiLCJyZXQiLCJydW5faW5fbWFpbl9kb250X3dhaXQiLCJleGMiLCJmaW5hbGlzZXIiLCJob29rIiwiZmluYWxpc2UiLCJmaW5hbGlzZV9vcl9leGl0Iiwid2VhayIsImNhbGxlZCIsIndyaXRlX3BlbmRpbmciLCJwcGZ0IiwibWFrZV9mb3JtYXR0ZXIiLCJjb21taXQiLCJnZXRfZm9ybWF0dGVyIiwicHVzaCIsIm91dF9zdHJpbmciLCJqIiwid3JpdGVfb3JkZXIiLCJ3cml0ZV9vcmRlcnMiLCJxdWV1ZSIsIm9mX2NoYW5uZWwiLCJrZnByaW50ZiIsImsiLCJwcGYiLCJpa2ZwcmludGYiLCJpZnByaW50ZiJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2x3dC91bml4L2x3dF9lbmdpbmUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3QvdW5peC9sd3RfbWFpbi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2x3dC91bml4L2x3dF91bml4Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbHd0L3VuaXgvbHd0X3RpbWVvdXQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3QvdW5peC9sd3RfdGhyb3R0bGUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3QvdW5peC9sd3Rfc3lzLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbHd0L3VuaXgvbHd0X2J5dGVzLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbHd0L3VuaXgvbHd0X2lvLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbHd0L3VuaXgvbHd0X3Byb2Nlc3MubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sd3QvdW5peC9sd3RfcHJlZW1wdGl2ZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2x3dC91bml4L2x3dF9nYy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2x3dC91bml4L2x3dF9mbXQubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUFNLE9BVGRpbkIsUUFNQXBkLFFBR1E3SixLQUF3Qjs7OztPQURoQ3FuQjtPQUNBSTtPQXhEQStFO09BNkJBc0k7T0F1QkFsckI7T0FDQUM7T0EvREF3cUI7T0FFQUU7T0F1REF0TjtPQUxBOE47T0FPQUk7T0FMQUQ7T0F4REF2UjtPQTJCQWdSO09BNUJBUjs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgRXZlbnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxudHlwZSBfZXZlbnQgPSB7XG4gIHN0b3AgOiB1bml0IExhenkudDtcbiAgKCogVGhlIHN0b3AgbWV0aG9kIG9mIHRoZSBldmVudC4gKilcbiAgbm9kZSA6IE9iai50IEx3dF9zZXF1ZW5jZS5ub2RlO1xuICAoKiBUaGUgbm9kZSBpbiB0aGUgc2VxdWVuY2Ugb2YgcmVnaXN0ZXJlZCBldmVudHMuICopXG59XG5cbnR5cGUgZXZlbnQgPSBfZXZlbnQgcmVmXG5cbmV4dGVybmFsIGNhc3Rfbm9kZSA6ICdhIEx3dF9zZXF1ZW5jZS5ub2RlIC0+IE9iai50IEx3dF9zZXF1ZW5jZS5ub2RlID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgc3RvcF9ldmVudCBldiA9XG4gIGxldCBldiA9ICFldiBpblxuICBMd3Rfc2VxdWVuY2UucmVtb3ZlIGV2Lm5vZGU7XG4gIExhenkuZm9yY2UgZXYuc3RvcFxuXG5sZXQgX2Zha2VfZXZlbnQgPSB7XG4gIHN0b3AgPSBsYXp5ICgpO1xuICBub2RlID0gTHd0X3NlcXVlbmNlLmFkZF9sIChPYmoucmVwciAoKSkgKEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCkpO1xufVxuXG5sZXQgZmFrZV9ldmVudCA9IHJlZiBfZmFrZV9ldmVudFxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IEVuZ2luZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmNsYXNzIHZpcnR1YWwgYWJzdHJhY3QgPSBvYmplY3Qoc2VsZilcbiAgbWV0aG9kIHZpcnR1YWwgaXRlciA6IGJvb2wgLT4gdW5pdFxuICBtZXRob2QgdmlydHVhbCBwcml2YXRlIGNsZWFudXAgOiB1bml0XG4gIG1ldGhvZCB2aXJ0dWFsIHByaXZhdGUgcmVnaXN0ZXJfcmVhZGFibGUgOiBVbml4LmZpbGVfZGVzY3IgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdCBMYXp5LnRcbiAgbWV0aG9kIHZpcnR1YWwgcHJpdmF0ZSByZWdpc3Rlcl93cml0YWJsZSA6IFVuaXguZmlsZV9kZXNjciAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0IExhenkudFxuICBtZXRob2QgdmlydHVhbCBwcml2YXRlIHJlZ2lzdGVyX3RpbWVyIDogZmxvYXQgLT4gYm9vbCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0IExhenkudFxuXG4gIHZhbCByZWFkYWJsZXMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpXG4gICgqIFNlcXVlbmNlIG9mIGNhbGxiYWNrcyB3YWl0aW5nIGZvciBhIGZpbGUgZGVzY3JpcHRvciB0byBiZWNvbWVcbiAgICAgcmVhZGFibGUuICopXG5cbiAgdmFsIHdyaXRhYmxlcyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKClcbiAgKCogU2VxdWVuY2Ugb2YgY2FsbGJhY2tzIHdhaXRpbmcgZm9yIGEgZmlsZSBkZXNjcmlwdG9yIHRvIGJlY29tZVxuICAgICB3cml0YWJsZS4gKilcblxuICB2YWwgdGltZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKVxuICAoKiBTZXF1ZW5jZSBvZiB0aW1lcnMuICopXG5cbiAgbWV0aG9kIGRlc3Ryb3kgPVxuICAgIEx3dF9zZXF1ZW5jZS5pdGVyX2wgKGZ1biAoX2ZkLCBfZiwgX2csIGV2KSAtPiBzdG9wX2V2ZW50IGV2KSByZWFkYWJsZXM7XG4gICAgTHd0X3NlcXVlbmNlLml0ZXJfbCAoZnVuIChfZmQsIF9mLCBfZywgZXYpIC0+IHN0b3BfZXZlbnQgZXYpIHdyaXRhYmxlcztcbiAgICBMd3Rfc2VxdWVuY2UuaXRlcl9sIChmdW4gKF9kZWxheSwgX3JlcGVhdCwgX2YsIF9nLCBldikgLT4gc3RvcF9ldmVudCBldilcbiAgICAgIHRpbWVycztcbiAgICBzZWxmI2NsZWFudXBcblxuICBtZXRob2QgdHJhbnNmZXIgKGVuZ2luZSA6IGFic3RyYWN0KSA9XG4gICAgTHd0X3NlcXVlbmNlLml0ZXJfbCAoZnVuIChmZCwgZiwgX2csIGV2KSAtPlxuICAgICAgc3RvcF9ldmVudCBldjsgZXYgOj0gIShlbmdpbmUjb25fcmVhZGFibGUgZmQgZikpIHJlYWRhYmxlcztcbiAgICBMd3Rfc2VxdWVuY2UuaXRlcl9sIChmdW4gKGZkLCBmLCBfZywgZXYpIC0+XG4gICAgICBzdG9wX2V2ZW50IGV2OyBldiA6PSAhKGVuZ2luZSNvbl93cml0YWJsZSBmZCBmKSkgd3JpdGFibGVzO1xuICAgIEx3dF9zZXF1ZW5jZS5pdGVyX2wgKGZ1biAoZGVsYXksIHJlcGVhdCwgZiwgX2csIGV2KSAtPlxuICAgICAgc3RvcF9ldmVudCBldjsgZXYgOj0gIShlbmdpbmUjb25fdGltZXIgZGVsYXkgcmVwZWF0IGYpKSB0aW1lcnNcblxuICBtZXRob2QgZmFrZV9pbyBmZCA9XG4gICAgTHd0X3NlcXVlbmNlLml0ZXJfbCAoZnVuIChmZCcsIF9mLCBnLCBfc3RvcCkgLT5cbiAgICAgIGlmIGZkID0gZmQnIHRoZW4gZyAoKSkgcmVhZGFibGVzO1xuICAgIEx3dF9zZXF1ZW5jZS5pdGVyX2wgKGZ1biAoZmQnLCBfZiwgZywgX3N0b3ApIC0+XG4gICAgICBpZiBmZCA9IGZkJyB0aGVuIGcgKCkpIHdyaXRhYmxlc1xuXG4gIG1ldGhvZCBvbl9yZWFkYWJsZSBmZCBmID1cbiAgICBsZXQgZXYgPSByZWYgX2Zha2VfZXZlbnQgaW5cbiAgICBsZXQgZyAoKSA9IGYgZXYgaW5cbiAgICBsZXQgc3RvcCA9IHNlbGYjcmVnaXN0ZXJfcmVhZGFibGUgZmQgZyBpblxuICAgIGV2IDo9IHsgc3RvcCA9IHN0b3A7IG5vZGUgPSBjYXN0X25vZGUgKEx3dF9zZXF1ZW5jZS5hZGRfciAoZmQsIGYsIGcsIGV2KSByZWFkYWJsZXMpIH07XG4gICAgZXZcblxuICBtZXRob2Qgb25fd3JpdGFibGUgZmQgZiA9XG4gICAgbGV0IGV2ID0gcmVmIF9mYWtlX2V2ZW50IGluXG4gICAgbGV0IGcgKCkgPSBmIGV2IGluXG4gICAgbGV0IHN0b3AgPSBzZWxmI3JlZ2lzdGVyX3dyaXRhYmxlIGZkIGcgaW5cbiAgICBldiA6PSB7IHN0b3AgPSBzdG9wOyBub2RlID0gY2FzdF9ub2RlIChMd3Rfc2VxdWVuY2UuYWRkX3IgKGZkLCBmLCBnLCBldikgd3JpdGFibGVzKSB9IDtcbiAgICBldlxuXG4gIG1ldGhvZCBvbl90aW1lciBkZWxheSByZXBlYXQgZiA9XG4gICAgbGV0IGV2ID0gcmVmIF9mYWtlX2V2ZW50IGluXG4gICAgbGV0IGcgKCkgPSBmIGV2IGluXG4gICAgbGV0IHN0b3AgPSBzZWxmI3JlZ2lzdGVyX3RpbWVyIGRlbGF5IHJlcGVhdCBnIGluXG4gICAgZXYgOj0geyBzdG9wID0gc3RvcDsgbm9kZSA9IGNhc3Rfbm9kZSAoTHd0X3NlcXVlbmNlLmFkZF9yIChkZWxheSwgcmVwZWF0LCBmLCBnLCBldikgdGltZXJzKSB9O1xuICAgIGV2XG5cbiAgbWV0aG9kIHJlYWRhYmxlX2NvdW50ID0gTHd0X3NlcXVlbmNlLmxlbmd0aCByZWFkYWJsZXNcbiAgbWV0aG9kIHdyaXRhYmxlX2NvdW50ID0gTHd0X3NlcXVlbmNlLmxlbmd0aCB3cml0YWJsZXNcbiAgbWV0aG9kIHRpbWVyX2NvdW50ID0gTHd0X3NlcXVlbmNlLmxlbmd0aCB0aW1lcnNcblxuICBtZXRob2QgZm9yayA9ICgpXG5cbiAgbWV0aG9kIGZvcndhcmRzX3NpZ25hbCAoX3NpZ251bTppbnQpID0gZmFsc2VcbmVuZFxuXG5jbGFzcyB0eXBlIHQgPSBvYmplY3RcbiAgaW5oZXJpdCBhYnN0cmFjdFxuXG4gIG1ldGhvZCBpdGVyIDogYm9vbCAtPiB1bml0XG4gIG1ldGhvZCBwcml2YXRlIGNsZWFudXAgOiB1bml0XG4gIG1ldGhvZCBwcml2YXRlIHJlZ2lzdGVyX3JlYWRhYmxlIDogVW5peC5maWxlX2Rlc2NyIC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXQgTGF6eS50XG4gIG1ldGhvZCBwcml2YXRlIHJlZ2lzdGVyX3dyaXRhYmxlIDogVW5peC5maWxlX2Rlc2NyIC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXQgTGF6eS50XG4gIG1ldGhvZCBwcml2YXRlIHJlZ2lzdGVyX3RpbWVyIDogZmxvYXQgLT4gYm9vbCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0IExhenkudFxuZW5kXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgVGhlIGxpYmV2IGVuZ2luZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxudHlwZSBldl9sb29wXG50eXBlIGV2X2lvXG50eXBlIGV2X3RpbWVyXG5cbm1vZHVsZSBFdl9iYWNrZW5kID1cbnN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgRVZfREVGQVVMVFxuICAgIHwgRVZfU0VMRUNUXG4gICAgfCBFVl9QT0xMXG4gICAgfCBFVl9FUE9MTFxuICAgIHwgRVZfS1FVRVVFXG4gICAgfCBFVl9ERVZQT0xMXG4gICAgfCBFVl9QT1JUXG5cbiAgbGV0IGRlZmF1bHQgPSBFVl9ERUZBVUxUXG4gIGxldCBzZWxlY3QgPSBFVl9TRUxFQ1RcbiAgbGV0IHBvbGwgPSBFVl9QT0xMXG4gIGxldCBlcG9sbCA9IEVWX0VQT0xMXG4gIGxldCBrcXVldWUgPSBFVl9LUVVFVUVcbiAgbGV0IGRldnBvbGwgPSBFVl9ERVZQT0xMXG4gIGxldCBwb3J0ID0gRVZfUE9SVFxuXG4gIGxldCBlcXVhbCA9ICggPSApXG5cbiAgbGV0IG5hbWUgPSBmdW5jdGlvblxuICAgIHwgRVZfREVGQVVMVCAtPiBcIkVWX0RFRkFVTFRcIlxuICAgIHwgRVZfU0VMRUNUIC0+IFwiRVZfU0VMRUNUXCJcbiAgICB8IEVWX1BPTEwgLT4gXCJFVl9QT0xMXCJcbiAgICB8IEVWX0VQT0xMIC0+IFwiRVZfRVBPTExcIlxuICAgIHwgRVZfS1FVRVVFIC0+IFwiRVZfS1FVRVVFXCJcbiAgICB8IEVWX0RFVlBPTEwgLT4gXCJFVl9ERVZQT0xMXCJcbiAgICB8IEVWX1BPUlQgLT4gXCJFVl9QT1JUXCJcblxuICBsZXQgcHAgZm10IHQgPSBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCAobmFtZSB0KVxuZW5kXG5cbmV4dGVybmFsIGV2X2luaXQgOiBFdl9iYWNrZW5kLnQgLT4gZXZfbG9vcCA9IFwibHd0X2xpYmV2X2luaXRcIlxuZXh0ZXJuYWwgZXZfYmFja2VuZCA6IGV2X2xvb3AgLT4gRXZfYmFja2VuZC50ID0gXCJsd3RfbGliZXZfYmFja2VuZFwiXG5leHRlcm5hbCBldl9zdG9wIDogZXZfbG9vcCAtPiB1bml0ID0gXCJsd3RfbGliZXZfc3RvcFwiXG5leHRlcm5hbCBldl9sb29wIDogZXZfbG9vcCAtPiBib29sIC0+IHVuaXQgPSBcImx3dF9saWJldl9sb29wXCJcbmV4dGVybmFsIGV2X3VubG9vcCA6IGV2X2xvb3AgLT4gdW5pdCA9IFwibHd0X2xpYmV2X3VubG9vcFwiXG5leHRlcm5hbCBldl9yZWFkYWJsZV9pbml0IDogZXZfbG9vcCAtPiBVbml4LmZpbGVfZGVzY3IgLT4gKHVuaXQgLT4gdW5pdCkgLT4gZXZfaW8gPSBcImx3dF9saWJldl9yZWFkYWJsZV9pbml0XCJcbmV4dGVybmFsIGV2X3dyaXRhYmxlX2luaXQgOiBldl9sb29wIC0+IFVuaXguZmlsZV9kZXNjciAtPiAodW5pdCAtPiB1bml0KSAtPiBldl9pbyA9IFwibHd0X2xpYmV2X3dyaXRhYmxlX2luaXRcIlxuZXh0ZXJuYWwgZXZfaW9fc3RvcCA6IGV2X2xvb3AgLT4gZXZfaW8gLT4gdW5pdCA9IFwibHd0X2xpYmV2X2lvX3N0b3BcIlxuZXh0ZXJuYWwgZXZfdGltZXJfaW5pdCA6IGV2X2xvb3AgLT4gZmxvYXQgLT4gYm9vbCAtPiAodW5pdCAtPiB1bml0KSAtPiBldl90aW1lciA9IFwibHd0X2xpYmV2X3RpbWVyX2luaXRcIlxuZXh0ZXJuYWwgZXZfdGltZXJfc3RvcCA6IGV2X2xvb3AgLT4gZXZfdGltZXIgLT4gdW5pdCAgPSBcImx3dF9saWJldl90aW1lcl9zdG9wXCJcblxuY2xhc3MgbGliZXYgPyhiYWNrZW5kPUV2X2JhY2tlbmQuZGVmYXVsdCkgKCkgPSBvYmplY3RcbiAgaW5oZXJpdCBhYnN0cmFjdFxuXG4gIHZhbCBsb29wID0gZXZfaW5pdCBiYWNrZW5kXG4gIG1ldGhvZCBsb29wID0gbG9vcFxuXG4gIG1ldGhvZCBiYWNrZW5kID0gZXZfYmFja2VuZCBsb29wXG5cbiAgbWV0aG9kIHByaXZhdGUgY2xlYW51cCA9IGV2X3N0b3AgbG9vcFxuXG4gIG1ldGhvZCBpdGVyIGJsb2NrID1cbiAgICB0cnlcbiAgICAgIGV2X2xvb3AgbG9vcCBibG9ja1xuICAgIHdpdGggZXhuIC0+XG4gICAgICBldl91bmxvb3AgbG9vcDtcbiAgICAgIHJhaXNlIGV4blxuXG4gIG1ldGhvZCBwcml2YXRlIHJlZ2lzdGVyX3JlYWRhYmxlIGZkIGYgPVxuICAgIGxldCBldiA9IGV2X3JlYWRhYmxlX2luaXQgbG9vcCBmZCBmIGluXG4gICAgbGF6eShldl9pb19zdG9wIGxvb3AgZXYpXG5cbiAgbWV0aG9kIHByaXZhdGUgcmVnaXN0ZXJfd3JpdGFibGUgZmQgZiA9XG4gICAgbGV0IGV2ID0gZXZfd3JpdGFibGVfaW5pdCBsb29wIGZkIGYgaW5cbiAgICBsYXp5KGV2X2lvX3N0b3AgbG9vcCBldilcblxuICBtZXRob2QgcHJpdmF0ZSByZWdpc3Rlcl90aW1lciBkZWxheSByZXBlYXQgZiA9XG4gICAgbGV0IGV2ID0gZXZfdGltZXJfaW5pdCBsb29wIGRlbGF5IHJlcGVhdCBmIGluXG4gICAgbGF6eShldl90aW1lcl9zdG9wIGxvb3AgZXYpXG5lbmRcblxuY2xhc3MgbGliZXZfZGVwcmVjYXRlZCA9IGxpYmV2ICgpXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgU2VsZWN0L3BvbGwgYmFzZWQgZW5naW5lcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxuKCogVHlwZSBvZiBhIHNsZWVwZXIgZm9yIHRoZSBzZWxlY3QgZW5naW5lLiAqKVxudHlwZSBzbGVlcGVyID0ge1xuICBtdXRhYmxlIHRpbWUgOiBmbG9hdDtcbiAgKCogVGhlIHRpbWUgYXQgd2hpY2ggdGhlIHNsZWVwZXIgc2hvdWxkIGJlIHdha2V1cC4gKilcblxuICBtdXRhYmxlIHN0b3BwZWQgOiBib29sO1xuICAoKiBbdHJ1ZV0gaWZmIHRoZSBldmVudCBoYXMgYmVlbiBzdG9wcGVkLiAqKVxuXG4gIGFjdGlvbiA6IHVuaXQgLT4gdW5pdDtcbiAgKCogVGhlIGFjdGlvbiBmb3IgdGhlIHNsZWVwZXIuICopXG59XG5cbm1vZHVsZSBTbGVlcF9xdWV1ZSA9XG4gIEx3dF9wcXVldWUuTWFrZShzdHJ1Y3RcbiAgICB0eXBlIHQgPSBzbGVlcGVyXG4gICAgbGV0IGNvbXBhcmUge3RpbWUgPSB0MTsgX30ge3RpbWUgPSB0MjsgX30gPSBjb21wYXJlIHQxIHQyXG4gIGVuZClcbiAgW0BAb2NhbWwud2FybmluZyBcIi0zXCJdXG5cbm1vZHVsZSBGZF9tYXAgPSBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gVW5peC5maWxlX2Rlc2NyIGxldCBjb21wYXJlID0gY29tcGFyZSBlbmQpXG5cbmxldCByZWMgcmVzdGFydF9hY3Rpb25zIHNsZWVwX3F1ZXVlIG5vdyA9XG4gIG1hdGNoIFNsZWVwX3F1ZXVlLmxvb2t1cF9taW4gc2xlZXBfcXVldWUgd2l0aFxuICB8IFNvbWV7IHN0b3BwZWQgPSB0cnVlOyBfIH0gLT5cbiAgICByZXN0YXJ0X2FjdGlvbnMgKFNsZWVwX3F1ZXVlLnJlbW92ZV9taW4gc2xlZXBfcXVldWUpIG5vd1xuICB8IFNvbWV7IHRpbWUgPSB0aW1lOyBhY3Rpb24gPSBhY3Rpb247IF8gfSB3aGVuIHRpbWUgPD0gbm93IC0+XG4gICAgKCogV2UgaGF2ZSB0byByZW1vdmUgdGhlIHNsZWVwZXIgdG8gdGhlIHF1ZXVlIGJlZm9yZSBwZXJmb3JtaW5nXG4gICAgICAgdGhlIGFjdGlvbi4gVGhlIGFjdGlvbiBjYW4gY2hhbmdlIHRoZSBzbGVlcGVyJ3MgdGltZSwgYW5kIHRoaXNcbiAgICAgICBtaWdodCBicmVhayB0aGUgcHJpb3JpdHkgcXVldWUgaW52YXJpYW50IGlmIHRoZSBzbGVlcGVyIGlzXG4gICAgICAgc3RpbGwgaW4gdGhlIHF1ZXVlLiAqKVxuICAgIGxldCBxID0gU2xlZXBfcXVldWUucmVtb3ZlX21pbiBzbGVlcF9xdWV1ZSBpblxuICAgIGFjdGlvbiAoKTtcbiAgICByZXN0YXJ0X2FjdGlvbnMgcSBub3dcbiAgfCBfIC0+XG4gICAgc2xlZXBfcXVldWVcblxubGV0IHJlYyBnZXRfbmV4dF90aW1lb3V0IHNsZWVwX3F1ZXVlID1cbiAgbWF0Y2ggU2xlZXBfcXVldWUubG9va3VwX21pbiBzbGVlcF9xdWV1ZSB3aXRoXG4gIHwgU29tZXsgc3RvcHBlZCA9IHRydWU7IF8gfSAtPlxuICAgIGdldF9uZXh0X3RpbWVvdXQgKFNsZWVwX3F1ZXVlLnJlbW92ZV9taW4gc2xlZXBfcXVldWUpXG4gIHwgU29tZXsgdGltZSA9IHRpbWU7IF8gfSAtPlxuICAgIG1heCAwLiAodGltZSAtLiBVbml4LmdldHRpbWVvZmRheSAoKSlcbiAgfCBOb25lIC0+XG4gICAgLTEuXG5cbmxldCBiYWRfZmQgZmQgPVxuICB0cnlcbiAgICBsZXQgXyA9IFVuaXguZnN0YXQgZmQgaW5cbiAgICBmYWxzZVxuICB3aXRoIFVuaXguVW5peF9lcnJvciAoXywgXywgXykgLT5cbiAgICB0cnVlXG5cbmxldCBpbnZva2VfYWN0aW9ucyBmZCBtYXAgPVxuICBtYXRjaCBGZF9tYXAuZmluZCBmZCBtYXAgd2l0aFxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gKClcbiAgfCBhY3Rpb25zIC0+IEx3dF9zZXF1ZW5jZS5pdGVyX2wgKGZ1biBmIC0+IGYgKCkpIGFjdGlvbnNcblxuY2xhc3MgdmlydHVhbCBzZWxlY3Rfb3JfcG9sbF9iYXNlZCA9IG9iamVjdFxuICBpbmhlcml0IGFic3RyYWN0XG5cbiAgdmFsIG11dGFibGUgc2xlZXBfcXVldWUgPSBTbGVlcF9xdWV1ZS5lbXB0eVxuICAoKiBUaHJlYWRzIHdhaXRpbmcgZm9yIGEgdGltZW91dCB0byBleHBpcmUuICopXG5cbiAgdmFsIG11dGFibGUgbmV3X3NsZWVwcyA9IFtdXG4gICgqIFNsZWVwZXJzIGFkZGVkIHNpbmNlIHRoZSBsYXN0IGl0ZXJhdGlvbiBvZiB0aGUgbWFpbiBsb29wOlxuXG4gICAgIFRoZXkgYXJlIG5vdCBhZGRlZCBpbW1lZGlhdGVseSB0byB0aGUgbWFpbiBzbGVlcCBxdWV1ZSBpbiBvcmRlclxuICAgICB0byBwcmV2ZW50IHRoZW0gZnJvbSBiZWluZyB3YWtldXAgaW1tZWRpYXRlbHkuICAqKVxuXG4gIHZhbCBtdXRhYmxlIHdhaXRfcmVhZGFibGUgPSBGZF9tYXAuZW1wdHlcbiAgKCogU2VxdWVuY2VzIG9mIGFjdGlvbnMgd2FpdGluZyBmb3IgZmlsZSBkZXNjcmlwdG9ycyB0byBiZWNvbWVcbiAgICAgcmVhZGFibGUuICopXG5cbiAgdmFsIG11dGFibGUgd2FpdF93cml0YWJsZSA9IEZkX21hcC5lbXB0eVxuICAoKiBTZXF1ZW5jZXMgb2YgYWN0aW9ucyB3YWl0aW5nIGZvciBmaWxlIGRlc2NyaXB0b3JzIHRvIGJlY29tZVxuICAgICB3cml0YWJsZS4gKilcblxuICBtZXRob2QgcHJpdmF0ZSBjbGVhbnVwID0gKClcblxuICBtZXRob2QgcHJpdmF0ZSByZWdpc3Rlcl90aW1lciBkZWxheSByZXBlYXQgZiA9XG4gICAgaWYgcmVwZWF0IHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWMgc2xlZXBlciA9IHsgdGltZSA9IFVuaXguZ2V0dGltZW9mZGF5ICgpICsuIGRlbGF5OyBzdG9wcGVkID0gZmFsc2U7IGFjdGlvbiA9IGcgfVxuICAgICAgYW5kIGcgKCkgPVxuICAgICAgICBzbGVlcGVyLnRpbWUgPC0gVW5peC5nZXR0aW1lb2ZkYXkgKCkgKy4gZGVsYXk7XG4gICAgICAgIG5ld19zbGVlcHMgPC0gc2xlZXBlciA6OiBuZXdfc2xlZXBzO1xuICAgICAgICBmICgpXG4gICAgICBpblxuICAgICAgbmV3X3NsZWVwcyA8LSBzbGVlcGVyIDo6IG5ld19zbGVlcHM7XG4gICAgICBsYXp5KHNsZWVwZXIuc3RvcHBlZCA8LSB0cnVlKVxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBsZXQgc2xlZXBlciA9IHsgdGltZSA9IFVuaXguZ2V0dGltZW9mZGF5ICgpICsuIGRlbGF5OyBzdG9wcGVkID0gZmFsc2U7IGFjdGlvbiA9IGYgfSBpblxuICAgICAgbmV3X3NsZWVwcyA8LSBzbGVlcGVyIDo6IG5ld19zbGVlcHM7XG4gICAgICBsYXp5KHNsZWVwZXIuc3RvcHBlZCA8LSB0cnVlKVxuICAgIGVuZFxuXG4gIG1ldGhvZCBwcml2YXRlIHJlZ2lzdGVyX3JlYWRhYmxlIGZkIGYgPVxuICAgIGxldCBhY3Rpb25zID1cbiAgICAgIHRyeVxuICAgICAgICBGZF9tYXAuZmluZCBmZCB3YWl0X3JlYWRhYmxlXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgYWN0aW9ucyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCkgaW5cbiAgICAgICAgd2FpdF9yZWFkYWJsZSA8LSBGZF9tYXAuYWRkIGZkIGFjdGlvbnMgd2FpdF9yZWFkYWJsZTtcbiAgICAgICAgYWN0aW9uc1xuICAgIGluXG4gICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX2wgZiBhY3Rpb25zIGluXG4gICAgbGF6eShMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGU7XG4gICAgICAgICBpZiBMd3Rfc2VxdWVuY2UuaXNfZW1wdHkgYWN0aW9ucyB0aGVuIHdhaXRfcmVhZGFibGUgPC0gRmRfbWFwLnJlbW92ZSBmZCB3YWl0X3JlYWRhYmxlKVxuXG4gIG1ldGhvZCBwcml2YXRlIHJlZ2lzdGVyX3dyaXRhYmxlIGZkIGYgPVxuICAgIGxldCBhY3Rpb25zID1cbiAgICAgIHRyeVxuICAgICAgICBGZF9tYXAuZmluZCBmZCB3YWl0X3dyaXRhYmxlXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgYWN0aW9ucyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCkgaW5cbiAgICAgICAgd2FpdF93cml0YWJsZSA8LSBGZF9tYXAuYWRkIGZkIGFjdGlvbnMgd2FpdF93cml0YWJsZTtcbiAgICAgICAgYWN0aW9uc1xuICAgIGluXG4gICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX2wgZiBhY3Rpb25zIGluXG4gICAgbGF6eShMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGU7XG4gICAgICAgICBpZiBMd3Rfc2VxdWVuY2UuaXNfZW1wdHkgYWN0aW9ucyB0aGVuIHdhaXRfd3JpdGFibGUgPC0gRmRfbWFwLnJlbW92ZSBmZCB3YWl0X3dyaXRhYmxlKVxuZW5kXG5cbmNsYXNzIHZpcnR1YWwgc2VsZWN0X2Jhc2VkID0gb2JqZWN0KHNlbGYpXG4gIGluaGVyaXQgc2VsZWN0X29yX3BvbGxfYmFzZWRcblxuICBtZXRob2QgcHJpdmF0ZSB2aXJ0dWFsIHNlbGVjdCA6IFVuaXguZmlsZV9kZXNjciBsaXN0IC0+IFVuaXguZmlsZV9kZXNjciBsaXN0IC0+IGZsb2F0IC0+IFVuaXguZmlsZV9kZXNjciBsaXN0ICogVW5peC5maWxlX2Rlc2NyIGxpc3RcblxuICBtZXRob2QgaXRlciBibG9jayA9XG4gICAgKCogVHJhbnNmZXIgYWxsIHNsZWVwZXJzIGFkZGVkIHNpbmNlIHRoZSBsYXN0IGl0ZXJhdGlvbiB0byB0aGVcbiAgICAgICBtYWluIHNsZWVwIHF1ZXVlOiAqKVxuICAgIHNsZWVwX3F1ZXVlIDwtIExpc3QuZm9sZF9sZWZ0IChmdW4gcSBlIC0+IFNsZWVwX3F1ZXVlLmFkZCBlIHEpIHNsZWVwX3F1ZXVlIG5ld19zbGVlcHM7XG4gICAgbmV3X3NsZWVwcyA8LSBbXTtcbiAgICAoKiBDb2xsZWN0IGZpbGUgZGVzY3JpcHRvcnMuICopXG4gICAgbGV0IGZkc19yID0gRmRfbWFwLmZvbGQgKGZ1biBmZCBfIGwgLT4gZmQgOjogbCkgd2FpdF9yZWFkYWJsZSBbXSBpblxuICAgIGxldCBmZHNfdyA9IEZkX21hcC5mb2xkIChmdW4gZmQgXyBsIC0+IGZkIDo6IGwpIHdhaXRfd3JpdGFibGUgW10gaW5cbiAgICAoKiBDb21wdXRlIHRoZSB0aW1lb3V0LiAqKVxuICAgIGxldCB0aW1lb3V0ID0gaWYgYmxvY2sgdGhlbiBnZXRfbmV4dF90aW1lb3V0IHNsZWVwX3F1ZXVlIGVsc2UgMC4gaW5cbiAgICAoKiBEbyB0aGUgYmxvY2tpbmcgY2FsbCAqKVxuICAgIGxldCBmZHNfciwgZmRzX3cgPVxuICAgICAgdHJ5XG4gICAgICAgIHNlbGYjc2VsZWN0IGZkc19yIGZkc193IHRpbWVvdXRcbiAgICAgIHdpdGhcbiAgICAgIHwgVW5peC5Vbml4X2Vycm9yIChVbml4LkVJTlRSLCBfLCBfKSAtPlxuICAgICAgICAoW10sIFtdKVxuICAgICAgfCBVbml4LlVuaXhfZXJyb3IgKFVuaXguRUJBREYsIF8sIF8pIC0+XG4gICAgICAgICgqIEtlZXBzIG9ubHkgYmFkIGZpbGUgZGVzY3JpcHRvcnMuIEFjdGlvbnMgcmVnaXN0ZXJlZCBvblxuICAgICAgICAgICB0aGVtIGhhdmUgdG8gaGFuZGxlIHRoZSBlcnJvcjogKilcbiAgICAgICAgKExpc3QuZmlsdGVyIGJhZF9mZCBmZHNfcixcbiAgICAgICAgIExpc3QuZmlsdGVyIGJhZF9mZCBmZHNfdylcbiAgICBpblxuICAgICgqIFJlc3RhcnQgdGhyZWFkcyB3YWl0aW5nIGZvciBhIHRpbWVvdXQ6ICopXG4gICAgc2xlZXBfcXVldWUgPC0gcmVzdGFydF9hY3Rpb25zIHNsZWVwX3F1ZXVlIChVbml4LmdldHRpbWVvZmRheSAoKSk7XG4gICAgKCogUmVzdGFydCB0aHJlYWRzIHdhaXRpbmcgb24gYSBmaWxlIGRlc2NyaXB0b3JzOiAqKVxuICAgIExpc3QuaXRlciAoZnVuIGZkIC0+IGludm9rZV9hY3Rpb25zIGZkIHdhaXRfcmVhZGFibGUpIGZkc19yO1xuICAgIExpc3QuaXRlciAoZnVuIGZkIC0+IGludm9rZV9hY3Rpb25zIGZkIHdhaXRfd3JpdGFibGUpIGZkc193XG5lbmRcblxuY2xhc3MgdmlydHVhbCBwb2xsX2Jhc2VkID0gb2JqZWN0KHNlbGYpXG4gIGluaGVyaXQgc2VsZWN0X29yX3BvbGxfYmFzZWRcblxuICBtZXRob2QgcHJpdmF0ZSB2aXJ0dWFsIHBvbGwgOiAoVW5peC5maWxlX2Rlc2NyICogYm9vbCAqIGJvb2wpIGxpc3QgLT4gZmxvYXQgLT4gKFVuaXguZmlsZV9kZXNjciAqIGJvb2wgKiBib29sKSBsaXN0XG5cbiAgbWV0aG9kIGl0ZXIgYmxvY2sgPVxuICAgICgqIFRyYW5zZmVyIGFsbCBzbGVlcGVycyBhZGRlZCBzaW5jZSB0aGUgbGFzdCBpdGVyYXRpb24gdG8gdGhlXG4gICAgICAgbWFpbiBzbGVlcCBxdWV1ZTogKilcbiAgICBzbGVlcF9xdWV1ZSA8LSBMaXN0LmZvbGRfbGVmdCAoZnVuIHEgZSAtPiBTbGVlcF9xdWV1ZS5hZGQgZSBxKSBzbGVlcF9xdWV1ZSBuZXdfc2xlZXBzO1xuICAgIG5ld19zbGVlcHMgPC0gW107XG4gICAgKCogQ29sbGVjdCBmaWxlIGRlc2NyaXB0b3JzLiAqKVxuICAgIGxldCBmZHMgPSBbXSBpblxuICAgIGxldCBmZHMgPSBGZF9tYXAuZm9sZCAoZnVuIGZkIF8gbCAtPiAoZmQsIHRydWUsIGZhbHNlKSA6OiBsKSB3YWl0X3JlYWRhYmxlIGZkcyBpblxuICAgIGxldCBmZHMgPSBGZF9tYXAuZm9sZCAoZnVuIGZkIF8gbCAtPiAoZmQsIGZhbHNlLCB0cnVlKSA6OiBsKSB3YWl0X3dyaXRhYmxlIGZkcyBpblxuICAgICgqIENvbXB1dGUgdGhlIHRpbWVvdXQuICopXG4gICAgbGV0IHRpbWVvdXQgPSBpZiBibG9jayB0aGVuIGdldF9uZXh0X3RpbWVvdXQgc2xlZXBfcXVldWUgZWxzZSAwLiBpblxuICAgICgqIERvIHRoZSBibG9ja2luZyBjYWxsICopXG4gICAgbGV0IGZkcyA9XG4gICAgICB0cnlcbiAgICAgICAgc2VsZiNwb2xsIGZkcyB0aW1lb3V0XG4gICAgICB3aXRoXG4gICAgICB8IFVuaXguVW5peF9lcnJvciAoVW5peC5FSU5UUiwgXywgXykgLT5cbiAgICAgICAgW11cbiAgICAgIHwgVW5peC5Vbml4X2Vycm9yIChVbml4LkVCQURGLCBfLCBfKSAtPlxuICAgICAgICAoKiBLZWVwcyBvbmx5IGJhZCBmaWxlIGRlc2NyaXB0b3JzLiBBY3Rpb25zIHJlZ2lzdGVyZWQgb25cbiAgICAgICAgICAgdGhlbSBoYXZlIHRvIGhhbmRsZSB0aGUgZXJyb3I6ICopXG4gICAgICAgIExpc3QuZmlsdGVyIChmdW4gKGZkLCBfLCBfKSAtPiBiYWRfZmQgZmQpIGZkc1xuICAgIGluXG4gICAgKCogUmVzdGFydCB0aHJlYWRzIHdhaXRpbmcgZm9yIGEgdGltZW91dDogKilcbiAgICBzbGVlcF9xdWV1ZSA8LSByZXN0YXJ0X2FjdGlvbnMgc2xlZXBfcXVldWUgKFVuaXguZ2V0dGltZW9mZGF5ICgpKTtcbiAgICAoKiBSZXN0YXJ0IHRocmVhZHMgd2FpdGluZyBvbiBhIGZpbGUgZGVzY3JpcHRvcnM6ICopXG4gICAgTGlzdC5pdGVyXG4gICAgICAoZnVuIChmZCwgcmVhZGFibGUsIHdyaXRhYmxlKSAtPlxuICAgICAgICAgaWYgcmVhZGFibGUgdGhlbiBpbnZva2VfYWN0aW9ucyBmZCB3YWl0X3JlYWRhYmxlO1xuICAgICAgICAgaWYgd3JpdGFibGUgdGhlbiBpbnZva2VfYWN0aW9ucyBmZCB3YWl0X3dyaXRhYmxlKVxuICAgICAgZmRzXG5lbmRcblxuY2xhc3Mgc2VsZWN0ID0gb2JqZWN0XG4gIGluaGVyaXQgc2VsZWN0X2Jhc2VkXG5cbiAgbWV0aG9kIHByaXZhdGUgc2VsZWN0IGZkc19yIGZkc193IHRpbWVvdXQgPVxuICAgIGxldCBmZHNfciwgZmRzX3csIF8gPSBVbml4LnNlbGVjdCBmZHNfciBmZHNfdyBbXSB0aW1lb3V0IGluXG4gICAgKGZkc19yLCBmZHNfdylcbmVuZFxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IFRoZSBjdXJyZW50IGVuZ2luZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBjdXJyZW50ID1cbiAgaWYgTHd0X2NvbmZpZy5fSEFWRV9MSUJFViAmJiBMd3RfY29uZmlnLmxpYmV2X2RlZmF1bHQgdGhlblxuICAgIHJlZiAobmV3IGxpYmV2ICgpIDo+IHQpXG4gIGVsc2VcbiAgICByZWYgKG5ldyBzZWxlY3QgOj4gdClcblxubGV0IGdldCAoKSA9XG4gICFjdXJyZW50XG5cbmxldCBzZXQgPyh0cmFuc2Zlcj10cnVlKSA/KGRlc3Ryb3k9dHJ1ZSkgZW5naW5lID1cbiAgaWYgdHJhbnNmZXIgdGhlbiAhY3VycmVudCN0cmFuc2ZlciAoZW5naW5lIDogI3QgOj4gYWJzdHJhY3QpO1xuICBpZiBkZXN0cm95IHRoZW4gIWN1cnJlbnQjZGVzdHJveTtcbiAgY3VycmVudCA6PSAoZW5naW5lIDogI3QgOj4gdClcblxubGV0IGl0ZXIgYmxvY2sgPSAhY3VycmVudCNpdGVyIGJsb2NrXG5sZXQgb25fcmVhZGFibGUgZmQgZiA9ICFjdXJyZW50I29uX3JlYWRhYmxlIGZkIGZcbmxldCBvbl93cml0YWJsZSBmZCBmID0gIWN1cnJlbnQjb25fd3JpdGFibGUgZmQgZlxubGV0IG9uX3RpbWVyIGRlbGF5IHJlcGVhdCBmID0gIWN1cnJlbnQjb25fdGltZXIgZGVsYXkgcmVwZWF0IGZcbmxldCBmYWtlX2lvIGZkID0gIWN1cnJlbnQjZmFrZV9pbyBmZFxubGV0IHJlYWRhYmxlX2NvdW50ICgpID0gIWN1cnJlbnQjcmVhZGFibGVfY291bnRcbmxldCB3cml0YWJsZV9jb3VudCAoKSA9ICFjdXJyZW50I3dyaXRhYmxlX2NvdW50XG5sZXQgdGltZXJfY291bnQgKCkgPSAhY3VycmVudCN0aW1lcl9jb3VudFxubGV0IGZvcmsgKCkgPSAhY3VycmVudCNmb3JrXG5sZXQgZm9yd2FyZHNfc2lnbmFsIG4gPSAhY3VycmVudCNmb3J3YXJkc19zaWduYWwgblxuXG5tb2R1bGUgVmVyc2lvbmVkID1cbnN0cnVjdFxuICBjbGFzcyBsaWJldl8xID0gbGliZXZfZGVwcmVjYXRlZFxuICBjbGFzcyBsaWJldl8yID0gbGliZXZcbmVuZFxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG4oKiBbTHd0X3NlcXVlbmNlXSBpcyBkZXByZWNhdGVkIOKAkyB3ZSBkb24ndCB3YW50IHVzZXJzIG91dHNpZGUgTHd0IHVzaW5nIGl0LlxuICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgdXNlZCBpbnRlcm5hbGx5IGJ5IEx3dC4gU28sIGJyaWVmbHkgZGlzYWJsZSB3YXJuaW5nIDNcbiAgIChcImRlcHJlY2F0ZWRcIiksIGFuZCBjcmVhdGUgYSBsb2NhbCwgbm9uLWRlcHJlY2F0ZWQgYWxpYXMgZm9yXG4gICBbTHd0X3NlcXVlbmNlXSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBieSB0aGUgcmVzdCBvZiB0aGUgY29kZSBpbiB0aGlzXG4gICBtb2R1bGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFueSBtb3JlIHdhcm5pbmdzLiAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubW9kdWxlIEx3dF9zZXF1ZW5jZSA9IEx3dF9zZXF1ZW5jZVxuW0BAQG9jYW1sLndhcm5pbmcgXCIrM1wiXVxuXG5vcGVuIEx3dC5JbmZpeFxuXG5sZXQgZW50ZXJfaXRlcl9ob29rcyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKClcbmxldCBsZWF2ZV9pdGVyX2hvb2tzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKVxuXG5sZXQgeWllbGQgPSBMd3QucGF1c2VcblxubGV0IGFiYW5kb25feWllbGRlZF9hbmRfcGF1c2VkICgpID1cbiAgTHd0LmFiYW5kb25fcGF1c2VkICgpXG5cbmxldCBydW4gcCA9XG4gIGxldCByZWMgcnVuX2xvb3AgKCkgPVxuICAgIG1hdGNoIEx3dC5wb2xsIHAgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICB4XG4gICAgfCBOb25lIC0+XG4gICAgICAoKiBDYWxsIGVudGVyIGhvb2tzLiAqKVxuICAgICAgTHd0X3NlcXVlbmNlLml0ZXJfbCAoZnVuIGYgLT4gZiAoKSkgZW50ZXJfaXRlcl9ob29rcztcblxuICAgICAgKCogRG8gdGhlIG1haW4gbG9vcCBjYWxsLiAqKVxuICAgICAgbGV0IHNob3VsZF9ibG9ja193YWl0aW5nX2Zvcl9pbyA9IEx3dC5wYXVzZWRfY291bnQgKCkgPSAwIGluXG4gICAgICBMd3RfZW5naW5lLml0ZXIgc2hvdWxkX2Jsb2NrX3dhaXRpbmdfZm9yX2lvO1xuXG4gICAgICAoKiBGdWxmaWxsIHBhdXNlZCBwcm9taXNlcy4gKilcbiAgICAgIEx3dC53YWtldXBfcGF1c2VkICgpO1xuXG4gICAgICAoKiBDYWxsIGxlYXZlIGhvb2tzLiAqKVxuICAgICAgTHd0X3NlcXVlbmNlLml0ZXJfbCAoZnVuIGYgLT4gZiAoKSkgbGVhdmVfaXRlcl9ob29rcztcblxuICAgICAgKCogUmVwZWF0LiAqKVxuICAgICAgcnVuX2xvb3AgKClcbiAgaW5cblxuICBydW5fbG9vcCAoKVxuXG5sZXQgcnVuX2FscmVhZHlfY2FsbGVkID0gcmVmIGBOb1xubGV0IHJ1bl9hbHJlYWR5X2NhbGxlZF9tdXRleCA9IE11dGV4LmNyZWF0ZSAoKVxuXG5sZXQgZmluaXNoZWQgKCkgPVxuICBNdXRleC5sb2NrIHJ1bl9hbHJlYWR5X2NhbGxlZF9tdXRleDtcbiAgcnVuX2FscmVhZHlfY2FsbGVkIDo9IGBObztcbiAgTXV0ZXgudW5sb2NrIHJ1bl9hbHJlYWR5X2NhbGxlZF9tdXRleFxuXG5sZXQgcnVuIHAgPVxuICAoKiBGYWlsIGluIGNhc2UgYSBjYWxsIHRvIEx3dF9tYWluLnJ1biBpcyBuZXN0ZWQgdW5kZXIgYW5vdGhlciBpbnZvY2F0aW9uIG9mXG4gICAgIEx3dF9tYWluLnJ1bi4gKilcbiAgTXV0ZXgubG9jayBydW5fYWxyZWFkeV9jYWxsZWRfbXV0ZXg7XG5cbiAgbGV0IGVycm9yX21lc3NhZ2VfaWZfY2FsbF9pc19uZXN0ZWQgPVxuICAgIG1hdGNoICFydW5fYWxyZWFkeV9jYWxsZWQgd2l0aFxuICAgICgqIGBGcm9tIGlzIGVmZmVjdGl2ZWx5IGRpc2FibGVkIGZvciB0aGUgdGltZSBiZWluZywgYmVjYXVzZSB0aGVyZSBpcyBhIGJ1ZyxcbiAgICAgICBwcmVzZW50IGluIGFsbCB2ZXJzaW9ucyBvZiBPQ2FtbCBzdXBwb3J0ZWQgYnkgTHd0LCB3aGVyZSwgd2l0aCB0aGVcbiAgICAgICBieXRlY29kZSBydW50aW1lLCBpZiBvbmUgY2hhbmdlcyB0aGUgd29ya2luZyBkaXJlY3RvcnkgYW5kIHRoZW4gYXR0ZW1wdHNcbiAgICAgICB0byByZXRyaWV2ZSB0aGUgYmFja3RyYWNlLCB0aGUgcnVudGltZSBjYWxscyBbYWJvcnRdIGF0IHRoZSBDIGxldmVsIGFuZFxuICAgICAgIGV4aXRzIHRoZSBwcm9ncmFtIHVuZ3JhY2VmdWxseS4gSXQgaXMgZXNwZWNpYWxseSBsaWtlbHkgdGhhdCBhIGRhZW1vblxuICAgICAgIHdvdWxkIGNoYW5nZSBkaXJlY3RvcnkgYmVmb3JlIGNhbGxpbmcgW0x3dF9tYWluLnJ1bl0sIHNvIHdlIGNhbid0IGhhdmUgaXRcbiAgICAgICByZXRyaWV2aW5nIHRoZSBiYWNrdHJhY2UsIGV2ZW4gdGhvdWdoIGEgZGFlbW9uIGlzIG5vdCBsaWtlbHkgdG8gYmVcbiAgICAgICBjb21waWxlZCB0byBieXRlY29kZS5cblxuICAgICAgIFRoaXMgY2FuIGJlIGFkZHJlc3NlZCB3aXRoIGRldGVjdGlvbi4gU3RhcnRpbmcgd2l0aCA0LjA0LCB0aGVyZSBpcyBhXG4gICAgICAgdHlwZSBbU3lzLmJhY2tlbmRfdHlwZV0gdGhhdCBjb3VsZCBiZSB1c2VkLiAqKVxuICAgIHwgYEZyb20gYmFja3RyYWNlX3N0cmluZyAtPlxuICAgICAgU29tZSAoUHJpbnRmLnNwcmludGYgXCIlc1xcbiVzXFxuJXNcIlxuICAgICAgICBcIk5lc3RlZCBjYWxscyB0byBMd3RfbWFpbi5ydW4gYXJlIG5vdCBhbGxvd2VkXCJcbiAgICAgICAgXCJMd3RfbWFpbi5ydW4gYWxyZWFkeSBjYWxsZWQgZnJvbTpcIlxuICAgICAgICBiYWNrdHJhY2Vfc3RyaW5nKVxuICAgIHwgYEZyb21fc29tZXdoZXJlIC0+XG4gICAgICBTb21lIChcIk5lc3RlZCBjYWxscyB0byBMd3RfbWFpbi5ydW4gYXJlIG5vdCBhbGxvd2VkXCIpXG4gICAgfCBgTm8gLT5cbiAgICAgIGxldCBjYWxsZWRfZnJvbSA9XG4gICAgICAgICgqIFNlZSBjb21tZW50IGFib3ZlLlxuICAgICAgICBpZiBQcmludGV4Yy5iYWNrdHJhY2Vfc3RhdHVzICgpIHRoZW5cbiAgICAgICAgICBsZXQgYmFja3RyYWNlID1cbiAgICAgICAgICAgIHRyeSByYWlzZSBFeGl0XG4gICAgICAgICAgICB3aXRoIEV4aXQgLT4gUHJpbnRleGMuZ2V0X2JhY2t0cmFjZSAoKVxuICAgICAgICAgIGluXG4gICAgICAgICAgYEZyb20gYmFja3RyYWNlXG4gICAgICAgIGVsc2UgKilcbiAgICAgICAgICBgRnJvbV9zb21ld2hlcmVcbiAgICAgIGluXG4gICAgICBydW5fYWxyZWFkeV9jYWxsZWQgOj0gY2FsbGVkX2Zyb207XG4gICAgICBOb25lXG4gIGluXG5cbiAgTXV0ZXgudW5sb2NrIHJ1bl9hbHJlYWR5X2NhbGxlZF9tdXRleDtcblxuICBiZWdpbiBtYXRjaCBlcnJvcl9tZXNzYWdlX2lmX2NhbGxfaXNfbmVzdGVkIHdpdGhcbiAgfCBTb21lIG1lc3NhZ2UgLT4gZmFpbHdpdGggbWVzc2FnZVxuICB8IE5vbmUgLT4gKClcbiAgZW5kO1xuXG4gIG1hdGNoIHJ1biBwIHdpdGhcbiAgfCByZXN1bHQgLT5cbiAgICBmaW5pc2hlZCAoKTtcbiAgICByZXN1bHRcbiAgfCBleGNlcHRpb24gZXhuIHdoZW4gTHd0LkV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgIGZpbmlzaGVkICgpO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgZXhpdF9ob29rcyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKClcblxubGV0IHJlYyBjYWxsX2hvb2tzICgpID1cbiAgbWF0Y2ggTHd0X3NlcXVlbmNlLnRha2Vfb3B0X2wgZXhpdF9ob29rcyB3aXRoXG4gIHwgTm9uZSAtPlxuICAgIEx3dC5yZXR1cm5fdW5pdFxuICB8IFNvbWUgZiAtPlxuICAgIEx3dC5jYXRjaFxuICAgICAgKGZ1biAoKSAtPiBmICgpKVxuICAgICAgKGZ1biBfICAtPiBMd3QucmV0dXJuX3VuaXQpID4+PSBmdW4gKCkgLT5cbiAgICBjYWxsX2hvb2tzICgpXG5cbmxldCAoKSA9XG4gIGF0X2V4aXQgKGZ1biAoKSAtPlxuICAgIGlmIG5vdCAoTHd0X3NlcXVlbmNlLmlzX2VtcHR5IGV4aXRfaG9va3MpIHRoZW4gYmVnaW5cbiAgICAgIEx3dC5hYmFuZG9uX3dha2V1cHMgKCk7XG4gICAgICBmaW5pc2hlZCAoKTtcbiAgICAgIHJ1biAoY2FsbF9ob29rcyAoKSlcbiAgICBlbmQpXG5cbmxldCBhdF9leGl0IGYgPSBpZ25vcmUgKEx3dF9zZXF1ZW5jZS5hZGRfbCBmIGV4aXRfaG9va3MpXG5cbm1vZHVsZSB0eXBlIEhvb2tzID1cbnNpZ1xuICB0eXBlICdyZXR1cm5fdmFsdWUga2luZFxuICB0eXBlIGhvb2tcblxuICB2YWwgYWRkX2ZpcnN0IDogKHVuaXQgLT4gdW5pdCBraW5kKSAtPiBob29rXG4gIHZhbCBhZGRfbGFzdCA6ICh1bml0IC0+IHVuaXQga2luZCkgLT4gaG9va1xuICB2YWwgcmVtb3ZlIDogaG9vayAtPiB1bml0XG4gIHZhbCByZW1vdmVfYWxsIDogdW5pdCAtPiB1bml0XG5lbmRcblxubW9kdWxlIHR5cGUgSG9va19zZXF1ZW5jZSA9XG5zaWdcbiAgdHlwZSAncmV0dXJuX3ZhbHVlIGtpbmRcbiAgdmFsIHNlcXVlbmNlIDogKHVuaXQgLT4gdW5pdCBraW5kKSBMd3Rfc2VxdWVuY2UudFxuZW5kXG5cbm1vZHVsZSBXcmFwX2hvb2tzIChTZXF1ZW5jZSA6IEhvb2tfc2VxdWVuY2UpID1cbnN0cnVjdFxuICB0eXBlICdhIGtpbmQgPSAnYSBTZXF1ZW5jZS5raW5kXG4gIHR5cGUgaG9vayA9ICh1bml0IC0+IHVuaXQgU2VxdWVuY2Uua2luZCkgTHd0X3NlcXVlbmNlLm5vZGVcblxuICBsZXQgYWRkX2ZpcnN0IGhvb2tfZm4gPVxuICAgIGxldCBob29rX25vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX2wgaG9va19mbiBTZXF1ZW5jZS5zZXF1ZW5jZSBpblxuICAgIGhvb2tfbm9kZVxuXG4gIGxldCBhZGRfbGFzdCBob29rX2ZuID1cbiAgICBsZXQgaG9va19ub2RlID0gTHd0X3NlcXVlbmNlLmFkZF9yIGhvb2tfZm4gU2VxdWVuY2Uuc2VxdWVuY2UgaW5cbiAgICBob29rX25vZGVcblxuICBsZXQgcmVtb3ZlIGhvb2tfbm9kZSA9XG4gICAgTHd0X3NlcXVlbmNlLnJlbW92ZSBob29rX25vZGVcblxuICBsZXQgcmVtb3ZlX2FsbCAoKSA9XG4gICAgTHd0X3NlcXVlbmNlLml0ZXJfbm9kZV9sIEx3dF9zZXF1ZW5jZS5yZW1vdmUgU2VxdWVuY2Uuc2VxdWVuY2VcbmVuZFxuXG5tb2R1bGUgRW50ZXJfaXRlcl9ob29rcyA9XG4gIFdyYXBfaG9va3MgKHN0cnVjdFxuICAgIHR5cGUgJ3JldHVybl92YWx1ZSBraW5kID0gJ3JldHVybl92YWx1ZVxuICAgIGxldCBzZXF1ZW5jZSA9IGVudGVyX2l0ZXJfaG9va3NcbiAgZW5kKVxuXG5tb2R1bGUgTGVhdmVfaXRlcl9ob29rcyA9XG4gIFdyYXBfaG9va3MgKHN0cnVjdFxuICAgIHR5cGUgJ3JldHVybl92YWx1ZSBraW5kID0gJ3JldHVybl92YWx1ZVxuICAgIGxldCBzZXF1ZW5jZSA9IGxlYXZlX2l0ZXJfaG9va3NcbiAgZW5kKVxuXG5tb2R1bGUgRXhpdF9ob29rcyA9XG4gIFdyYXBfaG9va3MgKHN0cnVjdFxuICAgIHR5cGUgJ3JldHVybl92YWx1ZSBraW5kID0gJ3JldHVybl92YWx1ZSBMd3QudFxuICAgIGxldCBzZXF1ZW5jZSA9IGV4aXRfaG9va3NcbiAgZW5kKVxuIiwiIyAxIFwic3JjL3VuaXgvbHd0X3VuaXguY3Bwby5tbFwiXG4oKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbm9wZW4gTHd0LkluZml4XG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgQ29uZmlndXJhdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxudHlwZSBhc3luY19tZXRob2QgPVxuICB8IEFzeW5jX25vbmVcbiAgfCBBc3luY19kZXRhY2hcbiAgfCBBc3luY19zd2l0Y2hcblxubGV0IGRlZmF1bHRfYXN5bmNfbWV0aG9kX3ZhciA9IHJlZiBBc3luY19kZXRhY2hcblxubGV0ICgpID1cbiAgdHJ5XG4gICAgbWF0Y2ggU3lzLmdldGVudiBcIkxXVF9BU1lOQ19NRVRIT0RcIiB3aXRoXG4gICAgfCBcIm5vbmVcIiAtPlxuICAgICAgZGVmYXVsdF9hc3luY19tZXRob2RfdmFyIDo9IEFzeW5jX25vbmVcbiAgICB8IFwiZGV0YWNoXCIgLT5cbiAgICAgIGRlZmF1bHRfYXN5bmNfbWV0aG9kX3ZhciA6PSBBc3luY19kZXRhY2hcbiAgICB8IFwic3dpdGNoXCIgLT5cbiAgICAgIGRlZmF1bHRfYXN5bmNfbWV0aG9kX3ZhciA6PSBBc3luY19zd2l0Y2hcbiAgICB8IHN0ciAtPlxuICAgICAgUHJpbnRmLmVwcmludGZcbiAgICAgICAgXCIlczogaW52YWxpZCBsd3QgYXN5bmMgbWV0aG9kOiAnJXMnLCBtdXN0IGJlICdub25lJywgJ2RldGFjaCcgb3IgJ3N3aXRjaCdcXG4lIVwiXG4gICAgICAgIChGaWxlbmFtZS5iYXNlbmFtZSBTeXMuZXhlY3V0YWJsZV9uYW1lKSBzdHJcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAoKVxuXG5sZXQgZGVmYXVsdF9hc3luY19tZXRob2QgKCkgPSAhZGVmYXVsdF9hc3luY19tZXRob2RfdmFyXG5sZXQgc2V0X2RlZmF1bHRfYXN5bmNfbWV0aG9kIGFtID0gZGVmYXVsdF9hc3luY19tZXRob2RfdmFyIDo9IGFtXG5cbmxldCBhc3luY19tZXRob2Rfa2V5ID0gTHd0Lm5ld19rZXkgKClcblxubGV0IGFzeW5jX21ldGhvZCAoKSA9XG4gIG1hdGNoIEx3dC5nZXQgYXN5bmNfbWV0aG9kX2tleSB3aXRoXG4gIHwgU29tZSBhbSAtPiBhbVxuICB8IE5vbmUgLT4gIWRlZmF1bHRfYXN5bmNfbWV0aG9kX3ZhclxuXG5sZXQgd2l0aF9hc3luY19ub25lIGYgPVxuICBMd3Qud2l0aF92YWx1ZSBhc3luY19tZXRob2Rfa2V5IChTb21lIEFzeW5jX25vbmUpIGZcblxubGV0IHdpdGhfYXN5bmNfZGV0YWNoIGYgPVxuICBMd3Qud2l0aF92YWx1ZSBhc3luY19tZXRob2Rfa2V5IChTb21lIEFzeW5jX2RldGFjaCkgZlxuXG5sZXQgd2l0aF9hc3luY19zd2l0Y2ggZiA9XG4gIEx3dC53aXRoX3ZhbHVlIGFzeW5jX21ldGhvZF9rZXkgKFNvbWUgQXN5bmNfc3dpdGNoKSBmXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgTm90aWZpY2F0aW9ucyBtYW5hZ2VtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxuKCogSW5mb3JtYXRpb25zIGFib3V0IGEgbm90aWZpZXIgKilcbnR5cGUgbm90aWZpZXIgPSB7XG4gIG5vdGlmeV9oYW5kbGVyIDogdW5pdCAtPiB1bml0O1xuICAoKiBUaGUgY2FsbGJhY2sgKilcblxuICBub3RpZnlfb25jZSA6IGJvb2w7XG4gICgqIFdoZXRoZXIgdG8gcmVtb3ZlIHRoZSBub3RpZmllciBhZnRlciB0aGUgcmVjZXB0aW9uIG9mIHRoZSBmaXJzdFxuICAgICBub3RpZmljYXRpb24gKilcbn1cblxubW9kdWxlIE5vdGlmaWVycyA9IEhhc2h0YmwuTWFrZShzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnRcbiAgICBsZXQgZXF1YWwgKHggOiBpbnQpICh5IDogaW50KSA9IHggPSB5XG4gICAgbGV0IGhhc2ggKHggOiBpbnQpID0geFxuICBlbmQpXG5cbmxldCBub3RpZmllcnMgPSBOb3RpZmllcnMuY3JlYXRlIDEwMjRcblxuKCogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9pc3N1ZXMvMjc3IGFuZFxuICAgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L3B1bGwvMjc4LiAqKVxubGV0IGN1cnJlbnRfbm90aWZpY2F0aW9uX2lkID0gcmVmICgweDdGRkZGRkZGIC0gMTAwMClcblxubGV0IHJlYyBmaW5kX2ZyZWVfaWQgaWQgPVxuICBpZiBOb3RpZmllcnMubWVtIG5vdGlmaWVycyBpZCB0aGVuXG4gICAgZmluZF9mcmVlX2lkIChpZCArIDEpXG4gIGVsc2VcbiAgICBpZFxuXG5sZXQgbWFrZV9ub3RpZmljYXRpb24gPyhvbmNlPWZhbHNlKSBmID1cbiAgbGV0IGlkID0gZmluZF9mcmVlX2lkICghY3VycmVudF9ub3RpZmljYXRpb25faWQgKyAxKSBpblxuICBjdXJyZW50X25vdGlmaWNhdGlvbl9pZCA6PSBpZDtcbiAgTm90aWZpZXJzLmFkZCBub3RpZmllcnMgaWQgeyBub3RpZnlfb25jZSA9IG9uY2U7IG5vdGlmeV9oYW5kbGVyID0gZiB9O1xuICBpZFxuXG5sZXQgc3RvcF9ub3RpZmljYXRpb24gaWQgPVxuICBOb3RpZmllcnMucmVtb3ZlIG5vdGlmaWVycyBpZFxuXG5sZXQgc2V0X25vdGlmaWNhdGlvbiBpZCBmID1cbiAgbGV0IG5vdGlmaWVyID0gTm90aWZpZXJzLmZpbmQgbm90aWZpZXJzIGlkIGluXG4gIE5vdGlmaWVycy5yZXBsYWNlIG5vdGlmaWVycyBpZCB7IG5vdGlmaWVyIHdpdGggbm90aWZ5X2hhbmRsZXIgPSBmIH1cblxubGV0IGNhbGxfbm90aWZpY2F0aW9uIGlkID1cbiAgbWF0Y2ggTm90aWZpZXJzLmZpbmQgbm90aWZpZXJzIGlkIHdpdGhcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+ICgpXG4gIHwgbm90aWZpZXIgLT5cbiAgICBpZiBub3RpZmllci5ub3RpZnlfb25jZSB0aGVuXG4gICAgICBzdG9wX25vdGlmaWNhdGlvbiBpZDtcbiAgICBub3RpZmllci5ub3RpZnlfaGFuZGxlciAoKVxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IFNsZWVwZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBzbGVlcCBkZWxheSA9XG4gIGxldCB3YWl0ZXIsIHdha2VuZXIgPSBMd3QudGFzayAoKSBpblxuICBsZXQgZXYgPSBMd3RfZW5naW5lLm9uX3RpbWVyIGRlbGF5IGZhbHNlIChmdW4gZXYgLT4gTHd0X2VuZ2luZS5zdG9wX2V2ZW50IGV2OyBMd3Qud2FrZXVwIHdha2VuZXIgKCkpIGluXG4gIEx3dC5vbl9jYW5jZWwgd2FpdGVyIChmdW4gKCkgLT4gTHd0X2VuZ2luZS5zdG9wX2V2ZW50IGV2KTtcbiAgd2FpdGVyXG5cbmxldCB5aWVsZCA9IEx3dC5wYXVzZVxuXG5sZXQgYXV0b195aWVsZCB0aW1lb3V0ID1cbiAgbGV0IGxpbWl0ID0gcmVmIChVbml4LmdldHRpbWVvZmRheSAoKSArLiB0aW1lb3V0KSBpblxuICBmdW4gKCkgLT5cbiAgICBsZXQgY3VycmVudCA9IFVuaXguZ2V0dGltZW9mZGF5ICgpIGluXG4gICAgaWYgY3VycmVudCA+PSAhbGltaXQgdGhlbiBiZWdpblxuICAgICAgbGltaXQgOj0gY3VycmVudCArLiB0aW1lb3V0O1xuICAgICAgeWllbGQgKCk7XG4gICAgZW5kIGVsc2VcbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgYXV0b19wYXVzZSB0aW1lb3V0ID1cbiAgbGV0IGxpbWl0ID0gcmVmIChVbml4LmdldHRpbWVvZmRheSAoKSArLiB0aW1lb3V0KSBpblxuICBmdW4gKCkgLT5cbiAgICBsZXQgY3VycmVudCA9IFVuaXguZ2V0dGltZW9mZGF5ICgpIGluXG4gICAgaWYgY3VycmVudCA+PSAhbGltaXQgdGhlbiBiZWdpblxuICAgICAgbGltaXQgOj0gY3VycmVudCArLiB0aW1lb3V0O1xuICAgICAgTHd0LnBhdXNlICgpO1xuICAgIGVuZCBlbHNlXG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxuZXhjZXB0aW9uIFRpbWVvdXRcblxubGV0IHRpbWVvdXQgZCA9IHNsZWVwIGQgPj49IGZ1biAoKSAtPiByYWlzZSBUaW1lb3V0XG5cbmxldCB3aXRoX3RpbWVvdXQgZCBmID0gTHd0LnBpY2sgW3RpbWVvdXQgZDsgTHd0LmFwcGx5IGYgKCldXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgSm9icyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxudHlwZSAnYSBqb2JcblxuZXh0ZXJuYWwgc3RhcnRfam9iIDogJ2Egam9iIC0+IGFzeW5jX21ldGhvZCAtPiBib29sID0gXCJsd3RfdW5peF9zdGFydF9qb2JcIlxuKCogU3RhcnRzIHRoZSBnaXZlbiBqb2Igd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLiBJdCByZXR1cm5zIFt0cnVlXVxuICAgaWYgdGhlIGpvYiBpcyBhbHJlYWR5IHRlcm1pbmF0ZWQuICopXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmV4dGVybmFsIGNoZWNrX2pvYiA6ICdhIGpvYiAtPiBpbnQgLT4gYm9vbCA9IFwibHd0X3VuaXhfY2hlY2tfam9iXCIgXCJub2FsbG9jXCJcbigqIENoZWNrIHdoZXRoZXIgdGhhdCBhIGpvYiBoYXMgdGVybWluYXRlZCBvciBub3QuIElmIGl0IGhhcyBub3RcbiAgIHlldCB0ZXJtaW5hdGVkLCBpdCBpcyBtYXJrZWQgc28gaXQgd2lsbCBzZW5kIGEgbm90aWZpY2F0aW9uXG4gICB3aGVuIGl0IGZpbmlzaGVzLiAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCIrM1wiXVxuXG4oKiBGb3IgYWxsIHJ1bm5pbmcgam9iLCBhIHdhaXRlciBhbmQgYSBmdW5jdGlvbiB0byBhYm9ydCBpdC4gKilcbmxldCBqb2JzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKVxuXG5sZXQgcmVjIGFib3J0X2pvYnMgZXhuID1cbiAgbWF0Y2ggTHd0X3NlcXVlbmNlLnRha2Vfb3B0X2wgam9icyB3aXRoXG4gIHwgU29tZSAoXywgZikgLT4gZiBleG47IGFib3J0X2pvYnMgZXhuXG4gIHwgTm9uZSAtPiAoKVxuXG5sZXQgY2FuY2VsX2pvYnMgKCkgPSBhYm9ydF9qb2JzIEx3dC5DYW5jZWxlZFxuXG5sZXQgd2FpdF9mb3Jfam9icyAoKSA9XG4gIEx3dC5qb2luIChMd3Rfc2VxdWVuY2UuZm9sZF9sIChmdW4gKHcsIF8pIGwgLT4gdyA6OiBsKSBqb2JzIFtdKVxuXG5sZXQgd3JhcF9yZXN1bHQgZiB4ID1cbiAgdHJ5XG4gICAgUmVzdWx0Lk9rIChmIHgpXG4gIHdpdGggZXhuIHdoZW4gTHd0LkV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgIFJlc3VsdC5FcnJvciBleG5cblxubGV0IHJ1bl9qb2JfYXV4IGFzeW5jX21ldGhvZCBqb2IgcmVzdWx0ID1cbiAgKCogU3RhcnRzIHRoZSBqb2IuICopXG4gIGlmIHN0YXJ0X2pvYiBqb2IgYXN5bmNfbWV0aG9kIHRoZW5cbiAgICAoKiBUaGUgam9iIGhhcyBhbHJlYWR5IHRlcm1pbmF0ZWQsIHJlYWQgYW5kIHJldHVybiB0aGUgcmVzdWx0XG4gICAgICAgaW1tZWRpYXRlbHkuICopXG4gICAgTHd0Lm9mX3Jlc3VsdCAocmVzdWx0IGpvYilcbiAgZWxzZSBiZWdpblxuICAgICgqIFRocmVhZCBmb3IgdGhlIGpvYi4gKilcbiAgICBsZXQgd2FpdGVyLCB3YWtlbmVyID0gTHd0LndhaXQgKCkgaW5cbiAgICAoKiBBZGQgdGhlIGpvYiB0byB0aGUgc2VxdWVuY2Ugb2YgYWxsIGpvYnMuICopXG4gICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX2wgKFxuICAgICAgKHdhaXRlciA+Pj0gZnVuIF8gLT4gTHd0LnJldHVybl91bml0KSxcbiAgICAgIChmdW4gZXhuIC0+IGlmIEx3dC5zdGF0ZSB3YWl0ZXIgPSBMd3QuU2xlZXAgdGhlbiBMd3Qud2FrZXVwX2V4biB3YWtlbmVyIGV4bikpXG4gICAgICBqb2JzIGluXG4gICAgaWdub3JlIGJlZ2luXG4gICAgICAoKiBDcmVhdGUgdGhlIG5vdGlmaWNhdGlvbiBmb3IgYXN5bmNocm9ub3VzIHdha2V1cC4gKilcbiAgICAgIGxldCBpZCA9XG4gICAgICAgIG1ha2Vfbm90aWZpY2F0aW9uIH5vbmNlOnRydWVcbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgTHd0X3NlcXVlbmNlLnJlbW92ZSBub2RlO1xuICAgICAgICAgICAgIGxldCByZXN1bHQgPSByZXN1bHQgam9iIGluXG4gICAgICAgICAgICAgaWYgTHd0LnN0YXRlIHdhaXRlciA9IEx3dC5TbGVlcCB0aGVuIEx3dC53YWtldXBfcmVzdWx0IHdha2VuZXIgcmVzdWx0KVxuICAgICAgaW5cbiAgICAgICgqIEdpdmUgdGhlIGpvYiBzb21lIHRpbWUgYmVmb3JlIHdlIGZhbGxiYWNrIHRvIGFzeW5jaHJvbm91c1xuICAgICAgICAgbm90aWZpY2F0aW9uLiAqKVxuICAgICAgTHd0LnBhdXNlICgpID4+PSBmdW4gKCkgLT5cbiAgICAgICgqIFRoZSBqb2IgaGFzIHRlcm1pbmF0ZWQsIHNlbmQgdGhlIHJlc3VsdCBpbW1lZGlhdGVseS4gKilcbiAgICAgIGlmIGNoZWNrX2pvYiBqb2IgaWQgdGhlbiBjYWxsX25vdGlmaWNhdGlvbiBpZDtcbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIGVuZDtcbiAgICB3YWl0ZXJcbiAgZW5kXG5cbmxldCBjaG9vc2VfYXN5bmNfbWV0aG9kID0gZnVuY3Rpb25cbiAgfCBTb21lIGFzeW5jX21ldGhvZCAtPlxuICAgIGFzeW5jX21ldGhvZFxuICB8IE5vbmUgLT5cbiAgICBtYXRjaCBMd3QuZ2V0IGFzeW5jX21ldGhvZF9rZXkgd2l0aFxuICAgIHwgU29tZSBhbSAtPiBhbVxuICAgIHwgTm9uZSAtPiAhZGVmYXVsdF9hc3luY19tZXRob2RfdmFyXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTE2XCJdXG5sZXQgZXhlY3V0ZV9qb2IgP2FzeW5jX21ldGhvZCB+am9iIH5yZXN1bHQgfmZyZWUgPVxuICBsZXQgYXN5bmNfbWV0aG9kID0gY2hvb3NlX2FzeW5jX21ldGhvZCBhc3luY19tZXRob2QgaW5cbiAgcnVuX2pvYl9hdXggYXN5bmNfbWV0aG9kIGpvYiAoZnVuIGpvYiAtPiBsZXQgeCA9IHdyYXBfcmVzdWx0IHJlc3VsdCBqb2IgaW4gZnJlZSBqb2I7IHgpXG5bQEBAb2NhbWwud2FybmluZyBcIisxNlwiXVxuXG5leHRlcm5hbCBzZWxmX3Jlc3VsdCA6ICdhIGpvYiAtPiAnYSA9IFwibHd0X3VuaXhfc2VsZl9yZXN1bHRcIlxuKCogcmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgam9iIHVzaW5nIHRoZSBbcmVzdWx0XSBmaWVsZCBvZiB0aGUgQ1xuICAgam9iIHN0cnVjdHVyZS4gKilcblxuZXh0ZXJuYWwgcnVuX2pvYl9zeW5jIDogJ2Egam9iIC0+ICdhID0gXCJsd3RfdW5peF9ydW5fam9iX3N5bmNcIlxuKCogRXhldWN0ZXMgYSBqb2Igc3luY2hyb25vdXNseSBhbmQgcmV0dXJucyBpdHMgcmVzdWx0LiAqKVxuXG5sZXQgc2VsZl9yZXN1bHQgam9iID1cbiAgdHJ5XG4gICAgUmVzdWx0Lk9rIChzZWxmX3Jlc3VsdCBqb2IpXG4gIHdpdGggZXhuIHdoZW4gTHd0LkV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgIFJlc3VsdC5FcnJvciBleG5cblxubGV0IGluX3JldGVudGlvbl90ZXN0ID0gcmVmIGZhbHNlXG5cbmxldCByZXRhaW5lZCBvID1cbiAgbGV0IHJldGFpbmVkID0gcmVmIHRydWUgaW5cbiAgR2MuZmluYWxpc2UgKGZ1biBfIC0+XG4gICAgaWYgIWluX3JldGVudGlvbl90ZXN0IHRoZW5cbiAgICAgIHJldGFpbmVkIDo9IGZhbHNlKVxuICAgIG87XG4gIGluX3JldGVudGlvbl90ZXN0IDo9IHRydWU7XG4gIHJldGFpbmVkXG5cbmxldCBydW5fam9iID9hc3luY19tZXRob2Qgam9iID1cbiAgaWYgIWluX3JldGVudGlvbl90ZXN0IHRoZW4gYmVnaW5cbiAgICBHYy5mdWxsX21ham9yICgpO1xuICAgIGluX3JldGVudGlvbl90ZXN0IDo9IGZhbHNlXG4gIGVuZDtcbiAgbGV0IGFzeW5jX21ldGhvZCA9IGNob29zZV9hc3luY19tZXRob2QgYXN5bmNfbWV0aG9kIGluXG4gIGlmIGFzeW5jX21ldGhvZCA9IEFzeW5jX25vbmUgdGhlblxuICAgIHRyeVxuICAgICAgTHd0LnJldHVybiAocnVuX2pvYl9zeW5jIGpvYilcbiAgICB3aXRoIGV4biB3aGVuIEx3dC5FeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT5cbiAgICAgIEx3dC5mYWlsIGV4blxuICBlbHNlXG4gICAgcnVuX2pvYl9hdXggYXN5bmNfbWV0aG9kIGpvYiBzZWxmX3Jlc3VsdFxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IEZpbGUgZGVzY3JpcHRvciB3cmFwcGVycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbnR5cGUgc3RhdGUgPSBPcGVuZWQgfCBDbG9zZWQgfCBBYm9ydGVkIG9mIGV4blxuXG50eXBlIGZpbGVfZGVzY3IgPSB7XG4gIGZkIDogVW5peC5maWxlX2Rlc2NyO1xuICAoKiBUaGUgdW5kZXJseWluZyB1bml4IGZpbGUgZGVzY3JpcHRvciAqKVxuXG4gIG11dGFibGUgc3RhdGU6IHN0YXRlO1xuICAoKiBUaGUgc3RhdGUgb2YgdGhlIGZpbGUgZGVzY3JpcHRvciAqKVxuXG4gIG11dGFibGUgc2V0X2ZsYWdzIDogYm9vbDtcbiAgKCogV2hldGhlciB0byBzZXQgZmlsZSBmbGFncyAqKVxuXG4gIG11dGFibGUgYmxvY2tpbmcgOiBib29sIEx3dC50IExhenkudDtcbiAgKCogSXMgdGhlIGZpbGUgZGVzY3JpcHRvciBpbiBibG9ja2luZyBvciBub24tYmxvY2tpbmcgbW9kZSAqKVxuXG4gIG11dGFibGUgZXZlbnRfcmVhZGFibGUgOiBMd3RfZW5naW5lLmV2ZW50IG9wdGlvbjtcbiAgKCogVGhlIGV2ZW50IHVzZWQgdG8gY2hlY2sgdGhlIGZpbGUgZGVzY3JpcHRvciBmb3IgcmVhZGFiaWxpdHkuICopXG5cbiAgbXV0YWJsZSBldmVudF93cml0YWJsZSA6IEx3dF9lbmdpbmUuZXZlbnQgb3B0aW9uO1xuICAoKiBUaGUgZXZlbnQgdXNlZCB0byBjaGVjayB0aGUgZmlsZSBkZXNjcmlwdG9yIGZvciB3cml0YWJpbGl0eS4gKilcblxuICBob29rc19yZWFkYWJsZSA6ICh1bml0IC0+IHVuaXQpIEx3dF9zZXF1ZW5jZS50O1xuICAoKiBIb29rcyB0byBjYWxsIHdoZW4gdGhlIGZpbGUgZGVzY3JpcHRvciBiZWNvbWVzIHJlYWRhYmxlLiAqKVxuXG4gIGhvb2tzX3dyaXRhYmxlIDogKHVuaXQgLT4gdW5pdCkgTHd0X3NlcXVlbmNlLnQ7XG4gICgqIEhvb2tzIHRvIGNhbGwgd2hlbiB0aGUgZmlsZSBkZXNjcmlwdG9yIGJlY29tZXMgd3JpdGFibGUuICopXG59XG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmV4dGVybmFsIGlzX3NvY2tldCA6IFVuaXguZmlsZV9kZXNjciAtPiBib29sID0gXCJsd3RfdW5peF9pc19zb2NrZXRcIiBcIm5vYWxsb2NcIlxuW0BAQG9jYW1sLndhcm5pbmcgXCIrM1wiXVxuXG5leHRlcm5hbCBndWVzc19ibG9ja2luZ19qb2IgOiBVbml4LmZpbGVfZGVzY3IgLT4gYm9vbCBqb2IgPSBcImx3dF91bml4X2d1ZXNzX2Jsb2NraW5nX2pvYlwiXG5cbmxldCBndWVzc19ibG9ja2luZyBmZCA9XG4gIHJ1bl9qb2IgKGd1ZXNzX2Jsb2NraW5nX2pvYiBmZClcblxubGV0IGlzX2Jsb2NraW5nID9ibG9ja2luZyA/KHNldF9mbGFncz10cnVlKSBmZCA9XG4gIGlmIFN5cy53aW4zMiB0aGVuIGJlZ2luXG4gICAgaWYgaXNfc29ja2V0IGZkIHRoZW5cbiAgICAgIG1hdGNoIGJsb2NraW5nLCBzZXRfZmxhZ3Mgd2l0aFxuICAgICAgfCBTb21lIHN0YXRlLCBmYWxzZSAtPlxuICAgICAgICBsYXp5KEx3dC5yZXR1cm4gc3RhdGUpXG4gICAgICB8IFNvbWUgdHJ1ZSwgdHJ1ZSAtPlxuICAgICAgICBsYXp5KFVuaXguY2xlYXJfbm9uYmxvY2sgZmQ7XG4gICAgICAgICAgICAgTHd0LnJldHVybl90cnVlKVxuICAgICAgfCBTb21lIGZhbHNlLCB0cnVlIC0+XG4gICAgICAgIGxhenkoVW5peC5zZXRfbm9uYmxvY2sgZmQ7XG4gICAgICAgICAgICAgTHd0LnJldHVybl9mYWxzZSlcbiAgICAgIHwgTm9uZSwgZmFsc2UgLT5cbiAgICAgICAgbGF6eShMd3QucmV0dXJuX2ZhbHNlKVxuICAgICAgfCBOb25lLCB0cnVlIC0+XG4gICAgICAgIGxhenkoVW5peC5zZXRfbm9uYmxvY2sgZmQ7XG4gICAgICAgICAgICAgTHd0LnJldHVybl9mYWxzZSlcbiAgICBlbHNlXG4gICAgICBtYXRjaCBibG9ja2luZyB3aXRoXG4gICAgICB8IFNvbWUgc3RhdGUgLT5cbiAgICAgICAgbGF6eShMd3QucmV0dXJuIHN0YXRlKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIGxhenkoTHd0LnJldHVybl90cnVlKVxuICBlbmQgZWxzZSBiZWdpblxuICAgIG1hdGNoIGJsb2NraW5nLCBzZXRfZmxhZ3Mgd2l0aFxuICAgIHwgU29tZSBzdGF0ZSwgZmFsc2UgLT5cbiAgICAgIGxhenkoTHd0LnJldHVybiBzdGF0ZSlcbiAgICB8IFNvbWUgdHJ1ZSwgdHJ1ZSAtPlxuICAgICAgbGF6eShVbml4LmNsZWFyX25vbmJsb2NrIGZkO1xuICAgICAgICAgICBMd3QucmV0dXJuX3RydWUpXG4gICAgfCBTb21lIGZhbHNlLCB0cnVlIC0+XG4gICAgICBsYXp5KFVuaXguc2V0X25vbmJsb2NrIGZkO1xuICAgICAgICAgICBMd3QucmV0dXJuX2ZhbHNlKVxuICAgIHwgTm9uZSwgZmFsc2UgLT5cbiAgICAgIGxhenkoZ3Vlc3NfYmxvY2tpbmcgZmQpXG4gICAgfCBOb25lLCB0cnVlIC0+XG4gICAgICBsYXp5KGd1ZXNzX2Jsb2NraW5nIGZkID4+PSBmdW5jdGlvblxuICAgICAgfCB0cnVlIC0+XG4gICAgICAgIFVuaXguY2xlYXJfbm9uYmxvY2sgZmQ7XG4gICAgICAgIEx3dC5yZXR1cm5fdHJ1ZVxuICAgICAgfCBmYWxzZSAtPlxuICAgICAgICBVbml4LnNldF9ub25ibG9jayBmZDtcbiAgICAgICAgTHd0LnJldHVybl9mYWxzZSlcbiAgZW5kXG5cbmxldCBta19jaCA/YmxvY2tpbmcgPyhzZXRfZmxhZ3M9dHJ1ZSkgZmQgPSB7XG4gIGZkID0gZmQ7XG4gIHN0YXRlID0gT3BlbmVkO1xuICBzZXRfZmxhZ3MgPSBzZXRfZmxhZ3M7XG4gIGJsb2NraW5nID0gaXNfYmxvY2tpbmcgP2Jsb2NraW5nIH5zZXRfZmxhZ3MgZmQ7XG4gIGV2ZW50X3JlYWRhYmxlID0gTm9uZTtcbiAgZXZlbnRfd3JpdGFibGUgPSBOb25lO1xuICBob29rc19yZWFkYWJsZSA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCk7XG4gIGhvb2tzX3dyaXRhYmxlID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKTtcbn1cblxubGV0IGNoZWNrX2Rlc2NyaXB0b3IgY2ggPVxuICBtYXRjaCBjaC5zdGF0ZSB3aXRoXG4gIHwgT3BlbmVkIC0+XG4gICAgKClcbiAgfCBBYm9ydGVkIGUgLT5cbiAgICByYWlzZSBlXG4gIHwgQ2xvc2VkIC0+XG4gICAgcmFpc2UgKFVuaXguVW5peF9lcnJvciAoVW5peC5FQkFERiwgXCJjaGVja19kZXNjcmlwdG9yXCIsIFwiXCIpKVxuXG5sZXQgc3RhdGUgY2ggPSBjaC5zdGF0ZVxuXG5sZXQgYmxvY2tpbmcgY2ggPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBMYXp5LmZvcmNlIGNoLmJsb2NraW5nXG5cbmxldCBzZXRfYmxvY2tpbmcgPyhzZXRfZmxhZ3M9dHJ1ZSkgY2ggYmxvY2tpbmcgPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBjaC5zZXRfZmxhZ3MgPC0gc2V0X2ZsYWdzO1xuICBjaC5ibG9ja2luZyA8LSBpc19ibG9ja2luZyB+YmxvY2tpbmcgfnNldF9mbGFncyBjaC5mZFxuXG5leHRlcm5hbCB1bml4X3N0dWJfcmVhZGFibGUgOiBVbml4LmZpbGVfZGVzY3IgLT4gYm9vbCA9IFwibHd0X3VuaXhfcmVhZGFibGVcIlxuZXh0ZXJuYWwgdW5peF9zdHViX3dyaXRhYmxlIDogVW5peC5maWxlX2Rlc2NyIC0+IGJvb2wgPSBcImx3dF91bml4X3dyaXRhYmxlXCJcblxubGV0IHJlYyB1bml4X3JlYWRhYmxlIGZkID1cbiAgdHJ5XG4gICAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICAgIFVuaXguc2VsZWN0IFtmZF0gW10gW10gMC4wIDw+IChbXSwgW10sIFtdKVxuICAgIGVsc2VcbiAgICAgIHVuaXhfc3R1Yl9yZWFkYWJsZSBmZFxuICB3aXRoIFVuaXguVW5peF9lcnJvciAoVW5peC5FSU5UUiwgXywgXykgLT5cbiAgICB1bml4X3JlYWRhYmxlIGZkXG5cbmxldCByZWMgdW5peF93cml0YWJsZSBmZCA9XG4gIHRyeVxuICAgIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgICBVbml4LnNlbGVjdCBbXSBbZmRdIFtdIDAuMCA8PiAoW10sIFtdLCBbXSlcbiAgICBlbHNlXG4gICAgICB1bml4X3N0dWJfd3JpdGFibGUgZmRcbiAgd2l0aCBVbml4LlVuaXhfZXJyb3IgKFVuaXguRUlOVFIsIF8sIF8pIC0+XG4gICAgdW5peF93cml0YWJsZSBmZFxuXG5sZXQgcmVhZGFibGUgY2ggPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICB1bml4X3JlYWRhYmxlIGNoLmZkXG5cbmxldCB3cml0YWJsZSBjaCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIHVuaXhfd3JpdGFibGUgY2guZmRcblxubGV0IHNldF9zdGF0ZSBjaCBzdCA9XG4gIGNoLnN0YXRlIDwtIHN0XG5cbmxldCBjbGVhcl9ldmVudHMgY2ggPVxuICBMd3Rfc2VxdWVuY2UuaXRlcl9ub2RlX2wgKGZ1biBub2RlIC0+IEx3dF9zZXF1ZW5jZS5yZW1vdmUgbm9kZTsgTHd0X3NlcXVlbmNlLmdldCBub2RlICgpKSBjaC5ob29rc19yZWFkYWJsZTtcbiAgTHd0X3NlcXVlbmNlLml0ZXJfbm9kZV9sIChmdW4gbm9kZSAtPiBMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGU7IEx3dF9zZXF1ZW5jZS5nZXQgbm9kZSAoKSkgY2guaG9va3Nfd3JpdGFibGU7XG4gIGJlZ2luXG4gICAgbWF0Y2ggY2guZXZlbnRfcmVhZGFibGUgd2l0aFxuICAgIHwgU29tZSBldiAtPlxuICAgICAgY2guZXZlbnRfcmVhZGFibGUgPC0gTm9uZTtcbiAgICAgIEx3dF9lbmdpbmUuc3RvcF9ldmVudCBldlxuICAgIHwgTm9uZSAtPlxuICAgICAgKClcbiAgZW5kO1xuICBiZWdpblxuICAgIG1hdGNoIGNoLmV2ZW50X3dyaXRhYmxlIHdpdGhcbiAgICB8IFNvbWUgZXYgLT5cbiAgICAgIGNoLmV2ZW50X3dyaXRhYmxlIDwtIE5vbmU7XG4gICAgICBMd3RfZW5naW5lLnN0b3BfZXZlbnQgZXZcbiAgICB8IE5vbmUgLT5cbiAgICAgICgpXG4gIGVuZFxuXG5sZXQgYWJvcnQgY2ggZSA9XG4gIGlmIGNoLnN0YXRlIDw+IENsb3NlZCB0aGVuIGJlZ2luXG4gICAgc2V0X3N0YXRlIGNoIChBYm9ydGVkIGUpO1xuICAgIGNsZWFyX2V2ZW50cyBjaFxuICBlbmRcblxubGV0IHVuaXhfZmlsZV9kZXNjciBjaCA9IGNoLmZkXG5cbmxldCBvZl91bml4X2ZpbGVfZGVzY3IgPSBta19jaFxuXG5sZXQgc3RkaW4gPSBvZl91bml4X2ZpbGVfZGVzY3IgfnNldF9mbGFnczpmYWxzZSB+YmxvY2tpbmc6dHJ1ZSBVbml4LnN0ZGluXG5sZXQgc3Rkb3V0ID0gb2ZfdW5peF9maWxlX2Rlc2NyIH5zZXRfZmxhZ3M6ZmFsc2UgfmJsb2NraW5nOnRydWUgVW5peC5zdGRvdXRcbmxldCBzdGRlcnIgPSBvZl91bml4X2ZpbGVfZGVzY3IgfnNldF9mbGFnczpmYWxzZSB+YmxvY2tpbmc6dHJ1ZSBVbml4LnN0ZGVyclxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IEFjdGlvbnMgb24gZmlsZSBkZXNjcmlwdG9ycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbnR5cGUgaW9fZXZlbnQgPSBSZWFkIHwgV3JpdGVcblxuZXhjZXB0aW9uIFJldHJ5XG5leGNlcHRpb24gUmV0cnlfd3JpdGVcbmV4Y2VwdGlvbiBSZXRyeV9yZWFkXG5cbnR5cGUgJ2Egb3V0Y29tZSA9XG4gIHwgU3VjY2VzcyBvZiAnYVxuICB8IEV4biBvZiBleG5cbiAgfCBSZXF1ZXVlZCBvZiBpb19ldmVudFxuXG4oKiBXYWl0IGEgYml0LCB0aGVuIHN0b3AgZXZlbnRzIHRoYXQgYXJlIG5vIG1vcmUgdXNlZC4gKilcbmxldCBzdG9wX2V2ZW50cyBjaCA9XG4gIEx3dC5vbl9zdWNjZXNzXG4gICAgKEx3dC5wYXVzZSAoKSlcbiAgICAoZnVuICgpIC0+XG4gICAgICAgaWYgTHd0X3NlcXVlbmNlLmlzX2VtcHR5IGNoLmhvb2tzX3JlYWRhYmxlIHRoZW4gYmVnaW5cbiAgICAgICAgIG1hdGNoIGNoLmV2ZW50X3JlYWRhYmxlIHdpdGhcbiAgICAgICAgIHwgU29tZSBldiAtPlxuICAgICAgICAgICBjaC5ldmVudF9yZWFkYWJsZSA8LSBOb25lO1xuICAgICAgICAgICBMd3RfZW5naW5lLnN0b3BfZXZlbnQgZXZcbiAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAoKVxuICAgICAgIGVuZDtcbiAgICAgICBpZiBMd3Rfc2VxdWVuY2UuaXNfZW1wdHkgY2guaG9va3Nfd3JpdGFibGUgdGhlbiBiZWdpblxuICAgICAgICAgbWF0Y2ggY2guZXZlbnRfd3JpdGFibGUgd2l0aFxuICAgICAgICAgfCBTb21lIGV2IC0+XG4gICAgICAgICAgIGNoLmV2ZW50X3dyaXRhYmxlIDwtIE5vbmU7XG4gICAgICAgICAgIEx3dF9lbmdpbmUuc3RvcF9ldmVudCBldlxuICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICgpXG4gICAgICAgZW5kKVxuXG5sZXQgcmVnaXN0ZXJfcmVhZGFibGUgY2ggPVxuICBpZiBjaC5ldmVudF9yZWFkYWJsZSA9IE5vbmUgdGhlblxuICAgIGNoLmV2ZW50X3JlYWRhYmxlIDwtIFNvbWUoTHd0X2VuZ2luZS5vbl9yZWFkYWJsZSBjaC5mZCAoZnVuIF8gLT4gTHd0X3NlcXVlbmNlLml0ZXJfbCAoZnVuIGYgLT4gZiAoKSkgY2guaG9va3NfcmVhZGFibGUpKVxuXG5sZXQgcmVnaXN0ZXJfd3JpdGFibGUgY2ggPVxuICBpZiBjaC5ldmVudF93cml0YWJsZSA9IE5vbmUgdGhlblxuICAgIGNoLmV2ZW50X3dyaXRhYmxlIDwtIFNvbWUoTHd0X2VuZ2luZS5vbl93cml0YWJsZSBjaC5mZCAoZnVuIF8gLT4gTHd0X3NlcXVlbmNlLml0ZXJfbCAoZnVuIGYgLT4gZiAoKSkgY2guaG9va3Nfd3JpdGFibGUpKVxuXG4oKiBSZXRyeSBhIHF1ZXVlZCBzeXNjYWxsLCBbd2FrZW5lcl0gaXMgdGhlIHRocmVhZCB0byB3YWtldXAgaWYgdGhlXG4gICBhY3Rpb24gc3VjY2VlZHM6ICopXG5sZXQgcmVjIHJldHJ5X3N5c2NhbGwgbm9kZSBldmVudCBjaCB3YWtlbmVyIGFjdGlvbiA9XG4gIGxldCByZXMgPVxuICAgIHRyeVxuICAgICAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgICAgIFN1Y2Nlc3MoYWN0aW9uICgpKVxuICAgIHdpdGhcbiAgICB8IFJldHJ5XG4gICAgfCBVbml4LlVuaXhfZXJyb3IoKFVuaXguRUFHQUlOIHwgVW5peC5FV09VTERCTE9DSyB8IFVuaXguRUlOVFIpLCBfLCBfKVxuICAgIHwgU3lzX2Jsb2NrZWRfaW8gLT5cbiAgICAgICgqIEVJTlRSIGJlY2F1c2Ugd2UgYXJlIGNhdGNoaW5nIFNJR19DSExEIGhlbmNlIHRoZSBzeXN0ZW1cbiAgICAgICAgIGNhbGwgbWlnaHQgYmUgaW50ZXJydXB0ZWQgdG8gaGFuZGxlIHRoZSBzaWduYWw7IHRoaXMgbGV0c1xuICAgICAgICAgdXMgcmVzdGFydCB0aGUgc3lzdGVtIGNhbGwgZXZlbnR1YWxseS4gKilcbiAgICAgIFJlcXVldWVkIGV2ZW50XG4gICAgfCBSZXRyeV9yZWFkIC0+XG4gICAgICBSZXF1ZXVlZCBSZWFkXG4gICAgfCBSZXRyeV93cml0ZSAtPlxuICAgICAgUmVxdWV1ZWQgV3JpdGVcbiAgICB8IGUgd2hlbiBMd3QuRXhjZXB0aW9uX2ZpbHRlci5ydW4gZSAtPlxuICAgICAgRXhuIGVcbiAgaW5cbiAgbWF0Y2ggcmVzIHdpdGhcbiAgfCBTdWNjZXNzIHYgLT5cbiAgICBMd3Rfc2VxdWVuY2UucmVtb3ZlICFub2RlO1xuICAgIHN0b3BfZXZlbnRzIGNoO1xuICAgIEx3dC53YWtldXAgd2FrZW5lciB2XG4gIHwgRXhuIGUgLT5cbiAgICBMd3Rfc2VxdWVuY2UucmVtb3ZlICFub2RlO1xuICAgIHN0b3BfZXZlbnRzIGNoO1xuICAgIEx3dC53YWtldXBfZXhuIHdha2VuZXIgZVxuICB8IFJlcXVldWVkIGV2ZW50JyAtPlxuICAgIGlmIGV2ZW50IDw+IGV2ZW50JyB0aGVuIGJlZ2luXG4gICAgICBMd3Rfc2VxdWVuY2UucmVtb3ZlICFub2RlO1xuICAgICAgc3RvcF9ldmVudHMgY2g7XG4gICAgICBtYXRjaCBldmVudCcgd2l0aFxuICAgICAgfCBSZWFkIC0+XG4gICAgICAgIG5vZGUgOj0gTHd0X3NlcXVlbmNlLmFkZF9yIChmdW4gKCkgLT4gcmV0cnlfc3lzY2FsbCBub2RlIFJlYWQgY2ggd2FrZW5lciBhY3Rpb24pIGNoLmhvb2tzX3JlYWRhYmxlIDtcbiAgICAgICAgcmVnaXN0ZXJfcmVhZGFibGUgY2hcbiAgICAgIHwgV3JpdGUgLT5cbiAgICAgICAgbm9kZSA6PSBMd3Rfc2VxdWVuY2UuYWRkX3IgKGZ1biAoKSAtPiByZXRyeV9zeXNjYWxsIG5vZGUgV3JpdGUgY2ggd2FrZW5lciBhY3Rpb24pIGNoLmhvb2tzX3dyaXRhYmxlO1xuICAgICAgICByZWdpc3Rlcl93cml0YWJsZSBjaFxuICAgIGVuZFxuXG5sZXQgZHVtbXkgPSBMd3Rfc2VxdWVuY2UuYWRkX3IgaWdub3JlIChMd3Rfc2VxdWVuY2UuY3JlYXRlICgpKVxuXG5sZXQgcmVnaXN0ZXJfYWN0aW9uIGV2ZW50IGNoIGFjdGlvbiA9XG4gIGxldCB3YWl0ZXIsIHdha2VuZXIgPSBMd3QudGFzayAoKSBpblxuICBtYXRjaCBldmVudCB3aXRoXG4gIHwgUmVhZCAtPlxuICAgIGxldCBub2RlID0gcmVmIGR1bW15IGluXG4gICAgbm9kZSA6PSBMd3Rfc2VxdWVuY2UuYWRkX3IgKGZ1biAoKSAtPiByZXRyeV9zeXNjYWxsIG5vZGUgUmVhZCBjaCB3YWtlbmVyIGFjdGlvbikgY2guaG9va3NfcmVhZGFibGU7XG4gICAgTHd0Lm9uX2NhbmNlbCB3YWl0ZXIgKGZ1biAoKSAtPiBMd3Rfc2VxdWVuY2UucmVtb3ZlICFub2RlOyBzdG9wX2V2ZW50cyBjaCk7XG4gICAgcmVnaXN0ZXJfcmVhZGFibGUgY2g7XG4gICAgd2FpdGVyXG4gIHwgV3JpdGUgLT5cbiAgICBsZXQgbm9kZSA9IHJlZiBkdW1teSBpblxuICAgIG5vZGUgOj0gTHd0X3NlcXVlbmNlLmFkZF9yIChmdW4gKCkgLT4gcmV0cnlfc3lzY2FsbCBub2RlIFdyaXRlIGNoIHdha2VuZXIgYWN0aW9uKSBjaC5ob29rc193cml0YWJsZTtcbiAgICBMd3Qub25fY2FuY2VsIHdhaXRlciAoZnVuICgpIC0+IEx3dF9zZXF1ZW5jZS5yZW1vdmUgIW5vZGU7IHN0b3BfZXZlbnRzIGNoKTtcbiAgICByZWdpc3Rlcl93cml0YWJsZSBjaDtcbiAgICB3YWl0ZXJcblxuKCogV3JhcHMgYSBzeXN0ZW0gY2FsbCAqKVxubGV0IHdyYXBfc3lzY2FsbCBldmVudCBjaCBhY3Rpb24gPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBMYXp5LmZvcmNlIGNoLmJsb2NraW5nID4+PSBmdW4gYmxvY2tpbmcgLT5cbiAgdHJ5XG4gICAgaWYgbm90IGJsb2NraW5nIHx8IChldmVudCA9IFJlYWQgJiYgdW5peF9yZWFkYWJsZSBjaC5mZCkgfHwgKGV2ZW50ID0gV3JpdGUgJiYgdW5peF93cml0YWJsZSBjaC5mZCkgdGhlblxuICAgICAgTHd0LnJldHVybiAoYWN0aW9uICgpKVxuICAgIGVsc2VcbiAgICAgIHJlZ2lzdGVyX2FjdGlvbiBldmVudCBjaCBhY3Rpb25cbiAgd2l0aFxuICB8IFJldHJ5XG4gIHwgVW5peC5Vbml4X2Vycm9yKChVbml4LkVBR0FJTiB8IFVuaXguRVdPVUxEQkxPQ0sgfCBVbml4LkVJTlRSKSwgXywgXylcbiAgfCBTeXNfYmxvY2tlZF9pbyAtPlxuICAgICgqIFRoZSBhY3Rpb24gY291bGQgbm90IGJlIGNvbXBsZXRlZCBpbW1lZGlhdGVseSwgcmVnaXN0ZXIgaXQ6ICopXG4gICAgcmVnaXN0ZXJfYWN0aW9uIGV2ZW50IGNoIGFjdGlvblxuICB8IFJldHJ5X3JlYWQgLT5cbiAgICByZWdpc3Rlcl9hY3Rpb24gUmVhZCBjaCBhY3Rpb25cbiAgfCBSZXRyeV93cml0ZSAtPlxuICAgIHJlZ2lzdGVyX2FjdGlvbiBXcml0ZSBjaCBhY3Rpb25cbiAgfCBlIHdoZW4gTHd0LkV4Y2VwdGlvbl9maWx0ZXIucnVuIGUgLT5cbiAgICBMd3QucmVyYWlzZSBlXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgQmFzaWMgZmlsZSBpbnB1dC9vdXRwdXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxudHlwZSBvcGVuX2ZsYWcgPVxuICBVbml4Lm9wZW5fZmxhZyA9XG4gIHwgT19SRE9OTFlcbiAgfCBPX1dST05MWVxuICB8IE9fUkRXUlxuICB8IE9fTk9OQkxPQ0tcbiAgfCBPX0FQUEVORFxuICB8IE9fQ1JFQVRcbiAgfCBPX1RSVU5DXG4gIHwgT19FWENMXG4gIHwgT19OT0NUVFlcbiAgfCBPX0RTWU5DXG4gIHwgT19TWU5DXG4gIHwgT19SU1lOQ1xuICB8IE9fU0hBUkVfREVMRVRFXG4gIHwgT19DTE9FWEVDXG4gIHwgT19LRUVQRVhFQ1xuXG5leHRlcm5hbCBvcGVuX2pvYiA6IHN0cmluZyAtPiBVbml4Lm9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiAoVW5peC5maWxlX2Rlc2NyICogYm9vbCkgam9iID0gXCJsd3RfdW5peF9vcGVuX2pvYlwiXG5cbmxldCBvcGVuZmlsZSBuYW1lIGZsYWdzIHBlcm1zID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChvZl91bml4X2ZpbGVfZGVzY3IgKFVuaXgub3BlbmZpbGUgbmFtZSBmbGFncyBwZXJtcykpXG4gIGVsc2VcbiAgICBydW5fam9iIChvcGVuX2pvYiBuYW1lIGZsYWdzIHBlcm1zKSA+Pj0gZnVuIChmZCwgYmxvY2tpbmcpIC0+XG4gICAgTHd0LnJldHVybiAob2ZfdW5peF9maWxlX2Rlc2NyIH5ibG9ja2luZyBmZClcblxuZXh0ZXJuYWwgY2xvc2Vfam9iIDogVW5peC5maWxlX2Rlc2NyIC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF9jbG9zZV9qb2JcIlxuXG5sZXQgY2xvc2UgY2ggPVxuICBpZiBjaC5zdGF0ZSA9IENsb3NlZCB0aGVuIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIHNldF9zdGF0ZSBjaCBDbG9zZWQ7XG4gIGNsZWFyX2V2ZW50cyBjaDtcbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmNsb3NlIGNoLmZkKVxuICBlbHNlXG4gICAgcnVuX2pvYiAoY2xvc2Vfam9iIGNoLmZkKVxuXG50eXBlIGJpZ2FycmF5ID1cbiAgKGNoYXIsIEJpZ2FycmF5LmludDhfdW5zaWduZWRfZWx0LCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuQXJyYXkxLnRcblxubGV0IHdhaXRfcmVhZCBjaCA9XG4gIEx3dC5jYXRjaFxuICAgIChmdW4gKCkgLT5cbiAgICAgICBpZiByZWFkYWJsZSBjaCB0aGVuXG4gICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICAgICBlbHNlXG4gICAgICAgICByZWdpc3Rlcl9hY3Rpb24gUmVhZCBjaCBpZ25vcmUpXG4gICAgTHd0LnJlcmFpc2VcblxuZXh0ZXJuYWwgc3R1Yl9yZWFkIDogVW5peC5maWxlX2Rlc2NyIC0+IEJ5dGVzLnQgLT4gaW50IC0+IGludCAtPiBpbnQgPSBcImx3dF91bml4X3JlYWRcIlxuZXh0ZXJuYWwgcmVhZF9qb2IgOiBVbml4LmZpbGVfZGVzY3IgLT4gQnl0ZXMudCAtPiBpbnQgLT4gaW50IC0+IGludCBqb2IgPSBcImx3dF91bml4X3JlYWRfam9iXCJcbmV4dGVybmFsIHN0dWJfcHJlYWQgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gQnl0ZXMudCAtPiBmaWxlX29mZnNldDppbnQgLT4gaW50IC0+IGludCAtPiBpbnQgPVxuICAgIFwibHd0X3VuaXhfcHJlYWRcIlxuZXh0ZXJuYWwgcHJlYWRfam9iIDpcbiAgVW5peC5maWxlX2Rlc2NyIC0+IEJ5dGVzLnQgLT4gZmlsZV9vZmZzZXQ6aW50IC0+IGludCAtPiBpbnQgLT4gaW50IGpvYiA9XG4gICAgXCJsd3RfdW5peF9wcmVhZF9qb2JcIlxuXG5sZXQgcmVhZCBjaCBidWYgcG9zIGxlbiA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB8fCBwb3MgPiBCeXRlcy5sZW5ndGggYnVmIC0gbGVuIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkx3dF91bml4LnJlYWRcIlxuICBlbHNlXG4gICAgTGF6eS5mb3JjZSBjaC5ibG9ja2luZyA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgLT5cbiAgICAgIHdhaXRfcmVhZCBjaCA+Pj0gZnVuICgpIC0+XG4gICAgICBydW5fam9iIChyZWFkX2pvYiBjaC5mZCBidWYgcG9zIGxlbilcbiAgICB8IGZhbHNlIC0+XG4gICAgICB3cmFwX3N5c2NhbGwgUmVhZCBjaCAoZnVuICgpIC0+IHN0dWJfcmVhZCBjaC5mZCBidWYgcG9zIGxlbilcblxubGV0IHByZWFkIGNoIGJ1ZiB+ZmlsZV9vZmZzZXQgcG9zIGxlbiA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB8fCBwb3MgPiBCeXRlcy5sZW5ndGggYnVmIC0gbGVuIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkx3dF91bml4LnByZWFkXCJcbiAgZWxzZVxuICAgIExhenkuZm9yY2UgY2guYmxvY2tpbmcgPj49IGZ1bmN0aW9uXG4gICAgfCB0cnVlIC0+XG4gICAgICB3YWl0X3JlYWQgY2ggPj49IGZ1biAoKSAtPlxuICAgICAgcnVuX2pvYiAocHJlYWRfam9iIGNoLmZkIGJ1ZiB+ZmlsZV9vZmZzZXQgcG9zIGxlbilcbiAgICB8IGZhbHNlIC0+XG4gICAgICB3cmFwX3N5c2NhbGwgUmVhZCBjaCAoZnVuICgpIC0+IHN0dWJfcHJlYWQgY2guZmQgYnVmIH5maWxlX29mZnNldCBwb3MgbGVuKVxuXG5leHRlcm5hbCBzdHViX3JlYWRfYmlnYXJyYXkgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gYmlnYXJyYXkgLT4gaW50IC0+IGludCAtPiBpbnQgPSBcImx3dF91bml4X2J5dGVzX3JlYWRcIlxuZXh0ZXJuYWwgcmVhZF9iaWdhcnJheV9qb2IgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gYmlnYXJyYXkgLT4gaW50IC0+IGludCAtPiBpbnQgam9iID1cbiAgXCJsd3RfdW5peF9ieXRlc19yZWFkX2pvYlwiXG5cbmxldCByZWFkX2JpZ2FycmF5IGZ1bmN0aW9uX25hbWUgZmQgYnVmIHBvcyBsZW4gPVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IDAgfHwgcG9zID4gQmlnYXJyYXkuQXJyYXkxLmRpbSBidWYgLSBsZW4gdGhlblxuICAgIGludmFsaWRfYXJnIGZ1bmN0aW9uX25hbWVcbiAgZWxzZVxuICAgIGJsb2NraW5nIGZkID4+PSBmdW5jdGlvblxuICAgIHwgdHJ1ZSAtPlxuICAgICAgd2FpdF9yZWFkIGZkID4+PSBmdW4gKCkgLT5cbiAgICAgIHJ1bl9qb2IgKHJlYWRfYmlnYXJyYXlfam9iICh1bml4X2ZpbGVfZGVzY3IgZmQpIGJ1ZiBwb3MgbGVuKVxuICAgIHwgZmFsc2UgLT5cbiAgICAgIHdyYXBfc3lzY2FsbCBSZWFkIGZkIChmdW4gKCkgLT5cbiAgICAgICAgc3R1Yl9yZWFkX2JpZ2FycmF5ICh1bml4X2ZpbGVfZGVzY3IgZmQpIGJ1ZiBwb3MgbGVuKVxuXG5sZXQgd2FpdF93cml0ZSBjaCA9XG4gIEx3dC5jYXRjaFxuICAgIChmdW4gKCkgLT5cbiAgICAgICBpZiB3cml0YWJsZSBjaCB0aGVuXG4gICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICAgICBlbHNlXG4gICAgICAgICByZWdpc3Rlcl9hY3Rpb24gV3JpdGUgY2ggaWdub3JlKVxuICAgIEx3dC5yZXJhaXNlXG5cbmV4dGVybmFsIHN0dWJfd3JpdGUgOiBVbml4LmZpbGVfZGVzY3IgLT4gQnl0ZXMudCAtPiBpbnQgLT4gaW50IC0+IGludCA9IFwibHd0X3VuaXhfd3JpdGVcIlxuZXh0ZXJuYWwgd3JpdGVfam9iIDogVW5peC5maWxlX2Rlc2NyIC0+IEJ5dGVzLnQgLT4gaW50IC0+IGludCAtPiBpbnQgam9iID0gXCJsd3RfdW5peF93cml0ZV9qb2JcIlxuZXh0ZXJuYWwgc3R1Yl9wd3JpdGUgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gQnl0ZXMudCAtPiBmaWxlX29mZnNldDppbnQgLT4gaW50IC0+IGludCAtPiBpbnQgPVxuICAgIFwibHd0X3VuaXhfcHdyaXRlXCJcbmV4dGVybmFsIHB3cml0ZV9qb2IgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gQnl0ZXMudCAtPiBmaWxlX29mZnNldDppbnQgLT4gaW50IC0+IGludCAtPiBpbnQgam9iID1cbiAgICBcImx3dF91bml4X3B3cml0ZV9qb2JcIlxuXG5sZXQgd3JpdGUgY2ggYnVmIHBvcyBsZW4gPVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IDAgfHwgcG9zID4gQnl0ZXMubGVuZ3RoIGJ1ZiAtIGxlbiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJMd3RfdW5peC53cml0ZVwiXG4gIGVsc2VcbiAgICBMYXp5LmZvcmNlIGNoLmJsb2NraW5nID4+PSBmdW5jdGlvblxuICAgIHwgdHJ1ZSAtPlxuICAgICAgd2FpdF93cml0ZSBjaCA+Pj0gZnVuICgpIC0+XG4gICAgICBydW5fam9iICh3cml0ZV9qb2IgY2guZmQgYnVmIHBvcyBsZW4pXG4gICAgfCBmYWxzZSAtPlxuICAgICAgd3JhcF9zeXNjYWxsIFdyaXRlIGNoIChmdW4gKCkgLT4gc3R1Yl93cml0ZSBjaC5mZCBidWYgcG9zIGxlbilcblxubGV0IHB3cml0ZSBjaCBidWYgfmZpbGVfb2Zmc2V0IHBvcyBsZW4gPVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IDAgfHwgcG9zID4gQnl0ZXMubGVuZ3RoIGJ1ZiAtIGxlbiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJMd3RfdW5peC5wd3JpdGVcIlxuICBlbHNlXG4gICAgTGF6eS5mb3JjZSBjaC5ibG9ja2luZyA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgLT5cbiAgICAgIHdhaXRfd3JpdGUgY2ggPj49IGZ1biAoKSAtPlxuICAgICAgcnVuX2pvYiAocHdyaXRlX2pvYiBjaC5mZCBidWYgfmZpbGVfb2Zmc2V0IHBvcyBsZW4pXG4gICAgfCBmYWxzZSAtPlxuICAgICAgd3JhcF9zeXNjYWxsIFdyaXRlIGNoIChmdW4gKCkgLT4gc3R1Yl9wd3JpdGUgY2guZmQgYnVmIH5maWxlX29mZnNldCBwb3MgbGVuKVxuXG5sZXQgd3JpdGVfc3RyaW5nIGNoIGJ1ZiBwb3MgbGVuID1cbiAgbGV0IGJ1ZiA9IEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgYnVmIGluXG4gIHdyaXRlIGNoIGJ1ZiBwb3MgbGVuXG5cbmxldCBwd3JpdGVfc3RyaW5nIGNoIGJ1ZiB+ZmlsZV9vZmZzZXQgcG9zIGxlbiA9XG4gIGxldCBidWYgPSBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGJ1ZiBpblxuICBwd3JpdGUgY2ggYnVmIH5maWxlX29mZnNldCBwb3MgbGVuXG5cbmV4dGVybmFsIHN0dWJfd3JpdGVfYmlnYXJyYXkgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gYmlnYXJyYXkgLT4gaW50IC0+IGludCAtPiBpbnQgPSBcImx3dF91bml4X2J5dGVzX3dyaXRlXCJcbmV4dGVybmFsIHdyaXRlX2JpZ2FycmF5X2pvYiA6XG4gIFVuaXguZmlsZV9kZXNjciAtPiBiaWdhcnJheSAtPiBpbnQgLT4gaW50IC0+IGludCBqb2IgPVxuICBcImx3dF91bml4X2J5dGVzX3dyaXRlX2pvYlwiXG5cbmxldCB3cml0ZV9iaWdhcnJheSBmdW5jdGlvbl9uYW1lIGZkIGJ1ZiBwb3MgbGVuID1cbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IEJpZ2FycmF5LkFycmF5MS5kaW0gYnVmIC0gbGVuIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBmdW5jdGlvbl9uYW1lXG4gIGVsc2VcbiAgICBibG9ja2luZyBmZCA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgLT5cbiAgICAgIHdhaXRfd3JpdGUgZmQgPj49IGZ1biAoKSAtPlxuICAgICAgcnVuX2pvYiAod3JpdGVfYmlnYXJyYXlfam9iICh1bml4X2ZpbGVfZGVzY3IgZmQpIGJ1ZiBwb3MgbGVuKVxuICAgIHwgZmFsc2UgLT5cbiAgICAgIHdyYXBfc3lzY2FsbCBXcml0ZSBmZCAoZnVuICgpIC0+XG4gICAgICAgIHN0dWJfd3JpdGVfYmlnYXJyYXkgKHVuaXhfZmlsZV9kZXNjciBmZCkgYnVmIHBvcyBsZW4pXG5cbm1vZHVsZSBJT192ZWN0b3JzID1cbnN0cnVjdFxuICB0eXBlIF9iaWdhcnJheSA9IGJpZ2FycmF5XG5cbiAgdHlwZSBidWZmZXIgPVxuICAgIHwgQnl0ZXMgb2YgYnl0ZXNcbiAgICB8IEJpZ2FycmF5IG9mIF9iaWdhcnJheVxuXG4gIHR5cGUgaW9fdmVjdG9yID1cbiAgICB7YnVmZmVyIDogYnVmZmVyO1xuICAgICBtdXRhYmxlIG9mZnNldCA6IGludDtcbiAgICAgbXV0YWJsZSBsZW5ndGggOiBpbnR9XG5cbiAgKCogVGhpcyByZXByZXNlbnRhdGlvbiBkb2VzIG5vdCBnaXZlIGNvbnN0YW50IGFtb3J0aXplZCB0aW1lIGFwcGVuZCBhY3Jvc3MgYWxsXG4gICAgIHBvc3NpYmxlIG9wZXJhdGlvbiBzZXF1ZW5jZXMsIGJ1dCBpdCBkb2VzIGZvciBleHBlY3RlZCB0eXBpY2FsIHVzYWdlLCBpblxuICAgICB3aGljaCBzb21lIG51bWJlciBvZiBhcHBlbmQgb3BlcmF0aW9ucyBpcyBmb2xsb3dlZCBieSBzb21lIG51bWJlciBvZlxuICAgICBmbGF0dGVuIG9wZXJhdGlvbnMuICopXG4gIHR5cGUgdCA9XG4gICAge211dGFibGUgcHJlZml4IDogaW9fdmVjdG9yIGxpc3Q7XG4gICAgIG11dGFibGUgcmV2ZXJzZWRfc3VmZml4IDogaW9fdmVjdG9yIGxpc3Q7XG4gICAgIG11dGFibGUgY291bnQgOiBpbnR9XG5cbiAgbGV0IGNyZWF0ZSAoKSA9IHtwcmVmaXggPSBbXTsgcmV2ZXJzZWRfc3VmZml4ID0gW107IGNvdW50ID0gMH1cblxuICBsZXQgYnl0ZV9jb3VudCB7cHJlZml4OyByZXZlcnNlZF9zdWZmaXg7IF99ID1cbiAgICBsZXQgY291bnRfYnVmZiA9IExpc3QuZm9sZF9sZWZ0IChmdW4gYWNjIHtsZW5ndGg7IF99IC0+IGFjYyArIGxlbmd0aCkgMCBpblxuICAgIGNvdW50X2J1ZmYgcHJlZml4ICsgY291bnRfYnVmZiByZXZlcnNlZF9zdWZmaXhcblxuICBsZXQgYXBwZW5kIGlvX3ZlY3RvcnMgaW9fdmVjdG9yID1cbiAgICBpb192ZWN0b3JzLnJldmVyc2VkX3N1ZmZpeCA8LSBpb192ZWN0b3I6OmlvX3ZlY3RvcnMucmV2ZXJzZWRfc3VmZml4O1xuICAgIGlvX3ZlY3RvcnMuY291bnQgPC0gaW9fdmVjdG9ycy5jb3VudCArIDFcblxuICBsZXQgYXBwZW5kX2J5dGVzIGlvX3ZlY3RvcnMgYnVmZmVyIG9mZnNldCBsZW5ndGggPVxuICAgIGFwcGVuZCBpb192ZWN0b3JzIHtidWZmZXIgPSBCeXRlcyBidWZmZXI7IG9mZnNldDsgbGVuZ3RofVxuXG4gIGxldCBhcHBlbmRfYmlnYXJyYXkgaW9fdmVjdG9ycyBidWZmZXIgb2Zmc2V0IGxlbmd0aCA9XG4gICAgYXBwZW5kIGlvX3ZlY3RvcnMge2J1ZmZlciA9IEJpZ2FycmF5IGJ1ZmZlcjsgb2Zmc2V0OyBsZW5ndGh9XG5cbiAgbGV0IGZsYXR0ZW4gaW9fdmVjdG9ycyA9XG4gICAgbWF0Y2ggaW9fdmVjdG9ycy5yZXZlcnNlZF9zdWZmaXggd2l0aFxuICAgIHwgW10gLT4gKClcbiAgICB8IF8gLT5cbiAgICAgIGlvX3ZlY3RvcnMucHJlZml4IDwtXG4gICAgICAgIGlvX3ZlY3RvcnMucHJlZml4IEAgKExpc3QucmV2IGlvX3ZlY3RvcnMucmV2ZXJzZWRfc3VmZml4KTtcbiAgICAgIGlvX3ZlY3RvcnMucmV2ZXJzZWRfc3VmZml4IDwtIFtdXG5cbiAgbGV0IGRyb3AgaW9fdmVjdG9ycyBjb3VudCA9XG4gICAgZmxhdHRlbiBpb192ZWN0b3JzO1xuICAgIGxldCByZWMgbG9vcCBjb3VudCBwcmVmaXggPVxuICAgICAgaWYgY291bnQgPD0gMCB0aGVuIHByZWZpeFxuICAgICAgZWxzZVxuICAgICAgICBtYXRjaCBwcmVmaXggd2l0aFxuICAgICAgICB8IFtdIC0+IFtdXG4gICAgICAgIHwge2xlbmd0aDsgX306OnJlc3Qgd2hlbiBsZW5ndGggPD0gY291bnQgLT5cbiAgICAgICAgICBpb192ZWN0b3JzLmNvdW50IDwtIGlvX3ZlY3RvcnMuY291bnQgLSAxO1xuICAgICAgICAgIGxvb3AgKGNvdW50IC0gbGVuZ3RoKSByZXN0XG4gICAgICAgIHwgZmlyc3Q6Ol8gLT5cbiAgICAgICAgICBmaXJzdC5vZmZzZXQgPC0gZmlyc3Qub2Zmc2V0ICsgY291bnQ7XG4gICAgICAgICAgZmlyc3QubGVuZ3RoIDwtIGZpcnN0Lmxlbmd0aCAtIGNvdW50O1xuICAgICAgICAgIHByZWZpeFxuICAgIGluXG4gICAgaW9fdmVjdG9ycy5wcmVmaXggPC0gbG9vcCBjb3VudCBpb192ZWN0b3JzLnByZWZpeFxuXG4gIGxldCBpc19lbXB0eSBpb192ZWN0b3JzID1cbiAgICBmbGF0dGVuIGlvX3ZlY3RvcnM7XG4gICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gdHJ1ZVxuICAgICAgfCB7bGVuZ3RoID0gMDsgX306OnJlc3QgLT4gbG9vcCByZXN0XG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBpblxuICAgIGxvb3AgaW9fdmVjdG9ycy5wcmVmaXhcblxuICBleHRlcm5hbCBzdHViX2lvdl9tYXggOiB1bml0IC0+IGludCBvcHRpb24gPSBcImx3dF91bml4X2lvdl9tYXhcIlxuXG4gIGxldCBzeXN0ZW1fbGltaXQgPVxuICAgIGlmIFN5cy53aW4zMiB0aGVuIE5vbmVcbiAgICBlbHNlIHN0dWJfaW92X21heCAoKVxuXG4gIGxldCBjaGVjayB0YWcgaW9fdmVjdG9yID1cbiAgICBsZXQgYnVmZmVyX2xlbmd0aCA9XG4gICAgICBtYXRjaCBpb192ZWN0b3IuYnVmZmVyIHdpdGhcbiAgICAgIHwgQnl0ZXMgcyAtPiBCeXRlcy5sZW5ndGggc1xuICAgICAgfCBCaWdhcnJheSBhIC0+IEJpZ2FycmF5LkFycmF5MS5kaW0gYVxuICAgIGluXG5cbiAgICBpZiBpb192ZWN0b3IubGVuZ3RoIDwgMCB8fFxuICAgICAgIGlvX3ZlY3Rvci5vZmZzZXQgPCAwIHx8XG4gICAgICAgaW9fdmVjdG9yLm9mZnNldCArIGlvX3ZlY3Rvci5sZW5ndGggPiBidWZmZXJfbGVuZ3RoIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIHRhZ1xuZW5kXG5cbigqIEZsYXR0ZW5zIHRoZSBJL08gdmVjdG9ycyBpbnRvIGEgc2luZ2xlIGxpc3QsIGNoZWNrcyB0aGVpciBib3VuZHMsIGFuZFxuICAgZXZhbHVhdGVzIHRvIHRoZSBtaW5pbXVtIG9mOiB0aGUgbnVtYmVyIG9mIHZlY3RvcnMgYW5kIHRoZSBzeXN0ZW0nc1xuICAgSU9WX01BWC4gKilcbmxldCBjaGVja19pb192ZWN0b3JzIGZ1bmN0aW9uX25hbWUgaW9fdmVjdG9ycyA9XG4gIElPX3ZlY3RvcnMuZmxhdHRlbiBpb192ZWN0b3JzO1xuICBMaXN0Lml0ZXIgKElPX3ZlY3RvcnMuY2hlY2sgZnVuY3Rpb25fbmFtZSkgaW9fdmVjdG9ycy5JT192ZWN0b3JzLnByZWZpeDtcblxuICBtYXRjaCBJT192ZWN0b3JzLnN5c3RlbV9saW1pdCB3aXRoXG4gIHwgU29tZSBsaW1pdCB3aGVuIGlvX3ZlY3RvcnMuSU9fdmVjdG9ycy5jb3VudCA+IGxpbWl0IC0+IGxpbWl0XG4gIHwgXyAtPiBpb192ZWN0b3JzLklPX3ZlY3RvcnMuY291bnRcblxuZXh0ZXJuYWwgc3R1Yl9yZWFkdiA6XG4gIFVuaXguZmlsZV9kZXNjciAtPiBJT192ZWN0b3JzLmlvX3ZlY3RvciBsaXN0IC0+IGludCAtPiBpbnQgPVxuICBcImx3dF91bml4X3JlYWR2XCJcblxuZXh0ZXJuYWwgcmVhZHZfam9iIDogVW5peC5maWxlX2Rlc2NyIC0+IElPX3ZlY3RvcnMudCAtPiBpbnQgLT4gaW50IGpvYiA9XG4gIFwibHd0X3VuaXhfcmVhZHZfam9iXCJcblxubGV0IHJlYWR2IGZkIGlvX3ZlY3RvcnMgPVxuICBsZXQgY291bnQgPSBjaGVja19pb192ZWN0b3JzIFwiTHd0X3VuaXgucmVhZHZcIiBpb192ZWN0b3JzIGluXG5cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBtYXRjaCBpb192ZWN0b3JzLklPX3ZlY3RvcnMucHJlZml4IHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBMd3QucmV0dXJuIDBcbiAgICB8IGZpcnN0OjpfIC0+XG4gICAgICBtYXRjaCBmaXJzdC5idWZmZXIgd2l0aFxuICAgICAgfCBCeXRlcyBidWZmZXIgLT5cbiAgICAgICAgcmVhZCBmZCBidWZmZXIgZmlyc3Qub2Zmc2V0IGZpcnN0Lmxlbmd0aFxuICAgICAgfCBCaWdhcnJheSBidWZmZXIgLT5cbiAgICAgICAgcmVhZF9iaWdhcnJheSBcIkx3dF91bml4LnJlYWR2XCIgZmQgYnVmZmVyIGZpcnN0Lm9mZnNldCBmaXJzdC5sZW5ndGhcblxuICBlbHNlXG4gICAgTGF6eS5mb3JjZSBmZC5ibG9ja2luZyA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgLT5cbiAgICAgIHdhaXRfcmVhZCBmZCA+Pj0gZnVuICgpIC0+XG4gICAgICBydW5fam9iIChyZWFkdl9qb2IgZmQuZmQgaW9fdmVjdG9ycyBjb3VudClcbiAgICB8IGZhbHNlIC0+XG4gICAgICB3cmFwX3N5c2NhbGwgUmVhZCBmZCAoZnVuICgpIC0+XG4gICAgICAgIHN0dWJfcmVhZHYgZmQuZmQgaW9fdmVjdG9ycy5JT192ZWN0b3JzLnByZWZpeCBjb3VudClcblxuZXh0ZXJuYWwgc3R1Yl93cml0ZXYgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gSU9fdmVjdG9ycy5pb192ZWN0b3IgbGlzdCAtPiBpbnQgLT4gaW50ID1cbiAgXCJsd3RfdW5peF93cml0ZXZcIlxuXG5leHRlcm5hbCB3cml0ZXZfam9iIDogVW5peC5maWxlX2Rlc2NyIC0+IElPX3ZlY3RvcnMudCAtPiBpbnQgLT4gaW50IGpvYiA9XG4gIFwibHd0X3VuaXhfd3JpdGV2X2pvYlwiXG5cbmxldCB3cml0ZXYgZmQgaW9fdmVjdG9ycyA9XG4gIGxldCBjb3VudCA9IGNoZWNrX2lvX3ZlY3RvcnMgXCJMd3RfdW5peC53cml0ZXZcIiBpb192ZWN0b3JzIGluXG5cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBtYXRjaCBpb192ZWN0b3JzLklPX3ZlY3RvcnMucHJlZml4IHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBMd3QucmV0dXJuIDBcbiAgICB8IGZpcnN0OjpfIC0+XG4gICAgICBtYXRjaCBmaXJzdC5idWZmZXIgd2l0aFxuICAgICAgfCBCeXRlcyBidWZmZXIgLT5cbiAgICAgICAgd3JpdGUgZmQgYnVmZmVyIGZpcnN0Lm9mZnNldCBmaXJzdC5sZW5ndGhcbiAgICAgIHwgQmlnYXJyYXkgYnVmZmVyIC0+XG4gICAgICAgIHdyaXRlX2JpZ2FycmF5IFwiTHd0X3VuaXgud3JpdGV2XCIgZmQgYnVmZmVyIGZpcnN0Lm9mZnNldCBmaXJzdC5sZW5ndGhcblxuICBlbHNlXG4gICAgTGF6eS5mb3JjZSBmZC5ibG9ja2luZyA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgLT5cbiAgICAgIHdhaXRfd3JpdGUgZmQgPj49IGZ1biAoKSAtPlxuICAgICAgcnVuX2pvYiAod3JpdGV2X2pvYiBmZC5mZCBpb192ZWN0b3JzIGNvdW50KVxuICAgIHwgZmFsc2UgLT5cbiAgICAgIHdyYXBfc3lzY2FsbCBXcml0ZSBmZCAoZnVuICgpIC0+XG4gICAgICAgIHN0dWJfd3JpdGV2IGZkLmZkIGlvX3ZlY3RvcnMuSU9fdmVjdG9ycy5wcmVmaXggY291bnQpXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgU2Vla2luZyBhbmQgdHJ1bmNhdGluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxudHlwZSBzZWVrX2NvbW1hbmQgPVxuICBVbml4LnNlZWtfY29tbWFuZCA9XG4gIHwgU0VFS19TRVRcbiAgfCBTRUVLX0NVUlxuICB8IFNFRUtfRU5EXG5cbmV4dGVybmFsIGxzZWVrX2pvYiA6XG4gIFVuaXguZmlsZV9kZXNjciAtPiBpbnQgLT4gVW5peC5zZWVrX2NvbW1hbmQgLT4gaW50IGpvYiA9IFwibHd0X3VuaXhfbHNlZWtfam9iXCJcblxubGV0IGxzZWVrIGNoIG9mZnNldCB3aGVuY2UgPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXgubHNlZWsgY2guZmQgb2Zmc2V0IHdoZW5jZSlcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKGxzZWVrX2pvYiBjaC5mZCBvZmZzZXQgd2hlbmNlKVxuXG5leHRlcm5hbCB0cnVuY2F0ZV9qb2IgOiBzdHJpbmcgLT4gaW50IC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF90cnVuY2F0ZV9qb2JcIlxuXG5sZXQgdHJ1bmNhdGUgbmFtZSBvZmZzZXQgPVxuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXgudHJ1bmNhdGUgbmFtZSBvZmZzZXQpXG4gIGVsc2VcbiAgICBydW5fam9iICh0cnVuY2F0ZV9qb2IgbmFtZSBvZmZzZXQpXG5cbmV4dGVybmFsIGZ0cnVuY2F0ZV9qb2IgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gaW50IC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF9mdHJ1bmNhdGVfam9iXCJcblxubGV0IGZ0cnVuY2F0ZSBjaCBvZmZzZXQgPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXguZnRydW5jYXRlIGNoLmZkIG9mZnNldClcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKGZ0cnVuY2F0ZV9qb2IgY2guZmQgb2Zmc2V0KVxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IEZpbGUgc3lzdGVtIHN5bmNocm9uaXNhdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmV4dGVybmFsIGZkYXRhc3luY19qb2IgOiBVbml4LmZpbGVfZGVzY3IgLT4gdW5pdCBqb2IgPSBcImx3dF91bml4X2ZkYXRhc3luY19qb2JcIlxuXG5sZXQgZmRhdGFzeW5jIGNoID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgcnVuX2pvYiAoZmRhdGFzeW5jX2pvYiBjaC5mZClcblxuZXh0ZXJuYWwgZnN5bmNfam9iIDogVW5peC5maWxlX2Rlc2NyIC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF9mc3luY19qb2JcIlxuXG5sZXQgZnN5bmMgY2ggPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBydW5fam9iIChmc3luY19qb2IgY2guZmQpXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgRmlsZSBzdGF0dXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxudHlwZSBmaWxlX3Blcm0gPSBVbml4LmZpbGVfcGVybVxuXG50eXBlIGZpbGVfa2luZCA9XG4gIFVuaXguZmlsZV9raW5kID1cbiAgfCBTX1JFR1xuICB8IFNfRElSXG4gIHwgU19DSFJcbiAgfCBTX0JMS1xuICB8IFNfTE5LXG4gIHwgU19GSUZPXG4gIHwgU19TT0NLXG5cbnR5cGUgc3RhdHMgPVxuICBVbml4LnN0YXRzID1cbiAge1xuICAgIHN0X2RldiA6IGludDtcbiAgICBzdF9pbm8gOiBpbnQ7XG4gICAgc3Rfa2luZCA6IGZpbGVfa2luZDtcbiAgICBzdF9wZXJtIDogZmlsZV9wZXJtO1xuICAgIHN0X25saW5rIDogaW50O1xuICAgIHN0X3VpZCA6IGludDtcbiAgICBzdF9naWQgOiBpbnQ7XG4gICAgc3RfcmRldiA6IGludDtcbiAgICBzdF9zaXplIDogaW50O1xuICAgIHN0X2F0aW1lIDogZmxvYXQ7XG4gICAgc3RfbXRpbWUgOiBmbG9hdDtcbiAgICBzdF9jdGltZSA6IGZsb2F0O1xuICB9XG5cbmV4dGVybmFsIHN0YXRfam9iIDogc3RyaW5nIC0+IFVuaXguc3RhdHMgam9iID0gXCJsd3RfdW5peF9zdGF0X2pvYlwiXG5cbmxldCBzdGF0IG5hbWUgPVxuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXguc3RhdCBuYW1lKVxuICBlbHNlXG4gICAgcnVuX2pvYiAoc3RhdF9qb2IgbmFtZSlcblxuZXh0ZXJuYWwgbHN0YXRfam9iIDogc3RyaW5nIC0+IFVuaXguc3RhdHMgam9iID0gXCJsd3RfdW5peF9sc3RhdF9qb2JcIlxuXG5sZXQgbHN0YXQgbmFtZSA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5sc3RhdCBuYW1lKVxuICBlbHNlXG4gICAgcnVuX2pvYiAobHN0YXRfam9iIG5hbWUpXG5cbmV4dGVybmFsIGZzdGF0X2pvYiA6IFVuaXguZmlsZV9kZXNjciAtPiBVbml4LnN0YXRzIGpvYiA9IFwibHd0X3VuaXhfZnN0YXRfam9iXCJcblxubGV0IGZzdGF0IGNoID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmZzdGF0IGNoLmZkKVxuICBlbHNlXG4gICAgcnVuX2pvYiAoZnN0YXRfam9iIGNoLmZkKVxuXG5sZXQgZmlsZV9leGlzdHMgbmFtZSA9XG4gIEx3dC50cnlfYmluZFxuICAgIChmdW4gKCkgLT4gc3RhdCBuYW1lKVxuICAgIChmdW4gXyAtPiBMd3QucmV0dXJuX3RydWUpXG4gICAgKGZ1biBlIC0+XG4gICAgICAgbWF0Y2ggZSB3aXRoXG4gICAgICAgfCBVbml4LlVuaXhfZXJyb3IgXyAtPiBMd3QucmV0dXJuX2ZhbHNlXG4gICAgICAgfCBfIC0+IEx3dC5yZXJhaXNlIGUpIFtAb2NhbWwud2FybmluZyBcIi00XCJdXG5cbmV4dGVybmFsIHV0aW1lc19qb2IgOiBzdHJpbmcgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBqb2IgPVxuICBcImx3dF91bml4X3V0aW1lc19qb2JcIlxuXG5sZXQgdXRpbWVzIHBhdGggYXRpbWUgbXRpbWUgPVxuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXgudXRpbWVzIHBhdGggYXRpbWUgbXRpbWUpXG4gIGVsc2VcbiAgICBydW5fam9iICh1dGltZXNfam9iIHBhdGggYXRpbWUgbXRpbWUpXG5cbmV4dGVybmFsIGlzYXR0eV9qb2IgOiBVbml4LmZpbGVfZGVzY3IgLT4gYm9vbCBqb2IgPSBcImx3dF91bml4X2lzYXR0eV9qb2JcIlxuXG5sZXQgaXNhdHR5IGNoID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmlzYXR0eSBjaC5mZClcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKGlzYXR0eV9qb2IgY2guZmQpXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgRmlsZSBvcGVyYXRpb25zIG9uIGxhcmdlIGZpbGVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG5zdHJ1Y3RcblxuICB0eXBlIHN0YXRzID1cbiAgICBVbml4LkxhcmdlRmlsZS5zdGF0cyA9XG4gICAge1xuICAgICAgc3RfZGV2IDogaW50O1xuICAgICAgc3RfaW5vIDogaW50O1xuICAgICAgc3Rfa2luZCA6IGZpbGVfa2luZDtcbiAgICAgIHN0X3Blcm0gOiBmaWxlX3Blcm07XG4gICAgICBzdF9ubGluayA6IGludDtcbiAgICAgIHN0X3VpZCA6IGludDtcbiAgICAgIHN0X2dpZCA6IGludDtcbiAgICAgIHN0X3JkZXYgOiBpbnQ7XG4gICAgICBzdF9zaXplIDogaW50NjQ7XG4gICAgICBzdF9hdGltZSA6IGZsb2F0O1xuICAgICAgc3RfbXRpbWUgOiBmbG9hdDtcbiAgICAgIHN0X2N0aW1lIDogZmxvYXQ7XG4gICAgfVxuXG4gIGV4dGVybmFsIGxzZWVrXzY0X2pvYiA6XG4gICAgVW5peC5maWxlX2Rlc2NyIC0+IGludDY0IC0+IFVuaXguc2Vla19jb21tYW5kIC0+IGludDY0IGpvYiA9XG4gICAgXCJsd3RfdW5peF9sc2Vla182NF9qb2JcIlxuXG4gIGxldCBsc2VlayBjaCBvZmZzZXQgd2hlbmNlID1cbiAgICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICAgIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgICBMd3QucmV0dXJuIChVbml4LkxhcmdlRmlsZS5sc2VlayBjaC5mZCBvZmZzZXQgd2hlbmNlKVxuICAgIGVsc2VcbiAgICAgIHJ1bl9qb2IgKGxzZWVrXzY0X2pvYiBjaC5mZCBvZmZzZXQgd2hlbmNlKVxuXG4gIGV4dGVybmFsIHRydW5jYXRlXzY0X2pvYiA6XG4gICAgc3RyaW5nIC0+IGludDY0IC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF90cnVuY2F0ZV82NF9qb2JcIlxuXG4gIGxldCB0cnVuY2F0ZSBuYW1lIG9mZnNldCA9XG4gICAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICAgIEx3dC5yZXR1cm4gKFVuaXguTGFyZ2VGaWxlLnRydW5jYXRlIG5hbWUgb2Zmc2V0KVxuICAgIGVsc2VcbiAgICAgIHJ1bl9qb2IgKHRydW5jYXRlXzY0X2pvYiBuYW1lIG9mZnNldClcblxuICBleHRlcm5hbCBmdHJ1bmNhdGVfNjRfam9iIDpcbiAgICBVbml4LmZpbGVfZGVzY3IgLT4gaW50NjQgLT4gdW5pdCBqb2IgPSBcImx3dF91bml4X2Z0cnVuY2F0ZV82NF9qb2JcIlxuXG4gIGxldCBmdHJ1bmNhdGUgY2ggb2Zmc2V0ID1cbiAgICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICAgIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgICBMd3QucmV0dXJuIChVbml4LkxhcmdlRmlsZS5mdHJ1bmNhdGUgY2guZmQgb2Zmc2V0KVxuICAgIGVsc2VcbiAgICAgIHJ1bl9qb2IgKGZ0cnVuY2F0ZV82NF9qb2IgY2guZmQgb2Zmc2V0KVxuXG4gIGV4dGVybmFsIHN0YXRfam9iIDogc3RyaW5nIC0+IFVuaXguTGFyZ2VGaWxlLnN0YXRzIGpvYiA9IFwibHd0X3VuaXhfc3RhdF82NF9qb2JcIlxuXG4gIGxldCBzdGF0IG5hbWUgPVxuICAgIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgICBMd3QucmV0dXJuIChVbml4LkxhcmdlRmlsZS5zdGF0IG5hbWUpXG4gICAgZWxzZVxuICAgICAgcnVuX2pvYiAoc3RhdF9qb2IgbmFtZSlcblxuICBleHRlcm5hbCBsc3RhdF9qb2IgOiBzdHJpbmcgLT4gVW5peC5MYXJnZUZpbGUuc3RhdHMgam9iID0gXCJsd3RfdW5peF9sc3RhdF82NF9qb2JcIlxuXG4gIGxldCBsc3RhdCBuYW1lID1cbiAgICBpZiBTeXMud2luMzIgdGhlblxuICAgICAgTHd0LnJldHVybiAoVW5peC5MYXJnZUZpbGUubHN0YXQgbmFtZSlcbiAgICBlbHNlXG4gICAgICBydW5fam9iIChsc3RhdF9qb2IgbmFtZSlcblxuICBleHRlcm5hbCBmc3RhdF9qb2IgOiBVbml4LmZpbGVfZGVzY3IgLT4gVW5peC5MYXJnZUZpbGUuc3RhdHMgam9iID0gXCJsd3RfdW5peF9mc3RhdF82NF9qb2JcIlxuXG4gIGxldCBmc3RhdCBjaCA9XG4gICAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgICBpZiBTeXMud2luMzIgdGhlblxuICAgICAgTHd0LnJldHVybiAoVW5peC5MYXJnZUZpbGUuZnN0YXQgY2guZmQpXG4gICAgZWxzZVxuICAgICAgcnVuX2pvYiAoZnN0YXRfam9iIGNoLmZkKVxuXG4gIGxldCBmaWxlX2V4aXN0cyBuYW1lID1cbiAgICBMd3QudHJ5X2JpbmRcbiAgICAgIChmdW4gKCkgLT4gc3RhdCBuYW1lKVxuICAgICAgKGZ1biBfIC0+IEx3dC5yZXR1cm5fdHJ1ZSlcbiAgICAgIChmdW4gZSAtPlxuICAgICAgICAgbWF0Y2ggZSB3aXRoXG4gICAgICAgICB8IFVuaXguVW5peF9lcnJvciBfIC0+IEx3dC5yZXR1cm5fZmFsc2VcbiAgICAgICAgIHwgXyAtPiBMd3QucmVyYWlzZSBlKSBbQG9jYW1sLndhcm5pbmcgXCItNFwiXVxuXG5lbmRcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBPcGVyYXRpb25zIG9uIGZpbGUgbmFtZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG5leHRlcm5hbCB1bmxpbmtfam9iIDogc3RyaW5nIC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF91bmxpbmtfam9iXCJcblxubGV0IHVubGluayBuYW1lID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LnVubGluayBuYW1lKVxuICBlbHNlXG4gICAgcnVuX2pvYiAodW5saW5rX2pvYiBuYW1lKVxuXG5leHRlcm5hbCByZW5hbWVfam9iIDogc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0IGpvYiA9IFwibHd0X3VuaXhfcmVuYW1lX2pvYlwiXG5cbmxldCByZW5hbWUgbmFtZTEgbmFtZTIgPVxuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXgucmVuYW1lIG5hbWUxIG5hbWUyKVxuICBlbHNlXG4gICAgcnVuX2pvYiAocmVuYW1lX2pvYiBuYW1lMSBuYW1lMilcblxuZXh0ZXJuYWwgbGlua19qb2IgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF9saW5rX2pvYlwiXG5cbmxldCBsaW5rIG9sZHBhdGggbmV3cGF0aCA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5saW5rIG9sZHBhdGggbmV3cGF0aClcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKGxpbmtfam9iIG9sZHBhdGggbmV3cGF0aClcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBGaWxlIHBlcm1pc3Npb25zIGFuZCBvd25lcnNoaXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG5leHRlcm5hbCBjaG1vZF9qb2IgOiBzdHJpbmcgLT4gaW50IC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF9jaG1vZF9qb2JcIlxuXG5sZXQgY2htb2QgbmFtZSBtb2RlID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmNobW9kIG5hbWUgbW9kZSlcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKGNobW9kX2pvYiBuYW1lIG1vZGUpXG5cbmV4dGVybmFsIGZjaG1vZF9qb2IgOiBVbml4LmZpbGVfZGVzY3IgLT4gaW50IC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF9mY2htb2Rfam9iXCJcblxubGV0IGZjaG1vZCBjaCBtb2RlID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmZjaG1vZCBjaC5mZCBtb2RlKVxuICBlbHNlXG4gICAgcnVuX2pvYiAoZmNobW9kX2pvYiBjaC5mZCBtb2RlKVxuXG5leHRlcm5hbCBjaG93bl9qb2IgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0IGpvYiA9IFwibHd0X3VuaXhfY2hvd25fam9iXCJcblxubGV0IGNob3duIG5hbWUgdWlkIGdpZCA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5jaG93biBuYW1lIHVpZCBnaWQpXG4gIGVsc2VcbiAgICBydW5fam9iIChjaG93bl9qb2IgbmFtZSB1aWQgZ2lkKVxuXG5leHRlcm5hbCBmY2hvd25fam9iIDpcbiAgVW5peC5maWxlX2Rlc2NyIC0+IGludCAtPiBpbnQgLT4gdW5pdCBqb2IgPSBcImx3dF91bml4X2ZjaG93bl9qb2JcIlxuXG5sZXQgZmNob3duIGNoIHVpZCBnaWQgPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXguZmNob3duIGNoLmZkIHVpZCBnaWQpXG4gIGVsc2VcbiAgICBydW5fam9iIChmY2hvd25fam9iIGNoLmZkIHVpZCBnaWQpXG5cbnR5cGUgYWNjZXNzX3Blcm1pc3Npb24gPVxuICBVbml4LmFjY2Vzc19wZXJtaXNzaW9uID1cbiAgfCBSX09LXG4gIHwgV19PS1xuICB8IFhfT0tcbiAgfCBGX09LXG5cbmV4dGVybmFsIGFjY2Vzc19qb2IgOlxuICBzdHJpbmcgLT4gVW5peC5hY2Nlc3NfcGVybWlzc2lvbiBsaXN0IC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF9hY2Nlc3Nfam9iXCJcblxubGV0IGFjY2VzcyBuYW1lIG1vZGUgPVxuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXguYWNjZXNzIG5hbWUgbW9kZSlcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKGFjY2Vzc19qb2IgbmFtZSBtb2RlKVxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IE9wZXJhdGlvbnMgb24gZmlsZSBkZXNjcmlwdG9ycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBkdXAgP2Nsb2V4ZWMgY2ggPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBsZXQgZmQgPSBVbml4LmR1cCA/Y2xvZXhlYyBjaC5mZCBpblxuICB7XG4gICAgZmQgPSBmZDtcbiAgICBzdGF0ZSA9IE9wZW5lZDtcbiAgICBzZXRfZmxhZ3MgPSBjaC5zZXRfZmxhZ3M7XG4gICAgYmxvY2tpbmcgPVxuICAgICAgaWYgY2guc2V0X2ZsYWdzIHRoZW5cbiAgICAgICAgbGF6eShMYXp5LmZvcmNlIGNoLmJsb2NraW5nID4+PSBmdW5jdGlvbiBibG9ja2luZyAtPlxuICAgICAgICAgICAgICAgTGF6eS5mb3JjZSAoaXNfYmxvY2tpbmcgfmJsb2NraW5nIGZkKSlcbiAgICAgIGVsc2VcbiAgICAgICAgY2guYmxvY2tpbmc7XG4gICAgZXZlbnRfcmVhZGFibGUgPSBOb25lO1xuICAgIGV2ZW50X3dyaXRhYmxlID0gTm9uZTtcbiAgICBob29rc19yZWFkYWJsZSA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCk7XG4gICAgaG9va3Nfd3JpdGFibGUgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpO1xuICB9XG5cbmxldCBkdXAyID9jbG9leGVjIGNoMSBjaDIgPVxuICBjaGVja19kZXNjcmlwdG9yIGNoMTtcbiAgVW5peC5kdXAyID9jbG9leGVjIGNoMS5mZCBjaDIuZmQ7XG4gIGNoMi5zZXRfZmxhZ3MgPC0gY2gxLnNldF9mbGFncztcbiAgY2gyLmJsb2NraW5nIDwtIChcbiAgICBpZiBjaDIuc2V0X2ZsYWdzIHRoZW5cbiAgICAgIGxhenkoTGF6eS5mb3JjZSBjaDEuYmxvY2tpbmcgPj49IGZ1bmN0aW9uIGJsb2NraW5nIC0+XG4gICAgICAgICAgICAgTGF6eS5mb3JjZSAoaXNfYmxvY2tpbmcgfmJsb2NraW5nIGNoMi5mZCkpXG4gICAgZWxzZVxuICAgICAgY2gxLmJsb2NraW5nXG4gIClcblxubGV0IHNldF9jbG9zZV9vbl9leGVjIGNoID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgVW5peC5zZXRfY2xvc2Vfb25fZXhlYyBjaC5mZFxuXG5sZXQgY2xlYXJfY2xvc2Vfb25fZXhlYyBjaCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIFVuaXguY2xlYXJfY2xvc2Vfb25fZXhlYyBjaC5mZFxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IERpcmVjdG9yaWVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmV4dGVybmFsIG1rZGlyX2pvYiA6IHN0cmluZyAtPiBpbnQgLT4gdW5pdCBqb2IgPSBcImx3dF91bml4X21rZGlyX2pvYlwiXG5cbmxldCBta2RpciBuYW1lIHBlcm1zID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4Lm1rZGlyIG5hbWUgcGVybXMpXG4gIGVsc2VcbiAgICBydW5fam9iIChta2Rpcl9qb2IgbmFtZSBwZXJtcylcblxuZXh0ZXJuYWwgcm1kaXJfam9iIDogc3RyaW5nIC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF9ybWRpcl9qb2JcIlxuXG5sZXQgcm1kaXIgbmFtZSA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5ybWRpciBuYW1lKVxuICBlbHNlXG4gICAgcnVuX2pvYiAocm1kaXJfam9iIG5hbWUpXG5cbmV4dGVybmFsIGNoZGlyX2pvYiA6IHN0cmluZyAtPiB1bml0IGpvYiA9IFwibHd0X3VuaXhfY2hkaXJfam9iXCJcblxubGV0IGNoZGlyIG5hbWUgPVxuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXguY2hkaXIgbmFtZSlcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKGNoZGlyX2pvYiBuYW1lKVxuXG5leHRlcm5hbCBnZXRjd2Rfam9iIDogdW5pdCAtPiBzdHJpbmcgam9iID0gXCJsd3RfdW5peF9nZXRjd2Rfam9iXCJcblxubGV0IGdldGN3ZCAoKSA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5nZXRjd2QgKCkpXG4gIGVsc2VcbiAgICBydW5fam9iIChnZXRjd2Rfam9iICgpKVxuXG5leHRlcm5hbCBjaHJvb3Rfam9iIDogc3RyaW5nIC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF9jaHJvb3Rfam9iXCJcblxubGV0IGNocm9vdCBuYW1lID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmNocm9vdCBuYW1lKVxuICBlbHNlXG4gICAgcnVuX2pvYiAoY2hyb290X2pvYiBuYW1lKVxuXG50eXBlIGRpcl9oYW5kbGUgPSBVbml4LmRpcl9oYW5kbGVcblxuZXh0ZXJuYWwgb3BlbmRpcl9qb2IgOiBzdHJpbmcgLT4gVW5peC5kaXJfaGFuZGxlIGpvYiA9IFwibHd0X3VuaXhfb3BlbmRpcl9qb2JcIlxuXG5sZXQgb3BlbmRpciBuYW1lID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4Lm9wZW5kaXIgbmFtZSlcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKG9wZW5kaXJfam9iIG5hbWUpXG5cbmV4dGVybmFsIHZhbGlkX2RpciA6IFVuaXguZGlyX2hhbmRsZSAtPiBib29sID0gXCJsd3RfdW5peF92YWxpZF9kaXJcIlxuZXh0ZXJuYWwgcmVhZGRpcl9qb2IgOiBVbml4LmRpcl9oYW5kbGUgLT4gc3RyaW5nIGpvYiA9IFwibHd0X3VuaXhfcmVhZGRpcl9qb2JcIlxuXG5sZXQgcmVhZGRpciBoYW5kbGUgPVxuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXgucmVhZGRpciBoYW5kbGUpXG4gIGVsc2VcbiAgaWYgdmFsaWRfZGlyIGhhbmRsZSB0aGVuXG4gICAgcnVuX2pvYiAocmVhZGRpcl9qb2IgaGFuZGxlKVxuICBlbHNlXG4gICAgTHd0LmZhaWwgKFVuaXguKFVuaXhfZXJyb3IgKEVCQURGLCBcIkx3dF91bml4LnJlYWRkaXJcIiwgXCJcIikpKVxuXG5leHRlcm5hbCByZWFkZGlyX25fam9iIDogVW5peC5kaXJfaGFuZGxlIC0+IGludCAtPiBzdHJpbmcgYXJyYXkgam9iID0gXCJsd3RfdW5peF9yZWFkZGlyX25fam9iXCJcblxubGV0IHJlYWRkaXJfbiBoYW5kbGUgY291bnQgPVxuICBpZiBjb3VudCA8IDAgdGhlblxuICAgIEx3dC5mYWlsIChJbnZhbGlkX2FyZ3VtZW50IFwiTHd0X3VuaXgucmVhZGRpcl9uXCIpXG4gIGVsc2UgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBsZXQgYXJyYXkgPSBBcnJheS5tYWtlIGNvdW50IFwiXCIgaW5cbiAgICBsZXQgcmVjIGZpbGwgaSA9XG4gICAgICBpZiBpID0gY291bnQgdGhlblxuICAgICAgICBMd3QucmV0dXJuIGFycmF5XG4gICAgICBlbHNlXG4gICAgICAgIG1hdGNoIGFycmF5LihpKSA8LSBVbml4LnJlYWRkaXIgaGFuZGxlIHdpdGhcbiAgICAgICAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTHd0LnJldHVybiAoQXJyYXkuc3ViIGFycmF5IDAgaSlcbiAgICAgICAgfCAoKSAtPiBmaWxsIChpICsgMSlcbiAgICBpblxuICAgIGZpbGwgMFxuICBlbHNlXG4gIGlmIHZhbGlkX2RpciBoYW5kbGUgdGhlblxuICAgIHJ1bl9qb2IgKHJlYWRkaXJfbl9qb2IgaGFuZGxlIGNvdW50KVxuICBlbHNlXG4gICAgTHd0LmZhaWwgKFVuaXguKFVuaXhfZXJyb3IgKEVCQURGLCBcIkx3dF91bml4LnJlYWRkaXJfblwiLCBcIlwiKSkpXG5cbmV4dGVybmFsIHJld2luZGRpcl9qb2IgOiBVbml4LmRpcl9oYW5kbGUgLT4gdW5pdCBqb2IgPSBcImx3dF91bml4X3Jld2luZGRpcl9qb2JcIlxuXG5sZXQgcmV3aW5kZGlyIGhhbmRsZSA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5yZXdpbmRkaXIgaGFuZGxlKVxuICBlbHNlXG4gIGlmIHZhbGlkX2RpciBoYW5kbGUgdGhlblxuICAgIHJ1bl9qb2IgKHJld2luZGRpcl9qb2IgaGFuZGxlKVxuICBlbHNlXG4gICAgTHd0LmZhaWwgKFVuaXguKFVuaXhfZXJyb3IgKEVCQURGLCBcIkx3dF91bml4LnJld2luZGRpclwiLCBcIlwiKSkpXG5cbmV4dGVybmFsIGNsb3NlZGlyX2pvYiA6IFVuaXguZGlyX2hhbmRsZSAtPiB1bml0IGpvYiA9IFwibHd0X3VuaXhfY2xvc2VkaXJfam9iXCJcbmV4dGVybmFsIGludmFsaWRhdGVfZGlyIDogVW5peC5kaXJfaGFuZGxlIC0+IHVuaXQgPSBcImx3dF91bml4X2ludmFsaWRhdGVfZGlyXCJcblxubGV0IGNsb3NlZGlyIGhhbmRsZSA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5jbG9zZWRpciBoYW5kbGUpXG4gIGVsc2VcbiAgaWYgdmFsaWRfZGlyIGhhbmRsZSB0aGVuXG4gICAgcnVuX2pvYiAoY2xvc2VkaXJfam9iIGhhbmRsZSkgPj49IGZ1biAoKSAtPlxuICAgIGludmFsaWRhdGVfZGlyIGhhbmRsZTtcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgZWxzZVxuICAgIEx3dC5mYWlsIChVbml4LihVbml4X2Vycm9yIChFQkFERiwgXCJMd3RfdW5peC5jbG9zZWRpclwiLCBcIlwiKSkpXG5cbnR5cGUgbGlzdF9kaXJlY3Rvcnlfc3RhdGUgID1cbiAgfCBMRFNfbm90X3N0YXJ0ZWRcbiAgfCBMRFNfbGlzdGluZyBvZiBVbml4LmRpcl9oYW5kbGVcbiAgfCBMRFNfZG9uZVxuXG5sZXQgY2xlYW51cF9kaXJfaGFuZGxlIHN0YXRlID1cbiAgbWF0Y2ggIXN0YXRlIHdpdGhcbiAgfCBMRFNfbGlzdGluZyBoYW5kbGUgLT5cbiAgICBpZ25vcmUgKGNsb3NlZGlyIGhhbmRsZSlcbiAgfCBMRFNfbm90X3N0YXJ0ZWQgfCBMRFNfZG9uZSAtPlxuICAgICgpXG5cbmxldCBmaWxlc19vZl9kaXJlY3RvcnkgcGF0aCA9XG4gIGxldCBjaHVua19zaXplID0gMTAyNCBpblxuICBsZXQgc3RhdGUgPSByZWYgTERTX25vdF9zdGFydGVkIGluXG4gIEx3dF9zdHJlYW0uY29uY2F0XG4gICAgKEx3dF9zdHJlYW0uZnJvbVxuICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICBtYXRjaCAhc3RhdGUgd2l0aFxuICAgICAgICAgIHwgTERTX25vdF9zdGFydGVkIC0+XG4gICAgICAgICAgICBvcGVuZGlyIHBhdGggPj49IGZ1biBoYW5kbGUgLT5cbiAgICAgICAgICAgIEx3dC5jYXRjaFxuICAgICAgICAgICAgICAoZnVuICgpIC0+IHJlYWRkaXJfbiBoYW5kbGUgY2h1bmtfc2l6ZSlcbiAgICAgICAgICAgICAgKGZ1biBleG4gLT5cbiAgICAgICAgICAgICAgICAgY2xvc2VkaXIgaGFuZGxlID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgTHd0LnJlcmFpc2UgZXhuKSA+Pj0gZnVuIGVudHJpZXMgLT5cbiAgICAgICAgICAgIGlmIEFycmF5Lmxlbmd0aCBlbnRyaWVzIDwgY2h1bmtfc2l6ZSB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIHN0YXRlIDo9IExEU19kb25lO1xuICAgICAgICAgICAgICBjbG9zZWRpciBoYW5kbGUgPj49IGZ1biAoKSAtPlxuICAgICAgICAgICAgICBMd3QucmV0dXJuIChTb21lKEx3dF9zdHJlYW0ub2ZfYXJyYXkgZW50cmllcykpXG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBzdGF0ZSA6PSBMRFNfbGlzdGluZyBoYW5kbGU7XG4gICAgICAgICAgICAgIEdjLmZpbmFsaXNlIGNsZWFudXBfZGlyX2hhbmRsZSBzdGF0ZTtcbiAgICAgICAgICAgICAgTHd0LnJldHVybiAoU29tZShMd3Rfc3RyZWFtLm9mX2FycmF5IGVudHJpZXMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBMRFNfbGlzdGluZyBoYW5kbGUgLT5cbiAgICAgICAgICAgIEx3dC5jYXRjaFxuICAgICAgICAgICAgICAoZnVuICgpIC0+IHJlYWRkaXJfbiBoYW5kbGUgY2h1bmtfc2l6ZSlcbiAgICAgICAgICAgICAgKGZ1biBleG4gLT5cbiAgICAgICAgICAgICAgICAgY2xvc2VkaXIgaGFuZGxlID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgTHd0LnJlcmFpc2UgZXhuKSA+Pj0gZnVuIGVudHJpZXMgLT5cbiAgICAgICAgICAgIGlmIEFycmF5Lmxlbmd0aCBlbnRyaWVzIDwgY2h1bmtfc2l6ZSB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIHN0YXRlIDo9IExEU19kb25lO1xuICAgICAgICAgICAgICBjbG9zZWRpciBoYW5kbGUgPj49IGZ1biAoKSAtPlxuICAgICAgICAgICAgICBMd3QucmV0dXJuIChTb21lKEx3dF9zdHJlYW0ub2ZfYXJyYXkgZW50cmllcykpXG4gICAgICAgICAgICBlbmQgZWxzZVxuICAgICAgICAgICAgICBMd3QucmV0dXJuIChTb21lKEx3dF9zdHJlYW0ub2ZfYXJyYXkgZW50cmllcykpXG4gICAgICAgICAgfCBMRFNfZG9uZSAtPlxuICAgICAgICAgICAgTHd0LnJldHVybl9ub25lKSlcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBQaXBlcyBhbmQgcmVkaXJlY3Rpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG5sZXQgcGlwZSA/Y2xvZXhlYyAoKSA9XG4gIGxldCAob3V0X2ZkLCBpbl9mZCkgPSBVbml4LnBpcGUgP2Nsb2V4ZWMgKCkgaW5cbiAgKG1rX2NoIH5ibG9ja2luZzpTeXMud2luMzIgb3V0X2ZkLCBta19jaCB+YmxvY2tpbmc6U3lzLndpbjMyIGluX2ZkKVxuXG5sZXQgcGlwZV9pbiA/Y2xvZXhlYyAoKSA9XG4gICBsZXQgKG91dF9mZCwgaW5fZmQpID0gVW5peC5waXBlID9jbG9leGVjICgpIGluXG4gIChta19jaCB+YmxvY2tpbmc6U3lzLndpbjMyIG91dF9mZCwgaW5fZmQpXG5cbmxldCBwaXBlX291dCA/Y2xvZXhlYyAoKSA9XG4gIGxldCAob3V0X2ZkLCBpbl9mZCkgPSBVbml4LnBpcGUgP2Nsb2V4ZWMgKCkgaW5cbiAgKG91dF9mZCwgbWtfY2ggfmJsb2NraW5nOlN5cy53aW4zMiBpbl9mZClcblxuZXh0ZXJuYWwgbWtmaWZvX2pvYiA6IHN0cmluZyAtPiBpbnQgLT4gdW5pdCBqb2IgPSBcImx3dF91bml4X21rZmlmb19qb2JcIlxuXG5sZXQgbWtmaWZvIG5hbWUgcGVybXMgPVxuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXgubWtmaWZvIG5hbWUgcGVybXMpXG4gIGVsc2VcbiAgICBydW5fam9iIChta2ZpZm9fam9iIG5hbWUgcGVybXMpXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgU3ltYm9saWMgbGlua3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxuZXh0ZXJuYWwgc3ltbGlua19qb2IgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF9zeW1saW5rX2pvYlwiXG5cbmxldCBzeW1saW5rID90b19kaXIgbmFtZTEgbmFtZTIgPVxuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXguc3ltbGluayA/dG9fZGlyIG5hbWUxIG5hbWUyKVxuICBlbHNlXG4gICAgcnVuX2pvYiAoc3ltbGlua19qb2IgbmFtZTEgbmFtZTIpXG5cbmV4dGVybmFsIHJlYWRsaW5rX2pvYiA6IHN0cmluZyAtPiBzdHJpbmcgam9iID0gXCJsd3RfdW5peF9yZWFkbGlua19qb2JcIlxuXG5sZXQgcmVhZGxpbmsgbmFtZSA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5yZWFkbGluayBuYW1lKVxuICBlbHNlXG4gICAgcnVuX2pvYiAocmVhZGxpbmtfam9iIG5hbWUpXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgTG9ja2luZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxudHlwZSBsb2NrX2NvbW1hbmQgPVxuICBVbml4LmxvY2tfY29tbWFuZCA9XG4gIHwgRl9VTE9DS1xuICB8IEZfTE9DS1xuICB8IEZfVExPQ0tcbiAgfCBGX1RFU1RcbiAgfCBGX1JMT0NLXG4gIHwgRl9UUkxPQ0tcblxuZXh0ZXJuYWwgbG9ja2Zfam9iIDogVW5peC5maWxlX2Rlc2NyIC0+IFVuaXgubG9ja19jb21tYW5kIC0+IGludCAtPiB1bml0IGpvYiA9IFwibHd0X3VuaXhfbG9ja2Zfam9iXCJcblxubGV0IGxvY2tmIGNoIGNtZCBzaXplID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmxvY2tmIGNoLmZkIGNtZCBzaXplKVxuICBlbHNlXG4gICAgcnVuX2pvYiAobG9ja2Zfam9iIGNoLmZkIGNtZCBzaXplKVxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IFVzZXIgaWQsIGdyb3VwIGlkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbnR5cGUgcGFzc3dkX2VudHJ5ID1cbiAgVW5peC5wYXNzd2RfZW50cnkgPVxuICB7XG4gICAgcHdfbmFtZSA6IHN0cmluZztcbiAgICBwd19wYXNzd2QgOiBzdHJpbmc7XG4gICAgcHdfdWlkIDogaW50O1xuICAgIHB3X2dpZCA6IGludDtcbiAgICBwd19nZWNvcyA6IHN0cmluZztcbiAgICBwd19kaXIgOiBzdHJpbmc7XG4gICAgcHdfc2hlbGwgOiBzdHJpbmdcbiAgfVxuXG50eXBlIGdyb3VwX2VudHJ5ID1cbiAgVW5peC5ncm91cF9lbnRyeSA9XG4gIHtcbiAgICBncl9uYW1lIDogc3RyaW5nO1xuICAgIGdyX3Bhc3N3ZCA6IHN0cmluZztcbiAgICBncl9naWQgOiBpbnQ7XG4gICAgZ3JfbWVtIDogc3RyaW5nIGFycmF5XG4gIH1cblxuZXh0ZXJuYWwgZ2V0bG9naW5fam9iIDogdW5pdCAtPiBzdHJpbmcgam9iID0gXCJsd3RfdW5peF9nZXRsb2dpbl9qb2JcIlxuXG5sZXQgZ2V0bG9naW4gKCkgPVxuICBpZiBTeXMud2luMzIgfHwgTHd0X2NvbmZpZy5hbmRyb2lkIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmdldGxvZ2luICgpKVxuICBlbHNlXG4gICAgcnVuX2pvYiAoZ2V0bG9naW5fam9iICgpKVxuXG5leHRlcm5hbCBnZXRwd25hbV9qb2IgOiBzdHJpbmcgLT4gVW5peC5wYXNzd2RfZW50cnkgam9iID0gXCJsd3RfdW5peF9nZXRwd25hbV9qb2JcIlxuXG5sZXQgZ2V0cHduYW0gbmFtZSA9XG4gIGlmIFN5cy53aW4zMiB8fCBMd3RfY29uZmlnLmFuZHJvaWQgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXguZ2V0cHduYW0gbmFtZSlcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKGdldHB3bmFtX2pvYiBuYW1lKVxuXG5leHRlcm5hbCBnZXRncm5hbV9qb2IgOiBzdHJpbmcgLT4gVW5peC5ncm91cF9lbnRyeSBqb2IgPSBcImx3dF91bml4X2dldGdybmFtX2pvYlwiXG5cbmxldCBnZXRncm5hbSBuYW1lID1cbiAgaWYgU3lzLndpbjMyIHx8IEx3dF9jb25maWcuYW5kcm9pZCB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5nZXRncm5hbSBuYW1lKVxuICBlbHNlXG4gICAgcnVuX2pvYiAoZ2V0Z3JuYW1fam9iIG5hbWUpXG5cbmV4dGVybmFsIGdldHB3dWlkX2pvYiA6IGludCAtPiBVbml4LnBhc3N3ZF9lbnRyeSBqb2IgPSBcImx3dF91bml4X2dldHB3dWlkX2pvYlwiXG5cbmxldCBnZXRwd3VpZCB1aWQgPVxuICBpZiBTeXMud2luMzIgfHwgTHd0X2NvbmZpZy5hbmRyb2lkIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmdldHB3dWlkIHVpZClcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKGdldHB3dWlkX2pvYiB1aWQpXG5cbmV4dGVybmFsIGdldGdyZ2lkX2pvYiA6IGludCAtPiBVbml4Lmdyb3VwX2VudHJ5IGpvYiA9IFwibHd0X3VuaXhfZ2V0Z3JnaWRfam9iXCJcblxubGV0IGdldGdyZ2lkIGdpZCA9XG4gIGlmIFN5cy53aW4zMiB8fCBMd3RfY29uZmlnLmFuZHJvaWQgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXguZ2V0Z3JnaWQgZ2lkKVxuICBlbHNlXG4gICAgcnVuX2pvYiAoZ2V0Z3JnaWRfam9iIGdpZClcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBTb2NrZXRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG50eXBlIG1zZ19mbGFnID1cbiAgVW5peC5tc2dfZmxhZyA9XG4gIHwgTVNHX09PQlxuICB8IE1TR19ET05UUk9VVEVcbiAgfCBNU0dfUEVFS1xuXG5leHRlcm5hbCBzdHViX3JlY3YgOiBVbml4LmZpbGVfZGVzY3IgLT4gQnl0ZXMudCAtPiBpbnQgLT4gaW50IC0+IFVuaXgubXNnX2ZsYWcgbGlzdCAtPiBpbnQgPSBcImx3dF91bml4X3JlY3ZcIlxuXG5sZXQgcmVjdiBjaCBidWYgcG9zIGxlbiBmbGFncyA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB8fCBwb3MgPiBCeXRlcy5sZW5ndGggYnVmIC0gbGVuIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkx3dF91bml4LnJlY3ZcIlxuICBlbHNlXG4gICAgbGV0IGRvX3JlY3YgPSBpZiBTeXMud2luMzIgdGhlbiBVbml4LnJlY3YgZWxzZSBzdHViX3JlY3YgaW5cbiAgICB3cmFwX3N5c2NhbGwgUmVhZCBjaCAoZnVuICgpIC0+IGRvX3JlY3YgY2guZmQgYnVmIHBvcyBsZW4gZmxhZ3MpXG5cbmV4dGVybmFsIHN0dWJfc2VuZCA6IFVuaXguZmlsZV9kZXNjciAtPiBCeXRlcy50IC0+IGludCAtPiBpbnQgLT4gVW5peC5tc2dfZmxhZyBsaXN0IC0+IGludCA9IFwibHd0X3VuaXhfc2VuZFwiXG5cbmxldCBzZW5kIGNoIGJ1ZiBwb3MgbGVuIGZsYWdzID1cbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IEJ5dGVzLmxlbmd0aCBidWYgLSBsZW4gdGhlblxuICAgIGludmFsaWRfYXJnIFwiTHd0X3VuaXguc2VuZFwiXG4gIGVsc2VcbiAgICBsZXQgZG9fc2VuZCA9IGlmIFN5cy53aW4zMiB0aGVuIFVuaXguc2VuZCBlbHNlIHN0dWJfc2VuZCBpblxuICAgIHdyYXBfc3lzY2FsbCBXcml0ZSBjaCAoZnVuICgpIC0+IGRvX3NlbmQgY2guZmQgYnVmIHBvcyBsZW4gZmxhZ3MpXG5cbmV4dGVybmFsIHN0dWJfcmVjdmZyb20gOiBVbml4LmZpbGVfZGVzY3IgLT4gQnl0ZXMudCAtPiBpbnQgLT4gaW50IC0+IFVuaXgubXNnX2ZsYWcgbGlzdCAtPiBpbnQgKiBVbml4LnNvY2thZGRyID0gXCJsd3RfdW5peF9yZWN2ZnJvbVwiXG5cbmxldCByZWN2ZnJvbSBjaCBidWYgcG9zIGxlbiBmbGFncyA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB8fCBwb3MgPiBCeXRlcy5sZW5ndGggYnVmIC0gbGVuIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkx3dF91bml4LnJlY3Zmcm9tXCJcbiAgZWxzZVxuICAgIGxldCBkb19yZWN2ZnJvbSA9IGlmIFN5cy53aW4zMiB0aGVuIFVuaXgucmVjdmZyb20gZWxzZSBzdHViX3JlY3Zmcm9tIGluXG4gICAgd3JhcF9zeXNjYWxsIFJlYWQgY2ggKGZ1biAoKSAtPiBkb19yZWN2ZnJvbSBjaC5mZCBidWYgcG9zIGxlbiBmbGFncylcblxuZXh0ZXJuYWwgc3R1Yl9zZW5kdG8gOiBVbml4LmZpbGVfZGVzY3IgLT4gQnl0ZXMudCAtPiBpbnQgLT4gaW50IC0+IFVuaXgubXNnX2ZsYWcgbGlzdCAtPiBVbml4LnNvY2thZGRyIC0+IGludCA9IFwibHd0X3VuaXhfc2VuZHRvX2J5dGVcIiBcImx3dF91bml4X3NlbmR0b1wiXG5cbmxldCBzZW5kdG8gY2ggYnVmIHBvcyBsZW4gZmxhZ3MgYWRkciA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB8fCBwb3MgPiBCeXRlcy5sZW5ndGggYnVmIC0gbGVuIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkx3dF91bml4LnNlbmR0b1wiXG4gIGVsc2VcbiAgICBsZXQgZG9fc2VuZHRvID0gaWYgU3lzLndpbjMyIHRoZW4gVW5peC5zZW5kdG8gZWxzZSBzdHViX3NlbmR0byBpblxuICAgIHdyYXBfc3lzY2FsbCBXcml0ZSBjaCAoZnVuICgpIC0+IGRvX3NlbmR0byBjaC5mZCBidWYgcG9zIGxlbiBmbGFncyBhZGRyKVxuXG5leHRlcm5hbCBzdHViX3JlY3ZfbXNnIDpcbiAgVW5peC5maWxlX2Rlc2NyIC0+IGludCAtPiBJT192ZWN0b3JzLmlvX3ZlY3RvciBsaXN0IC0+XG4gICAgaW50ICogVW5peC5maWxlX2Rlc2NyIGxpc3QgPVxuICBcImx3dF91bml4X3JlY3ZfbXNnXCJcblxubGV0IHJlY3ZfbXNnIH5zb2NrZXQgfmlvX3ZlY3RvcnMgPVxuICBsZXQgY291bnQgPSBjaGVja19pb192ZWN0b3JzIFwiTHd0X3VuaXgucmVjdl9tc2dcIiBpb192ZWN0b3JzIGluXG4gIHdyYXBfc3lzY2FsbCBSZWFkIHNvY2tldCAoZnVuICgpIC0+XG4gICAgc3R1Yl9yZWN2X21zZyBzb2NrZXQuZmQgY291bnQgaW9fdmVjdG9ycy5JT192ZWN0b3JzLnByZWZpeClcblxuZXh0ZXJuYWwgc3R1Yl9zZW5kX21zZyA6XG4gIFVuaXguZmlsZV9kZXNjciAtPlxuICBpbnQgLT4gSU9fdmVjdG9ycy5pb192ZWN0b3IgbGlzdCAtPlxuICBpbnQgLT4gVW5peC5maWxlX2Rlc2NyIGxpc3QgLT4gVW5peC5zb2NrYWRkciBvcHRpb24gLT5cbiAgICBpbnQgPSBcImx3dF91bml4X3NlbmRfbXNnX2J5dGVcIiBcImx3dF91bml4X3NlbmRfbXNnXCJcblxubGV0IHNlbmRfbXNnIH5zb2NrZXQgfmlvX3ZlY3RvcnMgfmZkcyA9XG4gIGxldCB2ZWN0b3JfY291bnQgPSBjaGVja19pb192ZWN0b3JzIFwiTHd0X3VuaXguc2VuZF9tc2dcIiBpb192ZWN0b3JzIGluXG4gIGxldCBmZF9jb3VudCA9IExpc3QubGVuZ3RoIGZkcyBpblxuICB3cmFwX3N5c2NhbGwgV3JpdGUgc29ja2V0IChmdW4gKCkgLT5cbiAgICBzdHViX3NlbmRfbXNnXG4gICAgICBzb2NrZXQuZmQgdmVjdG9yX2NvdW50IGlvX3ZlY3RvcnMuSU9fdmVjdG9ycy5wcmVmaXggZmRfY291bnQgZmRzIE5vbmUpXG5cbmxldCBzZW5kX21zZ3RvIH5zb2NrZXQgfmlvX3ZlY3RvcnMgfmZkcyB+ZGVzdCA9XG4gIGxldCB2ZWN0b3JfY291bnQgPSBjaGVja19pb192ZWN0b3JzIFwiTHd0X3VuaXguc2VuZF9tc2d0b1wiIGlvX3ZlY3RvcnMgaW5cbiAgbGV0IGZkX2NvdW50ID0gTGlzdC5sZW5ndGggZmRzIGluXG4gIHdyYXBfc3lzY2FsbCBXcml0ZSBzb2NrZXQgKGZ1biAoKSAtPlxuICAgIHN0dWJfc2VuZF9tc2dcbiAgICAgIHNvY2tldC5mZCB2ZWN0b3JfY291bnQgaW9fdmVjdG9ycy5JT192ZWN0b3JzLnByZWZpeCBmZF9jb3VudCBmZHMgKFNvbWUgZGVzdCkpXG5cbnR5cGUgaW5ldF9hZGRyID0gVW5peC5pbmV0X2FkZHJcblxudHlwZSBzb2NrZXRfZG9tYWluID1cbiAgVW5peC5zb2NrZXRfZG9tYWluID1cbiAgfCBQRl9VTklYXG4gIHwgUEZfSU5FVFxuICB8IFBGX0lORVQ2XG5cbnR5cGUgc29ja2V0X3R5cGUgPVxuICBVbml4LnNvY2tldF90eXBlID1cbiAgfCBTT0NLX1NUUkVBTVxuICB8IFNPQ0tfREdSQU1cbiAgfCBTT0NLX1JBV1xuICB8IFNPQ0tfU0VRUEFDS0VUXG5cbnR5cGUgc29ja2FkZHIgPSBVbml4LnNvY2thZGRyID0gQUREUl9VTklYIG9mIHN0cmluZyB8IEFERFJfSU5FVCBvZiBpbmV0X2FkZHIgKiBpbnRcblxubGV0IHNvY2tldCA/Y2xvZXhlYyBkb20gdHlwIHByb3RvID1cbiAgbGV0IHMgPSBVbml4LnNvY2tldCA/Y2xvZXhlYyBkb20gdHlwIHByb3RvIGluXG4gIG1rX2NoIH5ibG9ja2luZzpmYWxzZSBzXG5cbnR5cGUgc2h1dGRvd25fY29tbWFuZCA9XG4gIFVuaXguc2h1dGRvd25fY29tbWFuZCA9XG4gIHwgU0hVVERPV05fUkVDRUlWRVxuICB8IFNIVVRET1dOX1NFTkRcbiAgfCBTSFVURE9XTl9BTExcblxubGV0IHNodXRkb3duIGNoIHNodXRkb3duX2NvbW1hbmQgPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBVbml4LnNodXRkb3duIGNoLmZkIHNodXRkb3duX2NvbW1hbmRcblxuZXh0ZXJuYWwgc3R1Yl9zb2NrZXRwYWlyIDogP2Nsb2V4ZWM6Ym9vbCAtPiBzb2NrZXRfZG9tYWluIC0+IHNvY2tldF90eXBlIC0+IGludCAtPiBVbml4LmZpbGVfZGVzY3IgKiBVbml4LmZpbGVfZGVzY3IgPSBcImx3dF91bml4X3NvY2tldHBhaXJfc3R1YlwiXG5cbmxldCBzb2NrZXRwYWlyID9jbG9leGVjIGRvbSB0eXAgcHJvdG8gPVxuICBsZXQgKHMxLCBzMikgPVxuICAgIFxuIyAxNjc5IFwic3JjL3VuaXgvbHd0X3VuaXguY3Bwby5tbFwiXG4gICAgaWYgU3lzLndpbjMyICYmIChkb20gPD4gVW5peC5QRl9VTklYKSB0aGVuXG4gICAgICBzdHViX3NvY2tldHBhaXIgP2Nsb2V4ZWMgZG9tIHR5cCBwcm90b1xuICAgIGVsc2UgVW5peC5zb2NrZXRwYWlyID9jbG9leGVjIGRvbSB0eXAgcHJvdG8gaW5cbiAgXG4jIDE2OTMgXCJzcmMvdW5peC9sd3RfdW5peC5jcHBvLm1sXCJcbiAgKG1rX2NoIH5ibG9ja2luZzpmYWxzZSBzMSwgbWtfY2ggfmJsb2NraW5nOmZhbHNlIHMyKVxuXG5leHRlcm5hbCBhY2NlcHQ0IDpcbiAgP2Nsb2V4ZWM6Ym9vbCAtPiBub25ibG9jazpib29sIC0+XG4gIFVuaXguZmlsZV9kZXNjciAtPiBVbml4LmZpbGVfZGVzY3IgKiBVbml4LnNvY2thZGRyID0gXCJsd3RfdW5peF9hY2NlcHQ0XCJcblxubGV0IGFjY2VwdF9hbmRfc2V0X25vbmJsb2NrID9jbG9leGVjIGNoX2ZkID1cbiAgaWYgTHd0X2NvbmZpZy5fSEFWRV9BQ0NFUFQ0IHRoZW5cbiAgICBsZXQgKGZkLCBhZGRyKSA9IGFjY2VwdDQgP2Nsb2V4ZWMgfm5vbmJsb2NrOnRydWUgY2hfZmQgaW5cbiAgICAobWtfY2ggfmJsb2NraW5nOmZhbHNlIH5zZXRfZmxhZ3M6ZmFsc2UgZmQsIGFkZHIpXG4gIGVsc2VcbiAgICBsZXQgKGZkLCBhZGRyKSA9IFVuaXguYWNjZXB0ID9jbG9leGVjIGNoX2ZkIGluXG4gICAgKG1rX2NoIH5ibG9ja2luZzpmYWxzZSBmZCwgYWRkcilcblxubGV0IGFjY2VwdCA/Y2xvZXhlYyBjaCA9XG4gIHdyYXBfc3lzY2FsbCBSZWFkIGNoIChmdW4gXyAtPiBhY2NlcHRfYW5kX3NldF9ub25ibG9jayA/Y2xvZXhlYyBjaC5mZClcblxubGV0IGFjY2VwdF9uID9jbG9leGVjIGNoIG4gPVxuICBsZXQgbCA9IHJlZiBbXSBpblxuICBMYXp5LmZvcmNlIGNoLmJsb2NraW5nID4+PSBmdW4gYmxvY2tpbmcgLT5cbiAgTHd0LmNhdGNoXG4gICAgKGZ1biAoKSAtPlxuICAgICAgIHdyYXBfc3lzY2FsbCBSZWFkIGNoIGJlZ2luIGZ1biAoKSAtPlxuICAgICAgICAgYmVnaW5cbiAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgZm9yIF9pID0gMSB0byBuIGRvXG4gICAgICAgICAgICAgICBpZiBibG9ja2luZyAmJiBub3QgKHVuaXhfcmVhZGFibGUgY2guZmQpIHRoZW4gcmFpc2UgUmV0cnk7XG4gICAgICAgICAgICAgICBsIDo9IGFjY2VwdF9hbmRfc2V0X25vbmJsb2NrID9jbG9leGVjIGNoLmZkIDo6ICFsXG4gICAgICAgICAgICAgZG9uZVxuICAgICAgICAgICB3aXRoXG4gICAgICAgICAgIHwgKFVuaXguVW5peF9lcnJvcigoVW5peC5FQUdBSU4gfCBVbml4LkVXT1VMREJMT0NLIHwgVW5peC5FSU5UUiksIF8sIF8pIHwgUmV0cnkpIHdoZW4gIWwgPD4gW10gLT5cbiAgICAgICAgICAgICAoKiBJZ25vcmUgYmxvY2tpbmcgZXJyb3JzIGlmIHdlIGhhdmUgYXQgbGVhc3Qgb25lIGZpbGUtZGVzY3JpcHRvcjogKilcbiAgICAgICAgICAgICAoKVxuICAgICAgICAgZW5kO1xuICAgICAgICAgKExpc3QucmV2ICFsLCBOb25lKVxuICAgICAgIGVuZClcbiAgICAoZnVuIGV4biAtPiBMd3QucmV0dXJuIChMaXN0LnJldiAhbCwgU29tZSBleG4pKVxuXG5sZXQgY29ubmVjdCBjaCBhZGRyID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICAoKiBbaW5fcHJvZ3Jlc3NdIHRlbGwgd2hldGhlciBjb25uZWN0aW9uIGhhcyBzdGFydGVkIGJ1dCBub3RcbiAgICAgICB0ZXJtaW5hdGVkOiAqKVxuICAgIGxldCBpbl9wcm9ncmVzcyA9IHJlZiBmYWxzZSBpblxuICAgIHdyYXBfc3lzY2FsbCBXcml0ZSBjaCBiZWdpbiBmdW4gKCkgLT5cbiAgICAgIGlmICFpbl9wcm9ncmVzcyB0aGVuXG4gICAgICAgICgqIE5vdGhpbmcgd29ya3Mgd2l0aG91dCB0aGlzIHRlc3QgYW5kIGkgaGF2ZSBubyBpZGVhIHdoeS4uLiAqKVxuICAgICAgICBpZiB3cml0YWJsZSBjaCB0aGVuXG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBVbml4LmNvbm5lY3QgY2guZmQgYWRkclxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IFVuaXguVW5peF9lcnJvciAoVW5peC5FSVNDT05OLCBfLCBfKSAtPlxuICAgICAgICAgICAgKCogVGhpcyBpcyB0aGUgd2luZG93cyB3YXkgb2YgdGVsbGluZyB0aGF0IHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICBoYXMgY29tcGxldGVkLiAqKVxuICAgICAgICAgICAgKClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJhaXNlIFJldHJ5XG4gICAgICBlbHNlXG4gICAgICAgIHRyeVxuICAgICAgICAgIFVuaXguY29ubmVjdCBjaC5mZCBhZGRyXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBVbml4LlVuaXhfZXJyb3IgKFVuaXguRVdPVUxEQkxPQ0ssIF8sIF8pIC0+XG4gICAgICAgICAgaW5fcHJvZ3Jlc3MgOj0gdHJ1ZTtcbiAgICAgICAgICByYWlzZSBSZXRyeVxuICAgIGVuZFxuICBlbHNlXG4gICAgKCogW2luX3Byb2dyZXNzXSB0ZWxsIHdoZXRoZXIgY29ubmVjdGlvbiBoYXMgc3RhcnRlZCBidXQgbm90XG4gICAgICAgdGVybWluYXRlZDogKilcbiAgICBsZXQgaW5fcHJvZ3Jlc3MgPSByZWYgZmFsc2UgaW5cbiAgICB3cmFwX3N5c2NhbGwgV3JpdGUgY2ggYmVnaW4gZnVuICgpIC0+XG4gICAgICBpZiAhaW5fcHJvZ3Jlc3MgdGhlblxuICAgICAgICAoKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBpbiBwcm9ncmVzcywgW2dldHNvY2tvcHRfZXJyb3JdIHRlbGxzXG4gICAgICAgICAgIHdoZXRoZXIgaXQgc3VjY2NlZWQ6ICopXG4gICAgICAgIG1hdGNoIFVuaXguZ2V0c29ja29wdF9lcnJvciBjaC5mZCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICgqIFRoZSBzb2NrZXQgaXMgY29ubmVjdGVkICopXG4gICAgICAgICAgKClcbiAgICAgICAgfCBTb21lIGVyciAtPlxuICAgICAgICAgICgqIEFuIGVycm9yIGhhcHBlbmVkOiAqKVxuICAgICAgICAgIHJhaXNlIChVbml4LlVuaXhfZXJyb3IoZXJyLCBcImNvbm5lY3RcIiwgXCJcIikpXG4gICAgICBlbHNlXG4gICAgICAgIHRyeVxuICAgICAgICAgICgqIFdlIHNob3VsZCBwYXNzIG9ubHkgb25lIHRpbWUgaGVyZSwgdW5sZXNzIHRoZSBzeXN0ZW0gY2FsbFxuICAgICAgICAgICAgIGlzIGludGVycnVwdGVkIGJ5IGEgc2lnbmFsOiAqKVxuICAgICAgICAgIFVuaXguY29ubmVjdCBjaC5mZCBhZGRyXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBVbml4LlVuaXhfZXJyb3IgKFVuaXguRUlOUFJPR1JFU1MsIF8sIF8pIC0+XG4gICAgICAgICAgaW5fcHJvZ3Jlc3MgOj0gdHJ1ZTtcbiAgICAgICAgICByYWlzZSBSZXRyeVxuICAgIGVuZFxuXG5leHRlcm5hbCBiaW5kX2pvYiA6IFVuaXguZmlsZV9kZXNjciAtPiBVbml4LnNvY2thZGRyIC0+IHVuaXQgam9iID1cbiAgXCJsd3RfdW5peF9iaW5kX2pvYlwiXG5cbmxldCBiaW5kIGZkIGFkZHIgPVxuICBjaGVja19kZXNjcmlwdG9yIGZkO1xuICBtYXRjaCBTeXMud2luMzIsIGFkZHIgd2l0aFxuICB8IHRydWUsIF8gfCBmYWxzZSwgVW5peC5BRERSX0lORVQgXyAtPiBMd3QucmV0dXJuIChVbml4LmJpbmQgZmQuZmQgYWRkcilcbiAgfCBmYWxzZSwgVW5peC5BRERSX1VOSVggXyAtPiBydW5fam9iIChiaW5kX2pvYiBmZC5mZCBhZGRyKVxuXG5sZXQgbGlzdGVuIGNoIGNudCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIFVuaXgubGlzdGVuIGNoLmZkIGNudFxuXG5leHRlcm5hbCBzb21heGNvbm4gOiB1bml0IC0+IGludCA9IFwibHd0X3VuaXhfc29tYXhjb25uXCJcblxubGV0IGdldHBlZXJuYW1lIGNoID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgVW5peC5nZXRwZWVybmFtZSBjaC5mZFxuXG5sZXQgZ2V0c29ja25hbWUgY2ggPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBVbml4LmdldHNvY2tuYW1lIGNoLmZkXG5cbnR5cGUgY3JlZGVudGlhbHMgPSB7XG4gIGNyZWRfcGlkIDogaW50O1xuICBjcmVkX3VpZCA6IGludDtcbiAgY3JlZF9naWQgOiBpbnQ7XG59XG5cbmV4dGVybmFsIHN0dWJfZ2V0X2NyZWRlbnRpYWxzIDogVW5peC5maWxlX2Rlc2NyIC0+IGNyZWRlbnRpYWxzID0gXCJsd3RfdW5peF9nZXRfY3JlZGVudGlhbHNcIlxuXG5sZXQgZ2V0X2NyZWRlbnRpYWxzIGNoID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgc3R1Yl9nZXRfY3JlZGVudGlhbHMgY2guZmRcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBTb2NrZXQgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG50eXBlIHNvY2tldF9ib29sX29wdGlvbiA9XG4gIFVuaXguc29ja2V0X2Jvb2xfb3B0aW9uID1cbiAgfCBTT19ERUJVR1xuICB8IFNPX0JST0FEQ0FTVFxuICB8IFNPX1JFVVNFQUREUlxuICB8IFNPX0tFRVBBTElWRVxuICB8IFNPX0RPTlRST1VURVxuICB8IFNPX09PQklOTElORVxuICB8IFNPX0FDQ0VQVENPTk5cbiAgfCBUQ1BfTk9ERUxBWVxuICB8IElQVjZfT05MWVxuICBcbiMgMTgzNCBcInNyYy91bml4L2x3dF91bml4LmNwcG8ubWxcIlxuICB8IFNPX1JFVVNFUE9SVFxuXG4jIDE4MzcgXCJzcmMvdW5peC9sd3RfdW5peC5jcHBvLm1sXCJcbnR5cGUgc29ja2V0X2ludF9vcHRpb24gPVxuICBVbml4LnNvY2tldF9pbnRfb3B0aW9uID1cbiAgfCBTT19TTkRCVUZcbiAgfCBTT19SQ1ZCVUZcbiAgfCBTT19FUlJPUiBbQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgVW5peC5nZXRzb2Nrb3B0X2Vycm9yIGluc3RlYWQuXCJdXG4gIHwgU09fVFlQRVxuICB8IFNPX1JDVkxPV0FUXG4gIHwgU09fU05ETE9XQVRcblxudHlwZSBzb2NrZXRfb3B0aW50X29wdGlvbiA9IFVuaXguc29ja2V0X29wdGludF9vcHRpb24gPSBTT19MSU5HRVJcblxudHlwZSBzb2NrZXRfZmxvYXRfb3B0aW9uID1cbiAgVW5peC5zb2NrZXRfZmxvYXRfb3B0aW9uID1cbiAgfCBTT19SQ1ZUSU1FT1xuICB8IFNPX1NORFRJTUVPXG5cbmxldCBnZXRzb2Nrb3B0IGNoIG9wdCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIFVuaXguZ2V0c29ja29wdCBjaC5mZCBvcHRcblxubGV0IHNldHNvY2tvcHQgY2ggb3B0IHggPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBVbml4LnNldHNvY2tvcHQgY2guZmQgb3B0IHhcblxubGV0IGdldHNvY2tvcHRfaW50IGNoIG9wdCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIFVuaXguZ2V0c29ja29wdF9pbnQgY2guZmQgb3B0XG5cbmxldCBzZXRzb2Nrb3B0X2ludCBjaCBvcHQgeCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIFVuaXguc2V0c29ja29wdF9pbnQgY2guZmQgb3B0IHhcblxubGV0IGdldHNvY2tvcHRfb3B0aW50IGNoIG9wdCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIFVuaXguZ2V0c29ja29wdF9vcHRpbnQgY2guZmQgb3B0XG5cbmxldCBzZXRzb2Nrb3B0X29wdGludCBjaCBvcHQgeCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIFVuaXguc2V0c29ja29wdF9vcHRpbnQgY2guZmQgb3B0IHhcblxubGV0IGdldHNvY2tvcHRfZmxvYXQgY2ggb3B0ID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgVW5peC5nZXRzb2Nrb3B0X2Zsb2F0IGNoLmZkIG9wdFxuXG5sZXQgc2V0c29ja29wdF9mbG9hdCBjaCBvcHQgeCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIFVuaXguc2V0c29ja29wdF9mbG9hdCBjaC5mZCBvcHQgeFxuXG5sZXQgZ2V0c29ja29wdF9lcnJvciBjaCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIFVuaXguZ2V0c29ja29wdF9lcnJvciBjaC5mZFxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IE11bHRpY2FzdCBmdW5jdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmV4dGVybmFsIHN0dWJfbWNhc3Rfc2V0X2xvb3AgOiBVbml4LmZpbGVfZGVzY3IgLT4gYm9vbCAtPiB1bml0ID0gXCJsd3RfdW5peF9tY2FzdF9zZXRfbG9vcFwiXG5cbmV4dGVybmFsIHN0dWJfbWNhc3Rfc2V0X3R0bCA6IFVuaXguZmlsZV9kZXNjciAtPiBpbnQgLT4gdW5pdCA9IFwibHd0X3VuaXhfbWNhc3Rfc2V0X3R0bFwiXG5cbnR5cGUgbWNhc3RfYWN0aW9uID0gQWRkIHwgRHJvcFxuXG5leHRlcm5hbCBzdHViX21jYXN0X21vZGlmeV9tZW1iZXJzaGlwIDpcbiAgVW5peC5maWxlX2Rlc2NyIC0+IG1jYXN0X2FjdGlvbiAtPiBVbml4LmluZXRfYWRkciAtPiBVbml4LmluZXRfYWRkciAtPiB1bml0ID1cbiAgXCJsd3RfdW5peF9tY2FzdF9tb2RpZnlfbWVtYmVyc2hpcFwiXG5cbmxldCBtY2FzdF9zZXRfbG9vcCBjaCBmbGFnID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgc3R1Yl9tY2FzdF9zZXRfbG9vcCBjaC5mZCBmbGFnXG5cbmxldCBtY2FzdF9zZXRfdHRsIGNoIHR0bCA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIHN0dWJfbWNhc3Rfc2V0X3R0bCBjaC5mZCB0dGxcblxubGV0IG1jYXN0X2FkZF9tZW1iZXJzaGlwIGNoID8oaWZuYW1lID0gVW5peC5pbmV0X2FkZHJfYW55KSBhZGRyID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgc3R1Yl9tY2FzdF9tb2RpZnlfbWVtYmVyc2hpcCBjaC5mZCBBZGQgaWZuYW1lIGFkZHJcblxubGV0IG1jYXN0X2Ryb3BfbWVtYmVyc2hpcCBjaCA/KGlmbmFtZSA9IFVuaXguaW5ldF9hZGRyX2FueSkgYWRkciA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIHN0dWJfbWNhc3RfbW9kaWZ5X21lbWJlcnNoaXAgY2guZmQgRHJvcCBpZm5hbWUgYWRkclxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IEhvc3QgYW5kIHByb3RvY29sIGRhdGFiYXNlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbnR5cGUgaG9zdF9lbnRyeSA9XG4gIFVuaXguaG9zdF9lbnRyeSA9XG4gIHtcbiAgICBoX25hbWUgOiBzdHJpbmc7XG4gICAgaF9hbGlhc2VzIDogc3RyaW5nIGFycmF5O1xuICAgIGhfYWRkcnR5cGUgOiBzb2NrZXRfZG9tYWluO1xuICAgIGhfYWRkcl9saXN0IDogaW5ldF9hZGRyIGFycmF5XG4gIH1cblxudHlwZSBwcm90b2NvbF9lbnRyeSA9XG4gIFVuaXgucHJvdG9jb2xfZW50cnkgPVxuICB7XG4gICAgcF9uYW1lIDogc3RyaW5nO1xuICAgIHBfYWxpYXNlcyA6IHN0cmluZyBhcnJheTtcbiAgICBwX3Byb3RvIDogaW50XG4gIH1cblxudHlwZSBzZXJ2aWNlX2VudHJ5ID1cbiAgVW5peC5zZXJ2aWNlX2VudHJ5ID1cbiAge1xuICAgIHNfbmFtZSA6IHN0cmluZztcbiAgICBzX2FsaWFzZXMgOiBzdHJpbmcgYXJyYXk7XG4gICAgc19wb3J0IDogaW50O1xuICAgIHNfcHJvdG8gOiBzdHJpbmdcbiAgfVxuXG5leHRlcm5hbCBnZXRob3N0bmFtZV9qb2IgOiB1bml0IC0+IHN0cmluZyBqb2IgPSBcImx3dF91bml4X2dldGhvc3RuYW1lX2pvYlwiXG5cbmxldCBnZXRob3N0bmFtZSAoKSA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5nZXRob3N0bmFtZSAoKSlcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKGdldGhvc3RuYW1lX2pvYiAoKSlcblxubGV0IGhvc3RlbnRfbXV0ZXggPSBMd3RfbXV0ZXguY3JlYXRlICgpXG5cbmV4dGVybmFsIGdldGhvc3RieW5hbWVfam9iIDogc3RyaW5nIC0+IFVuaXguaG9zdF9lbnRyeSBqb2IgPSBcImx3dF91bml4X2dldGhvc3RieW5hbWVfam9iXCJcblxubGV0IGdldGhvc3RieW5hbWUgbmFtZSA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5nZXRob3N0YnluYW1lIG5hbWUpXG4gIGVsc2UgaWYgTHd0X2NvbmZpZy5fSEFWRV9SRUVOVFJBTlRfSE9TVEVOVCB0aGVuXG4gICAgcnVuX2pvYiAoZ2V0aG9zdGJ5bmFtZV9qb2IgbmFtZSlcbiAgZWxzZVxuICAgIEx3dF9tdXRleC53aXRoX2xvY2sgaG9zdGVudF9tdXRleCAoIGZ1biAoKSAtPlxuICAgICAgcnVuX2pvYiAoZ2V0aG9zdGJ5bmFtZV9qb2IgbmFtZSkgKVxuXG5leHRlcm5hbCBnZXRob3N0YnlhZGRyX2pvYiA6IFVuaXguaW5ldF9hZGRyIC0+IFVuaXguaG9zdF9lbnRyeSBqb2IgPSBcImx3dF91bml4X2dldGhvc3RieWFkZHJfam9iXCJcblxubGV0IGdldGhvc3RieWFkZHIgYWRkciA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5nZXRob3N0YnlhZGRyIGFkZHIpXG4gIGVsc2UgaWYgTHd0X2NvbmZpZy5fSEFWRV9SRUVOVFJBTlRfSE9TVEVOVCB0aGVuXG4gICAgcnVuX2pvYiAoZ2V0aG9zdGJ5YWRkcl9qb2IgYWRkcilcbiAgZWxzZVxuICAgIEx3dF9tdXRleC53aXRoX2xvY2sgaG9zdGVudF9tdXRleCAoIGZ1biAoKSAtPlxuICAgICAgcnVuX2pvYiAoZ2V0aG9zdGJ5YWRkcl9qb2IgYWRkcikgKVxuXG5sZXQgcHJvdG9lbnRfbXV0ZXggPVxuICBpZiBTeXMud2luMzIgfHwgTHd0X2NvbmZpZy5fSEFWRV9ORVREQl9SRUVOVFJBTlQgdGhlblxuICAgIGhvc3RlbnRfbXV0ZXhcbiAgZWxzZVxuICAgIEx3dF9tdXRleC5jcmVhdGUgKClcblxuZXh0ZXJuYWwgZ2V0cHJvdG9ieW5hbWVfam9iIDogc3RyaW5nIC0+IFVuaXgucHJvdG9jb2xfZW50cnkgam9iID0gXCJsd3RfdW5peF9nZXRwcm90b2J5bmFtZV9qb2JcIlxuXG5sZXQgZ2V0cHJvdG9ieW5hbWUgbmFtZSA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5nZXRwcm90b2J5bmFtZSBuYW1lKVxuICBlbHNlIGlmIEx3dF9jb25maWcuX0hBVkVfTkVUREJfUkVFTlRSQU5UIHRoZW5cbiAgICBydW5fam9iIChnZXRwcm90b2J5bmFtZV9qb2IgbmFtZSlcbiAgZWxzZVxuICAgIEx3dF9tdXRleC53aXRoX2xvY2sgcHJvdG9lbnRfbXV0ZXggKCBmdW4gKCkgLT5cbiAgICAgIHJ1bl9qb2IgKGdldHByb3RvYnluYW1lX2pvYiBuYW1lKSlcblxuZXh0ZXJuYWwgZ2V0cHJvdG9ieW51bWJlcl9qb2IgOiBpbnQgLT4gVW5peC5wcm90b2NvbF9lbnRyeSBqb2IgPSBcImx3dF91bml4X2dldHByb3RvYnludW1iZXJfam9iXCJcblxubGV0IGdldHByb3RvYnludW1iZXIgbnVtYmVyID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmdldHByb3RvYnludW1iZXIgbnVtYmVyKVxuICBlbHNlIGlmIEx3dF9jb25maWcuX0hBVkVfTkVUREJfUkVFTlRSQU5UIHRoZW5cbiAgICBydW5fam9iIChnZXRwcm90b2J5bnVtYmVyX2pvYiBudW1iZXIpXG4gIGVsc2VcbiAgICBMd3RfbXV0ZXgud2l0aF9sb2NrIHByb3RvZW50X211dGV4ICggZnVuICgpIC0+XG4gICAgICBydW5fam9iIChnZXRwcm90b2J5bnVtYmVyX2pvYiBudW1iZXIpKVxuXG4oKiBUT0RPOiBOb3QgdXNlZCBhbnl3aGVyZSwgYW5kIHRoYXQgbWlnaHQgYmUgYSBidWcuICopXG5sZXQgX3NlcnZlbnRfbXV0ZXggPVxuICBpZiBTeXMud2luMzIgfHwgTHd0X2NvbmZpZy5fSEFWRV9ORVREQl9SRUVOVFJBTlQgdGhlblxuICAgIGhvc3RlbnRfbXV0ZXhcbiAgZWxzZVxuICAgIEx3dF9tdXRleC5jcmVhdGUgKClcblxuZXh0ZXJuYWwgZ2V0c2VydmJ5bmFtZV9qb2IgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IFVuaXguc2VydmljZV9lbnRyeSBqb2IgPSBcImx3dF91bml4X2dldHNlcnZieW5hbWVfam9iXCJcblxubGV0IGdldHNlcnZieW5hbWUgbmFtZSB4ID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmdldHNlcnZieW5hbWUgbmFtZSB4KVxuICBlbHNlIGlmIEx3dF9jb25maWcuX0hBVkVfTkVUREJfUkVFTlRSQU5UIHRoZW5cbiAgICBydW5fam9iIChnZXRzZXJ2YnluYW1lX2pvYiBuYW1lIHgpXG4gIGVsc2VcbiAgICBMd3RfbXV0ZXgud2l0aF9sb2NrIHByb3RvZW50X211dGV4ICggZnVuICgpIC0+XG4gICAgICBydW5fam9iIChnZXRzZXJ2YnluYW1lX2pvYiBuYW1lIHgpIClcblxuZXh0ZXJuYWwgZ2V0c2VydmJ5cG9ydF9qb2IgOiBpbnQgLT4gc3RyaW5nIC0+IFVuaXguc2VydmljZV9lbnRyeSBqb2IgPSBcImx3dF91bml4X2dldHNlcnZieXBvcnRfam9iXCJcblxubGV0IGdldHNlcnZieXBvcnQgcG9ydCB4ID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmdldHNlcnZieXBvcnQgcG9ydCB4KVxuICBlbHNlIGlmIEx3dF9jb25maWcuX0hBVkVfTkVUREJfUkVFTlRSQU5UIHRoZW5cbiAgICBydW5fam9iIChnZXRzZXJ2Ynlwb3J0X2pvYiBwb3J0IHgpXG4gIGVsc2VcbiAgICBMd3RfbXV0ZXgud2l0aF9sb2NrIHByb3RvZW50X211dGV4ICggZnVuICgpIC0+XG4gICAgICBydW5fam9iIChnZXRzZXJ2Ynlwb3J0X2pvYiBwb3J0IHgpIClcblxudHlwZSBhZGRyX2luZm8gPVxuICBVbml4LmFkZHJfaW5mbyA9XG4gIHtcbiAgICBhaV9mYW1pbHkgOiBzb2NrZXRfZG9tYWluO1xuICAgIGFpX3NvY2t0eXBlIDogc29ja2V0X3R5cGU7XG4gICAgYWlfcHJvdG9jb2wgOiBpbnQ7XG4gICAgYWlfYWRkciA6IHNvY2thZGRyO1xuICAgIGFpX2Nhbm9ubmFtZSA6IHN0cmluZztcbiAgfVxuXG50eXBlIGdldGFkZHJpbmZvX29wdGlvbiA9XG4gIFVuaXguZ2V0YWRkcmluZm9fb3B0aW9uID1cbiAgfCBBSV9GQU1JTFkgb2Ygc29ja2V0X2RvbWFpblxuICB8IEFJX1NPQ0tUWVBFIG9mIHNvY2tldF90eXBlXG4gIHwgQUlfUFJPVE9DT0wgb2YgaW50XG4gIHwgQUlfTlVNRVJJQ0hPU1RcbiAgfCBBSV9DQU5PTk5BTUVcbiAgfCBBSV9QQVNTSVZFXG5cbmV4dGVybmFsIGdldGFkZHJpbmZvX2pvYiA6IHN0cmluZyAtPiBzdHJpbmcgLT4gVW5peC5nZXRhZGRyaW5mb19vcHRpb24gbGlzdCAtPiBVbml4LmFkZHJfaW5mbyBsaXN0IGpvYiA9IFwibHd0X3VuaXhfZ2V0YWRkcmluZm9fam9iXCJcblxubGV0IGdldGFkZHJpbmZvIGhvc3Qgc2VydmljZSBvcHRzID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LmdldGFkZHJpbmZvIGhvc3Qgc2VydmljZSBvcHRzKVxuICBlbHNlXG4gICAgcnVuX2pvYiAoZ2V0YWRkcmluZm9fam9iIGhvc3Qgc2VydmljZSBvcHRzKSA+Pj0gZnVuIGwgLT5cbiAgICBMd3QucmV0dXJuIChMaXN0LnJldiBsKVxuXG50eXBlIG5hbWVfaW5mbyA9XG4gIFVuaXgubmFtZV9pbmZvID1cbiAge1xuICAgIG5pX2hvc3RuYW1lIDogc3RyaW5nO1xuICAgIG5pX3NlcnZpY2UgOiBzdHJpbmc7XG4gIH1cblxudHlwZSBnZXRuYW1laW5mb19vcHRpb24gPVxuICBVbml4LmdldG5hbWVpbmZvX29wdGlvbiA9XG4gIHwgTklfTk9GUUROXG4gIHwgTklfTlVNRVJJQ0hPU1RcbiAgfCBOSV9OQU1FUkVRRFxuICB8IE5JX05VTUVSSUNTRVJWXG4gIHwgTklfREdSQU1cblxuZXh0ZXJuYWwgZ2V0bmFtZWluZm9fam9iIDogVW5peC5zb2NrYWRkciAtPiBVbml4LmdldG5hbWVpbmZvX29wdGlvbiBsaXN0IC0+IFVuaXgubmFtZV9pbmZvIGpvYiA9IFwibHd0X3VuaXhfZ2V0bmFtZWluZm9fam9iXCJcblxubGV0IGdldG5hbWVpbmZvIGFkZHIgb3B0cyA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC5nZXRuYW1laW5mbyBhZGRyIG9wdHMpXG4gIGVsc2VcbiAgICBydW5fam9iIChnZXRuYW1laW5mb19qb2IgYWRkciBvcHRzKVxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IFRlcm1pbmFsIGludGVyZmFjZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbnR5cGUgdGVybWluYWxfaW8gPVxuICBVbml4LnRlcm1pbmFsX2lvID1cbiAge1xuICAgIG11dGFibGUgY19pZ25icmsgOiBib29sO1xuICAgIG11dGFibGUgY19icmtpbnQgOiBib29sO1xuICAgIG11dGFibGUgY19pZ25wYXIgOiBib29sO1xuICAgIG11dGFibGUgY19wYXJtcmsgOiBib29sO1xuICAgIG11dGFibGUgY19pbnBjayA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX2lzdHJpcCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX2lubGNyIDogYm9vbDtcbiAgICBtdXRhYmxlIGNfaWduY3IgOiBib29sO1xuICAgIG11dGFibGUgY19pY3JubCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX2l4b24gOiBib29sO1xuICAgIG11dGFibGUgY19peG9mZiA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX29wb3N0IDogYm9vbDtcbiAgICBtdXRhYmxlIGNfb2JhdWQgOiBpbnQ7XG4gICAgbXV0YWJsZSBjX2liYXVkIDogaW50O1xuICAgIG11dGFibGUgY19jc2l6ZSA6IGludDtcbiAgICBtdXRhYmxlIGNfY3N0b3BiIDogaW50O1xuICAgIG11dGFibGUgY19jcmVhZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX3BhcmVuYiA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX3Bhcm9kZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX2h1cGNsIDogYm9vbDtcbiAgICBtdXRhYmxlIGNfY2xvY2FsIDogYm9vbDtcbiAgICBtdXRhYmxlIGNfaXNpZyA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX2ljYW5vbiA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX25vZmxzaCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX2VjaG8gOiBib29sO1xuICAgIG11dGFibGUgY19lY2hvZSA6IGJvb2w7XG4gICAgbXV0YWJsZSBjX2VjaG9rIDogYm9vbDtcbiAgICBtdXRhYmxlIGNfZWNob25sIDogYm9vbDtcbiAgICBtdXRhYmxlIGNfdmludHIgOiBjaGFyO1xuICAgIG11dGFibGUgY192cXVpdCA6IGNoYXI7XG4gICAgbXV0YWJsZSBjX3ZlcmFzZSA6IGNoYXI7XG4gICAgbXV0YWJsZSBjX3ZraWxsIDogY2hhcjtcbiAgICBtdXRhYmxlIGNfdmVvZiA6IGNoYXI7XG4gICAgbXV0YWJsZSBjX3Zlb2wgOiBjaGFyO1xuICAgIG11dGFibGUgY192bWluIDogaW50O1xuICAgIG11dGFibGUgY192dGltZSA6IGludDtcbiAgICBtdXRhYmxlIGNfdnN0YXJ0IDogY2hhcjtcbiAgICBtdXRhYmxlIGNfdnN0b3AgOiBjaGFyO1xuICB9XG5cbnR5cGUgc2V0YXR0cl93aGVuID1cbiAgVW5peC5zZXRhdHRyX3doZW4gPVxuICB8IFRDU0FOT1dcbiAgfCBUQ1NBRFJBSU5cbiAgfCBUQ1NBRkxVU0hcblxudHlwZSBmbHVzaF9xdWV1ZSA9XG4gIFVuaXguZmx1c2hfcXVldWUgPVxuICB8IFRDSUZMVVNIXG4gIHwgVENPRkxVU0hcbiAgfCBUQ0lPRkxVU0hcblxudHlwZSBmbG93X2FjdGlvbiA9XG4gIFVuaXguZmxvd19hY3Rpb24gPVxuICB8IFRDT09GRlxuICB8IFRDT09OXG4gIHwgVENJT0ZGXG4gIHwgVENJT05cblxuZXh0ZXJuYWwgdGNnZXRhdHRyX2pvYiA6IFVuaXguZmlsZV9kZXNjciAtPiBVbml4LnRlcm1pbmFsX2lvIGpvYiA9IFwibHd0X3VuaXhfdGNnZXRhdHRyX2pvYlwiXG5cbmxldCB0Y2dldGF0dHIgY2ggPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXgudGNnZXRhdHRyIGNoLmZkKVxuICBlbHNlXG4gICAgcnVuX2pvYiAodGNnZXRhdHRyX2pvYiBjaC5mZClcblxuZXh0ZXJuYWwgdGNzZXRhdHRyX2pvYiA6IFVuaXguZmlsZV9kZXNjciAtPiBVbml4LnNldGF0dHJfd2hlbiAtPiBVbml4LnRlcm1pbmFsX2lvIC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF90Y3NldGF0dHJfam9iXCJcblxubGV0IHRjc2V0YXR0ciBjaCB3aGVuXyBhdHRycyA9XG4gIGNoZWNrX2Rlc2NyaXB0b3IgY2g7XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgTHd0LnJldHVybiAoVW5peC50Y3NldGF0dHIgY2guZmQgd2hlbl8gYXR0cnMpXG4gIGVsc2VcbiAgICBydW5fam9iICh0Y3NldGF0dHJfam9iIGNoLmZkIHdoZW5fIGF0dHJzKVxuXG5leHRlcm5hbCB0Y3NlbmRicmVha19qb2IgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gaW50IC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF90Y3NlbmRicmVha19qb2JcIlxuXG5sZXQgdGNzZW5kYnJlYWsgY2ggZGVsYXkgPVxuICBjaGVja19kZXNjcmlwdG9yIGNoO1xuICBpZiBTeXMud2luMzIgdGhlblxuICAgIEx3dC5yZXR1cm4gKFVuaXgudGNzZW5kYnJlYWsgY2guZmQgZGVsYXkpXG4gIGVsc2VcbiAgICBydW5fam9iICh0Y3NlbmRicmVha19qb2IgY2guZmQgZGVsYXkpXG5cbmV4dGVybmFsIHRjZHJhaW5fam9iIDogVW5peC5maWxlX2Rlc2NyIC0+IHVuaXQgam9iID0gXCJsd3RfdW5peF90Y2RyYWluX2pvYlwiXG5cbmxldCB0Y2RyYWluIGNoID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LnRjZHJhaW4gY2guZmQpXG4gIGVsc2VcbiAgICBydW5fam9iICh0Y2RyYWluX2pvYiBjaC5mZClcblxuZXh0ZXJuYWwgdGNmbHVzaF9qb2IgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gVW5peC5mbHVzaF9xdWV1ZSAtPiB1bml0IGpvYiA9IFwibHd0X3VuaXhfdGNmbHVzaF9qb2JcIlxuXG5sZXQgdGNmbHVzaCBjaCBxID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LnRjZmx1c2ggY2guZmQgcSlcbiAgZWxzZVxuICAgIHJ1bl9qb2IgKHRjZmx1c2hfam9iIGNoLmZkIHEpXG5cbmV4dGVybmFsIHRjZmxvd19qb2IgOlxuICBVbml4LmZpbGVfZGVzY3IgLT4gVW5peC5mbG93X2FjdGlvbiAtPiB1bml0IGpvYiA9IFwibHd0X3VuaXhfdGNmbG93X2pvYlwiXG5cbmxldCB0Y2Zsb3cgY2ggYWN0ID1cbiAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBMd3QucmV0dXJuIChVbml4LnRjZmxvdyBjaC5mZCBhY3QpXG4gIGVsc2VcbiAgICBydW5fam9iICh0Y2Zsb3dfam9iIGNoLmZkIGFjdClcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBSZWFkaW5nIG5vdGlmaWNhdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG5leHRlcm5hbCBpbml0X25vdGlmaWNhdGlvbiA6IHVuaXQgLT4gVW5peC5maWxlX2Rlc2NyID0gXCJsd3RfdW5peF9pbml0X25vdGlmaWNhdGlvblwiXG5leHRlcm5hbCBzZW5kX25vdGlmaWNhdGlvbiA6IGludCAtPiB1bml0ID0gXCJsd3RfdW5peF9zZW5kX25vdGlmaWNhdGlvbl9zdHViXCJcbmV4dGVybmFsIHJlY3Zfbm90aWZpY2F0aW9ucyA6IHVuaXQgLT4gaW50IGFycmF5ID0gXCJsd3RfdW5peF9yZWN2X25vdGlmaWNhdGlvbnNcIlxuXG5sZXQgaGFuZGxlX25vdGlmaWNhdGlvbnMgXyA9XG4gICgqIFByb2Nlc3MgYXZhaWxhYmxlIG5vdGlmaWNhdGlvbnMuICopXG4gIEFycmF5Lml0ZXIgY2FsbF9ub3RpZmljYXRpb24gKHJlY3Zfbm90aWZpY2F0aW9ucyAoKSlcblxubGV0IGV2ZW50X25vdGlmaWNhdGlvbnMgPSByZWYgKEx3dF9lbmdpbmUub25fcmVhZGFibGUgKGluaXRfbm90aWZpY2F0aW9uICgpKSBoYW5kbGVfbm90aWZpY2F0aW9ucylcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBTaWduYWxzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG5leHRlcm5hbCBzZXRfc2lnbmFsIDogaW50IC0+IGludCAtPiBib29sIC0+IHVuaXQgPSBcImx3dF91bml4X3NldF9zaWduYWxcIlxuZXh0ZXJuYWwgcmVtb3ZlX3NpZ25hbCA6IGludCAtPiBib29sIC0+IHVuaXQgPSBcImx3dF91bml4X3JlbW92ZV9zaWduYWxcIlxuZXh0ZXJuYWwgaW5pdF9zaWduYWxzIDogdW5pdCAtPiB1bml0ID0gXCJsd3RfdW5peF9pbml0X3NpZ25hbHNcIlxuZXh0ZXJuYWwgaGFuZGxlX3NpZ25hbCA6IGludCAtPiB1bml0ID0gXCJsd3RfdW5peF9oYW5kbGVfc2lnbmFsXCJcblxubGV0ICgpID0gaW5pdF9zaWduYWxzICgpXG5cbmxldCBzZXRfc2lnbmFsIHNpZ251bSBub3RpZmljYXRpb24gPVxuICBzZXRfc2lnbmFsIHNpZ251bSBub3RpZmljYXRpb24gKEx3dF9lbmdpbmUuZm9yd2FyZHNfc2lnbmFsIHNpZ251bSlcblxubGV0IHJlbW92ZV9zaWduYWwgc2lnbnVtID1cbiAgcmVtb3ZlX3NpZ25hbCBzaWdudW0gKEx3dF9lbmdpbmUuZm9yd2FyZHNfc2lnbmFsIHNpZ251bSlcblxubW9kdWxlIFNpZ25hbF9tYXAgPSBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gaW50IGxldCBjb21wYXJlIGEgYiA9IGEgLSBiIGVuZClcblxudHlwZSBzaWduYWxfaGFuZGxlciA9IHtcbiAgc2hfbnVtIDogaW50O1xuICBzaF9ub2RlIDogKHNpZ25hbF9oYW5kbGVyX2lkIC0+IGludCAtPiB1bml0KSBMd3Rfc2VxdWVuY2Uubm9kZTtcbn1cblxuYW5kIHNpZ25hbF9oYW5kbGVyX2lkID0gc2lnbmFsX2hhbmRsZXIgb3B0aW9uIHJlZlxuXG5sZXQgc2lnbmFscyA9IHJlZiBTaWduYWxfbWFwLmVtcHR5XG5sZXQgc2lnbmFsX2NvdW50ICgpID1cbiAgU2lnbmFsX21hcC5mb2xkXG4gICAgKGZ1biBfc2lnbnVtIChfaWQsIGFjdGlvbnMpIGxlbiAtPiBsZW4gKyBMd3Rfc2VxdWVuY2UubGVuZ3RoIGFjdGlvbnMpXG4gICAgIXNpZ25hbHNcbiAgICAwXG5cbmxldCBvbl9zaWduYWxfZnVsbCBzaWdudW0gaGFuZGxlciA9XG4gIGxldCBpZCA9IHJlZiBOb25lIGluXG4gIGxldCBfLCBhY3Rpb25zID1cbiAgICB0cnlcbiAgICAgIFNpZ25hbF9tYXAuZmluZCBzaWdudW0gIXNpZ25hbHNcbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgbGV0IGFjdGlvbnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIGluXG4gICAgICBsZXQgbm90aWZpY2F0aW9uID1cbiAgICAgICAgbWFrZV9ub3RpZmljYXRpb25cbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgTHd0X3NlcXVlbmNlLml0ZXJfbFxuICAgICAgICAgICAgICAgKGZ1biBmIC0+IGYgaWQgc2lnbnVtKVxuICAgICAgICAgICAgICAgYWN0aW9ucylcbiAgICAgIGluXG4gICAgICAodHJ5XG4gICAgICAgICBzZXRfc2lnbmFsIHNpZ251bSBub3RpZmljYXRpb25cbiAgICAgICB3aXRoIGV4biB3aGVuIEx3dC5FeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT5cbiAgICAgICAgIHN0b3Bfbm90aWZpY2F0aW9uIG5vdGlmaWNhdGlvbjtcbiAgICAgICAgIHJhaXNlIGV4bik7XG4gICAgICBzaWduYWxzIDo9IFNpZ25hbF9tYXAuYWRkIHNpZ251bSAobm90aWZpY2F0aW9uLCBhY3Rpb25zKSAhc2lnbmFscztcbiAgICAgIChub3RpZmljYXRpb24sIGFjdGlvbnMpXG4gIGluXG4gIGxldCBub2RlID0gTHd0X3NlcXVlbmNlLmFkZF9yIGhhbmRsZXIgYWN0aW9ucyBpblxuICBpZCA6PSBTb21lIHsgc2hfbnVtID0gc2lnbnVtOyBzaF9ub2RlID0gbm9kZSB9O1xuICBpZFxuXG5sZXQgb25fc2lnbmFsIHNpZ251bSBmID0gb25fc2lnbmFsX2Z1bGwgc2lnbnVtIChmdW4gX2lkIG51bSAtPiBmIG51bSlcblxubGV0IGRpc2FibGVfc2lnbmFsX2hhbmRsZXIgaWQgPVxuICBtYXRjaCAhaWQgd2l0aFxuICB8IE5vbmUgLT5cbiAgICAoKVxuICB8IFNvbWUgc2ggLT5cbiAgICBpZCA6PSBOb25lO1xuICAgIEx3dF9zZXF1ZW5jZS5yZW1vdmUgc2guc2hfbm9kZTtcbiAgICBsZXQgbm90aWZpY2F0aW9uLCBhY3Rpb25zID0gU2lnbmFsX21hcC5maW5kIHNoLnNoX251bSAhc2lnbmFscyBpblxuICAgIGlmIEx3dF9zZXF1ZW5jZS5pc19lbXB0eSBhY3Rpb25zIHRoZW4gYmVnaW5cbiAgICAgIHJlbW92ZV9zaWduYWwgc2guc2hfbnVtO1xuICAgICAgc2lnbmFscyA6PSBTaWduYWxfbWFwLnJlbW92ZSBzaC5zaF9udW0gIXNpZ25hbHM7XG4gICAgICBzdG9wX25vdGlmaWNhdGlvbiBub3RpZmljYXRpb25cbiAgICBlbmRcblxubGV0IHJlaW5zdGFsbF9zaWduYWxfaGFuZGxlciBzaWdudW0gPVxuICBtYXRjaCBTaWduYWxfbWFwLmZpbmQgc2lnbnVtICFzaWduYWxzIHdpdGhcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+ICgpXG4gIHwgbm90aWZpY2F0aW9uLCBfIC0+XG4gICAgc2V0X3NpZ25hbCBzaWdudW0gbm90aWZpY2F0aW9uXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgUHJvY2Vzc2VzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxuZXh0ZXJuYWwgcmVzZXRfYWZ0ZXJfZm9yayA6IHVuaXQgLT4gdW5pdCA9IFwibHd0X3VuaXhfcmVzZXRfYWZ0ZXJfZm9ya1wiXG5cbmxldCBmb3JrICgpID1cbiAgbWF0Y2ggVW5peC5mb3JrICgpIHdpdGhcbiAgfCAwIC0+XG4gICAgKCogTGV0IHRoZSBlbmdpbmUgaGFuZGxlIHRoZSBmb3JrICopXG4gICAgTHd0X2VuZ2luZS5mb3JrICgpO1xuICAgICgqIFJlc2V0IHRocmVhZGluZy4gKilcbiAgICByZXNldF9hZnRlcl9mb3JrICgpO1xuICAgICgqIFN0b3AgdGhlIG9sZCBldmVudCBmb3Igbm90aWZpY2F0aW9ucy4gKilcbiAgICBMd3RfZW5naW5lLnN0b3BfZXZlbnQgIWV2ZW50X25vdGlmaWNhdGlvbnM7XG4gICAgKCogUmVpbml0aWFsaXNlIHRoZSBub3RpZmljYXRpb24gc3lzdGVtLiAqKVxuICAgIGV2ZW50X25vdGlmaWNhdGlvbnMgOj0gTHd0X2VuZ2luZS5vbl9yZWFkYWJsZSAoaW5pdF9ub3RpZmljYXRpb24gKCkpIGhhbmRsZV9ub3RpZmljYXRpb25zO1xuICAgICgqIENvbGxlY3QgYWxsIHBlbmRpbmcgam9icy4gKilcbiAgICBsZXQgbCA9IEx3dF9zZXF1ZW5jZS5mb2xkX2wgKGZ1biAoXywgZikgbCAtPiBmIDo6IGwpIGpvYnMgW10gaW5cbiAgICAoKiBSZW1vdmUgdGhlbSBhbGwuICopXG4gICAgTHd0X3NlcXVlbmNlLml0ZXJfbm9kZV9sIEx3dF9zZXF1ZW5jZS5yZW1vdmUgam9icztcbiAgICAoKiBBbmQgY2FuY2VsIHRoZW0gYWxsLiBXZSB5aWVsZCBmaXJzdCBzbyB0aGF0IGlmIHRoZSBwcm9ncmFtXG4gICAgICAgZG8gYW4gZXhlYyBqdXN0IGFmdGVyLCBpdCB3b24ndCBiZSBleGVjdXRlZC4gKilcbiAgICBMd3Qub25fdGVybWluYXRpb24gKEx3dF9tYWluLnlpZWxkICgpIFtAd2FybmluZyBcIi0zXCJdKSAoZnVuICgpIC0+IExpc3QuaXRlciAoZnVuIGYgLT4gZiBMd3QuQ2FuY2VsZWQpIGwpO1xuICAgIDBcbiAgfCBwaWQgLT5cbiAgICBwaWRcblxudHlwZSBwcm9jZXNzX3N0YXR1cyA9XG4gIFVuaXgucHJvY2Vzc19zdGF0dXMgPVxuICB8IFdFWElURUQgb2YgaW50XG4gIHwgV1NJR05BTEVEIG9mIGludFxuICB8IFdTVE9QUEVEIG9mIGludFxuXG50eXBlIHdhaXRfZmxhZyA9XG4gIFVuaXgud2FpdF9mbGFnID1cbiAgfCBXTk9IQU5HXG4gIHwgV1VOVFJBQ0VEXG5cbnR5cGUgcmVzb3VyY2VfdXNhZ2UgPSB7IHJ1X3V0aW1lIDogZmxvYXQ7IHJ1X3N0aW1lIDogZmxvYXQgfVxuXG5sZXQgaGFzX3dhaXQ0ID0gbm90IFN5cy53aW4zMlxuXG5leHRlcm5hbCBzdHViX3dhaXQ0IDogVW5peC53YWl0X2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ICogVW5peC5wcm9jZXNzX3N0YXR1cyAqIHJlc291cmNlX3VzYWdlID0gXCJsd3RfdW5peF93YWl0NFwiXG5cbmxldCBkb193YWl0NCBmbGFncyBwaWQgPVxuICBpZiBTeXMud2luMzIgfHwgTHd0X2NvbmZpZy5hbmRyb2lkIHRoZW5cbiAgICBsZXQgcGlkLCBzdGF0dXMgPSBVbml4LndhaXRwaWQgZmxhZ3MgcGlkIGluXG4gICAgKHBpZCwgc3RhdHVzLCB7IHJ1X3V0aW1lID0gMC4wOyBydV9zdGltZSA9IDAuMCB9KVxuICBlbHNlXG4gICAgc3R1Yl93YWl0NCBmbGFncyBwaWRcblxuXG5sZXQgd2FpdF9jaGlsZHJlbiA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKClcbmxldCB3YWl0X2NvdW50ICgpID0gTHd0X3NlcXVlbmNlLmxlbmd0aCB3YWl0X2NoaWxkcmVuXG5cbmxldCBzaWdjaGxkX2hhbmRsZXJfaW5zdGFsbGVkID0gcmVmIGZhbHNlXG5cbmxldCBpbnN0YWxsX3NpZ2NobGRfaGFuZGxlciAoKSA9XG4gIGlmIG5vdCBTeXMud2luMzIgJiYgbm90ICFzaWdjaGxkX2hhbmRsZXJfaW5zdGFsbGVkIHRoZW4gYmVnaW5cbiAgICBzaWdjaGxkX2hhbmRsZXJfaW5zdGFsbGVkIDo9IHRydWU7XG4gICAgaWdub3JlIGJlZ2luXG4gICAgICBvbl9zaWduYWwgU3lzLnNpZ2NobGRcbiAgICAgICAgKGZ1biBfIC0+XG4gICAgICAgICAgIEx3dF9zZXF1ZW5jZS5pdGVyX25vZGVfbCBiZWdpbiBmdW4gbm9kZSAtPlxuICAgICAgICAgICAgIGxldCB3YWtlbmVyLCBmbGFncywgcGlkID0gTHd0X3NlcXVlbmNlLmdldCBub2RlIGluXG4gICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICBsZXQgKHBpZCcsIF8sIF8pIGFzIHYgPSBkb193YWl0NCBmbGFncyBwaWQgaW5cbiAgICAgICAgICAgICAgIGlmIHBpZCcgPD4gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgICAgIEx3dF9zZXF1ZW5jZS5yZW1vdmUgbm9kZTtcbiAgICAgICAgICAgICAgICAgTHd0Lndha2V1cCB3YWtlbmVyIHZcbiAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgIHdpdGggZSB3aGVuIEx3dC5FeGNlcHRpb25fZmlsdGVyLnJ1biBlIC0+XG4gICAgICAgICAgICAgICBMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGU7XG4gICAgICAgICAgICAgICBMd3Qud2FrZXVwX2V4biB3YWtlbmVyIGVcbiAgICAgICAgICAgZW5kIHdhaXRfY2hpbGRyZW4pXG4gICAgZW5kXG4gIGVuZFxuXG4oKiBUaGUgY2FsbGJhY2sgb2YgTHd0LnBhdXNlIHdpbGwgb25seSBiZSBydW4gaWYgTHd0X21haW4ucnVuIGlzIGNhbGxlZCBieSB0aGVcbiAgIHVzZXIuIEluIHRoYXQgY2FzZSwgdGhlIHByb2Nlc3MgaXMgcG9zaXRpdmVseSB1c2luZyBMd3QsIGFuZCB3ZSB3YW50IHRvXG4gICBpbnN0YWxsIHRoZSBTSUdDSExEIGhhbmRsZXIsIGluIG9yZGVyIHRvIGNhdXNlIGFueSBFSU5UUi11bnNhZmUgY29kZSB0b1xuICAgZmFpbCAoYXMgaXQgc2hvdWxkKS4gKilcbmxldCAoKSA9XG4gIEx3dC5hc3luYyAoZnVuICgpIC0+XG4gICAgTHd0LnBhdXNlICgpID58PSBmdW4gKCkgLT5cbiAgICBpbnN0YWxsX3NpZ2NobGRfaGFuZGxlciAoKSlcblxubGV0IF93YWl0cGlkIGZsYWdzIHBpZCA9XG4gIEx3dC5jYXRjaFxuICAgIChmdW4gKCkgLT4gTHd0LnJldHVybiAoVW5peC53YWl0cGlkIGZsYWdzIHBpZCkpXG4gICAgTHd0LnJlcmFpc2VcblxubGV0IHdhaXRwaWQgPVxuICBpZiBTeXMud2luMzIgdGhlblxuICAgIF93YWl0cGlkXG4gIGVsc2VcbiAgICBmdW4gZmxhZ3MgcGlkIC0+XG4gICAgICBpbnN0YWxsX3NpZ2NobGRfaGFuZGxlciAoKTtcbiAgICAgIGlmIExpc3QubWVtIFVuaXguV05PSEFORyBmbGFncyB0aGVuXG4gICAgICAgIF93YWl0cGlkIGZsYWdzIHBpZFxuICAgICAgZWxzZVxuICAgICAgICBsZXQgZmxhZ3MgPSBVbml4LldOT0hBTkcgOjogZmxhZ3MgaW5cbiAgICAgICAgX3dhaXRwaWQgZmxhZ3MgcGlkID4+PSBmdW4gKChwaWQnLCBfKSBhcyByZXMpIC0+XG4gICAgICAgIGlmIHBpZCcgPD4gMCB0aGVuXG4gICAgICAgICAgTHd0LnJldHVybiByZXNcbiAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgIGxldCAocmVzLCB3KSA9IEx3dC50YXNrICgpIGluXG4gICAgICAgICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX2wgKHcsIGZsYWdzLCBwaWQpIHdhaXRfY2hpbGRyZW4gaW5cbiAgICAgICAgICBMd3Qub25fY2FuY2VsIHJlcyAoZnVuIF8gLT4gTHd0X3NlcXVlbmNlLnJlbW92ZSBub2RlKTtcbiAgICAgICAgICByZXMgPj49IGZ1biAocGlkLCBzdGF0dXMsIF8pIC0+XG4gICAgICAgICAgTHd0LnJldHVybiAocGlkLCBzdGF0dXMpXG4gICAgICAgIGVuZFxuXG5sZXQgd2FpdDQgZmxhZ3MgcGlkID1cbiAgaW5zdGFsbF9zaWdjaGxkX2hhbmRsZXIgKCk7XG4gIGlmIFN5cy53aW4zMiB8fCBMd3RfY29uZmlnLmFuZHJvaWQgdGhlblxuICAgIEx3dC5yZXR1cm4gKGRvX3dhaXQ0IGZsYWdzIHBpZClcbiAgZWxzZVxuICBpZiBMaXN0Lm1lbSBVbml4LldOT0hBTkcgZmxhZ3MgdGhlblxuICAgIEx3dC5yZXR1cm4gKGRvX3dhaXQ0IGZsYWdzIHBpZClcbiAgZWxzZVxuICAgIGxldCBmbGFncyA9IFVuaXguV05PSEFORyA6OiBmbGFncyBpblxuICAgIGxldCAocGlkJywgXywgXykgYXMgcmVzID0gZG9fd2FpdDQgZmxhZ3MgcGlkIGluXG4gICAgaWYgcGlkJyA8PiAwIHRoZW5cbiAgICAgIEx3dC5yZXR1cm4gcmVzXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IChyZXMsIHcpID0gTHd0LnRhc2sgKCkgaW5cbiAgICAgIGxldCBub2RlID0gTHd0X3NlcXVlbmNlLmFkZF9sICh3LCBmbGFncywgcGlkKSB3YWl0X2NoaWxkcmVuIGluXG4gICAgICBMd3Qub25fY2FuY2VsIHJlcyAoZnVuIF8gLT4gTHd0X3NlcXVlbmNlLnJlbW92ZSBub2RlKTtcbiAgICAgIHJlc1xuICAgIGVuZFxuXG5sZXQgd2FpdCAoKSA9IHdhaXRwaWQgW10gKC0xKVxuXG5leHRlcm5hbCBzeXN0ZW1fam9iIDogc3RyaW5nIC0+IGludCBqb2IgPSBcImx3dF91bml4X3N5c3RlbV9qb2JcIlxuXG4jIDI0NDUgXCJzcmMvdW5peC9sd3RfdW5peC5jcHBvLm1sXCJcbmV4dGVybmFsIHVuaXhfZXhpdCA6IGludCAtPiAnYSA9IFwiY2FtbF91bml4X2V4aXRcIlxuXG4jIDI0NTAgXCJzcmMvdW5peC9sd3RfdW5peC5jcHBvLm1sXCJcbmxldCBzeXN0ZW0gY21kID1cbiAgaWYgU3lzLndpbjMyIHRoZW5cbiAgICBydW5fam9iIChzeXN0ZW1fam9iIChcImNtZC5leGUgL2MgXCIgXiBjbWQpKSA+Pj0gZnVuIGNvZGUgLT5cbiAgICBMd3QucmV0dXJuIChVbml4LldFWElURUQgY29kZSlcbiAgZWxzZVxuICAgIG1hdGNoIGZvcmsgKCkgd2l0aFxuICAgIHwgMCAtPlxuICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgVW5peC5leGVjdiBcIi9iaW4vc2hcIiBbfCBcIi9iaW4vc2hcIjsgXCItY1wiOyBjbWQgfF1cbiAgICAgICAgd2l0aCBfIC0+XG4gICAgICAgICAgKCogRG8gbm90IHJ1biBhdF9leGl0IGhvb2tzICopXG4gICAgICAgICAgdW5peF9leGl0IDEyN1xuICAgICAgZW5kXG4gICAgfCBpZCAtPlxuICAgICAgd2FpdHBpZCBbXSBpZCA+fD0gc25kXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgTWlzYyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxubGV0IHJ1biA9IEx3dF9tYWluLnJ1blxuXG5sZXQgaGFuZGxlX3VuaXhfZXJyb3IgZiB4ID1cbiAgTHd0LmNhdGNoXG4gICAgKGZ1biAoKSAtPiBmIHgpXG4gICAgKGZ1biBleG4gLT5cbiAgICAgICBVbml4LmhhbmRsZV91bml4X2Vycm9yIChmdW4gKCkgLT4gcmFpc2UgZXhuKSAoKSlcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBTeXN0ZW0gdGhyZWFkIHBvb2wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5leHRlcm5hbCBwb29sX3NpemUgOiB1bml0IC0+IGludCA9IFwibHd0X3VuaXhfcG9vbF9zaXplXCIgXCJub2FsbG9jXCJcbmV4dGVybmFsIHNldF9wb29sX3NpemUgOiBpbnQgLT4gdW5pdCA9IFwibHd0X3VuaXhfc2V0X3Bvb2xfc2l6ZVwiIFwibm9hbGxvY1wiXG5leHRlcm5hbCB0aHJlYWRfY291bnQgOiB1bml0IC0+IGludCA9IFwibHd0X3VuaXhfdGhyZWFkX2NvdW50XCIgXCJub2FsbG9jXCJcbmV4dGVybmFsIHRocmVhZF93YWl0aW5nX2NvdW50IDogdW5pdCAtPiBpbnQgPSBcImx3dF91bml4X3RocmVhZF93YWl0aW5nX2NvdW50XCIgXCJub2FsbG9jXCJcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBDUFVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG5leHRlcm5hbCBnZXRfY3B1IDogdW5pdCAtPiBpbnQgPSBcImx3dF91bml4X2dldF9jcHVcIlxuXG5leHRlcm5hbCBzdHViX2dldF9hZmZpbml0eSA6IGludCAtPiBpbnQgbGlzdCA9IFwibHd0X3VuaXhfZ2V0X2FmZmluaXR5XCJcbmV4dGVybmFsIHN0dWJfc2V0X2FmZmluaXR5IDogaW50IC0+IGludCBsaXN0IC0+IHVuaXQgPSBcImx3dF91bml4X3NldF9hZmZpbml0eVwiXG5cbmxldCBnZXRfYWZmaW5pdHkgPyhwaWQ9MCkgKCkgPSBzdHViX2dldF9hZmZpbml0eSBwaWRcbmxldCBzZXRfYWZmaW5pdHkgPyhwaWQ9MCkgbCA9IHN0dWJfc2V0X2FmZmluaXR5IHBpZCBsXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgRXJyb3IgcHJpbnRpbmcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxubGV0ICgpID1cbiAgUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlclxuICAgIChmdW5jdGlvblxuICAgICAgfCBVbml4LlVuaXhfZXJyb3IoZXJyb3IsIGZ1bmMsIGFyZykgLT5cbiAgICAgICAgbGV0IGVycm9yID1cbiAgICAgICAgICBtYXRjaCBlcnJvciB3aXRoXG4gICAgICAgICAgfCBVbml4LkUyQklHIC0+IFwiRTJCSUdcIlxuICAgICAgICAgIHwgVW5peC5FQUNDRVMgLT4gXCJFQUNDRVNcIlxuICAgICAgICAgIHwgVW5peC5FQUdBSU4gLT4gXCJFQUdBSU5cIlxuICAgICAgICAgIHwgVW5peC5FQkFERiAtPiBcIkVCQURGXCJcbiAgICAgICAgICB8IFVuaXguRUJVU1kgLT4gXCJFQlVTWVwiXG4gICAgICAgICAgfCBVbml4LkVDSElMRCAtPiBcIkVDSElMRFwiXG4gICAgICAgICAgfCBVbml4LkVERUFETEsgLT4gXCJFREVBRExLXCJcbiAgICAgICAgICB8IFVuaXguRURPTSAtPiBcIkVET01cIlxuICAgICAgICAgIHwgVW5peC5FRVhJU1QgLT4gXCJFRVhJU1RcIlxuICAgICAgICAgIHwgVW5peC5FRkFVTFQgLT4gXCJFRkFVTFRcIlxuICAgICAgICAgIHwgVW5peC5FRkJJRyAtPiBcIkVGQklHXCJcbiAgICAgICAgICB8IFVuaXguRUlOVFIgLT4gXCJFSU5UUlwiXG4gICAgICAgICAgfCBVbml4LkVJTlZBTCAtPiBcIkVJTlZBTFwiXG4gICAgICAgICAgfCBVbml4LkVJTyAtPiBcIkVJT1wiXG4gICAgICAgICAgfCBVbml4LkVJU0RJUiAtPiBcIkVJU0RJUlwiXG4gICAgICAgICAgfCBVbml4LkVNRklMRSAtPiBcIkVNRklMRVwiXG4gICAgICAgICAgfCBVbml4LkVNTElOSyAtPiBcIkVNTElOS1wiXG4gICAgICAgICAgfCBVbml4LkVOQU1FVE9PTE9ORyAtPiBcIkVOQU1FVE9PTE9OR1wiXG4gICAgICAgICAgfCBVbml4LkVORklMRSAtPiBcIkVORklMRVwiXG4gICAgICAgICAgfCBVbml4LkVOT0RFViAtPiBcIkVOT0RFVlwiXG4gICAgICAgICAgfCBVbml4LkVOT0VOVCAtPiBcIkVOT0VOVFwiXG4gICAgICAgICAgfCBVbml4LkVOT0VYRUMgLT4gXCJFTk9FWEVDXCJcbiAgICAgICAgICB8IFVuaXguRU5PTENLIC0+IFwiRU5PTENLXCJcbiAgICAgICAgICB8IFVuaXguRU5PTUVNIC0+IFwiRU5PTUVNXCJcbiAgICAgICAgICB8IFVuaXguRU5PU1BDIC0+IFwiRU5PU1BDXCJcbiAgICAgICAgICB8IFVuaXguRU5PU1lTIC0+IFwiRU5PU1lTXCJcbiAgICAgICAgICB8IFVuaXguRU5PVERJUiAtPiBcIkVOT1RESVJcIlxuICAgICAgICAgIHwgVW5peC5FTk9URU1QVFkgLT4gXCJFTk9URU1QVFlcIlxuICAgICAgICAgIHwgVW5peC5FTk9UVFkgLT4gXCJFTk9UVFlcIlxuICAgICAgICAgIHwgVW5peC5FTlhJTyAtPiBcIkVOWElPXCJcbiAgICAgICAgICB8IFVuaXguRVBFUk0gLT4gXCJFUEVSTVwiXG4gICAgICAgICAgfCBVbml4LkVQSVBFIC0+IFwiRVBJUEVcIlxuICAgICAgICAgIHwgVW5peC5FUkFOR0UgLT4gXCJFUkFOR0VcIlxuICAgICAgICAgIHwgVW5peC5FUk9GUyAtPiBcIkVST0ZTXCJcbiAgICAgICAgICB8IFVuaXguRVNQSVBFIC0+IFwiRVNQSVBFXCJcbiAgICAgICAgICB8IFVuaXguRVNSQ0ggLT4gXCJFU1JDSFwiXG4gICAgICAgICAgfCBVbml4LkVYREVWIC0+IFwiRVhERVZcIlxuICAgICAgICAgIHwgVW5peC5FV09VTERCTE9DSyAtPiBcIkVXT1VMREJMT0NLXCJcbiAgICAgICAgICB8IFVuaXguRUlOUFJPR1JFU1MgLT4gXCJFSU5QUk9HUkVTU1wiXG4gICAgICAgICAgfCBVbml4LkVBTFJFQURZIC0+IFwiRUFMUkVBRFlcIlxuICAgICAgICAgIHwgVW5peC5FTk9UU09DSyAtPiBcIkVOT1RTT0NLXCJcbiAgICAgICAgICB8IFVuaXguRURFU1RBRERSUkVRIC0+IFwiRURFU1RBRERSUkVRXCJcbiAgICAgICAgICB8IFVuaXguRU1TR1NJWkUgLT4gXCJFTVNHU0laRVwiXG4gICAgICAgICAgfCBVbml4LkVQUk9UT1RZUEUgLT4gXCJFUFJPVE9UWVBFXCJcbiAgICAgICAgICB8IFVuaXguRU5PUFJPVE9PUFQgLT4gXCJFTk9QUk9UT09QVFwiXG4gICAgICAgICAgfCBVbml4LkVQUk9UT05PU1VQUE9SVCAtPiBcIkVQUk9UT05PU1VQUE9SVFwiXG4gICAgICAgICAgfCBVbml4LkVTT0NLVE5PU1VQUE9SVCAtPiBcIkVTT0NLVE5PU1VQUE9SVFwiXG4gICAgICAgICAgfCBVbml4LkVPUE5PVFNVUFAgLT4gXCJFT1BOT1RTVVBQXCJcbiAgICAgICAgICB8IFVuaXguRVBGTk9TVVBQT1JUIC0+IFwiRVBGTk9TVVBQT1JUXCJcbiAgICAgICAgICB8IFVuaXguRUFGTk9TVVBQT1JUIC0+IFwiRUFGTk9TVVBQT1JUXCJcbiAgICAgICAgICB8IFVuaXguRUFERFJJTlVTRSAtPiBcIkVBRERSSU5VU0VcIlxuICAgICAgICAgIHwgVW5peC5FQUREUk5PVEFWQUlMIC0+IFwiRUFERFJOT1RBVkFJTFwiXG4gICAgICAgICAgfCBVbml4LkVORVRET1dOIC0+IFwiRU5FVERPV05cIlxuICAgICAgICAgIHwgVW5peC5FTkVUVU5SRUFDSCAtPiBcIkVORVRVTlJFQUNIXCJcbiAgICAgICAgICB8IFVuaXguRU5FVFJFU0VUIC0+IFwiRU5FVFJFU0VUXCJcbiAgICAgICAgICB8IFVuaXguRUNPTk5BQk9SVEVEIC0+IFwiRUNPTk5BQk9SVEVEXCJcbiAgICAgICAgICB8IFVuaXguRUNPTk5SRVNFVCAtPiBcIkVDT05OUkVTRVRcIlxuICAgICAgICAgIHwgVW5peC5FTk9CVUZTIC0+IFwiRU5PQlVGU1wiXG4gICAgICAgICAgfCBVbml4LkVJU0NPTk4gLT4gXCJFSVNDT05OXCJcbiAgICAgICAgICB8IFVuaXguRU5PVENPTk4gLT4gXCJFTk9UQ09OTlwiXG4gICAgICAgICAgfCBVbml4LkVTSFVURE9XTiAtPiBcIkVTSFVURE9XTlwiXG4gICAgICAgICAgfCBVbml4LkVUT09NQU5ZUkVGUyAtPiBcIkVUT09NQU5ZUkVGU1wiXG4gICAgICAgICAgfCBVbml4LkVUSU1FRE9VVCAtPiBcIkVUSU1FRE9VVFwiXG4gICAgICAgICAgfCBVbml4LkVDT05OUkVGVVNFRCAtPiBcIkVDT05OUkVGVVNFRFwiXG4gICAgICAgICAgfCBVbml4LkVIT1NURE9XTiAtPiBcIkVIT1NURE9XTlwiXG4gICAgICAgICAgfCBVbml4LkVIT1NUVU5SRUFDSCAtPiBcIkVIT1NUVU5SRUFDSFwiXG4gICAgICAgICAgfCBVbml4LkVMT09QIC0+IFwiRUxPT1BcIlxuICAgICAgICAgIHwgVW5peC5FT1ZFUkZMT1cgLT4gXCJFT1ZFUkZMT1dcIlxuICAgICAgICAgIHwgVW5peC5FVU5LTk9XTkVSUiBuIC0+IFByaW50Zi5zcHJpbnRmIFwiRVVOS05PV05FUlIgJWRcIiBuXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUoUHJpbnRmLnNwcmludGYgXCJVbml4LlVuaXhfZXJyb3IoVW5peC4lcywgJVMsICVTKVwiIGVycm9yIGZ1bmMgYXJnKVxuICAgICAgfCBfIC0+XG4gICAgICAgIE5vbmUpXG5cbm1vZHVsZSBWZXJzaW9uZWQgPVxuc3RydWN0XG4gIGxldCBiaW5kXzEgY2ggYWRkciA9XG4gICAgY2hlY2tfZGVzY3JpcHRvciBjaDtcbiAgICBVbml4LmJpbmQgY2guZmQgYWRkclxuXG4gIGxldCBiaW5kXzIgPSBiaW5kXG5cbiAgbGV0IHJlY3ZfbXNnXzIgPSByZWN2X21zZ1xuXG4gIGxldCBzZW5kX21zZ18yID0gc2VuZF9tc2dcbmVuZFxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG50eXBlIHQgPVxuICB7IG11dGFibGUgZGVsYXkgOiBpbnQ7IGFjdGlvbiA6IHVuaXQgLT4gdW5pdDtcbiAgICBtdXRhYmxlIHByZXYgOiB0OyBtdXRhYmxlIG5leHQgOiB0IH1cblxubGV0IG1ha2UgZGVsYXkgYWN0aW9uID1cbiAgbGV0IHJlYyB4ID0geyBkZWxheSA9IGRlbGF5OyBhY3Rpb24gPSBhY3Rpb247IHByZXYgPSB4OyBuZXh0ID0geCB9IGluXG4gIHhcblxubGV0IGxzdF9lbXB0eSAoKSA9IG1ha2UgKC0xKSAoZnVuICgpIC0+ICgpKVxuXG5sZXQgbHN0X3JlbW92ZSB4ID1cbiAgbGV0IHAgPSB4LnByZXYgaW5cbiAgbGV0IG4gPSB4Lm5leHQgaW5cbiAgcC5uZXh0IDwtIG47XG4gIG4ucHJldiA8LSBwO1xuICB4Lm5leHQgPC0geDtcbiAgeC5wcmV2IDwtIHhcblxubGV0IGxzdF9pbnNlcnQgcCB4ID1cbiAgbGV0IG4gPSBwLm5leHQgaW5cbiAgcC5uZXh0IDwtIHg7XG4gIHgucHJldiA8LSBwO1xuICB4Lm5leHQgPC0gbjtcbiAgbi5wcmV2IDwtIHhcblxubGV0IGxzdF9pbl9saXN0IHggPSB4Lm5leHQgIT0geFxuXG5sZXQgbHN0X2lzX2VtcHR5IHNldCA9IHNldC5uZXh0ID09IHNldFxuXG5sZXQgbHN0X3BlZWsgcyA9IGxldCB4ID0gcy5uZXh0IGluIGxzdF9yZW1vdmUgeDsgeFxuXG4oKioqKilcblxubGV0IGNvdW50ID0gcmVmIDBcblxubGV0IGJ1Y2tldHMgPSByZWYgW3x8XVxuXG5sZXQgY3VyciA9IHJlZiAwXG5cbmxldCBzdG9wcGVkID0gcmVmIHRydWVcblxubGV0IHNpemUgbCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggIWJ1Y2tldHMgaW5cbiAgaWYgbCA+PSBsZW4gdGhlbiBiZWdpblxuICAgIGxldCBiID0gQXJyYXkuaW5pdCAobCArIDEpIChmdW4gXyAtPiBsc3RfZW1wdHkgKCkpIGluXG4gICAgQXJyYXkuYmxpdCAhYnVja2V0cyAhY3VyciBiIDAgKGxlbiAtICFjdXJyKTtcbiAgICBBcnJheS5ibGl0ICFidWNrZXRzIDAgYiAobGVuIC0gIWN1cnIpICFjdXJyO1xuICAgIGJ1Y2tldHMgOj0gYjsgY3VyciA6PSAwO1xuICBlbmRcblxuKCoqKiopXG5cbmxldCBoYW5kbGVfZXhuID1cbiAgcmVmXG4gICAgKGZ1biBleG4gLT5cbiAgICAgICFMd3QuYXN5bmNfZXhjZXB0aW9uX2hvb2sgZXhuKVxuXG5sZXQgc2V0X2V4bl9oYW5kbGVyIGYgPSBoYW5kbGVfZXhuIDo9IGZcblxubGV0IHJlYyBsb29wICgpID1cbiAgc3RvcHBlZCA6PSBmYWxzZTtcbiAgTHd0LmJpbmQgKEx3dF91bml4LnNsZWVwIDEuKSAoZnVuICgpIC0+XG4gICAgbGV0IHMgPSAhYnVja2V0cy4oIWN1cnIpIGluXG4gICAgd2hpbGUgbm90IChsc3RfaXNfZW1wdHkgcykgZG9cbiAgICAgIGxldCB4ID0gbHN0X3BlZWsgcyBpblxuICAgICAgZGVjciBjb3VudDtcbiAgICAgICgqWFhYIFNob3VsZCBwcm9iYWJseSByZXBvcnQgYW55IGV4Y2VwdGlvbiAqKVxuICAgICAgdHJ5XG4gICAgICAgIHguYWN0aW9uICgpXG4gICAgICB3aXRoIGUgd2hlbiBMd3QuRXhjZXB0aW9uX2ZpbHRlci5ydW4gZSAtPlxuICAgICAgICAhaGFuZGxlX2V4biBlXG4gICAgZG9uZTtcbiAgICBjdXJyIDo9ICghY3VyciArIDEpIG1vZCAoQXJyYXkubGVuZ3RoICFidWNrZXRzKTtcbiAgICBpZiAhY291bnQgPiAwIHRoZW4gbG9vcCAoKSBlbHNlIGJlZ2luIHN0b3BwZWQgOj0gdHJ1ZTsgTHd0LnJldHVybl91bml0IGVuZClcblxubGV0IHN0YXJ0IHggPVxuICBsZXQgaW5fbGlzdCA9IGxzdF9pbl9saXN0IHggaW5cbiAgbGV0IHNsb3QgPSAoIWN1cnIgKyB4LmRlbGF5KSBtb2QgKEFycmF5Lmxlbmd0aCAhYnVja2V0cykgaW5cbiAgbHN0X3JlbW92ZSB4O1xuICBsc3RfaW5zZXJ0ICFidWNrZXRzLihzbG90KSB4O1xuICBpZiBub3QgaW5fbGlzdCB0aGVuIGJlZ2luXG4gICAgaW5jciBjb3VudDtcbiAgICBpZiAhY291bnQgPSAxICYmICFzdG9wcGVkIHRoZW4gaWdub3JlIChsb29wICgpKVxuICBlbmRcblxubGV0IGNyZWF0ZSBkZWxheSBhY3Rpb24gPVxuICBpZiBkZWxheSA8IDEgdGhlbiBpbnZhbGlkX2FyZyBcIkx3dF90aW1lb3V0LmNyZWF0ZVwiO1xuICBsZXQgeCA9IG1ha2UgZGVsYXkgYWN0aW9uIGluXG4gIHNpemUgZGVsYXk7XG4gIHhcblxubGV0IHN0b3AgeCA9XG4gIGlmIGxzdF9pbl9saXN0IHggdGhlbiBiZWdpblxuICAgIGxzdF9yZW1vdmUgeDtcbiAgICBkZWNyIGNvdW50XG4gIGVuZFxuXG5sZXQgY2hhbmdlIHggZGVsYXkgPVxuICBpZiBkZWxheSA8IDEgdGhlbiBpbnZhbGlkX2FyZyBcIkx3dF90aW1lb3V0LmNoYW5nZVwiO1xuICB4LmRlbGF5IDwtIGRlbGF5O1xuICBzaXplIGRlbGF5O1xuICBpZiBsc3RfaW5fbGlzdCB4IHRoZW4gc3RhcnQgeFxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5vcGVuIEx3dC5JbmZpeFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUga2V5XG4gIHR5cGUgdFxuXG4gIHZhbCBjcmVhdGUgOiByYXRlOmludCAtPiBtYXg6aW50IC0+IG46aW50IC0+IHRcbiAgdmFsIHdhaXQgOiB0IC0+IGtleSAtPiBib29sIEx3dC50XG5lbmRcblxubW9kdWxlIE1ha2UgKEggOiBIYXNodGJsLkhhc2hlZFR5cGUpIDogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE1IID0gSGFzaHRibC5NYWtlKEgpXG5cbiAgdHlwZSBrZXkgPSBILnRcbiAgdHlwZSBlbHQgPSB7XG4gICAgbXV0YWJsZSBjb25zdW1lZCA6IGludDtcbiAgICBxdWV1ZSA6IGJvb2wgTHd0LnUgUXVldWUudDtcbiAgfVxuXG4gIHR5cGUgdCA9IHtcbiAgICByYXRlIDogaW50O1xuICAgIG1heCA6IGludDsgKCogbWF4aW11bSBudW1iZXIgb2Ygd2FpdGluZyB0aHJlYWRzICopXG4gICAgbXV0YWJsZSB3YWl0aW5nIDogaW50O1xuICAgIHRhYmxlIDogZWx0IE1ILnQ7XG4gICAgbXV0YWJsZSBjbGVhbmluZyA6IHVuaXQgTHd0LnQgb3B0aW9uO1xuICB9XG5cbiAgbGV0IGNyZWF0ZSB+cmF0ZSB+bWF4IH5uID1cbiAgICBpZiByYXRlIDwgMSB8fCBtYXggPCAxIHx8IG4gPCAwIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiTHd0X3Rocm90dGxlLlMuY3JlYXRlXCJcbiAgICBlbHNlIHtcbiAgICAgIHJhdGUgPSByYXRlO1xuICAgICAgbWF4ID0gbWF4O1xuICAgICAgd2FpdGluZyA9IDA7XG4gICAgICB0YWJsZSA9IE1ILmNyZWF0ZSBuO1xuICAgICAgY2xlYW5pbmcgPSBOb25lO1xuICAgIH1cblxuICBsZXQgdXBkYXRlX2tleSB0IGtleSBlbHQgKG9sZF93YWl0aW5nLHRvX3J1bikgPVxuICAgIGxldCByZWMgdXBkYXRlIHRvX3J1biA9IGZ1bmN0aW9uXG4gICAgICB8IDAgLT4gMCwgUXVldWUubGVuZ3RoIGVsdC5xdWV1ZSwgdG9fcnVuXG4gICAgICB8IGkgLT5cbiAgICAgICAgdHJ5XG4gICAgICAgICAgbGV0IHRvX3J1biA9IChRdWV1ZS50YWtlIGVsdC5xdWV1ZSk6OnRvX3J1biBpblxuICAgICAgICAgIHVwZGF0ZSB0b19ydW4gKGktMSlcbiAgICAgICAgd2l0aFxuICAgICAgICB8IFF1ZXVlLkVtcHR5IC0+IGksIDAsIHRvX3J1blxuICAgIGluXG4gICAgbGV0IG5vdF9jb25zdW1lZCwgd2FpdGluZywgdG9fcnVuID0gdXBkYXRlIHRvX3J1biB0LnJhdGUgaW5cbiAgICBsZXQgY29uc3VtZWQgPSB0LnJhdGUgLSBub3RfY29uc3VtZWQgaW5cbiAgICBpZiBjb25zdW1lZCA9IDBcbiAgICB0aGVuXG4gICAgICAoKiB0aGVyZSBpcyBubyB3YWl0aW5nIHRocmVhZHMgZm9yIHRoaXMga2V5OiB3ZSBjYW4gY2xlYW4gdGhlIHRhYmxlICopXG4gICAgICBNSC5yZW1vdmUgdC50YWJsZSBrZXlcbiAgICBlbHNlIGVsdC5jb25zdW1lZCA8LSBjb25zdW1lZDtcbiAgICAob2xkX3dhaXRpbmcrd2FpdGluZywgdG9fcnVuKVxuXG4gIGxldCByZWMgY2xlYW5fdGFibGUgdCA9XG4gICAgbGV0IHdhaXRpbmcsdG9fcnVuID0gTUguZm9sZCAodXBkYXRlX2tleSB0KSB0LnRhYmxlICgwLFtdKSBpblxuICAgIHQud2FpdGluZyA8LSB3YWl0aW5nO1xuICAgIGlmIHdhaXRpbmcgPSAwICYmIHRvX3J1biA9IFtdXG4gICAgdGhlblxuICAgICAgKCogdGhlIHRhYmxlIGlzIGVtcHR5OiB3ZSBkbyBub3QgbmVlZCB0byBjbGVhbiBpbiAxIHNlY29uZCAqKVxuICAgICAgdC5jbGVhbmluZyA8LSBOb25lXG4gICAgZWxzZSBsYXVuY2hfY2xlYW5pbmcgdDtcbiAgICBMaXN0Lml0ZXIgKGZ1biB1IC0+IEx3dC53YWtldXAgdSB0cnVlKSB0b19ydW5cblxuICBhbmQgbGF1bmNoX2NsZWFuaW5nIHQgPVxuICAgIHQuY2xlYW5pbmcgPC1cbiAgICAgIGxldCB0ID1cbiAgICAgICAgTHd0X3VuaXguc2xlZXAgMS4gPj49IGZ1biAoKSAtPlxuICAgICAgICBMd3QuY2F0Y2hcbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgY2xlYW5fdGFibGUgdDtcbiAgICAgICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG4gICAgICAgICAgKGZ1biBfZXhuIC0+XG4gICAgICAgICAgICAgKCogTm90IGdvb2QgcHJhY3RpY2UsIGJ1dCBub3Qgd29yc2UgdGhhbiB0aGUgY29kZSBpdCBpc1xuICAgICAgICAgICAgICAgIHJlcGxhY2luZy4gKilcbiAgICAgICAgICAgICBwcmVycl9lbmRsaW5lIFwiaW50ZXJuYWwgZXJyb3JcIjtcbiAgICAgICAgICAgICBQcmludGV4Yy5wcmludF9iYWNrdHJhY2Ugc3RkZXJyO1xuICAgICAgICAgICAgIEx3dC5yZXR1cm5fdW5pdClcbiAgICAgIGluXG4gICAgICBTb21lIHRcblxuICBsZXQgcmVhbGx5X3dhaXQgdCBlbHQgPVxuICAgIGxldCB3LHUgPSBMd3QudGFzayAoKSBpblxuICAgIGlmIHQubWF4ID4gdC53YWl0aW5nXG4gICAgdGhlbiAoUXVldWUuYWRkIHUgZWx0LnF1ZXVlO1xuICAgICAgICAgIHQud2FpdGluZyA8LSBzdWNjIHQud2FpdGluZztcbiAgICAgICAgICB3KVxuICAgIGVsc2UgTHd0LnJldHVybl9mYWxzZVxuXG4gIGxldCB3YWl0IHQga2V5ID1cbiAgICBsZXQgcmVzID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgZWx0ID0gTUguZmluZCB0LnRhYmxlIGtleSBpblxuICAgICAgICBpZiBlbHQuY29uc3VtZWQgPj0gdC5yYXRlXG4gICAgICAgIHRoZW4gcmVhbGx5X3dhaXQgdCBlbHRcbiAgICAgICAgZWxzZSAoZWx0LmNvbnN1bWVkIDwtIHN1Y2MgZWx0LmNvbnN1bWVkO1xuICAgICAgICAgICAgICBMd3QucmV0dXJuX3RydWUpXG4gICAgICB3aXRoXG4gICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgZWx0ID0geyBjb25zdW1lZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlID0gUXVldWUuY3JlYXRlICgpIH0gaW5cbiAgICAgICAgTUguYWRkIHQudGFibGUga2V5IGVsdDtcbiAgICAgICAgTHd0LnJldHVybl90cnVlXG4gICAgaW5cbiAgICAobWF0Y2ggdC5jbGVhbmluZyB3aXRoXG4gICAgIHwgTm9uZSAtPiBsYXVuY2hfY2xlYW5pbmcgdFxuICAgICB8IFNvbWUgXyAtPiAoKSk7XG4gICAgcmVzXG5cbmVuZFxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5leGNlcHRpb24gTm90X2F2YWlsYWJsZSBvZiBzdHJpbmdcblxubGV0ICgpID0gQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwibHd0Om5vdC1hdmFpbGFibGVcIiAoTm90X2F2YWlsYWJsZSBcIlwiKVxuXG5sZXQgd2luZG93cyA9IFN5cy53aW4zMlxuXG50eXBlIGZlYXR1cmUgPVxuICBbIGB3YWl0NFxuICB8IGBnZXRfY3B1XG4gIHwgYGdldF9hZmZpbml0eVxuICB8IGBzZXRfYWZmaW5pdHlcbiAgfCBgcmVjdl9tc2dcbiAgfCBgc2VuZF9tc2dcbiAgfCBgZmRfcGFzc2luZ1xuICB8IGBnZXRfY3JlZGVudGlhbHNcbiAgfCBgbWluY29yZVxuICB8IGBtYWR2aXNlXG4gIHwgYGZkYXRhc3luY1xuICB8IGBsaWJldiBdXG5cbmxldCBoYXZlID0gZnVuY3Rpb25cbiAgfCBgd2FpdDRcbiAgfCBgcmVjdl9tc2dcbiAgfCBgc2VuZF9tc2dcbiAgfCBgbWFkdmlzZSAtPiBub3QgU3lzLndpbjMyXG4gIHwgYG1pbmNvcmUgLT4gbm90IChTeXMud2luMzIgfHwgU3lzLmN5Z3dpbilcbiAgfCBgZ2V0X2NwdSAtPiBMd3RfY29uZmlnLl9IQVZFX0dFVENQVVxuICB8IGBnZXRfYWZmaW5pdHlcbiAgfCBgc2V0X2FmZmluaXR5IC0+IEx3dF9jb25maWcuX0hBVkVfQUZGSU5JVFlcbiAgfCBgZmRfcGFzc2luZyAtPiBMd3RfY29uZmlnLl9IQVZFX0ZEX1BBU1NJTkdcbiAgfCBgZ2V0X2NyZWRlbnRpYWxzIC0+IEx3dF9jb25maWcuX0hBVkVfR0VUX0NSRURFTlRJQUxTXG4gIHwgYGZkYXRhc3luYyAtPiBMd3RfY29uZmlnLl9IQVZFX0ZEQVRBU1lOQ1xuICB8IGBsaWJldiAtPiBMd3RfY29uZmlnLl9IQVZFX0xJQkVWXG5cbnR5cGUgYnl0ZV9vcmRlciA9IExpdHRsZV9lbmRpYW4gfCBCaWdfZW5kaWFuXG5cbmV4dGVybmFsIGdldF9ieXRlX29yZGVyIDogdW5pdCAtPiBieXRlX29yZGVyID0gXCJsd3RfdW5peF9zeXN0ZW1fYnl0ZV9vcmRlclwiXG5cbmxldCBieXRlX29yZGVyID0gZ2V0X2J5dGVfb3JkZXIgKClcbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxub3BlbiBCaWdhcnJheVxuXG50eXBlIHQgPSAoY2hhciwgaW50OF91bnNpZ25lZF9lbHQsIGNfbGF5b3V0KSBBcnJheTEudFxuXG5sZXQgY3JlYXRlIHNpemUgPSBBcnJheTEuY3JlYXRlIGNoYXIgY19sYXlvdXQgc2l6ZVxubGV0IGxlbmd0aCBieXRlcyA9IEFycmF5MS5kaW0gYnl0ZXNcblxuZXh0ZXJuYWwgZ2V0IDogdCAtPiBpbnQgLT4gY2hhciA9IFwiJWNhbWxfYmFfcmVmXzFcIlxuZXh0ZXJuYWwgc2V0IDogdCAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMVwiXG5cbmV4dGVybmFsIHVuc2FmZV9nZXQgOiB0IC0+IGludCAtPiBjaGFyID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzFcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IHQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8xXCJcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiB0IC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCJsd3RfdW5peF9maWxsX2J5dGVzXCIgXCJub2FsbG9jXCJcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxubGV0IGZpbGwgYnl0ZXMgb2ZzIGxlbiBjaCA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYnl0ZXMgLSBsZW4gdGhlblxuICAgIGludmFsaWRfYXJnIFwiTHd0X2J5dGVzLmZpbGxcIlxuICBlbHNlXG4gICAgdW5zYWZlX2ZpbGwgYnl0ZXMgb2ZzIGxlbiBjaFxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IEJsaXR0aW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmV4dGVybmFsIHVuc2FmZV9ibGl0X2Zyb21fYnl0ZXMgOiBCeXRlcy50IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwibHd0X3VuaXhfYmxpdF9mcm9tX2J5dGVzXCIgXCJub2FsbG9jXCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0X2Zyb21fc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwibHd0X3VuaXhfYmxpdF9mcm9tX3N0cmluZ1wiIFwibm9hbGxvY1wiXG5leHRlcm5hbCB1bnNhZmVfYmxpdF90b19ieXRlcyA6IHQgLT4gaW50IC0+IEJ5dGVzLnQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJsd3RfdW5peF9ibGl0X3RvX2J5dGVzXCIgXCJub2FsbG9jXCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImx3dF91bml4X2JsaXRcIiBcIm5vYWxsb2NcIlxuW0BAQG9jYW1sLndhcm5pbmcgXCIrM1wiXVxuXG5sZXQgYmxpdF9mcm9tX3N0cmluZyBzcmNfYnVmIHNyY19vZnMgZHN0X2J1ZiBkc3Rfb2ZzIGxlbiA9XG4gIGlmIChsZW4gPCAwXG4gICAgICB8fCBzcmNfb2ZzIDwgMCB8fCBzcmNfb2ZzID4gU3RyaW5nLmxlbmd0aCBzcmNfYnVmIC0gbGVuXG4gICAgICB8fCBkc3Rfb2ZzIDwgMCB8fCBkc3Rfb2ZzID4gbGVuZ3RoIGRzdF9idWYgLSBsZW4pIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkx3dF9ieXRlcy5ibGl0X2Zyb21fc3RyaW5nXCJcbiAgZWxzZVxuICAgIHVuc2FmZV9ibGl0X2Zyb21fc3RyaW5nIHNyY19idWYgc3JjX29mcyBkc3RfYnVmIGRzdF9vZnMgbGVuXG5cbmxldCBibGl0X2Zyb21fYnl0ZXMgc3JjX2J1ZiBzcmNfb2ZzIGRzdF9idWYgZHN0X29mcyBsZW4gPVxuICBpZiAobGVuIDwgMFxuICAgICAgfHwgc3JjX29mcyA8IDAgfHwgc3JjX29mcyA+IEJ5dGVzLmxlbmd0aCBzcmNfYnVmIC0gbGVuXG4gICAgICB8fCBkc3Rfb2ZzIDwgMCB8fCBkc3Rfb2ZzID4gbGVuZ3RoIGRzdF9idWYgLSBsZW4pIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkx3dF9ieXRlcy5ibGl0X2Zyb21fYnl0ZXNcIlxuICBlbHNlXG4gICAgdW5zYWZlX2JsaXRfZnJvbV9ieXRlcyBzcmNfYnVmIHNyY19vZnMgZHN0X2J1ZiBkc3Rfb2ZzIGxlblxuXG5sZXQgYmxpdF90b19ieXRlcyBzcmNfYnVmIHNyY19vZnMgZHN0X2J1ZiBkc3Rfb2ZzIGxlbiA9XG4gIGlmIChsZW4gPCAwXG4gICAgICB8fCBzcmNfb2ZzIDwgMCB8fCBzcmNfb2ZzID4gbGVuZ3RoIHNyY19idWYgLSBsZW5cbiAgICAgIHx8IGRzdF9vZnMgPCAwIHx8IGRzdF9vZnMgPiBCeXRlcy5sZW5ndGggZHN0X2J1ZiAtIGxlbikgdGhlblxuICAgIGludmFsaWRfYXJnIFwiTHd0X2J5dGVzLmJsaXRfdG9fYnl0ZXNcIlxuICBlbHNlXG4gICAgdW5zYWZlX2JsaXRfdG9fYnl0ZXMgc3JjX2J1ZiBzcmNfb2ZzIGRzdF9idWYgZHN0X29mcyBsZW5cblxubGV0IGJsaXQgc3JjX2J1ZiBzcmNfb2ZzIGRzdF9idWYgZHN0X29mcyBsZW4gPVxuICBpZiAobGVuIDwgMFxuICAgICAgfHwgc3JjX29mcyA8IDAgfHwgc3JjX29mcyA+IGxlbmd0aCBzcmNfYnVmIC0gbGVuXG4gICAgICB8fCBkc3Rfb2ZzIDwgMCB8fCBkc3Rfb2ZzID4gbGVuZ3RoIGRzdF9idWYgLSBsZW4pIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkx3dF9ieXRlcy5ibGl0XCJcbiAgZWxzZVxuICAgIHVuc2FmZV9ibGl0IHNyY19idWYgc3JjX29mcyBkc3RfYnVmIGRzdF9vZnMgbGVuXG5cbmxldCBvZl9ieXRlcyBidWYgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1ZiBpblxuICBsZXQgYnl0ZXMgPSBjcmVhdGUgbGVuIGluXG4gIHVuc2FmZV9ibGl0X2Zyb21fYnl0ZXMgYnVmIDAgYnl0ZXMgMCBsZW47XG4gIGJ5dGVzXG5cbmxldCBvZl9zdHJpbmcgc3RyID0gb2ZfYnl0ZXMgKEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgc3RyKVxuXG5sZXQgdG9fYnl0ZXMgYnl0ZXMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIGJ5dGVzIGluXG4gIGxldCBzdHIgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gIHVuc2FmZV9ibGl0X3RvX2J5dGVzIGJ5dGVzIDAgc3RyIDAgbGVuO1xuICBzdHJcblxubGV0IHRvX3N0cmluZyBieXRlcyA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgKHRvX2J5dGVzIGJ5dGVzKVxuXG5sZXQgcHJveHkgPSBBcnJheTEuc3ViXG5cbmxldCBleHRyYWN0IGJ1ZiBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBidWYgLSBsZW4gdGhlblxuICAgIGludmFsaWRfYXJnIFwiTHd0X2J5dGVzLmV4dHJhY3RcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IGJ1ZicgPSBjcmVhdGUgbGVuIGluXG4gICAgYmxpdCBidWYgb2ZzIGJ1ZicgMCBsZW47XG4gICAgYnVmJ1xuICBlbmRcblxubGV0IGNvcHkgYnVmID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBidWYgaW5cbiAgbGV0IGJ1ZicgPSBjcmVhdGUgbGVuIGluXG4gIGJsaXQgYnVmIDAgYnVmJyAwIGxlbjtcbiAgYnVmJ1xuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IElPcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbm9wZW4gTHd0X3VuaXhcblxubGV0IHJlYWQgPVxuICBMd3RfdW5peC5yZWFkX2JpZ2FycmF5IFwiTHd0X2J5dGVzLnJlYWRcIiBbQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG5sZXQgd3JpdGUgPVxuICBMd3RfdW5peC53cml0ZV9iaWdhcnJheSBcIkx3dF9ieXRlcy53cml0ZVwiIFtAb2NhbWwud2FybmluZyBcIi0zXCJdXG5cbmV4dGVybmFsIHN0dWJfcmVjdiA6IFVuaXguZmlsZV9kZXNjciAtPiB0IC0+IGludCAtPiBpbnQgLT4gVW5peC5tc2dfZmxhZyBsaXN0IC0+IGludCA9IFwibHd0X3VuaXhfYnl0ZXNfcmVjdlwiXG5cbmxldCByZWN2IGZkIGJ1ZiBwb3MgbGVuIGZsYWdzID1cbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IGxlbmd0aCBidWYgLSBsZW4gdGhlblxuICAgIGludmFsaWRfYXJnIFwiTHd0X2J5dGVzLnJlY3ZcIlxuICBlbHNlXG4gICAgd3JhcF9zeXNjYWxsIFJlYWQgZmQgKGZ1biAoKSAtPiBzdHViX3JlY3YgKHVuaXhfZmlsZV9kZXNjciBmZCkgYnVmIHBvcyBsZW4gZmxhZ3MpXG5cbmV4dGVybmFsIHN0dWJfc2VuZCA6IFVuaXguZmlsZV9kZXNjciAtPiB0IC0+IGludCAtPiBpbnQgLT4gVW5peC5tc2dfZmxhZyBsaXN0IC0+IGludCA9IFwibHd0X3VuaXhfYnl0ZXNfc2VuZFwiXG5cbmxldCBzZW5kIGZkIGJ1ZiBwb3MgbGVuIGZsYWdzID1cbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IGxlbmd0aCBidWYgLSBsZW4gdGhlblxuICAgIGludmFsaWRfYXJnIFwiTHd0X2J5dGVzLnNlbmRcIlxuICBlbHNlXG4gICAgd3JhcF9zeXNjYWxsIFdyaXRlIGZkIChmdW4gKCkgLT4gc3R1Yl9zZW5kICh1bml4X2ZpbGVfZGVzY3IgZmQpIGJ1ZiBwb3MgbGVuIGZsYWdzKVxuXG50eXBlIGlvX3ZlY3RvciA9IHtcbiAgaW92X2J1ZmZlciA6IHQ7XG4gIGlvdl9vZmZzZXQgOiBpbnQ7XG4gIGlvdl9sZW5ndGggOiBpbnQ7XG59XG5cbmxldCBpb192ZWN0b3IgfmJ1ZmZlciB+b2Zmc2V0IH5sZW5ndGggPSAoe1xuICBpb3ZfYnVmZmVyID0gYnVmZmVyO1xuICBpb3Zfb2Zmc2V0ID0gb2Zmc2V0O1xuICBpb3ZfbGVuZ3RoID0gbGVuZ3RoO1xufSA6IGlvX3ZlY3RvcilcblxubGV0IGNvbnZlcnRfaW9fdmVjdG9ycyBvbGRfaW9fdmVjdG9ycyA9XG4gIGxldCBpb192ZWN0b3JzID0gSU9fdmVjdG9ycy5jcmVhdGUgKCkgaW5cbiAgb2xkX2lvX3ZlY3RvcnNcbiAgfD4gTGlzdC5pdGVyIChmdW4gKHtpb3ZfYnVmZmVyOyBpb3Zfb2Zmc2V0OyBpb3ZfbGVuZ3RofSA6IGlvX3ZlY3RvcikgLT5cbiAgICBJT192ZWN0b3JzLmFwcGVuZF9iaWdhcnJheSBpb192ZWN0b3JzIGlvdl9idWZmZXIgaW92X29mZnNldCBpb3ZfbGVuZ3RoKTtcbiAgaW9fdmVjdG9yc1xuXG5sZXQgcmVjdl9tc2cgfnNvY2tldCB+aW9fdmVjdG9ycyA9XG4gIEx3dF91bml4LnJlY3ZfbXNnIH5zb2NrZXQgfmlvX3ZlY3RvcnM6KGNvbnZlcnRfaW9fdmVjdG9ycyBpb192ZWN0b3JzKVxuXG5sZXQgc2VuZF9tc2cgfnNvY2tldCB+aW9fdmVjdG9ycyB+ZmRzID1cbiAgTHd0X3VuaXguc2VuZF9tc2cgfnNvY2tldCB+aW9fdmVjdG9yczooY29udmVydF9pb192ZWN0b3JzIGlvX3ZlY3RvcnMpIH5mZHNcblxuZXh0ZXJuYWwgc3R1Yl9yZWN2ZnJvbSA6IFVuaXguZmlsZV9kZXNjciAtPiB0IC0+IGludCAtPiBpbnQgLT4gVW5peC5tc2dfZmxhZyBsaXN0IC0+IGludCAqIFVuaXguc29ja2FkZHIgPSBcImx3dF91bml4X2J5dGVzX3JlY3Zmcm9tXCJcblxubGV0IHJlY3Zmcm9tIGZkIGJ1ZiBwb3MgbGVuIGZsYWdzID1cbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IGxlbmd0aCBidWYgLSBsZW4gdGhlblxuICAgIGludmFsaWRfYXJnIFwiTHd0X2J5dGVzLnJlY3Zmcm9tXCJcbiAgZWxzZVxuICAgIHdyYXBfc3lzY2FsbCBSZWFkIGZkIChmdW4gKCkgLT4gc3R1Yl9yZWN2ZnJvbSAodW5peF9maWxlX2Rlc2NyIGZkKSBidWYgcG9zIGxlbiBmbGFncylcblxuZXh0ZXJuYWwgc3R1Yl9zZW5kdG8gOiBVbml4LmZpbGVfZGVzY3IgLT4gdCAtPiBpbnQgLT4gaW50IC0+IFVuaXgubXNnX2ZsYWcgbGlzdCAtPiBVbml4LnNvY2thZGRyIC0+IGludCA9IFwibHd0X3VuaXhfYnl0ZXNfc2VuZHRvX2J5dGVcIiBcImx3dF91bml4X2J5dGVzX3NlbmR0b1wiXG5cbmxldCBzZW5kdG8gZmQgYnVmIHBvcyBsZW4gZmxhZ3MgYWRkciA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB8fCBwb3MgPiBsZW5ndGggYnVmIC0gbGVuIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkx3dF9ieXRlcy5zZW5kdG9cIlxuICBlbHNlXG4gICAgd3JhcF9zeXNjYWxsIFdyaXRlIGZkIChmdW4gKCkgLT4gc3R1Yl9zZW5kdG8gKHVuaXhfZmlsZV9kZXNjciBmZCkgYnVmIHBvcyBsZW4gZmxhZ3MgYWRkcilcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBNZW1vcnkgbWFwcGVkIGZpbGVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG5sZXQgbWFwX2ZpbGUgfmZkID9wb3MgfnNoYXJlZCA/KHNpemU9KC0xKSkgKCkgPVxuICBVbml4Lm1hcF9maWxlIGZkID9wb3MgY2hhciBjX2xheW91dCBzaGFyZWQgW3xzaXplfF1cbiAgfD4gQmlnYXJyYXkuYXJyYXkxX29mX2dlbmFycmF5XG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmV4dGVybmFsIG1hcHBlZCA6IHQgLT4gYm9vbCA9IFwibHd0X3VuaXhfbWFwcGVkXCIgXCJub2FsbG9jXCJcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxudHlwZSBhZHZpY2UgPVxuICB8IE1BRFZfTk9STUFMXG4gIHwgTUFEVl9SQU5ET01cbiAgfCBNQURWX1NFUVVFTlRJQUxcbiAgfCBNQURWX1dJTExORUVEXG4gIHwgTUFEVl9ET05UTkVFRFxuICB8IE1BRFZfTUVSR0VBQkxFXG4gIHwgTUFEVl9VTk1FUkdFQUJMRVxuICB8IE1BRFZfSFVHRVBBR0VcbiAgfCBNQURWX05PSFVHRVBBR0VcblxuZXh0ZXJuYWwgc3R1Yl9tYWR2aXNlIDogdCAtPiBpbnQgLT4gaW50IC0+IGFkdmljZSAtPiB1bml0ID0gXCJsd3RfdW5peF9tYWR2aXNlXCJcblxubGV0IG1hZHZpc2UgYnVmIHBvcyBsZW4gYWR2aWNlID1cbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IGxlbmd0aCBidWYgLSBsZW4gdGhlblxuICAgIGludmFsaWRfYXJnIFwiTHd0X2J5dGVzLm1hZHZpc2VcIlxuICBlbHNlXG4gICAgc3R1Yl9tYWR2aXNlIGJ1ZiBwb3MgbGVuIGFkdmljZVxuXG5leHRlcm5hbCBnZXRfcGFnZV9zaXplIDogdW5pdCAtPiBpbnQgPSBcImx3dF91bml4X2dldF9wYWdlX3NpemVcIlxuXG5sZXQgcGFnZV9zaXplID0gZ2V0X3BhZ2Vfc2l6ZSAoKVxuXG5leHRlcm5hbCBzdHViX21pbmNvcmUgOiB0IC0+IGludCAtPiBpbnQgLT4gYm9vbCBhcnJheSAtPiB1bml0ID0gXCJsd3RfdW5peF9taW5jb3JlXCJcblxubGV0IG1pbmNvcmUgYnVmZmVyIG9mZnNldCBzdGF0ZXMgPVxuICBpZiAob2Zmc2V0IG1vZCBwYWdlX3NpemUgPD4gMFxuICAgICAgfHwgb2Zmc2V0IDwgMFxuICAgICAgfHwgbGVuZ3RoIGJ1ZmZlciAtIG9mZnNldCA8IChBcnJheS5sZW5ndGggc3RhdGVzIC0gMSkgKiBwYWdlX3NpemUgKyAxKVxuICB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJMd3RfYnl0ZXMubWluY29yZVwiXG4gIGVsc2VcbiAgICBzdHViX21pbmNvcmUgYnVmZmVyIG9mZnNldCAoQXJyYXkubGVuZ3RoIHN0YXRlcyAqIHBhZ2Vfc2l6ZSkgc3RhdGVzXG5cbmV4dGVybmFsIHdhaXRfbWluY29yZV9qb2IgOiB0IC0+IGludCAtPiB1bml0IGpvYiA9IFwibHd0X3VuaXhfd2FpdF9taW5jb3JlX2pvYlwiXG5cbmxldCB3YWl0X21pbmNvcmUgYnVmZmVyIG9mZnNldCA9XG4gIGlmIG9mZnNldCA8IDAgfHwgb2Zmc2V0ID49IGxlbmd0aCBidWZmZXIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiTHd0X2J5dGVzLndhaXRfbWluY29yZVwiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgc3RhdGUgPSBbfGZhbHNlfF0gaW5cbiAgICBtaW5jb3JlIGJ1ZmZlciAob2Zmc2V0IC0gKG9mZnNldCBtb2QgcGFnZV9zaXplKSkgc3RhdGU7XG4gICAgaWYgc3RhdGUuKDApIHRoZW5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIGVsc2VcbiAgICAgIHJ1bl9qb2IgKHdhaXRfbWluY29yZV9qb2IgYnVmZmVyIG9mZnNldClcbiAgZW5kXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbm9wZW4gTHd0LkluZml4XG5cbmV4Y2VwdGlvbiBDaGFubmVsX2Nsb3NlZCBvZiBzdHJpbmdcblxuKCogTWluaW11bSBzaXplIGZvciBidWZmZXJzOiAqKVxubGV0IG1pbl9idWZmZXJfc2l6ZSA9IDE2XG5cbmxldCBjaGVja19idWZmZXJfc2l6ZSBmdW5fbmFtZSBidWZmZXJfc2l6ZSA9XG4gIGlmIGJ1ZmZlcl9zaXplIDwgbWluX2J1ZmZlcl9zaXplIHRoZW5cbiAgICBQcmludGYua3NwcmludGYgaW52YWxpZF9hcmcgXCJMd3RfaW8uJXM6IHRvbyBzbWFsbCBidWZmZXIgc2l6ZVwiIGZ1bl9uYW1lXG4gIGVsc2UgaWYgYnVmZmVyX3NpemUgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZyBcIkx3dF9pby4lczogdG9vIGJpZyBidWZmZXIgc2l6ZVwiIGZ1bl9uYW1lXG4gIGVsc2VcbiAgICAoKVxuXG5sZXQgY2hlY2tfYnVmZmVyIGZ1bl9uYW1lIGJ1ZmZlciA9XG4gIGNoZWNrX2J1ZmZlcl9zaXplIGZ1bl9uYW1lIChMd3RfYnl0ZXMubGVuZ3RoIGJ1ZmZlcilcblxubGV0IGRlZmF1bHRfYnVmZmVyX3NpemUgPSByZWYgNDA5NlxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IFR5cGVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbnR5cGUgaW5wdXRcbnR5cGUgb3V0cHV0XG5cbnR5cGUgJ2EgbW9kZSA9XG4gIHwgSW5wdXQgOiBpbnB1dCBtb2RlXG4gIHwgT3V0cHV0IDogb3V0cHV0IG1vZGVcblxubGV0IGlucHV0IDogaW5wdXQgbW9kZSA9IElucHV0XG5sZXQgb3V0cHV0IDogb3V0cHV0IG1vZGUgPSBPdXRwdXRcblxuKCogQSBjaGFubmVsIHN0YXRlICopXG50eXBlICdtb2RlIHN0YXRlID1cbiAgfCBCdXN5X3ByaW1pdGl2ZVxuICAoKiBBIHByaW1pdGl2ZSBpcyBydW5uaW5nIG9uIHRoZSBjaGFubmVsICopXG5cbiAgfCBCdXN5X2F0b21pYyBvZiAnbW9kZSBjaGFubmVsXG4gICgqIEFuIGF0b21pYyBvcGVyYXRpb25zIGlzIGJlaW5nIHBlcmZvcm1lZCBvbiB0aGUgY2hhbm5lbC4gVGhlXG4gICAgIGFyZ3VtZW50IGlzIHRoZSB0ZW1wb3JhcnkgYXRvbWljIHdyYXBwZXIuICopXG5cbiAgfCBXYWl0aW5nX2Zvcl9idXN5XG4gICgqIEEgcXVldWVkIG9wZXJhdGlvbiBoYXMgbm90IHlldCBzdGFydGVkLiAqKVxuXG4gIHwgSWRsZVxuICAoKiBUaGUgY2hhbm5lbCBpcyB1bnVzZWQgKilcblxuICB8IENsb3NlZFxuICAoKiBUaGUgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQgKilcblxuICB8IEludmFsaWRcbiAgKCogVGhlIGNoYW5uZWwgaXMgYSB0ZW1wb3JhcnkgY2hhbm5lbCBjcmVhdGVkIGZvciBhbiBhdG9taWNcbiAgICAgb3BlcmF0aW9uIHdoaWNoIGhhcyB0ZXJtaW5hdGVkLiAqKVxuXG4oKiBBIHdyYXBwZXIsIHdoaWNoIGVuc3VyZXMgdGhhdCBpbyBvcGVyYXRpb25zIGFyZSBhdG9taWM6ICopXG5hbmQgJ21vZGUgY2hhbm5lbCA9IHtcbiAgbXV0YWJsZSBzdGF0ZSA6ICdtb2RlIHN0YXRlO1xuXG4gIGNoYW5uZWwgOiAnbW9kZSBfY2hhbm5lbDtcbiAgKCogVGhlIHJlYWwgY2hhbm5lbCAqKVxuXG4gIG11dGFibGUgcXVldWVkIDogdW5pdCBMd3QudSBMd3Rfc2VxdWVuY2UudDtcbiAgKCogUXVldWVkIG9wZXJhdGlvbnMgKilcbn1cblxuYW5kICdtb2RlIF9jaGFubmVsID0ge1xuICBtdXRhYmxlIGJ1ZmZlciA6IEx3dF9ieXRlcy50O1xuICBtdXRhYmxlIGxlbmd0aCA6IGludDtcblxuICBtdXRhYmxlIHB0ciA6IGludDtcbiAgKCogQ3VycmVudCBwb3NpdGlvbiAqKVxuXG4gIG11dGFibGUgbWF4IDogaW50O1xuICAoKiBQb3NpdGlvbiBvZiB0aGUgZW5kIG9mIGRhdGEgaW50IHRoZSBidWZmZXIuIEl0IGlzIGVxdWFsIHRvXG4gICAgIFtsZW5ndGhdIGZvciBvdXRwdXQgY2hhbm5lbHMuICopXG5cbiAgYWJvcnRfd2FpdGVyIDogaW50IEx3dC50O1xuICAoKiBUaHJlYWQgd2hpY2ggaXMgd2FrZXVwIHdpdGggYW4gZXhjZXB0aW9uIHdoZW4gdGhlIGNoYW5uZWwgaXNcbiAgICAgY2xvc2VkLiAqKVxuICBhYm9ydF93YWtlbmVyIDogaW50IEx3dC51O1xuXG4gIG11dGFibGUgYXV0b19mbHVzaGluZyA6IGJvb2w7XG4gICgqIFdoZXRoZXIgdGhlIGF1dG8tZmx1c2hlciBpcyBjdXJyZW50bHkgcnVubmluZyBvciBub3QgKilcblxuICBtYWluIDogJ21vZGUgY2hhbm5lbDtcbiAgKCogVGhlIG1haW4gd3JhcHBlciAqKVxuXG4gIGNsb3NlIDogdW5pdCBMd3QudCBMYXp5LnQ7XG4gICgqIENsb3NlIGZ1bmN0aW9uICopXG5cbiAgbW9kZSA6ICdtb2RlIG1vZGU7XG4gICgqIFRoZSBjaGFubmVsIG1vZGUgKilcblxuICBtdXRhYmxlIG9mZnNldCA6IGludDY0O1xuICAoKiBOdW1iZXIgb2YgYnl0ZXMgcmVhbGx5IHJlYWQvd3JpdHRlbiAqKVxuXG4gIHR5cCA6IHR5cDtcbiAgKCogVHlwZSBvZiB0aGUgY2hhbm5lbC4gKilcbn1cblxuYW5kIHR5cCA9XG4gIHwgVHlwZV9ub3JtYWwgb2ZcbiAgICAoTHd0X2J5dGVzLnQgLT4gaW50IC0+IGludCAtPiBpbnQgTHd0LnQpICpcbiAgICAgIChpbnQ2NCAtPiBVbml4LnNlZWtfY29tbWFuZCAtPiBpbnQ2NCBMd3QudClcbiAgKCogVGhlIGNoYW5uZWwgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIFttYWtlXS4gVGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgIGlzIHRoZSByZWZpbGwvZmx1c2ggZnVuY3Rpb24gYW5kIHRoZSBzZWNvbmQgaXMgdGhlIHNlZWtcbiAgICAgZnVuY3Rpb24uICopXG4gIHwgVHlwZV9ieXRlc1xuICAoKiBUaGUgY2hhbm5lbCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggW29mX2J5dGVzXS4gKilcblxudHlwZSBpbnB1dF9jaGFubmVsID0gaW5wdXQgY2hhbm5lbFxudHlwZSBvdXRwdXRfY2hhbm5lbCA9IG91dHB1dCBjaGFubmVsXG5cbnR5cGUgZGlyZWN0X2FjY2VzcyA9IHtcbiAgZGFfYnVmZmVyIDogTHd0X2J5dGVzLnQ7XG4gIG11dGFibGUgZGFfcHRyIDogaW50O1xuICBtdXRhYmxlIGRhX21heCA6IGludDtcbiAgZGFfcGVyZm9ybSA6IHVuaXQgLT4gaW50IEx3dC50O1xufVxuXG5sZXQgbW9kZSB3cmFwcGVyID0gd3JhcHBlci5jaGFubmVsLm1vZGVcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBDcmVhdGlvbnMsIGNsb3NpbmcsIGxvY2tpbmcsIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG4oKiBUaGlzIHN0cmFuZ2UgaGFzaCBmdW5jdGlvbiBpcyBmaW5lIGJlY2F1c2UgTHd0X2lvIG9ubHkgZXZlcjpcbiAgICAtIGFkZHMgZGlzdGluY3QgY2hhbm5lbHMgdG8gdGhlIGhhc2ggc2V0LFxuICAgIC0gZm9sZHMgb3ZlciB0aGUgaGFzaCBzZXQuXG4gICBMd3RfaW8gbmV2ZXIgbG9va3MgdXAgaW5kaXZpZHVhbCBlbGVtZW50cy4gVGhlIGNvbnN0YW50IGZ1bmN0aW9uIGlzIG5vdFxuICAgc3VpdGFibGUsIGJlY2F1c2UgdGhlbiBhbGwgY2hhbm5lbHMgd2lsbCBlbmQgdXAgaW4gdGhlIHNhbWUgaGFzaCBidWNrZXQuXG5cbiAgIEEgd2VhayBoYXNoIHNldCBpcyB1c2VkIGluc3RlYWQgb2YgYSB3ZWFrIGFycmF5IHRvIGF2b2lkIGhhdmluZyB0byBpbmNsdWRlXG4gICByZXNpemluZyBhbmQgY29tcGFjdGlvbiBjb2RlIGluIEx3dF9pby4gKilcbmxldCBoYXNoX291dHB1dF9jaGFubmVsID1cbiAgbGV0IGluZGV4ID0gcmVmIDAgaW5cbiAgZnVuICgpIC0+XG4gICAgaW5kZXggOj0gIWluZGV4ICsgMTtcbiAgICAhaW5kZXhcblxubW9kdWxlIE91dHB1dHMgPSBXZWFrLk1ha2Uoc3RydWN0XG4gICAgdHlwZSB0ID0gb3V0cHV0X2NoYW5uZWxcbiAgICBsZXQgaGFzaCBfID0gaGFzaF9vdXRwdXRfY2hhbm5lbCAoKVxuICAgIGxldCBlcXVhbCA9ICggPT0gKVxuICBlbmQpXG5cbigqIFRhYmxlIG9mIGFsbCBvcGVuZWQgb3V0cHV0IGNoYW5uZWxzLiBPbiBleGl0IHRoZXkgYXJlIGFsbFxuICAgZmx1c2hlZDogKilcbmxldCBvdXRwdXRzID0gT3V0cHV0cy5jcmVhdGUgMzJcblxubGV0IHBvc2l0aW9uIDogdHlwZSBtb2RlLiBtb2RlIGNoYW5uZWwgLT4gaW50NjQgPSBmdW4gd3JhcHBlciAtPlxuICBsZXQgY2ggPSB3cmFwcGVyLmNoYW5uZWwgaW5cbiAgbWF0Y2ggY2gubW9kZSB3aXRoXG4gIHwgSW5wdXQgLT5cbiAgICBJbnQ2NC5zdWIgY2gub2Zmc2V0IChJbnQ2NC5vZl9pbnQgKGNoLm1heCAtIGNoLnB0cikpXG4gIHwgT3V0cHV0IC0+XG4gICAgSW50NjQuYWRkIGNoLm9mZnNldCAoSW50NjQub2ZfaW50IGNoLnB0cilcblxubGV0IG5hbWUgOiB0eXBlIG1vZGUuIG1vZGUgX2NoYW5uZWwgLT4gc3RyaW5nID0gZnVuIGNoIC0+XG4gIG1hdGNoIGNoLm1vZGUgd2l0aFxuICB8IElucHV0IC0+IFwiaW5wdXRcIlxuICB8IE91dHB1dCAtPiBcIm91dHB1dFwiXG5cbmxldCBjbG9zZWRfY2hhbm5lbCBjaCA9IENoYW5uZWxfY2xvc2VkIChuYW1lIGNoKVxubGV0IGludmFsaWRfY2hhbm5lbCBjaCA9XG4gIEZhaWx1cmUgKFByaW50Zi5zcHJpbnRmIFwidGVtcG9yYXJ5IGF0b21pYyBjaGFubmVsICVzIG5vIG1vcmUgdmFsaWRcIiAobmFtZSBjaCkpXG5cbmxldCBpc19idXN5IGNoID1cbiAgbWF0Y2ggY2guc3RhdGUgd2l0aFxuICB8IEludmFsaWQgLT5cbiAgICByYWlzZSAoaW52YWxpZF9jaGFubmVsIGNoLmNoYW5uZWwpXG4gIHwgSWRsZSB8IENsb3NlZCAtPlxuICAgIGZhbHNlXG4gIHwgQnVzeV9wcmltaXRpdmUgfCBCdXN5X2F0b21pYyBfIHwgV2FpdGluZ19mb3JfYnVzeSAtPlxuICAgIHRydWVcblxuKCogRmx1c2gvcmVmaWxsIHRoZSBidWZmZXIuIE5vIHJhY2UgY29uZGl0aW9uIGNvdWxkIGhhcHBlbiBiZWNhdXNlXG4gICB0aGlzIGZ1bmN0aW9uIGlzIGFsd2F5cyBjYWxsZWQgYXRvbWljYWxseTogKilcbmxldCBwZXJmb3JtX2lvIDogdHlwZSBtb2RlLiBtb2RlIF9jaGFubmVsIC0+IGludCBMd3QudCA9IGZ1biBjaCAtPlxuICBtYXRjaCBjaC5tYWluLnN0YXRlIHdpdGhcbiAgfCBDbG9zZWQgLT5cbiAgICBMd3QuZmFpbCAoY2xvc2VkX2NoYW5uZWwgY2gpXG5cbiAgfCBJbnZhbGlkIC0+XG4gICAgTHd0LmZhaWwgKGludmFsaWRfY2hhbm5lbCBjaClcblxuICB8IElkbGVcbiAgfCBXYWl0aW5nX2Zvcl9idXN5IC0+XG4gICAgYXNzZXJ0IGZhbHNlXG5cbiAgfCBCdXN5X3ByaW1pdGl2ZVxuICB8IEJ1c3lfYXRvbWljIF8gLT5cbiAgICBtYXRjaCBjaC50eXAgd2l0aFxuICAgIHwgVHlwZV9ub3JtYWwgKHBlcmZvcm0sIF8pIC0+XG4gICAgICBsZXQgcHRyLCBsZW4gPVxuICAgICAgICBtYXRjaCBjaC5tb2RlIHdpdGhcbiAgICAgICAgfCBJbnB1dCAtPlxuICAgICAgICAgICgqIFNpemUgb2YgZGF0YSBpbiB0aGUgYnVmZmVyICopXG4gICAgICAgICAgbGV0IHNpemUgPSBjaC5tYXggLSBjaC5wdHIgaW5cbiAgICAgICAgICAoKiBJZiB0aGVyZSBhcmUgc3RpbGwgZGF0YSBpbiB0aGUgYnVmZmVyLCBrZWVwIHRoZW06ICopXG4gICAgICAgICAgaWYgc2l6ZSA+IDAgdGhlblxuICAgICAgICAgICAgTHd0X2J5dGVzLnVuc2FmZV9ibGl0IGNoLmJ1ZmZlciBjaC5wdHIgY2guYnVmZmVyIDAgc2l6ZTtcbiAgICAgICAgICAoKiBVcGRhdGUgcG9zaXRpb25zOiAqKVxuICAgICAgICAgIGNoLnB0ciA8LSAwO1xuICAgICAgICAgIGNoLm1heCA8LSBzaXplO1xuICAgICAgICAgIChzaXplLCBjaC5sZW5ndGggLSBzaXplKVxuICAgICAgICB8IE91dHB1dCAtPlxuICAgICAgICAgICgwLCBjaC5wdHIpXG4gICAgICBpblxuICAgICAgbGV0IHBlcmZvcm0gPVxuICAgICAgICBpZiBTeXMud2luMzIgdGhlblxuICAgICAgICAgIEx3dC5jYXRjaFxuICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICBwZXJmb3JtIGNoLmJ1ZmZlciBwdHIgbGVuKVxuICAgICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgICAgIHwgVW5peC5Vbml4X2Vycm9yIChVbml4LkVQSVBFLCBfLCBfKSAtPlxuICAgICAgICAgICAgICAgIEx3dC5yZXR1cm4gMFxuICAgICAgICAgICAgICB8IGV4biAtPiBMd3QucmVyYWlzZSBleG4pIFtAb2NhbWwud2FybmluZyBcIi00XCJdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwZXJmb3JtIGNoLmJ1ZmZlciBwdHIgbGVuXG4gICAgICBpblxuICAgICAgTHd0LnBpY2sgW2NoLmFib3J0X3dhaXRlcjsgcGVyZm9ybV0gPj49IGZ1biBuIC0+XG4gICAgICAoKiBOZXZlciB0cnVzdCB1c2VyIGZ1bmN0aW9ucy4uLiAqKVxuICAgICAgaWYgbiA8IDAgfHwgbiA+IGxlbiB0aGVuXG4gICAgICAgIEx3dC5mYWlsXG4gICAgICAgICAgKEZhaWx1cmVcbiAgICAgICAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICBcIkx3dF9pby5wZXJmb3JtX2lvOiBpbnZhbGlkIHJlc3VsdCBvZiB0aGUgWyVzXSBmdW5jdGlvblwiXG4gICAgICAgICAgICAgIChtYXRjaCBjaC5tb2RlIHdpdGggSW5wdXQgLT4gXCJyZWFkXCIgfCBPdXRwdXQgLT4gXCJ3cml0ZVwiKSkpXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgICgqIFVwZGF0ZSB0aGUgZ2xvYmFsIG9mZnNldDogKilcbiAgICAgICAgY2gub2Zmc2V0IDwtIEludDY0LmFkZCBjaC5vZmZzZXQgKEludDY0Lm9mX2ludCBuKTtcbiAgICAgICAgKCogVXBkYXRlIGJ1ZmZlciBwb3NpdGlvbnM6ICopXG4gICAgICAgIGJlZ2luIG1hdGNoIGNoLm1vZGUgd2l0aFxuICAgICAgICAgIHwgSW5wdXQgLT5cbiAgICAgICAgICAgIGNoLm1heCA8LSBjaC5tYXggKyBuXG4gICAgICAgICAgfCBPdXRwdXQgLT5cbiAgICAgICAgICAgICgqIFNoaWZ0IHJlbWFpbmluZyBkYXRhOiAqKVxuICAgICAgICAgICAgbGV0IGxlbiA9IGxlbiAtIG4gaW5cbiAgICAgICAgICAgIEx3dF9ieXRlcy51bnNhZmVfYmxpdCBjaC5idWZmZXIgbiBjaC5idWZmZXIgMCBsZW47XG4gICAgICAgICAgICBjaC5wdHIgPC0gbGVuXG4gICAgICAgIGVuZDtcbiAgICAgICAgTHd0LnJldHVybiBuXG4gICAgICBlbmRcblxuICAgIHwgVHlwZV9ieXRlcyAtPlxuICAgICAgYmVnaW4gbWF0Y2ggY2gubW9kZSB3aXRoXG4gICAgICB8IElucHV0IC0+XG4gICAgICAgIEx3dC5yZXR1cm4gMFxuICAgICAgfCBPdXRwdXQgLT5cbiAgICAgICAgTHd0LmZhaWxcbiAgICAgICAgICAoRmFpbHVyZSBcImNhbm5vdCBmbHVzaCBhIGNoYW5uZWwgY3JlYXRlZCB3aXRoIEx3dF9pby5vZl9zdHJpbmdcIilcbiAgICAgIGVuZFxuXG5sZXQgcmVmaWxsID0gcGVyZm9ybV9pb1xubGV0IGZsdXNoX3BhcnRpYWwgPSBwZXJmb3JtX2lvXG5cbmxldCByZWMgZmx1c2hfdG90YWwgb2MgPVxuICBpZiBvYy5wdHIgPiAwIHRoZW5cbiAgICBmbHVzaF9wYXJ0aWFsIG9jID4+PSBmdW4gXyAtPlxuICAgIGZsdXNoX3RvdGFsIG9jXG4gIGVsc2VcbiAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IHNhZmVfZmx1c2hfdG90YWwgb2MgPVxuICBMd3QuY2F0Y2hcbiAgICAoZnVuICgpIC0+IGZsdXNoX3RvdGFsIG9jKVxuICAgIChmdW4gXyAgLT4gTHd0LnJldHVybl91bml0KVxuXG5sZXQgZGVlcGVzdF93cmFwcGVyIGNoID1cbiAgbGV0IHJlYyBsb29wIHdyYXBwZXIgPVxuICAgIG1hdGNoIHdyYXBwZXIuc3RhdGUgd2l0aFxuICAgIHwgQnVzeV9hdG9taWMgd3JhcHBlciAtPlxuICAgICAgbG9vcCB3cmFwcGVyXG4gICAgfCBCdXN5X3ByaW1pdGl2ZSB8IFdhaXRpbmdfZm9yX2J1c3kgfCBJZGxlIHwgQ2xvc2VkIHwgSW52YWxpZCAtPlxuICAgICAgd3JhcHBlclxuICBpblxuICBsb29wIGNoLm1haW5cblxubGV0IGF1dG9fZmx1c2ggb2MgPVxuICBMd3QucGF1c2UgKCkgPj49IGZ1biAoKSAtPlxuICBsZXQgd3JhcHBlciA9IGRlZXBlc3Rfd3JhcHBlciBvYyBpblxuICBtYXRjaCB3cmFwcGVyLnN0YXRlIHdpdGhcbiAgfCBCdXN5X3ByaW1pdGl2ZSB8IFdhaXRpbmdfZm9yX2J1c3kgLT5cbiAgICAoKiBUaGUgY2hhbm5lbCBpcyB1c2VkLCBjYW5jZWwgYXV0byBmbHVzaGluZy4gSXQgd2lsbCBiZVxuICAgICAgIHJlc3RhcnRlZCB3aGVuIHRoZSBjaGFubmVsIEx3dC5yZXR1cm5zIHRvIHRoZSBbSWRsZV0gc3RhdGU6ICopXG4gICAgb2MuYXV0b19mbHVzaGluZyA8LSBmYWxzZTtcbiAgICBMd3QucmV0dXJuX3VuaXRcblxuICB8IEJ1c3lfYXRvbWljIF8gLT5cbiAgICAoKiBDYW5ub3QgaGFwcGVuIHNpbmNlIHdlIHRvb2sgdGhlIGRlZXBlc3Qgd3JhcHBlcjogKilcbiAgICBhc3NlcnQgZmFsc2VcblxuICB8IElkbGUgLT5cbiAgICBvYy5hdXRvX2ZsdXNoaW5nIDwtIGZhbHNlO1xuICAgIHdyYXBwZXIuc3RhdGUgPC0gQnVzeV9wcmltaXRpdmU7XG4gICAgc2FmZV9mbHVzaF90b3RhbCBvYyA+Pj0gZnVuICgpIC0+XG4gICAgaWYgd3JhcHBlci5zdGF0ZSA9IEJ1c3lfcHJpbWl0aXZlIHRoZW5cbiAgICAgIHdyYXBwZXIuc3RhdGUgPC0gSWRsZTtcbiAgICBpZiBub3QgKEx3dF9zZXF1ZW5jZS5pc19lbXB0eSB3cmFwcGVyLnF1ZXVlZCkgdGhlblxuICAgICAgTHd0Lndha2V1cF9sYXRlciAoTHd0X3NlcXVlbmNlLnRha2VfbCB3cmFwcGVyLnF1ZXVlZCkgKCk7XG4gICAgTHd0LnJldHVybl91bml0XG5cbiAgfCBDbG9zZWQgfCBJbnZhbGlkIC0+XG4gICAgTHd0LnJldHVybl91bml0XG5cbigqIEEgYGBsb2NrZWQnJyBjaGFubmVsIGlzIGEgY2hhbm5lbCBpbiB0aGUgc3RhdGUgW0J1c3lfcHJpbWl0aXZlXSBvclxuICAgW0J1c3lfYXRvbWljXSAqKVxuXG5sZXQgdW5sb2NrIDogdHlwZSBtLiBtIGNoYW5uZWwgLT4gdW5pdCA9IGZ1biB3cmFwcGVyIC0+IG1hdGNoIHdyYXBwZXIuc3RhdGUgd2l0aFxuICB8IEJ1c3lfcHJpbWl0aXZlIHwgQnVzeV9hdG9taWMgXyAtPlxuICAgIGlmIEx3dF9zZXF1ZW5jZS5pc19lbXB0eSB3cmFwcGVyLnF1ZXVlZCB0aGVuXG4gICAgICB3cmFwcGVyLnN0YXRlIDwtIElkbGVcbiAgICBlbHNlIGJlZ2luXG4gICAgICB3cmFwcGVyLnN0YXRlIDwtIFdhaXRpbmdfZm9yX2J1c3k7XG4gICAgICBMd3Qud2FrZXVwX2xhdGVyIChMd3Rfc2VxdWVuY2UudGFrZV9sIHdyYXBwZXIucXVldWVkKSAoKVxuICAgIGVuZDtcbiAgICAoKiBMYXVuY2hlcyB0aGUgYXV0by1mbHVzaGVyOiAqKVxuICAgIGxldCBjaCA9IHdyYXBwZXIuY2hhbm5lbCBpblxuICAgIGlmICgqIExhdW5jaCB0aGUgYXV0by1mbHVzaGVyIG9ubHkgaWYgdGhlIGNoYW5uZWwgaXMgbm90IGJ1c3k6ICopXG4gICAgICAod3JhcHBlci5zdGF0ZSA9IElkbGUgJiZcbiAgICAgICAoKiBMYXVuY2ggdGhlIGF1dG8tZmx1c2hlciBvbmx5IGZvciBvdXRwdXQgY2hhbm5lbDogKilcbiAgICAgICAobWF0Y2ggY2gubW9kZSB3aXRoIElucHV0IC0+IGZhbHNlIHwgT3V0cHV0IC0+IHRydWUpICYmXG4gICAgICAgKCogRG8gbm90IGxhdW5jaCB0d28gYXV0by1mbHVzaGVyOiAqKVxuICAgICAgIG5vdCBjaC5hdXRvX2ZsdXNoaW5nICYmXG4gICAgICAgKCogRG8gbm90IGxhdW5jaCB0aGUgYXV0by1mbHVzaGVyIGlmIG9wZXJhdGlvbnMgYXJlIHF1ZXVlZDogKilcbiAgICAgICBMd3Rfc2VxdWVuY2UuaXNfZW1wdHkgd3JhcHBlci5xdWV1ZWQpIHRoZW4gYmVnaW5cbiAgICAgIGNoLmF1dG9fZmx1c2hpbmcgPC0gdHJ1ZTtcbiAgICAgIGlnbm9yZSAoYXV0b19mbHVzaCBjaClcbiAgICBlbmRcblxuICB8IENsb3NlZCB8IEludmFsaWQgLT5cbiAgICAoKiBEbyBub3QgY2hhbmdlIGNoYW5uZWwgc3RhdGUgaWYgdGhlIGNoYW5uZWwgaGFzIGJlZW4gY2xvc2VkICopXG4gICAgaWYgbm90IChMd3Rfc2VxdWVuY2UuaXNfZW1wdHkgd3JhcHBlci5xdWV1ZWQpIHRoZW5cbiAgICAgIEx3dC53YWtldXBfbGF0ZXIgKEx3dF9zZXF1ZW5jZS50YWtlX2wgd3JhcHBlci5xdWV1ZWQpICgpXG5cbiAgfCBJZGxlIHwgV2FpdGluZ19mb3JfYnVzeSAtPlxuICAgICgqIFdlIG11c3QgbmV2ZXIgdW5sb2NrIGFuIHVubG9ja2VkIGNoYW5uZWwgKilcbiAgICBhc3NlcnQgZmFsc2VcblxuKCogV3JhcCBwcmltaXRpdmVzIGludG8gYXRvbWljIGlvIG9wZXJhdGlvbnM6ICopXG5sZXQgcHJpbWl0aXZlIGYgd3JhcHBlciA9IG1hdGNoIHdyYXBwZXIuc3RhdGUgd2l0aFxuICB8IElkbGUgLT5cbiAgICB3cmFwcGVyLnN0YXRlIDwtIEJ1c3lfcHJpbWl0aXZlO1xuICAgIEx3dC5maW5hbGl6ZVxuICAgICAgKGZ1biAoKSAtPiBmIHdyYXBwZXIuY2hhbm5lbClcbiAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgIHVubG9jayB3cmFwcGVyO1xuICAgICAgICAgTHd0LnJldHVybl91bml0KVxuXG4gIHwgQnVzeV9wcmltaXRpdmUgfCBCdXN5X2F0b21pYyBfIHwgV2FpdGluZ19mb3JfYnVzeSAtPlxuICAgIChMd3QuYWRkX3Rhc2tfciBbQG9jYW1sLndhcm5pbmcgXCItM1wiXSkgd3JhcHBlci5xdWV1ZWQgPj49IGZ1biAoKSAtPlxuICAgIGJlZ2luIG1hdGNoIHdyYXBwZXIuc3RhdGUgd2l0aFxuICAgICAgfCBDbG9zZWQgLT5cbiAgICAgICAgKCogVGhlIGNoYW5uZWwgaGFzIGJlZW4gY2xvc2VkIHdoaWxlIHdlIHdlcmUgd2FpdGluZyAqKVxuICAgICAgICB1bmxvY2sgd3JhcHBlcjtcbiAgICAgICAgTHd0LmZhaWwgKGNsb3NlZF9jaGFubmVsIHdyYXBwZXIuY2hhbm5lbClcblxuICAgICAgfCBJZGxlIHwgV2FpdGluZ19mb3JfYnVzeSAtPlxuICAgICAgICB3cmFwcGVyLnN0YXRlIDwtIEJ1c3lfcHJpbWl0aXZlO1xuICAgICAgICBMd3QuZmluYWxpemVcbiAgICAgICAgICAoZnVuICgpIC0+IGYgd3JhcHBlci5jaGFubmVsKVxuICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgICB1bmxvY2sgd3JhcHBlcjtcbiAgICAgICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG5cbiAgICAgIHwgSW52YWxpZCAtPlxuICAgICAgICBMd3QuZmFpbCAoaW52YWxpZF9jaGFubmVsIHdyYXBwZXIuY2hhbm5lbClcblxuICAgICAgfCBCdXN5X3ByaW1pdGl2ZSB8IEJ1c3lfYXRvbWljIF8gLT5cbiAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgZW5kXG5cbiAgfCBDbG9zZWQgLT5cbiAgICBMd3QuZmFpbCAoY2xvc2VkX2NoYW5uZWwgd3JhcHBlci5jaGFubmVsKVxuXG4gIHwgSW52YWxpZCAtPlxuICAgIEx3dC5mYWlsIChpbnZhbGlkX2NoYW5uZWwgd3JhcHBlci5jaGFubmVsKVxuXG4oKiBXcmFwIGEgc2VxdWVuY2Ugb2YgaW8gb3BlcmF0aW9ucyBpbnRvIGFuIGF0b21pYyBvcGVyYXRpb246ICopXG5sZXQgYXRvbWljIGYgd3JhcHBlciA9IG1hdGNoIHdyYXBwZXIuc3RhdGUgd2l0aFxuICB8IElkbGUgLT5cbiAgICBsZXQgdG1wX3dyYXBwZXIgPSB7IHN0YXRlID0gSWRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSB3cmFwcGVyLmNoYW5uZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZWQgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIH0gaW5cbiAgICB3cmFwcGVyLnN0YXRlIDwtIEJ1c3lfYXRvbWljIHRtcF93cmFwcGVyO1xuICAgIEx3dC5maW5hbGl6ZVxuICAgICAgKGZ1biAoKSAtPiBmIHRtcF93cmFwcGVyKVxuICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgKCogVGhlIHRlbXBvcmFyeSB3cmFwcGVyIGlzIG5vIG1vcmUgdmFsaWQ6ICopXG4gICAgICAgICB0bXBfd3JhcHBlci5zdGF0ZSA8LSBJbnZhbGlkO1xuICAgICAgICAgdW5sb2NrIHdyYXBwZXI7XG4gICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG5cbiAgfCBCdXN5X3ByaW1pdGl2ZSB8IEJ1c3lfYXRvbWljIF8gfCBXYWl0aW5nX2Zvcl9idXN5IC0+XG4gICAgKEx3dC5hZGRfdGFza19yIFtAb2NhbWwud2FybmluZyBcIi0zXCJdKSB3cmFwcGVyLnF1ZXVlZCA+Pj0gZnVuICgpIC0+XG4gICAgYmVnaW4gbWF0Y2ggd3JhcHBlci5zdGF0ZSB3aXRoXG4gICAgICB8IENsb3NlZCAtPlxuICAgICAgICAoKiBUaGUgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQgd2hpbGUgd2Ugd2VyZSB3YWl0aW5nICopXG4gICAgICAgIHVubG9jayB3cmFwcGVyO1xuICAgICAgICBMd3QuZmFpbCAoY2xvc2VkX2NoYW5uZWwgd3JhcHBlci5jaGFubmVsKVxuXG4gICAgICB8IElkbGUgfCBXYWl0aW5nX2Zvcl9idXN5IC0+XG4gICAgICAgIGxldCB0bXBfd3JhcHBlciA9IHsgc3RhdGUgPSBJZGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSB3cmFwcGVyLmNoYW5uZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVkID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSB9IGluXG4gICAgICAgIHdyYXBwZXIuc3RhdGUgPC0gQnVzeV9hdG9taWMgdG1wX3dyYXBwZXI7XG4gICAgICAgIEx3dC5maW5hbGl6ZVxuICAgICAgICAgIChmdW4gKCkgLT4gZiB0bXBfd3JhcHBlcilcbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgdG1wX3dyYXBwZXIuc3RhdGUgPC0gSW52YWxpZDtcbiAgICAgICAgICAgICB1bmxvY2sgd3JhcHBlcjtcbiAgICAgICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG5cbiAgICAgIHwgSW52YWxpZCAtPlxuICAgICAgICBMd3QuZmFpbCAoaW52YWxpZF9jaGFubmVsIHdyYXBwZXIuY2hhbm5lbClcblxuICAgICAgfCBCdXN5X3ByaW1pdGl2ZSB8IEJ1c3lfYXRvbWljIF8gLT5cbiAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgZW5kXG5cbiAgfCBDbG9zZWQgLT5cbiAgICBMd3QuZmFpbCAoY2xvc2VkX2NoYW5uZWwgd3JhcHBlci5jaGFubmVsKVxuXG4gIHwgSW52YWxpZCAtPlxuICAgIEx3dC5mYWlsIChpbnZhbGlkX2NoYW5uZWwgd3JhcHBlci5jaGFubmVsKVxuXG5sZXQgcmVjIGFib3J0IHdyYXBwZXIgPSBtYXRjaCB3cmFwcGVyLnN0YXRlIHdpdGhcbiAgfCBCdXN5X2F0b21pYyB0bXBfd3JhcHBlciAtPlxuICAgICgqIENsb3NlIHRoZSBkZXBlc3Qgb3BlbmVkIHdyYXBwZXI6ICopXG4gICAgYWJvcnQgdG1wX3dyYXBwZXJcbiAgfCBDbG9zZWQgLT5cbiAgICAoKiBEb3VibGUgY2xvc2UsIGp1c3QgcmV0dXJucyB0aGUgc2FtZSB0aGluZyBhcyBiZWZvcmUgKilcbiAgICBMYXp5LmZvcmNlIHdyYXBwZXIuY2hhbm5lbC5jbG9zZVxuICB8IEludmFsaWQgLT5cbiAgICBMd3QuZmFpbCAoaW52YWxpZF9jaGFubmVsIHdyYXBwZXIuY2hhbm5lbClcbiAgfCBJZGxlIHwgQnVzeV9wcmltaXRpdmUgfCBXYWl0aW5nX2Zvcl9idXN5IC0+XG4gICAgd3JhcHBlci5zdGF0ZSA8LSBDbG9zZWQ7XG4gICAgKCogQWJvcnQgYW55IGN1cnJlbnQgcmVhbCByZWFkaW5nL3dyaXRpbmcgb3BlcmF0aW9uIG9uIHRoZVxuICAgICAgIGNoYW5uZWw6ICopXG4gICAgTHd0Lndha2V1cF9leG5cbiAgICAgIHdyYXBwZXIuY2hhbm5lbC5hYm9ydF93YWtlbmVyIChjbG9zZWRfY2hhbm5lbCB3cmFwcGVyLmNoYW5uZWwpO1xuICAgIExhenkuZm9yY2Ugd3JhcHBlci5jaGFubmVsLmNsb3NlXG5cbmxldCBjbG9zZSA6IHR5cGUgbW9kZS4gbW9kZSBjaGFubmVsIC0+IHVuaXQgTHd0LnQgPSBmdW4gd3JhcHBlciAtPlxuICBsZXQgY2hhbm5lbCA9IHdyYXBwZXIuY2hhbm5lbCBpblxuICBpZiBjaGFubmVsLm1haW4gIT0gd3JhcHBlciB0aGVuXG4gICAgTHd0LmZhaWxcbiAgICAgIChGYWlsdXJlXG4gICAgICAgIFwiTHd0X2lvLmNsb3NlOiBjYW5ub3QgY2xvc2UgYSBjaGFubmVsIG9idGFpbmVkIHZpYSBMd3RfaW8uYXRvbWljXCIpXG4gIGVsc2VcbiAgICBtYXRjaCBjaGFubmVsLm1vZGUgd2l0aFxuICAgIHwgSW5wdXQgLT5cbiAgICAgICgqIEp1c3QgY2xvc2UgaXQgbm93OiAqKVxuICAgICAgYWJvcnQgd3JhcHBlclxuICAgIHwgT3V0cHV0IC0+XG4gICAgICBMd3QuY2F0Y2hcbiAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAoKiBQZXJmb3JtcyBhbGwgcGVuZGluZyBhY3Rpb25zLCBmbHVzaCB0aGUgYnVmZmVyLCB0aGVuIGNsb3NlIGl0OiAqKVxuICAgICAgICAgICBwcmltaXRpdmUgKGZ1biBjaGFubmVsIC0+XG4gICAgICAgICAgICAgc2FmZV9mbHVzaF90b3RhbCBjaGFubmVsID4+PSBmdW4gKCkgLT4gYWJvcnQgd3JhcHBlcikgd3JhcHBlcilcbiAgICAgICAgKGZ1biBfIC0+XG4gICAgICAgICAgIGFib3J0IHdyYXBwZXIpXG5cbmxldCBpc19jbG9zZWQgd3JhcHBlciA9XG4gIG1hdGNoIHdyYXBwZXIuc3RhdGUgd2l0aFxuICB8IENsb3NlZCAtPiB0cnVlXG4gIHwgQnVzeV9wcmltaXRpdmUgfCBCdXN5X2F0b21pYyBfIHwgV2FpdGluZ19mb3JfYnVzeSB8IElkbGUgfCBJbnZhbGlkIC0+IGZhbHNlXG5cbmxldCBmbHVzaF9hbGwgKCkgPVxuICBsZXQgd3JhcHBlcnMgPSBPdXRwdXRzLmZvbGQgKGZ1biB4IGwgLT4geCA6OiBsKSBvdXRwdXRzIFtdIGluXG4gIEx3dF9saXN0Lml0ZXJfcFxuICAgIChmdW4gd3JhcHBlciAtPlxuICAgICAgIEx3dC5jYXRjaFxuICAgICAgICAgKGZ1biAoKSAtPiBwcmltaXRpdmUgc2FmZV9mbHVzaF90b3RhbCB3cmFwcGVyKVxuICAgICAgICAgKGZ1biBfICAtPiBMd3QucmV0dXJuX3VuaXQpKVxuICAgIHdyYXBwZXJzXG5cbmxldCAoKSA9XG4gICgqIEZsdXNoIGFsbCBvcGVuZWQgb3V0cHV0IGNoYW5uZWxzIG9uIGV4aXQ6ICopXG4gIEx3dF9tYWluLmF0X2V4aXQgZmx1c2hfYWxsXG5cbmxldCBub19zZWVrIF9wb3MgX2NtZCA9XG4gIEx3dC5mYWlsIChGYWlsdXJlIFwiTHd0X2lvLnNlZWs6IHNlZWsgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGNoYW5uZWxcIilcblxubGV0IG1ha2UgOlxuICAgIHR5cGUgbS5cbiAgICA/YnVmZmVyIDogTHd0X2J5dGVzLnQgLT5cbiAgICA/Y2xvc2UgOiAodW5pdCAtPiB1bml0IEx3dC50KSAtPlxuICAgID9zZWVrIDogKGludDY0IC0+IFVuaXguc2Vla19jb21tYW5kIC0+IGludDY0IEx3dC50KSAtPlxuICAgIG1vZGUgOiBtIG1vZGUgLT5cbiAgICAoTHd0X2J5dGVzLnQgLT4gaW50IC0+IGludCAtPiBpbnQgTHd0LnQpIC0+XG4gICAgICBtIGNoYW5uZWwgPVxuICAgIGZ1biA/YnVmZmVyID8oY2xvc2U9THd0LnJldHVybikgPyhzZWVrPW5vX3NlZWspIH5tb2RlIHBlcmZvcm1faW8gLT5cbiAgbGV0IChidWZmZXIsIHNpemUpID1cbiAgICBtYXRjaCBidWZmZXIgd2l0aFxuICAgIHwgU29tZSBidWZmZXIgLT5cbiAgICAgIGNoZWNrX2J1ZmZlciBcIkx3dF9pby5tYWtlXCIgYnVmZmVyO1xuICAgICAgKGJ1ZmZlciwgTHd0X2J5dGVzLmxlbmd0aCBidWZmZXIpXG4gICAgfCBOb25lIC0+XG4gICAgICBsZXQgc2l6ZSA9ICFkZWZhdWx0X2J1ZmZlcl9zaXplIGluXG4gICAgICAoTHd0X2J5dGVzLmNyZWF0ZSBzaXplLCBzaXplKVxuICBpblxuICBsZXQgYWJvcnRfd2FpdGVyLCBhYm9ydF93YWtlbmVyID0gTHd0LndhaXQgKCkgaW5cbiAgbGV0IHJlYyBjaCA9IHtcbiAgICBidWZmZXIgPSBidWZmZXI7XG4gICAgbGVuZ3RoID0gc2l6ZTtcbiAgICBwdHIgPSAwO1xuICAgIG1heCA9IChtYXRjaCBtb2RlIHdpdGhcbiAgICAgIHwgSW5wdXQgLT4gMFxuICAgICAgfCBPdXRwdXQgLT4gc2l6ZSk7XG4gICAgY2xvc2UgPSBsYXp5KEx3dC5jYXRjaCBjbG9zZSBMd3QucmVyYWlzZSk7XG4gICAgYWJvcnRfd2FpdGVyID0gYWJvcnRfd2FpdGVyO1xuICAgIGFib3J0X3dha2VuZXIgPSBhYm9ydF93YWtlbmVyO1xuICAgIG1haW4gPSB3cmFwcGVyO1xuICAgIGF1dG9fZmx1c2hpbmcgPSBmYWxzZTtcbiAgICBtb2RlID0gbW9kZTtcbiAgICBvZmZzZXQgPSAwTDtcbiAgICB0eXAgPVxuICAgICAgVHlwZV9ub3JtYWwgKFxuICAgICAgICBwZXJmb3JtX2lvLFxuICAgICAgICBmdW4gcG9zIGNtZCAtPlxuICAgICAgICAgIHRyeSBzZWVrIHBvcyBjbWRcbiAgICAgICAgICB3aXRoIGUgd2hlbiBMd3QuRXhjZXB0aW9uX2ZpbHRlci5ydW4gZSAtPiBMd3QucmVyYWlzZSBlXG4gICAgKTtcbiAgfSBhbmQgd3JhcHBlciA9IHtcbiAgICBzdGF0ZSA9IElkbGU7XG4gICAgY2hhbm5lbCA9IGNoO1xuICAgIHF1ZXVlZCA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCk7XG4gIH0gaW5cbiAgKG1hdGNoIG1vZGUgd2l0aFxuICAgfCBJbnB1dCAtPiAoKVxuICAgfCBPdXRwdXQgLT4gT3V0cHV0cy5hZGQgb3V0cHV0cyB3cmFwcGVyKTtcbiAgd3JhcHBlclxuXG5sZXQgb2ZfYnl0ZXMgKHR5cGUgbSkgfihtb2RlIDogbSBtb2RlKSBieXRlcyA9XG4gIGxldCBsZW5ndGggPSBMd3RfYnl0ZXMubGVuZ3RoIGJ5dGVzIGluXG4gIGxldCBhYm9ydF93YWl0ZXIsIGFib3J0X3dha2VuZXIgPSBMd3Qud2FpdCAoKSBpblxuICBsZXQgcmVjIGNoID0ge1xuICAgIGJ1ZmZlciA9IGJ5dGVzO1xuICAgIGxlbmd0aCA9IGxlbmd0aDtcbiAgICBwdHIgPSAwO1xuICAgIG1heCA9IGxlbmd0aDtcbiAgICBjbG9zZSA9IGxhenkoTHd0LnJldHVybl91bml0KTtcbiAgICBhYm9ydF93YWl0ZXIgPSBhYm9ydF93YWl0ZXI7XG4gICAgYWJvcnRfd2FrZW5lciA9IGFib3J0X3dha2VuZXI7XG4gICAgbWFpbiA9IHdyYXBwZXI7XG4gICAgKCogQXV0byBmbHVzaCBpcyBzZXQgdG8gW3RydWVdIHRvIHByZXZlbnQgd3JpdGluZyBmdW5jdGlvbnMgZnJvbVxuICAgICAgIHRyeWluZyB0byBsYXVuY2ggdGhlIGF1dG8tZmxsdXNoZWQuICopXG4gICAgYXV0b19mbHVzaGluZyA9IHRydWU7XG4gICAgbW9kZSA9IG1vZGU7XG4gICAgb2Zmc2V0ID0gKG1hdGNoIG1vZGUgd2l0aFxuICAgICAgICB8IE91dHB1dCAtPiAwTFxuICAgICAgICB8IElucHV0IC0+IEludDY0Lm9mX2ludCBsZW5ndGgpO1xuICAgIHR5cCA9IFR5cGVfYnl0ZXM7XG4gIH0gYW5kIHdyYXBwZXIgPSB7XG4gICAgc3RhdGUgPSBJZGxlO1xuICAgIGNoYW5uZWwgPSBjaDtcbiAgICBxdWV1ZWQgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpO1xuICB9IGluXG4gIHdyYXBwZXJcblxubGV0IG9mX2ZkIDpcbiAgICB0eXBlIG0uXG4gICAgP2J1ZmZlciA6IEx3dF9ieXRlcy50IC0+XG4gICAgP2Nsb3NlIDogKHVuaXQgLT4gdW5pdCBMd3QudCkgLT5cbiAgICBtb2RlIDogbSBtb2RlIC0+XG4gICAgTHd0X3VuaXguZmlsZV9kZXNjciAtPlxuICAgICAgbSBjaGFubmVsID1cbiAgICBmdW4gP2J1ZmZlciA/Y2xvc2Ugfm1vZGUgZmQgLT5cbiAgbGV0IHBlcmZvcm1faW8gPSBtYXRjaCBtb2RlIHdpdGhcbiAgICB8IElucHV0IC0+IEx3dF9ieXRlcy5yZWFkIGZkXG4gICAgfCBPdXRwdXQgLT4gTHd0X2J5dGVzLndyaXRlIGZkXG4gIGluXG4gIG1ha2VcbiAgICA/YnVmZmVyXG4gICAgfmNsb3NlOihtYXRjaCBjbG9zZSB3aXRoXG4gICAgICB8IFNvbWUgZiAtPiBmXG4gICAgICB8IE5vbmUgLT4gKGZ1biAoKSAtPiBMd3RfdW5peC5jbG9zZSBmZCkpXG4gICAgfnNlZWs6KGZ1biBwb3MgY21kIC0+IEx3dF91bml4LkxhcmdlRmlsZS5sc2VlayBmZCBwb3MgY21kKVxuICAgIH5tb2RlXG4gICAgcGVyZm9ybV9pb1xuXG5sZXQgb2ZfdW5peF9mZCA6XG4gICAgdHlwZSBtLlxuICAgID9idWZmZXIgOiBMd3RfYnl0ZXMudCAtPlxuICAgID9jbG9zZSA6ICh1bml0IC0+IHVuaXQgTHd0LnQpIC0+XG4gICAgbW9kZSA6IG0gbW9kZSAtPiBVbml4LmZpbGVfZGVzY3IgLT5cbiAgICAgIG0gY2hhbm5lbCA9XG4gICAgZnVuID9idWZmZXIgP2Nsb3NlIH5tb2RlIGZkIC0+XG4gIG9mX2ZkID9idWZmZXIgP2Nsb3NlIH5tb2RlIChMd3RfdW5peC5vZl91bml4X2ZpbGVfZGVzY3IgZmQpXG5cbmxldCBidWZmZXJlZCA6IHR5cGUgbS4gbSBjaGFubmVsIC0+IGludCA9IGZ1biBjaCAtPlxuICBtYXRjaCBjaC5jaGFubmVsLm1vZGUgd2l0aFxuICB8IElucHV0IC0+IGNoLmNoYW5uZWwubWF4IC0gY2guY2hhbm5lbC5wdHJcbiAgfCBPdXRwdXQgLT4gY2guY2hhbm5lbC5wdHJcblxubGV0IGJ1ZmZlcl9zaXplIGNoID0gY2guY2hhbm5lbC5sZW5ndGhcblxubGV0IHJlc2l6ZV9idWZmZXIgOiB0eXBlIG0uIG0gY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCBMd3QudCA9IGZ1biB3cmFwcGVyIGxlbiAtPlxuICBpZiBsZW4gPCBtaW5fYnVmZmVyX3NpemUgdGhlblxuICAgIGludmFsaWRfYXJnIFwiTHd0X2lvLnJlc2l6ZV9idWZmZXI6IGJ1ZmZlciBzaXplIHRvbyBzbWFsbFwiO1xuICBtYXRjaCB3cmFwcGVyLmNoYW5uZWwudHlwIHdpdGhcbiAgfCBUeXBlX2J5dGVzIC0+XG4gICAgTHd0LmZhaWxcbiAgICAgIChGYWlsdXJlXG4gICAgICAgIChcIkx3dF9pby5yZXNpemVfYnVmZmVyOiBjYW5ub3QgcmVzaXplIHRoZSBidWZmZXIgb2YgYSBjaGFubmVsIFwiIF5cbiAgICAgICAgIFwiY3JlYXRlZCB3aXRoIEx3dF9pby5vZl9zdHJpbmdcIikpXG4gIHwgVHlwZV9ub3JtYWwgXyAtPlxuICAgIGxldCBmIDogdHlwZSBtLiBtIF9jaGFubmVsIC0+IHVuaXQgTHd0LnQgPSBmdW4gY2ggLT5cbiAgICAgIG1hdGNoIGNoLm1vZGUgd2l0aFxuICAgICAgfCBJbnB1dCAtPlxuICAgICAgICBsZXQgdW5yZWFkX2NvdW50ID0gY2gubWF4IC0gY2gucHRyIGluXG4gICAgICAgICgqIEZhaWwgaWYgd2Ugd2FudCB0byBkZWNyZWFzZSB0aGUgYnVmZmVyIHNpemUgYW5kIHRoZXJlIGlzXG4gICAgICAgICAgIHRvbyBtdWNoIHVucmVhZCBkYXRhIGluIHRoZSBidWZmZXI6ICopXG4gICAgICAgIGlmIGxlbiA8IHVucmVhZF9jb3VudCB0aGVuXG4gICAgICAgICAgTHd0LmZhaWxcbiAgICAgICAgICAgIChGYWlsdXJlXG4gICAgICAgICAgICAgIChcIkx3dF9pby5yZXNpemVfYnVmZmVyOiBjYW5ub3QgZGVjcmVhc2UgYnVmZmVyIHNpemUsIHRvbyBtdWNoIFwiIF5cbiAgICAgICAgICAgICAgIFwidW5yZWFkIGRhdGFcIikpXG4gICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICBsZXQgYnVmZmVyID0gTHd0X2J5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICAgICAgICBMd3RfYnl0ZXMudW5zYWZlX2JsaXQgY2guYnVmZmVyIGNoLnB0ciBidWZmZXIgMCB1bnJlYWRfY291bnQ7XG4gICAgICAgICAgY2guYnVmZmVyIDwtIGJ1ZmZlcjtcbiAgICAgICAgICBjaC5sZW5ndGggPC0gbGVuO1xuICAgICAgICAgIGNoLnB0ciA8LSAwO1xuICAgICAgICAgIGNoLm1heCA8LSB1bnJlYWRfY291bnQ7XG4gICAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgICAgIGVuZFxuICAgICAgfCBPdXRwdXQgLT5cbiAgICAgICAgKCogSWYgd2UgZGVjcmVhc2UgdGhlIGJ1ZmZlciBzaXplLCBmbHVzaCB0aGUgYnVmZmVyIHVudGlsXG4gICAgICAgICAgIHRoZSBudW1iZXIgb2YgYnVmZmVyZWQgYnl0ZXMgZml0cyBpbnRvIHRoZSBuZXcgYnVmZmVyOiAqKVxuICAgICAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgICAgIGlmIGNoLnB0ciA+IGxlbiB0aGVuXG4gICAgICAgICAgICBmbHVzaF9wYXJ0aWFsIGNoID4+PSBmdW4gXyAtPlxuICAgICAgICAgICAgbG9vcCAoKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgICAgICBpblxuICAgICAgICBsb29wICgpID4+PSBmdW4gKCkgLT5cbiAgICAgICAgbGV0IGJ1ZmZlciA9IEx3dF9ieXRlcy5jcmVhdGUgbGVuIGluXG4gICAgICAgIEx3dF9ieXRlcy51bnNhZmVfYmxpdCBjaC5idWZmZXIgMCBidWZmZXIgMCBjaC5wdHI7XG4gICAgICAgIGNoLmJ1ZmZlciA8LSBidWZmZXI7XG4gICAgICAgIGNoLmxlbmd0aCA8LSBsZW47XG4gICAgICAgIGNoLm1heCA8LSBsZW47XG4gICAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIGluXG4gICAgcHJpbWl0aXZlIGYgd3JhcHBlclxuXG5tb2R1bGUgUHJpbWl0aXZlcyA9XG5zdHJ1Y3RcblxuICAoKiBUaGlzIG1vZHVsZSBjb250YWlucyBhbGwgcHJpbWl0aXZlcyBvcGVyYXRpb25zLiBUaGUgb3BlcmF0ZXNcbiAgICAgd2l0aG91dCBwcm90ZWN0aW9uIHJlZ2FyZGluZyBsb2NraW5nLCB0aGV5IGFyZSB3cmFwcGVkIGFmdGVyIGludG9cbiAgICAgc2FmZSBvcGVyYXRpb25zLiAqKVxuXG4gICgqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgIHwgUmVhZGluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbiAgbGV0IHJlYyByZWFkX2NoYXIgaWMgPVxuICAgIGxldCBwdHIgPSBpYy5wdHIgaW5cbiAgICBpZiBwdHIgPSBpYy5tYXggdGhlblxuICAgICAgcmVmaWxsIGljID4+PSBmdW5jdGlvblxuICAgICAgfCAwIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gLT4gcmVhZF9jaGFyIGljXG4gICAgZWxzZSBiZWdpblxuICAgICAgaWMucHRyIDwtIHB0ciArIDE7XG4gICAgICBMd3QucmV0dXJuIChMd3RfYnl0ZXMudW5zYWZlX2dldCBpYy5idWZmZXIgcHRyKVxuICAgIGVuZFxuXG4gIGxldCByZWFkX2NoYXJfb3B0IGljID1cbiAgICBMd3QuY2F0Y2hcbiAgICAgIChmdW4gKCkgLT4gcmVhZF9jaGFyIGljID58PSBmdW4gY2ggLT4gU29tZSBjaClcbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IEVuZF9vZl9maWxlIC0+IEx3dC5yZXR1cm5fbm9uZVxuICAgICAgICB8IGV4biAtPiBMd3QucmVyYWlzZSBleG4pXG5cbiAgbGV0IHJlYWRfbGluZSBpYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTI4IGluXG4gICAgbGV0IHJlYyBsb29wIGNyX3JlYWQgPVxuICAgICAgTHd0LnRyeV9iaW5kIChmdW4gXyAtPiByZWFkX2NoYXIgaWMpXG4gICAgICAgIChmdW5jdGlvblxuICAgICAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICAgIEx3dC5yZXR1cm4oQnVmZmVyLmNvbnRlbnRzIGJ1ZilcbiAgICAgICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgICBpZiBjcl9yZWFkIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxyJztcbiAgICAgICAgICAgIGxvb3AgdHJ1ZVxuICAgICAgICAgIHwgY2ggLT5cbiAgICAgICAgICAgIGlmIGNyX3JlYWQgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXHInO1xuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjaDtcbiAgICAgICAgICAgIGxvb3AgZmFsc2UpXG4gICAgICAgIChmdW5jdGlvblxuICAgICAgICAgIHwgRW5kX29mX2ZpbGUgLT5cbiAgICAgICAgICAgIGlmIGNyX3JlYWQgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXHInO1xuICAgICAgICAgICAgTHd0LnJldHVybihCdWZmZXIuY29udGVudHMgYnVmKVxuICAgICAgICAgIHwgZXhuIC0+XG4gICAgICAgICAgICBMd3QucmVyYWlzZSBleG4pXG4gICAgaW5cbiAgICByZWFkX2NoYXIgaWMgPj49IGZ1bmN0aW9uXG4gICAgfCAnXFxyJyAtPiBsb29wIHRydWVcbiAgICB8ICdcXG4nIC0+IEx3dC5yZXR1cm4gXCJcIlxuICAgIHwgY2ggLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjaDsgbG9vcCBmYWxzZVxuXG4gIGxldCByZWFkX2xpbmVfb3B0IGljID1cbiAgICBMd3QuY2F0Y2hcbiAgICAgIChmdW4gKCkgLT4gcmVhZF9saW5lIGljID58PSBmdW4gY2ggLT4gU29tZSBjaClcbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IEVuZF9vZl9maWxlIC0+IEx3dC5yZXR1cm5fbm9uZVxuICAgICAgICB8IGV4biAtPiBMd3QucmVyYWlzZSBleG4pXG5cbiAgbGV0IHVuc2FmZV9yZWFkX2ludG8nIGljIGJsaXQgYnVmIG9mcyBsZW4gPVxuICAgIGxldCBhdmFpbCA9IGljLm1heCAtIGljLnB0ciBpblxuICAgIGlmIGF2YWlsID4gMCB0aGVuIGJlZ2luXG4gICAgICBsZXQgbGVuID0gbWluIGxlbiBhdmFpbCBpblxuICAgICAgYmxpdCBpYy5idWZmZXIgaWMucHRyIGJ1ZiBvZnMgbGVuO1xuICAgICAgaWMucHRyIDwtIGljLnB0ciArIGxlbjtcbiAgICAgIEx3dC5yZXR1cm4gbGVuXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHJlZmlsbCBpYyA+Pj0gZnVuIG4gLT5cbiAgICAgIGxldCBsZW4gPSBtaW4gbGVuIG4gaW5cbiAgICAgIGJsaXQgaWMuYnVmZmVyIDAgYnVmIG9mcyBsZW47XG4gICAgICBpYy5wdHIgPC0gbGVuO1xuICAgICAgaWMubWF4IDwtIG47XG4gICAgICBMd3QucmV0dXJuIGxlblxuICAgIGVuZFxuXG4gIGxldCB1bnNhZmVfcmVhZF9pbnRvX2JpZ3N0cmluZyBpYyBidWYgb2ZzIGxlbiA9XG4gICAgdW5zYWZlX3JlYWRfaW50bycgaWMgTHd0X2J5dGVzLnVuc2FmZV9ibGl0IGJ1ZiBvZnMgbGVuXG5cbiAgbGV0IHVuc2FmZV9yZWFkX2ludG8gaWMgYnVmIG9mcyBsZW4gPVxuICAgIHVuc2FmZV9yZWFkX2ludG8nIGljIEx3dF9ieXRlcy51bnNhZmVfYmxpdF90b19ieXRlcyBidWYgb2ZzIGxlblxuXG4gIGxldCByZWFkX2ludG9fYmlnc3RyaW5nIGljIGJ1ZiBvZnMgbGVuID1cbiAgICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzICsgbGVuID4gTHd0X2J5dGVzLmxlbmd0aCBidWYgdGhlblxuICAgICAgTHd0LmZhaWwgKEludmFsaWRfYXJndW1lbnQgXCJMd3RfaW8ucmVhZF9pbnRvX2JpZ3N0cmluZ1wiKVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGlmIGxlbiA9IDAgdGhlblxuICAgICAgICBMd3QucmV0dXJuIDBcbiAgICAgIGVsc2VcbiAgICAgICAgdW5zYWZlX3JlYWRfaW50b19iaWdzdHJpbmcgaWMgYnVmIG9mcyBsZW5cbiAgICBlbmRcblxuICBsZXQgcmVhZF9pbnRvIGljIGJ1ZiBvZnMgbGVuID1cbiAgICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzICsgbGVuID4gQnl0ZXMubGVuZ3RoIGJ1ZiB0aGVuXG4gICAgICBMd3QuZmFpbCAoSW52YWxpZF9hcmd1bWVudCBcIkx3dF9pby5yZWFkX2ludG9cIilcbiAgICBlbHNlIGJlZ2luXG4gICAgICBpZiBsZW4gPSAwIHRoZW5cbiAgICAgICAgTHd0LnJldHVybiAwXG4gICAgICBlbHNlXG4gICAgICAgIHVuc2FmZV9yZWFkX2ludG8gaWMgYnVmIG9mcyBsZW5cbiAgICBlbmRcblxuICBsZXQgdW5zYWZlX3JlYWRfaW50b19leGFjdGx5JyByZWFkX2ludG8gaWMgYnVmIG9mcyBsZW4gPVxuICAgIGxldCByZWMgbG9vcCBpYyBidWYgb2ZzIGxlbiA9XG4gICAgICByZWFkX2ludG8gaWMgYnVmIG9mcyBsZW4gPj49IGZ1bmN0aW9uXG4gICAgICB8IDAgLT5cbiAgICAgICAgICByYWlzZSBFbmRfb2ZfZmlsZVxuICAgICAgfCBuIC0+XG4gICAgICAgICAgbGV0IGxlbiA9IGxlbiAtIG4gaW5cbiAgICAgICAgICBpZiBsZW4gPSAwIHRoZW5cbiAgICAgICAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxvb3AgaWMgYnVmIChvZnMgKyBuKSBsZW5cbiAgICBpblxuICAgIGxvb3AgaWMgYnVmIG9mcyBsZW5cblxuXG4gIGxldCB1bnNhZmVfcmVhZF9pbnRvX2V4YWN0bHlfYmlnc3RyaW5nIGljIGJ1ZiBvZnMgbGVuID1cbiAgICB1bnNhZmVfcmVhZF9pbnRvX2V4YWN0bHknIHVuc2FmZV9yZWFkX2ludG9fYmlnc3RyaW5nIGljIGJ1ZiBvZnMgbGVuXG5cbiAgbGV0IHVuc2FmZV9yZWFkX2ludG9fZXhhY3RseSBpYyBidWYgb2ZzIGxlbiA9XG4gICAgdW5zYWZlX3JlYWRfaW50b19leGFjdGx5JyB1bnNhZmVfcmVhZF9pbnRvIGljIGJ1ZiBvZnMgbGVuXG5cbiAgbGV0IHJlYWRfaW50b19leGFjdGx5X2JpZ3N0cmluZyBpYyBidWYgb2ZzIGxlbiA9XG4gICAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IEx3dF9ieXRlcy5sZW5ndGggYnVmIHRoZW5cbiAgICAgIEx3dC5mYWlsIChJbnZhbGlkX2FyZ3VtZW50IFwiTHd0X2lvLnJlYWRfaW50b19leGFjdGx5X2JpZ3N0cmluZ1wiKVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGlmIGxlbiA9IDAgdGhlblxuICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICAgIGVsc2VcbiAgICAgICAgdW5zYWZlX3JlYWRfaW50b19leGFjdGx5X2JpZ3N0cmluZyBpYyBidWYgb2ZzIGxlblxuICAgIGVuZFxuXG4gIGxldCByZWFkX2ludG9fZXhhY3RseSBpYyBidWYgb2ZzIGxlbiA9XG4gICAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IEJ5dGVzLmxlbmd0aCBidWYgdGhlblxuICAgICAgTHd0LmZhaWwgKEludmFsaWRfYXJndW1lbnQgXCJMd3RfaW8ucmVhZF9pbnRvX2V4YWN0bHlcIilcbiAgICBlbHNlIGJlZ2luXG4gICAgICBpZiBsZW4gPSAwIHRoZW5cbiAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgICBlbHNlXG4gICAgICAgIHVuc2FmZV9yZWFkX2ludG9fZXhhY3RseSBpYyBidWYgb2ZzIGxlblxuICAgIGVuZFxuXG4gIGxldCByZXZfY29uY2F0IGxlbiBsID1cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBfID1cbiAgICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgIChmdW4gb2ZzIHN0ciAtPlxuICAgICAgICAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICAgICAgICAgbGV0IG9mcyA9IG9mcyAtIGxlbiBpblxuICAgICAgICAgICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgYnVmIG9mcyBsZW47XG4gICAgICAgICAgIG9mcylcbiAgICAgICAgbGVuIGxcbiAgICBpblxuICAgIGJ1ZlxuXG4gIGxldCByZWMgcmVhZF9hbGwgaWMgdG90YWxfbGVuIGFjYyA9XG4gICAgbGV0IGxlbiA9IGljLm1heCAtIGljLnB0ciBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgTHd0X2J5dGVzLnVuc2FmZV9ibGl0X3RvX2J5dGVzIGljLmJ1ZmZlciBpYy5wdHIgYnVmIDAgbGVuO1xuICAgIGxldCBzdHIgPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZiBpblxuICAgIGljLnB0ciA8LSBpYy5tYXg7XG4gICAgcmVmaWxsIGljID4+PSBmdW5jdGlvblxuICAgIHwgMCAtPlxuICAgICAgTHd0LnJldHVybiAocmV2X2NvbmNhdCAobGVuICsgdG90YWxfbGVuKSAoc3RyIDo6IGFjYykpXG4gICAgfCBfIC0+XG4gICAgICByZWFkX2FsbCBpYyAobGVuICsgdG90YWxfbGVuKSAoc3RyIDo6IGFjYylcblxuICBsZXQgcmVhZCBjb3VudCBpYyA9XG4gICAgbWF0Y2ggY291bnQgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgcmVhZF9hbGwgaWMgMCBbXSA+fD0gQnl0ZXMudW5zYWZlX3RvX3N0cmluZ1xuICAgIHwgU29tZSBsZW4gLT5cbiAgICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgICB1bnNhZmVfcmVhZF9pbnRvIGljIGJ1ZiAwIGxlbiA+Pj0gZnVuIHJlYWxfbGVuIC0+XG4gICAgICBpZiByZWFsX2xlbiA8IGxlbiB0aGVuXG4gICAgICAgIEx3dC5yZXR1cm4gQnl0ZXMuKHN1YiBidWYgMCByZWFsX2xlbiB8PiB1bnNhZmVfdG9fc3RyaW5nKVxuICAgICAgZWxzZVxuICAgICAgICBMd3QucmV0dXJuIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZilcblxuICBsZXQgcmVhZF92YWx1ZSBpYyA9XG4gICAgbGV0IGhlYWRlciA9IEJ5dGVzLmNyZWF0ZSBNYXJzaGFsLmhlYWRlcl9zaXplIGluXG4gICAgdW5zYWZlX3JlYWRfaW50b19leGFjdGx5IGljIGhlYWRlciAwIE1hcnNoYWwuaGVhZGVyX3NpemUgPj49IGZ1biAoKSAtPlxuICAgIGxldCBic2l6ZSA9IE1hcnNoYWwuZGF0YV9zaXplIGhlYWRlciAwIGluXG4gICAgbGV0IGJ1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAoTWFyc2hhbC5oZWFkZXJfc2l6ZSArIGJzaXplKSBpblxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0IGhlYWRlciAwIGJ1ZmZlciAwIE1hcnNoYWwuaGVhZGVyX3NpemU7XG4gICAgdW5zYWZlX3JlYWRfaW50b19leGFjdGx5IGljIGJ1ZmZlciBNYXJzaGFsLmhlYWRlcl9zaXplIGJzaXplID4+PSBmdW4gKCkgLT5cbiAgICBMd3QucmV0dXJuIChNYXJzaGFsLmZyb21fYnl0ZXMgYnVmZmVyIDApXG5cbiAgKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgfCBXcml0aW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxuICBsZXQgZmx1c2ggPSBmbHVzaF90b3RhbFxuXG4gIGxldCByZWMgd3JpdGVfY2hhciBvYyBjaCA9XG4gICAgbGV0IHB0ciA9IG9jLnB0ciBpblxuICAgIGlmIHB0ciA8IG9jLmxlbmd0aCB0aGVuIGJlZ2luXG4gICAgICBvYy5wdHIgPC0gcHRyICsgMTtcbiAgICAgIEx3dF9ieXRlcy51bnNhZmVfc2V0IG9jLmJ1ZmZlciBwdHIgY2g7XG4gICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICBlbmQgZWxzZVxuICAgICAgZmx1c2hfcGFydGlhbCBvYyA+Pj0gZnVuIF8gLT5cbiAgICAgIHdyaXRlX2NoYXIgb2MgY2hcblxuICBsZXQgcmVjIHVuc2FmZV93cml0ZV9mcm9tJyBibGl0IG9jIHN0ciBvZnMgbGVuID1cbiAgICBsZXQgYXZhaWwgPSBvYy5sZW5ndGggLSBvYy5wdHIgaW5cbiAgICBpZiBhdmFpbCA+PSBsZW4gdGhlbiBiZWdpblxuICAgICAgYmxpdCBzdHIgb2ZzIG9jLmJ1ZmZlciBvYy5wdHIgbGVuO1xuICAgICAgb2MucHRyIDwtIG9jLnB0ciArIGxlbjtcbiAgICAgIEx3dC5yZXR1cm4gMFxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBibGl0IHN0ciBvZnMgb2MuYnVmZmVyIG9jLnB0ciBhdmFpbDtcbiAgICAgIG9jLnB0ciA8LSBvYy5sZW5ndGg7XG4gICAgICBmbHVzaF9wYXJ0aWFsIG9jID4+PSBmdW4gXyAtPlxuICAgICAgbGV0IGxlbiA9IGxlbiAtIGF2YWlsIGluXG4gICAgICBpZiBvYy5wdHIgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgbGVuID0gMCB0aGVuXG4gICAgICAgICAgTHd0LnJldHVybiAwXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAoKiBFdmVyeXRoaW5nIGhhcyBiZWVuIHdyaXR0ZW4sIHRyeSB0byB3cml0ZSBtb3JlOiAqKVxuICAgICAgICAgIHVuc2FmZV93cml0ZV9mcm9tJyBibGl0IG9jIHN0ciAob2ZzICsgYXZhaWwpIGxlblxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgKCogTm90IGV2ZXJ5dGhpbmcgaGFzIGJlZW4gd3JpdHRlbiwganVzdCB3aGF0IGlzXG4gICAgICAgICAgIHJlbWFpbmluZzogKilcbiAgICAgICAgTHd0LnJldHVybiBsZW5cbiAgICBlbmRcblxuICBsZXQgdW5zYWZlX3dyaXRlX2Zyb21fYmlnc3RyaW5nIG9jIGJ5dGVzIG9mcyBsZW4gPVxuICAgIHVuc2FmZV93cml0ZV9mcm9tJyBMd3RfYnl0ZXMuYmxpdCBvYyBieXRlcyBvZnMgbGVuXG5cbiAgbGV0IHVuc2FmZV93cml0ZV9mcm9tIG9jIHN0ciBvZnMgbGVuID1cbiAgICB1bnNhZmVfd3JpdGVfZnJvbScgTHd0X2J5dGVzLnVuc2FmZV9ibGl0X2Zyb21fYnl0ZXMgb2Mgc3RyIG9mcyBsZW5cblxuICBsZXQgd3JpdGVfZnJvbV9iaWdzdHJpbmcgb2MgYnl0ZXMgb2ZzIGxlbiA9XG4gICAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IEx3dF9ieXRlcy5sZW5ndGggYnl0ZXMgdGhlblxuICAgICAgTHd0LmZhaWwgKEludmFsaWRfYXJndW1lbnQgXCJMd3RfaW8ud3JpdGVfZnJvbV9iaWdzdHJpbmdcIilcbiAgICBlbHNlIGJlZ2luXG4gICAgICBpZiBsZW4gPSAwIHRoZW5cbiAgICAgICAgTHd0LnJldHVybiAwXG4gICAgICBlbHNlXG4gICAgICAgIHVuc2FmZV93cml0ZV9mcm9tX2JpZ3N0cmluZyBvYyBieXRlcyBvZnMgbGVuID4+PSBmdW4gcmVtYWluaW5nIC0+XG4gICAgICAgIEx3dC5yZXR1cm4gKGxlbiAtIHJlbWFpbmluZylcbiAgICBlbmRcblxuICBsZXQgd3JpdGVfZnJvbSBvYyBidWYgb2ZzIGxlbiA9XG4gICAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IEJ5dGVzLmxlbmd0aCBidWYgdGhlblxuICAgICAgTHd0LmZhaWwgKEludmFsaWRfYXJndW1lbnQgXCJMd3RfaW8ud3JpdGVfZnJvbVwiKVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGlmIGxlbiA9IDAgdGhlblxuICAgICAgICBMd3QucmV0dXJuIDBcbiAgICAgIGVsc2VcbiAgICAgICAgdW5zYWZlX3dyaXRlX2Zyb20gb2MgYnVmIG9mcyBsZW4gPj49IGZ1biByZW1haW5pbmcgLT5cbiAgICAgICAgTHd0LnJldHVybiAobGVuIC0gcmVtYWluaW5nKVxuICAgIGVuZFxuXG4gIGxldCB3cml0ZV9mcm9tX3N0cmluZyBvYyBidWYgb2ZzIGxlbiA9XG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgYnVmIGluXG4gICAgd3JpdGVfZnJvbSBvYyBidWYgb2ZzIGxlblxuXG4gIGxldCB1bnNhZmVfd3JpdGVfZnJvbV9leGFjdGx5JyB3cml0ZV9mcm9tIG9jIGJ1ZiBvZnMgbGVuID1cbiAgICBsZXQgcmVjIGxvb3Agb2MgYnVmIG9mcyBsZW4gPVxuICAgICAgd3JpdGVfZnJvbSBvYyBidWYgb2ZzIGxlbiA+Pj0gZnVuY3Rpb25cbiAgICAgIHwgMCAtPlxuICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICAgIHwgbiAtPlxuICAgICAgICAgIGxvb3Agb2MgYnVmIChvZnMgKyBsZW4gLSBuKSBuXG4gICAgaW5cbiAgICBsb29wIG9jIGJ1ZiBvZnMgbGVuXG5cbiAgbGV0IHVuc2FmZV93cml0ZV9mcm9tX2V4YWN0bHkgb2MgYnVmIG9mcyBsZW4gPVxuICAgIHVuc2FmZV93cml0ZV9mcm9tX2V4YWN0bHknIHVuc2FmZV93cml0ZV9mcm9tIG9jIGJ1ZiBvZnMgbGVuXG5cbiAgbGV0IHVuc2FmZV93cml0ZV9mcm9tX2V4YWN0bHlfYmlnc3RyaW5nIG9jIGJ1ZiBvZnMgbGVuID1cbiAgICB1bnNhZmVfd3JpdGVfZnJvbV9leGFjdGx5JyB1bnNhZmVfd3JpdGVfZnJvbV9iaWdzdHJpbmcgb2MgYnVmIG9mcyBsZW5cblxuICBsZXQgd3JpdGVfZnJvbV9leGFjdGx5IG9jIGJ1ZiBvZnMgbGVuID1cbiAgICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzICsgbGVuID4gQnl0ZXMubGVuZ3RoIGJ1ZiB0aGVuXG4gICAgICBMd3QuZmFpbCAoSW52YWxpZF9hcmd1bWVudCBcIkx3dF9pby53cml0ZV9mcm9tX2V4YWN0bHlcIilcbiAgICBlbHNlIGJlZ2luXG4gICAgICBpZiBsZW4gPSAwIHRoZW5cbiAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgICBlbHNlXG4gICAgICAgIHVuc2FmZV93cml0ZV9mcm9tX2V4YWN0bHkgb2MgYnVmIG9mcyBsZW5cbiAgICBlbmRcblxuICBsZXQgd3JpdGVfZnJvbV9leGFjdGx5X2JpZ3N0cmluZyBvYyBidWYgb2ZzIGxlbiA9XG4gICAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IEx3dF9ieXRlcy5sZW5ndGggYnVmIHRoZW5cbiAgICAgIEx3dC5mYWlsIChJbnZhbGlkX2FyZ3VtZW50IFwiTHd0X2lvLndyaXRlX2Zyb21fZXhhY3RseV9iaWdzdHJpbmdcIilcbiAgICBlbHNlIGJlZ2luXG4gICAgICBpZiBsZW4gPSAwIHRoZW5cbiAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgICBlbHNlXG4gICAgICAgIHVuc2FmZV93cml0ZV9mcm9tX2V4YWN0bHlfYmlnc3RyaW5nIG9jIGJ1ZiBvZnMgbGVuXG4gICAgZW5kXG5cbiAgbGV0IHdyaXRlX2Zyb21fc3RyaW5nX2V4YWN0bHkgb2MgYnVmIG9mcyBsZW4gPVxuICAgIGxldCBidWYgPSBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGJ1ZiBpblxuICAgIHdyaXRlX2Zyb21fZXhhY3RseSBvYyBidWYgb2ZzIGxlblxuXG4gIGxldCB3cml0ZSBvYyBzdHIgPVxuICAgIGxldCBidWYgPSBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIHN0ciBpblxuICAgIHVuc2FmZV93cml0ZV9mcm9tX2V4YWN0bHkgb2MgYnVmIDAgKEJ5dGVzLmxlbmd0aCBidWYpXG5cbiAgbGV0IHdyaXRlX2xpbmUgb2Mgc3RyID1cbiAgICBsZXQgYnVmID0gQnl0ZXMudW5zYWZlX29mX3N0cmluZyBzdHIgaW5cbiAgICB1bnNhZmVfd3JpdGVfZnJvbV9leGFjdGx5IG9jIGJ1ZiAwIChCeXRlcy5sZW5ndGggYnVmKSA+Pj0gZnVuICgpIC0+XG4gICAgd3JpdGVfY2hhciBvYyAnXFxuJ1xuXG4gIGxldCB3cml0ZV92YWx1ZSBvYyA/KGZsYWdzPVtdKSB4ID1cbiAgICB3cml0ZSBvYyAoTWFyc2hhbC50b19zdHJpbmcgeCBmbGFncylcblxuICAoKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICB8IExvdy1sZXZlbCBhY2Nlc3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG4gIGxldCByZWMgcmVhZF9ibG9ja191bnNhZmUgaWMgc2l6ZSBmID1cbiAgICBpZiBpYy5tYXggLSBpYy5wdHIgPCBzaXplIHRoZW5cbiAgICAgIHJlZmlsbCBpYyA+Pj0gZnVuY3Rpb25cbiAgICAgIHwgMCAtPlxuICAgICAgICByYWlzZSBFbmRfb2ZfZmlsZVxuICAgICAgfCBfIC0+XG4gICAgICAgIHJlYWRfYmxvY2tfdW5zYWZlIGljIHNpemUgZlxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCBwdHIgPSBpYy5wdHIgaW5cbiAgICAgIGljLnB0ciA8LSBwdHIgKyBzaXplO1xuICAgICAgZiBpYy5idWZmZXIgcHRyXG4gICAgZW5kXG5cbiAgbGV0IHJlYyB3cml0ZV9ibG9ja191bnNhZmUgb2Mgc2l6ZSBmID1cbiAgICBpZiBvYy5tYXggLSBvYy5wdHIgPCBzaXplIHRoZW5cbiAgICAgIGZsdXNoX3BhcnRpYWwgb2MgPj49IGZ1biBfIC0+XG4gICAgICB3cml0ZV9ibG9ja191bnNhZmUgb2Mgc2l6ZSBmXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHB0ciA9IG9jLnB0ciBpblxuICAgICAgb2MucHRyIDwtIHB0ciArIHNpemU7XG4gICAgICBmIG9jLmJ1ZmZlciBwdHJcbiAgICBlbmRcblxuICBsZXQgYmxvY2sgOlxuICAgICAgdHlwZSBtLlxuICAgICAgbSBfY2hhbm5lbCAtPlxuICAgICAgaW50IC0+XG4gICAgICAoTHd0X2J5dGVzLnQgLT4gaW50IC0+ICdhIEx3dC50KSAtPlxuICAgICAgICAnYSBMd3QudCA9XG4gICAgICBmdW4gY2ggc2l6ZSBmIC0+XG4gICAgaWYgc2l6ZSA8IDAgfHwgc2l6ZSA+IG1pbl9idWZmZXJfc2l6ZSB0aGVuXG4gICAgICBMd3QuZmFpbCAoSW52YWxpZF9hcmd1bWVudCBcIkx3dF9pby5ibG9ja1wiKVxuICAgIGVsc2VcbiAgICBpZiBjaC5tYXggLSBjaC5wdHIgPj0gc2l6ZSB0aGVuIGJlZ2luXG4gICAgICBsZXQgcHRyID0gY2gucHRyIGluXG4gICAgICBjaC5wdHIgPC0gcHRyICsgc2l6ZTtcbiAgICAgIGYgY2guYnVmZmVyIHB0clxuICAgIGVuZCBlbHNlXG4gICAgICBtYXRjaCBjaC5tb2RlIHdpdGhcbiAgICAgIHwgSW5wdXQgLT5cbiAgICAgICAgcmVhZF9ibG9ja191bnNhZmUgY2ggc2l6ZSBmXG4gICAgICB8IE91dHB1dCAtPlxuICAgICAgICB3cml0ZV9ibG9ja191bnNhZmUgY2ggc2l6ZSBmXG5cbiAgbGV0IHBlcmZvcm0gdG9rZW4gZGEgY2ggPVxuICAgIGlmICF0b2tlbiB0aGVuIGJlZ2luXG4gICAgICBpZiBkYS5kYV9tYXggPD4gY2gubWF4IHx8IGRhLmRhX3B0ciA8IGNoLnB0ciB8fCBkYS5kYV9wdHIgPiBjaC5tYXggdGhlblxuICAgICAgICBMd3QuZmFpbCAoSW52YWxpZF9hcmd1bWVudCBcIkx3dF9pby5kaXJlY3RfYWNjZXNzLmRhX3BlcmZvcm1cIilcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgY2gucHRyIDwtIGRhLmRhX3B0cjtcbiAgICAgICAgcGVyZm9ybV9pbyBjaCA+Pj0gZnVuIGNvdW50IC0+XG4gICAgICAgIGRhLmRhX3B0ciA8LSBjaC5wdHI7XG4gICAgICAgIGRhLmRhX21heCA8LSBjaC5tYXg7XG4gICAgICAgIEx3dC5yZXR1cm4gY291bnRcbiAgICAgIGVuZFxuICAgIGVuZCBlbHNlXG4gICAgICBMd3QuZmFpbFxuICAgICAgICAoRmFpbHVyZVxuICAgICAgICAgIChcIkx3dF9pby5wZXJmb3JtOiB0aGlzIGZ1bmN0aW9uIGNhbiBub3QgYmUgY2FsbGVkIG91dHNpZGUgXCIgXlxuICAgICAgICAgICBcIkx3dF9pby5kaXJlY3RfYWNjZXNzXCIpKVxuXG4gIGxldCBkaXJlY3RfYWNjZXNzIGNoIGYgPVxuICAgIGxldCB0b2tlbiA9IHJlZiB0cnVlIGluXG4gICAgbGV0IHJlYyBkYSA9IHtcbiAgICAgIGRhX3B0ciA9IGNoLnB0cjtcbiAgICAgIGRhX21heCA9IGNoLm1heDtcbiAgICAgIGRhX2J1ZmZlciA9IGNoLmJ1ZmZlcjtcbiAgICAgIGRhX3BlcmZvcm0gPSAoZnVuIF8gLT4gcGVyZm9ybSB0b2tlbiBkYSBjaCk7XG4gICAgfSBpblxuICAgIGYgZGEgPj49IGZ1biB4IC0+XG4gICAgdG9rZW4gOj0gZmFsc2U7XG4gICAgaWYgZGEuZGFfbWF4IDw+IGNoLm1heCB8fCBkYS5kYV9wdHIgPCBjaC5wdHIgfHwgZGEuZGFfcHRyID4gY2gubWF4IHRoZW5cbiAgICAgIEx3dC5mYWlsIChGYWlsdXJlIFwiTHd0X2lvLmRpcmVjdF9hY2Nlc3M6IGludmFsaWQgcmVzdWx0IG9mIFtmXVwiKVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGNoLnB0ciA8LSBkYS5kYV9wdHI7XG4gICAgICBMd3QucmV0dXJuIHhcbiAgICBlbmRcblxuICBtb2R1bGUgTWFrZU51bWJlcklPIChFbmRpYW4gOiBFbmRpYW5CaWdzdHJpbmcuRW5kaWFuQmlnc3RyaW5nU2lnKSA9XG4gIHN0cnVjdFxuICAgICgqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgIHwgUmVhZGluZyBudW1iZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG4gICAgbGV0IHJlYWRfaW50IGljID1cbiAgICAgIHJlYWRfYmxvY2tfdW5zYWZlIGljIDRcbiAgICAgICAgKGZ1biBidWZmZXIgcHRyIC0+XG4gICAgICAgICAgTHd0LnJldHVybiAoSW50MzIudG9faW50IChFbmRpYW4uZ2V0X2ludDMyIGJ1ZmZlciBwdHIpKSlcblxuICAgIGxldCByZWFkX2ludDE2IGljID1cbiAgICAgIHJlYWRfYmxvY2tfdW5zYWZlIGljIDJcbiAgICAgICAgKGZ1biBidWZmZXIgcHRyIC0+XG4gICAgICAgICAgTHd0LnJldHVybiAoRW5kaWFuLmdldF9pbnQxNiBidWZmZXIgcHRyKSlcblxuICAgIGxldCByZWFkX2ludDMyIGljID1cbiAgICAgIHJlYWRfYmxvY2tfdW5zYWZlIGljIDRcbiAgICAgICAgKGZ1biBidWZmZXIgcHRyIC0+XG4gICAgICAgICAgTHd0LnJldHVybiAoRW5kaWFuLmdldF9pbnQzMiBidWZmZXIgcHRyKSlcblxuICAgIGxldCByZWFkX2ludDY0IGljID1cbiAgICAgIHJlYWRfYmxvY2tfdW5zYWZlIGljIDhcbiAgICAgICAgKGZ1biBidWZmZXIgcHRyIC0+XG4gICAgICAgICAgTHd0LnJldHVybiAoRW5kaWFuLmdldF9pbnQ2NCBidWZmZXIgcHRyKSlcblxuICAgIGxldCByZWFkX2Zsb2F0MzIgaWMgPVxuICAgICAgcmVhZF9pbnQzMiBpYyA+Pj0gZnVuIHggLT4gTHd0LnJldHVybiAoSW50MzIuZmxvYXRfb2ZfYml0cyB4KVxuICAgIGxldCByZWFkX2Zsb2F0NjQgaWMgPVxuICAgICAgcmVhZF9pbnQ2NCBpYyA+Pj0gZnVuIHggLT4gTHd0LnJldHVybiAoSW50NjQuZmxvYXRfb2ZfYml0cyB4KVxuXG4gICAgKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgfCBXcml0aW5nIG51bWJlcnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbiAgICBsZXQgd3JpdGVfaW50IG9jIHYgPVxuICAgICAgd3JpdGVfYmxvY2tfdW5zYWZlIG9jIDRcbiAgICAgICAgKGZ1biBidWZmZXIgcHRyIC0+XG4gICAgICAgICAgRW5kaWFuLnNldF9pbnQzMiBidWZmZXIgcHRyIChJbnQzMi5vZl9pbnQgdik7XG4gICAgICAgICAgTHd0LnJldHVybl91bml0KVxuXG4gICAgbGV0IHdyaXRlX2ludDE2IG9jIHYgPVxuICAgICAgd3JpdGVfYmxvY2tfdW5zYWZlIG9jIDJcbiAgICAgICAgKGZ1biBidWZmZXIgcHRyIC0+XG4gICAgICAgICAgRW5kaWFuLnNldF9pbnQxNiBidWZmZXIgcHRyIHY7XG4gICAgICAgICAgTHd0LnJldHVybl91bml0KVxuXG4gICAgbGV0IHdyaXRlX2ludDMyIG9jIHYgPVxuICAgICAgd3JpdGVfYmxvY2tfdW5zYWZlIG9jIDRcbiAgICAgICAgKGZ1biBidWZmZXIgcHRyIC0+XG4gICAgICAgICAgRW5kaWFuLnNldF9pbnQzMiBidWZmZXIgcHRyIHY7XG4gICAgICAgICAgTHd0LnJldHVybl91bml0KVxuXG4gICAgbGV0IHdyaXRlX2ludDY0IG9jIHYgPVxuICAgICAgd3JpdGVfYmxvY2tfdW5zYWZlIG9jIDhcbiAgICAgICAgKGZ1biBidWZmZXIgcHRyIC0+XG4gICAgICAgICAgRW5kaWFuLnNldF9pbnQ2NCBidWZmZXIgcHRyIHY7XG4gICAgICAgICAgTHd0LnJldHVybl91bml0KVxuXG4gICAgbGV0IHdyaXRlX2Zsb2F0MzIgb2MgdiA9IHdyaXRlX2ludDMyIG9jIChJbnQzMi5iaXRzX29mX2Zsb2F0IHYpXG4gICAgbGV0IHdyaXRlX2Zsb2F0NjQgb2MgdiA9IHdyaXRlX2ludDY0IG9jIChJbnQ2NC5iaXRzX29mX2Zsb2F0IHYpXG4gIGVuZFxuXG4gICgqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgIHwgUmFuZG9tIGFjY2VzcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbiAgbGV0IGRvX3NlZWsgZnVuX25hbWUgc2VlayBwb3MgPVxuICAgIHNlZWsgcG9zIFVuaXguU0VFS19TRVQgPj49IGZ1biBvZmZzZXQgLT5cbiAgICBpZiBvZmZzZXQgPD4gcG9zIHRoZW5cbiAgICAgIEx3dC5mYWlsIChGYWlsdXJlIChQcmludGYuc3ByaW50ZiBcIkx3dF9pby4lczogc2VlayBmYWlsZWRcIiBmdW5fbmFtZSkpXG4gICAgZWxzZVxuICAgICAgTHd0LnJldHVybl91bml0XG5cbiAgbGV0IHNldF9wb3NpdGlvbiA6XG4gICAgICB0eXBlIG0uXG4gICAgICBtIF9jaGFubmVsIC0+XG4gICAgICBpbnQ2NCAtPlxuICAgICAgICB1bml0IEx3dC50ID1cbiAgICAgIGZ1biBjaCBwb3MgLT5cbiAgICBtYXRjaCBjaC50eXAsIGNoLm1vZGUgd2l0aFxuICAgIHwgVHlwZV9ub3JtYWwoXywgc2VlayksIE91dHB1dCAtPlxuICAgICAgZmx1c2hfdG90YWwgY2ggPj49IGZ1biAoKSAtPlxuICAgICAgZG9fc2VlayBcInNldF9wb3NpdGlvblwiIHNlZWsgcG9zID4+PSBmdW4gKCkgLT5cbiAgICAgIGNoLm9mZnNldCA8LSBwb3M7XG4gICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICB8IFR5cGVfbm9ybWFsKF8sIHNlZWspLCBJbnB1dCAtPlxuICAgICAgbGV0IGN1cnJlbnQgPSBJbnQ2NC5zdWIgY2gub2Zmc2V0IChJbnQ2NC5vZl9pbnQgKGNoLm1heCAtIGNoLnB0cikpIGluXG4gICAgICBpZiBwb3MgPj0gY3VycmVudCAmJiBwb3MgPD0gY2gub2Zmc2V0IHRoZW4gYmVnaW5cbiAgICAgICAgY2gucHRyIDwtIGNoLm1heCAtIChJbnQ2NC50b19pbnQgKEludDY0LnN1YiBjaC5vZmZzZXQgcG9zKSk7XG4gICAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgZG9fc2VlayBcInNldF9wb3NpdGlvblwiIHNlZWsgcG9zID4+PSBmdW4gKCkgLT5cbiAgICAgICAgY2gub2Zmc2V0IDwtIHBvcztcbiAgICAgICAgY2gucHRyIDwtIDA7XG4gICAgICAgIGNoLm1heCA8LSAwO1xuICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICAgIGVuZFxuICAgIHwgVHlwZV9ieXRlcywgXyAtPlxuICAgICAgaWYgcG9zIDwgMEwgfHwgcG9zID4gSW50NjQub2ZfaW50IGNoLmxlbmd0aCB0aGVuXG4gICAgICAgIEx3dC5mYWlsIChGYWlsdXJlIFwiTHd0X2lvLnNldF9wb3NpdGlvbjogb3V0IG9mIGJvdW5kc1wiKVxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBjaC5wdHIgPC0gSW50NjQudG9faW50IHBvcztcbiAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgICBlbmRcblxuICBsZXQgbGVuZ3RoIGNoID0gbWF0Y2ggY2gudHlwIHdpdGhcbiAgICB8IFR5cGVfbm9ybWFsKF8sIHNlZWspIC0+XG4gICAgICBzZWVrIDBMIFVuaXguU0VFS19FTkQgPj49IGZ1biBsZW4gLT5cbiAgICAgIGRvX3NlZWsgXCJsZW5ndGhcIiBzZWVrIGNoLm9mZnNldCA+Pj0gZnVuICgpIC0+XG4gICAgICBMd3QucmV0dXJuIGxlblxuICAgIHwgVHlwZV9ieXRlcyAtPlxuICAgICAgTHd0LnJldHVybiAoSW50NjQub2ZfaW50IGNoLmxlbmd0aClcbmVuZFxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IFByaW1pdGl2ZSBvcGVyYXRpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCByZWFkX2NoYXIgd3JhcHBlciA9XG4gIGxldCBjaGFubmVsID0gd3JhcHBlci5jaGFubmVsIGluXG4gIGxldCBwdHIgPSBjaGFubmVsLnB0ciBpblxuICAoKiBTcGVlZC11cCBpbiBjYXNlIGEgY2hhcmFjdGVyIGlzIGF2YWlsYWJsZSBpbiB0aGUgYnVmZmVyLiBJdFxuICAgICBpbmNyZWFzZXMgcGVyZm9ybWFuY2VzIGJ5IDEweC4gKilcbiAgaWYgd3JhcHBlci5zdGF0ZSA9IElkbGUgJiYgcHRyIDwgY2hhbm5lbC5tYXggdGhlbiBiZWdpblxuICAgIGNoYW5uZWwucHRyIDwtIHB0ciArIDE7XG4gICAgTHd0LnJldHVybiAoTHd0X2J5dGVzLnVuc2FmZV9nZXQgY2hhbm5lbC5idWZmZXIgcHRyKVxuICBlbmQgZWxzZVxuICAgIHByaW1pdGl2ZSBQcmltaXRpdmVzLnJlYWRfY2hhciB3cmFwcGVyXG5cbmxldCByZWFkX2NoYXJfb3B0IHdyYXBwZXIgPVxuICBsZXQgY2hhbm5lbCA9IHdyYXBwZXIuY2hhbm5lbCBpblxuICBsZXQgcHRyID0gY2hhbm5lbC5wdHIgaW5cbiAgaWYgd3JhcHBlci5zdGF0ZSA9IElkbGUgJiYgcHRyIDwgY2hhbm5lbC5tYXggdGhlbiBiZWdpblxuICAgIGNoYW5uZWwucHRyIDwtIHB0ciArIDE7XG4gICAgTHd0LnJldHVybiAoU29tZShMd3RfYnl0ZXMudW5zYWZlX2dldCBjaGFubmVsLmJ1ZmZlciBwdHIpKVxuICBlbmQgZWxzZVxuICAgIHByaW1pdGl2ZSBQcmltaXRpdmVzLnJlYWRfY2hhcl9vcHQgd3JhcHBlclxuXG5sZXQgcmVhZF9saW5lIGljID1cbiAgcHJpbWl0aXZlIFByaW1pdGl2ZXMucmVhZF9saW5lIGljXG5cbmxldCByZWFkX2xpbmVfb3B0IGljID1cbiAgcHJpbWl0aXZlIFByaW1pdGl2ZXMucmVhZF9saW5lX29wdCBpY1xuXG5sZXQgcmVhZCA/Y291bnQgaWMgPVxuICBwcmltaXRpdmUgKGZ1biBpYyAtPiBQcmltaXRpdmVzLnJlYWQgY291bnQgaWMpIGljXG5cbmxldCByZWFkX2ludG8gaWMgc3RyIG9mcyBsZW4gPVxuICBwcmltaXRpdmUgKGZ1biBpYyAtPiBQcmltaXRpdmVzLnJlYWRfaW50byBpYyBzdHIgb2ZzIGxlbikgaWNcblxubGV0IHJlYWRfaW50b19leGFjdGx5IGljIHN0ciBvZnMgbGVuID1cbiAgcHJpbWl0aXZlIChmdW4gaWMgLT4gUHJpbWl0aXZlcy5yZWFkX2ludG9fZXhhY3RseSBpYyBzdHIgb2ZzIGxlbikgaWNcblxubGV0IHJlYWRfaW50b19iaWdzdHJpbmcgaWMgYnl0ZXMgb2ZzIGxlbiA9XG4gIHByaW1pdGl2ZSAoZnVuIGljIC0+IFByaW1pdGl2ZXMucmVhZF9pbnRvX2JpZ3N0cmluZyBpYyBieXRlcyBvZnMgbGVuKSBpY1xuXG5sZXQgcmVhZF9pbnRvX2V4YWN0bHlfYmlnc3RyaW5nIGljIGJ5dGVzIG9mcyBsZW4gPVxuICBwcmltaXRpdmUgKGZ1biBpYyAtPiBQcmltaXRpdmVzLnJlYWRfaW50b19leGFjdGx5X2JpZ3N0cmluZyBpYyBieXRlcyBvZnMgbGVuKSBpY1xuXG5sZXQgcmVhZF92YWx1ZSBpYyA9XG4gIHByaW1pdGl2ZSBQcmltaXRpdmVzLnJlYWRfdmFsdWUgaWNcblxubGV0IGZsdXNoIG9jID0gcHJpbWl0aXZlIFByaW1pdGl2ZXMuZmx1c2ggb2NcblxubGV0IHdyaXRlX2NoYXIgd3JhcHBlciB4ID1cbiAgbGV0IGNoYW5uZWwgPSB3cmFwcGVyLmNoYW5uZWwgaW5cbiAgbGV0IHB0ciA9IGNoYW5uZWwucHRyIGluXG4gIGlmIHdyYXBwZXIuc3RhdGUgPSBJZGxlICYmIHB0ciA8IGNoYW5uZWwubWF4IHRoZW4gYmVnaW5cbiAgICBjaGFubmVsLnB0ciA8LSBwdHIgKyAxO1xuICAgIEx3dF9ieXRlcy51bnNhZmVfc2V0IGNoYW5uZWwuYnVmZmVyIHB0ciB4O1xuICAgICgqIEZhc3QgbGF1bmNoaW5nIG9mIHRoZSBhdXRvIGZsdXNoZXI6ICopXG4gICAgaWYgbm90IGNoYW5uZWwuYXV0b19mbHVzaGluZyB0aGVuIGJlZ2luXG4gICAgICBjaGFubmVsLmF1dG9fZmx1c2hpbmcgPC0gdHJ1ZTtcbiAgICAgIGlnbm9yZSAoYXV0b19mbHVzaCBjaGFubmVsKTtcbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIGVuZCBlbHNlXG4gICAgICBMd3QucmV0dXJuX3VuaXRcbiAgZW5kIGVsc2VcbiAgICBwcmltaXRpdmUgKGZ1biBvYyAtPiBQcmltaXRpdmVzLndyaXRlX2NoYXIgb2MgeCkgd3JhcHBlclxuXG5sZXQgd3JpdGUgb2Mgc3RyID1cbiAgcHJpbWl0aXZlIChmdW4gb2MgLT4gUHJpbWl0aXZlcy53cml0ZSBvYyBzdHIpIG9jXG5cbmxldCB3cml0ZV9saW5lIG9jIHggPVxuICBwcmltaXRpdmUgKGZ1biBvYyAtPiBQcmltaXRpdmVzLndyaXRlX2xpbmUgb2MgeCkgb2NcblxubGV0IHdyaXRlX2Zyb20gb2Mgc3RyIG9mcyBsZW4gPVxuICBwcmltaXRpdmUgKGZ1biBvYyAtPiBQcmltaXRpdmVzLndyaXRlX2Zyb20gb2Mgc3RyIG9mcyBsZW4pIG9jXG5cbmxldCB3cml0ZV9mcm9tX2JpZ3N0cmluZyBvYyBieXRlcyBvZnMgbGVuID1cbiAgcHJpbWl0aXZlIChmdW4gb2MgLT4gUHJpbWl0aXZlcy53cml0ZV9mcm9tX2JpZ3N0cmluZyBvYyBieXRlcyBvZnMgbGVuKSBvY1xuXG5sZXQgd3JpdGVfZnJvbV9zdHJpbmcgb2Mgc3RyIG9mcyBsZW4gPVxuICBwcmltaXRpdmUgKGZ1biBvYyAtPiBQcmltaXRpdmVzLndyaXRlX2Zyb21fc3RyaW5nIG9jIHN0ciBvZnMgbGVuKSBvY1xuXG5sZXQgd3JpdGVfZnJvbV9leGFjdGx5IG9jIHN0ciBvZnMgbGVuID1cbiAgcHJpbWl0aXZlIChmdW4gb2MgLT4gUHJpbWl0aXZlcy53cml0ZV9mcm9tX2V4YWN0bHkgb2Mgc3RyIG9mcyBsZW4pIG9jXG5cbmxldCB3cml0ZV9mcm9tX2V4YWN0bHlfYmlnc3RyaW5nIG9jIGJ5dGVzIG9mcyBsZW4gPVxuICBwcmltaXRpdmUgKGZ1biBvYyAtPiBQcmltaXRpdmVzLndyaXRlX2Zyb21fZXhhY3RseV9iaWdzdHJpbmcgb2MgYnl0ZXMgb2ZzIGxlbikgb2NcblxubGV0IHdyaXRlX2Zyb21fc3RyaW5nX2V4YWN0bHkgb2Mgc3RyIG9mcyBsZW4gPVxuICBwcmltaXRpdmUgKGZ1biBvYyAtPiBQcmltaXRpdmVzLndyaXRlX2Zyb21fc3RyaW5nX2V4YWN0bHkgb2Mgc3RyIG9mcyBsZW4pIG9jXG5cbmxldCB3cml0ZV92YWx1ZSBvYyA/ZmxhZ3MgeCA9XG4gIHByaW1pdGl2ZSAoZnVuIG9jIC0+IFByaW1pdGl2ZXMud3JpdGVfdmFsdWUgb2MgP2ZsYWdzIHgpIG9jXG5cbmxldCBibG9jayBjaCBzaXplIGYgPVxuICBwcmltaXRpdmUgKGZ1biBjaCAtPiBQcmltaXRpdmVzLmJsb2NrIGNoIHNpemUgZikgY2hcblxubGV0IGRpcmVjdF9hY2Nlc3MgY2ggZiA9XG4gIHByaW1pdGl2ZSAoZnVuIGNoIC0+IFByaW1pdGl2ZXMuZGlyZWN0X2FjY2VzcyBjaCBmKSBjaFxuXG5sZXQgc2V0X3Bvc2l0aW9uIGNoIHBvcyA9XG4gIHByaW1pdGl2ZSAoZnVuIGNoIC0+IFByaW1pdGl2ZXMuc2V0X3Bvc2l0aW9uIGNoIHBvcykgY2hcblxubGV0IGxlbmd0aCBjaCA9XG4gIHByaW1pdGl2ZSBQcmltaXRpdmVzLmxlbmd0aCBjaFxuXG5tb2R1bGUgdHlwZSBOdW1iZXJJTyA9IHNpZ1xuICB2YWwgcmVhZF9pbnQgOiBpbnB1dF9jaGFubmVsIC0+IGludCBMd3QudFxuICB2YWwgcmVhZF9pbnQxNiA6IGlucHV0X2NoYW5uZWwgLT4gaW50IEx3dC50XG4gIHZhbCByZWFkX2ludDMyIDogaW5wdXRfY2hhbm5lbCAtPiBpbnQzMiBMd3QudFxuICB2YWwgcmVhZF9pbnQ2NCA6IGlucHV0X2NoYW5uZWwgLT4gaW50NjQgTHd0LnRcbiAgdmFsIHJlYWRfZmxvYXQzMiA6IGlucHV0X2NoYW5uZWwgLT4gZmxvYXQgTHd0LnRcbiAgdmFsIHJlYWRfZmxvYXQ2NCA6IGlucHV0X2NoYW5uZWwgLT4gZmxvYXQgTHd0LnRcbiAgdmFsIHdyaXRlX2ludCA6IG91dHB1dF9jaGFubmVsIC0+IGludCAtPiB1bml0IEx3dC50XG4gIHZhbCB3cml0ZV9pbnQxNiA6IG91dHB1dF9jaGFubmVsIC0+IGludCAtPiB1bml0IEx3dC50XG4gIHZhbCB3cml0ZV9pbnQzMiA6IG91dHB1dF9jaGFubmVsIC0+IGludDMyIC0+IHVuaXQgTHd0LnRcbiAgdmFsIHdyaXRlX2ludDY0IDogb3V0cHV0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCBMd3QudFxuICB2YWwgd3JpdGVfZmxvYXQzMiA6IG91dHB1dF9jaGFubmVsIC0+IGZsb2F0IC0+IHVuaXQgTHd0LnRcbiAgdmFsIHdyaXRlX2Zsb2F0NjQgOiBvdXRwdXRfY2hhbm5lbCAtPiBmbG9hdCAtPiB1bml0IEx3dC50XG5lbmRcblxubW9kdWxlIE1ha2VOdW1iZXJJTyAoRW5kaWFuIDogRW5kaWFuQmlnc3RyaW5nLkVuZGlhbkJpZ3N0cmluZ1NpZykgPVxuc3RydWN0XG4gIG1vZHVsZSBQcmltaXRpdmVzID0gUHJpbWl0aXZlcy5NYWtlTnVtYmVySU8gKEVuZGlhbilcblxuICBsZXQgcmVhZF9pbnQgaWMgPSBwcmltaXRpdmUgUHJpbWl0aXZlcy5yZWFkX2ludCBpY1xuICBsZXQgcmVhZF9pbnQxNiBpYyA9IHByaW1pdGl2ZSBQcmltaXRpdmVzLnJlYWRfaW50MTYgaWNcbiAgbGV0IHJlYWRfaW50MzIgaWMgPSBwcmltaXRpdmUgUHJpbWl0aXZlcy5yZWFkX2ludDMyIGljXG4gIGxldCByZWFkX2ludDY0IGljID0gcHJpbWl0aXZlIFByaW1pdGl2ZXMucmVhZF9pbnQ2NCBpY1xuICBsZXQgcmVhZF9mbG9hdDMyIGljID0gcHJpbWl0aXZlIFByaW1pdGl2ZXMucmVhZF9mbG9hdDMyIGljXG4gIGxldCByZWFkX2Zsb2F0NjQgaWMgPSBwcmltaXRpdmUgUHJpbWl0aXZlcy5yZWFkX2Zsb2F0NjQgaWNcblxuICBsZXQgd3JpdGVfaW50IG9jIHggPSBwcmltaXRpdmUgKGZ1biBvYyAtPiBQcmltaXRpdmVzLndyaXRlX2ludCBvYyB4KSBvY1xuICBsZXQgd3JpdGVfaW50MTYgb2MgeCA9IHByaW1pdGl2ZSAoZnVuIG9jIC0+IFByaW1pdGl2ZXMud3JpdGVfaW50MTYgb2MgeCkgb2NcbiAgbGV0IHdyaXRlX2ludDMyIG9jIHggPSBwcmltaXRpdmUgKGZ1biBvYyAtPiBQcmltaXRpdmVzLndyaXRlX2ludDMyIG9jIHgpIG9jXG4gIGxldCB3cml0ZV9pbnQ2NCBvYyB4ID0gcHJpbWl0aXZlIChmdW4gb2MgLT4gUHJpbWl0aXZlcy53cml0ZV9pbnQ2NCBvYyB4KSBvY1xuICBsZXQgd3JpdGVfZmxvYXQzMiBvYyB4ID1cbiAgICBwcmltaXRpdmUgKGZ1biBvYyAtPiBQcmltaXRpdmVzLndyaXRlX2Zsb2F0MzIgb2MgeCkgb2NcbiAgbGV0IHdyaXRlX2Zsb2F0NjQgb2MgeCA9XG4gICAgcHJpbWl0aXZlIChmdW4gb2MgLT4gUHJpbWl0aXZlcy53cml0ZV9mbG9hdDY0IG9jIHgpIG9jXG5lbmRcblxubW9kdWxlIExFID0gTWFrZU51bWJlcklPIChFbmRpYW5CaWdzdHJpbmcuTGl0dGxlRW5kaWFuX3Vuc2FmZSlcbm1vZHVsZSBCRSA9IE1ha2VOdW1iZXJJTyAoRW5kaWFuQmlnc3RyaW5nLkJpZ0VuZGlhbl91bnNhZmUpXG5cbnR5cGUgYnl0ZV9vcmRlciA9IEx3dF9zeXMuYnl0ZV9vcmRlciA9IExpdHRsZV9lbmRpYW4gfCBCaWdfZW5kaWFuXG5sZXQgc3lzdGVtX2J5dGVfb3JkZXIgPSBMd3Rfc3lzLmJ5dGVfb3JkZXJcblxuaW5jbHVkZSAodmFsIChtYXRjaCBzeXN0ZW1fYnl0ZV9vcmRlciB3aXRoXG4gIHwgTGl0dGxlX2VuZGlhbiAtPiAobW9kdWxlIExFIDogTnVtYmVySU8pXG4gIHwgQmlnX2VuZGlhbiAtPiAobW9kdWxlIEJFIDogTnVtYmVySU8pKSA6IE51bWJlcklPKVxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IE90aGVyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCByZWFkX2NoYXJzIGljID0gTHd0X3N0cmVhbS5mcm9tIChmdW4gXyAtPiByZWFkX2NoYXJfb3B0IGljKVxubGV0IHdyaXRlX2NoYXJzIG9jIGNoYXJzID1cbiAgTHd0X3N0cmVhbS5pdGVyX3MgKGZ1biBjaGFyIC0+IHdyaXRlX2NoYXIgb2MgY2hhcikgY2hhcnNcbmxldCByZWFkX2xpbmVzIGljID0gTHd0X3N0cmVhbS5mcm9tIChmdW4gXyAtPiByZWFkX2xpbmVfb3B0IGljKVxubGV0IHdyaXRlX2xpbmVzIG9jIGxpbmVzID1cbiAgTHd0X3N0cmVhbS5pdGVyX3MgKGZ1biBsaW5lIC0+IHdyaXRlX2xpbmUgb2MgbGluZSkgbGluZXNcblxubGV0IHplcm8gPVxuICBtYWtlXG4gICAgfm1vZGU6aW5wdXRcbiAgICB+YnVmZmVyOihMd3RfYnl0ZXMuY3JlYXRlIG1pbl9idWZmZXJfc2l6ZSlcbiAgICAoZnVuIHN0ciBvZnMgbGVuIC0+IEx3dF9ieXRlcy5maWxsIHN0ciBvZnMgbGVuICdcXHgwMCc7IEx3dC5yZXR1cm4gbGVuKVxuXG5sZXQgbnVsbCA9XG4gIG1ha2VcbiAgICB+bW9kZTpvdXRwdXRcbiAgICB+YnVmZmVyOihMd3RfYnl0ZXMuY3JlYXRlIG1pbl9idWZmZXJfc2l6ZSlcbiAgICAoZnVuIF9zdHIgX29mcyBsZW4gLT4gTHd0LnJldHVybiBsZW4pXG5cbigqIERvIG5vdCBjbG9zZSBzdGFuZGFyZCBpb3Mgb24gY2xvc2UsIG90aGVyd2lzZSB1bmNhdWdodCBleGNlcHRpb25zXG4gICB3aWxsIG5vdCBiZSBwcmludGVkICopXG5sZXQgc3RkaW4gPSBvZl9mZCB+bW9kZTppbnB1dCBMd3RfdW5peC5zdGRpblxubGV0IHN0ZG91dCA9IG9mX2ZkIH5tb2RlOm91dHB1dCBMd3RfdW5peC5zdGRvdXRcbmxldCBzdGRlcnIgPSBvZl9mZCB+bW9kZTpvdXRwdXQgTHd0X3VuaXguc3RkZXJyXG5cbmxldCBmcHJpbnQgb2MgdHh0ID0gd3JpdGUgb2MgdHh0XG5sZXQgZnByaW50bCBvYyB0eHQgPSB3cml0ZV9saW5lIG9jIHR4dFxubGV0IGZwcmludGYgb2MgZm10ID0gUHJpbnRmLmtzcHJpbnRmIChmdW4gdHh0IC0+IHdyaXRlIG9jIHR4dCkgZm10XG5sZXQgZnByaW50bGYgb2MgZm10ID0gUHJpbnRmLmtzcHJpbnRmIChmdW4gdHh0IC0+IHdyaXRlX2xpbmUgb2MgdHh0KSBmbXRcblxubGV0IHByaW50IHR4dCA9IHdyaXRlIHN0ZG91dCB0eHRcbmxldCBwcmludGwgdHh0ID0gd3JpdGVfbGluZSBzdGRvdXQgdHh0XG5sZXQgcHJpbnRmIGZtdCA9IFByaW50Zi5rc3ByaW50ZiBwcmludCBmbXRcbmxldCBwcmludGxmIGZtdCA9IFByaW50Zi5rc3ByaW50ZiBwcmludGwgZm10XG5cbmxldCBlcHJpbnQgdHh0ID0gd3JpdGUgc3RkZXJyIHR4dFxubGV0IGVwcmludGwgdHh0ID0gd3JpdGVfbGluZSBzdGRlcnIgdHh0XG5sZXQgZXByaW50ZiBmbXQgPSBQcmludGYua3NwcmludGYgZXByaW50IGZtdFxubGV0IGVwcmludGxmIGZtdCA9IFByaW50Zi5rc3ByaW50ZiBlcHJpbnRsIGZtdFxuXG5sZXQgcGlwZSA/Y2xvZXhlYyA/aW5fYnVmZmVyID9vdXRfYnVmZmVyIF8gPVxuICBsZXQgZmRfciwgZmRfdyA9IEx3dF91bml4LnBpcGUgP2Nsb2V4ZWMgKCkgaW5cbiAgKG9mX2ZkID9idWZmZXI6aW5fYnVmZmVyIH5tb2RlOmlucHV0IGZkX3IsXG4gICBvZl9mZCA/YnVmZmVyOm91dF9idWZmZXIgfm1vZGU6b3V0cHV0IGZkX3cpXG5cbnR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbmxldCBvcGVuX2ZpbGUgOlxuICAgIHR5cGUgbS5cbiAgICA/YnVmZmVyIDogTHd0X2J5dGVzLnQgLT5cbiAgICA/ZmxhZ3MgOiBVbml4Lm9wZW5fZmxhZyBsaXN0IC0+XG4gICAgP3Blcm0gOiBVbml4LmZpbGVfcGVybSAtPlxuICAgIG1vZGUgOiBtIG1vZGUgLT5cbiAgICBmaWxlX25hbWUgLT5cbiAgICAgIG0gY2hhbm5lbCBMd3QudCA9XG4gICAgZnVuID9idWZmZXIgP2ZsYWdzID9wZXJtIH5tb2RlIGZpbGVuYW1lIC0+XG4gIGxldCBmbGFncyA9IG1hdGNoIGZsYWdzLCBtb2RlIHdpdGhcbiAgICB8IFNvbWUgbCwgXyAtPlxuICAgICAgbFxuICAgIHwgTm9uZSwgSW5wdXQgLT5cbiAgICAgIFtVbml4Lk9fUkRPTkxZOyBVbml4Lk9fTk9OQkxPQ0tdXG4gICAgfCBOb25lLCBPdXRwdXQgLT5cbiAgICAgIFtVbml4Lk9fV1JPTkxZOyBVbml4Lk9fQ1JFQVQ7IFVuaXguT19UUlVOQzsgVW5peC5PX05PTkJMT0NLXVxuICBhbmQgcGVybSA9IG1hdGNoIHBlcm0sIG1vZGUgd2l0aFxuICAgIHwgU29tZSBwLCBfIC0+XG4gICAgICBwXG4gICAgfCBOb25lLCBJbnB1dCAtPlxuICAgICAgMFxuICAgIHwgTm9uZSwgT3V0cHV0IC0+XG4gICAgICAwbzY2NlxuICBpblxuICBMd3RfdW5peC5vcGVuZmlsZSBmaWxlbmFtZSBmbGFncyBwZXJtID4+PSBmdW4gZmQgLT5cbiAgTHd0LnJldHVybiAob2ZfZmQgP2J1ZmZlciB+bW9kZSBmZClcblxubGV0IHdpdGhfZmlsZSA/YnVmZmVyID9mbGFncyA/cGVybSB+bW9kZSBmaWxlbmFtZSBmID1cbiAgb3Blbl9maWxlID9idWZmZXIgP2ZsYWdzID9wZXJtIH5tb2RlIGZpbGVuYW1lID4+PSBmdW4gaWMgLT5cbiAgTHd0LmZpbmFsaXplXG4gICAgKGZ1biAoKSAtPiBmIGljKVxuICAgIChmdW4gKCkgLT4gY2xvc2UgaWMpXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0ICgpKVxuXG5sZXQgdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCBybmQgPSBSYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHBybmcpIDB4MTAwMDAwMCBpblxuICBGaWxlbmFtZS5jb25jYXQgdGVtcF9kaXIgKFByaW50Zi5zcHJpbnRmIFwiJXMlMDZ4JXNcIiBwcmVmaXggcm5kIHN1ZmZpeClcblxubGV0IG9wZW5fdGVtcF9maWxlID9idWZmZXIgP2ZsYWdzID9wZXJtID90ZW1wX2RpciA/cHJlZml4ID8oc3VmZml4ID0gXCJcIikgKCkgPVxuICBsZXQgZmxhZ3MgPVxuICAgIG1hdGNoIGZsYWdzIHdpdGhcbiAgICB8IE5vbmUgLT4gW1VuaXguT19XUk9OTFk7IFVuaXguT19DUkVBVDsgVW5peC5PX0VYQ0w7IFVuaXguT19DTE9FWEVDXVxuICAgIHwgU29tZSBmbGFncyAtPiBmbGFnc1xuICBpblxuICBsZXQgZGlyID1cbiAgICBtYXRjaCB0ZW1wX2RpciB3aXRoXG4gICAgfCBOb25lIC0+IEZpbGVuYW1lLmdldF90ZW1wX2Rpcl9uYW1lICgpXG4gICAgfCBTb21lIGRpcm5hbWUgLT4gZGlybmFtZVxuICBpblxuICBsZXQgcHJlZml4ID1cbiAgICBtYXRjaCBwcmVmaXggd2l0aFxuICAgIHwgTm9uZSAtPiBcImx3dF9pb190ZW1wX2ZpbGVfXCJcbiAgICB8IFNvbWUgcHJlZml4IC0+IHByZWZpeFxuICBpblxuXG4gIGxldCByZWMgYXR0ZW1wdCBuID1cbiAgICBsZXQgZm5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSBkaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIEx3dC5jYXRjaFxuICAgICAgKGZ1biAoKSAtPlxuICAgICAgICBvcGVuX2ZpbGUgP2J1ZmZlciB+ZmxhZ3MgP3Blcm0gfm1vZGU6T3V0cHV0IGZuYW1lID4+PSBmdW4gY2hhbiAtPlxuICAgICAgICBMd3QucmV0dXJuIChmbmFtZSwgY2hhbikpXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBVbml4LlVuaXhfZXJyb3IgXyB3aGVuIG4gPCAxMDAwIC0+IGF0dGVtcHQgKG4gKyAxKVxuICAgICAgICB8IGV4biAtPiBMd3QucmVyYWlzZSBleG4pXG4gIGluXG4gIGF0dGVtcHQgMFxuXG5sZXQgd2l0aF90ZW1wX2ZpbGUgP2J1ZmZlciA/ZmxhZ3MgP3Blcm0gP3RlbXBfZGlyID9wcmVmaXggP3N1ZmZpeCBmID1cbiAgb3Blbl90ZW1wX2ZpbGVcbiAgICA/YnVmZmVyID9mbGFncyA/cGVybSA/dGVtcF9kaXIgP3ByZWZpeCA/c3VmZml4ICgpID4+PSBmdW4gKGZuYW1lLCBjaGFuKSAtPlxuICBMd3QuZmluYWxpemVcbiAgICAoZnVuICgpIC0+XG4gICAgICBmIChmbmFtZSwgY2hhbikpXG4gICAgKGZ1biAoKSAtPlxuICAgICAgY2xvc2UgY2hhbiA+Pj0gZnVuICgpIC0+XG4gICAgICBMd3RfdW5peC51bmxpbmsgZm5hbWUpXG5cbmxldCBjcmVhdGVfdGVtcF9kaXJcbiAgICA/KHBlcm0gPSAwbzc1NSlcbiAgICA/KHBhcmVudCA9IEZpbGVuYW1lLmdldF90ZW1wX2Rpcl9uYW1lICgpKVxuICAgID8ocHJlZml4ID0gXCJsd3RfaW9fdGVtcF9kaXJfXCIpXG4gICAgPyhzdWZmaXggPSBcIlwiKVxuICAgICgpID1cbiAgbGV0IHJlYyBhdHRlbXB0IG4gPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgcGFyZW50IHByZWZpeCBzdWZmaXggaW5cbiAgICBMd3QuY2F0Y2hcbiAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgTHd0X3VuaXgubWtkaXIgbmFtZSBwZXJtID4+PSBmdW4gKCkgLT5cbiAgICAgICAgTHd0LnJldHVybiBuYW1lKVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICB8IFVuaXguVW5peF9lcnJvciAoVW5peC5FRVhJU1QsIF8sIF8pIHdoZW4gbiA8IDEwMDAgLT4gYXR0ZW1wdCAobiArIDEpXG4gICAgICB8IGV4biAtPiBMd3QucmVyYWlzZSBleG4pXG4gIGluXG4gIGF0dGVtcHQgMFxuXG5sZXQgd2luMzJfdW5saW5rIGZuID1cbiAgTHd0LmNhdGNoXG4gICAgKGZ1biAoKSAtPiBMd3RfdW5peC51bmxpbmsgZm4pXG4gICAgKGZ1bmN0aW9uXG4gICAgIHwgVW5peC5Vbml4X2Vycm9yIChVbml4LkVBQ0NFUywgXywgXykgYXMgZXhuIC0+XG4gICAgICAgKCogVHJ5IHJlbW92aW5nIHRoZSByZWFkLW9ubHkgYXR0cmlidXRlIGJlZm9yZSByZXRyeWluZyB1bmxpbmsuIFdlIGNhdGNoXG4gICAgICAgICAgYW55IGV4Y2VwdGlvbiBoZXJlIGFuZCBpZ25vcmUgaXQgaW4gZmF2b3VyIG9mIHRoZSBvcmlnaW5hbCBbZXhuXS4gKilcbiAgICAgICBMd3QuY2F0Y2hcbiAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgTHd0X3VuaXgubHN0YXQgZm4gPj49IGZ1biB7c3RfcGVybTsgX30gLT5cbiAgICAgICAgICAgTHd0X3VuaXguY2htb2QgZm4gMG82NjYgPj49IGZ1biAoKSAtPlxuICAgICAgICAgICBMd3QuY2F0Y2hcbiAgICAgICAgICAgICAoZnVuICgpIC0+IEx3dF91bml4LnVubGluayBmbilcbiAgICAgICAgICAgICAoZnVuY3Rpb24gXyAtPlxuICAgICAgICAgICAgICAgICgqIElmIGV2ZXJ5dGhpbmcgc3VjY2VlZGVkIGJ1dCB0aGUgZmluYWwgcmVtb3ZhbCBzdGlsbCBmYWlsZWQsXG4gICAgICAgICAgICAgICAgICAgcmVzdG9yZSBvcmlnaW5hbCBwZXJtaXNzaW9ucyAqKVxuICAgICAgICAgICAgICAgIEx3dF91bml4LmNobW9kIGZuIHN0X3Blcm0gPj49IGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgIEx3dC5yZXJhaXNlIGV4bilcbiAgICAgICAgIClcbiAgICAgICAgIChmdW4gXyAtPiBMd3QucmVyYWlzZSBleG4pXG4gICAgIHwgZXhuIC0+IEx3dC5yZXJhaXNlIGV4bilcblxubGV0IHVubGluayA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgd2luMzJfdW5saW5rXG4gIGVsc2VcbiAgICBMd3RfdW5peC51bmxpbmtcblxuKCogVGhpcyBpcyBsaWtlbHkgVkVSWSBzbG93IGZvciBkaXJlY3RvcmllcyB3aXRoIG1hbnkgZmlsZXMuIFRoYXQgaXMgcHJvYmFibHlcbiAgIGJlc3QgYWRkcmVzc2VkIGJ5IHN3aXRjaGluZyB0byBibG9ja2luZyBjYWxscyBydW4gaW5zaWRlIGEgd29ya2VyIHRocmVhZCxcbiAgIGkuZS4gd2l0aCBMd3RfcHJlZW1wdGl2ZS4gKilcbmxldCByZWMgZGVsZXRlX3JlY3Vyc2l2ZWx5IGRpcmVjdG9yeSA9XG4gIEx3dF91bml4LmZpbGVzX29mX2RpcmVjdG9yeSBkaXJlY3RvcnlcbiAgfD4gTHd0X3N0cmVhbS5pdGVyX3MgYmVnaW4gZnVuIGVudHJ5IC0+XG4gICAgaWYgZW50cnkgPSBGaWxlbmFtZS5jdXJyZW50X2Rpcl9uYW1lIHx8XG4gICAgICAgZW50cnkgPSBGaWxlbmFtZS5wYXJlbnRfZGlyX25hbWUgdGhlblxuICAgICAgTHd0LnJldHVybl91bml0XG4gICAgZWxzZVxuICAgICAgbGV0IHBhdGggPSBGaWxlbmFtZS5jb25jYXQgZGlyZWN0b3J5IGVudHJ5IGluXG4gICAgICBMd3RfdW5peC5sc3RhdCBwYXRoID4+PSBmdW4ge0x3dF91bml4LnN0X2tpbmQ7IF99IC0+XG4gICAgICBtYXRjaCBzdF9raW5kIHdpdGhcbiAgICAgIHwgU19ESVIgLT4gZGVsZXRlX3JlY3Vyc2l2ZWx5IHBhdGhcbiAgICAgIHwgU19MTksgd2hlbiAoU3lzLndpbjMyIHx8IFN5cy5jeWd3aW4pIC0+XG4gICAgICAgICBMd3RfdW5peC5zdGF0IHBhdGggPj49IGZ1biB7THd0X3VuaXguc3Rfa2luZDsgX30gLT5cbiAgICAgICAgIGJlZ2luIG1hdGNoIHN0X2tpbmQgd2l0aFxuICAgICAgICAgfCBTX0RJUiAtPiBMd3RfdW5peC5ybWRpciBwYXRoXG4gICAgICAgICB8IF8gLT4gdW5saW5rIHBhdGhcbiAgICAgICAgIGVuZFxuICAgICAgfCBfIC0+IHVubGluayBwYXRoXG4gIGVuZCA+Pj0gZnVuICgpIC0+XG4gIEx3dF91bml4LnJtZGlyIGRpcmVjdG9yeVxuXG5sZXQgd2l0aF90ZW1wX2RpciA/cGVybSA/cGFyZW50ID9wcmVmaXggP3N1ZmZpeCBmID1cbiAgY3JlYXRlX3RlbXBfZGlyID9wZXJtID9wYXJlbnQgP3ByZWZpeCA/c3VmZml4ICgpID4+PSBmdW4gbmFtZSAtPlxuICBMd3QuZmluYWxpemVcbiAgICAoZnVuICgpIC0+XG4gICAgICBmIG5hbWUpXG4gICAgKGZ1biAoKSAtPlxuICAgICAgZGVsZXRlX3JlY3Vyc2l2ZWx5IG5hbWUpXG5cbmxldCBmaWxlX2xlbmd0aCBmaWxlbmFtZSA9XG4gIEx3dF91bml4LnN0YXQgZmlsZW5hbWUgPj49IGZ1biBzdGF0IC0+XG4gIGlmIHN0YXQuVW5peC5zdF9raW5kID0gVW5peC5TX0RJUiB0aGVuXG4gICAgTHd0LmZhaWwgKFVuaXguKFVuaXhfZXJyb3IgKEVJU0RJUiwgXCJmaWxlX2xlbmd0aFwiLCBmaWxlbmFtZSkpKVxuICBlbHNlXG4gICAgd2l0aF9maWxlIH5tb2RlOmlucHV0IGZpbGVuYW1lIGxlbmd0aFxuXG5sZXQgY2xvc2Vfc29ja2V0IGZkID1cbiAgTHd0LmZpbmFsaXplXG4gICAgKGZ1biAoKSAtPlxuICAgICAgIEx3dC5jYXRjaFxuICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgTHd0X3VuaXguc2h1dGRvd24gZmQgVW5peC5TSFVURE9XTl9BTEw7XG4gICAgICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG4gICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgKCogT2NjdXJzIGlmIHRoZSBwZWVyIGNsb3NlcyB0aGUgY29ubmVjdGlvbiBmaXJzdC4gKilcbiAgICAgICAgICAgfCBVbml4LlVuaXhfZXJyb3IgKFVuaXguRU5PVENPTk4sIF8sIF8pIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgICAgICAgICB8IGV4biAtPiBMd3QucmVyYWlzZSBleG4pIFtAb2NhbWwud2FybmluZyBcIi00XCJdKVxuICAgIChmdW4gKCkgLT5cbiAgICAgICBMd3RfdW5peC5jbG9zZSBmZClcblxubGV0IG9wZW5fY29ubmVjdGlvbiA/ZmQgP2luX2J1ZmZlciA/b3V0X2J1ZmZlciBzb2NrYWRkciA9XG4gIGxldCBmZCA9XG4gICAgbWF0Y2ggZmQgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0X3VuaXguc29ja2V0IChVbml4LmRvbWFpbl9vZl9zb2NrYWRkciBzb2NrYWRkcikgVW5peC5TT0NLX1NUUkVBTSAwXG4gICAgfCBTb21lIGZkIC0+XG4gICAgICBmZFxuICBpblxuICBsZXQgY2xvc2UgPSBsYXp5IChjbG9zZV9zb2NrZXQgZmQpIGluXG4gIEx3dC5jYXRjaFxuICAgIChmdW4gKCkgLT5cbiAgICAgICBMd3RfdW5peC5jb25uZWN0IGZkIHNvY2thZGRyID4+PSBmdW4gKCkgLT5cbiAgICAgICAodHJ5IEx3dF91bml4LnNldF9jbG9zZV9vbl9leGVjIGZkIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+ICgpKTtcbiAgICAgICBMd3QucmV0dXJuIChtYWtlID9idWZmZXI6aW5fYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICB+Y2xvc2U6KGZ1biBfIC0+IExhenkuZm9yY2UgY2xvc2UpXG4gICAgICAgICAgICAgICAgICAgICB+bW9kZTppbnB1dCAoTHd0X2J5dGVzLnJlYWQgZmQpLFxuICAgICAgICAgICAgICAgICAgIG1ha2UgP2J1ZmZlcjpvdXRfYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICB+Y2xvc2U6KGZ1biBfIC0+IExhenkuZm9yY2UgY2xvc2UpXG4gICAgICAgICAgICAgICAgICAgICB+bW9kZTpvdXRwdXQgKEx3dF9ieXRlcy53cml0ZSBmZCkpKVxuICAgIChmdW4gZXhuIC0+XG4gICAgICAgTHd0X3VuaXguY2xvc2UgZmQgPj49IGZ1biAoKSAtPlxuICAgICAgIEx3dC5yZXJhaXNlIGV4bilcblxubGV0IHdpdGhfY2xvc2VfY29ubmVjdGlvbiBmIChpYywgb2MpID1cbiAgKCogSWYgdGhlIHVzZXIgYWxyZWFkeSB0cmllZCB0byBjbG9zZSB0aGUgc29ja2V0IGFuZCBnb3QgYW4gZXhjZXB0aW9uLCB3ZVxuICAgICBkb24ndCB3YW50IHRvIHJhaXNlIHRoYXQgZXhjZXB0aW9uIGFnYWluIGR1cmluZyBpbXBsaWNpdCBjbG9zZS4gKilcbiAgbGV0IGNsb3NlX2lmX25vdF9jbG9zZWQgY2hhbm5lbCA9XG4gICAgaWYgaXNfY2xvc2VkIGNoYW5uZWwgdGhlbiBMd3QucmV0dXJuX3VuaXQgZWxzZSBjbG9zZSBjaGFubmVsIGluXG5cbiAgTHd0LmZpbmFsaXplXG4gICAgKGZ1biAoKSAtPiBmIChpYywgb2MpKVxuICAgIChmdW4gKCkgLT4gY2xvc2VfaWZfbm90X2Nsb3NlZCBpYyA8Jj4gY2xvc2VfaWZfbm90X2Nsb3NlZCBvYylcblxubGV0IHdpdGhfY29ubmVjdGlvbiA/ZmQgP2luX2J1ZmZlciA/b3V0X2J1ZmZlciBzb2NrYWRkciBmID1cbiAgb3Blbl9jb25uZWN0aW9uID9mZCA/aW5fYnVmZmVyID9vdXRfYnVmZmVyIHNvY2thZGRyID4+PSBmdW4gY2hhbm5lbHMgLT5cbiAgd2l0aF9jbG9zZV9jb25uZWN0aW9uIGYgY2hhbm5lbHNcblxudHlwZSBzZXJ2ZXIgPSB7XG4gIHNodXRkb3duIDogdW5pdCBMd3QudCBMYXp5LnQ7XG59XG5cbmxldCBzaHV0ZG93bl9zZXJ2ZXIgc2VydmVyID0gTGF6eS5mb3JjZSBzZXJ2ZXIuc2h1dGRvd25cblxubGV0IHNodXRkb3duX3NlcnZlcl9kZXByZWNhdGVkIHNlcnZlciA9XG4gIEx3dC5hc3luYyAoZnVuICgpIC0+IHNodXRkb3duX3NlcnZlciBzZXJ2ZXIpXG5cbigqIFRoZXJlIGFyZSBzZXZlcmFsIHZhcmlhbnRzIG9mIGVzdGFibGlzaF9zZXJ2ZXIgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIG92ZXIgdGhlXG4gICB5ZWFycyBpbiBMd3RfaW8uIFRoaXMgaXMgdGhlaXIgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbi4gVGhlIGZ1bmN0aW9uc1xuICAgZXhwb3NlZCBpbiB0aGUgQVBJIGFyZSB2YXJpb3VzIHdyYXBwZXJzIGFyb3VuZCB0aGlzIG9uZS4gKilcbmxldCBlc3RhYmxpc2hfc2VydmVyX2dlbmVyaWNcbiAgICBiaW5kX2Z1bmN0aW9uXG4gICAgP2ZkOnByZWV4aXN0aW5nX3NvY2tldF9mb3JfbGlzdGVuaW5nXG4gICAgPyhiYWNrbG9nID0gTHd0X3VuaXguc29tYXhjb25uICgpIFtAb2NhbWwud2FybmluZyBcIi0zXCJdKVxuICAgIGxpc3RlbmluZ19hZGRyZXNzXG4gICAgY29ubmVjdGlvbl9oYW5kbGVyX2NhbGxiYWNrID1cblxuICBsZXQgbGlzdGVuaW5nX3NvY2tldCA9XG4gICAgbWF0Y2ggcHJlZXhpc3Rpbmdfc29ja2V0X2Zvcl9saXN0ZW5pbmcgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0X3VuaXguc29ja2V0XG4gICAgICAgIChVbml4LmRvbWFpbl9vZl9zb2NrYWRkciBsaXN0ZW5pbmdfYWRkcmVzcykgVW5peC5TT0NLX1NUUkVBTSAwXG4gICAgfCBTb21lIHNvY2tldCAtPlxuICAgICAgc29ja2V0XG4gIGluXG4gIEx3dF91bml4LnNldHNvY2tvcHQgbGlzdGVuaW5nX3NvY2tldCBVbml4LlNPX1JFVVNFQUREUiB0cnVlO1xuXG4gICgqIFRoaXMgcHJvbWlzZSBnZXRzIHJlc29sdmVkIHdpdGggYFNob3VsZF9zdG9wIHdoZW4gdGhlIHVzZXIgY2FsbHNcbiAgICAgTHd0X2lvLnNodXRkb3duX3NlcnZlci4gVGhpcyBiZWdpbnMgdGhlIHNodXRkb3duIHByb2NlZHVyZS4gKilcbiAgbGV0IHNob3VsZF9zdG9wLCBub3RpZnlfc2hvdWxkX3N0b3AgPVxuICAgIEx3dC53YWl0ICgpIGluXG5cbiAgKCogU29tZSB0aW1lIGFmdGVyIEx3dF9pby5zaHV0ZG93bl9zZXJ2ZXIgaXMgY2FsbGVkLCB0aGlzIGZ1bmN0aW9uXG4gICAgIGVzdGFibGlzaF9zZXJ2ZXJfZ2VuZXJpYyB3aWxsIGFjdHVhbGx5IGNsb3NlIHRoZSBsaXN0ZW5pbmcgc29ja2V0LiBBdCB0aGF0XG4gICAgIHBvaW50LCB0aGlzIHByb21pc2UgaXMgcmVzb2x2ZWQuIFRoaXMgZW5kcyB0aGUgc2h1dGRvd24gcHJvY2VkdXJlLiAqKVxuICBsZXQgd2FpdF91bnRpbF9saXN0ZW5pbmdfc29ja2V0X2Nsb3NlZCwgbm90aWZ5X2xpc3RlbmluZ19zb2NrZXRfY2xvc2VkID1cbiAgICBMd3Qud2FpdCAoKSBpblxuXG4gIGxldCByZWMgYWNjZXB0X2xvb3AgKCkgPVxuICAgIGxldCB0cnlfdG9fYWNjZXB0ID1cbiAgICAgIEx3dC5jYXRjaFxuICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgIEx3dF91bml4LmFjY2VwdCBsaXN0ZW5pbmdfc29ja2V0ID58PSBmdW4geCAtPlxuICAgICAgICAgICBgQWNjZXB0ZWQgeClcbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBVbml4LlVuaXhfZXJyb3IgKFVuaXguRUNPTk5BQk9SVEVELCBfLCBfKSAtPlxuICAgICAgICAgICAgTHd0LnJldHVybiBgVHJ5X2FnYWluXG4gICAgICAgICAgfCBlIC0+IEx3dC5yZXJhaXNlIGUpXG4gICAgaW5cblxuICAgIEx3dC5waWNrIFt0cnlfdG9fYWNjZXB0OyBzaG91bGRfc3RvcF0gPj49IGZ1bmN0aW9uXG4gICAgfCBgQWNjZXB0ZWQgKGNsaWVudF9zb2NrZXQsIGNsaWVudF9hZGRyZXNzKSAtPlxuICAgICAgYmVnaW5cbiAgICAgICAgdHJ5IEx3dF91bml4LnNldF9jbG9zZV9vbl9leGVjIGNsaWVudF9zb2NrZXRcbiAgICAgICAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gKClcbiAgICAgIGVuZDtcblxuICAgICAgY29ubmVjdGlvbl9oYW5kbGVyX2NhbGxiYWNrIGNsaWVudF9hZGRyZXNzIGNsaWVudF9zb2NrZXQ7XG5cbiAgICAgIGFjY2VwdF9sb29wICgpXG5cbiAgICB8IGBTaG91bGRfc3RvcCAtPlxuICAgICAgTHd0X3VuaXguY2xvc2UgbGlzdGVuaW5nX3NvY2tldCA+Pj0gZnVuICgpIC0+XG5cbiAgICAgIGJlZ2luIG1hdGNoIGxpc3RlbmluZ19hZGRyZXNzIHdpdGhcbiAgICAgIHwgVW5peC5BRERSX1VOSVggcGF0aCB3aGVuIHBhdGggPD4gXCJcIiAmJiBwYXRoLlswXSA8PiAnXFx4MDAnIC0+XG4gICAgICAgIFVuaXgudW5saW5rIHBhdGhcbiAgICAgIHwgXyAtPlxuICAgICAgICAoKVxuICAgICAgZW5kIFtAb2NhbWwud2FybmluZyBcIi00XCJdO1xuXG4gICAgICBMd3Qud2FrZXVwX2xhdGVyIG5vdGlmeV9saXN0ZW5pbmdfc29ja2V0X2Nsb3NlZCAoKTtcbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgYFRyeV9hZ2FpbiAtPlxuICAgICAgYWNjZXB0X2xvb3AgKClcbiAgaW5cblxuICBsZXQgc2VydmVyID1cbiAgICB7c2h1dGRvd24gPVxuICAgICAgbGF6eSBiZWdpblxuICAgICAgICBMd3Qud2FrZXVwX2xhdGVyIG5vdGlmeV9zaG91bGRfc3RvcCBgU2hvdWxkX3N0b3A7XG4gICAgICAgIHdhaXRfdW50aWxfbGlzdGVuaW5nX3NvY2tldF9jbG9zZWRcbiAgICAgIGVuZH1cbiAgaW5cblxuICAoKiBBY3R1YWxseSBzdGFydCB0aGUgc2VydmVyLiAqKVxuICBsZXQgc2VydmVyX2hhc19zdGFydGVkID1cbiAgICBiaW5kX2Z1bmN0aW9uIGxpc3RlbmluZ19zb2NrZXQgbGlzdGVuaW5nX2FkZHJlc3MgPj49IGZ1biAoKSAtPlxuICAgIEx3dF91bml4Lmxpc3RlbiBsaXN0ZW5pbmdfc29ja2V0IGJhY2tsb2c7XG5cbiAgICBMd3QuYXN5bmMgYWNjZXB0X2xvb3A7XG5cbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgaW5cblxuICBzZXJ2ZXIsIHNlcnZlcl9oYXNfc3RhcnRlZFxuXG5sZXQgZXN0YWJsaXNoX3NlcnZlcl93aXRoX2NsaWVudF9zb2NrZXRcbiAgICA/c2VydmVyX2ZkID9iYWNrbG9nID8obm9fY2xvc2UgPSBmYWxzZSkgc29ja2FkZHIgZiA9XG4gIGxldCBoYW5kbGVyIGNsaWVudF9hZGRyZXNzIGNsaWVudF9zb2NrZXQgPVxuICAgIEx3dC5hc3luYyBiZWdpbiBmdW4gKCkgLT5cbiAgICAgICgqIE5vdCB1c2luZyBMd3QuZmluYWxpemUgaGVyZSwgdG8gbWFrZSBzdXJlIHRoYXQgZXhjZXB0aW9ucyBmcm9tIFtmXVxuICAgICAgICAgcmVhY2ggIUx3dC5hc3luY19leGNlcHRpb25faG9vayBiZWZvcmUgZXhjZXB0aW9ucyBmcm9tIGNsb3NpbmcgdGhlXG4gICAgICAgICBjaGFubmVscy4gKilcbiAgICAgIEx3dC5jYXRjaFxuICAgICAgICAoZnVuICgpIC0+IGYgY2xpZW50X2FkZHJlc3MgY2xpZW50X3NvY2tldClcbiAgICAgICAgKGZ1biBleG4gLT5cbiAgICAgICAgICAhTHd0LmFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4bjtcbiAgICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG5cbiAgICAgID4+PSBmdW4gKCkgLT5cbiAgICAgIGlmIG5vX2Nsb3NlIHRoZW4gTHd0LnJldHVybl91bml0XG4gICAgICBlbHNlXG4gICAgICAgIGlmIEx3dF91bml4LnN0YXRlIGNsaWVudF9zb2NrZXQgPSBMd3RfdW5peC5DbG9zZWQgdGhlblxuICAgICAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgICAgICBlbHNlXG4gICAgICAgICAgTHd0LmNhdGNoXG4gICAgICAgICAgICAoZnVuICgpIC0+IGNsb3NlX3NvY2tldCBjbGllbnRfc29ja2V0KVxuICAgICAgICAgICAgKGZ1biBleG4gLT5cbiAgICAgICAgICAgICAgIUx3dC5hc3luY19leGNlcHRpb25faG9vayBleG47XG4gICAgICAgICAgICAgIEx3dC5yZXR1cm5fdW5pdClcbiAgICBlbmRcbiAgaW5cblxuICBsZXQgc2VydmVyLCBzZXJ2ZXJfc3RhcnRlZCA9XG4gICAgZXN0YWJsaXNoX3NlcnZlcl9nZW5lcmljXG4gICAgICBMd3RfdW5peC5iaW5kID9mZDpzZXJ2ZXJfZmQgP2JhY2tsb2cgc29ja2FkZHIgaGFuZGxlclxuICBpblxuICBzZXJ2ZXJfc3RhcnRlZCA+Pj0gZnVuICgpIC0+XG4gIEx3dC5yZXR1cm4gc2VydmVyXG5cbmxldCBlc3RhYmxpc2hfc2VydmVyX3dpdGhfY2xpZW50X2FkZHJlc3NfZ2VuZXJpY1xuICAgIGJpbmRfZnVuY3Rpb25cbiAgICA/ZmRcbiAgICA/KGJ1ZmZlcl9zaXplID0gIWRlZmF1bHRfYnVmZmVyX3NpemUpXG4gICAgP2JhY2tsb2dcbiAgICA/KG5vX2Nsb3NlID0gZmFsc2UpXG4gICAgc29ja2FkZHJcbiAgICBoYW5kbGVyID1cblxuICBsZXQgYmVzdF9lZmZvcnRfY2xvc2UgY2hhbm5lbCA9XG4gICAgKCogRmlyc3QsIGNoZWNrIHdoZXRoZXIgdGhlIGNoYW5uZWwgaXMgY2xvc2VkLiBmIG1heSBoYXZlIGFscmVhZHkgdHJpZWQgdG9cbiAgICAgICBjbG9zZSB0aGUgY2hhbm5lbCwgcmVjZWl2ZWQgYW4gZXhjZXB0aW9uLCBhbmQgaGFuZGxlZCBpdCBzb21laG93LiBJZiBzbyxcbiAgICAgICB0cnlpbmcgdG8gY2xvc2UgdGhlIGNoYW5uZWwgaGVyZSB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXhjZXB0aW9uLCB3aGljaFxuICAgICAgIHdpbGwgZ28gdG8gIUx3dC5hc3luY19leGNlcHRpb25faG9vaywgZGVzcGl0ZSB0aGUgdXNlcidzIGVmZm9ydHMuICopXG4gICAgKCogVGhlIEludmFsaWQgc3RhdGUgaXMgbm90IHBvc3NpYmxlIG9uIHRoZSBjaGFubmVsLCBiZWNhdXNlIGl0IHdhcyBub3RcbiAgICAgICBjcmVhdGVkIHVzaW5nIEx3dF9pby5hdG9taWMuICopXG4gICAgaWYgaXNfY2xvc2VkIGNoYW5uZWwgdGhlblxuICAgICAgTHd0LnJldHVybl91bml0XG4gICAgZWxzZVxuICAgICAgTHd0LmNhdGNoXG4gICAgICAgIChmdW4gKCkgLT4gY2xvc2UgY2hhbm5lbClcbiAgICAgICAgKGZ1biBleG4gLT5cbiAgICAgICAgICAhTHd0LmFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4bjtcbiAgICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG4gIGluXG5cbiAgbGV0IGhhbmRsZXIgY2xpZW50X2FkZHJlc3MgY2xpZW50X3NvY2tldCA9XG4gICAgTHd0LmFzeW5jIChmdW4gKCkgLT5cbiAgICAgIGxldCBjbG9zZSA9IGxhenkgKGNsb3NlX3NvY2tldCBjbGllbnRfc29ja2V0KSBpblxuICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPVxuICAgICAgICBvZl9mZFxuICAgICAgICAgIH5idWZmZXI6KEx3dF9ieXRlcy5jcmVhdGUgYnVmZmVyX3NpemUpXG4gICAgICAgICAgfm1vZGU6aW5wdXRcbiAgICAgICAgICB+Y2xvc2U6KGZ1biAoKSAtPiBMYXp5LmZvcmNlIGNsb3NlKVxuICAgICAgICAgIGNsaWVudF9zb2NrZXRcbiAgICAgIGluXG4gICAgICBsZXQgb3V0cHV0X2NoYW5uZWwgPVxuICAgICAgICBvZl9mZFxuICAgICAgICAgIH5idWZmZXI6KEx3dF9ieXRlcy5jcmVhdGUgYnVmZmVyX3NpemUpXG4gICAgICAgICAgfm1vZGU6b3V0cHV0XG4gICAgICAgICAgfmNsb3NlOihmdW4gKCkgLT4gTGF6eS5mb3JjZSBjbG9zZSlcbiAgICAgICAgICBjbGllbnRfc29ja2V0XG4gICAgICBpblxuXG4gICAgICAoKiBOb3QgdXNpbmcgTHd0LmZpbmFsaXplIGhlcmUsIHRvIG1ha2Ugc3VyZSB0aGF0IGV4Y2VwdGlvbnMgZnJvbSBbZl1cbiAgICAgICAgIHJlYWNoICFMd3QuYXN5bmNfZXhjZXB0aW9uX2hvb2sgYmVmb3JlIGV4Y2VwdGlvbnMgZnJvbSBjbG9zaW5nIHRoZVxuICAgICAgICAgY2hhbm5lbHMuICopXG4gICAgICBMd3QuY2F0Y2hcbiAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgIGhhbmRsZXIgY2xpZW50X2FkZHJlc3MgKGlucHV0X2NoYW5uZWwsIG91dHB1dF9jaGFubmVsKSlcbiAgICAgICAgKGZ1biBleG4gLT5cbiAgICAgICAgICAhTHd0LmFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4bjtcbiAgICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG5cbiAgICAgID4+PSBmdW4gKCkgLT5cbiAgICAgIGlmIG5vX2Nsb3NlIHRoZW4gTHd0LnJldHVybl91bml0XG4gICAgICBlbHNlXG4gICAgICAgIGJlc3RfZWZmb3J0X2Nsb3NlIGlucHV0X2NoYW5uZWwgPj49IGZ1biAoKSAtPlxuICAgICAgICBiZXN0X2VmZm9ydF9jbG9zZSBvdXRwdXRfY2hhbm5lbClcbiAgaW5cblxuICBlc3RhYmxpc2hfc2VydmVyX2dlbmVyaWMgYmluZF9mdW5jdGlvbiA/ZmQgP2JhY2tsb2cgc29ja2FkZHIgaGFuZGxlclxuXG5sZXQgZXN0YWJsaXNoX3NlcnZlcl93aXRoX2NsaWVudF9hZGRyZXNzXG4gICAgP2ZkID9idWZmZXJfc2l6ZSA/YmFja2xvZyA/bm9fY2xvc2Ugc29ja2FkZHIgaGFuZGxlciA9XG4gIGxldCBzZXJ2ZXIsIHNlcnZlcl9zdGFydGVkID1cbiAgICBlc3RhYmxpc2hfc2VydmVyX3dpdGhfY2xpZW50X2FkZHJlc3NfZ2VuZXJpY1xuICAgICAgTHd0X3VuaXguYmluZCA/ZmQgP2J1ZmZlcl9zaXplID9iYWNrbG9nID9ub19jbG9zZSBzb2NrYWRkciBoYW5kbGVyXG4gIGluXG4gIHNlcnZlcl9zdGFydGVkID4+PSBmdW4gKCkgLT5cbiAgTHd0LnJldHVybiBzZXJ2ZXJcblxubGV0IGVzdGFibGlzaF9zZXJ2ZXIgP2ZkID9idWZmZXJfc2l6ZSA/YmFja2xvZyA/bm9fY2xvc2Ugc29ja2FkZHIgZiA9XG4gIGxldCBmIF9hZGRyIGMgPSBmIGMgaW5cbiAgZXN0YWJsaXNoX3NlcnZlcl93aXRoX2NsaWVudF9hZGRyZXNzXG4gICAgP2ZkID9idWZmZXJfc2l6ZSA/YmFja2xvZyA/bm9fY2xvc2Ugc29ja2FkZHIgZlxuXG4oKiBPbGQsIGRlcHJlY2F0ZWQgdmVyc2lvbiBvZiBbZXN0YWJsaXNoX3NlcnZlcl0uIFRoaXMgZnVuY3Rpb24gaGFzIHRvIHBlcnNpc3RcbiAgIGZvciBhIHdoaWxlLCBpbiBzb21lIGZvcm0sIHVudGlsIGl0IGlzIG5vIGxvbmdlciBleHBvc2VkIGFzXG4gICBbTHd0X2lvLlZlcnNpb25lZC5lc3RhYmxpc2hfc2VydmVyXzFdLiAqKVxubGV0IGVzdGFibGlzaF9zZXJ2ZXJfZGVwcmVjYXRlZCA/ZmQgP2J1ZmZlcl9zaXplID9iYWNrbG9nIHNvY2thZGRyIGYgPVxuICBsZXQgYmxvY2tpbmdfYmluZCBmZCBhZGRyID1cbiAgICBMd3QucmV0dXJuIChMd3RfdW5peC5WZXJzaW9uZWQuYmluZF8xIGZkIGFkZHIpIFtAb2NhbWwud2FybmluZyBcIi0zXCJdXG4gIGluXG4gIGxldCBmIF9hZGRyIGMgPVxuICAgIGYgYztcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgaW5cblxuICBsZXQgc2VydmVyLCBzZXJ2ZXJfc3RhcnRlZCA9XG4gICAgZXN0YWJsaXNoX3NlcnZlcl93aXRoX2NsaWVudF9hZGRyZXNzX2dlbmVyaWNcbiAgICAgIGJsb2NraW5nX2JpbmQgP2ZkID9idWZmZXJfc2l6ZSA/YmFja2xvZyB+bm9fY2xvc2U6dHJ1ZSBzb2NrYWRkciBmXG4gIGluXG5cbiAgKCogUG9sbCBmb3IgZXhjZXB0aW9ucyBpbiBzZXJ2ZXIgc3RhcnR1cCB0aGF0IG1heSBoYXZlIG9jY3VycmVkIHN5bmNocm9ub3VzbHkuXG4gICAgIFRoaXMgZW11bGF0ZXMgYW4gb2xkLCBkZXByZWNhdGVkIGJlaGF2aW9yLiAqKVxuICBMd3QuaWdub3JlX3Jlc3VsdCBzZXJ2ZXJfc3RhcnRlZDtcbiAgc2VydmVyXG5cbmxldCBpZ25vcmVfY2xvc2UgY2ggPVxuICBpZ25vcmUgKGNsb3NlIGNoKVxuXG5sZXQgbWFrZV9zdHJlYW0gZiBsYXp5X2ljID1cbiAgbGV0IGxhenlfaWMgPVxuICAgIGxhenkoTGF6eS5mb3JjZSBsYXp5X2ljID4+PSBmdW4gaWMgLT5cbiAgICAgICAgIEdjLmZpbmFsaXNlIGlnbm9yZV9jbG9zZSBpYztcbiAgICAgICAgIEx3dC5yZXR1cm4gaWMpXG4gIGluXG4gIEx3dF9zdHJlYW0uZnJvbSAoZnVuIF8gLT5cbiAgICBMYXp5LmZvcmNlIGxhenlfaWMgPj49IGZ1biBpYyAtPlxuICAgIGYgaWMgPj49IGZ1biB4IC0+XG4gICAgaWYgeCA9IE5vbmUgdGhlblxuICAgICAgY2xvc2UgaWMgPj49IGZ1biAoKSAtPlxuICAgICAgTHd0LnJldHVybiB4XG4gICAgZWxzZVxuICAgICAgTHd0LnJldHVybiB4KVxuXG5sZXQgbGluZXNfb2ZfZmlsZSBmaWxlbmFtZSA9XG4gIG1ha2Vfc3RyZWFtIHJlYWRfbGluZV9vcHQgKGxhenkob3Blbl9maWxlIH5tb2RlOmlucHV0IGZpbGVuYW1lKSlcblxubGV0IGxpbmVzX3RvX2ZpbGUgZmlsZW5hbWUgbGluZXMgPVxuICB3aXRoX2ZpbGUgfm1vZGU6b3V0cHV0IGZpbGVuYW1lIChmdW4gb2MgLT4gd3JpdGVfbGluZXMgb2MgbGluZXMpXG5cbmxldCBjaGFyc19vZl9maWxlIGZpbGVuYW1lID1cbiAgbWFrZV9zdHJlYW0gcmVhZF9jaGFyX29wdCAobGF6eShvcGVuX2ZpbGUgfm1vZGU6aW5wdXQgZmlsZW5hbWUpKVxuXG5sZXQgY2hhcnNfdG9fZmlsZSBmaWxlbmFtZSBjaGFycyA9XG4gIHdpdGhfZmlsZSB+bW9kZTpvdXRwdXQgZmlsZW5hbWUgKGZ1biBvYyAtPiB3cml0ZV9jaGFycyBvYyBjaGFycylcblxubGV0IGhleGR1bXBfc3RyZWFtIG9jIHN0cmVhbSA9IHdyaXRlX2xpbmVzIG9jIChMd3Rfc3RyZWFtLmhleGR1bXAgc3RyZWFtKVxubGV0IGhleGR1bXAgb2MgYnVmID0gaGV4ZHVtcF9zdHJlYW0gb2MgKEx3dF9zdHJlYW0ub2Zfc3RyaW5nIGJ1ZilcblxubGV0IHNldF9kZWZhdWx0X2J1ZmZlcl9zaXplIHNpemUgPVxuICBjaGVja19idWZmZXJfc2l6ZSBcInNldF9kZWZhdWx0X2J1ZmZlcl9zaXplXCIgc2l6ZTtcbiAgZGVmYXVsdF9idWZmZXJfc2l6ZSA6PSBzaXplXG5sZXQgZGVmYXVsdF9idWZmZXJfc2l6ZSBfID0gIWRlZmF1bHRfYnVmZmVyX3NpemVcblxubW9kdWxlIFZlcnNpb25lZCA9XG5zdHJ1Y3RcbiAgbGV0IGVzdGFibGlzaF9zZXJ2ZXJfMSA9IGVzdGFibGlzaF9zZXJ2ZXJfZGVwcmVjYXRlZFxuICBsZXQgZXN0YWJsaXNoX3NlcnZlcl8yID0gZXN0YWJsaXNoX3NlcnZlclxuXG4gIGxldCBzaHV0ZG93bl9zZXJ2ZXJfMSA9IHNodXRkb3duX3NlcnZlcl9kZXByZWNhdGVkXG4gIGxldCBzaHV0ZG93bl9zZXJ2ZXJfMiA9IHNodXRkb3duX3NlcnZlclxuZW5kXG4iLCIjIDEgXCJzcmMvdW5peC9sd3RfcHJvY2Vzcy5jcHBvLm1sXCJcbigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxub3BlbiBMd3QuSW5maXhcblxudHlwZSBjb21tYW5kID0gc3RyaW5nICogc3RyaW5nIGFycmF5XG5cbmxldCBzaGVsbCA9XG4gIGlmIFN5cy53aW4zMiB0aGVuXG4gICAgZnVuIGNtZCAtPiAoXCJcIiwgW3xcImNtZC5leGVcIjsgXCIvY1wiOyBcIlxcMDAwXCIgXiBjbWR8XSlcbiAgZWxzZVxuICAgIGZ1biBjbWQgLT4gKFwiXCIsIFt8XCIvYmluL3NoXCI7IFwiLWNcIjsgY21kfF0pXG5cbnR5cGUgcmVkaXJlY3Rpb24gPVxuICBbIGBLZWVwXG4gIHwgYERldl9udWxsXG4gIHwgYENsb3NlXG4gIHwgYEZEX2NvcHkgb2YgVW5peC5maWxlX2Rlc2NyXG4gIHwgYEZEX21vdmUgb2YgVW5peC5maWxlX2Rlc2NyIF1cblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBPUy1kZXBlbmRlbnQgY29tbWFuZCBzcGF3bmluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG50eXBlIHByb2MgPSB7XG4gIGlkIDogaW50O1xuICAoKiBUaGUgcHJvY2VzcyBpZC4gKilcbiAgZmQgOiBVbml4LmZpbGVfZGVzY3I7XG4gICgqIEEgaGFuZGxlIG9uIHdpbmRvd3MsIGFuZCBhIGR1bW15IHZhbHVlIG9mIFVuaXguICopXG59XG5cbmxldCB3aW4zMl9nZXRfZmQgZmQgcmVkaXJlY3Rpb24gPVxuICBtYXRjaCByZWRpcmVjdGlvbiB3aXRoXG4gIHwgYEtlZXAgLT5cbiAgICBTb21lIGZkXG4gIHwgYERldl9udWxsIC0+XG4gICAgU29tZSAoVW5peC5vcGVuZmlsZSBcIm51bFwiIFtVbml4Lk9fUkRXUjsgVW5peC5PX0tFRVBFWEVDXSAwbzY2NilcbiAgfCBgQ2xvc2UgLT5cbiAgICBOb25lXG4gIHwgYEZEX2NvcHkgZmQnIC0+XG4gICAgU29tZSBmZCdcbiAgfCBgRkRfbW92ZSBmZCcgLT5cbiAgICBTb21lIGZkJ1xuXG5leHRlcm5hbCB3aW4zMl9jcmVhdGVfcHJvY2VzcyA6XG4gIHN0cmluZyBvcHRpb24gLT4gc3RyaW5nIC0+IHN0cmluZyBvcHRpb24gLT4gc3RyaW5nIG9wdGlvbiAtPlxuICAoVW5peC5maWxlX2Rlc2NyIG9wdGlvbiAqIFVuaXguZmlsZV9kZXNjciBvcHRpb24gKiBVbml4LmZpbGVfZGVzY3Igb3B0aW9uKSAtPlxuICAgIHByb2MgPSBcImx3dF9wcm9jZXNzX2NyZWF0ZV9wcm9jZXNzXCJcblxubGV0IHdpbjMyX3F1b3RlIGFyZyA9XG4gIGlmIFN0cmluZy5sZW5ndGggYXJnID4gMCAmJiBhcmcuWzBdID0gJ1xcMDAwJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBhcmcgMSAoU3RyaW5nLmxlbmd0aCBhcmcgLSAxKVxuICBlbHNlXG4gICAgRmlsZW5hbWUucXVvdGUgYXJnXG5cbmxldCB3aW4zMl9zcGF3blxuICAgID9jd2RcbiAgICA/KHN0ZGluOnJlZGlyZWN0aW9uPWBLZWVwKVxuICAgID8oc3Rkb3V0OnJlZGlyZWN0aW9uPWBLZWVwKVxuICAgID8oc3RkZXJyOnJlZGlyZWN0aW9uPWBLZWVwKVxuICAgIChwcm9nLCBhcmdzKSBlbnZcbiAgPVxuICBsZXQgY21kbGluZSA9IFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHdpbjMyX3F1b3RlIChBcnJheS50b19saXN0IGFyZ3MpKSBpblxuICBsZXQgZW52ID1cbiAgICBtYXRjaCBlbnYgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgTm9uZVxuICAgIHwgU29tZSBlbnYgLT5cbiAgICAgIGxldCBsZW4gPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBsZW4gc3RyIC0+IFN0cmluZy5sZW5ndGggc3RyICsgbGVuICsgMSkgMSBlbnYgaW5cbiAgICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgICBsZXQgb2ZzID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0XG4gICAgICAgICAgKGZ1biBvZnMgc3RyIC0+XG4gICAgICAgICAgICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgICAgICAgICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzIG9mcyBsZW47XG4gICAgICAgICAgICAgQnl0ZXMuc2V0IHJlcyAob2ZzICsgbGVuKSAnXFwwMDAnO1xuICAgICAgICAgICAgIG9mcyArIGxlbiArIDEpXG4gICAgICAgICAgMCBlbnZcbiAgICAgIGluXG4gICAgICBCeXRlcy5zZXQgcmVzIG9mcyAnXFwwMDAnO1xuICAgICAgU29tZSAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXMpXG4gIGluXG4gIGxldCBzdGRpbl9mZCAgPSB3aW4zMl9nZXRfZmQgVW5peC5zdGRpbiBzdGRpblxuICBhbmQgc3Rkb3V0X2ZkID0gd2luMzJfZ2V0X2ZkIFVuaXguc3Rkb3V0IHN0ZG91dFxuICBhbmQgc3RkZXJyX2ZkID0gd2luMzJfZ2V0X2ZkIFVuaXguc3RkZXJyIHN0ZGVyciBpblxuICBsZXQgcHJvYyA9XG4gICAgd2luMzJfY3JlYXRlX3Byb2Nlc3NcbiAgICAgIChpZiBwcm9nID0gXCJcIiB0aGVuIE5vbmUgZWxzZSBTb21lIHByb2cpIGNtZGxpbmUgZW52IGN3ZFxuICAgICAgKHN0ZGluX2ZkLCBzdGRvdXRfZmQsIHN0ZGVycl9mZClcbiAgaW5cbiAgbGV0IGNsb3NlIGZkIGZkJyA9XG4gICAgbWF0Y2ggZmQgd2l0aFxuICAgIHwgYEZEX21vdmUgXyB8IGBEZXZfbnVsbCAtPlxuICAgICAgVW5peC5jbG9zZSAobWF0Y2ggZmQnIHdpdGggU29tZSBmZCcgLT4gZmQnIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG4gICAgfCBfIC0+ICgpXG4gIGluXG4gIGNsb3NlIHN0ZGluIHN0ZGluX2ZkO1xuICBjbG9zZSBzdGRvdXQgc3Rkb3V0X2ZkO1xuICBjbG9zZSBzdGRlcnIgc3RkZXJyX2ZkO1xuICBwcm9jXG5cbmV4dGVybmFsIHdpbjMyX3dhaXRfam9iIDogVW5peC5maWxlX2Rlc2NyIC0+IGludCBMd3RfdW5peC5qb2IgPVxuICBcImx3dF9wcm9jZXNzX3dhaXRfam9iXCJcblxubGV0IHdpbjMyX3dhaXRwcm9jIHByb2MgPVxuICBMd3RfdW5peC5ydW5fam9iICh3aW4zMl93YWl0X2pvYiBwcm9jLmZkKSA+Pj0gZnVuIGNvZGUgLT5cbiAgTHd0LnJldHVyblxuICAgIChwcm9jLmlkLFxuICAgICBMd3RfdW5peC5XRVhJVEVEIGNvZGUsXG4gICAgIHtMd3RfdW5peC5ydV91dGltZSA9IDAuOyBMd3RfdW5peC5ydV9zdGltZSA9IDAufSlcblxuZXh0ZXJuYWwgd2luMzJfdGVybWluYXRlX3Byb2Nlc3MgOiBVbml4LmZpbGVfZGVzY3IgLT4gaW50IC0+IHVuaXQgPVxuICBcImx3dF9wcm9jZXNzX3Rlcm1pbmF0ZV9wcm9jZXNzXCJcblxubGV0IHdpbjMyX3Rlcm1pbmF0ZSBwcm9jID1cbiAgd2luMzJfdGVybWluYXRlX3Byb2Nlc3MgcHJvYy5mZCAxXG5cbmxldCB1bml4X3JlZGlyZWN0IGZkIHJlZGlyZWN0aW9uID0gbWF0Y2ggcmVkaXJlY3Rpb24gd2l0aFxuICB8IGBLZWVwIC0+XG4gICAgKClcbiAgfCBgRGV2X251bGwgLT5cbiAgICBsZXQgZGV2X251bGwgPSBVbml4Lm9wZW5maWxlIFwiL2Rldi9udWxsXCIgW1VuaXguT19SRFdSOyBVbml4Lk9fS0VFUEVYRUNdIDBvNjY2IGluXG4gICAgVW5peC5kdXAyIH5jbG9leGVjOmZhbHNlIGRldl9udWxsIGZkO1xuICAgIFVuaXguY2xvc2UgZGV2X251bGxcbiAgfCBgQ2xvc2UgLT5cbiAgICBVbml4LmNsb3NlIGZkXG4gIHwgYEZEX2NvcHkgZmQnIC0+XG4gICAgVW5peC5kdXAyIH5jbG9leGVjOmZhbHNlIGZkJyBmZFxuICB8IGBGRF9tb3ZlIGZkJyAtPlxuICAgIFVuaXguZHVwMiB+Y2xvZXhlYzpmYWxzZSBmZCcgZmQ7XG4gICAgVW5peC5jbG9zZSBmZCdcblxuIyAxMzcgXCJzcmMvdW5peC9sd3RfcHJvY2Vzcy5jcHBvLm1sXCJcbmV4dGVybmFsIHVuaXhfZXhpdCA6IGludCAtPiAnYSA9IFwiY2FtbF91bml4X2V4aXRcIlxuXG4jIDE0MiBcInNyYy91bml4L2x3dF9wcm9jZXNzLmNwcG8ubWxcIlxubGV0IHVuaXhfc3Bhd25cbiAgICA/Y3dkXG4gICAgPyhzdGRpbjpyZWRpcmVjdGlvbj1gS2VlcClcbiAgICA/KHN0ZG91dDpyZWRpcmVjdGlvbj1gS2VlcClcbiAgICA/KHN0ZGVycjpyZWRpcmVjdGlvbj1gS2VlcClcbiAgICAocHJvZywgYXJncykgZW52XG4gID1cbiAgbGV0IHByb2cgPSBpZiBwcm9nID0gXCJcIiAmJiBBcnJheS5sZW5ndGggYXJncyA+IDAgdGhlbiBhcmdzLigwKSBlbHNlIHByb2cgaW5cbiAgbWF0Y2ggTHd0X3VuaXguZm9yayAoKSB3aXRoXG4gIHwgMCAtPlxuICAgIHVuaXhfcmVkaXJlY3QgVW5peC5zdGRpbiBzdGRpbjtcbiAgICB1bml4X3JlZGlyZWN0IFVuaXguc3Rkb3V0IHN0ZG91dDtcbiAgICB1bml4X3JlZGlyZWN0IFVuaXguc3RkZXJyIHN0ZGVycjtcbiAgICBiZWdpblxuICAgICAgdHJ5XG4gICAgICAgIGJlZ2luIG1hdGNoIGN3ZCB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIGRpciAtPlxuICAgICAgICAgICAgU3lzLmNoZGlyIGRpclxuICAgICAgICBlbmQ7XG4gICAgICAgIG1hdGNoIGVudiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIFVuaXguZXhlY3ZwIHByb2cgYXJnc1xuICAgICAgICB8IFNvbWUgZW52IC0+XG4gICAgICAgICAgVW5peC5leGVjdnBlIHByb2cgYXJncyBlbnZcbiAgICAgIHdpdGggXyAtPlxuICAgICAgICAoKiBEbyBub3QgcnVuIGF0X2V4aXQgaG9va3MgKilcbiAgICAgICAgdW5peF9leGl0IDEyN1xuICAgIGVuZFxuICB8IGlkIC0+XG4gICAgbGV0IGNsb3NlID0gZnVuY3Rpb25cbiAgICAgIHwgYEZEX21vdmUgZmQgLT5cbiAgICAgICAgVW5peC5jbG9zZSBmZFxuICAgICAgfCBfIC0+XG4gICAgICAgICgpXG4gICAgaW5cbiAgICBjbG9zZSBzdGRpbjtcbiAgICBjbG9zZSBzdGRvdXQ7XG4gICAgY2xvc2Ugc3RkZXJyO1xuICAgIHtpZDsgZmQgPSBVbml4LnN0ZGlufVxuXG5sZXQgdW5peF93YWl0cHJvYyBwcm9jID0gTHd0X3VuaXgud2FpdDQgW10gcHJvYy5pZFxuXG5sZXQgdW5peF90ZXJtaW5hdGUgcHJvYyA9XG4gIFVuaXgua2lsbCBwcm9jLmlkIFN5cy5zaWdraWxsXG5cbmxldCBzcGF3biAgICAgPSBpZiBTeXMud2luMzIgdGhlbiB3aW4zMl9zcGF3biAgICAgZWxzZSB1bml4X3NwYXduXG5sZXQgd2FpdHByb2MgID0gaWYgU3lzLndpbjMyIHRoZW4gd2luMzJfd2FpdHByb2MgIGVsc2UgdW5peF93YWl0cHJvY1xubGV0IHRlcm1pbmF0ZSA9IGlmIFN5cy53aW4zMiB0aGVuIHdpbjMyX3Rlcm1pbmF0ZSBlbHNlIHVuaXhfdGVybWluYXRlXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgT2JqZWN0cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxudHlwZSBzdGF0ZSA9XG4gIHwgUnVubmluZ1xuICB8IEV4aXRlZCBvZiBVbml4LnByb2Nlc3Nfc3RhdHVzXG5cbmxldCBzdGF0dXMgKF9waWQsIHN0YXR1cywgX3J1c2FnZSkgPSBzdGF0dXNcbmxldCBydXNhZ2UgKF9waWQsIF9zdGF0dXMsIHJ1c2FnZSkgPSBydXNhZ2VcblxuZXh0ZXJuYWwgY2FzdF9jaGFuIDogJ2EgTHd0X2lvLmNoYW5uZWwgLT4gdW5pdCBMd3RfaW8uY2hhbm5lbCA9IFwiJWlkZW50aXR5XCJcbigqIFRyYW5zZm9ybSBhIGNoYW5uZWwgaW50byBhIGNoYW5uZWwgdGhhdCBvbmx5IHN1cHBvcnQgY2xvc2luZy4gKilcblxubGV0IGlnbm9yZV9jbG9zZSBjaGFuID0gaWdub3JlIChMd3RfaW8uY2xvc2UgY2hhbilcblxuY2xhc3MgdmlydHVhbCBjb21tb24gdGltZW91dCBwcm9jIGNoYW5uZWxzID1cbiAgbGV0IHdhaXQgPSB3YWl0cHJvYyBwcm9jIGluXG4gIG9iamVjdChzZWxmKVxuICAgIHZhbCBtdXRhYmxlIGNsb3NlZCA9IGZhbHNlXG5cbiAgICBtZXRob2QgcGlkID0gcHJvYy5pZFxuXG4gICAgbWV0aG9kIHN0YXRlID1cbiAgICAgIG1hdGNoIEx3dC5wb2xsIHdhaXQgd2l0aFxuICAgICAgfCBOb25lIC0+IFJ1bm5pbmdcbiAgICAgIHwgU29tZSAoX3BpZCwgc3RhdHVzLCBfcnVzYWdlKSAtPiBFeGl0ZWQgc3RhdHVzXG5cbiAgICBtZXRob2Qga2lsbCBzaWdudW0gPVxuICAgICAgaWYgTHd0LnN0YXRlIHdhaXQgPSBMd3QuU2xlZXAgdGhlblxuICAgICAgICBVbml4LmtpbGwgcHJvYy5pZCBzaWdudW1cblxuICAgIG1ldGhvZCB0ZXJtaW5hdGUgPVxuICAgICAgaWYgTHd0LnN0YXRlIHdhaXQgPSBMd3QuU2xlZXAgdGhlblxuICAgICAgICB0ZXJtaW5hdGUgcHJvY1xuXG4gICAgbWV0aG9kIGNsb3NlID1cbiAgICAgIGlmIGNsb3NlZCB0aGVuIHNlbGYjc3RhdHVzXG4gICAgICBlbHNlIChcbiAgICAgICAgY2xvc2VkIDwtIHRydWU7XG4gICAgICAgIEx3dC5wcm90ZWN0ZWQgKEx3dC5qb2luIChMaXN0Lm1hcCBMd3RfaW8uY2xvc2UgY2hhbm5lbHMpKVxuICAgICAgICA+Pj0gZnVuICgpIC0+IHNlbGYjc3RhdHVzXG4gICAgICApXG4gICAgbWV0aG9kIHN0YXR1cyA9IEx3dC5wcm90ZWN0ZWQgd2FpdCA+fD0gc3RhdHVzXG4gICAgbWV0aG9kIHJ1c2FnZSA9IEx3dC5wcm90ZWN0ZWQgd2FpdCA+fD0gcnVzYWdlXG5cbiAgICBpbml0aWFsaXplclxuICAgICAgKCogRW5zdXJlIGNoYW5uZWxzIGFyZSBjbG9zZWQgd2hlbiBubyBsb25nZXIgdXNlZC4gKilcbiAgICAgIExpc3QuaXRlciAoR2MuZmluYWxpc2UgaWdub3JlX2Nsb3NlKSBjaGFubmVscztcbiAgICAgICgqIEhhbmRsZSB0aW1lb3V0LiAqKVxuICAgICAgbWF0Y2ggdGltZW91dCB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgKClcbiAgICAgIHwgU29tZSBkdCAtPlxuICAgICAgICBpZ25vcmUgKFxuICAgICAgICAgICgqIElnbm9yZSBlcnJvcnMgc2luY2UgdGhleSBjYW4gYmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICBzZWxmI2Nsb3NlLiAqKVxuICAgICAgICAgIEx3dC50cnlfYmluZFxuICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgTHd0LmNob29zZSBbKEx3dF91bml4LnNsZWVwIGR0ID4+PSBmdW4gKCkgLT4gTHd0LnJldHVybl9mYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAod2FpdCA+Pj0gZnVuIF8gLT4gTHd0LnJldHVybl90cnVlKV0pXG4gICAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgICAgICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICAgICAgICBzZWxmI3Rlcm1pbmF0ZTtcbiAgICAgICAgICAgICAgICBzZWxmI2Nsb3NlID4+PSBmdW4gXyAtPiBMd3QucmV0dXJuX3VuaXQpXG4gICAgICAgICAgICAoZnVuIF8gLT5cbiAgICAgICAgICAgICAgICgqIFRoZSBleGNlcHRpb24gaXMgZHJvcHBlZCBiZWNhdXNlIGl0IGNhbiBiZVxuICAgICAgICAgICAgICAgICAgb2J0YWluZWQgd2l0aCBzZWxmI2Nsb3NlLiAqKVxuICAgICAgICAgICAgICAgTHd0LnJldHVybl91bml0KVxuICAgICAgICApXG4gIGVuZFxuXG5jbGFzcyBwcm9jZXNzX25vbmUgP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgY21kID1cbiAgbGV0IHByb2MgPSBzcGF3biBjbWQgZW52ID9jd2QgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBpblxuICBvYmplY3RcbiAgICBpbmhlcml0IGNvbW1vbiB0aW1lb3V0IHByb2MgW11cbiAgZW5kXG5cbmNsYXNzIHByb2Nlc3NfaW4gP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRpbiA/c3RkZXJyIGNtZCA9XG4gIGxldCBzdGRvdXRfciwgc3Rkb3V0X3cgPSBMd3RfdW5peC5waXBlX2luIH5jbG9leGVjOnRydWUgKCkgaW5cbiAgbGV0IHByb2MgPSBzcGF3biBjbWQgZW52ID9jd2QgP3N0ZGluIH5zdGRvdXQ6KGBGRF9tb3ZlIHN0ZG91dF93KSA/c3RkZXJyIGluXG4gIGxldCBzdGRvdXQgPSBMd3RfaW8ub2ZfZmQgfm1vZGU6THd0X2lvLmlucHV0IHN0ZG91dF9yIGluXG4gIG9iamVjdFxuICAgIGluaGVyaXQgY29tbW9uIHRpbWVvdXQgcHJvYyBbY2FzdF9jaGFuIHN0ZG91dF1cbiAgICBtZXRob2Qgc3Rkb3V0ID0gc3Rkb3V0XG4gIGVuZFxuXG5jbGFzcyBwcm9jZXNzX291dCA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZG91dCA/c3RkZXJyIGNtZCA9XG4gIGxldCBzdGRpbl9yLCBzdGRpbl93ID0gTHd0X3VuaXgucGlwZV9vdXQgfmNsb2V4ZWM6dHJ1ZSAoKSBpblxuICBsZXQgcHJvYyA9IHNwYXduIGNtZCBlbnYgP2N3ZCB+c3RkaW46KGBGRF9tb3ZlIHN0ZGluX3IpID9zdGRvdXQgP3N0ZGVyciBpblxuICBsZXQgc3RkaW4gPSBMd3RfaW8ub2ZfZmQgfm1vZGU6THd0X2lvLm91dHB1dCBzdGRpbl93IGluXG4gIG9iamVjdFxuICAgIGluaGVyaXQgY29tbW9uIHRpbWVvdXQgcHJvYyBbY2FzdF9jaGFuIHN0ZGluXVxuICAgIG1ldGhvZCBzdGRpbiA9IHN0ZGluXG4gIGVuZFxuXG5jbGFzcyBwcm9jZXNzID90aW1lb3V0ID9lbnYgP2N3ZCA/c3RkZXJyIGNtZCA9XG4gIGxldCBzdGRpbl9yLCBzdGRpbl93ID0gTHd0X3VuaXgucGlwZV9vdXQgfmNsb2V4ZWM6dHJ1ZSAoKVxuICBhbmQgc3Rkb3V0X3IsIHN0ZG91dF93ID0gTHd0X3VuaXgucGlwZV9pbiB+Y2xvZXhlYzp0cnVlICgpIGluXG4gIGxldCBwcm9jID1cbiAgICBzcGF3blxuICAgICAgY21kIGVudiA/Y3dkIH5zdGRpbjooYEZEX21vdmUgc3RkaW5fcikgfnN0ZG91dDooYEZEX21vdmUgc3Rkb3V0X3cpID9zdGRlcnJcbiAgaW5cbiAgbGV0IHN0ZGluID0gTHd0X2lvLm9mX2ZkIH5tb2RlOkx3dF9pby5vdXRwdXQgc3RkaW5fd1xuICBhbmQgc3Rkb3V0ID0gTHd0X2lvLm9mX2ZkIH5tb2RlOkx3dF9pby5pbnB1dCBzdGRvdXRfciBpblxuICBvYmplY3RcbiAgICBpbmhlcml0IGNvbW1vbiB0aW1lb3V0IHByb2MgW2Nhc3RfY2hhbiBzdGRpbjsgY2FzdF9jaGFuIHN0ZG91dF1cbiAgICBtZXRob2Qgc3RkaW4gPSBzdGRpblxuICAgIG1ldGhvZCBzdGRvdXQgPSBzdGRvdXRcbiAgZW5kXG5cbmNsYXNzIHByb2Nlc3NfZnVsbCA/dGltZW91dCA/ZW52ID9jd2QgY21kID1cbiAgbGV0IHN0ZGluX3IsIHN0ZGluX3cgPSBMd3RfdW5peC5waXBlX291dCB+Y2xvZXhlYzp0cnVlICgpXG4gIGFuZCBzdGRvdXRfciwgc3Rkb3V0X3cgPSBMd3RfdW5peC5waXBlX2luIH5jbG9leGVjOnRydWUgKClcbiAgYW5kIHN0ZGVycl9yLCBzdGRlcnJfdyA9IEx3dF91bml4LnBpcGVfaW4gfmNsb2V4ZWM6dHJ1ZSAoKSBpblxuICBsZXQgcHJvYyA9XG4gICAgc3Bhd25cbiAgICAgIGNtZCBlbnYgP2N3ZFxuICAgICAgfnN0ZGluOihgRkRfbW92ZSBzdGRpbl9yKVxuICAgICAgfnN0ZG91dDooYEZEX21vdmUgc3Rkb3V0X3cpXG4gICAgICB+c3RkZXJyOihgRkRfbW92ZSBzdGRlcnJfdylcbiAgaW5cbiAgbGV0IHN0ZGluID0gTHd0X2lvLm9mX2ZkIH5tb2RlOkx3dF9pby5vdXRwdXQgc3RkaW5fd1xuICBhbmQgc3Rkb3V0ID0gTHd0X2lvLm9mX2ZkIH5tb2RlOkx3dF9pby5pbnB1dCBzdGRvdXRfclxuICBhbmQgc3RkZXJyID0gTHd0X2lvLm9mX2ZkIH5tb2RlOkx3dF9pby5pbnB1dCBzdGRlcnJfciBpblxuICBvYmplY3RcbiAgICBpbmhlcml0XG4gICAgICBjb21tb24gdGltZW91dCBwcm9jIFtjYXN0X2NoYW4gc3RkaW47IGNhc3RfY2hhbiBzdGRvdXQ7IGNhc3RfY2hhbiBzdGRlcnJdXG4gICAgbWV0aG9kIHN0ZGluID0gc3RkaW5cbiAgICBtZXRob2Qgc3Rkb3V0ID0gc3Rkb3V0XG4gICAgbWV0aG9kIHN0ZGVyciA9IHN0ZGVyclxuICBlbmRcblxubGV0IG9wZW5fcHJvY2Vzc19ub25lID90aW1lb3V0ID9lbnYgP2N3ZCA/c3RkaW4gP3N0ZG91dCA/c3RkZXJyIGNtZCA9XG4gIG5ldyBwcm9jZXNzX25vbmUgP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgY21kXG5cbmxldCBvcGVuX3Byb2Nlc3NfaW4gP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRpbiA/c3RkZXJyIGNtZCA9XG4gIG5ldyBwcm9jZXNzX2luID90aW1lb3V0ID9lbnYgP2N3ZCA/c3RkaW4gP3N0ZGVyciBjbWRcblxubGV0IG9wZW5fcHJvY2Vzc19vdXQgP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRvdXQgP3N0ZGVyciBjbWQgPVxuICBuZXcgcHJvY2Vzc19vdXQgP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRvdXQgP3N0ZGVyciBjbWRcblxubGV0IG9wZW5fcHJvY2VzcyA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGVyciBjbWQgPVxuICBuZXcgcHJvY2VzcyA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGVyciBjbWRcblxubGV0IG9wZW5fcHJvY2Vzc19mdWxsID90aW1lb3V0ID9lbnYgP2N3ZCBjbWQgPVxuICBuZXcgcHJvY2Vzc19mdWxsID90aW1lb3V0ID9lbnYgP2N3ZCBjbWRcblxubGV0IG1ha2Vfd2l0aCBiYWNrZW5kID90aW1lb3V0ID9lbnYgP2N3ZCBjbWQgZiA9XG4gIGxldCBwcm9jZXNzID0gYmFja2VuZCA/dGltZW91dCA/ZW52ID9jd2QgY21kIGluXG4gIEx3dC5maW5hbGl6ZVxuICAgIChmdW4gKCkgLT4gZiBwcm9jZXNzKVxuICAgIChmdW4gKCkgLT5cbiAgICAgICBwcm9jZXNzI2Nsb3NlID4+PSBmdW4gXyAtPlxuICAgICAgIEx3dC5yZXR1cm5fdW5pdClcblxubGV0IHdpdGhfcHJvY2Vzc19ub25lID90aW1lb3V0ID9lbnYgP2N3ZCA/c3RkaW4gP3N0ZG91dCA/c3RkZXJyIGNtZCBmID1cbiAgbWFrZV93aXRoIChvcGVuX3Byb2Nlc3Nfbm9uZSA/c3RkaW4gP3N0ZG91dCA/c3RkZXJyKSA/dGltZW91dCA/ZW52ID9jd2QgY21kIGZcblxubGV0IHdpdGhfcHJvY2Vzc19pbiA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGluID9zdGRlcnIgY21kIGYgPVxuICBtYWtlX3dpdGggKG9wZW5fcHJvY2Vzc19pbiA/c3RkaW4gP3N0ZGVycikgP3RpbWVvdXQgP2VudiA/Y3dkIGNtZCBmXG5cbmxldCB3aXRoX3Byb2Nlc3Nfb3V0ID90aW1lb3V0ID9lbnYgP2N3ZCA/c3Rkb3V0ID9zdGRlcnIgY21kIGYgPVxuICBtYWtlX3dpdGggKG9wZW5fcHJvY2Vzc19vdXQgP3N0ZG91dCA/c3RkZXJyKSA/dGltZW91dCA/ZW52ID9jd2QgY21kIGZcblxubGV0IHdpdGhfcHJvY2VzcyA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGVyciBjbWQgZiA9XG4gIG1ha2Vfd2l0aCAob3Blbl9wcm9jZXNzID9zdGRlcnIpID90aW1lb3V0ID9lbnYgP2N3ZCBjbWQgZlxuXG5sZXQgd2l0aF9wcm9jZXNzX2Z1bGwgP3RpbWVvdXQgP2VudiA/Y3dkIGNtZCBmID1cbiAgbWFrZV93aXRoIG9wZW5fcHJvY2Vzc19mdWxsID90aW1lb3V0ID9lbnYgP2N3ZCBjbWQgZlxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IEhpZ2gtbGV2ZWwgZnVuY3Rpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBleGVjID90aW1lb3V0ID9lbnYgP2N3ZCA/c3RkaW4gP3N0ZG91dCA/c3RkZXJyIGNtZCA9XG4gIChvcGVuX3Byb2Nlc3Nfbm9uZSA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBjbWQpI2Nsb3NlXG5cbmxldCBpZ25vcmVfY2xvc2UgY2ggPVxuICBpZ25vcmUgKEx3dF9pby5jbG9zZSBjaClcblxubGV0IHJlYWRfb3B0IHJlYWQgaWMgPVxuICBMd3QuY2F0Y2hcbiAgICAoZnVuICgpIC0+IHJlYWQgaWMgPnw9IGZ1biB4IC0+IFNvbWUgeClcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgVW5peC5Vbml4X2Vycm9yIChVbml4LkVQSVBFLCBfLCBfKSB8IEVuZF9vZl9maWxlIC0+XG4gICAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICAgICAgfCBleG4gLT4gTHd0LnJlcmFpc2UgZXhuKSBbQG9jYW1sLndhcm5pbmcgXCItNFwiXVxuXG5sZXQgcmVjdl9jaGFycyBwciA9XG4gIGxldCBpYyA9IHByI3N0ZG91dCBpblxuICBHYy5maW5hbGlzZSBpZ25vcmVfY2xvc2UgaWM7XG4gIEx3dF9zdHJlYW0uZnJvbSAoZnVuIF8gLT5cbiAgICByZWFkX29wdCBMd3RfaW8ucmVhZF9jaGFyIGljID4+PSBmdW4geCAtPlxuICAgIGlmIHggPSBOb25lIHRoZW4gYmVnaW5cbiAgICAgIEx3dF9pby5jbG9zZSBpYyA+Pj0gZnVuICgpIC0+XG4gICAgICBMd3QucmV0dXJuIHhcbiAgICBlbmQgZWxzZVxuICAgICAgTHd0LnJldHVybiB4KVxuXG5sZXQgcmVjdl9saW5lcyBwciA9XG4gIGxldCBpYyA9IHByI3N0ZG91dCBpblxuICBHYy5maW5hbGlzZSBpZ25vcmVfY2xvc2UgaWM7XG4gIEx3dF9zdHJlYW0uZnJvbSAoZnVuIF8gLT5cbiAgICByZWFkX29wdCBMd3RfaW8ucmVhZF9saW5lIGljID4+PSBmdW4geCAtPlxuICAgIGlmIHggPSBOb25lIHRoZW4gYmVnaW5cbiAgICAgIEx3dF9pby5jbG9zZSBpYyA+Pj0gZnVuICgpIC0+XG4gICAgICBMd3QucmV0dXJuIHhcbiAgICBlbmQgZWxzZVxuICAgICAgTHd0LnJldHVybiB4KVxuXG5sZXQgcmVjdiBwciA9XG4gIGxldCBpYyA9IHByI3N0ZG91dCBpblxuICBMd3QuZmluYWxpemVcbiAgICAoZnVuICgpIC0+IEx3dF9pby5yZWFkIGljKVxuICAgIChmdW4gKCkgLT4gTHd0X2lvLmNsb3NlIGljKVxuXG5sZXQgcmVjdl9saW5lIHByID1cbiAgbGV0IGljID0gcHIjc3Rkb3V0IGluXG4gIEx3dC5maW5hbGl6ZVxuICAgIChmdW4gKCkgLT4gTHd0X2lvLnJlYWRfbGluZSBpYylcbiAgICAoZnVuICgpIC0+IEx3dF9pby5jbG9zZSBpYylcblxubGV0IHNlbmQgZiBwciBkYXRhID1cbiAgbGV0IG9jID0gcHIjc3RkaW4gaW5cbiAgTHd0LmZpbmFsaXplXG4gICAgKGZ1biAoKSAtPiBmIG9jIGRhdGEpXG4gICAgKGZ1biAoKSAtPiBMd3RfaW8uY2xvc2Ugb2MpXG5cbigqIFJlY2VpdmluZyAqKVxuXG5sZXQgcHJlYWQgP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRpbiA/c3RkZXJyIGNtZCA9XG4gIHJlY3YgKG9wZW5fcHJvY2Vzc19pbiA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGluID9zdGRlcnIgY21kKVxuXG5sZXQgcHJlYWRfY2hhcnMgP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRpbiA/c3RkZXJyIGNtZCA9XG4gIHJlY3ZfY2hhcnMgKG9wZW5fcHJvY2Vzc19pbiA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGluID9zdGRlcnIgY21kKVxuXG5sZXQgcHJlYWRfbGluZSA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGluID9zdGRlcnIgY21kID1cbiAgcmVjdl9saW5lIChvcGVuX3Byb2Nlc3NfaW4gP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRpbiA/c3RkZXJyIGNtZClcblxubGV0IHByZWFkX2xpbmVzID90aW1lb3V0ID9lbnYgP2N3ZCA/c3RkaW4gP3N0ZGVyciBjbWQgPVxuICByZWN2X2xpbmVzIChvcGVuX3Byb2Nlc3NfaW4gP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRpbiA/c3RkZXJyIGNtZClcblxuKCogU2VuZGluZyAqKVxuXG5sZXQgcHdyaXRlID90aW1lb3V0ID9lbnYgP2N3ZCA/c3Rkb3V0ID9zdGRlcnIgY21kIHRleHQgPVxuICBzZW5kIEx3dF9pby53cml0ZSAob3Blbl9wcm9jZXNzX291dCA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZG91dCA/c3RkZXJyIGNtZCkgdGV4dFxuXG5sZXQgcHdyaXRlX2NoYXJzID90aW1lb3V0ID9lbnYgP2N3ZCA/c3Rkb3V0ID9zdGRlcnIgY21kIGNoYXJzID1cbiAgc2VuZFxuICAgIEx3dF9pby53cml0ZV9jaGFyc1xuICAgIChvcGVuX3Byb2Nlc3Nfb3V0ID90aW1lb3V0ID9lbnYgP2N3ZCA/c3Rkb3V0ID9zdGRlcnIgY21kKVxuICAgIGNoYXJzXG5cbmxldCBwd3JpdGVfbGluZSA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZG91dCA/c3RkZXJyIGNtZCBsaW5lID1cbiAgc2VuZFxuICAgIEx3dF9pby53cml0ZV9saW5lXG4gICAgKG9wZW5fcHJvY2Vzc19vdXQgP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRvdXQgP3N0ZGVyciBjbWQpXG4gICAgbGluZVxuXG5sZXQgcHdyaXRlX2xpbmVzID90aW1lb3V0ID9lbnYgP2N3ZCA/c3Rkb3V0ID9zdGRlcnIgY21kIGxpbmVzID1cbiAgc2VuZFxuICAgIEx3dF9pby53cml0ZV9saW5lc1xuICAgIChvcGVuX3Byb2Nlc3Nfb3V0ID90aW1lb3V0ID9lbnYgP2N3ZCA/c3Rkb3V0ID9zdGRlcnIgY21kKVxuICAgIGxpbmVzXG5cbigqIE1hcHBpbmcgKilcblxudHlwZSAnYSBtYXBfc3RhdGUgPVxuICB8IEluaXRcbiAgfCBTYXZlIG9mICdhIG9wdGlvbiBMd3QudFxuICB8IERvbmVcblxuKCogTW9uaXRvciB0aGUgdGhyZWFkIFtzZW5kZXJdIGluIHRoZSBzdHJlYW0gW3N0XSBzbyB3cml0ZSBlcnJvcnMgYXJlXG4gICByZXBvcnRlZC4gKilcbmxldCBtb25pdG9yIHNlbmRlciBzdCA9XG4gIGxldCBzZW5kZXIgPSBzZW5kZXIgPnw9IGZ1biAoKSAtPiBOb25lIGluXG4gIGxldCBzdGF0ZSA9IHJlZiBJbml0IGluXG4gIEx3dF9zdHJlYW0uZnJvbVxuICAgIChmdW4gKCkgLT5cbiAgICAgICBtYXRjaCAhc3RhdGUgd2l0aFxuICAgICAgIHwgSW5pdCAtPlxuICAgICAgICAgbGV0IGdldHRlciA9IEx3dC5hcHBseSBMd3Rfc3RyZWFtLmdldCBzdCBpblxuICAgICAgICAgbGV0IHJlc3VsdCBfID1cbiAgICAgICAgICAgbWF0Y2ggTHd0LnN0YXRlIHNlbmRlciB3aXRoXG4gICAgICAgICAgIHwgTHd0LlNsZWVwIC0+XG4gICAgICAgICAgICAgKCogVGhlIHNlbmRlciBpcyBzdGlsbCBzbGVlcGluZywgYmVoYXZlIGFzIHRoZVxuICAgICAgICAgICAgICAgIGdldHRlci4gKilcbiAgICAgICAgICAgICBnZXR0ZXJcbiAgICAgICAgICAgfCBMd3QuUmV0dXJuIF8gLT5cbiAgICAgICAgICAgICAoKiBUaGUgc2VuZGVyIHRlcm1pbmF0ZWQgc3VjY2Vzc2Z1bGx5LCB3ZSBhcmVcbiAgICAgICAgICAgICAgICBkb25lIG1vbml0b3JpbmcgaXQuICopXG4gICAgICAgICAgICAgc3RhdGUgOj0gRG9uZTtcbiAgICAgICAgICAgICBnZXR0ZXJcbiAgICAgICAgICAgfCBMd3QuRmFpbCBfIC0+XG4gICAgICAgICAgICAgKCogVGhlIHNlbmRlciBmYWlsZWQsIGJlaGF2ZSBhcyB0aGUgc2VuZGVyIGZvclxuICAgICAgICAgICAgICAgIHRoaXMgZWxlbWVudCBhbmQgc2F2ZSBjdXJyZW50IGdldHRlci4gKilcbiAgICAgICAgICAgICBzdGF0ZSA6PSBTYXZlIGdldHRlcjtcbiAgICAgICAgICAgICBzZW5kZXJcbiAgICAgICAgIGluXG4gICAgICAgICBMd3QudHJ5X2JpbmQgKGZ1biAoKSAtPiBMd3QuY2hvb3NlIFtzZW5kZXI7IGdldHRlcl0pIHJlc3VsdCByZXN1bHRcbiAgICAgICB8IFNhdmUgdCAtPlxuICAgICAgICAgc3RhdGUgOj0gRG9uZTtcbiAgICAgICAgIHRcbiAgICAgICB8IERvbmUgLT5cbiAgICAgICAgIEx3dF9zdHJlYW0uZ2V0IHN0KVxuXG5sZXQgcG1hcCA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGVyciBjbWQgdGV4dCA9XG4gIGxldCBwciA9IG9wZW5fcHJvY2VzcyA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGVyciBjbWQgaW5cbiAgKCogU3RhcnQgdGhlIHNlbmRlciBhbmQgZ2V0dGVyIGF0IHRoZSBzYW1lIHRpbWUuICopXG4gIGxldCBzZW5kZXIgPSBzZW5kIEx3dF9pby53cml0ZSBwciB0ZXh0IGluXG4gIGxldCBnZXR0ZXIgPSByZWN2IHByIGluXG4gIEx3dC5jYXRjaFxuICAgIChmdW4gKCkgLT5cbiAgICAgICAoKiBXYWl0IGZvciBib3RoIHRvIHRlcm1pbmF0ZSwgcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICAgICAgZ2V0dGVyLiAqKVxuICAgICAgIHNlbmRlciA+Pj0gZnVuICgpIC0+IGdldHRlcilcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgTHd0LkNhbmNlbGVkIGFzIGV4biAtPlxuICAgICAgICAoKiBDYW5jZWwgdGhlIGdldHRlciBpZiB0aGUgc2VuZGVyIHdhcyBjYW5jZWxlZC4gKilcbiAgICAgICAgTHd0LmNhbmNlbCBnZXR0ZXI7XG4gICAgICAgIEx3dC5yZXJhaXNlIGV4blxuICAgICAgfCBleG4gLT4gTHd0LnJlcmFpc2UgZXhuKVxuXG5sZXQgcG1hcF9jaGFycyA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGVyciBjbWQgY2hhcnMgPVxuICBsZXQgcHIgPSBvcGVuX3Byb2Nlc3MgP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRlcnIgY21kIGluXG4gIGxldCBzZW5kZXIgPSBzZW5kIEx3dF9pby53cml0ZV9jaGFycyBwciBjaGFycyBpblxuICBtb25pdG9yIHNlbmRlciAocmVjdl9jaGFycyBwcilcblxubGV0IHBtYXBfbGluZSA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGVyciBjbWQgbGluZSA9XG4gIGxldCBwciA9IG9wZW5fcHJvY2VzcyA/dGltZW91dCA/ZW52ID9jd2QgP3N0ZGVyciBjbWQgaW5cbiAgKCogU3RhcnQgdGhlIHNlbmRlciBhbmQgZ2V0dGVyIGF0IHRoZSBzYW1lIHRpbWUuICopXG4gIGxldCBzZW5kZXIgPSBzZW5kIEx3dF9pby53cml0ZV9saW5lIHByIGxpbmUgaW5cbiAgbGV0IGdldHRlciA9IHJlY3ZfbGluZSBwciBpblxuICBMd3QuY2F0Y2hcbiAgICAoZnVuICgpIC0+XG4gICAgICAgKCogV2FpdCBmb3IgYm90aCB0byB0ZXJtaW5hdGUsIHJldHVybmluZyB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAgICAgIGdldHRlci4gKilcbiAgICAgICBzZW5kZXIgPj49IGZ1biAoKSAtPiBnZXR0ZXIpXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEx3dC5DYW5jZWxlZCBhcyBleG4gLT5cbiAgICAgICAgKCogQ2FuY2VsIHRoZSBnZXR0ZXIgaWYgdGhlIHNlbmRlciB3YXMgY2FuY2VsZWQuICopXG4gICAgICAgIEx3dC5jYW5jZWwgZ2V0dGVyO1xuICAgICAgICBMd3QucmVyYWlzZSBleG5cbiAgICAgIHwgZXhuIC0+IEx3dC5yZXJhaXNlIGV4bilcblxubGV0IHBtYXBfbGluZXMgP3RpbWVvdXQgP2VudiA/Y3dkID9zdGRlcnIgY21kIGxpbmVzID1cbiAgbGV0IHByID0gb3Blbl9wcm9jZXNzID90aW1lb3V0ID9lbnYgP2N3ZCA/c3RkZXJyIGNtZCBpblxuICBsZXQgc2VuZGVyID0gc2VuZCBMd3RfaW8ud3JpdGVfbGluZXMgcHIgbGluZXMgaW5cbiAgbW9uaXRvciBzZW5kZXIgKHJlY3ZfbGluZXMgcHIpXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbm9wZW4gTHd0LkluZml4XG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgUGFyYW1ldGVycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxuKCogTWluaW11bSBudW1iZXIgb2YgcHJlZW1wdGl2ZSB0aHJlYWRzOiAqKVxubGV0IG1pbl90aHJlYWRzIDogaW50IHJlZiA9IHJlZiAwXG5cbigqIE1heGltdW0gbnVtYmVyIG9mIHByZWVtcHRpdmUgdGhyZWFkczogKilcbmxldCBtYXhfdGhyZWFkcyA6IGludCByZWYgPSByZWYgMFxuXG4oKiBTaXplIG9mIHRoZSB3YWl0aW5nIHF1ZXVlOiAqKVxubGV0IG1heF90aHJlYWRfcXVldWVkID0gcmVmIDEwMDBcblxubGV0IGdldF9tYXhfbnVtYmVyX29mX3RocmVhZHNfcXVldWVkIF8gPVxuICAhbWF4X3RocmVhZF9xdWV1ZWRcblxubGV0IHNldF9tYXhfbnVtYmVyX29mX3RocmVhZHNfcXVldWVkIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTHd0X3ByZWVtcHRpdmUuc2V0X21heF9udW1iZXJfb2ZfdGhyZWFkc19xdWV1ZWRcIjtcbiAgbWF4X3RocmVhZF9xdWV1ZWQgOj0gblxuXG4oKiBUaGUgdG90YWwgbnVtYmVyIG9mIHByZWVtcHRpdmUgdGhyZWFkcyBjdXJyZW50bHkgcnVubmluZzogKilcbmxldCB0aHJlYWRzX2NvdW50ID0gcmVmIDBcblxuKCogKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgfCBQcmVlbXB0aXZlIHRocmVhZHMgbWFuYWdlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqKVxuXG5tb2R1bGUgQ0VMTCA6XG5zaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIG1ha2UgOiB1bml0IC0+ICdhIHRcbiAgdmFsIGdldCA6ICdhIHQgLT4gJ2FcbiAgdmFsIHNldCA6ICdhIHQgLT4gJ2EgLT4gdW5pdFxuZW5kID1cbnN0cnVjdFxuICB0eXBlICdhIHQgPSB7XG4gICAgbSAgOiBNdXRleC50O1xuICAgIGN2IDogQ29uZGl0aW9uLnQ7XG4gICAgbXV0YWJsZSBjZWxsIDogJ2Egb3B0aW9uO1xuICB9XG5cbiAgbGV0IG1ha2UgKCkgPSB7IG0gPSBNdXRleC5jcmVhdGUgKCk7IGN2ID0gQ29uZGl0aW9uLmNyZWF0ZSAoKTsgY2VsbCA9IE5vbmUgfVxuXG4gIGxldCBnZXQgdCA9XG4gICAgbGV0IHJlYyBhd2FpdF92YWx1ZSB0ID1cbiAgICAgIG1hdGNoIHQuY2VsbCB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgQ29uZGl0aW9uLndhaXQgdC5jdiB0Lm07XG4gICAgICAgIGF3YWl0X3ZhbHVlIHRcbiAgICAgIHwgU29tZSB2IC0+XG4gICAgICAgIHQuY2VsbCA8LSBOb25lO1xuICAgICAgICBNdXRleC51bmxvY2sgdC5tO1xuICAgICAgICB2XG4gICAgaW5cbiAgICBNdXRleC5sb2NrIHQubTtcbiAgICBhd2FpdF92YWx1ZSB0XG5cbiAgbGV0IHNldCB0IHYgPVxuICAgIE11dGV4LmxvY2sgdC5tO1xuICAgIHQuY2VsbCA8LSBTb21lIHY7XG4gICAgTXV0ZXgudW5sb2NrIHQubTtcbiAgICBDb25kaXRpb24uc2lnbmFsIHQuY3ZcbmVuZFxuXG50eXBlIHRocmVhZCA9IHtcbiAgdGFza19jZWxsOiAoaW50ICogKHVuaXQgLT4gdW5pdCkpIENFTEwudDtcbiAgKCogQ2hhbm5lbCB1c2VkIHRvIGNvbW11bmljYXRlIG5vdGlmaWNhdGlvbiBpZCBhbmQgdGFza3MgdG8gdGhlXG4gICAgIHdvcmtlciB0aHJlYWQuICopXG5cbiAgbXV0YWJsZSB0aHJlYWQgOiBUaHJlYWQudDtcbiAgKCogVGhlIHdvcmtlciB0aHJlYWQuICopXG5cbiAgbXV0YWJsZSByZXVzZSA6IGJvb2w7XG4gICgqIFdoZXRoZXIgdGhlIHRocmVhZCBtdXN0IGJlIHJlLWFkZGVkIHRvIHRoZSBwb29sIHdoZW4gdGhlIHdvcmsgaXNcbiAgICAgZG9uZS4gKilcbn1cblxuKCogUG9vbCBvZiB3b3JrZXIgdGhyZWFkczogKilcbmxldCB3b3JrZXJzIDogdGhyZWFkIFF1ZXVlLnQgPSBRdWV1ZS5jcmVhdGUgKClcblxuKCogUXVldWUgb2YgY2xpZW50cyB3YWl0aW5nIGZvciBhIHdvcmtlciB0byBiZSBhdmFpbGFibGU6ICopXG5sZXQgd2FpdGVycyA6IHRocmVhZCBMd3QudSBMd3Rfc2VxdWVuY2UudCA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKClcblxuKCogQ29kZSBleGVjdXRlZCBieSBhIHdvcmtlcjogKilcbmxldCByZWMgd29ya2VyX2xvb3Agd29ya2VyID1cbiAgbGV0IGlkLCB0YXNrID0gQ0VMTC5nZXQgd29ya2VyLnRhc2tfY2VsbCBpblxuICB0YXNrICgpO1xuICAoKiBJZiB0aGVyZSBpcyB0b28gbXVjaCB0aHJlYWRzLCBleGl0LiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIHVzZXJcbiAgICAgZGVjcmVhc2VkIHRoZSBtYXhpbXVtOiAqKVxuICBpZiAhdGhyZWFkc19jb3VudCA+ICFtYXhfdGhyZWFkcyB0aGVuIHdvcmtlci5yZXVzZSA8LSBmYWxzZTtcbiAgKCogVGVsbCB0aGUgbWFpbiB0aHJlYWQgdGhhdCB3b3JrIGlzIGRvbmU6ICopXG4gIEx3dF91bml4LnNlbmRfbm90aWZpY2F0aW9uIGlkO1xuICBpZiB3b3JrZXIucmV1c2UgdGhlbiB3b3JrZXJfbG9vcCB3b3JrZXJcblxuKCogY3JlYXRlIGEgbmV3IHdvcmtlcjogKilcbmxldCBtYWtlX3dvcmtlciAoKSA9XG4gIGluY3IgdGhyZWFkc19jb3VudDtcbiAgbGV0IHdvcmtlciA9IHtcbiAgICB0YXNrX2NlbGwgPSBDRUxMLm1ha2UgKCk7XG4gICAgdGhyZWFkID0gVGhyZWFkLnNlbGYgKCk7XG4gICAgcmV1c2UgPSB0cnVlO1xuICB9IGluXG4gIHdvcmtlci50aHJlYWQgPC0gVGhyZWFkLmNyZWF0ZSB3b3JrZXJfbG9vcCB3b3JrZXI7XG4gIHdvcmtlclxuXG4oKiBBZGQgYSB3b3JrZXIgdG8gdGhlIHBvb2w6ICopXG5sZXQgYWRkX3dvcmtlciB3b3JrZXIgPVxuICBtYXRjaCBMd3Rfc2VxdWVuY2UudGFrZV9vcHRfbCB3YWl0ZXJzIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgUXVldWUuYWRkIHdvcmtlciB3b3JrZXJzXG4gIHwgU29tZSB3IC0+XG4gICAgTHd0Lndha2V1cCB3IHdvcmtlclxuXG4oKiBXYWl0IGZvciB3b3JrZXIgdG8gYmUgYXZhaWxhYmxlLCB0aGVuIHJldHVybiBpdDogKilcbmxldCBnZXRfd29ya2VyICgpID1cbiAgaWYgbm90IChRdWV1ZS5pc19lbXB0eSB3b3JrZXJzKSB0aGVuXG4gICAgTHd0LnJldHVybiAoUXVldWUudGFrZSB3b3JrZXJzKVxuICBlbHNlIGlmICF0aHJlYWRzX2NvdW50IDwgIW1heF90aHJlYWRzIHRoZW5cbiAgICBMd3QucmV0dXJuIChtYWtlX3dvcmtlciAoKSlcbiAgZWxzZVxuICAgIChMd3QuYWRkX3Rhc2tfciBbQG9jYW1sLndhcm5pbmcgXCItM1wiXSkgd2FpdGVyc1xuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IEluaXRpYWxpc2F0aW9uLCBhbmQgZHluYW1pYyBwYXJhbWV0ZXJzIHJlc2V0ICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBnZXRfYm91bmRzICgpID0gKCFtaW5fdGhyZWFkcywgIW1heF90aHJlYWRzKVxuXG5sZXQgc2V0X2JvdW5kcyAobWluLCBtYXgpID1cbiAgaWYgbWluIDwgMCB8fCBtYXggPCBtaW4gdGhlbiBpbnZhbGlkX2FyZyBcIkx3dF9wcmVlbXB0aXZlLnNldF9ib3VuZHNcIjtcbiAgbGV0IGRpZmYgPSBtaW4gLSAhdGhyZWFkc19jb3VudCBpblxuICBtaW5fdGhyZWFkcyA6PSBtaW47XG4gIG1heF90aHJlYWRzIDo9IG1heDtcbiAgKCogTGF1bmNoIG5ldyB3b3JrZXJzOiAqKVxuICBmb3IgX2kgPSAxIHRvIGRpZmYgZG9cbiAgICBhZGRfd29ya2VyIChtYWtlX3dvcmtlciAoKSlcbiAgZG9uZVxuXG5sZXQgaW5pdGlhbGl6ZWQgPSByZWYgZmFsc2VcblxubGV0IGluaXQgbWluIG1heCBfZXJybG9nID1cbiAgaW5pdGlhbGl6ZWQgOj0gdHJ1ZTtcbiAgc2V0X2JvdW5kcyAobWluLCBtYXgpXG5cbmxldCBzaW1wbGVfaW5pdCAoKSA9XG4gIGlmIG5vdCAhaW5pdGlhbGl6ZWQgdGhlbiBiZWdpblxuICAgIGluaXRpYWxpemVkIDo9IHRydWU7XG4gICAgc2V0X2JvdW5kcyAoMCwgNClcbiAgZW5kXG5cbmxldCBuYnRocmVhZHMgKCkgPSAhdGhyZWFkc19jb3VudFxubGV0IG5idGhyZWFkc3F1ZXVlZCAoKSA9IEx3dF9zZXF1ZW5jZS5mb2xkX2wgKGZ1biBfIHggLT4geCArIDEpIHdhaXRlcnMgMFxubGV0IG5idGhyZWFkc2J1c3kgKCkgPSAhdGhyZWFkc19jb3VudCAtIFF1ZXVlLmxlbmd0aCB3b3JrZXJzXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgRGV0YWNoaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxubGV0IGluaXRfcmVzdWx0ID0gUmVzdWx0LkVycm9yIChGYWlsdXJlIFwiTHd0X3ByZWVtcHRpdmUuZGV0YWNoXCIpXG5cbmxldCBkZXRhY2ggZiBhcmdzID1cbiAgc2ltcGxlX2luaXQgKCk7XG4gIGxldCByZXN1bHQgPSByZWYgaW5pdF9yZXN1bHQgaW5cbiAgKCogVGhlIHRhc2sgZm9yIHRoZSB3b3JrZXIgdGhyZWFkOiAqKVxuICBsZXQgdGFzayAoKSA9XG4gICAgdHJ5XG4gICAgICByZXN1bHQgOj0gUmVzdWx0Lk9rIChmIGFyZ3MpXG4gICAgd2l0aCBleG4gd2hlbiBMd3QuRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICByZXN1bHQgOj0gUmVzdWx0LkVycm9yIGV4blxuICBpblxuICBnZXRfd29ya2VyICgpID4+PSBmdW4gd29ya2VyIC0+XG4gIGxldCB3YWl0ZXIsIHdha2VuZXIgPSBMd3Qud2FpdCAoKSBpblxuICBsZXQgaWQgPVxuICAgIEx3dF91bml4Lm1ha2Vfbm90aWZpY2F0aW9uIH5vbmNlOnRydWVcbiAgICAgIChmdW4gKCkgLT4gTHd0Lndha2V1cF9yZXN1bHQgd2FrZW5lciAhcmVzdWx0KVxuICBpblxuICBMd3QuZmluYWxpemVcbiAgICAoZnVuICgpIC0+XG4gICAgICAgKCogU2VuZCB0aGUgaWQgYW5kIHRoZSB0YXNrIHRvIHRoZSB3b3JrZXI6ICopXG4gICAgICAgQ0VMTC5zZXQgd29ya2VyLnRhc2tfY2VsbCAoaWQsIHRhc2spO1xuICAgICAgIHdhaXRlcilcbiAgICAoZnVuICgpIC0+XG4gICAgICAgaWYgd29ya2VyLnJldXNlIHRoZW5cbiAgICAgICAgICgqIFB1dCBiYWNrIHRoZSB3b3JrZXIgdG8gdGhlIHBvb2w6ICopXG4gICAgICAgICBhZGRfd29ya2VyIHdvcmtlclxuICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgIGRlY3IgdGhyZWFkc19jb3VudDtcbiAgICAgICAgICgqIE9yIHdhaXQgZm9yIHRoZSB0aHJlYWQgdG8gdGVybWluYXRlcywgdG8gZnJlZSBpdHMgYXNzb2NpYXRlZFxuICAgICAgICAgICAgcmVzb3VyY2VzOiAqKVxuICAgICAgICAgVGhyZWFkLmpvaW4gd29ya2VyLnRocmVhZFxuICAgICAgIGVuZDtcbiAgICAgICBMd3QucmV0dXJuX3VuaXQpXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgUnVubmluZyBMd3QgdGhyZWFkcyBpbiB0aGUgbWFpbiB0aHJlYWQgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxuKCogUXVldWUgb2YgW3VuaXQgLT4gdW5pdCBMd3QudF0gZnVuY3Rpb25zLiAqKVxubGV0IGpvYnMgPSBRdWV1ZS5jcmVhdGUgKClcblxuKCogTXV0ZXggdG8gcHJvdGVjdCBhY2Nlc3MgdG8gW2pvYnNdLiAqKVxubGV0IGpvYnNfbXV0ZXggPSBNdXRleC5jcmVhdGUgKClcblxubGV0IGpvYl9ub3RpZmljYXRpb24gPVxuICBMd3RfdW5peC5tYWtlX25vdGlmaWNhdGlvblxuICAgIChmdW4gKCkgLT5cbiAgICAgICAoKiBUYWtlIHRoZSBmaXJzdCBqb2IuIFRoZSBxdWV1ZSBpcyBuZXZlciBlbXB0eSBhdCB0aGlzXG4gICAgICAgICAgcG9pbnQuICopXG4gICAgICAgTXV0ZXgubG9jayBqb2JzX211dGV4O1xuICAgICAgIGxldCB0aHVuayA9IFF1ZXVlLnRha2Ugam9icyBpblxuICAgICAgIE11dGV4LnVubG9jayBqb2JzX211dGV4O1xuICAgICAgIGlnbm9yZSAodGh1bmsgKCkpKVxuXG5sZXQgcnVuX2luX21haW5fZG9udF93YWl0IGYgPVxuICAoKiBBZGQgdGhlIGpvYiB0byB0aGUgcXVldWUuICopXG4gIE11dGV4LmxvY2sgam9ic19tdXRleDtcbiAgUXVldWUuYWRkIGYgam9icztcbiAgTXV0ZXgudW5sb2NrIGpvYnNfbXV0ZXg7XG4gICgqIE5vdGlmeSB0aGUgbWFpbiB0aHJlYWQuICopXG4gIEx3dF91bml4LnNlbmRfbm90aWZpY2F0aW9uIGpvYl9ub3RpZmljYXRpb25cblxuKCogVGhlcmUgaXMgYSBwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaXNzdWUgZnJvbSBjcmVhdGluZyBhIGNlbGwgZXZlcnkgdGltZSB0aGlzXG4gICBmdW5jdGlvbiBpcyBjYWxsZWQuIFNlZTpcbiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9pc3N1ZXMvMjE4XG4gICBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvcHVsbC8yMTlcbiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9pc3N1ZXMvNzE1OCAqKVxubGV0IHJ1bl9pbl9tYWluIGYgPVxuICBsZXQgY2VsbCA9IENFTEwubWFrZSAoKSBpblxuICAoKiBDcmVhdGUgdGhlIGpvYi4gKilcbiAgbGV0IGpvYiAoKSA9XG4gICAgKCogRXhlY3V0ZSBbZl0gYW5kIHdhaXQgZm9yIGl0cyByZXN1bHQuICopXG4gICAgTHd0LnRyeV9iaW5kIGZcbiAgICAgIChmdW4gcmV0IC0+IEx3dC5yZXR1cm4gKFJlc3VsdC5PayByZXQpKVxuICAgICAgKGZ1biBleG4gLT4gTHd0LnJldHVybiAoUmVzdWx0LkVycm9yIGV4bikpID4+PSBmdW4gcmVzdWx0IC0+XG4gICAgKCogU2VuZCB0aGUgcmVzdWx0LiAqKVxuICAgIENFTEwuc2V0IGNlbGwgcmVzdWx0O1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICBpblxuICBydW5faW5fbWFpbl9kb250X3dhaXQgam9iO1xuICAoKiBXYWl0IGZvciB0aGUgcmVzdWx0LiAqKVxuICBtYXRjaCBDRUxMLmdldCBjZWxsIHdpdGhcbiAgfCBSZXN1bHQuT2sgcmV0IC0+IHJldFxuICB8IFJlc3VsdC5FcnJvciBleG4gLT4gcmFpc2UgZXhuXG5cbigqIFRoaXMgdmVyc2lvbiBzaGFkb3dzIHRoZSBvbmUgYWJvdmUsIGFkZGluZyBhbiBleGNlcHRpb24gaGFuZGxlciAqKVxubGV0IHJ1bl9pbl9tYWluX2RvbnRfd2FpdCBmIGhhbmRsZXIgPVxuICBsZXQgZiAoKSA9IEx3dC5jYXRjaCBmIChmdW4gZXhjIC0+IGhhbmRsZXIgZXhjOyBMd3QucmV0dXJuX3VuaXQpIGluXG4gIHJ1bl9pbl9tYWluX2RvbnRfd2FpdCBmXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbmxldCBlbnN1cmVfdGVybWluYXRpb24gdCA9XG4gIGlmIEx3dC5zdGF0ZSB0ID0gTHd0LlNsZWVwIHRoZW4gYmVnaW5cbiAgICBsZXQgaG9vayA9XG4gICAgICBMd3Rfc2VxdWVuY2UuYWRkX2wgKGZ1biBfIC0+IHQpIEx3dF9tYWluLmV4aXRfaG9va3MgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl1cbiAgICBpblxuICAgICgqIFJlbW92ZSB0aGUgaG9vayB3aGVuIHQgaGFzIHRlcm1pbmF0ZWQgKilcbiAgICBpZ25vcmUgKFxuICAgICAgTHd0LmZpbmFsaXplXG4gICAgICAgIChmdW4gKCkgLT4gdClcbiAgICAgICAgKGZ1biAoKSAtPiBMd3Rfc2VxdWVuY2UucmVtb3ZlIGhvb2s7IEx3dC5yZXR1cm5fdW5pdCkpXG4gIGVuZFxuXG5sZXQgZmluYWxpc2VyIGYgPVxuICAoKiBJbiBvcmRlciBub3QgdG8gY3JlYXRlIGEgcmVmZXJlbmNlIHRvIHRoZSB2YWx1ZSBpbiB0aGVcbiAgICAgbm90aWZpY2F0aW9uIGNhbGxiYWNrLCB3ZSB1c2UgYW4gaW5pdGlhbGx5IHVuc2V0IG9wdGlvbiBjZWxsXG4gICAgIHdoaWNoIHdpbGwgYmUgZmlsbGVkIHdoZW4gdGhlIGZpbmFsaXNlciBpcyBjYWxsZWQuICopXG4gIGxldCBvcHQgPSByZWYgTm9uZSBpblxuICBsZXQgaWQgPVxuICAgIEx3dF91bml4Lm1ha2Vfbm90aWZpY2F0aW9uXG4gICAgICB+b25jZTp0cnVlXG4gICAgICAoZnVuICgpIC0+XG4gICAgICAgICBtYXRjaCAhb3B0IHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICAgICAgIHwgU29tZSB4IC0+XG4gICAgICAgICAgIG9wdCA6PSBOb25lO1xuICAgICAgICAgICBlbnN1cmVfdGVybWluYXRpb24gKGYgeCkpXG4gIGluXG4gICgqIFRoZSByZWFsIGZpbmFsaXNlcjogZmlsbCB0aGUgY2VsbCBhbmQgc2VuZCBhIG5vdGlmaWNhdGlvbi4gKilcbiAgKGZ1biB4IC0+XG4gICAgIG9wdCA6PSBTb21lIHg7XG4gICAgIEx3dF91bml4LnNlbmRfbm90aWZpY2F0aW9uIGlkKVxuXG5sZXQgZmluYWxpc2UgZiB4ID1cbiAgR2MuZmluYWxpc2UgKGZpbmFsaXNlciBmKSB4XG5cbigqIEV4aXQgaG9vayBmb3IgYSBmaW5hbGlzZV9vcl9leGl0ICopXG5sZXQgZm9lX2V4aXQgZiBjYWxsZWQgd2VhayAoKSA9XG4gIG1hdGNoIFdlYWsuZ2V0IHdlYWsgMCB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICgqIFRoZSB2YWx1ZSBoYXMgYmVlbiBnYXJiYWdlIGNvbGxlY3RlZCwgbm9ybWFsbHkgdGhpcyBwb2ludFxuICAgICAgIGlzIG5ldmVyIHJlYWNoZWQgKilcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgfCBTb21lIHggLT5cbiAgICAoKiBKdXN0IHRvIGF2b2lkIGRvdWJsZSBmaW5hbGlzYXRpb24gKilcbiAgICBXZWFrLnNldCB3ZWFrIDAgTm9uZTtcbiAgICBpZiAhY2FsbGVkIHRoZW5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGNhbGxlZCA6PSB0cnVlO1xuICAgICAgZiB4XG4gICAgZW5kXG5cbigqIEZpbmFsaXNlciBmb3IgYSBmaW5hbGlzZV9vcl9leGl0ICopXG5sZXQgZm9lX2ZpbmFsaXNlciBmIGNhbGxlZCBob29rID1cbiAgZmluYWxpc2VyXG4gICAgKGZ1biB4IC0+XG4gICAgICAgKCogUmVtb3ZlIHRoZSBleGl0IGhvb2ssIGl0IGlzIG5vdCBuZWVkZWQgYW55bW9yZS4gKilcbiAgICAgICBMd3Rfc2VxdWVuY2UucmVtb3ZlIGhvb2s7XG4gICAgICAgKCogQ2FsbCB0aGUgcmVhbCBmaW5hbGlzZXIuICopXG4gICAgICAgaWYgIWNhbGxlZCB0aGVuXG4gICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICBjYWxsZWQgOj0gdHJ1ZTtcbiAgICAgICAgIGYgeFxuICAgICAgIGVuZClcblxubGV0IGZpbmFsaXNlX29yX2V4aXQgZiB4ID1cbiAgKCogQ3JlYXRlIGEgd2VhayBwb2ludGVyLCBzbyB0aGUgZXhpdC1ob29rIGRvZXMgbm90IGtlZXAgYSByZWZlcmVuY2VcbiAgICAgdG8gW3hdLiAqKVxuICBsZXQgd2VhayA9IFdlYWsuY3JlYXRlIDEgaW5cbiAgV2Vhay5zZXQgd2VhayAwIChTb21lIHgpO1xuICBsZXQgY2FsbGVkID0gcmVmIGZhbHNlIGluXG4gIGxldCBob29rID1cbiAgICBMd3Rfc2VxdWVuY2UuYWRkX2wgKGZvZV9leGl0IGYgY2FsbGVkIHdlYWspIEx3dF9tYWluLmV4aXRfaG9va3NcbiAgICAgIFtAb2NhbWwud2FybmluZyBcIi0zXCJdXG4gIGluXG4gIEdjLmZpbmFsaXNlIChmb2VfZmluYWxpc2VyIGYgY2FsbGVkIGhvb2spIHhcbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxub3BlbiBMd3QuSW5maXhcblxudHlwZSBmb3JtYXR0ZXIgPSB7XG4gIGNvbW1pdCA6IHVuaXQgLT4gdW5pdCBMd3QudCA7XG4gIGZtdCA6IEZvcm1hdC5mb3JtYXR0ZXIgO1xufVxuXG5sZXQgd3JpdGVfcGVuZGluZyBwcGZ0ID0gcHBmdC5jb21taXQgKClcbmxldCBmbHVzaCBwcGZ0ID0gRm9ybWF0LnBwX3ByaW50X2ZsdXNoIHBwZnQuZm10ICgpIDsgcHBmdC5jb21taXQgKClcblxubGV0IG1ha2VfZm9ybWF0dGVyIH5jb21taXQgfmZtdCAoKSA9IHsgY29tbWl0IDsgZm10IH1cblxubGV0IGdldF9mb3JtYXR0ZXIgeCA9IHguZm10XG5cbigqKiBTdHJlYW0gZm9ybWF0dGVyICopXG5cbnR5cGUgb3JkZXIgPVxuICB8IFN0cmluZyBvZiBzdHJpbmcgKiBpbnQgKiBpbnRcbiAgfCBGbHVzaFxuXG5sZXQgbWFrZV9zdHJlYW0gKCkgPVxuICBsZXQgc3RyZWFtLCBwdXNoID0gTHd0X3N0cmVhbS5jcmVhdGUgKCkgaW5cbiAgbGV0IG91dF9zdHJpbmcgcyBpIGogPVxuICAgIHB1c2ggQEAgU29tZSAoU3RyaW5nIChzLCBpLCBqKSlcbiAgYW5kIGZsdXNoICgpID1cbiAgICBwdXNoIEBAIFNvbWUgRmx1c2hcbiAgaW5cbiAgbGV0IGZtdCA9IEZvcm1hdC5tYWtlX2Zvcm1hdHRlciBvdXRfc3RyaW5nIGZsdXNoIGluXG4gICgqIE5vdCBzdXJlIGFib3V0IHRoYXQgb25lICopXG4gIEdjLmZpbmFsaXNlIChmdW4gXyAtPiBwdXNoIE5vbmUpIGZtdCA7XG4gIGxldCBjb21taXQgKCkgPSBMd3QucmV0dXJuX3VuaXQgaW5cbiAgc3RyZWFtLCBtYWtlX2Zvcm1hdHRlciB+Y29tbWl0IH5mbXQgKClcblxuKCoqIENoYW5uZWwgZm9ybWF0dGVyICopXG5cbmxldCB3cml0ZV9vcmRlciBvYyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nIChzLCBpLCBqKSAtPlxuICAgIEx3dF9pby53cml0ZV9mcm9tX3N0cmluZ19leGFjdGx5IG9jIHMgaSBqXG4gIHwgRmx1c2ggLT5cbiAgICBMd3RfaW8uZmx1c2ggb2NcblxubGV0IHJlYyB3cml0ZV9vcmRlcnMgb2MgcXVldWUgPVxuICBpZiBRdWV1ZS5pc19lbXB0eSBxdWV1ZSB0aGVuXG4gICAgTHd0LnJldHVybl91bml0XG4gIGVsc2VcbiAgICBsZXQgbyA9IFF1ZXVlLnBvcCBxdWV1ZSBpblxuICAgIHdyaXRlX29yZGVyIG9jIG8gPj49IGZ1biAoKSAtPlxuICAgIHdyaXRlX29yZGVycyBvYyBxdWV1ZVxuXG5sZXQgb2ZfY2hhbm5lbCBvYyA9XG4gIGxldCBxID0gUXVldWUuY3JlYXRlICgpIGluXG4gIGxldCBvdXRfc3RyaW5nIHMgaSBqID1cbiAgICBRdWV1ZS5wdXNoIChTdHJpbmcgKHMsIGksIGopKSBxXG4gIGFuZCBmbHVzaCAoKSA9XG4gICAgUXVldWUucHVzaCBGbHVzaCBxXG4gIGluXG4gIGxldCBmbXQgPSBGb3JtYXQubWFrZV9mb3JtYXR0ZXIgb3V0X3N0cmluZyBmbHVzaCBpblxuICBsZXQgY29tbWl0ICgpID0gd3JpdGVfb3JkZXJzIG9jIHEgaW5cbiAgbWFrZV9mb3JtYXR0ZXIgfmNvbW1pdCB+Zm10ICgpXG5cbigqKiBQcmludGluZyBmdW5jdGlvbnMgKilcblxubGV0IGtmcHJpbnRmIGsgcHBmdCBmbXQgPVxuICBGb3JtYXQua2ZwcmludGYgKGZ1biBfcHBmIC0+IGsgcHBmdCBAQCBwcGZ0LmNvbW1pdCAoKSkgcHBmdC5mbXQgZm10XG5sZXQgaWtmcHJpbnRmIGsgcHBmdCBmbXQgPVxuICBGb3JtYXQuaWtmcHJpbnRmIChmdW4gX3BwZiAtPiBrIHBwZnQgQEAgTHd0LnJldHVybl91bml0KSBwcGZ0LmZtdCBmbXRcblxubGV0IGZwcmludGYgcHBmdCBmbXQgPVxuICBrZnByaW50ZiAoZnVuIF8gdCAtPiB0KSBwcGZ0IGZtdFxubGV0IGlmcHJpbnRmIHBwZnQgZm10ID1cbiAgaWtmcHJpbnRmIChmdW4gXyB0IC0+IHQpIHBwZnQgZm10XG5cbmxldCBzdGRvdXQgPSBvZl9jaGFubmVsIEx3dF9pby5zdGRvdXRcbmxldCBzdGRlcnIgPSBvZl9jaGFubmVsIEx3dF9pby5zdGRlcnJcblxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZG91dCBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkZXJyIGZtdFxuIl19
