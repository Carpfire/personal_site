// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Dream_httpaf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dream_httpaf = [0];
   runtime.caml_register_global(0, Dream_httpaf, "Dream_httpaf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf__Websocket
//# unitInfo: Requires: Bigstringaf, Dream_pure__Stream, Dream_websocketaf__Websocketaf, Lwt, Lwt_stream, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Bigstringaf = global_data.Bigstringaf,
    Dream_websocketaf_Websocketaf = global_data.Dream_websocketaf__Websocketaf,
    Lwt_stream = global_data.Lwt_stream,
    Lwt = global_data.Lwt,
    Stdlib = global_data.Stdlib,
    Dream_pure_Stream = global_data.Dream_pure__Stream,
    cst_Ping_payload_cannot_exceed = "Ping payload cannot exceed 125 bytes",
    cst_Pong_payload_cannot_exceed = "Pong payload cannot exceed 125 bytes";
   function websocket_handler(stream, socket){
    var
     match = caml_call1(Lwt_stream[4], 0),
     push_frame = match[2],
     frames = match[1],
     message_is_binary = [0, 564146209];
    function frame(opcode, is_fin, param, payload){
     return typeof opcode === "number"
             ? 892411538
               <= opcode
               ? 915654071
                 <= opcode
                 ? 936573133
                   <= opcode
                   ? (message_is_binary
                      [1]
                     = 936573133,
                     caml_call1
                      (push_frame,
                       [0, [0, [0, 758940234, [0, 936573133, is_fin]], payload]]))
                   : caml_call1(push_frame, [0, [0, -611285096, payload]])
                 : 892709912
                   <= opcode
                   ? caml_call1(push_frame, [0, [0, 892709912, payload]])
                   : caml_call1(push_frame, [0, [0, 892411538, payload]])
               : 564146209
                 <= opcode
                 ? (message_is_binary
                    [1]
                   = 564146209,
                   caml_call1
                    (push_frame,
                     [0, [0, [0, 758940234, [0, 564146209, is_fin]], payload]]))
                 : caml_call1
                   (push_frame,
                    [0,
                     [0,
                      [0, 758940234, [0, message_is_binary[1], is_fin]],
                      payload]])
             : caml_call1(push_frame, [0, [0, -912009552, payload]]);
    }
    function eof(param){return caml_call1(push_frame, 0);}
    var
     closed = [0, 0],
     close_code = [0, 1005],
     current_payload = [0, 0],
     last_chunk = [0, 0],
     first_chunk_received = [0, 0],
     first_chunk = [0, Bigstringaf[2]],
     first_chunk_offset = [0, 0],
     first_chunk_length = [0, 0];
    function drain_payload(payload, continuation){
     function _o_(buffer, off, len){
      if(! first_chunk_received[1]){
       first_chunk[1] = buffer;
       first_chunk_offset[1] = off;
       first_chunk_length[1] = len;
       first_chunk_received[1] = 1;
      }
      return drain_payload(payload, continuation);
     }
     function _p_(param){
      var
       payload = first_chunk[1],
       offset = first_chunk_offset[1],
       length = first_chunk_length[1];
      first_chunk_received[1] = 0;
      first_chunk[1] = Bigstringaf[2];
      first_chunk_offset[1] = 0;
      first_chunk_length[1] = 0;
      return caml_call3(continuation, payload, offset, length);
     }
     return caml_call3(Dream_websocketaf_Websocketaf[1][2], payload, _p_, _o_);
    }
    function read(data, flush, ping, pong, close, exn){
     if(closed[1]) return caml_call1(close, close_code[1]);
     var _f_ = current_payload[1];
     if(_f_){
      var
       _g_ = _f_[1],
       payload = _g_[2],
       match = _g_[1],
       fin = match[2],
       binary = match[1],
       _h_ =
         function(buffer, off, len){
          var _n_ = last_chunk[1];
          if(_n_){
           var
            match = _n_[1],
            last_length = match[3],
            last_offset = match[2],
            last_buffer = match[1];
           last_chunk[1] = [0, [0, buffer, off, len]];
           var binary$0 = 564146209 === binary ? 1 : 0;
           return caml_call5
                   (data, last_buffer, last_offset, last_length, binary$0, 0);
          }
          last_chunk[1] = [0, [0, buffer, off, len]];
          return read(data, flush, ping, pong, close, exn);
         },
       _i_ =
         function(param){
          current_payload[1] = 0;
          var _m_ = last_chunk[1];
          if(! _m_) return read(data, flush, ping, pong, close, exn);
          var
           match = _m_[1],
           last_length = match[3],
           last_offset = match[2],
           last_buffer = match[1];
          last_chunk[1] = 0;
          var binary$0 = 564146209 === binary ? 1 : 0;
          return caml_call5
                  (data, last_buffer, last_offset, last_length, binary$0, fin);
         };
      return caml_call3
              (Dream_websocketaf_Websocketaf[1][2], payload, _i_, _h_);
     }
     function _j_(param){
      if(! param){
       if(1 - closed[1]){closed[1] = 1; close_code[1] = 1005;}
       caml_call2(Dream_websocketaf_Websocketaf[3][6], 0, socket);
       return caml_call1(close, close_code[1]);
      }
      var _l_ = param[1], match = _l_[1];
      if(typeof match !== "number"){
       var payload$3 = _l_[2], properties = match[2];
       current_payload[1] = [0, [0, properties, payload$3]];
       return read(data, flush, ping, pong, close, exn);
      }
      if(892411538 <= match){
       if(892709912 <= match){
        var payload = _l_[2];
        return drain_payload(payload, pong);
       }
       var payload$0 = _l_[2];
       return drain_payload(payload$0, ping);
      }
      if(-611285096 <= match){
       var payload$1 = _l_[2];
       return drain_payload
               (payload$1,
                function(buffer, offset, length){
                 if(2 <= length)
                  var
                   high_byte = caml_ba_get_1(buffer, offset),
                   low_byte = caml_ba_get_1(buffer, offset + 1 | 0),
                   code = high_byte << 8 | low_byte;
                 else
                  var code = 1005;
                 if(1 - closed[1]) close_code[1] = code;
                 return caml_call1(close, close_code[1]);
                });
      }
      var payload$2 = _l_[2];
      return drain_payload
              (payload$2,
               function(buffer, offset, length){
                return read(data, flush, ping, pong, close, exn);
               });
     }
     var _k_ = caml_call1(Lwt_stream[21], frames);
     return caml_call2(Lwt[29], _k_, _j_);
    }
    var bytes_since_flush = [0, 0];
    function flush(close, ok){
     bytes_since_flush[1] = 0;
     return closed[1]
             ? caml_call1(close, close_code[1])
             : caml_call2(Dream_websocketaf_Websocketaf[3][5], socket, ok);
    }
    function close(code){
     var _e_ = 1 - closed[1];
     return _e_
             ? caml_call2
               (Dream_websocketaf_Websocketaf[3][6],
                [0, [0, -912009552, code]],
                socket)
             : _e_;
    }
    function abort(exn){return close(1005);}
    var reader = caml_call3(Dream_pure_Stream[1], read, close, abort);
    caml_call2(Dream_pure_Stream[3], reader, stream);
    function outgoing_loop(param){
     function _a_(buffer, offset, length){
      if(125 < length)
       throw caml_maybe_attach_backtrace
              ([0, Stdlib[7], cst_Pong_payload_cannot_exceed], 1);
      if(closed[1]) return close(close_code[1]);
      if(0 === length)
       caml_call2(Dream_websocketaf_Websocketaf[3][4], 0, socket);
      else
       caml_call2
        (Dream_websocketaf_Websocketaf[3][4],
         [0, [0, buffer, offset, length]],
         socket);
      return outgoing_loop(0);
     }
     function _b_(buffer, offset, length){
      if(125 < length)
       throw caml_maybe_attach_backtrace
              ([0, Stdlib[7], cst_Ping_payload_cannot_exceed], 1);
      if(closed[1]) return close(close_code[1]);
      if(0 === length)
       caml_call2(Dream_websocketaf_Websocketaf[3][3], 0, socket);
      else
       caml_call2
        (Dream_websocketaf_Websocketaf[3][3],
         [0, [0, buffer, offset, length]],
         socket);
      return outgoing_loop(0);
     }
     function _c_(param){return flush(close, outgoing_loop);}
     function _d_(buffer, offset, length, binary, fin){
      var kind = binary ? 564146209 : 936573133;
      return closed[1]
              ? close(close_code[1])
              : (caml_call6
                 (Dream_websocketaf_Websocketaf[3][1],
                  socket,
                  [0, fin],
                  kind,
                  buffer,
                  offset,
                  length),
                bytes_since_flush[1] = bytes_since_flush[1] + length | 0,
                4096 <= bytes_since_flush[1]
                 ? flush(close, outgoing_loop)
                 : outgoing_loop(0));
     }
     return caml_call7
             (Dream_pure_Stream[12], stream, _d_, _c_, _b_, _a_, close, abort);
    }
    outgoing_loop(0);
    return [0, frame, eof];
   }
   var Dream_httpaf_Websocket = [0, websocket_handler];
   runtime.caml_register_global
    (8, Dream_httpaf_Websocket, "Dream_httpaf__Websocket");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJkcmVhbV9odHRwYWYuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIndlYnNvY2tldF9oYW5kbGVyIiwic3RyZWFtIiwic29ja2V0IiwicHVzaF9mcmFtZSIsImZyYW1lcyIsIm1lc3NhZ2VfaXNfYmluYXJ5IiwiZnJhbWUiLCJvcGNvZGUiLCJpc19maW4iLCJwYXlsb2FkIiwiZW9mIiwiY2xvc2VkIiwiY2xvc2VfY29kZSIsImN1cnJlbnRfcGF5bG9hZCIsImxhc3RfY2h1bmsiLCJmaXJzdF9jaHVua19yZWNlaXZlZCIsImZpcnN0X2NodW5rIiwiZmlyc3RfY2h1bmtfb2Zmc2V0IiwiZmlyc3RfY2h1bmtfbGVuZ3RoIiwiZHJhaW5fcGF5bG9hZCIsImNvbnRpbnVhdGlvbiIsImJ1ZmZlciIsIm9mZiIsImxlbiIsIm9mZnNldCIsImxlbmd0aCIsInJlYWQiLCJkYXRhIiwiZmx1c2giLCJwaW5nIiwicG9uZyIsImNsb3NlIiwiZXhuIiwiZmluIiwiYmluYXJ5IiwibGFzdF9sZW5ndGgiLCJsYXN0X29mZnNldCIsImxhc3RfYnVmZmVyIiwiYmluYXJ5JDAiLCJwYXlsb2FkJDMiLCJwcm9wZXJ0aWVzIiwicGF5bG9hZCQwIiwicGF5bG9hZCQxIiwiaGlnaF9ieXRlIiwibG93X2J5dGUiLCJjb2RlIiwicGF5bG9hZCQyIiwiYnl0ZXNfc2luY2VfZmx1c2giLCJvayIsImFib3J0IiwicmVhZGVyIiwib3V0Z29pbmdfbG9vcCIsImtpbmQiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvd2Vic29ja2V0Lm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7WUFhSUEsa0JBQWtCQyxRQUFPQztJQUlGO0tBQUEsUUFBQTtLQUFiQztLQUFSQztLQUNBQzthQU1BQyxNQUFPQyxR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QTVKdUJWLFFBdUpWOEM7SUFLb0I7YUFHakNqQixNQUFNYztLQUNSLGNBM0hFbEM7O2VBMEhKOztvQ0FBVWtDO2dCQS9KaUIzQzs7SUFxS3RCO0lBR0wsU0FBSStDLE1BQU1qQixLQUFPLE9BVGJELFlBU3VCO0lBRWQsSUFBVG1CLFNBQVMsaUNBdkZMeEIsTUE0RUpLLE9BU0FrQjtJQUdKLGlDQURJQyxRQTFLZ0JqRDthQTZLWmtEO2tCQStCTzlCLFFBQU9HLFFBQU9DO01BR3ZCLFNBSHVCQTtPQUlyQixNQUFBOztTQTNLSmQsa0JBMEhBb0IsTUF6SEFuQjtlQXNLeUJhO09BU25CLG1EQXJOaUJ2Qjs7T0F1TmpCOztpQkFYS21CLFFBQU9HLFFBQU9DO1NBNU1GdkI7TUF1TmpCLE9BMUNGaUQ7S0E4Q0M7a0JBN0JNOUIsUUFBT0csUUFBT0M7TUFDdkIsU0FEdUJBO09BRXJCLE1BQUE7O1NBM0pKZCxrQkEwSEFvQixNQXpIQW5CO2VBd0p5QmE7T0FPbkIsbURBck1pQnZCOztPQXVNakI7O2lCQVRLbUIsUUFBT0csUUFBT0M7U0E5TEZ2QjtNQXVNakIsT0ExQkZpRDtLQThCQzt5QkFkYSxPQXRDbEJ2QixNQVFBRyxPQWNJb0IsZUFnQndDO2tCQWJqQzlCLFFBQU9HLFFBQU9DLFFBQU9TLFFBQU9EO01BQ3JDLElBQUltQixPQUQwQmxCO2FBM0loQ3ZCO2dCQTBIQW9CLE1BekhBbkI7aUJBK0lJOztrQkFyTG1CVjtzQkFnTGdCK0I7a0JBQ2pDbUI7a0JBREsvQjtrQkFBT0c7a0JBQU9DO2dCQTNCekJzQix1QkFBQUEsdUJBMkJ5QnRCO3dCQTNCekJzQjttQkFFQW5CLE1BUUFHLE9BY0lvQjttQkFBQUE7S0FlQztLQWpCVCxPQUFBO3FDQTNLb0JsRCw0QkErSmhCOEIsT0FTQWtCO0lBcURVO0lBaERORTtJQW9EeUIsV0F0TjdCN0MsT0FvQkFJOztvQ0EvQkZWOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBEcmVhbSwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZFxuICAgZm9yIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9hYW50cm9uL2RyZWFtLlxuXG4gICBDb3B5cmlnaHQgMjAyMiBBbnRvbiBCYWNoaW4gKilcblxuXG5cbm1vZHVsZSBXZWJzb2NrZXRhZiA9IERyZWFtX3dlYnNvY2tldGFmLldlYnNvY2tldGFmXG5cbm1vZHVsZSBTdHJlYW0gPSBEcmVhbV9wdXJlLlN0cmVhbVxuXG5cblxubGV0IHdlYnNvY2tldF9oYW5kbGVyIHN0cmVhbSBzb2NrZXQgPVxuICAoKiBRdWV1ZSBvZiByZWNlaXZlZCBmcmFtZXMuIFRoZXJlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGEgbmljZSB3YXkgdG8gYWNoaWV2ZVxuICAgICBiYWNrcHJlc3N1cmUgd2l0aCB0aGUgY3VycmVudCBBUEkgb2Ygd2Vic29ja2V0L2FmLCBzbyB0aGF0IHdpbGwgaGF2ZSB0byBiZVxuICAgICBhZGRlZCBsYXRlci4gVGhlIHVzZXItZmFjaW5nIEFQSSBvZiBEcmVhbSBkb2VzIHN1cHBvcnQgYmFja3ByZXNzdXJlLiAqKVxuICBsZXQgZnJhbWVzLCBwdXNoX2ZyYW1lID0gTHd0X3N0cmVhbS5jcmVhdGUgKCkgaW5cbiAgbGV0IG1lc3NhZ2VfaXNfYmluYXJ5ID0gcmVmIGBCaW5hcnkgaW5cblxuICAoKiBGcmFtZSByZWFkZXIgY2FsbGVkIGJ5IHdlYnNvY2tldC9hZiBvbiBlYWNoIGZyYW1lIHJlY2VpdmVkLiBUaGVyZSBpcyBub1xuICAgICBnb29kIHdheSB0byB0cnVseSB0aHJvdHRsZSB0aGlzLCBoZW5jZSB0aGlzIGZyYW1lIHJlYWRlciBwdXNoZXMgZnJhbWVcbiAgICAgb2JqZWN0cyBpbnRvIHRoZSBhYm92ZSBmcmFtZSBxdWV1ZSBmb3IgdGhlIHJlYWRlciB0byB0YWtlIGZyb20gbGF0ZXIuIFNlZVxuICAgICBodHRwczovL2dpdGh1Yi5jb20vYW5tb250ZWlyby93ZWJzb2NrZXRhZi9pc3N1ZXMvMzQuICopXG4gIGxldCBmcmFtZSB+b3Bjb2RlIH5pc19maW4gfmxlbjpfIHBheWxvYWQgPVxuICAgIG1hdGNoIG9wY29kZSB3aXRoXG4gICAgfCBgQ29ubmVjdGlvbl9jbG9zZSAtPlxuICAgICAgcHVzaF9mcmFtZSAoU29tZSAoYENsb3NlLCBwYXlsb2FkKSlcbiAgICB8IGBQaW5nIC0+XG4gICAgICBwdXNoX2ZyYW1lIChTb21lIChgUGluZywgcGF5bG9hZCkpXG4gICAgfCBgUG9uZyAtPlxuICAgICAgcHVzaF9mcmFtZSAoU29tZSAoYFBvbmcsIHBheWxvYWQpKVxuICAgIHwgYE90aGVyIF8gLT5cbiAgICAgIHB1c2hfZnJhbWUgKFNvbWUgKGBPdGhlciwgcGF5bG9hZCkpXG4gICAgfCBgVGV4dCAtPlxuICAgICAgbWVzc2FnZV9pc19iaW5hcnkgOj0gYFRleHQ7XG4gICAgICBwdXNoX2ZyYW1lIChTb21lIChgRGF0YSAoYFRleHQsIGlzX2ZpbiksIHBheWxvYWQpKVxuICAgIHwgYEJpbmFyeSAtPlxuICAgICAgbWVzc2FnZV9pc19iaW5hcnkgOj0gYEJpbmFyeTtcbiAgICAgIHB1c2hfZnJhbWUgKFNvbWUgKGBEYXRhIChgQmluYXJ5LCBpc19maW4pLCBwYXlsb2FkKSlcbiAgICB8IGBDb250aW51YXRpb24gLT5cbiAgICAgIHB1c2hfZnJhbWUgKFNvbWUgKGBEYXRhICghbWVzc2FnZV9pc19iaW5hcnksIGlzX2ZpbiksIHBheWxvYWQpKVxuICBpblxuXG4gIGxldCBlb2YgKCkgPVxuICAgIHB1c2hfZnJhbWUgTm9uZSBpblxuXG4gICgqIFRoZSByZWFkZXIgcmV0cmlldmVzIHRoZSBuZXh0IGZyYW1lLiBJZiBpdCBpcyBhIGRhdGEgZnJhbWUsIGl0IGtlZXBzIGFcbiAgICAgcmVmZXJlbmNlIHRvIHRoZSBwYXlsb2FkIGFjcm9zcyBtdWx0aXBsZSByZWFkZXIgY2FsbHMsIHVudGlsIHRoZSBwYXlsb2FkIGlzXG4gICAgIGV4aGF1c3RlZC4gKilcbiAgbGV0IGNsb3NlZCA9IHJlZiBmYWxzZSBpblxuICBsZXQgY2xvc2VfY29kZSA9IHJlZiAxMDA1IGluXG4gIGxldCBjdXJyZW50X3BheWxvYWQgPSByZWYgTm9uZSBpblxuXG4gICgqIFVzZWQgdG8gY29udmVydCB0aGUgc2VwYXJhdGUgb25fZW9mIHBheWxvYWQgcmVhZGluZyBjYWxsYmFjayBpbnRvIGEgRklOIGJpdFxuICAgICBvbiB0aGUgbGFzdCBjaHVuayByZWFkLiBTZWVcbiAgICAgaHR0cHM6Ly9naXRodWIuY29tL2FubW9udGVpcm8vd2Vic29ja2V0YWYvaXNzdWVzLzM1LiAqKVxuICBsZXQgbGFzdF9jaHVuayA9IHJlZiBOb25lIGluXG4gICgqIFRPRE8gUmV2aWV3IHBlci1jaHVuayBhbGxvY2F0aW9ucywgaW5jbHVkaW5nIGN1cnJlbnRfcGF5bG9hZCBjb250ZW50cy4gKilcblxuICAoKiBGb3IgY29udHJvbCBmcmFtZXMsIHRoZSBwYXlsb2FkIGNhbiBiZSBhdCBtb3N0IDEyNSBieXRlcyBsb25nLiBXZSBhc3N1bWVcbiAgICAgdGhhdCB0aGUgZmlyc3QgY2h1bmsgd2lsbCBjb250YWluIHRoZSB3aG9sZSBwYXlsb2FkLCBhbmQgZGlzY2FyZCBhbnkgb3RoZXJcbiAgICAgY2h1bmtzIHRoYXQgbWF5IGJlIHJlcG9ydGVkIGJ5IHdlYnNvY2tldC9hZi4gKilcbiAgbGV0IGZpcnN0X2NodW5rX3JlY2VpdmVkID0gcmVmIGZhbHNlIGluXG4gIGxldCBmaXJzdF9jaHVuayA9IHJlZiBCaWdzdHJpbmdhZi5lbXB0eSBpblxuICBsZXQgZmlyc3RfY2h1bmtfb2Zmc2V0ID0gcmVmIDAgaW5cbiAgbGV0IGZpcnN0X2NodW5rX2xlbmd0aCA9IHJlZiAwIGluXG4gIGxldCByZWMgZHJhaW5fcGF5bG9hZCBwYXlsb2FkIGNvbnRpbnVhdGlvbiA9XG4gICAgV2Vic29ja2V0YWYuUGF5bG9hZC5zY2hlZHVsZV9yZWFkXG4gICAgICBwYXlsb2FkXG4gICAgICB+b25fcmVhZDooZnVuIGJ1ZmZlciB+b2ZmIH5sZW4gLT5cbiAgICAgICAgaWYgbm90ICFmaXJzdF9jaHVua19yZWNlaXZlZCB0aGVuIGJlZ2luXG4gICAgICAgICAgZmlyc3RfY2h1bmsgOj0gYnVmZmVyO1xuICAgICAgICAgIGZpcnN0X2NodW5rX29mZnNldCA6PSBvZmY7XG4gICAgICAgICAgZmlyc3RfY2h1bmtfbGVuZ3RoIDo9IGxlbjtcbiAgICAgICAgICBmaXJzdF9jaHVua19yZWNlaXZlZCA6PSB0cnVlXG4gICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgKCogVE9ETyBIb3cgdG8gaW50ZWdyYXRlIHRoaXMgdGhpbmcgd2l0aCBsb2dnaW5nPyAqKVxuICAgICAgICAgICgqIHdlYnNvY2tldF9sb2cud2FybmluZyAoZnVuIGxvZyAtPlxuICAgICAgICAgICAgbG9nIFwiUmVjZWl2ZWQgZnJhZ21lbnRlZCBjb250cm9sIGZyYW1lXCIpOyAqKVxuICAgICAgICAgICgpO1xuICAgICAgICBkcmFpbl9wYXlsb2FkIHBheWxvYWQgY29udGludWF0aW9uKVxuICAgICAgfm9uX2VvZjooZnVuICgpIC0+XG4gICAgICAgIGxldCBwYXlsb2FkID0gIWZpcnN0X2NodW5rIGluXG4gICAgICAgIGxldCBvZmZzZXQgPSAhZmlyc3RfY2h1bmtfb2Zmc2V0IGluXG4gICAgICAgIGxldCBsZW5ndGggPSAhZmlyc3RfY2h1bmtfbGVuZ3RoIGluXG4gICAgICAgIGZpcnN0X2NodW5rX3JlY2VpdmVkIDo9IGZhbHNlO1xuICAgICAgICBmaXJzdF9jaHVuayA6PSBCaWdzdHJpbmdhZi5lbXB0eTtcbiAgICAgICAgZmlyc3RfY2h1bmtfb2Zmc2V0IDo9IDA7XG4gICAgICAgIGZpcnN0X2NodW5rX2xlbmd0aCA6PSAwO1xuICAgICAgICBjb250aW51YXRpb24gcGF5bG9hZCBvZmZzZXQgbGVuZ3RoKVxuICBpblxuXG4gICgqIFRPRE8gQ2FuIHRoaXMgYmUgY2FuY2VsZWQgYnkgYSB1c2VyJ3MgY2xvc2U/IGkuZS4gd2lsbCB0aGF0IGV2ZW50dWFsbHlcbiAgICAgY2F1c2UgYSBjYWxsIHRvIGVvZiBhYm92ZT8gKilcbiAgbGV0IHJlYyByZWFkIH5kYXRhIH5mbHVzaCB+cGluZyB+cG9uZyB+Y2xvc2UgfmV4biA9XG4gICAgaWYgIWNsb3NlZCB0aGVuXG4gICAgICBjbG9zZSAhY2xvc2VfY29kZVxuICAgIGVsc2VcbiAgICAgIG1hdGNoICFjdXJyZW50X3BheWxvYWQgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIEx3dC5vbl9zdWNjZXNzIChMd3Rfc3RyZWFtLmdldCBmcmFtZXMpIGJlZ2luIGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGlmIG5vdCAhY2xvc2VkIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGNsb3NlZCA6PSB0cnVlO1xuICAgICAgICAgICAgY2xvc2VfY29kZSA6PSAxMDA1XG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIFdlYnNvY2tldGFmLldzZC5jbG9zZSBzb2NrZXQ7XG4gICAgICAgICAgY2xvc2UgIWNsb3NlX2NvZGVcbiAgICAgICAgfCBTb21lIChgQ2xvc2UsIHBheWxvYWQpIC0+XG4gICAgICAgICAgZHJhaW5fcGF5bG9hZCBwYXlsb2FkIEBAIGZ1biBidWZmZXIgb2Zmc2V0IGxlbmd0aCAtPlxuICAgICAgICAgIGxldCBjb2RlID1cbiAgICAgICAgICAgIGlmIGxlbmd0aCA8IDIgdGhlblxuICAgICAgICAgICAgICAxMDA1XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBoaWdoX2J5dGUgPSBDaGFyLmNvZGUgYnVmZmVyLntvZmZzZXR9XG4gICAgICAgICAgICAgIGFuZCBsb3dfYnl0ZSA9IENoYXIuY29kZSBidWZmZXIue29mZnNldCArIDF9IGluXG4gICAgICAgICAgICAgIGhpZ2hfYnl0ZSBsc2wgOCBsb3IgbG93X2J5dGVcbiAgICAgICAgICBpblxuICAgICAgICAgIGlmIG5vdCAhY2xvc2VkIHRoZW5cbiAgICAgICAgICAgIGNsb3NlX2NvZGUgOj0gY29kZTtcbiAgICAgICAgICBjbG9zZSAhY2xvc2VfY29kZVxuICAgICAgICB8IFNvbWUgKGBQaW5nLCBwYXlsb2FkKSAtPlxuICAgICAgICAgIGRyYWluX3BheWxvYWQgcGF5bG9hZCBAQFxuICAgICAgICAgIHBpbmdcbiAgICAgICAgfCBTb21lIChgUG9uZywgcGF5bG9hZCkgLT5cbiAgICAgICAgICBkcmFpbl9wYXlsb2FkIHBheWxvYWQgQEBcbiAgICAgICAgICBwb25nXG4gICAgICAgIHwgU29tZSAoYE90aGVyLCBwYXlsb2FkKSAtPlxuICAgICAgICAgIGRyYWluX3BheWxvYWQgcGF5bG9hZCBAQCBmdW4gX2J1ZmZlciBfb2Zmc2V0IGxlbmd0aCAtPlxuICAgICAgICAgIGlnbm9yZSBsZW5ndGg7ICgqIFRPRE8gbG9nIGluc3RlYWQgKilcbiAgICAgICAgICAoKiB3ZWJzb2NrZXRfbG9nLndhcm5pbmcgKGZ1biBsb2cgLT5cbiAgICAgICAgICAgIGxvZyBcIlVua25vd24gZnJhbWUgdHlwZSB3aXRoIGxlbmd0aCAlaVwiIGxlbmd0aCk7ICopXG4gICAgICAgICAgcmVhZCB+ZGF0YSB+Zmx1c2ggfnBpbmcgfnBvbmcgfmNsb3NlIH5leG5cbiAgICAgICAgfCBTb21lIChgRGF0YSBwcm9wZXJ0aWVzLCBwYXlsb2FkKSAtPlxuICAgICAgICAgIGN1cnJlbnRfcGF5bG9hZCA6PSBTb21lIChwcm9wZXJ0aWVzLCBwYXlsb2FkKTtcbiAgICAgICAgICByZWFkIH5kYXRhIH5mbHVzaCB+cGluZyB+cG9uZyB+Y2xvc2UgfmV4blxuICAgICAgICBlbmRcbiAgICAgIHwgU29tZSAoKGJpbmFyeSwgZmluKSwgcGF5bG9hZCkgLT5cbiAgICAgICAgV2Vic29ja2V0YWYuUGF5bG9hZC5zY2hlZHVsZV9yZWFkXG4gICAgICAgICAgcGF5bG9hZFxuICAgICAgICAgIH5vbl9yZWFkOihmdW4gYnVmZmVyIH5vZmYgfmxlbiAtPlxuICAgICAgICAgICAgbWF0Y2ggIWxhc3RfY2h1bmsgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGxhc3RfY2h1bmsgOj0gU29tZSAoYnVmZmVyLCBvZmYsIGxlbik7XG4gICAgICAgICAgICAgIHJlYWQgfmRhdGEgfmZsdXNoIH5waW5nIH5wb25nIH5jbG9zZSB+ZXhuXG4gICAgICAgICAgICB8IFNvbWUgKGxhc3RfYnVmZmVyLCBsYXN0X29mZnNldCwgbGFzdF9sZW5ndGgpIC0+XG4gICAgICAgICAgICAgIGxhc3RfY2h1bmsgOj0gU29tZSAoYnVmZmVyLCBvZmYsIGxlbik7XG4gICAgICAgICAgICAgIGxldCBiaW5hcnkgPSBiaW5hcnkgPSBgQmluYXJ5IGluXG4gICAgICAgICAgICAgIGRhdGEgbGFzdF9idWZmZXIgbGFzdF9vZmZzZXQgbGFzdF9sZW5ndGggYmluYXJ5IGZhbHNlKVxuICAgICAgICAgIH5vbl9lb2Y6KGZ1biAoKSAtPlxuICAgICAgICAgICAgY3VycmVudF9wYXlsb2FkIDo9IE5vbmU7XG4gICAgICAgICAgICBtYXRjaCAhbGFzdF9jaHVuayB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgcmVhZCB+ZGF0YSB+Zmx1c2ggfnBpbmcgfnBvbmcgfmNsb3NlIH5leG5cbiAgICAgICAgICAgIHwgU29tZSAobGFzdF9idWZmZXIsIGxhc3Rfb2Zmc2V0LCBsYXN0X2xlbmd0aCkgLT5cbiAgICAgICAgICAgICAgbGFzdF9jaHVuayA6PSBOb25lO1xuICAgICAgICAgICAgICBsZXQgYmluYXJ5ID0gYmluYXJ5ID0gYEJpbmFyeSBpblxuICAgICAgICAgICAgICBkYXRhIGxhc3RfYnVmZmVyIGxhc3Rfb2Zmc2V0IGxhc3RfbGVuZ3RoIGJpbmFyeSBmaW4pXG4gIGluXG5cbiAgbGV0IGJ5dGVzX3NpbmNlX2ZsdXNoID0gcmVmIDAgaW5cblxuICBsZXQgZmx1c2ggfmNsb3NlIG9rID1cbiAgICBieXRlc19zaW5jZV9mbHVzaCA6PSAwO1xuICAgIGlmICFjbG9zZWQgdGhlblxuICAgICAgY2xvc2UgIWNsb3NlX2NvZGVcbiAgICBlbHNlXG4gICAgICBXZWJzb2NrZXRhZi5Xc2QuZmx1c2hlZCBzb2NrZXQgb2tcbiAgaW5cblxuICBsZXQgY2xvc2UgY29kZSA9XG4gICAgaWYgbm90ICFjbG9zZWQgdGhlbiBiZWdpblxuICAgICAgKCogVE9ETyBSZWFsbHkgbmVlZCB0byB3b3JrIG91dCB0aGUgXCJjbG9zZSBoYW5kc2hha2VcIiBhbmQgaG93IGl0IGlzXG4gICAgICAgICBleHBvc2VkIGluIHRoZSBTdHJlYW0gQVBJLiAqKVxuICAgICAgKCogY2xvc2VkIDo9IHRydWU7ICopXG4gICAgICBXZWJzb2NrZXRhZi5Xc2QuY2xvc2UgfmNvZGU6KGBPdGhlciBjb2RlKSBzb2NrZXRcbiAgICBlbmRcbiAgaW5cblxuICBsZXQgYWJvcnQgX2V4biA9IGNsb3NlIDEwMDUgaW5cblxuICBsZXQgcmVhZGVyID0gU3RyZWFtLnJlYWRlciB+cmVhZCB+Y2xvc2UgfmFib3J0IGluXG4gIFN0cmVhbS5mb3J3YXJkIHJlYWRlciBzdHJlYW07XG5cbiAgbGV0IHJlYyBvdXRnb2luZ19sb29wICgpID1cbiAgICBTdHJlYW0ucmVhZFxuICAgICAgc3RyZWFtXG4gICAgICB+ZGF0YTooZnVuIGJ1ZmZlciBvZmZzZXQgbGVuZ3RoIGJpbmFyeSBmaW4gLT5cbiAgICAgICAgbGV0IGtpbmQgPSBpZiBiaW5hcnkgdGhlbiBgQmluYXJ5IGVsc2UgYFRleHQgaW5cbiAgICAgICAgaWYgIWNsb3NlZCB0aGVuXG4gICAgICAgICAgY2xvc2UgIWNsb3NlX2NvZGVcbiAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgIFdlYnNvY2tldGFmLldzZC5zY2hlZHVsZVxuICAgICAgICAgICAgc29ja2V0IH5pc19maW46ZmluIH5raW5kIGJ1ZmZlciB+b2ZmOm9mZnNldCB+bGVuOmxlbmd0aDtcbiAgICAgICAgICBieXRlc19zaW5jZV9mbHVzaCA6PSAhYnl0ZXNfc2luY2VfZmx1c2ggKyBsZW5ndGg7XG4gICAgICAgICAgaWYgIWJ5dGVzX3NpbmNlX2ZsdXNoID49IDQwOTYgdGhlblxuICAgICAgICAgICAgZmx1c2ggfmNsb3NlIG91dGdvaW5nX2xvb3BcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBvdXRnb2luZ19sb29wICgpXG4gICAgICAgIGVuZClcbiAgICAgIH5mbHVzaDooZnVuICgpIC0+IGZsdXNoIH5jbG9zZSBvdXRnb2luZ19sb29wKVxuICAgICAgfnBpbmc6KGZ1biBidWZmZXIgb2Zmc2V0IGxlbmd0aCAtPlxuICAgICAgICBpZiBsZW5ndGggPiAxMjUgdGhlblxuICAgICAgICAgIHJhaXNlIChGYWlsdXJlIFwiUGluZyBwYXlsb2FkIGNhbm5vdCBleGNlZWQgMTI1IGJ5dGVzXCIpO1xuICAgICAgICBpZiAhY2xvc2VkIHRoZW5cbiAgICAgICAgICBjbG9zZSAhY2xvc2VfY29kZVxuICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgaWYgbGVuZ3RoID0gMCB0aGVuXG4gICAgICAgICAgICBXZWJzb2NrZXRhZi5Xc2Quc2VuZF9waW5nIHNvY2tldFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIFdlYnNvY2tldGFmLldzZC5zZW5kX3BpbmdcbiAgICAgICAgICAgICAgfmFwcGxpY2F0aW9uX2RhdGE6e0ZhcmFkYXkuYnVmZmVyOyBvZmYgPSBvZmZzZXQ7IGxlbiA9IGxlbmd0aH1cbiAgICAgICAgICAgICAgc29ja2V0O1xuICAgICAgICAgIG91dGdvaW5nX2xvb3AgKClcbiAgICAgICAgZW5kKVxuICAgICAgfnBvbmc6KGZ1biBidWZmZXIgb2Zmc2V0IGxlbmd0aCAtPlxuICAgICAgICAoKiBUT0RPIElzIHRoZXJlIGFueSB3YXkgZm9yIHRoZSBwZWVyIHRvIHNlbmQgYSBwaW5nIHBheWxvYWQgd2l0aCBtb3JlXG4gICAgICAgICAgIHRoYW4gMTI1IGJ5dGVzLCBmb3JjaW5nIGEgdG9vLWxhcmdlIHBvbmcgYW5kIGFuIGV4Y2VwdGlvbj8gKilcbiAgICAgICAgaWYgbGVuZ3RoID4gMTI1IHRoZW5cbiAgICAgICAgICByYWlzZSAoRmFpbHVyZSBcIlBvbmcgcGF5bG9hZCBjYW5ub3QgZXhjZWVkIDEyNSBieXRlc1wiKTtcbiAgICAgICAgaWYgIWNsb3NlZCB0aGVuXG4gICAgICAgICAgY2xvc2UgIWNsb3NlX2NvZGVcbiAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgIGlmIGxlbmd0aCA9IDAgdGhlblxuICAgICAgICAgICAgV2Vic29ja2V0YWYuV3NkLnNlbmRfcG9uZyBzb2NrZXRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBXZWJzb2NrZXRhZi5Xc2Quc2VuZF9wb25nXG4gICAgICAgICAgICAgIH5hcHBsaWNhdGlvbl9kYXRhOntGYXJhZGF5LmJ1ZmZlcjsgb2ZmID0gb2Zmc2V0OyBsZW4gPSBsZW5ndGh9XG4gICAgICAgICAgICAgIHNvY2tldDtcbiAgICAgICAgICBvdXRnb2luZ19sb29wICgpXG4gICAgICAgIGVuZClcbiAgICAgIH5jbG9zZVxuICAgICAgfmV4bjphYm9ydFxuICBpblxuICBvdXRnb2luZ19sb29wICgpO1xuXG4gIFdlYnNvY2tldGFmLldlYnNvY2tldF9jb25uZWN0aW9uLntmcmFtZTsgZW9mfVxuIl19
