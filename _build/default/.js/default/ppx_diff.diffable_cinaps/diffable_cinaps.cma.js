// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Diffable_cinaps__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Diffable_cinaps = [0],
    Diffable_cinaps$0 = [0, Diffable_cinaps];
   runtime.caml_register_global(0, Diffable_cinaps$0, "Diffable_cinaps__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Diffable_cinaps__Tuple_helpers
//# unitInfo: Requires: Base, Base__List, Base__Printf, Base__String, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Ppx_string_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$43 = "",
    cst$45 = "\n",
    cst$39 = "\n\n",
    cst$48 = "\n\n        ",
    cst_module$6 = "\n\n        module ",
    cst_type$6 = "\n\n      type ",
    cst$47 = "\n          ",
    cst_open$2 = "\n          open ",
    cst_end_module$1 = "\n      end\n\n      module ",
    cst_module$7 = "\n      module ",
    cst_type$7 = "\n      type ",
    cst_module$8 = "\n    module ",
    cst$50 = "\n -> ",
    cst$41 = " ",
    cst$52 = " * ",
    cst$49 = " -> ",
    cst_local$4 = " -> local_ ",
    cst_to$3 = " -> to_: ",
    cst_sig$4 = " : sig\n        ",
    cst$51 = " = ",
    cst_struct$4 = " = struct\n        ",
    cst_Optional_diff_t$2 = " Optional_diff.t)",
    cst_deriving_sexp_bin_io$1 = " [@@deriving sexp, bin_io]",
    cst_list_local$1 = " list -> local_ ",
    cst_with_None_diff_Some_d$2 =
      " with\n               | None -> diff\n               | Some d -> ",
    cst$42 = "(",
    cst$40 = ")",
    cst$44 = ", ",
    cst_Variants_to_rank_t1$1 = ".Variants.to_rank t1) (",
    cst_t$4 = ".t",
    cst$46 = "?",
    cst_Diffable_cinaps_Tuple_help$0 = "Diffable_cinaps__Tuple_helpers",
    cst_exn = "_exn",
    cst_derived_on$1 = "derived_on",
    cst_diffable_cinaps$0 = "diffable_cinaps",
    cst_lib_cinaps_tuple_helpers_m = "lib/cinaps/tuple_helpers.ml",
    cst_local$3 = "local_ ",
    cst_t$3 = "t";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$32 = cst$40,
    cst$33 = cst$41,
    cst$34 = cst$42,
    cst$31 = cst$43,
    cst$30 = "\n          | _ :: _ -> ",
    cst$29 = "\n      | ",
    cst$27 = cst$46,
    cst$28 = "~",
    cst$26 = cst$41,
    cst$35 = cst$47,
    cst$36 = " =\n           ",
    cst$37 = " () =\n          ",
    cst$38 = cst$48,
    cst$21 = cst$44,
    cst$19 = ":",
    cst$20 = cst$46,
    cst$15 = cst$49,
    cst$16 = cst$49,
    cst$17 = cst$49,
    cst$18 = cst$49,
    cst$14 = cst$42,
    cst$10 = cst$40,
    cst$11 = cst$49,
    cst$12 = cst$49,
    cst$13 = cst$42,
    cst$22 = cst$47,
    cst$23 = cst$49,
    cst$24 = cst$49,
    cst$25 = cst$48,
    cst$8 = cst$51,
    cst$9 = cst$51,
    cst$7 = cst$51,
    cst$6 = cst$43,
    cst$0 = cst$43,
    cst$1 = cst$41,
    cst$2 = " =",
    cst$3 = " =\n          ",
    cst$4 = cst$41,
    cst$5 = cst$51,
    cst = cst$51,
    diff_module_name = "Diff",
    entry_diff_module_name = "Entry_diff",
    for_inlined_tuple_module_name = "For_inlined_tuple",
    max_supported =
      [0, 6, [0, cst_lib_cinaps_tuple_helpers_m, 334, 11197, 11220]],
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Ppx_string_runtime = global_data.Ppx_string_runtime,
    Base_Printf = global_data.Base__Printf,
    Base = global_data.Base,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Diffable_cinaps_Tuple_help$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_diffable_cinaps$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_lib_cinaps_tuple_helpers_m);
   caml_call2
    (Ppx_inline_test_lib[6], cst_diffable_cinaps$0, "tuple_helpers.ml");
   var
    _U_ = [0, cst$39],
    _T_ = [0, cst$39],
    cst_Variants = ".Variants.",
    _N_ = [0, [12, 95, [2, 0, 0]], "_%s"],
    cst_local$2 = cst_local$3,
    cst_failwith_BUG_non_empty_dif =
      'failwith "BUG: non-empty diff after apply"\n        ',
    _F_ = [0, ","],
    cst_match_diff_with = "\n          match diff with\n          | [] -> ",
    _G_ = [0, cst$43],
    cst_derived_on_in = " = derived_on in\n          ",
    _H_ = [0, cst$44],
    cst_derived_on_diff_let = " derived_on diff =\n          let ",
    _I_ = [0, cst$41],
    cst_match_diff_with_local_Opti =
      "\n            match diff with\n            | [] -> local_ Optional_diff.none\n            | _ :: _ -> local_ Optional_diff.return diff)\n\n\n        let apply_exn ",
    _J_ = [0, cst$43],
    cst_to_in_let_diff_in =
      " = to_ in\n            let diff = [] in\n            ",
    _K_ = [0, cst$44],
    cst_from_in_let = " = from in\n            let ",
    _L_ = [0, cst$44],
    cst_from_to_if_Base_phys_equal =
      " ~from ~to_ =\n          if Base.phys_equal from to_\n          then local_ Optional_diff.none\n          else (\n            let ",
    _M_ = [0, cst$41],
    cst_let_get = "\n        let get ",
    cst_d_acc_tl = " d :: acc) tl)\n         ",
    cst_d_ds_with_None_loop_acc_tl =
      " (d :: ds) with\n         | None -> loop acc tl\n         | Some d -> loop (",
    cst_x_x_assert_false_in_match_ =
      " x -> x\n          | _ -> assert false)\n        in\n        (match%optional.Optional_diff ",
    cst_true_false_in_let_ds_List_ =
      " _ -> true\n          | _ -> false)\n        in\n        let ds = List.map ds ~f:(function\n          | ",
    cst_d_tl_let_ds_tl_List_split_ =
      " d :: tl ->\n        let ds, tl = List.split_while tl ~f:(function\n          | ",
    cst_d_diff = " d :: diff\n            ",
    cst_with_None_diff_Some_d$0 = cst_with_None_diff_Some_d$2,
    cst_match_optional_Optional_di = " match%optional.Optional_diff ",
    cst_d_diff$0 = " d :: diff\n           ",
    cst_with_None_diff_Some_d$1 = cst_with_None_diff_Some_d$2,
    cst_match = " match ",
    cst_in = "\n          in\n        ",
    cst_let_diff = "let diff =\n            ",
    cst_diff$0 = "\n      diff",
    _E_ = [0, cst$45],
    cst_let_diff_in = "let diff = [] in\n      ",
    _D_ = [0, cst$41],
    cst_d_diff_in = " d :: diff\n          in\n       ",
    cst_with_None_diff_Some_d =
      " with\n            | None -> diff\n            | Some d -> ",
    cst_to$2 = " ~to_:",
    cst_from$2 = " ~from:",
    cst_let_diff_match_optional_Op =
      " let diff =\n            match%optional.Optional_diff ",
    cst_diff_in = ", diff\n         in\n         ",
    cst_d_tl = " d, tl\n          | _ -> ",
    cst_d_tl$0 = " d :: tl -> ",
    cst_diff_match_diff_with =
      ", diff =\n           match diff with\n          | ",
    cst_let = " let ",
    _y_ = [0, [2, 0, [4, 3, 0, 0, 0]], "%s%i"],
    _z_ = [0, [11, "{Gel.g = ", [2, 0, [12, 125, 0]]], "{Gel.g = %s}"],
    _v_ = [0, [11, "get", [4, 3, 0, 0, 0]], "get%i"],
    _w_ = [0, [11, "apply", [4, 3, 0, 0, [11, cst_exn, 0]]], "apply%i_exn"],
    _x_ =
      [0, [11, "of_list", [4, 3, 0, 0, [11, cst_exn, 0]]], "of_list%i_exn"],
    cst_from$1 = "from_",
    cst_to$1 = "to_",
    cst_derived_on$0 = cst_derived_on$1,
    cst_t$2 = cst_t$3,
    _A_ =
      [0,
       [12, 97, [4, 3, 0, 0, [11, "_diff_of_sexp", 0]]],
       "a%i_diff_of_sexp"],
    _B_ = [0, [12, 97, [4, 3, 0, 0, [11, "_of_sexp", 0]]], "a%i_of_sexp"],
    _C_ = [0, cst$41],
    _O_ = [0, cst$41],
    cst_in_local_Optional_diff_ret =
      "\n            in\n            local_ Optional_diff.return (loop [] diff)\n         ",
    _P_ = [0, cst$45],
    cst_ts_match_ts_with_local_Opt =
      " ts =\n        match ts with\n        | [] -> local_ Optional_diff.none\n        | _ :: _ ->\n          match List.concat ts |> List.stable_sort ~compare:compare_rank with\n          | [] -> local_ Optional_diff.return []\n          | _ :: _ as diff ->\n            let rec loop acc = function\n              | [] -> List.rev acc\n               ",
    cst_let_of_list_exn = "\n      let of_list_exn ",
    cst_let_of_list_exn_of_list_ex =
      "\n\n          let of_list_exn = of_list_exn\n        end\n      end\n    end\n       ",
    cst_open$0 = cst_open$2,
    cst_open$1 = cst_open$2,
    cst_struct$0 = " = struct\n          ",
    cst_module$3 = cst_module$6,
    cst_struct$1 = cst_struct$4,
    cst_end_module$0 = cst_end_module$1,
    cst_let_create_of_variants = "\n\n        let create_of_variants ",
    cst_Variants_to_name_dup_let_c =
      ".Variants.to_name dup)\n\n        let create ",
    cst_sexp_List_sort_compare_com =
      ' sexp |> List.sort ~compare:compare_rank in\n          match List.find_consecutive_duplicate l ~equal:equal_rank with\n          | None -> l\n          | Some (dup, _) ->\n           failwith ("Duplicate entry in tuple diff: " ^ ',
    cst_sexp_let_l_t_of_sexp = " sexp =\n          let l = t_of_sexp ",
    cst_let_singleton_entry_diff_e =
      "\n\n        let singleton entry_diff = [entry_diff]\n\n        let t_of_sexp ",
    cst_Variants_to_rank_t2 = ".Variants.to_rank t2)\n        ;;\n\n        ",
    cst_Variants_to_rank_t1 = cst_Variants_to_rank_t1$1,
    cst_Variants_to_rank_t2_let_eq =
      ".Variants.to_rank t2)\n        ;;\n\n        let equal_rank t1 t2 =\n          Int.equal (",
    cst_Variants_to_rank_t1$0 = cst_Variants_to_rank_t1$1,
    cst_let_compare_rank_t1_t2_Int =
      "\n\n        let compare_rank t1 t2 =\n          Int.compare (",
    cst_struct$2 = cst_struct$4,
    cst_module$4 = cst_module$7,
    cst_struct$3 = " = struct\n      ",
    cst_module$5 = cst_module$8,
    cst_Of_variant_t = ") Of_variant.t) ",
    cst_local$1 = ":local_ ((",
    _t_ = [0, cst$49],
    _s_ = [0, [11, cst_local$3, [2, 0, 0]], "local_ %s"],
    cst_Optional_diff_t$1 = " Optional_diff.t\n         ",
    cst_list_local$0 = cst_list_local$1,
    cst_val_of_list_exn = "\n\n        val of_list_exn : ",
    cst_Optional_diff_t_val_apply_ =
      " Optional_diff.t\n\n        val apply_exn : ",
    cst_local$0 = cst_local$4,
    cst_to$0 = cst_to$3,
    cst_from$0 = " -> from: ",
    cst_val_get = "\n        val get : ",
    cst_Optional_diff_t$0 = cst_Optional_diff_t$2,
    cst_list_local = cst_list_local$1,
    cst_Optional_diff_t = cst_Optional_diff_t$2,
    cst_local = cst_local$4,
    cst_to = cst_to$3,
    cst_from = "(from: ",
    _p_ = [0, cst$50],
    _q_ = [0, cst$50],
    _r_ = [0, cst$50],
    _u_ = [0, cst$49],
    cst_end_end_end = "\n        end\n      end\n    end\n       ",
    cst_sig$0 = " : sig\n          ",
    cst_module$0 = cst_module$6,
    cst_sig$1 = cst_sig$4,
    cst_end_module = cst_end_module$1,
    cst_val_create_of_variants = "\n\n        val create_of_variants : ",
    cst_unit = " -> unit -> ",
    cst_val_create = "\n\n        val create : ",
    cst_val_singleton = "\n\n        val singleton : ",
    cst_sig$2 = cst_sig$4,
    cst_module$1 = cst_module$7,
    cst_sig$3 = " : sig\n      ",
    cst_module$2 = cst_module$8,
    cst_deriving_sexp_bin_io_quick =
      " [@@deriving sexp, bin_io, quickcheck]\n  ",
    cst_type$4 = cst_type$6,
    cst_type$5 = cst_type$7,
    cst_deriving_sexp_bin_io$0 = cst_deriving_sexp_bin_io$1,
    _o_ = [0, cst$52],
    cst_type$3 = " type ",
    _m_ = [0, [11, "| ", [2, 0, [11, " of ", [2, 0, 0]]]], "| %s of %s"],
    _n_ = [0, cst$45],
    cst_private = " private",
    cst_open = "open ",
    cst_list_deriving_sexp_bin_io_ =
      " list [@@deriving sexp, bin_io, quickcheck]\n\n",
    cst_type$0 = cst_type$6,
    cst_deriving_variants_sexp_bin =
      "\n        [@@deriving variants, sexp, bin_io, quickcheck]\n      end\n      ",
    cst_type$1 = "\n        type ",
    cst_sig = ": sig",
    cst_struct = "= struct",
    cst_module = "\n\n      module ",
    cst_type$2 = cst_type$7,
    _l_ = [0, cst$52],
    cst_deriving_sexp_bin_io = cst_deriving_sexp_bin_io$1,
    cst_type = "type ",
    _e_ = [0, cst$44],
    _f_ = [0, [12, 40, [2, 0, [11, ") ", [2, 0, 0]]]], "(%s) %s"],
    _d_ = [0, [2, 0, [11, " Gel.t", 0]], "%s Gel.t"],
    _c_ = [0, [12, 116, [4, 3, 0, 0, 0]], "t%i"],
    cst_diff = "_diff",
    _b_ = [0, [11, "'a", [4, 3, 0, 0, 0]], "'a%i"],
    _a_ = [0, [11, "Tuple", [4, 3, 0, 0, 0]], "Tuple%i"],
    cst_t = cst_t$3,
    cst_derived_on = cst_derived_on$1,
    cst_t$0 = cst_t$4,
    cst_t$1 = cst_t$3,
    _i_ = [0, [2, 0, [11, cst_t$4, 0]], "%s.t"],
    _k_ = [0, [12, 84, [4, 3, 0, 0, 0]], "T%i"],
    _R_ = [0, 104758188],
    _S_ = [0, 104758188],
    cst_diffable_cinaps = cst_diffable_cinaps$0,
    cst_Diffable_cinaps_Tuple_help = cst_Diffable_cinaps_Tuple_help$0;
   function module_name(size){return caml_call2(Base_Printf[2], _a_, size);}
   function nums(size){
    function _ey_(_ez_){return 1 + _ez_ | 0;}
    return caml_call2(Base_List[40], size, _ey_);
   }
   function var$0(i){return caml_call2(Base_Printf[2], _b_, i);}
   function diff_var(i){
    var _ex_ = var$0(i);
    return caml_call2(Base[241], _ex_, cst_diff);
   }
   function create_arg(i){return caml_call2(Base_Printf[2], _c_, i);}
   function gel(i){
    var _ew_ = var$0(i);
    return caml_call2(Base_Printf[2], _d_, _ew_);
   }
   function vars(size){
    var _ev_ = nums(size);
    return caml_call2(Base_List[53], _ev_, var$0);
   }
   function diff_vars(size){
    var
     _es_ = nums(size),
     _et_ = caml_call2(Base_List[53], _es_, diff_var),
     _eu_ = vars(size);
    return caml_call2(Base[222], _eu_, _et_);
   }
   function type(name, vars, size){
    var
     _eq_ = caml_call1(vars, size),
     _er_ = caml_call2(Base_String[68], _e_, _eq_);
    return caml_call3(Base_Printf[2], _f_, _er_, name);
   }
   function t_type(_ep_){return type(cst_t, vars, _ep_);}
   function derived_on_type(_eo_){return type(cst_derived_on, vars, _eo_);}
   var
    _g_ =
      [0,
       entry_diff_module_name,
       [0, caml_call1(Ppx_string_runtime[1][2], cst_t$0), 0]],
    _h_ = caml_call1(Ppx_string_runtime[1][4], _g_);
   function entry_diff_type(_en_){return type(_h_, diff_vars, _en_);}
   function diff_type(_em_){return type(cst_t$1, diff_vars, _em_);}
   var
    _j_ = caml_call2(Base_Printf[2], _i_, diff_module_name),
    variant_name = caml_call1(Base_Printf[2], _k_);
   function type_declaration(size){
    var
     _eh_ = vars(size),
     tuple = caml_call2(Base_String[68], _l_, _eh_),
     _ei_ =
       [0,
        tuple,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_deriving_sexp_bin_io), 0]],
     _ej_ = [0, caml_call1(Ppx_string_runtime[1][2], cst), _ei_],
     _ek_ = [0, t_type(size), _ej_],
     _el_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type), _ek_];
    return caml_call1(Ppx_string_runtime[1][4], _el_);
   }
   function diff_type_declarations(size, signature){
    var maybe_private = signature ? cst_private : cst$6;
    if(signature)
     var maybe_open_entry_diff = cst$0;
    else
     var
      _ee_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_open),
         [0, entry_diff_module_name, 0]],
      maybe_open_entry_diff = caml_call1(Ppx_string_runtime[1][4], _ee_);
    var
     _dY_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_list_deriving_sexp_bin_io_),
        0],
     _dZ_ = [0, entry_diff_type(size), _dY_],
     _d0_ =
       [0,
        maybe_private,
        [0, caml_call1(Ppx_string_runtime[1][2], cst$1), _dZ_]],
     _d1_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$2), _d0_],
     _d2_ = [0, diff_type(size), _d1_],
     _d3_ =
       [0,
        maybe_open_entry_diff,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_type$0), _d2_]],
     _d4_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_deriving_variants_sexp_bin),
        _d3_];
    function _dV_(i){
     var _ef_ = diff_var(i), _eg_ = caml_call1(variant_name, i);
     return caml_call3(Base_Printf[2], _m_, _eg_, _ef_);
    }
    var
     _dW_ = nums(size),
     _dX_ = caml_call2(Base_List[53], _dW_, _dV_),
     _d5_ = [0, caml_call2(Base_String[68], _n_, _dX_), _d4_],
     _d6_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$3), _d5_],
     _d7_ = [0, diff_type(size), _d6_],
     _d8_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type$1), _d7_],
     _d9_ = signature ? cst_sig : cst_struct,
     _d__ =
       [0,
        entry_diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst$4), [0, _d9_, _d8_]]],
     _d$_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module), _d__],
     _ea_ = [0, t_type(size), _d$_],
     _eb_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$5), _ea_],
     _ec_ = [0, derived_on_type(size), _eb_],
     _ed_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type$2), _ec_];
    return caml_call1(Ppx_string_runtime[1][4], _ed_);
   }
   function for_inlined_tuple_type_declara(size){
    var
     _dO_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_deriving_sexp_bin_io$0),
        0],
     _dP_ = nums(size),
     _dQ_ = caml_call2(Base_List[53], _dP_, gel),
     _dR_ = [0, caml_call2(Base_String[68], _o_, _dQ_), _dO_],
     _dS_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$7), _dR_],
     _dT_ = [0, t_type(size), _dS_],
     _dU_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type$3), _dT_];
    return caml_call1(Ppx_string_runtime[1][4], _dU_);
   }
   function for_inlined_tuple_diff_type_de(size){
    var
     _dF_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_deriving_sexp_bin_io_quick),
        0],
     _dG_ = [0, type(_j_, diff_vars, size), _dF_],
     _dH_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$8), _dG_],
     _dI_ = [0, diff_type(size), _dH_],
     _dJ_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type$4), _dI_],
     _dK_ = [0, t_type(size), _dJ_],
     _dL_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$9), _dK_],
     _dM_ = [0, derived_on_type(size), _dL_],
     _dN_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type$5), _dM_];
    return caml_call1(Ppx_string_runtime[1][4], _dN_);
   }
   function tuple_mli(size){
    var
     nums$0 = nums(size),
     derived_on_type$0 = derived_on_type(size),
     diff_type$0 = diff_type(size);
    function _cr_(i){
     var
      _dy_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_Optional_diff_t), 0],
      _dz_ = [0, diff_var(i), _dy_],
      _dA_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_local), _dz_],
      _dB_ = [0, var$0(i), _dA_],
      _dC_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_to), _dB_],
      _dD_ = [0, var$0(i), _dC_],
      _dE_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_from), _dD_];
     return caml_call1(Ppx_string_runtime[1][4], _dE_);
    }
    var
     _cs_ = caml_call2(Base_List[53], nums$0, _cr_),
     get_functions = caml_call2(Base_String[68], _p_, _cs_);
    function _ct_(i){
     var
      _dr_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$10), 0],
      _ds_ = [0, var$0(i), _dr_],
      _dt_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$11), _ds_],
      _du_ = [0, diff_var(i), _dt_],
      _dv_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$12), _du_],
      _dw_ = [0, var$0(i), _dv_],
      _dx_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$13), _dw_];
     return caml_call1(Ppx_string_runtime[1][4], _dx_);
    }
    var
     apply_functions = caml_call2(Base_List[53], nums$0, _ct_),
     apply_functions$0 = caml_call2(Base_String[68], _q_, apply_functions);
    function _cu_(i){
     var
      _dm_ =
        [0, caml_call1(Ppx_string_runtime[1][2], cst_Optional_diff_t$0), 0],
      _dn_ = [0, diff_var(i), _dm_],
      _do_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_list_local), _dn_],
      _dp_ = [0, diff_var(i), _do_],
      _dq_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$14), _dp_];
     return caml_call1(Ppx_string_runtime[1][4], _dq_);
    }
    var of_list_functions = caml_call2(Base_List[53], nums$0, _cu_);
    function _cv_(param){
     var y = param[2], x = param[1];
     return [0, x, [0, y, 0]];
    }
    var
     _cw_ = caml_call2(Base_List[110], of_list_functions, apply_functions),
     _cx_ = caml_call2(Base_List[14], _cw_, _cv_),
     of_list_and_apply_functions = caml_call2(Base_String[68], _r_, _cx_);
    function function_declarations(local){
     var
      derived_on_type =
        local
         ? caml_call2(Base_Printf[2], _s_, derived_on_type$0)
         : derived_on_type$0,
      _da_ =
        [0,
         diff_type$0,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_Optional_diff_t$1), 0]],
      _db_ =
        [0,
         diff_type$0,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_list_local$0), _da_]],
      _dc_ =
        [0,
         of_list_and_apply_functions,
         [0, caml_call1(Ppx_string_runtime[1][2], cst$15), _db_]],
      _dd_ =
        [0,
         derived_on_type,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_val_of_list_exn), _dc_]],
      _de_ =
        [0,
         diff_type$0,
         [0, caml_call1(Ppx_string_runtime[1][2], cst$16), _dd_]],
      _df_ =
        [0,
         derived_on_type,
         [0, caml_call1(Ppx_string_runtime[1][2], cst$17), _de_]],
      _dg_ =
        [0,
         apply_functions$0,
         [0, caml_call1(Ppx_string_runtime[1][2], cst$18), _df_]],
      _dh_ =
        [0,
         diff_type$0,
         [0,
          caml_call1(Ppx_string_runtime[1][2], cst_Optional_diff_t_val_apply_),
          _dg_]],
      _di_ =
        [0,
         derived_on_type,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_local$0), _dh_]],
      _dj_ =
        [0,
         derived_on_type,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_to$0), _di_]],
      _dk_ =
        [0,
         get_functions,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_from$0), _dj_]],
      _dl_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_val_get), _dk_];
     return caml_call1(Ppx_string_runtime[1][4], _dl_);
    }
    function _cA_(i){
     var
      _c6_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_Of_variant_t), 0],
      _c7_ = [0, entry_diff_type(size), _c6_],
      _c8_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$21), _c7_],
      _c9_ = [0, diff_var(i), _c8_],
      _c__ = [0, caml_call1(Ppx_string_runtime[1][2], cst_local$1), _c9_],
      _c$_ = [0, create_arg(i), _c__];
     return caml_call1(Ppx_string_runtime[1][4], _c$_);
    }
    var
     _cB_ = caml_call2(Base_List[53], nums$0, _cA_),
     create_of_variants_args = caml_call2(Base_String[68], _u_, _cB_),
     _cC_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_end_end_end), 0],
     _cD_ = [0, function_declarations(1), _cC_],
     _cE_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$22), _cD_],
     _cF_ = [0, for_inlined_tuple_diff_type_de(size), _cE_],
     _cG_ =
       [0,
        diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_sig$0), _cF_]],
     _cH_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$0), _cG_],
     _cI_ = [0, for_inlined_tuple_type_declara(size), _cH_],
     _cJ_ =
       [0,
        for_inlined_tuple_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_sig$1), _cI_]],
     _cK_ =
       [0,
        diff_type$0,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_end_module), _cJ_]],
     _cL_ =
       [0,
        create_of_variants_args,
        [0, caml_call1(Ppx_string_runtime[1][2], cst$23), _cK_]],
     _cM_ =
       [0,
        diff_type$0,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_val_create_of_variants),
         _cL_]],
     _cN_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_unit), _cM_];
    function _cy_(i){
     var
      _c2_ = [0, diff_var(i), 0],
      _c3_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$19), _c2_],
      _c4_ = [0, create_arg(i), _c3_],
      _c5_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$20), _c4_];
     return caml_call1(Ppx_string_runtime[1][4], _c5_);
    }
    var
     _cz_ = caml_call2(Base_List[53], nums$0, _cy_),
     _cO_ = [0, caml_call2(Base_String[68], _t_, _cz_), _cN_],
     _cP_ =
       [0,
        diff_type$0,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_val_create), _cO_]],
     _cQ_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$24), _cP_],
     _cR_ = [0, entry_diff_type(size), _cQ_],
     _cS_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_val_singleton), _cR_],
     _cT_ = [0, function_declarations(0), _cS_],
     _cU_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$25), _cT_],
     _cV_ = [0, diff_type_declarations(size, 1), _cU_],
     _cW_ =
       [0,
        diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_sig$2), _cV_]],
     _cX_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$1), _cW_],
     _cY_ = [0, type_declaration(size), _cX_],
     _cZ_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_sig$3), _cY_],
     _c0_ = [0, module_name(size), _cZ_],
     _c1_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$2), _c0_];
    return caml_call1(Ppx_string_runtime[1][4], _c1_);
   }
   function tuple_ml(size){
    var
     nums$0 = nums(size),
     get = caml_call1(Base_Printf[2], _v_),
     apply = caml_call1(Base_Printf[2], _w_),
     of_list = caml_call1(Base_Printf[2], _x_);
    function maybe_gel(s, i, gel){
     var base = caml_call3(Base_Printf[2], _y_, s, i);
     return gel ? caml_call2(Base_Printf[2], _z_, base) : base;
    }
    function from(_cp_, _cq_){return maybe_gel(cst_from$1, _cp_, _cq_);}
    function to(_cn_, _co_){return maybe_gel(cst_to$1, _cn_, _co_);}
    function derived_on(_cl_, _cm_){
     return maybe_gel(cst_derived_on$0, _cl_, _cm_);
    }
    function t(_cj_, _ck_){return maybe_gel(cst_t$2, _cj_, _ck_);}
    function apply_diff(n){
     var
      _b__ = [0, caml_call1(Ppx_string_runtime[1][2], cst_diff_in), 0],
      _b$_ = [0, derived_on(n, 0), _b__],
      _ca_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_tl), _b$_],
      _cb_ = [0, derived_on(n, 0), _ca_],
      _cc_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$26), _cb_],
      _cd_ = [0, caml_call1(apply, n), _cc_],
      _ce_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_tl$0), _cd_],
      _cf_ = [0, caml_call1(variant_name, n), _ce_],
      _cg_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_diff_match_diff_with),
         _cf_],
      _ch_ = [0, t(n, 0), _cg_],
      _ci_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_let), _ch_];
     return caml_call1(Ppx_string_runtime[1][4], _ci_);
    }
    function get_diff(n){
     var
      _b1_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_diff_in), 0],
      _b2_ = [0, caml_call1(variant_name, n), _b1_],
      _b3_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_with_None_diff_Some_d),
         _b2_],
      _b4_ = [0, to(n, 0), _b3_],
      _b5_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_to$2), _b4_],
      _b6_ = [0, from(n, 0), _b5_],
      _b7_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_from$2), _b6_],
      _b8_ = [0, caml_call1(get, n), _b7_],
      _b9_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_let_diff_match_optional_Op),
         _b8_];
     return caml_call1(Ppx_string_runtime[1][4], _b9_);
    }
    var
     _X_ = caml_call1(Base_Printf[2], _A_),
     _Y_ = caml_call2(Base_List[53], nums$0, _X_),
     _Z_ = caml_call1(Base_Printf[2], _B_),
     ___ = caml_call2(Base_List[53], nums$0, _Z_),
     _$_ = caml_call2(Base[222], ___, _Y_),
     of_sexp_functions = caml_call2(Base_String[68], _C_, _$_);
    function create_args(optional){
     function _bX_(i){
      var _bZ_ = [0, create_arg(i), 0], _b0_ = optional ? cst$27 : cst$28;
      return caml_call1(Ppx_string_runtime[1][4], [0, _b0_, _bZ_]);
     }
     var _bY_ = caml_call2(Base_List[53], nums$0, _bX_);
     return caml_call2(Base_String[68], _D_, _bY_);
    }
    function create_function(value, option_or_optional_diff){
     function maybe_add_diff(i){
      var _bU_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_in), 0];
      if(898311236 <= option_or_optional_diff)
       var
        _bK_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_diff), 0],
        _bL_ = [0, caml_call1(variant_name, i), _bK_],
        _bM_ =
          [0,
           caml_call1(Ppx_string_runtime[1][2], cst_with_None_diff_Some_d$0),
           _bL_],
        _bN_ = [0, caml_call1(value, i), _bM_],
        _bO_ =
          [0,
           caml_call1
            (Ppx_string_runtime[1][2], cst_match_optional_Optional_di),
           _bN_],
        _bV_ = caml_call1(Ppx_string_runtime[1][4], _bO_);
      else
       var
        _bP_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_diff$0), 0],
        _bQ_ = [0, caml_call1(variant_name, i), _bP_],
        _bR_ =
          [0,
           caml_call1(Ppx_string_runtime[1][2], cst_with_None_diff_Some_d$1),
           _bQ_],
        _bS_ = [0, caml_call1(value, i), _bR_],
        _bT_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_match), _bS_],
        _bV_ = caml_call1(Ppx_string_runtime[1][4], _bT_);
      var
       _bW_ =
         [0,
          caml_call1(Ppx_string_runtime[1][2], cst_let_diff),
          [0, _bV_, _bU_]];
      return caml_call1(Ppx_string_runtime[1][4], _bW_);
     }
     var
      _bG_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_diff$0), 0],
      _bH_ = caml_call2(Base_List[66], nums$0, maybe_add_diff),
      _bI_ = [0, caml_call2(Base_String[68], _E_, _bH_), _bG_],
      _bJ_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_let_diff_in), _bI_];
     return caml_call1(Ppx_string_runtime[1][4], _bJ_);
    }
    function diff_of_list(i){
     var
      _bv_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_acc_tl), 0],
      _bw_ = [0, caml_call1(variant_name, i), _bv_],
      _bx_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_d_ds_with_None_loop_acc_tl),
         _bw_],
      _by_ = [0, caml_call1(of_list, i), _bx_],
      _bz_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_x_x_assert_false_in_match_),
         _by_],
      _bA_ = [0, caml_call1(variant_name, i), _bz_],
      _bB_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_true_false_in_let_ds_List_),
         _bA_],
      _bC_ = [0, caml_call1(variant_name, i), _bB_],
      _bD_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_d_tl_let_ds_tl_List_split_),
         _bC_],
      _bE_ = [0, caml_call1(variant_name, i), _bD_],
      _bF_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$29), _bE_];
     return caml_call1(Ppx_string_runtime[1][4], _bF_);
    }
    function function_implementations(local){
     var
      maybe_local = local ? cst_local$2 : cst$31,
      _aZ_ =
        [0,
         maybe_local,
         [0,
          caml_call1(Ppx_string_runtime[1][2], cst_failwith_BUG_non_empty_dif),
          0]],
      _a0_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$30), _aZ_];
     function _a1_(_bu_){return t(_bu_, local);}
     var
      _a2_ = caml_call2(Base_List[53], nums$0, _a1_),
      _a3_ =
        [0, maybe_local, [0, caml_call2(Base_String[68], _F_, _a2_), _a0_]],
      _a4_ =
        [0, caml_call1(Ppx_string_runtime[1][2], cst_match_diff_with), _a3_],
      _a5_ = caml_call2(Base_List[53], nums$0, apply_diff),
      _a6_ = [0, caml_call2(Base_String[68], _G_, _a5_), _a4_],
      _a7_ =
        [0, caml_call1(Ppx_string_runtime[1][2], cst_derived_on_in), _a6_];
     function _a8_(_bt_){return derived_on(_bt_, local);}
     var
      _a9_ = caml_call2(Base_List[53], nums$0, _a8_),
      _a__ = [0, caml_call2(Base_String[68], _H_, _a9_), _a7_],
      _a$_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_derived_on_diff_let),
         _a__],
      _ba_ = caml_call2(Base_List[53], nums$0, apply),
      _bb_ = [0, caml_call2(Base_String[68], _I_, _ba_), _a$_],
      _bc_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_match_diff_with_local_Opti),
         _bb_],
      _bd_ = caml_call2(Base_List[66], nums$0, get_diff),
      _be_ = [0, caml_call2(Base_String[68], _J_, _bd_), _bc_],
      _bf_ =
        [0, caml_call1(Ppx_string_runtime[1][2], cst_to_in_let_diff_in), _be_];
     function _bg_(_bs_){return to(_bs_, local);}
     var
      _bh_ = caml_call2(Base_List[53], nums$0, _bg_),
      _bi_ = [0, caml_call2(Base_String[68], _K_, _bh_), _bf_],
      _bj_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_from_in_let), _bi_];
     function _bk_(_br_){return from(_br_, local);}
     var
      _bl_ = caml_call2(Base_List[53], nums$0, _bk_),
      _bm_ = [0, caml_call2(Base_String[68], _L_, _bl_), _bj_],
      _bn_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_from_to_if_Base_phys_equal),
         _bm_],
      _bo_ = caml_call2(Base_List[53], nums$0, get),
      _bp_ = [0, caml_call2(Base_String[68], _M_, _bo_), _bn_],
      _bq_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_let_get), _bp_];
     return caml_call1(Ppx_string_runtime[1][4], _bq_);
    }
    function _aa_(x){
     var
      _aX_ = caml_call1(apply, x),
      _aY_ = [0, caml_call2(Base_Printf[2], _N_, _aX_), 0];
     return [0, caml_call1(of_list, x), _aY_];
    }
    var
     _ab_ = caml_call2(Base_List[14], nums$0, _aa_),
     of_list_and_apply_functions = caml_call2(Base_String[68], _O_, _ab_),
     _ac_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_in_local_Optional_diff_ret),
        0],
     _ad_ = caml_call2(Base_List[53], nums$0, diff_of_list),
     _ae_ = [0, caml_call2(Base_String[68], _P_, _ad_), _ac_],
     _af_ =
       [0,
        of_list_and_apply_functions,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_ts_match_ts_with_local_Opt),
         _ae_]],
     _ag_ =
       [0, caml_call1(Ppx_string_runtime[1][2], cst_let_of_list_exn), _af_],
     of_list_function = caml_call1(Ppx_string_runtime[1][4], _ag_);
    function create_arg_of_variant(i){
     var
      _aR_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$32), 0],
      _aS_ = [0, create_arg(i), _aR_],
      _aT_ =
        [0,
         entry_diff_module_name,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_Variants), _aS_]],
      _aU_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$33), _aT_],
      _aV_ = [0, create_arg(i), _aU_],
      _aW_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$34), _aV_];
     return caml_call1(Ppx_string_runtime[1][4], _aW_);
    }
    var
     _ah_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_let_of_list_exn_of_list_ex),
        0],
     _ai_ = [0, function_implementations(1), _ah_],
     _aj_ =
       [0,
        entry_diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst$35), _ai_]],
     _ak_ =
       [0,
        diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_open$0), _aj_]],
     _al_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_open$1), _ak_],
     _am_ = [0, for_inlined_tuple_diff_type_de(size), _al_],
     _an_ =
       [0,
        diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_struct$0), _am_]],
     _ao_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$3), _an_],
     _ap_ = [0, for_inlined_tuple_type_declara(size), _ao_],
     _aq_ =
       [0,
        for_inlined_tuple_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_struct$1), _ap_]],
     _ar_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_end_module$0), _aq_],
     _as_ = [0, create_function(create_arg_of_variant, 898311236), _ar_],
     _at_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$36), _as_],
     _au_ = [0, create_args(0), _at_],
     _av_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_let_create_of_variants),
        _au_],
     _aw_ = [0, create_function(create_arg, 729469813), _av_],
     _ax_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$37), _aw_],
     _ay_ = [0, create_args(1), _ax_],
     _az_ =
       [0,
        entry_diff_module_name,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_Variants_to_name_dup_let_c),
         _ay_]],
     _aA_ =
       [0,
        of_sexp_functions,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_sexp_List_sort_compare_com),
         _az_]],
     _aB_ =
       [0,
        of_sexp_functions,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_sexp_let_l_t_of_sexp),
         _aA_]],
     _aC_ =
       [0,
        of_list_function,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_let_singleton_entry_diff_e),
         _aB_]],
     _aD_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$38), _aC_],
     _aE_ = [0, function_implementations(0), _aD_],
     _aF_ =
       [0,
        entry_diff_module_name,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_Variants_to_rank_t2),
         _aE_]],
     _aG_ =
       [0,
        entry_diff_module_name,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_Variants_to_rank_t1),
         _aF_]],
     _aH_ =
       [0,
        entry_diff_module_name,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_Variants_to_rank_t2_let_eq),
         _aG_]],
     _aI_ =
       [0,
        entry_diff_module_name,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_Variants_to_rank_t1$0),
         _aH_]],
     _aJ_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_let_compare_rank_t1_t2_Int),
        _aI_],
     _aK_ = [0, diff_type_declarations(size, 0), _aJ_],
     _aL_ =
       [0,
        diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_struct$2), _aK_]],
     _aM_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$4), _aL_],
     _aN_ = [0, type_declaration(size), _aM_],
     _aO_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_struct$3), _aN_],
     _aP_ = [0, module_name(size), _aO_],
     _aQ_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$5), _aP_];
    return caml_call1(Ppx_string_runtime[1][4], _aQ_);
   }
   var
    _Q_ = caml_call1(Base[242], max_supported),
    l = caml_call5(Base_List[132], 0, _S_, _R_, 2, _Q_);
   function tuples_mli(param){
    var _W_ = caml_call2(Base_List[53], l, tuple_mli);
    return caml_call2(Base_String[68], _T_, _W_);
   }
   function tuples_ml(param){
    var _V_ = caml_call2(Base_List[53], l, tuple_ml);
    return caml_call2(Base_String[68], _U_, _V_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_diffable_cinaps);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Diffable_cinaps_Tuple_help);
   var
    Diffable_cinaps_Tuple_helpers = [0, max_supported, tuples_mli, tuples_ml];
   runtime.caml_register_global
    (220, Diffable_cinaps_Tuple_helpers, cst_Diffable_cinaps_Tuple_help$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Diffable_cinaps
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Diffable_cinaps = "Diffable_cinaps",
    cst_diffable_cinaps = "diffable_cinaps";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Diffable_cinaps);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_diffable_cinaps);
   caml_call1(Ppx_expect_runtime[1][1], "lib/cinaps/diffable_cinaps.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_diffable_cinaps, "diffable_cinaps.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_diffable_cinaps);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Diffable_cinaps);
   var Diffable_cinaps = [0];
   runtime.caml_register_global(11, Diffable_cinaps, cst_Diffable_cinaps);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJkaWZmYWJsZV9jaW5hcHMuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImRpZmZfbW9kdWxlX25hbWUiLCJlbnRyeV9kaWZmX21vZHVsZV9uYW1lIiwiZm9yX2lubGluZWRfdHVwbGVfbW9kdWxlX25hbWUiLCJtYXhfc3VwcG9ydGVkIiwibW9kdWxlX25hbWUiLCJzaXplIiwibnVtcyIsInZhciQwIiwiaSIsImRpZmZfdmFyIiwiY3JlYXRlX2FyZyIsImdlbCIsInZhcnMiLCJkaWZmX3ZhcnMiLCJ0eXBlIiwibmFtZSIsInRfdHlwZSIsImRlcml2ZWRfb25fdHlwZSIsImVudHJ5X2RpZmZfdHlwZSIsImRpZmZfdHlwZSIsInZhcmlhbnRfbmFtZSIsInR5cGVfZGVjbGFyYXRpb24iLCJ0dXBsZSIsImRpZmZfdHlwZV9kZWNsYXJhdGlvbnMiLCJzaWduYXR1cmUiLCJtYXliZV9wcml2YXRlIiwibWF5YmVfb3Blbl9lbnRyeV9kaWZmIiwiZm9yX2lubGluZWRfdHVwbGVfdHlwZV9kZWNsYXJhIiwiZm9yX2lubGluZWRfdHVwbGVfZGlmZl90eXBlX2RlIiwidHVwbGVfbWxpIiwibnVtcyQwIiwiZGVyaXZlZF9vbl90eXBlJDAiLCJkaWZmX3R5cGUkMCIsImdldF9mdW5jdGlvbnMiLCJhcHBseV9mdW5jdGlvbnMiLCJhcHBseV9mdW5jdGlvbnMkMCIsIm9mX2xpc3RfZnVuY3Rpb25zIiwieSIsIngiLCJvZl9saXN0X2FuZF9hcHBseV9mdW5jdGlvbnMiLCJmdW5jdGlvbl9kZWNsYXJhdGlvbnMiLCJsb2NhbCIsImNyZWF0ZV9vZl92YXJpYW50c19hcmdzIiwidHVwbGVfbWwiLCJnZXQiLCJhcHBseSIsIm9mX2xpc3QiLCJtYXliZV9nZWwiLCJzIiwiYmFzZSIsImZyb20iLCJ0byIsImRlcml2ZWRfb24iLCJ0IiwiYXBwbHlfZGlmZiIsIm4iLCJnZXRfZGlmZiIsIm9mX3NleHBfZnVuY3Rpb25zIiwiY3JlYXRlX2FyZ3MiLCJvcHRpb25hbCIsImNyZWF0ZV9mdW5jdGlvbiIsInZhbHVlIiwib3B0aW9uX29yX29wdGlvbmFsX2RpZmYiLCJtYXliZV9hZGRfZGlmZiIsImRpZmZfb2ZfbGlzdCIsImZ1bmN0aW9uX2ltcGxlbWVudGF0aW9ucyIsIm1heWJlX2xvY2FsIiwib2ZfbGlzdF9mdW5jdGlvbiIsImNyZWF0ZV9hcmdfb2ZfdmFyaWFudCIsImwiLCJ0dXBsZXNfbWxpIiwidHVwbGVzX21sIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcHB4X2RpZmYvZGlmZmFibGVfY2luYXBzL2RpZmZhYmxlX2NpbmFwc19fLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcHB4X2RpZmYvZGlmZmFibGVfY2luYXBzL3R1cGxlX2hlbHBlcnMubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FLMkI7O0lBQUE7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ0R2QkE7SUFDQUM7SUFDQUM7SUF1VUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBMVVBQyxZQUFhQyxNQUFPLE9BQUEsZ0NBQVBBLE1BQTZCO1lBSTFDQyxLQUFNRDtJQUF5QixvQjtJQUFBLE9BQUEsMEJBQXpCQTtHQUFrQztZQUN4Q0UsTUFBSUMsR0FBSSxPQUFBLGdDQUFKQSxHQUFvQjtZQUN4QkMsU0FBU0Q7SUFB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O0lBQUEsT0FBQTtHQWdEUTtHQUk4QztJQUFBLE1BQUEsc0JBRHBERjtJQUNBa0UsSUFBSTtZQUNKQztJQUFnQixVQUFBLDBCQURoQkQsR0F4UUF4QztJQXlRZ0IsT0FBQTtHQUFvRDtZQUNwRTBDO0lBQWUsVUFBQSwwQkFGZkYsR0EzTEExQjtJQTZMZSxPQUFBO0dBQW1EOzs7Ozs7d0NBSGxFeEMsZUFFQW1FLFlBQ0FDOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIERpZmZhYmxlX2NpbmFwcy5UdXBsZV9oZWxwZXJzICopXG5tb2R1bGUgVHVwbGVfaGVscGVycyA9IERpZmZhYmxlX2NpbmFwc19fVHVwbGVfaGVscGVyc1xuXG5tb2R1bGUgRGlmZmFibGVfY2luYXBzX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsIm9wZW4hIEJhc2Vcbm9wZW4gUHJpbnRmXG5cbmxldCBtb2R1bGVfbmFtZSB+c2l6ZSA9IHNwcmludGYgXCJUdXBsZSVpXCIgc2l6ZVxubGV0IGRpZmZfbW9kdWxlX25hbWUgPSBcIkRpZmZcIlxubGV0IGVudHJ5X2RpZmZfbW9kdWxlX25hbWUgPSBcIkVudHJ5X2RpZmZcIlxubGV0IGZvcl9pbmxpbmVkX3R1cGxlX21vZHVsZV9uYW1lID0gXCJGb3JfaW5saW5lZF90dXBsZVwiXG5sZXQgbnVtcyB+c2l6ZSA9IExpc3QuaW5pdCBzaXplIH5mOigoICsgKSAxKVxubGV0IHZhciBpID0gc3ByaW50ZiBcIidhJWlcIiBpXG5sZXQgZGlmZl92YXIgaSA9IHZhciBpIF4gXCJfZGlmZlwiXG5sZXQgY3JlYXRlX2FyZyBpID0gc3ByaW50ZiBcInQlaVwiIGlcbmxldCBnZWwgaSA9IHNwcmludGYgXCIlcyBHZWwudFwiICh2YXIgaSlcbmxldCB2YXJzIH5zaXplID0gTGlzdC5tYXAgKG51bXMgfnNpemUpIH5mOnZhclxubGV0IGRpZmZfdmFycyB+c2l6ZSA9IHZhcnMgfnNpemUgQCBMaXN0Lm1hcCAobnVtcyB+c2l6ZSkgfmY6ZGlmZl92YXJcblxubGV0IHR5cGVfIH5uYW1lIH52YXJzIH5zaXplID1cbiAgc3ByaW50ZiBcIiglcykgJXNcIiAoU3RyaW5nLmNvbmNhdCAodmFycyB+c2l6ZSkgfnNlcDpcIiwgXCIpIG5hbWVcbjs7XG5cbmxldCB0X3R5cGUgPSB0eXBlXyB+bmFtZTpcInRcIiB+dmFyc1xubGV0IGRlcml2ZWRfb25fdHlwZSA9IHR5cGVfIH5uYW1lOlwiZGVyaXZlZF9vblwiIH52YXJzXG5sZXQgZW50cnlfZGlmZl90eXBlID0gdHlwZV8gfm5hbWU6WyVzdHJpbmcgXCIle2VudHJ5X2RpZmZfbW9kdWxlX25hbWV9LnRcIl0gfnZhcnM6ZGlmZl92YXJzXG5sZXQgZGlmZl90eXBlID0gdHlwZV8gfm5hbWU6XCJ0XCIgfnZhcnM6ZGlmZl92YXJzXG5sZXQgZGlmZl90eXBlX3JlZmVyZW5jZSA9IHR5cGVfIH5uYW1lOihzcHJpbnRmIFwiJXMudFwiIGRpZmZfbW9kdWxlX25hbWUpIH52YXJzOmRpZmZfdmFyc1xubGV0IHZhcmlhbnRfbmFtZSA9IHNwcmludGYgXCJUJWlcIlxuXG5sZXQgdHlwZV9kZWNsYXJhdGlvbiB+c2l6ZSA9XG4gIGxldCB0dXBsZSA9IFN0cmluZy5jb25jYXQgKHZhcnMgfnNpemUpIH5zZXA6XCIgKiBcIiBpblxuICBbJXN0cmluZyB7fHR5cGUgJXt0X3R5cGUgfnNpemV9ID0gJXt0dXBsZX0gW0BAZGVyaXZpbmcgc2V4cCwgYmluX2lvXXx9XVxuOztcblxubGV0IGRpZmZfdHlwZV9kZWNsYXJhdGlvbnMgfnNpemUgfnNpZ25hdHVyZSA9XG4gIGxldCBtYXliZV9wcml2YXRlID0gaWYgc2lnbmF0dXJlIHRoZW4gXCIgcHJpdmF0ZVwiIGVsc2UgXCJcIiBpblxuICBsZXQgdmFyaWFudHMgfnNpemUgPVxuICAgIExpc3QubWFwIChudW1zIH5zaXplKSB+ZjooZnVuIGkgLT4gc3ByaW50ZiBcInwgJXMgb2YgJXNcIiAodmFyaWFudF9uYW1lIGkpIChkaWZmX3ZhciBpKSlcbiAgICB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCJcXG5cIlxuICBpblxuICBsZXQgbWF5YmVfb3Blbl9lbnRyeV9kaWZmID1cbiAgICBpZiBzaWduYXR1cmUgdGhlbiBcIlwiIGVsc2UgWyVzdHJpbmcge3xvcGVuICV7ZW50cnlfZGlmZl9tb2R1bGVfbmFtZX18fV1cbiAgaW5cbiAgWyVzdHJpbmdcbiAgICB7fFxuICAgICAgdHlwZSAle2Rlcml2ZWRfb25fdHlwZSB+c2l6ZX0gPSAle3RfdHlwZSB+c2l6ZX1cblxuICAgICAgbW9kdWxlICV7ZW50cnlfZGlmZl9tb2R1bGVfbmFtZX0gJXtpZiBzaWduYXR1cmUgdGhlbiBcIjogc2lnXCIgZWxzZSBcIj0gc3RydWN0XCJ9XG4gICAgICAgIHR5cGUgJXtkaWZmX3R5cGUgfnNpemV9ID1cbiAgICAgICAgICAle3ZhcmlhbnRzIH5zaXplfVxuICAgICAgICBbQEBkZXJpdmluZyB2YXJpYW50cywgc2V4cCwgYmluX2lvLCBxdWlja2NoZWNrXVxuICAgICAgZW5kXG4gICAgICAle21heWJlX29wZW5fZW50cnlfZGlmZn1cblxuICAgICAgdHlwZSAle2RpZmZfdHlwZSB+c2l6ZX0gPSV7bWF5YmVfcHJpdmF0ZX0gJXtlbnRyeV9kaWZmX3R5cGUgfnNpemV9IGxpc3QgW0BAZGVyaXZpbmcgc2V4cCwgYmluX2lvLCBxdWlja2NoZWNrXVxuXG58fV1cbjs7XG5cbmxldCBmb3JfaW5saW5lZF90dXBsZV90eXBlX2RlY2xhcmF0aW9uIH5zaXplID1cbiAgWyVzdHJpbmdcbiAgICB7fCB0eXBlICV7dF90eXBlIH5zaXplfSA9ICV7TGlzdC5tYXAgKG51bXMgfnNpemUpIH5mOmdlbCB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCIgKiBcIn0gW0BAZGVyaXZpbmcgc2V4cCwgYmluX2lvXXx9XVxuOztcblxubGV0IGZvcl9pbmxpbmVkX3R1cGxlX2RpZmZfdHlwZV9kZWNsYXJhdGlvbnMgfnNpemUgPVxuICBbJXN0cmluZ1xuICAgIHt8XG4gICAgICB0eXBlICV7ZGVyaXZlZF9vbl90eXBlIH5zaXplfSA9ICV7dF90eXBlIH5zaXplfVxuXG4gICAgICB0eXBlICV7ZGlmZl90eXBlIH5zaXplfSA9ICV7ZGlmZl90eXBlX3JlZmVyZW5jZSB+c2l6ZX0gW0BAZGVyaXZpbmcgc2V4cCwgYmluX2lvLCBxdWlja2NoZWNrXVxuICB8fV1cbjs7XG5cbmxldCB0dXBsZV9tbGkgc2l6ZSA9XG4gIGxldCBudW1zID0gbnVtcyB+c2l6ZSBpblxuICBsZXQgZGVyaXZlZF9vbl90eXBlID0gZGVyaXZlZF9vbl90eXBlIH5zaXplIGluXG4gIGxldCBkaWZmX3R5cGUgPSBkaWZmX3R5cGUgfnNpemUgaW5cbiAgbGV0IGdldF9mdW5jdGlvbnMgPVxuICAgIExpc3QubWFwIG51bXMgfmY6KGZ1biBpIC0+XG4gICAgICBbJXN0cmluZ1xuICAgICAgICB7fChmcm9tOiAle3ZhciBpfSAtPiB0b186ICV7dmFyIGl9IC0+IGxvY2FsXyAle2RpZmZfdmFyIGl9IE9wdGlvbmFsX2RpZmYudCl8fV0pXG4gICAgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuIC0+IFwiXG4gIGluXG4gIGxldCBhcHBseV9mdW5jdGlvbnMnID1cbiAgICBMaXN0Lm1hcCBudW1zIH5mOihmdW4gaSAtPiBbJXN0cmluZyB7fCgle3ZhciBpfSAtPiAle2RpZmZfdmFyIGl9IC0+ICV7dmFyIGl9KXx9XSlcbiAgaW5cbiAgbGV0IGFwcGx5X2Z1bmN0aW9ucyA9IGFwcGx5X2Z1bmN0aW9ucycgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuIC0+IFwiIGluXG4gIGxldCBvZl9saXN0X2Z1bmN0aW9ucycgPVxuICAgIExpc3QubWFwIG51bXMgfmY6KGZ1biBpIC0+XG4gICAgICBbJXN0cmluZyB7fCgle2RpZmZfdmFyIGl9IGxpc3QgLT4gbG9jYWxfICV7ZGlmZl92YXIgaX0gT3B0aW9uYWxfZGlmZi50KXx9XSlcbiAgaW5cbiAgbGV0IG9mX2xpc3RfYW5kX2FwcGx5X2Z1bmN0aW9ucyA9XG4gICAgTGlzdC56aXBfZXhuIG9mX2xpc3RfZnVuY3Rpb25zJyBhcHBseV9mdW5jdGlvbnMnXG4gICAgfD4gTGlzdC5jb25jYXRfbWFwIH5mOihmdW4gKHgsIHkpIC0+IFsgeDsgeSBdKVxuICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcbiAtPiBcIlxuICBpblxuICBsZXQgZnVuY3Rpb25fZGVjbGFyYXRpb25zIH5sb2NhbCA9XG4gICAgbGV0IGRlcml2ZWRfb25fdHlwZSA9XG4gICAgICBpZiBsb2NhbCB0aGVuIHNwcmludGYgXCJsb2NhbF8gJXNcIiBkZXJpdmVkX29uX3R5cGUgZWxzZSBkZXJpdmVkX29uX3R5cGVcbiAgICBpblxuICAgIFslc3RyaW5nXG4gICAgICB7fFxuICAgICAgICB2YWwgZ2V0IDogJXtnZXRfZnVuY3Rpb25zfSAtPiBmcm9tOiAle2Rlcml2ZWRfb25fdHlwZX0gLT4gdG9fOiAle2Rlcml2ZWRfb25fdHlwZX0gLT4gbG9jYWxfICV7ZGlmZl90eXBlfSBPcHRpb25hbF9kaWZmLnRcblxuICAgICAgICB2YWwgYXBwbHlfZXhuIDogJXthcHBseV9mdW5jdGlvbnN9IC0+ICV7ZGVyaXZlZF9vbl90eXBlfSAtPiAle2RpZmZfdHlwZX0gLT4gJXtkZXJpdmVkX29uX3R5cGV9XG5cbiAgICAgICAgdmFsIG9mX2xpc3RfZXhuIDogJXtvZl9saXN0X2FuZF9hcHBseV9mdW5jdGlvbnN9IC0+ICV7ZGlmZl90eXBlfSBsaXN0IC0+IGxvY2FsXyAle2RpZmZfdHlwZX0gT3B0aW9uYWxfZGlmZi50XG4gICAgICAgICB8fV1cbiAgaW5cbiAgbGV0IGNyZWF0ZV9hcmdzIH5vcHRpb25hbCA9XG4gICAgTGlzdC5tYXAgbnVtcyB+ZjooZnVuIGkgLT5cbiAgICAgIGlmIG9wdGlvbmFsXG4gICAgICB0aGVuIFslc3RyaW5nIHt8PyV7Y3JlYXRlX2FyZyBpfTole2RpZmZfdmFyIGl9fH1dXG4gICAgICBlbHNlIFslc3RyaW5nIHt8JXtjcmVhdGVfYXJnIGl9OiV7ZGlmZl92YXIgaX0gb3B0aW9ufH1dKVxuICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiAtPiBcIlxuICBpblxuICBsZXQgY3JlYXRlX29mX3ZhcmlhbnRzX2FyZ3MgPVxuICAgIExpc3QubWFwIG51bXMgfmY6KGZ1biBpIC0+XG4gICAgICBbJXN0cmluZ1xuICAgICAgICB7fCV7Y3JlYXRlX2FyZyBpfTpsb2NhbF8gKCgle2RpZmZfdmFyIGl9LCAle2VudHJ5X2RpZmZfdHlwZSB+c2l6ZX0pIE9mX3ZhcmlhbnQudCkgfH1dKVxuICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiAtPiBcIlxuICBpblxuICBbJXN0cmluZ1xuICAgIHt8XG4gICAgbW9kdWxlICV7bW9kdWxlX25hbWUgfnNpemV9IDogc2lnXG4gICAgICAle3R5cGVfZGVjbGFyYXRpb24gfnNpemV9XG4gICAgICBtb2R1bGUgJXtkaWZmX21vZHVsZV9uYW1lfSA6IHNpZ1xuICAgICAgICAle2RpZmZfdHlwZV9kZWNsYXJhdGlvbnMgfnNpemUgfnNpZ25hdHVyZTp0cnVlfVxuXG4gICAgICAgICV7ZnVuY3Rpb25fZGVjbGFyYXRpb25zIH5sb2NhbDpmYWxzZX1cblxuICAgICAgICB2YWwgc2luZ2xldG9uIDogJXtlbnRyeV9kaWZmX3R5cGUgfnNpemV9IC0+ICV7ZGlmZl90eXBlfVxuXG4gICAgICAgIHZhbCBjcmVhdGUgOiAle2NyZWF0ZV9hcmdzIH5vcHRpb25hbDp0cnVlfSAtPiB1bml0IC0+ICV7ZGlmZl90eXBlfVxuXG4gICAgICAgIHZhbCBjcmVhdGVfb2ZfdmFyaWFudHMgOiAle2NyZWF0ZV9vZl92YXJpYW50c19hcmdzfSAtPiAle2RpZmZfdHlwZX1cbiAgICAgIGVuZFxuXG4gICAgICBtb2R1bGUgJXtmb3JfaW5saW5lZF90dXBsZV9tb2R1bGVfbmFtZX0gOiBzaWdcbiAgICAgICAgJXtmb3JfaW5saW5lZF90dXBsZV90eXBlX2RlY2xhcmF0aW9uIH5zaXplfVxuXG4gICAgICAgIG1vZHVsZSAle2RpZmZfbW9kdWxlX25hbWV9IDogc2lnXG4gICAgICAgICAgJXtmb3JfaW5saW5lZF90dXBsZV9kaWZmX3R5cGVfZGVjbGFyYXRpb25zIH5zaXplfVxuICAgICAgICAgICV7ZnVuY3Rpb25fZGVjbGFyYXRpb25zIH5sb2NhbDp0cnVlfVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICAgICAgIHx9XVxuOztcblxubGV0IHR1cGxlX21sIHNpemUgPVxuICBsZXQgbnVtcyA9IG51bXMgfnNpemUgaW5cbiAgbGV0IGdldCA9IHNwcmludGYgXCJnZXQlaVwiIGluXG4gIGxldCBhcHBseSA9IHNwcmludGYgXCJhcHBseSVpX2V4blwiIGluXG4gIGxldCBvZl9saXN0ID0gc3ByaW50ZiBcIm9mX2xpc3QlaV9leG5cIiBpblxuICBsZXQgbWF5YmVfZ2VsIHMgaSB+Z2VsID1cbiAgICBsZXQgYmFzZSA9IHNwcmludGYgXCIlcyVpXCIgcyBpIGluXG4gICAgaWYgbm90IGdlbCB0aGVuIGJhc2UgZWxzZSBzcHJpbnRmIFwie0dlbC5nID0gJXN9XCIgYmFzZVxuICBpblxuICBsZXQgZnJvbSA9IG1heWJlX2dlbCBcImZyb21fXCIgaW5cbiAgbGV0IHRvXyA9IG1heWJlX2dlbCBcInRvX1wiIGluXG4gIGxldCBkZXJpdmVkX29uID0gbWF5YmVfZ2VsIFwiZGVyaXZlZF9vblwiIGluXG4gIGxldCB0ID0gbWF5YmVfZ2VsIFwidFwiIGluXG4gIGxldCBhcHBseV9kaWZmIG4gPVxuICAgIFslc3RyaW5nXG4gICAgICB7fCBsZXQgJXt0IG4gfmdlbDpmYWxzZX0sIGRpZmYgPVxuICAgICAgICAgICBtYXRjaCBkaWZmIHdpdGhcbiAgICAgICAgICB8ICV7dmFyaWFudF9uYW1lIG59IGQgOjogdGwgLT4gJXthcHBseSBufSAle2Rlcml2ZWRfb24gbiB+Z2VsOmZhbHNlfSBkLCB0bFxuICAgICAgICAgIHwgXyAtPiAle2Rlcml2ZWRfb24gbiB+Z2VsOmZhbHNlfSwgZGlmZlxuICAgICAgICAgaW5cbiAgICAgICAgIHx9XVxuICBpblxuICBsZXQgZ2V0X2RpZmYgbiA9XG4gICAgWyVzdHJpbmdcbiAgICAgIHt8IGxldCBkaWZmID1cbiAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsLk9wdGlvbmFsX2RpZmYgJXtnZXQgbn0gfmZyb206JXtmcm9tIG4gfmdlbDpmYWxzZX0gfnRvXzole3RvXyBuIH5nZWw6ZmFsc2V9IHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBkaWZmXG4gICAgICAgICAgICB8IFNvbWUgZCAtPiAle3ZhcmlhbnRfbmFtZSBufSBkIDo6IGRpZmZcbiAgICAgICAgICBpblxuICAgICAgIHx9XVxuICBpblxuICBsZXQgb2Zfc2V4cF9mdW5jdGlvbnMgPVxuICAgIExpc3QubWFwIG51bXMgfmY6KHNwcmludGYgXCJhJWlfb2Zfc2V4cFwiKVxuICAgIEAgTGlzdC5tYXAgbnVtcyB+Zjooc3ByaW50ZiBcImElaV9kaWZmX29mX3NleHBcIilcbiAgICB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCIgXCJcbiAgaW5cbiAgbGV0IGNyZWF0ZV9hcmdzIH5vcHRpb25hbCA9XG4gICAgTGlzdC5tYXAgbnVtcyB+ZjooZnVuIGkgLT5cbiAgICAgIFslc3RyaW5nIHt8JXtpZiBvcHRpb25hbCB0aGVuIFwiP1wiIGVsc2UgXCJ+XCJ9JXtjcmVhdGVfYXJnIGl9fH1dKVxuICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiBcIlxuICBpblxuICBsZXQgY3JlYXRlX2Z1bmN0aW9uIH52YWx1ZSBvcHRpb25fb3Jfb3B0aW9uYWxfZGlmZiA9XG4gICAgbGV0IG1heWJlX2FkZF9kaWZmIGkgPVxuICAgICAgbGV0IG1heWJlX2FkZCBpID1cbiAgICAgICAgbWF0Y2ggb3B0aW9uX29yX29wdGlvbmFsX2RpZmYgd2l0aFxuICAgICAgICB8IGBvcHRpb24gLT5cbiAgICAgICAgICBbJXN0cmluZ1xuICAgICAgICAgICAge3wgbWF0Y2ggJXt2YWx1ZSBpfSB3aXRoXG4gICAgICAgICAgICAgICB8IE5vbmUgLT4gZGlmZlxuICAgICAgICAgICAgICAgfCBTb21lIGQgLT4gJXt2YXJpYW50X25hbWUgaX0gZCA6OiBkaWZmXG4gICAgICAgICAgIHx9XVxuICAgICAgICB8IGBvcHRpb25hbF9kaWZmIC0+XG4gICAgICAgICAgWyVzdHJpbmdcbiAgICAgICAgICAgIHt8IG1hdGNoJW9wdGlvbmFsLk9wdGlvbmFsX2RpZmYgJXt2YWx1ZSBpfSB3aXRoXG4gICAgICAgICAgICAgICB8IE5vbmUgLT4gZGlmZlxuICAgICAgICAgICAgICAgfCBTb21lIGQgLT4gJXt2YXJpYW50X25hbWUgaX0gZCA6OiBkaWZmXG4gICAgICAgICAgICB8fV1cbiAgICAgIGluXG4gICAgICBbJXN0cmluZyB7fGxldCBkaWZmID1cbiAgICAgICAgICAgICV7bWF5YmVfYWRkIGl9XG4gICAgICAgICAgaW5cbiAgICAgICAgfH1dXG4gICAgaW5cbiAgICBbJXN0cmluZ1xuICAgICAge3xsZXQgZGlmZiA9IFtdIGluXG4gICAgICAle0xpc3QucmV2X21hcCBudW1zIH5mOm1heWJlX2FkZF9kaWZmIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcblwifVxuICAgICAgZGlmZnx9XVxuICBpblxuICBsZXQgZGlmZl9vZl9saXN0IGkgPVxuICAgIFslc3RyaW5nXG4gICAgICB7fFxuICAgICAgfCAle3ZhcmlhbnRfbmFtZSBpfSBkIDo6IHRsIC0+XG4gICAgICAgIGxldCBkcywgdGwgPSBMaXN0LnNwbGl0X3doaWxlIHRsIH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgJXt2YXJpYW50X25hbWUgaX0gXyAtPiB0cnVlXG4gICAgICAgICAgfCBfIC0+IGZhbHNlKVxuICAgICAgICBpblxuICAgICAgICBsZXQgZHMgPSBMaXN0Lm1hcCBkcyB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8ICV7dmFyaWFudF9uYW1lIGl9IHggLT4geFxuICAgICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG4gICAgICAgIGluXG4gICAgICAgIChtYXRjaCVvcHRpb25hbC5PcHRpb25hbF9kaWZmICV7b2ZfbGlzdCBpfSAoZCA6OiBkcykgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IGxvb3AgYWNjIHRsXG4gICAgICAgICB8IFNvbWUgZCAtPiBsb29wICgle3ZhcmlhbnRfbmFtZSBpfSBkIDo6IGFjYykgdGwpXG4gICAgICAgICB8fV1cbiAgaW5cbiAgbGV0IGZ1bmN0aW9uX2ltcGxlbWVudGF0aW9ucyB+bG9jYWwgPVxuICAgIGxldCBtYXliZV9sb2NhbCA9IGlmIGxvY2FsIHRoZW4gXCJsb2NhbF8gXCIgZWxzZSBcIlwiIGluXG4gICAgbGV0IGdlbCA9IGxvY2FsIGluXG4gICAgWyVzdHJpbmdcbiAgICAgIHt8XG4gICAgICAgIGxldCBnZXQgJXtMaXN0Lm1hcCBudW1zIH5mOmdldCB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCIgXCJ9IH5mcm9tIH50b18gPVxuICAgICAgICAgIGlmIEJhc2UucGh5c19lcXVhbCBmcm9tIHRvX1xuICAgICAgICAgIHRoZW4gbG9jYWxfIE9wdGlvbmFsX2RpZmYubm9uZVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0ICV7TGlzdC5tYXAgbnVtcyB+ZjooZnJvbSB+Z2VsKSB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCIsIFwifSA9IGZyb20gaW5cbiAgICAgICAgICAgIGxldCAle0xpc3QubWFwIG51bXMgfmY6KHRvXyB+Z2VsKSB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCIsIFwifSA9IHRvXyBpblxuICAgICAgICAgICAgbGV0IGRpZmYgPSBbXSBpblxuICAgICAgICAgICAgJXtMaXN0LnJldl9tYXAgbnVtcyB+ZjpnZXRfZGlmZiB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCJcIn1cbiAgICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgICAgfCBbXSAtPiBsb2NhbF8gT3B0aW9uYWxfZGlmZi5ub25lXG4gICAgICAgICAgICB8IF8gOjogXyAtPiBsb2NhbF8gT3B0aW9uYWxfZGlmZi5yZXR1cm4gZGlmZilcblxuXG4gICAgICAgIGxldCBhcHBseV9leG4gJXtMaXN0Lm1hcCBudW1zIH5mOmFwcGx5IHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiBcIn0gZGVyaXZlZF9vbiBkaWZmID1cbiAgICAgICAgICBsZXQgJXtMaXN0Lm1hcCBudW1zIH5mOihkZXJpdmVkX29uIH5nZWwpIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiwgXCJ9ID0gZGVyaXZlZF9vbiBpblxuICAgICAgICAgICV7TGlzdC5tYXAgbnVtcyB+ZjphcHBseV9kaWZmIHw+IFN0cmluZy5jb25jYXQgIH5zZXA6XCJcIn1cbiAgICAgICAgICBtYXRjaCBkaWZmIHdpdGhcbiAgICAgICAgICB8IFtdIC0+ICV7bWF5YmVfbG9jYWx9JXtMaXN0Lm1hcCBudW1zIH5mOih0IH5nZWwpIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIixcIn1cbiAgICAgICAgICB8IF8gOjogXyAtPiAle21heWJlX2xvY2FsfWZhaWx3aXRoIFwiQlVHOiBub24tZW1wdHkgZGlmZiBhZnRlciBhcHBseVwiXG4gICAgICAgIHx9XVxuICBpblxuICBsZXQgb2ZfbGlzdF9hbmRfYXBwbHlfZnVuY3Rpb25zID1cbiAgICBMaXN0LmNvbmNhdF9tYXAgbnVtcyB+ZjooZnVuIHggLT4gWyBvZl9saXN0IHg7IHNwcmludGYgXCJfJXNcIiAoYXBwbHkgeCkgXSlcbiAgICB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCIgXCJcbiAgaW5cbiAgbGV0IG9mX2xpc3RfZnVuY3Rpb24gPVxuICAgIFslc3RyaW5nXG4gICAgICB7fFxuICAgICAgbGV0IG9mX2xpc3RfZXhuICV7b2ZfbGlzdF9hbmRfYXBwbHlfZnVuY3Rpb25zfSB0cyA9XG4gICAgICAgIG1hdGNoIHRzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBsb2NhbF8gT3B0aW9uYWxfZGlmZi5ub25lXG4gICAgICAgIHwgXyA6OiBfIC0+XG4gICAgICAgICAgbWF0Y2ggTGlzdC5jb25jYXQgdHMgfD4gTGlzdC5zdGFibGVfc29ydCB+Y29tcGFyZTpjb21wYXJlX3Jhbmsgd2l0aFxuICAgICAgICAgIHwgW10gLT4gbG9jYWxfIE9wdGlvbmFsX2RpZmYucmV0dXJuIFtdXG4gICAgICAgICAgfCBfIDo6IF8gYXMgZGlmZiAtPlxuICAgICAgICAgICAgbGV0IHJlYyBsb29wIGFjYyA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgIHwgW10gLT4gTGlzdC5yZXYgYWNjXG4gICAgICAgICAgICAgICAle0xpc3QubWFwIG51bXMgfmY6ZGlmZl9vZl9saXN0IHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcblwifVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxvY2FsXyBPcHRpb25hbF9kaWZmLnJldHVybiAobG9vcCBbXSBkaWZmKVxuICAgICAgICAgfH1dXG4gIGluXG4gIGxldCBjcmVhdGVfYXJnX29mX3ZhcmlhbnQgaSA9XG4gICAgWyVzdHJpbmcge3woJXtjcmVhdGVfYXJnIGl9ICV7ZW50cnlfZGlmZl9tb2R1bGVfbmFtZX0uVmFyaWFudHMuJXtjcmVhdGVfYXJnIGl9KXx9XVxuICBpblxuICBbJXN0cmluZ1xuICAgIHt8XG4gICAgbW9kdWxlICV7bW9kdWxlX25hbWUgfnNpemV9ID0gc3RydWN0XG4gICAgICAle3R5cGVfZGVjbGFyYXRpb24gfnNpemV9XG4gICAgICBtb2R1bGUgJXtkaWZmX21vZHVsZV9uYW1lfSA9IHN0cnVjdFxuICAgICAgICAle2RpZmZfdHlwZV9kZWNsYXJhdGlvbnMgfnNpemUgfnNpZ25hdHVyZTpmYWxzZX1cblxuICAgICAgICBsZXQgY29tcGFyZV9yYW5rIHQxIHQyID1cbiAgICAgICAgICBJbnQuY29tcGFyZSAoJXtlbnRyeV9kaWZmX21vZHVsZV9uYW1lfS5WYXJpYW50cy50b19yYW5rIHQxKSAoJXtlbnRyeV9kaWZmX21vZHVsZV9uYW1lfS5WYXJpYW50cy50b19yYW5rIHQyKVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCBlcXVhbF9yYW5rIHQxIHQyID1cbiAgICAgICAgICBJbnQuZXF1YWwgKCV7ZW50cnlfZGlmZl9tb2R1bGVfbmFtZX0uVmFyaWFudHMudG9fcmFuayB0MSkgKCV7ZW50cnlfZGlmZl9tb2R1bGVfbmFtZX0uVmFyaWFudHMudG9fcmFuayB0MilcbiAgICAgICAgOztcblxuICAgICAgICAle2Z1bmN0aW9uX2ltcGxlbWVudGF0aW9ucyB+bG9jYWw6ZmFsc2V9XG5cbiAgICAgICAgJXtvZl9saXN0X2Z1bmN0aW9ufVxuXG4gICAgICAgIGxldCBzaW5nbGV0b24gZW50cnlfZGlmZiA9IFtlbnRyeV9kaWZmXVxuXG4gICAgICAgIGxldCB0X29mX3NleHAgJXtvZl9zZXhwX2Z1bmN0aW9uc30gc2V4cCA9XG4gICAgICAgICAgbGV0IGwgPSB0X29mX3NleHAgJXtvZl9zZXhwX2Z1bmN0aW9uc30gc2V4cCB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6Y29tcGFyZV9yYW5rIGluXG4gICAgICAgICAgbWF0Y2ggTGlzdC5maW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSBsIH5lcXVhbDplcXVhbF9yYW5rIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gbFxuICAgICAgICAgIHwgU29tZSAoZHVwLCBfKSAtPlxuICAgICAgICAgICBmYWlsd2l0aCAoXCJEdXBsaWNhdGUgZW50cnkgaW4gdHVwbGUgZGlmZjogXCIgXiAle2VudHJ5X2RpZmZfbW9kdWxlX25hbWV9LlZhcmlhbnRzLnRvX25hbWUgZHVwKVxuXG4gICAgICAgIGxldCBjcmVhdGUgJXtjcmVhdGVfYXJncyB+b3B0aW9uYWw6dHJ1ZX0gKCkgPVxuICAgICAgICAgICV7Y3JlYXRlX2Z1bmN0aW9uIH52YWx1ZTpjcmVhdGVfYXJnIGBvcHRpb259XG5cbiAgICAgICAgbGV0IGNyZWF0ZV9vZl92YXJpYW50cyAle2NyZWF0ZV9hcmdzIH5vcHRpb25hbDpmYWxzZX0gPVxuICAgICAgICAgICAle2NyZWF0ZV9mdW5jdGlvbiB+dmFsdWU6Y3JlYXRlX2FyZ19vZl92YXJpYW50IGBvcHRpb25hbF9kaWZmfVxuICAgICAgZW5kXG5cbiAgICAgIG1vZHVsZSAle2Zvcl9pbmxpbmVkX3R1cGxlX21vZHVsZV9uYW1lfSA9IHN0cnVjdFxuICAgICAgICAle2Zvcl9pbmxpbmVkX3R1cGxlX3R5cGVfZGVjbGFyYXRpb24gfnNpemV9XG5cbiAgICAgICAgbW9kdWxlICV7ZGlmZl9tb2R1bGVfbmFtZX0gPSBzdHJ1Y3RcbiAgICAgICAgICAle2Zvcl9pbmxpbmVkX3R1cGxlX2RpZmZfdHlwZV9kZWNsYXJhdGlvbnMgfnNpemV9XG4gICAgICAgICAgb3BlbiAle2RpZmZfbW9kdWxlX25hbWV9XG4gICAgICAgICAgb3BlbiAle2VudHJ5X2RpZmZfbW9kdWxlX25hbWV9XG4gICAgICAgICAgJXtmdW5jdGlvbl9pbXBsZW1lbnRhdGlvbnMgfmxvY2FsOnRydWV9XG5cbiAgICAgICAgICBsZXQgb2ZfbGlzdF9leG4gPSBvZl9saXN0X2V4blxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICAgICAgIHx9XVxuOztcblxubGV0IG1heF9zdXBwb3J0ZWQgPSA2LCBbJWhlcmVdXG5sZXQgbCA9IExpc3QucmFuZ2UgfnN0YXJ0OmBpbmNsdXNpdmUgfnN0b3A6YGluY2x1c2l2ZSAyIChmc3QgbWF4X3N1cHBvcnRlZClcbmxldCB0dXBsZXNfbWxpICgpID0gTGlzdC5tYXAgbCB+Zjp0dXBsZV9tbGkgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuXFxuXCJcbmxldCB0dXBsZXNfbWwgKCkgPSBMaXN0Lm1hcCBsIH5mOnR1cGxlX21sIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcblxcblwiXG4iXX0=
