// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Typed_field_map__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Typed_field_map = [0],
    Typed_field_map$0 = [0, Typed_field_map];
   runtime.caml_register_global(0, Typed_field_map$0, "Typed_field_map__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typed_field_map__The_map_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Typed_field_map_The_map_in = "Typed_field_map__The_map_intf",
    cst_typed_field_map = "typed_field_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Typed_field_map_The_map_in);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_typed_field_map);
   caml_call1(Ppx_expect_runtime[1][1], "typed_field_map/the_map_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_typed_field_map, "the_map_intf.ml");
   var For_records = [0];
   caml_call1(Ppx_inline_test_lib[7], cst_typed_field_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Typed_field_map_The_map_in);
   var Typed_field_map_The_map_intf = [0, For_records];
   runtime.caml_register_global
    (11, Typed_field_map_The_map_intf, cst_Typed_field_map_The_map_in);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typed_field_map__The_map
//# unitInfo: Requires: Core, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Typed_field_map__The_map_intf, Univ_map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Typed_field_map_The_map$0 = "Typed_field_map__The_map",
    cst_typed_field_map$0 = "typed_field_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Core = global_data.Core,
    Univ_map = global_data.Univ_map,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Typed_field_map_The_map$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_typed_field_map$0);
   caml_call1(Ppx_expect_runtime[1][1], "typed_field_map/the_map.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_typed_field_map$0, "the_map.ml");
   var
    cst_typed_field_map = cst_typed_field_map$0,
    cst_Typed_field_map_The_map = cst_Typed_field_map_The_map$0;
   function Make_plain(Key, Data){
    var
     names = Key[1],
     name = Key[2],
     path = Key[3],
     ord = Key[4],
     Type_ids = Key[5],
     Packed = Key[6],
     type_id = Type_ids[1];
    function sexp_of_t(param, t){return caml_call1(Packed[2], [0, t]);}
    var
     Key_mod =
       [0, names, name, path, ord, Type_ids, Packed, type_id, sexp_of_t];
    function sexp_of_t$0(param){return Core[149];}
    var
     include =
       caml_call1
        (caml_call1(Univ_map[26], [0, Key_mod[8], Key_mod[7]]),
         [0, sexp_of_t$0]),
     sexp_of_t$1 = include[1],
     invariant = include[3],
     empty = include[4],
     singleton = include[5],
     is_empty = include[6],
     set = include[7],
     mem = include[8],
     mem_by_id = include[9],
     find_exn = include[11],
     add = include[12],
     add_exn = include[13],
     change_exn = include[15],
     update = include[16],
     remove = include[17],
     remove_by_id = include[18],
     Packed$0 = include[19],
     key_id_set = include[20],
     to_alist = include[21],
     of_alist_exn = include[22],
     find_packed_by_id = include[23],
     find_packed_by_id_exn = include[24],
     type_equal = include[25];
    function create(creator){
     function _I_(acc, param){
      var t = param[1];
      return caml_call3(add_exn, acc, t, caml_call1(creator[1], t));
     }
     return caml_call3(Core_List[20], Key_mod[6][3], empty, _I_);
    }
    return [0,
            Key_mod,
            sexp_of_t$1,
            invariant,
            empty,
            singleton,
            is_empty,
            set,
            mem,
            mem_by_id,
            find_exn,
            add,
            add_exn,
            change_exn,
            update,
            remove,
            remove_by_id,
            Packed$0,
            key_id_set,
            to_alist,
            of_alist_exn,
            find_packed_by_id,
            find_packed_by_id_exn,
            type_equal,
            find_exn,
            change_exn,
            create];
   }
   function Make(Key, Data){
    var Base = Make_plain(Key, Data);
    function create(sexper, creator){
     return [0, Base[26].call(null, creator), sexper];
    }
    function set(t, key, data){
     var _H_ = t[2];
     return [0, caml_call3(Base[7], t[1], key, data), _H_];
    }
    function change(t, key, f){
     var _G_ = t[2];
     return [0, caml_call3(Base[25], t[1], key, f), _G_];
    }
    function find(t, key){return caml_call2(Base[24], t[1], key);}
    var Id = [0], Id_map = Make_plain(Key, Id);
    function transpose(A, t, create){
     function _A_(all){
      var map = caml_call1(Id_map[20], all);
      return caml_call1
              (create,
               [0, function(k){return caml_call2(Id_map[24], map, k);}]);
     }
     function _B_(param){
      var a = param[2], key = param[1];
      function _F_(a){return [0, key, a];}
      return caml_call2(A[1], a, _F_);
     }
     var
      _C_ = caml_call1(Base[19], t[1]),
      _D_ = caml_call2(Core_List[51], _C_, _B_),
      _E_ = caml_call1(A[2], _D_);
     return caml_call2(A[1], _E_, _A_);
    }
    function To_other_map(A, M){
     var Inner = Make_plain(Key, [0]);
     function run(t){
      function _s_(alist){
       var
        m = caml_call1(Inner[20], alist),
        _z_ = [0, function(k){return caml_call2(Inner[24], m, k);}];
       return caml_call2(M[4], 0, _z_);
      }
      function _t_(param){
       var a = param[2], key = param[1];
       function _x_(a){return [0, key, a];}
       var _y_ = caml_call1(A[3], a);
       return caml_call2(A[1], _y_, _x_);
      }
      var
       _u_ = caml_call1(Base[19], t[1]),
       _v_ = caml_call2(Core_List[51], _u_, _t_),
       _w_ = caml_call1(A[2], _v_);
      return caml_call2(A[1], _w_, _s_);
     }
     return [0, , run];
    }
    var As_applicative = [0, Id, Id_map, transpose, To_other_map];
    function sexp_of_t(t){
     var match = t[2];
     if(! match) return caml_call1(Base[2], t[1]);
     var sexpers = match[1];
     function _p_(param){
      var
       v = param[2],
       k = param[1],
       _r_ = caml_call1(sexpers[1], k),
       sexp_of_a = caml_call2(sexpers[2], _r_, v);
      return [1, [0, caml_call1(Key[6][2], [0, k]), [0, sexp_of_a, 0]]];
     }
     var _q_ = caml_call1(Base[19], t[1]);
     return [1, caml_call2(Core_List[51], _q_, _p_)];
    }
    return [0,
            Key,
            Data,
            ,
            create,
            set,
            change,
            find,
            As_applicative,
            sexp_of_t];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_typed_field_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Typed_field_map_The_map);
   function _a_(Key, _j_){
    var
     create_derived_on = Key[9],
     include = Make([0, Key[1], Key[2], Key[3], Key[4], Key[5], Key[6]], _j_),
     Data = include[2],
     create = include[4],
     set = include[5],
     change = include[6],
     find = include[7],
     As_applicative = include[8],
     sexp_of_t = include[9];
    function transpose_applicative(param, A){
     var f = param[1], t = create(0, [0, f]);
     function _o_(param){
      var f = param[1];
      return caml_call1(create_derived_on, [0, f]);
     }
     return As_applicative[3].call(null, A, t, _o_);
    }
    var _k_ = As_applicative[4];
    function _l_(_n_, _m_){return [0, _k_(_n_, _m_)[2]];}
    return [0,
            Key,
            sexp_of_t,
            Data,
            create,
            set,
            find,
            change,
            [0, As_applicative[3], _l_],
            transpose_applicative];
   }
   var
    Typed_field_map_The_map =
      [0,
       function(_c_, _b_){
        var _d_ = Make(_c_, _b_), _e_ = _d_[8], _f_ = _e_[4];
        function _g_(_i_, _h_){return [0, _f_(_i_, _h_)[2]];}
        return [0,
                _d_[9],
                _d_[1],
                _d_[2],
                _d_[4],
                _d_[5],
                _d_[7],
                _d_[6],
                [0, _e_[3], _g_]];
       },
       _a_];
   runtime.caml_register_global
    (14, Typed_field_map_The_map, cst_Typed_field_map_The_map$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typed_field_map__Nested
//# unitInfo: Requires: CamlinternalMod, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Typed_field_map__The_map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Typed_field_map_Nested$0 = "Typed_field_map__Nested",
    cst_typed_field_map$0 = "typed_field_map",
    cst_typed_field_map_nested_ml = "typed_field_map/nested.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typed_field_map_The_map = global_data.Typed_field_map__The_map,
    CamlinternalMod = global_data.CamlinternalMod,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Typed_field_map_Nested$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_typed_field_map$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_typed_field_map_nested_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_typed_field_map$0, "nested.ml");
   var
    _a_ = [0, [0]],
    _b_ = [0, cst_typed_field_map_nested_ml, 9, 4],
    _c_ = [0, [0]],
    _d_ = [0, cst_typed_field_map_nested_ml, 21, 4],
    _e_ = [0, [0]],
    _f_ = [0, [0]],
    cst_typed_field_map = cst_typed_field_map$0,
    cst_Typed_field_map_Nested = cst_Typed_field_map_Nested$0;
   function Make(Leaf_data){
    var
     Tree = caml_call2(CamlinternalMod[1], _b_, _a_),
     Branch = caml_call2(CamlinternalMod[1], _d_, _c_);
    caml_call3(CamlinternalMod[2], _e_, Tree, Tree);
    caml_call3(CamlinternalMod[2], _f_, Branch, Branch);
    function leaf(kind){return [0, kind];}
    function branch(N){
     var
      _g_ = N[1],
      Map =
        caml_call1
         (caml_call1
           (Typed_field_map_The_map[1],
            [0, _g_[1], _g_[2], _g_[3], _g_[4], _g_[5], _g_[6]]),
          Tree),
      map = caml_call2(Map[4], 0, [0, N[2]]);
     return [1,
             [0,
              N[1],
              [0, Map[1], Map[3], Map[4], Map[5], Map[6], Map[7], Map[8]],
              map]];
    }
    return [0, Tree, Branch, leaf, branch];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_typed_field_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Typed_field_map_Nested);
   var Typed_field_map_Nested = [0, Make];
   runtime.caml_register_global
    (19, Typed_field_map_Nested, cst_Typed_field_map_Nested$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typed_field_map__Sexp_serializers
//# unitInfo: Requires: Core, Core__List, Core__Sexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Typed_field_map__The_map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Typed_field_map_Sexp_seria = "Typed_field_map__Sexp_serializers",
    cst_typed_field_map = "typed_field_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_List = global_data.Core__List,
    Core_Sexp = global_data.Core__Sexp,
    Typed_field_map_The_map = global_data.Typed_field_map__The_map,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Typed_field_map_Sexp_seria);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_typed_field_map);
   caml_call1(Ppx_expect_runtime[1][1], "typed_field_map/sexp_serializers.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_typed_field_map, "sexp_serializers.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_typed_field_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Typed_field_map_Sexp_seria);
   var
    _b_ = [0, "missing_field"],
    cst_Cannot_deserialize_typed_f$1 =
      "Cannot deserialize typed_field_map. Reason: missing field:",
    _a_ = [0, "duplicate_field"],
    cst_Cannot_deserialize_typed_f$0 =
      "Cannot deserialize typed_field_map. Reason: duplicate field:",
    cst_Cannot_deserialize_typed_f =
      "Cannot deserialize typed_field_map. Reason: Unrecognized sexp:",
    Typed_field_map_Sexp_serialize =
      [0,
       function(Map){
        var
         Typed_field = Map[2],
         default_defaulter = [0, function(param){return 0;}];
        function sexp_of_t(to_sexper, t){
         function sexp_of_field(param){
          var
           key = param[1],
           key_sexp = caml_call1(Typed_field[6][2], [0, key]),
           _m_ = caml_call2(Map[6], t, key),
           data_sexp = caml_call2(to_sexper[1], key, _m_);
          return [1, [0, key_sexp, [0, data_sexp, 0]]];
         }
         return [1,
                 caml_call2(Core_List[51], Typed_field[6][3], sexp_of_field)];
        }
        var
         T = [0],
         include =
           caml_call1(caml_call1(Typed_field_map_The_map[1], Map[2]), T),
         create = include[4],
         set = include[5],
         find = include[6],
         empty = caml_call2(create, 0, [0, function(param){return 0;}]);
        function raise_invalid_sexp(sexp){
         var
          _k_ = [0, caml_call1(Core_Sexp[93], sexp), 0],
          _l_ =
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Cannot_deserialize_typed_f),
              _k_]];
         return caml_call1(Core[261], _l_);
        }
        function t_of_sexp(opt, of_sexper, sexp){
         if(opt)
          var sth = opt[1], default$0 = sth;
         else
          var default$0 = default_defaulter;
         if(0 === sexp[0]) return raise_invalid_sexp(sexp);
         var l = sexp[1];
         function _c_(acc, param){
          if(1 === param[0]){
           var _g_ = param[1];
           if(_g_){
            var _h_ = _g_[2];
            if(_h_ && ! _h_[2]){
             var
              data_sexp = _h_[1],
              key_sexp = _g_[1],
              key = caml_call1(Typed_field[6][1], key_sexp)[1],
              data = caml_call2(of_sexper[1], key, data_sexp);
             if(! caml_call2(find, acc, key))
              return caml_call3(set, acc, key, [0, data]);
             var
              duplicate_field = caml_call1(Typed_field[2], key),
              _i_ =
                [0,
                 [1, [0, _a_, [0, caml_call1(Core[558], duplicate_field), 0]]],
                 0],
              _j_ =
                [1,
                 [0,
                  caml_call1
                   (Sexplib0_Sexp_conv[7], cst_Cannot_deserialize_typed_f$0),
                  _i_]];
             return caml_call1(Core[261], _j_);
            }
           }
          }
          return raise_invalid_sexp(sexp);
         }
         var
          map_with_parsed_results = caml_call3(Core_List[20], l, empty, _c_),
          _d_ =
            [0,
             function(f){
              var match = caml_call2(find, map_with_parsed_results, f);
              if(match){var data = match[1]; return data;}
              var match$0 = caml_call1(default$0[1], f);
              if(match$0){var data$0 = match$0[1]; return data$0;}
              var
               missing_field = caml_call1(Typed_field[2], f),
               _e_ =
                 [0,
                  [1, [0, _b_, [0, caml_call1(Core[558], missing_field), 0]]],
                  0],
               _f_ =
                 [1,
                  [0,
                   caml_call1
                    (Sexplib0_Sexp_conv[7], cst_Cannot_deserialize_typed_f$1),
                   _e_]];
              return caml_call1(Core[261], _f_);
             }];
         return caml_call2(Map[4], 0, _d_);
        }
        return [0, sexp_of_t, t_of_sexp];
       }];
   runtime.caml_register_global
    (21, Typed_field_map_Sexp_serialize, cst_Typed_field_map_Sexp_seria);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typed_field_map
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Typed_field_map__The_map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Typed_field_map = "Typed_field_map",
    cst_typed_field_map = "typed_field_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Typed_field_map_The_map = global_data.Typed_field_map__The_map;
   caml_call1(Ppx_module_timer_runtime[4], cst_Typed_field_map);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_typed_field_map);
   caml_call1(Ppx_expect_runtime[1][1], "typed_field_map/typed_field_map.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_typed_field_map, "typed_field_map.ml");
   var
    Make = Typed_field_map_The_map[1],
    Make_for_records = Typed_field_map_The_map[2];
   caml_call1(Ppx_inline_test_lib[7], cst_typed_field_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Typed_field_map);
   var Typed_field_map = [0, Make, Make_for_records];
   runtime.caml_register_global(12, Typed_field_map, cst_Typed_field_map);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0eXBlZF9maWVsZF9tYXAuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInR5cGVfaWQiLCJzZXhwX29mX3QiLCJ0Iiwic2V4cF9vZl90JDAiLCJjcmVhdGUiLCJjcmVhdG9yIiwiYWNjIiwic2V4cGVyIiwic2V0Iiwia2V5IiwiZGF0YSIsImNoYW5nZSIsImYiLCJmaW5kIiwidHJhbnNwb3NlIiwiQSIsImFsbCIsIm1hcCIsImsiLCJhIiwicnVuIiwiYWxpc3QiLCJtIiwic2V4cGVycyIsInYiLCJzZXhwX29mX2EiLCJjcmVhdGVfZGVyaXZlZF9vbiIsInRyYW5zcG9zZV9hcHBsaWNhdGl2ZSIsImxlYWYiLCJraW5kIiwiYnJhbmNoIiwiTiIsImRlZmF1bHRfZGVmYXVsdGVyIiwidG9fc2V4cGVyIiwic2V4cF9vZl9maWVsZCIsImtleV9zZXhwIiwiZGF0YV9zZXhwIiwiZW1wdHkiLCJyYWlzZV9pbnZhbGlkX3NleHAiLCJzZXhwIiwidF9vZl9zZXhwIiwib3B0Iiwib2Zfc2V4cGVyIiwic3RoIiwiZGVmYXVsdCQwIiwibCIsImR1cGxpY2F0ZV9maWVsZCIsIm1hcF93aXRoX3BhcnNlZF9yZXN1bHRzIiwiZGF0YSQwIiwibWlzc2luZ19maWVsZCJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3BweF90eXBlZF9maWVsZHMvdHlwZWRfZmllbGRfbWFwL3R5cGVkX2ZpZWxkX21hcF9fLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcHB4X3R5cGVkX2ZpZWxkcy90eXBlZF9maWVsZF9tYXAvdGhlX21hcF9pbnRmLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcHB4X3R5cGVkX2ZpZWxkcy90eXBlZF9maWVsZF9tYXAvdGhlX21hcC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3BweF90eXBlZF9maWVsZHMvdHlwZWRfZmllbGRfbWFwL25lc3RlZC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3BweF90eXBlZF9maWVsZHMvdHlwZWRfZmllbGRfbWFwL3NleHBfc2VyaWFsaXplcnMubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FjMkI7O0lBQUE7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7R0N3RU47Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQy9FYkE7YUFDQUMsaUJBQVlDLEdBQUksT0FBdUIsMEJBQTNCQSxJQUFnQztJQUpqQzs7cURBR1hGLFNBQ0FDO2FBU0lFLG1CQUFjLGlCQUFjOzs7OzthQUE1QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FBVU5DLE9BQU9DO2tCQUNvQ0M7TUFBTCxJQUE0Qko7TUFDekMsT0FBQSxvQkFEa0JJLEtBQXVCSixHQUN6QyxXQUZsQkcsWUFDMkRIO0tBQzNCO0tBREQsT0FBQTtJQUNDO0lBMUJ1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUF3QjlERTs7OzthQXVCQUEsT0FBUUcsUUFBT0Y7S0FBVSwrQkFBVkEsVUFBUEU7SUFBdUQ7YUFDL0RDLElBQUlOLEdBQUdPLEtBQUtDO0tBQU8sVUFBZlI7S0FBZSxXQUFnQixvQkFBL0JBLE1BQUdPLEtBQUtDO0lBQW1EO2FBQy9EQyxPQUFPVCxHQUFFTyxLQUFLRztLQUFJLFVBQVhWO0tBQVcsV0FBZ0IscUJBQTNCQSxNQUFFTyxLQUFLRztJQUErQzthQUM3REMsS0FBS1gsR0FBRU8sS0FBTSxPQUFBLHFCQUFSUCxNQUFFTyxLQUEwQjtJQXFCdkIsSUFBQTthQVFSSyxVQUFrQkMsR0FBT2IsR0FBR0U7a0JBTWJZO01BQ0YsSUFBTkMsTUFBTSx1QkFERUQ7TUFFTCxPQUFBO2VBUmtCWjs0QkFRUGMsR0FBSyxPQUFBLHVCQURuQkQs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L0I7U0FaakM7VUFERVEsMEJBQ0YsMEJBRkdGLEdBZkhSO1VBZ0NBOztzQkFDU3pCO2NBQ0csWUFBQSxpQkFsQlZtQyx5QkFpQk9uQzs0QkFXSUYsaUJBQVEsT0FBUkE7Y0FSRSxjQUFBLFdBMUJMa0MsY0F1QkRoQzs4QkFJT29DLHFCQUFRLE9BQVJBO2NBRWU7ZUFBaEJDLGdCQUFnQiwyQkFOdEJyQzs7O3lEQU1NcUM7Ozs7Ozs7OzthQUtVO1NBWnpCLE9BQUE7UUFhQzttQkE5REhoRCxXQTJCQXVDOzs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgVHlwZWRfZmllbGRfbWFwLk5lc3RlZCAqKVxubW9kdWxlIE5lc3RlZCA9IFR5cGVkX2ZpZWxkX21hcF9fTmVzdGVkXG5cbigqKiBAY2Fub25pY2FsIFR5cGVkX2ZpZWxkX21hcC5TZXhwX3NlcmlhbGl6ZXJzICopXG5tb2R1bGUgU2V4cF9zZXJpYWxpemVycyA9IFR5cGVkX2ZpZWxkX21hcF9fU2V4cF9zZXJpYWxpemVyc1xuXG4oKiogQGNhbm9uaWNhbCBUeXBlZF9maWVsZF9tYXAuVGhlX21hcCAqKVxubW9kdWxlIFRoZV9tYXAgPSBUeXBlZF9maWVsZF9tYXBfX1RoZV9tYXBcblxuKCoqIEBjYW5vbmljYWwgVHlwZWRfZmllbGRfbWFwLlRoZV9tYXBfaW50ZiAqKVxubW9kdWxlIFRoZV9tYXBfaW50ZiA9IFR5cGVkX2ZpZWxkX21hcF9fVGhlX21hcF9pbnRmXG5cbm1vZHVsZSBUeXBlZF9maWVsZF9tYXBfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwib3BlbiEgQ29yZVxuXG5tb2R1bGUgdHlwZSBEYXRhID0gVDFcblxuKCoqIFRoZSByZWFzb24gdGhhdCBTX3BsYWluIGV4aXN0cyBpcyBiZWNhdXNlIHRoZSBUb19vdGhlcl9tYXAgZnVuY3RvciBuZWVkcyB0b1xuICAgIHRha2Ugb25lIGFzIGFuIGFyZ3VtZW50LCBzbyB0aGV5IG5lZWQgdG8gYmUgc3BsaXQuXG5cbiAgICBPbmUgb2YgdGhlc2UgbWFwcyBpcyBpc29tb3JwaGljIHRvIHRoZSByZWNvcmQgdGhhdCB0aGV5IGFyZSBidWlsdCBvdXQgb2YuICBXaGVuXG4gICAgY3JlYXRpbmcgdGhlIG1hcCB2aWEgdGhlIGNyZWF0b3IgZnVuY3Rpb24sIHlvdSBwcm92aWRlIGFsbCBwb3NzaWJsZSBrZXlzIGFuZCB2YWx1ZXMuXG5cbiAgICBUaGlzIG1lYW5zIHRoYXQgW2ZpbmRdIHdpbGwgYWx3YXlzIHN1Y2NlZWQuICAqKVxubW9kdWxlIHR5cGUgU19wbGFpbiA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBtb2R1bGUgS2V5IDogVHlwZWRfZmllbGRzX2xpYi5Db21tb24uU1xuICBtb2R1bGUgRGF0YSA6IERhdGFcblxuICB0eXBlIHNleHBlciA9XG4gICAgeyBpbmRpdmlkdWFsIDogJ2EuICdhIEtleS50IC0+ICdhIC0+IFNleHAudFxuICAgIDsgY29udGFpbmVyIDogJ2EuICgnYSAtPiBTZXhwLnQpIC0+ICdhIERhdGEudCAtPiBTZXhwLnRcbiAgICB9XG5cbiAgdHlwZSBjcmVhdG9yID0geyBmIDogJ2EuICdhIEtleS50IC0+ICdhIERhdGEudCB9XG5cbiAgdmFsIGNyZWF0ZSA6ID9zZXhwZXI6c2V4cGVyIC0+IGNyZWF0b3IgLT4gdFxuICB2YWwgc2V0IDogdCAtPiBrZXk6J2EgS2V5LnQgLT4gZGF0YTonYSBEYXRhLnQgLT4gdFxuXG4gICgqKiBGaW5kIHdpbGwgYWx3YXlzIHN1Y2NlZWQgICopXG4gIHZhbCBmaW5kIDogdCAtPiAnYSBLZXkudCAtPiAnYSBEYXRhLnRcblxuICB2YWwgY2hhbmdlIDogdCAtPiAnYSBLZXkudCAtPiBmOignYSBEYXRhLnQgLT4gJ2EgRGF0YS50KSAtPiB0XG5cbiAgbW9kdWxlIEFzX2FwcGxpY2F0aXZlIDogc2lnXG4gICAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgICAgdHlwZSAnYSB0ID0gJ2EgRGF0YS50XG5cbiAgICAgIHZhbCBtYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG4gICAgICB2YWwgYWxsIDogJ2EgdCBsaXN0IC0+ICdhIGxpc3QgdFxuICAgIGVuZFxuXG4gICAgdHlwZSBjcmVhdG9yID0geyBmIDogJ2EuICdhIEtleS50IC0+ICdhIH1cblxuICAgIHZhbCB0cmFuc3Bvc2UgOiAobW9kdWxlIFMpIC0+IHQgLT4gY3JlYXRlOihjcmVhdG9yIC0+ICdhKSAtPiAnYSBEYXRhLnRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIFNfcGxhaW5cblxuICBtb2R1bGUgQXNfYXBwbGljYXRpdmUgOiBzaWdcbiAgICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIEFzX2FwcGxpY2F0aXZlXG5cbiAgICBtb2R1bGUgdHlwZSBTX2Zvcl9vdGhlcl9tYXAgPSBzaWdcbiAgICAgICgqKiBUaGlzIG1vZHVsZSBpcyBiYXNpY2FsbHkgXCJBcHBsaWNhdGl2ZVwiLCBidXQgd2l0aCBhbiBhZGRpdGlvbmFsIHR5cGUgdGhhdCBjYW4gYmUgdXNlZCB0b1xuICAgICAgICAgIHRyYW5zbGF0ZSB0byB0aGUgYXBwbGljYXRpdmUgdHlwZS5cblxuICAgICAgICAgIFR5cGljYWxseSB0aGVzZSB0eXBlcyB3aWxsIGJlIHNvbWV0aGluZyBsaWtlXG5cbiAgICAgICAgICB7W1xuICAgICAgICAgICAgdHlwZSAnYSB0ID0gJ2EgVmFsdWUudFxuICAgICAgICAgICAgdHlwZSAnYSBzID0gJ2EgRm9ybS50XG5cbiAgICAgICAgICAgIHZhbCB0cmFuc2xhdGU6ICdhIEZvcm0udCBWYWx1ZS50IC0+ICdhIEZvcm0udCBWYWx1ZS50XG4gICAgICAgICAgXX1cblxuICAgICAgICAgIFt0cmFuc2xhdGVdIHByb2JhYmx5IGRvZXNuJ3QgbmVlZCB0byBkbyBhbnkgd29yay4gSXQganVzdCBleGlzdHMgdG9cbiAgICAgICAgICBleHBvc2UgYSB0eXBlIGVxdWFsaXR5IGJldHdlZW4gWydhIERhdGEudF0gYW5kIFsnYSBzIHRdLiAqKVxuXG4gICAgICB0eXBlICdhIHRcblxuICAgICAgdmFsIG1hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgICAgIHZhbCBhbGwgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG5cbiAgICAgIHR5cGUgJ2Egc1xuXG4gICAgICB2YWwgdHJhbnNsYXRlIDogJ2EgRGF0YS50IC0+ICdhIHMgdFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIFRvX290aGVyX21hcFxuICAgICAgKEEgOiBTX2Zvcl9vdGhlcl9tYXApXG4gICAgICAoTSA6IFNfcGxhaW4gd2l0aCB0eXBlICdhIEtleS50ID0gJ2EgS2V5LnQgYW5kIHR5cGUgJ2EgRGF0YS50ID0gJ2EgQS5zKSA6IHNpZ1xuICAgICAgdmFsIHJ1biA6IHQgLT4gTS50IEEudFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgRm9yX3JlY29yZHMgPSBzdHJ1Y3RcbiAgKCoqIFRoaXMgbW9kdWxlIHR5cGUganVzdCBleHRlbmRzIFtTXSB3aXRoIGEgbW9yZSBlcmdvbm9taWMgd2F5IHRvIGNhbGxcbiAgICAgIFt0cmFuc3Bvc2VfYXBwbGljYXRpdmVdIHRoYXQgd29ya3MgZm9yIHJlY29yZHMuXG5cbiAgICAgIEl0IGdvZXMgZnJvbTpcbiAgICAgIHtbXG4gICAgICAgIGxldCBtb2R1bGUgTWFwID0gVHlwZWRfZmllbGRfbWFwLk1ha2UgKFR5cGVkX2ZpZWxkKSAoRGVmZXJyZWQpIGluXG4gICAgICAgIGxldCBtYXAgPSBNYXAuY3JlYXRlIHsgZiB9IGluXG4gICAgICAgIE1hcC5Bc19hcHBsaWNhdGl2ZS50cmFuc3Bvc2VcbiAgICAgICAgICAobW9kdWxlIERlZmVycmVkKVxuICAgICAgICAgIG1hcFxuICAgICAgICAgIH5jcmVhdGU6KGZ1biB7IGYgfSAtPiBUeXBlZF9maWVsZC5jcmVhdGUgeyBmIH0pXG4gICAgICBdfVxuXG4gICAgICBUbzpcbiAgICAgIHtbXG4gICAgICAgIGxldCBtb2R1bGUgTWFwID0gVHlwZWRfZmllbGRfbWFwLk1ha2VfZm9yX3JlY29yZHMgKE0uVHlwZWRfZmllbGQpIChEZWZlcnJlZCkgaW5cbiAgICAgICAgTWFwLnRyYW5zcG9zZV9hcHBsaWNhdGl2ZSB7IGYgfSAobW9kdWxlIERlZmVycmVkKVxuICAgICAgXX0gKilcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIG1vZHVsZSBLZXkgOiBUeXBlZF9maWVsZHNfbGliLlNcbiAgICBpbmNsdWRlIFMgd2l0aCBtb2R1bGUgS2V5IDo9IEtleVxuXG4gICAgdmFsIHRyYW5zcG9zZV9hcHBsaWNhdGl2ZVxuICAgICAgOiAgY3JlYXRvclxuICAgICAgLT4gKG1vZHVsZSBBc19hcHBsaWNhdGl2ZS5TKVxuICAgICAgLT4gS2V5LmRlcml2ZWRfb24gRGF0YS50XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFRoZV9tYXAgPSBzaWdcbiAgbW9kdWxlIHR5cGUgRGF0YSA9IERhdGFcbiAgbW9kdWxlIHR5cGUgUyA9IFNcblxuICBtb2R1bGUgTWFrZSAoS2V5IDogVHlwZWRfZmllbGRzX2xpYi5Db21tb24uUykgKERhdGEgOiBEYXRhKSA6XG4gICAgUyB3aXRoIG1vZHVsZSBLZXkgPSBLZXkgYW5kIG1vZHVsZSBEYXRhID0gRGF0YVxuXG4gIG1vZHVsZSBNYWtlX2Zvcl9yZWNvcmRzIChLZXkgOiBUeXBlZF9maWVsZHNfbGliLlMpIChEYXRhIDogRGF0YSkgOlxuICAgIEZvcl9yZWNvcmRzLlMgd2l0aCBtb2R1bGUgS2V5ID0gS2V5IGFuZCBtb2R1bGUgRGF0YSA9IERhdGFcbmVuZFxuIiwib3BlbiEgQ29yZVxuaW5jbHVkZSBUaGVfbWFwX2ludGZcblxubW9kdWxlIE1ha2VfcGxhaW4gKEtleSA6IFR5cGVkX2ZpZWxkc19saWIuQ29tbW9uLlMpIChEYXRhIDogRGF0YSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIEtleV9tb2QgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEtleVxuXG4gICAgbGV0IHR5cGVfaWQgPSBUeXBlX2lkcy50eXBlX2lkXG4gICAgbGV0IHNleHBfb2ZfdCBfIHQgPSBQYWNrZWQuc2V4cF9vZl90IHsgZiA9IFQgdCB9XG4gIGVuZFxuXG4gIGluY2x1ZGVcbiAgICBVbml2X21hcC5NYWtlXG4gICAgICAoS2V5X21vZClcbiAgICAgIChzdHJ1Y3RcbiAgICAgICAgaW5jbHVkZSBEYXRhXG5cbiAgICAgICAgbGV0IHNleHBfb2ZfdCBfID0gc2V4cF9vZl9vcGFxdWVcbiAgICAgIGVuZClcblxuICBtb2R1bGUgS2V5ID0gS2V5X21vZFxuXG4gIGxldCBmaW5kID0gZmluZF9leG5cbiAgbGV0IGNoYW5nZSA9IGNoYW5nZV9leG5cblxuICB0eXBlIGNyZWF0b3IgPSB7IGYgOiAnYS4gJ2EgS2V5LnQgLT4gJ2EgRGF0YS50IH1cblxuICBsZXQgY3JlYXRlIGNyZWF0b3IgPVxuICAgIExpc3QuZm9sZCBLZXkuUGFja2VkLmFsbCB+aW5pdDplbXB0eSB+ZjooZnVuIGFjYyB7IGYgPSBLZXkuUGFja2VkLlQgdCB9IC0+XG4gICAgICBhZGRfZXhuIGFjYyB+a2V5OnQgfmRhdGE6KGNyZWF0b3IuZiB0KSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZSAoS2V5IDogVHlwZWRfZmllbGRzX2xpYi5Db21tb24uUykgKERhdGEgOiBEYXRhKSA9IHN0cnVjdFxuICBtb2R1bGUgS2V5ID0gS2V5XG4gIG1vZHVsZSBEYXRhID0gRGF0YVxuICBtb2R1bGUgQmFzZSA9IE1ha2VfcGxhaW4gKEtleSkgKERhdGEpXG5cbiAgdHlwZSBjcmVhdG9yID0gQmFzZS5jcmVhdG9yID0geyBmIDogJ2EuICdhIEtleS50IC0+ICdhIERhdGEudCB9XG5cbiAgdHlwZSBzZXhwZXIgPVxuICAgIHsgaW5kaXZpZHVhbCA6ICdhLiAnYSBLZXkudCAtPiAnYSAtPiBTZXhwLnRcbiAgICA7IGNvbnRhaW5lciA6ICdhLiAoJ2EgLT4gU2V4cC50KSAtPiAnYSBEYXRhLnQgLT4gU2V4cC50XG4gICAgfVxuXG4gIHR5cGUgdCA9XG4gICAgeyBiYXNlIDogQmFzZS50XG4gICAgOyBzZXhwZXIgOiBzZXhwZXIgb3B0aW9uXG4gICAgfVxuXG4gIGxldCBjcmVhdGUgP3NleHBlciBjcmVhdG9yID0geyBiYXNlID0gQmFzZS5jcmVhdGUgY3JlYXRvcjsgc2V4cGVyIH1cbiAgbGV0IHNldCB0IH5rZXkgfmRhdGEgPSB7IHQgd2l0aCBiYXNlID0gQmFzZS5zZXQgdC5iYXNlIH5rZXkgfmRhdGEgfVxuICBsZXQgY2hhbmdlIHQga2V5IH5mID0geyB0IHdpdGggYmFzZSA9IEJhc2UuY2hhbmdlIHQuYmFzZSBrZXkgfmYgfVxuICBsZXQgZmluZCB0IGtleSA9IEJhc2UuZmluZCB0LmJhc2Uga2V5XG5cbiAgbW9kdWxlIEFzX2FwcGxpY2F0aXZlID0gc3RydWN0XG4gICAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgICAgdHlwZSAnYSB0ID0gJ2EgRGF0YS50XG5cbiAgICAgIHZhbCBtYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG4gICAgICB2YWwgYWxsIDogJ2EgdCBsaXN0IC0+ICdhIGxpc3QgdFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgU19mb3Jfb3RoZXJfbWFwID0gc2lnXG4gICAgICB0eXBlICdhIHRcblxuICAgICAgdmFsIG1hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgICAgIHZhbCBhbGwgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG5cbiAgICAgIHR5cGUgJ2Egc1xuXG4gICAgICB2YWwgdHJhbnNsYXRlIDogJ2EgRGF0YS50IC0+ICdhIHMgdFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIElkID0gc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZFxuXG4gICAgbW9kdWxlIElkX21hcCA9IE1ha2VfcGxhaW4gKEtleSkgKElkKVxuXG4gICAgdHlwZSBjcmVhdG9yID0geyBmIDogJ2EuICdhIEtleS50IC0+ICdhIH1cblxuICAgIGxldCB0cmFuc3Bvc2UgKG1vZHVsZSBBIDogUykgdCB+Y3JlYXRlID1cbiAgICAgIHQuYmFzZVxuICAgICAgfD4gQmFzZS50b19hbGlzdFxuICAgICAgfD4gTGlzdC5tYXAgfmY6KGZ1bmN0aW9uIFQgKGtleSwgYSkgLT5cbiAgICAgICAgICAgQS5tYXAgYSB+ZjooZnVuIGEgLT4gSWRfbWFwLlBhY2tlZC5UIChrZXksIGEpKSlcbiAgICAgIHw+IEEuYWxsXG4gICAgICB8PiBBLm1hcCB+ZjooZnVuIGFsbCAtPlxuICAgICAgICAgICBsZXQgbWFwID0gSWRfbWFwLm9mX2FsaXN0X2V4biBhbGwgaW5cbiAgICAgICAgICAgY3JlYXRlIHsgZiA9IChmdW4gayAtPiBJZF9tYXAuZmluZCBtYXAgaykgfSlcbiAgICA7O1xuXG4gICAgbW9kdWxlIFRvX290aGVyX21hcFxuICAgICAgKEEgOiBTX2Zvcl9vdGhlcl9tYXApXG4gICAgICAoTSA6IFNfcGxhaW4gd2l0aCB0eXBlICdhIEtleS50ID0gJ2EgS2V5LnQgYW5kIHR5cGUgJ2EgRGF0YS50ID0gJ2EgQS5zKSA9XG4gICAgc3RydWN0XG4gICAgICBtb2R1bGUgSW5uZXIgPVxuICAgICAgICBNYWtlX3BsYWluXG4gICAgICAgICAgKEtleSlcbiAgICAgICAgICAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPSAnYSBBLnNcbiAgICAgICAgICBlbmQpXG5cbiAgICAgIGxldCBydW4gdCA9XG4gICAgICAgIHQuYmFzZVxuICAgICAgICB8PiBCYXNlLnRvX2FsaXN0XG4gICAgICAgIHw+IExpc3QubWFwIH5mOihmdW5jdGlvbiBUIChrZXksIGEpIC0+XG4gICAgICAgICAgICAgQS5tYXAgKEEudHJhbnNsYXRlIGEpIH5mOihmdW4gYSAtPiBJbm5lci5QYWNrZWQuVCAoa2V5LCBhKSkpXG4gICAgICAgIHw+IEEuYWxsXG4gICAgICAgIHw+IEEubWFwIH5mOihmdW4gYWxpc3QgLT5cbiAgICAgICAgICAgICBsZXQgbSA9IElubmVyLm9mX2FsaXN0X2V4biBhbGlzdCBpblxuICAgICAgICAgICAgIE0uY3JlYXRlIHsgZiA9IChmdW4gayAtPiBJbm5lci5maW5kIG0gaykgfSlcbiAgICAgIDs7XG4gICAgZW5kXG4gIGVuZFxuXG4gIGxldCBzZXhwX29mX3QgdCA9XG4gICAgbWF0Y2ggdC5zZXhwZXIgd2l0aFxuICAgIHwgTm9uZSAtPiBCYXNlLnNleHBfb2ZfdCB0LmJhc2VcbiAgICB8IFNvbWUgc2V4cGVycyAtPlxuICAgICAgdC5iYXNlXG4gICAgICB8PiBCYXNlLnRvX2FsaXN0XG4gICAgICB8PiBMaXN0Lm1hcCB+ZjooZnVuY3Rpb24gVCAoaywgdikgLT5cbiAgICAgICAgICAgbGV0IHNleHBfb2ZfYSA9IHNleHBlcnMuY29udGFpbmVyIChzZXhwZXJzLmluZGl2aWR1YWwgaykgdiBpblxuICAgICAgICAgICBTZXhwLkxpc3QgWyBLZXkuUGFja2VkLnNleHBfb2ZfdCB7IGYgPSBUIGsgfTsgc2V4cF9vZl9hIF0pXG4gICAgICB8PiBTZXhwLkxpc3RcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV9mb3JfcmVjb3JkcyAoS2V5IDogVHlwZWRfZmllbGRzX2xpYi5TKSAoRGF0YSA6IERhdGEpID0gc3RydWN0XG4gIGxldCBjcmVhdGVfZGVyaXZlZF9vbiA9IEtleS5jcmVhdGVcblxuICBtb2R1bGUgT3JpZ2luYWxfa2V5ID0gS2V5XG4gIGluY2x1ZGUgTWFrZSAoS2V5KSAoRGF0YSlcblxuICBsZXQgdHJhbnNwb3NlX2FwcGxpY2F0aXZlIHsgZiB9IChtb2R1bGUgQSA6IEFzX2FwcGxpY2F0aXZlLlMpID1cbiAgICBsZXQgdCA9IGNyZWF0ZSB7IGYgfSBpblxuICAgIEFzX2FwcGxpY2F0aXZlLnRyYW5zcG9zZSAobW9kdWxlIEEpIHQgfmNyZWF0ZTooZnVuIHsgZiB9IC0+IGNyZWF0ZV9kZXJpdmVkX29uIHsgZiB9KVxuICA7O1xuXG4gICgqIFJlLWV4cG9ydCBLZXkgYXMgVHlwZWRfZmllbGRzX2xpYi5TICopXG4gIG1vZHVsZSBLZXkgPSBPcmlnaW5hbF9rZXlcbmVuZFxuIiwib3BlbiEgQ29yZVxuXG5tb2R1bGUgTWFrZSAoTGVhZl9kYXRhIDogVDEpID0gc3RydWN0XG4gIG1vZHVsZSByZWMgVHJlZSA6IHNpZ1xuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB8IExlYWYgOiAnYSBMZWFmX2RhdGEudCAtPiAnYSB0XG4gICAgICB8IEJyYW5jaCA6IChtb2R1bGUgQnJhbmNoLlMgd2l0aCB0eXBlIFR5cGVkX2ZpZWxkLmRlcml2ZWRfb24gPSAnYSkgLT4gJ2EgdFxuICBlbmQgPVxuICAgIFRyZWVcblxuICBhbmQgQnJhbmNoIDogc2lnXG4gICAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgICAgbW9kdWxlIFR5cGVkX2ZpZWxkIDogVHlwZWRfZmllbGRzX2xpYi5TXG5cbiAgICAgIG1vZHVsZSBNYXAgOlxuICAgICAgICBUaGVfbWFwLlMgd2l0aCBtb2R1bGUgS2V5IDo9IFR5cGVkX2ZpZWxkIGFuZCB0eXBlICdhIERhdGEudCA6PSAnYSBUcmVlLnRcblxuICAgICAgdmFsIG1hcCA6IE1hcC50XG4gICAgZW5kXG4gIGVuZCA9XG4gICAgQnJhbmNoXG5cbiAgdHlwZSAnYSB0ID0gJ2EgVHJlZS50XG5cbiAgbGV0IGxlYWYga2luZCA9IFRyZWUuTGVhZiBraW5kXG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIG1vZHVsZSBUeXBlZF9maWVsZCA6IFR5cGVkX2ZpZWxkc19saWIuU1xuXG4gICAgdmFsIGNoaWxkcmVuIDogJ2EgVHlwZWRfZmllbGQudCAtPiAnYSBUcmVlLnRcbiAgZW5kXG5cbiAgbGV0IGJyYW5jaCAodHlwZSBhKSAobW9kdWxlIE4gOiBTIHdpdGggdHlwZSBUeXBlZF9maWVsZC5kZXJpdmVkX29uID0gYSkgPVxuICAgIGxldCBtb2R1bGUgTSA9IHN0cnVjdFxuICAgICAgbW9kdWxlIFR5cGVkX2ZpZWxkID0gTi5UeXBlZF9maWVsZFxuICAgICAgbW9kdWxlIE1hcCA9IFRoZV9tYXAuTWFrZSAoVHlwZWRfZmllbGQpIChUcmVlKVxuXG4gICAgICBsZXQgbWFwID0gTWFwLmNyZWF0ZSB7IGYgPSBOLmNoaWxkcmVuIH1cbiAgICBlbmRcbiAgICBpblxuICAgIFRyZWUuQnJhbmNoIChtb2R1bGUgTSlcbiAgOztcbmVuZFxuIiwib3BlbiEgQ29yZVxuXG5tb2R1bGUgTWFrZSAoTWFwIDogVGhlX21hcF9pbnRmLlNfcGxhaW4pID0gc3RydWN0XG4gIG1vZHVsZSBUeXBlZF9maWVsZCA9IE1hcC5LZXlcblxuICB0eXBlIHRvX3NleHBlciA9IHsgZiA6ICdhLiAnYSBUeXBlZF9maWVsZC50IC0+ICdhIE1hcC5EYXRhLnQgLT4gU2V4cC50IH1cbiAgdHlwZSBvZl9zZXhwZXIgPSB7IGYgOiAnYS4gJ2EgTWFwLktleS50IC0+IFNleHAudCAtPiAnYSBNYXAuRGF0YS50IH1cbiAgdHlwZSBkZWZhdWx0ZXIgPSB7IGYgOiAnYS4gJ2EgTWFwLktleS50IC0+ICdhIE1hcC5EYXRhLnQgb3B0aW9uIH1cblxuICBsZXQgZGVmYXVsdF9kZWZhdWx0ZXIgPSB7IGYgPSAoZnVuIF8gLT4gTm9uZSkgfVxuXG4gIGxldCBzZXhwX29mX3QgKHRvX3NleHBlciA6IHRvX3NleHBlcikgKHQgOiBNYXAudCkgOiBTZXhwLnQgPVxuICAgIGxldCBtb2R1bGUgUCA9IFR5cGVkX2ZpZWxkLlBhY2tlZCBpblxuICAgIGxldCBzZXhwX29mX2ZpZWxkIHsgUC5mID0gVCBrZXkgfSA9XG4gICAgICBsZXQga2V5X3NleHAgPSBQLnNleHBfb2ZfdCB7IGYgPSBUIGtleSB9IGluXG4gICAgICBsZXQgZGF0YV9zZXhwID0gdG9fc2V4cGVyLmYga2V5IChNYXAuZmluZCB0IGtleSkgaW5cbiAgICAgIFNleHAuTGlzdCBbIGtleV9zZXhwOyBkYXRhX3NleHAgXVxuICAgIGluXG4gICAgTGlzdCAoTGlzdC5tYXAgVHlwZWRfZmllbGQuUGFja2VkLmFsbCB+ZjpzZXhwX29mX2ZpZWxkKVxuICA7O1xuXG4gIG1vZHVsZSBPcHRpb25hbF9tYXAgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgTWFwLkRhdGEudCBvcHRpb25cbiAgICBlbmRcblxuICAgIGluY2x1ZGUgVGhlX21hcC5NYWtlIChNYXAuS2V5KSAoVClcblxuICAgIGxldCBlbXB0eSA9IGNyZWF0ZSB7IGYgPSAoZnVuIF8gLT4gTm9uZSkgfVxuICBlbmRcblxuICBsZXQgcmFpc2VfaW52YWxpZF9zZXhwIHNleHAgPVxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIkNhbm5vdCBkZXNlcmlhbGl6ZSB0eXBlZF9maWVsZF9tYXAuIFJlYXNvbjogVW5yZWNvZ25pemVkIHNleHA6XCJcbiAgICAgICAgICB+Xzooc2V4cCA6IFNleHAudCldXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA/KGRlZmF1bHQgPSBkZWZhdWx0X2RlZmF1bHRlcikgKG9mX3NleHBlciA6IG9mX3NleHBlcikgKHNleHAgOiBTZXhwLnQpXG4gICAgOiBNYXAudFxuICAgID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuQXRvbSBfIC0+IHJhaXNlX2ludmFsaWRfc2V4cCBzZXhwXG4gICAgfCBMaXN0IGwgLT5cbiAgICAgIGxldCBtYXBfd2l0aF9wYXJzZWRfcmVzdWx0cyA9XG4gICAgICAgIExpc3QuZm9sZCBsIH5pbml0Ok9wdGlvbmFsX21hcC5lbXB0eSB+ZjooZnVuIGFjYyAtPiBmdW5jdGlvblxuICAgICAgICAgIHwgTGlzdCBbIGtleV9zZXhwOyBkYXRhX3NleHAgXSAtPlxuICAgICAgICAgICAgbGV0IHsgZiA9IFQga2V5IH0gPSBUeXBlZF9maWVsZC5QYWNrZWQudF9vZl9zZXhwIGtleV9zZXhwIGluXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG9mX3NleHBlci5mIGtleSBkYXRhX3NleHAgaW5cbiAgICAgICAgICAgIChtYXRjaCBPcHRpb25hbF9tYXAuZmluZCBhY2Mga2V5IHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gT3B0aW9uYWxfbWFwLnNldCBhY2MgfmtleSB+ZGF0YTooU29tZSBkYXRhKVxuICAgICAgICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICAgICAgICBsZXQgZHVwbGljYXRlX2ZpZWxkID0gVHlwZWRfZmllbGQubmFtZSBrZXkgaW5cbiAgICAgICAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgZGVzZXJpYWxpemUgdHlwZWRfZmllbGRfbWFwLiBSZWFzb246IGR1cGxpY2F0ZSBmaWVsZDpcIlxuICAgICAgICAgICAgICAgICAgICAgKGR1cGxpY2F0ZV9maWVsZCA6IHN0cmluZyldKVxuICAgICAgICAgIHwgXyAtPiByYWlzZV9pbnZhbGlkX3NleHAgc2V4cClcbiAgICAgIGluXG4gICAgICBNYXAuY3JlYXRlXG4gICAgICAgIHsgTWFwLmYgPVxuICAgICAgICAgICAgKGZ1biBmIC0+XG4gICAgICAgICAgICAgIG1hdGNoIE9wdGlvbmFsX21hcC5maW5kIG1hcF93aXRoX3BhcnNlZF9yZXN1bHRzIGYgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAobWF0Y2ggZGVmYXVsdC5mIGYgd2l0aFxuICAgICAgICAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBkYXRhXG4gICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBtaXNzaW5nX2ZpZWxkID0gVHlwZWRfZmllbGQubmFtZSBmIGluXG4gICAgICAgICAgICAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IGRlc2VyaWFsaXplIHR5cGVkX2ZpZWxkX21hcC4gUmVhc29uOiBtaXNzaW5nIGZpZWxkOlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKG1pc3NpbmdfZmllbGQgOiBzdHJpbmcpXSlcbiAgICAgICAgICAgICAgfCBTb21lIGRhdGEgLT4gZGF0YSlcbiAgICAgICAgfVxuICA7O1xuZW5kXG4iXX0=
