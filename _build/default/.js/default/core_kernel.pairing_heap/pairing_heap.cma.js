// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Pairing_heap
//# unitInfo: Requires: Base__Container, Core, Core__Array, Core__Int, Core__List, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Pairing_heap$0 = "Pairing_heap",
    cst_pairing_heap$0 = "pairing_heap",
    cst_pairing_heap_src_pairing_h = "pairing_heap/src/pairing_heap.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Core_Array = global_data.Core__Array,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Core_Option = global_data.Core__Option,
    Tuple_pool = global_data.Tuple_pool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int,
    Base_Container = global_data.Base__Container;
   caml_call1(Ppx_module_timer_runtime[4], cst_Pairing_heap$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_pairing_heap$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_pairing_heap_src_pairing_h);
   caml_call2(Ppx_inline_test_lib[6], cst_pairing_heap$0, "pairing_heap.ml");
   var
    empty = Tuple_pool[3][4],
    is_empty = Tuple_pool[3][5],
    equal = Tuple_pool[3][7],
    cst_cannot_remove_from_a_diffe = "cannot remove from a different heap",
    cst_Heap_value_exn_node_was_re =
      "Heap.value_exn: node was removed from the heap",
    cst_Heap_top_exn_called_on_an_ = "Heap.top_exn called on an empty heap",
    _d_ = [0, cst_pairing_heap_src_pairing_h, 239, 10],
    _e_ = [0, cst_pairing_heap_src_pairing_h, 237, 8],
    _f_ = [0, cst_pairing_heap_src_pairing_h, 246, 2],
    _a_ = [0, cst_pairing_heap_src_pairing_h, 110, 4],
    cst_pairing_heap = cst_pairing_heap$0,
    cst_Pairing_heap = cst_Pairing_heap$0,
    dummy_id = -1;
   function child(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][4]);
   }
   function sibling(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][5]);
   }
   function prev(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][6]);
   }
   function id(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][7]);
   }
   function set_child(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][4], v);
   }
   function set_sibling(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][5], v);
   }
   function set_prev(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][6], v);
   }
   function value_exn(t, pool){
    if(caml_call1(is_empty, t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][3]);
   }
   function allocate(value, pool, id){
    var
     _H_ = caml_call1(empty, 0),
     _I_ = caml_call1(empty, 0),
     _J_ = caml_call1(empty, 0);
    return caml_call6(Tuple_pool[21], pool, value, _J_, _I_, _H_, id);
   }
   function free(t, pool){return caml_call2(Tuple_pool[16], pool, t);}
   function disconnect_sibling(t, pool){
    var sibling$0 = sibling(t, pool);
    if(1 - caml_call1(is_empty, sibling$0)){
     set_sibling(t, caml_call1(empty, 0), pool);
     set_prev(sibling$0, caml_call1(empty, 0), pool);
    }
    return sibling$0;
   }
   function disconnect_child(t, pool){
    var child$0 = child(t, pool);
    if(1 - caml_call1(is_empty, child$0)){
     set_child(t, caml_call1(empty, 0), pool);
     set_prev(child$0, caml_call1(empty, 0), pool);
    }
    return child$0;
   }
   function detach(t, pool){
    if(1 - caml_call1(is_empty, t)){
     var prev$0 = prev(t, pool);
     if(1 - caml_call1(is_empty, prev$0)){
      var
       relation_to_prev =
         caml_call2(equal, t, child(prev$0, pool)) ? -977688164 : -560648958;
      set_prev(t, caml_call1(empty, 0), pool);
      var sibling = disconnect_sibling(t, pool);
      if(-560648958 <= relation_to_prev)
       set_sibling(prev$0, sibling, pool);
      else
       set_child(prev$0, sibling, pool);
      if(1 - caml_call1(is_empty, sibling))
       return set_prev(sibling, prev$0, pool);
     }
    }
    return;
   }
   function create(capacity){
    var
     _E_ = caml_call1(Tuple_pool[3][4], 0),
     _F_ = caml_call1(Tuple_pool[3][4], 0),
     _G_ = [0, 0, caml_call1(Tuple_pool[3][4], 0), _F_, _E_, dummy_id];
    return caml_call3(Tuple_pool[9], Tuple_pool[1][21], capacity, _G_);
   }
   var _b_ = Core_Int[87], _c_ = Core_Int[64];
   function invariant(param, t){
    if
     (!
      caml_call1(is_empty, t[3])
      && ! caml_call1(is_empty, sibling(t[3], t[2])))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var
     _C_ = caml_call1(empty, 0),
     to_visit$2 = [0, [0, t[3], _C_, 0], 0],
     to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return 0;
     var
      to_visit$0 = to_visit[2],
      match = to_visit[1],
      maybe_parent_value = match[3],
      expected_prev = match[2],
      node = match[1];
     if(caml_call1(is_empty, node))
      var to_visit = to_visit$0;
     else{
      var this_value = value_exn(node, t[2]);
      if(! caml_call2(equal, prev(node, t[2]), expected_prev))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var
       _A_ =
         function(this_value){
           return function(parent_value){
            var _D_ = caml_call2(t[1], parent_value, this_value);
            if(caml_call2(Core[89], _D_, 0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);};
          }
          (this_value);
      caml_call2(Core_Option[46], maybe_parent_value, _A_);
      var
       _B_ =
         [0, [0, sibling(node, t[2]), node, maybe_parent_value], to_visit$0],
       to_visit$1 = [0, [0, child(node, t[2]), node, [0, this_value]], _B_],
       to_visit = to_visit$1;
     }
    }
   }
   function create$0(opt, cmp, param){
    if(opt) var sth = opt[1], min_size = sth; else var min_size = 1;
    var _z_ = caml_call1(empty, 0);
    return [0, cmp, create(min_size), _z_, 0];
   }
   function copy(param){
    var
     cmp = param[1],
     pool$0 = param[2],
     start = param[3],
     num_of_allocated_nodes = param[4],
     pool = create(caml_call1(Tuple_pool[11], pool$0));
    function copy_node(node, to_visit){
     if(caml_call1(is_empty, node))
      return [0, caml_call1(empty, 0), to_visit];
     var
      _x_ = id(node, pool$0),
      new_node = allocate(value_exn(node, pool$0), pool, _x_),
      _y_ = [0, [0, new_node, -560648958, sibling(node, pool$0)], to_visit],
      to_visit$0 = [0, [0, new_node, -977688164, child(node, pool$0)], _y_];
     return [0, new_node, to_visit$0];
    }
    var
     match$1 = copy_node(start, 0),
     to_visit$1 = match$1[2],
     new_start = match$1[1],
     to_visit = to_visit$1;
    for(;;){
     if(! to_visit) return [0, cmp, pool, new_start, num_of_allocated_nodes];
     var
      rest = to_visit[2],
      match = to_visit[1],
      node_to_copy = match[3],
      slot = match[2],
      node_to_update = match[1],
      match$0 = copy_node(node_to_copy, rest),
      to_visit$0 = match$0[2],
      new_node = match$0[1];
     if(-560648958 <= slot)
      set_sibling(node_to_update, new_node, pool);
     else
      set_child(node_to_update, new_node, pool);
     if(1 - caml_call1(is_empty, new_node))
      set_prev(new_node, node_to_update, pool);
     var to_visit = to_visit$0;
    }
   }
   function merge(t, root1, root2){
    if(caml_call1(is_empty, root1)) return root2;
    if(caml_call1(is_empty, root2)) return root1;
    function add_child(t, node, new_child){
     var pool = t[2], current_child = disconnect_child(node, pool);
     set_sibling(new_child, current_child, pool);
     if(1 - caml_call1(is_empty, current_child))
      set_prev(current_child, new_child, pool);
     set_child(node, new_child, pool);
     set_prev(new_child, node, pool);
     return node;
    }
    var
     v1 = value_exn(root1, t[2]),
     v2 = value_exn(root2, t[2]),
     _w_ = caml_call2(t[1], v1, v2);
    return caml_call2(Core[92], _w_, 0)
            ? add_child(t, root1, root2)
            : add_child(t, root2, root1);
   }
   function top_exn(t){
    return caml_call1(is_empty, t[3])
            ? caml_call1(Core[6], cst_Heap_top_exn_called_on_an_)
            : value_exn(t[3], t[2]);
   }
   function top(t){return caml_call1(is_empty, t[3]) ? 0 : [0, top_exn(t)];}
   function add_node(t$1, v){
    var t = t$1[2];
    if(caml_call1(Tuple_pool[14], t)){
     var t$0 = t$1[2];
     t$1[2] = caml_call2(Tuple_pool[13], 0, t$0);
    }
    t$1[4] = t$1[4] + 1 | 0;
    var _v_ = caml_call1(_c_, t$1[4]), node = allocate(v, t$1[2], _v_);
    t$1[3] = merge(t$1, t$1[3], node);
    return node;
   }
   function add(t, v){add_node(t, v); return 0;}
   var max_stack_depth = 1000;
   function loop(t, depth, head$0){
    if(! caml_call2(Core[88], depth, max_stack_depth)){
     if(caml_call1(is_empty, head$0)) return head$0;
     var next1$0 = disconnect_sibling(head$0, t[2]);
     if(caml_call1(is_empty, next1$0)) return head$0;
     var
      next2$0 = disconnect_sibling(next1$0, t[2]),
      _u_ = loop(t, depth + 1 | 0, next2$0);
     return merge(t, merge(t, head$0, next1$0), _u_);
    }
    var acc = 0, head = head$0;
    for(;;){
     if(caml_call1(is_empty, head))
      var match = acc;
     else{
      var next1 = disconnect_sibling(head, t[2]);
      if(! caml_call1(is_empty, next1)){
       var
        next2 = disconnect_sibling(next1, t[2]),
        acc$0 = [0, merge(t, head, next1), acc],
        acc = acc$0,
        head = next2;
       continue;
      }
      var match = [0, head, acc];
     }
     if(! match) return caml_call1(empty, 0);
     var h = match[1];
     if(! match[2]) return h;
     var
      xs = match[2],
      _t_ = function(acc, heap){return merge(t, acc, heap);};
     return caml_call3(Core_List[20], xs, h, _t_);
    }
   }
   function remove_non_empty(t, node){
    var pool = t[2];
    detach(node, pool);
    var
     head = disconnect_child(node, pool),
     merged_children = loop(t, 0, head),
     new_root =
       caml_call2(equal, t[3], node)
        ? merged_children
        : merge(t, t[3], merged_children);
    free(node, pool);
    t[3] = new_root;
    return 0;
   }
   function remove_top(t){
    var _s_ = 1 - caml_call1(is_empty, t[3]);
    return _s_ ? remove_non_empty(t, t[3]) : _s_;
   }
   function clear(t){
    var _q_ = 1 - caml_call1(is_empty, t[3]);
    if(_q_){
     var pool = t[2], node$0 = t[3], node = node$0;
     for(;;){
      var child$0 = child(node, pool), sibling$0 = sibling(node, pool);
      if(caml_call1(is_empty, child$0))
       if(caml_call1(is_empty, sibling$0)){
        var prev$0 = prev(node, pool);
        detach(node, pool);
        free(node, pool);
        if(! (1 - caml_call1(is_empty, prev$0))){
         t[3] = caml_call1(empty, 0);
         var _r_ = 0;
         break;
        }
        var node = prev$0;
       }
       else
        var node = sibling$0;
      else
       var node = child$0;
     }
    }
    else
     var _r_ = _q_;
    return _r_;
   }
   function pop_exn(t){var r = top_exn(t); remove_top(t); return r;}
   function pop(t){return caml_call1(is_empty, t[3]) ? 0 : [0, pop_exn(t)];}
   function pop_if(t, f){
    var match = top(t);
    if(! match) return 0;
    var v = match[1];
    return caml_call1(f, v) ? (remove_top(t), [0, v]) : 0;
   }
   function pop_while(t, f){
    var acc = 0;
    for(;;){
     var match = pop_if(t, f);
     if(! match) return caml_call1(Core_List[59], acc);
     var x = match[1], acc$0 = [0, x, acc], acc = acc$0;
    }
   }
   function fold(t, init, f){
    var
     pool = t[2],
     to_visit$2 = [0, t[3], 0],
     acc = init,
     to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return acc;
     var to_visit$0 = to_visit[2], node = to_visit[1];
     if(caml_call1(is_empty, node))
      var to_visit = to_visit$0;
     else
      var
       _p_ = [0, child(node, pool), to_visit$0],
       to_visit$1 = [0, sibling(node, pool), _p_],
       acc$0 = caml_call2(f, acc, value_exn(node, pool)),
       acc = acc$0,
       to_visit = to_visit$1;
    }
   }
   function iter(t, f){
    var pool = t[2], to_visit$2 = [0, t[3], 0], to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return 0;
     var to_visit$0 = to_visit[2], node = to_visit[1];
     if(caml_call1(is_empty, node))
      var to_visit = to_visit$0;
     else{
      caml_call1(f, value_exn(node, pool));
      var
       _o_ = [0, child(node, pool), to_visit$0],
       to_visit$1 = [0, sibling(node, pool), _o_],
       to_visit = to_visit$1;
     }
    }
   }
   function length(t){var t$0 = t[2]; return caml_call1(Tuple_pool[12], t$0);}
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = caml_call1(Base_Container[17], [0, fold, iter$0, length$0]);
   function is_empty$0(t){return caml_call1(is_empty, t[3]);}
   var
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7];
   function of_array(arr, cmp){
    var t = create$0([0, arr.length - 1], cmp, 0);
    function _n_(v){return add(t, v);}
    caml_call2(Core_Array[35], arr, _n_);
    return t;
   }
   function of_list(l, cmp){
    return of_array(caml_call1(Core_Array[24], l), cmp);
   }
   function sexp_of_t(f, t){
    var
     _k_ = t[1],
     _l_ = caml_call1(to_array, t),
     _m_ = caml_call2(Core_Array[118], _l_, _k_);
    return caml_call2(Core_Array[20], f, _m_);
   }
   function is_node_valid(t){
    var _j_ = t[2];
    return caml_call2(_b_, id(t[1], t[3][2]), _j_);
   }
   function value_exn$0(t){
    return is_node_valid(t)
            ? value_exn(t[1], t[3][2])
            : caml_call1(Core[6], cst_Heap_value_exn_node_was_re);
   }
   function sexp_of_t$0(sexp_of_a, t){
    var x_001 = is_node_valid(t) ? [0, value_exn(t[1], t[3][2])] : 0;
    return caml_call2(Core[515], sexp_of_a, x_001);
   }
   function remove(t, token){
    if(t !== token[3])
     return caml_call1(Core[6], cst_cannot_remove_from_a_diffe);
    var _h_ = 1 - caml_call1(is_empty, token[1]);
    if(_h_){
     if(is_node_valid(token)) remove_non_empty(t, token[1]);
     token[1] = caml_call1(empty, 0);
     var _i_ = 0;
    }
    else
     var _i_ = _h_;
    return _i_;
   }
   function add_removable(t, v){
    var node = add_node(t, v);
    return [0, node, id(node, t[2]), t];
   }
   function update(t, token, v){remove(t, token); return add_removable(t, v);}
   function find_elt(t, f){
    var nodes$2 = [0, t[3], 0], nodes = nodes$2;
    for(;;){
     if(! nodes) return 0;
     var nodes$0 = nodes[2], node = nodes[1];
     if(caml_call1(is_empty, node))
      var nodes = nodes$0;
     else{
      if(caml_call1(f, value_exn(node, t[2])))
       return [0, [0, node, id(node, t[2]), t]];
      var
       _g_ = [0, child(node, t[2]), nodes$0],
       nodes$1 = [0, sibling(node, t[2]), _g_],
       nodes = nodes$1;
     }
    }
   }
   function value(t, heap){return value_exn(t, heap[2]);}
   var Elt = [0, value];
   function update$0(t, elt, v){
    remove_non_empty(t, elt);
    return add_node(t, v);
   }
   var Unsafe = [0, Elt, add_node, remove_non_empty, update$0];
   caml_call1(Ppx_inline_test_lib[7], cst_pairing_heap);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Pairing_heap);
   var
    Pairing_heap =
      [0,
       sexp_of_t,
       mem,
       length,
       is_empty$0,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       invariant,
       min_elt,
       max_elt,
       create$0,
       of_array,
       of_list,
       top,
       top_exn,
       add,
       remove_top,
       clear,
       pop,
       pop_exn,
       pop_if,
       pop_while,
       copy,
       [0, sexp_of_t$0, value_exn$0],
       add_removable,
       remove,
       update,
       find_elt,
       Unsafe];
   runtime.caml_register_global(26, Pairing_heap, cst_Pairing_heap$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwYWlyaW5nX2hlYXAuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVtcHR5IiwiaXNfZW1wdHkiLCJlcXVhbCIsImR1bW15X2lkIiwiY2hpbGQiLCJ0IiwicG9vbCIsInNpYmxpbmciLCJwcmV2IiwiaWQiLCJzZXRfY2hpbGQiLCJ2Iiwic2V0X3NpYmxpbmciLCJzZXRfcHJldiIsInZhbHVlX2V4biIsImFsbG9jYXRlIiwidmFsdWUiLCJmcmVlIiwiZGlzY29ubmVjdF9zaWJsaW5nIiwic2libGluZyQwIiwiZGlzY29ubmVjdF9jaGlsZCIsImNoaWxkJDAiLCJkZXRhY2giLCJwcmV2JDAiLCJyZWxhdGlvbl90b19wcmV2IiwiY3JlYXRlIiwiY2FwYWNpdHkiLCJpbnZhcmlhbnQiLCJ0b192aXNpdCQyIiwidG9fdmlzaXQiLCJ0b192aXNpdCQwIiwibWF5YmVfcGFyZW50X3ZhbHVlIiwiZXhwZWN0ZWRfcHJldiIsIm5vZGUiLCJ0aGlzX3ZhbHVlIiwicGFyZW50X3ZhbHVlIiwidG9fdmlzaXQkMSIsImNyZWF0ZSQwIiwib3B0IiwiY21wIiwic3RoIiwibWluX3NpemUiLCJjb3B5IiwicG9vbCQwIiwic3RhcnQiLCJudW1fb2ZfYWxsb2NhdGVkX25vZGVzIiwiY29weV9ub2RlIiwibmV3X25vZGUiLCJuZXdfc3RhcnQiLCJyZXN0Iiwibm9kZV90b19jb3B5Iiwic2xvdCIsIm5vZGVfdG9fdXBkYXRlIiwibWVyZ2UiLCJyb290MSIsInJvb3QyIiwiYWRkX2NoaWxkIiwibmV3X2NoaWxkIiwiY3VycmVudF9jaGlsZCIsInYxIiwidjIiLCJ0b3BfZXhuIiwidG9wIiwiYWRkX25vZGUiLCJ0JDEiLCJ0JDAiLCJhZGQiLCJtYXhfc3RhY2tfZGVwdGgiLCJsb29wIiwiZGVwdGgiLCJoZWFkJDAiLCJuZXh0MSQwIiwibmV4dDIkMCIsImFjYyIsImhlYWQiLCJuZXh0MSIsIm5leHQyIiwiYWNjJDAiLCJoIiwieHMiLCJoZWFwIiwicmVtb3ZlX25vbl9lbXB0eSIsIm1lcmdlZF9jaGlsZHJlbiIsIm5ld19yb290IiwicmVtb3ZlX3RvcCIsImNsZWFyIiwibm9kZSQwIiwicG9wX2V4biIsInIiLCJwb3AiLCJwb3BfaWYiLCJmIiwicG9wX3doaWxlIiwieCIsImZvbGQiLCJpbml0IiwiaXRlciIsImxlbmd0aCIsIml0ZXIkMCIsImxlbmd0aCQwIiwiaXNfZW1wdHkkMCIsIm1lbSIsImV4aXN0cyIsImZvcl9hbGwiLCJjb3VudCIsInN1bSIsImZpbmQiLCJmaW5kX21hcCIsInRvX2xpc3QiLCJ0b19hcnJheSIsIm1pbl9lbHQiLCJtYXhfZWx0IiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwib2ZfYXJyYXkiLCJhcnIiLCJvZl9saXN0IiwibCIsInNleHBfb2ZfdCIsImlzX25vZGVfdmFsaWQiLCJ2YWx1ZV9leG4kMCIsInNleHBfb2ZfdCQwIiwic2V4cF9vZl9hIiwieF8wMDEiLCJyZW1vdmUiLCJ0b2tlbiIsImFkZF9yZW1vdmFibGUiLCJ1cGRhdGUiLCJmaW5kX2VsdCIsIm5vZGVzJDIiLCJub2RlcyIsIm5vZGVzJDAiLCJub2RlcyQxIiwidXBkYXRlJDAiLCJlbHQiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlX2tlcm5lbC9wYWlyaW5nX2hlYXAvcGFpcmluZ19oZWFwLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQThGTUE7SUFDQUM7SUFDQUM7Ozs7Ozs7Ozs7O0lBVEFDO1lBV0FDLE1BQU1DLEdBQUdDO0lBQU8sa0NBQVBBLE1BQUhEO0dBQXNDO1lBQzVDRSxRQUFRRixHQUFHQztJQUFPLGtDQUFQQSxNQUFIRDtHQUFzQztZQUM5Q0csS0FBS0gsR0FBR0M7SUFBTyxrQ0FBUEEsTUFBSEQ7R0FBc0M7WUFDM0NJLEdBQUdKLEdBQUdDO0lBQU8sa0NBQVBBLE1BQUhEO0dBQXNDO1lB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SnhDLGNBSVBoRTtZQU1GcUgsU0FBT2hJLEdBQUVpSSxLQUFJM0g7SUF6TWZzRSxpQkF5TVM1RSxHQUFFaUk7SUFDWCxPQXZTQXZFLFNBc1NTMUQsR0FBTU07R0FFRTtHQWJMLHNCQTNSWm9ELFVBNkZBa0Isa0JBeU1Fb0Q7Ozs7Ozs7O09BdkVGZjtPQXJCQWpCO09BWEFKO09BVUFHO09BMUJBSjtPQWhCQUY7T0FzREFrQjtPQUNBQztPQVhBWDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQS9SQWxGO09BZ1NBbUY7T0FDQUM7T0E1UUExRTtPQWdSQTZFO09BTUFFO09BaE9BdEQ7T0FOQUQ7T0FjQUs7T0FrR0FrQjtPQWtCQUM7T0FhQUk7T0FOQUY7T0FRQUc7T0FXQUU7T0FwTUFsRDtXQXNTRStFLGFBTkFEO09Ba0JGTTtPQVRBRjtPQWNBRztPQUtBQzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQ29yZVxubW9kdWxlIFBvb2wgPSBUdXBsZV9wb29sXG5tb2R1bGUgUG9pbnRlciA9IFBvb2wuUG9pbnRlclxuXG4oKiBUaGlzIHBvb2wgaG9sZHMgbm9kZXMgdGhhdCB3b3VsZCBiZSByZXByZXNlbnRlZCBtb3JlIHRyYWRpdGlvbmFsbHkgYXM6XG5cbiAgIHtbXG4gICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgfCBFbXB0eVxuICAgICAgIHwgSGVhcCBvZiAnYSAqICdhIHQgbGlzdCBdfVxuXG4gICBXZSB3aWxsIHJlcHJlc2VudCB0aGVtIGFzIGEgbGVmdC1jaGlsZCwgcmlnaHQtc2libGluZyB0cmVlIGluIGEgdHJpcGxldFxuICAgKHZhbHVlICogbGVmdF9jaGlsZCAqIHJpZ2h0X3NpYmxpbmcpLiAgVGhlIGxlZnQgY2hpbGQgYW5kIGFsbCByaWdodCBzaWJsaW5nc1xuICAgb2YgdGhlIGxlZnQgY2hpbGQgZm9ybSBhIGxpbmtlZCBsaXN0IHJlcHJlc2VudGluZyB0aGUgc3ViaGVhcHMgb2YgYSBnaXZlbiBoZWFwOlxuXG4gICB7dlxuICAgICAgICAgQVxuICAgICAgICAvXG4gICAgICAgQiAtPiBDIC0+IEQgLT4gRSAtPiBGXG4gICAgICAvICAgICAgICAgLyAgICAgICAgIC9cbiAgICAgRyAgICAgICAgIEgtPkktPkogICBLLT5MXG4gICB2fSAqKVxuXG5tb2R1bGUgTm9kZSA6IHNpZ1xuICAoKiBFeHBvc2luZyBbcHJpdmF0ZSBpbnRdIGlzIGEgc2lnbmlmaWNhbnQgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQsIGJlY2F1c2UgaXQgYWxsb3dzXG4gICAgIHRoZSBjb21waWxlciB0byBza2lwIHRoZSB3cml0ZSBiYXJyaWVyLiAqKVxuXG4gIHR5cGUgJ2EgdCA9IHByaXZhdGUgaW50XG5cbiAgbW9kdWxlIElkIDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICBlbmRcblxuICBtb2R1bGUgUG9vbCA6IHNpZ1xuICAgIHR5cGUgJ2Egbm9kZSA9ICdhIHRcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBjcmVhdGUgOiBtaW5fc2l6ZTppbnQgLT4gJ2EgdFxuICAgIHZhbCBpc19mdWxsIDogJ2EgdCAtPiBib29sXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gICAgdmFsIGdyb3cgOiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2Egbm9kZSAtPiAnYSBub2RlICogJ2EgdFxuICBlbmRcblxuICAoKiogW2FsbG9jYXRlIHYgfnBvb2xdIGFsbG9jYXRlcyBhIG5ldyBub2RlIGZyb20gdGhlIHBvb2wgd2l0aCBubyBjaGlsZCBvciBzaWJsaW5nICopXG4gIHZhbCBhbGxvY2F0ZSA6ICdhIC0+IHBvb2w6J2EgUG9vbC50IC0+IGlkOklkLnQgLT4gJ2EgdFxuXG4gICgqKiBbZnJlZSB0IH5wb29sXSBmcmVlcyBbdF0gZm9yIHJldXNlLiAgSXQgaXMgYW4gZXJyb3IgdG8gYWNjZXNzIFt0XSBhZnRlciB0aGlzLiAqKVxuICB2YWwgZnJlZSA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gdW5pdFxuXG4gICgqKiBhIHNwZWNpYWwgW3RdIHRoYXQgcmVwcmVzZW50cyB0aGUgZW1wdHkgbm9kZSAqKVxuICB2YWwgZW1wdHkgOiB1bml0IC0+ICdhIHRcblxuICB2YWwgaXNfZW1wdHkgOiAnYSB0IC0+IGJvb2xcbiAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcblxuICAoKiogW3ZhbHVlX2V4biB0IH5wb29sXSByZXR1cm4gdGhlIHZhbHVlIG9mIFt0XSwgcmFpc2UgaWYgW2lzX2VtcHR5IHRdICopXG4gIHZhbCB2YWx1ZV9leG4gOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhXG5cbiAgdmFsIGlkIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiBJZC50XG4gIHZhbCBjaGlsZCA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2EgdFxuICB2YWwgc2libGluZyA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2EgdFxuXG4gICgqKiBbcHJldiB0XSBpcyBlaXRoZXIgdGhlIHBhcmVudCBvZiBbdF0gb3IgdGhlIHNpYmxpbmcgaW1tZWRpYXRlbHkgbGVmdCBvZiBbdF0gKilcbiAgdmFsIHByZXYgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhIHRcblxuICAoKiogW2FkZF9jaGlsZCB0IH5jaGlsZCB+cG9vbF0gQWRkIGEgY2hpbGQgdG8gW3RdLCBwcmVzZXJ2aW5nIGV4aXN0aW5nIGNoaWxkcmVuIGFzXG4gICAgICBzaWJsaW5ncyBvZiBbY2hpbGRdLiBbdF0gYW5kIFtjaGlsZF0gc2hvdWxkIG5vdCBiZSBlbXB0eSBhbmQgW2NoaWxkXSBzaG91bGQgaGF2ZSBub1xuICAgICAgc2libGluZyBhbmQgaGF2ZSBubyBwcmV2IG5vZGUuICopXG4gIHZhbCBhZGRfY2hpbGQgOiAnYSB0IC0+IGNoaWxkOidhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gdW5pdFxuXG4gICgqKiBkaXNjb25uZWN0IGFuZCByZXR1cm4gdGhlIHNpYmxpbmcgKilcbiAgdmFsIGRpc2Nvbm5lY3Rfc2libGluZyA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2EgdFxuXG4gICgqKiBkaXNjb25uZWN0IGFuZCByZXR1cm4gdGhlIGNoaWxkICopXG4gIHZhbCBkaXNjb25uZWN0X2NoaWxkIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYSB0XG5cbiAgKCoqIFtkZXRhY2ggdCB+cG9vbF0gcmVtb3ZlcyBbdF0gZnJvbSB0aGUgdHJlZSwgYWRqdXN0aW5nIHBvaW50ZXJzIGFyb3VuZCBpdC4gQWZ0ZXJcbiAgICAgIFtkZXRhY2hdLCBbdF0gaXMgdGhlIHJvb3Qgb2YgYSBzdGFuZGFsb25lIGhlYXAsIHdoaWNoIGlzIGRldGFjaGVkIGZyb20gdGhlIG9yaWdpbmFsXG4gICAgICBoZWFwLiAqKVxuICB2YWwgZGV0YWNoIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIElkID0gSW50XG5cbiAgbGV0IGR1bW15X2lkIDogSWQudCA9IC0xXG5cbiAgdHlwZSAnYSBub2RlID1cbiAgICAoJ2EsICdhIG5vZGUgUG9pbnRlci50LCAnYSBub2RlIFBvaW50ZXIudCwgJ2Egbm9kZSBQb2ludGVyLnQsIElkLnQpIFBvb2wuU2xvdHMudDVcblxuICB0eXBlICdhIHQgPSAnYSBub2RlIFBvaW50ZXIudFxuXG4gIGxldCBlbXB0eSA9IFBvaW50ZXIubnVsbFxuICBsZXQgaXNfZW1wdHkgPSBQb2ludGVyLmlzX251bGxcbiAgbGV0IGVxdWFsID0gUG9pbnRlci5waHlzX2VxdWFsXG4gIGxldCB2YWx1ZSB0IH5wb29sID0gUG9vbC5nZXQgcG9vbCB0IFBvb2wuU2xvdC50MFxuICBsZXQgY2hpbGQgdCB+cG9vbCA9IFBvb2wuZ2V0IHBvb2wgdCBQb29sLlNsb3QudDFcbiAgbGV0IHNpYmxpbmcgdCB+cG9vbCA9IFBvb2wuZ2V0IHBvb2wgdCBQb29sLlNsb3QudDJcbiAgbGV0IHByZXYgdCB+cG9vbCA9IFBvb2wuZ2V0IHBvb2wgdCBQb29sLlNsb3QudDNcbiAgbGV0IGlkIHQgfnBvb2wgPSBQb29sLmdldCBwb29sIHQgUG9vbC5TbG90LnQ0XG5cbiAgKCogbGV0IHNldF92YWx1ZSAgIHQgdiB+cG9vbCA9IFBvb2wuc2V0IHBvb2wgdCBQb29sLlNsb3QudDAgdiAqKVxuICBsZXQgc2V0X2NoaWxkIHQgdiB+cG9vbCA9IFBvb2wuc2V0IHBvb2wgdCBQb29sLlNsb3QudDEgdlxuICBsZXQgc2V0X3NpYmxpbmcgdCB2IH5wb29sID0gUG9vbC5zZXQgcG9vbCB0IFBvb2wuU2xvdC50MiB2XG4gIGxldCBzZXRfcHJldiB0IHYgfnBvb2wgPSBQb29sLnNldCBwb29sIHQgUG9vbC5TbG90LnQzIHZcblxuICBsZXQgdmFsdWVfZXhuIHQgfnBvb2wgPVxuICAgIGFzc2VydCAobm90IChpc19lbXB0eSB0KSk7XG4gICAgdmFsdWUgdCB+cG9vbFxuICA7O1xuXG4gIGxldCBhbGxvY2F0ZSB2YWx1ZSB+cG9vbCB+aWQgPSBQb29sLm5ldzUgcG9vbCB2YWx1ZSAoZW1wdHkgKCkpIChlbXB0eSAoKSkgKGVtcHR5ICgpKSBpZFxuICBsZXQgZnJlZSB0IH5wb29sID0gUG9vbC51bnNhZmVfZnJlZSBwb29sIHRcblxuICBsZXQgZGlzY29ubmVjdF9zaWJsaW5nIHQgfnBvb2wgPVxuICAgIGxldCBzaWJsaW5nID0gc2libGluZyB0IH5wb29sIGluXG4gICAgaWYgbm90IChpc19lbXB0eSBzaWJsaW5nKVxuICAgIHRoZW4gKFxuICAgICAgc2V0X3NpYmxpbmcgdCAoZW1wdHkgKCkpIH5wb29sO1xuICAgICAgc2V0X3ByZXYgc2libGluZyAoZW1wdHkgKCkpIH5wb29sKTtcbiAgICBzaWJsaW5nXG4gIDs7XG5cbiAgbGV0IGRpc2Nvbm5lY3RfY2hpbGQgdCB+cG9vbCA9XG4gICAgbGV0IGNoaWxkID0gY2hpbGQgdCB+cG9vbCBpblxuICAgIGlmIG5vdCAoaXNfZW1wdHkgY2hpbGQpXG4gICAgdGhlbiAoXG4gICAgICBzZXRfY2hpbGQgdCAoZW1wdHkgKCkpIH5wb29sO1xuICAgICAgc2V0X3ByZXYgY2hpbGQgKGVtcHR5ICgpKSB+cG9vbCk7XG4gICAgY2hpbGRcbiAgOztcblxuICBsZXQgYWRkX2NoaWxkIHQgfmNoaWxkOm5ld19jaGlsZCB+cG9vbCA9XG4gICAgKCogYXNzZXJ0aW9ucyB3ZSB3b3VsZCBtYWtlLCBidXQgZm9yIHNwZWVkOlxuICAgICAgIGFzc2VydCAobm90IChpc19lbXB0eSB0KSk7XG4gICAgICAgYXNzZXJ0IChub3QgKGlzX2VtcHR5IG5ld19jaGlsZCkpO1xuICAgICAgIGFzc2VydCAoaXNfZW1wdHkgKHNpYmxpbmcgbmV3X2NoaWxkIH5wb29sKSk7XG4gICAgICAgYXNzZXJ0IChpc19lbXB0eSAocHJldiBuZXdfY2hpbGQgfnBvb2wpKTtcbiAgICAqKVxuICAgIGxldCBjdXJyZW50X2NoaWxkID0gZGlzY29ubmVjdF9jaGlsZCB0IH5wb29sIGluXG4gICAgKCogYWRkIFtuZXdfY2hpbGRdIHRvIHRoZSBsaXN0IG9mIFt0XSdzIGNoaWxkcmVuICh3aGljaCBtYXkgYmUgZW1wdHkpICopXG4gICAgc2V0X3NpYmxpbmcgbmV3X2NoaWxkIGN1cnJlbnRfY2hpbGQgfnBvb2w7XG4gICAgaWYgbm90IChpc19lbXB0eSBjdXJyZW50X2NoaWxkKSB0aGVuIHNldF9wcmV2IGN1cnJlbnRfY2hpbGQgbmV3X2NoaWxkIH5wb29sO1xuICAgIHNldF9jaGlsZCB0IG5ld19jaGlsZCB+cG9vbDtcbiAgICBzZXRfcHJldiBuZXdfY2hpbGQgdCB+cG9vbFxuICA7O1xuXG4gIGxldCBkZXRhY2ggdCB+cG9vbCA9XG4gICAgaWYgbm90IChpc19lbXB0eSB0KVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHByZXYgPSBwcmV2IHQgfnBvb2wgaW5cbiAgICAgIGlmIG5vdCAoaXNfZW1wdHkgcHJldilcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgcmVsYXRpb25fdG9fcHJldiA9IGlmIGVxdWFsIHQgKGNoaWxkIHByZXYgfnBvb2wpIHRoZW4gYGNoaWxkIGVsc2UgYHNpYmxpbmcgaW5cbiAgICAgICAgc2V0X3ByZXYgdCAoZW1wdHkgKCkpIH5wb29sO1xuICAgICAgICBsZXQgc2libGluZyA9IGRpc2Nvbm5lY3Rfc2libGluZyB0IH5wb29sIGluXG4gICAgICAgIChtYXRjaCByZWxhdGlvbl90b19wcmV2IHdpdGhcbiAgICAgICAgIHwgYGNoaWxkIC0+IHNldF9jaGlsZCBwcmV2IHNpYmxpbmcgfnBvb2xcbiAgICAgICAgIHwgYHNpYmxpbmcgLT4gc2V0X3NpYmxpbmcgcHJldiBzaWJsaW5nIH5wb29sKTtcbiAgICAgICAgaWYgbm90IChpc19lbXB0eSBzaWJsaW5nKSB0aGVuIHNldF9wcmV2IHNpYmxpbmcgcHJldiB+cG9vbCkpXG4gIDs7XG5cbiAgbW9kdWxlIFBvb2wgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBub2RlIFBvb2wudFxuICAgIHR5cGUgbm9ucmVjICdhIG5vZGUgPSAnYSBub2RlIFBvaW50ZXIudFxuXG4gICAgbGV0IGNyZWF0ZSAodHlwZSBhKSB+bWluX3NpemU6Y2FwYWNpdHkgOiBhIHQgPVxuICAgICAgUG9vbC5jcmVhdGVcbiAgICAgICAgUG9vbC5TbG90cy50NVxuICAgICAgICB+Y2FwYWNpdHlcbiAgICAgICAgfmR1bW15OlxuICAgICAgICAgICggKE9iai5tYWdpYyBOb25lIDogYSlcbiAgICAgICAgICAsIFBvaW50ZXIubnVsbCAoKVxuICAgICAgICAgICwgUG9pbnRlci5udWxsICgpXG4gICAgICAgICAgLCBQb2ludGVyLm51bGwgKClcbiAgICAgICAgICAsIGR1bW15X2lkIClcbiAgICA7O1xuXG4gICAgbGV0IGlzX2Z1bGwgdCA9IFBvb2wuaXNfZnVsbCB0XG4gICAgbGV0IGxlbmd0aCB0ID0gUG9vbC5sZW5ndGggdFxuICAgIGxldCBncm93IHQgPSBQb29sLmdyb3cgdFxuXG4gICAgbGV0IGNvcHkgdCBzdGFydCA9XG4gICAgICBsZXQgdCcgPSBjcmVhdGUgfm1pbl9zaXplOihQb29sLmNhcGFjaXR5IHQpIGluXG4gICAgICBsZXQgY29weV9ub2RlIG5vZGUgdG9fdmlzaXQgPVxuICAgICAgICBpZiBpc19lbXB0eSBub2RlXG4gICAgICAgIHRoZW4gZW1wdHkgKCksIHRvX3Zpc2l0XG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIHdlIHVzZSB0aGUgc2FtZSBpZCwgYnV0IHRoYXQncyBvayBzaW5jZSBpZHMgc2hvdWxkIGJlIHVuaXF1ZSBwZXIgaGVhcCAqKVxuICAgICAgICAgIGxldCBuZXdfbm9kZSA9XG4gICAgICAgICAgICBhbGxvY2F0ZSAodmFsdWVfZXhuIG5vZGUgfnBvb2w6dCkgfnBvb2w6dCcgfmlkOihpZCBub2RlIH5wb29sOnQpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgdG9fdmlzaXQgPVxuICAgICAgICAgICAgKG5ld19ub2RlLCBgY2hpbGQsIGNoaWxkIG5vZGUgfnBvb2w6dClcbiAgICAgICAgICAgIDo6IChuZXdfbm9kZSwgYHNpYmxpbmcsIHNpYmxpbmcgbm9kZSB+cG9vbDp0KVxuICAgICAgICAgICAgOjogdG9fdmlzaXRcbiAgICAgICAgICBpblxuICAgICAgICAgIG5ld19ub2RlLCB0b192aXNpdClcbiAgICAgIGluXG4gICAgICBsZXQgcmVjIGxvb3AgdG9fdmlzaXQgPVxuICAgICAgICBtYXRjaCB0b192aXNpdCB3aXRoXG4gICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgfCAobm9kZV90b191cGRhdGUsIHNsb3QsIG5vZGVfdG9fY29weSkgOjogcmVzdCAtPlxuICAgICAgICAgIGxldCBuZXdfbm9kZSwgdG9fdmlzaXQgPSBjb3B5X25vZGUgbm9kZV90b19jb3B5IHJlc3QgaW5cbiAgICAgICAgICAobWF0Y2ggc2xvdCB3aXRoXG4gICAgICAgICAgIHwgYGNoaWxkIC0+IHNldF9jaGlsZCBub2RlX3RvX3VwZGF0ZSBuZXdfbm9kZSB+cG9vbDp0J1xuICAgICAgICAgICB8IGBzaWJsaW5nIC0+IHNldF9zaWJsaW5nIG5vZGVfdG9fdXBkYXRlIG5ld19ub2RlIH5wb29sOnQnKTtcbiAgICAgICAgICBpZiBub3QgKGlzX2VtcHR5IG5ld19ub2RlKSB0aGVuIHNldF9wcmV2IG5ld19ub2RlIG5vZGVfdG9fdXBkYXRlIH5wb29sOnQnO1xuICAgICAgICAgIGxvb3AgdG9fdmlzaXRcbiAgICAgIGluXG4gICAgICBsZXQgbmV3X3N0YXJ0LCB0b192aXNpdCA9IGNvcHlfbm9kZSBzdGFydCBbXSBpblxuICAgICAgbG9vcCB0b192aXNpdDtcbiAgICAgIG5ld19zdGFydCwgdCdcbiAgICA7O1xuICBlbmRcbmVuZFxuXG50eXBlICdhIHQgPVxuICB7ICgqIGNtcCBpcyBwbGFjZWQgZmlyc3QgdG8gc2hvcnQtY2lyY3VpdCBwb2x5bW9ycGhpYyBjb21wYXJlICopXG4gICAgY21wIDogJ2EgLT4gJ2EgLT4gaW50XG4gIDsgbXV0YWJsZSBwb29sIDogJ2EgTm9kZS5Qb29sLnRcbiAgOyAoKiBpbnZhcmlhbnQ6ICBbcm9vdF0gbmV2ZXIgaGFzIGEgc2libGluZyAqKVxuICAgIG11dGFibGUgcm9vdCA6ICdhIE5vZGUudFxuICA7IG11dGFibGUgbnVtX29mX2FsbG9jYXRlZF9ub2RlcyA6IGludFxuICB9XG5cbmxldCBpbnZhcmlhbnQgXyB0ID1cbiAgbGV0IHJlYyBsb29wIHRvX3Zpc2l0ID1cbiAgICBtYXRjaCB0b192aXNpdCB3aXRoXG4gICAgfCBbXSAtPiAoKVxuICAgIHwgKG5vZGUsIGV4cGVjdGVkX3ByZXYsIG1heWJlX3BhcmVudF92YWx1ZSkgOjogcmVzdCAtPlxuICAgICAgaWYgbm90IChOb2RlLmlzX2VtcHR5IG5vZGUpXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHRoaXNfdmFsdWUgPSBOb2RlLnZhbHVlX2V4biBub2RlIH5wb29sOnQucG9vbCBpblxuICAgICAgICBhc3NlcnQgKE5vZGUuZXF1YWwgKE5vZGUucHJldiBub2RlIH5wb29sOnQucG9vbCkgZXhwZWN0ZWRfcHJldik7XG4gICAgICAgIE9wdGlvbi5pdGVyIG1heWJlX3BhcmVudF92YWx1ZSB+ZjooZnVuIHBhcmVudF92YWx1ZSAtPlxuICAgICAgICAgIGFzc2VydCAodC5jbXAgcGFyZW50X3ZhbHVlIHRoaXNfdmFsdWUgPD0gMCkpO1xuICAgICAgICBsb29wXG4gICAgICAgICAgKChOb2RlLmNoaWxkIG5vZGUgfnBvb2w6dC5wb29sLCBub2RlLCBTb21lIHRoaXNfdmFsdWUpXG4gICAgICAgICAgIDo6IChOb2RlLnNpYmxpbmcgbm9kZSB+cG9vbDp0LnBvb2wsIG5vZGUsIG1heWJlX3BhcmVudF92YWx1ZSlcbiAgICAgICAgICAgOjogcmVzdCkpXG4gICAgICBlbHNlIGxvb3AgcmVzdFxuICBpblxuICBhc3NlcnQgKE5vZGUuaXNfZW1wdHkgdC5yb290IHx8IE5vZGUuaXNfZW1wdHkgKE5vZGUuc2libGluZyB0LnJvb3QgfnBvb2w6dC5wb29sKSk7XG4gIGxvb3AgWyB0LnJvb3QsIE5vZGUuZW1wdHkgKCksIE5vbmUgXVxuOztcblxubGV0IGNyZWF0ZSA/KG1pbl9zaXplID0gMSkgfmNtcCAoKSA9XG4gIHsgY21wXG4gIDsgcG9vbCA9IE5vZGUuUG9vbC5jcmVhdGUgfm1pbl9zaXplXG4gIDsgcm9vdCA9IE5vZGUuZW1wdHkgKClcbiAgOyBudW1fb2ZfYWxsb2NhdGVkX25vZGVzID0gMFxuICB9XG47O1xuXG5sZXQgY29weSB7IGNtcDsgcG9vbDsgcm9vdDsgbnVtX29mX2FsbG9jYXRlZF9ub2RlcyB9ID1cbiAgbGV0IHJvb3QsIHBvb2wgPSBOb2RlLlBvb2wuY29weSBwb29sIHJvb3QgaW5cbiAgeyBjbXA7IHBvb2w7IHJvb3Q7IG51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgfVxuOztcblxubGV0IGFsbG9jYXRlIHQgdiA9XG4gIGlmIE5vZGUuUG9vbC5pc19mdWxsIHQucG9vbCB0aGVuIHQucG9vbCA8LSBOb2RlLlBvb2wuZ3JvdyB0LnBvb2w7XG4gIHQubnVtX29mX2FsbG9jYXRlZF9ub2RlcyA8LSB0Lm51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgKyAxO1xuICBOb2RlLmFsbG9jYXRlIHYgfnBvb2w6dC5wb29sIH5pZDooTm9kZS5JZC5vZl9pbnQgdC5udW1fb2ZfYWxsb2NhdGVkX25vZGVzKVxuOztcblxuKCogdHJhbnNsYXRpb246XG4gICB7W1xuICAgICBtYXRjaCByb290MSwgcm9vdDIgd2l0aFxuICAgICB8IE5vbmUsIGggfCBoLCBOb25lIC0+IGhcbiAgICAgfCBTb21lIChOb2RlICh2MSwgY2hpbGRyZW4xKSksIFNvbWUgKE5vZGUgKHYyLCBjaGlsZHJlbjIpKSAtPlxuICAgICAgIGlmIHYxIDwgdjJcbiAgICAgICB0aGVuIFNvbWUgKE5vZGUgKHYxLCByb290MiA6OiBjaGlsZHJlbjEpKVxuICAgICAgIGVsc2UgU29tZSAoTm9kZSAodjIsIHJvb3QxIDo6IGNoaWxkcmVuMikpXG4gICBdfVxuXG4gICBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbmVpdGhlciByb290IGhhcyBhIHByZXYgbm9kZSAodXN1YWxseSBiZWNhdXNlIHRoZSBpbnB1dHMgY29tZVxuICAgZnJvbSBbZGlzY29ubmVjdF8qXSBvciBhcmUgdGhlIHRvcCBvZiB0aGUgaGVhcCBvciBhcmUgdGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uKS4gKilcbmxldCBtZXJnZSB0IHJvb3QxIHJvb3QyID1cbiAgaWYgTm9kZS5pc19lbXB0eSByb290MVxuICB0aGVuIHJvb3QyXG4gIGVsc2UgaWYgTm9kZS5pc19lbXB0eSByb290MlxuICB0aGVuIHJvb3QxXG4gIGVsc2UgKFxuICAgIGxldCBhZGRfY2hpbGQgdCBub2RlIH5jaGlsZCA9XG4gICAgICBOb2RlLmFkZF9jaGlsZCBub2RlIH5wb29sOnQucG9vbCB+Y2hpbGQ7XG4gICAgICBub2RlXG4gICAgaW5cbiAgICBsZXQgdjEgPSBOb2RlLnZhbHVlX2V4biByb290MSB+cG9vbDp0LnBvb2wgaW5cbiAgICBsZXQgdjIgPSBOb2RlLnZhbHVlX2V4biByb290MiB+cG9vbDp0LnBvb2wgaW5cbiAgICBpZiB0LmNtcCB2MSB2MiA8IDBcbiAgICB0aGVuIGFkZF9jaGlsZCB0IHJvb3QxIH5jaGlsZDpyb290MlxuICAgIGVsc2UgYWRkX2NoaWxkIHQgcm9vdDIgfmNoaWxkOnJvb3QxKVxuOztcblxubGV0IHRvcF9leG4gdCA9XG4gIGlmIE5vZGUuaXNfZW1wdHkgdC5yb290XG4gIHRoZW4gZmFpbHdpdGggXCJIZWFwLnRvcF9leG4gY2FsbGVkIG9uIGFuIGVtcHR5IGhlYXBcIlxuICBlbHNlIE5vZGUudmFsdWVfZXhuIHQucm9vdCB+cG9vbDp0LnBvb2xcbjs7XG5cbmxldCB0b3AgdCA9IGlmIE5vZGUuaXNfZW1wdHkgdC5yb290IHRoZW4gTm9uZSBlbHNlIFNvbWUgKHRvcF9leG4gdClcblxubGV0IGFkZF9ub2RlIHQgdiA9XG4gIGxldCBub2RlID0gYWxsb2NhdGUgdCB2IGluXG4gIHQucm9vdCA8LSBtZXJnZSB0IHQucm9vdCBub2RlO1xuICBub2RlXG47O1xuXG5sZXQgYWRkIHQgdiA9IGlnbm9yZSAoYWRkX25vZGUgdCB2IDogXyBOb2RlLnQpXG5cbigqIFttZXJnZV9wYWlyc10gdGFrZXMgYSBsaXN0IG9mIGhlYXAgcm9vdHMgYW5kIG1lcmdlcyBjb25zZWN1dGl2ZSBwYWlycywgcmVkdWNpbmcgdGhlXG4gICBsaXN0IG9mIGxlbmd0aCBuIHRvIG4vMi4gIFRoZW4gaXQgbWVyZ2VzIHRoZSBtZXJnZWQgcGFpcnMgaW50byBhIHNpbmdsZSBoZWFwLiAgT25lXG4gICBpbnR1aXRpb24gaXMgdGhhdCB0aGlzIGlzIHNvbWV3aGF0IGxpa2UgYnVpbGRpbmcgYSBzaW5nbGUgbGV2ZWwgb2YgYSBiaW5hcnkgdHJlZS5cblxuICAgVGhlIG91dHB1dCBoZWFwIGRvZXMgbm90IGNvbnRhaW4gdGhlIHZhbHVlIHRoYXQgd2FzIGF0IHRoZSByb290IG9mIHRoZSBpbnB1dCBoZWFwLlxuXG4gICBXZSBicmVhayB0aGUgZnVuY3Rpb24gaW50byB0d28gcGFydHMuICBBIGZpcnN0IHN0YWdlIHRoYXQgaXMgd2lsbGluZyB0byB1c2UgbGltaXRlZFxuICAgc3RhY2sgaW5zdGVhZCBvZiBoZWFwIGFsbG9jYXRpb24gZm9yIGJvb2trZWVwaW5nLCBhbmQgYSBzZWNvbmQgc3RhZ2UgdGhhdCBzaGlmdHMgdG9cbiAgIHVzaW5nIGEgbGlzdCBhcyBhbiBhY2N1bXVsYXRvciBpZiB3ZSBnbyB0b28gZGVlcC5cblxuICAgVGhpcyBjYW4gYmUgbWFkZSB0YWlsIHJlY3Vyc2l2ZSBhbmQgbm9uLWFsbG9jYXRpbmcgYnkgc3RhcnRpbmcgd2l0aCBhbiBlbXB0eSBoZWFwIGFuZFxuICAgbWVyZ2luZyBtZXJnZWQgcGFpcnMgaW50byBpdC4gVW5mb3J0dW5hdGVseSB0aGlzIFwibGVmdCBmb2xkXCIgdmVyc2lvbiBpcyBub3Qgd2hhdCBpc1xuICAgZGVzY3JpYmVkIGluIHRoZSBvcmlnaW5hbCBwYXBlciBieSBGcmVkbWFuIGV0IGFsLjsgdGhleSBzcGVjaWZpY2FsbHkgc2F5IHRoYXRcbiAgIGNoaWxkcmVuIHNob3VsZCBiZSBtZXJnZWQgdG9nZXRoZXIgZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gICBsaXN0LiAoW21lcmdlXSBpcyBub3QgYXNzb2NpYXRpdmUsIHNvIG9yZGVyIG1hdHRlcnMuKVxuKilcbigqIHRyYW5zbGF0aW9uOlxuICAge1tcbiAgICAgbGV0IHJlYyBsb29wIGFjYyA9IGZ1bmN0aW9uXG4gICAgICAgfCBbXSAtPiBhY2NcbiAgICAgICB8IFtoZWFkXSAtPiBoZWFkIDo6IGFjY1xuICAgICAgIHwgaGVhZCA6OiBuZXh0MSA6OiBuZXh0MiAtPiBsb29wIChtZXJnZSBoZWFkIG5leHQxIDo6IGFjYykgbmV4dDJcbiAgICAgaW5cbiAgICAgbWF0Y2ggbG9vcCBbXSBjaGlsZHJlbiB3aXRoXG4gICAgIHwgW10gLT4gTm9uZVxuICAgICB8IFtoXSAtPiBTb21lIGhcbiAgICAgfCB4IDo6IHhzIC0+IFNvbWUgKExpc3QuZm9sZCB4cyB+aW5pdDp4IH5mOm1lcmdlKVxuICAgXX1cbiopXG5sZXQgYWxsb2NhdGluZ19tZXJnZV9wYWlycyB0IGhlYWQgPVxuICBsZXQgcmVjIGxvb3AgYWNjIGhlYWQgPVxuICAgIGlmIE5vZGUuaXNfZW1wdHkgaGVhZFxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbmV4dDEgPSBOb2RlLmRpc2Nvbm5lY3Rfc2libGluZyBoZWFkIH5wb29sOnQucG9vbCBpblxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBuZXh0MVxuICAgICAgdGhlbiBoZWFkIDo6IGFjY1xuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBuZXh0MiA9IE5vZGUuZGlzY29ubmVjdF9zaWJsaW5nIG5leHQxIH5wb29sOnQucG9vbCBpblxuICAgICAgICBsb29wIChtZXJnZSB0IGhlYWQgbmV4dDEgOjogYWNjKSBuZXh0MikpXG4gIGluXG4gIG1hdGNoIGxvb3AgW10gaGVhZCB3aXRoXG4gIHwgW10gLT4gTm9kZS5lbXB0eSAoKVxuICB8IFsgaCBdIC0+IGhcbiAgfCB4IDo6IHhzIC0+IExpc3QuZm9sZCB4cyB+aW5pdDp4IH5mOihmdW4gYWNjIGhlYXAgLT4gbWVyZ2UgdCBhY2MgaGVhcClcbjs7XG5cbigqIHRyYW5zbGF0aW9uOlxuICAge1tcbiAgICAgbWF0Y2ggdC5yb290IHdpdGhcbiAgICAgfCBOb2RlIChfLCBjaGlsZHJlbikgLT5cbiAgICAgICBsZXQgcmVjIGxvb3AgZGVwdGggY2hpbGRyZW4gPVxuICAgICAgICAgaWYgZGVwdGggPj0gbWF4X3N0YWNrX2RlcHRoXG4gICAgICAgICB0aGVuIGFsbG9jYXRpbmdfbWVyZ2VfcGFpcnMgdCBjaGlsZGVuXG4gICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgIG1hdGNoIGNoaWxkcmVuIHdpdGhcbiAgICAgICAgICAgfCBbXSAtPiBOb25lXG4gICAgICAgICAgIHwgW2hlYWRdIC0+IFNvbWUgaGVhZFxuICAgICAgICAgICB8IGhlYWQgOjogbmV4dDEgOjogbmV4dDIgLT5cbiAgICAgICAgICAgICBtZXJnZSAobWVyZ2UgaGVhZCBuZXh0MSkgKGxvb3AgKGRlcHRoICsgMSkgbmV4dDIpXG4gICAgICAgICBlbmRcbiAgICAgICBpblxuICAgICAgIGxvb3AgMCBjaGlsZHJlblxuICAgXX1cbiopXG5sZXQgbWVyZ2VfcGFpcnMgPVxuICBsZXQgbWF4X3N0YWNrX2RlcHRoID0gMV8wMDAgaW5cbiAgbGV0IHJlYyBsb29wIHQgZGVwdGggaGVhZCA9XG4gICAgaWYgZGVwdGggPj0gbWF4X3N0YWNrX2RlcHRoXG4gICAgdGhlbiBhbGxvY2F0aW5nX21lcmdlX3BhaXJzIHQgaGVhZFxuICAgIGVsc2UgaWYgTm9kZS5pc19lbXB0eSBoZWFkXG4gICAgdGhlbiBoZWFkXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbmV4dDEgPSBOb2RlLmRpc2Nvbm5lY3Rfc2libGluZyBoZWFkIH5wb29sOnQucG9vbCBpblxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBuZXh0MVxuICAgICAgdGhlbiBoZWFkXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG5leHQyID0gTm9kZS5kaXNjb25uZWN0X3NpYmxpbmcgbmV4dDEgfnBvb2w6dC5wb29sIGluXG4gICAgICAgICgqIG1lcmdlIHRoZSBmaXJzdCB0d28gbm9kZXMgaW4gb3VyIGxpc3QsIGFuZCB0aGVuIG1lcmdlIHRoZSByZXN1bHQgd2l0aCB0aGVcbiAgICAgICAgICAgcmVzdWx0IG9mIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgbWVyZ2VfcGFpcnMgb24gdGhlIHRhaWwgKilcbiAgICAgICAgbWVyZ2UgdCAobWVyZ2UgdCBoZWFkIG5leHQxKSAobG9vcCB0IChkZXB0aCArIDEpIG5leHQyKSkpXG4gIGluXG4gIGZ1biB0IGhlYWQgLT4gbG9vcCB0IDAgaGVhZFxuOztcblxubGV0IHJlbW92ZV9ub25fZW1wdHkgdCBub2RlID1cbiAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgTm9kZS5kZXRhY2ggbm9kZSB+cG9vbDtcbiAgbGV0IG1lcmdlZF9jaGlsZHJlbiA9IG1lcmdlX3BhaXJzIHQgKE5vZGUuZGlzY29ubmVjdF9jaGlsZCBub2RlIH5wb29sKSBpblxuICBsZXQgbmV3X3Jvb3QgPVxuICAgIGlmIE5vZGUuZXF1YWwgdC5yb290IG5vZGUgdGhlbiBtZXJnZWRfY2hpbGRyZW4gZWxzZSBtZXJnZSB0IHQucm9vdCBtZXJnZWRfY2hpbGRyZW5cbiAgaW5cbiAgTm9kZS5mcmVlIG5vZGUgfnBvb2w7XG4gIHQucm9vdCA8LSBuZXdfcm9vdFxuOztcblxubGV0IHJlbW92ZV90b3AgdCA9IGlmIG5vdCAoTm9kZS5pc19lbXB0eSB0LnJvb3QpIHRoZW4gcmVtb3ZlX25vbl9lbXB0eSB0IHQucm9vdFxuXG4oKiBOb3RlIHRoYXQgdGhpcyBpcyB0YWlsLXJlY3Vyc2l2ZSBhbmQgdGhhdCBlYWNoIG5vZGUgaXMgdmlzaXRlZCBhdCBtb3N0IDMgdGltZXMgKG9uY2VcbiAgIGZvciBlYWNoIGJyYW5jaCBvZiB0aGUgXCJpZlwiKSwgc28gaXQgdGFrZXMgbGluZWFyIHRpbWUgYW5kIGNvbnN0YW50IHNwYWNlLiAqKVxubGV0IHJlYyByZW1vdmVfYWxsX25vZGVzX25vbl9lbXB0eSBub2RlIH5wb29sID1cbiAgbGV0IGNoaWxkID0gTm9kZS5jaGlsZCBub2RlIH5wb29sIGluXG4gIGxldCBzaWJsaW5nID0gTm9kZS5zaWJsaW5nIG5vZGUgfnBvb2wgaW5cbiAgaWYgbm90IChOb2RlLmlzX2VtcHR5IGNoaWxkKVxuICB0aGVuIHJlbW92ZV9hbGxfbm9kZXNfbm9uX2VtcHR5IGNoaWxkIH5wb29sXG4gIGVsc2UgaWYgbm90IChOb2RlLmlzX2VtcHR5IHNpYmxpbmcpXG4gIHRoZW4gcmVtb3ZlX2FsbF9ub2Rlc19ub25fZW1wdHkgc2libGluZyB+cG9vbFxuICBlbHNlIChcbiAgICBsZXQgcHJldiA9IE5vZGUucHJldiBub2RlIH5wb29sIGluXG4gICAgTm9kZS5kZXRhY2ggbm9kZSB+cG9vbDtcbiAgICBOb2RlLmZyZWUgbm9kZSB+cG9vbDtcbiAgICBpZiBub3QgKE5vZGUuaXNfZW1wdHkgcHJldikgdGhlbiByZW1vdmVfYWxsX25vZGVzX25vbl9lbXB0eSBwcmV2IH5wb29sKVxuOztcblxubGV0IGNsZWFyIHQgPVxuICBpZiBub3QgKE5vZGUuaXNfZW1wdHkgdC5yb290KVxuICB0aGVuIChcbiAgICByZW1vdmVfYWxsX25vZGVzX25vbl9lbXB0eSB0LnJvb3QgfnBvb2w6dC5wb29sO1xuICAgIHQucm9vdCA8LSBOb2RlLmVtcHR5ICgpKVxuOztcblxubGV0IHBvcF9leG4gdCA9XG4gIGxldCByID0gdG9wX2V4biB0IGluXG4gIHJlbW92ZV90b3AgdDtcbiAgclxuOztcblxubGV0IHBvcCB0ID0gaWYgTm9kZS5pc19lbXB0eSB0LnJvb3QgdGhlbiBOb25lIGVsc2UgU29tZSAocG9wX2V4biB0KVxuXG5sZXQgcG9wX2lmIHQgZiA9XG4gIG1hdGNoIHRvcCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHYgLT5cbiAgICBpZiBmIHZcbiAgICB0aGVuIChcbiAgICAgIHJlbW92ZV90b3AgdDtcbiAgICAgIFNvbWUgdilcbiAgICBlbHNlIE5vbmVcbjs7XG5cbmxldCBwb3Bfd2hpbGUgdCBmID1cbiAgbGV0IHJlYyBsb29wIHQgZiBhY2MgPVxuICAgIG1hdGNoIHBvcF9pZiB0IGYgd2l0aFxuICAgIHwgTm9uZSAtPiBMaXN0LnJldiBhY2NcbiAgICB8IFNvbWUgeCAtPiBsb29wIHQgZiAoeCA6OiBhY2MpXG4gIGluXG4gIGxvb3AgdCBmIFtdXG47O1xuXG4oKiBwYWlyaW5nIGhlYXBzIGFyZSBub3QgYmFsYW5jZWQgdHJlZXMsIGFuZCB0aGVyZWZvcmUgd2UgY2FuJ3QgcmVseSBvbiBhIGJhbGFuY2VcbiAgIHByb3BlcnR5IHRvIHN0b3Agb3Vyc2VsdmVzIGZyb20gb3ZlcmZsb3dpbmcgdGhlIHN0YWNrLiAqKVxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCBwb29sID0gdC5wb29sIGluXG4gIGxldCByZWMgbG9vcCBhY2MgdG9fdmlzaXQgPVxuICAgIG1hdGNoIHRvX3Zpc2l0IHdpdGhcbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgbm9kZSA6OiByZXN0IC0+XG4gICAgICBpZiBOb2RlLmlzX2VtcHR5IG5vZGVcbiAgICAgIHRoZW4gbG9vcCBhY2MgcmVzdFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCB0b192aXNpdCA9IE5vZGUuc2libGluZyB+cG9vbCBub2RlIDo6IE5vZGUuY2hpbGQgfnBvb2wgbm9kZSA6OiByZXN0IGluXG4gICAgICAgIGxvb3AgKGYgYWNjIChOb2RlLnZhbHVlX2V4biB+cG9vbCBub2RlKSkgdG9fdmlzaXQpXG4gIGluXG4gIGxvb3AgaW5pdCBbIHQucm9vdCBdIFtAbm9udGFpbF1cbjs7XG5cbigqIGFsbW9zdCBpZGVudGljYWwgdG8gZm9sZCwgY29waWVkIGZvciBzcGVlZCBwdXJwb3NlcyAqKVxubGV0IGl0ZXIgdCB+ZiA9XG4gIGxldCBwb29sID0gdC5wb29sIGluXG4gIGxldCByZWMgbG9vcCB0b192aXNpdCA9XG4gICAgbWF0Y2ggdG9fdmlzaXQgd2l0aFxuICAgIHwgW10gLT4gKClcbiAgICB8IG5vZGUgOjogcmVzdCAtPlxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBub2RlXG4gICAgICB0aGVuIGxvb3AgcmVzdFxuICAgICAgZWxzZSAoXG4gICAgICAgIGYgKE5vZGUudmFsdWVfZXhuIH5wb29sIG5vZGUpO1xuICAgICAgICBsZXQgdG9fdmlzaXQgPSBOb2RlLnNpYmxpbmcgfnBvb2wgbm9kZSA6OiBOb2RlLmNoaWxkIH5wb29sIG5vZGUgOjogcmVzdCBpblxuICAgICAgICBsb29wIHRvX3Zpc2l0KVxuICBpblxuICBsb29wIFsgdC5yb290IF0gW0Bub250YWlsXVxuOztcblxubGV0IGxlbmd0aCB0ID0gTm9kZS5Qb29sLmxlbmd0aCB0LnBvb2xcblxubW9kdWxlIEMgPSBDb250YWluZXIuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGZvbGQgPSBmb2xkXG4gIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuZW5kKVxuXG5sZXQgaXNfZW1wdHkgdCA9IE5vZGUuaXNfZW1wdHkgdC5yb290XG5sZXQgbWVtID0gQy5tZW1cbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZvcl9hbGwgPSBDLmZvcl9hbGxcbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBzdW0gPSBDLnN1bVxubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCB0b19saXN0ID0gQy50b19saXN0XG5sZXQgdG9fYXJyYXkgPSBDLnRvX2FycmF5XG5sZXQgbWluX2VsdCA9IEMubWluX2VsdFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5cbmxldCBvZl9hcnJheSBhcnIgfmNtcCA9XG4gIGxldCB0ID0gY3JlYXRlIH5taW5fc2l6ZTooQXJyYXkubGVuZ3RoIGFycikgfmNtcCAoKSBpblxuICBBcnJheS5pdGVyIGFyciB+ZjooZnVuIHYgLT4gYWRkIHQgdik7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0IGwgfmNtcCA9IG9mX2FycmF5IChBcnJheS5vZl9saXN0IGwpIH5jbXBcbmxldCBzZXhwX29mX3QgZiB0ID0gQXJyYXkuc2V4cF9vZl90IGYgKHRvX2FycmF5IHQgfD4gQXJyYXkuc29ydGVkX2NvcHkgfmNvbXBhcmU6dC5jbXApXG5cbm1vZHVsZSBFbHQgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9XG4gICAgeyBtdXRhYmxlIG5vZGUgOiAnYSBOb2RlLnRcbiAgICA7IG5vZGVfaWQgOiBOb2RlLklkLnRcbiAgICA7IGhlYXAgOiAnYSB0XG4gICAgfVxuXG4gICgqIElmIGlkcyBhcmUgZGlmZmVyZW50LCBpdCBtZWFucyB0aGF0IHRoZSBub2RlIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBieSBzb21lXG4gICAgIG90aGVyIG1lYW5zIChhbmQgcG9zc2libHkgcmV1c2VkKS4gKilcbiAgbGV0IGlzX25vZGVfdmFsaWQgdCA9IE5vZGUuSWQuZXF1YWwgKE5vZGUuaWQgfnBvb2w6dC5oZWFwLnBvb2wgdC5ub2RlKSB0Lm5vZGVfaWRcblxuICBsZXQgdmFsdWUgdCA9XG4gICAgaWYgaXNfbm9kZV92YWxpZCB0IHRoZW4gU29tZSAoTm9kZS52YWx1ZV9leG4gdC5ub2RlIH5wb29sOnQuaGVhcC5wb29sKSBlbHNlIE5vbmVcbiAgOztcblxuICBsZXQgdmFsdWVfZXhuIHQgPVxuICAgIGlmIGlzX25vZGVfdmFsaWQgdFxuICAgIHRoZW4gTm9kZS52YWx1ZV9leG4gdC5ub2RlIH5wb29sOnQuaGVhcC5wb29sXG4gICAgZWxzZSBmYWlsd2l0aCBcIkhlYXAudmFsdWVfZXhuOiBub2RlIHdhcyByZW1vdmVkIGZyb20gdGhlIGhlYXBcIlxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBbJXNleHAgKHZhbHVlIHQgOiBhIG9wdGlvbildXG5lbmRcblxubGV0IHJlbW92ZSB0ICh0b2tlbiA6IF8gRWx0LnQpID1cbiAgaWYgbm90IChwaHlzX2VxdWFsIHQgdG9rZW4uaGVhcClcbiAgdGhlbiBmYWlsd2l0aCBcImNhbm5vdCByZW1vdmUgZnJvbSBhIGRpZmZlcmVudCBoZWFwXCJcbiAgZWxzZSBpZiBub3QgKE5vZGUuaXNfZW1wdHkgdG9rZW4ubm9kZSlcbiAgdGhlbiAoXG4gICAgaWYgRWx0LmlzX25vZGVfdmFsaWQgdG9rZW4gdGhlbiByZW1vdmVfbm9uX2VtcHR5IHQgdG9rZW4ubm9kZTtcbiAgICB0b2tlbi5ub2RlIDwtIE5vZGUuZW1wdHkgKCkpXG47O1xuXG5sZXQgYWRkX3JlbW92YWJsZSB0IHYgPVxuICBsZXQgbm9kZSA9IGFkZF9ub2RlIHQgdiBpblxuICB7IEVsdC5ub2RlOyBoZWFwID0gdDsgbm9kZV9pZCA9IE5vZGUuaWQgfnBvb2w6dC5wb29sIG5vZGUgfVxuOztcblxubGV0IHVwZGF0ZSB0IHRva2VuIHYgPVxuICByZW1vdmUgdCB0b2tlbjtcbiAgYWRkX3JlbW92YWJsZSB0IHZcbjs7XG5cbmxldCBmaW5kX2VsdCA9XG4gIGxldCByZWMgbG9vcCB0IGYgbm9kZXMgPVxuICAgIG1hdGNoIG5vZGVzIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IG5vZGUgOjogcmVzdCAtPlxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBub2RlXG4gICAgICB0aGVuIGxvb3AgdCBmIHJlc3RcbiAgICAgIGVsc2UgaWYgZiAoTm9kZS52YWx1ZV9leG4gbm9kZSB+cG9vbDp0LnBvb2wpXG4gICAgICB0aGVuIFNvbWUgeyBFbHQubm9kZTsgaGVhcCA9IHQ7IG5vZGVfaWQgPSBOb2RlLmlkIH5wb29sOnQucG9vbCBub2RlIH1cbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCB0IGYgKE5vZGUuc2libGluZyBub2RlIH5wb29sOnQucG9vbCA6OiBOb2RlLmNoaWxkIG5vZGUgfnBvb2w6dC5wb29sIDo6IHJlc3QpXG4gIGluXG4gIGZ1biB0IH5mIC0+IGxvb3AgdCBmIFsgdC5yb290IF1cbjs7XG5cbm1vZHVsZSBVbnNhZmUgPSBzdHJ1Y3RcbiAgbW9kdWxlIEVsdCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgaGVhcCA9ICdhIHRcbiAgICB0eXBlICdhIHQgPSAnYSBOb2RlLnRcblxuICAgIGxldCB2YWx1ZSB0IGhlYXAgPSBOb2RlLnZhbHVlX2V4biB+cG9vbDpoZWFwLnBvb2wgdFxuICBlbmRcblxuICBsZXQgYWRkX3JlbW92YWJsZSA9IGFkZF9ub2RlXG4gIGxldCByZW1vdmUgPSByZW1vdmVfbm9uX2VtcHR5XG5cbiAgbGV0IHVwZGF0ZSB0IGVsdCB2ID1cbiAgICByZW1vdmUgdCBlbHQ7XG4gICAgYWRkX3JlbW92YWJsZSB0IHZcbiAgOztcbmVuZFxuIl19
