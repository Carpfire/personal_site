// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Dream__cipher
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dream_cipher = [0];
   runtime.caml_register_global(0, Dream_cipher, "Dream__cipher");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream__cipher__Random
//# unitInfo: Requires: CamlinternalLazy, Mirage_crypto_rng, Stdlib, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Mirage_crypto_rng = global_data.Mirage_crypto_rng,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    initialized = [0, 0],
    cst_Entropy_is_not_initialized = "Entropy is not initialized.";
   function initialized$0(param){
    var match = initialized[1];
    if(! match) return caml_call1(Stdlib[2], cst_Entropy_is_not_initialized);
    var v = match[1], _a_ = runtime.caml_obj_tag(v);
    if(250 === _a_) return v[1];
    if(246 !== _a_ && 244 !== _a_) return v;
    return caml_call1(CamlinternalLazy[2], v);
   }
   function initialize(f){
    initialized[1] = [0, caml_call1(Stdlib_Lazy[6], f)];
    return 0;
   }
   function random_buffer(n){
    initialized$0(0);
    return caml_call2(Mirage_crypto_rng[11], 0, n);
   }
   function random(n){return random_buffer(n);}
   var
    Dream_cipher_Random =
      [0, initialized, initialized$0, initialize, random_buffer, random];
   runtime.caml_register_global
    (5, Dream_cipher_Random, "Dream__cipher__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream__cipher__Cipher
//# unitInfo: Requires: CamlinternalLazy, Digestif, Dream__cipher__Random, Dream_pure__Message, Mirage_crypto, Stdlib, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\0",
    Dream_pure_Message = global_data.Dream_pure__Message,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_List = global_data.Stdlib__List,
    Dream_cipher_Random = global_data.Dream__cipher__Random,
    Stdlib_String = global_data.Stdlib__String,
    Mirage_crypto = global_data.Mirage_crypto,
    Stdlib = global_data.Stdlib,
    Digestif = global_data.Digestif,
    name =
      caml_call2
       (Stdlib[28],
        "AEAD_AES_256_GCM, ",
        "mirage-crypto, key: SHA-256, nonce: 96 bits mirage-crypto-rng"),
    cst_redacted = "[redacted]",
    _c_ = [0, "dream.secret"],
    prefix = 0;
   function derive_key(secret){
    var
     _k_ = caml_call3(Digestif[4][12], 0, 0, secret),
     _l_ = caml_call1(Digestif[4][39], _k_);
    return caml_call1(Mirage_crypto[4][4][2], _l_);
   }
   function encrypt_with_nonce(secret, nonce, plaintext, associated_data){
    var
     key = derive_key(secret),
     ciphertext =
       caml_call4
        (Mirage_crypto[4][4][3], key, nonce, associated_data, plaintext),
     _j_ = caml_call2(Stdlib[28], nonce, ciphertext);
    return caml_call2(Stdlib[28], cst, _j_);
   }
   function encrypt(associated_data, secret, plaintext){
    return encrypt_with_nonce
            (secret,
             caml_call1(Dream_cipher_Random[4], 12),
             plaintext,
             associated_data);
   }
   function test_encrypt(associated_data, secret, nonce, plaintext){
    return encrypt_with_nonce(secret, nonce, plaintext, associated_data);
   }
   function decrypt(associated_data, secret, ciphertext){
    var key = derive_key(secret);
    if(14 > caml_ml_string_length(ciphertext)) return 0;
    if(runtime.caml_string_get(ciphertext, 0) !== 0) return 0;
    var
     _h_ =
       caml_call3
        (Stdlib_String[16],
         ciphertext,
         13,
         caml_ml_string_length(ciphertext) - 13 | 0),
     _i_ = caml_call3(Stdlib_String[16], ciphertext, 1, 12),
     plaintext =
       caml_call4(Mirage_crypto[4][4][4], key, _i_, associated_data, _h_);
    return plaintext;
   }
   var
    AEAD_AES_256_GCM =
      [0,
       prefix,
       name,
       derive_key,
       encrypt_with_nonce,
       encrypt,
       test_encrypt,
       decrypt],
    _a_ = 0,
    _b_ = [0, function(secrets){return cst_redacted;}],
    secrets_field = caml_call3(Dream_pure_Message[39], _c_, _b_, _a_);
   function set_secret(opt, secret){
    if(opt) var sth = opt[1], old_secrets = sth; else var old_secrets = 0;
    var value = [0, secret, old_secrets];
    return function(next_handler, request){
     caml_call3(Dream_pure_Message[41], request, secrets_field, value);
     return caml_call1(next_handler, request);};
   }
   var
    fallback_secrets =
      [246,
       function(param){return [0, caml_call1(Dream_cipher_Random[5], 32), 0];}];
   function encryption_secret(request){
    var match = caml_call2(Dream_pure_Message[40], request, secrets_field);
    if(match){
     var secrets = match[1];
     return caml_call1(Stdlib_List[6], secrets);
    }
    var _f_ = caml_obj_tag(fallback_secrets);
    a:
    if(250 === _f_)
     var _g_ = fallback_secrets[1];
    else{
     if(246 !== _f_ && 244 !== _f_){var _g_ = fallback_secrets; break a;}
     var _g_ = caml_call1(CamlinternalLazy[2], fallback_secrets);
    }
    return caml_call1(Stdlib_List[6], _g_);
   }
   function decryption_secrets(request){
    var match = caml_call2(Dream_pure_Message[40], request, secrets_field);
    if(match){var secrets = match[1]; return secrets;}
    var _e_ = caml_obj_tag(fallback_secrets);
    if(250 === _e_) return fallback_secrets[1];
    if(246 !== _e_ && 244 !== _e_) return fallback_secrets;
    return caml_call1(CamlinternalLazy[2], fallback_secrets);
   }
   function encrypt$0(associated_data, request, plaintext){
    var secret = encryption_secret(request);
    return caml_call3(AEAD_AES_256_GCM[5], associated_data, secret, plaintext);
   }
   function decrypt$0(associated_data$0, request, ciphertext){
    var
     secrets$1 = decryption_secrets(request),
     associated_data = associated_data$0,
     secrets = secrets$1,
     _d_ = AEAD_AES_256_GCM[7];
    for(;;){
     if(! secrets) return 0;
     var
      secrets$0 = secrets[2],
      secret = secrets[1],
      plaintext = caml_call3(_d_, associated_data, secret, ciphertext);
     if(plaintext) return plaintext;
     var associated_data = 0, secrets = secrets$0;
    }
   }
   var
    Dream_cipher_Cipher =
      [0,
       AEAD_AES_256_GCM,
       secrets_field,
       set_secret,
       fallback_secrets,
       encryption_secret,
       decryption_secrets,
       encrypt$0,
       decrypt$0];
   runtime.caml_register_global
    (13, Dream_cipher_Cipher, "Dream__cipher__Cipher");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJkcmVhbV9fY2lwaGVyLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJpbml0aWFsaXplZCIsImluaXRpYWxpemVkJDAiLCJ2IiwiaW5pdGlhbGl6ZSIsImYiLCJyYW5kb21fYnVmZmVyIiwibiIsInJhbmRvbSIsIm5hbWUiLCJwcmVmaXgiLCJkZXJpdmVfa2V5Iiwic2VjcmV0IiwiZW5jcnlwdF93aXRoX25vbmNlIiwibm9uY2UiLCJwbGFpbnRleHQiLCJhc3NvY2lhdGVkX2RhdGEiLCJrZXkiLCJjaXBoZXJ0ZXh0IiwiZW5jcnlwdCIsInRlc3RfZW5jcnlwdCIsImRlY3J5cHQiLCJzZWNyZXRzIiwic2VjcmV0c19maWVsZCIsInNldF9zZWNyZXQiLCJvcHQiLCJzdGgiLCJvbGRfc2VjcmV0cyIsInZhbHVlIiwibmV4dF9oYW5kbGVyIiwicmVxdWVzdCIsImZhbGxiYWNrX3NlY3JldHMiLCJlbmNyeXB0aW9uX3NlY3JldCIsImRlY3J5cHRpb25fc2VjcmV0cyIsImVuY3J5cHQkMCIsImRlY3J5cHQkMCIsImFzc29jaWF0ZWRfZGF0YSQwIiwic2VjcmV0cyQxIiwic2VjcmV0cyQwIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0vY2lwaGVyL3JhbmRvbS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtL2NpcGhlci9jaXBoZXIubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0dBVTRDOzs7Ozs7SUFBeENBOztZQUVBQztJQUNGLFlBSEVEO2dCQUlRLE9BQUE7UUFDSEUseUNBQUFBOzJCQUFBQTttQ0FBSyxPQUFMQTtJQUFLLE9BQUEsZ0NBQUxBO0dBQWlCO1lBRXRCQyxXQUFXQztJQVBYSixxQkFPb0MsMkJBQXpCSTs7R0FBMEM7WUFFckRDLGNBQWNDO0lBUGRMO0lBUUYsT0FBQSxxQ0FEZ0JLO0dBRVk7WUFFMUJDLE9BQU9ELEdBQ1QsT0FMRUQsY0FJT0MsR0FDTTs7O1VBZGJOLGFBRUFDLGVBS0FFLFlBRUFFLGVBSUFFOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHQzRDQTs7Ozs7Ozs7Ozs7SUFERUM7TUFDRjs7Ozs7O0lBSkVDO1lBT0FDLFdBQVdDO0lBQ2I7S0FBQSxNQUFBLGtDQURhQTtLQUNiLE1BQUE7SUFBQSxPQUFBO0dBR2tDO1lBR2hDQyxtQkFBbUJELFFBQU9FLE9BQU1DLFdBQVVDO0lBQzVDO0tBQUlDLE1BUkZOLFdBT21CQztLQUdqQk07T0FDRjtpQ0FIRUQsS0FEd0JILE9BQWdCRSxpQkFBVkQ7S0FNekIsTUFBQSx1QkFObUJELE9BR3hCSTtJQUdLLE9BQUE7R0FBa0I7WUFFekJDLFFBQVNILGlCQUFpQkosUUFBT0c7SUFDbkMsT0FURUY7YUFRMEJEO2FBRW5CO2FBRjBCRzthQUF4QkM7R0FFaUQ7WUFFMURJLGFBQWNKLGlCQUFpQkosUUFBUUUsT0FBTUM7SUFDL0MsT0FiRUYsbUJBWStCRCxRQUFRRSxPQUFNQyxXQUEvQkM7R0FFd0I7WUFFdENLLFFBQVNMLGlCQUFpQkosUUFBT007SUFDekIsSUFBTkQsTUF4QkZOLFdBdUIwQkM7WUFFNUIsc0JBRm1DTSxhQUdqQztPQUVHLHdCQUw4QkEsc0JBTS9CO0lBUUk7S0FBQTtPQUFBOztTQWQyQkE7OytCQUFBQTtLQVlwQixNQUFBLDhCQVpvQkE7S0FTM0JIO09BQ0YsbUNBVEZFLFVBRE9EO0lBZ0JQLE9BUElEO0dBT0s7R0EzRGpCO0lBQUE7O09BYU1MO09BR0FEO09BSUFFO09BT0FFO09BUUFNO09BSUFDO09BSUFDOztJQXNCVSxtQkFBS0MsU0FBWSxvQkFBWTtJQUh6Q0MsZ0JBQ0Y7WUFTRUMsV0FBYUMsS0FBa0JiO0lBQ2pDLEdBRGVhLFNBQWNDLE1BQWRELFFBQUFFLGNBQWNELGNBQWRDO0lBQ0gsSUFBUkMsWUFENkJoQixRQUFsQmU7SUFFZixnQkFBSUUsY0FBYUM7S0FDZixtQ0FEZUEsU0FaZlAsZUFXRUs7S0FFRixPQUFBLFdBREVDLGNBQWFDLFNBRUs7R0FBQTtHQUdqQjtJQURIQzs7dUJBQ0csV0FBQztZQUVKQyxrQkFBa0JGO0lBQ2QsWUFBQSxtQ0FEY0EsU0FuQmxCUDs7U0FxQktEO0tBQVcsT0FBQSwyQkFBWEE7OzJCQUxMUzs7O2VBQUFBOzs4Q0FBQUE7K0NBQUFBOztJQU1nQixPQUFBO0dBQTZCO1lBRTdDRSxtQkFBbUJIO0lBQ2YsWUFBQSxtQ0FEZUEsU0F4Qm5CUDtrQkEwQktELG9CQUFXLE9BQVhBOzJCQVZMUzsyQkFBQUE7MENBQUFBOzJDQUFBQTtHQVdtQztZQUVuQ0csVUFBU2xCLGlCQUFnQmMsU0FBUWY7SUFJakMsSUEvR2tESCxTQWlHbERvQixrQkFVeUJGO0lBMUczQixPQUFBLGdDQTBHV2QsaUJBM0d5Q0osUUEyR2pCRztHQUt4QjtZQUVUb0IsVUFBU0MsbUJBQWdCTixTQUFRWjtJQUNuQztLQS9Hd0RtQixZQWtHdERKLG1CQVl5Qkg7S0E5R2FkLGtCQThHN0JvQjtLQTlHNkNkLFVBQUFlOzs7S0FFeEQsS0FGd0RmLFNBR2hEO0tBRUE7TUFMZ0RnQixZQUFBaEI7TUFJdERWLFNBSnNEVTtNQU1wRFAsWUFESSxnQkFMZ0NDLGlCQUl0Q0osUUEwR2lDTTtRQXhHL0JILFdBQXVCLE9BQXZCQTtTQU5vQ0MscUJBQWdCTSxVQUFBZ0I7O0dBbUg1Qzs7Ozs7T0F6Q1ZmO09BVUFDO09BTUFPO09BR0FDO09BS0FDO09BS0FDO09BT0FDOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBEcmVhbSwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZFxuICAgZm9yIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9hYW50cm9uL2RyZWFtLlxuXG4gICBDb3B5cmlnaHQgMjAyMSBBbnRvbiBCYWNoaW4gKilcblxuXG5cbigqIFRPRE8gTEFURVIgSXMgdGhlcmUgc29tZXRoaW5nIHdpdGggbGlnaHRlciBkZXBlbmRlbmNpZXM/IEFsdGhvdWdoIHBlcmhhcHNcbiAgIHRoZXNlIGFyZSBub3Qgc28gYmFkLi4uICopXG5cbmxldCBfaW5pdGlhbGl6ZWQgOiB1bml0IGxhenlfdCBvcHRpb24gcmVmID0gcmVmIE5vbmVcblxubGV0IGluaXRpYWxpemVkICgpID1cbiAgbWF0Y2ggIV9pbml0aWFsaXplZCB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIkVudHJvcHkgaXMgbm90IGluaXRpYWxpemVkLlwiXG4gIHwgU29tZSB2IC0+IExhenkuZm9yY2UgdlxuXG5sZXQgaW5pdGlhbGl6ZSBmID0gX2luaXRpYWxpemVkIDo9IFNvbWUgKExhenkuZnJvbV9mdW4gZilcblxubGV0IHJhbmRvbV9idWZmZXIgbiA9XG4gIGluaXRpYWxpemVkICgpIDtcbiAgTWlyYWdlX2NyeXB0b19ybmcuZ2VuZXJhdGUgblxuXG5sZXQgcmFuZG9tIG4gPVxuICByYW5kb21fYnVmZmVyIG5cbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIERyZWFtLCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kXG4gICBmb3IgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL2FhbnRyb24vZHJlYW0uXG5cbiAgIENvcHlyaWdodCAyMDIxIEFudG9uIEJhY2hpbiAqKVxuXG5cblxuKCogVE9ETyBSZXZpZXcgYWxsIHwgZXhjZXB0aW9uIGNhc2VzIGluIGFsbCBjb2RlIGFuZCBhdm9pZCB0aGVtIGFzIG11Y2ggc2FcbiAgIHBvc3NpYmxlLiAqKVxuKCogVE9ETyBTdXBwb3J0IG1peHR1cmUgb2YgZW5jcnlwdGlvbiBhbmQgc2lnbmluZy4gKilcbigqIFRPRE8gTEFURVIgU3dpdGNoIHRvIEFFQURfQUVTXzI1Nl9HQ01fU0lWLiBTZWVcbiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9taXJhZ2UvbWlyYWdlLWNyeXB0by9pc3N1ZXMvMTExLiAqKVxuXG5cblxubW9kdWxlIE1lc3NhZ2UgPSBEcmVhbV9wdXJlLk1lc3NhZ2VcblxuXG5cbm1vZHVsZSB0eXBlIENpcGhlciA9XG5zaWdcbiAgdmFsIHByZWZpeCA6IGNoYXJcbiAgdmFsIG5hbWUgOiBzdHJpbmdcblxuICB2YWwgZW5jcnlwdCA6XG4gICAgP2Fzc29jaWF0ZWRfZGF0YTpzdHJpbmcgLT4gc2VjcmV0OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nXG5cbiAgdmFsIGRlY3J5cHQgOlxuICAgID9hc3NvY2lhdGVkX2RhdGE6c3RyaW5nIC0+IHNlY3JldDpzdHJpbmcgLT4gc3RyaW5nIC0+IHN0cmluZyBvcHRpb25cblxuICB2YWwgdGVzdF9lbmNyeXB0IDpcbiAgICA/YXNzb2NpYXRlZF9kYXRhOnN0cmluZyAtPiBzZWNyZXQ6c3RyaW5nIC0+IG5vbmNlOnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nXG5lbmRcblxubGV0IGVuY3J5cHQgKG1vZHVsZSBDaXBoZXIgOiBDaXBoZXIpID9hc3NvY2lhdGVkX2RhdGEgc2VjcmV0IHBsYWludGV4dCA9XG4gIENpcGhlci5lbmNyeXB0ID9hc3NvY2lhdGVkX2RhdGEgfnNlY3JldCBwbGFpbnRleHRcblxubGV0IHJlYyBkZWNyeXB0XG4gICAgKChtb2R1bGUgQ2lwaGVyIDogQ2lwaGVyKSBhcyBjaXBoZXIpID9hc3NvY2lhdGVkX2RhdGEgc2VjcmV0cyBjaXBoZXJ0ZXh0ID1cblxuICBtYXRjaCBzZWNyZXRzIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgc2VjcmV0OjpzZWNyZXRzIC0+XG4gICAgbWF0Y2ggQ2lwaGVyLmRlY3J5cHQgP2Fzc29jaWF0ZWRfZGF0YSB+c2VjcmV0IGNpcGhlcnRleHQgd2l0aFxuICAgIHwgU29tZSBfIGFzIHBsYWludGV4dCAtPiBwbGFpbnRleHRcbiAgICB8IE5vbmUgLT4gZGVjcnlwdCBjaXBoZXIgc2VjcmV0cyBjaXBoZXJ0ZXh0XG5cbigqIEtleSBpcyBnb29kIGZvciB+Mi41IHllYXJzIGlmIGV2ZXJ5IHJlcXVlc3QgZS5nLiBnZW5lcmF0ZXMgb25lIG5ldyBzaWduZWRcbiAgIGNvb2tpZSwgYW5kIHRoZSBpbnN0YWxsYXRpb24gaXMgZG9pbmcgMTAwMCByZXF1ZXN0cyBwZXIgc2Vjb25kLiAqKVxubW9kdWxlIEFFQURfQUVTXzI1Nl9HQ00gPVxuc3RydWN0XG4gICgqIEVuY2lwaGVyZWQgbWVzc2FnZXMgYXJlIHByZWZpeGVkIHdpdGggYSB2ZXJzaW9uLiBUaGVyZSBpcyBvbmx5IG9uZSByaWdodFxuICAgICBub3csIHZlcnNpb24gMCwgaW4gd2hpY2ggdGhlIHJlc3Qgb2YgdGhlIG1lc3NhZ2UgY29uc2lzdHMgb2Y6XG5cbiAgICAgLSBhIDk2LWJpdCBub25jZSwgYXMgcmVjb21tZW5kZWQgaW4gUkZDIDUxMTYuXG4gICAgIC0gY2lwaGVydGV4dCBnZW5lcmF0ZWQgYnkgQUVBRF9BRVNfMjU2X0dDTSAoUkZDIDUxMTYpLlxuXG4gICAgIFRoZSAyNTYtYml0IGtleSBpcyBcImRlcml2ZWRcIiBmcm9tIHRoZSBnaXZlbiBzZWNyZXQgYnkgaGFzaGluZyBpdCB3aXRoXG4gICAgIFNIQS0yNTYuXG5cbiAgICAgU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MTE2LiAqKVxuXG4gICgqIFRPRE8gTW92ZSB0aGlzIGNoZWNrIHRvIHRoZSBlbnZlbG9wZSBsb29wLiAqKVxuICBsZXQgcHJlZml4ID1cbiAgICAnXFx4MDAnXG5cbiAgbGV0IG5hbWUgPVxuICAgIFwiQUVBRF9BRVNfMjU2X0dDTSwgXCIgXlxuICAgIFwibWlyYWdlLWNyeXB0bywga2V5OiBTSEEtMjU2LCBub25jZTogOTYgYml0cyBtaXJhZ2UtY3J5cHRvLXJuZ1wiXG5cbiAgbGV0IGRlcml2ZV9rZXkgc2VjcmV0ID1cbiAgICBzZWNyZXRcbiAgICB8PiBEaWdlc3RpZi5TSEEyNTYuZGlnZXN0X3N0cmluZ1xuICAgIHw+IERpZ2VzdGlmLlNIQTI1Ni50b19yYXdfc3RyaW5nXG4gICAgfD4gTWlyYWdlX2NyeXB0by5BRVMuR0NNLm9mX3NlY3JldFxuXG4gICgqIFRPRE8gTWVtb2l6ZSBrZXlzIG9yIG90aGVyd2lzZSBhdm9pZCBrZXkgZGVyaXZhdGlvbiBvbiBldmVyeSBjYWxsLiAqKVxuICBsZXQgZW5jcnlwdF93aXRoX25vbmNlIHNlY3JldCBub25jZSBwbGFpbnRleHQgYXNzb2NpYXRlZF9kYXRhID1cbiAgICBsZXQga2V5ID0gZGVyaXZlX2tleSBzZWNyZXQgaW5cbiAgICBsZXQgYWRhdGEgPSBhc3NvY2lhdGVkX2RhdGEgaW5cbiAgICBsZXQgY2lwaGVydGV4dCA9XG4gICAgICBNaXJhZ2VfY3J5cHRvLkFFUy5HQ00uYXV0aGVudGljYXRlX2VuY3J5cHQgfmtleSB+bm9uY2UgP2FkYXRhIHBsYWludGV4dCBpblxuXG4gICAgXCJcXHgwMFwiIF4gbm9uY2UgXiBjaXBoZXJ0ZXh0XG5cbiAgbGV0IGVuY3J5cHQgP2Fzc29jaWF0ZWRfZGF0YSB+c2VjcmV0IHBsYWludGV4dCA9XG4gICAgZW5jcnlwdF93aXRoX25vbmNlXG4gICAgICBzZWNyZXQgKFJhbmRvbS5yYW5kb21fYnVmZmVyIDEyKSBwbGFpbnRleHQgYXNzb2NpYXRlZF9kYXRhXG5cbiAgbGV0IHRlc3RfZW5jcnlwdCA/YXNzb2NpYXRlZF9kYXRhIH5zZWNyZXQgfm5vbmNlIHBsYWludGV4dCA9XG4gICAgZW5jcnlwdF93aXRoX25vbmNlXG4gICAgICBzZWNyZXQgbm9uY2UgcGxhaW50ZXh0IGFzc29jaWF0ZWRfZGF0YVxuXG4gIGxldCBkZWNyeXB0ID9hc3NvY2lhdGVkX2RhdGEgfnNlY3JldCBjaXBoZXJ0ZXh0ID1cbiAgICBsZXQga2V5ID0gZGVyaXZlX2tleSBzZWNyZXQgaW5cbiAgICBpZiBTdHJpbmcubGVuZ3RoIGNpcGhlcnRleHQgPCAxNCB0aGVuXG4gICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgaWYgY2lwaGVydGV4dC5bMF0gIT0gcHJlZml4IHRoZW5cbiAgICAgICAgTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgYWRhdGEgPSBhc3NvY2lhdGVkX2RhdGEgaW5cbiAgICAgICAgbGV0IHBsYWludGV4dCA9XG4gICAgICAgICAgTWlyYWdlX2NyeXB0by5BRVMuR0NNLmF1dGhlbnRpY2F0ZV9kZWNyeXB0XG4gICAgICAgICAgICB+a2V5XG4gICAgICAgICAgICB+bm9uY2U6KFN0cmluZy5zdWIgY2lwaGVydGV4dCAxIDEyKVxuICAgICAgICAgICAgP2FkYXRhXG4gICAgICAgICAgICAoU3RyaW5nLnN1YiBjaXBoZXJ0ZXh0IDEzIChTdHJpbmcubGVuZ3RoIGNpcGhlcnRleHQgLSAxMykpXG4gICAgICAgIGluXG4gICAgICAgIHBsYWludGV4dFxuZW5kXG5cbmxldCBzZWNyZXRzX2ZpZWxkID1cbiAgTWVzc2FnZS5uZXdfZmllbGRcbiAgICB+bmFtZTpcImRyZWFtLnNlY3JldFwiXG4gICAgfnNob3dfdmFsdWU6KGZ1biBfc2VjcmV0cyAtPiBcIltyZWRhY3RlZF1cIilcbiAgICAoKVxuXG4oKiBUT0RPIEFkZCB3YXJuaW5ncyBhYm91dCBzZWNyZXQgbGVuZ3RoIGFuZCBzdWNoLiAqKVxuKCogVE9ETyBBbHNvIGFkZCB3YXJuaW5ncyBhYm91dCBpbXBsaWNpdCBzZWNyZXQgZ2VuZXJhdGlvbi4gSG93ZXZlciwgdGhlc2VcbiAgIHdhcm5pbmdzIG1pZ2h0IGJlIHByZXR0eSBzcGFtbXkuICopXG4oKiBUT0RPIFVwZGF0ZSBleGFtcGxlcyBhbmQgZG9jcy4gKilcbmxldCBzZXRfc2VjcmV0ID8ob2xkX3NlY3JldHMgPSBbXSkgc2VjcmV0ID1cbiAgbGV0IHZhbHVlID0gc2VjcmV0OjpvbGRfc2VjcmV0cyBpblxuICBmdW4gbmV4dF9oYW5kbGVyIHJlcXVlc3QgLT5cbiAgICBNZXNzYWdlLnNldF9maWVsZCByZXF1ZXN0IHNlY3JldHNfZmllbGQgdmFsdWU7XG4gICAgbmV4dF9oYW5kbGVyIHJlcXVlc3RcblxubGV0IGZhbGxiYWNrX3NlY3JldHMgPVxuICBsYXp5IFtSYW5kb20ucmFuZG9tIDMyXVxuXG5sZXQgZW5jcnlwdGlvbl9zZWNyZXQgcmVxdWVzdCA9XG4gIG1hdGNoIE1lc3NhZ2UuZmllbGQgcmVxdWVzdCBzZWNyZXRzX2ZpZWxkIHdpdGhcbiAgfCBTb21lIHNlY3JldHMgLT4gTGlzdC5oZCBzZWNyZXRzXG4gIHwgTm9uZSAtPiBMaXN0LmhkIChMYXp5LmZvcmNlIGZhbGxiYWNrX3NlY3JldHMpXG5cbmxldCBkZWNyeXB0aW9uX3NlY3JldHMgcmVxdWVzdCA9XG4gIG1hdGNoIE1lc3NhZ2UuZmllbGQgcmVxdWVzdCBzZWNyZXRzX2ZpZWxkIHdpdGhcbiAgfCBTb21lIHNlY3JldHMgLT4gc2VjcmV0c1xuICB8IE5vbmUgLT4gTGF6eS5mb3JjZSBmYWxsYmFja19zZWNyZXRzXG5cbmxldCBlbmNyeXB0ID9hc3NvY2lhdGVkX2RhdGEgcmVxdWVzdCBwbGFpbnRleHQgPVxuICBlbmNyeXB0XG4gICAgKG1vZHVsZSBBRUFEX0FFU18yNTZfR0NNKVxuICAgID9hc3NvY2lhdGVkX2RhdGFcbiAgICAoZW5jcnlwdGlvbl9zZWNyZXQgcmVxdWVzdClcbiAgICBwbGFpbnRleHRcblxubGV0IGRlY3J5cHQgP2Fzc29jaWF0ZWRfZGF0YSByZXF1ZXN0IGNpcGhlcnRleHQgPVxuICBkZWNyeXB0XG4gICAgKG1vZHVsZSBBRUFEX0FFU18yNTZfR0NNKVxuICAgID9hc3NvY2lhdGVkX2RhdGFcbiAgICAoZGVjcnlwdGlvbl9zZWNyZXRzIHJlcXVlc3QpXG4gICAgY2lwaGVydGV4dFxuIl19
