// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ssl
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Callback, Stdlib__Printexc, Stdlib__Printf, Stdlib__String, Unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst_Buffer_too_short$1 = "Buffer too short",
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$2,
    cst = cst$2,
    cst$0 = cst$2,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    Unix = global_data.Unix,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Callback = global_data.Stdlib__Callback,
    native_library_version = runtime.ocaml_ssl_get_version(0),
    cst_input_int_failed_to_read_4 = "input_int failed to read 4 bytes",
    cst_output_int_error_all_the_b =
      "output_int error: all the byte were not sent",
    cst_output_char_failed_to_writ = "output_char failed to write",
    cst_output_string_failed_to_wr = "output_string failed to write",
    cst_Ssl_read_into_big_array_st = "Ssl.read_into_big_array: start negative",
    cst_Ssl_read_into_big_array_le =
      "Ssl.read_into_big_array: length negative",
    cst_Buffer_too_short$0 = cst_Buffer_too_short$1,
    cst_Ssl_read_start_negative = "Ssl.read: start negative",
    cst_Ssl_read_length_negative = "Ssl.read: length negative",
    cst_Buffer_too_short = cst_Buffer_too_short$1,
    cst_Ssl_write_bigarray_start_n = "Ssl.write_bigarray: start negative",
    cst_Ssl_write_bigarray_length_ = "Ssl.write_bigarray: length negative",
    cst_Ssl_write_bigarray_Buffer_ = "Ssl.write_bigarray: Buffer too short",
    cst_Ssl_write_substring_start_ = "Ssl.write_substring: start negative",
    cst_Ssl_write_substring_length = "Ssl.write_substring: length negative",
    cst_Ssl_write_substring_Buffer = "Ssl.write_substring: Buffer too short",
    cst_Ssl_write_start_negative = "Ssl.write: start negative",
    cst_Ssl_write_length_negative = "Ssl.write: length negative",
    cst_Ssl_write_Buffer_too_short = "Ssl.write: Buffer too short",
    _c_ = [0, "SSL: Method error"],
    _d_ = [0, "SSL: Context error"],
    cst_SSL_Certificate_error = "SSL: Certificate error: ",
    _e_ = [0, "SSL: Cipher error"],
    _f_ = [0, "SSL: Diffie-Hellman error"],
    _g_ = [0, "SSL: EC curve error"],
    cst_SSL_Private_key_error = "SSL: Private key error: ",
    _h_ = [0, "SSL: Unmatching keys"],
    _i_ = [0, "SSL: Invalid socket"],
    _j_ = [0, "SSL: Handler error"],
    cst_SSL_connection_error = "SSL connection() error: ",
    cst_SSL_accept_error = "SSL accept() error: ",
    cst_SSL_read_error = "SSL read() error: ",
    cst_SSL_write_error = "SSL write() error: ",
    cst_SSL_verify_error = "SSL verify() error: ",
    _k_ =
      [0,
       [11, "SSL flush(", [9, 0, [11, ") error: ", 0]]],
       "SSL flush(%b) error: "],
    cst_lib_0 = "lib(0)",
    cst_reason_0 = "reason(0)",
    _a_ =
      [0,
       [11,
        "error:",
        [5,
         8,
         [0, 2, 2],
         0,
         [12,
          58,
          [5, 8, [0, 2, 6], 0, [12, 58, [2, 0, [11, "::", [2, 0, 0]]]]]]]],
       "error:%02lX:%06lX:%s::%s"],
    cst_Ssl_Method_error = "Ssl.Method_error",
    cst_Ssl_Context_error = "Ssl.Context_error",
    cst_Ssl_Certificate_error = "Ssl.Certificate_error",
    cst_Ssl_Cipher_error = "Ssl.Cipher_error",
    cst_Ssl_Diffie_hellman_error = "Ssl.Diffie_hellman_error",
    cst_Ssl_Ec_curve_error = "Ssl.Ec_curve_error",
    cst_Ssl_Private_key_error = "Ssl.Private_key_error",
    cst_Ssl_Unmatching_keys = "Ssl.Unmatching_keys",
    cst_Ssl_Invalid_socket = "Ssl.Invalid_socket",
    cst_Ssl_Handler_error = "Ssl.Handler_error",
    cst_Ssl_Connection_error = "Ssl.Connection_error",
    cst_Ssl_Accept_error = "Ssl.Accept_error",
    cst_Ssl_Read_error = "Ssl.Read_error",
    cst_Ssl_Write_error = "Ssl.Write_error",
    cst_Ssl_Verify_error = "Ssl.Verify_error",
    cst_Ssl_Flush_error = "Ssl.Flush_error",
    cst_ssl_exn_method_error = "ssl_exn_method_error",
    cst_ssl_exn_context_error = "ssl_exn_context_error",
    cst_ssl_exn_certificate_error = "ssl_exn_certificate_error",
    cst_ssl_exn_cipher_error = "ssl_exn_cipher_error",
    cst_ssl_exn_diffie_hellman_err = "ssl_exn_diffie_hellman_error",
    cst_ssl_exn_ec_curve_error = "ssl_exn_ec_curve_error",
    cst_ssl_exn_private_key_error = "ssl_exn_private_key_error",
    cst_ssl_exn_unmatching_keys = "ssl_exn_unmatching_keys",
    cst_ssl_exn_invalid_socket = "ssl_exn_invalid_socket",
    cst_ssl_exn_handler_error = "ssl_exn_handler_error",
    cst_ssl_exn_connection_error = "ssl_exn_connection_error",
    cst_ssl_exn_accept_error = "ssl_exn_accept_error",
    cst_ssl_exn_read_error = "ssl_exn_read_error",
    cst_ssl_exn_write_error = "ssl_exn_write_error",
    cst_ssl_exn_verify_error = "ssl_exn_verify_error",
    cst_ssl_exn_flush_error = "ssl_exn_flush_error";
   function get_error(param){return runtime.ocaml_ssl_error_struct(0);}
   function peek_error(param){return runtime.ocaml_ssl_error_struct(1);}
   function peek_last_error(param){return runtime.ocaml_ssl_error_struct(2);}
   function peek_last_error_string(param){
    var err = runtime.ocaml_ssl_error_struct(2), match = err[3];
    if(match)
     var lib = match[1], libstring = lib;
    else
     var libstring = cst_lib_0;
    var match$0 = err[4];
    if(match$0)
     var reason = match$0[1], reasonstring = reason;
    else
     var reasonstring = cst_reason_0;
    return caml_call5
            (Stdlib_Printf[4], _a_, err[1], err[2], libstring, reasonstring);
   }
   var
    Method_error = [248, cst_Ssl_Method_error, caml_fresh_oo_id(0)],
    Context_error = [248, cst_Ssl_Context_error, caml_fresh_oo_id(0)],
    Certificate_error = [248, cst_Ssl_Certificate_error, caml_fresh_oo_id(0)],
    Cipher_error = [248, cst_Ssl_Cipher_error, caml_fresh_oo_id(0)],
    Diffie_hellman_error =
      [248, cst_Ssl_Diffie_hellman_error, caml_fresh_oo_id(0)],
    Ec_curve_error = [248, cst_Ssl_Ec_curve_error, caml_fresh_oo_id(0)],
    Private_key_error = [248, cst_Ssl_Private_key_error, caml_fresh_oo_id(0)],
    Unmatching_keys = [248, cst_Ssl_Unmatching_keys, caml_fresh_oo_id(0)],
    Invalid_socket = [248, cst_Ssl_Invalid_socket, caml_fresh_oo_id(0)],
    Handler_error = [248, cst_Ssl_Handler_error, caml_fresh_oo_id(0)],
    Connection_error = [248, cst_Ssl_Connection_error, caml_fresh_oo_id(0)],
    Accept_error = [248, cst_Ssl_Accept_error, caml_fresh_oo_id(0)],
    Read_error = [248, cst_Ssl_Read_error, caml_fresh_oo_id(0)],
    Write_error = [248, cst_Ssl_Write_error, caml_fresh_oo_id(0)],
    Verify_error = [248, cst_Ssl_Verify_error, caml_fresh_oo_id(0)],
    Flush_error = [248, cst_Ssl_Flush_error, caml_fresh_oo_id(0)];
   function _b_(param){
    if(param === Method_error) return _c_;
    if(param === Context_error) return _d_;
    if(param[1] === Certificate_error){
     var s = param[2];
     return [0, caml_call2(Stdlib[28], cst_SSL_Certificate_error, s)];
    }
    if(param === Cipher_error) return _e_;
    if(param === Diffie_hellman_error) return _f_;
    if(param === Ec_curve_error) return _g_;
    if(param[1] === Private_key_error){
     var s$0 = param[2];
     return [0, caml_call2(Stdlib[28], cst_SSL_Private_key_error, s$0)];
    }
    if(param === Unmatching_keys) return _h_;
    if(param === Invalid_socket) return _i_;
    if(param === Handler_error) return _j_;
    if(param[1] === Connection_error){
     var _b$_ = peek_last_error_string(0);
     return [0, caml_call2(Stdlib[28], cst_SSL_connection_error, _b$_)];
    }
    if(param[1] === Accept_error){
     var _ca_ = peek_last_error_string(0);
     return [0, caml_call2(Stdlib[28], cst_SSL_accept_error, _ca_)];
    }
    if(param[1] === Read_error){
     var _cb_ = peek_last_error_string(0);
     return [0, caml_call2(Stdlib[28], cst_SSL_read_error, _cb_)];
    }
    if(param[1] === Write_error){
     var _cc_ = peek_last_error_string(0);
     return [0, caml_call2(Stdlib[28], cst_SSL_write_error, _cc_)];
    }
    if(param[1] === Verify_error){
     var _cd_ = peek_last_error_string(0);
     return [0, caml_call2(Stdlib[28], cst_SSL_verify_error, _cd_)];
    }
    if(param[1] !== Flush_error) return 0;
    var
     b = param[2],
     _ce_ = peek_last_error_string(0),
     _cf_ = caml_call2(Stdlib_Printf[4], _k_, b);
    return [0, caml_call2(Stdlib[28], _cf_, _ce_)];
   }
   caml_call1(Stdlib_Printexc[9], _b_);
   caml_call2(Stdlib_Callback[2], cst_ssl_exn_method_error, Method_error);
   caml_call2(Stdlib_Callback[2], cst_ssl_exn_context_error, Context_error);
   caml_call2
    (Stdlib_Callback[2],
     cst_ssl_exn_certificate_error,
     [0, Certificate_error, cst]);
   caml_call2(Stdlib_Callback[2], cst_ssl_exn_cipher_error, Cipher_error);
   caml_call2
    (Stdlib_Callback[2], cst_ssl_exn_diffie_hellman_err, Diffie_hellman_error);
   caml_call2(Stdlib_Callback[2], cst_ssl_exn_ec_curve_error, Ec_curve_error);
   caml_call2
    (Stdlib_Callback[2],
     cst_ssl_exn_private_key_error,
     [0, Private_key_error, cst$0]);
   caml_call2
    (Stdlib_Callback[2], cst_ssl_exn_unmatching_keys, Unmatching_keys);
   caml_call2(Stdlib_Callback[2], cst_ssl_exn_invalid_socket, Invalid_socket);
   caml_call2(Stdlib_Callback[2], cst_ssl_exn_handler_error, Handler_error);
   caml_call2
    (Stdlib_Callback[2],
     cst_ssl_exn_connection_error,
     [0, Connection_error, 0]);
   caml_call2
    (Stdlib_Callback[2], cst_ssl_exn_accept_error, [0, Accept_error, 0]);
   caml_call2(Stdlib_Callback[2], cst_ssl_exn_read_error, [0, Read_error, 0]);
   caml_call2
    (Stdlib_Callback[2], cst_ssl_exn_write_error, [0, Write_error, 0]);
   caml_call2
    (Stdlib_Callback[2], cst_ssl_exn_verify_error, [0, Verify_error, 31]);
   caml_call2
    (Stdlib_Callback[2], cst_ssl_exn_flush_error, [0, Flush_error, 1]);
   var thread_safe = [0, 0];
   function init(thread_safe$0, param){
    if(thread_safe$0)
     var b = thread_safe$0[1], thread_safe$1 = b;
    else
     var thread_safe$1 = thread_safe[1];
    return runtime.ocaml_ssl_init(thread_safe$1);
   }
   var
    client_verify_callback =
      runtime.ocaml_ssl_get_client_verify_callback_ptr(0);
   function connect(socket){
    var
     ret = runtime.ocaml_ssl_connect_blocking(socket),
     _b__ = 1 !== ret ? 1 : 0;
    if(! _b__) return _b__;
    var err = runtime.ocaml_ssl_get_error_code(socket, ret);
    throw caml_maybe_attach_backtrace([0, Connection_error, err], 1);
   }
   function accept(socket){
    var
     ret = runtime.ocaml_ssl_accept_blocking(socket),
     _b9_ = 1 !== ret ? 1 : 0;
    if(! _b9_) return _b9_;
    var err = runtime.ocaml_ssl_get_error_code(socket, ret);
    throw caml_maybe_attach_backtrace([0, Accept_error, err], 1);
   }
   function write(socket, buffer, start, length){
    if(start < 0) caml_call1(Stdlib[1], cst_Ssl_write_start_negative);
    if(length < 0) caml_call1(Stdlib[1], cst_Ssl_write_length_negative);
    if(caml_ml_bytes_length(buffer) < (start + length | 0))
     caml_call1(Stdlib[1], cst_Ssl_write_Buffer_too_short);
    var ret = runtime.ocaml_ssl_write_blocking(socket, buffer, start, length);
    if(ret > 0) return ret;
    var err = runtime.ocaml_ssl_get_error_code(socket, ret);
    throw caml_maybe_attach_backtrace([0, Write_error, err], 1);
   }
   function write_substring(socket, buffer, start, length){
    if(start < 0) caml_call1(Stdlib[1], cst_Ssl_write_substring_start_);
    if(length < 0) caml_call1(Stdlib[1], cst_Ssl_write_substring_length);
    if(caml_ml_string_length(buffer) < (start + length | 0))
     caml_call1(Stdlib[1], cst_Ssl_write_substring_Buffer);
    var ret = runtime.ocaml_ssl_write_blocking(socket, buffer, start, length);
    if(ret > 0) return ret;
    var err = runtime.ocaml_ssl_get_error_code(socket, ret);
    throw caml_maybe_attach_backtrace([0, Write_error, err], 1);
   }
   function write_bigarray(socket, buffer, start, length){
    if(start < 0) caml_call1(Stdlib[1], cst_Ssl_write_bigarray_start_n);
    if(length < 0) caml_call1(Stdlib[1], cst_Ssl_write_bigarray_length_);
    if(caml_ba_dim_1(buffer) < (start + length | 0))
     caml_call1(Stdlib[1], cst_Ssl_write_bigarray_Buffer_);
    var
     ret =
       runtime.ocaml_ssl_write_bigarray_blocking
        (socket, buffer, start, length);
    if(ret > 0) return ret;
    var err = runtime.ocaml_ssl_get_error_code(socket, ret);
    throw caml_maybe_attach_backtrace([0, Write_error, err], 1);
   }
   function read(socket, buffer, start, length){
    if(start < 0) caml_call1(Stdlib[1], cst_Ssl_read_start_negative);
    if(length < 0) caml_call1(Stdlib[1], cst_Ssl_read_length_negative);
    if(caml_ml_bytes_length(buffer) < (start + length | 0))
     caml_call1(Stdlib[1], cst_Buffer_too_short);
    var ret = runtime.ocaml_ssl_read_blocking(socket, buffer, start, length);
    if(ret > 0) return ret;
    var err = runtime.ocaml_ssl_get_error_code(socket, ret);
    throw caml_maybe_attach_backtrace([0, Read_error, err], 1);
   }
   function read_into_bigarray(socket, buffer, start, length){
    if(start < 0) caml_call1(Stdlib[1], cst_Ssl_read_into_big_array_st);
    if(length < 0) caml_call1(Stdlib[1], cst_Ssl_read_into_big_array_le);
    if(caml_ba_dim_1(buffer) < (start + length | 0))
     caml_call1(Stdlib[1], cst_Buffer_too_short$0);
    var
     ret =
       runtime.ocaml_ssl_read_into_bigarray_blocking
        (socket, buffer, start, length);
    if(ret > 0) return ret;
    var err = runtime.ocaml_ssl_get_error_code(socket, ret);
    throw caml_maybe_attach_backtrace([0, Read_error, err], 1);
   }
   function flush(socket){
    var
     ret = runtime.ocaml_ssl_flush_blocking(socket),
     _b8_ = 1 !== ret ? 1 : 0;
    if(_b8_)
     throw caml_maybe_attach_backtrace
            ([0, Flush_error, -2 === ret ? 1 : 0], 1);
    return _b8_;
   }
   function ssl_shutdown(socket){
    var ret = runtime.ocaml_ssl_shutdown_blocking(socket);
    if(ret >= 0) return 1 === ret ? 1 : 0;
    var err = runtime.ocaml_ssl_get_error_code(socket, ret);
    throw caml_maybe_attach_backtrace([0, Connection_error, err], 1);
   }
   function Make(Ssl_base){
    var
     connect = Ssl_base[1],
     accept = Ssl_base[2],
     ssl_shutdown = Ssl_base[3],
     flush = Ssl_base[4],
     read = Ssl_base[5],
     read_into_bigarray = Ssl_base[6],
     write = Ssl_base[7],
     write_substring = Ssl_base[8],
     write_bigarray = Ssl_base[9];
    function open_connection_with_context(context, sockaddr){
     var
      domain = caml_call1(Unix[134], sockaddr),
      sock = caml_call4(Unix[133], 0, domain, 0, 0);
     try{
      caml_call2(Unix[138], sock, sockaddr);
      var ssl = runtime.ocaml_ssl_embed_socket(sock, context);
      caml_call1(connect, ssl);
      return ssl;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      caml_call1(Unix[25], sock);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    }
    function open_connection(ssl_method, sockaddr){
     return open_connection_with_context
             (runtime.ocaml_ssl_create_context(ssl_method, 0), sockaddr);
    }
    function shutdown(sock){
     var
      _b6_ = 1 - caml_call1(ssl_shutdown, sock),
      _b7_ = _b6_ ? (caml_call1(ssl_shutdown, sock), 0) : _b6_;
     return _b7_;
    }
    function output_string(ssl, s){
     var len = caml_ml_string_length(s), to_write = [0, len], offset = [0, 0];
     for(;;){
      if(0 >= to_write[1]) return 0;
      var
       written = caml_call4(write_substring, ssl, s, offset[1], to_write[1]);
      if(written <= 0) caml_call1(Stdlib[2], cst_output_string_failed_to_wr);
      to_write[1] = to_write[1] - written | 0;
      offset[1] = offset[1] + written | 0;
     }
    }
    function output_char(ssl, c){
     var
      tmp = caml_call2(Stdlib_String[1], 1, c),
      written = caml_call4(write_substring, ssl, tmp, 0, 1),
      _b5_ = written <= 0 ? 1 : 0;
     return _b5_
             ? caml_call1(Stdlib[2], cst_output_char_failed_to_writ)
             : _b5_;
    }
    function output_int(ssl, i){
     var tmp = caml_create_bytes(4);
     caml_bytes_set(tmp, 0, caml_call1(Stdlib[29], i >>> 24 | 0));
     caml_bytes_set(tmp, 1, caml_call1(Stdlib[29], (i >>> 16 | 0) & 255));
     caml_bytes_set(tmp, 2, caml_call1(Stdlib[29], (i >>> 8 | 0) & 255));
     caml_bytes_set(tmp, 3, caml_call1(Stdlib[29], i & 255));
     var _b4_ = 4 !== caml_call4(write, ssl, tmp, 0, 4) ? 1 : 0;
     return _b4_
             ? caml_call1(Stdlib[2], cst_output_int_error_all_the_b)
             : _b4_;
    }
    function input_string(ssl){
     var
      buf = caml_create_bytes(1024),
      ret = [0, cst$1],
      r = [0, 1],
      bufsize = 1024;
     for(;;){
      if(0 === r[1]) return ret[1];
      r[1] = caml_call4(read, ssl, buf, 0, bufsize);
      var _b3_ = caml_call3(Stdlib_Bytes[8], buf, 0, r[1]);
      ret[1] = caml_call2(Stdlib[28], ret[1], _b3_);
     }
    }
    function input_char(ssl){
     var tmp = caml_create_bytes(1);
     if(1 === caml_call4(read, ssl, tmp, 0, 1)) return caml_bytes_get(tmp, 0);
     throw caml_maybe_attach_backtrace(Stdlib[12], 1);
    }
    function input_int(ssl){
     var
      i = [0, 0],
      tmp = caml_create_bytes(4),
      read$0 = caml_call4(read, ssl, tmp, 0, 4);
     if(read$0 < 4) caml_call1(Stdlib[2], cst_input_int_failed_to_read_4);
     i[1] = caml_bytes_get(tmp, 0);
     var _b0_ = caml_bytes_get(tmp, 1);
     i[1] = (i[1] << 8) + _b0_ | 0;
     var _b1_ = caml_bytes_get(tmp, 2);
     i[1] = (i[1] << 8) + _b1_ | 0;
     var _b2_ = caml_bytes_get(tmp, 3);
     i[1] = (i[1] << 8) + _b2_ | 0;
     return i[1];
    }
    return [0,
            connect,
            accept,
            ,
            flush,
            read,
            read_into_bigarray,
            write,
            write_substring,
            write_bigarray,
            open_connection_with_context,
            open_connection,
            ssl_shutdown,
            shutdown,
            shutdown,
            output_string,
            output_char,
            output_int,
            input_string,
            input_char,
            input_int];
   }
   function _l_(_bZ_, _bY_, _bX_, _bW_){
    return runtime.ocaml_ssl_write_bigarray(_bZ_, _bY_, _bX_, _bW_);
   }
   function _m_(_bV_, _bU_, _bT_, _bS_){
    return runtime.ocaml_ssl_write(_bV_, _bU_, _bT_, _bS_);
   }
   function _n_(_bR_, _bQ_, _bP_, _bO_){
    return runtime.ocaml_ssl_write(_bR_, _bQ_, _bP_, _bO_);
   }
   function _o_(_bN_, _bM_, _bL_, _bK_){
    return runtime.ocaml_ssl_read_into_bigarray(_bN_, _bM_, _bL_, _bK_);
   }
   function _p_(_bJ_, _bI_, _bH_, _bG_){
    return runtime.ocaml_ssl_read(_bJ_, _bI_, _bH_, _bG_);
   }
   function _q_(_bF_){return runtime.ocaml_ssl_flush(_bF_);}
   function _r_(_bE_){return runtime.ocaml_ssl_shutdown(_bE_);}
   function _s_(_bD_){return runtime.ocaml_ssl_accept(_bD_);}
   var
    include =
      Make
       ([0,
         function(_bC_){return runtime.ocaml_ssl_connect(_bC_);},
         _s_,
         _r_,
         _q_,
         _p_,
         _o_,
         _n_,
         _m_,
         _l_]),
    connect$0 = include[1],
    accept$0 = include[2],
    flush$0 = include[4],
    read$0 = include[5],
    read_into_bigarray$0 = include[6],
    write$0 = include[7],
    write_substring$0 = include[8],
    write_bigarray$0 = include[9],
    open_connection_with_context = include[10],
    open_connection = include[11],
    close_notify = include[12],
    shutdown = include[13],
    shutdown_connection = include[14],
    output_string = include[15],
    output_char = include[16],
    output_int = include[17],
    input_string = include[18],
    input_char = include[19],
    input_int = include[20],
    Runtime_lock =
      Make
       ([0,
         connect,
         accept,
         ssl_shutdown,
         flush,
         read,
         read_into_bigarray,
         write,
         write_substring,
         write_bigarray]),
    read_into_bigarray_blocking = Runtime_lock[6],
    write_bigarray_blocking = Runtime_lock[9],
    _t_ =
      [0,
       Runtime_lock[1],
       Runtime_lock[2],
       Runtime_lock[11],
       Runtime_lock[10],
       Runtime_lock[12],
       Runtime_lock[14],
       Runtime_lock[13],
       Runtime_lock[4],
       Runtime_lock[5],
       Runtime_lock[6],
       Runtime_lock[7],
       Runtime_lock[8],
       Runtime_lock[9],
       Runtime_lock[18],
       Runtime_lock[15],
       Runtime_lock[19],
       Runtime_lock[16],
       Runtime_lock[20],
       Runtime_lock[17]];
   function _u_(_bB_){return runtime.ocaml_ssl_get_file_descr(_bB_);}
   function _v_(_bA_, _bz_){return runtime.ocaml_ssl_set1_ip(_bA_, _bz_);}
   function _w_(_by_, _bx_){return runtime.ocaml_ssl_set1_host(_by_, _bx_);}
   function _x_(_bw_, _bv_){
    return runtime.ocaml_ssl_set_hostflags(_bw_, _bv_);
   }
   function _y_(_bu_){return runtime.ocaml_ssl_verify(_bu_);}
   function _z_(_bt_){
    return runtime.ocaml_ssl_get_negotiated_alpn_protocol(_bt_);
   }
   function _A_(_bs_, _br_){
    return runtime.ocaml_ssl_set_alpn_protos(_bs_, _br_);
   }
   function _B_(_bq_, _bp_){
    return runtime.ocaml_ssl_set_client_SNI_hostname(_bq_, _bp_);
   }
   function _C_(_bo_, _bn_){
    return runtime.ocaml_ssl_embed_socket(_bo_, _bn_);
   }
   function _D_(_bm_, _bl_){return runtime.ocaml_ssl_digest(_bm_, _bl_);}
   function _E_(_bk_){return runtime.ocaml_ssl_get_verify_error_string(_bk_);}
   function _F_(_bj_){return runtime.ocaml_ssl_get_verify_result(_bj_);}
   function _G_(_bi_){
    return runtime.ocaml_ssl_ctx_set_default_verify_paths(_bi_);
   }
   function _H_(_bh_, _bg_, _bf_){
    return runtime.ocaml_ssl_ctx_load_verify_locations(_bh_, _bg_, _bf_);
   }
   function _I_(_be_){return runtime.ocaml_ssl_get_expiration_date(_be_);}
   function _J_(_bd_){return runtime.ocaml_ssl_get_start_date(_bd_);}
   function _K_(_bc_){return runtime.ocaml_ssl_get_subject(_bc_);}
   function _L_(_bb_){return runtime.ocaml_ssl_get_issuer(_bb_);}
   function _M_(_ba_){return runtime.ocaml_ssl_get_certificate(_ba_);}
   function _N_(_a$_, _a__){
    return runtime.ocaml_ssl_write_certificate(_a$_, _a__);
   }
   function _O_(_a9_){return runtime.ocaml_ssl_read_certificate(_a9_);}
   function _P_(_a8_){return runtime.ocaml_ssl_version(_a8_);}
   function _Q_(_a7_){return runtime.ocaml_ssl_get_cipher_version(_a7_);}
   function _R_(_a6_){return runtime.ocaml_ssl_get_cipher_name(_a6_);}
   function _S_(_a5_){return runtime.ocaml_ssl_get_cipher_description(_a5_);}
   function _T_(_a4_){return runtime.ocaml_ssl_get_current_cipher(_a4_);}
   function _U_(_a3_, _a2_){
    return runtime.ocaml_ssl_ctx_init_ec_from_named_curve(_a3_, _a2_);
   }
   function _V_(_a1_, _a0_){
    return runtime.ocaml_ssl_ctx_init_dh_from_file(_a1_, _a0_);
   }
   function _W_(_aZ_){return runtime.ocaml_ssl_ctx_honor_cipher_order(_aZ_);}
   function _X_(_aY_, _aX_){
    return runtime.ocaml_ssl_ctx_set_cipher_list(_aY_, _aX_);
   }
   function _Y_(_aW_, _aV_){
    return runtime.ocaml_ssl_disable_protocols(_aW_, _aV_);
   }
   function _Z_(_aU_, _aT_){
    return runtime.ocaml_ssl_ctx_set_alpn_select_callback(_aU_, _aT_);
   }
   function ___(_aS_, _aR_){
    return runtime.ocaml_ssl_ctx_set_alpn_protos(_aS_, _aR_);
   }
   function _$_(_aQ_, _aP_){
    return runtime.ocaml_ssl_ctx_set_verify_depth(_aQ_, _aP_);
   }
   function _aa_(_aO_, _aN_, _aM_){
    return runtime.ocaml_ssl_ctx_set_verify(_aO_, _aN_, _aM_);
   }
   function _ab_(_aL_){
    return runtime.ocaml_ssl_set_client_verify_callback_verbose(_aL_);
   }
   function _ac_(_aK_, _aJ_){
    return runtime.ocaml_ssl_ctx_set_client_CA_list_from_file(_aK_, _aJ_);
   }
   function _ad_(_aI_, _aH_){
    return runtime.ocaml_ssl_ctx_set_default_passwd_cb(_aI_, _aH_);
   }
   function _ae_(_aG_, _aF_, _aE_){
    return runtime.ocaml_ssl_ctx_use_certificate_from_string(_aG_, _aF_, _aE_);
   }
   function _af_(_aD_, _aC_, _aB_){
    return runtime.ocaml_ssl_ctx_use_certificate(_aD_, _aC_, _aB_);
   }
   function _ag_(_aA_, _az_){
    return runtime.ocaml_ssl_ctx_add_cert_to_store(_aA_, _az_);
   }
   function _ah_(_ay_, _ax_){
    return runtime.ocaml_ssl_ctx_add_extra_chain_cert(_ay_, _ax_);
   }
   function _ai_(_aw_){
    return runtime.ocaml_ssl_ctx_get_max_proto_version(_aw_);
   }
   function _aj_(_av_){
    return runtime.ocaml_ssl_ctx_get_min_proto_version(_av_);
   }
   function _ak_(_au_, _at_){
    return runtime.ocaml_ssl_ctx_set_max_proto_version(_au_, _at_);
   }
   function _al_(_as_, _ar_){
    return runtime.ocaml_ssl_ctx_set_min_proto_version(_as_, _ar_);
   }
   function _am_(_aq_, _ap_){
    return runtime.ocaml_ssl_create_context(_aq_, _ap_);
   }
   var
    _an_ = [0, get_error, peek_error, peek_last_error],
    Ssl =
      [0,
       native_library_version,
       Method_error,
       Context_error,
       Cipher_error,
       Diffie_hellman_error,
       Ec_curve_error,
       Certificate_error,
       Private_key_error,
       Unmatching_keys,
       Invalid_socket,
       Handler_error,
       Connection_error,
       Accept_error,
       Read_error,
       Write_error,
       Flush_error,
       Verify_error,
       init,
       function(_ao_){return runtime.ocaml_ssl_get_error_string(_ao_);},
       _an_,
       thread_safe,
       _am_,
       _al_,
       _ak_,
       _aj_,
       _ai_,
       _ah_,
       _ag_,
       _af_,
       _ae_,
       _ad_,
       _ac_,
       client_verify_callback,
       _ab_,
       _aa_,
       _$_,
       ___,
       _Z_,
       _Y_,
       _X_,
       _W_,
       _V_,
       _U_,
       _T_,
       _S_,
       _R_,
       _Q_,
       _P_,
       _O_,
       _N_,
       _M_,
       _L_,
       _K_,
       _J_,
       _I_,
       _H_,
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       connect$0,
       accept$0,
       open_connection,
       open_connection_with_context,
       close_notify,
       shutdown_connection,
       shutdown,
       flush$0,
       read$0,
       read_into_bigarray$0,
       write$0,
       write_substring$0,
       write_bigarray$0,
       input_string,
       output_string,
       input_char,
       output_char,
       input_int,
       output_int,
       _t_,
       read_into_bigarray_blocking,
       write_bigarray_blocking];
   runtime.caml_register_global(80, Ssl, "Ssl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ssl_threads
//# unitInfo: Requires: Ssl
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Ssl = global_data.Ssl;
   function init(param){Ssl[21][1] = 1; return 0;}
   var Ssl_threads = [0, init];
   runtime.caml_register_global(1, Ssl_threads, "Ssl_threads");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzc2wuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIm5hdGl2ZV9saWJyYXJ5X3ZlcnNpb24iLCJnZXRfZXJyb3IiLCJwZWVrX2Vycm9yIiwicGVla19sYXN0X2Vycm9yIiwicGVla19sYXN0X2Vycm9yX3N0cmluZyIsImVyciIsImxpYiIsImxpYnN0cmluZyIsInJlYXNvbiIsInJlYXNvbnN0cmluZyIsInMiLCJzJDAiLCJiIiwidGhyZWFkX3NhZmUiLCJpbml0IiwidGhyZWFkX3NhZmUkMCIsInRocmVhZF9zYWZlJDEiLCJjbGllbnRfdmVyaWZ5X2NhbGxiYWNrIiwiY29ubmVjdCIsInNvY2tldCIsInJldCIsImFjY2VwdCIsIndyaXRlIiwiYnVmZmVyIiwic3RhcnQiLCJsZW5ndGgiLCJ3cml0ZV9zdWJzdHJpbmciLCJ3cml0ZV9iaWdhcnJheSIsInJlYWQiLCJyZWFkX2ludG9fYmlnYXJyYXkiLCJmbHVzaCIsInNzbF9zaHV0ZG93biIsIm9wZW5fY29ubmVjdGlvbl93aXRoX2NvbnRleHQiLCJjb250ZXh0Iiwic29ja2FkZHIiLCJkb21haW4iLCJzb2NrIiwic3NsIiwiZXhuJDAiLCJleG4iLCJvcGVuX2Nvbm5lY3Rpb24iLCJzc2xfbWV0aG9kIiwic2h1dGRvd24iLCJvdXRwdXRfc3RyaW5nIiwibGVuIiwidG9fd3JpdGUiLCJvZmZzZXQiLCJ3cml0dGVuIiwib3V0cHV0X2NoYXIiLCJjIiwidG1wIiwib3V0cHV0X2ludCIsImkiLCJpbnB1dF9zdHJpbmciLCJidWYiLCJyIiwiYnVmc2l6ZSIsImlucHV0X2NoYXIiLCJpbnB1dF9pbnQiLCJyZWFkJDAiLCJjb25uZWN0JDAiLCJhY2NlcHQkMCIsImZsdXNoJDAiLCJyZWFkX2ludG9fYmlnYXJyYXkkMCIsIndyaXRlJDAiLCJ3cml0ZV9zdWJzdHJpbmckMCIsIndyaXRlX2JpZ2FycmF5JDAiLCJjbG9zZV9ub3RpZnkiLCJzaHV0ZG93bl9jb25uZWN0aW9uIiwicmVhZF9pbnRvX2JpZ2FycmF5X2Jsb2NraW5nIiwid3JpdGVfYmlnYXJyYXlfYmxvY2tpbmciXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9zc2wvc3NsLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvc3NsL3NzbF90aHJlYWRzLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7R0EwQnVDOzs7Ozs7Ozs7Ozs7O0lBQW5DQSx5QkFBbUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQW9GakNDLGlCQUFlLE9BQUEsa0NBQXNCO1lBQ3JDQyxrQkFBZ0IsT0FBQSxrQ0FBdUI7WUFDdkNDLHVCQUFxQixPQUFBLGtDQUE0QjtZQUdqREM7SUFDRixJQUFJQyxNQUFNLG1DQUNWLFFBRElBOztTQUNvQ0MsZ0JBQXBDQyxZQUFvQ0Q7O1NBQXBDQztJQUNKLGNBRklGOztTQUd5QkcscUJBRHpCQyxlQUN5QkQ7O1NBRHpCQztJQUdKLE9BQUE7b0NBTElKLFFBQUFBLFFBQ0FFLFdBQ0FFO0dBUVU7R0FHbEI7SUFBQTtJQUNBO0lBQ0E7SUFDQTtJQUNBOztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7O0lBRzRCLDJCQUNKO2dDQUNDOztTQUNDQztLQUFLLFdBQUssa0RBQVZBOzsrQkFDRjt1Q0FDUTtpQ0FDTjs7U0FDQUM7S0FBSyxXQUFLLGtEQUFWQTs7a0NBQ0M7aUNBQ0Q7Z0NBQ0Q7O0tBRWtCLFdBNUNyQ1A7S0E0Q0UsV0FBSzs7O0tBRTBCLFdBOUNqQ0E7S0E4Q0UsV0FBSzs7O0tBRXdCLFdBaEQvQkE7S0FnREUsV0FBSzs7O0tBRXlCLFdBbERoQ0E7S0FrREUsV0FBSzs7O0tBRTBCLFdBcERqQ0E7S0Fv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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0hGMkM7T0FDQUM7T0FrUUlyQjtPQWJBUjtPQWtCQW1DO09BS0FDO09BSEExQjtPQXZRSm9CO09BQ0FIO09BQ0FJO09BQ0FDO09BQ0FDO09BQ0FDO09BZ1NJYjtPQXpCQVY7T0FvQ0FjO09BekJBVDtPQTZCQVU7T0F4QkFQOztPQTBDRmtCO09BR0FDOzs7RTs7Ozs7Ozs7Ozs7O1lDcndCQXhELFlBQVUseUJBQXVCO3lCQUFqQ0E7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogQ29weXJpZ2h0IChDKSAyMDAzLTIwMDUgU2FtdWVsIE1pbXJhbVxuXG4gICBUaGlzIGZpbGUgaXMgcGFydCBvZiBPY2FtbC1zc2wuXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyXG4gICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWVcbiAgIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1NcbiAgIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmVcbiAgIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgSW5jLixcbiAgIDUxIEZyYW5rbGluIFN0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQSAqKVxuXG50eXBlIHZlcnNpb24gPVxuICB7IG1ham9yIDogaW50ICAoKiogbWFqb3IgdmVyc2lvbiAqKVxuICA7IG1pbm9yIDogaW50ICAoKiogbWlub3IgdmVyc2lvbiAqKVxuICA7IHBhdGNoIDogaW50ICAoKiogcGF0Y2ggbnVtYmVyIChmaXggKyBwYXRjaCBpbiB2ZXJzaW9uIDwgMy4wKSAqKVxuICB9XG5cbmV4dGVybmFsIGdldF92ZXJzaW9uIDogdW5pdCAtPiB2ZXJzaW9uID0gXCJvY2FtbF9zc2xfZ2V0X3ZlcnNpb25cIlxuXG5sZXQgbmF0aXZlX2xpYnJhcnlfdmVyc2lvbiA6IHZlcnNpb24gPSBnZXRfdmVyc2lvbiAoKVxuXG50eXBlIHByb3RvY29sID1cbiAgfCBTU0x2MjNcbiAgfCBTU0x2M1xuICB8IFRMU3YxXG4gIHwgVExTdjFfMVxuICB8IFRMU3YxXzJcbiAgfCBUTFN2MV8zXG5cbnR5cGUgY29udGV4dFxudHlwZSBjZXJ0aWZpY2F0ZVxudHlwZSBzb2NrZXRcblxudHlwZSBzc2xfZXJyb3IgPVxuICB8IEVycm9yX25vbmVcbiAgfCBFcnJvcl9zc2xcbiAgfCBFcnJvcl93YW50X3JlYWRcbiAgfCBFcnJvcl93YW50X3dyaXRlXG4gIHwgRXJyb3Jfd2FudF94NTA5X2xvb2t1cFxuICB8IEVycm9yX3N5c2NhbGxcbiAgfCBFcnJvcl96ZXJvX3JldHVyblxuICB8IEVycm9yX3dhbnRfY29ubmVjdFxuICB8IEVycm9yX3dhbnRfYWNjZXB0XG4gIHwgRXJyb3Jfd2FudF9hc3luY1xuICB8IEVycm9yX3dhbnRfYXN5bmNfam9iXG4gIHwgRXJyb3Jfd2FudF9jbGllbnRfaGVsbG9fY2JcbiAgfCBFcnJvcl93YW50X3JldHJ5X3ZlcmlmeVxuXG50eXBlIHZlcmlmeV9lcnJvciA9XG4gIHwgRXJyb3Jfdl91bmFibGVfdG9fZ2V0X2lzc3Vlcl9jZXJ0XG4gIHwgRXJyb3Jfdl91bmFibGVfdG9fZ2V0X2N0bFxuICB8IEVycm9yX3ZfdW5hYmxlX3RvX2RlY3J5cHRfY2VydF9zaWduYXR1cmVcbiAgfCBFcnJvcl92X3VuYWJsZV90b19kZWNyeXB0X0NSTF9zaWduYXR1cmVcbiAgfCBFcnJvcl92X3VuYWJsZV90b19kZWNvZGVfaXNzdWVyX3B1YmxpY19rZXlcbiAgfCBFcnJvcl92X2NlcnRfc2lnbmF0dXJlX2ZhaWx1cmVcbiAgfCBFcnJvcl92X0NSTF9zaWduYXR1cmVfZmFpbHVyZVxuICB8IEVycm9yX3ZfY2VydF9ub3RfeWV0X3ZhbGlkXG4gIHwgRXJyb3Jfdl9jZXJ0X2hhc19leHBpcmVkXG4gIHwgRXJyb3Jfdl9DUkxfbm90X3lldF92YWxpZFxuICB8IEVycm9yX3ZfQ1JMX2hhc19leHBpcmVkXG4gIHwgRXJyb3Jfdl9lcnJvcl9pbl9jZXJ0X25vdF9iZWZvcmVfZmllbGRcbiAgfCBFcnJvcl92X2Vycm9yX2luX2NlcnRfbm90X2FmdGVyX2ZpZWxkXG4gIHwgRXJyb3Jfdl9lcnJvcl9pbl9DUkxfbGFzdF91cGRhdGVfZmllbGRcbiAgfCBFcnJvcl92X2Vycm9yX2luX0NSTF9uZXh0X3VwZGF0ZV9maWVsZFxuICB8IEVycm9yX3Zfb3V0X29mX21lbVxuICB8IEVycm9yX3ZfZGVwdGhfemVyb19zZWxmX3NpZ25lZF9jZXJ0XG4gIHwgRXJyb3Jfdl9zZWxmX3NpZ25lZF9jZXJ0X2luX2NoYWluXG4gIHwgRXJyb3Jfdl91bmFibGVfdG9fZ2V0X2lzc3Vlcl9jZXJ0X2xvY2FsbHlcbiAgfCBFcnJvcl92X3VuYWJsZV90b192ZXJpZnlfbGVhZl9zaWduYXR1cmVcbiAgfCBFcnJvcl92X2NlcnRfY2hhaW5fdG9vX2xvbmdcbiAgfCBFcnJvcl92X2NlcnRfcmV2b2tlZFxuICB8IEVycm9yX3ZfaW52YWxpZF9DQVxuICB8IEVycm9yX3ZfcGF0aF9sZW5ndGhfZXhjZWVkZWRcbiAgfCBFcnJvcl92X2ludmFsaWRfcHVycG9zZVxuICB8IEVycm9yX3ZfY2VydF91bnRydXN0ZWRcbiAgfCBFcnJvcl92X2NlcnRfcmVqZWN0ZWRcbiAgfCBFcnJvcl92X3N1YmplY3RfaXNzdWVyX21pc21hdGNoXG4gIHwgRXJyb3Jfdl9ha2lkX3NraWRfbWlzbWF0Y2hcbiAgfCBFcnJvcl92X2FraWRfaXNzdWVyX3NlcmlhbF9taXNtYXRjaFxuICB8IEVycm9yX3Zfa2V5dXNhZ2Vfbm9fY2VydHNpZ25cbiAgfCBFcnJvcl92X2FwcGxpY2F0aW9uX3ZlcmlmaWNhdGlvblxuXG50eXBlIGJpZ2FycmF5ID1cbiAgKGNoYXIsIEJpZ2FycmF5LmludDhfdW5zaWduZWRfZWx0LCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuQXJyYXkxLnRcblxuZXh0ZXJuYWwgZ2V0X2Vycm9yX3N0cmluZyA6IHVuaXQgLT4gc3RyaW5nID0gXCJvY2FtbF9zc2xfZ2V0X2Vycm9yX3N0cmluZ1wiXG4oKiogS2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKilcblxubW9kdWxlIEVycm9yID0gc3RydWN0XG4gIHR5cGUgdCA9IHByaXZhdGVcbiAgICB7IGxpYnJhcnlfbnVtYmVyIDogaW50XG4gICAgOyByZWFzb25fY29kZSA6IGludFxuICAgIDsgbGliIDogc3RyaW5nIG9wdGlvblxuICAgIDsgcmVhc29uIDogc3RyaW5nIG9wdGlvblxuICAgIH1cblxuICB0eXBlIGVycl9mdW5jdGlvbiA9XG4gICAgfCBHZXRfZXJyb3JcbiAgICB8IFBlZWtfZXJyb3JcbiAgICB8IFBlZWtfbGFzdF9lcnJvclxuXG4gIGV4dGVybmFsIGVycm9yX3N0cnVjdCA6IGVycl9mdW5jdGlvbiAtPiB0ID0gXCJvY2FtbF9zc2xfZXJyb3Jfc3RydWN0XCJcblxuICBsZXQgZ2V0X2Vycm9yICgpID0gZXJyb3Jfc3RydWN0IEdldF9lcnJvclxuICBsZXQgcGVla19lcnJvciAoKSA9IGVycm9yX3N0cnVjdCBQZWVrX2Vycm9yXG4gIGxldCBwZWVrX2xhc3RfZXJyb3IgKCkgPSBlcnJvcl9zdHJ1Y3QgUGVla19sYXN0X2Vycm9yXG5cbiAgKCoqIFJlcHJvZHVjZXMgdGhlIHN0cmluZyBmb3JtYXQgZnJvbSBFUlJfZXJyb3Jfc3RyaW5nX24gKilcbiAgbGV0IHBlZWtfbGFzdF9lcnJvcl9zdHJpbmcgKCkgPVxuICAgIGxldCBlcnIgPSBwZWVrX2xhc3RfZXJyb3IgKCkgaW5cbiAgICBsZXQgbGlic3RyaW5nID0gbWF0Y2ggZXJyLmxpYiB3aXRoIFNvbWUgbGliIC0+IGxpYiB8IE5vbmUgLT4gXCJsaWIoMClcIiBpblxuICAgIGxldCByZWFzb25zdHJpbmcgPVxuICAgICAgbWF0Y2ggZXJyLnJlYXNvbiB3aXRoIFNvbWUgcmVhc29uIC0+IHJlYXNvbiB8IE5vbmUgLT4gXCJyZWFzb24oMClcIlxuICAgIGluXG4gICAgUHJpbnRmLnNwcmludGZcbiAgICAgIFwiZXJyb3I6JTAybFg6JTA2bFg6JXM6OiVzXCJcbiAgICAgIChJbnQzMi5vZl9pbnQgZXJyLmxpYnJhcnlfbnVtYmVyKVxuICAgICAgKEludDMyLm9mX2ludCBlcnIucmVhc29uX2NvZGUpXG4gICAgICBsaWJzdHJpbmdcbiAgICAgIHJlYXNvbnN0cmluZ1xuZW5kXG5cbmV4Y2VwdGlvbiBNZXRob2RfZXJyb3JcbmV4Y2VwdGlvbiBDb250ZXh0X2Vycm9yXG5leGNlcHRpb24gQ2VydGlmaWNhdGVfZXJyb3Igb2Ygc3RyaW5nXG5leGNlcHRpb24gQ2lwaGVyX2Vycm9yXG5leGNlcHRpb24gRGlmZmllX2hlbGxtYW5fZXJyb3JcbmV4Y2VwdGlvbiBFY19jdXJ2ZV9lcnJvclxuZXhjZXB0aW9uIFByaXZhdGVfa2V5X2Vycm9yIG9mIHN0cmluZ1xuZXhjZXB0aW9uIFVubWF0Y2hpbmdfa2V5c1xuZXhjZXB0aW9uIEludmFsaWRfc29ja2V0XG5leGNlcHRpb24gSGFuZGxlcl9lcnJvclxuZXhjZXB0aW9uIENvbm5lY3Rpb25fZXJyb3Igb2Ygc3NsX2Vycm9yXG5leGNlcHRpb24gQWNjZXB0X2Vycm9yIG9mIHNzbF9lcnJvclxuZXhjZXB0aW9uIFJlYWRfZXJyb3Igb2Ygc3NsX2Vycm9yXG5leGNlcHRpb24gV3JpdGVfZXJyb3Igb2Ygc3NsX2Vycm9yXG5leGNlcHRpb24gVmVyaWZ5X2Vycm9yIG9mIHZlcmlmeV9lcnJvclxuZXhjZXB0aW9uIEZsdXNoX2Vycm9yIG9mIGJvb2wgKCogdHJ1ZSBtZWFucyByZXRyeSAqKVxuXG5sZXQgKCkgPVxuICBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIChmdW5jdGlvblxuICAgICAgfCBNZXRob2RfZXJyb3IgLT4gU29tZSBcIlNTTDogTWV0aG9kIGVycm9yXCJcbiAgICAgIHwgQ29udGV4dF9lcnJvciAtPiBTb21lIFwiU1NMOiBDb250ZXh0IGVycm9yXCJcbiAgICAgIHwgQ2VydGlmaWNhdGVfZXJyb3IgcyAtPiBTb21lIChcIlNTTDogQ2VydGlmaWNhdGUgZXJyb3I6IFwiIF4gcylcbiAgICAgIHwgQ2lwaGVyX2Vycm9yIC0+IFNvbWUgXCJTU0w6IENpcGhlciBlcnJvclwiXG4gICAgICB8IERpZmZpZV9oZWxsbWFuX2Vycm9yIC0+IFNvbWUgXCJTU0w6IERpZmZpZS1IZWxsbWFuIGVycm9yXCJcbiAgICAgIHwgRWNfY3VydmVfZXJyb3IgLT4gU29tZSBcIlNTTDogRUMgY3VydmUgZXJyb3JcIlxuICAgICAgfCBQcml2YXRlX2tleV9lcnJvciBzIC0+IFNvbWUgKFwiU1NMOiBQcml2YXRlIGtleSBlcnJvcjogXCIgXiBzKVxuICAgICAgfCBVbm1hdGNoaW5nX2tleXMgLT4gU29tZSBcIlNTTDogVW5tYXRjaGluZyBrZXlzXCJcbiAgICAgIHwgSW52YWxpZF9zb2NrZXQgLT4gU29tZSBcIlNTTDogSW52YWxpZCBzb2NrZXRcIlxuICAgICAgfCBIYW5kbGVyX2Vycm9yIC0+IFNvbWUgXCJTU0w6IEhhbmRsZXIgZXJyb3JcIlxuICAgICAgfCBDb25uZWN0aW9uX2Vycm9yIF8gLT5cbiAgICAgICAgU29tZSAoXCJTU0wgY29ubmVjdGlvbigpIGVycm9yOiBcIiBeIEVycm9yLnBlZWtfbGFzdF9lcnJvcl9zdHJpbmcgKCkpXG4gICAgICB8IEFjY2VwdF9lcnJvciBfIC0+XG4gICAgICAgIFNvbWUgKFwiU1NMIGFjY2VwdCgpIGVycm9yOiBcIiBeIEVycm9yLnBlZWtfbGFzdF9lcnJvcl9zdHJpbmcgKCkpXG4gICAgICB8IFJlYWRfZXJyb3IgXyAtPlxuICAgICAgICBTb21lIChcIlNTTCByZWFkKCkgZXJyb3I6IFwiIF4gRXJyb3IucGVla19sYXN0X2Vycm9yX3N0cmluZyAoKSlcbiAgICAgIHwgV3JpdGVfZXJyb3IgXyAtPlxuICAgICAgICBTb21lIChcIlNTTCB3cml0ZSgpIGVycm9yOiBcIiBeIEVycm9yLnBlZWtfbGFzdF9lcnJvcl9zdHJpbmcgKCkpXG4gICAgICB8IFZlcmlmeV9lcnJvciBfIC0+XG4gICAgICAgIFNvbWUgKFwiU1NMIHZlcmlmeSgpIGVycm9yOiBcIiBeIEVycm9yLnBlZWtfbGFzdF9lcnJvcl9zdHJpbmcgKCkpXG4gICAgICB8IEZsdXNoX2Vycm9yIGIgLT5cbiAgICAgICAgU29tZVxuICAgICAgICAgIChQcmludGYuc3ByaW50ZiBcIlNTTCBmbHVzaCglYikgZXJyb3I6IFwiIGJcbiAgICAgICAgICBeIEVycm9yLnBlZWtfbGFzdF9lcnJvcl9zdHJpbmcgKCkpXG4gICAgICB8IF8gLT4gTm9uZSlcblxubGV0ICgpID1cbiAgQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwic3NsX2V4bl9tZXRob2RfZXJyb3JcIiBNZXRob2RfZXJyb3I7XG4gIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcInNzbF9leG5fY29udGV4dF9lcnJvclwiIENvbnRleHRfZXJyb3I7XG4gIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcInNzbF9leG5fY2VydGlmaWNhdGVfZXJyb3JcIiAoQ2VydGlmaWNhdGVfZXJyb3IgXCJcIik7XG4gIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcInNzbF9leG5fY2lwaGVyX2Vycm9yXCIgQ2lwaGVyX2Vycm9yO1xuICBDYWxsYmFjay5yZWdpc3Rlcl9leGNlcHRpb25cbiAgICBcInNzbF9leG5fZGlmZmllX2hlbGxtYW5fZXJyb3JcIlxuICAgIERpZmZpZV9oZWxsbWFuX2Vycm9yO1xuICBDYWxsYmFjay5yZWdpc3Rlcl9leGNlcHRpb24gXCJzc2xfZXhuX2VjX2N1cnZlX2Vycm9yXCIgRWNfY3VydmVfZXJyb3I7XG4gIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcInNzbF9leG5fcHJpdmF0ZV9rZXlfZXJyb3JcIiAoUHJpdmF0ZV9rZXlfZXJyb3IgXCJcIik7XG4gIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcInNzbF9leG5fdW5tYXRjaGluZ19rZXlzXCIgVW5tYXRjaGluZ19rZXlzO1xuICBDYWxsYmFjay5yZWdpc3Rlcl9leGNlcHRpb24gXCJzc2xfZXhuX2ludmFsaWRfc29ja2V0XCIgSW52YWxpZF9zb2NrZXQ7XG4gIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcInNzbF9leG5faGFuZGxlcl9lcnJvclwiIEhhbmRsZXJfZXJyb3I7XG4gIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvblxuICAgIFwic3NsX2V4bl9jb25uZWN0aW9uX2Vycm9yXCJcbiAgICAoQ29ubmVjdGlvbl9lcnJvciBFcnJvcl9ub25lKTtcbiAgQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwic3NsX2V4bl9hY2NlcHRfZXJyb3JcIiAoQWNjZXB0X2Vycm9yIEVycm9yX25vbmUpO1xuICBDYWxsYmFjay5yZWdpc3Rlcl9leGNlcHRpb24gXCJzc2xfZXhuX3JlYWRfZXJyb3JcIiAoUmVhZF9lcnJvciBFcnJvcl9ub25lKTtcbiAgQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwic3NsX2V4bl93cml0ZV9lcnJvclwiIChXcml0ZV9lcnJvciBFcnJvcl9ub25lKTtcbiAgQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uXG4gICAgXCJzc2xfZXhuX3ZlcmlmeV9lcnJvclwiXG4gICAgKFZlcmlmeV9lcnJvciBFcnJvcl92X2FwcGxpY2F0aW9uX3ZlcmlmaWNhdGlvbik7XG4gIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcInNzbF9leG5fZmx1c2hfZXJyb3JcIiAoRmx1c2hfZXJyb3IgdHJ1ZSlcblxubGV0IHRocmVhZF9zYWZlID0gcmVmIGZhbHNlXG5cbmV4dGVybmFsIGluaXQgOiBib29sIC0+IHVuaXQgPSBcIm9jYW1sX3NzbF9pbml0XCJcblxubGV0IHRzID0gdGhyZWFkX3NhZmVcblxubGV0IGluaXQgP3RocmVhZF9zYWZlICgpID1cbiAgbGV0IHRocmVhZF9zYWZlID0gbWF0Y2ggdGhyZWFkX3NhZmUgd2l0aCBTb21lIGIgLT4gYiB8IE5vbmUgLT4gIXRzIGluXG4gIGluaXQgdGhyZWFkX3NhZmVcblxudHlwZSBjb250ZXh0X3R5cGUgPVxuICB8IENsaWVudF9jb250ZXh0XG4gIHwgU2VydmVyX2NvbnRleHRcbiAgfCBCb3RoX2NvbnRleHRcblxuZXh0ZXJuYWwgY3JlYXRlX2NvbnRleHQgOlxuICAgcHJvdG9jb2xcbiAgLT4gY29udGV4dF90eXBlXG4gIC0+IGNvbnRleHRcbiAgPSBcIm9jYW1sX3NzbF9jcmVhdGVfY29udGV4dFwiXG5cbmV4dGVybmFsIHNldF9taW5fcHJvdG9jb2xfdmVyc2lvbiA6XG4gICBjb250ZXh0XG4gIC0+IHByb3RvY29sXG4gIC0+IHVuaXRcbiAgPSBcIm9jYW1sX3NzbF9jdHhfc2V0X21pbl9wcm90b192ZXJzaW9uXCJcblxuZXh0ZXJuYWwgc2V0X21heF9wcm90b2NvbF92ZXJzaW9uIDpcbiAgIGNvbnRleHRcbiAgLT4gcHJvdG9jb2xcbiAgLT4gdW5pdFxuICA9IFwib2NhbWxfc3NsX2N0eF9zZXRfbWF4X3Byb3RvX3ZlcnNpb25cIlxuXG5leHRlcm5hbCBnZXRfbWluX3Byb3RvY29sX3ZlcnNpb24gOlxuICAgY29udGV4dFxuICAtPiBwcm90b2NvbFxuICA9IFwib2NhbWxfc3NsX2N0eF9nZXRfbWluX3Byb3RvX3ZlcnNpb25cIlxuXG5leHRlcm5hbCBnZXRfbWF4X3Byb3RvY29sX3ZlcnNpb24gOlxuICAgY29udGV4dFxuICAtPiBwcm90b2NvbFxuICA9IFwib2NhbWxfc3NsX2N0eF9nZXRfbWF4X3Byb3RvX3ZlcnNpb25cIlxuXG5leHRlcm5hbCBhZGRfZXh0cmFfY2hhaW5fY2VydCA6XG4gICBjb250ZXh0XG4gIC0+IHN0cmluZ1xuICAtPiB1bml0XG4gID0gXCJvY2FtbF9zc2xfY3R4X2FkZF9leHRyYV9jaGFpbl9jZXJ0XCJcblxuZXh0ZXJuYWwgYWRkX2NlcnRfdG9fc3RvcmUgOlxuICAgY29udGV4dFxuICAtPiBzdHJpbmdcbiAgLT4gdW5pdFxuICA9IFwib2NhbWxfc3NsX2N0eF9hZGRfY2VydF90b19zdG9yZVwiXG5cbmV4dGVybmFsIHVzZV9jZXJ0aWZpY2F0ZSA6XG4gICBjb250ZXh0XG4gIC0+IHN0cmluZ1xuICAtPiBzdHJpbmdcbiAgLT4gdW5pdFxuICA9IFwib2NhbWxfc3NsX2N0eF91c2VfY2VydGlmaWNhdGVcIlxuXG5leHRlcm5hbCB1c2VfY2VydGlmaWNhdGVfZnJvbV9zdHJpbmcgOlxuICAgY29udGV4dFxuICAtPiBzdHJpbmdcbiAgLT4gc3RyaW5nXG4gIC0+IHVuaXRcbiAgPSBcIm9jYW1sX3NzbF9jdHhfdXNlX2NlcnRpZmljYXRlX2Zyb21fc3RyaW5nXCJcblxuZXh0ZXJuYWwgc2V0X3Bhc3N3b3JkX2NhbGxiYWNrIDpcbiAgIGNvbnRleHRcbiAgLT4gKGJvb2wgLT4gc3RyaW5nKVxuICAtPiB1bml0XG4gID0gXCJvY2FtbF9zc2xfY3R4X3NldF9kZWZhdWx0X3Bhc3N3ZF9jYlwiXG5cbmV4dGVybmFsIGVtYmVkX3NvY2tldCA6XG4gICBVbml4LmZpbGVfZGVzY3JcbiAgLT4gY29udGV4dFxuICAtPiBzb2NrZXRcbiAgPSBcIm9jYW1sX3NzbF9lbWJlZF9zb2NrZXRcIlxuXG5leHRlcm5hbCBkaXNhYmxlX3Byb3RvY29scyA6XG4gICBjb250ZXh0XG4gIC0+IHByb3RvY29sIGxpc3RcbiAgLT4gdW5pdFxuICA9IFwib2NhbWxfc3NsX2Rpc2FibGVfcHJvdG9jb2xzXCJcblxuZXh0ZXJuYWwgc2V0X2NpcGhlcl9saXN0IDpcbiAgIGNvbnRleHRcbiAgLT4gc3RyaW5nXG4gIC0+IHVuaXRcbiAgPSBcIm9jYW1sX3NzbF9jdHhfc2V0X2NpcGhlcl9saXN0XCJcblxuZXh0ZXJuYWwgaG9ub3JfY2lwaGVyX29yZGVyIDpcbiAgIGNvbnRleHRcbiAgLT4gdW5pdFxuICA9IFwib2NhbWxfc3NsX2N0eF9ob25vcl9jaXBoZXJfb3JkZXJcIlxuXG5leHRlcm5hbCBpbml0X2RoX2Zyb21fZmlsZSA6XG4gICBjb250ZXh0XG4gIC0+IHN0cmluZ1xuICAtPiB1bml0XG4gID0gXCJvY2FtbF9zc2xfY3R4X2luaXRfZGhfZnJvbV9maWxlXCJcblxuZXh0ZXJuYWwgaW5pdF9lY19mcm9tX25hbWVkX2N1cnZlIDpcbiAgIGNvbnRleHRcbiAgLT4gc3RyaW5nXG4gIC0+IHVuaXRcbiAgPSBcIm9jYW1sX3NzbF9jdHhfaW5pdF9lY19mcm9tX25hbWVkX2N1cnZlXCJcblxuZXh0ZXJuYWwgbG9hZF92ZXJpZnlfbG9jYXRpb25zIDpcbiAgIGNvbnRleHRcbiAgLT4gc3RyaW5nXG4gIC0+IHN0cmluZ1xuICAtPiB1bml0XG4gID0gXCJvY2FtbF9zc2xfY3R4X2xvYWRfdmVyaWZ5X2xvY2F0aW9uc1wiXG5cbmV4dGVybmFsIHNldF9kZWZhdWx0X3ZlcmlmeV9wYXRocyA6XG4gICBjb250ZXh0XG4gIC0+IGJvb2xcbiAgPSBcIm9jYW1sX3NzbF9jdHhfc2V0X2RlZmF1bHRfdmVyaWZ5X3BhdGhzXCJcblxuZXh0ZXJuYWwgZ2V0X3ZlcmlmeV9yZXN1bHQgOiBzb2NrZXQgLT4gaW50ID0gXCJvY2FtbF9zc2xfZ2V0X3ZlcmlmeV9yZXN1bHRcIlxuXG5leHRlcm5hbCBnZXRfdmVyaWZ5X2Vycm9yX3N0cmluZyA6XG4gICBpbnRcbiAgLT4gc3RyaW5nXG4gID0gXCJvY2FtbF9zc2xfZ2V0X3ZlcmlmeV9lcnJvcl9zdHJpbmdcIlxuXG5leHRlcm5hbCBkaWdlc3QgOlxuICAgWyBgU0hBMSB8IGBTSEEyNTYgfCBgU0hBMzg0IF1cbiAgLT4gY2VydGlmaWNhdGVcbiAgLT4gc3RyaW5nXG4gID0gXCJvY2FtbF9zc2xfZGlnZXN0XCJcblxudHlwZSB2ZXJpZnlfbW9kZSA9XG4gIHwgVmVyaWZ5X3BlZXJcbiAgfCBWZXJpZnlfZmFpbF9pZl9ub19wZWVyX2NlcnRcbiAgfCBWZXJpZnlfY2xpZW50X29uY2VcblxudHlwZSB2ZXJpZnlfY2FsbGJhY2tcblxuZXh0ZXJuYWwgZ2V0X2NsaWVudF92ZXJpZnlfY2FsbGJhY2tfcHRyIDpcbiAgIHVuaXRcbiAgLT4gdmVyaWZ5X2NhbGxiYWNrXG4gID0gXCJvY2FtbF9zc2xfZ2V0X2NsaWVudF92ZXJpZnlfY2FsbGJhY2tfcHRyXCJcblxubGV0IGNsaWVudF92ZXJpZnlfY2FsbGJhY2sgPSBnZXRfY2xpZW50X3ZlcmlmeV9jYWxsYmFja19wdHIgKClcblxuZXh0ZXJuYWwgc2V0X2NsaWVudF92ZXJpZnlfY2FsbGJhY2tfdmVyYm9zZSA6XG4gICBib29sXG4gIC0+IHVuaXRcbiAgPSBcIm9jYW1sX3NzbF9zZXRfY2xpZW50X3ZlcmlmeV9jYWxsYmFja192ZXJib3NlXCJcblxuZXh0ZXJuYWwgc2V0X3ZlcmlmeSA6XG4gICBjb250ZXh0XG4gIC0+IHZlcmlmeV9tb2RlIGxpc3RcbiAgLT4gdmVyaWZ5X2NhbGxiYWNrIG9wdGlvblxuICAtPiB1bml0XG4gID0gXCJvY2FtbF9zc2xfY3R4X3NldF92ZXJpZnlcIlxuXG5leHRlcm5hbCBzZXRfdmVyaWZ5X2RlcHRoIDpcbiAgIGNvbnRleHRcbiAgLT4gaW50XG4gIC0+IHVuaXRcbiAgPSBcIm9jYW1sX3NzbF9jdHhfc2V0X3ZlcmlmeV9kZXB0aFwiXG5cbmV4dGVybmFsIHNldF9jbGllbnRfQ0FfbGlzdF9mcm9tX2ZpbGUgOlxuICAgY29udGV4dFxuICAtPiBzdHJpbmdcbiAgLT4gdW5pdFxuICA9IFwib2NhbWxfc3NsX2N0eF9zZXRfY2xpZW50X0NBX2xpc3RfZnJvbV9maWxlXCJcblxuZXh0ZXJuYWwgc2V0X2NvbnRleHRfYWxwbl9wcm90b3MgOlxuICAgY29udGV4dFxuICAtPiBzdHJpbmcgbGlzdFxuICAtPiB1bml0XG4gID0gXCJvY2FtbF9zc2xfY3R4X3NldF9hbHBuX3Byb3Rvc1wiXG5cbmV4dGVybmFsIHNldF9jb250ZXh0X2FscG5fc2VsZWN0X2NhbGxiYWNrIDpcbiAgIGNvbnRleHRcbiAgLT4gKHN0cmluZyBsaXN0IC0+IHN0cmluZyBvcHRpb24pXG4gIC0+IHVuaXRcbiAgPSBcIm9jYW1sX3NzbF9jdHhfc2V0X2FscG5fc2VsZWN0X2NhbGxiYWNrXCJcblxuZXh0ZXJuYWwgdmVyc2lvbiA6IHNvY2tldCAtPiBwcm90b2NvbCA9IFwib2NhbWxfc3NsX3ZlcnNpb25cIlxuXG50eXBlIGNpcGhlclxuXG5leHRlcm5hbCBnZXRfY2lwaGVyIDogc29ja2V0IC0+IGNpcGhlciA9IFwib2NhbWxfc3NsX2dldF9jdXJyZW50X2NpcGhlclwiXG5cbmV4dGVybmFsIGdldF9jaXBoZXJfZGVzY3JpcHRpb24gOlxuICAgY2lwaGVyXG4gIC0+IHN0cmluZ1xuICA9IFwib2NhbWxfc3NsX2dldF9jaXBoZXJfZGVzY3JpcHRpb25cIlxuXG4oKiBUT0RPOiBnZXRfY2lwaGVyX2JpdHMgKilcblxuZXh0ZXJuYWwgZ2V0X2NpcGhlcl9uYW1lIDogY2lwaGVyIC0+IHN0cmluZyA9IFwib2NhbWxfc3NsX2dldF9jaXBoZXJfbmFtZVwiXG5leHRlcm5hbCBnZXRfY2lwaGVyX3ZlcnNpb24gOiBjaXBoZXIgLT4gc3RyaW5nID0gXCJvY2FtbF9zc2xfZ2V0X2NpcGhlcl92ZXJzaW9uXCJcbmV4dGVybmFsIGdldF9jZXJ0aWZpY2F0ZSA6IHNvY2tldCAtPiBjZXJ0aWZpY2F0ZSA9IFwib2NhbWxfc3NsX2dldF9jZXJ0aWZpY2F0ZVwiXG5leHRlcm5hbCByZWFkX2NlcnRpZmljYXRlIDogc3RyaW5nIC0+IGNlcnRpZmljYXRlID0gXCJvY2FtbF9zc2xfcmVhZF9jZXJ0aWZpY2F0ZVwiXG5cbmV4dGVybmFsIHdyaXRlX2NlcnRpZmljYXRlIDpcbiAgIHN0cmluZ1xuICAtPiBjZXJ0aWZpY2F0ZVxuICAtPiB1bml0XG4gID0gXCJvY2FtbF9zc2xfd3JpdGVfY2VydGlmaWNhdGVcIlxuXG5leHRlcm5hbCBnZXRfaXNzdWVyIDogY2VydGlmaWNhdGUgLT4gc3RyaW5nID0gXCJvY2FtbF9zc2xfZ2V0X2lzc3VlclwiXG5leHRlcm5hbCBnZXRfc3ViamVjdCA6IGNlcnRpZmljYXRlIC0+IHN0cmluZyA9IFwib2NhbWxfc3NsX2dldF9zdWJqZWN0XCJcbmV4dGVybmFsIGdldF9zdGFydF9kYXRlIDogY2VydGlmaWNhdGUgLT4gVW5peC50bSA9IFwib2NhbWxfc3NsX2dldF9zdGFydF9kYXRlXCJcblxuZXh0ZXJuYWwgZ2V0X2V4cGlyYXRpb25fZGF0ZSA6XG4gICBjZXJ0aWZpY2F0ZVxuICAtPiBVbml4LnRtXG4gID0gXCJvY2FtbF9zc2xfZ2V0X2V4cGlyYXRpb25fZGF0ZVwiXG5cbmV4dGVybmFsIGZpbGVfZGVzY3Jfb2Zfc29ja2V0IDpcbiAgIHNvY2tldFxuICAtPiBVbml4LmZpbGVfZGVzY3JcbiAgPSBcIm9jYW1sX3NzbF9nZXRfZmlsZV9kZXNjclwiXG5cbmV4dGVybmFsIHNldF9jbGllbnRfU05JX2hvc3RuYW1lIDpcbiAgIHNvY2tldFxuICAtPiBzdHJpbmdcbiAgLT4gdW5pdFxuICA9IFwib2NhbWxfc3NsX3NldF9jbGllbnRfU05JX2hvc3RuYW1lXCJcblxuZXh0ZXJuYWwgc2V0X2FscG5fcHJvdG9zIDpcbiAgIHNvY2tldFxuICAtPiBzdHJpbmcgbGlzdFxuICAtPiB1bml0XG4gID0gXCJvY2FtbF9zc2xfc2V0X2FscG5fcHJvdG9zXCJcblxuZXh0ZXJuYWwgZ2V0X25lZ290aWF0ZWRfYWxwbl9wcm90b2NvbCA6XG4gICBzb2NrZXRcbiAgLT4gc3RyaW5nIG9wdGlvblxuICA9IFwib2NhbWxfc3NsX2dldF9uZWdvdGlhdGVkX2FscG5fcHJvdG9jb2xcIlxuXG5leHRlcm5hbCB2ZXJpZnkgOiBzb2NrZXQgLT4gdW5pdCA9IFwib2NhbWxfc3NsX3ZlcmlmeVwiXG5cbnR5cGUgeDUwOV9jaGVja19mbGFnID1cbiAgfCBBbHdheXNfY2hlY2tfc3ViamVjdFxuICB8IE5vX3dpbGRjYXJkc1xuICB8IE5vX3BhcnRpYWxfd2lsZGNhcmRzXG4gIHwgTXVsdGlfbGFiZWxfd2lsZGNhcmRzXG4gIHwgU2luZ2xlX2xhYmVsX3N1YmRvbWFpbnNcblxuZXh0ZXJuYWwgc2V0X2hvc3RmbGFncyA6XG4gICBzb2NrZXRcbiAgLT4geDUwOV9jaGVja19mbGFnIGxpc3RcbiAgLT4gdW5pdFxuICA9IFwib2NhbWxfc3NsX3NldF9ob3N0ZmxhZ3NcIlxuXG5leHRlcm5hbCBzZXRfaG9zdCA6IHNvY2tldCAtPiBzdHJpbmcgLT4gdW5pdCA9IFwib2NhbWxfc3NsX3NldDFfaG9zdFwiXG5leHRlcm5hbCBzZXRfaXAgOiBzb2NrZXQgLT4gc3RyaW5nIC0+IHVuaXQgPSBcIm9jYW1sX3NzbF9zZXQxX2lwXCJcblxuKCogSGVyZSBpcyB0aGUgc2lnbmF0dXJlIG9mIHRoZSBiYXNlIGNvbW11bmljYXRpb24gZnVuY3Rpb25zIHRoYXQgYXJlXG4gICBpbXBsZW1lbnRlZCBiZWxvdyBpbiB0d28gdmVyc2lvbnMgKilcbm1vZHVsZSB0eXBlIFNzbF9iYXNlID0gc2lnXG4gIHZhbCBjb25uZWN0IDogc29ja2V0IC0+IHVuaXRcbiAgdmFsIGFjY2VwdCA6IHNvY2tldCAtPiB1bml0XG4gIHZhbCBzc2xfc2h1dGRvd24gOiBzb2NrZXQgLT4gYm9vbFxuICB2YWwgZmx1c2ggOiBzb2NrZXQgLT4gdW5pdFxuICB2YWwgcmVhZCA6IHNvY2tldCAtPiBCeXRlcy50IC0+IGludCAtPiBpbnQgLT4gaW50XG4gIHZhbCByZWFkX2ludG9fYmlnYXJyYXkgOiBzb2NrZXQgLT4gYmlnYXJyYXkgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgdmFsIHdyaXRlIDogc29ja2V0IC0+IEJ5dGVzLnQgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgdmFsIHdyaXRlX3N1YnN0cmluZyA6IHNvY2tldCAtPiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgdmFsIHdyaXRlX2JpZ2FycmF5IDogc29ja2V0IC0+IGJpZ2FycmF5IC0+IGludCAtPiBpbnQgLT4gaW50XG5lbmRcblxuKCogUHJvdmlkZSB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBjb21tdW5pY2F0aW9uIGZ1bmN0aW9ucyB0aGF0IHJlbGVhc2UgdGhlXG4gICBPQ2FtbCBydW50aW1lIGxvY2ssIGFsbG93aW5nIG11bHRpcGxlIHN5c3RocmVhZHMgdG8gZXhlY3V0ZSBjb25jdXJyZW50bHkuICopXG5tb2R1bGUgUnVudGltZV91bmxvY2tfYmFzZSA9IHN0cnVjdFxuICBleHRlcm5hbCBjb25uZWN0IDogc29ja2V0IC0+IHVuaXQgPSBcIm9jYW1sX3NzbF9jb25uZWN0XCJcbiAgZXh0ZXJuYWwgYWNjZXB0IDogc29ja2V0IC0+IHVuaXQgPSBcIm9jYW1sX3NzbF9hY2NlcHRcIlxuICBleHRlcm5hbCB3cml0ZSA6IHNvY2tldCAtPiBCeXRlcy50IC0+IGludCAtPiBpbnQgLT4gaW50ID0gXCJvY2FtbF9zc2xfd3JpdGVcIlxuXG4gIGV4dGVybmFsIHdyaXRlX3N1YnN0cmluZyA6XG4gICAgIHNvY2tldFxuICAgIC0+IHN0cmluZ1xuICAgIC0+IGludFxuICAgIC0+IGludFxuICAgIC0+IGludFxuICAgID0gXCJvY2FtbF9zc2xfd3JpdGVcIlxuXG4gIGV4dGVybmFsIHdyaXRlX2JpZ2FycmF5IDpcbiAgICAgc29ja2V0XG4gICAgLT4gYmlnYXJyYXlcbiAgICAtPiBpbnRcbiAgICAtPiBpbnRcbiAgICAtPiBpbnRcbiAgICA9IFwib2NhbWxfc3NsX3dyaXRlX2JpZ2FycmF5XCJcblxuICBleHRlcm5hbCByZWFkIDogc29ja2V0IC0+IEJ5dGVzLnQgLT4gaW50IC0+IGludCAtPiBpbnQgPSBcIm9jYW1sX3NzbF9yZWFkXCJcblxuICBleHRlcm5hbCByZWFkX2ludG9fYmlnYXJyYXkgOlxuICAgICBzb2NrZXRcbiAgICAtPiBiaWdhcnJheVxuICAgIC0+IGludFxuICAgIC0+IGludFxuICAgIC0+IGludFxuICAgID0gXCJvY2FtbF9zc2xfcmVhZF9pbnRvX2JpZ2FycmF5XCJcblxuICBleHRlcm5hbCBmbHVzaCA6IHNvY2tldCAtPiB1bml0ID0gXCJvY2FtbF9zc2xfZmx1c2hcIlxuICBleHRlcm5hbCBzc2xfc2h1dGRvd24gOiBzb2NrZXQgLT4gYm9vbCA9IFwib2NhbWxfc3NsX3NodXRkb3duXCJcbmVuZFxuXG4oKiBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCByZWxlYXNlIHRoZSBsb2NrLiAqKVxubW9kdWxlIFJ1bnRpbWVfbG9ja19iYXNlID0gc3RydWN0XG4gIGV4dGVybmFsIGdldF9lcnJvciA6IHNvY2tldCAtPiBpbnQgLT4gc3NsX2Vycm9yID0gXCJvY2FtbF9zc2xfZ2V0X2Vycm9yX2NvZGVcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY29ubmVjdCA6IHNvY2tldCAtPiBpbnQgPSBcIm9jYW1sX3NzbF9jb25uZWN0X2Jsb2NraW5nXCIgW0BAbm9hbGxvY11cblxuICBsZXQgY29ubmVjdCBzb2NrZXQgPVxuICAgIGxldCByZXQgPSBjb25uZWN0IHNvY2tldCBpblxuICAgICgqIEZyb20gaHR0cHM6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9tYW4xLjEuMS9tYW4zL1NTTF9jb25uZWN0Lmh0bWw6XG5cbiAgICAgICBSRVRVUk4gVkFMVUVTXG5cbiAgICAgICAwIFRoZSBUTFMvU1NMIGhhbmRzaGFrZSB3YXMgbm90IHN1Y2Nlc3NmdWwgWy4uLl0uIENhbGwgU1NMX2dldF9lcnJvcigpXG4gICAgICAgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIHJldCB0byBmaW5kIG91dCB0aGUgcmVhc29uLlxuXG4gICAgICAgMSBUaGUgVExTL1NTTCBoYW5kc2hha2Ugd2FzIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgWy4uLl0uXG5cbiAgICAgICA8MCBUaGUgVExTL1NTTCBoYW5kc2hha2Ugd2FzIG5vdCBzdWNjZXNzZnVsIFsuLi5dLiBDYWxsIFNTTF9nZXRfZXJyb3IoKVxuICAgICAgIHdpdGggdGhlIHJldHVybiB2YWx1ZSByZXQgdG8gZmluZCBvdXQgdGhlIHJlYXNvbi4gKilcbiAgICBpZiByZXQgPD4gMVxuICAgIHRoZW5cbiAgICAgIGxldCBlcnIgPSBnZXRfZXJyb3Igc29ja2V0IHJldCBpblxuICAgICAgcmFpc2UgKENvbm5lY3Rpb25fZXJyb3IgZXJyKVxuXG4gIGV4dGVybmFsIGFjY2VwdCA6IHNvY2tldCAtPiBpbnQgPSBcIm9jYW1sX3NzbF9hY2NlcHRfYmxvY2tpbmdcIiBbQEBub2FsbG9jXVxuXG4gIGxldCBhY2NlcHQgc29ja2V0ID1cbiAgICBsZXQgcmV0ID0gYWNjZXB0IHNvY2tldCBpblxuICAgICgqIEZyb20gaHR0cHM6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9tYW4xLjEuMS9tYW4zL1NTTF9hY2NlcHQuaHRtbDpcblxuICAgICAgIFJFVFVSTiBWQUxVRVNcblxuICAgICAgIDAgVGhlIFRMUy9TU0wgaGFuZHNoYWtlIHdhcyBub3Qgc3VjY2Vzc2Z1bCBbLi4uXS4gQ2FsbCBTU0xfZ2V0X2Vycm9yKClcbiAgICAgICB3aXRoIHRoZSByZXR1cm4gdmFsdWUgcmV0IHRvIGZpbmQgb3V0IHRoZSByZWFzb24uXG5cbiAgICAgICAxIFRoZSBUTFMvU1NMIGhhbmRzaGFrZSB3YXMgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCBbLi4uXS5cblxuICAgICAgIDwwIFRoZSBUTFMvU1NMIGhhbmRzaGFrZSB3YXMgbm90IHN1Y2Nlc3NmdWwgWy4uLl0uIENhbGwgU1NMX2dldF9lcnJvcigpXG4gICAgICAgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIHJldCB0byBmaW5kIG91dCB0aGUgcmVhc29uLiAqKVxuICAgIGlmIHJldCA8PiAxXG4gICAgdGhlblxuICAgICAgbGV0IGVyciA9IGdldF9lcnJvciBzb2NrZXQgcmV0IGluXG4gICAgICByYWlzZSAoQWNjZXB0X2Vycm9yIGVycilcblxuICBleHRlcm5hbCB3cml0ZSA6XG4gICAgIHNvY2tldFxuICAgIC0+IEJ5dGVzLnRcbiAgICAtPiBpbnRcbiAgICAtPiBpbnRcbiAgICAtPiBpbnRcbiAgICA9IFwib2NhbWxfc3NsX3dyaXRlX2Jsb2NraW5nXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGxldCB3cml0ZSBzb2NrZXQgYnVmZmVyIHN0YXJ0IGxlbmd0aCA9XG4gICAgaWYgc3RhcnQgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJTc2wud3JpdGU6IHN0YXJ0IG5lZ2F0aXZlXCI7XG4gICAgaWYgbGVuZ3RoIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU3NsLndyaXRlOiBsZW5ndGggbmVnYXRpdmVcIjtcbiAgICBpZiBzdGFydCArIGxlbmd0aCA+IEJ5dGVzLmxlbmd0aCBidWZmZXJcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiU3NsLndyaXRlOiBCdWZmZXIgdG9vIHNob3J0XCI7XG4gICAgbGV0IHJldCA9IHdyaXRlIHNvY2tldCBidWZmZXIgc3RhcnQgbGVuZ3RoIGluXG4gICAgKCogRnJvbSBodHRwczovL3d3dy5vcGVuc3NsLm9yZy9kb2NzL21hbjEuMS4xL21hbjMvU1NMX3dyaXRlLmh0bWw6XG5cbiAgICAgICBSRVRVUk4gVkFMVUVTXG5cbiAgICAgICA+IDAgVGhlIHdyaXRlIG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bCwgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGUgbnVtYmVyIG9mXG4gICAgICAgYnl0ZXMgYWN0dWFsbHkgd3JpdHRlbiB0byB0aGUgVExTL1NTTCBjb25uZWN0aW9uLlxuXG4gICAgICAgPD0gMCBUaGUgd3JpdGUgb3BlcmF0aW9uIHdhcyBub3Qgc3VjY2Vzc2Z1bCBbLi4uXS4gQ2FsbCBTU0xfZ2V0X2Vycm9yKClcbiAgICAgICB3aXRoIHRoZSByZXR1cm4gdmFsdWUgcmV0IHRvIGZpbmQgb3V0IHRoZSByZWFzb24uICopXG4gICAgKGlmIHJldCA8PSAwXG4gICAgIHRoZW5cbiAgICAgICBsZXQgZXJyID0gZ2V0X2Vycm9yIHNvY2tldCByZXQgaW5cbiAgICAgICByYWlzZSAoV3JpdGVfZXJyb3IgZXJyKSk7XG4gICAgcmV0XG5cbiAgZXh0ZXJuYWwgd3JpdGVfc3Vic3RyaW5nIDpcbiAgICAgc29ja2V0XG4gICAgLT4gc3RyaW5nXG4gICAgLT4gaW50XG4gICAgLT4gaW50XG4gICAgLT4gaW50XG4gICAgPSBcIm9jYW1sX3NzbF93cml0ZV9ibG9ja2luZ1wiXG4gICAgW0BAbm9hbGxvY11cblxuICBsZXQgd3JpdGVfc3Vic3RyaW5nIHNvY2tldCBidWZmZXIgc3RhcnQgbGVuZ3RoID1cbiAgICBpZiBzdGFydCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNzbC53cml0ZV9zdWJzdHJpbmc6IHN0YXJ0IG5lZ2F0aXZlXCI7XG4gICAgaWYgbGVuZ3RoIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU3NsLndyaXRlX3N1YnN0cmluZzogbGVuZ3RoIG5lZ2F0aXZlXCI7XG4gICAgaWYgc3RhcnQgKyBsZW5ndGggPiBTdHJpbmcubGVuZ3RoIGJ1ZmZlclxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJTc2wud3JpdGVfc3Vic3RyaW5nOiBCdWZmZXIgdG9vIHNob3J0XCI7XG4gICAgbGV0IHJldCA9IHdyaXRlX3N1YnN0cmluZyBzb2NrZXQgYnVmZmVyIHN0YXJ0IGxlbmd0aCBpblxuICAgIChpZiByZXQgPD0gMFxuICAgICB0aGVuXG4gICAgICAgbGV0IGVyciA9IGdldF9lcnJvciBzb2NrZXQgcmV0IGluXG4gICAgICAgcmFpc2UgKFdyaXRlX2Vycm9yIGVycikpO1xuICAgIHJldFxuXG4gIGV4dGVybmFsIHdyaXRlX2JpZ2FycmF5IDpcbiAgICAgc29ja2V0XG4gICAgLT4gYmlnYXJyYXlcbiAgICAtPiBpbnRcbiAgICAtPiBpbnRcbiAgICAtPiBpbnRcbiAgICA9IFwib2NhbWxfc3NsX3dyaXRlX2JpZ2FycmF5X2Jsb2NraW5nXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGxldCB3cml0ZV9iaWdhcnJheSBzb2NrZXQgYnVmZmVyIHN0YXJ0IGxlbmd0aCA9XG4gICAgaWYgc3RhcnQgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJTc2wud3JpdGVfYmlnYXJyYXk6IHN0YXJ0IG5lZ2F0aXZlXCI7XG4gICAgaWYgbGVuZ3RoIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU3NsLndyaXRlX2JpZ2FycmF5OiBsZW5ndGggbmVnYXRpdmVcIjtcbiAgICBpZiBzdGFydCArIGxlbmd0aCA+IEJpZ2FycmF5LkFycmF5MS5kaW0gYnVmZmVyXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlNzbC53cml0ZV9iaWdhcnJheTogQnVmZmVyIHRvbyBzaG9ydFwiO1xuICAgIGxldCByZXQgPSB3cml0ZV9iaWdhcnJheSBzb2NrZXQgYnVmZmVyIHN0YXJ0IGxlbmd0aCBpblxuICAgIChpZiByZXQgPD0gMFxuICAgICB0aGVuXG4gICAgICAgbGV0IGVyciA9IGdldF9lcnJvciBzb2NrZXQgcmV0IGluXG4gICAgICAgcmFpc2UgKFdyaXRlX2Vycm9yIGVycikpO1xuICAgIHJldFxuXG4gIGV4dGVybmFsIHJlYWQgOlxuICAgICBzb2NrZXRcbiAgICAtPiBCeXRlcy50XG4gICAgLT4gaW50XG4gICAgLT4gaW50XG4gICAgLT4gaW50XG4gICAgPSBcIm9jYW1sX3NzbF9yZWFkX2Jsb2NraW5nXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGxldCByZWFkIHNvY2tldCBidWZmZXIgc3RhcnQgbGVuZ3RoID1cbiAgICBpZiBzdGFydCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNzbC5yZWFkOiBzdGFydCBuZWdhdGl2ZVwiO1xuICAgIGlmIGxlbmd0aCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNzbC5yZWFkOiBsZW5ndGggbmVnYXRpdmVcIjtcbiAgICBpZiBzdGFydCArIGxlbmd0aCA+IEJ5dGVzLmxlbmd0aCBidWZmZXIgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlciB0b28gc2hvcnRcIjtcbiAgICBsZXQgcmV0ID0gcmVhZCBzb2NrZXQgYnVmZmVyIHN0YXJ0IGxlbmd0aCBpblxuICAgICgqIEZyb20gaHR0cHM6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9tYW4xLjEuMS9tYW4zL1NTTF9yZWFkLmh0bWxcblxuICAgICAgIFJFVFVSTiBWQUxVRVNcblxuICAgICAgID4gMCBUaGUgcmVhZCBvcGVyYXRpb24gd2FzIHN1Y2Nlc3NmdWwuIFRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIG51bWJlciBvZlxuICAgICAgIGJ5dGVzIGFjdHVhbGx5IHJlYWQgZnJvbSB0aGUgVExTL1NTTCBjb25uZWN0aW9uLlxuXG4gICAgICAgPD0gMCBUaGUgcmVhZCBvcGVyYXRpb24gd2FzIG5vdCBzdWNjZXNzZnVsIFsuLi5dLiBDYWxsIFNTTF9nZXRfZXJyb3IoMylcbiAgICAgICB3aXRoIHRoZSByZXR1cm4gdmFsdWUgcmV0IHRvIGZpbmQgb3V0IHRoZSByZWFzb24uICopXG4gICAgKGlmIHJldCA8PSAwXG4gICAgIHRoZW5cbiAgICAgICBsZXQgZXJyID0gZ2V0X2Vycm9yIHNvY2tldCByZXQgaW5cbiAgICAgICByYWlzZSAoUmVhZF9lcnJvciBlcnIpKTtcbiAgICByZXRcblxuICBleHRlcm5hbCByZWFkX2ludG9fYmlnYXJyYXkgOlxuICAgICBzb2NrZXRcbiAgICAtPiBiaWdhcnJheVxuICAgIC0+IGludFxuICAgIC0+IGludFxuICAgIC0+IGludFxuICAgID0gXCJvY2FtbF9zc2xfcmVhZF9pbnRvX2JpZ2FycmF5X2Jsb2NraW5nXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGxldCByZWFkX2ludG9fYmlnYXJyYXkgc29ja2V0IGJ1ZmZlciBzdGFydCBsZW5ndGggPVxuICAgIGlmIHN0YXJ0IDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU3NsLnJlYWRfaW50b19iaWdfYXJyYXk6IHN0YXJ0IG5lZ2F0aXZlXCI7XG4gICAgaWYgbGVuZ3RoIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU3NsLnJlYWRfaW50b19iaWdfYXJyYXk6IGxlbmd0aCBuZWdhdGl2ZVwiO1xuICAgIGlmIHN0YXJ0ICsgbGVuZ3RoID4gQmlnYXJyYXkuQXJyYXkxLmRpbSBidWZmZXJcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyIHRvbyBzaG9ydFwiO1xuICAgIGxldCByZXQgPSByZWFkX2ludG9fYmlnYXJyYXkgc29ja2V0IGJ1ZmZlciBzdGFydCBsZW5ndGggaW5cbiAgICAoaWYgcmV0IDw9IDBcbiAgICAgdGhlblxuICAgICAgIGxldCBlcnIgPSBnZXRfZXJyb3Igc29ja2V0IHJldCBpblxuICAgICAgIHJhaXNlIChSZWFkX2Vycm9yIGVycikpO1xuICAgIHJldFxuXG4gIGV4dGVybmFsIGZsdXNoIDogc29ja2V0IC0+IGludCA9IFwib2NhbWxfc3NsX2ZsdXNoX2Jsb2NraW5nXCIgW0BAbm9hbGxvY11cblxuICBsZXQgZmx1c2ggc29ja2V0ID1cbiAgICBsZXQgcmV0ID0gZmx1c2ggc29ja2V0IGluXG4gICAgKCogRnJvbSBodHRwczovL3d3dy5vcGVuc3NsLm9yZy9kb2NzL21hbjEuMS4xL21hbjMvQklPX2ZsdXNoLmh0bWw6XG5cbiAgICAgICBSRVRVUk4gVkFMVUVTXG5cbiAgICAgICBCSU9fZmx1c2goKSByZXR1cm5zIDEgZm9yIHN1Y2Nlc3MgYW5kIDAgb3IgLTEgZm9yIGZhaWx1cmUuXG5cbiAgICAgICBBZGRpdGlvbmFsbHksIHdlIHVzZSAtMiB0byBzaWduYWwgdGhlIG5lZWQgdG8gcmV0cnkgd2l0aG91dCBhbGxvY2F0aW9uLFxuICAgICAgIHNlZSBbc3NsX3N0dWJzLmNdLiAqKVxuICAgIGlmIHJldCA8PiAxIHRoZW4gcmFpc2UgKEZsdXNoX2Vycm9yIChyZXQgPSAtMikpXG5cbiAgZXh0ZXJuYWwgc3NsX3NodXRkb3duIDogc29ja2V0IC0+IGludCA9IFwib2NhbWxfc3NsX3NodXRkb3duX2Jsb2NraW5nXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGxldCBzc2xfc2h1dGRvd24gc29ja2V0ID1cbiAgICBsZXQgcmV0ID0gc3NsX3NodXRkb3duIHNvY2tldCBpblxuICAgIChpZiByZXQgPCAwXG4gICAgIHRoZW5cbiAgICAgICBsZXQgZXJyID0gZ2V0X2Vycm9yIHNvY2tldCByZXQgaW5cbiAgICAgICByYWlzZSAoQ29ubmVjdGlvbl9lcnJvciBlcnIpKTtcbiAgICByZXQgPSAxXG5lbmRcblxuKCogVGhlIGZ1bmN0b3IgaW1wbGVtZW50aW5nIGNvbW11bmljYXRpb24gZnVuY3Rpb25zIGZyb20gYSBzdHJ1Y3R1cmUgb2YgdHlwZVxuICAgU3NsX2Jhc2UgKilcbm1vZHVsZSBNYWtlIChTc2xfYmFzZSA6IFNzbF9iYXNlKSA9IHN0cnVjdFxuICBpbmNsdWRlIFNzbF9iYXNlXG5cbiAgbGV0IG9wZW5fY29ubmVjdGlvbl93aXRoX2NvbnRleHQgY29udGV4dCBzb2NrYWRkciA9XG4gICAgbGV0IGRvbWFpbiA9IFVuaXguZG9tYWluX29mX3NvY2thZGRyIHNvY2thZGRyIGluXG4gICAgbGV0IHNvY2sgPSBVbml4LnNvY2tldCBkb21haW4gVW5peC5TT0NLX1NUUkVBTSAwIGluXG4gICAgdHJ5XG4gICAgICBVbml4LmNvbm5lY3Qgc29jayBzb2NrYWRkcjtcbiAgICAgIGxldCBzc2wgPSBlbWJlZF9zb2NrZXQgc29jayBjb250ZXh0IGluXG4gICAgICBjb25uZWN0IHNzbDtcbiAgICAgIHNzbFxuICAgIHdpdGhcbiAgICB8IGV4biAtPlxuICAgICAgVW5peC5jbG9zZSBzb2NrO1xuICAgICAgcmFpc2UgZXhuXG5cbiAgbGV0IG9wZW5fY29ubmVjdGlvbiBzc2xfbWV0aG9kIHNvY2thZGRyID1cbiAgICBvcGVuX2Nvbm5lY3Rpb25fd2l0aF9jb250ZXh0XG4gICAgICAoY3JlYXRlX2NvbnRleHQgc3NsX21ldGhvZCBDbGllbnRfY29udGV4dClcbiAgICAgIHNvY2thZGRyXG5cbiAgbGV0IGNsb3NlX25vdGlmeSA9IHNzbF9zaHV0ZG93blxuXG4gIGxldCBzaHV0ZG93biBzb2NrID1cbiAgICBpZiBub3QgKGNsb3NlX25vdGlmeSBzb2NrKSB0aGVuIGlnbm9yZSAoY2xvc2Vfbm90aWZ5IHNvY2sgOiBib29sKVxuXG4gIGxldCBzaHV0ZG93bl9jb25uZWN0aW9uID0gc2h1dGRvd25cblxuICBsZXQgb3V0cHV0X3N0cmluZyBzc2wgcyA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCB0b193cml0ZSA9IHJlZiBsZW4gaW5cbiAgICBsZXQgb2Zmc2V0ID0gcmVmIDAgaW5cbiAgICB3aGlsZSAhdG9fd3JpdGUgPiAwIGRvXG4gICAgICBsZXQgd3JpdHRlbiA9IHdyaXRlX3N1YnN0cmluZyBzc2wgcyAhb2Zmc2V0ICF0b193cml0ZSBpblxuICAgICAgaWYgd3JpdHRlbiA8PSAwIHRoZW4gZmFpbHdpdGggXCJvdXRwdXRfc3RyaW5nIGZhaWxlZCB0byB3cml0ZVwiO1xuICAgICAgdG9fd3JpdGUgOj0gIXRvX3dyaXRlIC0gd3JpdHRlbjtcbiAgICAgIG9mZnNldCA6PSAhb2Zmc2V0ICsgd3JpdHRlblxuICAgIGRvbmVcblxuICBsZXQgb3V0cHV0X2NoYXIgc3NsIGMgPVxuICAgIGxldCB0bXAgPSBTdHJpbmcubWFrZSAxIGMgaW5cbiAgICBsZXQgd3JpdHRlbiA9IHdyaXRlX3N1YnN0cmluZyBzc2wgdG1wIDAgMSBpblxuICAgIGlmIHdyaXR0ZW4gPD0gMCB0aGVuIGZhaWx3aXRoIFwib3V0cHV0X2NoYXIgZmFpbGVkIHRvIHdyaXRlXCJcblxuICBsZXQgb3V0cHV0X2ludCBzc2wgaSA9XG4gICAgbGV0IHRtcCA9IEJ5dGVzLmNyZWF0ZSA0IGluXG4gICAgQnl0ZXMuc2V0IHRtcCAwIChjaGFyX29mX2ludCAoaSBsc3IgMjQpKTtcbiAgICBCeXRlcy5zZXQgdG1wIDEgKGNoYXJfb2ZfaW50ICgoaSBsc3IgMTYpIGxhbmQgMHhmZikpO1xuICAgIEJ5dGVzLnNldCB0bXAgMiAoY2hhcl9vZl9pbnQgKChpIGxzciA4KSBsYW5kIDB4ZmYpKTtcbiAgICBCeXRlcy5zZXQgdG1wIDMgKGNoYXJfb2ZfaW50IChpIGxhbmQgMHhmZikpO1xuICAgIGlmIHdyaXRlIHNzbCB0bXAgMCA0IDw+IDRcbiAgICB0aGVuIGZhaWx3aXRoIFwib3V0cHV0X2ludCBlcnJvcjogYWxsIHRoZSBieXRlIHdlcmUgbm90IHNlbnRcIlxuXG4gIGxldCBpbnB1dF9zdHJpbmcgc3NsID1cbiAgICBsZXQgYnVmc2l6ZSA9IDEwMjQgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGJ1ZnNpemUgaW5cbiAgICBsZXQgcmV0ID0gcmVmIFwiXCIgaW5cbiAgICBsZXQgciA9IHJlZiAxIGluXG4gICAgd2hpbGUgIXIgPD4gMCBkb1xuICAgICAgciA6PSByZWFkIHNzbCBidWYgMCBidWZzaXplO1xuICAgICAgcmV0IDo9ICFyZXQgXiBCeXRlcy5zdWJfc3RyaW5nIGJ1ZiAwICFyXG4gICAgZG9uZTtcbiAgICAhcmV0XG5cbiAgbGV0IGlucHV0X2NoYXIgc3NsID1cbiAgICBsZXQgdG1wID0gQnl0ZXMuY3JlYXRlIDEgaW5cbiAgICBpZiByZWFkIHNzbCB0bXAgMCAxIDw+IDEgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlIEJ5dGVzLmdldCB0bXAgMFxuXG4gIGxldCBpbnB1dF9pbnQgc3NsID1cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IHRtcCA9IEJ5dGVzLmNyZWF0ZSA0IGluXG4gICAgbGV0IHJlYWQgPSByZWFkIHNzbCB0bXAgMCA0IGluXG4gICAgaWYgcmVhZCA8IDQgdGhlbiBmYWlsd2l0aCBcImlucHV0X2ludCBmYWlsZWQgdG8gcmVhZCA0IGJ5dGVzXCI7XG4gICAgaSA6PSBpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IHRtcCAwKTtcbiAgICBpIDo9ICghaSBsc2wgOCkgKyBpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IHRtcCAxKTtcbiAgICBpIDo9ICghaSBsc2wgOCkgKyBpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IHRtcCAyKTtcbiAgICBpIDo9ICghaSBsc2wgOCkgKyBpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IHRtcCAzKTtcbiAgICAhaVxuZW5kXG5cbigqIFdlIGFwcGx5IHRoZSBmdW5jdG9yIHR3aWNlLiBUaGUgcmVsZWFzaW5nIGZ1bmN0aW9ucyBhcmUgaW1wb3J0ZWQgYXNcbiAgIGRlZmF1bHQgKilcbmluY2x1ZGUgTWFrZSAoUnVudGltZV91bmxvY2tfYmFzZSlcbm1vZHVsZSBSdW50aW1lX2xvY2sgPSBNYWtlIChSdW50aW1lX2xvY2tfYmFzZSlcblxuKCoqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGZvciBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgdmVyc2lvbiAqKVxubGV0IHJlYWRfaW50b19iaWdhcnJheV9ibG9ja2luZyA6IHNvY2tldCAtPiBiaWdhcnJheSAtPiBpbnQgLT4gaW50IC0+IGludCA9XG4gIFJ1bnRpbWVfbG9jay5yZWFkX2ludG9fYmlnYXJyYXlcblxubGV0IHdyaXRlX2JpZ2FycmF5X2Jsb2NraW5nIDogc29ja2V0IC0+IGJpZ2FycmF5IC0+IGludCAtPiBpbnQgLT4gaW50ID1cbiAgUnVudGltZV9sb2NrLndyaXRlX2JpZ2FycmF5XG4iLCIoKiBDb3B5cmlnaHQgKEMpIDIwMDMtMjAwNSBTYW11ZWwgTWltcmFtXG5cbiAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE9jYW1sLXNzbC5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXQgdW5kZXJcbiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZVxuICAgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTU1xuICAgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZVxuICAgZGV0YWlscy5cblxuICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBJbmMuLFxuICAgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBICopXG5cbmxldCBpbml0ICgpID0gU3NsLnRocmVhZF9zYWZlIDo9IHRydWVcbiJdfQ==
