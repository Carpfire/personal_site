// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Dream_websocketaf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dream_websocketaf = [0];
   runtime.caml_register_global(0, Dream_websocketaf, "Dream_websocketaf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Optional_thunk
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    cst_Optional_thunk_this_functi =
      "Optional_thunk: this function is not representable as a some value";
   function none(param){return 0;}
   function some(f){
    if(f === none) caml_call1(Stdlib[2], cst_Optional_thunk_this_functi);
    return f;
   }
   function is_none(t){return t === none ? 1 : 0;}
   function is_some(t){return 1 - is_none(t);}
   function call_if_some(t){return caml_call1(t, 0);}
   function unchecked_value(t){return t;}
   var
    Dream_websocketaf_Optional_thu =
      [0, none, some, is_none, is_some, call_if_some, unchecked_value];
   runtime.caml_register_global
    (2, Dream_websocketaf_Optional_thu, "Dream_websocketaf__Optional_thunk");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Websocket
//# unitInfo: Requires: Bigstringaf, Stdlib, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Bigstringaf = global_data.Bigstringaf,
    Stdlib = global_data.Stdlib,
    Stdlib_Format = global_data.Stdlib__Format,
    cst_Close_code_of_bigstring_ex =
      "Close_code.of_bigstring_exn: can't read 2 bytes from bigstring",
    cst_Close_code_of_code_exn_val =
      "Close_code.of_code_exn: value can't fit in two bytes",
    cst_Close_code_of_code_exn_val$0 =
      "Close_code.of_code_exn: value in invalid range 0-999",
    _b_ = [0, [4, 0, 0, 0, 0], "%d"],
    cst_Opcode_of_code_exn_value_c =
      "Opcode.of_code_exn: value can't fit in four bits",
    _a_ =
      [0,
       225667031,
       936573133,
       564146209,
       [0, -912009552, 3],
       [0, -912009552, 4],
       [0, -912009552, 5],
       [0, -912009552, 6],
       [0, -912009552, 7],
       915654071,
       892411538,
       892709912,
       [0, -912009552, 11],
       [0, -912009552, 12],
       [0, -912009552, 13],
       [0, -912009552, 14],
       [0, -912009552, 15]],
    _c_ =
      [0,
       -1037083581,
       -1047972493,
       122638209,
       885248340,
       [0, -912009552, 1004],
       -832751506,
       862413028,
       956323317,
       -718269448,
       60978301,
       -1065495525,
       -732353682,
       [0, -912009552, 1012],
       [0, -912009552, 1013],
       [0, -912009552, 1014],
       1072880723];
   function code(param){
    if(typeof param === "number")
     return 892411538 <= param
             ? 915654071
               <= param
               ? 936573133 <= param ? 1 : 8
               : 892709912 <= param ? 10 : 9
             : 564146209 <= param ? 2 : 0;
    var code = param[2];
    return code;
   }
   var code_table = _a_.slice();
   function unsafe_of_code(code){return code_table[1 + code];}
   function of_code(code){return 15 < code ? 0 : [0, code_table[1 + code]];}
   function of_code_exn(code){
    if(15 < code) caml_call1(Stdlib[2], cst_Opcode_of_code_exn_value_c);
    return code_table[1 + code];
   }
   function pp_hum(fmt, t){
    var _h_ = code(t);
    return caml_call3(Stdlib_Format[137], fmt, _b_, _h_);
   }
   var
    Opcode =
      [0,
       code,
       code_table,
       unsafe_of_code,
       of_code,
       of_code_exn,
       code,
       of_code,
       of_code_exn,
       pp_hum];
   function code$0(param){
    if(typeof param === "number")
     return 60978301 <= param
             ? 862413028
               <= param
               ? 956323317
                 <= param
                 ? 1072880723 <= param ? 1015 : 1007
                 : 885248340 <= param ? 1003 : 1006
               : 122638209 <= param ? 1002 : 1009
             : -1037083581
               <= param
               ? -732353682
                 <= param
                 ? -718269448 <= param ? 1008 : 1011
                 : -832751506 <= param ? 1005 : 1000
               : -1047972493 <= param ? 1001 : 1010;
    var code = param[2];
    return code;
   }
   var code_table$0 = _c_.slice();
   function unsafe_of_code$0(code){return code_table$0[1 + code];}
   function of_code$0(code){
    if(65535 >= code && 1000 <= code)
     return 1016 <= code
             ? [0, [0, -912009552, code]]
             : [0, unsafe_of_code$0(code & 15)];
    return 0;
   }
   function of_code_exn$0(code){
    if(65535 < code) caml_call1(Stdlib[2], cst_Close_code_of_code_exn_val);
    if(code < 1000) caml_call1(Stdlib[2], cst_Close_code_of_code_exn_val$0);
    return 1016 <= code ? [0, -912009552, code] : unsafe_of_code$0(code & 15);
   }
   function of_bigstring(bs, off){
    if(0 > ((caml_call1(Bigstringaf[6], bs) - off | 0) - 2 | 0)) return 0;
    var code_int = caml_call2(Bigstringaf[16], bs, off);
    return of_code$0(code_int);
   }
   function of_bigstring_exn(bs, off){
    if(0 > ((caml_call1(Bigstringaf[6], bs) - off | 0) - 2 | 0))
     return caml_call1(Stdlib[2], cst_Close_code_of_bigstring_ex);
    var code_int = caml_call2(Bigstringaf[16], bs, off);
    return of_code_exn$0(code_int);
   }
   var
    Close_code =
      [0,
       code$0,
       code_table$0,
       unsafe_of_code$0,
       of_code$0,
       of_code_exn$0,
       code$0,
       of_code$0,
       of_code_exn$0,
       of_bigstring,
       of_bigstring_exn];
   function apply_mask(mask, opt, src_off, len, bs){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var n = len[1], len$0 = n;
    else
     var len$0 = caml_call1(Bigstringaf[6], bs);
    var _f_ = (off + len$0 | 0) - 1 | 0;
    if(_f_ >= off){
     var i = off;
     for(;;){
      var
       j = ((i + src_off | 0) - off | 0) % 4 | 0,
       c = runtime.caml_ba_get_1(bs, i),
       c$0 = c ^ mask >> (8 * (3 - j | 0) | 0) & 255;
      runtime.caml_ba_set_1(bs, i, c$0);
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      var i = _g_;
     }
    }
    return 0;
   }
   function apply_mask_bytes(mask, bs, src_off, off, len){
    var _d_ = (off + len | 0) - 1 | 0;
    if(_d_ >= off){
     var i = off;
     for(;;){
      var
       j = ((i + src_off | 0) - off | 0) % 4 | 0,
       c = runtime.caml_bytes_unsafe_get(bs, i),
       c$0 = c ^ mask >> (8 * (3 - j | 0) | 0) & 255;
      runtime.caml_bytes_unsafe_set(bs, i, c$0);
      var _e_ = i + 1 | 0;
      if(_d_ === i) break;
      var i = _e_;
     }
    }
    return 0;
   }
   var
    Frame = [0, apply_mask, apply_mask_bytes],
    Dream_websocketaf_Websocket = [0, Opcode, Close_code, Frame];
   runtime.caml_register_global
    (12, Dream_websocketaf_Websocket, "Dream_websocketaf__Websocket");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Serialize
//# unitInfo: Requires: Dream_websocketaf__Websocket, Faraday
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_websocketaf_Websocket = global_data.Dream_websocketaf__Websocket,
    Faraday = global_data.Faraday;
   function serialize_headers(mask, faraday, is_fin, opcode, payload_length){
    var
     opcode$0 = caml_call1(Dream_websocketaf_Websocket[1][6], opcode),
     is_fin$0 = is_fin ? 128 : 0,
     is_mask = mask ? 128 : 0;
    caml_call2(Faraday[8], faraday, is_fin$0 | opcode$0);
    if(125 < payload_length)
     if(65535 < payload_length){
      caml_call2(Faraday[8], faraday, is_mask | 127);
      caml_call2
       (Faraday[9][4], faraday, runtime.caml_int64_of_int32(payload_length));
     }
     else{
      caml_call2(Faraday[8], faraday, is_mask | 126);
      caml_call2(Faraday[9][1], faraday, payload_length);
     }
    else
     caml_call2(Faraday[8], faraday, is_mask | payload_length);
    if(! mask) return 0;
    var mask$0 = mask[1];
    return caml_call2(Faraday[9][2], faraday, mask$0);
   }
   function serialize_control(mask, faraday, opcode){
    return serialize_headers(mask, faraday, 1, opcode, 0);
   }
   function schedule_serialize
   (mask, faraday, is_fin, opcode, payload, src_off, off, len){
    serialize_headers(mask, faraday, is_fin, opcode, len);
    if(mask){
     var mask$0 = mask[1];
     caml_call5
      (Dream_websocketaf_Websocket[3][1],
       mask$0,
       [0, off],
       src_off,
       [0, len],
       payload);
    }
    return caml_call4(Faraday[11], faraday, [0, off], [0, len], payload);
   }
   function serialize_bytes
   (mask, faraday, is_fin, opcode, payload, src_off, off, len){
    serialize_headers(mask, faraday, is_fin, opcode, len);
    if(mask){
     var mask$0 = mask[1];
     caml_call5
      (Dream_websocketaf_Websocket[3][2], mask$0, payload, src_off, off, len);
    }
    return caml_call4(Faraday[4], faraday, [0, off], [0, len], payload);
   }
   var
    Dream_websocketaf_Serialize =
      [0,
       serialize_headers,
       serialize_control,
       schedule_serialize,
       serialize_bytes];
   runtime.caml_register_global
    (2, Dream_websocketaf_Serialize, "Dream_websocketaf__Serialize");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Wsd
//# unitInfo: Requires: Dream_websocketaf__Optional_thunk, Dream_websocketaf__Serialize, Dream_websocketaf__Websocket, Faraday, Stdlib, Stdlib__Bytes
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Faraday = global_data.Faraday,
    Dream_websocketaf_Websocket = global_data.Dream_websocketaf__Websocket,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Dream_websocketaf_Serialize = global_data.Dream_websocketaf__Serialize,
    Dream_websocketaf_Optional_thu =
      global_data.Dream_websocketaf__Optional_thunk,
    Stdlib = global_data.Stdlib,
    _b_ = [0, -611285096, 0],
    _a_ = [0, 862413028],
    cst_on_wakeup_on_closed_writer = "on_wakeup on closed writer",
    cst_on_wakeup_only_one_callbac =
      "on_wakeup: only one callback can be registered at a time";
   function default_ready_to_write(param){return 0;}
   function create(error_handler, mode){
    var _e_ = Dream_websocketaf_Optional_thu[1];
    return [0, caml_call1(Faraday[1], 4096), mode, _e_, error_handler, 17724];
   }
   function mask(t){
    var match = t[2];
    if(typeof match === "number") return 0;
    var m = match[2];
    return [0, caml_call1(m, 0)];
   }
   function is_closed(t){return caml_call1(Faraday[20], t[1]);}
   function on_wakeup(t, k){
    return caml_call1(Faraday[20], t[1])
            ? caml_call1(Stdlib[2], cst_on_wakeup_on_closed_writer)
            : caml_call1
               (Dream_websocketaf_Optional_thu[4], t[3])
              ? caml_call1(Stdlib[2], cst_on_wakeup_only_one_callbac)
              : (t[3] = caml_call1(Dream_websocketaf_Optional_thu[2], k), 0);
   }
   function wakeup(t){
    var f = t[3];
    t[3] = Dream_websocketaf_Optional_thu[1];
    return caml_call1(Dream_websocketaf_Optional_thu[5], f);
   }
   function schedule(t, opt, kind, payload, off, len){
    if(opt) var sth = opt[1], is_fin = sth; else var is_fin = 1;
    var mask$0 = mask(t);
    caml_call8
     (Dream_websocketaf_Serialize[3],
      mask$0,
      t[1],
      is_fin,
      kind,
      payload,
      0,
      off,
      len);
    return wakeup(t);
   }
   function send_bytes(t, opt, kind, payload, off, len){
    if(opt) var sth = opt[1], is_fin = sth; else var is_fin = 1;
    var mask$0 = mask(t);
    caml_call8
     (Dream_websocketaf_Serialize[4],
      mask$0,
      t[1],
      is_fin,
      kind,
      payload,
      0,
      off,
      len);
    return wakeup(t);
   }
   function send_ping(application_data, t){
    if(application_data){
     var
      match = application_data[1],
      len = match[3],
      off = match[2],
      buffer = match[1],
      mask$0 = mask(t);
     caml_call8
      (Dream_websocketaf_Serialize[3],
       mask$0,
       t[1],
       1,
       892411538,
       buffer,
       0,
       off,
       len);
    }
    else
     caml_call3(Dream_websocketaf_Serialize[2], 0, t[1], 892411538);
    return wakeup(t);
   }
   function send_pong(application_data, t){
    if(application_data){
     var
      match = application_data[1],
      len = match[3],
      off = match[2],
      buffer = match[1],
      mask$0 = mask(t);
     caml_call8
      (Dream_websocketaf_Serialize[3],
       mask$0,
       t[1],
       1,
       892709912,
       buffer,
       0,
       off,
       len);
    }
    else
     caml_call3(Dream_websocketaf_Serialize[2], 0, t[1], 892709912);
    return wakeup(t);
   }
   function flushed(t, f){return caml_call2(Faraday[16], t[1], f);}
   function close(code, t){
    if(code){
     var
      code$0 = code[1],
      mask$0 = mask(t),
      payload = runtime.caml_create_bytes(2),
      _d_ = caml_call1(Dream_websocketaf_Websocket[2][6], code$0);
     caml_call3(Stdlib_Bytes[76], payload, 0, _d_);
     caml_call8
      (Dream_websocketaf_Serialize[4],
       mask$0,
       t[1],
       1,
       915654071,
       payload,
       0,
       0,
       2);
    }
    caml_call1(Faraday[19], t[1]);
    return wakeup(t);
   }
   function error_code(t){
    var error = t[5];
    return typeof error === "number" ? 0 : [0, error];
   }
   function report_error(t, error){
    if(typeof t[5] !== "number") return close(_a_, t);
    t[5] = error;
    var _c_ = 1 - is_closed(t);
    return _c_ ? caml_call2(t[4], t, error) : _c_;
   }
   function next(t){
    var match = caml_call1(Faraday[23], t[1]);
    if(typeof match === "number") return 73271853 <= match ? 73271853 : _b_;
    var iovecs = match[2];
    return [0, -477700929, iovecs];
   }
   function report_result(t, result){
    if(typeof result === "number") return close(0, t);
    var len = result[2];
    return caml_call2(Faraday[21], t[1], len);
   }
   var
    Dream_websocketaf_Wsd =
      [0,
       default_ready_to_write,
       create,
       mask,
       is_closed,
       on_wakeup,
       wakeup,
       schedule,
       send_bytes,
       send_ping,
       send_pong,
       flushed,
       close,
       error_code,
       report_error,
       next,
       report_result];
   runtime.caml_register_global
    (10, Dream_websocketaf_Wsd, "Dream_websocketaf__Wsd");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Handshake
//# unitInfo: Requires: Base64, Dream_httpaf___Httpaf, Stdlib, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_13 = "13",
    cst_connection$0 = "connection",
    cst_sec_websocket_key$2 = "sec-websocket-key",
    cst_sec_websocket_version$0 = "sec-websocket-version",
    cst_upgrade$1 = "upgrade",
    cst_websocket$0 = "websocket",
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Base64 = global_data.Base64,
    Stdlib = global_data.Stdlib,
    _i_ = [0, 0],
    cst_sec_websocket_key$1 = cst_sec_websocket_key$2,
    cst_Sec_Websocket_Accept = "Sec-Websocket-Accept",
    _f_ = [0, "Connection", cst_upgrade$1],
    _g_ = [0, "Upgrade", cst_websocket$0],
    _h_ = [1, "Didn't pass scrutiny"],
    cst_upgrade$0 = cst_upgrade$1,
    cst_sec_websocket_version = cst_sec_websocket_version$0,
    cst_sec_websocket_key$0 = cst_sec_websocket_key$2,
    cst_connection = cst_connection$0,
    cst_upgrade = cst_upgrade$1,
    cst_host = "host",
    cst_websocket = cst_websocket$0,
    _e_ = [0, 1],
    cst_258EAFA5_E914_47DA_95CA_C5 = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    _d_ = [0, 1],
    cst_sec_websocket_key = cst_sec_websocket_key$2,
    _a_ = [0, cst_sec_websocket_version$0, cst_13],
    _b_ = [0, cst_connection$0, cst_upgrade$1],
    _c_ = [0, cst_upgrade$1, cst_websocket$0];
   function create_request(nonce, headers, target){
    var
     nonce$0 = caml_call5(Base64[12], 0, 0, 0, 0, nonce),
     headers$0 =
       caml_call2
        (Dream_httpaf_Httpaf[4][8],
         headers,
         [0,
          _c_,
          [0, _b_, [0, _a_, [0, [0, cst_sec_websocket_key, nonce$0], 0]]]]);
    return caml_call4
            (Dream_httpaf_Httpaf[6][1], 0, [0, headers$0], 3546230, target);
   }
   function sec_websocket_key_proof(sha1, sec_websocket_key){
    var
     concatenation =
       caml_call2
        (Stdlib[28], sec_websocket_key, cst_258EAFA5_E914_47DA_95CA_C5),
     _w_ = caml_call1(sha1, concatenation);
    return caml_call5(Base64[12], _d_, 0, 0, 0, _w_);
   }
   function lower(c){if(65 <= c && 90 >= c) return c + 32 | 0; return c;}
   function equal(x, y){
    var
     len = caml_ml_string_length(x),
     _t_ = len === caml_ml_string_length(y) ? 1 : 0;
    if(_t_){
     var equal_so_far = [0, 1], i = [0, 0];
     for(;;){
      if(equal_so_far[1] && i[1] < len){
       var
        c1 = caml_string_unsafe_get(x, i[1]),
        c2 = caml_string_unsafe_get(y, i[1]),
        _u_ = lower(c2);
       equal_so_far[1] = lower(c1) === _u_ ? 1 : 0;
       i[1]++;
       continue;
      }
      var _v_ = equal_so_far[1];
      break;
     }
    }
    else
     var _v_ = _t_;
    return _v_;
   }
   var CI = [0, lower, equal];
   function passes_scrutiny(request_method, headers){
    try{
     var
      val =
        caml_call2
         (Dream_httpaf_Httpaf[4][14], headers, cst_sec_websocket_version),
      sec_websocket_key =
        caml_call2
         (Dream_httpaf_Httpaf[4][14], headers, cst_sec_websocket_key$0),
      connection =
        caml_call2(Dream_httpaf_Httpaf[4][14], headers, cst_connection),
      upgrade = caml_call2(Dream_httpaf_Httpaf[4][14], headers, cst_upgrade);
     caml_call2(Dream_httpaf_Httpaf[4][14], headers, cst_host);
    }
    catch(_s_){return 0;}
    if
     (typeof request_method === "number"
      &&
       3546230 === request_method
       && ! runtime.caml_string_notequal(val, cst_13)){
     var _k_ = caml_call2(CI[2], upgrade, cst_websocket);
     if(_k_){
      var
       _l_ = caml_call2(Stdlib_String[17], 44, connection),
       _m_ =
         function(v){
          var _r_ = caml_call1(Stdlib_String[24], v);
          return caml_call2(CI[2], _r_, cst_upgrade$0);
         },
       _n_ = caml_call2(Stdlib_List[34], _m_, _l_);
      if(_n_)
       try{
        var
         _p_ =
           16
            ===
             caml_ml_string_length
              (caml_call5(Base64[6], _e_, 0, 0, 0, sec_websocket_key))
            ? 1
            : 0;
        return _p_;
       }
       catch(_q_){var _o_ = 0;}
      else
       var _o_ = _n_;
     }
     else
      var _o_ = _k_;
     return _o_;
    }
    return 0;
   }
   function upgrade_headers(sha1, request_method, headers){
    if(! passes_scrutiny(request_method, headers)) return _h_;
    var
     sec_websocket_key =
       caml_call2
        (Dream_httpaf_Httpaf[4][14], headers, cst_sec_websocket_key$1),
     accept = sec_websocket_key_proof(sha1, sec_websocket_key),
     upgrade_headers =
       [0, _g_, [0, _f_, [0, [0, cst_Sec_Websocket_Accept, accept], 0]]];
    return [0, upgrade_headers];
   }
   function respond_with_upgrade(opt, sha1, reqd, upgrade_handler){
    if(opt)
     var sth = opt[1], headers = sth;
    else
     var headers = Dream_httpaf_Httpaf[4][1];
    var
     request = caml_call1(Dream_httpaf_Httpaf[9][1], reqd),
     match = upgrade_headers(sha1, request[1], request[4]);
    if(0 === match[0]){
     var
      upgrade_headers$0 = match[1],
      _j_ = caml_call2(Dream_httpaf_Httpaf[4][8], headers, upgrade_headers$0);
     caml_call3(Dream_httpaf_Httpaf[9][8], reqd, _j_, upgrade_handler);
     return _i_;
    }
    var msg = match[1];
    return [1, msg];
   }
   var
    Dream_websocketaf_Handshake =
      [0,
       create_request,
       sec_websocket_key_proof,
       CI,
       passes_scrutiny,
       upgrade_headers,
       respond_with_upgrade];
   runtime.caml_register_global
    (26, Dream_websocketaf_Handshake, "Dream_websocketaf__Handshake");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Client_handshake
//# unitInfo: Requires: Dream_httpaf___Httpaf, Dream_websocketaf__Handshake
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Dream_websocketaf_Handshake = global_data.Dream_websocketaf__Handshake,
    _a_ = [0, 1];
   function create(nonce, headers, error_handler, response_handler, target){
    var
     connection = caml_call2(Dream_httpaf_Httpaf[12][1], 0, 0),
     _b_ = caml_call3(Dream_websocketaf_Handshake[1], nonce, headers, target),
     body =
       caml_call5
        (Dream_httpaf_Httpaf[12][2],
         connection,
         _a_,
         _b_,
         error_handler,
         response_handler);
    return [0, connection, body];
   }
   function next_read_operation(t){
    return caml_call1(Dream_httpaf_Httpaf[12][3], t[1]);
   }
   function next_write_operation(t){
    return caml_call1(Dream_httpaf_Httpaf[12][6], t[1]);
   }
   function read(t){return caml_call1(Dream_httpaf_Httpaf[12][4], t[1]);}
   function yield_reader(t){
    return caml_call1(Dream_httpaf_Httpaf[12][8], t[1]);
   }
   function report_write_result(t){
    return caml_call1(Dream_httpaf_Httpaf[12][7], t[1]);
   }
   function yield_writer(t){
    return caml_call1(Dream_httpaf_Httpaf[12][9], t[1]);
   }
   function report_exn(t, exn){
    return caml_call2(Dream_httpaf_Httpaf[12][10], t[1], exn);
   }
   function is_closed(t){
    return caml_call1(Dream_httpaf_Httpaf[12][11], t[1]);
   }
   function close(t){
    caml_call1(Dream_httpaf_Httpaf[5][2][6], t[2]);
    return caml_call1(Dream_httpaf_Httpaf[12][12], t[1]);
   }
   var
    Dream_websocketaf_Client_hands =
      [0,
       create,
       next_read_operation,
       next_write_operation,
       read,
       yield_reader,
       report_write_result,
       yield_writer,
       report_exn,
       is_closed,
       close];
   runtime.caml_register_global
    (3, Dream_websocketaf_Client_hands, "Dream_websocketaf__Client_handshake");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Payload
//# unitInfo: Requires: Bigstringaf, Faraday, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Faraday = global_data.Faraday,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Bigstringaf = global_data.Bigstringaf,
    _a_ = [0, "src/vendor/websocketaf/lib/payload.ml", 80, 26],
    cst_Payload_schedule_read_read =
      "Payload.schedule_read: reader already scheduled";
   function default_on_eof(param){return 0;}
   function default_on_read(param, _f_, _e_){return 0;}
   function of_faraday(faraday){
    return [0, faraday, 0, default_on_eof, default_on_read];
   }
   function create(buffer){return of_faraday(caml_call1(Faraday[2], buffer));}
   function create_empty(param){
    var t = create(Bigstringaf[2]);
    caml_call1(Faraday[19], t[1]);
    return t;
   }
   var empty = create_empty(0);
   function is_closed(t){return caml_call1(Faraday[20], t[1]);}
   function unsafe_faraday(t){return t[1];}
   function do_execute_read$0(counter, t, on_eof, on_read){
    var match = caml_call1(Faraday[23], t[1]);
    if(typeof match === "number")
     return 73271853 <= match
             ? 0
             : (t
                [2]
               = 0,
               t[3] = default_on_eof,
               t[4] = default_on_read,
               caml_call1(on_eof, 0));
    var match$0 = match[2];
    if(! match$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var iovec = match$0[1];
    t[2] = 0;
    t[3] = default_on_eof;
    t[4] = default_on_read;
    var len = iovec[3], off = iovec[2], buffer = iovec[1];
    caml_call2(Faraday[21], t[1], len);
    caml_call3(on_read, buffer, off, len);
    if(counter >= 50) return caml_trampoline_return(execute_read$0, [0, t]);
    var counter$0 = counter + 1 | 0;
    return execute_read$0(counter$0, t);
   }
   function execute_read$0(counter, t){
    var _b_ = t[2];
    if(! _b_) return _b_;
    var _c_ = t[4], _d_ = t[3];
    if(counter >= 50)
     return caml_trampoline_return(do_execute_read$0, [0, t, _d_, _c_]);
    var counter$0 = counter + 1 | 0;
    return do_execute_read$0(counter$0, t, _d_, _c_);
   }
   function do_execute_read(t, on_eof, on_read){
    return caml_trampoline(do_execute_read$0(0, t, on_eof, on_read));
   }
   function execute_read(t){return caml_trampoline(execute_read$0(0, t));}
   function schedule_read(t, on_eof, on_read){
    if(t[2]) caml_call1(Stdlib[2], cst_Payload_schedule_read_read);
    if(1 - is_closed(t)){t[2] = 1; t[3] = on_eof; t[4] = on_read;}
    return do_execute_read(t, on_eof, on_read);
   }
   function is_read_scheduled(t){return t[2];}
   function close(t){caml_call1(Faraday[19], t[1]); return execute_read(t);}
   var
    Dream_websocketaf_Payload =
      [0,
       default_on_eof,
       default_on_read,
       of_faraday,
       create,
       create_empty,
       empty,
       is_closed,
       unsafe_faraday,
       do_execute_read,
       execute_read,
       schedule_read,
       is_read_scheduled,
       close];
   runtime.caml_register_global
    (6, Dream_websocketaf_Payload, "Dream_websocketaf__Payload");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Parse
//# unitInfo: Requires: Angstrom, Bigstringaf, Dream_websocketaf__Payload, Dream_websocketaf__Websocket, Faraday, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Angstrom = global_data.Angstrom,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Bigstringaf = global_data.Bigstringaf,
    Dream_websocketaf_Payload = global_data.Dream_websocketaf__Payload,
    Faraday = global_data.Faraday,
    Dream_websocketaf_Websocket = global_data.Dream_websocketaf__Websocket,
    cst_websocketaf_Reader_unable_ =
      "websocketaf.Reader.unable to start parser",
    _d_ = [0, "src/vendor/websocketaf/lib/parse.ml", 191, 13],
    cst_missing_payload_bytes = "missing payload bytes",
    cst_Frame_mask_exn_no_mask_pre = "Frame.mask_exn: no mask present";
   function is_fin(t){
    var bits = caml_ba_get_1(t[1], 0);
    return (bits & 128) === 128 ? 1 : 0;
   }
   function rsv(t){
    var bits = caml_ba_get_1(t[1], 0);
    return (bits >>> 4 | 0) & 7;
   }
   function opcode(t){
    var bits = caml_ba_get_1(t[1], 0);
    return caml_call1(Dream_websocketaf_Websocket[1][3], bits & 15);
   }
   function payload_length_of_headers(headers){
    var bits = caml_ba_get_1(headers, 1), length = bits & 127;
    return 126 === length
            ? caml_call2(Bigstringaf[31], headers, 2)
            : 127
              === length
              ? runtime.caml_int64_to_int32
                (caml_call2(Bigstringaf[41], headers, 2))
              : length;
   }
   function payload_length(t){return payload_length_of_headers(t[1]);}
   function has_mask(t){
    var bits = caml_ba_get_1(t[1], 1);
    return (bits & 128) === 128 ? 1 : 0;
   }
   function mask(t){
    if(! has_mask(t)) return 0;
    var
     bits = caml_ba_get_1(t[1], 1),
     _w_ =
       254 === bits
        ? caml_call2(Bigstringaf[37], t[1], 4)
        : 255
          === bits
          ? caml_call2(Bigstringaf[37], t[1], 10)
          : caml_call2(Bigstringaf[37], t[1], 2);
    return [0, _w_];
   }
   function mask_exn(t){
    var bits = caml_ba_get_1(t[1], 1);
    return 254 === bits
            ? caml_call2(Bigstringaf[37], t[1], 4)
            : 255
              === bits
              ? caml_call2(Bigstringaf[37], t[1], 10)
              : 127
                <= bits
                ? caml_call2(Bigstringaf[37], t[1], 2)
                : caml_call1(Stdlib[2], cst_Frame_mask_exn_no_mask_pre);
   }
   function length(t){
    var payload_length$0 = payload_length(t);
    return caml_call1(Bigstringaf[6], t[1]) + payload_length$0 | 0;
   }
   function payload_offset_of_bits(bits){
    var
     mask_offset = (bits & 128) >>> 5 | 0,
     length = bits & 127,
     length_offset = 126 <= length ? 2 << ((length & 1) << 2) : 0;
    return (2 + mask_offset | 0) + length_offset | 0;
   }
   function payload_offset(opt, bs){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    var bits = caml_ba_get_1(bs, off + 1 | 0);
    return payload_offset_of_bits(bits);
   }
   function _a_(headers_len){
    return caml_call2(Angstrom[72][1], headers_len, Bigstringaf[5]);
   }
   function _b_(bs, off, param){return payload_offset([0, off], bs);}
   var
    _c_ = caml_call2(Angstrom[72][5], 2, _b_),
    parse_headers = caml_call2(Angstrom[53], _c_, _a_);
   function payload_parser(t){
    function read_exact(src_off, n){
     if(0 === n) return caml_call1(Angstrom[51], 0);
     function _n_(param){
      if(param){
       var _o_ = caml_call1(Angstrom[52], cst_missing_payload_bytes);
       return caml_call2(Angstrom[58], Angstrom[50], _o_);
      }
      function _p_(m){
       var m$0 = caml_call2(Stdlib[16], m, n), n$0 = n - m$0 | 0;
       function _v_(param){return read_exact(src_off + m$0 | 0, n$0);}
       var payload = t[2], _q_ = Angstrom[50];
       if(caml_call1(Dream_websocketaf_Payload[7], payload))
        var _r_ = caml_call1(Angstrom[22], m$0);
       else
        var
         _t_ =
           function(bs){
            var
             faraday = caml_call1(Dream_websocketaf_Payload[8], payload),
             match = mask(t);
            if(match){
             var mask$0 = match[1];
             caml_call5
              (Dream_websocketaf_Websocket[3][1], mask$0, 0, src_off, 0, bs);
            }
            return caml_call4(Faraday[11], faraday, 0, 0, bs);
           },
         _u_ = caml_call1(Angstrom[17], m$0),
         _r_ = caml_call2(Angstrom[55], _u_, _t_);
       var _s_ = caml_call2(Angstrom[58], _r_, _q_);
       return caml_call2(Angstrom[53], _s_, _v_);
      }
      return caml_call2(Angstrom[53], Angstrom[79], _p_);
     }
     return caml_call2(Angstrom[53], Angstrom[24], _n_);
    }
    function _m_(param){
     var payload = t[2];
     caml_call1(Dream_websocketaf_Payload[13], payload);
     return Angstrom[50];
    }
    var n = payload_length(t), _l_ = read_exact(0, n);
    return caml_call2(Angstrom[53], _l_, _m_);
   }
   function frame(buf){
    function _k_(headers){
     var
      len = payload_length_of_headers(headers),
      payload =
        0 === len
         ? Dream_websocketaf_Payload[6]
         : caml_call1(Dream_websocketaf_Payload[4], buf);
     return [0, headers, payload];
    }
    return caml_call2(Angstrom[55], parse_headers, _k_);
   }
   function create(frame_handler){
    var buf = caml_call1(Bigstringaf[1], 4096);
    function _f_(frame){
     var
      payload = frame[2],
      is_fin$0 = is_fin(frame),
      opcode$0 = opcode(frame),
      len = payload_length(frame);
     caml_call4(frame_handler, opcode$0, is_fin$0, len, payload);
     return payload_parser(frame);
    }
    var
     _g_ = Angstrom[50],
     _h_ = frame(buf),
     _i_ = caml_call2(Angstrom[59], _h_, _g_),
     _j_ = caml_call2(Angstrom[53], _i_, _f_),
     parser = caml_call1(Angstrom[43], _j_);
    return [0, parser, 0, 0];
   }
   function transition(t, state){
    switch(state[0]){
      case 0:
       var match = state[1], continue$0 = match[2], committed = match[1];
       t[2] = [1, continue$0];
       return committed;
      case 1:
       var consumed = state[1]; break;
      default:
       var consumed$0 = state[1];
       if(0 !== consumed$0){
        var msg = state[3], marks = state[2];
        t[2] = [0, [0, -796721133, [0, marks, msg]]];
        return consumed$0;
       }
       var consumed = consumed$0;
    }
    t[2] = 0;
    return consumed;
   }
   function start(t, state){
    switch(state[0]){
      case 0:
       var _e_ = state[1];
       if(0 === _e_[1]){
        var continue$0 = _e_[2];
        t[2] = [1, continue$0];
        return 0;
       }
       break;
      case 1:
       return caml_call1(Stdlib[2], cst_websocketaf_Reader_unable_);
      default:
       if(0 === state[1]){
        var msg = state[3], marks = state[2];
        t[2] = [0, [0, -796721133, [0, marks, msg]]];
        return 0;
       }
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
   }
   function read_with_more(t, bs, off, len, more){
    var match = t[2];
    if(typeof match === "number"){
     start(t, caml_call1(Angstrom[77][1], t[1]));
     var consumed = read_with_more(t, bs, off, len, more);
    }
    else if(0 === match[0])
     var consumed = 0;
    else
     var
      continue$0 = match[1],
      consumed = transition(t, caml_call4(continue$0, bs, off, len, more));
    if(! more) t[3] = 1;
    return consumed;
   }
   function next(t){
    var match = t[2];
    if(typeof match === "number") return t[3] ? -611285096 : 914388854;
    if(0 !== match[0]) return 914388854;
    var failure = match[1];
    return [0, 106380200, failure];
   }
   var
    Reader = [0, create, transition, start, read_with_more, next],
    Dream_websocketaf_Parse =
      [0,
       is_fin,
       rsv,
       opcode,
       payload_length_of_headers,
       payload_length,
       has_mask,
       mask,
       mask_exn,
       length,
       payload_offset_of_bits,
       payload_offset,
       parse_headers,
       payload_parser,
       frame,
       Reader];
   runtime.caml_register_global
    (11, Dream_websocketaf_Parse, "Dream_websocketaf__Parse");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Websocket_connection
//# unitInfo: Requires: Dream_websocketaf__Parse, Dream_websocketaf__Wsd, Stdlib, Stdlib__Bytes, Stdlib__Int32, Stdlib__Printexc, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_websocketaf_Wsd = global_data.Dream_websocketaf__Wsd,
    Dream_websocketaf_Parse = global_data.Dream_websocketaf__Parse,
    Stdlib = global_data.Stdlib,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Random = global_data.Stdlib__Random;
   function random_int32(param){
    return caml_call1(Stdlib_Random[7], Stdlib_Int32[9]);
   }
   function default_error_handler(wsd, param){
    var
     exn = param[2],
     message = caml_call1(Stdlib_Printexc[1], exn),
     payload = caml_call1(Stdlib_Bytes[5], message);
    caml_call6
     (Dream_websocketaf_Wsd[8],
      wsd,
      0,
      936573133,
      payload,
      0,
      runtime.caml_ml_bytes_length(payload));
    return caml_call2(Dream_websocketaf_Wsd[12], 0, wsd);
   }
   function create(mode, opt, websocket_handler){
    if(opt)
     var sth = opt[1], error_handler = sth;
    else
     var error_handler = default_error_handler;
    var
     wsd = caml_call2(Dream_websocketaf_Wsd[2], error_handler, mode),
     match = caml_call1(websocket_handler, wsd),
     eof = match[2],
     frame = match[1];
    return [0, caml_call1(Dream_websocketaf_Parse[15][1], frame), wsd, eof];
   }
   function shutdown(param){
    var wsd = param[2];
    return caml_call2(Dream_websocketaf_Wsd[12], 0, wsd);
   }
   function set_error_and_handle(t, error){
    caml_call2(Dream_websocketaf_Wsd[14], t[2], error);
    return shutdown(t);
   }
   function next_read_operation(t){
    var operation = caml_call1(Dream_websocketaf_Parse[15][5], t[1]);
    if(typeof operation === "number") return operation;
    var message = operation[2][2][2];
    set_error_and_handle(t, [0, 3458171, [0, Stdlib[7], message]]);
    return -611285096;
   }
   function next_write_operation(t){
    return caml_call1(Dream_websocketaf_Wsd[15], t[2]);
   }
   function read(t, bs, off, len){
    return caml_call5(Dream_websocketaf_Parse[15][4], t[1], bs, off, len, 1);
   }
   function read_eof(t, bs, off, len){
    var r = caml_call5(Dream_websocketaf_Parse[15][4], t[1], bs, off, len, 0);
    caml_call1(t[3], 0);
    return r;
   }
   function report_write_result(t, result){
    return caml_call2(Dream_websocketaf_Wsd[16], t[2], result);
   }
   function yield_writer(t, k){
    return caml_call1(Dream_websocketaf_Wsd[4], t[2])
            ? (caml_call2
               (Dream_websocketaf_Wsd[12], 0, t[2]),
              caml_call1(k, 0))
            : caml_call2(Dream_websocketaf_Wsd[5], t[2], k);
   }
   function is_closed(param){
    var wsd = param[2];
    return caml_call1(Dream_websocketaf_Wsd[4], wsd);
   }
   function report_exn(t, exn){
    return set_error_and_handle(t, [0, 3458171, exn]);
   }
   function yield_reader(t, f){return 0;}
   var
    Dream_websocketaf_Websocket_co =
      [0,
       random_int32,
       default_error_handler,
       create,
       shutdown,
       set_error_and_handle,
       next_read_operation,
       next_write_operation,
       read,
       read_eof,
       report_write_result,
       yield_writer,
       is_closed,
       report_exn,
       yield_reader];
   runtime.caml_register_global
    (7,
     Dream_websocketaf_Websocket_co,
     "Dream_websocketaf__Websocket_connection");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Client_connection
//# unitInfo: Requires: Base64, CamlinternalLazy, Dream_httpaf___Httpaf, Dream_websocketaf__Client_handshake, Dream_websocketaf__Handshake, Dream_websocketaf__Websocket_connection, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_vendor_websocketaf_lib =
      "src/vendor/websocketaf/lib/client_connection.ml",
    cst_upgrade$1 = "upgrade",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_websocketaf_Client_hands =
      global_data.Dream_websocketaf__Client_handshake,
    Dream_websocketaf_Websocket_co =
      global_data.Dream_websocketaf__Websocket_connection,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base64 = global_data.Base64,
    Dream_websocketaf_Handshake = global_data.Dream_websocketaf__Handshake,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    _c_ = [0, cst_src_vendor_websocketaf_lib, 157, 28],
    _b_ = [0, cst_src_vendor_websocketaf_lib, 124, 8],
    _a_ = [0, cst_src_vendor_websocketaf_lib, 72, 19],
    cst_upgrade$0 = cst_upgrade$1,
    cst_sec_websocket_accept = "sec-websocket-accept",
    cst_connection = "connection",
    cst_upgrade = cst_upgrade$1,
    cst_websocket = "websocket";
   function passes_scrutiny(status, accept, headers){
    try{
     var
      sec_websocket_accept =
        caml_call2
         (Dream_httpaf_Httpaf[4][14], headers, cst_sec_websocket_accept),
      connection =
        caml_call2(Dream_httpaf_Httpaf[4][14], headers, cst_connection),
      upgrade = caml_call2(Dream_httpaf_Httpaf[4][14], headers, cst_upgrade);
    }
    catch(_o_){return 0;}
    if(typeof status === "number" && -1021676630 === status){
     var
      _i_ =
        caml_call2(Dream_websocketaf_Handshake[3][2], upgrade, cst_websocket);
     if(_i_){
      var
       _j_ = caml_call2(Stdlib_String[17], 44, connection),
       _k_ =
         function(v){
          var _n_ = caml_call1(Stdlib_String[24], v);
          return caml_call2
                  (Dream_websocketaf_Handshake[3][2], _n_, cst_upgrade$0);
         },
       _l_ = caml_call2(Stdlib_List[34], _k_, _j_);
      if(_l_)
       return caml_call2(Stdlib_String[9], sec_websocket_accept, accept);
      var _m_ = _l_;
     }
     else
      var _m_ = _i_;
     return _m_;
    }
    return 0;
   }
   function handshake_exn(t){
    var match = t[1];
    if(0 !== match[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var handshake = match[1];
    return handshake;
   }
   function connect
   (nonce, opt, sha1, error_handler, websocket_handler, target){
    if(opt)
     var sth = opt[1], headers = sth;
    else
     var headers = Dream_httpaf_Httpaf[4][1];
    var
     response_handler = function _h_(_f_, _g_){return _h_.fun(_f_, _g_);},
     t = [];
    caml_update_dummy
     (response_handler,
      function(response, response_body){
       var headers = response[4], status = response[2], _e_ = caml_obj_tag(t);
       a:
       if(250 === _e_)
        var t$0 = t[1];
       else{
        if(246 !== _e_ && 244 !== _e_){var t$0 = t; break a;}
        var t$0 = caml_call1(CamlinternalLazy[2], t);
       }
       var
        nonce$0 = caml_call5(Base64[12], 0, 0, 0, 0, nonce),
        accept = caml_call2(Dream_websocketaf_Handshake[2], sha1, nonce$0);
       if(! passes_scrutiny(status, accept, headers))
        return caml_call1
                (error_handler, [0, 641382818, [0, response, response_body]]);
       caml_call1(Dream_httpaf_Httpaf[5][1][2], response_body);
       var handshake = handshake_exn(t$0);
       t$0[1] =
        [1,
         caml_call3
          (Dream_websocketaf_Websocket_co[3],
           [0, 1055145579, Dream_websocketaf_Websocket_co[1]],
           0,
           websocket_handler)];
       return caml_call1(Dream_websocketaf_Client_hands[10], handshake);
      });
    caml_update_dummy
     (t,
      [246,
       function(param){
        return [0,
                [0,
                 caml_call5
                  (Dream_websocketaf_Client_hands[1],
                   nonce,
                   headers,
                   error_handler,
                   response_handler,
                   target)]];
       }]);
    var _d_ = caml_obj_tag(t);
    if(250 === _d_) return t[1];
    if(246 !== _d_ && 244 !== _d_) return t;
    return caml_call1(CamlinternalLazy[2], t);
   }
   function create(error_handler, websocket_handler){
    return [0,
            [1,
             caml_call3
              (Dream_websocketaf_Websocket_co[3],
               [0, 1055145579, Dream_websocketaf_Websocket_co[1]],
               error_handler,
               websocket_handler)]];
   }
   function next_read_operation(t){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call1(Dream_websocketaf_Client_hands[2], handshake);
    }
    var
     websocket = match[1],
     operation = caml_call1(Dream_websocketaf_Websocket_co[6], websocket);
    if(typeof operation === "number") return operation;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function read(t, bs, off, len){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call4
             (Dream_websocketaf_Client_hands[4], handshake, bs, off, len);
    }
    var websocket = match[1];
    return caml_call4
            (Dream_websocketaf_Websocket_co[8], websocket, bs, off, len);
   }
   function read_eof(t, bs, off, len){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call4
             (Dream_websocketaf_Client_hands[4], handshake, bs, off, len);
    }
    var websocket = match[1];
    return caml_call4
            (Dream_websocketaf_Websocket_co[9], websocket, bs, off, len);
   }
   function next_write_operation(t){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call1(Dream_websocketaf_Client_hands[3], handshake);
    }
    var websocket = match[1];
    return caml_call1(Dream_websocketaf_Websocket_co[7], websocket);
   }
   function report_write_result(t, result){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call2(Dream_websocketaf_Client_hands[6], handshake, result);
    }
    var websocket = match[1];
    return caml_call2(Dream_websocketaf_Websocket_co[10], websocket, result);
   }
   function report_exn(t, exn){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call2(Dream_websocketaf_Client_hands[8], handshake, exn);
    }
    var websocket = match[1];
    return caml_call2(Dream_websocketaf_Websocket_co[13], websocket, exn);
   }
   function yield_reader(t, f){
    var match = t[1];
    if(0 !== match[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var handshake = match[1];
    return caml_call2(Dream_websocketaf_Client_hands[5], handshake, f);
   }
   function yield_writer(t, f){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call2(Dream_websocketaf_Client_hands[7], handshake, f);
    }
    var websocket = match[1];
    return caml_call2(Dream_websocketaf_Websocket_co[11], websocket, f);
   }
   function is_closed(t){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call1(Dream_websocketaf_Client_hands[9], handshake);
    }
    var websocket = match[1];
    return caml_call1(Dream_websocketaf_Websocket_co[12], websocket);
   }
   function shutdown(t){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call1(Dream_websocketaf_Client_hands[10], handshake);
    }
    var websocket = match[1];
    return caml_call1(Dream_websocketaf_Websocket_co[4], websocket);
   }
   var
    Dream_websocketaf_Client_conne =
      [0,
       passes_scrutiny,
       handshake_exn,
       connect,
       create,
       next_read_operation,
       read,
       read_eof,
       next_write_operation,
       report_write_result,
       report_exn,
       yield_reader,
       yield_writer,
       is_closed,
       shutdown];
   runtime.caml_register_global
    (17,
     Dream_websocketaf_Client_conne,
     "Dream_websocketaf__Client_connection");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Server_connection
//# unitInfo: Requires: CamlinternalLazy, Dream_gluten__Gluten, Dream_httpaf___Httpaf, Dream_websocketaf__Handshake, Dream_websocketaf__Websocket_connection, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_vendor_websocketaf_lib =
      "src/vendor/websocketaf/lib/server_connection.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_gluten_Gluten = global_data.Dream_gluten__Gluten,
    Dream_websocketaf_Websocket_co =
      global_data.Dream_websocketaf__Websocket_connection,
    Assert_failure = global_data.Assert_failure,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Dream_websocketaf_Handshake = global_data.Dream_websocketaf__Handshake,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    CamlinternalLazy = global_data.CamlinternalLazy,
    _c_ = [0, cst_src_vendor_websocketaf_lib, 109, 19],
    _b_ = [0, cst_src_vendor_websocketaf_lib, 84, 4],
    _a_ = [0, [0, "Connection", "close"], 0];
   function is_closed(t){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call1(Dream_gluten_Gluten[3][9], handshake);
    }
    var websocket = match[1];
    return caml_call1(Dream_websocketaf_Websocket_co[12], websocket);
   }
   function create(sha1, error_handler, websocket_handler){
    var
     upgrade_handler = function _o_(_m_, _n_){return _o_.fun(_m_, _n_);},
     request_handler = function _l_(_k_){return _l_.fun(_k_);},
     t = [];
    caml_update_dummy
     (upgrade_handler,
      function(upgrade, param){
       var _j_ = caml_obj_tag(t);
       a:
       if(250 === _j_)
        var t$0 = t[1];
       else{
        if(246 !== _j_ && 244 !== _j_){var t$0 = t; break a;}
        var t$0 = caml_call1(CamlinternalLazy[2], t);
       }
       var
        ws_connection =
          caml_call3
           (Dream_websocketaf_Websocket_co[3],
            583778019,
            error_handler,
            websocket_handler);
       t$0[1] = [1, ws_connection];
       return caml_call1
               (upgrade,
                caml_call2
                 (Dream_gluten_Gluten[1],
                  [0,
                   Dream_websocketaf_Websocket_co[6],
                   Dream_websocketaf_Websocket_co[8],
                   Dream_websocketaf_Websocket_co[9],
                   Dream_websocketaf_Websocket_co[14],
                   Dream_websocketaf_Websocket_co[7],
                   Dream_websocketaf_Websocket_co[10],
                   Dream_websocketaf_Websocket_co[11],
                   Dream_websocketaf_Websocket_co[13],
                   Dream_websocketaf_Websocket_co[12],
                   Dream_websocketaf_Websocket_co[4]],
                  ws_connection));
      });
    caml_update_dummy
     (request_handler,
      function(param){
       var upgrade = param[2], reqd = param[1];
       function error(msg){
        var
         _i_ = [0, caml_call1(Dream_httpaf_Httpaf[4][2], _a_)],
         response =
           caml_call4(Dream_httpaf_Httpaf[7][1], 0, 0, _i_, -99004555);
        return caml_call3(Dream_httpaf_Httpaf[9][5], reqd, response, msg);
       }
       function _g_(param){
        var
         _h_ = caml_call1(upgrade_handler, upgrade),
         match =
           caml_call4(Dream_websocketaf_Handshake[6], 0, sha1, reqd, _h_);
        if(0 === match[0]) return 0;
        var msg = match[1];
        return error(msg);
       }
       var ret = caml_call2(Dream_httpaf_Httpaf[9][11], reqd, _g_);
       if(0 === ret[0]) return 0;
       var exn = ret[1];
       return error(caml_call1(Stdlib_Printexc[1], exn));
      });
    caml_update_dummy
     (t,
      [246,
       function(param){
        var
         _e_ = caml_call2(Dream_httpaf_Httpaf[11][1], 0, 0),
         _f_ = Dream_httpaf_Httpaf[11];
        return [0,
                [0,
                 caml_call3
                  (Dream_gluten_Gluten[3][13],
                   [0,
                    _f_[2],
                    _f_[3],
                    _f_[4],
                    _f_[5],
                    _f_[6],
                    _f_[7],
                    _f_[8],
                    _f_[9],
                    _f_[10],
                    _f_[12]],
                   _e_,
                   request_handler)],
                websocket_handler];
       }]);
    var _d_ = caml_obj_tag(t);
    if(250 === _d_) return t[1];
    if(246 !== _d_ && 244 !== _d_) return t;
    return caml_call1(CamlinternalLazy[2], t);
   }
   function create_websocket(error_handler, websocket_handler){
    return [0,
            [1,
             caml_call3
              (Dream_websocketaf_Websocket_co[3],
               583778019,
               error_handler,
               websocket_handler)],
            websocket_handler];
   }
   function shutdown(t){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call1(Dream_gluten_Gluten[3][10], handshake);
    }
    var websocket = match[1];
    return caml_call1(Dream_websocketaf_Websocket_co[4], websocket);
   }
   function report_exn(t, exn){
    var match = t[1];
    if(0 === match[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var websocket = match[1];
    return caml_call2(Dream_websocketaf_Websocket_co[13], websocket, exn);
   }
   function next_read_operation(t){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call1(Dream_gluten_Gluten[3][1], handshake);
    }
    var websocket = match[1];
    return caml_call1(Dream_websocketaf_Websocket_co[6], websocket);
   }
   function read(t, bs, off, len){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call4(Dream_gluten_Gluten[3][2], handshake, bs, off, len);
    }
    var websocket = match[1];
    return caml_call4
            (Dream_websocketaf_Websocket_co[8], websocket, bs, off, len);
   }
   function read_eof(t, bs, off, len){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call4(Dream_gluten_Gluten[3][3], handshake, bs, off, len);
    }
    var websocket = match[1];
    return caml_call4
            (Dream_websocketaf_Websocket_co[9], websocket, bs, off, len);
   }
   function yield_reader(t, f){
    var match = t[1];
    if(0 !== match[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var handshake = match[1];
    return caml_call2(Dream_gluten_Gluten[3][4], handshake, f);
   }
   function next_write_operation(t){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call1(Dream_gluten_Gluten[3][5], handshake);
    }
    var websocket = match[1];
    return caml_call1(Dream_websocketaf_Websocket_co[7], websocket);
   }
   function report_write_result(t, result){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call2(Dream_gluten_Gluten[3][6], handshake, result);
    }
    var websocket = match[1];
    return caml_call2(Dream_websocketaf_Websocket_co[10], websocket, result);
   }
   function yield_writer(t, f){
    var match = t[1];
    if(0 === match[0]){
     var handshake = match[1];
     return caml_call2(Dream_gluten_Gluten[3][7], handshake, f);
    }
    var websocket = match[1];
    return caml_call2(Dream_websocketaf_Websocket_co[11], websocket, f);
   }
   var
    Dream_websocketaf_Server_conne =
      [0,
       is_closed,
       create,
       create_websocket,
       shutdown,
       report_exn,
       next_read_operation,
       read,
       read_eof,
       yield_reader,
       next_write_operation,
       report_write_result,
       yield_writer];
   runtime.caml_register_global
    (10,
     Dream_websocketaf_Server_conne,
     "Dream_websocketaf__Server_connection");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_websocketaf__Websocketaf
//# unitInfo: Requires: Dream_websocketaf__Client_connection, Dream_websocketaf__Handshake, Dream_websocketaf__Payload, Dream_websocketaf__Server_connection, Dream_websocketaf__Websocket, Dream_websocketaf__Websocket_connection, Dream_websocketaf__Wsd
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Dream_websocketaf_Server_conne =
      global_data.Dream_websocketaf__Server_connection,
    Dream_websocketaf_Client_conne =
      global_data.Dream_websocketaf__Client_connection,
    Dream_websocketaf_Handshake = global_data.Dream_websocketaf__Handshake,
    Dream_websocketaf_Wsd = global_data.Dream_websocketaf__Wsd,
    Dream_websocketaf_Websocket = global_data.Dream_websocketaf__Websocket,
    Dream_websocketaf_Payload = global_data.Dream_websocketaf__Payload,
    _a_ = Dream_websocketaf_Websocket[2],
    _b_ = Dream_websocketaf_Websocket[1],
    Dream_websocketaf_Websocketaf =
      [0,
       [0,
        Dream_websocketaf_Payload[7],
        Dream_websocketaf_Payload[11],
        Dream_websocketaf_Payload[13]],
       [0,
        [0, _b_[1], _b_[4], _b_[5], _b_[6], _b_[7], _b_[8], _b_[9]],
        [0, _a_[1], _a_[4], _a_[5], _a_[6], _a_[7], _a_[8], _a_[9], _a_[10]]],
       [0,
        Dream_websocketaf_Wsd[7],
        Dream_websocketaf_Wsd[8],
        Dream_websocketaf_Wsd[9],
        Dream_websocketaf_Wsd[10],
        Dream_websocketaf_Wsd[11],
        Dream_websocketaf_Wsd[12],
        Dream_websocketaf_Wsd[4],
        Dream_websocketaf_Wsd[13]],
       [0,
        Dream_websocketaf_Handshake[1],
        Dream_websocketaf_Handshake[5],
        Dream_websocketaf_Handshake[6]],
       [0],
       [0,
        Dream_websocketaf_Client_conne[3],
        Dream_websocketaf_Client_conne[4],
        Dream_websocketaf_Client_conne[5],
        Dream_websocketaf_Client_conne[8],
        Dream_websocketaf_Client_conne[6],
        Dream_websocketaf_Client_conne[7],
        Dream_websocketaf_Client_conne[11],
        Dream_websocketaf_Client_conne[9],
        Dream_websocketaf_Client_conne[12],
        Dream_websocketaf_Client_conne[10],
        Dream_websocketaf_Client_conne[13],
        Dream_websocketaf_Client_conne[14]],
       [0,
        Dream_websocketaf_Server_conne[2],
        Dream_websocketaf_Server_conne[3],
        Dream_websocketaf_Server_conne[6],
        Dream_websocketaf_Server_conne[10],
        Dream_websocketaf_Server_conne[7],
        Dream_websocketaf_Server_conne[8],
        Dream_websocketaf_Server_conne[11],
        Dream_websocketaf_Server_conne[5],
        Dream_websocketaf_Server_conne[9],
        Dream_websocketaf_Server_conne[12],
        Dream_websocketaf_Server_conne[1],
        Dream_websocketaf_Server_conne[4]]];
   runtime.caml_register_global
    (6, Dream_websocketaf_Websocketaf, "Dream_websocketaf__Websocketaf");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJkcmVhbV93ZWJzb2NrZXRhZi5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsibm9uZSIsInNvbWUiLCJmIiwiaXNfbm9uZSIsInQiLCJpc19zb21lIiwiY2FsbF9pZl9zb21lIiwidW5jaGVja2VkX3ZhbHVlIiwiY29kZSIsImNvZGVfdGFibGUiLCJ1bnNhZmVfb2ZfY29kZSIsIm9mX2NvZGUiLCJvZl9jb2RlX2V4biIsInBwX2h1bSIsImZtdCIsImNvZGUkMCIsImNvZGVfdGFibGUkMCIsInVuc2FmZV9vZl9jb2RlJDAiLCJvZl9jb2RlJDAiLCJvZl9jb2RlX2V4biQwIiwib2ZfYmlnc3RyaW5nIiwiYnMiLCJvZmYiLCJjb2RlX2ludCIsIm9mX2JpZ3N0cmluZ19leG4iLCJhcHBseV9tYXNrIiwibWFzayIsIm9wdCIsInNyY19vZmYiLCJsZW4iLCJzdGgiLCJuIiwibGVuJDAiLCJpIiwiaiIsImMiLCJjJDAiLCJhcHBseV9tYXNrX2J5dGVzIiwic2VyaWFsaXplX2hlYWRlcnMiLCJmYXJhZGF5IiwiaXNfZmluIiwib3Bjb2RlIiwicGF5bG9hZF9sZW5ndGgiLCJvcGNvZGUkMCIsImlzX2ZpbiQwIiwiaXNfbWFzayIsIm1hc2skMCIsInNlcmlhbGl6ZV9jb250cm9sIiwic2NoZWR1bGVfc2VyaWFsaXplIiwicGF5bG9hZCIsInNlcmlhbGl6ZV9ieXRlcyIsImRlZmF1bHRfcmVhZHlfdG9fd3JpdGUiLCJjcmVhdGUiLCJlcnJvcl9oYW5kbGVyIiwibW9kZSIsIm0iLCJpc19jbG9zZWQiLCJvbl93YWtldXAiLCJrIiwid2FrZXVwIiwic2NoZWR1bGUiLCJraW5kIiwic2VuZF9ieXRlcyIsInNlbmRfcGluZyIsImFwcGxpY2F0aW9uX2RhdGEiLCJidWZmZXIiLCJzZW5kX3BvbmciLCJmbHVzaGVkIiwiY2xvc2UiLCJlcnJvcl9jb2RlIiwiZXJyb3IiLCJyZXBvcnRfZXJyb3IiLCJuZXh0IiwiaW92ZWNzIiwicmVwb3J0X3Jlc3VsdCIsInJlc3VsdCIsImNyZWF0ZV9yZXF1ZXN0Iiwibm9uY2UiLCJoZWFkZXJzIiwidGFyZ2V0Iiwibm9uY2UkMCIsImhlYWRlcnMkMCIsInNlY193ZWJzb2NrZXRfa2V5X3Byb29mIiwic2hhMSIsInNlY193ZWJzb2NrZXRfa2V5IiwiY29uY2F0ZW5hdGlvbiIsImxvd2VyIiwiZXF1YWwiLCJ4IiwieSIsImVxdWFsX3NvX2ZhciIsImMxIiwiYzIiLCJwYXNzZXNfc2NydXRpbnkiLCJyZXF1ZXN0X21ldGhvZCIsImNvbm5lY3Rpb24iLCJ1cGdyYWRlIiwidiIsInVwZ3JhZGVfaGVhZGVycyIsImFjY2VwdCIsInJlc3BvbmRfd2l0aF91cGdyYWRlIiwicmVxZCIsInVwZ3JhZGVfaGFuZGxlciIsInJlcXVlc3QiLCJ1cGdyYWRlX2hlYWRlcnMkMCIsIm1zZyIsInJlc3BvbnNlX2hhbmRsZXIiLCJib2R5IiwibmV4dF9yZWFkX29wZXJhdGlvbiIsIm5leHRfd3JpdGVfb3BlcmF0aW9uIiwicmVhZCIsInlpZWxkX3JlYWRlciIsInJlcG9ydF93cml0ZV9yZXN1bHQiLCJ5aWVsZF93cml0ZXIiLCJyZXBvcnRfZXhuIiwiZXhuIiwiZGVmYXVsdF9vbl9lb2YiLCJkZWZhdWx0X29uX3JlYWQiLCJvZl9mYXJhZGF5IiwiY3JlYXRlX2VtcHR5IiwiZW1wdHkiLCJ1bnNhZmVfZmFyYWRheSIsImRvX2V4ZWN1dGVfcmVhZCQwIiwib25fZW9mIiwib25fcmVhZCIsImlvdmVjIiwiZXhlY3V0ZV9yZWFkJDAiLCJkb19leGVjdXRlX3JlYWQiLCJleGVjdXRlX3JlYWQiLCJzY2hlZHVsZV9yZWFkIiwiaXNfcmVhZF9zY2hlZHVsZWQiLCJiaXRzIiwicnN2IiwicGF5bG9hZF9sZW5ndGhfb2ZfaGVhZGVycyIsImxlbmd0aCIsImhhc19tYXNrIiwibWFza19leG4iLCJwYXlsb2FkX2xlbmd0aCQwIiwicGF5bG9hZF9vZmZzZXRfb2ZfYml0cyIsIm1hc2tfb2Zmc2V0IiwibGVuZ3RoX29mZnNldCIsInBheWxvYWRfb2Zmc2V0IiwiaGVhZGVyc19sZW4iLCJwYXJzZV9oZWFkZXJzIiwicGF5bG9hZF9wYXJzZXIiLCJyZWFkX2V4YWN0IiwibSQwIiwibiQwIiwiZnJhbWUiLCJidWYiLCJmcmFtZV9oYW5kbGVyIiwicGFyc2VyIiwidHJhbnNpdGlvbiIsInN0YXRlIiwiY29udGludWUkMCIsImNvbW1pdHRlZCIsImNvbnN1bWVkIiwiY29uc3VtZWQkMCIsIm1hcmtzIiwic3RhcnQiLCJyZWFkX3dpdGhfbW9yZSIsIm1vcmUiLCJmYWlsdXJlIiwicmFuZG9tX2ludDMyIiwiZGVmYXVsdF9lcnJvcl9oYW5kbGVyIiwid3NkIiwibWVzc2FnZSIsIndlYnNvY2tldF9oYW5kbGVyIiwiZW9mIiwic2h1dGRvd24iLCJzZXRfZXJyb3JfYW5kX2hhbmRsZSIsIm9wZXJhdGlvbiIsInJlYWRfZW9mIiwiciIsInN0YXR1cyIsInNlY193ZWJzb2NrZXRfYWNjZXB0IiwiaGFuZHNoYWtlX2V4biIsImhhbmRzaGFrZSIsImNvbm5lY3QiLCJyZXNwb25zZSIsInJlc3BvbnNlX2JvZHkiLCJ0JDAiLCJ3ZWJzb2NrZXQiLCJyZXF1ZXN0X2hhbmRsZXIiLCJ3c19jb25uZWN0aW9uIiwicmV0IiwiY3JlYXRlX3dlYnNvY2tldCJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS13ZWJzb2NrZXRhZi9vcHRpb25hbF90aHVuay5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS13ZWJzb2NrZXRhZi93ZWJzb2NrZXQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0td2Vic29ja2V0YWYvc2VyaWFsaXplLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLXdlYnNvY2tldGFmL3dzZC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS13ZWJzb2NrZXRhZi9oYW5kc2hha2UubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0td2Vic29ja2V0YWYvY2xpZW50X2hhbmRzaGFrZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS13ZWJzb2NrZXRhZi9wYXlsb2FkLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLXdlYnNvY2tldGFmL3BhcnNlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLXdlYnNvY2tldGFmL3dlYnNvY2tldF9jb25uZWN0aW9uLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLXdlYnNvY2tldGFmL2NsaWVudF9jb25uZWN0aW9uLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLXdlYnNvY2tldGFmL3NlcnZlcl9jb25uZWN0aW9uLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7Ozs7Ozs7O1lBRUlBLFlBQXNDLFNBQUU7WUFDeENDLEtBQUtDO0lBQ1AsR0FET0EsTUFETEYsTUFHRztJQUFBLE9BRkVFO0dBR047WUFFQ0MsUUFBUUMsR0FBSSxPQUFKQSxNQU5SSixhQU1xQjtZQUNyQkssUUFBUUQsR0FBSSxXQURaRCxRQUNRQyxHQUFtQjtZQUMzQkUsYUFBYUYsR0FBSSxPQUFBLFdBQUpBLE1BQVE7WUFDckJH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QUY7T0FNQUc7T0FNQUM7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJ0eXBlIHQgPSB1bml0IC0+IHVuaXRcblxubGV0IG5vbmUgPSBTeXMub3BhcXVlX2lkZW50aXR5IChmdW4gKCkgLT4gKCkpXG5sZXQgc29tZSBmID1cbiAgaWYgZiA9PSBub25lXG4gIHRoZW4gZmFpbHdpdGggXCJPcHRpb25hbF90aHVuazogdGhpcyBmdW5jdGlvbiBpcyBub3QgcmVwcmVzZW50YWJsZSBhcyBhIHNvbWUgdmFsdWVcIjtcbiAgZlxuXG5sZXQgaXNfbm9uZSB0ID0gdCA9PSBub25lXG5sZXQgaXNfc29tZSB0ID0gbm90IChpc19ub25lIHQpXG5sZXQgY2FsbF9pZl9zb21lIHQgPSB0ICgpXG5sZXQgdW5jaGVja2VkX3ZhbHVlIHQgPSB0XG4iLCJtb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcblxubW9kdWxlIElPVmVjID0gSHR0cGFmLklPVmVjXG5cbm1vZHVsZSBPcGNvZGUgPSBzdHJ1Y3RcbiAgdHlwZSBzdGFuZGFyZF9ub25fY29udHJvbCA9XG4gICAgWyBgQ29udGludWF0aW9uXG4gICAgfCBgVGV4dFxuICAgIHwgYEJpbmFyeSBdXG5cbiAgdHlwZSBzdGFuZGFyZF9jb250cm9sID1cbiAgICBbIGBDb25uZWN0aW9uX2Nsb3NlXG4gICAgfCBgUGluZ1xuICAgIHwgYFBvbmcgXVxuXG4gIHR5cGUgc3RhbmRhcmQgPVxuICAgIFsgc3RhbmRhcmRfbm9uX2NvbnRyb2xcbiAgICB8IHN0YW5kYXJkX2NvbnRyb2wgXVxuXG4gIHR5cGUgdCA9XG4gICAgWyBzdGFuZGFyZFxuICAgIHwgYE90aGVyIG9mIGludCBdXG5cbiAgbGV0IGNvZGUgPSBmdW5jdGlvblxuICAgIHwgYENvbnRpbnVhdGlvbiAgICAgLT4gMHgwXG4gICAgfCBgVGV4dCAgICAgICAgICAgICAtPiAweDFcbiAgICB8IGBCaW5hcnkgICAgICAgICAgIC0+IDB4MlxuICAgIHwgYENvbm5lY3Rpb25fY2xvc2UgLT4gMHg4XG4gICAgfCBgUGluZyAgICAgICAgICAgICAtPiAweDlcbiAgICB8IGBQb25nICAgICAgICAgICAgIC0+IDB4YVxuICAgIHwgYE90aGVyIGNvZGUgICAgICAgLT4gY29kZVxuXG4gIGxldCBjb2RlX3RhYmxlIDogdCBhcnJheSA9XG4gICAgW3wgYENvbnRpbnVhdGlvblxuICAgICA7IGBUZXh0XG4gICAgIDsgYEJpbmFyeVxuICAgICA7IGBPdGhlciAweDNcbiAgICAgOyBgT3RoZXIgMHg0XG4gICAgIDsgYE90aGVyIDB4NVxuICAgICA7IGBPdGhlciAweDZcbiAgICAgOyBgT3RoZXIgMHg3XG4gICAgIDsgYENvbm5lY3Rpb25fY2xvc2VcbiAgICAgOyBgUGluZ1xuICAgICA7IGBQb25nXG4gICAgIDsgYE90aGVyIDB4YlxuICAgICA7IGBPdGhlciAweGNcbiAgICAgOyBgT3RoZXIgMHhkXG4gICAgIDsgYE90aGVyIDB4ZVxuICAgICA7IGBPdGhlciAweGZcbiAgICAgfF1cblxuICBsZXQgdW5zYWZlX29mX2NvZGUgY29kZSA9XG4gICAgQXJyYXkudW5zYWZlX2dldCBjb2RlX3RhYmxlIGNvZGVcblxuICBsZXQgb2ZfY29kZSBjb2RlID1cbiAgICBpZiBjb2RlID4gMHhmXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSBTb21lIChBcnJheS51bnNhZmVfZ2V0IGNvZGVfdGFibGUgY29kZSlcblxuICBsZXQgb2ZfY29kZV9leG4gY29kZSA9XG4gICAgaWYgY29kZSA+IDB4ZlxuICAgIHRoZW4gZmFpbHdpdGggXCJPcGNvZGUub2ZfY29kZV9leG46IHZhbHVlIGNhbid0IGZpdCBpbiBmb3VyIGJpdHNcIjtcbiAgICBBcnJheS51bnNhZmVfZ2V0IGNvZGVfdGFibGUgY29kZVxuXG4gIGxldCB0b19pbnQgPSBjb2RlXG4gIGxldCBvZl9pbnQgPSBvZl9jb2RlXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfY29kZV9leG5cblxuICBsZXQgcHBfaHVtIGZtdCB0ID1cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlZFwiICh0b19pbnQgdClcbmVuZFxuXG5tb2R1bGUgQ2xvc2VfY29kZSA9IHN0cnVjdFxuICB0eXBlIHN0YW5kYXJkID1cbiAgICBbIGBOb3JtYWxfY2xvc3VyZVxuICAgIHwgYEdvaW5nX2F3YXlcbiAgICB8IGBQcm90b2NvbF9lcnJvclxuICAgIHwgYFVuc3VwcG9ydGVkX2RhdGFcbiAgICB8IGBOb19zdGF0dXNfcmN2ZFxuICAgIHwgYEFibm9ybWFsX2Nsb3N1cmVcbiAgICB8IGBJbnZhbGlkX2ZyYW1lX3BheWxvYWRfZGF0YVxuICAgIHwgYFBvbGljeV92aW9sYXRpb25cbiAgICB8IGBNZXNzYWdlX3Rvb19iaWdcbiAgICB8IGBNYW5kYXRvcnlfZXh0XG4gICAgfCBgSW50ZXJuYWxfc2VydmVyX2Vycm9yXG4gICAgfCBgVExTX2hhbmRzaGFrZSBdXG5cbiAgdHlwZSB0ID1cbiAgICBbIHN0YW5kYXJkIHwgYE90aGVyIG9mIGludCBdXG5cbiAgbGV0IGNvZGUgPSBmdW5jdGlvblxuICAgIHwgYE5vcm1hbF9jbG9zdXJlICAgICAgICAgICAgIC0+IDEwMDBcbiAgICB8IGBHb2luZ19hd2F5ICAgICAgICAgICAgICAgICAtPiAxMDAxXG4gICAgfCBgUHJvdG9jb2xfZXJyb3IgICAgICAgICAgICAgLT4gMTAwMlxuICAgIHwgYFVuc3VwcG9ydGVkX2RhdGEgICAgICAgICAgIC0+IDEwMDNcbiAgICB8IGBOb19zdGF0dXNfcmN2ZCAgICAgICAgICAgICAtPiAxMDA1XG4gICAgfCBgQWJub3JtYWxfY2xvc3VyZSAgICAgICAgICAgLT4gMTAwNlxuICAgIHwgYEludmFsaWRfZnJhbWVfcGF5bG9hZF9kYXRhIC0+IDEwMDdcbiAgICB8IGBQb2xpY3lfdmlvbGF0aW9uICAgICAgICAgICAtPiAxMDA4XG4gICAgfCBgTWVzc2FnZV90b29fYmlnICAgICAgICAgICAgLT4gMTAwOVxuICAgIHwgYE1hbmRhdG9yeV9leHQgICAgICAgICAgICAgIC0+IDEwMTBcbiAgICB8IGBJbnRlcm5hbF9zZXJ2ZXJfZXJyb3IgICAgICAtPiAxMDExXG4gICAgfCBgVExTX2hhbmRzaGFrZSAgICAgICAgICAgICAgLT4gMTAxNVxuICAgIHwgYE90aGVyIGNvZGUgICAgICAgICAgICAgICAgIC0+IGNvZGVcblxuICBsZXQgY29kZV90YWJsZSA6IHQgYXJyYXkgPVxuICAgIFt8IGBOb3JtYWxfY2xvc3VyZVxuICAgICA7IGBHb2luZ19hd2F5XG4gICAgIDsgYFByb3RvY29sX2Vycm9yXG4gICAgIDsgYFVuc3VwcG9ydGVkX2RhdGFcbiAgICAgOyBgT3RoZXIgMTAwNFxuICAgICA7IGBOb19zdGF0dXNfcmN2ZFxuICAgICA7IGBBYm5vcm1hbF9jbG9zdXJlXG4gICAgIDsgYEludmFsaWRfZnJhbWVfcGF5bG9hZF9kYXRhXG4gICAgIDsgYFBvbGljeV92aW9sYXRpb25cbiAgICAgOyBgTWVzc2FnZV90b29fYmlnXG4gICAgIDsgYE1hbmRhdG9yeV9leHRcbiAgICAgOyBgSW50ZXJuYWxfc2VydmVyX2Vycm9yXG4gICAgIDsgYE90aGVyIDEwMTJcbiAgICAgOyBgT3RoZXIgMTAxM1xuICAgICA7IGBPdGhlciAxMDE0XG4gICAgIDsgYFRMU19oYW5kc2hha2VcbiAgICAgfF1cblxuICBsZXQgdW5zYWZlX29mX2NvZGUgY29kZSA9XG4gICAgQXJyYXkudW5zYWZlX2dldCBjb2RlX3RhYmxlIGNvZGVcblxuICBsZXQgb2ZfY29kZSBjb2RlID1cbiAgICBpZiBjb2RlID4gMHhmZmZmIHx8IGNvZGUgPCAxMDAwIHRoZW4gTm9uZVxuICAgIGVsc2UgaWYgY29kZSA8IDEwMTYgICAgICAgICAgICAgdGhlbiBTb21lICh1bnNhZmVfb2ZfY29kZSAoY29kZSBsYW5kIDBiMTExMSkpXG4gICAgZWxzZSBTb21lIChgT3RoZXIgY29kZSlcbiAgOztcblxuICBsZXQgb2ZfY29kZV9leG4gY29kZSA9XG4gICAgaWYgY29kZSA+IDB4ZmZmZlxuICAgIHRoZW4gZmFpbHdpdGggXCJDbG9zZV9jb2RlLm9mX2NvZGVfZXhuOiB2YWx1ZSBjYW4ndCBmaXQgaW4gdHdvIGJ5dGVzXCI7XG4gICAgaWYgY29kZSA8IDEwMDBcbiAgICB0aGVuIGZhaWx3aXRoIFwiQ2xvc2VfY29kZS5vZl9jb2RlX2V4bjogdmFsdWUgaW4gaW52YWxpZCByYW5nZSAwLTk5OVwiO1xuICAgIGlmIGNvZGUgPCAxMDE2XG4gICAgdGhlbiB1bnNhZmVfb2ZfY29kZSAoY29kZSBsYW5kIDBiMTExMSlcbiAgICBlbHNlIGBPdGhlciBjb2RlXG4gIDs7XG5cbiAgbGV0IHRvX2ludCA9IGNvZGVcbiAgbGV0IG9mX2ludCA9IG9mX2NvZGVcbiAgbGV0IG9mX2ludF9leG4gPSBvZl9jb2RlX2V4blxuXG4gIGxldCBvZl9iaWdzdHJpbmcgYnMgfm9mZiA9XG4gICAgKCogQ2xvc2UgY29kZSB0YWtlcyAyIGJ5dGVzICopXG4gICAgaWYgQmlnc3RyaW5nYWYubGVuZ3RoIGJzIC0gb2ZmIC0gMiAgPCAwXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbGV0IGNvZGVfaW50ID0gQmlnc3RyaW5nYWYuZ2V0X2ludDE2X2JlIGJzIG9mZiBpblxuICAgICAgb2ZfaW50IGNvZGVfaW50XG5cbiAgbGV0IG9mX2JpZ3N0cmluZ19leG4gYnMgfm9mZiA9XG4gICAgKCogQ2xvc2UgY29kZSB0YWtlcyAyIGJ5dGVzICopXG4gICAgaWYgQmlnc3RyaW5nYWYubGVuZ3RoIGJzIC0gb2ZmIC0gMiAgPCAwXG4gICAgdGhlbiBmYWlsd2l0aCBcIkNsb3NlX2NvZGUub2ZfYmlnc3RyaW5nX2V4bjogY2FuJ3QgcmVhZCAyIGJ5dGVzIGZyb20gYmlnc3RyaW5nXCJcbiAgICBlbHNlXG4gICAgICBsZXQgY29kZV9pbnQgPSBCaWdzdHJpbmdhZi5nZXRfaW50MTZfYmUgYnMgb2ZmIGluXG4gICAgICBvZl9pbnRfZXhuIGNvZGVfaW50XG5lbmRcblxubW9kdWxlIEZyYW1lID0gc3RydWN0XG4gIGxldCBhcHBseV9tYXNrIG1hc2sgPyhvZmY9MCkgfnNyY19vZmYgP2xlbiBicyA9XG4gICAgbGV0IGxlbiA9XG4gICAgICBtYXRjaCBsZW4gd2l0aFxuICAgICAgfCBOb25lIC0+IEJpZ3N0cmluZ2FmLmxlbmd0aCBic1xuICAgICAgfCBTb21lIG4gLT4gblxuICAgIGluXG4gICAgZm9yIGkgPSBvZmYgdG8gb2ZmICsgbGVuIC0gMSBkb1xuICAgICAgbGV0IGogPSAoaSArIHNyY19vZmYgLSBvZmYpIG1vZCA0IGluXG4gICAgICAoKiBsZXQgaiA9IChpIC0gb2ZmKSBtb2QgNCBpbiAqKVxuICAgICAgbGV0IGMgPSBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IGJzIGkgfD4gQ2hhci5jb2RlIGluXG4gICAgICBsZXQgYyA9IGMgbHhvciBJbnQzMi4obG9nYW5kIChzaGlmdF9yaWdodCBtYXNrICg4ICogKDMgLSBqKSkpIDB4ZmZsIHw+IHRvX2ludCkgaW5cbiAgICAgIEJpZ3N0cmluZ2FmLnVuc2FmZV9zZXQgYnMgaSAoQ2hhci51bnNhZmVfY2hyIGMpXG4gICAgZG9uZVxuICA7O1xuXG4gIGxldCBhcHBseV9tYXNrX2J5dGVzIG1hc2sgYnMgfnNyY19vZmYgfm9mZiB+bGVuID1cbiAgICBmb3IgaSA9IG9mZiB0byBvZmYgKyBsZW4gLSAxIGRvXG4gICAgICAoKiBsZXQgaiA9IChpIC0gb2ZmKSBtb2QgNCBpbiAqKVxuICAgICAgbGV0IGogPSAoaSArIHNyY19vZmYgLSBvZmYpIG1vZCA0IGluXG4gICAgICBsZXQgYyA9IEJ5dGVzLnVuc2FmZV9nZXQgYnMgaSB8PiBDaGFyLmNvZGUgaW5cbiAgICAgIGxldCBjID0gYyBseG9yIEludDMyLihsb2dhbmQgKHNoaWZ0X3JpZ2h0IG1hc2sgKDggKiAoMyAtIGopKSkgMHhmZmwgfD4gdG9faW50KSBpblxuICAgICAgQnl0ZXMudW5zYWZlX3NldCBicyBpIChDaGFyLnVuc2FmZV9jaHIgYylcbiAgICBkb25lXG4gIDs7XG5lbmRcbiIsImxldCBzZXJpYWxpemVfaGVhZGVycyA/bWFzayBmYXJhZGF5IH5pc19maW4gfm9wY29kZSB+cGF5bG9hZF9sZW5ndGggPVxuICBsZXQgb3Bjb2RlID0gV2Vic29ja2V0Lk9wY29kZS50b19pbnQgb3Bjb2RlIGluXG4gIGxldCBpc19maW4gPSBpZiBpc19maW4gdGhlbiAxIGxzbCA3IGVsc2UgMCBpblxuICBsZXQgaXNfbWFzayA9XG4gICAgbWF0Y2ggbWFzayB3aXRoXG4gICAgfCBOb25lICAgLT4gMFxuICAgIHwgU29tZSBfIC0+IDEgbHNsIDdcbiAgaW5cbiAgRmFyYWRheS53cml0ZV91aW50OCBmYXJhZGF5IChpc19maW4gbG9yIG9wY29kZSk7XG4gIGlmICAgICAgcGF5bG9hZF9sZW5ndGggPD0gMTI1ICAgIHRoZW5cbiAgICBGYXJhZGF5LndyaXRlX3VpbnQ4IGZhcmFkYXkgKGlzX21hc2sgbG9yIHBheWxvYWRfbGVuZ3RoKVxuICBlbHNlIGlmIHBheWxvYWRfbGVuZ3RoIDw9IDB4ZmZmZiB0aGVuIGJlZ2luXG4gICAgRmFyYWRheS53cml0ZV91aW50OCAgICAgZmFyYWRheSAoaXNfbWFzayBsb3IgMTI2KTtcbiAgICBGYXJhZGF5LkJFLndyaXRlX3VpbnQxNiBmYXJhZGF5IHBheWxvYWRfbGVuZ3RoO1xuICBlbmQgZWxzZSBiZWdpblxuICAgIEZhcmFkYXkud3JpdGVfdWludDggICAgIGZhcmFkYXkgKGlzX21hc2sgbG9yIDEyNyk7XG4gICAgRmFyYWRheS5CRS53cml0ZV91aW50NjQgZmFyYWRheSAoSW50NjQub2ZfaW50IHBheWxvYWRfbGVuZ3RoKTtcbiAgZW5kO1xuICBiZWdpbiBtYXRjaCBtYXNrIHdpdGhcbiAgfCBOb25lICAgICAgLT4gKClcbiAgfCBTb21lIG1hc2sgLT4gRmFyYWRheS5CRS53cml0ZV91aW50MzIgZmFyYWRheSBtYXNrXG4gIGVuZFxuOztcblxubGV0IHNlcmlhbGl6ZV9jb250cm9sID9tYXNrIGZhcmFkYXkgfm9wY29kZSA9XG4gIGxldCBvcGNvZGUgPSAob3Bjb2RlIDo+IFdlYnNvY2tldC5PcGNvZGUudCkgaW5cbiAgc2VyaWFsaXplX2hlYWRlcnMgZmFyYWRheSA/bWFzayB+aXNfZmluOnRydWUgfm9wY29kZSB+cGF5bG9hZF9sZW5ndGg6MFxuXG5sZXQgc2NoZWR1bGVfc2VyaWFsaXplID9tYXNrIGZhcmFkYXkgfmlzX2ZpbiB+b3Bjb2RlIH5wYXlsb2FkIH5zcmNfb2ZmIH5vZmYgfmxlbiA9XG4gIHNlcmlhbGl6ZV9oZWFkZXJzIGZhcmFkYXkgP21hc2sgfmlzX2ZpbiB+b3Bjb2RlIH5wYXlsb2FkX2xlbmd0aDpsZW47XG4gIGJlZ2luIG1hdGNoIG1hc2sgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIG1hc2sgLT4gV2Vic29ja2V0LkZyYW1lLmFwcGx5X21hc2sgbWFzayBwYXlsb2FkIH5zcmNfb2ZmIH5vZmYgfmxlblxuICBlbmQ7XG4gIEZhcmFkYXkuc2NoZWR1bGVfYmlnc3RyaW5nIGZhcmFkYXkgcGF5bG9hZCB+b2ZmIH5sZW47XG47O1xuXG5sZXQgc2VyaWFsaXplX2J5dGVzID9tYXNrIGZhcmFkYXkgfmlzX2ZpbiB+b3Bjb2RlIH5wYXlsb2FkIH5zcmNfb2ZmIH5vZmYgfmxlbiA9XG4gIHNlcmlhbGl6ZV9oZWFkZXJzIGZhcmFkYXkgP21hc2sgfmlzX2ZpbiB+b3Bjb2RlIH5wYXlsb2FkX2xlbmd0aDpsZW47XG4gIGJlZ2luIG1hdGNoIG1hc2sgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIG1hc2sgLT4gV2Vic29ja2V0LkZyYW1lLmFwcGx5X21hc2tfYnl0ZXMgbWFzayBwYXlsb2FkIH5zcmNfb2ZmIH5vZmYgfmxlblxuICBlbmQ7XG4gIEZhcmFkYXkud3JpdGVfYnl0ZXMgZmFyYWRheSBwYXlsb2FkIH5vZmYgfmxlbjtcbjs7XG4iLCJtb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcblxubW9kdWxlIElPVmVjID0gSHR0cGFmLklPVmVjXG5cbnR5cGUgZXJyb3IgPSBbIGBFeG4gb2YgZXhuIF1cblxudHlwZSBtb2RlID1cbiAgWyBgQ2xpZW50IG9mIHVuaXQgLT4gaW50MzJcbiAgfCBgU2VydmVyXG4gIF1cblxudHlwZSB0ID1cbiAgeyBmYXJhZGF5IDogRmFyYWRheS50XG4gIDsgbW9kZSA6IG1vZGVcbiAgOyBtdXRhYmxlIHdha2V1cCA6IE9wdGlvbmFsX3RodW5rLnRcbiAgOyBlcnJvcl9oYW5kbGVyOiBlcnJvcl9oYW5kbGVyXG4gIDsgbXV0YWJsZSBlcnJvcl9jb2RlOiBbYE9rIHwgZXJyb3IgXVxuICB9XG5hbmQgZXJyb3JfaGFuZGxlciA9IHQgLT4gZXJyb3IgLT4gdW5pdFxuXG5sZXQgZGVmYXVsdF9yZWFkeV90b193cml0ZSA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgKGZ1biAoKSAtPiAoKSlcblxubGV0IGNyZWF0ZSB+ZXJyb3JfaGFuZGxlciBtb2RlID1cbiAgeyBmYXJhZGF5ID0gRmFyYWRheS5jcmVhdGUgMHgxMDAwXG4gIDsgbW9kZVxuICA7IHdha2V1cCA9IE9wdGlvbmFsX3RodW5rLm5vbmVcbiAgOyBlcnJvcl9oYW5kbGVyXG4gIDsgZXJyb3JfY29kZSA9IGBPa1xuICB9XG5cbmxldCBtYXNrIHQgPVxuICBtYXRjaCB0Lm1vZGUgd2l0aFxuICB8IGBDbGllbnQgbSAtPiBTb21lIChtICgpKVxuICB8IGBTZXJ2ZXIgLT4gTm9uZVxuXG5sZXQgaXNfY2xvc2VkIHQgPVxuICBGYXJhZGF5LmlzX2Nsb3NlZCB0LmZhcmFkYXlcblxubGV0IG9uX3dha2V1cCB0IGsgPVxuICBpZiBGYXJhZGF5LmlzX2Nsb3NlZCB0LmZhcmFkYXlcbiAgdGhlbiBmYWlsd2l0aCBcIm9uX3dha2V1cCBvbiBjbG9zZWQgd3JpdGVyXCJcbiAgZWxzZSBpZiBPcHRpb25hbF90aHVuay5pc19zb21lIHQud2FrZXVwXG4gIHRoZW4gZmFpbHdpdGggXCJvbl93YWtldXA6IG9ubHkgb25lIGNhbGxiYWNrIGNhbiBiZSByZWdpc3RlcmVkIGF0IGEgdGltZVwiXG4gIGVsc2UgdC53YWtldXAgPC0gT3B0aW9uYWxfdGh1bmsuc29tZSBrXG5cbmxldCB3YWtldXAgdCA9XG4gIGxldCBmID0gdC53YWtldXAgaW5cbiAgdC53YWtldXAgPC0gT3B0aW9uYWxfdGh1bmsubm9uZTtcbiAgT3B0aW9uYWxfdGh1bmsuY2FsbF9pZl9zb21lIGZcblxubGV0IHNjaGVkdWxlIHQgPyhpc19maW49dHJ1ZSkgfmtpbmQgcGF5bG9hZCB+b2ZmIH5sZW4gPVxuICBsZXQgbWFzayA9IG1hc2sgdCBpblxuICBTZXJpYWxpemUuc2NoZWR1bGVfc2VyaWFsaXplXG4gICAgdC5mYXJhZGF5XG4gICAgKCogVE9ETzogaXNfZmluICopXG4gICAgP21hc2tcbiAgICB+aXNfZmluXG4gICAgfm9wY29kZTooa2luZCA6PiBXZWJzb2NrZXQuT3Bjb2RlLnQpXG4gICAgfnNyY19vZmY6MFxuICAgIH5wYXlsb2FkIH5vZmYgfmxlbjtcbiAgd2FrZXVwIHRcblxubGV0IHNlbmRfYnl0ZXMgdCA/KGlzX2Zpbj10cnVlKSB+a2luZCBwYXlsb2FkIH5vZmYgfmxlbiA9XG4gIGxldCBtYXNrID0gbWFzayB0IGluXG4gIFNlcmlhbGl6ZS5zZXJpYWxpemVfYnl0ZXNcbiAgICB0LmZhcmFkYXlcbiAgICA/bWFza1xuICAgIH5pc19maW5cbiAgICB+b3Bjb2RlOihraW5kIDo+IFdlYnNvY2tldC5PcGNvZGUudClcbiAgICB+cGF5bG9hZFxuICAgIH5zcmNfb2ZmOjBcbiAgICB+b2ZmXG4gICAgfmxlbjtcbiAgd2FrZXVwIHRcblxubGV0IHNlbmRfcGluZyA/YXBwbGljYXRpb25fZGF0YSB0ID1cbiAgYmVnaW4gbWF0Y2ggYXBwbGljYXRpb25fZGF0YSB3aXRoXG4gIHwgTm9uZSAtPiBTZXJpYWxpemUuc2VyaWFsaXplX2NvbnRyb2wgdC5mYXJhZGF5IH5vcGNvZGU6YFBpbmdcbiAgfCBTb21lIHsgSU9WZWMuYnVmZmVyOyBvZmY7IGxlbiB9IC0+XG4gICAgbGV0IG1hc2sgPSBtYXNrIHQgaW5cbiAgICBTZXJpYWxpemUuc2NoZWR1bGVfc2VyaWFsaXplXG4gICAgICB0LmZhcmFkYXlcbiAgICAgID9tYXNrXG4gICAgICB+aXNfZmluOnRydWVcbiAgICAgIH5vcGNvZGU6YFBpbmdcbiAgICAgIH5zcmNfb2ZmOjBcbiAgICAgIH5wYXlsb2FkOmJ1ZmZlclxuICAgICAgfm9mZlxuICAgICAgfmxlbjtcbiAgZW5kO1xuICB3YWtldXAgdFxuXG5sZXQgc2VuZF9wb25nID9hcHBsaWNhdGlvbl9kYXRhIHQgPVxuICBiZWdpbiBtYXRjaCBhcHBsaWNhdGlvbl9kYXRhIHdpdGhcbiAgfCBOb25lIC0+IFNlcmlhbGl6ZS5zZXJpYWxpemVfY29udHJvbCB0LmZhcmFkYXkgfm9wY29kZTpgUG9uZztcbiAgfCBTb21lIHsgSU9WZWMuYnVmZmVyOyBvZmY7IGxlbiB9IC0+XG4gICAgbGV0IG1hc2sgPSBtYXNrIHQgaW5cbiAgICBTZXJpYWxpemUuc2NoZWR1bGVfc2VyaWFsaXplXG4gICAgICB0LmZhcmFkYXlcbiAgICAgID9tYXNrXG4gICAgICB+aXNfZmluOnRydWVcbiAgICAgIH5vcGNvZGU6YFBvbmdcbiAgICAgIH5zcmNfb2ZmOjBcbiAgICAgIH5wYXlsb2FkOmJ1ZmZlclxuICAgICAgfm9mZlxuICAgICAgfmxlbjtcbiAgZW5kO1xuICB3YWtldXAgdFxuXG5sZXQgZmx1c2hlZCB0IGYgPSBGYXJhZGF5LmZsdXNoIHQuZmFyYWRheSBmXG5cbmxldCBjbG9zZSA/Y29kZSB0ID1cbiAgYmVnaW4gbWF0Y2ggY29kZSB3aXRoXG4gIHwgU29tZSBjb2RlIC0+XG4gICAgbGV0IG1hc2sgPSBtYXNrIHQgaW5cbiAgICBsZXQgcGF5bG9hZCA9IEJ5dGVzLmNyZWF0ZSAyIGluXG4gICAgQnl0ZXMuc2V0X3VpbnQxNl9iZSBwYXlsb2FkIDAgKFdlYnNvY2tldC5DbG9zZV9jb2RlLnRvX2ludCBjb2RlKTtcbiAgICBTZXJpYWxpemUuc2VyaWFsaXplX2J5dGVzIHQuZmFyYWRheVxuICAgICAgP21hc2tcbiAgICAgIH5pc19maW46dHJ1ZVxuICAgICAgfm9wY29kZTpgQ29ubmVjdGlvbl9jbG9zZVxuICAgICAgfnNyY19vZmY6MFxuICAgICAgfnBheWxvYWQgfm9mZjowIH5sZW46MjtcbiAgfCBOb25lIC0+ICgpXG4gIGVuZDtcbiAgRmFyYWRheS5jbG9zZSB0LmZhcmFkYXk7XG4gIHdha2V1cCB0XG5cbmxldCBlcnJvcl9jb2RlIHQgPVxuICBtYXRjaCB0LmVycm9yX2NvZGUgd2l0aFxuICB8ICNlcnJvciBhcyBlcnJvciAtPiBTb21lIGVycm9yXG4gIHwgYE9rICAgICAgICAgICAgIC0+IE5vbmVcblxubGV0IHJlcG9ydF9lcnJvciB0IGVycm9yID1cbiAgbWF0Y2ggdC5lcnJvcl9jb2RlIHdpdGhcbiAgfCBgT2sgLT5cbiAgICB0LmVycm9yX2NvZGUgPC0gKGVycm9yIDo+IFtgT2sgfCBlcnJvcl0pO1xuICAgIGlmIG5vdCAoaXNfY2xvc2VkIHQpXG4gICAgdGhlbiB0LmVycm9yX2hhbmRsZXIgdCBlcnJvclxuICB8IGBFeG4gX2V4biAtPlxuICAgIGNsb3NlIH5jb2RlOmBBYm5vcm1hbF9jbG9zdXJlIHRcblxubGV0IG5leHQgdCA9XG4gIG1hdGNoIEZhcmFkYXkub3BlcmF0aW9uIHQuZmFyYWRheSB3aXRoXG4gIHwgYENsb3NlICAgICAgICAgLT4gYENsb3NlIDAgKCogWFhYKGFuZHJlYXMpOiBzaG91bGQgdHJhY2sgdW53cml0dGVuIGJ5dGVzICopXG4gIHwgYFlpZWxkICAgICAgICAgLT4gYFlpZWxkXG4gIHwgYFdyaXRldiBpb3ZlY3MgLT4gYFdyaXRlIGlvdmVjc1xuXG5sZXQgcmVwb3J0X3Jlc3VsdCB0IHJlc3VsdCA9XG4gIG1hdGNoIHJlc3VsdCB3aXRoXG4gIHwgYENsb3NlZCAtPiBjbG9zZSB0XG4gIHwgYE9rIGxlbiAtPiBGYXJhZGF5LnNoaWZ0IHQuZmFyYWRheSBsZW5cbiIsIm1vZHVsZSBIdHRwYWYgPSBEcmVhbV9odHRwYWZfLkh0dHBhZlxuXG5tb2R1bGUgSGVhZGVycyA9IEh0dHBhZi5IZWFkZXJzXG5cbmxldCBjcmVhdGVfcmVxdWVzdCB+bm9uY2UgfmhlYWRlcnMgdGFyZ2V0ID1cbiAgbGV0IG5vbmNlID0gQmFzZTY0LmVuY29kZV9leG4gbm9uY2UgaW5cbiAgbGV0IGhlYWRlcnMgPVxuICAgIEhlYWRlcnMuYWRkX2xpc3RcbiAgICAgIGhlYWRlcnNcbiAgICAgIFsgXCJ1cGdyYWRlXCIgICAgICAgICAgICAgICwgXCJ3ZWJzb2NrZXRcIlxuICAgICAgOyBcImNvbm5lY3Rpb25cIiAgICAgICAgICAgLCBcInVwZ3JhZGVcIlxuICAgICAgOyBcInNlYy13ZWJzb2NrZXQtdmVyc2lvblwiLCBcIjEzXCJcbiAgICAgIDsgXCJzZWMtd2Vic29ja2V0LWtleVwiICAgICwgbm9uY2VcbiAgICAgIF1cbiAgaW5cbiAgSHR0cGFmLlJlcXVlc3QuY3JlYXRlIH5oZWFkZXJzIGBHRVQgdGFyZ2V0XG5cbmxldCBzZWNfd2Vic29ja2V0X2tleV9wcm9vZiB+c2hhMSBzZWNfd2Vic29ja2V0X2tleSA9XG4gICgqIEZyb20gUkZDNjQ1NcKnMS4zOlxuICAgKiAgIEZvciB0aGlzIGhlYWRlciBmaWVsZCwgdGhlIHNlcnZlciBoYXMgdG8gdGFrZSB0aGUgdmFsdWUgKGFzIHByZXNlbnRcbiAgICogICBpbiB0aGUgaGVhZGVyIGZpZWxkLCBlLmcuLCB0aGUgYmFzZTY0LWVuY29kZWQgW1JGQzQ2NDhdIHZlcnNpb24gbWludXNcbiAgICogICBhbnkgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSkgYW5kIGNvbmNhdGVuYXRlIHRoaXMgd2l0aCB0aGVcbiAgICogICBHbG9iYWxseSBVbmlxdWUgSWRlbnRpZmllciAoR1VJRCwgW1JGQzQxMjJdKSBcIjI1OEVBRkE1LUU5MTQtNDdEQS1cbiAgICogICA5NUNBLUM1QUIwREM4NUIxMVwiIGluIHN0cmluZyBmb3JtLCB3aGljaCBpcyB1bmxpa2VseSB0byBiZSB1c2VkIGJ5XG4gICAqICAgbmV0d29yayBlbmRwb2ludHMgdGhhdCBkbyBub3QgdW5kZXJzdGFuZCB0aGUgV2ViU29ja2V0IFByb3RvY29sLiAgQVxuICAgKiAgIFNIQS0xIGhhc2ggKDE2MCBiaXRzKSBbRklQUy4xODAtM10sIGJhc2U2NC1lbmNvZGVkIChzZWUgU2VjdGlvbiA0IG9mXG4gICAqICAgW1JGQzQ2NDhdKSwgb2YgdGhpcyBjb25jYXRlbmF0aW9uIGlzIHRoZW4gcmV0dXJuZWQgaW4gdGhlIHNlcnZlcidzXG4gICAqICAgaGFuZHNoYWtlLiAqKVxuICBsZXQgY29uY2F0ZW5hdGlvbiA9XG4gICBzZWNfd2Vic29ja2V0X2tleSBeIFwiMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExXCJcbiAgaW5cbiAgQmFzZTY0LmVuY29kZV9leG4gfnBhZDp0cnVlIChzaGExIGNvbmNhdGVuYXRpb24pXG5cbigqIENvcGllZCBmcm9tIGhlYWRlcnMubWwgaW4gaHR0cC9hZi5cbiAqIENvbXBhcmVzIEFTQ0lJIHN0cmluZ3MgaW4gYSBDYXNlIEluc2Vuc2l0aXZlIG1hbm5lci4gKilcbm1vZHVsZSBDSSA9IHN0cnVjdFxuICBsZXRbQGlubGluZSBhbHdheXNdIGxvd2VyIGMgPVxuICAgIGlmIGMgPj0gMHg0MSAmJiBjIDw9IDB4NWEgdGhlbiBjICsgMzIgZWxzZSBjXG5cbiAgbGV0IGVxdWFsIHggeSA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggeCBpblxuICAgIGxlbiA9IFN0cmluZy5sZW5ndGggeSAmJiAoXG4gICAgICBsZXQgZXF1YWxfc29fZmFyID0gcmVmIHRydWUgaW5cbiAgICAgIGxldCBpICAgICAgICAgICAgPSByZWYgMCBpblxuICAgICAgd2hpbGUgIWVxdWFsX3NvX2ZhciAmJiAhaSA8IGxlbiBkb1xuICAgICAgICBsZXQgYzEgPSBDaGFyLmNvZGUgKFN0cmluZy51bnNhZmVfZ2V0IHggIWkpIGluXG4gICAgICAgIGxldCBjMiA9IENoYXIuY29kZSAoU3RyaW5nLnVuc2FmZV9nZXQgeSAhaSkgaW5cbiAgICAgICAgZXF1YWxfc29fZmFyIDo9IGxvd2VyIGMxID0gbG93ZXIgYzI7XG4gICAgICAgIGluY3IgaVxuICAgICAgZG9uZTtcbiAgICAgICFlcXVhbF9zb19mYXJcbiAgICApXG5lbmRcblxuKCogVE9ETzogdGhpcyBmdW5jdGlvbiBjYW4ganVzdCByZXR1cm4gdGhlIHJlYXNvbiAqKVxubGV0IHBhc3Nlc19zY3J1dGlueSB+cmVxdWVzdF9tZXRob2QgaGVhZGVycyA9XG4gICgqIEZyb20gUkZDNjQ1NcKnNC4yLjE6XG4gICAqICAgVGhlIGNsaWVudCdzIG9wZW5pbmcgaGFuZHNoYWtlIGNvbnNpc3RzIG9mIHRoZSBmb2xsb3dpbmcgcGFydHMuIElmIHRoZVxuICAgKiAgIHNlcnZlciwgd2hpbGUgcmVhZGluZyB0aGUgaGFuZHNoYWtlLCBmaW5kcyB0aGF0IHRoZSBjbGllbnQgZGlkIG5vdCBzZW5kXG4gICAqICAgYSBoYW5kc2hha2UgdGhhdCBtYXRjaGVzIHRoZSBkZXNjcmlwdGlvbiBiZWxvdyBbLi4uXSwgdGhlIHNlcnZlciBNVVNUXG4gICAqICAgc3RvcCBwcm9jZXNzaW5nIHRoZSBjbGllbnQncyBoYW5kc2hha2UgYW5kIHJldHVybiBhbiBIVFRQIHJlc3BvbnNlIHdpdGhcbiAgICogICBhbiBhcHByb3ByaWF0ZSBlcnJvciBjb2RlIChzdWNoIGFzIDQwMCBCYWQgUmVxdWVzdCkuXG4gICAqXG4gICAqICAgMS4gQW4gSFRUUC8xLjEgb3IgaGlnaGVyIEdFVCByZXF1ZXN0LCBpbmNsdWRpbmcgYSBcIlJlcXVlc3QtVVJJXCJcbiAgICogICAgICBbUkZDMjYxNl0gWy4uLl0uXG4gICAqXG4gICAqICAgMi4gQSB8SG9zdHwgaGVhZGVyIGZpZWxkIGNvbnRhaW5pbmcgdGhlIHNlcnZlcidzIGF1dGhvcml0eS5cbiAgICpcbiAgICogICAzLiBBbiB8VXBncmFkZXwgaGVhZGVyIGZpZWxkIGNvbnRhaW5pbmcgdGhlIHZhbHVlIFwid2Vic29ja2V0XCIsIHRyZWF0ZWRcbiAgICogICAgICBhcyBhbiBBU0NJSSBjYXNlLWluc2Vuc2l0aXZlIHZhbHVlLlxuICAgKlxuICAgKiAgIDQuIEEgfENvbm5lY3Rpb258IGhlYWRlciBmaWVsZCB0aGF0IGluY2x1ZGVzIHRoZSB0b2tlbiBcIlVwZ3JhZGVcIix0cmVhdGVkXG4gICAqICAgICAgYXMgYW4gQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSB2YWx1ZS5cbiAgICpcbiAgICogICA1LiBBIHxTZWMtV2ViU29ja2V0LUtleXwgaGVhZGVyIGZpZWxkIHdpdGggYSBiYXNlNjQtZW5jb2RlZCAoc2VlIFNlY3Rpb25cbiAgICogICAgICA0IG9mIFtSRkM0NjQ4XSkgdmFsdWUgdGhhdCwgd2hlbiBkZWNvZGVkLCBpcyAxNiBieXRlcyBpbiBsZW5ndGguXG4gICAqXG4gICAqICAgNi4gQSB8U2VjLVdlYlNvY2tldC1WZXJzaW9ufCBoZWFkZXIgZmllbGQsIHdpdGggYSB2YWx1ZSBvZiAxMy5cbiAgICpcbiAgICogICBbLi4uXVxuICAgKlxuICAgKiAgIE5vdGU6IHRoZXJlIGFyZSA5IHBvaW50cyBpbiB0aGUgYWJvdmUgc2VjdGlvbiBvZiB0aGUgUkZDLCBhbmQgdGhlIGxhc3RcbiAgICogICAzIHJlZmVyIHRvIG9wdGlvbmFsIGZpZWxkcy5cbiAgICopXG4gbWF0Y2hcbiAgIHJlcXVlc3RfbWV0aG9kLFxuICAgSGVhZGVycy5nZXRfZXhuIGhlYWRlcnMgXCJob3N0XCIsXG4gICBIZWFkZXJzLmdldF9leG4gaGVhZGVycyBcInVwZ3JhZGVcIixcbiAgIEhlYWRlcnMuZ2V0X2V4biBoZWFkZXJzIFwiY29ubmVjdGlvblwiLFxuICAgSGVhZGVycy5nZXRfZXhuIGhlYWRlcnMgXCJzZWMtd2Vic29ja2V0LWtleVwiLFxuICAgSGVhZGVycy5nZXRfZXhuIGhlYWRlcnMgXCJzZWMtd2Vic29ja2V0LXZlcnNpb25cIlxuICAgd2l0aFxuICAgKCogMSwgICAyICopXG4gfCBgR0VULCBfaG9zdCwgdXBncmFkZSwgY29ubmVjdGlvbiwgc2VjX3dlYnNvY2tldF9rZXksIFwiMTNcIiAtPlxuICAgKCogMyAqKVxuICAgQ0kuZXF1YWwgdXBncmFkZSBcIndlYnNvY2tldFwiICYmXG4gICAoKiA0ICopXG4gICAoTGlzdC5leGlzdHNcbiAgICAgKGZ1biB2IC0+IENJLmVxdWFsIChTdHJpbmcudHJpbSB2KSBcInVwZ3JhZGVcIilcbiAgICAgKFN0cmluZy5zcGxpdF9vbl9jaGFyICcsJyBjb25uZWN0aW9uKSkgJiZcbiAgICgqIDUgKilcbiAgICh0cnkgU3RyaW5nLmxlbmd0aCAoQmFzZTY0LmRlY29kZV9leG4gfnBhZDp0cnVlIHNlY193ZWJzb2NrZXRfa2V5KSA9IDE2XG4gICAgd2l0aCB8IF8gLT4gZmFsc2UpXG4gfCBfIC0+IGZhbHNlXG4gfCBleGNlcHRpb24gXyAtPiBmYWxzZVxuXG5sZXQgdXBncmFkZV9oZWFkZXJzIH5zaGExIH5yZXF1ZXN0X21ldGhvZCBoZWFkZXJzID1cbiAgaWYgcGFzc2VzX3NjcnV0aW55IH5yZXF1ZXN0X21ldGhvZCBoZWFkZXJzIHRoZW4gYmVnaW5cbiAgICBsZXQgc2VjX3dlYnNvY2tldF9rZXkgPSBIZWFkZXJzLmdldF9leG4gaGVhZGVycyBcInNlYy13ZWJzb2NrZXQta2V5XCIgaW5cbiAgICBsZXQgYWNjZXB0ID0gc2VjX3dlYnNvY2tldF9rZXlfcHJvb2YgfnNoYTEgc2VjX3dlYnNvY2tldF9rZXkgaW5cbiAgICBsZXQgdXBncmFkZV9oZWFkZXJzID1cbiAgICAgIFsgXCJVcGdyYWRlXCIsICAgICAgICAgICAgICBcIndlYnNvY2tldFwiXG4gICAgICA7IFwiQ29ubmVjdGlvblwiLCAgICAgICAgICAgXCJ1cGdyYWRlXCJcbiAgICAgIDsgXCJTZWMtV2Vic29ja2V0LUFjY2VwdFwiLCBhY2NlcHRcbiAgICAgIF1cbiAgICBpblxuICAgIE9rIHVwZ3JhZGVfaGVhZGVyc1xuICBlbmQgZWxzZVxuICAgIEVycm9yIFwiRGlkbid0IHBhc3Mgc2NydXRpbnlcIlxuXG5sZXQgcmVzcG9uZF93aXRoX3VwZ3JhZGUgPyhoZWFkZXJzPUhlYWRlcnMuZW1wdHkpIH5zaGExIHJlcWQgdXBncmFkZV9oYW5kbGVyID1cbiAgbGV0IHJlcXVlc3QgPSBIdHRwYWYuUmVxZC5yZXF1ZXN0IHJlcWQgaW5cbiAgbWF0Y2ggdXBncmFkZV9oZWFkZXJzIH5zaGExIH5yZXF1ZXN0X21ldGhvZDpyZXF1ZXN0Lm1ldGggcmVxdWVzdC5oZWFkZXJzIHdpdGhcbiAgfCBPayB1cGdyYWRlX2hlYWRlcnMgLT5cbiAgICBIdHRwYWYuUmVxZC5yZXNwb25kX3dpdGhfdXBncmFkZSByZXFkIChIZWFkZXJzLmFkZF9saXN0IGhlYWRlcnMgdXBncmFkZV9oZWFkZXJzKSB1cGdyYWRlX2hhbmRsZXI7XG4gICAgT2sgKClcbiAgfCBFcnJvciBtc2cgLT4gRXJyb3IgbXNnXG4iLCJtb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcblxubW9kdWxlIElPVmVjID0gSHR0cGFmLklPVmVjXG5cbnR5cGUgdCA9XG4gIHsgY29ubmVjdGlvbiA6IEh0dHBhZi5DbGllbnRfY29ubmVjdGlvbi50XG4gIDsgYm9keSAgICAgICA6IEh0dHBhZi5Cb2R5LldyaXRlci50IH1cblxuKCogVE9ETyhhbm1vbnRlaXJvKTogeWV0IGFub3RoZXIgYXJndW1lbnQsIGB+Y29uZmlnYCAqKVxubGV0IGNyZWF0ZVxuICAgIH5ub25jZVxuICAgIH5oZWFkZXJzXG4gICAgfmVycm9yX2hhbmRsZXJcbiAgICB+cmVzcG9uc2VfaGFuZGxlclxuICAgIHRhcmdldFxuICA9XG4gIGxldCBjb25uZWN0aW9uID0gSHR0cGFmLkNsaWVudF9jb25uZWN0aW9uLmNyZWF0ZSAoKSBpblxuICBsZXQgYm9keSA9XG4gICAgSHR0cGFmLkNsaWVudF9jb25uZWN0aW9uLnJlcXVlc3RcbiAgICAgIGNvbm5lY3Rpb25cbiAgICAgIChIYW5kc2hha2UuY3JlYXRlX3JlcXVlc3Qgfm5vbmNlIH5oZWFkZXJzIHRhcmdldClcbiAgICAgIH5lcnJvcl9oYW5kbGVyXG4gICAgICB+cmVzcG9uc2VfaGFuZGxlclxuICAgICAgfmZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHk6dHJ1ZVxuICBpblxuICB7IGNvbm5lY3Rpb25cbiAgOyBib2R5XG4gIH1cbjs7XG5cbmxldCBuZXh0X3JlYWRfb3BlcmF0aW9uIHQgPVxuICBIdHRwYWYuQ2xpZW50X2Nvbm5lY3Rpb24ubmV4dF9yZWFkX29wZXJhdGlvbiB0LmNvbm5lY3Rpb25cblxubGV0IG5leHRfd3JpdGVfb3BlcmF0aW9uIHQgPVxuICBIdHRwYWYuQ2xpZW50X2Nvbm5lY3Rpb24ubmV4dF93cml0ZV9vcGVyYXRpb24gdC5jb25uZWN0aW9uXG5cbmxldCByZWFkIHQgPVxuICBIdHRwYWYuQ2xpZW50X2Nvbm5lY3Rpb24ucmVhZCB0LmNvbm5lY3Rpb25cblxubGV0IHlpZWxkX3JlYWRlciB0ID1cbiAgSHR0cGFmLkNsaWVudF9jb25uZWN0aW9uLnlpZWxkX3JlYWRlciB0LmNvbm5lY3Rpb25cblxubGV0IHJlcG9ydF93cml0ZV9yZXN1bHQgdCA9XG4gIEh0dHBhZi5DbGllbnRfY29ubmVjdGlvbi5yZXBvcnRfd3JpdGVfcmVzdWx0IHQuY29ubmVjdGlvblxuXG5sZXQgeWllbGRfd3JpdGVyIHQgPVxuICBIdHRwYWYuQ2xpZW50X2Nvbm5lY3Rpb24ueWllbGRfd3JpdGVyIHQuY29ubmVjdGlvblxuXG5sZXQgcmVwb3J0X2V4biB0IGV4biA9XG4gIEh0dHBhZi5DbGllbnRfY29ubmVjdGlvbi5yZXBvcnRfZXhuIHQuY29ubmVjdGlvbiBleG5cblxubGV0IGlzX2Nsb3NlZCB0ID1cbiAgSHR0cGFmLkNsaWVudF9jb25uZWN0aW9uLmlzX2Nsb3NlZCB0LmNvbm5lY3Rpb25cblxubGV0IGNsb3NlIHQgPVxuICBIdHRwYWYuQm9keS5Xcml0ZXIuY2xvc2UgdC5ib2R5O1xuICBIdHRwYWYuQ2xpZW50X2Nvbm5lY3Rpb24uc2h1dGRvd24gdC5jb25uZWN0aW9uXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggSW5oYWJpdGVkIFR5cGUgTExDLlxuICogIENvcHlyaWdodCAoYykgMjAyMSBBbnTDs25pbyBOdW5vIE1vbnRlaXJvXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogIGFyZSBtZXQ6XG4gKlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gKiAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gKiAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gKiAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gKiAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gKiAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICogIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICogIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxubW9kdWxlIEh0dHBhZiA9IERyZWFtX2h0dHBhZl8uSHR0cGFmXG5cbm1vZHVsZSBJT1ZlYyA9IEh0dHBhZi5JT1ZlY1xuXG4gIHR5cGUgdCA9XG4gIHsgZmFyYWRheSA6IEZhcmFkYXkudFxuICA7IG11dGFibGUgcmVhZF9zY2hlZHVsZWQgOiBib29sXG4gIDsgbXV0YWJsZSBvbl9lb2YgOiB1bml0IC0+IHVuaXRcbiAgOyBtdXRhYmxlIG9uX3JlYWQgOiBCaWdzdHJpbmdhZi50IC0+IG9mZjppbnQgLT4gbGVuOmludCAtPiB1bml0XG4gIH1cblxuICBsZXQgZGVmYXVsdF9vbl9lb2YgICAgICAgICA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgKGZ1biAoKSAtPiAoKSlcbiAgbGV0IGRlZmF1bHRfb25fcmVhZCAgICAgICAgPSBTeXMub3BhcXVlX2lkZW50aXR5IChmdW4gXyB+b2ZmOl8gfmxlbjpfIC0+ICgpKVxuXG4gIGxldCBvZl9mYXJhZGF5IGZhcmFkYXkgPVxuICAgIHsgZmFyYWRheVxuICAgIDsgcmVhZF9zY2hlZHVsZWQgICAgICAgICA9IGZhbHNlXG4gICAgOyBvbl9lb2YgICAgICAgICAgICAgICAgID0gZGVmYXVsdF9vbl9lb2ZcbiAgICA7IG9uX3JlYWQgICAgICAgICAgICAgICAgPSBkZWZhdWx0X29uX3JlYWRcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSBidWZmZXIgPVxuICAgIG9mX2ZhcmFkYXkgKEZhcmFkYXkub2ZfYmlnc3RyaW5nIGJ1ZmZlcilcblxuICBsZXQgY3JlYXRlX2VtcHR5ICgpID1cbiAgICBsZXQgdCA9IGNyZWF0ZSBCaWdzdHJpbmdhZi5lbXB0eSBpblxuICAgIEZhcmFkYXkuY2xvc2UgdC5mYXJhZGF5O1xuICAgIHRcblxuICBsZXQgZW1wdHkgPSBjcmVhdGVfZW1wdHkgKClcblxuICBsZXQgaXNfY2xvc2VkIHQgPVxuICAgIEZhcmFkYXkuaXNfY2xvc2VkIHQuZmFyYWRheVxuXG4gIGxldCB1bnNhZmVfZmFyYWRheSB0ID1cbiAgICB0LmZhcmFkYXlcblxuICBsZXQgcmVjIGRvX2V4ZWN1dGVfcmVhZCB0IG9uX2VvZiBvbl9yZWFkID1cbiAgICBtYXRjaCBGYXJhZGF5Lm9wZXJhdGlvbiB0LmZhcmFkYXkgd2l0aFxuICAgIHwgYFlpZWxkICAgICAgICAgICAtPiAoKVxuICAgIHwgYENsb3NlICAgICAgICAgICAtPlxuICAgICAgdC5yZWFkX3NjaGVkdWxlZCA8LSBmYWxzZTtcbiAgICAgIHQub25fZW9mICAgICAgICAgPC0gZGVmYXVsdF9vbl9lb2Y7XG4gICAgICB0Lm9uX3JlYWQgICAgICAgIDwtIGRlZmF1bHRfb25fcmVhZDtcbiAgICAgIG9uX2VvZiAoKVxuICAgIHwgYFdyaXRldiBbXSAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IGBXcml0ZXYgKGlvdmVjOjpfKSAtPlxuICAgICAgdC5yZWFkX3NjaGVkdWxlZCA8LSBmYWxzZTtcbiAgICAgIHQub25fZW9mICAgICAgICAgPC0gZGVmYXVsdF9vbl9lb2Y7XG4gICAgICB0Lm9uX3JlYWQgICAgICAgIDwtIGRlZmF1bHRfb25fcmVhZDtcbiAgICAgIGxldCB7IElPVmVjLmJ1ZmZlcjsgb2ZmOyBsZW4gfSA9IGlvdmVjIGluXG4gICAgICBGYXJhZGF5LnNoaWZ0IHQuZmFyYWRheSBsZW47XG4gICAgICBvbl9yZWFkIGJ1ZmZlciB+b2ZmIH5sZW47XG4gICAgICBleGVjdXRlX3JlYWQgdFxuICBhbmQgZXhlY3V0ZV9yZWFkIHQgPVxuICAgIGlmIHQucmVhZF9zY2hlZHVsZWQgdGhlbiBkb19leGVjdXRlX3JlYWQgdCB0Lm9uX2VvZiB0Lm9uX3JlYWRcblxuICBsZXQgc2NoZWR1bGVfcmVhZCB0IH5vbl9lb2Ygfm9uX3JlYWQgPVxuICAgIGlmIHQucmVhZF9zY2hlZHVsZWRcbiAgICB0aGVuIGZhaWx3aXRoIFwiUGF5bG9hZC5zY2hlZHVsZV9yZWFkOiByZWFkZXIgYWxyZWFkeSBzY2hlZHVsZWRcIjtcbiAgICBpZiBub3QgKGlzX2Nsb3NlZCB0KVxuICAgIHRoZW4gYmVnaW5cbiAgICAgIHQucmVhZF9zY2hlZHVsZWQgPC0gdHJ1ZTtcbiAgICAgIHQub25fZW9mICAgICAgICAgPC0gb25fZW9mO1xuICAgICAgdC5vbl9yZWFkICAgICAgICA8LSBvbl9yZWFkO1xuICAgIGVuZDtcbiAgICBkb19leGVjdXRlX3JlYWQgdCBvbl9lb2Ygb25fcmVhZFxuXG4gIGxldCBpc19yZWFkX3NjaGVkdWxlZCB0ID0gdC5yZWFkX3NjaGVkdWxlZFxuXG4gIGxldCBjbG9zZSB0ID1cbiAgICBGYXJhZGF5LmNsb3NlIHQuZmFyYWRheTtcbiAgICBleGVjdXRlX3JlYWQgdFxuIiwidHlwZSB0ID1cbnsgaGVhZGVyczogQmlnc3RyaW5nYWYudFxuOyBwYXlsb2FkOiBQYXlsb2FkLnRcbn1cblxubGV0IGlzX2ZpbiB0ID1cbiAgbGV0IGJpdHMgPSBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IHQuaGVhZGVycyAwIHw+IENoYXIuY29kZSBpblxuICBiaXRzIGxhbmQgKDEgbHNsIDcpID0gMSBsc2wgN1xuOztcblxubGV0IHJzdiB0ID1cbiAgbGV0IGJpdHMgPSBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IHQuaGVhZGVycyAwIHw+IENoYXIuY29kZSBpblxuICAoYml0cyBsc3IgNCkgbGFuZCAwYjAxMTFcbjs7XG5cbmxldCBvcGNvZGUgdCA9XG4gIGxldCBiaXRzID0gQmlnc3RyaW5nYWYudW5zYWZlX2dldCB0LmhlYWRlcnMgMCB8PiBDaGFyLmNvZGUgaW5cbiAgYml0cyBsYW5kIDBiMTExMSB8PiBXZWJzb2NrZXQuT3Bjb2RlLnVuc2FmZV9vZl9jb2RlXG47O1xuXG5sZXQgcGF5bG9hZF9sZW5ndGhfb2ZfaGVhZGVycyBoZWFkZXJzID1cbiAgbGV0IGJpdHMgPSBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IGhlYWRlcnMgMSB8PiBDaGFyLmNvZGUgaW5cbiAgbGV0IGxlbmd0aCA9IGJpdHMgbGFuZCAwYjAxMTExMTExIGluXG4gIGlmIGxlbmd0aCA9IDEyNiB0aGVuIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfYmUgaGVhZGVycyAyICAgICAgICAgICAgICAgICBlbHNlXG4gICgqIFRoaXMgaXMgdGVjaG5pY2FsbHkgdW5zYWZlLCBidXQgaWYgc29tZWJvZHkncyBhc2tpbmcgdXMgdG8gcmVhZCAyXjYzXG4gICAqIGJ5dGVzLCB0aGVuIHdlJ3JlIGFscmVhZHkgc2NyZXdlZC4gKilcbiAgaWYgbGVuZ3RoID0gMTI3IHRoZW4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9iZSBoZWFkZXJzIDIgfD4gSW50NjQudG9faW50IGVsc2VcbiAgbGVuZ3RoXG47O1xuXG5sZXQgcGF5bG9hZF9sZW5ndGggdCA9IHBheWxvYWRfbGVuZ3RoX29mX2hlYWRlcnMgdC5oZWFkZXJzXG5cbmxldCBoYXNfbWFzayB0ID1cbiAgbGV0IGJpdHMgPSBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IHQuaGVhZGVycyAxIHw+IENoYXIuY29kZSBpblxuICBiaXRzIGxhbmQgKDEgbHNsIDcpID0gMSBsc2wgN1xuOztcblxubGV0IG1hc2sgdCA9XG4gIGlmIG5vdCAoaGFzX21hc2sgdClcbiAgdGhlbiBOb25lXG4gIGVsc2VcbiAgICBTb21lIChcbiAgICAgIGxldCBiaXRzID0gQmlnc3RyaW5nYWYudW5zYWZlX2dldCB0LmhlYWRlcnMgMSB8PiBDaGFyLmNvZGUgaW5cbiAgICAgIGlmIGJpdHMgID0gMjU0IHRoZW4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9iZSB0LmhlYWRlcnMgNCAgZWxzZVxuICAgICAgaWYgYml0cyAgPSAyNTUgdGhlbiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2JlIHQuaGVhZGVycyAxMCBlbHNlXG4gICAgICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2JlIHQuaGVhZGVycyAyKVxuOztcblxubGV0IG1hc2tfZXhuIHQgPVxuICBsZXQgYml0cyA9IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXQgdC5oZWFkZXJzIDEgfD4gQ2hhci5jb2RlIGluXG4gIGlmIGJpdHMgID0gMjU0IHRoZW4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9iZSB0LmhlYWRlcnMgNCAgZWxzZVxuICBpZiBiaXRzICA9IDI1NSB0aGVuIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfYmUgdC5oZWFkZXJzIDEwIGVsc2VcbiAgaWYgYml0cyA+PSAxMjcgdGhlbiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2JlIHQuaGVhZGVycyAyICBlbHNlXG4gIGZhaWx3aXRoIFwiRnJhbWUubWFza19leG46IG5vIG1hc2sgcHJlc2VudFwiXG47O1xuXG5sZXQgbGVuZ3RoIHQgPVxuICBsZXQgcGF5bG9hZF9sZW5ndGggPSBwYXlsb2FkX2xlbmd0aCB0IGluXG4gIEJpZ3N0cmluZ2FmLmxlbmd0aCB0LmhlYWRlcnMgKyBwYXlsb2FkX2xlbmd0aFxuOztcblxubGV0IHBheWxvYWRfb2Zmc2V0X29mX2JpdHMgYml0cyA9XG4gIGxldCBpbml0aWFsX29mZnNldCA9IDIgaW5cbiAgbGV0IG1hc2tfb2Zmc2V0ICAgID0gKGJpdHMgbGFuZCAoMSBsc2wgNykpIGxzciAoNyAtIDIpIGluXG4gIGxldCBsZW5ndGhfb2Zmc2V0ICA9XG4gICAgbGV0IGxlbmd0aCA9IGJpdHMgbGFuZCAwYjAxMTExMTExIGluXG4gICAgaWYgbGVuZ3RoIDwgMTI2XG4gICAgdGhlbiAwXG4gICAgZWxzZSAyIGxzbCAoKGxlbmd0aCBsYW5kIDBiMSkgbHNsIDIpXG4gIGluXG4gIGluaXRpYWxfb2Zmc2V0ICsgbWFza19vZmZzZXQgKyBsZW5ndGhfb2Zmc2V0XG47O1xuXG5sZXQgcGF5bG9hZF9vZmZzZXQgPyhvZmY9MCkgYnMgPVxuICBsZXQgYml0cyA9IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXQgYnMgKG9mZiArIDEpIHw+IENoYXIuY29kZSBpblxuICBwYXlsb2FkX29mZnNldF9vZl9iaXRzIGJpdHNcbjs7XG5cbmxldCBwYXJzZV9oZWFkZXJzID1cbiAgbGV0IG9wZW4gQW5nc3Ryb20gaW5cbiAgVW5zYWZlLnBlZWsgMiAoZnVuIGJzIH5vZmYgfmxlbjpfIC0+IHBheWxvYWRfb2Zmc2V0IH5vZmYgYnMpXG4gID4+PSBmdW4gaGVhZGVyc19sZW4gLT4gVW5zYWZlLnRha2UgaGVhZGVyc19sZW4gQmlnc3RyaW5nYWYuc3ViXG47O1xuXG5sZXQgcGF5bG9hZF9wYXJzZXIgdCA9XG4gIGxldCBvcGVuIEFuZ3N0cm9tIGluXG4gIGxldCB1bm1hc2sgdCBicyB+c3JjX29mZiA9XG4gICAgbWF0Y2ggbWFzayB0IHdpdGhcbiAgICB8IE5vbmUgLT4gYnNcbiAgICB8IFNvbWUgbWFzayAtPlxuICAgICAgV2Vic29ja2V0LkZyYW1lLmFwcGx5X21hc2sgbWFzayBicyB+c3JjX29mZjtcbiAgICAgIGJzXG4gIGluXG4gIGxldCBmaW5pc2ggcGF5bG9hZCA9XG4gICAgbGV0IG9wZW4gQW5nc3Ryb20gaW5cbiAgICBQYXlsb2FkLmNsb3NlIHBheWxvYWQ7XG4gICAgY29tbWl0XG4gIGluXG4gIGxldCBzY2hlZHVsZV9zaXplIH5zcmNfb2ZmIHBheWxvYWQgbiA9XG4gICAgbGV0IG9wZW4gQW5nc3Ryb20gaW5cbiAgICBiZWdpbiBpZiBQYXlsb2FkLmlzX2Nsb3NlZCBwYXlsb2FkXG4gICAgdGhlbiBhZHZhbmNlIG5cbiAgICBlbHNlIHRha2VfYmlnc3RyaW5nIG4gPj58IGZ1biBicyAtPlxuICAgICAgbGV0IGZhcmFkYXkgPSBQYXlsb2FkLnVuc2FmZV9mYXJhZGF5IHBheWxvYWQgaW5cbiAgICAgIEZhcmFkYXkuc2NoZWR1bGVfYmlnc3RyaW5nIGZhcmFkYXkgKHVubWFzayB+c3JjX29mZiB0IGJzKVxuICAgIGVuZCAqPiBjb21taXRcbiAgaW5cbiAgbGV0IHJlYWRfZXhhY3QgPVxuICAgIGxldCByZWMgcmVhZF9leGFjdCBzcmNfb2ZmIG4gPVxuICAgICAgaWYgbiA9IDBcbiAgICAgIHRoZW4gcmV0dXJuICgpXG4gICAgICBlbHNlXG4gICAgICAgIGF0X2VuZF9vZl9pbnB1dFxuICAgICAgICA+Pj0gZnVuY3Rpb25cbiAgICAgICAgICB8IHRydWUgLT4gY29tbWl0ICo+IGZhaWwgXCJtaXNzaW5nIHBheWxvYWQgYnl0ZXNcIlxuICAgICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICAgIGF2YWlsYWJsZSA+Pj0gZnVuIG0gLT5cbiAgICAgICAgICAgIGxldCBtJyA9IChtaW4gbSBuKSBpblxuICAgICAgICAgICAgbGV0IG4nID0gbiAtIG0nIGluXG4gICAgICAgICAgICBzY2hlZHVsZV9zaXplIH5zcmNfb2ZmIHQucGF5bG9hZCBtJyA+Pj0gZnVuICgpIC0+IHJlYWRfZXhhY3QgKHNyY19vZmYgKyBtJykgbidcbiAgICBpblxuICAgIGZ1biBuIC0+IHJlYWRfZXhhY3QgMCBuXG4gIGluXG4gIHJlYWRfZXhhY3QgKHBheWxvYWRfbGVuZ3RoIHQpXG4gID4+PSBmdW4gKCkgLT4gZmluaXNoIHQucGF5bG9hZFxuOztcblxubGV0IGZyYW1lIH5idWYgPVxuICBsZXQgb3BlbiBBbmdzdHJvbSBpblxuICBwYXJzZV9oZWFkZXJzXG4gID4+fCBmdW4gaGVhZGVycyAtPlxuICAgIGxldCBsZW4gPSBwYXlsb2FkX2xlbmd0aF9vZl9oZWFkZXJzIGhlYWRlcnMgaW5cbiAgICBsZXQgcGF5bG9hZCA9IG1hdGNoIGxlbiB3aXRoXG4gICAgfCAwIC0+IFBheWxvYWQuZW1wdHlcbiAgICB8IF8gLT4gUGF5bG9hZC5jcmVhdGUgYnVmXG4gICAgaW5cbiAgICB7IGhlYWRlcnM7IHBheWxvYWQgfVxuOztcblxubW9kdWxlIFJlYWRlciA9IHN0cnVjdFxuICBtb2R1bGUgQVUgPSBBbmdzdHJvbS5VbmJ1ZmZlcmVkXG5cbiAgdHlwZSAnZXJyb3IgcGFyc2Vfc3RhdGUgPVxuICAgIHwgRG9uZVxuICAgIHwgRmFpbCAgICBvZiAnZXJyb3JcbiAgICB8IFBhcnRpYWwgb2YgKEJpZ3N0cmluZ2FmLnQgLT4gb2ZmOmludCAtPiBsZW46aW50IC0+IEFVLm1vcmUgLT4gdW5pdCBBVS5zdGF0ZSlcblxuICB0eXBlICdlcnJvciB0ID1cbiAgICB7IHBhcnNlciA6IHVuaXQgQW5nc3Ryb20udFxuICAgIDsgbXV0YWJsZSBwYXJzZV9zdGF0ZSA6ICdlcnJvciBwYXJzZV9zdGF0ZVxuICAgIDsgbXV0YWJsZSBjbG9zZWQgICAgICA6IGJvb2wgfVxuXG4gIGxldCBjcmVhdGUgZnJhbWVfaGFuZGxlciA9XG4gICAgbGV0IHBhcnNlciA9XG4gICAgICBsZXQgb3BlbiBBbmdzdHJvbSBpblxuICAgICAgbGV0IGJ1ZiA9IEJpZ3N0cmluZ2FmLmNyZWF0ZSAweDEwMDAgaW5cbiAgICAgIHNraXBfbWFueVxuICAgICAgICAoZnJhbWUgfmJ1ZiA8KiBjb21taXQgPj49IGZ1biBmcmFtZSAtPlxuICAgICAgICAgIGxldCBwYXlsb2FkID0gZnJhbWUucGF5bG9hZCBpblxuICAgICAgICAgIGxldCBpc19maW4gPSBpc19maW4gZnJhbWUgaW5cbiAgICAgICAgICBsZXQgb3Bjb2RlID0gb3Bjb2RlIGZyYW1lIGluXG4gICAgICAgICAgbGV0IGxlbiA9IHBheWxvYWRfbGVuZ3RoIGZyYW1lIGluXG4gICAgICAgICAgZnJhbWVfaGFuZGxlciB+b3Bjb2RlIH5pc19maW4gfmxlbiBwYXlsb2FkO1xuICAgICAgICAgIHBheWxvYWRfcGFyc2VyIGZyYW1lKVxuICAgIGluXG4gICAgeyBwYXJzZXJcbiAgICA7IHBhcnNlX3N0YXRlID0gRG9uZVxuICAgIDsgY2xvc2VkICAgICAgPSBmYWxzZVxuICAgIH1cbiAgOztcblxuICBsZXQgdHJhbnNpdGlvbiB0IHN0YXRlID1cbiAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgfCBBVS5Eb25lKGNvbnN1bWVkLCAoKSlcbiAgICB8IEFVLkZhaWwoMCBhcyBjb25zdW1lZCwgXywgXykgLT5cbiAgICAgIHQucGFyc2Vfc3RhdGUgPC0gRG9uZTtcbiAgICAgIGNvbnN1bWVkXG4gICAgfCBBVS5GYWlsKGNvbnN1bWVkLCBtYXJrcywgbXNnKSAtPlxuICAgICAgdC5wYXJzZV9zdGF0ZSA8LSBGYWlsIChgUGFyc2UobWFya3MsIG1zZykpO1xuICAgICAgY29uc3VtZWRcbiAgICB8IEFVLlBhcnRpYWwgeyBjb21taXR0ZWQ7IGNvbnRpbnVlIH0gLT5cbiAgICAgIHQucGFyc2Vfc3RhdGUgPC0gUGFydGlhbCBjb250aW51ZTtcbiAgICAgIGNvbW1pdHRlZFxuICBhbmQgc3RhcnQgdCBzdGF0ZSA9XG4gICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICB8IEFVLkRvbmUgXyAgICAgICAgIC0+IGZhaWx3aXRoIFwid2Vic29ja2V0YWYuUmVhZGVyLnVuYWJsZSB0byBzdGFydCBwYXJzZXJcIlxuICAgICAgfCBBVS5GYWlsKDAsIG1hcmtzLCBtc2cpIC0+XG4gICAgICAgIHQucGFyc2Vfc3RhdGUgPC0gRmFpbCAoYFBhcnNlKG1hcmtzLCBtc2cpKVxuICAgICAgfCBBVS5QYXJ0aWFsIHsgY29tbWl0dGVkID0gMDsgY29udGludWUgfSAtPlxuICAgICAgICB0LnBhcnNlX3N0YXRlIDwtIFBhcnRpYWwgY29udGludWVcbiAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICBsZXQgcmVjIHJlYWRfd2l0aF9tb3JlIHQgYnMgfm9mZiB+bGVuIG1vcmUgPVxuICAgIGxldCBjb25zdW1lZCA9XG4gICAgICBtYXRjaCB0LnBhcnNlX3N0YXRlIHdpdGhcbiAgICAgIHwgRmFpbCBfIC0+IDBcbiAgICAgIHwgRG9uZSAgIC0+XG4gICAgICAgIHN0YXJ0IHQgKEFVLnBhcnNlIHQucGFyc2VyKTtcbiAgICAgICAgcmVhZF93aXRoX21vcmUgIHQgYnMgfm9mZiB+bGVuIG1vcmU7XG4gICAgICB8IFBhcnRpYWwgY29udGludWUgLT5cbiAgICAgICAgdHJhbnNpdGlvbiB0IChjb250aW51ZSBicyBtb3JlIH5vZmYgfmxlbilcbiAgICBpblxuICAgIGJlZ2luIG1hdGNoIG1vcmUgd2l0aFxuICAgIHwgQ29tcGxldGUgLT4gdC5jbG9zZWQgPC0gdHJ1ZTtcbiAgICB8IEluY29tcGxldGUgLT4gKClcbiAgICBlbmQ7XG4gICAgY29uc3VtZWRcblxuICBsZXQgbmV4dCB0ID1cbiAgICBtYXRjaCB0LnBhcnNlX3N0YXRlIHdpdGhcbiAgICB8IERvbmUgLT5cbiAgICAgIGlmIHQuY2xvc2VkXG4gICAgICB0aGVuIGBDbG9zZVxuICAgICAgZWxzZSBgUmVhZFxuICAgIHwgRmFpbCBmYWlsdXJlIC0+IGBFcnJvciBmYWlsdXJlXG4gICAgfCBQYXJ0aWFsIF8gLT4gYFJlYWRcbmVuZFxuIiwibW9kdWxlIEh0dHBhZiA9IERyZWFtX2h0dHBhZl8uSHR0cGFmXG5cbm1vZHVsZSBJT1ZlYyA9IEh0dHBhZi5JT1ZlY1xubW9kdWxlIFJlYWRlciA9IFBhcnNlLlJlYWRlclxuXG50eXBlIGVycm9yID0gWyBgRXhuIG9mIGV4biBdXG5cbnR5cGUgZXJyb3JfaGFuZGxlciA9IFdzZC50IC0+IGVycm9yIC0+IHVuaXRcblxudHlwZSB0ID1cbiAgeyByZWFkZXIgOiBbYFBhcnNlIG9mIHN0cmluZyBsaXN0ICogc3RyaW5nXSBSZWFkZXIudFxuICA7IHdzZCAgICA6IFdzZC50XG4gIDsgZW9mIDogdW5pdCAtPiB1bml0XG4gIH1cblxudHlwZSBpbnB1dF9oYW5kbGVycyA9XG4gIHsgZnJhbWUgOiBvcGNvZGU6V2Vic29ja2V0Lk9wY29kZS50IC0+IGlzX2Zpbjpib29sIC0+IGxlbjppbnQgLT4gUGF5bG9hZC50IC0+IHVuaXRcbiAgOyBlb2YgICA6IHVuaXQgLT4gdW5pdCB9XG5cbigqIFRPRE86IHRoaXMgc2hvdWxkIGJlIHBhc3NlZCBhcyBhbiBhcmd1bWVudCBmcm9tIHRoZSBydW50aW1lLCB0byBhbGxvdyBmb3JcbiAqIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24uICopXG4oKiBGcm9tIFJGQzY0NTXCpzUuMzpcbiAqICAgVGhlIG1hc2tpbmcga2V5IGlzIGEgMzItYml0IHZhbHVlIGNob3NlbiBhdCByYW5kb20gYnkgdGhlIGNsaWVudC4gV2hlblxuICogICBwcmVwYXJpbmcgYSBtYXNrZWQgZnJhbWUsIHRoZSBjbGllbnQgTVVTVCBwaWNrIGEgZnJlc2ggbWFza2luZyBrZXkgZnJvbVxuICogICB0aGUgc2V0IG9mIGFsbG93ZWQgMzItYml0IHZhbHVlcy4gVGhlIG1hc2tpbmcga2V5IG5lZWRzIHRvIGJlXG4gKiAgIHVucHJlZGljdGFibGU7IHRodXMsIHRoZSBtYXNraW5nIGtleSBNVVNUIGJlIGRlcml2ZWQgZnJvbSBhIHN0cm9uZyBzb3VyY2VcbiAqICAgb2YgZW50cm9weSwgYW5kIHRoZSBtYXNraW5nIGtleSBmb3IgYSBnaXZlbiBmcmFtZSBNVVNUIE5PVCBtYWtlIGl0IHNpbXBsZVxuICogICBmb3IgYSBzZXJ2ZXIvcHJveHkgdG8gcHJlZGljdCB0aGUgbWFza2luZyBrZXkgZm9yIGEgc3Vic2VxdWVudCBmcmFtZS4gKilcbmxldCByYW5kb21faW50MzIgKCkgPVxuICBSYW5kb20uaW50MzIgSW50MzIubWF4X2ludFxuXG5sZXQgZGVmYXVsdF9lcnJvcl9oYW5kbGVyIHdzZCAoYEV4biBleG4pID1cbiAgbGV0IG1lc3NhZ2UgPSBQcmludGV4Yy50b19zdHJpbmcgZXhuIGluXG4gIGxldCBwYXlsb2FkID0gQnl0ZXMub2Zfc3RyaW5nIG1lc3NhZ2UgaW5cbiAgV3NkLnNlbmRfYnl0ZXMgd3NkIH5raW5kOmBUZXh0IHBheWxvYWQgfm9mZjowIH5sZW46KEJ5dGVzLmxlbmd0aCBwYXlsb2FkKTtcbiAgV3NkLmNsb3NlIHdzZFxuOztcblxubGV0IGNyZWF0ZSB+bW9kZSA/KGVycm9yX2hhbmRsZXIgPSBkZWZhdWx0X2Vycm9yX2hhbmRsZXIpIHdlYnNvY2tldF9oYW5kbGVyID1cbiAgbGV0IHdzZCA9IFdzZC5jcmVhdGUgfmVycm9yX2hhbmRsZXIgbW9kZSBpblxuICBsZXQgeyBmcmFtZTsgZW9mIH0gPSB3ZWJzb2NrZXRfaGFuZGxlciB3c2QgaW5cbiAgeyByZWFkZXIgPSBSZWFkZXIuY3JlYXRlIGZyYW1lXG4gIDsgd3NkXG4gIDsgZW9mXG4gIH1cblxubGV0IHNodXRkb3duIHsgd3NkOyBfIH0gPVxuICBXc2QuY2xvc2Ugd3NkXG5cbmxldCBzZXRfZXJyb3JfYW5kX2hhbmRsZSB0IGVycm9yID1cbiAgV3NkLnJlcG9ydF9lcnJvciB0LndzZCBlcnJvcjtcbiAgc2h1dGRvd24gdFxuXG5sZXQgbmV4dF9yZWFkX29wZXJhdGlvbiB0ID1cbiAgbWF0Y2ggUmVhZGVyLm5leHQgdC5yZWFkZXIgd2l0aFxuICB8IGBFcnJvciAoYFBhcnNlIChfLCBtZXNzYWdlKSkgLT5cbiAgICBzZXRfZXJyb3JfYW5kX2hhbmRsZSB0IChgRXhuIChGYWlsdXJlIG1lc3NhZ2UpKTsgYENsb3NlXG4gIHwgKGBSZWFkIHwgYENsb3NlKSBhcyBvcGVyYXRpb24gLT4gb3BlcmF0aW9uXG5cbmxldCBuZXh0X3dyaXRlX29wZXJhdGlvbiB0ID1cbiAgV3NkLm5leHQgdC53c2RcblxubGV0IHJlYWQgdCBicyB+b2ZmIH5sZW4gPVxuICBSZWFkZXIucmVhZF93aXRoX21vcmUgdC5yZWFkZXIgYnMgfm9mZiB+bGVuIEluY29tcGxldGVcblxubGV0IHJlYWRfZW9mIHQgYnMgfm9mZiB+bGVuID1cbiAgbGV0IHIgPSBSZWFkZXIucmVhZF93aXRoX21vcmUgdC5yZWFkZXIgYnMgfm9mZiB+bGVuIENvbXBsZXRlIGluXG4gIHQuZW9mICgpO1xuICByXG5cbmxldCByZXBvcnRfd3JpdGVfcmVzdWx0IHQgcmVzdWx0ID1cbiAgV3NkLnJlcG9ydF9yZXN1bHQgdC53c2QgcmVzdWx0XG5cbmxldCB5aWVsZF93cml0ZXIgdCBrID1cbiAgaWYgV3NkLmlzX2Nsb3NlZCB0LndzZFxuICB0aGVuIGJlZ2luXG4gICAgV3NkLmNsb3NlIHQud3NkO1xuICAgIGsgKClcbiAgZW5kIGVsc2VcbiAgICBXc2Qub25fd2FrZXVwIHQud3NkIGtcblxubGV0IGlzX2Nsb3NlZCB7IHdzZDsgXyB9ID1cbiAgV3NkLmlzX2Nsb3NlZCB3c2RcblxubGV0IHJlcG9ydF9leG4gdCBleG4gPVxuICBzZXRfZXJyb3JfYW5kX2hhbmRsZSB0IChgRXhuIGV4bilcblxubGV0IHlpZWxkX3JlYWRlciBfdCBfZiA9ICgpXG4iLCJtb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcblxubW9kdWxlIEhlYWRlcnMgPSBIdHRwYWYuSGVhZGVyc1xuXG50eXBlIHN0YXRlID1cbiAgfCBIYW5kc2hha2Ugb2YgQ2xpZW50X2hhbmRzaGFrZS50XG4gIHwgV2Vic29ja2V0IG9mIFdlYnNvY2tldF9jb25uZWN0aW9uLnRcblxudHlwZSB0ID0geyBtdXRhYmxlIHN0YXRlOiBzdGF0ZSB9XG5cbnR5cGUgZXJyb3IgPVxuICBbIEh0dHBhZi5DbGllbnRfY29ubmVjdGlvbi5lcnJvclxuICB8IGBIYW5kc2hha2VfZmFpbHVyZSBvZiBIdHRwYWYuUmVzcG9uc2UudCAqIEh0dHBhZi5Cb2R5LlJlYWRlci50IF1cblxubGV0IHBhc3Nlc19zY3J1dGlueSB+c3RhdHVzIH5hY2NlcHQgaGVhZGVycyA9XG4gKCpcbiAgKiBUaGUgY2xpZW50IE1VU1QgdmFsaWRhdGUgdGhlIHNlcnZlcidzIHJlc3BvbnNlIGFzIGZvbGxvd3M6XG4gICpcbiAgKiAgIDEuIElmIHRoZSBzdGF0dXMgY29kZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgbm90IDEwMSwgdGhlIGNsaWVudFxuICAqICAgICAgaGFuZGxlcyB0aGUgcmVzcG9uc2UgcGVyIEhUVFAgW1JGQzI2MTZdIHByb2NlZHVyZXMgWy4uLl0uXG4gICpcbiAgKiAgIDIuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhbiB8VXBncmFkZXwgaGVhZGVyIGZpZWxkIG9yIHRoZSB8VXBncmFkZXxcbiAgKiAgICAgIGhlYWRlciBmaWVsZCBjb250YWlucyBhIHZhbHVlIHRoYXQgaXMgbm90IGFuIEFTQ0lJIGNhc2UtIGluc2Vuc2l0aXZlXG4gICogICAgICBtYXRjaCBmb3IgdGhlIHZhbHVlIFwid2Vic29ja2V0XCIsIHRoZSBjbGllbnQgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0XG4gICogICAgICBDb25uZWN0aW9uXy5cbiAgKlxuICAqICAgMy4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfENvbm5lY3Rpb258IGhlYWRlciBmaWVsZCBvciB0aGUgfENvbm5lY3Rpb258XG4gICogICAgICBoZWFkZXIgZmllbGQgZG9lc24ndCBjb250YWluIGEgdG9rZW4gdGhhdCBpcyBhbiBBU0NJSSBjYXNlLWluc2Vuc2l0aXZlXG4gICogICAgICBtYXRjaCBmb3IgdGhlIHZhbHVlIFwiVXBncmFkZVwiLCB0aGUgY2xpZW50IE1VU1QgX0ZhaWwgdGhlIFdlYlNvY2tldFxuICAqICAgICAgQ29ubmVjdGlvbl8uXG5cbiAgKiAgIDQuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhIHxTZWMtV2ViU29ja2V0LUFjY2VwdHwgaGVhZGVyIGZpZWxkIG9yXG4gICogICAgICB0aGUgfFNlYy1XZWJTb2NrZXQtQWNjZXB0fCBjb250YWlucyBhIHZhbHVlIG90aGVyIHRoYW4gdGhlXG4gICogICAgICBiYXNlNjQtZW5jb2RlZCBTSEEtMSBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgfFNlYy1XZWJTb2NrZXQtXG4gICogICAgICBLZXl8IChhcyBhIHN0cmluZywgbm90IGJhc2U2NC1kZWNvZGVkKSB3aXRoIHRoZSBzdHJpbmcgXCIyNThFQUZBNS1cbiAgKiAgICAgIEU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMVwiIGJ1dCBpZ25vcmluZyBhbnkgbGVhZGluZyBhbmRcbiAgKiAgICAgIHRyYWlsaW5nIHdoaXRlc3BhY2UsIHRoZSBjbGllbnQgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0XG4gICogICAgICBDb25uZWN0aW9uXy5cblxuICAqIDUuICBJZiB0aGUgcmVzcG9uc2UgaW5jbHVkZXMgYSB8U2VjLVdlYlNvY2tldC1FeHRlbnNpb25zfCBoZWFkZXJcbiAgKiAgICAgZmllbGQgYW5kIHRoaXMgaGVhZGVyIGZpZWxkIGluZGljYXRlcyB0aGUgdXNlIG9mIGFuIGV4dGVuc2lvblxuICAqICAgICB0aGF0IHdhcyBub3QgcHJlc2VudCBpbiB0aGUgY2xpZW50J3MgaGFuZHNoYWtlICh0aGUgc2VydmVyIGhhc1xuICAqICAgICBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIG5vdCByZXF1ZXN0ZWQgYnkgdGhlIGNsaWVudCksIHRoZSBjbGllbnRcbiAgKiAgICAgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLiAgKFRoZSBwYXJzaW5nIG9mIHRoaXNcbiAgKiAgICAgaGVhZGVyIGZpZWxkIHRvIGRldGVybWluZSB3aGljaCBleHRlbnNpb25zIGFyZSByZXF1ZXN0ZWQgaXNcbiAgKiAgICAgZGlzY3Vzc2VkIGluIFNlY3Rpb24gOS4xLilcbiAgKiAqKVxuIG1hdGNoXG4gICBzdGF0dXMsXG4gICBIZWFkZXJzLmdldF9leG4gaGVhZGVycyBcInVwZ3JhZGVcIixcbiAgIEhlYWRlcnMuZ2V0X2V4biBoZWFkZXJzIFwiY29ubmVjdGlvblwiLFxuICAgSGVhZGVycy5nZXRfZXhuIGhlYWRlcnMgXCJzZWMtd2Vic29ja2V0LWFjY2VwdFwiXG4gICB3aXRoXG4gICAoKiAxICopXG4gfCBgU3dpdGNoaW5nX3Byb3RvY29scywgdXBncmFkZSwgY29ubmVjdGlvbiwgc2VjX3dlYnNvY2tldF9hY2NlcHQgLT5cbiAgICgqIDIgKilcbiAgIEhhbmRzaGFrZS5DSS5lcXVhbCB1cGdyYWRlIFwid2Vic29ja2V0XCIgJiZcbiAgICgqIDMgKilcbiAgIChMaXN0LmV4aXN0c1xuICAgICAoZnVuIHYgLT4gSGFuZHNoYWtlLkNJLmVxdWFsIChTdHJpbmcudHJpbSB2KSBcInVwZ3JhZGVcIilcbiAgICAgKFN0cmluZy5zcGxpdF9vbl9jaGFyICcsJyBjb25uZWN0aW9uKSkgJiZcbiAgICgqIDQgKilcbiAgIFN0cmluZy5lcXVhbCBzZWNfd2Vic29ja2V0X2FjY2VwdCBhY2NlcHRcbiAgICgqIFRPRE8oYW5tb250ZWlybyk6IDUgKilcbiAgfCBfIC0+IGZhbHNlXG4gIHwgZXhjZXB0aW9uIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBoYW5kc2hha2VfZXhuIHQgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBIYW5kc2hha2UgaGFuZHNoYWtlIC0+IGhhbmRzaGFrZVxuICB8IFdlYnNvY2tldCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgY29ubmVjdFxuICAgIH5ub25jZVxuICAgID8oaGVhZGVycyA9IEh0dHBhZi5IZWFkZXJzLmVtcHR5KVxuICAgIH5zaGExXG4gICAgfmVycm9yX2hhbmRsZXJcbiAgICB+d2Vic29ja2V0X2hhbmRsZXJcbiAgICB0YXJnZXRcbiAgPVxuICBsZXQgcmVjIHJlc3BvbnNlX2hhbmRsZXIgcmVzcG9uc2UgcmVzcG9uc2VfYm9keSA9XG4gICAgbGV0IHsgSHR0cGFmLlJlc3BvbnNlLnN0YXR1czsgaGVhZGVyczsgXyAgfSA9IHJlc3BvbnNlIGluXG4gICAgbGV0IHQgPSBMYXp5LmZvcmNlIHQgaW5cbiAgICBsZXQgbm9uY2UgPSBCYXNlNjQuZW5jb2RlX2V4biBub25jZSBpblxuICAgIGxldCBhY2NlcHQgPSBIYW5kc2hha2Uuc2VjX3dlYnNvY2tldF9rZXlfcHJvb2YgfnNoYTEgbm9uY2UgaW5cbiAgICBpZiBwYXNzZXNfc2NydXRpbnkgfnN0YXR1cyB+YWNjZXB0IGhlYWRlcnMgdGhlbiBiZWdpblxuICAgICAgSHR0cGFmLkJvZHkuUmVhZGVyLmNsb3NlIHJlc3BvbnNlX2JvZHk7XG4gICAgICBsZXQgaGFuZHNoYWtlID0gaGFuZHNoYWtlX2V4biB0IGluXG4gICAgICB0LnN0YXRlIDwtXG4gICAgICAgIFdlYnNvY2tldFxuICAgICAgICAgKFdlYnNvY2tldF9jb25uZWN0aW9uLmNyZWF0ZVxuICAgICAgICAgIH5tb2RlOihgQ2xpZW50IFdlYnNvY2tldF9jb25uZWN0aW9uLnJhbmRvbV9pbnQzMilcbiAgICAgICAgICB3ZWJzb2NrZXRfaGFuZGxlcik7XG4gICAgICBDbGllbnRfaGFuZHNoYWtlLmNsb3NlIGhhbmRzaGFrZVxuICAgIGVuZCBlbHNlXG4gICAgICBlcnJvcl9oYW5kbGVyIChgSGFuZHNoYWtlX2ZhaWx1cmUocmVzcG9uc2UsIHJlc3BvbnNlX2JvZHkpKVxuXG4gIGFuZCB0ID0gbGF6eVxuICAgIHsgc3RhdGUgPSBIYW5kc2hha2UgKENsaWVudF9oYW5kc2hha2UuY3JlYXRlXG4gICAgICAgIH5ub25jZVxuICAgICAgICB+aGVhZGVyc1xuICAgICAgICB+ZXJyb3JfaGFuZGxlcjooZXJyb3JfaGFuZGxlciA6PiBIdHRwYWYuQ2xpZW50X2Nvbm5lY3Rpb24uZXJyb3JfaGFuZGxlcilcbiAgICAgICAgfnJlc3BvbnNlX2hhbmRsZXJcbiAgICAgICAgdGFyZ2V0KSB9XG4gIGluXG4gIExhenkuZm9yY2UgdFxuXG5sZXQgY3JlYXRlID9lcnJvcl9oYW5kbGVyIHdlYnNvY2tldF9oYW5kbGVyID1cbiAgeyBzdGF0ZSA9XG4gICAgICBXZWJzb2NrZXRcbiAgICAgICAgKFdlYnNvY2tldF9jb25uZWN0aW9uLmNyZWF0ZVxuICAgICAgICAgIH5tb2RlOihgQ2xpZW50IFdlYnNvY2tldF9jb25uZWN0aW9uLnJhbmRvbV9pbnQzMilcbiAgICAgICAgICA/ZXJyb3JfaGFuZGxlclxuICAgICAgICAgIHdlYnNvY2tldF9oYW5kbGVyKSB9XG5cbmxldCBuZXh0X3JlYWRfb3BlcmF0aW9uIHQgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBIYW5kc2hha2UgaGFuZHNoYWtlIC0+IENsaWVudF9oYW5kc2hha2UubmV4dF9yZWFkX29wZXJhdGlvbiBoYW5kc2hha2VcbiAgfCBXZWJzb2NrZXQgd2Vic29ja2V0IC0+XG4gICAgbWF0Y2ggV2Vic29ja2V0X2Nvbm5lY3Rpb24ubmV4dF9yZWFkX29wZXJhdGlvbiB3ZWJzb2NrZXQgd2l0aFxuICAgIHwgYEVycm9yIChgUGFyc2UgKF8sIF9tZXNzYWdlKSkgLT5cbiAgICAgICAgKCogVE9ETyhhbm1vbnRlaXJvKTogaGFuZGxlIHRoaXMgKilcbiAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgICAgICgqIHNldF9lcnJvcl9hbmRfaGFuZGxlIHQgKGBFeG4gKEZhaWx1cmUgbWVzc2FnZSkpOyBgQ2xvc2UgKilcbiAgICB8IChgUmVhZCB8IGBDbG9zZSkgYXMgb3BlcmF0aW9uIC0+IG9wZXJhdGlvblxuXG5sZXQgcmVhZCB0IGJzIH5vZmYgfmxlbiA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IEhhbmRzaGFrZSBoYW5kc2hha2UgLT4gQ2xpZW50X2hhbmRzaGFrZS5yZWFkIGhhbmRzaGFrZSBicyB+b2ZmIH5sZW5cbiAgfCBXZWJzb2NrZXQgd2Vic29ja2V0IC0+IFdlYnNvY2tldF9jb25uZWN0aW9uLnJlYWQgd2Vic29ja2V0IGJzIH5vZmYgfmxlblxuXG5sZXQgcmVhZF9lb2YgdCBicyB+b2ZmIH5sZW4gPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBIYW5kc2hha2UgaGFuZHNoYWtlIC0+IENsaWVudF9oYW5kc2hha2UucmVhZCBoYW5kc2hha2UgYnMgfm9mZiB+bGVuXG4gIHwgV2Vic29ja2V0IHdlYnNvY2tldCAtPiBXZWJzb2NrZXRfY29ubmVjdGlvbi5yZWFkX2VvZiB3ZWJzb2NrZXQgYnMgfm9mZiB+bGVuXG5cbmxldCBuZXh0X3dyaXRlX29wZXJhdGlvbiB0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSGFuZHNoYWtlIGhhbmRzaGFrZSAtPiBDbGllbnRfaGFuZHNoYWtlLm5leHRfd3JpdGVfb3BlcmF0aW9uIGhhbmRzaGFrZVxuICB8IFdlYnNvY2tldCB3ZWJzb2NrZXQgLT4gV2Vic29ja2V0X2Nvbm5lY3Rpb24ubmV4dF93cml0ZV9vcGVyYXRpb24gd2Vic29ja2V0XG5cbmxldCByZXBvcnRfd3JpdGVfcmVzdWx0IHQgcmVzdWx0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSGFuZHNoYWtlIGhhbmRzaGFrZSAtPiBDbGllbnRfaGFuZHNoYWtlLnJlcG9ydF93cml0ZV9yZXN1bHQgaGFuZHNoYWtlIHJlc3VsdFxuICB8IFdlYnNvY2tldCB3ZWJzb2NrZXQgLT4gV2Vic29ja2V0X2Nvbm5lY3Rpb24ucmVwb3J0X3dyaXRlX3Jlc3VsdCB3ZWJzb2NrZXQgcmVzdWx0XG5cbmxldCByZXBvcnRfZXhuIHQgZXhuID1cbiAgYmVnaW4gbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSGFuZHNoYWtlIGhhbmRzaGFrZSAtPiBDbGllbnRfaGFuZHNoYWtlLnJlcG9ydF9leG4gaGFuZHNoYWtlIGV4blxuICB8IFdlYnNvY2tldCB3ZWJzb2NrZXQgLT4gV2Vic29ja2V0X2Nvbm5lY3Rpb24ucmVwb3J0X2V4biB3ZWJzb2NrZXQgZXhuXG4gIGVuZFxuXG5sZXQgeWllbGRfcmVhZGVyIHQgZiA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IEhhbmRzaGFrZSBoYW5kc2hha2UgLT4gQ2xpZW50X2hhbmRzaGFrZS55aWVsZF9yZWFkZXIgaGFuZHNoYWtlIGZcbiAgfCBXZWJzb2NrZXQgX3dlYnNvY2tldCAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHlpZWxkX3dyaXRlciB0IGYgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBIYW5kc2hha2UgaGFuZHNoYWtlIC0+IENsaWVudF9oYW5kc2hha2UueWllbGRfd3JpdGVyIGhhbmRzaGFrZSBmXG4gIHwgV2Vic29ja2V0IHdlYnNvY2tldCAtPiBXZWJzb2NrZXRfY29ubmVjdGlvbi55aWVsZF93cml0ZXIgd2Vic29ja2V0IGZcblxuXG5sZXQgaXNfY2xvc2VkIHQgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBIYW5kc2hha2UgaGFuZHNoYWtlIC0+IENsaWVudF9oYW5kc2hha2UuaXNfY2xvc2VkIGhhbmRzaGFrZVxuICB8IFdlYnNvY2tldCB3ZWJzb2NrZXQgLT4gV2Vic29ja2V0X2Nvbm5lY3Rpb24uaXNfY2xvc2VkIHdlYnNvY2tldFxuXG5sZXQgc2h1dGRvd24gdCA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IEhhbmRzaGFrZSBoYW5kc2hha2UgLT4gQ2xpZW50X2hhbmRzaGFrZS5jbG9zZSBoYW5kc2hha2VcbiAgfCBXZWJzb2NrZXQgd2Vic29ja2V0IC0+IFdlYnNvY2tldF9jb25uZWN0aW9uLnNodXRkb3duIHdlYnNvY2tldFxuOztcbiIsIm1vZHVsZSBHbHV0ZW4gPSBEcmVhbV9nbHV0ZW4uR2x1dGVuXG5tb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcblxubW9kdWxlIElPVmVjID0gSHR0cGFmLklPVmVjXG5tb2R1bGUgU2VydmVyX2hhbmRzaGFrZSA9IEdsdXRlbi5TZXJ2ZXJcblxudHlwZSBzdGF0ZSA9XG4gIHwgSGFuZHNoYWtlIG9mIFNlcnZlcl9oYW5kc2hha2UudFxuICB8IFdlYnNvY2tldCBvZiBXZWJzb2NrZXRfY29ubmVjdGlvbi50XG5cbnR5cGUgZXJyb3IgPSBXZWJzb2NrZXRfY29ubmVjdGlvbi5lcnJvclxudHlwZSBlcnJvcl9oYW5kbGVyID0gV2Vic29ja2V0X2Nvbm5lY3Rpb24uZXJyb3JfaGFuZGxlclxuXG50eXBlIHQgPVxuICB7IG11dGFibGUgc3RhdGU6IHN0YXRlXG4gIDsgd2Vic29ja2V0X2hhbmRsZXI6IFdzZC50IC0+IFdlYnNvY2tldF9jb25uZWN0aW9uLmlucHV0X2hhbmRsZXJzXG4gIH1cblxubGV0IGlzX2Nsb3NlZCB0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSGFuZHNoYWtlIGhhbmRzaGFrZSAtPlxuICAgIFNlcnZlcl9oYW5kc2hha2UuaXNfY2xvc2VkIGhhbmRzaGFrZVxuICB8IFdlYnNvY2tldCB3ZWJzb2NrZXQgLT5cbiAgICBXZWJzb2NrZXRfY29ubmVjdGlvbi5pc19jbG9zZWQgd2Vic29ja2V0XG5cbmxldCBjcmVhdGUgfnNoYTEgP2Vycm9yX2hhbmRsZXIgd2Vic29ja2V0X2hhbmRsZXIgPVxuICBsZXQgcmVjIHVwZ3JhZGVfaGFuZGxlciB1cGdyYWRlICgpID1cbiAgICBsZXQgdCA9IExhenkuZm9yY2UgdCBpblxuICAgIGxldCB3c19jb25uZWN0aW9uID1cbiAgICAgIFdlYnNvY2tldF9jb25uZWN0aW9uLmNyZWF0ZSB+bW9kZTpgU2VydmVyID9lcnJvcl9oYW5kbGVyIHdlYnNvY2tldF9oYW5kbGVyXG4gICAgaW5cbiAgICB0LnN0YXRlIDwtIFdlYnNvY2tldCB3c19jb25uZWN0aW9uO1xuICAgIHVwZ3JhZGUgKEdsdXRlbi5tYWtlIChtb2R1bGUgV2Vic29ja2V0X2Nvbm5lY3Rpb24pIHdzX2Nvbm5lY3Rpb24pO1xuICBhbmQgcmVxdWVzdF9oYW5kbGVyIHsgR2x1dGVuLnJlcWQ7IHVwZ3JhZGUgfSA9XG4gICAgbGV0IGVycm9yIG1zZyA9XG4gICAgICBsZXQgcmVzcG9uc2UgPSBIdHRwYWYuKFJlc3BvbnNlLmNyZWF0ZVxuICAgICAgICB+aGVhZGVyczooSGVhZGVycy5vZl9saXN0IFtcIkNvbm5lY3Rpb25cIiwgXCJjbG9zZVwiXSlcbiAgICAgICAgYEJhZF9yZXF1ZXN0KVxuICAgICAgaW5cbiAgICAgIEh0dHBhZi5SZXFkLnJlc3BvbmRfd2l0aF9zdHJpbmcgcmVxZCByZXNwb25zZSBtc2dcbiAgICBpblxuICAgIGxldCByZXQgPSBIdHRwYWYuUmVxZC50cnlfd2l0aCByZXFkIChmdW4gKCkgLT5cbiAgICAgIG1hdGNoIEhhbmRzaGFrZS5yZXNwb25kX3dpdGhfdXBncmFkZSB+c2hhMSByZXFkICh1cGdyYWRlX2hhbmRsZXIgdXBncmFkZSkgd2l0aFxuICAgICAgfCBPayAoKSAtPiAoKVxuICAgICAgfCBFcnJvciBtc2cgLT4gZXJyb3IgbXNnKVxuICAgIGluXG4gICAgbWF0Y2ggcmV0IHdpdGhcbiAgICB8IE9rICgpIC0+ICgpXG4gICAgfCBFcnJvciBleG4gLT5cbiAgICAgIGVycm9yIChQcmludGV4Yy50b19zdHJpbmcgZXhuKVxuICBhbmQgdCA9IGxhenlcbiAgICB7IHN0YXRlID1cbiAgICAgICAgSGFuZHNoYWtlXG4gICAgICAgICAgKFNlcnZlcl9oYW5kc2hha2UuY3JlYXRlX3VwZ3JhZGFibGVcbiAgICAgICAgICAgIH5wcm90b2NvbDoobW9kdWxlIEh0dHBhZi5TZXJ2ZXJfY29ubmVjdGlvbilcbiAgICAgICAgICAgIH5jcmVhdGU6XG4gICAgICAgICAgICAgIChIdHRwYWYuU2VydmVyX2Nvbm5lY3Rpb24uY3JlYXRlID9jb25maWc6Tm9uZSA/ZXJyb3JfaGFuZGxlcjpOb25lKVxuICAgICAgICAgICAgcmVxdWVzdF9oYW5kbGVyKVxuICAgIDsgd2Vic29ja2V0X2hhbmRsZXJcbiAgICB9XG4gIGluXG4gIExhenkuZm9yY2UgdFxuXG5sZXQgY3JlYXRlX3dlYnNvY2tldCA/ZXJyb3JfaGFuZGxlciB3ZWJzb2NrZXRfaGFuZGxlciA9XG4gIHsgc3RhdGUgPVxuICAgICAgV2Vic29ja2V0XG4gICAgICAgIChXZWJzb2NrZXRfY29ubmVjdGlvbi5jcmVhdGVcbiAgICAgICAgICAgfm1vZGU6YFNlcnZlclxuICAgICAgICAgICA/ZXJyb3JfaGFuZGxlclxuICAgICAgICAgICB3ZWJzb2NrZXRfaGFuZGxlcilcbiAgOyB3ZWJzb2NrZXRfaGFuZGxlclxuICB9XG5cbmxldCBzaHV0ZG93biB0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSGFuZHNoYWtlIGhhbmRzaGFrZSAtPiBTZXJ2ZXJfaGFuZHNoYWtlLnNodXRkb3duIGhhbmRzaGFrZVxuICB8IFdlYnNvY2tldCB3ZWJzb2NrZXQgLT4gV2Vic29ja2V0X2Nvbm5lY3Rpb24uc2h1dGRvd24gd2Vic29ja2V0XG47O1xuXG5sZXQgcmVwb3J0X2V4biB0IGV4biA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IEhhbmRzaGFrZSBfIC0+XG4gICAgKCogVE9ETzogd2UgbmVlZCB0byBoYW5kbGUgdGhpcyBwcm9wZXJseS4gVGhlcmUgd2FzIGFuIGVycm9yIGluIHRoZSB1cGdyYWRlICopXG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgV2Vic29ja2V0IHdlYnNvY2tldCAtPlxuICAgIFdlYnNvY2tldF9jb25uZWN0aW9uLnJlcG9ydF9leG4gd2Vic29ja2V0IGV4blxuXG5sZXQgbmV4dF9yZWFkX29wZXJhdGlvbiB0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSGFuZHNoYWtlIGhhbmRzaGFrZSAtPiBTZXJ2ZXJfaGFuZHNoYWtlLm5leHRfcmVhZF9vcGVyYXRpb24gaGFuZHNoYWtlXG4gIHwgV2Vic29ja2V0IHdlYnNvY2tldCAtPiBXZWJzb2NrZXRfY29ubmVjdGlvbi5uZXh0X3JlYWRfb3BlcmF0aW9uIHdlYnNvY2tldFxuOztcblxubGV0IHJlYWQgdCBicyB+b2ZmIH5sZW4gPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBIYW5kc2hha2UgaGFuZHNoYWtlIC0+IFNlcnZlcl9oYW5kc2hha2UucmVhZCBoYW5kc2hha2UgYnMgfm9mZiB+bGVuXG4gIHwgV2Vic29ja2V0IHdlYnNvY2tldCAtPiBXZWJzb2NrZXRfY29ubmVjdGlvbi5yZWFkIHdlYnNvY2tldCBicyB+b2ZmIH5sZW5cbjs7XG5cbmxldCByZWFkX2VvZiB0IGJzIH5vZmYgfmxlbiA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IEhhbmRzaGFrZSBoYW5kc2hha2UgLT4gU2VydmVyX2hhbmRzaGFrZS5yZWFkX2VvZiBoYW5kc2hha2UgYnMgfm9mZiB+bGVuXG4gIHwgV2Vic29ja2V0IHdlYnNvY2tldCAtPiBXZWJzb2NrZXRfY29ubmVjdGlvbi5yZWFkX2VvZiB3ZWJzb2NrZXQgYnMgfm9mZiB+bGVuXG47O1xuXG5sZXQgeWllbGRfcmVhZGVyIHQgZiA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IEhhbmRzaGFrZSBoYW5kc2hha2UgLT4gU2VydmVyX2hhbmRzaGFrZS55aWVsZF9yZWFkZXIgaGFuZHNoYWtlIGZcbiAgfCBXZWJzb2NrZXQgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IG5leHRfd3JpdGVfb3BlcmF0aW9uIHQgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBIYW5kc2hha2UgaGFuZHNoYWtlIC0+IFNlcnZlcl9oYW5kc2hha2UubmV4dF93cml0ZV9vcGVyYXRpb24gaGFuZHNoYWtlXG4gIHwgV2Vic29ja2V0IHdlYnNvY2tldCAtPiBXZWJzb2NrZXRfY29ubmVjdGlvbi5uZXh0X3dyaXRlX29wZXJhdGlvbiB3ZWJzb2NrZXRcbjs7XG5cbmxldCByZXBvcnRfd3JpdGVfcmVzdWx0IHQgcmVzdWx0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSGFuZHNoYWtlIGhhbmRzaGFrZSAtPiBTZXJ2ZXJfaGFuZHNoYWtlLnJlcG9ydF93cml0ZV9yZXN1bHQgaGFuZHNoYWtlIHJlc3VsdFxuICB8IFdlYnNvY2tldCB3ZWJzb2NrZXQgLT4gV2Vic29ja2V0X2Nvbm5lY3Rpb24ucmVwb3J0X3dyaXRlX3Jlc3VsdCB3ZWJzb2NrZXQgcmVzdWx0XG47O1xuXG5sZXQgeWllbGRfd3JpdGVyIHQgZiA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IEhhbmRzaGFrZSBoYW5kc2hha2UgLT4gU2VydmVyX2hhbmRzaGFrZS55aWVsZF93cml0ZXIgaGFuZHNoYWtlIGZcbiAgfCBXZWJzb2NrZXQgd2Vic29ja2V0IC0+IFdlYnNvY2tldF9jb25uZWN0aW9uLnlpZWxkX3dyaXRlciB3ZWJzb2NrZXQgZlxuOztcbiJdfQ==
