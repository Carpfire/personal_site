// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Cstruct
//# unitInfo: Requires: Stdlib, Stdlib__Bigarray, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__List, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "  ",
    cst_dst_off = " dst-off=",
    cst_dst = " dst=",
    cst_len = " len=",
    cst_off = " off=",
    cst_src_off = " src-off=",
    cst_a = "@\n%a@.",
    cst = "@;",
    cst_BE$5 = "BE",
    cst_Cstruct_blit_src = "Cstruct.blit src=",
    cst_Cstruct_blit_from_bytes_sr = "Cstruct.blit_from_bytes src=",
    cst_Cstruct_blit_from_string_s = "Cstruct.blit_from_string src=",
    cst_Cstruct_blit_to_bytes_src = "Cstruct.blit_to_bytes src=",
    cst_HE$5 = "HE",
    cst_LE$5 = "LE",
    cst_d = "[%d]",
    cst_cut_empty_separator$1 = "cut: empty separator",
    cst_cuts_empty_separator$1 = "cuts: empty separator",
    cst_index_out_of_bounds$3 = "index out of bounds",
    cst_of_hex_odd_numbers_of_char = "of_hex: odd numbers of characters",
    cst_span_negative_max$1 = "span: negative max",
    cst_span_negative_min$1 = "span: negative min",
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    _P_ = [0, 1],
    _O_ = [0, 1],
    cst_cuts_empty_separator$0 = cst_cuts_empty_separator$1,
    cst_cuts_empty_separator = cst_cuts_empty_separator$1,
    cst_cut_empty_separator$0 = cst_cut_empty_separator$1,
    cst_cut_empty_separator = cst_cut_empty_separator$1,
    _M_ = [0, 0],
    _N_ = [0, 0],
    cst_span_negative_min$0 = cst_span_negative_min$1,
    cst_span_negative_max$0 = cst_span_negative_max$1,
    _L_ = [0, 0],
    _J_ = [0, 0],
    _K_ = [0, 0],
    cst_span_negative_min = cst_span_negative_min$1,
    cst_span_negative_max = cst_span_negative_max$1,
    _I_ = [0, 0],
    _H_ = [0, 0],
    _G_ = [0, 0],
    _F_ = [0, 0],
    cst_index_out_of_bounds$2 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$1 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$0 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds = cst_index_out_of_bounds$3,
    cst_Cstruct_concat = "Cstruct.concat",
    _E_ = [0, [17, 3, [15, [17, 4, 0]]], cst_a],
    _B_ = [0, [17, [0, cst, 1, 0], 0], cst],
    _A_ = [0, [12, 32, 0], " "],
    _z_ = [0, [11, cst$0, 0], cst$0],
    _C_ = [0, [15, [4, 6, 0, [0, 2], [15, 0]]], "%a%.2x%a"],
    _x_ =
      [0,
       [11,
        "of_hex: invalid character at pos ",
        [4, 0, 0, 0, [11, ": ", [1, 0]]]],
       "of_hex: invalid character at pos %d: %C"],
    _y_ =
      [0,
       [11, cst_of_hex_odd_numbers_of_char, 0],
       cst_of_hex_odd_numbers_of_char],
    cst_to_string = "to_string",
    cst_Cstruct_copyv = "Cstruct.copyv",
    cst_Cstruct_lenv = "Cstruct.lenv",
    cst_HE$4 = cst_HE$5,
    cst_HE$3 = cst_HE$5,
    cst_HE$2 = cst_HE$5,
    cst_HE$1 = cst_HE$5,
    cst_HE$0 = cst_HE$5,
    cst_HE = cst_HE$5,
    cst_LE$4 = cst_LE$5,
    cst_LE$3 = cst_LE$5,
    cst_LE$2 = cst_LE$5,
    cst_LE$1 = cst_LE$5,
    cst_LE$0 = cst_LE$5,
    cst_LE = cst_LE$5,
    cst_BE$4 = cst_BE$5,
    cst_BE$3 = cst_BE$5,
    cst_BE$2 = cst_BE$5,
    cst_BE$1 = cst_BE$5,
    cst_BE$0 = cst_BE$5,
    cst_BE = cst_BE$5,
    cst_get_uint64 = ".get_uint64",
    cst_get_uint32 = ".get_uint32",
    cst_get_uint16 = ".get_uint16",
    cst_set_uint64 = ".set_uint64",
    cst_set_uint32 = ".set_uint32",
    cst_set_uint16 = ".set_uint16",
    cst_get_char = "get_char",
    cst_get_uint8 = "get_uint8",
    cst_set_char = "set_char",
    cst_set_uint8 = "set_uint8",
    _u_ =
      [0,
       [11,
        "ERROR: t.off+t.len=",
        [4, 0, 0, 0, [12, 32, [15, [12, 10, [10, 0]]]]]],
       "ERROR: t.off+t.len=%d %a\n%!"],
    _v_ = [0, "lib/cstruct.ml", 127, 4],
    _w_ = [0, [15, 0], "%a"],
    cst_check_alignment_must_be_po =
      "check_alignment must be positive integer",
    _t_ =
      [0,
       [11,
        "Cstruct.iter ",
        [15, [11, " i=", [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]],
       "Cstruct.iter %a i=%d len=%d"],
    _s_ =
      [0,
       [11,
        "Cstruct.split ",
        [15, [11, " start=", [4, 0, 0, 0, [11, cst_off, [4, 0, 0, 0, 0]]]]]],
       "Cstruct.split %a start=%d off=%d"],
    _r_ =
      [0,
       [11,
        "invalid bounds in Cstruct.",
        [2,
         0,
         [12,
          32,
          [15, [11, cst_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]]]],
       "invalid bounds in Cstruct.%s %a off=%d len=%d"],
    _q_ =
      [0,
       [11,
        cst_Cstruct_blit_to_bytes_src,
        [15,
         [11,
          cst_dst,
          [15,
           [11, cst_dst_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]]]],
       "Cstruct.blit_to_bytes src=%a dst=%a dst-off=%d len=%d"],
    _p_ =
      [0,
       [11,
        cst_Cstruct_blit_to_bytes_src,
        [15,
         [11,
          cst_dst,
          [15,
           [11, cst_src_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]]]],
       "Cstruct.blit_to_bytes src=%a dst=%a src-off=%d len=%d"],
    _o_ =
      [0,
       [11,
        cst_Cstruct_blit_from_bytes_sr,
        [15,
         [11,
          cst_dst,
          [15,
           [11, cst_dst_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]]]],
       "Cstruct.blit_from_bytes src=%a dst=%a dst-off=%d len=%d"],
    _n_ =
      [0,
       [11,
        cst_Cstruct_blit_from_bytes_sr,
        [15,
         [11,
          cst_dst,
          [15,
           [11, cst_src_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]]]],
       "Cstruct.blit_from_bytes src=%a dst=%a src-off=%d len=%d"],
    _m_ =
      [0,
       [11,
        cst_Cstruct_blit_from_string_s,
        [15,
         [11,
          cst_dst,
          [15,
           [11, cst_dst_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]]]],
       "Cstruct.blit_from_string src=%a dst=%a dst-off=%d len=%d"],
    _l_ =
      [0,
       [11,
        cst_Cstruct_blit_from_string_s,
        [15,
         [11,
          cst_dst,
          [15,
           [11, cst_src_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]]]],
       "Cstruct.blit_from_string src=%a dst=%a src-off=%d len=%d"],
    _k_ =
      [0,
       [11,
        cst_Cstruct_blit_src,
        [15,
         [11,
          cst_dst,
          [15,
           [11, cst_dst_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]]]],
       "Cstruct.blit src=%a dst=%a dst-off=%d len=%d"],
    _j_ =
      [0,
       [11,
        cst_Cstruct_blit_src,
        [15,
         [11,
          cst_dst,
          [15,
           [11, cst_src_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]]]],
       "Cstruct.blit src=%a dst=%a src-off=%d len=%d"],
    _i_ =
      [0,
       [11,
        "Cstruct.to_hex_string ",
        [15, [11, cst_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]],
       "Cstruct.to_hex_string %a off=%d len=%d"],
    _h_ =
      [0,
       [11,
        "Cstruct.",
        [2,
         0,
         [12,
          32,
          [15, [11, cst_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]]]],
       "Cstruct.%s %a off=%d len=%d"],
    _g_ =
      [0,
       [11, "Cstruct.shiftv short by ", [4, 0, 0, 0, 0]],
       "Cstruct.shiftv short by %d"],
    _f_ =
      [0,
       [11, "Cstruct.shift ", [15, [12, 32, [4, 0, 0, 0, 0]]]],
       "Cstruct.shift %a %d"],
    _e_ =
      [0,
       [11,
        "Cstruct.sub: ",
        [15, [11, cst_off, [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]]]],
       "Cstruct.sub: %a off=%d len=%d"],
    _d_ =
      [0,
       [11,
        "Cstruct.of_bigarray off=",
        [4, 0, 0, 0, [11, cst_len, [4, 0, 0, 0, 0]]]],
       "Cstruct.of_bigarray off=%d len=%d"],
    _c_ = [0, [12, 91, [4, 0, 0, 0, [12, 93, 0]]], cst_d],
    _b_ = [0, [12, 91, [4, 0, 0, 0, [12, 93, 0]]], cst_d],
    _a_ =
      [0,
       [12,
        91,
        [4,
         0,
         0,
         0,
         [12, 44, [4, 0, 0, 0, [11, "](", [4, 0, 0, 0, [12, 41, 0]]]]]]],
       "[%d,%d](%d)"],
    cst_copy = "copy",
    _D_ = [0, [17, 3, [15, [17, 4, 0]]], cst_a];
   function pp_t(ppf, t){
    var _bk_ = caml_ba_dim_1(t[1]);
    return caml_call5(Stdlib_Format[137], ppf, _a_, t[2], t[3], _bk_);
   }
   function string_t(ppf, str){
    return caml_call3
            (Stdlib_Format[137], ppf, _b_, caml_ml_string_length(str));
   }
   function bytes_t(ppf, str){
    return caml_call3(Stdlib_Format[137], ppf, _c_, caml_ml_bytes_length(str));
   }
   function err(fmt){
    var
     b = caml_call1(Stdlib_Buffer[1], 20),
     ppf = caml_call1(Stdlib_Format[114], b);
    function k(ppf){
     caml_call2(Stdlib_Format[38], ppf, 0);
     var _bj_ = caml_call1(Stdlib_Buffer[2], b);
     return caml_call1(Stdlib[1], _bj_);
    }
    return caml_call3(Stdlib_Format[144], k, ppf, fmt);
   }
   function err_invalid_bounds(f){return caml_call2(err(_r_), f, pp_t);}
   function of_bigarray(opt, len, buffer){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    var dim = caml_ba_dim_1(buffer);
    if(len) var len$0 = len[1], len$1 = len$0; else var len$1 = dim - off | 0;
    if
     (0 <= off
      && 0 <= len$1 && 0 <= (off + len$1 | 0) && dim >= (off + len$1 | 0))
     return [0, buffer, off, len$1];
    return caml_call1(caml_call1(err(_d_), off), len$1);
   }
   function to_bigarray(buffer){
    return runtime.caml_ba_sub(buffer[1], buffer[2], buffer[3]);
   }
   function create_unsafe(len){
    var
     buffer =
       caml_call3
        (Stdlib_Bigarray[19][1],
         Stdlib_Bigarray[13],
         Stdlib_Bigarray[15],
         len);
    return [0, buffer, 0, len];
   }
   function check_bounds(t, len){
    var
     _bh_ = 0 <= len ? 1 : 0,
     _bi_ = _bh_ ? len <= caml_ba_dim_1(t[1]) ? 1 : 0 : _bh_;
    return _bi_;
   }
   var empty = create_unsafe(0);
   function check_alignment(t, alignment){
    return 0 < alignment
            ? runtime.caml_check_alignment_bigstring(t[1], t[2], alignment)
            : caml_call1(Stdlib[1], cst_check_alignment_must_be_po);
   }
   function byte$0(i){return caml_call1(Stdlib_Char[1], i);}
   function byte_to_int(b){return b;}
   function debug(t){
    var max_len = caml_ba_dim_1(t[1]);
    if(max_len >= (t[2] + t[3] | 0) && 0 <= t[3] && 0 <= t[2])
     return caml_call3(Stdlib_Format[141], _w_, pp_t, t);
    caml_call4(Stdlib_Format[138], _u_, t[2] + t[3] | 0, pp_t, t);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
   }
   function sub(t, off, len){
    var
     new_start = t[2] + off | 0,
     new_end = new_start + len | 0,
     old_end = t[2] + t[3] | 0;
    if(t[2] <= new_start && new_end <= old_end && new_start <= new_end)
     return [0, t[1], new_start, len];
    return caml_call2(caml_call2(err(_e_), pp_t, t), off, len);
   }
   function shift(t, amount){
    var off = t[2] + amount | 0, len = t[3] - amount | 0;
    if(0 <= amount && t[3] >= amount && check_bounds(t, off + len | 0))
     return [0, t[1], off, len];
    return caml_call1(caml_call2(err(_f_), pp_t, t), amount);
   }
   function shiftv(ts$0, n){
    var ts$1 = ts$0, n$0 = n;
    for(;;){
     if(0 === n$0){
      var x = ts$1;
      for(;;){
       if(x){var ts = x[2], t = x[1]; if(0 === t[3]){var x = ts; continue;}}
       return x;
      }
     }
     if(! ts$1) return caml_call1(err(_g_), n$0);
     var t$0 = ts$1[1], ts$2 = ts$1[2];
     if(t$0[3] > n$0){var ts$3 = ts$1[2]; return [0, shift(t$0, n$0), ts$3];}
     var n$1 = n$0 - t$0[3] | 0, ts$1 = ts$2, n$0 = n$1;
    }
   }
   function copy_to_string(caller, src, srcoff, len){
    if(0 <= len && 0 <= srcoff && (src[3] - srcoff | 0) >= len){
     var b = caml_create_bytes(len);
     runtime.caml_blit_bigstring_to_string
      (src[1], src[2] + srcoff | 0, b, 0, len);
     return caml_call1(Stdlib_Bytes[44], b);
    }
    return caml_call2(caml_call3(err(_h_), caller, pp_t, src), srcoff, len);
   }
   function copy(_be_, _bf_, _bg_){
    return copy_to_string(cst_copy, _be_, _bf_, _bg_);
   }
   function blit(src, srcoff, dst, dstoff, len){
    if(0 <= len && 0 <= srcoff && (src[3] - srcoff | 0) >= len){
     if(0 <= dstoff && (dst[3] - dstoff | 0) >= len)
      return runtime.caml_blit_bigstring_to_bigstring
              (src[1], src[2] + srcoff | 0, dst[1], dst[2] + dstoff | 0, len);
     return caml_call2
             (caml_call4(err(_k_), pp_t, src, pp_t, dst), dstoff, len);
    }
    return caml_call2(caml_call4(err(_j_), pp_t, src, pp_t, dst), srcoff, len);
   }
   function sub_copy(cstr, off, len){
    var cstr2 = create_unsafe(len);
    blit(cstr, off, cstr2, 0, len);
    return cstr2;
   }
   function blit_from_string(src, srcoff, dst, dstoff, len){
    if
     (0 <= len
      &&
       0 <= srcoff
       && 0 <= dstoff && (caml_ml_string_length(src) - srcoff | 0) >= len)
     return (dst[3] - dstoff | 0) < len
             ? caml_call2
               (caml_call4(err(_m_), string_t, src, pp_t, dst), dstoff, len)
             : runtime.caml_blit_string_to_bigstring
               (src, srcoff, dst[1], dst[2] + dstoff | 0, len);
    return caml_call2
            (caml_call4(err(_l_), string_t, src, pp_t, dst), srcoff, len);
   }
   function blit_from_bytes(src, srcoff, dst, dstoff, len){
    if
     (0 <= len
      &&
       0 <= srcoff
       && 0 <= dstoff && (caml_ml_bytes_length(src) - srcoff | 0) >= len)
     return (dst[3] - dstoff | 0) < len
             ? caml_call2
               (caml_call4(err(_o_), bytes_t, src, pp_t, dst), dstoff, len)
             : runtime.caml_blit_string_to_bigstring
               (src, srcoff, dst[1], dst[2] + dstoff | 0, len);
    return caml_call2
            (caml_call4(err(_n_), bytes_t, src, pp_t, dst), srcoff, len);
   }
   function blit_to_bytes(src, srcoff, dst, dstoff, len){
    if(0 <= len && 0 <= srcoff && 0 <= dstoff && (src[3] - srcoff | 0) >= len)
     return (caml_ml_bytes_length(dst) - dstoff | 0) < len
             ? caml_call2
               (caml_call4(err(_q_), pp_t, src, bytes_t, dst), dstoff, len)
             : runtime.caml_blit_bigstring_to_string
               (src[1], src[2] + srcoff | 0, dst, dstoff, len);
    return caml_call2
            (caml_call4(err(_p_), pp_t, src, bytes_t, dst), srcoff, len);
   }
   function compare(t1, t2){
    var l1 = t1[3], l2 = t2[3], r = runtime.caml_int_compare(l1, l2);
    if(0 !== r) return r;
    var r$0 = runtime.caml_compare_bigstring(t1[1], t1[2], t2[1], t2[2], l1);
    return 0 === r$0 ? 0 : 0 <= r$0 ? 1 : -1;
   }
   function equal(t1, t2){return 0 === compare(t1, t2) ? 1 : 0;}
   function memset(t, x){
    return runtime.caml_fill_bigstring(t[1], t[2], t[3], x);
   }
   function create(len){var t = create_unsafe(len); memset(t, 0); return t;}
   function set_uint8(t, i, c){
    if(t[3] > i && 0 <= i) return caml_ba_set_1(t[1], t[2] + i | 0, c);
    return caml_call3(err_invalid_bounds(cst_set_uint8), t, i, 1);
   }
   function set_char(t, i, c){
    if(t[3] > i && 0 <= i) return caml_ba_set_1(t[1], t[2] + i | 0, c);
    return caml_call3(err_invalid_bounds(cst_set_char), t, i, 1);
   }
   function get_uint8(t, i){
    if(t[3] > i && 0 <= i) return caml_ba_get_1(t[1], t[2] + i | 0);
    return caml_call3(err_invalid_bounds(cst_get_uint8), t, i, 1);
   }
   function get_char(t, i){
    if(t[3] > i && 0 <= i) return caml_ba_get_1(t[1], t[2] + i | 0);
    return caml_call3(err_invalid_bounds(cst_get_char), t, i, 1);
   }
   function set_uint16(swap, p, t, i, c){
    if((t[3] - 2 | 0) >= i && 0 <= i){
     var _bd_ = swap ? caml_bswap16(c) : c;
     return runtime.caml_ba_uint8_set16(t[1], t[2] + i | 0, _bd_);
    }
    return caml_call3
            (err_invalid_bounds(caml_call2(Stdlib[28], p, cst_set_uint16)),
             t,
             i,
             2);
   }
   function set_uint32(swap, p, t, i, c){
    if((t[3] - 4 | 0) >= i && 0 <= i){
     var _bc_ = swap ? caml_int32_bswap(c) : c;
     return runtime.caml_ba_uint8_set32(t[1], t[2] + i | 0, _bc_);
    }
    return caml_call3
            (err_invalid_bounds(caml_call2(Stdlib[28], p, cst_set_uint32)),
             t,
             i,
             4);
   }
   function set_uint64(swap, p, t, i, c){
    if((t[3] - 8 | 0) >= i && 0 <= i){
     var _bb_ = swap ? caml_int64_bswap(c) : c;
     return runtime.caml_ba_uint8_set64(t[1], t[2] + i | 0, _bb_);
    }
    return caml_call3
            (err_invalid_bounds(caml_call2(Stdlib[28], p, cst_set_uint64)),
             t,
             i,
             8);
   }
   function get_uint16(swap, p, t, i){
    if((t[3] - 2 | 0) >= i && 0 <= i){
     var r = runtime.caml_ba_uint8_get16(t[1], t[2] + i | 0);
     return swap ? caml_bswap16(r) : r;
    }
    return caml_call3
            (err_invalid_bounds(caml_call2(Stdlib[28], p, cst_get_uint16)),
             t,
             i,
             2);
   }
   function get_uint32(swap, p, t, i){
    if((t[3] - 4 | 0) >= i && 0 <= i){
     var r = runtime.caml_ba_uint8_get32(t[1], t[2] + i | 0);
     return swap ? caml_int32_bswap(r) : r;
    }
    return caml_call3
            (err_invalid_bounds(caml_call2(Stdlib[28], p, cst_get_uint32)),
             t,
             i,
             4);
   }
   function get_uint64(swap, p, t, i){
    if((t[3] - 8 | 0) >= i && 0 <= i){
     var r = runtime.caml_ba_uint8_get64(t[1], t[2] + i | 0);
     return swap ? caml_int64_bswap(r) : r;
    }
    return caml_call3
            (err_invalid_bounds(caml_call2(Stdlib[28], p, cst_get_uint64)),
             t,
             i,
             8);
   }
   function set_uint16$0(t, i, c){
    return set_uint16(1 - Stdlib_Sys[11], cst_BE, t, i, c);
   }
   function set_uint32$0(t, i, c){
    return set_uint32(1 - Stdlib_Sys[11], cst_BE$0, t, i, c);
   }
   function set_uint64$0(t, i, c){
    return set_uint64(1 - Stdlib_Sys[11], cst_BE$1, t, i, c);
   }
   function get_uint16$0(t, i){
    return get_uint16(1 - Stdlib_Sys[11], cst_BE$2, t, i);
   }
   function get_uint32$0(t, i){
    return get_uint32(1 - Stdlib_Sys[11], cst_BE$3, t, i);
   }
   function get_uint64$0(t, i){
    return get_uint64(1 - Stdlib_Sys[11], cst_BE$4, t, i);
   }
   function set_uint16$1(t, i, c){
    return set_uint16(Stdlib_Sys[11], cst_LE, t, i, c);
   }
   function set_uint32$1(t, i, c){
    return set_uint32(Stdlib_Sys[11], cst_LE$0, t, i, c);
   }
   function set_uint64$1(t, i, c){
    return set_uint64(Stdlib_Sys[11], cst_LE$1, t, i, c);
   }
   function get_uint16$1(t, i){
    return get_uint16(Stdlib_Sys[11], cst_LE$2, t, i);
   }
   function get_uint32$1(t, i){
    return get_uint32(Stdlib_Sys[11], cst_LE$3, t, i);
   }
   function get_uint64$1(t, i){
    return get_uint64(Stdlib_Sys[11], cst_LE$4, t, i);
   }
   function set_uint16$2(t, i, c){return set_uint16(0, cst_HE, t, i, c);}
   function set_uint32$2(t, i, c){return set_uint32(0, cst_HE$0, t, i, c);}
   function set_uint64$2(t, i, c){return set_uint64(0, cst_HE$1, t, i, c);}
   function get_uint16$2(t, i){return get_uint16(0, cst_HE$2, t, i);}
   function get_uint32$2(t, i){return get_uint32(0, cst_HE$3, t, i);}
   function get_uint64$2(t, i){return get_uint64(0, cst_HE$4, t, i);}
   function length(param){var len = param[3]; return len;}
   function sum_lengths(caller, l){
    var acc = 0, param = l;
    for(;;){
     if(! param) return acc;
     var t = param[2], h = param[1], sum = h[3] + acc | 0;
     if(sum < acc) return caml_call1(Stdlib[1], caller);
     var acc = sum, param = t;
    }
   }
   function lenv(l){return sum_lengths(cst_Cstruct_lenv, l);}
   function copyv(ts){
    var
     sz = sum_lengths(cst_Cstruct_copyv, ts),
     dst = caml_create_bytes(sz),
     _a$_ = 0;
    function _ba_(off, src){
     var x = src[3];
     runtime.caml_blit_bigstring_to_string(src[1], src[2], dst, off, x);
     return off + x | 0;
    }
    caml_call3(Stdlib_List[26], _ba_, _a$_, ts);
    return caml_call1(Stdlib_Bytes[44], dst);
   }
   function fillv(src, dst){
    var dst$0 = dst, n = 0, param = src;
    for(;;){
     if(! param) return [0, n, 0];
     var tl = param[2], hd = param[1], avail = dst$0[3], first = hd[3];
     if(first > avail){
      blit(hd, 0, dst$0, 0, avail);
      var rest_hd = shift(hd, avail);
      return [0, n + avail | 0, [0, rest_hd, tl]];
     }
     blit(hd, 0, dst$0, 0, first);
     var
      n$0 = n + first | 0,
      dst$1 = shift(dst$0, first),
      dst$0 = dst$1,
      n = n$0,
      param = tl;
    }
   }
   function to_string(opt, sz, t){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(sz) var l = sz[1], len = l; else var len = t[3] - off | 0;
    return copy_to_string(cst_to_string, t, off, len);
   }
   function to_hex_string(opt, sz, t){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    function nibble_to_char(i){
     return 10 <= i
             ? caml_call1(Stdlib_Char[1], (i - 10 | 0) + 97 | 0)
             : caml_call1(Stdlib_Char[1], i + 48 | 0);
    }
    if(sz) var l = sz[1], len = l; else var len = t[3] - off | 0;
    if(0 <= len && 0 <= off && (t[3] - off | 0) >= len){
     var out = caml_create_bytes(2 * len | 0), _a9_ = len - 1 | 0, _a8_ = 0;
     if(_a9_ >= 0){
      var i = _a8_;
      for(;;){
       var c = caml_ba_get_1(t[1], (i + t[2] | 0) + off | 0);
       caml_bytes_set(out, 2 * i | 0, nibble_to_char(c >>> 4 | 0));
       caml_bytes_set(out, (2 * i | 0) + 1 | 0, nibble_to_char(c & 15));
       var _a__ = i + 1 | 0;
       if(_a9_ === i) break;
       var i = _a__;
      }
     }
     return caml_call1(Stdlib_Bytes[44], out);
    }
    return caml_call2(caml_call2(err(_i_), pp_t, t), off, len);
   }
   function to_bytes(off, len, t){
    var _a7_ = to_string(off, len, t);
    return caml_call1(Stdlib_Bytes[45], _a7_);
   }
   function of_data_abstract(blitfun, lenfun, allocator, opt, len, buf){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var len$0 = len[1], buflen = len$0;
    else
     var buflen = caml_call1(lenfun, buf) - off | 0;
    if(allocator){
     var fn = allocator[1], c = caml_call1(fn, buflen);
     caml_call5(blitfun, buf, off, c, 0, buflen);
     return [0, c[1], c[2], buflen];
    }
    var c$0 = create_unsafe(buflen);
    caml_call5(blitfun, buf, off, c$0, 0, buflen);
    return c$0;
   }
   function of_string(allocator, off, len, buf){
    return of_data_abstract
            (blit_from_string,
             caml_ml_string_length,
             allocator,
             off,
             len,
             buf);
   }
   function of_bytes(allocator, off, len, buf){
    return of_data_abstract
            (blit_from_bytes, caml_ml_bytes_length, allocator, off, len, buf);
   }
   function of_hex(opt, len, str){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var l = len[1], l$0 = l;
    else
     var l$0 = caml_ml_string_length(str) - off | 0;
    var
     str$0 = caml_call3(Stdlib_String[16], str, off, l$0),
     z = [0, create_unsafe(caml_ml_string_length(str$0) >>> 1 | 0), 0, 0, 0],
     st = [0, z];
    function _a2_(char$0){
     var
      param = st[1],
      acc = param[4],
      p = param[3],
      i = param[2],
      cs = param[1],
      p$0 = p + 1 | 0,
      _a5_ = char$0 - 9 | 0;
     a:
     {
      b:
      {
       if(4 < _a5_ >>> 0){
        if(23 === _a5_) break b;
       }
       else if(1 < _a5_ - 2 >>> 0) break b;
       var _a6_ = 0;
       break a;
      }
      var _a6_ = 1;
     }
     if(_a6_)
      var _a4_ = [0, cs, i, p$0, acc];
     else{
      a:
      {
       if(65 <= char$0){
        if(97 <= char$0){
         if(103 > char$0){var match = char$0 - 87 | 0; break a;}
        }
        else if(71 > char$0){var match = char$0 - 55 | 0; break a;}
       }
       else if(9 >= char$0 - 48 >>> 0){var match = char$0 - 48 | 0; break a;}
       var match = caml_call4(Stdlib_Format[147], Stdlib[1], _x_, p, char$0);
      }
      if(acc){
       var y = acc[1];
       set_uint8(cs, i, match | y);
       var _a4_ = [0, cs, i + 1 | 0, p$0, 0];
      }
      else
       var _a4_ = [0, cs, i, p$0, [0, match << 4]];
     }
     st[1] = _a4_;
     return 0;
    }
    caml_call2(Stdlib_String[30], _a2_, str$0);
    var _a3_ = st[1], cs = _a3_[1];
    if(_a3_[4]) return caml_call2(Stdlib_Format[147], Stdlib[1], _y_);
    var i = _a3_[2];
    return sub(cs, 0, i);
   }
   function hexdump_pp(fmt, t){
    function before(fmt, param){
     return 0 === param
             ? 0
             : 8
               === param
               ? caml_call2(Stdlib_Format[137], fmt, _z_)
               : caml_call2(Stdlib_Format[137], fmt, _A_);
    }
    function after(fmt, param){
     return 15 === param ? caml_call2(Stdlib_Format[137], fmt, _B_) : 0;
    }
    caml_call2(Stdlib_Format[7], fmt, 0);
    var _a0_ = t[3] - 1 | 0, _aZ_ = 0;
    if(_a0_ >= 0){
     var i = _aZ_;
     for(;;){
      var column = i % 16 | 0, c = caml_ba_get_1(t[1], t[2] + i | 0);
      caml_call7
       (Stdlib_Format[137], fmt, _C_, before, column, c, after, column);
      var _a1_ = i + 1 | 0;
      if(_a0_ === i) break;
      var i = _a1_;
     }
    }
    return caml_call2(Stdlib_Format[3], fmt, 0);
   }
   var hexdump = caml_call2(Stdlib_Format[138], _D_, hexdump_pp);
   function hexdump_to_buffer(buf, t){
    var f = caml_call1(Stdlib_Format[114], buf);
    return caml_call4(Stdlib_Format[137], f, _E_, hexdump_pp, t);
   }
   function split(opt, t, off){
    if(opt) var sth = opt[1], start = sth; else var start = 0;
    try{
     var
      header = sub(t, start, off),
      body = sub(t, start + off | 0, (t[3] - off | 0) - start | 0),
      _aX_ = [0, header, body];
     return _aX_;
    }
    catch(_aY_){
     var _aW_ = caml_wrap_exception(_aY_);
     if(_aW_[1] === Stdlib[6])
      return caml_call2(caml_call2(err(_s_), pp_t, t), start, off);
     throw caml_maybe_attach_backtrace(_aW_, 0);
    }
   }
   function iter(lenfn, pfn, t){
    var body = [0, [0, t]], i = [0, 0];
    return function(param){
     var match = body[1];
     if(! match) return 0;
     var buf = match[1];
     if(0 === buf[3]){body[1] = 0; return 0;}
     var match$0 = caml_call1(lenfn, buf);
     if(! match$0){body[1] = 0; return 0;}
     var plen = match$0[1];
     i[1]++;
     try{var _aU_ = split(0, buf, plen), match$1 = _aU_;}
     catch(_aV_){
      var _aS_ = caml_wrap_exception(_aV_);
      if(_aS_[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(_aS_, 0);
      var
       _aT_ = i[1],
       match$1 = caml_call2(caml_call2(err(_t_), pp_t, buf), _aT_, plen);
     }
     var rest = match$1[2], p = match$1[1];
     body[1] = [0, rest];
     return [0, caml_call1(pfn, p)];};
   }
   function fold(f, next, acc){
    var acc$0 = acc;
    for(;;){
     var match = caml_call1(next, 0);
     if(! match) return acc$0;
     var v = match[1], acc$1 = caml_call2(f, acc$0, v), acc$0 = acc$1;
    }
   }
   function append(cs1, cs2){
    var l1 = cs1[3], l2 = cs2[3], cs = create_unsafe(l1 + l2 | 0);
    blit(cs1, 0, cs, 0, l1);
    blit(cs2, 0, cs, l1, l2);
    return cs;
   }
   function concat(css){
    if(! css) return create_unsafe(0);
    if(css[2]){
     var
      result = create_unsafe(sum_lengths(cst_Cstruct_concat, css)),
      aux =
        function(off, cs){
         var n = cs[3];
         blit(cs, 0, result, off, n);
         return off + n | 0;
        };
     caml_call3(Stdlib_List[26], aux, 0, css);
     return result;
    }
    var cs = css[1];
    return cs;
   }
   function rev(t){
    var n = t[3], out = create_unsafe(n), _aQ_ = n - 1 | 0, _aP_ = 0;
    if(_aQ_ >= 0){
     var i_src = _aP_;
     for(;;){
      var byte$0 = get_uint8(t, i_src), i_dst = (n - 1 | 0) - i_src | 0;
      set_uint8(out, i_dst, byte$0);
      var _aR_ = i_src + 1 | 0;
      if(_aQ_ === i_src) break;
      var i_src = _aR_;
     }
    }
    return out;
   }
   function get(param, zidx){
    var
     len = param[3],
     off = param[2],
     buffer = param[1],
     _aN_ = zidx < 0 ? 1 : 0,
     _aO_ = _aN_ || (len <= zidx ? 1 : 0);
    if(_aO_) caml_call1(Stdlib[1], cst_index_out_of_bounds);
    return caml_ba_get_1(buffer, off + zidx | 0);
   }
   function get_byte(param, zidx){
    var
     len = param[3],
     off = param[2],
     buffer = param[1],
     _aL_ = zidx < 0 ? 1 : 0,
     _aM_ = _aL_ || (len <= zidx ? 1 : 0);
    if(_aM_) caml_call1(Stdlib[1], cst_index_out_of_bounds$0);
    return caml_ba_get_1(buffer, off + zidx | 0);
   }
   function string(opt, len, str){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    var str_len = caml_ml_string_length(str);
    if(len) var len$0 = len[1], len$1 = len$0; else var len$1 = str_len;
    var _aI_ = off < 0 ? 1 : 0;
    if(_aI_)
     var _aJ_ = _aI_;
    else
     var
      _aK_ = len$1 < 0 ? 1 : 0,
      _aJ_ = _aK_ || (str_len < (off + len$1 | 0) ? 1 : 0);
    if(_aJ_) caml_call1(Stdlib[1], cst_index_out_of_bounds$1);
    var
     buffer =
       caml_call3
        (Stdlib_Bigarray[19][1],
         Stdlib_Bigarray[13],
         Stdlib_Bigarray[15],
         str_len);
    runtime.caml_blit_string_to_bigstring(str, 0, buffer, 0, str_len);
    return of_bigarray([0, off], [0, len$1], buffer);
   }
   function buffer(opt, len, buffer){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    var buffer_len = caml_ba_dim_1(buffer);
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = buffer_len - off | 0;
    var _aF_ = off < 0 ? 1 : 0;
    if(_aF_)
     var _aG_ = _aF_;
    else
     var
      _aH_ = len$1 < 0 ? 1 : 0,
      _aG_ = _aH_ || (buffer_len < (off + len$1 | 0) ? 1 : 0);
    if(_aG_) caml_call1(Stdlib[1], cst_index_out_of_bounds$2);
    return of_bigarray([0, off], [0, len$1], buffer);
   }
   function start_pos(param){var off = param[2]; return off;}
   function stop_pos(param){
    var len = param[3], off = param[2];
    return off + len | 0;
   }
   function head(opt, cs){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    var len = cs[3];
    if(0 === len) return 0;
    var _aE_ = rev ? len - 1 | 0 : 0;
    return [0, get_char(cs, _aE_)];
   }
   function tail(opt, cs){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    var len = cs[3], off = cs[2], buffer = cs[1];
    return 0 === len
            ? cs
            : rev
              ? of_bigarray([0, off], [0, len - 2 | 0], buffer)
              : of_bigarray([0, off + 1 | 0], [0, len - 1 | 0], buffer);
   }
   function is_empty(param){var len = param[3]; return 0 === len ? 1 : 0;}
   function is_prefix(affix, cs){
    var len = cs[3], alen = affix[3];
    if(len < alen) return 0;
    var max_zidx = alen - 1 | 0, i = 0;
    for(;;){
     if(max_zidx < i) return 1;
     var _aD_ = get_char(cs, i);
     if(get_char(affix, i) !== _aD_) return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function is_infix(affix, cs){
    var len = cs[3], alen = affix[3];
    if(len < alen) return 0;
    var max_zidx_a = alen - 1 | 0, max_zidx_s = len - alen | 0, i = 0, k = 0;
    for(;;){
     if(max_zidx_s < i) return 0;
     if(max_zidx_a < k) return 1;
     if(0 < k){
      var _aB_ = get_char(cs, i + k | 0);
      if(get_char(affix, k) === _aB_)
       var k$0 = k + 1 | 0, k = k$0;
      else
       var i$0 = i + 1 | 0, i = i$0, k = 0;
     }
     else{
      var _aC_ = get_char(cs, i);
      if(get_char(affix, 0) === _aC_)
       var k = 1;
      else
       var i$1 = i + 1 | 0, i = i$1, k = 0;
     }
    }
   }
   function is_suffix(affix, cs){
    var len = cs[3], alen = affix[3];
    if(len < alen) return 0;
    var
     max_zidx = alen - 1 | 0,
     max_zidx_a = alen - 1 | 0,
     max_zidx_s = len - 1 | 0,
     i = 0;
    for(;;){
     if(max_zidx < i) return 1;
     var _aA_ = get_char(cs, max_zidx_s - i | 0);
     if(get_char(affix, max_zidx_a - i | 0) !== _aA_) return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function for_all(sat, cs){
    var acc = 1, i = 0;
    for(;;){
     if(i >= cs[3]) return acc;
     var
      i$0 = i + 1 | 0,
      _az_ = caml_call1(sat, get_char(cs, i)),
      acc$0 = _az_ ? acc : _az_,
      acc = acc$0,
      i = i$0;
    }
   }
   function exists(sat, cs){
    var acc = 0, i = 0;
    for(;;){
     if(i >= cs[3]) return acc;
     var
      i$0 = i + 1 | 0,
      _ay_ = caml_call1(sat, get_char(cs, i)),
      acc$0 = _ay_ || acc,
      acc = acc$0,
      i = i$0;
    }
   }
   function start(param){
    var off = param[2], buffer = param[1];
    return of_bigarray([0, off], _F_, buffer);
   }
   function stop(param){
    var len = param[3], off = param[2], buffer = param[1];
    return of_bigarray([0, off + len | 0], _G_, buffer);
   }
   function is_white(param){
    a:
    {
     if(14 <= param){if(32 === param) break a;} else if(9 <= param) break a;
     return 0;
    }
    return 1;
   }
   function trim(opt, cs){
    if(opt) var sth = opt[1], drop = sth; else var drop = is_white;
    var max_zpos = cs[3], off = cs[2], buffer = cs[1];
    if(0 === max_zpos) return cs;
    var max_zidx = max_zpos - 1 | 0;
    a:
    {
     b:
     {
      var i = 0;
      for(;;){
       if(max_zidx < i) break b;
       if(! caml_call1(drop, get_char(cs, i))) break;
       var i$0 = i + 1 | 0, i = i$0;
      }
      var left = i;
      break a;
     }
     var left = max_zpos;
    }
    if(left === max_zpos)
     return of_bigarray
             ([0, ((off * 2 | 0) + max_zpos | 0) / 2 | 0], _H_, buffer);
    var i$1 = max_zidx;
    for(;;){
     if(0 <= i$1){
      if(caml_call1(drop, get_char(cs, i$1))){
       var i$2 = i$1 - 1 | 0, i$1 = i$2;
       continue;
      }
      var right = i$1 + 1 | 0;
     }
     else
      var right = 0;
     if(0 === left && right === max_zpos) return cs;
     return of_bigarray([0, off + left | 0], [0, right - left | 0], buffer);
    }
   }
   function span(opt, _ax_, _aw_, _av_, cs){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    if(_ax_) var sth$0 = _ax_[1], min = sth$0; else var min = 0;
    if(_aw_) var sth$1 = _aw_[1], max = sth$1; else var max = Stdlib[19];
    if(_av_)
     var sth$2 = _av_[1], sat = sth$2;
    else
     var sat = function(param){return 1;};
    if(rev){
     var len$0 = cs[3], off$0 = cs[2], v$0 = cs[1];
     if(min < 0) caml_call1(Stdlib[1], cst_span_negative_min$0);
     if(max < 0) caml_call1(Stdlib[1], cst_span_negative_max$0);
     if(max >= min && 0 !== max){
      var
       max_zidx$1 = len$0 - 1 | 0,
       k$0 = len$0 - max | 0,
       min_zidx = 0 <= k$0 ? k$0 : 0,
       need_zidx = (len$0 - min | 0) - 1 | 0,
       i$1 = max_zidx$1;
      for(;;){
       if(min_zidx > i$1) break;
       if(! caml_call1(sat, get_char(cs, i$1))) break;
       var i$2 = i$1 - 1 | 0, i$1 = i$2;
      }
      if(need_zidx >= i$1 && i$1 !== max_zidx$1){
       if(0 > i$1) return [0, buffer([0, off$0], _N_, v$0), cs];
       var
        _au_ =
          buffer
           ([0, (off$0 + i$1 | 0) + 1 | 0],
            [0, len$0 - (i$1 + 1 | 0) | 0],
            v$0);
       return [0, buffer([0, off$0], [0, i$1 + 1 | 0], v$0), _au_];
      }
      return [0, cs, buffer([0, off$0 + len$0 | 0], _M_, v$0)];
     }
     return [0, cs, buffer([0, off$0 + len$0 | 0], _L_, v$0)];
    }
    var len = cs[3], off = cs[2], v = cs[1];
    if(min < 0) caml_call1(Stdlib[1], cst_span_negative_min);
    if(max < 0) caml_call1(Stdlib[1], cst_span_negative_max);
    if(max >= min && 0 !== max){
     var max_zidx = len - 1 | 0, k = max - 1 | 0;
     a:
     {
      if(max_zidx >= k && 0 <= k){var max_zidx$0 = k; break a;}
      var max_zidx$0 = max_zidx;
     }
     var i = 0;
     for(;;){
      if(i > max_zidx$0) break;
      if(! caml_call1(sat, get_char(cs, i))) break;
      var i$0 = i + 1 | 0, i = i$0;
     }
     if(i >= min && 0 !== i){
      if(i === len) return [0, cs, buffer([0, off + len | 0], _K_, v)];
      var _at_ = buffer([0, off + i | 0], [0, len - i | 0], v);
      return [0, buffer([0, off], [0, i], v), _at_];
     }
     return [0, buffer([0, off], _J_, v), cs];
    }
    return [0, buffer([0, off], _I_, v), cs];
   }
   function take(opt, min, max, sat, cs){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    var
     _ap_ = span([0, rev], min, max, sat, cs),
     _aq_ =
       rev ? function(_ar_){return _ar_[2];} : function(_as_){return _as_[1];};
    return _aq_(_ap_);
   }
   function drop(opt, min, max, sat, cs){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    var
     _al_ = span([0, rev], min, max, sat, cs),
     _am_ =
       rev ? function(_an_){return _an_[1];} : function(_ao_){return _ao_[2];};
    return _am_(_al_);
   }
   function cut(opt, sep, cs){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    if(rev){
     var len$0 = cs[3], off$0 = cs[2], v$0 = cs[1], sep_len$0 = sep[3];
     if(0 === sep_len$0) caml_call1(Stdlib[1], cst_cut_empty_separator$0);
     var
      max_sep_zidx$0 = sep_len$0 - 1 | 0,
      max_s_zidx$0 = len$0 - 1 | 0,
      i$5 = max_s_zidx$0 - max_sep_zidx$0 | 0,
      i$3 = i$5;
     for(;;){
      if(0 > i$3) return 0;
      var _ak_ = get_char(sep, 0);
      if(get_char(cs, i$3) === _ak_){
       var k$1 = 1;
       for(;;){
        if(max_sep_zidx$0 < k$1){
         var
          _ai_ =
            buffer
             ([0, (off$0 + i$3 | 0) + sep_len$0 | 0],
              [0, (len$0 - i$3 | 0) - sep_len$0 | 0],
              v$0);
         return [0, [0, buffer([0, off$0], [0, i$3], v$0), _ai_]];
        }
        var _aj_ = get_char(sep, k$1);
        if(get_char(cs, i$3 + k$1 | 0) !== _aj_) break;
        var k$2 = k$1 + 1 | 0, k$1 = k$2;
       }
       var i$2 = i$3 - 1 | 0, i$3 = i$2;
      }
      else
       var i$4 = i$3 - 1 | 0, i$3 = i$4;
     }
    }
    else{
     var len = cs[3], off = cs[2], v = cs[1], sep_len = sep[3];
     if(0 === sep_len) caml_call1(Stdlib[1], cst_cut_empty_separator);
     var
      max_sep_zidx = sep_len - 1 | 0,
      max_s_zidx = len - sep_len | 0,
      i$0 = 0;
     for(;;){
      if(max_s_zidx < i$0) return 0;
      var _ah_ = get_char(sep, 0);
      if(get_char(cs, i$0) === _ah_){
       var k = 1;
       for(;;){
        if(max_sep_zidx < k){
         var
          _af_ =
            buffer
             ([0, (off + i$0 | 0) + sep_len | 0],
              [0, (len - i$0 | 0) - sep_len | 0],
              v);
         return [0, [0, buffer([0, off], [0, i$0], v), _af_]];
        }
        var _ag_ = get_char(sep, k);
        if(get_char(cs, i$0 + k | 0) !== _ag_) break;
        var k$0 = k + 1 | 0, k = k$0;
       }
       var i = i$0 + 1 | 0, i$0 = i;
      }
      else
       var i$1 = i$0 + 1 | 0, i$0 = i$1;
     }
    }
   }
   function add_sub(no_empty, buf, off, len, acc){
    return 0 === len
            ? no_empty ? acc : [0, buffer([0, off], [0, len], buf), acc]
            : [0, buffer([0, off], [0, len], buf), acc];
   }
   function cuts(opt, _ae_, sep, cs){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    if(_ae_) var sth$0 = _ae_[1], empty = sth$0; else var empty = 1;
    if(rev){
     var
      no_empty = 1 - empty,
      zanchor$0 = cs[3],
      buffer$0 = cs[1],
      sep_len$0 = sep[3];
     if(0 === sep_len$0) caml_call1(Stdlib[1], cst_cuts_empty_separator$0);
     var
      max_sep_zidx$0 = sep_len$0 - 1 | 0,
      max_s_zidx$0 = zanchor$0 - 1 | 0,
      i$5 = max_s_zidx$0 - max_sep_zidx$0 | 0,
      zanchor$2 = zanchor$0,
      zanchor$1 = i$5,
      acc$2 = 0;
     for(;;){
      if(0 > zanchor$1){
       if(zanchor$2 !== zanchor$0)
        return add_sub(no_empty, buffer$0, 0, zanchor$2, acc$2);
       if(no_empty && 0 === zanchor$0) return 0;
       return [0, cs, 0];
      }
      var _ad_ = get_char(sep, 0);
      if(get_char(cs, zanchor$1) === _ad_){
       a:
       {
        var k$1 = 1;
        for(;;){
         if(max_sep_zidx$0 < k$1) break a;
         var _ac_ = get_char(cs, k$1);
         if(get_char(cs, zanchor$1 + k$1 | 0) !== _ac_) break;
         var k$2 = k$1 + 1 | 0, k$1 = k$2;
        }
        var i$3 = zanchor$1 - 1 | 0, zanchor$1 = i$3;
        continue;
       }
       var
        off$0 = zanchor$1 + sep_len$0 | 0,
        acc$1 =
          add_sub(no_empty, buffer$0, off$0, zanchor$2 - off$0 | 0, acc$2),
        i$2 = zanchor$1 - sep_len$0 | 0,
        zanchor$2 = zanchor$1,
        zanchor$1 = i$2,
        acc$2 = acc$1;
      }
      else
       var i$4 = zanchor$1 - 1 | 0, zanchor$1 = i$4;
     }
    }
    else{
     var
      no_empty$0 = 1 - empty,
      len = cs[3],
      off = cs[2],
      buffer = cs[1],
      sep_len = sep[3];
     if(0 === sep_len) caml_call1(Stdlib[1], cst_cuts_empty_separator);
     var
      max_sep_zidx = sep_len - 1 | 0,
      max_s_zidx = len - sep_len | 0,
      zanchor = 0,
      i$0 = 0,
      acc$0 = 0;
     for(;;){
      if(max_s_zidx < i$0){
       if(0 !== zanchor){
        var
         _aa_ =
           add_sub
            (no_empty$0, buffer, off + zanchor | 0, len - zanchor | 0, acc$0);
        return caml_call1(Stdlib_List[10], _aa_);
       }
       if(no_empty$0 && 0 === len) return 0;
       return [0, cs, 0];
      }
      var _ab_ = get_char(sep, 0);
      if(get_char(cs, i$0) === _ab_){
       a:
       {
        var k = 1;
        for(;;){
         if(max_sep_zidx < k) break a;
         var _$_ = get_char(sep, k);
         if(get_char(cs, i$0 + k | 0) !== _$_) break;
         var k$0 = k + 1 | 0, k = k$0;
        }
        var i = i$0 + 1 | 0, i$0 = i;
        continue;
       }
       var
        new_start = i$0 + sep_len | 0,
        acc =
          add_sub
           (no_empty$0, buffer, off + zanchor | 0, i$0 - zanchor | 0, acc$0),
        zanchor = new_start,
        i$0 = new_start,
        acc$0 = acc;
      }
      else
       var i$1 = i$0 + 1 | 0, i$0 = i$1;
     }
    }
   }
   function fields(opt, ___, cs){
    if(opt) var sth = opt[1], empty = sth; else var empty = 0;
    if(___) var sth$0 = ___[1], is_sep = sth$0; else var is_sep = is_white;
    var
     end_pos = cs[3],
     off = cs[2],
     buffer = cs[1],
     no_empty = 1 - empty,
     i$1 = end_pos - 1 | 0,
     end_pos$1 = i$1,
     end_pos$0 = end_pos,
     acc = 0;
    for(;;){
     if(0 > end_pos$1){
      if(end_pos$0 !== end_pos)
       return add_sub
               (no_empty,
                buffer,
                off,
                end_pos$0 - (end_pos$1 + 1 | 0) | 0,
                acc);
      if(no_empty && 0 === end_pos) return 0;
      return [0, cs, 0];
     }
     if(caml_call1(is_sep, get_char(cs, end_pos$1)))
      var
       acc$0 =
         add_sub
          (no_empty,
           buffer,
           (off + end_pos$1 | 0) + 1 | 0,
           end_pos$0 - (end_pos$1 + 1 | 0) | 0,
           acc),
       i = end_pos$1 - 1 | 0,
       end_pos$0 = end_pos$1,
       end_pos$1 = i,
       acc = acc$0;
     else
      var i$0 = end_pos$1 - 1 | 0, end_pos$1 = i$0;
    }
   }
   function find(opt, sat, cs){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    if(rev){
     var len$0 = cs[3], v$0 = cs[1], i$3 = len$0 - 1 | 0, i$1 = i$3;
     for(;;){
      if(0 > i$1) return 0;
      if(caml_call1(sat, get_char(cs, i$1)))
       return [0, buffer([0, i$1], _P_, v$0)];
      var i$2 = i$1 - 1 | 0, i$1 = i$2;
     }
    }
    else{
     var len = cs[3], v = cs[1], max_idx = len - 1 | 0, i = 0;
     for(;;){
      if(max_idx < i) return 0;
      if(caml_call1(sat, get_char(cs, i))) return [0, buffer([0, i], _O_, v)];
      var i$0 = i + 1 | 0, i = i$0;
     }
    }
   }
   function find_sub(opt, sub, cs){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    if(rev){
     var len$0 = cs[3], v$0 = cs[1], sub_len$0 = sub[3];
     if(len$0 < sub_len$0) return 0;
     var
      max_zidx_sub$0 = sub_len$0 - 1 | 0,
      i$5 = len$0 - sub_len$0 | 0,
      i$2 = i$5,
      k$1 = 0;
     for(;;){
      if(0 > i$2) return 0;
      if(max_zidx_sub$0 < k$1)
       return [0, buffer([0, i$2], [0, sub_len$0], v$0)];
      if(0 < k$1){
       var _Y_ = get_char(cs, i$2 + k$1 | 0);
       if(get_char(sub, k$1) === _Y_)
        var k$2 = k$1 + 1 | 0, k$1 = k$2;
       else
        var i$3 = i$2 - 1 | 0, i$2 = i$3, k$1 = 0;
      }
      else{
       var _Z_ = get_char(cs, i$2);
       if(get_char(sub, 0) === _Z_)
        var k$1 = 1;
       else
        var i$4 = i$2 - 1 | 0, i$2 = i$4, k$1 = 0;
      }
     }
    }
    else{
     var len = cs[3], off = cs[2], v = cs[1], sub_len = sub[3];
     if(len < sub_len) return 0;
     var
      max_zidx_sub = sub_len - 1 | 0,
      max_zidx_s = len - sub_len | 0,
      i = 0,
      k = 0;
     for(;;){
      if(max_zidx_s < i) return 0;
      if(max_zidx_sub < k)
       return [0, buffer([0, off + i | 0], [0, sub_len], v)];
      if(0 < k){
       var _W_ = get_char(cs, i + k | 0);
       if(get_char(sub, k) === _W_)
        var k$0 = k + 1 | 0, k = k$0;
       else
        var i$0 = i + 1 | 0, i = i$0, k = 0;
      }
      else{
       var _X_ = get_char(cs, i);
       if(get_char(sub, 0) === _X_)
        var k = 1;
       else
        var i$1 = i + 1 | 0, i = i$1, k = 0;
      }
     }
    }
   }
   function filter(sat, cs){
    var len = cs[3];
    if(0 === len) return empty;
    var b = create(len), max_zidx = len - 1 | 0, k = 0, i = 0;
    for(;;){
     if(max_zidx < i) return k === len ? b : sub(b, 0, k);
     var chr = get_char(cs, i);
     if(caml_call1(sat, chr)){
      set_char(b, k, chr);
      var i$0 = i + 1 | 0, k$0 = k + 1 | 0, k = k$0, i = i$0;
     }
     else
      var i$1 = i + 1 | 0, i = i$1;
    }
   }
   function filter_map(f, cs){
    var len = cs[3];
    if(0 === len) return empty;
    var b = create(len), max_zidx = len - 1 | 0, k = 0, i = 0;
    for(;;){
     if(max_zidx < i) return k === len ? b : sub(b, 0, k);
     var match = caml_call1(f, get_char(cs, i));
     if(match){
      var chr = match[1];
      set_char(b, i, chr);
      var i$0 = i + 1 | 0, k$0 = k + 1 | 0, k = k$0, i = i$0;
     }
     else
      var i$1 = i + 1 | 0, i = i$1;
    }
   }
   function map(f, cs){
    var len = cs[3];
    if(0 === len) return empty;
    var b = create(len), _U_ = len - 1 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      set_char(b, i, caml_call1(f, get_char(cs, i)));
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      var i = _V_;
     }
    }
    return b;
   }
   function mapi(f, cs){
    var len = cs[3];
    if(0 === len) return empty;
    var b = create(len), _R_ = len - 1 | 0, _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      set_char(b, i, caml_call2(f, i, get_char(cs, i)));
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      var i = _S_;
     }
    }
    return b;
   }
   var
    Cstruct =
      [0,
       byte$0,
       empty,
       of_bigarray,
       to_bigarray,
       create,
       create_unsafe,
       of_string,
       of_bytes,
       of_hex,
       equal,
       compare,
       byte_to_int,
       check_bounds,
       check_alignment,
       get_char,
       get_uint8,
       set_char,
       set_uint8,
       sub,
       sub_copy,
       shift,
       copy,
       blit,
       blit_from_string,
       blit_from_bytes,
       blit_to_bytes,
       memset,
       split,
       to_string,
       to_hex_string,
       to_bytes,
       [0,
        get_uint16$0,
        get_uint32$0,
        get_uint64$0,
        set_uint16$0,
        set_uint32$0,
        set_uint64$0],
       [0,
        get_uint16$1,
        get_uint32$1,
        get_uint64$1,
        set_uint16$1,
        set_uint32$1,
        set_uint64$1],
       [0,
        get_uint16$2,
        get_uint32$2,
        get_uint64$2,
        set_uint16$2,
        set_uint32$2,
        set_uint64$2],
       hexdump,
       hexdump_to_buffer,
       hexdump_pp,
       debug,
       lenv,
       copyv,
       fillv,
       shiftv,
       iter,
       fold,
       append,
       concat,
       rev,
       get,
       get_byte,
       string,
       buffer,
       start_pos,
       stop_pos,
       length,
       head,
       tail,
       is_empty,
       is_prefix,
       is_suffix,
       is_infix,
       for_all,
       exists,
       start,
       stop,
       trim,
       span,
       take,
       drop,
       cut,
       cuts,
       fields,
       find,
       find_sub,
       filter,
       filter_map,
       map,
       mapi,
       sum_lengths];
   runtime.caml_register_global(98, Cstruct, "Cstruct");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Cstruct_cap
//# unitInfo: Requires: Cstruct, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Cstruct = global_data.Cstruct,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    of_bigarray = Cstruct[3],
    create = Cstruct[5],
    create_unsafe = Cstruct[6],
    of_hex = Cstruct[9],
    equal = Cstruct[10],
    compare = Cstruct[11],
    check_alignment = Cstruct[14],
    get_char = Cstruct[15],
    get_uint8 = Cstruct[16],
    set_char = Cstruct[17],
    set_uint8 = Cstruct[18],
    shift = Cstruct[21],
    copy = Cstruct[22],
    memset = Cstruct[27],
    split = Cstruct[28],
    to_string = Cstruct[29],
    to_hex_string = Cstruct[30],
    to_bytes = Cstruct[31],
    BE = Cstruct[32],
    LE = Cstruct[33],
    lenv = Cstruct[39],
    copyv = Cstruct[40],
    fillv = Cstruct[41],
    shiftv = Cstruct[42],
    iter = Cstruct[43],
    fold = Cstruct[44],
    append = Cstruct[45],
    rev = Cstruct[47],
    head = Cstruct[55],
    tail = Cstruct[56],
    is_empty = Cstruct[57],
    is_prefix = Cstruct[58],
    is_suffix = Cstruct[59],
    is_infix = Cstruct[60],
    for_all = Cstruct[61],
    exists = Cstruct[62],
    start = Cstruct[63],
    stop = Cstruct[64],
    trim = Cstruct[65],
    span = Cstruct[66],
    take = Cstruct[67],
    drop = Cstruct[68],
    cut = Cstruct[69],
    cuts = Cstruct[70],
    fields = Cstruct[71],
    find = Cstruct[72],
    find_sub = Cstruct[73],
    filter = Cstruct[74],
    filter_map = Cstruct[75],
    map = Cstruct[76],
    mapi = Cstruct[77],
    of_string = caml_call1(Cstruct[7], 0),
    of_bytes = caml_call1(Cstruct[8], 0),
    cst_Cstruct_Cap_concat = "Cstruct.Cap.concat",
    _a_ = [0, "lib/cstruct_cap.ml", 72, 2];
   function pp(ppf, t){return caml_call2(Cstruct[37], ppf, t);}
   var length = Cstruct[54];
   function blit(src, src_off, dst, dst_off, len){
    return caml_call5(Cstruct[23], src, src_off, dst, dst_off, len);
   }
   function blit_from_string(src, src_off, dst, dst_off, len){
    return caml_call5(Cstruct[24], src, src_off, dst, dst_off, len);
   }
   function blit_from_bytes(src, src_off, dst, dst_off, len){
    return caml_call5(Cstruct[25], src, src_off, dst, dst_off, len);
   }
   function blit_to_bytes(src, src_off, dst, dst_off, len){
    return caml_call5(Cstruct[26], src, src_off, dst, dst_off, len);
   }
   function sub(t, off, len){return caml_call3(Cstruct[19], t, off, len);}
   function sub_copy(t, off, len){
    return caml_call3(Cstruct[20], t, off, len);
   }
   var unsafe_to_bigarray = Cstruct[4];
   function concat(vss){
    var
     res =
       caml_call1
        (create_unsafe, caml_call2(Cstruct[78], cst_Cstruct_Cap_concat, vss));
    function go(off, v){
     var len = caml_call1(Cstruct[54], v);
     caml_call5(Cstruct[23], v, 0, res, off, len);
     return off + len | 0;
    }
    var len = caml_call3(Stdlib_List[26], go, 0, vss);
    if(len === caml_call1(Cstruct[54], res)) return res;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function _b_(_d_){return _d_;}
   var
    Cstruct_cap =
      [0,
       function(_c_){return _c_;},
       _b_,
       equal,
       compare,
       pp,
       length,
       check_alignment,
       lenv,
       create,
       create_unsafe,
       sub,
       sub_copy,
       shift,
       shiftv,
       split,
       copy,
       append,
       concat,
       fillv,
       rev,
       memset,
       blit,
       blit_from_string,
       blit_from_bytes,
       of_string,
       to_string,
       to_hex_string,
       of_hex,
       copyv,
       of_bytes,
       to_bytes,
       blit_to_bytes,
       of_bigarray,
       unsafe_to_bigarray,
       iter,
       fold,
       get_char,
       set_char,
       get_uint8,
       set_uint8,
       BE,
       LE,
       head,
       tail,
       is_empty,
       is_prefix,
       is_suffix,
       is_infix,
       for_all,
       exists,
       start,
       stop,
       trim,
       span,
       take,
       drop,
       cut,
       cuts,
       fields,
       find,
       find_sub,
       filter,
       filter_map,
       map,
       mapi];
   runtime.caml_register_global(5, Cstruct_cap, "Cstruct_cap");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJjc3RydWN0LmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJwcF90IiwicHBmIiwidCIsInN0cmluZ190Iiwic3RyIiwiYnl0ZXNfdCIsImVyciIsImZtdCIsImIiLCJrIiwiZXJyX2ludmFsaWRfYm91bmRzIiwiZiIsIm9mX2JpZ2FycmF5Iiwib3B0IiwibGVuIiwiYnVmZmVyIiwic3RoIiwib2ZmIiwiZGltIiwibGVuJDAiLCJsZW4kMSIsInRvX2JpZ2FycmF5IiwiY3JlYXRlX3Vuc2FmZSIsImNoZWNrX2JvdW5kcyIsImVtcHR5IiwiY2hlY2tfYWxpZ25tZW50IiwiYWxpZ25tZW50IiwiYnl0ZSQwIiwiaSIsImJ5dGVfdG9faW50IiwiZGVidWciLCJtYXhfbGVuIiwic3ViIiwibmV3X3N0YXJ0IiwibmV3X2VuZCIsIm9sZF9lbmQiLCJzaGlmdCIsImFtb3VudCIsInNoaWZ0diIsInRzJDEiLCJuJDAiLCJ4IiwidHMiLCJ0JDAiLCJ0cyQyIiwidHMkMyIsImNvcHlfdG9fc3RyaW5nIiwiY2FsbGVyIiwic3JjIiwic3Jjb2ZmIiwiY29weSIsImJsaXQiLCJkc3QiLCJkc3RvZmYiLCJzdWJfY29weSIsImNzdHIiLCJjc3RyMiIsImJsaXRfZnJvbV9zdHJpbmciLCJibGl0X2Zyb21fYnl0ZXMiLCJibGl0X3RvX2J5dGVzIiwiY29tcGFyZSIsInQxIiwidDIiLCJsMSIsImwyIiwiciIsInIkMCIsImVxdWFsIiwibWVtc2V0IiwiY3JlYXRlIiwic2V0X3VpbnQ4IiwiYyIsInNldF9jaGFyIiwiZ2V0X3VpbnQ4IiwiZ2V0X2NoYXIiLCJzZXRfdWludDE2Iiwic3dhcCIsInAiLCJzZXRfdWludDMyIiwic2V0X3VpbnQ2NCIsImdldF91aW50MTYiLCJnZXRfdWludDMyIiwiZ2V0X3VpbnQ2NCIsInNldF91aW50MTYkMCIsInNldF91aW50MzIkMCIsInNldF91aW50NjQkMCIsImdldF91aW50MTYkMCIsImdldF91aW50MzIkMCIsImdldF91aW50NjQkMCIsInNldF91aW50MTYkMSIsInNldF91aW50MzIkMSIsInNldF91aW50NjQkMSIsImdldF91aW50MTYkMSIsImdldF91aW50MzIkMSIsImdldF91aW50NjQkMSIsInNldF91aW50MTYkMiIsInNldF91aW50MzIkMiIsInNldF91aW50NjQkMiIsImdldF91aW50MTYkMiIsImdldF91aW50MzIkMiIsImdldF91aW50NjQkMiIsImxlbmd0aCIsInN1bV9sZW5ndGhzIiwibCIsImFjYyIsImgiLCJzdW0iLCJsZW52IiwiY29weXYiLCJzeiIsImZpbGx2IiwiZHN0JDAiLCJuIiwidGwiLCJoZCIsImF2YWlsIiwiZmlyc3QiLCJyZXN0X2hkIiwidG9fc3RyaW5nIiwidG9faGV4X3N0cmluZyIsIm5pYmJsZV90b19jaGFyIiwib3V0IiwidG9fYnl0ZXMiLCJvZl9kYXRhX2Fic3RyYWN0IiwiYmxpdGZ1biIsImxlbmZ1biIsImFsbG9jYXRvciIsImJ1ZiIsImJ1ZmxlbiIsImZuIiwiYyQwIiwib2Zfc3RyaW5nIiwib2ZfYnl0ZXMiLCJvZl9oZXgiLCJsJDAiLCJzdHIkMCIsInoiLCJzdCIsImNoYXIkMCIsImNzIiwicCQwIiwibWF0Y2giLCJ5IiwiaGV4ZHVtcF9wcCIsImJlZm9yZSIsImFmdGVyIiwiY29sdW1uIiwiaGV4ZHVtcCIsImhleGR1bXBfdG9fYnVmZmVyIiwic3BsaXQiLCJzdGFydCIsImhlYWRlciIsImJvZHkiLCJpdGVyIiwibGVuZm4iLCJwZm4iLCJwbGVuIiwicmVzdCIsImZvbGQiLCJuZXh0IiwiYWNjJDAiLCJ2IiwiYWNjJDEiLCJhcHBlbmQiLCJjczEiLCJjczIiLCJjb25jYXQiLCJjc3MiLCJyZXN1bHQiLCJhdXgiLCJyZXYiLCJpX3NyYyIsImlfZHN0IiwiZ2V0IiwiemlkeCIsImdldF9ieXRlIiwic3RyaW5nIiwic3RyX2xlbiIsImJ1ZmZlcl9sZW4iLCJzdGFydF9wb3MiLCJzdG9wX3BvcyIsImhlYWQiLCJ0YWlsIiwiaXNfZW1wdHkiLCJpc19wcmVmaXgiLCJhZmZpeCIsImFsZW4iLCJtYXhfemlkeCIsImkkMCIsImlzX2luZml4IiwibWF4X3ppZHhfYSIsIm1heF96aWR4X3MiLCJrJDAiLCJpJDEiLCJpc19zdWZmaXgiLCJmb3JfYWxsIiwic2F0IiwiZXhpc3RzIiwic3RvcCIsImlzX3doaXRlIiwidHJpbSIsImRyb3AiLCJtYXhfenBvcyIsImxlZnQiLCJpJDIiLCJyaWdodCIsInNwYW4iLCJzdGgkMCIsIm1pbiIsInN0aCQxIiwibWF4Iiwic3RoJDIiLCJvZmYkMCIsInYkMCIsIm1heF96aWR4JDEiLCJtaW5femlkeCIsIm5lZWRfemlkeCIsIm1heF96aWR4JDAiLCJ0YWtlIiwiY3V0Iiwic2VwIiwic2VwX2xlbiQwIiwibWF4X3NlcF96aWR4JDAiLCJtYXhfc196aWR4JDAiLCJpJDUiLCJpJDMiLCJrJDEiLCJrJDIiLCJpJDQiLCJzZXBfbGVuIiwibWF4X3NlcF96aWR4IiwibWF4X3NfemlkeCIsImFkZF9zdWIiLCJub19lbXB0eSIsImN1dHMiLCJ6YW5jaG9yJDAiLCJidWZmZXIkMCIsInphbmNob3IkMiIsInphbmNob3IkMSIsImFjYyQyIiwibm9fZW1wdHkkMCIsInphbmNob3IiLCJmaWVsZHMiLCJpc19zZXAiLCJlbmRfcG9zIiwiZW5kX3BvcyQxIiwiZW5kX3BvcyQwIiwiZmluZCIsIm1heF9pZHgiLCJmaW5kX3N1YiIsInN1Yl9sZW4kMCIsIm1heF96aWR4X3N1YiQwIiwic3ViX2xlbiIsIm1heF96aWR4X3N1YiIsImZpbHRlciIsImNociIsImZpbHRlcl9tYXAiLCJtYXAiLCJtYXBpIiwicHAiLCJzcmNfb2ZmIiwiZHN0X29mZiIsInVuc2FmZV90b19iaWdhcnJheSIsInZzcyIsInJlcyIsImdvIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY3N0cnVjdC9jc3RydWN0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY3N0cnVjdC9jc3RydWN0X2NhcC5tbCJdLCJtYXBw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ZWxCO09BQUFFO09BQUErRztPQUFBbkc7T0FBQWlIO09BK0NmRztPQS9DZXhEO09BQUE0RDtPQUFBdEc7T0FxQmZqQjtPQUlBTTtPQUlBQztPQWZBeUU7T0FkZWI7T0FBQUM7T0FBQWM7T0FBQXpCO09BZWZ3QjtPQWZlVjtPQWlDZi9EO09BakNlL0M7T0E2Q2YwUDtPQTdDZTdHO09BQUFLO09BQUFwRjtPQUFBRjtPQUFBQztPQUFBSDs7O09BQUErRztPQUFBQztPQUFBQztPQUFBQztPQUFBVTtPQUFBTDtPQUFBTTtPQUFBRTtPQUFBL0M7T0FBQWdEO09BQUFFO09BQUFNO09BQUFZO09BQUFqQjtPQUFBa0I7T0FBQWU7T0FBQVE7T0FBQUs7T0FBQUU7T0FBQUs7T0FBQUU7T0FBQUM7T0FBQUM7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBBbmlsIE1hZGhhdmFwZWRkeSA8YW5pbEByZWNvaWwub3JnPlxuICpcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZCBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuICogV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1JcbiAqIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbiAqIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuICogQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0ZcbiAqIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gKilcblxudHlwZSBidWZmZXIgPSAoY2hhciwgQmlnYXJyYXkuaW50OF91bnNpZ25lZF9lbHQsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5BcnJheTEudFxuXG4oKiBOb3RlOlxuICpcbiAqIFdlIHRyeSB0byBtYWludGFpbiB0aGUgcHJvcGVydHkgdGhhdCBubyBjb25zdHJ1Y3RlZCBbdF0gY2FuIGV2ZXIgcG9pbnQgb3V0IG9mXG4gKiBpdHMgdW5kZXJseWluZyBidWZmZXIuIFRoaXMgcHJvcGVydHkgaXMgZ3VhcmRlZCBieSBhbGwgb2YgdGhlIGNvbnN0cnVjdGluZ1xuICogZnVuY3Rpb25zIGFuZCB0aGUgZmFjdCB0aGF0IHRoZSB0eXBlIGlzIHByaXZhdGUsIGFuZCB1c2VkIGJ5IHZhcmlvdXNcbiAqIGZ1bmN0aW9ucyB0aGF0IHdvdWxkIG90aGVyd2lzZSBiZSBjb21wbGV0ZWx5IHVuc2FmZS5cbiAqXG4gKiBGdXJ0aGVybW9yZSwgbm8gb3BlcmF0aW9uIG9uIFt0XSBpcyBhbGxvd2VkIHRvIGV4dGVuZCB0aGUgdmlldyBvbiB0aGVcbiAqIHVuZGVybHlpbmcgQmlnYXJyYXkgc3RydWN0dXJlLCBvbmx5IG5hcnJvd2luZyBpcyBhbGxvd2VkLlxuICpcbiAqIEFsbCB3ZWxsLWludGVuZGVkIHNvdWxzIGFyZSBraW5kbHkgaW52aXRlZCB0byBjcm9zcy1jaGVjayB0aGF0IHRoZSBjb2RlXG4gKiBpbmRlZWQgbWFpbnRhaW5zIHRoaXMgaW52YXJpYW50LlxuICopXG5cbnR5cGUgdCA9IHtcbiAgYnVmZmVyOiBidWZmZXI7XG4gIG9mZiAgIDogaW50O1xuICBsZW4gICA6IGludDtcbn1cblxubGV0IHBwX3QgcHBmIHQgPVxuICBGb3JtYXQuZnByaW50ZiBwcGYgXCJbJWQsJWRdKCVkKVwiIHQub2ZmIHQubGVuIChCaWdhcnJheS5BcnJheTEuZGltIHQuYnVmZmVyKVxubGV0IHN0cmluZ190IHBwZiBzdHIgPVxuICBGb3JtYXQuZnByaW50ZiBwcGYgXCJbJWRdXCIgKFN0cmluZy5sZW5ndGggc3RyKVxubGV0IGJ5dGVzX3QgcHBmIHN0ciA9XG4gIEZvcm1hdC5mcHJpbnRmIHBwZiBcIlslZF1cIiAoQnl0ZXMubGVuZ3RoIHN0cilcblxubGV0IGVyciBmbXQgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAgaW4gICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHRocmVhZCBzYWZldHkuICopXG4gIGxldCBwcGYgPSBGb3JtYXQuZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIHBwZiA9IEZvcm1hdC5wcF9wcmludF9mbHVzaCBwcGYgKCk7IGludmFsaWRfYXJnIChCdWZmZXIuY29udGVudHMgYikgaW5cbiAgRm9ybWF0LmtmcHJpbnRmIGsgcHBmIGZtdFxuXG5sZXQgZXJyX29mX2JpZ2FycmF5IHQgPSBlcnIgXCJDc3RydWN0Lm9mX2JpZ2FycmF5IG9mZj0lZCBsZW49JWRcIiB0XG5sZXQgZXJyX3N1YiB0ID0gZXJyIFwiQ3N0cnVjdC5zdWI6ICVhIG9mZj0lZCBsZW49JWRcIiBwcF90IHRcbmxldCBlcnJfc2hpZnQgdCA9IGVyciBcIkNzdHJ1Y3Quc2hpZnQgJWEgJWRcIiBwcF90IHRcbmxldCBlcnJfc2hpZnR2IG4gPSBlcnIgXCJDc3RydWN0LnNoaWZ0diBzaG9ydCBieSAlZFwiIG5cbmxldCBlcnJfY29weV90b19zdHJpbmcgY2FsbGVyIHQgPSBlcnIgXCJDc3RydWN0LiVzICVhIG9mZj0lZCBsZW49JWRcIiBjYWxsZXIgcHBfdCB0XG5sZXQgZXJyX3RvX2hleF9zdHJpbmcgdCA9IGVyciBcIkNzdHJ1Y3QudG9faGV4X3N0cmluZyAlYSBvZmY9JWQgbGVuPSVkXCIgcHBfdCB0XG5sZXQgZXJyX2JsaXRfc3JjIHNyYyBkc3QgPVxuICBlcnIgXCJDc3RydWN0LmJsaXQgc3JjPSVhIGRzdD0lYSBzcmMtb2ZmPSVkIGxlbj0lZFwiIHBwX3Qgc3JjIHBwX3QgZHN0XG5sZXQgZXJyX2JsaXRfZHN0IHNyYyBkc3QgPVxuICBlcnIgXCJDc3RydWN0LmJsaXQgc3JjPSVhIGRzdD0lYSBkc3Qtb2ZmPSVkIGxlbj0lZFwiIHBwX3Qgc3JjIHBwX3QgZHN0XG5sZXQgZXJyX2JsaXRfZnJvbV9zdHJpbmdfc3JjIHNyYyBkc3QgPVxuICBlcnIgXCJDc3RydWN0LmJsaXRfZnJvbV9zdHJpbmcgc3JjPSVhIGRzdD0lYSBzcmMtb2ZmPSVkIGxlbj0lZFwiXG4gICAgc3RyaW5nX3Qgc3JjIHBwX3QgZHN0XG5sZXQgZXJyX2JsaXRfZnJvbV9zdHJpbmdfZHN0IHNyYyBkc3QgPVxuICBlcnIgXCJDc3RydWN0LmJsaXRfZnJvbV9zdHJpbmcgc3JjPSVhIGRzdD0lYSBkc3Qtb2ZmPSVkIGxlbj0lZFwiXG4gICAgc3RyaW5nX3Qgc3JjIHBwX3QgZHN0XG5sZXQgZXJyX2JsaXRfZnJvbV9ieXRlc19zcmMgc3JjIGRzdCA9XG4gIGVyciBcIkNzdHJ1Y3QuYmxpdF9mcm9tX2J5dGVzIHNyYz0lYSBkc3Q9JWEgc3JjLW9mZj0lZCBsZW49JWRcIlxuICAgIGJ5dGVzX3Qgc3JjIHBwX3QgZHN0XG5sZXQgZXJyX2JsaXRfZnJvbV9ieXRlc19kc3Qgc3JjIGRzdCA9XG4gIGVyciBcIkNzdHJ1Y3QuYmxpdF9mcm9tX2J5dGVzIHNyYz0lYSBkc3Q9JWEgZHN0LW9mZj0lZCBsZW49JWRcIlxuICAgIGJ5dGVzX3Qgc3JjIHBwX3QgZHN0XG5sZXQgZXJyX2JsaXRfdG9fYnl0ZXNfc3JjIHNyYyBkc3QgPVxuICBlcnIgXCJDc3RydWN0LmJsaXRfdG9fYnl0ZXMgc3JjPSVhIGRzdD0lYSBzcmMtb2ZmPSVkIGxlbj0lZFwiXG4gICAgcHBfdCBzcmMgYnl0ZXNfdCBkc3RcbmxldCBlcnJfYmxpdF90b19ieXRlc19kc3Qgc3JjIGRzdD1cbiAgZXJyIFwiQ3N0cnVjdC5ibGl0X3RvX2J5dGVzIHNyYz0lYSBkc3Q9JWEgZHN0LW9mZj0lZCBsZW49JWRcIlxuICAgIHBwX3Qgc3JjIGJ5dGVzX3QgZHN0XG5sZXQgZXJyX2ludmFsaWRfYm91bmRzIGYgPVxuICBlcnIgXCJpbnZhbGlkIGJvdW5kcyBpbiBDc3RydWN0LiVzICVhIG9mZj0lZCBsZW49JWRcIiBmIHBwX3QgW0BAaW5saW5lIG5ldmVyXVxubGV0IGVycl9zcGxpdCB0ID0gZXJyIFwiQ3N0cnVjdC5zcGxpdCAlYSBzdGFydD0lZCBvZmY9JWRcIiBwcF90IHRcbmxldCBlcnJfaXRlciB0ID0gZXJyIFwiQ3N0cnVjdC5pdGVyICVhIGk9JWQgbGVuPSVkXCIgcHBfdCB0XG5cbmxldCBvZl9iaWdhcnJheSA/KG9mZj0wKSA/bGVuIGJ1ZmZlciA9XG4gIGxldCBkaW0gPSBCaWdhcnJheS5BcnJheTEuZGltIGJ1ZmZlciBpblxuICBsZXQgbGVuID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgTm9uZSAgICAgLT4gZGltIC0gb2ZmXG4gICAgfCBTb21lIGxlbiAtPiBsZW4gaW5cbiAgaWYgb2ZmIDwgMCB8fCBsZW4gPCAwIHx8IG9mZiArIGxlbiA8IDAgfHwgb2ZmICsgbGVuID4gZGltIHRoZW4gZXJyX29mX2JpZ2FycmF5IG9mZiBsZW5cbiAgZWxzZSB7IGJ1ZmZlcjsgb2ZmOyBsZW4gfVxuXG5sZXQgdG9fYmlnYXJyYXkgYnVmZmVyID1cbiAgQmlnYXJyYXkuQXJyYXkxLnN1YiBidWZmZXIuYnVmZmVyIGJ1ZmZlci5vZmYgYnVmZmVyLmxlblxuXG5sZXQgY3JlYXRlX3Vuc2FmZSBsZW4gPVxuICBsZXQgYnVmZmVyID0gQmlnYXJyYXkuKEFycmF5MS5jcmVhdGUgY2hhciBjX2xheW91dCBsZW4pIGluXG4gIHsgYnVmZmVyIDsgbGVuIDsgb2ZmID0gMCB9XG5cbmxldCBjaGVja19ib3VuZHMgdCBsZW4gPVxuICBsZW4gPj0gMCAmJiBCaWdhcnJheS5BcnJheTEuZGltIHQuYnVmZmVyID49IGxlblxuXG5sZXQgZW1wdHkgPSBjcmVhdGVfdW5zYWZlIDBcblxuZXh0ZXJuYWwgY2hlY2tfYWxpZ25tZW50X2JpZ3N0cmluZyA6IGJ1ZmZlciAtPiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfY2hlY2tfYWxpZ25tZW50X2JpZ3N0cmluZ1wiXG5cbmxldCBjaGVja19hbGlnbm1lbnQgdCBhbGlnbm1lbnQgPVxuICBpZiBhbGlnbm1lbnQgPiAwIHRoZW5cbiAgICBjaGVja19hbGlnbm1lbnRfYmlnc3RyaW5nIHQuYnVmZmVyIHQub2ZmIGFsaWdubWVudFxuICBlbHNlIGludmFsaWRfYXJnIFwiY2hlY2tfYWxpZ25tZW50IG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlclwiXG5cbnR5cGUgYnl0ZSA9IGNoYXJcblxubGV0IGJ5dGUgKGk6aW50KSA6IGJ5dGUgPSBDaGFyLmNociBpXG5sZXQgYnl0ZV90b19pbnQgKGI6Ynl0ZSkgPSBpbnRfb2ZfY2hhciBiXG5cbnR5cGUgdWludDggPSBpbnRcbnR5cGUgdWludDE2ID0gaW50XG50eXBlIHVpbnQzMiA9IGludDMyXG50eXBlIHVpbnQ2NCA9IGludDY0XG5cbmxldCBkZWJ1ZyB0ID1cbiAgbGV0IG1heF9sZW4gPSBCaWdhcnJheS5BcnJheTEuZGltIHQuYnVmZmVyIGluXG4gIGlmIHQub2ZmK3QubGVuID4gbWF4X2xlbiB8fCB0LmxlbiA8IDAgfHwgdC5vZmYgPCAwIHRoZW4gKFxuICAgIEZvcm1hdC5wcmludGYgXCJFUlJPUjogdC5vZmYrdC5sZW49JWQgJWFcXG4lIVwiICh0Lm9mZit0LmxlbikgcHBfdCB0O1xuICAgIGFzc2VydCBmYWxzZTtcbiAgKSBlbHNlXG4gICAgRm9ybWF0LmFzcHJpbnRmIFwiJWFcIiBwcF90IHRcblxubGV0IHN1YiB0IG9mZiBsZW4gPVxuICAoKiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9taXJhZ2Uvb2NhbWwtY3N0cnVjdC9wdWxsLzI0NVxuXG4gICAgIENzdHJ1Y3Quc3ViIHNob3VsZCBzZWxlY3Qgd2hhdCBhIHByb2dyYW1tZXIgaW50dWl0aXZlbHkgZXhwZWN0cyBhXG4gICAgIHN1Yi1jc3RydWN0IHRvIGJlLiBJIGltYWdpbmUgaG9sZGluZyBvdXQgbXkgaGFuZHMsIHdpdGggdGhlIGxlZnRcbiAgICAgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBvZmZzZXQgYW5kIHRoZSByaWdodCB0aGUgZW5kLiBJIHRoaW5rIG9mIGFcbiAgICAgc3ViLWNzdHJ1Y3QgYXMgYW55IHNwYW4gd2l0aGluIHRoaXMgcmFuZ2UuIElmIEkgbW92ZSBteSBsZWZ0IGhhbmQgb25seSB0b1xuICAgICB0aGUgcmlnaHQgKG5ld19zdGFydCA+PSB0Lm9mZiksIGFuZCBteSByaWdodCBoYW5kIG9ubHkgdG8gdGhlIGxlZnRcbiAgICAgKG5ld19lbmQgPD0gb2xkX2VuZCksIGFuZCB0aGV5IGRvbid0IGNyb3NzIChuZXdfc3RhcnQgPD0gbmV3X2VuZCksIHRoZW4gSVxuICAgICBmZWVsIHN1cmUgdGhlIHJlc3VsdCB3aWxsIGJlIGEgdmFsaWQgc3ViLWNzdHJ1Y3QuIEFuZCBpZiBJIHZpb2xhdGUgYW55IG9uZVxuICAgICBvZiB0aGVzZSBjb25zdHJhaW50cyAoZS5nLiBtb3ZpbmcgbXkgbGVmdCBoYW5kIGZ1cnRoZXIgbGVmdCksIHRoZW4gSSBmZWVsXG4gICAgIHN1cmUgdGhhdCB0aGUgcmVzdWx0IHdvdWxkbid0IGJlIHNvbWV0aGluZyBJJ2QgY29uc2lkZXIgdG8gYmUgYSBzdWItY3N0cnVjdC5cblxuICAgICBXcmFwcGluZyBjb25zaWRlcmF0aW9ucyBpbiBtb2R1bGFyIGFyaXRobWV0aWM6XG5cbiAgICAgTm90ZSB0aGF0IGlmIHggaXMgbm9uLW5lZ2F0aXZlLCBhbmQgeCArIHkgd3JhcHMsIHRoZW4geCArIHkgbXVzdCBiZVxuICAgICBuZWdhdGl2ZS4gVGhpcyBpcyBlYXN5IHRvIHNlZSB3aXRoIG1vZHVsYXIgYXJpdGhtZXRpYyBiZWNhdXNlIGlmIHkgaXNcbiAgICAgbmVnYXRpdmUgdGhlbiB0aGUgdHdvIGFyZ3VtZW50cyB3aWxsIGNhbmNlbCB0byBzb21lIGRlZ3JlZSB0aGUgcmVzdWx0XG4gICAgIGNhbm5vdCBiZSBmdXJ0aGVyIGZyb20gemVybyB0aGFuIG9uZSBvZiB0aGUgYXJndW1lbnRzLiBJZiB5IGlzIHBvc2l0aXZlXG4gICAgIHRoZW4geCArIHkgY2FuIHdyYXAsIGJ1dCBldmVuIG1heF9pbnQgKyBtYXhfaW50IGRvZXNuJ3Qgd3JhcCBhbGwgdGhlIHdheSB0b1xuICAgICB6ZXJvLlxuXG4gICAgIFRoZSB0aHJlZSBwb3NzaWJseS13cmFwcGluZyBvcGVyYXRpb25zIGFyZTpcblxuICAgICBuZXdfc3RhcnQgPSB0Lm9mZiArIG9mZi4gdC5vZmYgaXMgbm9uLW5lZ2F0aXZlIHNvIGlmIHRoaXMgd3JhcHMgdGhlblxuICAgICBuZXdfc3RhcnQgd2lsbCBiZSBuZWdhdGl2ZSBhbmQgd2lsbCBmYWlsIHRoZSBuZXdfc3RhcnQgPj0gdC5vZmYgdGVzdC5cblxuICAgICBuZXdfZW5kID0gbmV3X3N0YXJ0ICsgbGVuLiBUaGUgYWJvdmUgdGVzdCBlbnN1cmVzIHRoYXQgbmV3X3N0YXJ0IGlzXG4gICAgIG5vbi1uZWdhdGl2ZSBpbiBhbnkgc3VjY2Vzc2Z1bCByZXR1cm4uIFNvIGlmIHRoaXMgd3JhcHMgdGhlbiBuZXdfZW5kIHdpbGxcbiAgICAgYmUgbmVnYXRpdmUgYW5kIHdpbGwgZmFpbCB0aGUgbmV3X3N0YXJ0IDw9IG5ld19lbmQgdGVzdC5cblxuICAgICBvbGRfZW5kID0gdC5vZmYgKyB0Lmxlbi4gVGhpcyB1c2VzIG9ubHkgdGhlIGV4aXN0aW5nIHRydXN0ZWQgdmFsdWVzLiBJdFxuICAgICBjb3VsZCBvbmx5IHdyYXAgaWYgdGhlIHVuZGVybHlpbmcgYmlnYXJyYXkgaGFkIGEgbmVnYXRpdmUgbGVuZ3RoISAgKilcbiAgbGV0IG5ld19zdGFydCA9IHQub2ZmICsgb2ZmIGluXG4gIGxldCBuZXdfZW5kID0gbmV3X3N0YXJ0ICsgbGVuIGluXG4gIGxldCBvbGRfZW5kID0gdC5vZmYgKyB0LmxlbiBpblxuICBpZiBuZXdfc3RhcnQgPj0gdC5vZmYgJiYgbmV3X2VuZCA8PSBvbGRfZW5kICYmIG5ld19zdGFydCA8PSBuZXdfZW5kIHRoZW5cbiAgICB7IHQgd2l0aCBvZmYgPSBuZXdfc3RhcnQgOyBsZW4gfVxuICBlbHNlXG4gICAgZXJyX3N1YiB0IG9mZiBsZW5cblxubGV0IHNoaWZ0IHQgYW1vdW50ID1cbiAgbGV0IG9mZiA9IHQub2ZmICsgYW1vdW50IGluXG4gIGxldCBsZW4gPSB0LmxlbiAtIGFtb3VudCBpblxuICBpZiBhbW91bnQgPCAwIHx8IGFtb3VudCA+IHQubGVuIHx8IG5vdCAoY2hlY2tfYm91bmRzIHQgKG9mZitsZW4pKSB0aGVuXG4gICAgZXJyX3NoaWZ0IHQgYW1vdW50XG4gIGVsc2UgeyB0IHdpdGggb2ZmOyBsZW4gfVxuXG5sZXQgcmVjIHNraXBfZW1wdHkgPSBmdW5jdGlvblxuICB8IHQgOjogdHMgd2hlbiB0LmxlbiA9IDAgLT4gc2tpcF9lbXB0eSB0c1xuICB8IHggLT4geFxuXG5sZXQgcmVjIHNoaWZ0diB0cyA9IGZ1bmN0aW9uXG4gIHwgMCAtPiBza2lwX2VtcHR5IHRzXG4gIHwgbiAtPlxuICAgIG1hdGNoIHRzIHdpdGhcbiAgICB8IFtdIC0+IGVycl9zaGlmdHYgblxuICAgIHwgdCA6OiB0cyB3aGVuIG4gPj0gdC5sZW4gLT4gc2hpZnR2IHRzIChuIC0gdC5sZW4pXG4gICAgfCB0IDo6IHRzIC0+IHNoaWZ0IHQgbiA6OiB0c1xuXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nIDogYnVmZmVyIC0+IGludCAtPiBidWZmZXIgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZ190b19iaWdzdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGJ1ZmZlciAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nXCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgdW5zYWZlX2JsaXRfYnl0ZXNfdG9fYmlnc3RyaW5nIDogQnl0ZXMudCAtPiBpbnQgLT4gYnVmZmVyIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9iaWdzdHJpbmdfdG9fYnl0ZXMgOiBidWZmZXIgLT4gaW50IC0+IEJ5dGVzLnQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIHVuc2FmZV9jb21wYXJlX2JpZ3N0cmluZyA6IGJ1ZmZlciAtPiBpbnQgLT4gYnVmZmVyIC0+IGludCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX2NvbXBhcmVfYmlnc3RyaW5nXCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGxfYmlnc3RyaW5nIDogYnVmZmVyIC0+IGludCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZmlsbF9iaWdzdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5sZXQgY29weV90b19zdHJpbmcgY2FsbGVyIHNyYyBzcmNvZmYgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBzcmNvZmYgPCAwIHx8IHNyYy5sZW4gLSBzcmNvZmYgPCBsZW4gdGhlblxuICAgIGVycl9jb3B5X3RvX3N0cmluZyBjYWxsZXIgc3JjIHNyY29mZiBsZW5cbiAgZWxzZVxuICAgIGxldCBiID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0X2JpZ3N0cmluZ190b19ieXRlcyBzcmMuYnVmZmVyIChzcmMub2ZmK3NyY29mZikgYiAwIGxlbjtcbiAgICAoKiBUaGUgZm9sbG93aW5nIGNhbGwgaXMgc2FmZSwgc2luY2UgYiBpcyBub3QgdmlzaWJsZSBlbHNld2hlcmUuICopXG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiXG5cbmxldCBjb3B5ID0gY29weV90b19zdHJpbmcgXCJjb3B5XCJcblxubGV0IGJsaXQgc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgc3Jjb2ZmIDwgMCB8fCBzcmMubGVuIC0gc3Jjb2ZmIDwgbGVuIHRoZW5cbiAgICBlcnJfYmxpdF9zcmMgc3JjIGRzdCBzcmNvZmYgbGVuXG4gIGVsc2UgaWYgZHN0b2ZmIDwgMCB8fCBkc3QubGVuIC0gZHN0b2ZmIDwgbGVuIHRoZW5cbiAgICBlcnJfYmxpdF9kc3Qgc3JjIGRzdCBkc3RvZmYgbGVuXG4gIGVsc2VcbiAgICB1bnNhZmVfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nIHNyYy5idWZmZXIgKHNyYy5vZmYrc3Jjb2ZmKSBkc3QuYnVmZmVyXG4gICAgICAoZHN0Lm9mZitkc3RvZmYpIGxlblxuXG5sZXQgc3ViX2NvcHkgY3N0ciBvZmYgbGVuIDogdCA9XG4gIGxldCBjc3RyMiA9IGNyZWF0ZV91bnNhZmUgbGVuIGluXG4gIGJsaXQgY3N0ciBvZmYgY3N0cjIgMCBsZW47XG4gIGNzdHIyXG5cbmxldCBibGl0X2Zyb21fc3RyaW5nIHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IHNyY29mZiA8IDAgfHwgZHN0b2ZmIDwgMCB8fCBTdHJpbmcubGVuZ3RoIHNyYyAtIHNyY29mZiA8IGxlbiB0aGVuXG4gICAgZXJyX2JsaXRfZnJvbV9zdHJpbmdfc3JjIHNyYyBkc3Qgc3Jjb2ZmIGxlblxuICBlbHNlIGlmIGRzdC5sZW4gLSBkc3RvZmYgPCBsZW4gdGhlblxuICAgIGVycl9ibGl0X2Zyb21fc3RyaW5nX2RzdCBzcmMgZHN0IGRzdG9mZiBsZW5cbiAgZWxzZVxuICAgIHVuc2FmZV9ibGl0X3N0cmluZ190b19iaWdzdHJpbmcgc3JjIHNyY29mZiBkc3QuYnVmZmVyIChkc3Qub2ZmK2RzdG9mZikgbGVuXG5cbmxldCBibGl0X2Zyb21fYnl0ZXMgc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgc3Jjb2ZmIDwgMCB8fCBkc3RvZmYgPCAwIHx8IEJ5dGVzLmxlbmd0aCBzcmMgLSBzcmNvZmYgPCBsZW4gdGhlblxuICAgIGVycl9ibGl0X2Zyb21fYnl0ZXNfc3JjIHNyYyBkc3Qgc3Jjb2ZmIGxlblxuICBlbHNlIGlmIGRzdC5sZW4gLSBkc3RvZmYgPCBsZW4gdGhlblxuICAgIGVycl9ibGl0X2Zyb21fYnl0ZXNfZHN0IHNyYyBkc3QgZHN0b2ZmIGxlblxuICBlbHNlXG4gICAgdW5zYWZlX2JsaXRfYnl0ZXNfdG9fYmlnc3RyaW5nIHNyYyBzcmNvZmYgZHN0LmJ1ZmZlciAoZHN0Lm9mZitkc3RvZmYpIGxlblxuXG5sZXQgYmxpdF90b19ieXRlcyBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBzcmNvZmYgPCAwIHx8IGRzdG9mZiA8IDAgfHwgc3JjLmxlbiAtIHNyY29mZiA8IGxlbiB0aGVuXG4gICAgZXJyX2JsaXRfdG9fYnl0ZXNfc3JjIHNyYyBkc3Qgc3Jjb2ZmIGxlblxuICBlbHNlIGlmIEJ5dGVzLmxlbmd0aCBkc3QgLSBkc3RvZmYgPCBsZW4gdGhlblxuICAgIGVycl9ibGl0X3RvX2J5dGVzX2RzdCBzcmMgZHN0IGRzdG9mZiBsZW5cbiAgZWxzZVxuICAgIHVuc2FmZV9ibGl0X2JpZ3N0cmluZ190b19ieXRlcyBzcmMuYnVmZmVyIChzcmMub2ZmK3NyY29mZikgZHN0IGRzdG9mZiBsZW5cblxubGV0IGNvbXBhcmUgdDEgdDIgPVxuICBsZXQgbDEgPSB0MS5sZW5cbiAgYW5kIGwyID0gdDIubGVuIGluXG4gIG1hdGNoIGNvbXBhcmUgbDEgbDIgd2l0aFxuICB8IDAgLT5cbiAgICAoIG1hdGNoIHVuc2FmZV9jb21wYXJlX2JpZ3N0cmluZyB0MS5idWZmZXIgdDEub2ZmIHQyLmJ1ZmZlciB0Mi5vZmYgbDEgd2l0aFxuICAgICAgfCAwIC0+IDBcbiAgICAgIHwgciAtPiBpZiByIDwgMCB0aGVuIC0xIGVsc2UgMSApXG4gIHwgciAtPiByXG5cbmxldCBlcXVhbCB0MSB0MiA9IGNvbXBhcmUgdDEgdDIgPSAwXG5cbigqIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgc2FmZSBhcyBsb25nIGFzIGFsbCBbdF1zIGFyZSBjb2hlcmVudC4gKilcbmxldCBtZW1zZXQgdCB4ID0gdW5zYWZlX2ZpbGxfYmlnc3RyaW5nIHQuYnVmZmVyIHQub2ZmIHQubGVuIHhcblxubGV0IGNyZWF0ZSBsZW4gPVxuICBsZXQgdCA9IGNyZWF0ZV91bnNhZmUgbGVuIGluXG4gIG1lbXNldCB0IDA7XG4gIHRcblxubGV0IHNldF91aW50OCB0IGkgYyA9XG4gIGlmIGkgPj0gdC5sZW4gfHwgaSA8IDAgdGhlbiBlcnJfaW52YWxpZF9ib3VuZHMgXCJzZXRfdWludDhcIiB0IGkgMVxuICBlbHNlIEJpZ2FycmF5LkFycmF5MS5zZXQgdC5idWZmZXIgKHQub2ZmK2kpIChDaGFyLnVuc2FmZV9jaHIgYylcblxubGV0IHNldF9jaGFyIHQgaSBjID1cbiAgaWYgaSA+PSB0LmxlbiB8fCBpIDwgMCB0aGVuIGVycl9pbnZhbGlkX2JvdW5kcyBcInNldF9jaGFyXCIgdCBpIDFcbiAgZWxzZSBCaWdhcnJheS5BcnJheTEuc2V0IHQuYnVmZmVyICh0Lm9mZitpKSBjXG5cbmxldCBnZXRfdWludDggdCBpID1cbiAgaWYgaSA+PSB0LmxlbiB8fCBpIDwgMCB0aGVuIGVycl9pbnZhbGlkX2JvdW5kcyBcImdldF91aW50OFwiIHQgaSAxXG4gIGVsc2UgQ2hhci5jb2RlIChCaWdhcnJheS5BcnJheTEuZ2V0IHQuYnVmZmVyICh0Lm9mZitpKSlcblxubGV0IGdldF9jaGFyIHQgaSA9XG4gIGlmIGkgPj0gdC5sZW4gfHwgaSA8IDAgdGhlbiBlcnJfaW52YWxpZF9ib3VuZHMgXCJnZXRfY2hhclwiIHQgaSAxXG4gIGVsc2UgQmlnYXJyYXkuQXJyYXkxLmdldCB0LmJ1ZmZlciAodC5vZmYraSlcblxuXG5leHRlcm5hbCBiYV9zZXRfaW50MTYgOiBidWZmZXIgLT4gaW50IC0+IHVpbnQxNiAtPiB1bml0ID0gXCIlY2FtbF9iaWdzdHJpbmdfc2V0MTZ1XCJcbmV4dGVybmFsIGJhX3NldF9pbnQzMiA6IGJ1ZmZlciAtPiBpbnQgLT4gdWludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2JpZ3N0cmluZ19zZXQzMnVcIlxuZXh0ZXJuYWwgYmFfc2V0X2ludDY0IDogYnVmZmVyIC0+IGludCAtPiB1aW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYmlnc3RyaW5nX3NldDY0dVwiXG5leHRlcm5hbCBiYV9nZXRfaW50MTYgOiBidWZmZXIgLT4gaW50IC0+IHVpbnQxNiA9IFwiJWNhbWxfYmlnc3RyaW5nX2dldDE2dVwiXG5leHRlcm5hbCBiYV9nZXRfaW50MzIgOiBidWZmZXIgLT4gaW50IC0+IHVpbnQzMiA9IFwiJWNhbWxfYmlnc3RyaW5nX2dldDMydVwiXG5leHRlcm5hbCBiYV9nZXRfaW50NjQgOiBidWZmZXIgLT4gaW50IC0+IHVpbnQ2NCA9IFwiJWNhbWxfYmlnc3RyaW5nX2dldDY0dVwiXG5cbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldCBzZXRfdWludDE2IHN3YXAgcCB0IGkgYyA9XG4gIGlmIGkgPiB0LmxlbiAtIDIgfHwgaSA8IDAgdGhlbiBlcnJfaW52YWxpZF9ib3VuZHMgKHAgXiBcIi5zZXRfdWludDE2XCIpIHQgaSAyXG4gIGVsc2UgYmFfc2V0X2ludDE2IHQuYnVmZmVyICh0Lm9mZitpKSAoaWYgc3dhcCB0aGVuIHN3YXAxNiBjIGVsc2UgYykgW0BAaW5saW5lXVxuXG5sZXQgc2V0X3VpbnQzMiBzd2FwIHAgdCBpIGMgPVxuICBpZiBpID4gdC5sZW4gLSA0IHx8IGkgPCAwIHRoZW4gZXJyX2ludmFsaWRfYm91bmRzIChwIF4gXCIuc2V0X3VpbnQzMlwiKSB0IGkgNFxuICBlbHNlIGJhX3NldF9pbnQzMiB0LmJ1ZmZlciAodC5vZmYraSkgKGlmIHN3YXAgdGhlbiBzd2FwMzIgYyBlbHNlIGMpIFtAQGlubGluZV1cblxubGV0IHNldF91aW50NjQgc3dhcCBwIHQgaSBjID1cbiAgaWYgaSA+IHQubGVuIC0gOCB8fCBpIDwgMCB0aGVuIGVycl9pbnZhbGlkX2JvdW5kcyAocCBeIFwiLnNldF91aW50NjRcIikgdCBpIDhcbiAgZWxzZSBiYV9zZXRfaW50NjQgdC5idWZmZXIgKHQub2ZmK2kpIChpZiBzd2FwIHRoZW4gc3dhcDY0IGMgZWxzZSBjKSBbQEBpbmxpbmVdXG5cbmxldCBnZXRfdWludDE2IHN3YXAgcCB0IGkgPVxuICBpZiBpID4gdC5sZW4gLSAyIHx8IGkgPCAwIHRoZW4gZXJyX2ludmFsaWRfYm91bmRzIChwIF4gXCIuZ2V0X3VpbnQxNlwiKSB0IGkgMlxuICBlbHNlXG4gICAgbGV0IHIgPSBiYV9nZXRfaW50MTYgdC5idWZmZXIgKHQub2ZmK2kpIGluXG4gICAgaWYgc3dhcCB0aGVuIHN3YXAxNiByIGVsc2UgciBbQEBpbmxpbmVdXG5cbmxldCBnZXRfdWludDMyIHN3YXAgcCB0IGkgPVxuICBpZiBpID4gdC5sZW4gLSA0IHx8IGkgPCAwIHRoZW4gZXJyX2ludmFsaWRfYm91bmRzIChwIF4gXCIuZ2V0X3VpbnQzMlwiKSB0IGkgNFxuICBlbHNlXG4gICAgbGV0IHIgPSBiYV9nZXRfaW50MzIgdC5idWZmZXIgKHQub2ZmK2kpIGluXG4gICAgaWYgc3dhcCB0aGVuIHN3YXAzMiByIGVsc2UgciBbQEBpbmxpbmVdXG5cbmxldCBnZXRfdWludDY0IHN3YXAgcCB0IGkgPVxuICBpZiBpID4gdC5sZW4gLSA4IHx8IGkgPCAwIHRoZW4gZXJyX2ludmFsaWRfYm91bmRzIChwIF4gXCIuZ2V0X3VpbnQ2NFwiKSB0IGkgOFxuICBlbHNlXG4gICAgbGV0IHIgPSBiYV9nZXRfaW50NjQgdC5idWZmZXIgKHQub2ZmK2kpIGluXG4gICAgaWYgc3dhcCB0aGVuIHN3YXA2NCByIGVsc2UgciBbQEBpbmxpbmVdXG5cbm1vZHVsZSBCRSA9IHN0cnVjdFxuICBsZXQgc2V0X3VpbnQxNiB0IGkgYyA9IHNldF91aW50MTYgKG5vdCBTeXMuYmlnX2VuZGlhbikgXCJCRVwiIHQgaSBjIFtAQGlubGluZV1cbiAgbGV0IHNldF91aW50MzIgdCBpIGMgPSBzZXRfdWludDMyIChub3QgU3lzLmJpZ19lbmRpYW4pIFwiQkVcIiB0IGkgYyBbQEBpbmxpbmVdXG4gIGxldCBzZXRfdWludDY0IHQgaSBjID0gc2V0X3VpbnQ2NCAobm90IFN5cy5iaWdfZW5kaWFuKSBcIkJFXCIgdCBpIGMgW0BAaW5saW5lXVxuICBsZXQgZ2V0X3VpbnQxNiB0IGkgPSBnZXRfdWludDE2IChub3QgU3lzLmJpZ19lbmRpYW4pIFwiQkVcIiB0IGkgW0BAaW5saW5lXVxuICBsZXQgZ2V0X3VpbnQzMiB0IGkgPSBnZXRfdWludDMyIChub3QgU3lzLmJpZ19lbmRpYW4pIFwiQkVcIiB0IGkgW0BAaW5saW5lXVxuICBsZXQgZ2V0X3VpbnQ2NCB0IGkgPSBnZXRfdWludDY0IChub3QgU3lzLmJpZ19lbmRpYW4pIFwiQkVcIiB0IGkgW0BAaW5saW5lXVxuZW5kXG5cbm1vZHVsZSBMRSA9IHN0cnVjdFxuICBsZXQgc2V0X3VpbnQxNiB0IGkgYyA9IHNldF91aW50MTYgU3lzLmJpZ19lbmRpYW4gXCJMRVwiIHQgaSBjIFtAQGlubGluZV1cbiAgbGV0IHNldF91aW50MzIgdCBpIGMgPSBzZXRfdWludDMyIFN5cy5iaWdfZW5kaWFuIFwiTEVcIiB0IGkgYyBbQEBpbmxpbmVdXG4gIGxldCBzZXRfdWludDY0IHQgaSBjID0gc2V0X3VpbnQ2NCBTeXMuYmlnX2VuZGlhbiBcIkxFXCIgdCBpIGMgW0BAaW5saW5lXVxuICBsZXQgZ2V0X3VpbnQxNiB0IGkgPSBnZXRfdWludDE2IFN5cy5iaWdfZW5kaWFuIFwiTEVcIiB0IGkgW0BAaW5saW5lXVxuICBsZXQgZ2V0X3VpbnQzMiB0IGkgPSBnZXRfdWludDMyIFN5cy5iaWdfZW5kaWFuIFwiTEVcIiB0IGkgW0BAaW5saW5lXVxuICBsZXQgZ2V0X3VpbnQ2NCB0IGkgPSBnZXRfdWludDY0IFN5cy5iaWdfZW5kaWFuIFwiTEVcIiB0IGkgW0BAaW5saW5lXVxuZW5kXG5cbm1vZHVsZSBIRSA9IHN0cnVjdFxuICBsZXQgc2V0X3VpbnQxNiB0IGkgYyA9IHNldF91aW50MTYgZmFsc2UgXCJIRVwiIHQgaSBjIFtAQGlubGluZV1cbiAgbGV0IHNldF91aW50MzIgdCBpIGMgPSBzZXRfdWludDMyIGZhbHNlIFwiSEVcIiB0IGkgYyBbQEBpbmxpbmVdXG4gIGxldCBzZXRfdWludDY0IHQgaSBjID0gc2V0X3VpbnQ2NCBmYWxzZSBcIkhFXCIgdCBpIGMgW0BAaW5saW5lXVxuICBsZXQgZ2V0X3VpbnQxNiB0IGkgPSBnZXRfdWludDE2IGZhbHNlIFwiSEVcIiB0IGkgW0BAaW5saW5lXVxuICBsZXQgZ2V0X3VpbnQzMiB0IGkgPSBnZXRfdWludDMyIGZhbHNlIFwiSEVcIiB0IGkgW0BAaW5saW5lXVxuICBsZXQgZ2V0X3VpbnQ2NCB0IGkgPSBnZXRfdWludDY0IGZhbHNlIFwiSEVcIiB0IGkgW0BAaW5saW5lXVxuZW5kXG5cbmxldCBsZW5ndGggeyBsZW4gOyBfIH0gPSBsZW5cblxuKCoqIFtzdW1fbGVuZ3RocyB+Y2FsbGVyIGFjYyBsXSBpcyBbYWNjXSBwbHVzIHRoZSBzdW0gb2YgdGhlIGxlbmd0aHNcbiAgICBvZiB0aGUgZWxlbWVudHMgb2YgW2xdLiAgUmFpc2VzIFtJbnZhbGlkX2FyZ3VtZW50IGNhbGxlcl0gaWZcbiAgICBhcml0aG1ldGljIG92ZXJmbG93cy4gKilcbmxldCByZWMgc3VtX2xlbmd0aHNfYXV4IH5jYWxsZXIgYWNjID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoIDo6IHQgLT5cbiAgICAgbGV0IHN1bSA9IGxlbmd0aCBoICsgYWNjIGluXG4gICAgIGlmIHN1bSA8IGFjYyB0aGVuIGludmFsaWRfYXJnIGNhbGxlclxuICAgICBlbHNlIHN1bV9sZW5ndGhzX2F1eCB+Y2FsbGVyIHN1bSB0XG5cbmxldCBzdW1fbGVuZ3RocyB+Y2FsbGVyIGwgPSBzdW1fbGVuZ3Roc19hdXggfmNhbGxlciAwIGxcblxubGV0IGxlbnYgbCA9IHN1bV9sZW5ndGhzIH5jYWxsZXI6XCJDc3RydWN0LmxlbnZcIiBsXG5cbmxldCBjb3B5diB0cyA9XG4gIGxldCBzeiA9IHN1bV9sZW5ndGhzIH5jYWxsZXI6XCJDc3RydWN0LmNvcHl2XCIgdHMgaW5cbiAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSBzeiBpblxuICBsZXQgXyA9IExpc3QuZm9sZF9sZWZ0XG4gICAgKGZ1biBvZmYgc3JjIC0+XG4gICAgICBsZXQgeCA9IGxlbmd0aCBzcmMgaW5cbiAgICAgIHVuc2FmZV9ibGl0X2JpZ3N0cmluZ190b19ieXRlcyBzcmMuYnVmZmVyIHNyYy5vZmYgZHN0IG9mZiB4O1xuICAgICAgb2ZmICsgeFxuICAgICkgMCB0cyBpblxuICAoKiBUaGUgZm9sbG93aW5nIGNhbGwgaXMgc2FmZSwgc2luY2UgZHN0IGlzIG5vdCB2aXNpYmxlIGVsc2V3aGVyZS4gKilcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkc3RcblxubGV0IGZpbGx2IH5zcmMgfmRzdCA9XG4gIGxldCByZWMgYXV4IGRzdCBuID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IG4sIFtdXG4gICAgfCBoZDo6dGwgLT5cbiAgICAgICAgbGV0IGF2YWlsID0gbGVuZ3RoIGRzdCBpblxuICAgICAgICBsZXQgZmlyc3QgPSBsZW5ndGggaGQgaW5cbiAgICAgICAgaWYgZmlyc3QgPD0gYXZhaWwgdGhlbiAoXG4gICAgICAgICAgYmxpdCBoZCAwIGRzdCAwIGZpcnN0O1xuICAgICAgICAgIGF1eCAoc2hpZnQgZHN0IGZpcnN0KSAobiArIGZpcnN0KSB0bFxuICAgICAgICApIGVsc2UgKFxuICAgICAgICAgIGJsaXQgaGQgMCBkc3QgMCBhdmFpbDtcbiAgICAgICAgICBsZXQgcmVzdF9oZCA9IHNoaWZ0IGhkIGF2YWlsIGluXG4gICAgICAgICAgKG4gKyBhdmFpbCwgcmVzdF9oZCA6OiB0bClcbiAgICAgICAgKSBpblxuICBhdXggZHN0IDAgc3JjXG5cbmxldCB0b19zdHJpbmcgPyhvZmY9MCkgP2xlbjpzeiB0ID1cbiAgbGV0IGxlbiA9IG1hdGNoIHN6IHdpdGggTm9uZSAtPiBsZW5ndGggdCAtIG9mZiB8IFNvbWUgbCAtPiBsIGluXG4gIGNvcHlfdG9fc3RyaW5nIFwidG9fc3RyaW5nXCIgdCBvZmYgbGVuXG5cbmxldCB0b19oZXhfc3RyaW5nID8ob2ZmPTApID9sZW46c3ogdCA6IHN0cmluZyA9XG4gIGxldFtAaW5saW5lXSBuaWJibGVfdG9fY2hhciAoaTppbnQpIDogY2hhciA9XG4gICAgaWYgaSA8IDEwIHRoZW5cbiAgICAgIENoYXIuY2hyIChpICsgQ2hhci5jb2RlICcwJylcbiAgICBlbHNlXG4gICAgICBDaGFyLmNociAoaSAtIDEwICsgQ2hhci5jb2RlICdhJylcbiAgaW5cblxuICBsZXQgbGVuID0gbWF0Y2ggc3ogd2l0aCBOb25lIC0+IGxlbmd0aCB0IC0gb2ZmIHwgU29tZSBsIC0+IGwgaW5cbiAgaWYgbGVuIDwgMCB8fCBvZmYgPCAwIHx8IHQubGVuIC0gb2ZmIDwgbGVuIHRoZW5cbiAgICBlcnJfdG9faGV4X3N0cmluZyB0IG9mZiBsZW5cbiAgZWxzZSAoXG4gICAgbGV0IG91dCA9IEJ5dGVzLmNyZWF0ZSAoMiAqIGxlbikgaW5cbiAgICBmb3IgaT0wIHRvIGxlbi0xIGRvXG4gICAgICBsZXQgYyA9IENoYXIuY29kZSBAQCBCaWdhcnJheS5BcnJheTEuZ2V0IHQuYnVmZmVyIChpK3Qub2ZmK29mZikgaW5cbiAgICAgIEJ5dGVzLnNldCBvdXQgKDIqaSkgKG5pYmJsZV90b19jaGFyIChjIGxzciA0KSk7XG4gICAgICBCeXRlcy5zZXQgb3V0ICgyKmkrMSkgKG5pYmJsZV90b19jaGFyIChjIGxhbmQgMHhmKSk7XG4gICAgZG9uZTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIG91dFxuICApXG5cblxubGV0IHRvX2J5dGVzID9vZmYgP2xlbiB0ID1cbiAgQnl0ZXMudW5zYWZlX29mX3N0cmluZyAodG9fc3RyaW5nID9vZmYgP2xlbiB0KVxuXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBvZl9kYXRhX2Fic3RyYWN0IGJsaXRmdW4gbGVuZnVuID9hbGxvY2F0b3IgPyhvZmY9MCkgP2xlbiBidWYgPVxuICBsZXQgYnVmbGVuID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgTm9uZSAtPiBsZW5mdW4gYnVmIC0gb2ZmXG4gICAgfCBTb21lIGxlbiAtPiBsZW4gaW5cbiAgbWF0Y2ggYWxsb2NhdG9yIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgbGV0IGMgPSBjcmVhdGVfdW5zYWZlIGJ1ZmxlbiBpblxuICAgIGJsaXRmdW4gYnVmIG9mZiBjIDAgYnVmbGVuO1xuICAgIGNcbiAgfCBTb21lIGZuIC0+XG4gICAgbGV0IGMgPSBmbiBidWZsZW4gaW5cbiAgICBibGl0ZnVuIGJ1ZiBvZmYgYyAwIGJ1ZmxlbjtcbiAgICB7IGMgd2l0aCBsZW4gPSBidWZsZW4gfVxuXG5sZXQgb2Zfc3RyaW5nID9hbGxvY2F0b3IgP29mZiA/bGVuIGJ1ZiA9XG4gIG9mX2RhdGFfYWJzdHJhY3QgYmxpdF9mcm9tX3N0cmluZyBTdHJpbmcubGVuZ3RoID9hbGxvY2F0b3IgP29mZiA/bGVuIGJ1ZlxuXG5sZXQgb2ZfYnl0ZXMgP2FsbG9jYXRvciA/b2ZmID9sZW4gYnVmID1cbiAgb2ZfZGF0YV9hYnN0cmFjdCBibGl0X2Zyb21fYnl0ZXMgQnl0ZXMubGVuZ3RoID9hbGxvY2F0b3IgP29mZiA/bGVuIGJ1ZlxuXG5sZXQgb2ZfaGV4ID8ob2ZmPTApID9sZW4gc3RyID1cbiAgbGV0IHN0ciA9XG4gICAgbGV0IGwgPSBtYXRjaCBsZW4gd2l0aCBOb25lIC0+IFN0cmluZy5sZW5ndGggc3RyIC0gb2ZmIHwgU29tZSBsIC0+IGwgaW5cbiAgICBTdHJpbmcuc3ViIHN0ciBvZmYgbFxuICBpblxuICBsZXQgc3RyaW5nX2ZvbGQgfmYgfnogc3RyID1cbiAgICBsZXQgc3QgPSByZWYgeiBpblxuICAgICggU3RyaW5nLml0ZXIgKGZ1biBjIC0+IHN0IDo9IGYgIXN0IGMpIHN0ciAgOyAhc3QgKVxuICBpblxuICBsZXQgaGV4ZGlnaXQgcCA9IGZ1bmN0aW9uXG4gICAgfCAnYScgLi4gJ2YnIGFzIHggLT4gaW50X29mX2NoYXIgeCAtIDg3XG4gICAgfCAnQScgLi4gJ0YnIGFzIHggLT4gaW50X29mX2NoYXIgeCAtIDU1XG4gICAgfCAnMCcgLi4gJzknIGFzIHggLT4gaW50X29mX2NoYXIgeCAtIDQ4XG4gICAgfCB4IC0+XG4gICAgICBGb3JtYXQua3NwcmludGYgaW52YWxpZF9hcmcgXCJvZl9oZXg6IGludmFsaWQgY2hhcmFjdGVyIGF0IHBvcyAlZDogJUNcIiBwIHhcbiAgaW5cbiAgbGV0IHdoaXRlc3BhY2UgPSBmdW5jdGlvblxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXG4nIC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcbiAgaW5cbiAgbWF0Y2hcbiAgICBzdHJpbmdfZm9sZFxuICAgICAgfmY6KGZ1biAoY3MsIGksIHAsIGFjYykgLT5cbiAgICAgICAgICBsZXQgcCcgPSBzdWNjIHAgaW5cbiAgICAgICAgICBmdW5jdGlvblxuICAgICAgICAgIHwgY2hhciB3aGVuIHdoaXRlc3BhY2UgY2hhciAtPiAoY3MsIGksIHAnLCBhY2MpXG4gICAgICAgICAgfCBjaGFyIC0+XG4gICAgICAgICAgICBtYXRjaCBhY2MsIGhleGRpZ2l0IHAgY2hhciB3aXRoXG4gICAgICAgICAgICB8IChOb25lICAsIHgpIC0+IChjcywgaSwgcCcsIFNvbWUgKHggbHNsIDQpKVxuICAgICAgICAgICAgfCAoU29tZSB5LCB4KSAtPiBzZXRfdWludDggY3MgaSAoeCBsb3IgeSkgOyAoY3MsIHN1Y2MgaSwgcCcsIE5vbmUpKVxuICAgICAgfno6KGNyZWF0ZV91bnNhZmUgKFN0cmluZy5sZW5ndGggc3RyIGxzciAxKSwgMCwgMCwgTm9uZSlcbiAgICAgIHN0clxuICB3aXRoXG4gIHwgXyAsIF8sIF8sIFNvbWUgXyAtPlxuICAgIEZvcm1hdC5rc3ByaW50ZiBpbnZhbGlkX2FyZyBcIm9mX2hleDogb2RkIG51bWJlcnMgb2YgY2hhcmFjdGVyc1wiXG4gIHwgY3MsIGksIF8sIF8gLT4gc3ViIGNzIDAgaVxuXG5sZXQgaGV4ZHVtcF9wcCBmbXQgdCA9XG4gIGxldCBiZWZvcmUgZm10ID1cbiAgICBmdW5jdGlvblxuICAgIHwgMCAtPiAoKVxuICAgIHwgOCAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCIgIFwiO1xuICAgIHwgXyAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCIgXCJcbiAgaW5cbiAgbGV0IGFmdGVyIGZtdCA9XG4gICAgZnVuY3Rpb25cbiAgICB8IDE1IC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIkA7XCJcbiAgICB8ICBfIC0+ICgpXG4gIGluXG4gIEZvcm1hdC5wcF9vcGVuX3Zib3ggZm10IDAgO1xuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgbGV0IGNvbHVtbiA9IGkgbW9kIDE2IGluXG4gICAgbGV0IGMgPSBDaGFyLmNvZGUgKEJpZ2FycmF5LkFycmF5MS5nZXQgdC5idWZmZXIgKHQub2ZmK2kpKSBpblxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVhJS4yeCVhXCIgYmVmb3JlIGNvbHVtbiBjIGFmdGVyIGNvbHVtblxuICBkb25lIDtcbiAgRm9ybWF0LnBwX2Nsb3NlX2JveCBmbXQgKClcblxubGV0IGhleGR1bXAgPSBGb3JtYXQucHJpbnRmIFwiQFxcbiVhQC5cIiBoZXhkdW1wX3BwXG5cbmxldCBoZXhkdW1wX3RvX2J1ZmZlciBidWYgdCA9XG4gIGxldCBmID0gRm9ybWF0LmZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIEZvcm1hdC5mcHJpbnRmIGYgXCJAXFxuJWFALlwiIGhleGR1bXBfcHAgdFxuXG5sZXQgc3BsaXQgPyhzdGFydD0wKSB0IG9mZiA9XG4gIHRyeVxuICAgIGxldCBoZWFkZXIgPXN1YiB0IHN0YXJ0IG9mZiBpblxuICAgIGxldCBib2R5ID0gc3ViIHQgKHN0YXJ0K29mZikgKGxlbmd0aCB0IC0gb2ZmIC0gc3RhcnQpIGluXG4gICAgaGVhZGVyLCBib2R5XG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IGVycl9zcGxpdCB0IHN0YXJ0IG9mZlxuXG50eXBlICdhIGl0ZXIgPSB1bml0IC0+ICdhIG9wdGlvblxubGV0IGl0ZXIgbGVuZm4gcGZuIHQgPVxuICBsZXQgYm9keSA9IHJlZiAoU29tZSB0KSBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGZ1biAoKSAtPlxuICAgIG1hdGNoICFib2R5IHdpdGhcbiAgICAgIHxTb21lIGJ1ZiB3aGVuIGxlbmd0aCBidWYgPSAwIC0+XG4gICAgICAgIGJvZHkgOj0gTm9uZTtcbiAgICAgICAgTm9uZVxuICAgICAgfFNvbWUgYnVmIC0+IGJlZ2luXG4gICAgICAgIG1hdGNoIGxlbmZuIGJ1ZiB3aXRoXG4gICAgICAgIHxOb25lIC0+XG4gICAgICAgICAgYm9keSA6PSBOb25lO1xuICAgICAgICAgIE5vbmVcbiAgICAgICAgfFNvbWUgcGxlbiAtPlxuICAgICAgICAgIGluY3IgaTtcbiAgICAgICAgICBsZXQgcCxyZXN0ID1cbiAgICAgICAgICAgIHRyeSBzcGxpdCBidWYgcGxlbiB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiBlcnJfaXRlciBidWYgIWkgcGxlblxuICAgICAgICAgIGluXG4gICAgICAgICAgYm9keSA6PSBTb21lIHJlc3Q7XG4gICAgICAgICAgU29tZSAocGZuIHApXG4gICAgICBlbmRcbiAgICAgIHxOb25lIC0+IE5vbmVcblxubGV0IHJlYyBmb2xkIGYgbmV4dCBhY2MgPSBtYXRjaCBuZXh0ICgpIHdpdGhcbiAgfCBOb25lIC0+IGFjY1xuICB8IFNvbWUgdiAtPiBmb2xkIGYgbmV4dCAoZiBhY2MgdilcblxubGV0IGFwcGVuZCBjczEgY3MyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGNzMSBhbmQgbDIgPSBsZW5ndGggY3MyIGluXG4gIGxldCBjcyA9IGNyZWF0ZV91bnNhZmUgKGwxICsgbDIpIGluXG4gIGJsaXQgY3MxIDAgY3MgMCAgbDEgO1xuICBibGl0IGNzMiAwIGNzIGwxIGwyIDtcbiAgY3NcblxubGV0IGNvbmNhdCA9IGZ1bmN0aW9uXG4gIHwgW10gICAtPiBjcmVhdGVfdW5zYWZlIDBcbiAgfCBbY3NdIC0+IGNzXG4gIHwgY3NzICAtPlxuICAgICAgbGV0IHJlc3VsdCA9IGNyZWF0ZV91bnNhZmUgKHN1bV9sZW5ndGhzIH5jYWxsZXI6XCJDc3RydWN0LmNvbmNhdFwiIGNzcykgaW5cbiAgICAgIGxldCBhdXggb2ZmIGNzID1cbiAgICAgICAgbGV0IG4gPSBsZW5ndGggY3MgaW5cbiAgICAgICAgYmxpdCBjcyAwIHJlc3VsdCBvZmYgbiA7XG4gICAgICAgIG9mZiArIG4gaW5cbiAgICAgIGlnbm9yZSBAQCBMaXN0LmZvbGRfbGVmdCBhdXggMCBjc3MgO1xuICAgICAgcmVzdWx0XG5cbmxldCByZXYgdCA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IG91dCA9IGNyZWF0ZV91bnNhZmUgbiBpblxuICBmb3IgaV9zcmMgPSAwIHRvIG4gLSAxIGRvXG4gICAgbGV0IGJ5dGUgPSBnZXRfdWludDggdCBpX3NyYyBpblxuICAgIGxldCBpX2RzdCA9IG4gLSAxIC0gaV9zcmMgaW5cbiAgICBzZXRfdWludDggb3V0IGlfZHN0IGJ5dGVcbiAgZG9uZTtcbiAgb3V0XG5cbigqIENvbnZlbmllbmNlIGZ1bmN0aW9uLiAqKVxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nXG4gIDogc3RyaW5nIC0+IGludCAtPiBidWZmZXIgLT4gaW50IC0+IGludCAtPiB1bml0XG4gID0gXCJjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZ1wiXG5bQEBub2FsbG9jXVxuXG5sZXQgZ2V0IHsgYnVmZmVyOyBvZmY7IGxlbjsgfSB6aWR4ID1cbiAgaWYgemlkeCA8IDAgfHwgemlkeCA+PSBsZW4gdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiA7XG4gIEJpZ2FycmF5LkFycmF5MS5nZXQgYnVmZmVyIChvZmYgKyB6aWR4KVxuXG5sZXQgZ2V0X2J5dGUgeyBidWZmZXI7IG9mZjsgbGVuOyB9IHppZHggPVxuICBpZiB6aWR4IDwgMCB8fCB6aWR4ID49IGxlbiB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIDtcbiAgQ2hhci5jb2RlIChCaWdhcnJheS5BcnJheTEuZ2V0IGJ1ZmZlciAob2ZmICsgemlkeCkpXG5cbmxldCBzdHJpbmcgPyhvZmY9IDApID9sZW4gc3RyID1cbiAgbGV0IHN0cl9sZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgbGVuID0gbWF0Y2ggbGVuIHdpdGggTm9uZSAtPiBzdHJfbGVuIHwgU29tZSBsZW4gLT4gbGVuIGluXG4gIGlmIG9mZiA8IDAgfHwgbGVuIDwgMCB8fCBvZmYgKyBsZW4gPiBzdHJfbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgO1xuICBsZXQgYnVmZmVyID0gQmlnYXJyYXkuKEFycmF5MS5jcmVhdGUgY2hhciBjX2xheW91dCBzdHJfbGVuKSBpblxuICB1bnNhZmVfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nIHN0ciAwIGJ1ZmZlciAwIHN0cl9sZW4gO1xuICBvZl9iaWdhcnJheSB+b2ZmIH5sZW4gYnVmZmVyXG5cbmxldCBidWZmZXIgPyhvZmY9IDApID9sZW4gYnVmZmVyID1cbiAgbGV0IGJ1ZmZlcl9sZW4gPSBCaWdhcnJheS5BcnJheTEuZGltIGJ1ZmZlciBpblxuICBsZXQgbGVuID0gbWF0Y2ggbGVuIHdpdGggTm9uZSAtPiBidWZmZXJfbGVuIC0gb2ZmIHwgU29tZSBsZW4gLT4gbGVuIGluXG4gIGlmIG9mZiA8IDAgfHwgbGVuIDwgMCB8fCBvZmYgKyBsZW4gPiBidWZmZXJfbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgO1xuICBvZl9iaWdhcnJheSB+b2ZmIH5sZW4gYnVmZmVyXG5cbmxldCBzdGFydF9wb3MgeyBvZmY7IF8gfSA9IG9mZlxubGV0IHN0b3BfcG9zIHsgb2ZmOyBsZW47IF8gfSA9IG9mZiArIGxlblxuXG5sZXQgaGVhZCA/KHJldj0gZmFsc2UpICh7IGxlbjsgXyB9IGFzIGNzKSA9XG4gIGlmIGxlbiA9IDAgdGhlbiBOb25lXG4gIGVsc2UgU29tZSAoZ2V0X2NoYXIgY3MgKGlmIHJldiB0aGVuIGxlbiAtIDEgZWxzZSAwKSlcblxubGV0IHRhaWwgPyhyZXY9IGZhbHNlKSAoeyBidWZmZXI7IG9mZjsgbGVuOyB9IGFzIGNzKSA9XG4gIGlmIGxlbiA9IDAgdGhlbiBjc1xuICBlbHNlIGlmIHJldiB0aGVuIG9mX2JpZ2FycmF5IH5vZmYgfmxlbjoobGVuIC0gMikgYnVmZmVyXG4gIGVsc2Ugb2ZfYmlnYXJyYXkgfm9mZjoob2ZmICsgMSkgfmxlbjoobGVuIC0gMSkgYnVmZmVyXG5cbmxldCBpc19lbXB0eSB7IGxlbjsgXyB9ID0gbGVuID0gMFxuXG5sZXQgaXNfcHJlZml4IH5hZmZpeDooeyBsZW49IGFsZW47IF8gfSBhcyBhZmZpeClcbiAgICAoeyBsZW47IF8gfSBhcyBjcykgPVxuICBpZiBhbGVuID4gbGVuIHRoZW4gZmFsc2VcbiAgZWxzZVxuICAgIGxldCBtYXhfemlkeCA9IGFsZW4gLSAxIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+IG1heF96aWR4IHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBnZXRfY2hhciBhZmZpeCBpIDw+IGdldF9jaGFyIGNzIGlcbiAgICAgIHRoZW4gZmFsc2UgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gICAgbG9vcCAwXG5cbmxldCBpc19pbmZpeCB+YWZmaXg6KHsgbGVuPSBhbGVuOyBfIH0gYXMgYWZmaXgpXG4gICAgKHsgbGVuOyBfIH0gYXMgY3MpID1cbiAgaWYgYWxlbiA+IGxlbiB0aGVuIGZhbHNlXG4gIGVsc2VcbiAgICBsZXQgbWF4X3ppZHhfYSA9IGFsZW4gLSAxIGluXG4gICAgbGV0IG1heF96aWR4X3MgPSBsZW4gLSBhbGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGkgayA9XG4gICAgICBpZiBpID4gbWF4X3ppZHhfcyB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIGsgPiBtYXhfemlkeF9hIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBrID4gMCB0aGVuXG4gICAgICAgIGlmIGdldF9jaGFyIGFmZml4IGsgPSBnZXRfY2hhciBjcyAoaSArIGspXG4gICAgICAgIHRoZW4gbG9vcCBpIChzdWNjIGspXG4gICAgICAgIGVsc2UgbG9vcCAoc3VjYyBpKSAwXG4gICAgICBlbHNlIGlmIGdldF9jaGFyIGFmZml4IDAgPSBnZXRfY2hhciBjcyBpXG4gICAgICB0aGVuIGxvb3AgaSAxXG4gICAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgMCBpblxuICAgIGxvb3AgMCAwXG5cbmxldCBpc19zdWZmaXggfmFmZml4Oih7IGxlbj0gYWxlbjsgXyB9IGFzIGFmZml4KVxuICAgICh7IGxlbjsgXyB9IGFzIGNzKSA9XG4gIGlmIGFsZW4gPiBsZW4gdGhlbiBmYWxzZVxuICBlbHNlXG4gICAgbGV0IG1heF96aWR4ID0gYWxlbiAtIDEgaW5cbiAgICBsZXQgbWF4X3ppZHhfYSA9IGFsZW4gLSAxIGluXG4gICAgbGV0IG1heF96aWR4X3MgPSBsZW4gLSAxIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+IG1heF96aWR4IHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBnZXRfY2hhciBhZmZpeCAobWF4X3ppZHhfYSAtIGkpIDw+IGdldF9jaGFyIGNzIChtYXhfemlkeF9zIC0gaSlcbiAgICAgIHRoZW4gZmFsc2UgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gICAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHNhdCBjcyA9XG4gIGxldCByZWMgZ28gYWNjIGkgPVxuICAgIGlmIGkgPCBsZW5ndGggY3NcbiAgICB0aGVuIGdvIChzYXQgKGdldF9jaGFyIGNzIGkpICYmIGFjYykgKHN1Y2MgaSlcbiAgICBlbHNlIGFjYyBpblxuICBnbyB0cnVlIDBcblxubGV0IGV4aXN0cyBzYXQgY3MgPVxuICBsZXQgcmVjIGdvIGFjYyBpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGNzXG4gICAgdGhlbiBnbyAoc2F0IChnZXRfY2hhciBjcyBpKSB8fCBhY2MpIChzdWNjIGkpXG4gICAgZWxzZSBhY2MgaW5cbiAgZ28gZmFsc2UgMFxuXG5sZXQgc3RhcnQgeyBidWZmZXI7IG9mZjsgXyB9ID1cbiAgb2ZfYmlnYXJyYXkgYnVmZmVyIH5vZmYgfmxlbjowXG5cbmxldCBzdG9wIHsgYnVmZmVyOyBvZmY7IGxlbjsgfSA9XG4gIG9mX2JpZ2FycmF5IGJ1ZmZlciB+b2ZmOihvZmYgKyBsZW4pIH5sZW46MFxuXG5sZXQgaXNfd2hpdGUgPSBmdW5jdGlvbiAnICcgfCAnXFx0JyAuLiAnXFxyJyAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSA/KGRyb3AgPSBpc193aGl0ZSkgKHsgYnVmZmVyOyBvZmY7IGxlbjsgfSBhcyBjcykgPVxuICBpZiBsZW4gPSAwIHRoZW4gY3NcbiAgZWxzZVxuICAgIGxldCBtYXhfenBvcyA9IGxlbiBpblxuICAgIGxldCBtYXhfemlkeCA9IGxlbiAtIDEgaW5cbiAgICBsZXQgcmVjIGxlZnRfcG9zIGkgPVxuICAgICAgaWYgaSA+IG1heF96aWR4IHRoZW4gbWF4X3pwb3NcbiAgICAgIGVsc2UgaWYgZHJvcCAoZ2V0X2NoYXIgY3MgaSkgdGhlbiBsZWZ0X3BvcyAoc3VjYyBpKSBlbHNlIGkgaW5cbiAgICBsZXQgcmVjIHJpZ2h0X3BvcyBpID1cbiAgICAgIGlmIGkgPCAwIHRoZW4gMFxuICAgICAgZWxzZSBpZiBkcm9wIChnZXRfY2hhciBjcyBpKSB0aGVuIHJpZ2h0X3BvcyAocHJlZCBpKSBlbHNlIHN1Y2MgaSBpblxuICAgIGxldCBsZWZ0ID0gbGVmdF9wb3MgMCBpblxuICAgIGlmIGxlZnQgPSBtYXhfenBvc1xuICAgIHRoZW4gb2ZfYmlnYXJyYXkgYnVmZmVyIH5vZmY6KChvZmYgKiAyICsgbGVuKSAvIDIpIH5sZW46MFxuICAgIGVsc2VcbiAgICAgIGxldCByaWdodCA9IHJpZ2h0X3BvcyBtYXhfemlkeCBpblxuICAgICAgaWYgbGVmdCA9IDAgJiYgcmlnaHQgPSBtYXhfenBvcyB0aGVuIGNzXG4gICAgICBlbHNlIG9mX2JpZ2FycmF5IGJ1ZmZlciB+b2ZmOihvZmYgKyBsZWZ0KSB+bGVuOihyaWdodCAtIGxlZnQpXG5cbmxldCBmc3BhbiB+bWluIH5tYXggfnNhdCAoeyBidWZmZXI9IHY7IG9mZjsgbGVuOyB9IGFzIGNzKSA9XG4gIGlmIG1pbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcInNwYW46IG5lZ2F0aXZlIG1pblwiIDtcbiAgaWYgbWF4IDwgMCB0aGVuIGludmFsaWRfYXJnIFwic3BhbjogbmVnYXRpdmUgbWF4XCIgO1xuICBpZiBtaW4gPiBtYXggfHwgbWF4ID0gMCB0aGVuIChidWZmZXIgfm9mZjpvZmYgfmxlbjowIHYsIGNzKVxuICBlbHNlXG4gICAgbGV0IG1heF96aWR4ID0gbGVuIC0gMSBpblxuICAgIGxldCBtYXhfemlkeCA9XG4gICAgICBsZXQgayA9IG1heCAtIDEgaW5cbiAgICAgIGlmIGsgPiBtYXhfemlkeCB8fCBrIDwgMCB0aGVuIG1heF96aWR4IGVsc2UgayBpblxuICAgIGxldCBuZWVkX3ppZHggPSBtaW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpIDw9IG1heF96aWR4ICYmIHNhdCAoZ2V0X2NoYXIgY3MgaSkgdGhlbiBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgaWYgaSA8IG5lZWRfemlkeCB8fCBpID0gMCB0aGVuIGJ1ZmZlciB+b2ZmOm9mZiB+bGVuOjAgdiwgY3NcbiAgICAgIGVsc2UgaWYgaSA9IGxlbiB0aGVuIChjcywgYnVmZmVyIH5vZmY6KG9mZiArIGxlbikgfmxlbjowIHYpXG4gICAgICBlbHNlIGJ1ZmZlciB+b2ZmOm9mZiB+bGVuOmkgdiwgYnVmZmVyIH5vZmY6KG9mZiArIGkpIH5sZW46KGxlbiAtIGkpIHYgaW5cbiAgICBsb29wIDBcblxubGV0IHJzcGFuIH5taW4gfm1heCB+c2F0ICh7IGJ1ZmZlcj0gdjsgb2ZmOyBsZW47IH0gYXMgY3MpID1cbiAgaWYgbWluIDwgMCB0aGVuIGludmFsaWRfYXJnIFwic3BhbjogbmVnYXRpdmUgbWluXCIgO1xuICBpZiBtYXggPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJzcGFuOiBuZWdhdGl2ZSBtYXhcIiA7XG4gIGlmIG1pbiA+IG1heCB8fCBtYXggPSAwIHRoZW4gKGNzLCBidWZmZXIgfm9mZjoob2ZmICsgbGVuKSB+bGVuOjAgdilcbiAgZWxzZVxuICAgIGxldCBtYXhfemlkeCA9IGxlbiAtIDEgaW5cbiAgICBsZXQgbWluX3ppZHggPVxuICAgICAgbGV0IGsgPSBsZW4gLSBtYXggaW4gaWYgayA8IDAgdGhlbiAwIGVsc2UgayBpblxuICAgIGxldCBuZWVkX3ppZHggPSBsZW4gLSBtaW4gLSAxIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBtaW5femlkeCAmJiBzYXQgKGdldF9jaGFyIGNzIGkpIHRoZW4gbG9vcCAoaSAtIDEpXG4gICAgICBlbHNlIGlmIGkgPiBuZWVkX3ppZHggfHwgaSA9IG1heF96aWR4IHRoZW4gKGNzLCBidWZmZXIgfm9mZjoob2ZmICsgbGVuKSB+bGVuOjAgdilcbiAgICAgIGVsc2UgaWYgaSA8IDAgdGhlbiAoYnVmZmVyIH5vZmY6b2ZmIH5sZW46MCB2LCBjcylcbiAgICAgIGVsc2UgKGJ1ZmZlciB+b2ZmOm9mZiB+bGVuOihpICsgMSkgdiwgYnVmZmVyIH5vZmY6KG9mZiArIGkgKyAxKSB+bGVuOihsZW4gLSAoaSArIDEpKSB2KSBpblxuICAgIGxvb3AgbWF4X3ppZHhcblxubGV0IHNwYW4gPyhyZXY9IGZhbHNlKSA/KG1pbj0gMCkgPyhtYXg9IG1heF9pbnQpID8oc2F0PSBmdW4gXyAtPiB0cnVlKSBjcyA9XG4gIG1hdGNoIHJldiB3aXRoXG4gIHwgdHJ1ZSAgLT4gcnNwYW4gfm1pbiB+bWF4IH5zYXQgY3NcbiAgfCBmYWxzZSAtPiBmc3BhbiB+bWluIH5tYXggfnNhdCBjc1xuXG5sZXQgdGFrZSA/KHJldj0gZmFsc2UpID9taW4gP21heCA/c2F0IGNzID1cbiAgKGlmIHJldiB0aGVuIHNuZCBlbHNlIGZzdCkgQEAgc3BhbiB+cmV2ID9taW4gP21heCA/c2F0IGNzXG5cbmxldCBkcm9wID8ocmV2PSBmYWxzZSkgP21pbiA/bWF4ID9zYXQgY3MgPVxuICAoaWYgcmV2IHRoZW4gZnN0IGVsc2Ugc25kKSBAQCBzcGFuIH5yZXYgP21pbiA/bWF4ID9zYXQgY3NcblxubGV0IGZjdXQgfnNlcDooeyBsZW49IHNlcF9sZW47IF8gfSBhcyBzZXApXG4gICAgKHsgYnVmZmVyPSB2OyBvZmY7IGxlbjsgfSBhcyBjcykgPVxuICBpZiBzZXBfbGVuID0gMCB0aGVuIGludmFsaWRfYXJnIFwiY3V0OiBlbXB0eSBzZXBhcmF0b3JcIiA7XG4gIGxldCBtYXhfc2VwX3ppZHggPSBzZXBfbGVuIC0gMSBpblxuICBsZXQgbWF4X3NfemlkeCA9IGxlbiAtIHNlcF9sZW4gaW5cbiAgbGV0IHJlYyBjaGVja19zZXAgaSBrID1cbiAgICBpZiBrID4gbWF4X3NlcF96aWR4XG4gICAgdGhlbiBTb21lIChidWZmZXIgfm9mZjpvZmYgfmxlbjppIHYsXG4gICAgICAgICAgICAgICBidWZmZXIgfm9mZjoob2ZmICsgaSArIHNlcF9sZW4pIH5sZW46KGxlbiAtIGkgLSBzZXBfbGVuKSB2KVxuICAgIGVsc2UgaWYgZ2V0X2NoYXIgY3MgKGkgKyBrKSA9IGdldF9jaGFyIHNlcCBrXG4gICAgdGhlbiBjaGVja19zZXAgaSAoayArIDEpXG4gICAgZWxzZSBzY2FuIChpICsgMSlcbiAgYW5kIHNjYW4gaSA9XG4gICAgaWYgaSA+IG1heF9zX3ppZHggdGhlbiBOb25lXG4gICAgZWxzZSBpZiBnZXRfY2hhciBjcyBpID0gZ2V0X2NoYXIgc2VwIDBcbiAgICB0aGVuIGNoZWNrX3NlcCBpIDFcbiAgICBlbHNlIHNjYW4gKGkgKyAxKSBpblxuICBzY2FuIDBcblxubGV0IHJjdXQgfnNlcDooeyBsZW49IHNlcF9sZW47IF8gfSBhcyBzZXApICh7IGJ1ZmZlcj0gdjsgb2ZmOyBsZW47IH0gYXMgY3MpID1cbiAgaWYgc2VwX2xlbiA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcImN1dDogZW1wdHkgc2VwYXJhdG9yXCIgO1xuICBsZXQgbWF4X3NlcF96aWR4ID0gc2VwX2xlbiAtIDEgaW5cbiAgbGV0IG1heF9zX3ppZHggPSBsZW4gLSAxIGluXG4gIGxldCByZWMgY2hlY2tfc2VwIGkgayA9XG4gICAgaWYgayA+IG1heF9zZXBfemlkeCB0aGVuIFNvbWUgKGJ1ZmZlciB+b2ZmOm9mZiB+bGVuOmkgdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyIH5vZmY6KG9mZiArIGkgKyBzZXBfbGVuKSB+bGVuOihsZW4gLSBpIC0gc2VwX2xlbikgdilcbiAgICBlbHNlIGlmIGdldF9jaGFyIGNzIChpICsgaykgPSBnZXRfY2hhciBzZXAga1xuICAgIHRoZW4gY2hlY2tfc2VwIGkgKGsgKyAxKVxuICAgIGVsc2UgcnNjYW4gKGkgLSAxKVxuICBhbmQgcnNjYW4gaSA9XG4gICAgaWYgaSA8IDAgdGhlbiBOb25lXG4gICAgZWxzZSBpZiBnZXRfY2hhciBjcyBpID0gZ2V0X2NoYXIgc2VwIDBcbiAgICB0aGVuIGNoZWNrX3NlcCBpIDFcbiAgICBlbHNlIHJzY2FuIChpIC0gMSkgaW5cbiAgcnNjYW4gKG1heF9zX3ppZHggLSBtYXhfc2VwX3ppZHgpXG5cbmxldCBjdXQgPyhyZXY9IGZhbHNlKSB+c2VwIGNzID0gbWF0Y2ggcmV2IHdpdGhcbiAgfCB0cnVlICAtPiByY3V0IH5zZXAgY3NcbiAgfCBmYWxzZSAtPiBmY3V0IH5zZXAgY3NcblxubGV0IGFkZF9zdWIgfm5vX2VtcHR5IGJ1ZiB+b2ZmIH5sZW4gYWNjID1cbiAgaWYgbGVuID0gMFxuICB0aGVuICggaWYgbm9fZW1wdHkgdGhlbiBhY2MgZWxzZSBidWZmZXIgfm9mZiB+bGVuIGJ1ZiA6OiBhY2MgKVxuICBlbHNlIGJ1ZmZlciB+b2ZmIH5sZW4gYnVmIDo6IGFjY1xuXG5sZXQgZmN1dHMgfm5vX2VtcHR5IH5zZXA6KHsgbGVuPSBzZXBfbGVuOyBfIH0gYXMgc2VwKVxuICAgICAgKHsgYnVmZmVyOyBvZmY7IGxlbjsgfSBhcyBjcykgPVxuICBpZiBzZXBfbGVuID0gMCB0aGVuIGludmFsaWRfYXJnIFwiY3V0czogZW1wdHkgc2VwYXJhdG9yXCIgO1xuICBsZXQgbWF4X3NlcF96aWR4ID0gc2VwX2xlbiAtIDEgaW5cbiAgbGV0IG1heF9zX3ppZHggPSBsZW4gLSBzZXBfbGVuIGluXG4gIGxldCByZWMgY2hlY2tfc2VwIHphbmNob3IgaSBrIGFjYyA9XG4gICAgaWYgayA+IG1heF9zZXBfemlkeFxuICAgIHRoZW5cbiAgICAgIGxldCBuZXdfc3RhcnQgPSBpICsgc2VwX2xlbiBpblxuICAgICAgc2NhbiBuZXdfc3RhcnQgbmV3X3N0YXJ0IChhZGRfc3ViIH5ub19lbXB0eSBidWZmZXIgfm9mZjoob2ZmICsgemFuY2hvcikgfmxlbjooaSAtIHphbmNob3IpIGFjYylcbiAgICBlbHNlXG4gICAgICBpZiBnZXRfY2hhciBjcyAoaSArIGspID0gZ2V0X2NoYXIgc2VwIGtcbiAgICAgIHRoZW4gY2hlY2tfc2VwIHphbmNob3IgaSAoayArIDEpIGFjY1xuICAgICAgZWxzZSBzY2FuIHphbmNob3IgKGkgKyAxKSBhY2NcbiAgYW5kIHNjYW4gemFuY2hvciBpIGFjYyA9XG4gICAgaWYgaSA+IG1heF9zX3ppZHhcbiAgICB0aGVuXG4gICAgICBpZiB6YW5jaG9yID0gMCB0aGVuIChpZiBub19lbXB0eSAmJiBsZW4gPSAwIHRoZW4gW10gZWxzZSBbIGNzIF0pXG4gICAgICBlbHNlIExpc3QucmV2IChhZGRfc3ViIH5ub19lbXB0eSBidWZmZXIgfm9mZjoob2ZmICsgemFuY2hvcikgfmxlbjoobGVuIC0gemFuY2hvcikgYWNjKVxuICAgIGVsc2VcbiAgICAgIGlmIGdldF9jaGFyIGNzIGkgPSBnZXRfY2hhciBzZXAgMFxuICAgICAgdGhlbiBjaGVja19zZXAgemFuY2hvciBpIDEgYWNjXG4gICAgICBlbHNlIHNjYW4gemFuY2hvciAoaSArIDEpIGFjYyBpblxuICBzY2FuIDAgMCBbXVxuXG5sZXQgcmN1dHMgfm5vX2VtcHR5IH5zZXA6KHsgbGVuPSBzZXBfbGVuOyBfIH0gYXMgc2VwKVxuICAgICAgKHsgYnVmZmVyOyBsZW47IF8gfSBhcyBjcykgPVxuICBpZiBzZXBfbGVuID0gMCB0aGVuIGludmFsaWRfYXJnIFwiY3V0czogZW1wdHkgc2VwYXJhdG9yXCIgO1xuICBsZXQgc19sZW4gPSBsZW4gaW5cbiAgbGV0IG1heF9zZXBfemlkeCA9IHNlcF9sZW4gLSAxIGluXG4gIGxldCBtYXhfc196aWR4ID0gbGVuIC0gMSBpblxuICBsZXQgcmVjIGNoZWNrX3NlcCB6YW5jaG9yIGkgayBhY2MgPVxuICAgIGlmIGsgPiBtYXhfc2VwX3ppZHhcbiAgICB0aGVuIGxldCBvZmYgPSBpICsgc2VwX2xlbiBpblxuICAgICAgICAgcnNjYW4gaSAoaSAtIHNlcF9sZW4pIChhZGRfc3ViIH5ub19lbXB0eSBidWZmZXIgfm9mZiB+bGVuOih6YW5jaG9yIC0gb2ZmKSBhY2MpXG4gICAgZWxzZVxuICAgICAgaWYgZ2V0X2NoYXIgY3MgKGkgKyBrKSA9IGdldF9jaGFyIGNzIGtcbiAgICAgIHRoZW4gY2hlY2tfc2VwIHphbmNob3IgaSAoayArIDEpIGFjY1xuICAgICAgZWxzZSByc2NhbiB6YW5jaG9yIChpIC0gMSkgYWNjXG4gIGFuZCByc2NhbiB6YW5jaG9yIGkgYWNjID1cbiAgICBpZiBpIDwgMCB0aGVuXG4gICAgICBpZiB6YW5jaG9yID0gc19sZW4gdGhlbiAoIGlmIG5vX2VtcHR5ICYmIHNfbGVuID0gMCB0aGVuIFtdIGVsc2UgWyBjcyBdKVxuICAgICAgZWxzZSBhZGRfc3ViIH5ub19lbXB0eSBidWZmZXIgfm9mZjowIH5sZW46emFuY2hvciBhY2NcbiAgICBlbHNlXG4gICAgICBpZiBnZXRfY2hhciBjcyBpID0gZ2V0X2NoYXIgc2VwIDBcbiAgICAgIHRoZW4gY2hlY2tfc2VwIHphbmNob3IgaSAxIGFjY1xuICAgICAgZWxzZSByc2NhbiB6YW5jaG9yIChpIC0gMSkgYWNjIGluXG4gIHJzY2FuIHNfbGVuIChtYXhfc196aWR4IC0gbWF4X3NlcF96aWR4KSBbXVxuXG5sZXQgY3V0cyA/KHJldj0gZmFsc2UpID8oZW1wdHk9IHRydWUpIH5zZXAgY3MgPSBtYXRjaCByZXYgd2l0aFxuICB8IHRydWUgIC0+IHJjdXRzIH5ub19lbXB0eToobm90IGVtcHR5KSB+c2VwIGNzXG4gIHwgZmFsc2UgLT4gZmN1dHMgfm5vX2VtcHR5Oihub3QgZW1wdHkpIH5zZXAgY3NcblxubGV0IGZpZWxkcyA/KGVtcHR5PSBmYWxzZSkgPyhpc19zZXA9IGlzX3doaXRlKSAoeyBidWZmZXI7IG9mZjsgbGVuOyB9IGFzIGNzKSA9XG4gIGxldCBub19lbXB0eSA9IG5vdCBlbXB0eSBpblxuICBsZXQgbWF4X3BvcyA9IGxlbiBpblxuICBsZXQgcmVjIGxvb3AgaSBlbmRfcG9zIGFjYyA9XG4gICAgaWYgaSA8IDAgdGhlbiBiZWdpblxuICAgICAgICBpZiBlbmRfcG9zID0gbGVuXG4gICAgICAgIHRoZW4gKCBpZiBub19lbXB0eSAmJiBsZW4gPSAwIHRoZW4gW10gZWxzZSBbIGNzIF0pXG4gICAgICAgIGVsc2UgYWRkX3N1YiB+bm9fZW1wdHkgYnVmZmVyIH5vZmY6b2ZmIH5sZW46KGVuZF9wb3MgLSAoaSArIDEpKSBhY2NcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGlmIG5vdCAoaXNfc2VwIChnZXRfY2hhciBjcyBpKSlcbiAgICAgICAgdGhlbiBsb29wIChpIC0gMSkgZW5kX3BvcyBhY2NcbiAgICAgICAgZWxzZSBsb29wIChpIC0gMSkgaSAoYWRkX3N1YiB+bm9fZW1wdHkgYnVmZmVyIH5vZmY6KG9mZiArIGkgKyAxKSB+bGVuOihlbmRfcG9zIC0gKGkgKyAxKSkgYWNjKVxuICAgICAgZW5kIGluXG4gIGxvb3AgKG1heF9wb3MgLSAxKSBtYXhfcG9zIFtdXG5cbmxldCBmZmluZCBzYXQgKHsgYnVmZmVyPSB2OyBsZW47IF8gfSBhcyBjcykgPVxuICBsZXQgbWF4X2lkeCA9IGxlbiAtIDEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPiBtYXhfaWR4IHRoZW4gTm9uZVxuICAgIGVsc2UgaWYgc2F0IChnZXRfY2hhciBjcyBpKVxuICAgIHRoZW4gU29tZSAoYnVmZmVyIH5vZmY6aSB+bGVuOjEgdilcbiAgICBlbHNlIGxvb3AgKGkgKyAxKSBpblxuICBsb29wIDBcblxubGV0IHJmaW5kIHNhdCAoeyBidWZmZXI9IHY7IGxlbjsgXyB9IGFzIGNzKSA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDwgMCB0aGVuIE5vbmVcbiAgICBlbHNlIGlmIHNhdCAoZ2V0X2NoYXIgY3MgaSlcbiAgICB0aGVuIFNvbWUgKGJ1ZmZlciB+b2ZmOmkgfmxlbjoxIHYpXG4gICAgZWxzZSBsb29wIChpIC0gMSkgaW5cbiAgbG9vcCAobGVuIC0gMSlcblxubGV0IGZpbmQgPyhyZXY9IGZhbHNlKSBzYXQgY3MgPSBtYXRjaCByZXYgd2l0aFxuICB8IHRydWUgIC0+IHJmaW5kIHNhdCBjc1xuICB8IGZhbHNlIC0+IGZmaW5kIHNhdCBjc1xuXG5sZXQgZmZpbmRfc3ViIH5zdWI6KHsgbGVuPSBzdWJfbGVuOyBfIH0gYXMgc3ViKSAoeyBidWZmZXI9IHY7IG9mZjsgbGVuOyB9IGFzIGNzKSA9XG4gIGlmIHN1Yl9sZW4gPiBsZW4gdGhlbiBOb25lXG4gIGVsc2VcbiAgICBsZXQgbWF4X3ppZHhfc3ViID0gc3ViX2xlbiAtIDEgaW5cbiAgICBsZXQgbWF4X3ppZHhfcyA9IGxlbiAtIHN1Yl9sZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgaSBrID1cbiAgICAgIGlmIGkgPiBtYXhfemlkeF9zIHRoZW4gTm9uZVxuICAgICAgZWxzZSBpZiBrID4gbWF4X3ppZHhfc3ViIHRoZW4gU29tZSAoYnVmZmVyIHYgfm9mZjoob2ZmICsgaSkgfmxlbjpzdWJfbGVuKVxuICAgICAgZWxzZSBpZiBrID4gMFxuICAgICAgdGhlbiAoIGlmIGdldF9jaGFyIHN1YiBrID0gZ2V0X2NoYXIgY3MgKGkgKyBrKVxuICAgICAgICAgICAgIHRoZW4gbG9vcCBpIChrICsgMSlcbiAgICAgICAgICAgICBlbHNlIGxvb3AgKGkgKyAxKSAwIClcbiAgICAgIGVsc2UgaWYgZ2V0X2NoYXIgc3ViIDAgPSBnZXRfY2hhciBjcyBpXG4gICAgICB0aGVuIGxvb3AgaSAxXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKSAwIGluXG4gICAgbG9vcCAwIDBcblxubGV0IHJmaW5kX3N1YiB+c3ViOih7IGxlbj0gc3ViX2xlbjsgXyB9IGFzIHN1YikgKHsgYnVmZmVyPSB2OyBsZW47IF8gfSBhcyBjcykgPVxuICBpZiBzdWJfbGVuID4gbGVuIHRoZW4gTm9uZVxuICBlbHNlXG4gICAgbGV0IG1heF96aWR4X3N1YiA9IHN1Yl9sZW4gLSAxIGluXG4gICAgbGV0IHJlYyBsb29wIGkgayA9XG4gICAgICBpZiBpIDwgMCB0aGVuIE5vbmVcbiAgICAgIGVsc2UgaWYgayA+IG1heF96aWR4X3N1YiB0aGVuIFNvbWUgKGJ1ZmZlciB2IH5vZmY6aSB+bGVuOnN1Yl9sZW4pXG4gICAgICBlbHNlIGlmIGsgPiAwXG4gICAgICB0aGVuICggaWYgZ2V0X2NoYXIgc3ViIGsgPSBnZXRfY2hhciBjcyAoaSArIGspXG4gICAgICAgICAgICAgdGhlbiBsb29wIGkgKGsgKyAxKVxuICAgICAgICAgICAgIGVsc2UgbG9vcCAoaSAtIDEpIDAgKVxuICAgICAgZWxzZSBpZiBnZXRfY2hhciBzdWIgMCA9IGdldF9jaGFyIGNzIGlcbiAgICAgIHRoZW4gbG9vcCBpIDFcbiAgICAgIGVsc2UgbG9vcCAoaSAtIDEpIDAgaW5cbiAgICBsb29wIChsZW4gLSBzdWJfbGVuKSAwXG5cbmxldCBmaW5kX3N1YiA/KHJldj0gZmFsc2UpIH5zdWIgY3MgPSBtYXRjaCByZXYgd2l0aFxuICB8IHRydWUgIC0+IHJmaW5kX3N1YiB+c3ViIGNzXG4gIHwgZmFsc2UgLT4gZmZpbmRfc3ViIH5zdWIgY3NcblxubGV0IGZpbHRlciBzYXQgKHsgbGVuOyBfIH0gYXMgY3MpID1cbiAgaWYgbGVuID0gMCB0aGVuIGVtcHR5XG4gIGVsc2VcbiAgICBsZXQgYiA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgbWF4X3ppZHggPSBsZW4gLSAxIGluXG4gICAgbGV0IHJlYyBsb29wIGIgayBpID1cbiAgICAgIGlmIGkgPiBtYXhfemlkeFxuICAgICAgdGhlbiAoaWYgayA9IGxlbiB0aGVuIGIgZWxzZSBzdWIgYiAwIGspXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBjaHIgPSBnZXRfY2hhciBjcyBpIGluXG4gICAgICAgIGlmIHNhdCBjaHIgdGhlbiAoIHNldF9jaGFyIGIgayBjaHIgOyBsb29wIGIgKGsgKyAxKSAoaSArIDEpKVxuICAgICAgICBlbHNlIGxvb3AgYiBrIChpICsgMSkgaW5cbiAgICBsb29wIGIgMCAwXG5cbmxldCBmaWx0ZXJfbWFwIGYgKHsgbGVuOyBfIH0gYXMgY3MpID1cbiAgaWYgbGVuID0gMCB0aGVuIGVtcHR5XG4gIGVsc2VcbiAgICBsZXQgYiA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgbWF4X3ppZHggPSBsZW4gLSAxIGluXG4gICAgbGV0IHJlYyBsb29wIGIgayBpID1cbiAgICAgIGlmIGkgPiBtYXhfemlkeFxuICAgICAgdGhlbiAoaWYgayA9IGxlbiB0aGVuIGIgZWxzZSBzdWIgYiAwIGspXG4gICAgICBlbHNlIG1hdGNoIGYgKGdldF9jaGFyIGNzIGkpIHdpdGhcbiAgICAgICAgICAgfCBTb21lIGNociAtPlxuICAgICAgICAgICAgICBzZXRfY2hhciBiIGkgY2hyIDtcbiAgICAgICAgICAgICAgbG9vcCBiIChrICsgMSkgKGkgKyAxKVxuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgbG9vcCBiIGsgKGkgKyAxKSBpblxuICAgIGxvb3AgYiAwIDBcblxubGV0IG1hcCBmICh7IGxlbjsgXyB9IGFzIGNzKSA9XG4gIGlmIGxlbiA9IDAgdGhlbiBlbXB0eVxuICBlbHNlXG4gICAgbGV0IGIgPSBjcmVhdGUgbGVuIGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIHNldF9jaGFyIGIgaSAoZiAoZ2V0X2NoYXIgY3MgaSkpXG4gICAgZG9uZSA7IGJcblxubGV0IG1hcGkgZiAoeyBsZW47IF8gfSBhcyBjcykgPVxuICBpZiBsZW4gPSAwIHRoZW4gZW1wdHlcbiAgZWxzZVxuICAgIGxldCBiID0gY3JlYXRlIGxlbiBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBzZXRfY2hhciBiIGkgKGYgaSAoZ2V0X2NoYXIgY3MgaSkpXG4gICAgZG9uZSA7IGJcbiIsIigqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxOSBBbmlsIE1hZGhhdmFwZWRkeSA8YW5pbEByZWNvaWwub3JnPlxuICogQ29weXJpZ2h0IChjKSAyMDE5IFJvbWFpbiBDYWxhc2NpYmV0dGEgPHJvbWFpbi5jYWxhc2NpYmV0dGFAZ21haWwuY29tPlxuICpcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZCBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuICogV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1JcbiAqIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbiAqIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuICogQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0ZcbiAqIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gKilcblxuaW5jbHVkZSAoQ3N0cnVjdCA6IG1vZHVsZSB0eXBlIG9mIENzdHJ1Y3Qgd2l0aCB0eXBlIHQgOj0gQ3N0cnVjdC50KVxuXG50eXBlICdhIHJkID0gPCByZDogdW5pdDsgLi4gPiBhcyAnYVxudHlwZSAnYSB3ciA9IDwgd3I6IHVuaXQ7IC4uID4gYXMgJ2FcblxudHlwZSAnYSB0ID0gQ3N0cnVjdC50XG5cbnR5cGUgcmR3ciA9ICA8IHJkOiB1bml0OyB3cjogdW5pdDsgPlxudHlwZSBybyA9IDwgcmQ6IHVuaXQ7ID5cbnR5cGUgd28gPSA8IHdyOiB1bml0OyA+XG5cbmV4dGVybmFsIHJvIDogJ2EgcmQgdCAtPiBybyB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgd28gOiAnYSB3ciB0IC0+IHdvIHQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBvZl9zdHJpbmcgPSBDc3RydWN0Lm9mX3N0cmluZyA/YWxsb2NhdG9yOk5vbmVcbmxldCBvZl9ieXRlcyA9IENzdHJ1Y3Qub2ZfYnl0ZXMgP2FsbG9jYXRvcjpOb25lXG5cbmxldCBwcCBwcGYgdCA9IENzdHJ1Y3QuaGV4ZHVtcF9wcCBwcGYgdFxuXG5sZXQgbGVuZ3RoID0gQ3N0cnVjdC5sZW5ndGhcblxubGV0IGJsaXQgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiB+bGVuID1cbiAgQ3N0cnVjdC5ibGl0IHNyYyBzcmNfb2ZmIGRzdCBkc3Rfb2ZmIGxlblxuW0BAaW5saW5lXVxuXG5sZXQgYmxpdF9mcm9tX3N0cmluZyBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIH5sZW4gPVxuICBDc3RydWN0LmJsaXRfZnJvbV9zdHJpbmcgc3JjIHNyY19vZmYgZHN0IGRzdF9vZmYgbGVuXG5bQEBpbmxpbmVdXG5cbmxldCBibGl0X2Zyb21fYnl0ZXMgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiB+bGVuID1cbiAgQ3N0cnVjdC5ibGl0X2Zyb21fYnl0ZXMgc3JjIHNyY19vZmYgZHN0IGRzdF9vZmYgbGVuXG5bQEBpbmxpbmVdXG5cbmxldCBibGl0X3RvX2J5dGVzIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgfmxlbiA9XG4gIENzdHJ1Y3QuYmxpdF90b19ieXRlcyBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiBsZW5cbltAQGlubGluZV1cblxubGV0IHN1YiB0IH5vZmYgfmxlbiA9XG4gIENzdHJ1Y3Quc3ViIHQgb2ZmIGxlblxuW0BAaW5saW5lXVxuXG5sZXQgc3ViX2NvcHkgdCB+b2ZmIH5sZW4gPVxuICBDc3RydWN0LnN1Yl9jb3B5IHQgb2ZmIGxlblxuW0BAaW5saW5lXVxuXG5sZXQgdW5zYWZlX3RvX2JpZ2FycmF5ID0gQ3N0cnVjdC50b19iaWdhcnJheVxuXG5sZXQgY29uY2F0IHZzcyA9XG4gIGxldCByZXMgPSBjcmVhdGVfdW5zYWZlIChDc3RydWN0LnN1bV9sZW5ndGhzIH5jYWxsZXI6XCJDc3RydWN0LkNhcC5jb25jYXRcIiB2c3MpIGluXG4gIGxldCBnbyBvZmYgdiA9XG4gICAgbGV0IGxlbiA9IENzdHJ1Y3QubGVuZ3RoIHYgaW5cbiAgICBDc3RydWN0LmJsaXQgdiAwIHJlcyBvZmYgbGVuIDtcbiAgICBvZmYgKyBsZW4gaW5cbiAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IGdvIDAgdnNzIGluXG4gIGFzc2VydCAobGVuID0gQ3N0cnVjdC5sZW5ndGggcmVzKSA7XG4gIHJlc1xuIl19
