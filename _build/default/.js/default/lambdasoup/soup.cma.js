// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Soup
//# unitInfo: Requires: Markup, Stdlib, Stdlib__Buffer, Stdlib__Char, Stdlib__Int64, Stdlib__List, Stdlib__Printf, Stdlib__String, Stream
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$8 = "",
    cst$9 = " ",
    cst$10 = "=",
    cst_Soup$1 = "Soup.",
    cst_body = "body",
    cst_class$5 = "class",
    cst_id$2 = "id",
    cst_unterminated_attribute_sel$2 = "unterminated attribute selector",
    caml_equal = runtime.caml_equal,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_mod = runtime.caml_mod,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$8,
    cst$7 = cst$9,
    cst$6 = cst$9,
    internal = "Soup.swap: internal error: non-element node given",
    cst$5 = cst$8,
    cst$3 = cst$8,
    cst$4 = cst$10,
    cst$2 = "-",
    cst$0 = cst$8,
    cst = ":",
    whitespace = " \t\n\r",
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Markup = global_data.Markup,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stream = global_data.Stream,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_String = global_data.Stdlib__String,
    concat = Stdlib_String[7],
    sub = Stdlib_String[16],
    lowercase_ascii = Stdlib_String[27],
    index_from = Stdlib_String[32],
    cst_but_has_no_child_list = "but has no child list",
    cst_Soup_leaf_text_internal_er =
      "Soup.leaf_text: internal error: node is not a text node, ",
    _c_ = [0, cst$8],
    cst_not_equal = "not equal",
    cst_Soup_R_previous_element_No = "Soup.R.previous_element: None",
    cst_Soup_R_next_element_None = "Soup.R.next_element: None",
    cst_Soup_R_previous_sibling_No = "Soup.R.previous_sibling: None",
    cst_Soup_R_next_sibling_None = "Soup.R.next_sibling: None",
    cst_Soup_R_child_element_None = "Soup.R.child_element: None",
    cst_Soup_R_child_None = "Soup.R.child: None",
    cst_Soup_R_parent_None = "Soup.R.parent: None",
    cst_Soup_R_tag_None = "Soup.R.tag: None",
    cst_Soup_R_last_None = "Soup.R.last: None",
    cst_Soup_R_first_None = "Soup.R.first: None",
    cst_Soup_R_nth_None = "Soup.R.nth: None",
    cst_Soup_R_leaf_text_None = "Soup.R.leaf_text: None",
    cst_Soup_R_element_None = "Soup.R.element: None",
    cst_Soup_R_id_None = "Soup.R.id: None",
    cst_Soup_R_attribute_None = "Soup.R.attribute: None",
    cst_Soup_R_select_one_None = "Soup.R.select_one: None",
    cst_class$3 = cst_class$5,
    cst_class$4 = cst_class$5,
    cst_id$1 = cst_id$2,
    cst_class$2 = cst_class$5,
    cst_class$1 = cst_class$5,
    cst_Soup_set_attribute_interna =
      "Soup.set_attribute: internal error: not an element",
    cst_Soup_delete_attribute_inte =
      "Soup.delete_attribute: internal error: not an element",
    cst_Soup_set_name_internal_err =
      "Soup.set_name: internal error: not an element",
    cst_Soup_unwrap_node_has_no_pa = "Soup.unwrap: node has no parent",
    cst_Soup_replace_target_node_h = "Soup.replace: target node has no parent",
    cst_Soup_insert_after_target_n =
      "Soup.insert_after: target node has no parent",
    cst_Soup_insert_before_target_ =
      "Soup.insert_before: target node has no parent",
    cst_Soup_mutate_child_list_nod =
      "Soup.mutate_child_list: node has no children",
    cst_http_www_w3_org_1999_xhtml = "http://www.w3.org/1999/xhtml",
    cst_Try_Soup_if_you_d_prefer_r =
      "Try Soup.($?) if you'd prefer returning None instead of an exception.",
    _m_ =
      [0,
       [11, "Soup.($): '", [2, 0, [11, "' not found.\n", [2, 0, 0]]]],
       "Soup.($): '%s' not found.\n%s"],
    _i_ = [3, 0, 1],
    _j_ = [1, 0, 1],
    _k_ = [2, 0, 1],
    _l_ = [0, 0, 1],
    _h_ =
      [0,
       [11, "unknown pseudo-class or pseudo-element ':", [2, 0, [12, 39, 0]]],
       "unknown pseudo-class or pseudo-element ':%s'"],
    cst_expected_simple_selector = "expected simple selector",
    cst_unterminated = "unterminated '('",
    cst_expected_parenthesized_exp = "expected parenthesized expression",
    cst_expected_expression = "expected expression",
    _f_ = [0, 2, 1],
    _g_ = [0, 2, 0],
    cst_expected_n_even_or_odd = "expected 'n', 'even', or 'odd'",
    cst_expected_number_after_or = "expected number after '+' or '-'",
    cst_id$0 = cst_id$2,
    cst_class$0 = cst_class$5,
    cst_expected_end_of_attribute_ =
      "expected end of attribute selector (']')",
    _e_ =
      [0,
       [11, "invalid attribute operator '", [2, 0, [12, 39, 0]]],
       "invalid attribute operator '%s'"],
    cst_unterminated_attribute_sel = cst_unterminated_attribute_sel$2,
    cst_expected_value_in_attribut = "expected value in attribute selector",
    cst_unterminated_attribute_sel$0 = cst_unterminated_attribute_sel$2,
    cst_unterminated_attribute_sel$1 = cst_unterminated_attribute_sel$2,
    cst_unterminated_string = "unterminated string",
    cst_expected_quoted_string = "expected quoted string",
    _d_ = [0, [0, [12, 61, 0]], "%c="],
    cst_expected_attribute_operato = "expected attribute operator",
    cst_expected_tag_name_or = "expected tag name or '*'",
    cst_expected_an_identifier = "expected an identifier",
    cst_parent_does_not_have_given = "parent does not have given child",
    cst_Soup_Selector_element_inde =
      "Soup.Selector.element_index_with_name: internal error: ",
    cst_this_exception_should_have = "this exception should have been caught",
    cst_Soup_matches_attribute_sel =
      "Soup.matches_attribute_selector: internal error: ",
    cst_element_is_not_a_child_of_ =
      "element is not a child of its own parent",
    cst_Soup_index_of_element_inte = "Soup.index_of_element: internal error: ",
    cst_Soup_index_of_internal_err =
      "Soup.index_of: internal error: child not in parent's child list",
    cst_Soup_index_of_internal_err$0 =
      "Soup.index_of: internal error: parent has no children",
    cst_previous_siblings = "previous_siblings",
    cst_next_siblings = "next_siblings",
    cst_internal_error_parent_has_ =
      ": internal error: parent has no children",
    cst_Soup$0 = cst_Soup$1,
    cst_internal_error_child_not_i =
      ": internal error: child not in parent's child list",
    cst_Soup = cst_Soup$1,
    cst_class = cst_class$5,
    cst_Soup_fold_attributes_inter =
      "Soup.fold_attributes: internal error: not an element",
    cst_Soup_name_internal_error_n =
      "Soup.name: internal error: not an element",
    cst_Soup_with_stop_internal_er =
      "Soup.with_stop: internal error: !result = None",
    cst_Soup_forget_type_internal_ =
      "Soup._forget_type: internal error: node's self reference not set",
    cst_require_argument_is_None = "require: argument is None",
    cst_Soup_Stop = "Soup.Stop",
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_id = cst_id$2,
    cst_Soup_Parse_error = "Soup.Parse_error";
   function trim(s){
    a:
    b:
    {
     var prefix_length = 0;
     for(;;){
      if(prefix_length === caml_ml_string_length(s)) break b;
      var _cu_ = caml_string_get(s, prefix_length);
      if(! caml_call2(Stdlib_String[15], whitespace, _cu_)) break;
      var index = prefix_length + 1 | 0, prefix_length = index;
     }
     break a;
    }
    var
     s$0 =
       caml_call3
        (Stdlib_String[16],
         s,
         prefix_length,
         caml_ml_string_length(s) - prefix_length | 0),
     suffix_length = 0;
    for(;;){
     if(suffix_length !== caml_ml_string_length(s$0)){
      var
       _cv_ =
         caml_string_get
          (s$0, (caml_ml_string_length(s$0) - suffix_length | 0) - 1 | 0);
      if(caml_call2(Stdlib_String[15], whitespace, _cv_)){
       var rindex = suffix_length + 1 | 0, suffix_length = rindex;
       continue;
      }
     }
     return caml_call3
             (Stdlib_String[16],
              s$0,
              0,
              caml_ml_string_length(s$0) - suffix_length | 0);
    }
   }
   function require_internal(message, param){
    if(! param) return caml_call1(Stdlib[2], message);
    var v = param[1];
    return v;
   }
   function require(param){
    if(! param) return caml_call1(Stdlib[2], cst_require_argument_is_None);
    var v = param[1];
    return v;
   }
   function forget_type(n){
    return require_internal(cst_Soup_forget_type_internal_, n[1]);
   }
   function coerce(node){return forget_type(node);}
   function create_element(name, attributes, children){
    var
     values = [0, name, attributes, children],
     node = [0, 0, 0, [0, -744106340, values]];
    node[1] = [0, node];
    function _ct_(child){child[2] = [0, node]; return 0;}
    caml_call1(caml_call1(Stdlib_List[18], _ct_), children);
    return node;
   }
   function create_text(text){
    var node = [0, 0, 0, [0, 936573133, text]];
    node[1] = [0, node];
    return node;
   }
   function create_document(doctype, roots){
    var node = [0, 0, 0, [0, -188437701, [0, roots, doctype]]];
    node[1] = [0, node];
    function _cs_(root){root[2] = [0, node]; return 0;}
    caml_call1(caml_call1(Stdlib_List[18], _cs_), roots);
    return node;
   }
   function create_soup(param){return create_document(0, 0);}
   function from_signals(map_attributes, signals){
    var doctype = [0, 0];
    function _cg_(s){
     a:
     if(typeof s !== "number" && 990181650 === s[1]){var d = s[2]; doctype[1] = [0, d]; break a;}
     return s;
    }
    var
     s = caml_call1(caml_call1(Markup[24], _cg_), signals),
     _ch_ = 0,
     _ci_ = 0,
     _cj_ = 0,
     _ck_ = 0,
     _cl_ =
       [0,
        function(name, attributes, children){
         function _cp_(param){
          var v = param[2], match = param[1], n = match[2], ns = match[1];
          if(! caml_string_notequal(ns, cst$8)) return [0, n, v];
          var _cr_ = caml_call2(Stdlib[28], cst, n);
          return [0, caml_call2(Stdlib[28], ns, _cr_), v];
         }
         var
          _cq_ = caml_call1(caml_call1(Stdlib_List[20], _cp_), attributes),
          attributes$0 = caml_call1(caml_call1(map_attributes, name), _cq_);
         return create_element(name[2], attributes$0, children);
        }],
     _cm_ =
       [0, function(ss){return create_text(caml_call2(concat, cst$0, ss));}],
     _cn_ = caml_call7(Markup[33], _cm_, _cl_, _ck_, _cj_, _ci_, _ch_, s),
     _co_ = caml_call1(Markup[30], _cn_);
    return create_document(doctype[1], _co_);
   }
   function _a_(n, a){return a;}
   function from_signals$0(_cf_){return from_signals(_a_, _cf_);}
   function parse(text){
    var body_attributes = [0, 0];
    function report(l, e){
     if(typeof e !== "number" && -298452471 === e[1]){
      var _ce_ = e[2];
      if(! caml_string_notequal(_ce_[1], cst_body)){
       var attributes = _ce_[3];
       body_attributes[1] =
        caml_call2(Stdlib[37], body_attributes[1], attributes);
       return 0;
      }
     }
     return 0;
    }
    var
     s = caml_call1(Markup[10], text),
     _ca_ = caml_call4(Markup[8], [0, report], 0, 0, s),
     _cb_ = caml_call1(Markup[4], _ca_);
    return from_signals
            (function(name, attributes){
              var ns = name[1];
              if
               (!
                caml_string_notequal(name[2], cst_body)
                && caml_string_equal(ns, Markup[45][1])){
               var
                _cc_ = body_attributes[1],
                _cd_ =
                  function(attributes, param){
                   var v = param[2], n = param[1];
                   return caml_call2(Stdlib_List[53], n, attributes)
                           ? attributes
                           : [0, [0, n, v], attributes];
                  };
               return caml_call3(Stdlib_List[26], _cd_, attributes, _cc_);
              }
              return attributes;
             },
             _cb_);
   }
   function is_document(node){
    var _b$_ = node[3][1];
    return -188437701 === _b$_ ? 1 : 936573133 <= _b$_ ? 0 : 0;
   }
   function is_element(node){
    var _b__ = node[3][1];
    return -188437701 === _b__ ? 0 : 936573133 <= _b__ ? 0 : 1;
   }
   function is_text(node){
    var _b9_ = node[3][1];
    return -188437701 === _b9_ ? 0 : 936573133 <= _b9_ ? 1 : 0;
   }
   function element(node){
    return is_element(node) ? [0, forget_type(node)] : 0;
   }
   var Stop = [248, cst_Soup_Stop, caml_fresh_oo_id(0)], next = [0, _b_];
   function with_stop(f){
    var result = [0, 0], current = next[1];
    next[1] = caml_call1(Stdlib_Int64[6], current);
    var
     stop = [0, function(v){result[1] = [0, v]; throw [0, Stop, current];}];
    try{var _b8_ = caml_call1(f, stop); return _b8_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Stop){
      var id = exn[2];
      if(caml_equal(id, current)){
       var match = result[1];
       if(! match)
        return caml_call1(Stdlib[2], cst_Soup_with_stop_internal_er);
       var v = match[1];
       return v;
      }
     }
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function name(param){
    var _b7_ = param[3];
    if(typeof _b7_ !== "number" && -744106340 === _b7_[1]){
     var name = _b7_[2][1];
     return caml_call1(lowercase_ascii, name);
    }
    return caml_call1(Stdlib[2], cst_Soup_name_internal_error_n);
   }
   function fold_attributes(f, init, param){
    var _b5_ = param[3];
    if(typeof _b5_ !== "number" && -744106340 === _b5_[1]){
     var
      attributes = _b5_[2][2],
      _b6_ =
        function(v, param){
         var value = param[2], name = param[1];
         return caml_call3(f, v, name, value);
        };
     return caml_call1(caml_call2(Stdlib_List[26], _b6_, init), attributes);
    }
    return caml_call1(Stdlib[2], cst_Soup_fold_attributes_inter);
   }
   function attribute(name, node){
    return with_stop
            (function(stop){
              var _b4_ = 0;
              return fold_attributes
                      (function(param, name$0, value){
                        return caml_string_equal(name$0, name)
                                ? caml_call1(stop[1], [0, value])
                                : 0;
                       },
                       _b4_,
                       node);
             });
   }
   function has_attribute(name, node){return attribute(name, node) ? 1 : 0;}
   function split_attribute(s){
    var index = 0, vs = 0;
    for(;;){
     if(index === caml_ml_string_length(s))
      return caml_call1(Stdlib_List[10], vs);
     try{
      var
       _b2_ = [0, caml_call3(index_from, s, index, 32)],
       maybe_index = _b2_;
     }
     catch(_b3_){
      var _b0_ = caml_wrap_exception(_b3_);
      if(_b0_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b0_, 0);
      var maybe_index = 0;
     }
     if(! maybe_index){
      var
       _b1_ =
         [0,
          caml_call3(sub, s, index, caml_ml_string_length(s) - index | 0),
          vs];
      return caml_call1(Stdlib_List[10], _b1_);
     }
     var index$0 = maybe_index[1];
     if(index$0 === index)
      var index$1 = index$0 + 1 | 0, index = index$1;
     else
      var
       vs$0 = [0, caml_call3(sub, s, index, index$0 - index | 0), vs],
       index$2 = index$0 + 1 | 0,
       index = index$2,
       vs = vs$0;
    }
   }
   function classes(node){
    var match = attribute(cst_class, node);
    if(! match) return 0;
    var classes = match[1];
    return split_attribute(classes);
   }
   function id(_bZ_){return attribute(cst_id, _bZ_);}
   var empty = [0, function(param, init){return init;}];
   function fold(f, init, sequence){return caml_call2(sequence[1], f, init);}
   function filter_map(f, sequence){
    return [0,
            function(f$0, init){
             function _bY_(v, node){
              var match = caml_call1(f, node);
              if(! match) return v;
              var node$0 = match[1];
              return caml_call2(f$0, v, node$0);
             }
             return caml_call1(caml_call1(sequence[1], _bY_), init);
            }];
   }
   function filter(f){
    function _bW_(node){return caml_call1(f, node) ? [0, node] : 0;}
    return function(_bX_){return filter_map(_bW_, _bX_);};
   }
   function map(f){
    function _bU_(node){return [0, caml_call1(f, node)];}
    return function(_bV_){return filter_map(_bU_, _bV_);};
   }
   function flatten(f, sequence){
    return [0,
            function(f$0, init){
             function _bT_(v, node){
              return caml_call1(caml_call1(caml_call1(f, node)[1], f$0), v);
             }
             return caml_call1(caml_call1(sequence[1], _bT_), init);
            }];
   }
   function iter(f, sequence){
    var _bS_ = 0;
    return fold
            (function(param, node){return caml_call1(f, node);},
             _bS_,
             sequence);
   }
   function nth(index, sequence){
    return with_stop
            (function(stop){
              var _bR_ = 1;
              fold
               (function(index$0, node){
                 return index$0 === index
                         ? caml_call1(stop[1], [0, node])
                         : index$0 + 1 | 0;
                },
                _bR_,
                sequence);
              return 0;
             });
   }
   function first(sequence){return nth(1, sequence);}
   function last(sequence){
    var _bQ_ = 0;
    return fold(function(param, node){return [0, node];}, _bQ_, sequence);
   }
   function count(sequence){
    var _bP_ = 0;
    return fold(function(count, param){return count + 1 | 0;}, _bP_, sequence);
   }
   function to_list(sequence){
    var
     _bN_ = 0,
     _bO_ = fold(function(l, node){return [0, node, l];}, _bN_, sequence);
    return caml_call1(Stdlib_List[10], _bO_);
   }
   function rev(sequence){
    var _bM_ = to_list(sequence), l = caml_call1(Stdlib_List[10], _bM_);
    return [0,
            function(f, init){return caml_call3(Stdlib_List[26], f, init, l);}];
   }
   function elements(sequence){
    return [0,
            function(f, init){
             function _bL_(v, node){
              var match = element(node);
              if(! match) return v;
              var element$0 = match[1];
              return caml_call2(f, v, element$0);
             }
             return caml_call1(caml_call1(sequence[1], _bL_), init);
            }];
   }
   function child_list(param){
    var _bJ_ = param[3];
    if(typeof _bJ_ !== "number"){
     var _bK_ = _bJ_[1];
     if(-744106340 === _bK_){var children = _bJ_[2][3]; return [0, children];}
     if(-188437701 === _bK_){var roots = _bJ_[2][1]; return [0, roots];}
    }
    return 0;
   }
   function children(node){
    var match = child_list(node);
    if(! match) return empty;
    var children = match[1];
    return [0,
            function(f, init){
             return caml_call3(Stdlib_List[26], f, init, children);
            }];
   }
   function descendants(node){
    return [0,
            function(f, init){
             function _bH_(v, child){
              var _bI_ = caml_call2(f, v, child);
              return caml_call1
                      (caml_call1(descendants(forget_type(child))[1], f), _bI_);
             }
             return caml_call1(caml_call1(children(node)[1], _bH_), init);
            }];
   }
   function child(node){return first(children(node));}
   function child_element(node){return first(elements(children(node)));}
   function simple_parent(node){return node[2];}
   function parent(node){
    var match = node[2];
    if(! match) return 0;
    var node$0 = match[1];
    return is_document(node$0) ? 0 : [0, node$0];
   }
   function general_ancestors(get_parent, node){
    return [0,
            function(f, init){
             var match = caml_call1(get_parent, node);
             if(! match) return init;
             var parent = match[1], _bG_ = caml_call2(f, init, parent);
             return caml_call1
                     (caml_call1
                       (general_ancestors(get_parent, forget_type(parent))[1], f),
                      _bG_);
            }];
   }
   function ancestors(node){return general_ancestors(parent, node);}
   function siblings(node){
    var match = node[2];
    if(! match) return empty;
    var parent = match[1], _bF_ = children(parent);
    return filter
             (function(child){return child !== forget_type(node) ? 1 : 0;})
            (_bF_);
   }
   function sibling_lists(function_name, select, node){
    var match = node[2];
    if(! match) return empty;
    var parent = match[1], match$0 = child_list(parent);
    if(! match$0){
     var
      _bC_ =
        caml_call2(Stdlib[28], function_name, cst_internal_error_parent_has_),
      _bD_ = caml_call2(Stdlib[28], cst_Soup$0, _bC_);
     return caml_call1(Stdlib[2], _bD_);
    }
    var
     children = match$0[1],
     v = forget_type(node),
     prefix = 0,
     param = children;
    for(;;){
     if(param){
      var suffix = param[2], u = param[1];
      if(u !== v){
       var prefix$0 = [0, u, prefix], prefix = prefix$0, param = suffix;
       continue;
      }
      var lists = [0, prefix, suffix];
     }
     else
      var
       _bA_ =
         caml_call2(Stdlib[28], function_name, cst_internal_error_child_not_i),
       _bB_ = caml_call2(Stdlib[28], cst_Soup, _bA_),
       lists = caml_call1(Stdlib[2], _bB_);
     return [0,
             function(f, init){
              var _bE_ = caml_call1(select, lists);
              return caml_call1(caml_call2(Stdlib_List[26], f, init), _bE_);
             }];
    }
   }
   function next_siblings(node){
    return sibling_lists
            (cst_next_siblings, function(_bz_){return _bz_[2];}, node);
   }
   function previous_siblings(node){
    return sibling_lists
            (cst_previous_siblings, function(_by_){return _by_[1];}, node);
   }
   function next_sibling(node){return first(next_siblings(node));}
   function previous_sibling(node){return first(previous_siblings(node));}
   function next_element(node){return first(elements(next_siblings(node)));}
   function previous_element(node){
    return first(elements(previous_siblings(node)));
   }
   function index_of(node){
    var match = node[2];
    if(! match) return 1;
    var parent = match[1], match$0 = child_list(parent);
    if(! match$0)
     return caml_call1(Stdlib[2], cst_Soup_index_of_internal_err$0);
    var children = match$0[1];
    return with_stop
            (function(stop){
              function _bw_(index, child){
               var _bx_ = child === forget_type(node) ? 1 : 0;
               return _bx_ ? caml_call1(stop[1], index + 1 | 0) : _bx_;
              }
              caml_call1(caml_call1(Stdlib_List[19], _bw_), children);
              return caml_call1(Stdlib[2], cst_Soup_index_of_internal_err);
             });
   }
   function index_of_element(element){
    var match = element[2];
    if(! match) return 1;
    var parent = match[1];
    return with_stop
            (function(stop){
              var _bt_ = elements(children(parent)), _bu_ = 1;
              fold
               (function(index, element$0){
                 return element$0 === element
                         ? caml_call1(stop[1], index)
                         : index + 1 | 0;
                },
                _bu_,
                _bt_);
              var
               _bv_ =
                 caml_call2
                  (Stdlib[28],
                   cst_Soup_index_of_element_inte,
                   cst_element_is_not_a_child_of_);
              return caml_call1(Stdlib[2], _bv_);
             });
   }
   function at_most_n_children(count, node){
    return nth(count + 1 | 0, children(node)) ? 0 : 1;
   }
   function no_children(node){return at_most_n_children(0, node);}
   function at_most_one_child(node){return at_most_n_children(1, node);}
   function is_root(node){
    var match = node[2];
    if(! match) return 1 - is_document(node);
    var parent = match[1];
    return is_document(parent);
   }
   function tags(name$0, node){
    var
     name$1 = caml_call1(lowercase_ascii, name$0),
     _bs_ = elements(descendants(node));
    return filter
             (function(element){
               return caml_string_equal(name(element), name$1);
              })
            (_bs_);
   }
   function tag(name, node){return first(tags(name, node));}
   function normalize_children(trim, children){
    var prefix = 0, param = children;
    for(;;){
     if(! param) return caml_call1(Stdlib_List[10], prefix);
     var rest = param[2], node = param[1], match = node[3];
     if(typeof match !== "number" && 936573133 === match[1]){
      var s = match[2], s$0 = caml_call1(trim, s);
      if(caml_string_equal(s$0, cst$8)){var param = rest; continue;}
      if(prefix){
       var match$0 = prefix[1][3];
       if(typeof match$0 !== "number" && 936573133 === match$0[1]){
        var
         prefix$2 = prefix[2],
         s$1 = match$0[2],
         prefix$3 =
           [0, create_text(caml_call2(Stdlib[28], s$1, s$0)), prefix$2],
         prefix = prefix$3,
         param = rest;
        continue;
       }
      }
      var
       prefix$1 = [0, create_text(s$0), prefix],
       prefix = prefix$1,
       param = rest;
      continue;
     }
     var prefix$0 = [0, node, prefix], prefix = prefix$0, param = rest;
    }
   }
   function leaf_text(node){
    var node$0 = node;
    for(;;){
     var
      trim$0 =
        function(s){return caml_string_equal(trim(s), cst$8) ? cst$1 : s;},
      match = node$0[3];
     if(936573133 <= match[1]){var s = match[2]; return [0, s];}
     var
      _br_ = child_list(node$0),
      children =
        normalize_children
         (trim$0,
          require_internal
           (caml_call2
             (Stdlib[28],
              cst_Soup_leaf_text_internal_er,
              cst_but_has_no_child_list),
            _br_));
     if(! children) return _c_;
     if(children[2]) return 0;
     var child = children[1], node$1 = forget_type(child), node$0 = node$1;
    }
   }
   function texts(node){
    var match = node[3], _bm_ = match[1];
    if(-188437701 === _bm_){
     var
      roots = match[2][1],
      _bn_ = caml_call1(caml_call1(Stdlib_List[20], forget_type), roots),
      _bo_ = caml_call1(caml_call1(Stdlib_List[20], texts), _bn_);
     return caml_call1(caml_call2(Stdlib_List[26], Stdlib[37], 0), _bo_);
    }
    if(936573133 <= _bm_){var s = match[2]; return [0, s, 0];}
    var
     children = match[2][3],
     _bp_ = caml_call1(caml_call1(Stdlib_List[20], forget_type), children),
     _bq_ = caml_call1(caml_call1(Stdlib_List[20], texts), _bp_);
    return caml_call1(caml_call2(Stdlib_List[26], Stdlib[37], 0), _bq_);
   }
   function trimmed_texts(node){
    var
     _bj_ = texts(node),
     _bk_ = caml_call1(caml_call1(Stdlib_List[20], trim), _bj_);
    function _bl_(s){return 0 < caml_ml_string_length(s) ? 1 : 0;}
    return caml_call1(caml_call1(Stdlib_List[44], _bl_), _bk_);
   }
   var Parse_error = [248, cst_Soup_Parse_error, caml_fresh_oo_id(0)];
   function has_prefix(prefix, s){
    return caml_string_equal
            (caml_call3(sub, s, 0, caml_ml_string_length(prefix)), prefix);
   }
   function has_substring(s$0, s){
    var substring_length = caml_ml_string_length(s$0);
    try{
     var index = 0;
     for(;;){
      if(caml_string_equal(caml_call3(sub, s, index, substring_length), s$0)){var _bg_ = 1; return _bg_;}
      var index$0 = index + 1 | 0, index = index$0;
     }
    }
    catch(_bi_){
     var _bh_ = caml_wrap_exception(_bi_);
     if(_bh_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_bh_, 0);
    }
   }
   function element_count(node){
    var match = node[2];
    if(! match) return 1;
    var parent = match[1];
    return count(elements(children(parent)));
   }
   function element_count_with_name(name$0, node){
    var match = node[2];
    if(! match) return 1;
    var parent = match[1], _bf_ = elements(children(parent));
    return count
            (filter
               (function(element){
                 return caml_string_equal(name(element), name$0);
                })
              (_bf_));
   }
   function element_index_with_name(name$0, node){
    var match = node[2];
    if(! match) return 1;
    var parent = match[1];
    return with_stop
            (function(stop){
              caml_call1(Stdlib[63], Stdlib[39]);
              var
               _bb_ = elements(children(parent)),
               _bc_ =
                 filter
                   (function(element){
                     return caml_string_equal(name(element), name$0);
                    })
                  (_bb_),
               _bd_ = 1;
              fold
               (function(index, element){
                 return element === node
                         ? caml_call1(stop[1], index)
                         : index + 1 | 0;
                },
                _bd_,
                _bc_);
              var
               _be_ =
                 caml_call2
                  (Stdlib[28],
                   cst_Soup_Selector_element_inde,
                   cst_parent_does_not_have_given);
              return caml_call1(Stdlib[2], _be_);
             });
   }
   function conditional_mod(n, a){return 0 === a ? n : caml_mod(n, a);}
   function matches_simple_selector(node, param){
    switch(param[0]){
      case 0:
       var match = param[1];
       if(! match) return 1;
       var name$8 = match[1], _a$_ = caml_call1(lowercase_ascii, name$8);
       return caml_string_equal(name(node), _a$_);
      case 1:
       var
        attribute_selector = param[1],
        captured =
          caml_call2
           (Stdlib[28],
            cst_Soup_matches_attribute_sel,
            cst_this_exception_should_have);
       try{
        switch(attribute_selector[0]){
          case 0:
           var
            name$0 = attribute_selector[1],
            _a4_ = has_attribute(name$0, node);
           break;
          case 1:
           var
            value = attribute_selector[2],
            name$1 = attribute_selector[1],
            _a4_ = caml_equal(attribute(name$1, node), [0, value]);
           break;
          case 2:
           var
            value$0 = attribute_selector[2],
            name$2 = attribute_selector[1],
            _a5_ =
              split_attribute
               (require_internal(captured, attribute(name$2, node))),
            _a4_ = caml_call1(caml_call1(Stdlib_List[37], value$0), _a5_);
           break;
          case 3:
           var
            value$1 = attribute_selector[2],
            name$3 = attribute_selector[1],
            value$4 = require_internal(captured, attribute(name$3, node)),
            _a6_ = caml_string_equal(value$4, value$1),
            _a7_ =
              _a6_
              || has_prefix(caml_call2(Stdlib[28], value$1, cst$2), value$4),
            _a4_ = _a7_;
           break;
          case 4:
           var
            value$2 = attribute_selector[2],
            name$4 = attribute_selector[1],
            _a4_ =
              has_prefix
               (value$2, require_internal(captured, attribute(name$4, node)));
           break;
          case 5:
           var
            suffix = attribute_selector[2],
            name$5 = attribute_selector[1],
            s$0 = require_internal(captured, attribute(name$5, node)),
            suffix_length = caml_ml_string_length(suffix),
            _a4_ =
              caml_string_equal
               (caml_call3
                 (sub,
                  s$0,
                  caml_ml_string_length(s$0) - suffix_length | 0,
                  suffix_length),
                suffix);
           break;
          default:
           var
            value$3 = attribute_selector[2],
            name$6 = attribute_selector[1],
            _a4_ =
              has_substring
               (value$3, require_internal(captured, attribute(name$6, node)));
        }
        return _a4_;
       }
       catch(_ba_){return 0;}
      default:
       var pseudo_class_selector = param[1];
       if(typeof pseudo_class_selector === "number")
        switch(pseudo_class_selector){
          case 0:
           return 0 === parent(node) ? 1 : 0;
          case 1:
           return 1 === element_count(node) ? 1 : 0;
          case 2:
           return 1 === element_count_with_name(name(node), node) ? 1 : 0;
          default: return no_children(node);
        }
       switch(pseudo_class_selector[0]){
         case 0:
          var b = pseudo_class_selector[2], a = pseudo_class_selector[1];
          return conditional_mod(index_of_element(node), a) === b ? 1 : 0;
         case 1:
          var
           b$0 = pseudo_class_selector[2],
           a$0 = pseudo_class_selector[1],
           element_count$0 = element_count(node);
          return conditional_mod
                   ((element_count$0 - index_of_element(node) | 0) + 1 | 0,
                    a$0)
                  === b$0
                  ? 1
                  : 0;
         case 2:
          var b$1 = pseudo_class_selector[2], a$1 = pseudo_class_selector[1];
          return conditional_mod
                   (element_index_with_name(name(node), node), a$1)
                  === b$1
                  ? 1
                  : 0;
         case 3:
          var
           b$2 = pseudo_class_selector[2],
           a$2 = pseudo_class_selector[1],
           name$7 = name(node),
           element_count$1 = element_count_with_name(name$7, node);
          return conditional_mod
                   ((element_count$1 - element_index_with_name(name$7, node)
                    | 0)
                    + 1
                    | 0,
                    a$2)
                  === b$2
                  ? 1
                  : 0;
         case 4:
          var s = pseudo_class_selector[1], _a8_ = texts(node);
          return has_substring(s, caml_call1(caml_call1(concat, cst$3), _a8_));
         case 5:
          var
           selector = pseudo_class_selector[1],
           _a9_ = descendants(node),
           _a__ =
             filter(function(descendant){return 1 - is_text(descendant);})
              (_a9_);
          return 0
                  <
                   count
                    (filter
                       (function(descendant){
                         return matches_simple_selector(descendant, selector);
                        })
                      (_a__))
                  ? 1
                  : 0;
         default:
          var selector$0 = pseudo_class_selector[1];
          return 1 - matches_simple_selector(node, selector$0);
       }
    }
   }
   function up_to(node, sequence){
    return [0,
            function(f, init){
             return with_stop
                     (function(stop){
                       function _a3_(v, node$0){
                        var v$0 = caml_call2(f, v, node$0);
                        return node$0 === node ? caml_call1(stop[1], v$0) : v$0;
                       }
                       return caml_call2(sequence[1], _a3_, init);
                      });
            }];
   }
   function one(sequence){
    return [0,
            function(f, init){
             return with_stop
                     (function(stop){
                       function _a1_(v, node){
                        var _a2_ = caml_call2(f, v, node);
                        return caml_call1(stop[1], _a2_);
                       }
                       return caml_call2(sequence[1], _a1_, init);
                      });
            }];
   }
   function matches_selector(selector, root_node, at_node){
    return with_stop
            (function(stop){
              function backwards_traversal(at_node, param){
               if(! param)
                return at_node === root_node ? caml_call1(stop[1], 1) : 0;
               var
                rest = param[2],
                match = param[1],
                simple_selectors = match[2],
                combinator = match[1];
               if(! is_element(at_node)) return 0;
               function _aZ_(_a0_){
                return matches_simple_selector(at_node, _a0_);
               }
               if(! caml_call2(Stdlib_List[33], _aZ_, simple_selectors))
                return 0;
               switch(combinator){
                 case 0:
                  var
                   next_nodes =
                     up_to(root_node, general_ancestors(simple_parent, at_node));
                  break;
                 case 1:
                  var next_nodes = one(ancestors(at_node)); break;
                 case 2:
                  var next_nodes = one(elements(previous_siblings(at_node)));
                  break;
                 default:
                  var
                   next_nodes =
                     up_to(root_node, elements(previous_siblings(at_node)));
               }
               return iter
                       (function(node){return backwards_traversal(node, rest);},
                        next_nodes);
              }
              backwards_traversal
               (at_node, caml_call1(Stdlib_List[10], selector));
              return 0;
             });
   }
   function is_decimal_char(c){
    var _aX_ = 48 <= c ? 1 : 0, _aY_ = _aX_ ? c <= 57 ? 1 : 0 : _aX_;
    return _aY_;
   }
   function is_hexadecimal_char(c){
    var _aS_ = is_decimal_char(c);
    if(_aS_)
     var _aT_ = _aS_;
    else{
     var _aU_ = 97 <= c ? 1 : 0, _aV_ = _aU_ ? c <= 102 ? 1 : 0 : _aU_;
     if(_aV_)
      var _aT_ = _aV_;
     else
      var _aW_ = 65 <= c ? 1 : 0, _aT_ = _aW_ ? c <= 70 ? 1 : 0 : _aW_;
    }
    return _aT_;
   }
   function is_identifier_char(c){
    var
     c$0 = caml_call1(Stdlib_Char[3], c),
     _aN_ = 97 <= c$0 ? 1 : 0,
     _aO_ = _aN_ ? c$0 <= 122 ? 1 : 0 : _aN_;
    if(_aO_)
     var _aP_ = _aO_;
    else{
     var _aQ_ = is_decimal_char(c$0);
     if(_aQ_)
      var _aP_ = _aQ_;
     else
      var _aR_ = 45 === c$0 ? 1 : 0, _aP_ = _aR_ || (95 === c$0 ? 1 : 0);
    }
    return _aP_;
   }
   function parse_error(msg){
    throw caml_maybe_attach_backtrace([0, Parse_error, msg], 1);
   }
   function parse_identifier(stream){
    var
     buffer = caml_call1(Stdlib_Buffer[1], 32),
     match$2 = caml_call1(Stream[11], stream);
    a:
    {
     b:
     if(match$2){
      var c$1 = match$2[1];
      if(92 !== c$1 && ! is_identifier_char(c$1)) break b;
      break a;
     }
     parse_error(cst_expected_an_identifier);
    }
    for(;;){
     var match$3 = caml_call1(Stream[11], stream);
     if(match$3){
      var c$2 = match$3[1];
      if(92 === c$2){
       caml_call1(Stream[12], stream);
       var match$1 = caml_call1(Stream[11], stream);
       if(match$1){
        var c$0 = match$1[1];
        if(is_hexadecimal_char(c$0)){
         a:
         b:
         {
          c:
          d:
          {
           e:
           {
            var value = 0, count = 0;
            for(;;){
             if(6 <= count) break b;
             var match = caml_call1(Stream[11], stream);
             if(! match) break c;
             var c = match[1], switcher = c - 11 | 0;
             if(20 < switcher >>> 0){
              if(23 >= switcher + 2 >>> 0) break e;
             }
             else if(2 === switcher) break;
             if(! is_hexadecimal_char(c)) break d;
             caml_call1(Stream[12], stream);
             var _aJ_ = c - 65 | 0;
             f:
             {
              if(37 >= _aJ_ >>> 0)
               switch(_aJ_){
                 case 0:
                 case 32:
                  var _aK_ = 10; break f;
                 case 1:
                 case 33:
                  var _aK_ = 11; break f;
                 case 2:
                 case 34:
                  var _aK_ = 12; break f;
                 case 3:
                 case 35:
                  var _aK_ = 13; break f;
                 case 4:
                 case 36:
                  var _aK_ = 14; break f;
                 case 5:
                 case 37:
                  var _aK_ = 15; break f;
               }
              var _aK_ = c - 48 | 0;
             }
             var
              value$0 = (value * 16 | 0) + _aK_ | 0,
              count$0 = count + 1 | 0,
              value = value$0,
              count = count$0;
            }
            var match$0 = caml_call2(Stream[14], 2, stream);
            f:
            if(match$0 && 13 === match$0[1]){
             var _aL_ = match$0[2];
             if(_aL_ && 10 === _aL_[1] && ! _aL_[2]){
              caml_call1(Stream[12], stream);
              caml_call1(Stream[12], stream);
              break f;
             }
            }
            break a;
           }
           caml_call1(Stream[12], stream);
           break a;
          }
          break a;
         }
         var _aM_ = 255 < value ? 26 : caml_call1(Stdlib_Char[1], value);
        }
        else{caml_call1(Stream[12], stream); var _aM_ = c$0;}
       }
       else
        var _aM_ = 92;
       caml_call2(Stdlib_Buffer[12], buffer, _aM_);
       continue;
      }
      if(is_identifier_char(c$2)){
       caml_call2(Stdlib_Buffer[12], buffer, c$2);
       caml_call1(Stream[12], stream);
       continue;
      }
     }
     return caml_call1(Stdlib_Buffer[2], buffer);
    }
   }
   function parse_quoted_string(stream){
    var match = caml_call1(Stream[11], stream);
    a:
    if(match){
     var delim = match[1];
     if(34 !== delim && 39 !== delim) break a;
     caml_call1(Stream[12], stream);
     var buffer = caml_call1(Stdlib_Buffer[1], 64);
     for(;;){
      var match$0 = caml_call1(Stream[11], stream);
      if(! match$0) return parse_error(cst_unterminated_string);
      var c = match$0[1];
      if(c === delim){
       caml_call1(Stream[12], stream);
       return caml_call1(Stdlib_Buffer[2], buffer);
      }
      if(92 === c){
       caml_call1(Stream[12], stream);
       var match$1 = caml_call1(Stream[11], stream);
       b:
       {
        if(match$1){
         var c$0 = match$1[1];
         if(c$0 === delim){
          caml_call2(Stdlib_Buffer[12], buffer, delim);
          caml_call1(Stream[12], stream);
          break b;
         }
        }
        caml_call2(Stdlib_Buffer[12], buffer, 92);
       }
      }
      else{
       caml_call2(Stdlib_Buffer[12], buffer, c);
       caml_call1(Stream[12], stream);
      }
     }
    }
    return parse_error(cst_expected_quoted_string);
   }
   function consume_whitespace(stream){
    for(;;){
     var match = caml_call1(Stream[11], stream);
     if(match){
      var c = match[1], _aF_ = 32 === c ? 1 : 0;
      if(_aF_)
       var _aG_ = _aF_;
      else{
       var _aH_ = 9 === c ? 1 : 0;
       if(_aH_)
        var _aG_ = _aH_;
       else
        var _aI_ = 10 === c ? 1 : 0, _aG_ = _aI_ || (13 === c ? 1 : 0);
      }
      if(_aG_){caml_call1(Stream[12], stream); continue;}
     }
     return;
    }
   }
   function parse_number(stream){
    var buffer = caml_call1(Stdlib_Buffer[1], 16);
    for(;;){
     var match = caml_call1(Stream[11], stream);
     if(match){
      var c = match[1];
      if(is_decimal_char(c)){
       caml_call2(Stdlib_Buffer[12], buffer, c);
       caml_call1(Stream[12], stream);
       continue;
      }
     }
     return runtime.caml_int_of_string(caml_call1(Stdlib_Buffer[2], buffer));
    }
   }
   function parse_modular_pattern_tail(a, stream){
    caml_call1(Stream[12], stream);
    var match = caml_call1(Stream[11], stream);
    a:
    if(match){
     var c = match[1];
     if(43 !== c && 45 !== c) break a;
     caml_call1(Stream[12], stream);
     var match$0 = caml_call1(Stream[11], stream);
     if(match$0){
      var c$0 = match$0[1];
      if(is_decimal_char(c$0)){
       var
        b = parse_number(stream),
        b$0 = 43 === c ? caml_mod(b, a) : a - caml_mod(b, a) | 0;
       return [0, a, b$0];
      }
     }
     return parse_error(cst_expected_number_after_or);
    }
    return [0, a, 0];
   }
   function parse_modular_pattern(stream){
    var match = caml_call1(Stream[11], stream);
    if(match){
     var c = match[1], switcher = c - 101 | 0;
     if(10 >= switcher >>> 0)
      switch(switcher){
        case 9:
         return parse_modular_pattern_tail(1, stream);
        case 0:
        case 10:
         var match$1 = parse_identifier(stream);
         return caml_string_notequal(match$1, "even")
                 ? caml_string_notequal
                    (match$1, "odd")
                   ? parse_error(cst_expected_n_even_or_odd)
                   : _f_
                 : _g_;
      }
     if(is_decimal_char(c)){
      var a = parse_number(stream), match$0 = caml_call1(Stream[11], stream);
      if(match$0 && 110 === match$0[1])
       return parse_modular_pattern_tail(a, stream);
      return [0, 0, a];
     }
    }
    return parse_error(cst_expected_expression);
   }
   function parse_parenthesized_value(f, stream){
    var match = caml_call1(Stream[11], stream);
    if(match && 40 === match[1]){
     caml_call1(Stream[12], stream);
     consume_whitespace(stream);
     var value = caml_call1(f, stream);
     consume_whitespace(stream);
     var match$0 = caml_call1(Stream[11], stream);
     if(match$0 && 41 === match$0[1]){
      caml_call1(Stream[12], stream);
      return value;
     }
     return parse_error(cst_unterminated);
    }
    return parse_error(cst_expected_parenthesized_exp);
   }
   function parse_simple_selector(stream){
    var match$10 = caml_call1(Stream[11], stream);
    if(! match$10) return parse_error(cst_expected_simple_selector);
    var _aA_ = match$10[1];
    if(47 <= _aA_){
     if(58 === _aA_){
      caml_call1(Stream[12], stream);
      var
       function$0 = parse_identifier(stream),
       switch$0 = caml_string_compare(function$0, "not");
      a:
      {
       if(0 <= switch$0){
        if(0 >= switch$0){
         var
          selector = parse_parenthesized_value(parse_simple_selector, stream),
          _aB_ = [6, selector];
         break a;
        }
        if(! caml_string_notequal(function$0, "nth-child")){
         var
          match$9 = parse_parenthesized_value(parse_modular_pattern, stream),
          b$2 = match$9[2],
          a$2 = match$9[1],
          _aB_ = [0, a$2, b$2];
         break a;
        }
        if(! caml_string_notequal(function$0, "nth-last-child")){
         var
          match$8 = parse_parenthesized_value(parse_modular_pattern, stream),
          b$1 = match$8[2],
          a$1 = match$8[1],
          _aB_ = [1, a$1, b$1];
         break a;
        }
        if(! caml_string_notequal(function$0, "nth-last-of-type")){
         var
          match$7 = parse_parenthesized_value(parse_modular_pattern, stream),
          b$0 = match$7[2],
          a$0 = match$7[1],
          _aB_ = [3, a$0, b$0];
         break a;
        }
        if(! caml_string_notequal(function$0, "nth-of-type")){
         var
          match$6 = parse_parenthesized_value(parse_modular_pattern, stream),
          b = match$6[2],
          a = match$6[1],
          _aB_ = [2, a, b];
         break a;
        }
        if(! caml_string_notequal(function$0, "only-child")){var _aB_ = 1; break a;}
        if(! caml_string_notequal(function$0, "only-of-type")){var _aB_ = 2; break a;}
        if(! caml_string_notequal(function$0, "root")){var _aB_ = 0; break a;}
       }
       else{
        if(! caml_string_notequal(function$0, "contains")){
         var
          s = parse_parenthesized_value(parse_quoted_string, stream),
          _aB_ = [4, s];
         break a;
        }
        if(! caml_string_notequal(function$0, "empty")){var _aB_ = 3; break a;}
        if(! caml_string_notequal(function$0, "first-child")){var _aB_ = _l_; break a;}
        if(! caml_string_notequal(function$0, "first-of-type")){var _aB_ = _k_; break a;}
        if(! caml_string_notequal(function$0, "has")){
         var
          selector$0 =
            parse_parenthesized_value(parse_simple_selector, stream),
          _aB_ = [5, selector$0];
         break a;
        }
        if(! caml_string_notequal(function$0, "last-child")){var _aB_ = _j_; break a;}
        if(! caml_string_notequal(function$0, "last-of-type")){var _aB_ = _i_; break a;}
       }
       var _aB_ = caml_call3(Stdlib_Printf[10], parse_error, _h_, function$0);
      }
      return [2, _aB_];
     }
     if(91 === _aA_){
      caml_call1(Stream[12], stream);
      consume_whitespace(stream);
      var name$0 = parse_identifier(stream);
      consume_whitespace(stream);
      var match$3 = caml_call1(Stream[11], stream);
      if(match$3)
       if(93 === match$3[1]){
        caml_call1(Stream[12], stream);
        var _aC_ = [0, name$0];
       }
       else{
        var match$0 = caml_call2(Stream[14], 2, stream);
        a:
        {
         if(match$0){
          var c = match$0[1];
          if(61 === c){
           var _ax_ = match$0[2];
           if(_ax_ && ! _ax_[2]){
            caml_call1(Stream[12], stream);
            var operator = cst$4;
            break a;
           }
          }
          else{
           var _ay_ = match$0[2];
           if(_ay_ && 61 === _ay_[1] && ! _ay_[2]){
            caml_call1(Stream[12], stream);
            caml_call1(Stream[12], stream);
            var operator = caml_call2(Stdlib_Printf[4], _d_, c);
            break a;
           }
          }
         }
         var operator = parse_error(cst_expected_attribute_operato);
        }
        consume_whitespace(stream);
        var match$4 = caml_call1(Stream[11], stream);
        if(match$4)
         if(93 === match$4[1])
          var _aC_ = parse_error(cst_expected_value_in_attribut);
         else{
          var match$1 = caml_call1(Stream[11], stream);
          a:
          {
           b:
           if(match$1){
            var _az_ = match$1[1];
            if(34 !== _az_ && 39 !== _az_) break b;
            var value = parse_quoted_string(stream);
            break a;
           }
           var buffer = caml_call1(Stdlib_Buffer[1], 32);
           b:
           for(;;){
            var match$2 = caml_call1(Stream[11], stream);
            if(! match$2) break b;
            var c$0 = match$2[1];
            if(93 === c$0) break;
            caml_call2(Stdlib_Buffer[12], buffer, c$0);
            caml_call1(Stream[12], stream);
           }
           var value = caml_call1(Stdlib_Buffer[2], buffer);
          }
          consume_whitespace(stream);
          var
           match$5 = caml_call1(Stream[11], stream),
           _aC_ =
             match$5
              ? 93
                === match$5[1]
                ? (caml_call1
                   (Stream[12], stream),
                  caml_string_notequal(operator, "$=")
                   ? caml_string_notequal
                      (operator, "*=")
                     ? caml_string_notequal
                        (operator, cst$10)
                       ? caml_string_notequal
                          (operator, "^=")
                         ? caml_string_notequal
                            (operator, "|=")
                           ? caml_string_notequal
                              (operator, "~=")
                             ? caml_call3(Stdlib_Printf[10], parse_error, _e_, operator)
                             : [2, name$0, value]
                           : [3, name$0, value]
                         : [4, name$0, value]
                       : [1, name$0, value]
                     : [6, name$0, value]
                   : [5, name$0, value])
                : parse_error(cst_expected_end_of_attribute_)
              : parse_error(cst_unterminated_attribute_sel);
         }
        else
         var _aC_ = parse_error(cst_unterminated_attribute_sel$0);
       }
      else
       var _aC_ = parse_error(cst_unterminated_attribute_sel$1);
      return [1, _aC_];
     }
    }
    else{
     if(35 === _aA_){
      caml_call1(Stream[12], stream);
      var value$1 = parse_identifier(stream);
      return [1, [1, cst_id$0, value$1]];
     }
     if(46 <= _aA_){
      caml_call1(Stream[12], stream);
      var value$0 = parse_identifier(stream);
      return [1, [2, cst_class$0, value$0]];
     }
    }
    var match = caml_call1(Stream[11], stream);
    a:
    {
     if(match && 42 === match[1]){
      caml_call1(Stream[12], stream);
      var _aD_ = 0;
      break a;
     }
     try{var name = parse_identifier(stream), _aw_ = [0, name], _aD_ = _aw_;}
     catch(_aE_){var _aD_ = parse_error(cst_expected_tag_name_or);}
    }
    return [0, _aD_];
   }
   function parse$0(s){
    var stream = caml_call1(Stream[5], s), selectors$2 = 0;
    for(;;){
     consume_whitespace(stream);
     if(! caml_call1(Stream[11], stream))
      return caml_call1(Stdlib_List[10], selectors$2);
     var match$0 = caml_call1(Stream[11], stream);
     a:
     {
      b:
      if(match$0){
       var _au_ = match$0[1];
       if(43 === _au_){
        caml_call1(Stream[12], stream);
        var _av_ = 2;
       }
       else if(62 === _au_){
        caml_call1(Stream[12], stream);
        var _av_ = 1;
       }
       else{
        if(126 !== _au_) break b;
        caml_call1(Stream[12], stream);
        var _av_ = 3;
       }
       var combinator = _av_;
       break a;
      }
      var combinator = 0;
     }
     consume_whitespace(stream);
     var first = parse_simple_selector(stream), selectors$1 = [0, first, 0];
     a:
     {
      var selectors = selectors$1;
      for(;;){
       var match = caml_call1(Stream[11], stream);
       if(! match) break a;
       var c = match[1], _aq_ = 46 === c ? 1 : 0;
       if(_aq_)
        var _ar_ = _aq_;
       else{
        var _as_ = 35 === c ? 1 : 0;
        if(_as_)
         var _ar_ = _as_;
        else
         var _at_ = 91 === c ? 1 : 0, _ar_ = _at_ || (58 === c ? 1 : 0);
       }
       if(! _ar_) break;
       var
        selectors$0 = [0, parse_simple_selector(stream), selectors],
        selectors = selectors$0;
      }
     }
     var
      selectors$3 =
        [0,
         [0, combinator, caml_call1(Stdlib_List[10], selectors)],
         selectors$2],
      selectors$2 = selectors$3;
    }
   }
   function matches_selector$0(root_node, selector, node){
    var
     root_node$0 = forget_type(root_node),
     node$0 = forget_type(node),
     selector$0 = parse$0(selector);
    return matches_selector(selector$0, root_node$0, node$0);
   }
   function select(selector, root_node$0){
    var
     selector$0 = parse$0(selector),
     root_node = forget_type(root_node$0),
     match = root_node[2];
    if(match)
     var parent = match[1], candidates = descendants(parent);
    else
     var candidates = descendants(root_node);
    var _ao_ = elements(candidates);
    return filter
             (function(_ap_){
               return matches_selector(selector$0, root_node, _ap_);
              })
            (_ao_);
   }
   function select_one(selector, node){return first(select(selector, node));}
   function symbol(node, selector){
    var _an_ = select_one(selector, node);
    return require_internal
            (caml_call3
              (Stdlib_Printf[4],
               _m_,
               selector,
               cst_Try_Soup_if_you_d_prefer_r),
             _an_);
   }
   function symbol$0(node, selector){return select_one(selector, node);}
   function symbol$1(node, selector){return select(selector, node);}
   var Infix = [0, symbol, symbol$0, symbol$1];
   function signals(root){
    var root$0 = forget_type(root);
    function traverse(acc, param){
     var match = param[3], _al_ = match[1];
     if(-188437701 === _al_){
      var match$0 = match[2], roots = match$0[1], doctype = match$0[2];
      if(doctype)
       var
        doctype$0 = doctype[1],
        acc$0 = caml_call2(Stdlib[37], acc, [0, [0, 990181650, doctype$0], 0]);
      else
       var acc$0 = acc;
      return traverse_list(acc$0, roots);
     }
     if(936573133 <= _al_){
      var s = match[2];
      return [0, [0, 936573133, [0, s, 0]], acc];
     }
     var
      match$1 = match[2],
      name = match$1[1],
      attributes = match$1[2],
      children = match$1[3];
     function _am_(param){
      var v = param[2], n = param[1];
      return [0, [0, cst$5, n], v];
     }
     var
      start_signal =
        [0,
         856096383,
         [0,
          [0, cst_http_www_w3_org_1999_xhtml, name],
          caml_call2(Stdlib_List[20], _am_, attributes)]];
     return [0, 38565624, traverse_list([0, start_signal, acc], children)];
    }
    function traverse_list(acc, l){
     return caml_call3(Stdlib_List[26], traverse, acc, l);
    }
    var _aj_ = traverse(0, root$0), _ak_ = caml_call1(Stdlib_List[10], _aj_);
    return caml_call1(Markup[29], _ak_);
   }
   function pretty_print(root){
    var
     _ah_ = signals(root),
     s = caml_call1(Markup[39], _ah_),
     _ai_ = caml_call3(Markup[9], 0, 0, s);
    return caml_call1(Markup[15], _ai_);
   }
   function to_string(root){
    var s = signals(root), _ag_ = caml_call3(Markup[9], 0, 0, s);
    return caml_call1(Markup[15], _ag_);
   }
   function equal_general(normalize_children, n$0, n){
    function equal_children(children$0, children){
     var
      children$1 = caml_call1(normalize_children, children$0),
      children$2 = caml_call1(normalize_children, children);
     try{
      var
       _ac_ =
         function(c$0, c){
          var _af_ = 1 - equal_general(normalize_children, c$0, c);
          if(_af_) throw [0, Stdlib[6], cst_not_equal];
          return _af_;
         };
      caml_call3(Stdlib_List[28], _ac_, children$1, children$2);
      var _ad_ = 1;
      return _ad_;
     }
     catch(_ae_){
      var _ab_ = caml_wrap_exception(_ae_);
      if(_ab_[1] === Stdlib[6]) return 0;
      throw caml_maybe_attach_backtrace(_ab_, 0);
     }
    }
    var _$_ = n$0[3], _aa_ = _$_[1];
    if(-188437701 === _aa_){
     var values = _$_[2], match = n[3];
     if(typeof match !== "number" && -188437701 === match[1]){
      var values$0 = match[2];
      return equal_children(values[1], values$0[1]);
     }
    }
    else if(936573133 <= _aa_){
     var s = _$_[2], match$0 = n[3];
     if(typeof match$0 !== "number" && 936573133 === match$0[1]){var s$0 = match$0[2]; return caml_equal(s, s$0);}
    }
    else{
     var values$1 = _$_[2], match$1 = n[3];
     if(typeof match$1 !== "number" && -744106340 === match$1[1]){
      var
       values$2 = match$1[2],
       _W_ = caml_string_equal(values$1[1], values$2[1]);
      if(_W_){
       var
        _X_ =
          function(attr$0, attr){
           return caml_string_compare(attr$0[1], attr[1]);
          },
        sort = caml_call1(Stdlib_List[59], _X_),
        _Y_ = caml_call1(sort, values$2[2]),
        _Z_ = caml_equal(caml_call1(sort, values$1[2]), _Y_);
       if(_Z_) return equal_children(values$1[3], values$2[3]);
       var ___ = _Z_;
      }
      else
       var ___ = _W_;
      return ___;
     }
    }
    return 0;
   }
   function equal(n$0, n){
    var _S_ = forget_type(n), _T_ = forget_type(n$0);
    function _U_(s){return s;}
    return equal_general
            (function(_V_){return normalize_children(_U_, _V_);}, _T_, _S_);
   }
   function equal_modulo_whitespace(n$0, n){
    var _P_ = forget_type(n), _Q_ = forget_type(n$0);
    return equal_general
            (function(_R_){return normalize_children(trim, _R_);}, _Q_, _P_);
   }
   function mutate_child_list(f, node){
    var match = node[3], _O_ = match[1];
    if(-188437701 === _O_){
     var values = match[2];
     values[1] = caml_call1(f, values[1]);
     return 0;
    }
    if(936573133 <= _O_)
     return caml_call1(Stdlib[2], cst_Soup_mutate_child_list_nod);
    var values$0 = match[2];
    values$0[3] = caml_call1(f, values$0[3]);
    return 0;
   }
   function delete$0(node){
    var match = node[2];
    if(! match) return 0;
    var parent = match[1];
    function _N_(child){return child !== forget_type(node) ? 1 : 0;}
    mutate_child_list(caml_call1(Stdlib_List[44], _N_), parent);
    node[2] = 0;
    return 0;
   }
   function insert_at_index(k, element, node){
    var element$0 = forget_type(element), node$0 = forget_type(node);
    delete$0(node$0);
    if(is_document(node$0)){
     var
      children$0 = to_list(children(node$0)),
      _I_ = function(child){child[2] = 0; return 0;};
     caml_call1(caml_call1(Stdlib_List[18], _I_), children$0);
     mutate_child_list(function(param){return 0;}, node$0);
     var nodes = children$0;
    }
    else
     var nodes = [0, node$0, 0];
    mutate_child_list
     (function(l){
       var prefix = 0, index = 1, param = l;
       for(;;){
        if(! param){
         var _M_ = caml_call1(Stdlib_List[10], prefix);
         return caml_call2(Stdlib[37], _M_, nodes);
        }
        var l$0 = param[2], x = param[1];
        if(k <= index){
         var
          _K_ = caml_call2(Stdlib[37], nodes, [0, x, l$0]),
          _L_ = caml_call1(Stdlib_List[10], prefix);
         return caml_call2(Stdlib[37], _L_, _K_);
        }
        var
         index$0 = index + 1 | 0,
         prefix$0 = [0, x, prefix],
         prefix = prefix$0,
         index = index$0,
         param = l$0;
       }
      },
      element$0);
    function _J_(node){node[2] = [0, element$0]; return 0;}
    return caml_call1(caml_call1(Stdlib_List[18], _J_), nodes);
   }
   function append_child(element, node){
    return insert_at_index(count(children(element)) + 1 | 0, element, node);
   }
   function prepend_child(element, node){
    return insert_at_index(1, element, node);
   }
   function insert_before(target, node){
    var
     _H_ = require_internal(cst_Soup_insert_before_target_, parent(target));
    return insert_at_index(index_of(target), _H_, node);
   }
   function insert_after(target, node){
    var
     _G_ = require_internal(cst_Soup_insert_after_target_n, parent(target));
    return insert_at_index(index_of(target) + 1 | 0, _G_, node);
   }
   function clear(node){
    return mutate_child_list
            (function(children){
              function _F_(child){child[2] = 0; return 0;}
              caml_call1(caml_call1(Stdlib_List[18], _F_), children);
              return 0;
             },
             node);
   }
   function replace(target, node){
    delete$0(node);
    var
     parent$0 =
       require_internal(cst_Soup_replace_target_node_h, parent(target)),
     index = index_of(target);
    delete$0(target);
    return insert_at_index(index, parent$0, node);
   }
   function swap(target, element){
    var
     target_children = require_internal(internal, child_list(target)),
     element_children = require_internal(internal, child_list(element));
    function _D_(child){child[2] = [0, element]; return 0;}
    caml_call1(caml_call1(Stdlib_List[18], _D_), target_children);
    function _E_(child){child[2] = [0, target]; return 0;}
    caml_call1(caml_call1(Stdlib_List[18], _E_), element_children);
    mutate_child_list(function(param){return element_children;}, target);
    mutate_child_list(function(param){return target_children;}, element);
    return replace(target, element);
   }
   function wrap(target, element){
    delete$0(element);
    clear(element);
    replace(target, element);
    return append_child(element, target);
   }
   function unwrap(node){
    var
     parent$0 = require_internal(cst_Soup_unwrap_node_has_no_pa, parent(node)),
     index = index_of(node);
    delete$0(node);
    var match = child_list(node);
    if(match) var l = match[1], children = l; else var children = 0;
    try{clear(node);}
    catch(_C_){
     var _y_ = caml_wrap_exception(_C_);
     if(_y_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_y_, 0);
    }
    var _z_ = caml_call1(Stdlib_List[10], children);
    function _A_(_B_){return insert_at_index(index, parent$0, _B_);}
    return caml_call1(caml_call1(Stdlib_List[18], _A_), _z_);
   }
   function append_root(document, node){
    delete$0(node);
    mutate_child_list
     (function(f){
       var _x_ = [0, forget_type(node), 0];
       return caml_call2(Stdlib[37], f, _x_);
      },
      document);
    node[2] = [0, document];
    return 0;
   }
   function prepend_root(document, node){
    delete$0(node);
    mutate_child_list
     (function(f){return [0, forget_type(node), f];}, document);
    node[2] = [0, document];
    return 0;
   }
   function set_name(new_name, param){
    var match = param[3];
    if(typeof match !== "number" && -744106340 === match[1]){
     var e = match[2];
     e[1] = caml_call1(lowercase_ascii, trim(new_name));
     return 0;
    }
    return caml_call1(Stdlib[2], cst_Soup_set_name_internal_err);
   }
   function delete_attribute(name, param){
    var match = param[3];
    if(typeof match !== "number" && -744106340 === match[1]){
     var
      e = match[2],
      _v_ = e[2],
      _w_ =
        function(param){
         var name$0 = param[1];
         return caml_string_notequal(name$0, name);
        };
     e[2] = caml_call1(caml_call1(Stdlib_List[44], _w_), _v_);
     return 0;
    }
    return caml_call1(Stdlib[2], cst_Soup_delete_attribute_inte);
   }
   function set_attribute(name, value, param){
    var match = param[3];
    if(typeof match !== "number" && -744106340 === match[1]){
     var
      e = match[2],
      _t_ = e[2],
      _u_ =
        function(param){
         var name$0 = param[1];
         return caml_string_notequal(name$0, name);
        },
      attributes = caml_call1(caml_call1(Stdlib_List[44], _u_), _t_);
     e[2] = [0, [0, name, value], attributes];
     return 0;
    }
    return caml_call1(Stdlib[2], cst_Soup_set_attribute_interna);
   }
   function set_classes(classes, element){
    var v = caml_call1(caml_call1(concat, cst$6), classes);
    return set_attribute(cst_class$1, v, element);
   }
   function add_class(class$0, element){
    var classes$0 = classes(element);
    return caml_call2(Stdlib_List[37], class$0, classes$0)
            ? 0
            : set_classes([0, class$0, classes$0], element);
   }
   function remove_class(class$0, element){
    var _r_ = classes(element);
    function _s_(c){return caml_string_notequal(c, class$0);}
    var v = caml_call1(caml_call1(Stdlib_List[44], _s_), _r_);
    return v
            ? set_classes(v, element)
            : delete_attribute(cst_class$2, element);
   }
   function create_element$0(id, class$0, classes, opt, inner_text, name){
    if(opt) var sth = opt[1], attributes = sth; else var attributes = 0;
    if(inner_text)
     var s = inner_text[1], children = [0, create_text(s), 0];
    else
     var children = 0;
    var element = create_element(name, 0, children);
    function _q_(param){
     var v = param[2], n = param[1];
     return set_attribute(n, v, element);
    }
    caml_call1(caml_call1(Stdlib_List[18], _q_), attributes);
    if(classes){
     var
      classes$0 = classes[1],
      v = caml_call1(caml_call1(concat, cst$7), classes$0);
     set_attribute(cst_class$3, v, element);
    }
    if(class$0){
     var class$1 = class$0[1];
     set_attribute(cst_class$4, class$1, element);
    }
    if(id){var id$0 = id[1]; set_attribute(cst_id$1, id$0, element);}
    return element;
   }
   function select_one$0(s, n){
    return require_internal(cst_Soup_R_select_one_None, select_one(s, n));
   }
   function attribute$0(s, n){
    return require_internal(cst_Soup_R_attribute_None, attribute(s, n));
   }
   function id$0(n){return require_internal(cst_Soup_R_id_None, id(n));}
   function element$0(n){
    return require_internal(cst_Soup_R_element_None, element(n));
   }
   function leaf_text$0(n){
    return require_internal(cst_Soup_R_leaf_text_None, leaf_text(n));
   }
   function nth$0(n, t){
    return require_internal(cst_Soup_R_nth_None, nth(n, t));
   }
   function first$0(t){
    return require_internal(cst_Soup_R_first_None, first(t));
   }
   function last$0(t){return require_internal(cst_Soup_R_last_None, last(t));}
   function tag$0(s, n){
    return require_internal(cst_Soup_R_tag_None, tag(s, n));
   }
   function parent$0(n){
    return require_internal(cst_Soup_R_parent_None, parent(n));
   }
   function child$0(n){
    return require_internal(cst_Soup_R_child_None, child(n));
   }
   function child_element$0(n){
    return require_internal(cst_Soup_R_child_element_None, child_element(n));
   }
   function next_sibling$0(n){
    return require_internal(cst_Soup_R_next_sibling_None, next_sibling(n));
   }
   function previous_sibling$0(n){
    return require_internal
            (cst_Soup_R_previous_sibling_No, previous_sibling(n));
   }
   function next_element$0(n){
    return require_internal(cst_Soup_R_next_element_None, next_element(n));
   }
   function previous_element$0(n){
    return require_internal
            (cst_Soup_R_previous_element_No, previous_element(n));
   }
   var
    R =
      [0,
       select_one$0,
       attribute$0,
       id$0,
       element$0,
       leaf_text$0,
       nth$0,
       first$0,
       last$0,
       tag$0,
       parent$0,
       child$0,
       child_element$0,
       next_sibling$0,
       previous_sibling$0,
       next_element$0,
       previous_element$0];
   function read_channel(channel){
    var _p_ = caml_call1(Markup[12], channel);
    return caml_call1(Markup[15], _p_);
   }
   function read_file(path){
    var _o_ = caml_call1(Markup[13], path)[1];
    return caml_call1(Markup[15], _o_);
   }
   var write_channel = Stdlib[66];
   function write_file(path, data){
    var _n_ = caml_call1(Markup[10], data);
    return caml_call1(caml_call1(Markup[18], path), _n_);
   }
   var
    Soup =
      [0,
       parse,
       Parse_error,
       select,
       select_one,
       symbol$1,
       symbol$0,
       symbol,
       Infix,
       matches_selector$0,
       require,
       R,
       with_stop,
       name,
       attribute,
       classes,
       id,
       has_attribute,
       fold_attributes,
       coerce,
       element,
       elements,
       texts,
       trimmed_texts,
       leaf_text,
       children,
       descendants,
       ancestors,
       siblings,
       next_siblings,
       previous_siblings,
       fold,
       filter,
       map,
       filter_map,
       flatten,
       iter,
       rev,
       to_list,
       nth,
       first,
       last,
       count,
       index_of,
       index_of_element,
       tags,
       tag,
       parent,
       is_root,
       is_document,
       is_element,
       is_text,
       child,
       child_element,
       next_sibling,
       previous_sibling,
       next_element,
       previous_element,
       no_children,
       at_most_one_child,
       to_string,
       pretty_print,
       signals,
       from_signals$0,
       equal,
       equal_modulo_whitespace,
       create_element$0,
       create_text,
       create_soup,
       append_child,
       prepend_child,
       insert_at_index,
       insert_before,
       insert_after,
       delete$0,
       clear,
       replace,
       swap,
       wrap,
       unwrap,
       append_root,
       prepend_root,
       set_name,
       set_attribute,
       delete_attribute,
       add_class,
       remove_class,
       read_file,
       read_channel,
       write_file,
       write_channel];
   runtime.caml_register_global(135, Soup, "Soup");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lambdasoup
//# unitInfo: Requires: Soup
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Soup = global_data.Soup,
    parse = Soup[1],
    Parse_error = Soup[2],
    select = Soup[3],
    select_one = Soup[4],
    symbol = Soup[5],
    symbol$0 = Soup[6],
    symbol$1 = Soup[7],
    Infix = Soup[8],
    matches_selector = Soup[9],
    require = Soup[10],
    R = Soup[11],
    with_stop = Soup[12],
    name = Soup[13],
    attribute = Soup[14],
    classes = Soup[15],
    id = Soup[16],
    has_attribute = Soup[17],
    fold_attributes = Soup[18],
    coerce = Soup[19],
    element = Soup[20],
    elements = Soup[21],
    texts = Soup[22],
    trimmed_texts = Soup[23],
    leaf_text = Soup[24],
    children = Soup[25],
    descendants = Soup[26],
    ancestors = Soup[27],
    siblings = Soup[28],
    next_siblings = Soup[29],
    previous_siblings = Soup[30],
    fold = Soup[31],
    filter = Soup[32],
    map = Soup[33],
    filter_map = Soup[34],
    flatten = Soup[35],
    iter = Soup[36],
    rev = Soup[37],
    to_list = Soup[38],
    nth = Soup[39],
    first = Soup[40],
    last = Soup[41],
    count = Soup[42],
    index_of = Soup[43],
    index_of_element = Soup[44],
    tags = Soup[45],
    tag = Soup[46],
    parent = Soup[47],
    is_root = Soup[48],
    is_document = Soup[49],
    is_element = Soup[50],
    is_text = Soup[51],
    child = Soup[52],
    child_element = Soup[53],
    next_sibling = Soup[54],
    previous_sibling = Soup[55],
    next_element = Soup[56],
    previous_element = Soup[57],
    no_children = Soup[58],
    at_most_one_child = Soup[59],
    to_string = Soup[60],
    pretty_print = Soup[61],
    signals = Soup[62],
    from_signals = Soup[63],
    equal = Soup[64],
    equal_modulo_whitespace = Soup[65],
    create_element = Soup[66],
    create_text = Soup[67],
    create_soup = Soup[68],
    append_child = Soup[69],
    prepend_child = Soup[70],
    insert_at_index = Soup[71],
    insert_before = Soup[72],
    insert_after = Soup[73],
    delete$0 = Soup[74],
    clear = Soup[75],
    replace = Soup[76],
    swap = Soup[77],
    wrap = Soup[78],
    unwrap = Soup[79],
    append_root = Soup[80],
    prepend_root = Soup[81],
    set_name = Soup[82],
    set_attribute = Soup[83],
    delete_attribute = Soup[84],
    add_class = Soup[85],
    remove_class = Soup[86],
    read_file = Soup[87],
    read_channel = Soup[88],
    write_file = Soup[89],
    write_channel = Soup[90],
    Lambdasoup =
      [0,
       Parse_error,
       select,
       select_one,
       symbol,
       symbol$0,
       symbol$1,
       Infix,
       matches_selector,
       require,
       R,
       with_stop,
       name,
       attribute,
       classes,
       id,
       has_attribute,
       fold_attributes,
       coerce,
       element,
       elements,
       texts,
       trimmed_texts,
       leaf_text,
       children,
       descendants,
       ancestors,
       siblings,
       next_siblings,
       previous_siblings,
       fold,
       filter,
       map,
       filter_map,
       flatten,
       iter,
       rev,
       to_list,
       nth,
       first,
       last,
       count,
       index_of,
       index_of_element,
       tags,
       tag,
       parent,
       is_root,
       is_document,
       is_element,
       is_text,
       child,
       child_element,
       next_sibling,
       previous_sibling,
       next_element,
       previous_element,
       no_children,
       at_most_one_child,
       to_string,
       pretty_print,
       signals,
       from_signals,
       equal,
       equal_modulo_whitespace,
       create_element,
       create_text,
       create_soup,
       append_child,
       prepend_child,
       insert_at_index,
       insert_before,
       insert_after,
       delete$0,
       clear,
       replace,
       swap,
       wrap,
       unwrap,
       append_root,
       prepend_root,
       set_name,
       set_attribute,
       delete_attribute,
       add_class,
       remove_class,
       read_file,
       read_channel,
       write_file,
       write_channel,
       parse];
   runtime.caml_register_global(1, Lambdasoup, "Lambdasoup");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzb3VwLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJpbnRlcm5hbCIsIndoaXRlc3BhY2UiLCJ0cmltIiwicyIsInByZWZpeF9sZW5ndGgiLCJpbmRleCIsInMkMCIsInN1ZmZpeF9sZW5ndGgiLCJyaW5kZXgiLCJyZXF1aXJlX2ludGVybmFsIiwibWVzc2FnZSIsInYiLCJyZXF1aXJlIiwiZm9yZ2V0X3R5cGUiLCJuIiwiY29lcmNlIiwibm9kZSIsImNyZWF0ZV9lbGVtZW50IiwibmFtZSIsImF0dHJpYnV0ZXMiLCJjaGlsZHJlbiIsInZhbHVlcyIsImNoaWxkIiwiY3JlYXRlX3RleHQiLCJ0ZXh0IiwiY3JlYXRlX2RvY3VtZW50IiwiZG9jdHlwZSIsInJvb3RzIiwicm9vdCIsImNyZWF0ZV9zb3VwIiwiZnJvbV9zaWduYWxzIiwibWFwX2F0dHJpYnV0ZXMiLCJzaWduYWxzIiwiZCIsIm5zIiwiYXR0cmlidXRlcyQwIiwic3MiLCJhIiwiZnJvbV9zaWduYWxzJDAiLCJwYXJzZSIsImJvZHlfYXR0cmlidXRlcyIsInJlcG9ydCIsImwiLCJlIiwiaXNfZG9jdW1lbnQiLCJpc19lbGVtZW50IiwiaXNfdGV4dCIsImVsZW1lbnQiLCJuZXh0Iiwid2l0aF9zdG9wIiwiZiIsInJlc3VsdCIsImN1cnJlbnQiLCJzdG9wIiwiaWQiLCJmb2xkX2F0dHJpYnV0ZXMiLCJpbml0IiwidmFsdWUiLCJhdHRyaWJ1dGUiLCJuYW1lJDAiLCJoYXNfYXR0cmlidXRlIiwic3BsaXRfYXR0cmlidXRlIiwidnMiLCJtYXliZV9pbmRleCIsImluZGV4JDAiLCJpbmRleCQxIiwidnMkMCIsImluZGV4JDIiLCJjbGFzc2VzIiwiZW1wdHkiLCJmb2xkIiwic2VxdWVuY2UiLCJmaWx0ZXJfbWFwIiwiZiQwIiwibm9kZSQwIiwiZmlsdGVyIiwibWFwIiwiZmxhdHRlbiIsIml0ZXIiLCJudGgiLCJmaXJzdCIsImxhc3QiLCJjb3VudCIsInRvX2xpc3QiLCJyZXYiLCJlbGVtZW50cyIsImVsZW1lbnQkMCIsImNoaWxkX2xpc3QiLCJkZXNjZW5kYW50cyIsImNoaWxkX2VsZW1lbnQiLCJzaW1wbGVfcGFyZW50IiwicGFyZW50IiwiZ2VuZXJhbF9hbmNlc3RvcnMiLCJnZXRfcGFyZW50IiwiYW5jZXN0b3JzIiwic2libGluZ3MiLCJzaWJsaW5nX2xpc3RzIiwiZnVuY3Rpb25fbmFtZSIsInNlbGVjdCIsInByZWZpeCIsInN1ZmZpeCIsInUiLCJsaXN0cyIsIm5leHRfc2libGluZ3MiLCJwcmV2aW91c19zaWJsaW5ncyIsIm5leHRfc2libGluZyIsInByZXZpb3VzX3NpYmxpbmciLCJuZXh0X2VsZW1lbnQiLCJwcmV2aW91c19lbGVtZW50IiwiaW5kZXhfb2YiLCJpbmRleF9vZl9lbGVtZW50IiwiYXRfbW9zdF9uX2NoaWxkcmVuIiwibm9fY2hpbGRyZW4iLCJhdF9tb3N0X29uZV9jaGlsZCIsImlzX3Jvb3QiLCJ0YWdzIiwibmFtZSQxIiwidGFnIiwibm9ybWFsaXplX2NoaWxkcmVuIiwicmVzdCIsInByZWZpeCQyIiwicyQxIiwibGVhZl90ZXh0IiwidHJpbSQwIiwibm9kZSQxIiwidGV4dHMiLCJ0cmltbWVkX3RleHRzIiwiaGFzX3ByZWZpeCIsImhhc19zdWJzdHJpbmciLCJzdWJzdHJpbmdfbGVuZ3RoIiwiZWxlbWVudF9jb3VudCIsImVsZW1lbnRfY291bnRfd2l0aF9uYW1lIiwiZWxlbWVudF9pbmRleF93aXRoX25hbWUiLCJjb25kaXRpb25hbF9tb2QiLCJtYXRjaGVzX3NpbXBsZV9zZWxlY3RvciIsIm5hbWUkOCIsImF0dHJpYnV0ZV9zZWxlY3RvciIsImNhcHR1cmVkIiwidmFsdWUkMCIsIm5hbWUkMiIsInZhbHVlJDEiLCJuYW1lJDMiLCJ2YWx1ZSQ0IiwidmFsdWUkMiIsIm5hbWUkNCIsIm5hbWUkNSIsInZhbHVlJDMiLCJuYW1lJDYiLCJwc2V1ZG9fY2xhc3Nfc2VsZWN0b3IiLCJiIiwiYiQwIiwiYSQwIiwiZWxlbWVudF9jb3VudCQwIiwiYiQxIiwiYSQxIiwiYiQyIiwiYSQyIiwibmFtZSQ3IiwiZWxlbWVudF9jb3VudCQxIiwic2VsZWN0b3IiLCJkZXNjZW5kYW50Iiwic2VsZWN0b3IkMCIsInVwX3RvIiwidiQwIiwib25lIiwibWF0Y2hlc19zZWxlY3RvciIsInJvb3Rfbm9kZSIsImF0X25vZGUiLCJiYWNrd2FyZHNfdHJhdmVyc2FsIiwic2ltcGxlX3NlbGVjdG9ycyIsImNvbWJpbmF0b3IiLCJuZXh0X25vZGVzIiwiaXNfZGVjaW1hbF9jaGFyIiwiYyIsImlzX2hleGFkZWNpbWFsX2NoYXIiLCJpc19pZGVudGlmaWVyX2NoYXIiLCJjJDAiLCJwYXJzZV9lcnJvciIsIm1zZyIsInBhcnNlX2lkZW50aWZpZXIiLCJzdHJlYW0iLCJidWZmZXIiLCJjJDEiLCJjJDIiLCJjb3VudCQwIiwicGFyc2VfcXVvdGVkX3N0cmluZyIsImRlbGltIiwiY29uc3VtZV93aGl0ZXNwYWNlIiwicGFyc2VfbnVtYmVyIiwicGFyc2VfbW9kdWxhcl9wYXR0ZXJuX3RhaWwiLCJwYXJzZV9tb2R1bGFyX3BhdHRlcm4iLCJwYXJzZV9wYXJlbnRoZXNpemVkX3ZhbHVlIiwicGFyc2Vfc2ltcGxlX3NlbGVjdG9yIiwiZnVuY3Rpb24kMCIsIm9wZXJhdG9yIiwicGFyc2UkMCIsInNlbGVjdG9ycyQyIiwic2VsZWN0b3JzJDEiLCJzZWxlY3RvcnMiLCJzZWxlY3RvcnMkMCIsInNlbGVjdG9ycyQzIiwibWF0Y2hlc19zZWxlY3RvciQwIiwicm9vdF9ub2RlJDAiLCJjYW5kaWRhdGVzIiwic2VsZWN0X29uZSIsInN5bWJvbCIsInN5bWJvbCQwIiwic3ltYm9sJDEiLCJyb290JDAiLCJ0cmF2ZXJzZSIsImFjYyIsImRvY3R5cGUkMCIsImFjYyQwIiwidHJhdmVyc2VfbGlzdCIsInN0YXJ0X3NpZ25hbCIsInByZXR0eV9wcmludCIsInRvX3N0cmluZyIsImVxdWFsX2dlbmVyYWwiLCJuJDAiLCJlcXVhbF9jaGlsZHJlbiIsImNoaWxkcmVuJDAiLCJjaGlsZHJlbiQxIiwiY2hpbGRyZW4kMiIsInZhbHVlcyQwIiwidmFsdWVzJDEiLCJ2YWx1ZXMkMiIsImF0dHIkMCIsImF0dHIiLCJzb3J0IiwiZXF1YWwiLCJlcXVhbF9tb2R1bG9fd2hpdGVzcGFjZSIsIm11dGF0ZV9jaGlsZF9saXN0IiwiZGVsZXRlJDAiLCJpbnNlcnRfYXRfaW5kZXgiLCJrIiwibm9kZXMiLCJsJDAiLCJ4IiwiYXBwZW5kX2NoaWxkIiwicHJlcGVuZF9jaGlsZCIsImluc2VydF9iZWZvcmUiLCJ0YXJnZXQiLCJpbnNlcnRfYWZ0ZXIiLCJjbGVhciIsInJlcGxhY2UiLCJwYXJlbnQkMCIsInN3YXAiLCJ0YXJnZXRfY2hpbGRyZW4iLCJlbGVtZW50X2NoaWxkcmVuIiwid3JhcCIsInVud3JhcCIsImFwcGVuZF9yb290IiwiZG9jdW1lbnQiLCJwcmVwZW5kX3Jvb3QiLCJzZXRfbmFtZSIsIm5ld19uYW1lIiwiZGVsZXRlX2F0dHJpYnV0ZSIsInNldF9hdHRyaWJ1dGUiLCJzZXRfY2xhc3NlcyIsImFkZF9jbGFzcyIsImNsYXNzJDAiLCJjbGFzc2VzJDAiLCJyZW1vdmVfY2xhc3MiLCJjcmVhdGVfZWxlbWVudCQwIiwib3B0IiwiaW5uZXJfdGV4dCIsInN0aCIsImNsYXNzJDEiLCJpZCQwIiwic2VsZWN0X29uZSQwIiwiYXR0cmlidXRlJDAiLCJsZWFmX3RleHQkMCIsIm50aCQwIiwidCIsImZpcnN0JDAiLCJsYXN0JDAiLCJ0YWckMCIsImNoaWxkJDAiLCJjaGlsZF9lbGVtZW50JDAiLCJuZXh0X3NpYmxpbmckMCIsInByZXZpb3VzX3NpYmxpbmckMCIsIm5leHRfZWxlbWVudCQwIiwicHJldmlvdXNfZWxlbWVudCQwIiwicmVhZF9jaGFubmVsIiwiY2hhbm5lbCIsInJlYWRfZmlsZSIsInBhdGgiLCJ3cml0ZV9jaGFubmVsIiwid3JpdGVfZmlsZSIsImRhdGEiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9sYW1iZGFzb3VwL3NvdXAubWwiXSwibWFwcGluZ3MiOiI7Ozs7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Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTGFtYmRhIFNvdXAsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlXG4gICBMSUNFTlNFLm1kIGZvciBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vYWFudHJvbi9sYW1iZGFzb3VwLiAqKVxuXG5tb2R1bGUgU3RyaW5nID1cbnN0cnVjdFxuICBpbmNsdWRlIFN0cmluZ1xuXG4gIGxldCB0cmltID1cbiAgICBsZXQgd2hpdGVzcGFjZSA9IFwiIFxcdFxcblxcclwiIGluXG4gICAgZnVuIHMgLT5cbiAgICAgIGxldCByZWMgbWVhc3VyZV9wcmVmaXggaW5kZXggPVxuICAgICAgICBpZiBpbmRleCA9IFN0cmluZy5sZW5ndGggcyB0aGVuIGluZGV4XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpZiBTdHJpbmcuY29udGFpbnMgd2hpdGVzcGFjZSBzLltpbmRleF0gdGhlblxuICAgICAgICAgICAgbWVhc3VyZV9wcmVmaXggKGluZGV4ICsgMSlcbiAgICAgICAgICBlbHNlIGluZGV4XG4gICAgICBpblxuICAgICAgbGV0IHByZWZpeF9sZW5ndGggPSBtZWFzdXJlX3ByZWZpeCAwIGluXG4gICAgICBsZXQgcyA9IFN0cmluZy5zdWIgcyBwcmVmaXhfbGVuZ3RoIChTdHJpbmcubGVuZ3RoIHMgLSBwcmVmaXhfbGVuZ3RoKSBpblxuXG4gICAgICBsZXQgcmVjIG1lYXN1cmVfc3VmZml4IHJpbmRleCA9XG4gICAgICAgIGlmIHJpbmRleCA9IFN0cmluZy5sZW5ndGggcyB0aGVuIHJpbmRleFxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgU3RyaW5nLmNvbnRhaW5zIHdoaXRlc3BhY2Ugcy5bU3RyaW5nLmxlbmd0aCBzIC0gcmluZGV4IC0gMV0gdGhlblxuICAgICAgICAgICAgbWVhc3VyZV9zdWZmaXggKHJpbmRleCArIDEpXG4gICAgICAgICAgZWxzZSByaW5kZXhcbiAgICAgIGluXG4gICAgICBsZXQgc3VmZml4X2xlbmd0aCA9IG1lYXN1cmVfc3VmZml4IDAgaW5cbiAgICAgIFN0cmluZy5zdWIgcyAwIChTdHJpbmcubGVuZ3RoIHMgLSBzdWZmaXhfbGVuZ3RoKVxuZW5kXG5cbnR5cGUgZWxlbWVudCA9IHVuaXRcbnR5cGUgZ2VuZXJhbCA9IHVuaXRcbnR5cGUgc291cCA9IHVuaXRcblxudHlwZSBlbGVtZW50X3ZhbHVlcyA9XG4gIHttdXRhYmxlIG5hbWUgICAgICAgOiBzdHJpbmc7XG4gICBtdXRhYmxlIGF0dHJpYnV0ZXMgOiAoc3RyaW5nICogc3RyaW5nKSBsaXN0O1xuICAgbXV0YWJsZSBjaGlsZHJlbiAgIDogZ2VuZXJhbCBub2RlIGxpc3R9XG5cbmFuZCBkb2N1bWVudF92YWx1ZXMgPVxuICB7bXV0YWJsZSByb290cyA6IGdlbmVyYWwgbm9kZSBsaXN0O1xuICAgZG9jdHlwZSA6IE1hcmt1cC5kb2N0eXBlIG9wdGlvbn1cblxuYW5kICdhIG5vZGUgPVxuICB7bXV0YWJsZSBzZWxmICAgOiAnYi4gJ2Igbm9kZSBvcHRpb247XG4gICBtdXRhYmxlIHBhcmVudCA6IGdlbmVyYWwgbm9kZSBvcHRpb247XG4gICB2YWx1ZXMgICAgICAgICA6IFsgYEVsZW1lbnQgb2YgZWxlbWVudF92YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgfCBgVGV4dCBvZiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgfCBgRG9jdW1lbnQgb2YgZG9jdW1lbnRfdmFsdWVzIF19XG5cbmxldCByZXF1aXJlX2ludGVybmFsIG1lc3NhZ2UgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gZmFpbHdpdGggbWVzc2FnZVxuICB8IFNvbWUgdiAtPiB2XG5cbmxldCByZXF1aXJlID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwicmVxdWlyZTogYXJndW1lbnQgaXMgTm9uZVwiXG4gIHwgU29tZSB2IC0+IHZcblxubGV0IGZvcmdldF90eXBlIDogKF8gbm9kZSkgLT4gKF8gbm9kZSkgPVxuICBmdW4gbiAtPlxuICAgIHJlcXVpcmVfaW50ZXJuYWxcbiAgICAgIFwiU291cC5fZm9yZ2V0X3R5cGU6IGludGVybmFsIGVycm9yOiBub2RlJ3Mgc2VsZiByZWZlcmVuY2Ugbm90IHNldFwiXG4gICAgICBuLnNlbGZcblxubGV0IGNvZXJjZSBub2RlID0gZm9yZ2V0X3R5cGUgbm9kZVxuXG5sZXQgY3JlYXRlX2VsZW1lbnQgbmFtZSBhdHRyaWJ1dGVzIGNoaWxkcmVuID1cbiAgbGV0IHZhbHVlcyA9IHtuYW1lOyBhdHRyaWJ1dGVzOyBjaGlsZHJlbn0gaW5cbiAgbGV0IG5vZGUgPSB7c2VsZiA9IE5vbmU7IHBhcmVudCA9IE5vbmU7IHZhbHVlcyA9IGBFbGVtZW50IHZhbHVlc30gaW5cbiAgbm9kZS5zZWxmIDwtIFNvbWUgbm9kZTtcbiAgY2hpbGRyZW4gfD4gTGlzdC5pdGVyIChmdW4gY2hpbGQgLT4gY2hpbGQucGFyZW50IDwtIFNvbWUgbm9kZSk7XG4gIG5vZGVcblxubGV0IGNyZWF0ZV90ZXh0IHRleHQgPVxuICBsZXQgbm9kZSA9IHtzZWxmID0gTm9uZTsgcGFyZW50ID0gTm9uZTsgdmFsdWVzID0gYFRleHQgdGV4dH0gaW5cbiAgbm9kZS5zZWxmIDwtIFNvbWUgbm9kZTtcbiAgbm9kZVxuXG5sZXQgY3JlYXRlX2RvY3VtZW50IGRvY3R5cGUgcm9vdHMgPVxuICBsZXQgbm9kZSA9XG4gICAge3NlbGYgPSBOb25lOyBwYXJlbnQgPSBOb25lOyB2YWx1ZXMgPSBgRG9jdW1lbnQge3Jvb3RzOyBkb2N0eXBlfX0gaW5cbiAgbm9kZS5zZWxmIDwtIFNvbWUgbm9kZTtcbiAgcm9vdHMgfD4gTGlzdC5pdGVyIChmdW4gcm9vdCAtPiByb290LnBhcmVudCA8LSBTb21lIG5vZGUpO1xuICBub2RlXG5cbmxldCBjcmVhdGVfc291cCAoKSA9IGNyZWF0ZV9kb2N1bWVudCBOb25lIFtdXG5cbmxldCBmcm9tX3NpZ25hbHMnIH5tYXBfYXR0cmlidXRlcyBzaWduYWxzID1cbiAgbGV0IGRvY3R5cGUgPSByZWYgTm9uZSBpblxuICBzaWduYWxzXG4gIHw+IE1hcmt1cC5tYXAgKGZ1biBzIC0+XG4gICAgYmVnaW4gbWF0Y2ggcyB3aXRoXG4gICAgfCBgRG9jdHlwZSBkIC0+IGRvY3R5cGUgOj0gU29tZSBkXG4gICAgfCBfIC0+ICgpXG4gICAgZW5kO1xuICAgIHMpXG4gIHw+IChmdW4gcyAtPiBNYXJrdXAudHJlZXNcbiAgICB+dGV4dDooZnVuIHNzIC0+IGNyZWF0ZV90ZXh0IChTdHJpbmcuY29uY2F0IFwiXCIgc3MpKVxuICAgIH5lbGVtZW50OihmdW4gbmFtZSBhdHRyaWJ1dGVzIGNoaWxkcmVuIC0+XG4gICAgICBsZXQgYXR0cmlidXRlcyA9XG4gICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgfD4gTGlzdC5tYXAgKGZ1biAoKG5zLCBuKSwgdikgLT5cbiAgICAgICAgICBtYXRjaCBucyB3aXRoXG4gICAgICAgICAgfCBcIlwiIC0+IChuLCB2KVxuICAgICAgICAgIHwgXyAtPiAobnMgXiBcIjpcIiBeIG4sIHYpKVxuICAgICAgICB8PiBtYXBfYXR0cmlidXRlcyBuYW1lIGluXG4gICAgICBjcmVhdGVfZWxlbWVudCAoc25kIG5hbWUpIGF0dHJpYnV0ZXMgY2hpbGRyZW4pXG4gICAgcylcbiAgfD4gTWFya3VwLnRvX2xpc3RcbiAgfD4gY3JlYXRlX2RvY3VtZW50ICFkb2N0eXBlXG5cbmxldCBmcm9tX3NpZ25hbHMgPVxuICBmcm9tX3NpZ25hbHMnIH5tYXBfYXR0cmlidXRlczooZnVuIF9uIGEgLT4gYSlcblxubGV0IHBhcnNlIHRleHQgPVxuICBsZXQgYm9keV9hdHRyaWJ1dGVzID0gcmVmIFtdIGluXG4gIGxldCByZXBvcnQgX2wgZSA9XG4gICAgbWF0Y2ggZSB3aXRoXG4gICAgfCBgTWlzbmVzdGVkX3RhZyAoXCJib2R5XCIsIF8sIGF0dHJpYnV0ZXMpIC0+XG4gICAgICBib2R5X2F0dHJpYnV0ZXMgOj0gIWJvZHlfYXR0cmlidXRlcyBAIGF0dHJpYnV0ZXNcbiAgICB8IF8gLT4gKCkgaW5cbiAgdGV4dFxuICB8PiBNYXJrdXAuc3RyaW5nXG4gIHw+IChmdW4gcyAtPiBNYXJrdXAucGFyc2VfaHRtbCB+cmVwb3J0IHMpXG4gIHw+IE1hcmt1cC5zaWduYWxzXG4gIHw+IGZyb21fc2lnbmFscydcbiAgICB+bWFwX2F0dHJpYnV0ZXM6KGZ1biBuYW1lIGF0dHJpYnV0ZXMgLT5cbiAgICAgIG1hdGNoIG5hbWUgd2l0aFxuICAgICAgfCBucywgXCJib2R5XCIgd2hlbiBucyA9IE1hcmt1cC5Ocy5odG1sIC0+XG4gICAgICAgIExpc3QuZm9sZF9sZWZ0IChmdW4gYXR0cmlidXRlcyAobiwgdikgLT5cbiAgICAgICAgICBtYXRjaCBMaXN0Lm1lbV9hc3NvYyBuIGF0dHJpYnV0ZXMgd2l0aFxuICAgICAgICAgIHwgdHJ1ZSAtPiBhdHRyaWJ1dGVzXG4gICAgICAgICAgfCBmYWxzZSAtPiAobiwgdik6OmF0dHJpYnV0ZXNcbiAgICAgICAgKSBhdHRyaWJ1dGVzICFib2R5X2F0dHJpYnV0ZXNcbiAgICAgIHwgXyAtPiBhdHRyaWJ1dGVzKVxuXG5sZXQgaXNfZG9jdW1lbnQgbm9kZSA9XG4gIG1hdGNoIG5vZGUudmFsdWVzIHdpdGhcbiAgfCBgRWxlbWVudCBfIC0+IGZhbHNlXG4gIHwgYFRleHQgXyAtPiBmYWxzZVxuICB8IGBEb2N1bWVudCBfIC0+IHRydWVcblxubGV0IGlzX2VsZW1lbnQgbm9kZSA9XG4gIG1hdGNoIG5vZGUudmFsdWVzIHdpdGhcbiAgfCBgRWxlbWVudCBfIC0+IHRydWVcbiAgfCBgVGV4dCBfIC0+IGZhbHNlXG4gIHwgYERvY3VtZW50IF8gLT4gZmFsc2VcblxubGV0IGlzX3RleHQgbm9kZSA9XG4gIG1hdGNoIG5vZGUudmFsdWVzIHdpdGhcbiAgfCBgVGV4dCBfIC0+IHRydWVcbiAgfCBgRWxlbWVudCBfIC0+IGZhbHNlXG4gIHwgYERvY3VtZW50IF8gLT4gZmFsc2VcblxubGV0IGVsZW1lbnQgbm9kZSA9XG4gIGlmIGlzX2VsZW1lbnQgbm9kZSB0aGVuIFNvbWUgKGZvcmdldF90eXBlIG5vZGUpIGVsc2UgTm9uZVxuXG50eXBlICdhIHN0b3AgPSB7dGhyb3cgOiAnYi4gJ2EgLT4gJ2J9XG5cbmV4Y2VwdGlvbiBTdG9wIG9mIGludDY0XG5cbmxldCBnZW5lcmF0ZV9pZCA9XG4gIGxldCBuZXh0ID0gcmVmIDBMIGluXG4gIGZ1biAoKSAtPlxuICAgIGxldCBjdXJyZW50ID0gIW5leHQgaW5cbiAgICBuZXh0IDo9IEludDY0LnN1Y2MgY3VycmVudDtcbiAgICBjdXJyZW50XG5cbmxldCB3aXRoX3N0b3AgZiA9XG4gIGxldCByZXN1bHQgPSByZWYgTm9uZSBpblxuICBsZXQgaWQgPSBnZW5lcmF0ZV9pZCAoKSBpblxuICBsZXQgc3RvcCA9IHt0aHJvdyA9IGZ1biB2IC0+IHJlc3VsdCA6PSBTb21lIHY7IHJhaXNlX25vdHJhY2UgKFN0b3AgaWQpfSBpblxuICB0cnkgZiBzdG9wXG4gIHdpdGggU3RvcCBpZCcgd2hlbiBpZCcgPSBpZCAtPlxuICAgIG1hdGNoICFyZXN1bHQgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgZmFpbHdpdGggXCJTb3VwLndpdGhfc3RvcDogaW50ZXJuYWwgZXJyb3I6ICFyZXN1bHQgPSBOb25lXCIgW0Bjb3ZlcmFnZSBvZmZdXG4gICAgfCBTb21lIHYgLT4gdlxuXG5sZXQgbmFtZSA9IGZ1bmN0aW9uXG4gIHwge3ZhbHVlcyA9IGBFbGVtZW50IHtuYW1lOyBffTsgX30gLT4gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBuYW1lXG4gIHwgXyAtPiBmYWlsd2l0aCBcIlNvdXAubmFtZTogaW50ZXJuYWwgZXJyb3I6IG5vdCBhbiBlbGVtZW50XCIgW0Bjb3ZlcmFnZSBvZmZdXG5cbmxldCBmb2xkX2F0dHJpYnV0ZXMgZiBpbml0ID0gZnVuY3Rpb25cbiAgfCB7dmFsdWVzID0gYEVsZW1lbnQge2F0dHJpYnV0ZXM7IF99OyBffSAtPlxuICAgIGF0dHJpYnV0ZXMgfD4gTGlzdC5mb2xkX2xlZnQgKGZ1biB2IChuYW1lLCB2YWx1ZSkgLT4gZiB2IG5hbWUgdmFsdWUpIGluaXRcbiAgfCBfIC0+XG4gICAgZmFpbHdpdGggXCJTb3VwLmZvbGRfYXR0cmlidXRlczogaW50ZXJuYWwgZXJyb3I6IG5vdCBhbiBlbGVtZW50XCJcbiAgICAgIFtAY292ZXJhZ2Ugb2ZmXVxuXG5sZXQgYXR0cmlidXRlIG5hbWUgbm9kZSA9XG4gIHdpdGhfc3RvcCAoZnVuIHN0b3AgLT5cbiAgICBub2RlIHw+IGZvbGRfYXR0cmlidXRlcyAoZnVuIF8gbmFtZScgdmFsdWUgLT5cbiAgICAgIGlmIG5hbWUnID0gbmFtZSB0aGVuIHN0b3AudGhyb3cgKFNvbWUgdmFsdWUpIGVsc2UgTm9uZSlcbiAgICAgIE5vbmUpXG5cbmxldCBoYXNfYXR0cmlidXRlIG5hbWUgbm9kZSA9XG4gIG1hdGNoIGF0dHJpYnV0ZSBuYW1lIG5vZGUgd2l0aFxuICB8IE5vbmUgLT4gZmFsc2VcbiAgfCBTb21lIF8gLT4gdHJ1ZVxuXG5sZXQgc3BsaXRfYXR0cmlidXRlIHMgPVxuICBsZXQgcmVjIGxvb3AgaW5kZXggdnMgPVxuICAgIGlmIGluZGV4ID0gU3RyaW5nLmxlbmd0aCBzIHRoZW4gTGlzdC5yZXYgdnNcbiAgICBlbHNlXG4gICAgICBsZXQgbWF5YmVfaW5kZXgnID1cbiAgICAgICAgdHJ5IFNvbWUgKFN0cmluZy5pbmRleF9mcm9tIHMgaW5kZXggJyAnKVxuICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiBOb25lXG4gICAgICBpblxuICAgICAgbWF0Y2ggbWF5YmVfaW5kZXgnIHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoU3RyaW5nLnN1YiBzIGluZGV4IChTdHJpbmcubGVuZ3RoIHMgLSBpbmRleCkpOjp2cyB8PiBMaXN0LnJldlxuICAgICAgfCBTb21lIGluZGV4JyB3aGVuIGluZGV4JyA9IGluZGV4IC0+IGxvb3AgKGluZGV4JyArIDEpIHZzXG4gICAgICB8IFNvbWUgaW5kZXgnIC0+XG4gICAgICAgIChTdHJpbmcuc3ViIHMgaW5kZXggKGluZGV4JyAtIGluZGV4KSk6OnZzIHw+IGxvb3AgKGluZGV4JyArIDEpXG4gIGluXG4gIGxvb3AgMCBbXVxuXG5sZXQgY2xhc3NlcyBub2RlID1cbiAgbWF0Y2ggYXR0cmlidXRlIFwiY2xhc3NcIiBub2RlIHdpdGhcbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBjbGFzc2VzIC0+IHNwbGl0X2F0dHJpYnV0ZSBjbGFzc2VzXG5cbmxldCBpZCA9IGF0dHJpYnV0ZSBcImlkXCJcblxudHlwZSAnYSBub2RlcyA9IHtlbGltaW5hdGUgOiAnYi4gKCdiIC0+ICdhIG5vZGUgLT4gJ2IpIC0+ICdiIC0+ICdifVxuXG5sZXQgZW1wdHkgPSB7ZWxpbWluYXRlID0gZnVuIF8gaW5pdCAtPiBpbml0fVxuXG5sZXQgZm9sZCBmIGluaXQgc2VxdWVuY2UgPSBzZXF1ZW5jZS5lbGltaW5hdGUgZiBpbml0XG5cbmxldCBmaWx0ZXJfbWFwIGYgc2VxdWVuY2UgPVxuICB7ZWxpbWluYXRlID0gZnVuIGYnIGluaXQgLT5cbiAgICBpbml0IHw+IHNlcXVlbmNlLmVsaW1pbmF0ZSAoZnVuIHYgbm9kZSAtPlxuICAgICAgbWF0Y2ggZiBub2RlIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB2XG4gICAgICB8IFNvbWUgbm9kZScgLT4gZicgdiBub2RlJyl9XG5cbmxldCBmaWx0ZXIgZiA9IGZpbHRlcl9tYXAgKGZ1biBub2RlIC0+IGlmIGYgbm9kZSB0aGVuIFNvbWUgbm9kZSBlbHNlIE5vbmUpXG5cbmxldCBtYXAgZiA9IGZpbHRlcl9tYXAgKGZ1biBub2RlIC0+IFNvbWUgKGYgbm9kZSkpXG5cbmxldCBmbGF0dGVuIGYgc2VxdWVuY2UgPVxuICB7ZWxpbWluYXRlID0gZnVuIGYnIGluaXQgLT5cbiAgICBpbml0IHw+IHNlcXVlbmNlLmVsaW1pbmF0ZSAoZnVuIHYgbm9kZSAtPiB2IHw+IChmIG5vZGUpLmVsaW1pbmF0ZSBmJyl9XG5cbmxldCBpdGVyIGYgc2VxdWVuY2UgPSBmb2xkIChmdW4gKCkgbm9kZSAtPiBmIG5vZGUpICgpIHNlcXVlbmNlXG5cbmxldCBudGggaW5kZXggc2VxdWVuY2UgPVxuICB3aXRoX3N0b3AgKGZ1biBzdG9wIC0+XG4gICAgc2VxdWVuY2VcbiAgICB8PiBmb2xkIChmdW4gaW5kZXgnIG5vZGUgLT5cbiAgICAgIGlmIGluZGV4JyA9IGluZGV4IHRoZW4gc3RvcC50aHJvdyAoU29tZSBub2RlKSBlbHNlIGluZGV4JyArIDEpXG4gICAgICAxXG4gICAgfD4gaWdub3JlO1xuICAgIE5vbmUpXG5cbmxldCBmaXJzdCBzZXF1ZW5jZSA9IG50aCAxIHNlcXVlbmNlXG5cbmxldCBsYXN0IHNlcXVlbmNlID0gc2VxdWVuY2UgfD4gZm9sZCAoZnVuIF8gbm9kZSAtPiBTb21lIG5vZGUpIE5vbmVcblxubGV0IGNvdW50IHNlcXVlbmNlID0gc2VxdWVuY2UgfD4gZm9sZCAoZnVuIGNvdW50IF8gLT4gY291bnQgKyAxKSAwXG5cbmxldCB0b19saXN0IHNlcXVlbmNlID0gZm9sZCAoZnVuIGwgbm9kZSAtPiBub2RlOjpsKSBbXSBzZXF1ZW5jZSB8PiBMaXN0LnJldlxuXG5sZXQgb2ZfbGlzdCBsID0ge2VsaW1pbmF0ZSA9IGZ1biBmIGluaXQgLT4gTGlzdC5mb2xkX2xlZnQgZiBpbml0IGx9XG5cbmxldCByZXYgc2VxdWVuY2UgPSBzZXF1ZW5jZSB8PiB0b19saXN0IHw+IExpc3QucmV2IHw+IG9mX2xpc3RcblxubGV0IGVsZW1lbnRzIHNlcXVlbmNlID1cbiAge2VsaW1pbmF0ZSA9IGZ1biBmIGluaXQgLT5cbiAgICBpbml0IHw+IHNlcXVlbmNlLmVsaW1pbmF0ZSAoZnVuIHYgbm9kZSAtPlxuICAgICAgbWF0Y2ggZWxlbWVudCBub2RlIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB2XG4gICAgICB8IFNvbWUgZWxlbWVudCAtPiBmIHYgZWxlbWVudCl9XG5cbmxldCBjaGlsZF9saXN0ID0gZnVuY3Rpb25cbiAgfCB7dmFsdWVzID0gYEVsZW1lbnQge2NoaWxkcmVuOyBffTsgX30gLT4gU29tZSBjaGlsZHJlblxuICB8IHt2YWx1ZXMgPSBgRG9jdW1lbnQge3Jvb3RzOyBffTsgX30gLT4gU29tZSByb290c1xuICB8IF8gLT4gTm9uZVxuXG5sZXQgY2hpbGRyZW4gbm9kZSA9XG4gIG1hdGNoIGNoaWxkX2xpc3Qgbm9kZSB3aXRoXG4gIHwgU29tZSBjaGlsZHJlbiAtPiB7ZWxpbWluYXRlID0gZnVuIGYgaW5pdCAtPiBMaXN0LmZvbGRfbGVmdCBmIGluaXQgY2hpbGRyZW59XG4gIHwgXyAtPiBlbXB0eVxuXG5sZXQgcmVjIGRlc2NlbmRhbnRzIG5vZGUgPVxuICB7ZWxpbWluYXRlID0gZnVuIGYgaW5pdCAtPlxuICAgIGluaXQgfD4gKGNoaWxkcmVuIG5vZGUpLmVsaW1pbmF0ZSAoZnVuIHYgY2hpbGQgLT5cbiAgICAgIGYgdiBjaGlsZCB8PiAoZGVzY2VuZGFudHMgKGZvcmdldF90eXBlIGNoaWxkKSkuZWxpbWluYXRlIGYpfVxuXG5sZXQgY2hpbGQgbm9kZSA9IG5vZGUgfD4gY2hpbGRyZW4gfD4gZmlyc3RcblxubGV0IGNoaWxkX2VsZW1lbnQgbm9kZSA9IG5vZGUgfD4gY2hpbGRyZW4gfD4gZWxlbWVudHMgfD4gZmlyc3RcblxubGV0IHNpbXBsZV9wYXJlbnQgbm9kZSA9IG5vZGUucGFyZW50XG5cbmxldCBwYXJlbnQgbm9kZSA9XG4gIG1hdGNoIG5vZGUucGFyZW50IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIG5vZGUgd2hlbiBpc19kb2N1bWVudCBub2RlIC0+IE5vbmVcbiAgfCBTb21lIG5vZGUgLT4gU29tZSBub2RlXG5cbmxldCByZWMgZ2VuZXJhbF9hbmNlc3RvcnMgZ2V0X3BhcmVudCBub2RlID1cbiAge2VsaW1pbmF0ZSA9IGZ1biBmIGluaXQgLT5cbiAgICBtYXRjaCBnZXRfcGFyZW50IG5vZGUgd2l0aFxuICAgIHwgTm9uZSAtPiBpbml0XG4gICAgfCBTb21lIHBhcmVudCAtPlxuICAgICAgZiBpbml0IHBhcmVudFxuICAgICAgfD4gKGdlbmVyYWxfYW5jZXN0b3JzIGdldF9wYXJlbnQgKGZvcmdldF90eXBlIHBhcmVudCkpLmVsaW1pbmF0ZSBmfVxuXG5sZXQgc2ltcGxlX2FuY2VzdG9ycyA9IGdlbmVyYWxfYW5jZXN0b3JzIHNpbXBsZV9wYXJlbnRcbmxldCBhbmNlc3RvcnMgbm9kZSA9IGdlbmVyYWxfYW5jZXN0b3JzIHBhcmVudCBub2RlXG5cbmxldCBzaWJsaW5ncyBub2RlID1cbiAgbWF0Y2ggc2ltcGxlX3BhcmVudCBub2RlIHdpdGhcbiAgfCBOb25lIC0+IGVtcHR5XG4gIHwgU29tZSBwYXJlbnQgLT5cbiAgICBjaGlsZHJlbiBwYXJlbnRcbiAgICB8PiBmaWx0ZXIgKGZ1biBjaGlsZCAtPiBjaGlsZCAhPSAoZm9yZ2V0X3R5cGUgbm9kZSkpXG5cbmxldCBzcGxpdF9hdF9pZGVudGl0eSBmdW5jdGlvbl9uYW1lIHYgbCA9XG4gIGxldCByZWMgbG9vcCBwcmVmaXggPSBmdW5jdGlvblxuICAgIHwgW10gLT5cbiAgICAgIGZhaWx3aXRoXG4gICAgICAgIChcIlNvdXAuXCIgXiBmdW5jdGlvbl9uYW1lIF5cbiAgICAgICAgIFwiOiBpbnRlcm5hbCBlcnJvcjogY2hpbGQgbm90IGluIHBhcmVudCdzIGNoaWxkIGxpc3RcIikgW0Bjb3ZlcmFnZSBvZmZdXG4gICAgfCB1OjpzdWZmaXggLT5cbiAgICAgIGlmIHUgPT0gdiB0aGVuIHByZWZpeCwgc3VmZml4IGVsc2UgbG9vcCAodTo6cHJlZml4KSBzdWZmaXhcbiAgaW5cbiAgbG9vcCBbXSBsXG5cbmxldCBzaWJsaW5nX2xpc3RzIGZ1bmN0aW9uX25hbWUgc2VsZWN0IG5vZGUgPVxuICBtYXRjaCBzaW1wbGVfcGFyZW50IG5vZGUgd2l0aFxuICB8IE5vbmUgLT4gZW1wdHlcbiAgfCBTb21lIHBhcmVudCAtPlxuICAgIG1hdGNoIGNoaWxkX2xpc3QgcGFyZW50IHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIGZhaWx3aXRoXG4gICAgICAgIChcIlNvdXAuXCIgXiBmdW5jdGlvbl9uYW1lIF4gXCI6IGludGVybmFsIGVycm9yOiBwYXJlbnQgaGFzIG5vIGNoaWxkcmVuXCIpXG4gICAgICAgICAgW0Bjb3ZlcmFnZSBvZmZdXG4gICAgfCBTb21lIGNoaWxkcmVuIC0+XG4gICAgICBsZXQgbGlzdHMgPVxuICAgICAgICBzcGxpdF9hdF9pZGVudGl0eSBmdW5jdGlvbl9uYW1lIChmb3JnZXRfdHlwZSBub2RlKSBjaGlsZHJlbiBpblxuICAgICAge2VsaW1pbmF0ZSA9IGZ1biBmIGluaXQgLT4gc2VsZWN0IGxpc3RzIHw+IExpc3QuZm9sZF9sZWZ0IGYgaW5pdH1cblxubGV0IG5leHRfc2libGluZ3Mgbm9kZSA9IHNpYmxpbmdfbGlzdHMgXCJuZXh0X3NpYmxpbmdzXCIgc25kIG5vZGVcbmxldCBwcmV2aW91c19zaWJsaW5ncyBub2RlID0gc2libGluZ19saXN0cyBcInByZXZpb3VzX3NpYmxpbmdzXCIgZnN0IG5vZGVcblxubGV0IG5leHRfc2libGluZyBub2RlID0gbmV4dF9zaWJsaW5ncyBub2RlIHw+IGZpcnN0XG5sZXQgcHJldmlvdXNfc2libGluZyBub2RlID0gcHJldmlvdXNfc2libGluZ3Mgbm9kZSB8PiBmaXJzdFxuXG5sZXQgbmV4dF9lbGVtZW50IG5vZGUgPSBuZXh0X3NpYmxpbmdzIG5vZGUgfD4gZWxlbWVudHMgfD4gZmlyc3RcbmxldCBwcmV2aW91c19lbGVtZW50IG5vZGUgPSBwcmV2aW91c19zaWJsaW5ncyBub2RlIHw+IGVsZW1lbnRzIHw+IGZpcnN0XG5cbmxldCBpbmRleF9vZiBub2RlID1cbiAgbWF0Y2ggc2ltcGxlX3BhcmVudCBub2RlIHdpdGhcbiAgfCBOb25lIC0+IDFcbiAgfCBTb21lIHBhcmVudCAtPlxuICAgIG1hdGNoIGNoaWxkX2xpc3QgcGFyZW50IHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIGZhaWx3aXRoIFwiU291cC5pbmRleF9vZjogaW50ZXJuYWwgZXJyb3I6IHBhcmVudCBoYXMgbm8gY2hpbGRyZW5cIlxuICAgICAgICBbQGNvdmVyYWdlIG9mZl1cbiAgICB8IFNvbWUgY2hpbGRyZW4gLT5cbiAgICAgIHdpdGhfc3RvcCAoZnVuIHN0b3AgLT5cbiAgICAgICAgY2hpbGRyZW4gfD4gTGlzdC5pdGVyaSAoZnVuIGluZGV4IGNoaWxkIC0+XG4gICAgICAgICAgaWYgY2hpbGQgPT0gKGZvcmdldF90eXBlIG5vZGUpIHRoZW4gc3RvcC50aHJvdyAoaW5kZXggKyAxKSk7XG4gICAgICAgIGZhaWx3aXRoXG4gICAgICAgICAgXCJTb3VwLmluZGV4X29mOiBpbnRlcm5hbCBlcnJvcjogY2hpbGQgbm90IGluIHBhcmVudCdzIGNoaWxkIGxpc3RcIilcbiAgICAgICAgICAgIFtAY292ZXJhZ2Ugb2ZmXVxuXG5sZXQgaW5kZXhfb2ZfZWxlbWVudCBlbGVtZW50ID1cbiAgbWF0Y2ggc2ltcGxlX3BhcmVudCBlbGVtZW50IHdpdGhcbiAgfCBOb25lIC0+IDFcbiAgfCBTb21lIHBhcmVudCAtPlxuICAgIHdpdGhfc3RvcCAoZnVuIHN0b3AgLT5cbiAgICAgIHBhcmVudFxuICAgICAgfD4gY2hpbGRyZW5cbiAgICAgIHw+IGVsZW1lbnRzXG4gICAgICB8PiBmb2xkIChmdW4gaW5kZXggZWxlbWVudCcgLT5cbiAgICAgICAgaWYgZWxlbWVudCcgPT0gZWxlbWVudCB0aGVuIHN0b3AudGhyb3cgaW5kZXggZWxzZSBpbmRleCArIDEpIDFcbiAgICAgIHw+IGlnbm9yZSBbQGNvdmVyYWdlIG9mZl07XG4gICAgICAoZmFpbHdpdGhcbiAgICAgICAgKFwiU291cC5pbmRleF9vZl9lbGVtZW50OiBpbnRlcm5hbCBlcnJvcjogXCIgXlxuICAgICAgICBcImVsZW1lbnQgaXMgbm90IGEgY2hpbGQgb2YgaXRzIG93biBwYXJlbnRcIikpIFtAY292ZXJhZ2Ugb2ZmXSlcblxubGV0IGF0X21vc3Rfbl9jaGlsZHJlbiBjb3VudCBub2RlID1cbiAgbWF0Y2ggbnRoIChjb3VudCArIDEpIChjaGlsZHJlbiBub2RlKSB3aXRoXG4gIHwgTm9uZSAtPiB0cnVlXG4gIHwgU29tZSBfIC0+IGZhbHNlXG5cbmxldCBub19jaGlsZHJlbiBub2RlID0gYXRfbW9zdF9uX2NoaWxkcmVuIDAgbm9kZVxubGV0IGF0X21vc3Rfb25lX2NoaWxkIG5vZGUgPSBhdF9tb3N0X25fY2hpbGRyZW4gMSBub2RlXG5cbmxldCBpc19yb290IG5vZGUgPVxuICBtYXRjaCBub2RlLnBhcmVudCB3aXRoXG4gIHwgTm9uZSAtPiBub3QgKGlzX2RvY3VtZW50IG5vZGUpXG4gIHwgU29tZSBwYXJlbnQgLT4gaXNfZG9jdW1lbnQgcGFyZW50XG5cbmxldCB0YWdzIG5hbWUnIG5vZGUgPVxuICBsZXQgbmFtZScgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIG5hbWUnIGluXG4gIG5vZGVcbiAgfD4gZGVzY2VuZGFudHNcbiAgfD4gZWxlbWVudHNcbiAgfD4gZmlsdGVyIChmdW4gZWxlbWVudCAtPiBuYW1lIGVsZW1lbnQgPSBuYW1lJylcblxubGV0IHRhZyBuYW1lIG5vZGUgPSB0YWdzIG5hbWUgbm9kZSB8PiBmaXJzdFxuXG5sZXQgbm9ybWFsaXplX2NoaWxkcmVuIHRyaW0gY2hpbGRyZW4gPVxuICBsZXQgcmVjIGxvb3AgcHJlZml4ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IExpc3QucmV2IHByZWZpeFxuICAgIHwgbm9kZTo6cmVzdCAtPlxuICAgICAgbWF0Y2ggbm9kZS52YWx1ZXMgd2l0aFxuICAgICAgfCBgVGV4dCBzIC0+XG4gICAgICAgIGxldCBzID0gdHJpbSBzIGluXG4gICAgICAgIGlmIHMgPSBcIlwiIHRoZW4gbG9vcCBwcmVmaXggcmVzdFxuICAgICAgICBlbHNlXG4gICAgICAgICAgKG1hdGNoIHByZWZpeCB3aXRoXG4gICAgICAgICAgfCB7dmFsdWVzID0gYFRleHQgcyc7IF99OjpwcmVmaXgnIC0+XG4gICAgICAgICAgICBsb29wICgoY3JlYXRlX3RleHQgKHMnIF4gcykpOjpwcmVmaXgnKSByZXN0XG4gICAgICAgICAgfCBfIC0+IGxvb3AgKChjcmVhdGVfdGV4dCBzKTo6cHJlZml4KSByZXN0KVxuICAgICAgfCBfIC0+IGxvb3AgKG5vZGU6OnByZWZpeCkgcmVzdFxuICBpblxuXG4gIGxvb3AgW10gY2hpbGRyZW5cblxubGV0IHJlYyBsZWFmX3RleHQgbm9kZSA9XG4gIGxldCB0cmltIHMgPSBpZiBTdHJpbmcudHJpbSBzID0gXCJcIiB0aGVuIFwiXCIgZWxzZSBzIGluXG5cbiAgbWF0Y2ggbm9kZS52YWx1ZXMgd2l0aFxuICB8IGBUZXh0IHMgLT4gU29tZSBzXG4gIHwgYEVsZW1lbnQgX1xuICB8IGBEb2N1bWVudCBfIC0+XG4gICAgbGV0IGNoaWxkcmVuID1cbiAgICAgIGNoaWxkX2xpc3Qgbm9kZVxuICAgICAgfD4gcmVxdWlyZV9pbnRlcm5hbFxuICAgICAgICAoXCJTb3VwLmxlYWZfdGV4dDogaW50ZXJuYWwgZXJyb3I6IG5vZGUgaXMgbm90IGEgdGV4dCBub2RlLCBcIiBeXG4gICAgICAgICBcImJ1dCBoYXMgbm8gY2hpbGQgbGlzdFwiKVxuICAgICAgfD4gbm9ybWFsaXplX2NoaWxkcmVuIHRyaW1cbiAgICBpblxuICAgIG1hdGNoIGNoaWxkcmVuIHdpdGhcbiAgICB8IFtdIC0+IFNvbWUgXCJcIlxuICAgIHwgW2NoaWxkXSAtPiBsZWFmX3RleHQgKGZvcmdldF90eXBlIGNoaWxkKVxuICAgIHwgXyAtPiBOb25lXG5cbmxldCByZWMgdGV4dHMgbm9kZSA9XG4gIG1hdGNoIG5vZGUudmFsdWVzIHdpdGhcbiAgfCBgVGV4dCBzIC0+IFtzXVxuICB8IGBFbGVtZW50IHtjaGlsZHJlbjsgX30gLT5cbiAgICBjaGlsZHJlbiB8PiBMaXN0Lm1hcCBmb3JnZXRfdHlwZSB8PiBMaXN0Lm1hcCB0ZXh0cyB8PiBMaXN0LmZvbGRfbGVmdCAoQCkgW11cbiAgfCBgRG9jdW1lbnQge3Jvb3RzOyBffSAtPlxuICAgIHJvb3RzIHw+IExpc3QubWFwIGZvcmdldF90eXBlIHw+IExpc3QubWFwIHRleHRzIHw+IExpc3QuZm9sZF9sZWZ0IChAKSBbXVxuXG5sZXQgdHJpbW1lZF90ZXh0cyBub2RlID1cbiAgdGV4dHMgbm9kZVxuICB8PiBMaXN0Lm1hcCBTdHJpbmcudHJpbVxuICB8PiBMaXN0LmZpbHRlciAoZnVuIHMgLT4gU3RyaW5nLmxlbmd0aCBzID4gMClcblxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yIG9mIHN0cmluZ1xuXG5tb2R1bGUgU2VsZWN0b3IgOlxuc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBwYXJzZSA6IHN0cmluZyAtPiB0XG4gIHZhbCBzZWxlY3QgOiAoXyBub2RlKSAtPiB0IC0+IGVsZW1lbnQgbm9kZXNcbiAgdmFsIG1hdGNoZXNfc2VsZWN0b3IgOiB0IC0+IHNvdXAgbm9kZSAtPiBzb3VwIG5vZGUgLT4gYm9vbFxuZW5kID1cbnN0cnVjdFxuICB0eXBlIHR5cGVfID0gTmFtZSBvZiBzdHJpbmcgfCBVbml2ZXJzYWxcblxuICB0eXBlIGF0dHJpYnV0ZSA9XG4gICAgfCBQcmVzZW50IG9mIHN0cmluZ1xuICAgIHwgRXhhY3RseSBvZiBzdHJpbmcgKiBzdHJpbmdcbiAgICB8IE1lbWJlciBvZiBzdHJpbmcgKiBzdHJpbmdcbiAgICB8IEhhc0Rhc2hTZXBhcmF0ZWRQcmVmaXggb2Ygc3RyaW5nICogc3RyaW5nXG4gICAgfCBQcmVmaXggb2Ygc3RyaW5nICogc3RyaW5nXG4gICAgfCBTdWZmaXggb2Ygc3RyaW5nICogc3RyaW5nXG4gICAgfCBTdWJzdHJpbmcgb2Ygc3RyaW5nICogc3RyaW5nXG5cbiAgdHlwZSBwc2V1ZG9fY2xhc3MgPVxuICAgIHwgUm9vdFxuICAgIHwgTnRoQ2hpbGQgb2YgaW50ICogaW50XG4gICAgfCBOdGhMYXN0Q2hpbGQgb2YgaW50ICogaW50XG4gICAgfCBOdGhPZlR5cGUgb2YgaW50ICogaW50XG4gICAgfCBOdGhMYXN0T2ZUeXBlIG9mIGludCAqIGludFxuICAgIHwgT25seUNoaWxkXG4gICAgfCBPbmx5T2ZUeXBlXG4gICAgfCBFbXB0eVxuICAgIHwgQ29udGVudCBvZiBzdHJpbmdcbiAgICB8IEhhcyBvZiBzaW1wbGVfc2VsZWN0b3JcbiAgICB8IE5vdCBvZiBzaW1wbGVfc2VsZWN0b3JcblxuICBhbmQgc2ltcGxlX3NlbGVjdG9yID1cbiAgICB8IFR5cGUgb2YgdHlwZV9cbiAgICB8IEF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVcbiAgICB8IFBzZXVkb19jbGFzcyBvZiBwc2V1ZG9fY2xhc3NcblxuICB0eXBlIGNvbWJpbmF0b3IgPVxuICAgIHwgRGVzY2VuZGFudFxuICAgIHwgQ2hpbGRcbiAgICB8IEFkamFjZW50U2libGluZ1xuICAgIHwgSW5kaXJlY3RTaWJsaW5nXG5cbiAgdHlwZSB0ID0gKGNvbWJpbmF0b3IgKiBzaW1wbGVfc2VsZWN0b3IgbGlzdCkgbGlzdFxuXG4gIGxldCBoYXNfcHJlZml4IHByZWZpeCBzID0gU3RyaW5nLnN1YiBzIDAgKFN0cmluZy5sZW5ndGggcHJlZml4KSA9IHByZWZpeFxuXG4gIGxldCBoYXNfc3VmZml4IHN1ZmZpeCBzID1cbiAgICBsZXQgc3VmZml4X2xlbmd0aCA9IFN0cmluZy5sZW5ndGggc3VmZml4IGluXG4gICAgU3RyaW5nLnN1YiBzIChTdHJpbmcubGVuZ3RoIHMgLSBzdWZmaXhfbGVuZ3RoKSBzdWZmaXhfbGVuZ3RoID0gc3VmZml4XG5cbiAgbGV0IGhhc19zdWJzdHJpbmcgcycgcyA9XG4gICAgbGV0IHN1YnN0cmluZ19sZW5ndGggPSBTdHJpbmcubGVuZ3RoIHMnIGluXG4gICAgbGV0IHJlYyBsb29wIGluZGV4ID1cbiAgICAgIGlmIFN0cmluZy5zdWIgcyBpbmRleCBzdWJzdHJpbmdfbGVuZ3RoID0gcycgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGluZGV4ICsgMSlcbiAgICBpblxuICAgIHRyeSBsb29wIDBcbiAgICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiBmYWxzZVxuXG4gIGxldCBtYXRjaGVzX2F0dHJpYnV0ZV9zZWxlY3RvciBub2RlIHNlbGVjdG9yID1cbiAgICBsZXQgY2FwdHVyZWQgPVxuICAgICAgXCJTb3VwLm1hdGNoZXNfYXR0cmlidXRlX3NlbGVjdG9yOiBpbnRlcm5hbCBlcnJvcjogXCIgXlxuICAgICAgXCJ0aGlzIGV4Y2VwdGlvbiBzaG91bGQgaGF2ZSBiZWVuIGNhdWdodFwiXG4gICAgaW5cblxuICAgIHRyeVxuICAgICAgbWF0Y2ggc2VsZWN0b3Igd2l0aFxuICAgICAgfCBQcmVzZW50IG5hbWUgLT4gaGFzX2F0dHJpYnV0ZSBuYW1lIG5vZGVcbiAgICAgIHwgRXhhY3RseSAobmFtZSwgdmFsdWUpIC0+IGF0dHJpYnV0ZSBuYW1lIG5vZGUgPSBTb21lIHZhbHVlXG4gICAgICB8IE1lbWJlciAobmFtZSwgdmFsdWUpIC0+XG4gICAgICAgIGF0dHJpYnV0ZSBuYW1lIG5vZGVcbiAgICAgICAgfD4gcmVxdWlyZV9pbnRlcm5hbCBjYXB0dXJlZFxuICAgICAgICB8PiBzcGxpdF9hdHRyaWJ1dGVcbiAgICAgICAgfD4gTGlzdC5tZW0gdmFsdWVcbiAgICAgIHwgSGFzRGFzaFNlcGFyYXRlZFByZWZpeCAobmFtZSwgdmFsdWUpIC0+XG4gICAgICAgIGxldCB2YWx1ZScgPSBhdHRyaWJ1dGUgbmFtZSBub2RlIHw+IHJlcXVpcmVfaW50ZXJuYWwgY2FwdHVyZWQgaW5cbiAgICAgICAgdmFsdWUnID0gdmFsdWUgfHwgaGFzX3ByZWZpeCAodmFsdWUgXiBcIi1cIikgdmFsdWUnXG4gICAgICB8IFByZWZpeCAobmFtZSwgdmFsdWUpIC0+XG4gICAgICAgIGF0dHJpYnV0ZSBuYW1lIG5vZGUgfD4gcmVxdWlyZV9pbnRlcm5hbCBjYXB0dXJlZCB8PiBoYXNfcHJlZml4IHZhbHVlXG4gICAgICB8IFN1ZmZpeCAobmFtZSwgdmFsdWUpIC0+XG4gICAgICAgIGF0dHJpYnV0ZSBuYW1lIG5vZGUgfD4gcmVxdWlyZV9pbnRlcm5hbCBjYXB0dXJlZCB8PiBoYXNfc3VmZml4IHZhbHVlXG4gICAgICB8IFN1YnN0cmluZyAobmFtZSwgdmFsdWUpIC0+XG4gICAgICAgIGF0dHJpYnV0ZSBuYW1lIG5vZGUgfD4gcmVxdWlyZV9pbnRlcm5hbCBjYXB0dXJlZCB8PiBoYXNfc3Vic3RyaW5nIHZhbHVlXG5cbiAgICB3aXRoIF8gLT4gZmFsc2VcblxuICBsZXQgZWxlbWVudF9jb3VudCBub2RlID1cbiAgICBtYXRjaCBzaW1wbGVfcGFyZW50IG5vZGUgd2l0aFxuICAgIHwgTm9uZSAtPiAxIFtAY292ZXJhZ2Ugb2ZmXVxuICAgIHwgU29tZSBwYXJlbnQgLT4gcGFyZW50IHw+IGNoaWxkcmVuIHw+IGVsZW1lbnRzIHw+IGNvdW50XG5cbiAgbGV0IGVsZW1lbnRfY291bnRfd2l0aF9uYW1lIG5hbWUnIG5vZGUgPVxuICAgIG1hdGNoIHNpbXBsZV9wYXJlbnQgbm9kZSB3aXRoXG4gICAgfCBOb25lIC0+IDEgW0Bjb3ZlcmFnZSBvZmZdXG4gICAgfCBTb21lIHBhcmVudCAtPlxuICAgICAgcGFyZW50XG4gICAgICB8PiBjaGlsZHJlblxuICAgICAgfD4gZWxlbWVudHNcbiAgICAgIHw+IGZpbHRlciAoZnVuIGVsZW1lbnQgLT4gbmFtZSBlbGVtZW50ID0gbmFtZScpXG4gICAgICB8PiBjb3VudFxuXG4gIGxldCBlbGVtZW50X2luZGV4X3dpdGhfbmFtZSBuYW1lJyBub2RlID1cbiAgICBtYXRjaCBzaW1wbGVfcGFyZW50IG5vZGUgd2l0aFxuICAgIHwgTm9uZSAtPiAxIFtAY292ZXJhZ2Ugb2ZmXVxuICAgIHwgU29tZSBwYXJlbnQgLT5cbiAgICAgIHdpdGhfc3RvcCAoZnVuIHN0b3AgLT5cbiAgICAgICAgZmx1c2ggc3Rkb3V0O1xuICAgICAgICBwYXJlbnRcbiAgICAgICAgfD4gY2hpbGRyZW5cbiAgICAgICAgfD4gZWxlbWVudHNcbiAgICAgICAgfD4gZmlsdGVyIChmdW4gZWxlbWVudCAtPiBuYW1lIGVsZW1lbnQgPSBuYW1lJylcbiAgICAgICAgfD4gZm9sZCAoZnVuIGluZGV4IGVsZW1lbnQgLT5cbiAgICAgICAgICBpZiBlbGVtZW50ID09IG5vZGUgdGhlbiBzdG9wLnRocm93IGluZGV4IGVsc2UgaW5kZXggKyAxKVxuICAgICAgICAgIDFcbiAgICAgICAgfD4gaWdub3JlIFtAY292ZXJhZ2Ugb2ZmXTtcbiAgICAgICAgKGZhaWx3aXRoXG4gICAgICAgICAgKFwiU291cC5TZWxlY3Rvci5lbGVtZW50X2luZGV4X3dpdGhfbmFtZTogaW50ZXJuYWwgZXJyb3I6IFwiIF5cbiAgICAgICAgICAgXCJwYXJlbnQgZG9lcyBub3QgaGF2ZSBnaXZlbiBjaGlsZFwiKSkgW0Bjb3ZlcmFnZSBvZmZdKVxuXG4gIGxldCBjb25kaXRpb25hbF9tb2QgbiBhID0gaWYgYSA9IDAgdGhlbiBuIGVsc2UgbiBtb2QgYVxuXG4gIGxldCByZWMgbWF0Y2hlc19wc2V1ZG9fY2xhc3Nfc2VsZWN0b3Igbm9kZSBzZWxlY3RvciA9XG4gICAgbWF0Y2ggc2VsZWN0b3Igd2l0aFxuICAgIHwgUm9vdCAtPiBwYXJlbnQgbm9kZSA9IE5vbmVcbiAgICB8IE50aENoaWxkIChhLCBiKSAtPiBjb25kaXRpb25hbF9tb2QgKGluZGV4X29mX2VsZW1lbnQgbm9kZSkgYSA9IGJcbiAgICB8IE50aExhc3RDaGlsZCAoYSwgYikgLT5cbiAgICAgIGxldCBlbGVtZW50X2NvdW50ID0gZWxlbWVudF9jb3VudCBub2RlIGluXG4gICAgICBjb25kaXRpb25hbF9tb2QgKGVsZW1lbnRfY291bnQgLSAoaW5kZXhfb2ZfZWxlbWVudCBub2RlKSArIDEpIGEgPSBiXG4gICAgfCBOdGhPZlR5cGUgKGEsIGIpIC0+XG4gICAgICBjb25kaXRpb25hbF9tb2QgKGVsZW1lbnRfaW5kZXhfd2l0aF9uYW1lIChuYW1lIG5vZGUpIG5vZGUpIGEgPSBiXG4gICAgfCBOdGhMYXN0T2ZUeXBlIChhLCBiKSAtPlxuICAgICAgbGV0IG5hbWUgPSBuYW1lIG5vZGUgaW5cbiAgICAgIGxldCBlbGVtZW50X2NvdW50ID0gZWxlbWVudF9jb3VudF93aXRoX25hbWUgbmFtZSBub2RlIGluXG4gICAgICBjb25kaXRpb25hbF9tb2RcbiAgICAgICAgKGVsZW1lbnRfY291bnQgLSAoZWxlbWVudF9pbmRleF93aXRoX25hbWUgbmFtZSBub2RlKSArIDEpIGEgPSBiXG4gICAgfCBPbmx5Q2hpbGQgLT4gZWxlbWVudF9jb3VudCBub2RlID0gMVxuICAgIHwgT25seU9mVHlwZSAtPiBlbGVtZW50X2NvdW50X3dpdGhfbmFtZSAobmFtZSBub2RlKSBub2RlID0gMVxuICAgIHwgRW1wdHkgLT4gbm9fY2hpbGRyZW4gbm9kZVxuICAgIHwgQ29udGVudCBzIC0+IHRleHRzIG5vZGUgfD4gU3RyaW5nLmNvbmNhdCBcIlwiIHw+IGhhc19zdWJzdHJpbmcgc1xuICAgIHwgSGFzIHNlbGVjdG9yIC0+XG4gICAgICBkZXNjZW5kYW50cyBub2RlXG4gICAgICB8PiBmaWx0ZXIgKGZ1biBkZXNjZW5kYW50IC0+IG5vdCAoaXNfdGV4dCBkZXNjZW5kYW50KSlcbiAgICAgIHw+IGZpbHRlciAoZnVuIGRlc2NlbmRhbnQgLT4gbWF0Y2hlc19zaW1wbGVfc2VsZWN0b3IgZGVzY2VuZGFudCBzZWxlY3RvcilcbiAgICAgIHw+IGNvdW50XG4gICAgICB8PiBmdW4gY291bnQgLT4gY291bnQgPiAwXG4gICAgfCBOb3Qgc2VsZWN0b3IgLT4gbm90IChtYXRjaGVzX3NpbXBsZV9zZWxlY3RvciBub2RlIHNlbGVjdG9yKVxuXG4gIGFuZCBtYXRjaGVzX3NpbXBsZV9zZWxlY3RvciBub2RlID0gZnVuY3Rpb25cbiAgICB8IFR5cGUgVW5pdmVyc2FsIC0+IHRydWVcbiAgICB8IFR5cGUgKE5hbWUgbmFtZScpIC0+IG5hbWUgbm9kZSA9IChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIG5hbWUnKVxuICAgIHwgQXR0cmlidXRlIGF0dHJpYnV0ZV9zZWxlY3RvciAtPlxuICAgICAgbWF0Y2hlc19hdHRyaWJ1dGVfc2VsZWN0b3Igbm9kZSBhdHRyaWJ1dGVfc2VsZWN0b3JcbiAgICB8IFBzZXVkb19jbGFzcyBwc2V1ZG9fY2xhc3Nfc2VsZWN0b3IgLT5cbiAgICAgIG1hdGNoZXNfcHNldWRvX2NsYXNzX3NlbGVjdG9yIG5vZGUgcHNldWRvX2NsYXNzX3NlbGVjdG9yXG5cbiAgbGV0IG1hdGNoZXNfc2ltcGxlX3NlbGVjdG9ycyBub2RlIHNlbGVjdG9ycyA9XG4gICAgTGlzdC5mb3JfYWxsIChtYXRjaGVzX3NpbXBsZV9zZWxlY3RvciBub2RlKSBzZWxlY3RvcnNcblxuICBsZXQgdXBfdG8gbm9kZSBzZXF1ZW5jZSA9XG4gICAge2VsaW1pbmF0ZSA9IGZ1biBmIGluaXQgLT5cbiAgICAgIHdpdGhfc3RvcCAoZnVuIHN0b3AgLT5cbiAgICAgICAgc2VxdWVuY2UuZWxpbWluYXRlIChmdW4gdiBub2RlJyAtPlxuICAgICAgICAgIGxldCB2JyA9IGYgdiBub2RlJyBpblxuICAgICAgICAgIGlmIG5vZGUnID09IG5vZGUgdGhlbiBzdG9wLnRocm93IHYnIGVsc2UgdicpIGluaXQpfVxuXG4gIGxldCBvbmUgc2VxdWVuY2UgPVxuICAgIHtlbGltaW5hdGUgPSBmdW4gZiBpbml0IC0+XG4gICAgICB3aXRoX3N0b3AgKGZ1biBzdG9wIC0+XG4gICAgICAgIHNlcXVlbmNlLmVsaW1pbmF0ZSAoZnVuIHYgbm9kZSAtPiBmIHYgbm9kZSB8PiBzdG9wLnRocm93KSBpbml0KX1cblxuICBsZXQgbWF0Y2hlc19zZWxlY3RvciBzZWxlY3RvciByb290X25vZGUgYXRfbm9kZSA9XG4gICAgd2l0aF9zdG9wIChmdW4gc3RvcCAtPlxuICAgICAgbGV0IHJlYyBiYWNrd2FyZHNfdHJhdmVyc2FsIGF0X25vZGUgPSBmdW5jdGlvblxuXHR8IFtdIC0+IGlmIGF0X25vZGUgPT0gcm9vdF9ub2RlIHRoZW4gc3RvcC50aHJvdyB0cnVlIGVsc2UgKClcblx0fCAoY29tYmluYXRvciwgc2ltcGxlX3NlbGVjdG9ycyk6OnJlc3QgLT5cblx0ICBpZiBub3QgKGlzX2VsZW1lbnQgYXRfbm9kZSkgdGhlbiAoKVxuXHQgIGVsc2Vcblx0ICAgIGlmIG5vdCAobWF0Y2hlc19zaW1wbGVfc2VsZWN0b3JzIGF0X25vZGUgc2ltcGxlX3NlbGVjdG9ycykgdGhlbiAoKVxuXHQgICAgZWxzZVxuXHQgICAgICBsZXQgbmV4dF9ub2RlcyA9XG5cdFx0bWF0Y2ggY29tYmluYXRvciB3aXRoXG5cdFx0fCBEZXNjZW5kYW50IC0+XG5cdFx0ICBhdF9ub2RlIHw+IHNpbXBsZV9hbmNlc3RvcnMgfD4gdXBfdG8gcm9vdF9ub2RlXG5cdFx0fCBDaGlsZCAtPiBhdF9ub2RlIHw+IGFuY2VzdG9ycyB8PiBvbmVcblx0XHR8IEluZGlyZWN0U2libGluZyAtPlxuXHRcdCAgYXRfbm9kZSB8PiBwcmV2aW91c19zaWJsaW5ncyB8PiBlbGVtZW50cyB8PiB1cF90byByb290X25vZGVcblx0XHR8IEFkamFjZW50U2libGluZyAtPlxuXHRcdCAgYXRfbm9kZSB8PiBwcmV2aW91c19zaWJsaW5ncyB8PiBlbGVtZW50cyB8PiBvbmVcblx0ICAgICAgaW5cblx0ICAgICAgbmV4dF9ub2RlcyB8PiBpdGVyIChmdW4gbm9kZSAtPiBiYWNrd2FyZHNfdHJhdmVyc2FsIG5vZGUgcmVzdClcbiAgICAgIGluXG4gICAgICBiYWNrd2FyZHNfdHJhdmVyc2FsIGF0X25vZGUgKExpc3QucmV2IHNlbGVjdG9yKTtcbiAgICAgIGZhbHNlKVxuXG4gIGxldCBzZWxlY3Qgcm9vdF9ub2RlIHNlbGVjdG9yID1cbiAgICBsZXQgcm9vdF9ub2RlID0gZm9yZ2V0X3R5cGUgcm9vdF9ub2RlIGluXG4gICAgbGV0IGNhbmRpZGF0ZXMgPVxuICAgICAgbWF0Y2ggc2ltcGxlX3BhcmVudCByb290X25vZGUgd2l0aFxuICAgICAgfCBOb25lIC0+IGRlc2NlbmRhbnRzIHJvb3Rfbm9kZVxuICAgICAgfCBTb21lIHBhcmVudCAtPiBkZXNjZW5kYW50cyBwYXJlbnRcbiAgICBpblxuICAgIGNhbmRpZGF0ZXNcbiAgICB8PiBlbGVtZW50c1xuICAgIHw+IGZpbHRlciAobWF0Y2hlc19zZWxlY3RvciBzZWxlY3RvciByb290X25vZGUpXG5cbiAgbGV0IGlzX2RlY2ltYWxfY2hhciBjID1cbiAgICAoKENoYXIuY29kZSBjKSA+PSAoQ2hhci5jb2RlICcwJykpICYmICgoQ2hhci5jb2RlIGMpIDw9IChDaGFyLmNvZGUgJzknKSlcblxuICBsZXQgaXNfaGV4YWRlY2ltYWxfY2hhciBjID1cbiAgICAoaXNfZGVjaW1hbF9jaGFyIGMpIHx8IChjID49ICdhJyAmJiBjIDw9ICdmJykgfHwgKGMgPj0gJ0EnICYmIGMgPD0gJ0YnKVxuXG4gIGxldCBpc19pZGVudGlmaWVyX2NoYXIgYyA9XG4gICAgbGV0IGMgPSBDaGFyLmxvd2VyY2FzZV9hc2NpaSBjIGluXG4gICAgKChDaGFyLmNvZGUgYykgPj0gKENoYXIuY29kZSAnYScpICYmIChDaGFyLmNvZGUgYykgPD0gKENoYXIuY29kZSAneicpKSB8fFxuICAgIChpc19kZWNpbWFsX2NoYXIgYykgfHwgKGMgPT0gJy0nKSB8fCAoYyA9PSAnXycpXG5cbiAgbGV0IGlzX3doaXRlc3BhY2VfY2hhciBjID1cbiAgICBjID0gJyAnIHx8IGMgPSAnXFx0JyB8fCBjID0gJ1xcbicgfHwgYyA9ICdcXHInXG5cbiAgbGV0IGlzX2NvbnRpbnVhdGlvbl9zaW1wbGVfc2VsZWN0b3Jfc3RhcnRfY2hhciBjID1cbiAgICAoYyA9PSAnLicpIHx8IChjID09ICcjJykgfHwgKGMgPT0gJ1snKSB8fCAoYyA9PSAnOicpXG5cbiAgbGV0IGhleGFkZWNpbWFsX3ZhbHVlID0gZnVuY3Rpb25cbiAgICB8ICdBJyB8ICdhJyAtPiAweEFcbiAgICB8ICdCJyB8ICdiJyAtPiAweEJcbiAgICB8ICdDJyB8ICdjJyAtPiAweENcbiAgICB8ICdEJyB8ICdkJyAtPiAweERcbiAgICB8ICdFJyB8ICdlJyAtPiAweEVcbiAgICB8ICdGJyB8ICdmJyAtPiAweEZcbiAgICB8IGMgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnXG5cbiAgbGV0IHBhcnNlX2Vycm9yIG1zZyA9IHJhaXNlIChQYXJzZV9lcnJvciBtc2cpXG5cbiAgbGV0IHJlYyBwYXJzZV9oZXhhZGVjaW1hbF9lc2NhcGUgdmFsdWUgY291bnQgc3RyZWFtID1cbiAgICBpZiBjb3VudCA+PSA2IHRoZW5cbiAgICAgIHZhbHVlXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RyZWFtIHdpdGhcbiAgICAgIHwgU29tZSAoJyAnIHwgJ1xcdCcgfCAnXFxuJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RyZWFtO1xuICAgICAgICB2YWx1ZVxuICAgICAgfCBTb21lICdcXHInIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5ucGVlayAyIHN0cmVhbSB3aXRoXG4gICAgICAgIHwgWydcXHInOyAnXFxuJ10gLT5cbiAgICAgICAgICBTdHJlYW0uanVuayBzdHJlYW07XG4gICAgICAgICAgU3RyZWFtLmp1bmsgc3RyZWFtXG4gICAgICAgIHwgXyAtPiAoKVxuICAgICAgICBlbmQ7XG4gICAgICAgIHZhbHVlXG4gICAgICB8IFNvbWUgYyB3aGVuIGlzX2hleGFkZWNpbWFsX2NoYXIgYyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJlYW07XG4gICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlICogMHgxMCArIGhleGFkZWNpbWFsX3ZhbHVlIGMgaW5cbiAgICAgICAgcGFyc2VfaGV4YWRlY2ltYWxfZXNjYXBlIHZhbHVlIChjb3VudCArIDEpIHN0cmVhbVxuICAgICAgfCBfIC0+IHZhbHVlXG5cbiAgbGV0IHBhcnNlX2VzY2FwZV9zZXF1ZW5jZSBzdHJlYW0gPVxuICAgIFN0cmVhbS5qdW5rIHN0cmVhbTtcbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgIHwgTm9uZSAtPiAnXFxcXCdcbiAgICB8IFNvbWUgYyB3aGVuIGlzX2hleGFkZWNpbWFsX2NoYXIgYyAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcGFyc2VfaGV4YWRlY2ltYWxfZXNjYXBlIDAgMCBzdHJlYW0gd2l0aFxuICAgICAgfCBuIHdoZW4gbiA+IDB4RkYgLT4gJ1xceDFBJ1xuICAgICAgfCBuIC0+IENoYXIuY2hyIG5cbiAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+XG4gICAgICBTdHJlYW0uanVuayBzdHJlYW07XG4gICAgICBjXG5cbiAgbGV0IHBhcnNlX2lkZW50aWZpZXIgc3RyZWFtID1cbiAgICBsZXQgYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSAzMiBpblxuICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cmVhbSB3aXRoXG4gICAgfCBTb21lICdcXFxcJyAtPiAoKVxuICAgIHwgU29tZSBjIHdoZW4gaXNfaWRlbnRpZmllcl9jaGFyIGMgLT4gKClcbiAgICB8IF8gLT4gKHBhcnNlX2Vycm9yIFtAY292ZXJhZ2Ugb2ZmXSkgXCJleHBlY3RlZCBhbiBpZGVudGlmaWVyXCJcbiAgICBlbmQ7XG4gICAgbGV0IHJlYyBsb29wICgpID1cbiAgICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cmVhbSB3aXRoXG4gICAgICB8IFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWZmZXIgKHBhcnNlX2VzY2FwZV9zZXF1ZW5jZSBzdHJlYW0pOyBsb29wICgpXG4gICAgICB8IFNvbWUgYyB3aGVuIGlzX2lkZW50aWZpZXJfY2hhciBjIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWZmZXIgYzsgU3RyZWFtLmp1bmsgc3RyZWFtOyBsb29wICgpXG4gICAgICB8IF8gLT4gQnVmZmVyLmNvbnRlbnRzIGJ1ZmZlclxuICAgIGluXG4gICAgbG9vcCAoKVxuXG4gIGxldCBwYXJzZV90eXBlX3NlbGVjdG9yIHN0cmVhbSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RyZWFtIHdpdGhcbiAgICB8IFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cmVhbTsgVW5pdmVyc2FsXG4gICAgfCBfIC0+XG4gICAgICB0cnlcbiAgICAgICAgbGV0IG5hbWUgPSBwYXJzZV9pZGVudGlmaWVyIHN0cmVhbSBpblxuICAgICAgICBOYW1lIG5hbWVcbiAgICAgIHdpdGggXyAtPiBwYXJzZV9lcnJvciBcImV4cGVjdGVkIHRhZyBuYW1lIG9yICcqJ1wiXG5cbiAgbGV0IHBhcnNlX2F0dHJpYnV0ZV9vcGVyYXRvciBzdHJlYW0gPVxuICAgIG1hdGNoIFN0cmVhbS5ucGVlayAyIHN0cmVhbSB3aXRoXG4gICAgfCBbJz0nOyBfXSAtPiBTdHJlYW0uanVuayBzdHJlYW07IFwiPVwiXG4gICAgfCBbYzsgJz0nXSAtPlxuICAgICAgU3RyZWFtLmp1bmsgc3RyZWFtOyBTdHJlYW0uanVuayBzdHJlYW07IFByaW50Zi5zcHJpbnRmIFwiJWM9XCIgY1xuICAgIHwgXyAtPiBwYXJzZV9lcnJvciBcImV4cGVjdGVkIGF0dHJpYnV0ZSBvcGVyYXRvclwiXG5cbiAgbGV0IHBhcnNlX3F1b3RlZF9zdHJpbmcgc3RyZWFtID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgIHwgU29tZSAoJ1wiJyBhcyBkZWxpbSkgfCBTb21lICgnXFwnJyBhcyBkZWxpbSkgLT5cbiAgICAgIFN0cmVhbS5qdW5rIHN0cmVhbTtcbiAgICAgIGxldCBidWZmZXIgPSBCdWZmZXIuY3JlYXRlIDY0IGluXG4gICAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgICAgICB8IFNvbWUgYyB3aGVuIGMgPSBkZWxpbSAtPlxuICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cmVhbTsgQnVmZmVyLmNvbnRlbnRzIGJ1ZmZlclxuICAgICAgICB8IFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgICAgU3RyZWFtLmp1bmsgc3RyZWFtO1xuICAgICAgICAgIChtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgICAgICAgIHwgU29tZSBjIHdoZW4gYyA9IGRlbGltIC0+XG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmZmVyIGRlbGltOyBTdHJlYW0uanVuayBzdHJlYW1cbiAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWZmZXIgJ1xcXFwnKTtcbiAgICAgICAgICBsb29wICgpXG4gICAgICAgIHwgU29tZSBjIC0+XG4gICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZmZlciBjOyBTdHJlYW0uanVuayBzdHJlYW07IGxvb3AgKClcbiAgICAgICAgfCBOb25lIC0+IHBhcnNlX2Vycm9yIFwidW50ZXJtaW5hdGVkIHN0cmluZ1wiXG4gICAgICBpblxuICAgICAgbG9vcCAoKVxuICAgIHwgXyAtPiBwYXJzZV9lcnJvciBcImV4cGVjdGVkIHF1b3RlZCBzdHJpbmdcIlxuXG4gIGxldCBwYXJzZV9zdHJpbmcgc3RyZWFtID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgIHwgU29tZSAnXCInIHwgU29tZSAnXFwnJyAtPiBwYXJzZV9xdW90ZWRfc3RyaW5nIHN0cmVhbVxuICAgIHwgXyAtPlxuICAgICAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgMzIgaW5cbiAgICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cmVhbSB3aXRoXG4gICAgICAgIHwgU29tZSAnXScgfCBOb25lIC0+IEJ1ZmZlci5jb250ZW50cyBidWZmZXJcbiAgICAgICAgfCBTb21lIGMgLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZmZlciBjOyBTdHJlYW0uanVuayBzdHJlYW07IGxvb3AgKClcbiAgICAgIGluXG4gICAgICBsb29wICgpXG5cbiAgbGV0IGNvbnN1bWVfd2hpdGVzcGFjZSBzdHJlYW0gPVxuICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgICAgfCBTb21lIGMgd2hlbiBpc193aGl0ZXNwYWNlX2NoYXIgYyAtPiBTdHJlYW0uanVuayBzdHJlYW07IGxvb3AgKClcbiAgICAgIHwgXyAtPiAoKVxuICAgIGluXG4gICAgbG9vcCAoKVxuXG4gIGxldCBwYXJzZV9hdHRyaWJ1dGVfc2VsZWN0b3Igc3RyZWFtID1cbiAgICBTdHJlYW0uanVuayBzdHJlYW07XG4gICAgY29uc3VtZV93aGl0ZXNwYWNlIHN0cmVhbTtcbiAgICBsZXQgbmFtZSA9IHBhcnNlX2lkZW50aWZpZXIgc3RyZWFtIGluXG4gICAgY29uc3VtZV93aGl0ZXNwYWNlIHN0cmVhbTtcbiAgICAobWF0Y2ggU3RyZWFtLnBlZWsgc3RyZWFtIHdpdGhcbiAgICB8IE5vbmUgLT4gcGFyc2VfZXJyb3IgXCJ1bnRlcm1pbmF0ZWQgYXR0cmlidXRlIHNlbGVjdG9yXCJcbiAgICB8IFNvbWUgJ10nIC0+IFN0cmVhbS5qdW5rIHN0cmVhbTsgUHJlc2VudCBuYW1lXG4gICAgfCBTb21lIF8gLT5cbiAgICAgIGxldCBvcGVyYXRvciA9IHBhcnNlX2F0dHJpYnV0ZV9vcGVyYXRvciBzdHJlYW0gaW5cbiAgICAgIGNvbnN1bWVfd2hpdGVzcGFjZSBzdHJlYW07XG4gICAgICAobWF0Y2ggU3RyZWFtLnBlZWsgc3RyZWFtIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBwYXJzZV9lcnJvciBcInVudGVybWluYXRlZCBhdHRyaWJ1dGUgc2VsZWN0b3JcIlxuICAgICAgfCBTb21lICddJyAtPlxuICAgICAgICBwYXJzZV9lcnJvciBcImV4cGVjdGVkIHZhbHVlIGluIGF0dHJpYnV0ZSBzZWxlY3RvclwiXG4gICAgICB8IFNvbWUgXyAtPlxuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZV9zdHJpbmcgc3RyZWFtIGluXG4gICAgICAgIGNvbnN1bWVfd2hpdGVzcGFjZSBzdHJlYW07XG4gICAgICAgIChtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBwYXJzZV9lcnJvciBcInVudGVybWluYXRlZCBhdHRyaWJ1dGUgc2VsZWN0b3JcIlxuICAgICAgICB8IFNvbWUgJ10nIC0+XG4gICAgICAgICAgU3RyZWFtLmp1bmsgc3RyZWFtO1xuICAgICAgICAgIChtYXRjaCBvcGVyYXRvciB3aXRoXG4gICAgICAgICAgfCBcIj1cIiAtPiBFeGFjdGx5IChuYW1lLCB2YWx1ZSlcbiAgICAgICAgICB8IFwifj1cIiAtPiBNZW1iZXIgKG5hbWUsIHZhbHVlKVxuICAgICAgICAgIHwgXCJ8PVwiIC0+IEhhc0Rhc2hTZXBhcmF0ZWRQcmVmaXggKG5hbWUsIHZhbHVlKVxuICAgICAgICAgIHwgXCJePVwiIC0+IFByZWZpeCAobmFtZSwgdmFsdWUpXG4gICAgICAgICAgfCBcIiQ9XCIgLT4gU3VmZml4IChuYW1lLCB2YWx1ZSlcbiAgICAgICAgICB8IFwiKj1cIiAtPiBTdWJzdHJpbmcgKG5hbWUsIHZhbHVlKVxuICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgUHJpbnRmLmtzcHJpbnRmIHBhcnNlX2Vycm9yXG4gICAgICAgICAgICAgIFwiaW52YWxpZCBhdHRyaWJ1dGUgb3BlcmF0b3IgJyVzJ1wiIG9wZXJhdG9yKVxuICAgICAgICB8IFNvbWUgXyAtPiBwYXJzZV9lcnJvciBcImV4cGVjdGVkIGVuZCBvZiBhdHRyaWJ1dGUgc2VsZWN0b3IgKCddJylcIikpKVxuXG4gIGxldCBwYXJzZV9jbGFzc19zZWxlY3RvciBzdHJlYW0gPVxuICAgIFN0cmVhbS5qdW5rIHN0cmVhbTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZV9pZGVudGlmaWVyIHN0cmVhbSBpblxuICAgIE1lbWJlciAoXCJjbGFzc1wiLCB2YWx1ZSlcblxuICBsZXQgcGFyc2VfaWRfc2VsZWN0b3Igc3RyZWFtID1cbiAgICBTdHJlYW0uanVuayBzdHJlYW07XG4gICAgbGV0IHZhbHVlID0gcGFyc2VfaWRlbnRpZmllciBzdHJlYW0gaW5cbiAgICBFeGFjdGx5IChcImlkXCIsIHZhbHVlKVxuXG4gIGxldCBwYXJzZV9udW1iZXIgc3RyZWFtID1cbiAgICBsZXQgYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgICAgfCBTb21lIGMgd2hlbiBpc19kZWNpbWFsX2NoYXIgYyAtPlxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmZmVyIGM7IFN0cmVhbS5qdW5rIHN0cmVhbTsgbG9vcCAoKVxuICAgICAgfCBfIC0+IEJ1ZmZlci5jb250ZW50cyBidWZmZXJcbiAgICBpblxuICAgIGxvb3AgKCkgfD4gaW50X29mX3N0cmluZ1xuXG4gIGxldCBwYXJzZV9tb2R1bGFyX3BhdHRlcm5fdGFpbCBhIHN0cmVhbSA9XG4gICAgU3RyZWFtLmp1bmsgc3RyZWFtO1xuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cmVhbSB3aXRoXG4gICAgfCBTb21lICgnKycgYXMgYykgfCBTb21lICgnLScgYXMgYykgLT5cbiAgICAgIFN0cmVhbS5qdW5rIHN0cmVhbTtcbiAgICAgIChtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gaXNfZGVjaW1hbF9jaGFyIGMnIC0+XG4gICAgICAgIGxldCBiID0gcGFyc2VfbnVtYmVyIHN0cmVhbSBpblxuICAgICAgICBsZXQgYiA9XG4gICAgICAgICAgaWYgYyA9ICcrJyB0aGVuIGIgbW9kIGFcbiAgICAgICAgICBlbHNlIGEgLSAoYiBtb2QgYSlcbiAgICAgICAgaW5cbiAgICAgICAgYSwgYlxuICAgICAgfCBfIC0+IHBhcnNlX2Vycm9yIFwiZXhwZWN0ZWQgbnVtYmVyIGFmdGVyICcrJyBvciAnLSdcIilcbiAgICB8IF8gLT4gYSwgMFxuXG4gIGxldCBwYXJzZV9tb2R1bGFyX3BhdHRlcm4gc3RyZWFtID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgIHwgU29tZSAnZScgfCBTb21lICdvJyAtPlxuICAgICAgKG1hdGNoIHBhcnNlX2lkZW50aWZpZXIgc3RyZWFtIHdpdGhcbiAgICAgIHwgXCJldmVuXCIgLT4gKDIsIDApXG4gICAgICB8IFwib2RkXCIgLT4gKDIsIDEpXG4gICAgICB8IF8gLT4gcGFyc2VfZXJyb3IgXCJleHBlY3RlZCAnbicsICdldmVuJywgb3IgJ29kZCdcIilcbiAgICB8IFNvbWUgJ24nIC0+IHBhcnNlX21vZHVsYXJfcGF0dGVybl90YWlsIDEgc3RyZWFtXG4gICAgfCBTb21lIGMgd2hlbiBpc19kZWNpbWFsX2NoYXIgYyAtPlxuICAgICAgbGV0IGEgPSBwYXJzZV9udW1iZXIgc3RyZWFtIGluXG4gICAgICAobWF0Y2ggU3RyZWFtLnBlZWsgc3RyZWFtIHdpdGhcbiAgICAgIHwgU29tZSAnbicgLT4gcGFyc2VfbW9kdWxhcl9wYXR0ZXJuX3RhaWwgYSBzdHJlYW1cbiAgICAgIHwgXyAtPiAoMCwgYSkpXG4gICAgfCBfIC0+IHBhcnNlX2Vycm9yIFwiZXhwZWN0ZWQgZXhwcmVzc2lvblwiXG5cbiAgbGV0IHBhcnNlX3BhcmVudGhlc2l6ZWRfdmFsdWUgZiBzdHJlYW0gPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cmVhbSB3aXRoXG4gICAgfCBTb21lICcoJyAtPlxuICAgICAgU3RyZWFtLmp1bmsgc3RyZWFtO1xuICAgICAgY29uc3VtZV93aGl0ZXNwYWNlIHN0cmVhbTtcbiAgICAgIGxldCB2YWx1ZSA9IGYgc3RyZWFtIGluXG4gICAgICBjb25zdW1lX3doaXRlc3BhY2Ugc3RyZWFtO1xuICAgICAgKG1hdGNoIFN0cmVhbS5wZWVrIHN0cmVhbSB3aXRoXG4gICAgICB8IFNvbWUgJyknIC0+IFN0cmVhbS5qdW5rIHN0cmVhbTsgdmFsdWVcbiAgICAgIHwgXyAtPiBwYXJzZV9lcnJvciBcInVudGVybWluYXRlZCAnKCdcIilcbiAgICB8IF8gLT4gcGFyc2VfZXJyb3IgXCJleHBlY3RlZCBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25cIlxuXG4gIGxldCByZWMgcGFyc2VfcHNldWRvX2NsYXNzX3NlbGVjdG9yIHN0cmVhbSA9XG4gICAgU3RyZWFtLmp1bmsgc3RyZWFtO1xuICAgIGxldCBmdW5jdGlvbl8gPSBwYXJzZV9pZGVudGlmaWVyIHN0cmVhbSBpblxuICAgIChtYXRjaCBmdW5jdGlvbl8gd2l0aFxuICAgIHwgXCJyb290XCIgLT4gUm9vdFxuICAgIHwgXCJmaXJzdC1jaGlsZFwiIC0+IE50aENoaWxkICgwLCAxKVxuICAgIHwgXCJsYXN0LWNoaWxkXCIgLT4gTnRoTGFzdENoaWxkICgwLCAxKVxuICAgIHwgXCJmaXJzdC1vZi10eXBlXCIgLT4gTnRoT2ZUeXBlICgwLCAxKVxuICAgIHwgXCJsYXN0LW9mLXR5cGVcIiAtPiBOdGhMYXN0T2ZUeXBlICgwLCAxKVxuICAgIHwgXCJvbmx5LWNoaWxkXCIgLT4gT25seUNoaWxkXG4gICAgfCBcIm9ubHktb2YtdHlwZVwiIC0+IE9ubHlPZlR5cGVcbiAgICB8IFwibnRoLWNoaWxkXCIgLT5cbiAgICAgIGxldCBhLCBiID0gcGFyc2VfcGFyZW50aGVzaXplZF92YWx1ZSBwYXJzZV9tb2R1bGFyX3BhdHRlcm4gc3RyZWFtIGluXG4gICAgICBOdGhDaGlsZCAoYSwgYilcbiAgICB8IFwibnRoLW9mLXR5cGVcIiAtPlxuICAgICAgbGV0IGEsIGIgPSBwYXJzZV9wYXJlbnRoZXNpemVkX3ZhbHVlIHBhcnNlX21vZHVsYXJfcGF0dGVybiBzdHJlYW0gaW5cbiAgICAgIE50aE9mVHlwZSAoYSwgYilcbiAgICB8IFwibnRoLWxhc3QtY2hpbGRcIiAtPlxuICAgICAgbGV0IGEsIGIgPSBwYXJzZV9wYXJlbnRoZXNpemVkX3ZhbHVlIHBhcnNlX21vZHVsYXJfcGF0dGVybiBzdHJlYW0gaW5cbiAgICAgIE50aExhc3RDaGlsZCAoYSwgYilcbiAgICB8IFwibnRoLWxhc3Qtb2YtdHlwZVwiIC0+XG4gICAgICBsZXQgYSwgYiA9IHBhcnNlX3BhcmVudGhlc2l6ZWRfdmFsdWUgcGFyc2VfbW9kdWxhcl9wYXR0ZXJuIHN0cmVhbSBpblxuICAgICAgTnRoTGFzdE9mVHlwZSAoYSwgYilcbiAgICB8IFwiY29udGFpbnNcIiAtPlxuICAgICAgbGV0IHMgPSBwYXJzZV9wYXJlbnRoZXNpemVkX3ZhbHVlIHBhcnNlX3F1b3RlZF9zdHJpbmcgc3RyZWFtIGluXG4gICAgICBDb250ZW50IHNcbiAgICB8IFwiZW1wdHlcIiAtPiBFbXB0eVxuICAgIHwgXCJoYXNcIiAtPlxuICAgICAgbGV0IHNlbGVjdG9yID0gcGFyc2VfcGFyZW50aGVzaXplZF92YWx1ZSBwYXJzZV9zaW1wbGVfc2VsZWN0b3Igc3RyZWFtIGluXG4gICAgICBIYXMgc2VsZWN0b3JcbiAgICB8IFwibm90XCIgLT5cbiAgICAgIGxldCBzZWxlY3RvciA9IHBhcnNlX3BhcmVudGhlc2l6ZWRfdmFsdWUgcGFyc2Vfc2ltcGxlX3NlbGVjdG9yIHN0cmVhbSBpblxuICAgICAgTm90IHNlbGVjdG9yXG4gICAgfCBfIC0+XG4gICAgICBQcmludGYua3NwcmludGYgcGFyc2VfZXJyb3JcbiAgICAgICAgXCJ1bmtub3duIHBzZXVkby1jbGFzcyBvciBwc2V1ZG8tZWxlbWVudCAnOiVzJ1wiIGZ1bmN0aW9uXylcblxuICBhbmQgcGFyc2Vfc2ltcGxlX3NlbGVjdG9yIHN0cmVhbSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RyZWFtIHdpdGhcbiAgICB8IFNvbWUgJ1snIC0+IEF0dHJpYnV0ZSAocGFyc2VfYXR0cmlidXRlX3NlbGVjdG9yIHN0cmVhbSlcbiAgICB8IFNvbWUgJzonIC0+IFBzZXVkb19jbGFzcyAocGFyc2VfcHNldWRvX2NsYXNzX3NlbGVjdG9yIHN0cmVhbSlcbiAgICB8IFNvbWUgJy4nIC0+IEF0dHJpYnV0ZSAocGFyc2VfY2xhc3Nfc2VsZWN0b3Igc3RyZWFtKVxuICAgIHwgU29tZSAnIycgLT4gQXR0cmlidXRlIChwYXJzZV9pZF9zZWxlY3RvciBzdHJlYW0pXG4gICAgfCBTb21lIF8gLT4gVHlwZSAocGFyc2VfdHlwZV9zZWxlY3RvciBzdHJlYW0pXG4gICAgfCBOb25lIC0+IHBhcnNlX2Vycm9yIFwiZXhwZWN0ZWQgc2ltcGxlIHNlbGVjdG9yXCJcblxuICBsZXQgcGFyc2Vfc2ltcGxlX3NlbGVjdG9yX2xpc3Qgc3RyZWFtID1cbiAgICBsZXQgZmlyc3QgPSBwYXJzZV9zaW1wbGVfc2VsZWN0b3Igc3RyZWFtIGluXG4gICAgbGV0IHJlYyBsb29wIHNlbGVjdG9ycyA9XG4gICAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJlYW0gd2l0aFxuICAgICAgfCBTb21lIGMgd2hlbiBpc19jb250aW51YXRpb25fc2ltcGxlX3NlbGVjdG9yX3N0YXJ0X2NoYXIgYyAtPlxuICAgICAgICAocGFyc2Vfc2ltcGxlX3NlbGVjdG9yIHN0cmVhbSk6OnNlbGVjdG9ycyB8PiBsb29wXG4gICAgICB8IF8gLT4gTGlzdC5yZXYgc2VsZWN0b3JzXG4gICAgaW5cbiAgICBsb29wIFtmaXJzdF1cblxuICBsZXQgcGFyc2UgcyA9XG4gICAgbGV0IHN0cmVhbSA9IFN0cmVhbS5vZl9zdHJpbmcgcyBpblxuICAgIGxldCByZWMgbG9vcCBzZWxlY3RvcnMgPVxuICAgICAgY29uc3VtZV93aGl0ZXNwYWNlIHN0cmVhbTtcbiAgICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cmVhbSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTGlzdC5yZXYgc2VsZWN0b3JzXG4gICAgICB8IF8gLT5cbiAgICAgICAgbGV0IGNvbWJpbmF0b3IgPVxuICAgICAgICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cmVhbSB3aXRoXG4gICAgICAgICAgfCBTb21lICc+JyAtPiBTdHJlYW0uanVuayBzdHJlYW07IENoaWxkXG4gICAgICAgICAgfCBTb21lICcrJyAtPiBTdHJlYW0uanVuayBzdHJlYW07IEFkamFjZW50U2libGluZ1xuICAgICAgICAgIHwgU29tZSAnficgLT4gU3RyZWFtLmp1bmsgc3RyZWFtOyBJbmRpcmVjdFNpYmxpbmdcbiAgICAgICAgICB8IF8gLT4gRGVzY2VuZGFudFxuICAgICAgICBpblxuICAgICAgICBjb25zdW1lX3doaXRlc3BhY2Ugc3RyZWFtO1xuICAgICAgICAoY29tYmluYXRvciwgcGFyc2Vfc2ltcGxlX3NlbGVjdG9yX2xpc3Qgc3RyZWFtKTo6c2VsZWN0b3JzIHw+IGxvb3BcbiAgICBpblxuICAgIGxvb3AgW11cbmVuZFxuXG5sZXQgbWF0Y2hlc19zZWxlY3RvciByb290X25vZGUgc2VsZWN0b3Igbm9kZSA9XG4gIGxldCByb290X25vZGUgPSBmb3JnZXRfdHlwZSByb290X25vZGUgaW5cbiAgbGV0IG5vZGUgPSBmb3JnZXRfdHlwZSBub2RlIGluXG4gIGxldCBzZWxlY3RvciA9IFNlbGVjdG9yLnBhcnNlIHNlbGVjdG9yIGluXG4gIFNlbGVjdG9yLm1hdGNoZXNfc2VsZWN0b3Igc2VsZWN0b3Igcm9vdF9ub2RlIG5vZGVcblxubGV0IHNlbGVjdCBzZWxlY3RvciBub2RlID1cbiAgc2VsZWN0b3IgfD4gU2VsZWN0b3IucGFyc2UgfD4gU2VsZWN0b3Iuc2VsZWN0IG5vZGVcblxubGV0IHNlbGVjdF9vbmUgc2VsZWN0b3Igbm9kZSA9IHNlbGVjdCBzZWxlY3RvciBub2RlIHw+IGZpcnN0XG5cbmxldCAoJCkgbm9kZSBzZWxlY3RvciA9XG4gIG5vZGUgfD4gc2VsZWN0X29uZSBzZWxlY3RvclxuICB8PiByZXF1aXJlX2ludGVybmFsXG4gICAgKFByaW50Zi5zcHJpbnRmIFwiU291cC4oJCk6ICclcycgbm90IGZvdW5kLlxcbiVzXCJcbiAgICAgIHNlbGVjdG9yXG4gICAgICBcIlRyeSBTb3VwLigkPykgaWYgeW91J2QgcHJlZmVyIHJldHVybmluZyBOb25lIGluc3RlYWQgb2YgYW4gZXhjZXB0aW9uLlwiKVxuXG5sZXQgKCQ/KSBub2RlIHNlbGVjdG9yID0gbm9kZSB8PiBzZWxlY3Rfb25lIHNlbGVjdG9yXG5cbmxldCAoJCQpIG5vZGUgc2VsZWN0b3IgPSBub2RlIHw+IHNlbGVjdCBzZWxlY3RvclxuXG5tb2R1bGUgSW5maXggPVxuc3RydWN0XG4gIGxldCAoJCkgPSAoJClcbiAgbGV0ICgkPykgPSAoJD8pXG4gIGxldCAoJCQpID0gKCQkKVxuZW5kXG5cbmxldCBzaWduYWxzIHJvb3QgPVxuICBsZXQgcm9vdCA9IGZvcmdldF90eXBlIHJvb3QgaW5cblxuICBsZXQgcmVjIHRyYXZlcnNlIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCB7dmFsdWVzID0gYEVsZW1lbnQge25hbWU7IGF0dHJpYnV0ZXM7IGNoaWxkcmVufTsgX30gLT5cbiAgICAgIGxldCBzdGFydF9zaWduYWwgPVxuICAgICAgICBgU3RhcnRfZWxlbWVudFxuICAgICAgICAgICgoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIG5hbWUpLFxuICAgICAgICAgICBMaXN0Lm1hcCAoZnVuIChuLCB2KSAtPiAoXCJcIiwgbiksIHYpIGF0dHJpYnV0ZXMpXG4gICAgICBpblxuICAgICAgYEVuZF9lbGVtZW50OjoodHJhdmVyc2VfbGlzdCAoc3RhcnRfc2lnbmFsOjphY2MpIGNoaWxkcmVuKVxuXG4gICAgfCB7dmFsdWVzID0gYERvY3VtZW50IHtyb290czsgZG9jdHlwZX07IF99IC0+XG4gICAgICBsZXQgYWNjID1cbiAgICAgICAgbWF0Y2ggZG9jdHlwZSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBhY2NcbiAgICAgICAgfCBTb21lIGRvY3R5cGUgLT4gYWNjIEAgW2BEb2N0eXBlIGRvY3R5cGVdXG4gICAgICBpblxuICAgICAgdHJhdmVyc2VfbGlzdCBhY2Mgcm9vdHNcblxuICAgIHwge3ZhbHVlcyA9IGBUZXh0IHM7IF99IC0+IChgVGV4dCBbc10pOjphY2NcblxuICBhbmQgdHJhdmVyc2VfbGlzdCBhY2MgbCA9IExpc3QuZm9sZF9sZWZ0IHRyYXZlcnNlIGFjYyBsXG5cbiAgaW5cblxuICBMaXN0LnJldiAodHJhdmVyc2UgW10gcm9vdCkgfD4gTWFya3VwLm9mX2xpc3RcblxubGV0IHByZXR0eV9wcmludCByb290ID1cbiAgc2lnbmFscyByb290XG4gIHw+IE1hcmt1cC5wcmV0dHlfcHJpbnQgfD4gKGZ1biBzIC0+IE1hcmt1cC53cml0ZV9odG1sIHMpIHw+IE1hcmt1cC50b19zdHJpbmdcblxubGV0IHRvX3N0cmluZyByb290ID1cbiAgc2lnbmFscyByb290IHw+IChmdW4gcyAtPiBNYXJrdXAud3JpdGVfaHRtbCBzKSB8PiBNYXJrdXAudG9fc3RyaW5nXG5cbmxldCByZWMgZXF1YWxfZ2VuZXJhbCBub3JtYWxpemVfY2hpbGRyZW4gbiBuJyA9XG4gIGxldCBlcXVhbF90ZXh0IHMgcycgPSBzID0gcycgaW5cblxuICBsZXQgZXF1YWxfY2hpbGRyZW4gY2hpbGRyZW4gY2hpbGRyZW4nID1cbiAgICBsZXQgY2hpbGRyZW4gPSBub3JtYWxpemVfY2hpbGRyZW4gY2hpbGRyZW4gaW5cbiAgICBsZXQgY2hpbGRyZW4nID0gbm9ybWFsaXplX2NoaWxkcmVuIGNoaWxkcmVuJyBpblxuXG4gICAgdHJ5XG4gICAgICBMaXN0Lml0ZXIyIChmdW4gYyBjJyAtPlxuICAgICAgICBpZiBub3QgKGVxdWFsX2dlbmVyYWwgbm9ybWFsaXplX2NoaWxkcmVuIGMgYycpIHRoZW5cbiAgICAgICAgICByYWlzZV9ub3RyYWNlIChJbnZhbGlkX2FyZ3VtZW50IFwibm90IGVxdWFsXCIpKVxuICAgICAgICBjaGlsZHJlbiBjaGlsZHJlbic7XG4gICAgICB0cnVlXG4gICAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gZmFsc2VcbiAgaW5cblxuICBsZXQgZXF1YWxfZWxlbWVudCB2YWx1ZXMgdmFsdWVzJyA9XG4gICAgICAodmFsdWVzLm5hbWUgPSB2YWx1ZXMnLm5hbWUpXG4gICAgJiZcbiAgICAgIGJlZ2luXG4gICAgICAgIGxldCBzb3J0ID1cbiAgICAgICAgICBMaXN0LnNvcnQgKGZ1biBhdHRyIGF0dHInIC0+IGNvbXBhcmUgKGZzdCBhdHRyKSAoZnN0IGF0dHInKSkgaW5cbiAgICAgICAgKHNvcnQgdmFsdWVzLmF0dHJpYnV0ZXMpID0gKHNvcnQgdmFsdWVzJy5hdHRyaWJ1dGVzKVxuICAgICAgZW5kXG4gICAgJiZcbiAgICAgIGVxdWFsX2NoaWxkcmVuIHZhbHVlcy5jaGlsZHJlbiB2YWx1ZXMnLmNoaWxkcmVuXG4gIGluXG5cbiAgbGV0IGVxdWFsX2RvY3VtZW50IHZhbHVlcyB2YWx1ZXMnID1cbiAgICBlcXVhbF9jaGlsZHJlbiB2YWx1ZXMucm9vdHMgdmFsdWVzJy5yb290c1xuICBpblxuXG4gIG1hdGNoIG4sIG4nIHdpdGhcbiAgfCB7dmFsdWVzID0gYFRleHQgczsgX30sIHt2YWx1ZXMgPSBgVGV4dCBzJzsgX30gLT4gZXF1YWxfdGV4dCBzIHMnXG4gIHwge3ZhbHVlcyA9IGBFbGVtZW50IHY7IF99LCB7dmFsdWVzID0gYEVsZW1lbnQgdic7IF99IC0+IGVxdWFsX2VsZW1lbnQgdiB2J1xuICB8IHt2YWx1ZXMgPSBgRG9jdW1lbnQgdjsgX30sIHt2YWx1ZXMgPSBgRG9jdW1lbnQgdic7IF99IC0+IGVxdWFsX2RvY3VtZW50IHYgdidcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBlcXVhbCBuIG4nID1cbiAgZXF1YWxfZ2VuZXJhbFxuICAgIChub3JtYWxpemVfY2hpbGRyZW4gKGZ1biBzIC0+IHMpKSAoZm9yZ2V0X3R5cGUgbikgKGZvcmdldF90eXBlIG4nKVxuXG5sZXQgZXF1YWxfbW9kdWxvX3doaXRlc3BhY2UgbiBuJyA9XG4gIGVxdWFsX2dlbmVyYWxcbiAgICAobm9ybWFsaXplX2NoaWxkcmVuIFN0cmluZy50cmltKSAoZm9yZ2V0X3R5cGUgbikgKGZvcmdldF90eXBlIG4nKVxuXG5sZXQgbXV0YXRlX2NoaWxkX2xpc3QgZiBub2RlID1cbiAgbWF0Y2ggbm9kZS52YWx1ZXMgd2l0aFxuICB8IGBFbGVtZW50IHZhbHVlcyAtPiB2YWx1ZXMuY2hpbGRyZW4gPC0gZiB2YWx1ZXMuY2hpbGRyZW5cbiAgfCBgRG9jdW1lbnQgdmFsdWVzIC0+IHZhbHVlcy5yb290cyA8LSBmIHZhbHVlcy5yb290c1xuICB8IGBUZXh0IF8gLT4gZmFpbHdpdGggXCJTb3VwLm11dGF0ZV9jaGlsZF9saXN0OiBub2RlIGhhcyBubyBjaGlsZHJlblwiXG5cbmxldCBzdHJpcF9kb2N1bWVudCBub2RlID1cbiAgaWYgaXNfZG9jdW1lbnQgbm9kZSB0aGVuXG4gICAgbGV0IGNoaWxkcmVuID0gbm9kZSB8PiBjaGlsZHJlbiB8PiB0b19saXN0IGluXG4gICAgKGNoaWxkcmVuIHw+IExpc3QuaXRlciAoZnVuIGNoaWxkIC0+IGNoaWxkLnBhcmVudCA8LSBOb25lKTtcbiAgICBtdXRhdGVfY2hpbGRfbGlzdCAoZnVuIF8gLT4gW10pIG5vZGUpO1xuICAgIGNoaWxkcmVuXG4gIGVsc2VcbiAgICBbbm9kZV1cblxubGV0IGRlbGV0ZSBub2RlID1cbiAgbWF0Y2ggbm9kZS5wYXJlbnQgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIHBhcmVudCAtPlxuICAgIG11dGF0ZV9jaGlsZF9saXN0XG4gICAgICAoTGlzdC5maWx0ZXIgKGZ1biBjaGlsZCAtPiBjaGlsZCAhPSAoZm9yZ2V0X3R5cGUgbm9kZSkpKSBwYXJlbnQ7XG4gICAgbm9kZS5wYXJlbnQgPC0gTm9uZVxuXG5sZXQgaW5zZXJ0X2F0X2luZGV4IGsgZWxlbWVudCBub2RlID1cbiAgbGV0IGVsZW1lbnQgPSBmb3JnZXRfdHlwZSBlbGVtZW50IGluXG4gIGxldCBub2RlID0gZm9yZ2V0X3R5cGUgbm9kZSBpblxuXG4gIGRlbGV0ZSBub2RlO1xuXG4gIGxldCBub2RlcyA9IHN0cmlwX2RvY3VtZW50IG5vZGUgaW5cblxuICBtdXRhdGVfY2hpbGRfbGlzdCAoZnVuIGwgLT5cbiAgICBsZXQgcmVjIGxvb3AgcHJlZml4IGluZGV4ID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gKExpc3QucmV2IHByZWZpeCkgQCBub2Rlc1xuICAgICAgfCB4OjpsJyAtPlxuICAgICAgICBpZiBrIDw9IGluZGV4IHRoZW4gKExpc3QucmV2IHByZWZpeCkgQCBub2RlcyBAICh4OjpsJylcbiAgICAgICAgZWxzZSBsb29wICh4OjpwcmVmaXgpIChpbmRleCArIDEpIGwnXG4gICAgaW5cbiAgICBsb29wIFtdIDEgbCkgZWxlbWVudDtcblxuICBub2RlcyB8PiBMaXN0Lml0ZXIgKGZ1biBub2RlIC0+IG5vZGUucGFyZW50IDwtIFNvbWUgZWxlbWVudClcblxubGV0IGFwcGVuZF9jaGlsZCBlbGVtZW50IG5vZGUgPVxuICBpbnNlcnRfYXRfaW5kZXggKChlbGVtZW50IHw+IGNoaWxkcmVuIHw+IGNvdW50KSArIDEpIGVsZW1lbnQgbm9kZVxuXG5sZXQgcHJlcGVuZF9jaGlsZCBlbGVtZW50IG5vZGUgPVxuICBpbnNlcnRfYXRfaW5kZXggMSBlbGVtZW50IG5vZGVcblxubGV0IGluc2VydF9iZWZvcmUgdGFyZ2V0IG5vZGUgPVxuICBpbnNlcnRfYXRfaW5kZXhcbiAgICAoaW5kZXhfb2YgdGFyZ2V0KVxuICAgIChwYXJlbnQgdGFyZ2V0XG4gICAgIHw+IHJlcXVpcmVfaW50ZXJuYWwgXCJTb3VwLmluc2VydF9iZWZvcmU6IHRhcmdldCBub2RlIGhhcyBubyBwYXJlbnRcIilcbiAgICBub2RlXG5cbmxldCBpbnNlcnRfYWZ0ZXIgdGFyZ2V0IG5vZGUgPVxuICBpbnNlcnRfYXRfaW5kZXhcbiAgICAoKGluZGV4X29mIHRhcmdldCkgKyAxKVxuICAgIChwYXJlbnQgdGFyZ2V0XG4gICAgIHw+IHJlcXVpcmVfaW50ZXJuYWwgXCJTb3VwLmluc2VydF9hZnRlcjogdGFyZ2V0IG5vZGUgaGFzIG5vIHBhcmVudFwiKVxuICAgIG5vZGVcblxubGV0IGNsZWFyIG5vZGUgPVxuICBtdXRhdGVfY2hpbGRfbGlzdCAoZnVuIGNoaWxkcmVuIC0+XG4gICAgY2hpbGRyZW4gfD4gTGlzdC5pdGVyIChmdW4gY2hpbGQgLT4gY2hpbGQucGFyZW50IDwtIE5vbmUpOyBbXSkgbm9kZVxuXG5sZXQgcmVwbGFjZSB0YXJnZXQgbm9kZSA9XG4gIGRlbGV0ZSBub2RlO1xuICBsZXQgcGFyZW50ID1cbiAgICBwYXJlbnQgdGFyZ2V0XG4gICAgfD4gcmVxdWlyZV9pbnRlcm5hbCBcIlNvdXAucmVwbGFjZTogdGFyZ2V0IG5vZGUgaGFzIG5vIHBhcmVudFwiXG4gIGluXG4gIGxldCBpbmRleCA9IGluZGV4X29mIHRhcmdldCBpblxuICBkZWxldGUgdGFyZ2V0O1xuICBpbnNlcnRfYXRfaW5kZXggaW5kZXggcGFyZW50IG5vZGVcblxubGV0IHN3YXAgdGFyZ2V0IGVsZW1lbnQgPVxuICBsZXQgaW50ZXJuYWwgPSBcIlNvdXAuc3dhcDogaW50ZXJuYWwgZXJyb3I6IG5vbi1lbGVtZW50IG5vZGUgZ2l2ZW5cIiBpblxuICBsZXQgdGFyZ2V0X2NoaWxkcmVuID0gY2hpbGRfbGlzdCB0YXJnZXQgfD4gcmVxdWlyZV9pbnRlcm5hbCBpbnRlcm5hbCBpblxuICBsZXQgZWxlbWVudF9jaGlsZHJlbiA9IGNoaWxkX2xpc3QgZWxlbWVudCB8PiByZXF1aXJlX2ludGVybmFsIGludGVybmFsIGluXG4gIHRhcmdldF9jaGlsZHJlbiB8PiBMaXN0Lml0ZXIgKGZ1biBjaGlsZCAtPiBjaGlsZC5wYXJlbnQgPC0gU29tZSBlbGVtZW50KTtcbiAgZWxlbWVudF9jaGlsZHJlbiB8PiBMaXN0Lml0ZXIgKGZ1biBjaGlsZCAtPiBjaGlsZC5wYXJlbnQgPC0gU29tZSB0YXJnZXQpO1xuICBtdXRhdGVfY2hpbGRfbGlzdCAoZnVuIF8gLT4gZWxlbWVudF9jaGlsZHJlbikgdGFyZ2V0O1xuICBtdXRhdGVfY2hpbGRfbGlzdCAoZnVuIF8gLT4gdGFyZ2V0X2NoaWxkcmVuKSBlbGVtZW50O1xuICByZXBsYWNlIHRhcmdldCBlbGVtZW50XG5cbmxldCB3cmFwIHRhcmdldCBlbGVtZW50ID1cbiAgZGVsZXRlIGVsZW1lbnQ7XG4gIGNsZWFyIGVsZW1lbnQ7XG4gIHJlcGxhY2UgdGFyZ2V0IGVsZW1lbnQ7XG4gIGFwcGVuZF9jaGlsZCBlbGVtZW50IHRhcmdldFxuXG5sZXQgdW53cmFwIG5vZGUgPVxuICBsZXQgcGFyZW50ID1cbiAgICBwYXJlbnQgbm9kZSB8PiByZXF1aXJlX2ludGVybmFsIFwiU291cC51bndyYXA6IG5vZGUgaGFzIG5vIHBhcmVudFwiIGluXG4gIGxldCBpbmRleCA9IGluZGV4X29mIG5vZGUgaW5cbiAgZGVsZXRlIG5vZGU7XG4gIGxldCBjaGlsZHJlbiA9XG4gICAgbWF0Y2ggY2hpbGRfbGlzdCBub2RlIHdpdGhcbiAgICB8IE5vbmUgLT4gW11cbiAgICB8IFNvbWUgbCAtPiBsXG4gIGluXG4gICh0cnkgY2xlYXIgbm9kZVxuICB3aXRoIEZhaWx1cmUgXyAtPiAoKSk7XG4gIExpc3QucmV2IGNoaWxkcmVuIHw+IExpc3QuaXRlciAoaW5zZXJ0X2F0X2luZGV4IGluZGV4IHBhcmVudClcblxubGV0IGFwcGVuZF9yb290IGRvY3VtZW50IG5vZGUgPVxuICBkZWxldGUgbm9kZTtcbiAgbXV0YXRlX2NoaWxkX2xpc3QgKGZ1biBmIC0+IGYgQCBbZm9yZ2V0X3R5cGUgbm9kZV0pIGRvY3VtZW50O1xuICBub2RlLnBhcmVudCA8LSBTb21lIGRvY3VtZW50XG5cbmxldCBwcmVwZW5kX3Jvb3QgZG9jdW1lbnQgbm9kZSA9XG4gIGRlbGV0ZSBub2RlO1xuICBtdXRhdGVfY2hpbGRfbGlzdCAoZnVuIGYgLT4gKGZvcmdldF90eXBlIG5vZGUpOjpmKSBkb2N1bWVudDtcbiAgbm9kZS5wYXJlbnQgPC0gU29tZSBkb2N1bWVudFxuXG5sZXQgc2V0X25hbWUgbmV3X25hbWUgPSBmdW5jdGlvblxuICB8IHt2YWx1ZXMgPSBgRWxlbWVudCBlOyBffSAtPlxuICAgIGUubmFtZSA8LSBuZXdfbmFtZSB8PiBTdHJpbmcudHJpbSB8PiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpXG4gIHwgXyAtPlxuICAgIGZhaWx3aXRoIFwiU291cC5zZXRfbmFtZTogaW50ZXJuYWwgZXJyb3I6IG5vdCBhbiBlbGVtZW50XCIgW0Bjb3ZlcmFnZSBvZmZdXG5cbmxldCBkZWxldGVfYXR0cmlidXRlIG5hbWUgPSBmdW5jdGlvblxuICB8IHt2YWx1ZXMgPSBgRWxlbWVudCBlOyBffSAtPlxuICAgIGUuYXR0cmlidXRlcyA8LVxuICAgICAgZS5hdHRyaWJ1dGVzIHw+IExpc3QuZmlsdGVyIChmdW4gKG5hbWUnLCBfKSAtPiBuYW1lJyA8PiBuYW1lKVxuICB8IF8gLT5cbiAgICBmYWlsd2l0aCBcIlNvdXAuZGVsZXRlX2F0dHJpYnV0ZTogaW50ZXJuYWwgZXJyb3I6IG5vdCBhbiBlbGVtZW50XCJcbiAgICAgIFtAY292ZXJhZ2Ugb2ZmXVxuXG5sZXQgc2V0X2F0dHJpYnV0ZSBuYW1lIHZhbHVlID0gZnVuY3Rpb25cbiAgfCB7dmFsdWVzID0gYEVsZW1lbnQgZTsgX30gLT5cbiAgICBlLmF0dHJpYnV0ZXMgPC1cbiAgICAgIGUuYXR0cmlidXRlc1xuICAgICAgfD4gTGlzdC5maWx0ZXIgKGZ1biAobmFtZScsIF8pIC0+IG5hbWUnIDw+IG5hbWUpXG4gICAgICB8PiBmdW4gYXR0cmlidXRlcyAtPiAobmFtZSwgdmFsdWUpOjphdHRyaWJ1dGVzXG4gIHwgXyAtPlxuICAgIGZhaWx3aXRoIFwiU291cC5zZXRfYXR0cmlidXRlOiBpbnRlcm5hbCBlcnJvcjogbm90IGFuIGVsZW1lbnRcIlxuICAgICAgW0Bjb3ZlcmFnZSBvZmZdXG5cbmxldCBzZXRfY2xhc3NlcyBjbGFzc2VzIGVsZW1lbnQgPVxuICBjbGFzc2VzIHw+IFN0cmluZy5jb25jYXQgXCIgXCIgfD4gZnVuIHYgLT4gc2V0X2F0dHJpYnV0ZSBcImNsYXNzXCIgdiBlbGVtZW50XG5cbmxldCBhZGRfY2xhc3MgY2xhc3NfIGVsZW1lbnQgPVxuICBsZXQgY2xhc3NlcyA9IGNsYXNzZXMgZWxlbWVudCBpblxuICBpZiBMaXN0Lm1lbSBjbGFzc18gY2xhc3NlcyB0aGVuICgpXG4gIGVsc2Ugc2V0X2NsYXNzZXMgKGNsYXNzXzo6Y2xhc3NlcykgZWxlbWVudFxuXG5sZXQgcmVtb3ZlX2NsYXNzIGNsYXNzXyBlbGVtZW50ID1cbiAgY2xhc3NlcyBlbGVtZW50XG4gIHw+IExpc3QuZmlsdGVyIChmdW4gYyAtPiBjIDw+IGNsYXNzXylcbiAgfD4gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGRlbGV0ZV9hdHRyaWJ1dGUgXCJjbGFzc1wiIGVsZW1lbnRcbiAgICB8IHYgLT4gc2V0X2NsYXNzZXMgdiBlbGVtZW50XG5cbmxldCBjcmVhdGVfZWxlbWVudCA/aWQgP2NsYXNzXyA/Y2xhc3NlcyA/KGF0dHJpYnV0ZXMgPSBbXSkgP2lubmVyX3RleHQgbmFtZSA9XG4gIGxldCBjaGlsZHJlbiA9XG4gICAgbWF0Y2ggaW5uZXJfdGV4dCB3aXRoXG4gICAgfCBOb25lIC0+IFtdXG4gICAgfCBTb21lIHMgLT4gW2NyZWF0ZV90ZXh0IHNdXG4gIGluXG5cbiAgbGV0IGVsZW1lbnQgPSBjcmVhdGVfZWxlbWVudCBuYW1lIFtdIGNoaWxkcmVuIGluXG5cbiAgYXR0cmlidXRlcyB8PiBMaXN0Lml0ZXIgKGZ1biAobiwgdikgLT4gc2V0X2F0dHJpYnV0ZSBuIHYgZWxlbWVudCk7XG5cbiAgKG1hdGNoIGNsYXNzZXMgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGNsYXNzZXMgLT5cbiAgICBjbGFzc2VzIHw+IFN0cmluZy5jb25jYXQgXCIgXCIgfD4gZnVuIHYgLT4gc2V0X2F0dHJpYnV0ZSBcImNsYXNzXCIgdiBlbGVtZW50KTtcblxuICAobWF0Y2ggY2xhc3NfIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBjbGFzc18gLT4gc2V0X2F0dHJpYnV0ZSBcImNsYXNzXCIgY2xhc3NfIGVsZW1lbnQpO1xuXG4gIChtYXRjaCBpZCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgaWQgLT4gc2V0X2F0dHJpYnV0ZSBcImlkXCIgaWQgZWxlbWVudCk7XG5cbiAgZWxlbWVudFxuXG5tb2R1bGUgUiA9XG5zdHJ1Y3RcbiAgbGV0IHNlbGVjdF9vbmUgcyBuID1cbiAgICBzZWxlY3Rfb25lIHMgbiB8PiByZXF1aXJlX2ludGVybmFsIFwiU291cC5SLnNlbGVjdF9vbmU6IE5vbmVcIlxuXG4gIGxldCBhdHRyaWJ1dGUgcyBuID1cbiAgICBhdHRyaWJ1dGUgcyBuIHw+IHJlcXVpcmVfaW50ZXJuYWwgXCJTb3VwLlIuYXR0cmlidXRlOiBOb25lXCJcblxuICBsZXQgaWQgbiA9XG4gICAgaWQgbiB8PiByZXF1aXJlX2ludGVybmFsIFwiU291cC5SLmlkOiBOb25lXCJcblxuICBsZXQgZWxlbWVudCBuID1cbiAgICBlbGVtZW50IG4gfD4gcmVxdWlyZV9pbnRlcm5hbCBcIlNvdXAuUi5lbGVtZW50OiBOb25lXCJcblxuICBsZXQgbGVhZl90ZXh0IG4gPVxuICAgIGxlYWZfdGV4dCBuIHw+IHJlcXVpcmVfaW50ZXJuYWwgXCJTb3VwLlIubGVhZl90ZXh0OiBOb25lXCJcblxuICBsZXQgbnRoIG4gdCA9XG4gICAgbnRoIG4gdCB8PiByZXF1aXJlX2ludGVybmFsIFwiU291cC5SLm50aDogTm9uZVwiXG5cbiAgbGV0IGZpcnN0IHQgPVxuICAgIGZpcnN0IHQgfD4gcmVxdWlyZV9pbnRlcm5hbCBcIlNvdXAuUi5maXJzdDogTm9uZVwiXG5cbiAgbGV0IGxhc3QgdCA9XG4gICAgbGFzdCB0IHw+IHJlcXVpcmVfaW50ZXJuYWwgXCJTb3VwLlIubGFzdDogTm9uZVwiXG5cbiAgbGV0IHRhZyBzIG4gPVxuICAgIHRhZyBzIG4gfD4gcmVxdWlyZV9pbnRlcm5hbCBcIlNvdXAuUi50YWc6IE5vbmVcIlxuXG4gIGxldCBwYXJlbnQgbiA9XG4gICAgcGFyZW50IG4gfD4gcmVxdWlyZV9pbnRlcm5hbCBcIlNvdXAuUi5wYXJlbnQ6IE5vbmVcIlxuXG4gIGxldCBjaGlsZCBuID1cbiAgICBjaGlsZCBuIHw+IHJlcXVpcmVfaW50ZXJuYWwgXCJTb3VwLlIuY2hpbGQ6IE5vbmVcIlxuXG4gIGxldCBjaGlsZF9lbGVtZW50IG4gPVxuICAgIGNoaWxkX2VsZW1lbnQgbiB8PiByZXF1aXJlX2ludGVybmFsIFwiU291cC5SLmNoaWxkX2VsZW1lbnQ6IE5vbmVcIlxuXG4gIGxldCBuZXh0X3NpYmxpbmcgbiA9XG4gICAgbmV4dF9zaWJsaW5nIG4gfD4gcmVxdWlyZV9pbnRlcm5hbCBcIlNvdXAuUi5uZXh0X3NpYmxpbmc6IE5vbmVcIlxuXG4gIGxldCBwcmV2aW91c19zaWJsaW5nIG4gPVxuICAgIHByZXZpb3VzX3NpYmxpbmcgbiB8PiByZXF1aXJlX2ludGVybmFsIFwiU291cC5SLnByZXZpb3VzX3NpYmxpbmc6IE5vbmVcIlxuXG4gIGxldCBuZXh0X2VsZW1lbnQgbiA9XG4gICAgbmV4dF9lbGVtZW50IG4gfD4gcmVxdWlyZV9pbnRlcm5hbCBcIlNvdXAuUi5uZXh0X2VsZW1lbnQ6IE5vbmVcIlxuXG4gIGxldCBwcmV2aW91c19lbGVtZW50IG4gPVxuICAgIHByZXZpb3VzX2VsZW1lbnQgbiB8PiByZXF1aXJlX2ludGVybmFsIFwiU291cC5SLnByZXZpb3VzX2VsZW1lbnQ6IE5vbmVcIlxuZW5kXG5cbmxldCByZWFkX2NoYW5uZWwgY2hhbm5lbCA9IE1hcmt1cC5jaGFubmVsIGNoYW5uZWwgfD4gTWFya3VwLnRvX3N0cmluZ1xuXG5sZXQgcmVhZF9maWxlIHBhdGggPSBNYXJrdXAuZmlsZSBwYXRoIHw+IGZzdCB8PiBNYXJrdXAudG9fc3RyaW5nXG5cbmxldCB3cml0ZV9jaGFubmVsID0gb3V0cHV0X3N0cmluZ1xuXG5sZXQgd3JpdGVfZmlsZSBwYXRoIGRhdGEgPVxuICBNYXJrdXAuc3RyaW5nIGRhdGEgfD4gTWFya3VwLnRvX2ZpbGUgcGF0aFxuICBbQEBjb3ZlcmFnZSBvZmZdXG4iXX0=
