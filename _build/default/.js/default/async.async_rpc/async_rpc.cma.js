// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Async_rpc__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Async_rpc = [0],
    Async_rpc$0 = [0, Async_rpc];
   runtime.caml_register_global(0, Async_rpc$0, "Async_rpc__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_rpc__Import
//# unitInfo: Requires: Async_kernel, Async_log, Async_unix, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_rpc_Import = "Async_rpc__Import",
    cst_async_rpc = "async_rpc";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel = global_data.Async_kernel,
    Async_log = global_data.Async_log,
    Async_unix = global_data.Async_unix;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_rpc_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_rpc);
   caml_call1(Ppx_expect_runtime[1][1], "async_rpc/src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_rpc, "import.ml");
   var
    catch$0 = Async_kernel[3],
    choice = Async_kernel[4],
    choose = Async_kernel[5],
    don_t_wait_for = Async_kernel[6],
    never = Async_kernel[8],
    try_with = Async_kernel[11],
    upon = Async_kernel[12],
    with_timeout_exn = Async_kernel[14],
    symbol = Async_kernel[17],
    symbol$0 = Async_kernel[18],
    symbol$1 = Async_kernel[19],
    return$0 = Async_kernel[20],
    symbol_bind = Async_kernel[21],
    symbol_map = Async_kernel[22],
    Let_syntax = Async_kernel[23],
    Async_kernel_private = Async_kernel[24],
    Ppx_log_syntax = Async_log[39][1],
    Unix = Async_unix[1],
    after = Async_unix[2],
    at = Async_unix[3],
    every = Async_unix[4],
    with_timeout = Async_unix[5],
    schedule = Async_unix[6],
    schedule$0 = Async_unix[7],
    shutdown = Async_unix[8],
    within = Async_unix[9],
    within$0 = Async_unix[10],
    Printf = Async_unix[11],
    Overwrite = Async_unix[12],
    close_in_noerr = Async_unix[13],
    close_in = Async_unix[14],
    close_out_noerr = Async_unix[15],
    close_out = Async_unix[16],
    eprintf = Async_unix[17],
    flush_all = Async_unix[18],
    flush = Async_unix[19],
    fprintf = Async_unix[20],
    ifprintf = Async_unix[21],
    in_channel_length = Async_unix[22],
    input_binary_int = Async_unix[23],
    input_byte = Async_unix[24],
    input_char = Async_unix[25],
    input_line = Async_unix[26],
    input_lines = Async_unix[27],
    input = Async_unix[28],
    input_value = Async_unix[29],
    open_in_bin = Async_unix[30],
    open_in_gen = Async_unix[31],
    open_in = Async_unix[32],
    open_out_bin = Async_unix[33],
    open_out_gen = Async_unix[34],
    open_out = Async_unix[35],
    out_channel_length = Async_unix[36],
    output_binary_int = Async_unix[37],
    output_byte = Async_unix[38],
    output_char = Async_unix[39],
    output = Async_unix[40],
    output_string = Async_unix[41],
    output_value = Async_unix[42],
    pos_in = Async_unix[43],
    pos_out = Async_unix[44],
    prerr_char = Async_unix[45],
    prerr_endline = Async_unix[46],
    prerr_float = Async_unix[47],
    prerr_int = Async_unix[48],
    prerr_newline = Async_unix[49],
    prerr_string = Async_unix[50],
    print_char = Async_unix[51],
    print_endline = Async_unix[52],
    print_float = Async_unix[53],
    printf = Async_unix[54],
    print_int = Async_unix[55],
    print_newline = Async_unix[56],
    print_s = Async_unix[57],
    print_string = Async_unix[58],
    read_float = Async_unix[59],
    read_int = Async_unix[60],
    read_line = Async_unix[61],
    read_lines = Async_unix[62],
    read_wrap = Async_unix[63],
    really_input = Async_unix[64],
    seek_in = Async_unix[65],
    seek_out = Async_unix[66],
    set_binary_mode_in = Async_unix[67],
    set_binary_mode_out = Async_unix[68],
    write_lines = Async_unix[69],
    write_wrap = Async_unix[70],
    eprint_s = Async_unix[71],
    eprint_s_nonblocking = Async_unix[72],
    LargeFile = Async_unix[73],
    Sexp = Async_unix[74],
    exit = Async_unix[75],
    Async_unix_private = Async_unix[76];
   caml_call1(Ppx_inline_test_lib[7], cst_async_rpc);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_rpc_Import);
   var
    Async_rpc_Import =
      [0,
       catch$0,
       choice,
       choose,
       don_t_wait_for,
       never,
       try_with,
       upon,
       with_timeout_exn,
       symbol,
       symbol$0,
       symbol$1,
       return$0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Async_kernel_private,
       Ppx_log_syntax,
       Unix,
       after,
       at,
       every,
       with_timeout,
       schedule,
       schedule$0,
       shutdown,
       within,
       within$0,
       Printf,
       Overwrite,
       close_in_noerr,
       close_in,
       close_out_noerr,
       close_out,
       eprintf,
       flush_all,
       flush,
       fprintf,
       ifprintf,
       in_channel_length,
       input_binary_int,
       input_byte,
       input_char,
       input_line,
       input_lines,
       input,
       input_value,
       open_in_bin,
       open_in_gen,
       open_in,
       open_out_bin,
       open_out_gen,
       open_out,
       out_channel_length,
       output_binary_int,
       output_byte,
       output_char,
       output,
       output_string,
       output_value,
       pos_in,
       pos_out,
       prerr_char,
       prerr_endline,
       prerr_float,
       prerr_int,
       prerr_newline,
       prerr_string,
       print_char,
       print_endline,
       print_float,
       printf,
       print_int,
       print_newline,
       print_s,
       print_string,
       read_float,
       read_int,
       read_line,
       read_lines,
       read_wrap,
       really_input,
       seek_in,
       seek_out,
       set_binary_mode_in,
       set_binary_mode_out,
       write_lines,
       write_wrap,
       eprint_s,
       eprint_s_nonblocking,
       LargeFile,
       Sexp,
       exit,
       Async_unix_private];
   runtime.caml_register_global(14, Async_rpc_Import, cst_Async_rpc_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_rpc__Rpc_transport_low_latency
//# unitInfo: Requires: Async_kernel__Clock_ns, Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel__Monitor, Async_log, Async_rpc__Import, Async_rpc_kernel__Transport, Async_unix__Fd, Async_unix__Scheduler, Bigstring_unix, Core, Core__Bigstring, Core__Int, Core__Int63, Core__Ordered_collection_common, Core__Queue, Core__Time_ns, Core_unix, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_log_types__Message_sexp, Ppx_log_types__Message_source, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_record
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$3 = "",
    cst_did_not_match_expected_len = ") did not match expected length (",
    cst_Async_rpc_Rpc_transport_lo$1 = "Async_rpc__Rpc_transport_low_latency",
    cst_async_rpc$0 = "async_rpc",
    cst_async_rpc_src_rpc_transpor$0 =
      "async_rpc/src/rpc_transport_low_latency.ml",
    cst_buf = "buf",
    cst_buffering_threshold_in_byt$0 = "buffering_threshold_in_bytes",
    cst_close_finished = "close_finished",
    cst_config = "config",
    cst_fd = "fd",
    cst_initial_buffer_size$0 = "initial_buffer_size",
    cst_max_buffer_size$0 = "max_buffer_size",
    cst_max_message_size$0 = "max_message_size",
    cst_pos = "pos",
    cst_start_batching_after_num_m$0 = "start_batching_after_num_messages",
    cst_t$0 = "t",
    cst_write_timeout$0 = "write_timeout",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$3,
    cst$0 = cst$3,
    cst$1 = cst$3,
    cst = cst$3,
    error_source_002 = "async_rpc/src/rpc_transport_low_latency.ml.Config.t",
    Core = global_data.Core,
    Ppx_log_types_Message_source = global_data.Ppx_log_types__Message_source,
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_log_types_Message_sexp = global_data.Ppx_log_types__Message_sexp,
    Async_log = global_data.Async_log,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_unix_Fd = global_data.Async_unix__Fd,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Async_rpc_Import = global_data.Async_rpc__Import,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_Bigstring = global_data.Core__Bigstring,
    Core_Ordered_collection_common =
      global_data.Core__Ordered_collection_common,
    Async_rpc_kernel_Transport = global_data.Async_rpc_kernel__Transport,
    Assert_failure = global_data.Assert_failure,
    Core_unix = global_data.Core_unix,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_unix_Scheduler = global_data.Async_unix__Scheduler,
    Bigstring_unix = global_data.Bigstring_unix,
    Core_Int63 = global_data.Core__Int63,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Int = global_data.Core__Int,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_rpc_Rpc_transport_lo$1);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_rpc$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_async_rpc_src_rpc_transpor$0);
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_rpc$0, "rpc_transport_low_latency.ml");
   var
    default_write_timeout = caml_call1(Core_Time_ns[1][83], 2.),
    default_max_message_size = Core_Int[45],
    default_max_buffer_size = Core_Int[45],
    _ar_ = [0, "writer"],
    _as_ = [0, "reader"],
    _al_ = [0, "Bad_fd"],
    _am_ = [0, "Closed"],
    cst_Async_rpc_Rpc_transport_lo = cst_Async_rpc_Rpc_transport_lo$1,
    cst_async_rpc_src_rpc_transpor = cst_async_rpc_src_rpc_transpor$0,
    cst_t = cst_t$0,
    cst_timeout = "timeout",
    _aj_ =
      [0,
       [1,
        "Rpc_transport_low_latency.Writer timed out waiting to write on file descriptor. Closing the writer."]],
    _ak_ = [0, 106380200],
    _ai_ = [0, 106380200],
    _an_ = [0, "ready_to_result"],
    _ao_ = [0, cst_t$0],
    cst_Rpc_transport_low_latency_$11 =
      "Rpc_transport_low_latency.Writer: fd changed",
    _aq_ = [0, 0, 0],
    _ap_ = [0, cst_async_rpc_src_rpc_transpor$0, 875, 6],
    cst_write = "write",
    cst_writev = "writev",
    _ah_ = [0, 0],
    _ag_ = [0, cst_async_rpc_src_rpc_transpor$0, 699, 4],
    _X_ = [0, "sends_in_this_job"],
    _Y_ = [0, "last_send_job"],
    _Z_ = [0, "flushes"],
    ___ = [0, "monitor"],
    _$_ = [0, "bytes_written"],
    _aa_ = [0, cst_pos],
    _ab_ = [0, cst_buf],
    _ac_ = [0, "writing"],
    _ad_ = [0, "connection_state"],
    _ae_ = [0, cst_config],
    _af_ = [0, cst_fd],
    _U_ = [0, "connection_lost"],
    _V_ = [0, cst_close_finished],
    _W_ = [0, "close_started"],
    _S_ = [0, "ivar"],
    _T_ = [0, cst_pos],
    cst_Rpc_transport_low_latency_$10 =
      "Rpc_transport_low_latency.Reader_internal.peek_once_without_buffering_from_socket",
    _R_ =
      [0,
       [11,
        "peek_bin_prot: message length (",
        [4,
         0,
         0,
         0,
         [11, cst_did_not_match_expected_len, [4, 0, 0, 0, [12, 41, 0]]]]],
       "peek_bin_prot: message length (%d) did not match expected length (%d)"],
    cst_Rpc_transport_low_latency_$9 =
      "Rpc_transport_low_latency.Reader_internal.peek_bin_prot",
    _Q_ =
      [0,
       [11,
        "message length (",
        [4,
         0,
         0,
         0,
         [11, cst_did_not_match_expected_len, [4, 0, 0, 0, [12, 41, 0]]]]],
       "message length (%d) did not match expected length (%d)"],
    cst_Rpc_transport_low_latency_$8 =
      "Rpc_transport_low_latency.Reader_internal.read_forever",
    cst_Rpc_transport_low_latency_$6 =
      "Rpc_transport_low_latency.Reader: reader closed",
    _L_ = [0, cst_async_rpc_src_rpc_transpor$0, 483, 16301, 16315],
    cst_Rpc_transport_low_latency_$7 =
      "Rpc_transport_low_latency.Reader: already reading",
    _M_ = [0, cst_async_rpc_src_rpc_transpor$0, 490, 16462, 16476],
    _N_ = [0, -146189108],
    _O_ = [0, 3903734],
    _P_ = [0, [0, cst_async_rpc_src_rpc_transpor$0, 498, 16661, 16673]],
    _C_ = [1, -1025106484],
    cst_Rpc_transport_low_latency_$2 =
      "Rpc_transport_low_latency.Reader.read_forever: file descriptor doesn't support watching",
    _B_ = [1, 3456156],
    _E_ = [0, cst_async_rpc_src_rpc_transpor$0, 392, 11],
    _D_ = [1, -1025106484],
    _z_ = [0, "Rpc_transport_low_latency.Reader_internal.Dispatcher.run"],
    _A_ = [0, [0, cst_async_rpc_src_rpc_transpor$0, 363, 11463, 11479]],
    _K_ = [0, 0],
    cst_Rpc_transport_low_latency_$5 =
      "Rpc_transport_low_latency.Reader_internal.Dispatcher.peek_once_without_buffering_from_socket: on_message returned unexpected value",
    cst_Rpc_transport_low_latency_$3 =
      "Rpc_transport_low_latency.Reader_internal.Dispatcher.peek_once_without_buffering_from_socket file descriptor doesn't support watching",
    _H_ = [1, 658743757],
    cst_Rpc_transport_low_latency_$4 =
      "Rpc_transport_low_latency.Reader_internal.Dispatcher.peek_once_without_buffering_from_socket: unexpected state Waiting_for_handler",
    _J_ = [0, cst_async_rpc_src_rpc_transpor$0, 464, 11],
    _I_ = [1, -1025106484],
    _F_ =
      [0,
       "Rpc_transport_low_latency.Reader_internal.Dispatcher.peek_once_without_buffering_from_socket"],
    _G_ = [0, [0, cst_async_rpc_src_rpc_transpor$0, 418, 13565, 13581]],
    _y_ = [0, cst_async_rpc_src_rpc_transpor$0, 302, 6],
    _x_ = [0, cst_async_rpc_src_rpc_transpor$0, 247, 8],
    cst_read = "read",
    cst_BUG_Rpc_Low_latency_transp =
      "BUG: Rpc.Low_latency_transport's reader has buffered messages that are unprocessed.",
    cst_Message_len_value_exn_of_N = "Message_len.value_exn of None",
    _w_ =
      [0,
       [11, "Message_len.create_exn of negative int: ", [4, 0, 0, 0, 0]],
       "Message_len.create_exn of negative int: %d"],
    _n_ = [0, "bytes_read"],
    _o_ = [0, "max"],
    _p_ = [0, cst_pos],
    _q_ = [0, cst_buf],
    _r_ = [0, cst_close_finished],
    _s_ = [0, "closed"],
    _t_ = [0, "reading"],
    _u_ = [0, cst_config],
    _v_ = [0, cst_fd],
    _m_ = [0, 1],
    _l_ = [0, cst_async_rpc_src_rpc_transpor$0, 104, 4],
    _j_ = [0, cst_config],
    _k_ = [0, "new_size_request"],
    cst_Rpc_transport_low_latency_$1 =
      "Rpc_transport_low_latency: cannot grow buffer",
    _h_ = [0, cst_config],
    _i_ = [0, "message_size"],
    cst_Rpc_transport_low_latency_$0 =
      "Rpc_transport_low_latency: message too small or too big",
    cst_Rpc_transport_low_latency_ =
      "Rpc_transport_low_latency.Config.validate: invalid config",
    _g_ = [0, cst_async_rpc_src_rpc_transpor$0, 60, 2026, 2040],
    _a_ = [0, cst_start_batching_after_num_m$0],
    _b_ = [0, cst_buffering_threshold_in_byt$0],
    _c_ = [0, cst_write_timeout$0],
    _d_ = [0, cst_max_buffer_size$0],
    _e_ = [0, cst_initial_buffer_size$0],
    _f_ = [0, cst_max_message_size$0],
    cst_start_batching_after_num_m = cst_start_batching_after_num_m$0,
    cst_buffering_threshold_in_byt = cst_buffering_threshold_in_byt$0,
    cst_write_timeout = cst_write_timeout$0,
    cst_max_buffer_size = cst_max_buffer_size$0,
    cst_initial_buffer_size = cst_initial_buffer_size$0,
    cst_max_message_size = cst_max_message_size$0,
    cst_async_rpc = cst_async_rpc$0,
    cst_Async_rpc_Rpc_transport_lo$0 = cst_Async_rpc_Rpc_transport_lo$1,
    default_start_batching_after_n = 2,
    default_initial_buffer_size = 65536,
    default_buffering_threshold_in = 32768;
   function sexp_of_t(param){
    var
     start_batching_after_num_messa = param[6],
     buffering_threshold_in_bytes_0 = param[5],
     write_timeout_017 = param[4],
     max_buffer_size_015 = param[3],
     initial_buffer_size_013 = param[2],
     max_message_size_011 = param[1],
     arg_022 = caml_call1(Core[389], start_batching_after_num_messa),
     bnds_010 = [0, [1, [0, _a_, [0, arg_022, 0]]], 0],
     arg_020 = caml_call1(Core[389], buffering_threshold_in_bytes_0),
     bnds_010$0 = [0, [1, [0, _b_, [0, arg_020, 0]]], bnds_010],
     arg_018 = caml_call1(Core_Time_ns[1][10], write_timeout_017),
     bnds_010$1 = [0, [1, [0, _c_, [0, arg_018, 0]]], bnds_010$0],
     arg_016 = caml_call1(Core[389], max_buffer_size_015),
     bnds_010$2 = [0, [1, [0, _d_, [0, arg_016, 0]]], bnds_010$1],
     arg_014 = caml_call1(Core[389], initial_buffer_size_013),
     bnds_010$3 = [0, [1, [0, _e_, [0, arg_014, 0]]], bnds_010$2],
     arg_012 = caml_call1(Core[389], max_message_size_011),
     bnds_010$4 = [0, [1, [0, _f_, [0, arg_012, 0]]], bnds_010$3];
    return [1, bnds_010$4];
   }
   function validate(t){
    var _cO_ = caml_call2(Core[89], t[2], 0);
    if(_cO_)
     var _cP_ = _cO_;
    else{
     var _cQ_ = caml_call2(Core[89], t[1], 0);
     if(_cQ_)
      var _cP_ = _cQ_;
     else{
      var _cR_ = caml_call2(Core[91], t[2], t[3]);
      if(_cR_)
       var _cP_ = _cR_;
      else{
       var _cS_ = caml_call2(Core[91], t[1], t[3]);
       if(_cS_)
        var _cP_ = _cS_;
       else{
        var _cT_ = caml_call2(Core[92], t[5], 0);
        if(_cT_)
         var _cP_ = _cT_;
        else
         var
          _cU_ = caml_call2(Core[92], t[6], 0),
          _cP_ =
            _cU_ || caml_call2(Core_Time_ns[1][16], t[4], Core_Time_ns[1][76]);
       }
      }
     }
    }
    if(_cP_)
     caml_call5
      (Core[247], 0, _g_, cst_Rpc_transport_low_latency_, t, sexp_of_t);
    return t;
   }
   function t_of_sexp(x_009){
    function _cu_(param){
     var
      _cK_ = param[2],
      _cL_ = _cK_[2],
      _cM_ = _cL_[2],
      _cN_ = _cM_[2],
      start_batching_after_num_messa = _cN_[2][1],
      buffering_threshold_in_bytes = _cN_[1],
      write_timeout = _cM_[1],
      max_buffer_size = _cL_[1],
      initial_buffer_size = _cK_[1],
      max_message_size = param[1];
     return [0,
             max_message_size,
             initial_buffer_size,
             max_buffer_size,
             write_timeout,
             buffering_threshold_in_bytes,
             start_batching_after_num_messa];
    }
    var _cv_ = 0;
    function _cw_(param){
     return caml_string_notequal(param, cst_buffering_threshold_in_byt$0)
             ? caml_string_notequal
                (param, cst_initial_buffer_size$0)
               ? caml_string_notequal
                  (param, cst_max_buffer_size$0)
                 ? caml_string_notequal
                    (param, cst_max_message_size$0)
                   ? caml_string_notequal
                      (param, cst_start_batching_after_num_m$0)
                     ? caml_string_notequal(param, cst_write_timeout$0) ? -1 : 3
                     : 5
                   : 0
                 : 2
               : 1
             : 4;
    }
    var
     _cx_ = 0,
     _cy_ = Core[390],
     _cz_ =
       [0,
        cst_start_batching_after_num_m,
        [0, function(param){return default_start_batching_after_n;}],
        _cy_,
        _cx_],
     _cA_ = Core[390],
     _cB_ =
       [0,
        cst_buffering_threshold_in_byt,
        [0, function(param){return default_buffering_threshold_in;}],
        _cA_,
        _cz_],
     _cC_ = Core_Time_ns[1][9],
     _cD_ =
       [0,
        cst_write_timeout,
        [0, function(param){return default_write_timeout;}],
        _cC_,
        _cB_],
     _cE_ = Core[390],
     _cF_ =
       [0,
        cst_max_buffer_size,
        [0, function(param){return default_max_buffer_size;}],
        _cE_,
        _cD_],
     _cG_ = Core[390],
     _cH_ =
       [0,
        cst_initial_buffer_size,
        [0, function(param){return default_initial_buffer_size;}],
        _cG_,
        _cF_],
     _cI_ = Core[390],
     _cJ_ =
       [0,
        cst_max_message_size,
        [0, function(param){return default_max_message_size;}],
        _cI_,
        _cH_];
    return validate
            (caml_call6
              (Sexplib0_Sexp_conv_record[3],
               error_source_002,
               _cJ_,
               _cw_,
               _cv_,
               _cu_,
               x_009));
   }
   function create(opt, _ct_, _cs_, _cr_, _cq_, _cp_, param){
    if(opt)
     var sth = opt[1], max_message_size = sth;
    else
     var max_message_size = default_max_message_size;
    if(_ct_)
     var sth$0 = _ct_[1], initial_buffer_size = sth$0;
    else
     var initial_buffer_size = default_initial_buffer_size;
    if(_cs_)
     var sth$1 = _cs_[1], max_buffer_size = sth$1;
    else
     var max_buffer_size = default_max_buffer_size;
    if(_cr_)
     var sth$2 = _cr_[1], write_timeout = sth$2;
    else
     var write_timeout = default_write_timeout;
    if(_cq_)
     var sth$3 = _cq_[1], buffering_threshold_in_bytes = sth$3;
    else
     var buffering_threshold_in_bytes = default_buffering_threshold_in;
    if(_cp_)
     var sth$4 = _cp_[1], start_batching_after_num_messa = sth$4;
    else
     var start_batching_after_num_messa = default_start_batching_after_n;
    return validate
            ([0,
              max_message_size,
              initial_buffer_size,
              max_buffer_size,
              write_timeout,
              buffering_threshold_in_bytes,
              start_batching_after_num_messa]);
   }
   var default$0 = create(0, 0, 0, 0, 0, 0, 0);
   function message_size_ok(t, payload_len){
    var _co_ = caml_call2(Core[88], payload_len, 0);
    return _co_ ? caml_call2(Core[89], payload_len, t[1]) : _co_;
   }
   function grow_buffer(t, buf, new_size_request){
    var _cj_ = caml_call1(Core_Bigstring[21], buf);
    if(! caml_call2(Core[91], new_size_request, _cj_))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(caml_call2(Core[91], new_size_request, t[3])){
     var
      _ck_ = [0, [1, [0, _j_, [0, sexp_of_t(t), 0]]], 0],
      _cl_ =
        [0,
         [1,
          [0,
           [1, [0, _k_, [0, caml_call1(Core[389], new_size_request), 0]]],
           _ck_]],
         0],
      _cm_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Rpc_transport_low_latency_$1),
          _cl_]];
     caml_call1(Core[261], _cm_);
    }
    var
     _cn_ = caml_call1(Core_Int[48], new_size_request),
     len = caml_call2(Core_Int[89], t[3], _cn_);
    return runtime.bigstring_realloc(buf, len);
   }
   function set_nonblocking(fd){
    function _ch_(_ci_){return 0;}
    return caml_call3(Async_unix_Fd[23], _m_, fd, _ch_);
   }
   function sexp_of_t$0(param){
    var
     config_026 = param[2],
     fd_024 = param[1],
     reading_028 = param[3],
     closed_030 = param[4],
     close_finished_032 = param[5],
     buf_034 = param[6],
     pos_036 = param[7],
     max_038 = param[8],
     bytes_read_040 = param[9],
     arg_041 = caml_call1(Core_Int63[103], bytes_read_040),
     bnds_023 = [0, [1, [0, _n_, [0, arg_041, 0]]], 0],
     arg_039 = caml_call1(Core[389], max_038),
     bnds_023$0 = [0, [1, [0, _o_, [0, arg_039, 0]]], bnds_023],
     arg_037 = caml_call1(Core[389], pos_036),
     bnds_023$1 = [0, [1, [0, _p_, [0, arg_037, 0]]], bnds_023$0],
     arg_035 = caml_call1(Sexplib0_Sexp_conv[23], buf_034),
     bnds_023$2 = [0, [1, [0, _q_, [0, arg_035, 0]]], bnds_023$1],
     arg_033 = caml_call2(Async_kernel_Ivar[9], Core[620], close_finished_032),
     bnds_023$3 = [0, [1, [0, _r_, [0, arg_033, 0]]], bnds_023$2],
     arg_031 = caml_call1(Core[323], closed_030),
     bnds_023$4 = [0, [1, [0, _s_, [0, arg_031, 0]]], bnds_023$3],
     arg_029 = caml_call1(Core[323], reading_028),
     bnds_023$5 = [0, [1, [0, _t_, [0, arg_029, 0]]], bnds_023$4],
     arg_027 = sexp_of_t(config_026),
     bnds_023$6 = [0, [1, [0, _u_, [0, arg_027, 0]]], bnds_023$5],
     arg_025 = caml_call1(Async_unix_Fd[2], fd_024),
     bnds_023$7 = [0, [1, [0, _v_, [0, arg_025, 0]]], bnds_023$6];
    return [1, bnds_023$7];
   }
   function is_closed(t){return t[4];}
   function close_finished(t){return caml_call1(Async_kernel_Ivar[19], t[5]);}
   function bytes_read(t){return t[9];}
   var none = -1;
   function is_running(t){return t[5] ? 0 : 1;}
   function interrupt(t, reason){
    if(! is_running(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
    t[5] = [0, reason];
    return caml_call2(Async_kernel_Ivar[14], t[4], 0);
   }
   function can_process_message(t){
    var _cg_ = 1 - t[1][4];
    return _cg_ ? is_running(t) : _cg_;
   }
   function process_received_messages(t$0, read_or_peek){
    for(;;){
     var _cd_ = can_process_message(t$0);
     if(! _cd_) return _cd_;
     var t$1 = t$0[1], pos = t$1[7], available = t$1[8] - pos | 0;
     if(caml_call2(Core[88], available, Async_rpc_kernel_Transport[1][1])){
      var
       payload_len = caml_call2(Async_rpc_kernel_Transport[1][2], t$1[6], pos),
       total_len = payload_len + Async_rpc_kernel_Transport[1][1] | 0,
       t = t$1[2];
      if(1 - message_size_ok(t, payload_len)){
       var
        _b$_ = [0, [1, [0, _h_, [0, sexp_of_t(t), 0]]], 0],
        _ca_ =
          [0,
           [1,
            [0,
             [1, [0, _i_, [0, caml_call1(Core[389], payload_len), 0]]],
             _b$_]],
           0],
        _cb_ =
          [1,
           [0,
            caml_call1
             (Sexplib0_Sexp_conv[7], cst_Rpc_transport_low_latency_$0),
            _ca_]];
       caml_call1(Core[261], _cb_);
      }
      if(caml_call2(Core[89], total_len, available))
       var
        len =
          caml_call2(Core[92], payload_len, 0)
           ? caml_call3(Core[246], _w_, payload_len, 0)
           : payload_len;
      else{
       var _cc_ = caml_call1(Core_Bigstring[21], t$1[6]);
       if(caml_call2(Core[91], total_len, _cc_))
        t$1[6] = grow_buffer(t$1[2], t$1[6], total_len);
       var len = none;
      }
     }
     else
      var len = none;
     if(! caml_call2(Core[88], len, 0)) return caml_call1(t$0[3], 0);
     var
      len$0 =
        caml_call2(Core[92], len, 0)
         ? caml_call1(Core[6], cst_Message_len_value_exn_of_N)
         : len,
      start = t$0[1][7] + Async_rpc_kernel_Transport[1][1] | 0;
     if(914388854 <= read_or_peek){
      var
       _ce_ = caml_call1(Core_Int63[72], len$0),
       _cf_ = caml_call2(Core_Int63[19], t$0[1][9], _ce_);
      t$0[1][9] = _cf_;
      t$0[1][7] = start + len$0 | 0;
     }
     var match = caml_call3(t$0[2], t$0[1][6], start, len$0);
     if(typeof match !== "number"){
      if(0 === match[0]){var x = match[1]; return interrupt(t$0, [1, x]);}
      var d = match[1];
      if(! caml_call1(Async_kernel_Deferred[7], d))
       return interrupt(t$0, [0, d]);
     }
    }
   }
   function stop_watching_on_error(t, monitor){
    var parent = caml_call1(Async_kernel_Monitor[5], 0);
    function _b__(exn){
     if(is_running(t)) interrupt(t, 0);
     return caml_call3(Async_kernel_Monitor[15], parent, 0, exn);
    }
    return caml_call2(Async_kernel_Monitor[7], monitor, _b__);
   }
   function run
   (reader, allow_buffering, on_message, on_end_of_batch, read_or_peek){
    var
     t =
       [0,
        reader,
        on_message,
        on_end_of_batch,
        caml_call1(Async_kernel_Ivar[12], 0),
        0],
     monitor = caml_call4(Async_kernel_Monitor[3], _A_, 0, _z_, 0);
    stop_watching_on_error(t, monitor);
    function _bT_(param){
     if(-18684779 <= param)
      return caml_call1(Core[6], cst_Rpc_transport_low_latency_$2);
     var _b8_ = t[5];
     if(! _b8_){
      if(! caml_call1(Async_unix_Fd[16], t[1][1]) && ! t[1][4])
       throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
      return caml_call1(Async_rpc_Import[12], _D_);
     }
     var match = _b8_[1];
     if(typeof match === "number")
      return 0 === match
              ? caml_call1(Async_kernel_Deferred[19], 0)
              : caml_call1(Async_rpc_Import[12], _B_);
     if(0 === match[0]){
      var
       d = match[1],
       _b9_ =
         function(param){
          return reader[4]
                  ? caml_call1(Async_rpc_Import[12], _C_)
                  : run
                    (reader,
                     allow_buffering,
                     on_message,
                     on_end_of_batch,
                     read_or_peek);
         };
      return caml_call2(Async_rpc_Import[15][2], d, _b9_);
     }
     var x = match[1];
     return caml_call1(Async_rpc_Import[12], [0, x]);
    }
    function _bU_(param){
     process_received_messages(t, read_or_peek);
     var
      _bW_ = [0, close_finished(t[1]), 0],
      _bX_ = [0, caml_call1(Async_kernel_Ivar[19], t[4]), _bW_],
      interrupt$0 = caml_call1(Async_kernel_Deferred[23], _bX_);
     function _bY_(t$0){
      var _b6_ = can_process_message(t$0);
      if(_b6_){
       var t = t$0[1];
       if(caml_call2(Core[91], t[7], 0)){
        var len = t[8] - t[7] | 0;
        if(caml_call2(Core[91], len, 0))
         caml_call5(Core_Bigstring[22], t[6], t[7], t[6], 0, len);
        t[7] = 0;
        t[8] = len;
       }
       var
        _b0_ = t[8],
        available_buffer_capacity =
          caml_call1(Core_Bigstring[21], t[6]) - _b0_ | 0;
       if(allow_buffering)
        var len$0 = available_buffer_capacity;
       else{
        var pos = t[7], available = t[8] - pos | 0;
        if(caml_call2(Core[92], available, Async_rpc_kernel_Transport[1][1]))
         var _b5_ = Async_rpc_kernel_Transport[1][1] - available | 0;
        else{
         var
          payload_len =
            caml_call2(Async_rpc_kernel_Transport[1][2], t[6], pos),
          total_len = payload_len + Async_rpc_kernel_Transport[1][1] | 0;
         if(caml_call2(Core[92], available, total_len))
          var _b5_ = total_len - available | 0;
         else
          var
           _bZ_ =
             caml_call1(Sexplib0_Sexp_conv[7], cst_BUG_Rpc_Low_latency_transp),
           _b5_ = caml_call1(Core[261], _bZ_);
        }
        var len$0 = caml_call2(Core_Int[89], _b5_, available_buffer_capacity);
       }
       var
        _b1_ = t[6],
        _b2_ = [0, t[8]],
        _b3_ = caml_call1(Async_unix_Fd[40], t[1]),
        result = caml_call4(Bigstring_unix[131], _b3_, _b2_, [0, len$0], _b1_);
       a:
       {
        if(! caml_call1(Core_unix[5][2][6], result)){
         var error = caml_call1(Core_unix[5][2][10], result);
         b:
         if(typeof error === "number"){
          if(31 <= error){
           var _b4_ = error - 32 | 0;
           if(19 < _b4_ >>> 0){
            if(0 <= _b4_)
             switch(_b4_ - 20 | 0){
               case 0:
               case 1:
               case 2:
               case 4:
               case 10:
               case 13: break;
               default: break b;
             }
            var match = 3456156;
            break a;
           }
           if(5 !== _b4_) break b;
          }
          else if(2 !== error && 11 !== error) break b;
          var match = -445537353;
          break a;
         }
         throw caml_maybe_attach_backtrace
                ([0, Async_rpc_Import[18][153], error, cst_read, cst], 0);
        }
        var n = caml_call1(Core_unix[5][2][9], result);
        if(0 === n)
         var match = 3456156;
        else{
         if(! caml_call2(Core[91], n, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
         t[8] = t[8] + n | 0;
         var match = -554304611;
        }
       }
       if(-445537353 !== match)
        return 3456156 <= match
                ? interrupt(t$0, 1)
                : process_received_messages(t$0, read_or_peek);
       var _b7_ = 0;
      }
      else
       var _b7_ = _b6_;
      return _b7_;
     }
     return caml_call5
             (Async_unix_Fd[29], t[1][1], 914388854, interrupt$0, _bY_, t);
    }
    var _bV_ = caml_call3(Async_unix_Scheduler[4], [0, monitor], 0, _bU_);
    return caml_call2(Async_rpc_Import[15][2], _bV_, _bT_);
   }
   function read_or_peek_dispatcher(t, dispatcher_impl, caller_name){
    if(t[4])
     caml_call5
      (Core[247], 0, _L_, cst_Rpc_transport_low_latency_$6, cst$0, Core[558]);
    if(t[3])
     caml_call5
      (Core[247], 0, _M_, cst_Rpc_transport_low_latency_$7, cst$1, Core[558]);
    t[3] = 1;
    function _bR_(param){t[3] = 0; return Async_kernel_Deferred[18];}
    function _bS_(param){return caml_call1(dispatcher_impl, 0);}
    return caml_call8
            (Async_kernel_Monitor[23],
             _P_,
             0,
             [0, caller_name],
             0,
             _O_,
             _N_,
             _bS_,
             _bR_);
   }
   function read_forever(t, allow_buffering, on_message, on_end_of_batch){
    return read_or_peek_dispatcher
            (t,
             function(param){
              return run
                      (t, allow_buffering, on_message, on_end_of_batch, 914388854);
             },
             cst_Rpc_transport_low_latency_$8);
   }
   function read_forever$0(_bN_){
    var _bO_ = 1;
    return function(_bP_, _bQ_){return read_forever(_bN_, _bO_, _bP_, _bQ_);};
   }
   function close(t){
    if(1 - t[4]){
     t[4] = 1;
     var
      _bL_ =
        function(param){return caml_call2(Async_kernel_Ivar[14], t[5], 0);},
      _bM_ = caml_call2(Async_unix_Fd[12], 0, t[1]);
     caml_call2(Async_rpc_Import[9], _bM_, _bL_);
    }
    return close_finished(t);
   }
   function sexp_of_flush(param){
    var
     ivar_046 = param[2],
     pos_044 = param[1],
     arg_047 = caml_call2(Async_kernel_Ivar[9], Core[620], ivar_046),
     bnds_043 = [0, [1, [0, _S_, [0, arg_047, 0]]], 0],
     arg_045 = caml_call1(Core_Int63[103], pos_044),
     bnds_043$0 = [0, [1, [0, _T_, [0, arg_045, 0]]], bnds_043];
    return [1, bnds_043$0];
   }
   function start_close(t){return caml_call2(Async_kernel_Ivar[16], t[1], 0);}
   function is_able_to_send_data(t){
    return caml_call1(Async_kernel_Ivar[17], t[3]);
   }
   function sexp_of_t$1(param){
    var
     connection_state_060 = param[3],
     config_058 = param[2],
     fd_056 = param[1],
     writing_062 = param[4],
     buf_064 = param[5],
     pos_066 = param[6],
     bytes_written_068 = param[7],
     flushes_072 = param[9],
     monitor_070 = param[8],
     last_send_job_074 = param[10],
     sends_in_this_job_076 = param[11],
     arg_077 = caml_call1(Core[389], sends_in_this_job_076),
     bnds_055 = [0, [1, [0, _X_, [0, arg_077, 0]]], 0],
     arg_075 = caml_call1(Core[389], last_send_job_074),
     bnds_055$0 = [0, [1, [0, _Y_, [0, arg_075, 0]]], bnds_055],
     arg_073 = caml_call2(Core_Queue[13], sexp_of_flush, flushes_072),
     bnds_055$1 = [0, [1, [0, _Z_, [0, arg_073, 0]]], bnds_055$0],
     arg_071 = caml_call1(Async_kernel_Monitor[1], monitor_070),
     bnds_055$2 = [0, [1, [0, ___, [0, arg_071, 0]]], bnds_055$1],
     arg_069 = caml_call1(Core_Int63[103], bytes_written_068),
     bnds_055$3 = [0, [1, [0, _$_, [0, arg_069, 0]]], bnds_055$2],
     arg_067 = caml_call1(Core[389], pos_066),
     bnds_055$4 = [0, [1, [0, _aa_, [0, arg_067, 0]]], bnds_055$3],
     arg_065 = caml_call1(Sexplib0_Sexp_conv[23], buf_064),
     bnds_055$5 = [0, [1, [0, _ab_, [0, arg_065, 0]]], bnds_055$4],
     arg_063 = caml_call1(Core[323], writing_062),
     bnds_055$6 = [0, [1, [0, _ac_, [0, arg_063, 0]]], bnds_055$5],
     connection_lost_053 = connection_state_060[3],
     close_finished_051 = connection_state_060[2],
     close_started_049 = connection_state_060[1],
     arg_054 =
       caml_call2(Async_kernel_Ivar[9], Core[620], connection_lost_053),
     bnds_048 = [0, [1, [0, _U_, [0, arg_054, 0]]], 0],
     arg_052 = caml_call2(Async_kernel_Ivar[9], Core[620], close_finished_051),
     bnds_048$0 = [0, [1, [0, _V_, [0, arg_052, 0]]], bnds_048],
     arg_050 = caml_call2(Async_kernel_Ivar[9], Core[620], close_started_049),
     bnds_048$1 = [0, [1, [0, _W_, [0, arg_050, 0]]], bnds_048$0],
     arg_061 = [1, bnds_048$1],
     bnds_055$7 = [0, [1, [0, _ad_, [0, arg_061, 0]]], bnds_055$6],
     arg_059 = sexp_of_t(config_058),
     bnds_055$8 = [0, [1, [0, _ae_, [0, arg_059, 0]]], bnds_055$7],
     arg_057 = caml_call1(Async_unix_Fd[2], fd_056),
     bnds_055$9 = [0, [1, [0, _af_, [0, arg_057, 0]]], bnds_055$8];
    return [1, bnds_055$9];
   }
   function monitor(r){return r[8];}
   function bytes_written(r){return r[7];}
   function is_closed$0(t){
    var t$0 = t[3];
    return 1 - caml_call1(Async_kernel_Ivar[17], t$0[1]);
   }
   function bytes_to_write(t){return t[6];}
   function stopped(t){
    var
     t$0 = t[3],
     _bJ_ = [0, caml_call1(Async_kernel_Ivar[19], t$0[1]), 0],
     _bK_ = [0, caml_call1(Async_kernel_Ivar[19], t$0[3]), _bJ_];
    return caml_call1(Async_kernel_Deferred[23], _bK_);
   }
   function flushed(t){
    if(caml_call2(Core[90], t[6], 0)) return Async_kernel_Deferred[18];
    if(! is_able_to_send_data(t[3]))
     return caml_call1(Async_kernel_Deferred[19], 0);
    var
     _bH_ = caml_call1(Async_kernel_Ivar[12], 0),
     _bI_ = caml_call1(Core_Int63[72], t[6]),
     flush = [0, caml_call2(Core_Int63[19], t[7], _bI_), _bH_];
    caml_call2(Core_Queue[43], t[9], flush);
    return caml_call1(Async_kernel_Ivar[19], flush[2]);
   }
   function discard(t, n){
    if(caml_call2(Core[88], n, 0) && caml_call2(Core[89], n, t[6])){
     var remaining = t[6] - n | 0;
     if(caml_call2(Core[91], remaining, 0))
      caml_call5(Core_Bigstring[22], t[5], n, t[5], 0, remaining);
     t[6] = remaining;
     var _bG_ = caml_call1(Core_Int63[72], n);
     t[7] = caml_call2(Core_Int63[19], t[7], _bG_);
     for(;;){
      if(! caml_call1(Core_Queue[17], t[9])){
       var _bD_ = t[7], _bE_ = caml_call1(Core_Queue[50], t[9])[1];
       if(caml_call2(Core_Int63[108], _bE_, _bD_)){
        var _bF_ = caml_call1(Core_Queue[46], t[9])[2];
        caml_call2(Async_kernel_Ivar[14], _bF_, 0);
        continue;
       }
      }
      return;
     }
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ag_], 1);
   }
   function handle_error(t, error){
    a:
    if(typeof error === "number"){
     if(31 <= error){
      var _bC_ = error - 32 | 0;
      if(19 < _bC_ >>> 0){
       if(0 <= _bC_)
        switch(_bC_ - 20 | 0){
          case 0:
          case 1:
          case 2:
          case 4:
          case 10:
          case 13: break;
          default: break a;
        }
       var t$0 = t[3];
       caml_call2(Async_kernel_Ivar[16], t$0[3], 0);
       return 1;
      }
      if(5 !== _bC_) break a;
     }
     else if(2 !== error && 11 !== error) break a;
     return 0;
    }
    return 2;
   }
   function finish_close(t){
    var fd_closed = caml_call2(Async_unix_Fd[12], 0, t[1]);
    t[4] = 0;
    var t$0 = t[3];
    start_close(t$0);
    caml_call2(Async_kernel_Ivar[16], t$0[3], 0);
    var _bB_ = caml_call1(Async_kernel_Ivar[16], t$0[2]);
    return caml_call2(Async_rpc_Import[7], fd_closed, _bB_);
   }
   function write_everything(t){
    a:
    {
     try{
      var
       _bx_ = t[5],
       _by_ = [0, t[6]],
       _bz_ = caml_call1(Async_unix_Fd[40], t[1]),
       n = caml_call4(Bigstring_unix[143], _bz_, _ah_, _by_, _bx_);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn[1] !== Async_rpc_Import[18][153])
       throw caml_maybe_attach_backtrace(exn, 0);
      var error = exn[2];
      switch(handle_error(t, error)){
        case 0:
         var match = 0; break a;
        case 1:
         var match = 1; break a;
        default: throw caml_maybe_attach_backtrace(exn, 0);
      }
     }
     discard(t, n);
     var match = 0;
    }
    if(match) return finish_close(t);
    if(! caml_call2(Core[90], t[6], 0)) return wait_and_write_everything(t);
    t[4] = 0;
    var _bA_ = is_closed$0(t);
    return _bA_ ? finish_close(t) : _bA_;
   }
   function wait_and_write_everything(t){
    function _bk_(result){
     if(! is_able_to_send_data(t[3])) return finish_close(t);
     if(typeof result !== "number"){
      var result$0 = result[2];
      if(-102231997 === result$0) return write_everything(t);
      var
       _br_ = 0,
       _bs_ = 0,
       _bt_ = 0,
       _bu_ = -3286312 <= result$0 ? _al_ : _am_,
       _bv_ =
         [0,
          [1,
           [0,
            [1, [0, _ao_, [0, sexp_of_t$1(t), 0]]],
            [0, [1, [0, _an_, [0, _bu_, _bt_]]], _bs_]]],
          _br_],
       _bw_ =
         [1,
          [0,
           caml_call1
            (Sexplib0_Sexp_conv[7], cst_Rpc_transport_low_latency_$11),
           _bv_]];
      return caml_call1(Core[261], _bw_);
     }
     if(caml_call1(Async_log[39][1][4][1], _ai_)){
      var
       _bn_ =
         caml_call3
          (Ppx_log_types_Message_source[3][1],
           cst_async_rpc_src_rpc_transpor,
           775,
           cst_Async_rpc_Rpc_transport_lo),
       _bo_ = [0, [0, cst_t, [5, sexp_of_t$1(t)]], 0],
       _bp_ =
         [0,
          [0, cst_timeout, [5, caml_call1(Core_Time_ns[1][10], t[2][4])]],
          _bo_],
       _bq_ =
         [0,
          348871921,
          caml_call3(Ppx_log_types_Message_sexp[2], 0, _aj_, _bp_)];
      caml_call5(Async_log[39][1][4][3], _ak_, 0, 0, _bq_, _bn_);
     }
     return finish_close(t);
    }
    var
     _bl_ = caml_call2(Async_unix_Fd[28], t[1], -477700929),
     _bm_ = caml_call2(Async_kernel_Clock_ns[5], t[2][4], _bl_);
    return caml_call2(Async_rpc_Import[9], _bm_, _bk_);
   }
   function flush(t){
    var _bh_ = 1 - t[4], _bi_ = _bh_ ? caml_call2(Core[91], t[6], 0) : _bh_;
    if(! _bi_) return _bi_;
    t[4] = 1;
    function _bj_(param){return write_everything(t);}
    return caml_call3(Async_unix_Scheduler[5], [0, t[8]], 0, _bj_);
   }
   function ensure_at_least(t, needed){
    var _bf_ = t[6], _bg_ = caml_call1(Core_Bigstring[21], t[5]) - _bf_ | 0;
    if(caml_call2(Core[92], _bg_, needed)){
     var new_size_request = t[6] + needed | 0;
     t[5] = grow_buffer(t[2], t[5], new_size_request);
    }
    return;
   }
   function copy_bytes(t, buf, pos, len){
    if(caml_call2(Core[91], len, 0)){
     ensure_at_least(t, len);
     caml_call5(Core_Bigstring[22], buf, pos, t[5], t[6], len);
     t[6] = t[6] + len | 0;
    }
    return;
   }
   function slow_write_bin_prot_and_bigstr(t, writer, msg, buf, pos, len){
    var
     payload_len = caml_call1(writer[1], msg) + len | 0,
     total_len = Async_rpc_kernel_Transport[1][1] + payload_len | 0;
    if(! message_size_ok(t[2], payload_len))
     return [1, [0, payload_len, t[2][1]]];
    ensure_at_least(t, total_len);
    caml_call3(Async_rpc_kernel_Transport[1][3], t[5], t[6], payload_len);
    var
     stop =
       caml_call3
        (writer[2], t[5], t[6] + Async_rpc_kernel_Transport[1][1] | 0, msg);
    if(! caml_call2(Core[90], stop + len | 0, t[6] + total_len | 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ap_], 1);
    caml_call5(Core_Bigstring[22], buf, pos, t[5], stop, len);
    t[6] = stop + len | 0;
    return [0, 0, payload_len];
   }
   function send_bin_prot_and_bigstring(t, writer, msg, buf, pos, len){
    if(is_closed$0(t)) return 0;
    var _a$_ = caml_call1(Core_Bigstring[21], buf);
    caml_call3(Core_Ordered_collection_common[2], pos, len, _a$_);
    if(! is_able_to_send_data(t[3])) return _aq_;
    var current_job = caml_call1(Async_unix_Scheduler[33], 0);
    if(caml_call2(Core[90], current_job, t[10]))
     t[11] = t[11] + 1 | 0;
    else{t[10] = current_job; t[11] = 1;}
    var
     _a__ = caml_call2(Core[88], t[6], t[2][5]),
     send_now = _a__ || caml_call2(Core[89], t[11], t[2][6]),
     _ba_ = Async_rpc_kernel_Transport[1][1],
     _bb_ = t[6],
     _bc_ = caml_call1(Core_Bigstring[21], t[5]) - _bb_ | 0;
    a:
    if(caml_call2(Core[92], _bc_, _ba_))
     var
      result$0 = slow_write_bin_prot_and_bigstr(t, writer, msg, buf, pos, len);
    else{
     try{
      var
       stop =
         caml_call3
          (writer[2], t[5], t[6] + Async_rpc_kernel_Transport[1][1] | 0, msg);
     }
     catch(_be_){
      var
       result$0 =
         slow_write_bin_prot_and_bigstr(t, writer, msg, buf, pos, len);
      break a;
     }
     var
      payload_len =
        (stop - (t[6] + Async_rpc_kernel_Transport[1][1] | 0) | 0) + len | 0;
     if(message_size_ok(t[2], payload_len)){
      caml_call3(Async_rpc_kernel_Transport[1][3], t[5], t[6], payload_len);
      t[6] = stop;
      if(send_now){
       var
        len$0 =
          caml_call2(Core[92], len, 128)
           ? (copy_bytes(t, buf, pos, len), 0)
           : len,
        _a8_ = t[6],
        _a9_ = t[5],
        result =
          runtime.async_extra_rpc_writev2_byte
           (caml_call1(Async_unix_Fd[40], t[1]),
            _a9_,
            0,
            _a8_,
            buf,
            pos,
            len$0);
       if(caml_call1(Core_unix[5][2][6], result)){
        var n = caml_call1(Core_unix[5][2][9], result);
        if(caml_call2(Core[89], n, t[6])){
         discard(t, n);
         copy_bytes(t, buf, pos, len$0);
        }
        else{
         var
          written_from_other_buf = n - t[6] | 0,
          remaining_in_other_buf = len$0 - written_from_other_buf | 0;
         discard(t, t[6]);
         if(caml_call2(Core[91], remaining_in_other_buf, 0))
          copy_bytes
           (t, buf, pos + written_from_other_buf | 0, remaining_in_other_buf);
        }
       }
       else{
        var error = caml_call1(Core_unix[5][2][10], result);
        switch(handle_error(t, error)){
          case 0:
           copy_bytes(t, buf, pos, len$0); break;
          case 1: break;
          default:
           var
            syscall = caml_call2(Core[90], len$0, 0) ? cst_write : cst_writev;
           caml_call3
            (Async_kernel_Monitor[15],
             t[8],
             0,
             [0, Async_rpc_Import[18][153], error, syscall, cst$2]);
        }
       }
      }
      else
       copy_bytes(t, buf, pos, len);
      var _bd_ = [0, 0, payload_len];
     }
     else
      var _bd_ = [1, [0, payload_len, t[2][1]]];
     var result$0 = _bd_;
    }
    if(send_now)
     flush(t);
    else{
     var _a5_ = 1 - t[4], _a6_ = _a5_ ? caml_call2(Core[91], t[6], 0) : _a5_;
     if(_a6_){
      t[4] = 1;
      var _a7_ = function(param){return wait_and_write_everything(t);};
      caml_call3(Async_unix_Scheduler[5], [0, t[8]], 0, _a7_);
     }
    }
    return result$0;
   }
   function send_bin_prot_and_bigstring_no(t, writer, msg, buf, pos, len){
    var r = send_bin_prot_and_bigstring(t, writer, msg, buf, pos, len);
    if(typeof r !== "number" && 0 === r[0]){
     var bytes = r[2];
     return [0, Async_kernel_Deferred[18], bytes];
    }
    return r;
   }
   var dummy_buf = caml_call1(Core_Bigstring[121], 0);
   function send_bin_prot(t, writer, msg){
    return send_bin_prot_and_bigstring(t, writer, msg, dummy_buf, 0, 0);
   }
   function close$0(t$0){
    if(1 - is_closed$0(t$0)){
     start_close(t$0[3]);
     flush(t$0);
     if(1 - t$0[4]) finish_close(t$0);
    }
    var t = t$0[3];
    return caml_call1(Async_kernel_Ivar[19], t[2]);
   }
   function make_create(f, opt, max_message_size, fd){
    if(opt) var sth = opt[1], config = sth; else var config = default$0;
    var
     max_message_size$0 = caml_call2(Core[96], config[1], max_message_size),
     config$0 =
       validate
        ([0,
          max_message_size$0,
          config[2],
          config[3],
          config[4],
          config[5],
          config[6]]);
    return caml_call2(f, fd, config$0);
   }
   var
    include = Async_rpc_kernel_Transport[2],
    sexp_of_t$2 = include[1],
    close$1 = include[2],
    is_closed$1 = include[3],
    bytes_read$0 = include[4],
    read_forever$1 = include[5],
    pack = include[6],
    read_one_message_bin_prot = include[7];
   function create_internal(fd, config){
    set_nonblocking(fd);
    var
     _a3_ = Core_Int63[16],
     _a4_ = caml_call1(Core_Bigstring[121], config[2]),
     internal_reader =
       [0,
        fd,
        config,
        0,
        0,
        caml_call1(Async_kernel_Ivar[12], 0),
        _a4_,
        0,
        0,
        _a3_],
     reader =
       caml_call2
        (pack,
         [0, sexp_of_t$0, close, is_closed, bytes_read, read_forever$0],
         internal_reader);
    return [0, internal_reader, reader];
   }
   function create$0(_a0_, _a1_, _a2_){
    return make_create(create_internal, _a0_, _a1_, _a2_);
   }
   function transport_reader(t){return t[2];}
   function read_one_message_bin_prot_with(t, bin_reader){
    var t$0 = t[1];
    function _aY_(_aZ_){return 0;}
    return read_forever
            (t$0,
             0,
             function(buf, pos, len){
              var
               pos_ref = [0, pos],
               x = caml_call2(bin_reader[1], buf, pos_ref);
              return caml_call2(Core[93], pos_ref[1], pos + len | 0)
                      ? caml_call4(Core[246], _Q_, pos_ref[1] - pos | 0, len, 0)
                      : [0, x];
             },
             _aY_);
   }
   function peek_bin_prot(t, bin_reader){
    var t$0 = t[1];
    function on_message(buf, pos, len){
     var pos_ref = [0, pos], x = caml_call2(bin_reader[1], buf, pos_ref);
     return caml_call2(Core[93], pos_ref[1], pos + len | 0)
             ? caml_call4(Core[246], _R_, pos_ref[1] - pos | 0, len, 0)
             : [0, x];
    }
    return read_or_peek_dispatcher
            (t$0,
             function(param){
              var _aW_ = 892210619;
              return run(t$0, 1, on_message, function(_aX_){return 0;}, _aW_);
             },
             cst_Rpc_transport_low_latency_$9);
   }
   function peek_once_without_buffering_fr(t, len){
    var reader = t[1];
    function on_message(buf, param, _aV_){return [0, buf];}
    return read_or_peek_dispatcher
            (reader,
             function(param){
              var
               _aG_ = 0,
               _aH_ = caml_call1(Async_kernel_Ivar[12], 0),
               t =
                 [0,
                  reader,
                  on_message,
                  function(_aU_){return 0;},
                  _aH_,
                  _aG_],
               monitor = caml_call4(Async_kernel_Monitor[3], _G_, 0, _F_, 0),
               buf = caml_call1(Core_Bigstring[121], len);
              stop_watching_on_error(t, monitor);
              function _aI_(param){
               if(-18684779 <= param)
                return caml_call1(Core[6], cst_Rpc_transport_low_latency_$3);
               var _aT_ = t[5];
               if(_aT_){
                var match = _aT_[1];
                if(typeof match === "number")
                 return 0 === match
                         ? caml_call1(Async_kernel_Deferred[19], 0)
                         : caml_call1(Async_rpc_Import[12], _H_);
                if(0 === match[0])
                 return caml_call1(Core[6], cst_Rpc_transport_low_latency_$4);
                var x = match[1];
                return caml_call1(Async_rpc_Import[12], [0, x]);
               }
               if(! caml_call1(Async_unix_Fd[16], t[1][1]) && ! t[1][4])
                throw caml_maybe_attach_backtrace([0, Assert_failure, _J_], 1);
               return caml_call1(Async_rpc_Import[12], _I_);
              }
              function _aJ_(param){
               function _aL_(t){
                var _aP_ = can_process_message(t);
                if(! _aP_) return _aP_;
                function _aQ_(file_descr){
                 return caml_call4
                         (Bigstring_unix[129], file_descr, _K_, len, buf);
                }
                var
                 peek_len = caml_call3(Async_unix_Fd[32], 0, t[1][1], _aQ_);
                if(! caml_call2(Core[88], peek_len, len))
                 return interrupt(t, 1);
                var
                 _aR_ = caml_call1(Core_Int63[72], len),
                 _aS_ = caml_call2(Core_Int63[19], t[1][9], _aR_);
                t[1][9] = _aS_;
                var match = [0, buf];
                if(0 !== match[0])
                 return caml_call1(Core[6], cst_Rpc_transport_low_latency_$5);
                var x = match[1];
                return interrupt(t, [1, x]);
               }
               var
                _aM_ = [0, close_finished(t[1]), 0],
                _aN_ = [0, caml_call1(Async_kernel_Ivar[19], t[4]), _aM_],
                _aO_ = caml_call1(Async_kernel_Deferred[23], _aN_);
               return caml_call5
                       (Async_unix_Fd[29], t[1][1], 914388854, _aO_, _aL_, t);
              }
              var
               _aK_ =
                 caml_call3(Async_unix_Scheduler[4], [0, monitor], 0, _aJ_);
              return caml_call2(Async_rpc_Import[15][2], _aK_, _aI_);
             },
             cst_Rpc_transport_low_latency_$10);
   }
   function create$1(config, max_message_size, fd){
    var internal = make_create(create_internal, config, max_message_size, fd);
    return internal[2];
   }
   var
    include$0 = Async_rpc_kernel_Transport[3],
    sexp_of_t$3 = include$0[1],
    close$2 = include$0[2],
    is_closed$2 = include$0[3],
    monitor$0 = include$0[4],
    bytes_to_write$0 = include$0[5],
    bytes_written$0 = include$0[6],
    stopped$0 = include$0[7],
    flushed$0 = include$0[8],
    ready_to_write = include$0[9],
    send_bin_prot$0 = include$0[10],
    send_bin_prot_and_bigstring$0 = include$0[11],
    send_bin_prot_and_bigstring_no$0 = include$0[12],
    pack$0 = include$0[13],
    can_send = include$0[14],
    transfer = include$0[15];
   function create_internal$0(fd, config){
    set_nonblocking(fd);
    var
     _aC_ = caml_call2(Core_Queue[66], 0, 0),
     _aD_ = caml_call4(Async_kernel_Monitor[3], 0, 0, 0, 0),
     _aE_ = Core_Int63[16],
     _aF_ = caml_call1(Core_Bigstring[121], config[2]),
     _aA_ = caml_call1(Async_kernel_Ivar[12], 0),
     _aB_ = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call2
            (pack$0,
             [0,
              sexp_of_t$1,
              close$0,
              is_closed$0,
              monitor,
              bytes_to_write,
              bytes_written,
              stopped,
              flushed,
              flushed,
              send_bin_prot,
              send_bin_prot_and_bigstring,
              send_bin_prot_and_bigstring_no],
             [0,
              fd,
              config,
              [0, caml_call1(Async_kernel_Ivar[12], 0), _aB_, _aA_],
              0,
              _aF_,
              0,
              _aE_,
              _aD_,
              _aC_,
              0,
              0]);
   }
   function create$2(_ax_, _ay_, _az_){
    return make_create(create_internal$0, _ax_, _ay_, _az_);
   }
   function sexp_of_t$4(param){
    var
     writer_081 = param[2],
     reader_079 = param[1],
     arg_082 = caml_call1(sexp_of_t$3, writer_081),
     bnds_078 = [0, [1, [0, _ar_, [0, arg_082, 0]]], 0],
     arg_080 = caml_call1(sexp_of_t$2, reader_079),
     bnds_078$0 = [0, [1, [0, _as_, [0, arg_080, 0]]], bnds_078];
    return [1, bnds_078$0];
   }
   function create_internal$1(fd, config){
    var _aw_ = create_internal$0(fd, config);
    return [0, create_internal(fd, config), _aw_];
   }
   function create$3(_at_, _au_, _av_){
    return make_create(create_internal$1, _at_, _au_, _av_);
   }
   var close$3 = Async_rpc_kernel_Transport[5];
   function create$4(config, max_message_size, fd){
    var
     internal = make_create(create_internal$1, config, max_message_size, fd);
    return [0, internal[1][2], internal[2]];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_rpc);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_rpc_Rpc_transport_lo$0);
   var
    Async_rpc_Rpc_transport_low_la =
      [0,
       [0, t_of_sexp, sexp_of_t, create],
       [0,
        sexp_of_t$2,
        close$1,
        is_closed$1,
        bytes_read$0,
        read_forever$1,
        pack,
        read_one_message_bin_prot,
        create$1,
        [0,
         create$0,
         transport_reader,
         read_one_message_bin_prot_with,
         peek_bin_prot,
         peek_once_without_buffering_fr]],
       [0,
        sexp_of_t$3,
        close$2,
        is_closed$2,
        monitor$0,
        bytes_to_write$0,
        bytes_written$0,
        stopped$0,
        flushed$0,
        ready_to_write,
        send_bin_prot$0,
        send_bin_prot_and_bigstring$0,
        send_bin_prot_and_bigstring_no$0,
        pack$0,
        can_send,
        transfer,
        create$2],
       sexp_of_t$4,
       close$3,
       create$4,
       [0, create$3]];
   runtime.caml_register_global
    (147, Async_rpc_Rpc_transport_low_la, cst_Async_rpc_Rpc_transport_lo$1);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_rpc__Rpc_transport
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Monitor, Async_rpc__Import, Async_rpc_kernel, Async_rpc_kernel__Transport, Async_unix__Async_sys, Async_unix__Fd, Async_unix__Reader, Async_unix__Tcp, Async_unix__Unix_syscalls, Async_unix__Writer, Core, Core__Int, Core__Int63, Core__List, Core__Option, Core__Or_error, Core__Time_ns, Expect_test_config, Inline_test_config, Linux_ext, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_expect_runtime__Test_block, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Types, Ppx_inline_test_lib, Ppx_module_timer_runtime, Ppx_string_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    cst_Async_rpc_Rpc_transport$0 = "Async_rpc__Rpc_transport",
    cst_async_rpc$0 = "async_rpc",
    cst_async_rpc_src_rpc_transpor$0 = "async_rpc/src/rpc_transport.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    max_message_size_env_var = "ASYNC_RPC_MAX_MESSAGE_SIZE",
    Core_Time_ns = global_data.Core__Time_ns,
    Async_unix_Tcp = global_data.Async_unix__Tcp,
    Async_unix_Unix_syscalls = global_data.Async_unix__Unix_syscalls,
    Async_rpc_Import = global_data.Async_rpc__Import,
    Async_rpc_kernel = global_data.Async_rpc_kernel,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_unix_Fd = global_data.Async_unix__Fd,
    Linux_ext = global_data.Linux_ext,
    Core = global_data.Core,
    Core_Or_error = global_data.Core__Or_error,
    Async_unix_Writer = global_data.Async_unix__Writer,
    Async_unix_Reader = global_data.Async_unix__Reader,
    Async_rpc_kernel_Transport = global_data.Async_rpc_kernel__Transport,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_Int63 = global_data.Core__Int63,
    Ppx_string_runtime = global_data.Ppx_string_runtime,
    Core_List = global_data.Core__List,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Core_Int = global_data.Core__Int,
    Async_unix_Async_sys = global_data.Async_unix__Async_sys,
    Core_Option = global_data.Core__Option,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Expect_test_config = global_data.Expect_test_config,
    Ppx_expect_runtime_Test_block = global_data.Ppx_expect_runtime__Test_block,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_rpc_Rpc_transport$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_rpc$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_async_rpc_src_rpc_transpor$0);
   caml_call2(Ppx_inline_test_lib[6], cst_async_rpc$0, "rpc_transport.ml");
   var
    _m_ = [0, 3804260],
    _n_ = [0, 523273847],
    cst_Error_getting_peer_credent =
      "Error getting peer credentials of unix socket",
    _k_ = [0, -146189108],
    _l_ = [0, 523273847],
    _i_ = [0, "writer"],
    _j_ = [0, "reader"],
    _h_ = [1, 3456156],
    _e_ = [0, "Message_size"],
    _f_ = [0, "Max_message_size"],
    cst_env_var = " env var",
    cst_Rpc_transport_message_is_t =
      "Rpc_transport: message is too large or has negative size. Try increasing the size limit by setting the ",
    _g_ = [0, cst_async_rpc_src_rpc_transpor$0, 104, 3158, 3172],
    _d_ =
      [0,
       [11,
        "Rpc_transport.With_limit.create got negative max message size: ",
        [4, 0, 0, 0, 0]],
       "Rpc_transport.With_limit.create got negative max message size: %d"],
    _a_ = [0, "total_bytes"],
    _b_ = [0, "max_message_size"],
    _c_ = [0, "t"],
    _p_ = [0, "effective_max"],
    _q_ = [0, "proposed_max"],
    _r_ = [0, 1],
    _s_ = [0, 1024],
    _t_ =
      [0,
       [0,
        [0,
         "\n    ((proposed_max ()) (effective_max 104857600))\n    ((proposed_max (1)) (effective_max 1))\n    ((proposed_max (209715200)) (effective_max 209715200))\n    ",
         [0, cst]],
        [0, 1214, 1218, 1379]]],
    _u_ = [0, 1203, 1205, 1380],
    _x_ =
      [0,
       [0,
        [0,
         "\n    ((proposed_max ()) (effective_max 1024))\n    ((proposed_max (1)) (effective_max 1024))\n    ((proposed_max (209715200)) (effective_max 209715200))\n    ",
         [0, cst]],
        [0, 1448, 1452, 1611]]],
    _y_ = [0, 1437, 1439, 1612],
    _B_ =
      [0,
       [0,
        [0,
         "\n    ((proposed_max ()) (effective_max 314572800))\n    ((proposed_max (1)) (effective_max 314572800))\n    ((proposed_max (209715200)) (effective_max 314572800))\n    ",
         [0, cst]],
        [0, 1695, 1699, 1868]]],
    _C_ = [0, 1684, 1686, 1869],
    _F_ = [0, " "],
    _I_ = [0, 780, 780, 1869],
    _J_ = [0, 1862, 1869, 1869],
    _K_ = [0, 780, 780, 1869],
    cst_async_rpc_src_rpc_transpor = cst_async_rpc_src_rpc_transpor$0,
    cst_async_rpc = cst_async_rpc$0,
    cst_Async_rpc_Rpc_transport = cst_Async_rpc_Rpc_transport$0,
    max_message_size_from_environm =
      [246,
       function(_aR_){
        function _aS_(param){
         var
          _aT_ = Core_Int[78],
          _aU_ =
            caml_call1(Async_unix_Async_sys[14], max_message_size_env_var);
         return caml_call2(Core_Option[34], _aU_, _aT_);
        }
        return caml_call1(Core_Option[57], _aS_);
       }];
   function aux_effective_max_message_size
   (max_message_size_from_environm, proposed_max){
    var default$0 = 104857600;
    if(proposed_max){
     var x = proposed_max[1];
     if(max_message_size_from_environm){
      var y = max_message_size_from_environm[1];
      return caml_call2(Core_Int[90], x, y);
     }
     var x$0 = x;
    }
    else{
     if(! max_message_size_from_environm) return default$0;
     var x$0 = max_message_size_from_environm[1];
    }
    return x$0;
   }
   if(typeof Ppx_inline_test_lib[3] !== "number"){
    var
     Ppx_expect_test_block =
       caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
     _o_ =
       function(param){
        function test(max_message_size_from_environm){
         function _aO_(proposed_max){
          var
           effective_max =
             aux_effective_max_message_size
              (max_message_size_from_environm, proposed_max),
           _aP_ =
             [0,
              [1, [0, _p_, [0, caml_call1(Core[389], effective_max), 0]]],
              0],
           _aQ_ =
             [1,
              [0,
               [1,
                [0,
                 _q_,
                 [0, caml_call2(Core[515], Core[389], proposed_max), 0]]],
               _aP_]];
          return caml_call2(Async_rpc_Import[74], 0, _aQ_);
         }
         return caml_call2
                 (Core_List[19],
                  [0, 0, [0, _r_, [0, [0, 209715200], 0]]],
                  _aO_);
        }
        test(0);
        var _aL_ = caml_call1(Ppx_expect_runtime_Types[4][1], 0);
        caml_call1(Ppx_expect_test_block[2], _aL_);
        test(_s_);
        var _aM_ = caml_call1(Ppx_expect_runtime_Types[4][1], 1);
        caml_call1(Ppx_expect_test_block[2], _aM_);
        test([0, 314572800]);
        var _aN_ = caml_call1(Ppx_expect_runtime_Types[4][1], 2);
        return caml_call1(Ppx_expect_test_block[2], _aN_);
       },
     _v_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _u_,
         _t_),
     _w_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 0), _v_], 0],
     _z_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _y_,
         _x_),
     _A_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 1), _z_], _w_],
     _D_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _C_,
         _B_),
     _E_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 2), _D_], _A_],
     _G_ = caml_call1(Ppx_expect_runtime_Types[4][1], 4),
     _H_ = caml_call1(Ppx_expect_runtime_Types[4][1], 3);
    caml_call14
     (Ppx_expect_test_block[3],
      cst_async_rpc_src_rpc_transpor,
      27,
      _K_,
      _J_,
      _I_,
      [0, Ppx_expect_runtime_Types[1][1]],
      0,
      _H_,
      _G_,
      _F_,
      0,
      Inline_test_config,
      _E_,
      _o_);
   }
   function effective_max_message_size(proposed_max){
    var
     max_message_size_from_environm$0 =
       caml_call1(Core[248], max_message_size_from_environm);
    return aux_effective_max_message_size
            (max_message_size_from_environm$0, proposed_max);
   }
   function sexp_of_t(of_a_002, param){
    var
     max_message_size_006 = param[2],
     t_004 = param[1],
     total_bytes_008 = param[3],
     arg_009 = caml_call1(Core_Int63[103], total_bytes_008),
     bnds_003 = [0, [1, [0, _a_, [0, arg_009, 0]]], 0],
     arg_007 = caml_call1(Core[389], max_message_size_006),
     bnds_003$0 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_003],
     arg_005 = caml_call1(of_a_002, t_004),
     bnds_003$1 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_003$0];
    return [1, bnds_003$1];
   }
   function create(t, max_message_size){
    var max_message_size$0 = effective_max_message_size(max_message_size);
    if(caml_call2(Core[92], max_message_size$0, 0))
     caml_call3(Core[246], _d_, max_message_size$0, 0);
    return [0, t, max_message_size$0, Core_Int63[16]];
   }
   function message_size_ok(t, payload_len){
    var _aK_ = caml_call2(Core[88], payload_len, 0);
    return _aK_ ? caml_call2(Core[89], payload_len, t[2]) : _aK_;
   }
   function incr_total_bytes(t, bytes){
    var _aJ_ = caml_call1(Core_Int63[72], bytes);
    t[3] = caml_call2(Core_Int63[19], t[3], _aJ_);
    return;
   }
   function sexp_of_t$0(x_016){return sexp_of_t(Async_unix_Reader[3], x_016);}
   function close(t){return caml_call1(Async_unix_Reader[15], t[1]);}
   function is_closed(t){return caml_call1(Async_unix_Reader[17], t[1]);}
   function bytes_read(t){return t[3];}
   function all_unit_then_return(l, ret_val){
    if(! l) return caml_call1(Async_rpc_Import[12], ret_val);
    function _aH_(param){return ret_val;}
    var _aI_ = caml_call1(Async_kernel_Deferred[22], l);
    return caml_call2(Async_rpc_Import[15][3], _aI_, _aH_);
   }
   function read_forever(t, on_message, on_end_of_batch){
    function finish_loop(consumed, need, wait_before_reading){
     caml_call1(on_end_of_batch, 0);
     return all_unit_then_return
             (wait_before_reading,
              [0, 116552, [0, consumed, [0, 870031478, need]]]);
    }
    function handle_chunk(buf, pos$2, len$2){
     var pos = pos$2, len = len$2, consumed = 0, wait_before_reading = 0;
     for(;;){
      if(caml_call2(Core[92], len, Async_rpc_kernel_Transport[1][1]))
       return finish_loop
               (consumed,
                Async_rpc_kernel_Transport[1][1],
                wait_before_reading);
      var
       payload_len = caml_call2(Async_rpc_kernel_Transport[1][2], buf, pos),
       total_len = Async_rpc_kernel_Transport[1][1] + payload_len | 0;
      if(1 - message_size_ok(t, payload_len)){
       var
        _aC_ =
          function(param){
           var
            arg1_013 = param[2],
            arg0_012 = param[1],
            v_010 = arg0_012[2],
            res0_014 = [1, [0, _e_, [0, caml_call1(Core[389], v_010), 0]]],
            v_011 = arg1_013[2],
            res1_015 = [1, [0, _f_, [0, caml_call1(Core[389], v_011), 0]]];
           return [1, [0, res0_014, [0, res1_015, 0]]];
          },
        _aD_ = [0, [0, 183140761, payload_len], [0, -1017527468, t[2]]],
        _aE_ =
          [0,
           max_message_size_env_var,
           [0, caml_call1(Ppx_string_runtime[1][2], cst_env_var), 0]],
        _aF_ =
          [0,
           caml_call1
            (Ppx_string_runtime[1][2], cst_Rpc_transport_message_is_t),
           _aE_],
        _aG_ = caml_call1(Ppx_string_runtime[1][4], _aF_);
       caml_call5(Core[247], 0, _g_, _aG_, _aD_, _aC_);
      }
      if(caml_call2(Core[92], len, total_len))
       return finish_loop(consumed, total_len, wait_before_reading);
      var consumed$0 = consumed + total_len | 0;
      incr_total_bytes(t, payload_len);
      var
       result =
         caml_call3
          (on_message,
           buf,
           pos + Async_rpc_kernel_Transport[1][1] | 0,
           payload_len);
      if(typeof result === "number")
       var
        len$0 = len - total_len | 0,
        pos$0 = pos + total_len | 0,
        pos = pos$0,
        len = len$0,
        consumed = consumed$0;
      else{
       if(0 === result[0]){
        var x = result[1];
        return all_unit_then_return
                (wait_before_reading, [0, -686730715, [0, x, consumed$0]]);
       }
       var
        d = result[1],
        wait_before_reading$0 =
          caml_call1(Async_kernel_Deferred[7], d)
           ? wait_before_reading
           : [0, d, wait_before_reading],
        len$1 = len - total_len | 0,
        pos$1 = pos + total_len | 0,
        pos = pos$1,
        len = len$1,
        consumed = consumed$0,
        wait_before_reading = wait_before_reading$0;
      }
     }
    }
    function _aA_(param){
     if(typeof param !== "number" && 280164845 <= param[1]){var x = param[2]; return [0, x];}
     return _h_;
    }
    var _aB_ = caml_call2(Async_unix_Reader[29], t[1], handle_chunk);
    return caml_call2(Async_rpc_Import[15][3], _aB_, _aA_);
   }
   function sexp_of_t$1(x_018){return sexp_of_t(Async_unix_Writer[3], x_018);}
   function close$0(t){return caml_call2(Async_unix_Writer[65], 0, t[1]);}
   function is_closed$0(t){return caml_call1(Async_unix_Writer[68], t[1]);}
   function monitor(t){return caml_call1(Async_unix_Writer[64], t[1]);}
   function bytes_to_write(t){return caml_call1(Async_unix_Writer[75], t[1]);}
   function bytes_written(t){return t[3];}
   function stopped(t){
    var
     _ay_ = [0, caml_call1(Async_unix_Writer[22], t[1]), 0],
     _az_ = [0, caml_call1(Async_unix_Writer[66], t[1]), _ay_];
    return caml_call1(Async_kernel_Deferred[23], _az_);
   }
   function flushed(t){return caml_call1(Async_unix_Writer[58], t[1]);}
   function bin_write_payload_length(buf, pos, x){
    caml_call3(Async_rpc_kernel_Transport[1][3], buf, pos, x);
    return pos + Async_rpc_kernel_Transport[1][1] | 0;
   }
   function send_bin_prot_internal(t, bin_writer, x, followup_len){
    if(caml_call1(Async_unix_Writer[68], t[1])) return 0;
    var
     data_len = caml_call1(bin_writer[1], x),
     payload_len = data_len + followup_len | 0;
    return message_size_ok(t, payload_len)
            ? (incr_total_bytes
               (t, payload_len),
              caml_call4
               (Async_unix_Writer[47],
                t[1],
                Async_rpc_kernel_Transport[1][1],
                bin_write_payload_length,
                payload_len),
              caml_call4
               (Async_unix_Writer[47], t[1], data_len, bin_writer[2], x),
              [0, 0, payload_len])
            : [1, [0, payload_len, t[2]]];
   }
   function send_bin_prot(t, bin_writer, x){
    return send_bin_prot_internal(t, bin_writer, x, 0);
   }
   function send_bin_prot_and_bigstring(t, bin_writer, x, buf, pos, len){
    var result = send_bin_prot_internal(t, bin_writer, x, len);
    if(typeof result !== "number" && 0 === result[0]){
     caml_call4(Async_unix_Writer[34], [0, pos], [0, len], t[1], buf);
     return result;
    }
    return result;
   }
   function send_bin_prot_and_bigstring_no(t, bin_writer, x, buf, pos, len){
    var r = send_bin_prot_internal(t, bin_writer, x, len);
    if(typeof r !== "number" && 0 === r[0]){
     var bytes = r[2];
     caml_call4(Async_unix_Writer[48], t[1], [0, pos], [0, len], buf);
     return [0, caml_call1(Async_unix_Writer[58], t[1]), bytes];
    }
    return r;
   }
   var
    include = Async_rpc_kernel_Transport[2],
    sexp_of_t$2 = include[1],
    close$1 = include[2],
    is_closed$1 = include[3],
    bytes_read$0 = include[4],
    read_forever$0 = include[5],
    pack = include[6],
    read_one_message_bin_prot = include[7];
   function of_reader(max_message_size, reader){
    return caml_call2
            (pack,
             [0, sexp_of_t$0, close, is_closed, bytes_read, read_forever],
             create(reader, max_message_size));
   }
   var
    Reader =
      [0,
       sexp_of_t$2,
       close$1,
       is_closed$1,
       bytes_read$0,
       read_forever$0,
       pack,
       read_one_message_bin_prot,
       of_reader],
    include$0 = Async_rpc_kernel_Transport[3],
    sexp_of_t$3 = include$0[1],
    close$2 = include$0[2],
    is_closed$2 = include$0[3],
    monitor$0 = include$0[4],
    bytes_to_write$0 = include$0[5],
    bytes_written$0 = include$0[6],
    stopped$0 = include$0[7],
    flushed$0 = include$0[8],
    ready_to_write = include$0[9],
    send_bin_prot$0 = include$0[10],
    send_bin_prot_and_bigstring$0 = include$0[11],
    send_bin_prot_and_bigstring_no$0 = include$0[12],
    pack$0 = include$0[13],
    can_send = include$0[14],
    transfer = include$0[15];
   function of_writer(max_message_size, writer){
    caml_call2(Async_unix_Writer[20], writer, 0);
    return caml_call2
            (pack$0,
             [0,
              sexp_of_t$1,
              close$0,
              is_closed$0,
              monitor,
              bytes_to_write,
              bytes_written,
              stopped,
              flushed,
              flushed,
              send_bin_prot,
              send_bin_prot_and_bigstring,
              send_bin_prot_and_bigstring_no],
             create(writer, max_message_size));
   }
   var
    Writer =
      [0,
       sexp_of_t$3,
       close$2,
       is_closed$2,
       monitor$0,
       bytes_to_write$0,
       bytes_written$0,
       stopped$0,
       flushed$0,
       ready_to_write,
       send_bin_prot$0,
       send_bin_prot_and_bigstring$0,
       send_bin_prot_and_bigstring_no$0,
       pack$0,
       can_send,
       transfer,
       of_writer];
   function sexp_of_t$4(param){
    var
     writer_022 = param[2],
     reader_020 = param[1],
     arg_023 = caml_call1(Writer[1], writer_022),
     bnds_019 = [0, [1, [0, _i_, [0, arg_023, 0]]], 0],
     arg_021 = caml_call1(Reader[1], reader_020),
     bnds_019$0 = [0, [1, [0, _j_, [0, arg_021, 0]]], bnds_019];
    return [1, bnds_019$0];
   }
   var close$3 = Async_rpc_kernel_Transport[5];
   function of_reader_writer(max_message_size, reader, writer){
    var _ax_ = caml_call2(Writer[16], max_message_size, writer);
    return [0, caml_call2(Reader[8], max_message_size, reader), _ax_];
   }
   function of_fd
   (buffer_age_limit,
    reader_buffer_size,
    writer_buffer_size,
    max_message_size,
    fd){
    var
     _aw_ =
       caml_call7
        (Async_unix_Writer[18],
         writer_buffer_size,
         0,
         buffer_age_limit,
         0,
         0,
         0,
         fd);
    return of_reader_writer
            ([0, max_message_size],
             caml_call2(Async_unix_Reader[12], reader_buffer_size, fd),
             _aw_);
   }
   function default_transport_maker(fd, max_message_size){return of_fd(0, 0, 0, max_message_size, fd);
   }
   function make_serve_func_with_fd
   (tcp_creator,
    where_to_listen,
    max_connections,
    backlog,
    drop_incoming_connections,
    time_source,
    proposed_max,
    opt,
    _aq_,
    _ap_,
    handle_transport){
    if(opt)
     var sth = opt[1], make_transport = sth;
    else
     var make_transport = default_transport_maker;
    if(_aq_)
     var sth$0 = _aq_[1], auth = sth$0;
    else
     var auth = function(param){return 1;};
    if(_ap_)
     var sth$1 = _ap_[1], on_handler_error = sth$1;
    else
     var on_handler_error = -950194894;
    return caml_call9
            (tcp_creator,
             max_connections,
             0,
             backlog,
             drop_incoming_connections,
             0,
             time_source,
             on_handler_error,
             where_to_listen,
             function(client_addr, socket){
              if(! caml_call1(auth, client_addr))
               return caml_call1(Async_rpc_Import[12], 0);
              var
               max_message_size = effective_max_message_size(proposed_max),
               fd = caml_call1(Async_unix_Unix_syscalls[95][18], socket),
               transport = caml_call2(make_transport, fd, max_message_size);
              function _ar_(result){
               function _au_(param){
                if(0 === result[0])
                 return caml_call1(Async_rpc_Import[12], 0);
                var exn = result[1];
                throw caml_maybe_attach_backtrace(exn, 0);
               }
               var _av_ = caml_call1(close$3, transport);
               return caml_call2(Async_rpc_Import[15][2], _av_, _au_);
              }
              function _as_(param){
               return caml_call4
                       (handle_transport,
                        fd,
                        client_addr,
                        caml_call1(Async_unix_Unix_syscalls[95][20], socket),
                        transport);
              }
              var
               _at_ =
                 caml_call7
                  (Async_kernel_Monitor[16], 0, 0, 0, 0, _l_, _k_, _as_);
              return caml_call2(Async_rpc_Import[15][2], _at_, _ar_);
             });
   }
   function make_serve_func
   (tcp_creator,
    where_to_listen,
    max_connections,
    backlog,
    drop_incoming_connections,
    time_source,
    max_message_size,
    make_transport,
    auth,
    on_handler_error,
    handle_transport){
    return make_serve_func_with_fd
            (tcp_creator,
             where_to_listen,
             max_connections,
             backlog,
             drop_incoming_connections,
             time_source,
             max_message_size,
             make_transport,
             auth,
             on_handler_error,
             function(param, client_addr, server_addr, transport){
              return caml_call3
                      (handle_transport, client_addr, server_addr, transport);
             });
   }
   function serve(where_to_listen){
    var _af_ = Async_unix_Tcp[8][11];
    return function(_ag_, _ah_, _ai_, _aj_, _ak_, _al_, _am_, _an_, _ao_){
     return make_serve_func
             (_af_,
              where_to_listen,
              _ag_,
              _ah_,
              _ai_,
              _aj_,
              _ak_,
              _al_,
              _am_,
              _an_,
              _ao_);};
   }
   function serve_inet(where_to_listen){
    var _X_ = Async_unix_Tcp[8][12];
    return function(_Y_, _Z_, ___, _$_, _aa_, _ab_, _ac_, _ad_, _ae_){
     return make_serve_func
             (_X_,
              where_to_listen,
              _Y_,
              _Z_,
              ___,
              _$_,
              _aa_,
              _ab_,
              _ac_,
              _ad_,
              _ae_);};
   }
   function serve_unix
   (where_to_listen,
    max_connections,
    backlog,
    drop_incoming_connections,
    time_source,
    max_message_size,
    make_transport,
    auth,
    on_handler_error,
    handle_transport){
    function _S_(fd, client_addr, server_addr, transport){
     function _T_(param){
      var _W_ = caml_call1(Async_unix_Fd[40], fd);
      return caml_call1(caml_call1(Core[255], Linux_ext[32]), _W_);
     }
     var
      _U_ = caml_call2(Core_Or_error[37], 0, _T_),
      _V_ = caml_call2(Core_Or_error[48], _U_, cst_Error_getting_peer_credent),
      peer_credentials = caml_call1(Core[255], _V_);
     return caml_call4
             (handle_transport,
              client_addr,
              server_addr,
              peer_credentials,
              transport);
    }
    return make_serve_func_with_fd
            (Async_unix_Tcp[8][11],
             where_to_listen,
             max_connections,
             backlog,
             drop_incoming_connections,
             time_source,
             max_message_size,
             make_transport,
             auth,
             on_handler_error,
             _S_);
   }
   function connect(proposed_max, opt, _L_, where_to_connect){
    if(opt)
     var sth = opt[1], make_transport = sth;
    else
     var make_transport = default_transport_maker;
    if(_L_)
     var sth$0 = _L_[1], tcp_connect_timeout = sth$0;
    else
     var tcp_connect_timeout = Async_rpc_kernel[3][3];
    function _M_(sock){
     if(0 !== sock[0]) return caml_call1(Async_rpc_Import[12], sock);
     var sock$0 = sock[1];
     try{
      var
       sock_peername = caml_call1(Async_unix_Unix_syscalls[95][21], sock$0);
     }
     catch(exn_could_be_raised_if_the_soc$0){
      var
       exn_could_be_raised_if_the_soc =
         caml_wrap_exception(exn_could_be_raised_if_the_soc$0);
      caml_call2(Async_unix_Unix_syscalls[95][17], sock$0, 737457313);
      var
       _Q_ = caml_call1(Async_unix_Unix_syscalls[95][18], sock$0),
       _R_ = caml_call2(Async_rpc_Import[18][16], 0, _Q_);
      caml_call1(Async_rpc_Import[4], _R_);
      return caml_call1
              (Async_rpc_Import[12], [1, exn_could_be_raised_if_the_soc]);
     }
     var
      max_message_size = effective_max_message_size(proposed_max),
      transport =
        caml_call2
         (make_transport,
          caml_call1(Async_unix_Unix_syscalls[95][18], sock$0),
          max_message_size);
     return caml_call1
             (Async_rpc_Import[12], [0, [0, transport, sock_peername]]);
    }
    function _N_(param){
     var _P_ = [0, caml_call1(Core_Time_ns[1][144], tcp_connect_timeout)];
     return caml_call5(Async_unix_Tcp[3], 0, 0, _P_, 0, where_to_connect);
    }
    var _O_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _n_, _m_, _N_);
    return caml_call2(Async_rpc_Import[15][2], _O_, _M_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_rpc);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_rpc_Rpc_transport);
   var
    Async_rpc_Rpc_transport =
      [0,
       Reader,
       Writer,
       sexp_of_t$4,
       close$3,
       of_reader_writer,
       of_fd,
       [0, serve, serve_inet, serve_unix, connect]];
   runtime.caml_register_global
    (69, Async_rpc_Rpc_transport, cst_Async_rpc_Rpc_transport$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_rpc__Rpc
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Deferred_or_error, Async_kernel__Monitor, Async_rpc__Import, Async_rpc__Rpc_transport, Async_rpc_kernel, Async_rpc_kernel__Rpc, Async_rpc_kernel__Util, Async_unix__Async_sys, Async_unix__Reader, Async_unix__Tcp, Async_unix__Unix_syscalls, Base__Exn, Bigstring_unix, Core, Core__Info, Core__Option, Core__Pid, Core__Result, Core__String, Core__Time_ns, Core_unix, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    cst_Async_rpc_Rpc$0 = "Async_rpc__Rpc",
    cst = "_",
    cst_async_rpc$0 = "async_rpc",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call10(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    return (f.l >= 0 ? f.l : f.l = f.length) == 10
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_rpc_kernel_Util = global_data.Async_rpc_kernel__Util,
    Core = global_data.Core,
    Core_unix = global_data.Core_unix,
    Core_Option = global_data.Core__Option,
    Bigstring_unix = global_data.Bigstring_unix,
    Base_Exn = global_data.Base__Exn,
    Core_Pid = global_data.Core__Pid,
    Core_Info = global_data.Core__Info,
    Async_rpc_Import = global_data.Async_rpc__Import,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_rpc_Rpc_transport = global_data.Async_rpc__Rpc_transport,
    Async_unix_Tcp = global_data.Async_unix__Tcp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_rpc_kernel_Rpc = global_data.Async_rpc_kernel__Rpc,
    Async_unix_Unix_syscalls = global_data.Async_unix__Unix_syscalls,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_Result = global_data.Core__Result,
    Async_unix_Reader = global_data.Async_unix__Reader,
    Async_kernel_Deferred_or_error =
      global_data.Async_kernel__Deferred_or_error,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_rpc_kernel = global_data.Async_rpc_kernel,
    Async_unix_Async_sys = global_data.Async_unix__Async_sys,
    Core_String = global_data.Core__String;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_rpc_Rpc$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_rpc$0);
   caml_call1(Ppx_expect_runtime[1][1], "async_rpc/src/rpc.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_rpc$0, "rpc.ml");
   var
    include = Async_rpc_kernel_Rpc[5],
    sexp_of_t = include[1],
    Client_implementations = include[3],
    description = include[6],
    add_heartbeat_callback = include[7],
    reset_heartbeat_timeout = include[8],
    last_seen_alive = include[9],
    close = include[10],
    close_finished = include[11],
    close_reason = include[12],
    is_closed = include[13],
    bytes_to_write = include[14],
    bytes_written = include[15],
    bytes_read = include[16],
    flushed = include[17],
    peer_menu = include[18],
    peer_menu$0 = include[19],
    my_menu = include[20],
    peer_identification = include[21],
    _p_ =
      [0,
       [11,
        "Tried and failed to dump internal buffer to ",
        [2, 0, [11, " (offset ", [4, 0, 0, 0, [11, "): ", [2, 0, 0]]]]]],
       "Tried and failed to dump internal buffer to %s (offset %d): %s"],
    _q_ =
      [0,
       [11,
        "Dump of buffer written to ",
        [2, 0, [11, ". This message begins at offset ", [4, 0, 0, 0, 0]]]],
       "Dump of buffer written to %s. This message begins at offset %d"],
    cst_dev_shm_rpc_message_reader =
      "/dev/shm/rpc-message-reader-errors__pid_",
    cst_Rpc_Connection_with_client = "Rpc.Connection.with_client finished",
    _n_ = [0, 3804260],
    _o_ = [0, 523273847],
    _m_ = [0, cst],
    _l_ = [0, cst],
    cst_via_TCP = "via TCP",
    cst_Client_connected_via_TCP = "Client connected via TCP",
    _j_ = [0, "client_addr"],
    _k_ = [0, "server_addr"],
    cst_TCP_server = "TCP server",
    _g_ = [0, 3804260],
    _h_ = [0, 523273847],
    _i_ = [0, "Rpc.Connection.collect_errors"],
    _e_ = [0, 3804260],
    _f_ = [0, 523273847],
    cst_ASYNC_RPC_DEBUG_DUMP_DESER =
      "ASYNC_RPC_DEBUG_DUMP_DESERIALIZATION_ERRORS",
    cst_dev_shm = "/dev/shm",
    cst_ASYNC_RPC_DEBUG_DUMP_MESSA =
      "ASYNC_RPC_DEBUG_DUMP_MESSAGE_LENGTH_ERRORS",
    cst_async_rpc = cst_async_rpc$0,
    cst_Async_rpc_Rpc = cst_Async_rpc_Rpc$0,
    _a_ = include[4],
    _b_ = include[5],
    _c_ = include[22],
    _d_ = include[23];
   function create
   (implementations,
    connection_state,
    max_message_size,
    handshake_timeout,
    heartbeat_config,
    description,
    identification,
    reader,
    writer){
    var
     _a2_ =
       caml_call3
        (Async_rpc_Rpc_transport[5], max_message_size, reader, writer);
    return caml_call10
            (_a_,
             implementations,
             0,
             connection_state,
             caml_call2
              (Core_Option[34], handshake_timeout, Core_Time_ns[1][146]),
             heartbeat_config,
             0,
             description,
             0,
             identification,
             _a2_);
   }
   function contains_magic_prefix(reader){
    function _aZ_(param){
     if(0 === param[0]){
      var match = param[1];
      if(typeof match !== "number"){var b = match[2]; return b;}
     }
     return 0;
    }
    function _a0_(param){
     return caml_call3(Async_unix_Reader[46], 0, reader, _b_);
    }
    var
     _a1_ =
       caml_call6(Async_kernel_Deferred_or_error[38], 0, _f_, _e_, 0, 0, _a0_);
    return caml_call2(Async_rpc_Import[15][3], _a1_, _aZ_);
   }
   function with_close
   (implementations,
    max_message_size,
    handshake_timeout,
    heartbeat_config,
    description,
    connection_state,
    reader,
    writer,
    dispatch_queries,
    on_handshake_error){
    var
     _aY_ =
       caml_call3
        (Async_rpc_Rpc_transport[5], max_message_size, reader, writer);
    return caml_call10
            (_c_,
             implementations,
             0,
             caml_call2
              (Core_Option[34], handshake_timeout, Core_Time_ns[1][146]),
             heartbeat_config,
             description,
             0,
             connection_state,
             _aY_,
             dispatch_queries,
             on_handshake_error);
   }
   function server_with_close
   (max_message_size,
    handshake_timeout,
    heartbeat_config,
    description,
    reader,
    writer,
    implementations,
    connection_state,
    on_handshake_error){
    var
     _aX_ =
       caml_call3
        (Async_rpc_Rpc_transport[5], max_message_size, reader, writer);
    return caml_call8
            (_d_,
             caml_call2
              (Core_Option[34], handshake_timeout, Core_Time_ns[1][146]),
             heartbeat_config,
             description,
             0,
             _aX_,
             implementations,
             connection_state,
             on_handshake_error);
   }
   function serve_with_transport
   (identification,
    transport,
    handshake_timeout,
    heartbeat_config,
    implementations,
    description,
    connection_state,
    on_handshake_error,
    client_addr){
    function _aQ_(res){
     function _aV_(param){return caml_call1(Core_Result[40], res);}
     var _aW_ = caml_call1(Async_rpc_Rpc_transport[4], transport);
     return caml_call2(Async_rpc_Import[15][3], _aW_, _aV_);
    }
    function f(param){
     function _aS_(param){
      if(0 === param[0]){
       var t = param[1];
       return caml_call1(close_finished, t);
      }
      var handshake_error = param[1];
      if(typeof on_handshake_error === "number"){
       if(-146189108 <= on_handshake_error)
        throw caml_maybe_attach_backtrace(handshake_error, 0);
      }
      else{
       var f = on_handshake_error[2];
       caml_call2(f, client_addr, handshake_error);
      }
      return Async_kernel_Deferred[18];
     }
     var
      _aT_ =
        caml_call2(Core_Option[34], handshake_timeout, Core_Time_ns[1][146]),
      _aU_ =
        caml_call10
         (Async_rpc_kernel_Rpc[5][4],
          [0, implementations],
          0,
          connection_state,
          _aT_,
          heartbeat_config,
          0,
          [0, description],
          0,
          identification,
          transport);
     return caml_call2(Async_rpc_Import[15][2], _aU_, _aS_);
    }
    var monitor = caml_call1(Async_rpc_Rpc_transport[2][4], transport[2]);
    caml_call1(Async_kernel_Monitor[9], monitor);
    var _aI_ = 0;
    function _aJ_(_aR_){return _aR_;}
    var
     _aK_ = caml_call7(Async_kernel_Monitor[16], 0, 0, _i_, 0, _h_, _g_, f),
     _aL_ = [0, caml_call2(Async_rpc_Import[2], _aK_, _aJ_), _aI_];
    function _aM_(e){return [1, e];}
    var
     _aN_ = caml_call1(Async_kernel_Monitor[10], monitor),
     _aO_ = [0, caml_call2(Async_rpc_Import[2], _aN_, _aM_), _aL_],
     _aP_ = caml_call1(Async_rpc_Import[3], _aO_);
    return caml_call2(Async_rpc_Import[15][2], _aP_, _aQ_);
   }
   function connection_description
   (description, server_addr, client_addr, param){
    var
     _aF_ =
       [0,
        [1,
         [0,
          _j_,
          [0, caml_call1(Async_unix_Unix_syscalls[95][1][11], client_addr), 0]]],
        0],
     _aG_ =
       [0,
        [1,
         [0,
          _k_,
          [0, caml_call1(Async_unix_Unix_syscalls[95][1][11], server_addr), 0]]],
        _aF_],
     _aH_ = [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_TCP_server), _aG_]],
     connection_description = caml_call1(Core_Info[20], _aH_);
    if(! description) return connection_description;
    var description$0 = description[1];
    return caml_call1
            (Core_Info[26],
             [0, description$0, [0, connection_description, 0]]);
   }
   var default_on_handshake_error = -950194894;
   function make_serve_func
   (serve_with_transport_handler,
    implementations,
    initial_connection_state,
    where_to_listen,
    max_connections,
    backlog,
    drop_incoming_connections,
    time_source,
    max_message_size,
    make_transport,
    handshake_timeout,
    heartbeat_config,
    auth,
    opt,
    on_handler_error,
    description,
    identification,
    param){
    if(opt)
     var sth = opt[1], on_handshake_error = sth;
    else
     var on_handshake_error = default_on_handshake_error;
    return caml_call10
            (serve_with_transport_handler,
             where_to_listen,
             max_connections,
             backlog,
             drop_incoming_connections,
             time_source,
             max_message_size,
             make_transport,
             auth,
             on_handler_error,
             function(client_addr, server_addr, transport){
              function _aE_(conn){
               return caml_call2(initial_connection_state, client_addr, conn);
              }
              return serve_with_transport
                      (identification,
                       transport,
                       handshake_timeout,
                       heartbeat_config,
                       implementations,
                       connection_description
                        (description, server_addr, client_addr, 0),
                       _aE_,
                       on_handshake_error,
                       client_addr);
             });
   }
   function serve(implementations){
    var _an_ = Async_rpc_Rpc_transport[7][1];
    return function
     (_ao_,
      _ap_,
      _aq_,
      _ar_,
      _as_,
      _at_,
      _au_,
      _av_,
      _aw_,
      _ax_,
      _ay_,
      _az_,
      _aA_,
      _aB_,
      _aC_,
      _aD_){
     return make_serve_func
             (_an_,
              implementations,
              _ao_,
              _ap_,
              _aq_,
              _ar_,
              _as_,
              _at_,
              _au_,
              _av_,
              _aw_,
              _ax_,
              _ay_,
              _az_,
              _aA_,
              _aB_,
              _aC_,
              _aD_);};
   }
   function serve_inet(implementations){
    var _Y_ = Async_rpc_Rpc_transport[7][2];
    return function
     (_Z_,
      ___,
      _$_,
      _aa_,
      _ab_,
      _ac_,
      _ad_,
      _ae_,
      _af_,
      _ag_,
      _ah_,
      _ai_,
      _aj_,
      _ak_,
      _al_,
      _am_){
     return make_serve_func
             (_Y_,
              implementations,
              _Z_,
              ___,
              _$_,
              _aa_,
              _ab_,
              _ac_,
              _ad_,
              _ae_,
              _af_,
              _ag_,
              _ah_,
              _ai_,
              _aj_,
              _ak_,
              _al_,
              _am_);};
   }
   function serve_unix
   (implementations,
    initial_connection_state,
    where_to_listen,
    max_connections,
    backlog,
    drop_incoming_connections,
    time_source,
    max_message_size,
    make_transport,
    handshake_timeout,
    heartbeat_config,
    auth,
    opt,
    on_handler_error,
    description,
    identification,
    param){
    if(opt)
     var sth = opt[1], on_handshake_error = sth;
    else
     var on_handshake_error = default_on_handshake_error;
    function _W_(client_addr, server_addr, peer_creds, transport){
     function _X_(conn){
      return caml_call3
              (initial_connection_state, client_addr, peer_creds, conn);
     }
     return serve_with_transport
             (identification,
              transport,
              handshake_timeout,
              heartbeat_config,
              implementations,
              connection_description(description, server_addr, client_addr, 0),
              _X_,
              on_handshake_error,
              client_addr);
    }
    return caml_call10
            (Async_rpc_Rpc_transport[7][3],
             where_to_listen,
             max_connections,
             backlog,
             drop_incoming_connections,
             time_source,
             max_message_size,
             make_transport,
             auth,
             on_handler_error,
             _W_);
   }
   var
    default_handshake_timeout_floa =
      caml_call1(Core_Time_ns[1][144], Async_rpc_kernel[3][3]);
   function client
   (implementations,
    max_message_size,
    make_transport,
    opt,
    heartbeat_config,
    description,
    identification,
    where_to_connect){
    if(opt)
     var sth = opt[1], handshake_timeout_float = sth;
    else
     var handshake_timeout_float = default_handshake_timeout_floa;
    var
     handshake_timeout =
       caml_call1(Core_Time_ns[1][146], handshake_timeout_float),
     _G_ = caml_call1(Core_Time_ns[66], 0),
     finish_handshake_by =
       caml_call2(Core_Time_ns[67], _G_, handshake_timeout);
    function _H_(error){
     if(0 !== error[0]) return caml_call1(Async_rpc_Import[12], error);
     var match = error[1], sock_peername = match[2], transport = match[1];
     if(description)
      var
       desc = description[1],
       _J_ = 0,
       _K_ = 0,
       _L_ = function(param){return _l_;},
       _M_ = [0, caml_call2(Async_unix_Tcp[1][1], _L_, where_to_connect), _K_],
       _N_ = [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_via_TCP), _M_]],
       _O_ = [0, desc, [0, caml_call1(Core_Info[20], _N_), _J_]],
       description$0 = caml_call1(Core_Info[26], _O_);
     else
      var
       _S_ =
         function(x_003){
          function _V_(param){return _m_;}
          return caml_call2(Async_unix_Tcp[1][1], _V_, x_003);
         },
       description$0 =
         caml_call5
          (Core_Info[19],
           0,
           0,
           cst_Client_connected_via_TCP,
           where_to_connect,
           _S_);
     var
      _P_ = caml_call1(Core_Time_ns[66], 0),
      handshake_timeout =
        caml_call2(Core_Time_ns[73], finish_handshake_by, _P_);
     function _Q_(rpc_connection){
      if(0 === rpc_connection[0]){
       var t = rpc_connection[1];
       return caml_call1(Async_rpc_Import[12], [0, [0, sock_peername, t]]);
      }
      function _T_(param){
       return caml_call1(Async_rpc_Import[12], rpc_connection);
      }
      var _U_ = caml_call1(Async_rpc_Rpc_transport[4], transport);
      return caml_call2(Async_rpc_Import[15][2], _U_, _T_);
     }
     if(implementations)
      var
       match$0 = implementations[1],
       implementations$0 = match$0[2],
       connection_state = match$0[1],
       _R_ =
         caml_call10
          (Async_rpc_kernel_Rpc[5][4],
           [0, implementations$0],
           0,
           connection_state,
           [0, handshake_timeout],
           heartbeat_config,
           0,
           [0, description$0],
           0,
           identification,
           transport);
     else
      var
       match$1 = caml_call1(Client_implementations[1], 0),
       implementations$1 = match$1[2],
       connection_state$0 = match$1[1],
       _R_ =
         caml_call10
          (Async_rpc_kernel_Rpc[5][4],
           [0, implementations$1],
           0,
           connection_state$0,
           [0, handshake_timeout],
           heartbeat_config,
           0,
           [0, description$0],
           0,
           identification,
           transport);
     return caml_call2(Async_rpc_Import[15][2], _R_, _Q_);
    }
    var
     _I_ =
       caml_call4
        (Async_rpc_Rpc_transport[7][4],
         max_message_size,
         make_transport,
         [0, handshake_timeout],
         where_to_connect);
    return caml_call2(Async_rpc_Import[15][2], _I_, _H_);
   }
   function client$0
   (implementations,
    max_message_size,
    make_transport,
    handshake_timeout,
    heartbeat_config,
    description,
    identification,
    where_to_connect){
    function _D_(_F_){return _F_[2];}
    var
     _E_ =
       client
        (implementations,
         max_message_size,
         make_transport,
         handshake_timeout,
         heartbeat_config,
         description,
         identification,
         where_to_connect);
    return caml_call2(Async_rpc_Import[11], _E_, _D_);
   }
   function with_client
   (implementations,
    max_message_size,
    make_transport,
    handshake_timeout,
    heartbeat_config,
    description,
    identification,
    where_to_connect,
    f){
    function _w_(param){
     var t = param[2], remote_server = param[1];
     function _y_(result){
      function _B_(param){return result;}
      var
       _C_ =
         caml_call3
          (close,
           0,
           [0, caml_call1(Core_Info[14], cst_Rpc_Connection_with_client)],
           t);
      return caml_call2(Async_rpc_Import[15][3], _C_, _B_);
     }
     function _z_(param){return caml_call2(f, remote_server, t);}
     var
      _A_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _o_, _n_, _z_);
     return caml_call2(Async_rpc_Import[15][2], _A_, _y_);
    }
    var
     _x_ =
       client
        (implementations,
         max_message_size,
         make_transport,
         handshake_timeout,
         heartbeat_config,
         description,
         identification,
         where_to_connect);
    return caml_call2(Async_rpc_Import[10], _x_, _w_);
   }
   function with_client$0
   (implementations,
    max_message_size,
    make_transport,
    handshake_timeout,
    heartbeat_config,
    description,
    identification,
    where_to_connect,
    f){
    return with_client
            (implementations,
             max_message_size,
             make_transport,
             handshake_timeout,
             heartbeat_config,
             description,
             identification,
             where_to_connect,
             function(param){return f;});
   }
   var
    default_path =
      [246,
       function(param){
        var
         _u_ = caml_call1(Core_unix[34], 0),
         _v_ = caml_call1(Core_Pid[15], _u_);
        return caml_call2(Core[18], cst_dev_shm_rpc_message_reader, _v_);
       }],
    path_override = [0, 0];
   function dump_deserialization_error(buf, pos){
    function open_file(param){
     var match = path_override[1];
     if(match)
      var path = match[1], path$0 = path;
     else
      var path$0 = caml_call1(Core[248], default_path);
     return [0,
             caml_call3(Core_unix[49], 0, [0, 5, [0, 1, [0, 6, 0]]], path$0),
             path$0];
    }
    try{var _t_ = open_file(0), match = _t_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(caml_call1(Core_Option[61], path_override[1]))
      throw caml_maybe_attach_backtrace(exn, 0);
     path_override[1] = 0;
     var match = open_file(0);
    }
    var path = match[2], fd = match[1];
    a:
    {
     try{caml_call4(Bigstring_unix[137], fd, 0, 0, buf);}
     catch(e$0){
      var
       e = caml_wrap_exception(e$0),
       _s_ = caml_call1(Base_Exn[10], e),
       result = caml_call4(Core[265], _p_, path, pos, _s_);
      break a;
     }
     var result = caml_call3(Core[265], _q_, path, pos);
    }
    caml_call2(Core_unix[53], 0, fd);
    return result;
   }
   function enable_dumping_buffers_on_dese(override, param){
    if(override){
     var override$0 = override[1];
     path_override[1] = [0, override$0];
    }
    Async_rpc_kernel_Util[2][1] = dump_deserialization_error;
    return 0;
   }
   var
    match =
      caml_call1(Async_unix_Async_sys[14], cst_ASYNC_RPC_DEBUG_DUMP_DESER);
   if(match){
    var dump_to = match[1];
    a:
    {
     if
      (caml_string_notequal(dump_to, cst$0)
       && caml_string_notequal(dump_to, "1")){
      var
       _r_ =
         caml_call4(Core_String[48], 0, 0, dump_to, 47)
          ? [0, dump_to]
          : [0, caml_call2(Core[631], cst_dev_shm, dump_to)],
       path_override$0 = _r_;
      break a;
     }
     var path_override$0 = 0;
    }
    enable_dumping_buffers_on_dese(path_override$0, 0);
   }
   else{
    var
     match$0 =
       caml_call1(Async_unix_Async_sys[14], cst_ASYNC_RPC_DEBUG_DUMP_MESSA);
    a:
    if(match$0 && caml_string_notequal(match$0[1], cst$0)){enable_dumping_buffers_on_dese(0, 0); break a;}
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_rpc);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_rpc_Rpc);
   var
    Async_rpc_Rpc =
      [0,
       [0,
        sexp_of_t,
        description,
        add_heartbeat_callback,
        reset_heartbeat_timeout,
        last_seen_alive,
        close,
        close_finished,
        close_reason,
        is_closed,
        bytes_to_write,
        bytes_written,
        bytes_read,
        flushed,
        peer_menu,
        peer_menu$0,
        my_menu,
        peer_identification,
        create,
        contains_magic_prefix,
        with_close,
        server_with_close,
        serve,
        serve_inet,
        serve_unix,
        client$0,
        client,
        with_client$0,
        with_client],
       [0, enable_dumping_buffers_on_dese]];
   runtime.caml_register_global(58, Async_rpc_Rpc, cst_Async_rpc_Rpc$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_rpc
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_rpc = "Async_rpc",
    cst_async_rpc = "async_rpc";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_rpc);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_rpc);
   caml_call1(Ppx_expect_runtime[1][1], "async_rpc/src/async_rpc.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_rpc, "async_rpc.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_rpc);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_rpc);
   var Async_rpc = [0];
   runtime.caml_register_global(11, Async_rpc, cst_Async_rpc);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhc3luY19ycGMuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVycm9yX3NvdXJjZV8wMDIiLCJkZWZhdWx0X3dyaXRlX3RpbWVvdXQiLCJkZWZhdWx0X21heF9tZXNzYWdlX3NpemUiLCJkZWZhdWx0X21heF9idWZmZXJfc2l6ZSIsImRlZmF1bHRfc3RhcnRfYmF0Y2hpbmdfYWZ0ZXJfbiIsImRlZmF1bHRfaW5pdGlhbF9idWZmZXJfc2l6ZSIsImRlZmF1bHRfYnVmZmVyaW5nX3RocmVzaG9sZF9pbiIsInNleHBfb2ZfdCIsInN0YXJ0X2JhdGNoaW5nX2FmdGVyX251bV9tZXNzYSIsImJ1ZmZlcmluZ190aHJlc2hvbGRfaW5fYnl0ZXNfMCIsIndyaXRlX3RpbWVvdXRfMDE3IiwibWF4X2J1ZmZlcl9zaXplXzAxNSIsImluaXRpYWxfYnVmZmVyX3NpemVfMDEzIiwibWF4X21lc3NhZ2Vfc2l6ZV8wMTEiLCJhcmdfMDIyIiwiYm5kc18wMTAiLCJhcmdfMDIwIiwiYm5kc18wMTAkMCIsImFyZ18wMTgiLCJibmRzXzAxMCQxIiwiYXJnXzAxNiIsImJuZHNfMDEwJDIiLCJhcmdfMDE0IiwiYm5kc18wMTAkMyIsImFyZ18wMTIiLCJibmRzXzAxMCQ0IiwidmFsaWRhdGUiLCJ0IiwidF9vZl9zZXhwIiwieF8wMDkiLCJidWZmZXJpbmdfdGhyZXNob2xkX2luX2J5dGVzIiwid3JpdGVfdGltZW91dCIsIm1heF9idWZmZXJfc2l6ZSIsImluaXRpYWxfYnVmZmVyX3NpemUiLCJtYXhfbWVzc2FnZV9zaXplIiwiY3JlYXRlIiwib3B0Iiwic3RoIiwic3RoJDAiLCJzdGgkMSIsInN0aCQyIiwic3RoJDMiLCJzdGgkNCIsImRlZmF1bHQkMCIsIm1lc3NhZ2Vfc2l6ZV9vayIsInBheWxvYWRfbGVuIiwiZ3Jvd19idWZmZXIiLCJidWYiLCJuZXdfc2l6ZV9yZXF1ZXN0IiwibGVuIiwic2V0X25vbmJsb2NraW5nIiwiZmQiLCJzZXhwX29mX3QkMCIsImNvbmZpZ18wMjYiLCJmZF8wMjQiLCJyZWFkaW5nXzAyOCIsImNsb3NlZF8wMzAiLCJjbG9zZV9maW5pc2hlZF8wMzIiLCJidWZfMDM0IiwicG9zXzAzNiIsIm1heF8wMzgiLCJieXRlc19yZWFkXzA0MCIsImFyZ18wNDEiLCJibmRzXzAyMyIsImFyZ18wMzkiLCJibmRzXzAyMyQwIiwiYXJnXzAzNyIsImJuZHNfMDIzJDEiLCJhcmdfMDM1IiwiYm5kc18wMjMkMiIsImFyZ18wMzMiLCJibmRzXzAyMyQzIiwiYXJnXzAzMSIsImJuZHNfMDIzJDQiLCJhcmdfMDI5IiwiYm5kc18wMjMkNSIsImFyZ18wMjciLCJibmRzXzAyMyQ2IiwiYXJnXzAyNSIsImJuZHNfMDIzJDciLCJpc19jbG9zZWQiLCJjbG9zZV9maW5pc2hlZCIsImJ5dGVzX3JlYWQiLCJub25lIiwiaXNfcnVubmluZyIsImludGVycnVwdCIsInJlYXNvbiIsImNhbl9wcm9jZXNzX21lc3NhZ2UiLCJwcm9jZXNzX3JlY2VpdmVkX21lc3NhZ2VzIiwidCQwIiwicmVhZF9vcl9wZWVrIiwidCQxIiwicG9zIiwiYXZhaWxhYmxlIiwidG90YWxfbGVuIiwibGVuJDAiLCJzdGFydCIsIngiLCJkIiwic3RvcF93YXRjaGluZ19vbl9lcnJvciIsIm1vbml0b3IiLCJwYXJlbnQiLCJleG4iLCJydW4iLCJyZWFkZXIiLCJhbGxvd19idWZmZXJpbmciLCJvbl9tZXNzYWdlIiwib25fZW5kX29mX2JhdGNoIiwiaW50ZXJydXB0JDAiLCJhdmFpbGFibGVfYnVmZmVyX2NhcGFjaXR5IiwicmVzdWx0IiwiZXJyb3IiLCJuIiwicmVhZF9vcl9wZWVrX2Rpc3BhdGNoZXIiLCJkaXNwYXRjaGVyX2ltcGwiLCJjYWxsZXJfbmFtZSIsInJlYWRfZm9yZXZlciIsInJlYWRfZm9yZXZlciQwIiwiY2xvc2UiLCJzZXhwX29mX2ZsdXNoIiwiaXZhcl8wNDYiLCJwb3NfMDQ0IiwiYXJnXzA0NyIsImJuZHNfMDQzIiwiYXJnXzA0NSIsImJuZHNfMDQzJDAiLCJzdGFydF9jbG9zZSIsImlzX2FibGVfdG9fc2VuZF9kYXRhIiwic2V4cF9vZl90JDEiLCJjb25uZWN0aW9uX3N0YXRlXzA2MCIsImNvbmZpZ18wNTgiLCJmZF8wNTYiLCJ3cml0aW5nXzA2MiIsImJ1Zl8wNjQiLCJwb3NfMDY2IiwiYnl0ZXNfd3JpdHRlbl8wNjgiLCJmbHVzaGVzXzA3MiIsIm1vbml0b3JfMDcwIiwibGFzdF9zZW5kX2pvYl8wNzQiLCJzZW5kc19pbl90aGlzX2pvYl8wNzYiLCJhcmdfMDc3IiwiYm5kc18wNTUiLCJhcmdfMDc1IiwiYm5kc18wNTUkMCIsImFyZ18wNzMiLCJibmRzXzA1NSQxIiwiYXJnXzA3MSIsImJuZHNfMDU1JDIiLCJhcmdfMDY5IiwiYm5kc18wNTUkMyIsImFyZ18wNjciLCJibmRzXzA1NSQ0IiwiYXJnXzA2NSIsImJuZHNfMDU1JDUiLCJhcmdfMDYzIiwiYm5kc18wNTUkNiIsImNvbm5lY3Rpb25fbG9zdF8wNTMiLCJjbG9zZV9maW5pc2hlZF8wNTEiLCJjbG9zZV9zdGFydGVkXzA0OSIsImFyZ18wNTQiLCJibmRzXzA0OCIsImFyZ18wNTIiLCJibmRzXzA0OCQwIiwiYXJnXzA1MCIsImJuZHNfMDQ4JDEiLCJhcmdfMDYxIiwiYm5kc18wNTUkNyIsImFyZ18wNTkiLCJibmRzXzA1NSQ4IiwiYXJnXzA1NyIsImJuZHNfMDU1JDkiLCJyIiwiYnl0ZXNfd3JpdHRlbiIsImlzX2Nsb3NlZCQwIiwiYnl0ZXNfdG9fd3JpdGUiLCJzdG9wcGVkIiwiZmx1c2hlZCIsImZsdXNoIiwiZGlzY2FyZCIsInJlbWFpbmluZyIsImhhbmRsZV9lcnJvciIsImZpbmlzaF9jbG9zZSIsImZkX2Nsb3NlZCIsIndyaXRlX2V2ZXJ5dGhpbmciLCJleG4kMCIsIndhaXRfYW5kX3dyaXRlX2V2ZXJ5dGhpbmciLCJyZXN1bHQkMCIsImVuc3VyZV9hdF9sZWFzdCIsIm5lZWRlZCIsImNvcHlfYnl0ZXMiLCJzbG93X3dyaXRlX2Jpbl9wcm90X2FuZF9iaWdzdHIiLCJ3cml0ZXIiLCJtc2ciLCJzdG9wIiwic2VuZF9iaW5fcHJvdF9hbmRfYmlnc3RyaW5nIiwiY3VycmVudF9qb2IiLCJzZW5kX25vdyIsIndyaXR0ZW5fZnJvbV9vdGhlcl9idWYiLCJyZW1haW5pbmdfaW5fb3RoZXJfYnVmIiwic3lzY2FsbCIsInNlbmRfYmluX3Byb3RfYW5kX2JpZ3N0cmluZ19ubyIsImJ5dGVzIiwiZHVtbXlfYnVmIiwic2VuZF9iaW5fcHJvdCIsImNsb3NlJDAiLCJtYWtlX2NyZWF0ZSIsImYiLCJjb25maWciLCJtYXhfbWVzc2FnZV9zaXplJDAiLCJjb25maWckMCIsImNyZWF0ZV9pbnRlcm5hbCIsImludGVybmFsX3JlYWRlciIsImNyZWF0ZSQwIiwidHJhbnNwb3J0X3JlYWRlciIsInJlYWRfb25lX21lc3NhZ2VfYmluX3Byb3Rfd2l0aCIsImJpbl9yZWFkZXIiLCJwb3NfcmVmIiwicGVla19iaW5fcHJvdCIsInBlZWtfb25jZV93aXRob3V0X2J1ZmZlcmluZ19mciIsImZpbGVfZGVzY3IiLCJwZWVrX2xlbiIsImNyZWF0ZSQxIiwiaW50ZXJuYWwiLCJjcmVhdGVfaW50ZXJuYWwkMCIsImNyZWF0ZSQyIiwic2V4cF9vZl90JDQiLCJ3cml0ZXJfMDgxIiwicmVhZGVyXzA3OSIsImFyZ18wODIiLCJibmRzXzA3OCIsImFyZ18wODAiLCJibmRzXzA3OCQwIiwiY3JlYXRlX2ludGVybmFsJDEiLCJjcmVhdGUkMyIsImNsb3NlJDMiLCJjcmVhdGUkNCIsIm1heF9tZXNzYWdlX3NpemVfZW52X3ZhciIsIm1heF9tZXNzYWdlX3NpemVfZnJvbV9lbnZpcm9ubSIsImF1eF9lZmZlY3RpdmVfbWF4X21lc3NhZ2Vfc2l6ZSIsInByb3Bvc2VkX21heCIsInkiLCJ4JDAiLCJ0ZXN0IiwiZWZmZWN0aXZlX21heCIsImVmZmVjdGl2ZV9tYXhfbWVzc2FnZV9zaXplIiwibWF4X21lc3NhZ2Vfc2l6ZV9mcm9tX2Vudmlyb25tJDAiLCJvZl9hXzAwMiIsIm1heF9tZXNzYWdlX3NpemVfMDA2IiwidF8wMDQiLCJ0b3RhbF9ieXRlc18wMDgiLCJhcmdfMDA5IiwiYm5kc18wMDMiLCJhcmdfMDA3IiwiYm5kc18wMDMkMCIsImFyZ18wMDUiLCJibmRzXzAwMyQxIiwiaW5jcl90b3RhbF9ieXRlcyIsInhfMDE2IiwiYWxsX3VuaXRfdGhlbl9yZXR1cm4iLCJsIiwicmV0X3ZhbCIsImZpbmlzaF9sb29wIiwiY29uc3VtZWQiLCJuZWVkIiwid2FpdF9iZWZvcmVfcmVhZGluZyIsImhhbmRsZV9jaHVuayIsInBvcyQyIiwibGVuJDIiLCJhcmcxXzAxMyIsImFyZzBfMDEyIiwidl8wMTAiLCJyZXMwXzAxNCIsInZfMDExIiwicmVzMV8wMTUiLCJjb25zdW1lZCQwIiwicG9zJDAiLCJ3YWl0X2JlZm9yZV9yZWFkaW5nJDAiLCJsZW4kMSIsInBvcyQxIiwieF8wMTgiLCJiaW5fd3JpdGVfcGF5bG9hZF9sZW5ndGgiLCJzZW5kX2Jpbl9wcm90X2ludGVybmFsIiwiYmluX3dyaXRlciIsImZvbGxvd3VwX2xlbiIsImRhdGFfbGVuIiwib2ZfcmVhZGVyIiwib2Zfd3JpdGVyIiwid3JpdGVyXzAyMiIsInJlYWRlcl8wMjAiLCJhcmdfMDIzIiwiYm5kc18wMTkiLCJhcmdfMDIxIiwiYm5kc18wMTkkMCIsIm9mX3JlYWRlcl93cml0ZXIiLCJvZl9mZCIsImJ1ZmZlcl9hZ2VfbGltaXQiLCJyZWFkZXJfYnVmZmVyX3NpemUiLCJ3cml0ZXJfYnVmZmVyX3NpemUiLCJkZWZhdWx0X3RyYW5zcG9ydF9tYWtlciIsIm1ha2Vfc2VydmVfZnVuY193aXRoX2ZkIiwidGNwX2NyZWF0b3IiLCJ3aGVyZV90b19saXN0ZW4iLCJtYXhfY29ubmVjdGlvbnMiLCJiYWNrbG9nIiwiZHJvcF9pbmNvbWluZ19jb25uZWN0aW9ucyIsInRpbWVfc291cmNlIiwiaGFuZGxlX3RyYW5zcG9ydCIsIm1ha2VfdHJhbnNwb3J0IiwiYXV0aCIsIm9uX2hhbmRsZXJfZXJyb3IiLCJjbGllbnRfYWRkciIsInNvY2tldCIsInRyYW5zcG9ydCIsIm1ha2Vfc2VydmVfZnVuYyIsInNlcnZlcl9hZGRyIiwic2VydmUiLCJzZXJ2ZV9pbmV0Iiwic2VydmVfdW5peCIsInBlZXJfY3JlZGVudGlhbHMiLCJjb25uZWN0Iiwid2hlcmVfdG9fY29ubmVjdCIsInRjcF9jb25uZWN0X3RpbWVvdXQiLCJzb2NrIiwic29jayQwIiwic29ja19wZWVybmFtZSIsImV4bl9jb3VsZF9iZV9yYWlzZWRfaWZfdGhlX3NvYyQwIiwiZXhuX2NvdWxkX2JlX3JhaXNlZF9pZl90aGVfc29jIiwiaW1wbGVtZW50YXRpb25zIiwiY29ubmVjdGlvbl9zdGF0ZSIsImhhbmRzaGFrZV90aW1lb3V0IiwiaGVhcnRiZWF0X2NvbmZpZyIsImRlc2NyaXB0aW9uIiwiaWRlbnRpZmljYXRpb24iLCJjb250YWluc19tYWdpY19wcmVmaXgiLCJiIiwid2l0aF9jbG9zZSIsImRpc3BhdGNoX3F1ZXJpZXMiLCJvbl9oYW5kc2hha2VfZXJyb3IiLCJzZXJ2ZXJfd2l0aF9jbG9zZSIsInNlcnZlX3dpdGhfdHJhbnNwb3J0IiwicmVzIiwiaGFuZHNoYWtlX2Vycm9yIiwiZSIsImNvbm5lY3Rpb25fZGVzY3JpcHRpb24iLCJkZXNjcmlwdGlvbiQwIiwiZGVmYXVsdF9vbl9oYW5kc2hha2VfZXJyb3IiLCJzZXJ2ZV93aXRoX3RyYW5zcG9ydF9oYW5kbGVyIiwiaW5pdGlhbF9jb25uZWN0aW9uX3N0YXRlIiwiY29ubiIsInBlZXJfY3JlZHMiLCJkZWZhdWx0X2hhbmRzaGFrZV90aW1lb3V0X2Zsb2EiLCJjbGllbnQiLCJoYW5kc2hha2VfdGltZW91dF9mbG9hdCIsImZpbmlzaF9oYW5kc2hha2VfYnkiLCJkZXNjIiwieF8wMDMiLCJycGNfY29ubmVjdGlvbiIsImltcGxlbWVudGF0aW9ucyQwIiwiaW1wbGVtZW50YXRpb25zJDEiLCJjb25uZWN0aW9uX3N0YXRlJDAiLCJjbGllbnQkMCIsIndpdGhfY2xpZW50IiwicmVtb3RlX3NlcnZlciIsIndpdGhfY2xpZW50JDAiLCJkZWZhdWx0X3BhdGgiLCJwYXRoX292ZXJyaWRlIiwiZHVtcF9kZXNlcmlhbGl6YXRpb25fZXJyb3IiLCJvcGVuX2ZpbGUiLCJwYXRoIiwicGF0aCQwIiwiZSQwIiwiZW5hYmxlX2R1bXBpbmdfYnVmZmVyc19vbl9kZXNlIiwib3ZlcnJpZGUiLCJvdmVycmlkZSQwIiwiZHVtcF90byIsInBhdGhfb3ZlcnJpZGUkMCJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jL2FzeW5jX3JwYy9hc3luY19ycGNfXy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jL2FzeW5jX3JwYy9ycGNfdHJhbnNwb3J0X2xvd19sYXRlbmN5Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmMvYXN5bmNfcnBjL3JwY190cmFuc3BvcnQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luYy9hc3luY19ycGMvcnBjLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0dBY3FCOztJQUFBOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7OztJQ3dCbkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWpCNEI7SUFBeEJDLHdCQUF3QjtJQUd4QkM7SUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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O0tBQ0YsWUFQQUY7O1VBVVNHLGlCQUhMQyxTQUdLRDs7VUFITEMsU0FFUSxzQkFiWkw7S0FnQkE7YUFBRSx3REFMRUs7YUFBQUE7SUFlSTtJQUVWLElBQ00sSUFBQSxNQW5CRkY7VUFvQkF2TDtTQUFBbEYsMEJBQUFrRjtLQUNHLEdBQUEsNEJBM0JMcUw7TUE0Qk8sTUFBQSw0QkFGTHZRO0tBMUJGdVE7aUJBTUVFOztRQWtCSUMsaUJBQUo3VDs7O0tBU0osSUFDUSxnQ0FWSkEsVUF0QnlCSjtXQW1DZm1VO01BS1I7T0FMUTVCLHdCQUFBNEI7T0FLUixNQUFBLHlCQUxRNUI7T0FKVnhPLFNBS0EsMkJBZElrUSxNQXRCMEJwUjs7O1NBK0I5QmtCLFNBR0EsMkJBWklrUSxNQXRCMEJwUjs7SUEwQ2xDLDZCQXBCSXpDO0lBb0JKLE9BWEkyRDtHQVlFO1lBR0pxUSwrQkFBZ0VDO0lBQ2xFLEdBRGtFQTtTQUcxREMsYUFIMEREO0tBaERoRVAsdUJBbURNUTs7a0NBakROUDs7R0FtRDZCO0dBSXpCOztNQUFBOztRQVdBUTs7Ozs0QkFBQUE7K0JBQUFBO01BRGE7T0FBQTtTQUFBLGtDQUNiQTtnQkFBQUE7Z0JBQWdCLG1DQUFoQkE7T0FKQUM7OztTQUFBQTs7SUFoQkpKLCtCQWdCSUk7OztJQUpHOztPQUFBOzsyREFaUEo7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQXpiQWhWO1FBc0JBMFM7UUFTQUU7UUF3QkFHO1FBdUlBdkI7UUFHQUM7UUFJQUM7UUFxSEEyQztRQXJFQVQ7UUF1SEFZO1FBNUJBRjtXQXlHQVU7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX3JwYy5JbXBvcnQgKilcbm1vZHVsZSBJbXBvcnQgPSBBc3luY19ycGNfX0ltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19ycGMuUnBjICopXG5tb2R1bGUgUnBjID0gQXN5bmNfcnBjX19ScGNcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfcnBjLlJwY190cmFuc3BvcnQgKilcbm1vZHVsZSBScGNfdHJhbnNwb3J0ID0gQXN5bmNfcnBjX19ScGNfdHJhbnNwb3J0XG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX3JwYy5ScGNfdHJhbnNwb3J0X2xvd19sYXRlbmN5ICopXG5tb2R1bGUgUnBjX3RyYW5zcG9ydF9sb3dfbGF0ZW5jeSA9IEFzeW5jX3JwY19fUnBjX3RyYW5zcG9ydF9sb3dfbGF0ZW5jeVxuXG5tb2R1bGUgQXN5bmNfcnBjX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm1vZHVsZSBLZXJuZWxfdHJhbnNwb3J0ID0gUnBjX2tlcm5lbC5UcmFuc3BvcnRcbm1vZHVsZSBIZWFkZXIgPSBLZXJuZWxfdHJhbnNwb3J0LkhlYWRlclxubW9kdWxlIEhhbmRsZXJfcmVzdWx0ID0gS2VybmVsX3RyYW5zcG9ydC5IYW5kbGVyX3Jlc3VsdFxubW9kdWxlIFNlbmRfcmVzdWx0ID0gS2VybmVsX3RyYW5zcG9ydC5TZW5kX3Jlc3VsdFxuXG5leHRlcm5hbCB3cml0ZXYyXG4gIDogIENvcmVfdW5peC5GaWxlX2Rlc2NyLnRcbiAgLT4gYnVmMTpCaWdzdHJpbmcudFxuICAtPiBwb3MxOmludFxuICAtPiBsZW4xOmludFxuICAtPiBidWYyOkJpZ3N0cmluZy50XG4gIC0+IHBvczI6aW50XG4gIC0+IGxlbjI6aW50XG4gIC0+IFVuaXguU3lzY2FsbF9yZXN1bHQuSW50LnRcbiAgPSBcImFzeW5jX2V4dHJhX3JwY193cml0ZXYyX2J5dGVcIiBcImFzeW5jX2V4dHJhX3JwY193cml0ZXYyXCJcbiAgW0BAbm9hbGxvY11cblxubW9kdWxlIENvbmZpZyA9IHN0cnVjdFxuICAoKiBTYW1lIGFzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIFtidWZmZXJfYWdlX2xpbWl0XSBmb3IgW0FzeW5jX3VuaXguV3JpdGVyXSAqKVxuICBsZXQgZGVmYXVsdF93cml0ZV90aW1lb3V0ID0gVGltZV9ucy5TcGFuLm9mX21pbiAyLlxuXG4gICgqIE5vIG1heGltdW0gKilcbiAgbGV0IGRlZmF1bHRfbWF4X21lc3NhZ2Vfc2l6ZSA9IEludC5tYXhfdmFsdWVcbiAgbGV0IGRlZmF1bHRfbWF4X2J1ZmZlcl9zaXplID0gSW50Lm1heF92YWx1ZVxuXG4gICgqIEluIGdlbmVyYWwgd2UnbGwgc2VuZCAxIG1lc3NhZ2UgcGVyIGpvYiwgaWYgd2Ugc2VuZCAyIHRoZXJlIGlzIGEgZ29vZCBjaGFuY2Ugd2UgYXJlXG4gICAgIHNlbmRpbmcgYSBiYXRjaC5cblxuICAgICBEZWZhdWx0IHNob3VsZCBhY3R1YWxseSBiZSAxLCBidXQgdGhlcmUgd2FzIGEgYnVnIHRoYXQgbWFkZSBpdCAyIGluIHByYWN0aWNlLCBzbyB3ZVxuICAgICBrZWVwIDIgYXMgYSBkZWZhdWx0LiAqKVxuICBsZXQgZGVmYXVsdF9zdGFydF9iYXRjaGluZ19hZnRlcl9udW1fbWVzc2FnZXMgPSAyXG5cbiAgKCogQXJiaXRyYXJ5IGNob2ljZXMuICopXG4gIGxldCBkZWZhdWx0X2luaXRpYWxfYnVmZmVyX3NpemUgPSA2NCAqIDEwMjRcbiAgbGV0IGRlZmF1bHRfYnVmZmVyaW5nX3RocmVzaG9sZF9pbl9ieXRlcyA9IDMyICogMTAyNFxuXG4gIHR5cGUgdCA9XG4gICAgeyBtYXhfbWVzc2FnZV9zaXplIDogaW50IFtAZGVmYXVsdCBkZWZhdWx0X21heF9tZXNzYWdlX3NpemVdXG4gICAgOyBpbml0aWFsX2J1ZmZlcl9zaXplIDogaW50IFtAZGVmYXVsdCBkZWZhdWx0X2luaXRpYWxfYnVmZmVyX3NpemVdXG4gICAgOyBtYXhfYnVmZmVyX3NpemUgOiBpbnQgW0BkZWZhdWx0IGRlZmF1bHRfbWF4X2J1ZmZlcl9zaXplXVxuICAgIDsgd3JpdGVfdGltZW91dCA6IFRpbWVfbnMuU3Bhbi50IFtAZGVmYXVsdCBkZWZhdWx0X3dyaXRlX3RpbWVvdXRdXG4gICAgOyBidWZmZXJpbmdfdGhyZXNob2xkX2luX2J5dGVzIDogaW50IFtAZGVmYXVsdCBkZWZhdWx0X2J1ZmZlcmluZ190aHJlc2hvbGRfaW5fYnl0ZXNdXG4gICAgOyBzdGFydF9iYXRjaGluZ19hZnRlcl9udW1fbWVzc2FnZXMgOiBpbnRcbiAgICAgICAgIFtAZGVmYXVsdCBkZWZhdWx0X3N0YXJ0X2JhdGNoaW5nX2FmdGVyX251bV9tZXNzYWdlc11cbiAgICB9XG4gIFtAQGRlcml2aW5nIHNleHBdXG5cbiAgbGV0IHZhbGlkYXRlIHQgPVxuICAgIGlmIHQuaW5pdGlhbF9idWZmZXJfc2l6ZSA8PSAwXG4gICAgICAgfHwgdC5tYXhfbWVzc2FnZV9zaXplIDw9IDBcbiAgICAgICB8fCB0LmluaXRpYWxfYnVmZmVyX3NpemUgPiB0Lm1heF9idWZmZXJfc2l6ZVxuICAgICAgIHx8IHQubWF4X21lc3NhZ2Vfc2l6ZSA+IHQubWF4X2J1ZmZlcl9zaXplXG4gICAgICAgfHwgdC5idWZmZXJpbmdfdGhyZXNob2xkX2luX2J5dGVzIDwgMFxuICAgICAgIHx8IHQuc3RhcnRfYmF0Y2hpbmdfYWZ0ZXJfbnVtX21lc3NhZ2VzIDwgMFxuICAgICAgIHx8IFRpbWVfbnMuU3Bhbi4oIDw9ICkgdC53cml0ZV90aW1lb3V0IFRpbWVfbnMuU3Bhbi56ZXJvXG4gICAgdGhlblxuICAgICAgZmFpbHdpdGhzXG4gICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgXCJScGNfdHJhbnNwb3J0X2xvd19sYXRlbmN5LkNvbmZpZy52YWxpZGF0ZTogaW52YWxpZCBjb25maWdcIlxuICAgICAgICB0XG4gICAgICAgIHNleHBfb2ZfdDtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIHNleHAgfD4gdmFsaWRhdGVcblxuICBsZXQgY3JlYXRlXG4gICAgPyhtYXhfbWVzc2FnZV9zaXplID0gZGVmYXVsdF9tYXhfbWVzc2FnZV9zaXplKVxuICAgID8oaW5pdGlhbF9idWZmZXJfc2l6ZSA9IGRlZmF1bHRfaW5pdGlhbF9idWZmZXJfc2l6ZSlcbiAgICA/KG1heF9idWZmZXJfc2l6ZSA9IGRlZmF1bHRfbWF4X2J1ZmZlcl9zaXplKVxuICAgID8od3JpdGVfdGltZW91dCA9IGRlZmF1bHRfd3JpdGVfdGltZW91dClcbiAgICA/KGJ1ZmZlcmluZ190aHJlc2hvbGRfaW5fYnl0ZXMgPSBkZWZhdWx0X2J1ZmZlcmluZ190aHJlc2hvbGRfaW5fYnl0ZXMpXG4gICAgPyhzdGFydF9iYXRjaGluZ19hZnRlcl9udW1fbWVzc2FnZXMgPSBkZWZhdWx0X3N0YXJ0X2JhdGNoaW5nX2FmdGVyX251bV9tZXNzYWdlcylcbiAgICAoKVxuICAgID1cbiAgICB2YWxpZGF0ZVxuICAgICAgeyBtYXhfbWVzc2FnZV9zaXplXG4gICAgICA7IGluaXRpYWxfYnVmZmVyX3NpemVcbiAgICAgIDsgbWF4X2J1ZmZlcl9zaXplXG4gICAgICA7IHdyaXRlX3RpbWVvdXRcbiAgICAgIDsgYnVmZmVyaW5nX3RocmVzaG9sZF9pbl9ieXRlc1xuICAgICAgOyBzdGFydF9iYXRjaGluZ19hZnRlcl9udW1fbWVzc2FnZXNcbiAgICAgIH1cbiAgOztcblxuICBsZXQgZGVmYXVsdCA9IGNyZWF0ZSAoKVxuXG4gIGxldCBtZXNzYWdlX3NpemVfb2sgdCB+cGF5bG9hZF9sZW4gPVxuICAgIHBheWxvYWRfbGVuID49IDAgJiYgcGF5bG9hZF9sZW4gPD0gdC5tYXhfbWVzc2FnZV9zaXplXG4gIDs7XG5cbiAgbGV0IGNoZWNrX21lc3NhZ2Vfc2l6ZSB0IH5wYXlsb2FkX2xlbiA9XG4gICAgaWYgbm90IChtZXNzYWdlX3NpemVfb2sgdCB+cGF5bG9hZF9sZW4pXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJXNleHBcbiAgICAgICAgICBcIlJwY190cmFuc3BvcnRfbG93X2xhdGVuY3k6IG1lc3NhZ2UgdG9vIHNtYWxsIG9yIHRvbyBiaWdcIlxuICAgICAgICAgICwgeyBtZXNzYWdlX3NpemUgPSAocGF5bG9hZF9sZW4gOiBpbnQpOyBjb25maWcgPSAodCA6IHQpIH1dXG4gIDs7XG5cbiAgbGV0IGdyb3dfYnVmZmVyIHQgYnVmIH5uZXdfc2l6ZV9yZXF1ZXN0ID1cbiAgICBhc3NlcnQgKG5ld19zaXplX3JlcXVlc3QgPiBCaWdzdHJpbmcubGVuZ3RoIGJ1Zik7XG4gICAgaWYgbmV3X3NpemVfcmVxdWVzdCA+IHQubWF4X2J1ZmZlcl9zaXplXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJXNleHBcbiAgICAgICAgICBcIlJwY190cmFuc3BvcnRfbG93X2xhdGVuY3k6IGNhbm5vdCBncm93IGJ1ZmZlclwiXG4gICAgICAgICAgLCB7IG5ld19zaXplX3JlcXVlc3QgOiBpbnQ7IGNvbmZpZyA9ICh0IDogdCkgfV07XG4gICAgbGV0IGxlbiA9IEludC5taW4gdC5tYXhfYnVmZmVyX3NpemUgKEludC5jZWlsX3BvdzIgbmV3X3NpemVfcmVxdWVzdCkgaW5cbiAgICBCaWdzdHJpbmcudW5zYWZlX2Rlc3Ryb3lfYW5kX3Jlc2l6ZSBidWYgfmxlblxuICA7O1xuZW5kXG5cbmxldCBzZXRfbm9uYmxvY2tpbmcgZmQgPSBGZC53aXRoX2ZpbGVfZGVzY3JfZXhuIGZkIGlnbm9yZSB+bm9uYmxvY2tpbmc6dHJ1ZVxuXG5tb2R1bGUgUmVhZGVyX2ludGVybmFsID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBmZCA6IEZkLnRcbiAgICA7IGNvbmZpZyA6IENvbmZpZy50XG4gICAgOyBtdXRhYmxlIHJlYWRpbmcgOiBib29sXG4gICAgOyBtdXRhYmxlIGNsb3NlZCA6IGJvb2xcbiAgICA7IGNsb3NlX2ZpbmlzaGVkIDogdW5pdCBJdmFyLnRcbiAgICA7IG11dGFibGUgYnVmIDogKEJpZ3N0cmluZy50W0BzZXhwLm9wYXF1ZV0pXG4gICAgOyBtdXRhYmxlIHBvcyA6IGludCAoKiBTdGFydCBvZiB1bmNvbnN1bWVkIGRhdGEuICopXG4gICAgOyBtdXRhYmxlIG1heCA6IGludCAoKiBFbmQgICBvZiB1bmNvbnN1bWVkIGRhdGEuICopXG4gICAgOyBtdXRhYmxlIGJ5dGVzX3JlYWQgOiBJbnQ2My50XG4gICAgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBjcmVhdGUgZmQgY29uZmlnID1cbiAgICBzZXRfbm9uYmxvY2tpbmcgZmQ7XG4gICAgeyBmZFxuICAgIDsgY29uZmlnXG4gICAgOyByZWFkaW5nID0gZmFsc2VcbiAgICA7IGNsb3NlZCA9IGZhbHNlXG4gICAgOyBjbG9zZV9maW5pc2hlZCA9IEl2YXIuY3JlYXRlICgpXG4gICAgOyBidWYgPSBCaWdzdHJpbmcuY3JlYXRlIGNvbmZpZy5pbml0aWFsX2J1ZmZlcl9zaXplXG4gICAgOyBwb3MgPSAwXG4gICAgOyBtYXggPSAwXG4gICAgOyBieXRlc19yZWFkID0gSW50NjMuemVyb1xuICAgIH1cbiAgOztcblxuICBsZXQgaXNfY2xvc2VkIHQgPSB0LmNsb3NlZFxuICBsZXQgY2xvc2VfZmluaXNoZWQgdCA9IEl2YXIucmVhZCB0LmNsb3NlX2ZpbmlzaGVkXG4gIGxldCBieXRlc19yZWFkIHQgPSB0LmJ5dGVzX3JlYWRcblxuICAoKiBUbyBhdm9pZCBhbGxvY2F0aW5nIG9wdGlvbnMgaW4gYSByZWxhdGl2ZWx5IHNhZmUgd2F5LiAqKVxuICBtb2R1bGUgTWVzc2FnZV9sZW4gOiBzaWdcbiAgICB0eXBlIHQgPSBwcml2YXRlIGludFxuXG4gICAgdmFsIG5vbmUgOiB0XG4gICAgdmFsIGlzX3NvbWUgOiB0IC0+IGJvb2xcbiAgICB2YWwgY3JlYXRlX2V4biA6IGludCAtPiB0XG5cbiAgICAoKiBmYWlscyBvbiBuZWdhdGl2ZSBpbnRzICopXG5cbiAgICB2YWwgdmFsdWVfZXhuIDogdCAtPiBpbnRcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSB0ID0gaW50XG5cbiAgICBsZXQgbm9uZSA9IC0xXG4gICAgbGV0IGlzX3NvbWUgdCA9IHQgPj0gMFxuXG4gICAgbGV0IGNyZWF0ZV9leG4gbiA9XG4gICAgICBpZiBuIDwgMCB0aGVuIGZhaWx3aXRoZiBcIk1lc3NhZ2VfbGVuLmNyZWF0ZV9leG4gb2YgbmVnYXRpdmUgaW50OiAlZFwiIG4gKCkgZWxzZSBuXG4gICAgOztcblxuICAgIGxldCB2YWx1ZV9leG4gdCA9IGlmIHQgPCAwIHRoZW4gZmFpbHdpdGggXCJNZXNzYWdlX2xlbi52YWx1ZV9leG4gb2YgTm9uZVwiIGVsc2UgdFxuICBlbmRcblxuICAoKiBJZiBvbmUgZnVsbCBtZXNzYWdlIGlzIGF2YWlsYWJsZSwgcmV0dXJucyBpdHMgbGVuZ3RoIChub3QgaW5jbHVkaW5nIHRoZVxuICAgICBoZWFkZXIpLiBSZXR1cm5zIFtNZXNzYWdlX2xlbi5ub25lXSBvdGhlcndpc2UuICopXG4gIGxldCBnZXRfcGF5bG9hZF9sZW5ndGhfb2ZfbmV4dF9hdmFpbGFibGVfbWVzc2FnZSB0ID1cbiAgICBsZXQgcG9zID0gdC5wb3MgaW5cbiAgICBsZXQgYXZhaWxhYmxlID0gdC5tYXggLSBwb3MgaW5cbiAgICBpZiBhdmFpbGFibGUgPj0gSGVhZGVyLmxlbmd0aFxuICAgIHRoZW4gKFxuICAgICAgbGV0IHBheWxvYWRfbGVuID0gSGVhZGVyLnVuc2FmZV9nZXRfcGF5bG9hZF9sZW5ndGggdC5idWYgfnBvcyBpblxuICAgICAgbGV0IHRvdGFsX2xlbiA9IHBheWxvYWRfbGVuICsgSGVhZGVyLmxlbmd0aCBpblxuICAgICAgQ29uZmlnLmNoZWNrX21lc3NhZ2Vfc2l6ZSB0LmNvbmZpZyB+cGF5bG9hZF9sZW47XG4gICAgICBpZiB0b3RhbF9sZW4gPD0gYXZhaWxhYmxlXG4gICAgICB0aGVuIE1lc3NhZ2VfbGVuLmNyZWF0ZV9leG4gcGF5bG9hZF9sZW5cbiAgICAgIGVsc2UgKFxuICAgICAgICBpZiB0b3RhbF9sZW4gPiBCaWdzdHJpbmcubGVuZ3RoIHQuYnVmXG4gICAgICAgIHRoZW4gdC5idWYgPC0gQ29uZmlnLmdyb3dfYnVmZmVyIHQuY29uZmlnIHQuYnVmIH5uZXdfc2l6ZV9yZXF1ZXN0OnRvdGFsX2xlbjtcbiAgICAgICAgTWVzc2FnZV9sZW4ubm9uZSkpXG4gICAgZWxzZSBNZXNzYWdlX2xlbi5ub25lXG4gIDs7XG5cbiAgbGV0IGdldF9taW5pbWFsX2xlbmd0aF90b19yZWFkX2Zvcl9zaW5nbGVfbWVzc2FnZSB0ID1cbiAgICBsZXQgcG9zID0gdC5wb3MgaW5cbiAgICBsZXQgYXZhaWxhYmxlID0gdC5tYXggLSBwb3MgaW5cbiAgICBpZiBhdmFpbGFibGUgPCBIZWFkZXIubGVuZ3RoXG4gICAgdGhlbiBIZWFkZXIubGVuZ3RoIC0gYXZhaWxhYmxlXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcGF5bG9hZF9sZW4gPSBIZWFkZXIudW5zYWZlX2dldF9wYXlsb2FkX2xlbmd0aCB0LmJ1ZiB+cG9zIGluXG4gICAgICBsZXQgdG90YWxfbGVuID0gcGF5bG9hZF9sZW4gKyBIZWFkZXIubGVuZ3RoIGluXG4gICAgICBpZiBhdmFpbGFibGUgPCB0b3RhbF9sZW5cbiAgICAgIHRoZW4gdG90YWxfbGVuIC0gYXZhaWxhYmxlXG4gICAgICBlbHNlXG4gICAgICAgICgqIFRoaXMgd2lsbCBuZXZlciBoYXBwZW4gYmVjYXVzZSB3ZSBvbmx5IGNhbGwgdGhpcyBmdW5jdGlvbiBmcm9tIFtyZWZpbGxdIHdoaWNoXG4gICAgICAgICAgIGlzIG9ubHkgY2FsbGVkIGZyb20gW3Byb2Nlc3NfaW5jb21pbmddLiBbcHJvY2Vzc19yZWNlaXZlZF9tZXNzYWdlc10sIHdoaWNoIGlzXG4gICAgICAgICAgIGFsd2F5cyBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgW3Byb2Nlc3NfaW5jb21pbmddLCBlaXRoZXIgY29uc3VtZXMgYWxsIHRoZVxuICAgICAgICAgICBtZXNzYWdlcyB0aGF0IGFyZSBpbiB0aGUgYnVmZmVyIG9yIGludGVycnVwdHMgdGhlIHJlYWRlci4gKilcbiAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgXCJCVUc6IFJwYy5Mb3dfbGF0ZW5jeV90cmFuc3BvcnQncyByZWFkZXIgaGFzIGJ1ZmZlcmVkIG1lc3NhZ2VzIHRoYXQgYXJlIFxcXG4gICAgICAgICAgICAgdW5wcm9jZXNzZWQuXCJdKVxuICA7O1xuXG4gICgqIFNoaWZ0IHJlbWFpbmluZyB1bmNvbnN1bWVkIGRhdGEgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYnVmZmVyICopXG4gIGxldCBzaGlmdF91bmNvbnN1bWVkIHQgPVxuICAgIGlmIHQucG9zID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IGxlbiA9IHQubWF4IC0gdC5wb3MgaW5cbiAgICAgIGlmIGxlbiA+IDAgdGhlbiBCaWdzdHJpbmcuYmxpdCB+c3JjOnQuYnVmIH5kc3Q6dC5idWYgfnNyY19wb3M6dC5wb3MgfmRzdF9wb3M6MCB+bGVuO1xuICAgICAgdC5wb3MgPC0gMDtcbiAgICAgIHQubWF4IDwtIGxlbilcbiAgOztcblxuICBsZXQgcmVmaWxsIHQgfmFsbG93X2J1ZmZlcmluZyA9XG4gICAgc2hpZnRfdW5jb25zdW1lZCB0O1xuICAgIGxldCBhdmFpbGFibGVfYnVmZmVyX2NhcGFjaXR5ID0gQmlnc3RyaW5nLmxlbmd0aCB0LmJ1ZiAtIHQubWF4IGluXG4gICAgbGV0IGxlbiA9XG4gICAgICBpZiBhbGxvd19idWZmZXJpbmdcbiAgICAgIHRoZW4gYXZhaWxhYmxlX2J1ZmZlcl9jYXBhY2l0eVxuICAgICAgZWxzZVxuICAgICAgICBJbnQubWluXG4gICAgICAgICAgKGdldF9taW5pbWFsX2xlbmd0aF90b19yZWFkX2Zvcl9zaW5nbGVfbWVzc2FnZSB0KVxuICAgICAgICAgIGF2YWlsYWJsZV9idWZmZXJfY2FwYWNpdHlcbiAgICBpblxuICAgIGxldCByZXN1bHQgPVxuICAgICAgQmlnc3RyaW5nX3VuaXgucmVhZF9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmdcbiAgICAgICAgKEZkLmZpbGVfZGVzY3JfZXhuIHQuZmQpXG4gICAgICAgIHQuYnVmXG4gICAgICAgIH5wb3M6dC5tYXhcbiAgICAgICAgfmxlblxuICAgIGluXG4gICAgaWYgVW5peC5TeXNjYWxsX3Jlc3VsdC5JbnQuaXNfb2sgcmVzdWx0XG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBVbml4LlN5c2NhbGxfcmVzdWx0LkludC5va19leG4gcmVzdWx0IHdpdGhcbiAgICAgIHwgMCAtPiBgRW9mXG4gICAgICB8IG4gLT5cbiAgICAgICAgYXNzZXJ0IChuID4gMCk7XG4gICAgICAgIHQubWF4IDwtIHQubWF4ICsgbjtcbiAgICAgICAgYFJlYWRfc29tZSlcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIFVuaXguU3lzY2FsbF9yZXN1bHQuSW50LmVycm9yX2V4biByZXN1bHQgd2l0aFxuICAgICAgfCBFQUdBSU4gfCBFV09VTERCTE9DSyB8IEVJTlRSIC0+IGBOb3RoaW5nX2F2YWlsYWJsZVxuICAgICAgfCBFUElQRSB8IEVDT05OUkVTRVQgfCBFSE9TVFVOUkVBQ0ggfCBFTkVURE9XTiB8IEVORVRSRVNFVCB8IEVORVRVTlJFQUNIIHwgRVRJTUVET1VUXG4gICAgICAgIC0+IGBFb2ZcbiAgICAgIHwgZXJyb3IgLT4gcmFpc2UgKFVuaXguVW5peF9lcnJvciAoZXJyb3IsIFwicmVhZFwiLCBcIlwiKSkpXG4gIDs7XG5cbiAgbW9kdWxlIERpc3BhdGNoZXIgOiBzaWdcbiAgICB2YWwgcnVuXG4gICAgICA6ICB0XG4gICAgICAtPiBhbGxvd19idWZmZXJpbmc6Ym9vbFxuICAgICAgLT4gb25fbWVzc2FnZTooQmlnc3RyaW5nLnQgLT4gcG9zOmludCAtPiBsZW46aW50IC0+ICdhIEhhbmRsZXJfcmVzdWx0LnQpXG4gICAgICAtPiBvbl9lbmRfb2ZfYmF0Y2g6KHVuaXQgLT4gdW5pdClcbiAgICAgIC0+IHJlYWRfb3JfcGVlazpbIGBQZWVrIHwgYFJlYWQgXVxuICAgICAgLT4gKCdhLCBbIGBDbG9zZWQgfCBgRW9mIF0pIHJlc3VsdCBEZWZlcnJlZC50XG5cbiAgICB2YWwgcGVla19vbmNlX3dpdGhvdXRfYnVmZmVyaW5nX2Zyb21fc29ja2V0XG4gICAgICA6ICB0XG4gICAgICAtPiBvbl9tZXNzYWdlOihCaWdzdHJpbmcudCAtPiBwb3M6aW50IC0+IGxlbjppbnQgLT4gJ2EgSGFuZGxlcl9yZXN1bHQudClcbiAgICAgIC0+IGxlbjppbnRcbiAgICAgIC0+ICgnYSwgWyBgQ2xvc2VkIHwgYE5vdF9lbm91Z2hfZGF0YSBdKSByZXN1bHQgRGVmZXJyZWQudFxuICBlbmQgPSBzdHJ1Y3RcbiAgICAoKiBUaGlzIG1vZHVsZSBkb2VzIGEgW0ZkLmV2ZXJ5X3JlYWR5X3RvXSBhbmQgdGFrZXMgY2FyZSBvZiBleGl0aW5nIGl0IHdoZW4gdGhlXG4gICAgICAgY2FsbGJhY2sgcmV0dXJucyBbV2FpdCBfXS4gKilcblxuICAgIHR5cGUgJ2Egc3RhdGUgPVxuICAgICAgfCBSdW5uaW5nXG4gICAgICB8IFN0b3BwZWQgb2YgJ2Egc3RvcF9yZWFzb25cblxuICAgIGFuZCAnYSBzdG9wX3JlYXNvbiA9XG4gICAgICB8IEhhbmRsZXJfcmFpc2VkXG4gICAgICB8IEVvZl9yZWFjaGVkXG4gICAgICAoKiBMYXN0IGhhbmRsZXIgY2FsbCB0aGF0IHdhc24ndCBkZXRlcm1pbmVkIGltbWVkaWF0ZWx5ICopXG4gICAgICB8IFdhaXRpbmdfZm9yX2hhbmRsZXIgb2YgdW5pdCBEZWZlcnJlZC50XG4gICAgICB8IFN0b3BwZWRfYnlfdXNlciBvZiAnYVxuXG4gICAgdHlwZSBub25yZWMgJ2EgdCA9XG4gICAgICB7IHJlYWRlciA6IHRcbiAgICAgIDsgb25fbWVzc2FnZSA6IEJpZ3N0cmluZy50IC0+IHBvczppbnQgLT4gbGVuOmludCAtPiAnYSBIYW5kbGVyX3Jlc3VsdC50XG4gICAgICA7IG9uX2VuZF9vZl9iYXRjaCA6IHVuaXQgLT4gdW5pdFxuICAgICAgOyBpbnRlcnJ1cHQgOiB1bml0IEl2YXIudCAoKiBUbyBzdG9wIHdhdGNoaW5nIHRoZSBmaWxlIGRlc2NyaXB0b3IgKilcbiAgICAgIDsgbXV0YWJsZSBzdGF0ZSA6ICdhIHN0YXRlXG4gICAgICB9XG5cbiAgICBsZXQgaXNfcnVubmluZyB0ID1cbiAgICAgIG1hdGNoIHQuc3RhdGUgd2l0aFxuICAgICAgfCBSdW5uaW5nIC0+IHRydWVcbiAgICAgIHwgU3RvcHBlZCBfIC0+IGZhbHNlXG4gICAgOztcblxuICAgIGxldCBpbnRlcnJ1cHQgdCByZWFzb24gPVxuICAgICAgYXNzZXJ0IChpc19ydW5uaW5nIHQpO1xuICAgICAgdC5zdGF0ZSA8LSBTdG9wcGVkIHJlYXNvbjtcbiAgICAgIEl2YXIuZmlsbF9leG4gdC5pbnRlcnJ1cHQgKClcbiAgICA7O1xuXG4gICAgbGV0IGNhbl9wcm9jZXNzX21lc3NhZ2UgdCA9IChub3QgdC5yZWFkZXIuY2xvc2VkKSAmJiBpc19ydW5uaW5nIHRcblxuICAgIGxldCByZWMgcHJvY2Vzc19yZWNlaXZlZF9tZXNzYWdlcyB0IH5yZWFkX29yX3BlZWsgPVxuICAgICAgaWYgY2FuX3Byb2Nlc3NfbWVzc2FnZSB0XG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGxlbiA9IGdldF9wYXlsb2FkX2xlbmd0aF9vZl9uZXh0X2F2YWlsYWJsZV9tZXNzYWdlIHQucmVhZGVyIGluXG4gICAgICAgIGlmIE1lc3NhZ2VfbGVuLmlzX3NvbWUgbGVuXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsZW4gPSBNZXNzYWdlX2xlbi52YWx1ZV9leG4gbGVuIGluXG4gICAgICAgICAgbGV0IHN0YXJ0ID0gdC5yZWFkZXIucG9zICsgSGVhZGVyLmxlbmd0aCBpblxuICAgICAgICAgIGxldCAoKSA9XG4gICAgICAgICAgICBtYXRjaCByZWFkX29yX3BlZWsgd2l0aFxuICAgICAgICAgICAgfCBgUmVhZCAtPlxuICAgICAgICAgICAgICB0LnJlYWRlci5ieXRlc19yZWFkIDwtIEludDYzLih0LnJlYWRlci5ieXRlc19yZWFkICsgb2ZfaW50IGxlbik7XG4gICAgICAgICAgICAgIHQucmVhZGVyLnBvcyA8LSBzdGFydCArIGxlblxuICAgICAgICAgICAgfCBgUGVlayAtPiAoKVxuICAgICAgICAgIGluXG4gICAgICAgICAgbWF0Y2ggdC5vbl9tZXNzYWdlIHQucmVhZGVyLmJ1ZiB+cG9zOnN0YXJ0IH5sZW4gd2l0aFxuICAgICAgICAgIHwgU3RvcCB4IC0+IGludGVycnVwdCB0IChTdG9wcGVkX2J5X3VzZXIgeClcbiAgICAgICAgICB8IENvbnRpbnVlIC0+IHByb2Nlc3NfcmVjZWl2ZWRfbWVzc2FnZXMgdCB+cmVhZF9vcl9wZWVrXG4gICAgICAgICAgfCBXYWl0IGQgLT5cbiAgICAgICAgICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgZFxuICAgICAgICAgICAgdGhlbiBwcm9jZXNzX3JlY2VpdmVkX21lc3NhZ2VzIHQgfnJlYWRfb3JfcGVla1xuICAgICAgICAgICAgZWxzZSBpbnRlcnJ1cHQgdCAoV2FpdGluZ19mb3JfaGFuZGxlciBkKSlcbiAgICAgICAgZWxzZSB0Lm9uX2VuZF9vZl9iYXRjaCAoKSlcbiAgICA7O1xuXG4gICAgbGV0IHByb2Nlc3NfaW5jb21pbmcgdCB+YWxsb3dfYnVmZmVyaW5nIH5yZWFkX29yX3BlZWsgPVxuICAgICAgaWYgY2FuX3Byb2Nlc3NfbWVzc2FnZSB0XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggcmVmaWxsIHQucmVhZGVyIH5hbGxvd19idWZmZXJpbmcgd2l0aFxuICAgICAgICB8IGBFb2YgLT4gaW50ZXJydXB0IHQgRW9mX3JlYWNoZWRcbiAgICAgICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT4gKClcbiAgICAgICAgfCBgUmVhZF9zb21lIC0+IHByb2Nlc3NfcmVjZWl2ZWRfbWVzc2FnZXMgdCB+cmVhZF9vcl9wZWVrKVxuICAgIDs7XG5cbiAgICAoKiBXZSB3YW50IHRvIHN0b3AgcmVhZGluZy9kaXNwYXRjaGluZyBhcyBzb29uIGFzIHdlIGdldCBhbiBlcnJvciAqKVxuICAgIGxldCBzdG9wX3dhdGNoaW5nX29uX2Vycm9yIHQgfm1vbml0b3IgPVxuICAgICAgbGV0IHBhcmVudCA9IE1vbml0b3IuY3VycmVudCAoKSBpblxuICAgICAgTW9uaXRvci5kZXRhY2hfYW5kX2l0ZXJfZXJyb3JzIG1vbml0b3IgfmY6KGZ1biBleG4gLT5cbiAgICAgICAgaWYgaXNfcnVubmluZyB0IHRoZW4gaW50ZXJydXB0IHQgSGFuZGxlcl9yYWlzZWQ7XG4gICAgICAgICgqIExldCB0aGUgbW9uaXRvciBpbiBlZmZlY3Qgd2hlbiBbZGlzcGF0Y2hdIHdhcyBjYWxsZWQgZGVhbCB3aXRoIHRoZSBlcnJvci4gKilcbiAgICAgICAgTW9uaXRvci5zZW5kX2V4biBwYXJlbnQgZXhuKVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIHJ1biByZWFkZXIgfmFsbG93X2J1ZmZlcmluZyB+b25fbWVzc2FnZSB+b25fZW5kX29mX2JhdGNoIH5yZWFkX29yX3BlZWsgPVxuICAgICAgbGV0IHQgPVxuICAgICAgICB7IHJlYWRlclxuICAgICAgICA7IGludGVycnVwdCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICAgIDsgc3RhdGUgPSBSdW5uaW5nXG4gICAgICAgIDsgb25fbWVzc2FnZVxuICAgICAgICA7IG9uX2VuZF9vZl9iYXRjaFxuICAgICAgICB9XG4gICAgICBpblxuICAgICAgbGV0IG1vbml0b3IgPVxuICAgICAgICBNb25pdG9yLmNyZWF0ZVxuICAgICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgICB+bmFtZTpcIlJwY190cmFuc3BvcnRfbG93X2xhdGVuY3kuUmVhZGVyX2ludGVybmFsLkRpc3BhdGNoZXIucnVuXCJcbiAgICAgICAgICAoKVxuICAgICAgaW5cbiAgICAgIHN0b3Bfd2F0Y2hpbmdfb25fZXJyb3IgdCB+bW9uaXRvcjtcbiAgICAgIG1hdGNoJWJpbmRcbiAgICAgICAgU2NoZWR1bGVyLndpdGhpbicgfm1vbml0b3IgKGZ1biAoKSAtPlxuICAgICAgICAgICgqIFByb2Nlc3MgbWVzc2FnZXMgY3VycmVudGx5IGluIHRoZSBidWZmZXIuICopXG4gICAgICAgICAgKCogVGhpcyB3aWxsIGZpbGwgW3QuaW50ZXJydXB0XSBpZiBbb25fbWVzc2FnZV0gcmV0dXJucyBbV2FpdCBfXS4gSG93ZXZlciwgd2VcbiAgICAgICAgICAgICBleHBlY3QgW29uX21lc3NhZ2VdIHRvIGFsbW9zdCBuZXZlciByZXR1cm4gW1dhaXQgX10gd2l0aCB0aGlzIHRyYW5zcG9ydCwgc2luY2VcbiAgICAgICAgICAgICBldmVuIHRoZSBcIm5vbi1jb3B5aW5nXCIgd3JpdGVzIHJldHVybiBbRGVmZXJyZWQudW5pdF0uICopXG4gICAgICAgICAgcHJvY2Vzc19yZWNlaXZlZF9tZXNzYWdlcyB0IH5yZWFkX29yX3BlZWs7XG4gICAgICAgICAgbGV0IGludGVycnVwdCA9XG4gICAgICAgICAgICBEZWZlcnJlZC5hbnkgWyBJdmFyLnJlYWQgdC5pbnRlcnJ1cHQ7IGNsb3NlX2ZpbmlzaGVkIHQucmVhZGVyIF1cbiAgICAgICAgICBpblxuICAgICAgICAgIEZkLmludGVycnVwdGlibGVfZXZlcnlfcmVhZHlfdG9cbiAgICAgICAgICAgIH5pbnRlcnJ1cHRcbiAgICAgICAgICAgIHQucmVhZGVyLmZkXG4gICAgICAgICAgICBgUmVhZFxuICAgICAgICAgICAgKHByb2Nlc3NfaW5jb21pbmcgfmFsbG93X2J1ZmZlcmluZyB+cmVhZF9vcl9wZWVrKVxuICAgICAgICAgICAgdClcbiAgICAgIHdpdGhcbiAgICAgIHwgYEJhZF9mZCB8IGBVbnN1cHBvcnRlZCAtPlxuICAgICAgICBmYWlsd2l0aFxuICAgICAgICAgIFwiUnBjX3RyYW5zcG9ydF9sb3dfbGF0ZW5jeS5SZWFkZXIucmVhZF9mb3JldmVyOiBmaWxlIGRlc2NyaXB0b3IgZG9lc24ndCBcXFxuICAgICAgICAgICBzdXBwb3J0IHdhdGNoaW5nXCJcbiAgICAgIHwgYENsb3NlZCB8IGBJbnRlcnJ1cHRlZCAtPlxuICAgICAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICB8IFJ1bm5pbmcgLT5cbiAgICAgICAgICAgYXNzZXJ0IChGZC5pc19jbG9zZWQgdC5yZWFkZXIuZmQgfHwgdC5yZWFkZXIuY2xvc2VkKTtcbiAgICAgICAgICAgcmV0dXJuIChFcnJvciBgQ2xvc2VkKVxuICAgICAgICAgfCBTdG9wcGVkIChTdG9wcGVkX2J5X3VzZXIgeCkgLT4gcmV0dXJuIChPayB4KVxuICAgICAgICAgfCBTdG9wcGVkIEhhbmRsZXJfcmFpc2VkIC0+XG4gICAgICAgICAgICgqIFRoZSBleGNlcHRpb24gaGFzIGJlZW4gcHJvcGFnYXRlZCwgd2Ugb25seSBhcnJpdmUgaGVyZSBiZWNhdXNlIHdlIGZvcmNlZCB0aGVcbiAgICAgICAgICAgICAgW2ludGVycnVwdGlibGVfZXZlcnlfcmVhZHlfdG9dIHRvIGJlIGludGVycnVwdGVkLiAqKVxuICAgICAgICAgICBEZWZlcnJlZC5uZXZlciAoKVxuICAgICAgICAgfCBTdG9wcGVkIEVvZl9yZWFjaGVkIC0+IHJldHVybiAoRXJyb3IgYEVvZilcbiAgICAgICAgIHwgU3RvcHBlZCAoV2FpdGluZ19mb3JfaGFuZGxlciBkKSAtPlxuICAgICAgICAgICBsZXQlYmluZCAoKSA9IGQgaW5cbiAgICAgICAgICAgaWYgcmVhZGVyLmNsb3NlZFxuICAgICAgICAgICB0aGVuIHJldHVybiAoRXJyb3IgYENsb3NlZClcbiAgICAgICAgICAgZWxzZSBydW4gcmVhZGVyIH5hbGxvd19idWZmZXJpbmcgfm9uX21lc3NhZ2Ugfm9uX2VuZF9vZl9iYXRjaCB+cmVhZF9vcl9wZWVrKVxuICAgIDs7XG5cbiAgICBsZXQgcGVla19vbmNlX3dpdGhvdXRfYnVmZmVyaW5nX2Zyb21fc29ja2V0IHJlYWRlciB+b25fbWVzc2FnZSB+bGVuID1cbiAgICAgIGxldCB0ID1cbiAgICAgICAgeyByZWFkZXJcbiAgICAgICAgOyBpbnRlcnJ1cHQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IHN0YXRlID0gUnVubmluZ1xuICAgICAgICA7IG9uX21lc3NhZ2VcbiAgICAgICAgOyBvbl9lbmRfb2ZfYmF0Y2ggPSBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgaW5cbiAgICAgIGxldCBtb25pdG9yID1cbiAgICAgICAgTW9uaXRvci5jcmVhdGVcbiAgICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgICAgfm5hbWU6XG4gICAgICAgICAgICBcIlJwY190cmFuc3BvcnRfbG93X2xhdGVuY3kuUmVhZGVyX2ludGVybmFsLkRpc3BhdGNoZXIucGVla19vbmNlX3dpdGhvdXRfYnVmZmVyaW5nX2Zyb21fc29ja2V0XCJcbiAgICAgICAgICAoKVxuICAgICAgaW5cbiAgICAgIGxldCBidWYgPSBCaWdzdHJpbmcuY3JlYXRlIGxlbiBpblxuICAgICAgc3RvcF93YXRjaGluZ19vbl9lcnJvciB0IH5tb25pdG9yO1xuICAgICAgbWF0Y2glYmluZFxuICAgICAgICBTY2hlZHVsZXIud2l0aGluJyB+bW9uaXRvciAoZnVuICgpIC0+XG4gICAgICAgICAgRmQuaW50ZXJydXB0aWJsZV9ldmVyeV9yZWFkeV90b1xuICAgICAgICAgICAgfmludGVycnVwdDooRGVmZXJyZWQuYW55IFsgSXZhci5yZWFkIHQuaW50ZXJydXB0OyBjbG9zZV9maW5pc2hlZCB0LnJlYWRlciBdKVxuICAgICAgICAgICAgdC5yZWFkZXIuZmRcbiAgICAgICAgICAgIGBSZWFkXG4gICAgICAgICAgICAoZnVuIHQgLT5cbiAgICAgICAgICAgICAgaWYgY2FuX3Byb2Nlc3NfbWVzc2FnZSB0XG4gICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgIGxldCBwZWVrX2xlbiA9XG4gICAgICAgICAgICAgICAgICAoKiBbRmQuc3lzY2FsbF9leG5dIGNhdGNoZXMgRUlOVFIgYW5kIHJldHJpZXMgdGhlIGZ1bmN0aW9uLiBUaGlzIGlzIGJldHRlclxuICAgICAgICAgICAgICAgICAgICAgIHRoYW4gY2FsbGluZyBbcmVjdl9wZWVrX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZ10gZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgKilcbiAgICAgICAgICAgICAgICAgIEZkLnN5c2NhbGxfZXhuIHQucmVhZGVyLmZkIChmdW4gZmlsZV9kZXNjciAtPlxuICAgICAgICAgICAgICAgICAgICBCaWdzdHJpbmdfdW5peC5yZWN2X3BlZWtfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXG4gICAgICAgICAgICAgICAgICAgICAgZmlsZV9kZXNjclxuICAgICAgICAgICAgICAgICAgICAgIH5wb3M6MFxuICAgICAgICAgICAgICAgICAgICAgIH5sZW5cbiAgICAgICAgICAgICAgICAgICAgICBidWYpXG4gICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBpZiBwZWVrX2xlbiA+PSBsZW5cbiAgICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgIHQucmVhZGVyLmJ5dGVzX3JlYWQgPC0gSW50NjMuKHQucmVhZGVyLmJ5dGVzX3JlYWQgKyBvZl9pbnQgbGVuKTtcbiAgICAgICAgICAgICAgICAgIG1hdGNoIG9uX21lc3NhZ2UgYnVmIH5wb3M6MCB+bGVuIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgU3RvcCB4IC0+IGludGVycnVwdCB0IChTdG9wcGVkX2J5X3VzZXIgeClcbiAgICAgICAgICAgICAgICAgIHwgQ29udGludWUgfCBXYWl0IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgZmFpbHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICBcIlJwY190cmFuc3BvcnRfbG93X2xhdGVuY3kuUmVhZGVyX2ludGVybmFsLkRpc3BhdGNoZXIucGVla19vbmNlX3dpdGhvdXRfYnVmZmVyaW5nX2Zyb21fc29ja2V0OiBcXFxuICAgICAgICAgICAgICAgICAgICAgICBvbl9tZXNzYWdlIHJldHVybmVkIHVuZXhwZWN0ZWQgdmFsdWVcIilcbiAgICAgICAgICAgICAgICBlbHNlIGludGVycnVwdCB0IEVvZl9yZWFjaGVkKSlcbiAgICAgICAgICAgIHQpXG4gICAgICB3aXRoXG4gICAgICB8IGBCYWRfZmQgfCBgVW5zdXBwb3J0ZWQgLT5cbiAgICAgICAgZmFpbHdpdGhcbiAgICAgICAgICBcIlJwY190cmFuc3BvcnRfbG93X2xhdGVuY3kuUmVhZGVyX2ludGVybmFsLkRpc3BhdGNoZXIucGVla19vbmNlX3dpdGhvdXRfYnVmZmVyaW5nX2Zyb21fc29ja2V0IFxcXG4gICAgICAgICAgIGZpbGUgZGVzY3JpcHRvciBkb2Vzbid0IHN1cHBvcnQgd2F0Y2hpbmdcIlxuICAgICAgfCBgQ2xvc2VkIHwgYEludGVycnVwdGVkIC0+XG4gICAgICAgIChtYXRjaCB0LnN0YXRlIHdpdGhcbiAgICAgICAgIHwgUnVubmluZyAtPlxuICAgICAgICAgICBhc3NlcnQgKEZkLmlzX2Nsb3NlZCB0LnJlYWRlci5mZCB8fCB0LnJlYWRlci5jbG9zZWQpO1xuICAgICAgICAgICByZXR1cm4gKEVycm9yIGBDbG9zZWQpXG4gICAgICAgICB8IFN0b3BwZWQgKFN0b3BwZWRfYnlfdXNlciB4KSAtPiByZXR1cm4gKE9rIHgpXG4gICAgICAgICB8IFN0b3BwZWQgRW9mX3JlYWNoZWQgLT4gcmV0dXJuIChFcnJvciBgTm90X2Vub3VnaF9kYXRhKVxuICAgICAgICAgfCBTdG9wcGVkIEhhbmRsZXJfcmFpc2VkIC0+XG4gICAgICAgICAgICgqIFRoZSBleGNlcHRpb24gaGFzIGJlZW4gcHJvcGFnYXRlZCwgd2Ugb25seSBhcnJpdmUgaGVyZSBiZWNhdXNlIHdlIGZvcmNlZCB0aGVcbiAgICAgICAgICAgICAgW2ludGVycnVwdGlibGVfZXZlcnlfcmVhZHlfdG9dIHRvIGJlIGludGVycnVwdGVkLiAqKVxuICAgICAgICAgICBEZWZlcnJlZC5uZXZlciAoKVxuICAgICAgICAgfCBTdG9wcGVkIChXYWl0aW5nX2Zvcl9oYW5kbGVyIF8pIC0+XG4gICAgICAgICAgIGZhaWx3aXRoXG4gICAgICAgICAgICAgXCJScGNfdHJhbnNwb3J0X2xvd19sYXRlbmN5LlJlYWRlcl9pbnRlcm5hbC5EaXNwYXRjaGVyLnBlZWtfb25jZV93aXRob3V0X2J1ZmZlcmluZ19mcm9tX3NvY2tldDogXFxcbiAgICAgICAgICAgICAgdW5leHBlY3RlZCBzdGF0ZSBXYWl0aW5nX2Zvcl9oYW5kbGVyXCIpXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHJlYWRfb3JfcGVla19kaXNwYXRjaGVyIHQgfmRpc3BhdGNoZXJfaW1wbCB+Y2FsbGVyX25hbWUgPVxuICAgIGlmIHQuY2xvc2VkXG4gICAgdGhlblxuICAgICAgZmFpbHdpdGhzXG4gICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgXCJScGNfdHJhbnNwb3J0X2xvd19sYXRlbmN5LlJlYWRlcjogcmVhZGVyIGNsb3NlZFwiXG4gICAgICAgIFwiXCJcbiAgICAgICAgWyVzZXhwX29mOiBzdHJpbmddO1xuICAgIGlmIHQucmVhZGluZ1xuICAgIHRoZW5cbiAgICAgIGZhaWx3aXRoc1xuICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgIFwiUnBjX3RyYW5zcG9ydF9sb3dfbGF0ZW5jeS5SZWFkZXI6IGFscmVhZHkgcmVhZGluZ1wiXG4gICAgICAgIFwiXCJcbiAgICAgICAgWyVzZXhwX29mOiBzdHJpbmddO1xuICAgIHQucmVhZGluZyA8LSB0cnVlO1xuICAgIE1vbml0b3IucHJvdGVjdFxuICAgICAgfnJ1bjpgTm93XG4gICAgICB+cmVzdDpgUmFpc2VcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIH5uYW1lOmNhbGxlcl9uYW1lXG4gICAgICB+ZmluYWxseTooZnVuICgpIC0+XG4gICAgICAgIHQucmVhZGluZyA8LSBmYWxzZTtcbiAgICAgICAgRGVmZXJyZWQudW5pdClcbiAgICAgIChmdW4gKCkgLT4gZGlzcGF0Y2hlcl9pbXBsICgpKVxuICA7O1xuXG4gIGxldCByZWFkX2ZvcmV2ZXInIHQgfmFsbG93X2J1ZmZlcmluZyB+b25fbWVzc2FnZSB+b25fZW5kX29mX2JhdGNoID1cbiAgICByZWFkX29yX3BlZWtfZGlzcGF0Y2hlclxuICAgICAgdFxuICAgICAgfmRpc3BhdGNoZXJfaW1wbDooZnVuICgpIC0+XG4gICAgICAgIERpc3BhdGNoZXIucnVuIHQgfmFsbG93X2J1ZmZlcmluZyB+b25fbWVzc2FnZSB+b25fZW5kX29mX2JhdGNoIH5yZWFkX29yX3BlZWs6YFJlYWQpXG4gICAgICB+Y2FsbGVyX25hbWU6XCJScGNfdHJhbnNwb3J0X2xvd19sYXRlbmN5LlJlYWRlcl9pbnRlcm5hbC5yZWFkX2ZvcmV2ZXJcIlxuICA7O1xuXG4gIGxldCByZWFkX2ZvcmV2ZXIgPSByZWFkX2ZvcmV2ZXInIH5hbGxvd19idWZmZXJpbmc6dHJ1ZVxuXG4gIGxldCByZWFkX29uZV9tZXNzYWdlX2Jpbl9wcm90X3dpdGhvdXRfYnVmZmVyaW5nXG4gICAgdFxuICAgIChiaW5fcmVhZGVyIDogXyBCaW5fcHJvdC5UeXBlX2NsYXNzLnJlYWRlcilcbiAgICA9XG4gICAgcmVhZF9mb3JldmVyJ1xuICAgICAgdFxuICAgICAgfmFsbG93X2J1ZmZlcmluZzpmYWxzZVxuICAgICAgfm9uX21lc3NhZ2U6KGZ1biBidWYgfnBvcyB+bGVuIC0+XG4gICAgICAgIGxldCBwb3NfcmVmID0gcmVmIHBvcyBpblxuICAgICAgICBsZXQgeCA9IGJpbl9yZWFkZXIucmVhZCBidWYgfnBvc19yZWYgaW5cbiAgICAgICAgaWYgIXBvc19yZWYgPD4gcG9zICsgbGVuXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBmYWlsd2l0aGZcbiAgICAgICAgICAgIFwibWVzc2FnZSBsZW5ndGggKCVkKSBkaWQgbm90IG1hdGNoIGV4cGVjdGVkIGxlbmd0aCAoJWQpXCJcbiAgICAgICAgICAgICghcG9zX3JlZiAtIHBvcylcbiAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgKClcbiAgICAgICAgZWxzZSBTdG9wIHgpXG4gICAgICB+b25fZW5kX29mX2JhdGNoOmlnbm9yZVxuICA7O1xuXG4gIGxldCBwZWVrX2Jpbl9wcm90IHQgKGJpbl9yZWFkZXIgOiBfIEJpbl9wcm90LlR5cGVfY2xhc3MucmVhZGVyKSA9XG4gICAgbGV0IG9uX21lc3NhZ2UgYnVmIH5wb3MgfmxlbiA9XG4gICAgICBsZXQgcG9zX3JlZiA9IHJlZiBwb3MgaW5cbiAgICAgIGxldCB4ID0gYmluX3JlYWRlci5yZWFkIGJ1ZiB+cG9zX3JlZiBpblxuICAgICAgaWYgIXBvc19yZWYgPD4gcG9zICsgbGVuXG4gICAgICB0aGVuXG4gICAgICAgIGZhaWx3aXRoZlxuICAgICAgICAgIFwicGVla19iaW5fcHJvdDogbWVzc2FnZSBsZW5ndGggKCVkKSBkaWQgbm90IG1hdGNoIGV4cGVjdGVkIGxlbmd0aCAoJWQpXCJcbiAgICAgICAgICAoIXBvc19yZWYgLSBwb3MpXG4gICAgICAgICAgbGVuXG4gICAgICAgICAgKClcbiAgICAgIGVsc2UgSGFuZGxlcl9yZXN1bHQuU3RvcCB4XG4gICAgaW5cbiAgICByZWFkX29yX3BlZWtfZGlzcGF0Y2hlclxuICAgICAgdFxuICAgICAgfmRpc3BhdGNoZXJfaW1wbDooZnVuICgpIC0+XG4gICAgICAgIERpc3BhdGNoZXIucnVuXG4gICAgICAgICAgdFxuICAgICAgICAgIH5hbGxvd19idWZmZXJpbmc6dHJ1ZVxuICAgICAgICAgIH5vbl9tZXNzYWdlXG4gICAgICAgICAgfm9uX2VuZF9vZl9iYXRjaDppZ25vcmVcbiAgICAgICAgICB+cmVhZF9vcl9wZWVrOmBQZWVrKVxuICAgICAgfmNhbGxlcl9uYW1lOlwiUnBjX3RyYW5zcG9ydF9sb3dfbGF0ZW5jeS5SZWFkZXJfaW50ZXJuYWwucGVla19iaW5fcHJvdFwiXG4gIDs7XG5cbiAgbGV0IHBlZWtfb25jZV93aXRob3V0X2J1ZmZlcmluZ19mcm9tX3NvY2tldCB0IH5sZW4gPVxuICAgIGxldCBvbl9tZXNzYWdlIGJ1ZiB+cG9zOl8gfmxlbjpfID0gSGFuZGxlcl9yZXN1bHQuU3RvcCBidWYgaW5cbiAgICByZWFkX29yX3BlZWtfZGlzcGF0Y2hlclxuICAgICAgdFxuICAgICAgfmRpc3BhdGNoZXJfaW1wbDooZnVuICgpIC0+XG4gICAgICAgIERpc3BhdGNoZXIucGVla19vbmNlX3dpdGhvdXRfYnVmZmVyaW5nX2Zyb21fc29ja2V0IHQgfm9uX21lc3NhZ2UgfmxlbilcbiAgICAgIH5jYWxsZXJfbmFtZTpcbiAgICAgICAgXCJScGNfdHJhbnNwb3J0X2xvd19sYXRlbmN5LlJlYWRlcl9pbnRlcm5hbC5wZWVrX29uY2Vfd2l0aG91dF9idWZmZXJpbmdfZnJvbV9zb2NrZXRcIlxuICA7O1xuXG4gIGxldCBjbG9zZSB0ID1cbiAgICBpZiBub3QgdC5jbG9zZWRcbiAgICB0aGVuIChcbiAgICAgIHQuY2xvc2VkIDwtIHRydWU7XG4gICAgICBGZC5jbG9zZSB0LmZkID4+PiBmdW4gKCkgLT4gSXZhci5maWxsX2V4biB0LmNsb3NlX2ZpbmlzaGVkICgpKTtcbiAgICBjbG9zZV9maW5pc2hlZCB0XG4gIDs7XG5lbmRcblxubW9kdWxlIFdyaXRlcl9pbnRlcm5hbCA9IHN0cnVjdFxuICB0eXBlIGZsdXNoID1cbiAgICB7IHBvcyA6IEludDYzLnRcbiAgICA7IGl2YXIgOiB1bml0IEl2YXIudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgZ2V0X2pvYl9udW1iZXIgKCkgPSBTY2hlZHVsZXIubnVtX2pvYnNfcnVuICgpXG5cbiAgbW9kdWxlIENvbm5lY3Rpb25fc3RhdGUgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHZhbCBjcmVhdGUgOiB1bml0IC0+IHRcbiAgICB2YWwgaXNfY3VycmVudGx5X2FjY2VwdGluZ193cml0ZXMgOiB0IC0+IGJvb2xcbiAgICB2YWwgaXNfYWJsZV90b19zZW5kX2RhdGEgOiB0IC0+IGJvb2xcbiAgICB2YWwgc3RhcnRfY2xvc2UgOiB0IC0+IHVuaXRcbiAgICB2YWwgZmluaXNoX2Nsb3NlIDogdCAtPiBmZF9jbG9zZWQ6dW5pdCBEZWZlcnJlZC50IC0+IHVuaXRcbiAgICB2YWwgY29ubmVjdGlvbl9sb3N0IDogdCAtPiB1bml0XG4gICAgdmFsIGNsb3NlX2ZpbmlzaGVkIDogdCAtPiB1bml0IERlZmVycmVkLnRcbiAgICB2YWwgc3RvcHBlZCA6IHQgLT4gdW5pdCBEZWZlcnJlZC50XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB7IGNsb3NlX3N0YXJ0ZWQgOiB1bml0IEl2YXIudFxuICAgICAgOyBjbG9zZV9maW5pc2hlZCA6IHVuaXQgSXZhci50XG4gICAgICA7IGNvbm5lY3Rpb25fbG9zdCA6IHVuaXQgSXZhci50XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCBzdGFydF9jbG9zZSB0ID0gSXZhci5maWxsX2lmX2VtcHR5IHQuY2xvc2Vfc3RhcnRlZCAoKVxuXG4gICAgbGV0IGZpbmlzaF9jbG9zZSB0IH5mZF9jbG9zZWQgPVxuICAgICAgc3RhcnRfY2xvc2UgdDtcbiAgICAgIEl2YXIuZmlsbF9pZl9lbXB0eSB0LmNvbm5lY3Rpb25fbG9zdCAoKTtcbiAgICAgIHVwb24gZmRfY2xvc2VkIChJdmFyLmZpbGxfaWZfZW1wdHkgdC5jbG9zZV9maW5pc2hlZClcbiAgICA7O1xuXG4gICAgbGV0IGNsb3NlX2ZpbmlzaGVkIHQgPSBJdmFyLnJlYWQgdC5jbG9zZV9maW5pc2hlZFxuICAgIGxldCBpc19jdXJyZW50bHlfYWNjZXB0aW5nX3dyaXRlcyB0ID0gSXZhci5pc19lbXB0eSB0LmNsb3NlX3N0YXJ0ZWRcbiAgICBsZXQgaXNfYWJsZV90b19zZW5kX2RhdGEgdCA9IEl2YXIuaXNfZW1wdHkgdC5jb25uZWN0aW9uX2xvc3RcbiAgICBsZXQgY29ubmVjdGlvbl9sb3N0IHQgPSBJdmFyLmZpbGxfaWZfZW1wdHkgdC5jb25uZWN0aW9uX2xvc3QgKClcblxuICAgIGxldCBzdG9wcGVkIHQgPVxuICAgICAgRGVmZXJyZWQuYW55IFsgSXZhci5yZWFkIHQuY29ubmVjdGlvbl9sb3N0OyBJdmFyLnJlYWQgdC5jbG9zZV9zdGFydGVkIF1cbiAgICA7O1xuXG4gICAgbGV0IGNyZWF0ZSAoKSA9XG4gICAgICB7IGNsb3NlX3N0YXJ0ZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgOyBjbG9zZV9maW5pc2hlZCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICA7IGNvbm5lY3Rpb25fbG9zdCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICB9XG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB7IGZkIDogRmQudFxuICAgIDsgY29uZmlnIDogQ29uZmlnLnRcbiAgICA7IGNvbm5lY3Rpb25fc3RhdGUgOiBDb25uZWN0aW9uX3N0YXRlLnRcbiAgICA7IG11dGFibGUgd3JpdGluZyA6IGJvb2xcbiAgICA7IG11dGFibGUgYnVmIDogKEJpZ3N0cmluZy50W0BzZXhwLm9wYXF1ZV0pXG4gICAgOyBtdXRhYmxlIHBvcyA6IGludFxuICAgIDsgbXV0YWJsZSBieXRlc193cml0dGVuIDogSW50NjMudFxuICAgIDsgbW9uaXRvciA6IE1vbml0b3IudFxuICAgIDsgZmx1c2hlcyA6IGZsdXNoIFF1ZXVlLnQgKCogdGhlIGpvYiBudW1iZXIgb2YgdGhlIGpvYiB3aGVuIHdlIGxhc3Qgc2VudCBkYXRhICopXG4gICAgOyBtdXRhYmxlIGxhc3Rfc2VuZF9qb2IgOiBpbnRcbiAgICA7IG11dGFibGUgc2VuZHNfaW5fdGhpc19qb2IgOiBpbnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIHNleHBfb2YsIGZpZWxkcyB+Z2V0dGVyc11cblxuICBsZXQgY3JlYXRlIGZkIGNvbmZpZyA9XG4gICAgc2V0X25vbmJsb2NraW5nIGZkO1xuICAgIHsgZmRcbiAgICA7IGNvbmZpZ1xuICAgIDsgd3JpdGluZyA9IGZhbHNlXG4gICAgOyBjb25uZWN0aW9uX3N0YXRlID0gQ29ubmVjdGlvbl9zdGF0ZS5jcmVhdGUgKClcbiAgICA7IGJ1ZiA9IEJpZ3N0cmluZy5jcmVhdGUgY29uZmlnLmluaXRpYWxfYnVmZmVyX3NpemVcbiAgICA7IHBvcyA9IDBcbiAgICA7IGJ5dGVzX3dyaXR0ZW4gPSBJbnQ2My56ZXJvXG4gICAgOyBtb25pdG9yID0gTW9uaXRvci5jcmVhdGUgKClcbiAgICA7IGZsdXNoZXMgPSBRdWV1ZS5jcmVhdGUgKClcbiAgICA7IGxhc3Rfc2VuZF9qb2IgPSAwXG4gICAgOyBzZW5kc19pbl90aGlzX2pvYiA9IDBcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGlzX2Nsb3NlZCB0ID1cbiAgICBub3QgKENvbm5lY3Rpb25fc3RhdGUuaXNfY3VycmVudGx5X2FjY2VwdGluZ193cml0ZXMgdC5jb25uZWN0aW9uX3N0YXRlKVxuICA7O1xuXG4gIGxldCBjbG9zZV9maW5pc2hlZCB0ID0gQ29ubmVjdGlvbl9zdGF0ZS5jbG9zZV9maW5pc2hlZCB0LmNvbm5lY3Rpb25fc3RhdGVcbiAgbGV0IGJ5dGVzX3RvX3dyaXRlIHQgPSB0LnBvc1xuICBsZXQgc3RvcHBlZCB0ID0gQ29ubmVjdGlvbl9zdGF0ZS5zdG9wcGVkIHQuY29ubmVjdGlvbl9zdGF0ZVxuXG4gIGxldCBmbHVzaGVkIHQgPVxuICAgIGlmIHQucG9zID0gMFxuICAgIHRoZW4gRGVmZXJyZWQudW5pdFxuICAgIGVsc2UgaWYgbm90IChDb25uZWN0aW9uX3N0YXRlLmlzX2FibGVfdG9fc2VuZF9kYXRhIHQuY29ubmVjdGlvbl9zdGF0ZSlcbiAgICB0aGVuIERlZmVycmVkLm5ldmVyICgpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgZmx1c2ggPVxuICAgICAgICB7IHBvcyA9IEludDYzLiggKyApIHQuYnl0ZXNfd3JpdHRlbiAoSW50NjMub2ZfaW50IHQucG9zKTsgaXZhciA9IEl2YXIuY3JlYXRlICgpIH1cbiAgICAgIGluXG4gICAgICBRdWV1ZS5lbnF1ZXVlIHQuZmx1c2hlcyBmbHVzaDtcbiAgICAgIEl2YXIucmVhZCBmbHVzaC5pdmFyKVxuICA7O1xuXG4gIGxldCByZWFkeV90b193cml0ZSA9IGZsdXNoZWRcblxuICBsZXQgZGVxdWV1ZV9mbHVzaGVzIHQgPVxuICAgIHdoaWxlXG4gICAgICAobm90IChRdWV1ZS5pc19lbXB0eSB0LmZsdXNoZXMpKVxuICAgICAgJiYgSW50NjMuKCA8PSApIChRdWV1ZS5wZWVrX2V4biB0LmZsdXNoZXMpLnBvcyB0LmJ5dGVzX3dyaXR0ZW5cbiAgICBkb1xuICAgICAgSXZhci5maWxsX2V4biAoUXVldWUuZGVxdWV1ZV9leG4gdC5mbHVzaGVzKS5pdmFyICgpXG4gICAgZG9uZVxuICA7O1xuXG4gICgqIERpc2NhcmQgdGhlIFtuXSBmaXJzdCBieXRlcyBvZiBbdC5idWZdICopXG4gIGxldCBkaXNjYXJkIHQgbiA9XG4gICAgYXNzZXJ0IChuID49IDAgJiYgbiA8PSB0LnBvcyk7XG4gICAgbGV0IHJlbWFpbmluZyA9IHQucG9zIC0gbiBpblxuICAgIGlmIHJlbWFpbmluZyA+IDBcbiAgICB0aGVuIEJpZ3N0cmluZy5ibGl0IH5zcmM6dC5idWYgfmRzdDp0LmJ1ZiB+c3JjX3BvczpuIH5kc3RfcG9zOjAgfmxlbjpyZW1haW5pbmc7XG4gICAgdC5wb3MgPC0gcmVtYWluaW5nO1xuICAgIHQuYnl0ZXNfd3JpdHRlbiA8LSBJbnQ2My4oICsgKSB0LmJ5dGVzX3dyaXR0ZW4gKEludDYzLm9mX2ludCBuKTtcbiAgICBkZXF1ZXVlX2ZsdXNoZXMgdFxuICA7O1xuXG4gIG1vZHVsZSBFcnJvcl9raW5kID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgV3JpdGVfYmxvY2tlZFxuICAgICAgfCBDb25uZWN0aW9uX2xvc3RcbiAgICAgIHwgT3RoZXJfZXJyb3JcbiAgZW5kXG5cbiAgbGV0IGhhbmRsZV9lcnJvciB0IChlcnJvciA6IFVuaXguRXJyb3IudCkgOiBFcnJvcl9raW5kLnQgPVxuICAgIG1hdGNoIGVycm9yIHdpdGhcbiAgICB8IEVBR0FJTiB8IEVXT1VMREJMT0NLIHwgRUlOVFIgLT4gV3JpdGVfYmxvY2tlZFxuICAgIHwgRVBJUEUgfCBFQ09OTlJFU0VUIHwgRUhPU1RVTlJFQUNIIHwgRU5FVERPV04gfCBFTkVUUkVTRVQgfCBFTkVUVU5SRUFDSCB8IEVUSU1FRE9VVFxuICAgICAgLT5cbiAgICAgIENvbm5lY3Rpb25fc3RhdGUuY29ubmVjdGlvbl9sb3N0IHQuY29ubmVjdGlvbl9zdGF0ZTtcbiAgICAgIENvbm5lY3Rpb25fbG9zdFxuICAgIHwgXyAtPiBPdGhlcl9lcnJvclxuICA7O1xuXG4gIG1vZHVsZSBTaW5nbGVfd3JpdGVfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgQ29udGludWVcbiAgICAgIHwgU3RvcFxuICBlbmRcblxuICBsZXQgc2luZ2xlX3dyaXRlIHQgOiBTaW5nbGVfd3JpdGVfcmVzdWx0LnQgPVxuICAgIG1hdGNoXG4gICAgICBCaWdzdHJpbmdfdW5peC53cml0ZV9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmdcbiAgICAgICAgKEZkLmZpbGVfZGVzY3JfZXhuIHQuZmQpXG4gICAgICAgIHQuYnVmXG4gICAgICAgIH5wb3M6MFxuICAgICAgICB+bGVuOnQucG9zXG4gICAgd2l0aFxuICAgIHwgbiAtPlxuICAgICAgZGlzY2FyZCB0IG47XG4gICAgICBDb250aW51ZVxuICAgIHwgZXhjZXB0aW9uIChVbml4LlVuaXhfZXJyb3IgKGVycm9yLCBfLCBfKSBhcyBleG4pIC0+XG4gICAgICAobWF0Y2ggaGFuZGxlX2Vycm9yIHQgZXJyb3Igd2l0aFxuICAgICAgIHwgV3JpdGVfYmxvY2tlZCAtPiBDb250aW51ZVxuICAgICAgIHwgQ29ubmVjdGlvbl9sb3N0IC0+IFN0b3BcbiAgICAgICB8IE90aGVyX2Vycm9yIC0+IHJhaXNlIGV4bilcbiAgOztcblxuICBsZXQgZmluaXNoX2Nsb3NlIHQgPVxuICAgIGxldCBmZF9jbG9zZWQgPSBGZC5jbG9zZSB0LmZkIGluXG4gICAgdC53cml0aW5nIDwtIGZhbHNlO1xuICAgIENvbm5lY3Rpb25fc3RhdGUuZmluaXNoX2Nsb3NlIHQuY29ubmVjdGlvbl9zdGF0ZSB+ZmRfY2xvc2VkXG4gIDs7XG5cbiAgbGV0IHJlYyB3cml0ZV9ldmVyeXRoaW5nIHQgPVxuICAgIG1hdGNoIHNpbmdsZV93cml0ZSB0IHdpdGhcbiAgICB8IFN0b3AgLT4gZmluaXNoX2Nsb3NlIHRcbiAgICB8IENvbnRpbnVlIC0+XG4gICAgICBpZiB0LnBvcyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICB0LndyaXRpbmcgPC0gZmFsc2U7XG4gICAgICAgIGlmIGlzX2Nsb3NlZCB0IHRoZW4gZmluaXNoX2Nsb3NlIHQpXG4gICAgICBlbHNlIHdhaXRfYW5kX3dyaXRlX2V2ZXJ5dGhpbmcgdFxuXG4gIGFuZCB3YWl0X2FuZF93cml0ZV9ldmVyeXRoaW5nIHQgPVxuICAgIENsb2NrX25zLndpdGhfdGltZW91dCB0LmNvbmZpZy53cml0ZV90aW1lb3V0IChGZC5yZWFkeV90byB0LmZkIGBXcml0ZSlcbiAgICA+Pj4gZnVuIHJlc3VsdCAtPlxuICAgIGlmIG5vdCAoQ29ubmVjdGlvbl9zdGF0ZS5pc19hYmxlX3RvX3NlbmRfZGF0YSB0LmNvbm5lY3Rpb25fc3RhdGUpXG4gICAgdGhlbiBmaW5pc2hfY2xvc2UgdFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgIHwgYFJlc3VsdCBgUmVhZHkgLT4gd3JpdGVfZXZlcnl0aGluZyB0XG4gICAgICB8IGBUaW1lb3V0IC0+XG4gICAgICAgIEFzeW5jX2xvZy5QcHhfbG9nX3N5bnRheC4oXG4gICAgICAgICAgWyVsb2cuZ2xvYmFsLmVycm9yXG4gICAgICAgICAgICBcIlJwY190cmFuc3BvcnRfbG93X2xhdGVuY3kuV3JpdGVyIHRpbWVkIG91dCB3YWl0aW5nIHRvIHdyaXRlIG9uIGZpbGUgXFxcbiAgICAgICAgICAgICBkZXNjcmlwdG9yLiBDbG9zaW5nIHRoZSB3cml0ZXIuXCJcbiAgICAgICAgICAgICAgfnRpbWVvdXQ6KHQuY29uZmlnLndyaXRlX3RpbWVvdXQgOiBUaW1lX25zLlNwYW4udClcbiAgICAgICAgICAgICAgKHQgOiB0KV0pO1xuICAgICAgICBmaW5pc2hfY2xvc2UgdFxuICAgICAgfCBgUmVzdWx0ICgoYEJhZF9mZCB8IGBDbG9zZWQpIGFzIHJlc3VsdCkgLT5cbiAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgIFslc2V4cFxuICAgICAgICAgICAgXCJScGNfdHJhbnNwb3J0X2xvd19sYXRlbmN5LldyaXRlcjogZmQgY2hhbmdlZFwiXG4gICAgICAgICAgICAsIHsgdCA6IHQ7IHJlYWR5X3RvX3Jlc3VsdCA9IChyZXN1bHQgOiBbIGBCYWRfZmQgfCBgQ2xvc2VkIF0pIH1dKVxuICA7O1xuXG4gIGxldCBmbHVzaCB0ID1cbiAgICBpZiAobm90IHQud3JpdGluZykgJiYgdC5wb3MgPiAwXG4gICAgdGhlbiAoXG4gICAgICB0LndyaXRpbmcgPC0gdHJ1ZTtcbiAgICAgIFNjaGVkdWxlci53aXRoaW4gfm1vbml0b3I6dC5tb25pdG9yIChmdW4gKCkgLT4gd3JpdGVfZXZlcnl0aGluZyB0KSlcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfZmx1c2ggdCA9XG4gICAgaWYgKG5vdCB0LndyaXRpbmcpICYmIHQucG9zID4gMFxuICAgIHRoZW4gKFxuICAgICAgdC53cml0aW5nIDwtIHRydWU7XG4gICAgICBTY2hlZHVsZXIud2l0aGluIH5tb25pdG9yOnQubW9uaXRvciAoZnVuICgpIC0+IHdhaXRfYW5kX3dyaXRlX2V2ZXJ5dGhpbmcgdCkpXG4gIDs7XG5cbiAgbGV0IGVuc3VyZV9hdF9sZWFzdCB0IH5uZWVkZWQgPVxuICAgIGlmIEJpZ3N0cmluZy5sZW5ndGggdC5idWYgLSB0LnBvcyA8IG5lZWRlZFxuICAgIHRoZW4gKFxuICAgICAgbGV0IG5ld19zaXplX3JlcXVlc3QgPSB0LnBvcyArIG5lZWRlZCBpblxuICAgICAgdC5idWYgPC0gQ29uZmlnLmdyb3dfYnVmZmVyIHQuY29uZmlnIHQuYnVmIH5uZXdfc2l6ZV9yZXF1ZXN0KVxuICA7O1xuXG4gIGxldCBjb3B5X2J5dGVzIHQgfmJ1ZiB+cG9zIH5sZW4gPVxuICAgIGlmIGxlbiA+IDBcbiAgICB0aGVuIChcbiAgICAgIGVuc3VyZV9hdF9sZWFzdCB0IH5uZWVkZWQ6bGVuO1xuICAgICAgQmlnc3RyaW5nLmJsaXQgfnNyYzpidWYgfmRzdDp0LmJ1ZiB+c3JjX3Bvczpwb3MgfmRzdF9wb3M6dC5wb3MgfmxlbjtcbiAgICAgIHQucG9zIDwtIHQucG9zICsgbGVuKVxuICA7O1xuXG4gICgqIFdyaXRlIHdoYXQncyBpbiB0aGUgaW50ZXJuYWwgYnVmZmVyICsgYnl0ZXMgZGVub3RlZCBieSBbKGJ1ZiwgcG9zLCBsZW4pXSAqKVxuICBsZXQgdW5zYWZlX3NlbmRfYnl0ZXMgdCB+YnVmIH5wb3MgfmxlbiA9XG4gICAgbGV0IHJlc3VsdCA9XG4gICAgICB3cml0ZXYyXG4gICAgICAgIChGZC5maWxlX2Rlc2NyX2V4biB0LmZkKVxuICAgICAgICB+YnVmMTp0LmJ1ZlxuICAgICAgICB+cG9zMTowXG4gICAgICAgIH5sZW4xOnQucG9zXG4gICAgICAgIH5idWYyOmJ1ZlxuICAgICAgICB+cG9zMjpwb3NcbiAgICAgICAgfmxlbjI6bGVuXG4gICAgaW5cbiAgICBpZiBVbml4LlN5c2NhbGxfcmVzdWx0LkludC5pc19vayByZXN1bHRcbiAgICB0aGVuIChcbiAgICAgIGxldCBuID0gVW5peC5TeXNjYWxsX3Jlc3VsdC5JbnQub2tfZXhuIHJlc3VsdCBpblxuICAgICAgaWYgbiA8PSB0LnBvc1xuICAgICAgdGhlbiAoXG4gICAgICAgICgqIFdlIHdyb3RlIGxlc3MgdGhhbiB3aGF0J3MgaW4gdGhlIGludGVybmFsIGJ1ZmZlciwgZGlzY2FyZCB3aGF0IHdhcyB3cml0dGVuIGFuZFxuICAgICAgICAgICBjb3B5IGluIHRoZSBvdGhlciBidWZmZXIuICopXG4gICAgICAgIGRpc2NhcmQgdCBuO1xuICAgICAgICBjb3B5X2J5dGVzIHQgfmJ1ZiB+cG9zIH5sZW4pXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHdyaXR0ZW5fZnJvbV9vdGhlcl9idWYgPSBuIC0gdC5wb3MgaW5cbiAgICAgICAgbGV0IHJlbWFpbmluZ19pbl9vdGhlcl9idWYgPSBsZW4gLSB3cml0dGVuX2Zyb21fb3RoZXJfYnVmIGluXG4gICAgICAgIGRpc2NhcmQgdCB0LnBvcztcbiAgICAgICAgaWYgcmVtYWluaW5nX2luX290aGVyX2J1ZiA+IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIGNvcHlfYnl0ZXNcbiAgICAgICAgICAgIHRcbiAgICAgICAgICAgIH5idWZcbiAgICAgICAgICAgIH5wb3M6KHBvcyArIHdyaXR0ZW5fZnJvbV9vdGhlcl9idWYpXG4gICAgICAgICAgICB+bGVuOnJlbWFpbmluZ19pbl9vdGhlcl9idWYpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGVycm9yID0gVW5peC5TeXNjYWxsX3Jlc3VsdC5JbnQuZXJyb3JfZXhuIHJlc3VsdCBpblxuICAgICAgbWF0Y2ggaGFuZGxlX2Vycm9yIHQgZXJyb3Igd2l0aFxuICAgICAgfCBXcml0ZV9ibG9ja2VkIC0+IGNvcHlfYnl0ZXMgdCB+YnVmIH5wb3MgfmxlblxuICAgICAgfCBDb25uZWN0aW9uX2xvc3QgLT4gKClcbiAgICAgIHwgT3RoZXJfZXJyb3IgLT5cbiAgICAgICAgbGV0IHN5c2NhbGwgPSBpZiBsZW4gPSAwIHRoZW4gXCJ3cml0ZVwiIGVsc2UgXCJ3cml0ZXZcIiBpblxuICAgICAgICBNb25pdG9yLnNlbmRfZXhuIHQubW9uaXRvciAoVW5peC5Vbml4X2Vycm9yIChlcnJvciwgc3lzY2FsbCwgXCJcIikpKVxuICA7O1xuXG4gIGxldCBzbG93X3dyaXRlX2Jpbl9wcm90X2FuZF9iaWdzdHJpbmdcbiAgICB0XG4gICAgKHdyaXRlciA6IF8gQmluX3Byb3QuVHlwZV9jbGFzcy53cml0ZXIpXG4gICAgbXNnXG4gICAgfmJ1ZlxuICAgIH5wb3NcbiAgICB+bGVuXG4gICAgOiBfIFNlbmRfcmVzdWx0LnRcbiAgICA9XG4gICAgbGV0IHBheWxvYWRfbGVuID0gd3JpdGVyLnNpemUgbXNnICsgbGVuIGluXG4gICAgbGV0IHRvdGFsX2xlbiA9IEhlYWRlci5sZW5ndGggKyBwYXlsb2FkX2xlbiBpblxuICAgIGlmIENvbmZpZy5tZXNzYWdlX3NpemVfb2sgdC5jb25maWcgfnBheWxvYWRfbGVuXG4gICAgdGhlbiAoXG4gICAgICBlbnN1cmVfYXRfbGVhc3QgdCB+bmVlZGVkOnRvdGFsX2xlbjtcbiAgICAgIEhlYWRlci51bnNhZmVfc2V0X3BheWxvYWRfbGVuZ3RoIHQuYnVmIH5wb3M6dC5wb3MgcGF5bG9hZF9sZW47XG4gICAgICBsZXQgc3RvcCA9IHdyaXRlci53cml0ZSB0LmJ1ZiB+cG9zOih0LnBvcyArIEhlYWRlci5sZW5ndGgpIG1zZyBpblxuICAgICAgYXNzZXJ0IChzdG9wICsgbGVuID0gdC5wb3MgKyB0b3RhbF9sZW4pO1xuICAgICAgQmlnc3RyaW5nLmJsaXQgfnNyYzpidWYgfmRzdDp0LmJ1ZiB+c3JjX3Bvczpwb3MgfmRzdF9wb3M6c3RvcCB+bGVuO1xuICAgICAgdC5wb3MgPC0gc3RvcCArIGxlbjtcbiAgICAgIFNlbnQgeyByZXN1bHQgPSAoKTsgYnl0ZXMgPSBwYXlsb2FkX2xlbiB9KVxuICAgIGVsc2VcbiAgICAgIE1lc3NhZ2VfdG9vX2JpZyB7IHNpemUgPSBwYXlsb2FkX2xlbjsgbWF4X21lc3NhZ2Vfc2l6ZSA9IHQuY29uZmlnLm1heF9tZXNzYWdlX3NpemUgfVxuICA7O1xuXG4gIGxldCBzaG91bGRfc2VuZF9ub3cgdCA9XG4gICAgbGV0IGN1cnJlbnRfam9iID0gZ2V0X2pvYl9udW1iZXIgKCkgaW5cbiAgICBpZiBjdXJyZW50X2pvYiA9IHQubGFzdF9zZW5kX2pvYlxuICAgIHRoZW4gdC5zZW5kc19pbl90aGlzX2pvYiA8LSB0LnNlbmRzX2luX3RoaXNfam9iICsgMVxuICAgIGVsc2UgKFxuICAgICAgdC5sYXN0X3NlbmRfam9iIDwtIGN1cnJlbnRfam9iO1xuICAgICAgdC5zZW5kc19pbl90aGlzX2pvYiA8LSAxKTtcbiAgICB0LnBvcyA+PSB0LmNvbmZpZy5idWZmZXJpbmdfdGhyZXNob2xkX2luX2J5dGVzXG4gICAgfHwgdC5zZW5kc19pbl90aGlzX2pvYiA8PSB0LmNvbmZpZy5zdGFydF9iYXRjaGluZ19hZnRlcl9udW1fbWVzc2FnZXNcbiAgOztcblxuICBsZXQgc2VuZF9iaW5fcHJvdF9hbmRfYmlnc3RyaW5nXG4gICAgdFxuICAgICh3cml0ZXIgOiBfIEJpbl9wcm90LlR5cGVfY2xhc3Mud3JpdGVyKVxuICAgIG1zZ1xuICAgIH5idWZcbiAgICB+cG9zXG4gICAgfmxlblxuICAgIDogXyBTZW5kX3Jlc3VsdC50XG4gICAgPVxuICAgIGlmIGlzX2Nsb3NlZCB0XG4gICAgdGhlbiBDbG9zZWRcbiAgICBlbHNlIChcbiAgICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG5cbiAgICAgICAgfnBvc1xuICAgICAgICB+bGVuXG4gICAgICAgIH50b3RhbF9sZW5ndGg6KEJpZ3N0cmluZy5sZW5ndGggYnVmKTtcbiAgICAgIGlmIENvbm5lY3Rpb25fc3RhdGUuaXNfYWJsZV90b19zZW5kX2RhdGEgdC5jb25uZWN0aW9uX3N0YXRlXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHNlbmRfbm93ID0gc2hvdWxkX3NlbmRfbm93IHQgaW5cbiAgICAgICAgbGV0IHJlc3VsdCA9XG4gICAgICAgICAgaWYgQmlnc3RyaW5nLmxlbmd0aCB0LmJ1ZiAtIHQucG9zIDwgSGVhZGVyLmxlbmd0aFxuICAgICAgICAgIHRoZW4gc2xvd193cml0ZV9iaW5fcHJvdF9hbmRfYmlnc3RyaW5nIHQgd3JpdGVyIG1zZyB+YnVmIH5wb3MgfmxlblxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbWF0Y2ggd3JpdGVyLndyaXRlIHQuYnVmIH5wb3M6KHQucG9zICsgSGVhZGVyLmxlbmd0aCkgbXNnIHdpdGhcbiAgICAgICAgICAgIHwgZXhjZXB0aW9uIF8gLT5cbiAgICAgICAgICAgICAgKCogSXQncyBsaWtlbHkgdGhhdCB0aGUgZXhjZXB0aW9uIGlzIGR1ZSB0byBhIGJ1ZmZlciBvdmVyZmxvdywgc28gcmVzaXplIHRoZVxuICAgICAgICAgICAgICAgICBpbnRlcm5hbCBidWZmZXIgYW5kIHRyeSBhZ2Fpbi4gVGVjaG5pY2FsbHkgd2UgY291bGQgbWF0Y2ggb25cbiAgICAgICAgICAgICAgICAgW0Jpbl9wcm90LkNvbW1vbi5CdWZmZXJfc2hvcnRdIG9ubHksIGhvd2V2ZXIgd2UgY2FuJ3QgZWFzaWx5IGVuZm9yY2UgdGhhdFxuICAgICAgICAgICAgICAgICBjdXN0b20gYmluX3dyaXRlX3h4eCBmdW5jdGlvbnMgcmFpc2UgdGhpcyBwYXJ0aWN1bGFyIGV4Y2VwdGlvbiBhbmQgbm90XG4gICAgICAgICAgICAgICAgIFtJbnZhbGlkX2FyZ3VtZW50XSBvciBbRmFpbHVyZV0gZm9yIGluc3RhbmNlLiAqKVxuICAgICAgICAgICAgICBzbG93X3dyaXRlX2Jpbl9wcm90X2FuZF9iaWdzdHJpbmcgdCB3cml0ZXIgbXNnIH5idWYgfnBvcyB+bGVuXG4gICAgICAgICAgICB8IHN0b3AgLT5cbiAgICAgICAgICAgICAgbGV0IHBheWxvYWRfbGVuID0gc3RvcCAtICh0LnBvcyArIEhlYWRlci5sZW5ndGgpICsgbGVuIGluXG4gICAgICAgICAgICAgIGlmIENvbmZpZy5tZXNzYWdlX3NpemVfb2sgdC5jb25maWcgfnBheWxvYWRfbGVuXG4gICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgIEhlYWRlci51bnNhZmVfc2V0X3BheWxvYWRfbGVuZ3RoIHQuYnVmIH5wb3M6dC5wb3MgcGF5bG9hZF9sZW47XG4gICAgICAgICAgICAgICAgdC5wb3MgPC0gc3RvcDtcbiAgICAgICAgICAgICAgICBpZiBzZW5kX25vd1xuICAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICAgbGV0IGxlbiA9XG4gICAgICAgICAgICAgICAgICAgIGlmIGxlbiA8IDEyOFxuICAgICAgICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgICAgICBjb3B5X2J5dGVzIHQgfmJ1ZiB+cG9zIH5sZW47XG4gICAgICAgICAgICAgICAgICAgICAgMClcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBsZW5cbiAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICB1bnNhZmVfc2VuZF9ieXRlcyB0IH5idWYgfnBvcyB+bGVuKVxuICAgICAgICAgICAgICAgIGVsc2UgY29weV9ieXRlcyB0IH5idWYgfnBvcyB+bGVuO1xuICAgICAgICAgICAgICAgIFNlbnQgeyByZXN1bHQgPSAoKTsgYnl0ZXMgPSBwYXlsb2FkX2xlbiB9KVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgTWVzc2FnZV90b29fYmlnXG4gICAgICAgICAgICAgICAgICB7IHNpemUgPSBwYXlsb2FkX2xlbjsgbWF4X21lc3NhZ2Vfc2l6ZSA9IHQuY29uZmlnLm1heF9tZXNzYWdlX3NpemUgfSlcbiAgICAgICAgaW5cbiAgICAgICAgaWYgc2VuZF9ub3cgdGhlbiBmbHVzaCB0IGVsc2Ugc2NoZWR1bGVfZmx1c2ggdDtcbiAgICAgICAgcmVzdWx0KVxuICAgICAgZWxzZSBTZW50IHsgcmVzdWx0ID0gKCk7IGJ5dGVzID0gMCB9KVxuICA7O1xuXG4gIGxldCBzZW5kX2Jpbl9wcm90X2FuZF9iaWdzdHJpbmdfbm9uX2NvcHlpbmcgdCB3cml0ZXIgbXNnIH5idWYgfnBvcyB+bGVuID1cbiAgICBtYXRjaCBzZW5kX2Jpbl9wcm90X2FuZF9iaWdzdHJpbmcgdCB3cml0ZXIgbXNnIH5idWYgfnBvcyB+bGVuIHdpdGhcbiAgICB8IChDbG9zZWQgfCBNZXNzYWdlX3Rvb19iaWcgXykgYXMgciAtPiByXG4gICAgfCBTZW50IHsgcmVzdWx0ID0gKCk7IGJ5dGVzIH0gLT4gU2VudCB7IHJlc3VsdCA9IERlZmVycmVkLnVuaXQ7IGJ5dGVzIH1cbiAgOztcblxuICBsZXQgZHVtbXlfYnVmID0gQmlnc3RyaW5nLmNyZWF0ZSAwXG5cbiAgbGV0IHNlbmRfYmluX3Byb3QgdCB3cml0ZXIgbXNnID1cbiAgICBzZW5kX2Jpbl9wcm90X2FuZF9iaWdzdHJpbmcgdCB3cml0ZXIgbXNnIH5idWY6ZHVtbXlfYnVmIH5wb3M6MCB+bGVuOjBcbiAgOztcblxuICBsZXQgY2xvc2UgdCA9XG4gICAgaWYgbm90IChpc19jbG9zZWQgdClcbiAgICB0aGVuIChcbiAgICAgIENvbm5lY3Rpb25fc3RhdGUuc3RhcnRfY2xvc2UgdC5jb25uZWN0aW9uX3N0YXRlO1xuICAgICAgZmx1c2ggdDtcbiAgICAgIGlmIG5vdCB0LndyaXRpbmcgdGhlbiBmaW5pc2hfY2xvc2UgdCk7XG4gICAgY2xvc2VfZmluaXNoZWQgdFxuICA7O1xuZW5kXG5cbmxldCBtYWtlX2NyZWF0ZSBmID8oY29uZmlnID0gQ29uZmlnLmRlZmF1bHQpIH5tYXhfbWVzc2FnZV9zaXplIGZkID1cbiAgbGV0IG1heF9tZXNzYWdlX3NpemUgPSBtaW4gY29uZmlnLm1heF9tZXNzYWdlX3NpemUgbWF4X21lc3NhZ2Vfc2l6ZSBpblxuICBsZXQgY29uZmlnID0gQ29uZmlnLnZhbGlkYXRlIHsgY29uZmlnIHdpdGggbWF4X21lc3NhZ2Vfc2l6ZSB9IGluXG4gIGYgZmQgY29uZmlnXG47O1xuXG5tb2R1bGUgUmVhZGVyID0gc3RydWN0XG4gIGluY2x1ZGUgS2VybmVsX3RyYW5zcG9ydC5SZWFkZXJcblxuICBtb2R1bGUgV2l0aF9pbnRlcm5hbF9yZWFkZXIgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgeyBpbnRlcm5hbF9yZWFkZXIgOiBSZWFkZXJfaW50ZXJuYWwudFxuICAgICAgOyByZWFkZXIgOiBLZXJuZWxfdHJhbnNwb3J0LlJlYWRlci50XG4gICAgICB9XG5cbiAgICBsZXQgY3JlYXRlX2ludGVybmFsIGZkIGNvbmZpZyA9XG4gICAgICBsZXQgaW50ZXJuYWxfcmVhZGVyID0gUmVhZGVyX2ludGVybmFsLmNyZWF0ZSBmZCBjb25maWcgaW5cbiAgICAgIGxldCByZWFkZXIgPSBwYWNrIChtb2R1bGUgUmVhZGVyX2ludGVybmFsKSBpbnRlcm5hbF9yZWFkZXIgaW5cbiAgICAgIHsgaW50ZXJuYWxfcmVhZGVyOyByZWFkZXIgfVxuICAgIDs7XG5cbiAgICBsZXQgY3JlYXRlID0gbWFrZV9jcmVhdGUgY3JlYXRlX2ludGVybmFsXG4gICAgbGV0IHRyYW5zcG9ydF9yZWFkZXIgdCA9IHQucmVhZGVyXG5cbiAgICBsZXQgcmVhZF9vbmVfbWVzc2FnZV9iaW5fcHJvdF93aXRob3V0X2J1ZmZlcmluZyB0IGJpbl9yZWFkZXIgPVxuICAgICAgUmVhZGVyX2ludGVybmFsLnJlYWRfb25lX21lc3NhZ2VfYmluX3Byb3Rfd2l0aG91dF9idWZmZXJpbmdcbiAgICAgICAgdC5pbnRlcm5hbF9yZWFkZXJcbiAgICAgICAgYmluX3JlYWRlclxuICAgIDs7XG5cbiAgICBsZXQgcGVla19iaW5fcHJvdCB0IGJpbl9yZWFkZXIgPVxuICAgICAgUmVhZGVyX2ludGVybmFsLnBlZWtfYmluX3Byb3QgdC5pbnRlcm5hbF9yZWFkZXIgYmluX3JlYWRlclxuICAgIDs7XG5cbiAgICBsZXQgcGVla19vbmNlX3dpdGhvdXRfYnVmZmVyaW5nX2Zyb21fc29ja2V0IHQgfmxlbiA9XG4gICAgICBSZWFkZXJfaW50ZXJuYWwucGVla19vbmNlX3dpdGhvdXRfYnVmZmVyaW5nX2Zyb21fc29ja2V0IHQuaW50ZXJuYWxfcmVhZGVyIH5sZW5cbiAgICA7O1xuICBlbmRcblxuICBsZXQgY3JlYXRlID9jb25maWcgfm1heF9tZXNzYWdlX3NpemUgZmQgPVxuICAgIGxldCBpbnRlcm5hbCA9XG4gICAgICBtYWtlX2NyZWF0ZSBXaXRoX2ludGVybmFsX3JlYWRlci5jcmVhdGVfaW50ZXJuYWwgP2NvbmZpZyB+bWF4X21lc3NhZ2Vfc2l6ZSBmZFxuICAgIGluXG4gICAgaW50ZXJuYWwucmVhZGVyXG4gIDs7XG5lbmRcblxubW9kdWxlIFdyaXRlciA9IHN0cnVjdFxuICBpbmNsdWRlIEtlcm5lbF90cmFuc3BvcnQuV3JpdGVyXG5cbiAgbGV0IGNyZWF0ZV9pbnRlcm5hbCBmZCBjb25maWcgPVxuICAgIHBhY2sgKG1vZHVsZSBXcml0ZXJfaW50ZXJuYWwpIChXcml0ZXJfaW50ZXJuYWwuY3JlYXRlIGZkIGNvbmZpZylcbiAgOztcblxuICBsZXQgY3JlYXRlID0gbWFrZV9jcmVhdGUgY3JlYXRlX2ludGVybmFsXG5lbmRcblxudHlwZSB0ID0gS2VybmVsX3RyYW5zcG9ydC50ID1cbiAgeyByZWFkZXIgOiBSZWFkZXIudFxuICA7IHdyaXRlciA6IFdyaXRlci50XG4gIH1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbm1vZHVsZSBXaXRoX2ludGVybmFsX3JlYWRlciA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgcmVhZGVyX3dpdGhfaW50ZXJuYWxfcmVhZGVyIDogUmVhZGVyLldpdGhfaW50ZXJuYWxfcmVhZGVyLnRcbiAgICA7IHdyaXRlciA6IFdyaXRlci50XG4gICAgfVxuXG4gIGxldCBjcmVhdGVfaW50ZXJuYWwgZmQgY29uZmlnID1cbiAgICB7IHJlYWRlcl93aXRoX2ludGVybmFsX3JlYWRlciA9IFJlYWRlci5XaXRoX2ludGVybmFsX3JlYWRlci5jcmVhdGVfaW50ZXJuYWwgZmQgY29uZmlnXG4gICAgOyB3cml0ZXIgPSBXcml0ZXIuY3JlYXRlX2ludGVybmFsIGZkIGNvbmZpZ1xuICAgIH1cbiAgOztcblxuICBsZXQgY3JlYXRlID0gbWFrZV9jcmVhdGUgY3JlYXRlX2ludGVybmFsXG5lbmRcblxubGV0IGNsb3NlID0gS2VybmVsX3RyYW5zcG9ydC5jbG9zZVxuXG5sZXQgY3JlYXRlID9jb25maWcgfm1heF9tZXNzYWdlX3NpemUgZmQgPVxuICBsZXQgaW50ZXJuYWwgPVxuICAgIG1ha2VfY3JlYXRlIFdpdGhfaW50ZXJuYWxfcmVhZGVyLmNyZWF0ZV9pbnRlcm5hbCA/Y29uZmlnIH5tYXhfbWVzc2FnZV9zaXplIGZkXG4gIGluXG4gIHsgcmVhZGVyID0gaW50ZXJuYWwucmVhZGVyX3dpdGhfaW50ZXJuYWxfcmVhZGVyLnJlYWRlcjsgd3JpdGVyID0gaW50ZXJuYWwud3JpdGVyIH1cbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5tb2R1bGUgS2VybmVsX3RyYW5zcG9ydCA9IFJwY19rZXJuZWwuVHJhbnNwb3J0XG5tb2R1bGUgSGVhZGVyID0gS2VybmVsX3RyYW5zcG9ydC5IZWFkZXJcbm1vZHVsZSBIYW5kbGVyX3Jlc3VsdCA9IEtlcm5lbF90cmFuc3BvcnQuSGFuZGxlcl9yZXN1bHRcbm1vZHVsZSBTZW5kX3Jlc3VsdCA9IEtlcm5lbF90cmFuc3BvcnQuU2VuZF9yZXN1bHRcblxubGV0IG1heF9tZXNzYWdlX3NpemVfZW52X3ZhciA9IFwiQVNZTkNfUlBDX01BWF9NRVNTQUdFX1NJWkVcIlxuXG5sZXQgbWF4X21lc3NhZ2Vfc2l6ZV9mcm9tX2Vudmlyb25tZW50ID1cbiAgbGF6eVxuICAgIChPcHRpb24udHJ5X3dpdGhfam9pbiAoZnVuICgpIC0+XG4gICAgICAgU3lzLmdldGVudiBtYXhfbWVzc2FnZV9zaXplX2Vudl92YXIgfD4gT3B0aW9uLm1hcCB+ZjpJbnQub2Zfc3RyaW5nKSlcbjs7XG5cbmxldCBhdXhfZWZmZWN0aXZlX21heF9tZXNzYWdlX3NpemUgfm1heF9tZXNzYWdlX3NpemVfZnJvbV9lbnZpcm9ubWVudCB+cHJvcG9zZWRfbWF4ID1cbiAgbGV0IGRlZmF1bHQgPVxuICAgICgqIHVuZm9ydHVuYXRlbHksIGNvcGllZCBmcm9tIHJlYWRlcjAubWwgKilcbiAgICAxMDAgKiAxMDI0ICogMTAyNFxuICBpblxuICBtYXRjaCBwcm9wb3NlZF9tYXgsIG1heF9tZXNzYWdlX3NpemVfZnJvbV9lbnZpcm9ubWVudCB3aXRoXG4gIHwgTm9uZSwgTm9uZSAtPiBkZWZhdWx0XG4gIHwgU29tZSB4LCBOb25lIHwgTm9uZSwgU29tZSB4IC0+IHhcbiAgfCBTb21lIHgsIFNvbWUgeSAtPiBJbnQubWF4IHggeVxuOztcblxubGV0JWV4cGVjdF90ZXN0IFwiIFwiID1cbiAgbGV0IHRlc3Qgfm1heF9tZXNzYWdlX3NpemVfZnJvbV9lbnZpcm9ubWVudCA9XG4gICAgTGlzdC5pdGVyXG4gICAgICBbIE5vbmU7IFNvbWUgMTsgU29tZSAoMjAwICogMTAyNCAqIDEwMjQpIF1cbiAgICAgIH5mOihmdW4gcHJvcG9zZWRfbWF4IC0+XG4gICAgICAgIGxldCBlZmZlY3RpdmVfbWF4ID1cbiAgICAgICAgICBhdXhfZWZmZWN0aXZlX21heF9tZXNzYWdlX3NpemUgfm1heF9tZXNzYWdlX3NpemVfZnJvbV9lbnZpcm9ubWVudCB+cHJvcG9zZWRfbWF4XG4gICAgICAgIGluXG4gICAgICAgIHByaW50X3MgWyVtZXNzYWdlIChwcm9wb3NlZF9tYXggOiBpbnQgb3B0aW9uKSAoZWZmZWN0aXZlX21heCA6IGludCldKVxuICBpblxuICB0ZXN0IH5tYXhfbWVzc2FnZV9zaXplX2Zyb21fZW52aXJvbm1lbnQ6Tm9uZTtcbiAgWyVleHBlY3RcbiAgICB7fFxuICAgICgocHJvcG9zZWRfbWF4ICgpKSAoZWZmZWN0aXZlX21heCAxMDQ4NTc2MDApKVxuICAgICgocHJvcG9zZWRfbWF4ICgxKSkgKGVmZmVjdGl2ZV9tYXggMSkpXG4gICAgKChwcm9wb3NlZF9tYXggKDIwOTcxNTIwMCkpIChlZmZlY3RpdmVfbWF4IDIwOTcxNTIwMCkpXG4gICAgfH1dO1xuICB0ZXN0IH5tYXhfbWVzc2FnZV9zaXplX2Zyb21fZW52aXJvbm1lbnQ6KFNvbWUgMTAyNCk7XG4gIFslZXhwZWN0XG4gICAge3xcbiAgICAoKHByb3Bvc2VkX21heCAoKSkgKGVmZmVjdGl2ZV9tYXggMTAyNCkpXG4gICAgKChwcm9wb3NlZF9tYXggKDEpKSAoZWZmZWN0aXZlX21heCAxMDI0KSlcbiAgICAoKHByb3Bvc2VkX21heCAoMjA5NzE1MjAwKSkgKGVmZmVjdGl2ZV9tYXggMjA5NzE1MjAwKSlcbiAgICB8fV07XG4gIHRlc3Qgfm1heF9tZXNzYWdlX3NpemVfZnJvbV9lbnZpcm9ubWVudDooU29tZSAoMzAwICogMTAyNCAqIDEwMjQpKTtcbiAgWyVleHBlY3RcbiAgICB7fFxuICAgICgocHJvcG9zZWRfbWF4ICgpKSAoZWZmZWN0aXZlX21heCAzMTQ1NzI4MDApKVxuICAgICgocHJvcG9zZWRfbWF4ICgxKSkgKGVmZmVjdGl2ZV9tYXggMzE0NTcyODAwKSlcbiAgICAoKHByb3Bvc2VkX21heCAoMjA5NzE1MjAwKSkgKGVmZmVjdGl2ZV9tYXggMzE0NTcyODAwKSlcbiAgICB8fV1cbjs7XG5cbmxldCBlZmZlY3RpdmVfbWF4X21lc3NhZ2Vfc2l6ZSB+cHJvcG9zZWRfbWF4ID1cbiAgbGV0IG1heF9tZXNzYWdlX3NpemVfZnJvbV9lbnZpcm9ubWVudCA9IGZvcmNlIG1heF9tZXNzYWdlX3NpemVfZnJvbV9lbnZpcm9ubWVudCBpblxuICBhdXhfZWZmZWN0aXZlX21heF9tZXNzYWdlX3NpemUgfm1heF9tZXNzYWdlX3NpemVfZnJvbV9lbnZpcm9ubWVudCB+cHJvcG9zZWRfbWF4XG47O1xuXG5tb2R1bGUgV2l0aF9saW1pdCA6IHNpZ1xuICB0eXBlICdhIHQgPSBwcml2YXRlXG4gICAgeyB0IDogJ2FcbiAgICA7IG1heF9tZXNzYWdlX3NpemUgOiBpbnRcbiAgICA7IG11dGFibGUgdG90YWxfYnl0ZXMgOiBJbnQ2My50XG4gICAgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHZhbCBjcmVhdGUgOiAnYSAtPiBtYXhfbWVzc2FnZV9zaXplOmludCBvcHRpb24gLT4gJ2EgdFxuICB2YWwgbWVzc2FnZV9zaXplX29rIDogXyB0IC0+IHBheWxvYWRfbGVuOmludCAtPiBib29sXG4gIHZhbCBjaGVja19tZXNzYWdlX3NpemUgOiBfIHQgLT4gcGF5bG9hZF9sZW46aW50IC0+IHVuaXRcbiAgdmFsIGluY3JfdG90YWxfYnl0ZXMgOiBfIHQgLT4gaW50IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgdCA6ICdhXG4gICAgOyBtYXhfbWVzc2FnZV9zaXplIDogaW50XG4gICAgOyBtdXRhYmxlIHRvdGFsX2J5dGVzIDogSW50NjMudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlIHQgfm1heF9tZXNzYWdlX3NpemUgPVxuICAgIGxldCBtYXhfbWVzc2FnZV9zaXplID0gZWZmZWN0aXZlX21heF9tZXNzYWdlX3NpemUgfnByb3Bvc2VkX21heDptYXhfbWVzc2FnZV9zaXplIGluXG4gICAgaWYgbWF4X21lc3NhZ2Vfc2l6ZSA8IDBcbiAgICB0aGVuXG4gICAgICBmYWlsd2l0aGZcbiAgICAgICAgXCJScGNfdHJhbnNwb3J0LldpdGhfbGltaXQuY3JlYXRlIGdvdCBuZWdhdGl2ZSBtYXggbWVzc2FnZSBzaXplOiAlZFwiXG4gICAgICAgIG1heF9tZXNzYWdlX3NpemVcbiAgICAgICAgKCk7XG4gICAgeyB0OyBtYXhfbWVzc2FnZV9zaXplOyB0b3RhbF9ieXRlcyA9IEludDYzLnplcm8gfVxuICA7O1xuXG4gIGxldCBtZXNzYWdlX3NpemVfb2sgdCB+cGF5bG9hZF9sZW4gPVxuICAgIHBheWxvYWRfbGVuID49IDAgJiYgcGF5bG9hZF9sZW4gPD0gdC5tYXhfbWVzc2FnZV9zaXplXG4gIDs7XG5cbiAgbGV0IGNoZWNrX21lc3NhZ2Vfc2l6ZSB0IH5wYXlsb2FkX2xlbiA9XG4gICAgaWYgbm90IChtZXNzYWdlX3NpemVfb2sgdCB+cGF5bG9hZF9sZW4pXG4gICAgdGhlblxuICAgICAgZmFpbHdpdGhzXG4gICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgWyVzdHJpbmdcbiAgICAgICAgICBcIlJwY190cmFuc3BvcnQ6IG1lc3NhZ2UgaXMgdG9vIGxhcmdlIG9yIGhhcyBuZWdhdGl2ZSBzaXplLiBUcnkgaW5jcmVhc2luZyB0aGUgXFxcbiAgICAgICAgICAgc2l6ZSBsaW1pdCBieSBzZXR0aW5nIHRoZSAle21heF9tZXNzYWdlX3NpemVfZW52X3Zhcn0gZW52IHZhclwiXVxuICAgICAgICAoYE1lc3NhZ2Vfc2l6ZSBwYXlsb2FkX2xlbiwgYE1heF9tZXNzYWdlX3NpemUgdC5tYXhfbWVzc2FnZV9zaXplKVxuICAgICAgICBbJXNleHBfb2Y6IFsgYE1lc3NhZ2Vfc2l6ZSBvZiBpbnQgXSAqIFsgYE1heF9tZXNzYWdlX3NpemUgb2YgaW50IF1dXG4gIDs7XG5cbiAgbGV0IGluY3JfdG90YWxfYnl0ZXMgdCBieXRlcyA9IHQudG90YWxfYnl0ZXMgPC0gSW50NjMuKHQudG90YWxfYnl0ZXMgKyBvZl9pbnQgYnl0ZXMpXG5lbmRcblxubW9kdWxlIFVuaXhfcmVhZGVyID0gc3RydWN0XG4gIG9wZW4gV2l0aF9saW1pdFxuXG4gIHR5cGUgdCA9IFJlYWRlci50IFdpdGhfbGltaXQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBjcmVhdGUgfnJlYWRlciB+bWF4X21lc3NhZ2Vfc2l6ZSA9IFdpdGhfbGltaXQuY3JlYXRlIHJlYWRlciB+bWF4X21lc3NhZ2Vfc2l6ZVxuICBsZXQgY2xvc2UgdCA9IFJlYWRlci5jbG9zZSB0LnRcbiAgbGV0IGlzX2Nsb3NlZCB0ID0gUmVhZGVyLmlzX2Nsb3NlZCB0LnRcbiAgbGV0IGJ5dGVzX3JlYWQgdCA9IHQudG90YWxfYnl0ZXNcblxuICBsZXQgYWxsX3VuaXRfdGhlbl9yZXR1cm4gbCByZXRfdmFsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IHJldHVybiByZXRfdmFsICgqIGF2b2lkIGRlZmVycmVkIG9wZXJhdGlvbnMgaW4gdGhlIGNvbW1vbiBjYXNlICopXG4gICAgfCBfIC0+XG4gICAgICBsZXQlbWFwICgpID0gRGVmZXJyZWQuYWxsX3VuaXQgbCBpblxuICAgICAgcmV0X3ZhbFxuICA7O1xuXG4gIGxldCByZWFkX2ZvcmV2ZXIgdCB+b25fbWVzc2FnZSB+b25fZW5kX29mX2JhdGNoID1cbiAgICBsZXQgZmluaXNoX2xvb3AgfmNvbnN1bWVkIH5uZWVkIH53YWl0X2JlZm9yZV9yZWFkaW5nID1cbiAgICAgIG9uX2VuZF9vZl9iYXRjaCAoKTtcbiAgICAgIGFsbF91bml0X3RoZW5fcmV0dXJuIHdhaXRfYmVmb3JlX3JlYWRpbmcgKGBDb25zdW1lZCAoY29uc3VtZWQsIGBOZWVkIG5lZWQpKVxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGJ1ZiB+cG9zIH5sZW4gfmNvbnN1bWVkIH53YWl0X2JlZm9yZV9yZWFkaW5nID1cbiAgICAgIGlmIGxlbiA8IEhlYWRlci5sZW5ndGhcbiAgICAgIHRoZW4gZmluaXNoX2xvb3AgfmNvbnN1bWVkIH5uZWVkOkhlYWRlci5sZW5ndGggfndhaXRfYmVmb3JlX3JlYWRpbmdcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcGF5bG9hZF9sZW4gPSBIZWFkZXIudW5zYWZlX2dldF9wYXlsb2FkX2xlbmd0aCBidWYgfnBvcyBpblxuICAgICAgICBsZXQgdG90YWxfbGVuID0gSGVhZGVyLmxlbmd0aCArIHBheWxvYWRfbGVuIGluXG4gICAgICAgIFdpdGhfbGltaXQuY2hlY2tfbWVzc2FnZV9zaXplIHQgfnBheWxvYWRfbGVuO1xuICAgICAgICBpZiBsZW4gPCB0b3RhbF9sZW5cbiAgICAgICAgdGhlbiBmaW5pc2hfbG9vcCB+Y29uc3VtZWQgfm5lZWQ6dG90YWxfbGVuIH53YWl0X2JlZm9yZV9yZWFkaW5nXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBjb25zdW1lZCA9IGNvbnN1bWVkICsgdG90YWxfbGVuIGluXG4gICAgICAgICAgaW5jcl90b3RhbF9ieXRlcyB0IHBheWxvYWRfbGVuO1xuICAgICAgICAgIGxldCByZXN1bHQgOiBfIEhhbmRsZXJfcmVzdWx0LnQgPVxuICAgICAgICAgICAgb25fbWVzc2FnZSBidWYgfnBvczoocG9zICsgSGVhZGVyLmxlbmd0aCkgfmxlbjpwYXlsb2FkX2xlblxuICAgICAgICAgIGluXG4gICAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IFN0b3AgeCAtPlxuICAgICAgICAgICAgYWxsX3VuaXRfdGhlbl9yZXR1cm4gd2FpdF9iZWZvcmVfcmVhZGluZyAoYFN0b3BfY29uc3VtZWQgKHgsIGNvbnN1bWVkKSlcbiAgICAgICAgICB8IENvbnRpbnVlIC0+XG4gICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgIGJ1ZlxuICAgICAgICAgICAgICB+cG9zOihwb3MgKyB0b3RhbF9sZW4pXG4gICAgICAgICAgICAgIH5sZW46KGxlbiAtIHRvdGFsX2xlbilcbiAgICAgICAgICAgICAgfmNvbnN1bWVkXG4gICAgICAgICAgICAgIH53YWl0X2JlZm9yZV9yZWFkaW5nXG4gICAgICAgICAgfCBXYWl0IGQgLT5cbiAgICAgICAgICAgIGxldCB3YWl0X2JlZm9yZV9yZWFkaW5nID1cbiAgICAgICAgICAgICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCBkXG4gICAgICAgICAgICAgIHRoZW4gd2FpdF9iZWZvcmVfcmVhZGluZ1xuICAgICAgICAgICAgICBlbHNlIGQgOjogd2FpdF9iZWZvcmVfcmVhZGluZ1xuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgYnVmXG4gICAgICAgICAgICAgIH5wb3M6KHBvcyArIHRvdGFsX2xlbilcbiAgICAgICAgICAgICAgfmxlbjoobGVuIC0gdG90YWxfbGVuKVxuICAgICAgICAgICAgICB+Y29uc3VtZWRcbiAgICAgICAgICAgICAgfndhaXRfYmVmb3JlX3JlYWRpbmcpKVxuICAgIGluXG4gICAgbGV0IGhhbmRsZV9jaHVuayBidWYgfnBvcyB+bGVuID1cbiAgICAgIGxvb3AgYnVmIH5wb3MgfmxlbiB+Y29uc3VtZWQ6MCB+d2FpdF9iZWZvcmVfcmVhZGluZzpbXVxuICAgIGluXG4gICAgbWF0Y2glbWFwIFJlYWRlci5yZWFkX29uZV9jaHVua19hdF9hX3RpbWUgdC50IH5oYW5kbGVfY2h1bmsgd2l0aFxuICAgIHwgYEVvZiB8IGBFb2Zfd2l0aF91bmNvbnN1bWVkX2RhdGEgXyAtPiBFcnJvciBgRW9mXG4gICAgfCBgU3RvcHBlZCB4IC0+IE9rIHhcbiAgOztcbmVuZFxuXG5tb2R1bGUgVW5peF93cml0ZXIgPSBzdHJ1Y3RcbiAgb3BlbiBXaXRoX2xpbWl0XG5cbiAgdHlwZSB0ID0gV3JpdGVyLnQgV2l0aF9saW1pdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSB+d3JpdGVyIH5tYXhfbWVzc2FnZV9zaXplID1cbiAgICAoKiBQcmV2ZW50IGV4Y2VwdGlvbnMgaW4gdGhlIHdyaXRlciB3aGVuIHRoZSBvdGhlciBzaWRlIGRpc2Nvbm5lY3RzLiBOb3RlIHRoYXQgXCJzdGFsZVxuICAgICAgIGRhdGEgaW4gYnVmZmVyXCIgZXhjZXB0aW9ucyBhcmUgbm90IGFuIGlzc3VlIHdoZW4gdGhlIGNvbnN1bWVyIGxlYXZlcywgc2luY2VcbiAgICAgICBbUnBjX2tlcm5lbC5Db25uZWN0aW9uXSB0YWtlcyBjYXJlIG9mIGNsb3NpbmcgdGhlIHRyYW5zcG9ydCB3aGVuIHRoZSBjb25zdW1lclxuICAgICAgIGxlYXZlcy4gKilcbiAgICBXcml0ZXIuc2V0X3JhaXNlX3doZW5fY29uc3VtZXJfbGVhdmVzIHdyaXRlciBmYWxzZTtcbiAgICBXaXRoX2xpbWl0LmNyZWF0ZSB3cml0ZXIgfm1heF9tZXNzYWdlX3NpemVcbiAgOztcblxuICBsZXQgY2xvc2UgdCA9IFdyaXRlci5jbG9zZSB0LnRcbiAgbGV0IGlzX2Nsb3NlZCB0ID0gV3JpdGVyLmlzX2Nsb3NlZCB0LnRcbiAgbGV0IG1vbml0b3IgdCA9IFdyaXRlci5tb25pdG9yIHQudFxuICBsZXQgYnl0ZXNfdG9fd3JpdGUgdCA9IFdyaXRlci5ieXRlc190b193cml0ZSB0LnRcbiAgbGV0IGJ5dGVzX3dyaXR0ZW4gdCA9IHQudG90YWxfYnl0ZXNcbiAgbGV0IHN0b3BwZWQgdCA9IERlZmVycmVkLmFueSBbIFdyaXRlci5jbG9zZV9zdGFydGVkIHQudDsgV3JpdGVyLmNvbnN1bWVyX2xlZnQgdC50IF1cbiAgbGV0IGZsdXNoZWQgdCA9IFdyaXRlci5mbHVzaGVkIHQudFxuICBsZXQgcmVhZHlfdG9fd3JpdGUgPSBmbHVzaGVkXG5cbiAgbGV0IGJpbl93cml0ZV9wYXlsb2FkX2xlbmd0aCBidWYgfnBvcyB4ID1cbiAgICBIZWFkZXIudW5zYWZlX3NldF9wYXlsb2FkX2xlbmd0aCBidWYgfnBvcyB4O1xuICAgIHBvcyArIEhlYWRlci5sZW5ndGhcbiAgOztcblxuICBsZXQgc2VuZF9iaW5fcHJvdF9pbnRlcm5hbCB0IChiaW5fd3JpdGVyIDogXyBCaW5fcHJvdC5UeXBlX2NsYXNzLndyaXRlcikgeCB+Zm9sbG93dXBfbGVuXG4gICAgOiBfIFNlbmRfcmVzdWx0LnRcbiAgICA9XG4gICAgaWYgbm90IChXcml0ZXIuaXNfY2xvc2VkIHQudClcbiAgICB0aGVuIChcbiAgICAgIGxldCBkYXRhX2xlbiA9IGJpbl93cml0ZXIuc2l6ZSB4IGluXG4gICAgICBsZXQgcGF5bG9hZF9sZW4gPSBkYXRhX2xlbiArIGZvbGxvd3VwX2xlbiBpblxuICAgICAgaWYgbWVzc2FnZV9zaXplX29rIHQgfnBheWxvYWRfbGVuXG4gICAgICB0aGVuIChcbiAgICAgICAgaW5jcl90b3RhbF9ieXRlcyB0IHBheWxvYWRfbGVuO1xuICAgICAgICBXcml0ZXIud3JpdGVfYmluX3Byb3Rfbm9fc2l6ZV9oZWFkZXJcbiAgICAgICAgICB0LnRcbiAgICAgICAgICB+c2l6ZTpIZWFkZXIubGVuZ3RoXG4gICAgICAgICAgYmluX3dyaXRlX3BheWxvYWRfbGVuZ3RoXG4gICAgICAgICAgcGF5bG9hZF9sZW47XG4gICAgICAgIFdyaXRlci53cml0ZV9iaW5fcHJvdF9ub19zaXplX2hlYWRlciB0LnQgfnNpemU6ZGF0YV9sZW4gYmluX3dyaXRlci53cml0ZSB4O1xuICAgICAgICBTZW50IHsgcmVzdWx0ID0gKCk7IGJ5dGVzID0gcGF5bG9hZF9sZW4gfSlcbiAgICAgIGVsc2UgTWVzc2FnZV90b29fYmlnIHsgc2l6ZSA9IHBheWxvYWRfbGVuOyBtYXhfbWVzc2FnZV9zaXplID0gdC5tYXhfbWVzc2FnZV9zaXplIH0pXG4gICAgZWxzZSBDbG9zZWRcbiAgOztcblxuICBsZXQgc2VuZF9iaW5fcHJvdCB0IGJpbl93cml0ZXIgeCA9IHNlbmRfYmluX3Byb3RfaW50ZXJuYWwgdCBiaW5fd3JpdGVyIHggfmZvbGxvd3VwX2xlbjowXG5cbiAgbGV0IHNlbmRfYmluX3Byb3RfYW5kX2JpZ3N0cmluZyB0IGJpbl93cml0ZXIgeCB+YnVmIH5wb3MgfmxlbiA6IF8gU2VuZF9yZXN1bHQudCA9XG4gICAgbWF0Y2ggc2VuZF9iaW5fcHJvdF9pbnRlcm5hbCB0IGJpbl93cml0ZXIgeCB+Zm9sbG93dXBfbGVuOmxlbiB3aXRoXG4gICAgfCBTZW50IHsgcmVzdWx0ID0gKCk7IGJ5dGVzID0gKF8gOiBpbnQpIH0gYXMgcmVzdWx0IC0+XG4gICAgICBXcml0ZXIud3JpdGVfYmlnc3RyaW5nIHQudCBidWYgfnBvcyB+bGVuO1xuICAgICAgcmVzdWx0XG4gICAgfCBlcnJvciAtPiBlcnJvclxuICA7O1xuXG4gIGxldCBzZW5kX2Jpbl9wcm90X2FuZF9iaWdzdHJpbmdfbm9uX2NvcHlpbmcgdCBiaW5fd3JpdGVyIHggfmJ1ZiB+cG9zIH5sZW5cbiAgICA6IF8gU2VuZF9yZXN1bHQudFxuICAgID1cbiAgICBtYXRjaCBzZW5kX2Jpbl9wcm90X2ludGVybmFsIHQgYmluX3dyaXRlciB4IH5mb2xsb3d1cF9sZW46bGVuIHdpdGhcbiAgICB8IFNlbnQgeyByZXN1bHQgPSAoKTsgYnl0ZXMgfSAtPlxuICAgICAgV3JpdGVyLnNjaGVkdWxlX2JpZ3N0cmluZyB0LnQgYnVmIH5wb3MgfmxlbjtcbiAgICAgIFNlbnRcbiAgICAgICAgeyByZXN1bHQgPSBXcml0ZXIuZmx1c2hlZCB0LnRcbiAgICAgICAgOyBieXRlcyAoKiBUaGUgcmVzcG9uc2UgZnJvbSBbc2VuZF9iaW5fcHJvdF9pbnRlcm5hbF0gaW5jbHVkZXMgW2ZvbGxvd3VwX2xlbl0gKilcbiAgICAgICAgfVxuICAgIHwgKENsb3NlZCB8IE1lc3NhZ2VfdG9vX2JpZyBfKSBhcyByIC0+IHJcbiAgOztcbmVuZFxuXG5tb2R1bGUgUmVhZGVyID0gc3RydWN0XG4gIGluY2x1ZGUgS2VybmVsX3RyYW5zcG9ydC5SZWFkZXJcblxuICBsZXQgb2ZfcmVhZGVyID9tYXhfbWVzc2FnZV9zaXplIHJlYWRlciA9XG4gICAgcGFjayAobW9kdWxlIFVuaXhfcmVhZGVyKSAoVW5peF9yZWFkZXIuY3JlYXRlIH5yZWFkZXIgfm1heF9tZXNzYWdlX3NpemUpXG4gIDs7XG5lbmRcblxubW9kdWxlIFdyaXRlciA9IHN0cnVjdFxuICBpbmNsdWRlIEtlcm5lbF90cmFuc3BvcnQuV3JpdGVyXG5cbiAgbGV0IG9mX3dyaXRlciA/bWF4X21lc3NhZ2Vfc2l6ZSB3cml0ZXIgPVxuICAgIHBhY2sgKG1vZHVsZSBVbml4X3dyaXRlcikgKFVuaXhfd3JpdGVyLmNyZWF0ZSB+d3JpdGVyIH5tYXhfbWVzc2FnZV9zaXplKVxuICA7O1xuZW5kXG5cbnR5cGUgdCA9IEtlcm5lbF90cmFuc3BvcnQudCA9XG4gIHsgcmVhZGVyIDogUmVhZGVyLnRcbiAgOyB3cml0ZXIgOiBXcml0ZXIudFxuICB9XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgY2xvc2UgPSBLZXJuZWxfdHJhbnNwb3J0LmNsb3NlXG5cbmxldCBvZl9yZWFkZXJfd3JpdGVyID9tYXhfbWVzc2FnZV9zaXplIHJlYWRlciB3cml0ZXIgPVxuICB7IHJlYWRlciA9IFJlYWRlci5vZl9yZWFkZXIgP21heF9tZXNzYWdlX3NpemUgcmVhZGVyXG4gIDsgd3JpdGVyID0gV3JpdGVyLm9mX3dyaXRlciA/bWF4X21lc3NhZ2Vfc2l6ZSB3cml0ZXJcbiAgfVxuOztcblxubGV0IG9mX2ZkID9idWZmZXJfYWdlX2xpbWl0ID9yZWFkZXJfYnVmZmVyX3NpemUgP3dyaXRlcl9idWZmZXJfc2l6ZSB+bWF4X21lc3NhZ2Vfc2l6ZSBmZCA9XG4gIG9mX3JlYWRlcl93cml0ZXJcbiAgICB+bWF4X21lc3NhZ2Vfc2l6ZVxuICAgIChBc3luY191bml4LlJlYWRlci5jcmVhdGUgP2J1Zl9sZW46cmVhZGVyX2J1ZmZlcl9zaXplIGZkKVxuICAgIChBc3luY191bml4LldyaXRlci5jcmVhdGUgP2J1Zl9sZW46d3JpdGVyX2J1ZmZlcl9zaXplID9idWZmZXJfYWdlX2xpbWl0IGZkKVxuOztcblxubW9kdWxlIFRjcCA9IHN0cnVjdFxuICBsZXQgZGVmYXVsdF90cmFuc3BvcnRfbWFrZXIgZmQgfm1heF9tZXNzYWdlX3NpemUgPSBvZl9mZCBmZCB+bWF4X21lc3NhZ2Vfc2l6ZVxuXG4gIGxldCBtYWtlX3NlcnZlX2Z1bmNfd2l0aF9mZFxuICAgIHRjcF9jcmVhdG9yXG4gICAgfndoZXJlX3RvX2xpc3RlblxuICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICA/YmFja2xvZ1xuICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgP3RpbWVfc291cmNlXG4gICAgP21heF9tZXNzYWdlX3NpemU6cHJvcG9zZWRfbWF4XG4gICAgPyhtYWtlX3RyYW5zcG9ydCA9IGRlZmF1bHRfdHJhbnNwb3J0X21ha2VyKVxuICAgID8oYXV0aCA9IGZ1biBfIC0+IHRydWUpXG4gICAgPyhvbl9oYW5kbGVyX2Vycm9yID0gYElnbm9yZSlcbiAgICBoYW5kbGVfdHJhbnNwb3J0XG4gICAgPVxuICAgIHRjcF9jcmVhdG9yXG4gICAgICA/bWF4X2Nvbm5lY3Rpb25zXG4gICAgICA/bWF4X2FjY2VwdHNfcGVyX2JhdGNoOk5vbmVcbiAgICAgID9iYWNrbG9nXG4gICAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgICAgP3NvY2tldDpOb25lXG4gICAgICA/dGltZV9zb3VyY2VcbiAgICAgIH5vbl9oYW5kbGVyX2Vycm9yXG4gICAgICB3aGVyZV90b19saXN0ZW5cbiAgICAgIChmdW4gY2xpZW50X2FkZHIgc29ja2V0IC0+XG4gICAgICBtYXRjaCBhdXRoIGNsaWVudF9hZGRyIHdpdGhcbiAgICAgIHwgZmFsc2UgLT4gcmV0dXJuICgpXG4gICAgICB8IHRydWUgLT5cbiAgICAgICAgbGV0IG1heF9tZXNzYWdlX3NpemUgPSBlZmZlY3RpdmVfbWF4X21lc3NhZ2Vfc2l6ZSB+cHJvcG9zZWRfbWF4IGluXG4gICAgICAgIGxldCBmZCA9IFNvY2tldC5mZCBzb2NrZXQgaW5cbiAgICAgICAgbGV0IHRyYW5zcG9ydCA9IG1ha2VfdHJhbnNwb3J0IH5tYXhfbWVzc2FnZV9zaXplIGZkIGluXG4gICAgICAgIGxldCViaW5kIHJlc3VsdCA9XG4gICAgICAgICAgTW9uaXRvci50cnlfd2l0aCB+cnVuOmBTY2hlZHVsZSB+cmVzdDpgUmFpc2UgKGZ1biAoKSAtPlxuICAgICAgICAgICAgaGFuZGxlX3RyYW5zcG9ydFxuICAgICAgICAgICAgICBmZFxuICAgICAgICAgICAgICB+Y2xpZW50X2FkZHJcbiAgICAgICAgICAgICAgfnNlcnZlcl9hZGRyOihTb2NrZXQuZ2V0c29ja25hbWUgc29ja2V0KVxuICAgICAgICAgICAgICB0cmFuc3BvcnQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCViaW5kICgpID0gY2xvc2UgdHJhbnNwb3J0IGluXG4gICAgICAgIChtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICAgfCBPayAoKSAtPiByZXR1cm4gKClcbiAgICAgICAgIHwgRXJyb3IgZXhuIC0+IHJhaXNlIGV4bikpXG4gIDs7XG5cbiAgbGV0IG1ha2Vfc2VydmVfZnVuY1xuICAgIHRjcF9jcmVhdG9yXG4gICAgfndoZXJlX3RvX2xpc3RlblxuICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICA/YmFja2xvZ1xuICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgP3RpbWVfc291cmNlXG4gICAgP21heF9tZXNzYWdlX3NpemVcbiAgICA/bWFrZV90cmFuc3BvcnRcbiAgICA/YXV0aFxuICAgID9vbl9oYW5kbGVyX2Vycm9yXG4gICAgaGFuZGxlX3RyYW5zcG9ydFxuICAgID1cbiAgICBtYWtlX3NlcnZlX2Z1bmNfd2l0aF9mZFxuICAgICAgdGNwX2NyZWF0b3JcbiAgICAgIH53aGVyZV90b19saXN0ZW5cbiAgICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICAgID9iYWNrbG9nXG4gICAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgICAgP3RpbWVfc291cmNlXG4gICAgICA/bWF4X21lc3NhZ2Vfc2l6ZVxuICAgICAgP21ha2VfdHJhbnNwb3J0XG4gICAgICA/YXV0aFxuICAgICAgP29uX2hhbmRsZXJfZXJyb3JcbiAgICAgIChmdW4gKF8gOiBGZC50KSB+Y2xpZW50X2FkZHIgfnNlcnZlcl9hZGRyIHRyYW5zcG9ydCAtPlxuICAgICAgaGFuZGxlX3RyYW5zcG9ydCB+Y2xpZW50X2FkZHIgfnNlcnZlcl9hZGRyIHRyYW5zcG9ydClcbiAgOztcblxuICAoKiBldGEtZXhwYW5kIFt3aGVyZV90b19saXN0ZW5dIHRvIGF2b2lkIHZhbHVlIHJlc3RyaWN0aW9uLiAqKVxuICBsZXQgc2VydmUgfndoZXJlX3RvX2xpc3RlbiA9IG1ha2Vfc2VydmVfZnVuYyBUY3AuU2VydmVyLmNyZWF0ZV9zb2NrIH53aGVyZV90b19saXN0ZW5cblxuICAoKiBldGEtZXhwYW5kIFt3aGVyZV90b19saXN0ZW5dIHRvIGF2b2lkIHZhbHVlIHJlc3RyaWN0aW9uLiAqKVxuICBsZXQgc2VydmVfaW5ldCB+d2hlcmVfdG9fbGlzdGVuID1cbiAgICBtYWtlX3NlcnZlX2Z1bmMgVGNwLlNlcnZlci5jcmVhdGVfc29ja19pbmV0IH53aGVyZV90b19saXN0ZW5cbiAgOztcblxuICBsZXQgc2VydmVfdW5peFxuICAgIH4od2hlcmVfdG9fbGlzdGVuIDogVGNwLldoZXJlX3RvX2xpc3Rlbi51bml4KVxuICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICA/YmFja2xvZ1xuICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgP3RpbWVfc291cmNlXG4gICAgP21heF9tZXNzYWdlX3NpemVcbiAgICA/bWFrZV90cmFuc3BvcnRcbiAgICA/YXV0aFxuICAgID9vbl9oYW5kbGVyX2Vycm9yXG4gICAgaGFuZGxlX3RyYW5zcG9ydFxuICAgID1cbiAgICBtYWtlX3NlcnZlX2Z1bmNfd2l0aF9mZFxuICAgICAgVGNwLlNlcnZlci5jcmVhdGVfc29ja1xuICAgICAgfndoZXJlX3RvX2xpc3RlblxuICAgICAgP21heF9jb25uZWN0aW9uc1xuICAgICAgP2JhY2tsb2dcbiAgICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgICA/dGltZV9zb3VyY2VcbiAgICAgID9tYXhfbWVzc2FnZV9zaXplXG4gICAgICA/bWFrZV90cmFuc3BvcnRcbiAgICAgID9hdXRoXG4gICAgICA/b25faGFuZGxlcl9lcnJvclxuICAgICAgKGZ1biBmZCB+Y2xpZW50X2FkZHIgfnNlcnZlcl9hZGRyIHRyYW5zcG9ydCAtPlxuICAgICAgbGV0IHBlZXJfY3JlZGVudGlhbHMgPVxuICAgICAgICBPcl9lcnJvci50cnlfd2l0aCAoZnVuICgpIC0+XG4gICAgICAgICAgKG9rX2V4biBMaW51eF9leHQucGVlcl9jcmVkZW50aWFscykgKEZkLmZpbGVfZGVzY3JfZXhuIGZkKSlcbiAgICAgICAgfD4gT3JfZXJyb3IudGFnIH50YWc6XCJFcnJvciBnZXR0aW5nIHBlZXIgY3JlZGVudGlhbHMgb2YgdW5peCBzb2NrZXRcIlxuICAgICAgICB8PiBva19leG5cbiAgICAgIGluXG4gICAgICBoYW5kbGVfdHJhbnNwb3J0IH5jbGllbnRfYWRkciB+c2VydmVyX2FkZHIgcGVlcl9jcmVkZW50aWFscyB0cmFuc3BvcnQpXG4gIDs7XG5cbiAgbGV0IGNvbm5lY3RcbiAgICA/bWF4X21lc3NhZ2Vfc2l6ZTpwcm9wb3NlZF9tYXhcbiAgICA/KG1ha2VfdHJhbnNwb3J0ID0gZGVmYXVsdF90cmFuc3BvcnRfbWFrZXIpXG4gICAgPyh0Y3BfY29ubmVjdF90aW1lb3V0ID1cbiAgICAgIEFzeW5jX3JwY19rZXJuZWwuQXN5bmNfcnBjX2tlcm5lbF9wcml2YXRlLmRlZmF1bHRfaGFuZHNoYWtlX3RpbWVvdXQpXG4gICAgd2hlcmVfdG9fY29ubmVjdFxuICAgID1cbiAgICBsZXQlYmluZCBzb2NrID1cbiAgICAgIE1vbml0b3IudHJ5X3dpdGggfnJ1bjpgU2NoZWR1bGUgfnJlc3Q6YExvZyAoZnVuICgpIC0+XG4gICAgICAgIFRjcC5jb25uZWN0X3NvY2tcbiAgICAgICAgICB+dGltZW91dDooVGltZV9ucy5TcGFuLnRvX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCB0Y3BfY29ubmVjdF90aW1lb3V0KVxuICAgICAgICAgIHdoZXJlX3RvX2Nvbm5lY3QpXG4gICAgaW5cbiAgICBtYXRjaCBzb2NrIHdpdGhcbiAgICB8IEVycm9yIF8gYXMgZXJyb3IgLT4gcmV0dXJuIGVycm9yXG4gICAgfCBPayBzb2NrIC0+XG4gICAgICAobWF0Y2ggU29ja2V0LmdldHBlZXJuYW1lIHNvY2sgd2l0aFxuICAgICAgIHwgZXhjZXB0aW9uIGV4bl9jb3VsZF9iZV9yYWlzZWRfaWZfdGhlX3NvY2tldF9pc19kaWNvbm5lY3RlZF9ub3cgLT5cbiAgICAgICAgIFNvY2tldC5zaHV0ZG93biBzb2NrIGBCb3RoO1xuICAgICAgICAgZG9uJ3Rfd2FpdF9mb3IgKFVuaXguY2xvc2UgKFNvY2tldC5mZCBzb2NrKSk7XG4gICAgICAgICByZXR1cm4gKEVycm9yIGV4bl9jb3VsZF9iZV9yYWlzZWRfaWZfdGhlX3NvY2tldF9pc19kaWNvbm5lY3RlZF9ub3cpXG4gICAgICAgfCBzb2NrX3BlZXJuYW1lIC0+XG4gICAgICAgICBsZXQgbWF4X21lc3NhZ2Vfc2l6ZSA9IGVmZmVjdGl2ZV9tYXhfbWVzc2FnZV9zaXplIH5wcm9wb3NlZF9tYXggaW5cbiAgICAgICAgIGxldCB0cmFuc3BvcnQgPSBtYWtlX3RyYW5zcG9ydCAoU29ja2V0LmZkIHNvY2spIH5tYXhfbWVzc2FnZV9zaXplIGluXG4gICAgICAgICByZXR1cm4gKE9rICh0cmFuc3BvcnQsIHNvY2tfcGVlcm5hbWUpKSlcbiAgOztcbmVuZFxuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxubW9kdWxlIFRyYW5zcG9ydCA9IFJwY190cmFuc3BvcnRcbm1vZHVsZSBMb3dfbGF0ZW5jeV90cmFuc3BvcnQgPSBScGNfdHJhbnNwb3J0X2xvd19sYXRlbmN5XG5tb2R1bGUgQW55ID0gUnBjX2tlcm5lbC5Bbnlcbm1vZHVsZSBEZXNjcmlwdGlvbiA9IFJwY19rZXJuZWwuRGVzY3JpcHRpb25cbm1vZHVsZSBIb3dfdG9fcmVjb2duaXNlX2Vycm9ycyA9IFJwY19rZXJuZWwuSG93X3RvX3JlY29nbmlzZV9lcnJvcnNcbm1vZHVsZSBJbXBsZW1lbnRhdGlvbiA9IFJwY19rZXJuZWwuSW1wbGVtZW50YXRpb25cbm1vZHVsZSBJbXBsZW1lbnRhdGlvbnMgPSBScGNfa2VybmVsLkltcGxlbWVudGF0aW9uc1xubW9kdWxlIE9uX2V4Y2VwdGlvbiA9IFJwY19rZXJuZWwuT25fZXhjZXB0aW9uXG5tb2R1bGUgT25lX3dheSA9IFJwY19rZXJuZWwuT25lX3dheVxubW9kdWxlIFBpcGVfcnBjID0gUnBjX2tlcm5lbC5QaXBlX3JwY1xubW9kdWxlIFJwYyA9IFJwY19rZXJuZWwuUnBjXG5tb2R1bGUgU3RhdGVfcnBjID0gUnBjX2tlcm5lbC5TdGF0ZV9ycGNcbm1vZHVsZSBQaXBlX2Nsb3NlX3JlYXNvbiA9IFJwY19rZXJuZWwuUGlwZV9jbG9zZV9yZWFzb25cblxubW9kdWxlIENvbm5lY3Rpb24gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBScGNfa2VybmVsLkNvbm5lY3Rpb25cblxuICBsZXQgY3JlYXRlXG4gICAgP2ltcGxlbWVudGF0aW9uc1xuICAgIH5jb25uZWN0aW9uX3N0YXRlXG4gICAgP21heF9tZXNzYWdlX3NpemVcbiAgICA/aGFuZHNoYWtlX3RpbWVvdXRcbiAgICA/aGVhcnRiZWF0X2NvbmZpZ1xuICAgID9kZXNjcmlwdGlvblxuICAgID9pZGVudGlmaWNhdGlvblxuICAgIHJlYWRlclxuICAgIHdyaXRlclxuICAgID1cbiAgICBjcmVhdGVcbiAgICAgID9pbXBsZW1lbnRhdGlvbnNcbiAgICAgIH5jb25uZWN0aW9uX3N0YXRlXG4gICAgICA/aGFuZHNoYWtlX3RpbWVvdXQ6XG4gICAgICAgIChPcHRpb24ubWFwIGhhbmRzaGFrZV90aW1lb3V0IH5mOlRpbWVfbnMuU3Bhbi5vZl9zcGFuX2Zsb2F0X3JvdW5kX25lYXJlc3QpXG4gICAgICA/aGVhcnRiZWF0X2NvbmZpZ1xuICAgICAgP2Rlc2NyaXB0aW9uXG4gICAgICA/aWRlbnRpZmljYXRpb25cbiAgICAgIChUcmFuc3BvcnQub2ZfcmVhZGVyX3dyaXRlciByZWFkZXIgd3JpdGVyID9tYXhfbWVzc2FnZV9zaXplKVxuICA7O1xuXG4gIGxldCBjb250YWluc19tYWdpY19wcmVmaXggcmVhZGVyID1cbiAgICBtYXRjaCVtYXBcbiAgICAgIERlZmVycmVkLk9yX2Vycm9yLnRyeV93aXRoIH5ydW46YFNjaGVkdWxlIH5yZXN0OmBMb2cgKGZ1biAoKSAtPlxuICAgICAgICBSZWFkZXIucGVla19iaW5fcHJvdCByZWFkZXIgY29udGFpbnNfbWFnaWNfcHJlZml4KVxuICAgIHdpdGhcbiAgICB8IEVycm9yIF8gfCBPayBgRW9mIC0+IGZhbHNlXG4gICAgfCBPayAoYE9rIGIpIC0+IGJcbiAgOztcblxuICBsZXQgd2l0aF9jbG9zZVxuICAgID9pbXBsZW1lbnRhdGlvbnNcbiAgICA/bWF4X21lc3NhZ2Vfc2l6ZVxuICAgID9oYW5kc2hha2VfdGltZW91dFxuICAgID9oZWFydGJlYXRfY29uZmlnXG4gICAgP2Rlc2NyaXB0aW9uXG4gICAgfmNvbm5lY3Rpb25fc3RhdGVcbiAgICByZWFkZXJcbiAgICB3cml0ZXJcbiAgICB+ZGlzcGF0Y2hfcXVlcmllc1xuICAgIH5vbl9oYW5kc2hha2VfZXJyb3JcbiAgICA9XG4gICAgd2l0aF9jbG9zZVxuICAgICAgP2ltcGxlbWVudGF0aW9uc1xuICAgICAgP2hhbmRzaGFrZV90aW1lb3V0OlxuICAgICAgICAoT3B0aW9uLm1hcCBoYW5kc2hha2VfdGltZW91dCB+ZjpUaW1lX25zLlNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0KVxuICAgICAgP2hlYXJ0YmVhdF9jb25maWdcbiAgICAgID9kZXNjcmlwdGlvblxuICAgICAgfmNvbm5lY3Rpb25fc3RhdGVcbiAgICAgIChUcmFuc3BvcnQub2ZfcmVhZGVyX3dyaXRlciByZWFkZXIgd3JpdGVyID9tYXhfbWVzc2FnZV9zaXplKVxuICAgICAgfmRpc3BhdGNoX3F1ZXJpZXNcbiAgICAgIH5vbl9oYW5kc2hha2VfZXJyb3JcbiAgOztcblxuICBsZXQgc2VydmVyX3dpdGhfY2xvc2VcbiAgICA/bWF4X21lc3NhZ2Vfc2l6ZVxuICAgID9oYW5kc2hha2VfdGltZW91dFxuICAgID9oZWFydGJlYXRfY29uZmlnXG4gICAgP2Rlc2NyaXB0aW9uXG4gICAgcmVhZGVyXG4gICAgd3JpdGVyXG4gICAgfmltcGxlbWVudGF0aW9uc1xuICAgIH5jb25uZWN0aW9uX3N0YXRlXG4gICAgfm9uX2hhbmRzaGFrZV9lcnJvclxuICAgID1cbiAgICBzZXJ2ZXJfd2l0aF9jbG9zZVxuICAgICAgP2hhbmRzaGFrZV90aW1lb3V0OlxuICAgICAgICAoT3B0aW9uLm1hcCBoYW5kc2hha2VfdGltZW91dCB+ZjpUaW1lX25zLlNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0KVxuICAgICAgP2hlYXJ0YmVhdF9jb25maWdcbiAgICAgID9kZXNjcmlwdGlvblxuICAgICAgKFRyYW5zcG9ydC5vZl9yZWFkZXJfd3JpdGVyIHJlYWRlciB3cml0ZXIgP21heF9tZXNzYWdlX3NpemUpXG4gICAgICB+aW1wbGVtZW50YXRpb25zXG4gICAgICB+Y29ubmVjdGlvbl9zdGF0ZVxuICAgICAgfm9uX2hhbmRzaGFrZV9lcnJvclxuICA7O1xuXG4gIGxldCBjb2xsZWN0X2Vycm9ycyAodHJhbnNwb3J0IDogVHJhbnNwb3J0LnQpIH5mID1cbiAgICBsZXQgbW9uaXRvciA9IFRyYW5zcG9ydC5Xcml0ZXIubW9uaXRvciB0cmFuc3BvcnQud3JpdGVyIGluXG4gICAgKCogZG9uJ3QgcHJvcGFnYXRlIGVycm9ycyB1cCwgd2UgaGFuZGxlIHRoZW0gaGVyZSAqKVxuICAgIGlnbm9yZSAoTW9uaXRvci5kZXRhY2hfYW5kX2dldF9lcnJvcl9zdHJlYW0gbW9uaXRvcik7XG4gICAgY2hvb3NlXG4gICAgICBbIGNob2ljZSAoTW9uaXRvci5nZXRfbmV4dF9lcnJvciBtb25pdG9yKSAoZnVuIGUgLT4gRXJyb3IgZSlcbiAgICAgIDsgY2hvaWNlXG4gICAgICAgICAgKE1vbml0b3IudHJ5X3dpdGhcbiAgICAgICAgICAgICB+cnVuOmBTY2hlZHVsZVxuICAgICAgICAgICAgIH5yZXN0OmBMb2dcbiAgICAgICAgICAgICB+bmFtZTpcIlJwYy5Db25uZWN0aW9uLmNvbGxlY3RfZXJyb3JzXCJcbiAgICAgICAgICAgICBmKVxuICAgICAgICAgIEZuLmlkXG4gICAgICBdXG4gIDs7XG5cbiAgdHlwZSB0cmFuc3BvcnRfbWFrZXIgPSBGZC50IC0+IG1heF9tZXNzYWdlX3NpemU6aW50IC0+IFRyYW5zcG9ydC50XG5cbiAgbGV0IHNlcnZlX3dpdGhfdHJhbnNwb3J0XG4gICAgP2lkZW50aWZpY2F0aW9uXG4gICAgdHJhbnNwb3J0XG4gICAgfmhhbmRzaGFrZV90aW1lb3V0XG4gICAgfmhlYXJ0YmVhdF9jb25maWdcbiAgICB+aW1wbGVtZW50YXRpb25zXG4gICAgfmRlc2NyaXB0aW9uXG4gICAgfmNvbm5lY3Rpb25fc3RhdGVcbiAgICB+b25faGFuZHNoYWtlX2Vycm9yXG4gICAgfmNsaWVudF9hZGRyXG4gICAgPVxuICAgIGxldCViaW5kIHJlcyA9XG4gICAgICBjb2xsZWN0X2Vycm9ycyB0cmFuc3BvcnQgfmY6KGZ1biAoKSAtPlxuICAgICAgICBtYXRjaCViaW5kXG4gICAgICAgICAgUnBjX2tlcm5lbC5Db25uZWN0aW9uLmNyZWF0ZVxuICAgICAgICAgICAgP2hhbmRzaGFrZV90aW1lb3V0OlxuICAgICAgICAgICAgICAoT3B0aW9uLm1hcCBoYW5kc2hha2VfdGltZW91dCB+ZjpUaW1lX25zLlNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0KVxuICAgICAgICAgICAgP2hlYXJ0YmVhdF9jb25maWdcbiAgICAgICAgICAgID9pZGVudGlmaWNhdGlvblxuICAgICAgICAgICAgfmltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgfmRlc2NyaXB0aW9uXG4gICAgICAgICAgICB+Y29ubmVjdGlvbl9zdGF0ZVxuICAgICAgICAgICAgdHJhbnNwb3J0XG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBPayB0IC0+IGNsb3NlX2ZpbmlzaGVkIHRcbiAgICAgICAgfCBFcnJvciBoYW5kc2hha2VfZXJyb3IgLT5cbiAgICAgICAgICAobWF0Y2ggb25faGFuZHNoYWtlX2Vycm9yIHdpdGhcbiAgICAgICAgICAgfCBgQ2FsbCBmIC0+IGYgY2xpZW50X2FkZHIgaGFuZHNoYWtlX2Vycm9yXG4gICAgICAgICAgIHwgYFJhaXNlIC0+IHJhaXNlIGhhbmRzaGFrZV9lcnJvclxuICAgICAgICAgICB8IGBJZ25vcmUgLT4gKCkpO1xuICAgICAgICAgIERlZmVycmVkLnVuaXQpXG4gICAgaW5cbiAgICBsZXQlbWFwICgpID0gVHJhbnNwb3J0LmNsb3NlIHRyYW5zcG9ydCBpblxuICAgIFJlc3VsdC5va19leG4gcmVzXG4gIDs7XG5cbiAgbGV0IGNvbm5lY3Rpb25fZGVzY3JpcHRpb24gP2Rlc2NyaXB0aW9uIH5zZXJ2ZXJfYWRkciB+Y2xpZW50X2FkZHIgKCkgPVxuICAgIGxldCBzZXJ2ZXJfYWRkciA9IChzZXJ2ZXJfYWRkciA6PiBTb2NrZXQuQWRkcmVzcy50KSBpblxuICAgIGxldCBjbGllbnRfYWRkciA9IChjbGllbnRfYWRkciA6PiBTb2NrZXQuQWRkcmVzcy50KSBpblxuICAgIGxldCBjb25uZWN0aW9uX2Rlc2NyaXB0aW9uID1cbiAgICAgIEluZm8uY3JlYXRlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJUQ1Agc2VydmVyXCIgKHNlcnZlcl9hZGRyIDogU29ja2V0LkFkZHJlc3MudCkgKGNsaWVudF9hZGRyIDogU29ja2V0LkFkZHJlc3MudCldXG4gICAgaW5cbiAgICBtYXRjaCBkZXNjcmlwdGlvbiB3aXRoXG4gICAgfCBOb25lIC0+IGNvbm5lY3Rpb25fZGVzY3JpcHRpb25cbiAgICB8IFNvbWUgZGVzY3JpcHRpb24gLT4gSW5mby5vZl9saXN0IFsgZGVzY3JpcHRpb247IGNvbm5lY3Rpb25fZGVzY3JpcHRpb24gXVxuICA7O1xuXG4gIGxldCBkZWZhdWx0X29uX2hhbmRzaGFrZV9lcnJvciA9IGBJZ25vcmVcblxuICBsZXQgbWFrZV9zZXJ2ZV9mdW5jXG4gICAgc2VydmVfd2l0aF90cmFuc3BvcnRfaGFuZGxlclxuICAgIH5pbXBsZW1lbnRhdGlvbnNcbiAgICB+aW5pdGlhbF9jb25uZWN0aW9uX3N0YXRlXG4gICAgfndoZXJlX3RvX2xpc3RlblxuICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICA/YmFja2xvZ1xuICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgP3RpbWVfc291cmNlXG4gICAgP21heF9tZXNzYWdlX3NpemVcbiAgICA/bWFrZV90cmFuc3BvcnRcbiAgICA/aGFuZHNoYWtlX3RpbWVvdXRcbiAgICA/aGVhcnRiZWF0X2NvbmZpZ1xuICAgID9hdXRoXG4gICAgPyhvbl9oYW5kc2hha2VfZXJyb3IgPSBkZWZhdWx0X29uX2hhbmRzaGFrZV9lcnJvcilcbiAgICA/b25faGFuZGxlcl9lcnJvclxuICAgID9kZXNjcmlwdGlvblxuICAgID9pZGVudGlmaWNhdGlvblxuICAgICgpXG4gICAgPVxuICAgIHNlcnZlX3dpdGhfdHJhbnNwb3J0X2hhbmRsZXJcbiAgICAgIH53aGVyZV90b19saXN0ZW5cbiAgICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICAgID9iYWNrbG9nXG4gICAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgICAgP3RpbWVfc291cmNlXG4gICAgICA/bWF4X21lc3NhZ2Vfc2l6ZVxuICAgICAgP21ha2VfdHJhbnNwb3J0XG4gICAgICA/YXV0aFxuICAgICAgP29uX2hhbmRsZXJfZXJyb3JcbiAgICAgIChmdW4gfmNsaWVudF9hZGRyIH5zZXJ2ZXJfYWRkciB0cmFuc3BvcnQgLT5cbiAgICAgIHNlcnZlX3dpdGhfdHJhbnNwb3J0XG4gICAgICAgIH5oYW5kc2hha2VfdGltZW91dFxuICAgICAgICB+aGVhcnRiZWF0X2NvbmZpZ1xuICAgICAgICB+aW1wbGVtZW50YXRpb25zXG4gICAgICAgIH5kZXNjcmlwdGlvbjooY29ubmVjdGlvbl9kZXNjcmlwdGlvbiA/ZGVzY3JpcHRpb24gfnNlcnZlcl9hZGRyIH5jbGllbnRfYWRkciAoKSlcbiAgICAgICAgfmNvbm5lY3Rpb25fc3RhdGU6KGZ1biBjb25uIC0+IGluaXRpYWxfY29ubmVjdGlvbl9zdGF0ZSBjbGllbnRfYWRkciBjb25uKVxuICAgICAgICB+b25faGFuZHNoYWtlX2Vycm9yXG4gICAgICAgIH5jbGllbnRfYWRkclxuICAgICAgICA/aWRlbnRpZmljYXRpb25cbiAgICAgICAgdHJhbnNwb3J0KVxuICA7O1xuXG4gICgqIGV0YS1leHBhbmQgW2ltcGxlbWVudGF0aW9uc10gdG8gYXZvaWQgdmFsdWUgcmVzdHJpY3Rpb24uICopXG4gIGxldCBzZXJ2ZSB+aW1wbGVtZW50YXRpb25zID0gbWFrZV9zZXJ2ZV9mdW5jIFJwY190cmFuc3BvcnQuVGNwLnNlcnZlIH5pbXBsZW1lbnRhdGlvbnNcblxuICAoKiBldGEtZXhwYW5kIFtpbXBsZW1lbnRhdGlvbnNdIHRvIGF2b2lkIHZhbHVlIHJlc3RyaWN0aW9uLiAqKVxuICBsZXQgc2VydmVfaW5ldCB+aW1wbGVtZW50YXRpb25zID1cbiAgICBtYWtlX3NlcnZlX2Z1bmMgUnBjX3RyYW5zcG9ydC5UY3Auc2VydmVfaW5ldCB+aW1wbGVtZW50YXRpb25zXG4gIDs7XG5cbiAgbGV0IHNlcnZlX3VuaXhcbiAgICB+aW1wbGVtZW50YXRpb25zXG4gICAgfmluaXRpYWxfY29ubmVjdGlvbl9zdGF0ZVxuICAgIH53aGVyZV90b19saXN0ZW5cbiAgICA/bWF4X2Nvbm5lY3Rpb25zXG4gICAgP2JhY2tsb2dcbiAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgID90aW1lX3NvdXJjZVxuICAgID9tYXhfbWVzc2FnZV9zaXplXG4gICAgP21ha2VfdHJhbnNwb3J0XG4gICAgP2hhbmRzaGFrZV90aW1lb3V0XG4gICAgP2hlYXJ0YmVhdF9jb25maWdcbiAgICA/YXV0aFxuICAgID8ob25faGFuZHNoYWtlX2Vycm9yID0gZGVmYXVsdF9vbl9oYW5kc2hha2VfZXJyb3IpXG4gICAgP29uX2hhbmRsZXJfZXJyb3JcbiAgICA/ZGVzY3JpcHRpb25cbiAgICA/aWRlbnRpZmljYXRpb25cbiAgICAoKVxuICAgID1cbiAgICBScGNfdHJhbnNwb3J0LlRjcC5zZXJ2ZV91bml4XG4gICAgICB+d2hlcmVfdG9fbGlzdGVuXG4gICAgICA/bWF4X2Nvbm5lY3Rpb25zXG4gICAgICA/YmFja2xvZ1xuICAgICAgP2Ryb3BfaW5jb21pbmdfY29ubmVjdGlvbnNcbiAgICAgID90aW1lX3NvdXJjZVxuICAgICAgP21heF9tZXNzYWdlX3NpemVcbiAgICAgID9tYWtlX3RyYW5zcG9ydFxuICAgICAgP2F1dGhcbiAgICAgID9vbl9oYW5kbGVyX2Vycm9yXG4gICAgICAoZnVuIH5jbGllbnRfYWRkciB+c2VydmVyX2FkZHIgcGVlcl9jcmVkcyB0cmFuc3BvcnQgLT5cbiAgICAgIHNlcnZlX3dpdGhfdHJhbnNwb3J0XG4gICAgICAgIH5oYW5kc2hha2VfdGltZW91dFxuICAgICAgICB+aGVhcnRiZWF0X2NvbmZpZ1xuICAgICAgICB+aW1wbGVtZW50YXRpb25zXG4gICAgICAgIH5kZXNjcmlwdGlvbjooY29ubmVjdGlvbl9kZXNjcmlwdGlvbiA/ZGVzY3JpcHRpb24gfnNlcnZlcl9hZGRyIH5jbGllbnRfYWRkciAoKSlcbiAgICAgICAgfmNvbm5lY3Rpb25fc3RhdGU6KGZ1biBjb25uIC0+XG4gICAgICAgICAgaW5pdGlhbF9jb25uZWN0aW9uX3N0YXRlIGNsaWVudF9hZGRyIHBlZXJfY3JlZHMgY29ubilcbiAgICAgICAgfm9uX2hhbmRzaGFrZV9lcnJvclxuICAgICAgICB+Y2xpZW50X2FkZHJcbiAgICAgICAgP2lkZW50aWZpY2F0aW9uXG4gICAgICAgIHRyYW5zcG9ydClcbiAgOztcblxuICBsZXQgZGVmYXVsdF9oYW5kc2hha2VfdGltZW91dF9mbG9hdCA9XG4gICAgVGltZV9ucy5TcGFuLnRvX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdFxuICAgICAgQXN5bmNfcnBjX2tlcm5lbC5Bc3luY19ycGNfa2VybmVsX3ByaXZhdGUuZGVmYXVsdF9oYW5kc2hha2VfdGltZW91dFxuICA7O1xuXG4gIGxldCBjbGllbnQnXG4gICAgP2ltcGxlbWVudGF0aW9uc1xuICAgID9tYXhfbWVzc2FnZV9zaXplXG4gICAgP21ha2VfdHJhbnNwb3J0XG4gICAgP2hhbmRzaGFrZV90aW1lb3V0OihoYW5kc2hha2VfdGltZW91dF9mbG9hdCA9IGRlZmF1bHRfaGFuZHNoYWtlX3RpbWVvdXRfZmxvYXQpXG4gICAgP2hlYXJ0YmVhdF9jb25maWdcbiAgICA/ZGVzY3JpcHRpb25cbiAgICA/aWRlbnRpZmljYXRpb25cbiAgICB3aGVyZV90b19jb25uZWN0XG4gICAgPVxuICAgIGxldCBoYW5kc2hha2VfdGltZW91dCA9XG4gICAgICBUaW1lX25zLlNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0IGhhbmRzaGFrZV90aW1lb3V0X2Zsb2F0XG4gICAgaW5cbiAgICBsZXQgZmluaXNoX2hhbmRzaGFrZV9ieSA9IFRpbWVfbnMuYWRkIChUaW1lX25zLm5vdyAoKSkgaGFuZHNoYWtlX3RpbWVvdXQgaW5cbiAgICBtYXRjaCViaW5kXG4gICAgICBScGNfdHJhbnNwb3J0LlRjcC5jb25uZWN0XG4gICAgICAgID9tYXhfbWVzc2FnZV9zaXplXG4gICAgICAgID9tYWtlX3RyYW5zcG9ydFxuICAgICAgICB+dGNwX2Nvbm5lY3RfdGltZW91dDpoYW5kc2hha2VfdGltZW91dFxuICAgICAgICB3aGVyZV90b19jb25uZWN0XG4gICAgd2l0aFxuICAgIHwgRXJyb3IgXyBhcyBlcnJvciAtPiByZXR1cm4gZXJyb3JcbiAgICB8IE9rICh0cmFuc3BvcnQsIHNvY2tfcGVlcm5hbWUpIC0+XG4gICAgICBsZXQgZGVzY3JpcHRpb24gPVxuICAgICAgICBtYXRjaCBkZXNjcmlwdGlvbiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIEluZm8uY3JlYXRlXG4gICAgICAgICAgICBcIkNsaWVudCBjb25uZWN0ZWQgdmlhIFRDUFwiXG4gICAgICAgICAgICB3aGVyZV90b19jb25uZWN0XG4gICAgICAgICAgICBbJXNleHBfb2Y6IF8gVGNwLldoZXJlX3RvX2Nvbm5lY3QudF1cbiAgICAgICAgfCBTb21lIGRlc2MgLT5cbiAgICAgICAgICBJbmZvLm9mX2xpc3RcbiAgICAgICAgICAgIFsgZGVzY1xuICAgICAgICAgICAgOyBJbmZvLmNyZWF0ZV9zXG4gICAgICAgICAgICAgICAgWyVtZXNzYWdlIFwidmlhIFRDUFwiIH5fOih3aGVyZV90b19jb25uZWN0IDogXyBUY3AuV2hlcmVfdG9fY29ubmVjdC50KV1cbiAgICAgICAgICAgIF1cbiAgICAgIGluXG4gICAgICBsZXQgaGFuZHNoYWtlX3RpbWVvdXQgPSBUaW1lX25zLmRpZmYgZmluaXNoX2hhbmRzaGFrZV9ieSAoVGltZV9ucy5ub3cgKCkpIGluXG4gICAgICBsZXQlYmluZCBycGNfY29ubmVjdGlvbiA9XG4gICAgICAgIG1hdGNoIGltcGxlbWVudGF0aW9ucyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGxldCAoVCB7IGNvbm5lY3Rpb25fc3RhdGU7IGltcGxlbWVudGF0aW9ucyB9KSA9XG4gICAgICAgICAgICBDbGllbnRfaW1wbGVtZW50YXRpb25zLm51bGwgKClcbiAgICAgICAgICBpblxuICAgICAgICAgIFJwY19rZXJuZWwuQ29ubmVjdGlvbi5jcmVhdGVcbiAgICAgICAgICAgIHRyYW5zcG9ydFxuICAgICAgICAgICAgfmhhbmRzaGFrZV90aW1lb3V0XG4gICAgICAgICAgICA/aGVhcnRiZWF0X2NvbmZpZ1xuICAgICAgICAgICAgP2lkZW50aWZpY2F0aW9uXG4gICAgICAgICAgICB+aW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgICB+ZGVzY3JpcHRpb25cbiAgICAgICAgICAgIH5jb25uZWN0aW9uX3N0YXRlXG4gICAgICAgIHwgU29tZSAoQ2xpZW50X2ltcGxlbWVudGF0aW9ucy5UIHsgY29ubmVjdGlvbl9zdGF0ZTsgaW1wbGVtZW50YXRpb25zIH0pIC0+XG4gICAgICAgICAgUnBjX2tlcm5lbC5Db25uZWN0aW9uLmNyZWF0ZVxuICAgICAgICAgICAgdHJhbnNwb3J0XG4gICAgICAgICAgICB+aGFuZHNoYWtlX3RpbWVvdXRcbiAgICAgICAgICAgID9oZWFydGJlYXRfY29uZmlnXG4gICAgICAgICAgICA/aWRlbnRpZmljYXRpb25cbiAgICAgICAgICAgIH5pbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICAgIH5kZXNjcmlwdGlvblxuICAgICAgICAgICAgfmNvbm5lY3Rpb25fc3RhdGVcbiAgICAgIGluXG4gICAgICAobWF0Y2ggcnBjX2Nvbm5lY3Rpb24gd2l0aFxuICAgICAgIHwgT2sgdCAtPiByZXR1cm4gKE9rIChzb2NrX3BlZXJuYW1lLCB0KSlcbiAgICAgICB8IEVycm9yIF8gYXMgZXJyb3IgLT5cbiAgICAgICAgIGxldCViaW5kICgpID0gVHJhbnNwb3J0LmNsb3NlIHRyYW5zcG9ydCBpblxuICAgICAgICAgcmV0dXJuIGVycm9yKVxuICA7O1xuXG4gIGxldCBjbGllbnRcbiAgICA/aW1wbGVtZW50YXRpb25zXG4gICAgP21heF9tZXNzYWdlX3NpemVcbiAgICA/bWFrZV90cmFuc3BvcnRcbiAgICA/aGFuZHNoYWtlX3RpbWVvdXRcbiAgICA/aGVhcnRiZWF0X2NvbmZpZ1xuICAgID9kZXNjcmlwdGlvblxuICAgID9pZGVudGlmaWNhdGlvblxuICAgIHdoZXJlX3RvX2Nvbm5lY3RcbiAgICA9XG4gICAgY2xpZW50J1xuICAgICAgP2ltcGxlbWVudGF0aW9uc1xuICAgICAgP21heF9tZXNzYWdlX3NpemVcbiAgICAgID9tYWtlX3RyYW5zcG9ydFxuICAgICAgP2hhbmRzaGFrZV90aW1lb3V0XG4gICAgICA/aGVhcnRiZWF0X2NvbmZpZ1xuICAgICAgP2Rlc2NyaXB0aW9uXG4gICAgICA/aWRlbnRpZmljYXRpb25cbiAgICAgIHdoZXJlX3RvX2Nvbm5lY3RcbiAgICA+Pnw/IHNuZFxuICA7O1xuXG4gIGxldCB3aXRoX2NsaWVudCdcbiAgICA/aW1wbGVtZW50YXRpb25zXG4gICAgP21heF9tZXNzYWdlX3NpemVcbiAgICA/bWFrZV90cmFuc3BvcnRcbiAgICA/aGFuZHNoYWtlX3RpbWVvdXRcbiAgICA/aGVhcnRiZWF0X2NvbmZpZ1xuICAgID9kZXNjcmlwdGlvblxuICAgID9pZGVudGlmaWNhdGlvblxuICAgIHdoZXJlX3RvX2Nvbm5lY3RcbiAgICBmXG4gICAgPVxuICAgIGNsaWVudCdcbiAgICAgID9pbXBsZW1lbnRhdGlvbnNcbiAgICAgID9tYXhfbWVzc2FnZV9zaXplXG4gICAgICA/bWFrZV90cmFuc3BvcnRcbiAgICAgID9oYW5kc2hha2VfdGltZW91dFxuICAgICAgP2hlYXJ0YmVhdF9jb25maWdcbiAgICAgID9kZXNjcmlwdGlvblxuICAgICAgP2lkZW50aWZpY2F0aW9uXG4gICAgICB3aGVyZV90b19jb25uZWN0XG4gICAgPj49PyBmdW4gKHJlbW90ZV9zZXJ2ZXIsIHQpIC0+XG4gICAgbGV0JWJpbmQgcmVzdWx0ID1cbiAgICAgIE1vbml0b3IudHJ5X3dpdGggfnJ1bjpgU2NoZWR1bGUgfnJlc3Q6YExvZyAoZnVuICgpIC0+IGYgfnJlbW90ZV9zZXJ2ZXIgdClcbiAgICBpblxuICAgIGxldCVtYXAgKCkgPSBjbG9zZSB0IH5yZWFzb246KEluZm8ub2Zfc3RyaW5nIFwiUnBjLkNvbm5lY3Rpb24ud2l0aF9jbGllbnQgZmluaXNoZWRcIikgaW5cbiAgICByZXN1bHRcbiAgOztcblxuICBsZXQgd2l0aF9jbGllbnRcbiAgICA/aW1wbGVtZW50YXRpb25zXG4gICAgP21heF9tZXNzYWdlX3NpemVcbiAgICA/bWFrZV90cmFuc3BvcnRcbiAgICA/aGFuZHNoYWtlX3RpbWVvdXRcbiAgICA/aGVhcnRiZWF0X2NvbmZpZ1xuICAgID9kZXNjcmlwdGlvblxuICAgID9pZGVudGlmaWNhdGlvblxuICAgIHdoZXJlX3RvX2Nvbm5lY3RcbiAgICBmXG4gICAgPVxuICAgIHdpdGhfY2xpZW50J1xuICAgICAgP2ltcGxlbWVudGF0aW9uc1xuICAgICAgP21heF9tZXNzYWdlX3NpemVcbiAgICAgID9tYWtlX3RyYW5zcG9ydFxuICAgICAgP2hhbmRzaGFrZV90aW1lb3V0XG4gICAgICA/aGVhcnRiZWF0X2NvbmZpZ1xuICAgICAgP2Rlc2NyaXB0aW9uXG4gICAgICA/aWRlbnRpZmljYXRpb25cbiAgICAgIHdoZXJlX3RvX2Nvbm5lY3RcbiAgICAgIChmdW4gfnJlbW90ZV9zZXJ2ZXI6XyAtPiBmKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBGb3JfZGVidWdnaW5nID0gc3RydWN0XG4gIGxldCBkZWZhdWx0X3BhdGggPVxuICAgIGxhenkgKFwiL2Rldi9zaG0vcnBjLW1lc3NhZ2UtcmVhZGVyLWVycm9yc19fcGlkX1wiIF4gUGlkLnRvX3N0cmluZyAoQ29yZV91bml4LmdldHBpZCAoKSkpXG4gIDs7XG5cbiAgbGV0IHBhdGhfb3ZlcnJpZGUgPSByZWYgTm9uZVxuXG4gIGxldCBkdW1wX2Rlc2VyaWFsaXphdGlvbl9lcnJvciBidWYgfnBvcyA9XG4gICAgKCogRHVtcCB0aGUgbWVzc2FnZSBzeW5jaHJvbm91c2x5LCB0aGlzIGlzIHRoaXMgb2sgYXMgdGhpcyBpcyBiZWluZyB1c2VkIHRvIGRlYnVnIHdoeVxuICAgICAgIHRoZSBhcHBsaWNhdGlvbiBpcyBzZWVpbmcgdGhpcyBlcnJvciwgYW5kIGlzIGxpa2VseSBhYm91dCB0byBzaHV0IGRvd24gZnJvbSB0aGVcbiAgICAgICBmYWlsZWQgUlBDIGFueXdheS4gKilcbiAgICBsZXQgb3Blbl9maWxlICgpID1cbiAgICAgIGxldCBwYXRoID1cbiAgICAgICAgbWF0Y2ggIXBhdGhfb3ZlcnJpZGUgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gZm9yY2UgZGVmYXVsdF9wYXRoXG4gICAgICAgIHwgU29tZSBwYXRoIC0+IHBhdGhcbiAgICAgIGluXG4gICAgICAoIENvcmVfdW5peC5vcGVuZmlsZVxuICAgICAgICAgIHBhdGhcbiAgICAgICAgICB+bW9kZTpcbiAgICAgICAgICAgIFsgT19DUkVBVFxuICAgICAgICAgICAgOyBPX1dST05MWVxuICAgICAgICAgICAgOyAobGV0IGVuc3VyZV93ZV9kb250X2ZpbGxfdXBfZmlsZXN5c3RlbV9pZl9wcm9ncmFtX2lzX2VtaXR0aW5nX21hbnlfb2ZfdGhlc2UgPVxuICAgICAgICAgICAgICAgICBDb3JlX3VuaXguT19UUlVOQ1xuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIGVuc3VyZV93ZV9kb250X2ZpbGxfdXBfZmlsZXN5c3RlbV9pZl9wcm9ncmFtX2lzX2VtaXR0aW5nX21hbnlfb2ZfdGhlc2UpXG4gICAgICAgICAgICBdXG4gICAgICAsIHBhdGggKVxuICAgIGluXG4gICAgbGV0IGZkLCBwYXRoID1cbiAgICAgIHRyeSBvcGVuX2ZpbGUgKCkgd2l0aFxuICAgICAgfCBleG4gLT5cbiAgICAgICAgaWYgT3B0aW9uLmlzX25vbmUgIXBhdGhfb3ZlcnJpZGVcbiAgICAgICAgdGhlbiByYWlzZSBleG5cbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgcGF0aF9vdmVycmlkZSA6PSBOb25lO1xuICAgICAgICAgIG9wZW5fZmlsZSAoKSlcbiAgICBpblxuICAgIGxldCByZXN1bHQgPVxuICAgICAgbWF0Y2ggQmlnc3RyaW5nX3VuaXgucmVhbGx5X3dyaXRlIGZkIGJ1ZiB3aXRoXG4gICAgICB8ICgpIC0+XG4gICAgICAgIHNwcmludGYgXCJEdW1wIG9mIGJ1ZmZlciB3cml0dGVuIHRvICVzLiBUaGlzIG1lc3NhZ2UgYmVnaW5zIGF0IG9mZnNldCAlZFwiIHBhdGggcG9zXG4gICAgICB8IGV4Y2VwdGlvbiBlIC0+XG4gICAgICAgIHNwcmludGZcbiAgICAgICAgICBcIlRyaWVkIGFuZCBmYWlsZWQgdG8gZHVtcCBpbnRlcm5hbCBidWZmZXIgdG8gJXMgKG9mZnNldCAlZCk6ICVzXCJcbiAgICAgICAgICBwYXRoXG4gICAgICAgICAgcG9zXG4gICAgICAgICAgKEV4bi50b19zdHJpbmcgZSlcbiAgICBpblxuICAgIENvcmVfdW5peC5jbG9zZSBmZDtcbiAgICByZXN1bHRcbiAgOztcblxuICBsZXQgZW5hYmxlX2R1bXBpbmdfYnVmZmVyc19vbl9kZXNlcmlhbGl6YXRpb25fZXJyb3JzID9wYXRoX292ZXJyaWRlOm92ZXJyaWRlICgpID1cbiAgICAobWF0Y2ggb3ZlcnJpZGUgd2l0aFxuICAgICB8IE5vbmUgLT4gKClcbiAgICAgfCBTb21lIG92ZXJyaWRlIC0+IHBhdGhfb3ZlcnJpZGUgOj0gU29tZSBvdmVycmlkZSk7XG4gICAgQXN5bmNfcnBjX2tlcm5lbC5Bc3luY19ycGNfa2VybmVsX3ByaXZhdGUuVXRpbC5kdW1wZXJfZm9yX2Rlc2VyaWFsaXphdGlvbl9lcnJvcnNcbiAgICAgIDo9IGR1bXBfZGVzZXJpYWxpemF0aW9uX2Vycm9yXG4gIDs7XG5cbiAgbGV0ICgpID1cbiAgICBtYXRjaCBTeXMuZ2V0ZW52IFwiQVNZTkNfUlBDX0RFQlVHX0RVTVBfREVTRVJJQUxJWkFUSU9OX0VSUk9SU1wiIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgICgqIHN1cHBvcnQgZm9yIG9sZCBlbnYgdmFyICopXG4gICAgICAobWF0Y2ggU3lzLmdldGVudiBcIkFTWU5DX1JQQ19ERUJVR19EVU1QX01FU1NBR0VfTEVOR1RIX0VSUk9SU1wiIHdpdGhcbiAgICAgICB8IE5vbmUgfCBTb21lIFwiXCIgLT4gKClcbiAgICAgICB8IFNvbWUgXyAtPiBlbmFibGVfZHVtcGluZ19idWZmZXJzX29uX2Rlc2VyaWFsaXphdGlvbl9lcnJvcnMgKCkpXG4gICAgfCBTb21lIGR1bXBfdG8gLT5cbiAgICAgIGxldCBwYXRoX292ZXJyaWRlID1cbiAgICAgICAgbWF0Y2ggZHVtcF90byB3aXRoXG4gICAgICAgIHwgXCJcIiB8IFwiMVwiIC0+IE5vbmVcbiAgICAgICAgfCBkdW1wX3RvIHdoZW4gU3RyaW5nLmNvbnRhaW5zIGR1bXBfdG8gJy8nIC0+IFNvbWUgZHVtcF90b1xuICAgICAgICB8IGR1bXBfdG8gLT4gU29tZSAoXCIvZGV2L3NobVwiIF4vIGR1bXBfdG8pXG4gICAgICBpblxuICAgICAgZW5hYmxlX2R1bXBpbmdfYnVmZmVyc19vbl9kZXNlcmlhbGl6YXRpb25fZXJyb3JzID9wYXRoX292ZXJyaWRlICgpXG4gIDs7XG5lbmRcbiJdfQ==
