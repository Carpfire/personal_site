// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Async_unix__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Async_unix = [0],
    Async_unix$0 = [0, Async_unix];
   runtime.caml_register_global(0, Async_unix$0, "Async_unix__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Config
//# unitInfo: Requires: Async_kernel_config, Core__Int, Core__Int64, Core__Result, Core_unix, Linux_ext, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Config$0 = "Async_unix__Config",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_config = global_data.Async_kernel_config,
    Linux_ext = global_data.Linux_ext,
    Core_Result = global_data.Core__Result,
    Core_unix = global_data.Core_unix,
    Core_Int64 = global_data.Core__Int64,
    Core_Int = global_data.Core__Int;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Config$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/config.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "config.ml");
   var
    Max_num_open_file_descrs = Async_kernel_config[7],
    sexp_of_t = Async_kernel_config[12],
    create = Async_kernel_config[13],
    t = Async_kernel_config[14],
    environment_variable = Async_kernel_config[15],
    abort_after_thread_pool_stuck_ = Async_kernel_config[17],
    check_invariants = Async_kernel_config[18],
    detect_invalid_access_from_thr = Async_kernel_config[19],
    dump_core_on_job_delay = Async_kernel_config[20],
    thread_pool_cpu_affinity = Async_kernel_config[21],
    epoll_max_ready_events = Async_kernel_config[22],
    io_uring_max_submission_entrie = Async_kernel_config[23],
    io_uring_mode = Async_kernel_config[24],
    file_descr_watcher = Async_kernel_config[25],
    max_inter_cycle_timeout = Async_kernel_config[26],
    max_num_jobs_per_priority_per_ = Async_kernel_config[27],
    max_num_open_file_descrs = Async_kernel_config[28],
    max_num_threads = Async_kernel_config[29],
    min_inter_cycle_timeout = Async_kernel_config[30],
    record_backtraces = Async_kernel_config[31],
    report_thread_pool_stuck_for = Async_kernel_config[32],
    timing_wheel_config = Async_kernel_config[33],
    default_timing_wheel_config_fo = Async_kernel_config[34],
    task_id = Async_kernel_config[35],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Config = cst_Async_unix_Config$0,
    file_descr_watcher$0 =
      file_descr_watcher
      || (caml_call1(Core_Result[37], Linux_ext[35][6]) ? 1 : 2);
   if
    (caml_call2
      (Max_num_open_file_descrs[9],
       max_num_open_file_descrs,
       Max_num_open_file_descrs[10]))
    if(2 === file_descr_watcher$0)
     var
      max_num_open_file_descrs$0 =
        caml_call1(Max_num_open_file_descrs[4], 1024);
    else{
     var match = caml_call1(Core_unix[286][16], Core_unix[286][12])[2];
     if(match)
      var int64 = match[1], _a_ = caml_call1(Core_Int64[6], int64);
     else
      var _a_ = Core_Int[45];
     var
      _b_ =
        caml_call1(Max_num_open_file_descrs[5], Max_num_open_file_descrs[10]),
      _c_ = caml_call2(Core_Int[89], _b_, _a_),
      max_num_open_file_descrs$0 =
        caml_call1(Max_num_open_file_descrs[4], _c_);
    }
   else
    var max_num_open_file_descrs$0 = max_num_open_file_descrs;
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Config);
   var
    Async_unix_Config =
      [0,
       sexp_of_t,
       create,
       t,
       environment_variable,
       abort_after_thread_pool_stuck_,
       check_invariants,
       detect_invalid_access_from_thr,
       dump_core_on_job_delay,
       thread_pool_cpu_affinity,
       epoll_max_ready_events,
       io_uring_max_submission_entrie,
       io_uring_mode,
       file_descr_watcher$0,
       max_inter_cycle_timeout,
       max_num_jobs_per_priority_per_,
       max_num_open_file_descrs$0,
       max_num_threads,
       min_inter_cycle_timeout,
       record_backtraces,
       report_thread_pool_stuck_for,
       timing_wheel_config,
       default_timing_wheel_config_fo,
       task_id];
   runtime.caml_register_global
    (17, Async_unix_Config, cst_Async_unix_Config$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Busy_poller_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Busy_poller_int = "Async_unix__Busy_poller_intf",
    cst_async_unix = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Busy_poller_int);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][1], "src/busy_poller_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix, "busy_poller_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Busy_poller_int);
   var Async_unix_Busy_poller_intf = [0];
   runtime.caml_register_global
    (11, Async_unix_Busy_poller_intf, cst_Async_unix_Busy_poller_int);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Busy_poller
//# unitInfo: Requires: Core__Type_equal, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Busy_poller$0 = "Async_unix__Busy_poller",
    cst = "_",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Type_equal = global_data.Core__Type_equal;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Busy_poller$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/busy_poller.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "busy_poller.ml");
   var
    _d_ = [0, cst],
    _b_ = [0, cst],
    cst_empty = "empty",
    cst_extra = "extra",
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Busy_poller = cst_Async_unix_Busy_poller$0;
   function poll(t, param){return 0;}
   function _a_(param){return _b_;}
   var
    kind = caml_call2(Core_Type_equal[8][3], cst_empty, _a_),
    Empty_poller = [0, poll, kind];
   function poll$0(t, deadline){return caml_call1(t, deadline);}
   function _c_(param){return _d_;}
   var
    kind$0 = caml_call2(Core_Type_equal[8][3], cst_extra, _c_),
    Extra_poller = [0, poll$0, kind$0];
   function poll$1(param, deadline){
    var poller = param[2], P = param[1];
    return caml_call2(P[1], poller, deadline);
   }
   function create(impl, poller){return [0, impl, poller];}
   function create$0(f){return [0, Extra_poller, f];}
   var empty = [0, Empty_poller, 0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Busy_poller);
   var
    Async_unix_Busy_poller =
      [0, Empty_poller, Extra_poller, poll$1, create, create$0, empty];
   runtime.caml_register_global
    (16, Async_unix_Busy_poller, cst_Async_unix_Busy_poller$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Import
//# unitInfo: Requires: Async_kernel, Async_kernel_config, Base, Core, Core__Int, Core__Sexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Thread_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Import$0 = "Async_unix__Import",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Sexp = global_data.Core__Sexp,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int,
    Async_kernel = global_data.Async_kernel,
    Base = global_data.Base,
    Async_kernel_config = global_data.Async_kernel_config,
    Thread_pool = global_data.Thread_pool;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Import$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "import.ml");
   var
    _a_ = Core_Int[96],
    symbol = _a_[1],
    symbol$0 = _a_[2],
    symbol$1 = _a_[3],
    symbol$2 = _a_[4],
    symbol$3 = _a_[5],
    symbol$4 = _a_[6],
    equal = _a_[7],
    compare = _a_[8],
    min = _a_[9],
    max = _a_[10],
    after = Async_kernel[1],
    at = Async_kernel[2],
    catch$0 = Async_kernel[3],
    choice = Async_kernel[4],
    choose = Async_kernel[5],
    don_t_wait_for = Async_kernel[6],
    every = Async_kernel[7],
    never = Async_kernel[8],
    schedule = Async_kernel[9],
    schedule$0 = Async_kernel[10],
    try_with = Async_kernel[11],
    upon = Async_kernel[12],
    with_timeout = Async_kernel[13],
    with_timeout_exn = Async_kernel[14],
    within = Async_kernel[15],
    within$0 = Async_kernel[16],
    symbol$5 = Async_kernel[17],
    symbol$6 = Async_kernel[18],
    symbol$7 = Async_kernel[19],
    return$0 = Async_kernel[20],
    symbol_bind = Async_kernel[21],
    symbol_map = Async_kernel[22],
    Let_syntax = Async_kernel[23],
    Async_kernel_private = Async_kernel[24],
    _b_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Import = cst_Async_unix_Import$0;
   function print_s(sexp){
    var _c_ = caml_call2(Core_Sexp[84], 0, sexp);
    return caml_call2(Core[258], _b_, _c_);
   }
   var am_test_runner = Base[87][1];
   if(Async_kernel_config[16][12]) Thread_pool[22][1] = 1;
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Import);
   var
    Async_unix_Import =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       after,
       at,
       catch$0,
       choice,
       choose,
       don_t_wait_for,
       every,
       never,
       schedule,
       schedule$0,
       try_with,
       upon,
       with_timeout,
       with_timeout_exn,
       within,
       within$0,
       symbol$5,
       symbol$6,
       symbol$7,
       return$0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Async_kernel_private,
       print_s,
       am_test_runner];
   runtime.caml_register_global
    (19, Async_unix_Import, cst_Async_unix_Import$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Syscall
//# unitInfo: Requires: Core, Core__Error, Core_unix, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Syscall$0 = "Async_unix__Syscall",
    cst_async_unix$0 = "async_unix",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_unix = global_data.Core_unix,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core = global_data.Core,
    Core_Error = global_data.Core__Error;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Syscall$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/syscall.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "syscall.ml");
   var
    _a_ =
      caml_call5
       (Core_Error[19],
        0,
        0,
        "syscall interrupted too many times",
        1000,
        Core[389]),
    too_many_tries = caml_call1(Core_Error[28], _a_),
    too_many_tries_error = [1, too_many_tries],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Syscall = cst_Async_unix_Syscall$0;
   function syscall(f){
    var n = 0;
    for(;;){
     if(1000 <= n) return too_many_tries_error;
     try{var x = caml_call1(f, 0);}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn[1] === Core_unix[4]){
       var _d_ = exn[2];
       if(typeof _d_ === "number" && 11 === _d_){var n$0 = n + 1 | 0, n = n$0; continue;}
      }
      return [1, exn];
     }
     return [0, x];
    }
   }
   function is_eintr(r){
    var
     _b_ = caml_call1(Core_unix[5][8], r),
     _c_ = _b_ ? 11 === caml_call1(Core_unix[5][9], r) ? 1 : 0 : _b_;
    return _c_;
   }
   function syscall_result(a, f){
    var n = 0;
    for(;;){
     if(1000 <= n) throw caml_maybe_attach_backtrace(too_many_tries, 0);
     var r = caml_call1(f, a);
     if(! is_eintr(r)) return r;
     var n$0 = n + 1 | 0, n = n$0;
    }
   }
   function syscall_result2(a, b, f){
    var n = 0;
    for(;;){
     if(1000 <= n) throw caml_maybe_attach_backtrace(too_many_tries, 0);
     var r = caml_call2(f, a, b);
     if(! is_eintr(r)) return r;
     var n$0 = n + 1 | 0, n = n$0;
    }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Syscall);
   var Async_unix_Syscall = [0, syscall, syscall_result, syscall_result2];
   runtime.caml_register_global
    (15, Async_unix_Syscall, cst_Async_unix_Syscall$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Raw_fd
//# unitInfo: Requires: Async_kernel__Debug, Async_kernel__Execution_context, Async_kernel__Ivar, Async_kernel__Job, Async_unix__Import, Async_unix__Syscall, Base__Field, Core, Core__Info, Core__Result, Core_unix, Core_unix__File_descr, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Read_write_pair, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Raw_fd$0 = "Async_unix__Raw_fd",
    cst_Bad_fd = "Bad_fd",
    cst_Closed = "Closed",
    cst_Interrupted = "Interrupted",
    cst_Unknown = "Unknown",
    cst_Unsupported = "Unsupported",
    cst_async_unix$0 = "async_unix",
    cst_can_set_nonblock$0 = "can_set_nonblock",
    cst_close_finished$0 = "close_finished",
    cst_exn = "exn",
    cst_fd = "fd",
    cst_file_descr$0 = "file_descr",
    cst_info$0 = "info",
    cst_kind$0 = "kind",
    cst_nonblock_status$0 = "nonblock_status",
    cst_num_active_syscalls$0 = "num_active_syscalls",
    cst_src_raw_fd_ml = "src/raw_fd.ml",
    cst_state$0 = "state",
    cst_watching$0 = "watching",
    cst_watching_has_changed$0 = "watching_has_changed",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call10(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    return (f.l >= 0 ? f.l : f.l = f.length) == 10
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_unix_Syscall = global_data.Async_unix__Syscall,
    Core_Result = global_data.Core__Result,
    Core_unix = global_data.Core_unix,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Read_write_pair = global_data.Read_write_pair,
    Core_unix_File_descr = global_data.Core_unix__File_descr,
    Async_unix_Import = global_data.Async_unix__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Field = global_data.Base__Field,
    Core_Info = global_data.Core__Info,
    Async_kernel_Job = global_data.Async_kernel__Job,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Raw_fd$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_raw_fd_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "raw_fd.ml");
   var
    debug = Async_kernel_Debug[2],
    cst_Fd_syscall_result_exn_got_ = "Fd.syscall_result_exn got closed fd",
    cst_Fd_syscall_exn_got_closed_ = "Fd.syscall_exn got closed fd",
    cst_Fd_with_file_descr_exn_got = "Fd.with_file_descr_exn got closed fd",
    _av_ = [0, cst_fd],
    cst_Fd_set_nonblock_if_necessa =
      "Fd.set_nonblock_if_necessary called on fd that does not support nonblock",
    _at_ = [0, "new_state"],
    _au_ = [0, cst_fd],
    cst_Fd_set_state_attempted_dis =
      "Fd.set_state attempted disallowed state transition",
    cst_Fd_set_state = "Fd.set_state",
    cst_Fd_create = "Fd.create",
    _al_ = [0, cst_fd],
    _am_ = [0, cst_exn],
    cst_Fd_invariant_failed = "Fd.invariant failed",
    _as_ = [0, cst_src_raw_fd_ml, 169, 11],
    _ar_ = [0, cst_src_raw_fd_ml, 175, 11],
    _aq_ = [0, cst_src_raw_fd_ml, 177, 23],
    _an_ = [0, cst_src_raw_fd_ml, 183, 34],
    _ap_ = [0, cst_src_raw_fd_ml, 185, 13],
    _ao_ = [0, cst_src_raw_fd_ml, 186, 13],
    _ai_ = [0, cst_kind$0],
    _aj_ = [0, cst_info$0],
    _ak_ = [0, cst_file_descr$0],
    ___ = [0, cst_close_finished$0],
    _$_ = [0, cst_num_active_syscalls$0],
    _aa_ = [0, cst_watching_has_changed$0],
    _ab_ = [0, cst_watching$0],
    _ac_ = [0, cst_state$0],
    _ad_ = [0, cst_nonblock_status$0],
    _ae_ = [0, cst_can_set_nonblock$0],
    _af_ = [0, cst_kind$0],
    _ag_ = [0, cst_info$0],
    _ah_ = [0, cst_file_descr$0],
    _D_ = [0, "Blocking"],
    _E_ = [0, "Nonblocking"],
    _F_ = [0, cst_Unknown],
    _z_ = [0, cst_watching$0],
    _A_ = [0, cst_exn],
    cst_Watching_invariant_failed = "Watching.invariant failed",
    _B_ = [0, cst_src_raw_fd_ml, 87, 27],
    _C_ = [0, cst_src_raw_fd_ml, 88, 38],
    _u_ = [0, cst_Bad_fd],
    _v_ = [0, cst_Unsupported],
    _w_ = [0, cst_Interrupted],
    _x_ = [0, cst_Closed],
    _r_ = [0, "Not_watching"],
    _s_ = [0, "Stop_requested"],
    _t_ = [0, "Watch_once"],
    _y_ = [0, "Watch_repeatedly"],
    _n_ = [0, cst_Bad_fd],
    _o_ = [0, cst_Unsupported],
    _p_ = [0, "Ready"],
    _q_ = [0, cst_Closed],
    _m_ = [0, cst_Interrupted],
    _j_ = [0, cst_Closed],
    _k_ = [0, "Close_requested"],
    _l_ = [0, "Open"],
    _a_ = [0, "Char"],
    _b_ = [0, "Fifo"],
    _c_ = [0, "File"],
    _f_ = [0, cst_Unknown],
    _g_ = [0, "Unconnected"],
    _h_ = [0, "Active"],
    _i_ = [0, "Bound"],
    _d_ = [0, "Passive"],
    _e_ = [0, "Socket"],
    cst_close_finished = cst_close_finished$0,
    cst_num_active_syscalls = cst_num_active_syscalls$0,
    cst_watching_has_changed = cst_watching_has_changed$0,
    cst_watching = cst_watching$0,
    cst_state = cst_state$0,
    cst_nonblock_status = cst_nonblock_status$0,
    cst_can_set_nonblock = cst_can_set_nonblock$0,
    cst_kind = cst_kind$0,
    cst_info = cst_info$0,
    cst_file_descr = cst_file_descr$0,
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Raw_fd = cst_Async_unix_Raw_fd$0;
   function sexp_of_t(param){
    if(typeof param === "number")
     switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;}
    var
     arg0_001 = param[1],
     res0_002 =
       -893685881 === arg0_001
        ? _d_
        : 214958384
          <= arg0_001
          ? 785140586 <= arg0_001 ? _f_ : _g_
          : -891636250 <= arg0_001 ? _h_ : _i_;
    return [1, [0, _e_, [0, res0_002, 0]]];
   }
   var Kind = [0, sexp_of_t];
   function sexp_of_t$0(param){
    if(typeof param === "number") return _j_;
    if(0 === param[0]){
     var
      arg0_003 = param[1],
      res0_005 = caml_call1(Async_kernel_Execution_context[5], arg0_003),
      _bn_ = function(_bo_){return 0;},
      res1_006 = caml_call1(Sexplib0_Sexp_conv[24], _bn_);
     return [1, [0, _k_, [0, res0_005, [0, res1_006, 0]]]];
    }
    var
     arg0_007 = param[1],
     res0_008 = caml_call2(Async_kernel_Ivar[9], Core[620], arg0_007);
    return [1, [0, _l_, [0, res0_008, 0]]];
   }
   function transition_is_allowed(t$0, t){
    a:
    if(typeof t$0 !== "number"){
     if(0 === t$0[0]){
      if(typeof t !== "number") break a;
     }
     else if(typeof t === "number" || 1 === t[0]) break a;
     return 1;
    }
    return 0;
   }
   function is_open(param){
    if(typeof param !== "number" && 1 === param[0]) return 1;
    return 0;
   }
   var State = [0, sexp_of_t$0, transition_is_allowed, is_open];
   function sexp_of_ready_to_result(param){
    return -952706910 === param
            ? _m_
            : -18684779
              <= param
              ? -3286312 <= param ? _n_ : _o_
              : -102231997 <= param ? _p_ : _q_;
   }
   function sexp_of_t$1(param){
    if(typeof param === "number") return 0 === param ? _r_ : _s_;
    if(0 === param[0]){
     var
      arg0_009 = param[1],
      res0_010 =
        caml_call2(Async_kernel_Ivar[9], sexp_of_ready_to_result, arg0_009);
     return [1, [0, _t_, [0, res0_010, 0]]];
    }
    var
     arg1_012 = param[2],
     arg0_011 = param[1],
     res0_013 = caml_call1(Async_kernel_Job[1], arg0_011);
    function _bm_(param){
     return -18684779 <= param
             ? -3286312 <= param ? _u_ : _v_
             : -952706910 <= param ? _w_ : _x_;
    }
    var res1_014 = caml_call2(Async_kernel_Ivar[9], _bm_, arg1_012);
    return [1, [0, _y_, [0, res0_013, [0, res1_014, 0]]]];
   }
   function invariant(t){
    try{
     if(typeof t === "number")
      var _bl_ = 0;
     else if(0 === t[0]){
      var ivar = t[1];
      if(! caml_call1(Async_kernel_Ivar[17], ivar))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
      var _bl_ = 0;
     }
     else{
      var ivar$0 = t[2];
      if(! caml_call1(Async_kernel_Ivar[17], ivar$0))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
      var _bl_ = 0;
     }
     return _bl_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _bi_ = [0, [1, [0, _z_, [0, sexp_of_t$1(t), 0]]], 0],
      _bj_ = [0, [1, [0, _A_, [0, caml_call1(Core[625], exn), 0]]], _bi_],
      _bk_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Watching_invariant_failed),
          _bj_]];
     return caml_call1(Core[261], _bk_);
    }
   }
   var Watching = [0, sexp_of_t$1, invariant];
   function sexp_of_t$2(param){
    switch(param){case 0: return _D_;case 1: return _E_;default: return _F_;
    }
   }
   var Nonblock_status = [0, sexp_of_t$2];
   function close_finished(r){return r[10];}
   function num_active_syscalls(r){return r[9];}
   function set_num_active_syscalls(r, v){r[9] = v; return 0;}
   function watching_has_changed(r){return r[8];}
   function set_watching_has_changed(r, v){r[8] = v; return 0;}
   function watching(r){return r[7];}
   function state(r){return r[6];}
   function set_state(r, v){r[6] = v; return 0;}
   function nonblock_status(r){return r[5];}
   function set_nonblock_status(r, v){r[5] = v; return 0;}
   function can_set_nonblock(r){return r[4];}
   function set_can_set_nonblock(r, v){r[4] = v; return 0;}
   function kind(r){return r[3];}
   function set_kind(r, v){r[3] = v; return 0;}
   function info(r){return r[2];}
   function set_info(r, v){r[2] = v; return 0;}
   function file_descr(r){return r[1];}
   function _G_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], v];
   }
   var
    _H_ = 0,
    close_finished$0 =
      [0,
       function(param){return 0;},
       cst_close_finished,
       _H_,
       close_finished,
       _G_];
   function _I_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], v, r[10]];
   }
   var
    _J_ = [0, set_num_active_syscalls],
    num_active_syscalls$0 =
      [0,
       function(param){return 0;},
       cst_num_active_syscalls,
       _J_,
       num_active_syscalls,
       _I_];
   function _K_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v, r[9], r[10]];
   }
   var
    _L_ = [0, set_watching_has_changed],
    watching_has_changed$0 =
      [0,
       function(param){return 0;},
       cst_watching_has_changed,
       _L_,
       watching_has_changed,
       _K_];
   function _M_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8], r[9], r[10]];
   }
   var
    _N_ = 0,
    watching$0 =
      [0, function(param){return 0;}, cst_watching, _N_, watching, _M_];
   function _O_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8], r[9], r[10]];
   }
   var
    _P_ = [0, set_state],
    state$0 = [0, function(param){return 0;}, cst_state, _P_, state, _O_];
   function _Q_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8], r[9], r[10]];
   }
   var
    _R_ = [0, set_nonblock_status],
    nonblock_status$0 =
      [0,
       function(param){return 0;},
       cst_nonblock_status,
       _R_,
       nonblock_status,
       _Q_];
   function _S_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8], r[9], r[10]];
   }
   var
    _T_ = [0, set_can_set_nonblock],
    can_set_nonblock$0 =
      [0,
       function(param){return 0;},
       cst_can_set_nonblock,
       _T_,
       can_set_nonblock,
       _S_];
   function _U_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8], r[9], r[10]];
   }
   var
    _V_ = [0, set_kind],
    kind$0 = [0, function(param){return 0;}, cst_kind, _V_, kind, _U_];
   function _W_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10]];
   }
   var
    _X_ = [0, set_info],
    info$0 = [0, function(param){return 0;}, cst_info, _X_, info, _W_];
   function _Y_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10]];
   }
   var
    _Z_ = 0,
    file_descr$0 =
      [0, function(param){return 0;}, cst_file_descr, _Z_, file_descr, _Y_];
   function iter
   (file_descr_fun,
    info_fun,
    kind_fun,
    can_set_nonblock_fun,
    nonblock_status_fun,
    state_fun,
    watching_fun,
    watching_has_changed_fun,
    num_active_syscalls_fun,
    close_finished_fun){
    caml_call1(file_descr_fun, file_descr$0);
    caml_call1(info_fun, info$0);
    caml_call1(kind_fun, kind$0);
    caml_call1(can_set_nonblock_fun, can_set_nonblock$0);
    caml_call1(nonblock_status_fun, nonblock_status$0);
    caml_call1(state_fun, state$0);
    caml_call1(watching_fun, watching$0);
    caml_call1(watching_has_changed_fun, watching_has_changed$0);
    caml_call1(num_active_syscalls_fun, num_active_syscalls$0);
    return caml_call1(close_finished_fun, close_finished$0);
   }
   var
    Fields =
      [0,
       close_finished$0,
       num_active_syscalls$0,
       watching_has_changed$0,
       watching$0,
       state$0,
       nonblock_status$0,
       can_set_nonblock$0,
       kind$0,
       info$0,
       file_descr$0,
       iter];
   function sexp_of_t$3(param){
    var
     file_descr_016 = param[1],
     info_018 = param[2],
     kind_020 = param[3],
     can_set_nonblock_022 = param[4],
     nonblock_status_024 = param[5],
     state_026 = param[6],
     watching_028 = param[7],
     watching_has_changed_030 = param[8],
     num_active_syscalls_032 = param[9],
     close_finished_034 = param[10],
     arg_035 = caml_call2(Async_kernel_Ivar[9], Core[620], close_finished_034),
     bnds_015 = [0, [1, [0, ___, [0, arg_035, 0]]], 0],
     arg_033 = caml_call1(Core[389], num_active_syscalls_032),
     bnds_015$0 = [0, [1, [0, _$_, [0, arg_033, 0]]], bnds_015],
     arg_031 = caml_call1(Core[323], watching_has_changed_030),
     bnds_015$1 = [0, [1, [0, _aa_, [0, arg_031, 0]]], bnds_015$0],
     arg_029 = caml_call2(Read_write_pair[6][2], Watching[1], watching_028),
     bnds_015$2 = [0, [1, [0, _ab_, [0, arg_029, 0]]], bnds_015$1],
     arg_027 = caml_call1(State[1], state_026),
     bnds_015$3 = [0, [1, [0, _ac_, [0, arg_027, 0]]], bnds_015$2],
     arg_025 = caml_call1(Nonblock_status[1], nonblock_status_024),
     bnds_015$4 = [0, [1, [0, _ad_, [0, arg_025, 0]]], bnds_015$3],
     arg_023 = caml_call1(Core[323], can_set_nonblock_022),
     bnds_015$5 = [0, [1, [0, _ae_, [0, arg_023, 0]]], bnds_015$4],
     arg_021 = caml_call1(Kind[1], kind_020),
     bnds_015$6 = [0, [1, [0, _af_, [0, arg_021, 0]]], bnds_015$5],
     arg_019 = caml_call1(Core_Info[9], info_018),
     bnds_015$7 = [0, [1, [0, _ag_, [0, arg_019, 0]]], bnds_015$6],
     arg_017 = caml_call1(Core_unix_File_descr[2], file_descr_016),
     bnds_015$8 = [0, [1, [0, _ah_, [0, arg_017, 0]]], bnds_015$7];
    return [1, bnds_015$8];
   }
   function sexp_of_t_hum(param){
    var
     file_descr = param[1],
     info = param[2],
     kind = param[3],
     _bg_ = [0, [1, [0, _ai_, [0, caml_call1(Kind[1], kind), 0]]], 0],
     _bh_ = [0, [1, [0, _aj_, [0, caml_call1(Core_Info[9], info), 0]]], _bg_];
    return [1,
            [0,
             [1,
              [0,
               _ak_,
               [0, caml_call1(Core_unix_File_descr[2], file_descr), 0]]],
             _bh_]];
   }
   var
    T =
      [0,
       close_finished,
       num_active_syscalls,
       set_num_active_syscalls,
       watching_has_changed,
       set_watching_has_changed,
       watching,
       state,
       set_state,
       nonblock_status,
       set_nonblock_status,
       can_set_nonblock,
       set_can_set_nonblock,
       kind,
       set_kind,
       info,
       set_info,
       file_descr,
       Fields,
       sexp_of_t$3,
       sexp_of_t_hum],
    close_finished$1 = T[1],
    num_active_syscalls$1 = T[2],
    set_num_active_syscalls$0 = T[3],
    watching_has_changed$1 = T[4],
    set_watching_has_changed$0 = T[5],
    watching$1 = T[6],
    state$1 = T[7],
    nonblock_status$1 = T[9],
    set_nonblock_status$0 = T[10],
    can_set_nonblock$1 = T[11],
    set_can_set_nonblock$0 = T[12],
    kind$1 = T[13],
    set_kind$0 = T[14],
    info$1 = T[15],
    set_info$0 = T[16],
    file_descr$1 = T[17],
    Fields$0 = T[18],
    sexp_of_t$4 = T[19],
    sexp_of_t_hum$0 = T[20];
   function equal(t$0, t){return t$0 === t ? 1 : 0;}
   function invariant$0(t){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, t));
        },
      _aS_ =
        function(close_finished){
         var match = t[6];
         if(typeof match === "number") return 0;
         if(0 === match[0]){
          if(caml_call1(Async_kernel_Ivar[17], close_finished)) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _an_], 1);
         }
         var close_started = match[1];
         if(! caml_call1(Async_kernel_Ivar[17], close_finished))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ap_], 1);
         if(caml_call1(Async_kernel_Ivar[17], close_started)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
        },
      _aT_ = function(_bf_){return check(_aS_, _bf_);},
      _aU_ =
        function(num_active_syscalls){
         if(! caml_call2(Async_unix_Import[1], t[9], 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
         function watching(read_or_write){
          var match = caml_call2(Read_write_pair[23], t[7], read_or_write);
          if(typeof match === "number" && ! match) return 0;
          return 1;
         }
         var
          _bd_ = watching(-477700929),
          _be_ = watching(914388854) + _bd_ | 0;
         if(! caml_call2(Async_unix_Import[1], t[9], _be_))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ar_], 1);
         if(typeof t[6] !== "number") return 0;
         if(caml_call2(Async_unix_Import[3], num_active_syscalls, 0))
          return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aq_], 1);
        },
      _aV_ = function(_bc_){return check(_aU_, _bc_);},
      _aW_ = function(_bb_){return 0;},
      _aX_ =
        function(watching){
         return caml_call2(Read_write_pair[18], watching, Watching[2]);
        },
      _aY_ = function(_ba_){return check(_aX_, _ba_);},
      _aZ_ = function(_a$_){return 0;},
      _a0_ = function(_a__){return 0;},
      _a1_ = function(_a9_){return 0;},
      _a2_ = function(_a8_){return 0;},
      _a3_ = function(_a7_){return 0;},
      _a4_ = function(_a6_){return 0;},
      _a5_ =
        caml_call10
         (Fields$0[11],
          _a4_,
          _a3_,
          _a2_,
          _a1_,
          _a0_,
          _aZ_,
          _aY_,
          _aW_,
          _aV_,
          _aT_);
     return _a5_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _aP_ = [0, [1, [0, _al_, [0, caml_call1(sexp_of_t$4, t), 0]]], 0],
      _aQ_ = [0, [1, [0, _am_, [0, caml_call1(Core[625], exn), 0]]], _aP_],
      _aR_ =
        [1,
         [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_invariant_failed), _aQ_]];
     return caml_call1(Core[261], _aR_);
    }
   }
   function to_int(t){return caml_call1(Core_unix_File_descr[15], t[1]);}
   function create(opt, kind, file_descr, info){
    if(opt)
     var sth = opt[1], avoid_setting_nonblock = sth;
    else
     var avoid_setting_nonblock = 0;
    if(avoid_setting_nonblock)
     var can_set_nonblock = 0;
    else if(typeof kind === "number")
     switch(kind){
       case 0:
        var can_set_nonblock = 0; break;
       case 1:
        var can_set_nonblock = 1; break;
       default: var can_set_nonblock = 0;
     }
    else
     var can_set_nonblock = 1;
    var
     _aN_ = caml_call1(Async_kernel_Ivar[12], 0),
     _aO_ = caml_call1(Read_write_pair[11], 0),
     t =
       [0,
        file_descr,
        info,
        kind,
        can_set_nonblock,
        2,
        [1, caml_call1(Async_kernel_Ivar[12], 0)],
        _aO_,
        0,
        0,
        _aN_];
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_Fd_create, t, sexp_of_t$4);
    return t;
   }
   function inc_num_active_syscalls(t){
    var _aM_ = t[6];
    if(typeof _aM_ !== "number" && 1 === _aM_[0]){t[9] = t[9] + 1 | 0; return 17724;}
    return -1034200365;
   }
   function set_state$0(t, new_state){
    if(debug){
     var
      _aI_ =
        function(param){
         var
          arg1_037 = param[2],
          arg0_036 = param[1],
          res0_038 = caml_call1(State[1], arg0_036),
          res1_039 = caml_call1(sexp_of_t$4, arg1_037);
         return [1, [0, res0_038, [0, res1_039, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15], cst_Fd_set_state, [0, new_state, t], _aI_);
    }
    if(caml_call2(State[2], t[6], new_state)){t[6] = new_state; return 0;}
    var
     _aJ_ = [0, [1, [0, _at_, [0, caml_call1(State[1], new_state), 0]]], 0],
     _aK_ = [0, [1, [0, _au_, [0, caml_call1(sexp_of_t$4, t), 0]]], _aJ_],
     _aL_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_set_state_attempted_dis),
         _aK_]];
    return caml_call1(Core[261], _aL_);
   }
   function is_open$0(t){return caml_call1(State[3], t[6]);}
   function is_closed(t){return 1 - is_open$0(t);}
   function determine_nonblock_status(t){
    switch(t[5]){
      case 0:
       return 0;
      case 1:
       return 1;
      default:
       var
        flags = caml_call1(Core_unix[51], t[1]),
        nonblock = caml_call2(Core_unix[50][38], Core_unix[50][48], flags),
        _aH_ = nonblock ? 1 : 0;
       t[5] = _aH_;
       return nonblock;
    }
   }
   function supports_nonblock(t){
    return t[4] ? 1 : determine_nonblock_status(t);
   }
   function set_nonblock_if_necessary(opt, t){
    if(opt) var sth = opt[1], nonblocking = sth; else var nonblocking = 0;
    if(! nonblocking) return nonblocking;
    if(determine_nonblock_status(t)) return 0;
    if(t[4]){caml_call1(Core_unix[98], t[1]); t[5] = 1; return 0;}
    var
     _aF_ = [0, [1, [0, _av_, [0, caml_call1(sexp_of_t$4, t), 0]]], 0],
     _aG_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_set_nonblock_if_necessa),
         _aF_]];
    return caml_call1(Core[261], _aG_);
   }
   function with_file_descr_exn(nonblocking, t, f){
    if(is_closed(t)){
     var
      _aD_ = [0, caml_call1(sexp_of_t$4, t), 0],
      _aE_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_with_file_descr_exn_got),
          _aD_]];
     return caml_call1(Core[261], _aE_);
    }
    set_nonblock_if_necessary(nonblocking, t);
    return caml_call1(f, t[1]);
   }
   function with_file_descr(nonblocking, t, f){
    if(is_closed(t)) return -1034200365;
    try{
     set_nonblock_if_necessary(nonblocking, t);
     var _aC_ = [0, 17724, caml_call1(f, t[1])];
     return _aC_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return [0, 106380200, exn];
    }
   }
   function syscall(nonblocking, t, f){
    return with_file_descr
            (nonblocking,
             t,
             function(file_descr){
              function _aA_(param){return caml_call1(f, file_descr);}
              var _aB_ = caml_call1(Async_unix_Syscall[1], _aA_);
              return caml_call1(Core_Result[40], _aB_);
             });
   }
   function syscall_exn(nonblocking, t, f){
    var match = syscall(nonblocking, t, f);
    if(typeof match === "number"){
     var
      _ay_ = [0, caml_call1(sexp_of_t$4, t), 0],
      _az_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_syscall_exn_got_closed_),
          _ay_]];
     return caml_call1(Core[261], _az_);
    }
    if(106380200 <= match[1]){
     var exn = match[2];
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    var a = match[2];
    return a;
   }
   function syscall_result_exn(nonblocking, t, a, f){
    if(is_closed(t)){
     var
      _aw_ = [0, caml_call1(sexp_of_t$4, t), 0],
      _ax_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_syscall_result_exn_got_),
          _aw_]];
     return caml_call1(Core[261], _ax_);
    }
    set_nonblock_if_necessary(nonblocking, t);
    return caml_call3(Async_unix_Syscall[3], t[1], a, f);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Raw_fd);
   var
    Async_unix_Raw_fd =
      [0,
       debug,
       Kind,
       State,
       sexp_of_ready_to_result,
       Watching,
       Nonblock_status,
       T,
       close_finished$1,
       num_active_syscalls$1,
       set_num_active_syscalls$0,
       watching_has_changed$1,
       set_watching_has_changed$0,
       watching$1,
       state$1,
       nonblock_status$1,
       set_nonblock_status$0,
       can_set_nonblock$1,
       set_can_set_nonblock$0,
       kind$1,
       set_kind$0,
       info$1,
       set_info$0,
       file_descr$1,
       Fields$0,
       sexp_of_t$4,
       sexp_of_t_hum$0,
       equal,
       invariant$0,
       to_int,
       create,
       inc_num_active_syscalls,
       set_state$0,
       is_open$0,
       is_closed,
       determine_nonblock_status,
       supports_nonblock,
       set_nonblock_if_necessary,
       with_file_descr_exn,
       with_file_descr,
       syscall,
       syscall_exn,
       syscall_result_exn];
   runtime.caml_register_global
    (101, Async_unix_Raw_fd, cst_Async_unix_Raw_fd$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__By_descr
//# unitInfo: Requires: Async_unix__Import, Async_unix__Raw_fd, Core, Core__List, Core__Option_array, Core__Sexp, Core_unix__File_descr, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_By_descr$0 = "Async_unix__By_descr",
    cst_async_unix$0 = "async_unix",
    cst_file_descr = "file_descr",
    cst_src_by_descr_ml = "src/by_descr.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_unix_Raw_fd = global_data.Async_unix__Raw_fd,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Option_array = global_data.Core__Option_array,
    Core_unix_File_descr = global_data.Core_unix__File_descr,
    Assert_failure = global_data.Assert_failure,
    Core_Sexp = global_data.Core__Sexp,
    Core_List = global_data.Core__List,
    Async_unix_Import = global_data.Async_unix__Import,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_By_descr$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_by_descr_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "by_descr.ml");
   var
    _g_ = [0, "fd"],
    _h_ = [0, "exn"],
    cst_By_descr_invariant_failure = "By_descr.invariant failure",
    _i_ = [0, cst_src_by_descr_ml, 117, 8],
    cst_Attempt_to_register_a_file =
      "Attempt to register a file descriptor with Async that Async believes it is already managing.",
    _f_ = [0, 0],
    _e_ = [0, cst_file_descr],
    cst_By_descr_find_exn_got_unkn =
      "[By_descr.find_exn] got unknown file_descr",
    _b_ = [0, "max_file_descr"],
    _c_ = [0, "min_file_descr"],
    _d_ = [0, cst_file_descr],
    cst_The_file_descriptor_is_not =
      "The file descriptor is not in the range that Async allows, which probably means that the program has created too many file descriptors without closing them.  You can cause Async to allow more file descriptors via the [ASYNC_CONFIG] environment variable, like this: ASYNC_CONFIG='((max_num_open_file_descrs <NUMBER>))' foo.exe arg1 arg2 ...",
    _a_ = [0, "num_file_descrs"],
    cst_By_descr_create_got_negati =
      "[By_descr.create] got negative [num_file_descrs]",
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_By_descr = cst_Async_unix_By_descr$0;
   function capacity(t){return caml_call1(Core_Option_array[36], t);}
   function create(num_file_descrs){
    if(caml_call2(Async_unix_Import[5], num_file_descrs, 0)){
     var
      _Y_ =
        [0, [1, [0, _a_, [0, caml_call1(Core[389], num_file_descrs), 0]]], 0],
      _Z_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_By_descr_create_got_negati),
          _Y_]];
     caml_call1(Core[261], _Z_);
    }
    return caml_call1(Core_Option_array[13], num_file_descrs);
   }
   function bounds_check(t, file_descr){
    var
     i = caml_call1(Core_unix_File_descr[15], file_descr),
     _W_ = caml_call2(Async_unix_Import[2], 0, i);
    if(! _W_) return _W_;
    var _X_ = capacity(t);
    return caml_call2(Async_unix_Import[5], i, _X_);
   }
   function bounds_check_error(t, file_descr){
    var
     _S_ = capacity(t) - 1 | 0,
     _T_ = [0, [1, [0, _b_, [0, caml_call1(Core[389], _S_), 0]]], 0],
     _U_ =
       [0, [1, [0, _c_, [0, caml_call1(Sexplib0_Sexp_conv[10], 0), 0]]], _T_],
     _V_ =
       [0,
        [1, [0, _d_, [0, caml_call1(Core_unix_File_descr[2], file_descr), 0]]],
        _U_];
    return [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_The_file_descriptor_is_not),
             _V_]];
   }
   function bounds_check_exn(t, file_descr){
    var _Q_ = 1 - bounds_check(t, file_descr);
    if(! _Q_) return _Q_;
    var _R_ = bounds_check_error(t, file_descr);
    return caml_call1(Core[261], _R_);
   }
   function mem(t, file_descr){
    var _O_ = bounds_check(t, file_descr);
    if(! _O_) return _O_;
    var _P_ = caml_call1(Core_unix_File_descr[15], file_descr);
    return caml_call2(Core_Option_array[46], t, _P_);
   }
   function find(t, file_descr){
    if(! bounds_check(t, file_descr)) return 0;
    var _N_ = caml_call1(Core_unix_File_descr[15], file_descr);
    return caml_call2(Core_Option_array[42], t, _N_);
   }
   function find_exn(t, file_descr){
    bounds_check_exn(t, file_descr);
    var _J_ = caml_call1(Core_unix_File_descr[15], file_descr);
    if(caml_call2(Core_Option_array[45], t, _J_)){
     var
      _K_ =
        [0,
         [1,
          [0, _e_, [0, caml_call1(Core_unix_File_descr[2], file_descr), 0]]],
         0],
      _L_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_By_descr_find_exn_got_unkn),
          _K_]];
     caml_call1(Core[261], _L_);
    }
    var _M_ = caml_call1(Core_unix_File_descr[15], file_descr);
    return caml_call2(Core_Option_array[44], t, _M_);
   }
   function remove(t, fd){
    bounds_check_exn(t, fd);
    var _I_ = caml_call1(Core_unix_File_descr[15], fd);
    return caml_call2(Core_Option_array[53], t, _I_);
   }
   function add(t, file_descr, v){
    if(! bounds_check(t, file_descr)){
     var _H_ = bounds_check_error(t, file_descr);
     return caml_call1(Core[245], _H_);
    }
    var _E_ = caml_call1(Core_unix_File_descr[15], file_descr);
    if(caml_call2(Core_Option_array[46], t, _E_)){
     var
      _F_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Attempt_to_register_a_file);
     return caml_call1(Core[245], _F_);
    }
    var _G_ = caml_call1(Core_unix_File_descr[15], file_descr);
    caml_call3(Core_Option_array[52], t, _G_, v);
    return _f_;
   }
   function fold(t, init, f){
    var r = [0, init], _B_ = capacity(t) - 1 | 0, _A_ = 0;
    if(_B_ >= 0){
     var i = _A_;
     for(;;){
      if(caml_call2(Core_Option_array[46], t, i)){
       var _C_ = caml_call2(Core_Option_array[44], t, i);
       r[1] = caml_call2(f, r[1], _C_);
      }
      var _D_ = i + 1 | 0;
      if(_B_ === i) break;
      var i = _D_;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _y_ = capacity(t) - 1 | 0, _x_ = 0;
    if(_y_ >= 0){
     var i = _x_;
     for(;;){
      if(caml_call2(Core_Option_array[46], t, i))
       caml_call1(f, caml_call2(Core_Option_array[44], t, i));
      var _z_ = i + 1 | 0;
      if(_y_ === i) break;
      var i = _z_;
     }
    }
    return 0;
   }
   function exists(t, f){
    function _w_(param){
     if(! param) return 0;
     var x = param[1];
     return caml_call1(f, x);
    }
    return caml_call2(Core_Option_array[20], t, _w_);
   }
   function sexp_of_t(sexp_of, t){
    var r = [0, 0], _t_ = capacity(t) - 1 | 0, _s_ = 0;
    if(_t_ >= 0){
     var i = _s_;
     for(;;){
      if(caml_call2(Core_Option_array[46], t, i)){
       var x = caml_call2(Core_Option_array[44], t, i), acc = r[1];
       r[1] = [0, [0, i, caml_call1(sexp_of, x)], acc];
      }
      var _u_ = i + 1 | 0;
      if(_t_ === i) break;
      var i = _u_;
     }
    }
    var fd_alist = r[1], x_005 = caml_call1(Core_List[59], fd_alist);
    function _v_(param){
     var
      arg1_002 = param[2],
      arg0_001 = param[1],
      res0_003 = caml_call1(Core[389], arg0_001),
      res1_004 = caml_call1(Core_Sexp[93], arg1_002);
     return [1, [0, res0_003, [0, res1_004, 0]]];
    }
    return caml_call2(Core[472], _v_, x_005);
   }
   function invariant(x_006){
    try{
     var _n_ = capacity(x_006) - 1 | 0, _m_ = 0;
     if(_n_ >= 0){
      var i = _m_;
      for(;;){
       var match = caml_call2(Core_Option_array[42], x_006, i);
       if(match){
        var fd = match[1];
        caml_call1(Async_unix_Raw_fd[28], fd);
        var
         _p_ = caml_call1(Async_unix_Raw_fd[23], fd),
         _q_ = caml_call1(Core_unix_File_descr[13], i);
        if(! caml_call2(Core_unix_File_descr[3], _q_, _p_))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
       }
       var _r_ = i + 1 | 0;
       if(_n_ === i) break;
       var i = _r_;
      }
     }
     var _o_ = 0;
     return _o_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _j_ =
        [0, [1, [0, _g_, [0, sexp_of_t(Async_unix_Raw_fd[25], x_006), 0]]], 0],
      _k_ = [0, [1, [0, _h_, [0, caml_call1(Core[625], exn), 0]]], _j_],
      _l_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_By_descr_invariant_failure),
          _k_]];
     return caml_call1(Core[261], _l_);
    }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_By_descr);
   var
    Async_unix_By_descr =
      [0,
       sexp_of_t,
       invariant,
       create,
       capacity,
       add,
       mem,
       find,
       find_exn,
       remove,
       fold,
       iter,
       exists];
   runtime.caml_register_global
    (34, Async_unix_By_descr, cst_Async_unix_By_descr$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Clock
//# unitInfo: Requires: Async_kernel__Clock_ns, Async_unix__Import, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Time_float_unix, Time_ns_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Clock$0 = "Async_unix__Clock",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Time_ns_unix = global_data.Time_ns_unix,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Async_unix_Import = global_data.Async_unix__Import,
    Core_Option = global_data.Core__Option,
    Time_float_unix = global_data.Time_float_unix,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Clock$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/clock.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "clock.ml");
   var
    _a_ = [0, "Aborted"],
    _b_ = [0, "Happened"],
    _c_ = [0, "Scheduled_at"],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Clock = cst_Async_unix_Clock$0;
   function run_at(time, f, a){
    var _y_ = caml_call1(Time_ns_unix[68], time);
    return caml_call3(Async_kernel_Clock_ns[1], _y_, f, a);
   }
   function run_after(span, f, a){
    var _x_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call3(Async_kernel_Clock_ns[2], _x_, f, a);
   }
   function at(time){
    var _w_ = caml_call1(Time_ns_unix[68], time);
    return caml_call1(Async_kernel_Clock_ns[3], _w_);
   }
   function after(span){
    var _v_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call1(Async_kernel_Clock_ns[4], _v_);
   }
   function with_timeout(span, d){
    var _u_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call2(Async_kernel_Clock_ns[5], _u_, d);
   }
   function with_timeout_exn(span, d, error){
    var _t_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call3(Async_kernel_Clock_ns[6], _t_, d, error);
   }
   var
    sexp_of_t = Async_kernel_Clock_ns[7][1],
    sexp_of_t_unit = Async_kernel_Clock_ns[7][2],
    invariant = Async_kernel_Clock_ns[7][3],
    abort = Async_kernel_Clock_ns[7][9],
    abort_exn = Async_kernel_Clock_ns[7][10],
    abort_if_possible = Async_kernel_Clock_ns[7][11],
    fired = Async_kernel_Clock_ns[7][12];
   function scheduled_at(t){
    var _s_ = caml_call1(Async_kernel_Clock_ns[7][4], t);
    return caml_call1(Time_ns_unix[66], _s_);
   }
   function at$0(time){
    var _r_ = caml_call1(Time_ns_unix[68], time);
    return caml_call1(Async_kernel_Clock_ns[7][15], _r_);
   }
   function after$0(span){
    var _q_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call1(Async_kernel_Clock_ns[7][16], _q_);
   }
   function reschedule_at(t, time){
    var _p_ = caml_call1(Time_ns_unix[68], time);
    return caml_call2(Async_kernel_Clock_ns[7][13], t, _p_);
   }
   function reschedule_after(t, span){
    var _o_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call2(Async_kernel_Clock_ns[7][14], t, _o_);
   }
   function run_at$0(time, f, x){
    var _n_ = caml_call1(Time_ns_unix[68], time);
    return caml_call3(Async_kernel_Clock_ns[7][7], _n_, f, x);
   }
   function run_after$0(span, f, x){
    var _m_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call3(Async_kernel_Clock_ns[7][8], _m_, f, x);
   }
   function sexp_of_t$0(of_a_004, of_h_005, param){
    switch(param[0]){
      case 0:
       var arg0_006 = param[1], res0_007 = caml_call1(of_a_004, arg0_006);
       return [1, [0, _a_, [0, res0_007, 0]]];
      case 1:
       var arg0_008 = param[1], res0_009 = caml_call1(of_h_005, arg0_008);
       return [1, [0, _b_, [0, res0_009, 0]]];
      default:
       var
        arg0_010 = param[1],
        res0_011 = caml_call1(Time_float_unix[60], arg0_010);
       return [1, [0, _c_, [0, res0_011, 0]]];
    }
   }
   var Status = [0, sexp_of_t$0];
   function status(t){
    var match = caml_call1(Async_kernel_Clock_ns[7][6], t);
    switch(match[0]){
      case 0:
       var a = match[1]; return [0, a];
      case 1:
       var h = match[1]; return [1, h];
      default:
       var time = match[1]; return [2, caml_call1(Time_ns_unix[66], time)];
    }
   }
   function at_varying_intervals(stop, f){
    function _k_(param){
     var _l_ = caml_call1(f, 0);
     return caml_call1(Time_ns_unix[72][146], _l_);
    }
    return caml_call2(Async_kernel_Clock_ns[8], stop, _k_);
   }
   function at_intervals(start, stop, span){
    var
     start$0 = caml_call2(Core_Option[34], start, Time_ns_unix[68]),
     _j_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call3(Async_kernel_Clock_ns[9], start$0, stop, _j_);
   }
   function every(start, stop, continue_on_error, finished, span, f){
    var _i_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call6
            (Async_kernel_Clock_ns[10],
             start,
             stop,
             continue_on_error,
             finished,
             _i_,
             f);
   }
   function every$0(start, stop, continue_on_error, span, f){
    var _h_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call5
            (Async_kernel_Clock_ns[11],
             start,
             stop,
             continue_on_error,
             _h_,
             f);
   }
   function run_at_intervals(start, stop, continue_on_error, span, f){
    var
     start$0 = caml_call2(Core_Option[34], start, Time_ns_unix[68]),
     _g_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call5
            (Async_kernel_Clock_ns[12],
             start$0,
             stop,
             continue_on_error,
             _g_,
             f);
   }
   function run_at_intervals$0(start, stop, continue_on_error, span, f){
    var
     start$0 = caml_call2(Core_Option[34], start, Time_ns_unix[68]),
     _f_ = caml_call1(Time_ns_unix[72][146], span);
    return caml_call5
            (Async_kernel_Clock_ns[13],
             start$0,
             stop,
             continue_on_error,
             _f_,
             f);
   }
   function duration_of(f){
    function _d_(param){
     var span = param[2], res = param[1];
     return [0, res, caml_call1(Time_ns_unix[72][144], span)];
    }
    var _e_ = caml_call1(Async_kernel_Clock_ns[14], f);
    return caml_call2(Async_unix_Import[33][3], _e_, _d_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Clock);
   var
    Async_unix_Clock =
      [0,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       with_timeout_exn,
       [0,
        sexp_of_t,
        sexp_of_t_unit,
        invariant,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        abort,
        abort_exn,
        abort_if_possible,
        fired,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals,
       run_at_intervals$0,
       duration_of];
   runtime.caml_register_global(19, Async_unix_Clock, cst_Async_unix_Clock$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Dump_core_on_job_delay
//# unitInfo: Requires: Async_kernel_config, Async_unix__Clock, Core, Core_thread, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sys_unix, Time_float_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Dump_core_on_jo$0 = "Async_unix__Dump_core_on_job_delay",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Time_float_unix = global_data.Time_float_unix,
    Core = global_data.Core,
    Core_thread = global_data.Core_thread,
    Async_unix_Clock = global_data.Async_unix__Clock,
    Sys_unix = global_data.Sys_unix,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_config = global_data.Async_kernel_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Dump_core_on_jo$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/dump_core_on_job_delay.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_unix$0, "dump_core_on_job_delay.ml");
   var
    include = Async_kernel_config[8][1],
    sexp_of_t = include[2],
    cst_usr_bin_gcore = "/usr/bin/gcore",
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Dump_core_on_jo = cst_Async_unix_Dump_core_on_jo$0;
   function choose_dump_type(param){
    switch(param){
      case 0:
       return 4448519 === caml_call2(Sys_unix[2], 0, cst_usr_bin_gcore)
               ? 1
               : 0;
      case 1:
       return 0;
      default: return 1;
    }
   }
   function start_watching(dump_if_delayed_by, how_to_dump){
    var
     dump_type = choose_dump_type(how_to_dump),
     dump_if_delayed_by_sec =
       caml_call1(Time_float_unix[1][89], dump_if_delayed_by),
     tick_interval = caml_call1(Core[630], dump_if_delayed_by_sec / 10.),
     _a_ = 0;
    function _b_(param){
     return runtime.dump_core_on_job_delay_watch
             (dump_if_delayed_by_sec, dump_type);
    }
    caml_call3(Core_thread[2], 890699316, _b_, _a_);
    function _c_(_d_){return runtime.dump_core_on_job_delay_tick(_d_);}
    return caml_call5(Async_unix_Clock[11], 0, 0, 0, tick_interval, _c_);
   }
   function dump_core(opt, param){
    if(opt) var sth = opt[1], how_to_dump = sth; else var how_to_dump = 0;
    return runtime.dump_core_on_job_delay_dump_core
            (choose_dump_type(how_to_dump));
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Dump_core_on_jo);
   var
    Async_unix_Dump_core_on_job_de =
      [0, [0, sexp_of_t], start_watching, dump_core];
   runtime.caml_register_global
    (19, Async_unix_Dump_core_on_job_de, cst_Async_unix_Dump_core_on_jo$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__File_descr_watcher_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_File_descr_watc$0 = "Async_unix__File_descr_watcher_intf",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_File_descr_watc$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/file_descr_watcher_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_unix$0, "file_descr_watcher_intf.ml");
   var
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_File_descr_watc = cst_Async_unix_File_descr_watc$0;
   function variant_of(t, span_or_unit){
    return t ? [0, 818927100, span_or_unit] : -511334242;
   }
   var Timeout = [0, variant_of];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_File_descr_watc);
   var Async_unix_File_descr_watcher_ = [0, Timeout];
   runtime.caml_register_global
    (11, Async_unix_File_descr_watcher_, cst_Async_unix_File_descr_watc$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Epoll_file_descr_watcher
//# unitInfo: Requires: Async_kernel_config, Async_unix__Config, Base__Backtrace, Base__Field, Core, Core__List, Core__Or_error, Core__Result, Core_unix, Core_unix__File_descr, Linux_ext, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Epoll_file_desc$0 = "Async_unix__Epoll_file_descr_watcher",
    cst_async_unix$0 = "async_unix",
    cst_backtrace = "backtrace",
    cst_epoll$0 = "epoll",
    cst_epoll_file_descr_watcher = "epoll_file_descr_watcher",
    cst_exn = "exn",
    cst_src_epoll_file_descr_watch = "src/epoll_file_descr_watcher.ml",
    cst_timerfd$0 = "timerfd",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/epoll_file_descr_watcher.ml:40:26",
    ok = [0, 17724],
    timeout = [0, 642269825],
    Base_Backtrace = global_data.Base__Backtrace,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Linux_ext = global_data.Linux_ext,
    Core_unix = global_data.Core_unix,
    Core_Result = global_data.Core__Result,
    Async_unix_Config = global_data.Async_unix__Config,
    Async_kernel_config = global_data.Async_kernel_config,
    Core_Or_error = global_data.Core__Or_error,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Base_Field = global_data.Base__Field,
    Core_unix_File_descr = global_data.Core_unix__File_descr,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Epoll_file_desc$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_epoll_file_descr_watch);
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_unix$0, "epoll_file_descr_watcher.ml");
   var
    include = Linux_ext[60][1],
    sexp_of_t = include[2],
    equal = include[11],
    compare = include[12],
    symbol = include[31],
    do_intersect = include[36],
    in$0 = include[41],
    out = include[42],
    err = include[44],
    hup = include[45],
    et = include[46],
    in_out = caml_call2(symbol, in$0, out),
    for_timerfd = caml_call2(symbol, in$0, et),
    _n_ = [0, cst_epoll_file_descr_watcher],
    _o_ = [0, "check_result"],
    _p_ = [0, cst_backtrace],
    _q_ = [0, cst_exn],
    cst_Epoll_post_check_bug = "Epoll.post_check bug",
    _r_ = [0, cst_backtrace],
    _s_ = [0, cst_exn],
    cst_epoll_raised_unexpected_ex = "epoll raised unexpected exn",
    _l_ = [0, "Timeout"],
    _m_ = [0, "Ok"],
    _i_ = [0, cst_epoll_file_descr_watcher],
    _j_ = [0, cst_exn],
    cst_Epoll_file_descr_watcher_i =
      "Epoll_file_descr_watcher.invariant failed",
    _k_ = [0, cst_src_epoll_file_descr_watch, 46, 13],
    _a_ = [0, "handle_fd_write_ready"],
    _b_ = [0, "handle_fd_read_ready"],
    _c_ = [0, cst_epoll$0],
    _d_ = [0, cst_timerfd$0],
    cst_epoll = cst_epoll$0,
    cst_timerfd = cst_timerfd$0,
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Epoll_file_desc = cst_Async_unix_Epoll_file_desc$0;
   function sexp_of_t$0(param){
    var epoll_004 = param[2], timerfd_002 = param[1], bnds_001 = 0;
    function _ad_(_ag_){return 0;}
    var
     arg_009 = caml_call1(Sexplib0_Sexp_conv[24], _ad_),
     bnds_001$0 = [0, [1, [0, _a_, [0, arg_009, 0]]], bnds_001];
    function _ae_(_af_){return 0;}
    var
     arg_007 = caml_call1(Sexplib0_Sexp_conv[24], _ae_),
     bnds_001$1 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_001$0],
     arg_005 = caml_call1(Linux_ext[60][2], epoll_004),
     bnds_001$2 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_001$1],
     arg_003 = caml_call1(Linux_ext[35][4], timerfd_002),
     bnds_001$3 = [0, [1, [0, _d_, [0, arg_003, 0]]], bnds_001$2];
    return [1, bnds_001$3];
   }
   function epoll(r){return r[2];}
   function timerfd(r){return r[1];}
   function _e_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _f_ = 0,
    epoll$0 = [0, function(param){return 0;}, cst_epoll, _f_, epoll, _e_];
   function _g_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _h_ = 0,
    timerfd$0 =
      [0, function(param){return 0;}, cst_timerfd, _h_, timerfd, _g_],
    backend = 1;
   function invariant(t){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, t));
        },
      ___ =
        function(epoll){
         function _ab_(param, flags){
          function _ac_(flags$0){return caml_call2(equal, flags, flags$0);}
          if
           (caml_call2
             (Core_List[23],
              [0, in$0, [0, out, [0, in_out, [0, for_timerfd, 0]]]],
              _ac_))
           return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
         }
         return caml_call2(Linux_ext[60][10], epoll, _ab_);
        };
     check
      (function(timerfd){
        var
         _$_ = caml_call1(Linux_ext[35][5], timerfd),
         got = caml_call2(Linux_ext[60][6], t[2], _$_),
         expect = [0, for_timerfd],
         equal = 0,
         message = 0,
         here = 0;
        function sexpifier(x_014){
         return caml_call2(Core[515], sexp_of_t, x_014);
        }
        function comparator(a_010, b_011){
         function _aa_(a_012, b_013){
          return caml_call2(compare, a_012, b_013);
         }
         return caml_call3(Core[509], _aa_, a_010, b_011);
        }
        return caml_call8
                (Ppx_assert_lib_Runtime[3],
                 pos,
                 sexpifier,
                 comparator,
                 here,
                 message,
                 equal,
                 expect,
                 got);
       },
       timerfd$0);
     check(___, epoll$0);
     var _W_ = 0;
     return _W_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _X_ = [0, [1, [0, _i_, [0, sexp_of_t$0(t), 0]]], 0],
      _Y_ = [0, [1, [0, _j_, [0, caml_call1(Core[625], exn), 0]]], _X_],
      _Z_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Epoll_file_descr_watcher_i),
          _Y_]];
     return caml_call1(Core[261], _Z_);
    }
   }
   function create
   (timerfd, num_file_descrs, handle_fd_read_ready, handle_fd_write_ready){
    var
     _Q_ = caml_call1(Async_kernel_config[1][5], Async_unix_Config[10]),
     epoll =
       caml_call3(Core_Or_error[40], Linux_ext[60][4], num_file_descrs, _Q_),
     err_or_hup = caml_call2(symbol, hup, err);
    function handle_fd(read_or_write, handle_fd){
     var bit = 914388854 <= read_or_write ? in$0 : out;
     return function(file_descr, flags){
      var _T_ = caml_call2(do_intersect, flags, bit);
      if(_T_)
       var _U_ = _T_;
      else
       var
        _V_ = caml_call2(do_intersect, flags, err_or_hup),
        _U_ =
          _V_
           ? caml_call2
             (do_intersect,
              caml_call2(Linux_ext[60][7], epoll, file_descr),
              bit)
           : _V_;
      return _U_ ? caml_call1(handle_fd, file_descr) : _U_;};
    }
    var _R_ = caml_call1(Linux_ext[35][5], timerfd);
    caml_call3(Linux_ext[60][8], epoll, _R_, for_timerfd);
    var _S_ = handle_fd(-477700929, handle_fd_write_ready);
    return [0,
            timerfd,
            epoll,
            handle_fd(914388854, handle_fd_read_ready),
            _S_];
   }
   function reset_in_forked_process(t){
    return caml_call1(Linux_ext[60][5], t[2]);
   }
   function iter(t, f){
    function _L_(file_descr, flags){
     var
      _M_ = caml_call1(Linux_ext[35][5], t[1]),
      _N_ = 1 - caml_call2(Core_unix_File_descr[3], file_descr, _M_);
     if(_N_){
      if(caml_call2(do_intersect, flags, in$0))
       caml_call2(f, file_descr, 914388854);
      var _O_ = caml_call2(do_intersect, flags, out);
      if(_O_) return caml_call2(f, file_descr, -477700929);
      var _P_ = _O_;
     }
     else
      var _P_ = _N_;
     return _P_;
    }
    return caml_call2(Linux_ext[60][10], t[2], _L_);
   }
   function set(t, file_descr, desired){
    var
     actual_flags = caml_call2(Linux_ext[60][6], t[2], file_descr),
     _H_ = desired[2],
     desired_flags =
       desired[1] ? _H_ ? [0, in_out] : [0, in$0] : _H_ ? [0, out] : 0;
    if(! actual_flags){
     if(! desired_flags) return 17724;
     var d$0 = desired_flags[1];
     try{caml_call3(Linux_ext[60][8], t[2], file_descr, d$0);}
     catch(_K_){
      var _I_ = caml_wrap_exception(_K_);
      if(_I_[1] === Core_unix[4]){
       var _J_ = _I_[2];
       if(typeof _J_ === "number" && 30 === _J_) return -18684779;
      }
      throw caml_maybe_attach_backtrace(_I_, 0);
     }
     return 17724;
    }
    var a = actual_flags[1];
    if(! desired_flags){
     caml_call2(Linux_ext[60][9], t[2], file_descr);
     return 17724;
    }
    var d = desired_flags[1];
    if(1 - caml_call2(equal, a, d))
     caml_call3(Linux_ext[60][8], t[2], file_descr, d);
    return 17724;
   }
   var sexp_of_t$1 = Core[620], Pre = [0, sexp_of_t$1];
   function pre_check(t){return 0;}
   function sexp_of_t$2(x_019){
    function _F_(param){
     var
      arg1_016 = param[2],
      arg0_015 = param[1],
      res0_017 = caml_call1(Core[625], arg0_015),
      res1_018 = caml_call1(Base_Backtrace[1], arg1_016);
     return [1, [0, res0_017, [0, res1_018, 0]]];
    }
    function _G_(param){return 642269825 <= param ? _l_ : _m_;}
    return caml_call3(Core_Result[15], _G_, _F_, x_019);
   }
   function thread_safe_check(t, param, timeout$0, span_or_unit){
    try{
     var
      epoll = t[2],
      val =
        timeout$0
         ? caml_call2(Linux_ext[60][13], epoll, span_or_unit)
         : caml_call2(Linux_ext[60][12], epoll, -511334242);
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     return [1, [0, e, caml_call1(Base_Backtrace[6][4], 0)]];
    }
    return 642269825 <= val ? timeout : ok;
   }
   function post_check(t, check_result){
    try{
     if(0 === check_result[0])
      var
       _y_ =
         642269825 <= check_result[1]
          ? 0
          : (caml_call2
             (Linux_ext[60][14], t[2], t[4]),
            caml_call2(Linux_ext[60][14], t[2], t[3]),
            caml_call1(Linux_ext[60][16][1], t[2])),
       _z_ = _y_;
     else{
      var match = check_result[1], exn$0 = match[1];
      a:
      {
       b:
       if(exn$0[1] === Core_unix[4]){
        var _A_ = exn$0[2];
        if(typeof _A_ === "number"){if(11 !== _A_) break b;}
        else if(514 !== _A_[1]) break b;
        var _B_ = 0;
        break a;
       }
       var
        backtrace$0 = match[2],
        _C_ =
          [0,
           [1, [0, _r_, [0, caml_call1(Base_Backtrace[1], backtrace$0), 0]]],
           0],
        _D_ = [0, [1, [0, _s_, [0, caml_call1(Core[625], exn$0), 0]]], _C_],
        _E_ =
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_epoll_raised_unexpected_ex),
            _D_]],
        _B_ = caml_call1(Core[261], _E_);
      }
      var _z_ = _B_;
     }
     return _z_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      backtrace = caml_call1(Base_Backtrace[6][4], 0),
      _t_ = [0, [1, [0, _n_, [0, sexp_of_t$0(t), 0]]], 0],
      _u_ = [0, [1, [0, _o_, [0, sexp_of_t$2(check_result), 0]]], _t_],
      _v_ =
        [0,
         [1, [0, _p_, [0, caml_call1(Base_Backtrace[1], backtrace), 0]]],
         _u_],
      _w_ = [0, [1, [0, _q_, [0, caml_call1(Core[625], exn), 0]]], _v_],
      _x_ =
        [1,
         [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Epoll_post_check_bug), _w_]];
     return caml_call1(Core[261], _x_);
    }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Epoll_file_desc);
   var
    Async_unix_Epoll_file_descr_wa =
      [0,
       sexp_of_t$0,
       invariant,
       create,
       backend,
       set,
       iter,
       Pre,
       pre_check,
       [0, sexp_of_t$2],
       thread_safe_check,
       post_check,
       reset_in_forked_process];
   runtime.caml_register_global
    (50, Async_unix_Epoll_file_descr_wa, cst_Async_unix_Epoll_file_desc$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Interruptor
//# unitInfo: Requires: Async_kernel__Debug, Async_unix__Raw_fd, Core, Core__Bytes, Core__Info, Core_unix, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Read_write_pair, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Interruptor$0 = "Async_unix__Interruptor",
    cst_async_unix$0 = "async_unix",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_unix = global_data.Core_unix,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Read_write_pair = global_data.Read_write_pair,
    Async_unix_Raw_fd = global_data.Async_unix__Raw_fd,
    Core_Info = global_data.Core__Info,
    Core_Bytes = global_data.Core__Bytes,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Interruptor$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/interruptor.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "interruptor.ml");
   var
    debug = Async_kernel_Debug[5],
    _e_ = [0, 0],
    cst_Interruptor_clear = "Interruptor.clear",
    _f_ = [0, 1],
    cst_Interruptor_thread_safe_in = "Interruptor.thread_safe_interrupt",
    cst_writing_to_interrupt_pipe_ = "writing to interrupt_pipe_write",
    _d_ = [0, 1],
    cst_interruptor_pipe_read = "interruptor_pipe_read",
    cst_interruptor_pipe_write = "interruptor_pipe_write",
    _a_ = [0, "clearbuffer"],
    _b_ = [0, "already_interrupted"],
    _c_ = [0, "pipe"],
    cst_w = "w",
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Interruptor = cst_Async_unix_Interruptor$0;
   function sexp_of_t(param){
    var
     pipe_002 = param[1],
     already_interrupted_004 = param[2],
     clearbuffer_006 = param[3],
     arg_007 = caml_call1(Sexplib0_Sexp_conv[23], clearbuffer_006),
     bnds_001 = [0, [1, [0, _a_, [0, arg_007, 0]]], 0],
     arg_005 = caml_call1(Core[323], already_interrupted_004),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_005, 0]]], bnds_001],
     arg_003 = caml_call2(Read_write_pair[8], Async_unix_Raw_fd[25], pipe_002),
     bnds_001$1 = [0, [1, [0, _c_, [0, arg_003, 0]]], bnds_001$0];
    return [1, bnds_001$1];
   }
   function invariant(param){return 0;}
   function read_fd(t){
    return caml_call2(Read_write_pair[23], t[1], 914388854);
   }
   function create(create_fd){
    var
     match = caml_call2(Core_unix[117], 0, 0),
     pipe_write = match[2],
     pipe_read = match[1];
    caml_call1(Core_unix[100], pipe_read);
    caml_call1(Core_unix[100], pipe_write);
    var
     pipe_read$0 =
       caml_call3
        (create_fd,
         1,
         pipe_read,
         caml_call1(Core_Info[14], cst_interruptor_pipe_read)),
     pipe_write$0 =
       caml_call3
        (create_fd,
         1,
         pipe_write,
         caml_call1(Core_Info[14], cst_interruptor_pipe_write)),
     _t_ = caml_call2(Core_Bytes[46], 1024, 32);
    return [0,
            caml_call2(Read_write_pair[9], pipe_read$0, pipe_write$0),
            0,
            _t_];
   }
   var bytes_w = caml_call1(Core_Bytes[40], cst_w);
   function thread_safe_interrupt(t){
    if(debug)
     caml_call1(Async_kernel_Debug[16], cst_Interruptor_thread_safe_in);
    var _m_ = 1 - t[2];
    if(! _m_) return _m_;
    t[2] = 1;
    if(debug)
     caml_call1(Async_kernel_Debug[16], cst_writing_to_interrupt_pipe_);
    function _n_(file_descr){
     try{
      caml_call4(Core_unix[282], file_descr, 0, 0, bytes_w);
      var _r_ = 0;
      return _r_;
     }
     catch(_s_){
      var _p_ = caml_wrap_exception(_s_);
      a:
      if(_p_[1] === Core_unix[4]){
       var _q_ = _p_[2];
       if(typeof _q_ === "number"){
        if(2 !== _q_ && 37 !== _q_) break a;
        return 0;
       }
      }
      throw caml_maybe_attach_backtrace(_p_, 0);
     }
    }
    var _o_ = caml_call2(Read_write_pair[23], t[1], -477700929);
    return caml_call3(Async_unix_Raw_fd[41], _d_, _o_, _n_);
   }
   function clear(t){
    if(debug) caml_call1(Async_kernel_Debug[16], cst_Interruptor_clear);
    if(t[2]){
     var
      _g_ =
        function(file_descr){
         for(;;){
          a:
          try{
           caml_call4
            (Core_unix[281],
             file_descr,
             _e_,
             [0, runtime.caml_ml_bytes_length(t[3])],
             t[3]);
           var _k_ = 1, read_again = _k_;
          }
          catch(_l_){
           var _i_ = caml_wrap_exception(_l_);
           b:
           if(_i_[1] === Core_unix[4]){
            var _j_ = _i_[2];
            if(typeof _j_ === "number"){
             if(2 !== _j_ && 37 !== _j_) break b;
             var read_again = 0;
             break a;
            }
           }
           throw caml_maybe_attach_backtrace(_i_, 0);
          }
          if(! read_again) return read_again;
         }
        },
      _h_ = caml_call2(Read_write_pair[23], t[1], 914388854);
     caml_call3(Async_unix_Raw_fd[41], _f_, _h_, _g_);
    }
    t[2] = 0;
    return 0;
   }
   function already_interrupted(t){return t[2];}
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Interruptor);
   var
    Async_unix_Interruptor =
      [0,
       sexp_of_t,
       invariant,
       create,
       read_fd,
       thread_safe_interrupt,
       clear,
       already_interrupted];
   runtime.caml_register_global
    (31, Async_unix_Interruptor, cst_Async_unix_Interruptor$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Io_uring_types_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Io_uring_types_ = "Async_unix__Io_uring_types_intf",
    cst_async_unix = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Io_uring_types_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][1], "src/io_uring_types_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_unix, "io_uring_types_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Io_uring_types_);
   var Async_unix_Io_uring_types_intf = [0];
   runtime.caml_register_global
    (11, Async_unix_Io_uring_types_intf, cst_Async_unix_Io_uring_types_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Io_uring_raw_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Io_uring_raw_in = "Async_unix__Io_uring_raw_intf",
    cst_async_unix = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Io_uring_raw_in);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][1], "src/io_uring_raw_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix, "io_uring_raw_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Io_uring_raw_in);
   var Async_unix_Io_uring_raw_intf = [0];
   runtime.caml_register_global
    (11, Async_unix_Io_uring_raw_intf, cst_Async_unix_Io_uring_raw_in);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Io_uring_raw_null
//# unitInfo: Requires: Async_unix__Import, Core, Core__Int64, Core__Or_error, Core__Result, Core_unix, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Io_uring_raw_nu$0 = "Async_unix__Io_uring_raw_null",
    cst_async_unix$0 = "async_unix",
    cst_src_io_uring_raw_null_ml = "src/io_uring_raw_null.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Core_Or_error = global_data.Core__Or_error,
    Core_unix = global_data.Core_unix,
    Core = global_data.Core,
    Core_Result = global_data.Core__Result,
    Core_Int64 = global_data.Core__Int64,
    Async_unix_Import = global_data.Async_unix__Import,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Io_uring_raw_nu$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_io_uring_raw_null_ml);
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_unix$0, "io_uring_raw_null.ml");
   var
    _w_ = [0, cst_src_io_uring_raw_null_ml, 212, 25],
    _v_ = [0, cst_src_io_uring_raw_null_ml, 211, 23],
    _u_ = [0, cst_src_io_uring_raw_null_ml, 210, 15],
    _t_ = [0, cst_src_io_uring_raw_null_ml, 209, 14],
    _s_ = [0, cst_src_io_uring_raw_null_ml, 208, 16],
    _r_ = [0, cst_src_io_uring_raw_null_ml, 207, 13],
    _q_ = [0, cst_src_io_uring_raw_null_ml, 206, 15],
    _p_ = [0, cst_src_io_uring_raw_null_ml, 205, 14],
    _o_ = [0, cst_src_io_uring_raw_null_ml, 204, 16],
    _n_ = [0, cst_src_io_uring_raw_null_ml, 203, 17],
    _m_ = [0, cst_src_io_uring_raw_null_ml, 202, 15],
    _l_ = [0, cst_src_io_uring_raw_null_ml, 201, 14],
    _k_ = [0, cst_src_io_uring_raw_null_ml, 200, 14],
    _j_ = [0, cst_src_io_uring_raw_null_ml, 199, 13],
    _i_ = [0, cst_src_io_uring_raw_null_ml, 198, 13],
    _h_ = [0, cst_src_io_uring_raw_null_ml, 197, 25],
    _g_ = [0, cst_src_io_uring_raw_null_ml, 196, 29],
    _f_ = [0, cst_src_io_uring_raw_null_ml, 195, 15],
    _e_ = [0, cst_src_io_uring_raw_null_ml, 194, 25],
    _d_ = [0, cst_src_io_uring_raw_null_ml, 193, 13],
    cst_Io_uring_raw_create = "Io_uring_raw.create",
    _c_ = [0, cst_src_io_uring_raw_null_ml, 52, 17],
    _b_ = [0, cst_src_io_uring_raw_null_ml, 10, 17],
    _a_ = [0, cst_src_io_uring_raw_null_ml, 9, 17],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Io_uring_raw_nu = cst_Async_unix_Io_uring_raw_nu$0;
   function of_int(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function to_int(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   var Int63 = [0, of_int, to_int];
   function of_int$0(x){return x;}
   function symbol(_E_, _D_){return _E_ | _D_;}
   function mem(a, b){return caml_call2(Async_unix_Import[3], a & b, a);}
   var Clock = [0], pollin = 0, pollout = 0, pollerr = 0, pollhup = 0;
   function create(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   var
    Flags = [0, of_int$0, symbol, mem, 0, 0, 0, 0, 0, 0, 0],
    compressed = 0,
    immutable = 0,
    append = 0,
    nodump = 0,
    encrypted = 0,
    verity = 0,
    dax = 0;
   function check(param, _C_, _B_){return 0;}
   var
    type = 0,
    mode = 0,
    nlink = 0,
    uid = 0,
    gid = 0,
    atime = 0,
    mtime = 0,
    ctime = 0,
    ino = 0,
    size = 0,
    blocks = 0,
    basic_stats = 0,
    btime = 0,
    mnt_id = 0,
    dioalign = 0;
   function check$0(param, _A_){return 0;}
   function blksize(param){return Core_Int64[58];}
   function attributes(param){return Core_Int64[58];}
   function nlink$0(param){return Core_Int64[58];}
   function uid$0(param){return Core_Int64[58];}
   function gid$0(param){return Core_Int64[58];}
   function ino$0(param){return Core_Int64[58];}
   function size$0(param){return Core_Int64[58];}
   function blocks$0(param){return Core_Int64[58];}
   function attributes_mask(param){return Core_Int64[58];}
   function rdev(param){return Core_Int64[58];}
   function dev(param){return Core_Int64[58];}
   function mask(param){return Core_Int64[58];}
   function mnt_id$0(param){return Core_Int64[58];}
   function dio_mem_align(param){return Core_Int64[58];}
   function dio_offset_align(param){return Core_Int64[58];}
   function atime_sec(param){return Core_Int64[58];}
   function btime_sec(param){return Core_Int64[58];}
   function ctime_sec(param){return Core_Int64[58];}
   function mtime_sec(param){return Core_Int64[58];}
   function atime_nsec(param){return 0;}
   function btime_nsec(param){return 0;}
   function ctime_nsec(param){return 0;}
   function mtime_nsec(param){return 0;}
   function mode$0(param){return 0;}
   function perm(param){return 0;}
   function kind(param){return 785140586;}
   function sexp_of_t(x_001){
    return caml_call3(Core_Result[15], Core[389], Core_unix[3][3], x_001);
   }
   var Syscall_result = [0, sexp_of_t];
   function invariant(param){return 0;}
   var
    Handle = [0, invariant],
    Open_flags =
      [0,
       of_int$0,
       symbol,
       mem,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0],
    Resolve = [0, of_int$0, symbol, mem, 0, 0, 0, 0, 0, 0, 0];
   function create$0(param, _z_, _y_){
    return caml_call1(Core_Or_error[52], cst_Io_uring_raw_create);
   }
   function exit(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
   }
   function supports_ext_arg(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function submit(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function cqe_ready(param, _x_){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   function fill_completions(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   }
   function noop(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   }
   function read(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function write(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function readv(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
   }
   function writev(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
   }
   function poll_add(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   function openat2(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
   }
   function close(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
   }
   function unlink(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
   }
   function link(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
   }
   function timeout(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
   }
   function statx(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
   }
   function cancel(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
   }
   function syscall_result(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
   }
   function register_eventfd(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Io_uring_raw_nu);
   var
    Async_unix_Io_uring_raw_null =
      [0,
       Int63,
       [0, of_int$0, symbol, mem, pollin, pollout, pollerr, pollhup],
       Clock,
       [0,
        create,
        Flags,
        [0,
         of_int$0,
         symbol,
         mem,
         compressed,
         immutable,
         append,
         nodump,
         encrypted,
         verity,
         dax,
         check],
        [0,
         of_int$0,
         symbol,
         mem,
         type,
         mode,
         nlink,
         uid,
         gid,
         atime,
         mtime,
         ctime,
         ino,
         size,
         blocks,
         basic_stats,
         btime,
         mnt_id,
         dioalign,
         check$0],
        blksize,
        attributes,
        nlink$0,
        uid$0,
        gid$0,
        ino$0,
        size$0,
        blocks$0,
        attributes_mask,
        rdev,
        dev,
        mask,
        mnt_id$0,
        dio_mem_align,
        dio_offset_align,
        atime_sec,
        btime_sec,
        ctime_sec,
        mtime_sec,
        atime_nsec,
        btime_nsec,
        ctime_nsec,
        mtime_nsec,
        mode$0,
        perm,
        kind],
       Open_flags,
       Resolve,
       Syscall_result,
       Handle,
       create$0,
       supports_ext_arg,
       exit,
       register_eventfd,
       submit,
       cqe_ready,
       fill_completions,
       noop,
       read,
       write,
       readv,
       writev,
       poll_add,
       openat2,
       close,
       link,
       unlink,
       timeout,
       statx,
       cancel,
       syscall_result];
   runtime.caml_register_global
    (42, Async_unix_Io_uring_raw_null, cst_Async_unix_Io_uring_raw_nu$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Io_uring_raw
//# unitInfo: Requires: Async_unix__Io_uring_raw_null, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Io_uring_raw = "Async_unix__Io_uring_raw",
    cst_async_unix = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_unix_Io_uring_raw_null = global_data.Async_unix__Io_uring_raw_null;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Io_uring_raw);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][1], "src/io_uring_raw.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix, "io_uring_raw.ml");
   var
    Int63 = Async_unix_Io_uring_raw_null[1],
    Poll_mask = Async_unix_Io_uring_raw_null[2],
    Clock = Async_unix_Io_uring_raw_null[3],
    Statx = Async_unix_Io_uring_raw_null[4],
    Open_flags = Async_unix_Io_uring_raw_null[5],
    Resolve = Async_unix_Io_uring_raw_null[6],
    Syscall_result = Async_unix_Io_uring_raw_null[7],
    Handle = Async_unix_Io_uring_raw_null[8],
    create = Async_unix_Io_uring_raw_null[9],
    supports_ext_arg = Async_unix_Io_uring_raw_null[10],
    exit = Async_unix_Io_uring_raw_null[11],
    register_eventfd = Async_unix_Io_uring_raw_null[12],
    submit = Async_unix_Io_uring_raw_null[13],
    cqe_ready = Async_unix_Io_uring_raw_null[14],
    fill_completions = Async_unix_Io_uring_raw_null[15],
    noop = Async_unix_Io_uring_raw_null[16],
    read = Async_unix_Io_uring_raw_null[17],
    write = Async_unix_Io_uring_raw_null[18],
    readv = Async_unix_Io_uring_raw_null[19],
    writev = Async_unix_Io_uring_raw_null[20],
    poll_add = Async_unix_Io_uring_raw_null[21],
    openat2 = Async_unix_Io_uring_raw_null[22],
    close = Async_unix_Io_uring_raw_null[23],
    link = Async_unix_Io_uring_raw_null[24],
    unlink = Async_unix_Io_uring_raw_null[25],
    timeout = Async_unix_Io_uring_raw_null[26],
    statx = Async_unix_Io_uring_raw_null[27],
    cancel = Async_unix_Io_uring_raw_null[28],
    syscall_result = Async_unix_Io_uring_raw_null[29];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Io_uring_raw);
   var
    Async_unix_Io_uring_raw =
      [0,
       Int63,
       Poll_mask,
       Clock,
       Statx,
       Open_flags,
       Resolve,
       Syscall_result,
       Handle,
       create,
       supports_ext_arg,
       exit,
       register_eventfd,
       submit,
       cqe_ready,
       fill_completions,
       noop,
       read,
       write,
       readv,
       writev,
       poll_add,
       openat2,
       close,
       link,
       unlink,
       timeout,
       statx,
       cancel,
       syscall_result];
   runtime.caml_register_global
    (12, Async_unix_Io_uring_raw, cst_Async_unix_Io_uring_raw);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Io_uring_file_descr_watcher
//# unitInfo: Requires: Async_kernel__Deferred, Async_unix__Import, Async_unix__Io_uring_raw, Base__Field, Bounded_int_table, Core, Core__List, Core_unix, Core_unix__File_descr, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Time_ns_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Io_uring_file_d$0 =
      "Async_unix__Io_uring_file_descr_watcher",
    cst_async_unix$0 = "async_unix",
    cst_src_io_uring_file_descr_wa = "src/io_uring_file_descr_watcher.ml",
    cst_states$0 = "states",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Bounded_int_table = global_data.Bounded_int_table,
    Core_unix = global_data.Core_unix,
    Core = global_data.Core,
    Async_unix_Import = global_data.Async_unix__Import,
    Async_unix_Io_uring_raw = global_data.Async_unix__Io_uring_raw,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Time_ns_unix = global_data.Time_ns_unix,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_unix_File_descr = global_data.Core_unix__File_descr,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Io_uring_file_d$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_io_uring_file_descr_wa);
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_async_unix$0,
     "io_uring_file_descr_watcher.ml");
   var
    include = Async_unix_Io_uring_raw[2],
    of_int = include[1],
    symbol = include[2],
    mem = include[3],
    pollin = include[4],
    pollout = include[5],
    pollerr = include[6],
    pollhup = include[7],
    cst_Attempted_to_remove_pollin =
      "Attempted to remove polling for a file descriptor that was not being polled",
    cst_Cannot_create_an_Ocaml_uri =
      "Cannot create an Ocaml_uring file descriptor watcher if IORING_FEAT_EXT_ARG is not supported because then it is not thread safe.",
    _g_ = [0, "io_uring_file_descr_watcher"],
    _h_ = [0, "exn"],
    cst_Io_uring_file_descr_watche =
      "Io_uring_file_descr_watcher.invariant failed",
    _i_ = [0, cst_src_io_uring_file_descr_wa, 41, 13],
    _a_ = [0, "handle_fd_write_ready"],
    _b_ = [0, "handle_fd_read_ready"],
    _c_ = [0, cst_states$0],
    _d_ = [0, "uring"],
    cst_states = cst_states$0,
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Io_uring_file_d = cst_Async_unix_Io_uring_file_d$0;
   function sexp_of_t(param){
    var states_004 = param[2], uring_002 = param[1], bnds_001 = 0;
    function _N_(_Q_){return 0;}
    var
     arg_009 = caml_call1(Sexplib0_Sexp_conv[24], _N_),
     bnds_001$0 = [0, [1, [0, _a_, [0, arg_009, 0]]], bnds_001];
    function _O_(_P_){return 0;}
    var
     arg_007 = caml_call1(Sexplib0_Sexp_conv[24], _O_),
     bnds_001$1 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_001$0],
     arg_005 = caml_call1(Sexplib0_Sexp_conv[23], states_004),
     bnds_001$2 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_001$1],
     arg_003 = caml_call1(Sexplib0_Sexp_conv[23], uring_002),
     bnds_001$3 = [0, [1, [0, _d_, [0, arg_003, 0]]], bnds_001$2];
    return [1, bnds_001$3];
   }
   function states(r){return r[2];}
   function _e_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _f_ = 0,
    states$0 = [0, function(param){return 0;}, cst_states, _f_, states, _e_],
    backend = 3;
   function invariant(t){
    try{
     var
      states = caml_call2(Base_Field[3], states$0, t),
      _J_ =
        function(param){
         var flags = param[2];
         function _K_(flags$0){
          var _M_ = caml_call2(mem, flags$0, flags);
          return _M_ ? caml_call2(mem, flags, flags$0) : _M_;
         }
         var
          _L_ =
            [0,
             pollin,
             [0, pollout, [0, caml_call2(symbol, pollin, pollout), 0]]];
         if(caml_call2(Core_List[23], _L_, _K_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
        };
     caml_call2(Bounded_int_table[14], states, _J_);
     var _F_ = 0;
     return _F_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _G_ = [0, [1, [0, _g_, [0, sexp_of_t(t), 0]]], 0],
      _H_ = [0, [1, [0, _h_, [0, caml_call1(Core[625], exn), 0]]], _G_],
      _I_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Io_uring_file_descr_watche),
          _H_]];
     return caml_call1(Core[261], _I_);
    }
   }
   function create
   (uring, num_file_descrs, handle_fd_read_ready, handle_fd_write_ready){
    if(1 - caml_call1(Async_unix_Io_uring_raw[10], uring)){
     var
      _y_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Cannot_create_an_Ocaml_uri);
     caml_call1(Core[261], _y_);
    }
    var
     states =
       caml_call4
        (Bounded_int_table[4],
         [0, Core_unix_File_descr[2]],
         num_file_descrs,
         Core_unix_File_descr[15],
         0);
    function handle_fd(read_or_write, handle_fd){
     var bit = 914388854 <= read_or_write ? pollin : pollout;
     return function(file_descr, flags){
      var _A_ = caml_call2(mem, bit, flags);
      if(_A_)
       var _B_ = _A_;
      else{
       var
        _C_ = caml_call2(mem, pollerr, flags),
        _D_ = _C_ || caml_call2(mem, pollhup, flags);
       if(_D_){
        var match = caml_call2(Bounded_int_table[9], states, file_descr);
        if(match)
         var flags$0 = match[1][2], _E_ = caml_call2(mem, bit, flags$0);
        else
         var _E_ = 0;
        var _B_ = _E_;
       }
       else
        var _B_ = _D_;
      }
      return _B_ ? caml_call1(handle_fd, file_descr) : _B_;};
    }
    var _z_ = handle_fd(-477700929, handle_fd_write_ready);
    return [0, uring, states, handle_fd(914388854, handle_fd_read_ready), _z_];
   }
   function reset_in_forked_process(param){return 0;}
   function iter(t, f){
    function _w_(file_descr, param){
     var flags = param[2];
     if(caml_call2(mem, pollin, flags)) caml_call2(f, file_descr, 914388854);
     var _x_ = caml_call2(mem, pollout, flags);
     return _x_ ? caml_call2(f, file_descr, -477700929) : _x_;
    }
    return caml_call2(Bounded_int_table[15], t[2], _w_);
   }
   function add_poll(t, file_descr, flags){
    var
     handle = caml_call3(Async_unix_Io_uring_raw[21], t[1], file_descr, flags);
    caml_call3(Bounded_int_table[30], t[2], file_descr, [0, handle, flags]);
    function _q_(res){
     var match = caml_call2(Bounded_int_table[9], t[2], file_descr);
     if(! match) return caml_call1(Async_unix_Import[30], 0);
     var match$0 = match[1], flags = match$0[2], running_job = match$0[1];
     if(running_job === handle)
      if(0 === res[0]){
       var res$0 = res[1], _t_ = caml_call1(of_int, res$0);
       caml_call2(t[3], file_descr, _t_);
       var _u_ = caml_call1(of_int, res$0);
       caml_call2(t[4], file_descr, _u_);
       add_poll(t, file_descr, flags);
      }
      else{
       var err = res[1];
       a:
       {
        if(typeof err !== "number" && 125 === err[1]) break a;
        var _v_ = caml_call1(Core_unix[3][5], err);
        caml_call1(Core[6], _v_);
       }
      }
     return caml_call1(Async_unix_Import[30], 0);
    }
    var
     _r_ = caml_call1(Async_unix_Io_uring_raw[29], handle),
     _s_ = caml_call2(Async_unix_Import[33][2], _r_, _q_);
    return caml_call1(Async_kernel_Deferred[25], _s_);
   }
   function remove_poll_exn(t, file_descr){
    var match = caml_call2(Bounded_int_table[9], t[2], file_descr);
    if(match){
     var running_job = match[1][1];
     caml_call2(Bounded_int_table[29], t[2], file_descr);
     var _o_ = caml_call2(Async_unix_Io_uring_raw[28], t[1], running_job);
     return caml_call1(Async_kernel_Deferred[25], _o_);
    }
    var
     _p_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Attempted_to_remove_pollin);
    return caml_call1(Core[261], _p_);
   }
   function set(t, file_descr, desired){
    var match = caml_call2(Bounded_int_table[9], t[2], file_descr);
    if(match)
     var flags = match[1][2], actual_flags = [0, flags];
    else
     var actual_flags = 0;
    var
     _l_ = desired[2],
     desired_flags =
       desired[1]
        ? _l_ ? [0, caml_call2(symbol, pollin, pollout)] : [0, pollin]
        : _l_ ? [0, pollout] : 0;
    if(! actual_flags){
     if(! desired_flags) return 17724;
     var d$0 = desired_flags[1];
     add_poll(t, file_descr, d$0);
     return 17724;
    }
    var a = actual_flags[1];
    if(! desired_flags){remove_poll_exn(t, file_descr); return 17724;}
    var
     d = desired_flags[1],
     _m_ = caml_call2(mem, a, d),
     _n_ = _m_ ? caml_call2(mem, d, a) : _m_;
    if(1 - _n_){remove_poll_exn(t, file_descr); add_poll(t, file_descr, d);}
    return 17724;
   }
   var sexp_of_t$0 = Core[620], Pre = [0, sexp_of_t$0];
   function pre_check(t){
    caml_call1(Async_unix_Io_uring_raw[13], t[1]);
    return 0;
   }
   var sexp_of_t$1 = Core[323], Check_result = [0, sexp_of_t$1];
   function thread_safe_check(t, param, timeout, span_or_unit){
    if(! timeout) return 1;
    var _k_ = caml_call1(Time_ns_unix[72][89], span_or_unit);
    return caml_call2(Async_unix_Io_uring_raw[14], t[1], _k_);
   }
   function post_check(t, ready){
    var
     _j_ = ready ? (caml_call1(Async_unix_Io_uring_raw[15], t[1]), 0) : ready;
    return _j_;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Io_uring_file_d);
   var
    Async_unix_Io_uring_file_descr =
      [0,
       sexp_of_t,
       invariant,
       create,
       backend,
       set,
       iter,
       Pre,
       pre_check,
       Check_result,
       thread_safe_check,
       post_check,
       reset_in_forked_process];
   runtime.caml_register_global
    (37, Async_unix_Io_uring_file_descr, cst_Async_unix_Io_uring_file_d$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Select_file_descr_watcher
//# unitInfo: Requires: Async_unix__Syscall, Bounded_int_table, Core, Core__List, Core__Result, Core_unix, Core_unix__File_descr, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Read_write_pair, Sexplib0__Sexp_conv, Time_ns_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Select_file_des$0 = "Async_unix__Select_file_descr_watcher",
    cst_async_unix$0 = "async_unix",
    cst_exn = "exn",
    cst_select_file_descr_watcher = "select_file_descr_watcher",
    cst_src_select_file_descr_watc = "src/select_file_descr_watcher.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_unix_File_descr = global_data.Core_unix__File_descr,
    Core_unix = global_data.Core_unix,
    Async_unix_Syscall = global_data.Async_unix__Syscall,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Time_ns_unix = global_data.Time_ns_unix,
    Core_Result = global_data.Core__Result,
    Bounded_int_table = global_data.Bounded_int_table,
    Read_write_pair = global_data.Read_write_pair,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Select_file_des$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_select_file_descr_watc);
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_unix$0, "select_file_descr_watcher.ml");
   var
    _j_ = [0, cst_select_file_descr_watcher],
    _k_ = [0, "check_result"],
    _l_ = [0, cst_exn],
    cst_File_descr_watcher_post_ch = "File_descr_watcher.post_check bug",
    cst_select_raised_unexpected_e = "select raised unexpected exn",
    _n_ = [0, cst_exn],
    _o_ = [0, "file_descr"],
    cst_fstat_raised_unexpected_ex = "fstat raised unexpected exn",
    _m_ = [0, cst_src_select_file_descr_watc, 104, 6],
    _h_ = [0, "select_result"],
    _i_ = [0, "pre"],
    _f_ = [0, cst_select_file_descr_watcher],
    _g_ = [0, cst_exn],
    cst_Select_file_descr_watcher_ =
      "Select_file_descr_watcher.invariant failed",
    _a_ = [0, "handle_fd_write_bad"],
    _b_ = [0, "handle_fd_write_ready"],
    _c_ = [0, "handle_fd_read_bad"],
    _d_ = [0, "handle_fd_read_ready"],
    _e_ = [0, "descr_tables"],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Select_file_des = cst_Async_unix_Select_file_des$0;
   function sexp_of_t(param){
    var descr_tables_002 = param[1], bnds_001 = 0;
    function _Y_(_ae_){return 0;}
    var
     arg_011 = caml_call1(Sexplib0_Sexp_conv[24], _Y_),
     bnds_001$0 = [0, [1, [0, _a_, [0, arg_011, 0]]], bnds_001];
    function _Z_(_ad_){return 0;}
    var
     arg_009 = caml_call1(Sexplib0_Sexp_conv[24], _Z_),
     bnds_001$1 = [0, [1, [0, _b_, [0, arg_009, 0]]], bnds_001$0];
    function ___(_ac_){return 0;}
    var
     arg_007 = caml_call1(Sexplib0_Sexp_conv[24], ___),
     bnds_001$2 = [0, [1, [0, _c_, [0, arg_007, 0]]], bnds_001$1];
    function _$_(_ab_){return 0;}
    var
     arg_005 = caml_call1(Sexplib0_Sexp_conv[24], _$_),
     bnds_001$3 = [0, [1, [0, _d_, [0, arg_005, 0]]], bnds_001$2],
     _aa_ =
       caml_call2(Bounded_int_table[1], Core_unix_File_descr[2], Core[620]),
     arg_003 = caml_call2(Read_write_pair[8], _aa_, descr_tables_002),
     bnds_001$4 = [0, [1, [0, _e_, [0, arg_003, 0]]], bnds_001$3];
    return [1, bnds_001$4];
   }
   var backend = 2;
   function invariant(t){
    try{
     var
      _S_ = function(_X_){return 0;},
      _T_ = function(_W_){return 0;},
      _U_ = caml_call2(Bounded_int_table[2], _T_, _S_),
      _V_ = caml_call2(Read_write_pair[18], t[1], _U_);
     return _V_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _P_ = [0, [1, [0, _f_, [0, sexp_of_t(t), 0]]], 0],
      _Q_ = [0, [1, [0, _g_, [0, caml_call1(Core[625], exn), 0]]], _P_],
      _R_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Select_file_descr_watcher_),
          _Q_]];
     return caml_call1(Core[261], _R_);
    }
   }
   function create
   (handle_fd_read_bad,
    handle_fd_write_bad,
    num_file_descrs,
    handle_fd_read_ready,
    handle_fd_write_ready){
    function _O_(param){
     return caml_call4
             (Bounded_int_table[4],
              [0, Core_unix_File_descr[2]],
              num_file_descrs,
              Core_unix_File_descr[15],
              0);
    }
    return [0,
            caml_call1(Read_write_pair[12], _O_),
            handle_fd_read_ready,
            handle_fd_read_bad,
            handle_fd_write_ready,
            handle_fd_write_bad];
   }
   function reset_in_forked_process(param){return 0;}
   function iter(t, f){
    function _M_(read_or_write, table){
     function _N_(key, param){return caml_call2(f, key, read_or_write);}
     return caml_call2(Bounded_int_table[15], table, _N_);
    }
    return caml_call2(Read_write_pair[17], t[1], _M_);
   }
   function sexp_of_t$0(x_012){
    var _L_ = caml_call1(Core[472], Core_unix_File_descr[2]);
    return caml_call2(Read_write_pair[8], _L_, x_012);
   }
   var Pre = [0, sexp_of_t$0];
   function set(t, file_descr, desired){
    function _K_(read_or_write, table){
     return caml_call2(Read_write_pair[23], desired, read_or_write)
             ? caml_call3(Bounded_int_table[30], table, file_descr, 0)
             : caml_call2(Bounded_int_table[29], table, file_descr);
    }
    caml_call2(Read_write_pair[17], t[1], _K_);
    return 17724;
   }
   function pre_check(t){
    return caml_call2(Read_write_pair[20], t[1], Bounded_int_table[7]);
   }
   function sexp_of_t$1(param){
    var
     select_result_016 = param[2],
     pre_014 = param[1],
     arg_017 =
       caml_call3
        (Core_Result[15], Core_unix[136][1], Core[625], select_result_016),
     bnds_013 = [0, [1, [0, _h_, [0, arg_017, 0]]], 0],
     arg_015 = caml_call1(Pre[1], pre_014),
     bnds_013$0 = [0, [1, [0, _i_, [0, arg_015, 0]]], bnds_013];
    return [1, bnds_013$0];
   }
   var Check_result = [0, sexp_of_t$1];
   function thread_safe_check(param, pre, timeout, span){
    var
     timeout$0 =
       timeout
        ? [0,
          818927100,
          caml_call2(Time_ns_unix[72][23], span, Time_ns_unix[72][71])]
        : -511334242;
    function _J_(param){
     return caml_call6(Core_unix[138], 0, pre[1], pre[2], 0, timeout$0, 0);
    }
    return [0, pre, caml_call1(Core_Result[54], _J_)];
   }
   function post_check(t, check_result){
    var select_result = check_result[2], pre = check_result[1];
    try{
     if(0 === select_result[0]){
      var
       match = select_result[1],
       except = match[3],
       write = match[2],
       read = match[1];
      if(! caml_call1(Core_List[18], except))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
      caml_call2(Core_List[19], write, t[4]);
      var _t_ = caml_call2(Core_List[19], read, t[2]);
     }
     else{
      var exn$0 = select_result[1];
      a:
      {
       b:
       if(exn$0[1] === Core_unix[4]){
        var _u_ = exn$0[2];
        c:
        {
         if(typeof _u_ === "number"){
          if(3 === _u_){
           var
            bad =
              function(read_or_write){
               var fds = 914388854 <= read_or_write ? pre[1] : pre[2];
               function _D_(ac, file_descr){
                function _E_(param){
                 caml_call1(Core_unix[75], file_descr);
                 return 0;
                }
                var match = caml_call1(Async_unix_Syscall[1], _E_);
                if(0 === match[0]) return ac;
                var exn = match[1];
                if(exn[1] === Core_unix[4]){
                 var _F_ = exn[2];
                 if(typeof _F_ === "number" && 3 === _F_)
                  return [0, file_descr, ac];
                }
                var
                 _G_ =
                   [0, [1, [0, _n_, [0, caml_call1(Core[625], exn), 0]]], 0],
                 _H_ =
                   [0,
                    [1,
                     [0,
                      _o_,
                      [0, caml_call1(Core_unix_File_descr[2], file_descr), 0]]],
                    _G_],
                 _I_ =
                   [1,
                    [0,
                     caml_call1
                      (Sexplib0_Sexp_conv[7], cst_fstat_raised_unexpected_ex),
                     _H_]];
                return caml_call1(Core[261], _I_);
               }
               return caml_call3(Core_List[20], fds, 0, _D_);
              },
            _v_ = t[5],
            _w_ = bad(-477700929);
           caml_call2(Core_List[19], _w_, _v_);
           var
            _x_ = t[3],
            _y_ = bad(914388854),
            _z_ = caml_call2(Core_List[19], _y_, _x_);
           break c;
          }
          if(11 !== _u_) break b;
         }
         else if(514 !== _u_[1]) break b;
         var _z_ = 0;
        }
        var _A_ = _z_;
        break a;
       }
       var
        _B_ = [0, caml_call1(Core[625], exn$0), 0],
        _C_ =
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_select_raised_unexpected_e),
            _B_]],
        _A_ = caml_call1(Core[261], _C_);
      }
      var _t_ = _A_;
     }
     return _t_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _p_ = [0, [1, [0, _j_, [0, sexp_of_t(t), 0]]], 0],
      _q_ =
        [0,
         [1, [0, _k_, [0, caml_call1(Check_result[1], check_result), 0]]],
         _p_],
      _r_ = [0, [1, [0, _l_, [0, caml_call1(Core[625], exn), 0]]], _q_],
      _s_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_File_descr_watcher_post_ch),
          _r_]];
     return caml_call1(Core[261], _s_);
    }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Select_file_des);
   var
    Async_unix_Select_file_descr_w =
      [0,
       sexp_of_t,
       invariant,
       create,
       backend,
       set,
       iter,
       Pre,
       pre_check,
       Check_result,
       thread_safe_check,
       post_check,
       reset_in_forked_process];
   runtime.caml_register_global
    (41, Async_unix_Select_file_descr_w, cst_Async_unix_Select_file_des$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Raw_signal_manager
//# unitInfo: Requires: Core, Core__Hashtbl, Core__Signal, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Raw_signal_mana$0 = "Async_unix__Raw_signal_manager",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Thread_safe_queue = global_data.Thread_safe_queue,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core = global_data.Core,
    Core_Signal = global_data.Core__Signal,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Raw_signal_mana$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/raw_signal_manager.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_unix$0, "raw_signal_manager.ml");
   var
    _a_ = [0, "thread_safe_notify_signal_delivered"],
    _b_ = [0, "delivered"],
    _c_ = [0, "original_dispositions_of_managed_signals"],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Raw_signal_mana = cst_Async_unix_Raw_signal_mana$0;
   function sexp_of_t(param){
    var
     delivered_004 = param[2],
     original_dispositions_of_manag = param[1],
     bnds_001 = 0;
    function _h_(_i_){return 0;}
    var
     arg_007 = caml_call1(Sexplib0_Sexp_conv[24], _h_),
     bnds_001$0 = [0, [1, [0, _a_, [0, arg_007, 0]]], bnds_001],
     arg_005 = caml_call1(Sexplib0_Sexp_conv[23], delivered_004),
     bnds_001$1 = [0, [1, [0, _b_, [0, arg_005, 0]]], bnds_001$0],
     arg_003 =
       caml_call2
        (Core_Signal[35][2],
         Core_Signal[88][1],
         original_dispositions_of_manag),
     bnds_001$2 = [0, [1, [0, _c_, [0, arg_003, 0]]], bnds_001$1];
    return [1, bnds_001$2];
   }
   function invariant(param){return 0;}
   function create(thread_safe_notify_signal_deli){
    var _g_ = caml_call1(Thread_safe_queue[3], 0);
    return [0,
            caml_call3(Core_Signal[35][5], 0, 0, 0),
            _g_,
            thread_safe_notify_signal_deli];
   }
   function is_managing(t, signal){
    return caml_call2(Core_Hashtbl[31], t[1], signal);
   }
   function manage(t, signal){
    function _e_(param){
     var
      _f_ =
        [0,
         -325978168,
         function(param){
          caml_call2(Thread_safe_queue[5], t[2], signal);
          return caml_call1(t[3], 0);
         }];
     return caml_call2(Core_Signal[88][2], signal, _f_);
    }
    caml_call3(Core_Hashtbl[54], t[1], signal, _e_);
    return 0;
   }
   function iter_delivered(t, f){
    for(;;){
     var _d_ = caml_call1(Thread_safe_queue[4], t[2]);
     if(! caml_call2(Core[91], _d_, 0)) return 0;
     var
      signal = caml_call1(Thread_safe_queue[6], t[2]),
      original_disposition = caml_call2(Core_Hashtbl[57], t[1], signal);
     caml_call2(f, original_disposition, signal);
    }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Raw_signal_mana);
   var
    Async_unix_Raw_signal_manager =
      [0, sexp_of_t, invariant, create, manage, is_managing, iter_delivered];
   runtime.caml_register_global
    (19, Async_unix_Raw_signal_manager, cst_Async_unix_Raw_signal_mana$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Shutdown
//# unitInfo: Requires: Async_kernel__Debug, Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel__Monitor, Async_unix__Clock, Async_unix__Import, Base__Backtrace, Base__Exn, Core, Core__Debug, Core__Error, Core__List, Core__Or_error, Core__Signal, Core_unix, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Signal_unix, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Shutdown$0 = "Async_unix__Shutdown",
    cst_Caml_exit_raised$1 = "Caml.exit raised",
    cst_async_unix$0 = "async_unix",
    cst_src_shutdown_ml = "src/shutdown.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Async_unix_Import = global_data.Async_unix__Import,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core = global_data.Core,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_Signal = global_data.Core__Signal,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Error = global_data.Core__Error,
    Core_Debug = global_data.Core__Debug,
    Core_Or_error = global_data.Core__Or_error,
    Assert_failure = global_data.Assert_failure,
    Core_List = global_data.Core__List,
    Base_Exn = global_data.Base__Exn,
    Core_unix = global_data.Core_unix,
    Match_failure = global_data.Match_failure,
    Stdlib = global_data.Stdlib,
    Signal_unix = global_data.Signal_unix,
    Async_unix_Clock = global_data.Async_unix__Clock,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Shutdown$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_shutdown_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "shutdown.ml");
   var
    cst_shutting_down_due_to_unhan =
      "shutting down due to unhandled exception",
    _m_ = [0, "Stop"],
    _n_ = [0, "Ignore"],
    _l_ = [0, "Continue"],
    _o_ = [0, "default_sys_behavior"],
    _p_ = [0, "signal"],
    cst_Shutdown_shutdown_with_sig =
      "Shutdown.shutdown_with_signal_exn: not a terminating signal",
    cst_Shutdown_forced = "Shutdown forced.",
    _k_ = [0, 1],
    cst_one_at_shutdown_function_f = "one at_shutdown function finished",
    cst_at_shutdown_function_raise = "at_shutdown function raised",
    _j_ = [0, 3804260],
    _h_ = [0, 1],
    _i_ = [0, cst_src_shutdown_ml, 124, 16],
    _f_ = [0, "prior"],
    _g_ = [0, "status"],
    cst_shutdown_with_inconsistent = "shutdown with inconsistent status",
    cst_shutdown = "shutdown",
    cst_Signal_unix_send_exn_faile =
      "Signal_unix.send_exn failed to kill process",
    cst_Caml_exit_raised$0 = cst_Caml_exit_raised$1,
    cst_Caml_exit_raised = cst_Caml_exit_raised$1,
    _e_ = [0, cst_src_shutdown_ml, 69, 4],
    cst_at_shutdown = "at_shutdown",
    _c_ = [0, "Yes"],
    _d_ = [0, "No"],
    _a_ = [0, "Exit"],
    _b_ = [0, "Signal"],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Shutdown = cst_Async_unix_Shutdown$0;
   function sexp_of_t(param){
    if(0 === param[0]){
     var arg0_007 = param[1], res0_008 = caml_call1(Core[389], arg0_007);
     return [1, [0, _a_, [0, res0_008, 0]]];
    }
    var arg0_009 = param[1], res0_010 = caml_call1(Core_Signal[10], arg0_009);
    return [1, [0, _b_, [0, res0_010, 0]]];
   }
   function sexp_of_t$0(param){
    if(! param) return _d_;
    var arg0_011 = param[1], res0_012 = sexp_of_t(arg0_011);
    return [1, [0, _c_, [0, res0_012, 0]]];
   }
   var
    Maybe_status = [0, sexp_of_t$0],
    debug = Async_kernel_Debug[11],
    todo = [0, 0];
   function at_shutdown(f){
    var backtrace = caml_call2(Base_Backtrace[2], 0, 0);
    if(debug)
     caml_call3
      (Async_kernel_Debug[15], cst_at_shutdown, backtrace, Base_Backtrace[1]);
    todo[1] = [0, [0, backtrace, f], todo[1]];
    return 0;
   }
   var
    shutting_down_ref = [0, 0],
    default_force_ref =
      [0,
       function(param){
        var _P_ = caml_call1(Core[630], 10.);
        return caml_call1(Async_unix_Clock[4], _P_);
       }];
   function default_force(param){return default_force_ref[1];}
   function set_default_force(force){default_force_ref[1] = force; return 0;}
   function shutting_down(param){return shutting_down_ref[1];}
   function is_shutting_down(param){return shutting_down(0) ? 1 : 0;}
   function ignore_exn(f){try{caml_call1(f, 0); return;}catch(_O_){return;}}
   function exit_reliably(status){
    if(0 === status[0]){
     var code = status[1];
     try{caml_call1(Core[83], code);}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      ignore_exn
       (function(param){
         return caml_call3
                 (Core_Debug[2], cst_Caml_exit_raised, exn, Base_Exn[1]);
        });
      var _M_ = caml_call2(Async_unix_Import[3], code, 0) ? 1 : code;
      return caml_call1(Core_unix[274], _M_);
     }
     throw caml_maybe_attach_backtrace([0, Match_failure, _e_], 1);
    }
    var signal = status[1];
    try{caml_call1(Stdlib[103], 0);}
    catch(exn){
     var exn$0 = caml_wrap_exception(exn);
     ignore_exn
      (function(param){
        return caml_call3
                (Core_Debug[2], cst_Caml_exit_raised$0, exn$0, Base_Exn[1]);
       });
    }
    caml_call2(Core_Signal[88][3], signal, -384499551);
    var _N_ = [0, 4001835, caml_call1(Core_unix[34], 0)];
    caml_call2(Signal_unix[6], signal, _N_);
    ignore_exn
     (function(param){
       return caml_call3
               (Core_Debug[2],
                cst_Signal_unix_send_exn_faile,
                signal,
                Core_Signal[10]);
      });
    return caml_call1(Core_unix[274], 1);
   }
   function shutdown_with_status(force, status){
    if(debug)
     ignore_exn
      (function(param){
        return caml_call3
                (Async_kernel_Debug[15], cst_shutdown, status, sexp_of_t);
       });
    var match = shutting_down_ref[1];
    if(! match){
     shutting_down_ref[1] = [0, status];
     var
      _E_ =
        function(results){
         var match = shutting_down(0);
         if(! match)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
         var status = match[1];
         a:
         if(0 === caml_call1(Core_Or_error[57], results)[0])
          var status$0 = status;
         else{
          if(0 === status[0] && 0 === status[1]){var status$0 = _h_; break a;}
          var status$0 = status;
         }
         return exit_reliably(status$0);
        },
      _F_ =
        function(param){
         var f = param[2], backtrace = param[1];
         function _J_(result){
          if(0 !== result[0]){
           var error = result[1];
           ignore_exn
            (function(param){
              function _L_(param){
               var
                arg1_015 = param[2],
                arg0_014 = param[1],
                res0_016 = caml_call1(Core_Error[9], arg0_014),
                res1_017 = caml_call1(Base_Backtrace[1], arg1_015);
               return [1, [0, res0_016, [0, res1_017, 0]]];
              }
              return caml_call3
                      (Core_Debug[2],
                       cst_at_shutdown_function_raise,
                       [0, error, backtrace],
                       _L_);
             });
          }
          if(debug)
           ignore_exn
            (function(param){
              return caml_call3
                      (Async_kernel_Debug[15],
                       cst_one_at_shutdown_function_f,
                       backtrace,
                       Base_Backtrace[1]);
             });
          return result;
         }
         var _K_ = caml_call6(Async_kernel_Monitor[17], 0, 0, 0, 0, _j_, f);
         return caml_call2(Async_unix_Import[33][3], _K_, _J_);
        },
      _G_ = caml_call2(Core_List[51], todo[1], _F_),
      _H_ = caml_call1(Async_kernel_Deferred[21], _G_);
     caml_call2(Async_unix_Import[22], _H_, _E_);
     if(force)
      var f = force[1], force$0 = f;
     else
      var force$0 = caml_call1(default_force_ref[1], 0);
     var
      _I_ =
        function(param){
         ignore_exn
          (function(param){
            return caml_call1(Async_kernel_Debug[16], cst_Shutdown_forced);
           });
         return exit_reliably(_k_);
        };
     return caml_call2(Async_unix_Import[22], force$0, _I_);
    }
    var prior = match[1];
    if(status === prior)
     var _A_ = 1;
    else if(0 === status[0]){
     var a_003 = status[1];
     if(0 === prior[0])
      var b_004 = prior[1], _A_ = caml_call2(Core[384], a_003, b_004);
     else
      var _A_ = 0;
    }
    else{
     var a_005 = status[1];
     if(0 === prior[0])
      var _A_ = 0;
     else
      var b_006 = prior[1], _A_ = caml_call2(Core_Signal[39], a_005, b_006);
    }
    a:
    if(_A_)
     var match$0 = 2;
    else{
     if(0 === status[0] && 0 === status[1]){var match$0 = 2; break a;}
     if(0 === prior[0] && 0 === prior[1]){var match$0 = 1; break a;}
     var match$0 = 0;
    }
    switch(match$0){
      case 0:
       var
        _B_ = [0, [1, [0, _f_, [0, sexp_of_t(prior), 0]]], 0],
        _C_ = [0, [1, [0, _g_, [0, sexp_of_t(status), 0]]], _B_],
        _D_ =
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_shutdown_with_inconsistent),
            _C_]];
       return caml_call1(Core[261], _D_);
      case 1:
       shutting_down_ref[1] = [0, status]; return 0;
      default: return 0;
    }
   }
   function shutdown(force, exit_code){
    return shutdown_with_status(force, [0, exit_code]);
   }
   function shutdown_with_signal_exn(force, signal){
    var default_sys_behavior = caml_call1(Core_Signal[46], signal);
    if(497016682 <= default_sys_behavior && 926227490 > default_sys_behavior)
     return shutdown_with_status(force, [1, signal]);
    var
     _v_ = 0,
     _w_ = 0,
     _x_ =
       192584839 === default_sys_behavior
        ? _l_
        : 926227490 <= default_sys_behavior ? _m_ : _n_,
     _y_ =
       [0,
        [1, [0, _p_, [0, caml_call1(Core_Signal[10], signal), 0]]],
        [0, [1, [0, _o_, [0, _x_, _w_]]], _v_]],
     _z_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Shutdown_shutdown_with_sig),
         _y_]];
    return caml_call1(Core[261], _z_);
   }
   function shutdown_on_unhandled_exn(param){
    function _s_(exn){
     ignore_exn
      (function(param){
        return caml_call3
                (Async_kernel_Debug[15],
                 cst_shutting_down_due_to_unhan,
                 exn,
                 Core[625]);
       });
     try{var _t_ = shutdown(0, 1); return _t_;}catch(_u_){return 0;}
    }
    return caml_call2(Async_kernel_Monitor[7], Async_kernel_Monitor[24], _s_);
   }
   function exit(force, status){
    shutdown(force, status);
    return caml_call1(Async_kernel_Deferred[19], 0);
   }
   var
    proceed_with_shutdown = caml_call1(Async_kernel_Ivar[12], 0),
    num_waiting = [0, 0];
   function check(param){
    var _r_ = caml_call2(Async_unix_Import[3], num_waiting[1], 0);
    return _r_
            ? caml_call2(Async_kernel_Ivar[14], proceed_with_shutdown, 0)
            : _r_;
   }
   at_shutdown
    (function(param){
      check(0);
      return caml_call1(Async_kernel_Ivar[19], proceed_with_shutdown);
     });
   function don_t_finish_before(d){
    if(shutting_down(0)) return 0;
    num_waiting[1]++;
    function _q_(param){
     num_waiting[1] += -1;
     return shutting_down(0) ? check(0) : 0;
    }
    return caml_call2(Async_unix_Import[22], d, _q_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Shutdown);
   var
    Async_unix_Shutdown =
      [0,
       shutdown,
       shutdown_with_signal_exn,
       shutdown_on_unhandled_exn,
       exit,
       default_force,
       set_default_force,
       [0, sexp_of_t],
       Maybe_status,
       shutting_down,
       is_shutting_down,
       at_shutdown,
       don_t_finish_before];
   runtime.caml_register_global
    (59, Async_unix_Shutdown, cst_Async_unix_Shutdown$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Signal_manager
//# unitInfo: Requires: Async_kernel__Async_kernel_scheduler, Async_unix__Raw_signal_manager, Async_unix__Shutdown, Core, Core__Bag, Core__Hashtbl, Core__List, Core__Signal, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Signal_manager$0 = "Async_unix__Signal_manager",
    cst_async_unix$0 = "async_unix",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_unix_Raw_signal_manager = global_data.Async_unix__Raw_signal_manager,
    Core_List = global_data.Core__List,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core_Signal = global_data.Core__Signal,
    Async_unix_Shutdown = global_data.Async_unix__Shutdown,
    Async_kernel_Async_kernel_sche =
      global_data.Async_kernel__Async_kernel_scheduler,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Bag = global_data.Core__Bag,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Signal_manager$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/signal_manager.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "signal_manager.ml");
   var
    _d_ = [0, "signal_dispatcher"],
    _e_ = [0, "raw_signal_manager"],
    _c_ = [0, "handlers_by_signal"],
    _b_ = [0, "exn"],
    cst_signal_handler_unexpectedl = "signal handler unexpectedly raised",
    _a_ = [0, "bag"],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Signal_manager = cst_Async_unix_Signal_manager$0;
   function sexp_of_t(param){
    var
     bag_002 = param[1],
     arg_003 = caml_call2(Core_Bag[3], Sexplib0_Sexp_conv[23], bag_002),
     bnds_001 = [0, [1, [0, _a_, [0, arg_003, 0]]], 0];
    return [1, bnds_001];
   }
   function get_handlers(t, signal){
    function _r_(param){return [0, caml_call1(Core_Bag[22], 0)];}
    return caml_call3(Core_Hashtbl[54], t[1], signal, _r_);
   }
   function sexp_of_t$0(param){
    var
     signal_dispatcher_010 = param[2],
     raw_signal_manager_008 = param[1],
     handlers_by_signal_005 = signal_dispatcher_010[1],
     arg_006 =
       caml_call2(Core_Signal[35][2], sexp_of_t, handlers_by_signal_005),
     bnds_004 = [0, [1, [0, _c_, [0, arg_006, 0]]], 0],
     arg_011 = [1, bnds_004],
     bnds_007 = [0, [1, [0, _d_, [0, arg_011, 0]]], 0],
     arg_009 =
       caml_call1(Async_unix_Raw_signal_manager[1], raw_signal_manager_008),
     bnds_007$0 = [0, [1, [0, _e_, [0, arg_009, 0]]], bnds_007];
    return [1, bnds_007$0];
   }
   function invariant(param){return 0;}
   function create(thread_safe_notify_signal_deli){
    var _q_ = [0, caml_call3(Core_Signal[35][5], 0, 0, 0)];
    return [0,
            caml_call1
             (Async_unix_Raw_signal_manager[3],
              thread_safe_notify_signal_deli),
            _q_];
   }
   function is_managing(t, signal){
    return caml_call2(Async_unix_Raw_signal_manager[5], t[1], signal);
   }
   function set_composable_handler(t, signals){
    var _p_ = caml_call1(Async_unix_Raw_signal_manager[4], t[1]);
    caml_call2(Core_List[19], signals, _p_);
    var t$0 = t[2];
    function _o_(signal){get_handlers(t$0, signal); return 0;}
    return caml_call2(Core_List[19], signals, _o_);
   }
   function manage(t, signal){
    return set_composable_handler(t, [0, signal, 0]);
   }
   function manage_but_keep_default_behavi(t, signal){
    return caml_call2(Async_unix_Raw_signal_manager[4], t[1], signal);
   }
   function install_handler(t, signals, handler){
    var _n_ = caml_call1(Async_unix_Raw_signal_manager[4], t[1]);
    caml_call2(Core_List[19], signals, _n_);
    var t$0 = t[2];
    function _m_(signal){
     var handlers = get_handlers(t$0, signal);
     return [0, handlers, caml_call2(Core_Bag[23], handlers[1], handler)];
    }
    return [0, caml_call2(Core_List[51], signals, _m_)];
   }
   function remove_handler(t, handler$0){
    var handler = handler$0[1];
    function _l_(param){
     var handler_elt = param[2], handlers = param[1];
     return caml_call2(Core_Bag[26], handlers[1], handler_elt);
    }
    return caml_call2(Core_List[19], handler, _l_);
   }
   function handle_delivered(t){
    function _f_(original_disposition, signal){
     var t$0 = t[2], match = caml_call2(Core_Hashtbl[56], t$0[1], signal);
     if(match){
      var
       handlers = match[1],
       _g_ =
         function(handler){
          try{var _k_ = caml_call1(handler, signal); return _k_;}
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _i_ = [0, [1, [0, _b_, [0, caml_call1(Core[625], exn), 0]]], 0],
            _j_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_signal_handler_unexpectedl),
                _i_]];
           return caml_call1(Core[261], _j_);
          }
         };
      return caml_call2(Core_Bag[7], handlers[1], _g_);
     }
     function _h_(param){
      if(typeof original_disposition !== "number"){
       var f = original_disposition[2];
       return caml_call1(f, signal);
      }
      if(-384499551 > original_disposition) return 0;
      var match = caml_call1(Core_Signal[46], signal);
      if(497016682 <= match && 926227490 > match)
       return caml_call2(Async_unix_Shutdown[2], 0, signal);
      return 0;
     }
     return caml_call3(Async_kernel_Async_kernel_sche[9], 0, 0, _h_);
    }
    caml_call2(Async_unix_Raw_signal_manager[6], t[1], _f_);
    return 0;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Signal_manager);
   var
    Async_unix_Signal_manager =
      [0,
       sexp_of_t$0,
       invariant,
       create,
       manage,
       manage_but_keep_default_behavi,
       is_managing,
       set_composable_handler,
       install_handler,
       remove_handler,
       handle_delivered];
   runtime.caml_register_global
    (26, Async_unix_Signal_manager, cst_Async_unix_Signal_manager$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Raw_scheduler
//# unitInfo: Requires: Async_kernel__Async_gc, Async_kernel__Async_kernel_scheduler, Async_kernel__Async_stream, Async_kernel__Clock_ns, Async_kernel__Debug, Async_kernel__Deferred, Async_kernel__Execution_context, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler, Async_kernel__Throttle, Async_kernel_config, Async_unix__Busy_poller, Async_unix__By_descr, Async_unix__Config, Async_unix__Dump_core_on_job_delay, Async_unix__Epoll_file_descr_watcher, Async_unix__File_descr_watcher_intf, Async_unix__Import, Async_unix__Interruptor, Async_unix__Io_uring_file_descr_watcher, Async_unix__Io_uring_raw, Async_unix__Raw_fd, Async_unix__Select_file_descr_watcher, Async_unix__Signal_manager, Base__Backtrace, Base__Exn, Base__Field, Core, Core__Bool, Core__Debug, Core__Error, Core__Int, Core__Int63, Core__Lazy, Core__List, Core__Option, Core__Or_error, Core__Pid, Core__Result, Core__Sexp, Core__Signal, Core__Stack, Core__Uniform_array, Core_thread, Core_unix, Core_unix__File_descr, Heap_block, Inline_test_config, Linux_ext, Nano_mutex, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Read_write_pair, Sexplib0__Sexp_conv, Stdlib, Thread_pool, Time_float_unix, Time_ns_unix, Time_stamp_counter
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Raw_scheduler$0 = "Async_unix__Raw_scheduler",
    cst_async_unix$0 = "async_unix",
    cst_busy_pollers$0 = "busy_pollers",
    cst_dns_lookup_throttle$0 = "dns_lookup_throttle",
    cst_exn = "exn",
    cst_external_fd_by_descr$0 = "external_fd_by_descr",
    cst_external_fd_events$0 = "external_fd_events",
    cst_fd_by_descr$0 = "fd_by_descr",
    cst_fds_whose_watching_has_cha$0 = "fds_whose_watching_has_changed",
    cst_file_descr = "file_descr",
    cst_file_descr_watcher$0 = "file_descr_watcher",
    cst_handle_thread_pool_stuck$0 = "handle_thread_pool_stuck",
    cst_have_lock_do_cycle$1 = "have_lock_do_cycle",
    cst_initialized_at$0 = "initialized_at",
    cst_interruptor$0 = "interruptor",
    cst_kernel_scheduler$0 = "kernel_scheduler",
    cst_max_inter_cycle_timeout$0 = "max_inter_cycle_timeout",
    cst_min_inter_cycle_timeout$0 = "min_inter_cycle_timeout",
    cst_mutex$0 = "mutex",
    cst_next_tsc_calibration$0 = "next_tsc_calibration",
    cst_num_busy_pollers$0 = "num_busy_pollers",
    cst_scheduler = "scheduler",
    cst_scheduler_thread_id$0 = "scheduler_thread_id",
    cst_signal_manager$0 = "signal_manager",
    cst_src_raw_scheduler_ml$0 = "src/raw_scheduler.ml",
    cst_start_type$0 = "start_type",
    cst_thread_pool$0 = "thread_pool",
    cst_thread_pool_stuck$0 = "thread_pool_stuck",
    cst_time_spent_waiting_for_io$0 = "time_spent_waiting_for_io",
    cst_timerfd$0 = "timerfd",
    cst_timerfd_set_at$0 = "timerfd_set_at",
    cst_uring$0 = "uring",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call26
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25){
    return (f.l >= 0 ? f.l : f.l = f.length) == 26
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23,
                a24,
                a25]);
   }
   function caml_call27
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25,
    a26){
    return (f.l >= 0 ? f.l : f.l = f.length) == 27
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25,
               a26)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23,
                a24,
                a25,
                a26]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/raw_scheduler.ml:624:17",
    text = "Async's thread pool is stuck",
    Core_Or_error = global_data.Core__Or_error,
    Base_Exn = global_data.Base__Exn,
    Core_unix_File_descr = global_data.Core_unix__File_descr,
    Async_unix_By_descr = global_data.Async_unix__By_descr,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_List = global_data.Core__List,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Core_Error = global_data.Core__Error,
    Core_Result = global_data.Core__Result,
    Core_Option = global_data.Core__Option,
    Async_unix_Import = global_data.Async_unix__Import,
    Thread_pool = global_data.Thread_pool,
    Time_ns_unix = global_data.Time_ns_unix,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Base_Backtrace = global_data.Base__Backtrace,
    Nano_mutex = global_data.Nano_mutex,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Time_float_unix = global_data.Time_float_unix,
    Core_Pid = global_data.Core__Pid,
    Core_unix = global_data.Core_unix,
    Core_thread = global_data.Core_thread,
    Heap_block = global_data.Heap_block,
    Core_Sexp = global_data.Core__Sexp,
    Stdlib = global_data.Stdlib,
    Async_unix_Dump_core_on_job_de =
      global_data.Async_unix__Dump_core_on_job_delay,
    Async_unix_Signal_manager = global_data.Async_unix__Signal_manager,
    Linux_ext = global_data.Linux_ext,
    Time_stamp_counter = global_data.Time_stamp_counter,
    Core_Uniform_array = global_data.Core__Uniform_array,
    Async_unix_Busy_poller = global_data.Async_unix__Busy_poller,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_unix_File_descr_watcher_ =
      global_data.Async_unix__File_descr_watcher_intf,
    Async_unix_Interruptor = global_data.Async_unix__Interruptor,
    Async_unix_Raw_fd = global_data.Async_unix__Raw_fd,
    Read_write_pair = global_data.Read_write_pair,
    Core_Signal = global_data.Core__Signal,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_unix_Config = global_data.Async_unix__Config,
    Core_Lazy = global_data.Core__Lazy,
    Core_Int63 = global_data.Core__Int63,
    Core_Stack = global_data.Core__Stack,
    Assert_failure = global_data.Assert_failure,
    Async_unix_Io_uring_raw = global_data.Async_unix__Io_uring_raw,
    Async_unix_Io_uring_file_descr =
      global_data.Async_unix__Io_uring_file_descr_watcher,
    Async_unix_Epoll_file_descr_wa =
      global_data.Async_unix__Epoll_file_descr_watcher,
    Async_unix_Select_file_descr_w =
      global_data.Async_unix__Select_file_descr_watcher,
    Core_Int = global_data.Core__Int,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime;
   global_data.Core__Bool;
   var
    Core_Debug = global_data.Core__Debug,
    Base_Field = global_data.Base__Field,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Async_kernel_Async_kernel_sche =
      global_data.Async_kernel__Async_kernel_scheduler,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Raw_scheduler$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_raw_scheduler_ml$0);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "raw_scheduler.ml");
   var
    debug = Async_kernel_Debug[10],
    cst_Attempt_to_run_one_cycle_w =
      "Attempt to run_one_cycle without holding Async lock",
    cst_Attempt_to_unregister_an_F =
      "Attempt to unregister an FD which is not registered",
    _bo_ = [0, 3553398],
    _bp_ = [0, 0],
    cst_Unsupported_file_descripto$0 =
      "Unsupported file descriptor type in unregister_fd",
    _bm_ = [0, 3553398],
    _bn_ = [0, 0],
    cst_Unsupported_file_descripto =
      "Unsupported file descriptor type in register_fd",
    cst_Cannot_watch_external_fds_ =
      "Cannot watch external fds while using the Ocaml_uring fd watcher",
    cst_FD_registration_must_only_ =
      "FD registration must only be done from the scheduler thread",
    cst_Scheduler_External_run_one$1 =
      "Scheduler.External.run_one_cycle called from wrong thread",
    cst_Scheduler_External_run_one$0 =
      "Scheduler.External.run_one_cycle called recursively",
    cst_Scheduler_External_run_one$2 =
      "Scheduler.External.run_one_cycle called while scheduler already running in another thread",
    cst_Scheduler_External_run_one =
      "Scheduler.External.run_one_cycle called from within Async",
    _bl_ = [0, "ev.file_descr"],
    cst_Bad_file_descriptor = "Bad file descriptor",
    cst_Scheduler_External_current =
      "Scheduler.External.current_thread_can_cycle called from within Async",
    cst_Attempt_to_call_current_th =
      "Attempt to call current_thread_can_cycle without holding Async lock",
    cst_Thread_pool_stats_subscrip =
      "Thread_pool_stats_subscription.create_exn can only be called once",
    cst_long_async_cycle = "long async cycle",
    _bk_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    _bj_ = [0, cst_initialized_at$0],
    cst_Async_was_initialized_prio =
      "Async was initialized prior to [Scheduler.go_main]",
    cst_cannot_mix_Scheduler_go_an =
      "cannot mix Scheduler.go and Scheduler.External",
    cst_cannot_Scheduler_go_more_t = "cannot Scheduler.go more than once",
    cst_Scheduler_go = "Scheduler.go",
    cst_error_program_is_attemptin =
      "error: program is attempting to schedule async work too soon (at toplevel of a library, usually)",
    _bh_ = [0, "pid"],
    _bi_ = [0, "thread_id"],
    cst_bug_in_async_scheduler = "bug in async scheduler",
    cst_Sexp_hum = "%{Sexp#hum}\n%!",
    _bf_ = [12, 10, [10, 0]],
    _bg_ = [0, 0],
    cst_unhandled_exception_in_Asy = "unhandled exception in Async scheduler",
    cst_dumping_core = "dumping core",
    cst_handling_delivered_signals = "handling delivered signals",
    _bd_ = [0, "Immediately"],
    _be_ = [0, "After"],
    cst_File_descr_watcher_pre_che = "File_descr_watcher.pre_check",
    cst_File_descr_watcher_thread_ = "File_descr_watcher.thread_safe_check",
    cst_File_descr_watcher_post_ch = "File_descr_watcher.post_check",
    _bb_ = [0, cst_scheduler],
    _bc_ = [0, "interruptor_read_fd"],
    cst_can_not_watch_interruptor = "can not watch interruptor",
    cst_add_busy_poller_maximum_nu =
      "[add_busy_poller] maximum number of pollers exceeded",
    _a8_ = [0, cst_scheduler],
    _a9_ = [0, "bt"],
    _a__ = [0, cst_exn],
    _a$_ = [0, "fd"],
    _ba_ = [0, "desired"],
    cst_sync_changed_fds_to_file_d =
      "sync_changed_fds_to_file_descr_watcher unable to set fd",
    cst_File_descr_watcher_set = "File_descr_watcher.set",
    cst_have_lock_do_cycle$0 = cst_have_lock_do_cycle$1,
    cst_Async_is_unusable_due_to_S =
      "Async is unusable due to [Scheduler.make_async_unusable]",
    cst_Async_refuses_to_run_using =
      "Async refuses to run using epoll on a system that doesn't support timer FDs, since\nAsync will be unable to timeout with sub-millisecond precision.",
    _a6_ = [0, cst_src_raw_scheduler_ml$0, 661, 14],
    cst_creating_scheduler = "creating scheduler",
    _a3_ = [0, cst_file_descr],
    cst_File_descr_watcher_returne$0 =
      "File_descr_watcher returned unknown file descr",
    _a2_ = [0, cst_file_descr],
    cst_File_descr_watcher_returne =
      "File_descr_watcher returned the timerfd as ready to be written to",
    cst_request_stop_watching = "request_stop_watching",
    cst_request_start_watching = "request_start_watching",
    cst_give_up_on_watching = "give_up_on_watching",
    _aX_ = [0, "last_thread_creation_failure"],
    _aY_ = [0, "max_num_threads"],
    _aZ_ = [0, "num_threads_created"],
    _a0_ = [0, "stuck_for"],
    _a1_ =
      [0,
       [2, 0, [11, ", and will raise an exception in ", [2, 0, 0]]],
       "%s, and will raise an exception in %s"],
    cst_attempt_to_access_Async_fr =
      "attempt to access Async from thread not holding the Async lock",
    _aM_ = [0, cst_scheduler],
    _aN_ = [0, cst_exn],
    cst_Scheduler_invariant_failed = "Scheduler.invariant failed",
    _aW_ = [0, cst_src_raw_scheduler_ml$0, 308, 13],
    _aU_ = [0, cst_src_raw_scheduler_ml$0, 311, 27],
    _aV_ = [0, cst_src_raw_scheduler_ml$0, 310, 23],
    _aR_ = [0, cst_file_descr],
    _aS_ = [0, cst_exn],
    cst_fd_problem = "fd problem",
    cst_missing_from_fd_by_descr = "missing from fd_by_descr",
    _aT_ = [0, cst_src_raw_scheduler_ml$0, 320, 28],
    _aQ_ = [0, cst_src_raw_scheduler_ml$0, 333, 15],
    _aP_ = [0, cst_src_raw_scheduler_ml$0, 337, 45],
    _aO_ = [0, cst_src_raw_scheduler_ml$0, 352, 11],
    _aI_ = [0, cst_scheduler],
    _aJ_ = [0, "backtrace"],
    _aK_ = [0, "error"],
    _aL_ = [0, cst_file_descr],
    cst_Async_was_unable_to_add_a_ =
      "Async was unable to add a file descriptor to its table of open file descriptors",
    cst_Async_the_one_and_only_not =
      "Async the_one_and_only not ready to initialize",
    cst_lock_released = "lock released",
    cst_waiting_on_lock = "waiting on lock",
    _ah_ = [0, cst_uring$0],
    _ai_ = [0, cst_initialized_at$0],
    _aj_ = [0, cst_min_inter_cycle_timeout$0],
    _ak_ = [0, cst_max_inter_cycle_timeout$0],
    _al_ = [0, cst_have_lock_do_cycle$1],
    _am_ = [0, cst_kernel_scheduler$0],
    _an_ = [0, cst_next_tsc_calibration$0],
    _ao_ = [0, cst_dns_lookup_throttle$0],
    _ap_ = [0, cst_thread_pool_stuck$0],
    _aq_ = [0, cst_handle_thread_pool_stuck$0],
    _ar_ = [0, cst_thread_pool$0],
    _as_ = [0, cst_signal_manager$0],
    _at_ = [0, cst_interruptor$0],
    _au_ = [0, cst_scheduler_thread_id$0],
    _av_ = [0, cst_timerfd_set_at$0],
    _aw_ = [0, cst_timerfd$0],
    _ax_ = [0, cst_external_fd_events$0],
    _ay_ = [0, cst_external_fd_by_descr$0],
    _az_ = [0, cst_fd_by_descr$0],
    _aA_ = [0, cst_time_spent_waiting_for_io$0],
    _aB_ = [0, cst_num_busy_pollers$0],
    _aC_ = [0, cst_busy_pollers$0],
    _aD_ = [0, cst_file_descr_watcher$0],
    _aE_ = [0, cst_fds_whose_watching_has_cha$0],
    _aF_ = [0, cst_start_type$0],
    _aG_ = [0, cst_mutex$0],
    _e_ = [0, "Not_started"],
    _f_ = [0, "Called_go"],
    _g_ = [0, "Called_block_on_async"],
    _h_ = [0, "active"],
    _i_ = [0, "Called_external_run"],
    _a_ = [0, "num_work_completed"],
    _b_ = [0, "stuck_since"],
    _c_ = [0, "Stuck"],
    _d_ = [0, "No_unstarted_work"],
    cst_uring = cst_uring$0,
    cst_initialized_at = cst_initialized_at$0,
    cst_min_inter_cycle_timeout = cst_min_inter_cycle_timeout$0,
    cst_max_inter_cycle_timeout = cst_max_inter_cycle_timeout$0,
    cst_have_lock_do_cycle = cst_have_lock_do_cycle$1,
    cst_kernel_scheduler = cst_kernel_scheduler$0,
    cst_next_tsc_calibration = cst_next_tsc_calibration$0,
    cst_dns_lookup_throttle = cst_dns_lookup_throttle$0,
    cst_thread_pool_stuck = cst_thread_pool_stuck$0,
    cst_handle_thread_pool_stuck = cst_handle_thread_pool_stuck$0,
    cst_thread_pool = cst_thread_pool$0,
    cst_signal_manager = cst_signal_manager$0,
    cst_interruptor = cst_interruptor$0,
    cst_scheduler_thread_id = cst_scheduler_thread_id$0,
    cst_timerfd_set_at = cst_timerfd_set_at$0,
    cst_timerfd = cst_timerfd$0,
    cst_external_fd_events = cst_external_fd_events$0,
    cst_external_fd_by_descr = cst_external_fd_by_descr$0,
    cst_fd_by_descr = cst_fd_by_descr$0,
    cst_time_spent_waiting_for_io = cst_time_spent_waiting_for_io$0,
    cst_num_busy_pollers = cst_num_busy_pollers$0,
    cst_busy_pollers = cst_busy_pollers$0,
    cst_file_descr_watcher = cst_file_descr_watcher$0,
    cst_fds_whose_watching_has_cha = cst_fds_whose_watching_has_cha$0,
    cst_start_type = cst_start_type$0,
    cst_mutex = cst_mutex$0,
    _aH_ = [0, 0],
    cst_src_raw_scheduler_ml = cst_src_raw_scheduler_ml$0,
    _a5_ = [0, "64-bits-only", 0],
    cst_maybe_report_long_async_cy =
      "maybe_report_long_async_cycles_to_magic_trace doesn't allocate",
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Raw_scheduler = cst_Async_unix_Raw_scheduler$0;
   function sexp_of_t(t){
    var
     arg1_002 = t[13],
     arg0_001 = t[4],
     res0_003 = caml_call1(Async_kernel_config[10][1], arg0_001),
     res1_004 = caml_call1(t[1], arg1_002);
    return [1, [0, res0_003, [0, res1_004, 0]]];
   }
   var
    File_descr_watcher = [0, sexp_of_t],
    Custom = [0],
    Which_watcher = [0, Custom],
    External_fd_event = [0];
   function sexp_of_t$0(param){
    if(! param) return _d_;
    var
     num_work_completed_008 = param[2],
     stuck_since_006 = param[1],
     arg_009 = caml_call1(Core[389], num_work_completed_008),
     bnds_005 = [0, [1, [0, _a_, [0, arg_009, 0]]], 0],
     arg_007 = caml_call1(Time_ns_unix[85], stuck_since_006),
     bnds_005$0 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_005];
    return [1, [0, _c_, bnds_005$0]];
   }
   var
    Thread_pool_stuck_status = [0, sexp_of_t$0],
    within_context = Async_kernel_Async_kernel_sche[2],
    within = Async_kernel_Async_kernel_sche[3],
    within$0 = Async_kernel_Async_kernel_sche[4],
    within_v = Async_kernel_Async_kernel_sche[5],
    with_local = Async_kernel_Async_kernel_sche[6],
    find_local = Async_kernel_Async_kernel_sche[7],
    schedule = Async_kernel_Async_kernel_sche[8],
    schedule$0 = Async_kernel_Async_kernel_sche[9],
    enqueue_job = Async_kernel_Async_kernel_sche[10],
    thread_safe_enqueue_job = Async_kernel_Async_kernel_sche[11],
    preserve_execution_context = Async_kernel_Async_kernel_sche[12],
    preserve_execution_context$0 = Async_kernel_Async_kernel_sche[13],
    cycle_start = Async_kernel_Async_kernel_sche[14],
    cycle_start_ns = Async_kernel_Async_kernel_sche[15],
    cycle_times = Async_kernel_Async_kernel_sche[16],
    cycle_times_ns = Async_kernel_Async_kernel_sche[17],
    last_cycle_time = Async_kernel_Async_kernel_sche[18],
    long_cycles = Async_kernel_Async_kernel_sche[19],
    cycle_count = Async_kernel_Async_kernel_sche[20],
    total_cycle_time = Async_kernel_Async_kernel_sche[21],
    event_precision = Async_kernel_Async_kernel_sche[22],
    event_precision_ns = Async_kernel_Async_kernel_sche[23],
    force_current_cycle_to_end = Async_kernel_Async_kernel_sche[24],
    set_max_num_jobs_per_priority_ = Async_kernel_Async_kernel_sche[25],
    max_num_jobs_per_priority_per_ = Async_kernel_Async_kernel_sche[26],
    set_record_backtraces = Async_kernel_Async_kernel_sche[27],
    recording_backtraces = Async_kernel_Async_kernel_sche[28],
    yield$0 = Async_kernel_Async_kernel_sche[29],
    yield_until_no_jobs_remain = Async_kernel_Async_kernel_sche[30],
    yield_every = Async_kernel_Async_kernel_sche[31],
    num_jobs_run = Async_kernel_Async_kernel_sche[32],
    num_pending_jobs = Async_kernel_Async_kernel_sche[33],
    Expert = Async_kernel_Async_kernel_sche[34];
   function sexp_of_start_type(param){
    if(typeof param === "number")
     switch(param){case 0: return _e_;case 1: return _f_;default: return _g_;}
    var
     active_011 = param[1],
     arg_012 = caml_call2(Core[598], Core[323], active_011),
     bnds_010 = [0, [1, [0, _h_, [0, arg_012, 0]]], 0];
    return [1, [0, _i_, bnds_010]];
   }
   function uring(r){return r[26];}
   function initialized_at(r){return r[25];}
   function min_inter_cycle_timeout(r){return r[24];}
   function set_min_inter_cycle_timeout(r, v){r[24] = v; return 0;}
   function max_inter_cycle_timeout(r){return r[23];}
   function set_max_inter_cycle_timeout(r, v){r[23] = v; return 0;}
   function have_lock_do_cycle(r){return r[22];}
   function set_have_lock_do_cycle(r, v){r[22] = v; return 0;}
   function kernel_scheduler(r){return r[21];}
   function next_tsc_calibration(r){return r[20];}
   function set_next_tsc_calibration(r, v){r[20] = v; return 0;}
   function dns_lookup_throttle(r){return r[19];}
   function thread_pool_stuck(r){return r[18];}
   function set_thread_pool_stuck(r, v){r[18] = v; return 0;}
   function handle_thread_pool_stuck(r){return r[17];}
   function set_handle_thread_pool_stuck(r, v){r[17] = v; return 0;}
   function thread_pool(r){return r[16];}
   function signal_manager(r){return r[15];}
   function interruptor(r){return r[14];}
   function scheduler_thread_id(r){return r[13];}
   function set_scheduler_thread_id(r, v){r[13] = v; return 0;}
   function timerfd_set_at(r){return r[12];}
   function set_timerfd_set_at(r, v){r[12] = v; return 0;}
   function timerfd(r){return r[11];}
   function set_timerfd(r, v){r[11] = v; return 0;}
   function external_fd_events(r){return r[10];}
   function set_external_fd_events(r, v){r[10] = v; return 0;}
   function external_fd_by_descr(r){return r[9];}
   function fd_by_descr(r){return r[8];}
   function time_spent_waiting_for_io(r){return r[7];}
   function set_time_spent_waiting_for_io(r, v){r[7] = v; return 0;}
   function num_busy_pollers(r){return r[6];}
   function set_num_busy_pollers(r, v){r[6] = v; return 0;}
   function busy_pollers(r){return r[5];}
   function file_descr_watcher(r){return r[4];}
   function fds_whose_watching_has_changed(r){return r[3];}
   function start_type(r){return r[2];}
   function set_start_type(r, v){r[2] = v; return 0;}
   function mutex(r){return r[1];}
   function _j_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            v];
   }
   var
    _k_ = 0,
    uring$0 = [0, function(param){return 0;}, cst_uring, _k_, uring, _j_];
   function _l_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            v,
            r[26]];
   }
   var
    _m_ = 0,
    initialized_at$0 =
      [0,
       function(param){return 0;},
       cst_initialized_at,
       _m_,
       initialized_at,
       _l_];
   function _n_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            v,
            r[25],
            r[26]];
   }
   var
    _o_ = [0, set_min_inter_cycle_timeout],
    min_inter_cycle_timeout$0 =
      [0,
       function(param){return 0;},
       cst_min_inter_cycle_timeout,
       _o_,
       min_inter_cycle_timeout,
       _n_];
   function _p_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            v,
            r[24],
            r[25],
            r[26]];
   }
   var
    _q_ = [0, set_max_inter_cycle_timeout],
    max_inter_cycle_timeout$0 =
      [0,
       function(param){return 0;},
       cst_max_inter_cycle_timeout,
       _q_,
       max_inter_cycle_timeout,
       _p_];
   function _r_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            v,
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _s_ = [0, set_have_lock_do_cycle],
    have_lock_do_cycle$0 =
      [0,
       function(param){return 0;},
       cst_have_lock_do_cycle,
       _s_,
       have_lock_do_cycle,
       _r_];
   function _t_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            v,
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _u_ = 0,
    kernel_scheduler$0 =
      [0,
       function(param){return 0;},
       cst_kernel_scheduler,
       _u_,
       kernel_scheduler,
       _t_];
   function _v_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            v,
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _w_ = [0, set_next_tsc_calibration],
    next_tsc_calibration$0 =
      [0,
       function(param){return 0;},
       cst_next_tsc_calibration,
       _w_,
       next_tsc_calibration,
       _v_];
   function _x_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            v,
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _y_ = 0,
    dns_lookup_throttle$0 =
      [0,
       function(param){return 0;},
       cst_dns_lookup_throttle,
       _y_,
       dns_lookup_throttle,
       _x_];
   function _z_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            v,
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _A_ = [0, set_thread_pool_stuck],
    thread_pool_stuck$0 =
      [0,
       function(param){return 0;},
       cst_thread_pool_stuck,
       _A_,
       thread_pool_stuck,
       _z_];
   function _B_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            v,
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _C_ = [0, set_handle_thread_pool_stuck],
    handle_thread_pool_stuck$0 =
      [0,
       function(param){return 0;},
       cst_handle_thread_pool_stuck,
       _C_,
       handle_thread_pool_stuck,
       _B_];
   function _D_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            v,
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _E_ = 0,
    thread_pool$0 =
      [0, function(param){return 0;}, cst_thread_pool, _E_, thread_pool, _D_];
   function _F_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            v,
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _G_ = 0,
    signal_manager$0 =
      [0,
       function(param){return 0;},
       cst_signal_manager,
       _G_,
       signal_manager,
       _F_];
   function _H_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            v,
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _I_ = 0,
    interruptor$0 =
      [0, function(param){return 0;}, cst_interruptor, _I_, interruptor, _H_];
   function _J_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            v,
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _K_ = [0, set_scheduler_thread_id],
    scheduler_thread_id$0 =
      [0,
       function(param){return 0;},
       cst_scheduler_thread_id,
       _K_,
       scheduler_thread_id,
       _J_];
   function _L_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _M_ = [0, set_timerfd_set_at],
    timerfd_set_at$0 =
      [0,
       function(param){return 0;},
       cst_timerfd_set_at,
       _M_,
       timerfd_set_at,
       _L_];
   function _N_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _O_ = [0, set_timerfd],
    timerfd$0 =
      [0, function(param){return 0;}, cst_timerfd, _O_, timerfd, _N_];
   function _P_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            v,
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _Q_ = [0, set_external_fd_events],
    external_fd_events$0 =
      [0,
       function(param){return 0;},
       cst_external_fd_events,
       _Q_,
       external_fd_events,
       _P_];
   function _R_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _S_ = 0,
    external_fd_by_descr$0 =
      [0,
       function(param){return 0;},
       cst_external_fd_by_descr,
       _S_,
       external_fd_by_descr,
       _R_];
   function _T_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _U_ = 0,
    fd_by_descr$0 =
      [0, function(param){return 0;}, cst_fd_by_descr, _U_, fd_by_descr, _T_];
   function _V_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _W_ = [0, set_time_spent_waiting_for_io],
    time_spent_waiting_for_io$0 =
      [0,
       function(param){return 0;},
       cst_time_spent_waiting_for_io,
       _W_,
       time_spent_waiting_for_io,
       _V_];
   function _X_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _Y_ = [0, set_num_busy_pollers],
    num_busy_pollers$0 =
      [0,
       function(param){return 0;},
       cst_num_busy_pollers,
       _Y_,
       num_busy_pollers,
       _X_];
   function _Z_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    ___ = 0,
    busy_pollers$0 =
      [0,
       function(param){return 0;},
       cst_busy_pollers,
       ___,
       busy_pollers,
       _Z_];
   function _$_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _aa_ = 0,
    file_descr_watcher$0 =
      [0,
       function(param){return 0;},
       cst_file_descr_watcher,
       _aa_,
       file_descr_watcher,
       _$_];
   function _ab_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _ac_ = 0,
    fds_whose_watching_has_changed$0 =
      [0,
       function(param){return 0;},
       cst_fds_whose_watching_has_cha,
       _ac_,
       fds_whose_watching_has_changed,
       _ab_];
   function _ad_(r, v){
    return [0,
            r[1],
            v,
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _ae_ = [0, set_start_type],
    start_type$0 =
      [0, function(param){return 0;}, cst_start_type, _ae_, start_type, _ad_];
   function _af_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26]];
   }
   var
    _ag_ = 0,
    mutex$0 = [0, function(param){return 0;}, cst_mutex, _ag_, mutex, _af_];
   function iter
   (mutex_fun,
    start_type_fun,
    fds_whose_watching_has_changed,
    file_descr_watcher_fun,
    busy_pollers_fun,
    num_busy_pollers_fun,
    time_spent_waiting_for_io_fun,
    fd_by_descr_fun,
    external_fd_by_descr_fun,
    external_fd_events_fun,
    timerfd_fun,
    timerfd_set_at_fun,
    scheduler_thread_id_fun,
    interruptor_fun,
    signal_manager_fun,
    thread_pool_fun,
    handle_thread_pool_stuck_fun,
    thread_pool_stuck_fun,
    dns_lookup_throttle_fun,
    next_tsc_calibration_fun,
    kernel_scheduler_fun,
    have_lock_do_cycle_fun,
    max_inter_cycle_timeout_fun,
    min_inter_cycle_timeout_fun,
    initialized_at_fun,
    uring_fun){
    caml_call1(mutex_fun, mutex$0);
    caml_call1(start_type_fun, start_type$0);
    caml_call1
     (fds_whose_watching_has_changed, fds_whose_watching_has_changed$0);
    caml_call1(file_descr_watcher_fun, file_descr_watcher$0);
    caml_call1(busy_pollers_fun, busy_pollers$0);
    caml_call1(num_busy_pollers_fun, num_busy_pollers$0);
    caml_call1(time_spent_waiting_for_io_fun, time_spent_waiting_for_io$0);
    caml_call1(fd_by_descr_fun, fd_by_descr$0);
    caml_call1(external_fd_by_descr_fun, external_fd_by_descr$0);
    caml_call1(external_fd_events_fun, external_fd_events$0);
    caml_call1(timerfd_fun, timerfd$0);
    caml_call1(timerfd_set_at_fun, timerfd_set_at$0);
    caml_call1(scheduler_thread_id_fun, scheduler_thread_id$0);
    caml_call1(interruptor_fun, interruptor$0);
    caml_call1(signal_manager_fun, signal_manager$0);
    caml_call1(thread_pool_fun, thread_pool$0);
    caml_call1(handle_thread_pool_stuck_fun, handle_thread_pool_stuck$0);
    caml_call1(thread_pool_stuck_fun, thread_pool_stuck$0);
    caml_call1(dns_lookup_throttle_fun, dns_lookup_throttle$0);
    caml_call1(next_tsc_calibration_fun, next_tsc_calibration$0);
    caml_call1(kernel_scheduler_fun, kernel_scheduler$0);
    caml_call1(have_lock_do_cycle_fun, have_lock_do_cycle$0);
    caml_call1(max_inter_cycle_timeout_fun, max_inter_cycle_timeout$0);
    caml_call1(min_inter_cycle_timeout_fun, min_inter_cycle_timeout$0);
    caml_call1(initialized_at_fun, initialized_at$0);
    return caml_call1(uring_fun, uring$0);
   }
   function fold
   (init,
    mutex_fun,
    start_type_fun,
    fds_whose_watching_has_changed,
    file_descr_watcher_fun,
    busy_pollers_fun,
    num_busy_pollers_fun,
    time_spent_waiting_for_io_fun,
    fd_by_descr_fun,
    external_fd_by_descr_fun,
    external_fd_events_fun,
    timerfd_fun,
    timerfd_set_at_fun,
    scheduler_thread_id_fun,
    interruptor_fun,
    signal_manager_fun,
    thread_pool_fun,
    handle_thread_pool_stuck_fun,
    thread_pool_stuck_fun,
    dns_lookup_throttle_fun,
    next_tsc_calibration_fun,
    kernel_scheduler_fun,
    have_lock_do_cycle_fun,
    max_inter_cycle_timeout_fun,
    min_inter_cycle_timeout_fun,
    initialized_at_fun,
    uring_fun){
    return caml_call2
            (uring_fun,
             caml_call2
              (initialized_at_fun,
               caml_call2
                (min_inter_cycle_timeout_fun,
                 caml_call2
                  (max_inter_cycle_timeout_fun,
                   caml_call2
                    (have_lock_do_cycle_fun,
                     caml_call2
                      (kernel_scheduler_fun,
                       caml_call2
                        (next_tsc_calibration_fun,
                         caml_call2
                          (dns_lookup_throttle_fun,
                           caml_call2
                            (thread_pool_stuck_fun,
                             caml_call2
                              (handle_thread_pool_stuck_fun,
                               caml_call2
                                (thread_pool_fun,
                                 caml_call2
                                  (signal_manager_fun,
                                   caml_call2
                                    (interruptor_fun,
                                     caml_call2
                                      (scheduler_thread_id_fun,
                                       caml_call2
                                        (timerfd_set_at_fun,
                                         caml_call2
                                          (timerfd_fun,
                                           caml_call2
                                            (external_fd_events_fun,
                                             caml_call2
                                              (external_fd_by_descr_fun,
                                               caml_call2
                                                (fd_by_descr_fun,
                                                 caml_call2
                                                  (time_spent_waiting_for_io_fun,
                                                   caml_call2
                                                    (num_busy_pollers_fun,
                                                     caml_call2
                                                      (busy_pollers_fun,
                                                       caml_call2
                                                        (file_descr_watcher_fun,
                                                         caml_call2
                                                          (fds_whose_watching_has_changed,
                                                           caml_call2
                                                            (start_type_fun,
                                                             caml_call2(mutex_fun, init, mutex$0),
                                                             start_type$0),
                                                           fds_whose_watching_has_changed$0),
                                                         file_descr_watcher$0),
                                                       busy_pollers$0),
                                                     num_busy_pollers$0),
                                                   time_spent_waiting_for_io$0),
                                                 fd_by_descr$0),
                                               external_fd_by_descr$0),
                                             external_fd_events$0),
                                           timerfd$0),
                                         timerfd_set_at$0),
                                       scheduler_thread_id$0),
                                     interruptor$0),
                                   signal_manager$0),
                                 thread_pool$0),
                               handle_thread_pool_stuck$0),
                             thread_pool_stuck$0),
                           dns_lookup_throttle$0),
                         next_tsc_calibration$0),
                       kernel_scheduler$0),
                     have_lock_do_cycle$0),
                   max_inter_cycle_timeout$0),
                 min_inter_cycle_timeout$0),
               initialized_at$0),
             uring$0);
   }
   var
    Fields =
      [0,
       uring$0,
       initialized_at$0,
       min_inter_cycle_timeout$0,
       max_inter_cycle_timeout$0,
       have_lock_do_cycle$0,
       kernel_scheduler$0,
       next_tsc_calibration$0,
       dns_lookup_throttle$0,
       thread_pool_stuck$0,
       handle_thread_pool_stuck$0,
       thread_pool$0,
       signal_manager$0,
       interruptor$0,
       scheduler_thread_id$0,
       timerfd_set_at$0,
       timerfd$0,
       external_fd_events$0,
       external_fd_by_descr$0,
       fd_by_descr$0,
       time_spent_waiting_for_io$0,
       num_busy_pollers$0,
       busy_pollers$0,
       file_descr_watcher$0,
       fds_whose_watching_has_changed$0,
       start_type$0,
       mutex$0,
       iter,
       fold];
   function sexp_of_t$1(param){
    var
     mutex_014 = param[1],
     start_type_016 = param[2],
     busy_pollers_022 = param[5],
     file_descr_watcher_020 = param[4],
     fds_whose_watching_has_changed = param[3],
     num_busy_pollers_024 = param[6],
     time_spent_waiting_for_io_026 = param[7],
     external_fd_by_descr_030 = param[9],
     fd_by_descr_028 = param[8],
     external_fd_events_032 = param[10],
     timerfd_034 = param[11],
     timerfd_set_at_036 = param[12],
     scheduler_thread_id_038 = param[13],
     thread_pool_044 = param[16],
     signal_manager_042 = param[15],
     interruptor_040 = param[14],
     thread_pool_stuck_048 = param[18],
     dns_lookup_throttle_050 = param[19],
     next_tsc_calibration_052 = param[20],
     kernel_scheduler_054 = param[21],
     have_lock_do_cycle_056 = param[22],
     max_inter_cycle_timeout_058 = param[23],
     min_inter_cycle_timeout_060 = param[24],
     uring_064 = param[26],
     initialized_at_062 = param[25],
     arg_065 = caml_call1(Sexplib0_Sexp_conv[23], uring_064),
     bnds_013 = [0, [1, [0, _ah_, [0, arg_065, 0]]], 0],
     arg_063 = caml_call1(Sexplib0_Sexp_conv[23], initialized_at_062),
     bnds_013$0 = [0, [1, [0, _ai_, [0, arg_063, 0]]], bnds_013],
     arg_061 =
       caml_call1(Async_kernel_config[4][2], min_inter_cycle_timeout_060),
     bnds_013$1 = [0, [1, [0, _aj_, [0, arg_061, 0]]], bnds_013$0],
     arg_059 =
       caml_call1(Async_kernel_config[3][2], max_inter_cycle_timeout_058),
     bnds_013$2 = [0, [1, [0, _ak_, [0, arg_059, 0]]], bnds_013$1];
    function _f9_(param){
     function _gb_(_gc_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _gb_);
    }
    var
     arg_057 = caml_call2(Core[515], _f9_, have_lock_do_cycle_056),
     bnds_013$3 = [0, [1, [0, _al_, [0, arg_057, 0]]], bnds_013$2],
     arg_055 = caml_call1(Async_kernel_Scheduler[1], kernel_scheduler_054),
     bnds_013$4 = [0, [1, [0, _am_, [0, arg_055, 0]]], bnds_013$3],
     arg_053 = caml_call1(Time_stamp_counter[10], next_tsc_calibration_052),
     bnds_013$5 = [0, [1, [0, _an_, [0, arg_053, 0]]], bnds_013$4],
     arg_051 =
       caml_call2
        (Async_kernel_Throttle[2], Core[620], dns_lookup_throttle_050),
     bnds_013$6 = [0, [1, [0, _ao_, [0, arg_051, 0]]], bnds_013$5],
     arg_049 = caml_call1(Thread_pool_stuck_status[1], thread_pool_stuck_048),
     bnds_013$7 = [0, [1, [0, _ap_, [0, arg_049, 0]]], bnds_013$6];
    function _f__(_ga_){return 0;}
    var
     arg_047 = caml_call1(Sexplib0_Sexp_conv[24], _f__),
     bnds_013$8 = [0, [1, [0, _aq_, [0, arg_047, 0]]], bnds_013$7],
     arg_045 = caml_call1(Thread_pool[2], thread_pool_044),
     bnds_013$9 = [0, [1, [0, _ar_, [0, arg_045, 0]]], bnds_013$8],
     arg_043 = caml_call1(Async_unix_Signal_manager[1], signal_manager_042),
     bnds_013$10 = [0, [1, [0, _as_, [0, arg_043, 0]]], bnds_013$9],
     arg_041 = caml_call1(Async_unix_Interruptor[1], interruptor_040),
     bnds_013$11 = [0, [1, [0, _at_, [0, arg_041, 0]]], bnds_013$10],
     arg_039 = caml_call1(Core[389], scheduler_thread_id_038),
     bnds_013$12 = [0, [1, [0, _au_, [0, arg_039, 0]]], bnds_013$11],
     arg_037 = caml_call1(Time_ns_unix[85], timerfd_set_at_036),
     bnds_013$13 = [0, [1, [0, _av_, [0, arg_037, 0]]], bnds_013$12],
     arg_035 = caml_call2(Core[515], Linux_ext[35][4], timerfd_034),
     bnds_013$14 = [0, [1, [0, _aw_, [0, arg_035, 0]]], bnds_013$13],
     arg_033 = caml_call1(Sexplib0_Sexp_conv[23], external_fd_events_032),
     bnds_013$15 = [0, [1, [0, _ax_, [0, arg_033, 0]]], bnds_013$14],
     _f$_ = caml_call1(Read_write_pair[8], Core[323]),
     arg_031 =
       caml_call2(Async_unix_By_descr[1], _f$_, external_fd_by_descr_030),
     bnds_013$16 = [0, [1, [0, _ay_, [0, arg_031, 0]]], bnds_013$15],
     arg_029 =
       caml_call2
        (Async_unix_By_descr[1], Async_unix_Raw_fd[25], fd_by_descr_028),
     bnds_013$17 = [0, [1, [0, _az_, [0, arg_029, 0]]], bnds_013$16],
     arg_027 =
       caml_call1(Time_stamp_counter[24][10], time_spent_waiting_for_io_026),
     bnds_013$18 = [0, [1, [0, _aA_, [0, arg_027, 0]]], bnds_013$17],
     arg_025 = caml_call1(Core[389], num_busy_pollers_024),
     bnds_013$19 = [0, [1, [0, _aB_, [0, arg_025, 0]]], bnds_013$18],
     arg_023 = caml_call1(Sexplib0_Sexp_conv[23], busy_pollers_022),
     bnds_013$20 = [0, [1, [0, _aC_, [0, arg_023, 0]]], bnds_013$19],
     arg_021 = caml_call1(File_descr_watcher[1], file_descr_watcher_020),
     bnds_013$21 = [0, [1, [0, _aD_, [0, arg_021, 0]]], bnds_013$20],
     arg_019 =
       caml_call2
        (Core_Stack[2], Async_unix_Raw_fd[25], fds_whose_watching_has_changed),
     bnds_013$22 = [0, [1, [0, _aE_, [0, arg_019, 0]]], bnds_013$21],
     arg_017 = sexp_of_start_type(start_type_016),
     bnds_013$23 = [0, [1, [0, _aF_, [0, arg_017, 0]]], bnds_013$22],
     arg_015 = caml_call1(Nano_mutex[1], mutex_014),
     bnds_013$24 = [0, [1, [0, _aG_, [0, arg_015, 0]]], bnds_013$23];
    return [1, bnds_013$24];
   }
   function max_num_threads(t){return caml_call1(Thread_pool[8], t[16]);}
   function max_num_open_file_descrs(t){
    return caml_call1(Async_unix_By_descr[4], t[8]);
   }
   function current_execution_context(t){
    return caml_call1(Async_kernel_Scheduler[4], t[21]);
   }
   function with_execution_context(t, context, f){
    return caml_call3(Async_kernel_Scheduler[5], t[21], context, f);
   }
   function thread_pool_cpu_affinity(t){
    return caml_call1(Thread_pool[5], t[16]);
   }
   function lock(t){
    if(debug) caml_call1(Async_kernel_Debug[16], cst_waiting_on_lock);
    return caml_call1(Nano_mutex[7], t[1]);
   }
   function try_lock(t){
    return -326120466 <= caml_call1(Nano_mutex[9], t[1]) ? 1 : 0;
   }
   function unlock(t){
    if(debug) caml_call1(Async_kernel_Debug[16], cst_lock_released);
    return caml_call1(Nano_mutex[11], t[1]);
   }
   function with_lock(t, f){
    lock(t);
    function _f8_(param){return unlock(t);}
    return caml_call2(Core[259], f, _f8_);
   }
   function am_holding_lock(t){return caml_call1(Nano_mutex[5], t[1]);}
   var
    mutex_for_initializing_the_one = caml_call1(Nano_mutex[3], 0),
    the_one_and_only_ref = [0, _aH_];
   function is_ready_to_initialize(param){
    return 1 === the_one_and_only_ref[1][0] ? 1 : 0;
   }
   function is_initialized(param){
    return 2 === the_one_and_only_ref[1][0] ? 1 : 0;
   }
   function the_one_and_only_uncommon_case(param){
    function _f6_(param){
     var match = the_one_and_only_ref[1];
     switch(match[0]){
       case 0:
        var
         _f7_ =
           caml_call1(Sexplib0_Sexp_conv[7], cst_Async_the_one_and_only_not);
        return caml_call1(Core[261], _f7_);
       case 1:
        var f = match[1], t = caml_call1(f, 0);
        the_one_and_only_ref[1] = [2, t];
        return t;
       default: var t$0 = match[1]; return t$0;
     }
    }
    return caml_call2(Nano_mutex[12], mutex_for_initializing_the_one, _f6_);
   }
   function the_one_and_only(param){
    var match = the_one_and_only_ref[1];
    if(2 !== match[0]) return the_one_and_only_uncommon_case(0);
    var t = match[1];
    return t;
   }
   var fds_created_before_initializat = [0, 0];
   function create_fd_registration(t, fd){
    var match = caml_call3(Async_unix_By_descr[5], t[8], fd[1], fd);
    if(0 === match[0]) return 0;
    var
     error = match[1],
     backtrace =
       Ppx_inline_test_lib[1] ? 0 : [0, caml_call2(Base_Backtrace[2], 0, 0)],
     _f0_ = Ppx_inline_test_lib[1] ? 0 : [0, t],
     match$0 = 0;
    if(_f0_)
     var
      v = _f0_[1],
      match$1 = [0, [1, [0, _aI_, [0, sexp_of_t$1(v), 0]]], match$0];
    else
     var match$1 = match$0;
    if(backtrace)
     var
      v$0 = backtrace[1],
      _f1_ =
        [0,
         [1, [0, _aJ_, [0, caml_call1(Base_Backtrace[1], v$0), 0]]],
         match$1];
    else
     var _f1_ = match$1;
    var
     _f2_ =
       [0, [1, [0, _aK_, [0, caml_call1(Core_Error[9], error), 0]]], _f1_],
     _f3_ = caml_call1(Async_unix_Raw_fd[23], fd),
     _f4_ =
       [0,
        [1, [0, _aL_, [0, caml_call1(Core_unix_File_descr[2], _f3_), 0]]],
        _f2_],
     res =
       [0,
        caml_call1(Sexplib0_Sexp_conv[7], cst_Async_was_unable_to_add_a_),
        _f4_];
    if(res[2]) var _f5_ = [1, res]; else var h = res[1], _f5_ = h;
    return caml_call1(Core[261], _f5_);
   }
   function create_fd(avoid_setting_nonblock, kind, file_descr, info){
    var
     fd =
       caml_call4
        (Async_unix_Raw_fd[30],
         avoid_setting_nonblock,
         kind,
         file_descr,
         info);
    if(is_initialized(0))
     create_fd_registration(the_one_and_only(0), fd);
    else{
     var
      _fZ_ =
        function(param){
         return is_initialized(0)
                 ? create_fd_registration(the_one_and_only(0), fd)
                 : (fds_created_before_initializat
                    [1]
                   = [0, fd, fds_created_before_initializat[1]],
                   0);
        };
     caml_call2(Nano_mutex[12], mutex_for_initializing_the_one, _fZ_);
    }
    return fd;
   }
   function current_thread_id(param){
    var _fY_ = caml_call1(Core_thread[3], 0);
    return caml_call1(Core_thread[4], _fY_);
   }
   function is_main_thread(param){
    var _fX_ = current_thread_id(0);
    return caml_call2(Async_unix_Import[3], _fX_, 0);
   }
   function remove_fd(t, fd){
    return caml_call2(Async_unix_By_descr[9], t[8], fd[1]);
   }
   function maybe_start_closing_fd(t, fd){
    var _fV_ = caml_call2(Async_unix_Import[3], fd[9], 0);
    if(_fV_){
     var match = fd[6];
     if(typeof match !== "number" && 0 === match[0]){
      var do_close_syscall = match[2], execution_context = match[1];
      remove_fd(t, fd);
      caml_call2(Async_unix_Raw_fd[32], fd, 0);
      return caml_call4
              (Async_kernel_Scheduler[8],
               t[21],
               execution_context,
               do_close_syscall,
               0);
     }
     var _fW_ = 0;
    }
    else
     var _fW_ = _fV_;
    return _fW_;
   }
   function dec_num_active_syscalls_fd(t, fd){
    fd[9] = fd[9] - 1 | 0;
    return maybe_start_closing_fd(t, fd);
   }
   function invariant(t){
    try{
     var
      check =
        function(invariant, field){
         return caml_call1(invariant, caml_call2(Base_Field[3], field, t));
        },
      _eK_ = function(_fU_){return 0;},
      _eL_ = function(_fT_){return 0;},
      _eM_ =
        function(min_inter_cycle_timeout){
         var
          _fR_ = caml_call1(Async_kernel_config[3][5], t[23]),
          _fS_ =
            caml_call1(Async_kernel_config[4][5], min_inter_cycle_timeout);
         if(caml_call2(Time_ns_unix[72][16], _fS_, _fR_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aO_], 1);
        },
      _eN_ = function(_fQ_){return check(_eM_, _fQ_);},
      _eO_ = function(_fP_){return 0;},
      _eP_ = function(_fO_){return 0;},
      _eQ_ = Async_kernel_Scheduler[3],
      _eR_ = function(_fN_){return check(_eQ_, _fN_);},
      _eS_ = function(_fM_){return 0;},
      _eT_ = function(_fL_){return 0;},
      _eU_ = function(_fK_){return 0;},
      _eV_ = function(_fJ_){return 0;},
      _eW_ = Thread_pool[3],
      _eX_ = function(_fI_){return check(_eW_, _fI_);},
      _eY_ = Async_unix_Signal_manager[2],
      _eZ_ = function(_fH_){return check(_eY_, _fH_);},
      _e0_ = Async_unix_Interruptor[2],
      _e1_ = function(_fG_){return check(_e0_, _fG_);},
      _e2_ = function(_fF_){return 0;},
      _e3_ = function(_fE_){return 0;},
      _e4_ = function(_fD_){return 0;},
      _e5_ =
        function(fds){
         if(caml_call1(Core_List[18], fds)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aP_], 1);
        },
      _e6_ = function(_fC_){return check(_e5_, _fC_);},
      _e7_ = function(_fB_){return 0;},
      _e8_ =
        function(fd_by_descr){
         caml_call1(Async_unix_By_descr[2], fd_by_descr);
         function _fy_(fd){
          var _fz_ = fd[8];
          if(! _fz_) return _fz_;
          function _fA_(fd$0){return fd === fd$0 ? 1 : 0;}
          if(caml_call2(Core_Stack[12], t[3], _fA_)) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
         }
         return caml_call2(Async_unix_By_descr[11], fd_by_descr, _fy_);
        },
      _e9_ = function(_fx_){return check(_e8_, _fx_);},
      _e__ = function(_fw_){return 0;},
      _e$_ = function(_fv_){return 0;},
      _fa_ = function(_fu_){return 0;},
      _fb_ =
        function(file_descr_watcher){
         caml_call1(file_descr_watcher[2], file_descr_watcher[13]);
         function _fn_(file_descr, param){
          try{
           var match = caml_call2(Async_unix_By_descr[7], t[8], file_descr);
           if(match){
            var fd = match[1], _fr_ = caml_call1(Async_unix_Raw_fd[9], fd);
            if(! caml_call2(Async_unix_Import[4], _fr_, 0))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _aT_], 1);
            var _fs_ = 0;
           }
           else
            var
             _ft_ =
               caml_call1(Sexplib0_Sexp_conv[7], cst_missing_from_fd_by_descr),
             _fs_ = caml_call1(Core[261], _ft_);
           return _fs_;
          }
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _fo_ =
              [0,
               [1,
                [0,
                 _aR_,
                 [0, caml_call1(Core_unix_File_descr[2], file_descr), 0]]],
               0],
            _fp_ =
              [0, [1, [0, _aS_, [0, caml_call1(Core[625], exn), 0]]], _fo_],
            _fq_ =
              [1,
               [0, caml_call1(Sexplib0_Sexp_conv[7], cst_fd_problem), _fp_]];
           return caml_call1(Core[261], _fq_);
          }
         }
         return caml_call2
                 (file_descr_watcher[6], file_descr_watcher[13], _fn_);
        },
      _fc_ = function(_fm_){return check(_fb_, _fm_);},
      _fd_ =
        function(fds_whose_watching_has_changed){
         function _fl_(fd){
          if(! fd[8])
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aW_], 1);
          var match = caml_call2(Async_unix_By_descr[7], t[8], fd[1]);
          if(! match)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aV_], 1);
          var fd$0 = match[1];
          if(fd === fd$0) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aU_], 1);
         }
         return caml_call2
                 (Core_Stack[8], fds_whose_watching_has_changed, _fl_);
        },
      _fe_ = function(_fk_){return check(_fd_, _fk_);},
      _ff_ = function(_fj_){return 0;},
      _fg_ = function(_fi_){return 0;},
      _fh_ =
        caml_call26
         (Fields[27],
          _fg_,
          _ff_,
          _fe_,
          _fc_,
          _fa_,
          _e$_,
          _e__,
          _e9_,
          _e7_,
          _e6_,
          _e4_,
          _e3_,
          _e2_,
          _e1_,
          _eZ_,
          _eX_,
          _eV_,
          _eU_,
          _eT_,
          _eS_,
          _eR_,
          _eP_,
          _eO_,
          _eN_,
          _eL_,
          _eK_);
     return _fh_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _eH_ = [0, [1, [0, _aM_, [0, sexp_of_t$1(t), 0]]], 0],
      _eI_ = [0, [1, [0, _aN_, [0, caml_call1(Core[625], exn), 0]]], _eH_],
      _eJ_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_invariant_failed),
          _eI_]];
     return caml_call1(Core[261], _eJ_);
    }
   }
   function update_check_access(t, do_check){
    var
     _eC_ =
       do_check
        ? [0,
          function(param){
           var _eD_ = 1 - am_holding_lock(t);
           if(! _eD_) return _eD_;
           function _eE_(param){
            var
             arg2_068 = param[3],
             arg1_067 = param[2],
             arg0_066 = param[1],
             res0_069 = caml_call1(Base_Backtrace[1], arg0_066),
             res1_070 = sexp_of_t$1(arg1_067),
             res2_071 = caml_call1(Time_float_unix[60], arg2_068);
            return [1, [0, res0_069, [0, res1_070, [0, res2_071, 0]]]];
           }
           var
            _eF_ = caml_call1(Time_float_unix[15], 0),
            _eG_ = [0, caml_call2(Base_Backtrace[2], 0, 0), t, _eF_];
           caml_call3
            (Async_kernel_Debug[15],
             cst_attempt_to_access_Async_fr,
             _eG_,
             _eE_);
           return caml_call1(Core[83], 1);
          }]
        : 0;
    return caml_call2(Async_kernel_Scheduler[31], t[21], _eC_);
   }
   function try_create_timerfd(param){
    var match = Linux_ext[35][6];
    if(0 !== match[0]) return 0;
    var create = match[1], clock = Linux_ext[35][1][12];
    try{
     var
      _eA_ =
        [0,
         caml_call2
          (create,
           [0,
            caml_call2
             (Linux_ext[35][2][31],
              Linux_ext[35][2][40],
              Linux_ext[35][2][41])],
           clock)];
     return _eA_;
    }
    catch(_eB_){
     var _ey_ = caml_wrap_exception(_eB_);
     if(_ey_[1] === Core_unix[4]){
      var _ez_ = _ey_[2];
      if(typeof _ez_ === "number"){
       if(12 === _ez_){
        var timerfd = caml_call2(create, 0, clock);
        caml_call1(Core_unix[100], timerfd);
        caml_call1(Core_unix[98], timerfd);
        return [0, timerfd];
       }
       if(25 === _ez_) return 0;
      }
     }
     throw caml_maybe_attach_backtrace(_ey_, 0);
    }
   }
   function default_handle_thread_pool_stu(thread_pool, stuck_for){
    var
     _ej_ = caml_call2(Time_ns_unix[72][15], stuck_for, Async_unix_Config[20]);
    if(! _ej_) return _ej_;
    var
     should_abort =
       caml_call2(Time_ns_unix[72][15], stuck_for, Async_unix_Config[5]);
    if(should_abort)
     var text$0 = text;
    else
     var
      _ew_ =
        caml_call2(Time_ns_unix[72][102], Async_unix_Config[5], stuck_for),
      _ex_ = caml_call1(Time_ns_unix[72][110], _ew_),
      text$0 = caml_call3(Core[265], _a1_, text, _ex_);
    var _ek_ = caml_call1(Thread_pool[20], thread_pool), match = 0;
    if(_ek_)
     var
      v = _ek_[1],
      _el_ = [0, [1, [0, _aX_, [0, caml_call1(Core_Sexp[93], v), 0]]], match];
    else
     var _el_ = match;
    var
     _em_ = caml_call1(Thread_pool[8], thread_pool),
     _en_ = [0, [1, [0, _aY_, [0, caml_call1(Core[389], _em_), 0]]], _el_],
     _eo_ = caml_call1(Thread_pool[9], thread_pool),
     _ep_ = [0, [1, [0, _aZ_, [0, caml_call1(Core[389], _eo_), 0]]], _en_],
     _eq_ = caml_call1(Time_ns_unix[72][110], stuck_for),
     _er_ = [0, [1, [0, _a0_, [0, caml_call1(Core[558], _eq_), 0]]], _ep_],
     _es_ = [0, caml_call1(Sexplib0_Sexp_conv[7], text$0), _er_],
     _et_ = Core[628] ? Time_ns_unix[33] : caml_call1(Time_ns_unix[40], 0),
     res = [0, caml_call1(Time_ns_unix[85], _et_), _es_];
    if(res[2]) var message = [1, res]; else var h = res[1], message = h;
    if(! should_abort) return caml_call1(Core_Debug[3], message);
    if(1 - Core[628]) caml_call2(Async_unix_Dump_core_on_job_de[3], 0, 0);
    var
     _eu_ = caml_call1(Core_Error[20], message),
     _ev_ = caml_call1(Core_Error[28], _eu_);
    return caml_call3
            (Async_kernel_Monitor[15], Async_kernel_Monitor[24], 0, _ev_);
   }
   function thread_pool_has_unfinished_wor(t){
    var _ei_ = caml_call1(Thread_pool[10], t[16]);
    return caml_call2(Async_unix_Import[6], _ei_, 0);
   }
   function thread_safe_wakeup_scheduler(t){
    return caml_call1(Async_unix_Interruptor[5], t[14]);
   }
   function i_am_the_scheduler(t){
    var _eg_ = t[13], _eh_ = current_thread_id(0);
    return caml_call2(Async_unix_Import[3], _eh_, _eg_);
   }
   function set_fd_desired_watching(t, fd, read_or_write, desired){
    caml_call3(Read_write_pair[26], fd[7], read_or_write, desired);
    var _ef_ = 1 - fd[8];
    return _ef_ ? (fd[8] = 1, caml_call2(Core_Stack[25], t[3], fd)) : _ef_;
   }
   function give_up_on_watching(t, fd, read_or_write, watching){
    if(Async_kernel_Debug[3]){
     var
      _ee_ =
        function(param){
         var
          arg2_074 = param[3],
          arg1_073 = param[2],
          arg0_072 = param[1],
          res0_075 = caml_call1(Read_write_pair[1][1], arg0_072),
          res1_076 = caml_call1(Async_unix_Raw_fd[25], arg1_073),
          res2_077 = sexp_of_t$1(arg2_074);
         return [1, [0, res0_075, [0, res1_076, [0, res2_077, 0]]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_give_up_on_watching,
       [0, read_or_write, fd, t],
       _ee_);
    }
    if(typeof watching === "number") return 0;
    if(0 === watching[0]){
     var ready_to = watching[1];
     caml_call2(Async_kernel_Ivar[14], ready_to, -18684779);
     return set_fd_desired_watching(t, fd, read_or_write, 1);
    }
    var finished = watching[2], job = watching[1];
    caml_call2(Async_kernel_Scheduler[11], t[21], job);
    caml_call2(Async_kernel_Ivar[14], finished, -18684779);
    return set_fd_desired_watching(t, fd, read_or_write, 1);
   }
   function request_start_watching(t, fd, read_or_write, watching){
    if(Async_kernel_Debug[3]){
     var
      _ec_ =
        function(param){
         var
          arg2_080 = param[3],
          arg1_079 = param[2],
          arg0_078 = param[1],
          res0_081 = caml_call1(Read_write_pair[1][1], arg0_078),
          res1_082 = caml_call1(Async_unix_Raw_fd[25], arg1_079),
          res2_083 = sexp_of_t$1(arg2_080);
         return [1, [0, res0_081, [0, res1_082, [0, res2_083, 0]]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_request_start_watching,
       [0, read_or_write, fd, t],
       _ec_);
    }
    var match = caml_call2(Read_write_pair[23], fd[7], read_or_write);
    if(typeof match === "number")
     if(match)
      var
       result =
         caml_call1(Async_unix_Raw_fd[34], fd) ? -1034200365 : -655995373;
     else
      var
       _ed_ =
         17724 <= caml_call1(Async_unix_Raw_fd[31], fd)
          ? -655995373
          : -1034200365,
       result = _ed_;
    else
     var result = 233446106;
    if(-655995373 === result){
     set_fd_desired_watching(t, fd, read_or_write, watching);
     if(1 - i_am_the_scheduler(t)) thread_safe_wakeup_scheduler(t);
    }
    return result;
   }
   function request_stop_watching(t, fd, read_or_write, value){
    if(Async_kernel_Debug[3]){
     var
      _d$_ =
        function(param){
         var
          arg3_087 = param[4],
          arg2_086 = param[3],
          arg1_085 = param[2],
          arg0_084 = param[1],
          res0_088 = caml_call1(Read_write_pair[1][1], arg0_084),
          res1_089 = caml_call1(Async_unix_Raw_fd[4], arg1_085),
          res2_090 = caml_call1(Async_unix_Raw_fd[25], arg2_086),
          res3_091 = sexp_of_t$1(arg3_087);
         return [1,
                 [0, res0_088, [0, res1_089, [0, res2_090, [0, res3_091, 0]]]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_request_stop_watching,
       [0, read_or_write, value, fd, t],
       _d$_);
    }
    var match = caml_call2(Read_write_pair[23], fd[7], read_or_write);
    if(typeof match === "number") return 0;
    if(0 === match[0]){
     var ready_to = match[1];
     caml_call2(Async_kernel_Ivar[14], ready_to, value);
     set_fd_desired_watching(t, fd, read_or_write, 1);
     var _ea_ = 1 - i_am_the_scheduler(t);
     return _ea_ ? thread_safe_wakeup_scheduler(t) : _ea_;
    }
    var finished = match[2], job = match[1];
    if(-102231997 === value)
     return caml_call3(Async_kernel_Scheduler[10], t[21], job, 0);
    caml_call2(Async_kernel_Scheduler[11], t[21], job);
    caml_call2(Async_kernel_Ivar[14], finished, value);
    set_fd_desired_watching(t, fd, read_or_write, 1);
    var _eb_ = 1 - i_am_the_scheduler(t);
    return _eb_ ? thread_safe_wakeup_scheduler(t) : _eb_;
   }
   function post_check_got_timerfd(file_descr){
    var
     _d9_ =
       [0,
        [1,
         [0, _a2_, [0, caml_call1(Core_unix_File_descr[2], file_descr), 0]]],
        0],
     _d__ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_File_descr_watcher_returne),
         _d9_]];
    return caml_call1(Core[261], _d__);
   }
   function post_check_invalid_fd(file_descr){
    var
     _d7_ =
       [0,
        [1,
         [0, _a3_, [0, caml_call1(Core_unix_File_descr[2], file_descr), 0]]],
        0],
     _d8_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_File_descr_watcher_returne$0),
         _d7_]];
    return caml_call1(Core[261], _d8_);
   }
   function post_check_handle_fd(t, file_descr, read_or_write, event_type){
    if(caml_call2(Async_unix_By_descr[6], t[8], file_descr)){
     var fd = caml_call2(Async_unix_By_descr[8], t[8], file_descr);
     return request_stop_watching(t, fd, read_or_write, event_type);
    }
    var match = t[11];
    if(match){
     var tfd = match[1];
     if(caml_call2(Core_unix_File_descr[3], file_descr, tfd))
      return 914388854 <= read_or_write
              ? 0
              : post_check_got_timerfd(file_descr);
    }
    if(! caml_call2(Async_unix_By_descr[6], t[9], file_descr))
     return post_check_invalid_fd(file_descr);
    var ev = [0, file_descr, read_or_write, event_type];
    t[10] = [0, ev, t[10]];
    return 0;
   }
   var too_long = [0, 0];
   function cycle_took_longer_than_100us(cycle_time){
    too_long[1] = 0;
    var
     _d5_ = too_long[1],
     _d6_ = _d5_ ? runtime.magic_trace_long_async_cycle(0) : _d5_;
    return _d6_;
   }
   function maybe_report_long_async_cycles(cycle_time){
    var
     symbol = Time_ns_unix[72][18],
     _d4_ =
       caml_call2(symbol, cycle_time, caml_call1(Time_ns_unix[72][116], 100));
    return _d4_ ? cycle_took_longer_than_100us(cycle_time) : _d4_;
   }
   function _a4_(param){
    var
     cycle_time = caml_call1(Time_ns_unix[72][93], 15),
     words_before = runtime.core_gc_major_plus_minor_words(0);
    maybe_report_long_async_cycles(cycle_time);
    var
     words_after = runtime.core_gc_major_plus_minor_words(0),
     got = words_after - words_before | 0,
     sexpifier = Core[389],
     expect = 0,
     equal = 0,
     message = 0,
     here = 0;
    function comparator(a_092, b_093){
     return caml_call2(Core[382], a_092, b_093);
    }
    caml_call8
     (Ppx_assert_lib_Runtime[3],
      pos,
      sexpifier,
      comparator,
      here,
      message,
      equal,
      expect,
      got);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib[9],
     Inline_test_config,
     cst_maybe_report_long_async_cy,
     _a5_,
     cst_src_raw_scheduler_ml,
     617,
     0,
     465,
     _a4_);
   function maybe_report_long_async_cycles$0(t){
    return maybe_report_long_async_cycles(t[21][16]);
   }
   function create(mutex, opt, _dv_, _du_, _dt_, param){
    if(opt)
     var sth = opt[1], thread_pool_cpu_affinity = sth;
    else
     var thread_pool_cpu_affinity = Async_unix_Config[9];
    if(_dv_)
     var sth$0 = _dv_[1], file_descr_watcher = sth$0;
    else
     var file_descr_watcher = [0, Async_unix_Config[13]];
    if(_du_)
     var sth$1 = _du_[1], max_num_open_file_descrs = sth$1;
    else
     var max_num_open_file_descrs = Async_unix_Config[16];
    if(_dt_)
     var sth$2 = _dt_[1], max_num_threads = sth$2;
    else
     var max_num_threads = Async_unix_Config[17];
    if(debug) caml_call1(Async_kernel_Debug[16], cst_creating_scheduler);
    var
     _dw_ = caml_call1(Async_kernel_config[5][5], max_num_threads),
     _dx_ = caml_call3(Thread_pool[4], [0, thread_pool_cpu_affinity], _dw_, 0),
     thread_pool = caml_call1(Core[255], _dx_),
     num_file_descrs =
       caml_call1(Async_kernel_config[7][5], max_num_open_file_descrs),
     fd_by_descr = caml_call1(Async_unix_By_descr[3], num_file_descrs);
    function create_fd(kind, file_descr, info){
     var
      fd = caml_call4(Async_unix_Raw_fd[30], 0, kind, file_descr, info),
      _d3_ = caml_call3(Async_unix_By_descr[5], fd_by_descr, fd[1], fd);
     caml_call1(Core[255], _d3_);
     return fd;
    }
    var
     external_fd_by_descr =
       caml_call1(Async_unix_By_descr[3], num_file_descrs),
     interruptor = caml_call1(Async_unix_Interruptor[3], create_fd),
     t_ref = [0, 0];
    function handle_fd(read_or_write, ready_or_bad_fd, file_descr){
     var match = t_ref[1];
     if(! match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a6_], 1);
     var t = match[1];
     return post_check_handle_fd
             (t, file_descr, read_or_write, ready_or_bad_fd);
    }
    var _dy_ = -102231997, _dz_ = 914388854;
    function handle_fd_read_ready(_d2_){return handle_fd(_dz_, _dy_, _d2_);}
    var _dA_ = -3286312, _dB_ = 914388854;
    function handle_fd_read_bad(_d1_){return handle_fd(_dB_, _dA_, _d1_);}
    var _dC_ = -102231997, _dD_ = -477700929;
    function handle_fd_write_ready(_d0_){return handle_fd(_dD_, _dC_, _d0_);}
    var _dE_ = -3286312, _dF_ = -477700929;
    function handle_fd_write_bad(_dZ_){return handle_fd(_dF_, _dE_, _dZ_);}
    if(0 === file_descr_watcher[0]){
     var _dG_ = file_descr_watcher[1];
     if(2 === _dG_)
      var
       watcher =
         caml_call5
          (Async_unix_Select_file_descr_w[3],
           handle_fd_read_bad,
           handle_fd_write_bad,
           num_file_descrs,
           handle_fd_read_ready,
           handle_fd_write_ready),
       sexp_of_t = Async_unix_Select_file_descr_w[1],
       invariant = Async_unix_Select_file_descr_w[2],
       create = Async_unix_Select_file_descr_w[3],
       backend = Async_unix_Select_file_descr_w[4],
       set = Async_unix_Select_file_descr_w[5],
       iter = Async_unix_Select_file_descr_w[6],
       Pre = Async_unix_Select_file_descr_w[7],
       pre_check = Async_unix_Select_file_descr_w[8],
       Check_result = Async_unix_Select_file_descr_w[9],
       thread_safe_check = Async_unix_Select_file_descr_w[10],
       post_check = Async_unix_Select_file_descr_w[11],
       reset_in_forked_process = Async_unix_Select_file_descr_w[12],
       uring = 0,
       timerfd = 0,
       file_descr_watcher$0 =
         [0,
          sexp_of_t,
          invariant,
          create,
          backend,
          set,
          iter,
          Pre,
          pre_check,
          Check_result,
          thread_safe_check,
          post_check,
          reset_in_forked_process,
          watcher];
     else if(3 <= _dG_)
      var
       _dV_ = caml_call1(Async_kernel_config[2][5], Async_unix_Config[11]),
       _dW_ = caml_call3(Async_unix_Io_uring_raw[9], 0, _dV_, 0),
       uring$0 = caml_call1(Core_Or_error[40], _dW_),
       watcher$0 =
         caml_call4
          (Async_unix_Io_uring_file_descr[3],
           uring$0,
           num_file_descrs,
           handle_fd_read_ready,
           handle_fd_write_ready),
       sexp_of_t$0 = Async_unix_Io_uring_file_descr[1],
       invariant$0 = Async_unix_Io_uring_file_descr[2],
       create$0 = Async_unix_Io_uring_file_descr[3],
       backend$0 = Async_unix_Io_uring_file_descr[4],
       set$0 = Async_unix_Io_uring_file_descr[5],
       iter$0 = Async_unix_Io_uring_file_descr[6],
       Pre$0 = Async_unix_Io_uring_file_descr[7],
       pre_check$0 = Async_unix_Io_uring_file_descr[8],
       Check_result$0 = Async_unix_Io_uring_file_descr[9],
       thread_safe_check$0 = Async_unix_Io_uring_file_descr[10],
       post_check$0 = Async_unix_Io_uring_file_descr[11],
       reset_in_forked_process$0 = Async_unix_Io_uring_file_descr[12],
       uring = [0, uring$0],
       timerfd = 0,
       file_descr_watcher$0 =
         [0,
          sexp_of_t$0,
          invariant$0,
          create$0,
          backend$0,
          set$0,
          iter$0,
          Pre$0,
          pre_check$0,
          Check_result$0,
          thread_safe_check$0,
          post_check$0,
          reset_in_forked_process$0,
          watcher$0];
     else{
      var match = try_create_timerfd(0);
      if(match)
       var timerfd$0 = match[1], timerfd$1 = timerfd$0;
      else
       var
        _dX_ =
          caml_call1(Sexplib0_Sexp_conv[7], cst_Async_refuses_to_run_using),
        timerfd$1 = caml_call1(Core[261], _dX_);
      var
       watcher$1 =
         caml_call4
          (Async_unix_Epoll_file_descr_wa[3],
           timerfd$1,
           num_file_descrs,
           handle_fd_read_ready,
           handle_fd_write_ready),
       sexp_of_t$1 = Async_unix_Epoll_file_descr_wa[1],
       invariant$1 = Async_unix_Epoll_file_descr_wa[2],
       create$1 = Async_unix_Epoll_file_descr_wa[3],
       backend$1 = Async_unix_Epoll_file_descr_wa[4],
       set$1 = Async_unix_Epoll_file_descr_wa[5],
       iter$1 = Async_unix_Epoll_file_descr_wa[6],
       Pre$1 = Async_unix_Epoll_file_descr_wa[7],
       pre_check$1 = Async_unix_Epoll_file_descr_wa[8],
       Check_result$1 = Async_unix_Epoll_file_descr_wa[9],
       thread_safe_check$1 = Async_unix_Epoll_file_descr_wa[10],
       post_check$1 = Async_unix_Epoll_file_descr_wa[11],
       reset_in_forked_process$1 = Async_unix_Epoll_file_descr_wa[12],
       uring = 0,
       timerfd = [0, timerfd$1],
       file_descr_watcher$0 =
         [0,
          sexp_of_t$1,
          invariant$1,
          create$1,
          backend$1,
          set$1,
          iter$1,
          Pre$1,
          pre_check$1,
          Check_result$1,
          thread_safe_check$1,
          post_check$1,
          reset_in_forked_process$1,
          watcher$1];
     }
    }
    else
     var
      Custom = file_descr_watcher[1],
      watcher$2 =
        caml_call5
         (Custom[3],
          handle_fd_read_bad,
          handle_fd_write_bad,
          num_file_descrs,
          handle_fd_read_ready,
          handle_fd_write_ready),
      sexp_of_t$2 = Custom[1],
      invariant$2 = Custom[2],
      create$2 = Custom[3],
      backend$2 = Custom[4],
      set$2 = Custom[5],
      iter$2 = Custom[6],
      Pre$2 = Custom[7],
      pre_check$2 = Custom[8],
      Check_result$2 = Custom[9],
      thread_safe_check$2 = Custom[10],
      post_check$2 = Custom[11],
      reset_in_forked_process$2 = Custom[12],
      file_descr_watcher$1 =
        [0,
         sexp_of_t$2,
         invariant$2,
         create$2,
         backend$2,
         set$2,
         iter$2,
         Pre$2,
         pre_check$2,
         Check_result$2,
         thread_safe_check$2,
         post_check$2,
         reset_in_forked_process$2,
         watcher$2],
      uring = 0,
      timerfd = 0,
      file_descr_watcher$0 = file_descr_watcher$1;
    var
     _dH_ = caml_call1(Thread_pool[8], thread_pool) / 2 | 0,
     max_concurrent_dns_lookups = caml_call2(Core_Int[90], _dH_, 1),
     dns_lookup_throttle =
       caml_call2(Async_kernel_Throttle[5], 1, max_concurrent_dns_lookups),
     kernel_scheduler = caml_call1(Async_kernel_Scheduler[2], 0),
     _dI_ = caml_call2(Base_Backtrace[2], 0, 0),
     _dJ_ = Async_unix_Config[18],
     _dK_ = Async_unix_Config[14],
     _dL_ = 0,
     _dM_ = caml_call1(Time_stamp_counter[25], 0),
     _dN_ = 0;
    function _dO_(param){
     return caml_call1(Async_unix_Interruptor[5], interruptor);
    }
    var
     _dP_ = caml_call1(Async_unix_Signal_manager[3], _dO_),
     _dQ_ = Time_ns_unix[37],
     _dR_ = caml_call1(Time_stamp_counter[24][33], 0),
     _dS_ = caml_call2(Core_Uniform_array[16], 256, Async_unix_Busy_poller[6]),
     t =
       [0,
        mutex,
        0,
        caml_call1(Core_Stack[23], 0),
        file_descr_watcher$0,
        _dS_,
        0,
        _dR_,
        fd_by_descr,
        external_fd_by_descr,
        0,
        timerfd,
        _dQ_,
        -1,
        interruptor,
        _dP_,
        thread_pool,
        default_handle_thread_pool_stu,
        _dN_,
        dns_lookup_throttle,
        _dM_,
        kernel_scheduler,
        _dL_,
        _dK_,
        _dJ_,
        _dI_,
        uring];
    t_ref[1] = [0, t];
    update_check_access(t, Async_unix_Config[7]);
    function _dT_(_dY_){return create_fd_registration(t, _dY_);}
    var _dU_ = caml_call1(Core_List[59], fds_created_before_initializat[1]);
    caml_call2(Core_List[19], _dU_, _dT_);
    fds_created_before_initializat[1] = 0;
    return t;
   }
   function init(take_the_lock){
    var mutex = caml_call1(Nano_mutex[3], 0);
    if(take_the_lock) caml_call1(Nano_mutex[7], mutex);
    the_one_and_only_ref[1] =
     [1, function(param){return create(mutex, 0, 0, 0, 0, 0);}];
    return 0;
   }
   init(1);
   function _a7_(take_the_lock){
    var _ds_ = the_one_and_only_ref[1];
    if(2 === _ds_[0]){
     var match = _ds_[1], file_descr_watcher = match[4], timerfd = match[11];
     caml_call1(file_descr_watcher[12], file_descr_watcher[13]);
     if(timerfd){var tfd = timerfd[1]; caml_call2(Core_unix[53], 0, tfd);}
    }
    caml_call1(Async_kernel_Scheduler[68], 0);
    fds_created_before_initializat[1] = 0;
    return init(take_the_lock);
   }
   function reset_in_forked_process_withou(param){return _a7_(0);}
   function reset_in_forked_process(param){return _a7_(1);}
   function make_async_unusable(param){
    reset_in_forked_process(0);
    caml_call1(Async_kernel_Scheduler[67], 0);
    the_one_and_only_ref[1] =
     [1,
      function(param){
       var
        _dr_ =
          caml_call1(Sexplib0_Sexp_conv[7], cst_Async_is_unusable_due_to_S);
       return caml_call1(Core[261], _dr_);
      }];
    return 0;
   }
   function thread_safe_enqueue_external_j(t, f){
    return caml_call2(Async_kernel_Scheduler[55], t[21], f);
   }
   function have_lock_do_cycle$1(t){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15], cst_have_lock_do_cycle$0, t, sexp_of_t$1);
    var match = t[22];
    if(match){var f = match[1]; return caml_call1(f, 0);}
    caml_call1(Async_kernel_Scheduler[14], t[21]);
    maybe_report_long_async_cycles$0(t);
    var _dq_ = 1 - i_am_the_scheduler(t);
    return _dq_ ? thread_safe_wakeup_scheduler(t) : _dq_;
   }
   function log_sync_changed_fds_to_file_d(t, file_descr, desired){
    var _do_ = t[4];
    function _dp_(param){
     var
      arg2_096 = param[3],
      arg1_095 = param[2],
      arg0_094 = param[1],
      res0_097 = caml_call1(Core_unix_File_descr[2], arg0_094),
      res1_098 = caml_call2(Read_write_pair[8], Core[323], arg1_095),
      res2_099 = caml_call1(_do_[1], arg2_096);
     return [1, [0, res0_097, [0, res1_098, [0, res2_099, 0]]]];
    }
    return caml_call3
            (Async_kernel_Debug[15],
             cst_File_descr_watcher_set,
             [0, file_descr, desired, _do_[13]],
             _dp_);
   }
   function sync_changed_fd_failed(t, fd, desired, exn){
    var
     bt = caml_call1(Base_Backtrace[6][4], 0),
     _di_ = [0, [1, [0, _a8_, [0, sexp_of_t$1(t), 0]]], 0],
     _dj_ =
       [0, [1, [0, _a9_, [0, caml_call1(Base_Backtrace[1], bt), 0]]], _di_],
     _dk_ = [0, [1, [0, _a__, [0, caml_call1(Core[625], exn), 0]]], _dj_],
     _dl_ =
       [0,
        [1, [0, _a$_, [0, caml_call1(Async_unix_Raw_fd[25], fd), 0]]],
        _dk_],
     _dm_ =
       [0,
        [1,
         [0, _ba_, [0, caml_call2(Read_write_pair[8], Core[323], desired), 0]]],
        _dl_],
     _dn_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_sync_changed_fds_to_file_d),
         _dm_]];
    return caml_call1(Core[261], _dn_);
   }
   function sync_changed_fds_to_file_descr(t){
    var _c$_ = 1 - caml_call1(Core_Stack[7], t[3]);
    if(_c$_){
     var F = t[4];
     for(;;){
      if(caml_call1(Core_Stack[7], t[3])){var _da_ = 0; break;}
      var fd = caml_call1(Core_Stack[27], t[3]);
      fd[8] = 0;
      var
       _db_ = function(watching){return typeof watching === "number" ? 0 : 1;},
       desired = caml_call2(Read_write_pair[20], fd[7], _db_);
      if(Async_kernel_Debug[3])
       log_sync_changed_fds_to_file_d(t, fd[1], desired);
      try{var _df_ = caml_call3(F[5], F[13], fd[1], desired), _dc_ = _df_;}
      catch(exn$0){
       var
        exn = caml_wrap_exception(exn$0),
        _dc_ = sync_changed_fd_failed(t, fd, desired, exn);
      }
      if(17724 <= _dc_){
       var
        _dd_ =
          function(fd){
            return function(read_or_write, watching){
             if(typeof watching === "number" && watching){
              caml_call3(Read_write_pair[26], fd[7], read_or_write, 0);
              return dec_num_active_syscalls_fd(t, fd);
             }
             return 0;};
           }
           (fd);
       caml_call2(Read_write_pair[17], fd[7], _dd_);
      }
      else{
       var
        _de_ =
          function(fd){
            return function(_dg_, _dh_){
             return give_up_on_watching(t, fd, _dg_, _dh_);};
           }
           (fd);
       caml_call2(Read_write_pair[17], fd[7], _de_);
      }
     }
    }
    else
     var _da_ = _c$_;
    return _da_;
   }
   function maybe_calibrate_tsc(t){
    var _c5_ = caml_call1(Core_Lazy[40], Time_stamp_counter[30]);
    if(_c5_){
     var
      now = caml_call1(Time_stamp_counter[25], 0),
      _c6_ = caml_call2(Time_stamp_counter[13], now, t[20]);
     if(_c6_){
      var calibrator = caml_call1(Core[248], Time_stamp_counter[30]);
      caml_call1(Time_stamp_counter[23][12], calibrator);
      var
       _c7_ = caml_call1(Core_Int63[72], 1000000000),
       _c8_ = caml_call2(Time_stamp_counter[24][39], _c7_, calibrator);
      t[20] = caml_call2(Time_stamp_counter[27], now, _c8_);
      var _c9_ = 0;
     }
     else
      var _c9_ = _c6_;
     var _c__ = _c9_;
    }
    else
     var _c__ = _c5_;
    return _c__;
   }
   function create_job(execution_context, t, f, x){
    if(execution_context)
     var e = execution_context[1], execution_context$0 = e;
    else
     var execution_context$0 = current_execution_context(t);
    return caml_call4
            (Async_kernel_Scheduler[9], t[21], execution_context$0, f, x);
   }
   function dump_core_on_job_delay(param){
    var _c3_ = Async_unix_Config[8];
    if(! _c3_) return 0;
    var
     match = _c3_[1],
     how_to_dump = match[2],
     dump_if_delayed_by = match[1],
     _c4_ = caml_call1(Time_ns_unix[72][144], dump_if_delayed_by);
    return caml_call2(Async_unix_Dump_core_on_job_de[2], _c4_, how_to_dump);
   }
   function num_busy_pollers$1(t){return t[6];}
   function add_busy_poller(t, max_busy_wait_duration, f){
    var _cZ_ = caml_call1(Core_Uniform_array[19], t[5]);
    if(caml_call2(Async_unix_Import[3], t[6], _cZ_)){
     var
      _c0_ = caml_call1(Sexplib0_Sexp_conv[7], cst_add_busy_poller_maximum_nu);
     caml_call1(Core[261], _c0_);
    }
    caml_call3(Core_Uniform_array[23], t[5], t[6], f);
    t[6] = t[6] + 1 | 0;
    var
     _c1_ = caml_call1(Async_kernel_config[3][5], t[23]),
     _c2_ = caml_call2(Time_ns_unix[72][23], _c1_, max_busy_wait_duration);
    t[23] = caml_call1(Async_kernel_config[3][4], _c2_);
    return 0;
   }
   function init$0(t){
    dump_core_on_job_delay(0);
    function _cQ_(param){return thread_safe_wakeup_scheduler(t);}
    caml_call2(Async_kernel_Scheduler[51], t[21], _cQ_);
    t[13] = current_thread_id(0);
    caml_call2(Async_unix_Signal_manager[4], t[15], Core_Signal[59]);
    var
     interruptor_finished = caml_call1(Async_kernel_Ivar[12], 0),
     interruptor_read_fd = caml_call1(Async_unix_Interruptor[4], t[14]);
    function problem_with_interruptor(param){
     var
      _cW_ = [0, [1, [0, _bb_, [0, sexp_of_t$1(t), 0]]], 0],
      _cX_ =
        [0,
         [1,
          [0,
           _bc_,
           [0, caml_call1(Async_unix_Raw_fd[25], interruptor_read_fd), 0]]],
         _cW_],
      _cY_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_can_not_watch_interruptor),
          _cX_]];
     return caml_call1(Core[261], _cY_);
    }
    var _cR_ = 0;
    function _cS_(_cV_){return 0;}
    var
     match =
       request_start_watching
        (t,
         interruptor_read_fd,
         914388854,
         [1,
          caml_call4
           (Async_kernel_Scheduler[9],
            t[21],
            Async_kernel_Execution_context[7],
            _cS_,
            _cR_),
          interruptor_finished]);
    a:
    if(-655995373 !== match && 233446106 > match){problem_with_interruptor(0); break a;}
    function _cT_(param){return problem_with_interruptor(0);}
    var _cU_ = caml_call1(Async_kernel_Ivar[19], interruptor_finished);
    return caml_call2(Async_unix_Import[22], _cU_, _cT_);
   }
   function fds_may_produce_events(t){
    var interruptor_fd = caml_call1(Async_unix_Interruptor[4], t[14]);
    function _cM_(fd){
     var _cN_ = 1 - caml_call2(Async_unix_Raw_fd[27], fd, interruptor_fd);
     if(! _cN_) return _cN_;
     function _cO_(watching){
      if(typeof watching === "number" && ! watching) return 0;
      return 1;
     }
     var _cP_ = caml_call1(Async_unix_Raw_fd[13], fd);
     return caml_call2(Read_write_pair[15], _cP_, _cO_);
    }
    return caml_call2(Async_unix_By_descr[12], t[8], _cM_);
   }
   function check_file_descr_watcher(t, timeout, span_or_unit){
    var F = t[4];
    if(Async_kernel_Debug[3])
     caml_call3
      (Async_kernel_Debug[15], cst_File_descr_watcher_pre_che, t, sexp_of_t$1);
    var pre = caml_call1(F[8], F[13]);
    unlock(t);
    caml_call1(Core_thread[10], 0);
    if(Async_kernel_Debug[3]){
     var
      _cI_ =
        function(param){
         var arg1_103 = param[2], arg0_102 = param[1];
         if(typeof arg0_102 === "number")
          var res0_104 = _bd_;
         else
          var
           v_101 = arg0_102[2],
           res0_104 =
             [1, [0, _be_, [0, caml_call1(Time_ns_unix[72][10], v_101), 0]]];
         var res1_105 = sexp_of_t$1(arg1_103);
         return [1, [0, res0_104, [0, res1_105, 0]]];
        },
      _cJ_ =
        [0,
         caml_call2
          (Async_unix_File_descr_watcher_[1][1], timeout, span_or_unit),
         t];
     caml_call3
      (Async_kernel_Debug[15], cst_File_descr_watcher_thread_, _cJ_, _cI_);
    }
    var
     before = caml_call1(Time_stamp_counter[25], 0),
     check_result = caml_call4(F[10], F[13], pre, timeout, span_or_unit),
     after = caml_call1(Time_stamp_counter[25], 0),
     _cK_ = caml_call2(Time_stamp_counter[26], after, before);
    t[7] = caml_call2(Time_stamp_counter[24][35], t[7], _cK_);
    lock(t);
    caml_call1(Async_unix_Interruptor[6], t[14]);
    if(Async_kernel_Debug[3]){
     var
      _cL_ =
        function(param){
         var
          arg1_107 = param[2],
          arg0_106 = param[1],
          res0_108 = caml_call1(F[9][1], arg0_106),
          res1_109 = sexp_of_t$1(arg1_107);
         return [1, [0, res0_108, [0, res1_109, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_File_descr_watcher_post_ch,
       [0, check_result, t],
       _cL_);
    }
    return caml_call2(F[11], F[13], check_result);
   }
   function run_busy_pollers_once(t, deadline){
    var did_work = [0, 0];
    try{
     var _cF_ = t[6] - 1 | 0, _cE_ = 0;
     if(_cF_ >= 0){
      var i = _cE_;
      for(;;){
       var
        poller = caml_call2(Core_Uniform_array[21], t[5], i),
        _cG_ = caml_call2(Async_unix_Busy_poller[3], poller, deadline);
       if(caml_call2(Async_unix_Import[4], _cG_, 0)) did_work[1] = 1;
       var _cH_ = i + 1 | 0;
       if(_cF_ === i) break;
       var i = _cH_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     caml_call3(Async_kernel_Monitor[15], Async_kernel_Monitor[24], 0, exn);
    }
    return did_work[1];
   }
   function run_busy_pollers(t, timeout){
    var
     calibrator = caml_call1(Core[248], Time_stamp_counter[30]),
     _cy_ = caml_call2(Time_stamp_counter[24][41], timeout, calibrator),
     _cz_ = caml_call1(Time_stamp_counter[25], 0),
     deadline = [0, caml_call2(Time_stamp_counter[27], _cz_, _cy_)];
    for(;;){
     var
      pollers_did_something = run_busy_pollers_once(t, deadline[1]),
      now = caml_call1(Time_stamp_counter[25], 0);
     if(pollers_did_something)
      if(caml_call1(Async_kernel_Scheduler[45], t[21]))
       deadline[1] = now;
      else if(caml_call1(Async_kernel_Scheduler[16], t[21])){
       var
        _cA_ = caml_call2(Time_stamp_counter[32], now, calibrator),
        _cB_ = caml_call1(Async_kernel_Scheduler[18], t[21]),
        _cC_ = caml_call2(Time_ns_unix[47], _cB_, _cA_),
        new_timeout = caml_call2(Time_stamp_counter[24][41], _cC_, calibrator),
        _cD_ = caml_call2(Time_stamp_counter[27], now, new_timeout);
       deadline[1] = caml_call2(Time_stamp_counter[21], deadline[1], _cD_);
      }
     if(! caml_call2(Time_stamp_counter[17], now, deadline[1])) return 0;
    }
   }
   function compute_timeout_and_check_file(t){
    var
     min_inter_cycle_timeout = t[24],
     max_inter_cycle_timeout = t[23],
     have_busy_pollers = caml_call2(Async_unix_Import[4], t[6], 0),
     match = t[11];
    a:
    {
     if(match && ! have_busy_pollers){
      var
       timerfd = match[1],
       have_min_inter_cycle_timeout =
         caml_call2
          (Time_ns_unix[72][18],
           min_inter_cycle_timeout,
           Time_ns_unix[72][76]);
      if(caml_call1(Async_kernel_Scheduler[45], t[21]))
       var
        max_inter_cycle_timeout$0 =
          have_min_inter_cycle_timeout
           ? (t
              [12]
             = Time_ns_unix[37],
             caml_call2(Linux_ext[35][8], timerfd, min_inter_cycle_timeout),
             max_inter_cycle_timeout)
           : Time_ns_unix[72][76];
      else if(caml_call1(Async_kernel_Scheduler[16], t[21])){
       var next_event_at$0 = caml_call1(Async_kernel_Scheduler[18], t[21]);
       if(have_min_inter_cycle_timeout)
        var
         _cw_ = caml_call1(Time_ns_unix[40], 0),
         _cx_ = caml_call2(Time_ns_unix[41], _cw_, min_inter_cycle_timeout),
         set_timerfd_at = caml_call2(Time_ns_unix[98], next_event_at$0, _cx_);
       else
        var set_timerfd_at = next_event_at$0;
       if(1 - caml_call2(Time_ns_unix[95], t[12], set_timerfd_at)){
        t[12] = set_timerfd_at;
        caml_call2(Linux_ext[35][7], timerfd, set_timerfd_at);
       }
       var max_inter_cycle_timeout$0 = max_inter_cycle_timeout;
      }
      else
       var max_inter_cycle_timeout$0 = max_inter_cycle_timeout;
      var file_descr_watcher_timeout = max_inter_cycle_timeout$0;
      break a;
     }
     if(caml_call1(Async_kernel_Scheduler[45], t[21]))
      var file_descr_watcher_timeout = min_inter_cycle_timeout;
     else if(caml_call1(Async_kernel_Scheduler[16], t[21]))
      var
       next_event_at = caml_call1(Async_kernel_Scheduler[18], t[21]),
       _ct_ = caml_call1(Time_ns_unix[40], 0),
       _cu_ = caml_call2(Time_ns_unix[47], next_event_at, _ct_),
       _cv_ = caml_call2(Time_ns_unix[72][24], min_inter_cycle_timeout, _cu_),
       file_descr_watcher_timeout =
         caml_call2(Time_ns_unix[72][23], max_inter_cycle_timeout, _cv_);
     else
      var file_descr_watcher_timeout = max_inter_cycle_timeout;
    }
    return caml_call2
             (Time_ns_unix[72][16],
              file_descr_watcher_timeout,
              Time_ns_unix[72][76])
            ? (run_busy_pollers_once
               (t, Time_stamp_counter[29]),
              check_file_descr_watcher(t, 0, 0))
            : have_busy_pollers
              ? (run_busy_pollers
                 (t, file_descr_watcher_timeout),
                check_file_descr_watcher(t, 0, 0))
              : check_file_descr_watcher(t, 1, file_descr_watcher_timeout);
   }
   function one_iter(t){
    if(caml_call1(Async_kernel_Scheduler[33], t[21])) invariant(t);
    maybe_calibrate_tsc(t);
    sync_changed_fds_to_file_descr(t);
    compute_timeout_and_check_file(t);
    if(debug)
     caml_call1(Async_kernel_Debug[16], cst_handling_delivered_signals);
    caml_call1(Async_unix_Signal_manager[10], t[15]);
    have_lock_do_cycle$1(t);
    return caml_call1(Async_kernel_Scheduler[20], t[21]);
   }
   function be_the_scheduler(opt, t){
    if(opt)
     var sth = opt[1], raise_unhandled_exn = sth;
    else
     var raise_unhandled_exn = 0;
    init$0(t);
    try{
     for(;;){var match = one_iter(t); if(match) break;}
     var
      error = match[1],
      _cr_ = 830880297,
      error$1 = error,
      error_kind = _cr_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     unlock(t);
     var
      _cm_ =
        function(param){
         var
          arg1_111 = param[2],
          arg0_110 = param[1],
          res0_112 = caml_call1(Core[625], arg0_110),
          res1_113 = sexp_of_t$1(arg1_111);
         return [1, [0, res0_112, [0, res1_113, 0]]];
        },
      error$0 =
        caml_call5
         (Core_Error[19], 0, 0, cst_bug_in_async_scheduler, [0, exn, t], _cm_),
      error$1 = error$0,
      error_kind = 436759384;
    }
    if(raise_unhandled_exn) return caml_call1(Core_Error[30], error$1);
    try{caml_call1(Stdlib[103], 0);}catch(_cs_){}
    if(830880297 <= error_kind){
     var
      _cn_ = [0, caml_call1(Core_Error[9], error$1), 0],
      _co_ = caml_call1(Time_ns_unix[40], 0),
      _cp_ = [1, [0, caml_call1(Time_ns_unix[85], _co_), _cn_]],
      _cq_ =
        [0,
         [24,
          _bg_,
          function(param, custom_printf_114){
           return caml_call2(Core_Sexp[84], 0, custom_printf_114);
          },
          _bf_],
         cst_Sexp_hum];
     caml_call2(Core[243], _cq_, _cp_);
    }
    else{
     caml_call3
      (Async_kernel_Debug[15],
       cst_unhandled_exception_in_Asy,
       error$1,
       Core_Error[9]);
     caml_call1(Async_kernel_Debug[16], cst_dumping_core);
     caml_call2(Async_unix_Dump_core_on_job_de[3], 0, 0);
    }
    return caml_call1(Core_unix[274], 1);
   }
   function add_finalizer(t, heap_block, f){
    return caml_call3(Async_kernel_Scheduler[47], t[21], heap_block, f);
   }
   function add_finalizer_exn(t, x, f){
    function _cl_(heap_block){
     return caml_call1(f, caml_call1(Heap_block[4], heap_block));
    }
    return add_finalizer(t, caml_call1(Heap_block[3], x), _cl_);
   }
   function async_kernel_config_task_id(param){
    var
     v_115 = caml_call1(Core_unix[34], 0),
     _ck_ = caml_call1(Core_thread[3], 0),
     thread_id = caml_call1(Core_thread[4], _ck_),
     res0_119 = [1, [0, _bh_, [0, caml_call1(Core_Pid[13], v_115), 0]]],
     res1_120 = [1, [0, _bi_, [0, caml_call1(Core[389], thread_id), 0]]];
    return [1, [0, res0_119, [0, res1_120, 0]]];
   }
   function set_task_id(param){
    Async_kernel_config[35][1] = async_kernel_config_task_id;
    return 0;
   }
   function raise_if_any_jobs_were_schedul(param){
    var
     _ch_ = caml_call1(Async_kernel_Scheduler[2], 0),
     match = caml_call1(Async_kernel_Scheduler[54], _ch_);
    if(! match) return 0;
    var
     bt = match[1],
     _ci_ = [0, caml_call1(Base_Backtrace[1], bt), 0],
     _cj_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_error_program_is_attemptin),
         _ci_]];
    return caml_call1(Core[261], _cj_);
   }
   function is_running(t){
    var _cg_ = t[2];
    if(typeof _cg_ === "number" && ! _cg_) return 0;
    return 1;
   }
   function go(raise_unhandled_exn, param){
    if(debug) caml_call1(Async_kernel_Debug[16], cst_Scheduler_go);
    set_task_id(0);
    var t = the_one_and_only(0);
    if(1 - am_holding_lock(t)) lock(t);
    var _cd_ = t[2];
    if(typeof _cd_ === "number")
     switch(_cd_){
       case 0:
        t[2] = 1; return be_the_scheduler(raise_unhandled_exn, t);
       case 1:
        var
         _ce_ =
           caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_Scheduler_go_more_t);
        return caml_call1(Core[261], _ce_);
       default:
        unlock(t);
        thread_safe_wakeup_scheduler(t);
        return caml_call1(Time_float_unix[112], 0);
     }
    var
     _cf_ = caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_mix_Scheduler_go_an);
    return caml_call1(Core[261], _cf_);
   }
   function go_main
   (raise_unhandled_exn,
    file_descr_watcher,
    max_num_open_file_descrs,
    max_num_threads,
    main,
    param){
    var _b$_ = the_one_and_only_ref[1];
    if(2 === _b$_[0]){
     var
      initialized_at = _b$_[1][25],
      _cb_ =
        [0,
         [1, [0, _bj_, [0, caml_call1(Base_Backtrace[1], initialized_at), 0]]],
         0],
      _cc_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Async_was_initialized_prio),
          _cb_]];
     caml_call1(Core[261], _cc_);
    }
    var
     max_num_open_file_descrs$0 =
       caml_call2
        (Core_Option[34], max_num_open_file_descrs, Async_kernel_config[7][4]),
     max_num_threads$0 =
       caml_call2(Core_Option[34], max_num_threads, Async_kernel_config[5][4]),
     mutex = caml_call1(Nano_mutex[3], 0);
    caml_call1(Nano_mutex[7], mutex);
    the_one_and_only_ref[1] =
     [1,
      function(param){
       return create
               (mutex,
                0,
                file_descr_watcher,
                max_num_open_file_descrs$0,
                max_num_threads$0,
                0);
      }];
    var _ca_ = caml_call1(Async_unix_Import[30], 0);
    caml_call2(Async_kernel_Deferred[4], _ca_, main);
    return go(raise_unhandled_exn, 0);
   }
   function is_the_one_and_only_running(param){
    return is_ready_to_initialize(0) ? 0 : is_running(the_one_and_only(0));
   }
   function report_long_cycle_times(opt, param){
    if(opt)
     var sth = opt[1], cutoff = sth;
    else
     var cutoff = caml_call1(Core[630], 1.);
    function _b7_(span){
     var
      _b9_ =
        caml_call5
         (Core_Error[19],
          0,
          0,
          cst_long_async_cycle,
          span,
          Time_ns_unix[72][10]),
      _b__ = caml_call1(Core_Error[12], _b9_);
     return caml_call2(Core[243], _bk_, _b__);
    }
    var
     _b8_ = caml_call1(long_cycles, caml_call1(Time_ns_unix[72][146], cutoff));
    return caml_call2(Async_kernel_Async_stream[18], _b8_, _b7_);
   }
   function set_check_invariants(bool){
    var _b6_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2(Async_kernel_Scheduler[34], _b6_, bool);
   }
   function set_detect_invalid_access_from(bool){
    return update_check_access(the_one_and_only(0), bool);
   }
   function set_max_inter_cycle_timeout$0(span){
    var
     _b4_ = caml_call1(Time_ns_unix[72][146], span),
     _b5_ = caml_call1(Async_kernel_config[3][4], _b4_);
    the_one_and_only(0)[23] = _b5_;
    return 0;
   }
   function t(param){return the_one_and_only(0);}
   function with_t_once_started(f){
    var match = the_one_and_only_ref[1];
    if(2 === match[0]){
     var t$0 = match[1];
     if(is_running(t$0)) return caml_call1(f, t$0);
    }
    function _b2_(param){return caml_call1(f, t(0));}
    var _b3_ = caml_call1(Async_unix_Import[30], 0);
    return caml_call2(Async_kernel_Deferred[11], _b3_, _b2_);
   }
   function fold_fields(init, folder){
    var t$0 = t(0);
    function f(ac, field){return caml_call3(folder[1], ac, t$0, field);}
    return caml_call27
            (Fields[28],
             init,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f,
             f);
   }
   function handle_thread_pool_stuck$1(f){
    var
     t$0 = t(0),
     kernel_scheduler = t$0[21],
     execution_context =
       caml_call1(Async_kernel_Scheduler[4], kernel_scheduler);
    t$0[17] =
     function(param, stuck_for){
      var _b0_ = 0;
      function _b1_(param){return caml_call1(f, stuck_for);}
      return caml_call4
              (Async_kernel_Scheduler[8],
               kernel_scheduler,
               execution_context,
               _b1_,
               _b0_);
     };
    return 0;
   }
   var created = [0, 0];
   function create_exn(param){
    if(created[1]) caml_call1(Core[6], cst_Thread_pool_stats_subscrip);
    created[1] = 1;
    return 0;
   }
   function get_and_reset(param){
    var t$0 = t(0);
    return caml_call1(Thread_pool[24], t$0[16]);
   }
   var
    Thread_pool_stats_subscription = [0, created, create_exn, get_and_reset],
    For_metrics = [0, Thread_pool_stats_subscription];
   function current_thread_can_cycle(param){
    if(is_ready_to_initialize(0)) return 1;
    var t = the_one_and_only(0);
    if(1 - am_holding_lock(t)){
     var
      _bY_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Attempt_to_call_current_th);
     caml_call1(Core[261], _bY_);
    }
    var match = t[2];
    if(typeof match === "number"){if(! match) return 1;}
    else{var active = match[1]; if(! active[1]) return i_am_the_scheduler(t);}
    if(i_am_the_scheduler(t)){
     var
      _bZ_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_External_current);
     caml_call1(Core[261], _bZ_);
    }
    return 0;
   }
   function collect_events(event_list){
    function _bV_(ev){
     if(-3286312 > ev[3]) return [0, ev[1], ev[2]];
     var
      _bW_ =
        [0,
         [1, [0, _bl_, [0, caml_call1(Core_unix_File_descr[2], ev[1]), 0]]],
         0],
      _bX_ =
        [1,
         [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Bad_file_descriptor), _bW_]];
     return caml_call1(Core[261], _bX_);
    }
    return caml_call2(Core_List[51], event_list, _bV_);
   }
   function run_one_cycle(t){
    set_task_id(0);
    var match = t[2];
    if(typeof match === "number")
     if(match){
      var _bL_ = current_thread_id(0);
      if(caml_call2(Async_unix_Import[3], t[13], _bL_))
       var
        _bM_ =
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_External_run_one),
        active = caml_call1(Core[261], _bM_);
      else
       var
        _bS_ =
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_External_run_one$2),
        active = caml_call1(Core[261], _bS_);
     }
     else{
      var active$0 = [0, 0];
      t[2] = [0, active$0];
      init$0(t);
      var active = active$0;
     }
    else
     var active$1 = match[1], active = active$1;
    if(active[1]){
     var
      _bN_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_External_run_one$0);
     caml_call1(Core[261], _bN_);
    }
    var _bO_ = current_thread_id(0);
    if(caml_call2(Async_unix_Import[6], t[13], _bO_)){
     var
      _bP_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_External_run_one$1);
     caml_call1(Core[261], _bP_);
    }
    active[1] = 1;
    function _bQ_(param){active[1] = 0; t[10] = 0; return 0;}
    function _bR_(param){
     var _bT_ = Core_Error[30], _bU_ = one_iter(t);
     caml_call2(Core_Option[46], _bU_, _bT_);
     return collect_events(t[10]);
    }
    return caml_call2(Base_Exn[13], _bR_, _bQ_);
   }
   function check_thread(param){
    var _bJ_ = 1 - current_thread_can_cycle(0);
    if(! _bJ_) return _bJ_;
    var
     _bK_ = caml_call1(Sexplib0_Sexp_conv[7], cst_FD_registration_must_only_);
    return caml_call1(Core[261], _bK_);
   }
   function register_fd(fd, ops){
    check_thread(0);
    var t = the_one_and_only(0);
    if(t[26]){
     var
      _bG_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Cannot_watch_external_fds_);
     return caml_call1(Core[261], _bG_);
    }
    var F = t[4];
    function _bH_(param){
     try{var val = caml_call3(F[5], F[13], fd, ops);}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      caml_call2(Async_unix_By_descr[9], t[9], fd);
      return [1, caml_call2(Core_Error[27], _bm_, exn)];
     }
     return 17724 <= val
             ? _bn_
             : (caml_call2
                (Async_unix_By_descr[9], t[9], fd),
               [1, caml_call1(Core_Error[14], cst_Unsupported_file_descripto)]);
    }
    var _bI_ = caml_call3(Async_unix_By_descr[5], t[9], fd, ops);
    return caml_call2(Core_Result[25][4][2], _bI_, _bH_);
   }
   var not_watching = caml_call2(Read_write_pair[9], 0, 0);
   function unregister_fd(fd){
    check_thread(0);
    var t = the_one_and_only(0), F = t[4];
    if(! caml_call2(Async_unix_By_descr[6], t[9], fd))
     return [1, caml_call1(Core_Error[14], cst_Attempt_to_unregister_an_F)];
    caml_call2(Async_unix_By_descr[9], t[9], fd);
    try{var val = caml_call3(F[5], F[13], fd, not_watching);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return [1, caml_call2(Core_Error[27], _bo_, exn)];
    }
    return 17724 <= val
            ? _bp_
            : [1,
              caml_call1(Core_Error[14], cst_Unsupported_file_descripto$0)];
   }
   function is_registered(fd){
    check_thread(0);
    var t = the_one_and_only(0);
    return caml_call2(Async_unix_By_descr[6], t[9], fd);
   }
   function run_one_cycle$0(max_wait){
    var t = the_one_and_only(0);
    if(1 - am_holding_lock(t)){
     var
      _bA_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Attempt_to_run_one_cycle_w);
     caml_call1(Core[261], _bA_);
    }
    if(typeof max_wait !== "number"){
     var
      wake_at = max_wait[2],
      wake = caml_call1(Async_kernel_Clock_ns[7][15], wake_at),
      _bD_ =
        function(param){
         return caml_call2(Async_kernel_Clock_ns[7][11], wake, 0);
        },
      _bE_ = function(param){return run_one_cycle(t);};
     return caml_call2(Base_Exn[13], _bE_, _bD_);
    }
    if(1059257461 <= max_wait) return run_one_cycle(t);
    var _bB_ = 0;
    function _bC_(_bF_){return 0;}
    caml_call4
     (Async_kernel_Scheduler[8],
      t[21],
      Async_kernel_Execution_context[7],
      _bC_,
      _bB_);
    return run_one_cycle(t);
   }
   function run_cycles_until_determined(d){
    for(;;){
     var match = caml_call1(Async_kernel_Deferred[5], d);
     if(match){var x = match[1]; return x;}
     var ready_fds = run_one_cycle$0(1059257461);
     if(ready_fds){
      var
       t = the_one_and_only(0),
       _bq_ =
         function(fd){
          return [0, fd, caml_call2(Async_unix_By_descr[8], t[9], fd)];
         },
       _br_ =
         function(a_122, b_123){
          return caml_call2(Core_unix_File_descr[4], a_122, b_123);
         },
       _bs_ = function(_bz_){return _bz_[1];},
       _bt_ = caml_call2(Core_List[51], ready_fds, _bs_),
       _bu_ = caml_call2(Core_List[122], _bt_, _br_),
       fd_ops = caml_call2(Core_List[51], _bu_, _bq_),
       temporarily_unregister =
         function(param){
          if(! param) return run_cycles_until_determined(d);
          var
           fd_ops = param[2],
           match = param[1],
           ops = match[2],
           fd = match[1],
           _bv_ = unregister_fd(fd);
          caml_call1(Core_Or_error[40], _bv_);
          function _bw_(param){
           var _by_ = register_fd(fd, ops);
           return caml_call1(Core_Or_error[40], _by_);
          }
          function _bx_(param){return temporarily_unregister(fd_ops);}
          return caml_call2(Base_Exn[13], _bx_, _bw_);
         };
      return temporarily_unregister(fd_ops);
     }
    }
   }
   var
    External =
      [0,
       current_thread_can_cycle,
       collect_events,
       check_thread,
       register_fd,
       not_watching,
       unregister_fd,
       is_registered,
       run_one_cycle$0,
       run_cycles_until_determined];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Raw_scheduler);
   var
    Async_unix_Raw_scheduler =
      [0,
       debug,
       File_descr_watcher,
       Which_watcher,
       External_fd_event,
       Thread_pool_stuck_status,
       within_context,
       within,
       within$0,
       within_v,
       with_local,
       find_local,
       schedule,
       schedule$0,
       enqueue_job,
       thread_safe_enqueue_job,
       preserve_execution_context,
       preserve_execution_context$0,
       cycle_start,
       cycle_start_ns,
       cycle_times,
       cycle_times_ns,
       last_cycle_time,
       long_cycles,
       cycle_count,
       total_cycle_time,
       event_precision,
       event_precision_ns,
       force_current_cycle_to_end,
       set_max_num_jobs_per_priority_,
       max_num_jobs_per_priority_per_,
       set_record_backtraces,
       recording_backtraces,
       yield$0,
       yield_until_no_jobs_remain,
       yield_every,
       num_jobs_run,
       num_pending_jobs,
       Expert,
       sexp_of_start_type,
       uring,
       initialized_at,
       min_inter_cycle_timeout,
       set_min_inter_cycle_timeout,
       max_inter_cycle_timeout,
       set_have_lock_do_cycle,
       kernel_scheduler,
       next_tsc_calibration,
       set_next_tsc_calibration,
       dns_lookup_throttle,
       thread_pool_stuck,
       set_thread_pool_stuck,
       set_handle_thread_pool_stuck,
       thread_pool,
       signal_manager,
       interruptor,
       scheduler_thread_id,
       set_scheduler_thread_id,
       timerfd_set_at,
       set_timerfd_set_at,
       timerfd,
       set_timerfd,
       external_fd_events,
       set_external_fd_events,
       external_fd_by_descr,
       fd_by_descr,
       time_spent_waiting_for_io,
       set_time_spent_waiting_for_io,
       set_num_busy_pollers,
       busy_pollers,
       file_descr_watcher,
       fds_whose_watching_has_changed,
       start_type,
       set_start_type,
       mutex,
       Fields,
       sexp_of_t$1,
       max_num_threads,
       max_num_open_file_descrs,
       current_execution_context,
       with_execution_context,
       thread_pool_cpu_affinity,
       lock,
       try_lock,
       unlock,
       with_lock,
       am_holding_lock,
       mutex_for_initializing_the_one,
       the_one_and_only_ref,
       is_ready_to_initialize,
       is_initialized,
       the_one_and_only_uncommon_case,
       the_one_and_only,
       fds_created_before_initializat,
       create_fd_registration,
       create_fd,
       current_thread_id,
       is_main_thread,
       remove_fd,
       maybe_start_closing_fd,
       dec_num_active_syscalls_fd,
       invariant,
       update_check_access,
       try_create_timerfd,
       default_handle_thread_pool_stu,
       thread_pool_has_unfinished_wor,
       thread_safe_wakeup_scheduler,
       i_am_the_scheduler,
       set_fd_desired_watching,
       give_up_on_watching,
       request_start_watching,
       request_stop_watching,
       post_check_got_timerfd,
       post_check_invalid_fd,
       post_check_handle_fd,
       cycle_took_longer_than_100us,
       maybe_report_long_async_cycles$0,
       create,
       reset_in_forked_process_withou,
       reset_in_forked_process,
       make_async_unusable,
       thread_safe_enqueue_external_j,
       have_lock_do_cycle$1,
       log_sync_changed_fds_to_file_d,
       sync_changed_fd_failed,
       sync_changed_fds_to_file_descr,
       maybe_calibrate_tsc,
       create_job,
       dump_core_on_job_delay,
       num_busy_pollers$1,
       add_busy_poller,
       init$0,
       fds_may_produce_events,
       check_file_descr_watcher,
       run_busy_pollers_once,
       run_busy_pollers,
       compute_timeout_and_check_file,
       one_iter,
       be_the_scheduler,
       add_finalizer,
       add_finalizer_exn,
       async_kernel_config_task_id,
       set_task_id,
       raise_if_any_jobs_were_schedul,
       is_running,
       go,
       go_main,
       is_the_one_and_only_running,
       report_long_cycle_times,
       set_check_invariants,
       set_detect_invalid_access_from,
       set_max_inter_cycle_timeout$0,
       t,
       with_t_once_started,
       fold_fields,
       handle_thread_pool_stuck$1,
       For_metrics,
       External];
   runtime.caml_register_global
    (230, Async_unix_Raw_scheduler, cst_Async_unix_Raw_scheduler$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__In_thread
//# unitInfo: Requires: Async_kernel__Clock_ns, Async_kernel__Ivar, Async_kernel__Pipe, Async_unix__Import, Async_unix__Interruptor, Async_unix__Raw_scheduler, Async_unix__Syscall, Core, Core__Linked_queue, Core__Option, Core__Result, Core__Sexp, Linux_ext, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Squeue, Thread_pool, Time_ns_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_In_thread$0 = "Async_unix__In_thread",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    Thread_pool = global_data.Thread_pool,
    Time_ns_unix = global_data.Time_ns_unix,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Async_unix_Import = global_data.Async_unix__Import,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Core_Linked_queue = global_data.Core__Linked_queue,
    Squeue = global_data.Squeue,
    Async_unix_Syscall = global_data.Async_unix__Syscall,
    Core_Result = global_data.Core__Result,
    Core_Option = global_data.Core__Option,
    Core = global_data.Core,
    Async_unix_Raw_scheduler = global_data.Async_unix__Raw_scheduler,
    Core_Sexp = global_data.Core__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_unix_Interruptor = global_data.Async_unix__Interruptor,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Linux_ext = global_data.Linux_ext;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_In_thread$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/in_thread.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "in_thread.ml");
   var
    cst_Async_s_thread_pool_was_un =
      "Async's thread pool was unable to create a single thread",
    _a_ = [0, "Notify_the_scheduler"],
    _b_ = [0, "Take_the_async_lock"],
    _c_ = [0, "Try_to_take_the_async_lock"],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_In_thread = cst_Async_unix_In_thread$0;
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var default$0 = [0, 2], When_finished = [0, all, sexp_of_t, default$0];
   function stuck_check_interval(param){
    return caml_call1(Time_ns_unix[72][82], 1.);
   }
   function schedule_stuck_check(t){
    var _F_ = caml_call1(Thread_pool[13], t[16]);
    t[18] = [0, caml_call1(Time_ns_unix[40], 0), _F_];
    var _G_ = stuck_check_interval(0);
    return caml_call3(Async_kernel_Clock_ns[2], _G_, check_still_stuck, t);
   }
   function check_still_stuck(t){
    var match = t[18];
    if(! match) return 0;
    if(! caml_call1(Thread_pool[14], t[16])){t[18] = 0; return 0;}
    var
     num_work_completed = match[2],
     stuck_since = match[1],
     _B_ = caml_call1(Thread_pool[13], t[16]);
    if(! caml_call2(Async_unix_Import[3], num_work_completed, _B_))
     return schedule_stuck_check(t);
    var
     _C_ = caml_call1(Time_ns_unix[40], 0),
     _D_ = caml_call2(Time_ns_unix[47], _C_, stuck_since);
    caml_call2(t[17], t[16], _D_);
    var _E_ = stuck_check_interval(0);
    return caml_call3(Async_kernel_Clock_ns[2], _E_, check_still_stuck, t);
   }
   function run(priority, thread, name, f){
    var when_finished = When_finished[3][1];
    function _l_(t){
     var ivar = caml_call1(Async_kernel_Ivar[12], 0);
     function doit(param){
      var result = caml_call1(Core_Result[54], f);
      switch(when_finished){
        case 0:
         var locked = 0; break;
        case 1:
         caml_call1(Async_unix_Raw_scheduler[82], t); var locked = 1; break;
        default:
         if(caml_call1(Async_unix_Raw_scheduler[81], t))
          var _z_ = 0;
         else
          var
           _A_ =
             caml_call1(Async_unix_Raw_scheduler[83], t)
              ? caml_call1
                 (Async_unix_Interruptor[7], t[14])
                ? (caml_call1(Async_unix_Raw_scheduler[84], t), 0)
                : 1
              : 0,
           _z_ = _A_;
         var locked = _z_;
      }
      if(locked){
       var
        _u_ =
          function(param){return caml_call1(Async_unix_Raw_scheduler[84], t);},
        _v_ =
          function(param){
           caml_call2(Async_kernel_Ivar[14], ivar, result);
           return caml_call1(Async_unix_Raw_scheduler[122], t);
          };
       return caml_call2(Core[259], _v_, _u_);
      }
      var _w_ = 0;
      function _x_(param){
       return caml_call2(Async_kernel_Ivar[14], ivar, result);
      }
      var _y_ = caml_call1(Async_unix_Raw_scheduler[79], t);
      return caml_call4(Async_unix_Raw_scheduler[121], t, _y_, _x_, _w_);
     }
     if(thread){
      var
       helper_thread = thread[1],
       _m_ =
         caml_call5
          (Thread_pool[18], priority, name, t[16], helper_thread, doit);
      caml_call1(Core[255], _m_);
     }
     else{
      var _p_ = caml_call4(Thread_pool[12], priority, name, t[16], doit);
      caml_call1(Core[255], _p_);
      var _q_ = caml_call1(Thread_pool[9], t[16]);
      if(caml_call2(Async_unix_Import[3], _q_, 0)){
       var _r_ = caml_call1(Thread_pool[20], t[16]), match = 0;
       if(_r_)
        var v = _r_[1], _s_ = [0, caml_call1(Core_Sexp[93], v), match];
       else
        var _s_ = match;
       var
        res =
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Async_s_thread_pool_was_un),
           _s_];
       if(res[2]) var _t_ = [1, res]; else var h = res[1], _t_ = h;
       caml_call1(Core[261], _t_);
      }
     }
     if(caml_call1(Thread_pool[14], t[16]) && ! t[18])
      schedule_stuck_check(t);
     var _n_ = Core_Result[40], _o_ = caml_call1(Async_kernel_Ivar[19], ivar);
     return caml_call2(Async_unix_Import[32], _o_, _n_);
    }
    return caml_call1(Async_unix_Raw_scheduler[153], _l_);
   }
   function thread_pool_helper_thread(r){return r[1];}
   function create_internal(scheduler, thread_pool_helper_thread){
    function finalize(param){
     var thread_pool_helper_thread = param[1];
     return caml_call2
             (Thread_pool[19], scheduler[16], thread_pool_helper_thread);
    }
    var t = [0, thread_pool_helper_thread];
    caml_call3(Async_unix_Raw_scheduler[140], scheduler, t, finalize);
    return t;
   }
   function create_now(priority, name, param){
    var scheduler = caml_call1(Async_unix_Raw_scheduler[92], 0);
    function _j_(helper_thread){
     return create_internal(scheduler, helper_thread);
    }
    var _k_ = caml_call3(Thread_pool[16], priority, name, scheduler[16]);
    return caml_call2(Core_Result[46], _k_, _j_);
   }
   function create(priority, name, param){
    var scheduler = caml_call1(Async_unix_Raw_scheduler[92], 0);
    function _h_(helper_thread){
     return create_internal(scheduler, caml_call1(Core[255], helper_thread));
    }
    var
     _i_ =
       run
        (0,
         0,
         0,
         function(param){
          return caml_call3(Thread_pool[17], priority, name, scheduler[16]);
         });
    return caml_call2(Async_unix_Import[33][3], _i_, _h_);
   }
   function run$0(priority, thread, name, f){
    var
     thread$0 = caml_call2(Core_Option[34], thread, thread_pool_helper_thread);
    return run(priority, thread$0, name, f);
   }
   function syscall(name, f){
    return run$0
            (0,
             0,
             [0, name],
             function(param){return caml_call1(Async_unix_Syscall[1], f);});
   }
   function syscall_exn(name, f){
    return run$0
            (0,
             0,
             [0, name],
             function(param){
              var _g_ = caml_call1(Async_unix_Syscall[1], f);
              return caml_call1(Core_Result[40], _g_);
             });
   }
   function pipe_of_squeue(sq){
    var
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     w = match[2],
     r = match[1];
    function pull(param){
     var q = caml_call1(Core_Linked_queue[60], 0);
     caml_call2(Squeue[11], sq, q);
     return q;
    }
    function continue$0(q){
     var _e_ = caml_call1(Async_kernel_Pipe[30], w);
     caml_call2(Core_Linked_queue[15], q, _e_);
     var _f_ = caml_call1(Async_kernel_Pipe[28], w);
     return caml_call2(Async_unix_Import[27], _f_, loop);
    }
    function loop(param){
     var _d_ = run$0(0, 0, 0, pull);
     return caml_call2(Async_unix_Import[27], _d_, continue$0);
    }
    loop(0);
    return r;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_In_thread);
   var
    Async_unix_In_thread =
      [0,
       Linux_ext[53],
       [0, create, create_now],
       pipe_of_squeue,
       When_finished,
       run$0,
       syscall,
       syscall_exn];
   runtime.caml_register_global
    (35, Async_unix_In_thread, cst_Async_unix_In_thread$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Io_uring_raw_singleton
//# unitInfo: Requires: Async_kernel__Async_kernel_scheduler, Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel_config, Async_unix__Config, Async_unix__Io_uring_raw, Async_unix__Raw_scheduler, Core, Core__Error, Core__Info, Core__Int32, Core_unix, Linux_ext, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Io_uring_raw_si$0 = "Async_unix__Io_uring_raw_singleton",
    cst_async_unix$0 = "async_unix",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    arg0_005 = "unexpectedly stopped watching eventfd",
    arg0_001 = "unexpected result when asked to watch eventfd",
    Core = global_data.Core,
    Async_unix_Config = global_data.Async_unix__Config,
    Async_unix_Raw_scheduler = global_data.Async_unix__Raw_scheduler,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_unix_Io_uring_raw = global_data.Async_unix__Io_uring_raw,
    Linux_ext = global_data.Linux_ext,
    Core_Int32 = global_data.Core__Int32,
    Core_Error = global_data.Core__Error,
    Core_unix = global_data.Core_unix,
    Async_kernel_Async_kernel_sche =
      global_data.Async_kernel__Async_kernel_scheduler,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Info = global_data.Core__Info,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Io_uring_raw_si$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/io_uring_raw_singleton.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_unix$0, "io_uring_raw_singleton.ml");
   var
    _i_ = [0, 0],
    _h_ = [0, 0],
    _g_ = [0, 0],
    _a_ = [0, "Bad_fd"],
    _b_ = [0, "Unsupported"],
    _c_ = [0, "Interrupted"],
    _d_ = [0, "Closed"],
    _e_ = [0, "Already_watching"],
    _f_ = [0, "Already_closed"],
    cst_io_uring_raw_eventfd = "io_uring_raw eventfd",
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Io_uring_raw_si = cst_Async_unix_Io_uring_raw_si$0;
   function force_uring_exn(param){
    var
     _y_ = caml_call1(Async_kernel_config[2][5], Async_unix_Config[11]),
     uring = caml_call3(Async_unix_Io_uring_raw[9], 0, _y_, 0),
     _z_ = Linux_ext[34][4];
    if(0 === _z_[0]){
     var create_eventfd = _z_[1];
     if(0 !== uring[0]){
      var uring_error = uring[1];
      return caml_call1(Core_Error[30], uring_error);
     }
     var
      uring$0 = uring[1],
      _A_ = caml_call1(Core_Int32[5], 0),
      eventfd =
        caml_call2
         (create_eventfd,
          [0,
           caml_call2
            (Linux_ext[34][1][31], Linux_ext[34][1][40], Linux_ext[34][1][41])],
          _A_),
      _n_ = caml_call1(Linux_ext[34][7], eventfd);
     caml_call2(Async_unix_Io_uring_raw[12], uring$0, _n_);
     var
      _o_ =
        function(param){
         caml_call1(Async_unix_Io_uring_raw[13], uring$0);
         return 0;
        };
     caml_call1(Async_kernel_Async_kernel_sche[34][5], _o_);
     var
      _p_ = caml_call1(Sexplib0_Sexp_conv[7], cst_io_uring_raw_eventfd),
      _q_ = caml_call1(Core_Info[20], _p_),
      _r_ = caml_call1(Linux_ext[34][7], eventfd),
      fd = caml_call4(Async_unix_Raw_scheduler[95], 0, 1, _r_, _q_),
      _s_ = 0,
      _t_ =
        function(param){
         try{
          caml_call1(Linux_ext[34][5], eventfd);
          caml_call1(Async_unix_Io_uring_raw[15], uring$0);
          var _D_ = 0;
          return _D_;
         }
         catch(exn$0){
          var exn = caml_wrap_exception(exn$0);
          a:
          if(exn[1] === Core_unix[4]){
           var _C_ = exn[2];
           if(typeof _C_ === "number"){
            if(2 !== _C_ && 37 !== _C_) break a;
            return 0;
           }
          }
          throw caml_maybe_attach_backtrace(exn, 0);
         }
        },
      _u_ = caml_call1(Async_unix_Raw_scheduler[92], 0),
      eventfd_ready_job =
        caml_call4(Async_unix_Raw_scheduler[127], 0, _u_, _t_, _s_),
      finished_watching = caml_call1(Async_kernel_Ivar[12], 0),
      _v_ = caml_call1(Async_unix_Raw_scheduler[92], 0),
      arg1_002 =
        caml_call4
         (Async_unix_Raw_scheduler[110],
          _v_,
          fd,
          914388854,
          [1, eventfd_ready_job, finished_watching]);
     if(-655995373 !== arg1_002){
      var
       res0_003 = caml_call1(Core[558], arg0_001),
       res1_004 = 233446106 <= arg1_002 ? _e_ : _f_;
      caml_call1(Core[261], [1, [0, res0_003, [0, res1_004, 0]]]);
     }
     var
      _w_ =
        function(arg1_006){
         var
          res0_007 = caml_call1(Core[558], arg0_005),
          res1_008 =
            -18684779 <= arg1_006
             ? -3286312 <= arg1_006 ? _a_ : _b_
             : -952706910 <= arg1_006 ? _c_ : _d_;
         return caml_call1(Core[261], [1, [0, res0_007, [0, res1_008, 0]]]);
        },
      _x_ = caml_call1(Async_kernel_Ivar[19], finished_watching);
     caml_call2(Async_kernel_Deferred[4], _x_, _w_);
     return [1, uring$0];
    }
    var eventfd_error = _z_[1];
    if(0 === uring[0]){
     var uring$1 = uring[1];
     caml_call1(Async_unix_Io_uring_raw[11], uring$1);
     return caml_call1(Core_Error[30], eventfd_error);
    }
    var
     uring_error$0 = uring[1],
     _B_ =
       caml_call1(Core_Error[26], [0, eventfd_error, [0, uring_error$0, 0]]);
    return caml_call1(Core_Error[30], _B_);
   }
   var
    global_io_uring =
      [246,
       function(_l_){
        switch(Async_unix_Config[12]){
          case 0:
           return _i_;
          case 1:
           return force_uring_exn(0);
          case 2:
           try{var _j_ = force_uring_exn(0); return _j_;}
           catch(_m_){return _g_;}
          default:
           var
            _k_ = caml_call1(Async_unix_Raw_scheduler[152], 0),
            match = caml_call1(Async_unix_Raw_scheduler[40], _k_);
           if(! match) return _h_;
           var uring = match[1];
           return [1, uring];
        }
       }];
   function the_one_and_only(param){
    var match = caml_call1(Core[248], global_io_uring);
    if(0 === match[0]) return 0;
    var io_uring = match[1];
    return [0, io_uring];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Io_uring_raw_si);
   var Async_unix_Io_uring_raw_single = [0, the_one_and_only];
   runtime.caml_register_global
    (37, Async_unix_Io_uring_raw_single, cst_Async_unix_Io_uring_raw_si$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Fd
//# unitInfo: Requires: Async_kernel__Debug, Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler, Async_unix__By_descr, Async_unix__Import, Async_unix__In_thread, Async_unix__Io_uring_raw, Async_unix__Io_uring_raw_singleton, Async_unix__Raw_fd, Async_unix__Raw_scheduler, Base__Exn, Core, Core__Info, Core__Memo, Core__Sexp, Core_unix, Core_unix__File_descr, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Read_write_pair, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Fd$0 = "Async_unix__Fd",
    cst_async_unix$0 = "async_unix",
    cst_close$1 = "close",
    cst_fd = "fd",
    cst_fstat$1 = "fstat",
    cst_scheduler = "scheduler",
    cst_src_fd_ml = "src/fd.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Info = global_data.Core__Info,
    Async_unix_Raw_scheduler = global_data.Async_unix__Raw_scheduler,
    Async_unix_Raw_fd = global_data.Async_unix__Raw_fd,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_unix_By_descr = global_data.Async_unix__By_descr,
    Async_unix_Import = global_data.Async_unix__Import,
    Base_Exn = global_data.Base__Exn,
    Core_unix_File_descr = global_data.Core_unix__File_descr,
    Core_unix = global_data.Core_unix,
    Async_unix_In_thread = global_data.Async_unix__In_thread,
    Assert_failure = global_data.Assert_failure,
    Read_write_pair = global_data.Read_write_pair,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Async_unix_Io_uring_raw_single =
      global_data.Async_unix__Io_uring_raw_singleton,
    Async_unix_Io_uring_raw = global_data.Async_unix__Io_uring_raw,
    Core_Sexp = global_data.Core__Sexp,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Memo = global_data.Core__Memo;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Fd$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_fd_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "fd.ml");
   var
    include = Async_unix_Raw_fd[7],
    kind = include[13],
    info = include[15],
    sexp_of_t = include[19],
    sexp_of_t_hum = include[20],
    debug = Async_unix_Raw_fd[1],
    is_closed = Async_unix_Raw_fd[34],
    is_open = Async_unix_Raw_fd[33],
    syscall = Async_unix_Raw_fd[40],
    syscall_exn = Async_unix_Raw_fd[41],
    syscall_result_exn = Async_unix_Raw_fd[42],
    with_file_descr = Async_unix_Raw_fd[39],
    with_file_descr_exn = Async_unix_Raw_fd[38],
    include$0 = Async_unix_Raw_fd[2],
    sexp_of_t$0 = include$0[1],
    _y_ = [0, "previously_was"],
    _v_ = [0, cst_scheduler],
    _w_ = [0, "kind"],
    _x_ = [0, cst_fd],
    cst_Fd_replace_got_closed_fd = "Fd.replace got closed fd",
    cst_replaced = "replaced",
    cst_File_descriptor_can_t_be_r =
      "File descriptor can't be redirected while in use",
    cst_Fd_file_descr_exn_on_alrea = "Fd.file_descr_exn on already closed fd",
    cst_of_out_channel = "<of_out_channel>",
    cst_of_in_channel = "<of_in_channel>",
    cst_Fd_syscall_in_thread_exn_o = "Fd.syscall_in_thread_exn of a closed fd",
    cst_Fd_syscall_in_thread_probl =
      "Fd.syscall_in_thread problem -- please report this",
    _u_ = [0, cst_src_fd_ml, 342, 40],
    cst_Fd_every_ready_to = "Fd.every_ready_to",
    cst_Fd_interruptible_every_rea = "Fd.interruptible_every_ready_to",
    _t_ = [0, cst_src_fd_ml, 310, 40],
    cst_Fd_ready_to = "Fd.ready_to",
    cst_Fd_interruptible_ready_to = "Fd.interruptible_ready_to",
    _r_ = [0, cst_scheduler],
    _s_ = [0, cst_fd],
    cst_cannot_watch_an_fd_already =
      "cannot watch an fd already being watched",
    cst_Fd_start_watching = "Fd.start_watching",
    cst_Fd_with_file_descr_deferre =
      "Fd.with_file_descr_deferred_exn got closed fd",
    _p_ = [0, 3804260],
    _q_ = [0, 523273847],
    _o_ = [0, 523273847],
    _l_ = [0, 0],
    _m_ = [0, 523273847],
    _n_ = [0, "Fd.create_borrowed"],
    _k_ = [0, 0],
    cst_shutdown = "shutdown",
    _i_ = [0, 523273847],
    _j_ = [0, 0],
    cst_Fd_close = "Fd.close",
    _g_ = [0, cst_src_fd_ml, 149, 8],
    _h_ = [0, cst_fd],
    cst_close = cst_close$1,
    cst_close$0 = cst_close$1,
    cst_stderr = "<stderr>",
    cst_stdout = "<stdout>",
    cst_stdin = "<stdin>",
    _c_ = [0, 1],
    cst_fstat$0 = cst_fstat$1,
    _a_ = [0, cst_src_fd_ml, 67, 6],
    _b_ = [0, "file_descr"],
    cst_fstat = cst_fstat$1,
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Fd = cst_Async_unix_Fd$0;
   function get_socket_state(file_descr){
    try{var val = caml_call2(Core_unix[244], file_descr, 6);}
    catch(_bh_){
     var _bf_ = caml_wrap_exception(_bh_);
     if(_bf_[1] === Core_unix[4]){
      var _bg_ = _bf_[2];
      if(typeof _bg_ === "number" && 44 === _bg_) return 785140586;
     }
     throw caml_maybe_attach_backtrace(_bf_, 0);
    }
    return val ? -893685881 : -891636250;
   }
   function blocking_infer_using_stat(file_descr){
    var st = caml_call1(Core_unix[75], file_descr), kind = st[3];
    switch(kind){
      case 2:
       return 0;
      case 5:
       return 1;
      case 6:
       return [0, get_socket_state(file_descr)];
      default: return 2;
    }
   }
   function infer_using_stat(file_descr){
    var match = caml_call1(Async_unix_Io_uring_raw_single[1], 0);
    if(match){
     var
      uring = match[1],
      statx_buffer = caml_call1(Async_unix_Io_uring_raw[4][1], 0),
      _a$_ =
        function(param){
         if(0 !== param[0]){
          var
           err = param[1],
           _bd_ =
             [1,
              [0,
               [1,
                [0,
                 _b_,
                 [0, caml_call1(Core_unix_File_descr[2], file_descr), 0]]],
               0]],
           _be_ = caml_call1(Core_unix[10][1], _bd_);
          throw caml_maybe_attach_backtrace
                 ([0, Core_unix[4], err, cst_fstat, _be_], 0);
         }
         var res = param[1];
         if(! caml_call2(Async_unix_Import[3], res, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         var kind = caml_call1(Async_unix_Io_uring_raw[4][30], statx_buffer);
         if(215595176 <= kind){
          if(781514092 === kind) return 1;
          if(785140586 === kind) return 2;
         }
         else if(-495690425 !== kind)
          return -74006461 <= kind ? 0 : [0, get_socket_state(file_descr)];
         return 2;
        },
      _ba_ =
        caml_call6
         (Async_unix_Io_uring_raw[27],
          uring,
          [0, file_descr],
          Async_unix_Io_uring_raw[4][4][4],
          cst,
          statx_buffer,
          Async_unix_Io_uring_raw[4][2][5]),
      _bb_ = caml_call1(Async_unix_Io_uring_raw[29], _ba_);
     return caml_call2(Async_unix_Import[33][3], _bb_, _a$_);
    }
    function _bc_(param){return blocking_infer_using_stat(file_descr);}
    return caml_call2(Async_unix_In_thread[7], cst_fstat$0, _bc_);
   }
   function to_string(t){
    var _a__ = caml_call1(Async_unix_Raw_fd[25], t);
    return caml_call2(Core_Sexp[84], 0, _a__);
   }
   function the_one_and_only(param){
    return caml_call1(Async_unix_Raw_scheduler[92], 0);
   }
   function create(avoid_setting_nonblock, kind, file_descr, info){
    return caml_call4
            (Async_unix_Raw_scheduler[95],
             avoid_setting_nonblock,
             kind,
             file_descr,
             info);
   }
   function create_std_descr(file_descr, info){
    return create
            (_c_, blocking_infer_using_stat(file_descr), file_descr, info);
   }
   function _d_(param){
    var _a9_ = caml_call1(Core_Info[14], cst_stdin);
    return create_std_descr(Core_unix[42], _a9_);
   }
   var stdin = caml_call1(Core_Memo[3], _d_);
   function _e_(param){
    var _a8_ = caml_call1(Core_Info[14], cst_stdout);
    return create_std_descr(Core_unix[43], _a8_);
   }
   var stdout = caml_call1(Core_Memo[3], _e_);
   function _f_(param){
    var _a7_ = caml_call1(Core_Info[14], cst_stderr);
    return create_std_descr(Core_unix[44], _a7_);
   }
   var stderr = caml_call1(Core_Memo[3], _f_);
   function supports_nonblock(t){return caml_call1(Async_unix_Raw_fd[36], t);}
   function clear_nonblock(t){
    t[4] = 0;
    return t[5] ? (t[5] = 0, caml_call1(Core_unix[99], t[1])) : 0;
   }
   function close(opt, t){
    if(opt)
     var sth = opt[1], file_descriptor_handling = sth;
    else
     var file_descriptor_handling = _j_;
    if(debug)
     caml_call3
      (Async_kernel_Debug[15], cst_Fd_close, t, Async_unix_Raw_fd[25]);
    var match = t[6];
    a:
    if(typeof match !== "number" && 1 === match[0]){
     var close_started = match[1];
     caml_call2(Async_kernel_Ivar[14], close_started, 0);
     var
      do_close_syscall =
        function(param){
         function _aT_(param){
          return caml_call2(Async_kernel_Ivar[14], t[10], 0);
         }
         if(file_descriptor_handling)
          var
           socket_handling = file_descriptor_handling[1],
           _aU_ =
             function(param){
              var
               file_descr = t[1],
               match = caml_call1(Async_unix_Io_uring_raw_single[1], 0);
              if(match){
               var
                uring = match[1],
                _a1_ =
                  function(param){
                   if(0 !== param[0]){
                    var
                     err = param[1],
                     _a5_ =
                       [1,
                        [0,
                         [1,
                          [0,
                           _h_,
                           [0, caml_call1(Core_unix_File_descr[2], file_descr), 0]]],
                         0]],
                     _a6_ = caml_call1(Core_unix[10][1], _a5_);
                    throw caml_maybe_attach_backtrace
                           ([0, Core_unix[4], err, cst_close, _a6_], 0);
                   }
                   var result = param[1];
                   if(caml_call2(Async_unix_Import[3], result, 0)) return 0;
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _g_], 1);
                  },
                _a2_ =
                  caml_call2(Async_unix_Io_uring_raw[23], uring, file_descr),
                _a3_ = caml_call1(Async_unix_Io_uring_raw[29], _a2_);
               return caml_call2(Async_unix_Import[32], _a3_, _a1_);
              }
              function _a4_(param){
               return caml_call2(Core_unix[53], 0, file_descr);
              }
              return caml_call2(Async_unix_In_thread[7], cst_close$0, _a4_);
             },
           _aV_ =
             function(param){
              var _aY_ = t[3];
              if(typeof _aY_ !== "number"){
               var _aZ_ = _aY_[1];
               if
                (typeof _aZ_ === "number"
                 && -891636250 === _aZ_ && ! socket_handling){
                var
                 _a0_ =
                   function(param){return caml_call2(Core_unix[227], t[1], 2);};
                return caml_call2(Async_unix_In_thread[7], cst_shutdown, _a0_);
               }
              }
              return caml_call1(Async_unix_Import[30], 0);
             },
           _aW_ =
             caml_call8
              (Async_kernel_Monitor[23], 0, 0, 0, 0, _i_, 0, _aV_, _aU_);
         else
          var _aW_ = caml_call1(Async_unix_Import[30], 0);
         var _aX_ = caml_call2(Async_unix_Import[33][3], _aW_, _aT_);
         return caml_call1(Async_unix_Import[16], _aX_);
        },
      scheduler = the_one_and_only(0),
      kernel_scheduler = scheduler[21],
      _aS_ =
        [0,
         caml_call1(Async_kernel_Scheduler[4], kernel_scheduler),
         do_close_syscall];
     caml_call2(Async_unix_Raw_fd[32], t, _aS_);
     caml_call4
      (Async_unix_Raw_scheduler[111], scheduler, t, 914388854, -1025106484);
     caml_call4
      (Async_unix_Raw_scheduler[111], scheduler, t, -477700929, -1025106484);
     caml_call2(Async_unix_Raw_scheduler[99], scheduler, t);
     break a;
    }
    return caml_call1(Async_kernel_Ivar[19], t[10]);
   }
   function deregister(t){return close(_k_, t);}
   function close_finished(t){
    return caml_call1(Async_kernel_Ivar[19], t[10]);
   }
   function close_started(t){
    var match = t[6];
    if(typeof match !== "number" && 1 === match[0]){
     var close_started = match[1];
     return caml_call1(Async_kernel_Ivar[19], close_started);
    }
    return caml_call1(Async_unix_Import[30], 0);
   }
   function create_borrowed(avoid_setting_nonblock, kind, file_descr, info, f){
    var fd = create(avoid_setting_nonblock, kind, file_descr, info);
    function _aQ_(param){return close(_l_, fd);}
    function _aR_(param){return caml_call1(f, fd);}
    return caml_call8
            (Async_kernel_Monitor[23], 0, 0, _n_, 0, _m_, 0, _aR_, _aQ_);
   }
   function with_close(t, f){
    function _aO_(param){return close(0, t);}
    function _aP_(param){return caml_call1(f, t);}
    return caml_call8
            (Async_kernel_Monitor[23], 0, 0, 0, 0, _o_, 0, _aP_, _aO_);
   }
   function with_file_descr_deferred(t, opt, f){
    if(opt) var sth = opt[1], extract_exn = sth; else var extract_exn = 0;
    if(17724 > caml_call1(Async_unix_Raw_fd[31], t))
     return caml_call1(Async_unix_Import[30], -1034200365);
    function _aK_(result){
     var _aN_ = the_one_and_only(0);
     caml_call2(Async_unix_Raw_scheduler[100], _aN_, t);
     if(0 === result[0]){var x = result[1]; return [0, 17724, x];}
     var e = result[1];
     return [0, 106380200, e];
    }
    function _aL_(param){return caml_call1(f, t[1]);}
    var
     _aM_ =
       caml_call7
        (Async_kernel_Monitor[16], 0, 0, 0, [0, extract_exn], _q_, _p_, _aL_);
    return caml_call2(Async_unix_Import[33][3], _aM_, _aK_);
   }
   function with_file_descr_deferred_resul(t, f){
    function _aI_(param){
     if(typeof param === "number") return -1034200365;
     if(106380200 <= param[1]){
      var exn = param[2];
      return [0, 106380200, exn];
     }
     var match = param[2];
     if(0 === match[0]){var x = match[1]; return [0, 17724, x];}
     var exn$0 = match[1];
     return [0, 106380200, exn$0];
    }
    var _aJ_ = with_file_descr_deferred(t, 0, f);
    return caml_call2(Async_unix_Import[33][3], _aJ_, _aI_);
   }
   function with_file_descr_deferred_exn(t, f){
    function _aE_(param){
     if(typeof param === "number"){
      var
       _aG_ = [0, caml_call1(Async_unix_Raw_fd[26], t), 0],
       _aH_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_with_file_descr_deferre),
           _aG_]];
      return caml_call1(Core[261], _aH_);
     }
     if(106380200 <= param[1]){
      var exn = param[2];
      throw caml_maybe_attach_backtrace(exn, 0);
     }
     var x = param[2];
     return x;
    }
    var _aF_ = with_file_descr_deferred(t, 0, f);
    return caml_call2(Async_unix_Import[33][3], _aF_, _aE_);
   }
   function start_watching(t, read_or_write, watching){
    if(debug){
     var
      _aA_ =
        function(param){
         var
          arg1_004 = param[2],
          arg0_003 = param[1],
          res0_005 = caml_call1(Async_unix_Raw_fd[25], arg0_003),
          res1_006 = caml_call1(Read_write_pair[1][1], arg1_004);
         return [1, [0, res0_005, [0, res1_006, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_Fd_start_watching,
       [0, t, read_or_write],
       _aA_);
    }
    var
     r = the_one_and_only(0),
     x =
       caml_call4
        (Async_unix_Raw_scheduler[110], r, t, read_or_write, watching);
    if(233446106 > x) return x;
    var
     _aB_ =
       [0,
        [1, [0, _r_, [0, caml_call1(Async_unix_Raw_scheduler[76], r), 0]]],
        0],
     _aC_ =
       [0, [1, [0, _s_, [0, caml_call1(Async_unix_Raw_fd[25], t), 0]]], _aB_],
     _aD_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_watch_an_fd_already),
         _aC_]];
    return caml_call1(Core[261], _aD_);
   }
   function stop_watching_upon_interrupt(t, read_or_write, ivar, interrupt){
    function _aq_(param){
     if(840474678 <= param) return 0;
     var _ay_ = caml_call1(Async_kernel_Ivar[17], ivar);
     if(! _ay_) return _ay_;
     var _az_ = the_one_and_only(0);
     return caml_call4
             (Async_unix_Raw_scheduler[111],
              _az_,
              t,
              read_or_write,
              -952706910);
    }
    var _ar_ = 0;
    function _as_(param){return 840474678;}
    var
     _at_ = caml_call1(Async_kernel_Ivar[19], ivar),
     _au_ = [0, caml_call2(Async_unix_Import[14], _at_, _as_), _ar_];
    function _av_(param){return -952706910;}
    var
     _aw_ = [0, caml_call2(Async_unix_Import[14], interrupt, _av_), _au_],
     _ax_ = caml_call1(Async_unix_Import[15], _aw_);
    return caml_call2(Async_unix_Import[22], _ax_, _aq_);
   }
   function interruptible_ready_to(t, read_or_write, interrupt){
    if(debug){
     var
      _am_ =
        function(param){
         var
          arg1_008 = param[2],
          arg0_007 = param[1],
          res0_009 = caml_call1(Async_unix_Raw_fd[25], arg0_007),
          res1_010 = caml_call1(Read_write_pair[1][1], arg1_008);
         return [1, [0, res0_009, [0, res1_010, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_Fd_interruptible_ready_to,
       [0, t, read_or_write],
       _am_);
    }
    var
     ready = caml_call1(Async_kernel_Ivar[12], 0),
     match = start_watching(t, read_or_write, [0, ready]);
    if(-655995373 === match){
     stop_watching_upon_interrupt(t, read_or_write, ready, interrupt);
     var
      _an_ =
        function(res){
         return -18684779 === res
                 ? caml_call1
                    (Async_kernel_Deferred[7], interrupt)
                   ? -952706910
                   : -102231997
                 : res;
        },
      _ao_ = caml_call1(Async_kernel_Ivar[19], ready);
     return caml_call2(Async_kernel_Deferred[13], _ao_, _an_);
    }
    if(-18684779 > match)
     return caml_call1(Async_unix_Import[30], -1025106484);
    var
     _ap_ =
       caml_call1(Async_kernel_Deferred[7], interrupt)
        ? -952706910
        : -102231997;
    return caml_call1(Async_unix_Import[30], _ap_);
   }
   function ready_to(t, read_or_write){
    if(debug){
     var
      _aj_ =
        function(param){
         var
          arg1_012 = param[2],
          arg0_011 = param[1],
          res0_013 = caml_call1(Async_unix_Raw_fd[25], arg0_011),
          res1_014 = caml_call1(Read_write_pair[1][1], arg1_012);
         return [1, [0, res0_013, [0, res1_014, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15], cst_Fd_ready_to, [0, t, read_or_write], _aj_);
    }
    var
     ready = caml_call1(Async_kernel_Ivar[12], 0),
     match = start_watching(t, read_or_write, [0, ready]);
    if(-655995373 !== match)
     return -18684779 <= match
             ? caml_call1(Async_unix_Import[30], -102231997)
             : caml_call1(Async_unix_Import[30], -1025106484);
    function _ak_(x){
     if(-952706910 === x)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
     return -18684779 === x ? -102231997 : x;
    }
    var _al_ = caml_call1(Async_kernel_Ivar[19], ready);
    return caml_call2(Async_unix_Import[33][3], _al_, _ak_);
   }
   function interruptible_every_ready_to(t, read_or_write, interrupt, f, x){
    if(debug){
     var
      _ah_ =
        function(param){
         var
          arg1_016 = param[2],
          arg0_015 = param[1],
          res0_017 = caml_call1(Async_unix_Raw_fd[25], arg0_015),
          res1_018 = caml_call1(Read_write_pair[1][1], arg1_016);
         return [1, [0, res0_017, [0, res1_018, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_Fd_interruptible_every_rea,
       [0, t, read_or_write],
       _ah_);
    }
    var
     _ai_ = caml_call1(Async_unix_Raw_scheduler[152], 0),
     job =
       caml_call2(caml_call2(Async_unix_Raw_scheduler[127], 0, _ai_), f, x),
     finished = caml_call1(Async_kernel_Ivar[12], 0),
     match = start_watching(t, read_or_write, [1, job, finished]);
    return -655995373 === match
            ? (stop_watching_upon_interrupt
               (t, read_or_write, finished, interrupt),
              caml_call1(Async_kernel_Ivar[19], finished))
            : -18684779
              <= match
              ? caml_call1(Async_unix_Import[30], -18684779)
              : caml_call1(Async_unix_Import[30], -1025106484);
   }
   function every_ready_to(t, read_or_write, f, x){
    if(debug){
     var
      _ad_ =
        function(param){
         var
          arg1_020 = param[2],
          arg0_019 = param[1],
          res0_021 = caml_call1(Async_unix_Raw_fd[25], arg0_019),
          res1_022 = caml_call1(Read_write_pair[1][1], arg1_020);
         return [1, [0, res0_021, [0, res1_022, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_Fd_every_ready_to,
       [0, t, read_or_write],
       _ad_);
    }
    var
     _ae_ = caml_call1(Async_unix_Raw_scheduler[152], 0),
     job =
       caml_call2(caml_call2(Async_unix_Raw_scheduler[127], 0, _ae_), f, x),
     finished = caml_call1(Async_kernel_Ivar[12], 0),
     match = start_watching(t, read_or_write, [1, job, finished]);
    if(-655995373 !== match)
     return -18684779 <= match
             ? caml_call1(Async_unix_Import[30], -18684779)
             : caml_call1(Async_unix_Import[30], -1025106484);
    function _af_(x){
     if(-952706910 === x)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
     return x;
    }
    var _ag_ = caml_call1(Async_kernel_Ivar[19], finished);
    return caml_call2(Async_unix_Import[33][3], _ag_, _af_);
   }
   function syscall_in_thread(t, name, f){
    function _Z_(param){
     if(typeof param === "number") return -1034200365;
     if(106380200 <= param[1]){
      var
       e = param[2],
       _aa_ = [0, caml_call1(Core[625], e), 0],
       _ab_ = [0, caml_call1(Sexplib0_Sexp_conv[7], name), _aa_],
       _ac_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_syscall_in_thread_probl),
           _ab_]];
      return caml_call1(Core[261], _ac_);
     }
     var x = param[2];
     if(0 === x[0]){var x$0 = x[1]; return [0, 17724, x$0];}
     var exn = x[1];
     return [0, 106380200, exn];
    }
    var
     ___ =
       with_file_descr_deferred
        (t,
         0,
         function(file_descr){
          function _$_(param){return caml_call1(f, file_descr);}
          return caml_call2(Async_unix_In_thread[6], name, _$_);
         });
    return caml_call2(Async_unix_Import[33][3], ___, _Z_);
   }
   function syscall_in_thread_exn(t, name, f){
    function _U_(param){
     if(typeof param === "number"){
      var
       _W_ = [0, caml_call1(Async_unix_Raw_fd[26], t), 0],
       _X_ = [0, caml_call1(Sexplib0_Sexp_conv[7], name), _W_],
       _Y_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_syscall_in_thread_exn_o),
           _X_]];
      return caml_call1(Core[261], _Y_);
     }
     if(106380200 <= param[1]){
      var exn = param[2];
      throw caml_maybe_attach_backtrace(exn, 0);
     }
     var x = param[2];
     return x;
    }
    var _V_ = syscall_in_thread(t, name, f);
    return caml_call2(Async_unix_Import[33][3], _V_, _U_);
   }
   function of_in_channel(ic, kind){
    var _T_ = caml_call1(Core_Info[14], cst_of_in_channel);
    return create(0, kind, caml_call1(Core_unix[62], ic), _T_);
   }
   function of_out_channel(oc, kind){
    var _S_ = caml_call1(Core_Info[14], cst_of_out_channel);
    return create(0, kind, caml_call1(Core_unix[63], oc), _S_);
   }
   function of_in_channel_auto(ic){
    function _P_(_R_){return of_in_channel(ic, _R_);}
    var _Q_ = infer_using_stat(caml_call1(Core_unix[62], ic));
    return caml_call2(Async_unix_Import[32], _Q_, _P_);
   }
   function of_out_channel_auto(oc){
    function _M_(_O_){return of_out_channel(oc, _O_);}
    var _N_ = infer_using_stat(caml_call1(Core_unix[63], oc));
    return caml_call2(Async_unix_Import[32], _N_, _M_);
   }
   function file_descr_exn(t){
    if(! caml_call1(is_closed, t)) return t[1];
    var
     _K_ = [0, caml_call1(Async_unix_Raw_fd[25], t), 0],
     _L_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_file_descr_exn_on_alrea),
         _K_]];
    return caml_call1(Core[261], _L_);
   }
   function to_int_exn(t){
    var _J_ = file_descr_exn(t);
    return caml_call1(Core_unix_File_descr[15], _J_);
   }
   function expect_file_descr_redirection(file_descr, f){
    var
     _I_ = the_one_and_only(0),
     fd_by_descr = caml_call1(Async_unix_Raw_scheduler[65], _I_),
     match = caml_call2(Async_unix_By_descr[7], fd_by_descr, file_descr);
    if(! match) return caml_call1(f, 0);
    var fd = match[1];
    if(caml_call2(Async_unix_Import[4], fd[9], 0)){
     var
      _F_ = [0, caml_call1(Async_unix_Raw_fd[25], fd), 0],
      _G_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_File_descriptor_can_t_be_r),
          _F_]];
     caml_call1(Core[261], _G_);
    }
    function _H_(param){fd[3] = blocking_infer_using_stat(fd[1]); return 0;}
    return caml_call2(Base_Exn[13], f, _H_);
   }
   function replace(t, kind, info){
    if(caml_call1(is_closed, t)){
     var
      _z_ = the_one_and_only(0),
      _A_ =
        [0,
         [1, [0, _v_, [0, caml_call1(Async_unix_Raw_scheduler[76], _z_), 0]]],
         0],
      _B_ = [0, [1, [0, _w_, [0, caml_call1(sexp_of_t$0, kind), 0]]], _A_],
      _C_ =
        [0, [1, [0, _x_, [0, caml_call1(Async_unix_Raw_fd[25], t), 0]]], _B_],
      _D_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_replace_got_closed_fd),
          _C_]];
     return caml_call1(Core[261], _D_);
    }
    t[3] = kind;
    if(4150146 <= info[1])
     var i = info[2], i$0 = i;
    else
     var
      i$1 = info[2],
      _E_ =
        function(param){
         var
          arg1_025 = param[2],
          arg0_024 = param[1],
          res0_026 = caml_call1(Core_Info[9], arg0_024),
          v_023 = arg1_025[2],
          res1_027 = [1, [0, _y_, [0, caml_call1(Core_Info[9], v_023), 0]]];
         return [1, [0, res0_026, [0, res1_027, 0]]];
        },
      i$0 =
        caml_call5
         (Core_Info[19],
          0,
          0,
          cst_replaced,
          [0, i$1, [0, -751874386, t[2]]],
          _E_);
    t[2] = i$0;
    return 0;
   }
   var Private = [0, replace];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Fd);
   var
    Async_unix_Fd =
      [0,
       [0, sexp_of_t$0, infer_using_stat],
       sexp_of_t,
       sexp_of_t_hum,
       info,
       to_string,
       create,
       create_borrowed,
       kind,
       supports_nonblock,
       clear_nonblock,
       [0, close, deregister],
       close,
       deregister,
       close_started,
       close_finished,
       is_closed,
       with_close,
       is_open,
       stdin,
       stdout,
       stderr,
       with_file_descr,
       with_file_descr_exn,
       with_file_descr_deferred,
       with_file_descr_deferred_resul,
       with_file_descr_deferred_exn,
       interruptible_ready_to,
       ready_to,
       interruptible_every_ready_to,
       every_ready_to,
       syscall,
       syscall_exn,
       syscall_result_exn,
       syscall_in_thread,
       syscall_in_thread_exn,
       of_in_channel,
       of_out_channel,
       of_in_channel_auto,
       of_out_channel_auto,
       file_descr_exn,
       to_int_exn,
       expect_file_descr_redirection,
       Private];
   runtime.caml_register_global(80, Async_unix_Fd, cst_Async_unix_Fd$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Writer_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Writer_intf = "Async_unix__Writer_intf",
    cst_async_unix = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Writer_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][1], "src/writer_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix, "writer_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Writer_intf);
   var Async_unix_Writer_intf = [0];
   runtime.caml_register_global
    (11, Async_unix_Writer_intf, cst_Async_unix_Writer_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Backing_out_channel
//# unitInfo: Requires: Async_kernel__Async_invariant, Async_unix__Import, Core__Bigstring, Core__Bytes, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Stdio__Out_channel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Backing_out_cha$0 = "Async_unix__Backing_out_channel",
    cst_async_unix$0 = "async_unix",
    cst_src_backing_out_channel_ml = "src/backing_out_channel.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_unix_Import = global_data.Async_unix__Import,
    Core_Bytes = global_data.Core__Bytes,
    Core_Bigstring = global_data.Core__Bigstring,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    Async_kernel_Async_invariant = global_data.Async_kernel__Async_invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Backing_out_cha$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_backing_out_channel_ml);
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_unix$0, "backing_out_channel.ml");
   var
    _b_ = [0, "out_channel"],
    _a_ = [0, cst_src_backing_out_channel_ml, 14, 237, 259],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Backing_out_cha = cst_Async_unix_Backing_out_cha$0;
   function sexp_of_t(t){return caml_call1(t[3], 0);}
   function invariant(t){
    function _e_(param){return 0;}
    return caml_call4(Async_kernel_Async_invariant[1], _a_, t, sexp_of_t, _e_);
   }
   function create(output, flush, sexp){return [0, output, flush, sexp];}
   function of_out_channel(out_channel){
    var bytes_buf = [0, caml_call1(Core_Bytes[40], cst)];
    function _c_(param){
     return [1,
             [0,
              [1,
               [0, _b_, [0, caml_call1(Stdio_Out_channel[1], out_channel), 0]]],
              0]];
    }
    function _d_(param){
     return caml_call1(Stdio_Out_channel[10], out_channel);
    }
    return [0,
            function(buf, pos, len){
             if
              (caml_call2
                (Async_unix_Import[4],
                 len,
                 runtime.caml_ml_bytes_length(bytes_buf[1])))
              bytes_buf[1] = caml_call1(Core_Bytes[44], len * 2 | 0);
             caml_call5(Core_Bigstring[30][1], buf, pos, bytes_buf[1], 0, len);
             return caml_call4
                     (Stdio_Out_channel[11], out_channel, bytes_buf[1], 0, len);
            },
            _d_,
            _c_];
   }
   function output_iovec(t, iovec){
    return caml_call3(t[1], iovec[1], iovec[2], iovec[3]);
   }
   function flush(t){return caml_call1(t[2], 0);}
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Backing_out_cha);
   var
    Async_unix_Backing_out_channel =
      [0, sexp_of_t, invariant, of_out_channel, create, output_iovec, flush];
   runtime.caml_register_global
    (22, Async_unix_Backing_out_channel, cst_Async_unix_Backing_out_cha$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Io_uring
//# unitInfo: Requires: Async_unix__Fd, Async_unix__Import, Async_unix__Io_uring_raw, Async_unix__Io_uring_raw_singleton, Async_unix__Raw_scheduler, Core, Core__Array, Core__Info, Core__List, Core__Option, Core_unix, Core_unix__File_descr, Cstruct, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_Async_unix_Io_uring$0 = "Async_unix__Io_uring",
    cst_async_unix$0 = "async_unix",
    cst_fd = "fd",
    cst_filename = "filename",
    cst_fstat$1 = "fstat",
    cst_open$1 = "open",
    cst_read$1 = "read",
    cst_readv$1 = "readv",
    cst_src_io_uring_ml = "src/io_uring.ml",
    cst_statx$1 = "statx",
    cst_unlink$1 = "unlink",
    cst_write$1 = "write",
    cst_writev$1 = "writev",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = cst$4,
    cst$0 = cst$4,
    cst = cst$4,
    Async_unix_Import = global_data.Async_unix__Import,
    Async_unix_Raw_scheduler = global_data.Async_unix__Raw_scheduler,
    Core = global_data.Core,
    Async_unix_Io_uring_raw = global_data.Async_unix__Io_uring_raw,
    Core_unix = global_data.Core_unix,
    Core_unix_File_descr = global_data.Core_unix__File_descr,
    Async_unix_Fd = global_data.Async_unix__Fd,
    Assert_failure = global_data.Assert_failure,
    Core_Info = global_data.Core__Info,
    Core_Option = global_data.Core__Option,
    Cstruct = global_data.Cstruct,
    Core_Array = global_data.Core__Array,
    Core_List = global_data.Core__List,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_unix_Io_uring_raw_single =
      global_data.Async_unix__Io_uring_raw_singleton;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Io_uring$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_io_uring_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "io_uring.ml");
   var
    create = Async_unix_Io_uring_raw[9],
    exit = Async_unix_Io_uring_raw[11],
    submit = Async_unix_Io_uring_raw[13],
    fill_completions = Async_unix_Io_uring_raw[15],
    the_one_and_only = Async_unix_Io_uring_raw_single[1],
    cst_syscall_interrupted_too_ma = "syscall interrupted too many times",
    _o_ = [0, cst_filename],
    cst_lstat = "lstat",
    _n_ = [0, cst_fd],
    cst_fstat = cst_fstat$1,
    cst_fstat$0 = cst_fstat$1,
    _m_ = [0, cst_filename],
    cst_stat = "stat",
    _k_ = [0, "path"],
    _l_ = [0, cst_fd],
    cst_statx = cst_statx$1,
    cst_statx$0 = cst_statx$1,
    _j_ = [0, cst_src_io_uring_ml, 183, 4],
    _g_ = [0, 0],
    _h_ = [0, 0],
    _f_ = [0, 0],
    cst_link = "link",
    _d_ = [0, "link_name"],
    _e_ = [0, "target"],
    _i_ = [0, 0],
    _c_ = [0, 0],
    _b_ = [0, cst_filename],
    cst_unlink = cst_unlink$1,
    cst_unlink$0 = cst_unlink$1,
    cst_open = cst_open$1,
    cst_open$0 = cst_open$1,
    cst_writev = cst_writev$1,
    cst_writev$0 = cst_writev$1,
    cst_readv = cst_readv$1,
    cst_readv$0 = cst_readv$1,
    cst_write = cst_write$1,
    cst_write$0 = cst_write$1,
    cst_read$0 = cst_read$1,
    cst_read = cst_read$1,
    cst_Fd_syscall_in_thread_exn_o = "Fd.syscall_in_thread_exn of a closed fd",
    _a_ = [0, 1],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Io_uring = cst_Async_unix_Io_uring$0,
    max_tries = 1000;
   function attempt_syscall_internal(f, count){
    if(caml_call2(Async_unix_Import[3], count, max_tries))
     caml_call1(Core[6], cst_syscall_interrupted_too_ma);
    function _aA_(param){
     if(0 === param[0]){
      var result = param[1];
      return caml_call1(Async_unix_Import[30], [0, result]);
     }
     var err = param[1];
     if(typeof err === "number" && 11 === err){
      var
       _aD_ =
         function(param){return attempt_syscall_internal(f, count + 1 | 0);},
       _aE_ = caml_call1(Async_unix_Raw_scheduler[33], 0);
      return caml_call2(Async_unix_Import[33][2], _aE_, _aD_);
     }
     return caml_call1(Async_unix_Import[30], [1, err]);
    }
    var
     _aB_ = caml_call1(f, 0),
     _aC_ = caml_call1(Async_unix_Io_uring_raw[29], _aB_);
    return caml_call2(Async_unix_Import[33][2], _aC_, _aA_);
   }
   function attempt_syscall(f){return attempt_syscall_internal(f, 0);}
   function with_file_descr_deferred(name, fd, f){
    function _at_(param){
     if(typeof param === "number"){
      try{
       var
        _aw_ = [0, caml_call1(Async_unix_Fd[3], fd), 0],
        _ax_ = [0, caml_call1(Sexplib0_Sexp_conv[7], name), _aw_],
        _ay_ =
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_Fd_syscall_in_thread_exn_o),
            _ax_]],
        _az_ = caml_call1(Core[261], _ay_),
        exn$0 = _az_;
      }
      catch(exn$1){var exn = caml_wrap_exception(exn$1), exn$0 = exn;}
      return [1, exn$0];
     }
     if(106380200 <= param[1]){
      var exn$1 = param[2];
      throw caml_maybe_attach_backtrace(exn$1, 0);
     }
     var ok = param[2];
     return ok;
    }
    function _au_(fd){return caml_call1(f, fd);}
    var _av_ = caml_call3(Async_unix_Fd[24], fd, _a_, _au_);
    return caml_call2(Async_unix_Import[33][3], _av_, _at_);
   }
   function with_file_descr_deferred_opt(name, fd_opt, f){
    if(! fd_opt) return caml_call1(f, 0);
    var fd = fd_opt[1];
    return with_file_descr_deferred
            (name, fd, function(fd){return caml_call1(f, [0, fd]);});
   }
   function read_file_descr(t, opt, file_descr, off, len, buf){
    if(opt) var sth = opt[1], file_offset = sth; else var file_offset = -1;
    function _ap_(param){
     if(0 === param[0]){var res = param[1]; return [0, res];}
     var err = param[1];
     return [1, [0, Core_unix[4], err, cst_read, cst]];
    }
    var
     _aq_ =
       attempt_syscall
        (function(param){
          var
           _ar_ = caml_call3(Cstruct[3], off, len, buf),
           _as_ = caml_call1(Async_unix_Io_uring_raw[1][1], file_offset);
          return caml_call4
                  (Async_unix_Io_uring_raw[17], t, _as_, file_descr, _ar_);
         });
    return caml_call2(Async_unix_Import[33][3], _aq_, _ap_);
   }
   function read(t, opt, fd, off, len, buf){
    if(opt) var sth = opt[1], file_offset = sth; else var file_offset = -1;
    return with_file_descr_deferred
            (cst_read$0,
             fd,
             function(fd){
              return read_file_descr(t, [0, file_offset], fd, off, len, buf);
             });
   }
   function write(t, opt, fd, off, len, buf){
    if(opt) var sth = opt[1], file_offset = sth; else var file_offset = -1;
    return with_file_descr_deferred
            (cst_write$0,
             fd,
             function(fd){
              function _al_(param){
               if(0 === param[0]){var res = param[1]; return [0, res];}
               var err = param[1];
               return [1, [0, Core_unix[4], err, cst_write, cst$0]];
              }
              var
               _am_ =
                 attempt_syscall
                  (function(param){
                    var
                     _an_ = caml_call3(Cstruct[3], off, len, buf),
                     _ao_ =
                       caml_call1(Async_unix_Io_uring_raw[1][1], file_offset);
                    return caml_call4
                            (Async_unix_Io_uring_raw[18], t, _ao_, fd, _an_);
                   });
              return caml_call2(Async_unix_Import[33][3], _am_, _al_);
             });
   }
   function to_cstruct(iovecs){
    function _aj_(param){
     var len = param[3], pos = param[2], buf = param[1];
     return caml_call3(Cstruct[3], [0, pos], [0, len], buf);
    }
    var _ak_ = caml_call1(Core_Array[45], iovecs);
    return caml_call2(Core_List[51], _ak_, _aj_);
   }
   function readv(t, opt, fd, bufs){
    if(opt) var sth = opt[1], file_offset = sth; else var file_offset = -1;
    return with_file_descr_deferred
            (cst_readv$0,
             fd,
             function(fd){
              function _af_(param){
               if(0 === param[0]){var res = param[1]; return [0, res];}
               var err = param[1];
               return [1, [0, Core_unix[4], err, cst_readv, cst$1]];
              }
              var
               _ag_ =
                 attempt_syscall
                  (function(param){
                    var
                     _ah_ = to_cstruct(bufs),
                     _ai_ =
                       caml_call1(Async_unix_Io_uring_raw[1][1], file_offset);
                    return caml_call4
                            (Async_unix_Io_uring_raw[19], t, _ai_, fd, _ah_);
                   });
              return caml_call2(Async_unix_Import[33][3], _ag_, _af_);
             });
   }
   function writev(t, opt, fd, bufs){
    if(opt) var sth = opt[1], file_offset = sth; else var file_offset = -1;
    return with_file_descr_deferred
            (cst_writev$0,
             fd,
             function(fd){
              function _ab_(param){
               if(0 === param[0]){var res = param[1]; return [0, res];}
               var err = param[1];
               return [1, [0, Core_unix[4], err, cst_writev, cst$2]];
              }
              var
               _ac_ =
                 attempt_syscall
                  (function(param){
                    var
                     _ad_ = to_cstruct(bufs),
                     _ae_ =
                       caml_call1(Async_unix_Io_uring_raw[1][1], file_offset);
                    return caml_call4
                            (Async_unix_Io_uring_raw[20], t, _ae_, fd, _ad_);
                   });
              return caml_call2(Async_unix_Import[33][3], _ac_, _ab_);
             });
   }
   function openat2(t, access, flags, opt, resolve, info, fd, filename){
    if(opt) var sth = opt[1], perm = sth; else var perm = 420;
    a:
    {
     if
      (!
       caml_call2
        (Async_unix_Io_uring_raw[5][3], Async_unix_Io_uring_raw[5][7], flags)
       &&
        !
        caml_call2
         (Async_unix_Io_uring_raw[5][3],
          Async_unix_Io_uring_raw[5][19],
          flags)){
      var perm$0 = 0;
      break a;
     }
     var perm$0 = perm;
    }
    var
     _X_ = caml_call1(Core[558], filename),
     _Y_ = caml_call1(Core_Info[20], _X_),
     info$0 = caml_call2(Core_Option[39], info, _Y_);
    return with_file_descr_deferred_opt
            (cst_open$0,
             fd,
             function(fd_opt){
              function ___(param){
               if(0 === param[0]){
                var
                 res = param[1],
                 _aa_ = caml_call1(Core_unix_File_descr[13], res);
                return [0, caml_call4(Async_unix_Fd[6], 0, 2, _aa_, info$0)];
               }
               var err = param[1], _$_ = caml_call1(Core_Info[13], info$0);
               return [1, [0, Core_unix[4], err, cst_open, _$_]];
              }
              var
               _Z_ =
                 attempt_syscall
                  (function(param){
                    return caml_call7
                            (Async_unix_Io_uring_raw[22],
                             t,
                             access,
                             flags,
                             perm$0,
                             resolve,
                             fd_opt,
                             filename);
                   });
              return caml_call2(Async_unix_Import[33][3], _Z_, ___);
             });
   }
   function unlink(t, dir, fd, filename){
    return with_file_descr_deferred_opt
            (cst_unlink$0,
             fd,
             function(fd_opt){
              function _U_(param){
               if(0 === param[0]) return _c_;
               var
                err = param[1],
                _V_ =
                  [1,
                   [0,
                    [1, [0, _b_, [0, caml_call1(Core[558], filename), 0]]],
                    0]],
                _W_ = caml_call1(Core_unix[10][1], _V_);
               return [1, [0, Core_unix[4], err, cst_unlink, _W_]];
              }
              var
               _T_ =
                 attempt_syscall
                  (function(param){
                    return caml_call4
                            (Async_unix_Io_uring_raw[25], t, dir, fd_opt, filename);
                   });
              return caml_call2(Async_unix_Import[33][3], _T_, _U_);
             });
   }
   function link(t, opt, _I_, target, link_name, param){
    if(opt) var sth = opt[1], follow = sth; else var follow = 0;
    if(_I_) var sth$0 = _I_[1], force = sth$0; else var force = 0;
    function args_for_error(param){
     var
      _R_ = [0, [1, [0, _d_, [0, caml_call1(Core[558], link_name), 0]]], 0],
      _S_ =
        [1, [0, [1, [0, _e_, [0, caml_call1(Core[558], target), 0]]], _R_]];
     return caml_call1(Core_unix[10][1], _S_);
    }
    function _J_(unlink_res){
     if(0 === unlink_res[0]){
      var
       _O_ =
         function(param){
          if(0 === param[0]) return _f_;
          var err = param[1], _Q_ = args_for_error(0);
          return [1, [0, Core_unix[4], err, cst_link, _Q_]];
         },
       _P_ =
         attempt_syscall
          (function(param){
            return caml_call4
                    (Async_unix_Io_uring_raw[24], t, follow, target, link_name);
           });
      return caml_call2(Async_unix_Import[33][3], _P_, _O_);
     }
     var exn = unlink_res[1];
     return caml_call1(Async_unix_Import[30], [1, exn]);
    }
    if(force)
     var
      _K_ =
        function(param){
         if(0 === param[0]) return _g_;
         var exn = param[1];
         if(exn[1] !== Core_unix[4]) return [1, exn];
         var e = exn[2];
         if(typeof e === "number" && 20 === e) return _h_;
         var s = exn[3], _N_ = args_for_error(0);
         return [1, [0, Core_unix[4], e, s, _N_]];
        },
      _L_ = unlink(t, 0, 0, link_name),
      _M_ = caml_call2(Async_unix_Import[33][3], _L_, _K_);
    else
     var _M_ = caml_call1(Async_unix_Import[30], _i_);
    return caml_call2(Async_unix_Import[33][2], _M_, _J_);
   }
   function do_statx(t, fd, opt, path, flags){
    if(opt)
     var sth = opt[1], mask = sth;
    else
     var mask = Async_unix_Io_uring_raw[4][4][15];
    var statx_buffer = caml_call1(Async_unix_Io_uring_raw[4][1], 0);
    function _G_(param){
     if(0 !== param[0]){var err = param[1]; return [1, err];}
     var res = param[1];
     if(caml_call2(Async_unix_Import[3], res, 0)) return [0, statx_buffer];
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    }
    var
     _H_ =
       attempt_syscall
        (function(param){
          return caml_call6
                  (Async_unix_Io_uring_raw[27],
                   t,
                   fd,
                   mask,
                   path,
                   statx_buffer,
                   flags);
         });
    return caml_call2(Async_unix_Import[33][3], _H_, _G_);
   }
   function statx(t, x_003, opt, path, flags){
    if(opt)
     var sth = opt[1], mask = sth;
    else
     var mask = Async_unix_Io_uring_raw[4][4][15];
    return with_file_descr_deferred_opt
            (cst_statx$0,
             x_003,
             function(fd_opt){
              function _C_(param){
               if(0 === param[0]){var res = param[1]; return [0, res];}
               var
                err = param[1],
                _D_ =
                  [0, [1, [0, _k_, [0, caml_call1(Core[558], path), 0]]], 0],
                _E_ =
                  [1,
                   [0,
                    [1,
                     [0,
                      _l_,
                      [0, caml_call2(Core[515], Async_unix_Fd[2], x_003), 0]]],
                    _D_]],
                _F_ = caml_call1(Core_unix[10][1], _E_);
               return [1, [0, Core_unix[4], err, cst_statx, _F_]];
              }
              var _B_ = do_statx(t, fd_opt, [0, mask], path, flags);
              return caml_call2(Async_unix_Import[33][3], _B_, _C_);
             });
   }
   function stat(t, mask, filename){
    function _x_(param){
     if(0 === param[0]){var res = param[1]; return [0, res];}
     var
      err = param[1],
      _z_ =
        [1, [0, [1, [0, _m_, [0, caml_call1(Core[558], filename), 0]]], 0]],
      _A_ = caml_call1(Core_unix[10][1], _z_);
     return [1, [0, Core_unix[4], err, cst_stat, _A_]];
    }
    var
     _y_ = do_statx(t, 0, mask, filename, Async_unix_Io_uring_raw[4][2][4]);
    return caml_call2(Async_unix_Import[33][3], _y_, _x_);
   }
   function fstat(t, mask, fd){
    return with_file_descr_deferred
            (cst_fstat$0,
             fd,
             function(fd){
              function _t_(param){
               if(0 === param[0]){var res = param[1]; return [0, res];}
               var
                err = param[1],
                _v_ =
                  [1,
                   [0,
                    [1,
                     [0, _n_, [0, caml_call1(Core_unix_File_descr[2], fd), 0]]],
                    0]],
                _w_ = caml_call1(Core_unix[10][1], _v_);
               return [1, [0, Core_unix[4], err, cst_fstat, _w_]];
              }
              var
               _u_ =
                 do_statx
                  (t, [0, fd], mask, cst$3, Async_unix_Io_uring_raw[4][2][5]);
              return caml_call2(Async_unix_Import[33][3], _u_, _t_);
             });
   }
   function lstat(t, mask, filename){
    function _p_(param){
     if(0 === param[0]){var res = param[1]; return [0, res];}
     var
      err = param[1],
      _r_ =
        [1, [0, [1, [0, _o_, [0, caml_call1(Core[558], filename), 0]]], 0]],
      _s_ = caml_call1(Core_unix[10][1], _r_);
     return [1, [0, Core_unix[4], err, cst_lstat, _s_]];
    }
    var
     _q_ = do_statx(t, 0, mask, filename, Async_unix_Io_uring_raw[4][2][7]);
    return caml_call2(Async_unix_Import[33][3], _q_, _p_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Io_uring);
   var
    Async_unix_Io_uring =
      [0,
       create,
       exit,
       submit,
       fill_completions,
       read,
       read_file_descr,
       write,
       readv,
       writev,
       openat2,
       unlink,
       link,
       statx,
       stat,
       fstat,
       lstat,
       the_one_and_only];
   runtime.caml_register_global
    (67, Async_unix_Io_uring, cst_Async_unix_Io_uring$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Thread_safe
//# unitInfo: Requires: Async_kernel__Debug, Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler, Async_unix__Import, Async_unix__Raw_scheduler, Base__Exn, Core, Core__Result, Core_thread, Linux_ext, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Squeue, Thread_safe_ivar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Thread_safe$0 = "Async_unix__Thread_safe",
    cst_async_unix$0 = "async_unix",
    cst_block_on_async$0 = "block_on_async",
    cst_function = "function_",
    cst_run_in_async$1 = "run_in_async",
    cst_run_in_async_wait$1 = "run_in_async_wait",
    cst_run_in_async_with_optional$1 = "run_in_async_with_optional_cycle";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_unix_Raw_scheduler = global_data.Async_unix__Raw_scheduler,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Result = global_data.Core__Result,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Squeue = global_data.Squeue,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_unix_Import = global_data.Async_unix__Import,
    Linux_ext = global_data.Linux_ext,
    Base_Exn = global_data.Base__Exn,
    Core_thread = global_data.Core_thread,
    Thread_safe_ivar = global_data.Thread_safe_ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Thread_safe$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/thread_safe.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "thread_safe.ml");
   var
    debug = Async_kernel_Debug[13],
    _j_ = [0, "ok_to_drop_lock"],
    _k_ = [0, "am_holding_lock"],
    _l_ = [0, "i_am_the_scheduler"],
    cst_called_become_helper_threa =
      "called [become_helper_thread_and_block_on_async] from within async",
    cst_run_in_async_wait = cst_run_in_async_wait$1,
    cst_run_in_async_wait$0 = cst_run_in_async_wait$1,
    cst_run_in_async = cst_run_in_async$1,
    cst_run_in_async$0 = cst_run_in_async$1,
    cst_called_block_on_async_from =
      "called [block_on_async] from within async",
    cst_block_on_async = cst_block_on_async$0,
    _c_ = [0, 3804260],
    _d_ = [0, 523273847],
    _e_ = [0, cst_block_on_async$0],
    cst_async_scheduler = "async-scheduler",
    cst_run_in_async_with_optional = cst_run_in_async_with_optional$1,
    cst_run_in_async_with_optional$0 = cst_run_in_async_with_optional$1,
    _b_ = [0, cst_function],
    cst_cannot_call_while_holding_ =
      "cannot call while holding the async lock",
    _a_ = [0, cst_function],
    cst_cannot_call_from_the_main_ = "cannot call from the main thread",
    cst_run_holding_async_lock = "run_holding_async_lock",
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Thread_safe = cst_Async_unix_Thread_safe$0;
   function run_holding_async_lock(opt, t, f, finish){
    if(opt)
     var sth = opt[1], wakeup_scheduler = sth;
    else
     var wakeup_scheduler = 1;
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_run_holding_async_lock,
       t,
       Async_unix_Raw_scheduler[76]);
    if(1 - caml_call1(Async_unix_Raw_scheduler[86], t))
     caml_call1(Async_unix_Raw_scheduler[82], t);
    function _T_(param){
     if(wakeup_scheduler) caml_call1(Async_unix_Raw_scheduler[106], t);
     return caml_call1(Async_unix_Raw_scheduler[84], t);
    }
    function _U_(param){
     function _V_(param){return caml_call1(Core_Result[54], f);}
     return caml_call1
             (finish,
              caml_call3
               (Async_unix_Raw_scheduler[80],
                t,
                Async_kernel_Scheduler[12],
                _V_));
    }
    return caml_call2(Core[259], _U_, _T_);
   }
   function ensure_in_a_thread(t, function$0){
    if(caml_call1(Async_unix_Raw_scheduler[97], 0)){
     var
      _O_ = [0, [1, [0, _a_, [0, caml_call1(Core[558], function$0), 0]]], 0],
      _P_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_call_from_the_main_),
          _O_]];
     caml_call1(Core[261], _P_);
    }
    var _Q_ = caml_call1(Async_unix_Raw_scheduler[86], t);
    if(! _Q_) return _Q_;
    var
     _R_ = [0, [1, [0, _b_, [0, caml_call1(Core[558], function$0), 0]]], 0],
     _S_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_call_while_holding_),
         _R_]];
    return caml_call1(Core[261], _S_);
   }
   function without_async_lock_unchecked(t, f){
    if(! caml_call1(Async_unix_Raw_scheduler[86], t)) return caml_call1(f, 0);
    caml_call1(Async_unix_Raw_scheduler[84], t);
    function _N_(param){return caml_call1(Async_unix_Raw_scheduler[82], t);}
    return caml_call2(Core[259], f, _N_);
   }
   function block_on_async_not_holding_asy(t, f$0){
    if(1 - caml_call1(Async_unix_Raw_scheduler[144], t)){
     var
      f =
        function(param){
         if(caml_call1(Async_unix_Raw_scheduler[144], t)) return 17505;
         t[2] = 2;
         var scheduler_ran_a_job = caml_call1(Thread_safe_ivar[2], 0);
         function _L_(param){
          return caml_call2(Thread_safe_ivar[3], scheduler_ran_a_job, 0);
         }
         var _M_ = caml_call1(Async_unix_Import[30], 0);
         caml_call2(Async_unix_Import[22], _M_, _L_);
         return [0, 4448519, scheduler_ran_a_job];
        };
     if(caml_call1(Async_unix_Raw_scheduler[86], t))
      var starting = f(0);
     else{
      caml_call1(Async_unix_Raw_scheduler[82], t);
      var
       _E_ =
         function(param){return caml_call1(Async_unix_Raw_scheduler[84], t);},
       starting = caml_call2(Core[259], f, _E_);
     }
     if(typeof starting !== "number"){
      var scheduler_ran_a_job = starting[2];
      without_async_lock_unchecked
       (t,
        function(param){
         var _H_ = 0;
         function _I_(param){
          function _J_(param){
           var match = Linux_ext[39];
           if(0 === match[0]){
            var f = match[1];
            caml_call1(f, cst_async_scheduler);
           }
           caml_call1(Async_unix_Raw_scheduler[82], t);
           var _K_ = caml_call2(Async_unix_Raw_scheduler[138], 0, t);
           return caml_call1(Core[158], _K_);
          }
          return caml_call2(Base_Exn[14], 1, _J_);
         }
         caml_call3(Core_thread[2], 890699316, _I_, _H_);
         return caml_call1(Thread_safe_ivar[4], scheduler_ran_a_job);
        });
     }
    }
    function _F_(res){
     if(0 !== res[0]){var exn = res[1]; return [0, 425081257, [1, exn]];}
     var d = res[1], match = caml_call1(Async_kernel_Deferred[5], d);
     if(match){var v = match[1]; return [0, 425081257, v];}
     caml_call1(Async_unix_Raw_scheduler[122], t);
     var match$0 = caml_call1(Async_kernel_Deferred[5], d);
     if(match$0){var v$0 = match$0[1]; return [0, 425081257, v$0];}
     var q = caml_call1(Squeue[2], 1);
     function _G_(v){return caml_call2(Squeue[4], q, v);}
     caml_call2(Async_unix_Import[22], d, _G_);
     return [0, -762465177, q];
    }
    var
     maybe_blocked =
       run_holding_async_lock
        (0,
         t,
         function(param){
          return caml_call7
                  (Async_kernel_Monitor[16], 0, 0, _e_, 0, _d_, _c_, f$0);
         },
         _F_);
    if(425081257 <= maybe_blocked[1]){var v = maybe_blocked[2]; return v;}
    var q = maybe_blocked[2];
    return caml_call1(Squeue[7], q);
   }
   function _f_(t, f){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_block_on_async,
       t,
       Async_unix_Raw_scheduler[76]);
    var _A_ = caml_call1(Async_unix_Raw_scheduler[107], t);
    if(_A_)
     var _B_ = _A_;
    else
     var
      _D_ = caml_call1(Async_unix_Raw_scheduler[86], t),
      _B_ = _D_ ? 1 - caml_call1(Async_unix_Raw_scheduler[97], 0) : _D_;
    if(_B_){
     var
      _C_ = caml_call1(Sexplib0_Sexp_conv[7], cst_called_block_on_async_from);
     caml_call1(Core[261], _C_);
    }
    if(! caml_call1(Async_unix_Raw_scheduler[86], t))
     return block_on_async_not_holding_asy(t, f);
    var execution_context = caml_call1(Async_kernel_Scheduler[4], t[21]);
    caml_call1(Async_unix_Raw_scheduler[84], t);
    var res = block_on_async_not_holding_asy(t, f);
    caml_call1(Async_unix_Raw_scheduler[82], t);
    caml_call2(Async_kernel_Scheduler[7], t[21], execution_context);
    return res;
   }
   function _g_(wakeup_scheduler, t, f){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_run_in_async,
       t,
       Async_unix_Raw_scheduler[76]);
    ensure_in_a_thread(t, cst_run_in_async$0);
    return run_holding_async_lock
            (wakeup_scheduler, t, f, function(_z_){return _z_;});
   }
   function _h_(wakeup_scheduler, t, f){
    var _y_ = _g_(wakeup_scheduler, t, f);
    return caml_call1(Core_Result[40], _y_);
   }
   function _i_(t, f){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_run_in_async_wait,
       t,
       Async_unix_Raw_scheduler[76]);
    ensure_in_a_thread(t, cst_run_in_async_wait$0);
    return _f_(t, f);
   }
   function t(param){return caml_call1(Async_unix_Raw_scheduler[92], 0);}
   function am_holding_async_lock(param){
    var _x_ = t(0);
    return caml_call1(Async_unix_Raw_scheduler[86], _x_);
   }
   function deferred(param){
    var
     t$0 = t(0),
     ivar =
       caml_call1(Async_unix_Raw_scheduler[86], t$0)
        ? caml_call1(Async_kernel_Ivar[12], 0)
        : run_holding_async_lock
          (0, t$0, Async_kernel_Ivar[12], Core_Result[40]);
    function fill(x){
     return _h_
             (0,
              t$0,
              function(param){
               return caml_call2(Async_kernel_Ivar[14], ivar, x);
              });
    }
    return [0, caml_call1(Async_kernel_Ivar[19], ivar), fill];
   }
   function run_in_async_with_optional_cyc(wakeup_scheduler, f){
    var t$0 = t(0);
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_run_in_async_with_optional,
       t$0,
       Async_unix_Raw_scheduler[76]);
    ensure_in_a_thread(t$0, cst_run_in_async_with_optional$0);
    return run_holding_async_lock
            (wakeup_scheduler,
             t$0,
             f,
             function(param){
              if(0 !== param[0]){var exn = param[1]; return [1, exn];}
              var
               match = param[1],
               a = match[2],
               maybe_run_a_cycle = match[1];
              if(883827348 > maybe_run_a_cycle)
               caml_call1(Async_unix_Raw_scheduler[122], t$0);
              return [0, a];
             });
   }
   function run_in_async(wakeup_scheduler, f){return _g_(wakeup_scheduler, t(0), f);
   }
   function run_in_async_exn(wakeup_scheduler, f){return _h_(wakeup_scheduler, t(0), f);
   }
   function block_on_async(f){return _f_(t(0), f);}
   function block_on_async_exn(f){
    var t$0 = t(0), _w_ = _f_(t$0, f);
    return caml_call1(Core_Result[40], _w_);
   }
   function run_in_async_wait(f){return _i_(t(0), f);}
   function run_in_async_wait_exn(f){
    var t$0 = t(0), _v_ = _i_(t$0, f);
    return caml_call1(Core_Result[40], _v_);
   }
   function ok_to_drop_lock(t){
    var
     _t_ = caml_call1(Async_unix_Raw_scheduler[97], 0),
     _u_ = _t_ ? 1 - caml_call1(Async_kernel_Scheduler[74], t[21]) : _t_;
    return _u_;
   }
   function without_async_lock(f){
    var t$0 = t(0);
    a:
    if(! caml_call1(Async_unix_Raw_scheduler[107], t$0)){
     if
      (caml_call1(Async_unix_Raw_scheduler[86], t$0) && ! ok_to_drop_lock(t$0))
      break a;
     return without_async_lock_unchecked(t$0, f);
    }
    var
     _m_ = ok_to_drop_lock(t$0),
     _n_ = [0, [1, [0, _j_, [0, caml_call1(Core[323], _m_), 0]]], 0],
     _o_ = caml_call1(Async_unix_Raw_scheduler[86], t$0),
     _p_ = [0, [1, [0, _k_, [0, caml_call1(Core[323], _o_), 0]]], _n_],
     _q_ = caml_call1(Async_unix_Raw_scheduler[107], t$0),
     _r_ =
       [0,
        [1, [0, [1, [0, _l_, [0, caml_call1(Core[323], _q_), 0]]], _p_]],
        0],
     _s_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_called_become_helper_threa),
         _r_]];
    return caml_call1(Core[261], _s_);
   }
   function without_async_lock_unchecked$0(f){
    var t$0 = t(0);
    return without_async_lock_unchecked(t$0, f);
   }
   var For_tests = [0, without_async_lock_unchecked$0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Thread_safe);
   var
    Async_unix_Thread_safe =
      [0,
       am_holding_async_lock,
       deferred,
       run_in_async_with_optional_cyc,
       run_in_async,
       run_in_async_exn,
       block_on_async,
       block_on_async_exn,
       run_in_async_wait,
       run_in_async_wait_exn,
       without_async_lock,
       For_tests];
   runtime.caml_register_global
    (47, Async_unix_Thread_safe, cst_Async_unix_Thread_safe$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Scheduler
//# unitInfo: Requires: Async_kernel__Async_kernel_scheduler, Async_kernel__Deferred, Async_kernel_config, Async_unix__Io_uring_raw_singleton, Async_unix__Raw_scheduler, Async_unix__Thread_safe, Core, Core__Error, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Time_ns_unix, Time_stamp_counter
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Scheduler$0 = "Async_unix__Scheduler",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_unix_Thread_safe = global_data.Async_unix__Thread_safe,
    Async_unix_Io_uring_raw_single =
      global_data.Async_unix__Io_uring_raw_singleton,
    Async_kernel_config = global_data.Async_kernel_config,
    Time_ns_unix = global_data.Time_ns_unix,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Error = global_data.Core__Error,
    Time_stamp_counter = global_data.Time_stamp_counter,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_unix_Raw_scheduler = global_data.Async_unix__Raw_scheduler,
    Async_kernel_Async_kernel_sche =
      global_data.Async_kernel__Async_kernel_scheduler;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Scheduler$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/scheduler.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "scheduler.ml");
   var
    Which_watcher = Async_unix_Raw_scheduler[3],
    within_context = Async_unix_Raw_scheduler[6],
    within = Async_unix_Raw_scheduler[7],
    within$0 = Async_unix_Raw_scheduler[8],
    within_v = Async_unix_Raw_scheduler[9],
    with_local = Async_unix_Raw_scheduler[10],
    find_local = Async_unix_Raw_scheduler[11],
    schedule = Async_unix_Raw_scheduler[12],
    schedule$0 = Async_unix_Raw_scheduler[13],
    enqueue_job = Async_unix_Raw_scheduler[14],
    thread_safe_enqueue_job = Async_unix_Raw_scheduler[15],
    preserve_execution_context = Async_unix_Raw_scheduler[16],
    preserve_execution_context$0 = Async_unix_Raw_scheduler[17],
    cycle_start = Async_unix_Raw_scheduler[18],
    cycle_start_ns = Async_unix_Raw_scheduler[19],
    cycle_times = Async_unix_Raw_scheduler[20],
    cycle_times_ns = Async_unix_Raw_scheduler[21],
    last_cycle_time = Async_unix_Raw_scheduler[22],
    long_cycles = Async_unix_Raw_scheduler[23],
    cycle_count = Async_unix_Raw_scheduler[24],
    total_cycle_time = Async_unix_Raw_scheduler[25],
    event_precision = Async_unix_Raw_scheduler[26],
    event_precision_ns = Async_unix_Raw_scheduler[27],
    force_current_cycle_to_end = Async_unix_Raw_scheduler[28],
    set_max_num_jobs_per_priority_ = Async_unix_Raw_scheduler[29],
    max_num_jobs_per_priority_per_ = Async_unix_Raw_scheduler[30],
    set_record_backtraces = Async_unix_Raw_scheduler[31],
    recording_backtraces = Async_unix_Raw_scheduler[32],
    yield$0 = Async_unix_Raw_scheduler[33],
    yield_until_no_jobs_remain = Async_unix_Raw_scheduler[34],
    yield_every = Async_unix_Raw_scheduler[35],
    num_jobs_run = Async_unix_Raw_scheduler[36],
    num_pending_jobs = Async_unix_Raw_scheduler[37],
    sexp_of_t = Async_unix_Raw_scheduler[76],
    is_ready_to_initialize = Async_unix_Raw_scheduler[89],
    is_initialized = Async_unix_Raw_scheduler[90],
    default_handle_thread_pool_stu = Async_unix_Raw_scheduler[104],
    reset_in_forked_process_withou = Async_unix_Raw_scheduler[118],
    reset_in_forked_process = Async_unix_Raw_scheduler[119],
    make_async_unusable = Async_unix_Raw_scheduler[120],
    num_busy_pollers = Async_unix_Raw_scheduler[129],
    add_busy_poller = Async_unix_Raw_scheduler[130],
    raise_if_any_jobs_were_schedul = Async_unix_Raw_scheduler[143],
    go = Async_unix_Raw_scheduler[145],
    go_main = Async_unix_Raw_scheduler[146],
    is_the_one_and_only_running = Async_unix_Raw_scheduler[147],
    report_long_cycle_times = Async_unix_Raw_scheduler[148],
    set_check_invariants = Async_unix_Raw_scheduler[149],
    set_detect_invalid_access_from = Async_unix_Raw_scheduler[150],
    set_max_inter_cycle_timeout = Async_unix_Raw_scheduler[151],
    t = Async_unix_Raw_scheduler[152],
    fold_fields = Async_unix_Raw_scheduler[154],
    handle_thread_pool_stuck = Async_unix_Raw_scheduler[155],
    For_metrics = Async_unix_Raw_scheduler[156],
    External = Async_unix_Raw_scheduler[157],
    current_execution_context = Async_kernel_Async_kernel_sche[1],
    _e_ = [0, "t.max_inter_cycle_timeout"],
    _f_ = [0, "min_inter_cycle_timeout"],
    cst_min_inter_cycle_timeout_to = "min_inter_cycle_timeout too large",
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Scheduler = cst_Async_unix_Scheduler$0,
    _a_ = Async_unix_Raw_scheduler[77],
    _b_ = Async_unix_Raw_scheduler[78],
    _c_ = Async_unix_Raw_scheduler[105],
    _d_ = Async_unix_Raw_scheduler[132];
   function time_spent_waiting_for_io(param){
    var
     t$0 = caml_call1(t, 0),
     _m_ = caml_call1(Core[248], Time_stamp_counter[30]),
     _n_ = caml_call2(Time_stamp_counter[24][38], t$0[7], _m_);
    return caml_call1(Time_ns_unix[72][137], _n_);
   }
   function set_min_inter_cycle_timeout(min_inter_cycle_timeout){
    var t$0 = caml_call1(t, 0);
    if(caml_call2(Time_ns_unix[72][18], min_inter_cycle_timeout, t$0[23])){
     var
      _i_ =
        [0,
         [1, [0, _e_, [0, caml_call1(Async_kernel_config[3][2], t$0[23]), 0]]],
         0],
      _j_ =
        [0,
         [1,
          [0,
           _f_,
           [0, caml_call1(Time_ns_unix[72][10], min_inter_cycle_timeout), 0]]],
         _i_],
      _k_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_min_inter_cycle_timeout_to),
          _j_]],
      _l_ = caml_call1(Core_Error[8], _k_);
     caml_call1(Core_Error[30], _l_);
    }
    t$0[24] = caml_call1(Async_kernel_config[4][4], min_inter_cycle_timeout);
    return 0;
   }
   function max_num_open_file_descrs(param){
    return caml_call1(_b_, caml_call1(t, 0));
   }
   function fds_may_produce_events(param){
    return caml_call1(_d_, caml_call1(t, 0));
   }
   function thread_pool_has_unfinished_wor(param){return caml_call1(_c_, caml_call1(t, 0));
   }
   function max_num_threads(param){return caml_call1(_a_, caml_call1(t, 0));}
   function is_running(param){
    return caml_call1(is_the_one_and_only_running, 0);
   }
   function warm_up_fds(param){
    function _h_(param){return caml_call1(Async_kernel_Deferred[12], 0);}
    caml_call1(Async_unix_Thread_safe[7], _h_);
    caml_call1(Async_unix_Io_uring_raw_single[1], 0);
    return 0;
   }
   var For_tests = [0, warm_up_fds];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Scheduler);
   var
    _g_ = For_metrics[1],
    Async_unix_Scheduler =
      [0,
       sexp_of_t,
       current_execution_context,
       within_context,
       within,
       within$0,
       within_v,
       with_local,
       find_local,
       schedule,
       schedule$0,
       enqueue_job,
       thread_safe_enqueue_job,
       preserve_execution_context,
       preserve_execution_context$0,
       cycle_start,
       cycle_start_ns,
       cycle_times,
       cycle_times_ns,
       last_cycle_time,
       long_cycles,
       cycle_count,
       total_cycle_time,
       event_precision,
       event_precision_ns,
       force_current_cycle_to_end,
       set_max_num_jobs_per_priority_,
       max_num_jobs_per_priority_per_,
       set_record_backtraces,
       recording_backtraces,
       yield$0,
       yield_until_no_jobs_remain,
       yield_every,
       num_jobs_run,
       num_pending_jobs,
       Which_watcher,
       t,
       max_num_open_file_descrs,
       max_num_threads,
       go,
       go_main,
       raise_if_any_jobs_were_schedul,
       report_long_cycle_times,
       is_running,
       set_max_inter_cycle_timeout,
       set_check_invariants,
       set_detect_invalid_access_from,
       fold_fields,
       is_ready_to_initialize,
       is_initialized,
       reset_in_forked_process,
       reset_in_forked_process_withou,
       make_async_unusable,
       handle_thread_pool_stuck,
       default_handle_thread_pool_stu,
       time_spent_waiting_for_io,
       set_min_inter_cycle_timeout,
       fds_may_produce_events,
       thread_pool_has_unfinished_wor,
       add_busy_poller,
       num_busy_pollers,
       [0,
        External[8],
        External[9],
        External[1],
        External[4],
        External[6],
        External[7]],
       [0, [0, _g_[2], _g_[3]]],
       For_tests];
   runtime.caml_register_global
    (25, Async_unix_Scheduler, cst_Async_unix_Scheduler$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Require_explicit_time_source_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Require_explici =
      "Async_unix__Require_explicit_time_source_intf",
    cst_async_unix = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Require_explici);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix);
   caml_call1
    (Ppx_expect_runtime[1][1], "src/require_explicit_time_source_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_async_unix,
     "require_explicit_time_source_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Require_explici);
   var Async_unix_Require_explicit_ti = [0];
   runtime.caml_register_global
    (11, Async_unix_Require_explicit_ti, cst_Async_unix_Require_explici);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Require_explicit_time_source
//# unitInfo: Requires: Async_kernel__Require_explicit_time_source, Async_unix__Clock, Async_unix__Require_explicit_time_source_intf, Async_unix__Scheduler, Core__Date, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Time_float_unix, Time_ns_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Require_explici =
      "Async_unix__Require_explicit_time_source",
    cst_async_unix = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Require_explicit_ =
      global_data.Async_kernel__Require_explicit_time_source,
    Async_unix_Clock = global_data.Async_unix__Clock,
    Time_ns_unix = global_data.Time_ns_unix,
    Time_float_unix = global_data.Time_float_unix,
    Core_Date = global_data.Core__Date,
    Async_unix_Scheduler = global_data.Async_unix__Scheduler;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Require_explici);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][1], "src/require_explicit_time_source.ml");
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_async_unix,
     "require_explicit_time_source.ml");
   var
    at = Async_kernel_Require_explicit_[6],
    after = Async_kernel_Require_explicit_[7],
    every = Async_kernel_Require_explicit_[8],
    with_timeout = Async_kernel_Require_explicit_[9];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Require_explici);
   var
    _a_ = Time_ns_unix[75],
    _b_ = Time_float_unix[3],
    _c_ = Time_float_unix[3],
    Async_unix_Require_explicit_ti =
      [0,
       at,
       after,
       every,
       with_timeout,
       [0,
        Async_unix_Scheduler[1],
        Async_unix_Scheduler[2],
        Async_unix_Scheduler[3],
        Async_unix_Scheduler[4],
        Async_unix_Scheduler[5],
        Async_unix_Scheduler[6],
        Async_unix_Scheduler[7],
        Async_unix_Scheduler[8],
        Async_unix_Scheduler[9],
        Async_unix_Scheduler[10],
        Async_unix_Scheduler[11],
        Async_unix_Scheduler[12],
        Async_unix_Scheduler[13],
        Async_unix_Scheduler[14],
        Async_unix_Scheduler[16],
        Async_unix_Scheduler[17],
        Async_unix_Scheduler[18],
        Async_unix_Scheduler[19],
        Async_unix_Scheduler[20],
        Async_unix_Scheduler[21],
        Async_unix_Scheduler[22],
        Async_unix_Scheduler[23],
        Async_unix_Scheduler[24],
        Async_unix_Scheduler[25],
        Async_unix_Scheduler[26],
        Async_unix_Scheduler[27],
        Async_unix_Scheduler[28],
        Async_unix_Scheduler[29],
        Async_unix_Scheduler[30],
        Async_unix_Scheduler[31],
        Async_unix_Scheduler[32],
        Async_unix_Scheduler[33],
        Async_unix_Scheduler[34],
        Async_unix_Scheduler[36],
        Async_unix_Scheduler[37],
        Async_unix_Scheduler[38],
        Async_unix_Scheduler[39],
        Async_unix_Scheduler[40],
        Async_unix_Scheduler[41],
        Async_unix_Scheduler[42],
        Async_unix_Scheduler[43],
        Async_unix_Scheduler[44],
        Async_unix_Scheduler[45],
        Async_unix_Scheduler[46],
        Async_unix_Scheduler[47],
        Async_unix_Scheduler[48],
        Async_unix_Scheduler[49],
        Async_unix_Scheduler[50],
        Async_unix_Scheduler[51],
        Async_unix_Scheduler[52],
        Async_unix_Scheduler[53],
        Async_unix_Scheduler[54],
        Async_unix_Scheduler[55],
        Async_unix_Scheduler[56],
        Async_unix_Scheduler[57],
        Async_unix_Scheduler[58],
        Async_unix_Scheduler[59],
        Async_unix_Scheduler[60],
        Async_unix_Scheduler[15]],
       [0,
        Core_Date[1],
        Core_Date[2],
        Core_Date[3],
        Core_Date[4],
        Core_Date[5],
        Core_Date[6],
        Core_Date[7],
        Core_Date[8],
        Core_Date[9],
        Core_Date[10],
        Core_Date[11],
        Core_Date[12],
        Core_Date[13],
        Core_Date[14],
        Core_Date[15],
        Core_Date[16],
        Core_Date[17],
        Core_Date[18],
        Core_Date[22],
        Core_Date[23],
        Core_Date[24],
        Core_Date[25],
        Core_Date[26],
        Core_Date[27],
        Core_Date[28],
        Core_Date[29],
        Core_Date[30],
        Core_Date[31],
        Core_Date[32],
        Core_Date[33],
        Core_Date[34],
        Core_Date[35],
        Core_Date[36],
        Core_Date[37],
        Core_Date[38],
        Core_Date[39],
        Core_Date[40],
        Core_Date[41],
        Core_Date[43],
        Core_Date[47],
        Core_Date[48],
        Core_Date[49],
        Core_Date[50],
        Core_Date[51],
        Core_Date[52],
        Core_Date[53],
        Core_Date[54],
        Core_Date[55],
        Core_Date[56],
        Core_Date[57],
        Core_Date[58],
        Core_Date[59],
        Core_Date[60],
        Core_Date[61],
        Core_Date[62],
        Core_Date[63],
        Core_Date[64],
        Core_Date[65],
        Core_Date[66],
        Core_Date[67],
        Core_Date[68],
        Core_Date[69],
        Core_Date[70],
        Core_Date[71],
        Core_Date[72],
        Core_Date[73],
        Core_Date[74],
        Core_Date[75],
        Core_Date[76],
        Core_Date[77],
        Core_Date[78],
        Core_Date[79],
        Core_Date[80],
        Core_Date[81],
        Core_Date[82],
        Core_Date[83],
        Core_Date[84],
        Core_Date[85],
        Core_Date[86],
        Core_Date[87],
        Core_Date[88],
        Core_Date[89],
        Core_Date[90],
        Core_Date[91],
        Core_Date[92],
        Core_Date[93],
        Core_Date[99],
        Core_Date[101],
        Core_Date[102],
        Core_Date[103],
        Core_Date[100]],
       [0,
        Time_float_unix[4],
        Time_float_unix[5],
        Time_float_unix[6],
        Time_float_unix[8],
        Time_float_unix[9],
        Time_float_unix[10],
        Time_float_unix[11],
        Time_float_unix[13],
        Time_float_unix[14],
        Time_float_unix[16],
        Time_float_unix[17],
        Time_float_unix[18],
        Time_float_unix[19],
        Time_float_unix[20],
        Time_float_unix[21],
        Time_float_unix[22],
        Time_float_unix[23],
        Time_float_unix[24],
        Time_float_unix[25],
        Time_float_unix[26],
        Time_float_unix[27],
        Time_float_unix[28],
        Time_float_unix[29],
        Time_float_unix[30],
        Time_float_unix[31],
        Time_float_unix[32],
        Time_float_unix[33],
        Time_float_unix[34],
        Time_float_unix[35],
        Time_float_unix[36],
        Time_float_unix[37],
        Time_float_unix[38],
        Time_float_unix[39],
        Time_float_unix[40],
        Time_float_unix[41],
        Time_float_unix[42],
        Time_float_unix[43],
        Time_float_unix[44],
        Time_float_unix[45],
        Time_float_unix[46],
        Time_float_unix[47],
        Time_float_unix[48],
        Time_float_unix[49],
        Time_float_unix[50],
        Time_float_unix[51],
        Time_float_unix[52],
        Time_float_unix[53],
        Time_float_unix[54],
        Time_float_unix[55],
        Time_float_unix[56],
        Time_float_unix[57],
        Time_float_unix[58],
        Time_float_unix[59],
        Time_float_unix[60],
        Time_float_unix[61],
        Time_float_unix[62],
        Time_float_unix[63],
        Time_float_unix[64],
        Time_float_unix[65],
        Time_float_unix[66],
        Time_float_unix[67],
        Time_float_unix[68],
        Time_float_unix[69],
        Time_float_unix[70],
        Time_float_unix[71],
        Time_float_unix[72],
        Time_float_unix[73],
        Time_float_unix[74],
        Time_float_unix[75],
        Time_float_unix[76],
        Time_float_unix[77],
        Time_float_unix[78],
        Time_float_unix[79],
        Time_float_unix[80],
        Time_float_unix[81],
        Time_float_unix[82],
        Time_float_unix[85],
        Time_float_unix[86],
        Time_float_unix[87],
        Time_float_unix[91],
        Time_float_unix[92],
        Time_float_unix[93],
        Time_float_unix[94],
        Time_float_unix[95],
        Time_float_unix[96],
        Time_float_unix[97],
        Time_float_unix[98],
        Time_float_unix[99],
        Time_float_unix[100],
        Time_float_unix[101],
        Time_float_unix[102],
        Time_float_unix[103],
        Time_float_unix[104],
        Time_float_unix[105],
        Time_float_unix[106],
        Time_float_unix[107],
        Time_float_unix[108],
        Time_float_unix[109],
        Time_float_unix[110],
        Time_float_unix[111],
        Time_float_unix[112],
        Time_float_unix[113],
        Time_float_unix[114],
        [0,
         _c_[1],
         _c_[2],
         _c_[3],
         _c_[4],
         _c_[5],
         _c_[6],
         _c_[7],
         _c_[8],
         _c_[9],
         _c_[10],
         _c_[11],
         _c_[12],
         _c_[13],
         _c_[14],
         _c_[15],
         _c_[16],
         _c_[17],
         _c_[18],
         _c_[19],
         _c_[20],
         _c_[21],
         _c_[22],
         _c_[23],
         _c_[24],
         _c_[25],
         _c_[26],
         _c_[27],
         _c_[28],
         _c_[29],
         _c_[30],
         _c_[31],
         _c_[33],
         _c_[36],
         _c_[37],
         _c_[38],
         _c_[43],
         _c_[44],
         _c_[45],
         _c_[46],
         _c_[47],
         _c_[48],
         _c_[49],
         _c_[50],
         _c_[51],
         _c_[52],
         _c_[53],
         _c_[54],
         _c_[55],
         _c_[56],
         _c_[57],
         _c_[58],
         _c_[59],
         _c_[60],
         _c_[61],
         _c_[62],
         _c_[63],
         _c_[64],
         _c_[65],
         _c_[66],
         _c_[67],
         _c_[68],
         _c_[69],
         _c_[70],
         _c_[71],
         _c_[72],
         _c_[73],
         _c_[74],
         _c_[75],
         _c_[76],
         _c_[77],
         _c_[78],
         _c_[79],
         _c_[81]],
        Time_float_unix[15]],
       [0,
        Time_float_unix[4],
        Time_float_unix[5],
        Time_float_unix[6],
        Time_float_unix[8],
        Time_float_unix[9],
        Time_float_unix[10],
        Time_float_unix[11],
        Time_float_unix[13],
        Time_float_unix[14],
        Time_float_unix[16],
        Time_float_unix[17],
        Time_float_unix[18],
        Time_float_unix[19],
        Time_float_unix[20],
        Time_float_unix[21],
        Time_float_unix[22],
        Time_float_unix[23],
        Time_float_unix[24],
        Time_float_unix[25],
        Time_float_unix[26],
        Time_float_unix[27],
        Time_float_unix[28],
        Time_float_unix[29],
        Time_float_unix[30],
        Time_float_unix[31],
        Time_float_unix[32],
        Time_float_unix[33],
        Time_float_unix[34],
        Time_float_unix[35],
        Time_float_unix[36],
        Time_float_unix[37],
        Time_float_unix[38],
        Time_float_unix[39],
        Time_float_unix[40],
        Time_float_unix[41],
        Time_float_unix[42],
        Time_float_unix[43],
        Time_float_unix[44],
        Time_float_unix[45],
        Time_float_unix[46],
        Time_float_unix[47],
        Time_float_unix[48],
        Time_float_unix[49],
        Time_float_unix[50],
        Time_float_unix[51],
        Time_float_unix[52],
        Time_float_unix[53],
        Time_float_unix[54],
        Time_float_unix[55],
        Time_float_unix[56],
        Time_float_unix[57],
        Time_float_unix[58],
        Time_float_unix[59],
        Time_float_unix[60],
        Time_float_unix[61],
        Time_float_unix[62],
        Time_float_unix[63],
        Time_float_unix[64],
        Time_float_unix[65],
        Time_float_unix[66],
        Time_float_unix[67],
        Time_float_unix[68],
        Time_float_unix[69],
        Time_float_unix[70],
        Time_float_unix[71],
        Time_float_unix[72],
        Time_float_unix[73],
        Time_float_unix[74],
        Time_float_unix[75],
        Time_float_unix[76],
        Time_float_unix[77],
        Time_float_unix[78],
        Time_float_unix[79],
        Time_float_unix[80],
        Time_float_unix[81],
        Time_float_unix[82],
        Time_float_unix[85],
        Time_float_unix[86],
        Time_float_unix[87],
        Time_float_unix[91],
        Time_float_unix[92],
        Time_float_unix[93],
        Time_float_unix[94],
        Time_float_unix[95],
        Time_float_unix[96],
        Time_float_unix[97],
        Time_float_unix[98],
        Time_float_unix[99],
        Time_float_unix[100],
        Time_float_unix[101],
        Time_float_unix[102],
        Time_float_unix[103],
        Time_float_unix[104],
        Time_float_unix[105],
        Time_float_unix[106],
        Time_float_unix[107],
        Time_float_unix[108],
        Time_float_unix[109],
        Time_float_unix[110],
        Time_float_unix[111],
        Time_float_unix[112],
        Time_float_unix[113],
        Time_float_unix[114],
        [0,
         _b_[1],
         _b_[2],
         _b_[3],
         _b_[4],
         _b_[5],
         _b_[6],
         _b_[7],
         _b_[8],
         _b_[9],
         _b_[10],
         _b_[11],
         _b_[12],
         _b_[13],
         _b_[14],
         _b_[15],
         _b_[16],
         _b_[17],
         _b_[18],
         _b_[19],
         _b_[20],
         _b_[21],
         _b_[22],
         _b_[23],
         _b_[24],
         _b_[25],
         _b_[26],
         _b_[27],
         _b_[28],
         _b_[29],
         _b_[30],
         _b_[31],
         _b_[33],
         _b_[36],
         _b_[37],
         _b_[38],
         _b_[43],
         _b_[44],
         _b_[45],
         _b_[46],
         _b_[47],
         _b_[48],
         _b_[49],
         _b_[50],
         _b_[51],
         _b_[52],
         _b_[53],
         _b_[54],
         _b_[55],
         _b_[56],
         _b_[57],
         _b_[58],
         _b_[59],
         _b_[60],
         _b_[61],
         _b_[62],
         _b_[63],
         _b_[64],
         _b_[65],
         _b_[66],
         _b_[67],
         _b_[68],
         _b_[69],
         _b_[70],
         _b_[71],
         _b_[72],
         _b_[73],
         _b_[74],
         _b_[75],
         _b_[76],
         _b_[77],
         _b_[78],
         _b_[79],
         _b_[81]],
        Time_float_unix[15]],
       [0,
        Time_ns_unix[1],
        Time_ns_unix[2],
        Time_ns_unix[4],
        Time_ns_unix[5],
        Time_ns_unix[6],
        Time_ns_unix[7],
        Time_ns_unix[8],
        Time_ns_unix[9],
        Time_ns_unix[10],
        Time_ns_unix[11],
        Time_ns_unix[12],
        Time_ns_unix[13],
        Time_ns_unix[14],
        Time_ns_unix[15],
        Time_ns_unix[16],
        Time_ns_unix[17],
        Time_ns_unix[18],
        Time_ns_unix[19],
        Time_ns_unix[20],
        Time_ns_unix[21],
        Time_ns_unix[22],
        Time_ns_unix[23],
        Time_ns_unix[24],
        Time_ns_unix[25],
        Time_ns_unix[26],
        Time_ns_unix[27],
        Time_ns_unix[28],
        Time_ns_unix[29],
        Time_ns_unix[30],
        Time_ns_unix[31],
        Time_ns_unix[32],
        Time_ns_unix[33],
        Time_ns_unix[34],
        Time_ns_unix[35],
        Time_ns_unix[36],
        Time_ns_unix[37],
        Time_ns_unix[38],
        Time_ns_unix[39],
        Time_ns_unix[41],
        Time_ns_unix[42],
        Time_ns_unix[43],
        Time_ns_unix[44],
        Time_ns_unix[45],
        Time_ns_unix[46],
        Time_ns_unix[47],
        Time_ns_unix[48],
        Time_ns_unix[49],
        Time_ns_unix[50],
        Time_ns_unix[51],
        Time_ns_unix[52],
        Time_ns_unix[53],
        Time_ns_unix[54],
        Time_ns_unix[55],
        Time_ns_unix[56],
        Time_ns_unix[57],
        Time_ns_unix[58],
        Time_ns_unix[59],
        Time_ns_unix[60],
        Time_ns_unix[61],
        Time_ns_unix[62],
        Time_ns_unix[63],
        Time_ns_unix[64],
        Time_ns_unix[65],
        Time_ns_unix[66],
        Time_ns_unix[67],
        Time_ns_unix[68],
        Time_ns_unix[69],
        Time_ns_unix[73],
        Time_ns_unix[76],
        Time_ns_unix[77],
        Time_ns_unix[78],
        Time_ns_unix[79],
        Time_ns_unix[80],
        Time_ns_unix[81],
        Time_ns_unix[82],
        Time_ns_unix[83],
        Time_ns_unix[84],
        Time_ns_unix[85],
        Time_ns_unix[86],
        Time_ns_unix[87],
        Time_ns_unix[88],
        Time_ns_unix[89],
        Time_ns_unix[90],
        Time_ns_unix[91],
        Time_ns_unix[92],
        Time_ns_unix[93],
        Time_ns_unix[94],
        Time_ns_unix[95],
        Time_ns_unix[96],
        Time_ns_unix[97],
        Time_ns_unix[98],
        Time_ns_unix[99],
        Time_ns_unix[100],
        Time_ns_unix[101],
        Time_ns_unix[102],
        Time_ns_unix[103],
        Time_ns_unix[104],
        Time_ns_unix[105],
        Time_ns_unix[106],
        Time_ns_unix[108],
        Time_ns_unix[111],
        Time_ns_unix[112],
        Time_ns_unix[113],
        Time_ns_unix[118],
        Time_ns_unix[120],
        Time_ns_unix[121],
        Time_ns_unix[122],
        Time_ns_unix[123],
        Time_ns_unix[124],
        Time_ns_unix[125],
        Time_ns_unix[126],
        Time_ns_unix[127],
        Time_ns_unix[128],
        Time_ns_unix[129],
        Time_ns_unix[130],
        Time_ns_unix[131],
        Time_ns_unix[132],
        Time_ns_unix[133],
        Time_ns_unix[134],
        Time_ns_unix[135],
        [0,
         _a_[1],
         _a_[2],
         _a_[3],
         _a_[4],
         _a_[5],
         _a_[6],
         _a_[7],
         _a_[8],
         _a_[9],
         _a_[10],
         _a_[11],
         _a_[12],
         _a_[13],
         _a_[14],
         _a_[15],
         _a_[16],
         _a_[17],
         _a_[18],
         _a_[19],
         _a_[20],
         _a_[21],
         _a_[22],
         _a_[23],
         _a_[24],
         _a_[25],
         _a_[26],
         _a_[27],
         _a_[28],
         _a_[29],
         _a_[30],
         _a_[31],
         _a_[32],
         _a_[33],
         _a_[34],
         _a_[35],
         _a_[36],
         _a_[37],
         _a_[38],
         _a_[39],
         _a_[40],
         _a_[41],
         _a_[42],
         _a_[43],
         _a_[44],
         _a_[45],
         _a_[46],
         _a_[47],
         _a_[48],
         _a_[49],
         _a_[50],
         _a_[51],
         _a_[52],
         _a_[53],
         _a_[54],
         _a_[55],
         _a_[56],
         _a_[57],
         _a_[58],
         _a_[59],
         _a_[60],
         _a_[61],
         _a_[62],
         _a_[63],
         _a_[64],
         _a_[65],
         _a_[66],
         _a_[67],
         _a_[68],
         _a_[69],
         _a_[70],
         _a_[71],
         _a_[72],
         _a_[73],
         _a_[74],
         _a_[75],
         _a_[76],
         _a_[78],
         _a_[79],
         _a_[80],
         _a_[81],
         _a_[82],
         _a_[83],
         _a_[77]],
        Time_ns_unix[40]],
       Async_unix_Clock];
   runtime.caml_register_global
    (17, Async_unix_Require_explicit_ti, cst_Async_unix_Require_explici);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Signal
//# unitInfo: Requires: Async_unix__Import, Async_unix__Raw_scheduler, Async_unix__Signal_manager, Core, Core__List, Core__Option, Core__Signal, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Signal$0 = "Async_unix__Signal",
    cst_async_unix$0 = "async_unix",
    cst_src_signal_ml = "src/signal.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_unix_Signal_manager = global_data.Async_unix__Signal_manager,
    Core_List = global_data.Core__List,
    Async_unix_Import = global_data.Async_unix__Import,
    Async_unix_Raw_scheduler = global_data.Async_unix__Raw_scheduler,
    Core = global_data.Core,
    Core_Option = global_data.Core__Option,
    Assert_failure = global_data.Assert_failure,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Signal = global_data.Core__Signal;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Signal$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_signal_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "signal.ml");
   var
    bin_size_t = Core_Signal[1],
    bin_write_t = Core_Signal[2],
    bin_read_t = Core_Signal[3],
    bin_read_t$0 = Core_Signal[4],
    bin_shape_t = Core_Signal[5],
    bin_writer_t = Core_Signal[6],
    bin_reader_t = Core_Signal[7],
    bin_t = Core_Signal[8],
    t_of_sexp = Core_Signal[9],
    sexp_of_t = Core_Signal[10],
    symbol = Core_Signal[11],
    symbol$0 = Core_Signal[12],
    symbol$1 = Core_Signal[13],
    symbol$2 = Core_Signal[14],
    symbol$3 = Core_Signal[15],
    symbol$4 = Core_Signal[16],
    min = Core_Signal[17],
    max = Core_Signal[18],
    ascending = Core_Signal[19],
    descending = Core_Signal[20],
    between = Core_Signal[21],
    clamp_exn = Core_Signal[22],
    clamp = Core_Signal[23],
    comparator = Core_Signal[24],
    validate_lbound = Core_Signal[25],
    validate_ubound = Core_Signal[26],
    validate_bound = Core_Signal[27],
    Replace_polymorphic_compare = Core_Signal[28],
    Map = Core_Signal[29],
    Set = Core_Signal[30],
    compare = Core_Signal[31],
    hash_fold_t = Core_Signal[32],
    hash = Core_Signal[33],
    hashable = Core_Signal[34],
    Table = Core_Signal[35],
    Hash_set = Core_Signal[36],
    Hash_queue = Core_Signal[37],
    of_string = Core_Signal[38],
    equal = Core_Signal[39],
    of_caml_int = Core_Signal[40],
    to_caml_int = Core_Signal[41],
    to_string = Core_Signal[42],
    sexp_of_sys_behavior = Core_Signal[43],
    sys_behavior_of_sexp = Core_Signal[44],
    sys_behavior_of_sexp$0 = Core_Signal[45],
    default_sys_behavior = Core_Signal[46],
    abrt = Core_Signal[49],
    alrm = Core_Signal[50],
    bus = Core_Signal[51],
    chld = Core_Signal[52],
    cont = Core_Signal[53],
    fpe = Core_Signal[54],
    hup = Core_Signal[55],
    ill = Core_Signal[56],
    int$0 = Core_Signal[57],
    kill = Core_Signal[58],
    pipe = Core_Signal[59],
    poll = Core_Signal[60],
    prof = Core_Signal[61],
    quit = Core_Signal[62],
    segv = Core_Signal[63],
    sys = Core_Signal[64],
    stop = Core_Signal[65],
    term = Core_Signal[66],
    trap = Core_Signal[67],
    tstp = Core_Signal[68],
    ttin = Core_Signal[69],
    ttou = Core_Signal[70],
    urg = Core_Signal[71],
    usr1 = Core_Signal[72],
    usr2 = Core_Signal[73],
    vtalrm = Core_Signal[74],
    xcpu = Core_Signal[75],
    xfsz = Core_Signal[76],
    zero = Core_Signal[77],
    can_send_to = Core_Signal[78],
    of_system_int = Core_Signal[79],
    send = Core_Signal[80],
    send_exn = Core_Signal[81],
    send_i = Core_Signal[82],
    sexp_of_pid_spec = Core_Signal[83],
    sigpending = Core_Signal[84],
    sigprocmask = Core_Signal[85],
    sigsuspend = Core_Signal[86],
    to_system_int = Core_Signal[87],
    Stable = Core_Signal[89],
    _b_ = [0, cst_src_signal_ml, 6, 36],
    _a_ = [0, cst_src_signal_ml, 5, 44],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Signal = cst_Async_unix_Signal$0;
   function handle_default(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function ignore(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   var the_one_and_only = Async_unix_Raw_scheduler[92];
   function handle(stop, ts, f){
    var
     scheduler = caml_call1(the_one_and_only, 0),
     signal_manager = scheduler[15],
     _d_ = caml_call1(Async_unix_Raw_scheduler[16], f),
     _e_ = caml_call1(Core[267], _d_),
     handler =
       caml_call3(Async_unix_Signal_manager[8], signal_manager, ts, _e_);
    function _f_(stop){
     function _g_(param){
      return caml_call2(Async_unix_Signal_manager[9], signal_manager, handler);
     }
     return caml_call2(Async_unix_Import[22], stop, _g_);
    }
    return caml_call2(Core_Option[46], stop, _f_);
   }
   var
    terminating =
      [0, alrm, [0, hup, [0, int$0, [0, term, [0, usr1, [0, usr2, 0]]]]]];
   function manage_by_async(ts){
    var
     scheduler = caml_call1(the_one_and_only, 0),
     signal_manager = scheduler[15];
    function _c_(t){
     return caml_call2(Async_unix_Signal_manager[5], signal_manager, t);
    }
    return caml_call2(Core_List[19], ts, _c_);
   }
   function is_managed_by_async(t){
    var
     scheduler = caml_call1(the_one_and_only, 0),
     signal_manager = scheduler[15];
    return caml_call2(Async_unix_Signal_manager[6], signal_manager, t);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Signal);
   var
    Async_unix_Signal =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       t_of_sexp,
       sexp_of_t,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       Map,
       Set,
       compare,
       hash_fold_t,
       hash,
       hashable,
       Table,
       Hash_set,
       Hash_queue,
       of_string,
       equal,
       of_caml_int,
       to_caml_int,
       to_string,
       sexp_of_sys_behavior,
       sys_behavior_of_sexp,
       sys_behavior_of_sexp$0,
       default_sys_behavior,
       abrt,
       alrm,
       bus,
       chld,
       cont,
       fpe,
       hup,
       ill,
       int$0,
       kill,
       pipe,
       poll,
       prof,
       quit,
       segv,
       sys,
       stop,
       term,
       trap,
       tstp,
       ttin,
       ttou,
       urg,
       usr1,
       usr2,
       vtalrm,
       xcpu,
       xfsz,
       zero,
       can_send_to,
       of_system_int,
       send,
       send_exn,
       send_i,
       sexp_of_pid_spec,
       sigpending,
       sigprocmask,
       sigsuspend,
       to_system_int,
       Stable,
       handle_default,
       ignore,
       handle,
       manage_by_async,
       terminating,
       is_managed_by_async];
   runtime.caml_register_global
    (21, Async_unix_Signal, cst_Async_unix_Signal$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Unix_syscalls
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Deferred_list, Async_kernel__Execution_context, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler, Async_kernel__Throttle, Async_unix__Clock, Async_unix__Fd, Async_unix__Import, Async_unix__In_thread, Async_unix__Io_uring, Async_unix__Io_uring_raw, Async_unix__Io_uring_raw_singleton, Async_unix__Raw_scheduler, Async_unix__Signal, Base__Hash, Bin_prot__Common, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Write, Bin_shape, CamlinternalLazy, Core, Core__Command_internal, Core__Comparable, Core__Core_sys, Core__Fn, Core__Host_and_port, Core__Info, Core__Int, Core__Int64, Core__List, Core__Option, Core__Or_error, Core__Pid, Core__Printf, Core__Result, Core__Sexp, Core__Sexpable, Core__Signal, Core_unix, Core_unix__File_descr, Linux_ext, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_conv_record, Sys_unix, Time_float_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_ADDR_INET$1 = "ADDR_INET",
    cst_ADDR_UNIX$1 = "ADDR_UNIX",
    cst_AI_CANONNAME = "AI_CANONNAME",
    cst_AI_FAMILY$0 = "AI_FAMILY",
    cst_AI_NUMERICHOST = "AI_NUMERICHOST",
    cst_AI_PASSIVE = "AI_PASSIVE",
    cst_AI_PROTOCOL$0 = "AI_PROTOCOL",
    cst_AI_SOCKTYPE$0 = "AI_SOCKTYPE",
    cst_Async_unix_Unix_syscalls$0 = "Async_unix__Unix_syscalls",
    cst_Block$0 = "Block",
    cst_Char$0 = "Char",
    cst_Directory$0 = "Directory",
    cst_Fifo$0 = "Fifo",
    cst_File$0 = "File",
    cst_Flock = "Flock",
    cst_Inet$1 = "Inet",
    cst_Link$0 = "Link",
    cst_Lockf = "Lockf",
    cst_NI_DGRAM = "NI_DGRAM",
    cst_NI_NAMEREQD = "NI_NAMEREQD",
    cst_NI_NOFQDN = "NI_NOFQDN",
    cst_NI_NUMERICHOST = "NI_NUMERICHOST",
    cst_NI_NUMERICSERV = "NI_NUMERICSERV",
    cst_PF_INET = "PF_INET",
    cst_PF_INET6 = "PF_INET6",
    cst_PF_UNIX = "PF_UNIX",
    cst_SOCK_DGRAM = "SOCK_DGRAM",
    cst_SOCK_RAW = "SOCK_RAW",
    cst_SOCK_SEQPACKET = "SOCK_SEQPACKET",
    cst_SOCK_STREAM = "SOCK_STREAM",
    cst_Socket$0 = "Socket",
    cst_Unix$0 = "Unix",
    cst$2 = "_",
    cst_aDDR_INET = "aDDR_INET",
    cst_aDDR_UNIX = "aDDR_UNIX",
    cst_aI_CANONNAME = "aI_CANONNAME",
    cst_aI_FAMILY = "aI_FAMILY",
    cst_aI_NUMERICHOST = "aI_NUMERICHOST",
    cst_aI_PASSIVE = "aI_PASSIVE",
    cst_aI_PROTOCOL = "aI_PROTOCOL",
    cst_aI_SOCKTYPE = "aI_SOCKTYPE",
    cst_access$1 = "access",
    cst_ai_addr$2 = "ai_addr",
    cst_ai_canonname$2 = "ai_canonname",
    cst_ai_family$2 = "ai_family",
    cst_ai_protocol$2 = "ai_protocol",
    cst_ai_socktype$2 = "ai_socktype",
    cst_async_unix$0 = "async_unix",
    cst_atime$1 = "atime",
    cst_bound_on = "bound_on",
    cst_ctime$1 = "ctime",
    cst_dev$1 = "dev",
    cst_dir$0 = "dir",
    cst_file_perm$1 = "file_perm",
    cst_flock$0 = "flock",
    cst_fstat$1 = "fstat",
    cst_gecos$0 = "gecos",
    cst_getaddrinfo_option$1 = "getaddrinfo_option",
    cst_gethostbyaddr$1 = "gethostbyaddr",
    cst_gethostbyname$1 = "gethostbyname",
    cst_getnameinfo_option$1 = "getnameinfo_option",
    cst_gid$3 = "gid",
    cst_ino$1 = "ino",
    cst_kind$1 = "kind",
    cst_listening_on = "listening_on",
    cst_lockf$0 = "lockf",
    cst_mem$0 = "mem",
    cst_mkdir$1 = "mkdir",
    cst_mode = "mode",
    cst_mtime$1 = "mtime",
    cst_nI_DGRAM = "nI_DGRAM",
    cst_nI_NAMEREQD = "nI_NAMEREQD",
    cst_nI_NOFQDN = "nI_NOFQDN",
    cst_nI_NUMERICHOST = "nI_NUMERICHOST",
    cst_nI_NUMERICSERV = "nI_NUMERICSERV",
    cst_name$1 = "name",
    cst_ni_hostname$1 = "ni_hostname",
    cst_ni_service$1 = "ni_service",
    cst_nlink$1 = "nlink",
    cst_pF_INET = "pF_INET",
    cst_pF_INET6 = "pF_INET6",
    cst_pF_UNIX = "pF_UNIX",
    cst_passwd$1 = "passwd",
    cst_perm$1 = "perm",
    cst_rdev$1 = "rdev",
    cst_sOCK_DGRAM = "sOCK_DGRAM",
    cst_sOCK_RAW = "sOCK_RAW",
    cst_sOCK_SEQPACKET = "sOCK_SEQPACKET",
    cst_sOCK_STREAM = "sOCK_STREAM",
    cst_shell$0 = "shell",
    cst_size$1 = "size",
    cst_sockaddr$1 = "sockaddr",
    cst_sockaddr_blocking_sexp$1 = "sockaddr_blocking_sexp",
    cst_socket$2 = "socket",
    cst_socket_domain$1 = "socket_domain",
    cst_socket_type$1 = "socket_type",
    cst_src_unix_syscalls_ml = "src/unix_syscalls.ml",
    cst_src_unix_syscalls_ml_Addr_$3 =
      "src/unix_syscalls.ml.Addr_info.Blocking_sexp.t",
    cst_src_unix_syscalls_ml_Addr_$2 =
      "src/unix_syscalls.ml.Addr_info.getaddrinfo_option",
    cst_src_unix_syscalls_ml_File_ = "src/unix_syscalls.ml.File_kind.T.t",
    cst_src_unix_syscalls_ml_Name_$1 =
      "src/unix_syscalls.ml.Name_info.getnameinfo_option",
    cst_src_unix_syscalls_ml_Name_$2 = "src/unix_syscalls.ml.Name_info.t",
    cst_src_unix_syscalls_ml_Socke =
      "src/unix_syscalls.ml.Socket.Address.Blocking_sexp.t",
    cst_src_unix_syscalls_ml_Socke$1 =
      "src/unix_syscalls.ml.Socket.Address.Inet.Blocking_sexp.t",
    cst_src_unix_syscalls_ml_Socke$0 =
      "src/unix_syscalls.ml.Socket.Address.Unix.t",
    cst_src_unix_syscalls_ml_Stats$0 = "src/unix_syscalls.ml.Stats.t",
    cst_src_unix_syscalls_ml_socka$2 = "src/unix_syscalls.ml.sockaddr",
    cst_src_unix_syscalls_ml_socka$1 =
      "src/unix_syscalls.ml.sockaddr_blocking_sexp",
    cst_src_unix_syscalls_ml_socke$2 = "src/unix_syscalls.ml.socket_domain",
    cst_src_unix_syscalls_ml_socke$1 = "src/unix_syscalls.ml.socket_type",
    cst_t$19 = "t",
    cst_t_fd = "t.fd",
    cst_uid$2 = "uid",
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    err$4 = [2, cst_src_unix_syscalls_ml_Socke],
    err$3 = [2, "src/unix_syscalls.ml.Socket.Address.t"],
    err$2 = [2, cst_src_unix_syscalls_ml_Socke$0],
    err$1 = [2, cst_src_unix_syscalls_ml_Socke$1],
    err$0 = [2, "src/unix_syscalls.ml.Socket.Address.Inet.t"],
    cst = cst$1,
    err = [2, cst_src_unix_syscalls_ml_File_],
    all = [0, 0, [0, 1, 0]],
    error_source_012 = "src/unix_syscalls.ml.Lock_mechanism.T.t",
    error_source_028 = cst_src_unix_syscalls_ml_File_,
    error_source_030 = cst_src_unix_syscalls_ml_File_,
    error_source_032 = cst_src_unix_syscalls_ml_Stats$0,
    error_source_065 = "src/unix_syscalls.ml.wait_on",
    error_source_109 = cst_src_unix_syscalls_ml_Socke$1,
    error_source_113 = cst_src_unix_syscalls_ml_Socke$1,
    error_source_136 = cst_src_unix_syscalls_ml_Socke$0,
    error_source_138 = cst_src_unix_syscalls_ml_Socke$0,
    error_source_144 = cst_src_unix_syscalls_ml_Socke,
    error_source_170 = cst_src_unix_syscalls_ml_socke$2,
    error_source_176 = cst_src_unix_syscalls_ml_socke$1,
    error_source_194 = cst_src_unix_syscalls_ml_socka$1,
    error_source_226 = cst_src_unix_syscalls_ml_Addr_$3,
    error_source_241 = cst_src_unix_syscalls_ml_Addr_$2,
    error_source_265 = cst_src_unix_syscalls_ml_Name_$2,
    error_source_274 = cst_src_unix_syscalls_ml_Name_$1,
    error_source_277 = "src/unix_syscalls.ml.Passwd.t",
    error_source_295 = "src/unix_syscalls.ml.Group.t",
    Async_unix_In_thread = global_data.Async_unix__In_thread,
    Core_unix = global_data.Core_unix,
    Core = global_data.Core,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Async_unix_Fd = global_data.Async_unix__Fd,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Bin_prot_Common = global_data.Bin_prot__Common,
    Bin_prot_Write = global_data.Bin_prot__Write,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Core_Info = global_data.Core__Info,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_unix_Import = global_data.Async_unix__Import,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Core_List = global_data.Core__List,
    Core_Sexp = global_data.Core__Sexp,
    Core_Host_and_port = global_data.Core__Host_and_port,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Async_unix_Raw_scheduler = global_data.Async_unix__Raw_scheduler,
    Core_Pid = global_data.Core__Pid,
    Core_Result = global_data.Core__Result,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Core_Signal = global_data.Core__Signal,
    Async_unix_Signal = global_data.Async_unix__Signal,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Core_Fn = global_data.Core__Fn,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_unix_Io_uring_raw_single =
      global_data.Async_unix__Io_uring_raw_singleton,
    Async_unix_Io_uring = global_data.Async_unix__Io_uring,
    Time_float_unix = global_data.Time_float_unix,
    Async_unix_Io_uring_raw = global_data.Async_unix__Io_uring_raw,
    Core_Int64 = global_data.Core__Int64,
    Core_Option = global_data.Core__Option,
    Core_unix_File_descr = global_data.Core_unix__File_descr,
    Core_Printf = global_data.Core__Printf,
    Async_unix_Clock = global_data.Async_unix__Clock,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Linux_ext = global_data.Linux_ext,
    Core_Or_error = global_data.Core__Or_error,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Core_Sexpable = global_data.Core__Sexpable,
    Core_Command_internal = global_data.Core__Command_internal,
    Core_Comparable = global_data.Core__Comparable,
    Core_Core_sys = global_data.Core__Core_sys,
    Sys_unix = global_data.Sys_unix;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Unix_syscalls$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_unix_syscalls_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "unix_syscalls.ml");
   var
    Unix_error = Core_unix[4],
    include = Async_unix_Fd[11],
    close = include[1],
    deregister = include[2],
    cst_wordexp = "wordexp",
    cst_getlogin = "getlogin",
    cst_username = "username",
    _c5_ = [0, cst_mem$0],
    _c6_ = [0, cst_gid$3],
    _c7_ = [0, cst_passwd$1],
    _c8_ = [0, cst_name$1],
    cst_mem = cst_mem$0,
    cst_gid$2 = cst_gid$3,
    cst_passwd$0 = cst_passwd$1,
    cst_name$0 = cst_name$1,
    _cY_ = [0, cst_shell$0],
    _cZ_ = [0, cst_dir$0],
    _c0_ = [0, cst_gecos$0],
    _c1_ = [0, cst_gid$3],
    _c2_ = [0, cst_uid$2],
    _c3_ = [0, cst_passwd$1],
    _c4_ = [0, cst_name$1],
    cst_shell = cst_shell$0,
    cst_dir = cst_dir$0,
    cst_gecos = cst_gecos$0,
    cst_gid$1 = cst_gid$3,
    cst_uid$1 = cst_uid$2,
    cst_passwd = cst_passwd$1,
    cst_name = cst_name$1,
    cst_tcsetattr = "tcsetattr",
    cst_tcgetattr = "tcgetattr",
    cst_getnameinfo = "getnameinfo",
    _cV_ = [1, cst_src_unix_syscalls_ml_Name_$1],
    cst_src_unix_syscalls_ml_Name_$0 = cst_src_unix_syscalls_ml_Name_$1,
    _cL_ = [0, cst_NI_NOFQDN],
    _cM_ = [0, cst_NI_NUMERICHOST],
    _cN_ = [0, cst_NI_NAMEREQD],
    _cO_ = [0, cst_NI_NUMERICSERV],
    _cP_ = [0, cst_NI_DGRAM],
    _cJ_ = [0, cst_ni_service$1],
    _cK_ = [0, cst_ni_hostname$1],
    cst_ni_service$0 = cst_ni_service$1,
    cst_ni_hostname$0 = cst_ni_hostname$1,
    cst_src_unix_syscalls_ml_Name_ = cst_src_unix_syscalls_ml_Name_$2,
    cst_getaddrinfo = "getaddrinfo",
    _cz_ = [0, cst_AI_NUMERICHOST],
    _cA_ = [0, cst_AI_CANONNAME],
    _cB_ = [0, cst_AI_PASSIVE],
    _cC_ = [0, cst_AI_FAMILY$0],
    _cD_ = [0, cst_AI_SOCKTYPE$0],
    _cE_ = [0, cst_AI_PROTOCOL$0],
    _cy_ = [1, cst_src_unix_syscalls_ml_Addr_$2],
    cst_src_unix_syscalls_ml_Addr_$1 = cst_src_unix_syscalls_ml_Addr_$2,
    _co_ = [0, cst_ai_canonname$2],
    _cp_ = [0, cst_ai_addr$2],
    _cq_ = [0, cst_ai_protocol$2],
    _cr_ = [0, cst_ai_socktype$2],
    _cs_ = [0, cst_ai_family$2],
    cst_ai_canonname$1 = cst_ai_canonname$2,
    cst_ai_addr$1 = cst_ai_addr$2,
    cst_ai_protocol$1 = cst_ai_protocol$2,
    cst_ai_socktype$1 = cst_ai_socktype$2,
    cst_ai_family$1 = cst_ai_family$2,
    cst_src_unix_syscalls_ml_Addr_$0 = cst_src_unix_syscalls_ml_Addr_$3,
    _cf_ = [0, cst_ai_canonname$2],
    _cg_ = [0, cst_ai_addr$2],
    _ch_ = [0, cst_ai_protocol$2],
    _ci_ = [0, cst_ai_socktype$2],
    _cj_ = [0, cst_ai_family$2],
    cst_src_unix_syscalls_ml_Addr_ = "src/unix_syscalls.ml.Addr_info.t",
    _b$_ = [0, cst_ADDR_UNIX$1],
    _ca_ = [0, cst_ADDR_INET$1],
    _b__ = [1, cst_src_unix_syscalls_ml_socka$1],
    cst_src_unix_syscalls_ml_socka$0 = cst_src_unix_syscalls_ml_socka$1,
    _b4_ = [0, cst_ADDR_UNIX$1],
    _b5_ = [0, cst_ADDR_INET$1],
    _b3_ = [1, cst_src_unix_syscalls_ml_socka$2],
    cst_src_unix_syscalls_ml_socka = cst_src_unix_syscalls_ml_socka$2,
    _bV_ = [0, cst_SOCK_STREAM],
    _bW_ = [0, cst_SOCK_DGRAM],
    _bX_ = [0, cst_SOCK_RAW],
    _bY_ = [0, cst_SOCK_SEQPACKET],
    _bU_ = [1, cst_src_unix_syscalls_ml_socke$1],
    cst_src_unix_syscalls_ml_socke$0 = cst_src_unix_syscalls_ml_socke$1,
    _bM_ = [0, cst_PF_UNIX],
    _bN_ = [0, cst_PF_INET],
    _bO_ = [0, cst_PF_INET6],
    _bL_ = [1, cst_src_unix_syscalls_ml_socke$2],
    cst_src_unix_syscalls_ml_socke = cst_src_unix_syscalls_ml_socke$2,
    cst_gethostbyaddr$0 = cst_gethostbyaddr$1,
    cst_gethostbyaddr = cst_gethostbyaddr$1,
    cst_gethostbyname$0 = cst_gethostbyname$1,
    cst_gethostbyname = cst_gethostbyname$1,
    cst_socketpair = "<socketpair>",
    _bF_ = [0, -891636250],
    _bE_ = [0, 1],
    _bC_ = [0, cst_src_unix_syscalls_ml, 1302, 22],
    _bB_ = [0, cst_t_fd],
    cst_close_during_connect = "close during connect",
    _bA_ = [0, cst_t_fd],
    cst_close_after_connect = "close after connect",
    cst_connect_on_bad_file_descri = "connect on bad file descriptor",
    cst_connect = "connect",
    _bz_ = [0, cst_t_fd],
    cst_close_before_connect = "close before connect",
    cst_connected_to = "connected to",
    _bx_ = [0, -891636250],
    _by_ = [0, 1],
    _bw_ = [0, "limit"],
    cst_Socket_accept_at_most_inte =
      "[Socket.accept_at_most_interruptible] got [limit] < 1",
    cst_accept_on_bad_file_descrip = "accept on bad file descriptor",
    _bu_ = [0, 990972795, 0],
    _bv_ = [0, -289386606, -177230888],
    _br_ = [0, cst_listening_on],
    _bs_ = [0, "client"],
    _bp_ = [0, 1],
    _bq_ = [0, 1],
    cst_socket$1 = cst_socket$2,
    _bt_ = [0, -891636250],
    cst_listening = "listening",
    _bo_ = [0, -893685881],
    cst_bind = "bind",
    _bn_ = [0, cst_bound_on],
    cst_socket$0 = cst_socket$2,
    _bm_ = [0, -903208930],
    _bc_ = [0, cst$2],
    _bb_ = [0, 1],
    cst_socket = cst_socket$2,
    _bd_ = [0, 214958384],
    _ba_ = [0, cst$2],
    cst_tcp = "tcp",
    cst_udp = "udp",
    _a8_ = [0, cst_listening_on],
    _a9_ = [0, cst_bound_on],
    _a__ = [0, "type_"],
    _a$_ = [0, "connected_to"],
    _a6_ = [0, cst_socket_type$1],
    _a7_ = [0, "family"],
    cst_unix = "unix",
    cst_inet = "inet",
    cst_inet6 = "inet6",
    _a5_ = [0, 0],
    cst_Socket_Address_unix = "Socket.Address.unix",
    _aM_ = [0, cst_Unix$0],
    cst_Socket_Address_inet = "Socket.Address.inet",
    cst_0_0_0_0 = "0.0.0.0",
    _aE_ = [0, cst_Inet$1],
    _aD_ = [0, cst_Inet$1],
    cst_PORT = "PORT",
    _au_ = [0, [2, 0, [12, 58, [2, 0, 0]]], "%s:%s"],
    cst_getbyname = "getbyname",
    _aj_ = [0, "exit_or_signal"],
    _ak_ = [0, "child_pid"],
    cst_child_process_didn_t_exit_ = "child process didn't exit with status 0",
    cst_src_unix_syscalls_ml_735_7 = "src/unix_syscalls.ml:735:78",
    cst_already_handling_SIGCHLD = "already handling SIGCHLD",
    _ai_ = [0, cst_src_unix_syscalls_ml, 688, 8],
    cst_utimes = "utimes",
    cst_getgrouplist = "getgrouplist",
    cst_mkstemp = "mkstemp",
    cst_mkdtemp = "mkdtemp",
    cst_readlink = "readlink",
    cst_symlink = "symlink",
    cst_mkfifo = "mkfifo",
    _ah_ = [0, 1],
    cst_writer = "writer",
    cst_reader = "reader",
    cst_pipe = "pipe",
    cst_closedir = "closedir",
    cst_rewinddir = "rewinddir",
    cst_readdir = "readdir",
    cst_opendir = "opendir",
    cst_getcwd = "getcwd",
    cst_chroot = "chroot",
    cst_chdir = "chdir",
    cst_rmdir = "rmdir",
    cst_mkdir = cst_mkdir$1,
    cst_mkdir$0 = cst_mkdir$1,
    cst_access$0 = cst_access$1,
    cst_access = cst_access$1,
    _af_ = [0, 3804260],
    _ag_ = [0, 523273847],
    cst_fchown = "fchown",
    cst_chown = "chown",
    cst_fchmod = "fchmod",
    cst_chmod = "chmod",
    cst_link = "link",
    cst_rename = "rename",
    cst_remove = "remove",
    cst_unlink = "unlink",
    cst_isatty = "isatty",
    cst_lstat = "lstat",
    cst_stat = "stat",
    cst_fstat$0 = cst_fstat$1,
    cst_src_unix_syscalls_ml_Stats = cst_src_unix_syscalls_ml_Stats$0,
    _R_ = [0, cst_ctime$1],
    _S_ = [0, cst_mtime$1],
    _T_ = [0, cst_atime$1],
    _U_ = [0, cst_size$1],
    _V_ = [0, cst_rdev$1],
    _W_ = [0, cst_gid$3],
    _X_ = [0, cst_uid$2],
    _Y_ = [0, cst_nlink$1],
    _Z_ = [0, cst_perm$1],
    ___ = [0, cst_kind$1],
    _$_ = [0, cst_ino$1],
    _aa_ = [0, cst_dev$1],
    cst_ctime = cst_ctime$1,
    cst_mtime = cst_mtime$1,
    cst_atime = cst_atime$1,
    cst_size = cst_size$1,
    cst_rdev = cst_rdev$1,
    cst_gid = cst_gid$3,
    cst_uid = cst_uid$2,
    cst_nlink = cst_nlink$1,
    cst_perm = cst_perm$1,
    cst_kind = cst_kind$1,
    cst_ino = cst_ino$1,
    cst_dev = cst_dev$1,
    cst_fstat = cst_fstat$1,
    _y_ = [0, cst_Link$0],
    _z_ = [0, cst_Directory$0],
    _A_ = [0, cst_File$0],
    _B_ = [0, cst_Fifo$0],
    _D_ = [0, cst_Char$0],
    _E_ = [0, cst_Block$0],
    _C_ = [0, cst_Socket$0],
    _w_ = [0, "mechanism"],
    _x_ = [0, cst_mode],
    _u_ = [0, cst_Flock],
    _v_ = [0, cst_Lockf],
    cst_flock = cst_flock$0,
    _t_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _s_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _r_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _q_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_lockf = cst_lockf$0,
    _o_ = [0, "Exclusive"],
    _p_ = [0, "Shared"],
    cst_sync = "sync",
    cst_fdatasync = "fdatasync",
    cst_fsync = "fsync",
    cst_ftruncate = "ftruncate",
    cst_truncate = "truncate",
    cst_lseek = "lseek",
    cst_fcntl_setfl = "fcntl_setfl",
    cst_fcntl_getfl = "fcntl_getfl",
    _n_ = [0, 13, 0],
    cst_openfile = "openfile",
    _j_ = [0, [11, "0o", [4, 10, 0, 0, 0]], "0o%o"],
    _k_ = [0, cst_perm$1],
    _l_ = [0, cst_mode],
    _m_ = [0, "filename"],
    cst_open = "open",
    cst_Async_Unix_syscalls_openfi =
      "Async.Unix_syscalls.openfile: must provide at least one access flag",
    _g_ = [0, cst_src_unix_syscalls_ml, 82, 18],
    _h_ = [0, cst_src_unix_syscalls_ml, 83, 18],
    _i_ = [0, cst_src_unix_syscalls_ml, 84, 16],
    cst_cores = "cores",
    _a_ = [0, "status"],
    cst_shell_command_failed = "shell command failed",
    cst_system = "system",
    cst_file_perm = cst_file_perm$1,
    cst_src_unix_syscalls_ml_75_0 = "src/unix_syscalls.ml:75:0",
    cst_file_perm$0 = cst_file_perm$1,
    cst_Socket = cst_Socket$0,
    cst_Fifo = cst_Fifo$0,
    cst_Link = cst_Link$0,
    cst_Block = cst_Block$0,
    cst_Char = cst_Char$0,
    cst_Directory = cst_Directory$0,
    cst_File = cst_File$0,
    cst_src_unix_syscalls_ml_341_6 = "src/unix_syscalls.ml:341:6",
    cst_t = cst_t$19,
    cst_src_unix_syscalls_ml_340_4 = "src/unix_syscalls.ml:340:4",
    cst_t$0 = cst_t$19,
    cst_ctime$0 = cst_ctime$1,
    cst_mtime$0 = cst_mtime$1,
    cst_atime$0 = cst_atime$1,
    cst_size$0 = cst_size$1,
    cst_rdev$0 = cst_rdev$1,
    cst_gid$0 = cst_gid$3,
    cst_uid$0 = cst_uid$2,
    cst_nlink$0 = cst_nlink$1,
    cst_perm$0 = cst_perm$1,
    cst_kind$0 = cst_kind$1,
    cst_ino$0 = cst_ino$1,
    cst_dev$0 = cst_dev$1,
    cst_t$1 = cst_t$19,
    cst_src_unix_syscalls_ml_388_2 = "src/unix_syscalls.ml:388:2",
    cst_t$2 = cst_t$19,
    cst_Inet = cst_Inet$1,
    cst_src_unix_syscalls_ml_814_1 = "src/unix_syscalls.ml:814:15",
    cst_t$3 = cst_t$19,
    cst_src_unix_syscalls_ml_814_6 = "src/unix_syscalls.ml:814:6",
    cst_t$4 = cst_t$19,
    cst_Inet$0 = cst_Inet$1,
    cst_src_unix_syscalls_ml_829_1 = "src/unix_syscalls.ml:829:17",
    cst_t$5 = cst_t$19,
    cst_src_unix_syscalls_ml_829_8 = "src/unix_syscalls.ml:829:8",
    cst_t$6 = cst_t$19,
    cst_Unix = cst_Unix$0,
    cst_src_unix_syscalls_ml_858_1 = "src/unix_syscalls.ml:858:15",
    cst_t$7 = cst_t$19,
    cst_src_unix_syscalls_ml_858_6 = "src/unix_syscalls.ml:858:6",
    cst_t$8 = cst_t$19,
    cst_src_unix_syscalls_ml_873_8 = "src/unix_syscalls.ml:873:8",
    cst_src_unix_syscalls_ml_872_8 = "src/unix_syscalls.ml:872:8",
    cst_src_unix_syscalls_ml_872_6 = "src/unix_syscalls.ml:872:6",
    cst_t$9 = cst_t$19,
    cst_src_unix_syscalls_ml_871_4 = "src/unix_syscalls.ml:871:4",
    cst_t$10 = cst_t$19,
    cst_src_unix_syscalls_ml_880_1 = "src/unix_syscalls.ml:880:10",
    cst_src_unix_syscalls_ml_879_1 = "src/unix_syscalls.ml:879:10",
    cst_src_unix_syscalls_ml_879_8 = "src/unix_syscalls.ml:879:8",
    cst_t$11 = cst_t$19,
    cst_src_unix_syscalls_ml_878_6 = "src/unix_syscalls.ml:878:6",
    cst_t$12 = cst_t$19,
    cst_debug = "debug",
    cst_broadcast = "broadcast",
    cst_reuseaddr = "reuseaddr",
    cst_reuseport = "reuseport",
    cst_keepalive = "keepalive",
    cst_dontroute = "dontroute",
    cst_oobinline = "oobinline",
    cst_acceptconn = "acceptconn",
    cst_nodelay = "nodelay",
    cst_sndbuf = "sndbuf",
    cst_rcvbuf = "rcvbuf",
    cst_error = "error",
    cst_typ = "typ",
    cst_rcvlowat = "rcvlowat",
    cst_sndlowat = "sndlowat",
    cst_linger = "linger",
    cst_rcvtimeo = "rcvtimeo",
    cst_sndtimeo = "sndtimeo",
    cst_mcast_loop = "mcast_loop",
    cst_mcast_ttl = "mcast_ttl",
    _bG_ =
      [0,
       [0, cst_PF_UNIX, 0],
       [0, [0, cst_PF_INET, 0], [0, [0, cst_PF_INET6, 0], 0]]],
    cst_socket_domain = cst_socket_domain$1,
    cst_src_unix_syscalls_ml_1366_ = "src/unix_syscalls.ml:1366:0",
    cst_socket_domain$0 = cst_socket_domain$1,
    _bP_ =
      [0,
       [0, cst_SOCK_STREAM, 0],
       [0,
        [0, cst_SOCK_DGRAM, 0],
        [0, [0, cst_SOCK_RAW, 0], [0, [0, cst_SOCK_SEQPACKET, 0], 0]]]],
    cst_socket_type = cst_socket_type$1,
    cst_src_unix_syscalls_ml_1372_ = "src/unix_syscalls.ml:1372:0",
    cst_socket_type$0 = cst_socket_type$1,
    cst_ADDR_INET = cst_ADDR_INET$1,
    cst_ADDR_UNIX = cst_ADDR_UNIX$1,
    cst_sockaddr = cst_sockaddr$1,
    cst_src_unix_syscalls_ml_1379_ = "src/unix_syscalls.ml:1379:0",
    cst_sockaddr$0 = cst_sockaddr$1,
    cst_ADDR_INET$0 = cst_ADDR_INET$1,
    cst_ADDR_UNIX$0 = cst_ADDR_UNIX$1,
    cst_sockaddr_blocking_sexp = cst_sockaddr_blocking_sexp$1,
    cst_src_unix_syscalls_ml_1384_ = "src/unix_syscalls.ml:1384:0",
    cst_sockaddr_blocking_sexp$0 = cst_sockaddr_blocking_sexp$1,
    cst_ai_canonname = cst_ai_canonname$2,
    cst_ai_addr = cst_ai_addr$2,
    cst_ai_protocol = cst_ai_protocol$2,
    cst_ai_socktype = cst_ai_socktype$2,
    cst_ai_family = cst_ai_family$2,
    cst_t$13 = cst_t$19,
    cst_src_unix_syscalls_ml_1390_ = "src/unix_syscalls.ml:1390:2",
    cst_t$14 = cst_t$19,
    cst_ai_canonname$0 = cst_ai_canonname$2,
    cst_ai_addr$0 = cst_ai_addr$2,
    cst_ai_protocol$0 = cst_ai_protocol$2,
    cst_ai_socktype$0 = cst_ai_socktype$2,
    cst_ai_family$0 = cst_ai_family$2,
    cst_t$15 = cst_t$19,
    cst_src_unix_syscalls_ml_1400_ = "src/unix_syscalls.ml:1400:4",
    cst_t$16 = cst_t$19,
    _ct_ =
      [0,
       [0, cst_AI_NUMERICHOST, 0],
       [0, [0, cst_AI_CANONNAME, 0], [0, [0, cst_AI_PASSIVE, 0], 0]]],
    cst_AI_PROTOCOL = cst_AI_PROTOCOL$0,
    cst_AI_SOCKTYPE = cst_AI_SOCKTYPE$0,
    cst_AI_FAMILY = cst_AI_FAMILY$0,
    cst_getaddrinfo_option = cst_getaddrinfo_option$1,
    cst_src_unix_syscalls_ml_1410_ = "src/unix_syscalls.ml:1410:2",
    cst_getaddrinfo_option$0 = cst_getaddrinfo_option$1,
    cst_ni_service = cst_ni_service$1,
    cst_ni_hostname = cst_ni_hostname$1,
    cst_t$17 = cst_t$19,
    cst_src_unix_syscalls_ml_1425_ = "src/unix_syscalls.ml:1425:2",
    cst_t$18 = cst_t$19,
    _cQ_ =
      [0,
       [0, cst_NI_NOFQDN, 0],
       [0,
        [0, cst_NI_NUMERICHOST, 0],
        [0,
         [0, cst_NI_NAMEREQD, 0],
         [0, [0, cst_NI_NUMERICSERV, 0], [0, [0, cst_NI_DGRAM, 0], 0]]]]],
    cst_getnameinfo_option = cst_getnameinfo_option$1,
    cst_src_unix_syscalls_ml_1431_ = "src/unix_syscalls.ml:1431:2",
    cst_getnameinfo_option$0 = cst_getnameinfo_option$1,
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Unix_syscalls = cst_Async_unix_Unix_syscalls$0;
   function system(s){
    function _jK_(param){return caml_call1(Core_unix[33], s);}
    return caml_call2(Async_unix_In_thread[7], cst_system, _jK_);
   }
   function system_exn(s){
    function _jE_(status){
     var _jG_ = 1 - caml_call1(Core_Result[37], status);
     if(! _jG_) return _jG_;
     var
      _jH_ =
        [0, [1, [0, _a_, [0, caml_call1(Core_unix[15][7], status), 0]]], 0],
      _jI_ = [0, caml_call1(Core[558], s), _jH_],
      _jJ_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_shell_command_failed),
          _jI_]];
     return caml_call1(Core[261], _jJ_);
    }
    var _jF_ = system(s);
    return caml_call2(Async_unix_Import[33][3], _jF_, _jE_);
   }
   function getpid(param){return caml_call1(Core_unix[34], 0);}
   function getppid(param){return caml_call1(Core_unix[35], 0);}
   function getppid_exn(param){return caml_call1(Core_unix[36], 0);}
   function this_process_became_child_of_i(opt, param){
    if(opt)
     var sth = opt[1], poll_delay = sth;
    else
     var poll_delay = caml_call1(Core[630], 1.);
    function _jy_(i){
     function _jz_(param){
      var
       _jB_ = Core_Pid[47],
       _jC_ = getppid_exn(0),
       _jD_ = caml_call2(Core_Pid[23], _jC_, _jB_);
      return _jD_ ? caml_call2(Async_kernel_Ivar[14], i, 0) : _jD_;
     }
     var _jA_ = [0, caml_call1(Async_kernel_Ivar[19], i)];
     return caml_call5(Async_unix_Clock[11], 0, _jA_, 0, poll_delay, _jz_);
    }
    return caml_call1(Async_kernel_Deferred[3], _jy_);
   }
   function nice(i){return caml_call1(Core_unix[41], i);}
   function _b_(cores, param){
    return caml_call2(Async_unix_In_thread[7], cst_cores, cores);
   }
   var cores = caml_call2(Core_Or_error[53], Linux_ext[47], _b_);
   function convert_open_flag(param){
    return 654843454 <= param
            ? 771169788
              <= param
              ? 914344045
                <= param
                ? 926475899 <= param ? 10 : 2
                : 913115943 <= param ? 1 : 7
              : 693908748 <= param ? 6 : 0
            : -545248983
              <= param
              ? 54217645
                <= param
                ? 627796288 <= param ? 3 : 11
                : -207672161 <= param ? 9 : 5
              : -619113641 <= param ? 8 : 4;
   }
   var
    file_perm_of_sexp = Core[390],
    sexp_of_file_perm = Core[389],
    _c_ = Core[372],
    _d_ = [0, [0, caml_call1(Bin_shape[2][1], cst_file_perm), 0, _c_], 0],
    _e_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_75_0),
    group = caml_call2(Bin_prot_Shape[2], _e_, _d_),
    _f_ = caml_call1(Bin_shape[2][1], cst_file_perm$0),
    bin_shape_file_perm =
      caml_call1(caml_call2(Bin_prot_Shape[10], group, _f_), 0),
    bin_size_file_perm = Core[373],
    bin_write_file_perm = Core[375],
    bin_read_file_perm = Core[378],
    compare_file_perm = Core[382];
   function convert_to_uring_flags(param){
    switch(param){
      case 0:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      case 1:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      case 2:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
      case 3:
       return Async_unix_Io_uring_raw[5][16];
      case 4:
       return Async_unix_Io_uring_raw[5][5];
      case 5:
       return Async_unix_Io_uring_raw[5][7];
      case 6:
       return Async_unix_Io_uring_raw[5][20];
      case 7:
       return Async_unix_Io_uring_raw[5][11];
      case 8:
       return Async_unix_Io_uring_raw[5][14];
      case 9:
       return Async_unix_Io_uring_raw[5][10];
      case 10:
       return Async_unix_Io_uring_raw[5][18];
      case 11:
       return Async_unix_Io_uring_raw[5][18];
      case 12:
       return Async_unix_Io_uring_raw[5][4];
      case 13:
       return Async_unix_Io_uring_raw[5][6];
      default: return Async_unix_Io_uring_raw[5][4];
    }
   }
   function is_rw_flag(flag){return 3 <= flag ? 0 : 1;}
   function openfile(info, perm$0, file, mode){
    var
     _jl_ = caml_call2(Core_List[51], mode, convert_open_flag),
     unix_mode = caml_call2(Core[156], _jl_, _n_);
    function _jm_(file_descr){
     function _ju_(kind){
      var
       _jw_ = caml_call1(Core_Info[14], file),
       _jx_ = caml_call2(Core_Option[39], info, _jw_);
      return caml_call4(Async_unix_Fd[6], 0, kind, file_descr, _jx_);
     }
     var _jv_ = caml_call1(Async_unix_Fd[1][2], file_descr);
     return caml_call2(Async_unix_Import[33][3], _jv_, _ju_);
    }
    var match$2 = caml_call1(Async_unix_Io_uring_raw_single[1], 0);
    if(match$2){
     var
      uring = match$2[1],
      match$1 = caml_call2(Core_List[15], unix_mode, is_rw_flag),
      flags = match$1[2],
      access = match$1[1],
      _jd_ = function(param){if(1 !== param && 3 > param) return 1; return 0;},
      match = caml_call2(Core_List[27], access, _jd_),
      _je_ = function(param){return 1 < param - 1 >>> 0 ? 0 : 1;},
      match$0 = caml_call2(Core_List[27], access, _je_),
      access$0 =
        match
         ? match$0 ? 18373 : 82
         : match$0 ? 87 : caml_call1(Core[6], cst_Async_Unix_syscalls_openfi),
      _jf_ = Async_unix_Io_uring_raw[5][2],
      _jg_ = Async_unix_Io_uring_raw[5][4],
      _jh_ = caml_call2(Core_List[51], flags, convert_to_uring_flags),
      flags$0 = caml_call3(Core_List[20], _jh_, _jg_, _jf_),
      perm_for_error = caml_call2(Core_Option[39], perm$0, 420);
     a:
     {
      var default_perm = 420;
      if
       (!
        caml_call2
         (Async_unix_Io_uring_raw[5][3],
          Async_unix_Io_uring_raw[5][7],
          flags$0)
        &&
         !
         caml_call2
          (Async_unix_Io_uring_raw[5][3],
           Async_unix_Io_uring_raw[5][19],
           flags$0)){
       var default_perm$0 = 0;
       break a;
      }
      var default_perm$0 = default_perm;
     }
     var
      perm = caml_call2(Core_Option[39], perm$0, default_perm$0),
      _ji_ =
        function(param){
         if(0 === param[0]){
          var res = param[1];
          return caml_call1(Core_unix_File_descr[13], res);
         }
         var
          err = param[1],
          _jp_ = caml_call2(Core_Printf[2], _j_, perm_for_error),
          _jq_ = [0, [1, [0, _k_, [0, caml_call1(Core[558], _jp_), 0]]], 0],
          _jr_ =
            [0,
             [1,
              [0,
               _l_,
               [0, caml_call2(Core[472], Core_unix[46], unix_mode), 0]]],
             _jq_],
          _js_ =
            [1, [0, [1, [0, _m_, [0, caml_call1(Core[558], file), 0]]], _jr_]],
          _jt_ = caml_call1(Core_unix[10][1], _js_);
         throw caml_maybe_attach_backtrace
                ([0, Core_unix[4], err, cst_open, _jt_], 0);
        },
      _jj_ =
        caml_call7
         (Async_unix_Io_uring_raw[22],
          uring,
          access$0,
          flags$0,
          perm,
          Async_unix_Io_uring_raw[6][4],
          0,
          file),
      _jk_ = caml_call1(Async_unix_Io_uring_raw[29], _jj_),
      _jn_ = caml_call2(Async_unix_Import[33][3], _jk_, _ji_);
    }
    else
     var
      _jo_ =
        function(param){
         return caml_call3(Core_unix[49], perm$0, unix_mode, file);
        },
      _jn_ = caml_call2(Async_unix_In_thread[7], cst_openfile, _jo_);
    return caml_call2(Async_unix_Import[33][2], _jn_, _jm_);
   }
   function fcntl_getfl(fd){
    function _jc_(file_descr){return caml_call1(Core_unix[51], file_descr);}
    return caml_call3(Async_unix_Fd[35], fd, cst_fcntl_getfl, _jc_);
   }
   function fcntl_setfl(fd, flags){
    function _jb_(file_descr){
     return caml_call2(Core_unix[52], file_descr, flags);
    }
    return caml_call3(Async_unix_Fd[35], fd, cst_fcntl_setfl, _jb_);
   }
   function lseek(fd, pos, mode){
    var mode$0 = 3455931 === mode ? 2 : 4150146 <= mode ? 0 : 1;
    function _ja_(file_descr){
     return caml_call3(Core_unix[66], file_descr, pos, mode$0);
    }
    return caml_call3(Async_unix_Fd[35], fd, cst_lseek, _ja_);
   }
   function truncate(filename, len){
    function _i$_(param){return caml_call2(Core_unix[67], filename, len);}
    return caml_call2(Async_unix_In_thread[7], cst_truncate, _i$_);
   }
   function ftruncate(fd, len){
    function _i__(file_descr){
     return caml_call2(Core_unix[68], file_descr, len);
    }
    return caml_call3(Async_unix_Fd[35], fd, cst_ftruncate, _i__);
   }
   function fsync(fd){
    return caml_call3(Async_unix_Fd[35], fd, cst_fsync, Core_unix[279]);
   }
   function fdatasync(fd){
    return caml_call3(Async_unix_Fd[35], fd, cst_fdatasync, Core_unix[280]);
   }
   function sync(param){
    return caml_call2(Async_unix_In_thread[7], cst_sync, Core_unix[278]);
   }
   function sexp_of_t(param){return param ? _o_ : _p_;}
   function flock_command(param){
    return param ? Core_unix[80][2] : Core_unix[80][1];
   }
   function lockf(opt, fd, lock_mode){
    if(opt) var sth = opt[1], len = sth; else var len = _q_;
    var mode = lock_mode ? 1 : 4;
    function _i9_(file_descr){
     return caml_call3(Core_unix[79], file_descr, mode, len);
    }
    return caml_call3(Async_unix_Fd[35], fd, cst_lockf, _i9_);
   }
   function try_lockf(opt, fd, lock_mode){
    if(opt) var sth = opt[1], len = sth; else var len = _r_;
    var mode = lock_mode ? 2 : 5;
    function _i4_(file_descr){
     try{
      caml_call3(Core_unix[79], file_descr, mode, len);
      var _i7_ = 1;
      return _i7_;
     }
     catch(_i8_){
      var _i5_ = caml_wrap_exception(_i8_);
      if(_i5_[1] === Unix_error){
       var _i6_ = _i5_[2];
       if(typeof _i6_ === "number" && 1 >= _i6_ - 1 >>> 0) return 0;
      }
      throw caml_maybe_attach_backtrace(_i5_, 0);
     }
    }
    return caml_call3(Async_unix_Fd[32], 0, fd, _i4_);
   }
   function test_lockf(opt, fd){
    if(opt) var sth = opt[1], len = sth; else var len = _s_;
    function _iZ_(file_descr){
     try{
      caml_call3(Core_unix[79], file_descr, 3, len);
      var _i2_ = 1;
      return _i2_;
     }
     catch(_i3_){
      var _i0_ = caml_wrap_exception(_i3_);
      if(_i0_[1] === Unix_error){
       var _i1_ = _i0_[2];
       if(typeof _i1_ === "number" && 1 >= _i1_ - 1 >>> 0) return 0;
      }
      throw caml_maybe_attach_backtrace(_i0_, 0);
     }
    }
    return caml_call3(Async_unix_Fd[32], 0, fd, _iZ_);
   }
   function unlockf(opt, fd){
    if(opt) var sth = opt[1], len = sth; else var len = _t_;
    function _iY_(file_descr){
     return caml_call3(Core_unix[79], file_descr, 0, len);
    }
    return caml_call3(Async_unix_Fd[32], 0, fd, _iY_);
   }
   function flock(fd, lock_mode){
    var mode = flock_command(lock_mode);
    function _iX_(file_descr){
     return caml_call2(Core_unix[82], file_descr, mode);
    }
    return caml_call3(Async_unix_Fd[35], fd, cst_flock, _iX_);
   }
   function try_flock(fd, lock_mode){
    var mode = flock_command(lock_mode);
    function _iW_(file_descr){
     return caml_call2(Core_unix[81], file_descr, mode);
    }
    return caml_call3(Async_unix_Fd[32], 0, fd, _iW_);
   }
   function funlock(fd){
    function _iV_(file_descr){
     caml_call2(Core_unix[81], file_descr, Core_unix[80][3]);
     return 0;
    }
    return caml_call3(Async_unix_Fd[32], 0, fd, _iV_);
   }
   var compare = caml_int_compare;
   function t_of_sexp(sexp_013){
    a:
    {
     if(0 === sexp_013[0]){
      var _iR_ = sexp_013[1];
      b:
      if(caml_string_notequal(_iR_, cst_Flock)){
       if(caml_string_notequal(_iR_, cst_Lockf)){
        if(! caml_string_notequal(_iR_, cst_flock$0)) break b;
        if(caml_string_notequal(_iR_, cst_lockf$0)) break a;
       }
       return 0;
      }
      return 1;
     }
     var _iS_ = sexp_013[1];
     if(! _iS_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_012, sexp_013);
     var _iT_ = _iS_[1];
     if(0 !== _iT_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_012, sexp_013);
     var _iU_ = _iT_[1];
     b:
     if(caml_string_notequal(_iU_, cst_Flock)){
      if(caml_string_notequal(_iU_, cst_Lockf)){
       if(! caml_string_notequal(_iU_, cst_flock$0)) break b;
       if(caml_string_notequal(_iU_, cst_lockf$0)) break a;
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_012, sexp_013);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_012, sexp_013);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_012, sexp_013);
   }
   function sexp_of_t$0(param){return param ? _u_ : _v_;}
   var
    include$0 = caml_call1(Core_Sexpable[1], [0, t_of_sexp, sexp_of_t$0]),
    of_string = include$0[1],
    to_string = include$0[2],
    arg_type = caml_call2(Core_Command_internal[19][11][7], 0, t_of_sexp);
   function sexp_of_t$1(param){
    var
     mechanism_017 = param[2],
     mode_015 = param[1],
     arg_018 = sexp_of_t$0(mechanism_017),
     bnds_014 = [0, [1, [0, _w_, [0, arg_018, 0]]], 0],
     arg_016 = sexp_of_t(mode_015),
     bnds_014$0 = [0, [1, [0, _x_, [0, arg_016, 0]]], bnds_014];
    return [1, bnds_014$0];
   }
   var Lock = [0, sexp_of_t$1];
   function with_file(lock, perm, file, mode, f){
    function doit(f){
     function _iP_(fd){return caml_call2(Async_unix_Fd[17], fd, f);}
     var _iQ_ = openfile(0, perm, file, mode);
     return caml_call2(Async_unix_Import[33][2], _iQ_, _iP_);
    }
    if(! lock) return doit(f);
    var match = lock[1], mechanism = match[2], mode$0 = match[1];
    return doit
            (function(fd){
              function _iK_(param){return caml_call1(f, fd);}
              if(mechanism)
               var _iM_ = flock;
              else
               var
                _iJ_ = 0,
                _iM_ = function(_iN_, _iO_){return lockf(_iJ_, _iN_, _iO_);};
              var _iL_ = _iM_(fd, mode$0);
              return caml_call2(Async_unix_Import[33][2], _iL_, _iK_);
             });
   }
   function compare$0(a_021, b_022){
    if(a_021 === b_022) return 0;
    if(781514092 <= a_021){
     if(840421965 <= a_021){
      if(848053274 <= a_021){
       if(typeof b_022 === "number" && 848053274 === b_022) return 0;
      }
      else if(typeof b_022 === "number" && 840421965 === b_022) return 0;
     }
     else
      if(781515420 <= a_021){
       if(typeof b_022 === "number" && 781515420 === b_022) return 0;
      }
      else if(typeof b_022 === "number" && 781514092 === b_022) return 0;
    }
    else
     if(-623181869 === a_021){
      if(typeof b_022 === "number" && -623181869 === b_022) return 0;
     }
     else
      if(748194550 <= a_021){
       if(typeof b_022 === "number" && 748194550 === b_022) return 0;
      }
      else if(typeof b_022 === "number" && -936778451 === b_022) return 0;
    return caml_int_compare(a_021, b_022);
   }
   function t_of_sexp$0(sexp_026){
    if(0 === sexp_026[0]){
     var atom_024 = sexp_026[1];
     return caml_string_notequal(atom_024, cst_Block$0)
             ? caml_string_notequal
                (atom_024, cst_Char$0)
               ? caml_string_notequal
                  (atom_024, cst_Directory$0)
                 ? caml_string_notequal
                    (atom_024, cst_Fifo$0)
                   ? caml_string_notequal
                      (atom_024, cst_File$0)
                     ? caml_string_notequal
                        (atom_024, cst_Link$0)
                       ? caml_string_notequal
                          (atom_024, cst_Socket$0)
                         ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
                         : -623181869
                       : 848053274
                     : 781515420
                   : 781514092
                 : 840421965
               : 748194550
             : -936778451;
    }
    var _iI_ = sexp_026[1];
    if(! _iI_)
     return caml_call2
             (Sexplib0_Sexp_conv_error[29], error_source_028, sexp_026);
    var match = _iI_[1];
    if(0 !== match[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[28], error_source_028, sexp_026);
    var atom_024$0 = match[1];
    return caml_string_notequal(atom_024$0, cst_Block$0)
            ? caml_string_notequal
               (atom_024$0, cst_Char$0)
              ? caml_string_notequal
                 (atom_024$0, cst_Directory$0)
                ? caml_string_notequal
                   (atom_024$0, cst_Fifo$0)
                  ? caml_string_notequal
                     (atom_024$0, cst_File$0)
                    ? caml_string_notequal
                       (atom_024$0, cst_Link$0)
                      ? caml_string_notequal
                         (atom_024$0, cst_Socket$0)
                        ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
                        : caml_call2
                          (Sexplib0_Sexp_conv_error[25], error_source_028, sexp_026)
                      : caml_call2
                        (Sexplib0_Sexp_conv_error[25], error_source_028, sexp_026)
                    : caml_call2
                      (Sexplib0_Sexp_conv_error[25], error_source_028, sexp_026)
                  : caml_call2
                    (Sexplib0_Sexp_conv_error[25], error_source_028, sexp_026)
                : caml_call2
                  (Sexplib0_Sexp_conv_error[25], error_source_028, sexp_026)
              : caml_call2
                (Sexplib0_Sexp_conv_error[25], error_source_028, sexp_026)
            : caml_call2
              (Sexplib0_Sexp_conv_error[25], error_source_028, sexp_026);
   }
   function t_of_sexp$1(sexp_029){
    try{var _iG_ = t_of_sexp$0(sexp_029); return _iG_;}
    catch(_iH_){
     var _iF_ = caml_wrap_exception(_iH_);
     if(_iF_ === Sexplib0_Sexp_conv_error[22])
      return caml_call2
              (Sexplib0_Sexp_conv_error[24], error_source_030, sexp_029);
     throw caml_maybe_attach_backtrace(_iF_, 0);
    }
   }
   function sexp_of_t$2(param){
    return 781514092 <= param
            ? 840421965
              <= param
              ? 848053274 <= param ? _y_ : _z_
              : 781515420 <= param ? _A_ : _B_
            : -623181869 === param ? _C_ : 748194550 <= param ? _D_ : _E_;
   }
   var
    _F_ = [0, caml_call2(Bin_prot_Shape[6], cst_Socket, 0), 0],
    _G_ = [0, caml_call2(Bin_prot_Shape[6], cst_Fifo, 0), _F_],
    _H_ = [0, caml_call2(Bin_prot_Shape[6], cst_Link, 0), _G_],
    _I_ = [0, caml_call2(Bin_prot_Shape[6], cst_Block, 0), _H_],
    _J_ = [0, caml_call2(Bin_prot_Shape[6], cst_Char, 0), _I_],
    _K_ = [0, caml_call2(Bin_prot_Shape[6], cst_Directory, 0), _J_],
    _L_ = [0, caml_call2(Bin_prot_Shape[6], cst_File, 0), _K_],
    _M_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_341_6),
    _N_ = caml_call2(Bin_prot_Shape[8], _M_, _L_),
    _O_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, _N_], 0],
    _P_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_340_4),
    group$0 = caml_call2(Bin_prot_Shape[2], _P_, _O_),
    _Q_ = caml_call1(Bin_shape[2][1], cst_t$0),
    bin_shape_t = caml_call1(caml_call2(Bin_prot_Shape[10], group$0, _Q_), 0),
    include$1 =
      caml_call1
       (Core_Comparable[12], [0, compare$0, t_of_sexp$1, sexp_of_t$2]),
    symbol = include$1[1],
    symbol$0 = include$1[2],
    symbol$1 = include$1[3],
    symbol$2 = include$1[4],
    symbol$3 = include$1[5],
    symbol$4 = include$1[6],
    equal = include$1[7],
    compare$1 = include$1[8],
    min = include$1[9],
    max = include$1[10],
    ascending = include$1[11],
    descending = include$1[12],
    between = include$1[13],
    clamp_exn = include$1[14],
    clamp = include$1[15],
    comparator = include$1[16],
    validate_lbound = include$1[17],
    validate_ubound = include$1[18],
    validate_bound = include$1[19],
    Replace_polymorphic_compare = include$1[20],
    Map = include$1[21],
    Set = include$1[22];
   function of_unix(param){
    switch(param){
      case 0:
       return 781515420;
      case 1:
       return 840421965;
      case 2:
       return 748194550;
      case 3:
       return -936778451;
      case 4:
       return 848053274;
      case 5:
       return 781514092;
      default: return -623181869;
    }
   }
   function to_unix(param){
    return 781514092 <= param
            ? 840421965
              <= param
              ? 848053274 <= param ? 4 : 1
              : 781515420 <= param ? 0 : 5
            : -623181869 === param ? 6 : 748194550 <= param ? 2 : 3;
   }
   function ctime(r){return r[12];}
   function mtime(r){return r[11];}
   function atime(r){return r[10];}
   function size(r){return r[9];}
   function rdev(r){return r[8];}
   function gid(r){return r[7];}
   function uid(r){return r[6];}
   function nlink(r){return r[5];}
   function perm(r){return r[4];}
   function kind(r){return r[3];}
   function ino(r){return r[2];}
   function dev(r){return r[1];}
   function t_of_sexp$2(x_033){
    function _is_(param){
     var
      _iv_ = param[2],
      _iw_ = _iv_[2],
      _ix_ = _iw_[2],
      _iy_ = _ix_[2],
      _iz_ = _iy_[2],
      _iA_ = _iz_[2],
      _iB_ = _iA_[2],
      _iC_ = _iB_[2],
      _iD_ = _iC_[2],
      _iE_ = _iD_[2],
      ctime = _iE_[2][1],
      mtime = _iE_[1],
      atime = _iD_[1],
      size = _iC_[1],
      rdev = _iB_[1],
      gid = _iA_[1],
      uid = _iz_[1],
      nlink = _iy_[1],
      perm = _ix_[1],
      kind = _iw_[1],
      ino = _iv_[1],
      dev = param[1];
     return [0,
             dev,
             ino,
             kind,
             perm,
             nlink,
             uid,
             gid,
             rdev,
             size,
             atime,
             mtime,
             ctime];
    }
    var _it_ = 0;
    function _iu_(param){
     var switch$0 = caml_string_compare(param, cst_mtime$1);
     if(0 <= switch$0){
      if(0 >= switch$0) return 10;
      if(! caml_string_notequal(param, cst_nlink$1)) return 4;
      if(! caml_string_notequal(param, cst_perm$1)) return 3;
      if(! caml_string_notequal(param, cst_rdev$1)) return 7;
      if(! caml_string_notequal(param, cst_size$1)) return 8;
      if(! caml_string_notequal(param, cst_uid$2)) return 5;
     }
     else{
      if(! caml_string_notequal(param, cst_atime$1)) return 9;
      if(! caml_string_notequal(param, cst_ctime$1)) return 11;
      if(! caml_string_notequal(param, cst_dev$1)) return 0;
      if(! caml_string_notequal(param, cst_gid$3)) return 6;
      if(! caml_string_notequal(param, cst_ino$1)) return 1;
      if(! caml_string_notequal(param, cst_kind$1)) return 2;
     }
     return -1;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_032,
             [0,
              cst_dev,
              1,
              Core[390],
              [0,
               cst_ino,
               1,
               Core[390],
               [0,
                cst_kind,
                1,
                t_of_sexp$1,
                [0,
                 cst_perm,
                 1,
                 file_perm_of_sexp,
                 [0,
                  cst_nlink,
                  1,
                  Core[390],
                  [0,
                   cst_uid,
                   1,
                   Core[390],
                   [0,
                    cst_gid,
                    1,
                    Core[390],
                    [0,
                     cst_rdev,
                     1,
                     Core[390],
                     [0,
                      cst_size,
                      1,
                      Core[434],
                      [0,
                       cst_atime,
                       1,
                       Time_float_unix[59],
                       [0,
                        cst_mtime,
                        1,
                        Time_float_unix[59],
                        [0, cst_ctime, 1, Time_float_unix[59], 0]]]]]]]]]]]],
             _iu_,
             _it_,
             _is_,
             x_033);
   }
   function sexp_of_t$3(param){
    var
     ctime_057 = param[12],
     mtime_055 = param[11],
     atime_053 = param[10],
     size_051 = param[9],
     rdev_049 = param[8],
     gid_047 = param[7],
     uid_045 = param[6],
     nlink_043 = param[5],
     perm_041 = param[4],
     kind_039 = param[3],
     ino_037 = param[2],
     dev_035 = param[1],
     arg_058 = caml_call1(Time_float_unix[60], ctime_057),
     bnds_034 = [0, [1, [0, _R_, [0, arg_058, 0]]], 0],
     arg_056 = caml_call1(Time_float_unix[60], mtime_055),
     bnds_034$0 = [0, [1, [0, _S_, [0, arg_056, 0]]], bnds_034],
     arg_054 = caml_call1(Time_float_unix[60], atime_053),
     bnds_034$1 = [0, [1, [0, _T_, [0, arg_054, 0]]], bnds_034$0],
     arg_052 = caml_call1(Core[433], size_051),
     bnds_034$2 = [0, [1, [0, _U_, [0, arg_052, 0]]], bnds_034$1],
     arg_050 = caml_call1(Core[389], rdev_049),
     bnds_034$3 = [0, [1, [0, _V_, [0, arg_050, 0]]], bnds_034$2],
     arg_048 = caml_call1(Core[389], gid_047),
     bnds_034$4 = [0, [1, [0, _W_, [0, arg_048, 0]]], bnds_034$3],
     arg_046 = caml_call1(Core[389], uid_045),
     bnds_034$5 = [0, [1, [0, _X_, [0, arg_046, 0]]], bnds_034$4],
     arg_044 = caml_call1(Core[389], nlink_043),
     bnds_034$6 = [0, [1, [0, _Y_, [0, arg_044, 0]]], bnds_034$5],
     arg_042 = caml_call1(sexp_of_file_perm, perm_041),
     bnds_034$7 = [0, [1, [0, _Z_, [0, arg_042, 0]]], bnds_034$6],
     arg_040 = sexp_of_t$2(kind_039),
     bnds_034$8 = [0, [1, [0, ___, [0, arg_040, 0]]], bnds_034$7],
     arg_038 = caml_call1(Core[389], ino_037),
     bnds_034$9 = [0, [1, [0, _$_, [0, arg_038, 0]]], bnds_034$8],
     arg_036 = caml_call1(Core[389], dev_035),
     bnds_034$10 = [0, [1, [0, _aa_, [0, arg_036, 0]]], bnds_034$9];
    return [1, bnds_034$10];
   }
   var
    _ab_ =
      caml_call1
       (Bin_prot_Shape[4],
        [0,
         [0, cst_dev$0, Core[372]],
         [0,
          [0, cst_ino$0, Core[372]],
          [0,
           [0, cst_kind$0, bin_shape_t],
           [0,
            [0, cst_perm$0, bin_shape_file_perm],
            [0,
             [0, cst_nlink$0, Core[372]],
             [0,
              [0, cst_uid$0, Core[372]],
              [0,
               [0, cst_gid$0, Core[372]],
               [0,
                [0, cst_rdev$0, Core[372]],
                [0,
                 [0, cst_size$0, Core[416]],
                 [0,
                  [0, cst_atime$0, Time_float_unix[55]],
                  [0,
                   [0, cst_mtime$0, Time_float_unix[55]],
                   [0, [0, cst_ctime$0, Time_float_unix[55]], 0]]]]]]]]]]]]),
    _ac_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$1), 0, _ab_], 0],
    _ad_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_388_2),
    group$1 = caml_call2(Bin_prot_Shape[2], _ad_, _ac_),
    _ae_ = caml_call1(Bin_shape[2][1], cst_t$2),
    bin_shape_t$0 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$1, _ae_), 0);
   function bin_size_t(param){
    var
     v12 = param[12],
     v11 = param[11],
     v10 = param[10],
     v9 = param[9],
     v8 = param[8],
     v7 = param[7],
     v6 = param[6],
     v5 = param[5],
     v4 = param[4],
     v2 = param[2],
     v1 = param[1],
     _ih_ = caml_call1(Core[373], v1),
     size = caml_call2(Bin_prot_Common[23], 0, _ih_),
     _ii_ = caml_call1(Core[373], v2),
     size$0 = caml_call2(Bin_prot_Common[23], size, _ii_),
     size$1 = caml_call2(Bin_prot_Common[23], size$0, 4),
     _ij_ = caml_call1(bin_size_file_perm, v4),
     size$2 = caml_call2(Bin_prot_Common[23], size$1, _ij_),
     _ik_ = caml_call1(Core[373], v5),
     size$3 = caml_call2(Bin_prot_Common[23], size$2, _ik_),
     _il_ = caml_call1(Core[373], v6),
     size$4 = caml_call2(Bin_prot_Common[23], size$3, _il_),
     _im_ = caml_call1(Core[373], v7),
     size$5 = caml_call2(Bin_prot_Common[23], size$4, _im_),
     _in_ = caml_call1(Core[373], v8),
     size$6 = caml_call2(Bin_prot_Common[23], size$5, _in_),
     _io_ = caml_call1(Core[417], v9),
     size$7 = caml_call2(Bin_prot_Common[23], size$6, _io_),
     _ip_ = caml_call1(Time_float_unix[51], v10),
     size$8 = caml_call2(Bin_prot_Common[23], size$7, _ip_),
     _iq_ = caml_call1(Time_float_unix[51], v11),
     size$9 = caml_call2(Bin_prot_Common[23], size$8, _iq_),
     _ir_ = caml_call1(Time_float_unix[51], v12);
    return caml_call2(Bin_prot_Common[23], size$9, _ir_);
   }
   function bin_write_t(buf, pos, param){
    var
     v12 = param[12],
     v11 = param[11],
     v10 = param[10],
     v9 = param[9],
     v8 = param[8],
     v7 = param[7],
     v6 = param[6],
     v5 = param[5],
     v4 = param[4],
     v3 = param[3],
     v2 = param[2],
     v1 = param[1],
     pos$0 = caml_call3(Core[375], buf, pos, v1),
     pos$1 = caml_call3(Core[375], buf, pos$0, v2),
     pos$2 =
       781514092 <= v3
        ? 840421965
          <= v3
          ? 848053274
            <= v3
            ? caml_call3(Bin_prot_Write[29], buf, pos$1, 848053274)
            : caml_call3(Bin_prot_Write[29], buf, pos$1, 840421965)
          : 781515420
            <= v3
            ? caml_call3(Bin_prot_Write[29], buf, pos$1, 781515420)
            : caml_call3(Bin_prot_Write[29], buf, pos$1, 781514092)
        : -623181869
          === v3
          ? caml_call3(Bin_prot_Write[29], buf, pos$1, -623181869)
          : 748194550
            <= v3
            ? caml_call3(Bin_prot_Write[29], buf, pos$1, 748194550)
            : caml_call3(Bin_prot_Write[29], buf, pos$1, -936778451),
     pos$3 = caml_call3(bin_write_file_perm, buf, pos$2, v4),
     pos$4 = caml_call3(Core[375], buf, pos$3, v5),
     pos$5 = caml_call3(Core[375], buf, pos$4, v6),
     pos$6 = caml_call3(Core[375], buf, pos$5, v7),
     pos$7 = caml_call3(Core[375], buf, pos$6, v8),
     pos$8 = caml_call3(Core[419], buf, pos$7, v9),
     pos$9 = caml_call3(Time_float_unix[52], buf, pos$8, v10),
     pos$10 = caml_call3(Time_float_unix[52], buf, pos$9, v11);
    return caml_call3(Time_float_unix[52], buf, pos$10, v12);
   }
   var bin_writer_t = [0, bin_size_t, bin_write_t];
   function bin_read_t(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19], cst_src_unix_syscalls_ml_Stats, pos_ref[1]);
   }
   function bin_read_t$0(buf, pos_ref){
    var
     v_dev = caml_call2(Core[378], buf, pos_ref),
     v_ino = caml_call2(Core[378], buf, pos_ref),
     vint = caml_call2(Bin_prot_Read[28], buf, pos_ref);
    try{
     a:
     {
      if(781514092 <= vint)
       if(840421965 <= vint){
        if(848053274 === vint){var _if_ = 848053274; break a;}
        if(840421966 > vint){var _if_ = 840421965; break a;}
       }
       else{
        if(781515420 === vint){var _if_ = 781515420; break a;}
        if(781514093 > vint){var _if_ = 781514092; break a;}
       }
      else{
       if(-936778451 === vint){var _if_ = -936778451; break a;}
       if(-623181869 === vint){var _if_ = -623181869; break a;}
       if(748194550 === vint){var _if_ = 748194550; break a;}
      }
      throw caml_maybe_attach_backtrace(Bin_prot_Common[13], 0);
     }
     var v_kind = _if_;
    }
    catch(_ig_){
     var _ie_ = caml_wrap_exception(_ig_);
     if(_ie_ !== Bin_prot_Common[13])
      throw caml_maybe_attach_backtrace(_ie_, 0);
     var v_kind = caml_call2(Bin_prot_Common[18], err, pos_ref[1]);
    }
    var
     v_perm = caml_call2(bin_read_file_perm, buf, pos_ref),
     v_nlink = caml_call2(Core[378], buf, pos_ref),
     v_uid = caml_call2(Core[378], buf, pos_ref),
     v_gid = caml_call2(Core[378], buf, pos_ref),
     v_rdev = caml_call2(Core[378], buf, pos_ref),
     v_size = caml_call2(Core[422], buf, pos_ref),
     v_atime = caml_call2(Time_float_unix[53], buf, pos_ref),
     v_mtime = caml_call2(Time_float_unix[53], buf, pos_ref),
     v_ctime = caml_call2(Time_float_unix[53], buf, pos_ref);
    return [0,
            v_dev,
            v_ino,
            v_kind,
            v_perm,
            v_nlink,
            v_uid,
            v_gid,
            v_rdev,
            v_size,
            v_atime,
            v_mtime,
            v_ctime];
   }
   var
    bin_reader_t = [0, bin_read_t$0, bin_read_t],
    bin_t = [0, bin_shape_t$0, bin_writer_t, bin_reader_t];
   function compare$2(a_059, b_060){
    if(a_059 === b_060) return 0;
    var n = caml_call2(Core[382], a_059[1], b_060[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Core[382], a_059[2], b_060[2]);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(compare$1, a_059[3], b_060[3]);
    if(0 !== n$1) return n$1;
    var n$2 = caml_call2(compare_file_perm, a_059[4], b_060[4]);
    if(0 !== n$2) return n$2;
    var n$3 = caml_call2(Core[382], a_059[5], b_060[5]);
    if(0 !== n$3) return n$3;
    var n$4 = caml_call2(Core[382], a_059[6], b_060[6]);
    if(0 !== n$4) return n$4;
    var n$5 = caml_call2(Core[382], a_059[7], b_060[7]);
    if(0 !== n$5) return n$5;
    var n$6 = caml_call2(Core[382], a_059[8], b_060[8]);
    if(0 !== n$6) return n$6;
    var n$7 = caml_call2(Core[426], a_059[9], b_060[9]);
    if(0 !== n$7) return n$7;
    var n$8 = caml_call2(Time_float_unix[71], a_059[10], b_060[10]);
    if(0 !== n$8) return n$8;
    var n$9 = caml_call2(Time_float_unix[71], a_059[11], b_060[11]);
    return 0 === n$9
            ? caml_call2(Time_float_unix[71], a_059[12], b_060[12])
            : n$9;
   }
   function of_unix$0(u){
    function of_float_sec(f){
     var _id_ = caml_call1(Time_float_unix[1][82], f);
     return caml_call1(Time_float_unix[11], _id_);
    }
    var
     _h5_ = of_float_sec(u[12]),
     _h6_ = of_float_sec(u[11]),
     _h7_ = of_float_sec(u[10]),
     _h8_ = u[9],
     _h9_ = u[8],
     _h__ = u[7],
     _h$_ = u[6],
     _ia_ = u[5],
     _ib_ = u[4],
     _ic_ = of_unix(u[3]);
    return [0,
            u[1],
            u[2],
            _ic_,
            _ib_,
            _ia_,
            _h$_,
            _h__,
            _h9_,
            _h8_,
            _h7_,
            _h6_,
            _h5_];
   }
   function to_unix$0(u){
    function to_float_sec(f){
     var _h4_ = caml_call1(Time_float_unix[10], f);
     return caml_call1(Time_float_unix[1][89], _h4_);
    }
    var
     _hU_ = to_float_sec(u[12]),
     _hV_ = to_float_sec(u[11]),
     _hW_ = to_float_sec(u[10]),
     _hX_ = u[9],
     _hY_ = u[8],
     _hZ_ = u[7],
     _h0_ = u[6],
     _h1_ = u[5],
     _h2_ = u[4],
     _h3_ = to_unix(u[3]);
    return [0,
            u[1],
            u[2],
            _h3_,
            _h2_,
            _h1_,
            _h0_,
            _hZ_,
            _hY_,
            _hX_,
            _hW_,
            _hV_,
            _hU_];
   }
   function of_ocaml_uring_statx(u){
    function of_timespec(sec, nsec){
     var
      _hR_ = caml_call1(Time_float_unix[1][93], nsec),
      _hS_ = caml_call1(Time_float_unix[1][96], sec),
      _hT_ = caml_call2(Time_float_unix[1][104], _hS_, _hR_);
     return caml_call1(Time_float_unix[11], _hT_);
    }
    var
     _hu_ = caml_call1(Async_unix_Io_uring_raw[4][26], u),
     _hv_ = caml_call1(Async_unix_Io_uring_raw[4][22], u),
     _hw_ = of_timespec(caml_call1(Core_Int64[6], _hv_), _hu_),
     _hx_ = caml_call1(Async_unix_Io_uring_raw[4][27], u),
     _hy_ = caml_call1(Async_unix_Io_uring_raw[4][23], u),
     _hz_ = of_timespec(caml_call1(Core_Int64[6], _hy_), _hx_),
     _hA_ = caml_call1(Async_unix_Io_uring_raw[4][24], u),
     _hB_ = caml_call1(Async_unix_Io_uring_raw[4][20], u),
     _hC_ = of_timespec(caml_call1(Core_Int64[6], _hB_), _hA_),
     _hD_ = caml_call1(Async_unix_Io_uring_raw[4][11], u),
     _hE_ = caml_call1(Async_unix_Io_uring_raw[4][14], u),
     _hF_ = caml_call1(Core_Int64[6], _hE_),
     _hG_ = caml_call1(Async_unix_Io_uring_raw[4][9], u),
     _hH_ = caml_call1(Core_Int64[6], _hG_),
     _hI_ = caml_call1(Async_unix_Io_uring_raw[4][8], u),
     _hJ_ = caml_call1(Core_Int64[6], _hI_),
     _hK_ = caml_call1(Async_unix_Io_uring_raw[4][7], u),
     _hL_ = caml_call1(Core_Int64[6], _hK_),
     _hM_ = caml_call1(Async_unix_Io_uring_raw[4][29], u),
     param = caml_call1(Async_unix_Io_uring_raw[4][30], u);
    if(465753759 <= param)
     if(785140586 <= param){
      if(840421965 > param)
       throw caml_maybe_attach_backtrace
              ([0, Core_unix[4], 12, cst_fstat, cst], 0);
      var _hN_ = 840421965;
     }
     else
      var _hN_ = 781514092 <= param ? 781514092 : 781515420;
    else
     var
      _hN_ =
        -74006461 <= param
         ? 215595176 <= param ? -936778451 : 748194550
         : -495690425 <= param ? 848053274 : -623181869;
    var
     _hO_ = caml_call1(Async_unix_Io_uring_raw[4][10], u),
     _hP_ = caml_call1(Core_Int64[6], _hO_),
     _hQ_ = caml_call1(Async_unix_Io_uring_raw[4][15], u);
    return [0,
            caml_call1(Core_Int64[6], _hQ_),
            _hP_,
            _hN_,
            _hM_,
            _hL_,
            _hJ_,
            _hH_,
            _hF_,
            _hD_,
            _hC_,
            _hz_,
            _hw_];
   }
   function to_string$0(t){
    var _ht_ = sexp_of_t$3(t);
    return caml_call1(Core_Sexp[86], _ht_);
   }
   function fstat(fd){
    var match = caml_call1(Async_unix_Io_uring_raw_single[1], 0);
    if(match){
     var
      uring = match[1],
      _hq_ =
        function(res){
         return of_ocaml_uring_statx(caml_call1(Core_Result[40], res));
        },
      _hr_ = caml_call3(Async_unix_Io_uring[15], uring, 0, fd);
     return caml_call2(Async_unix_Import[32], _hr_, _hq_);
    }
    var _hs_ = caml_call3(Async_unix_Fd[35], fd, cst_fstat$0, Core_unix[75]);
    return caml_call2(Async_unix_Import[32], _hs_, of_unix$0);
   }
   function stat(filename){
    var match = caml_call1(Async_unix_Io_uring_raw_single[1], 0);
    if(match){
     var
      uring = match[1],
      _hm_ =
        function(res){
         return of_ocaml_uring_statx(caml_call1(Core_Result[40], res));
        },
      _hn_ = caml_call3(Async_unix_Io_uring[14], uring, 0, filename);
     return caml_call2(Async_unix_Import[32], _hn_, _hm_);
    }
    function _ho_(param){return caml_call1(Core_unix[73], filename);}
    var _hp_ = caml_call2(Async_unix_In_thread[7], cst_stat, _ho_);
    return caml_call2(Async_unix_Import[32], _hp_, of_unix$0);
   }
   function lstat(filename){
    var match = caml_call1(Async_unix_Io_uring_raw_single[1], 0);
    if(match){
     var
      uring = match[1],
      _hi_ =
        function(res){
         return of_ocaml_uring_statx(caml_call1(Core_Result[40], res));
        },
      _hj_ = caml_call3(Async_unix_Io_uring[16], uring, 0, filename);
     return caml_call2(Async_unix_Import[32], _hj_, _hi_);
    }
    function _hk_(param){return caml_call1(Core_unix[74], filename);}
    var _hl_ = caml_call2(Async_unix_In_thread[7], cst_lstat, _hk_);
    return caml_call2(Async_unix_Import[32], _hl_, of_unix$0);
   }
   function isatty(fd){
    return caml_call3(Async_unix_Fd[35], fd, cst_isatty, Core_unix[83]);
   }
   function unlink(filename){
    var match = caml_call1(Async_unix_Io_uring_raw_single[1], 0);
    if(match){
     var
      uring = match[1],
      _hf_ = Core_Result[40],
      _hg_ = caml_call4(Async_unix_Io_uring[11], uring, 0, 0, filename);
     return caml_call2(Async_unix_Import[32], _hg_, _hf_);
    }
    function _hh_(param){return caml_call1(Core_unix[85], filename);}
    return caml_call2(Async_unix_In_thread[7], cst_unlink, _hh_);
   }
   function remove(filename){
    function _he_(param){return caml_call1(Core_unix[86], filename);}
    return caml_call2(Async_unix_In_thread[7], cst_remove, _he_);
   }
   function rename(src, dst){
    function _hd_(param){return caml_call2(Core_unix[87], src, dst);}
    return caml_call2(Async_unix_In_thread[7], cst_rename, _hd_);
   }
   function link(force, target, link_name, param){
    var match = caml_call1(Async_unix_Io_uring_raw_single[1], 0);
    if(match){
     var
      uring = match[1],
      _ha_ = Core_Result[40],
      _hb_ =
        caml_call6
         (Async_unix_Io_uring[12], uring, 0, force, target, link_name, 0);
     return caml_call2(Async_unix_Import[32], _hb_, _ha_);
    }
    function _hc_(param){
     return caml_call4(Core_unix[88], force, target, link_name, 0);
    }
    return caml_call2(Async_unix_In_thread[7], cst_link, _hc_);
   }
   function chmod(filename, perm){
    function _g$_(param){return caml_call2(Core_unix[89], filename, perm);}
    return caml_call2(Async_unix_In_thread[7], cst_chmod, _g$_);
   }
   function fchmod(fd, perm){
    function _g__(file_descr){
     return caml_call2(Core_unix[90], file_descr, perm);
    }
    return caml_call3(Async_unix_Fd[35], fd, cst_fchmod, _g__);
   }
   function chown(filename, uid, gid){
    function _g9_(param){
     return caml_call3(Core_unix[91], filename, uid, gid);
    }
    return caml_call2(Async_unix_In_thread[7], cst_chown, _g9_);
   }
   function fchown(fd, uid, gid){
    function _g8_(file_descr){
     return caml_call3(Core_unix[92], file_descr, uid, gid);
    }
    return caml_call3(Async_unix_Fd[35], fd, cst_fchown, _g8_);
   }
   function access(filename, perm){
    function _g4_(param){
     if(0 === param[0]){var res = param[1]; return res;}
     var exn = param[1];
     return [1, caml_call1(Async_kernel_Monitor[13], exn)];
    }
    function _g5_(param){
     function _g7_(param){return caml_call2(Core_unix[94], filename, perm);}
     return caml_call2(Async_unix_In_thread[7], cst_access, _g7_);
    }
    var
     _g6_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _ag_, _af_, _g5_);
    return caml_call2(Async_unix_Import[33][3], _g6_, _g4_);
   }
   function access_exn(filename, perm){
    function _g3_(param){return caml_call2(Core_unix[95], filename, perm);}
    return caml_call2(Async_unix_In_thread[7], cst_access$0, _g3_);
   }
   function set_close_on_exec(fd){
    return caml_call3(Async_unix_Fd[23], 0, fd, Core_unix[100]);
   }
   function clear_close_on_exec(fd){
    return caml_call3(Async_unix_Fd[23], 0, fd, Core_unix[102]);
   }
   function mkdir(p, opt, dirname){
    if(opt) var sth = opt[1], perm = sth; else var perm = 511;
    if(p){
     var
      _g1_ =
        function(param){
         return caml_call2(Core_unix[104], [0, perm], dirname);
        };
     return caml_call2(Async_unix_In_thread[7], cst_mkdir, _g1_);
    }
    function _g2_(param){
     return caml_call2(Core_unix[103], [0, perm], dirname);
    }
    return caml_call2(Async_unix_In_thread[7], cst_mkdir$0, _g2_);
   }
   function rmdir(dirname){
    function _g0_(param){return caml_call1(Core_unix[105], dirname);}
    return caml_call2(Async_unix_In_thread[7], cst_rmdir, _g0_);
   }
   function chdir(dirname){
    function _gZ_(param){return caml_call1(Core_unix[106], dirname);}
    return caml_call2(Async_unix_In_thread[7], cst_chdir, _gZ_);
   }
   function chroot(dirname){
    function _gY_(param){return caml_call1(Core_unix[108], dirname);}
    return caml_call2(Async_unix_In_thread[7], cst_chroot, _gY_);
   }
   function getcwd(param){
    function _gX_(param){return caml_call1(Core_unix[107], 0);}
    return caml_call2(Async_unix_In_thread[7], cst_getcwd, _gX_);
   }
   function opendir(dirname){
    function _gW_(param){return caml_call2(Core_unix[109], 0, dirname);}
    return caml_call2(Async_unix_In_thread[7], cst_opendir, _gW_);
   }
   function readdir_opt(handle){
    function _gV_(param){return caml_call1(Core_unix[110], handle);}
    return caml_call2(Async_unix_In_thread[7], cst_readdir, _gV_);
   }
   function rewinddir(handle){
    function _gU_(param){return caml_call1(Core_unix[112], handle);}
    return caml_call2(Async_unix_In_thread[7], cst_rewinddir, _gU_);
   }
   function closedir(handle){
    function _gT_(param){return caml_call1(Core_unix[113], handle);}
    return caml_call2(Async_unix_In_thread[7], cst_closedir, _gT_);
   }
   function pipe(info){
    function _gO_(param){
     var writer = param[2], reader = param[1];
     function create(file_descr, kind){
      var _gS_ = caml_call2(Core_Info[22], info, kind);
      return caml_call4(Async_unix_Fd[6], 0, 1, file_descr, _gS_);
     }
     var _gR_ = [0, 846875347, create(writer, cst_writer)];
     return [0, [0, 824580451, create(reader, cst_reader)], _gR_];
    }
    function _gP_(param){return caml_call2(Core_unix[117], _ah_, 0);}
    var _gQ_ = caml_call2(Async_unix_In_thread[7], cst_pipe, _gP_);
    return caml_call2(Async_unix_Import[33][3], _gQ_, _gO_);
   }
   function mkfifo(opt, name){
    if(opt) var sth = opt[1], perm = sth; else var perm = 438;
    function _gN_(param){return caml_call2(Core_unix[118], name, perm);}
    return caml_call2(Async_unix_In_thread[7], cst_mkfifo, _gN_);
   }
   function symlink(target, link_name){
    function _gM_(param){
     return caml_call2(Core_unix[134], target, link_name);
    }
    return caml_call2(Async_unix_In_thread[7], cst_symlink, _gM_);
   }
   function readlink(filename){
    function _gL_(param){return caml_call1(Core_unix[135], filename);}
    return caml_call2(Async_unix_In_thread[7], cst_readlink, _gL_);
   }
   function mkdtemp(filename){
    function _gK_(param){return caml_call1(Core_unix[294], filename);}
    return caml_call2(Async_unix_In_thread[7], cst_mkdtemp, _gK_);
   }
   function mkstemp(filename){
    function _gG_(param){
     var
      file_descr = param[2],
      name = param[1],
      _gJ_ = caml_call1(Core_Info[14], name);
     return [0, name, caml_call4(Async_unix_Fd[6], 0, 2, file_descr, _gJ_)];
    }
    function _gH_(param){return caml_call1(Core_unix[293], filename);}
    var _gI_ = caml_call2(Async_unix_In_thread[7], cst_mkstemp, _gH_);
    return caml_call2(Async_unix_Import[33][3], _gI_, _gG_);
   }
   function getgrouplist(username, gid){
    function _gF_(param){return caml_call2(Core_unix[297], username, gid);}
    return caml_call2(Async_unix_In_thread[7], cst_getgrouplist, _gF_);
   }
   var
    times = Core_unix[156],
    time = Core_unix[145],
    gettimeofday = Core_unix[146],
    gmtime = Core_unix[147],
    localtime = Core_unix[149],
    mktime = Core_unix[150];
   function utimes(name, access, modif){
    function _gE_(param){
     return caml_call3(Core_unix[157], name, access, modif);
    }
    return caml_call2(Async_unix_In_thread[7], cst_utimes, _gE_);
   }
   var
    env_of_sexp = Core_unix[19],
    sexp_of_env = Core_unix[18],
    environment = Core_unix[11],
    getenv = Core_Core_sys[19],
    getenv_exn = Core_Core_sys[20],
    unsafe_getenv = Sys_unix[10],
    unsafe_getenv_exn = Sys_unix[11],
    putenv = Core_unix[12],
    unsetenv = Core_unix[13];
   function fork_exec(prog, argv, use_path, env, param){
    function _gD_(param){
     return caml_call6(Core_unix[22], prog, argv, 0, use_path, env, 0);
    }
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _gD_);
   }
   var wait_on_of_sexp = Core_unix[26];
   function wait_on_of_sexp$0(sexp_064){
    try{var _gB_ = caml_call1(wait_on_of_sexp, sexp_064); return _gB_;}
    catch(_gC_){
     var _gA_ = caml_wrap_exception(_gC_);
     if(_gA_ === Sexplib0_Sexp_conv_error[22])
      return caml_call2
              (Sexplib0_Sexp_conv_error[24], error_source_065, sexp_064);
     throw caml_maybe_attach_backtrace(_gA_, 0);
    }
   }
   var
    sexp_of_wait_on = Core_unix[24],
    wait_nohang = Core_unix[28],
    wait_nohang_untraced = Core_unix[30];
   function wait_nohang$0(t, wait_on){
    switch(t){
      case 0:
       return caml_call1(wait_nohang, wait_on);
      case 1:
       return caml_call1(wait_nohang_untraced, wait_on);
      default:
       var res = caml_call1(wait_nohang, [0, 4001835, wait_on]);
       if(! res) return 0;
       var match = res[1], exit_or_signal = match[2], pid2 = match[1];
       if(caml_call2(Core_Pid[19], pid2, wait_on)) return [0, exit_or_signal];
       throw caml_maybe_attach_backtrace([0, Assert_failure, _ai_], 1);
    }
   }
   function check(t){
    try{var val = wait_nohang$0(t[1], t[4]);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     caml_call3(Async_kernel_Monitor[15], t[2], 0, exn);
     return 1;
    }
    if(! val) return 0;
    var x = val[1];
    caml_call2(Async_kernel_Ivar[14], t[3], x);
    return 1;
   }
   var waits = [0, 0];
   function check_all(param){
    var _gz_ = caml_call1(Core_Fn[2], check);
    waits[1] = caml_call2(Core_List[12], waits[1], _gz_);
    return 0;
   }
   var should_handle_sigchld = [0, 1], am_handling_sigchld = [0, 0];
   function do_not_handle_sigchld(param){
    if(am_handling_sigchld[1]){
     var
      _gx_ =
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_src_unix_syscalls_ml_735_7),
         0],
      _gy_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_already_handling_SIGCHLD),
          _gx_]];
     caml_call1(Core[261], _gy_);
    }
    should_handle_sigchld[1] = 0;
    return 0;
   }
   var
    install_sigchld_handler_the_fi =
      [246,
       function(_gr_){
        var _gs_ = should_handle_sigchld[1];
        if(! _gs_) return _gs_;
        am_handling_sigchld[1] = 1;
        function _gt_(param){
         function _gw_(param){return check_all(0);}
         return caml_call3
                 (Async_unix_Signal[89], 0, [0, Core_Signal[52], 0], _gw_);
        }
        var
         _gu_ = Async_kernel_Execution_context[7],
         _gv_ = caml_call1(Async_kernel_Scheduler[2], 0);
        return caml_call2
                (caml_call1(Async_kernel_Scheduler[5], _gv_), _gu_, _gt_);
       }];
   function deferred_wait(wait_on, kind){
    var _gp_ = runtime.caml_obj_tag(install_sigchld_handler_the_fi);
    a:
    if(250 !== _gp_){
     if(246 !== _gp_ && 244 !== _gp_) break a;
     caml_call1(CamlinternalLazy[2], install_sigchld_handler_the_fi);
    }
    var match = wait_nohang$0(kind, wait_on);
    if(match){
     var result = match[1];
     return caml_call1(Async_unix_Import[30], result);
    }
    function _gq_(result){
     var monitor = caml_call1(Async_kernel_Monitor[5], 0);
     waits[1] = [0, [0, kind, monitor, result, wait_on], waits[1]];
     return 0;
    }
    return caml_call1(Async_kernel_Deferred[3], _gq_);
   }
   function wait(wait_on){return deferred_wait(wait_on, 0);}
   function wait_untraced(wait_on){return deferred_wait(wait_on, 1);}
   function waitpid_prompt(pid){return deferred_wait(pid, 2);}
   function waitpid_exn(pid){
    function _gj_(exit_or_signal){
     var _gl_ = caml_call1(Core_Result[38], exit_or_signal);
     if(! _gl_) return _gl_;
     var
      _gm_ =
        [0,
         [1, [0, _aj_, [0, caml_call1(Core_unix[15][7], exit_or_signal), 0]]],
         0],
      _gn_ = [0, [1, [0, _ak_, [0, caml_call1(Core_Pid[13], pid), 0]]], _gm_],
      _go_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_child_process_didn_t_exit_),
          _gn_]];
     return caml_call1(Core[261], _go_);
    }
    var _gk_ = waitpid_prompt(pid);
    return caml_call2(Async_unix_Import[33][3], _gk_, _gj_);
   }
   function dns_lookup(name, f){
    function _gh_(t){
     function _gi_(param){
      return caml_call4(Async_unix_In_thread[5], 0, 0, [0, name], f);
     }
     return caml_call2(Async_kernel_Throttle[10], t[19], _gi_);
    }
    return caml_call1(Async_unix_Raw_scheduler[153], _gh_);
   }
   var
    include$2 = Core_unix[175],
    bin_size_t$0 = include$2[1],
    bin_write_t$0 = include$2[2],
    bin_read_t$1 = include$2[3],
    bin_read_t$2 = include$2[4],
    bin_shape_t$1 = include$2[5],
    bin_writer_t$0 = include$2[6],
    bin_reader_t$0 = include$2[7],
    bin_t$0 = include$2[8],
    hash_fold_t = include$2[9],
    hash = include$2[10],
    sexp_of_t$4 = include$2[11],
    arg_type$0 = include$2[12],
    t_of_sexp$3 = include$2[13],
    Blocking_sexp = include$2[14],
    symbol$5 = include$2[15],
    symbol$6 = include$2[16],
    symbol$7 = include$2[17],
    symbol$8 = include$2[18],
    symbol$9 = include$2[19],
    symbol$10 = include$2[20],
    equal$0 = include$2[21],
    compare$3 = include$2[22],
    min$0 = include$2[23],
    max$0 = include$2[24],
    ascending$0 = include$2[25],
    descending$0 = include$2[26],
    between$0 = include$2[27],
    clamp_exn$0 = include$2[28],
    clamp$0 = include$2[29],
    comparator$0 = include$2[30],
    validate_lbound$0 = include$2[31],
    validate_ubound$0 = include$2[32],
    validate_bound$0 = include$2[33],
    of_string$0 = include$2[37],
    to_string$1 = include$2[39],
    bind_any = include$2[40],
    bind_any_inet6 = include$2[41],
    localhost = include$2[42],
    localhost_inet6 = include$2[43],
    inet4_addr_of_int32 = include$2[44],
    inet4_addr_to_int32_exn = include$2[45],
    inet4_addr_of_int63 = include$2[46],
    inet4_addr_to_int63_exn = include$2[47],
    _al_ = include$2[38];
   function of_string_or_getbyname(s){
    try{var t = caml_call1(of_string$0, s);}
    catch(_gg_){
     return dns_lookup
             (cst_getbyname, function(param){return caml_call1(_al_, s);});
    }
    return caml_call1(Async_kernel_Deferred[12], t);
   }
   function _am_(bind_to_interface, fd, spec){
    function _gf_(file_descr){
     return caml_call2(bind_to_interface, file_descr, spec);
    }
    return caml_call3(Async_unix_Fd[23], 0, fd, _gf_);
   }
   var
    bind_to_interface_exn = caml_call2(Core_Or_error[53], Linux_ext[58], _am_),
    _an_ =
      [0,
       caml_call1(Bin_prot_Shape[3], [0, bin_shape_t$1, [0, Core[372], 0]])],
    _ao_ = [0, caml_call2(Bin_prot_Shape[6], cst_Inet, _an_), 0],
    _ap_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_814_1),
    _aq_ = caml_call2(Bin_prot_Shape[8], _ap_, _ao_),
    _ar_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$3), 0, _aq_], 0],
    _as_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_814_6),
    group$2 = caml_call2(Bin_prot_Shape[2], _as_, _ar_),
    _at_ = caml_call1(Bin_shape[2][1], cst_t$4),
    bin_shape_t$2 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$2, _at_), 0);
   function bin_size_t$1(param){
    var
     args = param[2],
     v2 = args[2],
     v1 = args[1],
     _gd_ = caml_call1(bin_size_t$0, v1),
     size = caml_call2(Bin_prot_Common[23], 0, _gd_),
     _ge_ = caml_call1(Core[373], v2),
     size_args = caml_call2(Bin_prot_Common[23], size, _ge_);
    return caml_call2(Bin_prot_Common[23], size_args, 4);
   }
   function bin_write_t$1(buf, pos, param){
    var
     args = param[2],
     pos$0 = caml_call3(Bin_prot_Write[29], buf, pos, 815031220),
     v2 = args[2],
     v1 = args[1],
     pos$1 = caml_call3(bin_write_t$0, buf, pos$0, v1);
    return caml_call3(Core[375], buf, pos$1, v2);
   }
   var bin_writer_t$1 = [0, bin_size_t$1, bin_write_t$1];
   function bin_read_t$3(buf, pos_ref, vint){
    if(815031220 !== vint)
     throw caml_maybe_attach_backtrace(Bin_prot_Common[13], 0);
    var
     v1 = caml_call2(bin_read_t$1, buf, pos_ref),
     v2 = caml_call2(Core[378], buf, pos_ref),
     arg_1 = [0, v1, v2];
    return [0, 815031220, arg_1];
   }
   function bin_read_t$4(buf, pos_ref){
    var vint = caml_call2(Bin_prot_Read[28], buf, pos_ref);
    try{var _gb_ = bin_read_t$3(buf, pos_ref, vint); return _gb_;}
    catch(_gc_){
     var _ga_ = caml_wrap_exception(_gc_);
     if(_ga_ === Bin_prot_Common[13])
      return caml_call2(Bin_prot_Common[18], err$0, pos_ref[1]);
     throw caml_maybe_attach_backtrace(_ga_, 0);
    }
   }
   var
    bin_reader_t$1 = [0, bin_read_t$4, bin_read_t$3],
    bin_t$1 = [0, bin_shape_t$2, bin_writer_t$1, bin_reader_t$1];
   function compare$4(a_082, b_083){
    if(a_082 === b_083) return 0;
    var
     right_085 = b_083[2],
     left_084 = a_082[2],
     t_087 = left_084[2],
     t_086 = left_084[1],
     t_089 = right_085[2],
     t_088 = right_085[1],
     n = caml_call2(compare$3, t_086, t_088);
    return 0 === n ? caml_call2(Core[382], t_087, t_089) : n;
   }
   function hash_fold_t$0(hsv, arg){
    var
     v = arg[2],
     hsv$0 = caml_call2(Base_Hash[3], hsv, 815031220),
     e1 = v[2],
     e0 = v[1],
     hsv$1 = caml_call2(hash_fold_t, hsv$0, e0),
     hsv$2 = caml_call2(Core[387], hsv$1, e1);
    return hsv$2;
   }
   function hash$0(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _f$_ = hash_fold_t$0(hsv, arg);
    return caml_call1(Base_Hash[9], _f$_);
   }
   function to_string_internal(show_port_in_test, param){
    var match = param[2], p = match[2], a = match[1];
    a:
    {
     if(Ppx_inline_test_lib[1] && ! show_port_in_test){var _f9_ = cst_PORT; break a;}
     var _f9_ = caml_call1(Core_Int[79], p);
    }
    var _f__ = caml_call1(to_string$1, a);
    return caml_call3(Core[265], _au_, _f__, _f9_);
   }
   var _av_ = 0;
   function to_string$2(_f8_){return to_string_internal(_av_, _f8_);}
   function sexp_of_t$5(t){return [0, to_string$2(t)];}
   var
    _aw_ =
      [0,
       caml_call1(Bin_prot_Shape[3], [0, Blocking_sexp[5], [0, Core[372], 0]])],
    _ax_ = [0, caml_call2(Bin_prot_Shape[6], cst_Inet$0, _aw_), 0],
    _ay_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_829_1),
    _az_ = caml_call2(Bin_prot_Shape[8], _ay_, _ax_),
    _aA_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$5), 0, _az_], 0],
    _aB_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_829_8),
    group$3 = caml_call2(Bin_prot_Shape[2], _aB_, _aA_),
    _aC_ = caml_call1(Bin_shape[2][1], cst_t$6),
    bin_shape_t$3 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$3, _aC_), 0);
   function bin_size_t$2(param){
    var
     args = param[2],
     v2 = args[2],
     v1 = args[1],
     _f6_ = caml_call1(Blocking_sexp[1], v1),
     size = caml_call2(Bin_prot_Common[23], 0, _f6_),
     _f7_ = caml_call1(Core[373], v2),
     size_args = caml_call2(Bin_prot_Common[23], size, _f7_);
    return caml_call2(Bin_prot_Common[23], size_args, 4);
   }
   function bin_write_t$2(buf, pos, param){
    var
     args = param[2],
     pos$0 = caml_call3(Bin_prot_Write[29], buf, pos, 815031220),
     v2 = args[2],
     v1 = args[1],
     pos$1 = caml_call3(Blocking_sexp[2], buf, pos$0, v1);
    return caml_call3(Core[375], buf, pos$1, v2);
   }
   var bin_writer_t$2 = [0, bin_size_t$2, bin_write_t$2];
   function bin_read_t$5(buf, pos_ref, vint){
    if(815031220 !== vint)
     throw caml_maybe_attach_backtrace(Bin_prot_Common[13], 0);
    var
     v1 = caml_call2(Blocking_sexp[3], buf, pos_ref),
     v2 = caml_call2(Core[378], buf, pos_ref),
     arg_1 = [0, v1, v2];
    return [0, 815031220, arg_1];
   }
   function bin_read_t$6(buf, pos_ref){
    var vint = caml_call2(Bin_prot_Read[28], buf, pos_ref);
    try{var _f4_ = bin_read_t$5(buf, pos_ref, vint); return _f4_;}
    catch(_f5_){
     var _f3_ = caml_wrap_exception(_f5_);
     if(_f3_ === Bin_prot_Common[13])
      return caml_call2(Bin_prot_Common[18], err$1, pos_ref[1]);
     throw caml_maybe_attach_backtrace(_f3_, 0);
    }
   }
   var
    bin_reader_t$2 = [0, bin_read_t$6, bin_read_t$5],
    bin_t$2 = [0, bin_shape_t$3, bin_writer_t$2, bin_reader_t$2];
   function compare$5(a_090, b_091){
    if(a_090 === b_091) return 0;
    var
     right_093 = b_091[2],
     left_092 = a_090[2],
     t_095 = left_092[2],
     t_094 = left_092[1],
     t_097 = right_093[2],
     t_096 = right_093[1],
     n = caml_call2(Blocking_sexp[9], t_094, t_096);
    return 0 === n ? caml_call2(Core[382], t_095, t_097) : n;
   }
   function hash_fold_t$1(hsv, arg){
    var
     v = arg[2],
     hsv$0 = caml_call2(Base_Hash[3], hsv, 815031220),
     e1 = v[2],
     e0 = v[1],
     hsv$1 = caml_call2(Blocking_sexp[10], hsv$0, e0),
     hsv$2 = caml_call2(Core[387], hsv$1, e1);
    return hsv$2;
   }
   function hash$1(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _f2_ = hash_fold_t$1(hsv, arg);
    return caml_call1(Base_Hash[9], _f2_);
   }
   function t_of_sexp$4(sexp_101){
    if(0 === sexp_101[0]){
     var atom_099 = sexp_101[1];
     return caml_string_notequal(atom_099, cst_Inet$1)
             ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
             : caml_call2
               (Sexplib0_Sexp_conv_error[27], error_source_109, sexp_101);
    }
    var _fZ_ = sexp_101[1];
    if(! _fZ_)
     return caml_call2
             (Sexplib0_Sexp_conv_error[29], error_source_109, sexp_101);
    var match = _fZ_[1];
    if(0 !== match[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[28], error_source_109, sexp_101);
    var sexp_args_102 = _fZ_[2], atom_099$0 = match[1];
    if(caml_string_notequal(atom_099$0, cst_Inet$1))
     return caml_call1(Sexplib0_Sexp_conv_error[23], 0);
    if(sexp_args_102 && ! sexp_args_102[2]){
     var arg0_110 = sexp_args_102[1];
     a:
     {
      if(1 === arg0_110[0]){
       var _f0_ = arg0_110[1];
       if(_f0_){
        var _f1_ = _f0_[2];
        if(_f1_ && ! _f1_[2]){
         var
          arg1_105 = _f1_[1],
          arg0_104 = _f0_[1],
          res0_106 = caml_call1(Blocking_sexp[12], arg0_104),
          res1_107 = caml_call1(Core[390], arg1_105),
          res0_111 = [0, res0_106, res1_107];
         break a;
        }
       }
      }
      var
       res0_111 =
         caml_call3
          (Sexplib0_Sexp_conv_error[4], error_source_109, 2, arg0_110);
     }
     return [0, 815031220, res0_111];
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[26],
             error_source_109,
             atom_099$0,
             sexp_101);
   }
   function t_of_sexp$5(sexp_112){
    try{var _fX_ = t_of_sexp$4(sexp_112); return _fX_;}
    catch(_fY_){
     var _fW_ = caml_wrap_exception(_fY_);
     if(_fW_ === Sexplib0_Sexp_conv_error[22])
      return caml_call2
              (Sexplib0_Sexp_conv_error[24], error_source_113, sexp_112);
     throw caml_maybe_attach_backtrace(_fW_, 0);
    }
   }
   function sexp_of_t$6(param){
    var
     v_114 = param[2],
     arg1_116 = v_114[2],
     arg0_115 = v_114[1],
     res0_117 = caml_call1(Blocking_sexp[13], arg0_115),
     res1_118 = caml_call1(Core[389], arg1_116);
    return [1, [0, _aD_, [0, [1, [0, res0_117, [0, res1_118, 0]]], 0]]];
   }
   function sexp_of_t$7(param){
    var
     v_119 = param[2],
     arg1_121 = v_119[2],
     arg0_120 = v_119[1],
     res0_122 = caml_call1(sexp_of_t$4, arg0_120),
     res1_123 = caml_call1(Core[389], arg1_121);
    return [1, [0, _aE_, [0, [1, [0, res0_122, [0, res1_123, 0]]], 0]]];
   }
   var _aF_ = 1;
   function to_string$3(_fV_){return to_string_internal(_aF_, _fV_);}
   var Show_port_in_test = [0, sexp_of_t$7, to_string$3];
   function addr(param){var a = param[2][1]; return a;}
   function port(param){var p = param[2][2]; return p;}
   function to_host_and_port(param){
    var
     match = param[2],
     port = match[2],
     addr = match[1],
     _fU_ = caml_call1(to_string$1, addr);
    return caml_call2(Core_Host_and_port[1], _fU_, port);
   }
   function create(a, port){return [0, 815031220, [0, a, port]];}
   function create_bind_any(port){
    return [0, 815031220, [0, caml_call1(of_string$0, cst_0_0_0_0), port]];
   }
   function of_sockaddr_exn(u){
    if(0 === u[0]){
     var
      _fS_ = [0, caml_call1(Core_unix[206], u), 0],
      _fT_ =
        [1,
         [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Socket_Address_inet), _fS_]];
     return caml_call1(Core[261], _fT_);
    }
    var i = u[2], a = u[1];
    return [0, 815031220, [0, a, i]];
   }
   function to_sockaddr(param){
    var match = param[2], i = match[2], a = match[1];
    return [1, a, i];
   }
   var
    _aG_ = [0, caml_call2(Bin_prot_Shape[6], cst_Unix, [0, Core[541]]), 0],
    _aH_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_858_1),
    _aI_ = caml_call2(Bin_prot_Shape[8], _aH_, _aG_),
    _aJ_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$7), 0, _aI_], 0],
    _aK_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_858_6),
    group$4 = caml_call2(Bin_prot_Shape[2], _aK_, _aJ_),
    _aL_ = caml_call1(Bin_shape[2][1], cst_t$8),
    bin_shape_t$4 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$4, _aL_), 0);
   function bin_size_t$3(param){
    var args = param[2], size_args = caml_call1(Core[542], args);
    return caml_call2(Bin_prot_Common[23], size_args, 4);
   }
   function bin_write_t$3(buf, pos, param){
    var
     args = param[2],
     pos$0 = caml_call3(Bin_prot_Write[29], buf, pos, 948106920);
    return caml_call3(Core[544], buf, pos$0, args);
   }
   var bin_writer_t$3 = [0, bin_size_t$3, bin_write_t$3];
   function bin_read_t$7(buf, pos_ref, vint){
    if(948106920 !== vint)
     throw caml_maybe_attach_backtrace(Bin_prot_Common[13], 0);
    var arg_1 = caml_call2(Core[547], buf, pos_ref);
    return [0, 948106920, arg_1];
   }
   function bin_read_t$8(buf, pos_ref){
    var vint = caml_call2(Bin_prot_Read[28], buf, pos_ref);
    try{var _fQ_ = bin_read_t$7(buf, pos_ref, vint); return _fQ_;}
    catch(_fR_){
     var _fP_ = caml_wrap_exception(_fR_);
     if(_fP_ === Bin_prot_Common[13])
      return caml_call2(Bin_prot_Common[18], err$2, pos_ref[1]);
     throw caml_maybe_attach_backtrace(_fP_, 0);
    }
   }
   var
    bin_reader_t$3 = [0, bin_read_t$8, bin_read_t$7],
    bin_t$3 = [0, bin_shape_t$4, bin_writer_t$3, bin_reader_t$3];
   function compare$6(a_124, b_125){
    if(a_124 === b_125) return 0;
    var right_127 = b_125[2], left_126 = a_124[2];
    return caml_call2(Core[551], left_126, right_127);
   }
   function t_of_sexp$6(sexp_131){
    if(0 === sexp_131[0]){
     var atom_129 = sexp_131[1];
     return caml_string_notequal(atom_129, cst_Unix$0)
             ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
             : caml_call2
               (Sexplib0_Sexp_conv_error[27], error_source_136, sexp_131);
    }
    var _fO_ = sexp_131[1];
    if(! _fO_)
     return caml_call2
             (Sexplib0_Sexp_conv_error[29], error_source_136, sexp_131);
    var match = _fO_[1];
    if(0 !== match[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[28], error_source_136, sexp_131);
    var sexp_args_132 = _fO_[2], atom_129$0 = match[1];
    if(caml_string_notequal(atom_129$0, cst_Unix$0))
     return caml_call1(Sexplib0_Sexp_conv_error[23], 0);
    if(sexp_args_132 && ! sexp_args_132[2]){
     var
      arg0_134 = sexp_args_132[1],
      res0_135 = caml_call1(Core[559], arg0_134);
     return [0, 948106920, res0_135];
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[26],
             error_source_136,
             atom_129$0,
             sexp_131);
   }
   function t_of_sexp$7(sexp_137){
    try{var _fM_ = t_of_sexp$6(sexp_137); return _fM_;}
    catch(_fN_){
     var _fL_ = caml_wrap_exception(_fN_);
     if(_fL_ === Sexplib0_Sexp_conv_error[22])
      return caml_call2
              (Sexplib0_Sexp_conv_error[24], error_source_138, sexp_137);
     throw caml_maybe_attach_backtrace(_fL_, 0);
    }
   }
   function sexp_of_t$8(param){
    var v_139 = param[2];
    return [1, [0, _aM_, [0, caml_call1(Core[558], v_139), 0]]];
   }
   function create$0(s){return [0, 948106920, s];}
   function to_string$4(param){var s = param[2]; return s;}
   function of_sockaddr_exn$0(u){
    if(0 === u[0]){var s = u[1]; return [0, 948106920, s];}
    var
     _fJ_ = [0, caml_call1(Core_unix[206], u), 0],
     _fK_ =
       [1,
        [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Socket_Address_unix), _fJ_]];
    return caml_call1(Core[261], _fK_);
   }
   function to_sockaddr$0(param){var s = param[2]; return [0, s];}
   var
    _aN_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_873_8),
    _aO_ = [0, caml_call2(Bin_prot_Shape[7], _aN_, bin_shape_t$4), 0],
    _aP_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_872_8),
    _aQ_ = [0, caml_call2(Bin_prot_Shape[7], _aP_, bin_shape_t$2), _aO_],
    _aR_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_872_6),
    _aS_ = caml_call2(Bin_prot_Shape[8], _aR_, _aQ_),
    _aT_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$9), 0, _aS_], 0],
    _aU_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_871_4),
    group$5 = caml_call2(Bin_prot_Shape[2], _aU_, _aT_),
    _aV_ = caml_call1(Bin_shape[2][1], cst_t$10),
    bin_shape_t$5 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$5, _aV_), 0);
   function bin_size_t$4(v){
    return 948106920 <= v[1] ? bin_size_t$3(v) : bin_size_t$1(v);
   }
   function bin_write_t$4(buf, pos, v){
    return 948106920 <= v[1]
            ? bin_write_t$3(buf, pos, v)
            : bin_write_t$1(buf, pos, v);
   }
   var bin_writer_t$4 = [0, bin_size_t$4, bin_write_t$4];
   function bin_read_t$9(buf, pos_ref, vint){
    try{var _fH_ = bin_read_t$3(buf, pos_ref, vint); return _fH_;}
    catch(_fI_){
     var _fG_ = caml_wrap_exception(_fI_);
     if(_fG_ === Bin_prot_Common[13]) return bin_read_t$7(buf, pos_ref, vint);
     throw caml_maybe_attach_backtrace(_fG_, 0);
    }
   }
   function bin_read_t$10(buf, pos_ref){
    var vint = caml_call2(Bin_prot_Read[28], buf, pos_ref);
    try{var _fE_ = bin_read_t$9(buf, pos_ref, vint); return _fE_;}
    catch(_fF_){
     var _fD_ = caml_wrap_exception(_fF_);
     if(_fD_ === Bin_prot_Common[13])
      return caml_call2(Bin_prot_Common[18], err$3, pos_ref[1]);
     throw caml_maybe_attach_backtrace(_fD_, 0);
    }
   }
   var
    bin_reader_t$4 = [0, bin_read_t$10, bin_read_t$9],
    bin_t$4 = [0, bin_shape_t$5, bin_writer_t$4, bin_reader_t$4];
   function sexp_of_t$9(v_140){
    return 948106920 <= v_140[1] ? sexp_of_t$8(v_140) : sexp_of_t$5(v_140);
   }
   var
    _aW_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_880_1),
    _aX_ = [0, caml_call2(Bin_prot_Shape[7], _aW_, bin_shape_t$4), 0],
    _aY_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_879_1),
    _aZ_ = [0, caml_call2(Bin_prot_Shape[7], _aY_, bin_shape_t$3), _aX_],
    _a0_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_879_8),
    _a1_ = caml_call2(Bin_prot_Shape[8], _a0_, _aZ_),
    _a2_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$11), 0, _a1_], 0],
    _a3_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_878_6),
    group$6 = caml_call2(Bin_prot_Shape[2], _a3_, _a2_),
    _a4_ = caml_call1(Bin_shape[2][1], cst_t$12),
    bin_shape_t$6 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$6, _a4_), 0);
   function bin_size_t$5(v){
    return 948106920 <= v[1] ? bin_size_t$3(v) : bin_size_t$2(v);
   }
   function bin_write_t$5(buf, pos, v){
    return 948106920 <= v[1]
            ? bin_write_t$3(buf, pos, v)
            : bin_write_t$2(buf, pos, v);
   }
   var bin_writer_t$5 = [0, bin_size_t$5, bin_write_t$5];
   function bin_read_t$11(buf, pos_ref, vint){
    try{var _fB_ = bin_read_t$5(buf, pos_ref, vint); return _fB_;}
    catch(_fC_){
     var _fA_ = caml_wrap_exception(_fC_);
     if(_fA_ === Bin_prot_Common[13]) return bin_read_t$7(buf, pos_ref, vint);
     throw caml_maybe_attach_backtrace(_fA_, 0);
    }
   }
   function bin_read_t$12(buf, pos_ref){
    var vint = caml_call2(Bin_prot_Read[28], buf, pos_ref);
    try{var _fy_ = bin_read_t$11(buf, pos_ref, vint); return _fy_;}
    catch(_fz_){
     var _fx_ = caml_wrap_exception(_fz_);
     if(_fx_ === Bin_prot_Common[13])
      return caml_call2(Bin_prot_Common[18], err$4, pos_ref[1]);
     throw caml_maybe_attach_backtrace(_fx_, 0);
    }
   }
   var
    bin_reader_t$5 = [0, bin_read_t$12, bin_read_t$11],
    bin_t$5 = [0, bin_shape_t$6, bin_writer_t$5, bin_reader_t$5];
   function hash_fold_t$2(hsv$0, arg){
    if(948106920 > arg[1]) return hash_fold_t$1(hsv$0, arg);
    var v = arg[2], hsv = caml_call2(Base_Hash[3], hsv$0, 948106920);
    return caml_call2(Core[556], hsv, v);
   }
   function hash$2(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _fw_ = hash_fold_t$2(hsv, arg);
    return caml_call1(Base_Hash[9], _fw_);
   }
   function t_of_sexp$8(sexp_143){
    try{
     try{var _fr_ = t_of_sexp$4(sexp_143), _ft_ = _fr_;}
     catch(_fv_){
      var _fq_ = caml_wrap_exception(_fv_);
      if(_fq_ !== Sexplib0_Sexp_conv_error[22])
       throw caml_maybe_attach_backtrace(_fq_, 0);
      var _ft_ = t_of_sexp$6(sexp_143);
     }
     return _ft_;
    }
    catch(_fu_){
     var _fs_ = caml_wrap_exception(_fu_);
     if(_fs_ === Sexplib0_Sexp_conv_error[22])
      return caml_call2
              (Sexplib0_Sexp_conv_error[24], error_source_144, sexp_143);
     throw caml_maybe_attach_backtrace(_fs_, 0);
    }
   }
   function sexp_of_t$10(v_145){
    return 948106920 <= v_145[1] ? sexp_of_t$8(v_145) : sexp_of_t$6(v_145);
   }
   function to_sockaddr$1(t){
    return 948106920 <= t[1] ? to_sockaddr$0(t) : to_sockaddr(t);
   }
   function to_string$5(t){return 948106920 <= t[1] ? t[2] : to_string$2(t);}
   function to_string$6(t){
    switch(t[1]){
      case 0:
       return cst_unix;
      case 1:
       return cst_inet;
      default: return cst_inet6;
    }
   }
   var
    inet = [0, 1, 0, of_sockaddr_exn, sexp_of_t$5],
    unix = [0, 0, 1, of_sockaddr_exn$0, sexp_of_t$8];
   function is_inet_witness(t){return t[2] ? 0 : _a5_;}
   function sexp_of_t$11(of_a_147, param){
    var
     socket_type_151 = param[2],
     family_149 = param[1],
     arg_152 = caml_call1(Core_unix[187], socket_type_151),
     bnds_148 = [0, [1, [0, _a6_, [0, arg_152, 0]]], 0],
     family = family_149[1],
     arg_150 = caml_call1(Core_unix[177], family),
     bnds_148$0 = [0, [1, [0, _a7_, [0, arg_150, 0]]], bnds_148];
    return [1, bnds_148$0];
   }
   function family(t){return t[1];}
   var
    tcp = [0, inet, 0],
    udp = [0, inet, 1],
    unix$0 = [0, unix, 0],
    unix_dgram = [0, unix, 1];
   function info(param){
    var
     connected_to = param[1],
     bound_on = param[2],
     listening = param[3],
     x_153 = param[4],
     type =
       x_153 === tcp
        ? caml_call1(Sexplib0_Sexp_conv[7], cst_tcp)
        : x_153
          === udp
          ? caml_call1(Sexplib0_Sexp_conv[7], cst_udp)
          : sexp_of_t$11(function(param){return _ba_;}, x_153);
    if(listening)
     var listening_on = bound_on, bound_on$0 = 0;
    else
     var listening_on = 0, bound_on$0 = bound_on;
    var match = 0;
    if(listening_on)
     var
      v_156 = listening_on[1],
      match$0 = [0, [1, [0, _a8_, [0, sexp_of_t$9(v_156), 0]]], match];
    else
     var match$0 = match;
    if(bound_on$0)
     var
      v_155 = bound_on$0[1],
      _fo_ = [0, [1, [0, _a9_, [0, sexp_of_t$9(v_155), 0]]], match$0];
    else
     var _fo_ = match$0;
    var
     match$1 =
       [0, [1, [0, _a__, [0, caml_call1(Core_Sexp[93], type), 0]]], _fo_];
    if(connected_to)
     var
      v_154 = connected_to[1],
      _fp_ = [0, [1, [0, _a$_, [0, sexp_of_t$9(v_154), 0]]], match$1];
    else
     var _fp_ = match$1;
    return caml_call1(Core_Info[20], [1, _fp_]);
   }
   function sexp_of_t$12(param, _fn_, t){
    return caml_call1(Async_unix_Fd[2], t[2]);
   }
   function fd(t){return t[2];}
   function of_fd(fd, type){return [0, type, fd, 0];}
   function sexp_of_address(t){var t$0 = t[1]; return t$0[1][4];}
   function create$1(type){
    var
     file_descr = caml_call5(Core_unix[219], _bb_, type[1][1], type[2], 0, 0);
    function _fl_(x_157){
     return sexp_of_t$11(function(param){return _bc_;}, x_157);
    }
    var
     _fm_ = caml_call5(Core_Info[19], 0, 0, cst_socket, type, _fl_),
     fd = caml_call4(Async_unix_Fd[6], 0, _bd_, file_descr, _fm_);
    return [0, type, fd, [0, [0, 0, 0, 0, type]]];
   }
   function to_string$7(t){return t[1];}
   function make(getsockopt, setsockopt, name, opt){
    function _fk_(fd, a){return caml_call3(setsockopt, fd, opt, a);}
    return [0,
            name,
            function(fd){return caml_call2(getsockopt, fd, opt);},
            _fk_];
   }
   var _be_ = Core_unix[245], _bf_ = Core_unix[244];
   function bool(_fi_, _fj_){return make(_bf_, _be_, _fi_, _fj_);}
   var _bg_ = Core_unix[247], _bh_ = Core_unix[246];
   function int$0(_fg_, _fh_){return make(_bh_, _bg_, _fg_, _fh_);}
   var
    _bi_ = Core_unix[249],
    _bj_ = Core_unix[248],
    _bk_ = Core_unix[251],
    _bl_ = Core_unix[250];
   function float$0(_fe_, _ff_){return make(_bl_, _bk_, _fe_, _ff_);}
   var
    debug = bool(cst_debug, 0),
    broadcast = bool(cst_broadcast, 1),
    reuseaddr = bool(cst_reuseaddr, 2),
    reuseport = bool(cst_reuseport, 9),
    keepalive = bool(cst_keepalive, 3),
    dontroute = bool(cst_dontroute, 4),
    oobinline = bool(cst_oobinline, 5),
    acceptconn = bool(cst_acceptconn, 6),
    nodelay = bool(cst_nodelay, 7),
    sndbuf = int$0(cst_sndbuf, 0),
    rcvbuf = int$0(cst_rcvbuf, 1),
    error = int$0(cst_error, 2),
    typ = int$0(cst_typ, 3),
    rcvlowat = int$0(cst_rcvlowat, 4),
    sndlowat = int$0(cst_sndlowat, 5),
    linger = make(_bj_, _bi_, cst_linger, 0),
    rcvtimeo = float$0(cst_rcvtimeo, 0),
    sndtimeo = float$0(cst_sndtimeo, 1),
    mcast_loop = [0, cst_mcast_loop, Core_unix[309], Core_unix[310]],
    mcast_ttl = [0, cst_mcast_ttl, Core_unix[307], Core_unix[308]];
   function getopt(t, opt){
    return caml_call3(Async_unix_Fd[23], 0, t[2], opt[2]);
   }
   function setopt(t, opt, a){
    function _fd_(file_descr){return caml_call2(opt[3], file_descr, a);}
    return caml_call3(Async_unix_Fd[23], 0, t[2], _fd_);
   }
   function mcast_join(ifname, source, t, address){
    function _fb_(file_descr){
     var _fc_ = to_sockaddr$1(address);
     return caml_call4(Core_unix[305], ifname, source, file_descr, _fc_);
    }
    return caml_call3(Async_unix_Fd[23], 0, t[2], _fb_);
   }
   function mcast_leave(ifname, source, t, address){
    function _e$_(file_descr){
     var _fa_ = to_sockaddr$1(address);
     return caml_call4(Core_unix[306], ifname, source, file_descr, _fa_);
    }
    return caml_call3(Async_unix_Fd[23], 0, t[2], _e$_);
   }
   function mark_bound(t, address){
    var match = t[3];
    if(match){
     var i = match[1];
     i[2] = [0, address];
     var info$0 = [0, 4150146, info(i)];
    }
    else
     var
      sexp_of_address$0 = sexp_of_address(t),
      _e__ =
        function(param){
         var v_158 = param[2];
         return [1, [0, _bn_, [0, caml_call1(sexp_of_address$0, v_158), 0]]];
        },
      info$0 =
        [0,
         -72399366,
         caml_call5
          (Core_Info[19], 0, 0, cst_socket$0, [0, -850067008, address], _e__)];
    return caml_call3(Async_unix_Fd[43][1], t[2], _bm_, info$0);
   }
   function bind_keep_opts(t, address){
    var sockaddr = to_sockaddr$1(address);
    function _e7_(param){mark_bound(t, address); return t;}
    function _e8_(file_descr){
     return caml_call2(Core_unix[222], file_descr, sockaddr);
    }
    var _e9_ = caml_call3(Async_unix_Fd[35], t[2], cst_bind, _e8_);
    return caml_call2(Async_unix_Import[33][3], _e9_, _e7_);
   }
   function bind(opt, t, address){
    if(opt) var sth = opt[1], reuseaddr$0 = sth; else var reuseaddr$0 = 1;
    setopt(t, reuseaddr, reuseaddr$0);
    set_close_on_exec(t[2]);
    return bind_keep_opts(t, address);
   }
   function bind_inet_keep_opts(t, address){
    var sockaddr = to_sockaddr$1(address);
    function _e6_(file_descr){
     return caml_call2(Core_unix[222], file_descr, sockaddr);
    }
    caml_call3(Async_unix_Fd[32], 0, t[2], _e6_);
    mark_bound(t, address);
    return t;
   }
   function bind_inet(opt, t, address){
    if(opt) var sth = opt[1], reuseaddr$0 = sth; else var reuseaddr$0 = 1;
    setopt(t, reuseaddr, reuseaddr$0);
    set_close_on_exec(t[2]);
    return bind_inet_keep_opts(t, address);
   }
   function listen(opt, t){
    if(opt) var sth = opt[1], backlog = sth; else var backlog = 64;
    var fd = t[2];
    function _e5_(file_descr){
     return caml_call2(Core_unix[224], file_descr, backlog);
    }
    caml_call3(Async_unix_Fd[32], 0, fd, _e5_);
    var match = t[3];
    if(match){
     var i = match[1];
     i[3] = 1;
     var info$0 = [0, 4150146, info(i)];
    }
    else
     var info$0 = [0, -72399366, caml_call1(Core_Info[14], cst_listening)];
    caml_call3(Async_unix_Fd[43][1], fd, _bo_, info$0);
    return t;
   }
   function turn_off_nagle(addr, t){
    var _e4_ = t[1][2];
    if(1 === addr[0] && ! _e4_) return setopt(t, nodelay, 1);
    return;
   }
   function accept_nonblocking(t){
    function _eZ_(file_descr){
     return caml_call2(Core_unix[221], _bp_, file_descr);
    }
    var match = caml_call3(Async_unix_Fd[22], _bq_, t[2], _eZ_);
    if(typeof match === "number") return -177230888;
    if(106380200 > match[1]){
     var
      match$0 = match[2],
      sockaddr = match$0[2],
      file_descr = match$0[1],
      address = caml_call1(t[1][1][3], sockaddr),
      sexp_of_address$0 = sexp_of_address(t),
      _e1_ =
        function(param){
         var
          arg1_163 = param[2],
          arg0_162 = param[1],
          v_160 = arg0_162[2],
          res0_164 = [1, [0, _br_, [0, caml_call1(Core_Info[9], v_160), 0]]],
          v_161 = arg1_163[2],
          res1_165 =
            [1, [0, _bs_, [0, caml_call1(sexp_of_address$0, v_161), 0]]];
         return [1, [0, res0_164, [0, res1_165, 0]]];
        },
      _e2_ =
        [0,
         [0, 333306659, caml_call1(Async_unix_Fd[4], t[2])],
         [0, 173001291, address]],
      _e3_ = caml_call5(Core_Info[19], 0, 0, cst_socket$1, _e2_, _e1_),
      fd = caml_call4(Async_unix_Fd[6], 0, _bt_, file_descr, _e3_),
      s = [0, t[1], fd, 0];
     turn_off_nagle(sockaddr, s);
     return [0, 17724, [0, s, address]];
    }
    var exn = match[2];
    a:
    if(exn[1] === Unix_error){
     var _e0_ = exn[2];
     if(typeof _e0_ === "number"){
      if(12 <= _e0_){
       if(37 !== _e0_ && 55 !== _e0_) break a;
      }
      else if(2 !== _e0_ && 11 > _e0_) break a;
      return 616804163;
     }
    }
    throw caml_maybe_attach_backtrace(exn, 0);
   }
   function accept_interruptible(t, interrupt){
    function _eU_(param){
     var x = accept_nonblocking(t);
     if(typeof x === "number" && 616804163 <= x){
      var
       _eV_ =
         function(x){
          if(-102231997 > x)
           return -952706910 <= x ? [0, -289386606, x] : _bv_;
          if(-3286312 > x) return _bu_;
          var
           _eX_ = [0, caml_call1(Async_unix_Fd[2], t[2]), 0],
           _eY_ =
             [1,
              [0,
               caml_call1
                (Sexplib0_Sexp_conv[7], cst_accept_on_bad_file_descrip),
               _eX_]];
          return caml_call1(Core[261], _eY_);
         },
       _eW_ = caml_call3(Async_unix_Fd[27], t[2], 914388854, interrupt);
      return caml_call2(Async_unix_Import[33][3], _eW_, _eV_);
     }
     return caml_call1(Async_unix_Import[30], [0, -289386606, x]);
    }
    return caml_call2(Async_kernel_Deferred[31], 0, _eU_);
   }
   function accept(t){
    function _eS_(x){
     if(typeof x === "number" && -177230888 > x) return -177230888;
     return x;
    }
    var _eT_ = accept_interruptible(t, caml_call1(Async_unix_Fd[14], t[2]));
    return caml_call2(Async_unix_Import[33][3], _eT_, _eS_);
   }
   function accept_at_most_interruptible(t, limit, interrupt){
    if(caml_call2(Async_unix_Import[5], limit, 1)){
     var
      _eM_ = [0, [1, [0, _bw_, [0, caml_call1(Core[389], limit), 0]]], 0],
      _eN_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Socket_accept_at_most_inte),
          _eM_]];
     caml_call1(Core[261], _eN_);
    }
    function _eO_(x){
     if(typeof x === "number") return x;
     var
      connection = x[2],
      connections$1 = [0, connection, 0],
      limit$2 = limit - 1 | 0,
      limit$0 = limit$2,
      connections = connections$1;
     for(;;){
      if(! caml_call2(Async_unix_Import[3], limit$0, 0)){
       try{var val = accept_nonblocking(t);}
       catch(exn$0){
        var
         exn = caml_wrap_exception(exn$0),
         _eQ_ =
           function(param){
            var conn = param[1];
            return caml_call2(Async_unix_Fd[12], 0, conn[2]);
           },
         _eR_ =
           caml_call3
            (Async_kernel_Deferred_list[14], -686623969, connections, _eQ_);
        caml_call1(Async_unix_Import[16], _eR_);
        throw caml_maybe_attach_backtrace(exn, 0);
       }
       if(typeof val !== "number"){
        var
         connection$0 = val[2],
         connections$0 = [0, connection$0, connections],
         limit$1 = limit$0 - 1 | 0,
         limit$0 = limit$1,
         connections = connections$0;
        continue;
       }
      }
      return [0, 17724, caml_call1(Core_List[59], connections)];
     }
    }
    var _eP_ = accept_interruptible(t, interrupt);
    return caml_call2(Async_unix_Import[33][3], _eP_, _eO_);
   }
   function accept_at_most(t, limit){
    function _eK_(x){
     if(typeof x === "number" && -177230888 > x) return -177230888;
     return x;
    }
    var
     _eL_ =
       accept_at_most_interruptible
        (t, limit, caml_call1(Async_unix_Fd[14], t[2]));
    return caml_call2(Async_unix_Import[33][3], _eL_, _eK_);
   }
   function connect_interruptible(t, address, interrupt){
    var sockaddr = to_sockaddr$1(address);
    turn_off_nagle(sockaddr, t);
    function success(param){
     var match = t[3];
     if(match){
      var i = match[1];
      i[1] = [0, address];
      var info$0 = [0, 4150146, info(i)];
     }
     else
      var
       sexp_of_address$0 = sexp_of_address(t),
       info$0 =
         [0,
          -72399366,
          caml_call5
           (Core_Info[19], 0, 0, cst_connected_to, address, sexp_of_address$0)];
     caml_call3(Async_unix_Fd[43][1], t[2], _bx_, info$0);
     return [0, 17724, t];
    }
    function _ev_(file_descr){
     return caml_call2(Core_unix[223], file_descr, sockaddr);
    }
    var match = caml_call3(Async_unix_Fd[22], _by_, t[2], _ev_);
    if(typeof match === "number"){
     var
      _ew_ =
        [0, [1, [0, _bz_, [0, caml_call1(Async_unix_Fd[2], t[2]), 0]]], 0],
      _ex_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_close_before_connect),
          _ew_]];
     return caml_call1(Core[261], _ex_);
    }
    if(106380200 > match[1]){
     var _eB_ = success(0);
     return caml_call1(Async_unix_Import[30], _eB_);
    }
    var e = match[2];
    a:
    if(e[1] === Unix_error){
     var _ey_ = e[2];
     if(typeof _ey_ === "number"){
      if(11 !== _ey_ && 38 !== _ey_) break a;
      var
       _ez_ =
         function(x){
          if(-102231997 > x){
           if(-952706910 <= x) return x;
           var
            _eI_ =
              [0,
               [1, [0, _bB_, [0, caml_call1(Async_unix_Fd[2], t[2]), 0]]],
               0],
            _eJ_ =
              [1,
               [0,
                caml_call1(Sexplib0_Sexp_conv[7], cst_close_during_connect),
                _eI_]];
           return caml_call1(Core[261], _eJ_);
          }
          if(-3286312 <= x){
           var
            _eC_ = [0, caml_call1(Async_unix_Fd[2], t[2]), 0],
            _eD_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_connect_on_bad_file_descri),
                _eC_]];
           return caml_call1(Core[261], _eD_);
          }
          function _eE_(file_descr){
           return caml_call2(Core_unix[246], file_descr, 2);
          }
          var match = caml_call3(Async_unix_Fd[22], 0, t[2], _eE_);
          if(typeof match === "number"){
           var
            _eF_ =
              [0,
               [1, [0, _bA_, [0, caml_call1(Async_unix_Fd[2], t[2]), 0]]],
               0],
            _eG_ =
              [1,
               [0,
                caml_call1(Sexplib0_Sexp_conv[7], cst_close_after_connect),
                _eF_]];
           return caml_call1(Core[261], _eG_);
          }
          if(106380200 <= match[1]){
           var exn = match[2];
           throw caml_maybe_attach_backtrace(exn, 0);
          }
          var err = match[2];
          if(caml_call2(Async_unix_Import[3], err, 0)) return success(0);
          var _eH_ = to_string$5(address);
          return caml_call3(Core_unix[6], err, cst_connect, _eH_);
         },
       _eA_ = caml_call3(Async_unix_Fd[27], t[2], -477700929, interrupt);
      return caml_call2(Async_unix_Import[33][3], _eA_, _ez_);
     }
    }
    throw caml_maybe_attach_backtrace(e, 0);
   }
   function connect(t, addr){
    function _et_(param){
     if(typeof param === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bC_], 1);
     var t = param[2];
     return t;
    }
    var
     _eu_ =
       connect_interruptible
        (t, addr, caml_call1(Async_kernel_Deferred[19], 0));
    return caml_call2(Async_unix_Import[33][3], _eu_, _et_);
   }
   function shutdown(t, mode){
    var mode$0 = 737457313 === mode ? 2 : 925481320 <= mode ? 1 : 0;
    function _es_(file_descr){
     return caml_call2(Core_unix[227], file_descr, mode$0);
    }
    return caml_call3(Async_unix_Fd[32], 0, t[2], _es_);
   }
   function getsockname(t){
    var
     _eq_ = caml_call1(Async_unix_Fd[40], t[2]),
     _er_ = caml_call1(Core_unix[228], _eq_);
    return caml_call1(t[1][1][3], _er_);
   }
   function getpeername(t){
    var
     _eo_ = caml_call1(Async_unix_Fd[40], t[2]),
     _ep_ = caml_call1(Core_unix[229], _eo_);
    return caml_call1(t[1][1][3], _ep_);
   }
   function _bD_(f, t, ifname){return caml_call2(f, t[2], ifname);}
   var
    bind_to_interface_exn$0 =
      caml_call2(Core_Or_error[53], bind_to_interface_exn, _bD_);
   function socketpair(param){
    var
     match = caml_call5(Core_unix[220], _bE_, 0, 0, 0, 0),
     s2 = match[2],
     s1 = match[1];
    function make_fd(s){
     var _en_ = caml_call1(Core_Info[14], cst_socketpair);
     return caml_call4(Async_unix_Fd[6], 0, _bF_, s, _en_);
    }
    var _em_ = make_fd(s2);
    return [0, make_fd(s1), _em_];
   }
   function getbyname(n){
    return dns_lookup
            (cst_gethostbyname,
             function(param){return caml_call1(Core_unix[256][2], n);});
   }
   function getbyname_exn(n){
    return dns_lookup
            (cst_gethostbyname$0,
             function(param){return caml_call1(Core_unix[256][3], n);});
   }
   function getbyaddr(a){
    return dns_lookup
            (cst_gethostbyaddr,
             function(param){return caml_call1(Core_unix[256][4], a);});
   }
   function getbyaddr_exn(a){
    return dns_lookup
            (cst_gethostbyaddr$0,
             function(param){return caml_call1(Core_unix[256][5], a);});
   }
   var
    have_address_in_common = Core_unix[256][6],
    Host =
      [0,
       getbyname,
       getbyname_exn,
       getbyaddr,
       getbyaddr_exn,
       have_address_in_common],
    _bH_ = caml_call1(Bin_prot_Shape[5], _bG_),
    _bI_ =
      [0, [0, caml_call1(Bin_shape[2][1], cst_socket_domain), 0, _bH_], 0],
    _bJ_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_1366_),
    group$7 = caml_call2(Bin_prot_Shape[2], _bJ_, _bI_),
    _bK_ = caml_call1(Bin_shape[2][1], cst_socket_domain$0),
    bin_shape_socket_domain =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$7, _bK_), 0);
   function bin_size_socket_domain(param){return 1;}
   function bin_write_socket_domain(buf, pos, param){
    switch(param){
      case 0:
       return caml_call3(Bin_prot_Write[30], buf, pos, 0);
      case 1:
       return caml_call3(Bin_prot_Write[30], buf, pos, 1);
      default: return caml_call3(Bin_prot_Write[30], buf, pos, 2);
    }
   }
   var
    bin_writer_socket_domain =
      [0, bin_size_socket_domain, bin_write_socket_domain];
   function bin_read_socket_domain(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19], cst_src_unix_syscalls_ml_socke, pos_ref[1]);
   }
   function bin_read_socket_domain$0(buf, pos_ref){
    var match = caml_call2(Bin_prot_Read[29], buf, pos_ref);
    if(2 < match >>> 0)
     return caml_call2(Bin_prot_Common[18], _bL_, pos_ref[1]);
    switch(match){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   var
    bin_reader_socket_domain =
      [0, bin_read_socket_domain$0, bin_read_socket_domain],
    bin_socket_domain =
      [0,
       bin_shape_socket_domain,
       bin_writer_socket_domain,
       bin_reader_socket_domain],
    compare_socket_domain = caml_int_compare;
   function hash_fold_socket_domain(hsv, arg){
    switch(arg){
      case 0:
       var _el_ = 0; break;
      case 1:
       var _el_ = 1; break;
      default: var _el_ = 2;
    }
    return caml_call2(Base_Hash[3], hsv, _el_);
   }
   function hash_socket_domain(arg){
    var
     hsv = caml_call2(Base_Hash[11], 0, 0),
     _ek_ = hash_fold_socket_domain(hsv, arg);
    return caml_call1(Base_Hash[9], _ek_);
   }
   function socket_domain_of_sexp(sexp_171){
    a:
    {
     if(0 === sexp_171[0]){
      var _eg_ = sexp_171[1];
      b:
      if(caml_string_notequal(_eg_, cst_PF_INET)){
       c:
       if(caml_string_notequal(_eg_, cst_PF_INET6)){
        if(caml_string_notequal(_eg_, cst_PF_UNIX)){
         if(! caml_string_notequal(_eg_, cst_pF_INET)) break b;
         if(! caml_string_notequal(_eg_, cst_pF_INET6)) break c;
         if(caml_string_notequal(_eg_, cst_pF_UNIX)) break a;
        }
        return 0;
       }
       return 2;
      }
      return 1;
     }
     var _eh_ = sexp_171[1];
     if(! _eh_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_170, sexp_171);
     var _ei_ = _eh_[1];
     if(0 !== _ei_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_170, sexp_171);
     var _ej_ = _ei_[1];
     b:
     if(caml_string_notequal(_ej_, cst_PF_INET)){
      c:
      if(caml_string_notequal(_ej_, cst_PF_INET6)){
       if(caml_string_notequal(_ej_, cst_PF_UNIX)){
        if(! caml_string_notequal(_ej_, cst_pF_INET)) break b;
        if(! caml_string_notequal(_ej_, cst_pF_INET6)) break c;
        if(caml_string_notequal(_ej_, cst_pF_UNIX)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_170, sexp_171);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_170, sexp_171);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_170, sexp_171);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_170, sexp_171);
   }
   function sexp_of_socket_domain(param){
    switch(param){
      case 0:
       return _bM_;
      case 1:
       return _bN_;
      default: return _bO_;
    }
   }
   var
    _bQ_ = caml_call1(Bin_prot_Shape[5], _bP_),
    _bR_ = [0, [0, caml_call1(Bin_shape[2][1], cst_socket_type), 0, _bQ_], 0],
    _bS_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_1372_),
    group$8 = caml_call2(Bin_prot_Shape[2], _bS_, _bR_),
    _bT_ = caml_call1(Bin_shape[2][1], cst_socket_type$0),
    bin_shape_socket_type =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$8, _bT_), 0);
   function bin_size_socket_type(param){return 1;}
   function bin_write_socket_type(buf, pos, param){
    switch(param){
      case 0:
       return caml_call3(Bin_prot_Write[30], buf, pos, 0);
      case 1:
       return caml_call3(Bin_prot_Write[30], buf, pos, 1);
      case 2:
       return caml_call3(Bin_prot_Write[30], buf, pos, 2);
      default: return caml_call3(Bin_prot_Write[30], buf, pos, 3);
    }
   }
   var
    bin_writer_socket_type = [0, bin_size_socket_type, bin_write_socket_type];
   function bin_read_socket_type(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_src_unix_syscalls_ml_socke$0,
             pos_ref[1]);
   }
   function bin_read_socket_type$0(buf, pos_ref){
    var match = caml_call2(Bin_prot_Read[29], buf, pos_ref);
    if(3 < match >>> 0)
     return caml_call2(Bin_prot_Common[18], _bU_, pos_ref[1]);
    switch(match){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      default: return 3;
    }
   }
   var
    bin_reader_socket_type = [0, bin_read_socket_type$0, bin_read_socket_type],
    bin_socket_type =
      [0,
       bin_shape_socket_type,
       bin_writer_socket_type,
       bin_reader_socket_type],
    compare_socket_type = caml_int_compare;
   function hash_fold_socket_type(hsv, arg){
    switch(arg){
      case 0:
       var _ef_ = 0; break;
      case 1:
       var _ef_ = 1; break;
      case 2:
       var _ef_ = 2; break;
      default: var _ef_ = 3;
    }
    return caml_call2(Base_Hash[3], hsv, _ef_);
   }
   function hash_socket_type(arg){
    var
     hsv = caml_call2(Base_Hash[11], 0, 0),
     _ee_ = hash_fold_socket_type(hsv, arg);
    return caml_call1(Base_Hash[9], _ee_);
   }
   function socket_type_of_sexp(sexp_177){
    a:
    {
     if(0 === sexp_177[0]){
      var _ea_ = sexp_177[1];
      b:
      if(caml_string_notequal(_ea_, cst_SOCK_DGRAM)){
       c:
       if(caml_string_notequal(_ea_, cst_SOCK_RAW)){
        d:
        if(caml_string_notequal(_ea_, cst_SOCK_SEQPACKET)){
         if(caml_string_notequal(_ea_, cst_SOCK_STREAM)){
          if(! caml_string_notequal(_ea_, cst_sOCK_DGRAM)) break b;
          if(! caml_string_notequal(_ea_, cst_sOCK_RAW)) break c;
          if(! caml_string_notequal(_ea_, cst_sOCK_SEQPACKET)) break d;
          if(caml_string_notequal(_ea_, cst_sOCK_STREAM)) break a;
         }
         return 0;
        }
        return 3;
       }
       return 2;
      }
      return 1;
     }
     var _eb_ = sexp_177[1];
     if(! _eb_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_176, sexp_177);
     var _ec_ = _eb_[1];
     if(0 !== _ec_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_176, sexp_177);
     var _ed_ = _ec_[1];
     b:
     if(caml_string_notequal(_ed_, cst_SOCK_DGRAM)){
      c:
      if(caml_string_notequal(_ed_, cst_SOCK_RAW)){
       d:
       if(caml_string_notequal(_ed_, cst_SOCK_SEQPACKET)){
        if(caml_string_notequal(_ed_, cst_SOCK_STREAM)){
         if(! caml_string_notequal(_ed_, cst_sOCK_DGRAM)) break b;
         if(! caml_string_notequal(_ed_, cst_sOCK_RAW)) break c;
         if(! caml_string_notequal(_ed_, cst_sOCK_SEQPACKET)) break d;
         if(caml_string_notequal(_ed_, cst_sOCK_STREAM)) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_176, sexp_177);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_176, sexp_177);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_176, sexp_177);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_176, sexp_177);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_176, sexp_177);
   }
   function sexp_of_socket_type(param){
    switch(param){
      case 0:
       return _bV_;
      case 1:
       return _bW_;
      case 2:
       return _bX_;
      default: return _bY_;
    }
   }
   var
    _bZ_ =
      caml_call1
       (Bin_prot_Shape[5],
        [0,
         [0, cst_ADDR_UNIX, [0, Core[541], 0]],
         [0, [0, cst_ADDR_INET, [0, bin_shape_t$1, [0, Core[372], 0]]], 0]]),
    _b0_ = [0, [0, caml_call1(Bin_shape[2][1], cst_sockaddr), 0, _bZ_], 0],
    _b1_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_1379_),
    group$9 = caml_call2(Bin_prot_Shape[2], _b1_, _b0_),
    _b2_ = caml_call1(Bin_shape[2][1], cst_sockaddr$0),
    bin_shape_sockaddr =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$9, _b2_), 0);
   function bin_size_sockaddr(param){
    if(0 === param[0]){
     var v1 = param[1], _d9_ = caml_call1(Core[542], v1);
     return caml_call2(Bin_prot_Common[23], 1, _d9_);
    }
    var
     v2 = param[2],
     v1$0 = param[1],
     _d__ = caml_call1(bin_size_t$0, v1$0),
     size = caml_call2(Bin_prot_Common[23], 1, _d__),
     _d$_ = caml_call1(Core[373], v2);
    return caml_call2(Bin_prot_Common[23], size, _d$_);
   }
   function bin_write_sockaddr(buf, pos, param){
    if(0 === param[0]){
     var v1 = param[1], pos$0 = caml_call3(Bin_prot_Write[30], buf, pos, 0);
     return caml_call3(Core[544], buf, pos$0, v1);
    }
    var
     v2 = param[2],
     v1$0 = param[1],
     pos$1 = caml_call3(Bin_prot_Write[30], buf, pos, 1),
     pos$2 = caml_call3(bin_write_t$0, buf, pos$1, v1$0);
    return caml_call3(Core[375], buf, pos$2, v2);
   }
   var bin_writer_sockaddr = [0, bin_size_sockaddr, bin_write_sockaddr];
   function bin_read_sockaddr(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19], cst_src_unix_syscalls_ml_socka, pos_ref[1]);
   }
   function bin_read_sockaddr$0(buf, pos_ref){
    var match = caml_call2(Bin_prot_Read[29], buf, pos_ref);
    if(0 === match){
     var arg_1 = caml_call2(Core[547], buf, pos_ref);
     return [0, arg_1];
    }
    if(1 !== match) return caml_call2(Bin_prot_Common[18], _b3_, pos_ref[1]);
    var
     arg_1$0 = caml_call2(bin_read_t$1, buf, pos_ref),
     arg_2 = caml_call2(Core[378], buf, pos_ref);
    return [1, arg_1$0, arg_2];
   }
   var
    bin_reader_sockaddr = [0, bin_read_sockaddr$0, bin_read_sockaddr],
    bin_sockaddr =
      [0, bin_shape_sockaddr, bin_writer_sockaddr, bin_reader_sockaddr];
   function compare_sockaddr(a_178, b_179){
    if(a_178 === b_179) return 0;
    if(0 === a_178[0]){
     var a_180 = a_178[1];
     if(0 !== b_179[0]) return -1;
     var b_181 = b_179[1];
     return caml_call2(Core[551], a_180, b_181);
    }
    var a_184 = a_178[2], a_182 = a_178[1];
    if(0 === b_179[0]) return 1;
    var
     b_185 = b_179[2],
     b_183 = b_179[1],
     n = caml_call2(compare$3, a_182, b_183);
    return 0 === n ? caml_call2(Core[382], a_184, b_185) : n;
   }
   function sexp_of_sockaddr(param){
    if(0 === param[0]){
     var arg0_186 = param[1], res0_187 = caml_call1(Core[558], arg0_186);
     return [1, [0, _b4_, [0, res0_187, 0]]];
    }
    var
     arg1_189 = param[2],
     arg0_188 = param[1],
     res0_190 = caml_call1(sexp_of_t$4, arg0_188),
     res1_191 = caml_call1(Core[389], arg1_189);
    return [1, [0, _b5_, [0, res0_190, [0, res1_191, 0]]]];
   }
   var
    _b6_ =
      caml_call1
       (Bin_prot_Shape[5],
        [0,
         [0, cst_ADDR_UNIX$0, [0, Core[541], 0]],
         [0,
          [0, cst_ADDR_INET$0, [0, Blocking_sexp[5], [0, Core[372], 0]]],
          0]]),
    _b7_ =
      [0,
       [0, caml_call1(Bin_shape[2][1], cst_sockaddr_blocking_sexp), 0, _b6_],
       0],
    _b8_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_1384_),
    group$10 = caml_call2(Bin_prot_Shape[2], _b8_, _b7_),
    _b9_ = caml_call1(Bin_shape[2][1], cst_sockaddr_blocking_sexp$0),
    bin_shape_sockaddr_blocking_se =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$10, _b9_), 0);
   function bin_size_sockaddr_blocking_sex(param){
    if(0 === param[0]){
     var v1 = param[1], _d6_ = caml_call1(Core[542], v1);
     return caml_call2(Bin_prot_Common[23], 1, _d6_);
    }
    var
     v2 = param[2],
     v1$0 = param[1],
     _d7_ = caml_call1(Blocking_sexp[1], v1$0),
     size = caml_call2(Bin_prot_Common[23], 1, _d7_),
     _d8_ = caml_call1(Core[373], v2);
    return caml_call2(Bin_prot_Common[23], size, _d8_);
   }
   function bin_write_sockaddr_blocking_se(buf, pos, param){
    if(0 === param[0]){
     var v1 = param[1], pos$0 = caml_call3(Bin_prot_Write[30], buf, pos, 0);
     return caml_call3(Core[544], buf, pos$0, v1);
    }
    var
     v2 = param[2],
     v1$0 = param[1],
     pos$1 = caml_call3(Bin_prot_Write[30], buf, pos, 1),
     pos$2 = caml_call3(Blocking_sexp[2], buf, pos$1, v1$0);
    return caml_call3(Core[375], buf, pos$2, v2);
   }
   var
    bin_writer_sockaddr_blocking_s =
      [0, bin_size_sockaddr_blocking_sex, bin_write_sockaddr_blocking_se];
   function bin_read_sockaddr_blocking_sex(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_src_unix_syscalls_ml_socka$0,
             pos_ref[1]);
   }
   function bin_read_sockaddr_blocking_sex$0(buf, pos_ref){
    var match = caml_call2(Bin_prot_Read[29], buf, pos_ref);
    if(0 === match){
     var arg_1 = caml_call2(Core[547], buf, pos_ref);
     return [0, arg_1];
    }
    if(1 !== match) return caml_call2(Bin_prot_Common[18], _b__, pos_ref[1]);
    var
     arg_1$0 = caml_call2(Blocking_sexp[3], buf, pos_ref),
     arg_2 = caml_call2(Core[378], buf, pos_ref);
    return [1, arg_1$0, arg_2];
   }
   var
    bin_reader_sockaddr_blocking_s =
      [0, bin_read_sockaddr_blocking_sex$0, bin_read_sockaddr_blocking_sex],
    bin_sockaddr_blocking_sexp =
      [0,
       bin_shape_sockaddr_blocking_se,
       bin_writer_sockaddr_blocking_s,
       bin_reader_sockaddr_blocking_s];
   function sockaddr_blocking_sexp_of_sexp(sexp_196){
    a:
    {
     if(0 === sexp_196[0]){
      var _d2_ = sexp_196[1];
      b:
      if(caml_string_notequal(_d2_, cst_ADDR_INET$1)){
       if(caml_string_notequal(_d2_, cst_ADDR_UNIX$1)){
        if(! caml_string_notequal(_d2_, cst_aDDR_INET)) break b;
        if(caml_string_notequal(_d2_, cst_aDDR_UNIX)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_194, sexp_196);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_194, sexp_196);
     }
     var _d3_ = sexp_196[1];
     if(! _d3_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_194, sexp_196);
     var _d4_ = _d3_[1];
     if(0 !== _d4_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_194, sexp_196);
     var tag_197 = _d4_[1];
     b:
     if(caml_string_notequal(tag_197, cst_ADDR_INET$1)){
      if(caml_string_notequal(tag_197, cst_ADDR_UNIX$1)){
       if(! caml_string_notequal(tag_197, cst_aDDR_INET)) break b;
       if(caml_string_notequal(tag_197, cst_aDDR_UNIX)) break a;
      }
      var sexp_args_198 = _d3_[2];
      if(sexp_args_198 && ! sexp_args_198[2]){
       var
        arg0_199 = sexp_args_198[1],
        res0_200 = caml_call1(Core[559], arg0_199);
       return [0, res0_200];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_194,
               tag_197,
               sexp_196);
     }
     var sexp_args_203 = _d3_[2];
     if(sexp_args_203){
      var _d5_ = sexp_args_203[2];
      if(_d5_ && ! _d5_[2]){
       var
        arg1_205 = _d5_[1],
        arg0_204 = sexp_args_203[1],
        res0_206 = caml_call1(Blocking_sexp[12], arg0_204),
        res1_207 = caml_call1(Core[390], arg1_205);
       return [1, res0_206, res1_207];
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_194,
              tag_197,
              sexp_196);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_194, sexp_196);
   }
   function sexp_of_sockaddr_blocking_sexp(param){
    if(0 === param[0]){
     var arg0_208 = param[1], res0_209 = caml_call1(Core[558], arg0_208);
     return [1, [0, _b$_, [0, res0_209, 0]]];
    }
    var
     arg1_211 = param[2],
     arg0_210 = param[1],
     res0_212 = caml_call1(Blocking_sexp[13], arg0_210),
     res1_213 = caml_call1(Core[389], arg1_211);
    return [1, [0, _ca_, [0, res0_212, [0, res1_213, 0]]]];
   }
   var
    _cb_ =
      caml_call1
       (Bin_prot_Shape[4],
        [0,
         [0, cst_ai_family, bin_shape_socket_domain],
         [0,
          [0, cst_ai_socktype, bin_shape_socket_type],
          [0,
           [0, cst_ai_protocol, Core[372]],
           [0,
            [0, cst_ai_addr, bin_shape_sockaddr],
            [0, [0, cst_ai_canonname, Core[541]], 0]]]]]),
    _cc_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$13), 0, _cb_], 0],
    _cd_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_1390_),
    group$11 = caml_call2(Bin_prot_Shape[2], _cd_, _cc_),
    _ce_ = caml_call1(Bin_shape[2][1], cst_t$14),
    bin_shape_t$7 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$11, _ce_), 0);
   function bin_size_t$6(param){
    var
     v5 = param[5],
     v4 = param[4],
     v3 = param[3],
     size = caml_call2(Bin_prot_Common[23], 0, 1),
     size$0 = caml_call2(Bin_prot_Common[23], size, 1),
     _dZ_ = caml_call1(Core[373], v3),
     size$1 = caml_call2(Bin_prot_Common[23], size$0, _dZ_),
     _d0_ = bin_size_sockaddr(v4),
     size$2 = caml_call2(Bin_prot_Common[23], size$1, _d0_),
     _d1_ = caml_call1(Core[542], v5);
    return caml_call2(Bin_prot_Common[23], size$2, _d1_);
   }
   function bin_write_t$6(buf, pos, param){
    var
     v5 = param[5],
     v4 = param[4],
     v3 = param[3],
     v2 = param[2],
     v1 = param[1],
     pos$0 = bin_write_socket_domain(buf, pos, v1),
     pos$1 = bin_write_socket_type(buf, pos$0, v2),
     pos$2 = caml_call3(Core[375], buf, pos$1, v3),
     pos$3 = bin_write_sockaddr(buf, pos$2, v4);
    return caml_call3(Core[544], buf, pos$3, v5);
   }
   var bin_writer_t$6 = [0, bin_size_t$6, bin_write_t$6];
   function bin_read_t$13(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19], cst_src_unix_syscalls_ml_Addr_, pos_ref[1]);
   }
   function bin_read_t$14(buf, pos_ref){
    var
     v_ai_family = bin_read_socket_domain$0(buf, pos_ref),
     v_ai_socktype = bin_read_socket_type$0(buf, pos_ref),
     v_ai_protocol = caml_call2(Core[378], buf, pos_ref),
     v_ai_addr = bin_read_sockaddr$0(buf, pos_ref),
     v_ai_canonname = caml_call2(Core[547], buf, pos_ref);
    return [0,
            v_ai_family,
            v_ai_socktype,
            v_ai_protocol,
            v_ai_addr,
            v_ai_canonname];
   }
   var
    bin_reader_t$6 = [0, bin_read_t$14, bin_read_t$13],
    bin_t$6 = [0, bin_shape_t$7, bin_writer_t$6, bin_reader_t$6];
   function sexp_of_t$13(param){
    var
     ai_canonname_223 = param[5],
     ai_addr_221 = param[4],
     ai_protocol_219 = param[3],
     ai_socktype_217 = param[2],
     ai_family_215 = param[1],
     arg_224 = caml_call1(Core[558], ai_canonname_223),
     bnds_214 = [0, [1, [0, _cf_, [0, arg_224, 0]]], 0],
     arg_222 = sexp_of_sockaddr(ai_addr_221),
     bnds_214$0 = [0, [1, [0, _cg_, [0, arg_222, 0]]], bnds_214],
     arg_220 = caml_call1(Core[389], ai_protocol_219),
     bnds_214$1 = [0, [1, [0, _ch_, [0, arg_220, 0]]], bnds_214$0],
     arg_218 = sexp_of_socket_type(ai_socktype_217),
     bnds_214$2 = [0, [1, [0, _ci_, [0, arg_218, 0]]], bnds_214$1],
     arg_216 = sexp_of_socket_domain(ai_family_215),
     bnds_214$3 = [0, [1, [0, _cj_, [0, arg_216, 0]]], bnds_214$2];
    return [1, bnds_214$3];
   }
   var
    _ck_ =
      caml_call1
       (Bin_prot_Shape[4],
        [0,
         [0, cst_ai_family$0, bin_shape_socket_domain],
         [0,
          [0, cst_ai_socktype$0, bin_shape_socket_type],
          [0,
           [0, cst_ai_protocol$0, Core[372]],
           [0,
            [0, cst_ai_addr$0, bin_shape_sockaddr_blocking_se],
            [0, [0, cst_ai_canonname$0, Core[541]], 0]]]]]),
    _cl_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$15), 0, _ck_], 0],
    _cm_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_1400_),
    group$12 = caml_call2(Bin_prot_Shape[2], _cm_, _cl_),
    _cn_ = caml_call1(Bin_shape[2][1], cst_t$16),
    bin_shape_t$8 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$12, _cn_), 0);
   function bin_size_t$7(param){
    var
     v5 = param[5],
     v4 = param[4],
     v3 = param[3],
     size = caml_call2(Bin_prot_Common[23], 0, 1),
     size$0 = caml_call2(Bin_prot_Common[23], size, 1),
     _dW_ = caml_call1(Core[373], v3),
     size$1 = caml_call2(Bin_prot_Common[23], size$0, _dW_),
     _dX_ = bin_size_sockaddr_blocking_sex(v4),
     size$2 = caml_call2(Bin_prot_Common[23], size$1, _dX_),
     _dY_ = caml_call1(Core[542], v5);
    return caml_call2(Bin_prot_Common[23], size$2, _dY_);
   }
   function bin_write_t$7(buf, pos, param){
    var
     v5 = param[5],
     v4 = param[4],
     v3 = param[3],
     v2 = param[2],
     v1 = param[1],
     pos$0 = bin_write_socket_domain(buf, pos, v1),
     pos$1 = bin_write_socket_type(buf, pos$0, v2),
     pos$2 = caml_call3(Core[375], buf, pos$1, v3),
     pos$3 = bin_write_sockaddr_blocking_se(buf, pos$2, v4);
    return caml_call3(Core[544], buf, pos$3, v5);
   }
   var bin_writer_t$7 = [0, bin_size_t$7, bin_write_t$7];
   function bin_read_t$15(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_src_unix_syscalls_ml_Addr_$0,
             pos_ref[1]);
   }
   function bin_read_t$16(buf, pos_ref){
    var
     v_ai_family = bin_read_socket_domain$0(buf, pos_ref),
     v_ai_socktype = bin_read_socket_type$0(buf, pos_ref),
     v_ai_protocol = caml_call2(Core[378], buf, pos_ref),
     v_ai_addr = bin_read_sockaddr_blocking_sex$0(buf, pos_ref),
     v_ai_canonname = caml_call2(Core[547], buf, pos_ref);
    return [0,
            v_ai_family,
            v_ai_socktype,
            v_ai_protocol,
            v_ai_addr,
            v_ai_canonname];
   }
   var
    bin_reader_t$7 = [0, bin_read_t$16, bin_read_t$15],
    bin_t$7 = [0, bin_shape_t$8, bin_writer_t$7, bin_reader_t$7];
   function t_of_sexp$9(x_227){
    function _dQ_(param){
     var
      _dT_ = param[2],
      _dU_ = _dT_[2],
      _dV_ = _dU_[2],
      ai_canonname = _dV_[2][1],
      ai_addr = _dV_[1],
      ai_protocol = _dU_[1],
      ai_socktype = _dT_[1],
      ai_family = param[1];
     return [0, ai_family, ai_socktype, ai_protocol, ai_addr, ai_canonname];
    }
    var _dR_ = 0;
    function _dS_(param){
     return caml_string_notequal(param, cst_ai_addr$2)
             ? caml_string_notequal
                (param, cst_ai_canonname$2)
               ? caml_string_notequal
                  (param, cst_ai_family$2)
                 ? caml_string_notequal
                    (param, cst_ai_protocol$2)
                   ? caml_string_notequal(param, cst_ai_socktype$2) ? -1 : 1
                   : 2
                 : 0
               : 4
             : 3;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_226,
             [0,
              cst_ai_family$1,
              1,
              socket_domain_of_sexp,
              [0,
               cst_ai_socktype$1,
               1,
               socket_type_of_sexp,
               [0,
                cst_ai_protocol$1,
                1,
                Core[390],
                [0,
                 cst_ai_addr$1,
                 1,
                 sockaddr_blocking_sexp_of_sexp,
                 [0, cst_ai_canonname$1, 1, Core[559], 0]]]]],
             _dS_,
             _dR_,
             _dQ_,
             x_227);
   }
   function sexp_of_t$14(param){
    var
     ai_canonname_237 = param[5],
     ai_addr_235 = param[4],
     ai_protocol_233 = param[3],
     ai_socktype_231 = param[2],
     ai_family_229 = param[1],
     arg_238 = caml_call1(Core[558], ai_canonname_237),
     bnds_228 = [0, [1, [0, _co_, [0, arg_238, 0]]], 0],
     arg_236 = sexp_of_sockaddr_blocking_sexp(ai_addr_235),
     bnds_228$0 = [0, [1, [0, _cp_, [0, arg_236, 0]]], bnds_228],
     arg_234 = caml_call1(Core[389], ai_protocol_233),
     bnds_228$1 = [0, [1, [0, _cq_, [0, arg_234, 0]]], bnds_228$0],
     arg_232 = sexp_of_socket_type(ai_socktype_231),
     bnds_228$2 = [0, [1, [0, _cr_, [0, arg_232, 0]]], bnds_228$1],
     arg_230 = sexp_of_socket_domain(ai_family_229),
     bnds_228$3 = [0, [1, [0, _cs_, [0, arg_230, 0]]], bnds_228$2];
    return [1, bnds_228$3];
   }
   var
    _cu_ =
      caml_call1
       (Bin_prot_Shape[5],
        [0,
         [0, cst_AI_FAMILY, [0, bin_shape_socket_domain, 0]],
         [0,
          [0, cst_AI_SOCKTYPE, [0, bin_shape_socket_type, 0]],
          [0, [0, cst_AI_PROTOCOL, [0, Core[372], 0]], _ct_]]]),
    _cv_ =
      [0,
       [0, caml_call1(Bin_shape[2][1], cst_getaddrinfo_option), 0, _cu_],
       0],
    _cw_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_1410_),
    group$13 = caml_call2(Bin_prot_Shape[2], _cw_, _cv_),
    _cx_ = caml_call1(Bin_shape[2][1], cst_getaddrinfo_option$0),
    bin_shape_getaddrinfo_option =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$13, _cx_), 0);
   function bin_size_getaddrinfo_option(param){
    if(typeof param === "number") return 1;
    switch(param[0]){
      case 0:
       return caml_call2(Bin_prot_Common[23], 1, 1);
      case 1:
       return caml_call2(Bin_prot_Common[23], 1, 1);
      default:
       var v1 = param[1], _dP_ = caml_call1(Core[373], v1);
       return caml_call2(Bin_prot_Common[23], 1, _dP_);
    }
   }
   function bin_write_getaddrinfo_option(buf, pos, param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return caml_call3(Bin_prot_Write[30], buf, pos, 3);
       case 1:
        return caml_call3(Bin_prot_Write[30], buf, pos, 4);
       default: return caml_call3(Bin_prot_Write[30], buf, pos, 5);
     }
    switch(param[0]){
      case 0:
       var v1 = param[1], pos$0 = caml_call3(Bin_prot_Write[30], buf, pos, 0);
       return bin_write_socket_domain(buf, pos$0, v1);
      case 1:
       var
        v1$0 = param[1],
        pos$1 = caml_call3(Bin_prot_Write[30], buf, pos, 1);
       return bin_write_socket_type(buf, pos$1, v1$0);
      default:
       var
        v1$1 = param[1],
        pos$2 = caml_call3(Bin_prot_Write[30], buf, pos, 2);
       return caml_call3(Core[375], buf, pos$2, v1$1);
    }
   }
   var
    bin_writer_getaddrinfo_option =
      [0, bin_size_getaddrinfo_option, bin_write_getaddrinfo_option];
   function bin_read_getaddrinfo_option(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_src_unix_syscalls_ml_Addr_$1,
             pos_ref[1]);
   }
   function bin_read_getaddrinfo_option$0(buf, pos_ref){
    var match = caml_call2(Bin_prot_Read[29], buf, pos_ref);
    if(5 < match >>> 0)
     return caml_call2(Bin_prot_Common[18], _cy_, pos_ref[1]);
    switch(match){
      case 0:
       var arg_1 = bin_read_socket_domain$0(buf, pos_ref); return [0, arg_1];
      case 1:
       var arg_1$0 = bin_read_socket_type$0(buf, pos_ref);
       return [1, arg_1$0];
      case 2:
       var arg_1$1 = caml_call2(Core[378], buf, pos_ref); return [2, arg_1$1];
      case 3:
       return 0;
      case 4:
       return 1;
      default: return 2;
    }
   }
   var
    bin_reader_getaddrinfo_option =
      [0, bin_read_getaddrinfo_option$0, bin_read_getaddrinfo_option],
    bin_getaddrinfo_option =
      [0,
       bin_shape_getaddrinfo_option,
       bin_writer_getaddrinfo_option,
       bin_reader_getaddrinfo_option];
   function getaddrinfo_option_of_sexp(sexp_243){
    a:
    {
     if(0 === sexp_243[0]){
      var
       _dK_ = sexp_243[1],
       _dL_ = caml_string_compare(_dK_, cst_aI_CANONNAME);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          f:
          {
           if(0 <= _dL_){
            if(0 < _dL_){
             if(! caml_string_notequal(_dK_, cst_aI_FAMILY)) break f;
             if(! caml_string_notequal(_dK_, cst_aI_NUMERICHOST)) break e;
             if(! caml_string_notequal(_dK_, cst_aI_PASSIVE)) break d;
             if(! caml_string_notequal(_dK_, cst_aI_PROTOCOL)) break c;
             if(caml_string_notequal(_dK_, cst_aI_SOCKTYPE)) break a;
             break b;
            }
           }
           else if(caml_string_notequal(_dK_, cst_AI_CANONNAME)){
            if(! caml_string_notequal(_dK_, cst_AI_FAMILY$0)) break f;
            if(! caml_string_notequal(_dK_, cst_AI_NUMERICHOST)) break e;
            if(! caml_string_notequal(_dK_, cst_AI_PASSIVE)) break d;
            if(! caml_string_notequal(_dK_, cst_AI_PROTOCOL$0)) break c;
            if(caml_string_notequal(_dK_, cst_AI_SOCKTYPE$0)) break a;
            break b;
           }
           return 1;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_241, sexp_243);
         }
         return 0;
        }
        return 2;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_241, sexp_243);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_241, sexp_243);
     }
     var _dM_ = sexp_243[1];
     if(! _dM_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_241, sexp_243);
     var _dN_ = _dM_[1];
     if(0 !== _dN_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_241, sexp_243);
     var
      tag_244 = _dN_[1],
      _dO_ = caml_string_compare(tag_244, cst_aI_CANONNAME);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          if(0 <= _dO_){
           if(0 < _dO_){
            if(! caml_string_notequal(tag_244, cst_aI_FAMILY)) break f;
            if(! caml_string_notequal(tag_244, cst_aI_NUMERICHOST)) break e;
            if(! caml_string_notequal(tag_244, cst_aI_PASSIVE)) break d;
            if(! caml_string_notequal(tag_244, cst_aI_PROTOCOL)) break c;
            if(caml_string_notequal(tag_244, cst_aI_SOCKTYPE)) break a;
            break b;
           }
          }
          else if(caml_string_notequal(tag_244, cst_AI_CANONNAME)){
           if(! caml_string_notequal(tag_244, cst_AI_FAMILY$0)) break f;
           if(! caml_string_notequal(tag_244, cst_AI_NUMERICHOST)) break e;
           if(! caml_string_notequal(tag_244, cst_AI_PASSIVE)) break d;
           if(! caml_string_notequal(tag_244, cst_AI_PROTOCOL$0)) break c;
           if(caml_string_notequal(tag_244, cst_AI_SOCKTYPE$0)) break a;
           break b;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[7], error_source_241, sexp_243);
         }
         var sexp_args_245 = _dM_[2];
         if(sexp_args_245 && ! sexp_args_245[2]){
          var
           arg0_246 = sexp_args_245[1],
           res0_247 = socket_domain_of_sexp(arg0_246);
          return [0, res0_247];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_241,
                  tag_244,
                  sexp_243);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_241, sexp_243);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_241, sexp_243);
      }
      var sexp_args_255 = _dM_[2];
      if(sexp_args_255 && ! sexp_args_255[2]){
       var
        arg0_256 = sexp_args_255[1],
        res0_257 = caml_call1(Core[390], arg0_256);
       return [2, res0_257];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_241,
               tag_244,
               sexp_243);
     }
     var sexp_args_250 = _dM_[2];
     if(sexp_args_250 && ! sexp_args_250[2]){
      var
       arg0_251 = sexp_args_250[1],
       res0_252 = socket_type_of_sexp(arg0_251);
      return [1, res0_252];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_241,
              tag_244,
              sexp_243);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_241, sexp_243);
   }
   function sexp_of_getaddrinfo_option(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return _cz_;
       case 1:
        return _cA_;
       default: return _cB_;
     }
    switch(param[0]){
      case 0:
       var arg0_258 = param[1], res0_259 = sexp_of_socket_domain(arg0_258);
       return [1, [0, _cC_, [0, res0_259, 0]]];
      case 1:
       var arg0_260 = param[1], res0_261 = sexp_of_socket_type(arg0_260);
       return [1, [0, _cD_, [0, res0_261, 0]]];
      default:
       var arg0_262 = param[1], res0_263 = caml_call1(Core[389], arg0_262);
       return [1, [0, _cE_, [0, res0_263, 0]]];
    }
   }
   function get(opt, host, options){
    if(opt) var sth = opt[1], service = sth; else var service = cst$0;
    return dns_lookup
            (cst_getaddrinfo,
             function(param){
              return caml_call3(Core_unix[264], host, service, options);
             });
   }
   var
    _cF_ =
      caml_call1
       (Bin_prot_Shape[4],
        [0,
         [0, cst_ni_hostname, Core[541]],
         [0, [0, cst_ni_service, Core[541]], 0]]),
    _cG_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$17), 0, _cF_], 0],
    _cH_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_1425_),
    group$14 = caml_call2(Bin_prot_Shape[2], _cH_, _cG_),
    _cI_ = caml_call1(Bin_shape[2][1], cst_t$18),
    bin_shape_t$9 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$14, _cI_), 0);
   function bin_size_t$8(param){
    var
     v2 = param[2],
     v1 = param[1],
     _dI_ = caml_call1(Core[542], v1),
     size = caml_call2(Bin_prot_Common[23], 0, _dI_),
     _dJ_ = caml_call1(Core[542], v2);
    return caml_call2(Bin_prot_Common[23], size, _dJ_);
   }
   function bin_write_t$8(buf, pos, param){
    var
     v2 = param[2],
     v1 = param[1],
     pos$0 = caml_call3(Core[544], buf, pos, v1);
    return caml_call3(Core[544], buf, pos$0, v2);
   }
   var bin_writer_t$8 = [0, bin_size_t$8, bin_write_t$8];
   function bin_read_t$17(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19], cst_src_unix_syscalls_ml_Name_, pos_ref[1]);
   }
   function bin_read_t$18(buf, pos_ref){
    var
     v_ni_hostname = caml_call2(Core[547], buf, pos_ref),
     v_ni_service = caml_call2(Core[547], buf, pos_ref);
    return [0, v_ni_hostname, v_ni_service];
   }
   var
    bin_reader_t$8 = [0, bin_read_t$18, bin_read_t$17],
    bin_t$8 = [0, bin_shape_t$9, bin_writer_t$8, bin_reader_t$8];
   function t_of_sexp$10(x_266){
    function _dF_(param){
     var ni_service = param[2][1], ni_hostname = param[1];
     return [0, ni_hostname, ni_service];
    }
    var _dG_ = 0;
    function _dH_(param){
     return caml_string_notequal(param, cst_ni_hostname$1)
             ? caml_string_notequal(param, cst_ni_service$1) ? -1 : 1
             : 0;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_265,
             [0,
              cst_ni_hostname$0,
              1,
              Core[559],
              [0, cst_ni_service$0, 1, Core[559], 0]],
             _dH_,
             _dG_,
             _dF_,
             x_266);
   }
   function sexp_of_t$15(param){
    var
     ni_service_270 = param[2],
     ni_hostname_268 = param[1],
     arg_271 = caml_call1(Core[558], ni_service_270),
     bnds_267 = [0, [1, [0, _cJ_, [0, arg_271, 0]]], 0],
     arg_269 = caml_call1(Core[558], ni_hostname_268),
     bnds_267$0 = [0, [1, [0, _cK_, [0, arg_269, 0]]], bnds_267];
    return [1, bnds_267$0];
   }
   function getnameinfo_option_of_sexp(sexp_275){
    a:
    {
     if(0 === sexp_275[0]){
      var _dz_ = sexp_275[1], _dA_ = caml_string_compare(_dz_, cst_nI_DGRAM);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          if(0 <= _dA_){
           if(0 < _dA_){
            if(! caml_string_notequal(_dz_, cst_nI_NAMEREQD)) break e;
            if(! caml_string_notequal(_dz_, cst_nI_NOFQDN)) break d;
            if(! caml_string_notequal(_dz_, cst_nI_NUMERICHOST)) break c;
            if(caml_string_notequal(_dz_, cst_nI_NUMERICSERV)) break a;
            break b;
           }
          }
          else if(caml_string_notequal(_dz_, cst_NI_DGRAM)){
           if(! caml_string_notequal(_dz_, cst_NI_NAMEREQD)) break e;
           if(! caml_string_notequal(_dz_, cst_NI_NOFQDN)) break d;
           if(! caml_string_notequal(_dz_, cst_NI_NUMERICHOST)) break c;
           if(caml_string_notequal(_dz_, cst_NI_NUMERICSERV)) break a;
           break b;
          }
          return 4;
         }
         return 2;
        }
        return 0;
       }
       return 1;
      }
      return 3;
     }
     var _dB_ = sexp_275[1];
     if(! _dB_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_274, sexp_275);
     var _dC_ = _dB_[1];
     if(0 !== _dC_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_274, sexp_275);
     var _dD_ = _dC_[1], _dE_ = caml_string_compare(_dD_, cst_nI_DGRAM);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         if(0 <= _dE_){
          if(0 < _dE_){
           if(! caml_string_notequal(_dD_, cst_nI_NAMEREQD)) break e;
           if(! caml_string_notequal(_dD_, cst_nI_NOFQDN)) break d;
           if(! caml_string_notequal(_dD_, cst_nI_NUMERICHOST)) break c;
           if(caml_string_notequal(_dD_, cst_nI_NUMERICSERV)) break a;
           break b;
          }
         }
         else if(caml_string_notequal(_dD_, cst_NI_DGRAM)){
          if(! caml_string_notequal(_dD_, cst_NI_NAMEREQD)) break e;
          if(! caml_string_notequal(_dD_, cst_NI_NOFQDN)) break d;
          if(! caml_string_notequal(_dD_, cst_NI_NUMERICHOST)) break c;
          if(caml_string_notequal(_dD_, cst_NI_NUMERICSERV)) break a;
          break b;
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7], error_source_274, sexp_275);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_274, sexp_275);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_274, sexp_275);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_274, sexp_275);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_274, sexp_275);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_274, sexp_275);
   }
   function sexp_of_getnameinfo_option(param){
    switch(param){
      case 0:
       return _cL_;
      case 1:
       return _cM_;
      case 2:
       return _cN_;
      case 3:
       return _cO_;
      default: return _cP_;
    }
   }
   var
    _cR_ = caml_call1(Bin_prot_Shape[5], _cQ_),
    _cS_ =
      [0,
       [0, caml_call1(Bin_shape[2][1], cst_getnameinfo_option), 0, _cR_],
       0],
    _cT_ = caml_call1(Bin_shape[4][1], cst_src_unix_syscalls_ml_1431_),
    group$15 = caml_call2(Bin_prot_Shape[2], _cT_, _cS_),
    _cU_ = caml_call1(Bin_shape[2][1], cst_getnameinfo_option$0),
    bin_shape_getnameinfo_option =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$15, _cU_), 0);
   function bin_size_getnameinfo_option(param){return 1;}
   function bin_write_getnameinfo_option(buf, pos, param){
    switch(param){
      case 0:
       return caml_call3(Bin_prot_Write[30], buf, pos, 0);
      case 1:
       return caml_call3(Bin_prot_Write[30], buf, pos, 1);
      case 2:
       return caml_call3(Bin_prot_Write[30], buf, pos, 2);
      case 3:
       return caml_call3(Bin_prot_Write[30], buf, pos, 3);
      default: return caml_call3(Bin_prot_Write[30], buf, pos, 4);
    }
   }
   var
    bin_writer_getnameinfo_option =
      [0, bin_size_getnameinfo_option, bin_write_getnameinfo_option];
   function bin_read_getnameinfo_option(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_src_unix_syscalls_ml_Name_$0,
             pos_ref[1]);
   }
   function bin_read_getnameinfo_option$0(buf, pos_ref){
    var match = caml_call2(Bin_prot_Read[29], buf, pos_ref);
    if(4 < match >>> 0)
     return caml_call2(Bin_prot_Common[18], _cV_, pos_ref[1]);
    switch(match){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      case 3:
       return 3;
      default: return 4;
    }
   }
   var
    bin_reader_getnameinfo_option =
      [0, bin_read_getnameinfo_option$0, bin_read_getnameinfo_option],
    bin_getnameinfo_option =
      [0,
       bin_shape_getnameinfo_option,
       bin_writer_getnameinfo_option,
       bin_reader_getnameinfo_option];
   function get$0(addr, options){
    return dns_lookup
            (cst_getnameinfo,
             function(param){
              return caml_call2(Core_unix[269], addr, options);
             });
   }
   function gethostname(param){return caml_call1(Core_unix[255], 0);}
   function setuid(uid){return caml_call1(Core_unix[166], uid);}
   function setgid(gid){return caml_call1(Core_unix[169], gid);}
   function getuid(param){return caml_call1(Core_unix[164], 0);}
   function getgid(param){return caml_call1(Core_unix[167], 0);}
   function getegid(param){return caml_call1(Core_unix[168], 0);}
   function geteuid(param){return caml_call1(Core_unix[165], 0);}
   var include$3 = Core_unix[270], _cW_ = include$3[3], _cX_ = include$3[4];
   function tcgetattr(fd){
    function _dy_(file_descr){return caml_call1(_cW_, file_descr);}
    return caml_call3(Async_unix_Fd[35], fd, cst_tcgetattr, _dy_);
   }
   function tcsetattr(t, fd, mode){
    function _dx_(file_descr){return caml_call3(_cX_, t, file_descr, mode);}
    return caml_call3(Async_unix_Fd[35], fd, cst_tcsetattr, _dx_);
   }
   function shell(r){return r[7];}
   function dir(r){return r[6];}
   function gecos(r){return r[5];}
   function gid$0(r){return r[4];}
   function uid$0(r){return r[3];}
   function passwd(r){return r[2];}
   function name(r){return r[1];}
   function t_of_sexp$11(x_278){
    function _dp_(param){
     var
      _ds_ = param[2],
      _dt_ = _ds_[2],
      _du_ = _dt_[2],
      _dv_ = _du_[2],
      _dw_ = _dv_[2],
      shell = _dw_[2][1],
      dir = _dw_[1],
      gecos = _dv_[1],
      gid = _du_[1],
      uid = _dt_[1],
      passwd = _ds_[1],
      name = param[1];
     return [0, name, passwd, uid, gid, gecos, dir, shell];
    }
    var _dq_ = 0;
    function _dr_(param){
     return caml_string_notequal(param, cst_dir$0)
             ? caml_string_notequal
                (param, cst_gecos$0)
               ? caml_string_notequal
                  (param, cst_gid$3)
                 ? caml_string_notequal
                    (param, cst_name$1)
                   ? caml_string_notequal
                      (param, cst_passwd$1)
                     ? caml_string_notequal
                        (param, cst_shell$0)
                       ? caml_string_notequal(param, cst_uid$2) ? -1 : 2
                       : 6
                     : 1
                   : 0
                 : 3
               : 4
             : 5;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_277,
             [0,
              cst_name,
              1,
              Core[559],
              [0,
               cst_passwd,
               1,
               Core[559],
               [0,
                cst_uid$1,
                1,
                Core[390],
                [0,
                 cst_gid$1,
                 1,
                 Core[390],
                 [0,
                  cst_gecos,
                  1,
                  Core[559],
                  [0, cst_dir, 1, Core[559], [0, cst_shell, 1, Core[559], 0]]]]]]],
             _dr_,
             _dq_,
             _dp_,
             x_278);
   }
   function sexp_of_t$16(param){
    var
     shell_292 = param[7],
     dir_290 = param[6],
     gecos_288 = param[5],
     gid_286 = param[4],
     uid_284 = param[3],
     passwd_282 = param[2],
     name_280 = param[1],
     arg_293 = caml_call1(Core[558], shell_292),
     bnds_279 = [0, [1, [0, _cY_, [0, arg_293, 0]]], 0],
     arg_291 = caml_call1(Core[558], dir_290),
     bnds_279$0 = [0, [1, [0, _cZ_, [0, arg_291, 0]]], bnds_279],
     arg_289 = caml_call1(Core[558], gecos_288),
     bnds_279$1 = [0, [1, [0, _c0_, [0, arg_289, 0]]], bnds_279$0],
     arg_287 = caml_call1(Core[389], gid_286),
     bnds_279$2 = [0, [1, [0, _c1_, [0, arg_287, 0]]], bnds_279$1],
     arg_285 = caml_call1(Core[389], uid_284),
     bnds_279$3 = [0, [1, [0, _c2_, [0, arg_285, 0]]], bnds_279$2],
     arg_283 = caml_call1(Core[558], passwd_282),
     bnds_279$4 = [0, [1, [0, _c3_, [0, arg_283, 0]]], bnds_279$3],
     arg_281 = caml_call1(Core[558], name_280),
     bnds_279$5 = [0, [1, [0, _c4_, [0, arg_281, 0]]], bnds_279$4];
    return [1, bnds_279$5];
   }
   function getbyname$0(n){
    function _do_(param){return caml_call1(Core_unix[170][11], n);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _do_);
   }
   function getbyname_exn$0(n){
    function _dn_(param){return caml_call1(Core_unix[170][12], n);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _dn_);
   }
   function getbyuid(uid){
    function _dm_(param){return caml_call1(Core_unix[170][13], uid);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _dm_);
   }
   function getbyuid_exn(uid){
    function _dl_(param){return caml_call1(Core_unix[170][14], uid);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _dl_);
   }
   var
    Passwd =
      [0,
       shell,
       dir,
       gecos,
       gid$0,
       uid$0,
       passwd,
       name,
       t_of_sexp$11,
       sexp_of_t$16,
       getbyname$0,
       getbyname_exn$0,
       getbyuid,
       getbyuid_exn];
   function mem(r){return r[4];}
   function gid$1(r){return r[3];}
   function passwd$0(r){return r[2];}
   function name$0(r){return r[1];}
   function t_of_sexp$12(x_296){
    function _df_(param){
     var
      _dj_ = param[2],
      _dk_ = _dj_[2],
      mem = _dk_[2][1],
      gid = _dk_[1],
      passwd = _dj_[1],
      name = param[1];
     return [0, name, passwd, gid, mem];
    }
    var _dg_ = 0;
    function _dh_(param){
     return caml_string_notequal(param, cst_gid$3)
             ? caml_string_notequal
                (param, cst_mem$0)
               ? caml_string_notequal
                  (param, cst_name$1)
                 ? caml_string_notequal(param, cst_passwd$1) ? -1 : 1
                 : 0
               : 3
             : 2;
    }
    var _di_ = [0, cst_mem, 1, caml_call1(Core[302], Core[559]), 0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_295,
             [0,
              cst_name$0,
              1,
              Core[559],
              [0,
               cst_passwd$0,
               1,
               Core[559],
               [0, cst_gid$2, 1, Core[390], _di_]]],
             _dh_,
             _dg_,
             _df_,
             x_296);
   }
   function sexp_of_t$17(param){
    var
     mem_304 = param[4],
     gid_302 = param[3],
     passwd_300 = param[2],
     name_298 = param[1],
     arg_305 = caml_call2(Core[301], Core[558], mem_304),
     bnds_297 = [0, [1, [0, _c5_, [0, arg_305, 0]]], 0],
     arg_303 = caml_call1(Core[389], gid_302),
     bnds_297$0 = [0, [1, [0, _c6_, [0, arg_303, 0]]], bnds_297],
     arg_301 = caml_call1(Core[558], passwd_300),
     bnds_297$1 = [0, [1, [0, _c7_, [0, arg_301, 0]]], bnds_297$0],
     arg_299 = caml_call1(Core[558], name_298),
     bnds_297$2 = [0, [1, [0, _c8_, [0, arg_299, 0]]], bnds_297$1];
    return [1, bnds_297$2];
   }
   function getbyname$1(n){
    function _de_(param){return caml_call1(Core_unix[171][6], n);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _de_);
   }
   function getbyname_exn$1(n){
    function _dd_(param){return caml_call1(Core_unix[171][7], n);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _dd_);
   }
   function getbygid(gid){
    function _dc_(param){return caml_call1(Core_unix[171][8], gid);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _dc_);
   }
   function getbygid_exn(gid){
    function _db_(param){return caml_call1(Core_unix[171][9], gid);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _db_);
   }
   var
    Group =
      [0,
       mem,
       gid$1,
       passwd$0,
       name$0,
       t_of_sexp$12,
       sexp_of_t$17,
       getbyname$1,
       getbyname_exn$1,
       getbygid,
       getbygid_exn];
   function username(param){
    function _da_(param){return caml_call1(Core_unix[172], 0);}
    return caml_call2(Async_unix_In_thread[7], cst_username, _da_);
   }
   function getlogin(param){
    function _c$_(param){return caml_call1(Core_unix[173], 0);}
    return caml_call2(Async_unix_In_thread[7], cst_getlogin, _c$_);
   }
   function getifaddrs(param){
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, Core_unix[316]);
   }
   function _c9_(wordexp, flags, glob){
    function _c__(param){return caml_call2(wordexp, flags, glob);}
    return caml_call2(Async_unix_In_thread[7], cst_wordexp, _c__);
   }
   var wordexp = caml_call2(Core_Or_error[53], Core_unix[300], _c9_);
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Unix_syscalls);
   var
    Async_unix_Unix_syscalls =
      [0,
       system,
       system_exn,
       getpid,
       getppid,
       getppid_exn,
       this_process_became_child_of_i,
       nice,
       cores,
       openfile,
       [0, sexp_of_t],
       [0,
        compare,
        all,
        t_of_sexp,
        sexp_of_t$0,
        of_string,
        to_string,
        arg_type],
       Lock,
       with_file,
       fcntl_getfl,
       fcntl_setfl,
       close,
       deregister,
       lseek,
       truncate,
       ftruncate,
       fsync,
       fdatasync,
       sync,
       lockf,
       try_lockf,
       test_lockf,
       unlockf,
       flock,
       try_flock,
       funlock,
       [0,
        sexp_of_t$2,
        t_of_sexp$1,
        t_of_sexp$0,
        symbol,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        equal,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        validate_lbound,
        validate_ubound,
        validate_bound,
        Replace_polymorphic_compare,
        Map,
        Set,
        of_unix,
        to_unix],
       [0,
        ctime,
        mtime,
        atime,
        size,
        rdev,
        gid,
        uid,
        nlink,
        perm,
        kind,
        ino,
        dev,
        t_of_sexp$2,
        sexp_of_t$3,
        bin_size_t,
        bin_write_t,
        bin_read_t$0,
        bin_read_t,
        bin_shape_t$0,
        bin_writer_t,
        bin_reader_t,
        bin_t,
        compare$2,
        of_unix$0,
        to_unix$0,
        to_string$0],
       fstat,
       stat,
       lstat,
       isatty,
       unlink,
       remove,
       rename,
       link,
       chmod,
       fchmod,
       chown,
       fchown,
       access,
       access_exn,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir_opt,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       symlink,
       readlink,
       mkstemp,
       mkdtemp,
       getgrouplist,
       times,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       utimes,
       sexp_of_env,
       env_of_sexp,
       environment,
       getenv,
       getenv_exn,
       unsafe_getenv,
       unsafe_getenv_exn,
       putenv,
       unsetenv,
       fork_exec,
       sexp_of_wait_on,
       wait_on_of_sexp$0,
       wait_on_of_sexp,
       wait,
       wait_nohang,
       wait_untraced,
       wait_nohang_untraced,
       waitpid_prompt,
       waitpid_prompt,
       waitpid_exn,
       [0,
        bin_size_t$0,
        bin_write_t$0,
        bin_read_t$1,
        bin_read_t$2,
        bin_shape_t$1,
        bin_writer_t$0,
        bin_reader_t$0,
        bin_t$0,
        hash_fold_t,
        hash,
        sexp_of_t$4,
        arg_type$0,
        t_of_sexp$3,
        symbol$5,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        equal$0,
        compare$3,
        min$0,
        max$0,
        ascending$0,
        descending$0,
        between$0,
        clamp_exn$0,
        clamp$0,
        comparator$0,
        validate_lbound$0,
        validate_ubound$0,
        validate_bound$0,
        of_string$0,
        to_string$1,
        bind_any,
        bind_any_inet6,
        localhost,
        localhost_inet6,
        inet4_addr_of_int32,
        inet4_addr_to_int32_exn,
        inet4_addr_of_int63,
        inet4_addr_to_int63_exn,
        of_string_or_getbyname],
       [0],
       socketpair,
       [0,
        [0,
         [0,
          bin_size_t$3,
          bin_write_t$3,
          bin_read_t$8,
          bin_read_t$7,
          bin_shape_t$4,
          bin_writer_t$3,
          bin_reader_t$3,
          bin_t$3,
          sexp_of_t$8,
          t_of_sexp$7,
          t_of_sexp$6,
          compare$6,
          create$0,
          to_string$4,
          to_sockaddr$0],
         [0,
          bin_size_t$1,
          bin_write_t$1,
          bin_read_t$4,
          bin_read_t$3,
          bin_shape_t$2,
          bin_writer_t$1,
          bin_reader_t$1,
          bin_t$1,
          compare$4,
          hash_fold_t$0,
          hash$0,
          sexp_of_t$5,
          [0,
           bin_size_t$2,
           bin_write_t$2,
           bin_read_t$6,
           bin_read_t$5,
           bin_shape_t$3,
           bin_writer_t$2,
           bin_reader_t$2,
           bin_t$2,
           compare$5,
           hash_fold_t$1,
           hash$1,
           t_of_sexp$5,
           t_of_sexp$4,
           sexp_of_t$6],
          Show_port_in_test,
          create,
          create_bind_any,
          addr,
          port,
          to_string$2,
          to_host_and_port,
          to_sockaddr],
         bin_size_t$4,
         bin_write_t$4,
         bin_read_t$10,
         bin_read_t$9,
         bin_shape_t$5,
         bin_writer_t$4,
         bin_reader_t$4,
         bin_t$4,
         sexp_of_t$9,
         [0,
          bin_size_t$5,
          bin_write_t$5,
          bin_read_t$12,
          bin_read_t$11,
          bin_shape_t$6,
          bin_writer_t$5,
          bin_reader_t$5,
          bin_t$5,
          hash_fold_t$2,
          hash$2,
          t_of_sexp$8,
          sexp_of_t$10],
         to_string$5,
         to_sockaddr$1],
        [0, unix, inet, is_inet_witness, to_string$6],
        sexp_of_t$12,
        [0, sexp_of_t$11, tcp, udp, unix$0, unix_dgram, family],
        create$1,
        connect,
        connect_interruptible,
        bind_keep_opts,
        bind,
        bind_inet_keep_opts,
        bind_inet,
        listen,
        accept,
        accept_interruptible,
        accept_at_most,
        accept_at_most_interruptible,
        shutdown,
        fd,
        of_fd,
        getsockname,
        getpeername,
        [0,
         debug,
         broadcast,
         reuseaddr,
         reuseport,
         keepalive,
         dontroute,
         oobinline,
         acceptconn,
         nodelay,
         sndbuf,
         rcvbuf,
         error,
         typ,
         rcvlowat,
         sndlowat,
         linger,
         rcvtimeo,
         sndtimeo,
         mcast_loop,
         mcast_ttl,
         to_string$7],
        getopt,
        setopt,
        mcast_join,
        mcast_leave,
        bind_to_interface_exn$0],
       bind_to_interface_exn,
       Host,
       bin_shape_socket_domain,
       bin_size_socket_domain,
       bin_write_socket_domain,
       bin_writer_socket_domain,
       bin_read_socket_domain$0,
       bin_read_socket_domain,
       bin_reader_socket_domain,
       bin_socket_domain,
       compare_socket_domain,
       hash_fold_socket_domain,
       hash_socket_domain,
       sexp_of_socket_domain,
       socket_domain_of_sexp,
       bin_shape_socket_type,
       bin_size_socket_type,
       bin_write_socket_type,
       bin_writer_socket_type,
       bin_read_socket_type$0,
       bin_read_socket_type,
       bin_reader_socket_type,
       bin_socket_type,
       compare_socket_type,
       hash_fold_socket_type,
       hash_socket_type,
       sexp_of_socket_type,
       socket_type_of_sexp,
       bin_shape_sockaddr,
       bin_size_sockaddr,
       bin_write_sockaddr,
       bin_writer_sockaddr,
       bin_read_sockaddr$0,
       bin_read_sockaddr,
       bin_reader_sockaddr,
       bin_sockaddr,
       compare_sockaddr,
       sexp_of_sockaddr,
       bin_shape_sockaddr_blocking_se,
       bin_size_sockaddr_blocking_sex,
       bin_write_sockaddr_blocking_se,
       bin_writer_sockaddr_blocking_s,
       bin_read_sockaddr_blocking_sex$0,
       bin_read_sockaddr_blocking_sex,
       bin_reader_sockaddr_blocking_s,
       bin_sockaddr_blocking_sexp,
       sexp_of_sockaddr_blocking_sexp,
       sockaddr_blocking_sexp_of_sexp,
       [0,
        bin_size_t$6,
        bin_write_t$6,
        bin_read_t$14,
        bin_read_t$13,
        bin_shape_t$7,
        bin_writer_t$6,
        bin_reader_t$6,
        bin_t$6,
        sexp_of_t$13,
        [0,
         bin_size_t$7,
         bin_write_t$7,
         bin_read_t$16,
         bin_read_t$15,
         bin_shape_t$8,
         bin_writer_t$7,
         bin_reader_t$7,
         bin_t$7,
         t_of_sexp$9,
         sexp_of_t$14],
        bin_shape_getaddrinfo_option,
        bin_size_getaddrinfo_option,
        bin_write_getaddrinfo_option,
        bin_writer_getaddrinfo_option,
        bin_read_getaddrinfo_option$0,
        bin_read_getaddrinfo_option,
        bin_reader_getaddrinfo_option,
        bin_getaddrinfo_option,
        sexp_of_getaddrinfo_option,
        getaddrinfo_option_of_sexp,
        get],
       [0,
        bin_size_t$8,
        bin_write_t$8,
        bin_read_t$18,
        bin_read_t$17,
        bin_shape_t$9,
        bin_writer_t$8,
        bin_reader_t$8,
        bin_t$8,
        t_of_sexp$10,
        sexp_of_t$15,
        bin_shape_getnameinfo_option,
        bin_size_getnameinfo_option,
        bin_write_getnameinfo_option,
        bin_writer_getnameinfo_option,
        bin_read_getnameinfo_option$0,
        bin_read_getnameinfo_option,
        bin_reader_getnameinfo_option,
        bin_getnameinfo_option,
        sexp_of_getnameinfo_option,
        getnameinfo_option_of_sexp,
        get$0],
       gethostname,
       getuid,
       geteuid,
       getgid,
       getegid,
       setuid,
       setgid,
       Unix_error,
       [0, tcgetattr, tcsetattr],
       Passwd,
       Group,
       getifaddrs,
       username,
       getlogin,
       wordexp,
       [0, [0, check_all, do_not_handle_sigchld], dns_lookup]];
   runtime.caml_register_global
    (641, Async_unix_Unix_syscalls, cst_Async_unix_Unix_syscalls$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Writer0
//# unitInfo: Requires: Async_kernel__Async_invariant, Async_kernel__Debug, Async_kernel__Deferred, Async_kernel__Deferred_list, Async_kernel__Deferred_or_error, Async_kernel__Deferred_result, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Pipe, Async_kernel__Priority, Async_kernel__Time_source, Async_unix__Backing_out_channel, Async_unix__Fd, Async_unix__Import, Async_unix__In_thread, Async_unix__Io_uring, Async_unix__Io_uring_raw_singleton, Async_unix__Require_explicit_time_source, Async_unix__Shutdown, Async_unix__Unix_syscalls, Base__Exn, Base__Field, Base__Int63, Bigstring_unix, Bin_prot__Common, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Utils, Bin_prot__Write, Bin_shape, CamlinternalLazy, Core, Core__Array, Core__Bag, Core__Bigstring, Core__Bigsubstring, Core__Bool, Core__Deque, Core__Error, Core__Filename, Core__Hashable, Core__Hashtbl, Core__Info, Core__Int, Core__Int63, Core__Lazy, Core__List, Core__Option, Core__Or_error, Core__Ordered_collection_common, Core__Queue, Core__Result, Core__Sexp, Core__Signal, Core__Substring, Core__Unique_id, Core_unix, Expect_test_config, Filename_unix, Inline_test_config, Iobuf, Iobuf_unix, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_expect_runtime__Test_block, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Types, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib__Pre_sexp, Stdio__Out_channel, Stdlib__Format, Time_float_unix, Time_ns_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Async_unix_Writer0$0 = "Async_unix__Writer0",
    cst_At_most$0 = "At_most",
    cst_Closed = "Closed",
    cst_Consumer_left = "Consumer_left",
    cst_Error = "Error",
    cst_Unlimited$0 = "Unlimited",
    cst_async_unix$0 = "async_unix",
    cst_back$0 = "back",
    cst_background_writer_state$0 = "background_writer_state",
    cst_backing_out_channel$0 = "backing_out_channel",
    cst_buffer_age_limit$1 = "buffer_age_limit",
    cst_bytes_received_queue$0 = "bytes_received_queue",
    cst_bytes_written$0 = "bytes_written",
    cst_close_finished$0 = "close_finished",
    cst_close_started$0 = "close_started",
    cst_consumer_left$0 = "consumer_left",
    cst_exn = "exn",
    cst_flush_at_shutdown_elt$0 = "flush_at_shutdown_elt",
    cst_maximum_age = "maximum_age",
    cst_open_flags = "open_flags",
    cst_scheduled_back$0 = "scheduled_back",
    cst_scheduled_bytes$0 = "scheduled_bytes",
    cst_src_writer0_ml$0 = "src/writer0.ml",
    cst_src_writer0_ml_buffer_age_ = "src/writer0.ml.buffer_age_limit",
    cst_times_received_queue$0 = "times_received_queue",
    cst_too_old$0 = "too_old",
    cst_writer = "writer",
    cst_written = "written",
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = "\n",
    mode = [0, 913115943, [0, -545248983, 0]],
    err = [2, cst_src_writer0_ml_buffer_age_],
    pos$0 = "src/writer0.ml:396:30",
    pos = "src/writer0.ml:323:26",
    error_source_054 = cst_src_writer0_ml_buffer_age_,
    error_source_059 = cst_src_writer0_ml_buffer_age_,
    Core = global_data.Core,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Async_unix_Import = global_data.Async_unix__Import,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_Bag = global_data.Core__Bag,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_List = global_data.Core__List,
    Async_unix_Unix_syscalls = global_data.Async_unix__Unix_syscalls,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Assert_failure = global_data.Assert_failure,
    Filename_unix = global_data.Filename_unix,
    Core_Info = global_data.Core__Info,
    Async_unix_Fd = global_data.Async_unix__Fd,
    Core_Error = global_data.Core__Error,
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred_or_error =
      global_data.Async_kernel__Deferred_or_error,
    Core_Or_error = global_data.Core__Or_error,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Core_Option = global_data.Core__Option,
    Core_Filename = global_data.Core__Filename,
    Async_unix_In_thread = global_data.Async_unix__In_thread,
    Core_Lazy = global_data.Core__Lazy,
    Core_Signal = global_data.Core__Signal,
    Async_unix_Shutdown = global_data.Async_unix__Shutdown,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Core_unix = global_data.Core_unix,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    Async_unix_Backing_out_channel =
      global_data.Async_unix__Backing_out_channel,
    Async_unix_Require_explicit_ti =
      global_data.Async_unix__Require_explicit_time_source,
    Iobuf = global_data.Iobuf,
    Iobuf_unix = global_data.Iobuf_unix,
    Core_Bigsubstring = global_data.Core__Bigsubstring,
    Bin_prot_Utils = global_data.Bin_prot__Utils,
    Core_Bigstring = global_data.Core__Bigstring,
    Core_Sexp = global_data.Core__Sexp,
    Stdlib_Format = global_data.Stdlib__Format,
    Sexplib_Pre_sexp = global_data.Sexplib__Pre_sexp,
    Core_Substring = global_data.Core__Substring,
    Core_Ordered_collection_common =
      global_data.Core__Ordered_collection_common,
    Bigstring_unix = global_data.Bigstring_unix,
    Base_Exn = global_data.Base__Exn,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Time_ns_unix = global_data.Time_ns_unix,
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Core_Array = global_data.Core__Array,
    Async_kernel_Priority = global_data.Async_kernel__Priority,
    Core_Deque = global_data.Core__Deque,
    Core_Int63 = global_data.Core__Int63,
    Async_unix_Io_uring_raw_single =
      global_data.Async_unix__Io_uring_raw_singleton,
    Async_unix_Io_uring = global_data.Async_unix__Io_uring,
    Core_Int = global_data.Core__Int,
    Time_float_unix = global_data.Time_float_unix,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Bin_prot_Common = global_data.Bin_prot__Common,
    Bin_prot_Write = global_data.Bin_prot__Write,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Base_Int63 = global_data.Base__Int63,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Field = global_data.Base__Field,
    Async_kernel_Async_invariant = global_data.Async_kernel__Async_invariant,
    Core_Bool = global_data.Core__Bool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Core_Unique_id = global_data.Core__Unique_id,
    Core_Hashable = global_data.Core__Hashable,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Bin_shape = global_data.Bin_shape,
    Expect_test_config = global_data.Expect_test_config,
    Ppx_expect_runtime_Test_block = global_data.Ppx_expect_runtime__Test_block,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Writer0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_writer0_ml$0);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "writer0.ml");
   var
    Id = caml_call1(Core_Unique_id[2], 0),
    debug = Async_kernel_Debug[14],
    _bV_ = [0, 523273847],
    cst_Writer_with_file_atomic_no$0 =
      "Writer.with_file_atomic: not replacing special file",
    cst_Writer_with_file_atomic_no =
      "Writer.with_file_atomic: not replacing a directory",
    _bS_ = [0, cst_src_writer0_ml$0, 1866, 11],
    cst_writer_closed_by_f = "writer closed by [f]",
    _bR_ = [0, "file"],
    cst_Error_in_Writer_with_file_ = "Error in Writer.with_file_atomic",
    _bT_ = [0, -146189108],
    _bU_ = [0, 3903734],
    _bZ_ = [0, "phys_equal stdout stderr"],
    _bY_ = [0, "Lazy.is_val stderr"],
    _bX_ = [0, "Lazy.is_val stdout"],
    cst_unable_to_create_stdout_st = "unable to create stdout/stderr",
    cst_src_writer0_ml_1767_35 = "src/writer0.ml:1767:35",
    _bP_ = [0, "size"],
    _bQ_ = [0, cst_written],
    cst_Writer_write_bin_prot_no_s =
      "Writer.write_bin_prot_no_size_header bug!",
    _bO_ = [0, [15, [17, 2, 0]], "%a@?"],
    _bM_ = [0, "Space_if_needed"],
    _bN_ = [0, "Newline"],
    _bL_ = [0, cst_exn],
    cst_Writer_write_gen_whole_err =
      "Writer.write_gen_whole: error writing value",
    _bK_ = [0, cst_exn],
    cst_Writer_write_gen_error_wri = "Writer.write_gen: error writing value",
    _bJ_ = [0, cst_src_writer0_ml$0, 1356, 6],
    _bI_ = [0, cst_src_writer0_ml$0, 1357, 6],
    _bF_ = [0, cst_writer],
    _bG_ = [0, "len"],
    _bH_ = [0, cst_written],
    cst_write_direct_s_f_argument_ =
      "[write_direct]'s [~f] argument returned invalid [written]",
    _bE_ = [0, cst_src_writer0_ml$0, 1236, 4],
    _bD_ = [0, cst_src_writer0_ml$0, 1237, 4],
    _bw_ = [0, "n"],
    cst_write_system_call_returned =
      "write system call returned negative result",
    cst_write_got_EBADF = "write got EBADF",
    _bv_ = [0, cst_src_writer0_ml$0, 1133, 8],
    cst_Writer_start_write = "Writer.start_write",
    _by_ = [0, cst_src_writer0_ml$0, 1110, 4],
    _bx_ = [0, 1],
    cst_writer_ready_to_got_Bad_fd = "writer ready_to got Bad_fd",
    cst_Writer_write_when_ready = "Writer.write_when_ready",
    _bz_ = [0, cst_src_writer0_ml$0, 1160, 4],
    cst_Writer_write_finished = "Writer.write_finished",
    _bB_ = [0, cst_src_writer0_ml$0, 1169, 4],
    _bA_ = [0, 1024986025, 1],
    _bC_ = [0, cst_open_flags],
    cst_not_allowed_to_write_due_t =
      "not allowed to write due to file-descriptor flags",
    cst_writer_wrote_nonzero_amoun =
      "writer wrote nonzero amount but IO_queue is empty",
    _bu_ = [0, cst_src_writer0_ml$0, 1076, 6],
    cst_writer_wrote_more_bytes_th =
      "writer wrote more bytes than it received",
    cst_writev = "writev",
    cst_writer_fd_unexpectedly_clo = "writer fd unexpectedly closed ",
    _bt_ = [0, cst_src_writer0_ml$0, 1000, 4],
    _bs_ = [0, cst_src_writer0_ml$0, 989, 4],
    _br_ = [0, cst_src_writer0_ml$0, 995, 4],
    _bq_ = [0, 523273847],
    _bp_ = [0, 523273847],
    cst_attempt_to_use_closed_writ = "attempt to use closed writer",
    _bo_ = [0, cst_writer],
    cst_Writer_error_from_inner_mo = "Writer error from inner_monitor",
    cst_Writer_create_buf_len_0 = "Writer.create: buf_len <= 0",
    _bm_ = [0, "Writer.monitor"],
    _bn_ = [0, "Writer.inner_monitor"],
    _bk_ = [0, cst_Unlimited$0],
    _bl_ = [0, cst_At_most$0],
    cst_Writer_at_shutdown = "Writer.at_shutdown",
    cst_Writer_close = "Writer.close",
    _bb_ = [0, cst_src_writer0_ml$0, 740, 15],
    _ba_ = [0, cst_src_writer0_ml$0, 721, 37],
    _a$_ = [0, 1024986025, 1],
    _a__ = [0, 523273847],
    _a9_ = [0, cst_src_writer0_ml$0, 626, 4],
    _a7_ = [0, 0],
    _a3_ = [0, cst_writer],
    _a4_ = [0, 0],
    _a5_ = [0, "beginning_of_buffer"],
    _a6_ = [0, cst_maximum_age],
    cst_writer_buffer_has_data_old = "writer buffer has data older than",
    _a1_ = [0, "_"],
    _aX_ = [0, cst_src_writer0_ml$0, 386, 17],
    _aZ_ = [0, cst_src_writer0_ml$0, 389, 13],
    _aY_ = [0, cst_src_writer0_ml$0, 390, 13],
    _aW_ = [0, cst_src_writer0_ml$0, 399, 15],
    _aV_ = [0, cst_src_writer0_ml$0, 374, 13],
    _a0_ = [0, cst_src_writer0_ml$0, 367, 6],
    _a2_ = [0, cst_src_writer0_ml$0, 365, 13890, 13914],
    _aF_ = [0, cst_writer],
    _aG_ = [0, cst_exn],
    cst_writer_invariant_failed = "writer invariant failed",
    _aS_ = [0, cst_src_writer0_ml$0, 288, 12],
    _aR_ = [0, cst_src_writer0_ml$0, 289, 12],
    _aQ_ = [0, cst_src_writer0_ml$0, 290, 12],
    _aU_ = [0, cst_src_writer0_ml$0, 285, 12],
    _aT_ = [0, cst_src_writer0_ml$0, 286, 12],
    _aP_ = [0, cst_src_writer0_ml$0, 295, 11],
    _aO_ = [0, cst_src_writer0_ml$0, 302, 15],
    _aN_ = [0, cst_src_writer0_ml$0, 308, 11],
    _aM_ = [0, cst_src_writer0_ml$0, 311, 11],
    _aL_ = [0, cst_src_writer0_ml$0, 312, 32],
    _aK_ = [0, cst_src_writer0_ml$0, 319, 45],
    _aI_ = [0, cst_src_writer0_ml$0, 333, 40],
    _aJ_ = [0, cst_src_writer0_ml$0, 332, 11],
    _aH_ = [0, cst_src_writer0_ml$0, 337, 46],
    _ax_ = [0, "Running"],
    _ay_ = [0, "Not_running"],
    _az_ = [0, "Stopped_permanently"],
    _at_ = [0, "Per_cycle"],
    _au_ = [0, "Periodic"],
    _ak_ = [0, "Open"],
    _al_ = [0, cst_Closed],
    _aj_ = [0, "Closed_and_flushing"],
    _$_ = [0, cst_backing_out_channel$0],
    _aa_ = [0, "line_ending"],
    _ab_ = [0, cst_open_flags],
    _ac_ = [0, "raise_when_consumer_leaves"],
    _ad_ = [0, cst_consumer_left$0],
    _ae_ = [0, "check_buffer_age"],
    _af_ = [0, cst_flush_at_shutdown_elt$0],
    _ag_ = [0, "num_producers_to_flush_at_close"],
    _ah_ = [0, cst_close_started$0],
    _ai_ = [0, cst_close_finished$0],
    _am_ = [0, "close_state"],
    _an_ = [0, "time_source"],
    _ao_ = [0, cst_back$0],
    _ap_ = [0, cst_scheduled_back$0],
    _aq_ = [0, cst_scheduled_bytes$0],
    _ar_ = [0, cst_bytes_written$0],
    _as_ = [0, "bytes_received"],
    _av_ = [0, "syscall"],
    _aw_ = [0, "background_writer_stopped"],
    _aA_ = [0, cst_background_writer_state$0],
    _aB_ = [0, "inner_monitor"],
    _aC_ = [0, "monitor"],
    _aD_ = [0, "fd"],
    _aE_ = [0, "id"],
    _C_ = [0, cst_Error],
    _D_ = [0, cst_Closed],
    _E_ = [0, cst_Consumer_left],
    _A_ = [0, "Keep"],
    _B_ = [0, "Destroy"],
    _x_ = [0, "Already_closed"],
    _y_ = [0, cst_Error],
    _z_ = [0, "Ok"],
    _n_ = [0, "for_this_time_source"],
    _o_ = [0, cst_too_old$0],
    _p_ = [0, "bytes_seen"],
    _q_ = [0, cst_times_received_queue$0],
    _r_ = [0, cst_bytes_received_queue$0],
    _s_ = [0, "bytes_received_at_now_minus_maximum_age"],
    _t_ = [0, cst_maximum_age],
    _u_ = [0, cst_writer],
    _v_ = [0, "closed"],
    _w_ = [0, "active_checks"],
    _f_ = [0, "Unix"],
    _g_ = [0, "Dos"],
    _b_ = [0, cst_Error],
    _c_ = [0, cst_Consumer_left],
    _d_ = [0, "Force_closed"],
    _e_ = [0, "Flushed"],
    _a_ = [1, 0],
    cst_too_old = cst_too_old$0,
    cst_times_received_queue = cst_times_received_queue$0,
    cst_bytes_received_queue = cst_bytes_received_queue$0,
    cst_backing_out_channel = cst_backing_out_channel$0,
    cst_consumer_left = cst_consumer_left$0,
    cst_flush_at_shutdown_elt = cst_flush_at_shutdown_elt$0,
    cst_close_started = cst_close_started$0,
    cst_close_finished = cst_close_finished$0,
    cst_back = cst_back$0,
    cst_scheduled_back = cst_scheduled_back$0,
    cst_scheduled_bytes = cst_scheduled_bytes$0,
    cst_scheduled = "scheduled",
    cst_bytes_written = cst_bytes_written$0,
    cst_background_writer_state = cst_background_writer_state$0,
    cst_Unlimited = cst_Unlimited$0,
    cst_At_most = cst_At_most$0,
    cst_src_writer0_ml_817_2 = "src/writer0.ml:817:2",
    cst_buffer_age_limit = cst_buffer_age_limit$1,
    cst_src_writer0_ml_816_0 = "src/writer0.ml:816:0",
    cst_buffer_age_limit$0 = cst_buffer_age_limit$1,
    _b0_ =
      [0,
       [0,
        [0, ' ("Lazy.is_val stdout" false) ', [0, cst$1]],
        [0, 60027, 60040, 60074]]],
    _b1_ = [0, 60027, 60031, 60075],
    _b4_ =
      [0,
       [0,
        [0, ' ("Lazy.is_val stderr" false) ', [0, cst$1]],
        [0, 60129, 60142, 60176]]],
    _b5_ = [0, 60129, 60133, 60177],
    _b8_ =
      [0,
       [0,
        [0, ' ("phys_equal stdout stderr" true) ', [0, cst$1]],
        [0, 60664, 60677, 60716]]],
    _b9_ = [0, 60664, 60668, 60717],
    _ca_ = [0, "stdout and stderr are always the same in tests"],
    _cd_ = [0, 59906, 59908, 60717],
    _ce_ = [0, 60664, 60717, 60717],
    _cf_ = [0, 59906, 59908, 60717],
    cst_src_writer0_ml = cst_src_writer0_ml$0,
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Writer0 = cst_Async_unix_Writer0$0;
   function sexp_of_t(param){
    if(typeof param === "number")
     switch(param){case 0: return _b_;case 1: return _c_;default: return _d_;}
    var
     arg0_001 = param[1],
     res0_002 =
       Ppx_inline_test_lib[1]
        ? _a_
        : caml_call1(Async_unix_Require_explicit_ti[9][78], arg0_001);
    return [1, [0, _e_, [0, res0_002, 0]]];
   }
   var Flush_result = [0, sexp_of_t];
   function sexp_of_t$0(param){return param ? _f_ : _g_;}
   var Line_ending = [0, sexp_of_t$0];
   function too_old(r){return r[7];}
   function set_too_old(r, v){r[7] = v; return 0;}
   function times_received_queue(r){return r[5];}
   function bytes_received_queue(r){return r[4];}
   function _h_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _i_ = [0, set_too_old],
    too_old$0 =
      [0, function(param){return 0;}, cst_too_old, _i_, too_old, _h_];
   function _j_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
   }
   var
    _k_ = 0,
    times_received_queue$0 =
      [0,
       function(param){return 0;},
       cst_times_received_queue,
       _k_,
       times_received_queue,
       _j_];
   function _l_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
   }
   var
    _m_ = 0,
    bytes_received_queue$0 =
      [0,
       function(param){return 0;},
       cst_bytes_received_queue,
       _m_,
       bytes_received_queue,
       _l_];
   function sexp_of_t$1(of_a_003, param){
    var
     maximum_age_007 = param[2],
     writer_005 = param[1],
     bytes_received_at_now_minus_ma = param[3],
     times_received_queue_013 = param[5],
     bytes_received_queue_011 = param[4],
     bytes_seen_015 = param[6],
     too_old_017 = param[7],
     for_this_time_source_019 = param[8],
     closed_025 = for_this_time_source_019[2],
     active_checks_023 = for_this_time_source_019[1],
     arg_026 = caml_call2(Async_kernel_Ivar[9], Core[620], closed_025),
     bnds_022 = [0, [1, [0, _v_, [0, arg_026, 0]]], 0],
     arg_024 =
       caml_call2(Core_Bag[3], Sexplib0_Sexp_conv[23], active_checks_023),
     bnds_022$0 = [0, [1, [0, _w_, [0, arg_024, 0]]], bnds_022],
     arg_020 = [1, bnds_022$0],
     bnds_004 = [0, [1, [0, _n_, [0, arg_020, 0]]], 0],
     arg_018 = caml_call2(Async_kernel_Ivar[9], Core[620], too_old_017),
     bnds_004$0 = [0, [1, [0, _o_, [0, arg_018, 0]]], bnds_004],
     arg_016 = caml_call1(Core_Int63[103], bytes_seen_015),
     bnds_004$1 = [0, [1, [0, _p_, [0, arg_016, 0]]], bnds_004$0],
     arg_014 =
       caml_call2
        (Core_Queue[13],
         Async_unix_Require_explicit_ti[9][78],
         times_received_queue_013),
     bnds_004$2 = [0, [1, [0, _q_, [0, arg_014, 0]]], bnds_004$1],
     arg_012 =
       caml_call2(Core_Queue[13], Core_Int63[103], bytes_received_queue_011),
     bnds_004$3 = [0, [1, [0, _r_, [0, arg_012, 0]]], bnds_004$2],
     arg_010 = caml_call1(Core_Int63[103], bytes_received_at_now_minus_ma),
     bnds_004$4 = [0, [1, [0, _s_, [0, arg_010, 0]]], bnds_004$3],
     arg_008 = caml_call1(Time_ns_unix[72][10], maximum_age_007),
     bnds_004$5 = [0, [1, [0, _t_, [0, arg_008, 0]]], bnds_004$4],
     arg_006 = caml_call1(of_a_003, writer_005),
     bnds_004$6 = [0, [1, [0, _u_, [0, arg_006, 0]]], bnds_004$5];
    return [1, bnds_004$6];
   }
   function sexp_of_open_flags(param){
    if(typeof param === "number") return _x_;
    if(106380200 <= param[1]){
     var v_028 = param[2];
     return [1, [0, _y_, [0, caml_call1(Core[625], v_028), 0]]];
    }
    var v_027 = param[2];
    return [1, [0, _z_, [0, caml_call1(Core_unix[50][2], v_027), 0]]];
   }
   function sexp_of_t$2(param){return param ? _A_ : _B_;}
   var Destroy_or_keep = [0, sexp_of_t$2];
   function backing_out_channel(r){return r[27];}
   function set_backing_out_channel(r, v){r[27] = v; return 0;}
   function raise_when_consumer_leaves(r){return r[24];}
   function consumer_left(r){return r[23];}
   function flush_at_shutdown_elt(r){return r[21];}
   function set_flush_at_shutdown_elt(r, v){r[21] = v; return 0;}
   function close_started(r){return r[19];}
   function close_finished(r){return r[18];}
   function back(r){return r[14];}
   function set_back(r, v){r[14] = v; return 0;}
   function scheduled_back(r){return r[13];}
   function set_scheduled_back(r, v){r[13] = v; return 0;}
   function scheduled_bytes(r){return r[11];}
   function set_scheduled_bytes(r, v){r[11] = v; return 0;}
   function scheduled(r){return r[10];}
   function bytes_written(r){return r[9];}
   function set_bytes_written(r, v){r[9] = v; return 0;}
   function bytes_received(r){return r[8];}
   function background_writer_state(r){return r[5];}
   function set_background_writer_state(r, v){r[5] = v; return 0;}
   function monitor(r){return r[3];}
   function fd(r){return r[2];}
   function id(r){return r[1];}
   function _F_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            v];
   }
   var
    _G_ = [0, set_backing_out_channel],
    backing_out_channel$0 =
      [0,
       function(param){return 0;},
       cst_backing_out_channel,
       _G_,
       backing_out_channel,
       _F_];
   function _H_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            v,
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _I_ = 0,
    consumer_left$0 =
      [0,
       function(param){return 0;},
       cst_consumer_left,
       _I_,
       consumer_left,
       _H_];
   function _J_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            v,
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _K_ = [0, set_flush_at_shutdown_elt],
    flush_at_shutdown_elt$0 =
      [0,
       function(param){return 0;},
       cst_flush_at_shutdown_elt,
       _K_,
       flush_at_shutdown_elt,
       _J_];
   function _L_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            v,
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _M_ = 0,
    close_started$0 =
      [0,
       function(param){return 0;},
       cst_close_started,
       _M_,
       close_started,
       _L_];
   function _N_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            v,
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _O_ = 0,
    close_finished$0 =
      [0,
       function(param){return 0;},
       cst_close_finished,
       _O_,
       close_finished,
       _N_];
   function _P_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            v,
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _Q_ = [0, set_back],
    back$0 = [0, function(param){return 0;}, cst_back, _Q_, back, _P_];
   function _R_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            v,
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _S_ = [0, set_scheduled_back],
    scheduled_back$0 =
      [0,
       function(param){return 0;},
       cst_scheduled_back,
       _S_,
       scheduled_back,
       _R_];
   function _T_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _U_ = [0, set_scheduled_bytes],
    scheduled_bytes$0 =
      [0,
       function(param){return 0;},
       cst_scheduled_bytes,
       _U_,
       scheduled_bytes,
       _T_];
   function _V_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            v,
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _W_ = 0,
    scheduled$0 =
      [0, function(param){return 0;}, cst_scheduled, _W_, scheduled, _V_];
   function _X_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _Y_ = [0, set_bytes_written],
    bytes_written$0 =
      [0,
       function(param){return 0;},
       cst_bytes_written,
       _Y_,
       bytes_written,
       _X_];
   function _Z_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    ___ = [0, set_background_writer_state],
    background_writer_state$0 =
      [0,
       function(param){return 0;},
       cst_background_writer_state,
       ___,
       background_writer_state,
       _Z_];
   function sexp_of_writer(t){return caml_call1(Async_unix_Fd[3], t[2]);}
   function sexp_of_t_internals(param){
    var
     id = param[1],
     fd = param[2],
     inner_monitor = param[4],
     monitor = param[3],
     background_writer_state = param[5],
     syscall = param[7],
     background_writer_stopped = param[6],
     bytes_received = param[8],
     bytes_written = param[9],
     scheduled_bytes = param[11],
     scheduled_back = param[13],
     back = param[14],
     time_source = param[15],
     close_state = param[17],
     producers_to_flush_at_close = param[20],
     close_started = param[19],
     close_finished = param[18],
     flush_at_shutdown_elt = param[21],
     check_buffer_age = param[22],
     consumer_left = param[23],
     raise_when_consumer_leaves = param[24],
     line_ending = param[26],
     open_flags = param[25],
     backing_out_channel = param[27];
    function suppress_in_test(x){return Ppx_inline_test_lib[1] ? 0 : [0, x];}
    function monitor_name_in_test(monitor){
     if(! Ppx_inline_test_lib[1])
      return caml_call1(Async_kernel_Monitor[1], monitor);
     var _iu_ = caml_call1(Async_kernel_Monitor[4], monitor);
     return caml_call1(Core_Info[9], _iu_);
    }
    var
     time_source$0 =
       time_source === caml_call1(Async_kernel_Time_source[10], 0)
        ? 0
        : [0, time_source],
     match = suppress_in_test(id),
     match$0 = suppress_in_test(fd),
     match$1 = suppress_in_test(flush_at_shutdown_elt),
     match$2 = suppress_in_test(check_buffer_age),
     match$3 = suppress_in_test(open_flags),
     match$4 = 0;
    if(backing_out_channel)
     var
      v = backing_out_channel[1],
      _hY_ =
        [0,
         [1,
          [0, _$_, [0, caml_call1(Async_unix_Backing_out_channel[1], v), 0]]],
         match$4];
    else
     var _hY_ = match$4;
    var
     match$5 =
       [0,
        [1, [0, _aa_, [0, caml_call1(Line_ending[1], line_ending), 0]]],
        _hY_];
    if(match$3)
     var
      v$0 = match$3[1],
      _hZ_ = [0, [1, [0, _ab_, [0, sexp_of_open_flags(v$0), 0]]], match$5];
    else
     var _hZ_ = match$5;
    var
     _h0_ =
       [0,
        [1,
         [0, _ac_, [0, caml_call1(Core[323], raise_when_consumer_leaves), 0]]],
        _hZ_],
     match$6 =
       [0,
        [1,
         [0,
          _ad_,
          [0, caml_call2(Async_kernel_Ivar[9], Core[620], consumer_left), 0]]],
        _h0_];
    if(match$2)
     var
      x_035 = match$2[1],
      _h1_ = 0,
      _h2_ = Sexplib0_Sexp_conv[23],
      _h3_ = function(_it_){return sexp_of_t$1(_h2_, _it_);},
      _h4_ = caml_call1(Core_Bag[1][2], _h3_),
      _h5_ = caml_call1(Core[515], _h4_),
      match$7 =
        [0,
         [1, [0, _ae_, [0, caml_call2(Core_Lazy[23], _h5_, x_035), _h1_]]],
         match$6];
    else
     var match$7 = match$6;
    if(match$1)
     var
      x_034 = match$1[1],
      _h6_ = caml_call1(Core_Bag[1][2], Sexplib0_Sexp_conv[23]),
      _h7_ =
        [0,
         [1, [0, _af_, [0, caml_call2(Core[515], _h6_, x_034), 0]]],
         match$7];
    else
     var _h7_ = match$7;
    var
     _h8_ = caml_call1(Core_Bag[5], producers_to_flush_at_close),
     _h9_ = [0, [1, [0, _ag_, [0, caml_call1(Core[389], _h8_), 0]]], _h7_],
     _h__ =
       [0,
        [1,
         [0,
          _ah_,
          [0, caml_call2(Async_kernel_Ivar[9], Core[620], close_started), 0]]],
        _h9_],
     _h$_ =
       [0,
        [1,
         [0,
          _ai_,
          [0, caml_call2(Async_kernel_Ivar[9], Core[620], close_finished), 0]]],
        _h__],
     _ia_ = 0,
     _ib_ =
       -752096295 === close_state
        ? _aj_
        : 881668074 <= close_state ? _ak_ : _al_,
     match$8 = [0, [1, [0, _am_, [0, _ib_, _ia_]]], _h$_];
    if(time_source$0)
     var
      v$1 = time_source$0[1],
      _ic_ =
        [0,
         [1, [0, _an_, [0, caml_call1(Async_kernel_Time_source[4], v$1), 0]]],
         match$8];
    else
     var _ic_ = match$8;
    var
     _id_ = [0, [1, [0, _ao_, [0, caml_call1(Core[389], back), 0]]], _ic_],
     _ie_ =
       [0,
        [1, [0, _ap_, [0, caml_call1(Core[389], scheduled_back), 0]]],
        _id_],
     _if_ =
       [0,
        [1, [0, _aq_, [0, caml_call1(Core[389], scheduled_bytes), 0]]],
        _ie_],
     _ig_ =
       [0,
        [1, [0, _ar_, [0, caml_call1(Core_Int63[103], bytes_written), 0]]],
        _if_],
     _ih_ =
       [0,
        [1, [0, _as_, [0, caml_call1(Core_Int63[103], bytes_received), 0]]],
        _ig_],
     _ii_ = 0;
    if(typeof syscall === "number")
     var _ij_ = _at_;
    else
     var
      v_031 = syscall[2],
      _ij_ = [1, [0, _au_, [0, caml_call1(Time_float_unix[1][10], v_031), 0]]];
    var
     _ik_ =
       [0,
        [1,
         [0,
          _aw_,
          [0,
           caml_call2
            (Async_kernel_Ivar[9], Core[620], background_writer_stopped),
           0]]],
        [0, [1, [0, _av_, [0, _ij_, _ii_]]], _ih_]],
     _il_ = 0;
    if(typeof background_writer_state === "number")
     var _io_ = 951752159 <= background_writer_state ? _ax_ : _ay_;
    else{
     var v_029 = background_writer_state[2], _im_ = 0;
     switch(v_029){
       case 0:
        var _in_ = _C_; break;
       case 1:
        var _in_ = _D_; break;
       default: var _in_ = _E_;
     }
     var _io_ = [1, [0, _az_, [0, _in_, _im_]]];
    }
    var
     _ip_ = monitor_name_in_test(inner_monitor),
     _iq_ =
       [0,
        [1, [0, _aB_, [0, caml_call1(Core_Sexp[93], _ip_), 0]]],
        [0, [1, [0, _aA_, [0, _io_, _il_]]], _ik_]],
     _ir_ = monitor_name_in_test(monitor),
     match$9 =
       [0, [1, [0, _aC_, [0, caml_call1(Core_Sexp[93], _ir_), 0]]], _iq_];
    if(match$0)
     var
      v$2 = match$0[1],
      match$10 =
        [0,
         [1, [0, _aD_, [0, caml_call1(Async_unix_Fd[2], v$2), 0]]],
         match$9];
    else
     var match$10 = match$9;
    if(match)
     var
      v$3 = match[1],
      _is_ = [0, [1, [0, _aE_, [0, caml_call1(Id[10], v$3), 0]]], match$10];
    else
     var _is_ = match$10;
    return [1, _is_];
   }
   function set_raise_when_consumer_leaves(t, bool){t[24] = bool; return 0;}
   function bytes_to_write(t){return (t[11] + t[14] | 0) - t[13] | 0;}
   function is_stopped_permanently(t){
    return typeof t[5] === "number" ? 0 : 1;
   }
   function invariant(t){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, t));
        },
      _hy_ = caml_call1(Core_Option[20], Async_unix_Backing_out_channel[2]),
      _hz_ =
        function(consumer_left){
         var _hX_ = caml_call1(Async_kernel_Ivar[18], consumer_left);
         if(! _hX_) return _hX_;
         if(is_stopped_permanently(t)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aH_], 1);
        },
      _hA_ =
        function(o){
         var
          _hU_ = caml_call1(Async_kernel_Ivar[18], t[18]),
          _hV_ = caml_call1(Core[252], o);
         if(! caml_call2(Core_Bool[32], _hV_, _hU_))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aJ_], 1);
         function _hW_(elt){
          if(t === caml_call1(Core_Bag[1][3], elt)) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aI_], 1);
         }
         return caml_call2(Core_Option[46], o, _hW_);
        },
      _hB_ =
        function(close_started){
         var
          got = caml_call1(Async_kernel_Ivar[17], close_started),
          expect = 881668074 <= t[17] ? 1 : 0,
          sexpifier = Core[323],
          equal = 0,
          message = 0,
          here = 0;
         function comparator(a_037, b_038){
          return caml_call2(Core[316], a_037, b_038);
         }
         return caml_call8
                 (Ppx_assert_lib_Runtime[3],
                  pos,
                  sexpifier,
                  comparator,
                  here,
                  message,
                  equal,
                  expect,
                  got);
        },
      _hC_ =
        function(close_finished){
         if(-752096295 > t[17]) return 0;
         if(caml_call1(Async_kernel_Ivar[17], close_finished)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aK_], 1);
        },
      _hD_ =
        function(back){
         var _hT_ = caml_call1(Core_Bigstring[21], t[12]);
         if(caml_call2(Async_unix_Import[2], back, _hT_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aL_], 1);
        },
      _hE_ =
        function(scheduled_back){
         if
          (caml_call2(Async_unix_Import[2], 0, scheduled_back)
           && caml_call2(Async_unix_Import[2], scheduled_back, t[14]))
          return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aM_], 1);
        },
      _hF_ =
        function(scheduled_bytes){
         var t$0 = t[10];
         function _hR_(n, param){
          var iovec = param[1];
          return n + iovec[3] | 0;
         }
         var _hS_ = caml_call3(Core_Deque[18], t$0, 0, _hR_);
         if(caml_call2(Async_unix_Import[3], scheduled_bytes, _hS_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aN_], 1);
        },
      _hG_ =
        function(scheduled){
         function _hO_(param){
          var
           kind = param[2],
           iovec = param[1],
           _hP_ = t[12] === iovec[1] ? 1 : 0;
          if(! _hP_) return _hP_;
          var _hQ_ = kind ? 1 : 0;
          if(_hQ_) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aO_], 1);
         }
         return caml_call2(Core_Deque[17], scheduled, _hO_);
        },
      _hH_ =
        function(bytes_written){
         if
          (caml_call2(Core_Int63[108], Core_Int63[16], bytes_written)
           && caml_call2(Core_Int63[108], bytes_written, t[8]))
          return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aP_], 1);
        };
     check
      (function(param){
        if(typeof param === "number"){
         var _hJ_ = caml_call1(Core_Bigstring[21], t[12]);
         if(! caml_call2(Async_unix_Import[4], _hJ_, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
         var
          _hK_ = bytes_to_write(t),
          _hL_ = caml_call1(Core_Int63[72], _hK_),
          _hM_ = caml_call2(Core_Int63[20], t[8], t[9]);
         if(! caml_call2(Core_Int63[109], _hM_, _hL_))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aR_], 1);
         if(caml_call1(Async_kernel_Ivar[17], t[6])) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
        }
        var _hN_ = bytes_to_write(t);
        if(! caml_call2(Async_unix_Import[3], _hN_, 0))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aU_], 1);
        if(caml_call1(Async_kernel_Ivar[18], t[6])) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _aT_], 1);
       },
       background_writer_state$0);
     check(_hH_, bytes_written$0);
     check(_hG_, scheduled$0);
     check(_hF_, scheduled_bytes$0);
     check(_hE_, scheduled_back$0);
     check(_hD_, back$0);
     check(_hC_, close_finished$0);
     check(_hB_, close_started$0);
     check(_hA_, flush_at_shutdown_elt$0);
     check(_hz_, consumer_left$0);
     var _hI_ = check(_hy_, backing_out_channel$0);
     return _hI_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _hv_ = [0, [1, [0, _aF_, [0, sexp_of_t_internals(t), 0]]], 0],
      _hw_ = [0, [1, [0, _aG_, [0, caml_call1(Core[625], exn), 0]]], _hv_],
      _hx_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_writer_invariant_failed),
          _hw_]];
     return caml_call1(Core[261], _hx_);
    }
   }
   function elt_invariant(t){
    function _hh_(param){
     function check(f, field){
      return caml_call1(f, caml_call2(Base_Field[3], field, t));
     }
     var
      _hj_ = caml_call1(Core_Queue[16], t[5]),
      _hk_ = caml_call1(Core_Queue[16], t[4]);
     if(! caml_call2(Async_unix_Import[3], _hk_, _hj_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a0_], 1);
     function _hl_(ivar){
      var
       b = caml_call1(Async_kernel_Ivar[18], ivar),
       a = caml_call2(Base_Int63[98][10], t[3], t[1][9]),
       _ht_ = 1 - a,
       _hu_ = _ht_ || b;
      if(_hu_) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _aV_], 1);
     }
     function _hm_(q){
      var expect = caml_call1(Core_Queue[28], q);
      if(! expect) return 0;
      var
       got =
         caml_call2
          (Core_List[79], expect, Async_unix_Require_explicit_ti[9][89]),
       equal = 0,
       message = 0,
       here = 0;
      function sexpifier(x_044){
       return caml_call2
               (Core[472], Async_unix_Require_explicit_ti[9][78], x_044);
      }
      function comparator(a_040, b_041){
       function _hs_(a_042, b_043){
        return caml_call2(Async_unix_Require_explicit_ti[9][89], a_042, b_043);
       }
       return caml_call3(Core[466], _hs_, a_040, b_041);
      }
      caml_call8
       (Ppx_assert_lib_Runtime[3],
        pos$0,
        sexpifier,
        comparator,
        here,
        message,
        equal,
        expect,
        got);
      var
       _ho_ = t[2],
       _hp_ = caml_call1(Core_List[84], expect),
       _hq_ = caml_call1(Core_List[117], expect),
       _hr_ = caml_call2(Async_unix_Require_explicit_ti[9][45], _hq_, _hp_);
      if(caml_call2(Time_ns_unix[72][16], _hr_, _ho_)) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _aW_], 1);
     }
     check
      (function(q){
        function _hn_(prev, count){
         if(caml_call2(Core_Int63[111], prev, count)) return count;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aX_], 1);
        }
        var n = caml_call3(Core_Queue[19], q, t[3], _hn_);
        if(! caml_call2(Core_Int63[108], n, t[1][8]))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aZ_], 1);
        if(caml_call2(Core_Int63[109], n, t[6])) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _aY_], 1);
       },
       bytes_received_queue$0);
     check(_hm_, times_received_queue$0);
     check(_hl_, too_old$0);
     return 0;
    }
    function _hi_(x_039){
     return sexp_of_t$1(function(param){return _a1_;}, x_039);
    }
    return caml_call4(Async_kernel_Async_invariant[1], _a2_, t, _hi_, _hh_);
   }
   var dummy = 0;
   function process_active_check(e){
    var now = caml_call1(Async_kernel_Time_source[14], e[1][15]);
    a:
    for(;;){
     if(! (1 - caml_call1(Core_Queue[17], e[4]))) break a;
     var
      bytes_received = caml_call1(Core_Queue[50], e[4]),
      time_received = caml_call1(Core_Queue[50], e[5]),
      bytes_are_written = caml_call2(Core_Int63[108], bytes_received, e[1][9]),
      _g8_ = e[2],
      _g9_ =
        caml_call2(Async_unix_Require_explicit_ti[9][45], now, time_received),
      bytes_are_too_old = caml_call2(Time_ns_unix[72][18], _g9_, _g8_);
     if(bytes_are_too_old) e[3] = bytes_received;
     var bytes_are_written$0 = bytes_are_written || bytes_are_too_old;
     if(! bytes_are_written$0) break;
     caml_call1(Core_Queue[46], e[4]);
     caml_call1(Core_Queue[46], e[5]);
    }
    var bytes_received$0 = e[1][8], bytes_written = e[1][9];
    if(caml_call2(Base_Int63[98][10], bytes_received$0, e[6])){
     e[6] = bytes_received$0;
     if(caml_call2(Base_Int63[98][10], bytes_received$0, bytes_written)){
      caml_call2(Core_Queue[43], e[4], e[1][8]);
      caml_call2(Core_Queue[43], e[5], now);
     }
    }
    var too_old = caml_call2(Base_Int63[98][10], e[3], bytes_written);
    if(caml_call1(Async_kernel_Ivar[18], e[7])){
     if(! too_old){e[7] = caml_call1(Async_kernel_Ivar[12], 0); return 0;}
    }
    else if(too_old){
     caml_call2(Async_kernel_Ivar[14], e[7], 0);
     var
      writer = e[1],
      _g__ = [0, [1, [0, _a3_, [0, sexp_of_writer(writer), 0]]], 0],
      _g$_ = writer[12],
      _ha_ = caml_call1(Core_Bigstring[21], writer[12]),
      _hb_ = [0, caml_call2(Core_Int[89], 1024, _ha_)],
      _hc_ = caml_call3(Core_Bigstring[16], _a4_, _hb_, _g$_),
      _hd_ = [0, [1, [0, _a5_, [0, caml_call1(Core[558], _hc_), 0]]], _g__],
      _he_ =
        [0,
         [1, [0, _a6_, [0, caml_call1(Time_ns_unix[72][10], e[2]), 0]]],
         _hd_],
      _hf_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_writer_buffer_has_data_old),
          _he_]],
      _hg_ = caml_call1(Base_Exn[5], _hf_);
     return caml_call3(Async_kernel_Monitor[15], e[1][3], 0, _hg_);
    }
    return 0;
   }
   function check(t){
    return caml_call2(Core_Bag[7], t[1], process_active_check);
   }
   var sexp_of_t$3 = Async_kernel_Time_source[4];
   function hash_fold_t(state, t){
    var _g7_ = caml_call1(Async_kernel_Time_source[5], t);
    return caml_call2(Async_kernel_Time_source[3][35], state, _g7_);
   }
   function hash(t){
    var _g6_ = caml_call1(Async_kernel_Time_source[5], t);
    return caml_call1(Async_kernel_Time_source[3][36], _g6_);
   }
   function compare(t1, t2){
    var
     _g4_ = caml_call1(Async_kernel_Time_source[5], t2),
     _g5_ = caml_call1(Async_kernel_Time_source[5], t1);
    return caml_call2(Async_kernel_Time_source[3][20], _g5_, _g4_);
   }
   var
    Time_source_key =
      caml_call1
       (Core_Hashable[1], [0, hash_fold_t, compare, sexp_of_t$3, hash]),
    by_time_source = caml_call3(Time_source_key[5][5], 0, 0, 0);
   function num_active_checks_for(time_source){
    function _g2_(pt){return caml_call1(Core_Bag[5], pt[1]);}
    var _g3_ = caml_call2(Core_Hashtbl[56], by_time_source, time_source);
    return caml_call2(Core_Option[34], _g3_, _g2_);
   }
   function check_now(check_invariants, time_source){
    var t = caml_call2(Core_Hashtbl[57], by_time_source, time_source);
    if(check_invariants) caml_call2(Core_Bag[7], t[1], elt_invariant);
    return check(t);
   }
   function create(writer, maximum_age){
    if(typeof maximum_age === "number") return 0;
    var maximum_age$0 = maximum_age[2], time_source = writer[15];
    function _gR_(param){
     var
      _gY_ = caml_call1(Async_kernel_Ivar[12], 0),
      pt = [0, caml_call1(Core_Bag[22], 0), _gY_];
     function _gZ_(param){return check(pt);}
     var
      _g0_ = Time_ns_unix[72][71],
      _g1_ = [0, caml_call1(Async_kernel_Ivar[19], pt[2])];
     caml_call6
      (Async_kernel_Time_source[37], 0, _g1_, _a7_, time_source, _g0_, _gZ_);
     return pt;
    }
    var
     for_this_time_source =
       caml_call3(Core_Hashtbl[54], by_time_source, time_source, _gR_),
     _gS_ = caml_call1(Async_kernel_Ivar[12], 0),
     _gT_ = Core_Int63[16],
     _gU_ = caml_call2(Core_Queue[66], 0, 0),
     _gV_ = caml_call2(Core_Queue[66], 0, 0),
     _gW_ = Core_Int63[16],
     _gX_ =
       [0,
        writer,
        caml_call1(Time_ns_unix[72][146], maximum_age$0),
        _gW_,
        _gV_,
        _gU_,
        _gT_,
        _gS_,
        for_this_time_source];
    return [0, caml_call2(Core_Bag[23], for_this_time_source[1], _gX_)];
   }
   function destroy(t){
    if(! t) return;
    var
     elt = t[1],
     t$0 = caml_call1(Core_Bag[1][3], elt),
     per_time_source = t$0[8];
    caml_call2(Core_Bag[26], per_time_source[1], elt);
    var _gQ_ = caml_call1(Core_Bag[6], per_time_source[1]);
    return _gQ_
            ? (caml_call2
               (Core_Hashtbl[32], by_time_source, t$0[1][15]),
              caml_call2(Async_kernel_Ivar[16], per_time_source[2], 0))
            : _gQ_;
   }
   var _a8_ = [0, check_now, num_active_checks_for];
   function flushed_or_failed_with_result(t){
    var match = t[27];
    if(match){
     var backing_out_channel = match[1];
     caml_call1(Async_unix_Backing_out_channel[6], backing_out_channel);
     var _gM_ = [0, caml_call1(Async_kernel_Time_source[14], t[15])];
     return caml_call1(Async_unix_Import[30], _gM_);
    }
    if(caml_call2(Base_Int63[98][9], t[9], t[8])){
     var _gN_ = [0, caml_call1(Async_kernel_Time_source[14], t[15])];
     return caml_call1(Async_unix_Import[30], _gN_);
    }
    var _gO_ = t[5];
    if(typeof _gO_ !== "number")
     switch(_gO_[2]){
       case 0:
        return caml_call1(Async_unix_Import[30], 0);
       case 1:
        return caml_call1(Async_unix_Import[30], 2);
       default: return caml_call1(Async_unix_Import[30], 1);
     }
    if(caml_call1(Async_kernel_Ivar[18], t[18]))
     return caml_call1(Async_kernel_Deferred[12], 0);
    function _gP_(ivar){
     return caml_call2(Core_Queue[43], t[16], [0, ivar, t[8]]);
    }
    return caml_call1(Async_kernel_Deferred[3], _gP_);
   }
   function eager_map(t, f){
    if(! caml_call1(Async_kernel_Deferred[7], t))
     return caml_call2(Async_kernel_Deferred[13], t, f);
    var _gL_ = caml_call1(f, caml_call1(Async_kernel_Deferred[6], t));
    return caml_call1(Async_unix_Import[30], _gL_);
   }
   function flushed_or_failed_unit(t){
    function _gJ_(_gK_){return 0;}
    return eager_map(flushed_or_failed_with_result(t), _gJ_);
   }
   function flushed_time_ns(t){
    function f(param){
     if(typeof param === "number")
      return caml_call1(Async_kernel_Deferred[19], 0);
     var t = param[1];
     return caml_call1(Async_kernel_Deferred[12], t);
    }
    var t$0 = flushed_or_failed_with_result(t);
    return caml_call1(Async_kernel_Deferred[7], t$0)
            ? f(caml_call1(Async_kernel_Deferred[6], t$0))
            : caml_call2(Async_kernel_Deferred[11], t$0, f);
   }
   function flushed_time(t){
    var _gI_ = Async_unix_Require_explicit_ti[9][64];
    return eager_map(flushed_time_ns(t), _gI_);
   }
   function flushed(t){
    function _gG_(_gH_){return 0;}
    return eager_map(flushed_time_ns(t), _gG_);
   }
   function set_backing_out_channel$0(t, backing_out_channel){t[27] = [0, backing_out_channel]; return;
   }
   function set_synchronous_backing_out_ch(t, backing_out_channel){
    function wait_until_no_bytes_to_write(param){
     var _gD_ = bytes_to_write(t);
     if(caml_call2(Async_unix_Import[3], _gD_, 0)){
      set_backing_out_channel$0(t, backing_out_channel);
      return caml_call1(Async_unix_Import[30], 0);
     }
     function _gE_(param){return wait_until_no_bytes_to_write(0);}
     var _gF_ = flushed(t);
     return caml_call2(Async_unix_Import[33][2], _gF_, _gE_);
    }
    return wait_until_no_bytes_to_write(0);
   }
   function set_synchronous_out_channel(t, out_channel){
    return set_synchronous_backing_out_ch
            (t, caml_call1(Async_unix_Backing_out_channel[3], out_channel));
   }
   function using_synchronous_backing_out_(t){
    return caml_call1(Core_Option[62], t[27]);
   }
   function clear_synchronous_out_channel(t){
    var _gA_ = caml_call1(Core[253], t[27]);
    if(_gA_){
     var _gB_ = bytes_to_write(t);
     if(! caml_call2(Async_unix_Import[3], _gB_, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a9_], 1);
     t[27] = 0;
     var _gC_ = 0;
    }
    else
     var _gC_ = _gA_;
    return _gC_;
   }
   function with_synchronous_backing_out_c(t, backing_out_channel, f){
    var saved_backing_out_channel = t[27];
    function _gw_(param){
     t[27] = saved_backing_out_channel;
     return caml_call1(Async_unix_Import[30], 0);
    }
    function _gx_(param){
     function _gy_(param){return caml_call1(f, 0);}
     var _gz_ = set_synchronous_backing_out_ch(t, backing_out_channel);
     return caml_call2(Async_unix_Import[33][2], _gz_, _gy_);
    }
    return caml_call8
            (Async_kernel_Monitor[23], 0, 0, 0, 0, _a__, 0, _gx_, _gw_);
   }
   function with_synchronous_out_channel(t, out_channel, f){
    return with_synchronous_backing_out_c
            (t, caml_call1(Async_unix_Backing_out_channel[3], out_channel), f);
   }
   function set_fd(t, fd){
    function _gu_(param){t[2] = fd; return 0;}
    var _gv_ = flushed(t);
    return caml_call2(Async_unix_Import[33][3], _gv_, _gu_);
   }
   function consumer_left$1(t){
    return caml_call1(Async_kernel_Ivar[19], t[23]);
   }
   function close_finished$1(t){
    return caml_call1(Async_kernel_Ivar[19], t[18]);
   }
   function close_started$1(t){
    return caml_call1(Async_kernel_Ivar[19], t[19]);
   }
   function is_closed(t){return 881668074 <= t[17] ? 0 : 1;}
   function is_open(t){return 1 - is_closed(t);}
   var writers_to_flush_at_shutdown = caml_call1(Core_Bag[22], 0);
   function final_flush(force, t){
    function _gl_(f){return caml_call1(f, 0);}
    var
     _gm_ = caml_call1(Core_Bag[17], t[20]),
     producers_flushed =
       caml_call3(Async_kernel_Deferred_list[14], -676829465, _gm_, _gl_);
    a:
    if(force)
     var fc = force[1], force$0 = fc;
    else{
     var match = caml_call1(Async_unix_Fd[8], t[2]);
     if(typeof match === "number" && 2 <= match){
      var force$0 = caml_call1(Async_kernel_Deferred[19], 0);
      break a;
     }
     var
      _gk_ = caml_call1(Time_ns_unix[72][82], 5.),
      force$0 = caml_call2(Async_kernel_Time_source[29], t[15], _gk_);
    }
    var _go_ = t[22], _gp_ = caml_obj_tag(_go_);
    a:
    {
     var _gn_ = 0;
     if(250 === _gp_)
      var t$0 = _go_[1];
     else{
      if(246 !== _gp_ && 244 !== _gp_){var t$0 = _go_; break a;}
      var t$0 = caml_call1(CamlinternalLazy[2], _go_);
     }
    }
    if(t$0)
     var
      elt = t$0[1],
      _gj_ = caml_call1(Core_Bag[1][3], elt)[7],
      _gq_ = caml_call1(Async_kernel_Ivar[19], _gj_);
    else
     var _gq_ = caml_call1(Async_kernel_Deferred[19], 0);
    var
     _gr_ = [0, producers_flushed, [0, flushed(t), 0]],
     _gs_ =
       [0,
        caml_call1(Async_kernel_Deferred[22], _gr_),
        [0, force$0, [0, _gq_, _gn_]]],
     _gt_ = [0, consumer_left$1(t), _gs_];
    return caml_call1(Async_kernel_Deferred[24], _gt_);
   }
   function do_close_noflush(t){
    if(-752096295 > t[17]) return 0;
    t[17] = -1025106484;
    caml_call2(Async_kernel_Ivar[16], t[19], 0);
    if(caml_call1(Core_Lazy[40], t[22]))
     destroy(caml_call1(Core[248], t[22]));
    var match = t[21];
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bb_], 1);
    var elt = match[1];
    caml_call2(Core_Bag[26], writers_to_flush_at_shutdown, elt);
    function _gi_(param){return caml_call2(Async_kernel_Ivar[14], t[18], 0);}
    if(-752096295 <= t[17])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ba_], 1);
    var _ge_ = t[5];
    a:
    if(typeof _ge_ === "number" && -560725133 === _ge_){
     t[5] = _a$_;
     caml_call2(Async_kernel_Ivar[16], t[6], 0);
     break a;
    }
    function _gf_(param){return caml_call1(Async_kernel_Ivar[19], t[6]);}
    var
     _gg_ = caml_call2(Async_unix_Unix_syscalls[16], 0, t[2]),
     _gh_ = caml_call2(Async_unix_Import[33][2], _gg_, _gf_);
    return caml_call2(Async_unix_Import[27], _gh_, _gi_);
   }
   function close_internal(flush, t){
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_Writer_close, t, sexp_of_writer);
    if(typeof flush === "number"){
     do_close_noflush(t);
     return close_finished$1(t);
    }
    var force = flush[2];
    if(881668074 <= t[17]){
     t[17] = -752096295;
     caml_call2(Async_kernel_Ivar[14], t[19], 0);
     var
      _gc_ = function(param){return do_close_noflush(t);},
      _gd_ = final_flush(force, t);
     caml_call2(Async_unix_Import[27], _gd_, _gc_);
    }
    return close_finished$1(t);
   }
   function close(force_close, t){
    return close_internal([0, 365482660, force_close], t);
   }
   function close_noflush(t){return close_internal(-206574298, t);}
   function _bc_(param){
    if(debug) caml_call1(Async_kernel_Debug[16], cst_Writer_at_shutdown);
    function _f__(t){
     var
      _ga_ = [0, close_finished$1(t), 0],
      _gb_ = [0, final_flush(0, t), _ga_];
     return caml_call1(Async_kernel_Deferred[24], _gb_);
    }
    var _f$_ = caml_call1(Core_Bag[17], writers_to_flush_at_shutdown);
    return caml_call3(Async_kernel_Deferred_list[14], -676829465, _f$_, _f__);
   }
   caml_call1(Async_unix_Shutdown[11], _bc_);
   function stop_permanently(t, outcome){
    t[5] = [0, 1024986025, outcome];
    caml_call1(Core_Deque[54], t[10]);
    t[11] = 0;
    t[12] = caml_call1(Core_Bigstring[121], 0);
    t[13] = 0;
    t[14] = 0;
    caml_call2(Async_kernel_Ivar[16], t[6], 0);
    function _f8_(param){
     var ivar = param[1];
     switch(outcome){
       case 0:
        var _f9_ = 0; break;
       case 1:
        var _f9_ = 2; break;
       default: var _f9_ = 1;
     }
     return caml_call2(Async_kernel_Ivar[14], ivar, _f9_);
    }
    caml_call2(Core_Queue[18], t[16], _f8_);
    return caml_call1(Core_Queue[51], t[16]);
   }
   function stopped_permanently(t){
    return caml_call1(Async_kernel_Ivar[19], t[6]);
   }
   function die(t, sexp){
    stop_permanently(t, 0);
    return caml_call1(Core[261], sexp);
   }
   var
    _bd_ = [0, caml_call2(Bin_prot_Shape[6], cst_Unlimited, 0), 0],
    _be_ =
      [0,
       caml_call2(Bin_prot_Shape[6], cst_At_most, [0, Time_float_unix[1][5]]),
       _bd_],
    _bf_ = caml_call1(Bin_shape[4][1], cst_src_writer0_ml_817_2),
    _bg_ = caml_call2(Bin_prot_Shape[8], _bf_, _be_),
    _bh_ =
      [0, [0, caml_call1(Bin_shape[2][1], cst_buffer_age_limit), 0, _bg_], 0],
    _bi_ = caml_call1(Bin_shape[4][1], cst_src_writer0_ml_816_0),
    group = caml_call2(Bin_prot_Shape[2], _bi_, _bh_),
    _bj_ = caml_call1(Bin_shape[2][1], cst_buffer_age_limit$0),
    bin_shape_buffer_age_limit =
      caml_call1(caml_call2(Bin_prot_Shape[10], group, _bj_), 0);
   function bin_size_buffer_age_limit(param){
    if(typeof param !== "number" && -339018129 === param[1]){
     var args = param[2], size_args = caml_call1(Time_float_unix[1][1], args);
     return caml_call2(Bin_prot_Common[23], size_args, 4);
    }
    return 4;
   }
   function bin_write_buffer_age_limit(buf, pos, param){
    if(typeof param === "number")
     return caml_call3(Bin_prot_Write[29], buf, pos, 751362817);
    var
     args = param[2],
     pos$0 = caml_call3(Bin_prot_Write[29], buf, pos, -339018129);
    return caml_call3(Time_float_unix[1][2], buf, pos$0, args);
   }
   var
    bin_writer_buffer_age_limit =
      [0, bin_size_buffer_age_limit, bin_write_buffer_age_limit];
   function bin_read_buffer_age_limit(buf, pos_ref, vint){
    if(-339018129 === vint){
     var arg_1 = caml_call2(Time_float_unix[1][3], buf, pos_ref);
     return [0, -339018129, arg_1];
    }
    if(751362817 === vint) return 751362817;
    throw caml_maybe_attach_backtrace(Bin_prot_Common[13], 0);
   }
   function bin_read_buffer_age_limit$0(buf, pos_ref){
    var vint = caml_call2(Bin_prot_Read[28], buf, pos_ref);
    try{var _f6_ = bin_read_buffer_age_limit(buf, pos_ref, vint); return _f6_;
    }
    catch(_f7_){
     var _f5_ = caml_wrap_exception(_f7_);
     if(_f5_ === Bin_prot_Common[13])
      return caml_call2(Bin_prot_Common[18], err, pos_ref[1]);
     throw caml_maybe_attach_backtrace(_f5_, 0);
    }
   }
   var
    bin_reader_buffer_age_limit =
      [0, bin_read_buffer_age_limit$0, bin_read_buffer_age_limit],
    bin_buffer_age_limit =
      [0,
       bin_shape_buffer_age_limit,
       bin_writer_buffer_age_limit,
       bin_reader_buffer_age_limit];
   function buffer_age_limit_of_sexp(sexp_052){
    if(0 === sexp_052[0]){
     var atom_050 = sexp_052[1];
     return caml_string_notequal(atom_050, cst_At_most$0)
             ? caml_string_notequal
                (atom_050, cst_Unlimited$0)
               ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
               : 751362817
             : caml_call2
               (Sexplib0_Sexp_conv_error[27], error_source_054, sexp_052);
    }
    var _f4_ = sexp_052[1];
    if(! _f4_)
     return caml_call2
             (Sexplib0_Sexp_conv_error[29], error_source_054, sexp_052);
    var match = _f4_[1];
    if(0 !== match[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[28], error_source_054, sexp_052);
    var sexp_args_053 = _f4_[2], atom_050$0 = match[1];
    if(caml_string_notequal(atom_050$0, cst_At_most$0))
     return caml_string_notequal(atom_050$0, cst_Unlimited$0)
             ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
             : caml_call2
               (Sexplib0_Sexp_conv_error[25], error_source_054, sexp_052);
    if(sexp_args_053 && ! sexp_args_053[2]){
     var
      arg0_056 = sexp_args_053[1],
      res0_057 = caml_call1(Time_float_unix[1][9], arg0_056);
     return [0, -339018129, res0_057];
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[26],
             error_source_054,
             atom_050$0,
             sexp_052);
   }
   function buffer_age_limit_of_sexp$0(sexp_058){
    try{var _f2_ = buffer_age_limit_of_sexp(sexp_058); return _f2_;}
    catch(_f3_){
     var _f1_ = caml_wrap_exception(_f3_);
     if(_f1_ === Sexplib0_Sexp_conv_error[22])
      return caml_call2
              (Sexplib0_Sexp_conv_error[24], error_source_059, sexp_058);
     throw caml_maybe_attach_backtrace(_f1_, 0);
    }
   }
   function sexp_of_buffer_age_limit(param){
    if(typeof param === "number") return _bk_;
    var v_060 = param[2];
    return [1, [0, _bl_, [0, caml_call1(Time_float_unix[1][10], v_060), 0]]];
   }
   function create$0
   (buf_len, opt, buffer_age_limit, _fE_, _fD_, time_source, fd){
    if(opt) var sth = opt[1], syscall = sth; else var syscall = -843072412;
    if(_fE_)
     var sth$0 = _fE_[1], raise_when_consumer_leaves = sth$0;
    else
     var raise_when_consumer_leaves = 1;
    if(_fD_)
     var sth$1 = _fD_[1], line_ending = sth$1;
    else
     var line_ending = 1;
    if(time_source)
     var
      x = time_source[1],
      time_source$0 = caml_call1(Async_kernel_Time_source[8], x);
    else
     var time_source$0 = caml_call1(Async_kernel_Time_source[10], 0);
    if(buffer_age_limit)
     var z = buffer_age_limit[1], buffer_age_limit$0 = z;
    else{
     var match = caml_call1(Async_unix_Fd[8], fd);
     a:
     {
      if(typeof match === "number" && 2 <= match){var _fU_ = 751362817; break a;}
      var _fU_ = [0, -339018129, caml_call1(Time_float_unix[1][83], 2.)];
     }
     var buffer_age_limit$0 = _fU_;
    }
    if(buf_len)
     var
      buf_len$0 = buf_len[1],
      _fF_ =
        caml_call2(Async_unix_Import[2], buf_len$0, 0)
         ? caml_call1(Core[5], cst_Writer_create_buf_len_0)
         : buf_len$0,
      buf_len$1 = _fF_;
    else
     var buf_len$1 = 133120;
    var
     id = caml_call1(Id[45], 0),
     _fG_ = 0,
     _fH_ = Ppx_inline_test_lib[1] ? _bm_ : 0,
     monitor = caml_call4(Async_kernel_Monitor[3], 0, 0, _fH_, _fG_),
     _fI_ = 0,
     _fJ_ = Ppx_inline_test_lib[1] ? _bn_ : 0,
     inner_monitor = caml_call4(Async_kernel_Monitor[3], 0, 0, _fJ_, _fI_),
     consumer_left = caml_call1(Async_kernel_Ivar[12], 0);
    function _fK_(file_descr){return caml_call1(Core_unix[51], file_descr);}
    var
     open_flags = caml_call3(Async_unix_Fd[31], 0, fd, _fK_),
     _fL_ = caml_call1(Core_Bag[22], 0),
     _fM_ = caml_call1(Async_kernel_Ivar[12], 0),
     _fN_ = caml_call1(Async_kernel_Ivar[12], 0),
     _fO_ = caml_call2(Core_Queue[66], 0, 0),
     _fP_ = caml_call1(Core_Bigstring[121], buf_len$1),
     _fQ_ = caml_call3(Core_Deque[31], 0, 0, 0),
     _fR_ = Core_Int63[16],
     _fS_ = Core_Int63[16],
     t =
       [0,
        id,
        fd,
        monitor,
        inner_monitor,
        -560725133,
        caml_call1(Async_kernel_Ivar[12], 0),
        syscall,
        _fS_,
        _fR_,
        _fQ_,
        0,
        _fP_,
        0,
        0,
        time_source$0,
        _fO_,
        881668074,
        _fN_,
        _fM_,
        _fL_,
        0,
        dummy,
        consumer_left,
        raise_when_consumer_leaves,
        open_flags,
        line_ending,
        0];
    function _fT_(exn){
     var
      _fW_ = [0, [1, [0, _bo_, [0, sexp_of_writer(t), 0]]], 0],
      _fX_ = caml_call1(Async_kernel_Monitor[13], exn),
      _fY_ = [0, caml_call1(Base_Exn[1], _fX_), _fW_],
      _fZ_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Writer_error_from_inner_mo),
          _fY_]],
      _f0_ = caml_call1(Base_Exn[5], _fZ_);
     return caml_call3(Async_kernel_Monitor[15], monitor, 0, _f0_);
    }
    caml_call2(Async_kernel_Monitor[7], inner_monitor, _fT_);
    t[22] = [246, function(_fV_){return create(t, buffer_age_limit$0);}];
    t[21] = [0, caml_call2(Core_Bag[23], writers_to_flush_at_shutdown, t)];
    return t;
   }
   function set_buffer_age_limit(t, maximum_age){
    if(caml_call1(Core_Lazy[40], t[22]))
     destroy(caml_call1(Core[248], t[22]));
    t[22] = [246, function(_fC_){return create(t, maximum_age);}];
    return 0;
   }
   function of_out_channel(oc, kind){
    return create$0(0, 0, 0, 0, 0, 0, caml_call2(Async_unix_Fd[37], oc, kind));
   }
   function can_write(t){return -752096295 <= t[17] ? 1 : 0;}
   function ensure_can_write(t){
    var _fz_ = 1 - can_write(t);
    if(! _fz_) return _fz_;
    var
     _fA_ = [0, sexp_of_writer(t), 0],
     _fB_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_attempt_to_use_closed_writ),
         _fA_]];
    return caml_call1(Core[261], _fB_);
   }
   function open_file
   (info, opt, buf_len, syscall, _fv_, line_ending, time_source, file){
    if(opt) var sth = opt[1], append = sth; else var append = 0;
    if(_fv_) var sth$0 = _fv_[1], perm = sth$0; else var perm = 438;
    var _fw_ = append ? -999795206 : 693908748, mode$0 = [0, _fw_, mode];
    function _fx_(eta){
     return create$0(buf_len, syscall, 0, 0, line_ending, time_source, eta);
    }
    var
     _fy_ =
       caml_call4(Async_unix_Unix_syscalls[9], info, [0, perm], file, mode$0);
    return caml_call2(Async_unix_Import[32], _fy_, _fx_);
   }
   function with_close(t, f){
    function _fp_(param){return close_noflush(t);}
    function _fq_(param){
     function _fr_(res){
      function _ft_(param){return res;}
      var _fu_ = final_flush(0, t);
      return caml_call2(Async_unix_Import[33][3], _fu_, _ft_);
     }
     var _fs_ = caml_call1(f, 0);
     return caml_call2(Async_unix_Import[33][2], _fs_, _fr_);
    }
    return caml_call8
            (Async_kernel_Monitor[23], 0, 0, 0, 0, _bp_, 0, _fq_, _fp_);
   }
   function with_file
   (perm, append, syscall, opt, line_ending, time_source, file, f){
    if(opt) var sth = opt[1], exclusive = sth; else var exclusive = 0;
    function _ff_(t){
     var
      parent_monitor = caml_call1(Async_kernel_Monitor[5], 0),
      monitor = t[3];
     function _fh_(exn){
      function _fn_(param){
       return caml_call3(Async_kernel_Monitor[15], parent_monitor, 0, exn);
      }
      var _fo_ = close_noflush(t);
      return caml_call2(Async_unix_Import[22], _fo_, _fn_);
     }
     caml_call2(Async_kernel_Monitor[7], monitor, _fh_);
     return with_close
             (t,
              function(param){
               if(! exclusive) return caml_call1(f, t);
               function f$0(param){return caml_call1(f, t);}
               function _fi_(param){
                function _fk_(param){
                 function _fl_(param){
                  return caml_call2(Async_unix_Unix_syscalls[27], 0, t[2]);
                 }
                 var _fm_ = flushed(t);
                 return caml_call2(Async_unix_Import[33][3], _fm_, _fl_);
                }
                return caml_call8
                        (Async_kernel_Monitor[23], 0, 0, 0, 0, _bq_, 0, f$0, _fk_);
               }
               var
                _fj_ = caml_call3(Async_unix_Unix_syscalls[24], 0, t[2], 1);
               return caml_call2(Async_unix_Import[33][2], _fj_, _fi_);
              });
    }
    var
     _fg_ =
       open_file(0, append, 0, syscall, perm, line_ending, time_source, file);
    return caml_call2(Async_unix_Import[33][2], _fg_, _ff_);
   }
   function got_bytes(t, n){
    var _fe_ = caml_call1(Core_Int63[72], n);
    t[8] = caml_call2(Core_Int63[19], t[8], _fe_);
    return 0;
   }
   function add_iovec(t, kind, iovec, count_bytes_as_received){
    if(! caml_call2(Async_unix_Import[3], t[13], t[14]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bs_], 1);
    if(count_bytes_as_received) got_bytes(t, iovec[3]);
    if(1 - is_stopped_permanently(t)){
     t[11] = t[11] + iovec[3] | 0;
     caml_call2(Core_Deque[53], t[10], [0, iovec, kind]);
    }
    if(caml_call2(Async_unix_Import[3], t[13], t[14])) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _br_], 1);
   }
   function schedule_unscheduled(t, kind){
    var need_to_schedule = t[14] - t[13] | 0;
    if(! caml_call2(Async_unix_Import[1], need_to_schedule, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bt_], 1);
    var _fd_ = caml_call2(Async_unix_Import[4], need_to_schedule, 0);
    if(! _fd_) return _fd_;
    var pos = t[13];
    t[13] = t[14];
    return add_iovec
            (t,
             kind,
             caml_call3
              (Core_unix[276][7], [0, pos], [0, need_to_schedule], t[12]),
             0);
   }
   var dummy_iovec = caml_call1(Core_unix[276][5], Core_unix[276][4]);
   function mk_iovecs(t){
    schedule_unscheduled(t, 1);
    var _e6_ = Core_unix[276][9], _e7_ = caml_obj_tag(_e6_);
    a:
    if(250 === _e7_)
     var _e8_ = _e6_[1];
    else{
     if(246 !== _e7_ && 244 !== _e7_){var _e8_ = _e6_; break a;}
     var _e8_ = caml_call1(CamlinternalLazy[2], _e6_);
    }
    var
     _e9_ = caml_call1(Core_Deque[15], t[10]),
     n_iovecs = caml_call2(Core_Int[89], _e9_, _e8_),
     iovecs = caml_call2(Core_Array[63], n_iovecs, dummy_iovec),
     contains_mmapped_ref = [0, 0],
     iovecs_len = [0, 0];
    function _e__(r){
     var i = [0, 0];
     function _e$_(param){
      var iovec = param[1];
      if(caml_call2(Async_unix_Import[1], i[1], n_iovecs)) caml_call1(r, 0);
      var
       _fa_ = 1 - contains_mmapped_ref[1],
       _fb_ = _fa_ ? runtime.bigstring_is_mmapped_stub(iovec[1]) : _fa_;
      if(_fb_) contains_mmapped_ref[1] = 1;
      iovecs_len[1] = iovecs_len[1] + iovec[3] | 0;
      var _fc_ = i[1];
      runtime.caml_check_bound(iovecs, _fc_)[1 + _fc_] = iovec;
      i[1]++;
      return 0;
     }
     return caml_call2(Core_Deque[17], t[10], _e$_);
    }
    caml_call1(Core[268], _e__);
    return [0, iovecs, contains_mmapped_ref[1], iovecs_len[1]];
   }
   var thread_io_cutoff = 262144;
   function is_running(param){
    if(typeof param === "number" && 951752159 === param) return 1;
    return 0;
   }
   function fd_closed(t){
    return is_closed(t)
            ? stop_permanently(t, 1)
            : die
              (t,
               caml_call1
                (Sexplib0_Sexp_conv[7], cst_writer_fd_unexpectedly_clo));
   }
   function update_after_completed_write(t, bytes_written$0){
    var _e4_ = caml_call1(Core_Int63[72], bytes_written$0);
    t[9] = caml_call2(Core_Int63[19], t[9], _e4_);
    if(caml_call2(Core_Int63[110], t[9], t[8]))
     die(t, caml_call1(Sexplib0_Sexp_conv[7], cst_writer_wrote_more_bytes_th));
    var bytes_written = t[9], flushes = t[16], time_source = t[15];
    a:
    if(1 - caml_call1(Core_Queue[17], flushes)){
     var now = caml_call1(Async_kernel_Time_source[14], time_source);
     b:
     {
      for(;;){
       var match = caml_call1(Core_Queue[49], flushes);
       if(! match) break;
       var match$0 = match[1], z = match$0[2], ivar = match$0[1];
       if(! caml_call2(Core_Int63[108], z, bytes_written)) break b;
       caml_call2(Async_kernel_Ivar[14], ivar, [0, now]);
       caml_call1(Core_Queue[45], flushes);
      }
      break a;
     }
    }
    t[11] = t[11] - bytes_written$0 | 0;
    a:
    {
     b:
     {
      var bytes_written$1 = bytes_written$0;
      for(;;){
       if(! caml_call2(Async_unix_Import[1], bytes_written$1, 0))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _bu_], 1);
       var match$1 = caml_call1(Core_Deque[60], t[10]);
       if(! match$1) break;
       var
        _e5_ = match$1[1],
        kind = _e5_[2],
        match$2 = _e5_[1],
        len = match$2[3],
        pos = match$2[2],
        buf = match$2[1];
       if(! caml_call2(Async_unix_Import[1], bytes_written$1, len)) break b;
       if(! kind) runtime.bigstring_destroy_stub(buf);
       var
        bytes_written$2 = bytes_written$1 - len | 0,
        bytes_written$1 = bytes_written$2;
      }
      if(! caml_call2(Async_unix_Import[4], bytes_written$1, 0)) break a;
      die
       (t, caml_call1(Sexplib0_Sexp_conv[7], cst_writer_wrote_nonzero_amoun));
      break a;
     }
     var
      new_iovec =
        caml_call3
         (Core_unix[276][7],
          [0, pos + bytes_written$1 | 0],
          [0, len - bytes_written$1 | 0],
          buf);
     caml_call2(Core_Deque[52], t[10], [0, new_iovec, kind]);
    }
    schedule_unscheduled(t, 1);
    return caml_call1(Core_Deque[16], t[10])
            ? (t[14] = 0, t[13] = 0, 973210841)
            : -376447349;
   }
   function start_write(t){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15], cst_Writer_start_write, t, sexp_of_writer);
    if(! is_running(t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _by_], 1);
    var
     match = mk_iovecs(t),
     iovecs_len = match[3],
     contains_mmapped = match[2],
     iovecs = match[1];
    function handle_write_result(param){
     if(typeof param === "number") return fd_closed(t);
     if(106380200 > param[1]){
      var bytes_written = param[2];
      if(! caml_call2(Async_unix_Import[1], bytes_written, 0)){
       var
        _eX_ =
          [0, [1, [0, _bw_, [0, caml_call1(Core[389], bytes_written), 0]]], 0];
       return die
               (t,
                [1,
                 [0,
                  caml_call1
                   (Sexplib0_Sexp_conv[7], cst_write_system_call_returned),
                  _eX_]]);
      }
      if(debug){
       var
        _e0_ =
          function(param){
           var
            arg1_067 = param[2],
            arg0_066 = param[1],
            res0_068 = caml_call1(Core[389], arg0_066),
            res1_069 = sexp_of_writer(arg1_067);
           return [1, [0, res0_068, [0, res1_069, 0]]];
          };
       caml_call3
        (Async_kernel_Debug[15],
         cst_Writer_write_finished,
         [0, bytes_written, t],
         _e0_);
      }
      if(! is_running(t[5]))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bB_], 1);
      if(973210841 <= update_after_completed_write(t, bytes_written))
       return -752096295 <= t[17]
               ? (t[5] = -560725133, 0)
               : (t[5] = _bA_, caml_call2(Async_kernel_Ivar[16], t[6], 0));
      var match = t[7];
      if(typeof match === "number") return start_write(t);
      var
       span = match[2],
       _e1_ = function(param){return start_write(t);},
       _e2_ = caml_call1(Time_ns_unix[72][146], span),
       _e3_ = caml_call2(Async_kernel_Time_source[29], t[15], _e2_);
      return caml_call2(Async_unix_Import[27], _e3_, _e1_);
     }
     var exn = param[2];
     a:
     if(exn[1] === Async_unix_Unix_syscalls[153]){
      var _eV_ = exn[2];
      if(typeof _eV_ === "number"){
       if(31 <= _eV_){
        var _eW_ = _eV_ - 32 | 0;
        if(19 < _eW_ >>> 0){
         if(0 <= _eW_)
          switch(_eW_ - 20 | 0){
            case 0:
            case 1:
            case 2:
            case 4:
            case 10:
            case 13: break;
            default: break a;
          }
         if(! caml_call1(Async_kernel_Ivar[17], t[23]))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _bv_], 1);
         caml_call2(Async_kernel_Ivar[14], t[23], 0);
         if(! t[24]) return stop_permanently(t, 2);
         stop_permanently(t, 0);
         throw caml_maybe_attach_backtrace(exn, 0);
        }
        if(5 !== _eW_) break a;
       }
       else if(2 !== _eV_){
        if(3 === _eV_)
         return die(t, caml_call1(Sexplib0_Sexp_conv[7], cst_write_got_EBADF));
        break a;
       }
       if(debug)
        caml_call3
         (Async_kernel_Debug[15],
          cst_Writer_write_when_ready,
          t,
          sexp_of_writer);
       if(! is_running(t[5]))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _bz_], 1);
       var
        _eY_ =
          function(param){
           return -102231997 === param
                   ? start_write(t)
                   : -3286312
                     <= param
                     ? die
                       (t,
                        caml_call1
                         (Sexplib0_Sexp_conv[7], cst_writer_ready_to_got_Bad_fd))
                     : fd_closed(t);
          },
        _eZ_ = caml_call2(Async_unix_Fd[28], t[2], -477700929);
       return caml_call2(Async_unix_Import[27], _eZ_, _eY_);
      }
     }
     return die(t, caml_call1(Base_Exn[1], exn));
    }
    var _eR_ = 1 - caml_call1(Async_unix_Fd[9], t[2]);
    if(_eR_)
     var should_write_in_thread = _eR_;
    else
     var
      _eT_ = caml_call2(Async_unix_Import[4], iovecs_len, thread_io_cutoff),
      should_write_in_thread = _eT_ || contains_mmapped;
    if(should_write_in_thread){
     var
      fd = t[2],
      _eP_ =
        function(file_descr){
         var match = caml_call1(Async_unix_Io_uring_raw_single[1], 0);
         if(match){
          var uring = match[1];
          return caml_call4(Async_unix_Io_uring[9], uring, 0, fd, iovecs);
         }
         function _eU_(param){
          return caml_call3(Bigstring_unix[144], file_descr, 0, iovecs);
         }
         return caml_call2(Async_unix_In_thread[6], cst_writev, _eU_);
        },
      _eQ_ = caml_call2(Async_unix_Fd[25], fd, _eP_);
     return caml_call2(Async_unix_Import[27], _eQ_, handle_write_result);
    }
    function _eS_(file_descr){
     return caml_call3(Bigstring_unix[145], file_descr, 0, iovecs);
    }
    return handle_write_result
            (caml_call3(Async_unix_Fd[31], _bx_, t[2], _eS_));
   }
   function maybe_start_writer(t){
    var match$0 = t[27];
    if(! match$0){
     var _eL_ = t[5];
     if(typeof _eL_ === "number" && 951752159 > _eL_){
      var
       _eM_ = bytes_to_write(t),
       _eN_ = caml_call2(Async_unix_Import[4], _eM_, 0);
      if(! _eN_) return _eN_;
      caml_call1(Core[248], t[22]);
      t[5] = 951752159;
      var
       _eJ_ =
         function(param){
          var open_flags = t[25];
          a:
          {
           if(typeof open_flags !== "number" && 106380200 > open_flags[1]){
            var
             flags = open_flags[2],
             can_write_fd = caml_call1(Core_unix[50][54], flags);
            break a;
           }
           var can_write_fd = 0;
          }
          if(1 - can_write_fd){
           var
            _eO_ =
              [0, [1, [0, _bC_, [0, sexp_of_open_flags(open_flags), 0]]], 0];
           die
            (t,
             [1,
              [0,
               caml_call1
                (Sexplib0_Sexp_conv[7], cst_not_allowed_to_write_due_t),
               _eO_]]);
          }
          return start_write(t);
         };
      return caml_call3
              (Async_unix_Import[19],
               [0, t[4]],
               [0, Async_kernel_Priority[4]],
               _eJ_);
     }
     return 0;
    }
    var backing_out_channel = match$0[1];
    for(;;){
     var
      match = mk_iovecs(t),
      bytes_written = match[3],
      iovecs = match[1],
      _eK_ =
        function(iovec){
         return caml_call2
                 (Async_unix_Backing_out_channel[5],
                  backing_out_channel,
                  iovec);
        };
     caml_call2(Core_Array[35], iovecs, _eK_);
     if(973210841 <= update_after_completed_write(t, bytes_written)) return 0;
    }
   }
   function give_buf(t, desired){
    if(! caml_call2(Async_unix_Import[1], desired, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bE_], 1);
    if(is_stopped_permanently(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bD_], 1);
    got_bytes(t, desired);
    var
     buf_len = caml_call1(Core_Bigstring[21], t[12]),
     available = buf_len - t[14] | 0;
    if(caml_call2(Async_unix_Import[2], desired, available)){
     var pos = t[14];
     t[14] = t[14] + desired | 0;
     return [0, t[12], pos];
    }
    if(caml_call2(Async_unix_Import[4], desired, buf_len / 2 | 0)){
     schedule_unscheduled(t, 1);
     var buf = caml_call1(Core_Bigstring[121], desired);
     add_iovec(t, 0, caml_call3(Core_unix[276][7], 0, [0, desired], buf), 0);
     return [0, buf, 0];
    }
    schedule_unscheduled(t, 0);
    var buf$0 = caml_call1(Core_Bigstring[121], buf_len);
    t[12] = buf$0;
    t[13] = 0;
    t[14] = desired;
    return [0, buf$0, 0];
   }
   function write_gen_internal
   (t, src, src_pos, src_len, allow_partial_write, blit_to_bigstring){
    if(is_stopped_permanently(t)) return got_bytes(t, src_len);
    var
     _eI_ = t[14],
     available = caml_call1(Core_Bigstring[21], t[12]) - _eI_ | 0;
    if(caml_call2(Async_unix_Import[1], available, src_len)){
     got_bytes(t, src_len);
     var dst_pos = t[14];
     t[14] = dst_pos + src_len | 0;
     caml_call5(blit_to_bigstring, src, src_pos, t[12], dst_pos, src_len);
    }
    else if(allow_partial_write){
     got_bytes(t, available);
     var dst_pos$0 = t[14];
     t[14] = dst_pos$0 + available | 0;
     caml_call5(blit_to_bigstring, src, src_pos, t[12], dst_pos$0, available);
     var
      remaining = src_len - available | 0,
      match = give_buf(t, remaining),
      dst_pos$1 = match[2],
      dst = match[1];
     caml_call5
      (blit_to_bigstring,
       src,
       src_pos + available | 0,
       dst,
       dst_pos$1,
       remaining);
    }
    else{
     var
      match$0 = give_buf(t, src_len),
      dst_pos$2 = match$0[2],
      dst$0 = match$0[1];
     caml_call5(blit_to_bigstring, src, src_pos, dst$0, dst_pos$2, src_len);
    }
    return maybe_start_writer(t);
   }
   function write_gen_unchecked(pos, len, t, src, blit_to_bigstring, length){
    var
     _eH_ = caml_call1(length, src),
     match = caml_call4(Core_Ordered_collection_common[1], pos, len, 0, _eH_),
     src_len = match[2],
     src_pos = match[1];
    return write_gen_internal(t, src, src_pos, src_len, 1, blit_to_bigstring);
   }
   function write_bytes(pos, len, t, src){
    var _eG_ = runtime.caml_ml_bytes_length;
    return write_gen_unchecked
            (pos,
             len,
             t,
             src,
             function(src, src_pos, dst, dst_pos, len){
              return caml_call5
                      (Core_Bigstring[31][1], src, src_pos, dst, dst_pos, len);
             },
             _eG_);
   }
   function write(pos, len, t, src){
    var _eF_ = caml_ml_string_length;
    return write_gen_unchecked
            (pos,
             len,
             t,
             src,
             function(src, src_pos, dst, dst_pos, len){
              return caml_call5
                      (Core_Bigstring[29][1], src, src_pos, dst, dst_pos, len);
             },
             _eF_);
   }
   function write_bigstring(pos, len, t, src){
    function _eE_(buf){return caml_call1(Core_Bigstring[21], buf);}
    return write_gen_unchecked
            (pos,
             len,
             t,
             src,
             function(src, src_pos, dst, dst_pos, len){
              return caml_call5
                      (Core_Bigstring[22], src, src_pos, dst, dst_pos, len);
             },
             _eE_);
   }
   function to_formatter(t){
    function _eB_(_eD_){return 0;}
    function _eC_(str, pos, len){
     ensure_can_write(t);
     return write([0, pos], [0, len], t, str);
    }
    return caml_call2(Stdlib_Format[120], _eC_, _eB_);
   }
   function write_char(t, c){
    if(is_stopped_permanently(t)) return got_bytes(t, 1);
    var _ez_ = t[14], _eA_ = caml_call1(Core_Bigstring[21], t[12]) - _ez_ | 0;
    if(caml_call2(Async_unix_Import[1], _eA_, 1)){
     got_bytes(t, 1);
     caml_ba_set_1(t[12], t[14], c);
     t[14] = t[14] + 1 | 0;
    }
    else{
     var match = give_buf(t, 1), dst_pos = match[2], dst = match[1];
     caml_ba_set_1(dst, dst_pos, c);
    }
    return maybe_start_writer(t);
   }
   function newline(line_ending, t){
    if(line_ending)
     var x = line_ending[1], line_ending$0 = x;
    else
     var line_ending$0 = t[26];
    if(! line_ending$0) write_char(t, 13);
    return write_char(t, 10);
   }
   function sexp_of_t$4(param){return param ? _bM_ : _bN_;}
   var Terminate_with = [0, sexp_of_t$4];
   function write_sexp_internal(terminate_with, opt, t, sexp){
    if(opt) var sth = opt[1], hum = sth; else var hum = 0;
    if(hum){
     var _et_ = Core_Sexp[72], _eu_ = to_formatter(t);
     caml_call4(Stdlib_Format[137], _eu_, _bO_, _et_, sexp);
    }
    else{
     var
      _ev_ =
        function(eta){
         var _ew_ = 0, _ex_ = 0;
         return function(_ey_){return write(_ex_, _ew_, eta, _ey_);};
        };
     caml_call4(Core_Sexp[90], t, write_char, _ev_, sexp);
    }
    if(! terminate_with) return newline(0, t);
    if(0 === sexp[0])
     var
      str = sexp[1],
      space_is_needed = 1 - caml_call1(Sexplib_Pre_sexp[23], str);
    else
     var space_is_needed = 0;
    return space_is_needed ? write_char(t, 32) : space_is_needed;
   }
   function schedule_iovec(opt, t, iovec){
    if(opt)
     var sth = opt[1], destroy_or_keep = sth;
    else
     var destroy_or_keep = 1;
    schedule_unscheduled(t, 1);
    add_iovec(t, destroy_or_keep, iovec, 1);
    return maybe_start_writer(t);
   }
   function schedule_bigstring(destroy_or_keep, t, pos, len, bstr){
    return schedule_iovec
            (destroy_or_keep,
             t,
             caml_call3(Core_unix[276][7], pos, len, bstr));
   }
   function fsync(t){
    ensure_can_write(t);
    function _er_(param){
     return caml_call1(Async_unix_Unix_syscalls[21], t[2]);
    }
    var _es_ = flushed(t);
    return caml_call2(Async_unix_Import[33][2], _es_, _er_);
   }
   function fdatasync(t){
    ensure_can_write(t);
    function _ep_(param){
     return caml_call1(Async_unix_Unix_syscalls[22], t[2]);
    }
    var _eq_ = flushed(t);
    return caml_call2(Async_unix_Import[33][2], _eq_, _ep_);
   }
   function write_bin_prot(t, sw_arg, v){
    ensure_can_write(t);
    var len = caml_call1(sw_arg[1], v), tot_len = len + Bin_prot_Utils[1] | 0;
    if(is_stopped_permanently(t)) return got_bytes(t, tot_len);
    var match = give_buf(t, tot_len), start_pos = match[2], buf = match[1];
    caml_call5(Core_Bigstring[124], buf, [0, start_pos], sw_arg[2], len, v);
    return maybe_start_writer(t);
   }
   function send(t, s){
    ensure_can_write(t);
    var _eo_ = caml_call1(Core[22], caml_ml_string_length(s));
    write(0, 0, t, caml_call2(Core[18], _eo_, cst));
    return write(0, 0, t, s);
   }
   function schedule_iovec$0(destroy_or_keep, t, iovec){
    ensure_can_write(t);
    return schedule_iovec(destroy_or_keep, t, iovec);
   }
   function schedule_iovecs(t, iovecs){
    ensure_can_write(t);
    schedule_unscheduled(t, 1);
    var _el_ = 1;
    function _em_(_en_){return add_iovec(t, _el_, _en_, 1);}
    caml_call2(Core_Queue[18], iovecs, _em_);
    caml_call1(Core_Queue[51], iovecs);
    return maybe_start_writer(t);
   }
   function schedule_bigstring$0(t, pos, len, bstr){
    ensure_can_write(t);
    return schedule_bigstring(0, t, pos, len, bstr);
   }
   function schedule_bigsubstring(t, bigsubstring){
    ensure_can_write(t);
    var
     _ej_ = caml_call1(Core_Bigsubstring[29], bigsubstring),
     _ek_ = [0, caml_call1(Core_Bigsubstring[6], bigsubstring)];
    return schedule_bigstring
            (0,
             t,
             [0, caml_call1(Core_Bigsubstring[30], bigsubstring)],
             _ek_,
             _ej_);
   }
   function schedule_iobuf_peek(t, pos, len, iobuf){
    ensure_can_write(t);
    return schedule_iovec
            (0, t, caml_call3(Iobuf_unix[18][2], pos, len, iobuf));
   }
   function schedule_iobuf_consume(t, len$0, iobuf){
    ensure_can_write(t);
    var
     iovec = caml_call3(Iobuf_unix[18][2], 0, len$0, iobuf),
     len = iovec[3];
    schedule_iovec(0, t, iovec);
    function _eh_(param){return caml_call2(Iobuf[39], iobuf, len);}
    var _ei_ = flushed_time(t);
    return caml_call2(Async_unix_Import[33][3], _ei_, _eh_);
   }
   function write_gen(pos, len, t, src, blit_to_bigstring, length){
    ensure_can_write(t);
    try{
     var
      _eg_ = write_gen_unchecked(pos, len, t, src, blit_to_bigstring, length);
     return _eg_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _ef_ = [0, [1, [0, _bK_, [0, caml_call1(Core[625], exn), 0]]], 0];
     return die
             (t,
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Writer_write_gen_error_wri),
                _ef_]]);
    }
   }
   function write_bytes$0(pos, len, t, s){
    ensure_can_write(t);
    return write_bytes(pos, len, t, s);
   }
   function write$0(pos, len, t, s){
    ensure_can_write(t);
    return write(pos, len, t, s);
   }
   function write_line(line_ending, t, s){
    ensure_can_write(t);
    write(0, 0, t, s);
    return newline(line_ending, t);
   }
   function writef(t){
    ensure_can_write(t);
    function _ee_(s){return write(0, 0, t, s);}
    return caml_call1(Core[254], _ee_);
   }
   function write_sexp(hum, terminate_with$0, t, sexp){
    ensure_can_write(t);
    if(terminate_with$0)
     var sth = terminate_with$0[1], terminate_with = sth;
    else
     var terminate_with = 1;
    return write_sexp_internal(terminate_with, hum, t, sexp);
   }
   function write_sexp_internal$0(terminate_with, hum, t, sexp){
    ensure_can_write(t);
    return write_sexp_internal(terminate_with, hum, t, sexp);
   }
   function write_iobuf(pos, len, t, iobuf$0){
    ensure_can_write(t);
    var
     _ec_ = caml_call1(Iobuf[26], iobuf$0),
     iobuf = caml_call1(Iobuf[24], _ec_);
    function _ed_(buf){return caml_call1(Iobuf[29], buf);}
    return write_gen_unchecked
            (pos,
             len,
             t,
             iobuf,
             function(src, src_pos, dst, dst_pos, len){
              return caml_call5
                      (Iobuf[64][2][1], src, src_pos, dst, dst_pos, len);
             },
             _ed_);
   }
   function write_bigstring$0(pos, len, t, src){
    ensure_can_write(t);
    return write_bigstring(pos, len, t, src);
   }
   function write_bigsubstring(t, bigsubstring){
    ensure_can_write(t);
    var
     _ea_ = caml_call1(Core_Bigsubstring[29], bigsubstring),
     _eb_ = [0, caml_call1(Core_Bigsubstring[6], bigsubstring)];
    return write_bigstring
            ([0, caml_call1(Core_Bigsubstring[30], bigsubstring)],
             _eb_,
             t,
             _ea_);
   }
   function write_substring(t, substring){
    ensure_can_write(t);
    var
     _d__ = caml_call1(Core_Substring[29], substring),
     _d$_ = [0, caml_call1(Core_Substring[6], substring)];
    return write_bytes
            ([0, caml_call1(Core_Substring[30], substring)], _d$_, t, _d__);
   }
   function write_byte(t, b){
    ensure_can_write(t);
    var _d9_ = caml_call2(Core[237], b, 256);
    return write_char(t, caml_call1(Core[19], _d9_));
   }
   function write_char$0(t, c){ensure_can_write(t); return write_char(t, c);}
   function newline$0(line_ending, t){
    ensure_can_write(t);
    return newline(line_ending, t);
   }
   function write_bin_prot_no_size_header(t, size, write, v){
    ensure_can_write(t);
    if(is_stopped_permanently(t)) return got_bytes(t, size);
    var
     match = give_buf(t, size),
     start_pos = match[2],
     buf = match[1],
     end_pos = caml_call3(write, buf, start_pos, v),
     written = end_pos - start_pos | 0;
    if(caml_call2(Async_unix_Import[6], written, size)){
     var
      _d6_ = [0, [1, [0, _bP_, [0, caml_call1(Core[389], size), 0]]], 0],
      _d7_ = [0, [1, [0, _bQ_, [0, caml_call1(Core[389], written), 0]]], _d6_],
      _d8_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Writer_write_bin_prot_no_s),
          _d7_]];
     caml_call1(Core[261], _d8_);
    }
    return maybe_start_writer(t);
   }
   function write_direct(t, f){
    ensure_can_write(t);
    if(is_stopped_permanently(t)) return 0;
    var
     pos = t[14],
     len = caml_call1(Core_Bigstring[21], t[12]) - pos | 0,
     match = caml_call3(f, t[12], pos, len),
     written = match[2],
     x = match[1],
     _d0_ = caml_call2(Async_unix_Import[5], written, 0),
     _d1_ = _d0_ || caml_call2(Async_unix_Import[4], written, len);
    if(_d1_){
     var
      _d2_ = [0, [1, [0, _bF_, [0, sexp_of_writer(t), 0]]], 0],
      _d3_ = [0, [1, [0, _bG_, [0, caml_call1(Core[389], len), 0]]], _d2_],
      _d4_ = [0, [1, [0, _bH_, [0, caml_call1(Core[389], written), 0]]], _d3_],
      _d5_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_write_direct_s_f_argument_),
          _d4_]];
     caml_call1(Core[261], _d5_);
    }
    t[14] = pos + written | 0;
    got_bytes(t, written);
    maybe_start_writer(t);
    return [0, x];
   }
   function write_gen_whole(t, src, blit_to_bigstring, length){
    ensure_can_write(t);
    try{
     var
      src_len = caml_call1(length, src),
      _dY_ =
        write_gen_internal
         (t,
          src,
          0,
          src_len,
          0,
          function(src, src_pos, dst, dst_pos, len){
           if(! caml_call2(Async_unix_Import[3], src_pos, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bJ_], 1);
           if(caml_call2(Async_unix_Import[3], len, src_len))
            return caml_call3(blit_to_bigstring, src, dst, dst_pos);
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bI_], 1);
          });
     return _dY_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _dZ_ = [0, [1, [0, _bL_, [0, caml_call1(Core[625], exn), 0]]], 0];
     return die
             (t,
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Writer_write_gen_whole_err),
                _dZ_]]);
    }
   }
   var
    stdout_and_stderr_behave_nicel = [0, function(_dX_){return;}],
    stdout_and_stderr =
      [246,
       function(param){
        function _dS_(param){
         var
          stdout = caml_call1(Async_unix_Fd[20], 0),
          stderr = caml_call1(Async_unix_Fd[21], 0),
          stdout$0 = create$0(0, 0, 0, 0, 0, 0, stdout);
         function dev_and_ino(fd){
          var
           _dW_ = caml_call1(Async_unix_Fd[40], fd),
           stats = caml_call1(Core_unix[75], _dW_);
          return [0, stats[1], stats[2]];
         }
         if(Async_unix_Import[36]){
          set_backing_out_channel$0
           (stdout$0,
            caml_call1
             (Async_unix_Backing_out_channel[3], Stdio_Out_channel[3]));
          return [0, stdout$0, stdout$0];
         }
         var
          x_074 = dev_and_ino(stderr),
          x_073 = dev_and_ino(stdout),
          t_078 = x_073[2],
          t_077 = x_073[1],
          t_080 = x_074[2],
          t_079 = x_074[1],
          n = caml_call2(Core[382], t_077, t_079),
          match = 0 === n ? caml_call2(Core[382], t_078, t_080) : n,
          _dV_ = 0 === match ? 1 : 0;
         if(_dV_)
          var stderr$0 = stdout$0;
         else
          var
           stderr$1 = create$0(0, 0, 0, 0, 0, 0, stderr),
           stderr$0 = stderr$1;
         caml_call1(stdout_and_stderr_behave_nicel[1], stdout$0);
         caml_call1(stdout_and_stderr_behave_nicel[1], stderr$0);
         return [0, stdout$0, stderr$0];
        }
        var
         match =
           caml_call3
            (Async_unix_Require_explicit_ti[5][6],
             [0, Async_kernel_Monitor[24]],
             0,
             _dS_);
        if(match){var v = match[1]; return v;}
        var
         _dT_ =
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_unable_to_create_stdout_st),
            0],
         _dU_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_src_writer0_ml_1767_35),
             _dT_]];
        return caml_call1(Core[261], _dU_);
       }],
    stdout =
      [246,
       function(_dP_){
        var _dQ_ = caml_obj_tag(stdout_and_stderr);
        a:
        if(250 === _dQ_)
         var _dR_ = stdout_and_stderr[1];
        else{
         if(246 !== _dQ_ && 244 !== _dQ_){
          var _dR_ = stdout_and_stderr;
          break a;
         }
         var _dR_ = caml_call1(CamlinternalLazy[2], stdout_and_stderr);
        }
        return _dR_[1];
       }],
    stderr =
      [246,
       function(_dM_){
        var _dN_ = caml_obj_tag(stdout_and_stderr);
        a:
        if(250 === _dN_)
         var _dO_ = stdout_and_stderr[1];
        else{
         if(246 !== _dN_ && 244 !== _dN_){
          var _dO_ = stdout_and_stderr;
          break a;
         }
         var _dO_ = caml_call1(CamlinternalLazy[2], stdout_and_stderr);
        }
        return _dO_[2];
       }];
   function use_synchronous_stdout_and_std(param){
    var _dI_ = caml_obj_tag(stdout_and_stderr);
    a:
    if(250 === _dI_)
     var match = stdout_and_stderr[1];
    else{
     if(246 !== _dI_ && 244 !== _dI_){var match = stdout_and_stderr; break a;}
     var match = caml_call1(CamlinternalLazy[2], stdout_and_stderr);
    }
    var
     stderr = match[2],
     stdout = match[1],
     _dJ_ = stdout === stderr ? 0 : [0, [0, stderr, Stdio_Out_channel[4]], 0],
     ts_and_channels = [0, [0, stdout, Stdio_Out_channel[3]], _dJ_];
    function _dK_(param){
     var out_channel = param[2], t = param[1];
     return set_synchronous_out_channel(t, out_channel);
    }
    var _dL_ = caml_call2(Core_List[51], ts_and_channels, _dK_);
    return caml_call1(Async_kernel_Deferred[22], _dL_);
   }
   if(typeof Ppx_inline_test_lib[3] !== "number"){
    var
     Ppx_expect_test_block =
       caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
     _bW_ =
       function(param){
        var
         _dy_ = caml_call1(Core_Lazy[40], stdout),
         _dz_ = [1, [0, _bX_, [0, caml_call1(Core[323], _dy_), 0]]];
        caml_call1(Async_unix_Import[35], _dz_);
        var _dA_ = caml_call1(Ppx_expect_runtime_Types[4][1], 0);
        caml_call1(Ppx_expect_test_block[2], _dA_);
        var
         _dB_ = caml_call1(Core_Lazy[40], stderr),
         _dC_ = [1, [0, _bY_, [0, caml_call1(Core[323], _dB_), 0]]];
        caml_call1(Async_unix_Import[35], _dC_);
        var _dD_ = caml_call1(Ppx_expect_runtime_Types[4][1], 1);
        caml_call1(Ppx_expect_test_block[2], _dD_);
        var
         saved_stderr = caml_call2(Core_unix[96], 0, Core_unix[44]),
         match = caml_call2(Core_unix[117], 0, 0),
         pipe_w = match[2],
         pipe_r = match[1];
        caml_call4(Core_unix[97], 0, pipe_w, Core_unix[44], 0);
        caml_call2(Core_unix[53], 0, pipe_r);
        caml_call2(Core_unix[53], 0, pipe_w);
        var _dE_ = caml_obj_tag(stdout);
        a:
        if(250 === _dE_)
         var stdout$0 = stdout[1];
        else{
         if(246 !== _dE_ && 244 !== _dE_){var stdout$0 = stdout; break a;}
         var stdout$0 = caml_call1(CamlinternalLazy[2], stdout);
        }
        var _dF_ = caml_obj_tag(stderr);
        a:
        if(250 === _dF_)
         var stderr$0 = stderr[1];
        else{
         if(246 !== _dF_ && 244 !== _dF_){var stderr$0 = stderr; break a;}
         var stderr$0 = caml_call1(CamlinternalLazy[2], stderr);
        }
        caml_call4(Core_unix[97], 0, saved_stderr, Core_unix[44], 0);
        caml_call2(Core_unix[53], 0, saved_stderr);
        var
         _dG_ =
           [1,
            [0,
             _bZ_,
             [0, caml_call1(Core[323], stdout$0 === stderr$0 ? 1 : 0), 0]]];
        caml_call1(Async_unix_Import[35], _dG_);
        var _dH_ = caml_call1(Ppx_expect_runtime_Types[4][1], 2);
        return caml_call1(Ppx_expect_test_block[2], _dH_);
       },
     _b2_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _b1_,
         _b0_),
     _b3_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 0), _b2_], 0],
     _b6_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _b5_,
         _b4_),
     _b7_ =
       [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 1), _b6_], _b3_],
     _b__ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _b9_,
         _b8_),
     _b$_ =
       [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 2), _b__], _b7_],
     _cb_ = caml_call1(Ppx_expect_runtime_Types[4][1], 4),
     _cc_ = caml_call1(Ppx_expect_runtime_Types[4][1], 3);
    caml_call14
     (Ppx_expect_test_block[3],
      cst_src_writer0_ml,
      1792,
      _cf_,
      _ce_,
      _cd_,
      [0, Ppx_expect_runtime_Types[1][1]],
      0,
      _cc_,
      _cb_,
      _ca_,
      0,
      Inline_test_config,
      _b$_,
      _bW_);
   }
   function make_writer_behave_nicely_in_p(writer){
    set_buffer_age_limit(writer, 751362817);
    set_raise_when_consumer_leaves(writer, 0);
    function _dv_(param){
     return caml_call2(Async_unix_Shutdown[2], 0, Core_Signal[59]);
    }
    var
     _dw_ = consumer_left$1(writer),
     _dx_ = caml_call2(Async_unix_Import[33][3], _dw_, _dv_);
    return caml_call1(Async_unix_Import[16], _dx_);
   }
   function behave_nicely_in_pipeline(writers, param){
    if(writers){
     var l = writers[1];
     return caml_call2(Core_List[19], l, make_writer_behave_nicely_in_p);
    }
    if(caml_call1(Core_Lazy[40], stdout_and_stderr)){
     var
      match = caml_call1(Core[248], stdout_and_stderr),
      stderr = match[2],
      stdout = match[1];
     return caml_call2
             (Core_List[19],
              [0, stdout, [0, stderr, 0]],
              make_writer_behave_nicely_in_p);
    }
    stdout_and_stderr_behave_nicel[1] = make_writer_behave_nicely_in_p;
    return 0;
   }
   function with_file_atomic(temp_file, perm, opt, _cH_, time_source, file, f){
    if(opt) var sth = opt[1], do_fsync = sth; else var do_fsync = 0;
    if(_cH_)
     var sth$0 = _cH_[1], replace_special = sth$0;
    else
     var replace_special = 0;
    function _cI_(current_file_permissions){
     if(perm)
      var p = perm[1], initial_permissions = p;
     else if(current_file_permissions)
      var p$0 = current_file_permissions[1], initial_permissions = p$0;
     else
      var initial_permissions = 438;
     function _cS_(param){
      var
       fd = param[2],
       temp_file = param[1],
       t = create$0(0, 0, 0, 0, 0, time_source, fd);
      function _cY_(param){
       if(0 === param[0]){
        var res = param[1];
        return caml_call1(Async_unix_Import[30], res);
       }
       var error = param[1];
       function _dm_(unlink_result){
        function _dp_(close_result){
         var
          _ds_ = [0, [1, [0, _bR_, [0, caml_call1(Core[558], file), 0]]], 0],
          _dt_ =
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Error_in_Writer_with_file_),
              _ds_]],
          match =
            caml_call1
             (Core_Or_error[57], [0, close_result, [0, unlink_result, 0]]);
         if(0 === match[0]){
          if(10228857 <= error[1])
           var our_error = error[2], our_error$0 = our_error;
          else
           var
            f_error = error[2],
            our_error$0 = caml_call1(Core_Error[30], f_error);
          var our_error$1 = our_error$0;
         }
         else
          var
           cleanup_error = match[1],
           initial_error = error[2],
           our_error$1 =
             caml_call1
              (Core_Error[26], [0, initial_error, [0, cleanup_error, 0]]);
         var _du_ = caml_call2(Core_Error[23], our_error$1, _dt_);
         return caml_call1(Core_Error[30], _du_);
        }
        function _dq_(param){return close(0, t);}
        var _dr_ = caml_call6(Async_kernel_Monitor[17], 0, 0, 0, 0, 0, _dq_);
        return caml_call2(Async_unix_Import[33][3], _dr_, _dp_);
       }
       function _dn_(param){
        return caml_call1(Async_unix_Unix_syscalls[37], temp_file);
       }
       var _do_ = caml_call6(Async_kernel_Monitor[17], 0, 0, 0, 0, 0, _dn_);
       return caml_call2(Async_unix_Import[33][2], _do_, _dm_);
      }
      function _cZ_(f_result){
       function _c8_(param){
        if(0 === param[0]) return [0, f_result];
        var e = param[1];
        return [1, [0, 10228857, e]];
       }
       function _c9_(param){
        function _df_(param){
         function _dg_(param){
          function _di_(param){
           function _dk_(param){
            return caml_call2(Async_unix_Unix_syscalls[39], temp_file, file);
           }
           var _dl_ = close(0, t);
           return caml_call2(Async_unix_Import[33][2], _dl_, _dk_);
          }
          var
           _dj_ = do_fsync ? fsync(t) : caml_call1(Async_unix_Import[30], 0);
          return caml_call2(Async_unix_Import[33][2], _dj_, _di_);
         }
         var
          _dh_ =
            current_file_permissions
             ? caml_call2
               (Async_unix_Unix_syscalls[42], fd, initial_permissions)
             : caml_call1(Async_unix_Import[30], 0);
         return caml_call2(Async_unix_Import[33][2], _dh_, _dg_);
        }
        return caml_call6(Async_kernel_Monitor[17], 0, 0, 0, 0, 0, _df_);
       }
       var
        _c__ = [0, caml_call1(Core[558], file), 0],
        _c$_ =
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_writer_closed_by_f),
            _c__]],
        _da_ = caml_call1(Core_Error[20], _c$_),
        _db_ = 1 - is_closed(t),
        _dc_ = caml_call2(Core_Result[53], _db_, _da_),
        _dd_ = caml_call1(Async_kernel_Deferred[12], _dc_),
        _de_ =
          caml_call2(Async_kernel_Deferred_or_error[19][4][2], _dd_, _c9_);
       return caml_call2(Async_unix_Import[33][3], _de_, _c8_);
      }
      var _c0_ = Core_Result[47];
      function _c1_(e){return [0, -321063951, e];}
      function _c2_(_c7_){return caml_call2(_c0_, _c7_, _c1_);}
      function _c3_(param){return caml_call1(f, t);}
      var
       _c4_ = caml_call6(Async_kernel_Monitor[17], 0, 0, 0, 0, 0, _c3_),
       _c5_ = caml_call2(Async_unix_Import[32], _c4_, _c2_),
       _c6_ = caml_call2(Async_kernel_Deferred_result[3][4][2], _c5_, _cZ_);
      return caml_call2(Async_unix_Import[31], _c6_, _cY_);
     }
     var temp_file$0 = caml_call2(Core_Option[39], temp_file, file);
     function _cT_(param){
      var
       fd = param[2],
       temp_file = param[1],
       _cX_ = caml_call1(Core_Info[14], temp_file);
      return [0, temp_file, caml_call4(Async_unix_Fd[6], 0, 2, fd, _cX_)];
     }
     var
      dir = caml_call1(Core_Filename[20], temp_file$0),
      prefix = caml_call1(Core_Filename[19], temp_file$0);
     function _cU_(param){
      return caml_call5
              (Filename_unix[3],
               0,
               [0, initial_permissions],
               [0, dir],
               prefix,
               cst$0);
     }
     var
      _cV_ = caml_call4(Async_unix_In_thread[5], 0, 0, 0, _cU_),
      _cW_ = caml_call2(Async_unix_Import[33][3], _cV_, _cT_);
     return caml_call2(Async_unix_Import[33][2], _cW_, _cS_);
    }
    function _cJ_(param){
     if(0 !== param[0]) return 0;
     var stats = param[1], _cN_ = stats[3];
     if(840421965 <= _cN_){
      if(848053274 <= _cN_)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bS_], 1);
      var
       _cO_ = [0, caml_call1(Core[558], file), 0],
       _cP_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Writer_with_file_atomic_no),
           _cO_]];
      return caml_call1(Core[261], _cP_);
     }
     if(781515420 <= _cN_) return [0, stats[4]];
     if(replace_special) return [0, stats[4]];
     var
      _cQ_ = [0, caml_call1(Core[558], file), 0],
      _cR_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Writer_with_file_atomic_no$0),
          _cQ_]];
     return caml_call1(Core[261], _cR_);
    }
    function _cK_(param){
     return caml_call1(Async_unix_Unix_syscalls[34], file);
    }
    var
     _cL_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _bU_, _bT_, _cK_),
     _cM_ = caml_call2(Async_unix_Import[33][3], _cL_, _cJ_);
    return caml_call2(Async_unix_Import[33][2], _cM_, _cI_);
   }
   function save(temp_file, perm, fsync, replace_special, file, contents){
    return with_file_atomic
            (temp_file,
             perm,
             fsync,
             replace_special,
             0,
             file,
             function(t){
              write$0(0, 0, t, contents);
              return caml_call1(Async_unix_Import[30], 0);
             });
   }
   function save_lines(temp_file, perm, fsync, replace_special, file, lines){
    return with_file_atomic
            (temp_file,
             perm,
             fsync,
             replace_special,
             0,
             file,
             function(t){
              function _cG_(line){
               write$0(0, 0, t, line);
               return newline$0(0, t);
              }
              caml_call2(Core_List[19], lines, _cG_);
              return caml_call1(Async_unix_Import[30], 0);
             });
   }
   function save_sexp
   (temp_file, perm, fsync, replace_special, opt, file, sexp){
    if(opt) var sth = opt[1], hum = sth; else var hum = 1;
    return with_file_atomic
            (temp_file,
             perm,
             fsync,
             replace_special,
             0,
             file,
             function(t){
              write_sexp_internal$0(0, [0, hum], t, sexp);
              return caml_call1(Async_unix_Import[30], 0);
             });
   }
   function save_sexps_conv
   (temp_file, perm, fsync, replace_special, opt, file, xs, sexp_of_x){
    if(opt) var sth = opt[1], hum = sth; else var hum = 1;
    return with_file_atomic
            (temp_file,
             perm,
             fsync,
             replace_special,
             0,
             file,
             function(t){
              function _cF_(x){
               return write_sexp_internal$0
                       (0, [0, hum], t, caml_call1(sexp_of_x, x));
              }
              caml_call2(Core_List[19], xs, _cF_);
              return caml_call1(Async_unix_Import[30], 0);
             });
   }
   function save_sexps
   (temp_file, perm, fsync, replace_special, hum, file, sexps){
    return save_sexps_conv
            (temp_file,
             perm,
             fsync,
             replace_special,
             hum,
             file,
             sexps,
             function(_cE_){return _cE_;});
   }
   function save_bin_prot
   (temp_file, perm, fsync, replace_special, file, bin_writer, a){
    return with_file_atomic
            (temp_file,
             perm,
             fsync,
             replace_special,
             0,
             file,
             function(t){
              write_bin_prot(t, bin_writer, a);
              return caml_call1(Async_unix_Import[30], 0);
             });
   }
   function with_flushed_at_close(t, flushed, f){
    var
     producers_to_flush_at_close_el = caml_call2(Core_Bag[23], t[20], flushed);
    function _cD_(param){
     caml_call2(Core_Bag[26], t[20], producers_to_flush_at_close_el);
     return caml_call1(Async_unix_Import[30], 0);
    }
    return caml_call8(Async_kernel_Monitor[23], 0, 0, 0, 0, _bV_, 0, f, _cD_);
   }
   function make_transfer(opt, max_num_values_per_read, t, pipe_r, write_f){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred[19], 0);
    function _ci_(param){
     function _cB_(param){return 17724;}
     var _cC_ = flushed(t);
     return caml_call2(Async_unix_Import[33][3], _cC_, _cB_);
    }
    var
     consumer = caml_call2(Async_kernel_Pipe[23], pipe_r, _ci_),
     end_of_pipe_r = caml_call1(Async_kernel_Ivar[12], 0);
    function iter(param){
     if
      (!
       caml_call1(Async_kernel_Ivar[18], t[23])
       && can_write(t) && ! caml_call1(Async_kernel_Deferred[7], stop)){
      if(max_num_values_per_read)
       var
        max_queue_length = max_num_values_per_read[1],
        read_result =
          caml_call3
           (Async_kernel_Pipe[40],
            [0, consumer],
            [0, max_queue_length],
            pipe_r);
      else
       var
        read_result =
          caml_call3(Async_kernel_Pipe[40], [0, consumer], 0, pipe_r);
      if(typeof read_result !== "number"){
       var q = read_result[2];
       return caml_call2
               (write_f,
                q,
                function(param){
                 caml_call1(Async_kernel_Pipe[22][1], consumer);
                 var _cA_ = flushed(t);
                 return caml_call2(Async_unix_Import[27], _cA_, iter);
                });
      }
      if(3456156 <= read_result)
       return caml_call2(Async_kernel_Ivar[14], end_of_pipe_r, 0);
      var
       _cy_ = function(param){return iter(0);},
       _cz_ = caml_call1(Async_kernel_Pipe[46], pipe_r);
      return caml_call2(Async_unix_Import[27], _cz_, _cy_);
     }
     return 0;
    }
    function doit(param){
     iter(0);
     function _ck_(param){
      if(656392408 !== param && 1050608848 > param) return 0;
      return caml_call1(Async_kernel_Pipe[16], pipe_r);
     }
     var _cl_ = 0;
     function _cm_(param){return 1050608848;}
     var
      _cn_ = consumer_left$1(t),
      _co_ = [0, caml_call2(Async_unix_Import[14], _cn_, _cm_), _cl_];
     function _cp_(param){return 656392408;}
     var
      _cq_ = close_finished$1(t),
      _cr_ = [0, caml_call2(Async_unix_Import[14], _cq_, _cp_), _co_];
     function _cs_(param){return 926227490;}
     var _ct_ = [0, caml_call2(Async_unix_Import[14], stop, _cs_), _cr_];
     function _cu_(param){return -163278971;}
     var
      _cv_ = caml_call1(Async_kernel_Ivar[19], end_of_pipe_r),
      _cw_ = [0, caml_call2(Async_unix_Import[14], _cv_, _cu_), _ct_],
      _cx_ = caml_call1(Async_unix_Import[15], _cw_);
     return caml_call2(Async_unix_Import[33][3], _cx_, _ck_);
    }
    return with_flushed_at_close
            (t,
             function(param){
              var _cj_ = caml_call1(Async_kernel_Pipe[20], pipe_r);
              return caml_call1(Async_kernel_Deferred[15], _cj_);
             },
             doit);
   }
   function transfer(stop, max_num_values_per_read, t, pipe_r, write_f){
    return make_transfer
            (stop,
             max_num_values_per_read,
             t,
             pipe_r,
             function(q, cont){
              caml_call2(Core_Queue[18], q, write_f);
              return caml_call1(cont, 0);
             });
   }
   function transfer$0(stop, max_num_values_per_read, t, pipe_r, write_f){
    return make_transfer
            (stop,
             max_num_values_per_read,
             t,
             pipe_r,
             function(q, cont){
              var _ch_ = caml_call1(write_f, q);
              return caml_call2(Async_unix_Import[27], _ch_, cont);
             });
   }
   function pipe(t){
    var
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     pipe_w = match[2],
     pipe_r = match[1],
     _cg_ =
       transfer(0, 0, t, pipe_r, function(s){return write$0(0, 0, t, s);});
    caml_call1(Async_unix_Import[16], _cg_);
    return pipe_w;
   }
   function set_bytes_received(t, i){
    caml_call1(Core[248], t[22]);
    t[8] = i;
    return 0;
   }
   function set_bytes_written$0(t, i){t[9] = i; return 0;}
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Writer0);
   var
    Async_unix_Writer0 =
      [0,
       Id,
       Line_ending,
       sexp_of_writer,
       invariant,
       stdout,
       stderr,
       bin_shape_buffer_age_limit,
       bin_size_buffer_age_limit,
       bin_write_buffer_age_limit,
       bin_writer_buffer_age_limit,
       bin_read_buffer_age_limit$0,
       bin_read_buffer_age_limit,
       bin_reader_buffer_age_limit,
       bin_buffer_age_limit,
       sexp_of_buffer_age_limit,
       buffer_age_limit_of_sexp$0,
       buffer_age_limit_of_sexp,
       create$0,
       raise_when_consumer_leaves,
       set_raise_when_consumer_leaves,
       set_buffer_age_limit,
       consumer_left$1,
       of_out_channel,
       open_file,
       with_file,
       id,
       fd,
       set_fd,
       write_gen,
       write_gen_whole,
       write_direct,
       write_bytes$0,
       write$0,
       write_bigstring$0,
       write_iobuf,
       write_substring,
       write_bigsubstring,
       writef,
       to_formatter,
       write_char$0,
       newline$0,
       write_line,
       write_byte,
       Terminate_with,
       write_sexp,
       write_bin_prot,
       write_bin_prot_no_size_header,
       schedule_bigstring$0,
       schedule_bigsubstring,
       schedule_iobuf_peek,
       schedule_iobuf_consume,
       Destroy_or_keep,
       schedule_iovec$0,
       schedule_iovecs,
       Flush_result,
       flushed_or_failed_with_result,
       flushed_or_failed_unit,
       flushed,
       flushed_time,
       flushed_time_ns,
       fsync,
       fdatasync,
       send,
       monitor,
       close,
       close_started$1,
       close_finished$1,
       is_closed,
       is_open,
       with_close,
       can_write,
       is_stopped_permanently,
       stopped_permanently,
       with_flushed_at_close,
       bytes_to_write,
       bytes_written,
       bytes_received,
       with_file_atomic,
       save,
       save_lines,
       save_sexp,
       save_sexps,
       save_sexps_conv,
       save_bin_prot,
       transfer$0,
       transfer,
       pipe,
       behave_nicely_in_pipeline,
       set_synchronous_out_channel,
       using_synchronous_backing_out_,
       clear_synchronous_out_channel,
       with_synchronous_out_channel,
       use_synchronous_stdout_and_std,
       [0,
        Async_unix_Backing_out_channel[1],
        Async_unix_Backing_out_channel[4],
        Async_unix_Backing_out_channel[3]],
       set_synchronous_backing_out_ch,
       with_synchronous_backing_out_c,
       [0, [0, _a8_], set_bytes_received, set_bytes_written$0]];
   runtime.caml_register_global
    (313, Async_unix_Writer0, cst_Async_unix_Writer0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Reader0
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Deferred_or_error, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Pipe, Async_unix__Clock, Async_unix__Fd, Async_unix__Import, Async_unix__In_thread, Async_unix__Io_uring, Async_unix__Io_uring_raw_singleton, Async_unix__Raw_scheduler, Async_unix__Unix_syscalls, Base__Buffer, Base__Char, Base__Monad, Bigstring_unix, Bin_prot__Common, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Utils, Bin_prot__Write, Bin_shape, Core, Core__Bigstring, Core__Bigsubstring, Core__Bytes, Core__Error, Core__Int, Core__Int63, Core__Int64, Core__List, Core__Option, Core__Or_error, Core__Result, Core__Sexp, Core__String, Core__Substring, Core__Unique_id, Core_unix, Eager_deferred, Iobuf, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib__Conv, Sexplib__Sexp, Stdlib, Stdlib__Marshal, Time_float_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Reader0$0 = "Async_unix__Reader0",
    cst_Closed = "Closed",
    cst_Consumed = "Consumed",
    cst_Continue = "Continue",
    cst_Eof = "Eof",
    cst_In_use = "In_use",
    cst_Need = "Need",
    cst_Need_unknown = "Need_unknown",
    cst_Not_in_use = "Not_in_use",
    cst_Ok = "Ok",
    cst_Reader_read_bin_prot_got_c = "Reader.read_bin_prot got closed reader",
    cst_Stop = "Stop",
    cst_a = "a",
    cst_async_unix$0 = "async_unix",
    cst_exn = "exn",
    cst_fd = "fd",
    cst_file = "file",
    cst_len = "len",
    cst_open_flags = "open_flags",
    cst_pos = "pos",
    cst_read$1 = "read",
    cst_reader = "reader",
    cst_src_reader0_ml = "src/reader0.ml",
    cst_src_reader0_ml_Internal_St = "src/reader0.ml.Internal.State.t",
    cst_src_reader0_ml_Read_result = "src/reader0.ml.Read_result.Z.t",
    cst_t$0 = "t",
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    err = [2, cst_src_reader0_ml_Read_result],
    error_source_007 = cst_src_reader0_ml_Read_result,
    error_source_012 = cst_src_reader0_ml_Read_result,
    error_source_020 = cst_src_reader0_ml_Internal_St,
    error_source_022 = cst_src_reader0_ml_Internal_St,
    name = "substring",
    name$0 = "bigsubstring",
    line_delimiter_pred = [0, 748194550, 10],
    cst = " ",
    Core = global_data.Core,
    Async_unix_Import = global_data.Async_unix__Import,
    Core_Or_error = global_data.Core__Or_error,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Async_kernel_Deferred_or_error =
      global_data.Async_kernel__Deferred_or_error,
    Core_List = global_data.Core__List,
    Core_Error = global_data.Core__Error,
    Core_Sexp = global_data.Core__Sexp,
    Sexplib_Sexp = global_data.Sexplib__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_unix_Fd = global_data.Async_unix__Fd,
    Core_Int64 = global_data.Core__Int64,
    Async_unix_Unix_syscalls = global_data.Async_unix__Unix_syscalls,
    Eager_deferred = global_data.Eager_deferred,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_Bigstring = global_data.Core__Bigstring,
    Core_Bytes = global_data.Core__Bytes,
    Base_Buffer = global_data.Base__Buffer,
    Stdlib_Marshal = global_data.Stdlib__Marshal,
    Core_Substring = global_data.Core__Substring,
    Bin_prot_Utils = global_data.Bin_prot__Utils,
    Core_Int = global_data.Core__Int,
    Async_unix_Clock = global_data.Async_unix__Clock,
    Core_String = global_data.Core__String,
    Base_Char = global_data.Base__Char,
    Core_Bigsubstring = global_data.Core__Bigsubstring,
    Iobuf = global_data.Iobuf,
    Bigstring_unix = global_data.Bigstring_unix,
    Core_unix = global_data.Core_unix,
    Async_unix_Raw_scheduler = global_data.Async_unix__Raw_scheduler,
    Stdlib = global_data.Stdlib,
    Core_Int63 = global_data.Core__Int63,
    Time_float_unix = global_data.Time_float_unix,
    Async_unix_Io_uring_raw_single =
      global_data.Async_unix__Io_uring_raw_singleton,
    Core_Result = global_data.Core__Result,
    Async_unix_Io_uring = global_data.Async_unix__Io_uring,
    Async_unix_In_thread = global_data.Async_unix__In_thread,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Option = global_data.Core__Option,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Bin_prot_Common = global_data.Bin_prot__Common,
    Bin_prot_Write = global_data.Bin_prot__Write,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Core_Unique_id = global_data.Core__Unique_id,
    Base_Monad = global_data.Base__Monad,
    Sexplib_Conv = global_data.Sexplib__Conv;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Reader0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_reader0_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "reader0.ml");
   var
    Id = caml_call1(Core_Unique_id[2], 0),
    _a_ = [0, caml_call2(Bin_prot_Shape[6], cst_Eof, 0), 0],
    _b_ = caml_call1(Bin_shape[3][1], cst_a),
    _c_ = caml_call1(Bin_shape[4][1], "src/reader0.ml:10:15"),
    _d_ = [0, caml_call2(Bin_prot_Shape[11], _c_, _b_)],
    _e_ = [0, caml_call2(Bin_prot_Shape[6], cst_Ok, _d_), _a_],
    _f_ = caml_call1(Bin_shape[4][1], "src/reader0.ml:10:6"),
    _g_ = caml_call2(Bin_prot_Shape[8], _f_, _e_),
    _h_ = [0, caml_call1(Bin_shape[3][1], cst_a), 0],
    _i_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$0), _h_, _g_], 0],
    _j_ = caml_call1(Bin_shape[4][1], "src/reader0.ml:9:4"),
    group = caml_call2(Bin_prot_Shape[2], _j_, _i_),
    cst_Reader_load_bin_prot_got_u = "Reader.load_bin_prot got unexpected eof",
    _bi_ = [0, 3804260],
    _bj_ = [0, "Reader.load_bin_prot"],
    _bh_ = [0, cst_src_reader0_ml, 1553, 48],
    _be_ = [0, 3804260],
    _bf_ = [0, 523273847],
    _bg_ = [0, 1],
    _bb_ = [0, 3804260],
    _bc_ = [0, 523273847],
    _bd_ = [0, 1],
    cst_conversion_of_annotated_se =
      "conversion of annotated sexp unexpectedly succeeded",
    cst_Reader_load_sexp_requires_ =
      "Reader.load_sexp requires one sexp but got",
    _a$_ = [0, cst_exn],
    _ba_ = [0, cst_file],
    cst_Reader_load_sexp_s_error = "Reader.load_sexp(s) error",
    _a9_ = [0, cst_exn],
    _a__ = [0, cst_file],
    cst_invalid_sexp_failed_to_det =
      "invalid sexp (failed to determine location information)",
    _a5_ =
      [0,
       [2, 0, [12, 58, [4, 0, 0, 0, [12, 58, [4, 0, 0, 0, 0]]]]],
       "%s:%d:%d"],
    cst_syntax_error_when_parsing_ = "syntax error when parsing sexp",
    _a6_ = [0, 3804260],
    _a7_ = [0, 523273847],
    _a8_ = [0, 1],
    cst_Reader_load_sexp_error = "Reader.load_sexp error",
    _a4_ = [0, 0],
    cst_in = "in",
    cst_invalid_sexp = "invalid sexp",
    _a3_ = [0, cst_len],
    cst_Reader_peek_got_negative_l = "[Reader.peek] got negative len",
    _a2_ = [0, cst_src_reader0_ml, 1188, 19],
    _a0_ = [0, cst_reader],
    _a1_ = [0, "reason"],
    cst_can_not_read_from_reader = "can not read from reader",
    cst_closed = "closed",
    cst_in_use = "in use",
    _aY_ = [0, cst_reader],
    _aZ_ = [0, "length_str"],
    cst_Reader_recv_got_strange_le = "Reader.recv got strange length",
    cst_Reader_recv_got_unexpected = "Reader.recv got unexpected EOF",
    _aX_ = [1, 0],
    _aV_ = [0, -289386606, 0],
    _aW_ = [0, 990972795, 0],
    _aU_ = [0, 990972795, 0],
    _aS_ = [0, -289386606, 0],
    _aT_ = [0, -289386606, 0],
    cst_Reader_read_marshal_got_EO =
      "Reader.read_marshal got EOF with bytes remaining",
    _aQ_ = [0, "data"],
    _aR_ = [0, "length"],
    cst_Unconsumed_data = "Unconsumed data",
    _aO_ = [0, cst_reader],
    cst_Error_deserializing_reader = "Error deserializing reader",
    _aP_ = [0, 3903734],
    _aM_ = [0, cst_src_reader0_ml, 979, 25],
    _aN_ =
      [0,
       [11, cst_Reader_read_bin_prot_got_c, 0],
       cst_Reader_read_bin_prot_got_c],
    _aL_ =
      [0,
       [11,
        "max read length exceeded: ",
        [4, 0, 0, 0, [11, " > ", [4, 0, 0, 0, 0]]]],
       "max read length exceeded: %d > %d"],
    _aI_ = [0, 3456156],
    _aJ_ =
      [0,
       [11,
        "got Eof with ",
        [4,
         0,
         0,
         0,
         [11, " bytes left over (need ", [4, 0, 0, 0, [12, 41, 0]]]]],
       "got Eof with %d bytes left over (need %d)"],
    cst_Reader_read_bin_prot = "Reader.read_bin_prot",
    _aK_ =
      [0,
       [11, "max read length is negative: ", [4, 0, 0, 0, 0]],
       "max read length is negative: %d"],
    _aG_ = [0, "Read"],
    _aH_ = [0, "Peek"],
    cst_header = "header",
    cst_Negative_message_size = "Negative message size",
    cst_Bytes_needed_overflowed = "Bytes needed overflowed",
    cst_message = "message",
    _aD_ = [0, cst_pos],
    _aE_ = [0, "size"],
    _aF_ = [0, cst_reader],
    _ay_ = [0, "new_pos"],
    _az_ = [0, "read_len"],
    _aA_ = [0, "old_pos"],
    _aB_ = [0, cst_reader],
    _aC_ = [0, "bin_type"],
    cst_Unexpected_reader_position = "Unexpected reader position after read",
    _aw_ = [0, cst_reader],
    cst_Reader_read_sexp_got_unexp = "Reader.read_sexp got unexpected eof",
    _ax_ = [0, 3456156],
    _av_ = [0, cst_src_reader0_ml, 794, 25],
    _au_ = [0, cst_src_reader0_ml, 765, 8],
    _at_ = [0, cst_src_reader0_ml, 755, 32],
    _ar_ = [0, cst_src_reader0_ml, 658, 6],
    _as_ = [0, cst_src_reader0_ml, 655, 6],
    _aq_ =
      [0,
       [11, "Reader.read_", [2, 0, [11, " with empty string", 0]]],
       "Reader.read_%s with empty string"],
    _ao_ = [0, cst_Continue],
    _ap_ = [0, cst_Stop],
    _am_ = [0, cst_reader],
    cst_read_one_chunk_at_a_time_g =
      "read_one_chunk_at_a_time got overflow in buffer len",
    _ak_ = [0, cst_reader],
    _al_ = [0, cst_len],
    cst_handle_chunk_returned_inva = "handle_chunk returned invalid `Consumed",
    _an_ = [0, cst_src_reader0_ml, 499, 31],
    _ah_ = [0, cst_Need_unknown],
    _aj_ = [0, cst_Need],
    _ai_ = [0, cst_Consumed],
    _ae_ = [0, cst_Eof],
    _af_ = [0, "Stopped"],
    _ag_ = [0, "Eof_with_unconsumed_data"],
    ___ = [0, cst_Continue],
    _ac_ = [0, cst_Stop],
    _ad_ = [0, "Stop_consumed"],
    _$_ = [0, cst_Need_unknown],
    _ab_ = [0, cst_Need],
    _aa_ = [0, cst_Consumed],
    _Z_ = [0, cst_src_reader0_ml, 458, 4],
    _X_ = [0, cst_src_reader0_ml, 452, 26],
    _Y_ = [0, cst_src_reader0_ml, 443, 21],
    _V_ = [0, cst_src_reader0_ml, 431, 25],
    _W_ = [0, cst_src_reader0_ml, 423, 21],
    cst_read$0 = cst_read$1,
    _S_ = [0, cst_src_reader0_ml, 334, 32],
    _R_ = [0, 1],
    _T_ = [0, cst_src_reader0_ml, 315, 27],
    _Q_ = [0, cst_reader],
    cst_reader_file_descriptor_was =
      "reader file descriptor was unexpectedly closed",
    _O_ = [0, cst_reader],
    _P_ = [0, cst_open_flags],
    cst_not_allowed_to_read_due_to =
      "not allowed to read due to file-descriptor flags",
    _U_ = [0, cst_src_reader0_ml, 244, 26],
    cst_read = cst_read$1,
    _N_ = [0, 523273847],
    _M_ = [0, 523273847],
    _K_ = [0, 654843454, 0],
    _L_ = [0, 0],
    _I_ = [0, cst_fd],
    _J_ = [0, "buf_len"],
    cst_Reader_create_got_non_posi = "Reader.create got non positive buf_len",
    _H_ = [0, cst_src_reader0_ml, 126, 4],
    _G_ = [0, cst_src_reader0_ml, 127, 4],
    _F_ = [0, cst_src_reader0_ml, 128, 4],
    _w_ = [0, "Not_now"],
    _x_ = [0, "Not_ever"],
    _v_ = [0, "Yes"],
    _s_ = [0, "bytes_read"],
    _t_ = [0, cst_fd],
    _u_ = [0, "close_finished"],
    _y_ = [0, "close_may_destroy_buf"],
    _z_ = [0, "last_read_time"],
    _A_ = [0, cst_open_flags],
    _B_ = [0, cst_pos],
    _C_ = [0, "available"],
    _D_ = [0, "state"],
    _E_ = [0, "id"],
    _p_ = [0, "Already_closed"],
    _q_ = [0, "Error"],
    _r_ = [0, cst_Ok],
    _n_ = [0, cst_Not_in_use],
    _o_ = [0, cst_Closed],
    _m_ = [0, cst_In_use],
    _k_ = [0, cst_Eof],
    _l_ = [0, cst_Ok],
    cst_t = cst_t$0,
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Reader0 = cst_Async_unix_Reader0$0;
   function bin_shape_t(a){
    var _f3_ = caml_call1(Bin_shape[2][1], cst_t);
    return caml_call1(caml_call2(Bin_prot_Shape[10], group, _f3_), [0, a, 0]);
   }
   function bin_size_t(size_of_a, param){
    if(typeof param !== "number" && 17724 === param[1]){
     var args = param[2], size_args = caml_call1(size_of_a, args);
     return caml_call2(Bin_prot_Common[23], size_args, 4);
    }
    return 4;
   }
   function bin_write_t(write_a, buf, pos, param){
    if(typeof param === "number")
     return caml_call3(Bin_prot_Write[29], buf, pos, 3456156);
    var
     args = param[2],
     pos$0 = caml_call3(Bin_prot_Write[29], buf, pos, 17724);
    return caml_call3(write_a, buf, pos$0, args);
   }
   function bin_writer_t(bin_writer_a){
    function _fZ_(v){
     var _f0_ = bin_writer_a[2];
     return function(_f1_, _f2_){return bin_write_t(_f0_, v, _f1_, _f2_);};
    }
    return [0, function(v){return bin_size_t(bin_writer_a[1], v);}, _fZ_];
   }
   function bin_read_t(of_a, buf, pos_ref, vint){
    if(17724 === vint){
     var arg_1 = caml_call2(of_a, buf, pos_ref);
     return [0, 17724, arg_1];
    }
    if(3456156 === vint) return 3456156;
    throw caml_maybe_attach_backtrace(Bin_prot_Common[13], 0);
   }
   function bin_read_t$0(of_a, buf, pos_ref){
    var vint = caml_call2(Bin_prot_Read[28], buf, pos_ref);
    try{var _fX_ = bin_read_t(of_a, buf, pos_ref, vint); return _fX_;}
    catch(_fY_){
     var _fW_ = caml_wrap_exception(_fY_);
     if(_fW_ === Bin_prot_Common[13])
      return caml_call2(Bin_prot_Common[18], err, pos_ref[1]);
     throw caml_maybe_attach_backtrace(_fW_, 0);
    }
   }
   function bin_reader_t(bin_reader_a){
    function _fV_(buf, pos_ref, vtag){
     return bin_read_t(bin_reader_a[1], buf, pos_ref, vtag);
    }
    return [0,
            function(buf, pos_ref){
             return bin_read_t$0(bin_reader_a[1], buf, pos_ref);
            },
            _fV_];
   }
   function bin_t(bin_a){
    var _fT_ = bin_reader_t(bin_a[3]), _fU_ = bin_writer_t(bin_a[2]);
    return [0, bin_shape_t(bin_a[1]), _fU_, _fT_];
   }
   function t_of_sexp(of_a_001, sexp_005){
    if(0 === sexp_005[0]){
     var atom_003 = sexp_005[1];
     return caml_string_notequal(atom_003, cst_Eof)
             ? caml_string_notequal
                (atom_003, cst_Ok)
               ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
               : caml_call2
                 (Sexplib0_Sexp_conv_error[27], error_source_007, sexp_005)
             : 3456156;
    }
    var _fS_ = sexp_005[1];
    if(! _fS_)
     return caml_call2
             (Sexplib0_Sexp_conv_error[29], error_source_007, sexp_005);
    var match = _fS_[1];
    if(0 !== match[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[28], error_source_007, sexp_005);
    var sexp_args_006 = _fS_[2], atom_003$0 = match[1];
    if(! caml_string_notequal(atom_003$0, cst_Eof))
     return caml_call2
             (Sexplib0_Sexp_conv_error[25], error_source_007, sexp_005);
    if(caml_string_notequal(atom_003$0, cst_Ok))
     return caml_call1(Sexplib0_Sexp_conv_error[23], 0);
    if(sexp_args_006 && ! sexp_args_006[2]){
     var
      arg0_009 = sexp_args_006[1],
      res0_010 = caml_call1(of_a_001, arg0_009);
     return [0, 17724, res0_010];
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[26],
             error_source_007,
             atom_003$0,
             sexp_005);
   }
   function t_of_sexp$0(of_a_001, sexp_011){
    try{var _fQ_ = t_of_sexp(of_a_001, sexp_011); return _fQ_;}
    catch(_fR_){
     var _fP_ = caml_wrap_exception(_fR_);
     if(_fP_ === Sexplib0_Sexp_conv_error[22])
      return caml_call2
              (Sexplib0_Sexp_conv_error[24], error_source_012, sexp_011);
     throw caml_maybe_attach_backtrace(_fP_, 0);
    }
   }
   function sexp_of_t(of_a_013, param){
    if(typeof param === "number") return _k_;
    var v_014 = param[2];
    return [1, [0, _l_, [0, caml_call1(of_a_013, v_014), 0]]];
   }
   function bind(a, f){
    if(typeof a === "number") return 3456156;
    var a$0 = a[2];
    return caml_call1(f, a$0);
   }
   var
    map =
      [0,
       -198771759,
       function(a, f){
        if(typeof a === "number") return 3456156;
        var a$0 = a[2];
        return [0, 17724, caml_call1(f, a$0)];
       }];
   function return$0(a){return [0, 17724, a];}
   var
    Z =
      [0,
       bin_shape_t,
       bin_size_t,
       bin_write_t,
       bin_writer_t,
       bin_read_t,
       bin_read_t$0,
       bin_reader_t,
       bin_t,
       t_of_sexp,
       t_of_sexp$0,
       sexp_of_t,
       bind,
       map,
       return$0],
    bin_shape_t$0 = Z[1],
    bin_size_t$0 = Z[2],
    bin_write_t$0 = Z[3],
    bin_writer_t$0 = Z[4],
    bin_read_t$1 = Z[5],
    bin_read_t$2 = Z[6],
    bin_reader_t$0 = Z[7],
    bin_t$0 = Z[8],
    t_of_sexp$1 = Z[9],
    t_of_sexp$2 = Z[10],
    sexp_of_t$0 = Z[11],
    include = caml_call1(Base_Monad[1], [0, Z[12], Z[14], Z[13]]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    Read_result =
      [0,
       Z,
       bin_shape_t$0,
       bin_size_t$0,
       bin_write_t$0,
       bin_writer_t$0,
       bin_read_t$1,
       bin_read_t$2,
       bin_reader_t$0,
       bin_t$0,
       t_of_sexp$1,
       t_of_sexp$2,
       sexp_of_t$0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax];
   function t_of_sexp$3(sexp_018){
    if(0 === sexp_018[0]){
     var atom_016 = sexp_018[1];
     return caml_string_notequal(atom_016, cst_Closed)
             ? caml_string_notequal
                (atom_016, cst_In_use)
               ? caml_string_notequal
                  (atom_016, cst_Not_in_use)
                 ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
                 : -144639815
               : -985294899
             : -1025106484;
    }
    var _fO_ = sexp_018[1];
    if(! _fO_)
     return caml_call2
             (Sexplib0_Sexp_conv_error[29], error_source_020, sexp_018);
    var match = _fO_[1];
    if(0 !== match[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[28], error_source_020, sexp_018);
    var atom_016$0 = match[1];
    return caml_string_notequal(atom_016$0, cst_Closed)
            ? caml_string_notequal
               (atom_016$0, cst_In_use)
              ? caml_string_notequal
                 (atom_016$0, cst_Not_in_use)
                ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
                : caml_call2
                  (Sexplib0_Sexp_conv_error[25], error_source_020, sexp_018)
              : caml_call2
                (Sexplib0_Sexp_conv_error[25], error_source_020, sexp_018)
            : caml_call2
              (Sexplib0_Sexp_conv_error[25], error_source_020, sexp_018);
   }
   function t_of_sexp$4(sexp_021){
    try{var _fM_ = t_of_sexp$3(sexp_021); return _fM_;}
    catch(_fN_){
     var _fL_ = caml_wrap_exception(_fN_);
     if(_fL_ === Sexplib0_Sexp_conv_error[22])
      return caml_call2
              (Sexplib0_Sexp_conv_error[24], error_source_022, sexp_021);
     throw caml_maybe_attach_backtrace(_fL_, 0);
    }
   }
   function sexp_of_t$1(param){
    return -985294899 === param ? _m_ : -144639815 <= param ? _n_ : _o_;
   }
   var State = [0, t_of_sexp$3, t_of_sexp$4, sexp_of_t$1];
   function sexp_of_open_flags(param){
    if(typeof param === "number") return _p_;
    if(106380200 <= param[1]){
     var v_024 = param[2];
     return [1, [0, _q_, [0, caml_call1(Core[625], v_024), 0]]];
    }
    var v_023 = param[2];
    return [1, [0, _r_, [0, caml_call1(Core_unix[50][2], v_023), 0]]];
   }
   function open_flags(r){return r[11];}
   function last_read_time(r){return r[10];}
   function state(r){return r[8];}
   function available(r){return r[7];}
   function pos(r){return r[6];}
   function close_may_destroy_buf(r){return r[5];}
   function buf(r){return r[4];}
   function bytes_read(r){return r[3];}
   function id(r){return r[2];}
   function fd(r){return r[1];}
   function sexp_of_t$2(t){return caml_call1(Async_unix_Fd[3], t[1]);}
   function sexp_of_t_internals(param){
    var
     id = param[2],
     fd = param[1],
     bytes_read = param[3],
     close_may_destroy_buf = param[5],
     pos = param[6],
     available = param[7],
     state = param[8],
     close_finished = param[9],
     last_read_time = param[10],
     open_flags = param[11];
    function unless_testing(x){
     return caml_call2(Core_Option[60], 1 - Ppx_inline_test_lib[1], x);
    }
    var
     match = unless_testing(id),
     match$0 = unless_testing(open_flags),
     match$1 = unless_testing(last_read_time),
     match$2 = unless_testing(fd),
     match$3 =
       [0, [1, [0, _s_, [0, caml_call1(Core_Int63[103], bytes_read), 0]]], 0];
    if(match$2)
     var
      v = match$2[1],
      _fD_ =
        [0, [1, [0, _t_, [0, caml_call1(Async_unix_Fd[2], v), 0]]], match$3];
    else
     var _fD_ = match$3;
    var
     _fE_ =
       [0,
        [1,
         [0,
          _u_,
          [0, caml_call2(Async_kernel_Ivar[9], Core[620], close_finished), 0]]],
        _fD_],
     _fF_ = 0,
     _fG_ =
       4448519 === close_may_destroy_buf
        ? _v_
        : 381789322 <= close_may_destroy_buf ? _w_ : _x_,
     match$4 = [0, [1, [0, _y_, [0, _fG_, _fF_]]], _fE_];
    if(match$1)
     var
      v$0 = match$1[1],
      match$5 =
        [0,
         [1, [0, _z_, [0, caml_call1(Time_float_unix[60], v$0), 0]]],
         match$4];
    else
     var match$5 = match$4;
    if(match$0)
     var
      v$1 = match$0[1],
      _fH_ = [0, [1, [0, _A_, [0, sexp_of_open_flags(v$1), 0]]], match$5];
    else
     var _fH_ = match$5;
    var
     _fI_ = [0, [1, [0, _B_, [0, caml_call1(Core[389], pos), 0]]], _fH_],
     _fJ_ = [0, [1, [0, _C_, [0, caml_call1(Core[389], available), 0]]], _fI_],
     match$6 = [0, [1, [0, _D_, [0, caml_call1(State[3], state), 0]]], _fJ_];
    if(match)
     var
      v$2 = match[1],
      _fK_ = [0, [1, [0, _E_, [0, caml_call1(Id[10], v$2), 0]]], match$6];
    else
     var _fK_ = match$6;
    return [1, _fK_];
   }
   function invariant(t){
    if(! caml_call2(Async_unix_Import[2], 0, t[6]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
    if(! caml_call2(Async_unix_Import[2], 0, t[7]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
    var _fC_ = caml_call1(Core_Bigstring[21], t[4]);
    if(caml_call2(Async_unix_Import[2], t[6] + t[7] | 0, _fC_)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
   }
   function create(buf_len, fd){
    if(buf_len){
     var buf_len$0 = buf_len[1];
     if(caml_call2(Async_unix_Import[4], buf_len$0, 0))
      var buf_len$1 = buf_len$0;
     else
      var
       _fy_ = [0, [1, [0, _I_, [0, caml_call1(Async_unix_Fd[2], fd), 0]]], 0],
       _fz_ =
         [0, [1, [0, _J_, [0, caml_call1(Core[389], buf_len$0), 0]]], _fy_],
       _fA_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Reader_create_got_non_posi),
           _fz_]],
       buf_len$1 = caml_call1(Core[261], _fA_);
     var buf_len$2 = buf_len$1;
    }
    else{
     var match = caml_call1(Async_unix_Fd[8], fd);
     a:
     {
      if(typeof match === "number" && 1 !== match){var _fB_ = 32768; break a;}
      var _fB_ = 131072;
     }
     var buf_len$2 = _fB_;
    }
    function _ft_(file_descr){return caml_call1(Core_unix[51], file_descr);}
    var
     open_flags = caml_call3(Async_unix_Fd[31], 0, fd, _ft_),
     _fu_ = caml_call1(Async_unix_Raw_scheduler[18], 0),
     _fv_ = caml_call1(Async_kernel_Ivar[12], 0),
     _fw_ = caml_call1(Core_Bigstring[121], buf_len$2),
     _fx_ = Core_Int63[16];
    return [0,
            fd,
            caml_call1(Id[45], 0),
            _fx_,
            _fw_,
            4448519,
            0,
            0,
            -144639815,
            _fv_,
            _fu_,
            open_flags];
   }
   function of_in_channel(ic, kind){
    return create(0, caml_call2(Async_unix_Fd[36], ic, kind));
   }
   function open_file(buf_len, file){
    function _fr_(fd){return create(buf_len, fd);}
    var _fs_ = caml_call4(Async_unix_Unix_syscalls[9], 0, _L_, file, _K_);
    return caml_call2(Async_unix_Import[33][3], _fs_, _fr_);
   }
   var
    stdin =
      [246,
       function(param){return create(0, caml_call1(Async_unix_Fd[19], 0));}];
   function close_finished(t){return caml_call1(Async_kernel_Ivar[19], t[9]);}
   function is_closed(t){return -985294899 <= t[8] ? 0 : 1;}
   var empty_buf = caml_call1(Core_Bigstring[121], 0);
   function destroy(t){
    runtime.bigstring_destroy_stub(t[4]);
    t[4] = empty_buf;
    return 0;
   }
   function close(t){
    if(-985294899 <= t[8]){
     t[8] = -1025106484;
     var
      _fp_ =
        function(param){return caml_call2(Async_kernel_Ivar[14], t[9], 0);},
      _fq_ = caml_call2(Async_unix_Unix_syscalls[16], 0, t[1]);
     caml_call2(Async_unix_Import[22], _fq_, _fp_);
     t[6] = 0;
     t[7] = 0;
     if(4448519 === t[5]) destroy(t);
    }
    return close_finished(t);
   }
   function with_close(t, f){
    function _fo_(param){return close(t);}
    return caml_call8(Async_kernel_Monitor[23], 0, 0, 0, 0, _M_, 0, f, _fo_);
   }
   function with_reader_exclusive(t, f){
    function _fl_(param){
     function _fn_(param){
      if(1 - caml_call1(Async_unix_Fd[16], t[1]))
       caml_call2(Async_unix_Unix_syscalls[27], 0, t[1]);
      return caml_call1(Async_unix_Import[30], 0);
     }
     return caml_call8(Async_kernel_Monitor[23], 0, 0, 0, 0, _N_, 0, f, _fn_);
    }
    var _fm_ = caml_call3(Async_unix_Unix_syscalls[24], 0, t[1], 0);
    return caml_call2(Async_unix_Import[33][2], _fm_, _fl_);
   }
   function with_file(buf_len, opt, file, f){
    if(opt) var sth = opt[1], exclusive = sth; else var exclusive = 0;
    function _fj_(t){
     return with_close
             (t,
              function(param){
               return exclusive
                       ? with_reader_exclusive
                         (t, function(param){return caml_call1(f, t);})
                       : caml_call1(f, t);
              });
    }
    var _fk_ = open_file(buf_len, file);
    return caml_call2(Async_unix_Import[33][2], _fk_, _fj_);
   }
   function read_syscall_with_timestamp(fd, pos, len, buf){
    function _fc_(file_descr){
     var match = caml_call1(Async_unix_Io_uring_raw_single[1], 0);
     if(match){
      var
       uring = match[1],
       _fd_ = Core_Result[46],
       _fe_ =
         function(res){return [0, res, caml_call1(Time_float_unix[15], 0)];},
       _ff_ = function(_fi_){return caml_call2(_fd_, _fi_, _fe_);},
       _fg_ =
         caml_call6
          (Async_unix_Io_uring[6],
           uring,
           0,
           file_descr,
           [0, pos],
           [0, len],
           buf);
      return caml_call2(Async_unix_Import[32], _fg_, _ff_);
     }
     function _fh_(param){
      var
       res =
         caml_call5
          (Bigstring_unix[126], 0, file_descr, [0, pos], [0, len], buf);
      return [0, res, caml_call1(Time_float_unix[15], 0)];
     }
     return caml_call2(Async_unix_In_thread[6], cst_read, _fh_);
    }
    return caml_call2(Async_unix_Fd[25], fd, _fc_);
   }
   function get_data(t){
    function _eQ_(result){
     function eof(param){
      return caml_call2(Async_kernel_Ivar[14], result, 3456156);
     }
     var _eR_ = t[8], open_flags = t[11];
     a:
     if(-985294899 === _eR_){
      if(typeof open_flags !== "number"){
       var _eS_ = open_flags[1];
       if(17724 !== _eS_ && 106380200 !== _eS_) break a;
       if(106380200 <= open_flags[1])
        var can_read_fd = 0;
       else
        var
         open_flags$0 = open_flags[2],
         can_read_fd = caml_call1(Core_unix[50][53], open_flags$0);
       if(1 - can_read_fd){
        var
         _eT_ = [0, [1, [0, _O_, [0, sexp_of_t$2(t), 0]]], 0],
         _eU_ =
           [0, [1, [0, _P_, [0, sexp_of_open_flags(open_flags), 0]]], _eT_],
         _eV_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_not_allowed_to_read_due_to),
             _eU_]];
        caml_call1(Core[261], _eV_);
       }
       var
        ebadf =
          function(param){
           var
            _fa_ = [0, [1, [0, _Q_, [0, sexp_of_t$2(t), 0]]], 0],
            _fb_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_reader_file_descriptor_was),
                _fa_]];
           return caml_call1(Core[261], _fb_);
          },
        finish =
          function(res, handle){
           if(typeof res === "number") return eof(0);
           if(106380200 > res[1]){
            var
             match = res[2],
             read_time = match[2],
             bytes_read = match[1],
             _e$_ = caml_call1(Core_Int63[72], bytes_read);
            t[3] = caml_call2(Core_Int63[19], t[3], _e$_);
            return caml_call2(Async_unix_Import[3], bytes_read, 0)
                    ? eof(0)
                    : (t
                       [6]
                      = 0,
                      t[7] = t[7] + bytes_read | 0,
                      t[10] = read_time,
                      caml_call2(Async_kernel_Ivar[14], result, 17724));
           }
           var exn = res[2];
           a:
           {
            b:
            {
             if(exn[1] === Async_unix_Unix_syscalls[153]){
              var _e9_ = exn[2];
              if(typeof _e9_ === "number" && 3 === _e9_) return ebadf(0);
             }
             else if(exn[1] === Bigstring_unix[125]){
              if(0 !== exn[2]) break b;
              if(exn[3] === Stdlib[12]) break a;
              break b;
             }
             if(exn[1] === Async_unix_Unix_syscalls[153]){
              var _e__ = exn[2];
              if(typeof _e__ === "number"){
               if(31 !== _e__){
                if(52 > _e__) break b;
                switch(_e__ - 52 | 0){
                  case 0:
                  case 1:
                  case 2:
                  case 4:
                  case 10:
                  case 13: break;
                  default: break b;
                }
               }
               break a;
              }
             }
            }
            return caml_call1(handle, exn);
           }
           return eof(0);
          },
        buf = t[4],
        _eW_ = caml_call2(Async_unix_Import[4], t[7], 0),
        _eX_ = _eW_ ? caml_call2(Async_unix_Import[4], t[6], 0) : _eW_;
       if(_eX_){
        caml_call5(Core_Bigstring[22], buf, t[6], buf, 0, t[7]);
        t[6] = 0;
       }
       var pos = t[7], len = caml_call1(Core_Bigstring[21], buf) - pos | 0;
       if(caml_call1(Async_unix_Fd[9], t[1])){
        var
         loop =
           function(param){
            function _e2_(param){
             if(-102231997 !== param)
              return -3286312 <= param ? ebadf(0) : eof(0);
             var _e4_ = t[8];
             if(-985294899 === _e4_){
              var
               _e5_ =
                 function(exn){
                  a:
                  if(exn[1] === Async_unix_Unix_syscalls[153]){
                   var _e8_ = exn[2];
                   if(typeof _e8_ === "number"){
                    if(2 !== _e8_ && 37 !== _e8_) break a;
                    return loop(0);
                   }
                  }
                  throw caml_maybe_attach_backtrace(exn, 0);
                 },
               _e6_ =
                 function(file_descr){
                  var
                   _e7_ =
                     caml_call4
                      (Bigstring_unix[131], file_descr, [0, pos], [0, len], buf),
                   res = caml_call2(Core_unix[5][2][12], _e7_, cst_read$0);
                  return [0, res, caml_call1(Async_unix_Raw_scheduler[18], 0)];
                 };
              return finish
                      (caml_call3(Async_unix_Fd[31], _R_, t[1], _e6_), _e5_);
             }
             if(-144639815 <= _e4_)
              throw caml_maybe_attach_backtrace([0, Assert_failure, _S_], 1);
             return eof(0);
            }
            var _e3_ = caml_call2(Async_unix_Fd[28], t[1], 914388854);
            return caml_call2(Async_unix_Import[27], _e3_, _e2_);
           };
        return loop(0);
       }
       if(4448519 === t[5]) t[5] = 381789322;
       var
        _eY_ =
          function(res){
           if(381789322 <= t[5]) t[5] = 4448519;
           var _e0_ = t[8];
           if(-985294899 === _e0_)
            return finish
                    (res,
                     function(_e1_){throw caml_maybe_attach_backtrace(_e1_, 0);});
           if(-144639815 <= _e0_)
            throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
           destroy(t);
           return eof(0);
          },
        _eZ_ = read_syscall_with_timestamp(t[1], pos, len, buf);
       return caml_call2(Async_unix_Import[27], _eZ_, _eY_);
      }
     }
     else if(-144639815 <= _eR_)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _U_], 1);
     return eof(0);
    }
    return caml_call1(Async_kernel_Deferred[3], _eQ_);
   }
   function maybe_grow_buf_len(t, desired){
    var
     buf_len = caml_call1(Core_Bigstring[21], t[4]),
     _eO_ = caml_call2(Async_unix_Import[5], buf_len, desired);
    if(_eO_){
     var
      new_buf_len =
        caml_call2(Async_unix_Import[5], desired, 2 * buf_len | 0)
         ? 2 * buf_len | 0
         : caml_call2
            (Async_unix_Import[5], desired, 8 * buf_len | 0)
           ? desired
           : 4 * buf_len | 0,
      new_buf = caml_call1(Core_Bigstring[121], new_buf_len);
     if(caml_call2(Async_unix_Import[4], t[7], 0))
      caml_call5(Core_Bigstring[22], t[4], t[6], new_buf, 0, t[7]);
     t[4] = new_buf;
     t[6] = 0;
     var _eP_ = 0;
    }
    else
     var _eP_ = _eO_;
    return _eP_;
   }
   function get_data_until(t, available_at_least){
    if(caml_call2(Async_unix_Import[1], t[7], available_at_least))
     return caml_call1(Async_unix_Import[30], 17724);
    maybe_grow_buf_len(t, available_at_least);
    if(caml_call2(Async_unix_Import[4], t[6], 0)){
     caml_call5(Core_Bigstring[22], t[4], t[6], t[4], 0, t[7]);
     t[6] = 0;
    }
    function loop(param){
     function _eL_(result){
      if(caml_call2(Async_unix_Import[1], t[7], available_at_least))
       return caml_call1(Async_unix_Import[30], 17724);
      if(3456156 <= result)
       return caml_call1(Async_unix_Import[30], [0, 3456156, t[7]]);
      var _eN_ = caml_call1(Core_Bigstring[21], t[4]);
      if(caml_call2(Async_unix_Import[3], t[7], _eN_))
       maybe_grow_buf_len(t, available_at_least);
      return loop(0);
     }
     var _eM_ = get_data(t);
     return caml_call2(Async_unix_Import[33][2], _eM_, _eL_);
    }
    return loop(0);
   }
   function with_nonempty_buffer(t, f){
    var _eF_ = t[8];
    if(-985294899 !== _eF_){
     if(-144639815 <= _eF_)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
     var _eJ_ = caml_call1(f, 3456156);
     return caml_call1(Async_unix_Import[30], _eJ_);
    }
    if(caml_call2(Async_unix_Import[4], t[7], 0)){
     var _eG_ = caml_call1(f, 17724);
     return caml_call1(Async_unix_Import[30], _eG_);
    }
    function _eH_(ok_or_eof){
     var _eK_ = t[8];
     if(-985294899 === _eK_) return caml_call1(f, ok_or_eof);
     if(-144639815 <= _eK_)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
     return caml_call1(f, 3456156);
    }
    var _eI_ = get_data(t);
    return caml_call2(Async_unix_Import[33][3], _eI_, _eH_);
   }
   function with_nonempty_buffer$0(opt, t, f){
    if(opt) var sth = opt[1], force_refill = sth; else var force_refill = 0;
    var _eB_ = t[8];
    if(-985294899 === _eB_){
     if(! force_refill && caml_call2(Async_unix_Import[4], t[7], 0))
      return caml_call1(f, 17724);
     var
      _eC_ =
        function(ok_or_eof){
         var _eE_ = t[8];
         if(-985294899 === _eE_) return caml_call1(f, ok_or_eof);
         if(-144639815 <= _eE_)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
         return caml_call1(f, 3456156);
        },
      _eD_ = get_data(t);
     return caml_call2(Async_unix_Import[27], _eD_, _eC_);
    }
    if(-144639815 <= _eB_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _Y_], 1);
    return caml_call1(f, 3456156);
   }
   function consume(t, amount){
    if
     (caml_call2(Async_unix_Import[2], 0, amount)
      && caml_call2(Async_unix_Import[2], amount, t[7])){
     t[6] = t[6] + amount | 0;
     t[7] = t[7] - amount | 0;
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _Z_], 1);
   }
   function sexp_of_handle_chunk_result(of_a_031, param){
    if(typeof param === "number") return ___;
    var _ez_ = param[1];
    if(116552 === _ez_){
     var
      v_038 = param[2],
      arg1_041 = v_038[2],
      arg0_040 = v_038[1],
      res0_042 = caml_call1(Core[389], arg0_040),
      _eA_ = 0;
     if(typeof arg1_041 === "number")
      var res1_043 = _$_;
     else
      var
       v_039 = arg1_041[2],
       res1_043 = [1, [0, _ab_, [0, caml_call1(Core[389], v_039), 0]]];
     return [1, [0, _aa_, [0, [1, [0, res0_042, [0, res1_043, 0]]], _eA_]]];
    }
    if(926227490 <= _ez_){
     var v_032 = param[2];
     return [1, [0, _ac_, [0, caml_call1(of_a_031, v_032), 0]]];
    }
    var
     v_033 = param[2],
     arg1_035 = v_033[2],
     arg0_034 = v_033[1],
     res0_036 = caml_call1(of_a_031, arg0_034),
     res1_037 = caml_call1(Core[389], arg1_035);
    return [1, [0, _ad_, [0, [1, [0, res0_036, [0, res1_037, 0]]], 0]]];
   }
   function sexp_of_read_one_chunk_at_a_ti(of_a_044, param){
    if(typeof param === "number") return _ae_;
    if(280164845 <= param[1]){
     var v_045 = param[2];
     return [1, [0, _af_, [0, caml_call1(of_a_044, v_045), 0]]];
    }
    var v_046 = param[2];
    return [1, [0, _ag_, [0, caml_call1(Core[558], v_046), 0]]];
   }
   function sexp_of_consumed(param){
    var
     v_047 = param[2],
     arg1_050 = v_047[2],
     arg0_049 = v_047[1],
     res0_051 = caml_call1(Core[389], arg0_049),
     _ey_ = 0;
    if(typeof arg1_050 === "number")
     var res1_052 = _ah_;
    else
     var
      v_048 = arg1_050[2],
      res1_052 = [1, [0, _aj_, [0, caml_call1(Core[389], v_048), 0]]];
    return [1, [0, _ai_, [0, [1, [0, res0_051, [0, res1_052, 0]]], _ey_]]];
   }
   function read_one_chunk_at_a_time(t, handle_chunk){
    t[5] = -859789014;
    function _ej_(final_result){
     function loop(force_refill){
      return with_nonempty_buffer$0
              ([0, force_refill],
               t,
               function(param){
                if(3456156 <= param){
                 var
                  result =
                    caml_call2(Async_unix_Import[4], t[7], 0)
                     ? [0,
                       -596537294,
                       caml_call3(Core_Bigstring[16], [0, t[6]], [0, t[7]], t[4])]
                     : 3456156;
                 return caml_call2
                         (Async_kernel_Ivar[14], final_result, result);
                }
                var len = t[7];
                function continue$0(z){
                 var _ek_ = t[8];
                 if(-985294899 !== _ek_){
                  if(-144639815 <= _ek_)
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _an_], 1);
                  return caml_call2
                          (Async_kernel_Ivar[14], final_result, 3456156);
                 }
                 if(typeof z === "number"){consume(t, len); return loop(1);}
                 var _el_ = z[1];
                 if(116552 !== _el_){
                  if(926227490 <= _el_){
                   var a = z[2];
                   consume(t, len);
                   return caml_call2
                           (Async_kernel_Ivar[14], final_result, [0, 280164845, a]);
                  }
                  var
                   match$0 = z[2],
                   consumed$0 = match$0[2],
                   a$0 = match$0[1];
                  consume(t, consumed$0);
                  return caml_call2
                          (Async_kernel_Ivar[14], final_result, [0, 280164845, a$0]);
                 }
                 var
                  match = z[2],
                  need = match[2],
                  consumed = match[1],
                  _em_ = caml_call2(Async_unix_Import[5], consumed, 0);
                 if(_em_)
                  var _en_ = _em_;
                 else{
                  var _ev_ = caml_call2(Async_unix_Import[4], consumed, len);
                  if(_ev_)
                   var _en_ = _ev_;
                  else if(typeof need === "number")
                   var _en_ = 0;
                  else
                   var
                    need$1 = need[2],
                    _ew_ = caml_call2(Async_unix_Import[5], need$1, 0),
                    _ex_ =
                      _ew_
                      ||
                       caml_call2(Async_unix_Import[2], consumed + need$1 | 0, len),
                    _en_ = _ex_;
                 }
                 if(_en_){
                  var
                   _eo_ = [0, [1, [0, _ak_, [0, sexp_of_t$2(t), 0]]], 0],
                   _ep_ =
                     [0,
                      [1, [0, _al_, [0, caml_call1(Core[389], len), 0]]],
                      _eo_],
                   _eq_ = [0, sexp_of_consumed(z), _ep_],
                   _er_ =
                     [1,
                      [0,
                       caml_call1
                        (Sexplib0_Sexp_conv[7], cst_handle_chunk_returned_inva),
                       _eq_]];
                  caml_call1(Core[261], _er_);
                 }
                 consume(t, consumed);
                 var buf_len = caml_call1(Core_Bigstring[21], t[4]);
                 if(typeof need === "number")
                  var
                   new_len =
                     caml_call2(Async_unix_Import[3], t[7], buf_len)
                      ? buf_len * 2 | 0
                      : buf_len;
                 else
                  var
                   need$0 = need[2],
                   _eu_ =
                     caml_call2(Async_unix_Import[4], need$0, buf_len)
                      ? caml_call2(Core_Int[90], need$0, buf_len * 2 | 0)
                      : buf_len,
                   new_len = _eu_;
                 if(caml_call2(Async_unix_Import[5], new_len, 0)){
                  var
                   _es_ =
                     [0, [1, [0, _am_, [0, sexp_of_t_internals(t), 0]]], 0],
                   _et_ =
                     [1,
                      [0,
                       caml_call1
                        (Sexplib0_Sexp_conv[7], cst_read_one_chunk_at_a_time_g),
                       _es_]];
                  caml_call1(Core[261], _et_);
                 }
                 if(caml_call2(Async_unix_Import[4], new_len, buf_len)){
                  var new_buf = caml_call1(Core_Bigstring[121], new_len);
                  if(caml_call2(Async_unix_Import[4], t[7], 0))
                   caml_call5(Core_Bigstring[22], t[4], t[6], new_buf, 0, t[7]);
                  t[4] = new_buf;
                  t[6] = 0;
                 }
                 return loop(1);
                }
                var
                 deferred = caml_call3(handle_chunk, t[4], t[6], len),
                 match = caml_call1(Async_kernel_Deferred[5], deferred);
                if(! match)
                 return caml_call2
                         (Async_unix_Import[27], deferred, continue$0);
                var result$0 = match[1];
                return continue$0(result$0);
               });
     }
     return loop(0);
    }
    return caml_call1(Async_kernel_Deferred[3], _ej_);
   }
   function sexp_of_handle_iobuf_result(of_a_053, param){
    if(typeof param === "number") return _ao_;
    var v_054 = param[2];
    return [1, [0, _ap_, [0, caml_call1(of_a_053, v_054), 0]]];
   }
   function read_one_iobuf_at_a_time(t, handle_chunk){
    var iobuf = caml_call3(Iobuf[12], 0, 0, t[4]);
    return read_one_chunk_at_a_time
            (t,
             function(bstr, pos, len){
              caml_call4(Iobuf[78][12], iobuf, pos, len, bstr);
              function _eh_(handle_result){
               if(caml_call1(Iobuf[32], iobuf)) return handle_result;
               var consumed = len - caml_call1(Iobuf[29], iobuf) | 0;
               if(typeof handle_result === "number")
                return [0, 116552, [0, consumed, 1056277377]];
               var a = handle_result[2];
               return [0, -686730715, [0, a, consumed]];
              }
              var _ei_ = caml_call1(handle_chunk, iobuf);
              return caml_call2(Async_unix_Import[33][3], _ei_, _eh_);
             });
   }
   function Read(S, Name){
    function read_available(t, s){
     var
      _eg_ = caml_call1(S[6], s),
      len = caml_call2(Core_Int[89], t[7], _eg_);
     caml_call4(S[38], s, t[4], t[6], len);
     consume(t, len);
     return len;
    }
    function read(t, s){
     var _ef_ = caml_call1(S[6], s);
     if(caml_call2(Async_unix_Import[3], _ef_, 0))
      caml_call3(Core[250], _aq_, Name[1], 0);
     return with_nonempty_buffer
             (t,
              function(param){
               return 3456156 <= param
                       ? 3456156
                       : [0, 17724, read_available(t, s)];
              });
    }
    function really_read(t, s){
     function _eb_(result){
      function loop(s, amount_read){
       var _ec_ = caml_call1(S[6], s);
       if(caml_call2(Async_unix_Import[3], _ec_, 0))
        return caml_call2(Async_kernel_Ivar[14], result, 17724);
       function _ed_(param){
        if(typeof param === "number")
         return caml_call2
                 (Async_kernel_Ivar[14], result, [0, 3456156, amount_read]);
        var len = param[2];
        return loop(caml_call2(S[46], s, len), amount_read + len | 0);
       }
       var _ee_ = read(t, s);
       return caml_call2(Async_unix_Import[27], _ee_, _ed_);
      }
      return loop(s, 0);
     }
     return caml_call1(Async_kernel_Deferred[3], _eb_);
    }
    return [0, read_available, read, really_read];
   }
   var
    Read_substring = Read(Core_Substring, [0, name]),
    read_substring_available = Read_substring[1],
    read_substring = Read_substring[2],
    really_read_substring = Read_substring[3],
    Read_bigsubstring = Read(Core_Bigsubstring, [0, name$0]),
    read_bigsubstring = Read_bigsubstring[2],
    really_read_bigsubstring = Read_bigsubstring[3];
   function really_read_bigstring(t, bigstring){
    return caml_call2
            (really_read_bigsubstring,
             t,
             caml_call3(Core_Bigsubstring[32], 0, 0, bigstring));
   }
   function peek_available(t, len){
    var _d$_ = t[4], _ea_ = [0, caml_call2(Core_Int[89], len, t[7])];
    return caml_call3(Core_Bigstring[16], [0, t[6]], _ea_, _d$_);
   }
   function peek(t, len){
    function _d9_(param){
     if(typeof param === "number"){
      if(caml_call2(Async_unix_Import[1], t[7], len))
       return [0,
               17724,
               caml_call3(Core_Bigstring[16], [0, t[6]], [0, len], t[4])];
      throw caml_maybe_attach_backtrace([0, Assert_failure, _ar_], 1);
     }
     if(caml_call2(Async_unix_Import[5], t[7], len)) return 3456156;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
    }
    var _d__ = get_data_until(t, len);
    return caml_call2(Async_unix_Import[33][3], _d__, _d9_);
   }
   function read_available(t, pos, len, s){
    return caml_call2
            (read_substring_available,
             t,
             caml_call3(Core_Substring[32], pos, len, s));
   }
   function read(t, pos, len, s){
    return caml_call2
            (read_substring, t, caml_call3(Core_Substring[32], pos, len, s));
   }
   function really_read(t, pos, len, s){
    return caml_call2
            (really_read_substring,
             t,
             caml_call3(Core_Substring[32], pos, len, s));
   }
   function read_char(t){
    return with_nonempty_buffer
            (t,
             function(param){
              if(3456156 <= param) return 3456156;
              var c = caml_ba_get_1(t[4], t[6]);
              consume(t, 1);
              return [0, 17724, c];
             });
   }
   function first_char(t, p, available){
    var limit = t[6] + available | 0, buf = t[4];
    if(892857089 <= p[1]){
     var
      p$0 = p[2],
      _d6_ =
        function(param){
         var pos$1 = t[6], pos = pos$1;
         for(;;){
          if(caml_call2(Async_unix_Import[3], pos, limit)) return 0;
          if(caml_call1(p$0, caml_ba_get_1(buf, pos))) return [0, pos];
          var pos$0 = pos + 1 | 0, pos = pos$0;
         }
        };
     return caml_call2(Core_Or_error[37], 0, _d6_);
    }
    var ch = p[2], pos$1 = t[6], pos = pos$1;
    for(;;){
     if(caml_call2(Async_unix_Import[3], pos, limit))
      var _d8_ = 0;
     else{
      var _d7_ = caml_ba_get_1(buf, pos);
      if(! caml_call2(Base_Char[31][3], ch, _d7_)){
       var pos$0 = pos + 1 | 0, pos = pos$0;
       continue;
      }
      var _d8_ = [0, pos];
     }
     return [0, _d8_];
    }
   }
   function read_until_gen(t, p, keep_delim, max, k){
    function loop(ac, total){
     return with_nonempty_buffer$0
             (0,
              t,
              function(param){
               if(3456156 <= param){
                if(caml_call1(Core_List[18], ac))
                 var _d2_ = 3456156;
                else
                 var
                  _d3_ = caml_call1(Core_List[59], ac),
                  _d2_ =
                    [0, -256425003, caml_call1(Core_Bigsubstring[40], _d3_)];
                return caml_call1(k, [0, _d2_]);
               }
               function concat_helper(ss, lst){
                var _d5_ = caml_call2(Core_List[60], lst, [0, ss, 0]);
                return caml_call1(Core_Bigsubstring[40], _d5_);
               }
               if(max){
                var max$0 = max[1];
                if
                 (caml_call2
                   (Async_unix_Import[5], t[7], (max$0 - total | 0) + 1 | 0))
                 var need_more_bytes_to_exceed_max = 1, available = t[7];
                else
                 var
                  need_more_bytes_to_exceed_max = 0,
                  available = (max$0 - total | 0) + 1 | 0;
               }
               else
                var
                 available$0 = t[7],
                 need_more_bytes_to_exceed_max = 1,
                 available = available$0;
               var e = first_char(t, p, available);
               if(0 !== e[0]) return caml_call1(k, e);
               var match = e[1];
               if(match){
                var
                 pos = match[1],
                 amount_consumed = (pos + 1 | 0) - t[6] | 0,
                 len = keep_delim ? amount_consumed : amount_consumed - 1 | 0,
                 ss =
                   caml_call3(Core_Bigsubstring[32], [0, t[6]], [0, len], t[4]);
                consume(t, amount_consumed);
                var res = concat_helper(ss, ac);
                return caml_call1(k, [0, [0, 17724, res]]);
               }
               if(need_more_bytes_to_exceed_max){
                var
                 len$0 = t[7],
                 total$0 = total + len$0 | 0,
                 ss$0 =
                   caml_call3
                    (Core_Bigsubstring[32], [0, t[6]], [0, len$0], t[4]),
                 _d4_ = caml_call1(Core_Bigstring[21], t[4]);
                t[4] = caml_call1(Core_Bigstring[121], _d4_);
                t[6] = 0;
                t[7] = 0;
                return loop([0, ss$0, ac], total$0);
               }
               var
                ss$1 =
                  caml_call3
                   (Core_Bigsubstring[32], [0, t[6]], [0, available], t[4]);
               consume(t, available);
               var res$0 = concat_helper(ss$1, ac);
               return caml_call1(k, [0, [0, 338397998, res$0]]);
              });
    }
    return loop(0, 0);
   }
   function read_until(t, pred, keep_delim, k){
    return read_until_gen
            (t,
             pred,
             keep_delim,
             0,
             function(x){
              if(0 !== x[0]) return caml_call1(k, x);
              var _d1_ = x[1];
              if(typeof _d1_ !== "number" && 338397998 <= _d1_[1])
               throw caml_maybe_attach_backtrace([0, Assert_failure, _at_], 1);
              return caml_call1(k, x);
             });
   }
   function read_line_gen(t, k){
    return read_until
            (t,
             line_delimiter_pred,
             0,
             function(param){
              if(0 !== param[0])
               throw caml_maybe_attach_backtrace([0, Assert_failure, _au_], 1);
              var x = param[1];
              if(typeof x !== "number" && 17724 <= x[1]){
               var line = x[2], len = caml_ml_string_length(line);
               a:
               {
                if(caml_call2(Async_unix_Import[1], len, 1)){
                 var _dZ_ = runtime.caml_string_get(line, len - 1 | 0);
                 if(caml_call2(Base_Char[31][3], _dZ_, 13)){
                  var _d0_ = caml_call3(Core_String[3], line, 0, len - 1 | 0);
                  break a;
                 }
                }
                var _d0_ = line;
               }
               return caml_call1(k, [0, 17724, _d0_]);
              }
              return caml_call1(k, x);
             });
   }
   function read_line(t){
    function _dY_(result){
     return read_line_gen
             (t,
              function(z){
               a:
               {
                if(typeof z !== "number" && 17724 > z[1]){
                 var str = z[2], z$0 = [0, 17724, str];
                 break a;
                }
                var z$0 = z;
               }
               return caml_call2(Async_kernel_Ivar[14], result, z$0);
              });
    }
    return caml_call1(Async_kernel_Deferred[3], _dY_);
   }
   function really_read_line(wait_time, t){
    function _dS_(result){
     function fill_result(ac){
      if(! ac) return caml_call2(Async_kernel_Ivar[14], result, 0);
      var
       _dW_ = caml_call1(Core_List[59], ac),
       _dX_ = [0, caml_call2(Core_String[46], 0, _dW_)];
      return caml_call2(Async_kernel_Ivar[14], result, _dX_);
     }
     function continue$0(ac){
      var _dT_ = t[8];
      if(-985294899 === _dT_){
       var
        _dU_ = function(param){return loop(ac);},
        _dV_ = caml_call1(Async_unix_Clock[4], wait_time);
       return caml_call2(Async_unix_Import[27], _dV_, _dU_);
      }
      if(-144639815 <= _dT_)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
      return fill_result(ac);
     }
     function loop(ac){
      return read_line_gen
              (t,
               function(param){
                if(typeof param === "number") return continue$0(ac);
                if(17724 <= param[1]){
                 var line = param[2];
                 return fill_result([0, line, ac]);
                }
                var str = param[2];
                return continue$0([0, str, ac]);
               });
     }
     return loop(0);
    }
    return caml_call1(Async_kernel_Deferred[3], _dS_);
   }
   var space = caml_call3(Core_Bigstring[14], 0, 0, cst);
   function gen_read_sexp(parse_pos, t, sexp_kind, k){
    function loop(parse_fun){
     return with_nonempty_buffer$0
             (0,
              t,
              function(param){
               if(3456156 <= param){
                var
                 _dO_ =
                   function(param){return caml_call3(parse_fun, 0, 1, space);},
                 e = caml_call2(Core_Or_error[37], 0, _dO_);
                if(0 !== e[0]) return caml_call1(k, e);
                var match = e[1];
                if(0 === match[0]){
                 var parse_pos = match[2], sexp = match[1];
                 return caml_call1(k, [0, [0, 17724, [0, sexp, parse_pos]]]);
                }
                if(! match[1]) return caml_call1(k, _ax_);
                var
                 _dP_ = [0, [1, [0, _aw_, [0, sexp_of_t$2(t), 0]]], 0],
                 _dQ_ =
                   [1,
                    [0,
                     caml_call1
                      (Sexplib0_Sexp_conv[7], cst_Reader_read_sexp_got_unexp),
                     _dP_]];
                return caml_call1(Core[261], _dQ_);
               }
               function _dR_(param){
                return caml_call3(parse_fun, t[6], t[7], t[4]);
               }
               var e$0 = caml_call2(Core_Or_error[37], 0, _dR_);
               if(0 !== e$0[0]) return caml_call1(k, e$0);
               var match$0 = e$0[1];
               if(0 === match$0[0]){
                var parse_pos$0 = match$0[2], sexp$0 = match$0[1];
                consume(t, parse_pos$0[4] - t[6] | 0);
                return caml_call1
                        (k, [0, [0, 17724, [0, sexp$0, parse_pos$0]]]);
               }
               var parse_fun$0 = match$0[2];
               t[7] = 0;
               return loop(parse_fun$0);
              });
    }
    function parse(pos, len, buf){
     if(parse_pos)
      var
       parse_pos$0 = parse_pos[1],
       parse_pos$1 = caml_call2(Sexplib_Sexp[12][2], parse_pos$0, pos);
     else
      var parse_pos$1 = caml_call5(Sexplib_Sexp[12][1], 0, 0, [0, pos], 0, 0);
     return sexp_kind
             ? caml_call3
               (Sexplib_Sexp[14][7], [0, parse_pos$1], [0, len], buf)
             : caml_call3(Core_Sexp[51], [0, parse_pos$1], [0, len], buf);
    }
    return loop(parse);
   }
   function gen_read_sexps(parse_pos, t, sexp_kind){
    var
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     pipe_w = match[2],
     pipe_r = match[1];
    function _dH_(result){
     function loop(parse_pos){
      return gen_read_sexp
              (parse_pos,
               t,
               sexp_kind,
               function(param){
                if(0 !== param[0]){
                 var error = param[1];
                 return caml_call1(Core_Error[30], error);
                }
                var _dL_ = param[1];
                if(typeof _dL_ === "number")
                 return caml_call2(Async_kernel_Ivar[14], result, 0);
                var match = _dL_[2], parse_pos = match[2], sexp = match[1];
                if(caml_call1(Async_kernel_Pipe[17], pipe_w))
                 return caml_call2(Async_kernel_Ivar[14], result, 0);
                function _dM_(param){return loop([0, parse_pos]);}
                var _dN_ = caml_call2(Async_kernel_Pipe[29], pipe_w, sexp);
                return caml_call2(Async_unix_Import[27], _dN_, _dM_);
               });
     }
     return loop(parse_pos);
    }
    var finished = caml_call1(Async_kernel_Deferred[3], _dH_);
    function _dI_(param){
     function _dJ_(param){return caml_call1(Async_kernel_Pipe[15], pipe_w);}
     var _dK_ = close(t);
     return caml_call2(Async_unix_Import[27], _dK_, _dJ_);
    }
    caml_call2(Async_unix_Import[22], finished, _dI_);
    return pipe_r;
   }
   function read_sexps(parse_pos, t){return gen_read_sexps(parse_pos, t, 0);}
   function read_annotated_sexps(parse_pos, t){return gen_read_sexps(parse_pos, t, 1);
   }
   function unexpected_pos(bin_type, t, old_pos, read_len, new_pos){
    var
     _dB_ = [0, [1, [0, _ay_, [0, caml_call1(Core[389], new_pos), 0]]], 0],
     _dC_ = [0, [1, [0, _az_, [0, caml_call1(Core[389], read_len), 0]]], _dB_],
     _dD_ = [0, [1, [0, _aA_, [0, caml_call1(Core[389], old_pos), 0]]], _dC_],
     _dE_ = [0, [1, [0, _aB_, [0, sexp_of_t$2(t), 0]]], _dD_],
     _dF_ = [0, [1, [0, _aC_, [0, caml_call1(Core[558], bin_type), 0]]], _dE_],
     _dG_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Unexpected_reader_position),
         _dF_]];
    return [2, caml_call1(Core_Error[20], _dG_)];
   }
   function size_error(message, t, size, pos){
    var
     _dx_ = [0, [1, [0, _aD_, [0, caml_call1(Core[389], pos), 0]]], 0],
     _dy_ = [0, [1, [0, _aE_, [0, caml_call1(Core[389], size), 0]]], _dx_],
     _dz_ = [0, [1, [0, _aF_, [0, sexp_of_t$2(t), 0]]], _dy_],
     _dA_ = [1, [0, caml_call1(Sexplib0_Sexp_conv[7], message), _dz_]];
    return [2, caml_call1(Core_Error[20], _dA_)];
   }
   function read_raw(t, buf, pos_ref, len, bin_prot_reader){
    if(caml_call2(Async_unix_Import[5], len, Bin_prot_Utils[1]))
     return [1, Bin_prot_Utils[1]];
    var
     header_pos = pos_ref[1],
     message_size = caml_call2(Bin_prot_Utils[2], buf, pos_ref);
    if
     (caml_call2
       (Async_unix_Import[6], pos_ref[1], header_pos + Bin_prot_Utils[1] | 0))
     return unexpected_pos
             (cst_header, t, header_pos, Bin_prot_Utils[1], pos_ref[1]);
    if
     (caml_call2
       (Async_unix_Import[5], len - Bin_prot_Utils[1] | 0, message_size)){
     var bytes_needed = Bin_prot_Utils[1] + message_size | 0;
     return caml_call2(Async_unix_Import[5], message_size, 0)
             ? size_error
               (cst_Negative_message_size, t, message_size, header_pos)
             : caml_call2
                (Async_unix_Import[5], bytes_needed, 0)
               ? size_error
                 (cst_Bytes_needed_overflowed, t, bytes_needed, header_pos)
               : [1, bytes_needed];
    }
    var
     message_pos = pos_ref[1],
     message = caml_call2(bin_prot_reader[1], buf, pos_ref);
    return caml_call2
             (Async_unix_Import[6],
              pos_ref[1],
              message_pos + message_size | 0)
            ? unexpected_pos
              (cst_message, t, message_pos, message_size, pos_ref[1])
            : [0, message];
   }
   var Read_bin_prot = [0, unexpected_pos, size_error, read_raw];
   function sexp_of_t$3(param){return param ? _aG_ : _aH_;}
   var
    to_string = caml_call1(Sexplib_Conv[80], sexp_of_t$3),
    Peek_or_read = [0, sexp_of_t$3, to_string];
   function peek_or_read_bin_prot(opt, t, peek_or_read, bin_prot_reader, k){
    if(opt) var sth = opt[1], max_len = sth; else var max_len = Core_Int[45];
    function error(f){
     function _dv_(msg, param){
      function _dw_(param){
       var
        arg1_057 = param[2],
        arg0_056 = param[1],
        res0_058 = caml_call1(Core[558], arg0_056),
        res1_059 = sexp_of_t$2(arg1_057);
       return [1, [0, res0_058, [0, res1_059, 0]]];
      }
      return caml_call1
              (k,
               caml_call5
                (Core_Or_error[44],
                 0,
                 0,
                 cst_Reader_read_bin_prot,
                 [0, msg, t],
                 _dw_));
     }
     return caml_call2(Core[254], _dv_, f);
    }
    if(caml_call2(Async_unix_Import[5], max_len, 0))
     return caml_call2(error(_aK_), max_len, 0);
    var
     len_with_header = max_len + Bin_prot_Utils[1] | 0,
     max_len_with_header =
       caml_call2(Async_unix_Import[5], len_with_header, max_len)
        ? Core_Int[45]
        : len_with_header;
    function read_loop(param){
     var _ds_ = t[8];
     if(-985294899 === _ds_){
      var
       pos = t[6],
       pos_ref = [0, pos],
       len = caml_call2(Async_unix_Import[9], max_len_with_header, t[7]);
      try{
       var
        val =
          caml_call5(Read_bin_prot[3], t, t[4], pos_ref, len, bin_prot_reader);
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       return caml_call1(k, caml_call2(Core_Or_error[41], 0, exn));
      }
      switch(val[0]){
        case 0:
         var message = val[1];
         if(peek_or_read) consume(t, pos_ref[1] - pos | 0);
         return caml_call1(k, [0, [0, 17724, message]]);
        case 1:
         var need = val[1], need_message = need - Bin_prot_Utils[1] | 0;
         if(caml_call2(Async_unix_Import[4], need_message, max_len))
          return caml_call3(error(_aL_), need_message, max_len, 0);
         var
          _dt_ =
            function(param){
             if(typeof param === "number") return read_loop(0);
             var n = param[2];
             return caml_call2(Async_unix_Import[3], n, 0)
                     ? caml_call1(k, _aI_)
                     : caml_call3(error(_aJ_), n, need, 0);
            },
          _du_ = get_data_until(t, need);
         return caml_call2(Async_unix_Import[27], _du_, _dt_);
        default: var error$0 = val[1]; return caml_call1(k, [1, error$0]);
      }
     }
     if(-144639815 <= _ds_)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _aM_], 1);
     return caml_call1(error(_aN_), 0);
    }
    return read_loop(0);
   }
   function iter_bin_prot(t, bin_prot_reader, f){
    function handle_chunk(buf, chunk_pos, len){
     var limit = chunk_pos + len | 0, pos_ref = [0, chunk_pos];
     function read_loop(param){
      var
       header_pos = pos_ref[1],
       len = limit - header_pos | 0,
       match =
         caml_call5(Read_bin_prot[3], t, buf, pos_ref, len, bin_prot_reader);
      switch(match[0]){
        case 0:
         var
          message = match[1],
          _dq_ = function(param){return read_loop(0);},
          _dr_ = caml_call1(f, message);
         return caml_call2(Eager_deferred[12][4][2], _dr_, _dq_);
        case 1:
         var bytes = match[1];
         return caml_call2(Async_unix_Import[3], header_pos, limit)
                 ? caml_call1(Eager_deferred[12][1], 192584839)
                 : caml_call1
                   (Eager_deferred[12][1],
                    [0,
                     116552,
                     [0, header_pos - chunk_pos | 0, [0, 870031478, bytes]]]);
        default:
         var error = match[1];
         return caml_call1(Eager_deferred[12][1], [0, 926227490, error]);
      }
     }
     function _dl_(param){
      if(0 === param[0]){var result = param[1]; return result;}
      var
       exn = param[1],
       _dn_ = [0, [1, [0, _aO_, [0, sexp_of_t$2(t), 0]]], 0],
       _do_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Error_deserializing_reader),
           _dn_]],
       _dp_ = caml_call2(Core_Error[27], 0, exn);
      return [0, 926227490, caml_call2(Core_Error[23], _dp_, _do_)];
     }
     var
      _dm_ = caml_call7(Async_unix_Import[21], 0, 0, 0, 0, _aP_, 0, read_loop);
     return caml_call2(Eager_deferred[12][4][3], _dm_, _dl_);
    }
    function _de_(result){
     function _dg_(param){
      if(typeof result === "number")
       return Async_kernel_Deferred_or_error[37];
      if(280164845 <= result[1]){
       var error = result[2];
       return caml_call1(Eager_deferred[12][1], [1, error]);
      }
      var
       data = result[2],
       length = caml_ml_string_length(data),
       _di_ = [0, [1, [0, _aQ_, [0, caml_call1(Core[558], data), 0]]], 0],
       _dj_ = [0, [1, [0, _aR_, [0, caml_call1(Core[389], length), 0]]], _di_],
       _dk_ =
         [1,
          [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Unconsumed_data), _dj_]];
      return caml_call1(Async_kernel_Deferred_or_error[25], _dk_);
     }
     var _dh_ = close(t);
     return caml_call2(Eager_deferred[12][4][2], _dh_, _dg_);
    }
    var _df_ = read_one_chunk_at_a_time(t, handle_chunk);
    return caml_call2(Eager_deferred[12][4][2], _df_, _de_);
   }
   function read_marshal_raw(t){
    function eofn(n){
     if(caml_call2(Async_unix_Import[3], n, 0)) return 3456156;
     var
      _dc_ = [0, caml_call1(Core[389], n), 0],
      _dd_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Reader_read_marshal_got_EO),
          _dc_]];
     return caml_call1(Core[261], _dd_);
    }
    var header = caml_call1(Core_Bytes[44], Stdlib_Marshal[6]);
    function _c9_(param){
     if(typeof param === "number"){
      var
       len = caml_call2(Stdlib_Marshal[7], header, 0),
       buf = caml_call1(Core_Bytes[44], len + Stdlib_Marshal[6] | 0);
      caml_call5(Core_Bytes[17], header, 0, buf, 0, Stdlib_Marshal[6]);
      var
       sub =
         caml_call3(Core_Substring[32], [0, Stdlib_Marshal[6]], [0, len], buf),
       _c$_ =
         function(param){
          if(typeof param === "number") return [0, 17724, buf];
          var n = param[2];
          return eofn(n);
         },
       _da_ = caml_call2(really_read_substring, t, sub);
      return caml_call2(Async_unix_Import[33][3], _da_, _c$_);
     }
     var n = param[2], _db_ = eofn(n);
     return caml_call1(Async_unix_Import[30], _db_);
    }
    var _c__ = really_read(t, 0, 0, header);
    return caml_call2(Async_unix_Import[33][2], _c__, _c9_);
   }
   function read_marshal(t){
    function _c7_(param){
     if(typeof param === "number") return 3456156;
     var buf = param[2];
     return [0, 17724, caml_call2(Stdlib_Marshal[4], buf, 0)];
    }
    var _c8_ = read_marshal_raw(t);
    return caml_call2(Async_unix_Import[33][3], _c8_, _c7_);
   }
   function read_all(opt, t, read_one){
    if(opt)
     var sth = opt[1], close_when_finished = sth;
    else
     var close_when_finished = 1;
    var
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     pipe_w = match[2],
     pipe_r = match[1];
    function _cZ_(param){
     function _c3_(param){
      if(typeof param === "number")
       return caml_call1(Async_unix_Import[30], _aS_);
      var one = param[2];
      if(caml_call1(Async_kernel_Pipe[17], pipe_w))
       return caml_call1(Async_unix_Import[30], _aT_);
      function _c5_(param){return _aU_;}
      var _c6_ = caml_call2(Async_kernel_Pipe[29], pipe_w, one);
      return caml_call2(Async_unix_Import[33][3], _c6_, _c5_);
     }
     var _c4_ = caml_call1(read_one, t);
     return caml_call2(Async_unix_Import[33][2], _c4_, _c3_);
    }
    var finished = caml_call2(Async_kernel_Deferred[31], 0, _cZ_);
    function _c0_(param){
     function _c1_(param){return caml_call1(Async_kernel_Pipe[15], pipe_w);}
     var
      _c2_ =
        close_when_finished ? close(t) : caml_call1(Async_unix_Import[30], 0);
     return caml_call2(Async_unix_Import[27], _c2_, _c1_);
    }
    caml_call2(Async_unix_Import[22], finished, _c0_);
    return pipe_r;
   }
   function lines(t){return read_all(0, t, read_line);}
   function contents(t){
    var
     buf = caml_call1(Base_Buffer[2], 1024),
     sbuf = caml_call1(Core_Bytes[44], 1024);
    function _cS_(param){
     function _cX_(param){return caml_call1(Base_Buffer[3], buf);}
     var _cY_ = close(t);
     return caml_call2(Async_unix_Import[33][3], _cY_, _cX_);
    }
    function _cT_(param){
     function _cV_(param){
      if(typeof param === "number") return _aV_;
      var l = param[2];
      caml_call4(Base_Buffer[19], buf, sbuf, 0, l);
      return _aW_;
     }
     var _cW_ = read(t, 0, 0, sbuf);
     return caml_call2(Async_unix_Import[33][3], _cW_, _cV_);
    }
    var _cU_ = caml_call2(Async_kernel_Deferred[31], 0, _cT_);
    return caml_call2(Async_unix_Import[33][2], _cU_, _cS_);
   }
   function recv(t){
    function _cH_(i){
     function _cI_(param){
      if(typeof param === "number")
       return caml_call2(Async_kernel_Ivar[14], i, 3456156);
      var length_str = param[2];
      try{
       var _cP_ = [0, runtime.caml_int_of_string(length_str)], match = _cP_;
      }
      catch(_cR_){var match = _aX_;}
      if(0 === match[0]){
       var
        length = match[1],
        buf = caml_call1(Core_Bytes[44], length),
        _cK_ =
          function(param){
           if(typeof param === "number")
            return caml_call2(Async_kernel_Ivar[14], i, [0, 17724, buf]);
           var
            _cQ_ =
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Reader_recv_got_unexpected);
           return caml_call1(Core[261], _cQ_);
          },
        _cL_ = really_read(t, 0, 0, buf);
       return caml_call2(Async_unix_Import[27], _cL_, _cK_);
      }
      var
       _cM_ = [0, [1, [0, _aY_, [0, sexp_of_t$2(t), 0]]], 0],
       _cN_ =
         [0, [1, [0, _aZ_, [0, caml_call1(Core[558], length_str), 0]]], _cM_],
       _cO_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Reader_recv_got_strange_le),
           _cN_]];
      return caml_call1(Core[261], _cO_);
     }
     var _cJ_ = read_line(t);
     return caml_call2(Async_unix_Import[27], _cJ_, _cI_);
    }
    return caml_call1(Async_kernel_Deferred[3], _cH_);
   }
   function transfer(t, pipe_w){
    function _cA_(finished){
     function _cB_(param){
      return caml_call2(Async_kernel_Ivar[16], finished, 0);
     }
     var
      _cC_ = caml_call1(Async_kernel_Pipe[18], pipe_w),
      _cD_ = caml_call2(Async_unix_Import[33][3], _cC_, _cB_);
     caml_call1(Async_unix_Import[16], _cD_);
     function loop(param){
      return with_nonempty_buffer$0
              (0,
               t,
               function(param){
                if(3456156 <= param)
                 return caml_call2(Async_kernel_Ivar[16], finished, 0);
                var _cE_ = 1 - caml_call1(Async_kernel_Pipe[17], pipe_w);
                if(! _cE_) return _cE_;
                var pos = t[6], len = t[7];
                consume(t, len);
                var
                 _cF_ =
                   caml_call3(Core_Bigstring[16], [0, pos], [0, len], t[4]),
                 _cG_ = caml_call2(Async_kernel_Pipe[29], pipe_w, _cF_);
                return caml_call2(Async_unix_Import[27], _cG_, loop);
               });
     }
     return loop(0);
    }
    return caml_call1(Async_kernel_Deferred[3], _cA_);
   }
   var
    Internal =
      [0,
       State,
       sexp_of_open_flags,
       open_flags,
       last_read_time,
       state,
       available,
       pos,
       close_may_destroy_buf,
       buf,
       bytes_read,
       id,
       fd,
       sexp_of_t$2,
       sexp_of_t_internals,
       invariant,
       create,
       of_in_channel,
       open_file,
       stdin,
       close_finished,
       is_closed,
       empty_buf,
       destroy,
       close,
       with_close,
       with_reader_exclusive,
       with_file,
       read_syscall_with_timestamp,
       get_data,
       maybe_grow_buf_len,
       get_data_until,
       with_nonempty_buffer,
       with_nonempty_buffer$0,
       consume,
       sexp_of_handle_chunk_result,
       sexp_of_read_one_chunk_at_a_ti,
       sexp_of_consumed,
       read_one_chunk_at_a_time,
       sexp_of_handle_iobuf_result,
       read_one_iobuf_at_a_time,
       Read,
       Read_substring,
       read_substring_available,
       read_substring,
       really_read_substring,
       Read_bigsubstring,
       read_bigsubstring,
       really_read_bigsubstring,
       really_read_bigstring,
       peek_available,
       peek,
       read_available,
       read,
       really_read,
       read_char,
       first_char,
       read_until_gen,
       read_until,
       line_delimiter_pred,
       read_line_gen,
       read_line,
       really_read_line,
       space,
       gen_read_sexp,
       gen_read_sexps,
       read_sexps,
       read_annotated_sexps,
       Read_bin_prot,
       Peek_or_read,
       peek_or_read_bin_prot,
       iter_bin_prot,
       read_marshal_raw,
       read_marshal,
       read_all,
       lines,
       contents,
       recv,
       transfer],
    sexp_of_t$4 = Internal[13],
    sexp_of_handle_chunk_result$0 = Internal[35],
    sexp_of_handle_iobuf_result$0 = Internal[39],
    sexp_of_read_one_chunk_at_a_ti$0 = Internal[36],
    close$0 = Internal[24],
    close_finished$0 = Internal[20],
    create$0 = Internal[16],
    fd$0 = Internal[12],
    id$0 = Internal[11],
    invariant$0 = Internal[15],
    bytes_read$0 = Internal[10],
    is_closed$0 = Internal[21],
    last_read_time$0 = Internal[4],
    of_in_channel$0 = Internal[17],
    open_file$0 = Internal[18],
    stdin$0 = Internal[19],
    with_close$0 = Internal[25],
    with_file$0 = Internal[27];
   function use(t){
    function error(reason){
     var
      _cx_ = [0, [1, [0, _a0_, [0, caml_call1(sexp_of_t$4, t), 0]]], 0],
      _cy_ = [0, [1, [0, _a1_, [0, caml_call1(Core[558], reason), 0]]], _cx_],
      _cz_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_can_not_read_from_reader),
          _cy_]];
     return caml_call1(Core[261], _cz_);
    }
    var _cw_ = t[8];
    return -985294899 === _cw_
            ? error(cst_in_use)
            : -144639815 <= _cw_ ? (t[8] = -985294899, 0) : error(cst_closed);
   }
   function finished_read(t){
    var _cv_ = t[8];
    if(-985294899 === _cv_){t[8] = -144639815; return 0;}
    if(-144639815 <= _cv_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a2_], 1);
    return 0;
   }
   function do_read_now(t, f){
    use(t);
    var x = caml_call1(f, 0);
    finished_read(t);
    return x;
   }
   function bytes_available(t){
    return do_read_now(t, function(param){return t[7];});
   }
   function peek_available$0(t, len){
    return do_read_now
            (t, function(param){return caml_call2(Internal[50], t, len);});
   }
   function read_available$0(t, pos, len, s){
    return do_read_now
            (t,
             function(param){return caml_call4(Internal[52], t, pos, len, s);});
   }
   function do_read(t, f){
    use(t);
    function _ct_(x){finished_read(t); return x;}
    var _cu_ = caml_call1(f, 0);
    return caml_call2(Async_unix_Import[33][3], _cu_, _ct_);
   }
   function peek$0(t, len){
    if(caml_call2(Async_unix_Import[5], len, 0)){
     var
      _cr_ = [0, [1, [0, _a3_, [0, caml_call1(Core[389], len), 0]]], 0],
      _cs_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Reader_peek_got_negative_l),
          _cr_]];
     caml_call1(Core[261], _cs_);
    }
    return do_read
            (t, function(param){return caml_call2(Internal[51], t, len);});
   }
   function read$0(t, pos, len, s){
    return do_read
            (t,
             function(param){return caml_call4(Internal[53], t, pos, len, s);});
   }
   function read_char$0(t){
    return do_read(t, function(param){return caml_call1(Internal[55], t);});
   }
   function read_substring$0(t, s){
    return do_read(t, function(param){return caml_call2(Internal[44], t, s);});
   }
   function read_bigsubstring$0(t, s){
    return do_read(t, function(param){return caml_call2(Internal[47], t, s);});
   }
   function read_one_chunk_at_a_time$0(t, handle_chunk){
    return do_read
            (t,
             function(param){
              return caml_call2(Internal[38], t, handle_chunk);
             });
   }
   function read_one_iobuf_at_a_time$0(t, handle_chunk){
    return do_read
            (t,
             function(param){
              return caml_call2(Internal[40], t, handle_chunk);
             });
   }
   function really_read$0(t, pos, len, s){
    return do_read
            (t,
             function(param){return caml_call4(Internal[54], t, pos, len, s);});
   }
   function really_read_substring$0(t, s){
    return do_read(t, function(param){return caml_call2(Internal[45], t, s);});
   }
   function really_read_bigsubstring$0(t, s){
    return do_read(t, function(param){return caml_call2(Internal[48], t, s);});
   }
   function read_line$0(t){
    return do_read(t, function(param){return caml_call1(Internal[61], t);});
   }
   function really_read_line$0(wait_time, t){
    return do_read
            (t,
             function(param){return caml_call2(Internal[62], wait_time, t);});
   }
   function do_read_k(t, read_k, make_result){
    use(t);
    function _cp_(result){
     return caml_call1
             (read_k,
              function(r){
               finished_read(t);
               var _cq_ = caml_call1(make_result, caml_call1(Core[255], r));
               return caml_call2(Async_kernel_Ivar[14], result, _cq_);
              });
    }
    return caml_call1(Async_kernel_Deferred[3], _cp_);
   }
   function read_until$0(t, p, keep_delim){
    function _cn_(_co_){return _co_;}
    return do_read_k(t, caml_call3(Internal[58], t, p, keep_delim), _cn_);
   }
   function read_until_bounded(t, p, keep_delim, max){
    function _cl_(_cm_){return _cm_;}
    return do_read_k
            (t, caml_call4(Internal[57], t, p, keep_delim, [0, max]), _cl_);
   }
   function read_sexp(parse_pos, t){
    function _ck_(param){
     if(typeof param === "number") return 3456156;
     var sexp = param[2][1];
     return [0, 17724, sexp];
    }
    return do_read_k(t, caml_call3(Internal[64], parse_pos, t, 0), _ck_);
   }
   function read_sexps$0(parse_pos, t){
    use(t);
    return caml_call2(Internal[66], parse_pos, t);
   }
   function read_annotated_sexps$0(parse_pos, t){
    use(t);
    return caml_call2(Internal[67], parse_pos, t);
   }
   function peek_or_read_bin_prot$0(max_len, t, reader, peek_or_read){
    function _ci_(_cj_){return _cj_;}
    return do_read_k
            (t,
             caml_call4(Internal[70], max_len, t, peek_or_read, reader),
             _ci_);
   }
   function peek_bin_prot(max_len, t, reader){
    return peek_or_read_bin_prot$0(max_len, t, reader, 0);
   }
   function read_bin_prot(max_len, t, reader){
    return peek_or_read_bin_prot$0(max_len, t, reader, 1);
   }
   function iter_bin_prot$0(t, reader, f){
    use(t);
    return caml_call3(Internal[71], t, reader, f);
   }
   function iter_bin_prot_exn(t, reader, f){
    var _cg_ = Core[255], _ch_ = iter_bin_prot$0(t, reader, f);
    return caml_call2(Async_unix_Import[32], _ch_, _cg_);
   }
   function read_bin_prot_into_pipe(t, reader, f){
    function _ca_(writer){
     function _cb_(param){
      var _cf_ = caml_call1(close$0, t);
      return caml_call1(Async_unix_Import[16], _cf_);
     }
     var _cc_ = caml_call1(Async_kernel_Pipe[18], writer);
     caml_call2(Async_unix_Import[22], _cc_, _cb_);
     return iter_bin_prot_exn
             (t,
              reader,
              function(element){
               var
                _cd_ = caml_call1(Async_kernel_Pipe[34], writer),
                _ce_ = caml_call1(f, element);
               return caml_call2(Eager_deferred[2], _ce_, _cd_);
              });
    }
    return caml_call3(Async_kernel_Pipe[5], 0, 0, _ca_);
   }
   function read_marshal_raw$0(t){
    return do_read(t, function(param){return caml_call1(Internal[72], t);});
   }
   function read_marshal$0(t){
    return do_read(t, function(param){return caml_call1(Internal[73], t);});
   }
   function recv$0(t){
    return do_read(t, function(param){return caml_call1(Internal[77], t);});
   }
   function read_all$0(close_when_finished, t, read_one){
    return caml_call3(Internal[74], close_when_finished, t, read_one);
   }
   function lines$0(t){use(t); return caml_call1(Internal[75], t);}
   function contents$0(t){
    return do_read(t, function(param){return caml_call1(Internal[76], t);});
   }
   function file_contents(file){
    return caml_call4(with_file$0, 0, 0, file, contents$0);
   }
   function file_lines(file){
    function _b9_(t){
     var _b$_ = lines$0(t);
     return caml_call1(Async_kernel_Pipe[78], _b$_);
    }
    var _b__ = caml_call2(open_file$0, 0, file);
    return caml_call2(Async_unix_Import[33][2], _b__, _b9_);
   }
   function transfer$0(t){use(t); return caml_call1(Internal[78], t);}
   function lseek(t, offset, mode){
    return do_read
            (t,
             function(param){
              t[6] = 0;
              t[7] = 0;
              return caml_call3
                      (Async_unix_Unix_syscalls[18], t[1], offset, mode);
             });
   }
   function ltell(t){
    return do_read
            (t,
             function(param){
              function _b7_(fd_offset){
               return runtime.caml_int64_sub
                       (fd_offset, runtime.caml_int64_of_int32(t[7]));
              }
              var
               _b8_ =
                 caml_call3
                  (Async_unix_Unix_syscalls[18],
                   t[1],
                   Core_Int64[58],
                   3358048);
              return caml_call2(Async_unix_Import[33][3], _b8_, _b7_);
             });
   }
   function get_error(file, sexp_kind, a_of_sexp, annotated_sexp){
    try{
     var
      annotated_sexp$0 =
        sexp_kind
         ? annotated_sexp
         : caml_call1(Sexplib_Sexp[14][3], annotated_sexp);
     caml_call1(a_of_sexp, annotated_sexp$0);
     return _a4_;
    }
    catch(exn$1){
     var
      exn = caml_wrap_exception(exn$1),
      unexpected_error =
        function(param){
         function _b6_(param){
          var
           arg1_077 = param[2],
           arg0_076 = param[1],
           res0_078 = caml_call1(Core[558], arg0_076),
           res1_079 = caml_call1(Core[625], arg1_077);
          return [1, [0, res0_078, [0, res1_079, 0]]];
         }
         return caml_call5
                 (Core[244],
                  0,
                  0,
                  cst_Reader_load_sexp_error,
                  [0, file, exn],
                  _b6_);
        };
     if(exn[1] !== Core[153]) return unexpected_error(0);
     var
      bad_sexp = exn[3],
      exc = exn[2],
      match = caml_call2(Sexplib_Sexp[14][5], annotated_sexp, bad_sexp);
     if(! match) return unexpected_error(0);
     var
      bad_annotated_sexp = match[1],
      match$0 =
        caml_call3(Sexplib_Sexp[14][18], file, exc, bad_annotated_sexp);
     if(match$0[1] === Core[153]){
      var match$1 = match$0[2];
      if(match$1[1] === Sexplib_Sexp[14][2]){
       var
        sexp = match$0[3],
        exn$0 = match$1[3],
        pos = match$1[2],
        _b5_ =
          function(param){
           var
            arg3_083 = param[4],
            arg2_082 = param[3],
            arg1_081 = param[2],
            arg0_080 = param[1],
            res0_084 = caml_call1(Core[558], arg0_080),
            res1_085 = caml_call1(Core[625], arg1_081),
            res2_086 = caml_call1(Core[558], arg2_082),
            res3_087 = caml_call1(Core_Sexp[93], arg3_083);
           return [1,
                   [0,
                    res0_084,
                    [0, res1_085, [0, res2_086, [0, res3_087, 0]]]]];
          };
       return caml_call5
               (Core_Or_error[44],
                0,
                0,
                cst_invalid_sexp,
                [0, pos, exn$0, cst_in, sexp],
                _b5_);
      }
     }
     return unexpected_error(0);
    }
   }
   function gen_load_exn(exclusive, sexp_kind, file, convert, get_error){
    var may_load_file_multiple_times = [0, 0];
    function load(sexp_kind){
     function _bW_(param){
      if(0 === param[0]){var sexps = param[1]; return sexps;}
      var exn = param[1];
      if(exn[1] !== Core_Sexp[49]) throw caml_maybe_attach_backtrace(exn, 0);
      var
       match = exn[2],
       parse_state = match[2],
       err_msg = match[1],
       parse_pos = parse_state[2][1];
      function _b2_(param){
       var
        arg1_089 = param[2],
        arg0_088 = param[1],
        res0_090 = caml_call1(Core[558], arg0_088),
        res1_091 = caml_call1(Core[558], arg1_089);
       return [1, [0, res0_090, [0, res1_091, 0]]];
      }
      var
       _b3_ =
         [0,
          caml_call4(Core[265], _a5_, file, parse_pos[1], parse_pos[2]),
          err_msg],
       _b4_ =
         caml_call5
          (Core_Error[19], 0, 0, cst_syntax_error_when_parsing_, _b3_, _b2_);
      return caml_call1(Core_Error[30], _b4_);
     }
     function _bX_(param){
      return caml_call4
              (with_file$0,
               0,
               exclusive,
               file,
               function(t){
                var
                 _bZ_ = caml_call1(fd$0, t),
                 match = caml_call1(Async_unix_Fd[8], _bZ_);
                a:
                {
                 if(typeof match === "number" && 2 <= match){var _b0_ = 1; break a;}
                 var _b0_ = 0;
                }
                may_load_file_multiple_times[1] = _b0_;
                use(t);
                var _b1_ = caml_call3(Internal[65], 0, t, sexp_kind);
                return caml_call1(Async_kernel_Pipe[78], _b1_);
               });
     }
     var
      _bY_ =
        caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _a8_, _a7_, _a6_, _bX_);
     return caml_call2(Async_unix_Import[33][3], _bY_, _bW_);
    }
    function _bJ_(sexps){
     try{
      var
       _bT_ = caml_call1(convert, sexps),
       _bU_ = caml_call1(Async_unix_Import[30], _bT_);
      return _bU_;
     }
     catch(exn$1){
      var exn = caml_wrap_exception(exn$1);
      if(exn[1] !== Core[153]){
       var
        _bQ_ = [0, [1, [0, _a$_, [0, caml_call1(Core[625], exn), 0]]], 0],
        _bR_ = [0, [1, [0, _ba_, [0, caml_call1(Core[558], file), 0]]], _bQ_],
        _bS_ =
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_Reader_load_sexp_s_error),
            _bR_]];
       return caml_call1(Core[261], _bS_);
      }
      var exn$0 = exn[2];
      if(may_load_file_multiple_times[1]){
       var
        _bL_ =
          function(sexps){
           var _bV_ = caml_call1(get_error, sexps);
           return caml_call1(Core_Error[30], _bV_);
          },
        _bM_ = load(1);
       return caml_call2(Async_unix_Import[33][2], _bM_, _bL_);
      }
      var
       _bN_ = [0, [1, [0, _a9_, [0, caml_call1(Core[625], exn$0), 0]]], 0],
       _bO_ = [0, [1, [0, _a__, [0, caml_call1(Core[558], file), 0]]], _bN_],
       _bP_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_invalid_sexp_failed_to_det),
           _bO_]];
      return caml_call1(Core[261], _bP_);
     }
    }
    var _bK_ = load(sexp_kind);
    return caml_call2(Async_unix_Import[33][2], _bK_, _bJ_);
   }
   function get_load_result_exn(param){
    if(1025039613 <= param[1]){var x = param[2]; return x;}
    var exn = param[2][1];
    throw caml_maybe_attach_backtrace(exn, 0);
   }
   function gen_load_sexp_exn(exclusive, sexp_kind, file, a_of_sexp, param){
    function multiple(sexps){
     function _bH_(param){
      var
       arg1_095 = param[2],
       arg0_094 = param[1],
       res0_096 = caml_call1(Core[389], arg0_094),
       res1_097 = caml_call1(Core[558], arg1_095);
      return [1, [0, res0_096, [0, res1_097, 0]]];
     }
     var _bI_ = [0, caml_call1(Core_List[45], sexps), file];
     return caml_call5
             (Core_Error[19],
              0,
              0,
              cst_Reader_load_sexp_requires_,
              _bI_,
              _bH_);
    }
    function _bD_(annot_sexps){
     if(annot_sexps && ! annot_sexps[2]){
      var
       annot_sexp = annot_sexps[1],
       match = get_error(file, sexp_kind, a_of_sexp, annot_sexp);
      if(0 === match[0]){
       var
        _bF_ = Core_Sexp[93],
        _bG_ = caml_call1(Sexplib_Sexp[14][3], annot_sexp);
       return caml_call5
               (Core_Error[19],
                0,
                0,
                cst_conversion_of_annotated_se,
                _bG_,
                _bF_);
      }
      var e = match[1];
      return e;
     }
     return multiple(annot_sexps);
    }
    return gen_load_exn
            (exclusive,
             sexp_kind,
             file,
             function(sexps){
              if(sexps && ! sexps[2]){
               var sexp = sexps[1];
               return caml_call1(a_of_sexp, sexp);
              }
              var _bE_ = multiple(sexps);
              return caml_call1(Core_Error[30], _bE_);
             },
             _bD_);
   }
   function load_sexp_exn(exclusive, file, a_of_sexp){
    return gen_load_sexp_exn(exclusive, 0, file, a_of_sexp, 0);
   }
   function load_annotated_sexp_exn(exclusive, file, a_of_sexp){return gen_load_sexp_exn(exclusive, 1, file, a_of_sexp, 0);
   }
   function gen_load_sexp(exclusive, sexp_kind, file, a_of_sexp, param){
    function _bB_(_bC_){
     return gen_load_sexp_exn(exclusive, sexp_kind, file, a_of_sexp, _bC_);
    }
    return caml_call6
            (Async_kernel_Deferred_or_error[38], _bd_, _bc_, _bb_, 0, 0, _bB_);
   }
   function load_sexp(exclusive, file, a_of_sexp){
    return gen_load_sexp(exclusive, 0, file, a_of_sexp, 0);
   }
   function load_annotated_sexp(exclusive, file, a_of_sexp){return gen_load_sexp(exclusive, 1, file, a_of_sexp, 0);
   }
   function gen_load_sexps_exn(exclusive, sexp_kind, file, a_of_sexp, param){
    function _by_(annot_sexps){
     function _bz_(annot_sexp){
      var match = get_error(file, sexp_kind, a_of_sexp, annot_sexp);
      if(0 === match[0]) return 0;
      var error = match[1];
      return [0, error];
     }
     var _bA_ = caml_call2(Core_List[13], annot_sexps, _bz_);
     return caml_call1(Core_Error[26], _bA_);
    }
    return gen_load_exn
            (exclusive,
             sexp_kind,
             file,
             function(sexps){
              return caml_call2(Core_List[51], sexps, a_of_sexp);
             },
             _by_);
   }
   function load_sexps_exn(exclusive, file, a_of_sexp){
    return gen_load_sexps_exn(exclusive, 0, file, a_of_sexp, 0);
   }
   function load_annotated_sexps_exn(exclusive, file, a_of_sexp){return gen_load_sexps_exn(exclusive, 1, file, a_of_sexp, 0);
   }
   function gen_load_sexps(exclusive, sexp_kind, file, a_of_sexp, param){
    function _bw_(_bx_){
     return gen_load_sexps_exn(exclusive, sexp_kind, file, a_of_sexp, _bx_);
    }
    return caml_call6
            (Async_kernel_Deferred_or_error[38], _bg_, _bf_, _be_, 0, 0, _bw_);
   }
   function load_sexps(exclusive, file, a_of_sexp){
    return gen_load_sexps(exclusive, 0, file, a_of_sexp, 0);
   }
   function load_annotated_sexps(exclusive, file, a_of_sexp){return gen_load_sexps(exclusive, 1, file, a_of_sexp, 0);
   }
   function pipe(t){
    var
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     pipe_w = match[2],
     pipe_r = match[1];
    function _bs_(param){
     function _bu_(param){return caml_call1(Async_kernel_Pipe[15], pipe_w);}
     var _bv_ = caml_call1(close$0, t);
     return caml_call2(Async_unix_Import[27], _bv_, _bu_);
    }
    var _bt_ = caml_call1(transfer$0(t), pipe_w);
    caml_call2(Async_unix_Import[22], _bt_, _bs_);
    return pipe_r;
   }
   function drain(t){
    function _bp_(param){
     if(typeof param === "number") return caml_call1(close$0, t);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bh_], 1);
    }
    var
     _bq_ =
       read_one_chunk_at_a_time$0
        (t,
         function(bigstring, param, _br_){
          return caml_call1(Async_unix_Import[30], 192584839);
         });
    return caml_call2(Async_unix_Import[33][2], _bq_, _bp_);
   }
   function load_bin_prot(exclusive, max_len, file, bin_reader){
    function _bm_(result){
     if(0 !== result[0]) return result;
     var match = result[1];
     if(typeof match === "number")
      return caml_call1(Core_Or_error[46], cst_Reader_load_bin_prot_got_u);
     var v = match[2];
     return [0, v];
    }
    function _bn_(param){
     return caml_call4
             (with_file$0,
              0,
              exclusive,
              file,
              function(t){return read_bin_prot(max_len, t, bin_reader);});
    }
    var
     _bo_ = caml_call6(Async_kernel_Monitor[17], 0, 0, _bj_, 0, _bi_, _bn_);
    return caml_call2(Async_unix_Import[33][3], _bo_, _bm_);
   }
   function load_bin_prot_exn(exclusive, max_len, file, bin_reader){
    var
     _bk_ = Core[255],
     _bl_ = load_bin_prot(exclusive, max_len, file, bin_reader);
    return caml_call2(Async_unix_Import[32], _bl_, _bk_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Reader0);
   var
    Async_unix_Reader0 =
      [0,
       Id,
       Read_result,
       Internal,
       sexp_of_t$4,
       sexp_of_handle_chunk_result$0,
       sexp_of_handle_iobuf_result$0,
       sexp_of_read_one_chunk_at_a_ti$0,
       close$0,
       close_finished$0,
       create$0,
       fd$0,
       id$0,
       invariant$0,
       bytes_read$0,
       is_closed$0,
       last_read_time$0,
       of_in_channel$0,
       open_file$0,
       stdin$0,
       with_close$0,
       with_file$0,
       use,
       finished_read,
       do_read_now,
       bytes_available,
       peek_available$0,
       read_available$0,
       do_read,
       peek$0,
       read$0,
       read_char$0,
       read_substring$0,
       read_bigsubstring$0,
       read_one_chunk_at_a_time$0,
       read_one_iobuf_at_a_time$0,
       really_read$0,
       really_read_substring$0,
       really_read_bigsubstring$0,
       read_line$0,
       really_read_line$0,
       do_read_k,
       read_until$0,
       read_until_bounded,
       read_sexp,
       read_sexps$0,
       read_annotated_sexps$0,
       peek_or_read_bin_prot$0,
       peek_bin_prot,
       read_bin_prot,
       iter_bin_prot$0,
       iter_bin_prot_exn,
       read_bin_prot_into_pipe,
       read_marshal_raw$0,
       read_marshal$0,
       recv$0,
       read_all$0,
       lines$0,
       contents$0,
       file_contents,
       file_lines,
       transfer$0,
       lseek,
       ltell,
       get_error,
       gen_load_exn,
       get_load_result_exn,
       gen_load_sexp_exn,
       load_sexp_exn,
       load_annotated_sexp_exn,
       gen_load_sexp,
       load_sexp,
       load_annotated_sexp,
       gen_load_sexps_exn,
       load_sexps_exn,
       load_annotated_sexps_exn,
       gen_load_sexps,
       load_sexps,
       load_annotated_sexps,
       pipe,
       drain,
       load_bin_prot,
       load_bin_prot_exn];
   runtime.caml_register_global
    (239, Async_unix_Reader0, cst_Async_unix_Reader0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Reader
//# unitInfo: Requires: Async_kernel__Debug, Async_kernel__Pipe, Async_unix__Import, Async_unix__Reader0, Async_unix__Unix_syscalls, Async_unix__Writer0, Core, Core__Info, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Reader$0 = "Async_unix__Reader",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Info = global_data.Core__Info,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Async_unix_Writer0 = global_data.Async_unix__Writer0;
   global_data.Core;
   global_data.Async_kernel__Debug;
   var
    Async_unix_Import = global_data.Async_unix__Import,
    Async_unix_Unix_syscalls = global_data.Async_unix__Unix_syscalls,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_unix_Reader0 = global_data.Async_unix__Reader0;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Reader$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/reader.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "reader.ml");
   var
    Id = Async_unix_Reader0[1],
    Read_result = Async_unix_Reader0[2],
    sexp_of_t = Async_unix_Reader0[4],
    sexp_of_handle_chunk_result = Async_unix_Reader0[5],
    sexp_of_handle_iobuf_result = Async_unix_Reader0[6],
    sexp_of_read_one_chunk_at_a_ti = Async_unix_Reader0[7],
    close = Async_unix_Reader0[8],
    close_finished = Async_unix_Reader0[9],
    create = Async_unix_Reader0[10],
    fd = Async_unix_Reader0[11],
    id = Async_unix_Reader0[12],
    invariant = Async_unix_Reader0[13],
    bytes_read = Async_unix_Reader0[14],
    is_closed = Async_unix_Reader0[15],
    last_read_time = Async_unix_Reader0[16],
    of_in_channel = Async_unix_Reader0[17],
    open_file = Async_unix_Reader0[18],
    stdin = Async_unix_Reader0[19],
    with_close = Async_unix_Reader0[20],
    with_file = Async_unix_Reader0[21],
    bytes_available = Async_unix_Reader0[25],
    peek_available = Async_unix_Reader0[26],
    read_available = Async_unix_Reader0[27],
    peek = Async_unix_Reader0[29],
    read = Async_unix_Reader0[30],
    read_char = Async_unix_Reader0[31],
    read_substring = Async_unix_Reader0[32],
    read_bigsubstring = Async_unix_Reader0[33],
    read_one_chunk_at_a_time = Async_unix_Reader0[34],
    read_one_iobuf_at_a_time = Async_unix_Reader0[35],
    really_read = Async_unix_Reader0[36],
    really_read_substring = Async_unix_Reader0[37],
    really_read_bigsubstring = Async_unix_Reader0[38],
    read_line = Async_unix_Reader0[39],
    really_read_line = Async_unix_Reader0[40],
    read_until = Async_unix_Reader0[42],
    read_until_bounded = Async_unix_Reader0[43],
    read_sexp = Async_unix_Reader0[44],
    read_sexps = Async_unix_Reader0[45],
    read_annotated_sexps = Async_unix_Reader0[46],
    peek_bin_prot = Async_unix_Reader0[48],
    read_bin_prot = Async_unix_Reader0[49],
    iter_bin_prot = Async_unix_Reader0[50],
    iter_bin_prot_exn = Async_unix_Reader0[51],
    read_bin_prot_into_pipe = Async_unix_Reader0[52],
    read_marshal_raw = Async_unix_Reader0[53],
    read_marshal = Async_unix_Reader0[54],
    recv = Async_unix_Reader0[55],
    read_all = Async_unix_Reader0[56],
    lines = Async_unix_Reader0[57],
    contents = Async_unix_Reader0[58],
    file_contents = Async_unix_Reader0[59],
    file_lines = Async_unix_Reader0[60],
    transfer = Async_unix_Reader0[61],
    lseek = Async_unix_Reader0[62],
    ltell = Async_unix_Reader0[63],
    load_sexp_exn = Async_unix_Reader0[68],
    load_annotated_sexp_exn = Async_unix_Reader0[69],
    load_sexp = Async_unix_Reader0[71],
    load_annotated_sexp = Async_unix_Reader0[72],
    load_sexps_exn = Async_unix_Reader0[74],
    load_annotated_sexps_exn = Async_unix_Reader0[75],
    load_sexps = Async_unix_Reader0[77],
    load_annotated_sexps = Async_unix_Reader0[78],
    pipe = Async_unix_Reader0[79],
    drain = Async_unix_Reader0[80],
    load_bin_prot = Async_unix_Reader0[81],
    load_bin_prot_exn = Async_unix_Reader0[82],
    cst_reader_of_string_contents_ = "reader of string contents for tests",
    _a_ = [0, 0],
    _b_ = [0, 751362817],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Reader = cst_Async_unix_Reader$0;
   function of_pipe(info, pipe_r){
    function _c_(param){
     var
      writer_fd = param[2][2],
      reader_fd = param[1][2],
      reader = caml_call2(create, 0, reader_fd),
      writer =
        caml_call7(Async_unix_Writer0[18], 0, 0, _b_, _a_, 0, 0, writer_fd);
     function _e_(param){
      return caml_call2(Async_unix_Writer0[65], 0, writer);
     }
     function _f_(s){
      return caml_call4(Async_unix_Writer0[33], 0, 0, writer, s);
     }
     var
      _g_ = [0, caml_call1(close_finished, reader)],
      _h_ = caml_call5(Async_unix_Writer0[86], _g_, 0, writer, pipe_r, _f_),
      _i_ = caml_call2(Async_unix_Import[33][2], _h_, _e_);
     caml_call1(Async_unix_Import[16], _i_);
     return reader;
    }
    var _d_ = caml_call1(Async_unix_Unix_syscalls[58], info);
    return caml_call2(Async_unix_Import[33][3], _d_, _c_);
   }
   function of_string(opt, str){
    if(opt)
     var sth = opt[1], info = sth;
    else
     var info = caml_call1(Core_Info[14], cst_reader_of_string_contents_);
    return of_pipe(info, caml_call1(Async_kernel_Pipe[11], str));
   }
   var For_testing = [0, of_string];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Reader);
   var
    Async_unix_Reader =
      [0,
       [0,
        Read_result[2],
        Read_result[3],
        Read_result[4],
        Read_result[7],
        Read_result[6],
        Read_result[5],
        Read_result[8],
        Read_result[9],
        Read_result[12],
        Read_result[11],
        Read_result[10],
        Read_result[13],
        Read_result[14],
        Read_result[15],
        Read_result[16],
        Read_result[17],
        Read_result[18],
        Read_result[19],
        Read_result[20],
        Read_result[21],
        Read_result[22],
        Read_result[23]],
       Id,
       sexp_of_t,
       invariant,
       bytes_read,
       last_read_time,
       stdin,
       open_file,
       transfer,
       pipe,
       of_pipe,
       create,
       of_in_channel,
       with_file,
       close,
       close_finished,
       is_closed,
       with_close,
       id,
       fd,
       read,
       peek,
       bytes_available,
       read_available,
       peek_available,
       drain,
       sexp_of_read_one_chunk_at_a_ti,
       sexp_of_handle_chunk_result,
       read_one_chunk_at_a_time,
       sexp_of_handle_iobuf_result,
       read_one_iobuf_at_a_time,
       read_substring,
       read_bigsubstring,
       read_char,
       really_read,
       really_read_substring,
       really_read_bigsubstring,
       read_until,
       read_until_bounded,
       read_line,
       really_read_line,
       read_sexp,
       read_sexps,
       read_annotated_sexps,
       read_bin_prot,
       peek_bin_prot,
       iter_bin_prot,
       iter_bin_prot_exn,
       read_bin_prot_into_pipe,
       read_marshal_raw,
       read_marshal,
       recv,
       read_all,
       lseek,
       ltell,
       lines,
       contents,
       file_contents,
       file_lines,
       load_sexp,
       load_sexp_exn,
       load_sexps,
       load_sexps_exn,
       load_annotated_sexp,
       load_annotated_sexp_exn,
       load_annotated_sexps,
       load_annotated_sexps_exn,
       load_bin_prot,
       load_bin_prot_exn,
       For_testing];
   runtime.caml_register_global
    (23, Async_unix_Reader, cst_Async_unix_Reader$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Writer
//# unitInfo: Requires: Async_kernel__Debug, Async_kernel__Deferred, Async_kernel__Monitor, Async_kernel__Pipe, Async_unix__Import, Async_unix__Reader, Async_unix__Unix_syscalls, Async_unix__Writer0, Core, Core__Info, Core__Sexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Writer$0 = "Async_unix__Writer",
    cst_Writer_of_pipe$1 = "Writer.of_pipe",
    cst_async_unix$0 = "async_unix",
    cst_src_writer_ml = "src/writer.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_unix_Import = global_data.Async_unix__Import,
    Assert_failure = global_data.Assert_failure,
    Async_unix_Reader = global_data.Async_unix__Reader,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Core_Info = global_data.Core__Info,
    Core_Sexp = global_data.Core__Sexp,
    Async_unix_Unix_syscalls = global_data.Async_unix__Unix_syscalls,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core = global_data.Core,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_unix_Writer0 = global_data.Async_unix__Writer0;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Writer$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_writer_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "writer.ml");
   var
    Id = Async_unix_Writer0[1],
    Line_ending = Async_unix_Writer0[2],
    sexp_of_t = Async_unix_Writer0[3],
    invariant = Async_unix_Writer0[4],
    stdout = Async_unix_Writer0[5],
    stderr = Async_unix_Writer0[6],
    bin_shape_buffer_age_limit = Async_unix_Writer0[7],
    bin_size_buffer_age_limit = Async_unix_Writer0[8],
    bin_write_buffer_age_limit = Async_unix_Writer0[9],
    bin_writer_buffer_age_limit = Async_unix_Writer0[10],
    bin_read_buffer_age_limit = Async_unix_Writer0[11],
    bin_read_buffer_age_limit$0 = Async_unix_Writer0[12],
    bin_reader_buffer_age_limit = Async_unix_Writer0[13],
    bin_buffer_age_limit = Async_unix_Writer0[14],
    sexp_of_buffer_age_limit = Async_unix_Writer0[15],
    buffer_age_limit_of_sexp = Async_unix_Writer0[16],
    buffer_age_limit_of_sexp$0 = Async_unix_Writer0[17],
    create = Async_unix_Writer0[18],
    raise_when_consumer_leaves = Async_unix_Writer0[19],
    set_raise_when_consumer_leaves = Async_unix_Writer0[20],
    set_buffer_age_limit = Async_unix_Writer0[21],
    consumer_left = Async_unix_Writer0[22],
    of_out_channel = Async_unix_Writer0[23],
    open_file = Async_unix_Writer0[24],
    with_file = Async_unix_Writer0[25],
    id = Async_unix_Writer0[26],
    fd = Async_unix_Writer0[27],
    set_fd = Async_unix_Writer0[28],
    write_gen = Async_unix_Writer0[29],
    write_gen_whole = Async_unix_Writer0[30],
    write_direct = Async_unix_Writer0[31],
    write_bytes = Async_unix_Writer0[32],
    write = Async_unix_Writer0[33],
    write_bigstring = Async_unix_Writer0[34],
    write_iobuf = Async_unix_Writer0[35],
    write_substring = Async_unix_Writer0[36],
    write_bigsubstring = Async_unix_Writer0[37],
    writef = Async_unix_Writer0[38],
    to_formatter = Async_unix_Writer0[39],
    write_char = Async_unix_Writer0[40],
    newline = Async_unix_Writer0[41],
    write_line = Async_unix_Writer0[42],
    write_byte = Async_unix_Writer0[43],
    Terminate_with = Async_unix_Writer0[44],
    write_sexp = Async_unix_Writer0[45],
    write_bin_prot = Async_unix_Writer0[46],
    write_bin_prot_no_size_header = Async_unix_Writer0[47],
    schedule_bigstring = Async_unix_Writer0[48],
    schedule_bigsubstring = Async_unix_Writer0[49],
    schedule_iobuf_peek = Async_unix_Writer0[50],
    schedule_iobuf_consume = Async_unix_Writer0[51],
    Destroy_or_keep = Async_unix_Writer0[52],
    schedule_iovec = Async_unix_Writer0[53],
    schedule_iovecs = Async_unix_Writer0[54],
    Flush_result = Async_unix_Writer0[55],
    flushed_or_failed_with_result = Async_unix_Writer0[56],
    flushed_or_failed_unit = Async_unix_Writer0[57],
    flushed = Async_unix_Writer0[58],
    flushed_time = Async_unix_Writer0[59],
    flushed_time_ns = Async_unix_Writer0[60],
    fsync = Async_unix_Writer0[61],
    fdatasync = Async_unix_Writer0[62],
    send = Async_unix_Writer0[63],
    monitor = Async_unix_Writer0[64],
    close = Async_unix_Writer0[65],
    close_started = Async_unix_Writer0[66],
    close_finished = Async_unix_Writer0[67],
    is_closed = Async_unix_Writer0[68],
    is_open = Async_unix_Writer0[69],
    with_close = Async_unix_Writer0[70],
    can_write = Async_unix_Writer0[71],
    is_stopped_permanently = Async_unix_Writer0[72],
    stopped_permanently = Async_unix_Writer0[73],
    with_flushed_at_close = Async_unix_Writer0[74],
    bytes_to_write = Async_unix_Writer0[75],
    bytes_written = Async_unix_Writer0[76],
    bytes_received = Async_unix_Writer0[77],
    with_file_atomic = Async_unix_Writer0[78],
    save = Async_unix_Writer0[79],
    save_lines = Async_unix_Writer0[80],
    save_sexp = Async_unix_Writer0[81],
    save_sexps = Async_unix_Writer0[82],
    save_sexps_conv = Async_unix_Writer0[83],
    save_bin_prot = Async_unix_Writer0[84],
    transfer = Async_unix_Writer0[85],
    transfer$0 = Async_unix_Writer0[86],
    pipe = Async_unix_Writer0[87],
    behave_nicely_in_pipeline = Async_unix_Writer0[88],
    set_synchronous_out_channel = Async_unix_Writer0[89],
    using_synchronous_backing_out_ = Async_unix_Writer0[90],
    clear_synchronous_out_channel = Async_unix_Writer0[91],
    with_synchronous_out_channel = Async_unix_Writer0[92],
    use_synchronous_stdout_and_std = Async_unix_Writer0[93],
    Backing_out_channel = Async_unix_Writer0[94],
    set_synchronous_backing_out_ch = Async_unix_Writer0[95],
    with_synchronous_backing_out_c = Async_unix_Writer0[96],
    Private = Async_unix_Writer0[97],
    _b_ = [0, 926227490, 1050608848],
    _c_ = [0, 926227490, 106380200],
    _a_ = [0, cst_src_writer_ml, 41, 46],
    cst_Writer_of_pipe$0 = cst_Writer_of_pipe$1,
    cst_Writer_of_pipe = cst_Writer_of_pipe$1,
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Writer = cst_Async_unix_Writer$0;
   function of_pipe(time_source, info, pipe_w){
    function _j_(param){
     var
      writer_fd = param[2][2],
      reader_fd = param[1][2],
      reader = caml_call2(Async_unix_Reader[12], 0, reader_fd),
      writer = caml_call7(create, 0, 0, 0, 0, 0, time_source, writer_fd);
     if(Async_kernel_Debug[14]){
      var
       _l_ =
         function(param){
          var
           arg2_004 = param[3],
           arg1_003 = param[2],
           arg0_002 = param[1],
           res0_005 = caml_call2(Async_kernel_Pipe[3][1], Core[558], arg0_002),
           res1_006 = caml_call1(Async_unix_Reader[3], arg1_003),
           res2_007 = caml_call1(sexp_of_t, arg2_004);
          return [1, [0, res0_005, [0, res1_006, [0, res2_007, 0]]]];
         };
      caml_call3
       (Async_kernel_Debug[15],
        cst_Writer_of_pipe,
        [0, pipe_w, reader, writer],
        _l_);
     }
     function _m_(param){
      var
       _o_ = caml_call1(raise_when_consumer_leaves, writer),
       _p_ = _o_ ? 1 - caml_call1(is_closed, writer) : _o_;
      if(_p_){
       var
        _q_ = caml_call1(Core_Info[9], info),
        _r_ = caml_call1(Core_Sexp[86], _q_),
        _s_ =
          [0, Async_unix_Unix_syscalls[153], 31, cst_Writer_of_pipe$0, _r_],
        _t_ = caml_call1(monitor, writer);
       caml_call3(Async_kernel_Monitor[15], _t_, 0, _s_);
      }
      function _u_(param){
       var _y_ = 1 - caml_call1(Async_kernel_Pipe[17], pipe_w);
       return _y_ ? caml_call1(Async_kernel_Pipe[15], pipe_w) : _y_;
      }
      var
       _v_ = caml_call2(close, 0, writer),
       _w_ = caml_call1(Async_unix_Reader[15], reader),
       _x_ = caml_call2(Async_kernel_Deferred[20], _w_, _v_);
      return caml_call2(Async_unix_Import[33][3], _x_, _u_);
     }
     var
      _n_ = caml_call2(Async_unix_Reader[9], reader, pipe_w),
      closed_and_flushed_downstream =
        caml_call2(Async_unix_Import[33][2], _n_, _m_);
     return [0, writer, [0, -367689927, closed_and_flushed_downstream]];
    }
    var _k_ = caml_call1(Async_unix_Unix_syscalls[58], info);
    return caml_call2(Async_unix_Import[33][3], _k_, _j_);
   }
   function splice_result(t, from){
    function _e_(param){
     if(typeof param === "number") return 17724;
     if(280164845 > param[1])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var result = param[2];
     return result;
    }
    function _f_(buffer, pos, len){
     caml_call4(schedule_bigstring, t, [0, pos], [0, len], buffer);
     function _h_(param){
      return typeof param === "number" ? param ? _b_ : _c_ : 192584839;
     }
     var _i_ = caml_call1(flushed_or_failed_with_result, t);
     return caml_call2(Async_unix_Import[33][3], _i_, _h_);
    }
    var _g_ = caml_call2(Async_unix_Reader[29], from, _f_);
    return caml_call2(Async_unix_Import[33][3], _g_, _e_);
   }
   function splice(t, from){
    var _d_ = splice_result(t, from);
    return caml_call1(Async_kernel_Deferred[15], _d_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Writer);
   var
    Async_unix_Writer =
      [0,
       Id,
       Line_ending,
       sexp_of_t,
       invariant,
       stdout,
       stderr,
       bin_shape_buffer_age_limit,
       bin_size_buffer_age_limit,
       bin_write_buffer_age_limit,
       bin_writer_buffer_age_limit,
       bin_read_buffer_age_limit,
       bin_read_buffer_age_limit$0,
       bin_reader_buffer_age_limit,
       bin_buffer_age_limit,
       sexp_of_buffer_age_limit,
       buffer_age_limit_of_sexp,
       buffer_age_limit_of_sexp$0,
       create,
       raise_when_consumer_leaves,
       set_raise_when_consumer_leaves,
       set_buffer_age_limit,
       consumer_left,
       of_out_channel,
       open_file,
       with_file,
       id,
       fd,
       set_fd,
       write_gen,
       write_gen_whole,
       write_direct,
       write_bytes,
       write,
       write_bigstring,
       write_iobuf,
       write_substring,
       write_bigsubstring,
       writef,
       to_formatter,
       write_char,
       newline,
       write_line,
       write_byte,
       Terminate_with,
       write_sexp,
       write_bin_prot,
       write_bin_prot_no_size_header,
       schedule_bigstring,
       schedule_bigsubstring,
       schedule_iobuf_peek,
       schedule_iobuf_consume,
       Destroy_or_keep,
       schedule_iovec,
       schedule_iovecs,
       Flush_result,
       flushed_or_failed_with_result,
       flushed_or_failed_unit,
       flushed,
       flushed_time,
       flushed_time_ns,
       fsync,
       fdatasync,
       send,
       monitor,
       close,
       close_started,
       close_finished,
       is_closed,
       is_open,
       with_close,
       can_write,
       is_stopped_permanently,
       stopped_permanently,
       with_flushed_at_close,
       bytes_to_write,
       bytes_written,
       bytes_received,
       with_file_atomic,
       save,
       save_lines,
       save_sexp,
       save_sexps,
       save_sexps_conv,
       save_bin_prot,
       transfer,
       transfer$0,
       pipe,
       behave_nicely_in_pipeline,
       set_synchronous_out_channel,
       using_synchronous_backing_out_,
       clear_synchronous_out_channel,
       with_synchronous_out_channel,
       use_synchronous_stdout_and_std,
       Backing_out_channel,
       set_synchronous_backing_out_ch,
       with_synchronous_backing_out_c,
       Private,
       of_pipe,
       splice_result,
       splice];
   runtime.caml_register_global
    (28, Async_unix_Writer, cst_Async_unix_Writer$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Unused
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Unused = "Async_unix__Unused",
    cst_async_unix = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Unused);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][1], "src/unused.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix, "unused.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Unused);
   var Async_unix_Unused = [0];
   runtime.caml_register_global(11, Async_unix_Unused, cst_Async_unix_Unused);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Time_source_tests
//# unitInfo: Requires: Async_kernel__Ivar, Async_kernel__Scheduler, Async_kernel__Time_source, Async_unix__Import, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Time_source_tes$0 = "Async_unix__Time_source_tests",
    cst_async_unix$0 = "async_unix",
    cst_src_time_source_tests_ml$5 = "src/time_source_tests.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_unix_Import = global_data.Async_unix__Import,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Time_source_tes$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_time_source_tests_ml$5);
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_unix$0, "time_source_tests.ml");
   var
    run_cycles_until_no_jobs_remai = Async_kernel_Scheduler[15],
    _c_ = [0, 1],
    _b_ = [0, 0],
    cst_src_time_source_tests_ml = cst_src_time_source_tests_ml$5,
    cst_src_time_source_tests_ml$0 = cst_src_time_source_tests_ml$5,
    cst_let_iv_Ivar_create_in_let_ =
      "let iv = Ivar.create () in\nlet n = ref 0 in\nTime_source.run_repeatedly time_source ~stop:(Ivar.read iv)\n  ~continue_on_error:false\n  ~f:(fun () ->\n        if (!n) >= 1_000 then Ivar.fill_exn iv () else incr n; return ())\n  ~continue:Time_source.Continue.immediately;\nrun_cycles_until_no_jobs_remain ()",
    cst_continue_on_error_false = "~continue-on-error:false",
    cst_src_time_source_tests_ml$1 = cst_src_time_source_tests_ml$5,
    cst_src_time_source_tests_ml$2 = cst_src_time_source_tests_ml$5,
    cst_let_iv_Ivar_create_in_let_$0 =
      "let iv = Ivar.create () in\nlet n = ref 0 in\nTime_source.run_repeatedly time_source ~stop:(Ivar.read iv)\n  ~continue_on_error:true\n  ~f:(fun () ->\n        if (!n) >= 1_000 then Ivar.fill_exn iv () else incr n; return ())\n  ~continue:Time_source.Continue.immediately;\nrun_cycles_until_no_jobs_remain ()",
    cst_continue_on_error_true = "~continue_on_error:true",
    cst_src_time_source_tests_ml$3 = cst_src_time_source_tests_ml$5,
    cst_src_time_source_tests_ml$4 = cst_src_time_source_tests_ml$5,
    cst_Clock_every = "Clock.every",
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Time_source_tes = cst_Async_unix_Time_source_tes$0;
   if(Ppx_bench_lib_Benchmark_accumu[3]){
    var
     _a_ =
       function(param){
        var
         scheduler = caml_call1(Async_kernel_Scheduler[2], 0),
         time_source = caml_call1(Async_kernel_Time_source[40], scheduler[19]);
        if(Ppx_bench_lib_Benchmark_accumu[3]){
         var
          f =
            function(param, _h_){
             var
              iv = caml_call1(Async_kernel_Ivar[12], 0),
              n = [0, 0],
              _i_ = Async_kernel_Time_source[24][1];
             function _j_(param){
              if(caml_call2(Async_unix_Import[1], n[1], 1000))
               caml_call2(Async_kernel_Ivar[14], iv, 0);
              else
               n[1]++;
              return caml_call1(Async_unix_Import[30], 0);
             }
             var _k_ = [0, caml_call1(Async_kernel_Ivar[19], iv)];
             caml_call7
              (Async_kernel_Time_source[25],
               0,
               _k_,
               _b_,
               0,
               time_source,
               _j_,
               _i_);
             return caml_call1(run_cycles_until_no_jobs_remai, 0);
            };
         caml_call8
          (Ppx_bench_lib_Benchmark_accumu[5],
           cst_continue_on_error_false,
           cst_let_iv_Ivar_create_in_let_,
           cst_src_time_source_tests_ml$0,
           cst_src_time_source_tests_ml,
           12,
           4,
           412,
           [0, f]);
        }
        if(Ppx_bench_lib_Benchmark_accumu[3]){
         var
          f$0 =
            function(param, _d_){
             var
              iv = caml_call1(Async_kernel_Ivar[12], 0),
              n = [0, 0],
              _e_ = Async_kernel_Time_source[24][1];
             function _f_(param){
              if(caml_call2(Async_unix_Import[1], n[1], 1000))
               caml_call2(Async_kernel_Ivar[14], iv, 0);
              else
               n[1]++;
              return caml_call1(Async_unix_Import[30], 0);
             }
             var _g_ = [0, caml_call1(Async_kernel_Ivar[19], iv)];
             caml_call7
              (Async_kernel_Time_source[25],
               0,
               _g_,
               _c_,
               0,
               time_source,
               _f_,
               _e_);
             return caml_call1(run_cycles_until_no_jobs_remai, 0);
            };
         caml_call8
          (Ppx_bench_lib_Benchmark_accumu[5],
           cst_continue_on_error_true,
           cst_let_iv_Ivar_create_in_let_$0,
           cst_src_time_source_tests_ml$2,
           cst_src_time_source_tests_ml$1,
           26,
           4,
           410,
           [0, f$0]);
        }
        return 0;
       };
    caml_call8
     (Ppx_bench_lib_Benchmark_accumu[6],
      cst_Clock_every,
      cst,
      cst_src_time_source_tests_ml$4,
      cst_src_time_source_tests_ml$3,
      7,
      0,
      1011,
      _a_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Time_source_tes);
   var Async_unix_Time_source_tests = [0];
   runtime.caml_register_global
    (29, Async_unix_Time_source_tests, cst_Async_unix_Time_source_tes$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Tcp
//# unitInfo: Requires: Async_kernel__Async_invariant, Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Time_source, Async_unix__Clock, Async_unix__Fd, Async_unix__Import, Async_unix__Reader, Async_unix__Unix_syscalls, Async_unix__Writer, Base__Exn, Base__Field, Core, Core__Bag, Core__Fn, Core__Host_and_port, Core__Info, Core__List, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Time_ns_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Tcp$0 = "Async_unix__Tcp",
    cst = "_",
    cst_async_unix$0 = "async_unix",
    cst_client_address$0 = "client_address",
    cst_connections$0 = "connections",
    cst_listening_on = "listening_on",
    cst_max_accepts_per_batch$0 = "max_accepts_per_batch",
    cst_max_connections$0 = "max_connections",
    cst_src_tcp_ml = "src/tcp.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Async_unix_Unix_syscalls = global_data.Async_unix__Unix_syscalls,
    Async_unix_Fd = global_data.Async_unix__Fd,
    Async_unix_Import = global_data.Async_unix__Import,
    Core_List = global_data.Core__List,
    Core_Bag = global_data.Core__Bag,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_unix_Writer = global_data.Async_unix__Writer,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Core = global_data.Core,
    Base_Exn = global_data.Base__Exn,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Fn = global_data.Core__Fn,
    Assert_failure = global_data.Assert_failure,
    Base_Field = global_data.Base__Field,
    Time_ns_unix = global_data.Time_ns_unix,
    Core_Info = global_data.Core__Info,
    Async_kernel_Async_invariant = global_data.Async_kernel__Async_invariant,
    Async_unix_Reader = global_data.Async_unix__Reader,
    Async_unix_Clock = global_data.Async_unix__Clock,
    Core_Host_and_port = global_data.Core__Host_and_port,
    Core_Option = global_data.Core__Option,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Tcp$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_tcp_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "tcp.ml");
   var
    _ad_ = [0, 3804260],
    _ae_ = [0, 523273847],
    _af_ = [0, "Tcp.Server.create_sock_inet"],
    _aa_ = [0, 3804260],
    _ab_ = [0, 523273847],
    _ac_ = [0, "Tcp.Server.create_sock"],
    _$_ = [0, 1],
    _Z_ = [0, "retries_attempted_upon_addr_in_use"],
    ___ = [0, "exn"],
    cst_Failed_to_bind_and_listen_ = "Failed to bind and listen to socket.",
    cst_Tcp_Server_creater_got_neg =
      "Tcp.Server.creater got negative [max_connections]",
    _Y_ = [0, cst_src_tcp_ml, 522, 16945, 16961],
    _S_ = [0, cst],
    _R_ = [0, cst],
    _X_ = [0, cst_src_tcp_ml, 387, 13],
    _W_ = [0, cst_src_tcp_ml, 389, 47],
    _V_ = [0, cst_src_tcp_ml, 394, 13],
    _U_ = [0, cst_src_tcp_ml, 395, 13],
    cst_invariant_failed = "invariant failed",
    _T_ = [0, cst_src_tcp_ml, 401, 12337, 12359],
    _N_ = [0, "Passive"],
    _D_ = [0, "close_finished_and_handlers_determined"],
    _E_ = [0, "drop_incoming_connections"],
    _F_ = [0, "accept_is_pending"],
    _G_ = [0, cst_connections$0],
    _H_ = [0, cst_max_accepts_per_batch$0],
    _I_ = [0, cst_max_connections$0],
    _J_ = [0, "handle_client"],
    _K_ = [0, "Raise"],
    _P_ = [0, "Ignore"],
    _Q_ = [0, "Call"],
    _L_ = [0, "on_handler_error"],
    _M_ = [0, cst_listening_on],
    _O_ = [0, "socket"],
    _v_ = [0, cst_listening_on],
    _w_ = [0, "limit"],
    cst_At_limit_of_Tcp_server_max =
      "At limit of Tcp server [max_connections]. New connections will not be accepted until an existing connection is closed.",
    _t_ = [0, cst],
    _u_ = [0, cst_src_tcp_ml, 304, 8760, 8786],
    _r_ = [0, "Active"],
    _q_ = [0, cst_client_address$0],
    _s_ = [0, "client_socket"],
    _l_ = [0, cst_listening_on],
    _m_ = [0, "address"],
    _n_ = [0, "socket_type"],
    _j_ = [0, "On_port"],
    _k_ = [0, "On_port_chosen_by_os"],
    _g_ = [0, "Localhost"],
    _h_ = [0, "All_addresses"],
    _i_ = [0, "Address"],
    _d_ = [0, 3804260],
    _e_ = [0, 523273847],
    _f_ = [0, "Tcp.collect_errors"],
    cst_connection_attempt_timeout = "connection attempt timeout",
    cst_connection_attempt_aborted = "connection attempt aborted",
    _a_ = [0, 3804260],
    _b_ = [0, 523273847],
    _c_ = [0, "Tcp.close_sock_on_error"],
    cst_client_address = cst_client_address$0,
    cst_connections = cst_connections$0,
    cst_max_accepts_per_batch = cst_max_accepts_per_batch$0,
    cst_max_connections = cst_max_connections$0,
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Tcp = cst_Async_unix_Tcp$0;
   function sexp_of_t(param, _cF_){var info = _cF_[4]; return info;}
   function sexp_of_inet(x_001){return x_001[4];}
   function sexp_of_unix(x_002){return x_002[4];}
   function remote_address(t){return caml_call1(t[2], 0);}
   function create_local_address(bind_to_address, bind_to_port){
    if(bind_to_address){
     var
      inet_addr = bind_to_address[1],
      port = caml_call2(Core_Option[39], bind_to_port, 0);
     return [0,
             caml_call2
              (Async_unix_Unix_syscalls[95][1][2][15], inet_addr, port)];
    }
    if(! bind_to_port) return 0;
    var port$0 = bind_to_port[1];
    return [0, caml_call1(Async_unix_Unix_syscalls[95][1][2][16], port$0)];
   }
   function of_host_and_port(bind_to_address, bind_to_port, opt, hp){
    if(opt)
     var sth = opt[1], show_port_in_test = sth;
    else
     var show_port_in_test = 0;
    var
     port = hp[2],
     host = hp[1],
     _cA_ =
       show_port_in_test
        ? caml_call1(Core_Host_and_port[14], hp)
        : caml_call1(Core_Host_and_port[47][10], hp),
     _cB_ = create_local_address(bind_to_address, bind_to_port);
    function _cC_(param){
     function _cD_(inet_addr){
      return caml_call2
              (Async_unix_Unix_syscalls[95][1][2][15], inet_addr, port);
     }
     var _cE_ = caml_call1(Async_unix_Unix_syscalls[92][43], host);
     return caml_call2(Async_unix_Import[32], _cE_, _cD_);
    }
    return [0, Async_unix_Unix_syscalls[95][4][2], _cC_, _cB_, _cA_];
   }
   function of_file(file){
    var _cw_ = caml_call1(Core[558], file), _cx_ = 0;
    function _cy_(param){
     var _cz_ = caml_call1(Async_unix_Unix_syscalls[95][1][1][13], file);
     return caml_call1(Async_unix_Import[30], _cz_);
    }
    return [0, Async_unix_Unix_syscalls[95][4][4], _cy_, _cx_, _cw_];
   }
   function of_inet_address(bind_to_address, bind_to_port, opt, address){
    if(opt)
     var sth = opt[1], show_port_in_test = sth;
    else
     var show_port_in_test = 0;
    var
     _ct_ =
       show_port_in_test
        ? caml_call1(Async_unix_Unix_syscalls[95][1][2][14][1], address)
        : caml_call1(Async_unix_Unix_syscalls[95][1][2][12], address),
     _cu_ = create_local_address(bind_to_address, bind_to_port);
    function _cv_(param){return caml_call1(Async_unix_Import[30], address);}
    return [0, Async_unix_Unix_syscalls[95][4][2], _cv_, _cu_, _ct_];
   }
   function of_unix_address(address){
    var
     _cq_ = caml_call1(Async_unix_Unix_syscalls[95][1][1][9], address),
     _cr_ = 0;
    function _cs_(param){return caml_call1(Async_unix_Import[30], address);}
    return [0, Async_unix_Unix_syscalls[95][4][4], _cs_, _cr_, _cq_];
   }
   function reader_writer_of_sock
   (buffer_age_limit, reader_buffer_size, writer_buffer_size, s){
    var
     fd = caml_call1(Async_unix_Unix_syscalls[95][18], s),
     _cp_ =
       caml_call7
        (Async_unix_Writer[18],
         writer_buffer_size,
         0,
         buffer_age_limit,
         0,
         0,
         0,
         fd);
    return [0,
            caml_call2(Async_unix_Reader[12], reader_buffer_size, fd),
            _cp_];
   }
   function connect_sock
   (socket, interrupt, opt, time_source, where_to_connect){
    if(opt)
     var sth = opt[1], timeout = sth;
    else
     var timeout = caml_call1(Core[630], 10.);
    if(time_source)
     var
      x = time_source[1],
      time_source$0 = caml_call1(Async_kernel_Time_source[8], x);
    else
     var time_source$0 = caml_call1(Async_kernel_Time_source[10], 0);
    function _b7_(address){
     var
      _b9_ = caml_call1(Time_ns_unix[72][146], timeout),
      timeout$0 =
        caml_call2(Async_kernel_Time_source[33][19], time_source$0, _b9_);
     function _b__(param){
      return 0 === param[0]
              ? caml_call1(Async_kernel_Deferred[19], 0)
              : Async_kernel_Deferred[18];
     }
     var
      _b$_ = caml_call1(Async_kernel_Time_source[33][14], timeout$0),
      timeout$1 = caml_call2(Async_unix_Import[31], _b$_, _b__);
     if(interrupt)
      var
       interrupt$0 = interrupt[1],
       interrupt$1 =
         caml_call1
          (Async_kernel_Deferred[23], [0, interrupt$0, [0, timeout$1, 0]]);
     else
      var interrupt$1 = timeout$1;
     function connect_interruptible(s){
      return caml_call3
              (Async_unix_Unix_syscalls[95][7], s, address, interrupt$1);
     }
     function _ca_(result){
      if(socket)
       var s = socket[1], s$0 = s;
      else
       var
        s$0 = caml_call1(Async_unix_Unix_syscalls[95][5], where_to_connect[1]);
      function _ce_(param){
       if(typeof param !== "number"){
        var s = param[2];
        caml_call2(Async_kernel_Time_source[33][12], timeout$0, 0);
        return caml_call2(Async_kernel_Ivar[14], result, s);
       }
       var
        _cj_ = caml_call1(Async_unix_Unix_syscalls[95][18], s$0),
        _ck_ = caml_call2(Async_unix_Unix_syscalls[16], 0, _cj_);
       caml_call1(Async_unix_Import[16], _ck_);
       var
        address$0 = caml_call1(Async_unix_Unix_syscalls[95][1][13], address),
        match = caml_call2(Async_kernel_Time_source[33][10], timeout$0, 0);
       if(typeof match !== "number" && 1 === match[0]){
        var
         _cn_ = [0, caml_call1(Core[558], address$0), 0],
         _co_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_connection_attempt_timeout),
             _cn_]];
        return caml_call1(Core[261], _co_);
       }
       var
        _cl_ = [0, caml_call1(Core[558], address$0), 0],
        _cm_ =
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_connection_attempt_aborted),
            _cl_]];
       return caml_call1(Core[261], _cm_);
      }
      function f(param){
       var match = where_to_connect[3];
       if(! match) return connect_interruptible(s$0);
       var local_interface = match[1];
       function _ch_(s){return connect_interruptible(s);}
       var
        _ci_ =
          caml_call3(Async_unix_Unix_syscalls[95][9], 0, s$0, local_interface);
       return caml_call2(Async_unix_Import[31], _ci_, _ch_);
      }
      function _cb_(param){
       if(0 === param[0]){var v = param[1]; return v;}
       var
        e = param[1],
        _cf_ = caml_call1(Async_unix_Unix_syscalls[95][18], s$0),
        _cg_ = caml_call2(Async_unix_Unix_syscalls[16], 0, _cf_);
       caml_call1(Async_unix_Import[16], _cg_);
       throw caml_maybe_attach_backtrace(e, 0);
      }
      var
       _cc_ = caml_call7(Async_kernel_Monitor[16], 0, 0, _c_, 0, _b_, _a_, f),
       _cd_ = caml_call2(Async_unix_Import[32], _cc_, _cb_);
      return caml_call2(Async_unix_Import[27], _cd_, _ce_);
     }
     return caml_call1(Async_kernel_Deferred[3], _ca_);
    }
    var _b8_ = caml_call1(where_to_connect[2], 0);
    return caml_call2(Async_unix_Import[31], _b8_, _b7_);
   }
   function connect
   (socket,
    buffer_age_limit,
    interrupt,
    reader_buffer_size,
    writer_buffer_size,
    timeout,
    time_source,
    where_to_connect){
    function _b5_(s){
     var
      match =
        reader_writer_of_sock
         (buffer_age_limit, reader_buffer_size, writer_buffer_size, s),
      w = match[2],
      r = match[1];
     return [0, s, r, w];
    }
    var
     _b6_ =
       connect_sock(socket, interrupt, timeout, time_source, where_to_connect);
    return caml_call2(Async_unix_Import[32], _b6_, _b5_);
   }
   function collect_errors(writer, f){
    var monitor = caml_call1(Async_unix_Writer[64], writer);
    caml_call1(Async_kernel_Monitor[9], monitor);
    var _bX_ = 0;
    function _bY_(_b4_){return _b4_;}
    var
     _bZ_ = caml_call7(Async_kernel_Monitor[16], 0, 0, _f_, 0, _e_, _d_, f),
     _b0_ = [0, caml_call2(Async_unix_Import[14], _bZ_, _bY_), _bX_];
    function _b1_(e){return [1, e];}
    var
     _b2_ = caml_call1(Async_kernel_Monitor[10], monitor),
     _b3_ = [0, caml_call2(Async_unix_Import[14], _b2_, _b1_), _b0_];
    return caml_call1(Async_unix_Import[15], _b3_);
   }
   function close_connection_via_reader_an(r, w){
    var
     _bS_ = caml_call1(Core[630], 30.),
     force_close_event = caml_call1(Async_unix_Clock[7][16], _bS_);
    function _bT_(param){
     return 0 === param[0]
             ? caml_call1(Async_kernel_Deferred[19], 0)
             : Async_kernel_Deferred[18];
    }
    var
     _bU_ = caml_call1(Async_unix_Clock[7][12], force_close_event),
     force_close = caml_call2(Async_unix_Import[31], _bU_, _bT_);
    function _bV_(param){
     caml_call2(Async_unix_Clock[7][11], force_close_event, 0);
     return caml_call1(Async_unix_Reader[15], r);
    }
    var _bW_ = caml_call2(Async_unix_Writer[65], [0, force_close], w);
    return caml_call2(Async_unix_Import[31], _bW_, _bV_);
   }
   function with_connection
   (buffer_age_limit,
    interrupt,
    reader_buffer_size,
    writer_buffer_size,
    timeout,
    time_source,
    where_to_connect,
    f){
    function _bH_(socket){
     var
      match =
        reader_writer_of_sock
         (buffer_age_limit, reader_buffer_size, writer_buffer_size, socket),
      w = match[2],
      r = match[1],
      res =
        collect_errors
         (w, function(param){return caml_call3(f, socket, r, w);});
     function _bJ_(param){
      function _bP_(param){
       function _bR_(param){
        if(0 === param[0]){var v = param[1]; return v;}
        var e = param[1];
        throw caml_maybe_attach_backtrace(e, 0);
       }
       return caml_call2(Async_unix_Import[32], res, _bR_);
      }
      var _bQ_ = close_connection_via_reader_an(r, w);
      return caml_call2(Async_unix_Import[31], _bQ_, _bP_);
     }
     var
      _bK_ = [0, caml_call1(Async_unix_Writer[67], w), 0],
      _bL_ = [0, caml_call1(Async_unix_Reader[16], r), _bK_];
     function _bM_(param){return 0;}
     var
      _bN_ = [0, caml_call2(Async_unix_Import[32], res, _bM_), _bL_],
      _bO_ = caml_call1(Async_kernel_Deferred[23], _bN_);
     return caml_call2(Async_unix_Import[31], _bO_, _bJ_);
    }
    var
     _bI_ = connect_sock(0, interrupt, timeout, time_source, where_to_connect);
    return caml_call2(Async_unix_Import[31], _bI_, _bH_);
   }
   function sexp_of_t$0(param){
    if(typeof param === "number") return param ? _g_ : _h_;
    var
     arg0_003 = param[1],
     res0_004 = caml_call1(Async_unix_Unix_syscalls[92][11], arg0_003);
    return [1, [0, _i_, [0, res0_004, 0]]];
   }
   var Bind_to_address = [0, sexp_of_t$0];
   function sexp_of_t$1(param){
    if(! param) return _k_;
    var arg0_005 = param[1], res0_006 = caml_call1(Core[389], arg0_005);
    return [1, [0, _j_, [0, res0_006, 0]]];
   }
   var Bind_to_port = [0, sexp_of_t$1];
   function sexp_of_t$2(of_address_007, of_listening_on_008, param){
    var
     listening_on_014 = param[3],
     address_012 = param[2],
     socket_type_010 = param[1],
     arg_015 = caml_call1(Sexplib0_Sexp_conv[23], listening_on_014),
     bnds_009 = [0, [1, [0, _l_, [0, arg_015, 0]]], 0],
     arg_013 = caml_call1(of_address_007, address_012),
     bnds_009$0 = [0, [1, [0, _m_, [0, arg_013, 0]]], bnds_009],
     arg_011 =
       caml_call2
        (Async_unix_Unix_syscalls[95][4][1], of_address_007, socket_type_010),
     bnds_009$1 = [0, [1, [0, _n_, [0, arg_011, 0]]], bnds_009$0];
    return [1, bnds_009$1];
   }
   function address(r){return r[2];}
   function sexp_of_inet$0(x_016){
    return sexp_of_t$2
            (Async_unix_Unix_syscalls[95][1][2][12], Core[389], x_016);
   }
   function sexp_of_unix$0(x_017){
    return sexp_of_t$2
            (Async_unix_Unix_syscalls[95][1][1][9], Core[558], x_017);
   }
   function create(socket_type, address, listening_on){return [0, socket_type, address, listening_on];
   }
   function bind_to(bind_to_address, bind_to_port){
    if(bind_to_port)
     var port = bind_to_port[1], port$0 = port;
    else
     var port$0 = 0;
    if(typeof bind_to_address === "number")
     var
      address =
        bind_to_address
         ? caml_call2
           (Async_unix_Unix_syscalls[95][1][2][15],
            Async_unix_Unix_syscalls[92][37],
            port$0)
         : caml_call1(Async_unix_Unix_syscalls[95][1][2][16], port$0);
    else
     var
      addr = bind_to_address[1],
      address =
        caml_call2(Async_unix_Unix_syscalls[95][1][2][15], addr, port$0);
    function _bG_(param){var port = param[2][2]; return port;}
    return [0, Async_unix_Unix_syscalls[95][4][2], address, _bG_];
   }
   function of_port(port){return bind_to(0, [0, port]);}
   var of_port_chosen_by_os = bind_to(0, 0);
   function of_file$0(path){
    function _bE_(param){return path;}
    var _bF_ = caml_call1(Async_unix_Unix_syscalls[95][1][1][13], path);
    return [0, Async_unix_Unix_syscalls[95][4][4], _bF_, _bE_];
   }
   function client_address(r){return r[2];}
   function _o_(r, v){return [0, r[1], v];}
   var
    _p_ = 0,
    client_address$0 =
      [0,
       function(param){return 0;},
       cst_client_address,
       _p_,
       client_address,
       _o_];
   function sexp_of_t$3(of_address_018, param){
    var
     client_address_022 = param[2],
     client_socket_020 = param[1],
     arg_023 = caml_call1(of_address_018, client_address_022),
     bnds_019 = [0, [1, [0, _q_, [0, arg_023, 0]]], 0];
    function _bD_(param){return _r_;}
    var
     arg_021 =
       caml_call3
        (Async_unix_Unix_syscalls[95][3],
         _bD_,
         of_address_018,
         client_socket_020),
     bnds_019$0 = [0, [1, [0, _s_, [0, arg_021, 0]]], bnds_019];
    return [1, bnds_019$0];
   }
   function close(t){
    var _bC_ = caml_call1(Async_unix_Unix_syscalls[95][18], t[1]);
    return caml_call2(Async_unix_Fd[12], 0, _bC_);
   }
   function create$0(limit, time_source, listening_on){return [0, limit, time_source, listening_on, 0];
   }
   var
    log_threshold = caml_call1(Time_ns_unix[72][83], 1.),
    max_connection_limit_logger = [0, caml_call1(Core[257], 0)];
   function set_max_connection_limit_logge(_bB_){
    max_connection_limit_logger[1] = _bB_;
    return 0;
   }
   function log_at_limit(t, now){
    var
     _by_ = [0, [1, [0, _v_, [0, caml_call1(Core_Info[9], t[3]), 0]]], 0],
     _bz_ = [0, [1, [0, _w_, [0, caml_call1(Core[389], t[1]), 0]]], _by_],
     _bA_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_At_limit_of_Tcp_server_max),
         _bz_]];
    caml_call1(max_connection_limit_logger[1], _bA_);
    t[4] = [0, now];
    return 0;
   }
   function set_drop_incoming_connections(r, v){r[9] = v; return 0;}
   function connections(r){return r[7];}
   function max_accepts_per_batch(r){return r[6];}
   function max_connections(r){return r[5];}
   function listening_on(r){return r[2];}
   function socket(r){return r[1];}
   function _x_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8], r[9], r[10]];
   }
   var
    _y_ = 0,
    connections$0 =
      [0, function(param){return 0;}, cst_connections, _y_, connections, _x_];
   function _z_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8], r[9], r[10]];
   }
   var
    _A_ = 0,
    max_accepts_per_batch$0 =
      [0,
       function(param){return 0;},
       cst_max_accepts_per_batch,
       _A_,
       max_accepts_per_batch,
       _z_];
   function _B_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8], r[9], r[10]];
   }
   var
    _C_ = 0,
    max_connections$0 =
      [0,
       function(param){return 0;},
       cst_max_connections,
       _C_,
       max_connections,
       _B_];
   function sexp_of_t$4(of_address_025, of_listening_on_026, param){
    var
     connections_041 = param[7],
     max_accepts_per_batch_039 = param[6],
     max_connections_037 = param[5],
     on_handler_error_032 = param[3],
     listening_on_030 = param[2],
     socket_028 = param[1],
     accept_is_pending_043 = param[8],
     drop_incoming_connections_045 = param[9],
     close_finished_and_handlers_de = param[10],
     arg_048 =
       caml_call2
        (Async_kernel_Ivar[9], Core[620], close_finished_and_handlers_de),
     bnds_027 = [0, [1, [0, _D_, [0, arg_048, 0]]], 0],
     arg_046 = caml_call1(Core[323], drop_incoming_connections_045),
     bnds_027$0 = [0, [1, [0, _E_, [0, arg_046, 0]]], bnds_027],
     arg_044 = caml_call1(Core[323], accept_is_pending_043),
     bnds_027$1 = [0, [1, [0, _F_, [0, arg_044, 0]]], bnds_027$0];
    function _bq_(_bx_){return sexp_of_t$3(of_address_025, _bx_);}
    var
     arg_042 = caml_call2(Core_Bag[3], _bq_, connections_041),
     bnds_027$2 = [0, [1, [0, _G_, [0, arg_042, 0]]], bnds_027$1],
     arg_040 = caml_call1(Core[389], max_accepts_per_batch_039),
     bnds_027$3 = [0, [1, [0, _H_, [0, arg_040, 0]]], bnds_027$2],
     arg_038 = caml_call1(Core[389], max_connections_037[1]),
     bnds_027$4 = [0, [1, [0, _I_, [0, arg_038, 0]]], bnds_027$3];
    function _br_(_bw_){return 0;}
    var
     arg_036 = caml_call1(Sexplib0_Sexp_conv[24], _br_),
     bnds_027$5 = [0, [1, [0, _J_, [0, arg_036, 0]]], bnds_027$4];
    if(typeof on_handler_error_032 === "number")
     var arg_033 = -146189108 <= on_handler_error_032 ? _K_ : _P_;
    else
     var
      _bt_ = 0,
      _bu_ = function(_bv_){return 0;},
      arg_033 =
        [1, [0, _Q_, [0, caml_call1(Sexplib0_Sexp_conv[24], _bu_), _bt_]]];
    var
     bnds_027$6 = [0, [1, [0, _L_, [0, arg_033, 0]]], bnds_027$5],
     arg_031 = caml_call1(of_listening_on_026, listening_on_030),
     bnds_027$7 = [0, [1, [0, _M_, [0, arg_031, 0]]], bnds_027$6];
    function _bs_(param){return _N_;}
    var
     arg_029 =
       caml_call3
        (Async_unix_Unix_syscalls[95][3], _bs_, of_address_025, socket_028),
     bnds_027$8 = [0, [1, [0, _O_, [0, arg_029, 0]]], bnds_027$7];
    return [1, bnds_027$8];
   }
   function is_dropping_incoming_connectio(t){return t[9];}
   function num_connections(t){return caml_call1(Core_Bag[5], t[7]);}
   function sexp_of_inet$1(x_049){
    return sexp_of_t$4
            (Async_unix_Unix_syscalls[95][1][2][12], Core[389], x_049);
   }
   function sexp_of_unix$1(x_050){
    return sexp_of_t$4
            (Async_unix_Unix_syscalls[95][1][1][9], Core[558], x_050);
   }
   function listening_on_address(t){
    return caml_call1(Async_unix_Unix_syscalls[95][20], t[1]);
   }
   function invariant(t){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, t));
        },
      _bj_ =
        function(connections){
         function invariant_address(_bp_){return 0;}
         function _bm_(t){
          function _bn_(param){
           var
            client_address_fun =
              caml_call2
               (Async_kernel_Async_invariant[2], t, invariant_address);
           return caml_call1(client_address_fun, client_address$0);
          }
          function _bo_(x_024){
           return sexp_of_t$3(function(param){return _t_;}, x_024);
          }
          return caml_call4
                  (Async_kernel_Async_invariant[1], _u_, t, _bo_, _bn_);
         }
         caml_call2(Core_Bag[21], _bm_, connections);
         var num_connections$0 = num_connections(t);
         if(! caml_call2(Async_unix_Import[1], num_connections$0, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
         if(caml_call2(Async_unix_Import[2], num_connections$0, t[5][1]))
          return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _U_], 1);
        },
      _bk_ =
        function(max_accepts_per_batch){
         if(caml_call2(Async_unix_Import[1], max_accepts_per_batch, 1))
          return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
        };
     check
      (function(max_connections){
        if(caml_call2(Async_unix_Import[1], max_connections[1], 1)) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
       },
       max_connections$0);
     check(_bk_, max_accepts_per_batch$0);
     check(_bj_, connections$0);
     var _bh_ = 0;
     return _bh_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _bi_ =
        function(param){
         var
          arg1_052 = param[2],
          arg0_051 = param[1],
          res0_053 = caml_call1(Core[625], arg0_051);
         function _bl_(param){return _R_;}
         var
          res1_054 = sexp_of_t$4(function(param){return _S_;}, _bl_, arg1_052);
         return [1, [0, res0_053, [0, res1_054, 0]]];
        };
     return caml_call5
             (Core[247], 0, _T_, cst_invariant_failed, [0, exn, t], _bi_);
    }
   }
   function fd(t){return caml_call1(Async_unix_Unix_syscalls[95][18], t[1]);}
   function is_closed(t){
    var _bg_ = fd(t);
    return caml_call1(Async_unix_Fd[16], _bg_);
   }
   function close_finished(t){
    var _bf_ = fd(t);
    return caml_call1(Async_unix_Fd[15], _bf_);
   }
   function close_finished_and_handlers_de(t){
    return caml_call1(Async_kernel_Ivar[19], t[10]);
   }
   function close$0(opt, t){
    if(opt)
     var sth = opt[1], close_existing_connections = sth;
    else
     var close_existing_connections = 0;
    var _bc_ = fd(t), fd_closed = caml_call2(Async_unix_Fd[12], 0, _bc_);
    if(! close_existing_connections) return fd_closed;
    var
     _bd_ = caml_call1(Core_Bag[17], t[7]),
     _be_ = [0, fd_closed, caml_call2(Core_List[51], _bd_, close)];
    return caml_call1(Async_kernel_Deferred[22], _be_);
   }
   function maybe_accept(t){
    var _aV_ = num_connections(t), available_slots = t[5][1] - _aV_ | 0;
    if
     (!
      is_closed(t)
      && caml_call2(Async_unix_Import[4], available_slots, 0) && ! t[8]){
     t[8] = 1;
     var
      _aY_ =
        function(accept_result){
         t[8] = 0;
         if(typeof accept_result === "number") return 0;
         var conns = accept_result[2];
         a:
         {
          if(! is_closed(t) && ! t[9]){
           var
            _a2_ =
              function(param){
               var
                client_address = param[2],
                client_socket = param[1],
                connection = [0, client_socket, client_address],
                connections_elt = caml_call2(Core_Bag[23], t[7], connection);
               function _a5_(res){
                function _a7_(param){
                 caml_call2(Core_Bag[26], t[7], connections_elt);
                 var
                  _a9_ = close_finished(t),
                  _a__ = caml_call1(Async_kernel_Deferred[7], _a9_);
                 if(_a__)
                  var
                   _a$_ = num_connections(t),
                   _ba_ = caml_call2(Async_unix_Import[3], _a$_, 0);
                 else
                  var _ba_ = _a__;
                 if(_ba_) caml_call2(Async_kernel_Ivar[16], t[10], 0);
                 if(0 !== res[0]){
                  var e = res[1];
                  try{
                   var match = t[3];
                   if(typeof match === "number"){
                    if(-146189108 <= match)
                     throw caml_maybe_attach_backtrace(e, 0);
                   }
                   else{var f = match[2]; caml_call2(f, client_address, e);}
                  }
                  catch(e){
                   var e$0 = caml_wrap_exception(e), _bb_ = close$0(0, t);
                   caml_call1(Async_unix_Import[16], _bb_);
                   throw caml_maybe_attach_backtrace(e$0, 0);
                  }
                 }
                 return maybe_accept(t);
                }
                var _a8_ = close(connection);
                return caml_call2(Async_unix_Import[27], _a8_, _a7_);
               }
               var _a6_ = caml_call2(t[4], client_address, client_socket);
               return caml_call2(Async_unix_Import[27], _a6_, _a5_);
              };
           caml_call2(Core_List[19], conns, _a2_);
           break a;
          }
          var
           _a1_ =
             function(param){
              var
               sock = param[1],
               _a3_ = caml_call1(Async_unix_Unix_syscalls[95][18], sock),
               _a4_ = caml_call2(Async_unix_Fd[12], 0, _a3_);
              return caml_call1(Async_unix_Import[16], _a4_);
             };
          caml_call2(Core_List[19], conns, _a1_);
         }
         return maybe_accept(t);
        },
      _aZ_ = caml_call2(Async_unix_Import[9], t[6], available_slots),
      _a0_ = caml_call2(Async_unix_Unix_syscalls[95][15], t[1], _aZ_);
     return caml_call2(Async_unix_Import[27], _a0_, _aY_);
    }
    var
     _aW_ = 1 - is_closed(t),
     _aX_ = _aW_ ? caml_call2(Async_unix_Import[3], available_slots, 0) : _aW_;
    if(! _aX_) return _aX_;
    var
     t$0 = t[5],
     now = caml_call1(Async_kernel_Time_source[14], t$0[2]),
     match = t$0[4];
    if(! match) return log_at_limit(t$0, now);
    var
     last_logged = match[1],
     _aT_ = caml_call2(Time_ns_unix[47], now, last_logged),
     _aU_ = caml_call2(Time_ns_unix[72][18], _aT_, log_threshold);
    return _aU_ ? log_at_limit(t$0, now) : _aU_;
   }
   function create_from_socket
   (max_connections,
    opt,
    _aL_,
    on_handler_error,
    where_to_listen,
    handle_client,
    socket){
    if(opt)
     var sth = opt[1], max_accepts_per_batch = sth;
    else
     var max_accepts_per_batch = 1;
    if(_aL_)
     var sth$0 = _aL_[1], drop_incoming_connections = sth$0;
    else
     var drop_incoming_connections = 0;
    var
     _aM_ = caml_call1(Async_kernel_Ivar[12], 0),
     _aN_ = caml_call1(Core_Bag[22], 0),
     _aO_ = caml_call1(Async_unix_Unix_syscalls[95][20], socket),
     t =
       [0,
        socket,
        caml_call1(where_to_listen[3], _aO_),
        on_handler_error,
        handle_client,
        max_connections,
        max_accepts_per_batch,
        _aN_,
        0,
        drop_incoming_connections,
        _aM_];
    function _aP_(param){
     var
      _aR_ = num_connections(t),
      _aS_ = caml_call2(Async_unix_Import[3], _aR_, 0);
     return _aS_ ? caml_call2(Async_kernel_Ivar[16], t[10], 0) : _aS_;
    }
    var _aQ_ = close_finished(t);
    caml_call2(Async_unix_Import[27], _aQ_, _aP_);
    maybe_accept(t);
    return t;
   }
   function get_max_connections_limit(max_connections){
    if(! max_connections) return 10000;
    var max_connections$0 = max_connections[1];
    if(caml_call2(Async_unix_Import[2], max_connections$0, 0))
     caml_call5
      (Core[247],
       0,
       _Y_,
       cst_Tcp_Server_creater_got_neg,
       max_connections$0,
       Core[389]);
    return max_connections$0;
   }
   function create$1(maybe_socket, where_to_listen){
    if(maybe_socket){
     var socket = maybe_socket[1];
     return [0, caml_call1(Core_Fn[1], socket), 0];
    }
    var inet = where_to_listen[2];
    if(948106920 <= inet[1])
     var match = 0;
    else
     var
      _aJ_ = caml_call1(Async_unix_Unix_syscalls[95][1][2][18], inet),
      match = caml_call2(Async_unix_Import[3], _aJ_, 0);
    var _aK_ = match ? 10 : 0;
    return [0,
            function(param){
             var
              socket =
                caml_call1
                 (Async_unix_Unix_syscalls[95][5], where_to_listen[1]);
             caml_call3
              (Async_unix_Unix_syscalls[95][24],
               socket,
               Async_unix_Unix_syscalls[95][22][3],
               1);
             return socket;
            },
            _aK_];
   }
   function handle_exn(t, socket, exn, retries_attempted_upon_addr_in){
    var
     _aD_ = caml_call1(Async_unix_Unix_syscalls[95][18], socket),
     _aE_ = caml_call2(Async_unix_Unix_syscalls[16], 0, _aD_);
    caml_call1(Async_unix_Import[16], _aE_);
    if
     (caml_call2(Async_unix_Import[4], t[2], retries_attempted_upon_addr_in)
      && exn[1] === Async_unix_Unix_syscalls[153]){
     var _aF_ = exn[2];
     if(typeof _aF_ === "number" && 50 === _aF_) return;
    }
    if(! caml_call2(Async_unix_Import[4], retries_attempted_upon_addr_in, 0))
     throw caml_maybe_attach_backtrace(exn, 0);
    var
     _aG_ =
       [0,
        [1,
         [0,
          _Z_,
          [0, caml_call1(Core[389], retries_attempted_upon_addr_in), 0]]],
        0],
     _aH_ = [0, [1, [0, ___, [0, caml_call1(Base_Exn[1], exn), 0]]], _aG_],
     _aI_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Failed_to_bind_and_listen_),
         _aH_]];
    return caml_call1(Core[261], _aI_);
   }
   function aux_bind_and_listen_maybe_retr
   (t, retries_attempted_upon_addr_in, f){
    var socket = caml_call1(t[1], 0);
    function _aA_(param){
     if(0 === param[0]){
      var v = param[1];
      return caml_call1(Async_unix_Import[30], v);
     }
     var exn = param[1];
     handle_exn(t, socket, exn, retries_attempted_upon_addr_in);
     return aux_bind_and_listen_maybe_retr
             (t, retries_attempted_upon_addr_in + 1 | 0, f);
    }
    function _aB_(param){return caml_call1(f, socket);}
    var _aC_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _$_, 0, 0, _aB_);
    return caml_call2(Async_unix_Import[33][2], _aC_, _aA_);
   }
   function create_sock_non_inet_internal
   (max_connections,
    max_accepts_per_batch,
    backlog,
    drop_incoming_connections,
    socket,
    time_source,
    on_handler_error,
    where_to_listen,
    handle_client){
    if(time_source)
     var
      x = time_source[1],
      time_source$0 = caml_call1(Async_kernel_Time_source[8], x);
    else
     var time_source$0 = caml_call1(Async_kernel_Time_source[10], 0);
    function _au_(socket){
     var
      _ay_ = caml_call1(Async_unix_Unix_syscalls[95][18], socket),
      _az_ = caml_call1(Async_unix_Fd[4], _ay_),
      max_connections$0 =
        create$0
         (get_max_connections_limit(max_connections), time_source$0, _az_);
     return create_from_socket
             (max_connections$0,
              max_accepts_per_batch,
              drop_incoming_connections,
              on_handler_error,
              where_to_listen,
              handle_client,
              socket);
    }
    var
     socket_creator = create$1(socket, where_to_listen),
     _av_ =
       aux_bind_and_listen_maybe_retr
        (socket_creator,
         0,
         function(socket){
          var
           _aw_ = caml_call1(Async_unix_Unix_syscalls[95][12], backlog),
           _ax_ =
             caml_call2
              (Async_unix_Unix_syscalls[95][8], socket, where_to_listen[2]);
          return caml_call2(Async_unix_Import[32], _ax_, _aw_);
         });
    return caml_call2(Async_unix_Import[33][3], _av_, _au_);
   }
   function create_sock_inet_internal
   (max_connections,
    max_accepts_per_batch,
    backlog,
    drop_incoming_connections,
    socket$0,
    time_source,
    on_handler_error,
    where_to_listen,
    handle_client){
    if(time_source)
     var
      x = time_source[1],
      time_source$0 = caml_call1(Async_kernel_Time_source[8], x);
    else
     var time_source$0 = caml_call1(Async_kernel_Time_source[10], 0);
    var
     socket_creator = create$1(socket$0, where_to_listen),
     retries_attempted_upon_addr_in = 0;
    for(;;){
     var socket = caml_call1(socket_creator[1], 0);
     try{
      var
       _ar_ =
         caml_call2
          (Async_unix_Unix_syscalls[95][10], socket, where_to_listen[2]),
       socket$1 = caml_call2(Async_unix_Unix_syscalls[95][12], backlog, _ar_);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      handle_exn(socket_creator, socket, exn, retries_attempted_upon_addr_in);
      var
       retries_attempted_upon_addr_in$0 =
         retries_attempted_upon_addr_in + 1 | 0,
       retries_attempted_upon_addr_in = retries_attempted_upon_addr_in$0;
      continue;
     }
     var
      _as_ = caml_call1(Async_unix_Unix_syscalls[95][18], socket$1),
      _at_ = caml_call1(Async_unix_Fd[4], _as_),
      max_connections$0 =
        create$0
         (get_max_connections_limit(max_connections), time_source$0, _at_);
     return create_from_socket
             (max_connections$0,
              max_accepts_per_batch,
              drop_incoming_connections,
              on_handler_error,
              where_to_listen,
              handle_client,
              socket$1);
    }
   }
   function create_sock_inet_internal_asyn
   (max_connections,
    max_accepts_per_batch,
    backlog,
    drop_incoming_connections,
    socket,
    time_source,
    on_handler_error,
    where_to_listen,
    handle_client){
    var
     _aq_ =
       create_sock_inet_internal
        (max_connections,
         max_accepts_per_batch,
         backlog,
         drop_incoming_connections,
         socket,
         time_source,
         on_handler_error,
         where_to_listen,
         handle_client);
    return caml_call1(Async_unix_Import[30], _aq_);
   }
   function create_sock_internal
   (max_connections,
    max_accepts_per_batch,
    backlog,
    drop_incoming_connections,
    socket,
    time_source,
    on_handler_error,
    where_to_listen,
    handle_client){
    var
     _ap_ = caml_call1(Async_unix_Unix_syscalls[95][4][6], where_to_listen[1]),
     is_inet = caml_call1(Async_unix_Unix_syscalls[95][2][3], _ap_),
     match =
       is_inet
        ? [0, create_sock_inet_internal_asyn]
        : [0, create_sock_non_inet_internal],
     f = match[1];
    return f
            (max_connections,
             max_accepts_per_batch,
             backlog,
             drop_incoming_connections,
             socket,
             time_source,
             on_handler_error,
             where_to_listen,
             handle_client);
   }
   function create_sock
   (max_connections,
    max_accepts_per_batch,
    backlog,
    drop_incoming_connections,
    socket,
    time_source,
    on_handler_error,
    where_to_listen,
    handle_client){
    return create_sock_internal
            (max_connections,
             max_accepts_per_batch,
             backlog,
             drop_incoming_connections,
             socket,
             time_source,
             on_handler_error,
             where_to_listen,
             function(client_address, client_socket){
              function _ao_(param){
               return caml_call2(handle_client, client_address, client_socket);
              }
              return caml_call7
                      (Async_kernel_Monitor[16], 0, 0, _ac_, 0, _ab_, _aa_, _ao_);
             });
   }
   function create_sock_inet
   (max_connections,
    max_accepts_per_batch,
    backlog,
    drop_incoming_connections,
    socket,
    time_source,
    on_handler_error,
    where_to_listen,
    handle_client){
    return create_sock_inet_internal
            (max_connections,
             max_accepts_per_batch,
             backlog,
             drop_incoming_connections,
             socket,
             time_source,
             on_handler_error,
             where_to_listen,
             function(client_address, client_socket){
              function _an_(param){
               return caml_call2(handle_client, client_address, client_socket);
              }
              return caml_call7
                      (Async_kernel_Monitor[16], 0, 0, _af_, 0, _ae_, _ad_, _an_);
             });
   }
   function create_internal
   (create_sock,
    buffer_age_limit,
    max_connections,
    max_accepts_per_batch,
    backlog,
    drop_incoming_connections,
    socket,
    time_source,
    on_handler_error,
    where_to_listen,
    handle_client){
    return caml_call9
            (create_sock,
             max_connections,
             max_accepts_per_batch,
             backlog,
             drop_incoming_connections,
             socket,
             time_source,
             on_handler_error,
             where_to_listen,
             function(client_address, client_socket){
              var
               match =
                 reader_writer_of_sock(buffer_age_limit, 0, 0, client_socket),
               w = match[2],
               r = match[1];
              caml_call2(Async_unix_Writer[20], w, 0);
              function _ag_(res){
               function _al_(param){return res;}
               var _am_ = close_connection_via_reader_an(r, w);
               return caml_call2(Async_unix_Import[32], _am_, _al_);
              }
              var
               _ah_ = caml_call1(Async_unix_Writer[22], w),
               _ai_ = [0, caml_call1(Async_kernel_Deferred[33], _ah_), 0],
               _aj_ =
                 [0,
                  collect_errors
                   (w,
                    function(param){
                     return caml_call3(handle_client, client_address, r, w);
                    }),
                  _ai_],
               _ak_ = caml_call1(Async_kernel_Deferred[23], _aj_);
              return caml_call2(Async_unix_Import[31], _ak_, _ag_);
             });
   }
   function create_inet
   (buffer_age_limit,
    max_connections,
    max_accepts_per_batch,
    backlog,
    drop_incoming_connections,
    socket,
    time_source,
    on_handler_error,
    where_to_listen,
    handle_client){
    return create_internal
            (create_sock_inet_internal,
             buffer_age_limit,
             max_connections,
             max_accepts_per_batch,
             backlog,
             drop_incoming_connections,
             socket,
             time_source,
             on_handler_error,
             where_to_listen,
             handle_client);
   }
   function create$2
   (buffer_age_limit,
    max_connections,
    max_accepts_per_batch,
    backlog,
    drop_incoming_connections,
    socket,
    time_source,
    on_handler_error,
    where_to_listen,
    handle_client){
    return create_internal
            (create_sock_internal,
             buffer_age_limit,
             max_connections,
             max_accepts_per_batch,
             backlog,
             drop_incoming_connections,
             socket,
             time_source,
             on_handler_error,
             where_to_listen,
             handle_client);
   }
   var
    Private = [0, fd],
    Aliases = [0],
    Private$0 =
      [0, close_connection_via_reader_an, set_max_connection_limit_logge];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Tcp);
   var
    Async_unix_Tcp =
      [0,
       [0,
        sexp_of_t,
        sexp_of_inet,
        sexp_of_unix,
        remote_address,
        of_host_and_port,
        of_inet_address,
        of_file,
        of_unix_address],
       with_connection,
       connect_sock,
       connect,
       Bind_to_address,
       Bind_to_port,
       [0,
        sexp_of_t$2,
        sexp_of_inet$0,
        sexp_of_unix$0,
        create,
        address,
        bind_to,
        of_port,
        of_port_chosen_by_os,
        of_file$0],
       [0,
        sexp_of_t$4,
        sexp_of_inet$1,
        sexp_of_unix$1,
        invariant,
        listening_on,
        listening_on_address,
        close$0,
        close_finished,
        is_closed,
        close_finished_and_handlers_de,
        create_sock,
        create_sock_inet,
        create$2,
        create_inet,
        socket,
        num_connections,
        set_drop_incoming_connections,
        is_dropping_incoming_connectio,
        Private],
       Aliases,
       Private$0];
   runtime.caml_register_global(107, Async_unix_Tcp, cst_Async_unix_Tcp$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Process
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Deferred_or_error, Async_unix__Fd, Async_unix__Import, Async_unix__In_thread, Async_unix__Reader, Async_unix__Unix_syscalls, Async_unix__Writer, CamlinternalLazy, Core, Core__Info, Core__Int, Core__Lazy, Core__List, Core__Or_error, Core__Pid, Core__Sexp, Core__Signal, Core__String, Core_unix, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_record, Signal_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    cst_Async_unix_Process$0 = "Async_unix__Process",
    cst_Process_run_failed$1 = "Process.run failed",
    cst_args = "args",
    cst_async_unix$0 = "async_unix",
    cst_child_process$1 = "child process",
    cst_env = "env",
    cst_exit_status$0 = "exit_status",
    cst_pid = "pid",
    cst_prog = "prog",
    cst_src_process_ml = "src/process.ml",
    cst_stderr$1 = "stderr",
    cst_stdin$1 = "stdin",
    cst_stdout$1 = "stdout",
    cst_working_dir = "working_dir",
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   function caml_call11(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
    return (f.l >= 0 ? f.l : f.l = f.length) == 11
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    error_source_036 = "src/process.ml.Output.Stable.V1.t",
    Core_Pid = global_data.Core__Pid,
    Core_Signal = global_data.Core__Signal,
    Core = global_data.Core,
    Core_Lazy = global_data.Core__Lazy,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Signal_unix = global_data.Signal_unix,
    Core_unix = global_data.Core_unix,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Or_error = global_data.Core__Or_error,
    Async_unix_Writer = global_data.Async_unix__Writer,
    Core_Info = global_data.Core__Info,
    Async_unix_Fd = global_data.Async_unix__Fd,
    Async_unix_Unix_syscalls = global_data.Async_unix__Unix_syscalls,
    Async_unix_Import = global_data.Async_unix__Import,
    Async_kernel_Deferred_or_error =
      global_data.Async_kernel__Deferred_or_error,
    Async_unix_In_thread = global_data.Async_unix__In_thread,
    Async_unix_Reader = global_data.Async_unix__Reader,
    Core_Int = global_data.Core__Int,
    Core_List = global_data.Core__List,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Core_Sexp = global_data.Core__Sexp,
    Core_String = global_data.Core__String,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Process$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_process_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "process.ml");
   var
    env_of_sexp = Async_unix_Unix_syscalls[73],
    sexp_of_env = Async_unix_Unix_syscalls[72],
    _ag_ =
      [0,
       [11,
        "Process.send_signal_compat_exn ",
        [2, 0, [11, " pid:", [2, 0, 0]]]],
       "Process.send_signal_compat_exn %s pid:%s"],
    _ab_ = [0, cst_exit_status$0],
    _ac_ = [0, cst_env],
    _ad_ = [0, cst_working_dir],
    _ae_ = [0, cst_args],
    _af_ = [0, cst_prog],
    cst_Process_run_forwarding_wit =
      "Process.run_forwarding_with_shared_fds failed",
    _Z_ = [0, cst_pid],
    ___ = [0, cst_prog],
    _$_ = [0, cst_args],
    cst_stdin$0 = cst_stdin$1,
    cst_child_process$0 = cst_child_process$1,
    _aa_ = [0, [0, cst_src_process_ml, 388, 9065, 9084]],
    cst_create_process_with_fds = "create_process_with_fds",
    _T_ = [0, cst_exit_status$0],
    _U_ = [0, cst_env],
    _V_ = [0, cst_working_dir],
    _W_ = [0, cst_args],
    _X_ = [0, cst_prog],
    cst_Process_run_failed$0 = cst_Process_run_failed$1,
    _O_ = [0, "output"],
    _P_ = [0, cst_args],
    _Q_ = [0, cst_prog],
    _R_ = [0, 0],
    cst_Process_run_expect_no_outp =
      "Process.run_expect_no_output: non-empty output",
    cst_Process_run_failed = cst_Process_run_failed$1,
    _D_ = [0, 0],
    _w_ = [0, cst_stderr$1],
    _x_ = [0, cst_stdout$1],
    _y_ = [0, cst_exit_status$0],
    _C_ = [0, cst_env],
    _z_ = [0, cst_working_dir],
    _A_ = [0, cst_args],
    _B_ = [0, cst_prog],
    _t_ = [0, cst_exit_status$0],
    _u_ = [0, cst_stderr$1],
    _v_ = [0, cst_stdout$1],
    _q_ = [0, cst_exit_status$0],
    _r_ = [0, cst_stderr$1],
    _s_ = [0, cst_stdout$1],
    cst_exit_status = cst_exit_status$0,
    cst_stderr$0 = cst_stderr$1,
    cst_stdout$0 = cst_stdout$1,
    _j_ = [0, cst_pid],
    _k_ = [0, cst_prog],
    _l_ = [0, cst_args],
    cst_child_process = cst_child_process$1,
    _m_ = [0, [0, cst_src_process_ml, 52, 965, 982]],
    cst_stdin = cst_stdin$1,
    _n_ = [0, 0],
    _o_ = [0, 751362817],
    cst_stderr = cst_stderr$1,
    cst_stdout = cst_stdout$1,
    _p_ = [0, -72399366, 0],
    cst_create_process_env = "create_process_env",
    _a_ = [0, "wait"],
    _b_ = [0, cst_env],
    _c_ = [0, cst_working_dir],
    _d_ = [0, cst_args],
    _e_ = [0, cst_prog],
    _f_ = [0, cst_stderr$1],
    _g_ = [0, cst_stdout$1],
    _h_ = [0, cst_stdin$1],
    _i_ = [0, cst_pid],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Process = cst_Async_unix_Process$0;
   function stderr(r){return r[4];}
   function stdout(r){return r[3];}
   function stdin(r){return r[2];}
   function pid(r){return r[1];}
   function sexp_of_t(param){
    var
     wait_019 = param[9],
     env_017 = param[8],
     working_dir_015 = param[7],
     args_013 = param[6],
     prog_011 = param[5],
     stderr_009 = param[4],
     stdout_007 = param[3],
     stdin_005 = param[2],
     pid_003 = param[1],
     _cF_ = caml_call1(Async_kernel_Deferred[1], Core_unix[15][7]),
     arg_020 = caml_call2(Core_Lazy[23], _cF_, wait_019),
     bnds_002 = [0, [1, [0, _a_, [0, arg_020, 0]]], 0],
     arg_018 = caml_call1(sexp_of_env, env_017),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_018, 0]]], bnds_002],
     arg_016 = caml_call2(Core[515], Core[558], working_dir_015),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_016, 0]]], bnds_002$0],
     arg_014 = caml_call2(Core[472], Core[558], args_013),
     bnds_002$2 = [0, [1, [0, _d_, [0, arg_014, 0]]], bnds_002$1],
     arg_012 = caml_call1(Core[558], prog_011),
     bnds_002$3 = [0, [1, [0, _e_, [0, arg_012, 0]]], bnds_002$2],
     arg_010 = caml_call1(Async_unix_Reader[3], stderr_009),
     bnds_002$4 = [0, [1, [0, _f_, [0, arg_010, 0]]], bnds_002$3],
     arg_008 = caml_call1(Async_unix_Reader[3], stdout_007),
     bnds_002$5 = [0, [1, [0, _g_, [0, arg_008, 0]]], bnds_002$4],
     arg_006 = caml_call1(Async_unix_Writer[3], stdin_005),
     bnds_002$6 = [0, [1, [0, _h_, [0, arg_006, 0]]], bnds_002$5],
     arg_004 = caml_call1(Core_Pid[13], pid_003),
     bnds_002$7 = [0, [1, [0, _i_, [0, arg_004, 0]]], bnds_002$6];
    return [1, bnds_002$7];
   }
   function create
   (argv0,
    buf_len,
    opt,
    prog_search_path,
    write_to_stdin,
    working_dir,
    setpgid,
    prog,
    args,
    param){
    if(opt) var sth = opt[1], env = sth; else var env = _p_;
    function _cv_(param){
     if(0 !== param[0]){
      var exn = param[1];
      return caml_call2(Core_Or_error[41], 0, exn);
     }
     var
      match = param[1],
      stderr = match[4],
      stdout = match[3],
      stdin = match[2],
      pid = match[1];
     function create_fd(name, file_descr){
      function _cD_(param){
       var
        arg3_027 = param[4],
        arg2_026 = param[3],
        arg1_025 = param[2],
        arg0_024 = param[1],
        res0_028 = caml_call1(Core[558], arg0_024),
        v_021 = arg1_025[2],
        res1_029 = [1, [0, _j_, [0, caml_call1(Core_Pid[13], v_021), 0]]],
        v_022 = arg2_026[2],
        res2_030 = [1, [0, _k_, [0, caml_call1(Core[558], v_022), 0]]],
        v_023 = arg3_027[2],
        res3_031 =
          [1, [0, _l_, [0, caml_call2(Core[472], Core[558], v_023), 0]]];
       return [1,
               [0, res0_028, [0, res1_029, [0, res2_030, [0, res3_031, 0]]]]];
      }
      var
       _cE_ =
         caml_call5
          (Core_Info[19],
           _m_,
           0,
           cst_child_process,
           [0,
            name,
            [0, 5593163, pid],
            [0, -899758182, prog],
            [0, -1066103459, args]],
           _cD_);
      return caml_call4(Async_unix_Fd[6], 0, 1, file_descr, _cE_);
     }
     var
      fd = create_fd(cst_stdin, stdin),
      stdin$0 =
        write_to_stdin
         ? caml_call7(Async_unix_Writer[18], buf_len, 0, _o_, _n_, 0, 0, fd)
         : caml_call7(Async_unix_Writer[18], buf_len, 0, 0, 0, 0, 0, fd),
      _cy_ =
        [246,
         function(_cC_){return caml_call1(Async_unix_Unix_syscalls[90], pid);}],
      _cz_ = create_fd(cst_stderr, stderr),
      _cA_ = caml_call2(Async_unix_Reader[12], buf_len, _cz_),
      _cB_ = create_fd(cst_stdout, stdout),
      t =
        [0,
         pid,
         stdin$0,
         caml_call2(Async_unix_Reader[12], buf_len, _cB_),
         _cA_,
         prog,
         args,
         working_dir,
         env,
         _cy_];
     if(write_to_stdin){
      var write_to_stdin$0 = write_to_stdin[1];
      caml_call4(Async_unix_Writer[33], 0, 0, t[2], write_to_stdin$0);
     }
     return [0, t];
    }
    function _cw_(param){
     return caml_call8
             (Core_unix[121],
              working_dir,
              prog_search_path,
              argv0,
              setpgid,
              prog,
              args,
              env,
              0);
    }
    var
     _cx_ = caml_call2(Async_unix_In_thread[6], cst_create_process_env, _cw_);
    return caml_call2(Async_unix_Import[33][3], _cx_, _cv_);
   }
   function create_exn
   (argv0,
    buf_len,
    env,
    prog_search_path,
    stdin,
    working_dir,
    setpgid,
    prog,
    args,
    param){
    var
     _ct_ = Core[255],
     _cu_ =
       create
        (argv0,
         buf_len,
         env,
         prog_search_path,
         stdin,
         working_dir,
         setpgid,
         prog,
         args,
         0);
    return caml_call2(Async_unix_Import[32], _cu_, _ct_);
   }
   function sexp_of_t$0(t){
    if(0 !== t[0]){var sexp = t[1]; return sexp;}
    var lines = t[1];
    a:
    if(lines){
     if(! caml_string_notequal(lines[1], cst$0) && ! lines[2]) break a;
     return caml_call2(Core[472], Core[558], lines);
    }
    return caml_call1(Sexplib0_Sexp_conv[7], cst);
   }
   function create$0(string){
    try{var _cr_ = [1, caml_call1(Core_Sexp[76], string)]; return _cr_;}
    catch(_cs_){return [0, caml_call2(Core_String[78], string, 10)];}
   }
   var Lines_or_sexp = [0, sexp_of_t$0, create$0];
   function compare(a_033, b_034){
    if(a_033 === b_034) return 0;
    var n = caml_call2(Core[551], a_033[1], b_034[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Core[551], a_033[2], b_034[2]);
    return 0 === n$0 ? caml_call2(Core_unix[15][5], a_033[3], b_034[3]) : n$0;
   }
   function t_of_sexp(x_037){
    function _cn_(param){
     var
      _cq_ = param[2],
      exit_status = _cq_[2][1],
      stderr = _cq_[1],
      stdout = param[1];
     return [0, stdout, stderr, exit_status];
    }
    var _co_ = 0;
    function _cp_(param){
     return caml_string_notequal(param, cst_exit_status$0)
             ? caml_string_notequal
                (param, cst_stderr$1)
               ? caml_string_notequal(param, cst_stdout$1) ? -1 : 0
               : 1
             : 2;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_036,
             [0,
              cst_stdout$0,
              1,
              Core[559],
              [0,
               cst_stderr$0,
               1,
               Core[559],
               [0, cst_exit_status, 1, Core_unix[15][6], 0]]],
             _cp_,
             _co_,
             _cn_,
             x_037);
   }
   function sexp_of_t$1(param){
    var
     exit_status_043 = param[3],
     stderr_041 = param[2],
     stdout_039 = param[1],
     arg_044 = caml_call1(Core_unix[15][7], exit_status_043),
     bnds_038 = [0, [1, [0, _q_, [0, arg_044, 0]]], 0],
     arg_042 = caml_call1(Core[558], stderr_041),
     bnds_038$0 = [0, [1, [0, _r_, [0, arg_042, 0]]], bnds_038],
     arg_040 = caml_call1(Core[558], stdout_039),
     bnds_038$1 = [0, [1, [0, _s_, [0, arg_040, 0]]], bnds_038$0];
    return [1, bnds_038$1];
   }
   var
    V1 = [0, compare, t_of_sexp, sexp_of_t$1],
    Stable = [0, V1],
    include = Stable[1],
    compare$0 = include[1];
   function sexp_of_t$2(t){
    var
     _cj_ = [0, [1, [0, _t_, [0, caml_call1(Core_unix[15][7], t[3]), 0]]], 0],
     _ck_ = caml_call1(Lines_or_sexp[2], t[2]),
     _cl_ =
       [0, [1, [0, _u_, [0, caml_call1(Lines_or_sexp[1], _ck_), 0]]], _cj_],
     _cm_ = caml_call1(Lines_or_sexp[2], t[1]);
    return [1,
            [0,
             [1, [0, _v_, [0, caml_call1(Lines_or_sexp[1], _cm_), 0]]],
             _cl_]];
   }
   function wait(t){return caml_call1(Core[248], t[9]);}
   function collect_output_and_wait(t){
    var
     stdout = caml_call1(Async_unix_Reader[57], t[3]),
     stderr = caml_call1(Async_unix_Reader[57], t[4]);
    function _cb_(param){
     function _cf_(exit_status){
      function _ch_(stdout){
       function _ci_(stderr){
        return caml_call1
                (Async_unix_Import[30], [0, stdout, stderr, exit_status]);
       }
       return caml_call2(Async_unix_Import[33][2], stderr, _ci_);
      }
      return caml_call2(Async_unix_Import[33][2], stdout, _ch_);
     }
     var _cg_ = wait(t);
     return caml_call2(Async_unix_Import[33][2], _cg_, _cf_);
    }
    var
     _cc_ = t[2],
     _cd_ = [0, caml_call1(Async_kernel_Deferred[19], 0)],
     _ce_ = caml_call2(Async_unix_Writer[65], _cd_, _cc_);
    return caml_call2(Async_unix_Import[33][2], _ce_, _cb_);
   }
   function sexp_of_t$3(param){
    var
     stderr_067 = param[7],
     stdout_065 = param[6],
     exit_status_063 = param[5],
     env_060 = param[4],
     working_dir_054 = param[3],
     args_052 = param[2],
     prog_050 = param[1],
     arg_068 = caml_call1(Lines_or_sexp[1], stderr_067),
     bnds_049 = [0, [1, [0, _w_, [0, arg_068, 0]]], 0],
     arg_066 = caml_call1(Lines_or_sexp[1], stdout_065),
     bnds_049$0 = [0, [1, [0, _x_, [0, arg_066, 0]]], bnds_049],
     arg_064 = caml_call1(Core_unix[15][2], exit_status_063),
     bnds_049$1 = [0, [1, [0, _y_, [0, arg_064, 0]]], bnds_049$0];
    a:
    {
     if(-72399366 <= env_060[1] && ! env_060[2]){var _ca_ = 1; break a;}
     var _ca_ = 0;
    }
    if(_ca_)
     var bnds_049$2 = bnds_049$1;
    else
     var
      arg_062 = caml_call1(sexp_of_env, env_060),
      bnd_061 = [1, [0, _C_, [0, arg_062, 0]]],
      bnds_049$2 = [0, bnd_061, bnds_049$1];
    if(working_dir_054)
     var
      v_055 = working_dir_054[1],
      arg_057 = caml_call1(Core[558], v_055),
      bnd_056 = [1, [0, _z_, [0, arg_057, 0]]],
      bnds_049$3 = [0, bnd_056, bnds_049$2];
    else
     var bnds_049$3 = bnds_049$2;
    var
     arg_053 = caml_call2(Core[472], Core[558], args_052),
     bnds_049$4 = [0, [1, [0, _A_, [0, arg_053, 0]]], bnds_049$3],
     arg_051 = caml_call1(Core[558], prog_050),
     bnds_049$5 = [0, [1, [0, _B_, [0, arg_051, 0]]], bnds_049$4];
    return [1, bnds_049$5];
   }
   function handle_exit_status(opt, ok){
    if(opt)
     var sth = opt[1], accept_nonzero_exit = sth;
    else
     var accept_nonzero_exit = 0;
    if(0 === ok[0]) return ok;
    var match = ok[1];
    if(typeof match !== "number" && -34939077 === match[1]){
     var n = match[2];
     if(caml_call3(Core_List[17], accept_nonzero_exit, n, Core_Int[87]))
      return _D_;
    }
    return ok;
   }
   function collect_stdout_and_wait(accept_nonzero_exit, t){
    function _b8_(param){
     var
      exit_status = param[3],
      stderr = param[2],
      stdout = param[1],
      match = handle_exit_status(accept_nonzero_exit, exit_status);
     if(0 === match[0]) return [0, stdout];
     var
      exit_status$0 = match[1],
      env = t[8],
      working_dir = t[7],
      args = t[6],
      prog = t[5],
      _b__ = caml_call1(Lines_or_sexp[2], stderr),
      _b$_ =
        [0,
         prog,
         args,
         working_dir,
         env,
         exit_status$0,
         caml_call1(Lines_or_sexp[2], stdout),
         _b__];
     return caml_call5
             (Core_Or_error[44],
              0,
              0,
              cst_Process_run_failed,
              _b$_,
              sexp_of_t$3);
    }
    var _b9_ = collect_output_and_wait(t);
    return caml_call2(Async_unix_Import[33][3], _b9_, _b8_);
   }
   function map_collect(collect, f, accept_nonzero_exit, t){
    function _b6_(a){return caml_call1(f, a);}
    var _b7_ = caml_call2(collect, accept_nonzero_exit, t);
    return caml_call2(Async_unix_Import[33][3], _b7_, _b6_);
   }
   var _E_ = Core[255];
   function collect_stdout_and_wait_exn(_b4_, _b5_){
    return map_collect(collect_stdout_and_wait, _E_, _b4_, _b5_);
   }
   var _F_ = Core_Or_error[53], _G_ = Core_String[80];
   function _H_(_b3_){return caml_call2(_F_, _b3_, _G_);}
   function collect_stdout_lines_and_wait(_b1_, _b2_){
    return map_collect(collect_stdout_and_wait, _H_, _b1_, _b2_);
   }
   var _I_ = Core[255];
   function collect_stdout_lines_and_wait_(_bZ_, _b0_){
    return map_collect(collect_stdout_lines_and_wait, _I_, _bZ_, _b0_);
   }
   function run
   (accept_nonzero_exit,
    argv0,
    env,
    prog_search_path,
    stdin,
    working_dir,
    prog,
    args,
    param){
    function _bX_(e){
     if(0 !== e[0]) return caml_call1(Async_unix_Import[30], e);
     var t = e[1];
     return collect_stdout_and_wait(accept_nonzero_exit, t);
    }
    var
     _bY_ =
       create
        (argv0,
         0,
         env,
         prog_search_path,
         stdin,
         working_dir,
         0,
         prog,
         args,
         0);
    return caml_call2(Async_unix_Import[33][2], _bY_, _bX_);
   }
   function map_run
   (run,
    f,
    accept_nonzero_exit,
    argv0,
    env,
    prog_search_path,
    stdin,
    working_dir,
    prog,
    args,
    param){
    function _bV_(a){return caml_call1(f, a);}
    var
     _bW_ =
       caml_call9
        (run,
         accept_nonzero_exit,
         argv0,
         env,
         prog_search_path,
         stdin,
         working_dir,
         prog,
         args,
         0);
    return caml_call2(Async_unix_Import[33][3], _bW_, _bV_);
   }
   var _J_ = Core[255];
   function run_exn(_bM_, _bN_, _bO_, _bP_, _bQ_, _bR_, _bS_, _bT_, _bU_){
    return map_run
            (run, _J_, _bM_, _bN_, _bO_, _bP_, _bQ_, _bR_, _bS_, _bT_, _bU_);
   }
   var _K_ = Core_Or_error[53], _L_ = Core_String[80];
   function _M_(_bL_){return caml_call2(_K_, _bL_, _L_);}
   function run_lines(_bC_, _bD_, _bE_, _bF_, _bG_, _bH_, _bI_, _bJ_, _bK_){
    return map_run
            (run, _M_, _bC_, _bD_, _bE_, _bF_, _bG_, _bH_, _bI_, _bJ_, _bK_);
   }
   var _N_ = Core[255];
   function run_lines_exn
   (_bt_, _bu_, _bv_, _bw_, _bx_, _by_, _bz_, _bA_, _bB_){
    return map_run
            (run_lines,
             _N_,
             _bt_,
             _bu_,
             _bv_,
             _bw_,
             _bx_,
             _by_,
             _bz_,
             _bA_,
             _bB_);
   }
   function run_expect_no_output
   (accept_nonzero_exit,
    argv0,
    env,
    prog_search_path,
    stdin,
    working_dir,
    prog,
    x_072,
    param){
    function _bo_(err){
     if(0 !== err[0]) return err;
     var non_empty_output = err[1];
     if(! caml_string_notequal(non_empty_output, cst$0)) return _R_;
     function _bq_(param){
      var
       _br_ =
         [0,
          [1, [0, _O_, [0, caml_call1(Core[558], non_empty_output), 0]]],
          0],
       _bs_ =
         [0,
          [1, [0, _P_, [0, caml_call2(Core[472], Core[558], x_072), 0]]],
          _br_];
      return [1,
              [0, [1, [0, _Q_, [0, caml_call1(Core[558], prog), 0]]], _bs_]];
     }
     return caml_call5
             (Core_Or_error[44],
              0,
              0,
              cst_Process_run_expect_no_outp,
              0,
              _bq_);
    }
    var
     _bp_ =
       run
        (accept_nonzero_exit,
         argv0,
         env,
         prog_search_path,
         stdin,
         working_dir,
         prog,
         x_072,
         0);
    return caml_call2(Async_unix_Import[33][3], _bp_, _bo_);
   }
   var _S_ = Core[255];
   function run_expect_no_output_exn
   (_bf_, _bg_, _bh_, _bi_, _bj_, _bk_, _bl_, _bm_, _bn_){
    return map_run
            (run_expect_no_output,
             _S_,
             _bf_,
             _bg_,
             _bh_,
             _bi_,
             _bj_,
             _bk_,
             _bl_,
             _bm_,
             _bn_);
   }
   function transfer_and_close(reader, writer){
    function _be_(param){
     return caml_call2(Async_unix_Writer[100], writer, reader);
    }
    return caml_call2(Async_unix_Reader[18], reader, _be_);
   }
   function forward_output_and_wait(accept_nonzero_exit, t){
    var
     _aY_ = t[2],
     _aZ_ = [0, caml_call1(Async_kernel_Deferred[19], 0)],
     let_syntax_073 = caml_call2(Async_unix_Writer[65], _aZ_, _aY_),
     _a0_ = Async_unix_Writer[5],
     _a1_ = caml_obj_tag(_a0_);
    a:
    if(250 === _a1_)
     var _a2_ = _a0_[1];
    else{
     if(246 !== _a1_ && 244 !== _a1_){var _a2_ = _a0_; break a;}
     var _a2_ = caml_call1(CamlinternalLazy[2], _a0_);
    }
    var
     let_syntax_074 = transfer_and_close(t[3], _a2_),
     _a3_ = Async_unix_Writer[6],
     _a4_ = caml_obj_tag(_a3_);
    a:
    if(250 === _a4_)
     var _a5_ = _a3_[1];
    else{
     if(246 !== _a4_ && 244 !== _a4_){var _a5_ = _a3_; break a;}
     var _a5_ = caml_call1(CamlinternalLazy[2], _a3_);
    }
    var
     let_syntax_075 = transfer_and_close(t[4], _a5_),
     let_syntax_076 = wait(t);
    function _a6_(param){
     var
      exit_status = param[2][2][2],
      ok = handle_exit_status(accept_nonzero_exit, exit_status);
     if(0 === ok[0]) return ok;
     var
      exit_status$0 = ok[1],
      env = t[8],
      working_dir = t[7],
      x_078 = t[6],
      prog = t[5],
      _a__ =
        [0,
         [1, [0, _T_, [0, caml_call1(Core_unix[15][2], exit_status$0), 0]]],
         0],
      _a$_ = [0, [1, [0, _U_, [0, caml_call1(sexp_of_env, env), 0]]], _a__],
      _ba_ =
        [0,
         [1, [0, _V_, [0, caml_call2(Core[515], Core[558], working_dir), 0]]],
         _a$_],
      _bb_ =
        [0,
         [1, [0, _W_, [0, caml_call2(Core[472], Core[558], x_078), 0]]],
         _ba_],
      _bc_ = [0, [1, [0, _X_, [0, caml_call1(Core[558], prog), 0]]], _bb_],
      _bd_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Process_run_failed$0),
          _bc_]];
     return caml_call1(Core_Or_error[45], _bd_);
    }
    var
     _a7_ =
       caml_call2(Async_unix_Import[33][4], let_syntax_075, let_syntax_076),
     _a8_ = caml_call2(Async_unix_Import[33][4], let_syntax_074, _a7_),
     _a9_ = caml_call2(Async_unix_Import[33][4], let_syntax_073, _a8_);
    return caml_call2(Async_unix_Import[33][3], _a9_, _a6_);
   }
   var _Y_ = Core[255];
   function forward_output_and_wait_exn(_aW_, _aX_){
    return map_collect(forward_output_and_wait, _Y_, _aW_, _aX_);
   }
   function run_forwarding_with_spliced_fd
   (accept_nonzero_exit,
    argv0,
    env,
    prog_search_path,
    stdin,
    working_dir,
    prog,
    args,
    param){
    function _aU_(e){
     if(0 !== e[0]) return caml_call1(Async_unix_Import[30], e);
     var t = e[1];
     return forward_output_and_wait(accept_nonzero_exit, t);
    }
    var
     _aV_ =
       create
        (argv0,
         0,
         env,
         prog_search_path,
         stdin,
         working_dir,
         0,
         prog,
         args,
         0);
    return caml_call2(Async_unix_Import[33][2], _aV_, _aU_);
   }
   function run_forwarding_with_shared_fds
   (accept_nonzero_exit,
    argv0,
    x_099,
    prog_search_path,
    write_to_stdin,
    working_dir,
    prog,
    x_097,
    param){
    var _ax_ = Async_unix_Writer[5], _ay_ = caml_obj_tag(_ax_);
    a:
    if(250 === _ay_)
     var _az_ = _ax_[1];
    else{
     if(246 !== _ay_ && 244 !== _ay_){var _az_ = _ax_; break a;}
     var _az_ = caml_call1(CamlinternalLazy[2], _ax_);
    }
    var
     let_syntax_080 = caml_call1(Async_unix_Writer[58], _az_),
     _aA_ = Async_unix_Writer[6],
     _aB_ = caml_obj_tag(_aA_);
    a:
    if(250 === _aB_)
     var _aC_ = _aA_[1];
    else{
     if(246 !== _aB_ && 244 !== _aB_){var _aC_ = _aA_; break a;}
     var _aC_ = caml_call1(CamlinternalLazy[2], _aA_);
    }
    var let_syntax_081 = caml_call1(Async_unix_Writer[58], _aC_);
    function _aD_(param){
     function _aF_(param){
      if(0 === param[0]){
       var
        match = param[1],
        stdin = match[2],
        pid = match[1],
        _aI_ =
          function(param){
           var
            arg3_092 = param[4],
            arg2_091 = param[3],
            arg1_090 = param[2],
            arg0_089 = param[1],
            res0_093 = caml_call1(Core[558], arg0_089),
            v_086 = arg1_090[2],
            res1_094 = [1, [0, _Z_, [0, caml_call1(Core_Pid[13], v_086), 0]]],
            v_087 = arg2_091[2],
            res2_095 = [1, [0, ___, [0, caml_call1(Core[558], v_087), 0]]],
            v_088 = arg3_092[2],
            res3_096 =
              [1, [0, _$_, [0, caml_call2(Core[472], Core[558], v_088), 0]]];
           return [1,
                   [0,
                    res0_093,
                    [0, res1_094, [0, res2_095, [0, res3_096, 0]]]]];
          },
        _aJ_ =
          caml_call5
           (Core_Info[19],
            _aa_,
            0,
            cst_child_process$0,
            [0,
             cst_stdin$0,
             [0, 5593163, pid],
             [0, -899758182, prog],
             [0, -1066103459, x_097]],
            _aI_),
        _aK_ = caml_call4(Async_unix_Fd[6], 0, 1, stdin, _aJ_),
        writer = caml_call7(Async_unix_Writer[18], 0, 0, 0, 0, 0, 0, _aK_),
        _aL_ =
          function(param){
           if(write_to_stdin){
            var write_to_stdin$0 = write_to_stdin[1];
            caml_call4(Async_unix_Writer[33], 0, 0, writer, write_to_stdin$0);
           }
           return caml_call1(Async_unix_Writer[57], writer);
          },
        let_syntax_083 = caml_call2(Async_unix_Writer[70], writer, _aL_),
        let_syntax_084 = caml_call1(Async_unix_Unix_syscalls[90], pid),
        _aM_ =
          function(param){
           var
            exit_status = param[2],
            ok = handle_exit_status(accept_nonzero_exit, exit_status);
           if(0 === ok[0]) return ok;
           var
            exit_status$0 = ok[1],
            _aO_ =
              [0,
               [1,
                [0, _ab_, [0, caml_call1(Core_unix[15][2], exit_status$0), 0]]],
               0],
            _aP_ =
              [0,
               [1,
                [0, _ac_, [0, caml_call2(Core[515], sexp_of_env, x_099), 0]]],
               _aO_],
            _aQ_ =
              [0,
               [1,
                [0,
                 _ad_,
                 [0, caml_call2(Core[515], Core[558], working_dir), 0]]],
               _aP_],
            _aR_ =
              [0,
               [1, [0, _ae_, [0, caml_call2(Core[472], Core[558], x_097), 0]]],
               _aQ_],
            _aS_ =
              [0, [1, [0, _af_, [0, caml_call1(Core[558], prog), 0]]], _aR_],
            _aT_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Process_run_forwarding_wit),
                _aS_]];
           return caml_call1(Core_Or_error[45], _aT_);
          },
        _aN_ =
          caml_call2(Async_unix_Import[33][4], let_syntax_083, let_syntax_084);
       return caml_call2(Async_unix_Import[33][3], _aN_, _aM_);
      }
      var exn = param[1];
      return caml_call2(Async_kernel_Deferred_or_error[22], 0, exn);
     }
     function _aG_(param){
      return caml_call11
              (Core_unix[124],
               working_dir,
               prog_search_path,
               argv0,
               0,
               x_099,
               prog,
               x_097,
               0,
               [0, Core_unix[43]],
               [0, Core_unix[44]],
               0);
     }
     var
      _aH_ =
        caml_call2(Async_unix_In_thread[6], cst_create_process_with_fds, _aG_);
     return caml_call2(Async_unix_Import[33][2], _aH_, _aF_);
    }
    var
     _aE_ =
       caml_call2(Async_unix_Import[33][4], let_syntax_080, let_syntax_081);
    return caml_call2(Async_unix_Import[33][2], _aE_, _aD_);
   }
   function run_forwarding(opt){
    if(opt)
     var sth = opt[1], child_fds = sth;
    else
     var child_fds = -197985892;
    return 256529599 <= child_fds
            ? run_forwarding_with_shared_fds
            : run_forwarding_with_spliced_fd;
   }
   function run_forwarding_exn(child_fds){
    var _am_ = Core[255], _an_ = run_forwarding(child_fds);
    return function(_ao_, _ap_, _aq_, _ar_, _as_, _at_, _au_, _av_, _aw_){
     return map_run
             (_an_,
              _am_,
              _ao_,
              _ap_,
              _aq_,
              _ar_,
              _as_,
              _at_,
              _au_,
              _av_,
              _aw_);};
   }
   function send_signal_internal(t, signal){
    if(caml_call1(Core_Lazy[40], t[9])){
     var _aj_ = t[9], _ak_ = caml_obj_tag(_aj_);
     a:
     if(250 === _ak_)
      var _al_ = _aj_[1];
     else{
      if(246 !== _ak_ && 244 !== _ak_){var _al_ = _aj_; break a;}
      var _al_ = caml_call1(CamlinternalLazy[2], _aj_);
     }
     if(caml_call1(Async_kernel_Deferred[7], _al_)) return 275217255;
    }
    return 17724 <= caml_call2(Signal_unix[4], signal, [0, 4001835, t[1]])
            ? 17724
            : 204897742;
   }
   function send_signal_compat(t, signal){
    return 204897742 <= send_signal_internal(t, signal) ? -658003819 : 17724;
   }
   function send_signal_compat_exn(t, signal){
    if(17724 <= send_signal_compat(t, signal)) return 0;
    var
     _ah_ = caml_call1(Core_Pid[15], t[1]),
     _ai_ = caml_call1(Core_Signal[42], signal);
    return caml_call4(Core[246], _ag_, _ai_, _ah_, 0);
   }
   function send_signal(t, signal){send_signal_compat(t, signal); return 0;}
   var Aliases = [0], For_tests = [0, send_signal_internal];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Process);
   var
    Async_unix_Process =
      [0,
       sexp_of_t,
       pid,
       stdin,
       stdout,
       stderr,
       sexp_of_env,
       env_of_sexp,
       create,
       create_exn,
       wait,
       [0, compare$0, sexp_of_t$2, Stable],
       collect_output_and_wait,
       run,
       run_exn,
       run_lines,
       run_lines_exn,
       run_expect_no_output,
       run_expect_no_output_exn,
       run_forwarding,
       run_forwarding_exn,
       collect_stdout_and_wait,
       collect_stdout_and_wait_exn,
       collect_stdout_lines_and_wait,
       collect_stdout_lines_and_wait_,
       forward_output_and_wait,
       forward_output_and_wait_exn,
       send_signal,
       send_signal_compat,
       send_signal_compat_exn,
       Lines_or_sexp,
       Aliases,
       For_tests];
   runtime.caml_register_global
    (105, Async_unix_Process, cst_Async_unix_Process$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Io_stats
//# unitInfo: Requires: Core__Int63, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv_record
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Io_stats$0 = "Async_unix__Io_stats",
    cst_async_unix$0 = "async_unix",
    cst_char$0 = "char",
    cst_fifo$0 = "fifo",
    cst_file$0 = "file",
    cst_socket$0 = "socket",
    cst_total$0 = "total",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_002 = "src/io_stats.ml.t",
    Core_Int63 = global_data.Core__Int63,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Io_stats$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/io_stats.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "io_stats.ml");
   var
    _a_ = [0, cst_socket$0],
    _b_ = [0, cst_file$0],
    _c_ = [0, cst_fifo$0],
    _d_ = [0, cst_char$0],
    _e_ = [0, cst_total$0],
    cst_socket = cst_socket$0,
    cst_file = cst_file$0,
    cst_fifo = cst_fifo$0,
    cst_char = cst_char$0,
    cst_total = cst_total$0,
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Io_stats = cst_Async_unix_Io_stats$0;
   function t_of_sexp(x_003){
    function _f_(param){
     var
      _i_ = param[2],
      _j_ = _i_[2],
      _k_ = _j_[2],
      socket = _k_[2][1],
      file = _k_[1],
      fifo = _j_[1],
      char$0 = _i_[1],
      total = param[1];
     return [0, total, char$0, fifo, file, socket];
    }
    var _g_ = 0;
    function _h_(param){
     return caml_string_notequal(param, cst_char$0)
             ? caml_string_notequal
                (param, cst_fifo$0)
               ? caml_string_notequal
                  (param, cst_file$0)
                 ? caml_string_notequal
                    (param, cst_socket$0)
                   ? caml_string_notequal(param, cst_total$0) ? -1 : 0
                   : 4
                 : 3
               : 2
             : 1;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_002,
             [0,
              cst_total,
              1,
              Core_Int63[102],
              [0,
               cst_char,
               1,
               Core_Int63[102],
               [0,
                cst_fifo,
                1,
                Core_Int63[102],
                [0,
                 cst_file,
                 1,
                 Core_Int63[102],
                 [0, cst_socket, 1, Core_Int63[102], 0]]]]],
             _h_,
             _g_,
             _f_,
             x_003);
   }
   function sexp_of_t(param){
    var
     total_005 = param[1],
     char_007 = param[2],
     fifo_009 = param[3],
     file_011 = param[4],
     socket_013 = param[5],
     arg_014 = caml_call1(Core_Int63[103], socket_013),
     bnds_004 = [0, [1, [0, _a_, [0, arg_014, 0]]], 0],
     arg_012 = caml_call1(Core_Int63[103], file_011),
     bnds_004$0 = [0, [1, [0, _b_, [0, arg_012, 0]]], bnds_004],
     arg_010 = caml_call1(Core_Int63[103], fifo_009),
     bnds_004$1 = [0, [1, [0, _c_, [0, arg_010, 0]]], bnds_004$0],
     arg_008 = caml_call1(Core_Int63[103], char_007),
     bnds_004$2 = [0, [1, [0, _d_, [0, arg_008, 0]]], bnds_004$1],
     arg_006 = caml_call1(Core_Int63[103], total_005),
     bnds_004$3 = [0, [1, [0, _e_, [0, arg_006, 0]]], bnds_004$2];
    return [1, bnds_004$3];
   }
   function create(param){
    return [0,
            Core_Int63[16],
            Core_Int63[16],
            Core_Int63[16],
            Core_Int63[16],
            Core_Int63[16]];
   }
   function update(t, kind, bytes){
    t[1] = caml_call2(Core_Int63[19], t[1], bytes);
    if(typeof kind === "number")
     switch(kind){
       case 0:
        t[2] = caml_call2(Core_Int63[19], t[2], bytes); return 0;
       case 1:
        t[3] = caml_call2(Core_Int63[19], t[3], bytes); return 0;
       default: t[4] = caml_call2(Core_Int63[19], t[4], bytes); return 0;
     }
    t[5] = caml_call2(Core_Int63[19], t[5], bytes);
    return 0;
   }
   function total(t){return t[1];}
   function get(t, kind){
    if(typeof kind === "number")
     switch(kind){
       case 0:
        return t[2];
       case 1:
        return t[3];
       default: return t[4];
     }
    return t[5];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Io_stats);
   var
    Async_unix_Io_stats =
      [0, t_of_sexp, sexp_of_t, create, update, total, get];
   runtime.caml_register_global
    (29, Async_unix_Io_stats, cst_Async_unix_Io_stats$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Async_print
//# unitInfo: Requires: Async_unix__Writer, CamlinternalLazy, Core, Core__Float, Core__Int, Core__Printf, Core__Sexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Async_print$0 = "Async_unix__Async_print",
    cst_async_unix$0 = "async_unix",
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Sexp = global_data.Core__Sexp,
    Core_Float = global_data.Core__Float,
    Core_Int = global_data.Core__Int,
    Async_unix_Writer = global_data.Async_unix__Writer,
    Core_Printf = global_data.Core__Printf,
    Core = global_data.Core,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Async_print$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_print.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "async_print.ml");
   var
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Async_print = cst_Async_unix_Async_print$0;
   function stdout(param){
    var _n_ = Async_unix_Writer[5], _o_ = caml_obj_tag(_n_);
    if(250 === _o_) return _n_[1];
    if(246 !== _o_ && 244 !== _o_) return _n_;
    return caml_call1(CamlinternalLazy[2], _n_);
   }
   function stderr(param){
    var _l_ = Async_unix_Writer[6], _m_ = caml_obj_tag(_l_);
    if(250 === _m_) return _l_[1];
    if(246 !== _m_ && 244 !== _m_) return _l_;
    return caml_call1(CamlinternalLazy[2], _l_);
   }
   function do_printf(writer){
    function _j_(s){
     var _k_ = caml_call1(writer, 0);
     return caml_call4(Async_unix_Writer[33], 0, 0, _k_, s);
    }
    return caml_call1(Core[254], _j_);
   }
   function printf(fmt){return caml_call1(do_printf(stdout), fmt);}
   function fprintf(writer, fmt){
    function _i_(s){
     return caml_call4(Async_unix_Writer[33], 0, 0, writer, s);
    }
    return caml_call2(Core_Printf[4], _i_, fmt);
   }
   function eprintf(fmt){return caml_call1(do_printf(stderr), fmt);}
   function print_char(c){
    var _h_ = stdout(0);
    return caml_call2(Async_unix_Writer[40], _h_, c);
   }
   function prerr_char(c){
    var _g_ = stderr(0);
    return caml_call2(Async_unix_Writer[40], _g_, c);
   }
   function print_string(s){
    var _f_ = stdout(0);
    return caml_call4(Async_unix_Writer[33], 0, 0, _f_, s);
   }
   function prerr_string(s){
    var _e_ = stderr(0);
    return caml_call4(Async_unix_Writer[33], 0, 0, _e_, s);
   }
   function print_newline(param){
    var _d_ = stdout(0);
    return caml_call2(Async_unix_Writer[40], _d_, 10);
   }
   function prerr_newline(param){
    var _c_ = stderr(0);
    return caml_call2(Async_unix_Writer[40], _c_, 10);
   }
   function print_endline(s){print_string(s); return print_newline(0);}
   function prerr_endline(s){prerr_string(s); return prerr_newline(0);}
   function print_int(i){return print_string(caml_call1(Core_Int[79], i));}
   function prerr_int(i){return prerr_string(caml_call1(Core_Int[79], i));}
   function print_float(f){
    return print_string(caml_call1(Core_Float[159], f));
   }
   function prerr_float(f){
    return prerr_string(caml_call1(Core_Float[159], f));
   }
   function print_s(mach, sexp){
    var
     _b_ =
       mach
        ? caml_call1(Core_Sexp[85], sexp)
        : caml_call2(Core_Sexp[84], 0, sexp);
    return print_endline(_b_);
   }
   function eprint_s(mach, sexp){
    var
     _a_ =
       mach
        ? caml_call1(Core_Sexp[85], sexp)
        : caml_call2(Core_Sexp[84], 0, sexp);
    return prerr_endline(_a_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Async_print);
   var
    Async_unix_Async_print =
      [0,
       print_char,
       prerr_char,
       print_string,
       prerr_string,
       print_int,
       prerr_int,
       print_float,
       prerr_float,
       print_endline,
       prerr_endline,
       print_newline,
       prerr_newline,
       print_s,
       printf,
       fprintf,
       eprintf,
       eprint_s];
   runtime.caml_register_global
    (18, Async_unix_Async_print, cst_Async_unix_Async_print$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix__Async_sys
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Pipe, Async_kernel__Time_source, Async_unix__Clock, Async_unix__Import, Async_unix__In_thread, Async_unix__Unix_syscalls, Core, Core__Core_sys, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sys_unix, Time_float_unix, Time_ns_unix
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix_Async_sys$0 = "Async_unix__Async_sys",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_unix_Clock = global_data.Async_unix__Clock,
    Async_unix_Import = global_data.Async_unix__Import,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_unix_Unix_syscalls = global_data.Async_unix__Unix_syscalls,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Time_float_unix = global_data.Time_float_unix,
    Time_ns_unix = global_data.Time_ns_unix,
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_unix_In_thread = global_data.Async_unix__In_thread,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Core_sys = global_data.Core__Core_sys,
    Sys_unix = global_data.Sys_unix;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix_Async_sys$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_sys.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "async_sys.ml");
   var
    argv = Core_Core_sys[2],
    get_argv = Core_Core_sys[1],
    executable_name = Sys_unix[1],
    _r_ = [0, "file"],
    cst_when_file_exists_can_not_c = "when_file_exists can not check file",
    _o_ = [0, 3804260],
    _p_ = [0, 523273847],
    _q_ = [0, 1],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix_Async_sys = cst_Async_unix_Async_sys$0;
   function wrap1(f, x1){
    function _ab_(param){return caml_call1(f, x1);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _ab_);
   }
   var _a_ = Sys_unix[14];
   function chdir(_aa_){return wrap1(_a_, _aa_);}
   var _b_ = Sys_unix[12];
   function command(_$_){return wrap1(_b_, _$_);}
   var _c_ = Sys_unix[13];
   function command_exn(___){return wrap1(_c_, ___);}
   var
    quote = Core_Core_sys[21],
    concat_quoted = Core_Core_sys[22],
    _d_ = Sys_unix[15];
   function getcwd(_Z_){return wrap1(_d_, _Z_);}
   var _e_ = Sys_unix[23];
   function home_directory(_Y_){return wrap1(_e_, _Y_);}
   var _f_ = Sys_unix[18];
   function ls_dir(_X_){return wrap1(_f_, _X_);}
   var _g_ = Sys_unix[16];
   function readdir(_W_){return wrap1(_g_, _W_);}
   var _h_ = Sys_unix[8];
   function remove(_V_){return wrap1(_h_, _V_);}
   var f = Sys_unix[9];
   function rename(x1, x2){
    function _U_(param){return caml_call2(f, x1, x2);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _U_);
   }
   function wrap_is(f, follow_symlinks, path){
    function _T_(param){return caml_call2(f, follow_symlinks, path);}
    return caml_call4(Async_unix_In_thread[5], 0, 0, 0, _T_);
   }
   var _i_ = Sys_unix[2];
   function file_exists(_R_, _S_){return wrap_is(_i_, _R_, _S_);}
   var _j_ = Sys_unix[3];
   function file_exists_exn(_P_, _Q_){return wrap_is(_j_, _P_, _Q_);}
   var _k_ = Sys_unix[4];
   function is_directory(_N_, _O_){return wrap_is(_k_, _N_, _O_);}
   var _l_ = Sys_unix[6];
   function is_directory_exn(_L_, _M_){return wrap_is(_l_, _L_, _M_);}
   var _m_ = Sys_unix[5];
   function is_file(_J_, _K_){return wrap_is(_m_, _J_, _K_);}
   var _n_ = Sys_unix[7];
   function is_file_exn(_H_, _I_){return wrap_is(_n_, _H_, _I_);}
   function when_file_changes(opt, _A_, file){
    if(opt)
     var sth = opt[1], time_source = sth;
    else
     var time_source = caml_call1(Async_kernel_Time_source[10], 0);
    if(_A_)
     var sth$0 = _A_[1], poll_delay = sth$0;
    else
     var poll_delay = caml_call1(Core[630], 0.5);
    var
     last_reported_mtime = [0, 0],
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     writer = match[2],
     reader = match[1];
    function loop(param){
     function _B_(stat_result){
      var _E_ = 1 - caml_call1(Async_kernel_Pipe[17], writer);
      if(! _E_) return _E_;
      if(0 === stat_result[0]){
       var
        st = stat_result[1],
        mtime = st[11],
        match = last_reported_mtime[1];
       if(match)
        var
         last_reported_mtime$0 = match[1],
         should_report =
           1 - caml_call2(Time_float_unix[70], mtime, last_reported_mtime$0);
       else
        var should_report = 1;
       if(should_report){
        last_reported_mtime[1] = [0, mtime];
        caml_call2(Async_kernel_Pipe[30], writer, [0, mtime]);
       }
      }
      else{
       var exn = stat_result[1];
       last_reported_mtime[1] = 0;
       caml_call2(Async_kernel_Pipe[30], writer, [1, exn]);
      }
      var
       _F_ = caml_call1(Time_ns_unix[72][146], poll_delay),
       _G_ = caml_call2(Async_kernel_Time_source[29], time_source, _F_);
      return caml_call2(Async_unix_Import[27], _G_, loop);
     }
     function _C_(param){
      return caml_call1(Async_unix_Unix_syscalls[34], file);
     }
     var
      _D_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _q_, _p_, _o_, _C_);
     return caml_call2(Async_unix_Import[27], _D_, _B_);
    }
    loop(0);
    return reader;
   }
   function when_file_exists(follow_symlinks, opt, file){
    if(opt)
     var sth = opt[1], poll_delay = sth;
    else
     var poll_delay = caml_call1(Core[630], 0.5);
    function _u_(i){
     function loop(param){
      function _v_(param){
       if(4448519 === param) return caml_call2(Async_kernel_Ivar[14], i, 0);
       if(785140586 <= param){
        var
         _x_ = [0, [1, [0, _r_, [0, caml_call1(Core[558], file), 0]]], 0],
         _y_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_when_file_exists_can_not_c),
             _x_]];
        return caml_call1(Core[261], _y_);
       }
       var _z_ = caml_call1(Async_unix_Clock[4], poll_delay);
       return caml_call2(Async_unix_Import[22], _z_, loop);
      }
      var _w_ = file_exists(follow_symlinks, file);
      return caml_call2(Async_unix_Import[27], _w_, _v_);
     }
     return loop(0);
    }
    return caml_call1(Async_kernel_Deferred[3], _u_);
   }
   function c_int_size(_t_){return runtime.c_int_size(_t_);}
   var
    execution_mode = Sys_unix[22],
    getenv = Core_Core_sys[19],
    getenv_exn = Core_Core_sys[20],
    int_size = Core_Core_sys[10],
    interactive = Core_Core_sys[3],
    ocaml_version = Core_Core_sys[16],
    os_type = Core_Core_sys[4],
    word_size = Core_Core_sys[9];
   function opaque_identity(_s_){return _s_;}
   var big_endian = Core_Core_sys[11];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix_Async_sys);
   var
    Async_unix_Async_sys =
      [0,
       argv,
       get_argv,
       executable_name,
       file_exists,
       file_exists_exn,
       when_file_exists,
       when_file_changes,
       is_directory,
       is_directory_exn,
       is_file,
       is_file_exn,
       remove,
       rename,
       getenv,
       getenv_exn,
       command,
       command_exn,
       quote,
       concat_quoted,
       chdir,
       getcwd,
       readdir,
       ls_dir,
       home_directory,
       opaque_identity,
       interactive,
       os_type,
       word_size,
       int_size,
       big_endian,
       ocaml_version,
       execution_mode,
       c_int_size];
   runtime.caml_register_global
    (33, Async_unix_Async_sys, cst_Async_unix_Async_sys$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_unix
//# unitInfo: Requires: Async_unix__Async_print, Async_unix__Clock, Async_unix__Scheduler, Async_unix__Shutdown, Async_unix__Unix_syscalls, Core__Printf, Core__Sexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_unix$0 = "Async_unix",
    cst_async_unix$0 = "async_unix";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Printf = global_data.Core__Printf,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_unix_Unix_syscalls = global_data.Async_unix__Unix_syscalls,
    Async_unix_Clock = global_data.Async_unix__Clock,
    Async_unix_Scheduler = global_data.Async_unix__Scheduler,
    Async_unix_Shutdown = global_data.Async_unix__Shutdown,
    Async_unix_Async_print = global_data.Async_unix__Async_print,
    Core_Sexp = global_data.Core__Sexp;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_unix$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_unix.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_unix$0, "async_unix.ml");
   var
    system = Async_unix_Unix_syscalls[1],
    system_exn = Async_unix_Unix_syscalls[2],
    getpid = Async_unix_Unix_syscalls[3],
    getppid = Async_unix_Unix_syscalls[4],
    getppid_exn = Async_unix_Unix_syscalls[5],
    this_process_became_child_of_i = Async_unix_Unix_syscalls[6],
    nice = Async_unix_Unix_syscalls[7],
    cores = Async_unix_Unix_syscalls[8],
    openfile = Async_unix_Unix_syscalls[9],
    Lock_mode = Async_unix_Unix_syscalls[10],
    Lock_mechanism = Async_unix_Unix_syscalls[11],
    Lock = Async_unix_Unix_syscalls[12],
    with_file = Async_unix_Unix_syscalls[13],
    fcntl_getfl = Async_unix_Unix_syscalls[14],
    fcntl_setfl = Async_unix_Unix_syscalls[15],
    close = Async_unix_Unix_syscalls[16],
    deregister = Async_unix_Unix_syscalls[17],
    lseek = Async_unix_Unix_syscalls[18],
    truncate = Async_unix_Unix_syscalls[19],
    ftruncate = Async_unix_Unix_syscalls[20],
    fsync = Async_unix_Unix_syscalls[21],
    fdatasync = Async_unix_Unix_syscalls[22],
    sync = Async_unix_Unix_syscalls[23],
    lockf = Async_unix_Unix_syscalls[24],
    try_lockf = Async_unix_Unix_syscalls[25],
    test_lockf = Async_unix_Unix_syscalls[26],
    unlockf = Async_unix_Unix_syscalls[27],
    flock = Async_unix_Unix_syscalls[28],
    try_flock = Async_unix_Unix_syscalls[29],
    funlock = Async_unix_Unix_syscalls[30],
    File_kind = Async_unix_Unix_syscalls[31],
    Stats = Async_unix_Unix_syscalls[32],
    fstat = Async_unix_Unix_syscalls[33],
    stat = Async_unix_Unix_syscalls[34],
    lstat = Async_unix_Unix_syscalls[35],
    isatty = Async_unix_Unix_syscalls[36],
    unlink = Async_unix_Unix_syscalls[37],
    remove = Async_unix_Unix_syscalls[38],
    rename = Async_unix_Unix_syscalls[39],
    link = Async_unix_Unix_syscalls[40],
    chmod = Async_unix_Unix_syscalls[41],
    fchmod = Async_unix_Unix_syscalls[42],
    chown = Async_unix_Unix_syscalls[43],
    fchown = Async_unix_Unix_syscalls[44],
    access = Async_unix_Unix_syscalls[45],
    access_exn = Async_unix_Unix_syscalls[46],
    set_close_on_exec = Async_unix_Unix_syscalls[47],
    clear_close_on_exec = Async_unix_Unix_syscalls[48],
    mkdir = Async_unix_Unix_syscalls[49],
    rmdir = Async_unix_Unix_syscalls[50],
    chdir = Async_unix_Unix_syscalls[51],
    getcwd = Async_unix_Unix_syscalls[52],
    chroot = Async_unix_Unix_syscalls[53],
    opendir = Async_unix_Unix_syscalls[54],
    readdir_opt = Async_unix_Unix_syscalls[55],
    rewinddir = Async_unix_Unix_syscalls[56],
    closedir = Async_unix_Unix_syscalls[57],
    pipe = Async_unix_Unix_syscalls[58],
    mkfifo = Async_unix_Unix_syscalls[59],
    symlink = Async_unix_Unix_syscalls[60],
    readlink = Async_unix_Unix_syscalls[61],
    mkstemp = Async_unix_Unix_syscalls[62],
    mkdtemp = Async_unix_Unix_syscalls[63],
    getgrouplist = Async_unix_Unix_syscalls[64],
    times = Async_unix_Unix_syscalls[65],
    time = Async_unix_Unix_syscalls[66],
    gettimeofday = Async_unix_Unix_syscalls[67],
    gmtime = Async_unix_Unix_syscalls[68],
    localtime = Async_unix_Unix_syscalls[69],
    mktime = Async_unix_Unix_syscalls[70],
    utimes = Async_unix_Unix_syscalls[71],
    sexp_of_env = Async_unix_Unix_syscalls[72],
    env_of_sexp = Async_unix_Unix_syscalls[73],
    environment = Async_unix_Unix_syscalls[74],
    getenv = Async_unix_Unix_syscalls[75],
    getenv_exn = Async_unix_Unix_syscalls[76],
    unsafe_getenv = Async_unix_Unix_syscalls[77],
    unsafe_getenv_exn = Async_unix_Unix_syscalls[78],
    putenv = Async_unix_Unix_syscalls[79],
    unsetenv = Async_unix_Unix_syscalls[80],
    fork_exec = Async_unix_Unix_syscalls[81],
    sexp_of_wait_on = Async_unix_Unix_syscalls[82],
    wait_on_of_sexp = Async_unix_Unix_syscalls[83],
    wait_on_of_sexp$0 = Async_unix_Unix_syscalls[84],
    wait = Async_unix_Unix_syscalls[85],
    wait_nohang = Async_unix_Unix_syscalls[86],
    wait_untraced = Async_unix_Unix_syscalls[87],
    wait_nohang_untraced = Async_unix_Unix_syscalls[88],
    waitpid = Async_unix_Unix_syscalls[89],
    waitpid_prompt = Async_unix_Unix_syscalls[90],
    waitpid_exn = Async_unix_Unix_syscalls[91],
    Inet_addr = Async_unix_Unix_syscalls[92],
    Protocol_family = Async_unix_Unix_syscalls[93],
    socketpair = Async_unix_Unix_syscalls[94],
    Socket = Async_unix_Unix_syscalls[95],
    bind_to_interface_exn = Async_unix_Unix_syscalls[96],
    Host = Async_unix_Unix_syscalls[97],
    bin_shape_socket_domain = Async_unix_Unix_syscalls[98],
    bin_size_socket_domain = Async_unix_Unix_syscalls[99],
    bin_write_socket_domain = Async_unix_Unix_syscalls[100],
    bin_writer_socket_domain = Async_unix_Unix_syscalls[101],
    bin_read_socket_domain = Async_unix_Unix_syscalls[102],
    bin_read_socket_domain$0 = Async_unix_Unix_syscalls[103],
    bin_reader_socket_domain = Async_unix_Unix_syscalls[104],
    bin_socket_domain = Async_unix_Unix_syscalls[105],
    compare_socket_domain = Async_unix_Unix_syscalls[106],
    hash_fold_socket_domain = Async_unix_Unix_syscalls[107],
    hash_socket_domain = Async_unix_Unix_syscalls[108],
    sexp_of_socket_domain = Async_unix_Unix_syscalls[109],
    socket_domain_of_sexp = Async_unix_Unix_syscalls[110],
    bin_shape_socket_type = Async_unix_Unix_syscalls[111],
    bin_size_socket_type = Async_unix_Unix_syscalls[112],
    bin_write_socket_type = Async_unix_Unix_syscalls[113],
    bin_writer_socket_type = Async_unix_Unix_syscalls[114],
    bin_read_socket_type = Async_unix_Unix_syscalls[115],
    bin_read_socket_type$0 = Async_unix_Unix_syscalls[116],
    bin_reader_socket_type = Async_unix_Unix_syscalls[117],
    bin_socket_type = Async_unix_Unix_syscalls[118],
    compare_socket_type = Async_unix_Unix_syscalls[119],
    hash_fold_socket_type = Async_unix_Unix_syscalls[120],
    hash_socket_type = Async_unix_Unix_syscalls[121],
    sexp_of_socket_type = Async_unix_Unix_syscalls[122],
    socket_type_of_sexp = Async_unix_Unix_syscalls[123],
    bin_shape_sockaddr = Async_unix_Unix_syscalls[124],
    bin_size_sockaddr = Async_unix_Unix_syscalls[125],
    bin_write_sockaddr = Async_unix_Unix_syscalls[126],
    bin_writer_sockaddr = Async_unix_Unix_syscalls[127],
    bin_read_sockaddr = Async_unix_Unix_syscalls[128],
    bin_read_sockaddr$0 = Async_unix_Unix_syscalls[129],
    bin_reader_sockaddr = Async_unix_Unix_syscalls[130],
    bin_sockaddr = Async_unix_Unix_syscalls[131],
    compare_sockaddr = Async_unix_Unix_syscalls[132],
    sexp_of_sockaddr = Async_unix_Unix_syscalls[133],
    bin_shape_sockaddr_blocking_se = Async_unix_Unix_syscalls[134],
    bin_size_sockaddr_blocking_sex = Async_unix_Unix_syscalls[135],
    bin_write_sockaddr_blocking_se = Async_unix_Unix_syscalls[136],
    bin_writer_sockaddr_blocking_s = Async_unix_Unix_syscalls[137],
    bin_read_sockaddr_blocking_sex = Async_unix_Unix_syscalls[138],
    bin_read_sockaddr_blocking_sex$0 = Async_unix_Unix_syscalls[139],
    bin_reader_sockaddr_blocking_s = Async_unix_Unix_syscalls[140],
    bin_sockaddr_blocking_sexp = Async_unix_Unix_syscalls[141],
    sexp_of_sockaddr_blocking_sexp = Async_unix_Unix_syscalls[142],
    sockaddr_blocking_sexp_of_sexp = Async_unix_Unix_syscalls[143],
    Addr_info = Async_unix_Unix_syscalls[144],
    Name_info = Async_unix_Unix_syscalls[145],
    gethostname = Async_unix_Unix_syscalls[146],
    getuid = Async_unix_Unix_syscalls[147],
    geteuid = Async_unix_Unix_syscalls[148],
    getgid = Async_unix_Unix_syscalls[149],
    getegid = Async_unix_Unix_syscalls[150],
    setuid = Async_unix_Unix_syscalls[151],
    setgid = Async_unix_Unix_syscalls[152],
    Unix_error = Async_unix_Unix_syscalls[153],
    Terminal_io = Async_unix_Unix_syscalls[154],
    Passwd = Async_unix_Unix_syscalls[155],
    Group = Async_unix_Unix_syscalls[156],
    getifaddrs = Async_unix_Unix_syscalls[157],
    username = Async_unix_Unix_syscalls[158],
    getlogin = Async_unix_Unix_syscalls[159],
    wordexp = Async_unix_Unix_syscalls[160],
    Private = Async_unix_Unix_syscalls[161],
    Unix =
      [0,
       system,
       system_exn,
       getpid,
       getppid,
       getppid_exn,
       this_process_became_child_of_i,
       nice,
       cores,
       openfile,
       Lock_mode,
       Lock_mechanism,
       Lock,
       with_file,
       fcntl_getfl,
       fcntl_setfl,
       close,
       deregister,
       lseek,
       truncate,
       ftruncate,
       fsync,
       fdatasync,
       sync,
       lockf,
       try_lockf,
       test_lockf,
       unlockf,
       flock,
       try_flock,
       funlock,
       File_kind,
       Stats,
       fstat,
       stat,
       lstat,
       isatty,
       unlink,
       remove,
       rename,
       link,
       chmod,
       fchmod,
       chown,
       fchown,
       access,
       access_exn,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir_opt,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       symlink,
       readlink,
       mkstemp,
       mkdtemp,
       getgrouplist,
       times,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       utimes,
       sexp_of_env,
       env_of_sexp,
       environment,
       getenv,
       getenv_exn,
       unsafe_getenv,
       unsafe_getenv_exn,
       putenv,
       unsetenv,
       fork_exec,
       sexp_of_wait_on,
       wait_on_of_sexp,
       wait_on_of_sexp$0,
       wait,
       wait_nohang,
       wait_untraced,
       wait_nohang_untraced,
       waitpid,
       waitpid_prompt,
       waitpid_exn,
       Inet_addr,
       Protocol_family,
       socketpair,
       Socket,
       bind_to_interface_exn,
       Host,
       bin_shape_socket_domain,
       bin_size_socket_domain,
       bin_write_socket_domain,
       bin_writer_socket_domain,
       bin_read_socket_domain,
       bin_read_socket_domain$0,
       bin_reader_socket_domain,
       bin_socket_domain,
       compare_socket_domain,
       hash_fold_socket_domain,
       hash_socket_domain,
       sexp_of_socket_domain,
       socket_domain_of_sexp,
       bin_shape_socket_type,
       bin_size_socket_type,
       bin_write_socket_type,
       bin_writer_socket_type,
       bin_read_socket_type,
       bin_read_socket_type$0,
       bin_reader_socket_type,
       bin_socket_type,
       compare_socket_type,
       hash_fold_socket_type,
       hash_socket_type,
       sexp_of_socket_type,
       socket_type_of_sexp,
       bin_shape_sockaddr,
       bin_size_sockaddr,
       bin_write_sockaddr,
       bin_writer_sockaddr,
       bin_read_sockaddr,
       bin_read_sockaddr$0,
       bin_reader_sockaddr,
       bin_sockaddr,
       compare_sockaddr,
       sexp_of_sockaddr,
       bin_shape_sockaddr_blocking_se,
       bin_size_sockaddr_blocking_sex,
       bin_write_sockaddr_blocking_se,
       bin_writer_sockaddr_blocking_s,
       bin_read_sockaddr_blocking_sex,
       bin_read_sockaddr_blocking_sex$0,
       bin_reader_sockaddr_blocking_s,
       bin_sockaddr_blocking_sexp,
       sexp_of_sockaddr_blocking_sexp,
       sockaddr_blocking_sexp_of_sexp,
       Addr_info,
       Name_info,
       gethostname,
       getuid,
       geteuid,
       getgid,
       getegid,
       setuid,
       setgid,
       Unix_error,
       Terminal_io,
       Passwd,
       Group,
       getifaddrs,
       username,
       getlogin,
       wordexp,
       Private],
    after = Async_unix_Clock[4],
    at = Async_unix_Clock[3],
    every = Async_unix_Clock[11],
    with_timeout = Async_unix_Clock[5],
    schedule = Async_unix_Scheduler[10],
    schedule$0 = Async_unix_Scheduler[9],
    shutdown = Async_unix_Shutdown[1],
    within = Async_unix_Scheduler[5],
    within$0 = Async_unix_Scheduler[4],
    bprintf = Core_Printf[3],
    failwithf = Core_Printf[6],
    cst_async_unix = cst_async_unix$0,
    cst_Async_unix = cst_Async_unix$0,
    shadow = 382630979;
   function fprintf(param){return shadow;}
   function ifprintf(param){return Core_Printf[1];}
   var invalid_argf = Core_Printf[7], kbprintf = Core_Printf[5];
   function kfprintf(param, _c_){return shadow;}
   var
    ksprintf = Core_Printf[4],
    sprintf = Core_Printf[2],
    Printf =
      [0,
       shadow,
       bprintf,
       shadow,
       shadow,
       failwithf,
       fprintf,
       ifprintf,
       invalid_argf,
       kbprintf,
       kfprintf,
       ksprintf,
       shadow,
       sprintf];
   function overwrite1(x){return x;}
   function overwrite2(param){return overwrite1;}
   function overwrite3(param){return overwrite2;}
   function overwrite4(param){return overwrite3;}
   var
    Overwrite = [0, overwrite1, overwrite2, overwrite3, overwrite4],
    close_in_noerr = Overwrite[1],
    close_in = Overwrite[1],
    close_out_noerr = Overwrite[1],
    close_out = Overwrite[1],
    eprintf = Async_unix_Async_print[16],
    flush_all = Overwrite[1],
    flush = Overwrite[1],
    fprintf$0 = Async_unix_Async_print[15],
    ifprintf$0 = Core_Printf[1],
    in_channel_length = Overwrite[1],
    input_binary_int = Overwrite[1],
    input_byte = Overwrite[1],
    input_char = Overwrite[1],
    input_line = Overwrite[1];
   function input_lines(param){return Overwrite[1];}
   var
    input = Overwrite[4],
    input_value = Overwrite[1],
    open_in_bin = Overwrite[1],
    open_in_gen = Overwrite[3],
    open_in = Overwrite[1],
    open_out_bin = Overwrite[1],
    open_out_gen = Overwrite[3],
    open_out = Overwrite[1],
    out_channel_length = Overwrite[1],
    output_binary_int = Overwrite[2],
    output_byte = Overwrite[2],
    output_char = Overwrite[2],
    output = Overwrite[4],
    output_string = Overwrite[2],
    output_value = Overwrite[2],
    pos_in = Overwrite[1],
    pos_out = Overwrite[1],
    prerr_char = Async_unix_Async_print[2],
    prerr_endline = Async_unix_Async_print[10],
    prerr_float = Async_unix_Async_print[8],
    prerr_int = Async_unix_Async_print[6],
    prerr_newline = Async_unix_Async_print[12],
    prerr_string = Async_unix_Async_print[4],
    print_char = Async_unix_Async_print[1],
    print_endline = Async_unix_Async_print[9],
    print_float = Async_unix_Async_print[7],
    printf = Async_unix_Async_print[14],
    print_int = Async_unix_Async_print[5],
    print_newline = Async_unix_Async_print[11],
    print_s = Async_unix_Async_print[13],
    print_string = Async_unix_Async_print[3],
    read_float = Overwrite[1],
    read_int = Overwrite[1],
    read_line = Overwrite[1],
    read_lines = Overwrite[1];
   function read_wrap(param, _b_){return Overwrite[1];}
   var
    really_input = Overwrite[4],
    seek_in = Overwrite[2],
    seek_out = Overwrite[1],
    set_binary_mode_in = Overwrite[2],
    set_binary_mode_out = Overwrite[2],
    write_lines = Overwrite[2];
   function write_wrap(param, _a_){return Overwrite[1];}
   var
    eprint_s = Overwrite[1],
    eprint_s_nonblocking = Async_unix_Async_print[17],
    seek_out$0 = Overwrite[1],
    pos_out$0 = Overwrite[1],
    out_channel_length$0 = Overwrite[1],
    seek_in$0 = Overwrite[1],
    pos_in$0 = Overwrite[1],
    in_channel_length$0 = Overwrite[1],
    LargeFile =
      [0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0],
    Sexp =
      [0,
       Core_Sexp[1],
       Core_Sexp[2],
       Core_Sexp[3],
       Core_Sexp[4],
       Core_Sexp[5],
       Core_Sexp[6],
       Core_Sexp[7],
       Core_Sexp[8],
       Core_Sexp[9],
       Core_Sexp[10],
       Core_Sexp[11],
       Core_Sexp[12],
       Core_Sexp[13],
       Core_Sexp[15],
       Core_Sexp[16],
       Core_Sexp[17],
       Core_Sexp[18],
       Core_Sexp[19],
       Core_Sexp[20],
       Core_Sexp[21],
       Core_Sexp[22],
       Core_Sexp[23],
       Core_Sexp[24],
       Core_Sexp[25],
       Core_Sexp[26],
       Core_Sexp[27],
       Core_Sexp[28],
       Core_Sexp[29],
       Core_Sexp[30],
       Core_Sexp[31],
       Core_Sexp[35],
       Core_Sexp[36],
       Core_Sexp[37],
       Core_Sexp[38],
       Core_Sexp[39],
       Core_Sexp[40],
       Core_Sexp[41],
       Core_Sexp[42],
       Core_Sexp[43],
       Core_Sexp[44],
       Core_Sexp[45],
       Core_Sexp[46],
       Core_Sexp[47],
       Core_Sexp[48],
       Core_Sexp[49],
       Core_Sexp[50],
       Core_Sexp[51],
       Core_Sexp[52],
       Core_Sexp[53],
       Core_Sexp[54],
       Core_Sexp[55],
       Core_Sexp[56],
       Core_Sexp[57],
       Core_Sexp[58],
       Core_Sexp[59],
       Core_Sexp[60],
       Core_Sexp[61],
       Core_Sexp[62],
       Core_Sexp[63],
       Core_Sexp[64],
       Core_Sexp[65],
       Core_Sexp[72],
       Core_Sexp[73],
       Core_Sexp[74],
       Core_Sexp[75],
       Core_Sexp[76],
       Core_Sexp[77],
       Core_Sexp[78],
       Core_Sexp[79],
       Core_Sexp[80],
       Core_Sexp[81],
       Core_Sexp[82],
       Core_Sexp[83],
       Core_Sexp[84],
       Core_Sexp[85],
       Core_Sexp[86],
       Core_Sexp[87],
       Core_Sexp[88],
       Core_Sexp[89],
       Core_Sexp[90],
       Core_Sexp[91],
       Core_Sexp[92],
       Core_Sexp[93],
       Core_Sexp[94],
       Core_Sexp[95],
       Core_Sexp[96],
       Core_Sexp[97],
       Core_Sexp[98],
       Core_Sexp[99],
       Core_Sexp[100],
       Core_Sexp[101],
       Core_Sexp[102],
       Core_Sexp[103],
       Core_Sexp[104],
       Core_Sexp[105],
       Core_Sexp[106],
       Core_Sexp[107],
       Core_Sexp[108],
       Core_Sexp[109],
       Core_Sexp[110],
       Core_Sexp[113],
       Core_Sexp[68],
       Core_Sexp[66],
       Core_Sexp[67],
       Core_Sexp[71],
       Core_Sexp[69],
       Core_Sexp[70]],
    exit = Async_unix_Shutdown[4],
    Async_unix_private = [0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_unix);
   var
    Async_unix =
      [0,
       Unix,
       after,
       at,
       every,
       with_timeout,
       schedule,
       schedule$0,
       shutdown,
       within,
       within$0,
       Printf,
       Overwrite,
       close_in_noerr,
       close_in,
       close_out_noerr,
       close_out,
       eprintf,
       flush_all,
       flush,
       fprintf$0,
       ifprintf$0,
       in_channel_length,
       input_binary_int,
       input_byte,
       input_char,
       input_line,
       input_lines,
       input,
       input_value,
       open_in_bin,
       open_in_gen,
       open_in,
       open_out_bin,
       open_out_gen,
       open_out,
       out_channel_length,
       output_binary_int,
       output_byte,
       output_char,
       output,
       output_string,
       output_value,
       pos_in,
       pos_out,
       prerr_char,
       prerr_endline,
       prerr_float,
       prerr_int,
       prerr_newline,
       prerr_string,
       print_char,
       print_endline,
       print_float,
       printf,
       print_int,
       print_newline,
       print_s,
       print_string,
       read_float,
       read_int,
       read_line,
       read_lines,
       read_wrap,
       really_input,
       seek_in,
       seek_out,
       set_binary_mode_in,
       set_binary_mode_out,
       write_lines,
       write_wrap,
       eprint_s,
       eprint_s_nonblocking,
       LargeFile,
       Sexp,
       exit,
       Async_unix_private];
   runtime.caml_register_global(18, Async_unix, cst_Async_unix$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhc3luY191bml4LmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJmaWxlX2Rlc2NyX3dhdGNoZXIkMCIsIm1heF9udW1fb3Blbl9maWxlX2Rlc2NycyQwIiwiaW50NjQiLCJwb2xsIiwidCIsImtpbmQiLCJwb2xsJDAiLCJkZWFkbGluZSIsImtpbmQkMCIsInBvbGwkMSIsInBvbGxlciIsIlAiLCJjcmVhdGUiLCJpbXBsIiwiY3JlYXRlJDAiLCJmIiwiZW1wdHkiLCJwcmludF9zIiwic2V4cCIsImFtX3Rlc3RfcnVubmVyIiwidG9vX21hbnlfdHJpZXMiLCJ0b29fbWFueV90cmllc19lcnJvciIsInN5c2NhbGwiLCJuIiwieCIsImV4biQwIiwiZXhuIiwibiQwIiwiaXNfZWludHIiLCJyIiwic3lzY2FsbF9yZXN1bHQiLCJhIiwic3lzY2FsbF9yZXN1bHQyIiwiYiIsImRlYnVnIiwic2V4cF9vZl90IiwiYXJnMF8wMDEiLCJyZXMwXzAwMiIsInNleHBfb2ZfdCQwIiwiYXJnMF8wMDMiLCJyZXMwXzAwNSIsInJlczFfMDA2IiwiYXJnMF8wMDciLCJyZXMwXzAwOCIsInRyYW5zaXRpb25faXNfYWxsb3dlZCIsInQkMCIsImlzX29wZW4iLCJzZXhwX29mX3JlYWR5X3RvX3Jlc3VsdCIsInNleHBfb2ZfdCQxIiwiYXJnMF8wMDkiLCJyZXMwXzAxMCIsImFyZzFfMDEyIiwiYXJnMF8wMTEiLCJyZXMwXzAxMyIsInJlczFfMDE0IiwiaW52YXJpYW50IiwiaXZhciIsIml2YXIkMCIsInNleHBfb2ZfdCQyIiwiY2xvc2VfZmluaXNoZWQiLCJudW1fYWN0aXZlX3N5c2NhbGxzIiwic2V0X251bV9hY3RpdmVfc3lzY2FsbHMiLCJ2Iiwid2F0Y2hpbmdfaGFzX2NoYW5nZWQiLCJzZXRfd2F0Y2hpbmdfaGFzX2NoYW5nZWQiLCJ3YXRjaGluZyIsInN0YXRlIiwic2V0X3N0YXRlIiwibm9uYmxvY2tfc3RhdHVzIiwic2V0X25vbmJsb2NrX3N0YXR1cyIsImNhbl9zZXRfbm9uYmxvY2siLCJzZXRfY2FuX3NldF9ub25ibG9jayIsInNldF9raW5kIiwiaW5mbyIsInNldF9pbmZvIiwiZmlsZV9kZXNjciIsImNsb3NlX2ZpbmlzaGVkJDAiLCJudW1fYWN0aXZlX3N5c2NhbGxzJDAiLCJ3YXRjaGluZ19oYXNfY2hhbmdlZCQwIiwid2F0Y2hpbmckMCIsInN0YXRlJDAiLCJub25ibG9ja19zdGF0dXMkMCIsImNhbl9zZXRfbm9uYmxvY2skMCIsImluZm8kMCIsImZpbGVfZGVzY3IkMCIsIml0ZXIiLCJmaWxlX2Rlc2NyX2Z1biIsImluZm9fZnVuIiwia2luZF9mdW4iLCJjYW5fc2V0X25vbmJsb2NrX2Z1biIsIm5vbmJsb2NrX3N0YXR1c19mdW4iLCJzdGF0ZV9mdW4iLCJ3YXRjaGluZ19mdW4iLCJ3YXRjaGluZ19oYXNfY2hhbmdlZF9mdW4iLCJudW1fYWN0aXZlX3N5c2NhbGxzX2Z1biIsImNsb3NlX2ZpbmlzaGVkX2Z1biIsInNleHBfb2ZfdCQzIiwiZmlsZV9kZXNjcl8wMTYiLCJpbmZvXzAxOCIsImtpbmRfMDIwIiwiY2FuX3NldF9ub25ibG9ja18wMjIiLCJub25ibG9ja19zdGF0dXNfMDI0Iiwic3RhdGVfMDI2Iiwid2F0Y2hpbmdfMDI4Iiwid2F0Y2hpbmdfaGFzX2NoYW5nZWRfMDMwIiwibnVtX2FjdGl2ZV9zeXNjYWxsc18wMzIiLCJjbG9zZV9maW5pc2hlZF8wMzQiLCJhcmdfMDM1IiwiYm5kc18wMTUiLCJhcmdfMDMzIiwiYm5kc18wMTUkMCIsImFyZ18wMzEiLCJibmRzXzAxNSQxIiwiYXJnXzAyOSIsImJuZHNfMDE1JDIiLCJhcmdfMDI3IiwiYm5kc18wMTUkMyIsImFyZ18wMjUiLCJibmRzXzAxNSQ0IiwiYXJnXzAyMyIsImJuZHNfMDE1JDUiLCJhcmdfMDIxIiwiYm5kc18wMTUkNiIsImFyZ18wMTkiLCJibmRzXzAxNSQ3IiwiYXJnXzAxNyIsImJuZHNfMDE1JDgiLCJzZXhwX29mX3RfaHVtIiwiY2xvc2VfZmluaXNoZWQkMSIsIm51bV9hY3RpdmVfc3lzY2FsbHMkMSIsInNldF9udW1fYWN0aXZlX3N5c2NhbGxzJDAiLCJ3YXRjaGluZ19oYXNfY2hhbmdlZCQxIiwic2V0X3dhdGNoaW5nX2hhc19jaGFuZ2VkJDAiLCJ3YXRjaGluZyQxIiwic3RhdGUkMSIsIm5vbmJsb2NrX3N0YXR1cyQxIiwic2V0X25vbmJsb2NrX3N0YXR1cyQwIiwiY2FuX3NldF9ub25ibG9jayQxIiwic2V0X2Nhbl9zZXRfbm9uYmxvY2skMCIsImtpbmQkMSIsInNldF9raW5kJDAiLCJpbmZvJDEiLCJzZXRfaW5mbyQwIiwiZmlsZV9kZXNjciQxIiwic2V4cF9vZl90JDQiLCJzZXhwX29mX3RfaHVtJDAiLCJlcXVhbCIsImludmFyaWFudCQwIiwiY2hlY2siLCJmaWVsZCIsImNsb3NlX3N0YXJ0ZWQiLCJyZWFkX29yX3dyaXRlIiwidG9faW50Iiwib3B0Iiwic3RoIiwiYXZvaWRfc2V0dGluZ19ub25ibG9jayIsImluY19udW1fYWN0aXZlX3N5c2NhbGxzIiwic2V0X3N0YXRlJDAiLCJuZXdfc3RhdGUiLCJhcmcxXzAzNyIsImFyZzBfMDM2IiwicmVzMF8wMzgiLCJyZXMxXzAzOSIsImlzX29wZW4kMCIsImlzX2Nsb3NlZCIsImRldGVybWluZV9ub25ibG9ja19zdGF0dXMiLCJmbGFncyIsIm5vbmJsb2NrIiwic3VwcG9ydHNfbm9uYmxvY2siLCJzZXRfbm9uYmxvY2tfaWZfbmVjZXNzYXJ5Iiwibm9uYmxvY2tpbmciLCJ3aXRoX2ZpbGVfZGVzY3JfZXhuIiwid2l0aF9maWxlX2Rlc2NyIiwic3lzY2FsbF9leG4iLCJzeXNjYWxsX3Jlc3VsdF9leG4iLCJjYXBhY2l0eSIsIm51bV9maWxlX2Rlc2NycyIsImJvdW5kc19jaGVjayIsImkiLCJib3VuZHNfY2hlY2tfZXJyb3IiLCJib3VuZHNfY2hlY2tfZXhuIiwibWVtIiwiZmluZCIsImZpbmRfZXhuIiwicmVtb3ZlIiwiZmQiLCJhZGQiLCJmb2xkIiwiaW5pdCIsImV4aXN0cyIsInNleHBfb2YiLCJhY2MiLCJmZF9hbGlzdCIsInhfMDA1IiwiYXJnMV8wMDIiLCJyZXMwXzAwMyIsInJlczFfMDA0IiwieF8wMDYiLCJydW5fYXQiLCJ0aW1lIiwicnVuX2FmdGVyIiwic3BhbiIsImF0IiwiYWZ0ZXIiLCJ3aXRoX3RpbWVvdXQiLCJkIiwid2l0aF90aW1lb3V0X2V4biIsImVycm9yIiwic2V4cF9vZl90X3VuaXQiLCJhYm9ydCIsImFib3J0X2V4biIsImFib3J0X2lmX3Bvc3NpYmxlIiwiZmlyZWQiLCJzY2hlZHVsZWRfYXQiLCJhdCQwIiwiYWZ0ZXIkMCIsInJlc2NoZWR1bGVfYXQiLCJyZXNjaGVkdWxlX2FmdGVyIiwicnVuX2F0JDAiLCJydW5fYWZ0ZXIkMCIsIm9mX2FfMDA0Iiwib2ZfaF8wMDUiLCJhcmcwXzAwNiIsInJlczBfMDA3IiwiYXJnMF8wMDgiLCJyZXMwXzAwOSIsImFyZzBfMDEwIiwicmVzMF8wMTEiLCJzdGF0dXMiLCJoIiwiYXRfdmFyeWluZ19pbnRlcnZhbHMiLCJzdG9wIiwiYXRfaW50ZXJ2YWxzIiwic3RhcnQiLCJzdGFydCQwIiwiZXZlcnkiLCJjb250aW51ZV9vbl9lcnJvciIsImZpbmlzaGVkIiwiZXZlcnkkMCIsInJ1bl9hdF9pbnRlcnZhbHMiLCJydW5fYXRfaW50ZXJ2YWxzJDAiLCJkdXJhdGlvbl9vZiIsInJlcyIsImNob29zZV9kdW1wX3R5cGUiLCJzdGFydF93YXRjaGluZyIsImR1bXBfaWZfZGVsYXllZF9ieSIsImhvd190b19kdW1wIiwiZHVtcF90eXBlIiwiZHVtcF9pZl9kZWxheWVkX2J5X3NlYyIsInRpY2tfaW50ZXJ2YWwiLCJkdW1wX2NvcmUiLCJ2YXJpYW50X29mIiwic3Bhbl9vcl91bml0IiwicG9zIiwib2siLCJ0aW1lb3V0IiwiaW5fb3V0IiwiZm9yX3RpbWVyZmQiLCJlcG9sbF8wMDQiLCJ0aW1lcmZkXzAwMiIsImJuZHNfMDAxIiwiYXJnXzAwOSIsImJuZHNfMDAxJDAiLCJhcmdfMDA3IiwiYm5kc18wMDEkMSIsImFyZ18wMDUiLCJibmRzXzAwMSQyIiwiYXJnXzAwMyIsImJuZHNfMDAxJDMiLCJlcG9sbCIsInRpbWVyZmQiLCJlcG9sbCQwIiwidGltZXJmZCQwIiwiYmFja2VuZCIsImZsYWdzJDAiLCJnb3QiLCJleHBlY3QiLCJtZXNzYWdlIiwiaGVyZSIsInNleHBpZmllciIsInhfMDE0IiwiY29tcGFyYXRvciIsImFfMDEwIiwiYl8wMTEiLCJhXzAxMiIsImJfMDEzIiwiaGFuZGxlX2ZkX3JlYWRfcmVhZHkiLCJoYW5kbGVfZmRfd3JpdGVfcmVhZHkiLCJlcnJfb3JfaHVwIiwiaGFuZGxlX2ZkIiwiYml0IiwicmVzZXRfaW5fZm9ya2VkX3Byb2Nlc3MiLCJzZXQiLCJkZXNpcmVkIiwiYWN0dWFsX2ZsYWdzIiwiZGVzaXJlZF9mbGFncyIsImQkMCIsInByZV9jaGVjayIsInhfMDE5IiwiYXJnMV8wMTYiLCJhcmcwXzAxNSIsInJlczBfMDE3IiwicmVzMV8wMTgiLCJ0aHJlYWRfc2FmZV9jaGVjayIsInRpbWVvdXQkMCIsImUkMCIsImUiLCJwb3N0X2NoZWNrIiwiY2hlY2tfcmVzdWx0IiwiYmFja3RyYWNlJDAiLCJiYWNrdHJhY2UiLCJwaXBlXzAwMiIsImFscmVhZHlfaW50ZXJydXB0ZWRfMDA0IiwiY2xlYXJidWZmZXJfMDA2IiwicmVhZF9mZCIsImNyZWF0ZV9mZCIsInBpcGVfd3JpdGUiLCJwaXBlX3JlYWQiLCJwaXBlX3JlYWQkMCIsInBpcGVfd3JpdGUkMCIsImJ5dGVzX3ciLCJ0aHJlYWRfc2FmZV9pbnRlcnJ1cHQiLCJjbGVhciIsInJlYWRfYWdhaW4iLCJhbHJlYWR5X2ludGVycnVwdGVkIiwib2ZfaW50Iiwib2ZfaW50JDAiLCJzeW1ib2wiLCJwb2xsaW4iLCJwb2xsb3V0IiwicG9sbGVyciIsInBvbGxodXAiLCJjb21wcmVzc2VkIiwiaW1tdXRhYmxlIiwiYXBwZW5kIiwibm9kdW1wIiwiZW5jcnlwdGVkIiwidmVyaXR5IiwiZGF4IiwidHlwZSIsIm1vZGUiLCJubGluayIsInVpZCIsImdpZCIsImF0aW1lIiwibXRpbWUiLCJjdGltZSIsImlubyIsInNpemUiLCJibG9ja3MiLCJiYXNpY19zdGF0cyIsImJ0aW1lIiwibW50X2lkIiwiZGlvYWxpZ24iLCJjaGVjayQwIiwiYmxrc2l6ZSIsImF0dHJpYnV0ZXMiLCJubGluayQwIiwidWlkJDAiLCJnaWQkMCIsImlubyQwIiwic2l6ZSQwIiwiYmxvY2tzJDAiLCJhdHRyaWJ1dGVzX21hc2siLCJyZGV2IiwiZGV2IiwibWFzayIsIm1udF9pZCQwIiwiZGlvX21lbV9hbGlnbiIsImRpb19vZmZzZXRfYWxpZ24iLCJhdGltZV9zZWMiLCJidGltZV9zZWMiLCJjdGltZV9zZWMiLCJtdGltZV9zZWMiLCJhdGltZV9uc2VjIiwiYnRpbWVfbnNlYyIsImN0aW1lX25zZWMiLCJtdGltZV9uc2VjIiwibW9kZSQwIiwicGVybSIsInhfMDAxIiwiZXhpdCIsInN1cHBvcnRzX2V4dF9hcmciLCJzdWJtaXQiLCJjcWVfcmVhZHkiLCJmaWxsX2NvbXBsZXRpb25zIiwibm9vcCIsInJlYWQiLCJ3cml0ZSIsInJlYWR2Iiwid3JpdGV2IiwicG9sbF9hZGQiLCJvcGVuYXQyIiwiY2xvc2UiLCJ1bmxpbmsiLCJsaW5rIiwic3RhdHgiLCJjYW5jZWwiLCJyZWdpc3Rlcl9ldmVudGZkIiwic3RhdGVzXzAwNCIsInVyaW5nXzAwMiIsInN0YXRlcyIsInN0YXRlcyQwIiwidXJpbmciLCJhZGRfcG9sbCIsImhhbmRsZSIsInJ1bm5pbmdfam9iIiwicmVzJDAiLCJlcnIiLCJyZW1vdmVfcG9sbF9leG4iLCJyZWFkeSIsImRlc2NyX3RhYmxlc18wMDIiLCJhcmdfMDExIiwiYm5kc18wMDEkNCIsImhhbmRsZV9mZF9yZWFkX2JhZCIsImhhbmRsZV9mZF93cml0ZV9iYWQiLCJ0YWJsZSIsImtleSIsInhfMDEyIiwic2VsZWN0X3Jlc3VsdF8wMTYiLCJwcmVfMDE0IiwiYm5kc18wMTMiLCJhcmdfMDE1IiwiYm5kc18wMTMkMCIsInByZSIsInNlbGVjdF9yZXN1bHQiLCJleGNlcHQiLCJiYWQiLCJmZHMiLCJhYyIsImRlbGl2ZXJlZF8wMDQiLCJvcmlnaW5hbF9kaXNwb3NpdGlvbnNfb2ZfbWFuYWciLCJ0aHJlYWRfc2FmZV9ub3RpZnlfc2lnbmFsX2RlbGkiLCJpc19tYW5hZ2luZyIsInNpZ25hbCIsIm1hbmFnZSIsIml0ZXJfZGVsaXZlcmVkIiwib3JpZ2luYWxfZGlzcG9zaXRpb24iLCJyZXMwXzAxMiIsInRvZG8iLCJhdF9zaHV0ZG93biIsInNodXR0aW5nX2Rvd25fcmVmIiwiZGVmYXVsdF9mb3JjZV9yZWYiLCJkZWZhdWx0X2ZvcmNlIiwic2V0X2RlZmF1bHRfZm9yY2UiLCJmb3JjZSIsInNodXR0aW5nX2Rvd24iLCJpc19zaHV0dGluZ19kb3duIiwiaWdub3JlX2V4biIsImV4aXRfcmVsaWFibHkiLCJjb2RlIiwic2h1dGRvd25fd2l0aF9zdGF0dXMiLCJyZXN1bHRzIiwic3RhdHVzJDAiLCJyZXN1bHQiLCJhcmcxXzAxNSIsImFyZzBfMDE0IiwicmVzMF8wMTYiLCJyZXMxXzAxNyIsImZvcmNlJDAiLCJwcmlvciIsImFfMDAzIiwiYl8wMDQiLCJhXzAwNSIsImJfMDA2Iiwic2h1dGRvd24iLCJleGl0X2NvZGUiLCJzaHV0ZG93bl93aXRoX3NpZ25hbF9leG4iLCJkZWZhdWx0X3N5c19iZWhhdmlvciIsInNodXRkb3duX29uX3VuaGFuZGxlZF9leG4iLCJwcm9jZWVkX3dpdGhfc2h1dGRvd24iLCJudW1fd2FpdGluZyIsImRvbl90X2ZpbmlzaF9iZWZvcmUiLCJiYWdfMDAyIiwiZ2V0X2hhbmRsZXJzIiwic2lnbmFsX2Rpc3BhdGNoZXJfMDEwIiwicmF3X3NpZ25hbF9tYW5hZ2VyXzAwOCIsImhhbmRsZXJzX2J5X3NpZ25hbF8wMDUiLCJhcmdfMDA2IiwiYm5kc18wMDQiLCJibmRzXzAwNyIsImJuZHNfMDA3JDAiLCJzZXRfY29tcG9zYWJsZV9oYW5kbGVyIiwic2lnbmFscyIsIm1hbmFnZV9idXRfa2VlcF9kZWZhdWx0X2JlaGF2aSIsImluc3RhbGxfaGFuZGxlciIsImhhbmRsZXIiLCJoYW5kbGVycyIsInJlbW92ZV9oYW5kbGVyIiwiaGFuZGxlciQwIiwiaGFuZGxlcl9lbHQiLCJoYW5kbGVfZGVsaXZlcmVkIiwidGV4dCIsIm51bV93b3JrX2NvbXBsZXRlZF8wMDgiLCJzdHVja19zaW5jZV8wMDYiLCJibmRzXzAwNSIsImJuZHNfMDA1JDAiLCJzZXhwX29mX3N0YXJ0X3R5cGUiLCJhY3RpdmVfMDExIiwiYXJnXzAxMiIsImJuZHNfMDEwIiwiaW5pdGlhbGl6ZWRfYXQiLCJtaW5faW50ZXJfY3ljbGVfdGltZW91dCIsInNldF9taW5faW50ZXJfY3ljbGVfdGltZW91dCIsIm1heF9pbnRlcl9jeWNsZV90aW1lb3V0Iiwic2V0X21heF9pbnRlcl9jeWNsZV90aW1lb3V0IiwiaGF2ZV9sb2NrX2RvX2N5Y2xlIiwic2V0X2hhdmVfbG9ja19kb19jeWNsZSIsImtlcm5lbF9zY2hlZHVsZXIiLCJuZXh0X3RzY19jYWxpYnJhdGlvbiIsInNldF9uZXh0X3RzY19jYWxpYnJhdGlvbiIsImRuc19sb29rdXBfdGhyb3R0bGUiLCJ0aHJlYWRfcG9vbF9zdHVjayIsInNldF90aHJlYWRfcG9vbF9zdHVjayIsImhhbmRsZV90aHJlYWRfcG9vbF9zdHVjayIsInNldF9oYW5kbGVfdGhyZWFkX3Bvb2xfc3R1Y2siLCJ0aHJlYWRfcG9vbCIsInNpZ25hbF9tYW5hZ2VyIiwiaW50ZXJydXB0b3IiLCJzY2hlZHVsZXJfdGhyZWFkX2lkIiwic2V0X3NjaGVkdWxlcl90aHJlYWRfaWQiLCJ0aW1lcmZkX3NldF9hdCIsInNldF90aW1lcmZkX3NldF9hdCIsInNldF90aW1lcmZkIiwiZXh0ZXJuYWxfZmRfZXZlbnRzIiwic2V0X2V4dGVybmFsX2ZkX2V2ZW50cyIsImV4dGVybmFsX2ZkX2J5X2Rlc2NyIiwiZmRfYnlfZGVzY3IiLCJ0aW1lX3NwZW50X3dhaXRpbmdfZm9yX2lvIiwic2V0X3RpbWVfc3BlbnRfd2FpdGluZ19mb3JfaW8iLCJudW1fYnVzeV9wb2xsZXJzIiwic2V0X251bV9idXN5X3BvbGxlcnMiLCJidXN5X3BvbGxlcnMiLCJmaWxlX2Rlc2NyX3dhdGNoZXIiLCJmZHNfd2hvc2Vfd2F0Y2hpbmdfaGFzX2NoYW5nZWQiLCJzdGFydF90eXBlIiwic2V0X3N0YXJ0X3R5cGUiLCJtdXRleCIsInVyaW5nJDAiLCJpbml0aWFsaXplZF9hdCQwIiwibWluX2ludGVyX2N5Y2xlX3RpbWVvdXQkMCIsIm1heF9pbnRlcl9jeWNsZV90aW1lb3V0JDAiLCJoYXZlX2xvY2tfZG9fY3ljbGUkMCIsImtlcm5lbF9zY2hlZHVsZXIkMCIsIm5leHRfdHNjX2NhbGlicmF0aW9uJDAiLCJkbnNfbG9va3VwX3Rocm90dGxlJDAiLCJ0aHJlYWRfcG9vbF9zdHVjayQwIiwiaGFuZGxlX3RocmVhZF9wb29sX3N0dWNrJDAiLCJ0aHJlYWRfcG9vbCQwIiwic2lnbmFsX21hbmFnZXIkMCIsImludGVycnVwdG9yJDAiLCJzY2hlZHVsZXJfdGhyZWFkX2lkJDAiLCJ0aW1lcmZkX3NldF9hdCQwIiwiZXh0ZXJuYWxfZmRfZXZlbnRzJDAiLCJleHRlcm5hbF9mZF9ieV9kZXNjciQwIiwiZmRfYnlfZGVzY3IkMCIsInRpbWVfc3BlbnRfd2FpdGluZ19mb3JfaW8kMCIsIm51bV9idXN5X3BvbGxlcnMkMCIsImJ1c3lfcG9sbGVycyQwIiwiZmRzX3dob3NlX3dhdGNoaW5nX2hhc19jaGFuZ2VkJDAiLCJzdGFydF90eXBlJDAiLCJtdXRleCQwIiwibXV0ZXhfZnVuIiwic3RhcnRfdHlwZV9mdW4iLCJmaWxlX2Rlc2NyX3dhdGNoZXJfZnVuIiwiYnVzeV9wb2xsZXJzX2Z1biIsIm51bV9idXN5X3BvbGxlcnNfZnVuIiwidGltZV9zcGVudF93YWl0aW5nX2Zvcl9pb19mdW4iLCJmZF9ieV9kZXNjcl9mdW4iLCJleHRlcm5hbF9mZF9ieV9kZXNjcl9mdW4iLCJleHRlcm5hbF9mZF9ldmVudHNfZnVuIiwidGltZXJmZF9mdW4iLCJ0aW1lcmZkX3NldF9hdF9mdW4iLCJzY2hlZHVsZXJfdGhyZWFkX2lkX2Z1biIsImludGVycnVwdG9yX2Z1biIsInNpZ25hbF9tYW5hZ2VyX2Z1biIsInRocmVhZF9wb29sX2Z1biIsImhhbmRsZV90aHJlYWRfcG9vbF9zdHVja19mdW4iLCJ0aHJlYWRfcG9vbF9zdHVja19mdW4iLCJkbnNfbG9va3VwX3Rocm90dGxlX2Z1biIsIm5leHRfdHNjX2NhbGlicmF0aW9uX2Z1biIsImtlcm5lbF9zY2hlZHVsZXJfZnVuIiwiaGF2ZV9sb2NrX2RvX2N5Y2xlX2Z1biIsIm1heF9pbnRlcl9jeWNsZV90aW1lb3V0X2Z1biIsIm1pbl9pbnRlcl9jeWNsZV90aW1lb3V0X2Z1biIsImluaXRpYWxpemVkX2F0X2Z1biIsInVyaW5nX2Z1biIsIm11dGV4XzAxNCIsInN0YXJ0X3R5cGVfMDE2IiwiYnVzeV9wb2xsZXJzXzAyMiIsImZpbGVfZGVzY3Jfd2F0Y2hlcl8wMjAiLCJudW1fYnVzeV9wb2xsZXJzXzAyNCIsInRpbWVfc3BlbnRfd2FpdGluZ19mb3JfaW9fMDI2IiwiZXh0ZXJuYWxfZmRfYnlfZGVzY3JfMDMwIiwiZmRfYnlfZGVzY3JfMDI4IiwiZXh0ZXJuYWxfZmRfZXZlbnRzXzAzMiIsInRpbWVyZmRfMDM0IiwidGltZXJmZF9zZXRfYXRfMDM2Iiwic2NoZWR1bGVyX3RocmVhZF9pZF8wMzgiLCJ0aHJlYWRfcG9vbF8wNDQiLCJzaWduYWxfbWFuYWdlcl8wNDIiLCJpbnRlcnJ1cHRvcl8wNDAiLCJ0aHJlYWRfcG9vbF9zdHVja18wNDgiLCJkbnNfbG9va3VwX3Rocm90dGxlXzA1MCIsIm5leHRfdHNjX2NhbGlicmF0aW9uXzA1MiIsImtlcm5lbF9zY2hlZHVsZXJfMDU0IiwiaGF2ZV9sb2NrX2RvX2N5Y2xlXzA1NiIsIm1heF9pbnRlcl9jeWNsZV90aW1lb3V0XzA1OCIsIm1pbl9pbnRlcl9jeWNsZV90aW1lb3V0XzA2MCIsInVyaW5nXzA2NCIsImluaXRpYWxpemVkX2F0XzA2MiIsImFyZ18wNjUiLCJhcmdfMDYzIiwiYXJnXzA2MSIsImJuZHNfMDEzJDEiLCJhcmdfMDU5IiwiYm5kc18wMTMkMiIsImFyZ18wNTciLCJibmRzXzAxMyQzIiwiYXJnXzA1NSIsImJuZHNfMDEzJDQiLCJhcmdfMDUzIiwiYm5kc18wMTMkNSIsImFyZ18wNTEiLCJibmRzXzAxMyQ2IiwiYXJnXzA0OSIsImJuZHNfMDEzJDciLCJhcmdfMDQ3IiwiYm5kc18wMTMkOCIsImFyZ18wNDUiLCJibmRzXzAxMyQ5IiwiYXJnXzA0MyIsImJuZHNfMDEzJDEwIiwiYXJnXzA0MSIsImJuZHNfMDEzJDExIiwiYXJnXzAzOSIsImJuZHNfMDEzJDEyIiwiYXJnXzAzNyIsImJuZHNfMDEzJDEzIiwiYm5kc18wMTMkMTQiLCJibmRzXzAxMyQxNSIsImJuZHNfMDEzJDE2IiwiYm5kc18wMTMkMTciLCJibmRzXzAxMyQxOCIsImJuZHNfMDEzJDE5IiwiYm5kc18wMTMkMjAiLCJibmRzXzAxMyQyMSIsImJuZHNfMDEzJDIyIiwiYm5kc18wMTMkMjMiLCJibmRzXzAxMyQyNCIsIm1heF9udW1fdGhyZWFkcyIsIm1heF9udW1fb3Blbl9maWxlX2Rlc2NycyIsImN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQiLCJ3aXRoX2V4ZWN1dGlvbl9jb250ZXh0IiwiY29udGV4dCIsInRocmVhZF9wb29sX2NwdV9hZmZpbml0eSIsImxvY2siLCJ0cnlfbG9jayIsInVubG9jayIsIndpdGhfbG9jayIsImFtX2hvbGRpbmdfbG9jayIsIm11dGV4X2Zvcl9pbml0aWFsaXppbmdfdGhlX29uZSIsInRoZV9vbmVfYW5kX29ubHlfcmVmIiwiaXNfcmVhZHlfdG9faW5pdGlhbGl6ZSIsImlzX2luaXRpYWxpemVkIiwidGhlX29uZV9hbmRfb25seV91bmNvbW1vbl9jYXNlIiwidGhlX29uZV9hbmRfb25seSIsImZkc19jcmVhdGVkX2JlZm9yZV9pbml0aWFsaXphdCIsImNyZWF0ZV9mZF9yZWdpc3RyYXRpb24iLCJtYXRjaCQwIiwibWF0Y2gkMSIsInYkMCIsImN1cnJlbnRfdGhyZWFkX2lkIiwiaXNfbWFpbl90aHJlYWQiLCJyZW1vdmVfZmQiLCJtYXliZV9zdGFydF9jbG9zaW5nX2ZkIiwiZG9fY2xvc2Vfc3lzY2FsbCIsImV4ZWN1dGlvbl9jb250ZXh0IiwiZGVjX251bV9hY3RpdmVfc3lzY2FsbHNfZmQiLCJmZCQwIiwidXBkYXRlX2NoZWNrX2FjY2VzcyIsImRvX2NoZWNrIiwiYXJnMl8wNjgiLCJhcmcxXzA2NyIsImFyZzBfMDY2IiwicmVzMF8wNjkiLCJyZXMxXzA3MCIsInJlczJfMDcxIiwidHJ5X2NyZWF0ZV90aW1lcmZkIiwiY2xvY2siLCJkZWZhdWx0X2hhbmRsZV90aHJlYWRfcG9vbF9zdHUiLCJzdHVja19mb3IiLCJzaG91bGRfYWJvcnQiLCJ0ZXh0JDAiLCJtYXRjaCIsInRocmVhZF9wb29sX2hhc191bmZpbmlzaGVkX3dvciIsInRocmVhZF9zYWZlX3dha2V1cF9zY2hlZHVsZXIiLCJpX2FtX3RoZV9zY2hlZHVsZXIiLCJzZXRfZmRfZGVzaXJlZF93YXRjaGluZyIsImdpdmVfdXBfb25fd2F0Y2hpbmciLCJhcmcyXzA3NCIsImFyZzFfMDczIiwiYXJnMF8wNzIiLCJyZXMwXzA3NSIsInJlczFfMDc2IiwicmVzMl8wNzciLCJyZWFkeV90byIsImpvYiIsInJlcXVlc3Rfc3RhcnRfd2F0Y2hpbmciLCJhcmcyXzA4MCIsImFyZzFfMDc5IiwiYXJnMF8wNzgiLCJyZXMwXzA4MSIsInJlczFfMDgyIiwicmVzMl8wODMiLCJyZXF1ZXN0X3N0b3Bfd2F0Y2hpbmciLCJ2YWx1ZSIsImFyZzNfMDg3IiwiYXJnMl8wODYiLCJhcmcxXzA4NSIsImFyZzBfMDg0IiwicmVzMF8wODgiLCJyZXMxXzA4OSIsInJlczJfMDkwIiwicmVzM18wOTEiLCJwb3N0X2NoZWNrX2dvdF90aW1lcmZkIiwicG9zdF9jaGVja19pbnZhbGlkX2ZkIiwicG9zdF9jaGVja19oYW5kbGVfZmQiLCJldmVudF90eXBlIiwidGZkIiwiZXYiLCJ0b29fbG9uZyIsImN5Y2xlX3Rvb2tfbG9uZ2VyX3RoYW5fMTAwdXMiLCJjeWNsZV90aW1lIiwibWF5YmVfcmVwb3J0X2xvbmdfYXN5bmNfY3ljbGVzIiwid29yZHNfYmVmb3JlIiwid29yZHNfYWZ0ZXIiLCJhXzA5MiIsImJfMDkzIiwibWF5YmVfcmVwb3J0X2xvbmdfYXN5bmNfY3ljbGVzJDAiLCJzdGgkMCIsInN0aCQxIiwic3RoJDIiLCJ0X3JlZiIsInJlYWR5X29yX2JhZF9mZCIsIndhdGNoZXIiLCJ3YXRjaGVyJDAiLCJ0aW1lcmZkJDEiLCJ3YXRjaGVyJDEiLCJDdXN0b20iLCJ3YXRjaGVyJDIiLCJmaWxlX2Rlc2NyX3dhdGNoZXIkMSIsIm1heF9jb25jdXJyZW50X2Ruc19sb29rdXBzIiwidGFrZV90aGVfbG9jayIsInJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzX3dpdGhvdSIsIm1ha2VfYXN5bmNfdW51c2FibGUiLCJ0aHJlYWRfc2FmZV9lbnF1ZXVlX2V4dGVybmFsX2oiLCJoYXZlX2xvY2tfZG9fY3ljbGUkMSIsImxvZ19zeW5jX2NoYW5nZWRfZmRzX3RvX2ZpbGVfZCIsImFyZzJfMDk2IiwiYXJnMV8wOTUiLCJhcmcwXzA5NCIsInJlczBfMDk3IiwicmVzMV8wOTgiLCJyZXMyXzA5OSIsInN5bmNfY2hhbmdlZF9mZF9mYWlsZWQiLCJidCIsInN5bmNfY2hhbmdlZF9mZHNfdG9fZmlsZV9kZXNjciIsIm1heWJlX2NhbGlicmF0ZV90c2MiLCJub3ciLCJjYWxpYnJhdG9yIiwiY3JlYXRlX2pvYiIsImV4ZWN1dGlvbl9jb250ZXh0JDAiLCJkdW1wX2NvcmVfb25fam9iX2RlbGF5IiwibnVtX2J1c3lfcG9sbGVycyQxIiwiYWRkX2J1c3lfcG9sbGVyIiwibWF4X2J1c3lfd2FpdF9kdXJhdGlvbiIsImluaXQkMCIsImludGVycnVwdG9yX2ZpbmlzaGVkIiwiaW50ZXJydXB0b3JfcmVhZF9mZCIsInByb2JsZW1fd2l0aF9pbnRlcnJ1cHRvciIsImZkc19tYXlfcHJvZHVjZV9ldmVudHMiLCJpbnRlcnJ1cHRvcl9mZCIsImNoZWNrX2ZpbGVfZGVzY3Jfd2F0Y2hlciIsImFyZzFfMTAzIiwiYXJnMF8xMDIiLCJyZXMwXzEwNCIsInZfMTAxIiwicmVzMV8xMDUiLCJiZWZvcmUiLCJhcmcxXzEwNyIsImFyZzBfMTA2IiwicmVzMF8xMDgiLCJyZXMxXzEwOSIsInJ1bl9idXN5X3BvbGxlcnNfb25jZSIsImRpZF93b3JrIiwicnVuX2J1c3lfcG9sbGVycyIsInBvbGxlcnNfZGlkX3NvbWV0aGluZyIsIm5ld190aW1lb3V0IiwiY29tcHV0ZV90aW1lb3V0X2FuZF9jaGVja19maWxlIiwiaGF2ZV9idXN5X3BvbGxlcnMiLCJoYXZlX21pbl9pbnRlcl9jeWNsZV90aW1lb3V0IiwibmV4dF9ldmVudF9hdCQwIiwic2V0X3RpbWVyZmRfYXQiLCJmaWxlX2Rlc2NyX3dhdGNoZXJfdGltZW91dCIsIm5leHRfZXZlbnRfYXQiLCJvbmVfaXRlciIsImJlX3RoZV9zY2hlZHVsZXIiLCJyYWlzZV91bmhhbmRsZWRfZXhuIiwiZXJyb3IkMSIsImVycm9yX2tpbmQiLCJhcmcxXzExMSIsImFyZzBfMTEwIiwicmVzMF8xMTIiLCJyZXMxXzExMyIsImVycm9yJDAiLCJjdXN0b21fcHJpbnRmXzExNCIsImFkZF9maW5hbGl6ZXIiLCJoZWFwX2Jsb2NrIiwiYWRkX2ZpbmFsaXplcl9leG4iLCJhc3luY19rZXJuZWxfY29uZmlnX3Rhc2tfaWQiLCJ2XzExNSIsInRocmVhZF9pZCIsInJlczBfMTE5IiwicmVzMV8xMjAiLCJzZXRfdGFza19pZCIsInJhaXNlX2lmX2FueV9qb2JzX3dlcmVfc2NoZWR1bCIsImlzX3J1bm5pbmciLCJnbyIsImdvX21haW4iLCJtYWluIiwibWF4X251bV90aHJlYWRzJDAiLCJpc190aGVfb25lX2FuZF9vbmx5X3J1bm5pbmciLCJyZXBvcnRfbG9uZ19jeWNsZV90aW1lcyIsImN1dG9mZiIsInNldF9jaGVja19pbnZhcmlhbnRzIiwiYm9vbCIsInNldF9kZXRlY3RfaW52YWxpZF9hY2Nlc3NfZnJvbSIsInNldF9tYXhfaW50ZXJfY3ljbGVfdGltZW91dCQwIiwid2l0aF90X29uY2Vfc3RhcnRlZCIsImZvbGRfZmllbGRzIiwiZm9sZGVyIiwiaGFuZGxlX3RocmVhZF9wb29sX3N0dWNrJDEiLCJjcmVhdGVkIiwiY3JlYXRlX2V4biIsImdldF9hbmRfcmVzZXQiLCJjdXJyZW50X3RocmVhZF9jYW5fY3ljbGUiLCJhY3RpdmUiLCJjb2xsZWN0X2V2ZW50cyIsImV2ZW50X2xpc3QiLCJydW5fb25lX2N5Y2xlIiwiYWN0aXZlJDAiLCJhY3RpdmUkMSIsImNoZWNrX3RocmVhZCIsInJlZ2lzdGVyX2ZkIiwib3BzIiwibm90X3dhdGNoaW5nIiwidW5yZWdpc3Rlcl9mZCIsImlzX3JlZ2lzdGVyZWQiLCJydW5fb25lX2N5Y2xlJDAiLCJtYXhfd2FpdCIsIndha2VfYXQiLCJ3YWtlIiwicnVuX2N5Y2xlc191bnRpbF9kZXRlcm1pbmVkIiwicmVhZHlfZmRzIiwiYV8xMjIiLCJiXzEyMyIsImZkX29wcyIsInRlbXBvcmFyaWx5X3VucmVnaXN0ZXIiLCJhbGwiLCJkZWZhdWx0JDAiLCJzdHVja19jaGVja19pbnRlcnZhbCIsInNjaGVkdWxlX3N0dWNrX2NoZWNrIiwiY2hlY2tfc3RpbGxfc3R1Y2siLCJudW1fd29ya19jb21wbGV0ZWQiLCJzdHVja19zaW5jZSIsInJ1biIsInByaW9yaXR5IiwidGhyZWFkIiwibmFtZSIsIndoZW5fZmluaXNoZWQiLCJkb2l0IiwibG9ja2VkIiwiaGVscGVyX3RocmVhZCIsInRocmVhZF9wb29sX2hlbHBlcl90aHJlYWQiLCJjcmVhdGVfaW50ZXJuYWwiLCJzY2hlZHVsZXIiLCJmaW5hbGl6ZSIsImNyZWF0ZV9ub3ciLCJydW4kMCIsInRocmVhZCQwIiwicGlwZV9vZl9zcXVldWUiLCJzcSIsInciLCJwdWxsIiwicSIsImNvbnRpbnVlJDAiLCJsb29wIiwiYXJnMF8wMDUiLCJmb3JjZV91cmluZ19leG4iLCJjcmVhdGVfZXZlbnRmZCIsInVyaW5nX2Vycm9yIiwiZXZlbnRmZCIsImV2ZW50ZmRfcmVhZHlfam9iIiwiZmluaXNoZWRfd2F0Y2hpbmciLCJhcmcxXzAwNiIsInJlczFfMDA4IiwiZXZlbnRmZF9lcnJvciIsInVyaW5nJDEiLCJ1cmluZ19lcnJvciQwIiwiZ2xvYmFsX2lvX3VyaW5nIiwiaW9fdXJpbmciLCJnZXRfc29ja2V0X3N0YXRlIiwiYmxvY2tpbmdfaW5mZXJfdXNpbmdfc3RhdCIsInN0IiwiaW5mZXJfdXNpbmdfc3RhdCIsInN0YXR4X2J1ZmZlciIsInRvX3N0cmluZyIsImNyZWF0ZV9zdGRfZGVzY3IiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsImNsZWFyX25vbmJsb2NrIiwiZmlsZV9kZXNjcmlwdG9yX2hhbmRsaW5nIiwic29ja2V0X2hhbmRsaW5nIiwiZGVyZWdpc3RlciIsImNyZWF0ZV9ib3Jyb3dlZCIsIndpdGhfY2xvc2UiLCJ3aXRoX2ZpbGVfZGVzY3JfZGVmZXJyZWQiLCJleHRyYWN0X2V4biIsIndpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZF9yZXN1bCIsIndpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZF9leG4iLCJhcmcxXzAwNCIsInN0b3Bfd2F0Y2hpbmdfdXBvbl9pbnRlcnJ1cHQiLCJpbnRlcnJ1cHQiLCJpbnRlcnJ1cHRpYmxlX3JlYWR5X3RvIiwiYXJnMV8wMDgiLCJyZXMxXzAxMCIsImludGVycnVwdGlibGVfZXZlcnlfcmVhZHlfdG8iLCJldmVyeV9yZWFkeV90byIsImFyZzFfMDIwIiwiYXJnMF8wMTkiLCJyZXMwXzAyMSIsInJlczFfMDIyIiwic3lzY2FsbF9pbl90aHJlYWQiLCJ4JDAiLCJzeXNjYWxsX2luX3RocmVhZF9leG4iLCJvZl9pbl9jaGFubmVsIiwiaWMiLCJvZl9vdXRfY2hhbm5lbCIsIm9jIiwib2ZfaW5fY2hhbm5lbF9hdXRvIiwib2Zfb3V0X2NoYW5uZWxfYXV0byIsImZpbGVfZGVzY3JfZXhuIiwidG9faW50X2V4biIsImV4cGVjdF9maWxlX2Rlc2NyX3JlZGlyZWN0aW9uIiwicmVwbGFjZSIsImkkMCIsImkkMSIsImFyZzFfMDI1IiwiYXJnMF8wMjQiLCJyZXMwXzAyNiIsInZfMDIzIiwicmVzMV8wMjciLCJvdXRwdXQiLCJmbHVzaCIsIm91dF9jaGFubmVsIiwiYnl0ZXNfYnVmIiwiYnVmIiwibGVuIiwib3V0cHV0X2lvdmVjIiwiaW92ZWMiLCJtYXhfdHJpZXMiLCJhdHRlbXB0X3N5c2NhbGxfaW50ZXJuYWwiLCJjb3VudCIsImF0dGVtcHRfc3lzY2FsbCIsImV4biQxIiwid2l0aF9maWxlX2Rlc2NyX2RlZmVycmVkX29wdCIsImZkX29wdCIsInJlYWRfZmlsZV9kZXNjciIsIm9mZiIsImZpbGVfb2Zmc2V0IiwidG9fY3N0cnVjdCIsImlvdmVjcyIsImJ1ZnMiLCJhY2Nlc3MiLCJyZXNvbHZlIiwiZmlsZW5hbWUiLCJwZXJtJDAiLCJkaXIiLCJ0YXJnZXQiLCJsaW5rX25hbWUiLCJmb2xsb3ciLCJhcmdzX2Zvcl9lcnJvciIsInVubGlua19yZXMiLCJzIiwiZG9fc3RhdHgiLCJwYXRoIiwieF8wMDMiLCJzdGF0IiwiZnN0YXQiLCJsc3RhdCIsInJ1bl9ob2xkaW5nX2FzeW5jX2xvY2siLCJmaW5pc2giLCJ3YWtldXBfc2NoZWR1bGVyIiwiZW5zdXJlX2luX2FfdGhyZWFkIiwiZnVuY3Rpb24kMCIsIndpdGhvdXRfYXN5bmNfbG9ja191bmNoZWNrZWQiLCJibG9ja19vbl9hc3luY19ub3RfaG9sZGluZ19hc3kiLCJmJDAiLCJzY2hlZHVsZXJfcmFuX2Ffam9iIiwic3RhcnRpbmciLCJtYXliZV9ibG9ja2VkIiwiYW1faG9sZGluZ19hc3luY19sb2NrIiwiZGVmZXJyZWQiLCJmaWxsIiwicnVuX2luX2FzeW5jX3dpdGhfb3B0aW9uYWxfY3ljIiwibWF5YmVfcnVuX2FfY3ljbGUiLCJydW5faW5fYXN5bmMiLCJydW5faW5fYXN5bmNfZXhuIiwiYmxvY2tfb25fYXN5bmMiLCJibG9ja19vbl9hc3luY19leG4iLCJydW5faW5fYXN5bmNfd2FpdCIsInJ1bl9pbl9hc3luY193YWl0X2V4biIsIm9rX3RvX2Ryb3BfbG9jayIsIndpdGhvdXRfYXN5bmNfbG9jayIsIndpdGhvdXRfYXN5bmNfbG9ja191bmNoZWNrZWQkMCIsIndhcm1fdXBfZmRzIiwiaGFuZGxlX2RlZmF1bHQiLCJpZ25vcmUiLCJ0cyIsInRlcm1pbmF0aW5nIiwibWFuYWdlX2J5X2FzeW5jIiwiaXNfbWFuYWdlZF9ieV9hc3luYyIsImVyciQ0IiwiZXJyJDMiLCJlcnIkMiIsImVyciQxIiwiZXJyJDAiLCJlcnJvcl9zb3VyY2VfMDEyIiwiZXJyb3Jfc291cmNlXzAyOCIsImVycm9yX3NvdXJjZV8wMzAiLCJlcnJvcl9zb3VyY2VfMDMyIiwiZXJyb3Jfc291cmNlXzA2NSIsImVycm9yX3NvdXJjZV8xMDkiLCJlcnJvcl9zb3VyY2VfMTEzIiwiZXJyb3Jfc291cmNlXzEzNiIsImVycm9yX3NvdXJjZV8xMzgiLCJlcnJvcl9zb3VyY2VfMTQ0IiwiZXJyb3Jfc291cmNlXzE3MCIsImVycm9yX3NvdXJjZV8xNzYiLCJlcnJvcl9zb3VyY2VfMTk0IiwiZXJyb3Jfc291cmNlXzIyNiIsImVycm9yX3NvdXJjZV8yNDEiLCJlcnJvcl9zb3VyY2VfMjY1IiwiZXJyb3Jfc291cmNlXzI3NCIsImVycm9yX3NvdXJjZV8yNzciLCJlcnJvcl9zb3VyY2VfMjk1Iiwic3lzdGVtIiwic3lzdGVtX2V4biIsImdldHBpZCIsImdldHBwaWQiLCJnZXRwcGlkX2V4biIsInRoaXNfcHJvY2Vzc19iZWNhbWVfY2hpbGRfb2ZfaSIsInBvbGxfZGVsYXkiLCJuaWNlIiwiY29yZXMiLCJjb252ZXJ0X29wZW5fZmxhZyIsImZpbGVfcGVybV9vZl9zZXhwIiwic2V4cF9vZl9maWxlX3Blcm0iLCJncm91cCIsImJpbl9zaGFwZV9maWxlX3Blcm0iLCJiaW5fc2l6ZV9maWxlX3Blcm0iLCJiaW5fd3JpdGVfZmlsZV9wZXJtIiwiYmluX3JlYWRfZmlsZV9wZXJtIiwiY29tcGFyZV9maWxlX3Blcm0iLCJjb252ZXJ0X3RvX3VyaW5nX2ZsYWdzIiwiaXNfcndfZmxhZyIsImZsYWciLCJvcGVuZmlsZSIsImZpbGUiLCJ1bml4X21vZGUiLCJhY2Nlc3MkMCIsInBlcm1fZm9yX2Vycm9yIiwiZGVmYXVsdF9wZXJtIiwiZGVmYXVsdF9wZXJtJDAiLCJmY250bF9nZXRmbCIsImZjbnRsX3NldGZsIiwibHNlZWsiLCJ0cnVuY2F0ZSIsImZ0cnVuY2F0ZSIsImZzeW5jIiwiZmRhdGFzeW5jIiwic3luYyIsImZsb2NrX2NvbW1hbmQiLCJsb2NrZiIsImxvY2tfbW9kZSIsInRyeV9sb2NrZiIsInRlc3RfbG9ja2YiLCJ1bmxvY2tmIiwiZmxvY2siLCJ0cnlfZmxvY2siLCJmdW5sb2NrIiwiY29tcGFyZSIsInRfb2Zfc2V4cCIsInNleHBfMDEzIiwiYXJnX3R5cGUiLCJtZWNoYW5pc21fMDE3IiwibW9kZV8wMTUiLCJhcmdfMDE4IiwiYm5kc18wMTQiLCJhcmdfMDE2IiwiYm5kc18wMTQkMCIsIndpdGhfZmlsZSIsIm1lY2hhbmlzbSIsImNvbXBhcmUkMCIsImFfMDIxIiwiYl8wMjIiLCJ0X29mX3NleHAkMCIsInNleHBfMDI2IiwiYXRvbV8wMjQiLCJhdG9tXzAyNCQwIiwidF9vZl9zZXhwJDEiLCJzZXhwXzAyOSIsImdyb3VwJDAiLCJiaW5fc2hhcGVfdCIsIm9mX3VuaXgiLCJ0b191bml4IiwidF9vZl9zZXhwJDIiLCJ4XzAzMyIsImN0aW1lXzA1NyIsIm10aW1lXzA1NSIsImF0aW1lXzA1MyIsInNpemVfMDUxIiwicmRldl8wNDkiLCJnaWRfMDQ3IiwidWlkXzA0NSIsIm5saW5rXzA0MyIsInBlcm1fMDQxIiwia2luZF8wMzkiLCJpbm9fMDM3IiwiZGV2XzAzNSIsImFyZ18wNTgiLCJibmRzXzAzNCIsImFyZ18wNTYiLCJibmRzXzAzNCQwIiwiYXJnXzA1NCIsImJuZHNfMDM0JDEiLCJhcmdfMDUyIiwiYm5kc18wMzQkMiIsImFyZ18wNTAiLCJibmRzXzAzNCQzIiwiYXJnXzA0OCIsImJuZHNfMDM0JDQiLCJhcmdfMDQ2IiwiYm5kc18wMzQkNSIsImFyZ18wNDQiLCJibmRzXzAzNCQ2IiwiYXJnXzA0MiIsImJuZHNfMDM0JDciLCJhcmdfMDQwIiwiYm5kc18wMzQkOCIsImFyZ18wMzgiLCJibmRzXzAzNCQ5IiwiYXJnXzAzNiIsImJuZHNfMDM0JDEwIiwiZ3JvdXAkMSIsImJpbl9zaGFwZV90JDAiLCJiaW5fc2l6ZV90IiwidjEyIiwidjExIiwidjEwIiwidjkiLCJ2OCIsInY3IiwidjYiLCJ2NSIsInY0IiwidjIiLCJ2MSIsInNpemUkMSIsInNpemUkMiIsInNpemUkMyIsInNpemUkNCIsInNpemUkNSIsInNpemUkNiIsInNpemUkNyIsInNpemUkOCIsInNpemUkOSIsImJpbl93cml0ZV90IiwidjMiLCJwb3MkMCIsInBvcyQxIiwicG9zJDIiLCJwb3MkMyIsInBvcyQ0IiwicG9zJDUiLCJwb3MkNiIsInBvcyQ3IiwicG9zJDgiLCJwb3MkOSIsInBvcyQxMCIsImJpbl93cml0ZXJfdCIsImJpbl9yZWFkX3QiLCJwb3NfcmVmIiwidmludCIsImJpbl9yZWFkX3QkMCIsInZfZGV2Iiwidl9pbm8iLCJ2X2tpbmQiLCJ2X3Blcm0iLCJ2X25saW5rIiwidl91aWQiLCJ2X2dpZCIsInZfcmRldiIsInZfc2l6ZSIsInZfYXRpbWUiLCJ2X210aW1lIiwidl9jdGltZSIsImJpbl9yZWFkZXJfdCIsImJpbl90IiwiY29tcGFyZSQyIiwiYV8wNTkiLCJiXzA2MCIsIm4kMSIsIm4kMiIsIm4kMyIsIm4kNCIsIm4kNSIsIm4kNiIsIm4kNyIsIm4kOCIsIm4kOSIsIm9mX3VuaXgkMCIsInUiLCJvZl9mbG9hdF9zZWMiLCJ0b191bml4JDAiLCJ0b19mbG9hdF9zZWMiLCJvZl9vY2FtbF91cmluZ19zdGF0eCIsIm9mX3RpbWVzcGVjIiwic2VjIiwibnNlYyIsInRvX3N0cmluZyQwIiwiaXNhdHR5IiwicmVuYW1lIiwic3JjIiwiZHN0IiwiY2htb2QiLCJmY2htb2QiLCJjaG93biIsImZjaG93biIsImFjY2Vzc19leG4iLCJzZXRfY2xvc2Vfb25fZXhlYyIsImNsZWFyX2Nsb3NlX29uX2V4ZWMiLCJta2RpciIsInAiLCJkaXJuYW1lIiwicm1kaXIiLCJjaGRpciIsImNocm9vdCIsImdldGN3ZCIsIm9wZW5kaXIiLCJyZWFkZGlyX29wdCIsInJld2luZGRpciIsImNsb3NlZGlyIiwicGlwZSIsIndyaXRlciIsInJlYWRlciIsIm1rZmlmbyIsInN5bWxpbmsiLCJyZWFkbGluayIsIm1rZHRlbXAiLCJta3N0ZW1wIiwiZ2V0Z3JvdXBsaXN0IiwidXNlcm5hbWUiLCJ0aW1lcyIsImdldHRpbWVvZmRheSIsImdtdGltZSIsImxvY2FsdGltZSIsIm1rdGltZSIsInV0aW1lcyIsIm1vZGlmIiwiZW52X29mX3NleHAiLCJzZXhwX29mX2VudiIsImVudmlyb25tZW50IiwiZ2V0ZW52IiwiZ2V0ZW52X2V4biIsInVuc2FmZV9nZXRlbnYiLCJ1bnNhZmVfZ2V0ZW52X2V4biIsInB1dGVudiIsInVuc2V0ZW52IiwiZm9ya19leGVjIiwicHJvZyIsImFyZ3YiLCJ1c2VfcGF0aCIsImVudiIsIndhaXRfb25fb2Zfc2V4cCIsIndhaXRfb25fb2Zfc2V4cCQwIiwic2V4cF8wNjQiLCJzZXhwX29mX3dhaXRfb24iLCJ3YWl0X25vaGFuZyIsIndhaXRfbm9oYW5nX3VudHJhY2VkIiwid2FpdF9ub2hhbmckMCIsIndhaXRfb24iLCJleGl0X29yX3NpZ25hbCIsInBpZDIiLCJ3YWl0cyIsImNoZWNrX2FsbCIsInNob3VsZF9oYW5kbGVfc2lnY2hsZCIsImFtX2hhbmRsaW5nX3NpZ2NobGQiLCJkb19ub3RfaGFuZGxlX3NpZ2NobGQiLCJpbnN0YWxsX3NpZ2NobGRfaGFuZGxlcl90aGVfZmkiLCJkZWZlcnJlZF93YWl0IiwibW9uaXRvciIsIndhaXQiLCJ3YWl0X3VudHJhY2VkIiwid2FpdHBpZF9wcm9tcHQiLCJwaWQiLCJ3YWl0cGlkX2V4biIsImRuc19sb29rdXAiLCJvZl9zdHJpbmdfb3JfZ2V0YnluYW1lIiwiYmluZF90b19pbnRlcmZhY2UiLCJzcGVjIiwiYmluZF90b19pbnRlcmZhY2VfZXhuIiwiZ3JvdXAkMiIsImJpbl9zaGFwZV90JDIiLCJiaW5fc2l6ZV90JDEiLCJhcmdzIiwic2l6ZV9hcmdzIiwiYmluX3dyaXRlX3QkMSIsImJpbl93cml0ZXJfdCQxIiwiYmluX3JlYWRfdCQzIiwiYXJnXzEiLCJiaW5fcmVhZF90JDQiLCJiaW5fcmVhZGVyX3QkMSIsImJpbl90JDEiLCJjb21wYXJlJDQiLCJhXzA4MiIsImJfMDgzIiwicmlnaHRfMDg1IiwibGVmdF8wODQiLCJ0XzA4NyIsInRfMDg2IiwidF8wODkiLCJ0XzA4OCIsImhhc2hfZm9sZF90JDAiLCJoc3YiLCJhcmciLCJoc3YkMCIsImUxIiwiZTAiLCJoc3YkMSIsImhzdiQyIiwiaGFzaCQwIiwidG9fc3RyaW5nX2ludGVybmFsIiwic2hvd19wb3J0X2luX3Rlc3QiLCJ0b19zdHJpbmckMiIsInNleHBfb2ZfdCQ1IiwiZ3JvdXAkMyIsImJpbl9zaGFwZV90JDMiLCJiaW5fc2l6ZV90JDIiLCJiaW5fd3JpdGVfdCQyIiwiYmluX3dyaXRlcl90JDIiLCJiaW5fcmVhZF90JDUiLCJiaW5fcmVhZF90JDYiLCJiaW5fcmVhZGVyX3QkMiIsImJpbl90JDIiLCJjb21wYXJlJDUiLCJhXzA5MCIsImJfMDkxIiwicmlnaHRfMDkzIiwibGVmdF8wOTIiLCJ0XzA5NSIsInRfMDk0IiwidF8wOTciLCJ0XzA5NiIsImhhc2hfZm9sZF90JDEiLCJoYXNoJDEiLCJ0X29mX3NleHAkNCIsInNleHBfMTAxIiwiYXRvbV8wOTkiLCJzZXhwX2FyZ3NfMTAyIiwiYXRvbV8wOTkkMCIsImFyZzFfMTA1IiwiYXJnMF8xMDQiLCJyZXMwXzEwNiIsInJlczFfMTA3IiwicmVzMF8xMTEiLCJ0X29mX3NleHAkNSIsInNleHBfMTEyIiwic2V4cF9vZl90JDYiLCJ2XzExNCIsImFyZzFfMTE2IiwiYXJnMF8xMTUiLCJyZXMwXzExNyIsInJlczFfMTE4Iiwic2V4cF9vZl90JDciLCJ2XzExOSIsImFyZzFfMTIxIiwiYXJnMF8xMjAiLCJyZXMwXzEyMiIsInJlczFfMTIzIiwidG9fc3RyaW5nJDMiLCJhZGRyIiwicG9ydCIsInRvX2hvc3RfYW5kX3BvcnQiLCJjcmVhdGVfYmluZF9hbnkiLCJvZl9zb2NrYWRkcl9leG4iLCJ0b19zb2NrYWRkciIsImdyb3VwJDQiLCJiaW5fc2hhcGVfdCQ0IiwiYmluX3NpemVfdCQzIiwiYmluX3dyaXRlX3QkMyIsImJpbl93cml0ZXJfdCQzIiwiYmluX3JlYWRfdCQ3IiwiYmluX3JlYWRfdCQ4IiwiYmluX3JlYWRlcl90JDMiLCJiaW5fdCQzIiwiY29tcGFyZSQ2IiwiYV8xMjQiLCJiXzEyNSIsInJpZ2h0XzEyNyIsImxlZnRfMTI2IiwidF9vZl9zZXhwJDYiLCJzZXhwXzEzMSIsImF0b21fMTI5Iiwic2V4cF9hcmdzXzEzMiIsImF0b21fMTI5JDAiLCJhcmcwXzEzNCIsInJlczBfMTM1IiwidF9vZl9zZXhwJDciLCJzZXhwXzEzNyIsInNleHBfb2ZfdCQ4Iiwidl8xMzkiLCJ0b19zdHJpbmckNCIsIm9mX3NvY2thZGRyX2V4biQwIiwidG9fc29ja2FkZHIkMCIsImdyb3VwJDUiLCJiaW5fc2hhcGVfdCQ1IiwiYmluX3NpemVfdCQ0IiwiYmluX3dyaXRlX3QkNCIsImJpbl93cml0ZXJfdCQ0IiwiYmluX3JlYWRfdCQ5IiwiYmluX3JlYWRfdCQxMCIsImJpbl9yZWFkZXJfdCQ0IiwiYmluX3QkNCIsInNleHBfb2ZfdCQ5Iiwidl8xNDAiLCJncm91cCQ2IiwiYmluX3NoYXBlX3QkNiIsImJpbl9zaXplX3QkNSIsImJpbl93cml0ZV90JDUiLCJiaW5fd3JpdGVyX3QkNSIsImJpbl9yZWFkX3QkMTEiLCJiaW5fcmVhZF90JDEyIiwiYmluX3JlYWRlcl90JDUiLCJiaW5fdCQ1IiwiaGFzaF9mb2xkX3QkMiIsImhhc2gkMiIsInRfb2Zfc2V4cCQ4Iiwic2V4cF8xNDMiLCJzZXhwX29mX3QkMTAiLCJ2XzE0NSIsInRvX3NvY2thZGRyJDEiLCJ0b19zdHJpbmckNSIsInRvX3N0cmluZyQ2IiwiaW5ldCIsInVuaXgiLCJpc19pbmV0X3dpdG5lc3MiLCJzZXhwX29mX3QkMTEiLCJvZl9hXzE0NyIsInNvY2tldF90eXBlXzE1MSIsImZhbWlseV8xNDkiLCJhcmdfMTUyIiwiYm5kc18xNDgiLCJmYW1pbHkiLCJhcmdfMTUwIiwiYm5kc18xNDgkMCIsInRjcCIsInVkcCIsInVuaXgkMCIsInVuaXhfZGdyYW0iLCJjb25uZWN0ZWRfdG8iLCJib3VuZF9vbiIsImxpc3RlbmluZyIsInhfMTUzIiwibGlzdGVuaW5nX29uIiwiYm91bmRfb24kMCIsInZfMTU2Iiwidl8xNTUiLCJ2XzE1NCIsInNleHBfb2ZfdCQxMiIsIm9mX2ZkIiwic2V4cF9vZl9hZGRyZXNzIiwiY3JlYXRlJDEiLCJ4XzE1NyIsInRvX3N0cmluZyQ3IiwibWFrZSIsImdldHNvY2tvcHQiLCJzZXRzb2Nrb3B0IiwiaW50JDAiLCJmbG9hdCQwIiwiYnJvYWRjYXN0IiwicmV1c2VhZGRyIiwicmV1c2Vwb3J0Iiwia2VlcGFsaXZlIiwiZG9udHJvdXRlIiwib29iaW5saW5lIiwiYWNjZXB0Y29ubiIsIm5vZGVsYXkiLCJzbmRidWYiLCJyY3ZidWYiLCJ0eXAiLCJyY3Zsb3dhdCIsInNuZGxvd2F0IiwibGluZ2VyIiwicmN2dGltZW8iLCJzbmR0aW1lbyIsIm1jYXN0X2xvb3AiLCJtY2FzdF90dGwiLCJnZXRvcHQiLCJzZXRvcHQiLCJtY2FzdF9qb2luIiwiaWZuYW1lIiwic291cmNlIiwiYWRkcmVzcyIsIm1jYXN0X2xlYXZlIiwibWFya19ib3VuZCIsInNleHBfb2ZfYWRkcmVzcyQwIiwidl8xNTgiLCJiaW5kX2tlZXBfb3B0cyIsInNvY2thZGRyIiwiYmluZCIsInJldXNlYWRkciQwIiwiYmluZF9pbmV0X2tlZXBfb3B0cyIsImJpbmRfaW5ldCIsImxpc3RlbiIsImJhY2tsb2ciLCJ0dXJuX29mZl9uYWdsZSIsImFjY2VwdF9ub25ibG9ja2luZyIsImFyZzFfMTYzIiwiYXJnMF8xNjIiLCJ2XzE2MCIsInJlczBfMTY0Iiwidl8xNjEiLCJyZXMxXzE2NSIsImFjY2VwdF9pbnRlcnJ1cHRpYmxlIiwiYWNjZXB0IiwiYWNjZXB0X2F0X21vc3RfaW50ZXJydXB0aWJsZSIsImxpbWl0IiwiY29ubmVjdGlvbiIsImNvbm5lY3Rpb25zJDEiLCJsaW1pdCQyIiwibGltaXQkMCIsImNvbm5lY3Rpb25zIiwiY29ubiIsImNvbm5lY3Rpb24kMCIsImNvbm5lY3Rpb25zJDAiLCJsaW1pdCQxIiwiYWNjZXB0X2F0X21vc3QiLCJjb25uZWN0X2ludGVycnVwdGlibGUiLCJzdWNjZXNzIiwiY29ubmVjdCIsImdldHNvY2tuYW1lIiwiZ2V0cGVlcm5hbWUiLCJiaW5kX3RvX2ludGVyZmFjZV9leG4kMCIsInNvY2tldHBhaXIiLCJzMiIsInMxIiwibWFrZV9mZCIsImdldGJ5bmFtZSIsImdldGJ5bmFtZV9leG4iLCJnZXRieWFkZHIiLCJnZXRieWFkZHJfZXhuIiwiaGF2ZV9hZGRyZXNzX2luX2NvbW1vbiIsImdyb3VwJDciLCJiaW5fc2hhcGVfc29ja2V0X2RvbWFpbiIsImJpbl9zaXplX3NvY2tldF9kb21haW4iLCJiaW5fd3JpdGVfc29ja2V0X2RvbWFpbiIsImJpbl93cml0ZXJfc29ja2V0X2RvbWFpbiIsImJpbl9yZWFkX3NvY2tldF9kb21haW4iLCJiaW5fcmVhZF9zb2NrZXRfZG9tYWluJDAiLCJiaW5fcmVhZGVyX3NvY2tldF9kb21haW4iLCJiaW5fc29ja2V0X2RvbWFpbiIsImNvbXBhcmVfc29ja2V0X2RvbWFpbiIsImhhc2hfZm9sZF9zb2NrZXRfZG9tYWluIiwiaGFzaF9zb2NrZXRfZG9tYWluIiwic29ja2V0X2RvbWFpbl9vZl9zZXhwIiwic2V4cF8xNzEiLCJzZXhwX29mX3NvY2tldF9kb21haW4iLCJncm91cCQ4IiwiYmluX3NoYXBlX3NvY2tldF90eXBlIiwiYmluX3NpemVfc29ja2V0X3R5cGUiLCJiaW5fd3JpdGVfc29ja2V0X3R5cGUiLCJiaW5fd3JpdGVyX3NvY2tldF90eXBlIiwiYmluX3JlYWRfc29ja2V0X3R5cGUiLCJiaW5fcmVhZF9zb2NrZXRfdHlwZSQwIiwiYmluX3JlYWRlcl9zb2NrZXRfdHlwZSIsImJpbl9zb2NrZXRfdHlwZSIsImNvbXBhcmVfc29ja2V0X3R5cGUiLCJoYXNoX2ZvbGRfc29ja2V0X3R5cGUiLCJoYXNoX3NvY2tldF90eXBlIiwic29ja2V0X3R5cGVfb2Zfc2V4cCIsInNleHBfMTc3Iiwic2V4cF9vZl9zb2NrZXRfdHlwZSIsImdyb3VwJDkiLCJiaW5fc2hhcGVfc29ja2FkZHIiLCJiaW5fc2l6ZV9zb2NrYWRkciIsInYxJDAiLCJiaW5fd3JpdGVfc29ja2FkZHIiLCJiaW5fd3JpdGVyX3NvY2thZGRyIiwiYmluX3JlYWRfc29ja2FkZHIiLCJiaW5fcmVhZF9zb2NrYWRkciQwIiwiYXJnXzEkMCIsImFyZ18yIiwiYmluX3JlYWRlcl9zb2NrYWRkciIsImJpbl9zb2NrYWRkciIsImNvbXBhcmVfc29ja2FkZHIiLCJhXzE3OCIsImJfMTc5IiwiYV8xODAiLCJiXzE4MSIsImFfMTg0IiwiYV8xODIiLCJiXzE4NSIsImJfMTgzIiwic2V4cF9vZl9zb2NrYWRkciIsImFyZzBfMTg2IiwicmVzMF8xODciLCJhcmcxXzE4OSIsImFyZzBfMTg4IiwicmVzMF8xOTAiLCJyZXMxXzE5MSIsImdyb3VwJDEwIiwiYmluX3NoYXBlX3NvY2thZGRyX2Jsb2NraW5nX3NlIiwiYmluX3NpemVfc29ja2FkZHJfYmxvY2tpbmdfc2V4IiwiYmluX3dyaXRlX3NvY2thZGRyX2Jsb2NraW5nX3NlIiwiYmluX3dyaXRlcl9zb2NrYWRkcl9ibG9ja2luZ19zIiwiYmluX3JlYWRfc29ja2FkZHJfYmxvY2tpbmdfc2V4IiwiYmluX3JlYWRfc29ja2FkZHJfYmxvY2tpbmdfc2V4JDAiLCJiaW5fcmVhZGVyX3NvY2thZGRyX2Jsb2NraW5nX3MiLCJiaW5fc29ja2FkZHJfYmxvY2tpbmdfc2V4cCIsInNvY2thZGRyX2Jsb2NraW5nX3NleHBfb2Zfc2V4cCIsInNleHBfMTk2IiwidGFnXzE5NyIsInNleHBfYXJnc18xOTgiLCJhcmcwXzE5OSIsInJlczBfMjAwIiwic2V4cF9hcmdzXzIwMyIsImFyZzFfMjA1IiwiYXJnMF8yMDQiLCJyZXMwXzIwNiIsInJlczFfMjA3Iiwic2V4cF9vZl9zb2NrYWRkcl9ibG9ja2luZ19zZXhwIiwiYXJnMF8yMDgiLCJyZXMwXzIwOSIsImFyZzFfMjExIiwiYXJnMF8yMTAiLCJyZXMwXzIxMiIsInJlczFfMjEzIiwiZ3JvdXAkMTEiLCJiaW5fc2hhcGVfdCQ3IiwiYmluX3NpemVfdCQ2IiwiYmluX3dyaXRlX3QkNiIsImJpbl93cml0ZXJfdCQ2IiwiYmluX3JlYWRfdCQxMyIsImJpbl9yZWFkX3QkMTQiLCJ2X2FpX2ZhbWlseSIsInZfYWlfc29ja3R5cGUiLCJ2X2FpX3Byb3RvY29sIiwidl9haV9hZGRyIiwidl9haV9jYW5vbm5hbWUiLCJiaW5fcmVhZGVyX3QkNiIsImJpbl90JDYiLCJzZXhwX29mX3QkMTMiLCJhaV9jYW5vbm5hbWVfMjIzIiwiYWlfYWRkcl8yMjEiLCJhaV9wcm90b2NvbF8yMTkiLCJhaV9zb2NrdHlwZV8yMTciLCJhaV9mYW1pbHlfMjE1IiwiYXJnXzIyNCIsImJuZHNfMjE0IiwiYXJnXzIyMiIsImJuZHNfMjE0JDAiLCJhcmdfMjIwIiwiYm5kc18yMTQkMSIsImFyZ18yMTgiLCJibmRzXzIxNCQyIiwiYXJnXzIxNiIsImJuZHNfMjE0JDMiLCJncm91cCQxMiIsImJpbl9zaGFwZV90JDgiLCJiaW5fc2l6ZV90JDciLCJiaW5fd3JpdGVfdCQ3IiwiYmluX3dyaXRlcl90JDciLCJiaW5fcmVhZF90JDE1IiwiYmluX3JlYWRfdCQxNiIsImJpbl9yZWFkZXJfdCQ3IiwiYmluX3QkNyIsInRfb2Zfc2V4cCQ5IiwieF8yMjciLCJhaV9jYW5vbm5hbWUiLCJhaV9hZGRyIiwiYWlfcHJvdG9jb2wiLCJhaV9zb2NrdHlwZSIsImFpX2ZhbWlseSIsInNleHBfb2ZfdCQxNCIsImFpX2Nhbm9ubmFtZV8yMzciLCJhaV9hZGRyXzIzNSIsImFpX3Byb3RvY29sXzIzMyIsImFpX3NvY2t0eXBlXzIzMSIsImFpX2ZhbWlseV8yMjkiLCJhcmdfMjM4IiwiYm5kc18yMjgiLCJhcmdfMjM2IiwiYm5kc18yMjgkMCIsImFyZ18yMzQiLCJibmRzXzIyOCQxIiwiYXJnXzIzMiIsImJuZHNfMjI4JDIiLCJhcmdfMjMwIiwiYm5kc18yMjgkMyIsImdyb3VwJDEzIiwiYmluX3NoYXBlX2dldGFkZHJpbmZvX29wdGlvbiIsImJpbl9zaXplX2dldGFkZHJpbmZvX29wdGlvbiIsImJpbl93cml0ZV9nZXRhZGRyaW5mb19vcHRpb24iLCJ2MSQxIiwiYmluX3dyaXRlcl9nZXRhZGRyaW5mb19vcHRpb24iLCJiaW5fcmVhZF9nZXRhZGRyaW5mb19vcHRpb24iLCJiaW5fcmVhZF9nZXRhZGRyaW5mb19vcHRpb24kMCIsImFyZ18xJDEiLCJiaW5fcmVhZGVyX2dldGFkZHJpbmZvX29wdGlvbiIsImJpbl9nZXRhZGRyaW5mb19vcHRpb24iLCJnZXRhZGRyaW5mb19vcHRpb25fb2Zfc2V4cCIsInNleHBfMjQzIiwidGFnXzI0NCIsInNleHBfYXJnc18yNDUiLCJhcmcwXzI0NiIsInJlczBfMjQ3Iiwic2V4cF9hcmdzXzI1NSIsImFyZzBfMjU2IiwicmVzMF8yNTciLCJzZXhwX2FyZ3NfMjUwIiwiYXJnMF8yNTEiLCJyZXMwXzI1MiIsInNleHBfb2ZfZ2V0YWRkcmluZm9fb3B0aW9uIiwiYXJnMF8yNTgiLCJyZXMwXzI1OSIsImFyZzBfMjYwIiwicmVzMF8yNjEiLCJhcmcwXzI2MiIsInJlczBfMjYzIiwiZ2V0IiwiaG9zdCIsIm9wdGlvbnMiLCJzZXJ2aWNlIiwiZ3JvdXAkMTQiLCJiaW5fc2hhcGVfdCQ5IiwiYmluX3NpemVfdCQ4IiwiYmluX3dyaXRlX3QkOCIsImJpbl93cml0ZXJfdCQ4IiwiYmluX3JlYWRfdCQxNyIsImJpbl9yZWFkX3QkMTgiLCJ2X25pX2hvc3RuYW1lIiwidl9uaV9zZXJ2aWNlIiwiYmluX3JlYWRlcl90JDgiLCJiaW5fdCQ4IiwidF9vZl9zZXhwJDEwIiwieF8yNjYiLCJuaV9zZXJ2aWNlIiwibmlfaG9zdG5hbWUiLCJzZXhwX29mX3QkMTUiLCJuaV9zZXJ2aWNlXzI3MCIsIm5pX2hvc3RuYW1lXzI2OCIsImFyZ18yNzEiLCJibmRzXzI2NyIsImFyZ18yNjkiLCJibmRzXzI2NyQwIiwiZ2V0bmFtZWluZm9fb3B0aW9uX29mX3NleHAiLCJzZXhwXzI3NSIsInNleHBfb2ZfZ2V0bmFtZWluZm9fb3B0aW9uIiwiZ3JvdXAkMTUiLCJiaW5fc2hhcGVfZ2V0bmFtZWluZm9fb3B0aW9uIiwiYmluX3NpemVfZ2V0bmFtZWluZm9fb3B0aW9uIiwiYmluX3dyaXRlX2dldG5hbWVpbmZvX29wdGlvbiIsImJpbl93cml0ZXJfZ2V0bmFtZWluZm9fb3B0aW9uIiwiYmluX3JlYWRfZ2V0bmFtZWluZm9fb3B0aW9uIiwiYmluX3JlYWRfZ2V0bmFtZWluZm9fb3B0aW9uJDAiLCJiaW5fcmVhZGVyX2dldG5hbWVpbmZvX29wdGlvbiIsImJpbl9nZXRuYW1laW5mb19vcHRpb24iLCJnZXQkMCIsImdldGhvc3RuYW1lIiwic2V0dWlkIiwic2V0Z2lkIiwiZ2V0dWlkIiwiZ2V0Z2lkIiwiZ2V0ZWdpZCIsImdldGV1aWQiLCJ0Y2dldGF0dHIiLCJ0Y3NldGF0dHIiLCJzaGVsbCIsImdlY29zIiwicGFzc3dkIiwidF9vZl9zZXhwJDExIiwieF8yNzgiLCJzZXhwX29mX3QkMTYiLCJzaGVsbF8yOTIiLCJkaXJfMjkwIiwiZ2Vjb3NfMjg4IiwiZ2lkXzI4NiIsInVpZF8yODQiLCJwYXNzd2RfMjgyIiwibmFtZV8yODAiLCJhcmdfMjkzIiwiYm5kc18yNzkiLCJhcmdfMjkxIiwiYm5kc18yNzkkMCIsImFyZ18yODkiLCJibmRzXzI3OSQxIiwiYXJnXzI4NyIsImJuZHNfMjc5JDIiLCJhcmdfMjg1IiwiYm5kc18yNzkkMyIsImFyZ18yODMiLCJibmRzXzI3OSQ0IiwiYXJnXzI4MSIsImJuZHNfMjc5JDUiLCJnZXRieW5hbWUkMCIsImdldGJ5bmFtZV9leG4kMCIsImdldGJ5dWlkIiwiZ2V0Ynl1aWRfZXhuIiwiZ2lkJDEiLCJwYXNzd2QkMCIsIm5hbWUkMCIsInRfb2Zfc2V4cCQxMiIsInhfMjk2Iiwic2V4cF9vZl90JDE3IiwibWVtXzMwNCIsImdpZF8zMDIiLCJwYXNzd2RfMzAwIiwibmFtZV8yOTgiLCJhcmdfMzA1IiwiYm5kc18yOTciLCJhcmdfMzAzIiwiYm5kc18yOTckMCIsImFyZ18zMDEiLCJibmRzXzI5NyQxIiwiYXJnXzI5OSIsImJuZHNfMjk3JDIiLCJnZXRieW5hbWUkMSIsImdldGJ5bmFtZV9leG4kMSIsImdldGJ5Z2lkIiwiZ2V0YnlnaWRfZXhuIiwiZ2V0bG9naW4iLCJnZXRpZmFkZHJzIiwid29yZGV4cCIsImdsb2IiLCJlcnJvcl9zb3VyY2VfMDU0IiwiZXJyb3Jfc291cmNlXzA1OSIsInRvb19vbGQiLCJzZXRfdG9vX29sZCIsInRpbWVzX3JlY2VpdmVkX3F1ZXVlIiwiYnl0ZXNfcmVjZWl2ZWRfcXVldWUiLCJ0b29fb2xkJDAiLCJ0aW1lc19yZWNlaXZlZF9xdWV1ZSQwIiwiYnl0ZXNfcmVjZWl2ZWRfcXVldWUkMCIsIm9mX2FfMDAzIiwibWF4aW11bV9hZ2VfMDA3Iiwid3JpdGVyXzAwNSIsImJ5dGVzX3JlY2VpdmVkX2F0X25vd19taW51c19tYSIsInRpbWVzX3JlY2VpdmVkX3F1ZXVlXzAxMyIsImJ5dGVzX3JlY2VpdmVkX3F1ZXVlXzAxMSIsImJ5dGVzX3NlZW5fMDE1IiwidG9vX29sZF8wMTciLCJmb3JfdGhpc190aW1lX3NvdXJjZV8wMTkiLCJjbG9zZWRfMDI1IiwiYWN0aXZlX2NoZWNrc18wMjMiLCJhcmdfMDI2IiwiYm5kc18wMjIiLCJhcmdfMDI0IiwiYm5kc18wMjIkMCIsImFyZ18wMjAiLCJibmRzXzAwNCQwIiwiYm5kc18wMDQkMSIsImFyZ18wMTQiLCJibmRzXzAwNCQyIiwiYm5kc18wMDQkMyIsImFyZ18wMTAiLCJibmRzXzAwNCQ0IiwiYXJnXzAwOCIsImJuZHNfMDA0JDUiLCJibmRzXzAwNCQ2Iiwic2V4cF9vZl9vcGVuX2ZsYWdzIiwidl8wMjgiLCJ2XzAyNyIsImJhY2tpbmdfb3V0X2NoYW5uZWwiLCJzZXRfYmFja2luZ19vdXRfY2hhbm5lbCIsInJhaXNlX3doZW5fY29uc3VtZXJfbGVhdmVzIiwiY29uc3VtZXJfbGVmdCIsImZsdXNoX2F0X3NodXRkb3duX2VsdCIsInNldF9mbHVzaF9hdF9zaHV0ZG93bl9lbHQiLCJiYWNrIiwic2V0X2JhY2siLCJzY2hlZHVsZWRfYmFjayIsInNldF9zY2hlZHVsZWRfYmFjayIsInNjaGVkdWxlZF9ieXRlcyIsInNldF9zY2hlZHVsZWRfYnl0ZXMiLCJzY2hlZHVsZWQiLCJieXRlc193cml0dGVuIiwic2V0X2J5dGVzX3dyaXR0ZW4iLCJieXRlc19yZWNlaXZlZCIsImJhY2tncm91bmRfd3JpdGVyX3N0YXRlIiwic2V0X2JhY2tncm91bmRfd3JpdGVyX3N0YXRlIiwiaWQiLCJiYWNraW5nX291dF9jaGFubmVsJDAiLCJjb25zdW1lcl9sZWZ0JDAiLCJmbHVzaF9hdF9zaHV0ZG93bl9lbHQkMCIsImNsb3NlX3N0YXJ0ZWQkMCIsImJhY2skMCIsInNjaGVkdWxlZF9iYWNrJDAiLCJzY2hlZHVsZWRfYnl0ZXMkMCIsInNjaGVkdWxlZCQwIiwiYnl0ZXNfd3JpdHRlbiQwIiwiYmFja2dyb3VuZF93cml0ZXJfc3RhdGUkMCIsInNleHBfb2Zfd3JpdGVyIiwic2V4cF9vZl90X2ludGVybmFscyIsImlubmVyX21vbml0b3IiLCJiYWNrZ3JvdW5kX3dyaXRlcl9zdG9wcGVkIiwidGltZV9zb3VyY2UiLCJjbG9zZV9zdGF0ZSIsInByb2R1Y2Vyc190b19mbHVzaF9hdF9jbG9zZSIsImNoZWNrX2J1ZmZlcl9hZ2UiLCJsaW5lX2VuZGluZyIsIm9wZW5fZmxhZ3MiLCJzdXBwcmVzc19pbl90ZXN0IiwibW9uaXRvcl9uYW1lX2luX3Rlc3QiLCJ0aW1lX3NvdXJjZSQwIiwibWF0Y2gkNCIsIm1hdGNoJDUiLCJtYXRjaCQ2IiwieF8wMzUiLCJtYXRjaCQ3IiwieF8wMzQiLCJtYXRjaCQ4IiwidiQxIiwidl8wMzEiLCJ2XzAyOSIsIm1hdGNoJDkiLCJ2JDIiLCJtYXRjaCQxMCIsInYkMyIsInNldF9yYWlzZV93aGVuX2NvbnN1bWVyX2xlYXZlcyIsImJ5dGVzX3RvX3dyaXRlIiwiaXNfc3RvcHBlZF9wZXJtYW5lbnRseSIsIm8iLCJlbHQiLCJhXzAzNyIsImJfMDM4IiwiZWx0X2ludmFyaWFudCIsInhfMDQ0IiwiYV8wNDAiLCJiXzA0MSIsImFfMDQyIiwiYl8wNDMiLCJwcmV2IiwieF8wMzkiLCJkdW1teSIsInByb2Nlc3NfYWN0aXZlX2NoZWNrIiwidGltZV9yZWNlaXZlZCIsImJ5dGVzX2FyZV93cml0dGVuIiwiYnl0ZXNfYXJlX3Rvb19vbGQiLCJieXRlc19hcmVfd3JpdHRlbiQwIiwiYnl0ZXNfcmVjZWl2ZWQkMCIsImhhc2hfZm9sZF90IiwiaGFzaCIsInQxIiwidDIiLCJieV90aW1lX3NvdXJjZSIsIm51bV9hY3RpdmVfY2hlY2tzX2ZvciIsInB0IiwiY2hlY2tfbm93IiwiY2hlY2tfaW52YXJpYW50cyIsIm1heGltdW1fYWdlIiwibWF4aW11bV9hZ2UkMCIsImZvcl90aGlzX3RpbWVfc291cmNlIiwiZGVzdHJveSIsInBlcl90aW1lX3NvdXJjZSIsImZsdXNoZWRfb3JfZmFpbGVkX3dpdGhfcmVzdWx0IiwiZWFnZXJfbWFwIiwiZmx1c2hlZF9vcl9mYWlsZWRfdW5pdCIsImZsdXNoZWRfdGltZV9ucyIsImZsdXNoZWRfdGltZSIsImZsdXNoZWQiLCJzZXRfYmFja2luZ19vdXRfY2hhbm5lbCQwIiwic2V0X3N5bmNocm9ub3VzX2JhY2tpbmdfb3V0X2NoIiwid2FpdF91bnRpbF9ub19ieXRlc190b193cml0ZSIsInNldF9zeW5jaHJvbm91c19vdXRfY2hhbm5lbCIsInVzaW5nX3N5bmNocm9ub3VzX2JhY2tpbmdfb3V0XyIsImNsZWFyX3N5bmNocm9ub3VzX291dF9jaGFubmVsIiwid2l0aF9zeW5jaHJvbm91c19iYWNraW5nX291dF9jIiwic2F2ZWRfYmFja2luZ19vdXRfY2hhbm5lbCIsIndpdGhfc3luY2hyb25vdXNfb3V0X2NoYW5uZWwiLCJzZXRfZmQiLCJjb25zdW1lcl9sZWZ0JDEiLCJjbG9zZV9zdGFydGVkJDEiLCJ3cml0ZXJzX3RvX2ZsdXNoX2F0X3NodXRkb3duIiwiZmluYWxfZmx1c2giLCJwcm9kdWNlcnNfZmx1c2hlZCIsImZjIiwiZG9fY2xvc2Vfbm9mbHVzaCIsImNsb3NlX2ludGVybmFsIiwiZm9yY2VfY2xvc2UiLCJjbG9zZV9ub2ZsdXNoIiwic3RvcF9wZXJtYW5lbnRseSIsIm91dGNvbWUiLCJzdG9wcGVkX3Blcm1hbmVudGx5IiwiZGllIiwiYmluX3NoYXBlX2J1ZmZlcl9hZ2VfbGltaXQiLCJiaW5fc2l6ZV9idWZmZXJfYWdlX2xpbWl0IiwiYmluX3dyaXRlX2J1ZmZlcl9hZ2VfbGltaXQiLCJiaW5fd3JpdGVyX2J1ZmZlcl9hZ2VfbGltaXQiLCJiaW5fcmVhZF9idWZmZXJfYWdlX2xpbWl0IiwiYmluX3JlYWRfYnVmZmVyX2FnZV9saW1pdCQwIiwiYmluX3JlYWRlcl9idWZmZXJfYWdlX2xpbWl0IiwiYmluX2J1ZmZlcl9hZ2VfbGltaXQiLCJidWZmZXJfYWdlX2xpbWl0X29mX3NleHAiLCJzZXhwXzA1MiIsImF0b21fMDUwIiwic2V4cF9hcmdzXzA1MyIsImF0b21fMDUwJDAiLCJhcmcwXzA1NiIsInJlczBfMDU3IiwiYnVmZmVyX2FnZV9saW1pdF9vZl9zZXhwJDAiLCJzZXhwXzA1OCIsInNleHBfb2ZfYnVmZmVyX2FnZV9saW1pdCIsInZfMDYwIiwiYnVmX2xlbiIsImJ1ZmZlcl9hZ2VfbGltaXQiLCJ6IiwiYnVmZmVyX2FnZV9saW1pdCQwIiwiYnVmX2xlbiQwIiwiYnVmX2xlbiQxIiwic2V0X2J1ZmZlcl9hZ2VfbGltaXQiLCJjYW5fd3JpdGUiLCJlbnN1cmVfY2FuX3dyaXRlIiwib3Blbl9maWxlIiwiZXhjbHVzaXZlIiwicGFyZW50X21vbml0b3IiLCJnb3RfYnl0ZXMiLCJhZGRfaW92ZWMiLCJjb3VudF9ieXRlc19hc19yZWNlaXZlZCIsInNjaGVkdWxlX3Vuc2NoZWR1bGVkIiwibmVlZF90b19zY2hlZHVsZSIsImR1bW15X2lvdmVjIiwibWtfaW92ZWNzIiwibl9pb3ZlY3MiLCJjb250YWluc19tbWFwcGVkX3JlZiIsImlvdmVjc19sZW4iLCJ0aHJlYWRfaW9fY3V0b2ZmIiwiZmRfY2xvc2VkIiwidXBkYXRlX2FmdGVyX2NvbXBsZXRlZF93cml0ZSIsImZsdXNoZXMiLCJieXRlc193cml0dGVuJDEiLCJieXRlc193cml0dGVuJDIiLCJuZXdfaW92ZWMiLCJzdGFydF93cml0ZSIsImNvbnRhaW5zX21tYXBwZWQiLCJoYW5kbGVfd3JpdGVfcmVzdWx0IiwicmVzMF8wNjgiLCJyZXMxXzA2OSIsInNob3VsZF93cml0ZV9pbl90aHJlYWQiLCJtYXliZV9zdGFydF93cml0ZXIiLCJjYW5fd3JpdGVfZmQiLCJnaXZlX2J1ZiIsImF2YWlsYWJsZSIsImJ1ZiQwIiwid3JpdGVfZ2VuX2ludGVybmFsIiwic3JjX3BvcyIsInNyY19sZW4iLCJhbGxvd19wYXJ0aWFsX3dyaXRlIiwiYmxpdF90b19iaWdzdHJpbmciLCJkc3RfcG9zIiwiZHN0X3BvcyQwIiwicmVtYWluaW5nIiwiZHN0X3BvcyQxIiwiZHN0X3BvcyQyIiwiZHN0JDAiLCJ3cml0ZV9nZW5fdW5jaGVja2VkIiwibGVuZ3RoIiwid3JpdGVfYnl0ZXMiLCJ3cml0ZV9iaWdzdHJpbmciLCJ0b19mb3JtYXR0ZXIiLCJzdHIiLCJ3cml0ZV9jaGFyIiwiYyIsIm5ld2xpbmUiLCJsaW5lX2VuZGluZyQwIiwid3JpdGVfc2V4cF9pbnRlcm5hbCIsInRlcm1pbmF0ZV93aXRoIiwiaHVtIiwic3BhY2VfaXNfbmVlZGVkIiwic2NoZWR1bGVfaW92ZWMiLCJkZXN0cm95X29yX2tlZXAiLCJzY2hlZHVsZV9iaWdzdHJpbmciLCJic3RyIiwid3JpdGVfYmluX3Byb3QiLCJzd19hcmciLCJ0b3RfbGVuIiwic3RhcnRfcG9zIiwic2VuZCIsInNjaGVkdWxlX2lvdmVjJDAiLCJzY2hlZHVsZV9pb3ZlY3MiLCJzY2hlZHVsZV9iaWdzdHJpbmckMCIsInNjaGVkdWxlX2JpZ3N1YnN0cmluZyIsImJpZ3N1YnN0cmluZyIsInNjaGVkdWxlX2lvYnVmX3BlZWsiLCJpb2J1ZiIsInNjaGVkdWxlX2lvYnVmX2NvbnN1bWUiLCJsZW4kMCIsIndyaXRlX2dlbiIsIndyaXRlX2J5dGVzJDAiLCJ3cml0ZSQwIiwid3JpdGVfbGluZSIsIndyaXRlZiIsIndyaXRlX3NleHAiLCJ0ZXJtaW5hdGVfd2l0aCQwIiwid3JpdGVfc2V4cF9pbnRlcm5hbCQwIiwid3JpdGVfaW9idWYiLCJpb2J1ZiQwIiwid3JpdGVfYmlnc3RyaW5nJDAiLCJ3cml0ZV9iaWdzdWJzdHJpbmciLCJ3cml0ZV9zdWJzdHJpbmciLCJzdWJzdHJpbmciLCJ3cml0ZV9ieXRlIiwid3JpdGVfY2hhciQwIiwibmV3bGluZSQwIiwid3JpdGVfYmluX3Byb3Rfbm9fc2l6ZV9oZWFkZXIiLCJlbmRfcG9zIiwid3JpdHRlbiIsIndyaXRlX2RpcmVjdCIsIndyaXRlX2dlbl93aG9sZSIsInN0ZG91dF9hbmRfc3RkZXJyX2JlaGF2ZV9uaWNlbCIsInN0ZG91dF9hbmRfc3RkZXJyIiwic3Rkb3V0JDAiLCJkZXZfYW5kX2lubyIsInN0YXRzIiwieF8wNzQiLCJ4XzA3MyIsInRfMDc4IiwidF8wNzciLCJ0XzA4MCIsInRfMDc5Iiwic3RkZXJyJDAiLCJzdGRlcnIkMSIsInVzZV9zeW5jaHJvbm91c19zdGRvdXRfYW5kX3N0ZCIsInRzX2FuZF9jaGFubmVscyIsInNhdmVkX3N0ZGVyciIsInBpcGVfdyIsInBpcGVfciIsIm1ha2Vfd3JpdGVyX2JlaGF2ZV9uaWNlbHlfaW5fcCIsImJlaGF2ZV9uaWNlbHlfaW5fcGlwZWxpbmUiLCJ3cml0ZXJzIiwibCIsIndpdGhfZmlsZV9hdG9taWMiLCJ0ZW1wX2ZpbGUiLCJkb19mc3luYyIsInJlcGxhY2Vfc3BlY2lhbCIsImN1cnJlbnRfZmlsZV9wZXJtaXNzaW9ucyIsImluaXRpYWxfcGVybWlzc2lvbnMiLCJwJDAiLCJ1bmxpbmtfcmVzdWx0IiwiY2xvc2VfcmVzdWx0Iiwib3VyX2Vycm9yIiwib3VyX2Vycm9yJDAiLCJmX2Vycm9yIiwib3VyX2Vycm9yJDEiLCJjbGVhbnVwX2Vycm9yIiwiaW5pdGlhbF9lcnJvciIsImZfcmVzdWx0IiwidGVtcF9maWxlJDAiLCJwcmVmaXgiLCJzYXZlIiwiY29udGVudHMiLCJzYXZlX2xpbmVzIiwibGluZXMiLCJsaW5lIiwic2F2ZV9zZXhwIiwic2F2ZV9zZXhwc19jb252IiwieHMiLCJzZXhwX29mX3giLCJzYXZlX3NleHBzIiwic2V4cHMiLCJzYXZlX2Jpbl9wcm90IiwiYmluX3dyaXRlciIsIndpdGhfZmx1c2hlZF9hdF9jbG9zZSIsInByb2R1Y2Vyc190b19mbHVzaF9hdF9jbG9zZV9lbCIsIm1ha2VfdHJhbnNmZXIiLCJtYXhfbnVtX3ZhbHVlc19wZXJfcmVhZCIsIndyaXRlX2YiLCJjb25zdW1lciIsImVuZF9vZl9waXBlX3IiLCJtYXhfcXVldWVfbGVuZ3RoIiwicmVhZF9yZXN1bHQiLCJ0cmFuc2ZlciIsImNvbnQiLCJ0cmFuc2ZlciQwIiwic2V0X2J5dGVzX3JlY2VpdmVkIiwic2V0X2J5dGVzX3dyaXR0ZW4kMCIsImVycm9yX3NvdXJjZV8wMDciLCJlcnJvcl9zb3VyY2VfMDIwIiwiZXJyb3Jfc291cmNlXzAyMiIsImxpbmVfZGVsaW1pdGVyX3ByZWQiLCJzaXplX29mX2EiLCJ3cml0ZV9hIiwiYmluX3dyaXRlcl9hIiwib2ZfYSIsImJpbl9yZWFkZXJfYSIsInZ0YWciLCJiaW5fYSIsIm9mX2FfMDAxIiwic2V4cF8wMDUiLCJhdG9tXzAwMyIsInNleHBfYXJnc18wMDYiLCJhdG9tXzAwMyQwIiwic2V4cF8wMTEiLCJvZl9hXzAxMyIsInZfMDE0IiwiYSQwIiwibWFwIiwicmV0dXJuJDAiLCJiaW5fc2l6ZV90JDAiLCJiaW5fd3JpdGVfdCQwIiwiYmluX3dyaXRlcl90JDAiLCJiaW5fcmVhZF90JDEiLCJiaW5fcmVhZF90JDIiLCJiaW5fcmVhZGVyX3QkMCIsImJpbl90JDAiLCJ0X29mX3NleHAkMyIsInNleHBfMDE4IiwiYXRvbV8wMTYiLCJhdG9tXzAxNiQwIiwic2V4cF8wMjEiLCJ2XzAyNCIsImxhc3RfcmVhZF90aW1lIiwiY2xvc2VfbWF5X2Rlc3Ryb3lfYnVmIiwiYnl0ZXNfcmVhZCIsInVubGVzc190ZXN0aW5nIiwibWF0Y2gkMyIsImJ1Zl9sZW4kMiIsImVtcHR5X2J1ZiIsIndpdGhfcmVhZGVyX2V4Y2x1c2l2ZSIsInJlYWRfc3lzY2FsbF93aXRoX3RpbWVzdGFtcCIsImdldF9kYXRhIiwiZW9mIiwiY2FuX3JlYWRfZmQiLCJvcGVuX2ZsYWdzJDAiLCJlYmFkZiIsInJlYWRfdGltZSIsIm1heWJlX2dyb3dfYnVmX2xlbiIsIm5ld19idWZfbGVuIiwibmV3X2J1ZiIsImdldF9kYXRhX3VudGlsIiwiYXZhaWxhYmxlX2F0X2xlYXN0Iiwid2l0aF9ub25lbXB0eV9idWZmZXIiLCJva19vcl9lb2YiLCJ3aXRoX25vbmVtcHR5X2J1ZmZlciQwIiwiZm9yY2VfcmVmaWxsIiwiY29uc3VtZSIsImFtb3VudCIsInNleHBfb2ZfaGFuZGxlX2NodW5rX3Jlc3VsdCIsIm9mX2FfMDMxIiwidl8wMzgiLCJhcmcxXzA0MSIsImFyZzBfMDQwIiwicmVzMF8wNDIiLCJyZXMxXzA0MyIsInZfMDM5Iiwidl8wMzIiLCJ2XzAzMyIsImFyZzFfMDM1IiwiYXJnMF8wMzQiLCJyZXMwXzAzNiIsInJlczFfMDM3Iiwic2V4cF9vZl9yZWFkX29uZV9jaHVua19hdF9hX3RpIiwib2ZfYV8wNDQiLCJ2XzA0NSIsInZfMDQ2Iiwic2V4cF9vZl9jb25zdW1lZCIsInZfMDQ3IiwiYXJnMV8wNTAiLCJhcmcwXzA0OSIsInJlczBfMDUxIiwicmVzMV8wNTIiLCJ2XzA0OCIsInJlYWRfb25lX2NodW5rX2F0X2FfdGltZSIsImhhbmRsZV9jaHVuayIsImZpbmFsX3Jlc3VsdCIsImNvbnN1bWVkJDAiLCJuZWVkIiwiY29uc3VtZWQiLCJuZWVkJDEiLCJuZXdfbGVuIiwibmVlZCQwIiwicmVzdWx0JDAiLCJzZXhwX29mX2hhbmRsZV9pb2J1Zl9yZXN1bHQiLCJvZl9hXzA1MyIsInZfMDU0IiwicmVhZF9vbmVfaW9idWZfYXRfYV90aW1lIiwiaGFuZGxlX3Jlc3VsdCIsInJlYWRfYXZhaWxhYmxlIiwicmVhbGx5X3JlYWQiLCJhbW91bnRfcmVhZCIsInJlYWRfc3Vic3RyaW5nX2F2YWlsYWJsZSIsInJlYWRfc3Vic3RyaW5nIiwicmVhbGx5X3JlYWRfc3Vic3RyaW5nIiwicmVhZF9iaWdzdWJzdHJpbmciLCJyZWFsbHlfcmVhZF9iaWdzdWJzdHJpbmciLCJyZWFsbHlfcmVhZF9iaWdzdHJpbmciLCJiaWdzdHJpbmciLCJwZWVrX2F2YWlsYWJsZSIsInBlZWsiLCJyZWFkX2NoYXIiLCJmaXJzdF9jaGFyIiwiY2giLCJyZWFkX3VudGlsX2dlbiIsImtlZXBfZGVsaW0iLCJtYXgiLCJrIiwidG90YWwiLCJjb25jYXRfaGVscGVyIiwic3MiLCJsc3QiLCJtYXgkMCIsIm5lZWRfbW9yZV9ieXRlc190b19leGNlZWRfbWF4IiwiYXZhaWxhYmxlJDAiLCJhbW91bnRfY29uc3VtZWQiLCJ0b3RhbCQwIiwic3MkMCIsInNzJDEiLCJyZWFkX3VudGlsIiwicHJlZCIsInJlYWRfbGluZV9nZW4iLCJyZWFkX2xpbmUiLCJ6JDAiLCJyZWFsbHlfcmVhZF9saW5lIiwid2FpdF90aW1lIiwiZmlsbF9yZXN1bHQiLCJzcGFjZSIsImdlbl9yZWFkX3NleHAiLCJwYXJzZV9wb3MiLCJzZXhwX2tpbmQiLCJwYXJzZV9mdW4iLCJwYXJzZV9wb3MkMCIsInNleHAkMCIsInBhcnNlX2Z1biQwIiwicGFyc2UiLCJwYXJzZV9wb3MkMSIsImdlbl9yZWFkX3NleHBzIiwicmVhZF9zZXhwcyIsInJlYWRfYW5ub3RhdGVkX3NleHBzIiwidW5leHBlY3RlZF9wb3MiLCJiaW5fdHlwZSIsIm9sZF9wb3MiLCJyZWFkX2xlbiIsIm5ld19wb3MiLCJzaXplX2Vycm9yIiwicmVhZF9yYXciLCJiaW5fcHJvdF9yZWFkZXIiLCJoZWFkZXJfcG9zIiwibWVzc2FnZV9zaXplIiwiYnl0ZXNfbmVlZGVkIiwibWVzc2FnZV9wb3MiLCJwZWVrX29yX3JlYWRfYmluX3Byb3QiLCJwZWVrX29yX3JlYWQiLCJtYXhfbGVuIiwibXNnIiwiYXJnMV8wNTciLCJyZXMwXzA1OCIsInJlczFfMDU5IiwibGVuX3dpdGhfaGVhZGVyIiwibWF4X2xlbl93aXRoX2hlYWRlciIsInJlYWRfbG9vcCIsIm5lZWRfbWVzc2FnZSIsIml0ZXJfYmluX3Byb3QiLCJjaHVua19wb3MiLCJieXRlcyIsImRhdGEiLCJyZWFkX21hcnNoYWxfcmF3IiwiZW9mbiIsImhlYWRlciIsInN1YiIsInJlYWRfbWFyc2hhbCIsInJlYWRfYWxsIiwicmVhZF9vbmUiLCJjbG9zZV93aGVuX2ZpbmlzaGVkIiwib25lIiwic2J1ZiIsInJlY3YiLCJsZW5ndGhfc3RyIiwic2V4cF9vZl9oYW5kbGVfY2h1bmtfcmVzdWx0JDAiLCJzZXhwX29mX2hhbmRsZV9pb2J1Zl9yZXN1bHQkMCIsInNleHBfb2ZfcmVhZF9vbmVfY2h1bmtfYXRfYV90aSQwIiwiY2xvc2UkMCIsImlkJDAiLCJieXRlc19yZWFkJDAiLCJpc19jbG9zZWQkMCIsImxhc3RfcmVhZF90aW1lJDAiLCJvZl9pbl9jaGFubmVsJDAiLCJvcGVuX2ZpbGUkMCIsInN0ZGluJDAiLCJ3aXRoX2Nsb3NlJDAiLCJ3aXRoX2ZpbGUkMCIsInVzZSIsInJlYXNvbiIsImZpbmlzaGVkX3JlYWQiLCJkb19yZWFkX25vdyIsImJ5dGVzX2F2YWlsYWJsZSIsInBlZWtfYXZhaWxhYmxlJDAiLCJyZWFkX2F2YWlsYWJsZSQwIiwiZG9fcmVhZCIsInBlZWskMCIsInJlYWQkMCIsInJlYWRfY2hhciQwIiwicmVhZF9zdWJzdHJpbmckMCIsInJlYWRfYmlnc3Vic3RyaW5nJDAiLCJyZWFkX29uZV9jaHVua19hdF9hX3RpbWUkMCIsInJlYWRfb25lX2lvYnVmX2F0X2FfdGltZSQwIiwicmVhbGx5X3JlYWQkMCIsInJlYWxseV9yZWFkX3N1YnN0cmluZyQwIiwicmVhbGx5X3JlYWRfYmlnc3Vic3RyaW5nJDAiLCJyZWFkX2xpbmUkMCIsInJlYWxseV9yZWFkX2xpbmUkMCIsImRvX3JlYWRfayIsInJlYWRfayIsIm1ha2VfcmVzdWx0IiwicmVhZF91bnRpbCQwIiwicmVhZF91bnRpbF9ib3VuZGVkIiwicmVhZF9zZXhwIiwicmVhZF9zZXhwcyQwIiwicmVhZF9hbm5vdGF0ZWRfc2V4cHMkMCIsInBlZWtfb3JfcmVhZF9iaW5fcHJvdCQwIiwicGVla19iaW5fcHJvdCIsInJlYWRfYmluX3Byb3QiLCJpdGVyX2Jpbl9wcm90JDAiLCJpdGVyX2Jpbl9wcm90X2V4biIsInJlYWRfYmluX3Byb3RfaW50b19waXBlIiwiZWxlbWVudCIsInJlYWRfbWFyc2hhbF9yYXckMCIsInJlYWRfbWFyc2hhbCQwIiwicmVjdiQwIiwicmVhZF9hbGwkMCIsImxpbmVzJDAiLCJjb250ZW50cyQwIiwiZmlsZV9jb250ZW50cyIsImZpbGVfbGluZXMiLCJvZmZzZXQiLCJsdGVsbCIsImZkX29mZnNldCIsImdldF9lcnJvciIsImFfb2Zfc2V4cCIsImFubm90YXRlZF9zZXhwIiwiYW5ub3RhdGVkX3NleHAkMCIsInVuZXhwZWN0ZWRfZXJyb3IiLCJhcmcxXzA3NyIsImFyZzBfMDc2IiwicmVzMF8wNzgiLCJyZXMxXzA3OSIsImJhZF9zZXhwIiwiZXhjIiwiYmFkX2Fubm90YXRlZF9zZXhwIiwiYXJnM18wODMiLCJhcmcyXzA4MiIsImFyZzFfMDgxIiwiYXJnMF8wODAiLCJyZXMwXzA4NCIsInJlczFfMDg1IiwicmVzMl8wODYiLCJyZXMzXzA4NyIsImdlbl9sb2FkX2V4biIsImNvbnZlcnQiLCJtYXlfbG9hZF9maWxlX211bHRpcGxlX3RpbWVzIiwibG9hZCIsInBhcnNlX3N0YXRlIiwiZXJyX21zZyIsImFyZzFfMDg5IiwiYXJnMF8wODgiLCJyZXMwXzA5MCIsInJlczFfMDkxIiwiZ2V0X2xvYWRfcmVzdWx0X2V4biIsImdlbl9sb2FkX3NleHBfZXhuIiwibXVsdGlwbGUiLCJyZXMwXzA5NiIsInJlczFfMDk3IiwiYW5ub3Rfc2V4cHMiLCJhbm5vdF9zZXhwIiwibG9hZF9zZXhwX2V4biIsImxvYWRfYW5ub3RhdGVkX3NleHBfZXhuIiwiZ2VuX2xvYWRfc2V4cCIsImxvYWRfc2V4cCIsImxvYWRfYW5ub3RhdGVkX3NleHAiLCJnZW5fbG9hZF9zZXhwc19leG4iLCJsb2FkX3NleHBzX2V4biIsImxvYWRfYW5ub3RhdGVkX3NleHBzX2V4biIsImdlbl9sb2FkX3NleHBzIiwibG9hZF9zZXhwcyIsImxvYWRfYW5ub3RhdGVkX3NleHBzIiwiZHJhaW4iLCJsb2FkX2Jpbl9wcm90IiwiYmluX3JlYWRlciIsImxvYWRfYmluX3Byb3RfZXhuIiwib2ZfcGlwZSIsIndyaXRlcl9mZCIsInJlYWRlcl9mZCIsIm9mX3N0cmluZyIsImFyZzJfMDA0IiwiYXJnMV8wMDMiLCJhcmcwXzAwMiIsInJlczJfMDA3IiwiY2xvc2VkX2FuZF9mbHVzaGVkX2Rvd25zdHJlYW0iLCJzcGxpY2VfcmVzdWx0IiwiZnJvbSIsImJ1ZmZlciIsInNwbGljZSIsInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haSIsIml2Iiwic2V4cF9vZl9pbmV0Iiwic2V4cF9vZl91bml4IiwieF8wMDIiLCJyZW1vdGVfYWRkcmVzcyIsImNyZWF0ZV9sb2NhbF9hZGRyZXNzIiwiYmluZF90b19hZGRyZXNzIiwiYmluZF90b19wb3J0IiwiaW5ldF9hZGRyIiwicG9ydCQwIiwib2ZfaG9zdF9hbmRfcG9ydCIsIm9mX2ZpbGUiLCJvZl9pbmV0X2FkZHJlc3MiLCJvZl91bml4X2FkZHJlc3MiLCJyZWFkZXJfd3JpdGVyX29mX3NvY2siLCJyZWFkZXJfYnVmZmVyX3NpemUiLCJ3cml0ZXJfYnVmZmVyX3NpemUiLCJjb25uZWN0X3NvY2siLCJzb2NrZXQiLCJ3aGVyZV90b19jb25uZWN0IiwidGltZW91dCQxIiwiaW50ZXJydXB0JDAiLCJpbnRlcnJ1cHQkMSIsInMkMCIsImFkZHJlc3MkMCIsImxvY2FsX2ludGVyZmFjZSIsImNvbGxlY3RfZXJyb3JzIiwiY2xvc2VfY29ubmVjdGlvbl92aWFfcmVhZGVyX2FuIiwiZm9yY2VfY2xvc2VfZXZlbnQiLCJ3aXRoX2Nvbm5lY3Rpb24iLCJyZXMwXzAwNCIsInJlczBfMDA2Iiwib2ZfYWRkcmVzc18wMDciLCJvZl9saXN0ZW5pbmdfb25fMDA4IiwibGlzdGVuaW5nX29uXzAxNCIsImFkZHJlc3NfMDEyIiwic29ja2V0X3R5cGVfMDEwIiwiYm5kc18wMDkiLCJhcmdfMDEzIiwiYm5kc18wMDkkMCIsImJuZHNfMDA5JDEiLCJzZXhwX29mX2luZXQkMCIsInhfMDE2Iiwic2V4cF9vZl91bml4JDAiLCJ4XzAxNyIsInNvY2tldF90eXBlIiwiYmluZF90byIsIm9mX3BvcnQiLCJvZl9wb3J0X2Nob3Nlbl9ieV9vcyIsIm9mX2ZpbGUkMCIsImNsaWVudF9hZGRyZXNzIiwiY2xpZW50X2FkZHJlc3MkMCIsIm9mX2FkZHJlc3NfMDE4IiwiY2xpZW50X2FkZHJlc3NfMDIyIiwiY2xpZW50X3NvY2tldF8wMjAiLCJibmRzXzAxOSIsImJuZHNfMDE5JDAiLCJsb2dfdGhyZXNob2xkIiwibWF4X2Nvbm5lY3Rpb25fbGltaXRfbG9nZ2VyIiwic2V0X21heF9jb25uZWN0aW9uX2xpbWl0X2xvZ2dlIiwibG9nX2F0X2xpbWl0Iiwic2V0X2Ryb3BfaW5jb21pbmdfY29ubmVjdGlvbnMiLCJtYXhfYWNjZXB0c19wZXJfYmF0Y2giLCJtYXhfY29ubmVjdGlvbnMiLCJtYXhfYWNjZXB0c19wZXJfYmF0Y2gkMCIsIm1heF9jb25uZWN0aW9ucyQwIiwib2ZfYWRkcmVzc18wMjUiLCJvZl9saXN0ZW5pbmdfb25fMDI2IiwiY29ubmVjdGlvbnNfMDQxIiwibWF4X2FjY2VwdHNfcGVyX2JhdGNoXzAzOSIsIm1heF9jb25uZWN0aW9uc18wMzciLCJvbl9oYW5kbGVyX2Vycm9yXzAzMiIsImxpc3RlbmluZ19vbl8wMzAiLCJzb2NrZXRfMDI4IiwiYWNjZXB0X2lzX3BlbmRpbmdfMDQzIiwiZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc18wNDUiLCJjbG9zZV9maW5pc2hlZF9hbmRfaGFuZGxlcnNfZGUiLCJibmRzXzAyNyIsImJuZHNfMDI3JDAiLCJibmRzXzAyNyQxIiwiYm5kc18wMjckMiIsImJuZHNfMDI3JDMiLCJibmRzXzAyNyQ0IiwiYm5kc18wMjckNSIsImJuZHNfMDI3JDYiLCJibmRzXzAyNyQ3IiwiYm5kc18wMjckOCIsImlzX2Ryb3BwaW5nX2luY29taW5nX2Nvbm5lY3RpbyIsIm51bV9jb25uZWN0aW9ucyIsInNleHBfb2ZfaW5ldCQxIiwieF8wNDkiLCJzZXhwX29mX3VuaXgkMSIsInhfMDUwIiwibGlzdGVuaW5nX29uX2FkZHJlc3MiLCJpbnZhcmlhbnRfYWRkcmVzcyIsImNsaWVudF9hZGRyZXNzX2Z1biIsInhfMDI0IiwibnVtX2Nvbm5lY3Rpb25zJDAiLCJhcmcxXzA1MiIsImFyZzBfMDUxIiwicmVzMF8wNTMiLCJyZXMxXzA1NCIsImNsb3NlX2V4aXN0aW5nX2Nvbm5lY3Rpb25zIiwibWF5YmVfYWNjZXB0IiwiYXZhaWxhYmxlX3Nsb3RzIiwiYWNjZXB0X3Jlc3VsdCIsImNvbm5zIiwiY2xpZW50X3NvY2tldCIsImNvbm5lY3Rpb25zX2VsdCIsInNvY2siLCJsYXN0X2xvZ2dlZCIsImNyZWF0ZV9mcm9tX3NvY2tldCIsIm9uX2hhbmRsZXJfZXJyb3IiLCJ3aGVyZV90b19saXN0ZW4iLCJoYW5kbGVfY2xpZW50IiwiZHJvcF9pbmNvbWluZ19jb25uZWN0aW9ucyIsImdldF9tYXhfY29ubmVjdGlvbnNfbGltaXQiLCJtYXliZV9zb2NrZXQiLCJoYW5kbGVfZXhuIiwicmV0cmllc19hdHRlbXB0ZWRfdXBvbl9hZGRyX2luIiwiYXV4X2JpbmRfYW5kX2xpc3Rlbl9tYXliZV9yZXRyIiwiY3JlYXRlX3NvY2tfbm9uX2luZXRfaW50ZXJuYWwiLCJzb2NrZXRfY3JlYXRvciIsImNyZWF0ZV9zb2NrX2luZXRfaW50ZXJuYWwiLCJzb2NrZXQkMCIsInNvY2tldCQxIiwicmV0cmllc19hdHRlbXB0ZWRfdXBvbl9hZGRyX2luJDAiLCJjcmVhdGVfc29ja19pbmV0X2ludGVybmFsX2FzeW4iLCJjcmVhdGVfc29ja19pbnRlcm5hbCIsImlzX2luZXQiLCJjcmVhdGVfc29jayIsImNyZWF0ZV9zb2NrX2luZXQiLCJjcmVhdGVfaW5ldCIsImNyZWF0ZSQyIiwiZXJyb3Jfc291cmNlXzAzNiIsIndhaXRfMDE5IiwiZW52XzAxNyIsIndvcmtpbmdfZGlyXzAxNSIsImFyZ3NfMDEzIiwicHJvZ18wMTEiLCJzdGRlcnJfMDA5Iiwic3Rkb3V0XzAwNyIsInN0ZGluXzAwNSIsInBpZF8wMDMiLCJibmRzXzAwMiIsImJuZHNfMDAyJDAiLCJibmRzXzAwMiQxIiwiYm5kc18wMDIkMiIsImJuZHNfMDAyJDMiLCJibmRzXzAwMiQ0IiwiYm5kc18wMDIkNSIsImJuZHNfMDAyJDYiLCJhcmdfMDA0IiwiYm5kc18wMDIkNyIsImFyZ3YwIiwicHJvZ19zZWFyY2hfcGF0aCIsIndyaXRlX3RvX3N0ZGluIiwid29ya2luZ19kaXIiLCJzZXRwZ2lkIiwiYXJnM18wMjciLCJhcmcyXzAyNiIsInJlczBfMDI4Iiwidl8wMjEiLCJyZXMxXzAyOSIsInZfMDIyIiwicmVzMl8wMzAiLCJyZXMzXzAzMSIsIndyaXRlX3RvX3N0ZGluJDAiLCJzdHJpbmciLCJhXzAzMyIsImJfMDM0IiwieF8wMzciLCJleGl0X3N0YXR1cyIsImV4aXRfc3RhdHVzXzA0MyIsInN0ZGVycl8wNDEiLCJzdGRvdXRfMDM5IiwiYm5kc18wMzgiLCJibmRzXzAzOCQwIiwiYm5kc18wMzgkMSIsImNvbGxlY3Rfb3V0cHV0X2FuZF93YWl0Iiwic3RkZXJyXzA2NyIsInN0ZG91dF8wNjUiLCJleGl0X3N0YXR1c18wNjMiLCJlbnZfMDYwIiwid29ya2luZ19kaXJfMDU0IiwiYXJnc18wNTIiLCJwcm9nXzA1MCIsImFyZ18wNjgiLCJibmRzXzA0OSIsImFyZ18wNjYiLCJibmRzXzA0OSQwIiwiYXJnXzA2NCIsImJuZHNfMDQ5JDEiLCJibmRzXzA0OSQyIiwiYXJnXzA2MiIsImJuZF8wNjEiLCJ2XzA1NSIsImJuZF8wNTYiLCJibmRzXzA0OSQzIiwiYm5kc18wNDkkNCIsImJuZHNfMDQ5JDUiLCJoYW5kbGVfZXhpdF9zdGF0dXMiLCJhY2NlcHRfbm9uemVyb19leGl0IiwiY29sbGVjdF9zdGRvdXRfYW5kX3dhaXQiLCJleGl0X3N0YXR1cyQwIiwibWFwX2NvbGxlY3QiLCJjb2xsZWN0IiwiY29sbGVjdF9zdGRvdXRfYW5kX3dhaXRfZXhuIiwiY29sbGVjdF9zdGRvdXRfbGluZXNfYW5kX3dhaXQiLCJjb2xsZWN0X3N0ZG91dF9saW5lc19hbmRfd2FpdF8iLCJtYXBfcnVuIiwicnVuX2V4biIsInJ1bl9saW5lcyIsInJ1bl9saW5lc19leG4iLCJydW5fZXhwZWN0X25vX291dHB1dCIsInhfMDcyIiwibm9uX2VtcHR5X291dHB1dCIsInJ1bl9leHBlY3Rfbm9fb3V0cHV0X2V4biIsInRyYW5zZmVyX2FuZF9jbG9zZSIsImZvcndhcmRfb3V0cHV0X2FuZF93YWl0IiwibGV0X3N5bnRheF8wNzMiLCJsZXRfc3ludGF4XzA3NCIsImxldF9zeW50YXhfMDc1IiwibGV0X3N5bnRheF8wNzYiLCJ4XzA3OCIsImZvcndhcmRfb3V0cHV0X2FuZF93YWl0X2V4biIsInJ1bl9mb3J3YXJkaW5nX3dpdGhfc3BsaWNlZF9mZCIsInJ1bl9mb3J3YXJkaW5nX3dpdGhfc2hhcmVkX2ZkcyIsInhfMDk5IiwieF8wOTciLCJsZXRfc3ludGF4XzA4MCIsImxldF9zeW50YXhfMDgxIiwiYXJnM18wOTIiLCJhcmcyXzA5MSIsImFyZzFfMDkwIiwiYXJnMF8wODkiLCJyZXMwXzA5MyIsInZfMDg2IiwicmVzMV8wOTQiLCJ2XzA4NyIsInJlczJfMDk1Iiwidl8wODgiLCJyZXMzXzA5NiIsImxldF9zeW50YXhfMDgzIiwibGV0X3N5bnRheF8wODQiLCJydW5fZm9yd2FyZGluZyIsImNoaWxkX2ZkcyIsInJ1bl9mb3J3YXJkaW5nX2V4biIsInNlbmRfc2lnbmFsX2ludGVybmFsIiwic2VuZF9zaWduYWxfY29tcGF0Iiwic2VuZF9zaWduYWxfY29tcGF0X2V4biIsInNlbmRfc2lnbmFsIiwiZXJyb3Jfc291cmNlXzAwMiIsImZpZm8iLCJjaGFyJDAiLCJ0b3RhbF8wMDUiLCJjaGFyXzAwNyIsImZpZm9fMDA5IiwiZmlsZV8wMTEiLCJzb2NrZXRfMDEzIiwidXBkYXRlIiwiZG9fcHJpbnRmIiwicHJpbnRmIiwiZm10IiwiZnByaW50ZiIsImVwcmludGYiLCJwcmludF9jaGFyIiwicHJlcnJfY2hhciIsInByaW50X3N0cmluZyIsInByZXJyX3N0cmluZyIsInByaW50X25ld2xpbmUiLCJwcmVycl9uZXdsaW5lIiwicHJpbnRfZW5kbGluZSIsInByZXJyX2VuZGxpbmUiLCJwcmludF9pbnQiLCJwcmVycl9pbnQiLCJwcmludF9mbG9hdCIsInByZXJyX2Zsb2F0IiwibWFjaCIsImVwcmludF9zIiwiZ2V0X2FyZ3YiLCJleGVjdXRhYmxlX25hbWUiLCJ3cmFwMSIsIngxIiwiY29tbWFuZCIsImNvbW1hbmRfZXhuIiwicXVvdGUiLCJjb25jYXRfcXVvdGVkIiwiaG9tZV9kaXJlY3RvcnkiLCJsc19kaXIiLCJyZWFkZGlyIiwieDIiLCJ3cmFwX2lzIiwiZm9sbG93X3N5bWxpbmtzIiwiZmlsZV9leGlzdHMiLCJmaWxlX2V4aXN0c19leG4iLCJpc19kaXJlY3RvcnkiLCJpc19kaXJlY3RvcnlfZXhuIiwiaXNfZmlsZSIsImlzX2ZpbGVfZXhuIiwid2hlbl9maWxlX2NoYW5nZXMiLCJsYXN0X3JlcG9ydGVkX210aW1lIiwic3RhdF9yZXN1bHQiLCJsYXN0X3JlcG9ydGVkX210aW1lJDAiLCJzaG91bGRfcmVwb3J0Iiwid2hlbl9maWxlX2V4aXN0cyIsImNfaW50X3NpemUiLCJleGVjdXRpb25fbW9kZSIsImludF9zaXplIiwiaW50ZXJhY3RpdmUiLCJvY2FtbF92ZXJzaW9uIiwib3NfdHlwZSIsIndvcmRfc2l6ZSIsIm9wYXF1ZV9pZGVudGl0eSIsImJpZ19lbmRpYW4iLCJzY2hlZHVsZSIsInNjaGVkdWxlJDAiLCJ3aXRoaW4iLCJ3aXRoaW4kMCIsImJwcmludGYiLCJmYWlsd2l0aGYiLCJzaGFkb3ciLCJpZnByaW50ZiIsImludmFsaWRfYXJnZiIsImticHJpbnRmIiwia2ZwcmludGYiLCJrc3ByaW50ZiIsInNwcmludGYiLCJvdmVyd3JpdGUxIiwib3ZlcndyaXRlMiIsIm92ZXJ3cml0ZTMiLCJvdmVyd3JpdGU0IiwiY2xvc2VfaW5fbm9lcnIiLCJjbG9zZV9pbiIsImNsb3NlX291dF9ub2VyciIsImNsb3NlX291dCIsImZsdXNoX2FsbCIsImZwcmludGYkMCIsImlmcHJpbnRmJDAiLCJpbl9jaGFubmVsX2xlbmd0aCIsImlucHV0X2JpbmFyeV9pbnQiLCJpbnB1dF9ieXRlIiwiaW5wdXRfY2hhciIsImlucHV0X2xpbmUiLCJpbnB1dF9saW5lcyIsImlucHV0IiwiaW5wdXRfdmFsdWUiLCJvcGVuX2luX2JpbiIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbiIsIm9wZW5fb3V0X2JpbiIsIm9wZW5fb3V0X2dlbiIsIm9wZW5fb3V0Iiwib3V0X2NoYW5uZWxfbGVuZ3RoIiwib3V0cHV0X2JpbmFyeV9pbnQiLCJvdXRwdXRfYnl0ZSIsIm91dHB1dF9jaGFyIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dF92YWx1ZSIsInBvc19pbiIsInBvc19vdXQiLCJyZWFkX2Zsb2F0IiwicmVhZF9pbnQiLCJyZWFkX2xpbmVzIiwicmVhZF93cmFwIiwicmVhbGx5X2lucHV0Iiwic2Vla19pbiIsInNlZWtfb3V0Iiwic2V0X2JpbmFyeV9tb2RlX2luIiwic2V0X2JpbmFyeV9tb2RlX291dCIsIndyaXRlX2xpbmVzIiwid3JpdGVfd3JhcCIsImVwcmludF9zX25vbmJsb2NraW5nIiwic2Vla19vdXQkMCIsInBvc19vdXQkMCIsIm91dF9jaGFubmVsX2xlbmd0aCQwIiwic2Vla19pbiQwIiwicG9zX2luJDAiLCJpbl9jaGFubmVsX2xlbmd0aCQwIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9hc3luY191bml4X18ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L2NvbmZpZy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvYnVzeV9wb2xsZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L2ltcG9ydC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvc3lzY2FsbC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvcmF3X2ZkLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9ieV9kZXNjci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvY2xvY2subWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L2R1bXBfY29yZV9vbl9qb2JfZGVsYXkubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L2ZpbGVfZGVzY3Jfd2F0Y2hlcl9pbnRmLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9lcG9sbF9maWxlX2Rlc2NyX3dhdGNoZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L2ludGVycnVwdG9yLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9pb191cmluZ19yYXdfbnVsbC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvaW9fdXJpbmdfZmlsZV9kZXNjcl93YXRjaGVyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9zZWxlY3RfZmlsZV9kZXNjcl93YXRjaGVyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9yYXdfc2lnbmFsX21hbmFnZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L3NodXRkb3duLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9zaWduYWxfbWFuYWdlci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvcmF3X3NjaGVkdWxlci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvaW5fdGhyZWFkLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9pb191cmluZ19yYXdfc2luZ2xldG9uLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9mZC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvYmFja2luZ19vdXRfY2hhbm5lbC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvaW9fdXJpbmcubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L3RocmVhZF9zYWZlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9zY2hlZHVsZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L3NpZ25hbC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvdW5peF9zeXNjYWxscy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvd3JpdGVyMC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvcmVhZGVyMC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvcmVhZGVyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC93cml0ZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L3RpbWVfc291cmNlX3Rlc3RzLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC90Y3AubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L3Byb2Nlc3MubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY191bml4L2lvX3N0YXRzLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9hc3luY19wcmludC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX3VuaXgvYXN5bmNfc3lzLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfdW5peC9hc3luY191bml4Lm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0dBeUlzQjs7SUFBQTs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3JJbEJBOztVQUtHO0dBS0E7S0FBQTs7OzthQVZIQTs7TUFR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RDs7Ozs7T0FFQWlMOzs7Ozs7Ozs7Ozs7T0EzQkEzUztPQU9BekI7T0FnQkFzUjtPQUNBdEY7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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SjtJQUNBenRGO0lBQ0F1dEY7SUFDQTZGO0lBQ0FDO0lBQ0FoaUI7SUFDQWlpQjtZQUNBQyxzQkFBMkIsb0JBQVU7O0lBQ3JDQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQUNBQyx1QkFBNEIsb0JBQVU7R0FhdkI7SUFYZjVGO0lBU0E2RjtJQUdFQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQU5hOztPQUNiTDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztJQTBCSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUdBejlFO0lBSXdCOzs7Ozs7Ozs7T0F2SnhCbEw7T0FDQUQ7T0FDQWlDO09BQ0EvQjtPQUNBMmtGO09BQ0FDO09BQ0F2MEU7T0FDQXcwRTtPQUNBQzs7O09Ba0NFYztPQUNBQztPQUNBQztPQUNBQztPQUNBdEU7T0FDQXVFO09BQ0F2MkQ7T0FDQXcyRDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBNTNEO09BQ0E2M0Q7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQTdGO09BQ0FNO09BQ0FJO09BQ0FGO09BQ0FKO09BQ0FGO09BQ0FIO09BQ0FNO09BQ0FJO09BQ0FkO09BQ0FZO09BQ0FKO09BQ0F6dEY7T0FDQXV0RjtPQUNBNkY7T0FDQUM7T0FDQWhpQjtPQUNBaWlCO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUE1RjtPQVNBNkY7OztPQXFDRm45RTs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Bc3luY19wcmludCAqKVxubW9kdWxlIEFzeW5jX3ByaW50ID0gQXN5bmNfdW5peF9fQXN5bmNfcHJpbnRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Bc3luY19zeXMgKilcbm1vZHVsZSBBc3luY19zeXMgPSBBc3luY191bml4X19Bc3luY19zeXNcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5CYWNraW5nX291dF9jaGFubmVsICopXG5tb2R1bGUgQmFja2luZ19vdXRfY2hhbm5lbCA9IEFzeW5jX3VuaXhfX0JhY2tpbmdfb3V0X2NoYW5uZWxcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5CdXN5X3BvbGxlciAqKVxubW9kdWxlIEJ1c3lfcG9sbGVyID0gQXN5bmNfdW5peF9fQnVzeV9wb2xsZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5CdXN5X3BvbGxlcl9pbnRmICopXG5tb2R1bGUgQnVzeV9wb2xsZXJfaW50ZiA9IEFzeW5jX3VuaXhfX0J1c3lfcG9sbGVyX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5CeV9kZXNjciAqKVxubW9kdWxlIEJ5X2Rlc2NyID0gQXN5bmNfdW5peF9fQnlfZGVzY3JcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5DbG9jayAqKVxubW9kdWxlIENsb2NrID0gQXN5bmNfdW5peF9fQ2xvY2tcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Db25maWcgKilcbm1vZHVsZSBDb25maWcgPSBBc3luY191bml4X19Db25maWdcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5EdW1wX2NvcmVfb25fam9iX2RlbGF5ICopXG5tb2R1bGUgRHVtcF9jb3JlX29uX2pvYl9kZWxheSA9IEFzeW5jX3VuaXhfX0R1bXBfY29yZV9vbl9qb2JfZGVsYXlcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5FcG9sbF9maWxlX2Rlc2NyX3dhdGNoZXIgKilcbm1vZHVsZSBFcG9sbF9maWxlX2Rlc2NyX3dhdGNoZXIgPSBBc3luY191bml4X19FcG9sbF9maWxlX2Rlc2NyX3dhdGNoZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5GZCAqKVxubW9kdWxlIEZkID0gQXN5bmNfdW5peF9fRmRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5GaWxlX2Rlc2NyX3dhdGNoZXJfaW50ZiAqKVxubW9kdWxlIEZpbGVfZGVzY3Jfd2F0Y2hlcl9pbnRmID0gQXN5bmNfdW5peF9fRmlsZV9kZXNjcl93YXRjaGVyX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5JbXBvcnQgKilcbm1vZHVsZSBJbXBvcnQgPSBBc3luY191bml4X19JbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Jbl90aHJlYWQgKilcbm1vZHVsZSBJbl90aHJlYWQgPSBBc3luY191bml4X19Jbl90aHJlYWRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5JbnRlcnJ1cHRvciAqKVxubW9kdWxlIEludGVycnVwdG9yID0gQXN5bmNfdW5peF9fSW50ZXJydXB0b3JcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Jb19zdGF0cyAqKVxubW9kdWxlIElvX3N0YXRzID0gQXN5bmNfdW5peF9fSW9fc3RhdHNcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Jb191cmluZyAqKVxubW9kdWxlIElvX3VyaW5nID0gQXN5bmNfdW5peF9fSW9fdXJpbmdcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Jb191cmluZ19maWxlX2Rlc2NyX3dhdGNoZXIgKilcbm1vZHVsZSBJb191cmluZ19maWxlX2Rlc2NyX3dhdGNoZXIgPSBBc3luY191bml4X19Jb191cmluZ19maWxlX2Rlc2NyX3dhdGNoZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Jb191cmluZ19yYXcgKilcbm1vZHVsZSBJb191cmluZ19yYXcgPSBBc3luY191bml4X19Jb191cmluZ19yYXdcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Jb191cmluZ19yYXdfaW50ZiAqKVxubW9kdWxlIElvX3VyaW5nX3Jhd19pbnRmID0gQXN5bmNfdW5peF9fSW9fdXJpbmdfcmF3X2ludGZcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Jb191cmluZ19yYXdfbnVsbCAqKVxubW9kdWxlIElvX3VyaW5nX3Jhd19udWxsID0gQXN5bmNfdW5peF9fSW9fdXJpbmdfcmF3X251bGxcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Jb191cmluZ19yYXdfc2luZ2xldG9uICopXG5tb2R1bGUgSW9fdXJpbmdfcmF3X3NpbmdsZXRvbiA9IEFzeW5jX3VuaXhfX0lvX3VyaW5nX3Jhd19zaW5nbGV0b25cblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Jb191cmluZ190eXBlc19pbnRmICopXG5tb2R1bGUgSW9fdXJpbmdfdHlwZXNfaW50ZiA9IEFzeW5jX3VuaXhfX0lvX3VyaW5nX3R5cGVzX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Qcm9jZXNzICopXG5tb2R1bGUgUHJvY2VzcyA9IEFzeW5jX3VuaXhfX1Byb2Nlc3NcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5SYXdfZmQgKilcbm1vZHVsZSBSYXdfZmQgPSBBc3luY191bml4X19SYXdfZmRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5SYXdfc2NoZWR1bGVyICopXG5tb2R1bGUgUmF3X3NjaGVkdWxlciA9IEFzeW5jX3VuaXhfX1Jhd19zY2hlZHVsZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5SYXdfc2lnbmFsX21hbmFnZXIgKilcbm1vZHVsZSBSYXdfc2lnbmFsX21hbmFnZXIgPSBBc3luY191bml4X19SYXdfc2lnbmFsX21hbmFnZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5SZWFkZXIgKilcbm1vZHVsZSBSZWFkZXIgPSBBc3luY191bml4X19SZWFkZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5SZWFkZXIwICopXG5tb2R1bGUgUmVhZGVyMCA9IEFzeW5jX3VuaXhfX1JlYWRlcjBcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5SZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlICopXG5tb2R1bGUgUmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZSA9IEFzeW5jX3VuaXhfX1JlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2VcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5SZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlX2ludGYgKilcbm1vZHVsZSBSZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlX2ludGYgPSBBc3luY191bml4X19SZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5TY2hlZHVsZXIgKilcbm1vZHVsZSBTY2hlZHVsZXIgPSBBc3luY191bml4X19TY2hlZHVsZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5TZWxlY3RfZmlsZV9kZXNjcl93YXRjaGVyICopXG5tb2R1bGUgU2VsZWN0X2ZpbGVfZGVzY3Jfd2F0Y2hlciA9IEFzeW5jX3VuaXhfX1NlbGVjdF9maWxlX2Rlc2NyX3dhdGNoZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5TaHV0ZG93biAqKVxubW9kdWxlIFNodXRkb3duID0gQXN5bmNfdW5peF9fU2h1dGRvd25cblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5TaWduYWwgKilcbm1vZHVsZSBTaWduYWwgPSBBc3luY191bml4X19TaWduYWxcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5TaWduYWxfbWFuYWdlciAqKVxubW9kdWxlIFNpZ25hbF9tYW5hZ2VyID0gQXN5bmNfdW5peF9fU2lnbmFsX21hbmFnZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5TeXNjYWxsICopXG5tb2R1bGUgU3lzY2FsbCA9IEFzeW5jX3VuaXhfX1N5c2NhbGxcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5UY3AgKilcbm1vZHVsZSBUY3AgPSBBc3luY191bml4X19UY3BcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5UaHJlYWRfc2FmZSAqKVxubW9kdWxlIFRocmVhZF9zYWZlID0gQXN5bmNfdW5peF9fVGhyZWFkX3NhZmVcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5UaW1lX3NvdXJjZV90ZXN0cyAqKVxubW9kdWxlIFRpbWVfc291cmNlX3Rlc3RzID0gQXN5bmNfdW5peF9fVGltZV9zb3VyY2VfdGVzdHNcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Vbml4X3N5c2NhbGxzICopXG5tb2R1bGUgVW5peF9zeXNjYWxscyA9IEFzeW5jX3VuaXhfX1VuaXhfc3lzY2FsbHNcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5VbnVzZWQgKilcbm1vZHVsZSBVbnVzZWQgPSBBc3luY191bml4X19VbnVzZWRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Xcml0ZXIgKilcbm1vZHVsZSBXcml0ZXIgPSBBc3luY191bml4X19Xcml0ZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Xcml0ZXIwICopXG5tb2R1bGUgV3JpdGVyMCA9IEFzeW5jX3VuaXhfX1dyaXRlcjBcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfdW5peC5Xcml0ZXJfaW50ZiAqKVxubW9kdWxlIFdyaXRlcl9pbnRmID0gQXN5bmNfdW5peF9fV3JpdGVyX2ludGZcblxubW9kdWxlIEFzeW5jX3VuaXhfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwib3BlbiEgQ29yZVxubW9kdWxlIFVuaXggPSBDb3JlX3VuaXhcbmluY2x1ZGUgQXN5bmNfa2VybmVsLkFzeW5jX2tlcm5lbF9jb25maWdcblxubGV0IGZpbGVfZGVzY3Jfd2F0Y2hlciA9XG4gIG1hdGNoIGZpbGVfZGVzY3Jfd2F0Y2hlciB3aXRoXG4gIHwgKEVwb2xsIHwgU2VsZWN0IHwgSW9fdXJpbmcpIGFzIHggLT4geFxuICB8IEVwb2xsX2lmX3RpbWVyZmQgLT5cbiAgICAoKiBXaXRob3V0IHRpbWVyZmQsIGVwb2xsX3dhaXQoMikgdGltZW91dHMgd291bGQgaGF2ZSBvbmx5IG1pbGxpc2Vjb25kIHByZWNpc2lvbi4gKilcbiAgICBpZiBSZXN1bHQuaXNfb2sgTGludXhfZXh0LlRpbWVyZmQuY3JlYXRlIHRoZW4gRXBvbGwgZWxzZSBTZWxlY3Rcbjs7XG5cbmxldCBtYXhfbnVtX29wZW5fZmlsZV9kZXNjcnMgPVxuICBpZiBub3RcbiAgICAgICAoTWF4X251bV9vcGVuX2ZpbGVfZGVzY3JzLmVxdWFsXG4gICAgICAgICAgbWF4X251bV9vcGVuX2ZpbGVfZGVzY3JzXG4gICAgICAgICAgTWF4X251bV9vcGVuX2ZpbGVfZGVzY3JzLmRlZmF1bHQpXG4gIHRoZW4gbWF4X251bV9vcGVuX2ZpbGVfZGVzY3JzXG4gIGVsc2UgKFxuICAgIG1hdGNoIGZpbGVfZGVzY3Jfd2F0Y2hlciB3aXRoXG4gICAgfCBTZWxlY3QgLT5cbiAgICAgICgqIFRoZSBtYXhpbXVtIG51bWVyaWMgdmFsdWUgZm9yIGEgZmlsZSBkZXNjcmlwdG9yIHdhdGNoYWJsZSBieSBbc2VsZWN0XSBpcyBsaW1pdGVkXG4gICAgICAgICBieSBbRkRfU0VUU0laRV0sIHdoaWNoIGhhcHBlbnMgdG8gYmUgMTAyNCBvbiBMaW51eC4gKilcbiAgICAgIE1heF9udW1fb3Blbl9maWxlX2Rlc2Nycy5jcmVhdGVfZXhuIDEwMjRcbiAgICB8IEVwb2xsIHwgRXBvbGxfaWZfdGltZXJmZCB8IElvX3VyaW5nIC0+XG4gICAgICBJbnQubWluXG4gICAgICAgIE1heF9udW1fb3Blbl9maWxlX2Rlc2Nycy4oZGVmYXVsdCB8PiByYXcpXG4gICAgICAgIChtYXRjaCBVbml4LlJMaW1pdC4oZ2V0IG51bV9maWxlX2Rlc2NyaXB0b3JzKS5tYXggd2l0aFxuICAgICAgICAgfCBJbmZpbml0eSAtPiBJbnQubWF4X3ZhbHVlXG4gICAgICAgICB8IExpbWl0IGludDY0IC0+IGludDY0IHw+IEludDY0LnRvX2ludF9leG4pXG4gICAgICB8PiBNYXhfbnVtX29wZW5fZmlsZV9kZXNjcnMuY3JlYXRlX2V4bilcbjs7XG4iLCJvcGVuIENvcmVcblxubW9kdWxlIHR5cGUgUyA9IEJ1c3lfcG9sbGVyX2ludGYuU1xuXG5tb2R1bGUgRW1wdHlfcG9sbGVyID0gc3RydWN0XG4gIHR5cGUgdCA9IHVuaXRcblxuICBsZXQgcG9sbCAoX3QgOiB0KSB+ZGVhZGxpbmU6XyA9IDBcbiAgbGV0IGtpbmQgPSBUeXBlX2VxdWFsLklkLmNyZWF0ZSB+bmFtZTpcImVtcHR5XCIgWyVzZXhwX29mOiBfXVxuZW5kXG5cbm1vZHVsZSBFeHRyYV9wb2xsZXIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gZGVhZGxpbmU6VGltZV9zdGFtcF9jb3VudGVyLnQgLT4gaW50XG5cbiAgbGV0IHBvbGwgKHQgOiB0KSB+ZGVhZGxpbmUgPSB0IH5kZWFkbGluZVxuICBsZXQga2luZCA9IFR5cGVfZXF1YWwuSWQuY3JlYXRlIH5uYW1lOlwiZXh0cmFcIiBbJXNleHBfb2Y6IF9dXG5lbmRcblxudHlwZSBwYWNrZWQgPSBUIDogKG1vZHVsZSBTIHdpdGggdHlwZSB0ID0gJ2EpICogJ2EgLT4gcGFja2VkXG5cbmxldFtAaW5saW5lIGFsd2F5c10gcG9sbCAoVCAoKG1vZHVsZSBQKSwgcG9sbGVyKSkgfmRlYWRsaW5lID0gUC5wb2xsIHBvbGxlciB+ZGVhZGxpbmVcbmxldCBjcmVhdGUgaW1wbCBwb2xsZXIgPSBUIChpbXBsLCBwb2xsZXIpXG5sZXQgY3JlYXRlJyBmID0gY3JlYXRlIChtb2R1bGUgRXh0cmFfcG9sbGVyKSBmXG5sZXQgZW1wdHkgPSBjcmVhdGUgKG1vZHVsZSBFbXB0eV9wb2xsZXIpICgpXG4iLCJvcGVuIENvcmVcbm1vZHVsZSBVbml4ID0gQ29yZV91bml4XG5tb2R1bGUgVGhyZWFkID0gQ29yZV90aHJlYWRcbm1vZHVsZSBUaW1lID0gVGltZV9mbG9hdF91bml4XG5tb2R1bGUgVGltZV9ucyA9IFRpbWVfbnNfdW5peFxuaW5jbHVkZSBJbnQuUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5pbmNsdWRlIEFzeW5jX2tlcm5lbFxubW9kdWxlIEVwb2xsX21heF9yZWFkeV9ldmVudHMgPSBDb25maWcuRXBvbGxfbWF4X3JlYWR5X2V2ZW50c1xubW9kdWxlIElvX3VyaW5nX21heF9zdWJtaXNzaW9uX2VudHJpZXMgPSBDb25maWcuSW9fdXJpbmdfbWF4X3N1Ym1pc3Npb25fZW50cmllc1xubW9kdWxlIElvX3VyaW5nX21vZGUgPSBDb25maWcuSW9fdXJpbmdfbW9kZVxubW9kdWxlIE1heF9pbnRlcl9jeWNsZV90aW1lb3V0ID0gQ29uZmlnLk1heF9pbnRlcl9jeWNsZV90aW1lb3V0XG5tb2R1bGUgTWF4X251bV9vcGVuX2ZpbGVfZGVzY3JzID0gQ29uZmlnLk1heF9udW1fb3Blbl9maWxlX2Rlc2Nyc1xubW9kdWxlIE1heF9udW1fdGhyZWFkcyA9IENvbmZpZy5NYXhfbnVtX3RocmVhZHNcbm1vZHVsZSBNaW5faW50ZXJfY3ljbGVfdGltZW91dCA9IENvbmZpZy5NaW5faW50ZXJfY3ljbGVfdGltZW91dFxubW9kdWxlIERlYnVnID0gQXN5bmNfa2VybmVsX3ByaXZhdGUuRGVidWdcbm1vZHVsZSBKb2IgPSBBc3luY19rZXJuZWxfcHJpdmF0ZS5Kb2Jcbm1vZHVsZSBLZXJuZWxfc2NoZWR1bGVyID0gQXN5bmNfa2VybmVsX3NjaGVkdWxlci5Qcml2YXRlXG5tb2R1bGUgRmlsZV9kZXNjciA9IFVuaXguRmlsZV9kZXNjclxuXG5sZXQgcHJpbnRfcyBzZXhwID0gQ29yZS5wcmludGYgXCIlc1xcbiUhXCIgKHNleHAgfD4gU2V4cC50b19zdHJpbmdfaHVtKVxubGV0IGFtX3Rlc3RfcnVubmVyID0gQmFzZS5FeHBvcnRlZF9mb3Jfc3BlY2lmaWNfdXNlcy5hbV90ZXN0aW5nXG5cbmxldCAoKSA9XG4gIGlmIEFzeW5jX2tlcm5lbF9jb25maWcuUHJpbnRfZGVidWdfbWVzc2FnZXNfZm9yLnRocmVhZF9wb29sXG4gIHRoZW4gVGhyZWFkX3Bvb2wuZGVidWcgOj0gdHJ1ZVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBQb2x5XG5tb2R1bGUgVW5peCA9IENvcmVfdW5peFxubW9kdWxlIFN5c2NhbGxfcmVzdWx0ID0gVW5peC5TeXNjYWxsX3Jlc3VsdFxuXG5sZXQgbWF4X3RyaWVzID0gMTAwMFxuXG5sZXQgdG9vX21hbnlfdHJpZXMgPVxuICBFcnJvci50b19leG5cbiAgICAoRXJyb3IuY3JlYXRlIFwic3lzY2FsbCBpbnRlcnJ1cHRlZCB0b28gbWFueSB0aW1lc1wiIG1heF90cmllcyBbJXNleHBfb2Y6IGludF0pXG47O1xuXG5sZXQgdG9vX21hbnlfdHJpZXNfZXJyb3IgPSBFcnJvciB0b29fbWFueV90cmllc1xuXG5sZXQgc3lzY2FsbCA9XG4gIGxldCByZWMgbG9vcCBmIG4gPVxuICAgIGlmIG4gPj0gbWF4X3RyaWVzXG4gICAgdGhlbiB0b29fbWFueV90cmllc19lcnJvclxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggZiAoKSB3aXRoXG4gICAgICB8IHggLT4gT2sgeFxuICAgICAgfCBleGNlcHRpb24gVW5peC5Vbml4X2Vycm9yIChFSU5UUiwgXywgXykgLT4gbG9vcCBmIChuICsgMSlcbiAgICAgIHwgZXhjZXB0aW9uIGV4biAtPiBFcnJvciBleG4pXG4gIGluXG4gIGZ1biBmIC0+IGxvb3AgZiAwXG47O1xuXG5sZXQgaXNfZWludHIgciA9IFN5c2NhbGxfcmVzdWx0LmlzX2Vycm9yIHIgJiYgU3lzY2FsbF9yZXN1bHQuZXJyb3JfZXhuIHIgPSBFSU5UUlxuXG5sZXQgc3lzY2FsbF9yZXN1bHQgPVxuICBsZXQgcmVjIGxvb3AgYSBmIG4gPVxuICAgIGlmIG4gPj0gbWF4X3RyaWVzXG4gICAgdGhlbiByYWlzZSB0b29fbWFueV90cmllc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IHIgPSBmIGEgaW5cbiAgICAgIGlmIG5vdCAoaXNfZWludHIgcikgdGhlbiByIGVsc2UgbG9vcCBhIGYgKG4gKyAxKSlcbiAgaW5cbiAgZnVuIGEgZiAtPiBsb29wIGEgZiAwXG47O1xuXG5sZXQgc3lzY2FsbF9yZXN1bHQyID1cbiAgbGV0IHJlYyBsb29wIGEgYiBmIG4gPVxuICAgIGlmIG4gPj0gbWF4X3RyaWVzXG4gICAgdGhlbiByYWlzZSB0b29fbWFueV90cmllc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IHIgPSBmIGEgYiBpblxuICAgICAgaWYgbm90IChpc19laW50ciByKSB0aGVuIHIgZWxzZSBsb29wIGEgYiBmIChuICsgMSkpXG4gIGluXG4gIGZ1biBhIGIgZiAtPiBsb29wIGEgYiBmIDBcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5cbmxldCBkZWJ1ZyA9IERlYnVnLmZkXG5cbm1vZHVsZSBGaWxlX2Rlc2NyID0gVW5peC5GaWxlX2Rlc2NyXG5cbm1vZHVsZSBLaW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBDaGFyXG4gICAgfCBGaWZvXG4gICAgfCBGaWxlXG4gICAgfCBTb2NrZXQgb2YgWyBgVW5jb25uZWN0ZWQgfCBgQm91bmQgfCBgUGFzc2l2ZSB8IGBBY3RpdmUgfCBgVW5rbm93biBdXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG4gICgqIFtTdGF0ZV0gaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHdoZW4gdGhlIGZpbGUgZGVzY3JpcHRvciBpcyBpbiB1c2Ugb3IgYmVpbmdcbiAgICAgY2xvc2VkLiAgSGVyZSBhcmUgdGhlIGFsbG93ZWQgdHJhbnNpdGlvbnMuXG5cbiAgICAgT3BlbiAtLT4gQ2xvc2VfcmVxdWVzdGVkIC0tPiBDbG9zZWQgKilcbiAgdHlwZSB0ID1cbiAgICAoKiBbQ2xvc2VfcmVxdWVzdGVkIChleGVjdXRpb25fY29udGV4dCwgZG9fY2xvc2Vfc3lzY2FsbCldIGluZGljYXRlcyB0aGF0IFtGZC5jbG9zZSB0XVxuICAgICAgIGhhcyBiZWVuIGNhbGxlZCwgYnV0IHRoYXQgd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCB0aGUgY2xvc2UoKSBzeXNjYWxsLCBiZWNhdXNlIHRoZXJlXG4gICAgICAgYXJlIHN0aWxsIGFjdGl2ZSBzeXNjYWxscyB1c2luZyB0aGUgZmlsZSBkZXNjcmlwdG9yLiAgT25jZSB0aGVyZSBhcmUgbm8gYWN0aXZlXG4gICAgICAgc3lzY2FsbHMsIHdlIGVucXVldWUgYSBqb2IgdG8gW2RvX2Nsb3NlX3N5c2NhbGxdIGluIFtleGVjdXRpb25fY29udGV4dF0uICopXG4gICAgfCBDbG9zZV9yZXF1ZXN0ZWQgb2YgRXhlY3V0aW9uX2NvbnRleHQudCAqICh1bml0IC0+IHVuaXQpXG4gICAgKCogW0Nsb3NlZF0gaW5kaWNhdGVzIHRoYXQgdGhlcmUgYXJlIG5vIG1vcmUgYWN0aXZlIHN5c2NhbGxzIGFuZCB3ZSBoYXZlIHN0YXJ0ZWQgdGhlXG4gICAgICAgY2xvc2UoKSBzeXNjYWxsLiAqKVxuICAgIHwgQ2xvc2VkXG4gICAgKCogW09wZW5dIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIGEgZmlsZSBkZXNjcmlwdG9yLCBhbmQgdGhlIG5vcm1hbCBzdGF0ZSB3aGVuIGl0IGlzXG4gICAgICAgaW4gdXNlLiAgSXQgaW5kaWNhdGVzIHRoYXQgaXQgaGFzIG5vdCBub3QgeWV0IGJlZW4gY2xvc2VkLiAgVGhlIGFyZ3VtZW50IGlzIGFuIGl2YXJcbiAgICAgICB0byBiZSBmaWxsZWQgd2hlbiBbY2xvc2VdIGlzIGNhbGxlZC4gKilcbiAgICB8IE9wZW4gb2YgdW5pdCBJdmFyLnRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgdHJhbnNpdGlvbl9pc19hbGxvd2VkIHQgdCcgPVxuICAgIG1hdGNoIHQsIHQnIHdpdGhcbiAgICB8IE9wZW4gXywgQ2xvc2VfcmVxdWVzdGVkIF8gfCBDbG9zZV9yZXF1ZXN0ZWQgXywgQ2xvc2VkIC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaXNfb3BlbiA9IGZ1bmN0aW9uXG4gICAgfCBPcGVuIF8gLT4gdHJ1ZVxuICAgIHwgQ2xvc2VfcmVxdWVzdGVkIF8gfCBDbG9zZWQgLT4gZmFsc2VcbiAgOztcbmVuZFxuXG50eXBlIHJlYWR5X3RvX3Jlc3VsdCA9XG4gIFsgYFJlYWR5XG4gIHwgYEJhZF9mZFxuICB8IGBDbG9zZWRcbiAgfCBgSW50ZXJydXB0ZWRcbiAgfCBgVW5zdXBwb3J0ZWRcbiAgXVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubW9kdWxlIFdhdGNoaW5nID0gc3RydWN0XG4gICgqIEV2ZXJ5IGZkIGNhbiBiZSBtb25pdG9yZWQgYnkgYSBmaWxlX2Rlc2NyX3dhdGNoZXIgZm9yIHJlYWQsIGZvciB3cml0ZSwgZm9yIGJvdGgsIG9yXG4gICAgIGZvciBuZWl0aGVyLiAgRWFjaCBmZCBhbHNvIGhhcyBpdHMgb3duIG5vdGlvbiwgaW5kZXBlbmRlbnQgb2YgdGhlIGZpbGVfZGVzY3Jfd2F0Y2hlcixcbiAgICAgb2YgYSBbV2F0Y2hpbmcudF0sIGZvciBib3RoIHJlYWQgYW5kIHdyaXRlIHRoYXQgaW5kaWNhdGVzIHRoZSBkZXNpcmVkIHN0YXRlIG9mIHRoZVxuICAgICBmaWxlX2Rlc2NyX3dhdGNoZXIgZm9yIHRoaXMgZmQuICBUaGF0IGRlc2lyZWQgc3RhdGUgaXMgbWFpbnRhaW5lZCBvbmx5IGluIHRoZSBmZFxuICAgICB3aGlsZSBhc3luYyBqb2JzIGFyZSBydW5uaW5nLCBhbmQgaXMgdGhlbiBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgZmlsZV9kZXNjcl93YXRjaGVyJ3NcbiAgICAgbm90aW9uLCB2aWEgY2FsbHMgdG8gW0ZpbGVfZGVzY3Jfd2F0Y2hlci5zZXRdLCBqdXN0IHByaW9yIHRvIGFza2luZyB0aGVcbiAgICAgZmlsZV9kZXNjcl93YXRjaGVyIHRvIGNoZWNrIGZkcyBmb3IgcmVhZHkgSS9PLlxuXG4gICAgIEluaXRpYWxseSwgd2F0Y2hpbmcgc3RhdGUgc3RhcnRzIGFzIFtOb3Rfd2F0Y2hpbmddLiAgV2hlbiBvbmUgaW5pdGlhbGx5IHJlcXVlc3RzIHRoYXRcbiAgICAgdGhlIGZkIGJlIG1vbml0b3JlZCB2aWEgW3JlcXVlc3Rfc3RhcnRfd2F0Y2hpbmddLCB0aGUgc3RhdGUgdHJhbnNpdGlvbnMgdG9cbiAgICAgW1dhdGNoX29uY2VdIG9yIFtXYXRjaF9yZXBlYXRlZGx5XS4gIEFmdGVyIHRoZSBmaWxlX2Rlc2NyX3dhdGNoZXIgZGV0ZWN0cyBJL08gaXNcbiAgICAgYXZhaWxhYmxlLCB0aGUgam9iIGluIFtXYXRjaF9yZXBlYXRlZGx5XSBpcyBlbnF1ZXVlZCwgb3IgdGhlIGl2YXIgaW4gW1dhdGNoX29uY2VdIGlzXG4gICAgIGZpbGxlZCBhbmQgdGhlIHN0YXRlIHRyYW5zaXRpb25zIHRvIFtTdG9wX3JlcXVlc3RlZF0uICBPciwgaWYgb25lIGNhbGxzXG4gICAgIFtyZXF1ZXN0X3N0b3Bfd2F0Y2hpbmddLCB0aGUgc3RhdGUgdHJhbnNpdGlvbnMgdG8gW1N0b3BfcmVxdWVzdGVkXS4gIEZpbmFsbHksXG4gICAgIFtTdG9wX3JlcXVlc3RlZF0gd2lsbCB0cmFuc2l0aW9uIHRvIFtOb3Rfd2F0Y2hpbmddIHdoZW4gdGhlIGRlc2lyZWQgc3RhdGUgaXNcbiAgICAgc3luY2hyb25pemVkIHdpdGggdGhlIGZpbGVfZGVzY3Jfd2F0Y2hlci4gKilcbiAgdHlwZSB0ID1cbiAgICB8IE5vdF93YXRjaGluZ1xuICAgIHwgV2F0Y2hfb25jZSBvZiByZWFkeV90b19yZXN1bHQgSXZhci50XG4gICAgfCBXYXRjaF9yZXBlYXRlZGx5IG9mXG4gICAgICAgIEpvYi50ICogWyBgQmFkX2ZkIHwgYENsb3NlZCB8IGBJbnRlcnJ1cHRlZCB8IGBVbnN1cHBvcnRlZCBdIEl2YXIudFxuICAgIHwgU3RvcF9yZXF1ZXN0ZWRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IHQgOiB1bml0ID1cbiAgICB0cnlcbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBOb3Rfd2F0Y2hpbmcgfCBTdG9wX3JlcXVlc3RlZCAtPiAoKVxuICAgICAgfCBXYXRjaF9vbmNlIGl2YXIgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpXG4gICAgICB8IFdhdGNoX3JlcGVhdGVkbHkgKF8sIGl2YXIpIC0+IGFzc2VydCAoSXZhci5pc19lbXB0eSBpdmFyKVxuICAgIHdpdGhcbiAgICB8IGV4biAtPiByYWlzZV9zIFslbWVzc2FnZSBcIldhdGNoaW5nLmludmFyaWFudCBmYWlsZWRcIiAoZXhuIDogZXhuKSB+d2F0Y2hpbmc6KHQgOiB0KV1cbiAgOztcbmVuZFxuXG5tb2R1bGUgTm9uYmxvY2tfc3RhdHVzID0gc3RydWN0XG4gICgqIEVuY29kZXMgdGhlIGtub3dsZWRnZSBvZiB0aGUgT19OT05CTE9DSyBmbGFnIG9mIGFuIGZkLiAqKVxuICB0eXBlIHQgPVxuICAgIHwgQmxvY2tpbmdcbiAgICB8IE5vbmJsb2NraW5nXG4gICAgfCBVbmtub3duXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGZpbGVfZGVzY3IgOiBGaWxlX2Rlc2NyLnRcbiAgICA7ICgqIFtpbmZvXSBpcyBmb3IgZGVidWdnaW5nIGluZm8uIEl0IGlzIG11dGFibGUgYmVjYXVzZSBpdCBjaGFuZ2VzIGFmdGVyIFtiaW5kXSxcbiAgICAgICAgIFtsaXN0ZW5dLCBvcltjb25uZWN0XS4gKilcbiAgICAgIG11dGFibGUgaW5mbyA6IEluZm8udFxuICAgIDsgKCogW2tpbmRdIGlzIG11dGFibGUgYmVjYXVzZSBpdCBjaGFuZ2VzIGFmdGVyIFtiaW5kXSwgW2xpc3Rlbl0sIG9yIFtjb25uZWN0XS4gKilcbiAgICAgIG11dGFibGUga2luZCA6IEtpbmQudFxuICAgIDsgKCogaWYgW2Nhbl9zZXRfbm9uYmxvY2tdIGlzIHRydWUsIGFzeW5jIHdpbGwgc3dpdGNoIHRoZSB1bmRlcmx5aW5nIGZpbGVcbiAgICAgICAgIGRlc2NyaXB0b3IgaW50byBub25ibG9ja2luZyBtb2RlIGFueSB0aW1lIGEgbm9uLWJsb2NraW5nIG9wZXJhdGlvbiBpcyBhdHRlbXB0ZWQuXG4gICAgICAgICBJdCBjYW4gYmUgW2ZhbHNlXSBpZiB0aGUgdXNlciBleHBsaWNpdGx5IHRlbGxzIGFzeW5jIHRvIGF2b2lkIG1vZGlmeWluZyB0aGF0XG4gICAgICAgICBmbGFnIG9uIHRoZSB1bmRlcmx5aW5nIGZkLCBvciBpZiBBc3luYyBkZXRlY3RzIHRoYXQgdGhlIGZpbGUgZGVzY3JpcHRvclxuICAgICAgICAgZG9lc24ndCBzdXBwb3J0IG5vbmJsb2NraW5nIEkvTy4gKilcbiAgICAgIG11dGFibGUgY2FuX3NldF9ub25ibG9jayA6IGJvb2xcbiAgICA7IG11dGFibGUgbm9uYmxvY2tfc3RhdHVzIDogTm9uYmxvY2tfc3RhdHVzLnRcbiAgICA7IG11dGFibGUgc3RhdGUgOiBTdGF0ZS50XG4gICAgOyB3YXRjaGluZyA6IFdhdGNoaW5nLnQgUmVhZF93cml0ZV9wYWlyLk11dGFibGUudFxuICAgIDsgKCogW3dhdGNoaW5nX2hhc19jaGFuZ2VkXSBpcyB0cnVlIGlmIFt3YXRjaGluZ10gaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZVxuICAgICAgICAgW3dhdGNoaW5nXSB3YXMgc3luY2hyb25pemVkIHdpdGggdGhlIGZpbGVfZGVzY3Jfd2F0Y2hlci4gIEluIHRoaXMgY2FzZSwgdGhlXG4gICAgICAgICBmZCBhcHBlYXJzIGluIHRoZSBzY2hlZHVsZXIncyBbZmRzX3dob3NlX3dhdGNoaW5nX2hhc19jaGFuZ2VkXSBsaXN0IHNvIHRoYXRcbiAgICAgICAgIGl0IGNhbiBiZSBzeW5jaHJvbml6ZWQgbGF0ZXIuICopXG4gICAgICBtdXRhYmxlIHdhdGNoaW5nX2hhc19jaGFuZ2VkIDogYm9vbFxuICAgIDsgKCogW251bV9hY3RpdmVfc3lzY2FsbHNdIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgY2FsbCBbY2xvc2VdIG9uIGEgZmlsZVxuICAgICAgICAgZGVzY3JpcHRvciB1bnRpbCB0aGVyZSBhcmUgbm8gYWN0aXZlIHN5c3RlbSBjYWxscyBpbnZvbHZpbmcgdGhhdCBmaWxlIGRlc2NyaXB0b3IuXG4gICAgICAgICBUaGlzIHByZXZlbnRzIHJhY2VzIGluIHdoaWNoIHRoZSBPUyBhc3NpZ25zIHRoYXQgZmlsZSBkZXNjcmlwdG9yIHRvIGEgbmV3XG4gICAgICAgICBvcGVuIGZpbGUsIGFuZCB0aHVzIGEgc3lzdGVtIGNhbGwgZGVhbHMgd2l0aCB0aGUgd3Jvbmcgb3BlbiBmaWxlLiAgIElmIHRoZVxuICAgICAgICAgc3RhdGUgb2YgYW4gZmQgaXMgW0Nsb3NlX3JlcXVlc3RlZF0sIHRoZW4gb25jZSBbbnVtX2FjdGl2ZV9zeXNjYWxsc10gZHJvcHMgdG9cbiAgICAgICAgIHplcm8sIHRoZSBjbG9zZSgpIHN5c2NhbGwgd2lsbCBzdGFydCBhbmQgdGhlIHN0YXRlIHdpbGwgdHJhbnNpdGlvbiB0byBbQ2xvc2VkXSxcbiAgICAgICAgIHRodXMgcHJldmVudGluZyBmdXJ0aGVyIHN5c3RlbSBjYWxscyBmcm9tIHVzaW5nIHRoZSBmaWxlIGRlc2NyaXB0b3IuXG5cbiAgICAgICAgIFtudW1fYWN0aXZlX3N5c2NhbGxzXSBpcyBhYnVzZWQgc2xpZ2h0bHkgdG8gaW5jbHVkZSB0aGUgc3lzY2FsbCB0byB0aGVcbiAgICAgICAgIGZpbGVfZGVzY3Jfd2F0Y2hlciB0byBjaGVjayBmb3IgcmVhZHkgSS9PLiAgV2F0Y2hpbmcgZm9yIHJlYWQgYW5kIGZvciB3cml0ZVxuICAgICAgICAgZWFjaCBwb3RlbnRpYWxseSBjb3VudCBmb3Igb25lIGFjdGl2ZSBzeXNjYWxsLiAqKVxuICAgICAgbXV0YWJsZSBudW1fYWN0aXZlX3N5c2NhbGxzIDogaW50XG4gICAgOyAoKiBbY2xvc2VfZmluaXNoZWRdIGJlY29tZXMgZGV0ZXJtaW5lZCBhZnRlciB0aGUgZmlsZSBkZXNjcmlwdG9yIGhhcyBiZWVuIGNsb3NlZFxuICAgICAgICAgYW5kIHRoZSB1bmRlcmx5aW5nIGNsb3NlKCkgc3lzdGVtIGNhbGwgaGFzIGZpbmlzaGVkLiAqKVxuICAgICAgY2xvc2VfZmluaXNoZWQgOiB1bml0IEl2YXIudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxuICB0eXBlIHRfaHVtID0gdFxuXG4gIGxldCBzZXhwX29mX3RfaHVtIHsgZmlsZV9kZXNjcjsgaW5mbzsga2luZDsgXyB9ID1cbiAgICBbJXNleHAgeyBmaWxlX2Rlc2NyIDogRmlsZV9kZXNjci50OyBpbmZvIDogSW5mby50OyBraW5kIDogS2luZC50IH1dXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBlcXVhbCAodCA6IHQpIHQnID0gcGh5c19lcXVhbCB0IHQnXG5cbmxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+aW5mbzppZ25vcmVcbiAgICAgIH5maWxlX2Rlc2NyOmlnbm9yZVxuICAgICAgfmtpbmQ6aWdub3JlXG4gICAgICB+Y2FuX3NldF9ub25ibG9jazppZ25vcmVcbiAgICAgIH5ub25ibG9ja19zdGF0dXM6aWdub3JlXG4gICAgICB+c3RhdGU6aWdub3JlXG4gICAgICB+d2F0Y2hpbmc6XG4gICAgICAgIChjaGVjayAoZnVuIHdhdGNoaW5nIC0+IFJlYWRfd3JpdGVfcGFpci5pdGVyIHdhdGNoaW5nIH5mOldhdGNoaW5nLmludmFyaWFudCkpXG4gICAgICB+d2F0Y2hpbmdfaGFzX2NoYW5nZWQ6aWdub3JlXG4gICAgICB+bnVtX2FjdGl2ZV9zeXNjYWxsczpcbiAgICAgICAgKGNoZWNrIChmdW4gbnVtX2FjdGl2ZV9zeXNjYWxscyAtPlxuICAgICAgICAgICBhc3NlcnQgKHQubnVtX2FjdGl2ZV9zeXNjYWxscyA+PSAwKTtcbiAgICAgICAgICAgbGV0IHdhdGNoaW5nIHJlYWRfb3Jfd3JpdGUgPVxuICAgICAgICAgICAgIG1hdGNoIFJlYWRfd3JpdGVfcGFpci5nZXQgdC53YXRjaGluZyByZWFkX29yX3dyaXRlIHdpdGhcbiAgICAgICAgICAgICB8IE5vdF93YXRjaGluZyAtPiAwXG4gICAgICAgICAgICAgfCBTdG9wX3JlcXVlc3RlZCB8IFdhdGNoX29uY2UgXyB8IFdhdGNoX3JlcGVhdGVkbHkgXyAtPiAxXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGFzc2VydCAodC5udW1fYWN0aXZlX3N5c2NhbGxzID49IHdhdGNoaW5nIGBSZWFkICsgd2F0Y2hpbmcgYFdyaXRlKTtcbiAgICAgICAgICAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICAgIHwgQ2xvc2VkIC0+IGFzc2VydCAobnVtX2FjdGl2ZV9zeXNjYWxscyA9IDApXG4gICAgICAgICAgIHwgQ2xvc2VfcmVxdWVzdGVkIF8gfCBPcGVuIF8gLT4gKCkpKVxuICAgICAgfmNsb3NlX2ZpbmlzaGVkOlxuICAgICAgICAoY2hlY2sgKGZ1biBjbG9zZV9maW5pc2hlZCAtPlxuICAgICAgICAgICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgICAgICAgICAgfCBDbG9zZWQgLT4gKClcbiAgICAgICAgICAgfCBDbG9zZV9yZXF1ZXN0ZWQgXyAtPiBhc3NlcnQgKEl2YXIuaXNfZW1wdHkgY2xvc2VfZmluaXNoZWQpXG4gICAgICAgICAgIHwgT3BlbiBjbG9zZV9zdGFydGVkIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGNsb3NlX2ZpbmlzaGVkKTtcbiAgICAgICAgICAgICBhc3NlcnQgKEl2YXIuaXNfZW1wdHkgY2xvc2Vfc3RhcnRlZCkpKVxuICB3aXRoXG4gIHwgZXhuIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiRmQuaW52YXJpYW50IGZhaWxlZFwiIChleG4gOiBleG4pIH5mZDoodCA6IHQpXVxuOztcblxubGV0IHRvX2ludCB0ID0gRmlsZV9kZXNjci50b19pbnQgdC5maWxlX2Rlc2NyXG5cbmxldCBjcmVhdGUgPyhhdm9pZF9zZXR0aW5nX25vbmJsb2NrID0gZmFsc2UpIChraW5kIDogS2luZC50KSBmaWxlX2Rlc2NyIGluZm8gPVxuICBsZXQgY2FuX3NldF9ub25ibG9jayA9XG4gICAgaWYgYXZvaWRfc2V0dGluZ19ub25ibG9ja1xuICAgIHRoZW4gZmFsc2VcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGtpbmQgd2l0aFxuICAgICAgKCogTm8gcG9pbnQgaW4gc2V0dGluZyBub25ibG9ja2luZyBmb3IgZmlsZXMuICBVbml4IGRvZXNuJ3QgY2FyZS4gKilcbiAgICAgIHwgRmlsZSAtPiBmYWxzZVxuICAgICAgKCogV2UgZG9uJ3QgdXNlIG5vbmJsb2NraW5nIEkvTyBmb3IgY2hhciBkZXZpY2VzIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlXG4gICAgICAgICBibG9ja2luZyBzdGF0dXMgb2YgVFRZcywgd2hpY2ggd291bGQgYWZmZWN0IGFsbCBwcm9jZXNzZXMgY3VycmVudGx5IGF0dGFjaGVkIHRvXG4gICAgICAgICB0aGF0IFRUWSBhbmQgZXZlbiBwZXJzaXN0IGFmdGVyIHRoaXMgcHJvY2VzcyB0ZXJtaW5hdGVzLlxuXG4gICAgICAgICBBbHNvLCAvZGV2L251bGwgaXMgYSBjaGFyIGRldmljZSBub3Qgc3VwcG9ydGVkIGJ5IGVwb2xsLlxuXG4gICAgICAgICBXZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBkb2luZyBub25ibG9ja2luZyBJL08gb24gb3RoZXIgY2hhcmFjdGVyIGRldmljZXMsXG4gICAgICAgICBlLmcuIC9kZXYvcmFuZG9tLiAqKVxuICAgICAgfCBDaGFyIC0+IGZhbHNlXG4gICAgICB8IEZpZm8gLT4gdHJ1ZVxuICAgICAgfCBTb2NrZXQgXyAtPlxuICAgICAgICAoKiBBbGwgb25lIGNhbiBkbyBvbiBhIGBCb3VuZCBzb2NrZXQgaXMgbGlzdGVuKCkgdG8gaXQsIGFuZCB3ZSBkb24ndCB1c2UgbGlzdGVuKClcbiAgICAgICAgICAgaW4gYSBub25ibG9ja2luZyB3YXkuXG4gICAgICAgICAgIGBVbmNvbm5lY3RlZCBzb2NrZXRzIHN1cHBvcnQgbm9uYmxvY2tpbmcgc28gd2UgY2FuIGNvbm5lY3QoKSB0aGVtLlxuICAgICAgICAgICBgUGFzc2l2ZSAgICAgc29ja2V0cyBzdXBwb3J0IG5vbmJsb2NraW5nIHNvIHdlIGNhbiBhY2NlcHQoKSB0aGVtLlxuICAgICAgICAgICBgQWN0aXZlICAgICAgc29ja2V0cyBzdXBwb3J0IG5vbmJsb2NraW5nIHNvIHdlIGNhbiByZWFkKCkgYW5kIHdyaXRlKCkgdGhlbS5cblxuICAgICAgICAgICBXZSBuZWVkIHRoZSBzb2NrZXRzIHRvIGJlIGluIG5vbmJsb2NraW5nIG1vZGUgZm9yIFtgVW5jb25uZWN0ZWRdIGFuZCBbYFBhc3NpdmVdXG4gICAgICAgICAgIHNvY2tldHMsIGJlY2F1c2UgW2FjY2VwdF9pbnRlcnJ1cHRpYmxlXSBhbmQgW2Nvbm5lY3RfaW50ZXJydXB0aWJsZV0gaW5cbiAgICAgICAgICAgdW5peF9zeXNjYWxscy5tbCBhc3N1bWUgdGhhdCBzdWNoIHNvY2tldHMgYXJlIG5vbmJsb2NraW5nLiAgT24gdGhlIG90aGVyIGhhbmQsXG4gICAgICAgICAgIHRoZXJlIGlzIG5vIHN1Y2ggYXNzdW1wdGlvbiBhYm91dCBbYEFjdGl2ZV0gc29ja2V0cy5cblxuICAgICAgICAgICBJbiBhbnkgY2FzZSwgcmV0dXJuaW5nIFt0cnVlXSBoZXJlIG1ha2VzIHNlbnNlLiBOb3Qgb25seSBpcyBpdCBoYXJtbGVzc1xuICAgICAgICAgICBpbiBjYXNlIHdlIGRvbid0IGVuZCB1cCB1c2luZyBpdCwgYnV0IHRoaXMgZmllbGQgaXMgYWxzbyBub3QgdXBkYXRlZCBieVxuICAgICAgICAgICBzb2NrZXQgc3RhdGUgdHJhbnNpdGlvbnMgKFtGZC5Qcml2YXRlLnJlcGxhY2VdKSwgc28gaXRzIHZhbHVlIG5lZWRzIHRvIGJlIHRoZVxuICAgICAgICAgICBzYW1lIGFjcm9zcyB0aGUgZGlmZmVyZW50IHNvY2tldCBzdGF0ZXMuXG4gICAgICAgICopXG4gICAgICAgIHRydWUpXG4gIGluXG4gIGxldCB0ID1cbiAgICB7IGluZm9cbiAgICA7IGZpbGVfZGVzY3JcbiAgICA7IGtpbmRcbiAgICA7IGNhbl9zZXRfbm9uYmxvY2tcbiAgICA7IG5vbmJsb2NrX3N0YXR1cyA9IE5vbmJsb2NrX3N0YXR1cy5Vbmtub3duXG4gICAgOyBzdGF0ZSA9IFN0YXRlLk9wZW4gKEl2YXIuY3JlYXRlICgpKVxuICAgIDsgd2F0Y2hpbmcgPSBSZWFkX3dyaXRlX3BhaXIuY3JlYXRlX2JvdGggV2F0Y2hpbmcuTm90X3dhdGNoaW5nXG4gICAgOyB3YXRjaGluZ19oYXNfY2hhbmdlZCA9IGZhbHNlXG4gICAgOyBudW1fYWN0aXZlX3N5c2NhbGxzID0gMFxuICAgIDsgY2xvc2VfZmluaXNoZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgIH1cbiAgaW5cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJGZC5jcmVhdGVcIiB0IFslc2V4cF9vZjogdF07XG4gIHRcbjs7XG5cbmxldCBpbmNfbnVtX2FjdGl2ZV9zeXNjYWxscyB0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgQ2xvc2VfcmVxdWVzdGVkIF8gfCBDbG9zZWQgLT4gYEFscmVhZHlfY2xvc2VkXG4gIHwgT3BlbiBfIC0+XG4gICAgdC5udW1fYWN0aXZlX3N5c2NhbGxzIDwtIHQubnVtX2FjdGl2ZV9zeXNjYWxscyArIDE7XG4gICAgYE9rXG47O1xuXG5sZXQgc2V0X3N0YXRlIHQgbmV3X3N0YXRlID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJGZC5zZXRfc3RhdGVcIiAobmV3X3N0YXRlLCB0KSBbJXNleHBfb2Y6IFN0YXRlLnQgKiB0XTtcbiAgaWYgU3RhdGUudHJhbnNpdGlvbl9pc19hbGxvd2VkIHQuc3RhdGUgbmV3X3N0YXRlXG4gIHRoZW4gdC5zdGF0ZSA8LSBuZXdfc3RhdGVcbiAgZWxzZVxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIkZkLnNldF9zdGF0ZSBhdHRlbXB0ZWQgZGlzYWxsb3dlZCBzdGF0ZSB0cmFuc2l0aW9uXCJcbiAgICAgICAgICB+ZmQ6KHQgOiB0KVxuICAgICAgICAgIChuZXdfc3RhdGUgOiBTdGF0ZS50KV1cbjs7XG5cbmxldCBpc19vcGVuIHQgPSBTdGF0ZS5pc19vcGVuIHQuc3RhdGVcbmxldCBpc19jbG9zZWQgdCA9IG5vdCAoaXNfb3BlbiB0KVxuXG5sZXQgZGV0ZXJtaW5lX25vbmJsb2NrX3N0YXR1cyB0ID1cbiAgbWF0Y2ggdC5ub25ibG9ja19zdGF0dXMgd2l0aFxuICB8IFVua25vd24gLT5cbiAgICBsZXQgZmxhZ3MgPSBDb3JlX3VuaXguZmNudGxfZ2V0ZmwgdC5maWxlX2Rlc2NyIGluXG4gICAgbGV0IG5vbmJsb2NrID1cbiAgICAgIENvcmVfdW5peC5PcGVuX2ZsYWdzLmlzX3N1YnNldCBDb3JlX3VuaXguT3Blbl9mbGFncy5ub25ibG9jayB+b2ZfOmZsYWdzXG4gICAgaW5cbiAgICB0Lm5vbmJsb2NrX3N0YXR1c1xuICAgICAgPC0gKG1hdGNoIG5vbmJsb2NrIHdpdGhcbiAgICAgICAgICB8IGZhbHNlIC0+IEJsb2NraW5nXG4gICAgICAgICAgfCB0cnVlIC0+IE5vbmJsb2NraW5nKTtcbiAgICBub25ibG9ja1xuICB8IE5vbmJsb2NraW5nIC0+IHRydWVcbiAgfCBCbG9ja2luZyAtPiBmYWxzZVxuOztcblxubGV0IHN1cHBvcnRzX25vbmJsb2NrIHQgPSBpZiB0LmNhbl9zZXRfbm9uYmxvY2sgdGhlbiB0cnVlIGVsc2UgZGV0ZXJtaW5lX25vbmJsb2NrX3N0YXR1cyB0XG5cbmxldCBzZXRfbm9uYmxvY2tfaWZfbmVjZXNzYXJ5ID8obm9uYmxvY2tpbmcgPSBmYWxzZSkgdCA9XG4gIGlmIG5vbmJsb2NraW5nXG4gIHRoZW4gKFxuICAgIG1hdGNoIGRldGVybWluZV9ub25ibG9ja19zdGF0dXMgdCB3aXRoXG4gICAgfCB0cnVlIC0+ICgpXG4gICAgfCBmYWxzZSAtPlxuICAgICAgaWYgdC5jYW5fc2V0X25vbmJsb2NrXG4gICAgICB0aGVuIChcbiAgICAgICAgVW5peC5zZXRfbm9uYmxvY2sgdC5maWxlX2Rlc2NyO1xuICAgICAgICB0Lm5vbmJsb2NrX3N0YXR1cyA8LSBOb25ibG9ja2luZylcbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgXCJGZC5zZXRfbm9uYmxvY2tfaWZfbmVjZXNzYXJ5IGNhbGxlZCBvbiBmZCB0aGF0IGRvZXMgbm90IHN1cHBvcnQgbm9uYmxvY2tcIlxuICAgICAgICAgICAgICB+ZmQ6KHQgOiB0KV0pXG47O1xuXG5sZXQgd2l0aF9maWxlX2Rlc2NyX2V4biA/bm9uYmxvY2tpbmcgdCBmID1cbiAgaWYgaXNfY2xvc2VkIHRcbiAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIkZkLndpdGhfZmlsZV9kZXNjcl9leG4gZ290IGNsb3NlZCBmZFwiIH5fOih0IDogdCldXG4gIGVsc2UgKFxuICAgIHNldF9ub25ibG9ja19pZl9uZWNlc3NhcnkgdCA/bm9uYmxvY2tpbmc7XG4gICAgZiB0LmZpbGVfZGVzY3IpXG47O1xuXG5sZXQgd2l0aF9maWxlX2Rlc2NyID9ub25ibG9ja2luZyB0IGYgPVxuICBpZiBpc19jbG9zZWQgdFxuICB0aGVuIGBBbHJlYWR5X2Nsb3NlZFxuICBlbHNlIChcbiAgICB0cnlcbiAgICAgIHNldF9ub25ibG9ja19pZl9uZWNlc3NhcnkgdCA/bm9uYmxvY2tpbmc7XG4gICAgICBgT2sgKGYgdC5maWxlX2Rlc2NyKVxuICAgIHdpdGhcbiAgICB8IGV4biAtPiBgRXJyb3IgZXhuKVxuOztcblxubGV0IHN5c2NhbGwgP25vbmJsb2NraW5nIHQgZiA9XG4gIHdpdGhfZmlsZV9kZXNjciB0ID9ub25ibG9ja2luZyAoZnVuIGZpbGVfZGVzY3IgLT5cbiAgICBSZXN1bHQub2tfZXhuIChTeXNjYWxsLnN5c2NhbGwgKGZ1biAoKSAtPiBmIGZpbGVfZGVzY3IpKSlcbjs7XG5cbmxldCBzeXNjYWxsX2V4biA/bm9uYmxvY2tpbmcgdCBmID1cbiAgbWF0Y2ggc3lzY2FsbCB0IGYgP25vbmJsb2NraW5nIHdpdGhcbiAgfCBgT2sgYSAtPiBhXG4gIHwgYEFscmVhZHlfY2xvc2VkIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiRmQuc3lzY2FsbF9leG4gZ290IGNsb3NlZCBmZFwiIH5fOih0IDogdCldXG4gIHwgYEVycm9yIGV4biAtPiByYWlzZSBleG5cbjs7XG5cbmxldCBzeXNjYWxsX3Jlc3VsdF9leG4gP25vbmJsb2NraW5nIHQgYSBmID1cbiAgaWYgaXNfY2xvc2VkIHRcbiAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIkZkLnN5c2NhbGxfcmVzdWx0X2V4biBnb3QgY2xvc2VkIGZkXCIgfl86KHQgOiB0KV1cbiAgZWxzZSAoXG4gICAgc2V0X25vbmJsb2NrX2lmX25lY2Vzc2FyeSB0ID9ub25ibG9ja2luZztcbiAgICBTeXNjYWxsLnN5c2NhbGxfcmVzdWx0MiB0LmZpbGVfZGVzY3IgYSBmKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcblxudHlwZSAnYSB0ID0gJ2EgT3B0aW9uX2FycmF5LnRcblxubGV0IGNhcGFjaXR5IHQgPSBPcHRpb25fYXJyYXkubGVuZ3RoIHRcblxubGV0IGNyZWF0ZSB+bnVtX2ZpbGVfZGVzY3JzID1cbiAgaWYgbnVtX2ZpbGVfZGVzY3JzIDwgMFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiW0J5X2Rlc2NyLmNyZWF0ZV0gZ290IG5lZ2F0aXZlIFtudW1fZmlsZV9kZXNjcnNdXCIgKG51bV9maWxlX2Rlc2NycyA6IGludCldO1xuICBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46bnVtX2ZpbGVfZGVzY3JzXG47O1xuXG5sZXQgYm91bmRzX2NoZWNrIHQgZmlsZV9kZXNjciA9XG4gIGxldCBpID0gZmlsZV9kZXNjciB8PiBGaWxlX2Rlc2NyLnRvX2ludCBpblxuICAwIDw9IGkgJiYgaSA8IGNhcGFjaXR5IHRcbjs7XG5cbmxldCBib3VuZHNfY2hlY2tfZXJyb3IgdCBmaWxlX2Rlc2NyID1cbiAgWyVtZXNzYWdlXG4gICAgXCJUaGUgZmlsZSBkZXNjcmlwdG9yIGlzIG5vdCBpbiB0aGUgcmFuZ2UgdGhhdCBBc3luYyBhbGxvd3MsIHdoaWNoIHByb2JhYmx5IG1lYW5zIFxcXG4gICAgIHRoYXQgdGhlIHByb2dyYW0gaGFzIGNyZWF0ZWQgdG9vIG1hbnkgZmlsZSBkZXNjcmlwdG9ycyB3aXRob3V0IGNsb3NpbmcgdGhlbS4gIFlvdSBcXFxuICAgICBjYW4gY2F1c2UgQXN5bmMgdG8gYWxsb3cgbW9yZSBmaWxlIGRlc2NyaXB0b3JzIHZpYSB0aGUgW0FTWU5DX0NPTkZJR10gZW52aXJvbm1lbnQgXFxcbiAgICAgdmFyaWFibGUsIGxpa2UgdGhpczogQVNZTkNfQ09ORklHPScoKG1heF9udW1fb3Blbl9maWxlX2Rlc2NycyA8TlVNQkVSPikpJyBmb28uZXhlIFxcXG4gICAgIGFyZzEgYXJnMiAuLi5cIlxuICAgICAgKGZpbGVfZGVzY3IgOiBGaWxlX2Rlc2NyLnQpXG4gICAgICB+bWluX2ZpbGVfZGVzY3I6MFxuICAgICAgfm1heF9maWxlX2Rlc2NyOihjYXBhY2l0eSB0IC0gMSA6IGludCldXG47O1xuXG5sZXQgYm91bmRzX2NoZWNrX2V4biB0IGZpbGVfZGVzY3IgPVxuICBpZiBub3QgKGJvdW5kc19jaGVjayB0IGZpbGVfZGVzY3IpIHRoZW4gcmFpc2VfcyAoYm91bmRzX2NoZWNrX2Vycm9yIHQgZmlsZV9kZXNjcilcbjs7XG5cbmxldCBtZW0gdCBmaWxlX2Rlc2NyID1cbiAgYm91bmRzX2NoZWNrIHQgZmlsZV9kZXNjciAmJiBPcHRpb25fYXJyYXkuaXNfc29tZSB0IChmaWxlX2Rlc2NyIHw+IEZpbGVfZGVzY3IudG9faW50KVxuOztcblxubGV0IGZpbmQgdCBmaWxlX2Rlc2NyID1cbiAgaWYgbm90IChib3VuZHNfY2hlY2sgdCBmaWxlX2Rlc2NyKVxuICB0aGVuIE5vbmVcbiAgZWxzZSBPcHRpb25fYXJyYXkuZ2V0IHQgKGZpbGVfZGVzY3IgfD4gRmlsZV9kZXNjci50b19pbnQpXG47O1xuXG5sZXQgZmluZF9leG4gdCBmaWxlX2Rlc2NyID1cbiAgYm91bmRzX2NoZWNrX2V4biB0IGZpbGVfZGVzY3I7XG4gIGlmIE9wdGlvbl9hcnJheS5pc19ub25lIHQgKGZpbGVfZGVzY3IgfD4gRmlsZV9kZXNjci50b19pbnQpXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2UgXCJbQnlfZGVzY3IuZmluZF9leG5dIGdvdCB1bmtub3duIGZpbGVfZGVzY3JcIiAoZmlsZV9kZXNjciA6IEZpbGVfZGVzY3IudCldO1xuICBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQgKGZpbGVfZGVzY3IgfD4gRmlsZV9kZXNjci50b19pbnQpXG47O1xuXG5sZXQgcmVtb3ZlIHQgKGZkIDogRmlsZV9kZXNjci50KSA9XG4gIGJvdW5kc19jaGVja19leG4gdCBmZDtcbiAgT3B0aW9uX2FycmF5LnNldF9ub25lIHQgKGZkIHw+IEZpbGVfZGVzY3IudG9faW50KVxuOztcblxubGV0IGFkZCB0IGZpbGVfZGVzY3IgdiA9XG4gIGlmIG5vdCAoYm91bmRzX2NoZWNrIHQgZmlsZV9kZXNjcilcbiAgdGhlbiBlcnJvcl9zIChib3VuZHNfY2hlY2tfZXJyb3IgdCBmaWxlX2Rlc2NyKVxuICBlbHNlIGlmIE9wdGlvbl9hcnJheS5pc19zb21lIHQgKGZpbGVfZGVzY3IgfD4gRmlsZV9kZXNjci50b19pbnQpXG4gIHRoZW5cbiAgICBlcnJvcl9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJBdHRlbXB0IHRvIHJlZ2lzdGVyIGEgZmlsZSBkZXNjcmlwdG9yIHdpdGggQXN5bmMgdGhhdCBBc3luYyBiZWxpZXZlcyBpdCBpcyBcXFxuICAgICAgICAgYWxyZWFkeSBtYW5hZ2luZy5cIl1cbiAgZWxzZSAoXG4gICAgT3B0aW9uX2FycmF5LnNldF9zb21lIHQgKGZpbGVfZGVzY3IgfD4gRmlsZV9kZXNjci50b19pbnQpIHY7XG4gICAgT2sgKCkpXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gY2FwYWNpdHkgdCAtIDEgZG9cbiAgICBpZiBPcHRpb25fYXJyYXkuaXNfc29tZSB0IGkgdGhlbiByIDo9IGYgIXIgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdCBpKVxuICBkb25lO1xuICAhclxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBsZXQgciA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBjYXBhY2l0eSB0IC0gMSBkb1xuICAgIGlmIE9wdGlvbl9hcnJheS5pc19zb21lIHQgaSB0aGVuIHIgOj0gZiBpICFyIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQgaSlcbiAgZG9uZTtcbiAgIXJcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gY2FwYWNpdHkgdCAtIDEgZG9cbiAgICBpZiBPcHRpb25fYXJyYXkuaXNfc29tZSB0IGkgdGhlbiBmIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQgaSlcbiAgZG9uZVxuOztcblxubGV0IGV4aXN0cyB0IH5mID1cbiAgT3B0aW9uX2FycmF5LmV4aXN0cyB0IH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgIHwgU29tZSB4IC0+IGYgeClcbjs7XG5cbigqIFRoZSBkZWZhdWx0IHNleHAgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpcyBodWdlIGFuZCBwb2xsdXRlcyBkZWJ1ZyBvdXRwdXQgKilcbmxldCBzZXhwX29mX3Qgc2V4cF9vZiB0ID1cbiAgbGV0IGZkX2FsaXN0ID0gZm9sZGkgfmluaXQ6W10gdCB+ZjooZnVuIGkgYWNjIHggLT4gKGksIHNleHBfb2YgeCkgOjogYWNjKSBpblxuICBbJXNleHBfb2Y6IChpbnQgKiBTZXhwLnQpIGxpc3RdIChMaXN0LnJldiBmZF9hbGlzdClcbjs7XG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIHRyeVxuICAgIGZvciBpID0gMCB0byBjYXBhY2l0eSB0IC0gMSBkb1xuICAgICAgbWF0Y2ggT3B0aW9uX2FycmF5LmdldCB0IGkgd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgZmQgLT5cbiAgICAgICAgUmF3X2ZkLmludmFyaWFudCBmZDtcbiAgICAgICAgYXNzZXJ0IChGaWxlX2Rlc2NyLmVxdWFsIChpIHw+IEZpbGVfZGVzY3Iub2ZfaW50KSAoUmF3X2ZkLmZpbGVfZGVzY3IgZmQpKVxuICAgIGRvbmVcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiQnlfZGVzY3IuaW52YXJpYW50IGZhaWx1cmVcIiAoZXhuIDogZXhuKSB+ZmQ6KHQgOiBSYXdfZmQudCB0KV1cbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gQXN5bmNfa2VybmVsLkNsb2NrX25zXG5tb2R1bGUgT3JfdGltZW91dCA9IE9yX3RpbWVvdXRcblxubGV0IHJ1bl9hdCB0aW1lIGYgYSA9IHJ1bl9hdCAoVGltZV9ucy5vZl90aW1lX2Zsb2F0X3JvdW5kX25lYXJlc3QgdGltZSkgZiBhXG5sZXQgcnVuX2FmdGVyIHNwYW4gZiBhID0gcnVuX2FmdGVyIChUaW1lX25zLlNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0IHNwYW4pIGYgYVxubGV0IGF0IHRpbWUgPSBhdCAoVGltZV9ucy5vZl90aW1lX2Zsb2F0X3JvdW5kX25lYXJlc3QgdGltZSlcbmxldCBhZnRlciBzcGFuID0gYWZ0ZXIgKFRpbWVfbnMuU3Bhbi5vZl9zcGFuX2Zsb2F0X3JvdW5kX25lYXJlc3Qgc3BhbilcbmxldCB3aXRoX3RpbWVvdXQgc3BhbiBkID0gd2l0aF90aW1lb3V0IChUaW1lX25zLlNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0IHNwYW4pIGRcblxubGV0IHdpdGhfdGltZW91dF9leG4gc3BhbiBkIH5lcnJvciA9XG4gIHdpdGhfdGltZW91dF9leG4gKFRpbWVfbnMuU3Bhbi5vZl9zcGFuX2Zsb2F0X3JvdW5kX25lYXJlc3Qgc3BhbikgZCB+ZXJyb3Jcbjs7XG5cbm1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICBtb2R1bGUgQWJvcnRfcmVzdWx0ID0gRXZlbnQuQWJvcnRfcmVzdWx0XG4gIG1vZHVsZSBGaXJlZCA9IEV2ZW50LkZpcmVkXG4gIG1vZHVsZSBSZXNjaGVkdWxlX3Jlc3VsdCA9IEV2ZW50LlJlc2NoZWR1bGVfcmVzdWx0XG5cbiAgdHlwZSAoJ2EsICdoKSB0ID0gKCdhLCAnaCkgRXZlbnQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlIHRfdW5pdCA9IEV2ZW50LnRfdW5pdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgPSBFdmVudC5pbnZhcmlhbnRcbiAgbGV0IGFib3J0ID0gRXZlbnQuYWJvcnRcbiAgbGV0IGFib3J0X2V4biA9IEV2ZW50LmFib3J0X2V4blxuICBsZXQgYWJvcnRfaWZfcG9zc2libGUgPSBFdmVudC5hYm9ydF9pZl9wb3NzaWJsZVxuICBsZXQgZmlyZWQgPSBFdmVudC5maXJlZFxuICBsZXQgc2NoZWR1bGVkX2F0IHQgPSBUaW1lX25zLnRvX3RpbWVfZmxvYXRfcm91bmRfbmVhcmVzdCAoRXZlbnQuc2NoZWR1bGVkX2F0IHQpXG4gIGxldCBhdCB0aW1lID0gRXZlbnQuYXQgKFRpbWVfbnMub2ZfdGltZV9mbG9hdF9yb3VuZF9uZWFyZXN0IHRpbWUpXG4gIGxldCBhZnRlciBzcGFuID0gRXZlbnQuYWZ0ZXIgKFRpbWVfbnMuU3Bhbi5vZl9zcGFuX2Zsb2F0X3JvdW5kX25lYXJlc3Qgc3BhbilcblxuICBsZXQgcmVzY2hlZHVsZV9hdCB0IHRpbWUgPVxuICAgIEV2ZW50LnJlc2NoZWR1bGVfYXQgdCAoVGltZV9ucy5vZl90aW1lX2Zsb2F0X3JvdW5kX25lYXJlc3QgdGltZSlcbiAgOztcblxuICBsZXQgcmVzY2hlZHVsZV9hZnRlciB0IHNwYW4gPVxuICAgIEV2ZW50LnJlc2NoZWR1bGVfYWZ0ZXIgdCAoVGltZV9ucy5TcGFuLm9mX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCBzcGFuKVxuICA7O1xuXG4gIGxldCBydW5fYXQgdGltZSBmIHggPSBFdmVudC5ydW5fYXQgKFRpbWVfbnMub2ZfdGltZV9mbG9hdF9yb3VuZF9uZWFyZXN0IHRpbWUpIGYgeFxuXG4gIGxldCBydW5fYWZ0ZXIgc3BhbiBmIHggPVxuICAgIEV2ZW50LnJ1bl9hZnRlciAoVGltZV9ucy5TcGFuLm9mX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCBzcGFuKSBmIHhcbiAgOztcblxuICBtb2R1bGUgU3RhdHVzID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgIHwgQWJvcnRlZCBvZiAnYVxuICAgICAgfCBIYXBwZW5lZCBvZiAnaFxuICAgICAgfCBTY2hlZHVsZWRfYXQgb2YgVGltZS50XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbGV0IHN0YXR1cyB0IDogXyBTdGF0dXMudCA9XG4gICAgbWF0Y2ggRXZlbnQuc3RhdHVzIHQgd2l0aFxuICAgIHwgQWJvcnRlZCBhIC0+IEFib3J0ZWQgYVxuICAgIHwgSGFwcGVuZWQgaCAtPiBIYXBwZW5lZCBoXG4gICAgfCBTY2hlZHVsZWRfYXQgdGltZSAtPiBTY2hlZHVsZWRfYXQgKFRpbWVfbnMudG9fdGltZV9mbG9hdF9yb3VuZF9uZWFyZXN0IHRpbWUpXG4gIDs7XG5lbmRcblxubGV0IGF0X3ZhcnlpbmdfaW50ZXJ2YWxzID9zdG9wIGYgPVxuICBhdF92YXJ5aW5nX2ludGVydmFscyA/c3RvcCAoZnVuICgpIC0+IFRpbWVfbnMuU3Bhbi5vZl9zcGFuX2Zsb2F0X3JvdW5kX25lYXJlc3QgKGYgKCkpKVxuOztcblxubGV0IGF0X2ludGVydmFscyA/c3RhcnQgP3N0b3Agc3BhbiA9XG4gIGxldCBzdGFydCA9IE9wdGlvbi5tYXAgc3RhcnQgfmY6VGltZV9ucy5vZl90aW1lX2Zsb2F0X3JvdW5kX25lYXJlc3QgaW5cbiAgYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCAoVGltZV9ucy5TcGFuLm9mX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCBzcGFuKVxuOztcblxubGV0IGV2ZXJ5JyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZCBzcGFuIGYgPVxuICBldmVyeSdcbiAgICA/c3RhcnRcbiAgICA/c3RvcFxuICAgID9jb250aW51ZV9vbl9lcnJvclxuICAgID9maW5pc2hlZFxuICAgIChUaW1lX25zLlNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0IHNwYW4pXG4gICAgZlxuOztcblxubGV0IGV2ZXJ5ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3Igc3BhbiBmID1cbiAgZXZlcnkgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciAoVGltZV9ucy5TcGFuLm9mX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCBzcGFuKSBmXG47O1xuXG5sZXQgcnVuX2F0X2ludGVydmFscycgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciBzcGFuIGYgPVxuICBsZXQgc3RhcnQgPSBPcHRpb24ubWFwIHN0YXJ0IH5mOlRpbWVfbnMub2ZfdGltZV9mbG9hdF9yb3VuZF9uZWFyZXN0IGluXG4gIHJ1bl9hdF9pbnRlcnZhbHMnXG4gICAgP3N0YXJ0XG4gICAgP3N0b3BcbiAgICA/Y29udGludWVfb25fZXJyb3JcbiAgICAoVGltZV9ucy5TcGFuLm9mX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCBzcGFuKVxuICAgIGZcbjs7XG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3Igc3BhbiBmID1cbiAgbGV0IHN0YXJ0ID0gT3B0aW9uLm1hcCBzdGFydCB+ZjpUaW1lX25zLm9mX3RpbWVfZmxvYXRfcm91bmRfbmVhcmVzdCBpblxuICBydW5fYXRfaW50ZXJ2YWxzXG4gICAgP3N0YXJ0XG4gICAgP3N0b3BcbiAgICA/Y29udGludWVfb25fZXJyb3JcbiAgICAoVGltZV9ucy5TcGFuLm9mX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCBzcGFuKVxuICAgIGZcbjs7XG5cbmxldCBkdXJhdGlvbl9vZiBmID1cbiAgbGV0JW1hcCByZXMsIHNwYW4gPSBkdXJhdGlvbl9vZiBmIGluXG4gIHJlcywgVGltZV9ucy5TcGFuLnRvX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCBzcGFuXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBEdW1wX3R5cGUgPSBzdHJ1Y3RcbiAgKCogVGhpcyB2YXJpYW50IG1pcnJvcnMgYW4gZW51bSBpbiB0aGUgQywgc28gb3JkZXIgaW4gdGhpcyBkZWNsYXJhdGlvbiBtYXR0ZXJzLiAqKVxuICB0eXBlIHQgPVxuICAgIHwgQ2FsbF9hYm9ydFxuICAgIHwgQ2FsbF9nY29yZVxuZW5kXG5cbmV4dGVybmFsIGR1bXBfY29yZSA6IER1bXBfdHlwZS50IC0+IHVuaXQgPSBcImR1bXBfY29yZV9vbl9qb2JfZGVsYXlfZHVtcF9jb3JlXCJcbmV4dGVybmFsIHdhdGNoIDogZmxvYXQgLT4gRHVtcF90eXBlLnQgLT4gdW5pdCA9IFwiZHVtcF9jb3JlX29uX2pvYl9kZWxheV93YXRjaFwiXG5leHRlcm5hbCB0aWNrIDogdW5pdCAtPiB1bml0ID0gXCJkdW1wX2NvcmVfb25fam9iX2RlbGF5X3RpY2tcIlxuXG5tb2R1bGUgSG93X3RvX2R1bXAgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDb25maWcuRHVtcF9jb3JlX29uX2pvYl9kZWxheS5Ib3dfdG9fZHVtcFxuXG4gIGxldCBjaG9vc2VfZHVtcF90eXBlIDogdCAtPiBEdW1wX3R5cGUudCA9IGZ1bmN0aW9uXG4gICAgfCBDYWxsX2Fib3J0IC0+IENhbGxfYWJvcnRcbiAgICB8IENhbGxfZ2NvcmUgLT4gQ2FsbF9nY29yZVxuICAgIHwgRGVmYXVsdCAtPlxuICAgICAgKG1hdGNoIFN5c191bml4LmZpbGVfZXhpc3RzIFwiL3Vzci9iaW4vZ2NvcmVcIiB3aXRoXG4gICAgICAgfCBgWWVzIC0+IENhbGxfZ2NvcmVcbiAgICAgICB8IGBObyB8IGBVbmtub3duIC0+IENhbGxfYWJvcnQpXG4gIDs7XG5lbmRcblxubGV0IHN0YXJ0X3dhdGNoaW5nIH5kdW1wX2lmX2RlbGF5ZWRfYnkgfmhvd190b19kdW1wID1cbiAgbGV0IGR1bXBfdHlwZSA9IEhvd190b19kdW1wLmNob29zZV9kdW1wX3R5cGUgaG93X3RvX2R1bXAgaW5cbiAgbGV0IGR1bXBfaWZfZGVsYXllZF9ieV9zZWMgPSBUaW1lLlNwYW4udG9fc2VjIGR1bXBfaWZfZGVsYXllZF9ieSBpblxuICBsZXQgdGlja19pbnRlcnZhbCA9IHNlYyAoZHVtcF9pZl9kZWxheWVkX2J5X3NlYyAvLiAxMC4pIGluXG4gIGlnbm9yZVxuICAgIChUaHJlYWQuY3JlYXRlXG4gICAgICAgfm9uX3VuY2F1Z2h0X2V4bjpgUHJpbnRfdG9fc3RkZXJyXG4gICAgICAgKGZ1biAoKSAtPiB3YXRjaCBkdW1wX2lmX2RlbGF5ZWRfYnlfc2VjIGR1bXBfdHlwZSlcbiAgICAgICAoKVxuICAgICAgOiBUaHJlYWQudCk7XG4gIENsb2NrLmV2ZXJ5IHRpY2tfaW50ZXJ2YWwgdGlja1xuOztcblxubGV0IGR1bXBfY29yZSA/KGhvd190b19kdW1wID0gSG93X3RvX2R1bXAuRGVmYXVsdCkgKCkgPVxuICBkdW1wX2NvcmUgKEhvd190b19kdW1wLmNob29zZV9kdW1wX3R5cGUgaG93X3RvX2R1bXApXG47O1xuIiwiKCoqIFtGaWxlX2Rlc2NyX3dhdGNoZXJfaW50Zi5TXSBwcm92aWRlcyBhbiBBUEkgZm9yIGZvciB3YXRjaGluZyBhIHNldCBvZiBmaWxlIGRlc2NyaXB0b3JzXG4gICAgdG8gc2VlIGlmIHRoZXkgYXJlIHJlYWR5IGZvciByZWFkaW5nIG9yIHdyaXRpbmcuXG5cbiAgICBXZSBoYXZlIHR3byBpbXBsZW1lbnRhdGlvbnMsIG9uZSB1c2luZyBlcG9sbCwgYW5kIG9uZSB1c2luZyBzZWxlY3QuXG5cbiAgICBOb25lIG9mIHRoZSBmdW5jdGlvbnMgbmVlZCB0byBiZSB0aHJlYWQtc2FmZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mXG4gICAgW3RocmVhZF9zYWZlX2NoZWNrXS4gIFNvIHRoYXQgaW1wbGVtZW50YXRpb25zIGNhbiBlYXNpbHkgZG8gbm9uLXRocmVhZC1zYWZlIGFjdGlvbnMsXG4gICAgY2hlY2tpbmcgZm9yIHJlYWR5IEkvTyBpcyBhbHdheXMgZG9uZSBpbiB0aHJlZSBzdGVwczpcblxuICAgIDEuIFtwcmVfY2hlY2tdLCB3aGlsZSBob2xkaW5nIHRoZSBhc3luYyBsb2NrXG4gICAgMi4gW3RocmVhZF9zYWZlX2NoZWNrXSwgd2hpbGUgbm90IGhvbGRpbmcgdGhlIGFzeW5jIGxvY2tcbiAgICAzLiBbcG9zdF9jaGVja10sIHdoaWxlIGhvbGRpbmcgdGhlIGFzeW5jIGxvY2sgKilcblxub3BlbiEgQ29yZVxub3BlbiBJbXBvcnRcblxubW9kdWxlIFRpbWVvdXQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICAoKl8gcGVyZm9ybWFuY2UgaGFjazogYXZvaWQgYWxsb2NhdGlvbiAqKVxuICAgIHwgSW1tZWRpYXRlbHkgOiB1bml0IHRcbiAgICB8IEFmdGVyIDogVGltZV9ucy5TcGFuLnQgdFxuXG4gIGxldCB2YXJpYW50X29mIDogdHlwZSBhLiBhIHQgLT4gYSAtPiBbIGBJbW1lZGlhdGVseSB8IGBBZnRlciBvZiBUaW1lX25zLlNwYW4udCBdID1cbiAgICBmdW4gdCBzcGFuX29yX3VuaXQgLT5cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEltbWVkaWF0ZWx5IC0+IGBJbW1lZGlhdGVseVxuICAgIHwgQWZ0ZXIgLT4gYEFmdGVyIChzcGFuX29yX3VuaXQgOiBUaW1lX25zLlNwYW4udClcbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gICgqKiBBIGZpbGUtZGVzY3Itd2F0Y2hlciBpcyBlc3NlbnRpYWxseSBhIG1hcCBmcm9tIFtGaWxlX2Rlc2NyLnRdIHRvIFtib29sXG4gICAgICBSZWFkX3dyaXRlX3BhaXIudF0sIHdoaWNoIGRlZmluZXMgdGhlIHNldCBvZiBmaWxlIGRlc2NyaXB0b3JzIGJlaW5nIHdhdGNoZWQsIGFuZCBmb3JcbiAgICAgIGVhY2ggZmlsZSBkZXNjcmlwdG9yLCB3aGV0aGVyIGl0IGlzIGJlaW5nIHdhdGNoZWQgZm9yIHJlYWQsIHdyaXRlLCBvciBib3RoLiBJZiBhXG4gICAgICBmaWxlIGRlc2NyaXB0b3IgaXMgbm90IGJlaW5nIHdhdGNoZWQgZm9yIGVpdGhlciwgaXQgaXMgbm90IGluIHRoZSBtYXAuICopXG4gIHR5cGUgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICgqKiBbYWRkaXRpb25hbF9jcmVhdGVfYXJnc10gYWJzdHJhY3RzIG92ZXIgdGhlIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGRpZmZlcmVudFxuICAgICAgZmlsZS1kZXNjci13YXRjaGVyJ3MgW2NyZWF0ZV0gZnVuY3Rpb24uICopXG4gIHR5cGUgJ2EgYWRkaXRpb25hbF9jcmVhdGVfYXJnc1xuXG4gICgqKiBbY3JlYXRlIH5udW1fZmlsZV9kZXNjcnNdIGNyZWF0ZXMgYSBuZXcgZmlsZS1kZXNjci13YXRjaGVyIHRoYXQgaXMgYWJsZSB0byB3YXRjaFxuICAgICAgZmlsZSBkZXNjcmlwdG9ycyBpbiB7WyBbMCwgbnVtX2ZpbGVfZGVzY3JzKSBdfS4gKilcbiAgdmFsIGNyZWF0ZVxuICAgIDogKG51bV9maWxlX2Rlc2NyczppbnRcbiAgICAgICAtPiBoYW5kbGVfZmRfcmVhZF9yZWFkeTooRmlsZV9kZXNjci50IC0+IHVuaXQpXG4gICAgICAgLT4gaGFuZGxlX2ZkX3dyaXRlX3JlYWR5OihGaWxlX2Rlc2NyLnQgLT4gdW5pdClcbiAgICAgICAtPiB0KVxuICAgICAgYWRkaXRpb25hbF9jcmVhdGVfYXJnc1xuXG4gIHZhbCBiYWNrZW5kIDogQ29uZmlnLkZpbGVfZGVzY3Jfd2F0Y2hlci50XG5cbiAgKCoqIFtzZXRdIGFsdGVycyB0aGUgbWFwIG9mIGZpbGUgZGVzY3JpcHRvcnMgYmVpbmcgd2F0Y2hlZC4gIEl0IHdpbGwgdGFrZSBlZmZlY3Qgb24gdGhlXG4gICAgICBuZXh0IGNhbGwgdG8gW3RocmVhZF9zYWZlX2NoZWNrXS4gIENhbGxpbmcgW3NldCBmZF0gd2l0aCBbeyByZWFkID0gZmFsc2UsIHdyaXRlID1cbiAgICAgIGZhbHNlIH1dIHJlbW92ZXMgW2ZkXSBmcm9tIHRoZSBtYXAuXG4gICAgICBbYFVuc3VwcG9ydGVkXSBjYW4gYmUgcmV0dXJuZWQgZm9yIGZpbGUgZGVzY3JpcHRvcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBwb2xsaW5nLlxuICAgICAgVGhpcyB1c3VhbGx5IChhbHdheXM/KSBtZWFucyB0aGF0IHRoZXkgYXJlIGFsd2F5cyByZWFkeSBmb3IgcmVhZCBvciB3cml0ZS5cbiAgKilcbiAgdmFsIHNldCA6IHQgLT4gRmlsZV9kZXNjci50IC0+IGJvb2wgUmVhZF93cml0ZV9wYWlyLnQgLT4gWyBgT2sgfCBgVW5zdXBwb3J0ZWQgXVxuXG4gICgqKiBbaXRlciB0IH5mXSBpdGVyYXRlcyBvdmVyIGV2ZXJ5IGZpbGUgZGVzY3JpcHRvciBpbiB0aGUgbWFwLCBhcHBseSBbZl0gdG8gaXQgb25jZVxuICAgICAgZm9yIGVhY2ggb2YgXFx7YFJlYWQsYFdyaXRlXFx9IHRoYXQgaXQgaXMgYmVpbmcgd2F0Y2hlZCBmb3IuICopXG4gIHZhbCBpdGVyIDogdCAtPiBmOihGaWxlX2Rlc2NyLnQgLT4gUmVhZF93cml0ZV9wYWlyLktleS50IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW3ByZV9jaGVjayB0XSBkb2VzIHdoYXRldmVyIG5vbi10aHJlYWQtc2FmZSB3b3JrIGlzIG5lY2Vzc2FyeSB0byBwcmVwYXJlIGZvciB0aGVcbiAgICAgIHN5c3RlbSBjYWxsIHRoYXQgY2hlY2tzIGZpbGUgZGVzY3JpcHRvcnMgYmVpbmcgcmVhZHkgZm9yIHJlYWQgb3Igd3JpdGUuICBbcHJlX2NoZWNrXVxuICAgICAgZG9lcyBub3Qgc2lkZSBlZmZlY3QgW3RdLiAqKVxuICBtb2R1bGUgUHJlIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIHZhbCBwcmVfY2hlY2sgOiB0IC0+IFByZS50XG5cbiAgKCoqIFt0aHJlYWRfc2FmZV9jaGVjayB0IHByZSB0aW1lb3V0IHNwYW5fb3JfdW5pdF0gY2hlY2tzIHRoZSBmaWxlIGRlc2NyaXB0b3JzIGZvciB0aGVpclxuICAgICAgc3RhdHVzIGFuZCByZXR1cm5zIHdoZW4gYXQgbGVhc3Qgb25lIGlzIGF2YWlsYWJsZSwgb3IgdGhlIFt0aW1lb3V0LCBzcGFuX29yX3VuaXRdXG4gICAgICBwYXNzZXMuICBbdGhyZWFkX3NhZmVfY2hlY2tdIGRvZXMgbm90IHNpZGUgZWZmZWN0IFt0XS4gIFVubGlrZSB0aGUgcmVzdCBvZiB0aGVcbiAgICAgIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSwgW3RocmVhZF9zYWZlX2NoZWNrXSBpcyB0aHJlYWQgc2FmZS4gKilcbiAgbW9kdWxlIENoZWNrX3Jlc3VsdCA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICB2YWwgdGhyZWFkX3NhZmVfY2hlY2sgOiB0IC0+IFByZS50IC0+ICdhIFRpbWVvdXQudCAtPiAnYSAtPiBDaGVja19yZXN1bHQudFxuXG4gICgqKiBbcG9zdF9jaGVjayB0IGNoZWNrX3Jlc3VsdF0gY2FsbHMgdGhlIFtoYW5kbGVfZmQqXSBmdW5jdGlvbnMgc3VwcGxpZWQgdG8gW2NyZWF0ZV06XG5cbiAgICAgIDEuIGZvciBlYWNoIGZpbGUgZGVzY3JpcHRvciB0aGF0IGlzIHJlYWR5IHRvIGJlIHdyaXR0ZW4gdG8sIHRoZW5cbiAgICAgIDIuIGZvciBlYWNoIGZpbGUgZGVzY3JpcHRvciB0aGF0IGlzIHJlYWR5IHRvIGJlIHJlYWQgZnJvbS5cblxuICAgICAgV2UgaGFuZGxlIHdyaXRlcyBiZWZvcmUgcmVhZHMgc28gdGhhdCB3ZSBnZXQgYWxsIHRoZSB3cml0ZXMgc3RhcnRlZCBnb2luZyB0byB0aGVcbiAgICAgIGV4dGVybmFsIHdvcmxkIGJlZm9yZSB3ZSBwcm9jZXNzIGFsbCB0aGUgcmVhZHMuICBUaGlzIHdpbGwgbmljZWx5IGJhdGNoIHRvZ2V0aGVyXG4gICAgICBhbGwgdGhlIG91dHB1dCBiYXNlZCBvbiB0aGUgcmVhZHMgZm9yIHRoZSBuZXh0IHdyaXRlcy5cblxuICAgICAgSXQgaXMgZ3VhcmFudGVlZCB0aGF0IGl0IGNhbGxzIFtoYW5kbGVfZmRfcmVhZCpdIG9ubHkgb24gYW4gW2ZkXSB0aGF0IGlzIHdhdGNoZWQgZm9yXG4gICAgICByZWFkIGFzIHBlciBbc2V0XSwgYW5kIFtoYW5kbGVfZmRfd3JpdGUqXSBvbmx5IG9uIGFuIFtmZF0gdGhhdCBpcyB3YXRjaGVkIGZvciB3cml0ZVxuICAgICAgYXMgcGVyIFtzZXRdLiAqKVxuICB2YWwgcG9zdF9jaGVjayA6IHQgLT4gQ2hlY2tfcmVzdWx0LnQgLT4gdW5pdFxuXG4gIHZhbCByZXNldF9pbl9mb3JrZWRfcHJvY2VzcyA6IHQgLT4gdW5pdFxuZW5kXG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIEZpbGVfZGVzY3Jfd2F0Y2hlcl9pbnRmXG5vcGVuIFJlYWRfd3JpdGVfcGFpci5FeHBvcnRcbm1vZHVsZSBFcG9sbCA9IExpbnV4X2V4dC5FcG9sbFxubW9kdWxlIFRpbWVyZmQgPSBMaW51eF9leHQuVGltZXJmZFxuXG5tb2R1bGUgRmxhZ3MgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBFcG9sbC5GbGFnc1xuXG4gIGxldCBpbl9vdXQgPSBpbl8gKyBvdXRcblxuICAoKiBVc2UgdGhlIGVkZ2UtdHJpZ2dlcmVkIGJlaGF2aW9yIHNvIHdlIGRvbid0IGhhdmUgdG8gcmVzZXQgdGhlIHRpbWVyZmQgd2hlbiBpdFxuICAgICBleHBpcmVzLiAqKVxuICBsZXQgZm9yX3RpbWVyZmQgPSBpbl8gKyBldFxuXG4gIGxldCBvZl9ydyA9IGZ1bmN0aW9uXG4gICAgfCBgUmVhZCAtPiBpbl9cbiAgICB8IGBXcml0ZSAtPiBvdXRcbiAgOztcbmVuZFxuXG50eXBlIHQgPVxuICB7IHRpbWVyZmQgOiBUaW1lcmZkLnRcbiAgOyBlcG9sbCA6IEVwb2xsLnRcbiAgOyBoYW5kbGVfZmRfcmVhZF9yZWFkeSA6IEZpbGVfZGVzY3IudCAtPiBGbGFncy50IC0+IHVuaXRcbiAgOyBoYW5kbGVfZmRfd3JpdGVfcmVhZHkgOiBGaWxlX2Rlc2NyLnQgLT4gRmxhZ3MudCAtPiB1bml0XG4gIH1cbltAQGRlcml2aW5nIHNleHBfb2YsIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXJdXG5cbmxldCBiYWNrZW5kID0gQ29uZmlnLkZpbGVfZGVzY3Jfd2F0Y2hlci5FcG9sbFxubGV0IGlzX3RpbWVyZmQgdCBmZCA9IEZpbGVfZGVzY3IuZXF1YWwgZmQgKFRpbWVyZmQudG9fZmlsZV9kZXNjciB0LnRpbWVyZmQpXG5cbmxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+dGltZXJmZDpcbiAgICAgICAgKGNoZWNrIChmdW4gdGltZXJmZCAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBGbGFncy50IG9wdGlvbl1cbiAgICAgICAgICAgICAoRXBvbGwuZmluZCB0LmVwb2xsIChUaW1lcmZkLnRvX2ZpbGVfZGVzY3IgdGltZXJmZCkpXG4gICAgICAgICAgICAgfmV4cGVjdDooU29tZSBGbGFncy5mb3JfdGltZXJmZCkpKVxuICAgICAgfmVwb2xsOlxuICAgICAgICAoY2hlY2sgKGZ1biBlcG9sbCAtPlxuICAgICAgICAgICBFcG9sbC5pdGVyIGVwb2xsIH5mOihmdW4gXyBmbGFncyAtPlxuICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICBMaXN0LmV4aXN0c1xuICAgICAgICAgICAgICAgICBGbGFncy5bIGluXzsgb3V0OyBpbl9vdXQ7IGZvcl90aW1lcmZkIF1cbiAgICAgICAgICAgICAgICAgfmY6KGZ1biBmbGFncycgLT4gRmxhZ3MuZXF1YWwgZmxhZ3MgZmxhZ3MnKSkpKSlcbiAgICAgIH5oYW5kbGVfZmRfcmVhZF9yZWFkeTppZ25vcmVcbiAgICAgIH5oYW5kbGVfZmRfd3JpdGVfcmVhZHk6aWdub3JlXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJFcG9sbF9maWxlX2Rlc2NyX3dhdGNoZXIuaW52YXJpYW50IGZhaWxlZFwiXG4gICAgICAgICAgKGV4biA6IGV4bilcbiAgICAgICAgICB+ZXBvbGxfZmlsZV9kZXNjcl93YXRjaGVyOih0IDogdCldXG47O1xuXG50eXBlICdhIGFkZGl0aW9uYWxfY3JlYXRlX2FyZ3MgPSB0aW1lcmZkOkxpbnV4X2V4dC5UaW1lcmZkLnQgLT4gJ2FcblxubGV0IGNyZWF0ZSB+dGltZXJmZCB+bnVtX2ZpbGVfZGVzY3JzIH5oYW5kbGVfZmRfcmVhZF9yZWFkeSB+aGFuZGxlX2ZkX3dyaXRlX3JlYWR5ID1cbiAgbGV0IGVwb2xsID1cbiAgICBPcl9lcnJvci5va19leG5cbiAgICAgIEVwb2xsLmNyZWF0ZVxuICAgICAgfm51bV9maWxlX2Rlc2Nyc1xuICAgICAgfm1heF9yZWFkeV9ldmVudHM6KEVwb2xsX21heF9yZWFkeV9ldmVudHMucmF3IENvbmZpZy5lcG9sbF9tYXhfcmVhZHlfZXZlbnRzKVxuICBpblxuICBsZXQgZXJyX29yX2h1cCA9IEZsYWdzLihodXAgKyBlcnIpIGluXG4gIGxldCBoYW5kbGVfZmQgcmVhZF9vcl93cml0ZSBoYW5kbGVfZmQgPVxuICAgIGxldCBiaXQgPSBGbGFncy5vZl9ydyByZWFkX29yX3dyaXRlIGluXG4gICAgZnVuIGZpbGVfZGVzY3IgZmxhZ3MgLT5cbiAgICAgICgqIEEgZGlmZmVyZW5jZSBiZXR3ZWVuIHNlbGVjdCBhbmQgZXBvbGwgY3JvcHMgdXAgaGVyZTogZXBvbGwgaGFzIGltcGxpY2l0IGV2ZW50XG4gICAgICAgICBmbGFncyBmb3IgaGFuZ3VwIChIVVApIGFuZCBlcnJvciAoRVJSKSwgd2hlcmVhcyBzZWxlY3Qgd2lsbCBqdXN0IHJldHVybiB0aGF0IGZkXG4gICAgICAgICBhcyBcInJlYWR5XCIgaW4gaXRzIGFwcHJvcHJpYXRlIGZkX3NldC4gIFNpbmNlIHdlIGRvbid0IGtub3cgaWYgaXQncyByZWFkeSBmb3IgSU5cbiAgICAgICAgIG9yIE9VVCwgd2UgaGF2ZSB0byBnbyBsb29rdXAgdGhlIGVudHJ5IGlmIHRoZSBIVVAgb3IgRVJSIGZsYWcgaXMgc2V0LiAqKVxuICAgICAgaWYgRmxhZ3MuZG9faW50ZXJzZWN0IGZsYWdzIGJpdFxuICAgICAgICAgfHwgKEZsYWdzLmRvX2ludGVyc2VjdCBmbGFncyBlcnJfb3JfaHVwXG4gICAgICAgICAgICAgJiYgRmxhZ3MuZG9faW50ZXJzZWN0IChFcG9sbC5maW5kX2V4biBlcG9sbCBmaWxlX2Rlc2NyKSBiaXQpXG4gICAgICB0aGVuIGhhbmRsZV9mZCBmaWxlX2Rlc2NyXG4gIGluXG4gIEVwb2xsLnNldCBlcG9sbCAoVGltZXJmZC50b19maWxlX2Rlc2NyIHRpbWVyZmQpIEZsYWdzLmZvcl90aW1lcmZkO1xuICB7IHRpbWVyZmRcbiAgOyBlcG9sbFxuICA7IGhhbmRsZV9mZF9yZWFkX3JlYWR5ID0gaGFuZGxlX2ZkIGBSZWFkIGhhbmRsZV9mZF9yZWFkX3JlYWR5XG4gIDsgaGFuZGxlX2ZkX3dyaXRlX3JlYWR5ID0gaGFuZGxlX2ZkIGBXcml0ZSBoYW5kbGVfZmRfd3JpdGVfcmVhZHlcbiAgfVxuOztcblxubGV0IHJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzIHQgPSBFcG9sbC5jbG9zZSB0LmVwb2xsXG5cbmxldCBpdGVyIHQgfmYgPVxuICBFcG9sbC5pdGVyIHQuZXBvbGwgfmY6KGZ1biBmaWxlX2Rlc2NyIGZsYWdzIC0+XG4gICAgaWYgbm90IChpc190aW1lcmZkIHQgZmlsZV9kZXNjcilcbiAgICB0aGVuIChcbiAgICAgIGlmIEZsYWdzLmRvX2ludGVyc2VjdCBmbGFncyBGbGFncy5pbl8gdGhlbiBmIGZpbGVfZGVzY3IgYFJlYWQ7XG4gICAgICBpZiBGbGFncy5kb19pbnRlcnNlY3QgZmxhZ3MgRmxhZ3Mub3V0IHRoZW4gZiBmaWxlX2Rlc2NyIGBXcml0ZSkpXG47O1xuXG5sZXQgc2V0IHQgZmlsZV9kZXNjciBkZXNpcmVkID1cbiAgbGV0IGFjdHVhbF9mbGFncyA9IEVwb2xsLmZpbmQgdC5lcG9sbCBmaWxlX2Rlc2NyIGluXG4gIGxldCBkZXNpcmVkX2ZsYWdzID1cbiAgICBtYXRjaCBkZXNpcmVkLnJlYWQsIGRlc2lyZWQud3JpdGUgd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlIC0+IE5vbmVcbiAgICB8IHRydWUsIGZhbHNlIC0+IFNvbWUgRmxhZ3MuaW5fXG4gICAgfCBmYWxzZSwgdHJ1ZSAtPiBTb21lIEZsYWdzLm91dFxuICAgIHwgdHJ1ZSwgdHJ1ZSAtPiBTb21lIEZsYWdzLmluX291dFxuICBpblxuICBtYXRjaCBhY3R1YWxfZmxhZ3MsIGRlc2lyZWRfZmxhZ3Mgd2l0aFxuICB8IE5vbmUsIE5vbmUgLT4gYE9rXG4gIHwgTm9uZSwgU29tZSBkIC0+XG4gICAgKG1hdGNoIEVwb2xsLnNldCB0LmVwb2xsIGZpbGVfZGVzY3IgZCB3aXRoXG4gICAgIHwgZXhjZXB0aW9uIENvcmVfdW5peC5Vbml4X2Vycm9yIChFUEVSTSwgXywgXykgLT4gYFVuc3VwcG9ydGVkXG4gICAgIHwgKCkgLT4gYE9rKVxuICB8IFNvbWUgXywgTm9uZSAtPlxuICAgIEVwb2xsLnJlbW92ZSB0LmVwb2xsIGZpbGVfZGVzY3I7XG4gICAgYE9rXG4gIHwgU29tZSBhLCBTb21lIGQgLT5cbiAgICBpZiBub3QgKEZsYWdzLmVxdWFsIGEgZCkgdGhlbiBFcG9sbC5zZXQgdC5lcG9sbCBmaWxlX2Rlc2NyIGQ7XG4gICAgYE9rXG47O1xuXG5tb2R1bGUgUHJlID0gc3RydWN0XG4gIHR5cGUgdCA9IHVuaXQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5sZXQgcHJlX2NoZWNrIF90ID0gKClcblxubW9kdWxlIENoZWNrX3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPSAoWyBgT2sgfCBgVGltZW91dCBdLCBleG4gKiBCYWNrdHJhY2UudCkgUmVzdWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgb2sgPSBPayBgT2tcbiAgbGV0IHRpbWVvdXQgPSBPayBgVGltZW91dFxuZW5kXG5cbmxldCBlcG9sbF93YWl0ICh0eXBlIGEpIChlcG9sbCA6IEVwb2xsLnQpICh0aW1lb3V0IDogYSBUaW1lb3V0LnQpIChzcGFuX29yX3VuaXQgOiBhKSA9XG4gIG1hdGNoIHRpbWVvdXQgd2l0aFxuICB8IEltbWVkaWF0ZWx5IC0+IEVwb2xsLndhaXQgZXBvbGwgfnRpbWVvdXQ6YEltbWVkaWF0ZWx5XG4gIHwgQWZ0ZXIgLT4gRXBvbGwud2FpdF90aW1lb3V0X2FmdGVyIGVwb2xsIHNwYW5fb3JfdW5pdFxuOztcblxubGV0IHRocmVhZF9zYWZlX2NoZWNrIHQgKCkgdGltZW91dCBzcGFuX29yX3VuaXQgPVxuICBtYXRjaCBlcG9sbF93YWl0IHQuZXBvbGwgdGltZW91dCBzcGFuX29yX3VuaXQgd2l0aFxuICB8IGBPayAtPiBDaGVja19yZXN1bHQub2tcbiAgfCBgVGltZW91dCAtPiBDaGVja19yZXN1bHQudGltZW91dFxuICB8IGV4Y2VwdGlvbiBlIC0+IEVycm9yIChlLCBCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50ICgpKVxuOztcblxubGV0IHBvc3RfY2hlY2sgdCBjaGVja19yZXN1bHQgPVxuICB0cnlcbiAgICBtYXRjaCBjaGVja19yZXN1bHQgd2l0aFxuICAgICgqIFdlIHRoaW5rIDUxNCBzaG91bGQgYmUgdHJlYXRlZCBsaWtlIEVJTlRSLiAqKVxuICAgIHwgRXJyb3IgKFVuaXguVW5peF9lcnJvciAoKEVJTlRSIHwgRVVOS05PV05FUlIgNTE0KSwgXywgXyksIF8pIC0+ICgpXG4gICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcImVwb2xsIHJhaXNlZCB1bmV4cGVjdGVkIGV4blwiIChleG4gOiBleG4pIChiYWNrdHJhY2UgOiBCYWNrdHJhY2UudCldXG4gICAgfCBPayBgVGltZW91dCAtPiAoKVxuICAgIHwgT2sgYE9rIC0+XG4gICAgICBFcG9sbC5pdGVyX3JlYWR5IHQuZXBvbGwgfmY6dC5oYW5kbGVfZmRfd3JpdGVfcmVhZHk7XG4gICAgICBFcG9sbC5pdGVyX3JlYWR5IHQuZXBvbGwgfmY6dC5oYW5kbGVfZmRfcmVhZF9yZWFkeTtcbiAgICAgIEVwb2xsLkV4cGVydC5jbGVhcl9yZWFkeSB0LmVwb2xsXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudCAoKSBpblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIkVwb2xsLnBvc3RfY2hlY2sgYnVnXCJcbiAgICAgICAgICAoZXhuIDogZXhuKVxuICAgICAgICAgIChiYWNrdHJhY2UgOiBCYWNrdHJhY2UudClcbiAgICAgICAgICAoY2hlY2tfcmVzdWx0IDogQ2hlY2tfcmVzdWx0LnQpXG4gICAgICAgICAgfmVwb2xsX2ZpbGVfZGVzY3Jfd2F0Y2hlcjoodCA6IHQpXVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm1vZHVsZSBGZCA9IFJhd19mZFxuXG5sZXQgZGVidWcgPSBEZWJ1Zy5pbnRlcnJ1cHRvclxuXG50eXBlIHQgPVxuICB7IHBpcGUgOiBGZC50IFJlYWRfd3JpdGVfcGFpci50XG4gIDsgKCogW2FscmVhZHlfaW50ZXJydXB0ZWRdIGtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgd2UndmUgYWxyZWFkeSBpbnRlcnJ1cHRlZCBzaW5jZSB0aGVcbiAgICAgICBtb3N0IHJlY2VudCBjYWxsIHRvIFtjbGVhcl0sIGFuZCBpZiBzbywgYXZvaWQgd3JpdGluZyB0byB0aGUgcGlwZSBhZ2Fpbi5cbiAgICAgICBbYWxyZWFkeV9pbnRlcnJ1cHRlZF0gZG9lcyBub3QgZXhhY3RseSB0cmFjayB0aGUgc3RhdGUgb2YgW3BpcGVdLiAgSXQgaXMgcG9zc2libGVcbiAgICAgICBmb3IgW2FscmVhZHlfaW50ZXJydXB0ZWRdIHRvIGJlIGZhbHNlIGFuZCBmb3IgdGhlIFtwaXBlXSB0byBiZSBub25lbXB0eS4gIFRoZSBrZXlcbiAgICAgICBwcm9wZXJ0eSBpcyB0aGF0IGlmIFthbHJlYWR5X2ludGVycnVwdGVkXSBpcyB0cnVlIHRoZW4gW3BpcGVdIGlzIG5vbmVtcHR5KilcbiAgICBtdXRhYmxlIGFscmVhZHlfaW50ZXJydXB0ZWQgOiBib29sXG4gIDsgY2xlYXJidWZmZXIgOiAoQnl0ZXMudFtAc2V4cC5vcGFxdWVdKVxuICB9XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IF8gPSAoKVxubGV0IHJlYWRfZmQgdCA9IFJlYWRfd3JpdGVfcGFpci5nZXQgdC5waXBlIGBSZWFkXG5cbmxldCBjcmVhdGUgfmNyZWF0ZV9mZCA9XG4gIGxldCBwaXBlX3JlYWQsIHBpcGVfd3JpdGUgPSBVbml4LnBpcGUgKCkgaW5cbiAgVW5peC5zZXRfY2xvc2Vfb25fZXhlYyBwaXBlX3JlYWQ7XG4gIFVuaXguc2V0X2Nsb3NlX29uX2V4ZWMgcGlwZV93cml0ZTtcbiAgbGV0IHBpcGVfcmVhZCA9XG4gICAgY3JlYXRlX2ZkIEZkLktpbmQuRmlmbyBwaXBlX3JlYWQgKEluZm8ub2Zfc3RyaW5nIFwiaW50ZXJydXB0b3JfcGlwZV9yZWFkXCIpXG4gIGluXG4gIGxldCBwaXBlX3dyaXRlID0gY3JlYXRlX2ZkIEZpZm8gcGlwZV93cml0ZSAoSW5mby5vZl9zdHJpbmcgXCJpbnRlcnJ1cHRvcl9waXBlX3dyaXRlXCIpIGluXG4gIHsgcGlwZSA9IFJlYWRfd3JpdGVfcGFpci5jcmVhdGUgfnJlYWQ6cGlwZV9yZWFkIH53cml0ZTpwaXBlX3dyaXRlXG4gIDsgYWxyZWFkeV9pbnRlcnJ1cHRlZCA9IGZhbHNlXG4gIDsgY2xlYXJidWZmZXIgPSBCeXRlcy5tYWtlIDEwMjQgJyAnXG4gIH1cbjs7XG5cbigqIFtieXRlc193XSBpcyBhIHRvcGxldmVsIHRvIG1ha2Ugc3VyZSBpdCdzIG5vdCBhbGxvY2F0ZWQgbXVsdGlwbGUgdGltZXMuICopXG5sZXQgYnl0ZXNfdyA9IEJ5dGVzLm9mX3N0cmluZyBcIndcIlxuXG4oKiBbdGhyZWFkX3NhZmVfaW50ZXJydXB0XVxuICAgQXMgdGhlIG5hbWUgaW1wbGllcywgaXQgaXMgc2FmZSB0byBjYWxsIGZyb20gYW55IHRocmVhZDsgW3RocmVhZF9zYWZlX2ludGVycnVwdF0gZG9lc1xuICAgbm90IGFzc3VtZSB0aGUgc2NoZWR1bGVyIGxvY2sgaXMgaGVsZCwgYWx0aG91Z2ggaXQgaXMgZmluZSBpZiBpdCBpcy4gIEJlY2F1c2Ugb2ZcbiAgIE9DYW1sJ3MgY29tcGlsYXRpb24sIHRoZSB0ZXN0LWFuZC1zZXQgb2YgW3QuYWxyZWFkeV9pbnRlcnJ1cHRlZF0gaXMgYXRvbWljLCBzb1xuICAgd2Ugd2lsbCBvbmx5IGV2ZXIgd3JpdGUgb25lIGJ5dGUgdG8gdGhlIHBpcGUgYmVmb3JlIGl0IGlzIGNsZWFyZWQuICopXG5cbigqIE1hcmtlZCB3aXRoIGF0dHJpYnV0ZXMgc28gYW55IGFsbG9jYXRpb24gYXQgdGhlIGNhbGwgc2l0ZSBjYW5ub3QgYmUgc3VuayBkb3duIGludG8gdGhlXG4gICBhdG9taWMgc2VjdGlvbiAodGhlcmUgZXhpc3RzIG5vIGJhcnJpZXIgaW4gT0NhbWwgcmlnaHQgbm93IHRvIHByZXZlbnQgdGhpcykgKilcbmxldFtAaW5saW5lIG5ldmVyXSBbQHNwZWNpYWxpc2UgbmV2ZXJdIFtAbG9jYWwgbmV2ZXJdIHRocmVhZF9zYWZlX2ludGVycnVwdCB0ID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwiSW50ZXJydXB0b3IudGhyZWFkX3NhZmVfaW50ZXJydXB0XCI7XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBpZiBub3QgdC5hbHJlYWR5X2ludGVycnVwdGVkXG4gIHRoZW4gKFxuICAgIHQuYWxyZWFkeV9pbnRlcnJ1cHRlZCA8LSB0cnVlO1xuICAgICgqIEVORCBBVE9NSUMgKilcbiAgICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJ3cml0aW5nIHRvIGludGVycnVwdF9waXBlX3dyaXRlXCI7XG4gICAgRmQuc3lzY2FsbF9leG5cbiAgICAgIChSZWFkX3dyaXRlX3BhaXIuZ2V0IHQucGlwZSBgV3JpdGUpXG4gICAgICB+bm9uYmxvY2tpbmc6dHJ1ZVxuICAgICAgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgICB0cnkgaWdub3JlIChVbml4LndyaXRlX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyBmaWxlX2Rlc2NyIGJ5dGVzX3cgOiBpbnQpIHdpdGhcbiAgICAgIHwgVW5peC5Vbml4X2Vycm9yICgoRVdPVUxEQkxPQ0sgfCBFQUdBSU4pLCBfLCBfKSAtPiAoKSkpXG47O1xuXG5sZXQgY2xlYXIgdCA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nX3N0cmluZyBcIkludGVycnVwdG9yLmNsZWFyXCI7XG4gICgqIFdlIG9ubHkgbmVlZCB0byBjbGVhciB0aGUgcGlwZSBpZiBpdCB3YXMgd3JpdHRlbiB0by4gIFRoaXMgc2F2ZXMgYSBzeXN0ZW0gY2FsbCBpbiB0aGVcbiAgICAgY29tbW9uIGNhc2UuICopXG4gIGlmIHQuYWxyZWFkeV9pbnRlcnJ1cHRlZFxuICB0aGVuXG4gICAgRmQuc3lzY2FsbF9leG4gKFJlYWRfd3JpdGVfcGFpci5nZXQgdC5waXBlIGBSZWFkKSB+bm9uYmxvY2tpbmc6dHJ1ZSAoZnVuIGZpbGVfZGVzY3IgLT5cbiAgICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICAgIGxldCByZWFkX2FnYWluID1cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIGxldCBieXRlc19yZWFkID1cbiAgICAgICAgICAgICAgVW5peC5yZWFkX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZ1xuICAgICAgICAgICAgICAgIGZpbGVfZGVzY3JcbiAgICAgICAgICAgICAgICB0LmNsZWFyYnVmZmVyXG4gICAgICAgICAgICAgICAgfnBvczowXG4gICAgICAgICAgICAgICAgfmxlbjooQnl0ZXMubGVuZ3RoIHQuY2xlYXJidWZmZXIpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWdub3JlIChieXRlc19yZWFkIDogaW50KTtcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBVbml4LlVuaXhfZXJyb3IgKChFV09VTERCTE9DSyB8IEVBR0FJTiksIF8sIF8pIC0+IGZhbHNlXG4gICAgICAgIGluXG4gICAgICAgIGlmIHJlYWRfYWdhaW4gdGhlbiBsb29wICgpXG4gICAgICBpblxuICAgICAgbG9vcCAoKSk7XG4gICgqIFdlIG11c3QgY2xlYXIgW2FscmVhZHlfaW50ZXJydXB0ZWRdIGFmdGVyIGVtcHR5aW5nIHRoZSBwaXBlLiAgSWYgd2UgZGlkIGl0IGJlZm9yZSxcbiAgICAgYSBbdGhyZWFkX3NhZmVfaW50ZXJydXB0XSBjb3VsZCBjb21lIGFsb25nIGluIGJldHdlZW4uICBXZSB3b3VsZCB0aGVuIGJlIGxlZnQgd2l0aFxuICAgICBbYWxyZWFkeV9pbnRlcnJ1cHRlZCA9IHRydWVdIGFuZCBhbiBlbXB0eSBwaXBlLCB3aGljaCB3b3VsZCB0aGVuIGNhdXNlIGFcbiAgICAgW3RocmVhZF9zYWZlX2ludGVycnVwdF0gYWZ0ZXIgW2NsZWFyXSByZXR1cm5zIHRvIGluY29ycmVjdGx5IGJlIGEgbm8tb3AuICopXG4gIHQuYWxyZWFkeV9pbnRlcnJ1cHRlZCA8LSBmYWxzZVxuOztcblxubGV0IGFscmVhZHlfaW50ZXJydXB0ZWQgdCA9IHQuYWxyZWFkeV9pbnRlcnJ1cHRlZFxuIiwib3BlbiEgQ29yZVxub3BlbiBJbXBvcnRcblxudHlwZSB0XG5cbm1vZHVsZSBJbnQ2MyA9IHN0cnVjdFxuICB0eXBlIHQgW0BAaW1tZWRpYXRlNjRdXG5cbiAgbGV0IG9mX2ludCBfID0gYXNzZXJ0IGZhbHNlXG4gIGxldCB0b19pbnQgXyA9IGFzc2VydCBmYWxzZVxuZW5kXG5cbm1vZHVsZSBGTEFHUyA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgZW1wdHkgPSAwXG4gIGxldCBfID0gZW1wdHlcbiAgbGV0IG9mX2ludCB4ID0geFxuICBsZXQgKCArICkgPSAoIGxvciApXG4gIGxldCBtZW0gYSBiID0gYSBsYW5kIGIgPSBhXG5lbmRcblxubW9kdWxlIFBvbGxfbWFzayA9IHN0cnVjdFxuICBpbmNsdWRlIEZMQUdTXG5cbiAgbGV0IHBvbGxpbiA9IDBcbiAgbGV0IHBvbGxvdXQgPSAwXG4gIGxldCBwb2xsZXJyID0gMFxuICBsZXQgcG9sbGh1cCA9IDBcbmVuZFxuXG5tb2R1bGUgQ2xvY2sgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEJvb3R0aW1lXG4gICAgfCBSZWFsdGltZVxuZW5kXG5cbm1vZHVsZSBTdGF0eCA9IHN0cnVjdFxuICB0eXBlIHRcblxuICB0eXBlIGtpbmQgPVxuICAgIFsgYFVua25vd25cbiAgICB8IGBGaWZvXG4gICAgfCBgQ2hhcmFjdGVyX3NwZWNpYWxcbiAgICB8IGBEaXJlY3RvcnlcbiAgICB8IGBCbG9ja19kZXZpY2VcbiAgICB8IGBSZWd1bGFyX2ZpbGVcbiAgICB8IGBTeW1ib2xpY19saW5rXG4gICAgfCBgU29ja2V0XG4gICAgXVxuXG4gIGxldCBjcmVhdGUgXyA9IGFzc2VydCBmYWxzZVxuXG4gIG1vZHVsZSBGbGFncyA9IHN0cnVjdFxuICAgIGluY2x1ZGUgRkxBR1NcblxuICAgIGxldCBlbXB0eSA9IDBcbiAgICBsZXQgZW1wdHlfcGF0aCA9IDBcbiAgICBsZXQgbm9fYXV0b21vdW50ID0gMFxuICAgIGxldCBzeW1saW5rX25vZm9sbG93ID0gMFxuICAgIGxldCBzdGF0eF9zeW5jX2FzX3N0YXQgPSAwXG4gICAgbGV0IHN0YXR4X2ZvcmNlX3N5bmMgPSAwXG4gICAgbGV0IHN0YXR4X2RvbnRfc3luYyA9IDBcbiAgZW5kXG5cbiAgbW9kdWxlIEF0dHIgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEZMQUdTXG5cbiAgICBsZXQgY29tcHJlc3NlZCA9IDBcbiAgICBsZXQgaW1tdXRhYmxlID0gMFxuICAgIGxldCBhcHBlbmQgPSAwXG4gICAgbGV0IG5vZHVtcCA9IDBcbiAgICBsZXQgZW5jcnlwdGVkID0gMFxuICAgIGxldCB2ZXJpdHkgPSAwXG5cbiAgICAoKiogU2luY2UgTGludXggNS44ICopXG4gICAgbGV0IGRheCA9IDBcblxuICAgIGxldCBjaGVjayA/bWFzazpfIF8gXyA9IGZhbHNlXG4gIGVuZFxuXG4gIG1vZHVsZSBNYXNrID0gc3RydWN0XG4gICAgaW5jbHVkZSBGTEFHU1xuXG4gICAgbGV0IHR5cGUnID0gMFxuICAgIGxldCBtb2RlID0gMFxuICAgIGxldCBubGluayA9IDBcbiAgICBsZXQgdWlkID0gMFxuICAgIGxldCBnaWQgPSAwXG4gICAgbGV0IGF0aW1lID0gMFxuICAgIGxldCBtdGltZSA9IDBcbiAgICBsZXQgY3RpbWUgPSAwXG4gICAgbGV0IGlubyA9IDBcbiAgICBsZXQgc2l6ZSA9IDBcbiAgICBsZXQgYmxvY2tzID0gMFxuICAgIGxldCBiYXNpY19zdGF0cyA9IDBcbiAgICBsZXQgYnRpbWUgPSAwXG5cbiAgICAoKiogQXMgb2YgTGludXggNS44ICopXG4gICAgbGV0IG1udF9pZCA9IDBcblxuICAgICgqKiBBcyBvZiBMaW51eCA2LjEgKilcbiAgICBsZXQgZGlvYWxpZ24gPSAwXG5cbiAgICBsZXQgY2hlY2sgXyBfID0gZmFsc2VcbiAgZW5kXG5cbiAgbGV0IGJsa3NpemUgXyA9IEludDY0Lnplcm9cbiAgbGV0IGF0dHJpYnV0ZXMgXyA9IEludDY0Lnplcm9cbiAgbGV0IG5saW5rIF8gPSBJbnQ2NC56ZXJvXG4gIGxldCB1aWQgXyA9IEludDY0Lnplcm9cbiAgbGV0IGdpZCBfID0gSW50NjQuemVyb1xuICBsZXQgaW5vIF8gPSBJbnQ2NC56ZXJvXG4gIGxldCBzaXplIF8gPSBJbnQ2NC56ZXJvXG4gIGxldCBibG9ja3MgXyA9IEludDY0Lnplcm9cbiAgbGV0IGF0dHJpYnV0ZXNfbWFzayBfID0gSW50NjQuemVyb1xuICBsZXQgcmRldiBfID0gSW50NjQuemVyb1xuICBsZXQgZGV2IF8gPSBJbnQ2NC56ZXJvXG4gIGxldCBtYXNrIF8gPSBJbnQ2NC56ZXJvXG5cbiAgKCoqIFNlZSB7ISBNYXNrLm1udF9pZH0uICopXG4gIGxldCBtbnRfaWQgXyA9IEludDY0Lnplcm9cblxuICAoKiogU2VlIHshIE1hc2suZGlvYWxpZ259LiAqKVxuICBsZXQgZGlvX21lbV9hbGlnbiBfID0gSW50NjQuemVyb1xuXG4gICgqKiBTZWUgeyEgTWFzay5kaW9hbGlnbn0uICopXG4gIGxldCBkaW9fb2Zmc2V0X2FsaWduIF8gPSBJbnQ2NC56ZXJvXG5cbiAgbGV0IGF0aW1lX3NlYyBfID0gSW50NjQuemVyb1xuICBsZXQgYnRpbWVfc2VjIF8gPSBJbnQ2NC56ZXJvXG4gIGxldCBjdGltZV9zZWMgXyA9IEludDY0Lnplcm9cbiAgbGV0IG10aW1lX3NlYyBfID0gSW50NjQuemVyb1xuICBsZXQgYXRpbWVfbnNlYyBfID0gMFxuICBsZXQgYnRpbWVfbnNlYyBfID0gMFxuICBsZXQgY3RpbWVfbnNlYyBfID0gMFxuICBsZXQgbXRpbWVfbnNlYyBfID0gMFxuICBsZXQgbW9kZSBfID0gMFxuICBsZXQgcGVybSBfID0gMFxuICBsZXQga2luZCBfID0gYFVua25vd25cbmVuZFxuXG5tb2R1bGUgU3lzY2FsbF9yZXN1bHQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gKGludCwgVW5peC5FcnJvci50KSBSZXN1bHQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbm1vZHVsZSBIYW5kbGUgPSBzdHJ1Y3RcbiAgdHlwZSB0XG5cbiAgbGV0IGludmFyaWFudCBfID0gKClcbmVuZFxuXG4oKiogRmxhZ3MgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIG9wZW5hdDIuICopXG5tb2R1bGUgT3Blbl9mbGFncyA9IHN0cnVjdFxuICBpbmNsdWRlIEZMQUdTXG5cbiAgbGV0IGVtcHR5ID0gMFxuICBsZXQgYXBwZW5kID0gMFxuICBsZXQgY2xvZXhlYyA9IDBcbiAgbGV0IGNyZWF0ID0gMFxuICBsZXQgZGlyZWN0ID0gMFxuICBsZXQgZGlyZWN0b3J5ID0gMFxuICBsZXQgZHN5bmMgPSAwXG4gIGxldCBleGNsID0gMFxuICBsZXQgbGFyZ2VmaWxlID0gMFxuICBsZXQgbm9hdGltZSA9IDBcbiAgbGV0IG5vY3R0eSA9IDBcbiAgbGV0IG5vZm9sbG93ID0gMFxuICBsZXQgbm9uYmxvY2sgPSAwXG4gIGxldCBwYXRoID0gMFxuICBsZXQgc3luYyA9IDBcbiAgbGV0IHRtcGZpbGUgPSAwXG4gIGxldCB0cnVuYyA9IDBcbmVuZFxuXG4oKiogRmxhZ3MgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIG9wZW5hdDIgdG8gY29udHJvbCBwYXRoIHJlc29sdXRpb24uICopXG5tb2R1bGUgUmVzb2x2ZSA9IHN0cnVjdFxuICBpbmNsdWRlIEZMQUdTXG5cbiAgbGV0IGVtcHR5ID0gMFxuICBsZXQgYmVuZWF0aCA9IDBcbiAgbGV0IGluX3Jvb3QgPSAwXG4gIGxldCBub19tYWdpY2xpbmtzID0gMFxuICBsZXQgbm9fc3ltbGlua3MgPSAwXG4gIGxldCBub194ZGV2ID0gMFxuICBsZXQgY2FjaGVkID0gMFxuZW5kXG5cbmxldCBjcmVhdGUgP3BvbGxpbmdfdGltZW91dDpfIH5xdWV1ZV9kZXB0aDpfICgpID1cbiAgT3JfZXJyb3IudW5pbXBsZW1lbnRlZCBcIklvX3VyaW5nX3Jhdy5jcmVhdGVcIlxuOztcblxubGV0IGV4aXQgXyA9IGFzc2VydCBmYWxzZVxubGV0IHN1cHBvcnRzX2V4dF9hcmcgXyA9IGFzc2VydCBmYWxzZVxubGV0IHN1Ym1pdCBfID0gYXNzZXJ0IGZhbHNlXG5sZXQgY3FlX3JlYWR5IF8gfnRpbWVvdXQ6XyA9IGFzc2VydCBmYWxzZVxubGV0IGZpbGxfY29tcGxldGlvbnMgXyA9IGFzc2VydCBmYWxzZVxubGV0IG5vb3AgXyA9IGFzc2VydCBmYWxzZVxubGV0IHJlYWQgXyA9IGFzc2VydCBmYWxzZVxubGV0IHdyaXRlIF8gPSBhc3NlcnQgZmFsc2VcbmxldCByZWFkdiBfID0gYXNzZXJ0IGZhbHNlXG5sZXQgd3JpdGV2IF8gPSBhc3NlcnQgZmFsc2VcbmxldCBwb2xsX2FkZCBfID0gYXNzZXJ0IGZhbHNlXG5sZXQgb3BlbmF0MiBfID0gYXNzZXJ0IGZhbHNlXG5sZXQgY2xvc2UgXyA9IGFzc2VydCBmYWxzZVxubGV0IHVubGluayBfID0gYXNzZXJ0IGZhbHNlXG5sZXQgbGluayBfID0gYXNzZXJ0IGZhbHNlXG5sZXQgdGltZW91dCBfID0gYXNzZXJ0IGZhbHNlXG5sZXQgc3RhdHggXyA9IGFzc2VydCBmYWxzZVxubGV0IGNhbmNlbCBfID0gYXNzZXJ0IGZhbHNlXG5sZXQgc3lzY2FsbF9yZXN1bHQgXyA9IGFzc2VydCBmYWxzZVxubGV0IHJlZ2lzdGVyX2V2ZW50ZmQgXyA9IGFzc2VydCBmYWxzZVxuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxub3BlbiBGaWxlX2Rlc2NyX3dhdGNoZXJfaW50Zlxub3BlbiBSZWFkX3dyaXRlX3BhaXIuRXhwb3J0XG5tb2R1bGUgVGFibGUgPSBCb3VuZGVkX2ludF90YWJsZVxuXG5tb2R1bGUgRmxhZ3MgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJb191cmluZ19yYXcuUG9sbF9tYXNrXG5cbiAgbGV0IG9mX3J3ID0gZnVuY3Rpb25cbiAgICB8IGBSZWFkIC0+IHBvbGxpblxuICAgIHwgYFdyaXRlIC0+IHBvbGxvdXRcbiAgOztcbmVuZFxuXG5tb2R1bGUgRmRfc3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHJ1bm5pbmdfam9iIDogSW9fdXJpbmdfcmF3LkhhbmRsZS50XG4gICAgOyBmbGFncyA6IElvX3VyaW5nX3Jhdy5Qb2xsX21hc2sudFxuICAgIH1cbmVuZFxuXG50eXBlIHQgPVxuICB7IHVyaW5nIDogKElvX3VyaW5nX3Jhdy50W0BzZXhwLm9wYXF1ZV0pXG4gIDsgc3RhdGVzIDogKChGaWxlX2Rlc2NyLnQsIEZkX3N0YXRlLnQpIFRhYmxlLnRbQHNleHAub3BhcXVlXSlcbiAgOyBoYW5kbGVfZmRfcmVhZF9yZWFkeSA6IEZpbGVfZGVzY3IudCAtPiBGbGFncy50IC0+IHVuaXRcbiAgOyBoYW5kbGVfZmRfd3JpdGVfcmVhZHkgOiBGaWxlX2Rlc2NyLnQgLT4gRmxhZ3MudCAtPiB1bml0XG4gIH1cbltAQGRlcml2aW5nIHNleHBfb2YsIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXJdXG5cbmxldCBiYWNrZW5kID0gQ29uZmlnLkZpbGVfZGVzY3Jfd2F0Y2hlci5Jb191cmluZ1xuXG5sZXQgaW52YXJpYW50IHQgOiB1bml0ID1cbiAgdHJ5XG4gICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfnVyaW5nOmlnbm9yZVxuICAgICAgfnN0YXRlczpcbiAgICAgICAgKGNoZWNrIChmdW4gc3RhdGVzIC0+XG4gICAgICAgICAgIFRhYmxlLml0ZXIgc3RhdGVzIH5mOihmdW4geyBGZF9zdGF0ZS5ydW5uaW5nX2pvYiA9IF87IGZsYWdzIH0gLT5cbiAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgTGlzdC5leGlzdHNcbiAgICAgICAgICAgICAgICAgRmxhZ3MuWyBwb2xsaW47IHBvbGxvdXQ7IHBvbGxpbiArIHBvbGxvdXQgXVxuICAgICAgICAgICAgICAgICB+ZjooZnVuIGZsYWdzJyAtPiBGbGFncy4obWVtIGZsYWdzJyBmbGFncyAmJiBtZW0gZmxhZ3MgZmxhZ3MnKSkpKSkpXG4gICAgICB+aGFuZGxlX2ZkX3JlYWRfcmVhZHk6aWdub3JlXG4gICAgICB+aGFuZGxlX2ZkX3dyaXRlX3JlYWR5Omlnbm9yZVxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiSW9fdXJpbmdfZmlsZV9kZXNjcl93YXRjaGVyLmludmFyaWFudCBmYWlsZWRcIlxuICAgICAgICAgIChleG4gOiBleG4pXG4gICAgICAgICAgfmlvX3VyaW5nX2ZpbGVfZGVzY3Jfd2F0Y2hlcjoodCA6IHQpXVxuOztcblxudHlwZSAnYSBhZGRpdGlvbmFsX2NyZWF0ZV9hcmdzID0gdXJpbmc6SW9fdXJpbmdfcmF3LnQgLT4gJ2FcblxubGV0IGNyZWF0ZSB+dXJpbmcgfm51bV9maWxlX2Rlc2NycyB+aGFuZGxlX2ZkX3JlYWRfcmVhZHkgfmhhbmRsZV9mZF93cml0ZV9yZWFkeSA9XG4gIGlmIG5vdCAoSW9fdXJpbmdfcmF3LnN1cHBvcnRzX2V4dF9hcmcgdXJpbmcpXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJXNleHBcbiAgICAgICAgXCJDYW5ub3QgY3JlYXRlIGFuIE9jYW1sX3VyaW5nIGZpbGUgZGVzY3JpcHRvciB3YXRjaGVyIGlmIElPUklOR19GRUFUX0VYVF9BUkcgaXMgXFxcbiAgICAgICAgIG5vdCBzdXBwb3J0ZWQgYmVjYXVzZSB0aGVuIGl0IGlzIG5vdCB0aHJlYWQgc2FmZS5cIl07XG4gIGxldCBzdGF0ZXMgPVxuICAgIFRhYmxlLmNyZWF0ZVxuICAgICAgfm51bV9rZXlzOm51bV9maWxlX2Rlc2Nyc1xuICAgICAgfmtleV90b19pbnQ6RmlsZV9kZXNjci50b19pbnRcbiAgICAgIH5zZXhwX29mX2tleTpGaWxlX2Rlc2NyLnNleHBfb2ZfdFxuICAgICAgKClcbiAgaW5cbiAgbGV0IGhhbmRsZV9mZCByZWFkX29yX3dyaXRlIGhhbmRsZV9mZCA9XG4gICAgbGV0IGJpdCA9IEZsYWdzLm9mX3J3IHJlYWRfb3Jfd3JpdGUgaW5cbiAgICBmdW4gZmlsZV9kZXNjciBmbGFncyAtPlxuICAgICAgKCogW2lvX3VyaW5nXSwgc2ltaWxhciB0byBbZXBvbGxdLCBoYXMgYW4gaW1wbGljaXQgZXZlbnRcbiAgICAgICAgIGZsYWdzIGZvciBoYW5ndXAgKEhVUCkgYW5kIGVycm9yIChFUlIpLCB3aGVyZWFzIHNlbGVjdCB3aWxsIGp1c3QgcmV0dXJuIHRoYXQgZmRcbiAgICAgICAgIGFzIFwicmVhZHlcIiBpbiBpdHMgYXBwcm9wcmlhdGUgZmRfc2V0LiAgU2luY2Ugd2UgZG9uJ3Qga25vdyBpZiBpdCdzIHJlYWR5IGZvciBJTlxuICAgICAgICAgb3IgT1VULCB3ZSBoYXZlIHRvIGdvIGxvb2t1cCB0aGUgZW50cnkgaWYgdGhlIEhVUCBvciBFUlIgZmxhZyBpcyBzZXQuICopXG4gICAgICBpZiBGbGFncy5tZW0gYml0IGZsYWdzXG4gICAgICAgICB8fCAoKEZsYWdzLm1lbSBGbGFncy5wb2xsZXJyIGZsYWdzIHx8IEZsYWdzLm1lbSBGbGFncy5wb2xsaHVwIGZsYWdzKVxuICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgbWF0Y2ggVGFibGUuZmluZCBzdGF0ZXMgZmlsZV9kZXNjciB3aXRoXG4gICAgICAgICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICAgICAgICAgfCBTb21lIHsgRmRfc3RhdGUucnVubmluZ19qb2IgPSBfOyBmbGFncyB9IC0+IEZsYWdzLm1lbSBiaXQgZmxhZ3MpXG4gICAgICB0aGVuIGhhbmRsZV9mZCBmaWxlX2Rlc2NyXG4gIGluXG4gIHsgdXJpbmdcbiAgOyBzdGF0ZXNcbiAgOyBoYW5kbGVfZmRfcmVhZF9yZWFkeSA9IGhhbmRsZV9mZCBgUmVhZCBoYW5kbGVfZmRfcmVhZF9yZWFkeVxuICA7IGhhbmRsZV9mZF93cml0ZV9yZWFkeSA9IGhhbmRsZV9mZCBgV3JpdGUgaGFuZGxlX2ZkX3dyaXRlX3JlYWR5XG4gIH1cbjs7XG5cbmxldCByZXNldF9pbl9mb3JrZWRfcHJvY2VzcyBfID0gKClcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIFRhYmxlLml0ZXJpIHQuc3RhdGVzIH5mOihmdW4gfmtleTpmaWxlX2Rlc2NyIH5kYXRhOnsgcnVubmluZ19qb2IgPSBfOyBmbGFncyB9IC0+XG4gICAgaWYgRmxhZ3MubWVtIEZsYWdzLnBvbGxpbiBmbGFncyB0aGVuIGYgZmlsZV9kZXNjciBgUmVhZDtcbiAgICBpZiBGbGFncy5tZW0gRmxhZ3MucG9sbG91dCBmbGFncyB0aGVuIGYgZmlsZV9kZXNjciBgV3JpdGUpXG47O1xuXG5sZXQgcmVjIGFkZF9wb2xsIHQgZmlsZV9kZXNjciBmbGFncyA9XG4gIGxldCBoYW5kbGUgPSBJb191cmluZ19yYXcucG9sbF9hZGQgdC51cmluZyBmaWxlX2Rlc2NyIGZsYWdzIGluXG4gIFRhYmxlLnNldCB0LnN0YXRlcyB+a2V5OmZpbGVfZGVzY3IgfmRhdGE6eyBydW5uaW5nX2pvYiA9IGhhbmRsZTsgZmxhZ3MgfTtcbiAgRGVmZXJyZWQuZG9uJ3Rfd2FpdF9mb3JcbiAgICAobGV0JWJpbmQgcmVzID0gSW9fdXJpbmdfcmF3LnN5c2NhbGxfcmVzdWx0IGhhbmRsZSBpblxuICAgICBtYXRjaCBUYWJsZS5maW5kIHQuc3RhdGVzIGZpbGVfZGVzY3Igd2l0aFxuICAgICB8IE5vbmUgLT4gcmV0dXJuICgpXG4gICAgIHwgU29tZSB7IHJ1bm5pbmdfam9iOyBmbGFncyB9IC0+XG4gICAgICAgaWYgcGh5c19lcXVhbCBydW5uaW5nX2pvYiBoYW5kbGVcbiAgICAgICB0aGVuIChcbiAgICAgICAgIG1hdGNoIHJlcyB3aXRoXG4gICAgICAgICAoKiBUaGlzIGlzIEVDQU5DRUxFRCAqKVxuICAgICAgICAgfCBFcnJvciAoVW5peC5FVU5LTk9XTkVSUiAxMjUpIC0+ICgpXG4gICAgICAgICB8IEVycm9yIGVyciAtPiBmYWlsd2l0aCAoVW5peC5FcnJvci5tZXNzYWdlIGVycilcbiAgICAgICAgIHwgT2sgcmVzIC0+XG4gICAgICAgICAgIGhhbmRsZV9mZF9yZWFkX3JlYWR5IHQgZmlsZV9kZXNjciAoRmxhZ3Mub2ZfaW50IHJlcyk7XG4gICAgICAgICAgIGhhbmRsZV9mZF93cml0ZV9yZWFkeSB0IGZpbGVfZGVzY3IgKEZsYWdzLm9mX2ludCByZXMpO1xuICAgICAgICAgICBhZGRfcG9sbCB0IGZpbGVfZGVzY3IgZmxhZ3MpO1xuICAgICAgIHJldHVybiAoKSlcbjs7XG5cbmxldCByZW1vdmVfcG9sbF9leG4gdCBmaWxlX2Rlc2NyID1cbiAgbWF0Y2ggVGFibGUuZmluZCB0LnN0YXRlcyBmaWxlX2Rlc2NyIHdpdGhcbiAgfCBTb21lIHsgcnVubmluZ19qb2I7IF8gfSAtPlxuICAgIFRhYmxlLnJlbW92ZSB0LnN0YXRlcyBmaWxlX2Rlc2NyO1xuICAgIERlZmVycmVkLmRvbid0X3dhaXRfZm9yIChJb191cmluZ19yYXcuY2FuY2VsIHQudXJpbmcgcnVubmluZ19qb2IpXG4gIHwgTm9uZSAtPlxuICAgIHJhaXNlX3NcbiAgICAgIFslc2V4cFxuICAgICAgICBcIkF0dGVtcHRlZCB0byByZW1vdmUgcG9sbGluZyBmb3IgYSBmaWxlIGRlc2NyaXB0b3IgdGhhdCB3YXMgbm90IGJlaW5nIHBvbGxlZFwiXVxuOztcblxubGV0IHNldCB0IGZpbGVfZGVzY3IgZGVzaXJlZCA9XG4gIGxldCBhY3R1YWxfZmxhZ3MgPVxuICAgIG1hdGNoIFRhYmxlLmZpbmQgdC5zdGF0ZXMgZmlsZV9kZXNjciB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeyBydW5uaW5nX2pvYiA9IF87IGZsYWdzIH0gLT4gU29tZSBmbGFnc1xuICBpblxuICBsZXQgZGVzaXJlZF9mbGFncyA9XG4gICAgbWF0Y2ggZGVzaXJlZC5yZWFkLCBkZXNpcmVkLndyaXRlIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBOb25lXG4gICAgfCB0cnVlLCBmYWxzZSAtPiBTb21lIEZsYWdzLnBvbGxpblxuICAgIHwgZmFsc2UsIHRydWUgLT4gU29tZSBGbGFncy5wb2xsb3V0XG4gICAgfCB0cnVlLCB0cnVlIC0+IFNvbWUgRmxhZ3MuKHBvbGxpbiArIHBvbGxvdXQpXG4gIGluXG4gIG1hdGNoIGFjdHVhbF9mbGFncywgZGVzaXJlZF9mbGFncyB3aXRoXG4gIHwgTm9uZSwgTm9uZSAtPiBgT2tcbiAgfCBOb25lLCBTb21lIGQgLT5cbiAgICBhZGRfcG9sbCB0IGZpbGVfZGVzY3IgZDtcbiAgICBgT2tcbiAgfCBTb21lIF8sIE5vbmUgLT5cbiAgICByZW1vdmVfcG9sbF9leG4gdCBmaWxlX2Rlc2NyO1xuICAgIGBPa1xuICB8IFNvbWUgYSwgU29tZSBkIC0+XG4gICAgaWYgbm90IChGbGFncy5tZW0gYSBkICYmIEZsYWdzLm1lbSBkIGEpXG4gICAgdGhlbiAoXG4gICAgICByZW1vdmVfcG9sbF9leG4gdCBmaWxlX2Rlc2NyO1xuICAgICAgYWRkX3BvbGwgdCBmaWxlX2Rlc2NyIGQpO1xuICAgIGBPa1xuOztcblxubW9kdWxlIFByZSA9IHN0cnVjdFxuICB0eXBlIHQgPSB1bml0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubGV0IHByZV9jaGVjayB0ID1cbiAgKCogVGhpcyBoYXMgdGhlIGVmZWN0IG9mIHN1Ym1pdHRpbmcgYXQgdGhlIGVuZCBvZiBldmVyeSBjeWNsZS4gKilcbiAgbGV0IChfIDogaW50KSA9IElvX3VyaW5nX3Jhdy5zdWJtaXQgdC51cmluZyBpblxuICAoKVxuOztcblxubW9kdWxlIENoZWNrX3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPSBib29sIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxuKCogRmlsbGluZyBjb21wbGV0aW9ucyBpcyBjaGVhcCB3aGVuIG5vdGhpbmcgaXMgcmVhZHksIHNvIGluIGNhc2Ugd2Ugd2FudCB0byB0aW1lb3V0XG4gICBpbW1lZGlhdGVseSwgaXQncyBvayB0byBqdXN0IHRyeSBhbmQgZmlsbCBjb21wbGV0aW9ucyB3aXRob3V0IGNoZWNraW5nIHRoZSBjb21wbGV0aW9uXG4gICBxdWV1ZSBhcyB3ZWxsLiAqKVxubGV0IHRocmVhZF9zYWZlX2NoZWNrICh0eXBlIGEpIHQgKCkgKHRpbWVvdXQgOiBhIFRpbWVvdXQudCkgKHNwYW5fb3JfdW5pdCA6IGEpID1cbiAgbWF0Y2ggdGltZW91dCB3aXRoXG4gIHwgSW1tZWRpYXRlbHkgLT4gdHJ1ZVxuICB8IEFmdGVyIC0+IElvX3VyaW5nX3Jhdy5jcWVfcmVhZHkgdC51cmluZyB+dGltZW91dDooVGltZV9ucy5TcGFuLnRvX3NlYyBzcGFuX29yX3VuaXQpXG47O1xuXG5sZXQgcG9zdF9jaGVjayB0IHJlYWR5ID1cbiAgaWYgcmVhZHlcbiAgdGhlbiAoXG4gICAgbGV0IChfIDogaW50KSA9IElvX3VyaW5nX3Jhdy5maWxsX2NvbXBsZXRpb25zIHQudXJpbmcgaW5cbiAgICAoKSlcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIEZpbGVfZGVzY3Jfd2F0Y2hlcl9pbnRmXG5vcGVuIFJlYWRfd3JpdGVfcGFpci5FeHBvcnRcbm1vZHVsZSBUYWJsZSA9IEJvdW5kZWRfaW50X3RhYmxlXG5cbnR5cGUgdCA9XG4gIHsgZGVzY3JfdGFibGVzIDogKEZpbGVfZGVzY3IudCwgdW5pdCkgVGFibGUudCBSZWFkX3dyaXRlX3BhaXIudFxuICA7IGhhbmRsZV9mZF9yZWFkX3JlYWR5IDogRmlsZV9kZXNjci50IC0+IHVuaXRcbiAgOyBoYW5kbGVfZmRfcmVhZF9iYWQgOiBGaWxlX2Rlc2NyLnQgLT4gdW5pdFxuICA7IGhhbmRsZV9mZF93cml0ZV9yZWFkeSA6IEZpbGVfZGVzY3IudCAtPiB1bml0XG4gIDsgaGFuZGxlX2ZkX3dyaXRlX2JhZCA6IEZpbGVfZGVzY3IudCAtPiB1bml0XG4gIH1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBiYWNrZW5kID0gQ29uZmlnLkZpbGVfZGVzY3Jfd2F0Y2hlci5TZWxlY3RcblxubGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gIHRyeSBSZWFkX3dyaXRlX3BhaXIuaXRlciB0LmRlc2NyX3RhYmxlcyB+ZjooVGFibGUuaW52YXJpYW50IGlnbm9yZSBpZ25vcmUpIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJTZWxlY3RfZmlsZV9kZXNjcl93YXRjaGVyLmludmFyaWFudCBmYWlsZWRcIlxuICAgICAgICAgIChleG4gOiBleG4pXG4gICAgICAgICAgfnNlbGVjdF9maWxlX2Rlc2NyX3dhdGNoZXI6KHQgOiB0KV1cbjs7XG5cbnR5cGUgJ2EgYWRkaXRpb25hbF9jcmVhdGVfYXJncyA9XG4gIGhhbmRsZV9mZF9yZWFkX2JhZDooRmlsZV9kZXNjci50IC0+IHVuaXQpXG4gIC0+IGhhbmRsZV9mZF93cml0ZV9iYWQ6KEZpbGVfZGVzY3IudCAtPiB1bml0KVxuICAtPiAnYVxuXG5sZXQgY3JlYXRlXG4gIH5oYW5kbGVfZmRfcmVhZF9iYWRcbiAgfmhhbmRsZV9mZF93cml0ZV9iYWRcbiAgfm51bV9maWxlX2Rlc2Nyc1xuICB+aGFuZGxlX2ZkX3JlYWRfcmVhZHlcbiAgfmhhbmRsZV9mZF93cml0ZV9yZWFkeVxuICA9XG4gIHsgZGVzY3JfdGFibGVzID1cbiAgICAgIFJlYWRfd3JpdGVfcGFpci5jcmVhdGVfZm4gKGZ1biAoKSAtPlxuICAgICAgICBUYWJsZS5jcmVhdGVcbiAgICAgICAgICB+bnVtX2tleXM6bnVtX2ZpbGVfZGVzY3JzXG4gICAgICAgICAgfmtleV90b19pbnQ6RmlsZV9kZXNjci50b19pbnRcbiAgICAgICAgICB+c2V4cF9vZl9rZXk6RmlsZV9kZXNjci5zZXhwX29mX3RcbiAgICAgICAgICAoKSlcbiAgOyBoYW5kbGVfZmRfcmVhZF9yZWFkeVxuICA7IGhhbmRsZV9mZF9yZWFkX2JhZFxuICA7IGhhbmRsZV9mZF93cml0ZV9yZWFkeVxuICA7IGhhbmRsZV9mZF93cml0ZV9iYWRcbiAgfVxuOztcblxubGV0IHJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzIF8gPSAoKVxuXG5sZXQgaXRlciB0IH5mID1cbiAgUmVhZF93cml0ZV9wYWlyLml0ZXJpIHQuZGVzY3JfdGFibGVzIH5mOihmdW4gcmVhZF9vcl93cml0ZSB0YWJsZSAtPlxuICAgIFRhYmxlLml0ZXJpIHRhYmxlIH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5IHJlYWRfb3Jfd3JpdGUpKVxuOztcblxubW9kdWxlIFByZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBGaWxlX2Rlc2NyLnQgbGlzdCBSZWFkX3dyaXRlX3BhaXIudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbmxldCBzZXQgdCBmaWxlX2Rlc2NyIGRlc2lyZWQgPVxuICBSZWFkX3dyaXRlX3BhaXIuaXRlcmkgdC5kZXNjcl90YWJsZXMgfmY6KGZ1biByZWFkX29yX3dyaXRlIHRhYmxlIC0+XG4gICAgaWYgUmVhZF93cml0ZV9wYWlyLmdldCBkZXNpcmVkIHJlYWRfb3Jfd3JpdGVcbiAgICB0aGVuIFRhYmxlLnNldCB0YWJsZSB+a2V5OmZpbGVfZGVzY3IgfmRhdGE6KClcbiAgICBlbHNlIFRhYmxlLnJlbW92ZSB0YWJsZSBmaWxlX2Rlc2NyKTtcbiAgYE9rXG47O1xuXG5sZXQgcHJlX2NoZWNrIHQgPSBSZWFkX3dyaXRlX3BhaXIubWFwIHQuZGVzY3JfdGFibGVzIH5mOlRhYmxlLmtleXNcblxubW9kdWxlIENoZWNrX3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgcHJlIDogUHJlLnRcbiAgICA7IHNlbGVjdF9yZXN1bHQgOiAoVW5peC5TZWxlY3RfZmRzLnQsIGV4bikgUmVzdWx0LnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubGV0IHRocmVhZF9zYWZlX2NoZWNrICh0eXBlIGEpIChfIDogdCkgKHByZSA6IFByZS50KSAodGltZW91dCA6IGEgVGltZW91dC50KSAoc3BhbiA6IGEpID1cbiAgbGV0IHRpbWVvdXQgPVxuICAgIG1hdGNoIHRpbWVvdXQgd2l0aFxuICAgIHwgSW1tZWRpYXRlbHkgLT4gYEltbWVkaWF0ZWx5XG4gICAgKCogV2FpdCBubyBsb25nZXIgdGhhbiBvbmUgc2Vjb25kLCB3aGljaCBhdm9pZHMgYW55IHdlaXJkbmVzcyBkdWUgdG8gZmVlZGluZyBsYXJnZVxuICAgICAgIHRpbWVvdXRzIHRvIHNlbGVjdC4gKilcbiAgICB8IEFmdGVyIC0+IGBBZnRlciAoVGltZV9ucy5TcGFuLm1pbiBzcGFuIFRpbWVfbnMuU3Bhbi5zZWNvbmQpXG4gIGluXG4gIHsgQ2hlY2tfcmVzdWx0LnByZVxuICA7IHNlbGVjdF9yZXN1bHQgPVxuICAgICAgUmVzdWx0LnRyeV93aXRoIChmdW4gKCkgLT5cbiAgICAgICAgVW5peC5zZWxlY3QgfnJlYWQ6cHJlLnJlYWQgfndyaXRlOnByZS53cml0ZSB+ZXhjZXB0OltdIH50aW1lb3V0ICgpKVxuICB9XG47O1xuXG5sZXQgcG9zdF9jaGVjayB0ICh7IENoZWNrX3Jlc3VsdC5wcmU7IHNlbGVjdF9yZXN1bHQgfSBhcyBjaGVja19yZXN1bHQpID1cbiAgdHJ5XG4gICAgbWF0Y2ggc2VsZWN0X3Jlc3VsdCB3aXRoXG4gICAgKCogV2UgdGhpbmsgNTE0IHNob3VsZCBiZSB0cmVhdGVkIGxpa2UgRUlOVFIuICopXG4gICAgfCBFcnJvciAoVW5peC5Vbml4X2Vycm9yICgoRUlOVFIgfCBFVU5LTk9XTkVSUiA1MTQpLCBfLCBfKSkgLT4gKClcbiAgICB8IE9rIHsgcmVhZDsgd3JpdGU7IGV4Y2VwdCB9IC0+XG4gICAgICBhc3NlcnQgKExpc3QuaXNfZW1wdHkgZXhjZXB0KTtcbiAgICAgIExpc3QuaXRlciB3cml0ZSB+Zjp0LmhhbmRsZV9mZF93cml0ZV9yZWFkeTtcbiAgICAgIExpc3QuaXRlciByZWFkIH5mOnQuaGFuZGxlX2ZkX3JlYWRfcmVhZHlcbiAgICB8IEVycm9yIChVbml4LlVuaXhfZXJyb3IgKEVCQURGLCBfLCBfKSkgLT5cbiAgICAgIGxldCBiYWQgcmVhZF9vcl93cml0ZSA9XG4gICAgICAgIGxldCBmZHMgPVxuICAgICAgICAgIG1hdGNoIHJlYWRfb3Jfd3JpdGUgd2l0aFxuICAgICAgICAgIHwgYFJlYWQgLT4gcHJlLnJlYWRcbiAgICAgICAgICB8IGBXcml0ZSAtPiBwcmUud3JpdGVcbiAgICAgICAgaW5cbiAgICAgICAgTGlzdC5mb2xkIGZkcyB+aW5pdDpbXSB+ZjooZnVuIGFjIGZpbGVfZGVzY3IgLT5cbiAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgU3lzY2FsbC5zeXNjYWxsIChmdW4gKCkgLT4gaWdub3JlIChVbml4LmZzdGF0IGZpbGVfZGVzY3IgOiBVbml4LnN0YXRzKSlcbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBPayAoKSAtPiBhY1xuICAgICAgICAgIHwgRXJyb3IgKFVuaXguVW5peF9lcnJvciAoRUJBREYsIF8sIF8pKSAtPiBmaWxlX2Rlc2NyIDo6IGFjXG4gICAgICAgICAgfCBFcnJvciBleG4gLT5cbiAgICAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgICAgXCJmc3RhdCByYWlzZWQgdW5leHBlY3RlZCBleG5cIiAoZmlsZV9kZXNjciA6IEZpbGVfZGVzY3IudCkgKGV4biA6IGV4bildKVxuICAgICAgaW5cbiAgICAgIExpc3QuaXRlciAoYmFkIGBXcml0ZSkgfmY6dC5oYW5kbGVfZmRfd3JpdGVfYmFkO1xuICAgICAgTGlzdC5pdGVyIChiYWQgYFJlYWQpIH5mOnQuaGFuZGxlX2ZkX3JlYWRfYmFkXG4gICAgfCBFcnJvciBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJzZWxlY3QgcmFpc2VkIHVuZXhwZWN0ZWQgZXhuXCIgfl86KGV4biA6IGV4bildXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJGaWxlX2Rlc2NyX3dhdGNoZXIucG9zdF9jaGVjayBidWdcIlxuICAgICAgICAgIChleG4gOiBleG4pXG4gICAgICAgICAgKGNoZWNrX3Jlc3VsdCA6IENoZWNrX3Jlc3VsdC50KVxuICAgICAgICAgIH5zZWxlY3RfZmlsZV9kZXNjcl93YXRjaGVyOih0IDogdCldXG47O1xuIiwib3BlbiBDb3JlXG5tb2R1bGUgU2lnbmFsID0gQ29yZS5TaWduYWxcblxudHlwZSBkZWxpdmVyZWQgPSBTaWduYWwudCBUaHJlYWRfc2FmZV9xdWV1ZS50XG5cbnR5cGUgdCA9XG4gIHsgb3JpZ2luYWxfZGlzcG9zaXRpb25zX29mX21hbmFnZWRfc2lnbmFscyA6IFNpZ25hbC5FeHBlcnQuYmVoYXZpb3IgU2lnbmFsLlRhYmxlLnRcbiAgOyBkZWxpdmVyZWQgOiAoZGVsaXZlcmVkW0BzZXhwLm9wYXF1ZV0pXG4gIDsgdGhyZWFkX3NhZmVfbm90aWZ5X3NpZ25hbF9kZWxpdmVyZWQgOiB1bml0IC0+IHVuaXRcbiAgfVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBfID0gKClcblxubGV0IGNyZWF0ZSB+dGhyZWFkX3NhZmVfbm90aWZ5X3NpZ25hbF9kZWxpdmVyZWQgPVxuICB7IG9yaWdpbmFsX2Rpc3Bvc2l0aW9uc19vZl9tYW5hZ2VkX3NpZ25hbHMgPSBTaWduYWwuVGFibGUuY3JlYXRlICgpXG4gIDsgZGVsaXZlcmVkID0gVGhyZWFkX3NhZmVfcXVldWUuY3JlYXRlICgpXG4gIDsgdGhyZWFkX3NhZmVfbm90aWZ5X3NpZ25hbF9kZWxpdmVyZWRcbiAgfVxuOztcblxubGV0IGlzX21hbmFnaW5nIHQgc2lnbmFsID0gSGFzaHRibC5tZW0gdC5vcmlnaW5hbF9kaXNwb3NpdGlvbnNfb2ZfbWFuYWdlZF9zaWduYWxzIHNpZ25hbFxuXG5sZXQgbWFuYWdlIHQgc2lnbmFsID1cbiAgbGV0IF9vcmlnaW5hbF9kaXNwb3NpdGlvbiA9XG4gICAgSGFzaHRibC5maW5kX29yX2FkZFxuICAgICAgdC5vcmlnaW5hbF9kaXNwb3NpdGlvbnNfb2ZfbWFuYWdlZF9zaWduYWxzXG4gICAgICBzaWduYWxcbiAgICAgIH5kZWZhdWx0OihmdW4gKCkgLT5cbiAgICAgIFNpZ25hbC5FeHBlcnQuc2lnbmFsXG4gICAgICAgIHNpZ25hbFxuICAgICAgICAoYEhhbmRsZVxuICAgICAgICAgIChmdW4gXyAtPlxuICAgICAgICAgICAgKCogRXZlcnl0aGluZyBpbiB0aGlzIGZ1bmN0aW9uIGJvZHkgbXVzdCBiZSB0aHJlYWQgc2FmZSwgc2luY2UgaXQgaXMgcnVubmluZyBpbiBhblxuICAgICAgICAgICAgICAgICAgIE9DYW1sIHNpZ25hbCBoYW5kbGVyLiAqKVxuICAgICAgICAgICAgVGhyZWFkX3NhZmVfcXVldWUuZW5xdWV1ZSB0LmRlbGl2ZXJlZCBzaWduYWw7XG4gICAgICAgICAgICB0LnRocmVhZF9zYWZlX25vdGlmeV9zaWduYWxfZGVsaXZlcmVkICgpKSkpXG4gIGluXG4gICgpXG47O1xuXG5sZXQgaXRlcl9kZWxpdmVyZWQgdCB+ZiA9XG4gIHdoaWxlIFRocmVhZF9zYWZlX3F1ZXVlLmxlbmd0aCB0LmRlbGl2ZXJlZCA+IDAgZG9cbiAgICBsZXQgc2lnbmFsID0gVGhyZWFkX3NhZmVfcXVldWUuZGVxdWV1ZV9leG4gdC5kZWxpdmVyZWQgaW5cbiAgICBsZXQgb3JpZ2luYWxfZGlzcG9zaXRpb24gPVxuICAgICAgSGFzaHRibC5maW5kX2V4biB0Lm9yaWdpbmFsX2Rpc3Bvc2l0aW9uc19vZl9tYW5hZ2VkX3NpZ25hbHMgc2lnbmFsXG4gICAgaW5cbiAgICBmIH5vcmlnaW5hbF9kaXNwb3NpdGlvbiBzaWduYWxcbiAgZG9uZVxuOztcbiIsIigqIFVuaXQgdGVzdHMgYXJlIGluIC4uLy4uL2xpYl90ZXN0L3NodXRkb3duX3Rlc3RzLm1sICopXG5cbm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm1vZHVsZSBTaWduYWwgPSBDb3JlLlNpZ25hbFxuXG5tb2R1bGUgU3RhdHVzX2NvbXBhdGliaWxpdHkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEluY29tcGF0aWJsZVxuICAgIHwgQ29tcGF0aWJsZV9hbmRfcmVwbGFjZVxuICAgIHwgQ29tcGF0aWJsZV9hbmRfZG9fbm90X3JlcGxhY2VcbmVuZFxuXG5tb2R1bGUgU3RhdHVzID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBFeGl0IG9mIGludFxuICAgIHwgU2lnbmFsIG9mIFNpZ25hbC50XG4gIFtAQGRlcml2aW5nIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXRpYmlsaXR5IHQgfnByaW9yIDogU3RhdHVzX2NvbXBhdGliaWxpdHkudCA9XG4gICAgaWYgZXF1YWwgdCBwcmlvclxuICAgIHRoZW4gQ29tcGF0aWJsZV9hbmRfZG9fbm90X3JlcGxhY2VcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIHByaW9yLCB0IHdpdGhcbiAgICAgIHwgXywgRXhpdCAwIC0+IENvbXBhdGlibGVfYW5kX2RvX25vdF9yZXBsYWNlXG4gICAgICB8IEV4aXQgMCwgXyAtPiBDb21wYXRpYmxlX2FuZF9yZXBsYWNlXG4gICAgICB8IF8sIF8gLT4gSW5jb21wYXRpYmxlKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYXliZV9zdGF0dXMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IE5vXG4gICAgfCBZZXMgb2YgU3RhdHVzLnRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5sZXQgZGVidWcgPSBEZWJ1Zy5zaHV0ZG93blxubGV0IHRvZG8gPSByZWYgW11cblxubGV0IGF0X3NodXRkb3duIGYgPVxuICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLmdldCAoKSBpblxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcImF0X3NodXRkb3duXCIgYmFja3RyYWNlIFslc2V4cF9vZjogQmFja3RyYWNlLnRdO1xuICB0b2RvIDo9IChiYWNrdHJhY2UsIGYpIDo6ICF0b2RvXG47O1xuXG5sZXQgc2h1dHRpbmdfZG93bl9yZWYgPSByZWYgTWF5YmVfc3RhdHVzLk5vXG5sZXQgZGVmYXVsdF9mb3JjZV9yZWYgPSByZWYgKGZ1biAoKSAtPiBDbG9jay5hZnRlciAoc2VjIDEwLikpXG5sZXQgZGVmYXVsdF9mb3JjZSAoKSA9ICFkZWZhdWx0X2ZvcmNlX3JlZlxubGV0IHNldF9kZWZhdWx0X2ZvcmNlIGZvcmNlID0gZGVmYXVsdF9mb3JjZV9yZWYgOj0gZm9yY2VcbmxldCBzaHV0dGluZ19kb3duICgpID0gIXNodXR0aW5nX2Rvd25fcmVmXG5cbmxldCBpc19zaHV0dGluZ19kb3duICgpID1cbiAgbWF0Y2ggc2h1dHRpbmdfZG93biAoKSB3aXRoXG4gIHwgTm8gLT4gZmFsc2VcbiAgfCBZZXMgXyAtPiB0cnVlXG47O1xuXG4oKiBCZSBjYXJlZnVsIHRvIGVuc3VyZSBbc2h1dGRvd25dIGRvZXNuJ3QgcmFpc2UganVzdCBiZWNhdXNlXG4gICBzdGRlcnIgaXMgY2xvc2VkICopXG5sZXQgaWdub3JlX2V4biBmID1cbiAgdHJ5IGYgKCkgd2l0aFxuICB8IF8gLT4gKClcbjs7XG5cbmxldCBleGl0X3JlbGlhYmx5IHN0YXR1cyA9XG4gIG1hdGNoIChzdGF0dXMgOiBTdGF0dXMudCkgd2l0aFxuICB8IEV4aXQgY29kZSAtPlxuICAgIChtYXRjaCAoZXhpdCBjb2RlIDogTm90aGluZy50KSB3aXRoXG4gICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgIGlnbm9yZV9leG4gKGZ1biAoKSAtPiBDb3JlLkRlYnVnLmVwcmludHMgXCJDYW1sLmV4aXQgcmFpc2VkXCIgZXhuIFslc2V4cF9vZjogRXhuLnRdKTtcbiAgICAgICBDb3JlX3VuaXguZXhpdF9pbW1lZGlhdGVseSAoaWYgY29kZSA9IDAgdGhlbiAxIGVsc2UgY29kZSlcbiAgICAgfCBfIC0+IC4pXG4gIHwgU2lnbmFsIHNpZ25hbCAtPlxuICAgIChtYXRjaCBTdGRsaWIuZG9fYXRfZXhpdCAoKSB3aXRoXG4gICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgIGlnbm9yZV9leG4gKGZ1biAoKSAtPiBDb3JlLkRlYnVnLmVwcmludHMgXCJDYW1sLmV4aXQgcmFpc2VkXCIgZXhuIFslc2V4cF9vZjogRXhuLnRdKVxuICAgICB8ICgpIC0+ICgpKTtcbiAgICBTaWduYWwuRXhwZXJ0LnNldCBzaWduYWwgYERlZmF1bHQ7XG4gICAgU2lnbmFsX3VuaXguc2VuZF9leG4gc2lnbmFsIChgUGlkIChDb3JlX3VuaXguZ2V0cGlkICgpKSk7XG4gICAgaWdub3JlX2V4biAoZnVuICgpIC0+XG4gICAgICBDb3JlLkRlYnVnLmVwcmludHNcbiAgICAgICAgXCJTaWduYWxfdW5peC5zZW5kX2V4biBmYWlsZWQgdG8ga2lsbCBwcm9jZXNzXCJcbiAgICAgICAgc2lnbmFsXG4gICAgICAgIFslc2V4cF9vZjogU2lnbmFsLnRdKTtcbiAgICBDb3JlX3VuaXguZXhpdF9pbW1lZGlhdGVseSAxXG47O1xuXG5sZXQgc2h1dGRvd25fd2l0aF9zdGF0dXMgP2ZvcmNlIHN0YXR1cyA9XG4gIGlmIGRlYnVnIHRoZW4gaWdub3JlX2V4biAoZnVuICgpIC0+IERlYnVnLmxvZyBcInNodXRkb3duXCIgc3RhdHVzIFslc2V4cF9vZjogU3RhdHVzLnRdKTtcbiAgbWF0Y2ggIXNodXR0aW5nX2Rvd25fcmVmIHdpdGhcbiAgfCBZZXMgcHJpb3IgLT5cbiAgICAobWF0Y2ggU3RhdHVzLmNvbXBhdGliaWxpdHkgc3RhdHVzIH5wcmlvciB3aXRoXG4gICAgIHwgSW5jb21wYXRpYmxlIC0+XG4gICAgICAgcmFpc2Vfc1xuICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgIFwic2h1dGRvd24gd2l0aCBpbmNvbnNpc3RlbnQgc3RhdHVzXCIgKHN0YXR1cyA6IFN0YXR1cy50KSAocHJpb3IgOiBTdGF0dXMudCldXG4gICAgIHwgQ29tcGF0aWJsZV9hbmRfcmVwbGFjZSAtPiBzaHV0dGluZ19kb3duX3JlZiA6PSBZZXMgc3RhdHVzXG4gICAgIHwgQ29tcGF0aWJsZV9hbmRfZG9fbm90X3JlcGxhY2UgLT4gKCkpXG4gIHwgTm8gLT5cbiAgICBzaHV0dGluZ19kb3duX3JlZiA6PSBZZXMgc3RhdHVzO1xuICAgIHVwb25cbiAgICAgIChEZWZlcnJlZC5hbGxcbiAgICAgICAgIChMaXN0Lm1hcCAhdG9kbyB+ZjooZnVuIChiYWNrdHJhY2UsIGYpIC0+XG4gICAgICAgICAgICBsZXQlbWFwIHJlc3VsdCA9IE1vbml0b3IudHJ5X3dpdGhfb3JfZXJyb3IgfnJlc3Q6YExvZyBmIGluXG4gICAgICAgICAgICAobWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgICAgICB8IE9rICgpIC0+ICgpXG4gICAgICAgICAgICAgfCBFcnJvciBlcnJvciAtPlxuICAgICAgICAgICAgICAgaWdub3JlX2V4biAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgIENvcmUuRGVidWcuZXByaW50c1xuICAgICAgICAgICAgICAgICAgIFwiYXRfc2h1dGRvd24gZnVuY3Rpb24gcmFpc2VkXCJcbiAgICAgICAgICAgICAgICAgICAoZXJyb3IsIGJhY2t0cmFjZSlcbiAgICAgICAgICAgICAgICAgICBbJXNleHBfb2Y6IEVycm9yLnQgKiBCYWNrdHJhY2UudF0pKTtcbiAgICAgICAgICAgIGlmIGRlYnVnXG4gICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgIGlnbm9yZV9leG4gKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgIERlYnVnLmxvZ1xuICAgICAgICAgICAgICAgICAgXCJvbmUgYXRfc2h1dGRvd24gZnVuY3Rpb24gZmluaXNoZWRcIlxuICAgICAgICAgICAgICAgICAgYmFja3RyYWNlXG4gICAgICAgICAgICAgICAgICBbJXNleHBfb2Y6IEJhY2t0cmFjZS50XSk7XG4gICAgICAgICAgICByZXN1bHQpKSlcbiAgICAgIChmdW4gcmVzdWx0cyAtPlxuICAgICAgICBtYXRjaCBzaHV0dGluZ19kb3duICgpIHdpdGhcbiAgICAgICAgfCBObyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgfCBZZXMgc3RhdHVzIC0+XG4gICAgICAgICAgbGV0IHN0YXR1cyA9XG4gICAgICAgICAgICBtYXRjaCBPcl9lcnJvci5jb21iaW5lX2Vycm9yc191bml0IHJlc3VsdHMgd2l0aFxuICAgICAgICAgICAgfCBPayAoKSAtPiBzdGF0dXNcbiAgICAgICAgICAgIHwgRXJyb3IgXyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICAgICAgIHwgRXhpdCAwIC0+IEV4aXQgMVxuICAgICAgICAgICAgICAgfCBfIC0+IHN0YXR1cylcbiAgICAgICAgICBpblxuICAgICAgICAgIGV4aXRfcmVsaWFibHkgc3RhdHVzKTtcbiAgICBsZXQgZm9yY2UgPVxuICAgICAgbWF0Y2ggZm9yY2Ugd2l0aFxuICAgICAgfCBOb25lIC0+ICFkZWZhdWx0X2ZvcmNlX3JlZiAoKVxuICAgICAgfCBTb21lIGYgLT4gZlxuICAgIGluXG4gICAgdXBvbiBmb3JjZSAoZnVuICgpIC0+XG4gICAgICBpZ25vcmVfZXhuIChmdW4gKCkgLT4gRGVidWcubG9nX3N0cmluZyBcIlNodXRkb3duIGZvcmNlZC5cIik7XG4gICAgICBleGl0X3JlbGlhYmx5IChFeGl0IDEpKVxuOztcblxubGV0IHNodXRkb3duID9mb3JjZSBleGl0X2NvZGUgPSBzaHV0ZG93bl93aXRoX3N0YXR1cyA/Zm9yY2UgKEV4aXQgZXhpdF9jb2RlKVxuXG5sZXQgc2h1dGRvd25fd2l0aF9zaWduYWxfZXhuID9mb3JjZSBzaWduYWwgPVxuICBtYXRjaCBTaWduYWwuZGVmYXVsdF9zeXNfYmVoYXZpb3Igc2lnbmFsIHdpdGhcbiAgfCBgVGVybWluYXRlIHwgYER1bXBfY29yZSAtPiBzaHV0ZG93bl93aXRoX3N0YXR1cyA/Zm9yY2UgKFNpZ25hbCBzaWduYWwpXG4gIHwgKGBTdG9wIHwgYENvbnRpbnVlIHwgYElnbm9yZSkgYXMgZGVmYXVsdF9zeXNfYmVoYXZpb3IgLT5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJTaHV0ZG93bi5zaHV0ZG93bl93aXRoX3NpZ25hbF9leG46IG5vdCBhIHRlcm1pbmF0aW5nIHNpZ25hbFwiXG4gICAgICAgICAgKHNpZ25hbCA6IFNpZ25hbC50KVxuICAgICAgICAgIChkZWZhdWx0X3N5c19iZWhhdmlvciA6IFsgYFN0b3AgfCBgQ29udGludWUgfCBgSWdub3JlIF0pXVxuOztcblxubGV0IHNodXRkb3duX29uX3VuaGFuZGxlZF9leG4gKCkgPVxuICBNb25pdG9yLmRldGFjaF9hbmRfaXRlcl9lcnJvcnMgTW9uaXRvci5tYWluIH5mOihmdW4gZXhuIC0+XG4gICAgaWdub3JlX2V4biAoZnVuICgpIC0+XG4gICAgICBEZWJ1Zy5sb2cgXCJzaHV0dGluZyBkb3duIGR1ZSB0byB1bmhhbmRsZWQgZXhjZXB0aW9uXCIgZXhuIFslc2V4cF9vZjogZXhuXSk7XG4gICAgdHJ5IHNodXRkb3duIDEgd2l0aFxuICAgIHwgXyAtPlxuICAgICAgKCogVGhlIGFib3ZlIFtzaHV0ZG93bl0gY2FsbCByYWlzZXMgaWYgd2UgaGF2ZSBhbHJlYWR5IGNhbGxlZCBzaHV0ZG93biB3aXRoIGFcbiAgICAgICAgIGRpZmZlcmVudCBub24temVybyBzdGF0dXMuICopXG4gICAgICAoKSlcbjs7XG5cbmxldCBleGl0ID9mb3JjZSBzdGF0dXMgPVxuICBzaHV0ZG93biA/Zm9yY2Ugc3RhdHVzO1xuICBEZWZlcnJlZC5uZXZlciAoKVxuOztcblxubGV0IGRvbid0X2ZpbmlzaF9iZWZvcmUgPVxuICBsZXQgcHJvY2VlZF93aXRoX3NodXRkb3duID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IG51bV93YWl0aW5nID0gcmVmIDAgaW5cbiAgbGV0IGNoZWNrICgpID0gaWYgIW51bV93YWl0aW5nID0gMCB0aGVuIEl2YXIuZmlsbF9leG4gcHJvY2VlZF93aXRoX3NodXRkb3duICgpIGluXG4gIGF0X3NodXRkb3duIChmdW4gKCkgLT5cbiAgICBjaGVjayAoKTtcbiAgICBJdmFyLnJlYWQgcHJvY2VlZF93aXRoX3NodXRkb3duKTtcbiAgZnVuIGQgLT5cbiAgICBtYXRjaCBzaHV0dGluZ19kb3duICgpIHdpdGhcbiAgICB8IFllcyBfIC0+ICgpXG4gICAgfCBObyAtPlxuICAgICAgaW5jciBudW1fd2FpdGluZztcbiAgICAgIHVwb24gZCAoZnVuICgpIC0+XG4gICAgICAgIGRlY3IgbnVtX3dhaXRpbmc7XG4gICAgICAgIG1hdGNoIHNodXR0aW5nX2Rvd24gKCkgd2l0aFxuICAgICAgICB8IE5vIC0+ICgpXG4gICAgICAgIHwgWWVzIF8gLT4gY2hlY2sgKCkpXG47O1xuIiwib3BlbiBDb3JlXG5tb2R1bGUgU2lnbmFsID0gQ29yZS5TaWduYWxcblxubW9kdWxlIEhhbmRsZXJzID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgYmFnIDogKChTaWduYWwudCAtPiB1bml0KVtAc2V4cC5vcGFxdWVdKSBCYWcudCB9IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSAoKSA9IHsgYmFnID0gQmFnLmNyZWF0ZSAoKSB9XG4gIGxldCBhZGQgdCBoYW5kbGVyID0gQmFnLmFkZCB0LmJhZyBoYW5kbGVyXG4gIGxldCByZW1vdmUgdCBoYW5kbGVyX2VsdCA9IEJhZy5yZW1vdmUgdC5iYWcgaGFuZGxlcl9lbHRcblxuICBsZXQgZGVsaXZlciB0IHNpZ25hbCA9XG4gICAgQmFnLml0ZXIgdC5iYWcgfmY6KGZ1biBoYW5kbGVyIC0+XG4gICAgICB0cnkgaGFuZGxlciBzaWduYWwgd2l0aFxuICAgICAgfCBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJzaWduYWwgaGFuZGxlciB1bmV4cGVjdGVkbHkgcmFpc2VkXCIgKGV4biA6IGV4bildKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBIYW5kbGVyID0gc3RydWN0XG4gIHR5cGUgdCA9IFQgb2YgKEhhbmRsZXJzLnQgKiAoU2lnbmFsLnQgLT4gdW5pdCkgQmFnLkVsdC50KSBsaXN0XG5lbmRcblxudHlwZSBoYW5kbGVyID0gSGFuZGxlci50XG5cbm1vZHVsZSB0eXBlIFNpZ25hbF9kaXNwYXRjaGVyID0gc2lnXG4gIHR5cGUgdFxuICB0eXBlIGhhbmRsZXJcblxuICB2YWwgc2V0X2NvbXBvc2FibGVfaGFuZGxlciA6IHQgLT4gU2lnbmFsLnQgbGlzdCAtPiB1bml0XG4gIHZhbCBpbnN0YWxsX2hhbmRsZXIgOiB0IC0+IFNpZ25hbC50IGxpc3QgLT4gKFNpZ25hbC50IC0+IHVuaXQpIC0+IGhhbmRsZXJcbiAgdmFsIHJlbW92ZV9oYW5kbGVyIDogdCAtPiBoYW5kbGVyIC0+IHVuaXRcbmVuZFxuXG5tb2R1bGUgU2lnbmFsX2Rpc3BhdGNoZXIgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBTaWduYWxfZGlzcGF0Y2hlciB3aXRoIHR5cGUgdCA6PSB0IGFuZCB0eXBlIGhhbmRsZXIgPSBoYW5kbGVyXG5cbiAgdmFsIGNyZWF0ZSA6IHVuaXQgLT4gdFxuICB2YWwgZGlzcGF0Y2ggOiB0IC0+IG9yaWdpbmFsX2Rpc3Bvc2l0aW9uOlNpZ25hbC5FeHBlcnQuYmVoYXZpb3IgLT4gU2lnbmFsLnQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgaGFuZGxlcnNfYnlfc2lnbmFsIDogSGFuZGxlcnMudCBTaWduYWwuVGFibGUudCB9IFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgbm9ucmVjIGhhbmRsZXIgPSBoYW5kbGVyXG5cbiAgbGV0IGNyZWF0ZSAoKSA9IHsgaGFuZGxlcnNfYnlfc2lnbmFsID0gU2lnbmFsLlRhYmxlLmNyZWF0ZSAoKSB9XG5cbiAgbGV0IGdldF9oYW5kbGVycyB0IHNpZ25hbCA9XG4gICAgSGFzaHRibC5maW5kX29yX2FkZCB0LmhhbmRsZXJzX2J5X3NpZ25hbCBzaWduYWwgfmRlZmF1bHQ6KGZ1biAoKSAtPlxuICAgICAgSGFuZGxlcnMuY3JlYXRlICgpKVxuICA7O1xuXG4gIGxldCBzZXRfY29tcG9zYWJsZV9oYW5kbGVyIHQgc2lnbmFscyA9XG4gICAgTGlzdC5pdGVyIHNpZ25hbHMgfmY6KGZ1biBzaWduYWwgLT4gaWdub3JlIChnZXRfaGFuZGxlcnMgdCBzaWduYWwgOiBIYW5kbGVycy50KSlcbiAgOztcblxuICBsZXQgaW5zdGFsbF9oYW5kbGVyIHQgc2lnbmFscyBoYW5kbGVyID1cbiAgICBIYW5kbGVyLlRcbiAgICAgIChMaXN0Lm1hcCBzaWduYWxzIH5mOihmdW4gc2lnbmFsIC0+XG4gICAgICAgICBsZXQgaGFuZGxlcnMgPSBnZXRfaGFuZGxlcnMgdCBzaWduYWwgaW5cbiAgICAgICAgIGhhbmRsZXJzLCBIYW5kbGVycy5hZGQgaGFuZGxlcnMgaGFuZGxlcikpXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9oYW5kbGVyIF90IChIYW5kbGVyLlQgaGFuZGxlcikgPVxuICAgIExpc3QuaXRlciBoYW5kbGVyIH5mOihmdW4gKGhhbmRsZXJzLCBoYW5kbGVyX2VsdCkgLT5cbiAgICAgIEhhbmRsZXJzLnJlbW92ZSBoYW5kbGVycyBoYW5kbGVyX2VsdClcbiAgOztcblxuICBsZXQgZGVmYXVsdF9zaWduYWxfaGFuZGxlciB+b3JpZ2luYWxfZGlzcG9zaXRpb24gc2lnbmFsID1cbiAgICBBc3luY19rZXJuZWwuQXN5bmNfa2VybmVsX3NjaGVkdWxlci5zY2hlZHVsZSAoZnVuICgpIC0+XG4gICAgICBtYXRjaCBvcmlnaW5hbF9kaXNwb3NpdGlvbiB3aXRoXG4gICAgICB8IGBJZ25vcmUgLT4gKClcbiAgICAgIHwgYEhhbmRsZSBmIC0+IGYgc2lnbmFsXG4gICAgICB8IGBEZWZhdWx0IC0+XG4gICAgICAgIChtYXRjaCBTaWduYWwuZGVmYXVsdF9zeXNfYmVoYXZpb3Igc2lnbmFsIHdpdGhcbiAgICAgICAgIHwgYFRlcm1pbmF0ZSB8IGBEdW1wX2NvcmUgLT4gU2h1dGRvd24uc2h1dGRvd25fd2l0aF9zaWduYWxfZXhuIHNpZ25hbFxuICAgICAgICAgfCBgU3RvcCB8IGBDb250aW51ZSB8IGBJZ25vcmUgLT4gKCkpKVxuICA7O1xuXG4gIGxldCBkaXNwYXRjaCB0IH5vcmlnaW5hbF9kaXNwb3NpdGlvbiBzaWduYWwgPVxuICAgIG1hdGNoIEhhc2h0YmwuZmluZCB0LmhhbmRsZXJzX2J5X3NpZ25hbCBzaWduYWwgd2l0aFxuICAgIHwgTm9uZSAtPiBkZWZhdWx0X3NpZ25hbF9oYW5kbGVyIH5vcmlnaW5hbF9kaXNwb3NpdGlvbiBzaWduYWxcbiAgICB8IFNvbWUgaGFuZGxlcnMgLT4gSGFuZGxlcnMuZGVsaXZlciBoYW5kbGVycyBzaWduYWxcbiAgOztcbmVuZFxuXG50eXBlIHQgPVxuICB7IHJhd19zaWduYWxfbWFuYWdlciA6IFJhd19zaWduYWxfbWFuYWdlci50XG4gIDsgc2lnbmFsX2Rpc3BhdGNoZXIgOiBTaWduYWxfZGlzcGF0Y2hlci50XG4gIH1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgXyA9ICgpXG5cbmxldCBjcmVhdGUgfnRocmVhZF9zYWZlX25vdGlmeV9zaWduYWxfZGVsaXZlcmVkID1cbiAgeyByYXdfc2lnbmFsX21hbmFnZXIgPSBSYXdfc2lnbmFsX21hbmFnZXIuY3JlYXRlIH50aHJlYWRfc2FmZV9ub3RpZnlfc2lnbmFsX2RlbGl2ZXJlZFxuICA7IHNpZ25hbF9kaXNwYXRjaGVyID0gU2lnbmFsX2Rpc3BhdGNoZXIuY3JlYXRlICgpXG4gIH1cbjs7XG5cbmxldCBpc19tYW5hZ2luZyB0IHNpZ25hbCA9IFJhd19zaWduYWxfbWFuYWdlci5pc19tYW5hZ2luZyB0LnJhd19zaWduYWxfbWFuYWdlciBzaWduYWxcblxubGV0IHNldF9jb21wb3NhYmxlX2hhbmRsZXIgdCBzaWduYWxzID1cbiAgTGlzdC5pdGVyIHNpZ25hbHMgfmY6KFJhd19zaWduYWxfbWFuYWdlci5tYW5hZ2UgdC5yYXdfc2lnbmFsX21hbmFnZXIpO1xuICBTaWduYWxfZGlzcGF0Y2hlci5zZXRfY29tcG9zYWJsZV9oYW5kbGVyIHQuc2lnbmFsX2Rpc3BhdGNoZXIgc2lnbmFsc1xuOztcblxubGV0IG1hbmFnZSB0IHNpZ25hbCA9IHNldF9jb21wb3NhYmxlX2hhbmRsZXIgdCBbIHNpZ25hbCBdXG5cbmxldCBtYW5hZ2VfYnV0X2tlZXBfZGVmYXVsdF9iZWhhdmlvciB0IHNpZ25hbCA9XG4gIFJhd19zaWduYWxfbWFuYWdlci5tYW5hZ2UgdC5yYXdfc2lnbmFsX21hbmFnZXIgc2lnbmFsXG47O1xuXG5sZXQgaW5zdGFsbF9oYW5kbGVyIHQgc2lnbmFscyBmID1cbiAgTGlzdC5pdGVyIHNpZ25hbHMgfmY6KFJhd19zaWduYWxfbWFuYWdlci5tYW5hZ2UgdC5yYXdfc2lnbmFsX21hbmFnZXIpO1xuICBTaWduYWxfZGlzcGF0Y2hlci5pbnN0YWxsX2hhbmRsZXIgdC5zaWduYWxfZGlzcGF0Y2hlciBzaWduYWxzIGZcbjs7XG5cbmxldCByZW1vdmVfaGFuZGxlciB0IGhhbmRsZXIgPVxuICBTaWduYWxfZGlzcGF0Y2hlci5yZW1vdmVfaGFuZGxlciB0LnNpZ25hbF9kaXNwYXRjaGVyIGhhbmRsZXJcbjs7XG5cbmxldCBoYW5kbGVfZGVsaXZlcmVkIHQgPVxuICAoKiBUaGUgbG9jYWxfIGFubm90YXRpb24gaXMgdGhlcmUgdG8gbWFrZSBzdXJlIHRoZSBjbG9zdXJlIGNhbid0IGJlIGFsbG9jYXRlZCBvbiB0aGVcbiAgICAgaGVhcCAqKVxuICBsZXQgKCkgPVxuICAgIFJhd19zaWduYWxfbWFuYWdlci5pdGVyX2RlbGl2ZXJlZFxuICAgICAgdC5yYXdfc2lnbmFsX21hbmFnZXJcbiAgICAgIH5mOihmdW4gfm9yaWdpbmFsX2Rpc3Bvc2l0aW9uIHNpZ25hbCAtPlxuICAgICAgU2lnbmFsX2Rpc3BhdGNoZXIuZGlzcGF0Y2ggfm9yaWdpbmFsX2Rpc3Bvc2l0aW9uIHQuc2lnbmFsX2Rpc3BhdGNoZXIgc2lnbmFsKVxuICBpblxuICAoKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm1vZHVsZSBGZCA9IFJhd19mZFxubW9kdWxlIFdhdGNoaW5nID0gRmQuV2F0Y2hpbmdcbm1vZHVsZSBTaWduYWwgPSBDb3JlLlNpZ25hbFxubW9kdWxlIFRpbWVyZmQgPSBMaW51eF9leHQuVGltZXJmZFxubW9kdWxlIFRzYyA9IFRpbWVfc3RhbXBfY291bnRlclxuXG5sZXQgZGVidWcgPSBEZWJ1Zy5zY2hlZHVsZXJcblxubW9kdWxlIEZpbGVfZGVzY3Jfd2F0Y2hlciA9IHN0cnVjdFxuICAoKiBBIGZpbGUgZGVzY3JpcHRvciB3YXRjaGVyIGltcGxlbWVudGF0aW9uICsgYSB3YXRjaGVyLiAgV2UgbmVlZCB0aGUgZmlsZS1kZXNjciB3YXRjaGVyXG4gICAgIGFzIGEgZmlyc3QtY2xhc3MgdmFsdWUgdG8gc3VwcG9ydCBjaG9vc2luZyB3aGljaCBmaWxlLWRlc2NyIHdhdGNoZXIgdG8gdXNlIGluXG4gICAgIFtnb19tYWluXS4gIFdlIGNvdWxkIGRlZmluZSBbdF0gYXMgW0Vwb2xsIG9mIC4uLiB8IFNlbGVjdCBvZiAuLi5dIGFuZCBkaXNwYXRjaCBldmVyeVxuICAgICBjYWxsLCBidXQgaXQgaXMgc2ltcGxlciB0byBqdXN0IHBhY2sgdGhlIGZpbGUgZGVzY3JpcHRvciB3YXRjaGVyIHdpdGggaXRzIGFzc29jaWF0ZWRcbiAgICAgZnVuY3Rpb25zIChPTy1wcm9ncmFtbWluZyB3aXRoIG1vZHVsZXMuLi4pLiAqKVxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgaW5jbHVkZSBGaWxlX2Rlc2NyX3dhdGNoZXJfaW50Zi5TXG5cbiAgICB2YWwgd2F0Y2hlciA6IHRcbiAgZW5kXG5cbiAgdHlwZSB0ID0gKG1vZHVsZSBTKVxuXG4gIGxldCBzZXhwX29mX3QgdCA9XG4gICAgbGV0IG1vZHVsZSBGID0gKHZhbCB0IDogUykgaW5cbiAgICAoKiBJbmNsdWRlIHRoZSBiYWNrZW5kIGluZm9ybWF0aW9uIHNvIHdlIGtub3cgd2hpY2ggb25lIGl0IGlzLiAqKVxuICAgIFslc2V4cF9vZjogQ29uZmlnLkZpbGVfZGVzY3Jfd2F0Y2hlci50ICogRi50XSAoRi5iYWNrZW5kLCBGLndhdGNoZXIpXG4gIDs7XG5lbmRcblxubW9kdWxlIFdoaWNoX3dhdGNoZXIgPSBzdHJ1Y3RcbiAgbW9kdWxlIEN1c3RvbSA9IHN0cnVjdFxuICAgIG1vZHVsZSB0eXBlIFMgPVxuICAgICAgRmlsZV9kZXNjcl93YXRjaGVyX2ludGYuU1xuICAgICAgICB3aXRoIHR5cGUgJ2EgYWRkaXRpb25hbF9jcmVhdGVfYXJncyA9XG4gICAgICAgICAgaGFuZGxlX2ZkX3JlYWRfYmFkOihGaWxlX2Rlc2NyLnQgLT4gdW5pdClcbiAgICAgICAgICAtPiBoYW5kbGVfZmRfd3JpdGVfYmFkOihGaWxlX2Rlc2NyLnQgLT4gdW5pdClcbiAgICAgICAgICAtPiAnYVxuXG4gICAgdHlwZSB0ID0gKG1vZHVsZSBTKVxuICBlbmRcblxuICB0eXBlIHQgPVxuICAgIHwgQ29uZmlnIG9mIENvbmZpZy5GaWxlX2Rlc2NyX3dhdGNoZXIudFxuICAgIHwgQ3VzdG9tIG9mIEN1c3RvbS50XG5lbmRcblxubW9kdWxlIEV4dGVybmFsX2ZkX2V2ZW50ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBmaWxlX2Rlc2NyIDogRmlsZV9kZXNjci50XG4gICAgOyByZWFkX29yX3dyaXRlIDogUmVhZF93cml0ZV9wYWlyLktleS50XG4gICAgOyBldmVudF90eXBlIDogWyBgUmVhZHkgfCBgQmFkX2ZkIF0gKCogSFVQIGlzIHJlcG9ydGVkIGFzIGBSZWFkeSAqKVxuICAgIH1cbmVuZFxuXG5tb2R1bGUgVGhyZWFkX3Bvb2xfc3R1Y2tfc3RhdHVzID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBOb191bnN0YXJ0ZWRfd29ya1xuICAgIHwgU3R1Y2sgb2ZcbiAgICAgICAgeyBzdHVja19zaW5jZSA6IFRpbWVfbnMudFxuICAgICAgICA7IG51bV93b3JrX2NvbXBsZXRlZCA6IGludFxuICAgICAgICB9XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxuaW5jbHVkZSBBc3luY19rZXJuZWxfc2NoZWR1bGVyXG5cbnR5cGUgc3RhcnRfdHlwZSA9XG4gIHwgTm90X3N0YXJ0ZWRcbiAgfCBDYWxsZWRfZ29cbiAgfCBDYWxsZWRfYmxvY2tfb25fYXN5bmMgKCogVGhyZWFkX3NhZmUuYmxvY2tfb25fYXN5bmMgc3RhcnRlZCB0aGUgc2NoZWR1bGVyICopXG4gIHwgQ2FsbGVkX2V4dGVybmFsX3J1biBvZiB7IGFjdGl2ZSA6IGJvb2wgcmVmIH1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbnR5cGUgdCA9XG4gIHsgKCogVGhlIHNjaGVkdWxlciBbbXV0ZXhdIG11c3QgYmUgbG9ja2VkIGJ5IGFsbCBjb2RlIHRoYXQgaXMgbWFuaXB1bGF0aW5nIHNjaGVkdWxlclxuICAgICAgIGRhdGEgc3RydWN0dXJlcywgd2hpY2ggaXMgYWxtb3N0IGFsbCBhc3luYyBjb2RlLiAgVGhlIFttdXRleF0gaXMgYXV0b21hdGljYWxseVxuICAgICAgIGxvY2tlZCBpbiB0aGUgbWFpbiB0aHJlYWQgd2hlbiB0aGUgc2NoZWR1bGVyIGlzIGZpcnN0IGNyZWF0ZWQuICBBIFtOYW5vX211dGV4XVxuICAgICAgIGtlZXBzIHRyYWNrIG9mIHdoaWNoIHRocmVhZCBpcyBob2xkaW5nIHRoZSBsb2NrLiAgVGhpcyBtZWFucyB3ZSBjYW4gZGV0ZWN0IGVycm9yc1xuICAgICAgIGluIHdoaWNoIGNvZGUgaW5jb3JyZWN0bHkgYWNjZXNzZXMgYXN5bmMgZnJvbSBhIHRocmVhZCBub3QgaG9sZGluZyB0aGUgbG9jay4gIFdlIGRvXG4gICAgICAgdGhpcyB3aGVuIFtkZXRlY3RfaW52YWxpZF9hY2Nlc3NfZnJvbV90aHJlYWQgPSB0cnVlXS4gIFdlIGFsc28gZGV0ZWN0IGVycm9ycyBpblxuICAgICAgIHdoaWNoIGNvZGUgdHJpZXMgdG8gYWNxdWlyZSB0aGUgYXN5bmMgbG9jayB3aGlsZSBpdCBhbHJlYWR5IGhvbGRzIGl0LCBvciByZWxlYXNlc1xuICAgICAgIHRoZSBsb2NrIHdoZW4gaXQgZG9lc24ndCBob2xkIGl0LiAqKVxuICAgIG11dGV4IDogTmFub19tdXRleC50XG4gIDsgbXV0YWJsZSBzdGFydF90eXBlIDogc3RhcnRfdHlwZVxuICA7ICgqIFtmZHNfd2hvc2Vfd2F0Y2hpbmdfaGFzX2NoYW5nZWRdIGhvbGRzIGFsbCBmZHMgd2hvc2Ugd2F0Y2hpbmcgaGFzIGNoYW5nZWQgc2luY2VcbiAgICAgICB0aGUgbGFzdCB0aW1lIHRoZWlyIGRlc2lyZWQgc3RhdGUgd2FzIHNldCBpbiB0aGUgW2ZpbGVfZGVzY3Jfd2F0Y2hlcl0uICopXG4gICAgZmRzX3dob3NlX3dhdGNoaW5nX2hhc19jaGFuZ2VkIDogRmQudCBTdGFjay50XG4gIDsgZmlsZV9kZXNjcl93YXRjaGVyIDogRmlsZV9kZXNjcl93YXRjaGVyLnRcbiAgOyAoKiBSZXR1cm5zIGhvdyBtYW55IGV2ZW50cyB0aGUgcG9sbCBoYXMgcHJvY2Vzc2VkLiAqKVxuICAgIGJ1c3lfcG9sbGVycyA6IChCdXN5X3BvbGxlci5wYWNrZWQgVW5pZm9ybV9hcnJheS50W0BzZXhwLm9wYXF1ZV0pXG4gIDsgbXV0YWJsZSBudW1fYnVzeV9wb2xsZXJzIDogaW50XG4gIDsgbXV0YWJsZSB0aW1lX3NwZW50X3dhaXRpbmdfZm9yX2lvIDogVHNjLlNwYW4udFxuICA7ICgqIFtmZF9ieV9kZXNjcl0gaG9sZHMgZXZlcnkgZmlsZSBkZXNjcmlwdG9yIHRoYXQgQXN5bmMgbWFuYWdlcy4gIEZkcyBhcmUgYWRkZWRcbiAgICAgICB3aGVuIHRoZXkgYXJlIGNyZWF0ZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhleSB0cmFuc2l0aW9uIHRvIFtDbG9zZWRdLiAqKVxuICAgIGZkX2J5X2Rlc2NyIDogRmQudCBCeV9kZXNjci50XG4gIDsgKCogW2V4dGVybmFsX2ZkX2J5X2Rlc2NyXSBob2xkcyBmaWxlIGRlc2NyaXB0b3JzIHJlZ2lzdGVyZWQgdmlhIEV4dGVybmFsLlxuICAgICAgIEFzeW5jIGRvZXMgbm8gSS9PIG9uIHRoZXNlLCBub3IgZG9lcyBpdCBvcGVuIG9yIGNsb3NlIHRoZW0sIGJ1dCBpdCByZXBvcnRzXG4gICAgICAgcmVhZGluZXNzIG9mIHRoZW0gZnJvbSBFeHRlcm5hbC5ydW5fb25lX2N5Y2xlICopXG4gICAgZXh0ZXJuYWxfZmRfYnlfZGVzY3IgOiBib29sIFJlYWRfd3JpdGVfcGFpci50IEJ5X2Rlc2NyLnRcbiAgOyAoKiBbZXh0ZXJuYWxfcmVhZHlfZmRzXSBjb21tdW5pY2F0ZXMgdGhlIHNldCBvZiByZWFkeSBleHRlcm5hbCBmaWxlIGRlc2NyaXB0b3JzIGZyb21cbiAgICAgICBbcG9zdF9jaGVja19oYW5kbGVfZmRdIHRvIFtydW5fb25lX2N5Y2xlXSwgYW5kIGlzIGVtcHR5IGF0IG90aGVyIHRpbWVzICopXG4gICAgbXV0YWJsZSBleHRlcm5hbF9mZF9ldmVudHMgOiAoRXh0ZXJuYWxfZmRfZXZlbnQudCBsaXN0W0BzZXhwLm9wYXF1ZV0pXG4gIDsgKCogSWYgd2UgYXJlIHVzaW5nIGEgZmlsZSBkZXNjcmlwdG9yIHdhdGNoZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHN1Yi1taWxsaXNlY29uZFxuICAgICAgIHRpbWVvdXQsIFt0aW1lcmZkXSBjb250YWlucyBhIHRpbWVyZmQgdXNlZCB0byBoYW5kbGUgdGhlIG5leHQgZXhwaXJhdGlvbi5cbiAgICAgICBbdGltZXJmZF9zZXRfYXRdIGhvbGRzIHRoZSB0aGUgdGltZSBhdCB3aGljaCBbdGltZXJmZF0gaXMgc2V0IHRvIGV4cGlyZS4gIFRoaXNcbiAgICAgICBsZXRzIHVzIGF2b2lkIGNhbGxpbmcgW1RpbWVfbnMubm93XSBhbmQgW0xpbnV4X2V4dC5UaW1lcmZkLnNldF9hZnRlcl0gdW5sZXNzXG4gICAgICAgd2UgbmVlZCB0byBjaGFuZ2UgdGhhdCB0aW1lLiAqKVxuICAgIG11dGFibGUgdGltZXJmZCA6IExpbnV4X2V4dC5UaW1lcmZkLnQgb3B0aW9uXG4gIDsgbXV0YWJsZSB0aW1lcmZkX3NldF9hdCA6IFRpbWVfbnMudFxuICA7ICgqIEEgZGlzdGluZ3Vpc2hlZCB0aHJlYWQsIGNhbGxlZCB0aGUgXCJzY2hlZHVsZXJcIiB0aHJlYWQsIGlzIGNvbnRpbnVhbGx5IGxvb3BpbmcsXG4gICAgICAgY2hlY2tpbmcgZmlsZSBkZXNjcmlwdG9ycyBmb3IgSS9PIGFuZCB0aGVuIHJ1bm5pbmcgYSBjeWNsZS4gIEl0IG1hbmFnZXNcbiAgICAgICB0aGUgW2ZpbGVfZGVzY3Jfd2F0Y2hlcl0gYW5kIHJ1bnMgc2lnbmFsIGhhbmRsZXJzLlxuXG4gICAgICAgW3NjaGVkdWxlcl90aHJlYWRfaWRdIGlzIG11dGFibGUgYmVjYXVzZSB3ZSBjcmVhdGUgdGhlIHNjaGVkdWxlciBiZWZvcmUgc3RhcnRpbmdcbiAgICAgICB0aGUgc2NoZWR1bGVyIHJ1bm5pbmcuICBPbmNlIHdlIHN0YXJ0IHJ1bm5pbmcgdGhlIHNjaGVkdWxlciwgW3NjaGVkdWxlcl90aHJlYWRfaWRdXG4gICAgICAgaXMgc2V0IGFuZCBuZXZlciBjaGFuZ2VzIGFnYWluLiAqKVxuICAgIG11dGFibGUgc2NoZWR1bGVyX3RocmVhZF9pZCA6IGludFxuICA7ICgqIFRoZSBbaW50ZXJydXB0b3JdIGlzIHVzZWQgdG8gd2FrZSB1cCB0aGUgc2NoZWR1bGVyIHdoZW4gaXQgaXMgYmxvY2tlZCBvbiB0aGUgZmlsZVxuICAgICAgIGRlc2NyaXB0b3Igd2F0Y2hlci4gKilcbiAgICBpbnRlcnJ1cHRvciA6IEludGVycnVwdG9yLnRcbiAgOyBzaWduYWxfbWFuYWdlciA6IFNpZ25hbF9tYW5hZ2VyLnRcbiAgOyAoKiBUaGUgW3RocmVhZF9wb29sXSBpcyB1c2VkIGZvciBtYWtpbmcgYmxvY2tpbmcgc3lzdGVtIGNhbGxzIGluIHRocmVhZHMgb3RoZXIgdGhhblxuICAgICAgIHRoZSBzY2hlZHVsZXIgdGhyZWFkLCBhbmQgZm9yIHNlcnZpY2luZyBbSW5fdGhyZWFkLnJ1bl0gcmVxdWVzdHMuICopXG4gICAgdGhyZWFkX3Bvb2wgOiBUaHJlYWRfcG9vbC50XG4gIDsgKCogW2hhbmRsZV90aHJlYWRfcG9vbF9zdHVja10gaXMgY2FsbGVkIG9uY2UgcGVyIHNlY29uZCBpZiB0aGUgdGhyZWFkIHBvb2wgaXNcInN0dWNrXCIsXG4gICAgICAgaS5lIGhhcyBub3QgY29tcGxldGVkIGEgam9iIGZvciBvbmUgc2Vjb25kIGFuZCBoYXMgbm8gYXZhaWxhYmxlIHRocmVhZHMuICopXG4gICAgbXV0YWJsZSBoYW5kbGVfdGhyZWFkX3Bvb2xfc3R1Y2sgOiBUaHJlYWRfcG9vbC50IC0+IHN0dWNrX2ZvcjpUaW1lX25zLlNwYW4udCAtPiB1bml0XG4gIDsgbXV0YWJsZSB0aHJlYWRfcG9vbF9zdHVjayA6IFRocmVhZF9wb29sX3N0dWNrX3N0YXR1cy50XG4gIDsgZG5zX2xvb2t1cF90aHJvdHRsZSA6IHVuaXQgVGhyb3R0bGUudFxuICAgICAgKCogW2Ruc19sb29rdXBfdGhyb3R0bGVdIGV4aXN0cyB0byBwcmV2ZW50IHRoZSBlbnRpcmUgdGhyZWFkIHBvb2wgZnJvbSBiZWluZyB1c2VkIG9uIEROU1xuICAgICBsb29rdXBzLiBETlMgaXMgYmVpbmcgc3BlY2lhbC1jYXNlZCBoZXJlIGNvbXBhcmVkIHRvIG90aGVyIGJsb2NraW5nIG9wZXJhdGlvbnMgYXNcbiAgICAgaXQncyBzb21ld2hhdCBjb21tb24gZm9yIHByb2Nlc3NlcyB0byBkbyBsb3RzIG9mIGNvbmN1cnJlbnQgRE5TIGxvb2t1cHMsIGFuZCBETlNcbiAgICAgbG9va3VwcyBjYW4gYmxvY2sgZm9yIGEgbG9uZyB0aW1lLCBlc3BlY2lhbGx5IGluIHRoZSBwcmVzZW5jZSBuZXR3b3JrIHVuYXZhaWxhYmlsaXR5LlxuICAqKVxuICA7IG11dGFibGUgbmV4dF90c2NfY2FsaWJyYXRpb24gOiBUc2MudFxuICA7IGtlcm5lbF9zY2hlZHVsZXIgOiBLZXJuZWxfc2NoZWR1bGVyLnRcbiAgOyAoKiBbaGF2ZV9sb2NrX2RvX2N5Y2xlXSBpcyB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgaW1wbGVtZW50YXRpb24gb2YgcnVubmluZyBhIGN5Y2xlLlxuICAgICAgIEUuZy4gaW4gRWNhbWwgaXQgaXMgc2V0IHRvIHNvbWV0aGluZyB0aGF0IGNhdXNlcyBFbWFjcyB0byBydW4gYSBjeWNsZS4gKilcbiAgICBtdXRhYmxlIGhhdmVfbG9ja19kb19jeWNsZSA6ICh1bml0IC0+IHVuaXQpIG9wdGlvbiAoKiBjb25maWd1cmF0aW9uKilcbiAgOyBtdXRhYmxlIG1heF9pbnRlcl9jeWNsZV90aW1lb3V0IDogTWF4X2ludGVyX2N5Y2xlX3RpbWVvdXQudFxuICA7IG11dGFibGUgbWluX2ludGVyX2N5Y2xlX3RpbWVvdXQgOiBNaW5faW50ZXJfY3ljbGVfdGltZW91dC50XG4gIDsgKCogW2luaXRpYWxpemVkX2F0XSBpcyB0aGUgY2FsbCBzdGFjayBmcm9tIHdoZW4gdGhlIHNjaGVkdWxlciB3YXMgaW5pdGlhbGl6ZWQuICBJdCdzXG4gICAgICAgZ2VuZXJhbGx5IG1vcmUgY29uZnVzaW5nIHRoYW4gdXNlZnVsIGlmIGl0J3Mgc2hvd24gb24gY3Jhc2gsIHNvIHdlIG9taXQgaXQgZnJvbSB0aGVcbiAgICAgICBzZXhwLiAqKVxuICAgIGluaXRpYWxpemVkX2F0IDogKEJhY2t0cmFjZS50W0BzZXhwLm9wYXF1ZV0pXG4gIDsgdXJpbmcgOiAoSW9fdXJpbmdfcmF3LnQgb3B0aW9uW0BzZXhwLm9wYXF1ZV0pXG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOihmb2xkLCBpdGVyKSwgc2V4cF9vZl1cblxubGV0IG1heF9udW1fdGhyZWFkcyB0ID0gVGhyZWFkX3Bvb2wubWF4X251bV90aHJlYWRzIHQudGhyZWFkX3Bvb2xcbmxldCBtYXhfbnVtX29wZW5fZmlsZV9kZXNjcnMgdCA9IEJ5X2Rlc2NyLmNhcGFjaXR5IHQuZmRfYnlfZGVzY3JcblxubGV0IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCA9XG4gIEtlcm5lbF9zY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0Lmtlcm5lbF9zY2hlZHVsZXJcbjs7XG5cbmxldCB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0IHQgY29udGV4dCB+ZiA9XG4gIEtlcm5lbF9zY2hlZHVsZXIud2l0aF9leGVjdXRpb25fY29udGV4dCB0Lmtlcm5lbF9zY2hlZHVsZXIgY29udGV4dCB+ZlxuOztcblxubGV0IHRocmVhZF9wb29sX2NwdV9hZmZpbml0eSB0ID0gVGhyZWFkX3Bvb2wuY3B1X2FmZmluaXR5IHQudGhyZWFkX3Bvb2xcblxubGV0IGxvY2sgdCA9XG4gICgqIFRoZSBmb2xsb3dpbmcgZGVidWcgbWVzc2FnZSBpcyBvdXRzaWRlIHRoZSBsb2NrLCBhbmQgc28gdGhlcmUgY2FuIGJlIHJhY2VzIGJldHdlZW5cbiAgICAgbXVsdGlwbGUgdGhyZWFkcyBwcmludGluZyB0aGlzIG1lc3NhZ2UuICopXG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nX3N0cmluZyBcIndhaXRpbmcgb24gbG9ja1wiO1xuICBOYW5vX211dGV4LmxvY2tfZXhuIHQubXV0ZXhcbjs7XG5cbmxldCB0cnlfbG9jayB0ID1cbiAgbWF0Y2ggTmFub19tdXRleC50cnlfbG9ja19leG4gdC5tdXRleCB3aXRoXG4gIHwgYEFjcXVpcmVkIC0+IHRydWVcbiAgfCBgTm90X2FjcXVpcmVkIC0+IGZhbHNlXG47O1xuXG5sZXQgdW5sb2NrIHQgPVxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJsb2NrIHJlbGVhc2VkXCI7XG4gIE5hbm9fbXV0ZXgudW5sb2NrX2V4biB0Lm11dGV4XG47O1xuXG5sZXQgd2l0aF9sb2NrIHQgZiA9XG4gIGxvY2sgdDtcbiAgcHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IHVubG9jayB0KVxuOztcblxubGV0IGFtX2hvbGRpbmdfbG9jayB0ID0gTmFub19tdXRleC5jdXJyZW50X3RocmVhZF9oYXNfbG9jayB0Lm11dGV4XG5cbnR5cGUgdGhlX29uZV9hbmRfb25seSA9XG4gIHwgTm90X3JlYWR5X3RvX2luaXRpYWxpemUgb2ZcbiAgICAgICgqIHRoaXMgW3VuaXRdIG1ha2VzIHRoZSByZXByZXNlbnRhdGlvbiBhbHdheXMgYmUgYSBwb2ludGVyLCB0aHVzXG4gICAgICAgICBtYWtpbmcgdGhlIHBhdHRlcm4tbWF0Y2ggZmFzdGVyICopXG4gICAgICB1bml0XG4gIHwgUmVhZHlfdG9faW5pdGlhbGl6ZSBvZiAodW5pdCAtPiB0KVxuICB8IEluaXRpYWxpemVkIG9mIHRcblxuKCogV2UgdXNlIGEgbXV0ZXggdG8gcHJvdGVjdCBjcmVhdGlvbiBvZiB0aGUgb25lLWFuZC1vbmx5IHNjaGVkdWxlciBpbiB0aGUgZXZlbnQgdGhhdFxuICAgbXVsdGlwbGUgdGhyZWFkcyBhdHRlbXB0IHRvIGNhbGwgW3RoZV9vbmVfYW5kX29ubHldIHNpbXVsdGFuZW91c2x5LCB3aGljaCBjYW5cbiAgIGhhcHBlbiBpbiBwcm9ncmFtcyB0aGF0IGFyZSB1c2luZyBbVGhyZWFkX3NhZmUucnVuX2luX2FzeW5jXS4gKilcbmxldCBtdXRleF9mb3JfaW5pdGlhbGl6aW5nX3RoZV9vbmVfYW5kX29ubHlfcmVmID0gTmFub19tdXRleC5jcmVhdGUgKClcbmxldCB0aGVfb25lX2FuZF9vbmx5X3JlZiA6IHRoZV9vbmVfYW5kX29ubHkgcmVmID0gcmVmIChOb3RfcmVhZHlfdG9faW5pdGlhbGl6ZSAoKSlcblxubGV0IGlzX3JlYWR5X3RvX2luaXRpYWxpemUgKCkgPVxuICBtYXRjaCAhdGhlX29uZV9hbmRfb25seV9yZWYgd2l0aFxuICB8IE5vdF9yZWFkeV90b19pbml0aWFsaXplICgpIHwgSW5pdGlhbGl6ZWQgXyAtPiBmYWxzZVxuICB8IFJlYWR5X3RvX2luaXRpYWxpemUgXyAtPiB0cnVlXG47O1xuXG5sZXQgaXNfaW5pdGlhbGl6ZWQgKCkgPVxuICBtYXRjaCAhdGhlX29uZV9hbmRfb25seV9yZWYgd2l0aFxuICB8IEluaXRpYWxpemVkIF8gLT4gdHJ1ZVxuICB8IE5vdF9yZWFkeV90b19pbml0aWFsaXplICgpIHwgUmVhZHlfdG9faW5pdGlhbGl6ZSBfIC0+IGZhbHNlXG47O1xuXG4oKiBIYW5kbGluZyB0aGUgdW5jb21tb24gY2FzZXMgaW4gdGhpcyBmdW5jdGlvbiBhbGxvd3MgW3RoZV9vbmVfYW5kX29ubHldIHRvIGJlIGlubGluZWQuXG4gICBUaGUgcHJlc2VuY2Ugb2YgYSBzdHJpbmcgY29uc3RhbnQgKGFuZCB0aGUgY29sZCBhbm5vdGF0aW9uKSBrZWVwcyB0aGlzIGZ1bmN0aW9uIGZyb21cbiAgIGJlaW5nIGlubGluZWQuICopXG5sZXRbQGNvbGRdIHRoZV9vbmVfYW5kX29ubHlfdW5jb21tb25fY2FzZSAoKSA9XG4gIE5hbm9fbXV0ZXguY3JpdGljYWxfc2VjdGlvbiBtdXRleF9mb3JfaW5pdGlhbGl6aW5nX3RoZV9vbmVfYW5kX29ubHlfcmVmIH5mOihmdW4gKCkgLT5cbiAgICBtYXRjaCAhdGhlX29uZV9hbmRfb25seV9yZWYgd2l0aFxuICAgIHwgSW5pdGlhbGl6ZWQgdCAtPiB0XG4gICAgfCBOb3RfcmVhZHlfdG9faW5pdGlhbGl6ZSAoKSAtPlxuICAgICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJBc3luYyB0aGVfb25lX2FuZF9vbmx5IG5vdCByZWFkeSB0byBpbml0aWFsaXplXCJdXG4gICAgfCBSZWFkeV90b19pbml0aWFsaXplIGYgLT5cbiAgICAgIGxldCB0ID0gZiAoKSBpblxuICAgICAgdGhlX29uZV9hbmRfb25seV9yZWYgOj0gSW5pdGlhbGl6ZWQgdDtcbiAgICAgIHQpXG47O1xuXG5sZXQgdGhlX29uZV9hbmRfb25seSAoKSA9XG4gIG1hdGNoICF0aGVfb25lX2FuZF9vbmx5X3JlZiB3aXRoXG4gIHwgSW5pdGlhbGl6ZWQgdCAtPiB0XG4gIHwgTm90X3JlYWR5X3RvX2luaXRpYWxpemUgKCkgfCBSZWFkeV90b19pbml0aWFsaXplIF8gLT5cbiAgICB0aGVfb25lX2FuZF9vbmx5X3VuY29tbW9uX2Nhc2UgKClcbjs7XG5cbmxldCBmZHNfY3JlYXRlZF9iZWZvcmVfaW5pdGlhbGl6YXRpb24gPSByZWYgW11cblxubGV0IGNyZWF0ZV9mZF9yZWdpc3RyYXRpb24gdCBmZCA9XG4gIG1hdGNoIEJ5X2Rlc2NyLmFkZCB0LmZkX2J5X2Rlc2NyIGZkLkZkLmZpbGVfZGVzY3IgZmQgd2l0aFxuICB8IE9rICgpIC0+ICgpXG4gIHwgRXJyb3IgZXJyb3IgLT5cbiAgICBsZXQgYmFja3RyYWNlID1cbiAgICAgIGlmIFBweF9pbmxpbmVfdGVzdF9saWIuYW1fcnVubmluZyB0aGVuIE5vbmUgZWxzZSBTb21lIChCYWNrdHJhY2UuZ2V0ICgpKVxuICAgIGluXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiQXN5bmMgd2FzIHVuYWJsZSB0byBhZGQgYSBmaWxlIGRlc2NyaXB0b3IgdG8gaXRzIHRhYmxlIG9mIG9wZW4gZmlsZSBkZXNjcmlwdG9yc1wiXG4gICAgICAgICAgfmZpbGVfZGVzY3I6KEZkLmZpbGVfZGVzY3IgZmQgOiBGaWxlX2Rlc2NyLnQpXG4gICAgICAgICAgKGVycm9yIDogRXJyb3IudClcbiAgICAgICAgICAoYmFja3RyYWNlIDogKEJhY2t0cmFjZS50IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgICAgICB+c2NoZWR1bGVyOlxuICAgICAgICAgICAgKGlmIFBweF9pbmxpbmVfdGVzdF9saWIuYW1fcnVubmluZyB0aGVuIE5vbmUgZWxzZSBTb21lIHRcbiAgICAgICAgICAgICAgOiAodCBvcHRpb25bQHNleHAub3B0aW9uXSkpXVxuOztcblxubGV0IGNyZWF0ZV9mZCA/YXZvaWRfc2V0dGluZ19ub25ibG9jayBraW5kIGZpbGVfZGVzY3IgaW5mbyA9XG4gICgqIFdlIG1ha2UgaXQgcG9zc2libGUgdG8gY3JlYXRlIGEgd3JpdGVyIHdpdGhvdXQgaW5pdGlhbGl6aW5nIHRoZSBhc3luYyBzY2hlZHVsZXIsIGFzXG4gICAgIHRoaXMgaXMgc29tZXRoaW5nIHRoYXQgaGFwcGVucyBhIGZhaXIgYW1vdW50IGF0IHRvcGxldmVsIG9mIHByb2dyYW1zLiAqKVxuICBsZXQgZmQgPSBGZC5jcmVhdGUgP2F2b2lkX3NldHRpbmdfbm9uYmxvY2sga2luZCBmaWxlX2Rlc2NyIGluZm8gaW5cbiAgaWYgaXNfaW5pdGlhbGl6ZWQgKClcbiAgdGhlbiBjcmVhdGVfZmRfcmVnaXN0cmF0aW9uICh0aGVfb25lX2FuZF9vbmx5ICgpKSBmZFxuICBlbHNlXG4gICAgTmFub19tdXRleC5jcml0aWNhbF9zZWN0aW9uIG11dGV4X2Zvcl9pbml0aWFsaXppbmdfdGhlX29uZV9hbmRfb25seV9yZWYgfmY6KGZ1biAoKSAtPlxuICAgICAgaWYgaXNfaW5pdGlhbGl6ZWQgKClcbiAgICAgIHRoZW4gY3JlYXRlX2ZkX3JlZ2lzdHJhdGlvbiAodGhlX29uZV9hbmRfb25seSAoKSkgZmRcbiAgICAgIGVsc2UgZmRzX2NyZWF0ZWRfYmVmb3JlX2luaXRpYWxpemF0aW9uIDo9IGZkIDo6ICFmZHNfY3JlYXRlZF9iZWZvcmVfaW5pdGlhbGl6YXRpb24pO1xuICBmZFxuOztcblxubGV0IGN1cnJlbnRfdGhyZWFkX2lkICgpID0gQ29yZV90aHJlYWQuKGlkIChzZWxmICgpKSlcblxuKCogT0NhbWwgcnVudGltZSBoYXBwZW5zIHRvIGFzc2lnbiB0aGUgdGhyZWFkIGlkIG9mIFswXSB0byB0aGUgbWFpbiB0aHJlYWRcbiAgICh0aGUgaW5pdGlhbCB0aHJlYWQgdGhhdCBzdGFydHMgdGhlIHByb2dyYW0pLiAqKVxubGV0IGlzX21haW5fdGhyZWFkICgpID0gY3VycmVudF90aHJlYWRfaWQgKCkgPSAwXG5sZXQgcmVtb3ZlX2ZkIHQgZmQgPSBCeV9kZXNjci5yZW1vdmUgdC5mZF9ieV9kZXNjciBmZC5GZC5maWxlX2Rlc2NyXG5cbmxldCBtYXliZV9zdGFydF9jbG9zaW5nX2ZkIHQgKGZkIDogRmQudCkgPVxuICBpZiBmZC5udW1fYWN0aXZlX3N5c2NhbGxzID0gMFxuICB0aGVuIChcbiAgICBtYXRjaCBmZC5zdGF0ZSB3aXRoXG4gICAgfCBDbG9zZWQgfCBPcGVuIF8gLT4gKClcbiAgICB8IENsb3NlX3JlcXVlc3RlZCAoZXhlY3V0aW9uX2NvbnRleHQsIGRvX2Nsb3NlX3N5c2NhbGwpIC0+XG4gICAgICAoKiBXZSBtdXN0IHJlbW92ZSB0aGUgZmQgbm93IGFuZCBub3QgYWZ0ZXIgdGhlIGNsb3NlIGhhcyBmaW5pc2hlZC4gIElmIHdlIHdhaXRlZFxuICAgICAgICAgdW50aWwgYWZ0ZXIgdGhlIGNsb3NlIGhhZCBmaW5pc2hlZCwgdGhlbiB0aGUgZmQgbWlnaHQgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgICAgICAgIHJldXNlZCBieSB0aGUgT1MgYW5kIHJlcGxhY2VkLiAqKVxuICAgICAgcmVtb3ZlX2ZkIHQgZmQ7XG4gICAgICBGZC5zZXRfc3RhdGUgZmQgQ2xvc2VkO1xuICAgICAgS2VybmVsX3NjaGVkdWxlci5lbnF1ZXVlIHQua2VybmVsX3NjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBkb19jbG9zZV9zeXNjYWxsICgpKVxuOztcblxubGV0IGRlY19udW1fYWN0aXZlX3N5c2NhbGxzX2ZkIHQgKGZkIDogRmQudCkgPVxuICBmZC5udW1fYWN0aXZlX3N5c2NhbGxzIDwtIGZkLm51bV9hY3RpdmVfc3lzY2FsbHMgLSAxO1xuICBtYXliZV9zdGFydF9jbG9zaW5nX2ZkIHQgZmRcbjs7XG5cbmxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgaW52YXJpYW50IGZpZWxkID0gaW52YXJpYW50IChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm11dGV4Omlnbm9yZVxuICAgICAgfmhhdmVfbG9ja19kb19jeWNsZTppZ25vcmVcbiAgICAgIH5zdGFydF90eXBlOmlnbm9yZVxuICAgICAgfmZkc193aG9zZV93YXRjaGluZ19oYXNfY2hhbmdlZDpcbiAgICAgICAgKGNoZWNrIChmdW4gZmRzX3dob3NlX3dhdGNoaW5nX2hhc19jaGFuZ2VkIC0+XG4gICAgICAgICAgIFN0YWNrLml0ZXIgZmRzX3dob3NlX3dhdGNoaW5nX2hhc19jaGFuZ2VkIH5mOihmdW4gKGZkIDogRmQudCkgLT5cbiAgICAgICAgICAgICBhc3NlcnQgZmQud2F0Y2hpbmdfaGFzX2NoYW5nZWQ7XG4gICAgICAgICAgICAgbWF0Y2ggQnlfZGVzY3IuZmluZCB0LmZkX2J5X2Rlc2NyIGZkLmZpbGVfZGVzY3Igd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgICB8IFNvbWUgZmQnIC0+IGFzc2VydCAocGh5c19lcXVhbCBmZCBmZCcpKSkpXG4gICAgICB+ZmlsZV9kZXNjcl93YXRjaGVyOlxuICAgICAgICAoY2hlY2sgKGZ1biBmaWxlX2Rlc2NyX3dhdGNoZXIgLT5cbiAgICAgICAgICAgbGV0IG1vZHVsZSBGID0gKHZhbCBmaWxlX2Rlc2NyX3dhdGNoZXIgOiBGaWxlX2Rlc2NyX3dhdGNoZXIuUykgaW5cbiAgICAgICAgICAgRi5pbnZhcmlhbnQgRi53YXRjaGVyO1xuICAgICAgICAgICBGLml0ZXIgRi53YXRjaGVyIH5mOihmdW4gZmlsZV9kZXNjciBfIC0+XG4gICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICBtYXRjaCBCeV9kZXNjci5maW5kIHQuZmRfYnlfZGVzY3IgZmlsZV9kZXNjciB3aXRoXG4gICAgICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJtaXNzaW5nIGZyb20gZmRfYnlfZGVzY3JcIl1cbiAgICAgICAgICAgICAgIHwgU29tZSBmZCAtPiBhc3NlcnQgKEZkLm51bV9hY3RpdmVfc3lzY2FsbHMgZmQgPiAwKVxuICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICB8IGV4biAtPlxuICAgICAgICAgICAgICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJmZCBwcm9ibGVtXCIgKGV4biA6IGV4bikgKGZpbGVfZGVzY3IgOiBGaWxlX2Rlc2NyLnQpXSkpKVxuICAgICAgfmJ1c3lfcG9sbGVyczppZ25vcmVcbiAgICAgIH5udW1fYnVzeV9wb2xsZXJzOmlnbm9yZVxuICAgICAgfnRpbWVfc3BlbnRfd2FpdGluZ19mb3JfaW86aWdub3JlXG4gICAgICB+ZmRfYnlfZGVzY3I6XG4gICAgICAgIChjaGVjayAoZnVuIGZkX2J5X2Rlc2NyIC0+XG4gICAgICAgICAgIEJ5X2Rlc2NyLmludmFyaWFudCBmZF9ieV9kZXNjcjtcbiAgICAgICAgICAgQnlfZGVzY3IuaXRlciBmZF9ieV9kZXNjciB+ZjooZnVuIGZkIC0+XG4gICAgICAgICAgICAgaWYgZmQud2F0Y2hpbmdfaGFzX2NoYW5nZWRcbiAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICBTdGFjay5leGlzdHMgdC5mZHNfd2hvc2Vfd2F0Y2hpbmdfaGFzX2NoYW5nZWQgfmY6KGZ1biBmZCcgLT5cbiAgICAgICAgICAgICAgICAgICBwaHlzX2VxdWFsIGZkIGZkJykpKSkpXG4gICAgICB+ZXh0ZXJuYWxfZmRfYnlfZGVzY3I6aWdub3JlXG4gICAgICB+ZXh0ZXJuYWxfZmRfZXZlbnRzOihjaGVjayAoZnVuIGZkcyAtPiBhc3NlcnQgKExpc3QuaXNfZW1wdHkgZmRzKSkpXG4gICAgICB+dGltZXJmZDppZ25vcmVcbiAgICAgIH50aW1lcmZkX3NldF9hdDppZ25vcmVcbiAgICAgIH5zY2hlZHVsZXJfdGhyZWFkX2lkOmlnbm9yZVxuICAgICAgfmludGVycnVwdG9yOihjaGVjayBJbnRlcnJ1cHRvci5pbnZhcmlhbnQpXG4gICAgICB+c2lnbmFsX21hbmFnZXI6KGNoZWNrIFNpZ25hbF9tYW5hZ2VyLmludmFyaWFudClcbiAgICAgIH50aHJlYWRfcG9vbDooY2hlY2sgVGhyZWFkX3Bvb2wuaW52YXJpYW50KVxuICAgICAgfmhhbmRsZV90aHJlYWRfcG9vbF9zdHVjazppZ25vcmVcbiAgICAgIH50aHJlYWRfcG9vbF9zdHVjazppZ25vcmVcbiAgICAgIH5kbnNfbG9va3VwX3Rocm90dGxlOmlnbm9yZVxuICAgICAgfm5leHRfdHNjX2NhbGlicmF0aW9uOmlnbm9yZVxuICAgICAgfmtlcm5lbF9zY2hlZHVsZXI6KGNoZWNrIEtlcm5lbF9zY2hlZHVsZXIuaW52YXJpYW50KVxuICAgICAgfm1heF9pbnRlcl9jeWNsZV90aW1lb3V0Omlnbm9yZVxuICAgICAgfm1pbl9pbnRlcl9jeWNsZV90aW1lb3V0OlxuICAgICAgICAoY2hlY2sgKGZ1biBtaW5faW50ZXJfY3ljbGVfdGltZW91dCAtPlxuICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgIFRpbWVfbnMuU3Bhbi4oIDw9IClcbiAgICAgICAgICAgICAgIChNaW5faW50ZXJfY3ljbGVfdGltZW91dC5yYXcgbWluX2ludGVyX2N5Y2xlX3RpbWVvdXQpXG4gICAgICAgICAgICAgICAoTWF4X2ludGVyX2N5Y2xlX3RpbWVvdXQucmF3IHQubWF4X2ludGVyX2N5Y2xlX3RpbWVvdXQpKSkpXG4gICAgICB+aW5pdGlhbGl6ZWRfYXQ6aWdub3JlXG4gICAgICB+dXJpbmc6aWdub3JlXG4gIHdpdGhcbiAgfCBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJTY2hlZHVsZXIuaW52YXJpYW50IGZhaWxlZFwiIChleG4gOiBleG4pIH5zY2hlZHVsZXI6KHQgOiB0KV1cbjs7XG5cbmxldCB1cGRhdGVfY2hlY2tfYWNjZXNzIHQgZG9fY2hlY2sgPVxuICBLZXJuZWxfc2NoZWR1bGVyLnNldF9jaGVja19hY2Nlc3NcbiAgICB0Lmtlcm5lbF9zY2hlZHVsZXJcbiAgICAoaWYgbm90IGRvX2NoZWNrXG4gICAgIHRoZW4gTm9uZVxuICAgICBlbHNlXG4gICAgICAgU29tZVxuICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICBpZiBub3QgKGFtX2hvbGRpbmdfbG9jayB0KVxuICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICBEZWJ1Zy5sb2dcbiAgICAgICAgICAgICAgIFwiYXR0ZW1wdCB0byBhY2Nlc3MgQXN5bmMgZnJvbSB0aHJlYWQgbm90IGhvbGRpbmcgdGhlIEFzeW5jIGxvY2tcIlxuICAgICAgICAgICAgICAgKEJhY2t0cmFjZS5nZXQgKCksIHQsIFRpbWUubm93ICgpKVxuICAgICAgICAgICAgICAgWyVzZXhwX29mOiBCYWNrdHJhY2UudCAqIHQgKiBUaW1lLnRdO1xuICAgICAgICAgICAgIGV4aXQgMSkpKVxuOztcblxuKCogVHJ5IHRvIGNyZWF0ZSBhIHRpbWVyZmQuICBJdCByZXR1cm5zIFtOb25lXSBpZiBbQ29yZV0gaXMgbm90IGJ1aWx0IHdpdGggdGltZXJmZCBzdXBwb3J0XG4gICBvciBpZiBpdCBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBjdXJyZW50IHN5c3RlbS4gKilcbmxldCB0cnlfY3JlYXRlX3RpbWVyZmQgKCkgPVxuICBtYXRjaCBUaW1lcmZkLmNyZWF0ZSB3aXRoXG4gIHwgRXJyb3IgXyAtPiBOb25lXG4gIHwgT2sgY3JlYXRlIC0+XG4gICAgbGV0IGNsb2NrID0gVGltZXJmZC5DbG9jay5yZWFsdGltZSBpblxuICAgICh0cnkgU29tZSAoY3JlYXRlIGNsb2NrIH5mbGFnczpUaW1lcmZkLkZsYWdzLihub25ibG9jayArIGNsb2V4ZWMpKSB3aXRoXG4gICAgIHwgVW5peC5Vbml4X2Vycm9yIChFTk9TWVMsIF8sIF8pIC0+XG4gICAgICAgKCogS2VybmVsIHRvbyBvbGQuICopXG4gICAgICAgTm9uZVxuICAgICB8IFVuaXguVW5peF9lcnJvciAoRUlOVkFMLCBfLCBfKSAtPlxuICAgICAgICgqIEZsYWdzIGFyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIExpbnV4ID49IDIuNi4yNywgdHJ5IHdpdGhvdXQgdGhlbS4gKilcbiAgICAgICBsZXQgdGltZXJmZCA9IGNyZWF0ZSBjbG9jayBpblxuICAgICAgIFVuaXguc2V0X2Nsb3NlX29uX2V4ZWMgKHRpbWVyZmQgOiBUaW1lcmZkLnQgOj4gVW5peC5GaWxlX2Rlc2NyLnQpO1xuICAgICAgIFVuaXguc2V0X25vbmJsb2NrICh0aW1lcmZkIDogVGltZXJmZC50IDo+IFVuaXguRmlsZV9kZXNjci50KTtcbiAgICAgICBTb21lIHRpbWVyZmQpXG47O1xuXG5sZXQgZGVmYXVsdF9oYW5kbGVfdGhyZWFkX3Bvb2xfc3R1Y2sgdGhyZWFkX3Bvb2wgfnN0dWNrX2ZvciA9XG4gIGlmIFRpbWVfbnMuU3Bhbi4oID49ICkgc3R1Y2tfZm9yIENvbmZpZy5yZXBvcnRfdGhyZWFkX3Bvb2xfc3R1Y2tfZm9yXG4gIHRoZW4gKFxuICAgIGxldCBzaG91bGRfYWJvcnQgPVxuICAgICAgVGltZV9ucy5TcGFuLiggPj0gKSBzdHVja19mb3IgQ29uZmlnLmFib3J0X2FmdGVyX3RocmVhZF9wb29sX3N0dWNrX2ZvclxuICAgIGluXG4gICAgbGV0IHRleHQgPSBcIkFzeW5jJ3MgdGhyZWFkIHBvb2wgaXMgc3R1Y2tcIiBpblxuICAgIGxldCB0ZXh0ID1cbiAgICAgIGlmIHNob3VsZF9hYm9ydFxuICAgICAgdGhlbiB0ZXh0XG4gICAgICBlbHNlXG4gICAgICAgIHNwcmludGZcbiAgICAgICAgICBcIiVzLCBhbmQgd2lsbCByYWlzZSBhbiBleGNlcHRpb24gaW4gJXNcIlxuICAgICAgICAgIHRleHRcbiAgICAgICAgICAoVGltZV9ucy5TcGFuLnRvX3Nob3J0X3N0cmluZ1xuICAgICAgICAgICAgIChUaW1lX25zLlNwYW4uKCAtICkgQ29uZmlnLmFib3J0X2FmdGVyX3RocmVhZF9wb29sX3N0dWNrX2ZvciBzdHVja19mb3IpKVxuICAgIGluXG4gICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiXCJcbiAgICAgICAgICB+XzooaWYgYW1fcnVubmluZ190ZXN0IHRoZW4gVGltZV9ucy5lcG9jaCBlbHNlIFRpbWVfbnMubm93ICgpIDogVGltZV9ucy50KVxuICAgICAgICAgIHRleHRcbiAgICAgICAgICB+c3R1Y2tfZm9yOihUaW1lX25zLlNwYW4udG9fc2hvcnRfc3RyaW5nIHN0dWNrX2ZvciA6IHN0cmluZylcbiAgICAgICAgICB+bnVtX3RocmVhZHNfY3JlYXRlZDooVGhyZWFkX3Bvb2wubnVtX3RocmVhZHMgdGhyZWFkX3Bvb2wgOiBpbnQpXG4gICAgICAgICAgfm1heF9udW1fdGhyZWFkczooVGhyZWFkX3Bvb2wubWF4X251bV90aHJlYWRzIHRocmVhZF9wb29sIDogaW50KVxuICAgICAgICAgIH5sYXN0X3RocmVhZF9jcmVhdGlvbl9mYWlsdXJlOlxuICAgICAgICAgICAgKFRocmVhZF9wb29sLmxhc3RfdGhyZWFkX2NyZWF0aW9uX2ZhaWx1cmUgdGhyZWFkX3Bvb2xcbiAgICAgICAgICAgICAgOiAoU2V4cC50IG9wdGlvbltAc2V4cC5vcHRpb25dKSldXG4gICAgaW5cbiAgICBpZiBzaG91bGRfYWJvcnRcbiAgICB0aGVuIChcbiAgICAgICgqIENvcmUgZHVtcHMgYXJlIGV4Y2VwdGlvbmFsbHkgdXNlZnVsIHdoZW4gaW52ZXN0aWdhdGluZyB0aHJlYWQgcG9vbCBzdHVjayBlcnJvcnMsXG4gICAgICAgICBzaW5jZSB0aGV5IGdpdmUgeW91IGFjY2VzcyB0byBhbGwgdGhlIGNhbGwgc3RhY2tzIHRoYXQgZ290IHN0dWNrLCBzbyBkdW1wIGl0IGhlcmVcbiAgICAgICAgIChjb3JlIGR1bXAgaW4gW2JlX3RoZV9zY2hlZHVsZXJdIGlzIG5vdCBraWNraW5nIGluIGhlcmUgYmVjYXVzZSB0aGlzIGVycm9yIGlzXG4gICAgICAgICBjbGFzc2lmaWVkIGFzIFtgVXNlcl91bmNhdWdodF0sIG5vdCBbYEFzeW5jX3VuY2F1Z2h0XSkuXG5cbiAgICAgICAgIE5vdCBkdW1waW5nIHdoZW4gW2FtX3J1bm5pbmdfdGVzdF0gdG8gYXZvaWQgcG90ZW50aWFsbHkgbWFraW5nIHNvbWUgZXhpc3RpbmdcbiAgICAgICAgIHRlc3RzIHNsb3dlciBpbiBjYXNlIHRoZXkgYXJlIGRlbGliZXJhdGVseSB0ZXN0aW5nIHRoaXMgc2NlbmFyaW8uICopXG4gICAgICBpZiBub3QgYW1fcnVubmluZ190ZXN0IHRoZW4gRHVtcF9jb3JlX29uX2pvYl9kZWxheS5kdW1wX2NvcmUgKCk7XG4gICAgICBNb25pdG9yLnNlbmRfZXhuIE1vbml0b3IubWFpbiAoRXJyb3IudG9fZXhuIChFcnJvci5jcmVhdGVfcyBtZXNzYWdlKSkpXG4gICAgZWxzZSBDb3JlLkRlYnVnLmVwcmludF9zIG1lc3NhZ2UpXG47O1xuXG5sZXQgdGhyZWFkX3Bvb2xfaGFzX3VuZmluaXNoZWRfd29yayB0ID0gVGhyZWFkX3Bvb2wudW5maW5pc2hlZF93b3JrIHQudGhyZWFkX3Bvb2wgPD4gMFxubGV0IHRocmVhZF9zYWZlX3dha2V1cF9zY2hlZHVsZXIgdCA9IEludGVycnVwdG9yLnRocmVhZF9zYWZlX2ludGVycnVwdCB0LmludGVycnVwdG9yXG5sZXQgaV9hbV90aGVfc2NoZWR1bGVyIHQgPSBjdXJyZW50X3RocmVhZF9pZCAoKSA9IHQuc2NoZWR1bGVyX3RocmVhZF9pZFxuXG5sZXQgc2V0X2ZkX2Rlc2lyZWRfd2F0Y2hpbmcgdCAoZmQgOiBGZC50KSByZWFkX29yX3dyaXRlIGRlc2lyZWQgPVxuICBSZWFkX3dyaXRlX3BhaXIuc2V0IGZkLndhdGNoaW5nIHJlYWRfb3Jfd3JpdGUgZGVzaXJlZDtcbiAgaWYgbm90IGZkLndhdGNoaW5nX2hhc19jaGFuZ2VkXG4gIHRoZW4gKFxuICAgIGZkLndhdGNoaW5nX2hhc19jaGFuZ2VkIDwtIHRydWU7XG4gICAgU3RhY2sucHVzaCB0LmZkc193aG9zZV93YXRjaGluZ19oYXNfY2hhbmdlZCBmZClcbjs7XG5cbmxldCBnaXZlX3VwX29uX3dhdGNoaW5nIHQgZmQgcmVhZF9vcl93cml0ZSAod2F0Y2hpbmcgOiBXYXRjaGluZy50KSA9XG4gIGlmIERlYnVnLmZpbGVfZGVzY3Jfd2F0Y2hlclxuICB0aGVuXG4gICAgRGVidWcubG9nXG4gICAgICBcImdpdmVfdXBfb25fd2F0Y2hpbmdcIlxuICAgICAgKHJlYWRfb3Jfd3JpdGUsIGZkLCB0KVxuICAgICAgWyVzZXhwX29mOiBSZWFkX3dyaXRlX3BhaXIuS2V5LnQgKiBGZC50ICogdF07XG4gIG1hdGNoIHdhdGNoaW5nIHdpdGhcbiAgfCBTdG9wX3JlcXVlc3RlZCB8IE5vdF93YXRjaGluZyAtPiAoKVxuICB8IFdhdGNoX29uY2UgcmVhZHlfdG8gLT5cbiAgICBJdmFyLmZpbGxfZXhuIHJlYWR5X3RvIGBVbnN1cHBvcnRlZDtcbiAgICBzZXRfZmRfZGVzaXJlZF93YXRjaGluZyB0IGZkIHJlYWRfb3Jfd3JpdGUgU3RvcF9yZXF1ZXN0ZWRcbiAgfCBXYXRjaF9yZXBlYXRlZGx5IChqb2IsIGZpbmlzaGVkKSAtPlxuICAgIEtlcm5lbF9zY2hlZHVsZXIuZnJlZV9qb2IgdC5rZXJuZWxfc2NoZWR1bGVyIGpvYjtcbiAgICBJdmFyLmZpbGxfZXhuIGZpbmlzaGVkIGBVbnN1cHBvcnRlZDtcbiAgICBzZXRfZmRfZGVzaXJlZF93YXRjaGluZyB0IGZkIHJlYWRfb3Jfd3JpdGUgU3RvcF9yZXF1ZXN0ZWRcbjs7XG5cbmxldCByZXF1ZXN0X3N0YXJ0X3dhdGNoaW5nIHQgZmQgcmVhZF9vcl93cml0ZSB3YXRjaGluZyA9XG4gIGlmIERlYnVnLmZpbGVfZGVzY3Jfd2F0Y2hlclxuICB0aGVuXG4gICAgRGVidWcubG9nXG4gICAgICBcInJlcXVlc3Rfc3RhcnRfd2F0Y2hpbmdcIlxuICAgICAgKHJlYWRfb3Jfd3JpdGUsIGZkLCB0KVxuICAgICAgWyVzZXhwX29mOiBSZWFkX3dyaXRlX3BhaXIuS2V5LnQgKiBGZC50ICogdF07XG4gIGxldCByZXN1bHQgPVxuICAgIG1hdGNoIFJlYWRfd3JpdGVfcGFpci5nZXQgZmQud2F0Y2hpbmcgcmVhZF9vcl93cml0ZSB3aXRoXG4gICAgfCBXYXRjaF9vbmNlIF8gfCBXYXRjaF9yZXBlYXRlZGx5IF8gLT4gYEFscmVhZHlfd2F0Y2hpbmdcbiAgICB8IFN0b3BfcmVxdWVzdGVkIC0+XG4gICAgICAoKiBXZSBkb24ndCBbaW5jX251bV9hY3RpdmVfc3lzY2FsbHNdIGluIHRoaXMgY2FzZSwgYmVjYXVzZSB3ZSBhbHJlYWR5IGRpZCB3aGVuIHdlXG4gICAgICAgICB0cmFuc2l0aW9uZWQgZnJvbSBbTm90X3dhdGNoaW5nXSB0byBbV2F0Y2hpbmddLiAgQWxzbywgaXQgaXMgcG9zc2libGUgdGhhdCBbZmRdXG4gICAgICAgICB3YXMgY2xvc2VkIHNpbmNlIHdlIHRyYW5zaXRpb25lZCB0byBbU3RvcF9yZXF1ZXN0ZWRdLCBpbiB3aGljaCBjYXNlIHdlIGRvbid0IHdhbnRcbiAgICAgICAgIHRvIFtzdGFydF93YXRjaGluZ107IHdlIHdhbnQgdG8gcmVwb3J0IHRoYXQgaXQgd2FzIGNsb3NlZCBhbmQgbGVhdmUgaXRcbiAgICAgICAgIFtTdG9wX3JlcXVlc3RlZF0gc28gdGhlIHRoZSBmaWxlLWRlc2NyLXdhdGNoZXIgd2lsbCBzdG9wIHdhdGNoaW5nIGl0IGFuZCB3ZSBjYW5cbiAgICAgICAgIGFjdHVhbGx5IGNsb3NlIGl0LiAqKVxuICAgICAgaWYgRmQuaXNfY2xvc2VkIGZkIHRoZW4gYEFscmVhZHlfY2xvc2VkIGVsc2UgYFdhdGNoaW5nXG4gICAgfCBOb3Rfd2F0Y2hpbmcgLT5cbiAgICAgIChtYXRjaCBGZC5pbmNfbnVtX2FjdGl2ZV9zeXNjYWxscyBmZCB3aXRoXG4gICAgICAgfCBgQWxyZWFkeV9jbG9zZWQgLT4gYEFscmVhZHlfY2xvc2VkXG4gICAgICAgfCBgT2sgLT4gYFdhdGNoaW5nKVxuICBpblxuICAobWF0Y2ggcmVzdWx0IHdpdGhcbiAgIHwgYEFscmVhZHlfY2xvc2VkIHwgYEFscmVhZHlfd2F0Y2hpbmcgLT4gKClcbiAgIHwgYFdhdGNoaW5nIC0+XG4gICAgIHNldF9mZF9kZXNpcmVkX3dhdGNoaW5nIHQgZmQgcmVhZF9vcl93cml0ZSB3YXRjaGluZztcbiAgICAgaWYgbm90IChpX2FtX3RoZV9zY2hlZHVsZXIgdCkgdGhlbiB0aHJlYWRfc2FmZV93YWtldXBfc2NoZWR1bGVyIHQpO1xuICByZXN1bHRcbjs7XG5cbmxldCByZXF1ZXN0X3N0b3Bfd2F0Y2hpbmcgdCBmZCByZWFkX29yX3dyaXRlIHZhbHVlID1cbiAgaWYgRGVidWcuZmlsZV9kZXNjcl93YXRjaGVyXG4gIHRoZW5cbiAgICBEZWJ1Zy5sb2dcbiAgICAgIFwicmVxdWVzdF9zdG9wX3dhdGNoaW5nXCJcbiAgICAgIChyZWFkX29yX3dyaXRlLCB2YWx1ZSwgZmQsIHQpXG4gICAgICBbJXNleHBfb2Y6IFJlYWRfd3JpdGVfcGFpci5LZXkudCAqIEZkLnJlYWR5X3RvX3Jlc3VsdCAqIEZkLnQgKiB0XTtcbiAgbWF0Y2ggUmVhZF93cml0ZV9wYWlyLmdldCBmZC53YXRjaGluZyByZWFkX29yX3dyaXRlIHdpdGhcbiAgfCBTdG9wX3JlcXVlc3RlZCB8IE5vdF93YXRjaGluZyAtPiAoKVxuICB8IFdhdGNoX29uY2UgcmVhZHlfdG8gLT5cbiAgICBJdmFyLmZpbGxfZXhuIHJlYWR5X3RvIHZhbHVlO1xuICAgIHNldF9mZF9kZXNpcmVkX3dhdGNoaW5nIHQgZmQgcmVhZF9vcl93cml0ZSBTdG9wX3JlcXVlc3RlZDtcbiAgICBpZiBub3QgKGlfYW1fdGhlX3NjaGVkdWxlciB0KSB0aGVuIHRocmVhZF9zYWZlX3dha2V1cF9zY2hlZHVsZXIgdFxuICB8IFdhdGNoX3JlcGVhdGVkbHkgKGpvYiwgZmluaXNoZWQpIC0+XG4gICAgKG1hdGNoIHZhbHVlIHdpdGhcbiAgICAgfCBgUmVhZHkgLT4gS2VybmVsX3NjaGVkdWxlci5lbnF1ZXVlX2pvYiB0Lmtlcm5lbF9zY2hlZHVsZXIgam9iIH5mcmVlX2pvYjpmYWxzZVxuICAgICB8IChgQ2xvc2VkIHwgYEJhZF9mZCB8IGBJbnRlcnJ1cHRlZCB8IGBVbnN1cHBvcnRlZCkgYXMgdmFsdWUgLT5cbiAgICAgICBLZXJuZWxfc2NoZWR1bGVyLmZyZWVfam9iIHQua2VybmVsX3NjaGVkdWxlciBqb2I7XG4gICAgICAgSXZhci5maWxsX2V4biBmaW5pc2hlZCB2YWx1ZTtcbiAgICAgICBzZXRfZmRfZGVzaXJlZF93YXRjaGluZyB0IGZkIHJlYWRfb3Jfd3JpdGUgU3RvcF9yZXF1ZXN0ZWQ7XG4gICAgICAgaWYgbm90IChpX2FtX3RoZV9zY2hlZHVsZXIgdCkgdGhlbiB0aHJlYWRfc2FmZV93YWtldXBfc2NoZWR1bGVyIHQpXG47O1xuXG5sZXRbQGNvbGRdIHBvc3RfY2hlY2tfZ290X3RpbWVyZmQgZmlsZV9kZXNjciA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiRmlsZV9kZXNjcl93YXRjaGVyIHJldHVybmVkIHRoZSB0aW1lcmZkIGFzIHJlYWR5IHRvIGJlIHdyaXR0ZW4gdG9cIlxuICAgICAgICAoZmlsZV9kZXNjciA6IEZpbGVfZGVzY3IudCldXG47O1xuXG5sZXRbQGNvbGRdIHBvc3RfY2hlY2tfaW52YWxpZF9mZCBmaWxlX2Rlc2NyID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJGaWxlX2Rlc2NyX3dhdGNoZXIgcmV0dXJuZWQgdW5rbm93biBmaWxlIGRlc2NyXCIgKGZpbGVfZGVzY3IgOiBGaWxlX2Rlc2NyLnQpXVxuOztcblxubGV0IHBvc3RfY2hlY2tfaGFuZGxlX2ZkIHQgZmlsZV9kZXNjciByZWFkX29yX3dyaXRlIChldmVudF90eXBlIDogWyBgUmVhZHkgfCBgQmFkX2ZkIF0pID1cbiAgaWYgQnlfZGVzY3IubWVtIHQuZmRfYnlfZGVzY3IgZmlsZV9kZXNjclxuICB0aGVuIChcbiAgICBsZXQgZmQgPSBCeV9kZXNjci5maW5kX2V4biB0LmZkX2J5X2Rlc2NyIGZpbGVfZGVzY3IgaW5cbiAgICByZXF1ZXN0X3N0b3Bfd2F0Y2hpbmcgdCBmZCByZWFkX29yX3dyaXRlIChldmVudF90eXBlIDo+IEZkLnJlYWR5X3RvX3Jlc3VsdCkpXG4gIGVsc2UgKFxuICAgIG1hdGNoIHQudGltZXJmZCB3aXRoXG4gICAgfCBTb21lIHRmZCB3aGVuIEZpbGVfZGVzY3IuZXF1YWwgZmlsZV9kZXNjciAodGZkIDo+IFVuaXguRmlsZV9kZXNjci50KSAtPlxuICAgICAgKG1hdGNoIHJlYWRfb3Jfd3JpdGUgd2l0aFxuICAgICAgIHwgYFJlYWQgLT5cbiAgICAgICAgICgqIFdlIGRvbid0IG5lZWQgdG8gYWN0dWFsbHkgY2FsbCBbcmVhZF0gc2luY2Ugd2UgYXJlIHVzaW5nIHRoZVxuICAgICAgICAgICAgZWRnZS10cmlnZ2VyZWQgYmVoYXZpb3IuICopXG4gICAgICAgICAoKVxuICAgICAgIHwgYFdyaXRlIC0+IHBvc3RfY2hlY2tfZ290X3RpbWVyZmQgZmlsZV9kZXNjcilcbiAgICB8IF8gLT5cbiAgICAgIGlmIEJ5X2Rlc2NyLm1lbSB0LmV4dGVybmFsX2ZkX2J5X2Rlc2NyIGZpbGVfZGVzY3JcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgZXYgOiBFeHRlcm5hbF9mZF9ldmVudC50ID0geyBmaWxlX2Rlc2NyOyByZWFkX29yX3dyaXRlOyBldmVudF90eXBlIH0gaW5cbiAgICAgICAgdC5leHRlcm5hbF9mZF9ldmVudHMgPC0gZXYgOjogdC5leHRlcm5hbF9mZF9ldmVudHMpXG4gICAgICBlbHNlIHBvc3RfY2hlY2tfaW52YWxpZF9mZCBmaWxlX2Rlc2NyKVxuOztcblxuZXh0ZXJuYWwgbWFnaWNfdHJhY2VfbG9uZ19hc3luY19jeWNsZSA6IHVuaXQgLT4gdW5pdCA9IFwibWFnaWNfdHJhY2VfbG9uZ19hc3luY19jeWNsZVwiXG4gIFtAQG5vYWxsb2NdXG5cbmxldCBjeWNsZV90b29rX2xvbmdlcl90aGFuXzEwMHVzID1cbiAgbGV0IG9wZW4gQm9vbC5Ob25fc2hvcnRfY2lyY3VpdGluZyBpblxuICBsZXQgKCA+ICkgPSBUaW1lX25zLlNwYW4uKCA+ICkgaW5cbiAgbGV0IHRvb19sb25nID0gcmVmIGZhbHNlIGluXG4gIGxldFtAaW5saW5lXSB0b29fbG9uZ19pZiBib29sID0gdG9vX2xvbmcgOj0gIXRvb19sb25nIHx8IGJvb2wgaW5cbiAgZnVuIFtAaW5saW5lIG5ldmVyXSB+Y3ljbGVfdGltZSAtPlxuICAgIHRvb19sb25nIDo9IGZhbHNlO1xuICAgIFslcHJvYmUgXCJtYWdpY190cmFjZV9hc3luY19jeWNsZV9sb25nZXJfdGhhbl8xMDB1c1wiICh0b29fbG9uZyA6PSB0cnVlKV07XG4gICAgWyVwcm9iZVxuICAgICAgXCJtYWdpY190cmFjZV9hc3luY19jeWNsZV9sb25nZXJfdGhhbl8zMDB1c1wiXG4gICAgICAgICh0b29fbG9uZ19pZiAoY3ljbGVfdGltZSA+IFRpbWVfbnMuU3Bhbi5vZl9pbnRfdXMgMzAwKSldO1xuICAgIFslcHJvYmVcbiAgICAgIFwibWFnaWNfdHJhY2VfYXN5bmNfY3ljbGVfbG9uZ2VyX3RoYW5fMW1zXCJcbiAgICAgICAgKHRvb19sb25nX2lmIChjeWNsZV90aW1lID4gVGltZV9ucy5TcGFuLm9mX2ludF9tcyAxKSldO1xuICAgIFslcHJvYmVcbiAgICAgIFwibWFnaWNfdHJhY2VfYXN5bmNfY3ljbGVfbG9uZ2VyX3RoYW5fM21zXCJcbiAgICAgICAgKHRvb19sb25nX2lmIChjeWNsZV90aW1lID4gVGltZV9ucy5TcGFuLm9mX2ludF9tcyAzKSldO1xuICAgIFslcHJvYmVcbiAgICAgIFwibWFnaWNfdHJhY2VfYXN5bmNfY3ljbGVfbG9uZ2VyX3RoYW5fMTBtc1wiXG4gICAgICAgICh0b29fbG9uZ19pZiAoY3ljbGVfdGltZSA+IFRpbWVfbnMuU3Bhbi5vZl9pbnRfbXMgMTApKV07XG4gICAgWyVwcm9iZVxuICAgICAgXCJtYWdpY190cmFjZV9hc3luY19jeWNsZV9sb25nZXJfdGhhbl8zMG1zXCJcbiAgICAgICAgKHRvb19sb25nX2lmIChjeWNsZV90aW1lID4gVGltZV9ucy5TcGFuLm9mX2ludF9tcyAzMCkpXTtcbiAgICBbJXByb2JlXG4gICAgICBcIm1hZ2ljX3RyYWNlX2FzeW5jX2N5Y2xlX2xvbmdlcl90aGFuXzEwMG1zXCJcbiAgICAgICAgKHRvb19sb25nX2lmIChjeWNsZV90aW1lID4gVGltZV9ucy5TcGFuLm9mX2ludF9tcyAxMDApKV07XG4gICAgWyVwcm9iZVxuICAgICAgXCJtYWdpY190cmFjZV9hc3luY19jeWNsZV9sb25nZXJfdGhhbl8zMDBtc1wiXG4gICAgICAgICh0b29fbG9uZ19pZiAoY3ljbGVfdGltZSA+IFRpbWVfbnMuU3Bhbi5vZl9pbnRfbXMgMzAwKSldO1xuICAgIFslcHJvYmVcbiAgICAgIFwibWFnaWNfdHJhY2VfYXN5bmNfY3ljbGVfbG9uZ2VyX3RoYW5fMXNcIlxuICAgICAgICAodG9vX2xvbmdfaWYgKGN5Y2xlX3RpbWUgPiBUaW1lX25zLlNwYW4ub2ZfaW50X3NlYyAxKSldO1xuICAgIFslcHJvYmVcbiAgICAgIFwibWFnaWNfdHJhY2VfYXN5bmNfY3ljbGVfbG9uZ2VyX3RoYW5fM3NcIlxuICAgICAgICAodG9vX2xvbmdfaWYgKGN5Y2xlX3RpbWUgPiBUaW1lX25zLlNwYW4ub2ZfaW50X3NlYyAzKSldO1xuICAgIFslcHJvYmVcbiAgICAgIFwibWFnaWNfdHJhY2VfYXN5bmNfY3ljbGVfbG9uZ2VyX3RoYW5fMTBzXCJcbiAgICAgICAgKHRvb19sb25nX2lmIChjeWNsZV90aW1lID4gVGltZV9ucy5TcGFuLm9mX2ludF9zZWMgMTApKV07XG4gICAgWyVwcm9iZVxuICAgICAgXCJtYWdpY190cmFjZV9hc3luY19jeWNsZV9sb25nZXJfdGhhbl8zMHNcIlxuICAgICAgICAodG9vX2xvbmdfaWYgKGN5Y2xlX3RpbWUgPiBUaW1lX25zLlNwYW4ub2ZfaW50X3NlYyAzMCkpXTtcbiAgICBbJXByb2JlXG4gICAgICBcIm1hZ2ljX3RyYWNlX2FzeW5jX2N5Y2xlX2xvbmdlcl90aGFuXzFtXCJcbiAgICAgICAgKHRvb19sb25nX2lmIChjeWNsZV90aW1lID4gVGltZV9ucy5TcGFuLm9mX2ludF9zZWMgNjApKV07XG4gICAgaWYgIXRvb19sb25nIHRoZW4gbWFnaWNfdHJhY2VfbG9uZ19hc3luY19jeWNsZSAoKVxuOztcblxubGV0W0BpbmxpbmVdIG1heWJlX3JlcG9ydF9sb25nX2FzeW5jX2N5Y2xlc190b19tYWdpY190cmFjZSB+Y3ljbGVfdGltZSA9XG4gIGxldCAoID4gKSA9IFRpbWVfbnMuU3Bhbi4oID4gKSBpblxuICAoKiBUaGlzIGZpcnN0IGNoZWNrIGlzIGxpZnRlZCBvdXQgdG8gYXZvaWQgdGhlIGxpbmVhciBzY2FuIHRocm91Z2ggZWFjaCBwcm9iZSBkdXJpbmdcbiAgICAgc2hvcnQgYXN5bmMgY3ljbGVzLiAqKVxuICBpZiBjeWNsZV90aW1lID4gVGltZV9ucy5TcGFuLm9mX2ludF91cyAxMDAgdGhlbiBjeWNsZV90b29rX2xvbmdlcl90aGFuXzEwMHVzIH5jeWNsZV90aW1lXG47O1xuXG5sZXQldGVzdF91bml0IChcIm1heWJlX3JlcG9ydF9sb25nX2FzeW5jX2N5Y2xlc190b19tYWdpY190cmFjZSBkb2Vzbid0IGFsbG9jYXRlXCIgW0B0YWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI2NC1iaXRzLW9ubHlcIl0pXG4gID1cbiAgbGV0IGN5Y2xlX3RpbWUgPSBUaW1lX25zLlNwYW4ub2ZfaW50X3NlYyAxNSBpblxuICBsZXQgd29yZHNfYmVmb3JlID0gR2MubWFqb3JfcGx1c19taW5vcl93b3JkcyAoKSBpblxuICBtYXliZV9yZXBvcnRfbG9uZ19hc3luY19jeWNsZXNfdG9fbWFnaWNfdHJhY2UgfmN5Y2xlX3RpbWU7XG4gIGxldCB3b3Jkc19hZnRlciA9IEdjLm1ham9yX3BsdXNfbWlub3Jfd29yZHMgKCkgaW5cbiAgWyV0ZXN0X3Jlc3VsdDogaW50XSAod29yZHNfYWZ0ZXIgLSB3b3Jkc19iZWZvcmUpIH5leHBlY3Q6MFxuOztcblxubGV0W0BpbmxpbmVdIG1heWJlX3JlcG9ydF9sb25nX2FzeW5jX2N5Y2xlc190b19tYWdpY190cmFjZSB0IDogdW5pdCA9XG4gIG1heWJlX3JlcG9ydF9sb25nX2FzeW5jX2N5Y2xlc190b19tYWdpY190cmFjZVxuICAgIH5jeWNsZV90aW1lOnQua2VybmVsX3NjaGVkdWxlci5sYXN0X2N5Y2xlX3RpbWVcbjs7XG5cbmxldCBjcmVhdGVcbiAgfm11dGV4XG4gID8odGhyZWFkX3Bvb2xfY3B1X2FmZmluaXR5ID0gQ29uZmlnLnRocmVhZF9wb29sX2NwdV9hZmZpbml0eSlcbiAgPyhmaWxlX2Rlc2NyX3dhdGNoZXIgPSBXaGljaF93YXRjaGVyLkNvbmZpZyBDb25maWcuZmlsZV9kZXNjcl93YXRjaGVyKVxuICA/KG1heF9udW1fb3Blbl9maWxlX2Rlc2NycyA9IENvbmZpZy5tYXhfbnVtX29wZW5fZmlsZV9kZXNjcnMpXG4gID8obWF4X251bV90aHJlYWRzID0gQ29uZmlnLm1heF9udW1fdGhyZWFkcylcbiAgKClcbiAgPVxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJjcmVhdGluZyBzY2hlZHVsZXJcIjtcbiAgbGV0IHRocmVhZF9wb29sID1cbiAgICBva19leG5cbiAgICAgIChUaHJlYWRfcG9vbC5jcmVhdGVcbiAgICAgICAgICgpXG4gICAgICAgICB+Y3B1X2FmZmluaXR5OnRocmVhZF9wb29sX2NwdV9hZmZpbml0eVxuICAgICAgICAgfm1heF9udW1fdGhyZWFkczooTWF4X251bV90aHJlYWRzLnJhdyBtYXhfbnVtX3RocmVhZHMpKVxuICBpblxuICBsZXQgbnVtX2ZpbGVfZGVzY3JzID0gTWF4X251bV9vcGVuX2ZpbGVfZGVzY3JzLnJhdyBtYXhfbnVtX29wZW5fZmlsZV9kZXNjcnMgaW5cbiAgbGV0IGZkX2J5X2Rlc2NyID0gQnlfZGVzY3IuY3JlYXRlIH5udW1fZmlsZV9kZXNjcnMgaW5cbiAgbGV0IGNyZWF0ZV9mZCBraW5kIGZpbGVfZGVzY3IgaW5mbyA9XG4gICAgbGV0IGZkID0gRmQuY3JlYXRlIGtpbmQgZmlsZV9kZXNjciBpbmZvIGluXG4gICAgb2tfZXhuIChCeV9kZXNjci5hZGQgZmRfYnlfZGVzY3IgZmQuRmQuZmlsZV9kZXNjciBmZCk7XG4gICAgZmRcbiAgaW5cbiAgbGV0IGV4dGVybmFsX2ZkX2J5X2Rlc2NyID0gQnlfZGVzY3IuY3JlYXRlIH5udW1fZmlsZV9kZXNjcnMgaW5cbiAgbGV0IGludGVycnVwdG9yID0gSW50ZXJydXB0b3IuY3JlYXRlIH5jcmVhdGVfZmQgaW5cbiAgbGV0IHRfcmVmID0gcmVmIE5vbmUgaW5cbiAgKCogc2V0IGJlbG93LCBhZnRlciBbdF0gaXMgZGVmaW5lZCAqKVxuICBsZXQgaGFuZGxlX2ZkIHJlYWRfb3Jfd3JpdGUgcmVhZHlfb3JfYmFkX2ZkIGZpbGVfZGVzY3IgPVxuICAgIG1hdGNoICF0X3JlZiB3aXRoXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgU29tZSB0IC0+IHBvc3RfY2hlY2tfaGFuZGxlX2ZkIHQgZmlsZV9kZXNjciByZWFkX29yX3dyaXRlIHJlYWR5X29yX2JhZF9mZFxuICBpblxuICBsZXQgaGFuZGxlX2ZkX3JlYWRfcmVhZHkgPSBoYW5kbGVfZmQgYFJlYWQgYFJlYWR5IGluXG4gIGxldCBoYW5kbGVfZmRfcmVhZF9iYWQgPSBoYW5kbGVfZmQgYFJlYWQgYEJhZF9mZCBpblxuICBsZXQgaGFuZGxlX2ZkX3dyaXRlX3JlYWR5ID0gaGFuZGxlX2ZkIGBXcml0ZSBgUmVhZHkgaW5cbiAgbGV0IGhhbmRsZV9mZF93cml0ZV9iYWQgPSBoYW5kbGVfZmQgYFdyaXRlIGBCYWRfZmQgaW5cbiAgbGV0IGZpbGVfZGVzY3Jfd2F0Y2hlciwgdGltZXJmZCwgdXJpbmcgPVxuICAgIG1hdGNoIGZpbGVfZGVzY3Jfd2F0Y2hlciB3aXRoXG4gICAgfCBDdXN0b20gKG1vZHVsZSBDdXN0b20pIC0+XG4gICAgICBsZXQgd2F0Y2hlciA9XG4gICAgICAgIEN1c3RvbS5jcmVhdGVcbiAgICAgICAgICB+bnVtX2ZpbGVfZGVzY3JzXG4gICAgICAgICAgfmhhbmRsZV9mZF9yZWFkX3JlYWR5XG4gICAgICAgICAgfmhhbmRsZV9mZF9yZWFkX2JhZFxuICAgICAgICAgIH5oYW5kbGVfZmRfd3JpdGVfcmVhZHlcbiAgICAgICAgICB+aGFuZGxlX2ZkX3dyaXRlX2JhZFxuICAgICAgaW5cbiAgICAgIGxldCBtb2R1bGUgVyA9IHN0cnVjdFxuICAgICAgICBpbmNsdWRlIEN1c3RvbVxuXG4gICAgICAgIGxldCB3YXRjaGVyID0gd2F0Y2hlclxuICAgICAgZW5kXG4gICAgICBpblxuICAgICAgKG1vZHVsZSBXIDogRmlsZV9kZXNjcl93YXRjaGVyLlMpLCBOb25lLCBOb25lXG4gICAgfCBDb25maWcgU2VsZWN0IC0+XG4gICAgICBsZXQgd2F0Y2hlciA9XG4gICAgICAgIFNlbGVjdF9maWxlX2Rlc2NyX3dhdGNoZXIuY3JlYXRlXG4gICAgICAgICAgfm51bV9maWxlX2Rlc2Nyc1xuICAgICAgICAgIH5oYW5kbGVfZmRfcmVhZF9yZWFkeVxuICAgICAgICAgIH5oYW5kbGVfZmRfcmVhZF9iYWRcbiAgICAgICAgICB+aGFuZGxlX2ZkX3dyaXRlX3JlYWR5XG4gICAgICAgICAgfmhhbmRsZV9mZF93cml0ZV9iYWRcbiAgICAgIGluXG4gICAgICBsZXQgbW9kdWxlIFcgPSBzdHJ1Y3RcbiAgICAgICAgaW5jbHVkZSBTZWxlY3RfZmlsZV9kZXNjcl93YXRjaGVyXG5cbiAgICAgICAgbGV0IHdhdGNoZXIgPSB3YXRjaGVyXG4gICAgICBlbmRcbiAgICAgIGluXG4gICAgICAobW9kdWxlIFcgOiBGaWxlX2Rlc2NyX3dhdGNoZXIuUyksIE5vbmUsIE5vbmVcbiAgICB8IENvbmZpZyAoRXBvbGwgfCBFcG9sbF9pZl90aW1lcmZkKSAtPlxuICAgICAgbGV0IHRpbWVyZmQgPVxuICAgICAgICBtYXRjaCB0cnlfY3JlYXRlX3RpbWVyZmQgKCkgd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICByYWlzZV9zXG4gICAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgICAge3xBc3luYyByZWZ1c2VzIHRvIHJ1biB1c2luZyBlcG9sbCBvbiBhIHN5c3RlbSB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCB0aW1lciBGRHMsIHNpbmNlXG5Bc3luYyB3aWxsIGJlIHVuYWJsZSB0byB0aW1lb3V0IHdpdGggc3ViLW1pbGxpc2Vjb25kIHByZWNpc2lvbi58fV1cbiAgICAgICAgfCBTb21lIHRpbWVyZmQgLT4gdGltZXJmZFxuICAgICAgaW5cbiAgICAgIGxldCB3YXRjaGVyID1cbiAgICAgICAgRXBvbGxfZmlsZV9kZXNjcl93YXRjaGVyLmNyZWF0ZVxuICAgICAgICAgIH5udW1fZmlsZV9kZXNjcnNcbiAgICAgICAgICB+dGltZXJmZFxuICAgICAgICAgIH5oYW5kbGVfZmRfcmVhZF9yZWFkeVxuICAgICAgICAgIH5oYW5kbGVfZmRfd3JpdGVfcmVhZHlcbiAgICAgIGluXG4gICAgICBsZXQgbW9kdWxlIFcgPSBzdHJ1Y3RcbiAgICAgICAgaW5jbHVkZSBFcG9sbF9maWxlX2Rlc2NyX3dhdGNoZXJcblxuICAgICAgICBsZXQgd2F0Y2hlciA9IHdhdGNoZXJcbiAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIChtb2R1bGUgVyA6IEZpbGVfZGVzY3Jfd2F0Y2hlci5TKSwgU29tZSB0aW1lcmZkLCBOb25lXG4gICAgfCBDb25maWcgSW9fdXJpbmcgLT5cbiAgICAgIGxldCB1cmluZyA9XG4gICAgICAgIElvX3VyaW5nX3Jhdy5jcmVhdGVcbiAgICAgICAgICB+cXVldWVfZGVwdGg6XG4gICAgICAgICAgICAoSW9fdXJpbmdfbWF4X3N1Ym1pc3Npb25fZW50cmllcy5yYXcgQ29uZmlnLmlvX3VyaW5nX21heF9zdWJtaXNzaW9uX2VudHJpZXMpXG4gICAgICAgICAgKClcbiAgICAgICAgfD4gT3JfZXJyb3Iub2tfZXhuXG4gICAgICBpblxuICAgICAgbGV0IHdhdGNoZXIgPVxuICAgICAgICBJb191cmluZ19maWxlX2Rlc2NyX3dhdGNoZXIuY3JlYXRlXG4gICAgICAgICAgfnVyaW5nXG4gICAgICAgICAgfm51bV9maWxlX2Rlc2Nyc1xuICAgICAgICAgIH5oYW5kbGVfZmRfcmVhZF9yZWFkeVxuICAgICAgICAgIH5oYW5kbGVfZmRfd3JpdGVfcmVhZHlcbiAgICAgIGluXG4gICAgICBsZXQgbW9kdWxlIFcgPSBzdHJ1Y3RcbiAgICAgICAgaW5jbHVkZSBJb191cmluZ19maWxlX2Rlc2NyX3dhdGNoZXJcblxuICAgICAgICBsZXQgd2F0Y2hlciA9IHdhdGNoZXJcbiAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIChtb2R1bGUgVyA6IEZpbGVfZGVzY3Jfd2F0Y2hlci5TKSwgTm9uZSwgU29tZSB1cmluZ1xuICBpblxuICBsZXQgZG5zX2xvb2t1cF90aHJvdHRsZSA9XG4gICAgbGV0IG1heF9jb25jdXJyZW50X2Ruc19sb29rdXBzID1cbiAgICAgIEludC5tYXggKFRocmVhZF9wb29sLm1heF9udW1fdGhyZWFkcyB0aHJlYWRfcG9vbCAvIDIpIDFcbiAgICBpblxuICAgIFRocm90dGxlLmNyZWF0ZVxuICAgICAgfmNvbnRpbnVlX29uX2Vycm9yOnRydWVcbiAgICAgIH5tYXhfY29uY3VycmVudF9qb2JzOm1heF9jb25jdXJyZW50X2Ruc19sb29rdXBzXG4gIGluXG4gIGxldCBrZXJuZWxfc2NoZWR1bGVyID0gS2VybmVsX3NjaGVkdWxlci50ICgpIGluXG4gIGxldCB0ID1cbiAgICB7IG11dGV4XG4gICAgOyBzdGFydF90eXBlID0gTm90X3N0YXJ0ZWRcbiAgICA7IGZkc193aG9zZV93YXRjaGluZ19oYXNfY2hhbmdlZCA9IFN0YWNrLmNyZWF0ZSAoKVxuICAgIDsgZmlsZV9kZXNjcl93YXRjaGVyXG4gICAgOyBidXN5X3BvbGxlcnMgPSBVbmlmb3JtX2FycmF5LmNyZWF0ZSB+bGVuOjI1NiBCdXN5X3BvbGxlci5lbXB0eVxuICAgIDsgbnVtX2J1c3lfcG9sbGVycyA9IDBcbiAgICA7IHRpbWVfc3BlbnRfd2FpdGluZ19mb3JfaW8gPSBUc2MuU3Bhbi5vZl9pbnRfZXhuIDBcbiAgICA7IGZkX2J5X2Rlc2NyXG4gICAgOyBleHRlcm5hbF9mZF9ieV9kZXNjclxuICAgIDsgZXh0ZXJuYWxfZmRfZXZlbnRzID0gW11cbiAgICA7IHRpbWVyZmRcbiAgICA7IHRpbWVyZmRfc2V0X2F0ID0gVGltZV9ucy5tYXhfdmFsdWVfZm9yXzF1c19yb3VuZGluZ1xuICAgIDsgc2NoZWR1bGVyX3RocmVhZF9pZCA9IC0xICgqIHNldCB3aGVuIFtiZV90aGVfc2NoZWR1bGVyXSBpcyBjYWxsZWQgKilcbiAgICA7IGludGVycnVwdG9yXG4gICAgOyBzaWduYWxfbWFuYWdlciA9XG4gICAgICAgIFNpZ25hbF9tYW5hZ2VyLmNyZWF0ZSB+dGhyZWFkX3NhZmVfbm90aWZ5X3NpZ25hbF9kZWxpdmVyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIEludGVycnVwdG9yLnRocmVhZF9zYWZlX2ludGVycnVwdCBpbnRlcnJ1cHRvcilcbiAgICA7IHRocmVhZF9wb29sXG4gICAgOyBoYW5kbGVfdGhyZWFkX3Bvb2xfc3R1Y2sgPSBkZWZhdWx0X2hhbmRsZV90aHJlYWRfcG9vbF9zdHVja1xuICAgIDsgdGhyZWFkX3Bvb2xfc3R1Y2sgPSBOb191bnN0YXJ0ZWRfd29ya1xuICAgIDsgZG5zX2xvb2t1cF90aHJvdHRsZVxuICAgIDsgbmV4dF90c2NfY2FsaWJyYXRpb24gPSBUc2Mubm93ICgpXG4gICAgOyBrZXJuZWxfc2NoZWR1bGVyXG4gICAgOyBoYXZlX2xvY2tfZG9fY3ljbGUgPSBOb25lXG4gICAgOyBtYXhfaW50ZXJfY3ljbGVfdGltZW91dCA9IENvbmZpZy5tYXhfaW50ZXJfY3ljbGVfdGltZW91dFxuICAgIDsgbWluX2ludGVyX2N5Y2xlX3RpbWVvdXQgPSBDb25maWcubWluX2ludGVyX2N5Y2xlX3RpbWVvdXRcbiAgICA7IGluaXRpYWxpemVkX2F0ID0gQmFja3RyYWNlLmdldCAoKVxuICAgIDsgdXJpbmdcbiAgICB9XG4gIGluXG4gIHRfcmVmIDo9IFNvbWUgdDtcbiAgdXBkYXRlX2NoZWNrX2FjY2VzcyB0IENvbmZpZy5kZXRlY3RfaW52YWxpZF9hY2Nlc3NfZnJvbV90aHJlYWQ7XG4gIExpc3QuaXRlciAoTGlzdC5yZXYgIWZkc19jcmVhdGVkX2JlZm9yZV9pbml0aWFsaXphdGlvbikgfmY6KGNyZWF0ZV9mZF9yZWdpc3RyYXRpb24gdCk7XG4gIGZkc19jcmVhdGVkX2JlZm9yZV9pbml0aWFsaXphdGlvbiA6PSBbXTtcbiAgdFxuOztcblxubGV0IGluaXQgfnRha2VfdGhlX2xvY2sgPVxuICBsZXQgbXV0ZXggPSBOYW5vX211dGV4LmNyZWF0ZSAoKSBpblxuICBpZiB0YWtlX3RoZV9sb2NrXG4gIHRoZW5cbiAgICAoKiBXZSBjcmVhdGUgYSBtdXRleCB0aGF0J3MgaW5pdGlhbGx5IGxvY2tlZCBieSB0aGUgbWFpbiB0aHJlYWQgdG8gc3VwcG9ydCB0aGVcbiAgICAgICBjYXNlIHdoZW4gdGhlIHVzZXIgZG9lcyBhc3luYyBzdHVmZiBhdCB0aGUgdG9wIGxldmVsIGJlZm9yZSBjYWxsaW5nXG4gICAgICAgW1NjaGVkdWxlci5nb10uICBUaGlzIGxvY2sgbWFrZXMgc3VyZSB0aGF0IGFzeW5jIGpvYnMgZG9uJ3QgcnVuIHVudGlsXG4gICAgICAgW1NjaGVkdWxlci5nb10gaXMgY2FsbGVkLiAgVGhhdCBjb3VsZCBoYXBwZW4sIGUuZy4gYnkgY3JlYXRpbmcgYSByZWFkZXIgdGhhdFxuICAgICAgIGRvZXMgYSByZWFkIHN5c3RlbSBjYWxsIGluIGFub3RoZXIgKHRydWUpIHRocmVhZC4gIFRoZSBzY2hlZHVsZXIgcmVtYWluc1xuICAgICAgIGxvY2tlZCB1bnRpbCB0aGUgc2NoZWR1bGVyIHVubG9ja3MgaXQuICopXG4gICAgTmFub19tdXRleC5sb2NrX2V4biBtdXRleDtcbiAgdGhlX29uZV9hbmRfb25seV9yZWYgOj0gUmVhZHlfdG9faW5pdGlhbGl6ZSAoZnVuICgpIC0+IGNyZWF0ZSB+bXV0ZXggKCkpXG47O1xuXG5sZXQgKCkgPSBpbml0IH50YWtlX3RoZV9sb2NrOnRydWVcblxubGV0IHJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzIH50YWtlX3RoZV9sb2NrID1cbiAgKG1hdGNoICF0aGVfb25lX2FuZF9vbmx5X3JlZiB3aXRoXG4gICB8IE5vdF9yZWFkeV90b19pbml0aWFsaXplICgpIHwgUmVhZHlfdG9faW5pdGlhbGl6ZSBfIC0+ICgpXG4gICB8IEluaXRpYWxpemVkIHsgZmlsZV9kZXNjcl93YXRjaGVyOyB0aW1lcmZkOyBfIH0gLT5cbiAgICAgbGV0IG1vZHVsZSBGID0gKHZhbCBmaWxlX2Rlc2NyX3dhdGNoZXIgOiBGaWxlX2Rlc2NyX3dhdGNoZXIuUykgaW5cbiAgICAgRi5yZXNldF9pbl9mb3JrZWRfcHJvY2VzcyBGLndhdGNoZXI7XG4gICAgIChtYXRjaCB0aW1lcmZkIHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIHRmZCAtPiBVbml4LmNsb3NlICh0ZmQgOj4gVW5peC5GaWxlX2Rlc2NyLnQpKSk7XG4gIEtlcm5lbF9zY2hlZHVsZXIucmVzZXRfaW5fZm9ya2VkX3Byb2Nlc3MgKCk7XG4gIGZkc19jcmVhdGVkX2JlZm9yZV9pbml0aWFsaXphdGlvbiA6PSBbXTtcbiAgaW5pdCB+dGFrZV90aGVfbG9ja1xuOztcblxubGV0IHJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzX3dpdGhvdXRfdGFraW5nX2xvY2sgKCkgPVxuICByZXNldF9pbl9mb3JrZWRfcHJvY2VzcyB+dGFrZV90aGVfbG9jazpmYWxzZVxuOztcblxubGV0IHJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzICgpID0gcmVzZXRfaW5fZm9ya2VkX3Byb2Nlc3MgfnRha2VfdGhlX2xvY2s6dHJ1ZVxuXG5sZXQgbWFrZV9hc3luY191bnVzYWJsZSAoKSA9XG4gIHJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzICgpO1xuICBLZXJuZWxfc2NoZWR1bGVyLm1ha2VfYXN5bmNfdW51c2FibGUgKCk7XG4gIHRoZV9vbmVfYW5kX29ubHlfcmVmXG4gICAgOj0gUmVhZHlfdG9faW5pdGlhbGl6ZVxuICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICByYWlzZV9zIFslc2V4cCBcIkFzeW5jIGlzIHVudXNhYmxlIGR1ZSB0byBbU2NoZWR1bGVyLm1ha2VfYXN5bmNfdW51c2FibGVdXCJdKVxuOztcblxubGV0IHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZiA9XG4gIEtlcm5lbF9zY2hlZHVsZXIudGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qb2IgdC5rZXJuZWxfc2NoZWR1bGVyIGZcbjs7XG5cbmxldCBoYXZlX2xvY2tfZG9fY3ljbGUgdCA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwiaGF2ZV9sb2NrX2RvX2N5Y2xlXCIgdCBbJXNleHBfb2Y6IHRdO1xuICBtYXRjaCB0LmhhdmVfbG9ja19kb19jeWNsZSB3aXRoXG4gIHwgU29tZSBmIC0+IGYgKClcbiAgfCBOb25lIC0+XG4gICAgS2VybmVsX3NjaGVkdWxlci5ydW5fY3ljbGUgdC5rZXJuZWxfc2NoZWR1bGVyO1xuICAgIG1heWJlX3JlcG9ydF9sb25nX2FzeW5jX2N5Y2xlc190b19tYWdpY190cmFjZSB0O1xuICAgICgqIElmIHdlIGFyZSBub3QgdGhlIHNjaGVkdWxlciwgd2FrZSBpdCB1cCBzbyBpdCBjYW4gcHJvY2VzcyBhbnkgcmVtYWluaW5nIGpvYnMsIGNsb2NrXG4gICAgICAgZXZlbnRzLCBvciBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLiAqKVxuICAgIGlmIG5vdCAoaV9hbV90aGVfc2NoZWR1bGVyIHQpIHRoZW4gdGhyZWFkX3NhZmVfd2FrZXVwX3NjaGVkdWxlciB0XG47O1xuXG5sZXRbQGNvbGRdIGxvZ19zeW5jX2NoYW5nZWRfZmRzX3RvX2ZpbGVfZGVzY3Jfd2F0Y2hlciB0IGZpbGVfZGVzY3IgZGVzaXJlZCA9XG4gIGxldCBtb2R1bGUgRiA9ICh2YWwgdC5maWxlX2Rlc2NyX3dhdGNoZXIgOiBGaWxlX2Rlc2NyX3dhdGNoZXIuUykgaW5cbiAgRGVidWcubG9nXG4gICAgXCJGaWxlX2Rlc2NyX3dhdGNoZXIuc2V0XCJcbiAgICAoZmlsZV9kZXNjciwgZGVzaXJlZCwgRi53YXRjaGVyKVxuICAgIFslc2V4cF9vZjogRmlsZV9kZXNjci50ICogYm9vbCBSZWFkX3dyaXRlX3BhaXIudCAqIEYudF1cbjs7XG5cbmxldFtAY29sZF0gc3luY19jaGFuZ2VkX2ZkX2ZhaWxlZCB0IGZkIGRlc2lyZWQgZXhuID1cbiAgbGV0IGJ0ID0gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudCAoKSBpblxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcInN5bmNfY2hhbmdlZF9mZHNfdG9fZmlsZV9kZXNjcl93YXRjaGVyIHVuYWJsZSB0byBzZXQgZmRcIlxuICAgICAgICAoZGVzaXJlZCA6IGJvb2wgUmVhZF93cml0ZV9wYWlyLnQpXG4gICAgICAgIChmZCA6IEZkLnQpXG4gICAgICAgIChleG4gOiBleG4pXG4gICAgICAgIChidCA6IEJhY2t0cmFjZS50KVxuICAgICAgICB+c2NoZWR1bGVyOih0IDogdCldXG47O1xuXG5sZXQgc3luY19jaGFuZ2VkX2Zkc190b19maWxlX2Rlc2NyX3dhdGNoZXIgdCA9XG4gICgqIFdlIGVmZmljaWVudGx5IGRvIG5vdGhpbmcgaWYgbm90aGluZyBoYXMgY2hhbmdlZCwgYXZvaWRpbmcgZXZlbiB0aGUgZGVmaW5pdGlvbiBvZlxuICAgICBbbW9kdWxlIEZdLCB3aGljaCBjYW4gaGF2ZSBzb21lIGNvc3QuICopXG4gIGlmIG5vdCAoU3RhY2suaXNfZW1wdHkgdC5mZHNfd2hvc2Vfd2F0Y2hpbmdfaGFzX2NoYW5nZWQpXG4gIHRoZW5cbiAgICBsZXQgbW9kdWxlIEYgPSAodmFsIHQuZmlsZV9kZXNjcl93YXRjaGVyIDogRmlsZV9kZXNjcl93YXRjaGVyLlMpIGluXG4gICAgd2hpbGUgbm90IChTdGFjay5pc19lbXB0eSB0LmZkc193aG9zZV93YXRjaGluZ19oYXNfY2hhbmdlZCkgZG9cbiAgICAgIGxldCBmZCA9IFN0YWNrLnBvcF9leG4gdC5mZHNfd2hvc2Vfd2F0Y2hpbmdfaGFzX2NoYW5nZWQgaW5cbiAgICAgIGZkLndhdGNoaW5nX2hhc19jaGFuZ2VkIDwtIGZhbHNlO1xuICAgICAgbGV0IGRlc2lyZWQgPVxuICAgICAgICBSZWFkX3dyaXRlX3BhaXIubWFwIGZkLndhdGNoaW5nIH5mOihmdW4gd2F0Y2hpbmcgLT5cbiAgICAgICAgICBtYXRjaCB3YXRjaGluZyB3aXRoXG4gICAgICAgICAgfCBXYXRjaF9vbmNlIF8gfCBXYXRjaF9yZXBlYXRlZGx5IF8gLT4gdHJ1ZVxuICAgICAgICAgIHwgTm90X3dhdGNoaW5nIHwgU3RvcF9yZXF1ZXN0ZWQgLT4gZmFsc2UpXG4gICAgICBpblxuICAgICAgaWYgRGVidWcuZmlsZV9kZXNjcl93YXRjaGVyXG4gICAgICB0aGVuIGxvZ19zeW5jX2NoYW5nZWRfZmRzX3RvX2ZpbGVfZGVzY3Jfd2F0Y2hlciB0IGZkLmZpbGVfZGVzY3IgZGVzaXJlZDtcbiAgICAgIG1hdGNoXG4gICAgICAgIHRyeSBGLnNldCBGLndhdGNoZXIgZmQuZmlsZV9kZXNjciBkZXNpcmVkIHdpdGhcbiAgICAgICAgfCBleG4gLT4gc3luY19jaGFuZ2VkX2ZkX2ZhaWxlZCB0IGZkIGRlc2lyZWQgZXhuXG4gICAgICB3aXRoXG4gICAgICB8IGBVbnN1cHBvcnRlZCAtPiBSZWFkX3dyaXRlX3BhaXIuaXRlcmkgZmQud2F0Y2hpbmcgfmY6KGdpdmVfdXBfb25fd2F0Y2hpbmcgdCBmZClcbiAgICAgIHwgYE9rIC0+XG4gICAgICAgICgqIFdlIG1vZGlmeSBBc3luYydzIGRhdGEgc3RydWN0dXJlcyBhZnRlciBjYWxsaW5nIFtGLnNldF0sIHNvIHRoYXRcbiAgICAgICAgICAgdGhlIGVycm9yIG1lc3NhZ2UgcHJvZHVjZWQgYnkgW3N5bmNfY2hhbmdlZF9mZF9mYWlsZWRdIGRpc3BsYXlzXG4gICAgICAgICAgIHRoZW0gYXMgdGhleSB3ZXJlIGJlZm9yZSB0aGUgY2FsbC4gKilcbiAgICAgICAgUmVhZF93cml0ZV9wYWlyLml0ZXJpIGZkLndhdGNoaW5nIH5mOihmdW4gcmVhZF9vcl93cml0ZSB3YXRjaGluZyAtPlxuICAgICAgICAgIG1hdGNoIHdhdGNoaW5nIHdpdGhcbiAgICAgICAgICB8IFdhdGNoX29uY2UgXyB8IFdhdGNoX3JlcGVhdGVkbHkgXyB8IE5vdF93YXRjaGluZyAtPiAoKVxuICAgICAgICAgIHwgU3RvcF9yZXF1ZXN0ZWQgLT5cbiAgICAgICAgICAgIFJlYWRfd3JpdGVfcGFpci5zZXQgZmQud2F0Y2hpbmcgcmVhZF9vcl93cml0ZSBOb3Rfd2F0Y2hpbmc7XG4gICAgICAgICAgICBkZWNfbnVtX2FjdGl2ZV9zeXNjYWxsc19mZCB0IGZkKVxuICAgIGRvbmVcbjs7XG5cbmxldCBtYXliZV9jYWxpYnJhdGVfdHNjIHQgPVxuICBpZiBMYXp5LmlzX3ZhbCBUc2MuY2FsaWJyYXRvclxuICB0aGVuIChcbiAgICBsZXQgbm93ID0gVHNjLm5vdyAoKSBpblxuICAgIGlmIFRzYy4oID49ICkgbm93IHQubmV4dF90c2NfY2FsaWJyYXRpb25cbiAgICB0aGVuIChcbiAgICAgIGxldCBjYWxpYnJhdG9yID0gZm9yY2UgVHNjLmNhbGlicmF0b3IgaW5cbiAgICAgIFRzYy5DYWxpYnJhdG9yLmNhbGlicmF0ZSBjYWxpYnJhdG9yO1xuICAgICAgdC5uZXh0X3RzY19jYWxpYnJhdGlvblxuICAgICAgICA8LSBUc2MuYWRkIG5vdyAoVHNjLlNwYW4ub2ZfbnMgKEludDYzLm9mX2ludCAxXzAwMF8wMDBfMDAwKSB+Y2FsaWJyYXRvcikpKVxuOztcblxubGV0IGNyZWF0ZV9qb2IgP2V4ZWN1dGlvbl9jb250ZXh0IHQgZiB4ID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgICBtYXRjaCBleGVjdXRpb25fY29udGV4dCB3aXRoXG4gICAgfCBTb21lIGUgLT4gZVxuICAgIHwgTm9uZSAtPiBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHRcbiAgaW5cbiAgS2VybmVsX3NjaGVkdWxlci5jcmVhdGVfam9iIHQua2VybmVsX3NjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIHhcbjs7XG5cbmxldCBkdW1wX2NvcmVfb25fam9iX2RlbGF5ICgpID1cbiAgbWF0Y2ggQ29uZmlnLmR1bXBfY29yZV9vbl9qb2JfZGVsYXkgd2l0aFxuICB8IERvX25vdF93YXRjaCAtPiAoKVxuICB8IFdhdGNoIHsgZHVtcF9pZl9kZWxheWVkX2J5OyBob3dfdG9fZHVtcCB9IC0+XG4gICAgRHVtcF9jb3JlX29uX2pvYl9kZWxheS5zdGFydF93YXRjaGluZ1xuICAgICAgfmR1bXBfaWZfZGVsYXllZF9ieTooVGltZV9ucy5TcGFuLnRvX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCBkdW1wX2lmX2RlbGF5ZWRfYnkpXG4gICAgICB+aG93X3RvX2R1bXBcbjs7XG5cbmxldCBudW1fYnVzeV9wb2xsZXJzIHQgPSB0Lm51bV9idXN5X3BvbGxlcnNcblxubGV0IGFkZF9idXN5X3BvbGxlciB0IH5tYXhfYnVzeV93YWl0X2R1cmF0aW9uIGYgPVxuICBpZiB0Lm51bV9idXN5X3BvbGxlcnMgPSBVbmlmb3JtX2FycmF5Lmxlbmd0aCB0LmJ1c3lfcG9sbGVyc1xuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiW2FkZF9idXN5X3BvbGxlcl0gbWF4aW11bSBudW1iZXIgb2YgcG9sbGVycyBleGNlZWRlZFwiXTtcbiAgVW5pZm9ybV9hcnJheS5zZXQgdC5idXN5X3BvbGxlcnMgdC5udW1fYnVzeV9wb2xsZXJzIGY7XG4gIHQubnVtX2J1c3lfcG9sbGVycyA8LSB0Lm51bV9idXN5X3BvbGxlcnMgKyAxO1xuICB0Lm1heF9pbnRlcl9jeWNsZV90aW1lb3V0XG4gICAgPC0gTWF4X2ludGVyX2N5Y2xlX3RpbWVvdXQuY3JlYXRlX2V4blxuICAgICAgICAgKFRpbWVfbnMuU3Bhbi5taW5cbiAgICAgICAgICAgIChNYXhfaW50ZXJfY3ljbGVfdGltZW91dC5yYXcgdC5tYXhfaW50ZXJfY3ljbGVfdGltZW91dClcbiAgICAgICAgICAgIG1heF9idXN5X3dhaXRfZHVyYXRpb24pXG47O1xuXG5sZXQgaW5pdCB0ID1cbiAgZHVtcF9jb3JlX29uX2pvYl9kZWxheSAoKTtcbiAgS2VybmVsX3NjaGVkdWxlci5zZXRfdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgdC5rZXJuZWxfc2NoZWR1bGVyIChmdW4gKCkgLT5cbiAgICB0aHJlYWRfc2FmZV93YWtldXBfc2NoZWR1bGVyIHQpO1xuICB0LnNjaGVkdWxlcl90aHJlYWRfaWQgPC0gY3VycmVudF90aHJlYWRfaWQgKCk7XG4gICgqIFdlIGhhbmRsZSBbU2lnbmFsLnBpcGVdIHNvIHRoYXQgd3JpdGUoKSBjYWxscyBvbiBhIGNsb3NlZCBwaXBlL3NvY2tldCBnZXQgRVBJUEUgYnV0XG4gICAgIHRoZSBwcm9jZXNzIGRvZXNuJ3QgZGllIGR1ZSB0byBhbiB1bmhhbmRsZWQgU0lHUElQRS4gKilcbiAgU2lnbmFsX21hbmFnZXIubWFuYWdlIHQuc2lnbmFsX21hbmFnZXIgU2lnbmFsLnBpcGU7XG4gIGxldCBpbnRlcnJ1cHRvcl9maW5pc2hlZCA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGxldCBpbnRlcnJ1cHRvcl9yZWFkX2ZkID0gSW50ZXJydXB0b3IucmVhZF9mZCB0LmludGVycnVwdG9yIGluXG4gIGxldCBwcm9ibGVtX3dpdGhfaW50ZXJydXB0b3IgKCkgPVxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcImNhbiBub3Qgd2F0Y2ggaW50ZXJydXB0b3JcIiAoaW50ZXJydXB0b3JfcmVhZF9mZCA6IEZkLnQpIH5zY2hlZHVsZXI6KHQgOiB0KV1cbiAgaW5cbiAgKG1hdGNoXG4gICAgIHJlcXVlc3Rfc3RhcnRfd2F0Y2hpbmdcbiAgICAgICB0XG4gICAgICAgaW50ZXJydXB0b3JfcmVhZF9mZFxuICAgICAgIGBSZWFkXG4gICAgICAgKFdhdGNoX3JlcGVhdGVkbHlcbiAgICAgICAgICAoIEtlcm5lbF9zY2hlZHVsZXIuY3JlYXRlX2pvYlxuICAgICAgICAgICAgICB0Lmtlcm5lbF9zY2hlZHVsZXJcbiAgICAgICAgICAgICAgRXhlY3V0aW9uX2NvbnRleHQubWFpblxuICAgICAgICAgICAgICBGbi5pZ25vcmVcbiAgICAgICAgICAgICAgKClcbiAgICAgICAgICAsIGludGVycnVwdG9yX2ZpbmlzaGVkICkpXG4gICB3aXRoXG4gICB8IGBBbHJlYWR5X3dhdGNoaW5nIHwgYFdhdGNoaW5nIC0+ICgpXG4gICB8IGBVbnN1cHBvcnRlZCB8IGBBbHJlYWR5X2Nsb3NlZCAtPiBwcm9ibGVtX3dpdGhfaW50ZXJydXB0b3IgKCkpO1xuICB1cG9uIChJdmFyLnJlYWQgaW50ZXJydXB0b3JfZmluaXNoZWQpIChmdW4gXyAtPiBwcm9ibGVtX3dpdGhfaW50ZXJydXB0b3IgKCkpXG47O1xuXG5sZXQgZmRzX21heV9wcm9kdWNlX2V2ZW50cyB0ID1cbiAgbGV0IGludGVycnVwdG9yX2ZkID0gSW50ZXJydXB0b3IucmVhZF9mZCB0LmludGVycnVwdG9yIGluXG4gIEJ5X2Rlc2NyLmV4aXN0cyB0LmZkX2J5X2Rlc2NyIH5mOihmdW4gZmQgLT5cbiAgICAoKiBKb2JzIGNyZWF0ZWQgYnkgdGhlIGludGVycnVwdG9yIGRvbid0IGRvIGFueXRoaW5nLCBzbyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgY291bnQgdGhlbSBhcyBzb21ldGhpbmcgdGhhdCBjYW4gZHJpdmUgcHJvZ3Jlc3MuIFdoZW4gaW50ZXJydXB0b3IgaXMgaW52b2x2ZWQsIHRoZVxuICAgICAgIHByb2dyZXNzIGlzIGRyaXZlbiBieSBvdGhlciBtb2R1bGVzIChlLmcuIHRoZSB0aHJlYWRfcG9vbCkuXG4gICAgICAgVGhlIGNhbGxlciBzaG91bGQgaW5zcGVjdCB0aG9zZSBkaXJlY3RseS5cblxuICAgICAgIFdlIGRvbid0IG5lZWQgYSBzaW1pbGFyIHNwZWNpYWwtY2FzZSBmb3IgW3RpbWVyZmRdIGJlY2F1c2UgdGhhdCdzIG5ldmVyIGFkZGVkXG4gICAgICAgdG8gW2ZkX2J5X2Rlc2NyXSwgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgICopXG4gICAgKG5vdCAoRmQuZXF1YWwgZmQgaW50ZXJydXB0b3JfZmQpKVxuICAgICYmIFJlYWRfd3JpdGVfcGFpci5leGlzdHMgKEZkLndhdGNoaW5nIGZkKSB+ZjooZnVuIHdhdGNoaW5nIC0+XG4gICAgICAgICBtYXRjaCAod2F0Y2hpbmcgOiBGZC5XYXRjaGluZy50KSB3aXRoXG4gICAgICAgICB8IE5vdF93YXRjaGluZyAtPiBmYWxzZVxuICAgICAgICAgKCogU3RvcF9yZXF1ZXN0ZWQgd2lsbCBlbnF1ZXVlIGEgc2luZ2xlIGpvYiwgc28gd2UgaGF2ZSBqb2JzIHRvIGRvIHN0aWxsIGF0IHRoaXMgcG9pbnQuICopXG4gICAgICAgICB8IFdhdGNoX29uY2UgXyB8IFdhdGNoX3JlcGVhdGVkbHkgXyB8IFN0b3BfcmVxdWVzdGVkIC0+IHRydWUpKVxuOztcblxuKCogV2UgYXZvaWQgYWxsb2NhdGlvbiBpbiBbY2hlY2tfZmlsZV9kZXNjcl93YXRjaGVyXSwgc2luY2UgaXQgaXMgY2FsbGVkIGV2ZXJ5IHRpbWUgaW5cbiAgIHRoZSBzY2hlZHVsZXIgbG9vcC4gKilcbmxldCBjaGVja19maWxlX2Rlc2NyX3dhdGNoZXIgdCB+dGltZW91dCBzcGFuX29yX3VuaXQgPVxuICBsZXQgbW9kdWxlIEYgPSAodmFsIHQuZmlsZV9kZXNjcl93YXRjaGVyIDogRmlsZV9kZXNjcl93YXRjaGVyLlMpIGluXG4gIGlmIERlYnVnLmZpbGVfZGVzY3Jfd2F0Y2hlclxuICB0aGVuIERlYnVnLmxvZyBcIkZpbGVfZGVzY3Jfd2F0Y2hlci5wcmVfY2hlY2tcIiB0IFslc2V4cF9vZjogdF07XG4gIGxldCBwcmUgPSBGLnByZV9jaGVjayBGLndhdGNoZXIgaW5cbiAgdW5sb2NrIHQ7XG4gICgqIFdlIHlpZWxkIHNvIHRoYXQgb3RoZXIgT0NhbWwgdGhyZWFkcyAoZXNwZWNpYWxseSB0aHJlYWQtcG9vbCB0aHJlYWRzKSBnZXQgYSBjaGFuY2UgdG9cbiAgICAgcnVuLiAgVGhpcyBpcyBhIGdvb2QgcG9pbnQgdG8geWllbGQsIGJlY2F1c2Ugd2UgZG8gbm90IGhvbGQgdGhlIEFzeW5jIGxvY2ssIHdoaWNoXG4gICAgIGFsbG93cyBvdGhlciB0aHJlYWRzIHRvIGFjcXVpcmUgaXQuICBbVGhyZWFkLnlpZWxkXSBvbmx5IHlpZWxkcyBpZiBvdGhlciBPQ2FtbFxuICAgICB0aHJlYWRzIGFyZSB3YWl0aW5nIHRvIGFjcXVpcmUgdGhlIE9DYW1sIGxvY2ssIGFuZCBpcyBmYXN0IGlmIG5vdC4gIEFzIG9mIE9DYW1sIDQuMDcsXG4gICAgIFtUaHJlYWQueWllbGRdIG9uIExpbnV4IGNhbGxzIFtuYW5vc2xlZXBdLCB3aGljaCBjYXVzZXMgdGhlIExpbnV4IHNjaGVkdWxlciB0b1xuICAgICBhY3R1YWxseSBzd2l0Y2ggdG8gb3RoZXIgdGhyZWFkcy4gKilcbiAgVGhyZWFkLnlpZWxkICgpO1xuICBpZiBEZWJ1Zy5maWxlX2Rlc2NyX3dhdGNoZXJcbiAgdGhlblxuICAgIERlYnVnLmxvZ1xuICAgICAgXCJGaWxlX2Rlc2NyX3dhdGNoZXIudGhyZWFkX3NhZmVfY2hlY2tcIlxuICAgICAgKEZpbGVfZGVzY3Jfd2F0Y2hlcl9pbnRmLlRpbWVvdXQudmFyaWFudF9vZiB0aW1lb3V0IHNwYW5fb3JfdW5pdCwgdClcbiAgICAgIFslc2V4cF9vZjogWyBgSW1tZWRpYXRlbHkgfCBgQWZ0ZXIgb2YgVGltZV9ucy5TcGFuLnQgXSAqIHRdO1xuICBsZXQgYmVmb3JlID0gVHNjLm5vdyAoKSBpblxuICBsZXQgY2hlY2tfcmVzdWx0ID0gRi50aHJlYWRfc2FmZV9jaGVjayBGLndhdGNoZXIgcHJlIHRpbWVvdXQgc3Bhbl9vcl91bml0IGluXG4gIGxldCBhZnRlciA9IFRzYy5ub3cgKCkgaW5cbiAgdC50aW1lX3NwZW50X3dhaXRpbmdfZm9yX2lvXG4gICAgPC0gVHNjLlNwYW4uKCArICkgdC50aW1lX3NwZW50X3dhaXRpbmdfZm9yX2lvIChUc2MuZGlmZiBhZnRlciBiZWZvcmUpO1xuICBsb2NrIHQ7XG4gICgqIFdlIGNhbGwgW0ludGVycnVwdG9yLmNsZWFyXSBhZnRlciBbdGhyZWFkX3NhZmVfY2hlY2tdIGFuZCBiZWZvcmUgYW55IG9mIHRoZVxuICAgICBwcm9jZXNzaW5nIHRoYXQgbmVlZHMgdG8gaGFwcGVuIGluIHJlc3BvbnNlIHRvIFt0aHJlYWRfc2FmZV9pbnRlcnJ1cHRdLiAgVGhhdFxuICAgICB3YXksIGV2ZW4gaWYgW0ludGVycnVwdG9yLmNsZWFyXSBjbGVhcnMgb3V0IGFuIGludGVycnVwdCB0aGF0IGhhc24ndCBiZWVuXG4gICAgIHNlcnZpY2VkIHlldCwgdGhlIGludGVycnVwdCB3aWxsIHN0aWxsIGJlIHNlcnZpY2VkIGJ5IHRoZSBpbW1lZGlhdGVseSBmb2xsb3dpbmdcbiAgICAgcHJvY2Vzc2luZy4gKilcbiAgSW50ZXJydXB0b3IuY2xlYXIgdC5pbnRlcnJ1cHRvcjtcbiAgaWYgRGVidWcuZmlsZV9kZXNjcl93YXRjaGVyXG4gIHRoZW5cbiAgICBEZWJ1Zy5sb2dcbiAgICAgIFwiRmlsZV9kZXNjcl93YXRjaGVyLnBvc3RfY2hlY2tcIlxuICAgICAgKGNoZWNrX3Jlc3VsdCwgdClcbiAgICAgIFslc2V4cF9vZjogRi5DaGVja19yZXN1bHQudCAqIHRdO1xuICBGLnBvc3RfY2hlY2sgRi53YXRjaGVyIGNoZWNrX3Jlc3VsdFxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBydW5fYnVzeV9wb2xsZXJzX29uY2UgdCB+ZGVhZGxpbmUgPVxuICBsZXQgZGlkX3dvcmsgPSByZWYgZmFsc2UgaW5cbiAgKHRyeVxuICAgICBmb3IgaSA9IDAgdG8gdC5udW1fYnVzeV9wb2xsZXJzIC0gMSBkb1xuICAgICAgIGxldCBwb2xsZXIgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdC5idXN5X3BvbGxlcnMgaSBpblxuICAgICAgIGlmIEJ1c3lfcG9sbGVyLnBvbGwgcG9sbGVyIH5kZWFkbGluZSA+IDAgdGhlbiBkaWRfd29yayA6PSB0cnVlXG4gICAgIGRvbmVcbiAgIHdpdGhcbiAgIHwgZXhuIC0+IE1vbml0b3Iuc2VuZF9leG4gTW9uaXRvci5tYWluIGV4bik7XG4gICFkaWRfd29ya1xuOztcblxubGV0IHJ1bl9idXN5X3BvbGxlcnMgdCB+dGltZW91dCA9XG4gIGxldCBjYWxpYnJhdG9yID0gZm9yY2UgVHNjLmNhbGlicmF0b3IgaW5cbiAgbGV0IGRlYWRsaW5lID1cbiAgICByZWYgKFRzYy5hZGQgKFRzYy5ub3cgKCkpIChUc2MuU3Bhbi5vZl90aW1lX25zX3NwYW4gdGltZW91dCB+Y2FsaWJyYXRvcikpXG4gIGluXG4gIHdoaWxlXG4gICAgbGV0IHBvbGxlcnNfZGlkX3NvbWV0aGluZyA9IHJ1bl9idXN5X3BvbGxlcnNfb25jZSB0IH5kZWFkbGluZTohZGVhZGxpbmUgaW5cbiAgICBsZXQgbm93ID0gVHNjLm5vdyAoKSBpblxuICAgIGlmIHBvbGxlcnNfZGlkX3NvbWV0aGluZ1xuICAgIHRoZW5cbiAgICAgIGlmIEtlcm5lbF9zY2hlZHVsZXIuY2FuX3J1bl9hX2pvYiB0Lmtlcm5lbF9zY2hlZHVsZXJcbiAgICAgIHRoZW4gZGVhZGxpbmUgOj0gbm93XG4gICAgICBlbHNlIGlmIEtlcm5lbF9zY2hlZHVsZXIuaGFzX3VwY29taW5nX2V2ZW50IHQua2VybmVsX3NjaGVkdWxlclxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBuZXdfdGltZW91dCA9XG4gICAgICAgICAgVGltZV9ucy5kaWZmXG4gICAgICAgICAgICAoS2VybmVsX3NjaGVkdWxlci5uZXh0X3VwY29taW5nX2V2ZW50X2V4biB0Lmtlcm5lbF9zY2hlZHVsZXIpXG4gICAgICAgICAgICAoVHNjLnRvX3RpbWVfbnMgbm93IH5jYWxpYnJhdG9yKVxuICAgICAgICAgIHw+IFRzYy5TcGFuLm9mX3RpbWVfbnNfc3BhbiB+Y2FsaWJyYXRvclxuICAgICAgICBpblxuICAgICAgICBkZWFkbGluZSA6PSBUc2MubWluICFkZWFkbGluZSAoVHNjLmFkZCBub3cgbmV3X3RpbWVvdXQpKTtcbiAgICBUc2MuKCA8ICkgbm93ICFkZWFkbGluZVxuICBkb1xuICAgICgpXG4gIGRvbmVcbjs7XG5cbigqIFdlIGNvbXB1dGUgdGhlIHRpbWVvdXQgYXMgdGhlIGxhc3QgdGhpbmcgYmVmb3JlIFtjaGVja19maWxlX2Rlc2NyX3dhdGNoZXJdLCBiZWNhdXNlXG4gICB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGUgdGltZW91dCBpcyB6ZXJvIGlmIHRoZXJlIGFyZSBhbnkgc2NoZWR1bGVkIGpvYnMuICBUaGUgY29kZVxuICAgaXMgc3RydWN0dXJlZCB0byBhdm9pZCBjYWxsaW5nIFtUaW1lX25zLm5vd10gYW5kIFtMaW51eF9leHQuVGltZXJmZC5zZXRfKl0gaWZcbiAgIHBvc3NpYmxlLiAgSW4gcGFydGljdWxhciwgd2Ugb25seSBjYWxsIFtUaW1lX25zLm5vd10gaWYgd2UgbmVlZCB0byBjb21wdXRlIHRoZVxuICAgdGltZW91dC1hZnRlciBzcGFuLiAgQW5kIHdlIG9ubHkgY2FsbCBbTGludXhfZXh0LlRpbWVyZmQuc2V0X2FmdGVyXSBpZiB0aGUgdGltZSB0aGF0XG4gICB3ZSB3YW50IGl0IHRvIGZpcmUgaXMgZGlmZmVyZW50IHRoYW4gdGhlIHRpbWUgaXQgaXMgYWxyZWFkeSBzZXQgdG8gZmlyZS4gKilcbmxldCBjb21wdXRlX3RpbWVvdXRfYW5kX2NoZWNrX2ZpbGVfZGVzY3Jfd2F0Y2hlciB0ID1cbiAgbGV0IG1pbl9pbnRlcl9jeWNsZV90aW1lb3V0ID0gKHQubWluX2ludGVyX2N5Y2xlX3RpbWVvdXQgOj4gVGltZV9ucy5TcGFuLnQpIGluXG4gIGxldCBtYXhfaW50ZXJfY3ljbGVfdGltZW91dCA9ICh0Lm1heF9pbnRlcl9jeWNsZV90aW1lb3V0IDo+IFRpbWVfbnMuU3Bhbi50KSBpblxuICBsZXQgaGF2ZV9idXN5X3BvbGxlcnMgPSB0Lm51bV9idXN5X3BvbGxlcnMgPiAwIGluXG4gIGxldCBmaWxlX2Rlc2NyX3dhdGNoZXJfdGltZW91dCA9XG4gICAgbWF0Y2ggdC50aW1lcmZkLCBoYXZlX2J1c3lfcG9sbGVycyB3aXRoXG4gICAgfCBOb25lLCBfIHwgU29tZSBfLCB0cnVlIC0+XG4gICAgICAoKiBTaW5jZSB0aGVyZSBpcyBubyB0aW1lcmZkLCB1c2UgdGhlIGZpbGUgZGVzY3JpcHRvciB3YXRjaGVyIHRpbWVvdXQuICopXG4gICAgICBpZiBLZXJuZWxfc2NoZWR1bGVyLmNhbl9ydW5fYV9qb2IgdC5rZXJuZWxfc2NoZWR1bGVyXG4gICAgICB0aGVuIG1pbl9pbnRlcl9jeWNsZV90aW1lb3V0XG4gICAgICBlbHNlIGlmIG5vdCAoS2VybmVsX3NjaGVkdWxlci5oYXNfdXBjb21pbmdfZXZlbnQgdC5rZXJuZWxfc2NoZWR1bGVyKVxuICAgICAgdGhlbiBtYXhfaW50ZXJfY3ljbGVfdGltZW91dFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBuZXh0X2V2ZW50X2F0ID0gS2VybmVsX3NjaGVkdWxlci5uZXh0X3VwY29taW5nX2V2ZW50X2V4biB0Lmtlcm5lbF9zY2hlZHVsZXIgaW5cbiAgICAgICAgVGltZV9ucy5TcGFuLm1pblxuICAgICAgICAgIG1heF9pbnRlcl9jeWNsZV90aW1lb3V0XG4gICAgICAgICAgKFRpbWVfbnMuU3Bhbi5tYXhcbiAgICAgICAgICAgICBtaW5faW50ZXJfY3ljbGVfdGltZW91dFxuICAgICAgICAgICAgIChUaW1lX25zLmRpZmYgbmV4dF9ldmVudF9hdCAoVGltZV9ucy5ub3cgKCkpKSkpXG4gICAgfCBTb21lIHRpbWVyZmQsIGZhbHNlIC0+XG4gICAgICAoKiBTZXQgW3RpbWVyZmRdIHRvIGZpcmUgaWYgbmVjZXNzYXJ5LCB0YWtpbmcgaW50byBhY2NvdW50IFtjYW5fcnVuX2Ffam9iXSxcbiAgICAgICAgIFttaW5faW50ZXJfY3ljbGVfdGltZW91dF0sIGFuZCBbbmV4dF9ldmVudF9hdF0uICopXG4gICAgICBsZXQgaGF2ZV9taW5faW50ZXJfY3ljbGVfdGltZW91dCA9XG4gICAgICAgIFRpbWVfbnMuU3Bhbi4oID4gKSBtaW5faW50ZXJfY3ljbGVfdGltZW91dCBUaW1lX25zLlNwYW4uemVyb1xuICAgICAgaW5cbiAgICAgIGlmIEtlcm5lbF9zY2hlZHVsZXIuY2FuX3J1bl9hX2pvYiB0Lmtlcm5lbF9zY2hlZHVsZXJcbiAgICAgIHRoZW5cbiAgICAgICAgaWYgbm90IGhhdmVfbWluX2ludGVyX2N5Y2xlX3RpbWVvdXRcbiAgICAgICAgdGhlbiBUaW1lX25zLlNwYW4uemVyb1xuICAgICAgICBlbHNlIChcbiAgICAgICAgICB0LnRpbWVyZmRfc2V0X2F0IDwtIFRpbWVfbnMubWF4X3ZhbHVlX2Zvcl8xdXNfcm91bmRpbmc7XG4gICAgICAgICAgTGludXhfZXh0LlRpbWVyZmQuc2V0X2FmdGVyIHRpbWVyZmQgbWluX2ludGVyX2N5Y2xlX3RpbWVvdXQ7XG4gICAgICAgICAgbWF4X2ludGVyX2N5Y2xlX3RpbWVvdXQpXG4gICAgICBlbHNlIGlmIG5vdCAoS2VybmVsX3NjaGVkdWxlci5oYXNfdXBjb21pbmdfZXZlbnQgdC5rZXJuZWxfc2NoZWR1bGVyKVxuICAgICAgdGhlbiBtYXhfaW50ZXJfY3ljbGVfdGltZW91dFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBuZXh0X2V2ZW50X2F0ID0gS2VybmVsX3NjaGVkdWxlci5uZXh0X3VwY29taW5nX2V2ZW50X2V4biB0Lmtlcm5lbF9zY2hlZHVsZXIgaW5cbiAgICAgICAgbGV0IHNldF90aW1lcmZkX2F0ID1cbiAgICAgICAgICBpZiBub3QgaGF2ZV9taW5faW50ZXJfY3ljbGVfdGltZW91dFxuICAgICAgICAgIHRoZW4gbmV4dF9ldmVudF9hdFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIFRpbWVfbnMubWF4XG4gICAgICAgICAgICAgIG5leHRfZXZlbnRfYXRcbiAgICAgICAgICAgICAgKFRpbWVfbnMuYWRkIChUaW1lX25zLm5vdyAoKSkgbWluX2ludGVyX2N5Y2xlX3RpbWVvdXQpXG4gICAgICAgIGluXG4gICAgICAgIGlmIG5vdCAoVGltZV9ucy5lcXVhbCB0LnRpbWVyZmRfc2V0X2F0IHNldF90aW1lcmZkX2F0KVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICB0LnRpbWVyZmRfc2V0X2F0IDwtIHNldF90aW1lcmZkX2F0O1xuICAgICAgICAgIExpbnV4X2V4dC5UaW1lcmZkLnNldF9hdCB0aW1lcmZkIHNldF90aW1lcmZkX2F0KTtcbiAgICAgICAgbWF4X2ludGVyX2N5Y2xlX3RpbWVvdXQpXG4gIGluXG4gIGlmIFRpbWVfbnMuU3Bhbi4oIDw9ICkgZmlsZV9kZXNjcl93YXRjaGVyX3RpbWVvdXQgVGltZV9ucy5TcGFuLnplcm9cbiAgdGhlbiAoXG4gICAgaWdub3JlIChydW5fYnVzeV9wb2xsZXJzX29uY2UgdCB+ZGVhZGxpbmU6VHNjLnplcm8gOiBib29sKTtcbiAgICBjaGVja19maWxlX2Rlc2NyX3dhdGNoZXIgdCB+dGltZW91dDpJbW1lZGlhdGVseSAoKSlcbiAgZWxzZSBpZiBoYXZlX2J1c3lfcG9sbGVyc1xuICB0aGVuIChcbiAgICBydW5fYnVzeV9wb2xsZXJzIHQgfnRpbWVvdXQ6ZmlsZV9kZXNjcl93YXRjaGVyX3RpbWVvdXQ7XG4gICAgY2hlY2tfZmlsZV9kZXNjcl93YXRjaGVyIHQgfnRpbWVvdXQ6SW1tZWRpYXRlbHkgKCkpXG4gIGVsc2UgY2hlY2tfZmlsZV9kZXNjcl93YXRjaGVyIHQgfnRpbWVvdXQ6QWZ0ZXIgZmlsZV9kZXNjcl93YXRjaGVyX3RpbWVvdXRcbjs7XG5cbmxldCBvbmVfaXRlciB0ID1cbiAgaWYgS2VybmVsX3NjaGVkdWxlci5jaGVja19pbnZhcmlhbnRzIHQua2VybmVsX3NjaGVkdWxlciB0aGVuIGludmFyaWFudCB0O1xuICBtYXliZV9jYWxpYnJhdGVfdHNjIHQ7XG4gIHN5bmNfY2hhbmdlZF9mZHNfdG9fZmlsZV9kZXNjcl93YXRjaGVyIHQ7XG4gIGNvbXB1dGVfdGltZW91dF9hbmRfY2hlY2tfZmlsZV9kZXNjcl93YXRjaGVyIHQ7XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nX3N0cmluZyBcImhhbmRsaW5nIGRlbGl2ZXJlZCBzaWduYWxzXCI7XG4gIFNpZ25hbF9tYW5hZ2VyLmhhbmRsZV9kZWxpdmVyZWQgdC5zaWduYWxfbWFuYWdlcjtcbiAgaGF2ZV9sb2NrX2RvX2N5Y2xlIHQ7XG4gIEtlcm5lbF9zY2hlZHVsZXIudW5jYXVnaHRfZXhuIHQua2VybmVsX3NjaGVkdWxlclxuOztcblxubGV0IGJlX3RoZV9zY2hlZHVsZXIgPyhyYWlzZV91bmhhbmRsZWRfZXhuID0gZmFsc2UpIHQgPVxuICBpbml0IHQ7XG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgbWF0Y2ggb25lX2l0ZXIgdCB3aXRoXG4gICAgfCBTb21lIGVycm9yIC0+IGVycm9yXG4gICAgfCBOb25lIC0+IGxvb3AgKClcbiAgaW5cbiAgbGV0IGVycm9yX2tpbmQsIGVycm9yID1cbiAgICB0cnkgYFVzZXJfdW5jYXVnaHQsIGxvb3AgKCkgd2l0aFxuICAgIHwgZXhuIC0+XG4gICAgICB1bmxvY2sgdDtcbiAgICAgIGBBc3luY191bmNhdWdodCwgRXJyb3IuY3JlYXRlIFwiYnVnIGluIGFzeW5jIHNjaGVkdWxlclwiIChleG4sIHQpIFslc2V4cF9vZjogZXhuICogdF1cbiAgaW5cbiAgaWYgcmFpc2VfdW5oYW5kbGVkX2V4blxuICB0aGVuIEVycm9yLnJhaXNlIGVycm9yXG4gIGVsc2UgKFxuICAgICgqIE9uZSByZWFzb24gdG8gcnVuIFtkb19hdF9leGl0XSBoYW5kbGVycyBiZWZvcmUgcHJpbnRpbmcgb3V0IHRoZSBlcnJvciBtZXNzYWdlIGlzXG4gICAgICAgdGhhdCBpdCBoZWxwcyBjdXJzZXMgYXBwbGljYXRpb25zIGJyaW5nIHRoZSB0ZXJtaW5hbCBpbiBhIGdvb2Qgc3RhdGUsIG90aGVyd2lzZVxuICAgICAgIHRoZSBlcnJvciBtZXNzYWdlIG1pZ2h0IGdldCBjb3JydXB0ZWQuICBBbHNvLCB0aGUgT0NhbWwgdG9wLWxldmVsIHVuY2F1Z2h0XG4gICAgICAgZXhjZXB0aW9uIGhhbmRsZXIgZG9lcyB0aGUgc2FtZS4gKilcbiAgICAodHJ5IFN0ZGxpYi5kb19hdF9leGl0ICgpIHdpdGhcbiAgICAgfCBfIC0+ICgpKTtcbiAgICAobWF0Y2ggZXJyb3Jfa2luZCB3aXRoXG4gICAgIHwgYFVzZXJfdW5jYXVnaHQgLT5cbiAgICAgICAoKiBEb24ndCB1c2UgRGVidWcubG9nLCB0byBhdm9pZCByZWR1bmRhbnQgZXJyb3IgKHRhc2tfaWQgaW4gcGFydGljdWxhcikgKilcbiAgICAgICBlcHJpbnRmICFcIiV7U2V4cCNodW19XFxuJSFcIiBbJXNleHAgKFRpbWVfbnMubm93ICgpIDogVGltZV9ucy50KSwgKGVycm9yIDogRXJyb3IudCldXG4gICAgIHwgYEFzeW5jX3VuY2F1Z2h0IC0+XG4gICAgICAgRGVidWcubG9nIFwidW5oYW5kbGVkIGV4Y2VwdGlvbiBpbiBBc3luYyBzY2hlZHVsZXJcIiBlcnJvciBbJXNleHBfb2Y6IEVycm9yLnRdO1xuICAgICAgIERlYnVnLmxvZ19zdHJpbmcgXCJkdW1waW5nIGNvcmVcIjtcbiAgICAgICBEdW1wX2NvcmVfb25fam9iX2RlbGF5LmR1bXBfY29yZSAoKSk7XG4gICAgVW5peC5leGl0X2ltbWVkaWF0ZWx5IDEpXG47O1xuXG5sZXQgYWRkX2ZpbmFsaXplciB0IGhlYXBfYmxvY2sgZiA9XG4gIEtlcm5lbF9zY2hlZHVsZXIuYWRkX2ZpbmFsaXplciB0Lmtlcm5lbF9zY2hlZHVsZXIgaGVhcF9ibG9jayBmXG47O1xuXG5sZXQgYWRkX2ZpbmFsaXplcl9leG4gdCB4IGYgPVxuICBhZGRfZmluYWxpemVyIHQgKEhlYXBfYmxvY2suY3JlYXRlX2V4biB4KSAoZnVuIGhlYXBfYmxvY2sgLT5cbiAgICBmIChIZWFwX2Jsb2NrLnZhbHVlIGhlYXBfYmxvY2spKVxuOztcblxubGV0IGFzeW5jX2tlcm5lbF9jb25maWdfdGFza19pZCAoKSA9XG4gIGxldCBwaWQgPSBVbml4LmdldHBpZCAoKSBpblxuICBsZXQgdGhyZWFkX2lkID0gVGhyZWFkLmlkIChUaHJlYWQuc2VsZiAoKSkgaW5cbiAgWyVzZXhwX29mOiBbIGBwaWQgb2YgUGlkLnQgXSAqIFsgYHRocmVhZF9pZCBvZiBpbnQgXV0gKGBwaWQgcGlkLCBgdGhyZWFkX2lkIHRocmVhZF9pZClcbjs7XG5cbmxldCBzZXRfdGFza19pZCAoKSA9IEFzeW5jX2tlcm5lbF9jb25maWcudGFza19pZCA6PSBhc3luY19rZXJuZWxfY29uZmlnX3Rhc2tfaWRcblxubGV0IHJhaXNlX2lmX2FueV9qb2JzX3dlcmVfc2NoZWR1bGVkICgpID1cbiAgbWF0Y2ggS2VybmVsX3NjaGVkdWxlci5iYWNrdHJhY2Vfb2ZfZmlyc3Rfam9iIChLZXJuZWxfc2NoZWR1bGVyLnQgKCkpIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBidCAtPlxuICAgIHJhaXNlX3NcbiAgICAgIFslc2V4cFxuICAgICAgICBcImVycm9yOiBwcm9ncmFtIGlzIGF0dGVtcHRpbmcgdG8gc2NoZWR1bGUgYXN5bmMgd29yayB0b28gc29vbiAoYXQgdG9wbGV2ZWwgb2YgYSBcXFxuICAgICAgICAgbGlicmFyeSwgdXN1YWxseSlcIlxuICAgICAgICAsIChidCA6IEJhY2t0cmFjZS50KV1cbjs7XG5cbmxldCBpc19ydW5uaW5nIHQgPVxuICBtYXRjaCB0LnN0YXJ0X3R5cGUgd2l0aFxuICB8IE5vdF9zdGFydGVkIC0+IGZhbHNlXG4gIHwgXyAtPiB0cnVlXG47O1xuXG5sZXQgZ28gP3JhaXNlX3VuaGFuZGxlZF9leG4gKCkgPVxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJTY2hlZHVsZXIuZ29cIjtcbiAgc2V0X3Rhc2tfaWQgKCk7XG4gIGxldCB0ID0gdGhlX29uZV9hbmRfb25seSAoKSBpblxuICAoKiBbZ29dIGNhbiBiZSBjYWxsZWQgZnJvbSBhIHRocmVhZCBvdGhlciB0aGFuIHRoZSBtYWluIHRocmVhZCwgZm9yIGV4YW1wbGUgaW4gcHJvZ3JhbXNcbiAgICAgdGhhdCByZXNldCBzY2hlZHVsZXIgYWZ0ZXIgZm9yaywgc28gaW4gc29tZSBjYXNlcyBpdCBtdXN0IGFjcXVpcmUgdGhlIGxvY2sgaWZcbiAgICAgdGhlIHRocmVhZCBoYXMgbm90IGFscmVhZHkgZG9uZSBzby4gKilcbiAgaWYgbm90IChhbV9ob2xkaW5nX2xvY2sgdCkgdGhlbiBsb2NrIHQ7XG4gIG1hdGNoIHQuc3RhcnRfdHlwZSB3aXRoXG4gIHwgTm90X3N0YXJ0ZWQgLT5cbiAgICB0LnN0YXJ0X3R5cGUgPC0gQ2FsbGVkX2dvO1xuICAgIGJlX3RoZV9zY2hlZHVsZXIgdCA/cmFpc2VfdW5oYW5kbGVkX2V4blxuICB8IENhbGxlZF9ibG9ja19vbl9hc3luYyAtPlxuICAgICgqIFRoaXMgY2FzZSBjYW4gb2NjdXIgaWYgdGhlIG1haW4gdGhyZWFkIHVzZXMgVGhyZWFkX3NhZmUuYmxvY2tfb25fYXN5bmMgYmVmb3JlXG4gICAgICAgc3RhcnRpbmcgQXN5bmMuIFRoZW4sIHRoZSBzY2hlZHVsZXIgaXMgc3RhcnRlZCBhbmQgcnVubmluZyBpbiBhbm90aGVyIHRocmVhZCxcbiAgICAgICBzbyB3ZSBibG9jayBmb3JldmVyIGluc3RlYWQgb2YgY2FsbGluZyBbYmVfdGhlX3NjaGVkdWxlcl0gKilcbiAgICB1bmxvY2sgdDtcbiAgICAoKiBXZSB3YWtldXAgdGhlIHNjaGVkdWxlciBzbyBpdCBjYW4gcmVzcG9uZCB0byB3aGF0ZXZlciBhc3luYyBjaGFuZ2VzIHRoaXMgdGhyZWFkXG4gICAgICAgbWFkZS4gKilcbiAgICB0aHJlYWRfc2FmZV93YWtldXBfc2NoZWR1bGVyIHQ7XG4gICAgKCogU2luY2UgdGhlIHNjaGVkdWxlciBpcyBhbHJlYWR5IHJ1bm5pbmcsIHNvIHdlIGp1c3QgcGF1c2UgZm9yZXZlci4gKilcbiAgICBUaW1lLnBhdXNlX2ZvcmV2ZXIgKClcbiAgfCBDYWxsZWRfZXh0ZXJuYWxfcnVuIF8gLT5cbiAgICByYWlzZV9zIFslbWVzc2FnZSBcImNhbm5vdCBtaXggU2NoZWR1bGVyLmdvIGFuZCBTY2hlZHVsZXIuRXh0ZXJuYWxcIl1cbiAgfCBDYWxsZWRfZ28gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJjYW5ub3QgU2NoZWR1bGVyLmdvIG1vcmUgdGhhbiBvbmNlXCJdXG47O1xuXG5sZXQgZ29fbWFpblxuICA/cmFpc2VfdW5oYW5kbGVkX2V4blxuICA/ZmlsZV9kZXNjcl93YXRjaGVyXG4gID9tYXhfbnVtX29wZW5fZmlsZV9kZXNjcnNcbiAgP21heF9udW1fdGhyZWFkc1xuICB+bWFpblxuICAoKVxuICA9XG4gIChtYXRjaCAhdGhlX29uZV9hbmRfb25seV9yZWYgd2l0aFxuICAgfCBOb3RfcmVhZHlfdG9faW5pdGlhbGl6ZSAoKSB8IFJlYWR5X3RvX2luaXRpYWxpemUgXyAtPiAoKVxuICAgfCBJbml0aWFsaXplZCB7IGluaXRpYWxpemVkX2F0OyBfIH0gLT5cbiAgICAgcmFpc2Vfc1xuICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgXCJBc3luYyB3YXMgaW5pdGlhbGl6ZWQgcHJpb3IgdG8gW1NjaGVkdWxlci5nb19tYWluXVwiXG4gICAgICAgICAgIChpbml0aWFsaXplZF9hdCA6IEJhY2t0cmFjZS50KV0pO1xuICBsZXQgbWF4X251bV9vcGVuX2ZpbGVfZGVzY3JzID1cbiAgICBPcHRpb24ubWFwIG1heF9udW1fb3Blbl9maWxlX2Rlc2NycyB+ZjpNYXhfbnVtX29wZW5fZmlsZV9kZXNjcnMuY3JlYXRlX2V4blxuICBpblxuICBsZXQgbWF4X251bV90aHJlYWRzID0gT3B0aW9uLm1hcCBtYXhfbnVtX3RocmVhZHMgfmY6TWF4X251bV90aHJlYWRzLmNyZWF0ZV9leG4gaW5cbiAgbGV0IG11dGV4ID0gTmFub19tdXRleC5jcmVhdGUgKCkgaW5cbiAgTmFub19tdXRleC5sb2NrX2V4biBtdXRleDtcbiAgdGhlX29uZV9hbmRfb25seV9yZWZcbiAgICA6PSBSZWFkeV90b19pbml0aWFsaXplXG4gICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgIGNyZWF0ZSB+bXV0ZXggP2ZpbGVfZGVzY3Jfd2F0Y2hlciA/bWF4X251bV9vcGVuX2ZpbGVfZGVzY3JzID9tYXhfbnVtX3RocmVhZHMgKCkpO1xuICBEZWZlcnJlZC51cG9uIChyZXR1cm4gKCkpIG1haW47XG4gIGdvID9yYWlzZV91bmhhbmRsZWRfZXhuICgpXG47O1xuXG5sZXQgaXNfdGhlX29uZV9hbmRfb25seV9ydW5uaW5nICgpID1cbiAgaWYgaXNfcmVhZHlfdG9faW5pdGlhbGl6ZSAoKSB0aGVuIGZhbHNlIGVsc2UgaXNfcnVubmluZyAodGhlX29uZV9hbmRfb25seSAoKSlcbjs7XG5cbmxldCByZXBvcnRfbG9uZ19jeWNsZV90aW1lcyA/KGN1dG9mZiA9IHNlYyAxLikgKCkgPVxuICBTdHJlYW0uaXRlclxuICAgIChsb25nX2N5Y2xlcyB+YXRfbGVhc3Q6KGN1dG9mZiB8PiBUaW1lX25zLlNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0KSlcbiAgICB+ZjooZnVuIHNwYW4gLT5cbiAgICAgIGVwcmludGZcbiAgICAgICAgXCIlc1xcbiUhXCJcbiAgICAgICAgKEVycm9yLnRvX3N0cmluZ19odW1cbiAgICAgICAgICAgKEVycm9yLmNyZWF0ZSBcImxvbmcgYXN5bmMgY3ljbGVcIiBzcGFuIFslc2V4cF9vZjogVGltZV9ucy5TcGFuLnRdKSkpXG47O1xuXG5sZXQgc2V0X2NoZWNrX2ludmFyaWFudHMgYm9vbCA9IEtlcm5lbF9zY2hlZHVsZXIuKHNldF9jaGVja19pbnZhcmlhbnRzICh0ICgpKSBib29sKVxuXG5sZXQgc2V0X2RldGVjdF9pbnZhbGlkX2FjY2Vzc19mcm9tX3RocmVhZCBib29sID1cbiAgdXBkYXRlX2NoZWNrX2FjY2VzcyAodGhlX29uZV9hbmRfb25seSAoKSkgYm9vbFxuOztcblxubGV0IHNldF9tYXhfaW50ZXJfY3ljbGVfdGltZW91dCBzcGFuID1cbiAgKHRoZV9vbmVfYW5kX29ubHkgKCkpLm1heF9pbnRlcl9jeWNsZV90aW1lb3V0XG4gICAgPC0gTWF4X2ludGVyX2N5Y2xlX3RpbWVvdXQuY3JlYXRlX2V4biAoVGltZV9ucy5TcGFuLm9mX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCBzcGFuKVxuOztcblxudHlwZSAnYiBmb2xkZXIgPSB7IGZvbGRlciA6ICdhLiAnYiAtPiB0IC0+ICh0LCAnYSkgRmllbGQudCAtPiAnYiB9XG5cbmxldCB0ICgpID0gdGhlX29uZV9hbmRfb25seSAoKVxuXG5sZXQgd2l0aF90X29uY2Vfc3RhcnRlZCB+ZiA9XG4gIG1hdGNoICF0aGVfb25lX2FuZF9vbmx5X3JlZiB3aXRoXG4gIHwgSW5pdGlhbGl6ZWQgdCB3aGVuIGlzX3J1bm5pbmcgdCAtPiBmIHRcbiAgfCBfIC0+IERlZmVycmVkLmJpbmQgKHJldHVybiAoKSkgfmY6KGZ1biAoKSAtPiBmICh0ICgpKSlcbjs7XG5cbmxldCBmb2xkX2ZpZWxkcyAodHlwZSBhKSB+aW5pdCBmb2xkZXIgOiBhID1cbiAgbGV0IHQgPSB0ICgpIGluXG4gIGxldCBmIGFjIGZpZWxkID0gZm9sZGVyLmZvbGRlciBhYyB0IGZpZWxkIGluXG4gIEZpZWxkcy5mb2xkXG4gICAgfmluaXRcbiAgICB+bXV0ZXg6ZlxuICAgIH5zdGFydF90eXBlOmZcbiAgICB+ZmRzX3dob3NlX3dhdGNoaW5nX2hhc19jaGFuZ2VkOmZcbiAgICB+ZmlsZV9kZXNjcl93YXRjaGVyOmZcbiAgICB+YnVzeV9wb2xsZXJzOmZcbiAgICB+bnVtX2J1c3lfcG9sbGVyczpmXG4gICAgfnRpbWVfc3BlbnRfd2FpdGluZ19mb3JfaW86ZlxuICAgIH5mZF9ieV9kZXNjcjpmXG4gICAgfmV4dGVybmFsX2ZkX2J5X2Rlc2NyOmZcbiAgICB+ZXh0ZXJuYWxfZmRfZXZlbnRzOmZcbiAgICB+dGltZXJmZDpmXG4gICAgfnRpbWVyZmRfc2V0X2F0OmZcbiAgICB+c2NoZWR1bGVyX3RocmVhZF9pZDpmXG4gICAgfmludGVycnVwdG9yOmZcbiAgICB+c2lnbmFsX21hbmFnZXI6ZlxuICAgIH50aHJlYWRfcG9vbDpmXG4gICAgfmhhbmRsZV90aHJlYWRfcG9vbF9zdHVjazpmXG4gICAgfnRocmVhZF9wb29sX3N0dWNrOmZcbiAgICB+ZG5zX2xvb2t1cF90aHJvdHRsZTpmXG4gICAgfm5leHRfdHNjX2NhbGlicmF0aW9uOmZcbiAgICB+a2VybmVsX3NjaGVkdWxlcjpmXG4gICAgfmhhdmVfbG9ja19kb19jeWNsZTpmXG4gICAgfm1heF9pbnRlcl9jeWNsZV90aW1lb3V0OmZcbiAgICB+bWluX2ludGVyX2N5Y2xlX3RpbWVvdXQ6ZlxuICAgIH5pbml0aWFsaXplZF9hdDpmXG4gICAgfnVyaW5nOmZcbjs7XG5cbmxldCBoYW5kbGVfdGhyZWFkX3Bvb2xfc3R1Y2sgZiA9XG4gIGxldCB0ID0gdCAoKSBpblxuICBsZXQga2VybmVsX3NjaGVkdWxlciA9IHQua2VybmVsX3NjaGVkdWxlciBpblxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBLZXJuZWxfc2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQga2VybmVsX3NjaGVkdWxlciBpblxuICB0LmhhbmRsZV90aHJlYWRfcG9vbF9zdHVja1xuICAgIDwtIChmdW4gXyB+c3R1Y2tfZm9yIC0+XG4gICAgICAgICBLZXJuZWxfc2NoZWR1bGVyLmVucXVldWVcbiAgICAgICAgICAga2VybmVsX3NjaGVkdWxlclxuICAgICAgICAgICBleGVjdXRpb25fY29udGV4dFxuICAgICAgICAgICAoZnVuICgpIC0+IGYgfnN0dWNrX2ZvcilcbiAgICAgICAgICAgKCkpXG47O1xuXG5tb2R1bGUgRm9yX21ldHJpY3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFRocmVhZF9wb29sX3N0YXRzX3N1YnNjcmlwdGlvbiA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IHVuaXRcblxuICAgIGxldCBjcmVhdGVkID0gcmVmIGZhbHNlXG5cbiAgICBsZXQgY3JlYXRlX2V4biAoKSA9XG4gICAgICBpZiAhY3JlYXRlZFxuICAgICAgdGhlbiBmYWlsd2l0aCBcIlRocmVhZF9wb29sX3N0YXRzX3N1YnNjcmlwdGlvbi5jcmVhdGVfZXhuIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlXCI7XG4gICAgICBjcmVhdGVkIDo9IHRydWU7XG4gICAgICAoKVxuICAgIDs7XG5cbiAgICBsZXQgZ2V0X2FuZF9yZXNldCAoKSA9XG4gICAgICBsZXQgdCA9IHQgKCkgaW5cbiAgICAgIFRocmVhZF9wb29sLmdldF9hbmRfcmVzZXRfc3RhdHMgdC50aHJlYWRfcG9vbFxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBFeHRlcm5hbCA9IHN0cnVjdFxuICBsZXQgY3VycmVudF90aHJlYWRfY2FuX2N5Y2xlICgpID1cbiAgICBpZiBpc19yZWFkeV90b19pbml0aWFsaXplICgpXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSAoXG4gICAgICBsZXQgdCA9IHRoZV9vbmVfYW5kX29ubHkgKCkgaW5cbiAgICAgIGlmIG5vdCAoYW1faG9sZGluZ19sb2NrIHQpXG4gICAgICB0aGVuXG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2UgXCJBdHRlbXB0IHRvIGNhbGwgY3VycmVudF90aHJlYWRfY2FuX2N5Y2xlIHdpdGhvdXQgaG9sZGluZyBBc3luYyBsb2NrXCJdO1xuICAgICAgbWF0Y2ggdC5zdGFydF90eXBlIHdpdGhcbiAgICAgIHwgTm90X3N0YXJ0ZWQgLT4gdHJ1ZVxuICAgICAgfCBDYWxsZWRfZXh0ZXJuYWxfcnVuIHsgYWN0aXZlIH0gd2hlbiBub3QgIWFjdGl2ZSAtPiBpX2FtX3RoZV9zY2hlZHVsZXIgdFxuICAgICAgfCBDYWxsZWRfZ28gfCBDYWxsZWRfYmxvY2tfb25fYXN5bmMgfCBDYWxsZWRfZXh0ZXJuYWxfcnVuIF8gLT5cbiAgICAgICAgaWYgaV9hbV90aGVfc2NoZWR1bGVyIHRcbiAgICAgICAgdGhlblxuICAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIlNjaGVkdWxlci5FeHRlcm5hbC5jdXJyZW50X3RocmVhZF9jYW5fY3ljbGUgY2FsbGVkIGZyb20gd2l0aGluIEFzeW5jXCJdO1xuICAgICAgICBmYWxzZSlcbiAgOztcblxuICBsZXQgY29sbGVjdF9ldmVudHMgZXZlbnRfbGlzdCA9XG4gICAgTGlzdC5tYXAgZXZlbnRfbGlzdCB+ZjooZnVuIChldiA6IEV4dGVybmFsX2ZkX2V2ZW50LnQpIC0+XG4gICAgICBtYXRjaCBldi5ldmVudF90eXBlIHdpdGhcbiAgICAgIHwgYEJhZF9mZCAtPiByYWlzZV9zIFslbWVzc2FnZSBcIkJhZCBmaWxlIGRlc2NyaXB0b3JcIiAoZXYuZmlsZV9kZXNjciA6IEZpbGVfZGVzY3IudCldXG4gICAgICB8IGBSZWFkeSAtPiBldi5maWxlX2Rlc2NyLCBldi5yZWFkX29yX3dyaXRlKVxuICA7O1xuXG4gIGxldCBydW5fb25lX2N5Y2xlIHQgPVxuICAgIHNldF90YXNrX2lkICgpO1xuICAgIGxldCBhY3RpdmUgPVxuICAgICAgbWF0Y2ggdC5zdGFydF90eXBlIHdpdGhcbiAgICAgIHwgQ2FsbGVkX2V4dGVybmFsX3J1biB7IGFjdGl2ZSB9IC0+IGFjdGl2ZVxuICAgICAgfCBDYWxsZWRfZ28gfCBDYWxsZWRfYmxvY2tfb25fYXN5bmMgLT5cbiAgICAgICAgaWYgdC5zY2hlZHVsZXJfdGhyZWFkX2lkID0gY3VycmVudF90aHJlYWRfaWQgKClcbiAgICAgICAgdGhlblxuICAgICAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiU2NoZWR1bGVyLkV4dGVybmFsLnJ1bl9vbmVfY3ljbGUgY2FsbGVkIGZyb20gd2l0aGluIEFzeW5jXCJdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICByYWlzZV9zXG4gICAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgICAgXCJTY2hlZHVsZXIuRXh0ZXJuYWwucnVuX29uZV9jeWNsZSBjYWxsZWQgd2hpbGUgc2NoZWR1bGVyIGFscmVhZHkgcnVubmluZyBcXFxuICAgICAgICAgICAgICAgaW4gYW5vdGhlciB0aHJlYWRcIl1cbiAgICAgIHwgTm90X3N0YXJ0ZWQgLT5cbiAgICAgICAgbGV0IGFjdGl2ZSA9IHJlZiBmYWxzZSBpblxuICAgICAgICB0LnN0YXJ0X3R5cGUgPC0gQ2FsbGVkX2V4dGVybmFsX3J1biB7IGFjdGl2ZSB9O1xuICAgICAgICBpbml0IHQ7XG4gICAgICAgIGFjdGl2ZVxuICAgIGluXG4gICAgaWYgIWFjdGl2ZVxuICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJTY2hlZHVsZXIuRXh0ZXJuYWwucnVuX29uZV9jeWNsZSBjYWxsZWQgcmVjdXJzaXZlbHlcIl07XG4gICAgaWYgdC5zY2hlZHVsZXJfdGhyZWFkX2lkIDw+IGN1cnJlbnRfdGhyZWFkX2lkICgpXG4gICAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIlNjaGVkdWxlci5FeHRlcm5hbC5ydW5fb25lX2N5Y2xlIGNhbGxlZCBmcm9tIHdyb25nIHRocmVhZFwiXTtcbiAgICBhY3RpdmUgOj0gdHJ1ZTtcbiAgICBFeG4ucHJvdGVjdFxuICAgICAgfmZpbmFsbHk6KGZ1biAoKSAtPlxuICAgICAgICBhY3RpdmUgOj0gZmFsc2U7XG4gICAgICAgIHQuZXh0ZXJuYWxfZmRfZXZlbnRzIDwtIFtdKVxuICAgICAgfmY6KGZ1biAoKSAtPlxuICAgICAgICBPcHRpb24uaXRlciAob25lX2l0ZXIgdCkgfmY6RXJyb3IucmFpc2U7XG4gICAgICAgIGNvbGxlY3RfZXZlbnRzIHQuZXh0ZXJuYWxfZmRfZXZlbnRzKVxuICA7O1xuXG4gIGxldCBjaGVja190aHJlYWQgKCkgPVxuICAgIGlmIG5vdCAoY3VycmVudF90aHJlYWRfY2FuX2N5Y2xlICgpKVxuICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJGRCByZWdpc3RyYXRpb24gbXVzdCBvbmx5IGJlIGRvbmUgZnJvbSB0aGUgc2NoZWR1bGVyIHRocmVhZFwiXVxuICA7O1xuXG4gIGxldCByZWdpc3Rlcl9mZCBmZCBvcHMgPVxuICAgIGNoZWNrX3RocmVhZCAoKTtcbiAgICBsZXQgdCA9IHRoZV9vbmVfYW5kX29ubHkgKCkgaW5cbiAgICBtYXRjaCB0LnVyaW5nIHdpdGhcbiAgICB8IFNvbWUgXyAtPlxuICAgICAgKCogVW5saWtlIHdpdGggdGhlIFtlcG9sbF0gb3IgW3NlbGVjdF0gZmQgd2F0Y2hlcnMsIHRoZSBmZCBjaGVja2luZyBpbiB1cmluZyBoYXBwZW5zXG4gICAgICAgICBhc3luY2hyb25vdXNseSwgc28gd2UgY2FuJ3QgaW1wbGVtZW50IGEgc3luY2hyb25vdXMgdmVyc2lvbiBvZiBbdW5yZWdpc3Rlcl9mZF06XG4gICAgICAgICB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBjYW5jZWxsYXRpb24gdG8gYmUgYWNrbm93bGVkZ2VkIGJ5IHRoZSBrZXJuZWwsIHdoaWNoXG4gICAgICAgICBtZWFucyB3YWl0aW5nIGZvciBhc3luY2hyb25vdXMgaW9fdXJpbmcgY29tcGxldGlvbnMuICopXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkNhbm5vdCB3YXRjaCBleHRlcm5hbCBmZHMgd2hpbGUgdXNpbmcgdGhlIE9jYW1sX3VyaW5nIGZkIHdhdGNoZXJcIl1cbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBtb2R1bGUgRiA9ICh2YWwgdC5maWxlX2Rlc2NyX3dhdGNoZXIgOiBGaWxlX2Rlc2NyX3dhdGNoZXIuUykgaW5cbiAgICAgIGxldCViaW5kLlJlc3VsdCAoKSA9IEJ5X2Rlc2NyLmFkZCB0LmV4dGVybmFsX2ZkX2J5X2Rlc2NyIGZkIG9wcyBpblxuICAgICAgKG1hdGNoIEYuc2V0IEYud2F0Y2hlciBmZCBvcHMgd2l0aFxuICAgICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgICAgQnlfZGVzY3IucmVtb3ZlIHQuZXh0ZXJuYWxfZmRfYnlfZGVzY3IgZmQ7XG4gICAgICAgICBFcnJvciAoRXJyb3Iub2ZfZXhuIH5iYWNrdHJhY2U6YEdldCBleG4pXG4gICAgICAgfCBgVW5zdXBwb3J0ZWQgLT5cbiAgICAgICAgIEJ5X2Rlc2NyLnJlbW92ZSB0LmV4dGVybmFsX2ZkX2J5X2Rlc2NyIGZkO1xuICAgICAgICAgRXJyb3IgKEVycm9yLm9mX3N0cmluZyBcIlVuc3VwcG9ydGVkIGZpbGUgZGVzY3JpcHRvciB0eXBlIGluIHJlZ2lzdGVyX2ZkXCIpXG4gICAgICAgfCBgT2sgLT4gT2sgKCkpXG4gIDs7XG5cbiAgbGV0IG5vdF93YXRjaGluZyA9IFJlYWRfd3JpdGVfcGFpci5jcmVhdGUgfnJlYWQ6ZmFsc2UgfndyaXRlOmZhbHNlXG5cbiAgbGV0IHVucmVnaXN0ZXJfZmQgZmQgPVxuICAgIGNoZWNrX3RocmVhZCAoKTtcbiAgICBsZXQgdCA9IHRoZV9vbmVfYW5kX29ubHkgKCkgaW5cbiAgICBsZXQgbW9kdWxlIEYgPSAodmFsIHQuZmlsZV9kZXNjcl93YXRjaGVyIDogRmlsZV9kZXNjcl93YXRjaGVyLlMpIGluXG4gICAgaWYgbm90IChCeV9kZXNjci5tZW0gdC5leHRlcm5hbF9mZF9ieV9kZXNjciBmZClcbiAgICB0aGVuIEVycm9yIChFcnJvci5vZl9zdHJpbmcgXCJBdHRlbXB0IHRvIHVucmVnaXN0ZXIgYW4gRkQgd2hpY2ggaXMgbm90IHJlZ2lzdGVyZWRcIilcbiAgICBlbHNlIChcbiAgICAgIEJ5X2Rlc2NyLnJlbW92ZSB0LmV4dGVybmFsX2ZkX2J5X2Rlc2NyIGZkO1xuICAgICAgbWF0Y2ggRi5zZXQgRi53YXRjaGVyIGZkIG5vdF93YXRjaGluZyB3aXRoXG4gICAgICB8IGV4Y2VwdGlvbiBleG4gLT4gRXJyb3IgKEVycm9yLm9mX2V4biB+YmFja3RyYWNlOmBHZXQgZXhuKVxuICAgICAgfCBgVW5zdXBwb3J0ZWQgLT5cbiAgICAgICAgKCogUHJvYmFibHkgdGhpcyBjYW4ndCBoYXBwZW4gYmVjYXVzZSB1bnN1cHBvcnRlZCBmZCBjYW4ndCBiZSByZWdpc3RlcmVkXG4gICAgICAgICAgIGluIHRoZSBmaXJzdCBwbGFjZSAqKVxuICAgICAgICBFcnJvciAoRXJyb3Iub2Zfc3RyaW5nIFwiVW5zdXBwb3J0ZWQgZmlsZSBkZXNjcmlwdG9yIHR5cGUgaW4gdW5yZWdpc3Rlcl9mZFwiKVxuICAgICAgfCBgT2sgLT4gT2sgKCkpXG4gIDs7XG5cbiAgbGV0IGlzX3JlZ2lzdGVyZWQgZmQgPVxuICAgIGNoZWNrX3RocmVhZCAoKTtcbiAgICBsZXQgdCA9IHRoZV9vbmVfYW5kX29ubHkgKCkgaW5cbiAgICBCeV9kZXNjci5tZW0gdC5leHRlcm5hbF9mZF9ieV9kZXNjciBmZFxuICA7O1xuXG4gIGxldCBydW5fb25lX2N5Y2xlIH5tYXhfd2FpdCA9XG4gICAgbGV0IHQgPSB0aGVfb25lX2FuZF9vbmx5ICgpIGluXG4gICAgaWYgbm90IChhbV9ob2xkaW5nX2xvY2sgdClcbiAgICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiQXR0ZW1wdCB0byBydW5fb25lX2N5Y2xlIHdpdGhvdXQgaG9sZGluZyBBc3luYyBsb2NrXCJdO1xuICAgIG1hdGNoIG1heF93YWl0IHdpdGhcbiAgICB8IGBaZXJvIC0+XG4gICAgICAoKiBFbnN1cmUgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHJlYWR5LXRvLXJ1biBqb2IsIHNvIHRoYXQgQXN5bmMgZG9lc24ndCBibG9jayAqKVxuICAgICAgS2VybmVsX3NjaGVkdWxlci5lbnF1ZXVlIHQua2VybmVsX3NjaGVkdWxlciBFeGVjdXRpb25fY29udGV4dC5tYWluIGlnbm9yZSAoKTtcbiAgICAgIHJ1bl9vbmVfY3ljbGUgdFxuICAgIHwgYFVudGlsIHdha2VfYXQgLT5cbiAgICAgIGxldCB3YWtlID0gQ2xvY2tfbnMuRXZlbnQuYXQgd2FrZV9hdCBpblxuICAgICAgRXhuLnByb3RlY3RcbiAgICAgICAgfmY6KGZ1biAoKSAtPiBydW5fb25lX2N5Y2xlIHQpXG4gICAgICAgIH5maW5hbGx5OihmdW4gKCkgLT4gQ2xvY2tfbnMuRXZlbnQuYWJvcnRfaWZfcG9zc2libGUgd2FrZSAoKSlcbiAgICB8IGBJbmRlZmluaXRlIC0+IHJ1bl9vbmVfY3ljbGUgdFxuICA7O1xuXG4gIGxldCByZWMgcnVuX2N5Y2xlc191bnRpbF9kZXRlcm1pbmVkIGQgPVxuICAgIG1hdGNoIERlZmVycmVkLnBlZWsgZCB3aXRoXG4gICAgfCBTb21lIHggLT4geFxuICAgIHwgTm9uZSAtPlxuICAgICAgKG1hdGNoIHJ1bl9vbmVfY3ljbGUgfm1heF93YWl0OmBJbmRlZmluaXRlIHdpdGhcbiAgICAgICB8IFtdIC0+IHJ1bl9jeWNsZXNfdW50aWxfZGV0ZXJtaW5lZCBkXG4gICAgICAgfCByZWFkeV9mZHMgLT5cbiAgICAgICAgICgqIFdlJ3JlIGJsb2NraW5nIHVudGlsIFtkXSBpcyBkZXRlcm1pbmVkLCBzbyB3ZSBpZ25vcmUgdGhlIGZhY3QgdGhhdCBzb21lIGZkc1xuICAgICAgICAgICAgYXJlIHJlYWR5LiBSZWFkaW5lc3MgaXMgbGV2ZWwtdHJpZ2dlcmVkIHNvIHRoZSBldmVudHMgd2lsbCByZWFwcGVhciBpbiB0aGVcbiAgICAgICAgICAgIG5leHQgW3J1bl9vbmVfY3ljbGVdIGlmIGlnbm9yZWQuXG5cbiAgICAgICAgICAgIEhvd2V2ZXIsIGlmIHdlIGp1c3QgY2FsbCBbcnVuX29uZV9jeWNsZV0gYWdhaW4gdGhlc2UgZmRzIHdpbGwgc3RpbGwgYmUgcmVhZHksXG4gICAgICAgICAgICBhbmQgd2UnbGwgc3BpbiBpbnN0ZWFkIG9mIGJsb2NraW5nIGlmIHdlIG5lZWQgdG8gd2FpdC4gU28sIHRvIGxldCBBc3luYyB3YWl0XG4gICAgICAgICAgICB3aXRob3V0IHNwaW5uaW5nIHVzZWxlc3NseSwgd2UgdGVtcG9yYXJpbHkgdW5yZWdpc3RlciB0aGUgcmVhZHkgZmRzIGFuZFxuICAgICAgICAgICAgcmUtcmVnaXN0ZXIgYWZ0ZXJ3YXJkcy5cblxuICAgICAgICAgICAgVGhpcyBpcyBub3QgdGFpbCByZWN1cnNpdmUsIGJ1dCB0aGUgc3RhY2sgZGVwdGggaXMgYm91bmRlZCBieSB0aGUgbnVtYmVyXG4gICAgICAgICAgICBvZiBleHRlcm5hbGx5IHJlZ2lzdGVyZWQgRkRzIHRoYXQgYXJlIG9yIGJlY29tZSByZWFkeSAqKVxuICAgICAgICAgbGV0IHQgPSB0aGVfb25lX2FuZF9vbmx5ICgpIGluXG4gICAgICAgICBsZXQgZmRfb3BzID1cbiAgICAgICAgICAgTGlzdC5tYXAgfmY6ZnN0IHJlYWR5X2Zkc1xuICAgICAgICAgICAoKiBGRHMgbWF5IGJlIGR1cGxpY2F0ZWQgaW4gcmVhZHlfZmRzIGlmIHRoZXkgYXJlIHNpbXVsdGFuZW91c2x5IHJlYWR5IGZvclxuICAgICAgICAgICAgICByZWFkaW5nIGFuZCB3cml0aW5nICopXG4gICAgICAgICAgIHw+IExpc3QuZGVkdXBfYW5kX3NvcnQgfmNvbXBhcmU6WyVjb21wYXJlOiBGaWxlX2Rlc2NyLnRdXG4gICAgICAgICAgIHw+IExpc3QubWFwIH5mOihmdW4gZmQgLT4gZmQsIEJ5X2Rlc2NyLmZpbmRfZXhuIHQuZXh0ZXJuYWxfZmRfYnlfZGVzY3IgZmQpXG4gICAgICAgICBpblxuICAgICAgICAgKCogVHJ5IHRvIGVuc3VyZSB0aGF0IHdlIGxlYXZlIHRoZSBzZXQgb2YgcmVnaXN0ZXJlZCBmZHMgdW5jaGFuZ2VkLFxuICAgICAgICAgICAgZXZlbiBpZiBhbiBleGNlcHRpb24gaXMgcmFpc2VkIHNvbWV3aGVyZSAqKVxuICAgICAgICAgbGV0IHJlYyB0ZW1wb3JhcmlseV91bnJlZ2lzdGVyID0gZnVuY3Rpb25cbiAgICAgICAgICAgfCBbXSAtPiBydW5fY3ljbGVzX3VudGlsX2RldGVybWluZWQgZFxuICAgICAgICAgICB8IChmZCwgb3BzKSA6OiBmZF9vcHMgLT5cbiAgICAgICAgICAgICB1bnJlZ2lzdGVyX2ZkIGZkIHw+IE9yX2Vycm9yLm9rX2V4bjtcbiAgICAgICAgICAgICBFeG4ucHJvdGVjdFxuICAgICAgICAgICAgICAgfmZpbmFsbHk6KGZ1biAoKSAtPiByZWdpc3Rlcl9mZCBmZCBvcHMgfD4gT3JfZXJyb3Iub2tfZXhuKVxuICAgICAgICAgICAgICAgfmY6KGZ1biAoKSAtPiB0ZW1wb3JhcmlseV91bnJlZ2lzdGVyIGZkX29wcylcbiAgICAgICAgIGluXG4gICAgICAgICB0ZW1wb3JhcmlseV91bnJlZ2lzdGVyIGZkX29wcylcbiAgOztcbmVuZFxuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxub3BlbiBSYXdfc2NoZWR1bGVyXG5tb2R1bGUgUHJpb3JpdHkgPSBMaW51eF9leHQuUHJpb3JpdHlcblxubW9kdWxlIFdoZW5fZmluaXNoZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IE5vdGlmeV90aGVfc2NoZWR1bGVyXG4gICAgfCBUYWtlX3RoZV9hc3luY19sb2NrXG4gICAgfCBUcnlfdG9fdGFrZV90aGVfYXN5bmNfbG9ja1xuICBbQEBkZXJpdmluZyBlbnVtZXJhdGUsIHNleHBfb2ZdXG5cbiAgbGV0IGRlZmF1bHQgPSByZWYgVHJ5X3RvX3Rha2VfdGhlX2FzeW5jX2xvY2tcbmVuZFxuXG5sZXQgdHJ5X3RvX2xvY2tfZm9yX2N5Y2xlX2lmX3NjaGVkdWxlcl9zbGVlcGluZyB0ID1cbiAgaWYgdHJ5X2xvY2sgdFxuICB0aGVuXG4gICAgaWYgbm90IChJbnRlcnJ1cHRvci5hbHJlYWR5X2ludGVycnVwdGVkIHQuaW50ZXJydXB0b3IpXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSAoXG4gICAgICB1bmxvY2sgdDtcbiAgICAgIGZhbHNlKVxuICBlbHNlIGZhbHNlXG47O1xuXG5sZXQgc3R1Y2tfY2hlY2tfaW50ZXJ2YWwgKCkgPSBUaW1lX25zLlNwYW4ub2Zfc2VjIDEuXG5cbmxldCByZWMgc2NoZWR1bGVfc3R1Y2tfY2hlY2sgdCA9XG4gIHQudGhyZWFkX3Bvb2xfc3R1Y2tcbiAgICA8LSBTdHVja1xuICAgICAgICAgeyBzdHVja19zaW5jZSA9IFRpbWVfbnMubm93ICgpXG4gICAgICAgICA7IG51bV93b3JrX2NvbXBsZXRlZCA9IFRocmVhZF9wb29sLm51bV93b3JrX2NvbXBsZXRlZCB0LnRocmVhZF9wb29sXG4gICAgICAgICB9O1xuICBDbG9ja19ucy5ydW5fYWZ0ZXIgKHN0dWNrX2NoZWNrX2ludGVydmFsICgpKSBjaGVja19zdGlsbF9zdHVjayB0XG5cbmFuZCBjaGVja19zdGlsbF9zdHVjayB0ID1cbiAgbWF0Y2ggdC50aHJlYWRfcG9vbF9zdHVjayB3aXRoXG4gIHwgTm9fdW5zdGFydGVkX3dvcmsgLT4gKClcbiAgfCBTdHVjayBfIHdoZW4gbm90IChUaHJlYWRfcG9vbC5oYXNfdW5zdGFydGVkX3dvcmsgdC50aHJlYWRfcG9vbCkgLT5cbiAgICB0LnRocmVhZF9wb29sX3N0dWNrIDwtIE5vX3Vuc3RhcnRlZF93b3JrXG4gIHwgU3R1Y2sgeyBzdHVja19zaW5jZTsgbnVtX3dvcmtfY29tcGxldGVkIH0gLT5cbiAgICBpZiBudW1fd29ya19jb21wbGV0ZWQgPSBUaHJlYWRfcG9vbC5udW1fd29ya19jb21wbGV0ZWQgdC50aHJlYWRfcG9vbFxuICAgIHRoZW4gKFxuICAgICAgdC5oYW5kbGVfdGhyZWFkX3Bvb2xfc3R1Y2tcbiAgICAgICAgdC50aHJlYWRfcG9vbFxuICAgICAgICB+c3R1Y2tfZm9yOihUaW1lX25zLmRpZmYgKFRpbWVfbnMubm93ICgpKSBzdHVja19zaW5jZSk7XG4gICAgICBDbG9ja19ucy5ydW5fYWZ0ZXIgKHN0dWNrX2NoZWNrX2ludGVydmFsICgpKSBjaGVja19zdGlsbF9zdHVjayB0KVxuICAgIGVsc2Ugc2NoZWR1bGVfc3R1Y2tfY2hlY2sgdFxuOztcblxubGV0IG1heWJlX21hcmtfdGhyZWFkX3Bvb2xfc3R1Y2sgdCA9XG4gIGlmIFRocmVhZF9wb29sLmhhc191bnN0YXJ0ZWRfd29yayB0LnRocmVhZF9wb29sXG4gIHRoZW4gKFxuICAgIG1hdGNoIHQudGhyZWFkX3Bvb2xfc3R1Y2sgd2l0aFxuICAgIHwgTm9fdW5zdGFydGVkX3dvcmsgLT4gc2NoZWR1bGVfc3R1Y2tfY2hlY2sgdFxuICAgIHwgXyAtPiAoKSlcbjs7XG5cbmxldCBydW5fYWZ0ZXJfc2NoZWR1bGVyX2lzX3N0YXJ0ZWRcbiAgfnByaW9yaXR5XG4gIH50aHJlYWRcbiAgfih3aGVuX2ZpbmlzaGVkIDogV2hlbl9maW5pc2hlZC50KVxuICB+bmFtZVxuICB+dFxuICBmXG4gID1cbiAgbGV0IGl2YXIgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBsZXQgZG9pdCAoKSA9XG4gICAgKCogQXQgdGhpcyBwb2ludCwgd2UgYXJlIGluIGEgdGhyZWFkLXBvb2wgdGhyZWFkLCBub3QgdGhlIGFzeW5jIHRocmVhZC4gKilcbiAgICBsZXQgcmVzdWx0ID0gUmVzdWx0LnRyeV93aXRoIGYgaW5cbiAgICBsZXQgbG9ja2VkID1cbiAgICAgIG1hdGNoIHdoZW5fZmluaXNoZWQgd2l0aFxuICAgICAgfCBUYWtlX3RoZV9hc3luY19sb2NrIC0+XG4gICAgICAgIGxvY2sgdDtcbiAgICAgICAgdHJ1ZVxuICAgICAgfCBOb3RpZnlfdGhlX3NjaGVkdWxlciAtPiBmYWxzZVxuICAgICAgfCBUcnlfdG9fdGFrZV90aGVfYXN5bmNfbG9jayAtPlxuICAgICAgICAobWF0Y2ggdGhyZWFkX3Bvb2xfY3B1X2FmZmluaXR5IHQgd2l0aFxuICAgICAgICAgfCBJbmhlcml0IC0+IHRyeV90b19sb2NrX2Zvcl9jeWNsZV9pZl9zY2hlZHVsZXJfc2xlZXBpbmcgdFxuICAgICAgICAgfCBDcHVzZXQgXyAtPlxuICAgICAgICAgICAoKiBJZiB0aGUgdXNlciBzcGVjaWZpZWQgYW4gYWZmaW5pdHkgZm9yIHRoZSB0aHJlYWQgcG9vbCwgdGhleSBwcmVzdW1hYmx5IGludGVuZFxuICAgICAgICAgICAgICBmb3IgQXN5bmMgam9icyB0byBiZSBhZmZpbml0aXplZCBkaWZmZXJlbnRseSBmcm9tIHRocmVhZC1wb29sIHRocmVhZHMsIHNvIHdlXG4gICAgICAgICAgICAgIGRvbid0IGV2ZW4gYXR0ZW1wdCB0byBydW4gam9icyBvbiB0aGUgdGhyZWFkLXBvb2wgdGhyZWFkLiAqKVxuICAgICAgICAgICBmYWxzZSlcbiAgICBpblxuICAgIGlmIGxvY2tlZFxuICAgIHRoZW5cbiAgICAgIHByb3RlY3RcbiAgICAgICAgfmZpbmFsbHk6KGZ1biAoKSAtPiB1bmxvY2sgdClcbiAgICAgICAgfmY6KGZ1biAoKSAtPlxuICAgICAgICAgIEl2YXIuZmlsbF9leG4gaXZhciByZXN1bHQ7XG4gICAgICAgICAgaGF2ZV9sb2NrX2RvX2N5Y2xlIHQpXG4gICAgZWxzZVxuICAgICAgdGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qb2JcbiAgICAgICAgdFxuICAgICAgICAoY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0KVxuICAgICAgICAoZnVuICgpIC0+IEl2YXIuZmlsbF9leG4gaXZhciByZXN1bHQpXG4gICAgICAgICgpXG4gIGluXG4gIChtYXRjaCB0aHJlYWQgd2l0aFxuICAgfCBOb25lIC0+XG4gICAgIG9rX2V4biAoVGhyZWFkX3Bvb2wuYWRkX3dvcmsgdC50aHJlYWRfcG9vbCBkb2l0ID9uYW1lID9wcmlvcml0eSk7XG4gICAgIGlmIFRocmVhZF9wb29sLm51bV90aHJlYWRzIHQudGhyZWFkX3Bvb2wgPSAwXG4gICAgIHRoZW5cbiAgICAgICByYWlzZV9zXG4gICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgXCJBc3luYydzIHRocmVhZCBwb29sIHdhcyB1bmFibGUgdG8gY3JlYXRlIGEgc2luZ2xlIHRocmVhZFwiXG4gICAgICAgICAgICAgfl86XG4gICAgICAgICAgICAgICAoVGhyZWFkX3Bvb2wubGFzdF90aHJlYWRfY3JlYXRpb25fZmFpbHVyZSB0LnRocmVhZF9wb29sXG4gICAgICAgICAgICAgICAgIDogKFNleHAudCBvcHRpb25bQHNleHAub3B0aW9uXSkpXVxuICAgfCBTb21lIGhlbHBlcl90aHJlYWQgLT5cbiAgICAgb2tfZXhuXG4gICAgICAgKFRocmVhZF9wb29sLmFkZF93b3JrX2Zvcl9oZWxwZXJfdGhyZWFkXG4gICAgICAgICAgdC50aHJlYWRfcG9vbFxuICAgICAgICAgIGhlbHBlcl90aHJlYWRcbiAgICAgICAgICBkb2l0XG4gICAgICAgICAgP25hbWVcbiAgICAgICAgICA/cHJpb3JpdHkpKTtcbiAgbWF5YmVfbWFya190aHJlYWRfcG9vbF9zdHVjayB0O1xuICBJdmFyLnJlYWQgaXZhciA+PnwgUmVzdWx0Lm9rX2V4blxuOztcblxubGV0IHJ1biA/cHJpb3JpdHkgP3RocmVhZCA/bmFtZSBmID1cbiAgbGV0IHdoZW5fZmluaXNoZWQgPSAhV2hlbl9maW5pc2hlZC5kZWZhdWx0IGluXG4gICgqIFdlIHVzZSBbd2l0aF90X29uY2Vfc3RhcnRlZF0gdG8gZm9yY2UgY2FsbHMgdG8gW3J1bl9hZnRlcl9zY2hlZHVsZXJfaXNfc3RhcnRlZF0gdG9cbiAgICAgd2FpdCB1bnRpbCBhZnRlciB0aGUgc2NoZWR1bGVyIGlzIHN0YXJ0ZWQuICBXZSBkbyB0aGlzIGJlY2F1c2VcbiAgICAgW3J1bl9hZnRlcl9zY2hlZHVsZXJfaXNfc3RhcnRlZF0gd2lsbCBjYXVzZSB0aGluZ3MgdG8gcnVuIGluIG90aGVyIHRocmVhZHMsIGFuZCB3aGVuXG4gICAgIGEgam9iIGlzIGZpbmlzaGVkIGluIGFub3RoZXIgdGhyZWFkLCBpdCB3aWxsIHRyeSB0byBhY3F1aXJlIHRoZSBhc3luYyBsb2NrIGFuZFxuICAgICBtYW5pcHVsYXRlIGFzeW5jIGRhdGFzdHJ1Y3R1cmVzLiAgVGhpcyBzZWVtcyBoYXJkIHRvIHRoaW5rIGFib3V0IGlmIGFzeW5jIGhhc24ndCBldmVuXG4gICAgIHN0YXJ0ZWQgeWV0LiAqKVxuICBSYXdfc2NoZWR1bGVyLndpdGhfdF9vbmNlX3N0YXJ0ZWQgfmY6KGZ1biB0IC0+XG4gICAgcnVuX2FmdGVyX3NjaGVkdWxlcl9pc19zdGFydGVkIH5wcmlvcml0eSB+dGhyZWFkIH53aGVuX2ZpbmlzaGVkIH5uYW1lIH50IGYpXG47O1xuXG5tb2R1bGUgSGVscGVyX3RocmVhZCA9IHN0cnVjdFxuICAoKiBBIHdyYXBwZXIgYXJvdW5kIFtUaHJlYWRfcG9vbF0ncyBoZWxwZXIgdGhyZWFkLCBzbyB3ZSBjYW4gYXR0YWNoIGEgZmluYWxpemVyLiAqKVxuICB0eXBlIHQgPSB7IHRocmVhZF9wb29sX2hlbHBlcl90aHJlYWQgOiBUaHJlYWRfcG9vbC5IZWxwZXJfdGhyZWFkLnQgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMsIHNleHBfb2ZdXG5cbiAgKCogQm90aCBbY3JlYXRlXSBhbmQgW2NyZWF0ZV9ub3ddIGFkZCBBc3luYyBmaW5hbGl6ZXJzIHRvIHRoZSByZXR1cm5lZCBoZWxwZXIgdGhyZWFkIHNvXG4gICAgIHRoYXQgdGhlIHRocmVhZCBjYW4gYmUgYWRkZWQgYmFjayB0byB0aGUgc2V0IG9mIHdvcmtlciB0aHJlYWRzIHdoZW4gdGhlcmUgYXJlIG5vXG4gICAgIHJlZmVyZW5jZXMgdG8gdGhlIGhlbHBlciB0aHJlYWQgYW5kIHRoZSB0aHJlYWQgaGFzIG5vIHBlbmRpbmcgd29yay4gIEJlY2F1c2VcbiAgICAgW1RocmVhZF9wb29sLmZpbmlzaGVkX3dpdGhfaGVscGVyX3RocmVhZF0gbmVlZHMgdG8gYWNxdWlyZSB0aGUgdGhyZWFkIHBvb2wgbG9jaywgaXRcbiAgICAgY2Fubm90IGJlIHJ1biB3aXRoaW4gYW4gb3JkaW5hcnkgZmluYWxpemVyLCBzaW5jZSB0aGF0IGNvdWxkIGNhdXNlIGl0IHRvIGJlIHJ1biBpbiBhXG4gICAgIGNvbnRleHQgd2hlcmUgdGhlIGNvZGUgaW50ZXJydXB0ZWQgYnkgdGhlIEdDIG1pZ2h0IGFscmVhZHkgYmUgaG9sZGluZyB0aGUgdGhyZWFkIHBvb2xcbiAgICAgbG9jaywgd2hpY2ggd291bGQgcmVzdWx0IGluIGEgZGVhZGxvY2suICBIZW5jZSB3ZSB1c2UgYW4gQXN5bmMgZmluYWxpemVyIC0tIHRoaXNcbiAgICAgY2F1c2VzIHRoZSBHQyB0byBtZXJlbHkgc2NoZWR1bGUgYW4gQXN5bmMgam9iIHRoYXQgY2FsbHNcbiAgICAgW1RocmVhZF9wb29sLmZpbmlzaGVkX3dpdGhfaGVscGVyX3RocmVhZF0uICBXZSBkb24ndCBhdHRhY2ggdGhlIGZpbmFsaXplciBpbnNpZGVcbiAgICAgW1RocmVhZF9wb29sXSBiZWNhdXNlIHRoZSB0aHJlYWQgcG9vbCBkb2Vzbid0IGtub3cgYWJvdXQgQXN5bmMsIGFuZCBpbiBwYXJ0aWN1bGFyXG4gICAgIGRvZXNuJ3Qga25vdyBhYm91dCBBc3luYyBmaW5hbGl6ZXJzLiAqKVxuICBsZXQgY3JlYXRlX2ludGVybmFsIHNjaGVkdWxlciB0aHJlYWRfcG9vbF9oZWxwZXJfdGhyZWFkID1cbiAgICBsZXQgZmluYWxpemUgeyB0aHJlYWRfcG9vbF9oZWxwZXJfdGhyZWFkIH0gPVxuICAgICAgVGhyZWFkX3Bvb2wuZmluaXNoZWRfd2l0aF9oZWxwZXJfdGhyZWFkXG4gICAgICAgIHNjaGVkdWxlci50aHJlYWRfcG9vbFxuICAgICAgICB0aHJlYWRfcG9vbF9oZWxwZXJfdGhyZWFkXG4gICAgaW5cbiAgICBsZXQgdCA9IHsgdGhyZWFkX3Bvb2xfaGVscGVyX3RocmVhZCB9IGluXG4gICAgYWRkX2ZpbmFsaXplcl9leG4gc2NoZWR1bGVyIHQgZmluYWxpemU7XG4gICAgdFxuICA7O1xuXG4gIGxldCBjcmVhdGVfbm93ID9wcmlvcml0eSA/bmFtZSAoKSA9XG4gICAgbGV0IHNjaGVkdWxlciA9IHRoZV9vbmVfYW5kX29ubHkgKCkgaW5cbiAgICBSZXN1bHQubWFwXG4gICAgICAoVGhyZWFkX3Bvb2wuY3JlYXRlX2hlbHBlcl90aHJlYWQgc2NoZWR1bGVyLnRocmVhZF9wb29sID9uYW1lID9wcmlvcml0eSlcbiAgICAgIH5mOihmdW4gaGVscGVyX3RocmVhZCAtPiBjcmVhdGVfaW50ZXJuYWwgc2NoZWR1bGVyIGhlbHBlcl90aHJlYWQpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSA/cHJpb3JpdHkgP25hbWUgKCkgPVxuICAgIGxldCBzY2hlZHVsZXIgPSB0aGVfb25lX2FuZF9vbmx5ICgpIGluXG4gICAgbGV0JW1hcCBoZWxwZXJfdGhyZWFkID1cbiAgICAgIHJ1biAoZnVuICgpIC0+XG4gICAgICAgIFRocmVhZF9wb29sLmJlY29tZV9oZWxwZXJfdGhyZWFkIHNjaGVkdWxlci50aHJlYWRfcG9vbCA/bmFtZSA/cHJpb3JpdHkpXG4gICAgaW5cbiAgICBjcmVhdGVfaW50ZXJuYWwgc2NoZWR1bGVyIChva19leG4gaGVscGVyX3RocmVhZClcbiAgOztcbmVuZFxuXG5sZXQgcnVuID9wcmlvcml0eSA/dGhyZWFkID9uYW1lIGYgPVxuICBsZXQgdGhyZWFkID0gT3B0aW9uLm1hcCB0aHJlYWQgfmY6SGVscGVyX3RocmVhZC50aHJlYWRfcG9vbF9oZWxwZXJfdGhyZWFkIGluXG4gIHJ1biA/cHJpb3JpdHkgP3RocmVhZCA/bmFtZSBmXG47O1xuXG5sZXQgc3lzY2FsbCB+bmFtZSBmID0gcnVuIH5uYW1lIChmdW4gKCkgLT4gU3lzY2FsbC5zeXNjYWxsIGYpXG5sZXQgc3lzY2FsbF9leG4gfm5hbWUgZiA9IHJ1biB+bmFtZSAoZnVuICgpIC0+IFJlc3VsdC5va19leG4gKFN5c2NhbGwuc3lzY2FsbCBmKSlcblxubGV0IHBpcGVfb2Zfc3F1ZXVlIHNxID1cbiAgbGV0IHIsIHcgPSBQaXBlLmNyZWF0ZSAoKSBpblxuICAoKiBUaGUgZnVuY3Rpb25zIGFyZSBkZWZpbmVkIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGFsbG9jYXRpb24uICopXG4gIGxldCBwdWxsICgpID1cbiAgICBsZXQgcSA9IExpbmtlZF9xdWV1ZS5jcmVhdGUgKCkgaW5cbiAgICBTcXVldWUudHJhbnNmZXJfcXVldWUgc3EgcTtcbiAgICBxXG4gIGluXG4gIGxldCByZWMgY29udGludWUgcSA9XG4gICAgTGlua2VkX3F1ZXVlLml0ZXIgcSB+ZjooUGlwZS53cml0ZV93aXRob3V0X3B1c2hiYWNrIHcpO1xuICAgIFBpcGUucHVzaGJhY2sgdyA+Pj4gbG9vcFxuICAoKiBbcnVuIHB1bGxdIHJ1bnMgW3B1bGxdIGluIGEgdGhyZWFkLCBiZWNhdXNlIFtTcXVldWUudHJhbnNmZXJfcXVldWVdIGNhbiBibG9jay4gKilcbiAgYW5kIGxvb3AgKCkgPSBydW4gcHVsbCA+Pj4gY29udGludWUgaW5cbiAgbG9vcCAoKTtcbiAgclxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4gSW1wb3J0XG5tb2R1bGUgRXZlbnRmZCA9IExpbnV4X2V4dC5FdmVudGZkXG5cbnR5cGUgdCA9XG4gIHwgTm90X3N1cHBvcnRlZCBvZiB1bml0XG4gIHwgT2sgb2YgSW9fdXJpbmdfcmF3LnRcblxubW9kdWxlIEV2ZW50ZmRfZHJpdmVyID0gc3RydWN0XG4gICgqKlxuICAgICBUaGUgc3VibWlzc2lvbiBhbmQgY29tcGxldGlvbiBvZiB0YXNrcyBpcyBjb21wbGV0ZWx5IGF1dG9ub21vdXMsIHVzaW5nIHR3byBhc3luYyBqb2JzXG4gICAgIChvbmUgZm9yIHN1Ym1pc3Npb24gYW5kIG9uZSBmb3IgY29tcGxldGlvbikgdGhhdCBnZXQgc2NoZWR1bGVkIHdoZW4gbmVlZGVkLlxuICAgICBTdWJtaXNzaW9uIGlzIGRvbmUgYXQgdGhlIGVuZCBvZiBldmVyeSBjeWNsZSAoc3VibWlzc2lvbnMgd2hlbiB0aGUgcXVldWUgaXMgZW1wdHlcbiAgICAgc2hvdWxkIGJlIHZlcnkgY2hlYXApLiBJZiBhIHN5c2NhbGwgbWFrZXMgaXRzIHdheSB0byB0aGUgY29tcGxldGlvbiBxdWV1ZSwgdGhlIGpvYlxuICAgICB0aGF0IHdpbGwgZmlsbCB0aGUgY29ycmVzcG9uZGluZyBkZWZlcnJlZCBpcyBzY2hlZHVsZWQgdGhlIG5leHQgdGltZSB0aGUgYXN5bmNcbiAgICAgc2NoZWR1bGVyIGNoZWNrcyBmb3IgSS9PIHRocm91Z2ggdGhlIGZpbGUgZGVzY3JpcHRvciB3YXRjaGVyLlxuICAqKVxuICBsZXQgcmVnaXN0ZXJfaG9va3MgdXJpbmcgZXZlbnRmZCA9XG4gICAgSW9fdXJpbmdfcmF3LnJlZ2lzdGVyX2V2ZW50ZmQgdXJpbmcgKEV2ZW50ZmQudG9fZmlsZV9kZXNjciBldmVudGZkKTtcbiAgICBBc3luY19rZXJuZWxfc2NoZWR1bGVyLkV4cGVydC5ydW5fZXZlcnlfY3ljbGVfZW5kIChmdW4gKCkgLT5cbiAgICAgIGxldCAoXyA6IGludCkgPSBJb191cmluZ19yYXcuc3VibWl0IHVyaW5nIGluXG4gICAgICAoKSk7XG4gICAgbGV0IGZkID1cbiAgICAgIFJhd19zY2hlZHVsZXIuY3JlYXRlX2ZkXG4gICAgICAgIFJhd19mZC5LaW5kLkZpZm9cbiAgICAgICAgKEV2ZW50ZmQudG9fZmlsZV9kZXNjciBldmVudGZkKVxuICAgICAgICAoSW5mby5jcmVhdGVfcyBbJXNleHAgXCJpb191cmluZ19yYXcgZXZlbnRmZFwiXSlcbiAgICBpblxuICAgICgqIEFsdGhvdWdoIHRoaXMgam9iIGlzIG9ubHkgZXZlciBzY2hlZHVsZWQgd2hlbiB0aGUgZXZlbnRmZCBpcyByZWFkeSB0byByZWFkLCB3ZVxuICAgICAgIHN0aWxsIGhhdmUgdG8gcnVuIGl0IGluIG5vbmJsb2NraW5nIG1vZGUgYW5kIGhhbmRsZSBvcGVyYXRpb25zIHRoYXQgd291bGQgYmxvY2suXG4gICAgICAgVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGlzIGpvYiBjb3VsZCBlbmQgdXAgYmVpbmcgc2NoZWR1bGVkIG1vcmUgdGhhbiBvbmNlIGF0IGFcbiAgICAgICB0aW1lIGFuZCBiZSBydW4gbXVsdGlwbGUgdGltZXMgd2l0aGluIHRoZSBzYW1lIGFzeW5jIGN5Y2xlLlxuICAgICAgIChtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSBjYW4gY2F1c2UgdGhpcyBqb2IgdG8gYmUgcnVuIGluIGEgZnV0dXJlIGN5Y2xlKVxuICAgICopXG4gICAgbGV0IGV2ZW50ZmRfcmVhZHlfam9iID1cbiAgICAgIFJhd19zY2hlZHVsZXIuY3JlYXRlX2pvYlxuICAgICAgICAoUmF3X3NjaGVkdWxlci50aGVfb25lX2FuZF9vbmx5ICgpKVxuICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQgKF8gOiBJbnQ2NC50KSA9IEV2ZW50ZmQucmVhZCBldmVudGZkIGluXG4gICAgICAgICAgICBsZXQgKF8gOiBpbnQpID0gSW9fdXJpbmdfcmF3LmZpbGxfY29tcGxldGlvbnMgdXJpbmcgaW5cbiAgICAgICAgICAgICgpXG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgVW5peC5Vbml4X2Vycm9yICgoRUFHQUlOIHwgRVdPVUxEQkxPQ0spLCBfLCBfKSAtPiAoKVxuICAgICAgICAgIHwgZXhuIC0+IHJhaXNlIGV4bilcbiAgICAgICAgKClcbiAgICBpblxuICAgIGxldCBmaW5pc2hlZF93YXRjaGluZyA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgKG1hdGNoXG4gICAgICAgUmF3X3NjaGVkdWxlci5yZXF1ZXN0X3N0YXJ0X3dhdGNoaW5nXG4gICAgICAgICAoUmF3X3NjaGVkdWxlci50aGVfb25lX2FuZF9vbmx5ICgpKVxuICAgICAgICAgZmRcbiAgICAgICAgIGBSZWFkXG4gICAgICAgICAoUmF3X2ZkLldhdGNoaW5nLldhdGNoX3JlcGVhdGVkbHkgKGV2ZW50ZmRfcmVhZHlfam9iLCBmaW5pc2hlZF93YXRjaGluZykpXG4gICAgIHdpdGhcbiAgICAgfCBgV2F0Y2hpbmcgLT4gKClcbiAgICAgfCAoYEFscmVhZHlfY2xvc2VkIHwgYEFscmVhZHlfd2F0Y2hpbmcpIGFzIHJlc3VsdCAtPlxuICAgICAgIHJhaXNlX3NcbiAgICAgICAgIFslc2V4cFxuICAgICAgICAgICAoKFwidW5leHBlY3RlZCByZXN1bHQgd2hlbiBhc2tlZCB0byB3YXRjaCBldmVudGZkXCIsIHJlc3VsdClcbiAgICAgICAgICAgICA6IHN0cmluZyAqIFsgYEFscmVhZHlfY2xvc2VkIHwgYEFscmVhZHlfd2F0Y2hpbmcgXSldKTtcbiAgICBEZWZlcnJlZC51cG9uIChJdmFyLnJlYWQgZmluaXNoZWRfd2F0Y2hpbmcpIChmdW4gcmVhc29uIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslc2V4cFxuICAgICAgICAgICgoXCJ1bmV4cGVjdGVkbHkgc3RvcHBlZCB3YXRjaGluZyBldmVudGZkXCIsIHJlYXNvbilcbiAgICAgICAgICAgIDogc3RyaW5nICogWyBgQmFkX2ZkIHwgYENsb3NlZCB8IGBJbnRlcnJ1cHRlZCB8IGBVbnN1cHBvcnRlZCBdKV0pXG4gIDs7XG5cbiAgbGV0IGZvcmNlX3VyaW5nX2V4biAoKSA9XG4gICAgbGV0IHVyaW5nID1cbiAgICAgIElvX3VyaW5nX3Jhdy5jcmVhdGVcbiAgICAgICAgfnF1ZXVlX2RlcHRoOlxuICAgICAgICAgIChJb191cmluZ19tYXhfc3VibWlzc2lvbl9lbnRyaWVzLnJhdyBDb25maWcuaW9fdXJpbmdfbWF4X3N1Ym1pc3Npb25fZW50cmllcylcbiAgICAgICAgKClcbiAgICBpblxuICAgIG1hdGNoIEV2ZW50ZmQuY3JlYXRlLCB1cmluZyB3aXRoXG4gICAgfCBFcnJvciBldmVudGZkX2Vycm9yLCBFcnJvciB1cmluZ19lcnJvciAtPlxuICAgICAgRXJyb3IucmFpc2UgKEVycm9yLm9mX2xpc3QgWyBldmVudGZkX2Vycm9yOyB1cmluZ19lcnJvciBdKVxuICAgIHwgRXJyb3IgZXZlbnRmZF9lcnJvciwgT2sgdXJpbmcgLT5cbiAgICAgIElvX3VyaW5nX3Jhdy5leGl0IHVyaW5nO1xuICAgICAgRXJyb3IucmFpc2UgZXZlbnRmZF9lcnJvclxuICAgIHwgT2sgXywgRXJyb3IgdXJpbmdfZXJyb3IgLT4gRXJyb3IucmFpc2UgdXJpbmdfZXJyb3JcbiAgICB8IE9rIGNyZWF0ZV9ldmVudGZkLCBPayB1cmluZyAtPlxuICAgICAgbGV0IGV2ZW50ZmQgPVxuICAgICAgICBjcmVhdGVfZXZlbnRmZCB+ZmxhZ3M6RXZlbnRmZC5GbGFncy4oY2xvZXhlYyArIG5vbmJsb2NrKSAoSW50MzIub2ZfaW50X2V4biAwKVxuICAgICAgaW5cbiAgICAgIHJlZ2lzdGVyX2hvb2tzIHVyaW5nIGV2ZW50ZmQ7XG4gICAgICBPayB1cmluZ1xuICA7O1xuXG4gIGxldCBmb3JjZV91cmluZ19ub3JhaXNlICgpID1cbiAgICB0cnkgZm9yY2VfdXJpbmdfZXhuICgpIHdpdGhcbiAgICB8IF9leG4gLT4gTm90X3N1cHBvcnRlZCAoKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBGcm9tX3NjaGVkdWxlcl9kcml2ZXIgPSBzdHJ1Y3RcbiAgbGV0IGZvcmNlX3VyaW5nICgpID1cbiAgICBtYXRjaCBSYXdfc2NoZWR1bGVyLnVyaW5nIChSYXdfc2NoZWR1bGVyLnQgKCkpIHdpdGhcbiAgICB8IE5vbmUgLT4gTm90X3N1cHBvcnRlZCAoKVxuICAgIHwgU29tZSB1cmluZyAtPiBPayB1cmluZ1xuICA7O1xuZW5kXG5cbmxldCBjcmVhdGVfZ2xvYmFsX2lvX3VyaW5nICgpID1cbiAgbWF0Y2ggQ29uZmlnLmlvX3VyaW5nX21vZGUgd2l0aFxuICB8IERpc2FibGVkIC0+IE5vdF9zdXBwb3J0ZWQgKClcbiAgfCBFdmVudGZkIC0+IEV2ZW50ZmRfZHJpdmVyLmZvcmNlX3VyaW5nX2V4biAoKVxuICB8IElmX2F2YWlsYWJsZV9ldmVudGZkIC0+IEV2ZW50ZmRfZHJpdmVyLmZvcmNlX3VyaW5nX25vcmFpc2UgKClcbiAgfCBGcm9tX3NjaGVkdWxlciAtPiBGcm9tX3NjaGVkdWxlcl9kcml2ZXIuZm9yY2VfdXJpbmcgKClcbjs7XG5cbmxldCBnbG9iYWxfaW9fdXJpbmcgPSBsYXp5IChjcmVhdGVfZ2xvYmFsX2lvX3VyaW5nICgpKVxuXG5sZXQgdGhlX29uZV9hbmRfb25seSAoKSA9XG4gIG1hdGNoIGZvcmNlIGdsb2JhbF9pb191cmluZyB3aXRoXG4gIHwgTm90X3N1cHBvcnRlZCAoKSAtPiBOb25lXG4gIHwgT2sgaW9fdXJpbmcgLT4gU29tZSBpb191cmluZ1xuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm1vZHVsZSBTY2hlZHVsZXIgPSBSYXdfc2NoZWR1bGVyXG5tb2R1bGUgRmQgPSBSYXdfZmRcbmluY2x1ZGUgRmQuVFxub3BlbiBGZFxuXG5sZXQgZGVidWcgPSBkZWJ1Z1xubGV0IGlzX2Nsb3NlZCA9IGlzX2Nsb3NlZFxubGV0IGlzX29wZW4gPSBpc19vcGVuXG5sZXQgc3lzY2FsbCA9IHN5c2NhbGxcbmxldCBzeXNjYWxsX2V4biA9IHN5c2NhbGxfZXhuXG5sZXQgc3lzY2FsbF9yZXN1bHRfZXhuID0gc3lzY2FsbF9yZXN1bHRfZXhuXG5sZXQgd2l0aF9maWxlX2Rlc2NyID0gd2l0aF9maWxlX2Rlc2NyXG5sZXQgd2l0aF9maWxlX2Rlc2NyX2V4biA9IHdpdGhfZmlsZV9kZXNjcl9leG5cblxubW9kdWxlIEtpbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBGZC5LaW5kXG5cbiAgbGV0IGdldF9zb2NrZXRfc3RhdGUgZmlsZV9kZXNjciA9XG4gICAgbWF0Y2ggVW5peC5nZXRzb2Nrb3B0IGZpbGVfZGVzY3IgU09fQUNDRVBUQ09OTiB3aXRoXG4gICAgfCB0cnVlIC0+IGBQYXNzaXZlXG4gICAgfCBmYWxzZSAtPiBgQWN0aXZlXG4gICAgfCBleGNlcHRpb24gVW5peC5Vbml4X2Vycm9yIChFTk9QUk9UT09QVCwgXywgXykgLT5cbiAgICAgICgqIFtTT19BQ0NFUFRDT05OXSBpcyBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgcGxhdGZvcm1zLiAqKVxuICAgICAgYFVua25vd25cbiAgOztcblxuICBsZXQga2luZF9mcm9tX2ZzdGF0IGZpbGVfZGVzY3IgKGtpbmQgOiBDb3JlX3VuaXguZmlsZV9raW5kKSA6IEZkLktpbmQudCA9XG4gICAgbWF0Y2gga2luZCB3aXRoXG4gICAgfCBTX1JFRyB8IFNfRElSIHwgU19CTEsgfCBTX0xOSyAtPiBGaWxlXG4gICAgfCBTX0NIUiAtPiBDaGFyXG4gICAgfCBTX0ZJRk8gLT4gRmlmb1xuICAgIHwgU19TT0NLIC0+IFNvY2tldCAoZ2V0X3NvY2tldF9zdGF0ZSBmaWxlX2Rlc2NyKVxuICA7O1xuXG4gIGxldCBibG9ja2luZ19pbmZlcl91c2luZ19zdGF0IGZpbGVfZGVzY3IgPVxuICAgIGxldCBzdCA9IFVuaXguZnN0YXQgZmlsZV9kZXNjciBpblxuICAgIGtpbmRfZnJvbV9mc3RhdCBmaWxlX2Rlc2NyIHN0LnN0X2tpbmRcbiAgOztcblxuICBsZXQga2luZF9mcm9tX3VyaW5nX3N0YXQgZmlsZV9kZXNjciBraW5kID1cbiAgICBtYXRjaCBraW5kIHdpdGhcbiAgICAoKiBXZSBkb24ndCBrbm93IHdoZW4gdGhlIGtlcm5lbCBjYW4gYWN0dWFsbHkgcmV0dXJuIFVua25vd24sIGJ1dCB0aGUgT0NhbWxcbiAgICAgICBpbXBsZW1lbnRhdGlvbiBvZiBzdGF0IGRlZmF1bHRzIHRvIGEgRmlsZSBpbiB0aGUgY2FzZSB0aGVyZSBpcyBubyBtYXRjaCwgc28gd2UgZG9cbiAgICAgICB0aGUgc2FtZS4gKilcbiAgICB8IGBVbmtub3duIC0+IEZpbGVcbiAgICB8IGBSZWd1bGFyX2ZpbGUgfCBgRGlyZWN0b3J5IHwgYEJsb2NrX2RldmljZSB8IGBTeW1ib2xpY19saW5rIC0+IEZpbGVcbiAgICB8IGBDaGFyYWN0ZXJfc3BlY2lhbCAtPiBDaGFyXG4gICAgfCBgRmlmbyAtPiBGaWZvXG4gICAgfCBgU29ja2V0IC0+IFNvY2tldCAoZ2V0X3NvY2tldF9zdGF0ZSBmaWxlX2Rlc2NyKVxuICA7O1xuXG4gIGxldCBpbmZlcl91c2luZ191cmluZ19zdGF0IGZpbGVfZGVzY3IgdXJpbmcgPVxuICAgIGxldCBzdGF0eF9idWZmZXIgPSBJb191cmluZ19yYXcuU3RhdHguY3JlYXRlICgpIGluXG4gICAgbWF0Y2glbWFwXG4gICAgICBJb191cmluZ19yYXcuc3RhdHhcbiAgICAgICAgdXJpbmdcbiAgICAgICAgfmZkOmZpbGVfZGVzY3JcbiAgICAgICAgfm1hc2s6SW9fdXJpbmdfcmF3LlN0YXR4Lk1hc2sudHlwZSdcbiAgICAgICAgXCJcIlxuICAgICAgICBzdGF0eF9idWZmZXJcbiAgICAgICAgSW9fdXJpbmdfcmF3LlN0YXR4LkZsYWdzLmVtcHR5X3BhdGhcbiAgICAgIHw+IElvX3VyaW5nX3Jhdy5zeXNjYWxsX3Jlc3VsdFxuICAgIHdpdGhcbiAgICB8IE9rIHJlcyAtPlxuICAgICAgYXNzZXJ0IChyZXMgPSAwKTtcbiAgICAgIGtpbmRfZnJvbV91cmluZ19zdGF0IGZpbGVfZGVzY3IgKElvX3VyaW5nX3Jhdy5TdGF0eC5raW5kIHN0YXR4X2J1ZmZlcilcbiAgICB8IEVycm9yIGVyciAtPlxuICAgICAgcmFpc2VcbiAgICAgICAgKFVuaXguVW5peF9lcnJvclxuICAgICAgICAgICAoIGVyclxuICAgICAgICAgICAsIFwiZnN0YXRcIlxuICAgICAgICAgICAsIENvcmVfdW5peC5Qcml2YXRlLnNleHBfdG9fc3RyaW5nX2h1bSBbJXNleHAgeyBmaWxlX2Rlc2NyIDogRmlsZV9kZXNjci50IH1dICkpXG4gIDs7XG5cbiAgbGV0IGluZmVyX3VzaW5nX3N0YXQgZmlsZV9kZXNjciA9XG4gICAgbWF0Y2ggSW9fdXJpbmdfcmF3X3NpbmdsZXRvbi50aGVfb25lX2FuZF9vbmx5ICgpIHdpdGhcbiAgICB8IFNvbWUgdXJpbmcgLT4gaW5mZXJfdXNpbmdfdXJpbmdfc3RhdCBmaWxlX2Rlc2NyIHVyaW5nXG4gICAgfCBOb25lIC0+XG4gICAgICBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJmc3RhdFwiIChmdW4gKCkgLT4gYmxvY2tpbmdfaW5mZXJfdXNpbmdfc3RhdCBmaWxlX2Rlc2NyKVxuICA7O1xuZW5kXG5cbmxldCB0b19zdHJpbmcgdCA9IFNleHAudG9fc3RyaW5nX2h1bSAoc2V4cF9vZl90IHQpXG5sZXQgdGhlX29uZV9hbmRfb25seSAoKSA9IFNjaGVkdWxlci50aGVfb25lX2FuZF9vbmx5ICgpXG5cbmxldCBjcmVhdGUgP2F2b2lkX3NldHRpbmdfbm9uYmxvY2sga2luZCBmaWxlX2Rlc2NyIGluZm8gPVxuICBTY2hlZHVsZXIuY3JlYXRlX2ZkID9hdm9pZF9zZXR0aW5nX25vbmJsb2NrIGtpbmQgZmlsZV9kZXNjciBpbmZvXG47O1xuXG4oKiBXZSBkbyBub3QgbWFrZSBbc3RkaW5dLCBbc3Rkb3V0XSwgb3IgW3N0ZGVycl0gbm9uYmxvY2tpbmcgc28gdGhhdFxuICAgb25lIGNhbiB1c2UgQ29yZSBJL08gbGlicmFyaWVzIHNpbXVsdGFuZW91c2x5IHdpdGggYXN5bmMgd2l0aG91dCB0aGVtIGZhaWxpbmcgZHVlIHRvXG4gICBbU3lzX2Jsb2NrZWRfaW9dLiAqKVxubGV0IGNyZWF0ZV9zdGRfZGVzY3IgZmlsZV9kZXNjciBpbmZvID1cbiAgY3JlYXRlXG4gICAgKEtpbmQuYmxvY2tpbmdfaW5mZXJfdXNpbmdfc3RhdCBmaWxlX2Rlc2NyKVxuICAgIGZpbGVfZGVzY3JcbiAgICBpbmZvXG4gICAgfmF2b2lkX3NldHRpbmdfbm9uYmxvY2s6dHJ1ZVxuOztcblxubGV0IHN0ZGluID0gTWVtby51bml0IChmdW4gKCkgLT4gY3JlYXRlX3N0ZF9kZXNjciBVbml4LnN0ZGluIChJbmZvLm9mX3N0cmluZyBcIjxzdGRpbj5cIikpXG5cbmxldCBzdGRvdXQgPVxuICBNZW1vLnVuaXQgKGZ1biAoKSAtPiBjcmVhdGVfc3RkX2Rlc2NyIFVuaXguc3Rkb3V0IChJbmZvLm9mX3N0cmluZyBcIjxzdGRvdXQ+XCIpKVxuOztcblxubGV0IHN0ZGVyciA9XG4gIE1lbW8udW5pdCAoZnVuICgpIC0+IGNyZWF0ZV9zdGRfZGVzY3IgVW5peC5zdGRlcnIgKEluZm8ub2Zfc3RyaW5nIFwiPHN0ZGVycj5cIikpXG47O1xuXG5sZXQgc3VwcG9ydHNfbm9uYmxvY2sgdCA9IEZkLnN1cHBvcnRzX25vbmJsb2NrIHRcblxubGV0IGNsZWFyX25vbmJsb2NrIHQgPVxuICAoKiBCeSBzZXR0aW5nIFt0LmNhbl9zZXRfbm9uYmxvY2tdIHRvIGZhbHNlIHdlJ3JlIG1ha2luZyB0aGUgdXNlciBjaG9pY2UgcGVyc2lzdGVudDpcbiAgICAgdGhlIG5leHQgdGltZSBhIG5vbmJsb2NraW5nIG9wZXJhdGlvbiBpcyBhdHRlbXB0ZWQgaXQgc2ltcGx5IHdvbid0IHdvcmssIGluc3RlYWQgb2ZcbiAgICAgaWdub3JpbmcgdGhlIHVzZXIgY2hvaWNlIGFuZCBzZXR0aW5nIG5vbmJsb2NrIGFueXdheSAqKVxuICB0LmNhbl9zZXRfbm9uYmxvY2sgPC0gZmFsc2U7XG4gIG1hdGNoIHQubm9uYmxvY2tfc3RhdHVzIHdpdGhcbiAgfCBCbG9ja2luZyAtPiAoKVxuICB8IE5vbmJsb2NraW5nIHwgVW5rbm93biAtPlxuICAgIHQubm9uYmxvY2tfc3RhdHVzIDwtIEJsb2NraW5nO1xuICAgIFVuaXguY2xlYXJfbm9uYmxvY2sgdC5maWxlX2Rlc2NyXG47O1xuXG5tb2R1bGUgQ2xvc2UgPSBzdHJ1Y3RcbiAgdHlwZSBzb2NrZXRfaGFuZGxpbmcgPVxuICAgIHwgU2h1dGRvd25fc29ja2V0XG4gICAgfCBEb19ub3Rfc2h1dGRvd25fc29ja2V0XG5cbiAgdHlwZSBmaWxlX2Rlc2NyaXB0b3JfaGFuZGxpbmcgPVxuICAgIHwgQ2xvc2VfZmlsZV9kZXNjcmlwdG9yIG9mIHNvY2tldF9oYW5kbGluZ1xuICAgIHwgRG9fbm90X2Nsb3NlX2ZpbGVfZGVzY3JpcHRvclxuXG4gIGxldCBjbG9zZV9zeXNjYWxsIGZpbGVfZGVzY3IgPVxuICAgIG1hdGNoIElvX3VyaW5nX3Jhd19zaW5nbGV0b24udGhlX29uZV9hbmRfb25seSAoKSB3aXRoXG4gICAgfCBTb21lIHVyaW5nIC0+XG4gICAgICBJb191cmluZ19yYXcuc3lzY2FsbF9yZXN1bHQgKElvX3VyaW5nX3Jhdy5jbG9zZSB1cmluZyBmaWxlX2Rlc2NyKVxuICAgICAgPj58IChmdW5jdGlvblxuICAgICAgfCBFcnJvciBlcnIgLT5cbiAgICAgICAgcmFpc2VcbiAgICAgICAgICAoVW5peC5Vbml4X2Vycm9yXG4gICAgICAgICAgICAgKCBlcnJcbiAgICAgICAgICAgICAsIFwiY2xvc2VcIlxuICAgICAgICAgICAgICwgQ29yZV91bml4LlByaXZhdGUuc2V4cF90b19zdHJpbmdfaHVtXG4gICAgICAgICAgICAgICAgIFslc2V4cCB7IGZkIDogRmlsZV9kZXNjci50ID0gZmlsZV9kZXNjciB9XSApKVxuICAgICAgfCBPayByZXN1bHQgLT5cbiAgICAgICAgYXNzZXJ0IChyZXN1bHQgPSAwKTtcbiAgICAgICAgKCkpXG4gICAgfCBOb25lIC0+IEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcImNsb3NlXCIgKGZ1biAoKSAtPiBVbml4LmNsb3NlIGZpbGVfZGVzY3IpXG4gIDs7XG5cbiAgbGV0IGNsb3NlID8oZmlsZV9kZXNjcmlwdG9yX2hhbmRsaW5nID0gQ2xvc2VfZmlsZV9kZXNjcmlwdG9yIFNodXRkb3duX3NvY2tldCkgdCA9XG4gICAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJGZC5jbG9zZVwiIHQgWyVzZXhwX29mOiB0XTtcbiAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgIHwgQ2xvc2VfcmVxdWVzdGVkIF8gfCBDbG9zZWQgLT4gKClcbiAgICAgfCBPcGVuIGNsb3NlX3N0YXJ0ZWQgLT5cbiAgICAgICBJdmFyLmZpbGxfZXhuIGNsb3NlX3N0YXJ0ZWQgKCk7XG4gICAgICAgbGV0IGRvX2Nsb3NlX3N5c2NhbGwgKCkgPVxuICAgICAgICAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAgICAgICAgKGxldCVtYXAgKCkgPVxuICAgICAgICAgICAgICBtYXRjaCBmaWxlX2Rlc2NyaXB0b3JfaGFuZGxpbmcgd2l0aFxuICAgICAgICAgICAgICB8IERvX25vdF9jbG9zZV9maWxlX2Rlc2NyaXB0b3IgLT4gcmV0dXJuICgpXG4gICAgICAgICAgICAgIHwgQ2xvc2VfZmlsZV9kZXNjcmlwdG9yIHNvY2tldF9oYW5kbGluZyAtPlxuICAgICAgICAgICAgICAgIE1vbml0b3IucHJvdGVjdFxuICAgICAgICAgICAgICAgICAgfnJ1bjpgU2NoZWR1bGVcbiAgICAgICAgICAgICAgICAgIH5maW5hbGx5OihmdW4gKCkgLT4gY2xvc2Vfc3lzY2FsbCB0LmZpbGVfZGVzY3IpXG4gICAgICAgICAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoIHQua2luZCwgc29ja2V0X2hhbmRsaW5nIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCBTb2NrZXQgYEFjdGl2ZSwgU2h1dGRvd25fc29ja2V0IC0+XG4gICAgICAgICAgICAgICAgICAgICAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwic2h1dGRvd25cIiAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBVbml4LnNodXRkb3duIHQuZmlsZV9kZXNjciB+bW9kZTpTSFVURE9XTl9BTEwpXG4gICAgICAgICAgICAgICAgICAgIHwgXyAtPiByZXR1cm4gKCkpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgSXZhci5maWxsX2V4biB0LmNsb3NlX2ZpbmlzaGVkICgpKVxuICAgICAgIGluXG4gICAgICAgbGV0IHNjaGVkdWxlciA9IHRoZV9vbmVfYW5kX29ubHkgKCkgaW5cbiAgICAgICBsZXQga2VybmVsX3NjaGVkdWxlciA9IHNjaGVkdWxlci5rZXJuZWxfc2NoZWR1bGVyIGluXG4gICAgICAgc2V0X3N0YXRlXG4gICAgICAgICB0XG4gICAgICAgICAoQ2xvc2VfcmVxdWVzdGVkXG4gICAgICAgICAgICAoS2VybmVsX3NjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IGtlcm5lbF9zY2hlZHVsZXIsIGRvX2Nsb3NlX3N5c2NhbGwpKTtcbiAgICAgICAoKiBOb3RpZnkgb3RoZXIgdXNlcnMgb2YgdGhpcyBmZCB0aGF0IGl0IGlzIGdvaW5nIHRvIGJlIGNsb3NlZC4gKilcbiAgICAgICBTY2hlZHVsZXIucmVxdWVzdF9zdG9wX3dhdGNoaW5nIHNjaGVkdWxlciB0IGBSZWFkIGBDbG9zZWQ7XG4gICAgICAgU2NoZWR1bGVyLnJlcXVlc3Rfc3RvcF93YXRjaGluZyBzY2hlZHVsZXIgdCBgV3JpdGUgYENsb3NlZDtcbiAgICAgICAoKiBJZiB0aGVyZSBhcmUgbm8gc3lzY2FsbHMgaW4gcHJvZ3Jlc3MsIHRoZW4gc3RhcnQgY2xvc2luZyB0aGUgZmQuICopXG4gICAgICAgU2NoZWR1bGVyLm1heWJlX3N0YXJ0X2Nsb3NpbmdfZmQgc2NoZWR1bGVyIHQpO1xuICAgIEl2YXIucmVhZCB0LmNsb3NlX2ZpbmlzaGVkXG4gIDs7XG5cbiAgbGV0IGRlcmVnaXN0ZXIgdCA9IGNsb3NlIH5maWxlX2Rlc2NyaXB0b3JfaGFuZGxpbmc6RG9fbm90X2Nsb3NlX2ZpbGVfZGVzY3JpcHRvciB0XG5lbmRcblxuaW5jbHVkZSBDbG9zZVxuXG5sZXQgY2xvc2VfZmluaXNoZWQgdCA9IEl2YXIucmVhZCB0LmNsb3NlX2ZpbmlzaGVkXG5cbmxldCBjbG9zZV9zdGFydGVkIHQgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBPcGVuIGNsb3NlX3N0YXJ0ZWQgLT4gSXZhci5yZWFkIGNsb3NlX3N0YXJ0ZWRcbiAgfCBDbG9zZV9yZXF1ZXN0ZWQgXyB8IENsb3NlZCAtPiByZXR1cm4gKClcbjs7XG5cbmxldCBjcmVhdGVfYm9ycm93ZWQgP2F2b2lkX3NldHRpbmdfbm9uYmxvY2sga2luZCBmaWxlX2Rlc2NyIGluZm8gfmYgPVxuICBsZXQgZmQgPSBjcmVhdGUgP2F2b2lkX3NldHRpbmdfbm9uYmxvY2sga2luZCBmaWxlX2Rlc2NyIGluZm8gaW5cbiAgTW9uaXRvci5wcm90ZWN0XG4gICAgfnJ1bjpgU2NoZWR1bGVcbiAgICB+bmFtZTpcIkZkLmNyZWF0ZV9ib3Jyb3dlZFwiXG4gICAgKGZ1biAoKSAtPiBmIGZkKVxuICAgIH5maW5hbGx5OihmdW4gKCkgLT4gY2xvc2UgfmZpbGVfZGVzY3JpcHRvcl9oYW5kbGluZzpEb19ub3RfY2xvc2VfZmlsZV9kZXNjcmlwdG9yIGZkKVxuOztcblxubGV0IHdpdGhfY2xvc2UgdCB+ZiA9XG4gIE1vbml0b3IucHJvdGVjdCB+cnVuOmBTY2hlZHVsZSAoZnVuICgpIC0+IGYgdCkgfmZpbmFsbHk6KGZ1biAoKSAtPiBjbG9zZSB0KVxuOztcblxubGV0IHdpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZCB0ID8oZXh0cmFjdF9leG4gPSBmYWxzZSkgZiA9XG4gIG1hdGNoIGluY19udW1fYWN0aXZlX3N5c2NhbGxzIHQgd2l0aFxuICB8IGBBbHJlYWR5X2Nsb3NlZCAtPiByZXR1cm4gYEFscmVhZHlfY2xvc2VkXG4gIHwgYE9rIC0+XG4gICAgbGV0JW1hcCByZXN1bHQgPVxuICAgICAgTW9uaXRvci50cnlfd2l0aCB+ZXh0cmFjdF9leG4gfnJ1bjpgU2NoZWR1bGUgfnJlc3Q6YExvZyAoZnVuICgpIC0+IGYgdC5maWxlX2Rlc2NyKVxuICAgIGluXG4gICAgU2NoZWR1bGVyLmRlY19udW1fYWN0aXZlX3N5c2NhbGxzX2ZkICh0aGVfb25lX2FuZF9vbmx5ICgpKSB0O1xuICAgIChtYXRjaCByZXN1bHQgd2l0aFxuICAgICB8IE9rIHggLT4gYE9rIHhcbiAgICAgfCBFcnJvciBlIC0+IGBFcnJvciBlKVxuOztcblxubGV0IHdpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZF9yZXN1bHQgdCBmID1cbiAgbWF0Y2glbWFwIHdpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZCB0IGYgd2l0aFxuICB8IGBBbHJlYWR5X2Nsb3NlZCAtPiBgQWxyZWFkeV9jbG9zZWRcbiAgfCBgT2sgKE9rIHgpIC0+IGBPayB4XG4gIHwgYE9rIChFcnJvciBleG4pIC0+IGBFcnJvciBleG5cbiAgfCBgRXJyb3IgZXhuIC0+IGBFcnJvciBleG5cbjs7XG5cbmxldCB3aXRoX2ZpbGVfZGVzY3JfZGVmZXJyZWRfZXhuIHQgZiA9XG4gIG1hdGNoJW1hcCB3aXRoX2ZpbGVfZGVzY3JfZGVmZXJyZWQgdCBmIHdpdGhcbiAgfCBgT2sgeCAtPiB4XG4gIHwgYEVycm9yIGV4biAtPiByYWlzZSBleG5cbiAgfCBgQWxyZWFkeV9jbG9zZWQgLT5cbiAgICByYWlzZV9zIFslbWVzc2FnZSBcIkZkLndpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZF9leG4gZ290IGNsb3NlZCBmZFwiIH5fOih0IDogdF9odW0pXVxuOztcblxubGV0IHN0YXJ0X3dhdGNoaW5nIHQgcmVhZF9vcl93cml0ZSB3YXRjaGluZyA9XG4gIGlmIGRlYnVnXG4gIHRoZW5cbiAgICBEZWJ1Zy5sb2cgXCJGZC5zdGFydF93YXRjaGluZ1wiICh0LCByZWFkX29yX3dyaXRlKSBbJXNleHBfb2Y6IHQgKiBSZWFkX3dyaXRlX3BhaXIuS2V5LnRdO1xuICBsZXQgciA9IHRoZV9vbmVfYW5kX29ubHkgKCkgaW5cbiAgbWF0Y2ggU2NoZWR1bGVyLnJlcXVlc3Rfc3RhcnRfd2F0Y2hpbmcgciB0IHJlYWRfb3Jfd3JpdGUgd2F0Y2hpbmcgd2l0aFxuICB8IChgVW5zdXBwb3J0ZWQgfCBgQWxyZWFkeV9jbG9zZWQgfCBgV2F0Y2hpbmcpIGFzIHggLT4geFxuICB8IGBBbHJlYWR5X3dhdGNoaW5nIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiY2Fubm90IHdhdGNoIGFuIGZkIGFscmVhZHkgYmVpbmcgd2F0Y2hlZFwiXG4gICAgICAgICAgfmZkOih0IDogdClcbiAgICAgICAgICB+c2NoZWR1bGVyOihyIDogU2NoZWR1bGVyLnQpXVxuOztcblxubGV0IHN0b3Bfd2F0Y2hpbmdfdXBvbl9pbnRlcnJ1cHQgdCByZWFkX29yX3dyaXRlIGl2YXIgfmludGVycnVwdCA9XG4gIHVwb25cbiAgICAoY2hvb3NlXG4gICAgICAgWyBjaG9pY2UgaW50ZXJydXB0IChmdW4gKCkgLT4gYEludGVycnVwdGVkKVxuICAgICAgIDsgY2hvaWNlIChJdmFyLnJlYWQgaXZhcikgKGZ1biBfIC0+IGBOb3RfaW50ZXJydXB0ZWQpXG4gICAgICAgXSlcbiAgICAoZnVuY3Rpb25cbiAgICAgfCBgTm90X2ludGVycnVwdGVkIC0+ICgpXG4gICAgIHwgYEludGVycnVwdGVkIC0+XG4gICAgICAgaWYgSXZhci5pc19lbXB0eSBpdmFyXG4gICAgICAgdGhlblxuICAgICAgICAgU2NoZWR1bGVyLnJlcXVlc3Rfc3RvcF93YXRjaGluZ1xuICAgICAgICAgICAodGhlX29uZV9hbmRfb25seSAoKSlcbiAgICAgICAgICAgdFxuICAgICAgICAgICByZWFkX29yX3dyaXRlXG4gICAgICAgICAgIGBJbnRlcnJ1cHRlZClcbjs7XG5cbmxldCBpbnRlcnJ1cHRpYmxlX3JlYWR5X3RvIHQgcmVhZF9vcl93cml0ZSB+aW50ZXJydXB0ID1cbiAgaWYgZGVidWdcbiAgdGhlblxuICAgIERlYnVnLmxvZ1xuICAgICAgXCJGZC5pbnRlcnJ1cHRpYmxlX3JlYWR5X3RvXCJcbiAgICAgICh0LCByZWFkX29yX3dyaXRlKVxuICAgICAgWyVzZXhwX29mOiB0ICogUmVhZF93cml0ZV9wYWlyLktleS50XTtcbiAgbGV0IHJlYWR5ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbWF0Y2ggc3RhcnRfd2F0Y2hpbmcgdCByZWFkX29yX3dyaXRlIChXYXRjaF9vbmNlIHJlYWR5KSB3aXRoXG4gIHwgYEFscmVhZHlfY2xvc2VkIC0+IHJldHVybiBgQ2xvc2VkXG4gIHwgYFVuc3VwcG9ydGVkIC0+XG4gICAgcmV0dXJuIChpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIGludGVycnVwdCB0aGVuIGBJbnRlcnJ1cHRlZCBlbHNlIGBSZWFkeSlcbiAgfCBgV2F0Y2hpbmcgLT5cbiAgICBzdG9wX3dhdGNoaW5nX3Vwb25faW50ZXJydXB0IHQgcmVhZF9vcl93cml0ZSByZWFkeSB+aW50ZXJydXB0O1xuICAgIERlZmVycmVkLm1hcCAoSXZhci5yZWFkIHJlYWR5KSB+ZjooZnVuY3Rpb25cbiAgICAgIHwgYFVuc3VwcG9ydGVkIC0+IGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgaW50ZXJydXB0IHRoZW4gYEludGVycnVwdGVkIGVsc2UgYFJlYWR5XG4gICAgICB8IChgQmFkX2ZkIHwgYENsb3NlZCB8IGBJbnRlcnJ1cHRlZCB8IGBSZWFkeSkgYXMgcmVzIC0+IHJlcylcbjs7XG5cbmxldCByZWFkeV90byB0IHJlYWRfb3Jfd3JpdGUgPVxuICBpZiBkZWJ1Z1xuICB0aGVuIERlYnVnLmxvZyBcIkZkLnJlYWR5X3RvXCIgKHQsIHJlYWRfb3Jfd3JpdGUpIFslc2V4cF9vZjogdCAqIFJlYWRfd3JpdGVfcGFpci5LZXkudF07XG4gIGxldCByZWFkeSA9IEl2YXIuY3JlYXRlICgpIGluXG4gIG1hdGNoIHN0YXJ0X3dhdGNoaW5nIHQgcmVhZF9vcl93cml0ZSAoV2F0Y2hfb25jZSByZWFkeSkgd2l0aFxuICB8IGBBbHJlYWR5X2Nsb3NlZCAtPiByZXR1cm4gYENsb3NlZFxuICB8IGBVbnN1cHBvcnRlZCAtPiByZXR1cm4gYFJlYWR5XG4gIHwgYFdhdGNoaW5nIC0+XG4gICAgKG1hdGNoJW1hcCBJdmFyLnJlYWQgcmVhZHkgd2l0aFxuICAgICB8IGBVbnN1cHBvcnRlZCAtPiBgUmVhZHlcbiAgICAgfCAoYEJhZF9mZCB8IGBDbG9zZWQgfCBgUmVhZHkpIGFzIHggLT4geFxuICAgICB8IGBJbnRlcnJ1cHRlZCAtPiAoKiBpbXBvc3NpYmxlICopIGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCBpbnRlcnJ1cHRpYmxlX2V2ZXJ5X3JlYWR5X3RvIHQgcmVhZF9vcl93cml0ZSB+aW50ZXJydXB0IGYgeCA9XG4gIGlmIGRlYnVnXG4gIHRoZW5cbiAgICBEZWJ1Zy5sb2dcbiAgICAgIFwiRmQuaW50ZXJydXB0aWJsZV9ldmVyeV9yZWFkeV90b1wiXG4gICAgICAodCwgcmVhZF9vcl93cml0ZSlcbiAgICAgIFslc2V4cF9vZjogdCAqIFJlYWRfd3JpdGVfcGFpci5LZXkudF07XG4gIGxldCBqb2IgPSBTY2hlZHVsZXIuKGNyZWF0ZV9qb2IgKHQgKCkpKSBmIHggaW5cbiAgbGV0IGZpbmlzaGVkID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbWF0Y2ggc3RhcnRfd2F0Y2hpbmcgdCByZWFkX29yX3dyaXRlIChXYXRjaF9yZXBlYXRlZGx5IChqb2IsIGZpbmlzaGVkKSkgd2l0aFxuICB8IGBBbHJlYWR5X2Nsb3NlZCAtPiByZXR1cm4gYENsb3NlZFxuICB8IGBVbnN1cHBvcnRlZCAtPiByZXR1cm4gYFVuc3VwcG9ydGVkXG4gIHwgYFdhdGNoaW5nIC0+XG4gICAgc3RvcF93YXRjaGluZ191cG9uX2ludGVycnVwdCB0IHJlYWRfb3Jfd3JpdGUgZmluaXNoZWQgfmludGVycnVwdDtcbiAgICAoSXZhci5yZWFkIGZpbmlzaGVkIDo+IFsgYEJhZF9mZCB8IGBDbG9zZWQgfCBgVW5zdXBwb3J0ZWQgfCBgSW50ZXJydXB0ZWQgXSBEZWZlcnJlZC50KVxuOztcblxubGV0IGV2ZXJ5X3JlYWR5X3RvIHQgcmVhZF9vcl93cml0ZSBmIHggPVxuICBpZiBkZWJ1Z1xuICB0aGVuXG4gICAgRGVidWcubG9nIFwiRmQuZXZlcnlfcmVhZHlfdG9cIiAodCwgcmVhZF9vcl93cml0ZSkgWyVzZXhwX29mOiB0ICogUmVhZF93cml0ZV9wYWlyLktleS50XTtcbiAgbGV0IGpvYiA9IFNjaGVkdWxlci4oY3JlYXRlX2pvYiAodCAoKSkpIGYgeCBpblxuICBsZXQgZmluaXNoZWQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBtYXRjaCBzdGFydF93YXRjaGluZyB0IHJlYWRfb3Jfd3JpdGUgKFdhdGNoX3JlcGVhdGVkbHkgKGpvYiwgZmluaXNoZWQpKSB3aXRoXG4gIHwgYEFscmVhZHlfY2xvc2VkIC0+IHJldHVybiBgQ2xvc2VkXG4gIHwgYFVuc3VwcG9ydGVkIC0+IHJldHVybiBgVW5zdXBwb3J0ZWRcbiAgfCBgV2F0Y2hpbmcgLT5cbiAgICAobWF0Y2glbWFwIEl2YXIucmVhZCBmaW5pc2hlZCB3aXRoXG4gICAgIHwgKGBVbnN1cHBvcnRlZCB8IGBCYWRfZmQgfCBgQ2xvc2VkKSBhcyB4IC0+IHhcbiAgICAgfCBgSW50ZXJydXB0ZWQgLT4gKCogaW1wb3NzaWJsZSAqKSBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgc3lzY2FsbF9pbl90aHJlYWQgdCB+bmFtZSBmID1cbiAgbWF0Y2glbWFwXG4gICAgd2l0aF9maWxlX2Rlc2NyX2RlZmVycmVkIHQgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgICBJbl90aHJlYWQuc3lzY2FsbCB+bmFtZSAoZnVuICgpIC0+IGYgZmlsZV9kZXNjcikpXG4gIHdpdGhcbiAgfCBgRXJyb3IgZSAtPlxuICAgICgqIFtJbl90aHJlYWQuc3lzY2FsbF0gY2F0Y2hlcyBhbnkgZXhjZXB0aW9ucyBbZl0gY2FuIHJhaXNlLCBzbyB0aGlzIGNhbiBvbmx5IGJlXG4gICAgICAgcmVhY2hlZCB3aGVuIHRoZXJlJ3Mgc29tZXRoaW5nIHdyb25nIHdpdGggdGhlIFtJbl90aHJlYWRdIG1hY2hpbmVyeSBpdHNlbGYuICopXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlIFwiRmQuc3lzY2FsbF9pbl90aHJlYWQgcHJvYmxlbSAtLSBwbGVhc2UgcmVwb3J0IHRoaXNcIiBuYW1lIH5fOihlIDogZXhuKV1cbiAgfCBgQWxyZWFkeV9jbG9zZWQgLT4gYEFscmVhZHlfY2xvc2VkXG4gIHwgYE9rIHggLT5cbiAgICAobWF0Y2ggeCB3aXRoXG4gICAgIHwgT2sgeCAtPiBgT2sgeFxuICAgICB8IEVycm9yIGV4biAtPiBgRXJyb3IgZXhuKVxuOztcblxubGV0IHN5c2NhbGxfaW5fdGhyZWFkX2V4biB0IH5uYW1lIGYgPVxuICBtYXRjaCVtYXAgc3lzY2FsbF9pbl90aHJlYWQgdCB+bmFtZSBmIHdpdGhcbiAgfCBgT2sgeCAtPiB4XG4gIHwgYEVycm9yIGV4biAtPiByYWlzZSBleG5cbiAgfCBgQWxyZWFkeV9jbG9zZWQgLT5cbiAgICByYWlzZV9zIFslbWVzc2FnZSBcIkZkLnN5c2NhbGxfaW5fdGhyZWFkX2V4biBvZiBhIGNsb3NlZCBmZFwiIG5hbWUgfl86KHQgOiB0X2h1bSldXG47O1xuXG5sZXQgb2ZfaW5fY2hhbm5lbCBpYyBraW5kID1cbiAgY3JlYXRlIGtpbmQgKFVuaXguZGVzY3Jfb2ZfaW5fY2hhbm5lbCBpYykgKEluZm8ub2Zfc3RyaW5nIFwiPG9mX2luX2NoYW5uZWw+XCIpXG47O1xuXG5sZXQgb2Zfb3V0X2NoYW5uZWwgb2Mga2luZCA9XG4gIGNyZWF0ZSBraW5kIChVbml4LmRlc2NyX29mX291dF9jaGFubmVsIG9jKSAoSW5mby5vZl9zdHJpbmcgXCI8b2Zfb3V0X2NoYW5uZWw+XCIpXG47O1xuXG5sZXQgb2ZfaW5fY2hhbm5lbF9hdXRvIGljID1cbiAgS2luZC5pbmZlcl91c2luZ19zdGF0IChVbml4LmRlc2NyX29mX2luX2NoYW5uZWwgaWMpID4+fCBvZl9pbl9jaGFubmVsIGljXG47O1xuXG5sZXQgb2Zfb3V0X2NoYW5uZWxfYXV0byBvYyA9XG4gIEtpbmQuaW5mZXJfdXNpbmdfc3RhdCAoVW5peC5kZXNjcl9vZl9vdXRfY2hhbm5lbCBvYykgPj58IG9mX291dF9jaGFubmVsIG9jXG47O1xuXG5sZXQgZmlsZV9kZXNjcl9leG4gdCA9XG4gIGlmIGlzX2Nsb3NlZCB0XG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJGZC5maWxlX2Rlc2NyX2V4biBvbiBhbHJlYWR5IGNsb3NlZCBmZFwiIH5fOih0IDogdCldXG4gIGVsc2UgdC5maWxlX2Rlc2NyXG47O1xuXG5sZXQgdG9faW50X2V4biB0ID0gRmlsZV9kZXNjci50b19pbnQgKGZpbGVfZGVzY3JfZXhuIHQpXG5cbmxldCBleHBlY3RfZmlsZV9kZXNjcl9yZWRpcmVjdGlvbl9mb3JfZmQgZmQgfmYgPVxuICBpZiBmZC5udW1fYWN0aXZlX3N5c2NhbGxzID4gMFxuICB0aGVuIHJhaXNlX3MgWyVzZXhwIFwiRmlsZSBkZXNjcmlwdG9yIGNhbid0IGJlIHJlZGlyZWN0ZWQgd2hpbGUgaW4gdXNlXCIsIChmZCA6IHQpXTtcbiAgRXhuLnByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPlxuICAgIGZkLmtpbmQgPC0gS2luZC5ibG9ja2luZ19pbmZlcl91c2luZ19zdGF0IGZkLmZpbGVfZGVzY3IpXG47O1xuXG5sZXQgZXhwZWN0X2ZpbGVfZGVzY3JfcmVkaXJlY3Rpb24gZmlsZV9kZXNjciB+ZiA9XG4gIGxldCBmZF9ieV9kZXNjciA9IFJhd19zY2hlZHVsZXIuZmRfYnlfZGVzY3IgKHRoZV9vbmVfYW5kX29ubHkgKCkpIGluXG4gIG1hdGNoIEJ5X2Rlc2NyLmZpbmQgZmRfYnlfZGVzY3IgZmlsZV9kZXNjciB3aXRoXG4gIHwgTm9uZSAtPiBmICgpXG4gIHwgU29tZSBmZCAtPiBleHBlY3RfZmlsZV9kZXNjcl9yZWRpcmVjdGlvbl9mb3JfZmQgZmQgfmZcbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCByZXBsYWNlIHQga2luZCBpbmZvID1cbiAgICBpZiBpc19jbG9zZWQgdFxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJGZC5yZXBsYWNlIGdvdCBjbG9zZWQgZmRcIlxuICAgICAgICAgICAgfmZkOih0IDogdClcbiAgICAgICAgICAgIChraW5kIDogS2luZC50KVxuICAgICAgICAgICAgfnNjaGVkdWxlcjoodGhlX29uZV9hbmRfb25seSAoKSA6IFNjaGVkdWxlci50KV1cbiAgICBlbHNlIChcbiAgICAgIHQua2luZCA8LSBraW5kO1xuICAgICAgdC5pbmZvXG4gICAgICAgIDwtIChtYXRjaCBpbmZvIHdpdGhcbiAgICAgICAgICAgIHwgYFNldCBpIC0+IGlcbiAgICAgICAgICAgIHwgYEV4dGVuZCBpIC0+XG4gICAgICAgICAgICAgIEluZm8uY3JlYXRlXG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlZFwiXG4gICAgICAgICAgICAgICAgKGksIGBwcmV2aW91c2x5X3dhcyB0LmluZm8pXG4gICAgICAgICAgICAgICAgWyVzZXhwX29mOiBJbmZvLnQgKiBbIGBwcmV2aW91c2x5X3dhcyBvZiBJbmZvLnQgXV0pKVxuICA7O1xuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgeyBvdXRwdXQgOiBCaWdzdHJpbmcudCAtPiBwb3M6aW50IC0+IGxlbjppbnQgLT4gdW5pdFxuICA7IGZsdXNoIDogdW5pdCAtPiB1bml0XG4gIDsgc2V4cCA6IHVuaXQgLT4gU2V4cC50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycyB+aXRlcmF0b3JzOml0ZXJdXG5cbmxldCBzZXhwX29mX3QgdCA9IHQuc2V4cCAoKVxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICBsZXQgX2NoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXIgfm91dHB1dDppZ25vcmUgfmZsdXNoOmlnbm9yZSB+c2V4cDppZ25vcmUpXG47O1xuXG5sZXQgY3JlYXRlIH5vdXRwdXQgfmZsdXNoIH5zZXhwID0geyBvdXRwdXQ7IGZsdXNoOyBzZXhwIH1cblxubGV0IG9mX291dF9jaGFubmVsIG91dF9jaGFubmVsIDogdCA9XG4gIGxldCBieXRlc19idWYgPSBCeXRlcy5vZl9zdHJpbmcgXCJcIiB8PiByZWYgaW5cbiAgY3JlYXRlXG4gICAgfm91dHB1dDooZnVuIGJ1ZiB+cG9zIH5sZW4gLT5cbiAgICAgIGlmIGxlbiA+IEJ5dGVzLmxlbmd0aCAhYnl0ZXNfYnVmIHRoZW4gYnl0ZXNfYnVmIDo9IEJ5dGVzLmNyZWF0ZSAobGVuICogMik7XG4gICAgICBCaWdzdHJpbmcuVG9fYnl0ZXMuYmxpdCB+bGVuIH5zcmM6YnVmIH5zcmNfcG9zOnBvcyB+ZHN0OiFieXRlc19idWYgfmRzdF9wb3M6MDtcbiAgICAgIE91dF9jaGFubmVsLm91dHB1dCBvdXRfY2hhbm5lbCB+YnVmOiFieXRlc19idWYgfnBvczowIH5sZW4pXG4gICAgfmZsdXNoOihmdW4gKCkgLT4gT3V0X2NoYW5uZWwuZmx1c2ggb3V0X2NoYW5uZWwpXG4gICAgfnNleHA6KGZ1biAoKSAtPiBbJXNleHAgeyBvdXRfY2hhbm5lbCA6IE91dF9jaGFubmVsLnQgfV0pXG47O1xuXG5sZXQgb3V0cHV0X2lvdmVjIHQgKGlvdmVjIDogQmlnc3RyaW5nLnQgQ29yZV91bml4LklPVmVjLnQpID1cbiAgdC5vdXRwdXQgaW92ZWMuYnVmIH5wb3M6aW92ZWMucG9zIH5sZW46aW92ZWMubGVuXG47O1xuXG5sZXQgZmx1c2ggdCA9IHQuZmx1c2ggKClcbiIsIm9wZW4hIENvcmVcbm9wZW4gSW1wb3J0XG5cbnR5cGUgdCA9IElvX3VyaW5nX3Jhdy50XG5cbmxldCBjcmVhdGUgPSBJb191cmluZ19yYXcuY3JlYXRlXG5sZXQgZXhpdCA9IElvX3VyaW5nX3Jhdy5leGl0XG5sZXQgc3VibWl0ID0gSW9fdXJpbmdfcmF3LnN1Ym1pdFxubGV0IGZpbGxfY29tcGxldGlvbnMgPSBJb191cmluZ19yYXcuZmlsbF9jb21wbGV0aW9uc1xubGV0IHRoZV9vbmVfYW5kX29ubHkgPSBJb191cmluZ19yYXdfc2luZ2xldG9uLnRoZV9vbmVfYW5kX29ubHlcbmxldCBtYXhfdHJpZXMgPSAxMDAwXG5cbmxldCByZWMgYXR0ZW1wdF9zeXNjYWxsX2ludGVybmFsIGYgY291bnQgPVxuICBpZiBjb3VudCA9IG1heF90cmllcyB0aGVuIGZhaWx3aXRoIFwic3lzY2FsbCBpbnRlcnJ1cHRlZCB0b28gbWFueSB0aW1lc1wiO1xuICBtYXRjaCViaW5kIElvX3VyaW5nX3Jhdy5zeXNjYWxsX3Jlc3VsdCAoZiAoKSkgd2l0aFxuICB8IEVycm9yIFVuaXguRXJyb3IuRUlOVFIgLT5cbiAgICAoKiBXZSBkb24ndCBrbm93IGlmIGlvX3VyaW5nIGNvbXBsZXRpb25zIGNhbiBhY3R1YWxseSByZXR1cm4gW0VJTlRSXSAocHJvYmFibHkgbm90PyksXG4gICAgICAgc28gdGhpcyBpcyBwb3NzaWJseSBkZWFkIGNvZGUuIFRvIGJlIG9uIHRoZSBzYWZlIHNpZGUsIHdlJ3JlIGp1c3QgcmVwbGljYXRpbmcgdGhlXG4gICAgICAgdHJhZGl0aW9uYWwgcmV0cnkgbG9vcCBmcm9tIFtTeXNjYWxsLnN5c2NhbGxdLiAqKVxuICAgIGxldCViaW5kICgpID0gUmF3X3NjaGVkdWxlci55aWVsZCAoKSBpblxuICAgIGF0dGVtcHRfc3lzY2FsbF9pbnRlcm5hbCBmIChjb3VudCArIDEpXG4gIHwgRXJyb3IgZXJyIC0+IHJldHVybiAoRXJyb3IgZXJyKVxuICB8IE9rIHJlc3VsdCAtPiByZXR1cm4gKE9rIHJlc3VsdClcbjs7XG5cbmxldCBhdHRlbXB0X3N5c2NhbGwgZiA9IGF0dGVtcHRfc3lzY2FsbF9pbnRlcm5hbCBmIDBcblxubGV0IHdpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZCB+bmFtZSBmZCBmID1cbiAgbWF0Y2glbWFwIEZkLndpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZCB+ZXh0cmFjdF9leG46dHJ1ZSBmZCAoZnVuIGZkIC0+IGYgZmQpIHdpdGhcbiAgfCBgQWxyZWFkeV9jbG9zZWQgLT5cbiAgICAoKiBXZSBoYXZlIHRvIG1hdGNoIHRoZSBlcnJvciBtZXNzYWdlcyBvZiBbRmQuc3lzY2FsbF9pbl90aHJlYWRfZXhuXSBiZWNhdXNlIGlmIHdlXG4gICAgICAgZGVmYXVsdCBbQXN5bmNdIHRvIHVzaW5nIFtJb191cmluZ10sIGlubGluZSB0ZXN0cyB0aGF0IGNhdGNoIGVycm9yIG1lc3NhZ2VzXG4gICAgICAgd2lsbCBzdGFydCBmYWlsaW5nLiAqKVxuICAgIEVycm9yXG4gICAgICAodHJ5XG4gICAgICAgICByYWlzZV9zXG4gICAgICAgICAgIFslbWVzc2FnZSBcIkZkLnN5c2NhbGxfaW5fdGhyZWFkX2V4biBvZiBhIGNsb3NlZCBmZFwiIG5hbWUgfl86KGZkIDogRmQudF9odW0pXVxuICAgICAgIHdpdGhcbiAgICAgICB8IGV4biAtPiBleG4pXG4gIHwgYEVycm9yIGV4biAtPiByYWlzZSBleG5cbiAgfCBgT2sgb2sgLT4gb2tcbjs7XG5cbmxldCB3aXRoX2ZpbGVfZGVzY3JfZGVmZXJyZWRfb3B0IH5uYW1lIGZkX29wdCB+ZiA9XG4gIG1hdGNoIGZkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBmIE5vbmVcbiAgfCBTb21lIGZkIC0+IHdpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZCB+bmFtZSBmZCAoZnVuIGZkIC0+IGYgKFNvbWUgZmQpKVxuOztcblxubGV0IHJlYWRfZmlsZV9kZXNjciB0ID8oZmlsZV9vZmZzZXQgPSAtMSkgZmlsZV9kZXNjciA/b2ZmID9sZW4gYnVmID1cbiAgbWF0Y2glbWFwXG4gICAgYXR0ZW1wdF9zeXNjYWxsIChmdW4gKCkgLT5cbiAgICAgIElvX3VyaW5nX3Jhdy5yZWFkXG4gICAgICAgIHRcbiAgICAgICAgfmZpbGVfb2Zmc2V0OihJb191cmluZ19yYXcuSW50NjMub2ZfaW50IGZpbGVfb2Zmc2V0KVxuICAgICAgICBmaWxlX2Rlc2NyXG4gICAgICAgIChDc3RydWN0Lm9mX2JpZ2FycmF5ID9vZmYgP2xlbiBidWYpKVxuICB3aXRoXG4gIHwgRXJyb3IgZXJyIC0+IEVycm9yIChVbml4LlVuaXhfZXJyb3IgKGVyciwgXCJyZWFkXCIsIFwiXCIpKVxuICB8IE9rIHJlcyAtPiBPayByZXNcbjs7XG5cbmxldCByZWFkIHQgPyhmaWxlX29mZnNldCA9IC0xKSBmZCA/b2ZmID9sZW4gYnVmID1cbiAgd2l0aF9maWxlX2Rlc2NyX2RlZmVycmVkIH5uYW1lOlwicmVhZFwiIGZkIChmdW4gZmQgLT5cbiAgICByZWFkX2ZpbGVfZGVzY3IgdCB+ZmlsZV9vZmZzZXQgZmQgP29mZiA/bGVuIGJ1Zilcbjs7XG5cbmxldCB3cml0ZSB0ID8oZmlsZV9vZmZzZXQgPSAtMSkgZmQgP29mZiA/bGVuIGJ1ZiA9XG4gIHdpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZCB+bmFtZTpcIndyaXRlXCIgZmQgKGZ1biBmZCAtPlxuICAgIG1hdGNoJW1hcFxuICAgICAgYXR0ZW1wdF9zeXNjYWxsIChmdW4gKCkgLT5cbiAgICAgICAgSW9fdXJpbmdfcmF3LndyaXRlXG4gICAgICAgICAgdFxuICAgICAgICAgIH5maWxlX29mZnNldDooSW9fdXJpbmdfcmF3LkludDYzLm9mX2ludCBmaWxlX29mZnNldClcbiAgICAgICAgICBmZFxuICAgICAgICAgIChDc3RydWN0Lm9mX2JpZ2FycmF5ID9vZmYgP2xlbiBidWYpKVxuICAgIHdpdGhcbiAgICB8IEVycm9yIGVyciAtPiBFcnJvciAoVW5peC5Vbml4X2Vycm9yIChlcnIsIFwid3JpdGVcIiwgXCJcIikpXG4gICAgfCBPayByZXMgLT4gT2sgcmVzKVxuOztcblxubGV0IHRvX2NzdHJ1Y3QgKGlvdmVjcyA6IEJpZ3N0cmluZy50IENvcmVfdW5peC5JT1ZlYy50IGFycmF5KSA9XG4gIEFycmF5LnRvX2xpc3QgaW92ZWNzXG4gIHw+IExpc3QubWFwIH5mOihmdW4geyBidWY7IHBvczsgbGVuIH0gLT4gQ3N0cnVjdC5vZl9iaWdhcnJheSB+b2ZmOnBvcyB+bGVuIGJ1Zilcbjs7XG5cbmxldCByZWFkdiB0ID8oZmlsZV9vZmZzZXQgPSAtMSkgZmQgYnVmcyA9XG4gIHdpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZCB+bmFtZTpcInJlYWR2XCIgZmQgKGZ1biBmZCAtPlxuICAgIG1hdGNoJW1hcFxuICAgICAgYXR0ZW1wdF9zeXNjYWxsIChmdW4gKCkgLT5cbiAgICAgICAgSW9fdXJpbmdfcmF3LnJlYWR2XG4gICAgICAgICAgdFxuICAgICAgICAgIH5maWxlX29mZnNldDooSW9fdXJpbmdfcmF3LkludDYzLm9mX2ludCBmaWxlX29mZnNldClcbiAgICAgICAgICBmZFxuICAgICAgICAgICh0b19jc3RydWN0IGJ1ZnMpKVxuICAgIHdpdGhcbiAgICB8IEVycm9yIGVyciAtPiBFcnJvciAoVW5peC5Vbml4X2Vycm9yIChlcnIsIFwicmVhZHZcIiwgXCJcIikpXG4gICAgfCBPayByZXMgLT4gT2sgcmVzKVxuOztcblxubGV0IHdyaXRldiB0ID8oZmlsZV9vZmZzZXQgPSAtMSkgZmQgKGJ1ZnMgOiBCaWdzdHJpbmcudCBDb3JlX3VuaXguSU9WZWMudCBhcnJheSkgPVxuICB3aXRoX2ZpbGVfZGVzY3JfZGVmZXJyZWQgfm5hbWU6XCJ3cml0ZXZcIiBmZCAoZnVuIGZkIC0+XG4gICAgbWF0Y2glbWFwXG4gICAgICBhdHRlbXB0X3N5c2NhbGwgKGZ1biAoKSAtPlxuICAgICAgICBJb191cmluZ19yYXcud3JpdGV2XG4gICAgICAgICAgdFxuICAgICAgICAgIH5maWxlX29mZnNldDooSW9fdXJpbmdfcmF3LkludDYzLm9mX2ludCBmaWxlX29mZnNldClcbiAgICAgICAgICBmZFxuICAgICAgICAgICh0b19jc3RydWN0IGJ1ZnMpKVxuICAgIHdpdGhcbiAgICB8IEVycm9yIGVyciAtPiBFcnJvciAoVW5peC5Vbml4X2Vycm9yIChlcnIsIFwid3JpdGV2XCIsIFwiXCIpKVxuICAgIHwgT2sgcmVzIC0+IE9rIHJlcylcbjs7XG5cbmxldCBvcGVuYXQyIHQgfmFjY2VzcyB+ZmxhZ3MgPyhwZXJtID0gMG82NDQpIH5yZXNvbHZlID9pbmZvID9mZCBmaWxlbmFtZSA9XG4gIGxldCBwZXJtID1cbiAgICBsZXQgb3BlbiBJb191cmluZ19yYXcuT3Blbl9mbGFncyBpblxuICAgIGlmIG1lbSBjcmVhdCBmbGFncyB8fCBtZW0gdG1wZmlsZSBmbGFncyB0aGVuIHBlcm0gZWxzZSAwXG4gIGluXG4gIGxldCBpbmZvID0gT3B0aW9uLnZhbHVlIGluZm8gfmRlZmF1bHQ6KEluZm8uY3JlYXRlX3MgWyVzZXhwIChmaWxlbmFtZSA6IHN0cmluZyldKSBpblxuICBsZXQgb3BlbmF0Ml9zeXNjYWxsIGZkX29wdCA9XG4gICAgYXR0ZW1wdF9zeXNjYWxsIChmdW4gKCkgLT5cbiAgICAgIElvX3VyaW5nX3Jhdy5vcGVuYXQyIHQgfmFjY2VzcyB+ZmxhZ3MgfnBlcm0gfnJlc29sdmUgP2ZkOmZkX29wdCBmaWxlbmFtZSlcbiAgaW5cbiAgbGV0IGZhaWx1cmVfZXJyb3IgZXJyID0gVW5peC5Vbml4X2Vycm9yIChlcnIsIFwib3BlblwiLCBJbmZvLnRvX3N0cmluZ19tYWNoIGluZm8pIGluXG4gIGxldCBzdWNjZXNzX2ZkIHJlcyA9IEZkLmNyZWF0ZSBGZC5LaW5kLkZpbGUgKEZpbGVfZGVzY3Iub2ZfaW50IHJlcykgaW5mbyBpblxuICB3aXRoX2ZpbGVfZGVzY3JfZGVmZXJyZWRfb3B0IH5uYW1lOlwib3BlblwiIGZkIH5mOihmdW4gZmQgLT5cbiAgICBtYXRjaCVtYXAgb3BlbmF0Ml9zeXNjYWxsIGZkIHdpdGhcbiAgICB8IEVycm9yIGVyciAtPiBFcnJvciAoZmFpbHVyZV9lcnJvciBlcnIpXG4gICAgfCBPayByZXMgLT4gT2sgKHN1Y2Nlc3NfZmQgcmVzKSlcbjs7XG5cbmxldCB1bmxpbmsgdCB+ZGlyID9mZCBmaWxlbmFtZSA9XG4gIGxldCB1bmxpbmtfc3lzY2FsbCBmZF9vcHQgPVxuICAgIGF0dGVtcHRfc3lzY2FsbCAoZnVuICgpIC0+IElvX3VyaW5nX3Jhdy51bmxpbmsgdCB+ZGlyID9mZDpmZF9vcHQgZmlsZW5hbWUpXG4gIGluXG4gIGxldCB0b19leG4gZXJyID1cbiAgICBVbml4LlVuaXhfZXJyb3JcbiAgICAgIChlcnIsIFwidW5saW5rXCIsIENvcmVfdW5peC5Qcml2YXRlLnNleHBfdG9fc3RyaW5nX2h1bSBbJXNleHAgeyBmaWxlbmFtZSA6IHN0cmluZyB9XSlcbiAgaW5cbiAgd2l0aF9maWxlX2Rlc2NyX2RlZmVycmVkX29wdCBmZCB+bmFtZTpcInVubGlua1wiIH5mOihmdW4gZmQgLT5cbiAgICBtYXRjaCVtYXAgdW5saW5rX3N5c2NhbGwgZmQgd2l0aFxuICAgIHwgRXJyb3IgZXJyIC0+IEVycm9yICh0b19leG4gZXJyKVxuICAgIHwgT2sgXyAtPiBPayAoKSlcbjs7XG5cbigqIFRoZSBbZm9yY2VdIGNhc2UgZm9yIHRoaXMgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQgdGhpcyB3YXkgaW4gb3JkZXIgdG8gYWxpZ24gd2l0aCB0aGVcbiAgIFtVbml4X3N5c2NhbGxzXSBlcnJvciBtZXNzYWdlIHdoaWNoIG91dHB1dHMgdGhlIGFyZ3VtZW50cyBvZiB0aGUgW2xpbmtdIGluIHRoZSBjYXNlXG4gICBbdW5saW5rXSBmYWlscy5cbiopXG5sZXQgbGluayB0ID8oZm9sbG93ID0gZmFsc2UpID8oZm9yY2UgPSBmYWxzZSkgfnRhcmdldCB+bGlua19uYW1lICgpID1cbiAgbGV0IGFyZ3NfZm9yX2Vycm9yICgpID1cbiAgICBDb3JlX3VuaXguUHJpdmF0ZS5zZXhwX3RvX3N0cmluZ19odW0gWyVzZXhwIHsgdGFyZ2V0IDogc3RyaW5nOyBsaW5rX25hbWUgOiBzdHJpbmcgfV1cbiAgaW5cbiAgbGV0JWJpbmQgdW5saW5rX3JlcyA9XG4gICAgbWF0Y2ggZm9yY2Ugd2l0aFxuICAgIHwgdHJ1ZSAtPlxuICAgICAgKG1hdGNoJW1hcCB1bmxpbmsgdCB+ZGlyOmZhbHNlIGxpbmtfbmFtZSB3aXRoXG4gICAgICAgfCBFcnJvciAoVW5peC5Vbml4X2Vycm9yIChVbml4LkVOT0VOVCwgXywgXykpIC0+IE9rICgpXG4gICAgICAgfCBFcnJvciAoVW5peC5Vbml4X2Vycm9yIChlLCBzLCBfKSkgLT5cbiAgICAgICAgIEVycm9yIChVbml4LlVuaXhfZXJyb3IgKGUsIHMsIGFyZ3NfZm9yX2Vycm9yICgpKSlcbiAgICAgICB8IEVycm9yIGV4biAtPiBFcnJvciBleG5cbiAgICAgICB8IE9rICgpIC0+IE9rICgpKVxuICAgIHwgZmFsc2UgLT4gcmV0dXJuIChPayAoKSlcbiAgaW5cbiAgbWF0Y2ggdW5saW5rX3JlcyB3aXRoXG4gIHwgRXJyb3IgZXhuIC0+IHJldHVybiAoRXJyb3IgZXhuKVxuICB8IE9rICgpIC0+XG4gICAgKG1hdGNoJW1hcFxuICAgICAgIGF0dGVtcHRfc3lzY2FsbCAoZnVuICgpIC0+IElvX3VyaW5nX3Jhdy5saW5rIHQgfmZvbGxvdyB+dGFyZ2V0IH5saW5rX25hbWUpXG4gICAgIHdpdGhcbiAgICAgfCBFcnJvciBlcnIgLT4gRXJyb3IgKFVuaXguVW5peF9lcnJvciAoZXJyLCBcImxpbmtcIiwgYXJnc19mb3JfZXJyb3IgKCkpKVxuICAgICB8IE9rIF8gLT4gT2sgKCkpXG47O1xuXG5sZXQgZG9fc3RhdHggdCA/ZmQgPyhtYXNrID0gSW9fdXJpbmdfcmF3LlN0YXR4Lk1hc2suYmFzaWNfc3RhdHMpIHBhdGggZmxhZ3MgPVxuICBsZXQgc3RhdHhfYnVmZmVyID0gSW9fdXJpbmdfcmF3LlN0YXR4LmNyZWF0ZSAoKSBpblxuICBtYXRjaCVtYXBcbiAgICBhdHRlbXB0X3N5c2NhbGwgKGZ1biAoKSAtPiBJb191cmluZ19yYXcuc3RhdHggdCA/ZmQgfm1hc2sgcGF0aCBzdGF0eF9idWZmZXIgZmxhZ3MpXG4gIHdpdGhcbiAgfCBFcnJvciBlcnIgLT4gRXJyb3IgZXJyXG4gIHwgT2sgcmVzIC0+XG4gICAgYXNzZXJ0IChyZXMgPSAwKTtcbiAgICBPayBzdGF0eF9idWZmZXJcbjs7XG5cbmxldCBzdGF0eCB0ID9mZCA/KG1hc2sgPSBJb191cmluZ19yYXcuU3RhdHguTWFzay5iYXNpY19zdGF0cykgcGF0aCBmbGFncyA9XG4gIGxldCBzdGF0eF9zeXNjYWxsIGZkX29wdCA9IGRvX3N0YXR4IHQgP2ZkOmZkX29wdCB+bWFzayBwYXRoIGZsYWdzIGluXG4gIGxldCBmYWlsdXJlX2Vycm9yIGVyciA9XG4gICAgVW5peC5Vbml4X2Vycm9yXG4gICAgICAoIGVyclxuICAgICAgLCBcInN0YXR4XCJcbiAgICAgICwgQ29yZV91bml4LlByaXZhdGUuc2V4cF90b19zdHJpbmdfaHVtIFslc2V4cCB7IGZkIDogRmQudCBvcHRpb247IHBhdGggOiBzdHJpbmcgfV1cbiAgICAgIClcbiAgaW5cbiAgd2l0aF9maWxlX2Rlc2NyX2RlZmVycmVkX29wdCB+bmFtZTpcInN0YXR4XCIgZmQgfmY6KGZ1biBmZCAtPlxuICAgIG1hdGNoJW1hcCBzdGF0eF9zeXNjYWxsIGZkIHdpdGhcbiAgICB8IEVycm9yIGVyciAtPiBFcnJvciAoZmFpbHVyZV9lcnJvciBlcnIpXG4gICAgfCBPayByZXMgLT4gT2sgcmVzKVxuOztcblxubGV0IHN0YXQgdCA/bWFzayBmaWxlbmFtZSA9XG4gIG1hdGNoJW1hcCBkb19zdGF0eCB0ID9tYXNrIGZpbGVuYW1lIElvX3VyaW5nX3Jhdy5TdGF0eC5GbGFncy5lbXB0eSB3aXRoXG4gIHwgRXJyb3IgZXJyIC0+XG4gICAgRXJyb3JcbiAgICAgIChVbml4LlVuaXhfZXJyb3JcbiAgICAgICAgIChlcnIsIFwic3RhdFwiLCBDb3JlX3VuaXguUHJpdmF0ZS5zZXhwX3RvX3N0cmluZ19odW0gWyVzZXhwIHsgZmlsZW5hbWUgOiBzdHJpbmcgfV0pKVxuICB8IE9rIHJlcyAtPiBPayByZXNcbjs7XG5cbmxldCBmc3RhdCB0ID9tYXNrIGZkID1cbiAgd2l0aF9maWxlX2Rlc2NyX2RlZmVycmVkIH5uYW1lOlwiZnN0YXRcIiBmZCAoZnVuIGZkIC0+XG4gICAgbWF0Y2glbWFwIGRvX3N0YXR4IHQgP21hc2sgfmZkIFwiXCIgSW9fdXJpbmdfcmF3LlN0YXR4LkZsYWdzLmVtcHR5X3BhdGggd2l0aFxuICAgIHwgT2sgcmVzIC0+IE9rIHJlc1xuICAgIHwgRXJyb3IgZXJyIC0+XG4gICAgICBFcnJvclxuICAgICAgICAoVW5peC5Vbml4X2Vycm9yXG4gICAgICAgICAgICggZXJyXG4gICAgICAgICAgICwgXCJmc3RhdFwiXG4gICAgICAgICAgICwgQ29yZV91bml4LlByaXZhdGUuc2V4cF90b19zdHJpbmdfaHVtIFslc2V4cCB7IGZkIDogRmlsZV9kZXNjci50IH1dICkpKVxuOztcblxubGV0IGxzdGF0IHQgP21hc2sgZmlsZW5hbWUgPVxuICBtYXRjaCVtYXAgZG9fc3RhdHggdCA/bWFzayBmaWxlbmFtZSBJb191cmluZ19yYXcuU3RhdHguRmxhZ3Muc3ltbGlua19ub2ZvbGxvdyB3aXRoXG4gIHwgT2sgcmVzIC0+IE9rIHJlc1xuICB8IEVycm9yIGVyciAtPlxuICAgIEVycm9yXG4gICAgICAoVW5peC5Vbml4X2Vycm9yXG4gICAgICAgICAoZXJyLCBcImxzdGF0XCIsIENvcmVfdW5peC5Qcml2YXRlLnNleHBfdG9fc3RyaW5nX2h1bSBbJXNleHAgeyBmaWxlbmFtZSA6IHN0cmluZyB9XSkpXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxub3BlbiBSYXdfc2NoZWR1bGVyXG5cbmxldCBkZWJ1ZyA9IERlYnVnLnRocmVhZF9zYWZlXG5cbmxldCBydW5faG9sZGluZ19hc3luY19sb2NrXG4gICh0eXBlIGEgYilcbiAgPyh3YWtldXBfc2NoZWR1bGVyID0gdHJ1ZSlcbiAgdFxuICAoZiA6IHVuaXQgLT4gYSlcbiAgfihmaW5pc2ggOiAoYSwgZXhuKSBSZXN1bHQudCAtPiBiKVxuICA6IGJcbiAgPVxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcInJ1bl9ob2xkaW5nX2FzeW5jX2xvY2tcIiB0IFslc2V4cF9vZjogdF07XG4gIGlmIG5vdCAoYW1faG9sZGluZ19sb2NrIHQpIHRoZW4gbG9jayB0O1xuICBwcm90ZWN0XG4gICAgfmZpbmFsbHk6KGZ1biAoKSAtPlxuICAgICAgaWYgd2FrZXVwX3NjaGVkdWxlciB0aGVuIHRocmVhZF9zYWZlX3dha2V1cF9zY2hlZHVsZXIgdDtcbiAgICAgIHVubG9jayB0KVxuICAgIH5mOihmdW4gKCkgLT5cbiAgICAgICgqIFdlIHJ1biBbZl0gd2l0aGluIHRoZSBbbWFpbl9leGVjdXRpb25fY29udGV4dF0gc28gdGhhdCBhbnkgZXJyb3JzIGFyZSBzZW50IHRvIGl0c1xuICAgICAgICAgbW9uaXRvciwgcmF0aGVyIHRoYW4gd2hhdGV2ZXIgcmFuZG9tIG1vbml0b3IgaGFwcGVuZWQgdG8gYmUgaW4gZWZmZWN0LiAqKVxuICAgICAgZmluaXNoXG4gICAgICAgICh3aXRoX2V4ZWN1dGlvbl9jb250ZXh0IHQgS2VybmVsX3NjaGVkdWxlci5tYWluX2V4ZWN1dGlvbl9jb250ZXh0IH5mOihmdW4gKCkgLT5cbiAgICAgICAgICAgUmVzdWx0LnRyeV93aXRoIGYpKSlcbjs7XG5cbmxldCBlbnN1cmVfaW5fYV90aHJlYWQgdCBmdW5jdGlvbl8gPVxuICBpZiBpc19tYWluX3RocmVhZCAoKVxuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiY2Fubm90IGNhbGwgZnJvbSB0aGUgbWFpbiB0aHJlYWRcIiAoZnVuY3Rpb25fIDogc3RyaW5nKV07XG4gIGlmIGFtX2hvbGRpbmdfbG9jayB0XG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJjYW5ub3QgY2FsbCB3aGlsZSBob2xkaW5nIHRoZSBhc3luYyBsb2NrXCIgKGZ1bmN0aW9uXyA6IHN0cmluZyldXG47O1xuXG5sZXQgcnVuX2luX2FzeW5jX3dpdGhfb3B0aW9uYWxfY3ljbGUgP3dha2V1cF9zY2hlZHVsZXIgdCBmID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJydW5faW5fYXN5bmNfd2l0aF9vcHRpb25hbF9jeWNsZVwiIHQgWyVzZXhwX29mOiB0XTtcbiAgZW5zdXJlX2luX2FfdGhyZWFkIHQgXCJydW5faW5fYXN5bmNfd2l0aF9vcHRpb25hbF9jeWNsZVwiO1xuICBydW5faG9sZGluZ19hc3luY19sb2NrID93YWtldXBfc2NoZWR1bGVyIHQgZiB+ZmluaXNoOihmdW5jdGlvblxuICAgIHwgRXJyb3IgZXhuIC0+IEVycm9yIGV4blxuICAgIHwgT2sgKG1heWJlX3J1bl9hX2N5Y2xlLCBhKSAtPlxuICAgICAgKG1hdGNoIG1heWJlX3J1bl9hX2N5Y2xlIHdpdGhcbiAgICAgICB8IGBEb19ub3RfcnVuX2FfY3ljbGUgLT4gKClcbiAgICAgICB8IGBSdW5fYV9jeWNsZSAtPiBoYXZlX2xvY2tfZG9fY3ljbGUgdCk7XG4gICAgICBPayBhKVxuOztcblxubGV0IHdpdGhfYXN5bmNfbG9jayB0IGYgPVxuICBpZiBhbV9ob2xkaW5nX2xvY2sgdFxuICB0aGVuIGYgKClcbiAgZWxzZSAoXG4gICAgbG9jayB0O1xuICAgIHByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiB1bmxvY2sgdCkpXG47O1xuXG5sZXQgd2l0aG91dF9hc3luY19sb2NrIHQgZiA9XG4gIGlmIGFtX2hvbGRpbmdfbG9jayB0XG4gIHRoZW4gKFxuICAgIHVubG9jayB0O1xuICAgIHByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiBsb2NrIHQpKVxuICBlbHNlIGYgKClcbjs7XG5cbmxldCBlbnN1cmVfdGhlX3NjaGVkdWxlcl9pc19zdGFydGVkIHQgPVxuICBpZiBub3QgKGlzX3J1bm5pbmcgdClcbiAgdGhlbiAoXG4gICAgbGV0IHN0YXJ0aW5nID1cbiAgICAgICgqIEhvbGQgdGhlIGxvY2sgd2hlbiBkZWNpZGluZyBpZiB3ZSdyZSB0aGUgZmlyc3QgdGhyZWFkIHRvIHN0YXJ0IHRoZSBzY2hlZHVsZXIuICopXG4gICAgICB3aXRoX2FzeW5jX2xvY2sgdCAoZnVuICgpIC0+XG4gICAgICAgIGlmIG5vdCAoaXNfcnVubmluZyB0KVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICB0LnN0YXJ0X3R5cGUgPC0gQ2FsbGVkX2Jsb2NrX29uX2FzeW5jO1xuICAgICAgICAgIGxldCBzY2hlZHVsZXJfcmFuX2Ffam9iID0gVGhyZWFkX3NhZmVfaXZhci5jcmVhdGUgKCkgaW5cbiAgICAgICAgICB1cG9uIChyZXR1cm4gKCkpIChmdW4gKCkgLT4gVGhyZWFkX3NhZmVfaXZhci5maWxsIHNjaGVkdWxlcl9yYW5fYV9qb2IgKCkpO1xuICAgICAgICAgIGBZZXMgc2NoZWR1bGVyX3Jhbl9hX2pvYilcbiAgICAgICAgZWxzZSBgTm8pXG4gICAgaW5cbiAgICBtYXRjaCBzdGFydGluZyB3aXRoXG4gICAgfCBgTm8gLT4gKClcbiAgICB8IGBZZXMgc2NoZWR1bGVyX3Jhbl9hX2pvYiAtPlxuICAgICAgKCogUmVsZWFzZSB0aGUgQXN5bmMgbG9jayBpZiBuZWNlc3NhcnksIHNvIHRoYXQgdGhlIHNjaGVkdWxlciBjYW4gYWNxdWlyZSBpdC4gKilcbiAgICAgIHdpdGhvdXRfYXN5bmNfbG9jayB0IChmdW4gKCkgLT5cbiAgICAgICAgaWdub3JlXG4gICAgICAgICAgKENvcmVfdGhyZWFkLmNyZWF0ZVxuICAgICAgICAgICAgIH5vbl91bmNhdWdodF9leG46YFByaW50X3RvX3N0ZGVyclxuICAgICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgIEV4bi5oYW5kbGVfdW5jYXVnaHQgfmV4aXQ6dHJ1ZSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgIGxldCAoKSA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggTGludXhfZXh0LnByX3NldF9uYW1lX2ZpcnN0MTYgd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgT2sgZiAtPiBmIFwiYXN5bmMtc2NoZWR1bGVyXCJcbiAgICAgICAgICAgICAgICAgICB8IEVycm9yIF8gLT4gKClcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgbG9jayB0O1xuICAgICAgICAgICAgICAgICBuZXZlcl9yZXR1cm5zIChiZV90aGVfc2NoZWR1bGVyIHQpKSlcbiAgICAgICAgICAgICAoKVxuICAgICAgICAgICAgOiBDb3JlX3RocmVhZC50KTtcbiAgICAgICAgKCogQmxvY2sgdW50aWwgdGhlIHNjaGVkdWxlciBoYXMgcnVuIHRoZSBhYm92ZSBqb2IuICopXG4gICAgICAgIFRocmVhZF9zYWZlX2l2YXIucmVhZCBzY2hlZHVsZXJfcmFuX2Ffam9iKSlcbjs7XG5cbmxldCBibG9ja19vbl9hc3luY19ub3RfaG9sZGluZ19hc3luY19sb2NrIHQgZiA9XG4gICgqIENyZWF0ZSBhIHNjaGVkdWxlciB0aHJlYWQgaWYgdGhlIHNjaGVkdWxlciBpc24ndCBhbHJlYWR5IHJ1bm5pbmcuICopXG4gIGVuc3VyZV90aGVfc2NoZWR1bGVyX2lzX3N0YXJ0ZWQgdDtcbiAgbGV0IG1heWJlX2Jsb2NrZWQgPVxuICAgIHJ1bl9ob2xkaW5nX2FzeW5jX2xvY2tcbiAgICAgIHRcbiAgICAgIChmdW4gKCkgLT4gTW9uaXRvci50cnlfd2l0aCB+cnVuOmBTY2hlZHVsZSB+cmVzdDpgTG9nIGYgfm5hbWU6XCJibG9ja19vbl9hc3luY1wiKVxuICAgICAgfmZpbmlzaDooZnVuIHJlcyAtPlxuICAgICAgICBtYXRjaCByZXMgd2l0aFxuICAgICAgICB8IEVycm9yIGV4biAtPiBgQXZhaWxhYmxlIChFcnJvciBleG4pXG4gICAgICAgIHwgT2sgZCAtPlxuICAgICAgICAgIChtYXRjaCBEZWZlcnJlZC5wZWVrIGQgd2l0aFxuICAgICAgICAgICB8IFNvbWUgdiAtPiBgQXZhaWxhYmxlIHZcbiAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgaGF2ZV9sb2NrX2RvX2N5Y2xlIHQ7XG4gICAgICAgICAgICAgKG1hdGNoIERlZmVycmVkLnBlZWsgZCB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IGBBdmFpbGFibGUgdlxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICBsZXQgcSA9IFNxdWV1ZS5jcmVhdGUgMSBpblxuICAgICAgICAgICAgICAgIHVwb24gZCAoZnVuIHYgLT4gU3F1ZXVlLnB1c2hfdW5jb25kIHEgdik7XG4gICAgICAgICAgICAgICAgKCogU3F1ZXVlLnBvcCBjYW4gYmxvY2ssIHNvIHdlIGhhdmUgdG8gZG8gaXQgb3V0c2lkZSBhc3luYyAqKVxuICAgICAgICAgICAgICAgIGBCbG9ja2VkX3dhaXRfb25fc3F1ZXVlIHEpKSlcbiAgaW5cbiAgbWF0Y2ggbWF5YmVfYmxvY2tlZCB3aXRoXG4gIHwgYEF2YWlsYWJsZSB2IC0+IHZcbiAgfCBgQmxvY2tlZF93YWl0X29uX3NxdWV1ZSBxIC0+XG4gICAgKCogW3J1bl9ob2xkaW5nX2FzeW5jX2xvY2tdIHJlbGVhc2VkIHRoZSBsb2NrLiAgSWYgdGhlIHNjaGVkdWxlciB3YXNuJ3QgYWxyZWFkeVxuICAgICAgIHJ1bm5pbmcgd2hlbiBbYmxvY2tfb25fYXN5bmNdIHdhcyBjYWxsZWQsIHRoZW4gd2Ugc3RhcnRlZCBpdCBhYm92ZS4gIFNvLCB0aGVcbiAgICAgICBzY2hlZHVsZXIgaXMgcnVubmluZywgYW5kIHdpbGwgZXZlbnR1YWxseSBydW4gdGhlIGpvYiB0byBwdXQgc29tZXRoaW5nIG9uIHRoZVxuICAgICAgIHNxdWV1ZS4gIFNvLCBpdCdzIE9LIHRvIGJsb2NrIHdhaXRpbmcgZm9yIGl0LiAqKVxuICAgIFNxdWV1ZS5wb3AgcVxuOztcblxubGV0IGJsb2NrX29uX2FzeW5jIHQgZiA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwiYmxvY2tfb25fYXN5bmNcIiB0IFslc2V4cF9vZjogdF07XG4gICgqIFdlIGRpc2FsbG93IGNhbGxpbmcgW2Jsb2NrX29uX2FzeW5jXSBpZiB0aGUgY2FsbGVyIGlzIHJ1bm5pbmcgaW5zaWRlIGFzeW5jLiAgVGhpcyBjYW5cbiAgICAgaGFwcGVuIGlmIG9uZSBpcyB0aGUgc2NoZWR1bGVyLCBvciBpZiBvbmUgaXMgaW4gc29tZSBvdGhlciB0aHJlYWQgdGhhdCBoYXMgdXNlZCwgZS5nLlxuICAgICBbcnVuX2luX2FzeW5jXSB0byBjYWxsIGludG8gYXN5bmMgYW5kIHJ1biBhIGN5Y2xlLiAgV2UgZG8gaG93ZXZlciwgd2FudCB0byBhbGxvdyB0aGVcbiAgICAgbWFpbiB0aHJlYWQgdG8gY2FsbCBbYmxvY2tfb25fYXN5bmNdLCBpbiB3aGljaCBjYXNlIGl0IHNob3VsZCByZWxlYXNlIHRoZSBsb2NrIGFuZFxuICAgICBhbGxvdyB0aGUgc2NoZWR1bGVyLCB3aGljaCBpcyBydW5uaW5nIGluIGFub3RoZXIgdGhyZWFkLCB0byBydW4uICopXG4gIGlmIGlfYW1fdGhlX3NjaGVkdWxlciB0IHx8IChhbV9ob2xkaW5nX2xvY2sgdCAmJiBub3QgKGlzX21haW5fdGhyZWFkICgpKSlcbiAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcImNhbGxlZCBbYmxvY2tfb25fYXN5bmNdIGZyb20gd2l0aGluIGFzeW5jXCJdO1xuICBpZiBub3QgKGFtX2hvbGRpbmdfbG9jayB0KVxuICB0aGVuIGJsb2NrX29uX2FzeW5jX25vdF9ob2xkaW5nX2FzeW5jX2xvY2sgdCBmXG4gIGVsc2UgKFxuICAgIGxldCBleGVjdXRpb25fY29udGV4dCA9XG4gICAgICBLZXJuZWxfc2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdC5rZXJuZWxfc2NoZWR1bGVyXG4gICAgaW5cbiAgICB1bmxvY2sgdDtcbiAgICBsZXQgcmVzID0gYmxvY2tfb25fYXN5bmNfbm90X2hvbGRpbmdfYXN5bmNfbG9jayB0IGYgaW5cbiAgICAoKiBJZiB3ZSdyZSB0aGUgbWFpbiB0aHJlYWQsIHdlIHNob3VsZCBsb2NrIHRoZSBzY2hlZHVsZXIgZm9yIHRoZSByZXN0IG9mIG1haW4sIHRvXG4gICAgICAgcHJldmVudCB0aGUgc2NoZWR1bGVyLCB3aGljaCBpcyBub3cgcnVubmluZyBpbiBhbm90aGVyIHRocmVhZCwgZnJvbSBpbnRlcmZlcmluZ1xuICAgICAgIHdpdGggdGhlIG1haW4gdGhyZWFkLiAgV2UgYWxzbyByZXN0b3JlIHRoZSBleGVjdXRpb24gY29udGV4dCwgc28gdGhhdCB0aGUgY29kZVxuICAgICAgIGluIHRoZSBtYWluIHRocmVhZCB3aWxsIGJlIGluIHRoZSBzYW1lIGV4ZWN1dGlvbiBjb250ZXh0IGFzIGJlZm9yZSBpdCBjYWxsZWRcbiAgICAgICBbYmxvY2tfb25fYXN5bmNdLiAgVGhlIHJlc3RvcmVkIGV4ZWN1dGlvbiBjb250ZXh0IHdpbGwgdXN1YWxseSBiZVxuICAgICAgIFtFeGVjdXRpb25fY29udGV4dC5tYWluXSwgYnV0IG5lZWQgbm90IGJlLCBpZiB0aGUgdXNlciBoYXMgZG9uZSBvcGVyYXRpb25zIHRoYXRcbiAgICAgICBhZGp1c3QgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQsIGUuZy4gW01vbml0b3Iud2l0aGluXS4gKilcbiAgICBsb2NrIHQ7XG4gICAgS2VybmVsX3NjaGVkdWxlci5zZXRfZXhlY3V0aW9uX2NvbnRleHQgdC5rZXJuZWxfc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0O1xuICAgIHJlcylcbjs7XG5cbmxldCBibG9ja19vbl9hc3luY19leG4gdCBmID0gUmVzdWx0Lm9rX2V4biAoYmxvY2tfb25fYXN5bmMgdCBmKVxuXG5sZXQgcnVuX2luX2FzeW5jID93YWtldXBfc2NoZWR1bGVyIHQgZiA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwicnVuX2luX2FzeW5jXCIgdCBbJXNleHBfb2Y6IHRdO1xuICBlbnN1cmVfaW5fYV90aHJlYWQgdCBcInJ1bl9pbl9hc3luY1wiO1xuICBydW5faG9sZGluZ19hc3luY19sb2NrID93YWtldXBfc2NoZWR1bGVyIHQgZiB+ZmluaXNoOkZuLmlkXG47O1xuXG5sZXQgcnVuX2luX2FzeW5jX2V4biA/d2FrZXVwX3NjaGVkdWxlciB0IGYgPVxuICBSZXN1bHQub2tfZXhuIChydW5faW5fYXN5bmMgP3dha2V1cF9zY2hlZHVsZXIgdCBmKVxuOztcblxubGV0IHJ1bl9pbl9hc3luY193YWl0IHQgZiA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwicnVuX2luX2FzeW5jX3dhaXRcIiB0IFslc2V4cF9vZjogdF07XG4gIGVuc3VyZV9pbl9hX3RocmVhZCB0IFwicnVuX2luX2FzeW5jX3dhaXRcIjtcbiAgYmxvY2tfb25fYXN5bmMgdCBmXG47O1xuXG5sZXQgcnVuX2luX2FzeW5jX3dhaXRfZXhuIHQgZiA9IFJlc3VsdC5va19leG4gKHJ1bl9pbl9hc3luY193YWl0IHQgZilcblxubGV0IGRlZmVycmVkIHQgPVxuICBsZXQgaXZhciA9XG4gICAgaWYgYW1faG9sZGluZ19sb2NrIHRcbiAgICB0aGVuIEl2YXIuY3JlYXRlICgpXG4gICAgZWxzZSBydW5faG9sZGluZ19hc3luY19sb2NrIHQgSXZhci5jcmVhdGUgfmZpbmlzaDpSZXN1bHQub2tfZXhuXG4gIGluXG4gIGxldCBmaWxsIHggPSBydW5faW5fYXN5bmNfZXhuIHQgKGZ1biAoKSAtPiBJdmFyLmZpbGxfZXhuIGl2YXIgeCkgaW5cbiAgSXZhci5yZWFkIGl2YXIsIGZpbGxcbjs7XG5cbmxldCB0ICgpID0gdGhlX29uZV9hbmRfb25seSAoKVxubGV0IGFtX2hvbGRpbmdfYXN5bmNfbG9jayAoKSA9IGFtX2hvbGRpbmdfbG9jayAodCAoKSlcbmxldCBkZWZlcnJlZCAoKSA9IGRlZmVycmVkICh0ICgpKVxuXG5sZXQgcnVuX2luX2FzeW5jX3dpdGhfb3B0aW9uYWxfY3ljbGUgP3dha2V1cF9zY2hlZHVsZXIgZiA9XG4gIHJ1bl9pbl9hc3luY193aXRoX29wdGlvbmFsX2N5Y2xlID93YWtldXBfc2NoZWR1bGVyICh0ICgpKSBmXG47O1xuXG5sZXQgcnVuX2luX2FzeW5jID93YWtldXBfc2NoZWR1bGVyIGYgPSBydW5faW5fYXN5bmMgP3dha2V1cF9zY2hlZHVsZXIgKHQgKCkpIGZcbmxldCBydW5faW5fYXN5bmNfZXhuID93YWtldXBfc2NoZWR1bGVyIGYgPSBydW5faW5fYXN5bmNfZXhuID93YWtldXBfc2NoZWR1bGVyICh0ICgpKSBmXG5sZXQgYmxvY2tfb25fYXN5bmMgZiA9IGJsb2NrX29uX2FzeW5jICh0ICgpKSBmXG5sZXQgYmxvY2tfb25fYXN5bmNfZXhuIGYgPSBibG9ja19vbl9hc3luY19leG4gKHQgKCkpIGZcbmxldCBydW5faW5fYXN5bmNfd2FpdCBmID0gcnVuX2luX2FzeW5jX3dhaXQgKHQgKCkpIGZcbmxldCBydW5faW5fYXN5bmNfd2FpdF9leG4gZiA9IHJ1bl9pbl9hc3luY193YWl0X2V4biAodCAoKSkgZlxuXG5sZXQgb2tfdG9fZHJvcF9sb2NrIHQgPVxuICBpc19tYWluX3RocmVhZCAoKSAmJiBub3QgKEtlcm5lbF9zY2hlZHVsZXIuaW5fY3ljbGUgdC5rZXJuZWxfc2NoZWR1bGVyKVxuOztcblxubGV0IHdpdGhvdXRfYXN5bmNfbG9ja191bmNoZWNrZWQgPSB3aXRob3V0X2FzeW5jX2xvY2tcblxubGV0IHdpdGhvdXRfYXN5bmNfbG9jayBmID1cbiAgbGV0IHQgPSB0ICgpIGluXG4gIGlmIGlfYW1fdGhlX3NjaGVkdWxlciB0IHx8IChhbV9ob2xkaW5nX2xvY2sgdCAmJiBub3QgKG9rX3RvX2Ryb3BfbG9jayB0KSlcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslc2V4cFxuICAgICAgICBcImNhbGxlZCBbYmVjb21lX2hlbHBlcl90aHJlYWRfYW5kX2Jsb2NrX29uX2FzeW5jXSBmcm9tIHdpdGhpbiBhc3luY1wiXG4gICAgICAgICwgeyBpX2FtX3RoZV9zY2hlZHVsZXIgPSAoaV9hbV90aGVfc2NoZWR1bGVyIHQgOiBib29sKVxuICAgICAgICAgIDsgYW1faG9sZGluZ19sb2NrID0gKGFtX2hvbGRpbmdfbG9jayB0IDogYm9vbClcbiAgICAgICAgICA7IG9rX3RvX2Ryb3BfbG9jayA9IChva190b19kcm9wX2xvY2sgdCA6IGJvb2wpXG4gICAgICAgICAgfV1cbiAgZWxzZSB3aXRob3V0X2FzeW5jX2xvY2sgdCBmXG47O1xuXG5tb2R1bGUgRm9yX3Rlc3RzID0gc3RydWN0XG4gIGxldCB3aXRob3V0X2FzeW5jX2xvY2tfdW5jaGVja2VkIGYgPVxuICAgIGxldCB0ID0gdCAoKSBpblxuICAgIHdpdGhvdXRfYXN5bmNfbG9ja191bmNoZWNrZWQgdCBmXG4gIDs7XG5lbmRcbiIsIigqIFtSYXdfc2NoZWR1bGVyXSBpcyBkaXN0aW5jdCBmcm9tIFtTY2hlZHVsZXJdLCBiZWNhdXNlIHRoZSBmb3JtZXIgZXhwb3NlcyBzb21lIHRoaW5nc1xuICAgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHdpdGhpbiBBc3luYyB0aGF0IGFyZSBub3QgZXhwb3NlZCBpbiBzY2hlZHVsZXIubWxpLlxuICAgQWxzbywgaXQgYnJlYWtzIGEgY3ljbGljIGRlcGVuZGVuY3kgW1Jhd19zY2hlZHVsZXIgLT4gTG9nIC0+IFNjaGVkdWxlcl0uICopXG5cbm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBSYXdfc2NoZWR1bGVyXG5cbmxldCBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ID0gQXN5bmNfa2VybmVsX3NjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0XG5cbmxldCB0aW1lX3NwZW50X3dhaXRpbmdfZm9yX2lvICgpID1cbiAgbGV0IHQgPSB0ICgpIGluXG4gIHQudGltZV9zcGVudF93YWl0aW5nX2Zvcl9pb1xuICB8PiBUc2MuU3Bhbi50b19ucyB+Y2FsaWJyYXRvcjooZm9yY2UgVGltZV9zdGFtcF9jb3VudGVyLmNhbGlicmF0b3IpXG4gIHw+IFRpbWVfbnMuU3Bhbi5vZl9pbnQ2M19uc1xuOztcblxubGV0IHNldF9taW5faW50ZXJfY3ljbGVfdGltZW91dCBtaW5faW50ZXJfY3ljbGVfdGltZW91dCA9XG4gIGxldCB0ID0gdCAoKSBpblxuICBpZiBUaW1lX25zLlNwYW4uKCA+IClcbiAgICAgICBtaW5faW50ZXJfY3ljbGVfdGltZW91dFxuICAgICAgICh0Lm1heF9pbnRlcl9jeWNsZV90aW1lb3V0IDo+IFRpbWVfbnMuU3Bhbi50KVxuICB0aGVuXG4gICAgRXJyb3IucmFpc2VcbiAgICAgIChbJW1lc3NhZ2VcbiAgICAgICAgIFwibWluX2ludGVyX2N5Y2xlX3RpbWVvdXQgdG9vIGxhcmdlXCJcbiAgICAgICAgICAgKG1pbl9pbnRlcl9jeWNsZV90aW1lb3V0IDogVGltZV9ucy5TcGFuLnQpXG4gICAgICAgICAgICh0Lm1heF9pbnRlcl9jeWNsZV90aW1lb3V0IDogTWF4X2ludGVyX2N5Y2xlX3RpbWVvdXQudCldXG4gICAgICAgfD4gWyVvZl9zZXhwOiBFcnJvci50XSk7XG4gIHQubWluX2ludGVyX2N5Y2xlX3RpbWVvdXQgPC0gTWluX2ludGVyX2N5Y2xlX3RpbWVvdXQuY3JlYXRlX2V4biBtaW5faW50ZXJfY3ljbGVfdGltZW91dFxuOztcblxubGV0IG1heF9udW1fb3Blbl9maWxlX2Rlc2NycyAoKSA9IG1heF9udW1fb3Blbl9maWxlX2Rlc2NycyAodCAoKSlcbmxldCBmZHNfbWF5X3Byb2R1Y2VfZXZlbnRzICgpID0gZmRzX21heV9wcm9kdWNlX2V2ZW50cyAodCAoKSlcbmxldCB0aHJlYWRfcG9vbF9oYXNfdW5maW5pc2hlZF93b3JrICgpID0gdGhyZWFkX3Bvb2xfaGFzX3VuZmluaXNoZWRfd29yayAodCAoKSlcbmxldCBtYXhfbnVtX3RocmVhZHMgKCkgPSBtYXhfbnVtX3RocmVhZHMgKHQgKCkpXG5sZXQgXyA9IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRcbmxldCBpc19ydW5uaW5nICgpID0gaXNfdGhlX29uZV9hbmRfb25seV9ydW5uaW5nICgpXG5cbm1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgbGV0IHdhcm1fdXBfZmRzICgpID1cbiAgICBsZXQgKCkgPSBUaHJlYWRfc2FmZS5ibG9ja19vbl9hc3luY19leG4gKGZ1biAoKSAtPiBEZWZlcnJlZC5yZXR1cm4gKCkpIGluXG4gICAgbGV0IChfIDogSW9fdXJpbmdfcmF3LnQgb3B0aW9uKSA9IElvX3VyaW5nX3Jhd19zaW5nbGV0b24udGhlX29uZV9hbmRfb25seSAoKSBpblxuICAgICgpXG4gIDs7XG5lbmRcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbmluY2x1ZGUgQ29yZS5TaWduYWxcblxubGV0IGhhbmRsZV9kZWZhdWx0IGBEb19ub3RfdXNlX3dpdGhfYXN5bmMgPSBhc3NlcnQgZmFsc2VcbmxldCBpZ25vcmUgYERvX25vdF91c2Vfd2l0aF9hc3luYyA9IGFzc2VydCBmYWxzZVxuXG5tb2R1bGUgU2NoZWR1bGVyID0gUmF3X3NjaGVkdWxlclxuXG5sZXQgdGhlX29uZV9hbmRfb25seSA9IFNjaGVkdWxlci50aGVfb25lX2FuZF9vbmx5XG5cbmxldCBoYW5kbGUgP3N0b3AgdHMgfmYgPVxuICBsZXQgc2NoZWR1bGVyID0gdGhlX29uZV9hbmRfb25seSAoKSBpblxuICBsZXQgc2lnbmFsX21hbmFnZXIgPSBzY2hlZHVsZXIuc2lnbmFsX21hbmFnZXIgaW5cbiAgbGV0IGhhbmRsZXIgPVxuICAgIFNpZ25hbF9tYW5hZ2VyLmluc3RhbGxfaGFuZGxlclxuICAgICAgc2lnbmFsX21hbmFnZXJcbiAgICAgIHRzXG4gICAgICAodW5zdGFnZSAoU2NoZWR1bGVyLnByZXNlcnZlX2V4ZWN1dGlvbl9jb250ZXh0IGYpKVxuICBpblxuICBPcHRpb24uaXRlciBzdG9wIH5mOihmdW4gc3RvcCAtPlxuICAgIHVwb24gc3RvcCAoZnVuICgpIC0+IFNpZ25hbF9tYW5hZ2VyLnJlbW92ZV9oYW5kbGVyIHNpZ25hbF9tYW5hZ2VyIGhhbmRsZXIpKVxuOztcblxubGV0IHRlcm1pbmF0aW5nID0gWyBhbHJtOyBodXA7IGludDsgdGVybTsgdXNyMTsgdXNyMiBdXG5cbmxldCBtYW5hZ2VfYnlfYXN5bmMgdHMgPVxuICBsZXQgc2NoZWR1bGVyID0gdGhlX29uZV9hbmRfb25seSAoKSBpblxuICBsZXQgc2lnbmFsX21hbmFnZXIgPSBzY2hlZHVsZXIuc2lnbmFsX21hbmFnZXIgaW5cbiAgTGlzdC5pdGVyIHRzIH5mOihmdW4gdCAtPlxuICAgIFNpZ25hbF9tYW5hZ2VyLm1hbmFnZV9idXRfa2VlcF9kZWZhdWx0X2JlaGF2aW9yIHNpZ25hbF9tYW5hZ2VyIHQpXG47O1xuXG5sZXQgaXNfbWFuYWdlZF9ieV9hc3luYyB0ID1cbiAgbGV0IHNjaGVkdWxlciA9IHRoZV9vbmVfYW5kX29ubHkgKCkgaW5cbiAgbGV0IHNpZ25hbF9tYW5hZ2VyID0gc2NoZWR1bGVyLnNpZ25hbF9tYW5hZ2VyIGluXG4gIFNpZ25hbF9tYW5hZ2VyLmlzX21hbmFnaW5nIHNpZ25hbF9tYW5hZ2VyIHRcbjs7XG4iLCJtb2R1bGUgQXN5bmNfc2lnbmFsID0gU2lnbmFsXG5vcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5tb2R1bGUgRmlsZV9kZXNjciA9IFVuaXguRmlsZV9kZXNjclxubW9kdWxlIEV4aXQgPSBVbml4LkV4aXRcbm1vZHVsZSBFeGl0X29yX3NpZ25hbCA9IFVuaXguRXhpdF9vcl9zaWduYWxcbm1vZHVsZSBFeGl0X29yX3NpZ25hbF9vcl9zdG9wID0gVW5peC5FeGl0X29yX3NpZ25hbF9vcl9zdG9wXG5tb2R1bGUgU3lzY2FsbF9yZXN1bHQgPSBVbml4LlN5c2NhbGxfcmVzdWx0XG5tb2R1bGUgRXJyb3IgPSBVbml4LkVycm9yXG5cbmV4Y2VwdGlvbiBVbml4X2Vycm9yID0gVW5peC5Vbml4X2Vycm9yXG5cbmluY2x1ZGUgRmQuQ2xvc2Vcbm1vZHVsZSBPcGVuX2ZsYWdzID0gVW5peC5PcGVuX2ZsYWdzXG5cbmxldCBzeXN0ZW0gcyA9IEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcInN5c3RlbVwiIChmdW4gKCkgLT4gVW5peC5zeXN0ZW0gcylcblxubGV0IHN5c3RlbV9leG4gcyA9XG4gIGxldCVtYXAgc3RhdHVzID0gc3lzdGVtIHMgaW5cbiAgaWYgbm90IChSZXN1bHQuaXNfb2sgc3RhdHVzKVxuICB0aGVuXG4gICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJzaGVsbCBjb21tYW5kIGZhaWxlZFwiIH5fOihzIDogc3RyaW5nKSAoc3RhdHVzIDogRXhpdF9vcl9zaWduYWwudCldXG47O1xuXG5sZXQgZ2V0cGlkICgpID0gVW5peC5nZXRwaWQgKClcbmxldCBnZXRwcGlkICgpID0gVW5peC5nZXRwcGlkICgpXG5sZXQgZ2V0cHBpZF9leG4gKCkgPSBVbml4LmdldHBwaWRfZXhuICgpXG5cbmxldCB0aGlzX3Byb2Nlc3NfYmVjYW1lX2NoaWxkX29mX2luaXQgPyhwb2xsX2RlbGF5ID0gc2VjIDEuKSAoKSA9XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIGkgLT5cbiAgICBDbG9jay5ldmVyeSBwb2xsX2RlbGF5IH5zdG9wOihJdmFyLnJlYWQgaSkgKGZ1biAoKSAtPlxuICAgICAgaWYgUGlkLmVxdWFsIChnZXRwcGlkX2V4biAoKSkgUGlkLmluaXQgdGhlbiBJdmFyLmZpbGxfZXhuIGkgKCkpKVxuOztcblxubGV0IG5pY2UgaSA9IFVuaXgubmljZSBpXG5cbmxldCBjb3JlcyA9XG4gIE9yX2Vycm9yLm1hcCBMaW51eF9leHQuY29yZXMgfmY6KGZ1biBjb3JlcyAoKSAtPlxuICAgIEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcImNvcmVzXCIgY29yZXMpXG47O1xuXG4oKiBiYXNpYyBpbnB1dC9vdXRwdXQgKilcblxubGV0IGNvbnZlcnRfb3Blbl9mbGFnIDogXyAtPiBVbml4Lm9wZW5fZmxhZyA9IGZ1bmN0aW9uXG4gIHwgYFJkb25seSAtPiBPX1JET05MWVxuICB8IGBXcm9ubHkgLT4gT19XUk9OTFlcbiAgfCBgUmR3ciAtPiBPX1JEV1JcbiAgfCBgTm9uYmxvY2sgLT4gT19OT05CTE9DS1xuICB8IGBBcHBlbmQgLT4gT19BUFBFTkRcbiAgfCBgQ3JlYXQgLT4gT19DUkVBVFxuICB8IGBUcnVuYyAtPiBPX1RSVU5DXG4gIHwgYEV4Y2wgLT4gT19FWENMXG4gIHwgYE5vY3R0eSAtPiBPX05PQ1RUWVxuICB8IGBEc3luYyAtPiBPX0RTWU5DXG4gIHwgYFN5bmMgLT4gT19TWU5DXG4gIHwgYFJzeW5jIC0+IE9fUlNZTkNcbjs7XG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgWyBgUmRvbmx5XG4gIHwgYFdyb25seVxuICB8IGBSZHdyXG4gIHwgYE5vbmJsb2NrXG4gIHwgYEFwcGVuZFxuICB8IGBDcmVhdFxuICB8IGBUcnVuY1xuICB8IGBFeGNsXG4gIHwgYE5vY3R0eVxuICB8IGBEc3luY1xuICB8IGBTeW5jXG4gIHwgYFJzeW5jXG4gIF1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbnR5cGUgZmlsZV9wZXJtID0gaW50IFtAQGRlcml2aW5nIHNleHAsIGJpbl9pbywgY29tcGFyZV1cblxuKCogSW1wbGVtZW50YXRpb24gb2YgW29wZW5maWxlXSBvbiB0b3Agb2YgW0lvX3VyaW5nXS4gKilcbm1vZHVsZSBVcmluZ19vcGVuZmlsZSA9IHN0cnVjdFxuICBsZXQgY29udmVydF90b191cmluZ19mbGFncyA6IFVuaXgub3Blbl9mbGFnIC0+IElvX3VyaW5nX3Jhdy5PcGVuX2ZsYWdzLnQgPVxuICAgIGxldCBvcGVuIElvX3VyaW5nX3Jhdy5PcGVuX2ZsYWdzIGluXG4gICAgZnVuY3Rpb25cbiAgICB8IE9fUkRPTkxZIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgT19XUk9OTFkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBPX1JEV1IgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBPX05PTkJMT0NLIC0+IG5vbmJsb2NrXG4gICAgfCBPX0FQUEVORCAtPiBhcHBlbmRcbiAgICB8IE9fQ1JFQVQgLT4gY3JlYXRcbiAgICB8IE9fVFJVTkMgLT4gdHJ1bmNcbiAgICB8IE9fRVhDTCAtPiBleGNsXG4gICAgfCBPX05PQ1RUWSAtPiBub2N0dHlcbiAgICB8IE9fRFNZTkMgLT4gZHN5bmNcbiAgICB8IE9fU1lOQyAtPiBzeW5jXG4gICAgKCogQWNjb3JkaW5nIHRvIHRoZSBvcGVuIG1hbiBwYWdlOlxuXG4gICAgICAgTGludXggaW1wbGVtZW50cyBPX1NZTkMgYW5kIE9fRFNZTkMsIGJ1dCBub3QgT19SU1lOQy4gIFNvbWV3aGF0XG4gICAgICAgaW5jb3JyZWN0bHksIGdsaWJjIGRlZmluZXMgT19SU1lOQyB0byBoYXZlIHRoZSBzYW1lIHZhbHVlIGFzXG4gICAgICAgT19TWU5DLiAgKE9fUlNZTkMgaXMgZGVmaW5lZCBpbiB0aGUgTGludXggaGVhZGVyIGZpbGVcbiAgICAgICA8YXNtL2ZjbnRsLmg+IG9uIEhQIFBBLVJJU0MsIGJ1dCBpdCBpcyBub3QgdXNlZC5cbiAgICAqKVxuICAgIHwgT19SU1lOQyAtPiBzeW5jXG4gICAgfCBPX0NMT0VYRUMgLT4gY2xvZXhlY1xuICAgICgqIFRoZXNlIGZsYWdzIGhhdmUgbm8gW29jYW1sX3VyaW5nXSBlcXVpdmFsZW50IChhbHNvLCB0aGV5IGFyZSB1bnJlYWNoYWJsZSBiZWNhdXNlXG4gICAgICAgdGhleSBhcmUgbm90IGV4cG9zZWQgYnkgW0FzeW5jXSkgKilcbiAgICB8IE9fU0hBUkVfREVMRVRFIC0+IGVtcHR5XG4gICAgfCBPX0tFRVBFWEVDIC0+IGVtcHR5XG4gIDs7XG5cbiAgbGV0IGlzX3J3X2ZsYWcgKGZsYWcgOiBVbml4Lm9wZW5fZmxhZykgPVxuICAgIG1hdGNoIGZsYWcgd2l0aFxuICAgIHwgT19SRE9OTFkgfCBPX1dST05MWSB8IE9fUkRXUiAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGNvbnZlcnRfdG9fdXJpbmdfYWNjZXNzIChhY2Nlc3MgOiBVbml4Lm9wZW5fZmxhZyBsaXN0KSA9XG4gICAgbWF0Y2hcbiAgICAgICggTGlzdC5maW5kIGFjY2VzcyB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IE9fUkRPTkxZIHwgT19SRFdSIC0+IHRydWVcbiAgICAgICAgICB8IF8gLT4gZmFsc2UpXG4gICAgICAsIExpc3QuZmluZCBhY2Nlc3MgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBPX1dST05MWSB8IE9fUkRXUiAtPiB0cnVlXG4gICAgICAgICAgfCBfIC0+IGZhbHNlKSApXG4gICAgd2l0aFxuICAgIHwgU29tZSBfLCBTb21lIF8gLT4gYFJXXG4gICAgfCBTb21lIF8sIE5vbmUgLT4gYFJcbiAgICB8IE5vbmUsIFNvbWUgXyAtPiBgV1xuICAgIHwgTm9uZSwgTm9uZSAtPlxuICAgICAgZmFpbHdpdGggXCJBc3luYy5Vbml4X3N5c2NhbGxzLm9wZW5maWxlOiBtdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIGFjY2VzcyBmbGFnXCJcbiAgOztcblxuICBsZXQgY29udmVydF90b191cmluZ19tb2RlIG1vZGUgPVxuICAgIGxldCBhY2Nlc3MsIGZsYWdzID0gTGlzdC5wYXJ0aXRpb25fdGYgbW9kZSB+Zjppc19yd19mbGFnIGluXG4gICAgbGV0IGFjY2VzcyA9IGNvbnZlcnRfdG9fdXJpbmdfYWNjZXNzIGFjY2VzcyBpblxuICAgIGxldCBmbGFncyA9XG4gICAgICBMaXN0Lm1hcCBmbGFncyB+Zjpjb252ZXJ0X3RvX3VyaW5nX2ZsYWdzXG4gICAgICB8PiBMaXN0LmZvbGQgfmluaXQ6SW9fdXJpbmdfcmF3Lk9wZW5fZmxhZ3MuZW1wdHkgfmY6SW9fdXJpbmdfcmF3Lk9wZW5fZmxhZ3MuKCArIClcbiAgICBpblxuICAgIGFjY2VzcywgZmxhZ3NcbiAgOztcblxuICBsZXQgb3BlbmZpbGUgdXJpbmcgP3Blcm0gZmlsZSB+dW5peF9tb2RlID1cbiAgICBsZXQgYWNjZXNzLCBmbGFncyA9IGNvbnZlcnRfdG9fdXJpbmdfbW9kZSB1bml4X21vZGUgaW5cbiAgICBsZXQgZGVmYXVsdF9wZXJtID0gMG82NDQgaW5cbiAgICBsZXQgcGVybV9mb3JfZXJyb3IgPSBPcHRpb24udmFsdWUgcGVybSB+ZGVmYXVsdDpkZWZhdWx0X3Blcm0gaW5cbiAgICBsZXQgcGVybSA9XG4gICAgICBPcHRpb24udmFsdWVcbiAgICAgICAgcGVybVxuICAgICAgICB+ZGVmYXVsdDpcbiAgICAgICAgICAobGV0IG9wZW4gSW9fdXJpbmdfcmF3Lk9wZW5fZmxhZ3MgaW5cbiAgICAgICAgICAgaWYgbWVtIGNyZWF0IGZsYWdzIHx8IG1lbSB0bXBmaWxlIGZsYWdzIHRoZW4gZGVmYXVsdF9wZXJtIGVsc2UgMClcbiAgICBpblxuICAgIG1hdGNoJW1hcFxuICAgICAgSW9fdXJpbmdfcmF3LnN5c2NhbGxfcmVzdWx0XG4gICAgICAgIChJb191cmluZ19yYXcub3BlbmF0MlxuICAgICAgICAgICB1cmluZ1xuICAgICAgICAgICB+YWNjZXNzXG4gICAgICAgICAgIH5mbGFnc1xuICAgICAgICAgICB+cGVybVxuICAgICAgICAgICB+cmVzb2x2ZTpJb191cmluZ19yYXcuUmVzb2x2ZS5lbXB0eVxuICAgICAgICAgICBmaWxlKVxuICAgIHdpdGhcbiAgICB8IEVycm9yIGVyciAtPlxuICAgICAgcmFpc2VcbiAgICAgICAgKFVuaXguVW5peF9lcnJvclxuICAgICAgICAgICAoIGVyclxuICAgICAgICAgICAsIFwib3BlblwiXG4gICAgICAgICAgICwgQ29yZV91bml4LlByaXZhdGUuc2V4cF90b19zdHJpbmdfaHVtXG4gICAgICAgICAgICAgICBbJXNleHBcbiAgICAgICAgICAgICAgICAgeyBmaWxlbmFtZSA6IHN0cmluZyA9IGZpbGVcbiAgICAgICAgICAgICAgICAgOyBtb2RlIDogVW5peC5vcGVuX2ZsYWcgbGlzdCA9IHVuaXhfbW9kZVxuICAgICAgICAgICAgICAgICA7IHBlcm0gOiBzdHJpbmcgPSBQcmludGYuc3ByaW50ZiBcIjBvJW9cIiBwZXJtX2Zvcl9lcnJvclxuICAgICAgICAgICAgICAgICB9XSApKVxuICAgIHwgT2sgcmVzIC0+IEZpbGVfZGVzY3Iub2ZfaW50IHJlc1xuICA7O1xuZW5kXG5cbmxldCBvcGVuZmlsZSA/aW5mbyA/cGVybSBmaWxlIH5tb2RlID1cbiAgbGV0IHVuaXhfbW9kZSA9IExpc3QubWFwIG1vZGUgfmY6Y29udmVydF9vcGVuX2ZsYWcgQCBbIE9fQ0xPRVhFQyBdIGluXG4gIGxldCViaW5kIGZpbGVfZGVzY3IgPVxuICAgIG1hdGNoIElvX3VyaW5nX3Jhd19zaW5nbGV0b24udGhlX29uZV9hbmRfb25seSAoKSB3aXRoXG4gICAgfCBTb21lIHVyaW5nIC0+IFVyaW5nX29wZW5maWxlLm9wZW5maWxlIHVyaW5nID9wZXJtIGZpbGUgfnVuaXhfbW9kZVxuICAgIHwgTm9uZSAtPlxuICAgICAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwib3BlbmZpbGVcIiAoZnVuICgpIC0+XG4gICAgICAgIFVuaXgub3BlbmZpbGUgP3Blcm0gZmlsZSB+bW9kZTp1bml4X21vZGUpXG4gIGluXG4gIGxldCVtYXAga2luZCA9IEZkLktpbmQuaW5mZXJfdXNpbmdfc3RhdCBmaWxlX2Rlc2NyIGluXG4gIEZkLmNyZWF0ZSBraW5kIGZpbGVfZGVzY3IgKE9wdGlvbi52YWx1ZSBpbmZvIH5kZWZhdWx0OihJbmZvLm9mX3N0cmluZyBmaWxlKSlcbjs7XG5cbmxldCBmY250bF9nZXRmbCBmZCA9XG4gIEZkLnN5c2NhbGxfaW5fdGhyZWFkX2V4biBmZCB+bmFtZTpcImZjbnRsX2dldGZsXCIgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgVW5peC5mY250bF9nZXRmbCBmaWxlX2Rlc2NyKVxuOztcblxubGV0IGZjbnRsX3NldGZsIGZkIGZsYWdzID1cbiAgRmQuc3lzY2FsbF9pbl90aHJlYWRfZXhuIGZkIH5uYW1lOlwiZmNudGxfc2V0ZmxcIiAoZnVuIGZpbGVfZGVzY3IgLT5cbiAgICBVbml4LmZjbnRsX3NldGZsIGZpbGVfZGVzY3IgZmxhZ3MpXG47O1xuXG5sZXQgbHNlZWsgZmQgcG9zIH5tb2RlID1cbiAgbGV0IG1vZGUgOiBVbml4LnNlZWtfY29tbWFuZCA9XG4gICAgbWF0Y2ggbW9kZSB3aXRoXG4gICAgfCBgU2V0IC0+IFNFRUtfU0VUXG4gICAgfCBgQ3VyIC0+IFNFRUtfQ1VSXG4gICAgfCBgRW5kIC0+IFNFRUtfRU5EXG4gIGluXG4gIEZkLnN5c2NhbGxfaW5fdGhyZWFkX2V4biBmZCB+bmFtZTpcImxzZWVrXCIgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgVW5peC5sc2VlayBmaWxlX2Rlc2NyIHBvcyB+bW9kZSlcbjs7XG5cbmxldCB0cnVuY2F0ZSBmaWxlbmFtZSB+bGVuID1cbiAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwidHJ1bmNhdGVcIiAoZnVuICgpIC0+IFVuaXgudHJ1bmNhdGUgZmlsZW5hbWUgfmxlbilcbjs7XG5cbmxldCBmdHJ1bmNhdGUgZmQgfmxlbiA9XG4gIEZkLnN5c2NhbGxfaW5fdGhyZWFkX2V4biBmZCB+bmFtZTpcImZ0cnVuY2F0ZVwiIChmdW4gZmlsZV9kZXNjciAtPlxuICAgIFVuaXguZnRydW5jYXRlIGZpbGVfZGVzY3Igfmxlbilcbjs7XG5cbmxldCBmc3luYyBmZCA9IEZkLnN5c2NhbGxfaW5fdGhyZWFkX2V4biBmZCB+bmFtZTpcImZzeW5jXCIgVW5peC5mc3luY1xubGV0IGZkYXRhc3luYyBmZCA9IEZkLnN5c2NhbGxfaW5fdGhyZWFkX2V4biBmZCB+bmFtZTpcImZkYXRhc3luY1wiIFVuaXguZmRhdGFzeW5jXG5sZXQgc3luYyAoKSA9IEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcInN5bmNcIiBVbml4LnN5bmNcblxubW9kdWxlIExvY2tfbW9kZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgU2hhcmVkXG4gICAgfCBFeGNsdXNpdmVcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgZmxvY2tfY29tbWFuZCA6IHQgLT4gXyA9IGZ1bmN0aW9uXG4gICAgfCBTaGFyZWQgLT4gVW5peC5GbG9ja19jb21tYW5kLmxvY2tfc2hhcmVkXG4gICAgfCBFeGNsdXNpdmUgLT4gVW5peC5GbG9ja19jb21tYW5kLmxvY2tfZXhjbHVzaXZlXG4gIDs7XG5lbmRcblxubGV0IGxvY2tmID8obGVuID0gMEwpIGZkIChsb2NrX21vZGUgOiBMb2NrX21vZGUudCkgPVxuICBsZXQgbW9kZSA6IFVuaXgubG9ja19jb21tYW5kID1cbiAgICBtYXRjaCBsb2NrX21vZGUgd2l0aFxuICAgIHwgU2hhcmVkIC0+IEZfUkxPQ0tcbiAgICB8IEV4Y2x1c2l2ZSAtPiBGX0xPQ0tcbiAgaW5cbiAgRmQuc3lzY2FsbF9pbl90aHJlYWRfZXhuIGZkIH5uYW1lOlwibG9ja2ZcIiAoZnVuIGZpbGVfZGVzY3IgLT5cbiAgICBVbml4LmxvY2tmIGZpbGVfZGVzY3Igfm1vZGUgfmxlbilcbjs7XG5cbmxldCB0cnlfbG9ja2YgPyhsZW4gPSAwTCkgZmQgKGxvY2tfbW9kZSA6IExvY2tfbW9kZS50KSA9XG4gIGxldCBtb2RlIDogVW5peC5sb2NrX2NvbW1hbmQgPVxuICAgIG1hdGNoIGxvY2tfbW9kZSB3aXRoXG4gICAgfCBTaGFyZWQgLT4gRl9UUkxPQ0tcbiAgICB8IEV4Y2x1c2l2ZSAtPiBGX1RMT0NLXG4gIGluXG4gIEZkLnN5c2NhbGxfZXhuIGZkIChmdW4gZmlsZV9kZXNjciAtPlxuICAgIHRyeVxuICAgICAgVW5peC5sb2NrZiBmaWxlX2Rlc2NyIH5tb2RlIH5sZW47XG4gICAgICB0cnVlXG4gICAgd2l0aFxuICAgIHwgVW5peF9lcnJvciAoKEVBQ0NFUyB8IEVBR0FJTiksIF8sIF8pIC0+IGZhbHNlKVxuOztcblxubGV0IHRlc3RfbG9ja2YgPyhsZW4gPSAwTCkgZmQgPVxuICBGZC5zeXNjYWxsX2V4biBmZCAoZnVuIGZpbGVfZGVzY3IgLT5cbiAgICB0cnlcbiAgICAgIFVuaXgubG9ja2YgZmlsZV9kZXNjciB+bW9kZTpGX1RFU1QgfmxlbjtcbiAgICAgIHRydWVcbiAgICB3aXRoXG4gICAgfCBVbml4X2Vycm9yICgoRUFDQ0VTIHwgRUFHQUlOKSwgXywgXykgLT4gZmFsc2UpXG47O1xuXG5sZXQgdW5sb2NrZiA/KGxlbiA9IDBMKSBmZCA9XG4gIEZkLnN5c2NhbGxfZXhuIGZkIChmdW4gZmlsZV9kZXNjciAtPiBVbml4LmxvY2tmIGZpbGVfZGVzY3Igfm1vZGU6Rl9VTE9DSyB+bGVuKVxuOztcblxubGV0IGZsb2NrIGZkIGxvY2tfbW9kZSA9XG4gIGxldCBtb2RlID0gTG9ja19tb2RlLmZsb2NrX2NvbW1hbmQgbG9ja19tb2RlIGluXG4gIEZkLnN5c2NhbGxfaW5fdGhyZWFkX2V4biBmZCB+bmFtZTpcImZsb2NrXCIgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgVW5peC5mbG9ja19ibG9ja2luZyBmaWxlX2Rlc2NyIG1vZGUpXG47O1xuXG5sZXQgdHJ5X2Zsb2NrIGZkIGxvY2tfbW9kZSA9XG4gIGxldCBtb2RlID0gTG9ja19tb2RlLmZsb2NrX2NvbW1hbmQgbG9ja19tb2RlIGluXG4gIEZkLnN5c2NhbGxfZXhuIGZkIChmdW4gZmlsZV9kZXNjciAtPiBVbml4LmZsb2NrIGZpbGVfZGVzY3IgbW9kZSlcbjs7XG5cbmxldCBmdW5sb2NrIGZkID1cbiAgRmQuc3lzY2FsbF9leG4gZmQgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgaWdub3JlIChVbml4LmZsb2NrIGZpbGVfZGVzY3IgVW5peC5GbG9ja19jb21tYW5kLnVubG9jayA6IGJvb2wpKVxuOztcblxubW9kdWxlIExvY2tfbWVjaGFuaXNtID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTG9ja2ZcbiAgICAgIHwgRmxvY2tcbiAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBlbnVtZXJhdGUsIHNleHAsIHZhcmlhbnRzXVxuICBlbmRcblxuICBsZXQgbG9jayAodCA6IFQudCkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgTG9ja2YgLT4gbG9ja2YgP2xlbjpOb25lXG4gICAgfCBGbG9jayAtPiBmbG9ja1xuICA7O1xuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIFNleHBhYmxlLlRvX3N0cmluZ2FibGUgKFQpXG5cbiAgbGV0IGFyZ190eXBlID0gQ29tbWFuZC5QYXJhbS5BcmdfdHlwZS5FeHBvcnQuc2V4cF9jb252IFQudF9vZl9zZXhwXG5lbmRcblxubW9kdWxlIExvY2sgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG1vZGUgOiBMb2NrX21vZGUudFxuICAgIDsgbWVjaGFuaXNtIDogTG9ja19tZWNoYW5pc20udFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5sZXQgd2l0aF9maWxlID9sb2NrID9wZXJtIGZpbGUgfm1vZGUgfmYgPVxuICAoKiBIZXJlIHdlIHJlbHkgb24gY2xvc2luZyB0aGUgZmQgdG8gcmVsZWFzZSB0aGUgbG9jayBpZiBhcHByb3ByaWF0ZS4gSW4gdGhlIGNhc2Ugb2ZcbiAgICAgZmxvY2ssIHRoaXMgd2lsbCByZWxlYXNlIHRoZSBsb2NrIG9ubHkgaWYgbm8gb3RoZXIgZmRzIGFyZSBwb2ludGluZyB0byB0aGUgc2FtZSBmaWxlXG4gICAgIGRlc2NyaXB0aW9uIGluIHRoZSBrZXJuZWwuIFRoaXMgd2lsbCBvbmx5IGhhcHBlbiBpZiBbZl0gZHVwcyBvciBvdGhlcndpc2UgY29waWVzIHRoZVxuICAgICBmZC5cblxuICAgICBUaGUgcXVlc3Rpb24gb2Ygd2hhdCBoYXBwZW5zIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhIGZpbGUgc3VjaCBhc1xuICAgICBbL2Rldi9mZCpdIGlzIGxlZnQgYXMgYW4gZXhlcmNpc2UgdG8gdGhlIGNhbGxlci4gKilcbiAgbGV0IGRvaXQgZiA9XG4gICAgbGV0JWJpbmQgZmQgPSBvcGVuZmlsZSBmaWxlIH5tb2RlID9wZXJtIGluXG4gICAgRmQud2l0aF9jbG9zZSBmZCB+ZlxuICBpblxuICBtYXRjaCBsb2NrIHdpdGhcbiAgfCBOb25lIC0+IGRvaXQgZlxuICB8IFNvbWUgeyBMb2NrLm1vZGU7IG1lY2hhbmlzbSB9IC0+XG4gICAgZG9pdCAoZnVuIGZkIC0+XG4gICAgICBsZXQlYmluZCAoKSA9IExvY2tfbWVjaGFuaXNtLmxvY2sgbWVjaGFuaXNtIGZkIG1vZGUgaW5cbiAgICAgIGYgZmQpXG47O1xuXG4oKiBmaWxlIHN0YXR1cyAqKVxuXG5tb2R1bGUgRmlsZV9raW5kID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIFsgYEZpbGVcbiAgICAgIHwgYERpcmVjdG9yeVxuICAgICAgfCBgQ2hhclxuICAgICAgfCBgQmxvY2tcbiAgICAgIHwgYExpbmtcbiAgICAgIHwgYEZpZm9cbiAgICAgIHwgYFNvY2tldFxuICAgICAgXVxuICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHAsIGJpbl9pb11cbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuXG4gIGxldCBvZl91bml4IDogVW5peC5maWxlX2tpbmQgLT4gXyA9IGZ1bmN0aW9uXG4gICAgfCBTX1JFRyAtPiBgRmlsZVxuICAgIHwgU19ESVIgLT4gYERpcmVjdG9yeVxuICAgIHwgU19DSFIgLT4gYENoYXJcbiAgICB8IFNfQkxLIC0+IGBCbG9ja1xuICAgIHwgU19MTksgLT4gYExpbmtcbiAgICB8IFNfRklGTyAtPiBgRmlmb1xuICAgIHwgU19TT0NLIC0+IGBTb2NrZXRcbiAgOztcblxuICBsZXQgdG9fdW5peCA6IHQgLT4gVW5peC5maWxlX2tpbmQgPSBmdW5jdGlvblxuICAgIHwgYEZpbGUgLT4gU19SRUdcbiAgICB8IGBEaXJlY3RvcnkgLT4gU19ESVJcbiAgICB8IGBDaGFyIC0+IFNfQ0hSXG4gICAgfCBgQmxvY2sgLT4gU19CTEtcbiAgICB8IGBMaW5rIC0+IFNfTE5LXG4gICAgfCBgRmlmbyAtPiBTX0ZJRk9cbiAgICB8IGBTb2NrZXQgLT4gU19TT0NLXG4gIDs7XG5cbiAgbGV0IG9mX29jYW1sX3VyaW5nIDogSW9fdXJpbmdfcmF3LlN0YXR4LmtpbmQgLT4gXyA9IGZ1bmN0aW9uXG4gICAgfCBgVW5rbm93biAtPiByYWlzZSAoVW5peC5Vbml4X2Vycm9yIChVbml4LkVJTlZBTCwgXCJmc3RhdFwiLCBcIlwiKSlcbiAgICB8IGBGaWZvIC0+IGBGaWZvXG4gICAgfCBgQ2hhcmFjdGVyX3NwZWNpYWwgLT4gYENoYXJcbiAgICB8IGBEaXJlY3RvcnkgLT4gYERpcmVjdG9yeVxuICAgIHwgYEJsb2NrX2RldmljZSAtPiBgQmxvY2tcbiAgICB8IGBSZWd1bGFyX2ZpbGUgLT4gYEZpbGVcbiAgICB8IGBTeW1ib2xpY19saW5rIC0+IGBMaW5rXG4gICAgfCBgU29ja2V0IC0+IGBTb2NrZXRcbiAgOztcbmVuZFxuXG5tb2R1bGUgU3RhdHMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGRldiA6IGludFxuICAgIDsgaW5vIDogaW50XG4gICAgOyBraW5kIDogRmlsZV9raW5kLnRcbiAgICA7IHBlcm0gOiBmaWxlX3Blcm1cbiAgICA7IG5saW5rIDogaW50XG4gICAgOyB1aWQgOiBpbnRcbiAgICA7IGdpZCA6IGludFxuICAgIDsgcmRldiA6IGludFxuICAgIDsgc2l6ZSA6IGludDY0XG4gICAgOyBhdGltZSA6IFRpbWUudFxuICAgIDsgbXRpbWUgOiBUaW1lLnRcbiAgICA7IGN0aW1lIDogVGltZS50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMsIHNleHAsIGJpbl9pbywgY29tcGFyZV1cblxuICBsZXQgb2ZfdW5peCAodSA6IFVuaXguc3RhdHMpID1cbiAgICBsZXQgb2ZfZmxvYXRfc2VjIGYgPSBUaW1lLm9mX3NwYW5fc2luY2VfZXBvY2ggKFRpbWUuU3Bhbi5vZl9zZWMgZikgaW5cbiAgICB7IGRldiA9IHUuc3RfZGV2XG4gICAgOyBpbm8gPSB1LnN0X2lub1xuICAgIDsga2luZCA9IEZpbGVfa2luZC5vZl91bml4IHUuc3Rfa2luZFxuICAgIDsgcGVybSA9IHUuc3RfcGVybVxuICAgIDsgbmxpbmsgPSB1LnN0X25saW5rXG4gICAgOyB1aWQgPSB1LnN0X3VpZFxuICAgIDsgZ2lkID0gdS5zdF9naWRcbiAgICA7IHJkZXYgPSB1LnN0X3JkZXZcbiAgICA7IHNpemUgPSB1LnN0X3NpemVcbiAgICA7IGF0aW1lID0gb2ZfZmxvYXRfc2VjIHUuc3RfYXRpbWVcbiAgICA7IG10aW1lID0gb2ZfZmxvYXRfc2VjIHUuc3RfbXRpbWVcbiAgICA7IGN0aW1lID0gb2ZfZmxvYXRfc2VjIHUuc3RfY3RpbWVcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHRvX3VuaXggKHUgOiB0KSA6IFVuaXguc3RhdHMgPVxuICAgIGxldCB0b19mbG9hdF9zZWMgZiA9IFRpbWUuU3Bhbi50b19zZWMgKFRpbWUudG9fc3Bhbl9zaW5jZV9lcG9jaCBmKSBpblxuICAgIHsgc3RfZGV2ID0gdS5kZXZcbiAgICA7IHN0X2lubyA9IHUuaW5vXG4gICAgOyBzdF9raW5kID0gRmlsZV9raW5kLnRvX3VuaXggdS5raW5kXG4gICAgOyBzdF9wZXJtID0gdS5wZXJtXG4gICAgOyBzdF9ubGluayA9IHUubmxpbmtcbiAgICA7IHN0X3VpZCA9IHUudWlkXG4gICAgOyBzdF9naWQgPSB1LmdpZFxuICAgIDsgc3RfcmRldiA9IHUucmRldlxuICAgIDsgc3Rfc2l6ZSA9IHUuc2l6ZVxuICAgIDsgc3RfYXRpbWUgPSB0b19mbG9hdF9zZWMgdS5hdGltZVxuICAgIDsgc3RfbXRpbWUgPSB0b19mbG9hdF9zZWMgdS5tdGltZVxuICAgIDsgc3RfY3RpbWUgPSB0b19mbG9hdF9zZWMgdS5jdGltZVxuICAgIH1cbiAgOztcblxuICBsZXQgb2Zfb2NhbWxfdXJpbmdfc3RhdHggKHUgOiBJb191cmluZ19yYXcuU3RhdHgudCkgPVxuICAgIGxldCBvcGVuIElvX3VyaW5nX3JhdyBpblxuICAgIGxldCBvZl90aW1lc3BlYyBzZWMgbnNlYyA9XG4gICAgICBUaW1lLm9mX3NwYW5fc2luY2VfZXBvY2ggVGltZS5TcGFuLihvZl9pbnRfc2VjIHNlYyArIG9mX2ludF9ucyBuc2VjKVxuICAgIGluXG4gICAgeyBkZXYgPSBTdGF0eC5kZXYgdSB8PiBJbnQ2NC50b19pbnRfZXhuXG4gICAgOyBpbm8gPSBTdGF0eC5pbm8gdSB8PiBJbnQ2NC50b19pbnRfZXhuXG4gICAgOyBraW5kID0gRmlsZV9raW5kLm9mX29jYW1sX3VyaW5nIChTdGF0eC5raW5kIHUpXG4gICAgOyBwZXJtID0gU3RhdHgucGVybSB1XG4gICAgOyBubGluayA9IFN0YXR4Lm5saW5rIHUgfD4gSW50NjQudG9faW50X2V4blxuICAgIDsgdWlkID0gU3RhdHgudWlkIHUgfD4gSW50NjQudG9faW50X2V4blxuICAgIDsgZ2lkID0gU3RhdHguZ2lkIHUgfD4gSW50NjQudG9faW50X2V4blxuICAgIDsgcmRldiA9IFN0YXR4LnJkZXYgdSB8PiBJbnQ2NC50b19pbnRfZXhuXG4gICAgOyBzaXplID0gU3RhdHguc2l6ZSB1XG4gICAgOyBhdGltZSA9IG9mX3RpbWVzcGVjIChTdGF0eC5hdGltZV9zZWMgdSB8PiBJbnQ2NC50b19pbnRfZXhuKSAoU3RhdHguYXRpbWVfbnNlYyB1KVxuICAgIDsgbXRpbWUgPSBvZl90aW1lc3BlYyAoU3RhdHgubXRpbWVfc2VjIHUgfD4gSW50NjQudG9faW50X2V4bikgKFN0YXR4Lm10aW1lX25zZWMgdSlcbiAgICA7IGN0aW1lID0gb2ZfdGltZXNwZWMgKFN0YXR4LmN0aW1lX3NlYyB1IHw+IEludDY0LnRvX2ludF9leG4pIChTdGF0eC5jdGltZV9uc2VjIHUpXG4gICAgfVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgdCA9IFNleHAudG9fc3RyaW5nIChzZXhwX29mX3QgdClcbmVuZFxuXG5sZXQgZnN0YXQgZmQgPVxuICBtYXRjaCBJb191cmluZ19yYXdfc2luZ2xldG9uLnRoZV9vbmVfYW5kX29ubHkgKCkgd2l0aFxuICB8IFNvbWUgdXJpbmcgLT5cbiAgICBJb191cmluZy5mc3RhdCB1cmluZyBmZCA+PnwgZnVuIHJlcyAtPiBSZXN1bHQub2tfZXhuIHJlcyB8PiBTdGF0cy5vZl9vY2FtbF91cmluZ19zdGF0eFxuICB8IE5vbmUgLT4gRmQuc3lzY2FsbF9pbl90aHJlYWRfZXhuIGZkIH5uYW1lOlwiZnN0YXRcIiBVbml4LmZzdGF0ID4+fCBTdGF0cy5vZl91bml4XG47O1xuXG5sZXQgc3RhdCBmaWxlbmFtZSA9XG4gIG1hdGNoIElvX3VyaW5nX3Jhd19zaW5nbGV0b24udGhlX29uZV9hbmRfb25seSAoKSB3aXRoXG4gIHwgU29tZSB1cmluZyAtPlxuICAgIElvX3VyaW5nLnN0YXQgdXJpbmcgZmlsZW5hbWVcbiAgICA+PnwgZnVuIHJlcyAtPiBSZXN1bHQub2tfZXhuIHJlcyB8PiBTdGF0cy5vZl9vY2FtbF91cmluZ19zdGF0eFxuICB8IE5vbmUgLT5cbiAgICBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJzdGF0XCIgKGZ1biAoKSAtPiBVbml4LnN0YXQgZmlsZW5hbWUpID4+fCBTdGF0cy5vZl91bml4XG47O1xuXG5sZXQgbHN0YXQgZmlsZW5hbWUgPVxuICBtYXRjaCBJb191cmluZ19yYXdfc2luZ2xldG9uLnRoZV9vbmVfYW5kX29ubHkgKCkgd2l0aFxuICB8IFNvbWUgdXJpbmcgLT5cbiAgICBJb191cmluZy5sc3RhdCB1cmluZyBmaWxlbmFtZVxuICAgID4+fCBmdW4gcmVzIC0+IFJlc3VsdC5va19leG4gcmVzIHw+IFN0YXRzLm9mX29jYW1sX3VyaW5nX3N0YXR4XG4gIHwgTm9uZSAtPlxuICAgIEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcImxzdGF0XCIgKGZ1biAoKSAtPiBVbml4LmxzdGF0IGZpbGVuYW1lKSA+PnwgU3RhdHMub2ZfdW5peFxuOztcblxuKCogV2UgdHJlYXQgW2lzYXR0eV0gYXMgYSBibG9ja2luZyBvcGVyYXRpb24sIGJlY2F1c2UgaXQgYWN0cyBvbiBhIGZpbGUuICopXG5sZXQgaXNhdHR5IGZkID0gRmQuc3lzY2FsbF9pbl90aHJlYWRfZXhuIGZkIH5uYW1lOlwiaXNhdHR5XCIgVW5peC5pc2F0dHlcblxuKCogb3BlcmF0aW9ucyBvbiBmaWxlbmFtZXMgKilcblxubGV0IHVubGluayBmaWxlbmFtZSA9XG4gIG1hdGNoIElvX3VyaW5nX3Jhd19zaW5nbGV0b24udGhlX29uZV9hbmRfb25seSAoKSB3aXRoXG4gIHwgU29tZSB1cmluZyAtPiBJb191cmluZy51bmxpbmsgdXJpbmcgfmRpcjpmYWxzZSBmaWxlbmFtZSA+PnwgUmVzdWx0Lm9rX2V4blxuICB8IE5vbmUgLT4gSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwidW5saW5rXCIgKGZ1biAoKSAtPiBVbml4LnVubGluayBmaWxlbmFtZSlcbjs7XG5cbmxldCByZW1vdmUgZmlsZW5hbWUgPVxuICBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJyZW1vdmVcIiAoZnVuICgpIC0+IFVuaXgucmVtb3ZlIGZpbGVuYW1lKVxuOztcblxubGV0IHJlbmFtZSB+c3JjIH5kc3QgPVxuICBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJyZW5hbWVcIiAoZnVuICgpIC0+IFVuaXgucmVuYW1lIH5zcmMgfmRzdClcbjs7XG5cbmxldCBsaW5rID9mb3JjZSB+dGFyZ2V0IH5saW5rX25hbWUgKCkgPVxuICBtYXRjaCBJb191cmluZ19yYXdfc2luZ2xldG9uLnRoZV9vbmVfYW5kX29ubHkgKCkgd2l0aFxuICB8IFNvbWUgdXJpbmcgLT4gSW9fdXJpbmcubGluayB1cmluZyA/Zm9yY2UgfnRhcmdldCB+bGlua19uYW1lICgpID4+fCBSZXN1bHQub2tfZXhuXG4gIHwgTm9uZSAtPlxuICAgIEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcImxpbmtcIiAoZnVuICgpIC0+IFVuaXgubGluayA/Zm9yY2UgfnRhcmdldCB+bGlua19uYW1lICgpKVxuOztcblxuKCogZmlsZSBwZXJtaXNzaW9uIGFuZCBvd25lcnNoaXAgKilcblxubGV0IGNobW9kIGZpbGVuYW1lIH5wZXJtID1cbiAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwiY2htb2RcIiAoZnVuICgpIC0+IFVuaXguY2htb2QgZmlsZW5hbWUgfnBlcm0pXG47O1xuXG5sZXQgZmNobW9kIGZkIH5wZXJtID1cbiAgRmQuc3lzY2FsbF9pbl90aHJlYWRfZXhuIGZkIH5uYW1lOlwiZmNobW9kXCIgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgVW5peC5mY2htb2QgZmlsZV9kZXNjciB+cGVybSlcbjs7XG5cbmxldCBjaG93biBmaWxlbmFtZSB+dWlkIH5naWQgPVxuICBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJjaG93blwiIChmdW4gKCkgLT4gVW5peC5jaG93biBmaWxlbmFtZSB+dWlkIH5naWQpXG47O1xuXG5sZXQgZmNob3duIGZkIH51aWQgfmdpZCA9XG4gIEZkLnN5c2NhbGxfaW5fdGhyZWFkX2V4biBmZCB+bmFtZTpcImZjaG93blwiIChmdW4gZmlsZV9kZXNjciAtPlxuICAgIFVuaXguZmNob3duIGZpbGVfZGVzY3IgfnVpZCB+Z2lkKVxuOztcblxubGV0IGFjY2VzcyBmaWxlbmFtZSBwZXJtID1cbiAgbWF0Y2glbWFwXG4gICAgTW9uaXRvci50cnlfd2l0aCB+cnVuOmBTY2hlZHVsZSB+cmVzdDpgTG9nIChmdW4gKCkgLT5cbiAgICAgIEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcImFjY2Vzc1wiIChmdW4gKCkgLT4gVW5peC5hY2Nlc3MgZmlsZW5hbWUgcGVybSkpXG4gIHdpdGhcbiAgfCBPayByZXMgLT4gcmVzXG4gIHwgRXJyb3IgZXhuIC0+IEVycm9yIChNb25pdG9yLmV4dHJhY3RfZXhuIGV4bilcbjs7XG5cbmxldCBhY2Nlc3NfZXhuIGZpbGVuYW1lIHBlcm0gPVxuICBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJhY2Nlc3NcIiAoZnVuICgpIC0+IFVuaXguYWNjZXNzX2V4biBmaWxlbmFtZSBwZXJtKVxuOztcblxuKCogb3BlcmF0aW9ucyBvbiBmaWxlIGRlc2NyaXB0b3JzICopXG5cbmxldCBzZXRfY2xvc2Vfb25fZXhlYyBmZCA9IEZkLndpdGhfZmlsZV9kZXNjcl9leG4gZmQgVW5peC5zZXRfY2xvc2Vfb25fZXhlY1xubGV0IGNsZWFyX2Nsb3NlX29uX2V4ZWMgZmQgPSBGZC53aXRoX2ZpbGVfZGVzY3JfZXhuIGZkIFVuaXguY2xlYXJfY2xvc2Vfb25fZXhlY1xuXG5sZXQgbWtkaXIgP3AgPyhwZXJtID0gMG83NzcpIGRpcm5hbWUgPVxuICBtYXRjaCBwIHdpdGhcbiAgfCBOb25lIC0+IEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcIm1rZGlyXCIgKGZ1biAoKSAtPiBVbml4Lm1rZGlyIGRpcm5hbWUgfnBlcm0pXG4gIHwgU29tZSAoKSAtPiBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJta2RpclwiIChmdW4gKCkgLT4gVW5peC5ta2Rpcl9wIGRpcm5hbWUgfnBlcm0pXG47O1xuXG5sZXQgcm1kaXIgZGlybmFtZSA9IEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcInJtZGlyXCIgKGZ1biAoKSAtPiBVbml4LnJtZGlyIGRpcm5hbWUpXG5sZXQgY2hkaXIgZGlybmFtZSA9IEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcImNoZGlyXCIgKGZ1biAoKSAtPiBVbml4LmNoZGlyIGRpcm5hbWUpXG5sZXQgY2hyb290IGRpcm5hbWUgPSBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJjaHJvb3RcIiAoZnVuICgpIC0+IFVuaXguY2hyb290IGRpcm5hbWUpXG5sZXQgZ2V0Y3dkICgpID0gSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwiZ2V0Y3dkXCIgKGZ1biAoKSAtPiBVbml4LmdldGN3ZCAoKSlcblxudHlwZSBkaXJfaGFuZGxlID0gVW5peC5kaXJfaGFuZGxlXG5cbmxldCBvcGVuZGlyIGRpcm5hbWUgPVxuICBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJvcGVuZGlyXCIgKGZ1biAoKSAtPiBVbml4Lm9wZW5kaXIgZGlybmFtZSlcbjs7XG5cbmxldCByZWFkZGlyX29wdCBoYW5kbGUgPVxuICBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJyZWFkZGlyXCIgKGZ1biAoKSAtPiBVbml4LnJlYWRkaXJfb3B0IGhhbmRsZSlcbjs7XG5cbmxldCByZXdpbmRkaXIgaGFuZGxlID1cbiAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwicmV3aW5kZGlyXCIgKGZ1biAoKSAtPiBVbml4LnJld2luZGRpciBoYW5kbGUpXG47O1xuXG5sZXQgY2xvc2VkaXIgaGFuZGxlID1cbiAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwiY2xvc2VkaXJcIiAoZnVuICgpIC0+IFVuaXguY2xvc2VkaXIgaGFuZGxlKVxuOztcblxubGV0IHBpcGUgaW5mbyA9XG4gIGxldCVtYXAgcmVhZGVyLCB3cml0ZXIgPVxuICAgIEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcInBpcGVcIiAoZnVuICgpIC0+IFVuaXgucGlwZSB+Y2xvc2Vfb25fZXhlYzp0cnVlICgpKVxuICBpblxuICBsZXQgY3JlYXRlIGZpbGVfZGVzY3Iga2luZCA9IEZkLmNyZWF0ZSBGaWZvIGZpbGVfZGVzY3IgKEluZm8udGFnIGluZm8gfnRhZzpraW5kKSBpblxuICBgUmVhZGVyIChjcmVhdGUgcmVhZGVyIFwicmVhZGVyXCIpLCBgV3JpdGVyIChjcmVhdGUgd3JpdGVyIFwid3JpdGVyXCIpXG47O1xuXG5sZXQgbWtmaWZvID8ocGVybSA9IDBvNjY2KSBuYW1lID1cbiAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwibWtmaWZvXCIgKGZ1biAoKSAtPiBVbml4Lm1rZmlmbyBuYW1lIH5wZXJtKVxuOztcblxuKCogc3ltbGlua3MgKilcbmxldCBzeW1saW5rIH50YXJnZXQgfmxpbmtfbmFtZSA9XG4gIEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcInN5bWxpbmtcIiAoZnVuICgpIC0+IFVuaXguc3ltbGluayB+dGFyZ2V0IH5saW5rX25hbWUpXG47O1xuXG5sZXQgcmVhZGxpbmsgZmlsZW5hbWUgPVxuICBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJyZWFkbGlua1wiIChmdW4gKCkgLT4gVW5peC5yZWFkbGluayBmaWxlbmFtZSlcbjs7XG5cbmxldCBta2R0ZW1wIGZpbGVuYW1lID1cbiAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwibWtkdGVtcFwiIChmdW4gKCkgLT4gVW5peC5ta2R0ZW1wIGZpbGVuYW1lKVxuOztcblxubGV0IG1rc3RlbXAgZmlsZW5hbWUgPVxuICBsZXQlbWFwIG5hbWUsIGZpbGVfZGVzY3IgPVxuICAgIEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcIm1rc3RlbXBcIiAoZnVuICgpIC0+IFVuaXgubWtzdGVtcCBmaWxlbmFtZSlcbiAgaW5cbiAgbmFtZSwgRmQuY3JlYXRlIEZpbGUgZmlsZV9kZXNjciAoSW5mby5vZl9zdHJpbmcgbmFtZSlcbjs7XG5cbmxldCBnZXRncm91cGxpc3QgdXNlcm5hbWUgZ2lkID1cbiAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwiZ2V0Z3JvdXBsaXN0XCIgKGZ1biAoKSAtPiBVbml4LmdldGdyb3VwbGlzdCB1c2VybmFtZSBnaWQpXG47O1xuXG50eXBlIHByb2Nlc3NfdGltZXMgPSBVbml4LnByb2Nlc3NfdGltZXMgPVxuICB7IHRtc191dGltZSA6IGZsb2F0XG4gIDsgdG1zX3N0aW1lIDogZmxvYXRcbiAgOyB0bXNfY3V0aW1lIDogZmxvYXRcbiAgOyB0bXNfY3N0aW1lIDogZmxvYXRcbiAgfVxuXG5sZXQgdGltZXMgPSBVbml4LnRpbWVzXG5cbnR5cGUgdG0gPSBVbml4LnRtID1cbiAgeyB0bV9zZWMgOiBpbnRcbiAgOyB0bV9taW4gOiBpbnRcbiAgOyB0bV9ob3VyIDogaW50XG4gIDsgdG1fbWRheSA6IGludFxuICA7IHRtX21vbiA6IGludFxuICA7IHRtX3llYXIgOiBpbnRcbiAgOyB0bV93ZGF5IDogaW50XG4gIDsgdG1feWRheSA6IGludFxuICA7IHRtX2lzZHN0IDogYm9vbFxuICB9XG5cbmxldCB0aW1lID0gVW5peC50aW1lXG5sZXQgZ2V0dGltZW9mZGF5ID0gVW5peC5nZXR0aW1lb2ZkYXlcbmxldCBnbXRpbWUgPSBVbml4LmdtdGltZVxubGV0IGxvY2FsdGltZSA9IFVuaXgubG9jYWx0aW1lXG5sZXQgbWt0aW1lID0gVW5peC5ta3RpbWVcblxubGV0IHV0aW1lcyBuYW1lIH5hY2Nlc3Mgfm1vZGlmID1cbiAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwidXRpbWVzXCIgKGZ1biAoKSAtPiBVbml4LnV0aW1lcyBuYW1lIH5hY2Nlc3Mgfm1vZGlmKVxuOztcblxuKCogZW52aXJvbm1lbnQgKilcblxudHlwZSBlbnYgPSBVbml4LmVudiBbQEBkZXJpdmluZyBzZXhwXVxuXG5sZXQgZW52aXJvbm1lbnQgPSBVbml4LmVudmlyb25tZW50XG5sZXQgZ2V0ZW52ID0gU3lzLmdldGVudlxubGV0IGdldGVudl9leG4gPSBTeXMuZ2V0ZW52X2V4blxubGV0IHVuc2FmZV9nZXRlbnYgPSBTeXNfdW5peC51bnNhZmVfZ2V0ZW52XG5sZXQgdW5zYWZlX2dldGVudl9leG4gPSBTeXNfdW5peC51bnNhZmVfZ2V0ZW52X2V4blxubGV0IHB1dGVudiA9IFVuaXgucHV0ZW52XG5sZXQgdW5zZXRlbnYgPSBVbml4LnVuc2V0ZW52XG5cbigqIHByb2Nlc3NlcyAqKVxuXG5sZXQgZm9ya19leGVjIH5wcm9nIH5hcmd2ID91c2VfcGF0aCA/ZW52ICgpID1cbiAgSW5fdGhyZWFkLnJ1biAoZnVuICgpIC0+IFVuaXguZm9ya19leGVjIH5wcm9nIH5hcmd2ID91c2VfcGF0aCA/ZW52ICgpKVxuOztcblxudHlwZSB3YWl0X29uID0gVW5peC53YWl0X29uIFtAQGRlcml2aW5nIHNleHBfcG9seV1cblxubGV0IHdhaXRfbm9oYW5nID0gVW5peC53YWl0X25vaGFuZ1xubGV0IHdhaXRfbm9oYW5nX3VudHJhY2VkID0gVW5peC53YWl0X25vaGFuZ191bnRyYWNlZFxuXG5tb2R1bGUgV2FpdCA6IHNpZ1xuICB2YWwgY2hlY2tfYWxsIDogdW5pdCAtPiB1bml0XG4gIHZhbCBkb19ub3RfaGFuZGxlX3NpZ2NobGQgOiB1bml0IC0+IHVuaXRcbiAgdmFsIHdhaXRwaWQgOiBQaWQudCAtPiBFeGl0X29yX3NpZ25hbC50IERlZmVycmVkLnRcbiAgdmFsIHdhaXQgOiB3YWl0X29uIC0+IChQaWQudCAqIEV4aXRfb3Jfc2lnbmFsLnQpIERlZmVycmVkLnRcbiAgdmFsIHdhaXRfdW50cmFjZWQgOiB3YWl0X29uIC0+IChQaWQudCAqIEV4aXRfb3Jfc2lnbmFsX29yX3N0b3AudCkgRGVmZXJyZWQudFxuZW5kID0gc3RydWN0XG4gIG1vZHVsZSBLaW5kID0gc3RydWN0XG4gICAgdHlwZSAoXywgXykgdCA9XG4gICAgICB8IE5vcm1hbCA6ICh3YWl0X29uLCBQaWQudCAqIEV4aXRfb3Jfc2lnbmFsLnQpIHRcbiAgICAgIHwgVW50cmFjZWQgOiAod2FpdF9vbiwgUGlkLnQgKiBFeGl0X29yX3NpZ25hbF9vcl9zdG9wLnQpIHRcbiAgICAgIHwgV2FpdHBpZCA6IChQaWQudCwgRXhpdF9vcl9zaWduYWwudCkgdFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgd2FpdHBpZF9ub2hhbmcgcGlkID1cbiAgICAgIGxldCByZXMgPSB3YWl0X25vaGFuZyAoYFBpZCBwaWQpIGluXG4gICAgICBtYXRjaCByZXMgd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgIHwgU29tZSAocGlkMiwgZXhpdF9vcl9zaWduYWwpIC0+XG4gICAgICAgIGFzc2VydCAoUGlkLiggPSApIHBpZDIgcGlkKTtcbiAgICAgICAgU29tZSBleGl0X29yX3NpZ25hbFxuICAgIDs7XG5cbiAgICBsZXQgd2FpdF9ub2hhbmcgOiB0eXBlIHEgci4gKHEsIHIpIHQgLT4gcSAtPiByIG9wdGlvbiA9XG4gICAgICBmdW4gdCB3YWl0X29uIC0+XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgTm9ybWFsIC0+IHdhaXRfbm9oYW5nIHdhaXRfb25cbiAgICAgIHwgVW50cmFjZWQgLT4gd2FpdF9ub2hhbmdfdW50cmFjZWQgd2FpdF9vblxuICAgICAgfCBXYWl0cGlkIC0+IHdhaXRwaWRfbm9oYW5nIHdhaXRfb25cbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgV2FpdCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB8IFQgOlxuICAgICAgICAgIHsga2luZCA6ICgncSwgJ3IpIEtpbmQudFxuICAgICAgICAgIDsgbW9uaXRvciA6IE1vbml0b3IudFxuICAgICAgICAgIDsgcmVzdWx0IDogJ3IgSXZhci50XG4gICAgICAgICAgOyB3YWl0X29uIDogJ3FcbiAgICAgICAgICB9XG4gICAgICAgICAgLT4gdFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgY2hlY2sgKFQgdCkgPVxuICAgICAgbWF0Y2ggS2luZC53YWl0X25vaGFuZyB0LmtpbmQgdC53YWl0X29uIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgfCBTb21lIHggLT5cbiAgICAgICAgSXZhci5maWxsX2V4biB0LnJlc3VsdCB4O1xuICAgICAgICB0cnVlXG4gICAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgICAgTW9uaXRvci5zZW5kX2V4biB0Lm1vbml0b3IgZXhuO1xuICAgICAgICB0cnVlXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHdhaXRzIDogV2FpdC50IGxpc3QgcmVmID0gcmVmIFtdXG5cbiAgbGV0IGFkZCB+a2luZCB+cmVzdWx0IH53YWl0X29uIH5tb25pdG9yID1cbiAgICB3YWl0cyA6PSBUIHsga2luZDsgcmVzdWx0OyB3YWl0X29uOyBtb25pdG9yIH0gOjogIXdhaXRzXG4gIDs7XG5cbiAgbGV0IGNoZWNrX2FsbCAoKSA9IHdhaXRzIDo9IExpc3QuZmlsdGVyICF3YWl0cyB+ZjooRm4ubm9uIFdhaXQuY2hlY2spXG4gIGxldCBzaG91bGRfaGFuZGxlX3NpZ2NobGQgPSByZWYgdHJ1ZVxuICBsZXQgYW1faGFuZGxpbmdfc2lnY2hsZCA9IHJlZiBmYWxzZVxuXG4gIGxldCBkb19ub3RfaGFuZGxlX3NpZ2NobGQgKCkgPVxuICAgIGlmICFhbV9oYW5kbGluZ19zaWdjaGxkIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJhbHJlYWR5IGhhbmRsaW5nIFNJR0NITERcIiBbJWhlcmVdXTtcbiAgICBzaG91bGRfaGFuZGxlX3NpZ2NobGQgOj0gZmFsc2VcbiAgOztcblxuICBsZXQgaW5zdGFsbF9zaWdjaGxkX2hhbmRsZXJfdGhlX2ZpcnN0X3RpbWUgPVxuICAgIGxhenlcbiAgICAgIChpZiAhc2hvdWxkX2hhbmRsZV9zaWdjaGxkXG4gICAgICAgdGhlbiAoXG4gICAgICAgICBhbV9oYW5kbGluZ19zaWdjaGxkIDo9IHRydWU7XG4gICAgICAgICAoKiBzaW5jZSBbY2hlY2tfYWxsXSBtYW5hZ2VzIGl0cyBvd24gbW9uaXRvcnMgYW5kIGRvZXMgbm90IHJhaXNlIGV4Y2VwdGlvbnMsIHdlXG4gICAgICAgICAgICBleGVjdXRlIHRoZSBbQXN5bmNfc2lnbmFsLmhhbmRsZV0gaW4gdGhlIG1haW4gZXhlY3V0aW9uIGNvbnRleHQgdG8gYXZvaWQgaXRcbiAgICAgICAgICAgIGtlZXBpbmcgYSByZWZlcmVuY2UgdG8gd2hhdGV2ZXIgbW9uaXRvciBpcyBjdXJyZW50IHdoZW5cbiAgICAgICAgICAgIFtpbnN0YWxsX3NpZ2NobGRfaGFuZGxlcl90aGVfZmlyc3RfdGltZV0gaXMgZmlyc3QgY29tcHV0ZWQgKilcbiAgICAgICAgIFNjaGVkdWxlci5Qcml2YXRlLih3aXRoX2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSlcbiAgICAgICAgICAgRXhlY3V0aW9uX2NvbnRleHQubWFpblxuICAgICAgICAgICB+ZjooZnVuICgpIC0+IEFzeW5jX3NpZ25hbC5oYW5kbGUgWyBTaWduYWwuY2hsZCBdIH5mOihmdW4gXyAtPiBjaGVja19hbGwgKCkpKSkpXG4gIDs7XG5cbiAgbGV0IGRlZmVycmVkX3dhaXQgKHR5cGUgcSByKSAod2FpdF9vbiA6IHEpIH4oa2luZCA6IChxLCByKSBLaW5kLnQpID1cbiAgICAoKiBXZSBhcmUgZ29pbmcgdG8gaW5zdGFsbCBhIGhhbmRsZXIgZm9yIFNJR0NITEQgdGhhdCB3aWxsIGNhbGwgW3dhaXRfbm9oYW5nIHdhaXRfb25dXG4gICAgICAgaW4gdGhlIGZ1dHVyZS4gIEhvd2V2ZXIsIHdlIG11c3QgYWxzbyBjYWxsIFt3YWl0X25vaGFuZyB3YWl0X29uXSByaWdodCBub3csIGluIGNhc2VcbiAgICAgICB0aGUgY2hpbGQgYWxyZWFkeSBleGl0ZWQsIGFuZCB3aWxsIHRodXMgbmV2ZXIgY2F1c2UgYSBTSUdDSExEIGluIHRoZSBmdXR1cmUuICBXZVxuICAgICAgIG11c3QgaW5zdGFsbCB0aGUgU0lHQ0hMRCBoYW5kbGVyIGZpcnN0IGFuZCB0aGVuIGNhbGwgW3dhaXRfbm9oYW5nXS4gIElmIHdlIGRpZFxuICAgICAgIFt3YWl0X25vaGFuZ10gZmlyc3QsIHdlIGNvdWxkIG1pc3MgYSBTSUdDSExEIHRoYXQgd2FzIGRlbGl2ZXJlZCBhZnRlciBjYWxsaW5nXG4gICAgICAgW3dhaXRfbm9oYW5nXSBhbmQgYmVmb3JlIGluc3RhbGxpbmcgdGhlIGhhbmRsZXIuICopXG4gICAgTGF6eS5mb3JjZSBpbnN0YWxsX3NpZ2NobGRfaGFuZGxlcl90aGVfZmlyc3RfdGltZTtcbiAgICBtYXRjaCBLaW5kLndhaXRfbm9oYW5nIGtpbmQgd2FpdF9vbiB3aXRoXG4gICAgfCBTb21lIHJlc3VsdCAtPiByZXR1cm4gcmVzdWx0XG4gICAgfCBOb25lIC0+XG4gICAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICAgICAgYWRkIH5raW5kIH5yZXN1bHQgfndhaXRfb24gfm1vbml0b3I6KE1vbml0b3IuY3VycmVudCAoKSkpXG4gIDs7XG5cbiAgbGV0IHdhaXQgd2FpdF9vbiA9IGRlZmVycmVkX3dhaXQgd2FpdF9vbiB+a2luZDpOb3JtYWxcbiAgbGV0IHdhaXRfdW50cmFjZWQgd2FpdF9vbiA9IGRlZmVycmVkX3dhaXQgd2FpdF9vbiB+a2luZDpVbnRyYWNlZFxuICBsZXQgd2FpdHBpZCBwaWQgPSBkZWZlcnJlZF93YWl0IHBpZCB+a2luZDpXYWl0cGlkXG5lbmRcblxubGV0IHdhaXQgPSBXYWl0LndhaXRcbmxldCB3YWl0X3VudHJhY2VkID0gV2FpdC53YWl0X3VudHJhY2VkXG5sZXQgd2FpdHBpZF9wcm9tcHQgPSBXYWl0LndhaXRwaWRcbmxldCB3YWl0cGlkID0gV2FpdC53YWl0cGlkXG5cbmxldCB3YWl0cGlkX2V4biBwaWQgPVxuICBsZXQlbWFwIGV4aXRfb3Jfc2lnbmFsID0gd2FpdHBpZCBwaWQgaW5cbiAgaWYgUmVzdWx0LmlzX2Vycm9yIGV4aXRfb3Jfc2lnbmFsXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJjaGlsZCBwcm9jZXNzIGRpZG4ndCBleGl0IHdpdGggc3RhdHVzIDBcIlxuICAgICAgICAgIH5jaGlsZF9waWQ6KHBpZCA6IFBpZC50KVxuICAgICAgICAgIChleGl0X29yX3NpZ25hbCA6IEV4aXRfb3Jfc2lnbmFsLnQpXVxuOztcblxubGV0IGRuc19sb29rdXAgfm5hbWUgZiA9XG4gIFJhd19zY2hlZHVsZXIud2l0aF90X29uY2Vfc3RhcnRlZCB+ZjooZnVuIHQgLT5cbiAgICBUaHJvdHRsZS5lbnF1ZXVlIHQuZG5zX2xvb2t1cF90aHJvdHRsZSAoZnVuICgpIC0+IEluX3RocmVhZC5ydW4gfm5hbWUgZikpXG47O1xuXG5tb2R1bGUgSW5ldF9hZGRyID0gc3RydWN0XG4gIGluY2x1ZGUgVW5peC5JbmV0X2FkZHJcblxuICBsZXQgb2Zfc3RyaW5nX29yX2dldGJ5bmFtZSBzID1cbiAgICBtYXRjaCBvZl9zdHJpbmcgcyB3aXRoXG4gICAgfCB0IC0+IERlZmVycmVkLnJldHVybiB0XG4gICAgfCBleGNlcHRpb24gXyAtPiBkbnNfbG9va3VwIH5uYW1lOlwiZ2V0YnluYW1lXCIgKGZ1biAoKSAtPiBvZl9zdHJpbmdfb3JfZ2V0YnluYW1lIHMpXG4gIDs7XG5lbmRcblxubW9kdWxlIENpZHIgPSBVbml4LkNpZHJcblxubGV0IGJpbmRfdG9faW50ZXJmYWNlX2V4biA9XG4gIE9yX2Vycm9yLm1hcCBMaW51eF9leHQuYmluZF90b19pbnRlcmZhY2UgfmY6KGZ1biBiaW5kX3RvX2ludGVyZmFjZSBmZCBzcGVjIC0+XG4gICAgRmQud2l0aF9maWxlX2Rlc2NyX2V4biBmZCAoZnVuIGZpbGVfZGVzY3IgLT4gYmluZF90b19pbnRlcmZhY2UgZmlsZV9kZXNjciBzcGVjKSlcbjs7XG5cbm1vZHVsZSBTb2NrZXQgPSBzdHJ1Y3RcbiAgbW9kdWxlIEFkZHJlc3MgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgSW5ldCA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gWyBgSW5ldCBvZiBJbmV0X2FkZHIudCAqIGludCBdIFtAQGRlcml2aW5nIGJpbl9pbywgY29tcGFyZSwgaGFzaF1cblxuICAgICAgbGV0IHRvX3N0cmluZ19pbnRlcm5hbCB+c2hvd19wb3J0X2luX3Rlc3QgKGBJbmV0IChhLCBwKSkgPVxuICAgICAgICBzcHJpbnRmXG4gICAgICAgICAgXCIlczolc1wiXG4gICAgICAgICAgKEluZXRfYWRkci50b19zdHJpbmcgYSlcbiAgICAgICAgICAoaWYgUHB4X2lubGluZV90ZXN0X2xpYi5hbV9ydW5uaW5nICYmIG5vdCBzaG93X3BvcnRfaW5fdGVzdFxuICAgICAgICAgICB0aGVuIFwiUE9SVFwiXG4gICAgICAgICAgIGVsc2UgcCB8PiBJbnQudG9fc3RyaW5nKVxuICAgICAgOztcblxuICAgICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ19pbnRlcm5hbCB+c2hvd19wb3J0X2luX3Rlc3Q6ZmFsc2VcbiAgICAgIGxldCBzZXhwX29mX3QgdCA6IFNleHAudCA9IEF0b20gKHRvX3N0cmluZyB0KVxuXG4gICAgICBtb2R1bGUgQmxvY2tpbmdfc2V4cCA9IHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBbIGBJbmV0IG9mIEluZXRfYWRkci5CbG9ja2luZ19zZXhwLnQgKiBpbnQgXVxuICAgICAgICBbQEBkZXJpdmluZyBiaW5faW8sIGNvbXBhcmUsIGhhc2gsIHNleHBdXG4gICAgICBlbmRcblxuICAgICAgbW9kdWxlIFNob3dfcG9ydF9pbl90ZXN0ID0gc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IFsgYEluZXQgb2YgSW5ldF9hZGRyLnQgKiBpbnQgXSBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdfaW50ZXJuYWwgfnNob3dfcG9ydF9pbl90ZXN0OnRydWVcbiAgICAgIGVuZFxuXG4gICAgICBsZXQgYWRkciAoYEluZXQgKGEsIF8pKSA9IGFcbiAgICAgIGxldCBwb3J0IChgSW5ldCAoXywgcCkpID0gcFxuXG4gICAgICBsZXQgdG9faG9zdF9hbmRfcG9ydCAoYEluZXQgKGFkZHIsIHBvcnQpKSA9XG4gICAgICAgIEhvc3RfYW5kX3BvcnQuY3JlYXRlIH5ob3N0OihJbmV0X2FkZHIudG9fc3RyaW5nIGFkZHIpIH5wb3J0XG4gICAgICA7O1xuXG4gICAgICBsZXQgY3JlYXRlIGEgfnBvcnQgPSBgSW5ldCAoYSwgcG9ydClcbiAgICAgIGxldCBjcmVhdGVfYmluZF9hbnkgfnBvcnQgPSBgSW5ldCAoSW5ldF9hZGRyLm9mX3N0cmluZyBcIjAuMC4wLjBcIiwgcG9ydClcblxuICAgICAgbGV0IG9mX3NvY2thZGRyX2V4biA6IFVuaXguc29ja2FkZHIgLT4gXyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgQUREUl9JTkVUIChhLCBpKSAtPiBgSW5ldCAoYSwgaSlcbiAgICAgICAgfCB1IC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiU29ja2V0LkFkZHJlc3MuaW5ldFwiIH5fOih1IDogVW5peC5zb2NrYWRkcildXG4gICAgICA7O1xuXG4gICAgICBsZXQgdG9fc29ja2FkZHIgKGBJbmV0IChhLCBpKSkgPSBVbml4LkFERFJfSU5FVCAoYSwgaSlcbiAgICBlbmRcblxuICAgIG1vZHVsZSBVbml4ID0gc3RydWN0XG4gICAgICB0eXBlIHQgPSBbIGBVbml4IG9mIHN0cmluZyBdIFtAQGRlcml2aW5nIGJpbl9pbywgY29tcGFyZSwgaGFzaCwgc2V4cF1cblxuICAgICAgbGV0IGNyZWF0ZSBzID0gYFVuaXggc1xuICAgICAgbGV0IHRvX3N0cmluZyAoYFVuaXggcykgPSBzXG5cbiAgICAgIGxldCBvZl9zb2NrYWRkcl9leG4gOiBVbml4LnNvY2thZGRyIC0+IHQgPSBmdW5jdGlvblxuICAgICAgICB8IEFERFJfVU5JWCBzIC0+IGBVbml4IHNcbiAgICAgICAgfCB1IC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiU29ja2V0LkFkZHJlc3MudW5peFwiIH5fOih1IDogVW5peC5zb2NrYWRkcildXG4gICAgICA7O1xuXG4gICAgICBsZXQgdG9fc29ja2FkZHIgKGBVbml4IHMpID0gVW5peC5BRERSX1VOSVggc1xuICAgIGVuZFxuXG4gICAgdHlwZSB0ID1cbiAgICAgIFsgSW5ldC50XG4gICAgICB8IFVuaXgudFxuICAgICAgXVxuICAgIFtAQGRlcml2aW5nIGJpbl9pbywgc2V4cF9vZl1cblxuICAgIG1vZHVsZSBCbG9ja2luZ19zZXhwID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICBbIEluZXQuQmxvY2tpbmdfc2V4cC50XG4gICAgICAgIHwgVW5peC50XG4gICAgICAgIF1cbiAgICAgIFtAQGRlcml2aW5nIGJpbl9pbywgaGFzaCwgc2V4cF1cbiAgICBlbmRcblxuICAgIGxldCB0b19zb2NrYWRkciA9IGZ1bmN0aW9uXG4gICAgICB8ICNJbmV0LnQgYXMgdCAtPiBJbmV0LnRvX3NvY2thZGRyIHRcbiAgICAgIHwgI1VuaXgudCBhcyB0IC0+IFVuaXgudG9fc29ja2FkZHIgdFxuICAgIDs7XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgICAgIHwgYEluZXQgXyBhcyB0IC0+IHQgfD4gSW5ldC50b19zdHJpbmdcbiAgICAgIHwgYFVuaXggXyBhcyB0IC0+IHQgfD4gVW5peC50b19zdHJpbmdcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmFtaWx5ID0gc3RydWN0XG4gICAgbW9kdWxlIEdhZHQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgXyB0ID1cbiAgICAgICAgfCBJbmV0IDogQWRkcmVzcy5JbmV0LnQgdFxuICAgICAgICB8IFVuaXggOiBBZGRyZXNzLlVuaXgudCB0XG5cbiAgICAgIGxldCBpc19pbmV0X3dpdG5lc3MgOiB0eXBlIGEuIGEgdCAtPiAoYSwgQWRkcmVzcy5JbmV0LnQpIFR5cGVfZXF1YWwudCBvcHRpb25cbiAgICAgICAgPSBmdW5jdGlvblxuICAgICAgICB8IEluZXQgLT4gU29tZSBUXG4gICAgICAgIHwgVW5peCAtPiBOb25lXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgdHlwZSAnYWRkcmVzcyB0ID1cbiAgICAgIHsgZmFtaWx5IDogVW5peC5zb2NrZXRfZG9tYWluXG4gICAgICA7IGZhbWlseV9nYWR0IDogJ2FkZHJlc3MgR2FkdC50XG4gICAgICA7IGFkZHJlc3Nfb2Zfc29ja2FkZHJfZXhuIDogVW5peC5zb2NrYWRkciAtPiAnYWRkcmVzc1xuICAgICAgOyBzZXhwX29mX2FkZHJlc3MgOiAnYWRkcmVzcyAtPiBTZXhwLnRcbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnQgJ2FkZHJlc3MgPSBbPCBBZGRyZXNzLnQgXVxuICAgIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVyc11cblxuICAgIGxldCBzZXhwX29mX3RcbiAgICAgIF9cbiAgICAgIHsgYWRkcmVzc19vZl9zb2NrYWRkcl9leG4gPSBfOyBmYW1pbHk7IGZhbWlseV9nYWR0ID0gXzsgc2V4cF9vZl9hZGRyZXNzID0gXyB9XG4gICAgICA9XG4gICAgICBbJXNleHAgKGZhbWlseSA6IFVuaXguc29ja2V0X2RvbWFpbildXG4gICAgOztcblxuICAgIGxldCB0b19zdHJpbmcgdCA9XG4gICAgICBtYXRjaCB0LmZhbWlseSB3aXRoXG4gICAgICB8IFBGX0lORVQgLT4gXCJpbmV0XCJcbiAgICAgIHwgUEZfSU5FVDYgLT4gXCJpbmV0NlwiXG4gICAgICB8IFBGX1VOSVggLT4gXCJ1bml4XCJcbiAgICA7O1xuXG4gICAgbGV0IGluZXQgPVxuICAgICAgeyBmYW1pbHkgPSBQRl9JTkVUXG4gICAgICA7IGZhbWlseV9nYWR0ID0gSW5ldFxuICAgICAgOyBhZGRyZXNzX29mX3NvY2thZGRyX2V4biA9IEFkZHJlc3MuSW5ldC5vZl9zb2NrYWRkcl9leG5cbiAgICAgIDsgc2V4cF9vZl9hZGRyZXNzID0gQWRkcmVzcy5JbmV0LnNleHBfb2ZfdFxuICAgICAgfVxuICAgIDs7XG5cbiAgICBsZXQgdW5peCA9XG4gICAgICB7IGZhbWlseSA9IFBGX1VOSVhcbiAgICAgIDsgZmFtaWx5X2dhZHQgPSBVbml4XG4gICAgICA7IGFkZHJlc3Nfb2Zfc29ja2FkZHJfZXhuID0gQWRkcmVzcy5Vbml4Lm9mX3NvY2thZGRyX2V4blxuICAgICAgOyBzZXhwX29mX2FkZHJlc3MgPSBBZGRyZXNzLlVuaXguc2V4cF9vZl90XG4gICAgICB9XG4gICAgOztcblxuICAgIGxldCBpc19pbmV0X3dpdG5lc3MgdCA9IEdhZHQuaXNfaW5ldF93aXRuZXNzIHQuZmFtaWx5X2dhZHRcbiAgZW5kXG5cbiAgbW9kdWxlIFR5cGUgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBmYW1pbHkgOiAnYSBGYW1pbHkudFxuICAgICAgOyBzb2NrZXRfdHlwZSA6IFVuaXguc29ja2V0X3R5cGVcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgbGV0IGZhbWlseSB0ID0gdC5mYW1pbHlcbiAgICBsZXQgc2V4cF9vZl9hZGRyZXNzIHQgPSB0LmZhbWlseS5zZXhwX29mX2FkZHJlc3NcbiAgICBsZXQgdGNwID0geyBmYW1pbHkgPSBGYW1pbHkuaW5ldDsgc29ja2V0X3R5cGUgPSBTT0NLX1NUUkVBTSB9XG4gICAgbGV0IHVkcCA9IHsgZmFtaWx5ID0gRmFtaWx5LmluZXQ7IHNvY2tldF90eXBlID0gU09DS19ER1JBTSB9XG4gICAgbGV0IHVuaXggPSB7IGZhbWlseSA9IEZhbWlseS51bml4OyBzb2NrZXRfdHlwZSA9IFNPQ0tfU1RSRUFNIH1cbiAgICBsZXQgdW5peF9kZ3JhbSA9IHsgZmFtaWx5ID0gRmFtaWx5LnVuaXg7IHNvY2tldF90eXBlID0gU09DS19ER1JBTSB9XG4gICAgbGV0IHBoeXNfc2FtZSAodDEgOiBfIHQpICh0MiA6IF8gdCkgPSBwaHlzX3NhbWUgdDEgdDJcbiAgZW5kXG5cbiAgbW9kdWxlIEZvcl9pbmZvID0gc3RydWN0XG4gICAgdHlwZSAnYWRkciB0ID1cbiAgICAgIHsgbXV0YWJsZSBjb25uZWN0ZWRfdG8gOiAnYWRkciBvcHRpb25cbiAgICAgIDsgbXV0YWJsZSBib3VuZF9vbiA6ICdhZGRyIG9wdGlvblxuICAgICAgOyBtdXRhYmxlIGxpc3RlbmluZyA6IGJvb2xcbiAgICAgIDsgdHlwZV8gOiAnYWRkciBUeXBlLnRcbiAgICAgIH1cblxuICAgIGxldCBjcmVhdGUgdHlwZV8gPSB7IGNvbm5lY3RlZF90byA9IE5vbmU7IGJvdW5kX29uID0gTm9uZTsgbGlzdGVuaW5nID0gZmFsc2U7IHR5cGVfIH1cblxuICAgIGxldCBpbmZvIHsgY29ubmVjdGVkX3RvOyBib3VuZF9vbjsgbGlzdGVuaW5nOyB0eXBlXyB9ID1cbiAgICAgIGxldCB0eXBlXyA9XG4gICAgICAgIGlmIFR5cGUucGh5c19zYW1lIHR5cGVfIFR5cGUudGNwXG4gICAgICAgIHRoZW4gWyVzZXhwIFwidGNwXCJdXG4gICAgICAgIGVsc2UgaWYgVHlwZS5waHlzX3NhbWUgdHlwZV8gVHlwZS51ZHBcbiAgICAgICAgdGhlbiBbJXNleHAgXCJ1ZHBcIl1cbiAgICAgICAgZWxzZSBbJXNleHAgKHR5cGVfIDogXyBUeXBlLnQpXVxuICAgICAgaW5cbiAgICAgIGxldCBib3VuZF9vbiwgbGlzdGVuaW5nX29uID0gaWYgbGlzdGVuaW5nIHRoZW4gTm9uZSwgYm91bmRfb24gZWxzZSBib3VuZF9vbiwgTm9uZSBpblxuICAgICAgSW5mby5jcmVhdGVfc1xuICAgICAgICBbJXNleHBcbiAgICAgICAgICB7IGNvbm5lY3RlZF90byA6IChbPCBBZGRyZXNzLnQgXSBvcHRpb25bQHNleHAub3B0aW9uXSlcbiAgICAgICAgICA7IHR5cGVfIDogU2V4cC50XG4gICAgICAgICAgOyBib3VuZF9vbiA6IChbPCBBZGRyZXNzLnQgXSBvcHRpb25bQHNleHAub3B0aW9uXSlcbiAgICAgICAgICA7IGxpc3RlbmluZ19vbiA6IChbPCBBZGRyZXNzLnQgXSBvcHRpb25bQHNleHAub3B0aW9uXSlcbiAgICAgICAgICB9XVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgJ2FkZHIgdF8gPVxuICAgIHsgdHlwZV8gOiAnYWRkciBUeXBlLnRcbiAgICA7IGZkIDogRmQudFxuICAgIDsgZm9yX2luZm8gOiAnYWRkciBGb3JfaW5mby50IG9wdGlvblxuICAgIH1cblxuICB0eXBlICgrJ3N0YXRlLCAnYWRkcikgdCA9ICdhZGRyIHRfXG4gICAgY29uc3RyYWludCAnc3RhdGUgPSBbPCBgVW5jb25uZWN0ZWQgfCBgQm91bmQgfCBgUGFzc2l2ZSB8IGBBY3RpdmUgXVxuXG4gIGxldCBzZXhwX29mX3QgXyBfIHQgPSBGZC5zZXhwX29mX3QgdC5mZFxuICBsZXQgZmQgdCA9IHQuZmRcbiAgbGV0IG9mX2ZkIGZkIHR5cGVfID0geyB0eXBlXzsgZmQ7IGZvcl9pbmZvID0gTm9uZSB9XG4gIGxldCBzZXhwX29mX2FkZHJlc3MgdCA9IFR5cGUuc2V4cF9vZl9hZGRyZXNzIHQudHlwZV9cblxuICBsZXQgY3JlYXRlICh0eXBlXyA6IF8gVHlwZS50KSA9XG4gICAgbGV0IGZpbGVfZGVzY3IgPVxuICAgICAgVW5peC5zb2NrZXRcbiAgICAgICAgfmRvbWFpbjp0eXBlXy5mYW1pbHkuZmFtaWx5XG4gICAgICAgIH5raW5kOnR5cGVfLnNvY2tldF90eXBlXG4gICAgICAgIH5wcm90b2NvbDowXG4gICAgICAgIH5jbG9zZV9vbl9leGVjOnRydWVcbiAgICAgICAgKClcbiAgICBpblxuICAgIGxldCBmZCA9XG4gICAgICBGZC5jcmVhdGVcbiAgICAgICAgKFNvY2tldCBgVW5jb25uZWN0ZWQpXG4gICAgICAgIGZpbGVfZGVzY3JcbiAgICAgICAgKEluZm8uY3JlYXRlIFwic29ja2V0XCIgdHlwZV8gWyVzZXhwX29mOiBfIFR5cGUudF0pXG4gICAgaW5cbiAgICB7IHR5cGVfOyBmZDsgZm9yX2luZm8gPSBTb21lIChGb3JfaW5mby5jcmVhdGUgdHlwZV8pIH1cbiAgOztcblxuICBtb2R1bGUgT3B0ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbmFtZSA6IHN0cmluZ1xuICAgICAgOyBnZXQgOiBGaWxlX2Rlc2NyLnQgLT4gJ2FcbiAgICAgIDsgc2V0IDogRmlsZV9kZXNjci50IC0+ICdhIC0+IHVuaXRcbiAgICAgIH1cblxuICAgIGxldCB0b19zdHJpbmcgdCA9IHQubmFtZVxuXG4gICAgbGV0IG1ha2UgZ2V0c29ja29wdCBzZXRzb2Nrb3B0IG5hbWUgb3B0ID1cbiAgICAgIHsgbmFtZVxuICAgICAgOyBnZXQgPSAoZnVuIGZkIC0+IGdldHNvY2tvcHQgZmQgb3B0KVxuICAgICAgOyBzZXQgPSAoZnVuIGZkIGEgLT4gc2V0c29ja29wdCBmZCBvcHQgYSlcbiAgICAgIH1cbiAgICA7O1xuXG4gICAgbGV0IGJvb2wgPSBtYWtlIFVuaXguZ2V0c29ja29wdCBVbml4LnNldHNvY2tvcHRcbiAgICBsZXQgaW50ID0gbWFrZSBVbml4LmdldHNvY2tvcHRfaW50IFVuaXguc2V0c29ja29wdF9pbnRcbiAgICBsZXQgb3B0aW50ID0gbWFrZSBVbml4LmdldHNvY2tvcHRfb3B0aW50IFVuaXguc2V0c29ja29wdF9vcHRpbnRcbiAgICBsZXQgZmxvYXQgPSBtYWtlIFVuaXguZ2V0c29ja29wdF9mbG9hdCBVbml4LnNldHNvY2tvcHRfZmxvYXRcbiAgICBsZXQgZGVidWcgPSBib29sIFwiZGVidWdcIiBTT19ERUJVR1xuICAgIGxldCBicm9hZGNhc3QgPSBib29sIFwiYnJvYWRjYXN0XCIgU09fQlJPQURDQVNUXG4gICAgbGV0IHJldXNlYWRkciA9IGJvb2wgXCJyZXVzZWFkZHJcIiBTT19SRVVTRUFERFJcbiAgICBsZXQgcmV1c2Vwb3J0ID0gYm9vbCBcInJldXNlcG9ydFwiIFNPX1JFVVNFUE9SVFxuICAgIGxldCBrZWVwYWxpdmUgPSBib29sIFwia2VlcGFsaXZlXCIgU09fS0VFUEFMSVZFXG4gICAgbGV0IGRvbnRyb3V0ZSA9IGJvb2wgXCJkb250cm91dGVcIiBTT19ET05UUk9VVEVcbiAgICBsZXQgb29iaW5saW5lID0gYm9vbCBcIm9vYmlubGluZVwiIFNPX09PQklOTElORVxuICAgIGxldCBhY2NlcHRjb25uID0gYm9vbCBcImFjY2VwdGNvbm5cIiBTT19BQ0NFUFRDT05OXG4gICAgbGV0IG5vZGVsYXkgPSBib29sIFwibm9kZWxheVwiIFRDUF9OT0RFTEFZXG4gICAgbGV0IHNuZGJ1ZiA9IGludCBcInNuZGJ1ZlwiIFNPX1NOREJVRlxuICAgIGxldCByY3ZidWYgPSBpbnQgXCJyY3ZidWZcIiBTT19SQ1ZCVUZcbiAgICBsZXQgZXJyb3IgPSBpbnQgXCJlcnJvclwiIChTT19FUlJPUiBbQGFsZXJ0IFwiLWRlcHJlY2F0ZWRcIl0pXG4gICAgbGV0IHR5cCA9IGludCBcInR5cFwiIFNPX1RZUEVcbiAgICBsZXQgcmN2bG93YXQgPSBpbnQgXCJyY3Zsb3dhdFwiIFNPX1JDVkxPV0FUXG4gICAgbGV0IHNuZGxvd2F0ID0gaW50IFwic25kbG93YXRcIiBTT19TTkRMT1dBVFxuICAgIGxldCBsaW5nZXIgPSBvcHRpbnQgXCJsaW5nZXJcIiBTT19MSU5HRVJcbiAgICBsZXQgcmN2dGltZW8gPSBmbG9hdCBcInJjdnRpbWVvXCIgU09fUkNWVElNRU9cbiAgICBsZXQgc25kdGltZW8gPSBmbG9hdCBcInNuZHRpbWVvXCIgU09fU05EVElNRU9cblxuICAgICgqIFNpbmNlIHRoZXJlIGFyZW4ndCBzb2NrZXQgb3B0aW9ucyBsaWtlIFNPX01DQVNUTE9PUCBvciBTT19NQ0FTVFRUTCwgd2Ugd3JhcFxuICAgICAgIFtDb3JlX3VuaXhdIGZ1bmN0aW9ucyB0byBtYXRjaCBhc3luYydzIHNvY2tldC1vcHRpb25zIGludGVyZmFjZS4gKilcbiAgICBsZXQgbWNhc3RfbG9vcCA9XG4gICAgICB7IG5hbWUgPSBcIm1jYXN0X2xvb3BcIjsgZ2V0ID0gVW5peC5nZXRfbWNhc3RfbG9vcDsgc2V0ID0gVW5peC5zZXRfbWNhc3RfbG9vcCB9XG4gICAgOztcblxuICAgIGxldCBtY2FzdF90dGwgPVxuICAgICAgeyBuYW1lID0gXCJtY2FzdF90dGxcIjsgZ2V0ID0gVW5peC5nZXRfbWNhc3RfdHRsOyBzZXQgPSBVbml4LnNldF9tY2FzdF90dGwgfVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBnZXRvcHQgdCAob3B0IDogXyBPcHQudCkgPSBGZC53aXRoX2ZpbGVfZGVzY3JfZXhuIHQuZmQgb3B0LmdldFxuXG4gIGxldCBzZXRvcHQgdCAob3B0IDogXyBPcHQudCkgYSA9XG4gICAgRmQud2l0aF9maWxlX2Rlc2NyX2V4biB0LmZkIChmdW4gZmlsZV9kZXNjciAtPiBvcHQuc2V0IGZpbGVfZGVzY3IgYSlcbiAgOztcblxuICBsZXQgbWNhc3Rfam9pbiA/aWZuYW1lID9zb3VyY2UgdCBhZGRyZXNzID1cbiAgICBGZC53aXRoX2ZpbGVfZGVzY3JfZXhuIHQuZmQgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgICBVbml4Lm1jYXN0X2pvaW4gP2lmbmFtZSA/c291cmNlIGZpbGVfZGVzY3IgKEFkZHJlc3MudG9fc29ja2FkZHIgYWRkcmVzcykpXG4gIDs7XG5cbiAgbGV0IG1jYXN0X2xlYXZlID9pZm5hbWUgP3NvdXJjZSB0IGFkZHJlc3MgPVxuICAgIEZkLndpdGhfZmlsZV9kZXNjcl9leG4gdC5mZCAoZnVuIGZpbGVfZGVzY3IgLT5cbiAgICAgIFVuaXgubWNhc3RfbGVhdmUgP2lmbmFtZSA/c291cmNlIGZpbGVfZGVzY3IgKEFkZHJlc3MudG9fc29ja2FkZHIgYWRkcmVzcykpXG4gIDs7XG5cbiAgbGV0IG1hcmtfYm91bmQgdCBhZGRyZXNzID1cbiAgICBsZXQgaW5mbyA9XG4gICAgICBtYXRjaCB0LmZvcl9pbmZvIHdpdGhcbiAgICAgIHwgU29tZSBpIC0+XG4gICAgICAgIGkuYm91bmRfb24gPC0gU29tZSBhZGRyZXNzO1xuICAgICAgICBgU2V0IChGb3JfaW5mby5pbmZvIGkpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgYEV4dGVuZFxuICAgICAgICAgIChJbmZvLmNyZWF0ZVxuICAgICAgICAgICAgIFwic29ja2V0XCJcbiAgICAgICAgICAgICAoYGJvdW5kX29uIGFkZHJlc3MpXG4gICAgICAgICAgICAgKGxldCBzZXhwX29mX2FkZHJlc3MgPSBzZXhwX29mX2FkZHJlc3MgdCBpblxuICAgICAgICAgICAgICBbJXNleHBfb2Y6IFsgYGJvdW5kX29uIG9mIGFkZHJlc3MgXV0pKVxuICAgIGluXG4gICAgRmQuUHJpdmF0ZS5yZXBsYWNlIHQuZmQgKFNvY2tldCBgQm91bmQpIGluZm9cbiAgOztcblxuICBsZXQgYmluZF9rZWVwX29wdHMgdCBhZGRyZXNzID1cbiAgICBsZXQgc29ja2FkZHIgPSBBZGRyZXNzLnRvX3NvY2thZGRyIGFkZHJlc3MgaW5cbiAgICBsZXQlbWFwICgpID1cbiAgICAgIEZkLnN5c2NhbGxfaW5fdGhyZWFkX2V4biB0LmZkIH5uYW1lOlwiYmluZFwiIChmdW4gZmlsZV9kZXNjciAtPlxuICAgICAgICBVbml4LmJpbmQgZmlsZV9kZXNjciB+YWRkcjpzb2NrYWRkcilcbiAgICBpblxuICAgIG1hcmtfYm91bmQgdCBhZGRyZXNzO1xuICAgIHRcbiAgOztcblxuICBsZXQgYmluZCA/KHJldXNlYWRkciA9IHRydWUpIHQgYWRkcmVzcyA9XG4gICAgc2V0b3B0IHQgT3B0LnJldXNlYWRkciByZXVzZWFkZHI7XG4gICAgc2V0X2Nsb3NlX29uX2V4ZWMgdC5mZDtcbiAgICBiaW5kX2tlZXBfb3B0cyB0IGFkZHJlc3NcbiAgOztcblxuICBsZXQgYmluZF9pbmV0X2tlZXBfb3B0cyB0IGFkZHJlc3MgPVxuICAgIGxldCBzb2NrYWRkciA9IEFkZHJlc3MudG9fc29ja2FkZHIgYWRkcmVzcyBpblxuICAgIEZkLnN5c2NhbGxfZXhuIHQuZmQgKGZ1biBmaWxlX2Rlc2NyIC0+IFVuaXguYmluZCBmaWxlX2Rlc2NyIH5hZGRyOnNvY2thZGRyKTtcbiAgICBtYXJrX2JvdW5kIHQgYWRkcmVzcztcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGJpbmRfaW5ldCA/KHJldXNlYWRkciA9IHRydWUpIHQgYWRkcmVzcyA9XG4gICAgc2V0b3B0IHQgT3B0LnJldXNlYWRkciByZXVzZWFkZHI7XG4gICAgc2V0X2Nsb3NlX29uX2V4ZWMgdC5mZDtcbiAgICBiaW5kX2luZXRfa2VlcF9vcHRzIHQgYWRkcmVzc1xuICA7O1xuXG4gIGxldCBsaXN0ZW4gPyhiYWNrbG9nID0gNjQpIHQgPVxuICAgIGxldCBmZCA9IHQuZmQgaW5cbiAgICBGZC5zeXNjYWxsX2V4biBmZCAoZnVuIGZpbGVfZGVzY3IgLT4gVW5peC5saXN0ZW4gZmlsZV9kZXNjciB+YmFja2xvZyk7XG4gICAgbGV0IGluZm8gPVxuICAgICAgbWF0Y2ggdC5mb3JfaW5mbyB3aXRoXG4gICAgICB8IFNvbWUgaSAtPlxuICAgICAgICBpLmxpc3RlbmluZyA8LSB0cnVlO1xuICAgICAgICBgU2V0IChGb3JfaW5mby5pbmZvIGkpXG4gICAgICB8IE5vbmUgLT4gYEV4dGVuZCAoSW5mby5vZl9zdHJpbmcgXCJsaXN0ZW5pbmdcIilcbiAgICBpblxuICAgIEZkLlByaXZhdGUucmVwbGFjZSBmZCAoU29ja2V0IGBQYXNzaXZlKSBpbmZvO1xuICAgIHRcbiAgOztcblxuICBsZXQgdHVybl9vZmZfbmFnbGUgKGFkZHIgOiBVbml4LnNvY2thZGRyKSB0ID1cbiAgICBtYXRjaCBhZGRyLCB0LnR5cGVfLnNvY2tldF90eXBlIHdpdGhcbiAgICB8IEFERFJfSU5FVCBfLCBTT0NLX1NUUkVBTSAtPiBzZXRvcHQgdCBPcHQubm9kZWxheSB0cnVlXG4gICAgfCAoQUREUl9VTklYIF8gfCBBRERSX0lORVQgXyksIF8gLT4gKClcbiAgOztcblxuICBsZXQgYWNjZXB0X25vbmJsb2NraW5nIHQgPVxuICAgICgqIFdlIGNhbGwgW2FjY2VwdF0gd2l0aCBbfm5vbmJsb2NraW5nOnRydWVdIGJlY2F1c2UgdGhlcmUgaXMgbm8gd2F5IHRvIHVzZVxuICAgICAgIFtzZWxlY3RdIHRvIGd1YXJhbnRlZSB0aGF0IGFuIFthY2NlcHRdIHdpbGwgbm90IGJsb2NrIChzZWUgU3RldmVucycgYm9vayBvblxuICAgICAgIFVuaXggTmV0d29yayBQcm9ncmFtbWluZywgcDQyMikuICopXG4gICAgbWF0Y2hcbiAgICAgIEZkLndpdGhfZmlsZV9kZXNjciB0LmZkIH5ub25ibG9ja2luZzp0cnVlIChmdW4gZmlsZV9kZXNjciAtPlxuICAgICAgICBVbml4LmFjY2VwdCBmaWxlX2Rlc2NyIH5jbG9zZV9vbl9leGVjOnRydWUpXG4gICAgd2l0aFxuICAgIHwgYEFscmVhZHlfY2xvc2VkIC0+IGBTb2NrZXRfY2xvc2VkXG4gICAgfCBgT2sgKGZpbGVfZGVzY3IsIHNvY2thZGRyKSAtPlxuICAgICAgbGV0IGFkZHJlc3MgPSBGYW1pbHkuYWRkcmVzc19vZl9zb2NrYWRkcl9leG4gdC50eXBlXy5mYW1pbHkgc29ja2FkZHIgaW5cbiAgICAgIGxldCBmZCA9XG4gICAgICAgIEZkLmNyZWF0ZVxuICAgICAgICAgIChGZC5LaW5kLlNvY2tldCBgQWN0aXZlKVxuICAgICAgICAgIGZpbGVfZGVzY3JcbiAgICAgICAgICAoSW5mby5jcmVhdGVcbiAgICAgICAgICAgICBcInNvY2tldFwiXG4gICAgICAgICAgICAgKGBsaXN0ZW5pbmdfb24gKEZkLmluZm8gdC5mZCksIGBjbGllbnQgYWRkcmVzcylcbiAgICAgICAgICAgICAobGV0IHNleHBfb2ZfYWRkcmVzcyA9IHNleHBfb2ZfYWRkcmVzcyB0IGluXG4gICAgICAgICAgICAgIFslc2V4cF9vZjogWyBgbGlzdGVuaW5nX29uIG9mIEluZm8udCBdICogWyBgY2xpZW50IG9mIGFkZHJlc3MgXV0pKVxuICAgICAgaW5cbiAgICAgIGxldCBzID0geyBmZDsgdHlwZV8gPSB0LnR5cGVfOyBmb3JfaW5mbyA9IE5vbmUgfSBpblxuICAgICAgdHVybl9vZmZfbmFnbGUgc29ja2FkZHIgcztcbiAgICAgIGBPayAocywgYWRkcmVzcylcbiAgICB8IGBFcnJvciAoVW5peF9lcnJvciAoKEVBR0FJTiB8IEVXT1VMREJMT0NLIHwgRUNPTk5BQk9SVEVEIHwgRUlOVFIpLCBfLCBfKSkgLT5cbiAgICAgICgqIElmIFthY2NlcHRdIHdvdWxkIGhhdmUgYmxvY2tlZCAoRUFHQUlOfEVXT1VMREJMT0NLKSBvciBnb3QgaW50ZXJydXB0ZWRcbiAgICAgICAgIChFSU5UUiksIHRoZW4gd2UgcmV0dXJuIFtgV291bGRfYmxvY2tdLlxuXG4gICAgICAgICBJZiB0aGUga2VybmVsIHJldHVybnMgRUNPTk5BQk9SVEVELCB0aGlzIG1lYW5zIHRoYXQgd2UgZmlyc3QgZ290IGEgY29ubmVjdGlvblxuICAgICAgICAgYW5kIHRoZXJlZm9yZSB3b2tlIHVwIGluIFwic2VsZWN0XCIgKHJlYWR5IHRvIHJlYWQpLiAgQnV0IGR1ZSB0byBzbG93bmVzc1xuICAgICAgICAgKGUuZy4gb3RoZXIgbG9uZyBhc3luYyBqb2JzIGdldHRpbmcgdG8gcnVuIGZpcnN0KSB3ZSBjb3VsZCBub3QgY2FsbCBhY2NlcHRcbiAgICAgICAgIHF1aWNrbHkgZW5vdWdoLCBhbmQgdGhlIG90aGVyIHNpZGUgdGVybWluYXRlZCB0aGUgY29ubmVjdGlvbiBpbiB0aGUgbWVhbndoaWxlLlxuICAgICAgICAgVGhvdWdoIG9uZSBjb3VsZCBpbWFnaW5lIHdlaXJkIGNsaWVudC9zZXJ2ZXIgYXBwbGljYXRpb25zIHRoYXQgYWJzb2x1dGVseSBuZWVkXG4gICAgICAgICB0byBrbm93IHRoYXQgc29tZSBjbGllbnQgYWJvcnRlZCB0aGUgY29ubmVjdGlvbiBiZWZvcmUgd2UgY291bGQgYWNjZXB0IGl0LCB0aGlzXG4gICAgICAgICBzZWVtcyBxdWl0ZSBjb250cml2ZWQgYW5kIHVubGlrZWx5LiAgSW4gdmlydHVhbGx5IGFsbCBjYXNlcyBwZW9wbGUganVzdCB3YW50IHRvXG4gICAgICAgICBjb250aW51ZSB3YWl0aW5nIGZvciBhIG5ldyBjb25uZWN0aW9uLlxuXG4gICAgICAgICBbU3lzX2Jsb2NrZWRfaW9dIGNhbm5vdCBiZSByYWlzZWQgaGVyZS4gIFRoaXMgaXMgYSBVbml4LWZ1bmN0aW9uLCBub3QgYVxuICAgICAgICAgc3RhbmRhcmQgT0NhbWwgSS9PLWZ1bmN0aW9uIChlLmcuIGZvciByZWFkaW5nIGZyb20gY2hhbm5lbHMpLiAgKilcbiAgICAgIGBXb3VsZF9ibG9ja1xuICAgIHwgYEVycm9yIGV4biAtPiByYWlzZSBleG5cbiAgOztcblxuICBsZXQgYWNjZXB0X2ludGVycnVwdGlibGUgdCB+aW50ZXJydXB0ID1cbiAgICBEZWZlcnJlZC5yZXBlYXRfdW50aWxfZmluaXNoZWQgKCkgKGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggYWNjZXB0X25vbmJsb2NraW5nIHQgd2l0aFxuICAgICAgfCAoYFNvY2tldF9jbG9zZWQgfCBgT2sgXykgYXMgeCAtPiByZXR1cm4gKGBGaW5pc2hlZCB4KVxuICAgICAgfCBgV291bGRfYmxvY2sgLT5cbiAgICAgICAgKG1hdGNoJW1hcCBGZC5pbnRlcnJ1cHRpYmxlX3JlYWR5X3RvIHQuZmQgYFJlYWQgfmludGVycnVwdCB3aXRoXG4gICAgICAgICB8IGBSZWFkeSAtPiBgUmVwZWF0ICgpXG4gICAgICAgICB8IGBJbnRlcnJ1cHRlZCBhcyB4IC0+IGBGaW5pc2hlZCB4XG4gICAgICAgICB8IGBDbG9zZWQgLT4gYEZpbmlzaGVkIGBTb2NrZXRfY2xvc2VkXG4gICAgICAgICB8IGBCYWRfZmQgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJhY2NlcHQgb24gYmFkIGZpbGUgZGVzY3JpcHRvclwiIH5fOih0LmZkIDogRmQudCldKSlcbiAgOztcblxuICBsZXQgYWNjZXB0IHQgPVxuICAgIG1hdGNoJW1hcCBhY2NlcHRfaW50ZXJydXB0aWJsZSB0IH5pbnRlcnJ1cHQ6KEZkLmNsb3NlX3N0YXJ0ZWQgdC5mZCkgd2l0aFxuICAgIHwgYEludGVycnVwdGVkIC0+IGBTb2NrZXRfY2xvc2VkXG4gICAgfCAoYFNvY2tldF9jbG9zZWQgfCBgT2sgXykgYXMgeCAtPiB4XG4gIDs7XG5cbiAgbGV0IGFjY2VwdF9hdF9tb3N0X2ludGVycnVwdGlibGUgdCB+bGltaXQgfmludGVycnVwdCA9XG4gICAgaWYgbGltaXQgPCAxXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJbU29ja2V0LmFjY2VwdF9hdF9tb3N0X2ludGVycnVwdGlibGVdIGdvdCBbbGltaXRdIDwgMVwiIChsaW1pdCA6IGludCldO1xuICAgIG1hdGNoJW1hcCBhY2NlcHRfaW50ZXJydXB0aWJsZSB0IH5pbnRlcnJ1cHQgd2l0aFxuICAgIHwgKGBTb2NrZXRfY2xvc2VkIHwgYEludGVycnVwdGVkKSBhcyB4IC0+IHhcbiAgICB8IGBPayBjb25uZWN0aW9uIC0+XG4gICAgICAoKiBOb3cgdGhhdCB3ZSBoYXZlIGEgY29ubmVjdGlvbiwgYWNjZXB0IHdpdGhvdXQgYmxvY2tpbmcgYXMgbWFueSBvdGhlciBjb25uZWN0aW9uc1xuICAgICAgICAgYXMgd2UgY2FuLCB1cCB0byBbbGltaXRdIHRvdGFsIGNvbm5lY3Rpb25zLiAqKVxuICAgICAgbGV0IHJlYyBsb29wIGxpbWl0IGNvbm5lY3Rpb25zID1cbiAgICAgICAgaWYgbGltaXQgPSAwXG4gICAgICAgIHRoZW4gY29ubmVjdGlvbnNcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggYWNjZXB0X25vbmJsb2NraW5nIHQgd2l0aFxuICAgICAgICAgIHwgYE9rIGNvbm5lY3Rpb24gLT4gbG9vcCAobGltaXQgLSAxKSAoY29ubmVjdGlvbiA6OiBjb25uZWN0aW9ucylcbiAgICAgICAgICB8IGBTb2NrZXRfY2xvc2VkIHwgYFdvdWxkX2Jsb2NrIC0+IGNvbm5lY3Rpb25zXG4gICAgICAgICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICAgICAgICBkb24ndF93YWl0X2ZvclxuICAgICAgICAgICAgICAoRGVmZXJyZWQuTGlzdC5pdGVyIH5ob3c6YFNlcXVlbnRpYWwgY29ubmVjdGlvbnMgfmY6KGZ1biAoY29ubiwgXykgLT5cbiAgICAgICAgICAgICAgICAgRmQuY2xvc2UgY29ubi5mZCkpO1xuICAgICAgICAgICAgcmFpc2UgZXhuKVxuICAgICAgaW5cbiAgICAgIGBPayAoTGlzdC5yZXYgKGxvb3AgKGxpbWl0IC0gMSkgWyBjb25uZWN0aW9uIF0pKVxuICA7O1xuXG4gIGxldCBhY2NlcHRfYXRfbW9zdCB0IH5saW1pdCA9XG4gICAgbWF0Y2glbWFwXG4gICAgICBhY2NlcHRfYXRfbW9zdF9pbnRlcnJ1cHRpYmxlIHQgfmxpbWl0IH5pbnRlcnJ1cHQ6KEZkLmNsb3NlX3N0YXJ0ZWQgdC5mZClcbiAgICB3aXRoXG4gICAgfCBgSW50ZXJydXB0ZWQgLT4gYFNvY2tldF9jbG9zZWRcbiAgICB8IChgU29ja2V0X2Nsb3NlZCB8IGBPayBfKSBhcyB4IC0+IHhcbiAgOztcblxuICBsZXQgY29ubmVjdF9pbnRlcnJ1cHRpYmxlIHQgYWRkcmVzcyB+aW50ZXJydXB0ID1cbiAgICBsZXQgc29ja2FkZHIgPSBBZGRyZXNzLnRvX3NvY2thZGRyIGFkZHJlc3MgaW5cbiAgICB0dXJuX29mZl9uYWdsZSBzb2NrYWRkciB0O1xuICAgIGxldCBzdWNjZXNzICgpID1cbiAgICAgIGxldCBpbmZvID1cbiAgICAgICAgbWF0Y2ggdC5mb3JfaW5mbyB3aXRoXG4gICAgICAgIHwgU29tZSBpIC0+XG4gICAgICAgICAgaS5jb25uZWN0ZWRfdG8gPC0gU29tZSBhZGRyZXNzO1xuICAgICAgICAgIGBTZXQgKEZvcl9pbmZvLmluZm8gaSlcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgbGV0IHNleHBfb2ZfYWRkcmVzcyA9IHNleHBfb2ZfYWRkcmVzcyB0IGluXG4gICAgICAgICAgYEV4dGVuZCAoSW5mby5jcmVhdGUgXCJjb25uZWN0ZWQgdG9cIiBhZGRyZXNzIFslc2V4cF9vZjogYWRkcmVzc10pXG4gICAgICBpblxuICAgICAgRmQuUHJpdmF0ZS5yZXBsYWNlIHQuZmQgKEZkLktpbmQuU29ja2V0IGBBY3RpdmUpIGluZm87XG4gICAgICBgT2sgdFxuICAgIGluXG4gICAgKCogV2UgY2FsbCBbY29ubmVjdF0gd2l0aCBbfm5vbmJsb2NraW5nOnRydWVdIHRvIGluaXRpYXRlIGFuIGFzeW5jaHJvbm91cyBjb25uZWN0IChzZWVcbiAgICAgICBTdGV2ZW5zJyBib29rIG9uIFVuaXggTmV0d29yayBQcm9ncmFtbWluZywgcDQxMykuICBPbmNlIHRoZSBjb25uZWN0IHN1Y2NlZWRzIG9yXG4gICAgICAgZmFpbHMsIFtzZWxlY3RdIG9uIHRoZSBzb2NrZXQgd2lsbCByZXR1cm4gaXQgaW4gdGhlIHdyaXRlYWJsZSBzZXQuICopXG4gICAgbWF0Y2hcbiAgICAgIEZkLndpdGhfZmlsZV9kZXNjciB0LmZkIH5ub25ibG9ja2luZzp0cnVlIChmdW4gZmlsZV9kZXNjciAtPlxuICAgICAgICBVbml4LmNvbm5lY3QgZmlsZV9kZXNjciB+YWRkcjpzb2NrYWRkcilcbiAgICB3aXRoXG4gICAgfCBgQWxyZWFkeV9jbG9zZWQgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJjbG9zZSBiZWZvcmUgY29ubmVjdFwiICh0LmZkIDogRmQudCldXG4gICAgfCBgT2sgKCkgLT4gcmV0dXJuIChzdWNjZXNzICgpKVxuICAgIHwgYEVycm9yIChVbml4X2Vycm9yICgoRUlOUFJPR1JFU1MgfCBFSU5UUiksIF8sIF8pKSAtPlxuICAgICAgKG1hdGNoJW1hcCBGZC5pbnRlcnJ1cHRpYmxlX3JlYWR5X3RvIHQuZmQgYFdyaXRlIH5pbnRlcnJ1cHQgd2l0aFxuICAgICAgIHwgYENsb3NlZCAtPiByYWlzZV9zIFslbWVzc2FnZSBcImNsb3NlIGR1cmluZyBjb25uZWN0XCIgKHQuZmQgOiBGZC50KV1cbiAgICAgICB8IGBCYWRfZmQgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJjb25uZWN0IG9uIGJhZCBmaWxlIGRlc2NyaXB0b3JcIiB+XzoodC5mZCA6IEZkLnQpXVxuICAgICAgIHwgYEludGVycnVwdGVkIGFzIHggLT4geFxuICAgICAgIHwgYFJlYWR5IC0+XG4gICAgICAgICAoKiBXZSBjYWxsIFtnZXRzb2Nrb3B0XSB0byBmaW5kIG91dCB3aGV0aGVyIHRoZSBjb25uZWN0IGhhcyBzdWNjZWVkIG9yIGZhaWxlZC4gKilcbiAgICAgICAgIChtYXRjaFxuICAgICAgICAgICAgRmQud2l0aF9maWxlX2Rlc2NyIHQuZmQgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgICAgICAgICAgIFVuaXguZ2V0c29ja29wdF9pbnQgZmlsZV9kZXNjciAoU09fRVJST1IgW0BhbGVydCBcIi1kZXByZWNhdGVkXCJdKSlcbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBgQWxyZWFkeV9jbG9zZWQgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJjbG9zZSBhZnRlciBjb25uZWN0XCIgKHQuZmQgOiBGZC50KV1cbiAgICAgICAgICB8IGBFcnJvciBleG4gLT4gcmFpc2UgZXhuXG4gICAgICAgICAgfCBgT2sgZXJyIC0+XG4gICAgICAgICAgICBpZiBlcnIgPSAwXG4gICAgICAgICAgICB0aGVuIHN1Y2Nlc3MgKClcbiAgICAgICAgICAgIGVsc2UgVW5peC51bml4X2Vycm9yIGVyciBcImNvbm5lY3RcIiAoQWRkcmVzcy50b19zdHJpbmcgYWRkcmVzcykpKVxuICAgIHwgYEVycm9yIGUgLT4gcmFpc2UgZVxuICA7O1xuXG4gIGxldCBjb25uZWN0IHQgYWRkciA9XG4gICAgbWF0Y2glbWFwIGNvbm5lY3RfaW50ZXJydXB0aWJsZSB0IGFkZHIgfmludGVycnVwdDooRGVmZXJyZWQubmV2ZXIgKCkpIHdpdGhcbiAgICB8IGBJbnRlcnJ1cHRlZCAtPiBhc3NlcnQgZmFsc2UgKCogaW1wb3NzaWJsZSAqKVxuICAgIHwgYE9rIHQgLT4gdFxuICA7O1xuXG4gIGxldCBzaHV0ZG93biB0IG1vZGUgPVxuICAgIGxldCBtb2RlIDogVW5peC5zaHV0ZG93bl9jb21tYW5kID1cbiAgICAgIG1hdGNoIG1vZGUgd2l0aFxuICAgICAgfCBgUmVjZWl2ZSAtPiBTSFVURE9XTl9SRUNFSVZFXG4gICAgICB8IGBTZW5kIC0+IFNIVVRET1dOX1NFTkRcbiAgICAgIHwgYEJvdGggLT4gU0hVVERPV05fQUxMXG4gICAgaW5cbiAgICBGZC5zeXNjYWxsX2V4biB0LmZkIChmdW4gZmlsZV9kZXNjciAtPiBVbml4LnNodXRkb3duIGZpbGVfZGVzY3Igfm1vZGUpXG4gIDs7XG5cbiAgbGV0IGdldHNvY2tuYW1lIHQgPVxuICAgIEZhbWlseS5hZGRyZXNzX29mX3NvY2thZGRyX2V4blxuICAgICAgdC50eXBlXy5mYW1pbHlcbiAgICAgIChVbml4LmdldHNvY2tuYW1lIChGZC5maWxlX2Rlc2NyX2V4biB0LmZkKSlcbiAgOztcblxuICBsZXQgZ2V0cGVlcm5hbWUgdCA9XG4gICAgRmFtaWx5LmFkZHJlc3Nfb2Zfc29ja2FkZHJfZXhuXG4gICAgICB0LnR5cGVfLmZhbWlseVxuICAgICAgKFVuaXguZ2V0cGVlcm5hbWUgKEZkLmZpbGVfZGVzY3JfZXhuIHQuZmQpKVxuICA7O1xuXG4gIGxldCBiaW5kX3RvX2ludGVyZmFjZV9leG4gPVxuICAgIE9yX2Vycm9yLm1hcCBiaW5kX3RvX2ludGVyZmFjZV9leG4gfmY6KGZ1biBmIHQgaWZuYW1lIC0+IGYgdC5mZCBpZm5hbWUpXG4gIDs7XG5lbmRcblxubGV0IHNvY2tldHBhaXIgKCkgPVxuICBsZXQgczEsIHMyID1cbiAgICBVbml4LnNvY2tldHBhaXIgfmRvbWFpbjpQRl9VTklYIH5raW5kOlNPQ0tfU1RSRUFNIH5wcm90b2NvbDowIH5jbG9zZV9vbl9leGVjOnRydWUgKClcbiAgaW5cbiAgbGV0IG1ha2VfZmQgcyA9IEZkLmNyZWF0ZSAoRmQuS2luZC5Tb2NrZXQgYEFjdGl2ZSkgcyAoSW5mby5vZl9zdHJpbmcgXCI8c29ja2V0cGFpcj5cIikgaW5cbiAgbWFrZV9mZCBzMSwgbWFrZV9mZCBzMlxuOztcblxubW9kdWxlIFByb3RvY29sX2ZhbWlseSA9IFVuaXguUHJvdG9jb2xfZmFtaWx5XG5cbm1vZHVsZSBIb3N0ID0gc3RydWN0XG4gIHR5cGUgdCA9IFVuaXguSG9zdC50ID1cbiAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICA7IGFsaWFzZXMgOiBzdHJpbmcgYXJyYXlcbiAgICA7IGZhbWlseSA6IFByb3RvY29sX2ZhbWlseS50XG4gICAgOyBhZGRyZXNzZXMgOiBJbmV0X2FkZHIudCBhcnJheVxuICAgIH1cblxuICBsZXQgZ2V0YnluYW1lIG4gPSBkbnNfbG9va3VwIH5uYW1lOlwiZ2V0aG9zdGJ5bmFtZVwiIChmdW4gKCkgLT4gVW5peC5Ib3N0LmdldGJ5bmFtZSBuKVxuXG4gIGxldCBnZXRieW5hbWVfZXhuIG4gPVxuICAgIGRuc19sb29rdXAgfm5hbWU6XCJnZXRob3N0YnluYW1lXCIgKGZ1biAoKSAtPiBVbml4Lkhvc3QuZ2V0YnluYW1lX2V4biBuKVxuICA7O1xuXG4gIGxldCBnZXRieWFkZHIgYSA9IGRuc19sb29rdXAgfm5hbWU6XCJnZXRob3N0YnlhZGRyXCIgKGZ1biAoKSAtPiBVbml4Lkhvc3QuZ2V0YnlhZGRyIGEpXG5cbiAgbGV0IGdldGJ5YWRkcl9leG4gYSA9XG4gICAgZG5zX2xvb2t1cCB+bmFtZTpcImdldGhvc3RieWFkZHJcIiAoZnVuICgpIC0+IFVuaXguSG9zdC5nZXRieWFkZHJfZXhuIGEpXG4gIDs7XG5cbiAgbGV0IGhhdmVfYWRkcmVzc19pbl9jb21tb24gPSBVbml4Lkhvc3QuaGF2ZV9hZGRyZXNzX2luX2NvbW1vblxuZW5kXG5cbnR5cGUgc29ja2V0X2RvbWFpbiA9IFVuaXguc29ja2V0X2RvbWFpbiA9XG4gIHwgUEZfVU5JWFxuICB8IFBGX0lORVRcbiAgfCBQRl9JTkVUNlxuW0BAZGVyaXZpbmcgYmluX2lvLCBjb21wYXJlLCBoYXNoLCBzZXhwXVxuXG50eXBlIHNvY2tldF90eXBlID0gVW5peC5zb2NrZXRfdHlwZSA9XG4gIHwgU09DS19TVFJFQU1cbiAgfCBTT0NLX0RHUkFNXG4gIHwgU09DS19SQVdcbiAgfCBTT0NLX1NFUVBBQ0tFVFxuW0BAZGVyaXZpbmcgYmluX2lvLCBjb21wYXJlLCBoYXNoLCBzZXhwXVxuXG50eXBlIHNvY2thZGRyID0gVW5peC5zb2NrYWRkciA9XG4gIHwgQUREUl9VTklYIG9mIHN0cmluZ1xuICB8IEFERFJfSU5FVCBvZiBJbmV0X2FkZHIudCAqIGludFxuW0BAZGVyaXZpbmcgYmluX2lvLCBjb21wYXJlLCBzZXhwX29mXVxuXG50eXBlIHNvY2thZGRyX2Jsb2NraW5nX3NleHAgPSBVbml4LnNvY2thZGRyID1cbiAgfCBBRERSX1VOSVggb2Ygc3RyaW5nXG4gIHwgQUREUl9JTkVUIG9mIEluZXRfYWRkci5CbG9ja2luZ19zZXhwLnQgKiBpbnRcbltAQGRlcml2aW5nIGJpbl9pbywgc2V4cF1cblxubW9kdWxlIEFkZHJfaW5mbyA9IHN0cnVjdFxuICB0eXBlIHQgPSBVbml4LmFkZHJfaW5mbyA9XG4gICAgeyBhaV9mYW1pbHkgOiBzb2NrZXRfZG9tYWluXG4gICAgOyBhaV9zb2NrdHlwZSA6IHNvY2tldF90eXBlXG4gICAgOyBhaV9wcm90b2NvbCA6IGludFxuICAgIDsgYWlfYWRkciA6IHNvY2thZGRyXG4gICAgOyBhaV9jYW5vbm5hbWUgOiBzdHJpbmdcbiAgICB9XG4gIFtAQGRlcml2aW5nIGJpbl9pbywgc2V4cF9vZl1cblxuICBtb2R1bGUgQmxvY2tpbmdfc2V4cCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFVuaXguYWRkcl9pbmZvID1cbiAgICAgIHsgYWlfZmFtaWx5IDogc29ja2V0X2RvbWFpblxuICAgICAgOyBhaV9zb2NrdHlwZSA6IHNvY2tldF90eXBlXG4gICAgICA7IGFpX3Byb3RvY29sIDogaW50XG4gICAgICA7IGFpX2FkZHIgOiBzb2NrYWRkcl9ibG9ja2luZ19zZXhwXG4gICAgICA7IGFpX2Nhbm9ubmFtZSA6IHN0cmluZ1xuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGJpbl9pbywgc2V4cF1cbiAgZW5kXG5cbiAgdHlwZSBnZXRhZGRyaW5mb19vcHRpb24gPSBVbml4LmdldGFkZHJpbmZvX29wdGlvbiA9XG4gICAgfCBBSV9GQU1JTFkgb2Ygc29ja2V0X2RvbWFpblxuICAgIHwgQUlfU09DS1RZUEUgb2Ygc29ja2V0X3R5cGVcbiAgICB8IEFJX1BST1RPQ09MIG9mIGludFxuICAgIHwgQUlfTlVNRVJJQ0hPU1RcbiAgICB8IEFJX0NBTk9OTkFNRVxuICAgIHwgQUlfUEFTU0lWRVxuICBbQEBkZXJpdmluZyBiaW5faW8sIHNleHBdXG5cbiAgbGV0IGdldCA/KHNlcnZpY2UgPSBcIlwiKSB+aG9zdCBvcHRpb25zID1cbiAgICBkbnNfbG9va3VwIH5uYW1lOlwiZ2V0YWRkcmluZm9cIiAoZnVuICgpIC0+IFVuaXguZ2V0YWRkcmluZm8gaG9zdCBzZXJ2aWNlIG9wdGlvbnMpXG4gIDs7XG5lbmRcblxubW9kdWxlIE5hbWVfaW5mbyA9IHN0cnVjdFxuICB0eXBlIHQgPSBVbml4Lm5hbWVfaW5mbyA9XG4gICAgeyBuaV9ob3N0bmFtZSA6IHN0cmluZ1xuICAgIDsgbmlfc2VydmljZSA6IHN0cmluZ1xuICAgIH1cbiAgW0BAZGVyaXZpbmcgYmluX2lvLCBzZXhwXVxuXG4gIHR5cGUgZ2V0bmFtZWluZm9fb3B0aW9uID0gVW5peC5nZXRuYW1laW5mb19vcHRpb24gPVxuICAgIHwgTklfTk9GUUROXG4gICAgfCBOSV9OVU1FUklDSE9TVFxuICAgIHwgTklfTkFNRVJFUURcbiAgICB8IE5JX05VTUVSSUNTRVJWXG4gICAgfCBOSV9ER1JBTVxuICBbQEBkZXJpdmluZyBzZXhwLCBiaW5faW9dXG5cbiAgbGV0IGdldCBhZGRyIG9wdGlvbnMgPVxuICAgIGRuc19sb29rdXAgfm5hbWU6XCJnZXRuYW1laW5mb1wiIChmdW4gKCkgLT4gVW5peC5nZXRuYW1laW5mbyBhZGRyIG9wdGlvbnMpXG4gIDs7XG5lbmRcblxubGV0IGdldGhvc3RuYW1lICgpID0gVW5peC5nZXRob3N0bmFtZSAoKVxubGV0IHNldHVpZCB1aWQgPSBVbml4LnNldHVpZCB1aWRcbmxldCBzZXRnaWQgZ2lkID0gVW5peC5zZXRnaWQgZ2lkXG5sZXQgZ2V0dWlkICgpID0gVW5peC5nZXR1aWQgKClcbmxldCBnZXRnaWQgKCkgPSBVbml4LmdldGdpZCAoKVxubGV0IGdldGVnaWQgKCkgPSBVbml4LmdldGVnaWQgKClcbmxldCBnZXRldWlkICgpID0gVW5peC5nZXRldWlkICgpXG5cbm1vZHVsZSBUZXJtaW5hbF9pbyA9IHN0cnVjdFxuICBpbmNsdWRlIFVuaXguVGVybWluYWxfaW9cblxuICBsZXQgdGNnZXRhdHRyIGZkID1cbiAgICBGZC5zeXNjYWxsX2luX3RocmVhZF9leG4gZmQgfm5hbWU6XCJ0Y2dldGF0dHJcIiAoZnVuIGZpbGVfZGVzY3IgLT4gdGNnZXRhdHRyIGZpbGVfZGVzY3IpXG4gIDs7XG5cbiAgbGV0IHRjc2V0YXR0ciB0IGZkIH5tb2RlID1cbiAgICBGZC5zeXNjYWxsX2luX3RocmVhZF9leG4gZmQgfm5hbWU6XCJ0Y3NldGF0dHJcIiAoZnVuIGZpbGVfZGVzY3IgLT5cbiAgICAgIHRjc2V0YXR0ciB0IGZpbGVfZGVzY3Igfm1vZGUpXG4gIDs7XG5lbmRcblxubW9kdWxlIFBhc3N3ZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBVbml4LlBhc3N3ZC50ID1cbiAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICA7IHBhc3N3ZCA6IHN0cmluZ1xuICAgIDsgdWlkIDogaW50XG4gICAgOyBnaWQgOiBpbnRcbiAgICA7IGdlY29zIDogc3RyaW5nXG4gICAgOyBkaXIgOiBzdHJpbmdcbiAgICA7IHNoZWxsIDogc3RyaW5nXG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMsIHNleHBdXG5cbiAgKCogVGhlIGZvdXIgW1VuaXguUGFzc3dkXSBmdW5jdGlvbnMgY2FsbCBDIGZ1bmN0aW9ucyB0aGF0IHJlbGVhc2UgdGhlIE9DYW1sIGxvY2sgYW5kIGRvXG4gICAgIGEgcmVlbnRyYW50IHN5c3RlbSBjYWxsLiAqKVxuICBsZXQgZ2V0YnluYW1lIG4gPSBJbl90aHJlYWQucnVuIChmdW4gKCkgLT4gVW5peC5QYXNzd2QuZ2V0YnluYW1lIG4pXG4gIGxldCBnZXRieW5hbWVfZXhuIG4gPSBJbl90aHJlYWQucnVuIChmdW4gKCkgLT4gVW5peC5QYXNzd2QuZ2V0YnluYW1lX2V4biBuKVxuICBsZXQgZ2V0Ynl1aWQgdWlkID0gSW5fdGhyZWFkLnJ1biAoZnVuICgpIC0+IFVuaXguUGFzc3dkLmdldGJ5dWlkIHVpZClcbiAgbGV0IGdldGJ5dWlkX2V4biB1aWQgPSBJbl90aHJlYWQucnVuIChmdW4gKCkgLT4gVW5peC5QYXNzd2QuZ2V0Ynl1aWRfZXhuIHVpZClcbmVuZFxuXG5tb2R1bGUgR3JvdXAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVW5peC5Hcm91cC50ID1cbiAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICA7IHBhc3N3ZCA6IHN0cmluZ1xuICAgIDsgZ2lkIDogaW50XG4gICAgOyBtZW0gOiBzdHJpbmcgYXJyYXlcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycywgc2V4cF1cblxuICAoKiBUaGUgZm91ciBbVW5peC5Hcm91cF0gZnVuY3Rpb25zIGNhbGwgQyBmdW5jdGlvbnMgdGhhdCByZWxlYXNlIHRoZSBPQ2FtbCBsb2NrIGFuZCBkbyBhXG4gICAgIHJlZW50cmFudCBzeXN0ZW0gY2FsbC4gKilcbiAgbGV0IGdldGJ5bmFtZSBuID0gSW5fdGhyZWFkLnJ1biAoZnVuICgpIC0+IFVuaXguR3JvdXAuZ2V0YnluYW1lIG4pXG4gIGxldCBnZXRieW5hbWVfZXhuIG4gPSBJbl90aHJlYWQucnVuIChmdW4gKCkgLT4gVW5peC5Hcm91cC5nZXRieW5hbWVfZXhuIG4pXG4gIGxldCBnZXRieWdpZCBnaWQgPSBJbl90aHJlYWQucnVuIChmdW4gKCkgLT4gVW5peC5Hcm91cC5nZXRieWdpZCBnaWQpXG4gIGxldCBnZXRieWdpZF9leG4gZ2lkID0gSW5fdGhyZWFkLnJ1biAoZnVuICgpIC0+IFVuaXguR3JvdXAuZ2V0YnlnaWRfZXhuIGdpZClcbmVuZFxuXG5sZXQgdXNlcm5hbWUgKCkgPSBJbl90aHJlYWQuc3lzY2FsbF9leG4gfm5hbWU6XCJ1c2VybmFtZVwiIChmdW4gKCkgLT4gVW5peC51c2VybmFtZSAoKSlcbmxldCBnZXRsb2dpbiAoKSA9IEluX3RocmVhZC5zeXNjYWxsX2V4biB+bmFtZTpcImdldGxvZ2luXCIgKGZ1biAoKSAtPiBVbml4LmdldGxvZ2luICgpKVxuXG5tb2R1bGUgSWZhZGRyID0gVW5peC5JZmFkZHJcblxubGV0IGdldGlmYWRkcnMgKCkgPSBJbl90aHJlYWQucnVuIFVuaXguZ2V0aWZhZGRyc1xuXG5sZXQgd29yZGV4cCA9XG4gIE9yX2Vycm9yLm1hcCBVbml4LndvcmRleHAgfmY6KGZ1biB3b3JkZXhwID9mbGFncyBnbG9iIC0+XG4gICAgSW5fdGhyZWFkLnN5c2NhbGxfZXhuIH5uYW1lOlwid29yZGV4cFwiIChmdW4gKCkgLT4gd29yZGV4cCA/ZmxhZ3MgZ2xvYikpXG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgV2FpdCA9IFdhaXRcblxuICBsZXQgZG5zX2xvb2t1cCA9IGRuc19sb29rdXBcbmVuZFxuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxub3BlbiBSZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlXG5tb2R1bGUgVW5peCA9IFVuaXhfc3lzY2FsbHNcbm1vZHVsZSBJT1ZlYyA9IENvcmVfdW5peC5JT1ZlY1xubW9kdWxlIElkID0gVW5pcXVlX2lkLkludDYzICgpXG5cbmxldCBkZWJ1ZyA9IERlYnVnLndyaXRlclxuXG5tb2R1bGUgVGltZV9uc19zdXBwcmVzc19zZXhwX2luX3Rlc3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVGltZV9ucy50XG5cbiAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICBpZiBQcHhfaW5saW5lX3Rlc3RfbGliLmFtX3J1bm5pbmcgdGhlbiBTZXhwLkxpc3QgW10gZWxzZSBUaW1lX25zLnNleHBfb2ZfdCB0XG4gIDs7XG5lbmRcblxubW9kdWxlIEZsdXNoX3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgRXJyb3JcbiAgICB8IENvbnN1bWVyX2xlZnRcbiAgICB8IEZvcmNlX2Nsb3NlZFxuICAgIHwgRmx1c2hlZCBvZiBUaW1lX25zX3N1cHByZXNzX3NleHBfaW5fdGVzdC50XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIExpbmVfZW5kaW5nID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBEb3NcbiAgICB8IFVuaXhcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5tb2R1bGUgQ2hlY2tfYnVmZmVyX2FnZScgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IHdyaXRlciA6ICdhXG4gICAgOyBtYXhpbXVtX2FnZSA6IFRpbWVfbnMuU3Bhbi50XG4gICAgOyBtdXRhYmxlIGJ5dGVzX3JlY2VpdmVkX2F0X25vd19taW51c19tYXhpbXVtX2FnZSA6IEludDYzLnRcbiAgICA7ICgqIFRoZSAyIGZvbGxvd2luZyBxdWV1ZXMgaG9sZCB0aGUgbm90LXlldC13cml0dGVuIGJ5dGVzIHJlY2VpdmVkIGJ5IHRoZSB3cml0ZXIgaW5cbiAgICAgICAgIHRoZSBsYXN0IFttYXhpbXVtX2FnZV0gcGVyaW9kIG9mIHRpbWUsIHdpdGggdGhlIHRpbWUgdGhleSB3ZXJlIHJlY2VpdmVkIGF0LlxuICAgICAgICAgW1F1ZXVlLmxlbmd0aCBieXRlc19yZWNlaXZlZF9xdWV1ZSA9IFF1ZXVlLmxlbmd0aCB0aW1lc19yZWNlaXZlZF9xdWV1ZV0uICopXG4gICAgICBieXRlc19yZWNlaXZlZF9xdWV1ZSA6IEludDYzLnQgUXVldWUudFxuICAgIDsgdGltZXNfcmVjZWl2ZWRfcXVldWUgOiBUaW1lX25zLnQgUXVldWUudFxuICAgIDsgKCogTnVtYmVyIG9mIGJ5dGVzIFwic2VlblwiIGJ5IHRoZSBjaGVja2VyLiAgW3Qud3JpdGVyLmJ5dGVzX3JlY2VpdmVkIC0gdC5ieXRlc19zZWVuXVxuICAgICAgICAgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGJ5IHRoZSB3cml0ZXIgc2luY2UgdGhlIGxhc3QgdGltZSB0aGVcbiAgICAgICAgIGNoZWNrZXIgcmFuLiAqKVxuICAgICAgbXV0YWJsZSBieXRlc19zZWVuIDogSW50NjMudFxuICAgIDsgKCogVGhlIGJ1ZmZlci1hZ2UgY2hlY2sgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgaW4gW3Rvb19vbGRdIGlmIGl0IGRldGVjdHMgYW4gYWdlXG4gICAgICAgICB2aW9sYXRpb24uICopXG4gICAgICBtdXRhYmxlIHRvb19vbGQgOiB1bml0IEl2YXIudFxuICAgIDsgKCogVGhlIGJ1ZmZlci1hZ2UgY2hlY2tzIGFyZSBzdG9yZWQgaW4gb25lIG9mIHRoZXNlIGRhdGEgc3RydWN0dXJlcyBwZXIgdGltZSBzb3VyY2UsXG4gICAgICAgICBhbmQgd2Uga2VlcCBhIHJlZmVyZW5jZSB0byBvdXIgcGFyZW50IG9uZSBpbiB0aGlzIFt0XSBzbyB3ZSBjYW4gZWFzaWx5IHJlbW92ZVxuICAgICAgICAgb3Vyc2VsdmVzIGZyb20gaXQgd2hlbiBjbG9zaW5nIHRoZSB3cml0ZXIuICopXG4gICAgICBmb3JfdGhpc190aW1lX3NvdXJjZSA6ICdhIHBlcl90aW1lX3NvdXJjZVxuICAgIH1cblxuICBhbmQgJ2EgcGVyX3RpbWVfc291cmNlID1cbiAgICB7IGFjdGl2ZV9jaGVja3MgOiAoJ2EgdFtAc2V4cC5vcGFxdWVdKSBCYWcudFxuICAgIDsgY2xvc2VkIDogdW5pdCBJdmFyLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIE9wZW5fZmxhZ3MgPSBVbml4Lk9wZW5fZmxhZ3NcblxudHlwZSBvcGVuX2ZsYWdzID1cbiAgWyBgQWxyZWFkeV9jbG9zZWRcbiAgfCBgT2sgb2YgT3Blbl9mbGFncy50XG4gIHwgYEVycm9yIG9mIGV4blxuICBdXG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5tb2R1bGUgQmFja2luZ19vdXRfY2hhbm5lbCA9IEJhY2tpbmdfb3V0X2NoYW5uZWxcblxubW9kdWxlIERlc3Ryb3lfb3Jfa2VlcCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgRGVzdHJveVxuICAgIHwgS2VlcFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbm1vZHVsZSBTY2hlZHVsZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gKEJpZ3N0cmluZy50IElPVmVjLnQgKiBEZXN0cm95X29yX2tlZXAudCkgRGVxdWUudFxuXG4gIGxldCBsZW5ndGggKHQgOiB0KSA9IERlcXVlLmZvbGQgdCB+aW5pdDowIH5mOihmdW4gbiAoaW92ZWMsIF8pIC0+IG4gKyBpb3ZlYy5sZW4pXG5lbmRcblxubW9kdWxlIFN0b3BfcmVhc29uID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBFcnJvclxuICAgIHwgQ2xvc2VkXG4gICAgfCAoKiBbQ29uc3VtZXJfbGVmdF0gaXMgb25seSByZXBvcnRlZCB3aGVuIFtyYWlzZV93aGVuX2NvbnN1bWVyX2xlYXZlcyA9IGZhbHNlXSxcbiAgICAgICAgIG90aGVyd2lzZSBhbiBbRXJyb3JdIGlzIHJlcG9ydGVkLiAqKVxuICAgICAgQ29uc3VtZXJfbGVmdFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbnR5cGUgdCA9XG4gIHsgaWQgOiBJZC50XG4gIDsgbXV0YWJsZSBmZCA6IEZkLnRcbiAgOyAoKiBUaGUgd3JpdGVyIHVzZXMgYSBiYWNrZ3JvdW5kIGpvYiB0byBmbHVzaCBkYXRhLiAgVGhlIGpvYiBydW5zIHdpdGhpblxuICAgICAgIFtpbm5lcl9tb25pdG9yXSwgd2hpY2ggaGFzIGEgaGFuZGxlciB0aGF0IHdyYXBzIGFsbCBlcnJvcnMgdG8gaW5jbHVkZSBbc2V4cF9vZl90XG4gICAgICAgdF0sIGFuZCBzZW5kcyB0aGVtIHRvIFttb25pdG9yXS4gKilcbiAgICBtb25pdG9yIDogTW9uaXRvci50XG4gIDsgaW5uZXJfbW9uaXRvciA6IE1vbml0b3IudFxuICA7IG11dGFibGVcbiAgICAgIGJhY2tncm91bmRfd3JpdGVyX3N0YXRlIDpcbiAgICAgIFsgYFJ1bm5pbmcgfCBgTm90X3J1bm5pbmcgfCBgU3RvcHBlZF9wZXJtYW5lbnRseSBvZiBTdG9wX3JlYXNvbi50IF1cbiAgOyBiYWNrZ3JvdW5kX3dyaXRlcl9zdG9wcGVkIDogdW5pdCBJdmFyLnRcbiAgOyAoKiBbc3lzY2FsbF0gZGV0ZXJtaW5lcyB0aGUgYmF0Y2hpbmcgYXBwcm9hY2ggdGhhdCB0aGUgd3JpdGVyIHVzZXMgdG8gYmF0Y2ggZGF0YVxuICAgICAgIHRvZ2V0aGVyIGFuZCBmbHVzaCBpdCB1c2luZyB0aGUgdW5kZXJseWluZyB3cml0ZSBzeXNjYWxsLiAqKVxuICAgIHN5c2NhbGwgOiBbIGBQZXJfY3ljbGUgfCBgUGVyaW9kaWMgb2YgVGltZV9mbG9hdC5TcGFuLnQgXVxuICA7ICgqIENvdW50cyBzaW5jZSB0aGUgd3JpdGVyIHdhcyBjcmVhdGVkLiAqKVxuICAgIG11dGFibGUgYnl0ZXNfcmVjZWl2ZWQgOiBJbnQ2My50XG4gIDsgbXV0YWJsZSBieXRlc193cml0dGVuIDogSW50NjMudFxuICA7ICgqIEJ5dGVzIHRoYXQgd2UgaGF2ZSByZWNlaXZlZCBidXQgbm90IHlldCB3cml0dGVuIGFyZSBzdG9yZWQgaW4gdHdvIHBsYWNlczpcbiAgICAgICBbc2NoZWR1bGVkXSBhbmQgW2J1Zl0uICBUaGUgYnl0ZXMgdGhhdCB3ZSBuZWVkIHRvIHdyaXRlIGFyZSB0aGUgY29uY2F0ZW5hdGlvbiBvZlxuICAgICAgIHRoZSBzZXF1ZW5jZSBvZiBpb3ZlY3MgaW4gW3NjaGVkdWxlZF0gZm9sbG93ZWQgYnkgdGhlIGJ5dGVzIGluIFtidWZdIGZyb21cbiAgICAgICBbc2NoZWR1bGVkX2JhY2tdIHRvIFtiYWNrXS4gIE5vdGUgdGhhdCBpb3ZlY3MgaW4gW3NjaGVkdWxlZF0gY2FuIHBvaW50IHRvIHJlZ2lvbnNcbiAgICAgICBpbiBbYnVmXSwgZXZlbiB0aGUgY3VycmVudCBbYnVmXSBpbiB0aGUgd3JpdGVyLiAqKVxuICAgICgqIFtzY2hlZHVsZWRdIGhvbGRzIGlvdmVjcyB0aGF0IHdlIHBsYW4gdG8gd3JpdGUuICopXG4gICAgc2NoZWR1bGVkIDogU2NoZWR1bGVkLnRcbiAgOyAoKiBbc2NoZWR1bGVkX2J5dGVzXSBpcyB0aGUgc3VtIG9mIHRoZSBsZW5ndGhzIG9mIHRoZSBpb3ZlY3MgaW5bc2NoZWR1bGVkXSAqKVxuICAgIG11dGFibGUgc2NoZWR1bGVkX2J5dGVzIDogaW50XG4gIDsgKCogW2J1Zl0gaGFzIHRocmVlIHJlZ2lvbnM6XG4gICAgICAgWzAsIHNjaGVkdWxlZF9iYWNrKSAgICAgICAgICAgICByZWNlaXZlZCBhbmQgc2NoZWR1bGVkXG4gICAgICAgW3NjaGVkdWxlZF9iYWNrLCBiYWNrKSAgICAgICAgICByZWNlaXZlZCBidXQgbm90IHNjaGVkdWxlZFxuICAgICAgIFtiYWNrLCBCaWdzdHJpbmcubGVuZ3RoIGJ1ZikgICAgZnJlZSBzcGFjZSopXG4gICAgbXV0YWJsZSBidWYgOiBCaWdzdHJpbmcudFxuICA7IG11dGFibGUgc2NoZWR1bGVkX2JhY2sgOiBpbnRcbiAgOyBtdXRhYmxlIGJhY2sgOiBpbnRcbiAgOyB0aW1lX3NvdXJjZSA6IFRpbWVfc291cmNlLnRcbiAgOyBmbHVzaGVzIDogKEZsdXNoX3Jlc3VsdC50IEl2YXIudCAqIEludDYzLnQpIFF1ZXVlLnRcbiAgOyAoKiBbY2xvc2VkX3N0YXRlXSB0cmFja3MgdGhlIHN0YXRlIG9mIHRoZSB3cml0ZXIgYXMgaXQgaXMgYmVpbmcgY2xvc2VkLiAgSW5pdGlhbGx5LFxuICAgICAgIFtjbG9zZWRfc3RhdGVdIGlzIFtgT3Blbl0uICBXaGVuIFtjbG9zZV0gaXMgY2FsbGVkLCBbY2xvc2VkX3N0YXRlXSB0cmFuc2l0aW9ucyB0b1xuICAgICAgIFtgQ2xvc2VkX2FuZF9mbHVzaGluZ10uICBPbmNlIHRoZSB3cml0ZXIgaXMgZmx1c2hlZCBhbmQgd2UncmUgYWN0dWFsbHkgZ29pbmcgdG9cbiAgICAgICBjbG9zZSBbZmRdLCBpdCB0cmFuc2l0aW9ucyB0b1tgQ2xvc2VkXS5cblxuICAgICAgIFRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIFtgQ2xvc2VkXSBhbmQgW2BDbG9zZWRfYW5kX2ZsdXNoaW5nXSBpcyBuZWNlc3NhcnkgYmVjYXVzZVxuICAgICAgIHdlIHdhbnQgdG8gYWxsb3cgW3dyaXRlXXMgdG8gaGFwcGVuIHdoaWxlIFtgQ2xvc2VkX2FuZF9mbHVzaGluZ10sIGJ1dCBub3Qgd2hlblxuICAgICAgIFtgQ2xvc2VkXS4gIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGFsbG93IHVwc3RyZWFtIHByb2R1Y2VycyB0byBmbHVzaCB0aGVpciBkYXRhIHRvXG4gICAgICAgdGhlIHdyaXRlciB3aGVuIGl0IGlzIGNsb3NlZC4gKilcbiAgICBtdXRhYmxlIGNsb3NlX3N0YXRlIDogWyBgT3BlbiB8IGBDbG9zZWRfYW5kX2ZsdXNoaW5nIHwgYENsb3NlZCBdXG4gIDsgKCogW2Nsb3NlX2ZpbmlzaGVkXSBpcyBmaWxsZWQgd2hlbiB0aGUgY2xvc2UoKSBzeXN0ZW0gY2FsbCBvbiBbZmRdIGZpbmlzaGVzLiAqKVxuICAgIGNsb3NlX2ZpbmlzaGVkIDogdW5pdCBJdmFyLnRcbiAgOyAoKiBbY2xvc2Vfc3RhcnRlZF0gaXMgZmlsbGVkIHdoZW4gW2Nsb3NlXSBpcyBjYWxsZWQuICopXG4gICAgY2xvc2Vfc3RhcnRlZCA6IHVuaXQgSXZhci50XG4gIDsgKCogW3Byb2R1Y2Vyc190b19mbHVzaF9hdF9jbG9zZV0gaG9sZHMgYWxsIHVwc3RyZWFtIHByb2R1Y2VycyBmZWVkaW5nIGRhdGEgdG8gdGhpc1xuICAgICAgIHdyaXRlciwgYW5kIHRodXMgc2hvdWxkIGJlIGZsdXNoZWQgd2hlbiB3ZSBjbG9zZSB0aGlzIHdyaXRlciwgYmVmb3JlIGZsdXNoaW5nXG4gICAgICAgdGhlIHdyaXRlciBpdHNlbGYuICopXG4gICAgcHJvZHVjZXJzX3RvX2ZsdXNoX2F0X2Nsb3NlIDogKHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50KSBCYWcudFxuICA7ICgqIFtmbHVzaF9hdF9zaHV0ZG93bl9lbHRdIGhvbGRzIHRoZSBlbGVtZW50IGluIFt3cml0ZXJzX3RvX2ZsdXNoX2F0X3NodXRkb3duXSBmb3JcbiAgICAgICB0aGlzIHdyaXRlci4gIEJlaW5nIGluIHRoYXQgYmFnIGlzIHdoYXQgY2F1c2VzIHRoaXMgd3JpdGVyIHRvIGJlIGF1dG9tYXRpY2FsbHlcbiAgICAgICBjbG9zZWQgd2hlbiBbc2h1dGRvd25dIGlzIGNhbGxlZCwgYW5kIGZvciBzaHV0ZG93biB0byB3YWl0IGZvciB0aGUgY2xvc2UgdG8gZmluaXNoLlxuICAgICAgIFtmbHVzaF9hdF9zaHV0ZG93bl9lbHRdIGlzIFtTb21lXSBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSB3cml0ZXIsIHVudGlsIHRoZVxuICAgICAgIGNsb3NlIGZpbmlzaGVzLCBhdCB3aGljaCBwb2ludCBpdCB0cmFuc2l0aW9ucyB0b1tOb25lXS4gKilcbiAgICBtdXRhYmxlIGZsdXNoX2F0X3NodXRkb3duX2VsdCA6IHQgQmFnLkVsdC50IG9wdGlvblxuICA7ICgqIExhenkgYnVmZmVyIGFnZSBjaGVjayBzbyB0aGF0IGZvcmNpbmcgZWl0aGVyIFtXcml0ZXIuc3Rkb3V0XSBhbmQgW1dyaXRlci5zdGRlcnJdXG4gICAgICAgZG9lc24ndCBzY2hlZHVsZSBhc3luYyB3b3JrLiAqKVxuICAgIG11dGFibGUgY2hlY2tfYnVmZmVyX2FnZSA6IHQgQ2hlY2tfYnVmZmVyX2FnZScudCBCYWcuRWx0LnQgb3B0aW9uIExhenkudFxuICA7ICgqIFRoZSBcImNvbnN1bWVyXCIgb2YgYSB3cml0ZXIgaXMgd2hvbWV2ZXIgaXMgcmVhZGluZyB0aGUgYnl0ZXMgdGhhdCB0aGUgd3JpdGVyXG4gICAgICAgaXMgd3JpdGluZy4gIEUuZy4gaWYgdGhlIHdyaXRlcidzIGZpbGUgZGVzY3JpcHRvciBpcyBhIHNvY2tldCwgdGhlbiBpdCBpcyB3aG9tZXZlclxuICAgICAgIGlzIG9uIHRoZSBvdGhlciBzaWRlIG9mIHRoZSBzb2NrZXQgY29ubmVjdGlvbi4gIElmIHRoZSBjb25zdW1lciBsZWF2ZXMsIFVuaXggd2lsbFxuICAgICAgIGluZGljYXRlIHRoaXMgYnkgcmV0dXJuaW5nIEVQSVBFIG9yIEVDT05OUkVTRVQgdG8gYSB3cml0ZSgpIHN5c2NhbGwuICBXZSBrZWVwXG4gICAgICAgdHJhY2sgb2YgdGhpcyB3aXRoIHRoZSBbY29uc3VtZXJfbGVmdF0gaXZhciwgd2hpY2ggaXMgZXhwb3NlZCBpbiB3cml0ZXIubWxpLlxuICAgICAgIFdlIGFsc28gYWxsb3cgdGhlIHVzZXIgdG8gY29uZmlndXJlIHdoYXQgYWN0aW9uIHRoZSB3cml0ZXIgdGFrZXMgd2hlbiB0aGVcbiAgICAgICBjb25zdW1lciBsZWF2ZXMuICBCeSBkZWZhdWx0LCBpdCByYWlzZXMsIGJ1dCB0aGF0IGNhbiBiZSBkaXNhYmxlZC4gKilcbiAgICBjb25zdW1lcl9sZWZ0IDogdW5pdCBJdmFyLnRcbiAgOyBtdXRhYmxlIHJhaXNlX3doZW5fY29uc3VtZXJfbGVhdmVzIDogYm9vbCAoKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICA7ICgqIFtvcGVuX2ZsYWdzXSBpcyB0aGUgb3Blbi1maWxlLWRlc2NyaXB0b3IgYml0cyBvZiBbZmRdLlxuICAgICAgIFtvcGVuX2ZsYWdzXSBpcyB1c2VkIHRvIHJlcG9ydCBhbiBlcnJvciB3aGVuIFtmZF0gaXMgbm90IHdyaXRhYmxlLiAqKVxuICAgIG9wZW5fZmxhZ3MgOiBvcGVuX2ZsYWdzXG4gIDsgbGluZV9lbmRpbmcgOiBMaW5lX2VuZGluZy50XG4gIDsgKCogSWYgc3BlY2lmaWVkLCBzdWJzZXF1ZW50IHdyaXRlcyBhcmUgc3luY2hyb25vdXNseSByZWRpcmVjdGVkIGhlcmUuICopXG4gICAgbXV0YWJsZSBiYWNraW5nX291dF9jaGFubmVsIDogQmFja2luZ19vdXRfY2hhbm5lbC50IG9wdGlvblxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfml0ZXJhdG9yczppdGVyXVxuXG5sZXQgc2V4cF9vZl90IHQgPSBbJXNleHAgKHQuZmQgOiBGZC50X2h1bSldXG5cbnR5cGUgdF9pbnRlcm5hbHMgPSB0XG5cbmxldCBzZXhwX29mX3RfaW50ZXJuYWxzXG4gICh7IGlkXG4gICA7IGZkXG4gICA7IG1vbml0b3JcbiAgIDsgaW5uZXJfbW9uaXRvclxuICAgOyBiYWNrZ3JvdW5kX3dyaXRlcl9zdGF0ZVxuICAgOyBiYWNrZ3JvdW5kX3dyaXRlcl9zdG9wcGVkXG4gICA7IHN5c2NhbGxcbiAgIDsgYnl0ZXNfcmVjZWl2ZWRcbiAgIDsgYnl0ZXNfd3JpdHRlblxuICAgOyBzY2hlZHVsZWQgPSBfXG4gICA7IHNjaGVkdWxlZF9ieXRlc1xuICAgOyBidWYgPSBfXG4gICA7IHNjaGVkdWxlZF9iYWNrXG4gICA7IGJhY2tcbiAgIDsgdGltZV9zb3VyY2VcbiAgIDsgZmx1c2hlcyA9IF9cbiAgIDsgY2xvc2Vfc3RhdGVcbiAgIDsgY2xvc2VfZmluaXNoZWRcbiAgIDsgY2xvc2Vfc3RhcnRlZFxuICAgOyBwcm9kdWNlcnNfdG9fZmx1c2hfYXRfY2xvc2VcbiAgIDsgZmx1c2hfYXRfc2h1dGRvd25fZWx0XG4gICA7IGNoZWNrX2J1ZmZlcl9hZ2VcbiAgIDsgY29uc3VtZXJfbGVmdFxuICAgOyByYWlzZV93aGVuX2NvbnN1bWVyX2xlYXZlc1xuICAgOyBvcGVuX2ZsYWdzXG4gICA7IGxpbmVfZW5kaW5nXG4gICA7IGJhY2tpbmdfb3V0X2NoYW5uZWxcbiAgIH0gOlxuICAgIHRfaW50ZXJuYWxzKVxuICA9XG4gIGxldCBzdXBwcmVzc19pbl90ZXN0IHggPSBpZiBQcHhfaW5saW5lX3Rlc3RfbGliLmFtX3J1bm5pbmcgdGhlbiBOb25lIGVsc2UgU29tZSB4IGluXG4gIGxldCBtb25pdG9yX25hbWVfaW5fdGVzdCBtb25pdG9yID1cbiAgICBpZiBQcHhfaW5saW5lX3Rlc3RfbGliLmFtX3J1bm5pbmdcbiAgICB0aGVuIFslc2V4cCAoTW9uaXRvci5uYW1lIG1vbml0b3IgOiBJbmZvLnQpXVxuICAgIGVsc2UgWyVzZXhwIChtb25pdG9yIDogTW9uaXRvci50KV1cbiAgaW5cbiAgbGV0IHRpbWVfc291cmNlID1cbiAgICBpZiBwaHlzX2VxdWFsIHRpbWVfc291cmNlIChUaW1lX3NvdXJjZS53YWxsX2Nsb2NrICgpKSB0aGVuIE5vbmUgZWxzZSBTb21lIHRpbWVfc291cmNlXG4gIGluXG4gICgqIFtvcGVuX2ZsYWdzXSBhcmUgbm9uLWRldGVybWluaXN0aWMgYWNyb3NzIENlbnRPUyB2ZXJzaW9ucyBhbmQgaGF2ZSBiZWVuIHN1cHByZXNzZWQgaW5cbiAgICAgdGVzdHMuICBMaW51eCBrZXJuZWxzIChDZW50T1MgNikgZXhwb3NlIE9fQ0xPRVhFQyB2aWEgZmNudGwoZmQsIEZfR0VURkwpLCBidXQgbmV3ZXJcbiAgICAgKENlbnRPUyA3KSBvbmVzIGRvbid0ICopXG4gIFslc2V4cFxuICAgIHsgaWQgPSAoc3VwcHJlc3NfaW5fdGVzdCBpZCA6IChJZC50IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICA7IGZkID0gKHN1cHByZXNzX2luX3Rlc3QgZmQgOiAoRmQudCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgOyBtb25pdG9yID0gKG1vbml0b3JfbmFtZV9pbl90ZXN0IG1vbml0b3IgOiBTZXhwLnQpXG4gICAgOyBpbm5lcl9tb25pdG9yID0gKG1vbml0b3JfbmFtZV9pbl90ZXN0IGlubmVyX21vbml0b3IgOiBTZXhwLnQpXG4gICAgOyBiYWNrZ3JvdW5kX3dyaXRlcl9zdGF0ZSA6IFsgYFJ1bm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBgTm90X3J1bm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBgU3RvcHBlZF9wZXJtYW5lbnRseSBvZiBTdG9wX3JlYXNvbi50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICA7IGJhY2tncm91bmRfd3JpdGVyX3N0b3BwZWQgOiB1bml0IEl2YXIudFxuICAgIDsgc3lzY2FsbCA6IFsgYFBlcl9jeWNsZSB8IGBQZXJpb2RpYyBvZiBUaW1lX2Zsb2F0LlNwYW4udCBdXG4gICAgOyBieXRlc19yZWNlaXZlZCA6IEludDYzLnRcbiAgICA7IGJ5dGVzX3dyaXR0ZW4gOiBJbnQ2My50XG4gICAgOyBzY2hlZHVsZWRfYnl0ZXMgOiBpbnRcbiAgICA7IHNjaGVkdWxlZF9iYWNrIDogaW50XG4gICAgOyBiYWNrIDogaW50XG4gICAgOyB0aW1lX3NvdXJjZSA6IChUaW1lX3NvdXJjZS50IG9wdGlvbltAc2V4cC5vcHRpb25dKVxuICAgIDsgY2xvc2Vfc3RhdGUgOiBbIGBPcGVuIHwgYENsb3NlZF9hbmRfZmx1c2hpbmcgfCBgQ2xvc2VkIF1cbiAgICA7IGNsb3NlX2ZpbmlzaGVkIDogdW5pdCBJdmFyLnRcbiAgICA7IGNsb3NlX3N0YXJ0ZWQgOiB1bml0IEl2YXIudFxuICAgIDsgbnVtX3Byb2R1Y2Vyc190b19mbHVzaF9hdF9jbG9zZSA9IChCYWcubGVuZ3RoIHByb2R1Y2Vyc190b19mbHVzaF9hdF9jbG9zZSA6IGludClcbiAgICA7IGZsdXNoX2F0X3NodXRkb3duX2VsdCA9XG4gICAgICAgIChzdXBwcmVzc19pbl90ZXN0IGZsdXNoX2F0X3NodXRkb3duX2VsdFxuICAgICAgICAgIDogKCh0W0BzZXhwLm9wYXF1ZV0pIEJhZy5FbHQudCBvcHRpb24gb3B0aW9uW0BzZXhwLm9wdGlvbl0pKVxuICAgIDsgY2hlY2tfYnVmZmVyX2FnZSA9XG4gICAgICAgIChzdXBwcmVzc19pbl90ZXN0IGNoZWNrX2J1ZmZlcl9hZ2VcbiAgICAgICAgICA6ICgodFtAc2V4cC5vcGFxdWVdKSBDaGVja19idWZmZXJfYWdlJy50IEJhZy5FbHQudCBvcHRpb24gTGF6eS50IG9wdGlvblxuICAgICAgICAgICAgW0BzZXhwLm9wdGlvbl0pKVxuICAgIDsgY29uc3VtZXJfbGVmdCA6IHVuaXQgSXZhci50XG4gICAgOyByYWlzZV93aGVuX2NvbnN1bWVyX2xlYXZlcyA6IGJvb2xcbiAgICA7IG9wZW5fZmxhZ3MgPSAoc3VwcHJlc3NfaW5fdGVzdCBvcGVuX2ZsYWdzIDogKG9wZW5fZmxhZ3Mgb3B0aW9uW0BzZXhwLm9wdGlvbl0pKVxuICAgIDsgbGluZV9lbmRpbmcgOiBMaW5lX2VuZGluZy50XG4gICAgOyBiYWNraW5nX291dF9jaGFubmVsIDogKEJhY2tpbmdfb3V0X2NoYW5uZWwudCBvcHRpb25bQHNleHAub3B0aW9uXSlcbiAgICB9XVxuOztcblxudHlwZSB3cml0ZXIgPSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBzZXRfcmFpc2Vfd2hlbl9jb25zdW1lcl9sZWF2ZXMgdCBib29sID0gdC5yYWlzZV93aGVuX2NvbnN1bWVyX2xlYXZlcyA8LSBib29sXG5sZXQgYnl0ZXNfdG9fd3JpdGUgdCA9IHQuc2NoZWR1bGVkX2J5dGVzICsgdC5iYWNrIC0gdC5zY2hlZHVsZWRfYmFja1xuXG5sZXQgaXNfc3RvcHBlZF9wZXJtYW5lbnRseSB0ID1cbiAgbWF0Y2ggdC5iYWNrZ3JvdW5kX3dyaXRlcl9zdGF0ZSB3aXRoXG4gIHwgYFN0b3BwZWRfcGVybWFuZW50bHkgXyAtPiB0cnVlXG4gIHwgYFJ1bm5pbmcgfCBgTm90X3J1bm5pbmcgLT4gZmFsc2Vcbjs7XG5cbmxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+aWQ6aWdub3JlXG4gICAgICB+ZmQ6aWdub3JlXG4gICAgICB+bW9uaXRvcjppZ25vcmVcbiAgICAgIH5pbm5lcl9tb25pdG9yOmlnbm9yZVxuICAgICAgfmJ1ZjppZ25vcmVcbiAgICAgIH5iYWNrZ3JvdW5kX3dyaXRlcl9zdGF0ZTpcbiAgICAgICAgKGNoZWNrIChmdW5jdGlvblxuICAgICAgICAgIHwgYFN0b3BwZWRfcGVybWFuZW50bHkgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChieXRlc190b193cml0ZSB0ID0gMCk7XG4gICAgICAgICAgICBhc3NlcnQgKEl2YXIuaXNfZnVsbCB0LmJhY2tncm91bmRfd3JpdGVyX3N0b3BwZWQpXG4gICAgICAgICAgfCBgUnVubmluZyB8IGBOb3RfcnVubmluZyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChCaWdzdHJpbmcubGVuZ3RoIHQuYnVmID4gMCk7XG4gICAgICAgICAgICBhc3NlcnQgKEludDYzLih0LmJ5dGVzX3JlY2VpdmVkIC0gdC5ieXRlc193cml0dGVuID0gb2ZfaW50IChieXRlc190b193cml0ZSB0KSkpO1xuICAgICAgICAgICAgYXNzZXJ0IChJdmFyLmlzX2VtcHR5IHQuYmFja2dyb3VuZF93cml0ZXJfc3RvcHBlZCkpKVxuICAgICAgfmJhY2tncm91bmRfd3JpdGVyX3N0b3BwZWQ6aWdub3JlXG4gICAgICB+c3lzY2FsbDppZ25vcmVcbiAgICAgIH5ieXRlc193cml0dGVuOlxuICAgICAgICAoY2hlY2sgKGZ1biBieXRlc193cml0dGVuIC0+XG4gICAgICAgICAgIGFzc2VydCAoSW50NjMuKHplcm8gPD0gYnl0ZXNfd3JpdHRlbiAmJiBieXRlc193cml0dGVuIDw9IHQuYnl0ZXNfcmVjZWl2ZWQpKSkpXG4gICAgICB+Ynl0ZXNfcmVjZWl2ZWQ6aWdub3JlXG4gICAgICB+c2NoZWR1bGVkOlxuICAgICAgICAoY2hlY2sgKGZ1biAoc2NoZWR1bGVkIDogU2NoZWR1bGVkLnQpIC0+XG4gICAgICAgICAgIERlcXVlLml0ZXIgc2NoZWR1bGVkIH5mOihmdW4gKGlvdmVjLCBraW5kKSAtPlxuICAgICAgICAgICAgIGlmIHBoeXNfZXF1YWwgdC5idWYgaW92ZWMuYnVmXG4gICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgbWF0Y2gga2luZCB3aXRoXG4gICAgICAgICAgICAgICAgIHwgS2VlcCAtPiB0cnVlXG4gICAgICAgICAgICAgICAgIHwgRGVzdHJveSAtPiBmYWxzZSkpKSlcbiAgICAgIH5zY2hlZHVsZWRfYnl0ZXM6XG4gICAgICAgIChjaGVjayAoZnVuIHNjaGVkdWxlZF9ieXRlcyAtPlxuICAgICAgICAgICBhc3NlcnQgKHNjaGVkdWxlZF9ieXRlcyA9IFNjaGVkdWxlZC5sZW5ndGggdC5zY2hlZHVsZWQpKSlcbiAgICAgIH5zY2hlZHVsZWRfYmFjazpcbiAgICAgICAgKGNoZWNrIChmdW4gc2NoZWR1bGVkX2JhY2sgLT5cbiAgICAgICAgICAgYXNzZXJ0ICgwIDw9IHNjaGVkdWxlZF9iYWNrICYmIHNjaGVkdWxlZF9iYWNrIDw9IHQuYmFjaykpKVxuICAgICAgfmJhY2s6KGNoZWNrIChmdW4gYmFjayAtPiBhc3NlcnQgKGJhY2sgPD0gQmlnc3RyaW5nLmxlbmd0aCB0LmJ1ZikpKVxuICAgICAgfnRpbWVfc291cmNlOmlnbm9yZVxuICAgICAgfmZsdXNoZXM6aWdub3JlXG4gICAgICB+Y2xvc2Vfc3RhdGU6aWdub3JlXG4gICAgICB+Y2xvc2VfZmluaXNoZWQ6XG4gICAgICAgIChjaGVjayAoZnVuIGNsb3NlX2ZpbmlzaGVkIC0+XG4gICAgICAgICAgIG1hdGNoIHQuY2xvc2Vfc3RhdGUgd2l0aFxuICAgICAgICAgICB8IGBPcGVuIHwgYENsb3NlZF9hbmRfZmx1c2hpbmcgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGNsb3NlX2ZpbmlzaGVkKVxuICAgICAgICAgICB8IGBDbG9zZWQgLT4gKCkpKVxuICAgICAgfmNsb3NlX3N0YXJ0ZWQ6XG4gICAgICAgIChjaGVjayAoZnVuIGNsb3NlX3N0YXJ0ZWQgLT5cbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogYm9vbF1cbiAgICAgICAgICAgICAoSXZhci5pc19lbXB0eSBjbG9zZV9zdGFydGVkKVxuICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAobWF0Y2ggdC5jbG9zZV9zdGF0ZSB3aXRoXG4gICAgICAgICAgICAgICAgfCBgT3BlbiAtPiB0cnVlXG4gICAgICAgICAgICAgICAgfCBgQ2xvc2VkIHwgYENsb3NlZF9hbmRfZmx1c2hpbmcgLT4gZmFsc2UpKSlcbiAgICAgIH5wcm9kdWNlcnNfdG9fZmx1c2hfYXRfY2xvc2U6aWdub3JlXG4gICAgICB+Zmx1c2hfYXRfc2h1dGRvd25fZWx0OlxuICAgICAgICAoY2hlY2sgKGZ1biBvIC0+XG4gICAgICAgICAgIGFzc2VydCAoQm9vbC5lcXVhbCAoaXNfbm9uZSBvKSAoSXZhci5pc19mdWxsIHQuY2xvc2VfZmluaXNoZWQpKTtcbiAgICAgICAgICAgT3B0aW9uLml0ZXIgbyB+ZjooZnVuIGVsdCAtPiBhc3NlcnQgKHBoeXNfZXF1YWwgdCAoQmFnLkVsdC52YWx1ZSBlbHQpKSkpKVxuICAgICAgfmNoZWNrX2J1ZmZlcl9hZ2U6aWdub3JlXG4gICAgICB+Y29uc3VtZXJfbGVmdDpcbiAgICAgICAgKGNoZWNrIChmdW4gY29uc3VtZXJfbGVmdCAtPlxuICAgICAgICAgICBpZiBJdmFyLmlzX2Z1bGwgY29uc3VtZXJfbGVmdCB0aGVuIGFzc2VydCAoaXNfc3RvcHBlZF9wZXJtYW5lbnRseSB0KSkpXG4gICAgICB+cmFpc2Vfd2hlbl9jb25zdW1lcl9sZWF2ZXM6aWdub3JlXG4gICAgICB+b3Blbl9mbGFnczppZ25vcmVcbiAgICAgIH5saW5lX2VuZGluZzppZ25vcmVcbiAgICAgIH5iYWNraW5nX291dF9jaGFubmVsOihjaGVjayAoT3B0aW9uLmludmFyaWFudCBCYWNraW5nX291dF9jaGFubmVsLmludmFyaWFudCkpXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zIFslbWVzc2FnZSBcIndyaXRlciBpbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgfndyaXRlcjoodCA6IHRfaW50ZXJuYWxzKV1cbjs7XG5cbm1vZHVsZSBDaGVja19idWZmZXJfYWdlIDogc2lnXG4gIHR5cGUgdCA9IHdyaXRlciBDaGVja19idWZmZXJfYWdlJy50IEJhZy5FbHQudCBvcHRpb25cblxuICB2YWwgZHVtbXkgOiB0XG4gIHZhbCBjcmVhdGUgOiB3cml0ZXIgLT4gbWF4aW11bV9hZ2U6WyBgQXRfbW9zdCBvZiBUaW1lX2Zsb2F0LlNwYW4udCB8IGBVbmxpbWl0ZWQgXSAtPiB0XG4gIHZhbCBkZXN0cm95IDogdCAtPiB1bml0XG4gIHZhbCB0b29fb2xkIDogdCAtPiB1bml0IERlZmVycmVkLnRcblxuICBtb2R1bGUgSW50ZXJuYWxfZm9yX3VuaXRfdGVzdCA6IHNpZ1xuICAgIHZhbCBjaGVja19ub3cgOiBjaGVja19pbnZhcmlhbnRzOmJvb2wgLT4gdGltZV9zb3VyY2U6VGltZV9zb3VyY2UudCAtPiB1bml0XG4gICAgdmFsIG51bV9hY3RpdmVfY2hlY2tzX2ZvciA6IFRpbWVfc291cmNlLnQgLT4gaW50IG9wdGlvblxuICBlbmRcbmVuZCA9IHN0cnVjdFxuICBvcGVuIENoZWNrX2J1ZmZlcl9hZ2UnXG5cbiAgdHlwZSB0ID0gd3JpdGVyIENoZWNrX2J1ZmZlcl9hZ2UnLnQgQmFnLkVsdC50IG9wdGlvblxuXG4gIGxldCBlbHRfaW52YXJpYW50IHQgOiB1bml0ID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICAgIGFzc2VydCAoUXVldWUubGVuZ3RoIHQuYnl0ZXNfcmVjZWl2ZWRfcXVldWUgPSBRdWV1ZS5sZW5ndGggdC50aW1lc19yZWNlaXZlZF9xdWV1ZSk7XG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+d3JpdGVyOmlnbm9yZVxuICAgICAgICB+bWF4aW11bV9hZ2U6aWdub3JlXG4gICAgICAgIH50b29fb2xkOlxuICAgICAgICAgIChjaGVjayAoZnVuIGl2YXIgLT5cbiAgICAgICAgICAgICBsZXQgaW1wbHkgYSBiID0gKG5vdCBhKSB8fCBiIGluXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIGltcGx5XG4gICAgICAgICAgICAgICAgIEludDYzLk8uKFxuICAgICAgICAgICAgICAgICAgIHQuYnl0ZXNfcmVjZWl2ZWRfYXRfbm93X21pbnVzX21heGltdW1fYWdlID4gdC53cml0ZXIuYnl0ZXNfd3JpdHRlbilcbiAgICAgICAgICAgICAgICAgKEl2YXIuaXNfZnVsbCBpdmFyKSkpKVxuICAgICAgICB+Ynl0ZXNfcmVjZWl2ZWRfcXVldWU6XG4gICAgICAgICAgKGNoZWNrIChmdW4gcSAtPlxuICAgICAgICAgICAgIGxldCBuID1cbiAgICAgICAgICAgICAgIFF1ZXVlLmZvbGRcbiAgICAgICAgICAgICAgICAgcVxuICAgICAgICAgICAgICAgICB+aW5pdDp0LmJ5dGVzX3JlY2VpdmVkX2F0X25vd19taW51c19tYXhpbXVtX2FnZVxuICAgICAgICAgICAgICAgICB+ZjooZnVuIHByZXYgY291bnQgLT5cbiAgICAgICAgICAgICAgICAgYXNzZXJ0IChJbnQ2My4oIDwgKSBwcmV2IGNvdW50KTtcbiAgICAgICAgICAgICAgICAgY291bnQpXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBhc3NlcnQgKEludDYzLiggPD0gKSBuIHQud3JpdGVyLmJ5dGVzX3JlY2VpdmVkKTtcbiAgICAgICAgICAgICBhc3NlcnQgKEludDYzLiggPSApIG4gdC5ieXRlc19zZWVuKSkpXG4gICAgICAgIH50aW1lc19yZWNlaXZlZF9xdWV1ZTpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBxIC0+XG4gICAgICAgICAgICAgbWF0Y2ggUXVldWUudG9fbGlzdCBxIHdpdGhcbiAgICAgICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgICAgICAgfCB0aW1lcyAtPlxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogVGltZV9ucy50IGxpc3RdXG4gICAgICAgICAgICAgICAgIH5leHBlY3Q6dGltZXNcbiAgICAgICAgICAgICAgICAgKExpc3Quc29ydCB0aW1lcyB+Y29tcGFyZTpUaW1lX25zLmNvbXBhcmUpO1xuICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgVGltZV9ucy5TcGFuLiggPD0gKVxuICAgICAgICAgICAgICAgICAgIChUaW1lX25zLmRpZmYgKExpc3QubGFzdF9leG4gdGltZXMpIChMaXN0LmhkX2V4biB0aW1lcykpXG4gICAgICAgICAgICAgICAgICAgdC5tYXhpbXVtX2FnZSkpKVxuICAgICAgICB+Ynl0ZXNfcmVjZWl2ZWRfYXRfbm93X21pbnVzX21heGltdW1fYWdlOmlnbm9yZVxuICAgICAgICB+Ynl0ZXNfc2VlbjppZ25vcmVcbiAgICAgICAgfmZvcl90aGlzX3RpbWVfc291cmNlOmlnbm9yZSlcbiAgOztcblxuICBsZXQgZHVtbXkgPSBOb25lXG5cbiAgKCogW3N5bmNdIHBydW5lcyBoaXN0b3J5IGJ5IHJlbW92aW5nIGFsbCB0aGUgZW50cmllcyBmcm9tIFsqX3JlY2VpdmVkX3F1ZXVlXXMgdGhhdFxuICAgICBjb3JyZXNwb25kIHRvIGJ5dGVzIGFscmVhZHkgd3JpdHRlbiBvciB0aW1lcyBvbGRlciB0aGFuIFtub3cgLSB0aW1lX3JlY2VpdmVkXS4gKilcbiAgbGV0IHJlYyBzeW5jIGUgfm5vdyA9XG4gICAgaWYgbm90IChRdWV1ZS5pc19lbXB0eSBlLmJ5dGVzX3JlY2VpdmVkX3F1ZXVlKVxuICAgIHRoZW4gKFxuICAgICAgbGV0IGJ5dGVzX3JlY2VpdmVkID0gUXVldWUucGVla19leG4gZS5ieXRlc19yZWNlaXZlZF9xdWV1ZSBpblxuICAgICAgbGV0IHRpbWVfcmVjZWl2ZWQgPSBRdWV1ZS5wZWVrX2V4biBlLnRpbWVzX3JlY2VpdmVkX3F1ZXVlIGluXG4gICAgICBsZXQgYnl0ZXNfYXJlX3dyaXR0ZW4gPSBJbnQ2My4oIDw9ICkgYnl0ZXNfcmVjZWl2ZWQgZS53cml0ZXIuYnl0ZXNfd3JpdHRlbiBpblxuICAgICAgbGV0IGJ5dGVzX2FyZV90b29fb2xkID1cbiAgICAgICAgVGltZV9ucy5TcGFuLiggPiApIChUaW1lX25zLmRpZmYgbm93IHRpbWVfcmVjZWl2ZWQpIGUubWF4aW11bV9hZ2VcbiAgICAgIGluXG4gICAgICBpZiBieXRlc19hcmVfdG9vX29sZFxuICAgICAgdGhlbiBlLmJ5dGVzX3JlY2VpdmVkX2F0X25vd19taW51c19tYXhpbXVtX2FnZSA8LSBieXRlc19yZWNlaXZlZDtcbiAgICAgIGlmIGJ5dGVzX2FyZV93cml0dGVuIHx8IGJ5dGVzX2FyZV90b29fb2xkXG4gICAgICB0aGVuIChcbiAgICAgICAgaWdub3JlIChRdWV1ZS5kZXF1ZXVlX2V4biBlLmJ5dGVzX3JlY2VpdmVkX3F1ZXVlIDogSW50NjMudCk7XG4gICAgICAgIGlnbm9yZSAoUXVldWUuZGVxdWV1ZV9leG4gZS50aW1lc19yZWNlaXZlZF9xdWV1ZSA6IFRpbWVfbnMudCk7XG4gICAgICAgIHN5bmMgZSB+bm93KSlcbiAgOztcblxuICBtb2R1bGUgUGVyX3RpbWVfc291cmNlID0gc3RydWN0XG4gICAgdHlwZSB0ID0gd3JpdGVyIENoZWNrX2J1ZmZlcl9hZ2UnLnBlcl90aW1lX3NvdXJjZVxuXG4gICAgbGV0IHByb2Nlc3NfYWN0aXZlX2NoZWNrIGUgPVxuICAgICAgbGV0IG5vdyA9IFRpbWVfc291cmNlLm5vdyBlLndyaXRlci50aW1lX3NvdXJjZSBpblxuICAgICAgc3luYyBlIH5ub3c7XG4gICAgICBsZXQgYnl0ZXNfcmVjZWl2ZWQgPSBlLndyaXRlci5ieXRlc19yZWNlaXZlZCBpblxuICAgICAgbGV0IGJ5dGVzX3dyaXR0ZW4gPSBlLndyaXRlci5ieXRlc193cml0dGVuIGluXG4gICAgICBpZiBJbnQ2My5PLihieXRlc19yZWNlaXZlZCA+IGUuYnl0ZXNfc2VlbilcbiAgICAgIHRoZW4gKFxuICAgICAgICBlLmJ5dGVzX3NlZW4gPC0gYnl0ZXNfcmVjZWl2ZWQ7XG4gICAgICAgIGlmIEludDYzLk8uKGJ5dGVzX3JlY2VpdmVkID4gYnl0ZXNfd3JpdHRlbilcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgUXVldWUuZW5xdWV1ZSBlLmJ5dGVzX3JlY2VpdmVkX3F1ZXVlIGUud3JpdGVyLmJ5dGVzX3JlY2VpdmVkO1xuICAgICAgICAgIFF1ZXVlLmVucXVldWUgZS50aW1lc19yZWNlaXZlZF9xdWV1ZSBub3cpKTtcbiAgICAgIGxldCB0b29fb2xkID0gSW50NjMuTy4oZS5ieXRlc19yZWNlaXZlZF9hdF9ub3dfbWludXNfbWF4aW11bV9hZ2UgPiBieXRlc193cml0dGVuKSBpblxuICAgICAgbWF0Y2ggSXZhci5pc19mdWxsIGUudG9vX29sZCwgdG9vX29sZCB3aXRoXG4gICAgICB8IHRydWUsIHRydWUgfCBmYWxzZSwgZmFsc2UgLT4gKClcbiAgICAgIHwgdHJ1ZSwgZmFsc2UgLT4gZS50b29fb2xkIDwtIEl2YXIuY3JlYXRlICgpXG4gICAgICB8IGZhbHNlLCB0cnVlIC0+XG4gICAgICAgIEl2YXIuZmlsbF9leG4gZS50b29fb2xkICgpO1xuICAgICAgICBsZXQgd3JpdGVyID0gZS53cml0ZXIgaW5cbiAgICAgICAgKCogW01vbml0b3Iuc2VuZF9leG5dIGVucXVldWVzIGpvYnMgYnV0IGRvZXMgbm90IHJ1biB1c2VyIGNvZGUsIGFuZCBzbyBjYW5ub3RcbiAgICAgICAgICAgbW9kaWZ5IFtlXS4gKilcbiAgICAgICAgTW9uaXRvci5zZW5kX2V4blxuICAgICAgICAgIGUud3JpdGVyLm1vbml0b3JcbiAgICAgICAgICAoRXhuLmNyZWF0ZV9zXG4gICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgICBcIndyaXRlciBidWZmZXIgaGFzIGRhdGEgb2xkZXIgdGhhblwiXG4gICAgICAgICAgICAgICAgIH5tYXhpbXVtX2FnZTooZS5tYXhpbXVtX2FnZSA6IFRpbWVfbnMuU3Bhbi50KVxuICAgICAgICAgICAgICAgICB+YmVnaW5uaW5nX29mX2J1ZmZlcjpcbiAgICAgICAgICAgICAgICAgICAoQmlnc3RyaW5nLnRvX3N0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgIHdyaXRlci5idWZcbiAgICAgICAgICAgICAgICAgICAgICB+cG9zOjBcbiAgICAgICAgICAgICAgICAgICAgICB+bGVuOihJbnQubWluIDEwMjQgKEJpZ3N0cmluZy5sZW5ndGggd3JpdGVyLmJ1ZikpXG4gICAgICAgICAgICAgICAgICAgICA6IHN0cmluZylcbiAgICAgICAgICAgICAgICAgKHdyaXRlciA6IHdyaXRlcildKVxuICAgIDs7XG5cbiAgICBsZXQgY3JlYXRlICgpID0geyBhY3RpdmVfY2hlY2tzID0gQmFnLmNyZWF0ZSAoKTsgY2xvc2VkID0gSXZhci5jcmVhdGUgKCkgfVxuICAgIGxldCBjaGVjayB0ID0gQmFnLml0ZXIgdC5hY3RpdmVfY2hlY2tzIH5mOnByb2Nlc3NfYWN0aXZlX2NoZWNrXG5cbiAgICBsZXQgaW50ZXJuYWxfY2hlY2tfbm93X2Zvcl91bml0X3Rlc3QgdCB+Y2hlY2tfaW52YXJpYW50cyA9XG4gICAgICBpZiBjaGVja19pbnZhcmlhbnRzIHRoZW4gQmFnLml0ZXIgdC5hY3RpdmVfY2hlY2tzIH5mOmVsdF9pbnZhcmlhbnQ7XG4gICAgICBjaGVjayB0XG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIFRpbWVfc291cmNlX2tleSA9IEhhc2hhYmxlLk1ha2VfcGxhaW4gKHN0cnVjdFxuICAgIHR5cGUgdCA9IFRpbWVfc291cmNlLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gVGltZV9zb3VyY2UuSWQuaGFzaF9mb2xkX3Qgc3RhdGUgKFRpbWVfc291cmNlLmlkIHQpXG4gICAgbGV0IGhhc2ggdCA9IFRpbWVfc291cmNlLklkLmhhc2ggKFRpbWVfc291cmNlLmlkIHQpXG4gICAgbGV0IGNvbXBhcmUgdDEgdDIgPSBUaW1lX3NvdXJjZS5JZC5jb21wYXJlIChUaW1lX3NvdXJjZS5pZCB0MSkgKFRpbWVfc291cmNlLmlkIHQyKVxuICBlbmQpXG5cbiAgKCogW2J5X3RpbWVfc291cmNlXSBob2xkcyB0aGUgc2V0IG9mIFtQZXJfdGltZV9zb3VyY2UudF0ncyB3aXRoIG5vbmVtcHR5IFthY3RpdmVfY2hlY2tzXS4gKilcbiAgbGV0IGJ5X3RpbWVfc291cmNlIDogUGVyX3RpbWVfc291cmNlLnQgVGltZV9zb3VyY2Vfa2V5LlRhYmxlLnQgPVxuICAgIFRpbWVfc291cmNlX2tleS5UYWJsZS5jcmVhdGUgKClcbiAgOztcblxuICBtb2R1bGUgSW50ZXJuYWxfZm9yX3VuaXRfdGVzdCA9IHN0cnVjdFxuICAgIGxldCBudW1fYWN0aXZlX2NoZWNrc19mb3IgdGltZV9zb3VyY2UgPVxuICAgICAgT3B0aW9uLm1hcCAoSGFzaHRibC5maW5kIGJ5X3RpbWVfc291cmNlIHRpbWVfc291cmNlKSB+ZjooZnVuIHB0IC0+XG4gICAgICAgIEJhZy5sZW5ndGggcHQuYWN0aXZlX2NoZWNrcylcbiAgICA7O1xuXG4gICAgbGV0IGNoZWNrX25vdyB+Y2hlY2tfaW52YXJpYW50cyB+dGltZV9zb3VyY2UgPVxuICAgICAgUGVyX3RpbWVfc291cmNlLmludGVybmFsX2NoZWNrX25vd19mb3JfdW5pdF90ZXN0XG4gICAgICAgIChIYXNodGJsLmZpbmRfZXhuIGJ5X3RpbWVfc291cmNlIHRpbWVfc291cmNlKVxuICAgICAgICB+Y2hlY2tfaW52YXJpYW50c1xuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBjcmVhdGUgd3JpdGVyIH5tYXhpbXVtX2FnZSA9XG4gICAgbWF0Y2ggbWF4aW11bV9hZ2Ugd2l0aFxuICAgIHwgYFVubGltaXRlZCAtPiBOb25lXG4gICAgfCBgQXRfbW9zdCBtYXhpbXVtX2FnZSAtPlxuICAgICAgbGV0IHRpbWVfc291cmNlID0gd3JpdGVyLnRpbWVfc291cmNlIGluXG4gICAgICBsZXQgZm9yX3RoaXNfdGltZV9zb3VyY2UgPVxuICAgICAgICBIYXNodGJsLmZpbmRfb3JfYWRkIGJ5X3RpbWVfc291cmNlIHRpbWVfc291cmNlIH5kZWZhdWx0OihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgcHQgPSBQZXJfdGltZV9zb3VyY2UuY3JlYXRlICgpIGluXG4gICAgICAgICAgVGltZV9zb3VyY2UuZXZlcnlcbiAgICAgICAgICAgIHRpbWVfc291cmNlXG4gICAgICAgICAgICBUaW1lX25zLlNwYW4uc2Vjb25kXG4gICAgICAgICAgICB+c3RvcDooSXZhci5yZWFkIHB0LmNsb3NlZClcbiAgICAgICAgICAgIH5jb250aW51ZV9vbl9lcnJvcjpmYWxzZVxuICAgICAgICAgICAgKGZ1biAoKSAtPiBQZXJfdGltZV9zb3VyY2UuY2hlY2sgcHQpO1xuICAgICAgICAgIHB0KVxuICAgICAgaW5cbiAgICAgIFNvbWVcbiAgICAgICAgKEJhZy5hZGRcbiAgICAgICAgICAgZm9yX3RoaXNfdGltZV9zb3VyY2UuYWN0aXZlX2NoZWNrc1xuICAgICAgICAgICB7IHdyaXRlclxuICAgICAgICAgICA7IGJ5dGVzX3JlY2VpdmVkX3F1ZXVlID0gUXVldWUuY3JlYXRlICgpXG4gICAgICAgICAgIDsgdGltZXNfcmVjZWl2ZWRfcXVldWUgPSBRdWV1ZS5jcmVhdGUgKClcbiAgICAgICAgICAgOyBtYXhpbXVtX2FnZSA9IFRpbWVfbnMuU3Bhbi5vZl9zcGFuX2Zsb2F0X3JvdW5kX25lYXJlc3QgbWF4aW11bV9hZ2VcbiAgICAgICAgICAgOyBieXRlc19zZWVuID0gSW50NjMuemVyb1xuICAgICAgICAgICA7IGJ5dGVzX3JlY2VpdmVkX2F0X25vd19taW51c19tYXhpbXVtX2FnZSA9IEludDYzLnplcm9cbiAgICAgICAgICAgOyB0b29fb2xkID0gSXZhci5jcmVhdGUgKClcbiAgICAgICAgICAgOyBmb3JfdGhpc190aW1lX3NvdXJjZVxuICAgICAgICAgICB9KVxuICA7O1xuXG4gIGxldCBkZXN0cm95IHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBlbHQgLT5cbiAgICAgIGxldCB0ID0gQmFnLkVsdC52YWx1ZSBlbHQgaW5cbiAgICAgIGxldCBwZXJfdGltZV9zb3VyY2UgPSB0LmZvcl90aGlzX3RpbWVfc291cmNlIGluXG4gICAgICBCYWcucmVtb3ZlIHBlcl90aW1lX3NvdXJjZS5hY3RpdmVfY2hlY2tzIGVsdDtcbiAgICAgIGlmIEJhZy5pc19lbXB0eSBwZXJfdGltZV9zb3VyY2UuYWN0aXZlX2NoZWNrc1xuICAgICAgdGhlbiAoXG4gICAgICAgIEhhc2h0YmwucmVtb3ZlIGJ5X3RpbWVfc291cmNlIHQud3JpdGVyLnRpbWVfc291cmNlO1xuICAgICAgICBJdmFyLmZpbGxfaWZfZW1wdHkgcGVyX3RpbWVfc291cmNlLmNsb3NlZCAoKSlcbiAgOztcblxuICBsZXQgdG9vX29sZCB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gRGVmZXJyZWQubmV2ZXIgKClcbiAgICB8IFNvbWUgZWx0IC0+IEl2YXIucmVhZCAoQmFnLkVsdC52YWx1ZSBlbHQpLnRvb19vbGRcbiAgOztcbmVuZFxuXG5sZXQgZmx1c2hlZF9vcl9mYWlsZWRfd2l0aF9yZXN1bHQgdCA9XG4gIG1hdGNoIHQuYmFja2luZ19vdXRfY2hhbm5lbCB3aXRoXG4gIHwgU29tZSBiYWNraW5nX291dF9jaGFubmVsIC0+XG4gICAgQmFja2luZ19vdXRfY2hhbm5lbC5mbHVzaCBiYWNraW5nX291dF9jaGFubmVsO1xuICAgIHJldHVybiAoRmx1c2hfcmVzdWx0LkZsdXNoZWQgKFRpbWVfc291cmNlLm5vdyB0LnRpbWVfc291cmNlKSlcbiAgfCBOb25lIC0+XG4gICAgaWYgSW50NjMuTy4odC5ieXRlc193cml0dGVuID0gdC5ieXRlc19yZWNlaXZlZClcbiAgICB0aGVuIHJldHVybiAoRmx1c2hfcmVzdWx0LkZsdXNoZWQgKFRpbWVfc291cmNlLm5vdyB0LnRpbWVfc291cmNlKSlcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIHQuYmFja2dyb3VuZF93cml0ZXJfc3RhdGUgd2l0aFxuICAgICAgfCBgU3RvcHBlZF9wZXJtYW5lbnRseSBFcnJvciAtPiByZXR1cm4gRmx1c2hfcmVzdWx0LkVycm9yXG4gICAgICB8IGBTdG9wcGVkX3Blcm1hbmVudGx5IENsb3NlZCAtPiByZXR1cm4gRmx1c2hfcmVzdWx0LkZvcmNlX2Nsb3NlZFxuICAgICAgfCBgU3RvcHBlZF9wZXJtYW5lbnRseSBDb25zdW1lcl9sZWZ0IC0+IHJldHVybiBGbHVzaF9yZXN1bHQuQ29uc3VtZXJfbGVmdFxuICAgICAgfCBgUnVubmluZyB8IGBOb3RfcnVubmluZyAtPlxuICAgICAgICBpZiBJdmFyLmlzX2Z1bGwgdC5jbG9zZV9maW5pc2hlZFxuICAgICAgICB0aGVuIERlZmVycmVkLnJldHVybiBGbHVzaF9yZXN1bHQuRXJyb3JcbiAgICAgICAgZWxzZVxuICAgICAgICAgIERlZmVycmVkLmNyZWF0ZSAoZnVuIGl2YXIgLT4gUXVldWUuZW5xdWV1ZSB0LmZsdXNoZXMgKGl2YXIsIHQuYnl0ZXNfcmVjZWl2ZWQpKSlcbjs7XG5cbmxldCBlYWdlcl9tYXAgdCB+ZiA9XG4gIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgdFxuICB0aGVuIHJldHVybiAoZiAoRGVmZXJyZWQudmFsdWVfZXhuIHQpKVxuICBlbHNlIERlZmVycmVkLm1hcCB0IH5mXG47O1xuXG5sZXQgZWFnZXJfYmluZCB0IH5mID1cbiAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCB0IHRoZW4gZiAoRGVmZXJyZWQudmFsdWVfZXhuIHQpIGVsc2UgRGVmZXJyZWQuYmluZCB0IH5mXG47O1xuXG5sZXQgZmx1c2hlZF9vcl9mYWlsZWRfdW5pdCB0ID0gZWFnZXJfbWFwIChmbHVzaGVkX29yX2ZhaWxlZF93aXRoX3Jlc3VsdCB0KSB+ZjppZ25vcmVcblxubGV0IGZsdXNoZWRfdGltZV9ucyB0ID1cbiAgZWFnZXJfYmluZCAoZmx1c2hlZF9vcl9mYWlsZWRfd2l0aF9yZXN1bHQgdCkgfmY6KGZ1bmN0aW9uXG4gICAgfCBGbHVzaGVkIHQgLT4gRGVmZXJyZWQucmV0dXJuIHRcbiAgICB8IEVycm9yIHwgQ29uc3VtZXJfbGVmdCB8IEZvcmNlX2Nsb3NlZCAtPiBEZWZlcnJlZC5uZXZlciAoKSlcbjs7XG5cbmxldCBmbHVzaGVkX3RpbWUgdCA9IGVhZ2VyX21hcCAoZmx1c2hlZF90aW1lX25zIHQpIH5mOlRpbWVfbnMudG9fdGltZV9mbG9hdF9yb3VuZF9uZWFyZXN0XG5cbmxldCBmbHVzaGVkIHQgPVxuICAoKiBldmVuIHRob3VnaCB3ZSBkb24ndCBwcm9taXNlIGFueSBlYWdlcm5lc3MsIHRoZXJlIGFyZSB0ZXN0cyBpbiB0aGUgdHJlZVxuICAgICB0aGF0IGRlcGVuZCBvbiBpdCAqKVxuICBlYWdlcl9tYXAgKGZsdXNoZWRfdGltZV9ucyB0KSB+ZjooaWdub3JlIDogVGltZV9ucy50IC0+IHVuaXQpXG47O1xuXG5sZXQgc2V0X2JhY2tpbmdfb3V0X2NoYW5uZWwgdCBiYWNraW5nX291dF9jaGFubmVsID1cbiAgdC5iYWNraW5nX291dF9jaGFubmVsIDwtIFNvbWUgYmFja2luZ19vdXRfY2hhbm5lbFxuOztcblxubGV0IHNldF9zeW5jaHJvbm91c19iYWNraW5nX291dF9jaGFubmVsIHQgYmFja2luZ19vdXRfY2hhbm5lbCA9XG4gIGxldCByZWMgd2FpdF91bnRpbF9ub19ieXRlc190b193cml0ZSAoKSA9XG4gICAgaWYgYnl0ZXNfdG9fd3JpdGUgdCA9IDBcbiAgICB0aGVuIChcbiAgICAgIHNldF9iYWNraW5nX291dF9jaGFubmVsIHQgYmFja2luZ19vdXRfY2hhbm5lbDtcbiAgICAgIHJldHVybiAoKSlcbiAgICBlbHNlIChcbiAgICAgIGxldCViaW5kICgpID0gZmx1c2hlZCB0IGluXG4gICAgICB3YWl0X3VudGlsX25vX2J5dGVzX3RvX3dyaXRlICgpKVxuICBpblxuICB3YWl0X3VudGlsX25vX2J5dGVzX3RvX3dyaXRlICgpXG47O1xuXG5sZXQgc2V0X3N5bmNocm9ub3VzX291dF9jaGFubmVsIHQgb3V0X2NoYW5uZWwgPVxuICBzZXRfc3luY2hyb25vdXNfYmFja2luZ19vdXRfY2hhbm5lbCB0IChCYWNraW5nX291dF9jaGFubmVsLm9mX291dF9jaGFubmVsIG91dF9jaGFubmVsKVxuOztcblxubGV0IHVzaW5nX3N5bmNocm9ub3VzX2JhY2tpbmdfb3V0X2NoYW5uZWwgdCA9IE9wdGlvbi5pc19zb21lIHQuYmFja2luZ19vdXRfY2hhbm5lbFxuXG5sZXQgY2xlYXJfc3luY2hyb25vdXNfb3V0X2NoYW5uZWwgdCA9XG4gIGlmIGlzX3NvbWUgdC5iYWNraW5nX291dF9jaGFubmVsXG4gIHRoZW4gKFxuICAgIGFzc2VydCAoYnl0ZXNfdG9fd3JpdGUgdCA9IDApO1xuICAgIHQuYmFja2luZ19vdXRfY2hhbm5lbCA8LSBOb25lKVxuOztcblxubGV0IHdpdGhfc3luY2hyb25vdXNfYmFja2luZ19vdXRfY2hhbm5lbCB0IGJhY2tpbmdfb3V0X2NoYW5uZWwgfmYgPVxuICBsZXQgc2F2ZWRfYmFja2luZ19vdXRfY2hhbm5lbCA9IHQuYmFja2luZ19vdXRfY2hhbm5lbCBpblxuICAoKiBUaGlzIGNvZGUgd2lsbCBmbHVzaCBhIGJpdCBtb3JlIGVhZ2VybHkgdGhhbiBpdCBuZWVkcyB0byBpZlxuICAgICBbd2l0aF9zeW5jaHJvbm91c19iYWNraW5nX291dF9jaGFubmVsIHQgb2NdIGlzIGNhbGxlZCByZWN1cnNpdmVseSBvbiB0aGUgc2FtZSBbdF0gYW5kXG4gICAgIFtvY10uICBUaGUgZmx1c2ggaXMgY2F1c2VkIGJ5IFtzZXRfc3luY2hyb25vdXNfYmFja2luZ19vdXRfY2hhbm5lbF0uICBJbiB0aGVvcnkgdGhpc1xuICAgICBjb3VsZCBoYXBwZW4gYnV0IGluIHByYWN0aWNlIGlzIGV4Y2VlZGluZ2x5IHVubGlrZWx5LiAqKVxuICBNb25pdG9yLnByb3RlY3RcbiAgICB+cnVuOmBTY2hlZHVsZVxuICAgIChmdW4gKCkgLT5cbiAgICAgIGxldCViaW5kICgpID0gc2V0X3N5bmNocm9ub3VzX2JhY2tpbmdfb3V0X2NoYW5uZWwgdCBiYWNraW5nX291dF9jaGFubmVsIGluXG4gICAgICBmICgpKVxuICAgIH5maW5hbGx5OihmdW4gKCkgLT5cbiAgICAgIHQuYmFja2luZ19vdXRfY2hhbm5lbCA8LSBzYXZlZF9iYWNraW5nX291dF9jaGFubmVsO1xuICAgICAgcmV0dXJuICgpKVxuOztcblxubGV0IHdpdGhfc3luY2hyb25vdXNfb3V0X2NoYW5uZWwgdCBvdXRfY2hhbm5lbCB+ZiA9XG4gIHdpdGhfc3luY2hyb25vdXNfYmFja2luZ19vdXRfY2hhbm5lbFxuICAgIHRcbiAgICB+ZlxuICAgIChCYWNraW5nX291dF9jaGFubmVsLm9mX291dF9jaGFubmVsIG91dF9jaGFubmVsKVxuOztcblxubGV0IHNldF9mZCB0IGZkID1cbiAgbGV0JW1hcCAoKSA9IGZsdXNoZWQgdCBpblxuICB0LmZkIDwtIGZkXG47O1xuXG5sZXQgY29uc3VtZXJfbGVmdCB0ID0gSXZhci5yZWFkIHQuY29uc3VtZXJfbGVmdFxubGV0IGNsb3NlX2ZpbmlzaGVkIHQgPSBJdmFyLnJlYWQgdC5jbG9zZV9maW5pc2hlZFxubGV0IGNsb3NlX3N0YXJ0ZWQgdCA9IEl2YXIucmVhZCB0LmNsb3NlX3N0YXJ0ZWRcblxubGV0IGlzX2Nsb3NlZCB0ID1cbiAgbWF0Y2ggdC5jbG9zZV9zdGF0ZSB3aXRoXG4gIHwgYE9wZW4gLT4gZmFsc2VcbiAgfCBgQ2xvc2VkIHwgYENsb3NlZF9hbmRfZmx1c2hpbmcgLT4gdHJ1ZVxuOztcblxubGV0IGlzX29wZW4gdCA9IG5vdCAoaXNfY2xvc2VkIHQpXG5sZXQgd3JpdGVyc190b19mbHVzaF9hdF9zaHV0ZG93biA6IHQgQmFnLnQgPSBCYWcuY3JlYXRlICgpXG5cbmxldCBldmFsX2ZvcmNlID9mb3JjZSB0ID1cbiAgbWF0Y2ggZm9yY2Ugd2l0aFxuICB8IFNvbWUgZmMgLT4gZmNcbiAgfCBOb25lIC0+XG4gICAgKCogV2UgdXNlZCB0byB1c2UgW2FmdGVyIChzZWMgNS4pXSBhcyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgW2ZvcmNlXSBmb3IgYWxsIGtpbmRzXG4gICAgICAgb2YgdW5kZXJseWluZyBmZHMuICBUaGlzIHdhcyBwcm9ibGVtYXRpYywgYmVjYXVzZSBpdCBzaWxlbnRseSBjYXVzZWQgZGF0YSBpblxuICAgICAgIHRoZSB3cml0ZXIncyBidWZmZXIgdG8gYmUgZHJvcHBlZCB3aGVuIGl0IGtpY2tlZCBpbi4gIFdlIGNhcmUgYWJvdXQgZGF0YVxuICAgICAgIGdldHRpbmcgb3V0IG9ubHkgZm9yIHRoZSBmaWxlcywgd2hlbiB3ZSB3YW50IHRvIGdldCBkYXRhIHRvIGRpc2suICBXaGVuIHdlXG4gICAgICAgY2xvc2Ugc29ja2V0IHdyaXRlcnMsIHdlIHVzdWFsbHkganVzdCB3YW50IHRvIGRyb3AgdGhlIGNvbm5lY3Rpb24sIHNvIHVzaW5nXG4gICAgICAgW2FmdGVyIChzZWMgNS4pXSAgbWFrZXMgc2Vuc2UuICopXG4gICAgKG1hdGNoIEZkLmtpbmQgdC5mZCB3aXRoXG4gICAgIHwgRmlsZSAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgICB8IENoYXIgfCBGaWZvIHwgU29ja2V0IF8gLT4gVGltZV9zb3VyY2UuYWZ0ZXIgdC50aW1lX3NvdXJjZSAoVGltZV9ucy5TcGFuLm9mX3NlYyA1LikpXG47O1xuXG5sZXQgZmluYWxfZmx1c2ggP2ZvcmNlIHQgPVxuICBsZXQgcHJvZHVjZXJzX2ZsdXNoZWQgPVxuICAgICgqIE5vdGUgdGhhdCBlYWNoIGVsZW1lbnQgb2YgW3Byb2R1Y2Vyc190b19mbHVzaF9hdF9jbG9zZV0gY2hlY2tzIHRoYXQgdGhlIHVwc3RyZWFtXG4gICAgICAgcHJvZHVjZXIgaXMgZmx1c2hlZCwgd2hpY2ggaW5jbHVkZXMgY2hlY2tpbmcgdGhhdCBbdF0gaXRzZWxmIGlzIGZsdXNoZWQgb25jZSB0aGVcbiAgICAgICBwcm9kdWNlciBoYXMgd3JpdHRlbiBldmVyeXRoaW5nIHRvIFt0XS4gIFNvLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgW2ZsdXNoZWQgdF1cbiAgICAgICBhZnRlciB0aGUgcHJvZHVjZXIgaXMgZmx1c2hlZC4gKilcbiAgICBEZWZlcnJlZC5MaXN0Lml0ZXJcbiAgICAgIH5ob3c6YFBhcmFsbGVsXG4gICAgICB+ZjooZnVuIGYgLT4gZiAoKSlcbiAgICAgIChCYWcudG9fbGlzdCB0LnByb2R1Y2Vyc190b19mbHVzaF9hdF9jbG9zZSlcbiAgaW5cbiAgbGV0IGZvcmNlID0gZXZhbF9mb3JjZSA/Zm9yY2UgdCBpblxuICBEZWZlcnJlZC5hbnlfdW5pdFxuICAgIFsgKCogSWYgdGhlIGNvbnN1bWVyIGxlYXZlcywgdGhlcmUncyBubyBtb3JlIHdyaXRpbmcgd2UgY2FuIGRvLiAqKVxuICAgICAgY29uc3VtZXJfbGVmdCB0XG4gICAgOyBEZWZlcnJlZC5hbGxfdW5pdCBbIHByb2R1Y2Vyc19mbHVzaGVkOyBmbHVzaGVkIHQgXVxuICAgIDsgZm9yY2VcbiAgICA7ICgqIFRoZSBidWZmZXItYWdlIGNoZWNrIG1pZ2h0IGZpcmUgd2hpbGUgd2UncmUgd2FpdGluZy4gKilcbiAgICAgIENoZWNrX2J1ZmZlcl9hZ2UudG9vX29sZCAoTGF6eS5mb3JjZSB0LmNoZWNrX2J1ZmZlcl9hZ2UpXG4gICAgXVxuOztcblxubGV0IHN0b3BfYmFja2dyb3VuZF93cml0ZXJfaWZfbm90X3J1bm5pbmdfbm93IHQgPVxuICBtYXRjaCB0LmJhY2tncm91bmRfd3JpdGVyX3N0YXRlIHdpdGhcbiAgfCBgTm90X3J1bm5pbmcgLT5cbiAgICB0LmJhY2tncm91bmRfd3JpdGVyX3N0YXRlIDwtIGBTdG9wcGVkX3Blcm1hbmVudGx5IENsb3NlZDtcbiAgICBJdmFyLmZpbGxfaWZfZW1wdHkgdC5iYWNrZ3JvdW5kX3dyaXRlcl9zdG9wcGVkICgpXG4gIHwgXyAtPiAoKVxuOztcblxubGV0IHN0b3BfYmFja2dyb3VuZF93cml0ZXJfYW5kX2Nsb3NlX2ZkIHQgPVxuICAoKiBpdCdzIGltcG9ydGFudCB0aGF0IHdlIHNldCBbY2xvc2Vfc3RhdGUgPSBgQ2xvc2VkXSwgb3RoZXJ3aXNlIHRoZSBiYWNrZ3JvdW5kIHdyaXRlclxuICAgICB3b24ndCBzdG9wIChzZWUgW3dyaXRlX2ZpbmlzaGVkXSkgKilcbiAgKG1hdGNoIHQuY2xvc2Vfc3RhdGUgd2l0aFxuICAgfCBgQ2xvc2VkIC0+ICgpXG4gICB8IGBDbG9zZWRfYW5kX2ZsdXNoaW5nIHwgYE9wZW4gLT4gYXNzZXJ0IGZhbHNlKTtcbiAgc3RvcF9iYWNrZ3JvdW5kX3dyaXRlcl9pZl9ub3RfcnVubmluZ19ub3cgdDtcbiAgKCogY2xvc2luZyB0aGUgZmQgKmNhdXNlcyogdGhlIGJhY2tncm91bmQgd3JpdGVyIHRvIGJlIHN0b3BwZWQgKHRoZSBjYWxsIHRvIFtyZWFkeV90b11cbiAgICAgdW5ibG9ja3MgZHVlIHRvIHRoaXMpICopXG4gIGxldCViaW5kICgpID0gVW5peC5jbG9zZSB0LmZkIGluXG4gICgqIFtiYWNrZ3JvdW5kX3dyaXRlcl9zdG9wcGVkXSBpcyBwcmV0dHkgbXVjaCBhbHdheXMgZGV0ZXJtaW5lZCBoZXJlIGJlY2F1c2VcbiAgICAgW1VuaXguY2xvc2VdIGlzIG11Y2ggc2xvd2VyLCBidXQgdGhlb3JldGljYWxseSBpdCdzIHN0aWxsIG5lY2Vzc2FyeSBpbiBjYXNlXG4gICAgIHRoZSBvcmRlcmluZyBjaGFuZ2VzLiAqKVxuICBJdmFyLnJlYWQgdC5iYWNrZ3JvdW5kX3dyaXRlcl9zdG9wcGVkXG47O1xuXG5sZXQgZG9fY2xvc2Vfbm9mbHVzaCB0ID1cbiAgbWF0Y2ggdC5jbG9zZV9zdGF0ZSB3aXRoXG4gIHwgYENsb3NlZF9hbmRfZmx1c2hpbmcgfCBgT3BlbiAtPlxuICAgIHQuY2xvc2Vfc3RhdGUgPC0gYENsb3NlZDtcbiAgICBJdmFyLmZpbGxfaWZfZW1wdHkgdC5jbG9zZV9zdGFydGVkICgpO1xuICAgIGlmIExhenkuaXNfdmFsIHQuY2hlY2tfYnVmZmVyX2FnZVxuICAgIHRoZW4gQ2hlY2tfYnVmZmVyX2FnZS5kZXN0cm95IChmb3JjZSB0LmNoZWNrX2J1ZmZlcl9hZ2UpO1xuICAgIChtYXRjaCB0LmZsdXNoX2F0X3NodXRkb3duX2VsdCB3aXRoXG4gICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgfCBTb21lIGVsdCAtPiBCYWcucmVtb3ZlIHdyaXRlcnNfdG9fZmx1c2hfYXRfc2h1dGRvd24gZWx0KTtcbiAgICBzdG9wX2JhY2tncm91bmRfd3JpdGVyX2FuZF9jbG9zZV9mZCB0ID4+PiBmdW4gKCkgLT4gSXZhci5maWxsX2V4biB0LmNsb3NlX2ZpbmlzaGVkICgpXG4gIHwgYENsb3NlZCAtPiAoKVxuOztcblxubGV0IGNsb3NlX2ludGVybmFsIH5mbHVzaCB0ID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJXcml0ZXIuY2xvc2VcIiB0IFslc2V4cF9vZjogdF07XG4gIG1hdGNoIGZsdXNoIHdpdGhcbiAgfCBgTm9fZmx1c2ggLT5cbiAgICBkb19jbG9zZV9ub2ZsdXNoIHQ7XG4gICAgY2xvc2VfZmluaXNoZWQgdFxuICB8IGBGbHVzaCBmb3JjZSAtPlxuICAgIChtYXRjaCB0LmNsb3NlX3N0YXRlIHdpdGhcbiAgICAgfCBgQ2xvc2VkX2FuZF9mbHVzaGluZyB8IGBDbG9zZWQgLT4gKClcbiAgICAgfCBgT3BlbiAtPlxuICAgICAgIHQuY2xvc2Vfc3RhdGUgPC0gYENsb3NlZF9hbmRfZmx1c2hpbmc7XG4gICAgICAgSXZhci5maWxsX2V4biB0LmNsb3NlX3N0YXJ0ZWQgKCk7XG4gICAgICAgZmluYWxfZmx1c2ggdCA/Zm9yY2UgPj4+IGZ1biAoKSAtPiBkb19jbG9zZV9ub2ZsdXNoIHQpO1xuICAgIGNsb3NlX2ZpbmlzaGVkIHRcbjs7XG5cbmxldCBjbG9zZSA/Zm9yY2VfY2xvc2UgdCA9IGNsb3NlX2ludGVybmFsIH5mbHVzaDooYEZsdXNoIGZvcmNlX2Nsb3NlKSB0XG5sZXQgY2xvc2Vfbm9mbHVzaCB0ID0gY2xvc2VfaW50ZXJuYWwgfmZsdXNoOmBOb19mbHVzaCB0XG5cbmxldCAoKSA9XG4gIFNodXRkb3duLmF0X3NodXRkb3duIChmdW4gKCkgLT5cbiAgICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJXcml0ZXIuYXRfc2h1dGRvd25cIjtcbiAgICBEZWZlcnJlZC5MaXN0Lml0ZXJcbiAgICAgIH5ob3c6YFBhcmFsbGVsXG4gICAgICAoQmFnLnRvX2xpc3Qgd3JpdGVyc190b19mbHVzaF9hdF9zaHV0ZG93bilcbiAgICAgIH5mOihmdW4gdCAtPiBEZWZlcnJlZC5hbnlfdW5pdCBbIGZpbmFsX2ZsdXNoIHQ7IGNsb3NlX2ZpbmlzaGVkIHQgXSkpXG47O1xuXG5sZXQgZmlsbF9mbHVzaGVzIHsgYnl0ZXNfd3JpdHRlbjsgZmx1c2hlczsgdGltZV9zb3VyY2U7IF8gfSA9XG4gIGlmIG5vdCAoUXVldWUuaXNfZW1wdHkgZmx1c2hlcylcbiAgdGhlbiAoXG4gICAgbGV0IG5vdyA9IFRpbWVfc291cmNlLm5vdyB0aW1lX3NvdXJjZSBpblxuICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICBtYXRjaCBRdWV1ZS5wZWVrIGZsdXNoZXMgd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgKGl2YXIsIHopIC0+XG4gICAgICAgIGlmIEludDYzLih6IDw9IGJ5dGVzX3dyaXR0ZW4pXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIEl2YXIuZmlsbF9leG4gaXZhciAoRmx1c2hfcmVzdWx0LkZsdXNoZWQgbm93KTtcbiAgICAgICAgICBpZ25vcmUgKFF1ZXVlLmRlcXVldWUgZmx1c2hlcyA6IChGbHVzaF9yZXN1bHQudCBJdmFyLnQgKiBJbnQ2My50KSBvcHRpb24pO1xuICAgICAgICAgIGxvb3AgKCkpXG4gICAgaW5cbiAgICBsb29wICgpKVxuOztcblxubGV0IHN0b3BfcGVybWFuZW50bHkgdCAob3V0Y29tZSA6IFN0b3BfcmVhc29uLnQpID1cbiAgdC5iYWNrZ3JvdW5kX3dyaXRlcl9zdGF0ZSA8LSBgU3RvcHBlZF9wZXJtYW5lbnRseSBvdXRjb21lO1xuICBEZXF1ZS5jbGVhciB0LnNjaGVkdWxlZDtcbiAgdC5zY2hlZHVsZWRfYnl0ZXMgPC0gMDtcbiAgdC5idWYgPC0gQmlnc3RyaW5nLmNyZWF0ZSAwO1xuICB0LnNjaGVkdWxlZF9iYWNrIDwtIDA7XG4gIHQuYmFjayA8LSAwO1xuICBJdmFyLmZpbGxfaWZfZW1wdHkgdC5iYWNrZ3JvdW5kX3dyaXRlcl9zdG9wcGVkICgpO1xuICBRdWV1ZS5pdGVyIHQuZmx1c2hlcyB+ZjooZnVuIChpdmFyLCBfKSAtPlxuICAgIEl2YXIuZmlsbF9leG5cbiAgICAgIGl2YXJcbiAgICAgIChtYXRjaCBvdXRjb21lIHdpdGhcbiAgICAgICB8IEVycm9yIC0+IEZsdXNoX3Jlc3VsdC5FcnJvclxuICAgICAgIHwgQ29uc3VtZXJfbGVmdCAtPiBGbHVzaF9yZXN1bHQuQ29uc3VtZXJfbGVmdFxuICAgICAgIHwgQ2xvc2VkIC0+IEZsdXNoX3Jlc3VsdC5Gb3JjZV9jbG9zZWQpKTtcbiAgUXVldWUuY2xlYXIgdC5mbHVzaGVzXG47O1xuXG5sZXQgc3RvcHBlZF9wZXJtYW5lbnRseSB0ID0gSXZhci5yZWFkIHQuYmFja2dyb3VuZF93cml0ZXJfc3RvcHBlZFxuXG5sZXQgZGllIHQgc2V4cCA9XG4gIHN0b3BfcGVybWFuZW50bHkgdCBFcnJvcjtcbiAgcmFpc2VfcyBzZXhwXG47O1xuXG50eXBlIGJ1ZmZlcl9hZ2VfbGltaXQgPVxuICBbIGBBdF9tb3N0IG9mIFRpbWVfZmxvYXQuU3Bhbi50XG4gIHwgYFVubGltaXRlZFxuICBdXG5bQEBkZXJpdmluZyBiaW5faW8sIHNleHBdXG5cbmxldCBjcmVhdGVcbiAgP2J1Zl9sZW5cbiAgPyhzeXNjYWxsID0gYFBlcl9jeWNsZSlcbiAgP2J1ZmZlcl9hZ2VfbGltaXRcbiAgPyhyYWlzZV93aGVuX2NvbnN1bWVyX2xlYXZlcyA9IHRydWUpXG4gID8obGluZV9lbmRpbmcgPSBMaW5lX2VuZGluZy5Vbml4KVxuICA/dGltZV9zb3VyY2VcbiAgZmRcbiAgPVxuICBsZXQgdGltZV9zb3VyY2UgPVxuICAgIG1hdGNoIHRpbWVfc291cmNlIHdpdGhcbiAgICB8IFNvbWUgeCAtPiBUaW1lX3NvdXJjZS5yZWFkX29ubHkgeFxuICAgIHwgTm9uZSAtPiBUaW1lX3NvdXJjZS53YWxsX2Nsb2NrICgpXG4gIGluXG4gIGxldCBidWZmZXJfYWdlX2xpbWl0ID1cbiAgICBtYXRjaCBidWZmZXJfYWdlX2xpbWl0IHdpdGhcbiAgICB8IFNvbWUgeiAtPiB6XG4gICAgfCBOb25lIC0+XG4gICAgICAobWF0Y2ggRmQua2luZCBmZCB3aXRoXG4gICAgICAgfCBGaWxlIC0+IGBVbmxpbWl0ZWRcbiAgICAgICB8IENoYXIgfCBGaWZvIHwgU29ja2V0IF8gLT4gYEF0X21vc3QgKFRpbWVfZmxvYXQuU3Bhbi5vZl9taW4gMi4pKVxuICBpblxuICBsZXQgYnVmX2xlbiA9XG4gICAgbWF0Y2ggYnVmX2xlbiB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAoKiBUaGlzIGV4Y2VlZHMgdGhlIHZhbHVlIGJpZ3N0cmluZ191bml4X3N0dWJzLmMgc2V0cyBNX01NQVBfVEhSRVNIT0xEIHRvLiBBcyBhXG4gICAgICAgICByZXN1bHQsIHRoZXNlIGJ1ZmZlcnMgYXJlIGFsbG9jYXRlZCB1c2luZyBtbWFwLCBzbyB0aGV5IGFyZSByZXR1cm5lZCB0byB0aGUgT1NcbiAgICAgICAgIHdoZW4gT0NhbWwgR0NzIHRoZW0uIElmIHRoaXMgd2VyZSBsZXNzIHRoYW4gTV9NTUFQX1RIUkVTSE9MRCwgdGhlIGJ1ZmZlcnMgd291bGRcbiAgICAgICAgIGJlIGFsbG9jYXRlZCB3aXRoIGJyaywgc28gbWFsbG9jIG1pZ2h0IGhvbGQgb24gdG8gdGhlbSBldmVuIGFmdGVyIE9DYW1sIEdDcyB0aGVtLFxuICAgICAgICAgd2hpY2ggY291bGQgX2luY3JlYXNlXyBtZW1vcnkgdXNhZ2UgZm9yIHByb2dyYW1zIHRoYXQgY3JlYXRlIG1hbnkgc3VjaFxuICAgICAgICAgYnVmZmVycy4gKilcbiAgICAgIDY1ICogMTAyNCAqIDIgKCogbGFyZ2VzdCBvYnNlcnZlZCBzaW5nbGUgd3JpdGUgY2FsbCAqIDIgKilcbiAgICB8IFNvbWUgYnVmX2xlbiAtPlxuICAgICAgaWYgYnVmX2xlbiA8PSAwIHRoZW4gaW52YWxpZF9hcmcgXCJXcml0ZXIuY3JlYXRlOiBidWZfbGVuIDw9IDBcIiBlbHNlIGJ1Zl9sZW5cbiAgaW5cbiAgbGV0IGlkID0gSWQuY3JlYXRlICgpIGluXG4gIGxldCBtb25pdG9yID1cbiAgICBNb25pdG9yLmNyZWF0ZVxuICAgICAgKClcbiAgICAgID9uYW1lOihpZiBQcHhfaW5saW5lX3Rlc3RfbGliLmFtX3J1bm5pbmcgdGhlbiBTb21lIFwiV3JpdGVyLm1vbml0b3JcIiBlbHNlIE5vbmUpXG4gIGluXG4gIGxldCBpbm5lcl9tb25pdG9yID1cbiAgICBNb25pdG9yLmNyZWF0ZVxuICAgICAgKClcbiAgICAgID9uYW1lOihpZiBQcHhfaW5saW5lX3Rlc3RfbGliLmFtX3J1bm5pbmcgdGhlbiBTb21lIFwiV3JpdGVyLmlubmVyX21vbml0b3JcIiBlbHNlIE5vbmUpXG4gIGluXG4gIGxldCBjb25zdW1lcl9sZWZ0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IG9wZW5fZmxhZ3MgPSBGZC5zeXNjYWxsIGZkIChmdW4gZmlsZV9kZXNjciAtPiBDb3JlX3VuaXguZmNudGxfZ2V0ZmwgZmlsZV9kZXNjcikgaW5cbiAgbGV0IHQgPVxuICAgIHsgaWRcbiAgICA7IGZkXG4gICAgOyBzeXNjYWxsXG4gICAgOyBtb25pdG9yXG4gICAgOyBpbm5lcl9tb25pdG9yXG4gICAgOyBidWYgPSBCaWdzdHJpbmcuY3JlYXRlIGJ1Zl9sZW5cbiAgICA7IGJhY2sgPSAwXG4gICAgOyBzY2hlZHVsZWRfYmFjayA9IDBcbiAgICA7IHNjaGVkdWxlZCA9IERlcXVlLmNyZWF0ZSAoKVxuICAgIDsgc2NoZWR1bGVkX2J5dGVzID0gMFxuICAgIDsgYnl0ZXNfcmVjZWl2ZWQgPSBJbnQ2My56ZXJvXG4gICAgOyBieXRlc193cml0dGVuID0gSW50NjMuemVyb1xuICAgIDsgdGltZV9zb3VyY2VcbiAgICA7IGZsdXNoZXMgPSBRdWV1ZS5jcmVhdGUgKClcbiAgICA7IGJhY2tncm91bmRfd3JpdGVyX3N0YXRlID0gYE5vdF9ydW5uaW5nXG4gICAgOyBiYWNrZ3JvdW5kX3dyaXRlcl9zdG9wcGVkID0gSXZhci5jcmVhdGUgKClcbiAgICA7IGNsb3NlX3N0YXRlID0gYE9wZW5cbiAgICA7IGNsb3NlX2ZpbmlzaGVkID0gSXZhci5jcmVhdGUgKClcbiAgICA7IGNsb3NlX3N0YXJ0ZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgIDsgcHJvZHVjZXJzX3RvX2ZsdXNoX2F0X2Nsb3NlID0gQmFnLmNyZWF0ZSAoKVxuICAgIDsgZmx1c2hfYXRfc2h1dGRvd25fZWx0ID0gTm9uZVxuICAgIDsgY2hlY2tfYnVmZmVyX2FnZSA9IGxhenkgQ2hlY2tfYnVmZmVyX2FnZS5kdW1teVxuICAgIDsgY29uc3VtZXJfbGVmdFxuICAgIDsgcmFpc2Vfd2hlbl9jb25zdW1lcl9sZWF2ZXNcbiAgICA7IG9wZW5fZmxhZ3NcbiAgICA7IGxpbmVfZW5kaW5nXG4gICAgOyBiYWNraW5nX291dF9jaGFubmVsID0gTm9uZVxuICAgIH1cbiAgaW5cbiAgTW9uaXRvci5kZXRhY2hfYW5kX2l0ZXJfZXJyb3JzIGlubmVyX21vbml0b3IgfmY6KGZ1biAoZXhuIDogRXhuLnQpIC0+XG4gICAgTW9uaXRvci5zZW5kX2V4blxuICAgICAgbW9uaXRvclxuICAgICAgKEV4bi5jcmVhdGVfc1xuICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgIFwiV3JpdGVyIGVycm9yIGZyb20gaW5uZXJfbW9uaXRvclwiXG4gICAgICAgICAgICAgfl86KE1vbml0b3IuZXh0cmFjdF9leG4gZXhuIDogRXhuLnQpXG4gICAgICAgICAgICAgfndyaXRlcjoodCA6IHQpXSkpO1xuICB0LmNoZWNrX2J1ZmZlcl9hZ2UgPC0gbGF6eSAoQ2hlY2tfYnVmZmVyX2FnZS5jcmVhdGUgdCB+bWF4aW11bV9hZ2U6YnVmZmVyX2FnZV9saW1pdCk7XG4gIHQuZmx1c2hfYXRfc2h1dGRvd25fZWx0IDwtIFNvbWUgKEJhZy5hZGQgd3JpdGVyc190b19mbHVzaF9hdF9zaHV0ZG93biB0KTtcbiAgdFxuOztcblxubGV0IHNldF9idWZmZXJfYWdlX2xpbWl0IHQgbWF4aW11bV9hZ2UgPVxuICBpZiBMYXp5LmlzX3ZhbCB0LmNoZWNrX2J1ZmZlcl9hZ2VcbiAgdGhlbiBDaGVja19idWZmZXJfYWdlLmRlc3Ryb3kgKGZvcmNlIHQuY2hlY2tfYnVmZmVyX2FnZSk7XG4gIHQuY2hlY2tfYnVmZmVyX2FnZSA8LSBsYXp5IChDaGVja19idWZmZXJfYWdlLmNyZWF0ZSB0IH5tYXhpbXVtX2FnZSlcbjs7XG5cbmxldCBvZl9vdXRfY2hhbm5lbCBvYyBraW5kID0gY3JlYXRlIChGZC5vZl9vdXRfY2hhbm5lbCBvYyBraW5kKVxuXG5sZXQgY2FuX3dyaXRlIHQgPVxuICBtYXRjaCB0LmNsb3NlX3N0YXRlIHdpdGhcbiAgfCBgT3BlbiB8IGBDbG9zZWRfYW5kX2ZsdXNoaW5nIC0+IHRydWVcbiAgfCBgQ2xvc2VkIC0+IGZhbHNlXG47O1xuXG5sZXQgZW5zdXJlX2Nhbl93cml0ZSB0ID1cbiAgaWYgbm90IChjYW5fd3JpdGUgdCkgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcImF0dGVtcHQgdG8gdXNlIGNsb3NlZCB3cml0ZXJcIiB+XzoodCA6IHQpXVxuOztcblxubGV0IG9wZW5fZmlsZVxuICA/aW5mb1xuICA/KGFwcGVuZCA9IGZhbHNlKVxuICA/YnVmX2xlblxuICA/c3lzY2FsbFxuICA/KHBlcm0gPSAwbzY2NilcbiAgP2xpbmVfZW5kaW5nXG4gID90aW1lX3NvdXJjZVxuICBmaWxlXG4gID1cbiAgKCogV3JpdGluZyB0byBORlMgbmVlZHMgdGhlIFtgVHJ1bmNdIGZsYWcgdG8gYXZvaWQgbGVhdmluZyBleHRyYSBqdW5rIGF0IHRoZSBlbmQgb2ZcbiAgICAgYSBmaWxlLiAqKVxuICBsZXQgbW9kZSA9IFsgYFdyb25seTsgYENyZWF0IF0gaW5cbiAgbGV0IG1vZGUgPSAoaWYgYXBwZW5kIHRoZW4gYEFwcGVuZCBlbHNlIGBUcnVuYykgOjogbW9kZSBpblxuICBVbml4Lm9wZW5maWxlID9pbmZvIGZpbGUgfm1vZGUgfnBlcm1cbiAgPj58IGNyZWF0ZSA/YnVmX2xlbiA/c3lzY2FsbCA/bGluZV9lbmRpbmcgP3RpbWVfc291cmNlXG47O1xuXG5sZXQgd2l0aF9jbG9zZSB0IH5mID1cbiAgTW9uaXRvci5wcm90ZWN0XG4gICAgfnJ1bjpgU2NoZWR1bGVcbiAgICAoZnVuICgpIC0+XG4gICAgICBsZXQlYmluZCByZXMgPSBmICgpIGluXG4gICAgICBsZXQlbWFwICgpID0gZmluYWxfZmx1c2ggdCBpblxuICAgICAgcmVzKVxuICAgIH5maW5hbGx5OihmdW4gKCkgLT4gY2xvc2Vfbm9mbHVzaCB0KVxuOztcblxubGV0IHdpdGhfd3JpdGVyX2V4Y2x1c2l2ZSB0IGYgPVxuICBsZXQlYmluZCAoKSA9IFVuaXgubG9ja2YgdC5mZCBFeGNsdXNpdmUgaW5cbiAgTW9uaXRvci5wcm90ZWN0IH5ydW46YFNjaGVkdWxlIGYgfmZpbmFsbHk6KGZ1biAoKSAtPlxuICAgIGxldCVtYXAgKCkgPSBmbHVzaGVkIHQgaW5cbiAgICBVbml4LnVubG9ja2YgdC5mZClcbjs7XG5cbmxldCB3aXRoX2ZpbGVcbiAgP3Blcm1cbiAgP2FwcGVuZFxuICA/c3lzY2FsbFxuICA/KGV4Y2x1c2l2ZSA9IGZhbHNlKVxuICA/bGluZV9lbmRpbmdcbiAgP3RpbWVfc291cmNlXG4gIGZpbGVcbiAgfmZcbiAgPVxuICBsZXQlYmluZCB0ID0gb3Blbl9maWxlID9wZXJtID9hcHBlbmQgP3N5c2NhbGwgP2xpbmVfZW5kaW5nID90aW1lX3NvdXJjZSBmaWxlIGluXG4gIGxldCBwYXJlbnRfbW9uaXRvciA9IE1vbml0b3IuY3VycmVudCAoKSBpblxuICBsZXQgbW9uaXRvciA9IG1vbml0b3IgdCBpblxuICBNb25pdG9yLmRldGFjaF9hbmRfaXRlcl9lcnJvcnMgbW9uaXRvciB+ZjooZnVuIGV4biAtPlxuICAgIHVwb24gKGNsb3NlX25vZmx1c2ggdCkgKGZ1biAoKSAtPiBNb25pdG9yLnNlbmRfZXhuIHBhcmVudF9tb25pdG9yIGV4bikpO1xuICB3aXRoX2Nsb3NlIHQgfmY6KGZ1biAoKSAtPlxuICAgIGlmIGV4Y2x1c2l2ZSB0aGVuIHdpdGhfd3JpdGVyX2V4Y2x1c2l2ZSB0IChmdW4gKCkgLT4gZiB0KSBlbHNlIGYgdClcbjs7XG5cbm1vZHVsZSBCdWZmZXJfbWFuYWdlbWVudCA9IHN0cnVjdFxuICBsZXQgZ290X2J5dGVzIHQgbiA9IHQuYnl0ZXNfcmVjZWl2ZWQgPC0gSW50NjMuKHQuYnl0ZXNfcmVjZWl2ZWQgKyBvZl9pbnQgbilcblxuICBsZXQgYWRkX2lvdmVjIHQga2luZCAoaW92ZWMgOiBfIElPVmVjLnQpIH5jb3VudF9ieXRlc19hc19yZWNlaXZlZCA9XG4gICAgYXNzZXJ0ICh0LnNjaGVkdWxlZF9iYWNrID0gdC5iYWNrKTtcbiAgICBpZiBjb3VudF9ieXRlc19hc19yZWNlaXZlZCB0aGVuIGdvdF9ieXRlcyB0IGlvdmVjLmxlbjtcbiAgICBpZiBub3QgKGlzX3N0b3BwZWRfcGVybWFuZW50bHkgdClcbiAgICB0aGVuIChcbiAgICAgIHQuc2NoZWR1bGVkX2J5dGVzIDwtIHQuc2NoZWR1bGVkX2J5dGVzICsgaW92ZWMubGVuO1xuICAgICAgRGVxdWUuZW5xdWV1ZV9iYWNrIHQuc2NoZWR1bGVkIChpb3ZlYywga2luZCkpO1xuICAgIGFzc2VydCAodC5zY2hlZHVsZWRfYmFjayA9IHQuYmFjaylcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfdW5zY2hlZHVsZWQgdCBraW5kID1cbiAgICBsZXQgbmVlZF90b19zY2hlZHVsZSA9IHQuYmFjayAtIHQuc2NoZWR1bGVkX2JhY2sgaW5cbiAgICBhc3NlcnQgKG5lZWRfdG9fc2NoZWR1bGUgPj0gMCk7XG4gICAgaWYgbmVlZF90b19zY2hlZHVsZSA+IDBcbiAgICB0aGVuIChcbiAgICAgIGxldCBwb3MgPSB0LnNjaGVkdWxlZF9iYWNrIGluXG4gICAgICB0LnNjaGVkdWxlZF9iYWNrIDwtIHQuYmFjaztcbiAgICAgIGFkZF9pb3ZlY1xuICAgICAgICB0XG4gICAgICAgIGtpbmRcbiAgICAgICAgKElPVmVjLm9mX2JpZ3N0cmluZyB0LmJ1ZiB+cG9zIH5sZW46bmVlZF90b19zY2hlZHVsZSlcbiAgICAgICAgfmNvdW50X2J5dGVzX2FzX3JlY2VpdmVkOmZhbHNlXG4gICAgICAoKiB0aGV5IHdlcmUgYWxyZWFkeSBjb3VudGVkICopKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBCYWNrZ3JvdW5kX3dyaXRlciA9IHN0cnVjdFxuICBvcGVuIEJ1ZmZlcl9tYW5hZ2VtZW50XG5cbiAgbGV0IGR1bW15X2lvdmVjID0gSU9WZWMuZW1wdHkgSU9WZWMuYmlnc3RyaW5nX2tpbmRcblxuICBsZXQgbWtfaW92ZWNzIHQgPVxuICAgIHNjaGVkdWxlX3Vuc2NoZWR1bGVkIHQgS2VlcDtcbiAgICBsZXQgbl9pb3ZlY3MgPSBJbnQubWluIChEZXF1ZS5sZW5ndGggdC5zY2hlZHVsZWQpIChMYXp5LmZvcmNlIElPVmVjLm1heF9pb3ZlY3MpIGluXG4gICAgbGV0IGlvdmVjcyA9IEFycmF5LmNyZWF0ZSB+bGVuOm5faW92ZWNzIGR1bW15X2lvdmVjIGluXG4gICAgbGV0IGNvbnRhaW5zX21tYXBwZWRfcmVmID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IGlvdmVjc19sZW4gPSByZWYgMCBpblxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgbGV0IGkgPSByZWYgMCBpblxuICAgICAgRGVxdWUuaXRlciB0LnNjaGVkdWxlZCB+ZjooZnVuIChpb3ZlYywgXykgLT5cbiAgICAgICAgaWYgIWkgPj0gbl9pb3ZlY3MgdGhlbiByLnJldHVybiAoKTtcbiAgICAgICAgaWYgKG5vdCAhY29udGFpbnNfbW1hcHBlZF9yZWYpICYmIEJpZ3N0cmluZy5pc19tbWFwcGVkIGlvdmVjLmJ1ZlxuICAgICAgICB0aGVuIGNvbnRhaW5zX21tYXBwZWRfcmVmIDo9IHRydWU7XG4gICAgICAgIGlvdmVjc19sZW4gOj0gIWlvdmVjc19sZW4gKyBpb3ZlYy5sZW47XG4gICAgICAgIGlvdmVjcy4oIWkpIDwtIGlvdmVjO1xuICAgICAgICBpbmNyIGkpKTtcbiAgICBpb3ZlY3MsICFjb250YWluc19tbWFwcGVkX3JlZiwgIWlvdmVjc19sZW5cbiAgOztcblxuICAoKiBTaXplIG9mIEkvTy0gb3IgYmxpdCBvcGVyYXRpb24gZm9yIHdoaWNoIGEgaGVscGVyIHRocmVhZCBzaG91bGQgYmUgdXNlZC4gIFRoaXMgbnVtYmVyXG4gICAgIChhIHBvd2VyIG9mIHR3bykgaXMgc29tZXdoYXQgZW1waXJpY2FsbHkgbW90aXZhdGVkLCBidXQgdGhlcmUgaXMgbm8gcmVhc29uIHdoeSBpdFxuICAgICBzaG91bGQgYmUgdGhlIGJlc3QuICopXG4gIGxldCB0aHJlYWRfaW9fY3V0b2ZmID0gMjYyXzE0NFxuXG4gIGxldCBpc19ydW5uaW5nID0gZnVuY3Rpb25cbiAgICB8IGBSdW5uaW5nIC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcbiAgOztcblxuICAoKiBJZiB0aGUgd3JpdGVyIHdhcyBjbG9zZWQsIHdlIHNob3VsZCBiZSBxdWlldC4gIEJ1dCBpZiBpdCB3YXNuJ3QsIHRoZW4gc29tZW9uZSB3YXNcbiAgICAgbW9ua2V5aW5nIGFyb3VuZCB3aXRoIHRoZSBmZCBiZWhpbmQgb3VyIGJhY2ssIGFuZCB3ZSBzaG91bGQgY29tcGxhaW4uXG5cbiAgICAgVGhlcmUgYXJlIHNvbWUgbGlicmFyaWVzIHRoYXQgY2xvc2UgdGhlIGZkIHdpdGhvdXQgY2xvc2luZyB0aGUgd3JpdGVyLCBlLmcuIFRjcCxcbiAgICAgdXN1YWxseSBmb3Igbm8gZ29vZCByZWFzb24uIEluIHRob3NlIGNhc2VzIGFueSB3cml0ZXMgaGFwcGVuaW5nIGFmdGVyIGZkIGlzIGNsb3NlZFxuICAgICB3aWxsIHJ1biBpbnRvIHRoaXMgZXJyb3IuICopXG4gIGxldCBmZF9jbG9zZWQgdCA9XG4gICAgaWYgaXNfY2xvc2VkIHRcbiAgICB0aGVuIHN0b3BfcGVybWFuZW50bHkgdCBDbG9zZWRcbiAgICBlbHNlIGRpZSB0IFslbWVzc2FnZSBcIndyaXRlciBmZCB1bmV4cGVjdGVkbHkgY2xvc2VkIFwiXVxuICA7O1xuXG4gIGxldCB3cml0ZXZfaW5fYmFja2dyb3VuZCBmZCBpb3ZlY3MgPVxuICAgIEZkLndpdGhfZmlsZV9kZXNjcl9kZWZlcnJlZF9yZXN1bHQgZmQgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgICBtYXRjaCBJb191cmluZ19yYXdfc2luZ2xldG9uLnRoZV9vbmVfYW5kX29ubHkgKCkgd2l0aFxuICAgICAgfCBTb21lIHVyaW5nIC0+IElvX3VyaW5nLndyaXRldiB1cmluZyBmZCBpb3ZlY3NcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBJbl90aHJlYWQuc3lzY2FsbCB+bmFtZTpcIndyaXRldlwiIChmdW4gKCkgLT5cbiAgICAgICAgICBCaWdzdHJpbmdfdW5peC53cml0ZXYgZmlsZV9kZXNjciBpb3ZlY3MpKVxuICA7O1xuXG4gIGxldCB1cGRhdGVfYWZ0ZXJfY29tcGxldGVkX3dyaXRlIHQgfmJ5dGVzX3dyaXR0ZW4gPVxuICAgIHQuYnl0ZXNfd3JpdHRlbiA8LSBJbnQ2My4odC5ieXRlc193cml0dGVuICsgb2ZfaW50IGJ5dGVzX3dyaXR0ZW4pO1xuICAgIGlmIEludDYzLih0LmJ5dGVzX3dyaXR0ZW4gPiB0LmJ5dGVzX3JlY2VpdmVkKVxuICAgIHRoZW4gZGllIHQgWyVtZXNzYWdlIFwid3JpdGVyIHdyb3RlIG1vcmUgYnl0ZXMgdGhhbiBpdCByZWNlaXZlZFwiXTtcbiAgICBmaWxsX2ZsdXNoZXMgdDtcbiAgICB0LnNjaGVkdWxlZF9ieXRlcyA8LSB0LnNjaGVkdWxlZF9ieXRlcyAtIGJ5dGVzX3dyaXR0ZW47XG4gICAgKCogUmVtb3ZlIHByb2Nlc3NlZCBpb3ZlY3MgZnJvbSB0LnNjaGVkdWxlZC4gKilcbiAgICBsZXQgcmVjIHJlbW92ZV9kb25lIGJ5dGVzX3dyaXR0ZW4gPVxuICAgICAgYXNzZXJ0IChieXRlc193cml0dGVuID49IDApO1xuICAgICAgbWF0Y2ggRGVxdWUuZGVxdWV1ZV9mcm9udCB0LnNjaGVkdWxlZCB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgaWYgYnl0ZXNfd3JpdHRlbiA+IDBcbiAgICAgICAgdGhlbiBkaWUgdCBbJW1lc3NhZ2UgXCJ3cml0ZXIgd3JvdGUgbm9uemVybyBhbW91bnQgYnV0IElPX3F1ZXVlIGlzIGVtcHR5XCJdXG4gICAgICB8IFNvbWUgKHsgYnVmOyBwb3M7IGxlbiB9LCBraW5kKSAtPlxuICAgICAgICBpZiBieXRlc193cml0dGVuID49IGxlblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBDdXJyZW50IEkvTy12ZWN0b3IgY29tcGxldGVseSB3cml0dGVuLiAgSW50ZXJuYWxseSBnZW5lcmF0ZWQgYnVmZmVycyBnZXRcbiAgICAgICAgICAgICBkZXN0cm95ZWQgaW1tZWRpYXRlbHkgdW5sZXNzIHRoZXkgYXJlIHN0aWxsIGluIHVzZSBmb3IgYnVmZmVyaW5nLiAgKilcbiAgICAgICAgICAobWF0Y2gga2luZCB3aXRoXG4gICAgICAgICAgIHwgRGVzdHJveSAtPiBCaWdzdHJpbmcudW5zYWZlX2Rlc3Ryb3kgYnVmXG4gICAgICAgICAgIHwgS2VlcCAtPiAoKSk7XG4gICAgICAgICAgcmVtb3ZlX2RvbmUgKGJ5dGVzX3dyaXR0ZW4gLSBsZW4pKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBQYXJ0aWFsIEkvTzogdXBkYXRlIHBhcnRpYWxseSB3cml0dGVuIEkvTy12ZWN0b3IgYW5kIHJldHJ5IEkvTy4gKilcbiAgICAgICAgICBsZXQgbmV3X2lvdmVjID1cbiAgICAgICAgICAgIElPVmVjLm9mX2JpZ3N0cmluZyBidWYgfnBvczoocG9zICsgYnl0ZXNfd3JpdHRlbikgfmxlbjoobGVuIC0gYnl0ZXNfd3JpdHRlbilcbiAgICAgICAgICBpblxuICAgICAgICAgIERlcXVlLmVucXVldWVfZnJvbnQgdC5zY2hlZHVsZWQgKG5ld19pb3ZlYywga2luZCkpXG4gICAgaW5cbiAgICByZW1vdmVfZG9uZSBieXRlc193cml0dGVuO1xuICAgICgqIFNlZSBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2UgdG8gZG8uICopXG4gICAgc2NoZWR1bGVfdW5zY2hlZHVsZWQgdCBLZWVwO1xuICAgIGlmIERlcXVlLmlzX2VtcHR5IHQuc2NoZWR1bGVkXG4gICAgdGhlbiAoXG4gICAgICB0LmJhY2sgPC0gMDtcbiAgICAgIHQuc2NoZWR1bGVkX2JhY2sgPC0gMDtcbiAgICAgIGBOb3RoaW5nX2xlZnQpXG4gICAgZWxzZSBgV3JpdGVzX3JlbWFpbmluZ1xuICA7O1xuXG4gIGxldCByZWMgc3RhcnRfd3JpdGUgdCA9XG4gICAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJXcml0ZXIuc3RhcnRfd3JpdGVcIiB0IFslc2V4cF9vZjogdF07XG4gICAgYXNzZXJ0IChpc19ydW5uaW5nIHQuYmFja2dyb3VuZF93cml0ZXJfc3RhdGUpO1xuICAgIGxldCBpb3ZlY3MsIGNvbnRhaW5zX21tYXBwZWQsIGlvdmVjc19sZW4gPSBta19pb3ZlY3MgdCBpblxuICAgIGxldCBoYW5kbGVfd3JpdGVfcmVzdWx0ID0gZnVuY3Rpb25cbiAgICAgIHwgYEFscmVhZHlfY2xvc2VkIC0+IGZkX2Nsb3NlZCB0XG4gICAgICB8IGBPayBuIC0+XG4gICAgICAgIGlmIG4gPj0gMFxuICAgICAgICB0aGVuIHdyaXRlX2ZpbmlzaGVkIHQgblxuICAgICAgICBlbHNlIGRpZSB0IFslbWVzc2FnZSBcIndyaXRlIHN5c3RlbSBjYWxsIHJldHVybmVkIG5lZ2F0aXZlIHJlc3VsdFwiIChuIDogaW50KV1cbiAgICAgIHwgYEVycm9yIChVbml4LlVuaXhfZXJyb3IgKChFV09VTERCTE9DSyB8IEVBR0FJTiksIF8sIF8pKSAtPiB3cml0ZV93aGVuX3JlYWR5IHRcbiAgICAgIHwgYEVycm9yIChVbml4LlVuaXhfZXJyb3IgKEVCQURGLCBfLCBfKSkgLT4gZGllIHQgWyVtZXNzYWdlIFwid3JpdGUgZ290IEVCQURGXCJdXG4gICAgICB8IGBFcnJvclxuICAgICAgICAgIChVbml4LlVuaXhfZXJyb3JcbiAgICAgICAgICAgICAoICggRVBJUEVcbiAgICAgICAgICAgICAgIHwgRUNPTk5SRVNFVFxuICAgICAgICAgICAgICAgfCBFSE9TVFVOUkVBQ0hcbiAgICAgICAgICAgICAgIHwgRU5FVERPV05cbiAgICAgICAgICAgICAgIHwgRU5FVFJFU0VUXG4gICAgICAgICAgICAgICB8IEVORVRVTlJFQUNIXG4gICAgICAgICAgICAgICB8IEVUSU1FRE9VVCApXG4gICAgICAgICAgICAgLCBfXG4gICAgICAgICAgICAgLCBfICkgYXMgZXhuKSAtPlxuICAgICAgICAoKiBbdC5jb25zdW1lcl9sZWZ0XSBpcyBlbXB0eSBzaW5jZSBvbmNlIHdlIHJlYWNoIHRoaXMgcG9pbnQsIHdlIHN0b3AgdGhlIHdyaXRlclxuICAgICAgICAgICBwZXJtYW5lbnRseSwgYW5kIHNvIHdpbGwgbmV2ZXIgcmVhY2ggaGVyZSBhZ2Fpbi4gKilcbiAgICAgICAgYXNzZXJ0IChJdmFyLmlzX2VtcHR5IHQuY29uc3VtZXJfbGVmdCk7XG4gICAgICAgIEl2YXIuZmlsbF9leG4gdC5jb25zdW1lcl9sZWZ0ICgpO1xuICAgICAgICBpZiB0LnJhaXNlX3doZW5fY29uc3VtZXJfbGVhdmVzXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHN0b3BfcGVybWFuZW50bHkgdCBFcnJvcjtcbiAgICAgICAgICByYWlzZSBleG4pXG4gICAgICAgIGVsc2Ugc3RvcF9wZXJtYW5lbnRseSB0IENvbnN1bWVyX2xlZnRcbiAgICAgIHwgYEVycm9yIGV4biAtPiBkaWUgdCBbJW1lc3NhZ2UgXCJcIiB+XzooZXhuIDogRXhuLnQpXVxuICAgIGluXG4gICAgbGV0IHNob3VsZF93cml0ZV9pbl90aHJlYWQgPVxuICAgICAgKG5vdCAoRmQuc3VwcG9ydHNfbm9uYmxvY2sgdC5mZCkpXG4gICAgICAoKiBUaG91Z2ggdGhlIHdyaXRlIHdpbGwgbm90IGJsb2NrIGluIHRoaXMgY2FzZSwgYSBtZW1vcnktbWFwcGVkIGJpZ3N0cmluZyBpbiBhblxuICAgICAgICAgSS9PLXZlY3RvciBtYXkgY2F1c2UgYSBwYWdlIGZhdWx0LCB3aGljaCB3b3VsZCBjYXVzZSB0aGUgYXN5bmMgc2NoZWR1bGVyIHRocmVhZFxuICAgICAgICAgdG8gYmxvY2suICBTbywgd2Ugd3JpdGUgaW4gYSBzZXBhcmF0ZSB0aHJlYWQsIGFuZCB0aGUgW0JpZ3N0cmluZy53cml0ZXZdIHJlbGVhc2VzXG4gICAgICAgICB0aGUgT0NhbWwgbG9jaywgYWxsb3dpbmcgdGhlIGFzeW5jIHNjaGVkdWxlciB0aHJlYWQgdG8gY29udGludWUuICopXG4gICAgICB8fCBpb3ZlY3NfbGVuID4gdGhyZWFkX2lvX2N1dG9mZlxuICAgICAgfHwgY29udGFpbnNfbW1hcHBlZFxuICAgIGluXG4gICAgaWYgc2hvdWxkX3dyaXRlX2luX3RocmVhZFxuICAgIHRoZW4gd3JpdGV2X2luX2JhY2tncm91bmQgdC5mZCBpb3ZlY3MgPj4+IGhhbmRsZV93cml0ZV9yZXN1bHRcbiAgICBlbHNlXG4gICAgICBoYW5kbGVfd3JpdGVfcmVzdWx0XG4gICAgICAgIChGZC5zeXNjYWxsIHQuZmQgfm5vbmJsb2NraW5nOnRydWUgKGZ1biBmaWxlX2Rlc2NyIC0+XG4gICAgICAgICAgIEJpZ3N0cmluZ191bml4LndyaXRldl9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmcgZmlsZV9kZXNjciBpb3ZlY3MpKVxuXG4gIGFuZCB3cml0ZV93aGVuX3JlYWR5IHQgPVxuICAgIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwiV3JpdGVyLndyaXRlX3doZW5fcmVhZHlcIiB0IFslc2V4cF9vZjogdF07XG4gICAgYXNzZXJ0IChpc19ydW5uaW5nIHQuYmFja2dyb3VuZF93cml0ZXJfc3RhdGUpO1xuICAgIEZkLnJlYWR5X3RvIHQuZmQgYFdyaXRlXG4gICAgPj4+IGZ1bmN0aW9uXG4gICAgfCBgQmFkX2ZkIC0+IGRpZSB0IFslbWVzc2FnZSBcIndyaXRlciByZWFkeV90byBnb3QgQmFkX2ZkXCJdXG4gICAgfCBgQ2xvc2VkIC0+IGZkX2Nsb3NlZCB0XG4gICAgfCBgUmVhZHkgLT4gc3RhcnRfd3JpdGUgdFxuXG4gIGFuZCB3cml0ZV9maW5pc2hlZCB0IGJ5dGVzX3dyaXR0ZW4gPVxuICAgIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwiV3JpdGVyLndyaXRlX2ZpbmlzaGVkXCIgKGJ5dGVzX3dyaXR0ZW4sIHQpIFslc2V4cF9vZjogaW50ICogdF07XG4gICAgYXNzZXJ0IChpc19ydW5uaW5nIHQuYmFja2dyb3VuZF93cml0ZXJfc3RhdGUpO1xuICAgIG1hdGNoIHVwZGF0ZV9hZnRlcl9jb21wbGV0ZWRfd3JpdGUgdCB+Ynl0ZXNfd3JpdHRlbiB3aXRoXG4gICAgfCBgTm90aGluZ19sZWZ0IC0+XG4gICAgICAobWF0Y2ggdC5jbG9zZV9zdGF0ZSB3aXRoXG4gICAgICAgfCBgT3BlbiB8IGBDbG9zZWRfYW5kX2ZsdXNoaW5nIC0+IHQuYmFja2dyb3VuZF93cml0ZXJfc3RhdGUgPC0gYE5vdF9ydW5uaW5nXG4gICAgICAgfCBgQ2xvc2VkIC0+XG4gICAgICAgICB0LmJhY2tncm91bmRfd3JpdGVyX3N0YXRlIDwtIGBTdG9wcGVkX3Blcm1hbmVudGx5IENsb3NlZDtcbiAgICAgICAgIEl2YXIuZmlsbF9pZl9lbXB0eSB0LmJhY2tncm91bmRfd3JpdGVyX3N0b3BwZWQgKCkpXG4gICAgfCBgV3JpdGVzX3JlbWFpbmluZyAtPlxuICAgICAgKG1hdGNoIHQuc3lzY2FsbCB3aXRoXG4gICAgICAgfCBgUGVyX2N5Y2xlIC0+IHN0YXJ0X3dyaXRlIHRcbiAgICAgICB8IGBQZXJpb2RpYyBzcGFuIC0+XG4gICAgICAgICBUaW1lX3NvdXJjZS5hZnRlciB0LnRpbWVfc291cmNlIChUaW1lX25zLlNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0IHNwYW4pXG4gICAgICAgICA+Pj4gZnVuIF8gLT4gc3RhcnRfd3JpdGUgdClcbiAgOztcblxuICBsZXQgc3RhcnRfd3JpdGVyIHQgPVxuICAgICgqIHNpbmNlIHdlJ3JlIHdyaXRpbmcsIGVuc3VyZSB0aGUgYnVmZmVyIGFnZSBjaGVjayBpcyBydW5uaW5nICopXG4gICAgbGV0IChfIDogXykgPSBmb3JjZSB0LmNoZWNrX2J1ZmZlcl9hZ2UgaW5cbiAgICB0LmJhY2tncm91bmRfd3JpdGVyX3N0YXRlIDwtIGBSdW5uaW5nO1xuICAgICgqIFdlIHNjaGVkdWxlIHRoZSBiYWNrZ3JvdW5kIHdyaXRlciB0aHJlYWQgdG8gcnVuIHdpdGggbG93IHByaW9yaXR5LCBzbyB0aGF0IGl0XG4gICAgICAgcnVucyBhdCB0aGUgZW5kIG9mIHRoZSBjeWNsZSBhbmQgdGhhdCBhbGwgb2YgdGhlIGNhbGxzIHRvIFdyaXRlci53cml0ZSB3aWxsXG4gICAgICAgdXN1YWxseSBiZSBiYXRjaGVkIGludG8gYSBzaW5nbGUgc3lzdGVtIGNhbGwuICopXG4gICAgc2NoZWR1bGUgfm1vbml0b3I6dC5pbm5lcl9tb25pdG9yIH5wcmlvcml0eTpQcmlvcml0eS5sb3cgKGZ1biAoKSAtPlxuICAgICAgbGV0IG9wZW5fZmxhZ3MgPSB0Lm9wZW5fZmxhZ3MgaW5cbiAgICAgIGxldCBjYW5fd3JpdGVfZmQgPVxuICAgICAgICBtYXRjaCBvcGVuX2ZsYWdzIHdpdGhcbiAgICAgICAgfCBgRXJyb3IgXyB8IGBBbHJlYWR5X2Nsb3NlZCAtPiBmYWxzZVxuICAgICAgICB8IGBPayBmbGFncyAtPiBVbml4Lk9wZW5fZmxhZ3MuY2FuX3dyaXRlIGZsYWdzXG4gICAgICBpblxuICAgICAgaWYgbm90IGNhbl93cml0ZV9mZFxuICAgICAgdGhlblxuICAgICAgICAoKiBUaGUgcmVhc29uIHdlIHByb2R1Y2UgYSBjdXN0b20gZXJyb3IgbWVzc2FnZSBpbiB0aGlzIGNhc2UgaXMgdGhhdFxuICAgICAgICAgICBMaW51eCBjb25mbGF0ZXMgdGhpcyBjYXNlIHdpdGggXCJub3QgYSB2YWxpZCBmaWxlIGRlc2NyaXB0b3JcIiAoRUJBREYpLCB3aGljaFxuICAgICAgICAgICBub3JtYWxseSBpbmRpY2F0ZXMgYSBzZXJpb3VzIGJ1ZyBpbiBmaWxlIGRlc2NyaXB0b3IgaGFuZGxpbmcuICopXG4gICAgICAgIGRpZVxuICAgICAgICAgIHRcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFwibm90IGFsbG93ZWQgdG8gd3JpdGUgZHVlIHRvIGZpbGUtZGVzY3JpcHRvciBmbGFnc1wiIChvcGVuX2ZsYWdzIDogb3Blbl9mbGFncyldO1xuICAgICAgc3RhcnRfd3JpdGUgdClcbiAgOztcblxuICBsZXQgcmVjIGZsdXNoX3RvX2JhY2tpbmdfb3V0X2NoYW5uZWwgdCBiYWNraW5nX291dF9jaGFubmVsID1cbiAgICBsZXQgaW92ZWNzLCAoXyA6IGJvb2wpLCBieXRlc193cml0dGVuID0gbWtfaW92ZWNzIHQgaW5cbiAgICBBcnJheS5pdGVyIGlvdmVjcyB+ZjooZnVuIGlvdmVjIC0+XG4gICAgICBCYWNraW5nX291dF9jaGFubmVsLm91dHB1dF9pb3ZlYyBiYWNraW5nX291dF9jaGFubmVsIGlvdmVjKTtcbiAgICBtYXRjaCB1cGRhdGVfYWZ0ZXJfY29tcGxldGVkX3dyaXRlIHQgfmJ5dGVzX3dyaXR0ZW4gd2l0aFxuICAgIHwgYE5vdGhpbmdfbGVmdCAtPiAoKVxuICAgIHwgYFdyaXRlc19yZW1haW5pbmcgLT4gZmx1c2hfdG9fYmFja2luZ19vdXRfY2hhbm5lbCB0IGJhY2tpbmdfb3V0X2NoYW5uZWxcbiAgOztcblxuICBsZXQgbWF5YmVfc3RhcnRfd3JpdGVyIHQgPVxuICAgIG1hdGNoIHQuYmFja2luZ19vdXRfY2hhbm5lbCB3aXRoXG4gICAgfCBTb21lIGJhY2tpbmdfb3V0X2NoYW5uZWwgLT4gZmx1c2hfdG9fYmFja2luZ19vdXRfY2hhbm5lbCB0IGJhY2tpbmdfb3V0X2NoYW5uZWxcbiAgICB8IE5vbmUgLT5cbiAgICAgIChtYXRjaCB0LmJhY2tncm91bmRfd3JpdGVyX3N0YXRlIHdpdGhcbiAgICAgICB8IGBTdG9wcGVkX3Blcm1hbmVudGx5IF8gfCBgUnVubmluZyAtPiAoKVxuICAgICAgIHwgYE5vdF9ydW5uaW5nIC0+IGlmIGJ5dGVzX3RvX3dyaXRlIHQgPiAwIHRoZW4gc3RhcnRfd3JpdGVyIHQpXG4gIDs7XG5lbmRcblxubGV0IG1heWJlX3N0YXJ0X3dyaXRlciA9IEJhY2tncm91bmRfd3JpdGVyLm1heWJlX3N0YXJ0X3dyaXRlclxuXG5tb2R1bGUgV3JpdGVzID0gc3RydWN0XG4gIG9wZW4gQnVmZmVyX21hbmFnZW1lbnRcblxuICBsZXQgZ2l2ZV9idWYgdCBkZXNpcmVkID1cbiAgICBhc3NlcnQgKGRlc2lyZWQgPj0gMCk7XG4gICAgYXNzZXJ0IChub3QgKGlzX3N0b3BwZWRfcGVybWFuZW50bHkgdCkpO1xuICAgIGdvdF9ieXRlcyB0IGRlc2lyZWQ7XG4gICAgbGV0IGJ1Zl9sZW4gPSBCaWdzdHJpbmcubGVuZ3RoIHQuYnVmIGluXG4gICAgbGV0IGF2YWlsYWJsZSA9IGJ1Zl9sZW4gLSB0LmJhY2sgaW5cbiAgICBpZiBkZXNpcmVkIDw9IGF2YWlsYWJsZVxuICAgIHRoZW4gKFxuICAgICAgKCogRGF0YSBmaXRzIGludG8gYnVmZmVyICopXG4gICAgICBsZXQgcG9zID0gdC5iYWNrIGluXG4gICAgICB0LmJhY2sgPC0gdC5iYWNrICsgZGVzaXJlZDtcbiAgICAgIHQuYnVmLCBwb3MpXG4gICAgZWxzZSBpZiAoKiBQcmVhbGxvY2F0ZWQgYnVmZmVyIHRvbyBzbWFsbDsgc2NoZWR1bGUgYnVmZmVyZWQgd3JpdGVzLiAgV2UgY3JlYXRlIGEgbmV3IGJ1ZmZlciBvZlxuICAgICAgICAgICAgICAgZXhhY3RseSB0aGUgZGVzaXJlZCBzaXplIGlmIHRoZSBkZXNpcmVkIHNpemUgaXMgbW9yZSB0aGFuIGhhbGYgdGhlIGJ1ZmZlciBsZW5ndGguXG4gICAgICAgICAgICAgICBJZiB3ZSBvbmx5IGNyZWF0ZWQgYSBuZXcgYnVmZmVyIHdoZW4gdGhlIGRlc2lyZWQgc2l6ZSB3YXMgZ3JlYXRlciB0aGFuIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgIGxlbmd0aCwgdGhlbiBtdWx0aXBsZSBjb25zZWN1dGl2ZSB3cml0ZXMgb2Ygc2xpZ2h0bHkgbW9yZSB0aGFuIGhhbGYgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgbGVuZ3RoIHdvdWxkIGVhY2ggd2FzdGUgc2xpZ2h0bHkgbGVzcyB0aGFuIGhhbGYgb2YgdGhlIGJ1ZmZlci4gIEFsdGhvdWdoLCBpdCBpc1xuICAgICAgICAgICAgICAgc3RpbGwgdGhlIGNhc2UgdGhhdCBtdWx0aXBsZSBjb25zZWN1dGl2ZSB3cml0ZXMgb2Ygc2xpZ2h0bHkgbW9yZSB0aGFuIG9uZSBxdWFydGVyXG4gICAgICAgICAgICAgICBvZiB0aGUgYnVmZmVyIGxlbmd0aCB3aWxsIHdhc3RlIHNsaWdodGx5IGxlc3MgdGhhbiBvbmUgcXVhcnRlciBvZiB0aGUgYnVmZmVyLiAqKVxuICAgICAgICAgICAgZGVzaXJlZCA+IGJ1Zl9sZW4gLyAyXG4gICAgdGhlbiAoXG4gICAgICBzY2hlZHVsZV91bnNjaGVkdWxlZCB0IEtlZXA7XG4gICAgICAoKiBQcmVhbGxvY2F0aW9uIHNpemUgdG9vIHNtYWxsOyBhbGxvY2F0ZSBkZWRpY2F0ZWQgYnVmZmVyICopXG4gICAgICBsZXQgYnVmID0gQmlnc3RyaW5nLmNyZWF0ZSBkZXNpcmVkIGluXG4gICAgICBhZGRfaW92ZWNcbiAgICAgICAgdFxuICAgICAgICBEZXN0cm95XG4gICAgICAgIChJT1ZlYy5vZl9iaWdzdHJpbmcgfmxlbjpkZXNpcmVkIGJ1ZilcbiAgICAgICAgfmNvdW50X2J5dGVzX2FzX3JlY2VpdmVkOmZhbHNlO1xuICAgICAgKCogd2UgYWxyZWFkeSBjb3VudGVkIHRoZW0gYWJvdmUgKilcbiAgICAgIGJ1ZiwgMClcbiAgICBlbHNlIChcbiAgICAgIHNjaGVkdWxlX3Vuc2NoZWR1bGVkIHQgRGVzdHJveTtcbiAgICAgICgqIFByZWFsbG9jYXRpb24gc2l6ZSBzdWZmaWNpZW50OyBwcmVhbGxvY2F0ZSBuZXcgYnVmZmVyICopXG4gICAgICBsZXQgYnVmID0gQmlnc3RyaW5nLmNyZWF0ZSBidWZfbGVuIGluXG4gICAgICB0LmJ1ZiA8LSBidWY7XG4gICAgICB0LnNjaGVkdWxlZF9iYWNrIDwtIDA7XG4gICAgICB0LmJhY2sgPC0gZGVzaXJlZDtcbiAgICAgIGJ1ZiwgMClcbiAgOztcblxuICAoKiBJZiBbYmxpdF90b19iaWdzdHJpbmddIHJhaXNlcywgW3dyaXRlX2dlbl91bmNoZWNrZWRdIG1heSBsZWF2ZSBzb21lIHVuZXhwZWN0ZWQgYnl0ZXMgaW5cbiAgICAgdGhlIGJpZ3N0cmluZy4gIEhvd2V2ZXIgaXQgbGVhdmVzIFt0LmJhY2tdIGFuZCBbdC5ieXRlc19yZWNlaXZlZF0gaW4gYWdyZWVtZW50LiAqKVxuICBsZXQgd3JpdGVfZ2VuX2ludGVybmFsXG4gICAgKHR5cGUgYSlcbiAgICB0XG4gICAgc3JjXG4gICAgfnNyY19wb3NcbiAgICB+c3JjX2xlblxuICAgIH5hbGxvd19wYXJ0aWFsX3dyaXRlXG4gICAgfihibGl0X3RvX2JpZ3N0cmluZyA6XG4gICAgICAgIHNyYzphIC0+IHNyY19wb3M6aW50IC0+IGRzdDpCaWdzdHJpbmcudCAtPiBkc3RfcG9zOmludCAtPiBsZW46aW50IC0+IHVuaXQpXG4gICAgPVxuICAgIGlmIGlzX3N0b3BwZWRfcGVybWFuZW50bHkgdFxuICAgIHRoZW4gZ290X2J5dGVzIHQgc3JjX2xlblxuICAgIGVsc2UgKFxuICAgICAgbGV0IGF2YWlsYWJsZSA9IEJpZ3N0cmluZy5sZW5ndGggdC5idWYgLSB0LmJhY2sgaW5cbiAgICAgIGlmIGF2YWlsYWJsZSA+PSBzcmNfbGVuXG4gICAgICB0aGVuIChcbiAgICAgICAgZ290X2J5dGVzIHQgc3JjX2xlbjtcbiAgICAgICAgbGV0IGRzdF9wb3MgPSB0LmJhY2sgaW5cbiAgICAgICAgdC5iYWNrIDwtIGRzdF9wb3MgKyBzcmNfbGVuO1xuICAgICAgICBibGl0X3RvX2JpZ3N0cmluZyB+c3JjIH5zcmNfcG9zIH5sZW46c3JjX2xlbiB+ZHN0OnQuYnVmIH5kc3RfcG9zKVxuICAgICAgZWxzZSBpZiBhbGxvd19wYXJ0aWFsX3dyaXRlXG4gICAgICB0aGVuIChcbiAgICAgICAgZ290X2J5dGVzIHQgYXZhaWxhYmxlO1xuICAgICAgICBsZXQgZHN0X3BvcyA9IHQuYmFjayBpblxuICAgICAgICB0LmJhY2sgPC0gZHN0X3BvcyArIGF2YWlsYWJsZTtcbiAgICAgICAgYmxpdF90b19iaWdzdHJpbmcgfnNyYyB+c3JjX3BvcyB+bGVuOmF2YWlsYWJsZSB+ZHN0OnQuYnVmIH5kc3RfcG9zO1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gc3JjX2xlbiAtIGF2YWlsYWJsZSBpblxuICAgICAgICBsZXQgZHN0LCBkc3RfcG9zID0gZ2l2ZV9idWYgdCByZW1haW5pbmcgaW5cbiAgICAgICAgYmxpdF90b19iaWdzdHJpbmcgfnNyYyB+c3JjX3Bvczooc3JjX3BvcyArIGF2YWlsYWJsZSkgfmxlbjpyZW1haW5pbmcgfmRzdCB+ZHN0X3BvcylcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgZHN0LCBkc3RfcG9zID0gZ2l2ZV9idWYgdCBzcmNfbGVuIGluXG4gICAgICAgIGJsaXRfdG9fYmlnc3RyaW5nIH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuOnNyY19sZW4pO1xuICAgICAgbWF5YmVfc3RhcnRfd3JpdGVyIHQpXG4gIDs7XG5cbiAgbGV0IHdyaXRlX2RpcmVjdCB0IH5mID1cbiAgICBpZiBpc19zdG9wcGVkX3Blcm1hbmVudGx5IHRcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIGxldCBwb3MgPSB0LmJhY2sgaW5cbiAgICAgIGxldCBsZW4gPSBCaWdzdHJpbmcubGVuZ3RoIHQuYnVmIC0gcG9zIGluXG4gICAgICBsZXQgeCwgd3JpdHRlbiA9IGYgdC5idWYgfnBvcyB+bGVuIGluXG4gICAgICBpZiB3cml0dGVuIDwgMCB8fCB3cml0dGVuID4gbGVuXG4gICAgICB0aGVuXG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFwiW3dyaXRlX2RpcmVjdF0ncyBbfmZdIGFyZ3VtZW50IHJldHVybmVkIGludmFsaWQgW3dyaXR0ZW5dXCJcbiAgICAgICAgICAgICAgKHdyaXR0ZW4gOiBpbnQpXG4gICAgICAgICAgICAgIChsZW4gOiBpbnQpXG4gICAgICAgICAgICAgIH53cml0ZXI6KHQgOiB0KV07XG4gICAgICB0LmJhY2sgPC0gcG9zICsgd3JpdHRlbjtcbiAgICAgIGdvdF9ieXRlcyB0IHdyaXR0ZW47XG4gICAgICBtYXliZV9zdGFydF93cml0ZXIgdDtcbiAgICAgIFNvbWUgeClcbiAgOztcblxuICBsZXQgd3JpdGVfZ2VuX3VuY2hlY2tlZCA/cG9zID9sZW4gdCBzcmMgfmJsaXRfdG9fYmlnc3RyaW5nIH5sZW5ndGggPVxuICAgIGxldCBzcmNfcG9zLCBzcmNfbGVuID1cbiAgICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggc3JjKVxuICAgIGluXG4gICAgd3JpdGVfZ2VuX2ludGVybmFsXG4gICAgICB0XG4gICAgICBzcmNcbiAgICAgIH5zcmNfcG9zXG4gICAgICB+c3JjX2xlblxuICAgICAgfmFsbG93X3BhcnRpYWxfd3JpdGU6dHJ1ZVxuICAgICAgfmJsaXRfdG9fYmlnc3RyaW5nXG4gIDs7XG5cbiAgbGV0IHdyaXRlX2dlbl93aG9sZV91bmNoZWNrZWQgdCBzcmMgfmJsaXRfdG9fYmlnc3RyaW5nIH5sZW5ndGggPVxuICAgIGxldCBzcmNfbGVuID0gbGVuZ3RoIHNyYyBpblxuICAgIHdyaXRlX2dlbl9pbnRlcm5hbFxuICAgICAgdFxuICAgICAgc3JjXG4gICAgICB+c3JjX3BvczowXG4gICAgICB+c3JjX2xlblxuICAgICAgfmFsbG93X3BhcnRpYWxfd3JpdGU6ZmFsc2VcbiAgICAgIH5ibGl0X3RvX2JpZ3N0cmluZzooZnVuIH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuIC0+XG4gICAgICBhc3NlcnQgKHNyY19wb3MgPSAwKTtcbiAgICAgIGFzc2VydCAobGVuID0gc3JjX2xlbik7XG4gICAgICBibGl0X3RvX2JpZ3N0cmluZyBzcmMgZHN0IH5wb3M6ZHN0X3BvcylcbiAgOztcblxuICBsZXQgd3JpdGVfYnl0ZXMgP3BvcyA/bGVuIHQgc3JjID1cbiAgICB3cml0ZV9nZW5fdW5jaGVja2VkXG4gICAgICA/cG9zXG4gICAgICA/bGVuXG4gICAgICB0XG4gICAgICBzcmNcbiAgICAgIH5ibGl0X3RvX2JpZ3N0cmluZzooZnVuIH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuIC0+XG4gICAgICAgIEJpZ3N0cmluZy5Gcm9tX2J5dGVzLmJsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4pXG4gICAgICB+bGVuZ3RoOkJ5dGVzLmxlbmd0aFxuICA7O1xuXG4gIGxldCB3cml0ZSA/cG9zID9sZW4gdCBzcmMgPVxuICAgIHdyaXRlX2dlbl91bmNoZWNrZWRcbiAgICAgID9wb3NcbiAgICAgID9sZW5cbiAgICAgIHRcbiAgICAgIHNyY1xuICAgICAgfmJsaXRfdG9fYmlnc3RyaW5nOihmdW4gfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gLT5cbiAgICAgICAgQmlnc3RyaW5nLkZyb21fc3RyaW5nLmJsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4pXG4gICAgICB+bGVuZ3RoOlN0cmluZy5sZW5ndGhcbiAgOztcblxuICBsZXQgd3JpdGVfYmlnc3RyaW5nID9wb3MgP2xlbiB0IHNyYyA9XG4gICAgd3JpdGVfZ2VuX3VuY2hlY2tlZFxuICAgICAgP3Bvc1xuICAgICAgP2xlblxuICAgICAgdFxuICAgICAgc3JjXG4gICAgICB+YmxpdF90b19iaWdzdHJpbmc6KGZ1biB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiAtPlxuICAgICAgICBCaWdzdHJpbmcuYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbilcbiAgICAgIH5sZW5ndGg6KGZ1biBidWYgLT4gQmlnc3RyaW5nLmxlbmd0aCBidWYpXG4gIDs7XG5cbiAgbGV0IHdyaXRlX2lvYnVmID9wb3MgP2xlbiB0IGlvYnVmID1cbiAgICBsZXQgaW9idWYgPSBJb2J1Zi5yZWFkX29ubHkgKElvYnVmLm5vX3NlZWsgaW9idWYpIGluXG4gICAgd3JpdGVfZ2VuX3VuY2hlY2tlZFxuICAgICAgP3Bvc1xuICAgICAgP2xlblxuICAgICAgdFxuICAgICAgaW9idWZcbiAgICAgIH5ibGl0X3RvX2JpZ3N0cmluZzooZnVuIH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuIC0+XG4gICAgICAgIElvYnVmLlBlZWsuVG9fYmlnc3RyaW5nLmJsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4pXG4gICAgICB+bGVuZ3RoOihmdW4gYnVmIC0+IElvYnVmLmxlbmd0aCBidWYpXG4gIDs7XG5cbiAgbGV0IHdyaXRlX3N1YnN0cmluZyB0IHN1YnN0cmluZyA9XG4gICAgd3JpdGVfYnl0ZXNcbiAgICAgIHRcbiAgICAgIChTdWJzdHJpbmcuYmFzZSBzdWJzdHJpbmcpXG4gICAgICB+cG9zOihTdWJzdHJpbmcucG9zIHN1YnN0cmluZylcbiAgICAgIH5sZW46KFN1YnN0cmluZy5sZW5ndGggc3Vic3RyaW5nKVxuICA7O1xuXG4gIGxldCB3cml0ZV9iaWdzdWJzdHJpbmcgdCBiaWdzdWJzdHJpbmcgPVxuICAgIHdyaXRlX2JpZ3N0cmluZ1xuICAgICAgdFxuICAgICAgKEJpZ3N1YnN0cmluZy5iYXNlIGJpZ3N1YnN0cmluZylcbiAgICAgIH5wb3M6KEJpZ3N1YnN0cmluZy5wb3MgYmlnc3Vic3RyaW5nKVxuICAgICAgfmxlbjooQmlnc3Vic3RyaW5nLmxlbmd0aCBiaWdzdWJzdHJpbmcpXG4gIDs7XG5cbiAgbGV0IHdyaXRlZiB0ID0ga3NwcmludGYgKGZ1biBzIC0+IHdyaXRlIHQgcylcblxuICBsZXQgd3JpdGVfZ2VuID9wb3MgP2xlbiB0IHNyYyB+YmxpdF90b19iaWdzdHJpbmcgfmxlbmd0aCA9XG4gICAgdHJ5IHdyaXRlX2dlbl91bmNoZWNrZWQgP3BvcyA/bGVuIHQgc3JjIH5ibGl0X3RvX2JpZ3N0cmluZyB+bGVuZ3RoIHdpdGhcbiAgICB8IGV4biAtPiBkaWUgdCBbJW1lc3NhZ2UgXCJXcml0ZXIud3JpdGVfZ2VuOiBlcnJvciB3cml0aW5nIHZhbHVlXCIgKGV4biA6IGV4bildXG4gIDs7XG5cbiAgbGV0IHdyaXRlX2dlbl93aG9sZSB0IHNyYyB+YmxpdF90b19iaWdzdHJpbmcgfmxlbmd0aCA9XG4gICAgdHJ5IHdyaXRlX2dlbl93aG9sZV91bmNoZWNrZWQgdCBzcmMgfmJsaXRfdG9fYmlnc3RyaW5nIH5sZW5ndGggd2l0aFxuICAgIHwgZXhuIC0+IGRpZSB0IFslbWVzc2FnZSBcIldyaXRlci53cml0ZV9nZW5fd2hvbGU6IGVycm9yIHdyaXRpbmcgdmFsdWVcIiAoZXhuIDogZXhuKV1cbiAgOztcblxuICBsZXQgdG9fZm9ybWF0dGVyIHQgPVxuICAgIEZvcm1hdC5tYWtlX2Zvcm1hdHRlclxuICAgICAgKGZ1biBzdHIgcG9zIGxlbiAtPlxuICAgICAgICBlbnN1cmVfY2FuX3dyaXRlIHQ7XG4gICAgICAgIHdyaXRlIH5wb3MgfmxlbiB0IHN0cilcbiAgICAgIGlnbm9yZVxuICA7O1xuXG4gIGxldCB3cml0ZV9jaGFyIHQgYyA9XG4gICAgaWYgaXNfc3RvcHBlZF9wZXJtYW5lbnRseSB0XG4gICAgdGhlbiBnb3RfYnl0ZXMgdCAxXG4gICAgZWxzZSAoXG4gICAgICAoKiBDaGVjayBmb3IgdGhlIGNvbW1vbiBjYXNlIHRoYXQgdGhlIGNoYXIgY2FuIHNpbXBseSBiZSBwdXQgaW4gdGhlIGJ1ZmZlci4gKilcbiAgICAgIGlmIEJpZ3N0cmluZy5sZW5ndGggdC5idWYgLSB0LmJhY2sgPj0gMVxuICAgICAgdGhlbiAoXG4gICAgICAgIGdvdF9ieXRlcyB0IDE7XG4gICAgICAgIHQuYnVmLnt0LmJhY2t9IDwtIGM7XG4gICAgICAgIHQuYmFjayA8LSB0LmJhY2sgKyAxKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBkc3QsIGRzdF9wb3MgPSBnaXZlX2J1ZiB0IDEgaW5cbiAgICAgICAgZHN0Lntkc3RfcG9zfSA8LSBjKTtcbiAgICAgIG1heWJlX3N0YXJ0X3dyaXRlciB0KVxuICA7O1xuXG4gIGxldCBuZXdsaW5lID9saW5lX2VuZGluZyB0ID1cbiAgICBsZXQgbGluZV9lbmRpbmcgPVxuICAgICAgbWF0Y2ggbGluZV9lbmRpbmcgd2l0aFxuICAgICAgfCBTb21lIHggLT4geFxuICAgICAgfCBOb25lIC0+IHQubGluZV9lbmRpbmdcbiAgICBpblxuICAgIChtYXRjaCBsaW5lX2VuZGluZyB3aXRoXG4gICAgIHwgVW5peCAtPiAoKVxuICAgICB8IERvcyAtPiB3cml0ZV9jaGFyIHQgJ1xccicpO1xuICAgIHdyaXRlX2NoYXIgdCAnXFxuJ1xuICA7O1xuXG4gIGxldCB3cml0ZV9saW5lID9saW5lX2VuZGluZyB0IHMgPVxuICAgIHdyaXRlIHQgcztcbiAgICBuZXdsaW5lIHQgP2xpbmVfZW5kaW5nXG4gIDs7XG5cbiAgbGV0IHdyaXRlX2J5dGUgdCBpID0gd3JpdGVfY2hhciB0IChjaGFyX29mX2ludCAoaSAlIDI1NikpXG5cbiAgbW9kdWxlIFRlcm1pbmF0ZV93aXRoID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTmV3bGluZVxuICAgICAgfCBTcGFjZV9pZl9uZWVkZWRcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgd3JpdGVfc2V4cF9pbnRlcm5hbCB+KHRlcm1pbmF0ZV93aXRoIDogVGVybWluYXRlX3dpdGgudCkgPyhodW0gPSBmYWxzZSkgdCBzZXhwID1cbiAgICBpZiBodW1cbiAgICB0aGVuIEZvcm1hdC5mcHJpbnRmICh0b19mb3JtYXR0ZXIgdCkgXCIlYUA/XCIgU2V4cC5wcF9odW0gc2V4cFxuICAgIGVsc2UgU2V4cC50b19idWZmZXJfZ2VuIH5idWY6dCB+YWRkX2NoYXI6d3JpdGVfY2hhciB+YWRkX3N0cmluZzp3cml0ZSBzZXhwO1xuICAgIG1hdGNoIHRlcm1pbmF0ZV93aXRoIHdpdGhcbiAgICB8IE5ld2xpbmUgLT4gbmV3bGluZSB0XG4gICAgfCBTcGFjZV9pZl9uZWVkZWQgLT5cbiAgICAgICgqIElmIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZG9lc24ndCBzdGFydC9lbmQgd2l0aCBwYXJlbiBvciBkb3VibGUgcXVvdGUsIHdlIGFkZFxuICAgICAgICAgYSBzcGFjZSBhZnRlciBpdCB0byBlbnN1cmUgdGhhdCB0aGUgcGFyc2VyIGNhbiByZWNvZ25pemUgdGhlIGVuZCBvZiB0aGUgc2V4cC5cblxuICAgICAgICAgQ29uY3JldGVseSwgc3RhcnRpbmcgd2l0aCAnKCcgb2NjdXJzIElGRiB0aGUgc2V4cCBpcyBhIFtTZXhwLkxpc3RdLCB3aGlsZVxuICAgICAgICAgc3RhcnRpbmcgd2l0aCAnXCInIG9jY3VycyBJRkYgdGhlIHNleHAgaXMgYSBbU2V4cC5BdG9tXSB3aGVyZSB0aGUgYXRvbSBuZWVkc1xuICAgICAgICAgZXNjYXBpbmcuICopXG4gICAgICBsZXQgc3BhY2VfaXNfbmVlZGVkID1cbiAgICAgICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgICAgIHwgTGlzdCBfIC0+IGZhbHNlXG4gICAgICAgIHwgQXRvbSBzdHIgLT4gbm90IChTZXhwbGliLlByZV9zZXhwLm11c3RfZXNjYXBlIHN0cilcbiAgICAgIGluXG4gICAgICBpZiBzcGFjZV9pc19uZWVkZWQgdGhlbiB3cml0ZV9jaGFyIHQgJyAnXG4gIDs7XG5cbiAgbGV0IHdyaXRlX3NleHAgP2h1bSA/KHRlcm1pbmF0ZV93aXRoID0gVGVybWluYXRlX3dpdGguU3BhY2VfaWZfbmVlZGVkKSB0IHNleHAgPVxuICAgIHdyaXRlX3NleHBfaW50ZXJuYWwgdCBzZXhwID9odW0gfnRlcm1pbmF0ZV93aXRoXG4gIDs7XG5cbiAgbGV0IHdyaXRlX2Jpbl9wcm90IHQgKHdyaXRlciA6IF8gQmluX3Byb3QuVHlwZV9jbGFzcy53cml0ZXIpIHYgPVxuICAgIGxldCBsZW4gPSB3cml0ZXIuc2l6ZSB2IGluXG4gICAgbGV0IHRvdF9sZW4gPSBsZW4gKyBCaW5fcHJvdC5VdGlscy5zaXplX2hlYWRlcl9sZW5ndGggaW5cbiAgICBpZiBpc19zdG9wcGVkX3Blcm1hbmVudGx5IHRcbiAgICB0aGVuIGdvdF9ieXRlcyB0IHRvdF9sZW5cbiAgICBlbHNlIChcbiAgICAgIGxldCBidWYsIHN0YXJ0X3BvcyA9IGdpdmVfYnVmIHQgdG90X2xlbiBpblxuICAgICAgaWdub3JlXG4gICAgICAgIChCaWdzdHJpbmcud3JpdGVfYmluX3Byb3Rfa25vd25fc2l6ZSBidWYgfnBvczpzdGFydF9wb3MgfnNpemU6bGVuIHdyaXRlci53cml0ZSB2XG4gICAgICAgICAgOiBpbnQpO1xuICAgICAgbWF5YmVfc3RhcnRfd3JpdGVyIHQpXG4gIDs7XG5cbiAgbGV0IHdyaXRlX2Jpbl9wcm90X25vX3NpemVfaGVhZGVyIHQgfnNpemUgd3JpdGUgdiA9XG4gICAgaWYgaXNfc3RvcHBlZF9wZXJtYW5lbnRseSB0XG4gICAgdGhlbiBnb3RfYnl0ZXMgdCBzaXplXG4gICAgZWxzZSAoXG4gICAgICBsZXQgYnVmLCBzdGFydF9wb3MgPSBnaXZlX2J1ZiB0IHNpemUgaW5cbiAgICAgIGxldCBlbmRfcG9zID0gd3JpdGUgYnVmIH5wb3M6c3RhcnRfcG9zIHYgaW5cbiAgICAgIGxldCB3cml0dGVuID0gZW5kX3BvcyAtIHN0YXJ0X3BvcyBpblxuICAgICAgaWYgd3JpdHRlbiA8PiBzaXplXG4gICAgICB0aGVuXG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFwiV3JpdGVyLndyaXRlX2Jpbl9wcm90X25vX3NpemVfaGVhZGVyIGJ1ZyFcIiAod3JpdHRlbiA6IGludCkgKHNpemUgOiBpbnQpXTtcbiAgICAgIG1heWJlX3N0YXJ0X3dyaXRlciB0KVxuICA7O1xuXG4gIGxldCBzZW5kIHQgcyA9XG4gICAgd3JpdGUgdCAoc3RyaW5nX29mX2ludCAoU3RyaW5nLmxlbmd0aCBzKSBeIFwiXFxuXCIpO1xuICAgIHdyaXRlIHQgc1xuICA7O1xuXG4gIGxldCBzY2hlZHVsZV9pb3ZlYyA/KGRlc3Ryb3lfb3Jfa2VlcCA9IERlc3Ryb3lfb3Jfa2VlcC5LZWVwKSB0IGlvdmVjID1cbiAgICBzY2hlZHVsZV91bnNjaGVkdWxlZCB0IEtlZXA7XG4gICAgYWRkX2lvdmVjIHQgZGVzdHJveV9vcl9rZWVwIGlvdmVjIH5jb3VudF9ieXRlc19hc19yZWNlaXZlZDp0cnVlO1xuICAgIG1heWJlX3N0YXJ0X3dyaXRlciB0XG4gIDs7XG5cbiAgbGV0IHNjaGVkdWxlX2lvdmVjcyB0IGlvdmVjcyA9XG4gICAgc2NoZWR1bGVfdW5zY2hlZHVsZWQgdCBLZWVwO1xuICAgIFF1ZXVlLml0ZXIgaW92ZWNzIH5mOihhZGRfaW92ZWMgdCBLZWVwIH5jb3VudF9ieXRlc19hc19yZWNlaXZlZDp0cnVlKTtcbiAgICBRdWV1ZS5jbGVhciBpb3ZlY3M7XG4gICAgbWF5YmVfc3RhcnRfd3JpdGVyIHRcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfYmlnc3RyaW5nID9kZXN0cm95X29yX2tlZXAgdCA/cG9zID9sZW4gYnN0ciA9XG4gICAgc2NoZWR1bGVfaW92ZWMgdCAoSU9WZWMub2ZfYmlnc3RyaW5nID9wb3MgP2xlbiBic3RyKSA/ZGVzdHJveV9vcl9rZWVwXG4gIDs7XG5cbiAgbGV0IHNjaGVkdWxlX2JpZ3N1YnN0cmluZyB0IGJpZ3N1YnN0cmluZyA9XG4gICAgc2NoZWR1bGVfYmlnc3RyaW5nXG4gICAgICB0XG4gICAgICAoQmlnc3Vic3RyaW5nLmJhc2UgYmlnc3Vic3RyaW5nKVxuICAgICAgfnBvczooQmlnc3Vic3RyaW5nLnBvcyBiaWdzdWJzdHJpbmcpXG4gICAgICB+bGVuOihCaWdzdWJzdHJpbmcubGVuZ3RoIGJpZ3N1YnN0cmluZylcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfaW9idWZfcGVlayB0ID9wb3MgP2xlbiBpb2J1ZiA9XG4gICAgc2NoZWR1bGVfaW92ZWMgdCAoSW9idWZfdW5peC5FeHBlcnQudG9faW92ZWNfc2hhcmVkID9wb3MgP2xlbiBpb2J1ZilcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfaW9idWZfY29uc3VtZSB0ID9sZW4gaW9idWYgPVxuICAgIGxldCBpb3ZlYyA9IElvYnVmX3VuaXguRXhwZXJ0LnRvX2lvdmVjX3NoYXJlZCA/bGVuIGlvYnVmIGluXG4gICAgbGV0IGxlbiA9IGlvdmVjLmxlbiBpblxuICAgIHNjaGVkdWxlX2lvdmVjIHQgaW92ZWM7XG4gICAgbGV0JW1hcCBfID0gZmx1c2hlZF90aW1lIHQgaW5cbiAgICBJb2J1Zi5hZHZhbmNlIGlvYnVmIGxlblxuICA7O1xuZW5kXG5cbm1vZHVsZSBDaGVja2VkX3dyaXRlcyA9IHN0cnVjdFxuICAoKiBUaGUgY29kZSBpbiB0aGlzIG1vZHVsZSBlbnN1cmVzIHRoYXQgbm8gY2FsbHMgaGFwcGVuIG9uIGEgY2xvc2VkIHdyaXRlci4gKilcblxuICBvcGVuIFdyaXRlc1xuXG4gIGxldCBmc3luYyB0ID1cbiAgICBlbnN1cmVfY2FuX3dyaXRlIHQ7XG4gICAgbGV0JWJpbmQgKCkgPSBmbHVzaGVkIHQgaW5cbiAgICBVbml4LmZzeW5jIHQuZmRcbiAgOztcblxuICBsZXQgZmRhdGFzeW5jIHQgPVxuICAgIGVuc3VyZV9jYW5fd3JpdGUgdDtcbiAgICBsZXQlYmluZCAoKSA9IGZsdXNoZWQgdCBpblxuICAgIFVuaXguZmRhdGFzeW5jIHQuZmRcbiAgOztcblxuICBsZXQgd3JpdGVfYmluX3Byb3QgdCBzd19hcmcgdiA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX2Jpbl9wcm90IHQgc3dfYXJnIHZcbiAgOztcblxuICBsZXQgc2VuZCB0IHMgPVxuICAgIGVuc3VyZV9jYW5fd3JpdGUgdDtcbiAgICBzZW5kIHQgc1xuICA7O1xuXG4gIGxldCBzY2hlZHVsZV9pb3ZlYyA/ZGVzdHJveV9vcl9rZWVwIHQgaW92ZWMgPVxuICAgIGVuc3VyZV9jYW5fd3JpdGUgdDtcbiAgICBzY2hlZHVsZV9pb3ZlYyA/ZGVzdHJveV9vcl9rZWVwIHQgaW92ZWNcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfaW92ZWNzIHQgaW92ZWNzID1cbiAgICBlbnN1cmVfY2FuX3dyaXRlIHQ7XG4gICAgc2NoZWR1bGVfaW92ZWNzIHQgaW92ZWNzXG4gIDs7XG5cbiAgbGV0IHNjaGVkdWxlX2JpZ3N0cmluZyB0ID9wb3MgP2xlbiBic3RyID1cbiAgICBlbnN1cmVfY2FuX3dyaXRlIHQ7XG4gICAgc2NoZWR1bGVfYmlnc3RyaW5nIHQgP3BvcyA/bGVuIGJzdHJcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfYmlnc3Vic3RyaW5nIHQgYmlnc3Vic3RyaW5nID1cbiAgICBlbnN1cmVfY2FuX3dyaXRlIHQ7XG4gICAgc2NoZWR1bGVfYmlnc3Vic3RyaW5nIHQgYmlnc3Vic3RyaW5nXG4gIDs7XG5cbiAgbGV0IHNjaGVkdWxlX2lvYnVmX3BlZWsgdCA/cG9zID9sZW4gaW9idWYgPVxuICAgIGVuc3VyZV9jYW5fd3JpdGUgdDtcbiAgICBzY2hlZHVsZV9pb2J1Zl9wZWVrIHQgP3BvcyA/bGVuIGlvYnVmXG4gIDs7XG5cbiAgbGV0IHNjaGVkdWxlX2lvYnVmX2NvbnN1bWUgdCA/bGVuIGlvYnVmID1cbiAgICBlbnN1cmVfY2FuX3dyaXRlIHQ7XG4gICAgc2NoZWR1bGVfaW9idWZfY29uc3VtZSB0ID9sZW4gaW9idWZcbiAgOztcblxuICBsZXQgd3JpdGVfZ2VuID9wb3MgP2xlbiB0IHNyYyB+YmxpdF90b19iaWdzdHJpbmcgfmxlbmd0aCA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX2dlbiA/cG9zID9sZW4gdCBzcmMgfmJsaXRfdG9fYmlnc3RyaW5nIH5sZW5ndGhcbiAgOztcblxuICBsZXQgd3JpdGVfYnl0ZXMgP3BvcyA/bGVuIHQgcyA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX2J5dGVzID9wb3MgP2xlbiB0IHNcbiAgOztcblxuICBsZXQgd3JpdGUgP3BvcyA/bGVuIHQgcyA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlID9wb3MgP2xlbiB0IHNcbiAgOztcblxuICBsZXQgd3JpdGVfbGluZSA/bGluZV9lbmRpbmcgdCBzID1cbiAgICBlbnN1cmVfY2FuX3dyaXRlIHQ7XG4gICAgd3JpdGVfbGluZSB0IHMgP2xpbmVfZW5kaW5nXG4gIDs7XG5cbiAgbGV0IHdyaXRlZiB0ID1cbiAgICBlbnN1cmVfY2FuX3dyaXRlIHQ7XG4gICAgd3JpdGVmIHRcbiAgOztcblxuICBsZXQgd3JpdGVfc2V4cCA/aHVtID90ZXJtaW5hdGVfd2l0aCB0IHMgPVxuICAgIGVuc3VyZV9jYW5fd3JpdGUgdDtcbiAgICB3cml0ZV9zZXhwID9odW0gP3Rlcm1pbmF0ZV93aXRoIHQgc1xuICA7O1xuXG4gIGxldCB3cml0ZV9zZXhwX2ludGVybmFsIH50ZXJtaW5hdGVfd2l0aCA/aHVtIHQgc2V4cCA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX3NleHBfaW50ZXJuYWwgfnRlcm1pbmF0ZV93aXRoID9odW0gdCBzZXhwXG4gIDs7XG5cbiAgbGV0IHdyaXRlX2lvYnVmID9wb3MgP2xlbiB0IGlvYnVmID1cbiAgICBlbnN1cmVfY2FuX3dyaXRlIHQ7XG4gICAgd3JpdGVfaW9idWYgP3BvcyA/bGVuIHQgaW9idWZcbiAgOztcblxuICBsZXQgd3JpdGVfYmlnc3RyaW5nID9wb3MgP2xlbiB0IHNyYyA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX2JpZ3N0cmluZyA/cG9zID9sZW4gdCBzcmNcbiAgOztcblxuICBsZXQgd3JpdGVfYmlnc3Vic3RyaW5nIHQgcyA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX2JpZ3N1YnN0cmluZyB0IHNcbiAgOztcblxuICBsZXQgd3JpdGVfc3Vic3RyaW5nIHQgcyA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX3N1YnN0cmluZyB0IHNcbiAgOztcblxuICBsZXQgd3JpdGVfYnl0ZSB0IGIgPVxuICAgIGVuc3VyZV9jYW5fd3JpdGUgdDtcbiAgICB3cml0ZV9ieXRlIHQgYlxuICA7O1xuXG4gIGxldCB3cml0ZV9jaGFyIHQgYyA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX2NoYXIgdCBjXG4gIDs7XG5cbiAgbGV0IG5ld2xpbmUgP2xpbmVfZW5kaW5nIHQgPVxuICAgIGVuc3VyZV9jYW5fd3JpdGUgdDtcbiAgICBuZXdsaW5lID9saW5lX2VuZGluZyB0XG4gIDs7XG5cbiAgbGV0IHdyaXRlX2Jpbl9wcm90X25vX3NpemVfaGVhZGVyIHQgfnNpemUgd3JpdGUgdiA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX2Jpbl9wcm90X25vX3NpemVfaGVhZGVyIHQgfnNpemUgd3JpdGUgdlxuICA7O1xuXG4gIGxldCB3cml0ZV9kaXJlY3QgdCB+ZiA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX2RpcmVjdCB0IH5mXG4gIDs7XG5cbiAgbGV0IHdyaXRlX2dlbl93aG9sZSB0IHNyYyB+YmxpdF90b19iaWdzdHJpbmcgfmxlbmd0aCA9XG4gICAgZW5zdXJlX2Nhbl93cml0ZSB0O1xuICAgIHdyaXRlX2dlbl93aG9sZSB0IHNyYyB+YmxpdF90b19iaWdzdHJpbmcgfmxlbmd0aFxuICA7O1xuXG4gIG1vZHVsZSBUZXJtaW5hdGVfd2l0aCA9IFdyaXRlcy5UZXJtaW5hdGVfd2l0aFxuXG4gICgqIHRoaXMgb25lIGFscmVhZHkgY2FsbHMgW2Vuc3VyZV9jYW5fd3JpdGVdICopXG4gIGxldCB0b19mb3JtYXR0ZXIgPSBXcml0ZXMudG9fZm9ybWF0dGVyXG5lbmRcblxuaW5jbHVkZSBDaGVja2VkX3dyaXRlc1xuXG5tb2R1bGUgU3Rkb3V0X2FuZF9zdGRlcnIgPSBzdHJ1Y3RcbiAgbGV0IHN0ZG91dF9hbmRfc3RkZXJyX2JlaGF2ZV9uaWNlbHlfaW5fcGlwZWxpbmUgPSByZWYgaWdub3JlXG5cbiAgbGV0IHN0ZG91dF9hbmRfc3RkZXJyID1cbiAgICBsYXp5XG4gICAgICAoKiBXZSBbY3JlYXRlXSB0aGUgd3JpdGVycyBpbnNpZGUgW01vbml0b3IubWFpbl0gc28gdGhhdCBpdCBpcyB0aGVpciBtb25pdG9ycydcbiAgICAgICAgIHBhcmVudC4gKilcbiAgICAgIChtYXRjaFxuICAgICAgICAgU2NoZWR1bGVyLndpdGhpbl92IH5tb25pdG9yOk1vbml0b3IubWFpbiAoZnVuICgpIC0+XG4gICAgICAgICAgIGxldCBzdGRvdXQgPSBGZC5zdGRvdXQgKCkgaW5cbiAgICAgICAgICAgbGV0IHN0ZGVyciA9IEZkLnN0ZGVyciAoKSBpblxuICAgICAgICAgICBsZXQgdCA9IGNyZWF0ZSBzdGRvdXQgaW5cbiAgICAgICAgICAgbGV0IGRldl9hbmRfaW5vIGZkID1cbiAgICAgICAgICAgICBsZXQgc3RhdHMgPSBDb3JlX3VuaXguZnN0YXQgKEZkLmZpbGVfZGVzY3JfZXhuIGZkKSBpblxuICAgICAgICAgICAgIHN0YXRzLnN0X2Rldiwgc3RhdHMuc3RfaW5vXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIG1hdGNoIGFtX3Rlc3RfcnVubmVyIHdpdGhcbiAgICAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgICAgKCogSW4gdGVzdHMsIHdlIHVzZSBzeW5jaHJvbm91cyBvdXRwdXQgdG8gaW1wcm92ZSBkZXRlcm1pbmlzbSwgZXNwZWNpYWxseVxuICAgICAgICAgICAgICAgIHdoZW4gbWl4aW5nIGxpYnJhcmllcyB0aGF0IHVzZSBDb3JlIGFuZCBBc3luYyBwcmludGluZy4gKilcbiAgICAgICAgICAgICBzZXRfYmFja2luZ19vdXRfY2hhbm5lbFxuICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgKEJhY2tpbmdfb3V0X2NoYW5uZWwub2Zfb3V0X2NoYW5uZWwgT3V0X2NoYW5uZWwuc3Rkb3V0KTtcbiAgICAgICAgICAgICB0LCB0XG4gICAgICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICAgICBsZXQgc3Rkb3V0LCBzdGRlcnIgPVxuICAgICAgICAgICAgICAgaWYgWyVjb21wYXJlLmVxdWFsOiBpbnQgKiBpbnRdIChkZXZfYW5kX2lubyBzdGRvdXQpIChkZXZfYW5kX2lubyBzdGRlcnIpXG4gICAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICAgICgqIElmIHN0ZG91dCBhbmQgc3RkZXJyIHBvaW50IHRvIHRoZSBzYW1lIGZpbGUsIHdlIG11c3Qgc2hhcmUgYSBzaW5nbGUgd3JpdGVyXG4gICAgICAgICAgICAgICAgICAgIGJldHdlZW4gdGhlbS4gIFNlZSB0aGUgY29tbWVudCBpbiB3cml0ZXIubWxpIGZvciBkZXRhaWxzLiAqKVxuICAgICAgICAgICAgICAgICB0LCB0XG4gICAgICAgICAgICAgICBlbHNlIHQsIGNyZWF0ZSBzdGRlcnJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICFzdGRvdXRfYW5kX3N0ZGVycl9iZWhhdmVfbmljZWx5X2luX3BpcGVsaW5lIHN0ZG91dDtcbiAgICAgICAgICAgICAhc3Rkb3V0X2FuZF9zdGRlcnJfYmVoYXZlX25pY2VseV9pbl9waXBlbGluZSBzdGRlcnI7XG4gICAgICAgICAgICAgc3Rkb3V0LCBzdGRlcnIpXG4gICAgICAgd2l0aFxuICAgICAgIHwgTm9uZSAtPiByYWlzZV9zIFslbWVzc2FnZSBbJWhlcmVdIFwidW5hYmxlIHRvIGNyZWF0ZSBzdGRvdXQvc3RkZXJyXCJdXG4gICAgICAgfCBTb21lIHYgLT4gdilcbiAgOztcblxuICBsZXQgc3Rkb3V0ID0gbGF6eSAoZnN0IChMYXp5LmZvcmNlIHN0ZG91dF9hbmRfc3RkZXJyKSlcbiAgbGV0IHN0ZGVyciA9IGxhenkgKHNuZCAoTGF6eS5mb3JjZSBzdGRvdXRfYW5kX3N0ZGVycikpXG5cbiAgbGV0IHVzZV9zeW5jaHJvbm91c19zdGRvdXRfYW5kX3N0ZGVyciAoKSA9XG4gICAgbGV0IHN0ZG91dCwgc3RkZXJyID0gTGF6eS5mb3JjZSBzdGRvdXRfYW5kX3N0ZGVyciBpblxuICAgIGxldCB0c19hbmRfY2hhbm5lbHMgPVxuICAgICAgKHN0ZG91dCwgT3V0X2NoYW5uZWwuc3Rkb3V0KVxuICAgICAgKCogV2Ugb25seSBzZXQgW3N0ZGVycl0gaWYgaXQgaXMgZGlzdGluY3QgZnJvbSBbc3Rkb3V0XS4gKilcbiAgICAgIDo6XG4gICAgICAobWF0Y2ggcGh5c19lcXVhbCBzdGRvdXQgc3RkZXJyIHdpdGhcbiAgICAgICB8IHRydWUgLT4gW11cbiAgICAgICB8IGZhbHNlIC0+IFsgc3RkZXJyLCBPdXRfY2hhbm5lbC5zdGRlcnIgXSlcbiAgICBpblxuICAgIExpc3QubWFwIHRzX2FuZF9jaGFubmVscyB+ZjooZnVuICh0LCBvdXRfY2hhbm5lbCkgLT5cbiAgICAgIHNldF9zeW5jaHJvbm91c19vdXRfY2hhbm5lbCB0IG91dF9jaGFubmVsKVxuICAgIHw+IERlZmVycmVkLmFsbF91bml0XG4gIDs7XG5cbiAgKCogVGhpcyB0ZXN0IGlzIGhlcmUgcmF0aGVyIHRoYW4gaW4gYSBbdGVzdF0gZGlyZWN0b3J5IGJlY2F1c2Ugd2Ugd2FudCBpdCB0byBydW5cbiAgICAgaW1tZWRpYXRlbHkgYWZ0ZXIgW3N0ZG91dF0gYW5kIFtzdGRlcnJdIGFyZSBkZWZpbmVkLCBzbyB0aGF0IHRoZXkgaGF2ZW4ndCB5ZXQgYmVlblxuICAgICBmb3JjZWQuICopXG4gIGxldCVleHBlY3RfdGVzdCBcInN0ZG91dCBhbmQgc3RkZXJyIGFyZSBhbHdheXMgdGhlIHNhbWUgaW4gdGVzdHNcIiA9XG4gICAgcHJpbnRfcyBbJW1lc3NhZ2UgKExhenkuaXNfdmFsIHN0ZG91dCA6IGJvb2wpXTtcbiAgICBbJWV4cGVjdCB7fCAoXCJMYXp5LmlzX3ZhbCBzdGRvdXRcIiBmYWxzZSkgfH1dO1xuICAgIHByaW50X3MgWyVtZXNzYWdlIChMYXp5LmlzX3ZhbCBzdGRlcnIgOiBib29sKV07XG4gICAgWyVleHBlY3Qge3wgKFwiTGF6eS5pc192YWwgc3RkZXJyXCIgZmFsc2UpIHx9XTtcbiAgICBsZXQgbW9kdWxlIFUgPSBDb3JlX3VuaXggaW5cbiAgICBsZXQgc2F2ZWRfc3RkZXJyID0gVS5kdXAgVS5zdGRlcnIgaW5cbiAgICAoKiBNYWtlIHN1cmUgZmQgMSBhbmQgMiBoYXZlIGRpZmZlcmVudCBpbm9kZXMgYXQgdGhlIHBvaW50IHRoYXQgd2UgZm9yY2UgdGhlbS4gKilcbiAgICBsZXQgcGlwZV9yLCBwaXBlX3cgPSBVLnBpcGUgKCkgaW5cbiAgICBVLmR1cDIgfnNyYzpwaXBlX3cgfmRzdDpVLnN0ZGVyciAoKTtcbiAgICBVLmNsb3NlIHBpcGVfcjtcbiAgICBVLmNsb3NlIHBpcGVfdztcbiAgICBsZXQgc3Rkb3V0ID0gTGF6eS5mb3JjZSBzdGRvdXQgaW5cbiAgICBsZXQgc3RkZXJyID0gTGF6eS5mb3JjZSBzdGRlcnIgaW5cbiAgICBVLmR1cDIgfnNyYzpzYXZlZF9zdGRlcnIgfmRzdDpVLnN0ZGVyciAoKTtcbiAgICBVLmNsb3NlIHNhdmVkX3N0ZGVycjtcbiAgICBwcmludF9zIFslbWVzc2FnZSAocGh5c19lcXVhbCBzdGRvdXQgc3RkZXJyIDogYm9vbCldO1xuICAgIFslZXhwZWN0IHt8IChcInBoeXNfZXF1YWwgc3Rkb3V0IHN0ZGVyclwiIHRydWUpIHx9XVxuICA7O1xuZW5kXG5cbmxldCBtYWtlX3dyaXRlcl9iZWhhdmVfbmljZWx5X2luX3BpcGVsaW5lIHdyaXRlciA9XG4gIHNldF9idWZmZXJfYWdlX2xpbWl0IHdyaXRlciBgVW5saW1pdGVkO1xuICBzZXRfcmFpc2Vfd2hlbl9jb25zdW1lcl9sZWF2ZXMgd3JpdGVyIGZhbHNlO1xuICBkb24ndF93YWl0X2ZvclxuICAgIChsZXQlbWFwICgpID0gY29uc3VtZXJfbGVmdCB3cml0ZXIgaW5cbiAgICAgU2h1dGRvd24uc2h1dGRvd25fd2l0aF9zaWduYWxfZXhuIFNpZ25hbC5waXBlKVxuOztcblxubGV0IGJlaGF2ZV9uaWNlbHlfaW5fcGlwZWxpbmUgP3dyaXRlcnMgKCkgPVxuICBtYXRjaCB3cml0ZXJzIHdpdGhcbiAgfCBTb21lIGwgLT4gTGlzdC5pdGVyIGwgfmY6bWFrZV93cml0ZXJfYmVoYXZlX25pY2VseV9pbl9waXBlbGluZVxuICB8IE5vbmUgLT5cbiAgICBsZXQgb3BlbiBTdGRvdXRfYW5kX3N0ZGVyciBpblxuICAgIGlmIExhenkuaXNfdmFsIHN0ZG91dF9hbmRfc3RkZXJyXG4gICAgdGhlbiAoXG4gICAgICBsZXQgc3Rkb3V0LCBzdGRlcnIgPSBmb3JjZSBzdGRvdXRfYW5kX3N0ZGVyciBpblxuICAgICAgTGlzdC5pdGVyIFsgc3Rkb3V0OyBzdGRlcnIgXSB+ZjptYWtlX3dyaXRlcl9iZWhhdmVfbmljZWx5X2luX3BpcGVsaW5lKVxuICAgIGVsc2VcbiAgICAgICgqIEZvcmNpbmcgdGhlIGxhenkgd291bGQgaW5pdGlhbGl6ZSB0aGUgc2NoZWR1bGVyLCB3aGljaCB3b3VsZCBtYWtlIGNhbGxzIHRvXG4gICAgICAgICBTY2hlZHVsZXIuZ29fbWFpbiByYWlzZS4gQXZvaWQgdGhhdCwgc28gdXNlcnMgY2FuIGNhbGwgdGhpcyBmdW5jdGlvbiB3aXRob3V0XG4gICAgICAgICBoYXZpbmcgdG8gdGhpbmsgYWJvdXQgdGhpcyBraW5kIG9mIGltcGxpY2F0aW9uLiAqKVxuICAgICAgc3Rkb3V0X2FuZF9zdGRlcnJfYmVoYXZlX25pY2VseV9pbl9waXBlbGluZSA6PSBtYWtlX3dyaXRlcl9iZWhhdmVfbmljZWx5X2luX3BpcGVsaW5lXG47O1xuXG5tb2R1bGUgRmlsZXN5c3RlbV9zdHVmZiA9IHN0cnVjdFxuICBsZXQgd2l0aF9maWxlX2F0b21pY1xuICAgID90ZW1wX2ZpbGVcbiAgICA/cGVybVxuICAgID9mc3luYzooZG9fZnN5bmMgPSBmYWxzZSlcbiAgICA/KHJlcGxhY2Vfc3BlY2lhbCA9IGZhbHNlKVxuICAgID90aW1lX3NvdXJjZVxuICAgIGZpbGVcbiAgICB+ZlxuICAgID1cbiAgICBsZXQlYmluZCBjdXJyZW50X2ZpbGVfcGVybWlzc2lvbnMgPVxuICAgICAgbWF0Y2glbWFwIE1vbml0b3IudHJ5X3dpdGggfnJ1bjpgTm93IH5yZXN0OmBSYWlzZSAoZnVuICgpIC0+IFVuaXguc3RhdCBmaWxlKSB3aXRoXG4gICAgICB8IE9rIHN0YXRzIC0+XG4gICAgICAgIChtYXRjaCBzdGF0cy5raW5kIHdpdGhcbiAgICAgICAgIHwgYEZpbGUgLT4gU29tZSBzdGF0cy5wZXJtXG4gICAgICAgICB8IGBEaXJlY3RvcnkgLT5cbiAgICAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICAgXCJXcml0ZXIud2l0aF9maWxlX2F0b21pYzogbm90IHJlcGxhY2luZyBhIGRpcmVjdG9yeVwiIH5fOihmaWxlIDogc3RyaW5nKV1cbiAgICAgICAgIHwgYENoYXIgfCBgQmxvY2sgfCBgRmlmbyB8IGBTb2NrZXQgLT5cbiAgICAgICAgICAgKG1hdGNoIHJlcGxhY2Vfc3BlY2lhbCB3aXRoXG4gICAgICAgICAgICB8IHRydWUgLT4gU29tZSBzdGF0cy5wZXJtXG4gICAgICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgIFwiV3JpdGVyLndpdGhfZmlsZV9hdG9taWM6IG5vdCByZXBsYWNpbmcgc3BlY2lhbCBmaWxlXCIgfl86KGZpbGUgOiBzdHJpbmcpXSlcbiAgICAgICAgIHwgYExpbmsgLT5cbiAgICAgICAgICAgKCogW1VuaXguc3RhdF0gcmVzb2x2ZXMgdGhlIHN5bWxpbmtzIGFscmVhZHkuXG4gICAgICAgICAgICAgIFVuZm9ydHVuYXRlbHksIHRoaXMgbWVhbnMgd2Ugd29uJ3QgYmUgYWJsZSB0byByZXBsYWNlIGEgXCJicm9rZW5cIiBzeW1saW5rLiAqKVxuICAgICAgICAgICBhc3NlcnQgZmFsc2UpXG4gICAgICB8IEVycm9yIF8gLT4gTm9uZVxuICAgIGluXG4gICAgbGV0IGluaXRpYWxfcGVybWlzc2lvbnMgPVxuICAgICAgbWF0Y2ggcGVybSB3aXRoXG4gICAgICB8IFNvbWUgcCAtPiBwXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgKG1hdGNoIGN1cnJlbnRfZmlsZV9wZXJtaXNzaW9ucyB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gMG82NjZcbiAgICAgICAgIHwgU29tZSBwIC0+IHApXG4gICAgaW5cbiAgICBsZXQlYmluZCB0ZW1wX2ZpbGUsIGZkID1cbiAgICAgIGxldCB0ZW1wX2ZpbGUgPSBPcHRpb24udmFsdWUgdGVtcF9maWxlIH5kZWZhdWx0OmZpbGUgaW5cbiAgICAgIGxldCVtYXAgdGVtcF9maWxlLCBmZCA9XG4gICAgICAgIGxldCBkaXIgPSBGaWxlbmFtZS5kaXJuYW1lIHRlbXBfZmlsZSBpblxuICAgICAgICBsZXQgcHJlZml4ID0gRmlsZW5hbWUuYmFzZW5hbWUgdGVtcF9maWxlIGluXG4gICAgICAgIEluX3RocmVhZC5ydW4gKGZ1biAoKSAtPlxuICAgICAgICAgIEZpbGVuYW1lX3VuaXgub3Blbl90ZW1wX2ZpbGVfZmQgfnBlcm06aW5pdGlhbF9wZXJtaXNzaW9ucyB+aW5fZGlyOmRpciBwcmVmaXggXCJcIilcbiAgICAgIGluXG4gICAgICB0ZW1wX2ZpbGUsIEZkLmNyZWF0ZSBGaWxlIGZkIChJbmZvLm9mX3N0cmluZyB0ZW1wX2ZpbGUpXG4gICAgaW5cbiAgICBsZXQgdCA9IGNyZWF0ZSA/dGltZV9zb3VyY2UgZmQgaW5cbiAgICAobGV0JWJpbmQuRGVmZXJyZWQuUmVzdWx0IGZfcmVzdWx0ID1cbiAgICAgICBNb25pdG9yLnRyeV93aXRoX29yX2Vycm9yIChmdW4gKCkgLT4gZiB0KVxuICAgICAgID4+fCBSZXN1bHQubWFwX2Vycm9yIH5mOihmdW4gZSAtPiBgZl9yYWlzZWQgZSlcbiAgICAgaW5cbiAgICAgbWF0Y2glbWFwXG4gICAgICAgbGV0JWJpbmQuRGVmZXJyZWQuT3JfZXJyb3IgKCkgPVxuICAgICAgICAgUmVzdWx0Lm9rX2lmX3RydWVcbiAgICAgICAgICAgKG5vdCAoaXNfY2xvc2VkIHQpKVxuICAgICAgICAgICB+ZXJyb3I6KEVycm9yLmNyZWF0ZV9zIFslbWVzc2FnZSBcIndyaXRlciBjbG9zZWQgYnkgW2ZdXCIgfl86KGZpbGUgOiBzdHJpbmcpXSlcbiAgICAgICAgIHw+IERlZmVycmVkLnJldHVyblxuICAgICAgIGluXG4gICAgICAgTW9uaXRvci50cnlfd2l0aF9vcl9lcnJvciAoZnVuICgpIC0+XG4gICAgICAgICBsZXQlYmluZCAoKSA9XG4gICAgICAgICAgIG1hdGNoIGN1cnJlbnRfZmlsZV9wZXJtaXNzaW9ucyB3aXRoXG4gICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICgqIFdlIGRvbid0IG5lZWQgdG8gY2hhbmdlIHRoZSBwZXJtaXNzaW9ucyBoZXJlLlxuICAgICAgICAgICAgICAgIFRoZSBbaW5pdGlhbF9wZXJtaXNzaW9uc10gKHdpdGggdW1hc2sgYXBwbGllZCBieSB0aGUgT1MpIHNob3VsZCBiZSBnb29kLiAqKVxuICAgICAgICAgICAgIHJldHVybiAoKVxuICAgICAgICAgICB8IFNvbWUgXyAtPlxuICAgICAgICAgICAgICgqIFdlIGFyZSBvdmVyd3JpdGluZyBwZXJtaXNzaW9ucyBoZXJlIHRvIHVuZG8gdGhlIHVtYXNrIHRoYXQgd2FzIGFwcGxpZWRcbiAgICAgICAgICAgICAgICBieSBbb3BlbmZpbGVdLiBUaGlzIGlzLCBwZXJoYXBzLCB1bnJlYXNvbmFibGUsIGJ1dCBpdCBwcmVzZXJ2ZXMgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgYmVoYXZpb3IuICopXG4gICAgICAgICAgICAgVW5peC5mY2htb2QgZmQgfnBlcm06aW5pdGlhbF9wZXJtaXNzaW9uc1xuICAgICAgICAgaW5cbiAgICAgICAgIGxldCViaW5kICgpID0gaWYgZG9fZnN5bmMgdGhlbiBmc3luYyB0IGVsc2UgcmV0dXJuICgpIGluXG4gICAgICAgICBsZXQlYmluZCAoKSA9IGNsb3NlIHQgaW5cbiAgICAgICAgIFVuaXgucmVuYW1lIH5zcmM6dGVtcF9maWxlIH5kc3Q6ZmlsZSlcbiAgICAgd2l0aFxuICAgICB8IEVycm9yIGUgLT4gRXJyb3IgKGBmaW5hbF9zdGVwc19yYWlzZWQgZSlcbiAgICAgfCBPayAoKSAtPiBPayBmX3Jlc3VsdClcbiAgICA+Pj0gZnVuY3Rpb25cbiAgICB8IE9rIHJlcyAtPiByZXR1cm4gcmVzXG4gICAgfCBFcnJvciBlcnJvciAtPlxuICAgICAgbGV0JWJpbmQgdW5saW5rX3Jlc3VsdCA9XG4gICAgICAgIE1vbml0b3IudHJ5X3dpdGhfb3JfZXJyb3IgKGZ1biAoKSAtPiBVbml4LnVubGluayB0ZW1wX2ZpbGUpXG4gICAgICBpblxuICAgICAgKCogTkIgd2UgbWF5IGhhdmUgdHJpZWQgdG8gY2xvc2UgYWJvdmUsIGJ1dCB0aGF0J3MgT0sgYmVjYXVzZSBjbG9zZSBpc1xuICAgICAgICAgaWRlbXBvdGVudC4gKilcbiAgICAgIGxldCVtYXAgY2xvc2VfcmVzdWx0ID0gTW9uaXRvci50cnlfd2l0aF9vcl9lcnJvciAoZnVuICgpIC0+IGNsb3NlIHQpIGluXG4gICAgICAobWF0Y2ggT3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdCBbIGNsb3NlX3Jlc3VsdDsgdW5saW5rX3Jlc3VsdCBdIHdpdGhcbiAgICAgICB8IE9rICgpIC0+XG4gICAgICAgICAobWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgICAgIHwgYGZfcmFpc2VkIGZfZXJyb3IgLT5cbiAgICAgICAgICAgICgqIFdlIGRvIG5vdCB0YWcgYW4gZXJyb3IgYXJpc2luZyBpbiBbZl0gKilcbiAgICAgICAgICAgIEVycm9yLnJhaXNlIGZfZXJyb3JcbiAgICAgICAgICB8IGBmaW5hbF9zdGVwc19yYWlzZWQgb3VyX2Vycm9yIC0+IG91cl9lcnJvcilcbiAgICAgICB8IEVycm9yIGNsZWFudXBfZXJyb3IgLT5cbiAgICAgICAgIGxldCBpbml0aWFsX2Vycm9yID1cbiAgICAgICAgICAgbWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgICAgICB8IGBmaW5hbF9zdGVwc19yYWlzZWQgZSB8IGBmX3JhaXNlZCBlIC0+IGVcbiAgICAgICAgIGluXG4gICAgICAgICBFcnJvci5vZl9saXN0IFsgaW5pdGlhbF9lcnJvcjsgY2xlYW51cF9lcnJvciBdKVxuICAgICAgfD4gRXJyb3IudGFnX3MgfnRhZzpbJW1lc3NhZ2UgXCJFcnJvciBpbiBXcml0ZXIud2l0aF9maWxlX2F0b21pY1wiIChmaWxlIDogc3RyaW5nKV1cbiAgICAgIHw+IEVycm9yLnJhaXNlXG4gIDs7XG5cbiAgbGV0IHNhdmUgP3RlbXBfZmlsZSA/cGVybSA/ZnN5bmMgP3JlcGxhY2Vfc3BlY2lhbCBmaWxlIH5jb250ZW50cyA9XG4gICAgd2l0aF9maWxlX2F0b21pYyA/dGVtcF9maWxlID9wZXJtID9mc3luYyA/cmVwbGFjZV9zcGVjaWFsIGZpbGUgfmY6KGZ1biB0IC0+XG4gICAgICB3cml0ZSB0IGNvbnRlbnRzO1xuICAgICAgcmV0dXJuICgpKVxuICA7O1xuXG4gIGxldCBzYXZlX2xpbmVzID90ZW1wX2ZpbGUgP3Blcm0gP2ZzeW5jID9yZXBsYWNlX3NwZWNpYWwgZmlsZSBsaW5lcyA9XG4gICAgd2l0aF9maWxlX2F0b21pYyA/dGVtcF9maWxlID9wZXJtID9mc3luYyA/cmVwbGFjZV9zcGVjaWFsIGZpbGUgfmY6KGZ1biB0IC0+XG4gICAgICBMaXN0Lml0ZXIgbGluZXMgfmY6KGZ1biBsaW5lIC0+XG4gICAgICAgIHdyaXRlIHQgbGluZTtcbiAgICAgICAgbmV3bGluZSB0KTtcbiAgICAgIHJldHVybiAoKSlcbiAgOztcblxuICBsZXQgc2F2ZV9zZXhwID90ZW1wX2ZpbGUgP3Blcm0gP2ZzeW5jID9yZXBsYWNlX3NwZWNpYWwgPyhodW0gPSB0cnVlKSBmaWxlIHNleHAgPVxuICAgIHdpdGhfZmlsZV9hdG9taWMgP3RlbXBfZmlsZSA/cGVybSA/ZnN5bmMgP3JlcGxhY2Vfc3BlY2lhbCBmaWxlIH5mOihmdW4gdCAtPlxuICAgICAgd3JpdGVfc2V4cF9pbnRlcm5hbCB0IHNleHAgfmh1bSB+dGVybWluYXRlX3dpdGg6TmV3bGluZTtcbiAgICAgIHJldHVybiAoKSlcbiAgOztcblxuICBsZXQgc2F2ZV9zZXhwc19jb252XG4gICAgP3RlbXBfZmlsZVxuICAgID9wZXJtXG4gICAgP2ZzeW5jXG4gICAgP3JlcGxhY2Vfc3BlY2lhbFxuICAgID8oaHVtID0gdHJ1ZSlcbiAgICBmaWxlXG4gICAgeHNcbiAgICBzZXhwX29mX3hcbiAgICA9XG4gICAgd2l0aF9maWxlX2F0b21pYyA/dGVtcF9maWxlID9wZXJtID9mc3luYyA/cmVwbGFjZV9zcGVjaWFsIGZpbGUgfmY6KGZ1biB0IC0+XG4gICAgICBMaXN0Lml0ZXIgeHMgfmY6KGZ1biB4IC0+XG4gICAgICAgIHdyaXRlX3NleHBfaW50ZXJuYWwgdCAoc2V4cF9vZl94IHgpIH5odW0gfnRlcm1pbmF0ZV93aXRoOk5ld2xpbmUpO1xuICAgICAgcmV0dXJuICgpKVxuICA7O1xuXG4gIGxldCBzYXZlX3NleHBzID90ZW1wX2ZpbGUgP3Blcm0gP2ZzeW5jID9yZXBsYWNlX3NwZWNpYWwgP2h1bSBmaWxlIHNleHBzID1cbiAgICBzYXZlX3NleHBzX2NvbnYgP3RlbXBfZmlsZSA/cGVybSA/ZnN5bmMgP3JlcGxhY2Vfc3BlY2lhbCA/aHVtIGZpbGUgc2V4cHMgRm4uaWRcbiAgOztcblxuICBsZXQgc2F2ZV9iaW5fcHJvdCA/dGVtcF9maWxlID9wZXJtID9mc3luYyA/cmVwbGFjZV9zcGVjaWFsIGZpbGUgYmluX3dyaXRlciBhID1cbiAgICB3aXRoX2ZpbGVfYXRvbWljID90ZW1wX2ZpbGUgP3Blcm0gP2ZzeW5jID9yZXBsYWNlX3NwZWNpYWwgZmlsZSB+ZjooZnVuIHQgLT5cbiAgICAgIHdyaXRlX2Jpbl9wcm90IHQgYmluX3dyaXRlciBhO1xuICAgICAgcmV0dXJuICgpKVxuICA7O1xuZW5kXG5cbmxldCB3aXRoX2ZsdXNoZWRfYXRfY2xvc2UgdCB+Zmx1c2hlZCB+ZiA9XG4gIGxldCBwcm9kdWNlcnNfdG9fZmx1c2hfYXRfY2xvc2VfZWx0ID0gQmFnLmFkZCB0LnByb2R1Y2Vyc190b19mbHVzaF9hdF9jbG9zZSBmbHVzaGVkIGluXG4gIE1vbml0b3IucHJvdGVjdCB+cnVuOmBTY2hlZHVsZSBmIH5maW5hbGx5OihmdW4gKCkgLT5cbiAgICBCYWcucmVtb3ZlIHQucHJvZHVjZXJzX3RvX2ZsdXNoX2F0X2Nsb3NlIHByb2R1Y2Vyc190b19mbHVzaF9hdF9jbG9zZV9lbHQ7XG4gICAgcmV0dXJuICgpKVxuOztcblxubW9kdWxlIFN0cmVhbWluZyA9IHN0cnVjdFxuICBsZXQgbWFrZV90cmFuc2ZlciA/KHN0b3AgPSBEZWZlcnJlZC5uZXZlciAoKSkgP21heF9udW1fdmFsdWVzX3Blcl9yZWFkIHQgcGlwZV9yIHdyaXRlX2YgPVxuICAgIGxldCBjb25zdW1lciA9XG4gICAgICBQaXBlLmFkZF9jb25zdW1lciBwaXBlX3IgfmRvd25zdHJlYW1fZmx1c2hlZDooZnVuICgpIC0+XG4gICAgICAgIGxldCVtYXAgKCkgPSBmbHVzaGVkIHQgaW5cbiAgICAgICAgYE9rKVxuICAgIGluXG4gICAgbGV0IGVuZF9vZl9waXBlX3IgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgICgqIFRoZSBvbmx5IHJlYXNvbiB3ZSBjYW4ndCB1c2UgW1BpcGUuaXRlcl0gaXMgYmVjYXVzZSBpdCBkb2Vzbid0IGFjY2VwdFxuICAgICAgIFs/bWF4X251bV92YWx1ZXNfcGVyX3JlYWRdLiAqKVxuICAgIGxldCByZWMgaXRlciAoKSA9XG4gICAgICBpZiBJdmFyLmlzX2Z1bGwgdC5jb25zdW1lcl9sZWZ0XG4gICAgICAgICB8fCAobm90IChjYW5fd3JpdGUgdCkpXG4gICAgICAgICB8fCBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIHN0b3BcbiAgICAgIHRoZW5cbiAgICAgICAgKCogVGhlIFtjaG9vc2VdIGluIFtkb2l0XSB3aWxsIGJlY29tZSBkZXRlcm1pbmVkIGFuZCBbZG9pdF0gd2lsbCBkbyB0aGUgcmlnaHRcbiAgICAgICAgICAgdGhpbmcuICopXG4gICAgICAgICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJlYWRfcmVzdWx0ID1cbiAgICAgICAgICBtYXRjaCBtYXhfbnVtX3ZhbHVlc19wZXJfcmVhZCB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IFBpcGUucmVhZF9ub3cnIHBpcGVfciB+Y29uc3VtZXJcbiAgICAgICAgICB8IFNvbWUgbWF4X3F1ZXVlX2xlbmd0aCAtPiBQaXBlLnJlYWRfbm93JyBwaXBlX3IgfmNvbnN1bWVyIH5tYXhfcXVldWVfbGVuZ3RoXG4gICAgICAgIGluXG4gICAgICAgIG1hdGNoIHJlYWRfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBgRW9mIC0+IEl2YXIuZmlsbF9leG4gZW5kX29mX3BpcGVfciAoKVxuICAgICAgICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPiBQaXBlLnZhbHVlc19hdmFpbGFibGUgcGlwZV9yID4+PiBmdW4gXyAtPiBpdGVyICgpXG4gICAgICAgIHwgYE9rIHEgLT5cbiAgICAgICAgICB3cml0ZV9mIHEgfmNvbnQ6KGZ1biAoKSAtPlxuICAgICAgICAgICAgUGlwZS5Db25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtIGNvbnN1bWVyO1xuICAgICAgICAgICAgZmx1c2hlZCB0ID4+PiBpdGVyKSlcbiAgICBpblxuICAgIGxldCBkb2l0ICgpID1cbiAgICAgICgqIENvbmN1cnJlY3kgYmV0d2VlbiBbaXRlcl0gYW5kIFtjaG9vc2VdIGlzIGVzc2VudGlhbC4gIEV2ZW4gaWYgW2l0ZXJdIGdldHMgYmxvY2tlZCxcbiAgICAgICAgIGZvciBleGFtcGxlIG9uIFtmbHVzaGVkXSwgdGhlIHJlc3VsdCBvZiBbZG9pdF0gY2FuIHN0aWxsIGJlIGRldGVybWluZWQgYnkgW2Nob2ljZV1zXG4gICAgICAgICBvdGhlciB0aGFuIFtlbmRfb2ZfcGlwZV9yXS4gKilcbiAgICAgIGl0ZXIgKCk7XG4gICAgICBtYXRjaCVtYXBcbiAgICAgICAgY2hvb3NlXG4gICAgICAgICAgWyBjaG9pY2UgKEl2YXIucmVhZCBlbmRfb2ZfcGlwZV9yKSAoZnVuICgpIC0+IGBFbmRfb2ZfcGlwZV9yKVxuICAgICAgICAgIDsgY2hvaWNlIHN0b3AgKGZ1biAoKSAtPiBgU3RvcClcbiAgICAgICAgICA7IGNob2ljZSAoY2xvc2VfZmluaXNoZWQgdCkgKGZ1biAoKSAtPiBgV3JpdGVyX2Nsb3NlZClcbiAgICAgICAgICA7IGNob2ljZSAoY29uc3VtZXJfbGVmdCB0KSAoZnVuICgpIC0+IGBDb25zdW1lcl9sZWZ0KVxuICAgICAgICAgIF1cbiAgICAgIHdpdGhcbiAgICAgIHwgYEVuZF9vZl9waXBlX3IgfCBgU3RvcCAtPiAoKVxuICAgICAgfCBgV3JpdGVyX2Nsb3NlZCB8IGBDb25zdW1lcl9sZWZ0IC0+IFBpcGUuY2xvc2VfcmVhZCBwaXBlX3JcbiAgICBpblxuICAgIHdpdGhfZmx1c2hlZF9hdF9jbG9zZSB0IH5mOmRvaXQgfmZsdXNoZWQ6KGZ1biAoKSAtPlxuICAgICAgRGVmZXJyZWQuaWdub3JlX20gKFBpcGUudXBzdHJlYW1fZmx1c2hlZCBwaXBlX3IpKVxuICA7O1xuXG4gIGxldCB0cmFuc2ZlciA/c3RvcCA/bWF4X251bV92YWx1ZXNfcGVyX3JlYWQgdCBwaXBlX3Igd3JpdGVfZiA9XG4gICAgbWFrZV90cmFuc2ZlciA/c3RvcCA/bWF4X251bV92YWx1ZXNfcGVyX3JlYWQgdCBwaXBlX3IgKGZ1biBxIH5jb250IC0+XG4gICAgICBRdWV1ZS5pdGVyIHEgfmY6d3JpdGVfZjtcbiAgICAgIGNvbnQgKCkpXG4gIDs7XG5cbiAgbGV0IHRyYW5zZmVyJyA/c3RvcCA/bWF4X251bV92YWx1ZXNfcGVyX3JlYWQgdCBwaXBlX3Igd3JpdGVfZiA9XG4gICAgbWFrZV90cmFuc2ZlciA/c3RvcCA/bWF4X251bV92YWx1ZXNfcGVyX3JlYWQgdCBwaXBlX3IgKGZ1biBxIH5jb250IC0+XG4gICAgICB3cml0ZV9mIHEgPj4+IGNvbnQpXG4gIDs7XG5cbiAgbGV0IHBpcGUgdCA9XG4gICAgbGV0IHBpcGVfciwgcGlwZV93ID0gUGlwZS5jcmVhdGUgKCkgaW5cbiAgICBkb24ndF93YWl0X2ZvciAodHJhbnNmZXIgdCBwaXBlX3IgKGZ1biBzIC0+IHdyaXRlIHQgcykpO1xuICAgIHBpcGVfd1xuICA7O1xuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBzZXRfYnl0ZXNfcmVjZWl2ZWQgdCBpID1cbiAgICBsZXQgKF8gOiBfKSA9IGZvcmNlIHQuY2hlY2tfYnVmZmVyX2FnZSBpblxuICAgIHQuYnl0ZXNfcmVjZWl2ZWQgPC0gaVxuICA7O1xuXG4gIGxldCBzZXRfYnl0ZXNfd3JpdHRlbiB0IGkgPSB0LmJ5dGVzX3dyaXR0ZW4gPC0gaVxuXG4gIG1vZHVsZSBDaGVja19idWZmZXJfYWdlID0gQ2hlY2tfYnVmZmVyX2FnZVxuZW5kXG5cbmluY2x1ZGUgU3Rkb3V0X2FuZF9zdGRlcnJcbmluY2x1ZGUgRmlsZXN5c3RlbV9zdHVmZlxuaW5jbHVkZSBTdHJlYW1pbmdcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm1vZHVsZSBTY2hlZHVsZXIgPSBSYXdfc2NoZWR1bGVyXG5tb2R1bGUgVW5peCA9IFVuaXhfc3lzY2FsbHNcbm1vZHVsZSBJZCA9IFVuaXF1ZV9pZC5JbnQ2MyAoKVxuXG5tb2R1bGUgUmVhZF9yZXN1bHQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFogPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPVxuICAgICAgWyBgT2sgb2YgJ2FcbiAgICAgIHwgYEVvZlxuICAgICAgXVxuICAgIFtAQGRlcml2aW5nIGJpbl9pbywgc2V4cF1cblxuICAgIGxldCBiaW5kIGEgfmYgPVxuICAgICAgbWF0Y2ggYSB3aXRoXG4gICAgICB8IGBPayBhIC0+IGYgYVxuICAgICAgfCBgRW9mIC0+IGBFb2ZcbiAgICA7O1xuXG4gICAgbGV0IG1hcCBhIH5mID1cbiAgICAgIG1hdGNoIGEgd2l0aFxuICAgICAgfCBgT2sgYSAtPiBgT2sgKGYgYSlcbiAgICAgIHwgYEVvZiAtPiBgRW9mXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGxldCByZXR1cm4gYSA9IGBPayBhXG4gIGVuZFxuXG4gIGluY2x1ZGUgWlxuICBpbmNsdWRlIE1vbmFkLk1ha2UgKFopXG5lbmRcblxuKCogV2UgcHV0IGV2ZXJ5dGhpbmcgaW4gbW9kdWxlIFtJbnRlcm5hbF0gYW5kIHRoZW4gZXhwb3NlIGp1c3QgdGhlIGZ1bmN0aW9ucyB3ZSB3YW50XG4gICBsYXRlci4gIFRoaXMgcmVtaW5kcyB1cyB0byB3cmFwIGZ1bmN0aW9ucyB3aXRoIFtkb19yZWFkXSwgd2hpY2ggd2UgZG8gdG8gcHJldmVudFxuICAgbXVsdGlwbGUgc2ltdWx0YW5lb3VzIGFjdGl2ZSB1c2VzIG9mIGEgcmVhZGVyLiAqKVxubW9kdWxlIEludGVybmFsID0gc3RydWN0XG4gIG1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICBbIGBOb3RfaW5fdXNlXG4gICAgICB8IGBJbl91c2VcbiAgICAgIHwgYENsb3NlZFxuICAgICAgXVxuICAgIFtAQGRlcml2aW5nIHNleHBdXG4gIGVuZFxuXG4gIG1vZHVsZSBPcGVuX2ZsYWdzID0gVW5peC5PcGVuX2ZsYWdzXG5cbiAgdHlwZSBvcGVuX2ZsYWdzID1cbiAgICBbIGBBbHJlYWR5X2Nsb3NlZFxuICAgIHwgYE9rIG9mIE9wZW5fZmxhZ3MudFxuICAgIHwgYEVycm9yIG9mIGV4blxuICAgIF1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlIHQgPVxuICAgIHsgZmQgOiBGZC50XG4gICAgOyBpZCA6IElkLnRcbiAgICA7IG11dGFibGUgYnl0ZXNfcmVhZCA6IEludDYzLnRcbiAgICA7ICgqIFtidWZdIGhvbGRzIGRhdGEgcmVhZCBieSB0aGUgcmVhZGVyIGZyb20gdGhlIE9TLCBidXQgbm90IHlldCByZWFkIGJ5IHVzZXIgY29kZS5cbiAgICAgICAgIFdoZW4gW3RdIGlzIGNsb3NlZCwgW2J1Zl0gaXMgc2V0IHRvIHRoZSBlbXB0eSBidWZmZXIuICBTbywgd2UgbXVzdCBtYWtlIHN1cmUgaW5cbiAgICAgICAgIGFueSBjb2RlIHRoYXQgYWNjZXNzZXMgW2J1Zl0gdGhhdCBbdF0gaGFzIG5vdCBiZWVuIGNsb3NlZC4gIEluIHBhcnRpY3VsYXIsIGFmdGVyXG4gICAgICAgICBhbnkgZGVmZXJyZWQgb3BlcmF0aW9uLCB3ZSBtdXN0IGNoZWNrIHdoZXRoZXIgW3RdIGhhcyBiZWVuIGNsb3NlZCB3aGlsZSB3ZSB3ZXJlXG4gICAgICAgICB3YWl0aW5nLiAqKVxuICAgICAgbXV0YWJsZSBidWYgOiBCaWdzdHJpbmcudFxuICAgIDsgKCogW2Nsb3NlX21heV9kZXN0cm95X2J1Zl0gaW5kaWNhdGVzIHdoZXRoZXIgYSBjYWxsIHRvIFtjbG9zZV0gY2FuIGltbWVkaWF0ZWx5XG4gICAgICAgICBkZXN0cm95IFtidWZdLiAgW2Nsb3NlX21heV9kZXN0cm95X2J1Zl0gaXMgdXN1YWxseSBbYFllc10sIGV4Y2VwdCB3aGVuIHdlJ3JlIGluXG4gICAgICAgICB0aGUgbWlkZGxlIG9mIGEgc3lzdGVtIGNhbGwgaW4gYW5vdGhlciB0aHJlYWQgdGhhdCByZWZlcnMgdG8gW2J1Zl0sIGluIHdoaWNoIGNhc2VcbiAgICAgICAgIGl0IGlzIFtgTm90X25vd10gYW5kIFtjbG9zZV0gY2FuJ3QgZGVzdHJveSBbYnVmXSwgYW5kIHdlIG11c3Qgd2FpdCB1bnRpbCB0aGF0XG4gICAgICAgICBzeXN0ZW0gY2FsbCBmaW5pc2hlcyBiZWZvcmUgZG9pbmcgc28uXG5cbiAgICAgICAgIFtgTm90X2V2ZXJdIGlzIHVzZWQgZm9yIFtyZWFkX29uZV9jaHVua19hdF9hX3RpbWVdLCB3aGljaCBleHBvc2VzW2J1Zl1cbiAgICAgICAgIHRvIGNsaWVudCBjb2RlLCB3aGljaCBtYXkgaW4gdHVybiBob2xkIG9uIHRvIGl0IChlLmcuIHZpYVxuICAgICAgICAgW0JpZ3N0cmluZy5zdWJfc2hhcmVkXSksIGFuZCB0aHVzIGl0IGlzIG5vdCBzYWZlIHRvIGV2ZXIgZGVzdHJveSBpdC4gKilcbiAgICAgIG11dGFibGUgY2xvc2VfbWF5X2Rlc3Ryb3lfYnVmIDogWyBgWWVzIHwgYE5vdF9ub3cgfCBgTm90X2V2ZXIgXVxuICAgIDsgKCogW3Bvc10gaXMgdGhlIGZpcnN0IGJ5dGUgb2YgZGF0YSBpbiBbYnVmXSB0byBiZSByZWFkIGJ5IHVzZXIgY29kZS4gKilcbiAgICAgIG11dGFibGUgcG9zIDogaW50XG4gICAgOyAoKiBbYXZhaWxhYmxlXSBpcyBob3cgbWFueSBieXRlcyBpbiBbYnVmXSBhcmUgYXZhaWxhYmxlIHRvIGJlIHJlYWQgYnkgdXNlciBjb2RlLiAqKVxuICAgICAgbXV0YWJsZSBhdmFpbGFibGUgOiBpbnRcbiAgICA7ICgqIFtgQ2xvc2VkXSBtZWFucyB0aGF0IFtjbG9zZSB0XSBoYXMgYmVlbiBjYWxsZWQuICBbYEluX3VzZV0gbWVhbnMgdGhlcmUgaXMgc29tZVxuICAgICAgICAgdXNlciBjYWxsIGV4dGFudCB0aGF0IGlzIHdhaXRpbmcgZm9yIGRhdGEgZnJvbSB0aGUgcmVhZGVyLiAqKVxuICAgICAgbXV0YWJsZSBzdGF0ZSA6IFN0YXRlLnRcbiAgICA7IGNsb3NlX2ZpbmlzaGVkIDogdW5pdCBJdmFyLnRcbiAgICA7IG11dGFibGUgbGFzdF9yZWFkX3RpbWUgOiBUaW1lLnRcbiAgICA7ICgqIFtvcGVuX2ZsYWdzXSBpcyB0aGUgb3Blbi1maWxlLWRlc2NyaXB0b3IgYml0cyBvZiBbZmRdLiAqKVxuICAgICAgb3Blbl9mbGFncyA6IG9wZW5fZmxhZ3NcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVyc11cblxuICBsZXQgc2V4cF9vZl90IHQgPSBbJXNleHAgKHQuZmQgOiBGZC50X2h1bSldXG5cbiAgdHlwZSB0X2ludGVybmFscyA9IHRcblxuICBsZXQgc2V4cF9vZl90X2ludGVybmFsc1xuICAgIHsgYXZhaWxhYmxlXG4gICAgOyBidWYgPSBfXG4gICAgOyBjbG9zZV9maW5pc2hlZFxuICAgIDsgY2xvc2VfbWF5X2Rlc3Ryb3lfYnVmXG4gICAgOyBpZFxuICAgIDsgZmRcbiAgICA7IGJ5dGVzX3JlYWRcbiAgICA7IGxhc3RfcmVhZF90aW1lXG4gICAgOyBvcGVuX2ZsYWdzXG4gICAgOyBwb3NcbiAgICA7IHN0YXRlXG4gICAgfVxuICAgID1cbiAgICBsZXQgdW5sZXNzX3Rlc3RpbmcgeCA9IE9wdGlvbi5zb21lX2lmIChub3QgUHB4X2lubGluZV90ZXN0X2xpYi5hbV9ydW5uaW5nKSB4IGluXG4gICAgWyVzZXhwXG4gICAgICB7IGlkID0gKGlkIHw+IHVubGVzc190ZXN0aW5nIDogKElkLnQgb3B0aW9uW0BzZXhwLm9wdGlvbl0pKVxuICAgICAgOyBzdGF0ZSA6IFN0YXRlLnRcbiAgICAgIDsgYXZhaWxhYmxlIDogaW50XG4gICAgICA7IHBvcyA6IGludFxuICAgICAgOyBvcGVuX2ZsYWdzID0gKG9wZW5fZmxhZ3MgfD4gdW5sZXNzX3Rlc3RpbmcgOiAob3Blbl9mbGFncyBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICA7IGxhc3RfcmVhZF90aW1lID1cbiAgICAgICAgICAobGFzdF9yZWFkX3RpbWUgfD4gdW5sZXNzX3Rlc3RpbmcgOiAoVGltZS50IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgIDsgY2xvc2VfbWF5X2Rlc3Ryb3lfYnVmIDogWyBgWWVzIHwgYE5vdF9ub3cgfCBgTm90X2V2ZXIgXVxuICAgICAgOyBjbG9zZV9maW5pc2hlZCA6IHVuaXQgSXZhci50XG4gICAgICA7IGZkID0gKGZkIHw+IHVubGVzc190ZXN0aW5nIDogKEZkLnQgb3B0aW9uW0BzZXhwLm9wdGlvbl0pKVxuICAgICAgOyBieXRlc19yZWFkIDogSW50NjMudFxuICAgICAgfV1cbiAgOztcblxuICBsZXQgaW52YXJpYW50IHQgOiB1bml0ID1cbiAgICBhc3NlcnQgKDAgPD0gdC5wb3MpO1xuICAgIGFzc2VydCAoMCA8PSB0LmF2YWlsYWJsZSk7XG4gICAgYXNzZXJ0ICh0LnBvcyArIHQuYXZhaWxhYmxlIDw9IEJpZ3N0cmluZy5sZW5ndGggdC5idWYpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSA/YnVmX2xlbiBmZCA9XG4gICAgbGV0IGJ1Zl9sZW4gPVxuICAgICAgbWF0Y2ggYnVmX2xlbiB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgKG1hdGNoIEZkLmtpbmQgZmQgd2l0aFxuICAgICAgICAgfCBDaGFyIHwgRmlsZSAtPiAzMiAqIDEwMjRcbiAgICAgICAgIHwgRmlmbyB8IFNvY2tldCBfIC0+XG4gICAgICAgICAgICgqIFRoaXMgZXF1YWxzIHRoZSB2YWx1ZSBiaWdzdHJpbmdfdW5peF9zdHVicy5jIHNldHMgTV9NTUFQX1RIUkVTSE9MRCB0by4gQXMgYVxuICAgICAgICAgICAgICByZXN1bHQsIHRoZXNlIGJ1ZmZlcnMgYXJlIGFsbG9jYXRlZCB1c2luZyBtbWFwLCBzbyB0aGV5IGFyZSByZXR1cm5lZCB0byB0aGVcbiAgICAgICAgICAgICAgT1Mgd2hlbiBPQ2FtbCBHQ3MgdGhlbS4gSWYgdGhpcyB3ZXJlIGxlc3MgdGhhbiBNX01NQVBfVEhSRVNIT0xELCB0aGUgYnVmZmVyc1xuICAgICAgICAgICAgICB3b3VsZCBiZSBhbGxvY2F0ZWQgd2l0aCBicmssIHNvIG1hbGxvYyBtaWdodCBob2xkIG9uIHRvIHRoZW0gZXZlbiBhZnRlclxuICAgICAgICAgICAgICBPQ2FtbCBHQ3MgdGhlbSwgd2hpY2ggY291bGQgX2luY3JlYXNlXyBtZW1vcnkgdXNhZ2UgZm9yIHByb2dyYW1zIHRoYXQgY3JlYXRlXG4gICAgICAgICAgICAgIG1hbnkgc3VjaCBidWZmZXJzLiAqKVxuICAgICAgICAgICAxMjggKiAxMDI0KVxuICAgICAgfCBTb21lIGJ1Zl9sZW4gLT5cbiAgICAgICAgaWYgYnVmX2xlbiA+IDBcbiAgICAgICAgdGhlbiBidWZfbGVuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICByYWlzZV9zXG4gICAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgICAgXCJSZWFkZXIuY3JlYXRlIGdvdCBub24gcG9zaXRpdmUgYnVmX2xlblwiIChidWZfbGVuIDogaW50KSAoZmQgOiBGZC50KV1cbiAgICBpblxuICAgIGxldCBvcGVuX2ZsYWdzID1cbiAgICAgICgqIEV2ZW4gdGhvdWdoIFtmY250bF0gaW4gZ2VuZXJhbCBjYW4gYmxvY2ssIFtmY250bF9nZXRmbF0gc2ltcGx5IHJlYWRzIGZsYWdzIHRoYXRcbiAgICAgICAgIGFyZSBhbHJlYWR5IGluIG1lbW9yeSwgc28gaXQgZG9lcyBub3QgbmVlZCB0byBiZSBydW4gaW4gYSBzZXBhcmF0ZSB0aHJlYWQuICopXG4gICAgICBGZC5zeXNjYWxsIGZkIChmdW4gZmlsZV9kZXNjciAtPiBDb3JlX3VuaXguZmNudGxfZ2V0ZmwgZmlsZV9kZXNjcilcbiAgICBpblxuICAgIHsgZmRcbiAgICA7IGlkID0gSWQuY3JlYXRlICgpXG4gICAgOyBieXRlc19yZWFkID0gSW50NjMuemVyb1xuICAgIDsgYnVmID0gQmlnc3RyaW5nLmNyZWF0ZSBidWZfbGVuXG4gICAgOyBjbG9zZV9tYXlfZGVzdHJveV9idWYgPSBgWWVzXG4gICAgOyBwb3MgPSAwXG4gICAgOyBhdmFpbGFibGUgPSAwXG4gICAgOyBzdGF0ZSA9IGBOb3RfaW5fdXNlXG4gICAgOyBjbG9zZV9maW5pc2hlZCA9IEl2YXIuY3JlYXRlICgpXG4gICAgOyBsYXN0X3JlYWRfdGltZSA9IFNjaGVkdWxlci5jeWNsZV9zdGFydCAoKVxuICAgIDsgb3Blbl9mbGFnc1xuICAgIH1cbiAgOztcblxuICBsZXQgb2ZfaW5fY2hhbm5lbCBpYyBraW5kID0gY3JlYXRlIChGZC5vZl9pbl9jaGFubmVsIGljIGtpbmQpXG5cbiAgbGV0IG9wZW5fZmlsZSA/YnVmX2xlbiBmaWxlID1cbiAgICBsZXQlbWFwIGZkID0gVW5peC5vcGVuZmlsZSBmaWxlIH5tb2RlOlsgYFJkb25seSBdIH5wZXJtOjBvMDAwIGluXG4gICAgY3JlYXRlIGZkID9idWZfbGVuXG4gIDs7XG5cbiAgbGV0IHN0ZGluID0gbGF6eSAoY3JlYXRlIChGZC5zdGRpbiAoKSkpXG4gIGxldCBjbG9zZV9maW5pc2hlZCB0ID0gSXZhci5yZWFkIHQuY2xvc2VfZmluaXNoZWRcblxuICBsZXQgaXNfY2xvc2VkIHQgPVxuICAgIG1hdGNoIHQuc3RhdGUgd2l0aFxuICAgIHwgYENsb3NlZCAtPiB0cnVlXG4gICAgfCBgTm90X2luX3VzZSB8IGBJbl91c2UgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgZW1wdHlfYnVmID0gQmlnc3RyaW5nLmNyZWF0ZSAwXG5cbiAgbGV0IGRlc3Ryb3kgdCA9XG4gICAgKCogQ2FsbGluZyBbdW5zYWZlX2Rlc3Ryb3ldIG9uIFt0XSdzIGJpZ3N0cmluZ3MgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgZmluYWxpemVycyB0b1xuICAgICAgIGZyZWUgdGhlbSBtYWtlcyB0aGVpciBzcGFjZSBpbW1lZGlhdGVseSBhdmFpbGFibGUgZm9yIHJldXNlIGJ5IEMncyBtYWxsb2MuICopXG4gICAgQmlnc3RyaW5nLnVuc2FmZV9kZXN0cm95IHQuYnVmO1xuICAgIHQuYnVmIDwtIGVtcHR5X2J1ZlxuICA7O1xuXG4gIGxldCBjbG9zZSB0ID1cbiAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgIHwgYENsb3NlZCAtPiAoKVxuICAgICB8IGBOb3RfaW5fdXNlIHwgYEluX3VzZSAtPlxuICAgICAgIHQuc3RhdGUgPC0gYENsb3NlZDtcbiAgICAgICB1cG9uIChVbml4LmNsb3NlIHQuZmQpIChmdW4gKCkgLT4gSXZhci5maWxsX2V4biB0LmNsb3NlX2ZpbmlzaGVkICgpKTtcbiAgICAgICB0LnBvcyA8LSAwO1xuICAgICAgIHQuYXZhaWxhYmxlIDwtIDA7XG4gICAgICAgKG1hdGNoIHQuY2xvc2VfbWF5X2Rlc3Ryb3lfYnVmIHdpdGhcbiAgICAgICAgfCBgWWVzIC0+IGRlc3Ryb3kgdFxuICAgICAgICB8IGBOb3Rfbm93IHwgYE5vdF9ldmVyIC0+ICgpKSk7XG4gICAgY2xvc2VfZmluaXNoZWQgdFxuICA7O1xuXG4gIGxldCB3aXRoX2Nsb3NlIHQgfmYgPSBNb25pdG9yLnByb3RlY3QgfnJ1bjpgU2NoZWR1bGUgZiB+ZmluYWxseTooZnVuICgpIC0+IGNsb3NlIHQpXG5cbiAgbGV0IHdpdGhfcmVhZGVyX2V4Y2x1c2l2ZSB0IGYgPVxuICAgIGxldCViaW5kICgpID0gVW5peC5sb2NrZiB0LmZkIFNoYXJlZCBpblxuICAgIE1vbml0b3IucHJvdGVjdCB+cnVuOmBTY2hlZHVsZSBmIH5maW5hbGx5OihmdW4gKCkgLT5cbiAgICAgIGlmIG5vdCAoRmQuaXNfY2xvc2VkIHQuZmQpIHRoZW4gVW5peC51bmxvY2tmIHQuZmQ7XG4gICAgICByZXR1cm4gKCkpXG4gIDs7XG5cbiAgbGV0IHdpdGhfZmlsZSA/YnVmX2xlbiA/KGV4Y2x1c2l2ZSA9IGZhbHNlKSBmaWxlIH5mID1cbiAgICBsZXQlYmluZCB0ID0gb3Blbl9maWxlID9idWZfbGVuIGZpbGUgaW5cbiAgICB3aXRoX2Nsb3NlIHQgfmY6KGZ1biAoKSAtPlxuICAgICAgaWYgZXhjbHVzaXZlIHRoZW4gd2l0aF9yZWFkZXJfZXhjbHVzaXZlIHQgKGZ1biAoKSAtPiBmIHQpIGVsc2UgZiB0KVxuICA7O1xuXG4gIGxldCByZWFkX3N5c2NhbGxfd2l0aF90aW1lc3RhbXAgZmQgfnBvcyB+bGVuIGJ1ZiA9XG4gICAgRmQud2l0aF9maWxlX2Rlc2NyX2RlZmVycmVkX3Jlc3VsdCBmZCAoZnVuIGZpbGVfZGVzY3IgLT5cbiAgICAgIG1hdGNoIElvX3VyaW5nX3Jhd19zaW5nbGV0b24udGhlX29uZV9hbmRfb25seSAoKSB3aXRoXG4gICAgICB8IFNvbWUgdXJpbmcgLT5cbiAgICAgICAgSW9fdXJpbmcucmVhZF9maWxlX2Rlc2NyIHVyaW5nIGZpbGVfZGVzY3Igfm9mZjpwb3MgfmxlbiBidWZcbiAgICAgICAgPj58IFJlc3VsdC5tYXAgfmY6KGZ1biByZXMgLT4gcmVzLCBUaW1lLm5vdyAoKSlcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBJbl90aHJlYWQuc3lzY2FsbCB+bmFtZTpcInJlYWRcIiAoZnVuICgpIC0+XG4gICAgICAgICAgbGV0IHJlcyA9IEJpZ3N0cmluZ191bml4LnJlYWQgZmlsZV9kZXNjciBidWYgfnBvcyB+bGVuIGluXG4gICAgICAgICAgcmVzLCBUaW1lLm5vdyAoKSkpXG4gIDs7XG5cbiAgKCogW2dldF9kYXRhIHRdIGF0dGVtcHRzIHRvIHJlYWQgZGF0YSBpbnRvIFt0LmJ1Zl0uICBJZiB0aGUgcmVhZCBnZXRzIGRhdGEsIFtnZXRfZGF0YV1cbiAgICAgcmV0dXJucyBbYE9rXSwgb3RoZXJ3aXNlIGl0IHJldHVybnMgW2BFb2ZdLiAqKVxuICBsZXQgZ2V0X2RhdGEgdCA6IFsgYE9rIHwgYEVvZiBdIERlZmVycmVkLnQgPVxuICAgIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgICAgbGV0IGVvZiAoKSA9IEl2YXIuZmlsbF9leG4gcmVzdWx0IGBFb2YgaW5cbiAgICAgIG1hdGNoIHQuc3RhdGUsIHQub3Blbl9mbGFncyB3aXRoXG4gICAgICB8IGBOb3RfaW5fdXNlLCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBgQ2xvc2VkLCBfIHwgXywgYEFscmVhZHlfY2xvc2VkIC0+IGVvZiAoKVxuICAgICAgfCBgSW5fdXNlLCAoKGBFcnJvciBfIHwgYE9rIF8pIGFzIG9wZW5fZmxhZ3MpIC0+XG4gICAgICAgIGxldCBjYW5fcmVhZF9mZCA9XG4gICAgICAgICAgbWF0Y2ggb3Blbl9mbGFncyB3aXRoXG4gICAgICAgICAgfCBgRXJyb3IgXyAtPiBmYWxzZVxuICAgICAgICAgIHwgYE9rIG9wZW5fZmxhZ3MgLT4gVW5peC5PcGVuX2ZsYWdzLmNhbl9yZWFkIG9wZW5fZmxhZ3NcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbm90IGNhbl9yZWFkX2ZkXG4gICAgICAgIHRoZW5cbiAgICAgICAgICByYWlzZV9zXG4gICAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgICAgXCJub3QgYWxsb3dlZCB0byByZWFkIGR1ZSB0byBmaWxlLWRlc2NyaXB0b3IgZmxhZ3NcIlxuICAgICAgICAgICAgICAgIChvcGVuX2ZsYWdzIDogb3Blbl9mbGFncylcbiAgICAgICAgICAgICAgICB+cmVhZGVyOih0IDogdCldO1xuICAgICAgICBsZXQgZWJhZGYgKCkgPVxuICAgICAgICAgICgqIElmIHRoZSBmaWxlIGRlc2NyaXB0b3IgaGFzIGJlZW4gY2xvc2VkLCB3ZSB3aWxsIGdldCBFQkFERiBmcm9tIGEgc3lzY2FsbC5cbiAgICAgICAgICAgICBJZiBzb21lb25lIGNsb3NlZCB0aGUgW0ZkLnRdIHVzaW5nIFtGZC5jbG9zZV0sIHRoZW4gdGhhdCBpcyBmaW5lLiAgQnV0IGlmIHRoZVxuICAgICAgICAgICAgIHVuZGVybHlpbmcgZmlsZSBkZXNjcmlwdG9yIGdvdCBjbG9zZWQgaW4gc29tZSBvdGhlciB3YXksIHRoZW4gc29tZXRoaW5nIGlzXG4gICAgICAgICAgICAgbGlrZWx5IHdyb25nLCBzbyB3ZSByYWlzZS4gKilcbiAgICAgICAgICByYWlzZV9zXG4gICAgICAgICAgICBbJW1lc3NhZ2UgXCJyZWFkZXIgZmlsZSBkZXNjcmlwdG9yIHdhcyB1bmV4cGVjdGVkbHkgY2xvc2VkXCIgfnJlYWRlcjoodCA6IHQpXVxuICAgICAgICBpblxuICAgICAgICBsZXQgZmluaXNoIHJlcyBoYW5kbGUgPVxuICAgICAgICAgIG1hdGNoIHJlcyB3aXRoXG4gICAgICAgICAgfCBgQWxyZWFkeV9jbG9zZWQgLT4gZW9mICgpXG4gICAgICAgICAgfCBgRXJyb3IgZXhuIC0+XG4gICAgICAgICAgICAobWF0Y2ggZXhuIHdpdGhcbiAgICAgICAgICAgICB8IEJpZ3N0cmluZ191bml4LklPRXJyb3IgKDAsIEVuZF9vZl9maWxlKVxuICAgICAgICAgICAgIHwgVW5peC5Vbml4X2Vycm9yXG4gICAgICAgICAgICAgICAgICggKCBFQ09OTlJFU0VUXG4gICAgICAgICAgICAgICAgICAgfCBFSE9TVFVOUkVBQ0hcbiAgICAgICAgICAgICAgICAgICB8IEVORVRET1dOXG4gICAgICAgICAgICAgICAgICAgfCBFTkVUUkVTRVRcbiAgICAgICAgICAgICAgICAgICB8IEVORVRVTlJFQUNIXG4gICAgICAgICAgICAgICAgICAgKCogV2hlbiB1c2luZyBPcGVuT25sb2FkLCByZWFkKCkgY2FuIHJldHVybiBFUElQRSBpZiBhIFRDUCBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgaXMgZXN0YWJsaXNoZWQgYW5kIHRoZW4gaW1tZWRpYXRlbHkgY2xvc2VkLiAqKVxuICAgICAgICAgICAgICAgICAgIHwgRVBJUEVcbiAgICAgICAgICAgICAgICAgICB8IEVUSU1FRE9VVCApXG4gICAgICAgICAgICAgICAgICwgX1xuICAgICAgICAgICAgICAgICAsIF8gKSAtPiBlb2YgKClcbiAgICAgICAgICAgICB8IFVuaXguVW5peF9lcnJvciAoRUJBREYsIF8sIF8pIC0+IGViYWRmICgpXG4gICAgICAgICAgICAgfCBfIC0+IGhhbmRsZSBleG4pXG4gICAgICAgICAgfCBgT2sgKGJ5dGVzX3JlYWQsIHJlYWRfdGltZSkgLT5cbiAgICAgICAgICAgIHQuYnl0ZXNfcmVhZCA8LSBJbnQ2My4odC5ieXRlc19yZWFkICsgb2ZfaW50IGJ5dGVzX3JlYWQpO1xuICAgICAgICAgICAgaWYgYnl0ZXNfcmVhZCA9IDBcbiAgICAgICAgICAgIHRoZW4gZW9mICgpXG4gICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgdC5wb3MgPC0gMDtcbiAgICAgICAgICAgICAgdC5hdmFpbGFibGUgPC0gdC5hdmFpbGFibGUgKyBieXRlc19yZWFkO1xuICAgICAgICAgICAgICB0Lmxhc3RfcmVhZF90aW1lIDwtIHJlYWRfdGltZTtcbiAgICAgICAgICAgICAgSXZhci5maWxsX2V4biByZXN1bHQgYE9rKVxuICAgICAgICBpblxuICAgICAgICBsZXQgYnVmID0gdC5idWYgaW5cbiAgICAgICAgaWYgdC5hdmFpbGFibGUgPiAwICYmIHQucG9zID4gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBCaWdzdHJpbmcuYmxpdCB+c3JjOmJ1ZiB+c3JjX3Bvczp0LnBvcyB+ZHN0OmJ1ZiB+ZHN0X3BvczowIH5sZW46dC5hdmFpbGFibGU7XG4gICAgICAgICAgdC5wb3MgPC0gMCk7XG4gICAgICAgIGxldCBwb3MgPSB0LmF2YWlsYWJsZSBpblxuICAgICAgICBsZXQgbGVuID0gQmlnc3RyaW5nLmxlbmd0aCBidWYgLSBwb3MgaW5cbiAgICAgICAgaWYgbm90IChGZC5zdXBwb3J0c19ub25ibG9jayB0LmZkKVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAobWF0Y2ggdC5jbG9zZV9tYXlfZGVzdHJveV9idWYgd2l0aFxuICAgICAgICAgICB8IGBZZXMgLT4gdC5jbG9zZV9tYXlfZGVzdHJveV9idWYgPC0gYE5vdF9ub3dcbiAgICAgICAgICAgfCBgTm90X25vdyB8IGBOb3RfZXZlciAtPiAoKSk7XG4gICAgICAgICAgcmVhZF9zeXNjYWxsX3dpdGhfdGltZXN0YW1wIHQuZmQgfnBvcyB+bGVuIGJ1ZlxuICAgICAgICAgID4+PiBmdW4gcmVzIC0+XG4gICAgICAgICAgKG1hdGNoIHQuY2xvc2VfbWF5X2Rlc3Ryb3lfYnVmIHdpdGhcbiAgICAgICAgICAgfCBgTm90X25vdyAtPiB0LmNsb3NlX21heV9kZXN0cm95X2J1ZiA8LSBgWWVzXG4gICAgICAgICAgIHwgYFllcyB8IGBOb3RfZXZlciAtPiAoKSk7XG4gICAgICAgICAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICAgfCBgTm90X2luX3VzZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IGBJbl91c2UgLT4gZmluaXNoIHJlcyByYWlzZVxuICAgICAgICAgIHwgYENsb3NlZCAtPlxuICAgICAgICAgICAgKCogSWYgd2UncmUgaGVyZSwgc29tZWJvZHkgW2Nsb3NlXWQgdGhlIHJlYWRlciB3aGlsZSB3ZSB3ZXJlIG1ha2luZyB0aGUgc3lzdGVtXG4gICAgICAgICAgICAgICBjYWxsLiAgW2Nsb3NlXSBjb3VsZG4ndCBbZGVzdHJveV0sIHNvIHdlIG5lZWQgdG8uICopXG4gICAgICAgICAgICBkZXN0cm95IHQ7XG4gICAgICAgICAgICBlb2YgKCkpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICAgICAgICAoKiBGb3JjZSB0aGUgYXN5bmMgY3ljbGUgdG8gZW5kIGJldHdlZW4gcmVhZHMsIGFsbG93aW5nIG90aGVycyB0byBydW4uICopXG4gICAgICAgICAgICBGZC5yZWFkeV90byB0LmZkIGBSZWFkXG4gICAgICAgICAgICA+Pj4gZnVuY3Rpb25cbiAgICAgICAgICAgIHwgYEJhZF9mZCAtPiBlYmFkZiAoKVxuICAgICAgICAgICAgfCBgQ2xvc2VkIC0+IGVvZiAoKVxuICAgICAgICAgICAgfCBgUmVhZHkgLT5cbiAgICAgICAgICAgICAgKCogVGhlcmUgaXMgYSByYWNlIGJldHdlZW4gdGhlIFtyZWFkeV90b10gYmVjb21pbmcgZGV0ZXJtaW5lZCBhbmQgc29tZW9uZVxuICAgICAgICAgICAgICAgICBbY2xvc2VdaW5nIFt0XS4gIEl0IGlzIHBvc3NpYmxlIHRvIGdldCBbYFJlYWR5XSBhbmQgdGhlbiBieSB0aGUgdGltZSB3ZVxuICAgICAgICAgICAgICAgICBnZXQgaGVyZSwgW3RdIGlzIGNsb3NlZC4gKilcbiAgICAgICAgICAgICAgKG1hdGNoIHQuc3RhdGUgd2l0aFxuICAgICAgICAgICAgICAgfCBgTm90X2luX3VzZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgICAgIHwgYENsb3NlZCAtPiBlb2YgKClcbiAgICAgICAgICAgICAgIHwgYEluX3VzZSAtPlxuICAgICAgICAgICAgICAgICBmaW5pc2hcbiAgICAgICAgICAgICAgICAgICAoRmQuc3lzY2FsbCB0LmZkIH5ub25ibG9ja2luZzp0cnVlIChmdW4gZmlsZV9kZXNjciAtPlxuICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgVW5peC5TeXNjYWxsX3Jlc3VsdC5JbnQub2tfb3JfdW5peF9lcnJvcl9leG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKEJpZ3N0cmluZ191bml4LnJlYWRfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfZGVzY3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5wb3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfmxlbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfnN5c2NhbGxfbmFtZTpcInJlYWRcIlxuICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgcmVzLCBTY2hlZHVsZXIuY3ljbGVfc3RhcnQgKCkpKVxuICAgICAgICAgICAgICAgICAgIChmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAoKiBTaW5jZSBbdC5mZF0gaXMgcmVhZHksIHdlIHNob3VsZCBuZXZlciBzZWUgRVdPVUxEQkxPQ0sgb3IgRUFHQUlOLlxuICAgICAgICAgICAgICAgICAgICAgICAgQnV0IHdlIGRvbid0IHRydXN0IHRoZSBPUy4gIFNvLCBpbiBjYXNlIGl0IGRvZXMsIHdlIGp1c3QgdHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2Fpbi4gKilcbiAgICAgICAgICAgICAgICAgICAgfCBVbml4LlVuaXhfZXJyb3IgKChFV09VTERCTE9DSyB8IEVBR0FJTiksIF8sIF8pIC0+IGxvb3AgKClcbiAgICAgICAgICAgICAgICAgICAgfCBleG4gLT4gcmFpc2UgZXhuKSlcbiAgICAgICAgICBpblxuICAgICAgICAgIGxvb3AgKCkpKVxuICA7O1xuXG4gICgqKiBHcm93IHRoZSBidWZmZXIgbGVuZ3RoIGlmIGl0cyBzaXplIGlzIGxlc3MgdGhhbiBbZGVzaXJlZF0uXG4gICAgICBJZiB0aGUgcmVxdWVzdGVkIGdyb3d0aCBpcyB0b28gbGFyZ2UsIHdlIG9ubHkgZ3JvdyB0aGUgYnVmZmVyIHRvIH40eCB0aGUgc2l6ZS5cbiAgICAgIFRoZSByZWFzb24gaXMgdGhhdCB0aGUgW2Rlc2lyZWRdIHZhbHVlIGlzIG9mdGVuIHJlYWQgZnJvbSB0aGUgZGF0YSBzdHJlYW0sXG4gICAgICBhbmQgd2UgZG9uJ3Qgd2FudCB0byBydW4gb3V0IG9mIG1lbW9yeSBpZiB3ZSByZWFkIGFuIGFic3VyZCBbZGVzaXJlZF0gdmFsdWUgZnJvbVxuICAgICAgdGhlIGRhdGEgc3RyZWFtLiAqKVxuICBsZXQgbWF5YmVfZ3Jvd19idWZfbGVuIHQgfmRlc2lyZWQgPVxuICAgIGxldCBidWZfbGVuID0gQmlnc3RyaW5nLmxlbmd0aCB0LmJ1ZiBpblxuICAgIGlmIGJ1Zl9sZW4gPCBkZXNpcmVkXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbmV3X2J1ZiA9XG4gICAgICAgIGxldCBuZXdfYnVmX2xlbiA9XG4gICAgICAgICAgaWYgZGVzaXJlZCA8IDIgKiBidWZfbGVuXG4gICAgICAgICAgdGhlbiAyICogYnVmX2xlblxuICAgICAgICAgIGVsc2UgaWYgZGVzaXJlZCA8IDggKiBidWZfbGVuXG4gICAgICAgICAgICAgICAgICAoKiBTbGlnaHRseSBtb3JlIHdpbGxpbmcgdG8gZ3JvdyB0aGUgYnVmZmVyIGlmIHRoYXQgYnJpbmdzIHVzIGV4YWN0bHkgdG9cbiAgICAgICAgICAgICBbZGVzaXJlZF0sIHNvIGdyb3cgYnkgOHggaGVyZSBpbnN0ZWFkIG9mIDR4LlxuXG4gICAgICAgICAgICAgVGhpcyB0cmljayBpcyB0byBhdm9pZCBncm93aW5nIGFib3ZlIFtkZXNpcmVkXSB3aGVuIFttYXliZV9ncm93X2J1Zl9sZW5dIGlzXG4gICAgICAgICAgICAgY2FsbGVkIG11bHRpcGxlIHRpbWVzLiAqKVxuICAgICAgICAgIHRoZW4gZGVzaXJlZFxuICAgICAgICAgIGVsc2UgNCAqIGJ1Zl9sZW5cbiAgICAgICAgaW5cbiAgICAgICAgQmlnc3RyaW5nLmNyZWF0ZSBuZXdfYnVmX2xlblxuICAgICAgaW5cbiAgICAgIGlmIHQuYXZhaWxhYmxlID4gMFxuICAgICAgdGhlblxuICAgICAgICBCaWdzdHJpbmcuYmxpdCB+c3JjOnQuYnVmIH5zcmNfcG9zOnQucG9zIH5sZW46dC5hdmFpbGFibGUgfmRzdDpuZXdfYnVmIH5kc3RfcG9zOjA7XG4gICAgICB0LmJ1ZiA8LSBuZXdfYnVmO1xuICAgICAgdC5wb3MgPC0gMClcbiAgOztcblxuICAoKiBbZ2V0X2RhdGFfdW50aWxdIGNhbGxzIFtnZXRfZGF0YV0gdG8gcmVhZCBpbnRvIFt0LmJ1Zl0gdW50aWwgW3QuYXZhaWxhYmxlID49XG4gICAgIGF2YWlsYWJsZV9hdF9sZWFzdF0sIG9yIHVudGlsIGl0IHJlYWNoZXMgRU9GLiAgSXQgcmV0dXJucyBbYE9rXSBpZiBbdC5hdmFpbGFibGUgPj1cbiAgICAgYXZhaWxhYmxlX2F0X2xlYXN0XSwgYW5kIFtgRW9mXSBpZiBub3QuICopXG4gIGxldCBnZXRfZGF0YV91bnRpbCB0IH5hdmFpbGFibGVfYXRfbGVhc3QgPVxuICAgIGlmIHQuYXZhaWxhYmxlID49IGF2YWlsYWJsZV9hdF9sZWFzdFxuICAgIHRoZW4gcmV0dXJuIGBPa1xuICAgIGVsc2UgKFxuICAgICAgbWF5YmVfZ3Jvd19idWZfbGVuIHQgfmRlc2lyZWQ6YXZhaWxhYmxlX2F0X2xlYXN0O1xuICAgICAgaWYgdC5wb3MgPiAwXG4gICAgICB0aGVuIChcbiAgICAgICAgQmlnc3RyaW5nLmJsaXQgfnNyYzp0LmJ1ZiB+c3JjX3Bvczp0LnBvcyB+ZHN0OnQuYnVmIH5kc3RfcG9zOjAgfmxlbjp0LmF2YWlsYWJsZTtcbiAgICAgICAgdC5wb3MgPC0gMCk7XG4gICAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgICBsZXQlYmluZCByZXN1bHQgPSBnZXRfZGF0YSB0IGluXG4gICAgICAgIGlmIHQuYXZhaWxhYmxlID49IGF2YWlsYWJsZV9hdF9sZWFzdFxuICAgICAgICB0aGVuIHJldHVybiBgT2tcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IGBFb2YgLT4gcmV0dXJuIChgRW9mIHQuYXZhaWxhYmxlKVxuICAgICAgICAgIHwgYE9rIC0+XG4gICAgICAgICAgICBpZiB0LmF2YWlsYWJsZSA9IEJpZ3N0cmluZy5sZW5ndGggdC5idWZcbiAgICAgICAgICAgIHRoZW4gbWF5YmVfZ3Jvd19idWZfbGVuIHQgfmRlc2lyZWQ6YXZhaWxhYmxlX2F0X2xlYXN0O1xuICAgICAgICAgICAgbG9vcCAoKSlcbiAgICAgIGluXG4gICAgICBsb29wICgpKVxuICA7O1xuXG4gICgqIFt3aXRoX25vbmVtcHR5X2J1ZmZlciB0IGZdIHdhaXRzIGZvciBbdC5idWZdIHRvIGhhdmUgZGF0YSwgYW5kIHRoZW4gcmV0dXJucyBbZiBgT2tdLlxuICAgICBJZiBubyBkYXRhIGNhbiBiZSByZWFkLCB0aGVuIFt3aXRoX25vbmVtcHR5X2J1ZmZlcl0gcmV0dXJucyBbZiBgRW9mXS5cbiAgICAgW3dpdGhfbm9uZW1wdHlfYnVmZmVyXSBtdXN0IGJlIGNhbGxlZCB3aXRoIFt0LnN0YXRlXSBhcyBbYENsb3NlZF0gb3IgW2BJbl91c2VdLiAgSXRcbiAgICAgZ3VhcmFudGVlcyB0aGF0IGlmIFtmIGBPa10gaXMgY2FsbGVkLCB0aGF0IFt0LnN0YXRlID0gYEluX3VzZV0uICopXG4gIGxldCB3aXRoX25vbmVtcHR5X2J1ZmZlciAodHlwZSBhKSB0IChmIDogWyBgT2sgfCBgRW9mIF0gLT4gYSkgOiBhIERlZmVycmVkLnQgPVxuICAgIG1hdGNoIHQuc3RhdGUgd2l0aFxuICAgIHwgYE5vdF9pbl91c2UgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBgQ2xvc2VkIC0+IHJldHVybiAoZiBgRW9mKVxuICAgIHwgYEluX3VzZSAtPlxuICAgICAgaWYgdC5hdmFpbGFibGUgPiAwXG4gICAgICB0aGVuIHJldHVybiAoZiBgT2spXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0JW1hcCBva19vcl9lb2YgPSBnZXRfZGF0YSB0IGluXG4gICAgICAgIG1hdGNoIHQuc3RhdGUgd2l0aFxuICAgICAgICB8IGBOb3RfaW5fdXNlIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICB8IGBDbG9zZWQgLT4gZiBgRW9mXG4gICAgICAgIHwgYEluX3VzZSAtPiBmIG9rX29yX2VvZilcbiAgOztcblxuICAoKiBbd2l0aF9ub25lbXB0eV9idWZmZXInIHQgZl0gaXMgYW4gb3B0aW1pemVkIHZlcnNpb24gb2ZcbiAgICAgW2Rvbid0X3dhaXRfZm9yICh3aXRoX25vbmVtcHR5X2J1ZmZlciB0IGYpXS5cblxuICAgICBXaXRoIFtmb3JjZV9yZWZpbGwgPSB0cnVlXSwgW3dpdGhfbm9uZW1wdHlfYnVmZmVyJ10gd2lsbCBkbyBhIHJlYWQsIHdoZXRoZXIgb3Igbm90XG4gICAgIHRoZXJlIGlzIGFscmVhZHkgZGF0YSBhdmFpbGFibGUgaW4gW3QuYnVmXS4gKilcbiAgbGV0IHdpdGhfbm9uZW1wdHlfYnVmZmVyJyA/KGZvcmNlX3JlZmlsbCA9IGZhbHNlKSB0IChmIDogWyBgT2sgfCBgRW9mIF0gLT4gdW5pdCkgOiB1bml0ID1cbiAgICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgICB8IGBOb3RfaW5fdXNlIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgYENsb3NlZCAtPiBmIGBFb2ZcbiAgICB8IGBJbl91c2UgLT5cbiAgICAgIGlmIChub3QgZm9yY2VfcmVmaWxsKSAmJiB0LmF2YWlsYWJsZSA+IDBcbiAgICAgIHRoZW4gZiBgT2tcbiAgICAgIGVsc2VcbiAgICAgICAgZ2V0X2RhdGEgdFxuICAgICAgICA+Pj4gZnVuIG9rX29yX2VvZiAtPlxuICAgICAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICB8IGBOb3RfaW5fdXNlIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgfCBgQ2xvc2VkIC0+IGYgYEVvZlxuICAgICAgICAgfCBgSW5fdXNlIC0+IGYgb2tfb3JfZW9mKVxuICA7O1xuXG4gIGxldCBjb25zdW1lIHQgYW1vdW50ID1cbiAgICBhc3NlcnQgKDAgPD0gYW1vdW50ICYmIGFtb3VudCA8PSB0LmF2YWlsYWJsZSk7XG4gICAgdC5wb3MgPC0gdC5wb3MgKyBhbW91bnQ7XG4gICAgdC5hdmFpbGFibGUgPC0gdC5hdmFpbGFibGUgLSBhbW91bnRcbiAgOztcblxuICB0eXBlICdhIGhhbmRsZV9jaHVua19yZXN1bHQgPVxuICAgIFsgYFN0b3Agb2YgJ2FcbiAgICB8IGBTdG9wX2NvbnN1bWVkIG9mICdhICogaW50XG4gICAgfCBgQ29udGludWVcbiAgICB8IGBDb25zdW1lZCBvZiBpbnQgKiBbIGBOZWVkIG9mIGludCB8IGBOZWVkX3Vua25vd24gXVxuICAgIF1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlICdhIHJlYWRfb25lX2NodW5rX2F0X2FfdGltZV9yZXN1bHQgPVxuICAgIFsgYEVvZlxuICAgIHwgYFN0b3BwZWQgb2YgJ2FcbiAgICB8IGBFb2Zfd2l0aF91bmNvbnN1bWVkX2RhdGEgb2Ygc3RyaW5nXG4gICAgXVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgY29uc3VtZWQgPSBbIGBDb25zdW1lZCBvZiBpbnQgKiBbIGBOZWVkIG9mIGludCB8IGBOZWVkX3Vua25vd24gXSBdXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IHJlYWRfb25lX2NodW5rX2F0X2FfdGltZSB0IH5oYW5kbGVfY2h1bmsgPVxuICAgIHQuY2xvc2VfbWF5X2Rlc3Ryb3lfYnVmIDwtIGBOb3RfZXZlcjtcbiAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBmaW5hbF9yZXN1bHQgLT5cbiAgICAgIGxldCByZWMgbG9vcCB+Zm9yY2VfcmVmaWxsID1cbiAgICAgICAgd2l0aF9ub25lbXB0eV9idWZmZXInIHQgfmZvcmNlX3JlZmlsbCAoZnVuY3Rpb25cbiAgICAgICAgICB8IGBFb2YgLT5cbiAgICAgICAgICAgIGxldCByZXN1bHQgPVxuICAgICAgICAgICAgICBpZiB0LmF2YWlsYWJsZSA+IDBcbiAgICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgIGBFb2Zfd2l0aF91bmNvbnN1bWVkX2RhdGFcbiAgICAgICAgICAgICAgICAgIChCaWdzdHJpbmcudG9fc3RyaW5nIHQuYnVmIH5wb3M6dC5wb3Mgfmxlbjp0LmF2YWlsYWJsZSlcbiAgICAgICAgICAgICAgZWxzZSBgRW9mXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgSXZhci5maWxsX2V4biBmaW5hbF9yZXN1bHQgcmVzdWx0XG4gICAgICAgICAgfCBgT2sgLT5cbiAgICAgICAgICAgIGxldCBsZW4gPSB0LmF2YWlsYWJsZSBpblxuICAgICAgICAgICAgbGV0IGNvbnRpbnVlIHogPVxuICAgICAgICAgICAgICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgICAgICAgICAgICAgfCBgTm90X2luX3VzZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgICAgfCBgQ2xvc2VkIC0+IEl2YXIuZmlsbF9leG4gZmluYWxfcmVzdWx0IGBFb2ZcbiAgICAgICAgICAgICAgfCBgSW5fdXNlIC0+XG4gICAgICAgICAgICAgICAgKG1hdGNoIHogd2l0aFxuICAgICAgICAgICAgICAgICB8IGBTdG9wIGEgLT5cbiAgICAgICAgICAgICAgICAgICBjb25zdW1lIHQgbGVuO1xuICAgICAgICAgICAgICAgICAgIEl2YXIuZmlsbF9leG4gZmluYWxfcmVzdWx0IChgU3RvcHBlZCBhKVxuICAgICAgICAgICAgICAgICB8IGBTdG9wX2NvbnN1bWVkIChhLCBjb25zdW1lZCkgLT5cbiAgICAgICAgICAgICAgICAgICBjb25zdW1lIHQgY29uc3VtZWQ7XG4gICAgICAgICAgICAgICAgICAgSXZhci5maWxsX2V4biBmaW5hbF9yZXN1bHQgKGBTdG9wcGVkIGEpXG4gICAgICAgICAgICAgICAgIHwgYENvbnRpbnVlIC0+XG4gICAgICAgICAgICAgICAgICAgY29uc3VtZSB0IGxlbjtcbiAgICAgICAgICAgICAgICAgICBsb29wIH5mb3JjZV9yZWZpbGw6dHJ1ZVxuICAgICAgICAgICAgICAgICB8IGBDb25zdW1lZCAoY29uc3VtZWQsIG5lZWQpIGFzIGMgLT5cbiAgICAgICAgICAgICAgICAgICBpZiBjb25zdW1lZCA8IDBcbiAgICAgICAgICAgICAgICAgICAgICB8fCBjb25zdW1lZCA+IGxlblxuICAgICAgICAgICAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggbmVlZCB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgfCBgTmVlZF91bmtub3duIC0+IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgfCBgTmVlZCBuZWVkIC0+IG5lZWQgPCAwIHx8IGNvbnN1bWVkICsgbmVlZCA8PSBsZW5cbiAgICAgICAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICAgICAgICByYWlzZV9zXG4gICAgICAgICAgICAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgIFwiaGFuZGxlX2NodW5rIHJldHVybmVkIGludmFsaWQgYENvbnN1bWVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH5fOihjIDogY29uc3VtZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAobGVuIDogaW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfnJlYWRlcjoodCA6IHQpXTtcbiAgICAgICAgICAgICAgICAgICBjb25zdW1lIHQgY29uc3VtZWQ7XG4gICAgICAgICAgICAgICAgICAgbGV0IGJ1Zl9sZW4gPSBCaWdzdHJpbmcubGVuZ3RoIHQuYnVmIGluXG4gICAgICAgICAgICAgICAgICAgbGV0IG5ld19sZW4gPVxuICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggbmVlZCB3aXRoXG4gICAgICAgICAgICAgICAgICAgICB8IGBOZWVkX3Vua25vd24gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgaWYgdC5hdmFpbGFibGUgPSBidWZfbGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIFRoZSBidWZmZXIgaXMgZnVsbCBhbmQgdGhlIGNsaWVudCBkb2Vzbid0IGtub3cgaG93IG11Y2ggdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0OiBkb3VibGUgdGhlIGJ1ZmZlciBzaXplLiAqKVxuICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGJ1Zl9sZW4gKiAyXG4gICAgICAgICAgICAgICAgICAgICAgIGVsc2UgYnVmX2xlblxuICAgICAgICAgICAgICAgICAgICAgfCBgTmVlZCBuZWVkIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIGlmIG5lZWQgPiBidWZfbGVuIHRoZW4gSW50Lm1heCBuZWVkIChidWZfbGVuICogMikgZWxzZSBidWZfbGVuXG4gICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICBpZiBuZXdfbGVuIDwgMFxuICAgICAgICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWFkX29uZV9jaHVua19hdF9hX3RpbWUgZ290IG92ZXJmbG93IGluIGJ1ZmZlciBsZW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfnJlYWRlcjoodCA6IHRfaW50ZXJuYWxzKV07XG4gICAgICAgICAgICAgICAgICAgKCogR3JvdyB0aGUgaW50ZXJuYWwgYnVmZmVyIGlmIG5lZWRlZC4gKilcbiAgICAgICAgICAgICAgICAgICBpZiBuZXdfbGVuID4gYnVmX2xlblxuICAgICAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld19idWYgPSBCaWdzdHJpbmcuY3JlYXRlIG5ld19sZW4gaW5cbiAgICAgICAgICAgICAgICAgICAgIGlmIHQuYXZhaWxhYmxlID4gMFxuICAgICAgICAgICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICBCaWdzdHJpbmcuYmxpdFxuICAgICAgICAgICAgICAgICAgICAgICAgIH5zcmM6dC5idWZcbiAgICAgICAgICAgICAgICAgICAgICAgICB+c3JjX3Bvczp0LnBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgIH5sZW46dC5hdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICB+ZHN0Om5ld19idWZcbiAgICAgICAgICAgICAgICAgICAgICAgICB+ZHN0X3BvczowO1xuICAgICAgICAgICAgICAgICAgICAgdC5idWYgPC0gbmV3X2J1ZjtcbiAgICAgICAgICAgICAgICAgICAgIHQucG9zIDwtIDApO1xuICAgICAgICAgICAgICAgICAgIGxvb3AgfmZvcmNlX3JlZmlsbDp0cnVlKVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxldCBkZWZlcnJlZCA9IGhhbmRsZV9jaHVuayB0LmJ1ZiB+cG9zOnQucG9zIH5sZW4gaW5cbiAgICAgICAgICAgIChtYXRjaCBEZWZlcnJlZC5wZWVrIGRlZmVycmVkIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gZGVmZXJyZWQgPj4+IGNvbnRpbnVlXG4gICAgICAgICAgICAgfCBTb21lIHJlc3VsdCAtPiBjb250aW51ZSByZXN1bHQpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgfmZvcmNlX3JlZmlsbDpmYWxzZSlcbiAgOztcblxuICB0eXBlICdhIGhhbmRsZV9pb2J1Zl9yZXN1bHQgPVxuICAgIFsgYFN0b3Agb2YgJ2FcbiAgICB8IGBDb250aW51ZVxuICAgIF1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgcmVhZF9vbmVfaW9idWZfYXRfYV90aW1lIHQgfmhhbmRsZV9jaHVuayA9XG4gICAgbGV0IGlvYnVmID0gSW9idWYub2ZfYmlnc3RyaW5nIHQuYnVmIGluXG4gICAgcmVhZF9vbmVfY2h1bmtfYXRfYV90aW1lIHQgfmhhbmRsZV9jaHVuazooZnVuIGJzdHIgfnBvcyB+bGVuIC0+XG4gICAgICBJb2J1Zi5FeHBlcnQucmVpbml0aWFsaXplX29mX2JpZ3N0cmluZyBpb2J1ZiBic3RyIH5wb3MgfmxlbjtcbiAgICAgIGxldCVtYXAgaGFuZGxlX3Jlc3VsdCA9IGhhbmRsZV9jaHVuayBpb2J1ZiBpblxuICAgICAgaWYgSW9idWYuaXNfZW1wdHkgaW9idWYgKCogW2lzX2VtcHR5XSBpbXBsaWVzIGFsbCBkYXRhIHdhcyBjb25zdW1lZCAqKVxuICAgICAgdGhlbiAoaGFuZGxlX3Jlc3VsdCA6PiBfIGhhbmRsZV9jaHVua19yZXN1bHQpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGNvbnN1bWVkID0gbGVuIC0gSW9idWYubGVuZ3RoIGlvYnVmIGluXG4gICAgICAgIG1hdGNoIGhhbmRsZV9yZXN1bHQgd2l0aFxuICAgICAgICB8IGBDb250aW51ZSAtPiBgQ29uc3VtZWQgKGNvbnN1bWVkLCBgTmVlZF91bmtub3duKVxuICAgICAgICB8IGBTdG9wIGEgLT4gYFN0b3BfY29uc3VtZWQgKGEsIGNvbnN1bWVkKSkpXG4gIDs7XG5cbiAgbW9kdWxlIFJlYWRcbiAgICAoUyA6IFN1YnN0cmluZ19pbnRmLlMpIChOYW1lIDogc2lnXG4gICAgICB2YWwgbmFtZSA6IHN0cmluZ1xuICAgIGVuZCkgPVxuICBzdHJ1Y3RcbiAgICBsZXQgcmVhZF9hdmFpbGFibGUgdCBzID1cbiAgICAgIGxldCBsZW4gPSBJbnQubWluIHQuYXZhaWxhYmxlIChTLmxlbmd0aCBzKSBpblxuICAgICAgUy5ibGl0X2Zyb21fYmlnc3RyaW5nIHMgfnNyYzp0LmJ1ZiB+c3JjX3Bvczp0LnBvcyB+bGVuO1xuICAgICAgY29uc3VtZSB0IGxlbjtcbiAgICAgIGxlblxuICAgIDs7XG5cbiAgICBsZXQgcmVhZCB0IHMgPVxuICAgICAgaWYgUy5sZW5ndGggcyA9IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJSZWFkZXIucmVhZF8lcyB3aXRoIGVtcHR5IHN0cmluZ1wiIE5hbWUubmFtZSAoKTtcbiAgICAgIHdpdGhfbm9uZW1wdHlfYnVmZmVyIHQgKGZ1bmN0aW9uXG4gICAgICAgIHwgYE9rIC0+IGBPayAocmVhZF9hdmFpbGFibGUgdCBzKVxuICAgICAgICB8IGBFb2YgLT4gYEVvZilcbiAgICA7O1xuXG4gICAgbGV0IHJlYWxseV9yZWFkIHQgcyA9XG4gICAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICAgICAgbGV0IHJlYyBsb29wIHMgYW1vdW50X3JlYWQgPVxuICAgICAgICAgIGlmIFMubGVuZ3RoIHMgPSAwXG4gICAgICAgICAgdGhlbiBJdmFyLmZpbGxfZXhuIHJlc3VsdCBgT2tcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZWFkIHQgc1xuICAgICAgICAgICAgPj4+IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGBFb2YgLT4gSXZhci5maWxsX2V4biByZXN1bHQgKGBFb2YgYW1vdW50X3JlYWQpXG4gICAgICAgICAgICB8IGBPayBsZW4gLT4gbG9vcCAoUy5kcm9wX3ByZWZpeCBzIGxlbikgKGFtb3VudF9yZWFkICsgbGVuKVxuICAgICAgICBpblxuICAgICAgICBsb29wIHMgMClcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgUmVhZF9zdWJzdHJpbmcgPVxuICAgIFJlYWRcbiAgICAgIChTdWJzdHJpbmcpXG4gICAgICAoc3RydWN0XG4gICAgICAgIGxldCBuYW1lID0gXCJzdWJzdHJpbmdcIlxuICAgICAgZW5kKVxuXG4gIGxldCByZWFkX3N1YnN0cmluZ19hdmFpbGFibGUgPSBSZWFkX3N1YnN0cmluZy5yZWFkX2F2YWlsYWJsZVxuICBsZXQgcmVhZF9zdWJzdHJpbmcgPSBSZWFkX3N1YnN0cmluZy5yZWFkXG4gIGxldCByZWFsbHlfcmVhZF9zdWJzdHJpbmcgPSBSZWFkX3N1YnN0cmluZy5yZWFsbHlfcmVhZFxuXG4gIG1vZHVsZSBSZWFkX2JpZ3N1YnN0cmluZyA9XG4gICAgUmVhZFxuICAgICAgKEJpZ3N1YnN0cmluZylcbiAgICAgIChzdHJ1Y3RcbiAgICAgICAgbGV0IG5hbWUgPSBcImJpZ3N1YnN0cmluZ1wiXG4gICAgICBlbmQpXG5cbiAgbGV0IHJlYWRfYmlnc3Vic3RyaW5nID0gUmVhZF9iaWdzdWJzdHJpbmcucmVhZFxuICBsZXQgcmVhbGx5X3JlYWRfYmlnc3Vic3RyaW5nID0gUmVhZF9iaWdzdWJzdHJpbmcucmVhbGx5X3JlYWRcblxuICBsZXQgcmVhbGx5X3JlYWRfYmlnc3RyaW5nIHQgYmlnc3RyaW5nID1cbiAgICByZWFsbHlfcmVhZF9iaWdzdWJzdHJpbmcgdCAoQmlnc3Vic3RyaW5nLmNyZWF0ZSBiaWdzdHJpbmcpXG4gIDs7XG5cbiAgbGV0IHBlZWtfYXZhaWxhYmxlIHQgfmxlbiA9XG4gICAgQmlnc3RyaW5nLnRvX3N0cmluZyB0LmJ1ZiB+cG9zOnQucG9zIH5sZW46KEludC5taW4gbGVuIHQuYXZhaWxhYmxlKVxuICA7O1xuXG4gIGxldCBwZWVrIHQgfmxlbiA9XG4gICAgbWF0Y2glbWFwIGdldF9kYXRhX3VudGlsIHQgfmF2YWlsYWJsZV9hdF9sZWFzdDpsZW4gd2l0aFxuICAgIHwgYEVvZiAoXyA6IGludCkgLT5cbiAgICAgIGFzc2VydCAodC5hdmFpbGFibGUgPCBsZW4pO1xuICAgICAgYEVvZlxuICAgIHwgYE9rIC0+XG4gICAgICBhc3NlcnQgKHQuYXZhaWxhYmxlID49IGxlbik7XG4gICAgICBgT2sgKEJpZ3N0cmluZy50b19zdHJpbmcgdC5idWYgfnBvczp0LnBvcyB+bGVuKVxuICA7O1xuXG4gIGxldCByZWFkX2F2YWlsYWJsZSB0ID9wb3MgP2xlbiBzID1cbiAgICByZWFkX3N1YnN0cmluZ19hdmFpbGFibGUgdCAoU3Vic3RyaW5nLmNyZWF0ZSBzID9wb3MgP2xlbilcbiAgOztcblxuICBsZXQgcmVhZCB0ID9wb3MgP2xlbiBzID0gcmVhZF9zdWJzdHJpbmcgdCAoU3Vic3RyaW5nLmNyZWF0ZSBzID9wb3MgP2xlbilcbiAgbGV0IHJlYWxseV9yZWFkIHQgP3BvcyA/bGVuIHMgPSByZWFsbHlfcmVhZF9zdWJzdHJpbmcgdCAoU3Vic3RyaW5nLmNyZWF0ZSBzID9wb3MgP2xlbilcblxuICBsZXQgcmVhZF9jaGFyIHQgPVxuICAgIHdpdGhfbm9uZW1wdHlfYnVmZmVyIHQgKGZ1bmN0aW9uXG4gICAgICB8IGBFb2YgLT4gYEVvZlxuICAgICAgfCBgT2sgLT5cbiAgICAgICAgbGV0IGMgPSB0LmJ1Zi57dC5wb3N9IGluXG4gICAgICAgIGNvbnN1bWUgdCAxO1xuICAgICAgICBgT2sgYylcbiAgOztcblxuICBsZXQgZmlyc3RfY2hhciB0IHAgfmF2YWlsYWJsZSA9XG4gICAgbGV0IGxpbWl0ID0gdC5wb3MgKyBhdmFpbGFibGUgaW5cbiAgICBsZXQgYnVmID0gdC5idWYgaW5cbiAgICBtYXRjaCBwIHdpdGhcbiAgICB8IGBQcmVkIHAgLT5cbiAgICAgIGxldCByZWMgbG9vcCBwb3MgPVxuICAgICAgICBpZiBwb3MgPSBsaW1pdCB0aGVuIE5vbmUgZWxzZSBpZiBwIGJ1Zi57cG9zfSB0aGVuIFNvbWUgcG9zIGVsc2UgbG9vcCAocG9zICsgMSlcbiAgICAgIGluXG4gICAgICAoKiBbcF0gaXMgc3VwcGxpZWQgYnkgdGhlIHVzZXIgYW5kIG1heSByYWlzZSwgc28gd2Ugd3JhcCBbbG9vcF0gaW4gYSBbdHJ5X3dpdGhdLiAgV2VcbiAgICAgICAgIHB1dCB0aGUgW3RyeV93aXRoXSBoZXJlIHJhdGhlciB0aGFuIGFyb3VuZCB0aGUgY2FsbCB0byBbcF0gdG8gYXZvaWQgcGVyLWNoYXJhY3RlclxuICAgICAgICAgdHJ5LXdpdGggb3ZlcmhlYWQuICopXG4gICAgICBPcl9lcnJvci50cnlfd2l0aCAoZnVuICgpIC0+IGxvb3AgdC5wb3MpXG4gICAgfCBgQ2hhciBjaCAtPlxuICAgICAgbGV0IHJlYyBsb29wIHBvcyA9XG4gICAgICAgIGlmIHBvcyA9IGxpbWl0XG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIGlmIENoYXIuTy4oY2ggPSBidWYue3Bvc30pXG4gICAgICAgIHRoZW4gU29tZSBwb3NcbiAgICAgICAgZWxzZSBsb29wIChwb3MgKyAxKVxuICAgICAgaW5cbiAgICAgIE9rIChsb29wIHQucG9zKVxuICA7O1xuXG4gIGxldCByZWFkX3VudGlsX2dlbiB0IHAgfmtlZXBfZGVsaW0gfm1heCBrID1cbiAgICBsZXQgcmVjIGxvb3AgYWMgdG90YWwgPVxuICAgICAgd2l0aF9ub25lbXB0eV9idWZmZXInIHQgKGZ1bmN0aW9uXG4gICAgICAgIHwgYEVvZiAtPlxuICAgICAgICAgIGtcbiAgICAgICAgICAgIChPa1xuICAgICAgICAgICAgICAgKGlmIExpc3QuaXNfZW1wdHkgYWNcbiAgICAgICAgICAgICAgICB0aGVuIGBFb2ZcbiAgICAgICAgICAgICAgICBlbHNlIGBFb2Zfd2l0aG91dF9kZWxpbSAoQmlnc3Vic3RyaW5nLmNvbmNhdF9zdHJpbmcgKExpc3QucmV2IGFjKSkpKVxuICAgICAgICB8IGBPayAtPlxuICAgICAgICAgIGxldCBjb25jYXRfaGVscGVyIHNzIGxzdCA9XG4gICAgICAgICAgICBCaWdzdWJzdHJpbmcuY29uY2F0X3N0cmluZyAoTGlzdC5yZXZfYXBwZW5kIGxzdCBbIHNzIF0pXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgYXZhaWxhYmxlLCBuZWVkX21vcmVfYnl0ZXNfdG9fZXhjZWVkX21heCA9XG4gICAgICAgICAgICBtYXRjaCBtYXggd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHQuYXZhaWxhYmxlLCB0cnVlXG4gICAgICAgICAgICB8IFNvbWUgbWF4IC0+XG4gICAgICAgICAgICAgIGlmIHQuYXZhaWxhYmxlIDwgbWF4IC0gdG90YWwgKyAxXG4gICAgICAgICAgICAgIHRoZW4gdC5hdmFpbGFibGUsIHRydWVcbiAgICAgICAgICAgICAgZWxzZSBtYXggLSB0b3RhbCArIDEsIGZhbHNlXG4gICAgICAgICAgaW5cbiAgICAgICAgICAobWF0Y2ggZmlyc3RfY2hhciB0IHAgfmF2YWlsYWJsZSB3aXRoXG4gICAgICAgICAgIHwgRXJyb3IgXyBhcyBlIC0+IGsgZVxuICAgICAgICAgICB8IE9rIE5vbmUgLT5cbiAgICAgICAgICAgICAobWF0Y2ggbmVlZF9tb3JlX2J5dGVzX3RvX2V4Y2VlZF9tYXggd2l0aFxuICAgICAgICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgICAgICAgbGV0IGFtb3VudF9jb25zdW1lZCA9IGF2YWlsYWJsZSBpblxuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBhbW91bnRfY29uc3VtZWQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3MgPSBCaWdzdWJzdHJpbmcuY3JlYXRlIHQuYnVmIH5wb3M6dC5wb3MgfmxlbiBpblxuICAgICAgICAgICAgICAgIGNvbnN1bWUgdCBhbW91bnRfY29uc3VtZWQ7XG4gICAgICAgICAgICAgICAgbGV0IHJlcyA9IGNvbmNhdF9oZWxwZXIgc3MgYWMgaW5cbiAgICAgICAgICAgICAgICBrIChPayAoYE1heF9leGNlZWRlZCByZXMpKVxuICAgICAgICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gdC5hdmFpbGFibGUgaW5cbiAgICAgICAgICAgICAgICBsZXQgdG90YWwgPSB0b3RhbCArIGxlbiBpblxuICAgICAgICAgICAgICAgIGxldCBzcyA9IEJpZ3N1YnN0cmluZy5jcmVhdGUgdC5idWYgfnBvczp0LnBvcyB+bGVuIGluXG4gICAgICAgICAgICAgICAgdC5idWYgPC0gQmlnc3RyaW5nLmNyZWF0ZSAoQmlnc3RyaW5nLmxlbmd0aCB0LmJ1Zik7XG4gICAgICAgICAgICAgICAgdC5wb3MgPC0gMDtcbiAgICAgICAgICAgICAgICB0LmF2YWlsYWJsZSA8LSAwO1xuICAgICAgICAgICAgICAgIGxvb3AgKHNzIDo6IGFjKSB0b3RhbClcbiAgICAgICAgICAgfCBPayAoU29tZSBwb3MpIC0+XG4gICAgICAgICAgICAgbGV0IGFtb3VudF9jb25zdW1lZCA9IHBvcyArIDEgLSB0LnBvcyBpblxuICAgICAgICAgICAgIGxldCBsZW4gPSBpZiBrZWVwX2RlbGltIHRoZW4gYW1vdW50X2NvbnN1bWVkIGVsc2UgYW1vdW50X2NvbnN1bWVkIC0gMSBpblxuICAgICAgICAgICAgIGxldCBzcyA9IEJpZ3N1YnN0cmluZy5jcmVhdGUgdC5idWYgfnBvczp0LnBvcyB+bGVuIGluXG4gICAgICAgICAgICAgY29uc3VtZSB0IGFtb3VudF9jb25zdW1lZDtcbiAgICAgICAgICAgICBsZXQgcmVzID0gY29uY2F0X2hlbHBlciBzcyBhYyBpblxuICAgICAgICAgICAgIGsgKE9rIChgT2sgcmVzKSkpKVxuICAgIGluXG4gICAgbG9vcCBbXSAwXG4gIDs7XG5cbiAgbGV0IHJlYWRfdW50aWwgdCBwcmVkIH5rZWVwX2RlbGltIGsgPVxuICAgIHJlYWRfdW50aWxfZ2VuIHQgcHJlZCB+a2VlcF9kZWxpbSB+bWF4Ok5vbmUgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIF8gYXMgeCAtPiBrIHhcbiAgICAgIHwgT2sgKGBNYXhfZXhjZWVkZWQgXykgLT4gYXNzZXJ0IGZhbHNlICgqIGltcG9zc2libGUgLSBubyBtYXhpbXVtIHNldCAqKVxuICAgICAgfCBPayAoYEVvZiB8IGBFb2Zfd2l0aG91dF9kZWxpbSBfIHwgYE9rIF8pIGFzIHggLT4gayB4KVxuICA7O1xuXG4gIGxldCBsaW5lX2RlbGltaXRlcl9wcmVkID0gYENoYXIgJ1xcbidcblxuICBsZXQgcmVhZF9saW5lX2dlbiB0IGsgPVxuICAgIHJlYWRfdW50aWwgdCBsaW5lX2RlbGltaXRlcl9wcmVkIH5rZWVwX2RlbGltOmZhbHNlIChmdW5jdGlvblxuICAgICAgfCBFcnJvciBfIC0+XG4gICAgICAgICgqIEltcG9zc2libGUsIHNpbmNlIHdlIHN1cHBsaWVkIGEgW2BDaGFyXSBwcmVkaWNhdGUuICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuICAgICAgfCBPayAoKGBFb2YgfCBgRW9mX3dpdGhvdXRfZGVsaW0gXykgYXMgeCkgLT4gayB4XG4gICAgICB8IE9rIChgT2sgbGluZSkgLT5cbiAgICAgICAga1xuICAgICAgICAgIChgT2tcbiAgICAgICAgICAgIChsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBsaW5lIGluXG4gICAgICAgICAgICAgaWYgbGVuID49IDEgJiYgQ2hhci5PLihsaW5lLltsZW4gLSAxXSA9ICdcXHInKVxuICAgICAgICAgICAgIHRoZW4gU3RyaW5nLnN1YiBsaW5lIH5wb3M6MCB+bGVuOihsZW4gLSAxKVxuICAgICAgICAgICAgIGVsc2UgbGluZSkpKVxuICA7O1xuXG4gIGxldCByZWFkX2xpbmUgdCA9XG4gICAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgICByZWFkX2xpbmVfZ2VuIHQgKGZ1biB6IC0+XG4gICAgICAgIEl2YXIuZmlsbF9leG5cbiAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAobWF0Y2ggeiB3aXRoXG4gICAgICAgICAgIHwgYEVvZl93aXRob3V0X2RlbGltIHN0ciAtPiBgT2sgc3RyXG4gICAgICAgICAgIHwgKGBPayBfIHwgYEVvZikgYXMgeCAtPiB4KSkpXG4gIDs7XG5cbiAgbGV0IHJlYWxseV9yZWFkX2xpbmUgfndhaXRfdGltZSB0ID1cbiAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICAgIGxldCBmaWxsX3Jlc3VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT4gSXZhci5maWxsX2V4biByZXN1bHQgTm9uZVxuICAgICAgICB8IGFjIC0+IEl2YXIuZmlsbF9leG4gcmVzdWx0IChTb21lIChTdHJpbmcuY29uY2F0IChMaXN0LnJldiBhYykpKVxuICAgICAgaW5cbiAgICAgIGxldCByZWMgY29udGludWUgYWMgPVxuICAgICAgICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgICAgICAgfCBgTm90X2luX3VzZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgfCBgQ2xvc2VkIC0+IGZpbGxfcmVzdWx0IGFjXG4gICAgICAgIHwgYEluX3VzZSAtPiBDbG9jay5hZnRlciB3YWl0X3RpbWUgPj4+IGZ1biAoKSAtPiBsb29wIGFjXG4gICAgICBhbmQgbG9vcCBhYyA9XG4gICAgICAgIHJlYWRfbGluZV9nZW4gdCAoZnVuY3Rpb25cbiAgICAgICAgICB8IGBFb2YgLT4gY29udGludWUgYWNcbiAgICAgICAgICB8IGBFb2Zfd2l0aG91dF9kZWxpbSBzdHIgLT4gY29udGludWUgKHN0ciA6OiBhYylcbiAgICAgICAgICB8IGBPayBsaW5lIC0+IGZpbGxfcmVzdWx0IChsaW5lIDo6IGFjKSlcbiAgICAgIGluXG4gICAgICBsb29wIFtdKVxuICA7O1xuXG4gIGxldCBzcGFjZSA9IEJpZ3N0cmluZy5vZl9zdHJpbmcgXCIgXCJcblxuICB0eXBlICdzZXhwIHNleHBfa2luZCA9XG4gICAgfCBQbGFpbiA6IFNleHAudCBzZXhwX2tpbmRcbiAgICB8IEFubm90YXRlZCA6IFNleHAuQW5ub3RhdGVkLnQgc2V4cF9raW5kXG5cbiAgbGV0IGdlbl9yZWFkX3NleHAgKHR5cGUgc2V4cCkgP3BhcnNlX3BvcyB0IH4oc2V4cF9raW5kIDogc2V4cCBzZXhwX2tpbmQpIGsgPVxuICAgIGxldCByZWMgbG9vcCBwYXJzZV9mdW4gPVxuICAgICAgd2l0aF9ub25lbXB0eV9idWZmZXInIHQgKGZ1bmN0aW9uXG4gICAgICAgIHwgYEVvZiAtPlxuICAgICAgICAgICgqIFRoZSBzZXhwIHBhcnNlciBkb2Vzbid0IGtub3cgdGhhdCBhIHRva2VuIGVuZHMgYXQgRU9GLCBzbyB3ZSBhZGQgYSBzcGFjZSB0b1xuICAgICAgICAgICAgIGJlIHN1cmUuICopXG4gICAgICAgICAgKG1hdGNoIE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gcGFyc2VfZnVuIH5wb3M6MCB+bGVuOjEgc3BhY2UpIHdpdGhcbiAgICAgICAgICAgfCBFcnJvciBfIGFzIGUgLT4gayBlXG4gICAgICAgICAgIHwgT2sgKFNleHAuRG9uZSAoc2V4cCwgcGFyc2VfcG9zKSkgLT4gayAoT2sgKGBPayAoc2V4cCwgcGFyc2VfcG9zKSkpXG4gICAgICAgICAgIHwgT2sgKENvbnQgKFBhcnNpbmdfdG9wbGV2ZWxfd2hpdGVzcGFjZSwgXykpIC0+IGsgKE9rIGBFb2YpXG4gICAgICAgICAgIHwgT2tcbiAgICAgICAgICAgICAgIChDb250XG4gICAgICAgICAgICAgICAgICggKCBQYXJzaW5nX2F0b21cbiAgICAgICAgICAgICAgICAgICB8IFBhcnNpbmdfbGlzdFxuICAgICAgICAgICAgICAgICAgIHwgUGFyc2luZ19uZXN0ZWRfd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgIHwgUGFyc2luZ19zZXhwX2NvbW1lbnRcbiAgICAgICAgICAgICAgICAgICB8IFBhcnNpbmdfYmxvY2tfY29tbWVudCApXG4gICAgICAgICAgICAgICAgICwgXyApKSAtPlxuICAgICAgICAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiUmVhZGVyLnJlYWRfc2V4cCBnb3QgdW5leHBlY3RlZCBlb2ZcIiB+cmVhZGVyOih0IDogdCldKVxuICAgICAgICB8IGBPayAtPlxuICAgICAgICAgIChtYXRjaFxuICAgICAgICAgICAgIE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gcGFyc2VfZnVuIH5wb3M6dC5wb3Mgfmxlbjp0LmF2YWlsYWJsZSB0LmJ1ZilcbiAgICAgICAgICAgd2l0aFxuICAgICAgICAgICB8IEVycm9yIF8gYXMgZSAtPiBrIGVcbiAgICAgICAgICAgfCBPayAoRG9uZSAoc2V4cCwgcGFyc2VfcG9zKSkgLT5cbiAgICAgICAgICAgICBjb25zdW1lIHQgKHBhcnNlX3Bvcy5idWZfcG9zIC0gdC5wb3MpO1xuICAgICAgICAgICAgIGsgKE9rIChgT2sgKHNleHAsIHBhcnNlX3BvcykpKVxuICAgICAgICAgICB8IE9rIChDb250IChfLCBwYXJzZV9mdW4pKSAtPlxuICAgICAgICAgICAgIHQuYXZhaWxhYmxlIDwtIDA7XG4gICAgICAgICAgICAgbG9vcCBwYXJzZV9mdW4pKVxuICAgIGluXG4gICAgbGV0IHBhcnNlIH5wb3MgfmxlbiBidWYgOiAoXywgc2V4cCkgU2V4cC5wYXJzZV9yZXN1bHQgPVxuICAgICAgKCogW3BhcnNlX3Bvc10gd2lsbCBiZSB0aHJlYWRlZCB0aHJvdWdoIHRoZSBlbnRpcmUgcmVhZGluZyBwcm9jZXNzIGJ5IHRoZSBzZXhwbGliXG4gICAgICAgICBjb2RlLiAgRXZlcnkgb2NjdXJyZW5jZSBvZiBbcGFyc2VfcG9zXSBhYm92ZSB3aWxsIGJlIGlkZW50aWNhbCB0byB0aGUgW3BhcnNlX3Bvc11cbiAgICAgICAgIGRlZmluZWQgaGVyZS4gKilcbiAgICAgIGxldCBwYXJzZV9wb3MgPVxuICAgICAgICBtYXRjaCBwYXJzZV9wb3Mgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU2V4cC5QYXJzZV9wb3MuY3JlYXRlIH5idWZfcG9zOnBvcyAoKVxuICAgICAgICB8IFNvbWUgcGFyc2VfcG9zIC0+IFNleHAuUGFyc2VfcG9zLndpdGhfYnVmX3BvcyBwYXJzZV9wb3MgcG9zXG4gICAgICBpblxuICAgICAgbWF0Y2ggc2V4cF9raW5kIHdpdGhcbiAgICAgIHwgUGxhaW4gLT4gU2V4cC5wYXJzZV9iaWdzdHJpbmcgP3BhcnNlX3BvczooU29tZSBwYXJzZV9wb3MpID9sZW46KFNvbWUgbGVuKSBidWZcbiAgICAgIHwgQW5ub3RhdGVkIC0+XG4gICAgICAgIFNleHAuQW5ub3RhdGVkLnBhcnNlX2JpZ3N0cmluZyA/cGFyc2VfcG9zOihTb21lIHBhcnNlX3BvcykgP2xlbjooU29tZSBsZW4pIGJ1ZlxuICAgIGluXG4gICAgbG9vcCBwYXJzZVxuICA7O1xuXG4gIHR5cGUgJ2EgcmVhZCA9ID9wYXJzZV9wb3M6U2V4cC5QYXJzZV9wb3MudCAtPiAnYVxuXG4gIGxldCBnZW5fcmVhZF9zZXhwcyA/cGFyc2VfcG9zIHQgfnNleHBfa2luZCA9XG4gICAgbGV0IHBpcGVfciwgcGlwZV93ID0gUGlwZS5jcmVhdGUgKCkgaW5cbiAgICBsZXQgZmluaXNoZWQgPVxuICAgICAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgICAgIGxldCByZWMgbG9vcCBwYXJzZV9wb3MgPVxuICAgICAgICAgIGdlbl9yZWFkX3NleHAgdCB+c2V4cF9raW5kID9wYXJzZV9wb3MgKGZ1bmN0aW9uXG4gICAgICAgICAgICB8IEVycm9yIGVycm9yIC0+IEVycm9yLnJhaXNlIGVycm9yXG4gICAgICAgICAgICB8IE9rIGBFb2YgLT4gSXZhci5maWxsX2V4biByZXN1bHQgKClcbiAgICAgICAgICAgIHwgT2sgKGBPayAoc2V4cCwgcGFyc2VfcG9zKSkgLT5cbiAgICAgICAgICAgICAgaWYgUGlwZS5pc19jbG9zZWQgcGlwZV93XG4gICAgICAgICAgICAgIHRoZW4gSXZhci5maWxsX2V4biByZXN1bHQgKClcbiAgICAgICAgICAgICAgZWxzZSBQaXBlLndyaXRlIHBpcGVfdyBzZXhwID4+PiBmdW4gKCkgLT4gbG9vcCAoU29tZSBwYXJzZV9wb3MpKVxuICAgICAgICBpblxuICAgICAgICBsb29wIHBhcnNlX3BvcylcbiAgICBpblxuICAgIHVwb24gZmluaXNoZWQgKGZ1biAoKSAtPiBjbG9zZSB0ID4+PiBmdW4gKCkgLT4gUGlwZS5jbG9zZSBwaXBlX3cpO1xuICAgIHBpcGVfclxuICA7O1xuXG4gIGxldCByZWFkX3NleHBzID9wYXJzZV9wb3MgdCA9IGdlbl9yZWFkX3NleHBzIHQgfnNleHBfa2luZDpQbGFpbiA/cGFyc2VfcG9zXG4gIGxldCByZWFkX2Fubm90YXRlZF9zZXhwcyA/cGFyc2VfcG9zIHQgPSBnZW5fcmVhZF9zZXhwcyB0IH5zZXhwX2tpbmQ6QW5ub3RhdGVkID9wYXJzZV9wb3NcblxuICBtb2R1bGUgUmVhZF9iaW5fcHJvdCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgcmVzdWx0ID1cbiAgICAgIHwgT2sgb2YgJ2FcbiAgICAgIHwgTmVlZF9ieXRlcyBvZiBpbnRcbiAgICAgIHwgRXJyb3Igb2YgRXJyb3IudFxuXG4gICAgbGV0W0Bjb2xkXSB1bmV4cGVjdGVkX3BvcyBiaW5fdHlwZSB0IH5vbGRfcG9zIH5yZWFkX2xlbiB+bmV3X3BvcyA9XG4gICAgICBFcnJvclxuICAgICAgICAoRXJyb3IuY3JlYXRlX3NcbiAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHJlYWRlciBwb3NpdGlvbiBhZnRlciByZWFkXCJcbiAgICAgICAgICAgICAgIChiaW5fdHlwZSA6IHN0cmluZylcbiAgICAgICAgICAgICAgIH5yZWFkZXI6KHQgOiB0KVxuICAgICAgICAgICAgICAgKG9sZF9wb3MgOiBpbnQpXG4gICAgICAgICAgICAgICAocmVhZF9sZW4gOiBpbnQpXG4gICAgICAgICAgICAgICAobmV3X3BvcyA6IGludCldKVxuICAgIDs7XG5cbiAgICBsZXRbQGNvbGRdIHNpemVfZXJyb3IgbWVzc2FnZSB0IH5zaXplIH5wb3MgPVxuICAgICAgRXJyb3IgKEVycm9yLmNyZWF0ZV9zIFslbWVzc2FnZSBtZXNzYWdlIH5yZWFkZXI6KHQgOiB0KSAoc2l6ZSA6IGludCkgKHBvcyA6IGludCldKVxuICAgIDs7XG5cbiAgICBsZXQgcmVhZF9yYXcgdCBidWYgfnBvc19yZWYgfmxlbiB+YmluX3Byb3RfcmVhZGVyID1cbiAgICAgIGlmIGxlbiA8IEJpbl9wcm90LlV0aWxzLnNpemVfaGVhZGVyX2xlbmd0aFxuICAgICAgdGhlbiBOZWVkX2J5dGVzIEJpbl9wcm90LlV0aWxzLnNpemVfaGVhZGVyX2xlbmd0aFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBoZWFkZXJfcG9zID0gIXBvc19yZWYgaW5cbiAgICAgICAgbGV0IG1lc3NhZ2Vfc2l6ZSA9IEJpbl9wcm90LlV0aWxzLmJpbl9yZWFkX3NpemVfaGVhZGVyIGJ1ZiB+cG9zX3JlZiBpblxuICAgICAgICBpZiAhcG9zX3JlZiA8PiBoZWFkZXJfcG9zICsgQmluX3Byb3QuVXRpbHMuc2l6ZV9oZWFkZXJfbGVuZ3RoXG4gICAgICAgIHRoZW5cbiAgICAgICAgICB1bmV4cGVjdGVkX3Bvc1xuICAgICAgICAgICAgXCJoZWFkZXJcIlxuICAgICAgICAgICAgdFxuICAgICAgICAgICAgfm9sZF9wb3M6aGVhZGVyX3Bvc1xuICAgICAgICAgICAgfnJlYWRfbGVuOkJpbl9wcm90LlV0aWxzLnNpemVfaGVhZGVyX2xlbmd0aFxuICAgICAgICAgICAgfm5ld19wb3M6IXBvc19yZWZcbiAgICAgICAgZWxzZSBpZiBsZW4gLSBCaW5fcHJvdC5VdGlscy5zaXplX2hlYWRlcl9sZW5ndGggPCBtZXNzYWdlX3NpemVcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGJ5dGVzX25lZWRlZCA9IEJpbl9wcm90LlV0aWxzLnNpemVfaGVhZGVyX2xlbmd0aCArIG1lc3NhZ2Vfc2l6ZSBpblxuICAgICAgICAgIGlmIG1lc3NhZ2Vfc2l6ZSA8IDBcbiAgICAgICAgICB0aGVuIHNpemVfZXJyb3IgXCJOZWdhdGl2ZSBtZXNzYWdlIHNpemVcIiB0IH5zaXplOm1lc3NhZ2Vfc2l6ZSB+cG9zOmhlYWRlcl9wb3NcbiAgICAgICAgICBlbHNlIGlmIGJ5dGVzX25lZWRlZCA8IDBcbiAgICAgICAgICB0aGVuIHNpemVfZXJyb3IgXCJCeXRlcyBuZWVkZWQgb3ZlcmZsb3dlZFwiIHQgfnNpemU6Ynl0ZXNfbmVlZGVkIH5wb3M6aGVhZGVyX3Bvc1xuICAgICAgICAgIGVsc2UgTmVlZF9ieXRlcyBieXRlc19uZWVkZWQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBtZXNzYWdlX3BvcyA9ICFwb3NfcmVmIGluXG4gICAgICAgICAgbGV0IG1lc3NhZ2UgPSBiaW5fcHJvdF9yZWFkZXIuQmluX3Byb3QuVHlwZV9jbGFzcy5yZWFkIGJ1ZiB+cG9zX3JlZiBpblxuICAgICAgICAgIGlmICFwb3NfcmVmIDw+IG1lc3NhZ2VfcG9zICsgbWVzc2FnZV9zaXplXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgdW5leHBlY3RlZF9wb3NcbiAgICAgICAgICAgICAgXCJtZXNzYWdlXCJcbiAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICB+b2xkX3BvczptZXNzYWdlX3Bvc1xuICAgICAgICAgICAgICB+cmVhZF9sZW46bWVzc2FnZV9zaXplXG4gICAgICAgICAgICAgIH5uZXdfcG9zOiFwb3NfcmVmXG4gICAgICAgICAgZWxzZSBPayBtZXNzYWdlKSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgUGVla19vcl9yZWFkID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgUGVla1xuICAgICAgfCBSZWFkXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCB0b19zdHJpbmcgPSBTZXhwbGliLkNvbnYuc3RyaW5nX29mX19vZl9fc2V4cF9vZiBbJXNleHBfb2Y6IHRdXG4gIGVuZFxuXG4gIGxldCBwZWVrX29yX3JlYWRfYmluX3Byb3RcbiAgICA/KG1heF9sZW4gPSBJbnQubWF4X3ZhbHVlKVxuICAgIHRcbiAgICB+KHBlZWtfb3JfcmVhZCA6IFBlZWtfb3JfcmVhZC50KVxuICAgIChiaW5fcHJvdF9yZWFkZXIgOiBfIEJpbl9wcm90LlR5cGVfY2xhc3MucmVhZGVyKVxuICAgIGtcbiAgICA9XG4gICAgbGV0IGVycm9yIGYgPVxuICAgICAga3NwcmludGZcbiAgICAgICAgKGZ1biBtc2cgKCkgLT5cbiAgICAgICAgICBrIChPcl9lcnJvci5lcnJvciBcIlJlYWRlci5yZWFkX2Jpbl9wcm90XCIgKG1zZywgdCkgWyVzZXhwX29mOiBzdHJpbmcgKiB0XSkpXG4gICAgICAgIGZcbiAgICBpblxuICAgIGxldCBoYW5kbGVfZW9mIH5uZWVkIG4gPVxuICAgICAgaWYgbiA9IDBcbiAgICAgIHRoZW4gayAoT2sgYEVvZilcbiAgICAgIGVsc2UgZXJyb3IgXCJnb3QgRW9mIHdpdGggJWQgYnl0ZXMgbGVmdCBvdmVyIChuZWVkICVkKVwiIG4gbmVlZCAoKVxuICAgIGluXG4gICAgaWYgbWF4X2xlbiA8IDBcbiAgICB0aGVuIGVycm9yIFwibWF4IHJlYWQgbGVuZ3RoIGlzIG5lZ2F0aXZlOiAlZFwiIG1heF9sZW4gKClcbiAgICBlbHNlIChcbiAgICAgIGxldCBtYXhfbGVuX3dpdGhfaGVhZGVyID1cbiAgICAgICAgbGV0IGxlbl93aXRoX2hlYWRlciA9IG1heF9sZW4gKyBCaW5fcHJvdC5VdGlscy5zaXplX2hlYWRlcl9sZW5ndGggaW5cbiAgICAgICAgaWYgbGVuX3dpdGhfaGVhZGVyIDwgbWF4X2xlbiB0aGVuIEludC5tYXhfdmFsdWUgZWxzZSBsZW5fd2l0aF9oZWFkZXJcbiAgICAgIGluXG4gICAgICBsZXQgcmVjIHJlYWRfbG9vcCAoKSA9XG4gICAgICAgIG1hdGNoIHQuc3RhdGUgd2l0aFxuICAgICAgICB8IGBOb3RfaW5fdXNlIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICB8IGBDbG9zZWQgLT4gZXJyb3IgXCJSZWFkZXIucmVhZF9iaW5fcHJvdCBnb3QgY2xvc2VkIHJlYWRlclwiICgpXG4gICAgICAgIHwgYEluX3VzZSAtPlxuICAgICAgICAgIGxldCBwb3MgPSB0LnBvcyBpblxuICAgICAgICAgIGxldCBwb3NfcmVmID0gcmVmIHBvcyBpblxuICAgICAgICAgIGxldCBsZW4gPSBtaW4gbWF4X2xlbl93aXRoX2hlYWRlciB0LmF2YWlsYWJsZSBpblxuICAgICAgICAgIChtYXRjaCBSZWFkX2Jpbl9wcm90LnJlYWRfcmF3IHQgdC5idWYgfnBvc19yZWYgfmxlbiB+YmluX3Byb3RfcmVhZGVyIHdpdGhcbiAgICAgICAgICAgfCBPayBtZXNzYWdlIC0+XG4gICAgICAgICAgICAgKG1hdGNoIHBlZWtfb3JfcmVhZCB3aXRoXG4gICAgICAgICAgICAgIHwgUGVlayAtPiAoKVxuICAgICAgICAgICAgICB8IFJlYWQgLT4gY29uc3VtZSB0ICghcG9zX3JlZiAtIHBvcykpO1xuICAgICAgICAgICAgIGsgKE9rIChgT2sgbWVzc2FnZSkpXG4gICAgICAgICAgIHwgTmVlZF9ieXRlcyBuZWVkIC0+XG4gICAgICAgICAgICAgbGV0IG5lZWRfbWVzc2FnZSA9IG5lZWQgLSBCaW5fcHJvdC5VdGlscy5zaXplX2hlYWRlcl9sZW5ndGggaW5cbiAgICAgICAgICAgICBpZiBuZWVkX21lc3NhZ2UgPiBtYXhfbGVuXG4gICAgICAgICAgICAgdGhlbiBlcnJvciBcIm1heCByZWFkIGxlbmd0aCBleGNlZWRlZDogJWQgPiAlZFwiIG5lZWRfbWVzc2FnZSBtYXhfbGVuICgpXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgZ2V0X2RhdGFfdW50aWwgdCB+YXZhaWxhYmxlX2F0X2xlYXN0Om5lZWRcbiAgICAgICAgICAgICAgID4+PiAoZnVuY3Rpb25cbiAgICAgICAgICAgICAgIHwgYEVvZiBuIC0+IGhhbmRsZV9lb2Ygfm5lZWQgblxuICAgICAgICAgICAgICAgfCBgT2sgLT4gcmVhZF9sb29wICgpKVxuICAgICAgICAgICB8IEVycm9yIGVycm9yIC0+IGsgKEVycm9yIGVycm9yKVxuICAgICAgICAgICB8IGV4Y2VwdGlvbiBleG4gLT4gayAoT3JfZXJyb3Iub2ZfZXhuIGV4bikpXG4gICAgICBpblxuICAgICAgcmVhZF9sb29wICgpKVxuICA7O1xuXG4gIGxldCBpdGVyX2Jpbl9wcm90IHQgYmluX3Byb3RfcmVhZGVyIH5mID1cbiAgICBsZXQgb3BlbiBFYWdlcl9kZWZlcnJlZC5MZXRfc3ludGF4IGluXG4gICAgbGV0IGhhbmRsZV9jaHVuayBidWYgfnBvczpjaHVua19wb3MgfmxlbiA9XG4gICAgICBsZXQgbGltaXQgPSBjaHVua19wb3MgKyBsZW4gaW5cbiAgICAgIGxldCBwb3NfcmVmID0gcmVmIGNodW5rX3BvcyBpblxuICAgICAgbGV0IHJlYyByZWFkX2xvb3AgKCkgPVxuICAgICAgICBsZXQgaGVhZGVyX3BvcyA9ICFwb3NfcmVmIGluXG4gICAgICAgIGxldCBsZW4gPSBsaW1pdCAtIGhlYWRlcl9wb3MgaW5cbiAgICAgICAgbWF0Y2ggUmVhZF9iaW5fcHJvdC5yZWFkX3JhdyB0IGJ1ZiB+cG9zX3JlZiB+bGVuIH5iaW5fcHJvdF9yZWFkZXIgd2l0aFxuICAgICAgICB8IE9rIG1lc3NhZ2UgLT5cbiAgICAgICAgICBsZXQlYmluZCAoKSA9IGYgbWVzc2FnZSBpblxuICAgICAgICAgIHJlYWRfbG9vcCAoKVxuICAgICAgICB8IE5lZWRfYnl0ZXMgYnl0ZXMgLT5cbiAgICAgICAgICBpZiBoZWFkZXJfcG9zID0gbGltaXRcbiAgICAgICAgICB0aGVuIHJldHVybiBgQ29udGludWVcbiAgICAgICAgICBlbHNlIHJldHVybiAoYENvbnN1bWVkIChoZWFkZXJfcG9zIC0gY2h1bmtfcG9zLCBgTmVlZCBieXRlcykpXG4gICAgICAgIHwgRXJyb3IgZXJyb3IgLT4gcmV0dXJuIChgU3RvcCBlcnJvcilcbiAgICAgIGluXG4gICAgICBtYXRjaCVtYXAgdHJ5X3dpdGggfnJ1bjpgTm93IHJlYWRfbG9vcCB3aXRoXG4gICAgICB8IE9rIHJlc3VsdCAtPiByZXN1bHRcbiAgICAgIHwgRXJyb3IgZXhuIC0+XG4gICAgICAgIGBTdG9wXG4gICAgICAgICAgKEVycm9yLm9mX2V4biBleG5cbiAgICAgICAgICAgfD4gRXJyb3IudGFnX3MgfnRhZzpbJW1lc3NhZ2UgXCJFcnJvciBkZXNlcmlhbGl6aW5nIHJlYWRlclwiIH5yZWFkZXI6KHQgOiB0KV0pXG4gICAgaW5cbiAgICBsZXQlYmluZCByZXN1bHQgPSByZWFkX29uZV9jaHVua19hdF9hX3RpbWUgdCB+aGFuZGxlX2NodW5rIGluXG4gICAgbGV0JWJpbmQgKCkgPSBjbG9zZSB0IGluXG4gICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICB8IGBFb2YgLT4gRGVmZXJyZWQuT3JfZXJyb3Iub2tfdW5pdFxuICAgIHwgYFN0b3BwZWQgZXJyb3IgLT4gcmV0dXJuIChFcnJvciBlcnJvcilcbiAgICB8IGBFb2Zfd2l0aF91bmNvbnN1bWVkX2RhdGEgZGF0YSAtPlxuICAgICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGggZGF0YSBpblxuICAgICAgRGVmZXJyZWQuT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJVbmNvbnN1bWVkIGRhdGFcIiAobGVuZ3RoIDogaW50KSAoZGF0YSA6IHN0cmluZyldXG4gIDs7XG5cbiAgbGV0IHJlYWRfbWFyc2hhbF9yYXcgdCA9XG4gICAgbGV0IGVvZm4gbiA9XG4gICAgICBpZiBuID0gMFxuICAgICAgdGhlbiBgRW9mXG4gICAgICBlbHNlXG4gICAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiUmVhZGVyLnJlYWRfbWFyc2hhbCBnb3QgRU9GIHdpdGggYnl0ZXMgcmVtYWluaW5nXCIgfl86KG4gOiBpbnQpXVxuICAgIGluXG4gICAgbGV0IGhlYWRlciA9IEJ5dGVzLmNyZWF0ZSBNYXJzaGFsLmhlYWRlcl9zaXplIGluXG4gICAgbWF0Y2glYmluZCByZWFsbHlfcmVhZCB0IGhlYWRlciB3aXRoXG4gICAgfCBgRW9mIG4gLT4gcmV0dXJuIChlb2ZuIG4pXG4gICAgfCBgT2sgLT5cbiAgICAgIGxldCBsZW4gPSBNYXJzaGFsLmRhdGFfc2l6ZSBoZWFkZXIgMCBpblxuICAgICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAobGVuICsgTWFyc2hhbC5oZWFkZXJfc2l6ZSkgaW5cbiAgICAgIEJ5dGVzLmJsaXQgfnNyYzpoZWFkZXIgfmRzdDpidWYgfnNyY19wb3M6MCB+ZHN0X3BvczowIH5sZW46TWFyc2hhbC5oZWFkZXJfc2l6ZTtcbiAgICAgIGxldCBzdWIgPSBTdWJzdHJpbmcuY3JlYXRlIGJ1ZiB+cG9zOk1hcnNoYWwuaGVhZGVyX3NpemUgfmxlbiBpblxuICAgICAgKG1hdGNoJW1hcCByZWFsbHlfcmVhZF9zdWJzdHJpbmcgdCBzdWIgd2l0aFxuICAgICAgIHwgYEVvZiBuIC0+IGVvZm4gblxuICAgICAgIHwgYE9rIC0+IGBPayBidWYpXG4gIDs7XG5cbiAgbGV0IHJlYWRfbWFyc2hhbCB0ID1cbiAgICBtYXRjaCVtYXAgcmVhZF9tYXJzaGFsX3JhdyB0IHdpdGhcbiAgICB8IGBFb2YgLT4gYEVvZlxuICAgIHwgYE9rIGJ1ZiAtPiBgT2sgKE1hcnNoYWwuZnJvbV9ieXRlcyBidWYgMClcbiAgOztcblxuICBsZXQgcmVhZF9hbGwgPyhjbG9zZV93aGVuX2ZpbmlzaGVkID0gdHJ1ZSkgdCByZWFkX29uZSA9XG4gICAgbGV0IHBpcGVfciwgcGlwZV93ID0gUGlwZS5jcmVhdGUgKCkgaW5cbiAgICBsZXQgZmluaXNoZWQgPVxuICAgICAgRGVmZXJyZWQucmVwZWF0X3VudGlsX2ZpbmlzaGVkICgpIChmdW4gKCkgLT5cbiAgICAgICAgbWF0Y2glYmluZCByZWFkX29uZSB0IHdpdGhcbiAgICAgICAgfCBgRW9mIC0+IHJldHVybiAoYEZpbmlzaGVkICgpKVxuICAgICAgICB8IGBPayBvbmUgLT5cbiAgICAgICAgICBpZiBQaXBlLmlzX2Nsb3NlZCBwaXBlX3dcbiAgICAgICAgICB0aGVuIHJldHVybiAoYEZpbmlzaGVkICgpKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0JW1hcCAoKSA9IFBpcGUud3JpdGUgcGlwZV93IG9uZSBpblxuICAgICAgICAgICAgYFJlcGVhdCAoKSkpXG4gICAgaW5cbiAgICBsZXQgbWF5YmVfY2xvc2UgdCA9IGlmIGNsb3NlX3doZW5fZmluaXNoZWQgdGhlbiBjbG9zZSB0IGVsc2UgcmV0dXJuICgpIGluXG4gICAgdXBvbiBmaW5pc2hlZCAoZnVuICgpIC0+IG1heWJlX2Nsb3NlIHQgPj4+IGZ1biAoKSAtPiBQaXBlLmNsb3NlIHBpcGVfdyk7XG4gICAgcGlwZV9yXG4gIDs7XG5cbiAgbGV0IGxpbmVzIHQgPSByZWFkX2FsbCB0IHJlYWRfbGluZVxuXG4gIGxldCBjb250ZW50cyB0ID1cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgbGV0IHNidWYgPSBCeXRlcy5jcmVhdGUgMTAyNCBpblxuICAgIGxldCViaW5kICgpID1cbiAgICAgIERlZmVycmVkLnJlcGVhdF91bnRpbF9maW5pc2hlZCAoKSAoZnVuICgpIC0+XG4gICAgICAgIG1hdGNoJW1hcCByZWFkIHQgc2J1ZiB3aXRoXG4gICAgICAgIHwgYEVvZiAtPiBgRmluaXNoZWQgKClcbiAgICAgICAgfCBgT2sgbCAtPlxuICAgICAgICAgIEJ1ZmZlci5hZGRfc3ViYnl0ZXMgYnVmIHNidWYgfnBvczowIH5sZW46bDtcbiAgICAgICAgICBgUmVwZWF0ICgpKVxuICAgIGluXG4gICAgbGV0JW1hcCAoKSA9IGNsb3NlIHQgaW5cbiAgICBCdWZmZXIuY29udGVudHMgYnVmXG4gIDs7XG5cbiAgbGV0IHJlY3YgdCA9XG4gICAgRGVmZXJyZWQuY3JlYXRlIChmdW4gaSAtPlxuICAgICAgcmVhZF9saW5lIHRcbiAgICAgID4+PiBmdW5jdGlvblxuICAgICAgfCBgRW9mIC0+IEl2YXIuZmlsbF9leG4gaSBgRW9mXG4gICAgICB8IGBPayBsZW5ndGhfc3RyIC0+XG4gICAgICAgIChtYXRjaFxuICAgICAgICAgICB0cnkgT2sgKGludF9vZl9zdHJpbmcgbGVuZ3RoX3N0cikgd2l0aFxuICAgICAgICAgICB8IF8gLT4gRXJyb3IgKClcbiAgICAgICAgIHdpdGhcbiAgICAgICAgIHwgRXJyb3IgKCkgLT5cbiAgICAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICAgXCJSZWFkZXIucmVjdiBnb3Qgc3RyYW5nZSBsZW5ndGhcIiAobGVuZ3RoX3N0ciA6IHN0cmluZykgfnJlYWRlcjoodCA6IHQpXVxuICAgICAgICAgfCBPayBsZW5ndGggLT5cbiAgICAgICAgICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBsZW5ndGggaW5cbiAgICAgICAgICAgcmVhbGx5X3JlYWQgdCBidWZcbiAgICAgICAgICAgPj4+IChmdW5jdGlvblxuICAgICAgICAgICB8IGBFb2YgXyAtPiByYWlzZV9zIFslbWVzc2FnZSBcIlJlYWRlci5yZWN2IGdvdCB1bmV4cGVjdGVkIEVPRlwiXVxuICAgICAgICAgICB8IGBPayAtPiBJdmFyLmZpbGxfZXhuIGkgKGBPayBidWYpKSkpXG4gIDs7XG5cbiAgbGV0IHRyYW5zZmVyIHQgcGlwZV93ID1cbiAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBmaW5pc2hlZCAtPlxuICAgICAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAgICAgKGxldCVtYXAgKCkgPSBQaXBlLmNsb3NlZCBwaXBlX3cgaW5cbiAgICAgICAgIEl2YXIuZmlsbF9pZl9lbXB0eSBmaW5pc2hlZCAoKSk7XG4gICAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgICB3aXRoX25vbmVtcHR5X2J1ZmZlcicgdCAoZnVuY3Rpb25cbiAgICAgICAgICB8IGBFb2YgLT4gSXZhci5maWxsX2lmX2VtcHR5IGZpbmlzaGVkICgpXG4gICAgICAgICAgfCBgT2sgLT5cbiAgICAgICAgICAgIGlmIG5vdCAoUGlwZS5pc19jbG9zZWQgcGlwZV93KVxuICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgIGxldCBwb3MgPSB0LnBvcyBpblxuICAgICAgICAgICAgICBsZXQgbGVuID0gdC5hdmFpbGFibGUgaW5cbiAgICAgICAgICAgICAgY29uc3VtZSB0IGxlbjtcbiAgICAgICAgICAgICAgUGlwZS53cml0ZSBwaXBlX3cgKEJpZ3N0cmluZy50b19zdHJpbmcgdC5idWYgfnBvcyB+bGVuKSA+Pj4gbG9vcCkpXG4gICAgICBpblxuICAgICAgbG9vcCAoKSlcbiAgOztcbmVuZFxuXG5vcGVuIEludGVybmFsXG5cbigqIFdlIG5vdyBleHBvc2UgYWxsIHRoZSBmdW5jdGlvbnMgaW4gdGhlIG1saS4gIEZvciBmdW5jdGlvbnMgdGhhdCBhY2Nlc3MgYSByZWFkZXIgaW4gYVxuICAgZGVmZXJyZWQgbWFubmVyLCB3ZSBlbmNsdWRlIGNvZGUgdG8gZHluYW1pY2FsbHkgZW5zdXJlIHRoYXQgdGhlcmUgYXJlbid0IHNpbXVsdGFuZW91c1xuICAgcmVhZHMuICopXG5cbnR5cGUgbm9ucmVjIHQgPSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG50eXBlIG5vbnJlYyAnYSBoYW5kbGVfY2h1bmtfcmVzdWx0ID0gJ2EgaGFuZGxlX2NodW5rX3Jlc3VsdCBbQEBkZXJpdmluZyBzZXhwX29mXVxudHlwZSBub25yZWMgJ2EgaGFuZGxlX2lvYnVmX3Jlc3VsdCA9ICdhIGhhbmRsZV9pb2J1Zl9yZXN1bHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxudHlwZSBub25yZWMgJ2EgcmVhZF9vbmVfY2h1bmtfYXRfYV90aW1lX3Jlc3VsdCA9ICdhIHJlYWRfb25lX2NodW5rX2F0X2FfdGltZV9yZXN1bHRcbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbnR5cGUgbm9ucmVjICdhIHJlYWQgPSAnYSByZWFkXG5cbmxldCBjbG9zZSA9IGNsb3NlXG5sZXQgY2xvc2VfZmluaXNoZWQgPSBjbG9zZV9maW5pc2hlZFxubGV0IGNyZWF0ZSA9IGNyZWF0ZVxubGV0IGZkID0gZmRcbmxldCBpZCA9IGlkXG5sZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG5sZXQgYnl0ZXNfcmVhZCA9IGJ5dGVzX3JlYWRcbmxldCBpc19jbG9zZWQgPSBpc19jbG9zZWRcbmxldCBsYXN0X3JlYWRfdGltZSA9IGxhc3RfcmVhZF90aW1lXG5sZXQgb2ZfaW5fY2hhbm5lbCA9IG9mX2luX2NoYW5uZWxcbmxldCBvcGVuX2ZpbGUgPSBvcGVuX2ZpbGVcbmxldCBzdGRpbiA9IHN0ZGluXG5sZXQgd2l0aF9jbG9zZSA9IHdpdGhfY2xvc2VcbmxldCB3aXRoX2ZpbGUgPSB3aXRoX2ZpbGVcblxubGV0IHVzZSB0ID1cbiAgbGV0IGVycm9yIHJlYXNvbiA9XG4gICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJjYW4gbm90IHJlYWQgZnJvbSByZWFkZXJcIiAocmVhc29uIDogc3RyaW5nKSB+cmVhZGVyOih0IDogdCldXG4gIGluXG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IGBDbG9zZWQgLT4gZXJyb3IgXCJjbG9zZWRcIlxuICB8IGBJbl91c2UgLT4gZXJyb3IgXCJpbiB1c2VcIlxuICB8IGBOb3RfaW5fdXNlIC0+IHQuc3RhdGUgPC0gYEluX3VzZVxuOztcblxubGV0IGZpbmlzaGVkX3JlYWQgdCA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IGBDbG9zZWQgLT4gKCkgKCogW2YgKCldIGNsb3NlZCBpdC4gIExlYXZlIGl0IGNsb3NlZC4gKilcbiAgfCBgTm90X2luX3VzZSAtPiBhc3NlcnQgZmFsc2UgKCogd2UncmUgdXNpbmcgaXQgKilcbiAgfCBgSW5fdXNlIC0+IHQuc3RhdGUgPC0gYE5vdF9pbl91c2Vcbjs7XG5cbmxldCBkb19yZWFkX25vdyB0IGYgPVxuICB1c2UgdDtcbiAgbGV0IHggPSBmICgpIGluXG4gIGZpbmlzaGVkX3JlYWQgdDtcbiAgeFxuOztcblxubGV0IGJ5dGVzX2F2YWlsYWJsZSB0ID0gZG9fcmVhZF9ub3cgdCAoZnVuICgpIC0+IHQuYXZhaWxhYmxlKVxubGV0IHBlZWtfYXZhaWxhYmxlIHQgfmxlbiA9IGRvX3JlYWRfbm93IHQgKGZ1biAoKSAtPiBwZWVrX2F2YWlsYWJsZSB0IH5sZW4pXG5sZXQgcmVhZF9hdmFpbGFibGUgdCA/cG9zID9sZW4gcyA9IGRvX3JlYWRfbm93IHQgKGZ1biAoKSAtPiByZWFkX2F2YWlsYWJsZSB0ID9wb3MgP2xlbiBzKVxuXG5sZXQgZG9fcmVhZCB0IGYgPVxuICB1c2UgdDtcbiAgbGV0JW1hcCB4ID0gZiAoKSBpblxuICBmaW5pc2hlZF9yZWFkIHQ7XG4gIHhcbjs7XG5cbmxldCBwZWVrIHQgfmxlbiA9XG4gIGlmIGxlbiA8IDAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIltSZWFkZXIucGVla10gZ290IG5lZ2F0aXZlIGxlblwiIChsZW4gOiBpbnQpXTtcbiAgZG9fcmVhZCB0IChmdW4gKCkgLT4gcGVlayB0IH5sZW4pXG47O1xuXG5sZXQgcmVhZCB0ID9wb3MgP2xlbiBzID0gZG9fcmVhZCB0IChmdW4gKCkgLT4gcmVhZCB0ID9wb3MgP2xlbiBzKVxubGV0IHJlYWRfY2hhciB0ID0gZG9fcmVhZCB0IChmdW4gKCkgLT4gcmVhZF9jaGFyIHQpXG5sZXQgcmVhZF9zdWJzdHJpbmcgdCBzID0gZG9fcmVhZCB0IChmdW4gKCkgLT4gcmVhZF9zdWJzdHJpbmcgdCBzKVxubGV0IHJlYWRfYmlnc3Vic3RyaW5nIHQgcyA9IGRvX3JlYWQgdCAoZnVuICgpIC0+IHJlYWRfYmlnc3Vic3RyaW5nIHQgcylcblxubGV0IHJlYWRfb25lX2NodW5rX2F0X2FfdGltZSB0IH5oYW5kbGVfY2h1bmsgPVxuICBkb19yZWFkIHQgKGZ1biAoKSAtPiByZWFkX29uZV9jaHVua19hdF9hX3RpbWUgdCB+aGFuZGxlX2NodW5rKVxuOztcblxubGV0IHJlYWRfb25lX2lvYnVmX2F0X2FfdGltZSB0IH5oYW5kbGVfY2h1bmsgPVxuICBkb19yZWFkIHQgKGZ1biAoKSAtPiByZWFkX29uZV9pb2J1Zl9hdF9hX3RpbWUgdCB+aGFuZGxlX2NodW5rKVxuOztcblxubGV0IHJlYWxseV9yZWFkIHQgP3BvcyA/bGVuIHMgPSBkb19yZWFkIHQgKGZ1biAoKSAtPiByZWFsbHlfcmVhZCB0ID9wb3MgP2xlbiBzKVxubGV0IHJlYWxseV9yZWFkX3N1YnN0cmluZyB0IHMgPSBkb19yZWFkIHQgKGZ1biAoKSAtPiByZWFsbHlfcmVhZF9zdWJzdHJpbmcgdCBzKVxubGV0IHJlYWxseV9yZWFkX2JpZ3N1YnN0cmluZyB0IHMgPSBkb19yZWFkIHQgKGZ1biAoKSAtPiByZWFsbHlfcmVhZF9iaWdzdWJzdHJpbmcgdCBzKVxubGV0IHJlYWRfbGluZSB0ID0gZG9fcmVhZCB0IChmdW4gKCkgLT4gcmVhZF9saW5lIHQpXG5sZXQgcmVhbGx5X3JlYWRfbGluZSB+d2FpdF90aW1lIHQgPSBkb19yZWFkIHQgKGZ1biAoKSAtPiByZWFsbHlfcmVhZF9saW5lIH53YWl0X3RpbWUgdClcblxuKCogW2RvX3JlYWRfa10gdGFrZXMgYSBbcmVhZF9rXSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgY29udGludWF0aW9uIGV4cGVjdGluZyBhblxuICAgW09yX2Vycm9yLnRdLiAgSXQgdXNlcyB0aGlzIHRvIGRvIGEgcmVhZCByZXR1cm5pbmcgYSBkZWZlcnJlZC4gIFRoaXMgYWxsb3dzIGl0IHRvIGNhbGxcbiAgIFtmaW5pc2hlZF9yZWFkXSBiZWZvcmUgY29udGludWluZywgaW4gdGhlIGV2ZW50IHRoYXQgdGhlIHJlc3VsdCBpcyBhbiBlcnJvci4gKilcbmxldCBkb19yZWFkX2tcbiAgKHR5cGUgciByJylcbiAgdFxuICAocmVhZF9rIDogKHIgT3JfZXJyb3IudCAtPiB1bml0KSAtPiB1bml0KVxuICAobWFrZV9yZXN1bHQgOiByIC0+IHInKVxuICA6IHInIERlZmVycmVkLnRcbiAgPVxuICB1c2UgdDtcbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgcmVhZF9rIChmdW4gciAtPlxuICAgICAgZmluaXNoZWRfcmVhZCB0O1xuICAgICAgSXZhci5maWxsX2V4biByZXN1bHQgKG1ha2VfcmVzdWx0IChva19leG4gcikpKSlcbjs7XG5cbmxldCByZWFkX3VudGlsIHQgcCB+a2VlcF9kZWxpbSA9IGRvX3JlYWRfayB0IChyZWFkX3VudGlsIHQgcCB+a2VlcF9kZWxpbSkgRm4uaWRcblxubGV0IHJlYWRfdW50aWxfYm91bmRlZCB0IHAgfmtlZXBfZGVsaW0gfm1heCA9XG4gIGRvX3JlYWRfayB0IChyZWFkX3VudGlsX2dlbiB0IHAgfmtlZXBfZGVsaW0gfm1heDooU29tZSBtYXgpKSBGbi5pZFxuOztcblxubGV0IHJlYWRfc2V4cCA/cGFyc2VfcG9zIHQgPVxuICBkb19yZWFkX2sgdCAoZ2VuX3JlYWRfc2V4cCB0IH5zZXhwX2tpbmQ6UGxhaW4gP3BhcnNlX3BvcykgKGZ1bmN0aW9uXG4gICAgfCBgRW9mIC0+IGBFb2ZcbiAgICB8IGBPayAoc2V4cCwgXykgLT4gYE9rIHNleHApXG47O1xuXG5sZXQgcmVhZF9zZXhwcyA/cGFyc2VfcG9zIHQgPVxuICB1c2UgdDtcbiAgcmVhZF9zZXhwcyA/cGFyc2VfcG9zIHRcbjs7XG5cbmxldCByZWFkX2Fubm90YXRlZF9zZXhwcyA/cGFyc2VfcG9zIHQgPVxuICB1c2UgdDtcbiAgcmVhZF9hbm5vdGF0ZWRfc2V4cHMgP3BhcnNlX3BvcyB0XG47O1xuXG5sZXQgcGVla19vcl9yZWFkX2Jpbl9wcm90ID9tYXhfbGVuIHQgcmVhZGVyIH5wZWVrX29yX3JlYWQgPVxuICBkb19yZWFkX2sgdCAocGVla19vcl9yZWFkX2Jpbl9wcm90ID9tYXhfbGVuIHQgcmVhZGVyIH5wZWVrX29yX3JlYWQpIEZuLmlkXG47O1xuXG5sZXQgcGVla19iaW5fcHJvdCA/bWF4X2xlbiB0IHJlYWRlciA9XG4gIHBlZWtfb3JfcmVhZF9iaW5fcHJvdCA/bWF4X2xlbiB0IHJlYWRlciB+cGVla19vcl9yZWFkOlBlZWtcbjs7XG5cbmxldCByZWFkX2Jpbl9wcm90ID9tYXhfbGVuIHQgcmVhZGVyID1cbiAgcGVla19vcl9yZWFkX2Jpbl9wcm90ID9tYXhfbGVuIHQgcmVhZGVyIH5wZWVrX29yX3JlYWQ6UmVhZFxuOztcblxubGV0IGl0ZXJfYmluX3Byb3QgdCByZWFkZXIgfmYgPVxuICB1c2UgdDtcbiAgaXRlcl9iaW5fcHJvdCB0IHJlYWRlciB+ZlxuOztcblxubGV0IGl0ZXJfYmluX3Byb3RfZXhuIHQgcmVhZGVyIH5mID0gaXRlcl9iaW5fcHJvdCB0IHJlYWRlciB+ZiA+Pnwgb2tfZXhuXG5cbmxldCByZWFkX2Jpbl9wcm90X2ludG9fcGlwZSB0IHJlYWRlciB+ZiA9XG4gIFBpcGUuY3JlYXRlX3JlYWRlciB+Y2xvc2Vfb25fZXhjZXB0aW9uOmZhbHNlIChmdW4gd3JpdGVyIC0+XG4gICAgdXBvbiAoUGlwZS5jbG9zZWQgd3JpdGVyKSAoZnVuICgpIC0+IGRvbid0X3dhaXRfZm9yIChjbG9zZSB0KSk7XG4gICAgaXRlcl9iaW5fcHJvdF9leG4gdCByZWFkZXIgfmY6KGZ1biBlbGVtZW50IC0+XG4gICAgICBFYWdlcl9kZWZlcnJlZC4oZiBlbGVtZW50ID4+PSBQaXBlLndyaXRlX2lmX29wZW4gd3JpdGVyKSkpXG47O1xuXG5sZXQgcmVhZF9tYXJzaGFsX3JhdyB0ID0gZG9fcmVhZCB0IChmdW4gKCkgLT4gcmVhZF9tYXJzaGFsX3JhdyB0KVxubGV0IHJlYWRfbWFyc2hhbCB0ID0gZG9fcmVhZCB0IChmdW4gKCkgLT4gcmVhZF9tYXJzaGFsIHQpXG5sZXQgcmVjdiB0ID0gZG9fcmVhZCB0IChmdW4gKCkgLT4gcmVjdiB0KVxuXG4oKiBbcmVhZF9hbGxdIGRvZXMgbm90IGNhbGwgW3VzZSB0XSwgYmVjYXVzZSBbcmVhZF9vbmVdIHdpbGwgZG8gc28gZWFjaCB0aW1lIGl0IGlzIHVzaW5nXG4gICBbdF0uICopXG5sZXQgcmVhZF9hbGwgP2Nsb3NlX3doZW5fZmluaXNoZWQgdCByZWFkX29uZSA9IHJlYWRfYWxsID9jbG9zZV93aGVuX2ZpbmlzaGVkIHQgcmVhZF9vbmVcblxubGV0IGxpbmVzIHQgPVxuICB1c2UgdDtcbiAgbGluZXMgdFxuOztcblxubGV0IGNvbnRlbnRzIHQgPSBkb19yZWFkIHQgKGZ1biAoKSAtPiBjb250ZW50cyB0KVxubGV0IGZpbGVfY29udGVudHMgZmlsZSA9IHdpdGhfZmlsZSBmaWxlIH5mOmNvbnRlbnRzXG5cbmxldCBmaWxlX2xpbmVzIGZpbGUgPVxuICBsZXQlYmluZCB0ID0gb3Blbl9maWxlIGZpbGUgaW5cbiAgUGlwZS50b19saXN0IChsaW5lcyB0KVxuOztcblxubGV0IHRyYW5zZmVyIHQgPVxuICB1c2UgdDtcbiAgdHJhbnNmZXIgdFxuOztcblxubGV0IGxzZWVrIHQgb2Zmc2V0IH5tb2RlID1cbiAgZG9fcmVhZCB0IChmdW4gKCkgLT5cbiAgICB0LnBvcyA8LSAwO1xuICAgIHQuYXZhaWxhYmxlIDwtIDA7XG4gICAgVW5peF9zeXNjYWxscy5sc2VlayB0LmZkIG9mZnNldCB+bW9kZSlcbjs7XG5cbmxldCBsdGVsbCB0ID1cbiAgZG9fcmVhZCB0IChmdW4gKCkgLT5cbiAgICBsZXQlbWFwIGZkX29mZnNldCA9IFVuaXhfc3lzY2FsbHMubHNlZWsgdC5mZCBJbnQ2NC56ZXJvIH5tb2RlOmBDdXIgaW5cbiAgICBJbnQ2NC4oIC0gKSBmZF9vZmZzZXQgKEludDY0Lm9mX2ludCB0LmF2YWlsYWJsZSkpXG47O1xuXG5sZXQgZ2V0X2Vycm9yXG4gICh0eXBlIGEgc2V4cClcbiAgfmZpbGVcbiAgfihzZXhwX2tpbmQgOiBzZXhwIHNleHBfa2luZClcbiAgfihhX29mX3NleHAgOiBzZXhwIC0+IGEpXG4gIChhbm5vdGF0ZWRfc2V4cCA6IFNleHAuQW5ub3RhdGVkLnQpXG4gID1cbiAgdHJ5XG4gICAgaWdub3JlXG4gICAgICAoYV9vZl9zZXhwXG4gICAgICAgICAobWF0Y2ggc2V4cF9raW5kIHdpdGhcbiAgICAgICAgICB8IFBsYWluIC0+IChTZXhwLkFubm90YXRlZC5nZXRfc2V4cCBhbm5vdGF0ZWRfc2V4cCA6IHNleHApXG4gICAgICAgICAgfCBBbm5vdGF0ZWQgLT4gKGFubm90YXRlZF9zZXhwIDogc2V4cCkpXG4gICAgICAgIDogYSk7XG4gICAgT2sgKClcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIGxldCB1bmV4cGVjdGVkX2Vycm9yICgpID1cbiAgICAgIGVycm9yIFwiUmVhZGVyLmxvYWRfc2V4cCBlcnJvclwiIChmaWxlLCBleG4pIFslc2V4cF9vZjogc3RyaW5nICogZXhuXVxuICAgIGluXG4gICAgKG1hdGNoIGV4biB3aXRoXG4gICAgIHwgT2Zfc2V4cF9lcnJvciAoZXhjLCBiYWRfc2V4cCkgLT5cbiAgICAgICAobWF0Y2ggU2V4cC5Bbm5vdGF0ZWQuZmluZF9zZXhwIGFubm90YXRlZF9zZXhwIGJhZF9zZXhwIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHVuZXhwZWN0ZWRfZXJyb3IgKClcbiAgICAgICAgfCBTb21lIGJhZF9hbm5vdGF0ZWRfc2V4cCAtPlxuICAgICAgICAgIChtYXRjaCBTZXhwLkFubm90YXRlZC5nZXRfY29udl9leG4gfmZpbGUgfmV4YyBiYWRfYW5ub3RhdGVkX3NleHAgd2l0aFxuICAgICAgICAgICB8IE9mX3NleHBfZXJyb3IgKFNleHAuQW5ub3RhdGVkLkNvbnZfZXhuIChwb3MsIGV4biksIHNleHApIC0+XG4gICAgICAgICAgICAgKCogVGhlIGVycm9yIHByb2R1Y2VkIGJ5IFtnZXRfY29udl9leG5dIGFscmVhZHkgaGFzIHRoZSBmaWxlIHBvc2l0aW9uLCBzb1xuICAgICAgICAgICAgICAgIHdlIGRvbid0IHdyYXAgd2l0aCBhIHJlZHVuZGFudCBlcnJvciBtZXNzYWdlLiAqKVxuICAgICAgICAgICAgIE9yX2Vycm9yLmVycm9yXG4gICAgICAgICAgICAgICBcImludmFsaWQgc2V4cFwiXG4gICAgICAgICAgICAgICAocG9zLCBleG4sIFwiaW5cIiwgc2V4cClcbiAgICAgICAgICAgICAgIFslc2V4cF9vZjogc3RyaW5nICogZXhuICogc3RyaW5nICogU2V4cC50XVxuICAgICAgICAgICB8IF8gLT4gdW5leHBlY3RlZF9lcnJvciAoKSkpXG4gICAgIHwgXyAtPiB1bmV4cGVjdGVkX2Vycm9yICgpKVxuOztcblxubGV0IGdlbl9sb2FkX2V4blxuICAodHlwZSBzZXhwIGEpXG4gID9leGNsdXNpdmVcbiAgfihzZXhwX2tpbmQgOiBzZXhwIHNleHBfa2luZClcbiAgfmZpbGVcbiAgKGNvbnZlcnQgOiBzZXhwIGxpc3QgLT4gYSlcbiAgKGdldF9lcnJvciA6IFNleHAuQW5ub3RhdGVkLnQgbGlzdCAtPiBFcnJvci50KVxuICA6IGEgRGVmZXJyZWQudFxuICA9XG4gIGxldCBtYXlfbG9hZF9maWxlX211bHRpcGxlX3RpbWVzID0gcmVmIGZhbHNlIGluXG4gIGxldCBsb2FkIH5zZXhwX2tpbmQgPVxuICAgIG1hdGNoJW1hcFxuICAgICAgTW9uaXRvci50cnlfd2l0aCB+cnVuOmBTY2hlZHVsZSB+cmVzdDpgTG9nIH5leHRyYWN0X2V4bjp0cnVlIChmdW4gKCkgLT5cbiAgICAgICAgd2l0aF9maWxlID9leGNsdXNpdmUgZmlsZSB+ZjooZnVuIHQgLT5cbiAgICAgICAgICAobWF5X2xvYWRfZmlsZV9tdWx0aXBsZV90aW1lc1xuICAgICAgICAgICAgIDo9ICgqIEFsdGhvdWdoIFtmaWxlXSB0eXBpY2FsbHkgaXMgb2Yga2luZCBbRmQuS2luZC5GaWxlXSwgaXQgbWF5IGFsc28gaGF2ZSBvdGhlclxuICAgICAgICAgICAgICAgICAgICBraW5kcy4gIFdlIGNhbiBvbmx5IGxvYWQgaXQgbXVsdGlwbGUgdGltZXMgaWYgaXQgaGFzIGtpbmQgW0ZpbGVdLiAqKVxuICAgICAgICAgICAgICAgIG1hdGNoIEZkLmtpbmQgKGZkIHQpIHdpdGhcbiAgICAgICAgICAgICAgICB8IEZpbGUgLT4gdHJ1ZVxuICAgICAgICAgICAgICAgIHwgQ2hhciB8IEZpZm8gfCBTb2NrZXQgXyAtPiBmYWxzZSk7XG4gICAgICAgICAgdXNlIHQ7XG4gICAgICAgICAgUGlwZS50b19saXN0IChnZW5fcmVhZF9zZXhwcyB0IH5zZXhwX2tpbmQpKSlcbiAgICB3aXRoXG4gICAgfCBPayBzZXhwcyAtPiBzZXhwc1xuICAgIHwgRXJyb3IgZXhuIC0+XG4gICAgICAobWF0Y2ggZXhuIHdpdGhcbiAgICAgICB8IFNleHAuUGFyc2VfZXJyb3IgeyBlcnJfbXNnOyBwYXJzZV9zdGF0ZTsgXyB9IC0+XG4gICAgICAgICAoKiBUaGlzIGNvZGUgcmVmb3JtYXRzIHRoZSBbUGFyc2VfZXJyb3JdIHByb2R1Y2VkIGJ5IHNleHBsaWIgdG8gYmUgbW9yZVxuICAgICAgICAgICAgcmVhZGFibGUuICopXG4gICAgICAgICBsZXQgcGFyc2VfcG9zID1cbiAgICAgICAgICAgbWF0Y2ggcGFyc2Vfc3RhdGUgd2l0aFxuICAgICAgICAgICB8IGBTZXhwIHsgcGFyc2VfcG9zOyBfIH0gfCBgQW5ub3QgeyBwYXJzZV9wb3M7IF8gfSAtPiBwYXJzZV9wb3NcbiAgICAgICAgIGluXG4gICAgICAgICBFcnJvci5yYWlzZVxuICAgICAgICAgICAoRXJyb3IuY3JlYXRlXG4gICAgICAgICAgICAgIFwic3ludGF4IGVycm9yIHdoZW4gcGFyc2luZyBzZXhwXCJcbiAgICAgICAgICAgICAgKHNwcmludGYgXCIlczolZDolZFwiIGZpbGUgcGFyc2VfcG9zLnRleHRfbGluZSBwYXJzZV9wb3MudGV4dF9jaGFyLCBlcnJfbXNnKVxuICAgICAgICAgICAgICBbJXNleHBfb2Y6IHN0cmluZyAqIHN0cmluZ10pXG4gICAgICAgfCBfIC0+IHJhaXNlIGV4bilcbiAgaW5cbiAgbGV0JWJpbmQgc2V4cHMgPSBsb2FkIH5zZXhwX2tpbmQgaW5cbiAgdHJ5IHJldHVybiAoY29udmVydCBzZXhwcykgd2l0aFxuICB8IE9mX3NleHBfZXJyb3IgKGV4biwgX2JhZF9zdWJzZXhwKSAtPlxuICAgIGlmICFtYXlfbG9hZF9maWxlX211bHRpcGxlX3RpbWVzXG4gICAgdGhlbiAoXG4gICAgICBsZXQlYmluZCBzZXhwcyA9IGxvYWQgfnNleHBfa2luZDpBbm5vdGF0ZWQgaW5cbiAgICAgIEVycm9yLnJhaXNlIChnZXRfZXJyb3Igc2V4cHMpKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIHNleHAgKGZhaWxlZCB0byBkZXRlcm1pbmUgbG9jYXRpb24gaW5mb3JtYXRpb24pXCJcbiAgICAgICAgICAgIChmaWxlIDogc3RyaW5nKVxuICAgICAgICAgICAgKGV4biA6IGV4bildXG4gIHwgZXhuIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiUmVhZGVyLmxvYWRfc2V4cChzKSBlcnJvclwiIChmaWxlIDogc3RyaW5nKSAoZXhuIDogZXhuKV1cbjs7XG5cbnR5cGUgKCdzZXhwLCAnYSwgJ2IpIGxvYWQgPSA/ZXhjbHVzaXZlOmJvb2wgLT4gc3RyaW5nIC0+ICgnc2V4cCAtPiAnYSkgLT4gJ2IgRGVmZXJyZWQudFxuXG5sZXQgZ2V0X2xvYWRfcmVzdWx0X2V4biA9IGZ1bmN0aW9uXG4gIHwgYFJlc3VsdCB4IC0+IHhcbiAgfCBgRXJyb3IgKGV4biwgX3NleHApIC0+IHJhaXNlIGV4blxuOztcblxubGV0IGdlbl9sb2FkX3NleHBfZXhuXG4gICh0eXBlIGEgc2V4cClcbiAgP2V4Y2x1c2l2ZVxuICB+KHNleHBfa2luZCA6IHNleHAgc2V4cF9raW5kKVxuICB+ZmlsZVxuICB+KGFfb2Zfc2V4cCA6IHNleHAgLT4gYSlcbiAgKClcbiAgPVxuICBsZXQgbXVsdGlwbGUgc2V4cHMgPVxuICAgIEVycm9yLmNyZWF0ZVxuICAgICAgXCJSZWFkZXIubG9hZF9zZXhwIHJlcXVpcmVzIG9uZSBzZXhwIGJ1dCBnb3RcIlxuICAgICAgKExpc3QubGVuZ3RoIHNleHBzLCBmaWxlKVxuICAgICAgWyVzZXhwX29mOiBpbnQgKiBzdHJpbmddXG4gIGluXG4gIGdlbl9sb2FkX2V4blxuICAgID9leGNsdXNpdmVcbiAgICB+ZmlsZVxuICAgIH5zZXhwX2tpbmRcbiAgICAoZnVuIHNleHBzIC0+XG4gICAgICBtYXRjaCBzZXhwcyB3aXRoXG4gICAgICB8IFsgc2V4cCBdIC0+IGFfb2Zfc2V4cCBzZXhwXG4gICAgICB8IF8gLT4gRXJyb3IucmFpc2UgKG11bHRpcGxlIHNleHBzKSlcbiAgICAoZnVuIGFubm90X3NleHBzIC0+XG4gICAgICBtYXRjaCBhbm5vdF9zZXhwcyB3aXRoXG4gICAgICB8IFsgYW5ub3Rfc2V4cCBdIC0+XG4gICAgICAgIChtYXRjaCBnZXRfZXJyb3IgfmZpbGUgfnNleHBfa2luZCB+YV9vZl9zZXhwIGFubm90X3NleHAgd2l0aFxuICAgICAgICAgfCBFcnJvciBlIC0+IGVcbiAgICAgICAgIHwgT2sgKCkgLT5cbiAgICAgICAgICAgRXJyb3IuY3JlYXRlXG4gICAgICAgICAgICAgXCJjb252ZXJzaW9uIG9mIGFubm90YXRlZCBzZXhwIHVuZXhwZWN0ZWRseSBzdWNjZWVkZWRcIlxuICAgICAgICAgICAgIChTZXhwLkFubm90YXRlZC5nZXRfc2V4cCBhbm5vdF9zZXhwKVxuICAgICAgICAgICAgIFslc2V4cF9vZjogU2V4cC50XSlcbiAgICAgIHwgXyAtPiBtdWx0aXBsZSBhbm5vdF9zZXhwcylcbjs7XG5cbmxldCBsb2FkX3NleHBfZXhuID9leGNsdXNpdmUgZmlsZSBhX29mX3NleHAgPVxuICBnZW5fbG9hZF9zZXhwX2V4biA/ZXhjbHVzaXZlIH5zZXhwX2tpbmQ6UGxhaW4gfmZpbGUgfmFfb2Zfc2V4cCAoKVxuOztcblxubGV0IGxvYWRfYW5ub3RhdGVkX3NleHBfZXhuID9leGNsdXNpdmUgZmlsZSBhX29mX3NleHAgPVxuICBnZW5fbG9hZF9zZXhwX2V4biA/ZXhjbHVzaXZlIH5zZXhwX2tpbmQ6QW5ub3RhdGVkIH5maWxlIH5hX29mX3NleHAgKClcbjs7XG5cbmxldCBnZW5fbG9hZF9zZXhwID9leGNsdXNpdmUgfnNleHBfa2luZCB+ZmlsZSB+YV9vZl9zZXhwICgpID1cbiAgRGVmZXJyZWQuT3JfZXJyb3IudHJ5X3dpdGhcbiAgICB+cnVuOmBTY2hlZHVsZVxuICAgIH5yZXN0OmBMb2dcbiAgICB+ZXh0cmFjdF9leG46dHJ1ZVxuICAgIChnZW5fbG9hZF9zZXhwX2V4biA/ZXhjbHVzaXZlIH5zZXhwX2tpbmQgfmZpbGUgfmFfb2Zfc2V4cClcbjs7XG5cbmxldCBsb2FkX3NleHAgP2V4Y2x1c2l2ZSBmaWxlIGFfb2Zfc2V4cCA9XG4gIGdlbl9sb2FkX3NleHAgP2V4Y2x1c2l2ZSB+c2V4cF9raW5kOlBsYWluIH5maWxlIH5hX29mX3NleHAgKClcbjs7XG5cbmxldCBsb2FkX2Fubm90YXRlZF9zZXhwID9leGNsdXNpdmUgZmlsZSBhX29mX3NleHAgPVxuICBnZW5fbG9hZF9zZXhwID9leGNsdXNpdmUgfnNleHBfa2luZDpBbm5vdGF0ZWQgfmZpbGUgfmFfb2Zfc2V4cCAoKVxuOztcblxubGV0IGdlbl9sb2FkX3NleHBzX2V4blxuICAodHlwZSBhIHNleHApXG4gID9leGNsdXNpdmVcbiAgfihzZXhwX2tpbmQgOiBzZXhwIHNleHBfa2luZClcbiAgfmZpbGVcbiAgfihhX29mX3NleHAgOiBzZXhwIC0+IGEpXG4gICgpXG4gID1cbiAgZ2VuX2xvYWRfZXhuXG4gICAgP2V4Y2x1c2l2ZVxuICAgIH5maWxlXG4gICAgfnNleHBfa2luZFxuICAgIChmdW4gc2V4cHMgLT4gTGlzdC5tYXAgc2V4cHMgfmY6YV9vZl9zZXhwKVxuICAgIChmdW4gYW5ub3Rfc2V4cHMgLT5cbiAgICAgIEVycm9yLm9mX2xpc3RcbiAgICAgICAgKExpc3QuZmlsdGVyX21hcCBhbm5vdF9zZXhwcyB+ZjooZnVuIGFubm90X3NleHAgLT5cbiAgICAgICAgICAgbWF0Y2ggZ2V0X2Vycm9yIH5maWxlIH5zZXhwX2tpbmQgfmFfb2Zfc2V4cCBhbm5vdF9zZXhwIHdpdGhcbiAgICAgICAgICAgfCBPayBfIC0+IE5vbmVcbiAgICAgICAgICAgfCBFcnJvciBlcnJvciAtPiBTb21lIGVycm9yKSkpXG47O1xuXG5sZXQgbG9hZF9zZXhwc19leG4gP2V4Y2x1c2l2ZSBmaWxlIGFfb2Zfc2V4cCA9XG4gIGdlbl9sb2FkX3NleHBzX2V4biA/ZXhjbHVzaXZlIH5zZXhwX2tpbmQ6UGxhaW4gfmZpbGUgfmFfb2Zfc2V4cCAoKVxuOztcblxubGV0IGxvYWRfYW5ub3RhdGVkX3NleHBzX2V4biA/ZXhjbHVzaXZlIGZpbGUgYV9vZl9zZXhwID1cbiAgZ2VuX2xvYWRfc2V4cHNfZXhuID9leGNsdXNpdmUgfnNleHBfa2luZDpBbm5vdGF0ZWQgfmZpbGUgfmFfb2Zfc2V4cCAoKVxuOztcblxubGV0IGdlbl9sb2FkX3NleHBzID9leGNsdXNpdmUgfnNleHBfa2luZCB+ZmlsZSB+YV9vZl9zZXhwICgpID1cbiAgRGVmZXJyZWQuT3JfZXJyb3IudHJ5X3dpdGhcbiAgICB+cnVuOmBTY2hlZHVsZVxuICAgIH5yZXN0OmBMb2dcbiAgICB+ZXh0cmFjdF9leG46dHJ1ZVxuICAgIChnZW5fbG9hZF9zZXhwc19leG4gP2V4Y2x1c2l2ZSB+c2V4cF9raW5kIH5maWxlIH5hX29mX3NleHApXG47O1xuXG5sZXQgbG9hZF9zZXhwcyA/ZXhjbHVzaXZlIGZpbGUgYV9vZl9zZXhwID1cbiAgZ2VuX2xvYWRfc2V4cHMgP2V4Y2x1c2l2ZSB+c2V4cF9raW5kOlBsYWluIH5maWxlIH5hX29mX3NleHAgKClcbjs7XG5cbmxldCBsb2FkX2Fubm90YXRlZF9zZXhwcyA/ZXhjbHVzaXZlIGZpbGUgYV9vZl9zZXhwID1cbiAgZ2VuX2xvYWRfc2V4cHMgP2V4Y2x1c2l2ZSB+c2V4cF9raW5kOkFubm90YXRlZCB+ZmlsZSB+YV9vZl9zZXhwICgpXG47O1xuXG5sZXQgcGlwZSB0ID1cbiAgbGV0IHBpcGVfciwgcGlwZV93ID0gUGlwZS5jcmVhdGUgKCkgaW5cbiAgdXBvbiAodHJhbnNmZXIgdCBwaXBlX3cpIChmdW4gKCkgLT4gY2xvc2UgdCA+Pj4gZnVuICgpIC0+IFBpcGUuY2xvc2UgcGlwZV93KTtcbiAgcGlwZV9yXG47O1xuXG5sZXQgZHJhaW4gdCA9XG4gIG1hdGNoJWJpbmRcbiAgICByZWFkX29uZV9jaHVua19hdF9hX3RpbWUgdCB+aGFuZGxlX2NodW5rOihmdW4gX2JpZ3N0cmluZyB+cG9zOl8gfmxlbjpfIC0+XG4gICAgICByZXR1cm4gYENvbnRpbnVlKVxuICB3aXRoXG4gIHwgYFN0b3BwZWQgXyB8IGBFb2Zfd2l0aF91bmNvbnN1bWVkX2RhdGEgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBgRW9mIC0+IGNsb3NlIHRcbjs7XG5cbnR5cGUgKCdhLCAnYikgbG9hZF9iaW5fcHJvdCA9XG4gID9leGNsdXNpdmU6Ym9vbFxuICAtPiA/bWF4X2xlbjppbnRcbiAgLT4gc3RyaW5nXG4gIC0+ICdhIEJpbl9wcm90LlR5cGVfY2xhc3MucmVhZGVyXG4gIC0+ICdiIERlZmVycmVkLnRcblxubGV0IGxvYWRfYmluX3Byb3QgP2V4Y2x1c2l2ZSA/bWF4X2xlbiBmaWxlIGJpbl9yZWFkZXIgPVxuICBtYXRjaCVtYXBcbiAgICBNb25pdG9yLnRyeV93aXRoX29yX2Vycm9yIH5yZXN0OmBMb2cgfm5hbWU6XCJSZWFkZXIubG9hZF9iaW5fcHJvdFwiIChmdW4gKCkgLT5cbiAgICAgIHdpdGhfZmlsZSA/ZXhjbHVzaXZlIGZpbGUgfmY6KGZ1biB0IC0+IHJlYWRfYmluX3Byb3QgP21heF9sZW4gdCBiaW5fcmVhZGVyKSlcbiAgd2l0aFxuICB8IE9rIChgT2sgdikgLT4gT2sgdlxuICB8IE9rIGBFb2YgLT4gT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwiUmVhZGVyLmxvYWRfYmluX3Byb3QgZ290IHVuZXhwZWN0ZWQgZW9mXCJcbiAgfCBFcnJvciBfIGFzIHJlc3VsdCAtPiByZXN1bHRcbjs7XG5cbmxldCBsb2FkX2Jpbl9wcm90X2V4biA/ZXhjbHVzaXZlID9tYXhfbGVuIGZpbGUgYmluX3JlYWRlciA9XG4gIGxvYWRfYmluX3Byb3QgP2V4Y2x1c2l2ZSA/bWF4X2xlbiBmaWxlIGJpbl9yZWFkZXIgPj58IG9rX2V4blxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbmluY2x1ZGUgUmVhZGVyMFxubW9kdWxlIFdyaXRlciA9IFdyaXRlcjBcblxubGV0IG9mX3BpcGUgaW5mbyBwaXBlX3IgPVxuICBsZXQlbWFwIGBSZWFkZXIgcmVhZGVyX2ZkLCBgV3JpdGVyIHdyaXRlcl9mZCA9IFVuaXgucGlwZSBpbmZvIGluXG4gIGxldCByZWFkZXIgPSBjcmVhdGUgcmVhZGVyX2ZkIGluXG4gIGxldCB3cml0ZXIgPVxuICAgIFdyaXRlci5jcmVhdGUgfmJ1ZmZlcl9hZ2VfbGltaXQ6YFVubGltaXRlZCB+cmFpc2Vfd2hlbl9jb25zdW1lcl9sZWF2ZXM6ZmFsc2Ugd3JpdGVyX2ZkXG4gIGluXG4gIGlmIGZhbHNlXG4gIHRoZW5cbiAgICBEZWJ1Zy5sb2dcbiAgICAgIFwiUmVhZGVyLm9mX3BpcGVcIlxuICAgICAgKHBpcGVfciwgcmVhZGVyLCB3cml0ZXIpXG4gICAgICBbJXNleHBfb2Y6IHN0cmluZyBQaXBlLlJlYWRlci50ICogdCAqIFdyaXRlci50XTtcbiAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAobGV0JWJpbmQgKCkgPVxuICAgICAgIFdyaXRlci50cmFuc2ZlciB3cml0ZXIgcGlwZV9yIH5zdG9wOihjbG9zZV9maW5pc2hlZCByZWFkZXIpIChmdW4gcyAtPlxuICAgICAgICAgV3JpdGVyLndyaXRlIHdyaXRlciBzKVxuICAgICBpblxuICAgICBXcml0ZXIuY2xvc2Ugd3JpdGVyKTtcbiAgcmVhZGVyXG47O1xuXG5tb2R1bGUgRm9yX3Rlc3RpbmcgPSBzdHJ1Y3RcbiAgbGV0IG9mX3N0cmluZyA/KGluZm8gPSBJbmZvLm9mX3N0cmluZyBcInJlYWRlciBvZiBzdHJpbmcgY29udGVudHMgZm9yIHRlc3RzXCIpIHN0ciA9XG4gICAgb2ZfcGlwZSBpbmZvIChQaXBlLnNpbmdsZXRvbiBzdHIpXG4gIDs7XG5lbmRcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbmluY2x1ZGUgV3JpdGVyMFxubW9kdWxlIFVuaXggPSBVbml4X3N5c2NhbGxzXG5cbmxldCBvZl9waXBlID90aW1lX3NvdXJjZSBpbmZvIHBpcGVfdyA9XG4gIGxldCVtYXAgYFJlYWRlciByZWFkZXJfZmQsIGBXcml0ZXIgd3JpdGVyX2ZkID0gVW5peC5waXBlIGluZm8gaW5cbiAgbGV0IHJlYWRlciA9IFJlYWRlci5jcmVhdGUgcmVhZGVyX2ZkIGluXG4gIGxldCB3cml0ZXIgPSBjcmVhdGUgP3RpbWVfc291cmNlIHdyaXRlcl9mZCBpblxuICBpZiBEZWJ1Zy53cml0ZXJcbiAgdGhlblxuICAgIERlYnVnLmxvZ1xuICAgICAgXCJXcml0ZXIub2ZfcGlwZVwiXG4gICAgICAocGlwZV93LCByZWFkZXIsIHdyaXRlcilcbiAgICAgIFslc2V4cF9vZjogc3RyaW5nIFBpcGUuV3JpdGVyLnQgKiBSZWFkZXIudCAqIHRdO1xuICAoKiBTaHV0dGxlIGJ5dGVzIGZyb20gW3JlYWRlcl0gdG8gW3BpcGVfd10uICBJZiB0aGUgdXNlciBjYWxscyBbY2xvc2Ugd3JpdGVyXSxcbiAgICAgdGhlbiBbcmVhZGVyXSB3aWxsIHNlZSBFT0YsIHdoaWNoIHdpbGwgY2F1c2UgW3RyYW5zZmVyXSB0byBjb21wbGV0ZS4gIElmIFtwaXBlX3ddXG4gICAgIGlzIGNsb3NlZCwgdGhlbiBbdHJhbnNmZXJdIHdpbGwgY29tcGxldGUuICopXG4gIGxldCBjbG9zZWRfYW5kX2ZsdXNoZWRfZG93bnN0cmVhbSA9XG4gICAgbGV0JWJpbmQgKCkgPSBSZWFkZXIudHJhbnNmZXIgcmVhZGVyIHBpcGVfdyBpblxuICAgIGlmIHJhaXNlX3doZW5fY29uc3VtZXJfbGVhdmVzIHdyaXRlciAmJiBub3QgKGlzX2Nsb3NlZCB3cml0ZXIpXG4gICAgdGhlblxuICAgICAgTW9uaXRvci5zZW5kX2V4blxuICAgICAgICAobW9uaXRvciB3cml0ZXIpXG4gICAgICAgIChVbml4LlVuaXhfZXJyb3IgKEVQSVBFLCBcIldyaXRlci5vZl9waXBlXCIsIFNleHAudG9fc3RyaW5nIChJbmZvLnNleHBfb2ZfdCBpbmZvKSkpO1xuICAgIGxldCVtYXAgKCksICgpID0gRGVmZXJyZWQuYm90aCAoUmVhZGVyLmNsb3NlIHJlYWRlcikgKGNsb3NlIHdyaXRlcikgaW5cbiAgICBpZiBub3QgKFBpcGUuaXNfY2xvc2VkIHBpcGVfdykgdGhlbiBQaXBlLmNsb3NlIHBpcGVfd1xuICBpblxuICB3cml0ZXIsIGBDbG9zZWRfYW5kX2ZsdXNoZWRfZG93bnN0cmVhbSBjbG9zZWRfYW5kX2ZsdXNoZWRfZG93bnN0cmVhbVxuOztcblxubGV0IHNwbGljZV9yZXN1bHQgdCB+ZnJvbSA9XG4gIG1hdGNoJW1hcFxuICAgIFJlYWRlci5yZWFkX29uZV9jaHVua19hdF9hX3RpbWUgZnJvbSB+aGFuZGxlX2NodW5rOihmdW4gYnVmZmVyIH5wb3MgfmxlbiAtPlxuICAgICAgc2NoZWR1bGVfYmlnc3RyaW5nIHQgfnBvcyB+bGVuIGJ1ZmZlcjtcbiAgICAgIG1hdGNoJW1hcCBmbHVzaGVkX29yX2ZhaWxlZF93aXRoX3Jlc3VsdCB0IHdpdGhcbiAgICAgIHwgRmx1c2hlZCAoXyA6IFRpbWVfbnMudCkgLT4gYENvbnRpbnVlXG4gICAgICB8IEVycm9yIC0+IGBTdG9wIGBFcnJvclxuICAgICAgfCBDb25zdW1lcl9sZWZ0IHwgRm9yY2VfY2xvc2VkIC0+IGBTdG9wIGBDb25zdW1lcl9sZWZ0KVxuICB3aXRoXG4gIHwgYEVvZl93aXRoX3VuY29uc3VtZWRfZGF0YSAoXyA6IHN0cmluZykgLT4gYXNzZXJ0IGZhbHNlXG4gICgqIHVucmVhY2hhYmxlIGJlY2F1c2UgW2hhbmRsZV9jaHVua10gb25seSByZXR1cm5zIFtgU3RvcHxgQ29udGludWVdICopXG4gIHwgYEVvZiAtPiBgT2tcbiAgfCBgU3RvcHBlZCByZXN1bHQgLT4gcmVzdWx0XG47O1xuXG5sZXQgc3BsaWNlIHQgfmZyb20gPSBzcGxpY2VfcmVzdWx0IHQgfmZyb20gfD4gRGVmZXJyZWQuaWdub3JlX21cbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIFRpbWVfc291cmNlID0gQXN5bmNfa2VybmVsLlRpbWVfc291cmNlXG5cbmxldCBydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluID0gS2VybmVsX3NjaGVkdWxlci5ydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluXG5cbmxldCViZW5jaF9tb2R1bGUgXCJDbG9jay5ldmVyeVwiID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICBsZXQgc2NoZWR1bGVyID0gS2VybmVsX3NjaGVkdWxlci50ICgpXG4gICAgbGV0IHRpbWVfc291cmNlID0gc2NoZWR1bGVyLnRpbWVfc291cmNlIHw+IFRpbWVfc291cmNlLm9mX3N5bmNocm9ub3VzXG5cbiAgICBsZXQlYmVuY2ggXCJ+Y29udGludWUtb24tZXJyb3I6ZmFsc2VcIiA9XG4gICAgICBsZXQgaXYgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgVGltZV9zb3VyY2UucnVuX3JlcGVhdGVkbHlcbiAgICAgICAgdGltZV9zb3VyY2VcbiAgICAgICAgfnN0b3A6KEl2YXIucmVhZCBpdilcbiAgICAgICAgfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlXG4gICAgICAgIH5mOihmdW4gKCkgLT5cbiAgICAgICAgICBpZiAhbiA+PSAxXzAwMCB0aGVuIEl2YXIuZmlsbF9leG4gaXYgKCkgZWxzZSBpbmNyIG47XG4gICAgICAgICAgcmV0dXJuICgpKVxuICAgICAgICB+Y29udGludWU6VGltZV9zb3VyY2UuQ29udGludWUuaW1tZWRpYXRlbHk7XG4gICAgICBydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluICgpXG4gICAgOztcblxuICAgIGxldCViZW5jaCBcIn5jb250aW51ZV9vbl9lcnJvcjp0cnVlXCIgPVxuICAgICAgbGV0IGl2ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICAgIFRpbWVfc291cmNlLnJ1bl9yZXBlYXRlZGx5XG4gICAgICAgIHRpbWVfc291cmNlXG4gICAgICAgIH5zdG9wOihJdmFyLnJlYWQgaXYpXG4gICAgICAgIH5jb250aW51ZV9vbl9lcnJvcjp0cnVlXG4gICAgICAgIH5mOihmdW4gKCkgLT5cbiAgICAgICAgICBpZiAhbiA+PSAxXzAwMCB0aGVuIEl2YXIuZmlsbF9leG4gaXYgKCkgZWxzZSBpbmNyIG47XG4gICAgICAgICAgcmV0dXJuICgpKVxuICAgICAgICB+Y29udGludWU6VGltZV9zb3VyY2UuQ29udGludWUuaW1tZWRpYXRlbHk7XG4gICAgICBydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluICgpXG4gICAgOztcbiAgZW5kKVxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIFVuaXggPSBVbml4X3N5c2NhbGxzXG5tb2R1bGUgU29ja2V0ID0gVW5peC5Tb2NrZXRcblxubW9kdWxlIFdoZXJlX3RvX2Nvbm5lY3QgPSBzdHJ1Y3RcbiAgdHlwZSAnYWRkciB0ID1cbiAgICB7IHNvY2tldF90eXBlIDogJ2FkZHIgU29ja2V0LlR5cGUudFxuICAgIDsgcmVtb3RlX2FkZHJlc3MgOiB1bml0IC0+ICdhZGRyIERlZmVycmVkLnRcbiAgICA7IGxvY2FsX2FkZHJlc3MgOiAnYWRkciBvcHRpb25cbiAgICA7IGluZm8gOiBTZXhwLnRcbiAgICB9XG5cbiAgbGV0IHNleHBfb2ZfdCBfIHsgaW5mbzsgXyB9ID0gaW5mb1xuXG4gIHR5cGUgaW5ldCA9IFNvY2tldC5BZGRyZXNzLkluZXQudCB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgdW5peCA9IFNvY2tldC5BZGRyZXNzLlVuaXgudCB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IHJlbW90ZV9hZGRyZXNzIHQgPSB0LnJlbW90ZV9hZGRyZXNzICgpXG5cbiAgbGV0IGNyZWF0ZV9sb2NhbF9hZGRyZXNzIH5iaW5kX3RvX2FkZHJlc3MgfmJpbmRfdG9fcG9ydCA9XG4gICAgbWF0Y2ggYmluZF90b19hZGRyZXNzLCBiaW5kX3RvX3BvcnQgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiBOb25lXG4gICAgfCBOb25lLCBTb21lIHBvcnQgLT4gU29tZSAoU29ja2V0LkFkZHJlc3MuSW5ldC5jcmVhdGVfYmluZF9hbnkgfnBvcnQpXG4gICAgfCBTb21lIGluZXRfYWRkciwgYmluZF90b19wb3J0IC0+XG4gICAgICBsZXQgcG9ydCA9IE9wdGlvbi52YWx1ZSBiaW5kX3RvX3BvcnQgfmRlZmF1bHQ6MCBpblxuICAgICAgU29tZSAoU29ja2V0LkFkZHJlc3MuSW5ldC5jcmVhdGUgfnBvcnQgaW5ldF9hZGRyKVxuICA7O1xuXG4gIGxldCBvZl9ob3N0X2FuZF9wb3J0XG4gICAgP2JpbmRfdG9fYWRkcmVzc1xuICAgID9iaW5kX3RvX3BvcnRcbiAgICA/KHNob3dfcG9ydF9pbl90ZXN0ID0gZmFsc2UpXG4gICAgKHsgSG9zdF9hbmRfcG9ydC5ob3N0OyBwb3J0IH0gYXMgaHApXG4gICAgPVxuICAgIHsgc29ja2V0X3R5cGUgPSBTb2NrZXQuVHlwZS50Y3BcbiAgICA7IHJlbW90ZV9hZGRyZXNzID1cbiAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgIFVuaXguSW5ldF9hZGRyLm9mX3N0cmluZ19vcl9nZXRieW5hbWUgaG9zdFxuICAgICAgICAgID4+fCBmdW4gaW5ldF9hZGRyIC0+IFNvY2tldC5BZGRyZXNzLkluZXQuY3JlYXRlIGluZXRfYWRkciB+cG9ydClcbiAgICA7IGxvY2FsX2FkZHJlc3MgPSBjcmVhdGVfbG9jYWxfYWRkcmVzcyB+YmluZF90b19hZGRyZXNzIH5iaW5kX3RvX3BvcnRcbiAgICA7IGluZm8gPVxuICAgICAgICAobWF0Y2ggc2hvd19wb3J0X2luX3Rlc3Qgd2l0aFxuICAgICAgICAgfCB0cnVlIC0+IFslc2V4cCAoaHAgOiBIb3N0X2FuZF9wb3J0LnQpXVxuICAgICAgICAgfCBmYWxzZSAtPiBbJXNleHAgKGhwIDogSG9zdF9hbmRfcG9ydC5IaWRlX3BvcnRfaW5fdGVzdC50KV0pXG4gICAgfVxuICA7O1xuXG4gIGxldCBvZl9maWxlIGZpbGUgPVxuICAgIHsgc29ja2V0X3R5cGUgPSBTb2NrZXQuVHlwZS51bml4XG4gICAgOyByZW1vdGVfYWRkcmVzcyA9IChmdW4gKCkgLT4gcmV0dXJuIChTb2NrZXQuQWRkcmVzcy5Vbml4LmNyZWF0ZSBmaWxlKSlcbiAgICA7IGxvY2FsX2FkZHJlc3MgPSBOb25lXG4gICAgOyBpbmZvID0gWyVzZXhwX29mOiBzdHJpbmddIGZpbGVcbiAgICB9XG4gIDs7XG5cbiAgbGV0IG9mX2luZXRfYWRkcmVzcyA/YmluZF90b19hZGRyZXNzID9iaW5kX3RvX3BvcnQgPyhzaG93X3BvcnRfaW5fdGVzdCA9IGZhbHNlKSBhZGRyZXNzID1cbiAgICB7IHNvY2tldF90eXBlID0gU29ja2V0LlR5cGUudGNwXG4gICAgOyByZW1vdGVfYWRkcmVzcyA9IChmdW4gKCkgLT4gcmV0dXJuIGFkZHJlc3MpXG4gICAgOyBsb2NhbF9hZGRyZXNzID0gY3JlYXRlX2xvY2FsX2FkZHJlc3MgfmJpbmRfdG9fYWRkcmVzcyB+YmluZF90b19wb3J0XG4gICAgOyBpbmZvID1cbiAgICAgICAgKG1hdGNoIHNob3dfcG9ydF9pbl90ZXN0IHdpdGhcbiAgICAgICAgIHwgdHJ1ZSAtPiBbJXNleHAgKGFkZHJlc3MgOiBTb2NrZXQuQWRkcmVzcy5JbmV0LlNob3dfcG9ydF9pbl90ZXN0LnQpXVxuICAgICAgICAgfCBmYWxzZSAtPiBbJXNleHAgKGFkZHJlc3MgOiBTb2NrZXQuQWRkcmVzcy5JbmV0LnQpXSlcbiAgICB9XG4gIDs7XG5cbiAgbGV0IG9mX3VuaXhfYWRkcmVzcyBhZGRyZXNzID1cbiAgICB7IHNvY2tldF90eXBlID0gU29ja2V0LlR5cGUudW5peFxuICAgIDsgcmVtb3RlX2FkZHJlc3MgPSAoZnVuICgpIC0+IHJldHVybiBhZGRyZXNzKVxuICAgIDsgbG9jYWxfYWRkcmVzcyA9IE5vbmVcbiAgICA7IGluZm8gPSBbJXNleHBfb2Y6IFNvY2tldC5BZGRyZXNzLlVuaXgudF0gYWRkcmVzc1xuICAgIH1cbiAgOztcbmVuZFxuXG5sZXQgY2xvc2Vfc29ja19vbl9lcnJvciBzIGYgPVxuICBNb25pdG9yLnRyeV93aXRoIH5ydW46YFNjaGVkdWxlIH5yZXN0OmBMb2cgfm5hbWU6XCJUY3AuY2xvc2Vfc29ja19vbl9lcnJvclwiIGZcbiAgPj58IGZ1bmN0aW9uXG4gIHwgT2sgdiAtPiB2XG4gIHwgRXJyb3IgZSAtPlxuICAgICgqIFtjbG9zZV0gbWF5IGZhaWwsIGJ1dCB3ZSBkb24ndCByZWFsbHkgY2FyZSwgc2luY2UgaXQgd2lsbCBmYWlsXG4gICAgICAgYXN5bmNocm9ub3VzbHkuICBUaGUgZXJyb3Igd2UgcmVhbGx5IGNhcmUgYWJvdXQgaXMgW2VdLCBhbmQgdGhlXG4gICAgICAgW3JhaXNlX2Vycm9yXSB3aWxsIGNhdXNlIHRoZSBjdXJyZW50IG1vbml0b3IgdG8gc2VlIHRoYXQuICopXG4gICAgZG9uJ3Rfd2FpdF9mb3IgKFVuaXguY2xvc2UgKFNvY2tldC5mZCBzKSk7XG4gICAgcmFpc2UgZVxuOztcblxubGV0IHJlYWRlcl93cml0ZXJfb2Zfc29jayA/YnVmZmVyX2FnZV9saW1pdCA/cmVhZGVyX2J1ZmZlcl9zaXplID93cml0ZXJfYnVmZmVyX3NpemUgcyA9XG4gIGxldCBmZCA9IFNvY2tldC5mZCBzIGluXG4gICggUmVhZGVyLmNyZWF0ZSA/YnVmX2xlbjpyZWFkZXJfYnVmZmVyX3NpemUgZmRcbiAgLCBXcml0ZXIuY3JlYXRlID9idWZmZXJfYWdlX2xpbWl0ID9idWZfbGVuOndyaXRlcl9idWZmZXJfc2l6ZSBmZCApXG47O1xuXG5sZXQgY29ubmVjdF9zb2NrXG4gID9zb2NrZXRcbiAgP2ludGVycnVwdFxuICA/KHRpbWVvdXQgPSBzZWMgMTAuKVxuICA/dGltZV9zb3VyY2VcbiAgKHdoZXJlX3RvX2Nvbm5lY3QgOiBfIFdoZXJlX3RvX2Nvbm5lY3QudClcbiAgPVxuICBsZXQgdGltZV9zb3VyY2UgPVxuICAgIG1hdGNoIHRpbWVfc291cmNlIHdpdGhcbiAgICB8IFNvbWUgeCAtPiBUaW1lX3NvdXJjZS5yZWFkX29ubHkgeFxuICAgIHwgTm9uZSAtPiBUaW1lX3NvdXJjZS53YWxsX2Nsb2NrICgpXG4gIGluXG4gIHdoZXJlX3RvX2Nvbm5lY3QucmVtb3RlX2FkZHJlc3MgKClcbiAgPj49IGZ1biBhZGRyZXNzIC0+XG4gIGxldCB0aW1lb3V0ID1cbiAgICBUaW1lX3NvdXJjZS5FdmVudC5hZnRlciB0aW1lX3NvdXJjZSAoVGltZV9ucy5TcGFuLm9mX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCB0aW1lb3V0KVxuICBpblxuICBsZXQgaW50ZXJydXB0ID1cbiAgICBsZXQgdGltZW91dCA9XG4gICAgICBUaW1lX3NvdXJjZS5FdmVudC5maXJlZCB0aW1lb3V0XG4gICAgICA+Pj0gZnVuY3Rpb25cbiAgICAgIHwgQWJvcnRlZCAoKSAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgICAgfCBIYXBwZW5lZCAoKSAtPiBEZWZlcnJlZC51bml0XG4gICAgaW5cbiAgICBtYXRjaCBpbnRlcnJ1cHQgd2l0aFxuICAgIHwgTm9uZSAtPiB0aW1lb3V0XG4gICAgfCBTb21lIGludGVycnVwdCAtPiBEZWZlcnJlZC5hbnkgWyBpbnRlcnJ1cHQ7IHRpbWVvdXQgXVxuICBpblxuICBsZXQgY29ubmVjdF9pbnRlcnJ1cHRpYmxlIHMgPSBTb2NrZXQuY29ubmVjdF9pbnRlcnJ1cHRpYmxlIHMgYWRkcmVzcyB+aW50ZXJydXB0IGluXG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCBzID1cbiAgICAgIG1hdGNoIHNvY2tldCB3aXRoXG4gICAgICB8IFNvbWUgcyAtPiBzXG4gICAgICB8IE5vbmUgLT4gU29ja2V0LmNyZWF0ZSB3aGVyZV90b19jb25uZWN0LnNvY2tldF90eXBlXG4gICAgaW5cbiAgICBjbG9zZV9zb2NrX29uX2Vycm9yIHMgKGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggd2hlcmVfdG9fY29ubmVjdC5sb2NhbF9hZGRyZXNzIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBjb25uZWN0X2ludGVycnVwdGlibGUgc1xuICAgICAgfCBTb21lIGxvY2FsX2ludGVyZmFjZSAtPlxuICAgICAgICBTb2NrZXQuYmluZCBzIGxvY2FsX2ludGVyZmFjZSA+Pj0gZnVuIHMgLT4gY29ubmVjdF9pbnRlcnJ1cHRpYmxlIHMpXG4gICAgPj4+IGZ1bmN0aW9uXG4gICAgfCBgT2sgcyAtPlxuICAgICAgVGltZV9zb3VyY2UuRXZlbnQuYWJvcnRfaWZfcG9zc2libGUgdGltZW91dCAoKTtcbiAgICAgIEl2YXIuZmlsbF9leG4gcmVzdWx0IHNcbiAgICB8IGBJbnRlcnJ1cHRlZCAtPlxuICAgICAgZG9uJ3Rfd2FpdF9mb3IgKFVuaXguY2xvc2UgKFNvY2tldC5mZCBzKSk7XG4gICAgICBsZXQgYWRkcmVzcyA9IFNvY2tldC5BZGRyZXNzLnRvX3N0cmluZyBhZGRyZXNzIGluXG4gICAgICAobWF0Y2ggVGltZV9zb3VyY2UuRXZlbnQuYWJvcnQgdGltZW91dCAoKSB3aXRoXG4gICAgICAgfCBQcmV2aW91c2x5X2hhcHBlbmVkICgpIC0+XG4gICAgICAgICByYWlzZV9zIFslc2V4cCBcImNvbm5lY3Rpb24gYXR0ZW1wdCB0aW1lb3V0XCIsIChhZGRyZXNzIDogc3RyaW5nKV1cbiAgICAgICB8IE9rIHwgUHJldmlvdXNseV9hYm9ydGVkICgpIC0+XG4gICAgICAgICByYWlzZV9zIFslc2V4cCBcImNvbm5lY3Rpb24gYXR0ZW1wdCBhYm9ydGVkXCIsIChhZGRyZXNzIDogc3RyaW5nKV0pKVxuOztcblxubGV0IGNvbm5lY3RcbiAgP3NvY2tldFxuICA/YnVmZmVyX2FnZV9saW1pdFxuICA/aW50ZXJydXB0XG4gID9yZWFkZXJfYnVmZmVyX3NpemVcbiAgP3dyaXRlcl9idWZmZXJfc2l6ZVxuICA/dGltZW91dFxuICA/dGltZV9zb3VyY2VcbiAgd2hlcmVfdG9fY29ubmVjdFxuICA9XG4gIGNvbm5lY3Rfc29jayA/c29ja2V0ID9pbnRlcnJ1cHQgP3RpbWVvdXQgP3RpbWVfc291cmNlIHdoZXJlX3RvX2Nvbm5lY3RcbiAgPj58IGZ1biBzIC0+XG4gIGxldCByLCB3ID1cbiAgICByZWFkZXJfd3JpdGVyX29mX3NvY2sgP2J1ZmZlcl9hZ2VfbGltaXQgP3JlYWRlcl9idWZmZXJfc2l6ZSA/d3JpdGVyX2J1ZmZlcl9zaXplIHNcbiAgaW5cbiAgcywgciwgd1xuOztcblxubGV0IGNvbGxlY3RfZXJyb3JzIHdyaXRlciBmID1cbiAgbGV0IG1vbml0b3IgPSBXcml0ZXIubW9uaXRvciB3cml0ZXIgaW5cbiAgaWdub3JlIChNb25pdG9yLmRldGFjaF9hbmRfZ2V0X2Vycm9yX3N0cmVhbSBtb25pdG9yIDogXyBTdHJlYW0udCk7XG4gICgqIGRvbid0IHByb3BhZ2F0ZSBlcnJvcnMgdXAsIHdlIGhhbmRsZSB0aGVtIGhlcmUgKilcbiAgY2hvb3NlXG4gICAgWyBjaG9pY2UgKE1vbml0b3IuZ2V0X25leHRfZXJyb3IgbW9uaXRvcikgKGZ1biBlIC0+IEVycm9yIGUpXG4gICAgOyBjaG9pY2VcbiAgICAgICAgKE1vbml0b3IudHJ5X3dpdGggfnJ1bjpgU2NoZWR1bGUgfnJlc3Q6YExvZyB+bmFtZTpcIlRjcC5jb2xsZWN0X2Vycm9yc1wiIGYpXG4gICAgICAgIEZuLmlkXG4gICAgXVxuOztcblxubGV0IGNsb3NlX2Nvbm5lY3Rpb25fdmlhX3JlYWRlcl9hbmRfd3JpdGVyIHIgdyA9XG4gIGxldCBmb3JjZV9jbG9zZV9ldmVudCA9IENsb2NrLkV2ZW50LmFmdGVyIChzZWMgMzAuKSBpblxuICBsZXQgZm9yY2VfY2xvc2UgPVxuICAgIENsb2NrLkV2ZW50LmZpcmVkIGZvcmNlX2Nsb3NlX2V2ZW50XG4gICAgPj49IGZ1bmN0aW9uXG4gICAgfCBBYm9ydGVkICgpIC0+IERlZmVycmVkLm5ldmVyICgpXG4gICAgfCBIYXBwZW5lZCAoKSAtPiBEZWZlcnJlZC51bml0XG4gIGluXG4gIFdyaXRlci5jbG9zZSB3IH5mb3JjZV9jbG9zZVxuICA+Pj0gZnVuICgpIC0+XG4gIENsb2NrLkV2ZW50LmFib3J0X2lmX3Bvc3NpYmxlIGZvcmNlX2Nsb3NlX2V2ZW50ICgpO1xuICBSZWFkZXIuY2xvc2UgclxuOztcblxubGV0IHdpdGhfY29ubmVjdGlvblxuICA/YnVmZmVyX2FnZV9saW1pdFxuICA/aW50ZXJydXB0XG4gID9yZWFkZXJfYnVmZmVyX3NpemVcbiAgP3dyaXRlcl9idWZmZXJfc2l6ZVxuICA/dGltZW91dFxuICA/dGltZV9zb3VyY2VcbiAgd2hlcmVfdG9fY29ubmVjdFxuICBmXG4gID1cbiAgY29ubmVjdF9zb2NrID9pbnRlcnJ1cHQgP3RpbWVvdXQgP3RpbWVfc291cmNlIHdoZXJlX3RvX2Nvbm5lY3RcbiAgPj49IGZ1biBzb2NrZXQgLT5cbiAgbGV0IHIsIHcgPVxuICAgIHJlYWRlcl93cml0ZXJfb2Zfc29jayA/YnVmZmVyX2FnZV9saW1pdCA/cmVhZGVyX2J1ZmZlcl9zaXplID93cml0ZXJfYnVmZmVyX3NpemUgc29ja2V0XG4gIGluXG4gIGxldCByZXMgPSBjb2xsZWN0X2Vycm9ycyB3IChmdW4gKCkgLT4gZiBzb2NrZXQgciB3KSBpblxuICBEZWZlcnJlZC5hbnlcbiAgICBbIChyZXMgPj58IGZ1biAoXyA6ICgnYSwgZXhuKSBSZXN1bHQudCkgLT4gKCkpXG4gICAgOyBSZWFkZXIuY2xvc2VfZmluaXNoZWQgclxuICAgIDsgV3JpdGVyLmNsb3NlX2ZpbmlzaGVkIHdcbiAgICBdXG4gID4+PSBmdW4gKCkgLT5cbiAgY2xvc2VfY29ubmVjdGlvbl92aWFfcmVhZGVyX2FuZF93cml0ZXIgciB3XG4gID4+PSBmdW4gKCkgLT5cbiAgcmVzXG4gID4+fCBmdW5jdGlvblxuICB8IE9rIHYgLT4gdlxuICB8IEVycm9yIGUgLT4gcmFpc2UgZVxuOztcblxubW9kdWxlIEJpbmRfdG9fYWRkcmVzcyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQWRkcmVzcyBvZiBVbml4LkluZXRfYWRkci50XG4gICAgfCBBbGxfYWRkcmVzc2VzXG4gICAgfCBMb2NhbGhvc3RcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5tb2R1bGUgQmluZF90b19wb3J0ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBPbl9wb3J0IG9mIGludFxuICAgIHwgT25fcG9ydF9jaG9zZW5fYnlfb3NcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5tb2R1bGUgV2hlcmVfdG9fbGlzdGVuID0gc3RydWN0XG4gIHR5cGUgKCdhZGRyZXNzLCAnbGlzdGVuaW5nX29uKSB0ID1cbiAgICB7IHNvY2tldF90eXBlIDogJ2FkZHJlc3MgU29ja2V0LlR5cGUudFxuICAgIDsgYWRkcmVzcyA6ICdhZGRyZXNzXG4gICAgOyBsaXN0ZW5pbmdfb24gOiAoJ2FkZHJlc3MgLT4gJ2xpc3RlbmluZ19vbltAc2V4cC5vcGFxdWVdKVxuICAgIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZiwgZmllbGRzIH5nZXR0ZXJzXVxuXG4gIHR5cGUgaW5ldCA9IChTb2NrZXQuQWRkcmVzcy5JbmV0LnQsIGludCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlIHVuaXggPSAoU29ja2V0LkFkZHJlc3MuVW5peC50LCBzdHJpbmcpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaXNfaW5ldF93aXRuZXNzIHQgPSBTb2NrZXQuRmFtaWx5LmlzX2luZXRfd2l0bmVzcyAoU29ja2V0LlR5cGUuZmFtaWx5IHQuc29ja2V0X3R5cGUpXG4gIGxldCBjcmVhdGUgfnNvY2tldF90eXBlIH5hZGRyZXNzIH5saXN0ZW5pbmdfb24gPSB7IHNvY2tldF90eXBlOyBhZGRyZXNzOyBsaXN0ZW5pbmdfb24gfVxuXG4gIGxldCBiaW5kX3RvIChiaW5kX3RvX2FkZHJlc3MgOiBCaW5kX3RvX2FkZHJlc3MudCkgKGJpbmRfdG9fcG9ydCA6IEJpbmRfdG9fcG9ydC50KSA9XG4gICAgbGV0IHBvcnQgPVxuICAgICAgbWF0Y2ggYmluZF90b19wb3J0IHdpdGhcbiAgICAgIHwgT25fcG9ydCBwb3J0IC0+IHBvcnRcbiAgICAgIHwgT25fcG9ydF9jaG9zZW5fYnlfb3MgLT4gMFxuICAgIGluXG4gICAgbGV0IGFkZHJlc3MgPVxuICAgICAgbWF0Y2ggYmluZF90b19hZGRyZXNzIHdpdGhcbiAgICAgIHwgQWxsX2FkZHJlc3NlcyAtPiBTb2NrZXQuQWRkcmVzcy5JbmV0LmNyZWF0ZV9iaW5kX2FueSB+cG9ydFxuICAgICAgfCBBZGRyZXNzIGFkZHIgLT4gU29ja2V0LkFkZHJlc3MuSW5ldC5jcmVhdGUgYWRkciB+cG9ydFxuICAgICAgfCBMb2NhbGhvc3QgLT4gU29ja2V0LkFkZHJlc3MuSW5ldC5jcmVhdGUgVW5peC5JbmV0X2FkZHIubG9jYWxob3N0IH5wb3J0XG4gICAgaW5cbiAgICB7IHNvY2tldF90eXBlID0gU29ja2V0LlR5cGUudGNwXG4gICAgOyBhZGRyZXNzXG4gICAgOyBsaXN0ZW5pbmdfb24gPVxuICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgIHwgYEluZXQgKF8sIHBvcnQpIC0+IHBvcnQpXG4gICAgfVxuICA7O1xuXG4gIGxldCBvZl9wb3J0IHBvcnQgPSBiaW5kX3RvIEFsbF9hZGRyZXNzZXMgKE9uX3BvcnQgcG9ydClcbiAgbGV0IG9mX3BvcnRfY2hvc2VuX2J5X29zID0gYmluZF90byBBbGxfYWRkcmVzc2VzIE9uX3BvcnRfY2hvc2VuX2J5X29zXG5cbiAgbGV0IG9mX2ZpbGUgcGF0aCA9XG4gICAgeyBzb2NrZXRfdHlwZSA9IFNvY2tldC5UeXBlLnVuaXhcbiAgICA7IGFkZHJlc3MgPSBTb2NrZXQuQWRkcmVzcy5Vbml4LmNyZWF0ZSBwYXRoXG4gICAgOyBsaXN0ZW5pbmdfb24gPSAoZnVuIF8gLT4gcGF0aClcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGJpbmRpbmdfb25fcG9ydF9jaG9zZW5fYnlfb3MgdCA9XG4gICAgbWF0Y2ggdC5hZGRyZXNzIHdpdGhcbiAgICB8IGBJbmV0IF8gYXMgaW5ldCAtPiBTb2NrZXQuQWRkcmVzcy5JbmV0LnBvcnQgaW5ldCA9IDBcbiAgICB8IGBVbml4IF8gLT4gZmFsc2VcbiAgOztcblxuICBsZXQgbWF4X3JldHJpZXNfdXBvbl9hZGRyX2luX3VzZSB0ID1cbiAgICBtYXRjaCBiaW5kaW5nX29uX3BvcnRfY2hvc2VuX2J5X29zIHQgd2l0aFxuICAgIHwgdHJ1ZSAtPiAxMFxuICAgIHwgZmFsc2UgLT4gMFxuICA7O1xuZW5kXG5cbm1vZHVsZSBTZXJ2ZXIgPSBzdHJ1Y3RcbiAgbW9kdWxlIENvbm5lY3Rpb24gPSBzdHJ1Y3RcbiAgICB0eXBlICdhZGRyZXNzIHQgPVxuICAgICAgeyBjbGllbnRfc29ja2V0IDogKFsgYEFjdGl2ZSBdLCAnYWRkcmVzcykgU29ja2V0LnRcbiAgICAgIDsgY2xpZW50X2FkZHJlc3MgOiAnYWRkcmVzc1xuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbiAgICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hZGRyZXNzIHQgPVxuICAgICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICAgIEZpZWxkcy5pdGVyIH5jbGllbnRfc29ja2V0Omlnbm9yZSB+Y2xpZW50X2FkZHJlc3M6KGNoZWNrIGludmFyaWFudF9hZGRyZXNzKSlcbiAgICA7O1xuXG4gICAgbGV0IGNyZWF0ZSB+Y2xpZW50X3NvY2tldCB+Y2xpZW50X2FkZHJlc3MgPSB7IGNsaWVudF9zb2NrZXQ7IGNsaWVudF9hZGRyZXNzIH1cbiAgICBsZXQgY2xvc2UgdCA9IEZkLmNsb3NlIChTb2NrZXQuZmQgdC5jbGllbnRfc29ja2V0KVxuICBlbmRcblxuICBtb2R1bGUgTWF4X2Nvbm5lY3Rpb25zID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHsgbGltaXQgOiBpbnRcbiAgICAgIDsgdGltZV9zb3VyY2UgOiBUaW1lX3NvdXJjZS50XG4gICAgICA7IGxpc3RlbmluZ19vbiA6IEluZm8udFxuICAgICAgOyBtdXRhYmxlIGxhc3RfbG9nZ2VkIDogVGltZV9ucy50IG9wdGlvblxuICAgICAgfVxuXG4gICAgbGV0IHNleHBfb2ZfdCB0ID0gWyVzZXhwX29mOiBpbnRdIHQubGltaXRcblxuICAgIGxldCBjcmVhdGUgfmxpbWl0IH50aW1lX3NvdXJjZSB+bGlzdGVuaW5nX29uID1cbiAgICAgIHsgbGltaXQ7IHRpbWVfc291cmNlOyBsaXN0ZW5pbmdfb247IGxhc3RfbG9nZ2VkID0gTm9uZSB9XG4gICAgOztcblxuICAgICgqIFdlIG1ha2Ugc3VyZSBub3QgdG8gYmUgdG9vIHNwYW1teSB3aXRoIGxvZ3MuIFRoaXMgbnVtYmVyIHdhcyBjaG9zZW4gcHJldHR5XG4gICAgICAgYXJiaXRyYXJpbHkuICopXG4gICAgbGV0IGxvZ190aHJlc2hvbGQgPSBUaW1lX25zLlNwYW4ub2ZfbWluIDEuXG4gICAgbGV0IG1heF9jb25uZWN0aW9uX2xpbWl0X2xvZ2dlciA9IHJlZiAoZXByaW50X3MgP21hY2g6Tm9uZSlcbiAgICBsZXQgc2V0X2xvZ2dlciA9ICggOj0gKSBtYXhfY29ubmVjdGlvbl9saW1pdF9sb2dnZXJcblxuICAgIGxldCBsb2dfYXRfbGltaXQgdCB+bm93ID1cbiAgICAgICFtYXhfY29ubmVjdGlvbl9saW1pdF9sb2dnZXJcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJBdCBsaW1pdCBvZiBUY3Agc2VydmVyIFttYXhfY29ubmVjdGlvbnNdLiBOZXcgY29ubmVjdGlvbnMgd2lsbCBub3QgYmUgXFxcbiAgICAgICAgICAgYWNjZXB0ZWQgdW50aWwgYW4gZXhpc3RpbmcgY29ubmVjdGlvbiBpcyBjbG9zZWQuXCJcbiAgICAgICAgICAgIH5saW1pdDoodC5saW1pdCA6IGludClcbiAgICAgICAgICAgIH5saXN0ZW5pbmdfb246KHQubGlzdGVuaW5nX29uIDogSW5mby50KV07XG4gICAgICB0Lmxhc3RfbG9nZ2VkIDwtIFNvbWUgbm93XG4gICAgOztcblxuICAgIGxldCBtYXliZV9sb2dfYXRfbGltaXQgdCA9XG4gICAgICBsZXQgbm93ID0gVGltZV9zb3VyY2Uubm93IHQudGltZV9zb3VyY2UgaW5cbiAgICAgIG1hdGNoIHQubGFzdF9sb2dnZWQgd2l0aFxuICAgICAgfCBOb25lIC0+IGxvZ19hdF9saW1pdCB0IH5ub3dcbiAgICAgIHwgU29tZSBsYXN0X2xvZ2dlZCAtPlxuICAgICAgICBpZiBUaW1lX25zLlNwYW4uKCA+ICkgKFRpbWVfbnMuZGlmZiBub3cgbGFzdF9sb2dnZWQpIGxvZ190aHJlc2hvbGRcbiAgICAgICAgdGhlbiBsb2dfYXRfbGltaXQgdCB+bm93XG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSAoJ2FkZHJlc3MsICdsaXN0ZW5pbmdfb24pIHQgPVxuICAgIHsgc29ja2V0IDogKFsgYFBhc3NpdmUgXSwgJ2FkZHJlc3MpIFNvY2tldC50XG4gICAgOyBsaXN0ZW5pbmdfb24gOiAnbGlzdGVuaW5nX29uXG4gICAgOyBvbl9oYW5kbGVyX2Vycm9yIDogWyBgUmFpc2UgfCBgSWdub3JlIHwgYENhbGwgb2YgJ2FkZHJlc3MgLT4gZXhuIC0+IHVuaXQgXVxuICAgIDsgaGFuZGxlX2NsaWVudCA6XG4gICAgICAgICdhZGRyZXNzIC0+IChbIGBBY3RpdmUgXSwgJ2FkZHJlc3MpIFNvY2tldC50IC0+ICh1bml0LCBleG4pIFJlc3VsdC50IERlZmVycmVkLnRcbiAgICA7IG1heF9jb25uZWN0aW9ucyA6IE1heF9jb25uZWN0aW9ucy50XG4gICAgOyBtYXhfYWNjZXB0c19wZXJfYmF0Y2ggOiBpbnRcbiAgICA7IGNvbm5lY3Rpb25zIDogJ2FkZHJlc3MgQ29ubmVjdGlvbi50IEJhZy50XG4gICAgOyBtdXRhYmxlIGFjY2VwdF9pc19wZW5kaW5nIDogYm9vbFxuICAgIDsgbXV0YWJsZSBkcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zIDogYm9vbFxuICAgIDsgY2xvc2VfZmluaXNoZWRfYW5kX2hhbmRsZXJzX2RldGVybWluZWQgOiB1bml0IEl2YXIudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5zZXR0ZXJzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxuICBsZXQgaXNfZHJvcHBpbmdfaW5jb21pbmdfY29ubmVjdGlvbnMgdCA9IHQuZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICBsZXQgbnVtX2Nvbm5lY3Rpb25zIHQgPSBCYWcubGVuZ3RoIHQuY29ubmVjdGlvbnNcbiAgbGV0IGxpc3RlbmluZ19zb2NrZXQgPSBzb2NrZXRcblxuICB0eXBlIGluZXQgPSAoU29ja2V0LkFkZHJlc3MuSW5ldC50LCBpbnQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSB1bml4ID0gKFNvY2tldC5BZGRyZXNzLlVuaXgudCwgc3RyaW5nKSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGxpc3RlbmluZ19vbl9hZGRyZXNzICh0IDogKF8sIF8pIHQpID0gU29ja2V0LmdldHNvY2tuYW1lIHQuc29ja2V0XG5cbiAgbGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gICAgdHJ5XG4gICAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfnNvY2tldDppZ25vcmVcbiAgICAgICAgfmxpc3RlbmluZ19vbjppZ25vcmVcbiAgICAgICAgfm9uX2hhbmRsZXJfZXJyb3I6aWdub3JlXG4gICAgICAgIH5oYW5kbGVfY2xpZW50Omlnbm9yZVxuICAgICAgICB+bWF4X2Nvbm5lY3Rpb25zOlxuICAgICAgICAgIChjaGVjayAoZnVuIChtYXhfY29ubmVjdGlvbnMgOiBNYXhfY29ubmVjdGlvbnMudCkgLT5cbiAgICAgICAgICAgICBhc3NlcnQgKG1heF9jb25uZWN0aW9ucy5saW1pdCA+PSAxKSkpXG4gICAgICAgIH5tYXhfYWNjZXB0c19wZXJfYmF0Y2g6XG4gICAgICAgICAgKGNoZWNrIChmdW4gbWF4X2FjY2VwdHNfcGVyX2JhdGNoIC0+IGFzc2VydCAobWF4X2FjY2VwdHNfcGVyX2JhdGNoID49IDEpKSlcbiAgICAgICAgfmNvbm5lY3Rpb25zOlxuICAgICAgICAgIChjaGVjayAoZnVuIGNvbm5lY3Rpb25zIC0+XG4gICAgICAgICAgICAgQmFnLmludmFyaWFudCAoQ29ubmVjdGlvbi5pbnZhcmlhbnQgaWdub3JlKSBjb25uZWN0aW9ucztcbiAgICAgICAgICAgICBsZXQgbnVtX2Nvbm5lY3Rpb25zID0gbnVtX2Nvbm5lY3Rpb25zIHQgaW5cbiAgICAgICAgICAgICBhc3NlcnQgKG51bV9jb25uZWN0aW9ucyA+PSAwKTtcbiAgICAgICAgICAgICBhc3NlcnQgKG51bV9jb25uZWN0aW9ucyA8PSB0Lm1heF9jb25uZWN0aW9ucy5saW1pdCkpKVxuICAgICAgICB+YWNjZXB0X2lzX3BlbmRpbmc6aWdub3JlXG4gICAgICAgIH5kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zOmlnbm9yZVxuICAgICAgICB+Y2xvc2VfZmluaXNoZWRfYW5kX2hhbmRsZXJzX2RldGVybWluZWQ6aWdub3JlXG4gICAgd2l0aFxuICAgIHwgZXhuIC0+XG4gICAgICBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcImludmFyaWFudCBmYWlsZWRcIiAoZXhuLCB0KSBbJXNleHBfb2Y6IGV4biAqIChfLCBfKSB0XVxuICA7O1xuXG4gIGxldCBmZCB0ID0gU29ja2V0LmZkIHQuc29ja2V0XG4gIGxldCBpc19jbG9zZWQgdCA9IEZkLmlzX2Nsb3NlZCAoZmQgdClcbiAgbGV0IGNsb3NlX2ZpbmlzaGVkIHQgPSBGZC5jbG9zZV9maW5pc2hlZCAoZmQgdClcblxuICBsZXQgY2xvc2VfZmluaXNoZWRfYW5kX2hhbmRsZXJzX2RldGVybWluZWQgdCA9XG4gICAgSXZhci5yZWFkIHQuY2xvc2VfZmluaXNoZWRfYW5kX2hhbmRsZXJzX2RldGVybWluZWRcbiAgOztcblxuICBsZXQgY2xvc2UgPyhjbG9zZV9leGlzdGluZ19jb25uZWN0aW9ucyA9IGZhbHNlKSB0ID1cbiAgICBsZXQgZmRfY2xvc2VkID0gRmQuY2xvc2UgKGZkIHQpIGluXG4gICAgaWYgbm90IGNsb3NlX2V4aXN0aW5nX2Nvbm5lY3Rpb25zXG4gICAgdGhlbiBmZF9jbG9zZWRcbiAgICBlbHNlXG4gICAgICAoKiBDb25uZWN0aW9ucyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBiYWcgYnkgdGhlIFttYXliZV9hY2NlcHRdIGJlbG93LCBhcyB0aGUgZmRzIGFyZVxuICAgICAgICAgY2xvc2VkLiAqKVxuICAgICAgRGVmZXJyZWQuYWxsX3VuaXRcbiAgICAgICAgKGZkX2Nsb3NlZCA6OiBMaXN0Lm1hcCAoQmFnLnRvX2xpc3QgdC5jb25uZWN0aW9ucykgfmY6Q29ubmVjdGlvbi5jbG9zZSlcbiAgOztcblxuICAoKiBbbWF5YmVfYWNjZXB0XSBpcyBhIGJpdCB0cmlja3ksIGJ1dCB0aGUgaWRlYSBpcyB0byBhdm9pZCBjYWxsaW5nIFthY2NlcHRdIHVudGlsIHdlXG4gICAgIGhhdmUgYW4gYXZhaWxhYmxlIHNsb3QgKGRldGVybWluZWQgYnkgW251bV9jb25uZWN0aW9ucyA8IG1heF9jb25uZWN0aW9uc10pLiAqKVxuICBsZXQgcmVjIG1heWJlX2FjY2VwdCB0ID1cbiAgICBsZXQgYXZhaWxhYmxlX3Nsb3RzID0gdC5tYXhfY29ubmVjdGlvbnMubGltaXQgLSBudW1fY29ubmVjdGlvbnMgdCBpblxuICAgIGlmIChub3QgKGlzX2Nsb3NlZCB0KSkgJiYgYXZhaWxhYmxlX3Nsb3RzID4gMCAmJiBub3QgdC5hY2NlcHRfaXNfcGVuZGluZ1xuICAgIHRoZW4gKFxuICAgICAgdC5hY2NlcHRfaXNfcGVuZGluZyA8LSB0cnVlO1xuICAgICAgU29ja2V0LmFjY2VwdF9hdF9tb3N0IH5saW1pdDoobWluIHQubWF4X2FjY2VwdHNfcGVyX2JhdGNoIGF2YWlsYWJsZV9zbG90cykgdC5zb2NrZXRcbiAgICAgID4+PiBmdW4gYWNjZXB0X3Jlc3VsdCAtPlxuICAgICAgdC5hY2NlcHRfaXNfcGVuZGluZyA8LSBmYWxzZTtcbiAgICAgIG1hdGNoIGFjY2VwdF9yZXN1bHQgd2l0aFxuICAgICAgfCBgU29ja2V0X2Nsb3NlZCAtPiAoKVxuICAgICAgfCBgT2sgY29ubnMgLT5cbiAgICAgICAgKCogSXQgaXMgcG9zc2libGUgdGhhdCBzb21lb25lIGNhbGxlZCBbY2xvc2UgdF0gYWZ0ZXIgdGhlIFthY2NlcHRdIHJldHVybmVkIGJ1dFxuICAgICAgICAgICBiZWZvcmUgd2UgZ290IGhlcmUuICBJbiB0aGF0IGNhc2UsIHdlIGp1c3QgY2xvc2UgdGhlIGNsaWVudHMuICBPbmUgbWlnaHQgYXJndWVcbiAgICAgICAgICAgdGhhdCBpZiBbY2xvc2VdIHdhcyBjYWxsZWQgd2l0aCBbY2xvc2VfZXhpc3RpbmdfY29ubmVjdGlvbnMgPSBmYWxzZV0sIHRoZW4gd2VcbiAgICAgICAgICAgc2hvdWxkIG5vdCBjbG9zZSB0aGVzZSwgYnV0IGluc3RlYWQgbGV0IHRoZSBjbGllbnRzIGZpbmlzaCB0aGVpciBidXNpbmVzcy4gT25lXG4gICAgICAgICAgIG1heSB3YW50IHRoaXMgZm9yIGV4YW1wbGUgdG8gYXJyYW5nZSBhIHNtb290aCBoYW5kb3ZlciB3aGVuIHVzaW5nXG4gICAgICAgICAgIFtTT19SRVVTRVBPUlRdLlxuICAgICAgICAgICBVbmZvcnR1bmF0ZWx5LCBldmVuIGlmIHdlIG1ha2UgdGhpcyBmaXgsIGEgc21vb3RoIGhhbmRvdmVyXG4gICAgICAgICAgIGRvZXMgbm90IHNlZW0gdG8gYmUgcG9zc2libGUgb24gTGludXgsIHNpbmNlIExpbnV4IGFzc2lnbnMgYSBjb25uZWN0aW9uIHRvIGFcbiAgICAgICAgICAgcHJvY2VzcyBiZWZvcmUgW2FjY2VwdF0gaXMgY2FsbGVkLCB3aGljaCBjcmVhdGVzIGFuIGluaGVyZW50IHJhY2UgYmV0d2VlbiB0aGF0XG4gICAgICAgICAgIGFuZCBbY2xvc2VdOiBhbnkgY29ubmVjdGlvbnMgYXNzaWduZWQgdG8gYSBsaXN0ZW5pbmcgc29ja2V0IGF0IHRoZSB0aW1lIG9mXG4gICAgICAgICAgIFtjbG9zZV0gd2lsbCBiZSBkcm9wcGVkLlxuICAgICAgICAgICAqKVxuICAgICAgICBpZiBpc19jbG9zZWQgdCB8fCB0LmRyb3BfaW5jb21pbmdfY29ubmVjdGlvbnNcbiAgICAgICAgdGhlblxuICAgICAgICAgIExpc3QuaXRlciBjb25ucyB+ZjooZnVuIChzb2NrLCBfKSAtPiBkb24ndF93YWl0X2ZvciAoRmQuY2xvc2UgKFNvY2tldC5mZCBzb2NrKSkpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAoKiBXZSBmaXJzdCBbaGFuZGxlX2NsaWVudF0gb24gYWxsIHRoZSBjb25uZWN0aW9ucywgd2hpY2ggaW5jcmVhc2VzXG4gICAgICAgICAgICAgW251bV9jb25uZWN0aW9uc10sIGFuZCB0aGVuIGNhbGwgW21heWJlX2FjY2VwdF0gdG8gdHJ5IHRvIGFjY2VwdCBtb3JlXG4gICAgICAgICAgICAgY2xpZW50cywgd2hpY2ggcmVzcGVjdHMgdGhlIGp1c3QtaW5jcmVhc2VkIFtudW1fY29ubmVjdGlvbnNdLiAqKVxuICAgICAgICAgIExpc3QuaXRlciBjb25ucyB+ZjooZnVuIChzb2NrLCBhZGRyKSAtPiBoYW5kbGVfY2xpZW50IHQgc29jayBhZGRyKTtcbiAgICAgICAgbWF5YmVfYWNjZXB0IHQpXG4gICAgZWxzZSBpZiAobm90IChpc19jbG9zZWQgdCkpICYmIGF2YWlsYWJsZV9zbG90cyA9IDBcbiAgICB0aGVuIE1heF9jb25uZWN0aW9ucy5tYXliZV9sb2dfYXRfbGltaXQgdC5tYXhfY29ubmVjdGlvbnNcblxuICBhbmQgaGFuZGxlX2NsaWVudCB0IGNsaWVudF9zb2NrZXQgY2xpZW50X2FkZHJlc3MgPVxuICAgIGxldCBjb25uZWN0aW9uID0gQ29ubmVjdGlvbi5jcmVhdGUgfmNsaWVudF9zb2NrZXQgfmNsaWVudF9hZGRyZXNzIGluXG4gICAgbGV0IGNvbm5lY3Rpb25zX2VsdCA9IEJhZy5hZGQgdC5jb25uZWN0aW9ucyBjb25uZWN0aW9uIGluXG4gICAgdC5oYW5kbGVfY2xpZW50IGNsaWVudF9hZGRyZXNzIGNsaWVudF9zb2NrZXRcbiAgICA+Pj4gZnVuIHJlcyAtPlxuICAgIENvbm5lY3Rpb24uY2xvc2UgY29ubmVjdGlvblxuICAgID4+PiBmdW4gKCkgLT5cbiAgICBCYWcucmVtb3ZlIHQuY29ubmVjdGlvbnMgY29ubmVjdGlvbnNfZWx0O1xuICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgKGNsb3NlX2ZpbmlzaGVkIHQpICYmIG51bV9jb25uZWN0aW9ucyB0ID0gMFxuICAgIHRoZW4gSXZhci5maWxsX2lmX2VtcHR5IHQuY2xvc2VfZmluaXNoZWRfYW5kX2hhbmRsZXJzX2RldGVybWluZWQgKCk7XG4gICAgKG1hdGNoIHJlcyB3aXRoXG4gICAgIHwgT2sgKCkgLT4gKClcbiAgICAgfCBFcnJvciBlIC0+XG4gICAgICAgKHRyeVxuICAgICAgICAgIG1hdGNoIHQub25faGFuZGxlcl9lcnJvciB3aXRoXG4gICAgICAgICAgfCBgSWdub3JlIC0+ICgpXG4gICAgICAgICAgfCBgUmFpc2UgLT4gcmFpc2UgZVxuICAgICAgICAgIHwgYENhbGwgZiAtPiBmIGNsaWVudF9hZGRyZXNzIGVcbiAgICAgICAgd2l0aFxuICAgICAgICB8IGUgLT5cbiAgICAgICAgICBkb24ndF93YWl0X2ZvciAoY2xvc2UgdCk7XG4gICAgICAgICAgcmFpc2UgZSkpO1xuICAgIG1heWJlX2FjY2VwdCB0XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9mcm9tX3NvY2tldFxuICAgIH5tYXhfY29ubmVjdGlvbnNcbiAgICA/KG1heF9hY2NlcHRzX3Blcl9iYXRjaCA9IDEpXG4gICAgPyhkcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zID0gZmFsc2UpXG4gICAgfm9uX2hhbmRsZXJfZXJyb3JcbiAgICAod2hlcmVfdG9fbGlzdGVuIDogXyBXaGVyZV90b19saXN0ZW4udClcbiAgICBoYW5kbGVfY2xpZW50XG4gICAgc29ja2V0XG4gICAgPVxuICAgIGxldCB0ID1cbiAgICAgIHsgc29ja2V0XG4gICAgICA7IGxpc3RlbmluZ19vbiA9IHdoZXJlX3RvX2xpc3Rlbi5saXN0ZW5pbmdfb24gKFNvY2tldC5nZXRzb2NrbmFtZSBzb2NrZXQpXG4gICAgICA7IG9uX2hhbmRsZXJfZXJyb3JcbiAgICAgIDsgaGFuZGxlX2NsaWVudFxuICAgICAgOyBtYXhfY29ubmVjdGlvbnNcbiAgICAgIDsgbWF4X2FjY2VwdHNfcGVyX2JhdGNoXG4gICAgICA7IGNvbm5lY3Rpb25zID0gQmFnLmNyZWF0ZSAoKVxuICAgICAgOyBhY2NlcHRfaXNfcGVuZGluZyA9IGZhbHNlXG4gICAgICA7IGRyb3BfaW5jb21pbmdfY29ubmVjdGlvbnNcbiAgICAgIDsgY2xvc2VfZmluaXNoZWRfYW5kX2hhbmRsZXJzX2RldGVybWluZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgfVxuICAgIGluXG4gICAgKGNsb3NlX2ZpbmlzaGVkIHRcbiAgICAgPj4+IGZ1biAoKSAtPlxuICAgICBpZiBudW1fY29ubmVjdGlvbnMgdCA9IDBcbiAgICAgdGhlbiBJdmFyLmZpbGxfaWZfZW1wdHkgdC5jbG9zZV9maW5pc2hlZF9hbmRfaGFuZGxlcnNfZGV0ZXJtaW5lZCAoKSk7XG4gICAgbWF5YmVfYWNjZXB0IHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCBnZXRfbWF4X2Nvbm5lY3Rpb25zX2xpbWl0IG1heF9jb25uZWN0aW9ucyA9XG4gICAgbWF0Y2ggbWF4X2Nvbm5lY3Rpb25zIHdpdGhcbiAgICB8IE5vbmUgLT4gMTBfMDAwXG4gICAgfCBTb21lIG1heF9jb25uZWN0aW9ucyAtPlxuICAgICAgaWYgbWF4X2Nvbm5lY3Rpb25zIDw9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgZmFpbHdpdGhzXG4gICAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICAgIFwiVGNwLlNlcnZlci5jcmVhdGVyIGdvdCBuZWdhdGl2ZSBbbWF4X2Nvbm5lY3Rpb25zXVwiXG4gICAgICAgICAgbWF4X2Nvbm5lY3Rpb25zXG4gICAgICAgICAgc2V4cF9vZl9pbnQ7XG4gICAgICBtYXhfY29ubmVjdGlvbnNcbiAgOztcblxuICBtb2R1bGUgU29ja2V0X2NyZWF0b3IgOiBzaWdcbiAgICB0eXBlICdhIHQgY29uc3RyYWludCAnYSA9IFs8IFNvY2tldC5BZGRyZXNzLnQgXVxuXG4gICAgdmFsIGNyZWF0ZVxuICAgICAgOiAgKFsgYFVuY29ubmVjdGVkIF0sICdhZGRyKSBTb2NrZXQudCBvcHRpb25cbiAgICAgIC0+ICgnYWRkciwgXykgV2hlcmVfdG9fbGlzdGVuLnRcbiAgICAgIC0+ICdhZGRyIHRcblxuICAgIHZhbCBiaW5kX2FuZF9saXN0ZW5fbWF5YmVfcmV0cnlcbiAgICAgIDogICdhZGRyIHRcbiAgICAgIC0+IGY6XG4gICAgICAgICAgICgoWyBgVW5jb25uZWN0ZWQgXSwgJ2FkZHIpIFNvY2tldC50XG4gICAgICAgICAgICAtPiAoWyBgUGFzc2l2ZSBdLCAnYWRkcikgU29ja2V0LnQgRGVmZXJyZWQudClcbiAgICAgIC0+IChbIGBQYXNzaXZlIF0sICdhZGRyKSBTb2NrZXQudCBEZWZlcnJlZC50XG5cbiAgICB2YWwgYmluZF9hbmRfbGlzdGVuX21heWJlX3JldHJ5J1xuICAgICAgOiAgJ2FkZHIgdFxuICAgICAgLT4gZjooKFsgYFVuY29ubmVjdGVkIF0sICdhZGRyKSBTb2NrZXQudCAtPiAoWyBgUGFzc2l2ZSBdLCAnYWRkcikgU29ja2V0LnQpXG4gICAgICAtPiAoWyBgUGFzc2l2ZSBdLCAnYWRkcikgU29ja2V0LnRcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSAnYWRkciB0ID1cbiAgICAgIHsgY3JlYXRlX3NvY2tldCA6IHVuaXQgLT4gKFsgYFVuY29ubmVjdGVkIF0sICdhZGRyKSBTb2NrZXQudFxuICAgICAgOyByZXRyaWVzX3Vwb25fYWRkcl9pbl91c2UgOiBpbnRcbiAgICAgIH1cblxuICAgIGxldCBjcmVhdGUgbWF5YmVfc29ja2V0IHdoZXJlX3RvX2xpc3RlbiA9XG4gICAgICBtYXRjaCBtYXliZV9zb2NrZXQgd2l0aFxuICAgICAgfCBTb21lIHNvY2tldCAtPiB7IGNyZWF0ZV9zb2NrZXQgPSBGbi5jb25zdCBzb2NrZXQ7IHJldHJpZXNfdXBvbl9hZGRyX2luX3VzZSA9IDAgfVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIHsgY3JlYXRlX3NvY2tldCA9XG4gICAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgIGxldCBzb2NrZXQgPSBTb2NrZXQuY3JlYXRlIHdoZXJlX3RvX2xpc3Rlbi5XaGVyZV90b19saXN0ZW4uc29ja2V0X3R5cGUgaW5cbiAgICAgICAgICAgICAgU29ja2V0LnNldG9wdCBzb2NrZXQgU29ja2V0Lk9wdC5yZXVzZWFkZHIgdHJ1ZTtcbiAgICAgICAgICAgICAgc29ja2V0KVxuICAgICAgICA7IHJldHJpZXNfdXBvbl9hZGRyX2luX3VzZSA9XG4gICAgICAgICAgICBXaGVyZV90b19saXN0ZW4ubWF4X3JldHJpZXNfdXBvbl9hZGRyX2luX3VzZSB3aGVyZV90b19saXN0ZW5cbiAgICAgICAgfVxuICAgIDs7XG5cbiAgICBsZXQgaGFuZGxlX2V4biB0IHNvY2tldCBleG4gfnJldHJpZXNfYXR0ZW1wdGVkX3Vwb25fYWRkcl9pbl91c2UgPVxuICAgICAgZG9uJ3Rfd2FpdF9mb3IgKFVuaXguY2xvc2UgKFNvY2tldC5mZCBzb2NrZXQpKTtcbiAgICAgIG1hdGNoIHQucmV0cmllc191cG9uX2FkZHJfaW5fdXNlID4gcmV0cmllc19hdHRlbXB0ZWRfdXBvbl9hZGRyX2luX3VzZSwgZXhuIHdpdGhcbiAgICAgIHwgdHJ1ZSwgVW5peC5Vbml4X2Vycm9yIChFQUREUklOVVNFLCBfLCBfKSAtPiBgUGxlYXNlX3JldHJ5XG4gICAgICB8IF8sIF8gLT5cbiAgICAgICAgaWYgcmV0cmllc19hdHRlbXB0ZWRfdXBvbl9hZGRyX2luX3VzZSA+IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIkZhaWxlZCB0byBiaW5kIGFuZCBsaXN0ZW4gdG8gc29ja2V0LlwiXG4gICAgICAgICAgICAgICAgKGV4biA6IEV4bi50KVxuICAgICAgICAgICAgICAgIChyZXRyaWVzX2F0dGVtcHRlZF91cG9uX2FkZHJfaW5fdXNlIDogaW50KV1cbiAgICAgICAgZWxzZSByYWlzZSBleG5cbiAgICA7O1xuXG4gICAgbGV0IHJlYyBhdXhfYmluZF9hbmRfbGlzdGVuX21heWJlX3JldHJ5IHQgfnJldHJpZXNfYXR0ZW1wdGVkX3Vwb25fYWRkcl9pbl91c2UgfmYgPVxuICAgICAgbGV0IHNvY2tldCA9IHQuY3JlYXRlX3NvY2tldCAoKSBpblxuICAgICAgbWF0Y2glYmluZCBNb25pdG9yLnRyeV93aXRoIH5leHRyYWN0X2V4bjp0cnVlIChmdW4gKCkgLT4gZiBzb2NrZXQpIHdpdGhcbiAgICAgIHwgT2sgdiAtPiByZXR1cm4gdlxuICAgICAgfCBFcnJvciBleG4gLT5cbiAgICAgICAgbGV0IGBQbGVhc2VfcmV0cnkgPSBoYW5kbGVfZXhuIHQgc29ja2V0IGV4biB+cmV0cmllc19hdHRlbXB0ZWRfdXBvbl9hZGRyX2luX3VzZSBpblxuICAgICAgICBhdXhfYmluZF9hbmRfbGlzdGVuX21heWJlX3JldHJ5XG4gICAgICAgICAgdFxuICAgICAgICAgIH5yZXRyaWVzX2F0dGVtcHRlZF91cG9uX2FkZHJfaW5fdXNlOihyZXRyaWVzX2F0dGVtcHRlZF91cG9uX2FkZHJfaW5fdXNlICsgMSlcbiAgICAgICAgICB+ZlxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGF1eF9iaW5kX2FuZF9saXN0ZW5fbWF5YmVfcmV0cnknIHQgfnJldHJpZXNfYXR0ZW1wdGVkX3Vwb25fYWRkcl9pbl91c2UgfmYgPVxuICAgICAgbGV0IHNvY2tldCA9IHQuY3JlYXRlX3NvY2tldCAoKSBpblxuICAgICAgdHJ5IGYgc29ja2V0IHdpdGhcbiAgICAgIHwgZXhuIC0+XG4gICAgICAgIGxldCBgUGxlYXNlX3JldHJ5ID0gaGFuZGxlX2V4biB0IHNvY2tldCBleG4gfnJldHJpZXNfYXR0ZW1wdGVkX3Vwb25fYWRkcl9pbl91c2UgaW5cbiAgICAgICAgYXV4X2JpbmRfYW5kX2xpc3Rlbl9tYXliZV9yZXRyeSdcbiAgICAgICAgICB0XG4gICAgICAgICAgfnJldHJpZXNfYXR0ZW1wdGVkX3Vwb25fYWRkcl9pbl91c2U6KHJldHJpZXNfYXR0ZW1wdGVkX3Vwb25fYWRkcl9pbl91c2UgKyAxKVxuICAgICAgICAgIH5mXG4gICAgOztcblxuICAgIGxldCBiaW5kX2FuZF9saXN0ZW5fbWF5YmVfcmV0cnkgPVxuICAgICAgYXV4X2JpbmRfYW5kX2xpc3Rlbl9tYXliZV9yZXRyeSB+cmV0cmllc19hdHRlbXB0ZWRfdXBvbl9hZGRyX2luX3VzZTowXG4gICAgOztcblxuICAgIGxldCBiaW5kX2FuZF9saXN0ZW5fbWF5YmVfcmV0cnknID1cbiAgICAgIGF1eF9iaW5kX2FuZF9saXN0ZW5fbWF5YmVfcmV0cnknIH5yZXRyaWVzX2F0dGVtcHRlZF91cG9uX2FkZHJfaW5fdXNlOjBcbiAgICA7O1xuICBlbmRcblxuICBsZXQgY3JlYXRlX3NvY2tfbm9uX2luZXRfaW50ZXJuYWxcbiAgICA/bWF4X2Nvbm5lY3Rpb25zXG4gICAgP21heF9hY2NlcHRzX3Blcl9iYXRjaFxuICAgID9iYWNrbG9nXG4gICAgP2Ryb3BfaW5jb21pbmdfY29ubmVjdGlvbnNcbiAgICA/c29ja2V0XG4gICAgP3RpbWVfc291cmNlXG4gICAgfm9uX2hhbmRsZXJfZXJyb3JcbiAgICAod2hlcmVfdG9fbGlzdGVuIDogXyBXaGVyZV90b19saXN0ZW4udClcbiAgICBoYW5kbGVfY2xpZW50XG4gICAgPVxuICAgIGxldCB0aW1lX3NvdXJjZSA9XG4gICAgICBtYXRjaCB0aW1lX3NvdXJjZSB3aXRoXG4gICAgICB8IFNvbWUgeCAtPiBUaW1lX3NvdXJjZS5yZWFkX29ubHkgeFxuICAgICAgfCBOb25lIC0+IFRpbWVfc291cmNlLndhbGxfY2xvY2sgKClcbiAgICBpblxuICAgIGxldCVtYXAgc29ja2V0ID1cbiAgICAgIGxldCBzb2NrZXRfY3JlYXRvciA9IFNvY2tldF9jcmVhdG9yLmNyZWF0ZSBzb2NrZXQgd2hlcmVfdG9fbGlzdGVuIGluXG4gICAgICBTb2NrZXRfY3JlYXRvci5iaW5kX2FuZF9saXN0ZW5fbWF5YmVfcmV0cnkgc29ja2V0X2NyZWF0b3IgfmY6KGZ1biBzb2NrZXQgLT5cbiAgICAgICAgU29ja2V0LmJpbmRfa2VlcF9vcHRzIHNvY2tldCB3aGVyZV90b19saXN0ZW4uYWRkcmVzcyA+PnwgU29ja2V0Lmxpc3RlbiA/YmFja2xvZylcbiAgICBpblxuICAgIGxldCBtYXhfY29ubmVjdGlvbnMgPVxuICAgICAgTWF4X2Nvbm5lY3Rpb25zLmNyZWF0ZVxuICAgICAgICB+bGltaXQ6KGdldF9tYXhfY29ubmVjdGlvbnNfbGltaXQgbWF4X2Nvbm5lY3Rpb25zKVxuICAgICAgICB+dGltZV9zb3VyY2VcbiAgICAgICAgICAoKiBXZSBtdXN0IGNhbGwgW0ZkLmluZm9dIG9uIHRoZSBzb2NrZXQncyBmZCBhZnRlciBbU29ja2V0LmJpbmRdIGlzIGNhbGxlZCxcbiAgICAgICAgICAgb3RoZXJ3aXNlIHRoZSBbSW5mby50XSB3b24ndCBoYXZlIGJlZW4gc2V0IHlldC4gKilcbiAgICAgICAgfmxpc3RlbmluZ19vbjooRmQuaW5mbyAoU29ja2V0LmZkIHNvY2tldCkpXG4gICAgaW5cbiAgICBjcmVhdGVfZnJvbV9zb2NrZXRcbiAgICAgIH5tYXhfY29ubmVjdGlvbnNcbiAgICAgID9tYXhfYWNjZXB0c19wZXJfYmF0Y2hcbiAgICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgICB+b25faGFuZGxlcl9lcnJvclxuICAgICAgd2hlcmVfdG9fbGlzdGVuXG4gICAgICBoYW5kbGVfY2xpZW50XG4gICAgICBzb2NrZXRcbiAgOztcblxuICBsZXQgY3JlYXRlX3NvY2tfaW5ldF9pbnRlcm5hbFxuICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICA/bWF4X2FjY2VwdHNfcGVyX2JhdGNoXG4gICAgP2JhY2tsb2dcbiAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgID8oc29ja2V0IDogKFsgYFVuY29ubmVjdGVkIF0sIFNvY2tldC5BZGRyZXNzLkluZXQudCkgU29ja2V0LnQgb3B0aW9uKVxuICAgID90aW1lX3NvdXJjZVxuICAgIH5vbl9oYW5kbGVyX2Vycm9yXG4gICAgKHdoZXJlX3RvX2xpc3RlbiA6IChTb2NrZXQuQWRkcmVzcy5JbmV0LnQsICdsaXN0ZW5pbmdfb24pIFdoZXJlX3RvX2xpc3Rlbi50KVxuICAgIGhhbmRsZV9jbGllbnRcbiAgICA9XG4gICAgbGV0IHRpbWVfc291cmNlID1cbiAgICAgIG1hdGNoIHRpbWVfc291cmNlIHdpdGhcbiAgICAgIHwgU29tZSB4IC0+IFRpbWVfc291cmNlLnJlYWRfb25seSB4XG4gICAgICB8IE5vbmUgLT4gVGltZV9zb3VyY2Uud2FsbF9jbG9jayAoKVxuICAgIGluXG4gICAgbGV0IHNvY2tldCA9XG4gICAgICBsZXQgc29ja2V0X2NyZWF0b3IgPSBTb2NrZXRfY3JlYXRvci5jcmVhdGUgc29ja2V0IHdoZXJlX3RvX2xpc3RlbiBpblxuICAgICAgU29ja2V0X2NyZWF0b3IuYmluZF9hbmRfbGlzdGVuX21heWJlX3JldHJ5JyBzb2NrZXRfY3JlYXRvciB+ZjooZnVuIHNvY2tldCAtPlxuICAgICAgICBTb2NrZXQuYmluZF9pbmV0X2tlZXBfb3B0cyBzb2NrZXQgd2hlcmVfdG9fbGlzdGVuLmFkZHJlc3NcbiAgICAgICAgfD4gU29ja2V0Lmxpc3RlbiA/YmFja2xvZylcbiAgICBpblxuICAgIGxldCBtYXhfY29ubmVjdGlvbnMgPVxuICAgICAgTWF4X2Nvbm5lY3Rpb25zLmNyZWF0ZVxuICAgICAgICB+bGltaXQ6KGdldF9tYXhfY29ubmVjdGlvbnNfbGltaXQgbWF4X2Nvbm5lY3Rpb25zKVxuICAgICAgICB+dGltZV9zb3VyY2VcbiAgICAgICAgICAoKiBXZSBtdXN0IGNhbGwgW0ZkLmluZm9dIG9uIHRoZSBzb2NrZXQncyBmZCBhZnRlciBbU29ja2V0LmJpbmRfaW5ldF0gaXMgY2FsbGVkLFxuICAgICAgICAgICBvdGhlcndpc2UgdGhlIFtJbmZvLnRdIHdvbid0IGhhdmUgYmVlbiBzZXQgeWV0LiAqKVxuICAgICAgICB+bGlzdGVuaW5nX29uOihGZC5pbmZvIChTb2NrZXQuZmQgc29ja2V0KSlcbiAgICBpblxuICAgIGNyZWF0ZV9mcm9tX3NvY2tldFxuICAgICAgfm1heF9jb25uZWN0aW9uc1xuICAgICAgP21heF9hY2NlcHRzX3Blcl9iYXRjaFxuICAgICAgP2Ryb3BfaW5jb21pbmdfY29ubmVjdGlvbnNcbiAgICAgIH5vbl9oYW5kbGVyX2Vycm9yXG4gICAgICB3aGVyZV90b19saXN0ZW5cbiAgICAgIGhhbmRsZV9jbGllbnRcbiAgICAgIHNvY2tldFxuICA7O1xuXG4gIHR5cGUgKCdhZGRyZXNzLCAnbGlzdGVuaW5nX29uLCAndGltZV9zb3VyY2VfYWNjZXNzKSBjcmVhdGVfc29ja19hc3luYyA9XG4gICAgP21heF9jb25uZWN0aW9uczppbnRcbiAgICAtPiA/bWF4X2FjY2VwdHNfcGVyX2JhdGNoOmludFxuICAgIC0+ID9iYWNrbG9nOmludFxuICAgIC0+ID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zOmJvb2xcbiAgICAtPiA/c29ja2V0OihbIGBVbmNvbm5lY3RlZCBdLCAnYWRkcmVzcykgU29ja2V0LnRcbiAgICAtPiA/dGltZV9zb3VyY2U6KFs+IHJlYWQgXSBhcyAndGltZV9zb3VyY2VfYWNjZXNzKSBUaW1lX3NvdXJjZS5UMS50XG4gICAgLT4gb25faGFuZGxlcl9lcnJvcjpbIGBDYWxsIG9mICdhZGRyZXNzIC0+IGV4biAtPiB1bml0IHwgYElnbm9yZSB8IGBSYWlzZSBdXG4gICAgLT4gKCdhZGRyZXNzLCAnbGlzdGVuaW5nX29uKSBXaGVyZV90b19saXN0ZW4udFxuICAgIC0+ICgnYWRkcmVzcyAtPiAoWyBgQWN0aXZlIF0sICdhZGRyZXNzKSBTb2NrZXQudCAtPiAodW5pdCwgZXhuKSBSZXN1bHQudCBEZWZlcnJlZC50KVxuICAgIC0+ICgnYWRkcmVzcywgJ2xpc3RlbmluZ19vbikgdCBEZWZlcnJlZC50XG5cbiAgbGV0IGNyZWF0ZV9zb2NrX2luZXRfaW50ZXJuYWxfYXN5bmMgOiAoJ2FkZHJlc3MsIF8sIF8pIGNyZWF0ZV9zb2NrX2FzeW5jID1cbiAgICBmdW4gP21heF9jb25uZWN0aW9uc1xuICAgICAgICA/bWF4X2FjY2VwdHNfcGVyX2JhdGNoXG4gICAgICAgID9iYWNrbG9nXG4gICAgICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgICAgID9zb2NrZXRcbiAgICAgICAgP3RpbWVfc291cmNlXG4gICAgICAgIH5vbl9oYW5kbGVyX2Vycm9yXG4gICAgICAgIHdoZXJlX3RvX2xpc3RlblxuICAgICAgICBoYW5kbGVfY2xpZW50IC0+XG4gICAgcmV0dXJuXG4gICAgICAoY3JlYXRlX3NvY2tfaW5ldF9pbnRlcm5hbFxuICAgICAgICAgP21heF9jb25uZWN0aW9uc1xuICAgICAgICAgP21heF9hY2NlcHRzX3Blcl9iYXRjaFxuICAgICAgICAgP2JhY2tsb2dcbiAgICAgICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgICAgICA/c29ja2V0XG4gICAgICAgICA/dGltZV9zb3VyY2VcbiAgICAgICAgIH5vbl9oYW5kbGVyX2Vycm9yXG4gICAgICAgICB3aGVyZV90b19saXN0ZW5cbiAgICAgICAgIGhhbmRsZV9jbGllbnQpXG4gIDs7XG5cbiAgdHlwZSAoJ2FkZHJlc3MsICdsaXN0ZW5pbmdfb24sICd0KSBjcmVhdGVfc29ja19hc3luY19ub19jb25zdHJhaW50ID1cbiAgICB8IFQgOlxuICAgICAgICAoJ2FkZHJlc3MsICdsaXN0ZW5pbmdfb24sICd0KSBjcmVhdGVfc29ja19hc3luY1xuICAgICAgICAtPiAoJ2FkZHJlc3MsICdsaXN0ZW5pbmdfb24sICd0KSBjcmVhdGVfc29ja19hc3luY19ub19jb25zdHJhaW50XG5cbiAgdHlwZSAnYWRkcmVzcyBpc19hZGRyZXNzX3R5cGUgPSBUIDogWzwgU29ja2V0LkFkZHJlc3MudCBdIGlzX2FkZHJlc3NfdHlwZVxuXG4gIGxldCBjcmVhdGVfc29ja19pbnRlcm5hbF90eXBlX2hhY2tlcnlcbiAgICA6IHR5cGUgYWRkcmVzcyBsaXN0ZW5pbmdfb24uXG4gICAgICBpc19hZGRyZXNzOmFkZHJlc3MgaXNfYWRkcmVzc190eXBlXG4gICAgICAtPiBpc19pbmV0OihhZGRyZXNzLCBbIGBJbmV0IG9mIFVuaXguSW5ldF9hZGRyLnQgKiBpbnQgXSkgVHlwZV9lcXVhbC50IG9wdGlvblxuICAgICAgLT4gKGFkZHJlc3MsIGxpc3RlbmluZ19vbiwgXykgY3JlYXRlX3NvY2tfYXN5bmNfbm9fY29uc3RyYWludFxuICAgID1cbiAgICBmdW4gfmlzX2FkZHJlc3MgfmlzX2luZXQgLT5cbiAgICBtYXRjaCBpc19pbmV0IHdpdGhcbiAgICB8IFNvbWUgVCAtPiBUIGNyZWF0ZV9zb2NrX2luZXRfaW50ZXJuYWxfYXN5bmNcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBUID0gaXNfYWRkcmVzcyBpblxuICAgICAgVCBjcmVhdGVfc29ja19ub25faW5ldF9pbnRlcm5hbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfc29ja19pbnRlcm5hbCA6IChfLCBfLCBbPiByZWFkIF0pIGNyZWF0ZV9zb2NrX2FzeW5jID1cbiAgICBmdW4gP21heF9jb25uZWN0aW9uc1xuICAgICAgICA/bWF4X2FjY2VwdHNfcGVyX2JhdGNoXG4gICAgICAgID9iYWNrbG9nXG4gICAgICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgICAgID9zb2NrZXRcbiAgICAgICAgP3RpbWVfc291cmNlXG4gICAgICAgIH5vbl9oYW5kbGVyX2Vycm9yXG4gICAgICAgIHdoZXJlX3RvX2xpc3RlblxuICAgICAgICBoYW5kbGVfY2xpZW50IC0+XG4gICAgbGV0IChUIGYpID1cbiAgICAgIGNyZWF0ZV9zb2NrX2ludGVybmFsX3R5cGVfaGFja2VyeVxuICAgICAgICB+aXNfaW5ldDooV2hlcmVfdG9fbGlzdGVuLmlzX2luZXRfd2l0bmVzcyB3aGVyZV90b19saXN0ZW4pXG4gICAgICAgIH5pc19hZGRyZXNzOlRcbiAgICBpblxuICAgIGZcbiAgICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICAgID9tYXhfYWNjZXB0c19wZXJfYmF0Y2hcbiAgICAgID9iYWNrbG9nXG4gICAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgICAgP3NvY2tldFxuICAgICAgP3RpbWVfc291cmNlXG4gICAgICB+b25faGFuZGxlcl9lcnJvclxuICAgICAgd2hlcmVfdG9fbGlzdGVuXG4gICAgICBoYW5kbGVfY2xpZW50XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9zb2NrXG4gICAgP21heF9jb25uZWN0aW9uc1xuICAgID9tYXhfYWNjZXB0c19wZXJfYmF0Y2hcbiAgICA/YmFja2xvZ1xuICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgP3NvY2tldFxuICAgID90aW1lX3NvdXJjZVxuICAgIH5vbl9oYW5kbGVyX2Vycm9yXG4gICAgKHdoZXJlX3RvX2xpc3RlbiA6ICgnYWRkcmVzcywgJ2xpc3RlbmluZ19vbikgV2hlcmVfdG9fbGlzdGVuLnQpXG4gICAgKGhhbmRsZV9jbGllbnQgOlxuICAgICAgKFs8IFNvY2tldC5BZGRyZXNzLnQgXSBhcyAnYikgLT4gKFsgYEFjdGl2ZSBdLCAnYikgU29ja2V0LnQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgID1cbiAgICBjcmVhdGVfc29ja19pbnRlcm5hbFxuICAgICAgP21heF9jb25uZWN0aW9uc1xuICAgICAgP21heF9hY2NlcHRzX3Blcl9iYXRjaFxuICAgICAgP2JhY2tsb2dcbiAgICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgICB+b25faGFuZGxlcl9lcnJvclxuICAgICAgP3NvY2tldFxuICAgICAgP3RpbWVfc291cmNlXG4gICAgICB3aGVyZV90b19saXN0ZW5cbiAgICAgIChmdW4gY2xpZW50X2FkZHJlc3MgY2xpZW50X3NvY2tldCAtPlxuICAgICAgTW9uaXRvci50cnlfd2l0aCB+cnVuOmBTY2hlZHVsZSB+cmVzdDpgTG9nIH5uYW1lOlwiVGNwLlNlcnZlci5jcmVhdGVfc29ja1wiIChmdW4gKCkgLT5cbiAgICAgICAgaGFuZGxlX2NsaWVudCBjbGllbnRfYWRkcmVzcyBjbGllbnRfc29ja2V0KSlcbiAgOztcblxuICBsZXQgY3JlYXRlX3NvY2tfaW5ldFxuICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICA/bWF4X2FjY2VwdHNfcGVyX2JhdGNoXG4gICAgP2JhY2tsb2dcbiAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgID9zb2NrZXRcbiAgICA/dGltZV9zb3VyY2VcbiAgICB+b25faGFuZGxlcl9lcnJvclxuICAgIHdoZXJlX3RvX2xpc3RlblxuICAgIGhhbmRsZV9jbGllbnRcbiAgICA9XG4gICAgY3JlYXRlX3NvY2tfaW5ldF9pbnRlcm5hbFxuICAgICAgP21heF9jb25uZWN0aW9uc1xuICAgICAgP21heF9hY2NlcHRzX3Blcl9iYXRjaFxuICAgICAgP2JhY2tsb2dcbiAgICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgICA/c29ja2V0XG4gICAgICA/dGltZV9zb3VyY2VcbiAgICAgIH5vbl9oYW5kbGVyX2Vycm9yXG4gICAgICB3aGVyZV90b19saXN0ZW5cbiAgICAgIChmdW4gY2xpZW50X2FkZHJlc3MgY2xpZW50X3NvY2tldCAtPlxuICAgICAgTW9uaXRvci50cnlfd2l0aFxuICAgICAgICB+cnVuOmBTY2hlZHVsZVxuICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgIH5uYW1lOlwiVGNwLlNlcnZlci5jcmVhdGVfc29ja19pbmV0XCJcbiAgICAgICAgKGZ1biAoKSAtPiBoYW5kbGVfY2xpZW50IGNsaWVudF9hZGRyZXNzIGNsaWVudF9zb2NrZXQpKVxuICA7O1xuXG4gIGxldCBjcmVhdGVfaW50ZXJuYWxcbiAgICB+Y3JlYXRlX3NvY2tcbiAgICA/YnVmZmVyX2FnZV9saW1pdFxuICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICA/bWF4X2FjY2VwdHNfcGVyX2JhdGNoXG4gICAgP2JhY2tsb2dcbiAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgID9zb2NrZXRcbiAgICA/dGltZV9zb3VyY2VcbiAgICB+b25faGFuZGxlcl9lcnJvclxuICAgIHdoZXJlX3RvX2xpc3RlblxuICAgIGhhbmRsZV9jbGllbnRcbiAgICA9XG4gICAgY3JlYXRlX3NvY2tcbiAgICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICAgID9tYXhfYWNjZXB0c19wZXJfYmF0Y2hcbiAgICAgID9iYWNrbG9nXG4gICAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgICAgP3NvY2tldFxuICAgICAgP3RpbWVfc291cmNlXG4gICAgICB+b25faGFuZGxlcl9lcnJvclxuICAgICAgd2hlcmVfdG9fbGlzdGVuXG4gICAgICAoZnVuIGNsaWVudF9hZGRyZXNzIGNsaWVudF9zb2NrZXQgLT5cbiAgICAgIGxldCByLCB3ID0gcmVhZGVyX3dyaXRlcl9vZl9zb2NrID9idWZmZXJfYWdlX2xpbWl0IGNsaWVudF9zb2NrZXQgaW5cbiAgICAgIFdyaXRlci5zZXRfcmFpc2Vfd2hlbl9jb25zdW1lcl9sZWF2ZXMgdyBmYWxzZTtcbiAgICAgIERlZmVycmVkLmFueVxuICAgICAgICBbIGNvbGxlY3RfZXJyb3JzIHcgKGZ1biAoKSAtPiBoYW5kbGVfY2xpZW50IGNsaWVudF9hZGRyZXNzIHIgdylcbiAgICAgICAgOyBXcml0ZXIuY29uc3VtZXJfbGVmdCB3IHw+IERlZmVycmVkLm9rXG4gICAgICAgIF1cbiAgICAgID4+PSBmdW4gcmVzIC0+IGNsb3NlX2Nvbm5lY3Rpb25fdmlhX3JlYWRlcl9hbmRfd3JpdGVyIHIgdyA+PnwgZnVuICgpIC0+IHJlcylcbiAgOztcblxuICBsZXQgY3JlYXRlX2luZXRcbiAgICA/YnVmZmVyX2FnZV9saW1pdFxuICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICA/bWF4X2FjY2VwdHNfcGVyX2JhdGNoXG4gICAgP2JhY2tsb2dcbiAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgID9zb2NrZXRcbiAgICA/dGltZV9zb3VyY2VcbiAgICB+b25faGFuZGxlcl9lcnJvclxuICAgIHdoZXJlX3RvX2xpc3RlblxuICAgIGhhbmRsZV9jbGllbnRcbiAgICA9XG4gICAgY3JlYXRlX2ludGVybmFsXG4gICAgICB+Y3JlYXRlX3NvY2s6Y3JlYXRlX3NvY2tfaW5ldF9pbnRlcm5hbFxuICAgICAgP2J1ZmZlcl9hZ2VfbGltaXRcbiAgICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICAgID9tYXhfYWNjZXB0c19wZXJfYmF0Y2hcbiAgICAgID9iYWNrbG9nXG4gICAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgICAgP3NvY2tldFxuICAgICAgP3RpbWVfc291cmNlXG4gICAgICB+b25faGFuZGxlcl9lcnJvclxuICAgICAgd2hlcmVfdG9fbGlzdGVuXG4gICAgICBoYW5kbGVfY2xpZW50XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZVxuICAgID9idWZmZXJfYWdlX2xpbWl0XG4gICAgP21heF9jb25uZWN0aW9uc1xuICAgID9tYXhfYWNjZXB0c19wZXJfYmF0Y2hcbiAgICA/YmFja2xvZ1xuICAgID9kcm9wX2luY29taW5nX2Nvbm5lY3Rpb25zXG4gICAgP3NvY2tldFxuICAgID90aW1lX3NvdXJjZVxuICAgIH5vbl9oYW5kbGVyX2Vycm9yXG4gICAgd2hlcmVfdG9fbGlzdGVuXG4gICAgaGFuZGxlX2NsaWVudFxuICAgID1cbiAgICBjcmVhdGVfaW50ZXJuYWxcbiAgICAgIH5jcmVhdGVfc29jazpjcmVhdGVfc29ja19pbnRlcm5hbFxuICAgICAgP2J1ZmZlcl9hZ2VfbGltaXRcbiAgICAgID9tYXhfY29ubmVjdGlvbnNcbiAgICAgID9tYXhfYWNjZXB0c19wZXJfYmF0Y2hcbiAgICAgID9iYWNrbG9nXG4gICAgICA/ZHJvcF9pbmNvbWluZ19jb25uZWN0aW9uc1xuICAgICAgP3NvY2tldFxuICAgICAgP3RpbWVfc291cmNlXG4gICAgICB+b25faGFuZGxlcl9lcnJvclxuICAgICAgd2hlcmVfdG9fbGlzdGVuXG4gICAgICBoYW5kbGVfY2xpZW50XG4gIDs7XG5cbiAgbW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgICBsZXQgZmQgPSBmZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQWxpYXNlcyA9IHN0cnVjdFxuICB0eXBlICdhIHdpdGhfY29ubmVjdF9vcHRpb25zID1cbiAgICA/YnVmZmVyX2FnZV9saW1pdDpbIGBBdF9tb3N0IG9mIFRpbWUuU3Bhbi50IHwgYFVubGltaXRlZCBdXG4gICAgLT4gP2ludGVycnVwdDp1bml0IERlZmVycmVkLnRcbiAgICAtPiA/cmVhZGVyX2J1ZmZlcl9zaXplOmludFxuICAgIC0+ID93cml0ZXJfYnVmZmVyX3NpemU6aW50XG4gICAgLT4gP3RpbWVvdXQ6VGltZS5TcGFuLnRcbiAgICAtPiA/dGltZV9zb3VyY2U6VGltZV9zb3VyY2UudFxuICAgIC0+ICdhXG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGNsb3NlX2Nvbm5lY3Rpb25fdmlhX3JlYWRlcl9hbmRfd3JpdGVyID0gY2xvc2VfY29ubmVjdGlvbl92aWFfcmVhZGVyX2FuZF93cml0ZXJcbiAgbGV0IHNldF9tYXhfY29ubmVjdGlvbl9saW1pdF9sb2dnZXIgPSBTZXJ2ZXIuTWF4X2Nvbm5lY3Rpb25zLnNldF9sb2dnZXJcbmVuZFxuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxubW9kdWxlIFVuaXggPSBVbml4X3N5c2NhbGxzXG5cbnR5cGUgZW52ID0gVW5peC5lbnYgW0BAZGVyaXZpbmcgc2V4cF1cblxudHlwZSB0ID1cbiAgeyBwaWQgOiBQaWQudFxuICA7IHN0ZGluIDogV3JpdGVyLnRcbiAgOyBzdGRvdXQgOiBSZWFkZXIudFxuICA7IHN0ZGVyciA6IFJlYWRlci50XG4gIDsgcHJvZyA6IHN0cmluZ1xuICA7IGFyZ3MgOiBzdHJpbmcgbGlzdFxuICA7IHdvcmtpbmdfZGlyIDogc3RyaW5nIG9wdGlvblxuICA7IGVudiA6IGVudlxuICA7IHdhaXQgOiBVbml4LkV4aXRfb3Jfc2lnbmFsLnQgRGVmZXJyZWQudCBMYXp5LnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzLCBzZXhwX29mXVxuXG5sZXQgY3JlYXRlXG4gID9hcmd2MFxuICA/YnVmX2xlblxuICA/KGVudiA9IGBFeHRlbmQgW10pXG4gID9wcm9nX3NlYXJjaF9wYXRoXG4gID9zdGRpbjp3cml0ZV90b19zdGRpblxuICA/d29ya2luZ19kaXJcbiAgP3NldHBnaWRcbiAgfnByb2dcbiAgfmFyZ3NcbiAgKClcbiAgPVxuICBtYXRjaCVtYXBcbiAgICBJbl90aHJlYWQuc3lzY2FsbCB+bmFtZTpcImNyZWF0ZV9wcm9jZXNzX2VudlwiIChmdW4gKCkgLT5cbiAgICAgIENvcmVfdW5peC5jcmVhdGVfcHJvY2Vzc19lbnZcbiAgICAgICAgfnByb2dcbiAgICAgICAgfmFyZ3NcbiAgICAgICAgfmVudlxuICAgICAgICA/d29ya2luZ19kaXJcbiAgICAgICAgP3Byb2dfc2VhcmNoX3BhdGhcbiAgICAgICAgP2FyZ3YwXG4gICAgICAgID9zZXRwZ2lkXG4gICAgICAgICgpKVxuICB3aXRoXG4gIHwgRXJyb3IgZXhuIC0+IE9yX2Vycm9yLm9mX2V4biBleG5cbiAgfCBPayB7IHBpZDsgc3RkaW47IHN0ZG91dDsgc3RkZXJyIH0gLT5cbiAgICBsZXQgY3JlYXRlX2ZkIG5hbWUgZmlsZV9kZXNjciA9XG4gICAgICBGZC5jcmVhdGVcbiAgICAgICAgRmlmb1xuICAgICAgICBmaWxlX2Rlc2NyXG4gICAgICAgIChJbmZvLmNyZWF0ZVxuICAgICAgICAgICBcImNoaWxkIHByb2Nlc3NcIlxuICAgICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgICAgIChuYW1lLCBgcGlkIHBpZCwgYHByb2cgcHJvZywgYGFyZ3MgYXJncylcbiAgICAgICAgICAgWyVzZXhwX29mOlxuICAgICAgICAgICAgIHN0cmluZyAqIFsgYHBpZCBvZiBQaWQudCBdICogWyBgcHJvZyBvZiBzdHJpbmcgXSAqIFsgYGFyZ3Mgb2Ygc3RyaW5nIGxpc3QgXV0pXG4gICAgaW5cbiAgICBsZXQgc3RkaW4gPVxuICAgICAgbGV0IGZkID0gY3JlYXRlX2ZkIFwic3RkaW5cIiBzdGRpbiBpblxuICAgICAgbWF0Y2ggd3JpdGVfdG9fc3RkaW4gd2l0aFxuICAgICAgfCBOb25lIC0+IFdyaXRlci5jcmVhdGUgP2J1Zl9sZW4gZmRcbiAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgIFdyaXRlci5jcmVhdGVcbiAgICAgICAgICA/YnVmX2xlblxuICAgICAgICAgIGZkXG4gICAgICAgICAgfmJ1ZmZlcl9hZ2VfbGltaXQ6YFVubGltaXRlZFxuICAgICAgICAgIH5yYWlzZV93aGVuX2NvbnN1bWVyX2xlYXZlczpmYWxzZVxuICAgIGluXG4gICAgbGV0IHQgPVxuICAgICAgeyBwaWRcbiAgICAgIDsgc3RkaW5cbiAgICAgIDsgc3Rkb3V0ID0gUmVhZGVyLmNyZWF0ZSA/YnVmX2xlbiAoY3JlYXRlX2ZkIFwic3Rkb3V0XCIgc3Rkb3V0KVxuICAgICAgOyBzdGRlcnIgPSBSZWFkZXIuY3JlYXRlID9idWZfbGVuIChjcmVhdGVfZmQgXCJzdGRlcnJcIiBzdGRlcnIpXG4gICAgICA7IHByb2dcbiAgICAgIDsgYXJnc1xuICAgICAgOyB3b3JraW5nX2RpclxuICAgICAgOyBlbnZcbiAgICAgIDsgd2FpdCA9XG4gICAgICAgICAgKCogSXQncyBvayB0aGF0IHdlJ3JlIG5vdCB1c2luZyBbTGF6eV9kZWZlcnJlZF0gaGVyZSBiZWNhdXNlXG4gICAgICAgICAgICAgdGhlcmUgYXJlIG5vIGtub3duIGV4Y2VwdGlvbnMgdGhhdCBbd2FpdHBpZF0gY2FuIHJhaXNlLlxuICAgICAgICAgICAgIEFsc28sIHdlIG5lZWQgdGhlIGRlZmVycmVkIHRvIGJlIGRldGVybWluZWQgaW4gdGhlIHNhbWUgQXN5bmMgam9iXG4gICAgICAgICAgICAgdGhhdCBtYWtlcyB0aGUgc3lzY2FsbCwgdG8gbWFrZSBbc2VuZF9zaWduYWxdIHNhZmUsIHNvIHdlIGNhbid0IHVzZVxuICAgICAgICAgICAgIFtMYXp5X2RlZmVycmVkXSBhcyBpcy5cbiAgICAgICAgICAgICBUaGUgcmVhc29uIHdlIGRvbid0IHdhbnQgdG8gZWFnZXJseSByZWFwIHRoZSBwcm9jZXNzIGlzIHRoYXQgdGhlIHVzZXIgbWlnaHRcbiAgICAgICAgICAgICB3YW50IHRvIHJlZmVyIHRvIHRoaXMgcHJvY2VzcyBieSBwaWQuIFRoZSBvbmx5IHdheSB0byBkbyB0aGlzIHNhZmVseVxuICAgICAgICAgICAgIGlzIHRvIGRvIGl0IGJlZm9yZSBjYWxsaW5nIFt3YWl0XS5cbiAgICAgICAgICAqKVxuICAgICAgICAgIGxhenkgKFVuaXgud2FpdHBpZF9wcm9tcHQgcGlkKVxuICAgICAgfVxuICAgIGluXG4gICAgKG1hdGNoIHdyaXRlX3RvX3N0ZGluIHdpdGhcbiAgICAgfCBOb25lIC0+ICgpXG4gICAgIHwgU29tZSB3cml0ZV90b19zdGRpbiAtPiBXcml0ZXIud3JpdGUgdC5zdGRpbiB3cml0ZV90b19zdGRpbik7XG4gICAgT2sgdFxuOztcblxubGV0IGNyZWF0ZV9leG5cbiAgP2FyZ3YwXG4gID9idWZfbGVuXG4gID9lbnZcbiAgP3Byb2dfc2VhcmNoX3BhdGhcbiAgP3N0ZGluXG4gID93b3JraW5nX2RpclxuICA/c2V0cGdpZFxuICB+cHJvZ1xuICB+YXJnc1xuICAoKVxuICA9XG4gIGNyZWF0ZVxuICAgID9hcmd2MFxuICAgID9idWZfbGVuXG4gICAgP2VudlxuICAgID9wcm9nX3NlYXJjaF9wYXRoXG4gICAgP3N0ZGluXG4gICAgP3dvcmtpbmdfZGlyXG4gICAgP3NldHBnaWRcbiAgICB+cHJvZ1xuICAgIH5hcmdzXG4gICAgKClcbiAgPj58IG9rX2V4blxuOztcblxubW9kdWxlIExpbmVzX29yX3NleHAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IExpbmVzIG9mIHN0cmluZyBsaXN0XG4gICAgfCBTZXhwIG9mIFNleHAudFxuXG4gIGxldCBzZXhwX29mX3QgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBMaW5lcyAoW10gfCBbIFwiXCIgXSkgLT4gWyVzZXhwIFwiXCJdXG4gICAgfCBMaW5lcyBsaW5lcyAtPiBbJXNleHAgKGxpbmVzIDogc3RyaW5nIGxpc3QpXVxuICAgIHwgU2V4cCBzZXhwIC0+IHNleHBcbiAgOztcblxuICBsZXQgY3JlYXRlIHN0cmluZyA9XG4gICAgdHJ5IFNleHAgKFNleHAub2Zfc3RyaW5nIHN0cmluZykgd2l0aFxuICAgIHwgXyAtPiBMaW5lcyAoU3RyaW5nLnNwbGl0IH5vbjonXFxuJyBzdHJpbmcpXG4gIDs7XG5lbmRcblxubW9kdWxlIE91dHB1dCA9IHN0cnVjdFxuICBtb2R1bGUgU3RhYmxlID0gc3RydWN0XG4gICAgbW9kdWxlIFYxID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB7IHN0ZG91dCA6IHN0cmluZ1xuICAgICAgICA7IHN0ZGVyciA6IHN0cmluZ1xuICAgICAgICA7IGV4aXRfc3RhdHVzIDogVW5peC5FeGl0X29yX3NpZ25hbC50XG4gICAgICAgIH1cbiAgICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG4gICAgZW5kXG4gIGVuZFxuXG4gIGluY2x1ZGUgU3RhYmxlLlYxXG5cbiAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiXCJcbiAgICAgICAgfnN0ZG91dDooTGluZXNfb3Jfc2V4cC5jcmVhdGUgdC5zdGRvdXQgOiBMaW5lc19vcl9zZXhwLnQpXG4gICAgICAgIH5zdGRlcnI6KExpbmVzX29yX3NleHAuY3JlYXRlIHQuc3RkZXJyIDogTGluZXNfb3Jfc2V4cC50KVxuICAgICAgICB+ZXhpdF9zdGF0dXM6KHQuZXhpdF9zdGF0dXMgOiBVbml4LkV4aXRfb3Jfc2lnbmFsLnQpXVxuICA7O1xuZW5kXG5cbmxldCB3YWl0IHQgPSBmb3JjZSB0LndhaXRcblxubGV0IGNvbGxlY3Rfb3V0cHV0X2FuZF93YWl0IHQgPVxuICBsZXQgc3Rkb3V0ID0gUmVhZGVyLmNvbnRlbnRzIHQuc3Rkb3V0IGluXG4gIGxldCBzdGRlcnIgPSBSZWFkZXIuY29udGVudHMgdC5zdGRlcnIgaW5cbiAgbGV0JWJpbmQgKCkgPSBXcml0ZXIuY2xvc2UgdC5zdGRpbiB+Zm9yY2VfY2xvc2U6KERlZmVycmVkLm5ldmVyICgpKSBpblxuICBsZXQlYmluZCBleGl0X3N0YXR1cyA9IHdhaXQgdCBpblxuICBsZXQlYmluZCBzdGRvdXQgPSBzdGRvdXQgaW5cbiAgbGV0JWJpbmQgc3RkZXJyID0gc3RkZXJyIGluXG4gIHJldHVybiB7IE91dHB1dC5zdGRvdXQ7IHN0ZGVycjsgZXhpdF9zdGF0dXMgfVxuOztcblxubW9kdWxlIEZhaWx1cmUgPSBzdHJ1Y3RcbiAgbGV0IHNob3VsZF9kcm9wX2VudiA9IGZ1bmN0aW9uXG4gICAgfCBgRXh0ZW5kIFtdIHwgYE92ZXJyaWRlIFtdIC0+IHRydWVcbiAgICB8IGBFeHRlbmQgKF8gOjogXykgfCBgT3ZlcnJpZGUgKF8gOjogXykgfCBgUmVwbGFjZSBfIHwgYFJlcGxhY2VfcmF3IF8gLT4gZmFsc2VcbiAgOztcblxuICB0eXBlIHQgPVxuICAgIHsgcHJvZyA6IHN0cmluZ1xuICAgIDsgYXJncyA6IHN0cmluZyBsaXN0XG4gICAgOyB3b3JraW5nX2RpciA6IHN0cmluZyBvcHRpb24gW0BzZXhwLm9wdGlvbl1cbiAgICA7IGVudiA6IGVudiBbQHNleHBfZHJvcF9pZiBzaG91bGRfZHJvcF9lbnZdXG4gICAgOyBleGl0X3N0YXR1cyA6IFVuaXguRXhpdF9vcl9zaWduYWwuZXJyb3JcbiAgICA7IHN0ZG91dCA6IExpbmVzX29yX3NleHAudFxuICAgIDsgc3RkZXJyIDogTGluZXNfb3Jfc2V4cC50XG4gICAgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbmxldCBoYW5kbGVfZXhpdF9zdGF0dXMgPyhhY2NlcHRfbm9uemVyb19leGl0ID0gW10pID0gZnVuY3Rpb25cbiAgfCBPayBfIGFzIG9rIC0+IG9rXG4gIHwgRXJyb3IgKGBFeGl0X25vbl96ZXJvIG4pIHdoZW4gTGlzdC5tZW0gYWNjZXB0X25vbnplcm9fZXhpdCBuIH5lcXVhbDpJbnQuZXF1YWwgLT4gT2sgKClcbiAgfCBFcnJvciBfIGFzIGUgLT4gZVxuOztcblxubGV0IGNvbGxlY3Rfc3Rkb3V0X2FuZF93YWl0ID9hY2NlcHRfbm9uemVyb19leGl0IHQgPVxuICBsZXQlbWFwIHsgc3Rkb3V0OyBzdGRlcnI7IGV4aXRfc3RhdHVzIH0gPSBjb2xsZWN0X291dHB1dF9hbmRfd2FpdCB0IGluXG4gIG1hdGNoIGhhbmRsZV9leGl0X3N0YXR1cyA/YWNjZXB0X25vbnplcm9fZXhpdCBleGl0X3N0YXR1cyB3aXRoXG4gIHwgT2sgKCkgLT4gT2sgc3Rkb3V0XG4gIHwgRXJyb3IgZXhpdF9zdGF0dXMgLT5cbiAgICBsZXQgeyBwcm9nOyBhcmdzOyB3b3JraW5nX2RpcjsgZW52OyBfIH0gPSB0IGluXG4gICAgT3JfZXJyb3IuZXJyb3JcbiAgICAgIFwiUHJvY2Vzcy5ydW4gZmFpbGVkXCJcbiAgICAgIHsgRmFpbHVyZS5wcm9nXG4gICAgICA7IGFyZ3NcbiAgICAgIDsgd29ya2luZ19kaXJcbiAgICAgIDsgZW52XG4gICAgICA7IGV4aXRfc3RhdHVzXG4gICAgICA7IHN0ZG91dCA9IExpbmVzX29yX3NleHAuY3JlYXRlIHN0ZG91dFxuICAgICAgOyBzdGRlcnIgPSBMaW5lc19vcl9zZXhwLmNyZWF0ZSBzdGRlcnJcbiAgICAgIH1cbiAgICAgIFslc2V4cF9vZjogRmFpbHVyZS50XVxuOztcblxubGV0IG1hcF9jb2xsZWN0IGNvbGxlY3QgZiA/YWNjZXB0X25vbnplcm9fZXhpdCB0ID1cbiAgbGV0JW1hcCBhID0gY29sbGVjdCA/YWNjZXB0X25vbnplcm9fZXhpdCB0IGluXG4gIGYgYVxuOztcblxubGV0IGNvbGxlY3Rfc3Rkb3V0X2FuZF93YWl0X2V4biA9IG1hcF9jb2xsZWN0IGNvbGxlY3Rfc3Rkb3V0X2FuZF93YWl0IG9rX2V4blxuXG5sZXQgY29sbGVjdF9zdGRvdXRfbGluZXNfYW5kX3dhaXQgPVxuICBtYXBfY29sbGVjdCBjb2xsZWN0X3N0ZG91dF9hbmRfd2FpdCAoT3JfZXJyb3IubWFwIH5mOlN0cmluZy5zcGxpdF9saW5lcylcbjs7XG5cbmxldCBjb2xsZWN0X3N0ZG91dF9saW5lc19hbmRfd2FpdF9leG4gPSBtYXBfY29sbGVjdCBjb2xsZWN0X3N0ZG91dF9saW5lc19hbmRfd2FpdCBva19leG5cblxubGV0IHJ1blxuICA/YWNjZXB0X25vbnplcm9fZXhpdFxuICA/YXJndjBcbiAgP2VudlxuICA/cHJvZ19zZWFyY2hfcGF0aFxuICA/c3RkaW5cbiAgP3dvcmtpbmdfZGlyXG4gIH5wcm9nXG4gIH5hcmdzXG4gICgpXG4gID1cbiAgbWF0Y2glYmluZCBjcmVhdGUgP2FyZ3YwID9lbnYgP3Byb2dfc2VhcmNoX3BhdGggP3N0ZGluID93b3JraW5nX2RpciB+cHJvZyB+YXJncyAoKSB3aXRoXG4gIHwgRXJyb3IgXyBhcyBlIC0+IHJldHVybiBlXG4gIHwgT2sgdCAtPiBjb2xsZWN0X3N0ZG91dF9hbmRfd2FpdCA/YWNjZXB0X25vbnplcm9fZXhpdCB0XG47O1xuXG5sZXQgbWFwX3J1blxuICBydW5cbiAgZlxuICA/YWNjZXB0X25vbnplcm9fZXhpdFxuICA/YXJndjBcbiAgP2VudlxuICA/cHJvZ19zZWFyY2hfcGF0aFxuICA/c3RkaW5cbiAgP3dvcmtpbmdfZGlyXG4gIH5wcm9nXG4gIH5hcmdzXG4gICgpXG4gID1cbiAgbGV0JW1hcCBhID1cbiAgICBydW5cbiAgICAgID9hY2NlcHRfbm9uemVyb19leGl0XG4gICAgICA/YXJndjBcbiAgICAgID9lbnZcbiAgICAgID9wcm9nX3NlYXJjaF9wYXRoXG4gICAgICA/c3RkaW5cbiAgICAgID93b3JraW5nX2RpclxuICAgICAgfnByb2dcbiAgICAgIH5hcmdzXG4gICAgICAoKVxuICBpblxuICBmIGFcbjs7XG5cbmxldCBydW5fZXhuID0gbWFwX3J1biBydW4gb2tfZXhuXG5sZXQgcnVuX2xpbmVzID0gbWFwX3J1biBydW4gKE9yX2Vycm9yLm1hcCB+ZjpTdHJpbmcuc3BsaXRfbGluZXMpXG5sZXQgcnVuX2xpbmVzX2V4biA9IG1hcF9ydW4gcnVuX2xpbmVzIG9rX2V4blxuXG5sZXQgcnVuX2V4cGVjdF9ub19vdXRwdXRcbiAgP2FjY2VwdF9ub256ZXJvX2V4aXRcbiAgP2FyZ3YwXG4gID9lbnZcbiAgP3Byb2dfc2VhcmNoX3BhdGhcbiAgP3N0ZGluXG4gID93b3JraW5nX2RpclxuICB+cHJvZ1xuICB+YXJnc1xuICAoKVxuICA9XG4gIG1hdGNoJW1hcFxuICAgIHJ1blxuICAgICAgP2FjY2VwdF9ub256ZXJvX2V4aXRcbiAgICAgID9hcmd2MFxuICAgICAgP2VudlxuICAgICAgP3Byb2dfc2VhcmNoX3BhdGhcbiAgICAgID9zdGRpblxuICAgICAgP3dvcmtpbmdfZGlyXG4gICAgICB+cHJvZ1xuICAgICAgfmFyZ3NcbiAgICAgICgpXG4gIHdpdGhcbiAgfCBFcnJvciBfIGFzIGVyciAtPiBlcnJcbiAgfCBPayBcIlwiIC0+IE9rICgpXG4gIHwgT2sgbm9uX2VtcHR5X291dHB1dCAtPlxuICAgIE9yX2Vycm9yLmVycm9yIFwiUHJvY2Vzcy5ydW5fZXhwZWN0X25vX291dHB1dDogbm9uLWVtcHR5IG91dHB1dFwiICgpIChmdW4gKCkgLT5cbiAgICAgIFslc2V4cCB7IHByb2cgOiBzdHJpbmc7IGFyZ3MgOiBzdHJpbmcgbGlzdDsgb3V0cHV0ID0gKG5vbl9lbXB0eV9vdXRwdXQgOiBzdHJpbmcpIH1dKVxuOztcblxubGV0IHJ1bl9leHBlY3Rfbm9fb3V0cHV0X2V4biA9IG1hcF9ydW4gcnVuX2V4cGVjdF9ub19vdXRwdXQgb2tfZXhuXG5cbmxldCB0cmFuc2Zlcl9hbmRfY2xvc2UgcmVhZGVyIHdyaXRlciA9XG4gIFJlYWRlci53aXRoX2Nsb3NlIHJlYWRlciB+ZjooZnVuICgpIC0+IFdyaXRlci5zcGxpY2UgfmZyb206cmVhZGVyIHdyaXRlcilcbjs7XG5cbmxldCBmb3J3YXJkX291dHB1dF9hbmRfd2FpdCA/YWNjZXB0X25vbnplcm9fZXhpdCB0ID1cbiAgbGV0JW1hcCAoKSA9IFdyaXRlci5jbG9zZSB0LnN0ZGluIH5mb3JjZV9jbG9zZTooRGVmZXJyZWQubmV2ZXIgKCkpXG4gIGFuZCAoKSA9IHRyYW5zZmVyX2FuZF9jbG9zZSB0LnN0ZG91dCAoTGF6eS5mb3JjZSBXcml0ZXIuc3Rkb3V0KVxuICBhbmQgKCkgPSB0cmFuc2Zlcl9hbmRfY2xvc2UgdC5zdGRlcnIgKExhenkuZm9yY2UgV3JpdGVyLnN0ZGVycilcbiAgYW5kIGV4aXRfc3RhdHVzID0gd2FpdCB0IGluXG4gIG1hdGNoIGhhbmRsZV9leGl0X3N0YXR1cyA/YWNjZXB0X25vbnplcm9fZXhpdCBleGl0X3N0YXR1cyB3aXRoXG4gIHwgT2sgXyBhcyBvayAtPiBva1xuICB8IEVycm9yIGV4aXRfc3RhdHVzIC0+XG4gICAgbGV0IHsgcHJvZzsgYXJnczsgd29ya2luZ19kaXI7IGVudjsgXyB9ID0gdCBpblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlByb2Nlc3MucnVuIGZhaWxlZFwiXG4gICAgICAgICAgKHByb2cgOiBzdHJpbmcpXG4gICAgICAgICAgKGFyZ3MgOiBzdHJpbmcgbGlzdClcbiAgICAgICAgICAod29ya2luZ19kaXIgOiBzdHJpbmcgb3B0aW9uKVxuICAgICAgICAgIChlbnYgOiBlbnYpXG4gICAgICAgICAgKGV4aXRfc3RhdHVzIDogVW5peC5FeGl0X29yX3NpZ25hbC5lcnJvcildXG47O1xuXG5sZXQgZm9yd2FyZF9vdXRwdXRfYW5kX3dhaXRfZXhuID0gbWFwX2NvbGxlY3QgZm9yd2FyZF9vdXRwdXRfYW5kX3dhaXQgb2tfZXhuXG5cbmxldCBydW5fZm9yd2FyZGluZ193aXRoX3NwbGljZWRfZmRzXG4gID9hY2NlcHRfbm9uemVyb19leGl0XG4gID9hcmd2MFxuICA/ZW52XG4gID9wcm9nX3NlYXJjaF9wYXRoXG4gID9zdGRpblxuICA/d29ya2luZ19kaXJcbiAgfnByb2dcbiAgfmFyZ3NcbiAgKClcbiAgPVxuICBtYXRjaCViaW5kIGNyZWF0ZSA/YXJndjAgP2VudiA/cHJvZ19zZWFyY2hfcGF0aCA/c3RkaW4gP3dvcmtpbmdfZGlyIH5wcm9nIH5hcmdzICgpIHdpdGhcbiAgfCBFcnJvciBfIGFzIGUgLT4gcmV0dXJuIGVcbiAgfCBPayB0IC0+IGZvcndhcmRfb3V0cHV0X2FuZF93YWl0ID9hY2NlcHRfbm9uemVyb19leGl0IHRcbjs7XG5cbmxldCBydW5fZm9yd2FyZGluZ193aXRoX3NoYXJlZF9mZHNcbiAgP2FjY2VwdF9ub256ZXJvX2V4aXRcbiAgP2FyZ3YwXG4gID9lbnZcbiAgP3Byb2dfc2VhcmNoX3BhdGhcbiAgP3N0ZGluOndyaXRlX3RvX3N0ZGluXG4gID93b3JraW5nX2RpclxuICB+cHJvZ1xuICB+YXJnc1xuICAoKVxuICA9XG4gIGxldCViaW5kICgpID0gV3JpdGVyLmZsdXNoZWQgKExhenkuZm9yY2UgV3JpdGVyLnN0ZG91dClcbiAgYW5kICgpID0gV3JpdGVyLmZsdXNoZWQgKExhenkuZm9yY2UgV3JpdGVyLnN0ZGVycikgaW5cbiAgbWF0Y2glYmluZFxuICAgIEluX3RocmVhZC5zeXNjYWxsIH5uYW1lOlwiY3JlYXRlX3Byb2Nlc3Nfd2l0aF9mZHNcIiAoZnVuICgpIC0+XG4gICAgICBDb3JlX3VuaXguY3JlYXRlX3Byb2Nlc3Nfd2l0aF9mZHNcbiAgICAgICAgP2FyZ3YwXG4gICAgICAgID9lbnZcbiAgICAgICAgP3Byb2dfc2VhcmNoX3BhdGhcbiAgICAgICAgP3dvcmtpbmdfZGlyXG4gICAgICAgIH5wcm9nXG4gICAgICAgIH5hcmdzXG4gICAgICAgIH5zdGRpbjpHZW5lcmF0ZVxuICAgICAgICB+c3Rkb3V0OihVc2VfdGhpcyBDb3JlX3VuaXguc3Rkb3V0KVxuICAgICAgICB+c3RkZXJyOihVc2VfdGhpcyBDb3JlX3VuaXguc3RkZXJyKVxuICAgICAgICAoKSlcbiAgd2l0aFxuICB8IEVycm9yIGV4biAtPiBEZWZlcnJlZC5Pcl9lcnJvci5vZl9leG4gZXhuXG4gIHwgT2sgeyBwaWQ7IHN0ZGluOyBzdGRvdXQgPSBgRGlkX25vdF9jcmVhdGVfZmQ7IHN0ZGVyciA9IGBEaWRfbm90X2NyZWF0ZV9mZCB9IC0+XG4gICAgbGV0JW1hcCAoKSA9XG4gICAgICBsZXQgd3JpdGVyID1cbiAgICAgICAgRmQuY3JlYXRlXG4gICAgICAgICAgRmlmb1xuICAgICAgICAgIHN0ZGluXG4gICAgICAgICAgKEluZm8uY3JlYXRlXG4gICAgICAgICAgICAgXCJjaGlsZCBwcm9jZXNzXCJcbiAgICAgICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgICAgICAgKFwic3RkaW5cIiwgYHBpZCBwaWQsIGBwcm9nIHByb2csIGBhcmdzIGFyZ3MpXG4gICAgICAgICAgICAgWyVzZXhwX29mOlxuICAgICAgICAgICAgICAgc3RyaW5nICogWyBgcGlkIG9mIFBpZC50IF0gKiBbIGBwcm9nIG9mIHN0cmluZyBdICogWyBgYXJncyBvZiBzdHJpbmcgbGlzdCBdXSlcbiAgICAgICAgfD4gV3JpdGVyLmNyZWF0ZVxuICAgICAgaW5cbiAgICAgIFdyaXRlci53aXRoX2Nsb3NlIHdyaXRlciB+ZjooZnVuICgpIC0+XG4gICAgICAgIChtYXRjaCB3cml0ZV90b19zdGRpbiB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgIHwgU29tZSB3cml0ZV90b19zdGRpbiAtPiBXcml0ZXIud3JpdGUgd3JpdGVyIHdyaXRlX3RvX3N0ZGluKTtcbiAgICAgICAgV3JpdGVyLmZsdXNoZWRfb3JfZmFpbGVkX3VuaXQgd3JpdGVyKVxuICAgIGFuZCBleGl0X3N0YXR1cyA9IFVuaXgud2FpdHBpZF9wcm9tcHQgcGlkIGluXG4gICAgKG1hdGNoIGhhbmRsZV9leGl0X3N0YXR1cyA/YWNjZXB0X25vbnplcm9fZXhpdCBleGl0X3N0YXR1cyB3aXRoXG4gICAgIHwgT2sgXyBhcyBvayAtPiBva1xuICAgICB8IEVycm9yIGV4aXRfc3RhdHVzIC0+XG4gICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgIFwiUHJvY2Vzcy5ydW5fZm9yd2FyZGluZ193aXRoX3NoYXJlZF9mZHMgZmFpbGVkXCJcbiAgICAgICAgICAgICAocHJvZyA6IHN0cmluZylcbiAgICAgICAgICAgICAoYXJncyA6IHN0cmluZyBsaXN0KVxuICAgICAgICAgICAgICh3b3JraW5nX2RpciA6IHN0cmluZyBvcHRpb24pXG4gICAgICAgICAgICAgKGVudiA6IGVudiBvcHRpb24pXG4gICAgICAgICAgICAgKGV4aXRfc3RhdHVzIDogVW5peC5FeGl0X29yX3NpZ25hbC5lcnJvcildKVxuOztcblxubGV0IHJ1bl9mb3J3YXJkaW5nID8oY2hpbGRfZmRzID0gYFNwbGljZSkgPVxuICBtYXRjaCBjaGlsZF9mZHMgd2l0aFxuICB8IGBTcGxpY2UgLT4gcnVuX2ZvcndhcmRpbmdfd2l0aF9zcGxpY2VkX2Zkc1xuICB8IGBTaGFyZSAtPiBydW5fZm9yd2FyZGluZ193aXRoX3NoYXJlZF9mZHNcbjs7XG5cbmxldCBydW5fZm9yd2FyZGluZ19leG4gP2NoaWxkX2ZkcyA9IG1hcF9ydW4gKHJ1bl9mb3J3YXJkaW5nID9jaGlsZF9mZHMpIG9rX2V4blxuXG5sZXQgc2VuZF9zaWduYWxfaW50ZXJuYWwgdCBzaWduYWwgPVxuICAoKiBXZSBkb24ndCBmb3JjZSB0aGUgbGF6eSAoYW5kIHRoZXJlZm9yZSB3ZSBkb24ndCByZWFwIHRoZSBQSUQpIGhlcmUuIFdlIG9ubHkgZG9cbiAgICAgdGhhdCBpZiB0aGUgdXNlciBjYWxscyBbd2FpdF0gZXhwbGljaXRseS4gKilcbiAgaWYgTGF6eS5pc192YWwgdC53YWl0ICYmIERlZmVycmVkLmlzX2RldGVybWluZWQgKExhenkuZm9yY2UgdC53YWl0KVxuICB0aGVuXG4gICAgKCogVGhlIHByb2Nlc3Mgd2FzIHJlYXBlZCwgc28gaXQncyBub3Qgc2FmZSB0byBzZW5kIHNpZ25hbHMgdG8gdGhpcyBwaWQuICopXG4gICAgYE5vX3N1Y2hfcHJvY2Vzc19pbnRlcm5hbFxuICBlbHNlIChcbiAgICBtYXRjaCBTaWduYWxfdW5peC5zZW5kIHNpZ25hbCAoYFBpZCB0LnBpZCkgd2l0aFxuICAgIHwgYE5vX3N1Y2hfcHJvY2VzcyAtPlxuICAgICAgKCogTm9ybWFsbHkgdGhpcyBzaG91bGQgbm90IGJlIHJlYWNoYWJsZTogZXZlbiBmb3IgYSB6b21iaWUgcHJvY2VzcyAoYSBwcm9jZXNzIHRoYXRcbiAgICAgICAgIGhhcyBhbHJlYWR5IGJlZW4gdGVybWluYXRlZCwgYnV0IHdhc24ndCB3YWl0ZWQgZm9yKSwgdGhlIFtraWxsXSBzeXN0ZW0gY2FsbFxuICAgICAgICAgcmV0dXJucyBzdWNjZXNzZnVsbHkuIEFuZCB3ZSBrbm93IHRoYXQgd2UgaGF2ZW4ndCB3YWl0ZWQgZm9yIHRoaXMgcHJvY2VzcyBiZWNhdXNlXG4gICAgICAgICBvdGhlcndpc2UgW3Qud2FpdF0gd291bGQgaGF2ZSBiZWVuIGRldGVybWluZWQuXG5cbiAgICAgICAgIEhvd2V2ZXIsIHdlIGRvIGV4cG9zZSB0aGUgW3BpZF0gc28gdGhlIHVzZXJzIGNhbiBhbmQgZG8gc29tZXRpbWVzIGNhbGxcbiAgICAgICAgIFtVbml4LndhaXRwaWRdIG9uIHRoYXQgcGlkLCB3aGljaCBjYW4gc3RpbGwgbGVhZCB0byB0aGUgcmFjZSB3ZSBhcmUgdHJ5aW5nIHRvXG4gICAgICAgICBwcmV2ZW50LlxuXG4gICAgICAgICBUaGUgcmlnaHQgZml4IHdvdWxkIGJlIHRvIHByZXZlbnQgdXNlcnMgZnJvbSBjYWxsaW5nIFt3YWl0cGlkXSBvbiBvdXIgcGlkLiAqKVxuICAgICAgYE5vX3N1Y2hfcHJvY2Vzc19PU1xuICAgIHwgYE9rIC0+IGBPaylcbjs7XG5cbmxldCBzZW5kX3NpZ25hbF9jb21wYXQgdCBzaWduYWwgPVxuICBtYXRjaCBzZW5kX3NpZ25hbF9pbnRlcm5hbCB0IHNpZ25hbCB3aXRoXG4gIHwgYE5vX3N1Y2hfcHJvY2Vzc19PUyB8IGBOb19zdWNoX3Byb2Nlc3NfaW50ZXJuYWwgLT4gYE5vX3N1Y2hfcHJvY2Vzc1xuICB8IGBPayAtPiBgT2tcbjs7XG5cbmxldCBzZW5kX3NpZ25hbF9jb21wYXRfZXhuIHQgc2lnbmFsID1cbiAgbWF0Y2ggKHNlbmRfc2lnbmFsX2NvbXBhdCB0IHNpZ25hbCA6IFsgYE9rIHwgYE5vX3N1Y2hfcHJvY2VzcyBdKSB3aXRoXG4gIHwgYE9rIC0+ICgpXG4gIHwgYE5vX3N1Y2hfcHJvY2VzcyAtPlxuICAgIGZhaWx3aXRoZlxuICAgICAgXCJQcm9jZXNzLnNlbmRfc2lnbmFsX2NvbXBhdF9leG4gJXMgcGlkOiVzXCJcbiAgICAgIChTaWduYWwudG9fc3RyaW5nIHNpZ25hbClcbiAgICAgIChQaWQudG9fc3RyaW5nIHQucGlkKVxuICAgICAgKClcbjs7XG5cbmxldCBzZW5kX3NpZ25hbCB0IHNpZ25hbCA9XG4gIGlnbm9yZSAoc2VuZF9zaWduYWxfY29tcGF0IHQgc2lnbmFsIDogWyBgT2sgfCBgTm9fc3VjaF9wcm9jZXNzIF0pXG47O1xuXG5tb2R1bGUgQWxpYXNlcyA9IHN0cnVjdFxuICB0eXBlICdhIGNyZWF0ZSA9XG4gICAgP2FyZ3YwOnN0cmluZ1xuICAgIC0+ID9idWZfbGVuOmludFxuICAgIC0+ID9lbnY6ZW52XG4gICAgLT4gP3Byb2dfc2VhcmNoX3BhdGg6c3RyaW5nIGxpc3RcbiAgICAtPiA/c3RkaW46c3RyaW5nXG4gICAgLT4gP3dvcmtpbmdfZGlyOnN0cmluZ1xuICAgIC0+ID9zZXRwZ2lkOkNvcmVfdW5peC5QZ2lkLnRcbiAgICAtPiBwcm9nOnN0cmluZ1xuICAgIC0+IGFyZ3M6c3RyaW5nIGxpc3RcbiAgICAtPiB1bml0XG4gICAgLT4gJ2EgRGVmZXJyZWQudFxuXG4gIHR5cGUgJ2EgcnVuID1cbiAgICA/YWNjZXB0X25vbnplcm9fZXhpdDppbnQgbGlzdFxuICAgIC0+ID9hcmd2MDpzdHJpbmdcbiAgICAtPiA/ZW52OmVudlxuICAgIC0+ID9wcm9nX3NlYXJjaF9wYXRoOnN0cmluZyBsaXN0XG4gICAgLT4gP3N0ZGluOnN0cmluZ1xuICAgIC0+ID93b3JraW5nX2RpcjpzdHJpbmdcbiAgICAtPiBwcm9nOnN0cmluZ1xuICAgIC0+IGFyZ3M6c3RyaW5nIGxpc3RcbiAgICAtPiB1bml0XG4gICAgLT4gJ2EgRGVmZXJyZWQudFxuXG4gIHR5cGUgJ2EgY29sbGVjdCA9ID9hY2NlcHRfbm9uemVyb19leGl0OmludCBsaXN0IC0+IHQgLT4gJ2EgRGVmZXJyZWQudFxuZW5kXG5cbm1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgbGV0IHNlbmRfc2lnbmFsX2ludGVybmFsID0gc2VuZF9zaWduYWxfaW50ZXJuYWxcbmVuZFxuIiwib3BlbiBDb3JlXG5cbnR5cGUgdCA9XG4gIHsgbXV0YWJsZSB0b3RhbCA6IEludDYzLnRcbiAgOyBtdXRhYmxlIGNoYXIgOiBJbnQ2My50XG4gIDsgbXV0YWJsZSBmaWZvIDogSW50NjMudFxuICA7IG11dGFibGUgZmlsZSA6IEludDYzLnRcbiAgOyBtdXRhYmxlIHNvY2tldCA6IEludDYzLnRcbiAgfVxuW0BAZGVyaXZpbmcgc2V4cF1cblxubGV0IGNyZWF0ZSAoKSA9XG4gIHsgdG90YWwgPSBJbnQ2My56ZXJvXG4gIDsgY2hhciA9IEludDYzLnplcm9cbiAgOyBmaWZvID0gSW50NjMuemVyb1xuICA7IGZpbGUgPSBJbnQ2My56ZXJvXG4gIDsgc29ja2V0ID0gSW50NjMuemVyb1xuICB9XG47O1xuXG5sZXQgdXBkYXRlIHQgfihraW5kIDogRmQuS2luZC50KSB+Ynl0ZXMgPVxuICB0LnRvdGFsIDwtIEludDYzLih0LnRvdGFsICsgYnl0ZXMpO1xuICBtYXRjaCBraW5kIHdpdGhcbiAgfCBDaGFyIC0+IHQuY2hhciA8LSBJbnQ2My4oICsgKSB0LmNoYXIgYnl0ZXNcbiAgfCBGaWZvIC0+IHQuZmlmbyA8LSBJbnQ2My4oICsgKSB0LmZpZm8gYnl0ZXNcbiAgfCBGaWxlIC0+IHQuZmlsZSA8LSBJbnQ2My4oICsgKSB0LmZpbGUgYnl0ZXNcbiAgfCBTb2NrZXQgXyAtPiB0LnNvY2tldCA8LSBJbnQ2My4oICsgKSB0LnNvY2tldCBieXRlc1xuOztcblxubGV0IHRvdGFsIHQgPSB0LnRvdGFsXG5cbmxldCBnZXQgdCB+KGtpbmQgOiBGZC5LaW5kLnQpID1cbiAgbWF0Y2gga2luZCB3aXRoXG4gIHwgQ2hhciAtPiB0LmNoYXJcbiAgfCBGaWZvIC0+IHQuZmlmb1xuICB8IEZpbGUgLT4gdC5maWxlXG4gIHwgU29ja2V0IF8gLT4gdC5zb2NrZXRcbjs7XG4iLCJvcGVuIENvcmVcblxubGV0IHN0ZG91dCAoKSA9IExhenkuZm9yY2UgV3JpdGVyLnN0ZG91dFxubGV0IHN0ZGVyciAoKSA9IExhenkuZm9yY2UgV3JpdGVyLnN0ZGVyclxubGV0IGRvX3ByaW50ZiB3cml0ZXIgPSBrc3ByaW50ZiAoZnVuIHMgLT4gV3JpdGVyLndyaXRlICh3cml0ZXIgKCkpIHMpXG5sZXQgcHJpbnRmIGZtdCA9IGRvX3ByaW50ZiBzdGRvdXQgZm10XG5sZXQgZnByaW50ZiB3cml0ZXIgZm10ID0gUHJpbnRmLmtzcHJpbnRmIChmdW4gcyAtPiBXcml0ZXIud3JpdGUgd3JpdGVyIHMpIGZtdFxubGV0IGVwcmludGYgZm10ID0gZG9fcHJpbnRmIHN0ZGVyciBmbXRcbmxldCBwcmludF9jaGFyIGMgPSBXcml0ZXIud3JpdGVfY2hhciAoc3Rkb3V0ICgpKSBjXG5sZXQgcHJlcnJfY2hhciBjID0gV3JpdGVyLndyaXRlX2NoYXIgKHN0ZGVyciAoKSkgY1xubGV0IHByaW50X3N0cmluZyBzID0gV3JpdGVyLndyaXRlIChzdGRvdXQgKCkpIHNcbmxldCBwcmVycl9zdHJpbmcgcyA9IFdyaXRlci53cml0ZSAoc3RkZXJyICgpKSBzXG5sZXQgcHJpbnRfbmV3bGluZSAoKSA9IFdyaXRlci53cml0ZV9jaGFyIChzdGRvdXQgKCkpICdcXG4nXG5sZXQgcHJlcnJfbmV3bGluZSAoKSA9IFdyaXRlci53cml0ZV9jaGFyIChzdGRlcnIgKCkpICdcXG4nXG5cbmxldCBwcmludF9lbmRsaW5lIHMgPVxuICBwcmludF9zdHJpbmcgcztcbiAgcHJpbnRfbmV3bGluZSAoKVxuOztcblxubGV0IHByZXJyX2VuZGxpbmUgcyA9XG4gIHByZXJyX3N0cmluZyBzO1xuICBwcmVycl9uZXdsaW5lICgpXG47O1xuXG5sZXQgcHJpbnRfaW50IGkgPSBwcmludF9zdHJpbmcgKEludC50b19zdHJpbmcgaSlcbmxldCBwcmVycl9pbnQgaSA9IHByZXJyX3N0cmluZyAoSW50LnRvX3N0cmluZyBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBwcmludF9zdHJpbmcgKEZsb2F0LnRvX3N0cmluZ18xMiBmKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBwcmVycl9zdHJpbmcgKEZsb2F0LnRvX3N0cmluZ18xMiBmKVxuXG5sZXQgcHJpbnRfcyA/bWFjaCBzZXhwID1cbiAgcHJpbnRfZW5kbGluZVxuICAgIChtYXRjaCBtYWNoIHdpdGhcbiAgICAgfCBTb21lICgpIC0+IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cFxuICAgICB8IE5vbmUgLT4gU2V4cC50b19zdHJpbmdfaHVtIHNleHApXG47O1xuXG5sZXQgZXByaW50X3MgP21hY2ggc2V4cCA9XG4gIHByZXJyX2VuZGxpbmVcbiAgICAobWF0Y2ggbWFjaCB3aXRoXG4gICAgIHwgU29tZSAoKSAtPiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHBcbiAgICAgfCBOb25lIC0+IFNleHAudG9fc3RyaW5nX2h1bSBzZXhwKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm1vZHVsZSBVbml4ID0gVW5peF9zeXNjYWxsc1xuXG5sZXQgYXJndiA9IChTeXMuYXJndiBbQHdhcm5pbmcgXCItM1wiXSlcbmxldCBnZXRfYXJndiA9IFN5cy5nZXRfYXJndlxubGV0IGV4ZWN1dGFibGVfbmFtZSA9IFN5c191bml4LmV4ZWN1dGFibGVfbmFtZVxubGV0IHdyYXAxIGYgeDEgPSBJbl90aHJlYWQucnVuIChmdW4gKCkgLT4gZiB4MSlcbmxldCB3cmFwMiBmIHgxIHgyID0gSW5fdGhyZWFkLnJ1biAoZnVuICgpIC0+IGYgeDEgeDIpXG5sZXQgY2hkaXIgPSB3cmFwMSBTeXNfdW5peC5jaGRpclxubGV0IGNvbW1hbmQgPSB3cmFwMSBTeXNfdW5peC5jb21tYW5kXG5sZXQgY29tbWFuZF9leG4gPSB3cmFwMSBTeXNfdW5peC5jb21tYW5kX2V4blxubGV0IHF1b3RlID0gU3lzLnF1b3RlXG5sZXQgY29uY2F0X3F1b3RlZCA9IFN5cy5jb25jYXRfcXVvdGVkXG5sZXQgZ2V0Y3dkID0gd3JhcDEgU3lzX3VuaXguZ2V0Y3dkXG5sZXQgaG9tZV9kaXJlY3RvcnkgPSB3cmFwMSBTeXNfdW5peC5ob21lX2RpcmVjdG9yeVxubGV0IGxzX2RpciA9IHdyYXAxIFN5c191bml4LmxzX2RpclxubGV0IHJlYWRkaXIgPSB3cmFwMSBTeXNfdW5peC5yZWFkZGlyXG5sZXQgcmVtb3ZlID0gd3JhcDEgU3lzX3VuaXgucmVtb3ZlXG5sZXQgcmVuYW1lID0gd3JhcDIgU3lzX3VuaXgucmVuYW1lXG5sZXQgd3JhcF9pcyBmID9mb2xsb3dfc3ltbGlua3MgcGF0aCA9IEluX3RocmVhZC5ydW4gKGZ1biAoKSAtPiBmID9mb2xsb3dfc3ltbGlua3MgcGF0aClcbmxldCBmaWxlX2V4aXN0cyA9IHdyYXBfaXMgU3lzX3VuaXguZmlsZV9leGlzdHNcbmxldCBmaWxlX2V4aXN0c19leG4gPSB3cmFwX2lzIFN5c191bml4LmZpbGVfZXhpc3RzX2V4blxubGV0IGlzX2RpcmVjdG9yeSA9IHdyYXBfaXMgU3lzX3VuaXguaXNfZGlyZWN0b3J5XG5sZXQgaXNfZGlyZWN0b3J5X2V4biA9IHdyYXBfaXMgU3lzX3VuaXguaXNfZGlyZWN0b3J5X2V4blxubGV0IGlzX2ZpbGUgPSB3cmFwX2lzIFN5c191bml4LmlzX2ZpbGVcbmxldCBpc19maWxlX2V4biA9IHdyYXBfaXMgU3lzX3VuaXguaXNfZmlsZV9leG5cblxubGV0IHdoZW5fZmlsZV9jaGFuZ2VzXG4gID8odGltZV9zb3VyY2UgPSBUaW1lX3NvdXJjZS53YWxsX2Nsb2NrICgpKVxuICA/KHBvbGxfZGVsYXkgPSBzZWMgMC41KVxuICBmaWxlXG4gID1cbiAgbGV0IGxhc3RfcmVwb3J0ZWRfbXRpbWUgPSByZWYgTm9uZSBpblxuICBsZXQgcmVhZGVyLCB3cml0ZXIgPSBQaXBlLmNyZWF0ZSAoKSBpblxuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIE1vbml0b3IudHJ5X3dpdGggfnJ1bjpgU2NoZWR1bGUgfnJlc3Q6YExvZyB+ZXh0cmFjdF9leG46dHJ1ZSAoZnVuICgpIC0+XG4gICAgICBVbml4LnN0YXQgZmlsZSlcbiAgICA+Pj4gZnVuIHN0YXRfcmVzdWx0IC0+XG4gICAgaWYgbm90IChQaXBlLmlzX2Nsb3NlZCB3cml0ZXIpXG4gICAgdGhlbiAoXG4gICAgICAobWF0Y2ggc3RhdF9yZXN1bHQgd2l0aFxuICAgICAgIHwgRXJyb3IgZXhuIC0+XG4gICAgICAgICBsYXN0X3JlcG9ydGVkX210aW1lIDo9IE5vbmU7XG4gICAgICAgICBQaXBlLndyaXRlX3dpdGhvdXRfcHVzaGJhY2sgd3JpdGVyIChFcnJvciBleG4pXG4gICAgICAgfCBPayBzdCAtPlxuICAgICAgICAgbGV0IG10aW1lID0gc3QubXRpbWUgaW5cbiAgICAgICAgIGxldCBzaG91bGRfcmVwb3J0ID1cbiAgICAgICAgICAgbWF0Y2ggIWxhc3RfcmVwb3J0ZWRfbXRpbWUgd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgICAgICB8IFNvbWUgbGFzdF9yZXBvcnRlZF9tdGltZSAtPiBub3QgKFRpbWUuZXF1YWwgbXRpbWUgbGFzdF9yZXBvcnRlZF9tdGltZSlcbiAgICAgICAgIGluXG4gICAgICAgICBpZiBzaG91bGRfcmVwb3J0XG4gICAgICAgICB0aGVuIChcbiAgICAgICAgICAgbGFzdF9yZXBvcnRlZF9tdGltZSA6PSBTb21lIG10aW1lO1xuICAgICAgICAgICBQaXBlLndyaXRlX3dpdGhvdXRfcHVzaGJhY2sgd3JpdGVyIChPayBtdGltZSkpKTtcbiAgICAgIFRpbWVfc291cmNlLmFmdGVyIHRpbWVfc291cmNlIChUaW1lX25zLlNwYW4ub2Zfc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0IHBvbGxfZGVsYXkpXG4gICAgICA+Pj4gbG9vcClcbiAgaW5cbiAgbG9vcCAoKTtcbiAgcmVhZGVyXG47O1xuXG5sZXQgd2hlbl9maWxlX2V4aXN0cyA/Zm9sbG93X3N5bWxpbmtzID8ocG9sbF9kZWxheSA9IHNlYyAwLjUpIGZpbGUgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpIC0+XG4gICAgbGV0IHJlYyBsb29wICgpID1cbiAgICAgIGZpbGVfZXhpc3RzID9mb2xsb3dfc3ltbGlua3MgZmlsZVxuICAgICAgPj4+IGZ1bmN0aW9uXG4gICAgICB8IGBZZXMgLT4gSXZhci5maWxsX2V4biBpICgpXG4gICAgICB8IGBObyAtPiB1cG9uIChDbG9jay5hZnRlciBwb2xsX2RlbGF5KSBsb29wXG4gICAgICB8IGBVbmtub3duIC0+XG4gICAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwid2hlbl9maWxlX2V4aXN0cyBjYW4gbm90IGNoZWNrIGZpbGVcIiAoZmlsZSA6IHN0cmluZyldXG4gICAgaW5cbiAgICBsb29wICgpKVxuOztcblxubGV0IGNfaW50X3NpemUgPSBTeXNfdW5peC5jX2ludF9zaXplXG5sZXQgZXhlY3V0aW9uX21vZGUgPSBTeXNfdW5peC5leGVjdXRpb25fbW9kZVxubGV0IGdldGVudiA9IFN5cy5nZXRlbnZcbmxldCBnZXRlbnZfZXhuID0gU3lzLmdldGVudl9leG5cbmxldCBpbnRfc2l6ZSA9IFN5cy5pbnRfc2l6ZV9pbl9iaXRzXG5sZXQgaW50ZXJhY3RpdmUgPSBTeXMuaW50ZXJhY3RpdmVcbmxldCBvY2FtbF92ZXJzaW9uID0gU3lzLm9jYW1sX3ZlcnNpb25cbmxldCBvc190eXBlID0gU3lzLm9zX3R5cGVcbmxldCB3b3JkX3NpemUgPSBTeXMud29yZF9zaXplX2luX2JpdHNcbmxldCBvcGFxdWVfaWRlbnRpdHkgPSBTeXMub3BhcXVlX2lkZW50aXR5XG5sZXQgYmlnX2VuZGlhbiA9IFN5cy5iaWdfZW5kaWFuXG4iLCJtb2R1bGUgQXN5bmNfY29uZmlnID0gQ29uZmlnXG5tb2R1bGUgQnVzeV9wb2xsZXIgPSBCdXN5X3BvbGxlclxubW9kdWxlIENsb2NrID0gQ2xvY2tcbm1vZHVsZSBEdW1wX2NvcmVfb25fam9iX2RlbGF5ID0gRHVtcF9jb3JlX29uX2pvYl9kZWxheVxubW9kdWxlIEZkID0gRmRcbm1vZHVsZSBJbl90aHJlYWQgPSBJbl90aHJlYWRcbm1vZHVsZSBJb19zdGF0cyA9IElvX3N0YXRzXG5tb2R1bGUgSW9fdXJpbmdfcmF3ID0gSW9fdXJpbmdfcmF3XG5tb2R1bGUgSW9fdXJpbmdfcmF3X3NpbmdsZXRvbiA9IElvX3VyaW5nX3Jhd19zaW5nbGV0b25cbm1vZHVsZSBJb191cmluZyA9IElvX3VyaW5nXG5tb2R1bGUgUHJpbnQgPSBBc3luY19wcmludFxubW9kdWxlIFByb2Nlc3MgPSBQcm9jZXNzXG5tb2R1bGUgUmVhZGVyID0gUmVhZGVyXG5tb2R1bGUgUmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZSA9IFJlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2Vcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXJcbm1vZHVsZSBTaHV0ZG93biA9IFNodXRkb3duXG5tb2R1bGUgU2lnbmFsID0gU2lnbmFsXG5tb2R1bGUgU29ja2V0ID0gVW5peF9zeXNjYWxscy5Tb2NrZXRcbm1vZHVsZSBTeXMgPSBBc3luY19zeXNcbm1vZHVsZSBUY3AgPSBUY3Bcbm1vZHVsZSBUaHJlYWRfc2FmZSA9IFRocmVhZF9zYWZlXG5tb2R1bGUgV3JpdGVyID0gV3JpdGVyXG5cbm1vZHVsZSBVbml4ID0gc3RydWN0XG4gIG1vZHVsZSBGZCA9IEZkXG5cbiAgaW5jbHVkZSBVbml4X3N5c2NhbGxzICgqKiBAb3BlbiAqKVxuZW5kXG5cbmxldCBhZnRlciA9IENsb2NrLmFmdGVyXG5sZXQgYXQgPSBDbG9jay5hdFxubGV0IGV2ZXJ5ID0gQ2xvY2suZXZlcnlcbmxldCB3aXRoX3RpbWVvdXQgPSBDbG9jay53aXRoX3RpbWVvdXRcbmxldCBzY2hlZHVsZSA9IFNjaGVkdWxlci5zY2hlZHVsZVxubGV0IHNjaGVkdWxlJyA9IFNjaGVkdWxlci5zY2hlZHVsZSdcbmxldCBzaHV0ZG93biA9IFNodXRkb3duLnNodXRkb3duXG5sZXQgd2l0aGluID0gU2NoZWR1bGVyLndpdGhpblxubGV0IHdpdGhpbicgPSBTY2hlZHVsZXIud2l0aGluJ1xuXG4oKiBXZSByZWJpbmQgYWxsIHBlcnZhc2l2ZSBhbmQgc29tZSBDb3JlIGZ1bmN0aW9ucyB0aGF0IGRlYWwgd2l0aCBJL08gc28gdGhhdCBvbmVcbiAgIGRvZXNuJ3QgdW5pbnRlbnRpb25hbGx5IGRvIGJsb2NraW5nIHN0dWZmIGluIGFuIEFzeW5jIHByb2dyYW0uICopXG5cbigqKiBTaGFkb3cgYmxvY2tpbmcgZnVuY3Rpb25zIGluIFtDb3JlLlByaW50Zl0gdG8gcHJldmVudCB0aGVpciB1bmludGVudGlvbmFsIHVzZS4gKilcbm1vZHVsZSBQcmludGYgPSBzdHJ1Y3RcbiAgbGV0IF9zaGFkb3cgPSBgUHJvYmFibHlfc2hvdWxkX25vdF91c2VfYmxvY2tpbmdfQ29yZV9QcmludGZfZnVuY3Rpb25zX3dpdGhfQXN5bmNcbiAgbGV0IGJwcmludGYgPSBDb3JlLlByaW50Zi5icHJpbnRmXG4gIGxldCBlcHJpbnRmID0gX3NoYWRvd1xuICBsZXQgZXhpdGYgPSBfc2hhZG93XG4gIGxldCBmYWlsd2l0aGYgPSBDb3JlLlByaW50Zi5mYWlsd2l0aGZcbiAgbGV0IGZwcmludGYgXyA9IF9zaGFkb3dcbiAgbGV0IGlmcHJpbnRmIF8gPSBDb3JlLlByaW50Zi5pZnByaW50ZlxuICBsZXQgaW52YWxpZF9hcmdmID0gQ29yZS5QcmludGYuaW52YWxpZF9hcmdmXG4gIGxldCBrYnByaW50ZiA9IENvcmUuUHJpbnRmLmticHJpbnRmXG4gIGxldCBrZnByaW50ZiBfIF8gPSBfc2hhZG93XG4gIGxldCBrc3ByaW50ZiA9IENvcmUuUHJpbnRmLmtzcHJpbnRmXG4gIGxldCBwcmludGYgPSBfc2hhZG93XG4gIGxldCBzcHJpbnRmID0gQ29yZS5QcmludGYuc3ByaW50ZlxuZW5kXG5cbmluY2x1ZGUgc3RydWN0XG4gIG9wZW4gQ29yZVxuXG4gIG1vZHVsZSBPdmVyd3JpdGVfID0gc3RydWN0XG4gICAgbGV0IG92ZXJ3cml0ZTEgKGBUaGlzX2lzX2FzeW5jX19UaGlua19hYm91dF9ibG9ja2luZyBhcyB4KSA9IHhcbiAgICBsZXQgb3ZlcndyaXRlMiBgVGhpc19pc19hc3luY19fVGhpbmtfYWJvdXRfYmxvY2tpbmcgPSBvdmVyd3JpdGUxXG4gICAgbGV0IG92ZXJ3cml0ZTMgYFRoaXNfaXNfYXN5bmNfX1RoaW5rX2Fib3V0X2Jsb2NraW5nID0gb3ZlcndyaXRlMlxuICAgIGxldCBvdmVyd3JpdGU0IGBUaGlzX2lzX2FzeW5jX19UaGlua19hYm91dF9ibG9ja2luZyA9IG92ZXJ3cml0ZTNcbiAgZW5kXG5cbiAgb3BlbiBPdmVyd3JpdGVfXG5cbiAgbGV0IGNsb3NlX2luX25vZXJyID0gb3ZlcndyaXRlMVxuICBsZXQgY2xvc2VfaW4gPSBvdmVyd3JpdGUxXG4gIGxldCBjbG9zZV9vdXRfbm9lcnIgPSBvdmVyd3JpdGUxXG4gIGxldCBjbG9zZV9vdXQgPSBvdmVyd3JpdGUxXG4gIGxldCBlcHJpbnRmID0gUHJpbnQuZXByaW50ZlxuICBsZXQgZmx1c2hfYWxsID0gb3ZlcndyaXRlMVxuICBsZXQgZmx1c2ggPSBvdmVyd3JpdGUxXG4gIGxldCBmcHJpbnRmID0gUHJpbnQuZnByaW50ZlxuICBsZXQgaWZwcmludGYgPSBQcmludGYuaWZwcmludGZcbiAgbGV0IGluX2NoYW5uZWxfbGVuZ3RoID0gb3ZlcndyaXRlMVxuICBsZXQgaW5wdXRfYmluYXJ5X2ludCA9IG92ZXJ3cml0ZTFcbiAgbGV0IGlucHV0X2J5dGUgPSBvdmVyd3JpdGUxXG4gIGxldCBpbnB1dF9jaGFyID0gb3ZlcndyaXRlMVxuICBsZXQgaW5wdXRfbGluZSA9IG92ZXJ3cml0ZTFcbiAgbGV0IGlucHV0X2xpbmVzID9maXhfd2luX2VvbDpfID0gb3ZlcndyaXRlMVxuICBsZXQgaW5wdXQgPSBvdmVyd3JpdGU0XG4gIGxldCBpbnB1dF92YWx1ZSA9IG92ZXJ3cml0ZTFcbiAgbGV0IG9wZW5faW5fYmluID0gb3ZlcndyaXRlMVxuICBsZXQgb3Blbl9pbl9nZW4gPSBvdmVyd3JpdGUzXG4gIGxldCBvcGVuX2luID0gb3ZlcndyaXRlMVxuICBsZXQgb3Blbl9vdXRfYmluID0gb3ZlcndyaXRlMVxuICBsZXQgb3Blbl9vdXRfZ2VuID0gb3ZlcndyaXRlM1xuICBsZXQgb3Blbl9vdXQgPSBvdmVyd3JpdGUxXG4gIGxldCBvdXRfY2hhbm5lbF9sZW5ndGggPSBvdmVyd3JpdGUxXG4gIGxldCBvdXRwdXRfYmluYXJ5X2ludCA9IG92ZXJ3cml0ZTJcbiAgbGV0IG91dHB1dF9ieXRlID0gb3ZlcndyaXRlMlxuICBsZXQgb3V0cHV0X2NoYXIgPSBvdmVyd3JpdGUyXG4gIGxldCBvdXRwdXQgPSBvdmVyd3JpdGU0XG4gIGxldCBvdXRwdXRfc3RyaW5nID0gb3ZlcndyaXRlMlxuICBsZXQgb3V0cHV0X3ZhbHVlID0gb3ZlcndyaXRlMlxuICBsZXQgcG9zX2luID0gb3ZlcndyaXRlMVxuICBsZXQgcG9zX291dCA9IG92ZXJ3cml0ZTFcbiAgbGV0IHByZXJyX2NoYXIgPSBQcmludC5wcmVycl9jaGFyXG4gIGxldCBwcmVycl9lbmRsaW5lID0gUHJpbnQucHJlcnJfZW5kbGluZVxuICBsZXQgcHJlcnJfZmxvYXQgPSBQcmludC5wcmVycl9mbG9hdFxuICBsZXQgcHJlcnJfaW50ID0gUHJpbnQucHJlcnJfaW50XG4gIGxldCBwcmVycl9uZXdsaW5lID0gUHJpbnQucHJlcnJfbmV3bGluZVxuICBsZXQgcHJlcnJfc3RyaW5nID0gUHJpbnQucHJlcnJfc3RyaW5nXG4gIGxldCBwcmludF9jaGFyID0gUHJpbnQucHJpbnRfY2hhclxuICBsZXQgcHJpbnRfZW5kbGluZSA9IFByaW50LnByaW50X2VuZGxpbmVcbiAgbGV0IHByaW50X2Zsb2F0ID0gUHJpbnQucHJpbnRfZmxvYXRcbiAgbGV0IHByaW50ZiA9IFByaW50LnByaW50ZlxuICBsZXQgcHJpbnRfaW50ID0gUHJpbnQucHJpbnRfaW50XG4gIGxldCBwcmludF9uZXdsaW5lID0gUHJpbnQucHJpbnRfbmV3bGluZVxuICBsZXQgcHJpbnRfcyA9IFByaW50LnByaW50X3NcbiAgbGV0IHByaW50X3N0cmluZyA9IFByaW50LnByaW50X3N0cmluZ1xuICBsZXQgcmVhZF9mbG9hdCA9IG92ZXJ3cml0ZTFcbiAgbGV0IHJlYWRfaW50ID0gb3ZlcndyaXRlMVxuICBsZXQgcmVhZF9saW5lID0gb3ZlcndyaXRlMVxuICBsZXQgcmVhZF9saW5lcyA9IG92ZXJ3cml0ZTFcbiAgbGV0IHJlYWRfd3JhcCA/YmluYXJ5Ol8gfmY6XyA9IG92ZXJ3cml0ZTFcbiAgbGV0IHJlYWxseV9pbnB1dCA9IG92ZXJ3cml0ZTRcbiAgbGV0IHNlZWtfaW4gPSBvdmVyd3JpdGUyXG4gIGxldCBzZWVrX291dCA9IG92ZXJ3cml0ZTFcbiAgbGV0IHNldF9iaW5hcnlfbW9kZV9pbiA9IG92ZXJ3cml0ZTJcbiAgbGV0IHNldF9iaW5hcnlfbW9kZV9vdXQgPSBvdmVyd3JpdGUyXG4gIGxldCB3cml0ZV9saW5lcyA9IG92ZXJ3cml0ZTJcbiAgbGV0IHdyaXRlX3dyYXAgP2JpbmFyeTpfIH5mOl8gPSBvdmVyd3JpdGUxXG5cbiAgbGV0IChlcHJpbnRfcyBbQGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgIFwiW3NpbmNlIDIwMTktMTJdIElmIHlvdSB3YW50IHRvIHRoZSBibG9ja2luZyB2ZXJzaW9uLCB1c2UgXFxcbiAgICAgICAgICAgICAgICAgICBbQ29yZS5lcHJpbnRfc10gKHRoaXMgcHJlc2VydmVzIGJlaGF2aW9yLCBidXQgaXMgZGlzY291cmFnZWQpLiBJZiB5b3UgXFxcbiAgICAgICAgICAgICAgICAgICB3YW50IHRoZSBub25ibG9ja2luZyB2ZXJzaW9uLCB1c2UgW2VwcmludF9zX25vbmJsb2NraW5nXSBvciBcXFxuICAgICAgICAgICAgICAgICAgIFtQcmludC5lcHJpbnRfc11cIl0pXG4gICAgPVxuICAgIG92ZXJ3cml0ZTFcbiAgOztcblxuICBsZXQgZXByaW50X3Nfbm9uYmxvY2tpbmcgPSBQcmludC5lcHJpbnRfc1xuXG4gIG1vZHVsZSBMYXJnZUZpbGUgPSBzdHJ1Y3RcbiAgICBsZXQgc2Vla19vdXQgPSBvdmVyd3JpdGUxXG4gICAgbGV0IHBvc19vdXQgPSBvdmVyd3JpdGUxXG4gICAgbGV0IG91dF9jaGFubmVsX2xlbmd0aCA9IG92ZXJ3cml0ZTFcbiAgICBsZXQgc2Vla19pbiA9IG92ZXJ3cml0ZTFcbiAgICBsZXQgcG9zX2luID0gb3ZlcndyaXRlMVxuICAgIGxldCBpbl9jaGFubmVsX2xlbmd0aCA9IG92ZXJ3cml0ZTFcbiAgZW5kXG5cbiAgbW9kdWxlIFNleHAgOiBzaWdcbiAgICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgICAgaW5jbHVkZSBTZXhwXG4gICAgZW5kXG5cbiAgICB2YWwgc2F2ZSA6ID9wZXJtOmludCAtPiBzdHJpbmcgLT4gdCAtPiB1bml0XG4gICAgICBbQEBhbGVydCBibG9ja2luZyBcIlVzZSBbV3JpdGVyLnNhdmVfc2V4cCB+aHVtOmZhbHNlXSB0byBhdm9pZCBibG9ja2luZy5cIl1cblxuICAgIHZhbCBzYXZlX2h1bSA6ID9wZXJtOmludCAtPiBzdHJpbmcgLT4gdCAtPiB1bml0XG4gICAgICBbQEBhbGVydCBibG9ja2luZyBcIlVzZSBbV3JpdGVyLnNhdmVfc2V4cCB+aHVtOnRydWVdIHRvIGF2b2lkIGJsb2NraW5nLlwiXVxuXG4gICAgdmFsIHNhdmVfbWFjaCA6ID9wZXJtOmludCAtPiBzdHJpbmcgLT4gdCAtPiB1bml0XG4gICAgICBbQEBhbGVydCBibG9ja2luZyBcIlVzZSBbV3JpdGVyLnNhdmVfc2V4cCB+aHVtOmZhbHNlXSB0byBhdm9pZCBibG9ja2luZy5cIl1cblxuICAgIHZhbCBzYXZlX3NleHBzIDogP3Blcm06aW50IC0+IHN0cmluZyAtPiB0IGxpc3QgLT4gdW5pdFxuICAgICAgW0BAYWxlcnQgYmxvY2tpbmcgXCJVc2UgW1dyaXRlci5zYXZlX3NleHBzIH5odW06ZmFsc2VdIHRvIGF2b2lkIGJsb2NraW5nLlwiXVxuXG4gICAgdmFsIHNhdmVfc2V4cHNfaHVtIDogP3Blcm06aW50IC0+IHN0cmluZyAtPiB0IGxpc3QgLT4gdW5pdFxuICAgICAgW0BAYWxlcnQgYmxvY2tpbmcgXCJVc2UgW1dyaXRlci5zYXZlX3NleHBzIH5odW06dHJ1ZV0gdG8gYXZvaWQgYmxvY2tpbmcuXCJdXG5cbiAgICB2YWwgc2F2ZV9zZXhwc19tYWNoIDogP3Blcm06aW50IC0+IHN0cmluZyAtPiB0IGxpc3QgLT4gdW5pdFxuICAgICAgW0BAYWxlcnQgYmxvY2tpbmcgXCJVc2UgW1dyaXRlci5zYXZlX3NleHBzIH5odW06ZmFsc2VdIHRvIGF2b2lkIGJsb2NraW5nLlwiXVxuICBlbmQgPVxuICAgIFNleHBcbmVuZFxuXG5sZXQgZXhpdCA9IFNodXRkb3duLmV4aXRcblxuKCoqLyoqKVxuXG5tb2R1bGUgQXN5bmNfdW5peF9wcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBCeV9kZXNjciA9IEJ5X2Rlc2NyXG4gIG1vZHVsZSBSYXdfZmQgPSBSYXdfZmRcbiAgbW9kdWxlIFJhd19zY2hlZHVsZXIgPSBSYXdfc2NoZWR1bGVyXG4gIG1vZHVsZSBTeXNjYWxsID0gU3lzY2FsbFxuZW5kXG4iXX0=
