// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Time_stamp_counter__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Time_stamp_counter = [0],
    Time_stamp_counter$0 = [0, Time_stamp_counter];
   runtime.caml_register_global
    (0, Time_stamp_counter$0, "Time_stamp_counter__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Time_stamp_counter__Import
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Time_stamp_counter_Import = "Time_stamp_counter__Import",
    cst_time_stamp_counter = "time_stamp_counter";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Time_stamp_counter_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_time_stamp_counter);
   caml_call1(Ppx_expect_runtime[1][1], "time_stamp_counter/src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_time_stamp_counter, "import.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_time_stamp_counter);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Time_stamp_counter_Import);
   var Time_stamp_counter_Import = [0];
   runtime.caml_register_global
    (11, Time_stamp_counter_Import, cst_Time_stamp_counter_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Time_stamp_counter
//# unitInfo: Requires: Base__Exn, Bin_prot__Common, Bin_prot__Shape, Bin_shape, Core, Core__Core_sys, Core__Float, Core__Int, Core__Int63, Core__List, Core__Time_float, Core__Time_ns, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv_record, Stdlib, Typerep_lib__Make_typename
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Time_stamp_counter$0 = "Time_stamp_counter",
    cst_ewma_time$1 = "ewma_time",
    cst_ewma_time_tsc$1 = "ewma_time_tsc",
    cst_ewma_tsc$1 = "ewma_tsc",
    cst_ewma_tsc_square$1 = "ewma_tsc_square",
    cst_float_fields$1 = "float_fields",
    cst_floats$1 = "floats",
    cst_monotonic_nanos_per_cycle$1 = "monotonic_nanos_per_cycle",
    cst_monotonic_sec_per_cycle$1 = "monotonic_sec_per_cycle",
    cst_monotonic_time$1 = "monotonic_time",
    cst_monotonic_time_nanos$1 = "monotonic_time_nanos",
    cst_monotonic_until_tsc$1 = "monotonic_until_tsc",
    cst_nanos_per_cycle$1 = "nanos_per_cycle",
    cst_sec_per_cycle$1 = "sec_per_cycle",
    cst_t$3 = "t",
    cst_time$1 = "time",
    cst_time_nanos$1 = "time_nanos",
    cst_time_stamp_counter$0 = "time_stamp_counter",
    cst_time_stamp_counter_src_tim$4 =
      "time_stamp_counter/src/time_stamp_counter.ml",
    cst_time_stamp_counter_src_tim$5 =
      "time_stamp_counter/src/time_stamp_counter.ml.Calibrator.t",
    cst_tsc$3 = "tsc",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    name = "time_stamp_counter/src/time_stamp_counter.ml.t",
    error_source_008 =
      "time_stamp_counter/src/time_stamp_counter.ml.Calibrator.float_fields",
    error_source_032 = cst_time_stamp_counter_src_tim$5,
    Core_Time_ns = global_data.Core__Time_ns,
    Core_Time_float = global_data.Core__Time_float,
    Base_Exn = global_data.Base__Exn,
    Core_Int63 = global_data.Core__Int63,
    Core_Float = global_data.Core__Float,
    Core = global_data.Core,
    Core_Core_sys = global_data.Core__Core_sys,
    Core_Int = global_data.Core__Int,
    Assert_failure = global_data.Assert_failure,
    Core_List = global_data.Core__List,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Bin_prot_Common = global_data.Bin_prot__Common,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename;
   caml_call1(Ppx_module_timer_runtime[4], cst_Time_stamp_counter$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_time_stamp_counter$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_time_stamp_counter_src_tim$4);
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_time_stamp_counter$0,
     "time_stamp_counter.ml");
   var
    _F_ = [0, "calibrator"],
    _E_ = [0, cst_time_stamp_counter_src_tim$4, 298, 4],
    _z_ = [0, cst_floats$1],
    _A_ = [0, cst_monotonic_time_nanos$1],
    _B_ = [0, cst_time_nanos$1],
    _C_ = [0, cst_monotonic_until_tsc$1],
    _D_ = [0, cst_tsc$3],
    cst_floats$0 = cst_floats$1,
    cst_monotonic_time_nanos$0 = cst_monotonic_time_nanos$1,
    cst_time_nanos$0 = cst_time_nanos$1,
    cst_monotonic_until_tsc$0 = cst_monotonic_until_tsc$1,
    cst_tsc$2 = cst_tsc$3,
    cst_time_stamp_counter_src_tim$3 = cst_time_stamp_counter_src_tim$5,
    _l_ = [0, cst_monotonic_nanos_per_cycle$1],
    _m_ = [0, cst_nanos_per_cycle$1],
    _n_ = [0, cst_ewma_tsc$1],
    _o_ = [0, cst_ewma_time$1],
    _p_ = [0, cst_ewma_tsc_square$1],
    _q_ = [0, cst_ewma_time_tsc$1],
    _r_ = [0, cst_monotonic_sec_per_cycle$1],
    _s_ = [0, cst_monotonic_time$1],
    _t_ = [0, cst_sec_per_cycle$1],
    _u_ = [0, cst_time$1],
    cst_monotonic_nanos_per_cycle$0 = cst_monotonic_nanos_per_cycle$1,
    cst_nanos_per_cycle$0 = cst_nanos_per_cycle$1,
    cst_ewma_tsc$0 = cst_ewma_tsc$1,
    cst_ewma_time$0 = cst_ewma_time$1,
    cst_ewma_tsc_square$0 = cst_ewma_tsc_square$1,
    cst_ewma_time_tsc$0 = cst_ewma_time_tsc$1,
    cst_monotonic_sec_per_cycle$0 = cst_monotonic_sec_per_cycle$1,
    cst_monotonic_time$0 = cst_monotonic_time$1,
    cst_sec_per_cycle$0 = cst_sec_per_cycle$1,
    cst_time$0 = cst_time$1,
    cst_t = cst_t$3,
    cst_time_stamp_counter_src_tim =
      "time_stamp_counter/src/time_stamp_counter.ml:85:0",
    cst_t$0 = cst_t$3,
    cst_tsc = cst_tsc$3,
    cst_time_stamp_counter_src_tim$0 =
      "time_stamp_counter/src/time_stamp_counter.ml:86:0",
    cst_tsc$0 = cst_tsc$3,
    cst_monotonic_nanos_per_cycle = cst_monotonic_nanos_per_cycle$1,
    cst_nanos_per_cycle = cst_nanos_per_cycle$1,
    cst_ewma_tsc = cst_ewma_tsc$1,
    cst_ewma_time = cst_ewma_time$1,
    cst_ewma_tsc_square = cst_ewma_tsc_square$1,
    cst_ewma_time_tsc = cst_ewma_time_tsc$1,
    cst_monotonic_sec_per_cycle = cst_monotonic_sec_per_cycle$1,
    cst_monotonic_time = cst_monotonic_time$1,
    cst_sec_per_cycle = cst_sec_per_cycle$1,
    cst_time = cst_time$1,
    cst_float_fields = cst_float_fields$1,
    cst_time_stamp_counter_src_tim$1 =
      "time_stamp_counter/src/time_stamp_counter.ml:115:2",
    cst_float_fields$0 = cst_float_fields$1,
    cst_floats = cst_floats$1,
    cst_monotonic_time_nanos = cst_monotonic_time_nanos$1,
    cst_time_nanos = cst_time_nanos$1,
    cst_monotonic_until_tsc = cst_monotonic_until_tsc$1,
    cst_tsc$1 = cst_tsc$3,
    cst_t$1 = cst_t$3,
    cst_time_stamp_counter_src_tim$2 =
      "time_stamp_counter/src/time_stamp_counter.ml:133:2",
    cst_t$2 = cst_t$3,
    cst_time_stamp_counter = cst_time_stamp_counter$0,
    cst_Time_stamp_counter = cst_Time_stamp_counter$0,
    max_percent_change_from_real_s = 0.2;
   function ewma(alpha, old, add){return (1. - alpha) * old + alpha * add;}
   var
    _a_ = Core_Int63[98],
    _b_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, _a_], 0],
    _c_ = caml_call1(Bin_shape[4][1], cst_time_stamp_counter_src_tim),
    group = caml_call2(Bin_prot_Shape[2], _c_, _b_),
    _d_ = caml_call1(Bin_shape[2][1], cst_t$0),
    bin_shape_t = caml_call1(caml_call2(Bin_prot_Shape[10], group, _d_), 0),
    bin_size_tsc = Core_Int63[94],
    bin_write_tsc = Core_Int63[95],
    bin_writer_t = [0, bin_size_tsc, bin_write_tsc],
    bin_read_t = Core_Int63[97],
    bin_read_tsc = Core_Int63[96],
    bin_reader_t = [0, bin_read_tsc, bin_read_t],
    bin_t = [0, bin_shape_t, bin_writer_t, bin_reader_t],
    tsc_of_sexp = Core_Int63[102],
    sexp_of_tsc = Core_Int63[103],
    Typename_of_t = caml_call1(Typerep_lib_Make_typename[1], [0, name]),
    typename_of_t = Typename_of_t[2],
    name_of_t = Typename_of_t[1],
    typerep_of_t = [9, [0, name_of_t, [0, Core_Int63[90]]]],
    _e_ = [0, [0, caml_call1(Bin_shape[2][1], cst_tsc), 0, bin_shape_t], 0],
    _f_ = caml_call1(Bin_shape[4][1], cst_time_stamp_counter_src_tim$0),
    group$0 = caml_call2(Bin_prot_Shape[2], _f_, _e_),
    _g_ = caml_call1(Bin_shape[2][1], cst_tsc$0),
    bin_shape_tsc =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$0, _g_), 0),
    max = Core_Int63[116],
    min = Core_Int63[115],
    compare = Core_Int63[114],
    equal = Core_Int63[113],
    symbol = Core_Int63[112],
    symbol$0 = Core_Int63[111],
    symbol$1 = Core_Int63[110],
    symbol$2 = Core_Int63[109],
    symbol$3 = Core_Int63[108],
    symbol$4 = Core_Int63[107];
   function diff(t1, t2){return caml_call2(Core_Int63[20], t1, t2);}
   function add(t, s){return caml_call2(Core_Int63[19], t, s);}
   function of_int63(t){return t;}
   function to_int63(t){return t;}
   var zero = Core_Int63[16];
   function now(param){
    var tsc64 = runtime.caml_rdtsc(0), _aU_ = Core_Core_sys[8];
    if(typeof _aU_ === "number" && ! _aU_)
     return caml_call1(Core_Int63[72], runtime.caml_int64_to_int32(tsc64));
    return caml_call1(Core_Int63[81], tsc64);
   }
   var
    _h_ =
      caml_call1
       (Bin_prot_Shape[4],
        [0,
         [0, cst_time, Core[350]],
         [0,
          [0, cst_sec_per_cycle, Core[350]],
          [0,
           [0, cst_monotonic_time, Core[350]],
           [0,
            [0, cst_monotonic_sec_per_cycle, Core[350]],
            [0,
             [0, cst_ewma_time_tsc, Core[350]],
             [0,
              [0, cst_ewma_tsc_square, Core[350]],
              [0,
               [0, cst_ewma_time, Core[350]],
               [0,
                [0, cst_ewma_tsc, Core[350]],
                [0,
                 [0, cst_nanos_per_cycle, Core[350]],
                 [0, [0, cst_monotonic_nanos_per_cycle, Core[350]], 0]]]]]]]]]]),
    _i_ = [0, [0, caml_call1(Bin_shape[2][1], cst_float_fields), 0, _h_], 0],
    _j_ = caml_call1(Bin_shape[4][1], cst_time_stamp_counter_src_tim$1),
    group$1 = caml_call2(Bin_prot_Shape[2], _j_, _i_),
    _k_ = caml_call1(Bin_shape[2][1], cst_float_fields$0),
    bin_shape_float_fields =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$1, _k_), 0);
   function float_fields_of_sexp(x_009){
    function _aJ_(param){
     var
      _aM_ = param[2],
      _aN_ = _aM_[2],
      _aO_ = _aN_[2],
      _aP_ = _aO_[2],
      _aQ_ = _aP_[2],
      _aR_ = _aQ_[2],
      _aS_ = _aR_[2],
      _aT_ = _aS_[2],
      monotonic_nanos_per_cycle = _aT_[2][1],
      nanos_per_cycle = _aT_[1],
      ewma_tsc = _aS_[1],
      ewma_time = _aR_[1],
      ewma_tsc_square = _aQ_[1],
      ewma_time_tsc = _aP_[1],
      monotonic_sec_per_cycle = _aO_[1],
      monotonic_time = _aN_[1],
      sec_per_cycle = _aM_[1],
      time = param[1];
     return [254,
             time,
             sec_per_cycle,
             monotonic_time,
             monotonic_sec_per_cycle,
             ewma_time_tsc,
             ewma_tsc_square,
             ewma_time,
             ewma_tsc,
             nanos_per_cycle,
             monotonic_nanos_per_cycle];
    }
    var _aK_ = 0;
    function _aL_(param){
     var
      switch$0 =
        runtime.caml_string_compare(param, cst_monotonic_sec_per_cycle$1);
     if(0 <= switch$0){
      if(0 >= switch$0) return 3;
      if(! caml_string_notequal(param, cst_monotonic_time$1)) return 2;
      if(! caml_string_notequal(param, cst_nanos_per_cycle$1)) return 8;
      if(! caml_string_notequal(param, cst_sec_per_cycle$1)) return 1;
      if(! caml_string_notequal(param, cst_time$1)) return 0;
     }
     else{
      if(! caml_string_notequal(param, cst_ewma_time$1)) return 6;
      if(! caml_string_notequal(param, cst_ewma_time_tsc$1)) return 4;
      if(! caml_string_notequal(param, cst_ewma_tsc$1)) return 7;
      if(! caml_string_notequal(param, cst_ewma_tsc_square$1)) return 5;
      if(! caml_string_notequal(param, cst_monotonic_nanos_per_cycle$1))
       return 9;
     }
     return -1;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_008,
             [0,
              cst_time$0,
              1,
              Core[368],
              [0,
               cst_sec_per_cycle$0,
               1,
               Core[368],
               [0,
                cst_monotonic_time$0,
                1,
                Core[368],
                [0,
                 cst_monotonic_sec_per_cycle$0,
                 1,
                 Core[368],
                 [0,
                  cst_ewma_time_tsc$0,
                  1,
                  Core[368],
                  [0,
                   cst_ewma_tsc_square$0,
                   1,
                   Core[368],
                   [0,
                    cst_ewma_time$0,
                    1,
                    Core[368],
                    [0,
                     cst_ewma_tsc$0,
                     1,
                     Core[368],
                     [0,
                      cst_nanos_per_cycle$0,
                      1,
                      Core[368],
                      [0, cst_monotonic_nanos_per_cycle$0, 1, Core[368], 0]]]]]]]]]],
             _aL_,
             _aK_,
             _aJ_,
             x_009);
   }
   var
    _v_ =
      caml_call1
       (Bin_prot_Shape[4],
        [0,
         [0, cst_tsc$1, bin_shape_tsc],
         [0,
          [0, cst_monotonic_until_tsc, bin_shape_tsc],
          [0,
           [0, cst_time_nanos, Core_Int63[98]],
           [0,
            [0, cst_monotonic_time_nanos, Core_Int63[98]],
            [0, [0, cst_floats, bin_shape_float_fields], 0]]]]]),
    _w_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$1), 0, _v_], 0],
    _x_ = caml_call1(Bin_shape[4][1], cst_time_stamp_counter_src_tim$2),
    group$2 = caml_call2(Bin_prot_Shape[2], _x_, _w_),
    _y_ = caml_call1(Bin_shape[2][1], cst_t$2),
    bin_shape_t$0 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$2, _y_), 0);
   function bin_size_t(param){
    var
     v1$0 = param[1],
     v2$0 = param[2],
     v3$0 = param[3],
     v4$0 = param[4],
     v5$0 = param[5],
     _aF_ = caml_call1(bin_size_tsc, v1$0),
     size$8 = caml_call2(Bin_prot_Common[23], 0, _aF_),
     _aG_ = caml_call1(bin_size_tsc, v2$0),
     size$9 = caml_call2(Bin_prot_Common[23], size$8, _aG_),
     _aH_ = caml_call1(Core_Int63[94], v3$0),
     size$10 = caml_call2(Bin_prot_Common[23], size$9, _aH_),
     _aI_ = caml_call1(Core_Int63[94], v4$0),
     size$11 = caml_call2(Bin_prot_Common[23], size$10, _aI_),
     v1 = v5$0[1],
     v2 = v5$0[2],
     v3 = v5$0[3],
     v4 = v5$0[4],
     v5 = v5$0[5],
     v6 = v5$0[6],
     v7 = v5$0[7],
     v8 = v5$0[8],
     v9 = v5$0[9],
     v10 = v5$0[10],
     _au_ = caml_call1(Core[351], v1),
     size = caml_call2(Bin_prot_Common[23], 0, _au_),
     _av_ = caml_call1(Core[351], v2),
     size$0 = caml_call2(Bin_prot_Common[23], size, _av_),
     _aw_ = caml_call1(Core[351], v3),
     size$1 = caml_call2(Bin_prot_Common[23], size$0, _aw_),
     _ax_ = caml_call1(Core[351], v4),
     size$2 = caml_call2(Bin_prot_Common[23], size$1, _ax_),
     _ay_ = caml_call1(Core[351], v5),
     size$3 = caml_call2(Bin_prot_Common[23], size$2, _ay_),
     _az_ = caml_call1(Core[351], v6),
     size$4 = caml_call2(Bin_prot_Common[23], size$3, _az_),
     _aA_ = caml_call1(Core[351], v7),
     size$5 = caml_call2(Bin_prot_Common[23], size$4, _aA_),
     _aB_ = caml_call1(Core[351], v8),
     size$6 = caml_call2(Bin_prot_Common[23], size$5, _aB_),
     _aC_ = caml_call1(Core[351], v9),
     size$7 = caml_call2(Bin_prot_Common[23], size$6, _aC_),
     _aD_ = caml_call1(Core[351], v10),
     _aE_ = caml_call2(Bin_prot_Common[23], size$7, _aD_);
    return caml_call2(Bin_prot_Common[23], size$11, _aE_);
   }
   function bin_write_t(buf, pos$8, param){
    var
     v1$0 = param[1],
     v2$0 = param[2],
     v3$0 = param[3],
     v4$0 = param[4],
     v5$0 = param[5],
     pos$9 = caml_call3(bin_write_tsc, buf, pos$8, v1$0),
     pos$10 = caml_call3(bin_write_tsc, buf, pos$9, v2$0),
     pos$11 = caml_call3(Core_Int63[95], buf, pos$10, v3$0),
     pos$12 = caml_call3(Core_Int63[95], buf, pos$11, v4$0),
     v1 = v5$0[1],
     v2 = v5$0[2],
     v3 = v5$0[3],
     v4 = v5$0[4],
     v5 = v5$0[5],
     v6 = v5$0[6],
     v7 = v5$0[7],
     v8 = v5$0[8],
     v9 = v5$0[9],
     v10 = v5$0[10],
     pos = caml_call3(Core[353], buf, pos$12, v1),
     pos$0 = caml_call3(Core[353], buf, pos, v2),
     pos$1 = caml_call3(Core[353], buf, pos$0, v3),
     pos$2 = caml_call3(Core[353], buf, pos$1, v4),
     pos$3 = caml_call3(Core[353], buf, pos$2, v5),
     pos$4 = caml_call3(Core[353], buf, pos$3, v6),
     pos$5 = caml_call3(Core[353], buf, pos$4, v7),
     pos$6 = caml_call3(Core[353], buf, pos$5, v8),
     pos$7 = caml_call3(Core[353], buf, pos$6, v9);
    return caml_call3(Core[353], buf, pos$7, v10);
   }
   var bin_writer_t$0 = [0, bin_size_t, bin_write_t];
   function bin_read_t$0(buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_time_stamp_counter_src_tim$3,
             pos_ref[1]);
   }
   function bin_read_t$1(buf, pos_ref){
    var
     v_tsc = caml_call2(bin_read_tsc, buf, pos_ref),
     v_monotonic_until_tsc = caml_call2(bin_read_tsc, buf, pos_ref),
     v_time_nanos = caml_call2(Core_Int63[96], buf, pos_ref),
     v_monotonic_time_nanos = caml_call2(Core_Int63[96], buf, pos_ref),
     v_time = caml_call2(Core[356], buf, pos_ref),
     v_sec_per_cycle = caml_call2(Core[356], buf, pos_ref),
     v_monotonic_time = caml_call2(Core[356], buf, pos_ref),
     v_monotonic_sec_per_cycle = caml_call2(Core[356], buf, pos_ref),
     v_ewma_time_tsc = caml_call2(Core[356], buf, pos_ref),
     v_ewma_tsc_square = caml_call2(Core[356], buf, pos_ref),
     v_ewma_time = caml_call2(Core[356], buf, pos_ref),
     v_ewma_tsc = caml_call2(Core[356], buf, pos_ref),
     v_nanos_per_cycle = caml_call2(Core[356], buf, pos_ref),
     v_monotonic_nanos_per_cycle = caml_call2(Core[356], buf, pos_ref),
     v_floats =
       [254,
        v_time,
        v_sec_per_cycle,
        v_monotonic_time,
        v_monotonic_sec_per_cycle,
        v_ewma_time_tsc,
        v_ewma_tsc_square,
        v_ewma_time,
        v_ewma_tsc,
        v_nanos_per_cycle,
        v_monotonic_nanos_per_cycle];
    return [0,
            v_tsc,
            v_monotonic_until_tsc,
            v_time_nanos,
            v_monotonic_time_nanos,
            v_floats];
   }
   var
    bin_reader_t$0 = [0, bin_read_t$1, bin_read_t$0],
    bin_t$0 = [0, bin_shape_t$0, bin_writer_t$0, bin_reader_t$0];
   function t_of_sexp(x_033){
    function _ao_(param){
     var
      _ar_ = param[2],
      _as_ = _ar_[2],
      _at_ = _as_[2],
      floats = _at_[2][1],
      monotonic_time_nanos = _at_[1],
      time_nanos = _as_[1],
      monotonic_until_tsc = _ar_[1],
      tsc = param[1];
     return [0,
             tsc,
             monotonic_until_tsc,
             time_nanos,
             monotonic_time_nanos,
             floats];
    }
    var _ap_ = 0;
    function _aq_(param){
     return caml_string_notequal(param, cst_floats$1)
             ? caml_string_notequal
                (param, cst_monotonic_time_nanos$1)
               ? caml_string_notequal
                  (param, cst_monotonic_until_tsc$1)
                 ? caml_string_notequal
                    (param, cst_time_nanos$1)
                   ? caml_string_notequal(param, cst_tsc$3) ? -1 : 0
                   : 2
                 : 1
               : 3
             : 4;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_032,
             [0,
              cst_tsc$2,
              1,
              tsc_of_sexp,
              [0,
               cst_monotonic_until_tsc$0,
               1,
               tsc_of_sexp,
               [0,
                cst_time_nanos$0,
                1,
                Core_Int63[102],
                [0,
                 cst_monotonic_time_nanos$0,
                 1,
                 Core_Int63[102],
                 [0, cst_floats$0, 1, float_fields_of_sexp, 0]]]]],
             _aq_,
             _ap_,
             _ao_,
             x_033);
   }
   function sexp_of_t(param){
    var
     tsc_035 = param[1],
     monotonic_until_tsc_037 = param[2],
     time_nanos_039 = param[3],
     monotonic_time_nanos_041 = param[4],
     floats_043 = param[5],
     time_011 = floats_043[1],
     sec_per_cycle_013 = floats_043[2],
     monotonic_time_015 = floats_043[3],
     monotonic_sec_per_cycle_017 = floats_043[4],
     ewma_time_tsc_019 = floats_043[5],
     ewma_tsc_square_021 = floats_043[6],
     ewma_time_023 = floats_043[7],
     ewma_tsc_025 = floats_043[8],
     nanos_per_cycle_027 = floats_043[9],
     monotonic_nanos_per_cycle_029 = floats_043[10],
     arg_030 = caml_call1(Core[367], monotonic_nanos_per_cycle_029),
     bnds_010 = [0, [1, [0, _l_, [0, arg_030, 0]]], 0],
     arg_028 = caml_call1(Core[367], nanos_per_cycle_027),
     bnds_010$0 = [0, [1, [0, _m_, [0, arg_028, 0]]], bnds_010],
     arg_026 = caml_call1(Core[367], ewma_tsc_025),
     bnds_010$1 = [0, [1, [0, _n_, [0, arg_026, 0]]], bnds_010$0],
     arg_024 = caml_call1(Core[367], ewma_time_023),
     bnds_010$2 = [0, [1, [0, _o_, [0, arg_024, 0]]], bnds_010$1],
     arg_022 = caml_call1(Core[367], ewma_tsc_square_021),
     bnds_010$3 = [0, [1, [0, _p_, [0, arg_022, 0]]], bnds_010$2],
     arg_020 = caml_call1(Core[367], ewma_time_tsc_019),
     bnds_010$4 = [0, [1, [0, _q_, [0, arg_020, 0]]], bnds_010$3],
     arg_018 = caml_call1(Core[367], monotonic_sec_per_cycle_017),
     bnds_010$5 = [0, [1, [0, _r_, [0, arg_018, 0]]], bnds_010$4],
     arg_016 = caml_call1(Core[367], monotonic_time_015),
     bnds_010$6 = [0, [1, [0, _s_, [0, arg_016, 0]]], bnds_010$5],
     arg_014 = caml_call1(Core[367], sec_per_cycle_013),
     bnds_010$7 = [0, [1, [0, _t_, [0, arg_014, 0]]], bnds_010$6],
     arg_012 = caml_call1(Core[367], time_011),
     bnds_010$8 = [0, [1, [0, _u_, [0, arg_012, 0]]], bnds_010$7],
     arg_044 = [1, bnds_010$8],
     bnds_034 = [0, [1, [0, _z_, [0, arg_044, 0]]], 0],
     arg_042 = caml_call1(Core_Int63[103], monotonic_time_nanos_041),
     bnds_034$0 = [0, [1, [0, _A_, [0, arg_042, 0]]], bnds_034],
     arg_040 = caml_call1(Core_Int63[103], time_nanos_039),
     bnds_034$1 = [0, [1, [0, _B_, [0, arg_040, 0]]], bnds_034$0],
     arg_038 = caml_call1(sexp_of_tsc, monotonic_until_tsc_037),
     bnds_034$2 = [0, [1, [0, _C_, [0, arg_038, 0]]], bnds_034$1],
     arg_036 = caml_call1(sexp_of_tsc, tsc_035),
     bnds_034$3 = [0, [1, [0, _D_, [0, arg_036, 0]]], bnds_034$2];
    return [1, bnds_034$3];
   }
   function convert(t, tsc, base, mul){
    var _an_ = diff(tsc, t[1]);
    return base + mul * caml_call1(Core_Int63[3], _an_);
   }
   function tsc_to_seconds_since_epoch(t, tsc){
    var
     _am_ =
       caml_call2(symbol$0, tsc, t[2])
        ? 0. + convert(t, tsc, t[5][3], t[5][4])
        : 0. + convert(t, tsc, t[5][1], t[5][2]);
    return 0. + _am_;
   }
   function convert$0(t, tsc, base, mul){
    var
     _aj_ = diff(tsc, t[1]),
     _ak_ = mul * caml_call1(Core_Int63[3], _aj_),
     _al_ = caml_call1(Core_Float[56], _ak_);
    return caml_call2(Core_Int63[19], base, _al_);
   }
   var initial_alpha = 1.;
   function calibrate_using(t, tsc, time, am_initializing){
    var
     estimated_time = 0. + tsc_to_seconds_since_epoch(t, tsc),
     time_diff_est = time - estimated_time,
     time_diff = time - t[5][1],
     _ac_ = diff(tsc, t[1]),
     tsc_diff = caml_call1(Core_Int63[3], _ac_),
     alpha =
       am_initializing
        ? initial_alpha
        : 0.
         + caml_call2(Core_Float[135], 0., 1. - Math.exp(-0.5 * time_diff));
    t[5][1] = time;
    t[1] = tsc;
    var _ad_ = ewma(alpha, t[5][5], tsc_diff * time_diff);
    t[5][5] = _ad_;
    var _ae_ = ewma(alpha, t[5][6], tsc_diff * tsc_diff);
    t[5][6] = _ae_;
    var _af_ = ewma(alpha, t[5][8], tsc_diff);
    t[5][8] = _af_;
    var _ag_ = ewma(alpha, t[5][7], time_diff);
    t[5][7] = _ag_;
    t[5][2] = t[5][5] / t[5][6];
    t[5][3] = estimated_time;
    if(1 - am_initializing){
     var
      catchup_sec_per_cycle = t[5][2] + time_diff_est / 1000000000.,
      _ah_ =
        caml_call1(Core_Float[6], time_diff_est)
         ? 0.
          + caml_call2(Core_Float[134], catchup_sec_per_cycle, t[5][2] * 1.2)
         : 0.
          + caml_call2(Core_Float[135], catchup_sec_per_cycle, t[5][2] * 0.8);
     t[5][4] = _ah_;
     var
      float$1 = time_diff_est / (t[5][4] - t[5][2]),
      if_iround_up_fails = Core_Int63[16];
     if(caml_call2(Core_Float[129], float$1, 0.)){
      var float$0 = Math.ceil(float$1);
      if(caml_call2(Core_Float[127], float$0, Core_Float[58]))
       var
        _aa_ = caml_call1(Core_Int63[60], float$0),
        _ai_ = caml_call2(Core_Int63[19], tsc, _aa_);
      else
       var _ai_ = if_iround_up_fails;
     }
     else if(caml_call2(Core_Float[126], float$1, Core_Float[57]))
      var
       _ab_ = caml_call1(Core_Int63[60], float$1),
       _ai_ = caml_call2(Core_Int63[19], tsc, _ab_);
     else
      var _ai_ = if_iround_up_fails;
     t[2] = _ai_;
    }
    t[3] = caml_call1(Core_Float[56], t[5][1] * 1000000000.);
    t[5][9] = t[5][2] * 1000000000.;
    t[4] = caml_call1(Core_Float[56], t[5][3] * 1000000000.);
    t[5][10] = t[5][4] * 1000000000.;
    return 0;
   }
   function now_float(param){
    var
     ___ = caml_call1(Core_Time_ns[66], 0),
     _$_ = caml_call1(Core_Time_ns[77], ___);
    return 1e-9 * caml_call1(Core_Int63[3], _$_);
   }
   function initialize(t, samples){
    function _Z_(param){
     var time = param[2], tsc = param[1];
     return calibrate_using(t, tsc, time, 1);
    }
    return caml_call2(Core_List[19], samples, _Z_);
   }
   function create_using(tsc, time, samples){
    var
     t =
       [0,
        tsc,
        Core_Int63[16],
        Core_Int63[16],
        Core_Int63[16],
        [254, time, 0., time, 0., 0., 0., 0., 0., 0., 0.]];
    initialize(t, samples);
    return t;
   }
   function create(param){
    var time = now_float(0), tsc = now(0), _X_ = Core_Core_sys[8];
    if(typeof _X_ === "number" && ! _X_){
     var interval = 0.0005, num_samples = 3;
     if(! caml_call2(Core_Int[81], 3, 1))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
     var
      loop =
        function(n, sleep){
         var _Y_ = now_float(0), sample = [0, now(0), _Y_];
         return caml_call2(Core_Int[83], n, 1)
                 ? [0, sample, 0]
                 : (runtime.tsc_nanosleep
                    (sleep),
                   [0, sample, loop(n - 1 | 0, sleep + 0.0005)]);
        },
      samples = loop(num_samples, interval);
     return create_using(tsc, time, samples);
    }
    var
     t =
       [0,
        tsc,
        Core_Int63[62],
        tsc,
        tsc,
        [254, time, 1e-9, time, 1e-9, 0., 0., 0., 0., 1., 1.]];
    return t;
   }
   var
    calibrator = [246, function(_W_){return create(0);}],
    cpu_mhz = [0, function(t){return 1. / (t[5][2] * 1000000.);}];
   function calibrate(t){
    var _V_ = now_float(0);
    return calibrate_using(t, now(0), _V_, 0);
   }
   function nanos_per_cycle(t){return t[5][9];}
   var
    Private = [0, create_using, calibrate_using, initialize, nanos_per_cycle],
    of_int_exn = Core_Int63[4],
    to_int_exn = Core_Int63[5],
    zero$0 = Core_Int63[16],
    symbol$5 = Core_Int63[19],
    symbol$6 = Core_Int63[20],
    bin_size_t$0 = Core_Int63[94],
    bin_write_t$0 = Core_Int63[95],
    bin_read_t$2 = Core_Int63[96],
    bin_read_t$3 = Core_Int63[97],
    bin_shape_t$1 = Core_Int63[98],
    bin_writer_t$1 = Core_Int63[99],
    bin_reader_t$1 = Core_Int63[100],
    bin_t$1 = Core_Int63[101],
    t_of_sexp$0 = Core_Int63[102],
    sexp_of_t$0 = Core_Int63[103],
    symbol$7 = Core_Int63[107],
    symbol$8 = Core_Int63[108],
    symbol$9 = Core_Int63[109],
    symbol$10 = Core_Int63[110],
    symbol$11 = Core_Int63[111],
    symbol$12 = Core_Int63[112],
    equal$0 = Core_Int63[113],
    compare$0 = Core_Int63[114],
    min$0 = Core_Int63[115],
    max$0 = Core_Int63[116],
    ascending = Core_Int63[117],
    descending = Core_Int63[118],
    between = Core_Int63[119],
    clamp_exn = Core_Int63[120],
    clamp = Core_Int63[121],
    Replace_polymorphic_compare = Core_Int63[122],
    comparator = Core_Int63[123],
    Map = Core_Int63[124],
    Set = Core_Int63[125],
    validate_lbound = Core_Int63[132],
    validate_ubound = Core_Int63[133],
    validate_bound = Core_Int63[134];
   function of_int63$0(t){return t;}
   function to_int63$0(t){return t;}
   var Private$0 = [0, of_int63$0, to_int63$0];
   function to_ns(t, calibrator){
    var _T_ = calibrator[5][9], _U_ = caml_call1(Core_Int63[3], t) * _T_;
    return caml_call1(Core_Float[56], _U_);
   }
   function of_ns(ns, calibrator){
    try{
     var
      _Q_ = calibrator[5][9],
      _R_ = caml_call1(Core_Int63[3], ns) / _Q_,
      _S_ = caml_call1(Core_Float[56], _R_);
     return _S_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _O_ = [0, [1, [0, _F_, [0, sexp_of_t(calibrator), 0]]], 0],
      _P_ = [1, [0, caml_call1(Base_Exn[1], exn), _O_]];
     return caml_call1(Core[261], _P_);
    }
   }
   function to_time_ns_span(t, calibrator){
    var _N_ = to_ns(t, calibrator);
    return caml_call1(Core_Time_ns[1][137], _N_);
   }
   function of_time_ns_span(span, calibrator){
    return of_ns(caml_call1(Core_Time_ns[1][136], span), calibrator);
   }
   function to_time(t, calibrator){
    var
     _L_ = tsc_to_seconds_since_epoch(calibrator, t),
     _M_ = caml_call1(Core_Time_float[84][82], _L_);
    return caml_call1(Core_Time_float[24], _M_);
   }
   function to_nanos_since_epoch(tsc, calibrator){
    return caml_call2(symbol$0, tsc, calibrator[2])
            ? convert$0(calibrator, tsc, calibrator[4], calibrator[5][10])
            : convert$0(calibrator, tsc, calibrator[3], calibrator[5][9]);
   }
   function to_time_ns(t, calibrator){
    var _K_ = to_nanos_since_epoch(t, calibrator);
    return caml_call1(Core_Time_ns[78], _K_);
   }
   var
    Private$1 =
      [0,
       ewma,
       of_int63,
       max_percent_change_from_real_s,
       to_nanos_since_epoch];
   caml_call1(Ppx_inline_test_lib[7], cst_time_stamp_counter);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Time_stamp_counter);
   var
    _G_ = Set[2],
    _H_ = Set[1],
    _I_ = Map[2],
    _J_ = Map[1],
    Time_stamp_counter =
      [0,
       bin_size_tsc,
       bin_write_tsc,
       bin_read_tsc,
       bin_read_t,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       tsc_of_sexp,
       sexp_of_tsc,
       typerep_of_t,
       typename_of_t,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$1,
       symbol$0,
       symbol,
       equal,
       compare,
       min,
       max,
       [0,
        bin_size_t,
        bin_write_t,
        bin_read_t$1,
        bin_read_t$0,
        bin_shape_t$0,
        bin_writer_t$0,
        bin_reader_t$0,
        bin_t$0,
        t_of_sexp,
        sexp_of_t,
        create,
        calibrate,
        cpu_mhz,
        Private],
       [0,
        bin_size_t$0,
        bin_write_t$0,
        bin_read_t$2,
        bin_read_t$3,
        bin_shape_t$1,
        bin_writer_t$1,
        bin_reader_t$1,
        bin_t$1,
        t_of_sexp$0,
        sexp_of_t$0,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        symbol$11,
        symbol$12,
        equal$0,
        compare$0,
        min$0,
        max$0,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        validate_lbound,
        validate_ubound,
        validate_bound,
        Replace_polymorphic_compare,
        [0,
         [0, _J_[9], _J_[10], _J_[11]],
         [0, _I_[9], _I_[10], _I_[11], _I_[12], _I_[13]],
         Map[3],
         Map[4],
         Map[5],
         Map[6],
         Map[7],
         Map[8],
         Map[9],
         Map[10],
         Map[11],
         Map[12],
         Map[13],
         Map[14],
         Map[15],
         Map[16],
         Map[17],
         Map[18],
         Map[19],
         Map[20],
         Map[21],
         Map[22],
         Map[23],
         Map[24],
         Map[25],
         Map[26],
         Map[27],
         Map[28],
         Map[29],
         Map[30],
         Map[31],
         Map[32],
         Map[33],
         Map[34],
         Map[35],
         Map[36],
         Map[37],
         Map[38],
         Map[39],
         Map[40],
         Map[41],
         Map[42],
         Map[43],
         Map[44],
         Map[45]],
        [0,
         [0, _H_[1], _H_[2], _H_[11]],
         [0, _G_[9], _G_[10], _G_[11], _G_[12], _G_[13]],
         Set[3],
         Set[4],
         Set[5],
         Set[6],
         Set[7],
         Set[8],
         Set[9],
         Set[10],
         Set[11],
         Set[12],
         Set[13],
         Set[14],
         Set[15],
         Set[16],
         Set[17],
         Set[18],
         Set[19],
         Set[20],
         Set[21],
         Set[22],
         Set[23],
         Set[24],
         Set[25],
         Set[26],
         Set[27],
         Set[28]],
        of_int_exn,
        to_int_exn,
        symbol$5,
        symbol$6,
        zero$0,
        to_ns,
        of_ns,
        to_time_ns_span,
        of_time_ns_span,
        Private$0],
       now,
       diff,
       add,
       to_int63,
       zero,
       calibrator,
       to_time,
       to_time_ns,
       Private$1];
   runtime.caml_register_global
    (150, Time_stamp_counter, cst_Time_stamp_counter$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aW1lX3N0YW1wX2NvdW50ZXIuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIm5hbWUiLCJlcnJvcl9zb3VyY2VfMDA4IiwiZXJyb3Jfc291cmNlXzAzMiIsIm1heF9wZXJjZW50X2NoYW5nZV9mcm9tX3JlYWxfcyIsImV3bWEiLCJhbHBoYSIsIm9sZCIsImFkZCIsImdyb3VwIiwiYmluX3NoYXBlX3QiLCJiaW5fc2l6ZV90c2MiLCJiaW5fd3JpdGVfdHNjIiwiYmluX3dyaXRlcl90IiwiYmluX3JlYWRfdCIsImJpbl9yZWFkX3RzYyIsImJpbl9yZWFkZXJfdCIsImJpbl90IiwidHNjX29mX3NleHAiLCJzZXhwX29mX3RzYyIsInR5cGVuYW1lX29mX3QiLCJuYW1lX29mX3QiLCJ0eXBlcmVwX29mX3QiLCJncm91cCQwIiwiYmluX3NoYXBlX3RzYyIsIm1heCIsIm1pbiIsImNvbXBhcmUiLCJlcXVhbCIsInN5bWJvbCIsInN5bWJvbCQwIiwic3ltYm9sJDEiLCJzeW1ib2wkMiIsInN5bWJvbCQzIiwic3ltYm9sJDQiLCJkaWZmIiwidDEiLCJ0MiIsInQiLCJzIiwib2ZfaW50NjMiLCJ0b19pbnQ2MyIsInplcm8iLCJub3ciLCJ0c2M2NCIsImdyb3VwJDEiLCJiaW5fc2hhcGVfZmxvYXRfZmllbGRzIiwiZmxvYXRfZmllbGRzX29mX3NleHAiLCJ4XzAwOSIsIm1vbm90b25pY19uYW5vc19wZXJfY3ljbGUiLCJuYW5vc19wZXJfY3ljbGUiLCJld21hX3RzYyIsImV3bWFfdGltZSIsImV3bWFfdHNjX3NxdWFyZSIsImV3bWFfdGltZV90c2MiLCJtb25vdG9uaWNfc2VjX3Blcl9jeWNsZSIsIm1vbm90b25pY190aW1lIiwic2VjX3Blcl9jeWNsZSIsInRpbWUiLCJncm91cCQyIiwiYmluX3NoYXBlX3QkMCIsImJpbl9zaXplX3QiLCJ2MSQwIiwidjIkMCIsInYzJDAiLCJ2NCQwIiwidjUkMCIsInNpemUkOCIsInNpemUkOSIsInNpemUkMTAiLCJzaXplJDExIiwidjEiLCJ2MiIsInYzIiwidjQiLCJ2NSIsInY2IiwidjciLCJ2OCIsInY5IiwidjEwIiwic2l6ZSIsInNpemUkMCIsInNpemUkMSIsInNpemUkMiIsInNpemUkMyIsInNpemUkNCIsInNpemUkNSIsInNpemUkNiIsInNpemUkNyIsImJpbl93cml0ZV90IiwiYnVmIiwicG9zJDgiLCJwb3MkOSIsInBvcyQxMCIsInBvcyQxMSIsInBvcyQxMiIsInBvcyIsInBvcyQwIiwicG9zJDEiLCJwb3MkMiIsInBvcyQzIiwicG9zJDQiLCJwb3MkNSIsInBvcyQ2IiwicG9zJDciLCJiaW5fd3JpdGVyX3QkMCIsImJpbl9yZWFkX3QkMCIsInBvc19yZWYiLCJ2aW50IiwiYmluX3JlYWRfdCQxIiwidl90c2MiLCJ2X21vbm90b25pY191bnRpbF90c2MiLCJ2X3RpbWVfbmFub3MiLCJ2X21vbm90b25pY190aW1lX25hbm9zIiwidl90aW1lIiwidl9zZWNfcGVyX2N5Y2xlIiwidl9tb25vdG9uaWNfdGltZSIsInZfbW9ub3RvbmljX3NlY19wZXJfY3ljbGUiLCJ2X2V3bWFfdGltZV90c2MiLCJ2X2V3bWFfdHNjX3NxdWFyZSIsInZfZXdtYV90aW1lIiwidl9ld21hX3RzYyIsInZfbmFub3NfcGVyX2N5Y2xlIiwidl9tb25vdG9uaWNfbmFub3NfcGVyX2N5Y2xlIiwidl9mbG9hdHMiLCJiaW5fcmVhZGVyX3QkMCIsImJpbl90JDAiLCJ0X29mX3NleHAiLCJ4XzAzMyIsImZsb2F0cyIsIm1vbm90b25pY190aW1lX25hbm9zIiwidGltZV9uYW5vcyIsIm1vbm90b25pY191bnRpbF90c2MiLCJ0c2MiLCJzZXhwX29mX3QiLCJ0c2NfMDM1IiwibW9ub3RvbmljX3VudGlsX3RzY18wMzciLCJ0aW1lX25hbm9zXzAzOSIsIm1vbm90b25pY190aW1lX25hbm9zXzA0MSIsImZsb2F0c18wNDMiLCJ0aW1lXzAxMSIsInNlY19wZXJfY3ljbGVfMDEzIiwibW9ub3RvbmljX3RpbWVfMDE1IiwibW9ub3RvbmljX3NlY19wZXJfY3ljbGVfMDE3IiwiZXdtYV90aW1lX3RzY18wMTkiLCJld21hX3RzY19zcXVhcmVfMDIxIiwiZXdtYV90aW1lXzAyMyIsImV3bWFfdHNjXzAyNSIsIm5hbm9zX3Blcl9jeWNsZV8wMjciLCJtb25vdG9uaWNfbmFub3NfcGVyX2N5Y2xlXzAyOSIsImFyZ18wMzAiLCJibmRzXzAxMCIsImFyZ18wMjgiLCJibmRzXzAxMCQwIiwiYXJnXzAyNiIsImJuZHNfMDEwJDEiLCJhcmdfMDI0IiwiYm5kc18wMTAkMiIsImFyZ18wMjIiLCJibmRzXzAxMCQzIiwiYXJnXzAyMCIsImJuZHNfMDEwJDQiLCJhcmdfMDE4IiwiYm5kc18wMTAkNSIsImFyZ18wMTYiLCJibmRzXzAxMCQ2IiwiYXJnXzAxNCIsImJuZHNfMDEwJDciLCJhcmdfMDEyIiwiYm5kc18wMTAkOCIsImFyZ18wNDQiLCJibmRzXzAzNCIsImFyZ18wNDIiLCJibmRzXzAzNCQwIiwiYXJnXzA0MCIsImJuZHNfMDM0JDEiLCJhcmdfMDM4IiwiYm5kc18wMzQkMiIsImFyZ18wMzYiLCJibmRzXzAzNCQzIiwiY29udmVydCIsImJhc2UiLCJtdWwiLCJ0c2NfdG9fc2Vjb25kc19zaW5jZV9lcG9jaCIsImNvbnZlcnQkMCIsImluaXRpYWxfYWxwaGEiLCJjYWxpYnJhdGVfdXNpbmciLCJhbV9pbml0aWFsaXppbmciLCJlc3RpbWF0ZWRfdGltZSIsInRpbWVfZGlmZl9lc3QiLCJ0aW1lX2RpZmYiLCJ0c2NfZGlmZiIsImNhdGNodXBfc2VjX3Blcl9jeWNsZSIsImZsb2F0JDEiLCJpZl9pcm91bmRfdXBfZmFpbHMiLCJmbG9hdCQwIiwibm93X2Zsb2F0IiwiaW5pdGlhbGl6ZSIsInNhbXBsZXMiLCJjcmVhdGVfdXNpbmciLCJjcmVhdGUiLCJpbnRlcnZhbCIsIm51bV9zYW1wbGVzIiwibG9vcCIsIm4iLCJzbGVlcCIsInNhbXBsZSIsImNhbGlicmF0b3IiLCJjcHVfbWh6IiwiY2FsaWJyYXRlIiwib2ZfaW50NjMkMCIsInRvX2ludDYzJDAiLCJ0b19ucyIsIm9mX25zIiwibnMiLCJleG4kMCIsImV4biIsInRvX3RpbWVfbnNfc3BhbiIsIm9mX3RpbWVfbnNfc3BhbiIsInNwYW4iLCJ0b190aW1lIiwidG9fbmFub3Nfc2luY2VfZXBvY2giLCJ0b190aW1lX25zIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY29yZV91bml4L3RpbWVfc3RhbXBfY291bnRlci90aW1lX3N0YW1wX2NvdW50ZXJfXy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NvcmVfdW5peC90aW1lX3N0YW1wX2NvdW50ZXIvdGltZV9zdGFtcF9jb3VudGVyLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0dBSzhCOztJQUFBOzs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDK0U5QkE7SUE4QkVDOztJQWtCQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBekRFQztZQU9BQyxLQUFNQyxPQUFPQyxLQUFLQyxLQUFNLGFBQWxCRixTQUFPQyxNQUFQRCxRQUFZRSxJQUE4QztHQUVwRTs7SUFBQSxjQUFLO0lBQUwsTUFBQTtJQUFBQyxRQUFBO0lBQUEsTUFBQTtJQUFLQyxjQUFMLFdBQUEsK0JBQUFEO0lBQ0FFO0lBQUFDO0lBREFDLG1CQUNBRixjQUFBQztJQURBRTtJQUNBQztJQURBQyxtQkFDQUQsY0FEQUQ7SUFBQUcsWUFBS1AsYUFBTEcsY0FBQUc7SUFDQUU7SUFBQUM7aUVBREFsQjtJQUFBbUI7SUFBQUM7SUFBQUMsdUJBQUFEO0lBQ0EsY0FBSyx5Q0FEQVg7SUFDTCxNQUFBO0lBQUFhLFVBQUE7SUFBQSxNQUFB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QXFCO1lBQzlFVyxnQkFBZ0JDLE1BQU1aO0lBQWEsT0FsQm5DTSxNQWtCeUMsaUNBQXpCTSxPQUFNWjtHQUE4RDtZQUt0RmEsUUFBUXZMLEdBQUcwSztJQUNiO0tBQUEsTUFyVUl4QiwyQkFvVVN3QixZQUFIMUs7S0FDVixNQUFBO0lBQUEsT0FBQTtHQUVpQztZQUd0QndMLHFCQUFxQnhGLEtBQUcwRTtJQUNuQyxPQS9TTyxXQW5GUWxMLFVBaVlpQndHLEtBQUcwRTtjQXRUcEJ2QixVQXNUb0J1QixZQUFIMUUsS0FBRzBFLGVBQUFBO2NBdFRwQnZCLFVBc1RvQnVCLFlBQUgxRSxLQUFHMEUsZUFBQUE7R0FDYTtZQUdyQ2UsV0FBV3pMLEdBQUcwSztJQUNPLFVBTHJCYyxxQkFJV3hMLEdBQUcwSztJQUNPLE9BQUE7R0FBb0M7R0FHckQ7OztPQTlZYjNNO09BU0FtQztPQWhCQXBDO09BNllTME47Ozs7Ozs7Ozs7OztPQW5ZYm5OO09BQUFDO09BQUFHO09BREFEO09BQUtKO09BQUxHO09BQUFHO09BQUFDO09BQ0FDO09BQUFDO09BREFHO09BQUFGO09BR2lCYztPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDs7UUE2Q2ZvQztRQUFBNkI7UUFBQW9CO1FBQUFIO1FBQUsvQztRQUFMOEM7UUFBQW9CO1FBQUFDO1FBQUFDO1FBQUFPO1FBaU9Ja0U7UUFvQk9TO1FBTlBEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQStEQUk7UUFTQUM7UUFpQkFJO1FBQ0FDOztPQXhXT2hMO09BWlRSO09BQ0EzQjtPQUVBaUM7T0FDQUM7T0FtWEFzSztPQUVBYTtPQVVTRTs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIFRpbWVfc3RhbXBfY291bnRlci5JbXBvcnQgKilcbm1vZHVsZSBJbXBvcnQgPSBUaW1lX3N0YW1wX2NvdW50ZXJfX0ltcG9ydFxuXG5tb2R1bGUgVGltZV9zdGFtcF9jb3VudGVyX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsIigqIFRpbWUgc3RhbXAgY291bnRlclxuICAgPT09PT09PT09PT09PT09PT09XG5cbiAgIFRoaXMgbW9kdWxlIHRyaWVzIHRvIGVzdGltYXRlIHRpbWUgYmFzZWQgb24gdGhlIENQVSB0aW1lIHN0YW1wIGNvdW50ZXIgKFRTQykuICBUaGUgdGltZVxuICAgZXN0aW1hdGVzIHJlcG9ydGVkIGJ5IHRoaXMgbW9kdWxlIGFyZSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuICBJdCB1c2VzIFtUaW1lLm5vdyAoKV1cbiAgIGFzIGl0cyBtZWFzdXJlIG9mIFwicmVhbCB0aW1lXCIgdG8gZG8gdGhpcy5cblxuICAgSGlzdG9yaWNhbGx5LCB0aGUgcmF0ZSBvZiBpbmNyZW1lbnQgb2YgdGhlIFRTQyAoc29tZXRpbWVzIHJlZmVycmVkIHRvIGFzIHRoZSBUU0NcbiAgIGZyZXF1ZW5jeSkgdmFyaWVkIGJhc2VkIG9mIENQVSBvdmVyY2xvY2tpbmcsIHRlbXBlcmF0dXJlLCBsb2FkIGV0Yy4gIE9uIG1vZGVybiBJbnRlbFxuICAgQ1BVJ3MgdGhlIFRTQyBpcyBleHBlY3RlZCB0byBiZSBzdGFibGUuICBPbiBMaW51eCBzeXN0ZW1zLCB0aGUgXCJjb25zdGFudF90c2NcIiBpblxuICAgL3Byb2MvY3B1aW5mbyBpbmRpY2F0ZXMgdGhhdCB0aGUgbWFjaGluZSBoYXMgYSBzdGFibGUgVFNDIHJhdGUuICBXaGlsZSB0aGlzIG1vZHVsZVxuICAgYXNzdW1lcyB0aGF0IHRoZSBUU0MgaXMgcmVsYXRpdmVseSBzdGFibGUsIGl0IGNhbiBhZGFwdCB0byBzbWFsbCB2YXJpYXRpb25zIGluIHRoZSBUU0NcbiAgIGZyZXF1ZW5jeS5cblxuICAgU2ltcGxlIE92ZXJ2aWV3XG4gICA9PT09PT09PT09PT09PT1cbiAgIEhlcmUgaXMgYW4gZXhwbGFuYXRpb24gb2YgaG93IHRoaXMgbW9kdWxlIHdvcmtzLiAgVGhlIG1vZHVsZSBtZWFzdXJlcyB0aGUgY2hhbmdlIGluXG4gICByZWFsIHRpbWUgYW5kIHRoZSBjaGFuZ2UgaW4gVFNDIGF0IGV2ZXJ5IGNhbGlicmF0aW9uIGNhbGwgYW5kIG1haW50YWlucyBhbiBFV01BIG9mXG4gICB0aGVzZSBkZWx0YXMuICBJdCB0aGVuIHVzZXMgdGhlIEVXTUEgdmFsdWVzIHRvIGRvIGxpbmVhciByZWdyZXNzaW9uIHdoZXJlIHRpbWUgaXMgdGhlXG4gICBlc3RpbWF0ZWQgdmFsdWUgYW5kIFRTQyBpcyB0aGUgcHJlZGljdG9yLiAgVGhlIGxpbmVhciByZWdyZXNzaW9uIGRvbmUgYXQgZXZlcnlcbiAgIGNhbGlicmF0aW9uIHN0ZXAgcHJvZHVjZXMgYW4gdXBkYXRlZCB0aW1lL3RzYyBzbG9wZS4gIFVzaW5nIHRoaXMgdGltZS90c2Mgc2xvcGUgYW5kXG4gICB0aGUgbGF0ZXN0IHZhbHVlIG9mIHJlYWwgdGltZSwgdGhlIG1vZHVsZSBlc3RpbWF0ZXMgdGltZSBpbiB0ZXJtcyBvZiB0c2MuXG5cbiAgIEVuc3VyaW5nIE1vbm90b25pY2l0eSBvZiBUaW1lXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgVGhlIHNpbXBsZSBwaWN0dXJlIGFib3ZlIGlzIGNvbXBsaWNhdGVkIGJ5IHRoZSBwcmVzZW5jZSBvZiBub2lzZS4gIFRoZXJlIGFyZSB0d29cbiAgIHNpZ25pZmljYW50IHNvdXJjZXMgb2Ygbm9pc2UuICBUaGUgZmlyc3QgaXMgdGhlIG5vaXNlIGNhdXNlZCBieSB2YXJpYXRpb25zIGluIHRoZVxuICAgZnJlcXVlbmN5IG9mIFRTQy4gIFRoZSBzZWNvbmQsIGFuZCBwcm9iYWJseSB0aGUgbW9yZSBzaWduaWZpY2FudCBvbmUsIGlzIG5vaXNlIGluIHJlYWxcbiAgIHRpbWUsIGkuZS4gbm9pc2UgaW4gdGhlIFtUaW1lLm5vdyAoKV0gY2FsbC5cblxuICAgKDEpIFtUaW1lLm5vdyAoKV0gY2FsbHMgc3VmZmVyIGZyb20gdGhlIG92ZXJoZWFkIG9mIHRyYW5zaXRpb24gZnJvbSB0aGUgdXNlciBwcm9ncmFtIHRvXG4gICBhIGtlcm5lbCB2ZHNvIGFuZFxuXG4gICAoMikgSXQgaXMgYWZmZWN0ZWQgYnkgTlRQIHVwZGF0ZXMuXG5cbiAgICgzKSBBbm90aGVyIHNpZ25pZmljYW50IHNvdXJjZSBvZiBlcnJvciBjb21lcyBmcm9tIGxvc3Mgb2YgcHJlY2lzaW9uLiAgW1RpbWUubm93XVxuICAgcmVwb3J0cyBhIDY0LWJpdCBmbG9hdCBvZiB3aGljaCBpdCBoYXMgNTIgYml0cyBvZiBtYW50aXNzYS4gIFRoZSA1MiBiaXRzIG9mIG1hbnRpc3NhXG4gICBmb3IgdGltZSBpbiBzZWNvbmRzIGZyb20gVW5peCBlcG9jaCBvbmx5IGFsbG93cyBmb3IgcHJlY2lzaW9uIGluIHRoZSBvcmRlciBvZlxuICAgbWljcm8tc2Vjb25kcy4gIENvbnNlcXVlbnRseSB0aGUgbWVhc3VyZW1lbnQgb2YgdGltZSB1c2luZyBbVGltZS5ub3ddIGNhbiBvbmx5IGJlXG4gICBwcmVjaXNlIGluIHRoZSBvcmRlciBvZiBtaWNyby1zZWNvbmRzLlxuXG4gICBOb2lzZSBpbiBtZWFzdXJpbmcgcmVhbCB0aW1lIGFuZCBpbiB0aGUgcmF0ZSBvZiB0aW1lL3RzYyBpbXBsaWVzIHRoYXQgYXQgZWFjaFxuICAgY2FsaWJyYXRpb24gcG9pbnQgdGhlIGVzdGltYXRlZCB0aW1lIFwianVtcHNcIiB1cCBvciBkb3duIHdpdGggcmVzcGVjdCB0byB0aGUgZXN0aW1hdGVcbiAgIHZhbHVlIG9mIHRpbWUgYmVmb3JlIGNhbGlicmF0aW9uLiAgSW4gb3RoZXIgd29yZHMsIHRoZSB0aW1lIGVzdGltYXRlZCB1c2luZyB0aGUgRVdNQVxuICAgbGluZWFyIHJlZ3Jlc3Npb24gaXMgbm90IHN0cmljdGx5IG1vbm90b25pYy5cblxuICAgV2UgcmVwb3J0IGEgbW9ub3RvbmljIHRpbWUgaW4gdGVybXMgb2YgdGhlIGVzdGltYXRlZCB0aW1lLCBieSBtYWludGFpbmluZyBhIHNlcGFyYXRlXG4gICBzbG9wZSBjYWxsZWQgdGhlIFwibW9ub3RvbmljIHRpbWUvVFNDIHNsb3BlXCIuICBBdCBldmVyeSBjYWxpYnJhdGlvbiBwb2ludCwgd2UgdGFrZSB0aGVcbiAgIGxhc3QgZXN0aW1hdGVkIHRpbWUgYW5kIGFkanVzdCB0aGUgbW9ub3RvbmljIHRpbWUvVFNDIHNsb3BlIHN1Y2ggdGhhdCBpdCBjYXRjaGVzIHVwIHRvXG4gICB0aGUgZXN0aW1hdGVkIHRpbWUgaW4gYSBmaXhlZCBudW1iZXIgb2YgY3ljbGVzLiAgSWYgdGhlIGV4cGVjdGVkIGNoYW5nZSBpbiBzbG9wZSBpcyB0b29cbiAgIGhpZ2gsIHdlIGJvdW5kIHRoZSByYXRlIG9mIGNoYW5nZSBvZiB0aGUgbW9ub3RvbmljIHRpbWUvVFNDIHNsb3BlLiAgQXMgbG9uZyBhc1xuICAgbW9ub3RvbmljIHRpbWUgaGFzIG5vdCBjYXVnaHQgdXAgd2l0aCB0aGUgZXN0aW1hdGVkIHRpbWUgd2UgcmVwb3J0IHRpbWUgaW4gdGVybXMgb2YgdGhlXG4gICBhZGp1c3RlZCBtb25vdG9uaWMgdGltZSBzbG9wZS4gIE9uY2Ugd2UgaGF2ZSBjYXVnaHQgdXAgdG8gdGhlIGVzdGltYXRlZCB0aW1lLCB3ZSBzdGFydFxuICAgcmVwb3J0aW5nIHRoZSBlc3RpbWF0ZWQgdGltZS5cblxuICAgV2UgY2FuIGNob3NlIHRoZSBudW1iZXIgb2YgY3ljbGVzIHRvIGFsbG93IGZvciBjYXRjaHVwIHRvIGJlIGFueSBudW1iZXIgd2Ugd2lzaC4gIEFcbiAgIG51bWJlciBpbiB0aGUgb3JkZXIgb2YgMUU2LTFFOSBUU0Mgc3RlcHMgYWxsb3dzIGZvciBhIGdyYWR1YWwgY2F0Y2h1cCByYXRlIHdpdGhvdXQgdG9vXG4gICBtYW55IGFicnVwdCBjaGFuZ2VzIGluIHRoZSByYXRlIG9mIHJlcG9ydGVkIHRpbWUuICBUaGUgYm91bmQgdG8gcmF0ZSBvZiBjaGFuZ2UgaXNcbiAgIGV4cHJlc3NlZCBpbiBwZXJjZW50YWdlIHRlcm1zIG9mIHNsb3BlIGFuZCBpcyBhdCBtYXggdGhlIHJhdGlvIGJ5IHdoaWNoIHdlIGV4cGVjdCB0aGVcbiAgIHVuZGVybHlpbmcgVFNDIGZyZXF1ZW5jeSB0byBjaGFuZ2Ugb24gdGhlIG1hY2hpbmUuICBJdCBpcyBkZWZpbmVkIGFzXG4gICBbbWF4X3BlcmNfY2hhbmdlX2Zyb21fcmVhbF9zbG9wZV0gYmVsb3cuXG5cbiAgIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHRoZSBhcHByb3hpbWF0aW9uIG9mIHRoZSBtb25vdG9uaWMgc2xvcGUgdHJ5aW5nIHRvIGNhdGNoIHVwXG4gICB3aXRoIHRoZSBlc3RpbWF0ZSBzbG9wZSBjYW4gYmUgYWNoaWV2ZWQgaW4gbWFueSBvdGhlciB3YXlzLiAgQSBtb3JlIHByaW5jaXBsZWQgYXBwcm9hY2hcbiAgIHRvIHRoaXMgd291bGQgYmUgdG8gdXNlIGEgUElEIGNvbnRyb2xsZXIgdGhhdCBhZGFwdHMgdG8gZXJyb3IgYW5kIGdldHMgdGhlIHJlcG9ydGVkXG4gICBtb25vdG9uaWMgdGltZSB0byBzbW9vdGhseSBmaXQgdGhlIGVzdGltYXRlZCB0aW1lLiAgSG93ZXZlciBQSUQgY29udHJvbGxlcnMgYXJlXG4gICBjb21wdXRhdGlvbmFsbHkgbW9yZSBleHBlbnNpdmUgYW5kIHdlIHVzZSBhIHNpbXBsZXIgbGluZWFyIGFwcHJveGltYXRpb24uXG4qKVxuXG5bJSVpbXBvcnQgXCJjb25maWcuaFwiXVxuXG5vcGVuISBDb3JlXG5vcGVuIFBvbHlcbm9wZW4hIEltcG9ydFxuXG5sZXQgbWF4X3BlcmNlbnRfY2hhbmdlX2Zyb21fcmVhbF9zbG9wZSA9IDAuMjBcblxubGV0ICgpID1cbiAgYXNzZXJ0ICgwLiA8PSBtYXhfcGVyY2VudF9jaGFuZ2VfZnJvbV9yZWFsX3Nsb3BlKTtcbiAgYXNzZXJ0IChtYXhfcGVyY2VudF9jaGFuZ2VfZnJvbV9yZWFsX3Nsb3BlIDw9IDEuKVxuOztcblxubGV0IGV3bWEgfmFscGhhIH5vbGQgfmFkZCA9ICgoMS4gLS4gYWxwaGEpICouIG9sZCkgKy4gKGFscGhhICouIGFkZClcblxudHlwZSB0ID0gSW50NjMudCBbQEBkZXJpdmluZyBiaW5faW8sIGNvbXBhcmUsIHNleHAsIHR5cGVyZXBdXG50eXBlIHRzYyA9IHQgW0BAZGVyaXZpbmcgYmluX2lvLCBjb21wYXJlLCBzZXhwXVxuXG5pbmNsdWRlIChJbnQ2MyA6IENvbXBhcmlzb25zLlMgd2l0aCB0eXBlIHQgOj0gdClcblxubGV0IGRpZmYgdDEgdDIgPSBJbnQ2My4oIC0gKSB0MSB0MlxubGV0IGFkZCB0IHMgPSBJbnQ2My4oICsgKSB0IHNcbmxldCBvZl9pbnQ2MyB0ID0gdFxubGV0IHRvX2ludDYzIHQgPSB0XG5sZXQgemVybyA9IEludDYzLnplcm9cblxuWyUlaWZkZWYgSlNDX0FSQ0hfU0lYVFlGT1VSXVxuXG5leHRlcm5hbCByZHRzYyA6IHVuaXQgLT4gKGludDY0W0B1bmJveGVkXSkgPSBcImNhbWxfcmR0c2NcIiBcImNhbWxfcmR0c2NfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdIFtAQGJ1aWx0aW5dXG5cbigqIG5vYWxsb2Mgb24geDg2XzY0IG9ubHkgKilcbmxldFtAaW5saW5lXSBub3cgKCkgPVxuICBsZXQgdHNjNjQgPSByZHRzYyAoKSBpblxuICAoKiBNYXRjaGluZyBvbiBTeXMuYmFja2VuZF90eXBlIGlzIGd1YXJhbnRlZWQgdG8gYmUgb3B0aW1pemVkIG91dC4gKilcbiAgbWF0Y2ggU3lzLmJhY2tlbmRfdHlwZSB3aXRoXG4gIHwgTmF0aXZlIC0+IHRzYzY0IHw+IFN0ZGxpYi5JbnQ2NC50b19pbnQgfD4gSW50NjMub2ZfaW50XG4gIHwgQnl0ZWNvZGUgfCBPdGhlciBfIC0+IHRzYzY0IHw+IEludDYzLm9mX2ludDY0X3RydW5jXG47O1xuXG5leHRlcm5hbCBuYW5vc2xlZXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwidHNjX25hbm9zbGVlcFwiXG5cbm1vZHVsZSBDYWxpYnJhdG9yID0gc3RydWN0XG4gICgqIHBlcmZvcm1hbmNlIGhhY2s6IHByZXZlbnQgd3JpdGVzIHRvIHRoaXMgcmVjb3JkIGZyb20gYm94aW5nIGZsb2F0cyBieSBtYWtpbmcgYWxsXG4gICAgIGZpZWxkcyBtdXRhYmxlIGZsb2F0cyAqKVxuICB0eXBlIGZsb2F0X2ZpZWxkcyA9XG4gICAgeyAoKiB0aGUgbW9zdCByZWNlbnQgb2JzZXJ2YXRpb25zIGFuZCByZWdyZXNzaW9uIHJlc3VsdHMgKilcbiAgICAgIG11dGFibGUgdGltZSA6IGZsb2F0XG4gICAgOyBtdXRhYmxlIHNlY19wZXJfY3ljbGUgOiBmbG9hdFxuICAgICAgICAoKiBtdXRhYmxlIHNlY19lcnJvcl9pbnRlcmNlcHQgICAgICA6IGZsb2F0OyAqKVxuXG4gICAgICAgICgqIHRoaXMgdGltZSB2YWx1ZSBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgKilcbiAgICA7IG11dGFibGUgbW9ub3RvbmljX3RpbWUgOiBmbG9hdFxuICAgIDsgbXV0YWJsZSBtb25vdG9uaWNfc2VjX3Blcl9jeWNsZSA6IGZsb2F0ICgqIGZvciBsaW5lYXIgcmVncmVzc2lvbiAqKVxuICAgIDsgbXV0YWJsZSBld21hX3RpbWVfdHNjIDogZmxvYXRcbiAgICA7IG11dGFibGUgZXdtYV90c2Nfc3F1YXJlIDogZmxvYXRcbiAgICA7IG11dGFibGUgZXdtYV90aW1lIDogZmxvYXRcbiAgICA7IG11dGFibGUgZXdtYV90c2MgOiBmbG9hdCAoKiBmb3IgY29tcHV0aW5nIHRpbWUgaW4gbmFub3MgKilcbiAgICA7IG11dGFibGUgbmFub3NfcGVyX2N5Y2xlIDogZmxvYXRcbiAgICA7IG11dGFibGUgbW9ub3RvbmljX25hbm9zX3Blcl9jeWNsZSA6IGZsb2F0XG4gICAgfVxuICBbQEBkZXJpdmluZyBiaW5faW8sIHNleHBdXG5cbiAgdHlwZSB0ID1cbiAgICB7ICgqIHRoZSBtb3N0IHJlY2VudCBvYnNlcnZhdGlvbnMgYW5kIHJlZ3Jlc3Npb24gcmVzdWx0cyAqKVxuICAgICAgbXV0YWJsZSB0c2MgOiB0c2MgKCogdGhpcyB0aW1lIHZhbHVlIGlzIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyAqKVxuICAgIDsgbXV0YWJsZSBtb25vdG9uaWNfdW50aWxfdHNjIDogdHNjICgqIGZvciBjb21wdXRpbmcgdGltZSBpbiBuYW5vcyAqKVxuICAgIDsgbXV0YWJsZSB0aW1lX25hbm9zIDogSW50NjMudFxuICAgIDsgbXV0YWJsZSBtb25vdG9uaWNfdGltZV9uYW5vcyA6IEludDYzLnRcbiAgICA7IGZsb2F0cyA6IGZsb2F0X2ZpZWxkc1xuICAgIH1cbiAgW0BAZGVyaXZpbmcgYmluX2lvLCBzZXhwXVxuXG4gIGxldCB0c2NfdG9fc2Vjb25kc19zaW5jZV9lcG9jaCA9XG4gICAgbGV0W0BpbmxpbmVdIGNvbnZlcnQgdCB0c2MgYmFzZSBtdWwgPVxuICAgICAgYmFzZSArLiAobXVsICouIEludDYzLnRvX2Zsb2F0IChkaWZmIHRzYyB0LnRzYykpXG4gICAgaW5cbiAgICBmdW4gW0BpbmxpbmVdIHQgdHNjIC0+XG4gICAgICAwLlxuICAgICAgKy5cbiAgICAgICgqIHBlcmZvcm1hbmNlIGhhY2s6IHN0b3BzIGZsb2F0IGJveGluZyAqKVxuICAgICAgaWYgdHNjIDwgdC5tb25vdG9uaWNfdW50aWxfdHNjXG4gICAgICB0aGVuXG4gICAgICAgIDAuXG4gICAgICAgICsuICgqIHBlcmZvcm1hbmNlIGhhY2s6IHN0b3BzIGZsb2F0IGJveGluZyAqKVxuICAgICAgICBjb252ZXJ0IHQgdHNjIHQuZmxvYXRzLm1vbm90b25pY190aW1lIHQuZmxvYXRzLm1vbm90b25pY19zZWNfcGVyX2N5Y2xlXG4gICAgICBlbHNlXG4gICAgICAgIDAuXG4gICAgICAgICsuICgqIHBlcmZvcm1hbmNlIGhhY2s6IHN0b3BzIGZsb2F0IGJveGluZyAqKVxuICAgICAgICBjb252ZXJ0IHQgdHNjIHQuZmxvYXRzLnRpbWUgdC5mbG9hdHMuc2VjX3Blcl9jeWNsZVxuICA7O1xuXG4gIGxldCB0c2NfdG9fbmFub3Nfc2luY2VfZXBvY2ggPVxuICAgIGxldFtAaW5saW5lXSBjb252ZXJ0IHQgdHNjIGJhc2UgbXVsID1cbiAgICAgICgqIFNjYWxlIGFuIGludCBieSBhIGZsb2F0IHdpdGhvdXQgaW50ZXJtZWRpYXRlIGFsbG9jYXRpb24gYW5kIG92ZXJmbG93LiAqKVxuICAgICAgKEludDYzLiggKyApIFtAaW5saW5lZCBoaW50XSlcbiAgICAgICAgYmFzZVxuICAgICAgICAoKEZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfZXhuIFtAaW5saW5lZCBoaW50XSlcbiAgICAgICAgICAgKG11bCAqLiAoSW50NjMudG9fZmxvYXQgW0BpbmxpbmVkIGhpbnRdKSAoZGlmZiB0c2MgdC50c2MpKSlcbiAgICBpblxuICAgIGZ1biBbQGlubGluZV0gdCB0c2MgLT5cbiAgICAgIGlmIHRzYyA8IHQubW9ub3RvbmljX3VudGlsX3RzY1xuICAgICAgdGhlbiBjb252ZXJ0IHQgdHNjIHQubW9ub3RvbmljX3RpbWVfbmFub3MgdC5mbG9hdHMubW9ub3RvbmljX25hbm9zX3Blcl9jeWNsZVxuICAgICAgZWxzZSBjb252ZXJ0IHQgdHNjIHQudGltZV9uYW5vcyB0LmZsb2F0cy5uYW5vc19wZXJfY3ljbGVcbiAgOztcblxuICAoKiBUaGUgcmF0ZSBvZiByZXNwb25zZSB0byB0aGUgdmFyaWF0aW9ucyBpbiBUU0MgZnJlcXVlbmN5IGNhbiBiZSBjb250cm9sbGVkIHZpYSBhbHBoYS5cbiAgICAgQWxwaGEgc2hvdWxkIGJlIGluICgwLDFdIGFuZCBjb250cm9scyB0aGUgZGVjYXkgb2YgdGhlIHN1YnNlcXVlbnQgRVdNQSBjYWxjdWxhdGlvbi5cbiAgICAgQSBsb3cgbnVtYmVyIHN1Y2ggYXMgMC4wMSBzdWdnZXN0cyB0aGF0IHRoZSBUU0MgaXMgbGFyZ2VseSBzdGFibGUgYW5kIHNtYWxsXG4gICAgIHZhcmlhdGlvbnMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgbm9pc2UuICBTZXR0aW5nIHRoaXMgbnVtYmVyIHRvIDAuNiBvciBoaWdoZXJcbiAgICAgaW5kaWNhdGVzIHRoYXQgZWFjaCBuZXcgbWVhc3VyZW1lbnQgb2YgdGhlIFRTQyBzaG91bGQgc2lnbmlmaWNhbnRseSBvdXR3ZWlnaCBwYXN0XG4gICAgIG1lYXN1cmVtZW50cyB3aGljaCBoYXMgdGhlIGVmZmVjdCBvZiBtYWtpbmcgdGltZSBjYWxpYnJhdGlvbiBtb3JlIHJlc3BvbnNpdmUgdG9cbiAgICAgZnJlcXVlbmN5IGNoYW5nZXMuICBJbiB0aGlzIG1vZHVsZSB3ZSBoYXZlIGNob3NlbiBhIHZhbHVlIG9mIGFscGhhIHRoYXQgdmFyaWVzIHdpdGhcbiAgICAgdGhlIGR1cmF0aW9uIG9mIHRpbWUsIGkuZS4gbG9uZ2VyIHRpbWUgc2FtcGxlcyBhcmUgZ2l2ZW4gbW9yZSB3ZWlnaHQgYW5kIHNob3J0ZXIgdGltZVxuICAgICBzYW1wbGVzIGFyZSBnaXZlbiBsZXNzZXIgd2VpZ2h0LiAqKVxuICBsZXRbQGlubGluZV0gYWxwaGFfZm9yX2ludGVydmFsIHRpbWVfZGlmZiA9XG4gICAgMC4gKy4gRmxvYXQubWF4IDAuICgxLiAtLiBleHAgKC0wLjUgKi4gdGltZV9kaWZmKSlcbiAgOztcblxuICBsZXQgY2F0Y2h1cF9jeWNsZXMgPSAxRTlcbiAgbGV0IGluaXRpYWxfYWxwaGEgPSAxLlxuXG4gICgqIHBlcmZvcm1hbmNlIGhhY2s6IFRoaXMgZnVuY3Rpb24gaXMgdGhlIHNhbWUgYXNcblxuICAgICB7W1xuICAgICAgIG1hdGNoIEZsb2F0Lmlyb3VuZF91cCBmbG9hdCB3aXRoXG4gICAgICAgfCBOb25lICAgLT4gaWZfaXJvdW5kX3VwX2ZhaWxzXG4gICAgICAgfCBTb21lIGkgLT4gSW50NjMuKCspIGludCBpXG4gICAgIF19XG5cbiAgICAgYnV0IEkgY291bGRuJ3QgZmluZCBhIHdheSB0byBtYWtlIHRoZSBzaW1wbGUgdmVyc2lvbiBzdG9wIGFsbG9jYXRpbmcsIGV2ZW4gd2l0aFxuICAgICBmbGFtYmRhIHR1cm5lZCBvbiAqKVxuICBsZXQgaXJvdW5kX3VwX2FuZF9hZGQgaW50IH5pZl9pcm91bmRfdXBfZmFpbHMgZmxvYXQgPVxuICAgIGlmIEZsb2F0LiggPiApIGZsb2F0IDAuMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IGZsb2F0JyA9IFN0ZGxpYi5jZWlsIGZsb2F0IGluXG4gICAgICBpZiBGbG9hdC4oIDw9ICkgZmxvYXQnIEZsb2F0Lmlyb3VuZF91Ym91bmRcbiAgICAgIHRoZW4gSW50NjMuKCArICkgaW50IChJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgZmxvYXQnKVxuICAgICAgZWxzZSBpZl9pcm91bmRfdXBfZmFpbHMpXG4gICAgZWxzZSBpZiBGbG9hdC4oID49ICkgZmxvYXQgRmxvYXQuaXJvdW5kX2xib3VuZFxuICAgIHRoZW4gSW50NjMuKCArICkgaW50IChJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgZmxvYXQpXG4gICAgZWxzZSBpZl9pcm91bmRfdXBfZmFpbHNcbiAgOztcblxuICBsZXRbQGlubGluZV0gY2FsaWJyYXRlX3VzaW5nIHQgfnRzYyB+dGltZSB+YW1faW5pdGlhbGl6aW5nID1cbiAgICBsZXQgZXN0aW1hdGVkX3RpbWUgPVxuICAgICAgMC5cbiAgICAgICsuICgqIHBlcmZvcm1hbmNlIGhhY2s6IHN0b3BzIGZsb2F0IGJveGluZyAqKVxuICAgICAgdHNjX3RvX3NlY29uZHNfc2luY2VfZXBvY2ggdCB0c2NcbiAgICBpblxuICAgIGxldCB0aW1lX2RpZmZfZXN0ID0gdGltZSAtLiBlc3RpbWF0ZWRfdGltZSBpblxuICAgIGxldCB0aW1lX2RpZmYgPSB0aW1lIC0uIHQuZmxvYXRzLnRpbWUgaW5cbiAgICBsZXQgdHNjX2RpZmYgPSBJbnQ2My50b19mbG9hdCAoZGlmZiB0c2MgdC50c2MpIGluXG4gICAgbGV0IGFscGhhID0gaWYgYW1faW5pdGlhbGl6aW5nIHRoZW4gaW5pdGlhbF9hbHBoYSBlbHNlIGFscGhhX2Zvcl9pbnRlcnZhbCB0aW1lX2RpZmYgaW5cbiAgICAoKiB1cGRhdGUgY3VycmVudCB0aW1lcyAqKVxuICAgIHQuZmxvYXRzLnRpbWUgPC0gdGltZTtcbiAgICB0LnRzYyA8LSB0c2M7XG4gICAgKCogdXBkYXRlIGV3bWEgYW5kIHJlZ3Jlc3Npb24uICopXG4gICAgdC5mbG9hdHMuZXdtYV90aW1lX3RzY1xuICAgICAgPC0gZXdtYSB+YWxwaGEgfm9sZDp0LmZsb2F0cy5ld21hX3RpbWVfdHNjIH5hZGQ6KHRzY19kaWZmICouIHRpbWVfZGlmZik7XG4gICAgdC5mbG9hdHMuZXdtYV90c2Nfc3F1YXJlXG4gICAgICA8LSBld21hIH5hbHBoYSB+b2xkOnQuZmxvYXRzLmV3bWFfdHNjX3NxdWFyZSB+YWRkOih0c2NfZGlmZiAqLiB0c2NfZGlmZik7XG4gICAgdC5mbG9hdHMuZXdtYV90c2MgPC0gZXdtYSB+YWxwaGEgfm9sZDp0LmZsb2F0cy5ld21hX3RzYyB+YWRkOnRzY19kaWZmO1xuICAgIHQuZmxvYXRzLmV3bWFfdGltZSA8LSBld21hIH5hbHBoYSB+b2xkOnQuZmxvYXRzLmV3bWFfdGltZSB+YWRkOnRpbWVfZGlmZjtcbiAgICAoKiBsaW5lYXIgcmVncmVzc2lvbiAqKVxuICAgIHQuZmxvYXRzLnNlY19wZXJfY3ljbGUgPC0gdC5mbG9hdHMuZXdtYV90aW1lX3RzYyAvLiB0LmZsb2F0cy5ld21hX3RzY19zcXVhcmU7XG4gICAgKCogdC5zZWNfZXJyb3JfaW50ZXJjZXB0IDwtIHQuZXdtYV90aW1lIC0uIHQuc2VjX3Blcl9jeWNsZSAqLiB0LmV3bWFfdHNjOyAqKVxuICAgICgqIG1vbm90b25pYyBwcmVkaWN0ZWQgdGltZSBhbmQgc2xvcGUuICopXG4gICAgdC5mbG9hdHMubW9ub3RvbmljX3RpbWUgPC0gZXN0aW1hdGVkX3RpbWU7XG4gICAgaWYgbm90IGFtX2luaXRpYWxpemluZ1xuICAgIHRoZW4gKFxuICAgICAgbGV0IGNhdGNodXBfc2VjX3Blcl9jeWNsZSA9XG4gICAgICAgICgqIFRoZSBzbG9wZSBzbyB0aGF0IGFmdGVyIFtjYXRjaHVwX2N5Y2xlc10sIHRoZSBtb25vdG9uaWMgZXN0aW1hdGVkIHRpbWUgZXF1YWxzXG4gICAgICAgICAgIHRoZSBlc3RpbWF0ZWQgdGltZSwgaS5lLiBzb2x2ZSBmb3IgW21vbm90b25pY19zZWNfcGVyX2N5Y2xlXSBpbjpcblxuICAgICAgICAgICB7W1xuICAgICAgICAgICAgIHQubW9ub3RvbmljX3RpbWUgKyBtb25vdG9uaWNfc2VjX3Blcl9jeWNsZSAqIGNhdGNodXBfY3ljbGVzXG4gICAgICAgICAgICAgPSB0LnRpbWUgICAgICAgICArIHQuc2VjX3Blcl9jeWNsZSAgICAgICAgICogY2F0Y2h1cF9jeWNsZXNcbiAgICAgICAgICAgXX1cblxuICAgICAgICAgICBOb3RlIHRoYXQgW3RpbWVfZGlmZl9lc3QgPSB0LnRpbWUgLSB0Lm1vbm90b25pY190aW1lXS4gKilcbiAgICAgICAgdC5mbG9hdHMuc2VjX3Blcl9jeWNsZSArLiAodGltZV9kaWZmX2VzdCAvLiBjYXRjaHVwX2N5Y2xlcylcbiAgICAgIGluXG4gICAgICB0LmZsb2F0cy5tb25vdG9uaWNfc2VjX3Blcl9jeWNsZVxuICAgICAgICA8LSAoaWYgRmxvYXQuaXNfcG9zaXRpdmUgdGltZV9kaWZmX2VzdFxuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAwLlxuICAgICAgICAgICAgICArLiAoKiBwZXJmb3JtYW5jZSBoYWNrOiBzdG9wcyBmbG9hdCBib3hpbmcgKilcbiAgICAgICAgICAgICAgRmxvYXQubWluXG4gICAgICAgICAgICAgICAgY2F0Y2h1cF9zZWNfcGVyX2N5Y2xlXG4gICAgICAgICAgICAgICAgKHQuZmxvYXRzLnNlY19wZXJfY3ljbGUgKi4gKDEuICsuIG1heF9wZXJjZW50X2NoYW5nZV9mcm9tX3JlYWxfc2xvcGUpKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAwLlxuICAgICAgICAgICAgICArLiAoKiBwZXJmb3JtYW5jZSBoYWNrOiBzdG9wcyBmbG9hdCBib3hpbmcgKilcbiAgICAgICAgICAgICAgRmxvYXQubWF4XG4gICAgICAgICAgICAgICAgY2F0Y2h1cF9zZWNfcGVyX2N5Y2xlXG4gICAgICAgICAgICAgICAgKHQuZmxvYXRzLnNlY19wZXJfY3ljbGUgKi4gKDEuIC0uIG1heF9wZXJjZW50X2NoYW5nZV9mcm9tX3JlYWxfc2xvcGUpKSk7XG4gICAgICAoKiBDb21wdXRlIHRoZSBudW1iZXIgb2YgY3ljbGVzIGluIHRoZSBmdXR1cmUgYXQgd2hpY2ggbW9ub3RvbmljIGVzdGltYXRlZCB0aW1lXG4gICAgICAgICBlcXVhbHMgZXN0aW1hdGVkIHRpbWUsIGkuZS4gc29sdmUgZm9yIFtjeWNsZXNdIGluOlxuXG4gICAgICAgICB7W1xuICAgICAgICAgICB0Lm1vbm90b25pY190aW1lICsgdC5tb25vdG9uaWNfc2VjX3Blcl9jeWNsZSAqIGN5Y2xlc1xuICAgICAgICAgICA9IHQudGltZSAgICAgICAgICsgdC5zZWNfcGVyX2N5Y2xlICAgICAgICAgICAqIGN5Y2xlc1xuICAgICAgICAgXX1cblxuICAgICAgICAgVGhpcyB2YWx1ZSBtaWdodCBnZXQgdmVyeSBzbWFsbCB3aGVuIHRoZSB0d28gc2xvcGVzIGFyZSBhYm91dCB0aGUgc2FtZS4gIEluIHN1Y2hcbiAgICAgICAgIGNhc2VzIHdlIGp1c3QgdXNlIHRoZSBlc3RpbWF0ZWQgc2xvcGUgYWx3YXlzLiAqKVxuICAgICAgdC5tb25vdG9uaWNfdW50aWxfdHNjXG4gICAgICAgIDwtIHRpbWVfZGlmZl9lc3QgLy4gKHQuZmxvYXRzLm1vbm90b25pY19zZWNfcGVyX2N5Y2xlIC0uIHQuZmxvYXRzLnNlY19wZXJfY3ljbGUpXG4gICAgICAgICAgIHw+IGlyb3VuZF91cF9hbmRfYWRkIHRzYyB+aWZfaXJvdW5kX3VwX2ZhaWxzOkludDYzLnplcm8pO1xuICAgICgqIFByZWNvbXB1dGUgdmFsdWVzIHJlcXVpcmVkIGZvciBbdHNjX3RvX25hbm9zX3NpbmNlX2Vwb2NoXS4gKilcbiAgICB0LnRpbWVfbmFub3MgPC0gRmxvYXQuaW50NjNfcm91bmRfbmVhcmVzdF9leG4gKHQuZmxvYXRzLnRpbWUgKi4gMUU5KTtcbiAgICB0LmZsb2F0cy5uYW5vc19wZXJfY3ljbGUgPC0gdC5mbG9hdHMuc2VjX3Blcl9jeWNsZSAqLiAxRTk7XG4gICAgdC5tb25vdG9uaWNfdGltZV9uYW5vc1xuICAgICAgPC0gRmxvYXQuaW50NjNfcm91bmRfbmVhcmVzdF9leG4gKHQuZmxvYXRzLm1vbm90b25pY190aW1lICouIDFFOSk7XG4gICAgdC5mbG9hdHMubW9ub3RvbmljX25hbm9zX3Blcl9jeWNsZSA8LSB0LmZsb2F0cy5tb25vdG9uaWNfc2VjX3Blcl9jeWNsZSAqLiAxRTlcbiAgOztcblxuICBsZXQgbm93X2Zsb2F0ICgpID1cbiAgICAxRS05ICouIEludDYzLnRvX2Zsb2F0IChUaW1lX25zLnRvX2ludDYzX25zX3NpbmNlX2Vwb2NoIChUaW1lX25zLm5vdyAoKSkpXG4gIDs7XG5cbiAgbGV0IGluaXRpYWxpemUgdCBzYW1wbGVzID1cbiAgICBMaXN0Lml0ZXIgc2FtcGxlcyB+ZjooZnVuICh0c2MsIHRpbWUpIC0+XG4gICAgICBjYWxpYnJhdGVfdXNpbmcgdCB+dHNjIH50aW1lIH5hbV9pbml0aWFsaXppbmc6dHJ1ZSlcbiAgOztcblxuICBsZXQgY29sbGVjdF9zYW1wbGVzIH5udW1fc2FtcGxlcyB+aW50ZXJ2YWwgPVxuICAgIGFzc2VydCAoSW50LiggPj0gKSBudW1fc2FtcGxlcyAxKTtcbiAgICAoKiBXZSBzbGVlcCBhdCBkaWZmZXJpbmcgaW50ZXJ2YWxzIHRvIGltcHJvdmUgdGhlIGVzdGltYXRpb24gb2YgW3NlY19wZXJfY3ljbGVdLiAqKVxuICAgIGxldCByZWMgbG9vcCBuIHNsZWVwID1cbiAgICAgIGxldCBzYW1wbGUgPSBub3cgKCksIG5vd19mbG9hdCAoKSBpblxuICAgICAgaWYgSW50LiggPSApIG4gMVxuICAgICAgdGhlbiBbIHNhbXBsZSBdXG4gICAgICBlbHNlIChcbiAgICAgICAgaWdub3JlIChuYW5vc2xlZXAgc2xlZXApO1xuICAgICAgICBzYW1wbGUgOjogbG9vcCAobiAtIDEpIChzbGVlcCArLiBpbnRlcnZhbCkpXG4gICAgaW5cbiAgICBsb29wIG51bV9zYW1wbGVzIGludGVydmFsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV91c2luZyB+dHNjIH50aW1lIH5zYW1wbGVzID1cbiAgICBsZXQgdCA9XG4gICAgICB7IG1vbm90b25pY191bnRpbF90c2MgPSBJbnQ2My56ZXJvXG4gICAgICA7IHRzY1xuICAgICAgOyB0aW1lX25hbm9zID0gSW50NjMuemVyb1xuICAgICAgOyBtb25vdG9uaWNfdGltZV9uYW5vcyA9IEludDYzLnplcm9cbiAgICAgIDsgZmxvYXRzID1cbiAgICAgICAgICB7IG1vbm90b25pY190aW1lID0gdGltZVxuICAgICAgICAgIDsgc2VjX3Blcl9jeWNsZSA9IDAuXG4gICAgICAgICAgOyBtb25vdG9uaWNfc2VjX3Blcl9jeWNsZSA9IDAuXG4gICAgICAgICAgOyB0aW1lXG4gICAgICAgICAgOyBld21hX3RpbWVfdHNjID0gMC5cbiAgICAgICAgICA7IGV3bWFfdHNjX3NxdWFyZSA9IDAuXG4gICAgICAgICAgOyBld21hX3RpbWUgPSAwLlxuICAgICAgICAgIDsgZXdtYV90c2MgPSAwLlxuICAgICAgICAgIDsgbmFub3NfcGVyX2N5Y2xlID0gMC5cbiAgICAgICAgICA7IG1vbm90b25pY19uYW5vc19wZXJfY3ljbGUgPSAwLlxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICBpblxuICAgIGluaXRpYWxpemUgdCBzYW1wbGVzO1xuICAgIHRcbiAgOztcblxuICBsZXQgY3JlYXRlX25hbm9zIH50c2MgfnRpbWUgPVxuICAgIGxldCB0ID1cbiAgICAgIHsgbW9ub3RvbmljX3VudGlsX3RzYyA9IEludDYzLm1heF92YWx1ZVxuICAgICAgOyB0c2NcbiAgICAgIDsgdGltZV9uYW5vcyA9IHRzY1xuICAgICAgOyBtb25vdG9uaWNfdGltZV9uYW5vcyA9IHRzY1xuICAgICAgOyBmbG9hdHMgPVxuICAgICAgICAgIHsgbW9ub3RvbmljX3RpbWUgPSB0aW1lXG4gICAgICAgICAgOyBzZWNfcGVyX2N5Y2xlID0gMWUtOVxuICAgICAgICAgIDsgbW9ub3RvbmljX3NlY19wZXJfY3ljbGUgPSAxZS05XG4gICAgICAgICAgOyB0aW1lXG4gICAgICAgICAgOyBld21hX3RpbWVfdHNjID0gMC5cbiAgICAgICAgICA7IGV3bWFfdHNjX3NxdWFyZSA9IDAuXG4gICAgICAgICAgOyBld21hX3RpbWUgPSAwLlxuICAgICAgICAgIDsgZXdtYV90c2MgPSAwLlxuICAgICAgICAgIDsgbmFub3NfcGVyX2N5Y2xlID0gMS5cbiAgICAgICAgICA7IG1vbm90b25pY19uYW5vc19wZXJfY3ljbGUgPSAxLlxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICBpblxuICAgIHRcbiAgOztcblxuICBsZXQgY3JlYXRlICgpID1cbiAgICBsZXQgdGltZSA9IG5vd19mbG9hdCAoKSBpblxuICAgIGxldCB0c2MgPSBub3cgKCkgaW5cbiAgICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgICB8IE5hdGl2ZSAtPlxuICAgICAgbGV0IHNhbXBsZXMgPSBjb2xsZWN0X3NhbXBsZXMgfm51bV9zYW1wbGVzOjMgfmludGVydmFsOjAuMDAwNSBpblxuICAgICAgY3JlYXRlX3VzaW5nIH50c2MgfnRpbWUgfnNhbXBsZXNcbiAgICB8IEJ5dGVjb2RlIHwgT3RoZXIgXyAtPlxuICAgICAgKCogQXNzdW1lcyB0aGUgaW1wbGVtZW50YXRpb24gb2YgcmR0c2MgcmV0dXJucyBtb25vdG9uaWMgbmFub3NlY29uZHMuICopXG4gICAgICBjcmVhdGVfbmFub3MgfnRzYyB+dGltZVxuICA7O1xuXG4gICgqIENyZWF0aW5nIGEgY2FsaWJyYXRvciB0YWtlcyBhYm91dCAzbXMuICopXG4gIGxldCB0ID0gbGF6eSAoY3JlYXRlICgpKVxuICBsZXQgY3B1X21oeiA9IE9rIChmdW4gdCAtPiAxLiAvLiAodC5mbG9hdHMuc2VjX3Blcl9jeWNsZSAqLiAxRTYpKVxuXG4gICgqIHBlcmZvcm1hbmNlIGhhY2s6IFtAY29sZF0gc28gW3RpbWVdIGlzIGFsd2F5cyB1bmJveGVkLiBbbm93X2Zsb2F0XSBhbmRcbiAgICAgW2NhbGlicmF0ZV91c2luZ10gbmVlZCB0byBiZSBpbmxpbmVkIGludG8gdGhlIHNhbWUgZnVuY3Rpb24gZm9yIHVuYm94ZWQgW3RpbWVdLlxuICAgICBQcmV2ZW50aW5nIFtjYWxpYnJhdGVdIGZyb20gYmVpbmcgaW5saW5lZCBtYWtlcyB0aGUgY29tcGlsZXIncyBpbmxpbmluZyBkZWNpc2lvblxuICAgICBtb3JlIHByZWRpY3RhYmxlLiAqKVxuICBsZXRbQGNvbGRdIGNhbGlicmF0ZSB0ID1cbiAgICBjYWxpYnJhdGVfdXNpbmcgdCB+dHNjOihub3cgKCkpIH50aW1lOihub3dfZmxvYXQgKCkpIH5hbV9pbml0aWFsaXppbmc6ZmFsc2VcbiAgOztcblxuICBtb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICAgIGxldCBjcmVhdGVfdXNpbmcgPSBjcmVhdGVfdXNpbmdcbiAgICBsZXQgY2FsaWJyYXRlX3VzaW5nID0gY2FsaWJyYXRlX3VzaW5nXG4gICAgbGV0IGluaXRpYWxpemUgPSBpbml0aWFsaXplXG4gICAgbGV0IG5hbm9zX3Blcl9jeWNsZSB0ID0gdC5mbG9hdHMubmFub3NfcGVyX2N5Y2xlXG4gIGVuZFxuZW5kXG5cblslJWVsc2VdXG5cbigqIG5vYWxsb2Mgb24geDg2XzY0IG9ubHkgKilcbmV4dGVybmFsIG5vdyA6IHVuaXQgLT4gdHNjID0gXCJ0c2NfZ2V0XCJcblxuKCogT3V0c2lkZSBvZiB4ODZfNjQsIFtub3ddIHJldHVybnMgdGhlIHJlc3VsdCBvZiBjbG9ja19nZXR0aW1lKCksIGkuZS4gdGhlIGN1cnJlbnQgdGltZVxuICAgaW4gbmFub3MgcGFzdCBlcG9jaC4gKilcblxubW9kdWxlIENhbGlicmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gdW5pdCBbQEBkZXJpdmluZyBiaW5faW8sIHNleHBdXG5cbiAgbGV0IHRzY190b19zZWNvbmRzX3NpbmNlX2Vwb2NoIF90IHRzYyA9IEludDYzLnRvX2Zsb2F0IHRzYyAqLiAxZS05XG4gIGxldCB0c2NfdG9fbmFub3Nfc2luY2VfZXBvY2ggX3QgdHNjID0gdHNjXG4gIGxldCBjcmVhdGVfdXNpbmcgfnRzYzpfIH50aW1lOl8gfnNhbXBsZXM6XyA9ICgpXG4gIGxldCBjcmVhdGUgKCkgPSAoKVxuICBsZXQgaW5pdGlhbGl6ZSBfdCBfc2FtcGxlcyA9ICgpXG4gIGxldCBjYWxpYnJhdGVfdXNpbmcgX3QgfnRzYzpfIH50aW1lOl8gfmFtX2luaXRpYWxpemluZzpfID0gKClcbiAgbGV0IGNhbGlicmF0ZSBfID0gKClcbiAgbGV0IHQgPSBsYXp5IChjcmVhdGUgKCkpXG5cbiAgbGV0IGNwdV9taHogPVxuICAgIE9yX2Vycm9yLnVuaW1wbGVtZW50ZWRcbiAgICAgIFwiVGltZV9zdGFtcF9jb3VudGVyLkNhbGlicmF0b3IuY3B1X21oeiBpcyBub3QgZGVmaW5lZCBmb3IgMzItYml0IHBsYXRmb3Jtc1wiXG4gIDs7XG5cbiAgbW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgICBsZXQgY3JlYXRlX3VzaW5nID0gY3JlYXRlX3VzaW5nXG4gICAgbGV0IGNhbGlicmF0ZV91c2luZyA9IGNhbGlicmF0ZV91c2luZ1xuICAgIGxldCBpbml0aWFsaXplID0gaW5pdGlhbGl6ZVxuICAgIGxldCBuYW5vc19wZXJfY3ljbGUgXyA9IDEuXG4gIGVuZFxuZW5kXG5cblslJWVuZGlmXVxuXG5tb2R1bGUgU3BhbiA9IHN0cnVjdFxuICBpbmNsdWRlIEludDYzXG5cbiAgbW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgICBsZXQgb2ZfaW50NjMgdCA9IHRcbiAgICBsZXQgdG9faW50NjMgdCA9IHRcbiAgZW5kXG5cbiAgWyUlaWZkZWYgSlNDX0FSQ0hfU0lYVFlGT1VSXVxuXG4gIGxldCB0b19ucyB0IH4oY2FsaWJyYXRvciA6IENhbGlicmF0b3IudCkgPVxuICAgIChGbG9hdC5pbnQ2M19yb3VuZF9uZWFyZXN0X2V4biBbQGlubGluZWQgaGludF0pXG4gICAgICAoSW50NjMudG9fZmxvYXQgdCAqLiBjYWxpYnJhdG9yLmZsb2F0cy5uYW5vc19wZXJfY3ljbGUpXG4gIDs7XG5cbiAgKCogSWYgdGhlIGNhbGlicmF0b3IgaGFzIG5vdCBiZWVuIHdlbGwgY2FsaWJyYXRlZCBhbmQgW25zXSBpcyBhIGxhcmdlIHZhbHVlLCB0aGVcbiAgICAgZm9sbG93aW5nIGNhbiBvdmVyZmxvdy4gVGhpcyBoYXBwZW5zIHJhcmVseSBpbiBoeWRyYSBpbiBhIHdheSB0aGF0IGRpZmZpY3VsdCB0b1xuICAgICByZXByb2R1Y2UuIFdlJ3ZlIGltcHJvdmVkIHRoZSBleG4gaGVyZSBzbyB0aGF0IHdlIGhhdmUgbW9yZSBpbmZvcm1hdGlvbiB0byBkZWJ1Z1xuICAgICB0aGVzZSBzcHVyaW91cyBlcnJvcnMgd2hlbiB0aGV5IGNvbWUgdXAuICopXG4gIGxldCBvZl9ucyBucyB+KGNhbGlicmF0b3IgOiBDYWxpYnJhdG9yLnQpID1cbiAgICB0cnlcbiAgICAgIEZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfZXhuXG4gICAgICAgIChJbnQ2My50b19mbG9hdCBucyAvLiBjYWxpYnJhdG9yLmZsb2F0cy5uYW5vc19wZXJfY3ljbGUpXG4gICAgd2l0aFxuICAgIHwgZXhuIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiXCIgfl86KGV4biA6IEV4bi50KSAoY2FsaWJyYXRvciA6IENhbGlicmF0b3IudCldXG4gIDs7XG5cbiAgWyUlZWxzZV1cblxuICAoKiBbdHNjX2dldF0gYWxyZWFkeSByZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgaW4gbnMgKilcblxuICBsZXQgdG9fbnMgdCB+Y2FsaWJyYXRvcjpfID0gdFxuICBsZXQgb2ZfbnMgbnMgfmNhbGlicmF0b3I6XyA9IG5zXG5cbiAgWyUlZW5kaWZdXG5cbiAgbGV0IHRvX3RpbWVfbnNfc3BhbiB0IH5jYWxpYnJhdG9yID0gVGltZV9ucy5TcGFuLm9mX2ludDYzX25zICh0b19ucyB0IH5jYWxpYnJhdG9yKVxuICBsZXQgb2ZfdGltZV9uc19zcGFuIHNwYW4gfmNhbGlicmF0b3IgPSBvZl9ucyAoVGltZV9ucy5TcGFuLnRvX2ludDYzX25zIHNwYW4pIH5jYWxpYnJhdG9yXG5lbmRcblxubGV0IGNhbGlicmF0b3IgPSBDYWxpYnJhdG9yLnRcblxubGV0IHRvX3RpbWUgdCB+Y2FsaWJyYXRvciA9XG4gIENhbGlicmF0b3IudHNjX3RvX3NlY29uZHNfc2luY2VfZXBvY2ggY2FsaWJyYXRvciB0XG4gIHw+IFRpbWVfZmxvYXQuU3Bhbi5vZl9zZWNcbiAgfD4gVGltZV9mbG9hdC5vZl9zcGFuX3NpbmNlX2Vwb2NoXG47O1xuXG5sZXRbQGlubGluZV0gdG9fbmFub3Nfc2luY2VfZXBvY2ggdCB+Y2FsaWJyYXRvciA9XG4gIENhbGlicmF0b3IudHNjX3RvX25hbm9zX3NpbmNlX2Vwb2NoIGNhbGlicmF0b3IgdFxuOztcblxubGV0W0BpbmxpbmVdIHRvX3RpbWVfbnMgdCB+Y2FsaWJyYXRvciA9XG4gIFRpbWVfbnMub2ZfaW50NjNfbnNfc2luY2VfZXBvY2ggKHRvX25hbm9zX3NpbmNlX2Vwb2NoIH5jYWxpYnJhdG9yIHQpXG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgZXdtYSA9IGV3bWFcbiAgbGV0IG9mX2ludDYzID0gb2ZfaW50NjNcbiAgbGV0IG1heF9wZXJjZW50X2NoYW5nZV9mcm9tX3JlYWxfc2xvcGUgPSBtYXhfcGVyY2VudF9jaGFuZ2VfZnJvbV9yZWFsX3Nsb3BlXG4gIGxldCB0b19uYW5vc19zaW5jZV9lcG9jaCA9IHRvX25hbm9zX3NpbmNlX2Vwb2NoXG5lbmRcbiJdfQ==
