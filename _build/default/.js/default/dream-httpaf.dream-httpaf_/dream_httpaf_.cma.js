// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Dream_httpaf_
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dream_httpaf = [0];
   runtime.caml_register_global(0, Dream_httpaf, "Dream_httpaf_");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Version
//# unitInfo: Requires: Stdlib, Stdlib__Buffer, Stdlib__Format, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_HTTP$0 = "HTTP/",
    cst_HTTP_d_d = "HTTP/%d.%d",
    cst_HTTP_1_0$0 = "HTTP/1.0",
    cst_HTTP_1_1$0 = "HTTP/1.1",
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    v1_0 = [0, 1, 0],
    v1_1 = [0, 1, 1],
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    _d_ =
      [0,
       [11, cst_HTTP$0, [4, 0, 0, 0, [12, 46, [4, 0, 0, 0, 0]]]],
       cst_HTTP_d_d],
    _b_ = [0, 1, 1],
    _c_ = [0, 1, 0],
    _a_ =
      [0,
       [11, cst_HTTP$0, [4, 0, 0, 0, [12, 46, [4, 0, 0, 0, 0]]]],
       cst_HTTP_d_d],
    cst_Version_of_string = "Version.of_string",
    cst_HTTP_1_1 = cst_HTTP_1_1$0,
    cst_HTTP_1_0 = cst_HTTP_1_0$0,
    cst_HTTP = cst_HTTP$0;
   function to_buffer(b, t){
    caml_call2(Stdlib_Buffer[16], b, cst_HTTP);
    var _i_ = caml_call1(Stdlib[33], t[1]);
    caml_call2(Stdlib_Buffer[16], b, _i_);
    caml_call2(Stdlib_Buffer[12], b, 46);
    var _j_ = caml_call1(Stdlib[33], t[2]);
    return caml_call2(Stdlib_Buffer[16], b, _j_);
   }
   function compare(x, y){
    var c = caml_int_compare(x[1], y[1]);
    return 0 === c ? caml_int_compare(x[2], y[2]) : c;
   }
   function to_string(t){
    if(1 === t[1]){
     var _h_ = t[2];
     if(0 === _h_) return cst_HTTP_1_0;
     if(1 === _h_) return cst_HTTP_1_1;
    }
    var b = caml_call1(Stdlib_Buffer[1], 8);
    to_buffer(b, t);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function of_string(s){
    if(! caml_string_notequal(s, cst_HTTP_1_0$0)) return _c_;
    if(! caml_string_notequal(s, cst_HTTP_1_1$0)) return _b_;
    try{
     var
      _e_ = function(major, minor){return [0, major, minor];},
      _f_ = caml_call3(Stdlib_Scanf[5], s, _a_, _e_);
     return _f_;
    }
    catch(_g_){
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[7], cst_Version_of_string], 1);
    }
   }
   function pp_hum(fmt, t){
    return caml_call4(Stdlib_Format[137], fmt, _d_, t[1], t[2]);
   }
   var
    Dream_httpaf_Version =
      [0, v1_0, v1_1, to_buffer, compare, to_string, of_string, pp_hum];
   runtime.caml_register_global
    (16, Dream_httpaf_Version, "Dream_httpaf___Version");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Status
//# unitInfo: Requires: Stdlib, Stdlib__Format, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    _c_ = [0, [4, 12, 0, 0, 0], "%u"],
    cst_408 = "408",
    cst_307 = "307",
    cst_417 = "417",
    cst_206 = "206",
    cst_428 = "428",
    cst_410 = "410",
    cst_414 = "414",
    cst_504 = "504",
    cst_202 = "202",
    cst_413 = "413",
    cst_418 = "418",
    cst_302 = "302",
    cst_301 = "301",
    cst_401 = "401",
    cst_412 = "412",
    cst_303 = "303",
    cst_100 = "100",
    cst_203 = "203",
    cst_429 = "429",
    cst_300 = "300",
    cst_405 = "405",
    cst_200 = "200",
    cst_407 = "407",
    cst_511 = "511",
    cst_409 = "409",
    cst_400 = "400",
    cst_406 = "406",
    cst_411 = "411",
    cst_205 = "205",
    cst_404 = "404",
    cst_304 = "304",
    cst_305 = "305",
    cst_403 = "403",
    cst_415 = "415",
    cst_501 = "501",
    cst_204 = "204",
    cst_201 = "201",
    cst_402 = "402",
    cst_500 = "500",
    cst_503 = "503",
    cst_420 = "420",
    cst_426 = "426",
    cst_502 = "502",
    cst_505 = "505",
    cst_101 = "101",
    cst_431 = "431",
    cst_416 = "416",
    _b_ =
      [0,
       [11,
        "Status.of_code: ",
        [4, 0, 0, 0, [11, " is not a three-digit number", 0]]],
       "Status.of_code: %d is not a three-digit number"],
    _a_ =
      [0,
       [11, "Status.unsafe_of_code: ", [4, 0, 0, 0, [11, " is negative", 0]]],
       "Status.unsafe_of_code: %d is negative"],
    cst_Request_Timeout = "Request Timeout",
    cst_Temporary_Redirect = "Temporary Redirect",
    cst_Expectation_Failed = "Expectation Failed",
    cst_Partial_Content = "Partial Content",
    cst_Precondition_Required = "Precondition Required",
    cst_Gone = "Gone",
    cst_URI_Too_Long = "URI Too Long",
    cst_Gateway_Timeout = "Gateway Timeout",
    cst_Accepted = "Accepted",
    cst_Payload_Too_Large = "Payload Too Large",
    cst_I_m_a_teapot = "I'm a teapot",
    cst_Found = "Found",
    cst_Moved_Permanently = "Moved Permanently",
    cst_Unauthorized = "Unauthorized",
    cst_Precondition_Failed = "Precondition Failed",
    cst_See_Other = "See Other",
    cst_Continue = "Continue",
    cst_Non_Authoritative_Informat = "Non-Authoritative Information",
    cst_Too_Many_Requests = "Too Many Requests",
    cst_Multiple_Choices = "Multiple Choices",
    cst_Method_Not_Allowed = "Method Not Allowed",
    cst_OK = "OK",
    cst_Proxy_Authentication_Requi = "Proxy Authentication Required",
    cst_Network_Authentication_Req = "Network Authentication Required",
    cst_Conflict = "Conflict",
    cst_Bad_Request = "Bad Request",
    cst_Not_Acceptable = "Not Acceptable",
    cst_Length_Required = "Length Required",
    cst_Reset_Content = "Reset Content",
    cst_Not_Found = "Not Found",
    cst_Not_Modified = "Not Modified",
    cst_Use_Proxy = "Use Proxy",
    cst_Forbidden = "Forbidden",
    cst_Unsupported_Media_Type = "Unsupported Media Type",
    cst_Not_Implemented = "Not Implemented",
    cst_No_Content = "No Content",
    cst_Created = "Created",
    cst_Payment_Required = "Payment Required",
    cst_Internal_Server_Error = "Internal Server Error",
    cst_Service_Unavailable = "Service Unavailable",
    cst_Enhance_Your_Calm = "Enhance Your Calm",
    cst_Upgrade_Required = "Upgrade Required",
    cst_Bad_Gateway = "Bad Gateway",
    cst_HTTP_Version_Not_Supported = "HTTP Version Not Supported",
    cst_Switching_Protocols = "Switching Protocols",
    cst_Request_Header_Fields_Too_ = "Request Header Fields Too Large",
    cst_Range_Not_Satisfiable = "Range Not Satisfiable";
   function default_reason_phrase(param){
    return -15361451 <= param
            ? 398750242
              <= param
              ? 792903807
                <= param
                ? 893234971
                  <= param
                  ? 1034456810
                    <= param
                    ? 1052164689
                      <= param
                      ? cst_Request_Timeout
                      : cst_Temporary_Redirect
                    : 897427648
                      <= param
                      ? cst_Expectation_Failed
                      : cst_Partial_Content
                  : 807430278 <= param ? cst_Precondition_Required : cst_Gone
                : 565592383
                  <= param
                  ? 731537414
                    <= param
                    ? 751586522
                      <= param
                      ? cst_URI_Too_Long
                      : cst_Gateway_Timeout
                    : 566851975 <= param ? cst_Accepted : cst_Payload_Too_Large
                  : 491839979 <= param ? cst_I_m_a_teapot : cst_Found
              : 102779818
                <= param
                ? 260151748
                  <= param
                  ? 324098644
                    <= param
                    ? 384167631
                      <= param
                      ? cst_Moved_Permanently
                      : cst_Unauthorized
                    : 282375460
                      <= param
                      ? cst_Precondition_Failed
                      : cst_See_Other
                  : 192584839
                    <= param
                    ? cst_Continue
                    : cst_Non_Authoritative_Informat
                : 17692
                  <= param
                  ? 18898339
                    <= param
                    ? 65414873
                      <= param
                      ? cst_Too_Many_Requests
                      : cst_Multiple_Choices
                    : 13829438 <= param ? cst_Method_Not_Allowed : cst_OK
                  : -12825579
                    <= param
                    ? cst_Proxy_Authentication_Requi
                    : cst_Network_Authentication_Req
            : -527633381
              <= param
              ? -358247754
                <= param
                ? -221106440
                  <= param
                  ? -99004555
                    <= param
                    ? -36288910 <= param ? cst_Conflict : cst_Bad_Request
                    : -176787538
                      <= param
                      ? cst_Not_Acceptable
                      : cst_Length_Required
                  : -234002583 <= param ? cst_Reset_Content : cst_Not_Found
                : -459143713
                  <= param
                  ? -398446314
                    <= param
                    ? -387970219 <= param ? cst_Not_Modified : cst_Use_Proxy
                    : -438114087
                      <= param
                      ? cst_Forbidden
                      : cst_Unsupported_Media_Type
                  : -498198474 <= param ? cst_Not_Implemented : cst_No_Content
              : -867418942
                <= param
                ? -774758938
                  <= param
                  ? -720017128
                    <= param
                    ? -558113336 <= param ? cst_Created : cst_Payment_Required
                    : -732353682
                      <= param
                      ? cst_Internal_Server_Error
                      : cst_Service_Unavailable
                  : -785212614
                    <= param
                    ? cst_Enhance_Your_Calm
                    : cst_Upgrade_Required
                : -1045236833
                  === param
                  ? cst_Range_Not_Satisfiable
                  : -1014316796
                    <= param
                    ? -957501398
                      <= param
                      ? cst_Bad_Gateway
                      : cst_HTTP_Version_Not_Supported
                    : -1021676630
                      <= param
                      ? cst_Switching_Protocols
                      : cst_Request_Header_Fields_Too_;
   }
   function to_code(param){
    if(typeof param === "number")
     return -15361451 <= param
             ? 398750242
               <= param
               ? 792903807
                 <= param
                 ? 893234971
                   <= param
                   ? 1034456810
                     <= param
                     ? 1052164689 <= param ? 408 : 307
                     : 897427648 <= param ? 417 : 206
                   : 807430278 <= param ? 428 : 410
                 : 565592383
                   <= param
                   ? 731537414
                     <= param
                     ? 751586522 <= param ? 414 : 504
                     : 566851975 <= param ? 202 : 413
                   : 491839979 <= param ? 418 : 302
               : 102779818
                 <= param
                 ? 260151748
                   <= param
                   ? 324098644
                     <= param
                     ? 384167631 <= param ? 301 : 401
                     : 282375460 <= param ? 412 : 303
                   : 192584839 <= param ? 100 : 203
                 : 17692
                   <= param
                   ? 18898339
                     <= param
                     ? 65414873 <= param ? 429 : 300
                     : 13829438 <= param ? 405 : 200
                   : -12825579 <= param ? 407 : 511
             : -527633381
               <= param
               ? -358247754
                 <= param
                 ? -221106440
                   <= param
                   ? -99004555
                     <= param
                     ? -36288910 <= param ? 409 : 400
                     : -176787538 <= param ? 406 : 411
                   : -234002583 <= param ? 205 : 404
                 : -459143713
                   <= param
                   ? -398446314
                     <= param
                     ? -387970219 <= param ? 304 : 305
                     : -438114087 <= param ? 403 : 415
                   : -498198474 <= param ? 501 : 204
               : -867418942
                 <= param
                 ? -774758938
                   <= param
                   ? -720017128
                     <= param
                     ? -558113336 <= param ? 201 : 402
                     : -732353682 <= param ? 500 : 503
                   : -785212614 <= param ? 420 : 426
                 : -1045236833
                   === param
                   ? 416
                   : -1014316796
                     <= param
                     ? -957501398 <= param ? 502 : 505
                     : -1021676630 <= param ? 101 : 431;
    var c = param[2];
    return c;
   }
   function really_unsafe_of_code(c){
    if(300 <= c)
     if(432 <= c){
      var switcher = c - 500 | 0;
      if(11 >= switcher >>> 0)
       switch(switcher){
         case 0:
          return -732353682;
         case 1:
          return -498198474;
         case 2:
          return -957501398;
         case 3:
          return -774758938;
         case 4:
          return 731537414;
         case 5:
          return -1014316796;
         case 11:
          return -15361451;
       }
     }
     else
      if(308 <= c){
       if(400 <= c)
        switch(c - 400 | 0){
          case 0:
           return -99004555;
          case 1:
           return 324098644;
          case 2:
           return -720017128;
          case 3:
           return -438114087;
          case 4:
           return -358247754;
          case 5:
           return 13829438;
          case 6:
           return -176787538;
          case 7:
           return -12825579;
          case 8:
           return 1052164689;
          case 9:
           return -36288910;
          case 10:
           return 792903807;
          case 11:
           return -221106440;
          case 12:
           return 282375460;
          case 13:
           return 565592383;
          case 14:
           return 751586522;
          case 15:
           return -459143713;
          case 16:
           return -1045236833;
          case 17:
           return 897427648;
          case 18:
           return 491839979;
          case 20:
           return -785212614;
          case 26:
           return -867418942;
          case 28:
           return 807430278;
          case 29:
           return 65414873;
          case 31:
           return -1051942420;
        }
      }
      else
       switch(c - 300 | 0){
         case 0:
          return 18898339;
         case 1:
          return 384167631;
         case 2:
          return 398750242;
         case 3:
          return 260151748;
         case 4:
          return -387970219;
         case 5:
          return -398446314;
         case 6: break;
         default: return 1034456810;
       }
    else{
     var switcher$0 = c - 100 | 0;
     if(1 >= switcher$0 >>> 0) return switcher$0 ? -1021676630 : 192584839;
     var switcher$1 = switcher$0 - 100 | 0;
     if(6 >= switcher$1 >>> 0)
      switch(switcher$1){
        case 0:
         return 17692;
        case 1:
         return -558113336;
        case 2:
         return 566851975;
        case 3:
         return 102779818;
        case 4:
         return -527633381;
        case 5:
         return -234002583;
        default: return 893234971;
      }
    }
    return [0, 748543309, c];
   }
   function unsafe_of_code(c){
    var s = really_unsafe_of_code(c);
    if(typeof s !== "number" && 748543309 === s[1]){
     var c$0 = s[2];
     if(0 <= c$0) return [0, 748543309, c$0];
     var _q_ = caml_call2(Stdlib_Printf[4], _a_, c$0);
     return caml_call1(Stdlib[2], _q_);
    }
    return s;
   }
   function of_code(c){
    var s = really_unsafe_of_code(c);
    if(typeof s !== "number" && 748543309 === s[1]){
     var c$0 = s[2];
     if(100 <= c$0 && 999 >= c$0) return [0, 748543309, c$0];
     var _p_ = caml_call2(Stdlib_Printf[4], _b_, c$0);
     return caml_call1(Stdlib[2], _p_);
    }
    return s;
   }
   function is_informational(t){
    a:
    {
     if(typeof t === "number"){
      if(-1021676630 !== t && 192584839 !== t) break a;
      return 1;
     }
     if(748543309 === t[1]){
      var
       n = t[2],
       _n_ = 100 <= n ? 1 : 0,
       _o_ = _n_ ? n <= 199 ? 1 : 0 : _n_;
      return _o_;
     }
    }
    return 0;
   }
   function is_successful(t){
    a:
    {
     if(typeof t === "number"){
      if(17692 <= t){
       if(566851975 <= t){
        if(893234971 !== t && 566851976 <= t) break a;
       }
       else if(102779818 !== t && 17693 <= t) break a;
      }
      else if(-558113336 !== t && -527633381 !== t && -234002583 !== t)
       break a;
      return 1;
     }
     if(748543309 === t[1]){
      var
       n = t[2],
       _l_ = 200 <= n ? 1 : 0,
       _m_ = _l_ ? n <= 299 ? 1 : 0 : _l_;
      return _m_;
     }
    }
    return 0;
   }
   function is_redirection(t){
    a:
    {
     if(typeof t === "number"){
      if(260151748 <= t){
       if(398750242 <= t){
        if(1034456810 !== t && 398750243 <= t) break a;
       }
       else if(384167631 !== t && 260151749 <= t) break a;
      }
      else if(-398446314 !== t && -387970219 !== t && 18898339 !== t) break a;
      return 1;
     }
     if(748543309 === t[1]){
      var
       n = t[2],
       _j_ = 300 <= n ? 1 : 0,
       _k_ = _j_ ? n <= 399 ? 1 : 0 : _j_;
      return _k_;
     }
    }
    return 0;
   }
   function is_client_error(t){
    a:
    {
     if(typeof t === "number"){
      if(-36288909 <= t){
       if(491839980 <= t){
        if(792903808 <= t){
         if(807430278 !== t && 897427648 !== t && 1052164689 !== t) break a;
        }
        else if(565592383 !== t && 751586522 !== t && 792903807 > t) break a;
       }
       else
        if(65414874 <= t){
         if(282375460 !== t && 324098644 !== t && 491839979 > t) break a;
        }
        else if(-12825579 !== t && 13829438 !== t && 65414873 > t) break a;
      }
      else
       if(-459143712 <= t){
        if(-221106439 <= t){
         if(-176787538 !== t && -99004555 !== t && -36288910 > t) break a;
        }
        else if(-438114087 !== t && -358247754 !== t && -221106440 > t)
         break a;
       }
       else
        if(-867418941 <= t){
         if(-785212614 !== t && -720017128 !== t && -459143713 > t) break a;
        }
        else if(-1051942420 !== t && -1045236833 !== t && -867418942 > t)
         break a;
      return 1;
     }
     if(748543309 === t[1]){
      var
       n = t[2],
       _h_ = 400 <= n ? 1 : 0,
       _i_ = _h_ ? n <= 499 ? 1 : 0 : _h_;
      return _i_;
     }
    }
    return 0;
   }
   function is_server_error(t){
    a:
    {
     if(typeof t === "number"){
      if(-732353682 <= t){
       if(-15361451 <= t){
        if(731537414 !== t && -15361450 <= t) break a;
       }
       else if(-498198474 !== t && -732353681 <= t) break a;
      }
      else if(-1014316796 !== t && -957501398 !== t && -774758938 !== t)
       break a;
      return 1;
     }
     if(748543309 === t[1]){
      var
       n = t[2],
       _f_ = 500 <= n ? 1 : 0,
       _g_ = _f_ ? n <= 599 ? 1 : 0 : _f_;
      return _g_;
     }
    }
    return 0;
   }
   function is_error(t){
    var _e_ = is_client_error(t);
    return _e_ ? _e_ : is_server_error(t);
   }
   function to_string(param){
    if(typeof param === "number")
     return -15361451 <= param
             ? 398750242
               <= param
               ? 792903807
                 <= param
                 ? 893234971
                   <= param
                   ? 1034456810
                     <= param
                     ? 1052164689 <= param ? cst_408 : cst_307
                     : 897427648 <= param ? cst_417 : cst_206
                   : 807430278 <= param ? cst_428 : cst_410
                 : 565592383
                   <= param
                   ? 731537414
                     <= param
                     ? 751586522 <= param ? cst_414 : cst_504
                     : 566851975 <= param ? cst_202 : cst_413
                   : 491839979 <= param ? cst_418 : cst_302
               : 102779818
                 <= param
                 ? 260151748
                   <= param
                   ? 324098644
                     <= param
                     ? 384167631 <= param ? cst_301 : cst_401
                     : 282375460 <= param ? cst_412 : cst_303
                   : 192584839 <= param ? cst_100 : cst_203
                 : 17692
                   <= param
                   ? 18898339
                     <= param
                     ? 65414873 <= param ? cst_429 : cst_300
                     : 13829438 <= param ? cst_405 : cst_200
                   : -12825579 <= param ? cst_407 : cst_511
             : -527633381
               <= param
               ? -358247754
                 <= param
                 ? -221106440
                   <= param
                   ? -99004555
                     <= param
                     ? -36288910 <= param ? cst_409 : cst_400
                     : -176787538 <= param ? cst_406 : cst_411
                   : -234002583 <= param ? cst_205 : cst_404
                 : -459143713
                   <= param
                   ? -398446314
                     <= param
                     ? -387970219 <= param ? cst_304 : cst_305
                     : -438114087 <= param ? cst_403 : cst_415
                   : -498198474 <= param ? cst_501 : cst_204
               : -867418942
                 <= param
                 ? -774758938
                   <= param
                   ? -720017128
                     <= param
                     ? -558113336 <= param ? cst_201 : cst_402
                     : -732353682 <= param ? cst_500 : cst_503
                   : -785212614 <= param ? cst_420 : cst_426
                 : -1045236833
                   === param
                   ? cst_416
                   : -1014316796
                     <= param
                     ? -957501398 <= param ? cst_502 : cst_505
                     : -1021676630 <= param ? cst_101 : cst_431;
    var c = param[2];
    return caml_call1(Stdlib[33], c);
   }
   function of_string(x){return of_code(runtime.caml_int_of_string(x));}
   function pp_hum(fmt, t){
    var _d_ = to_code(t);
    return caml_call3(Stdlib_Format[137], fmt, _c_, _d_);
   }
   var
    Dream_httpaf_Status =
      [0,
       default_reason_phrase,
       to_code,
       really_unsafe_of_code,
       unsafe_of_code,
       of_code,
       is_informational,
       is_successful,
       is_redirection,
       is_client_error,
       is_server_error,
       is_error,
       to_string,
       of_string,
       pp_hum];
   runtime.caml_register_global
    (100, Dream_httpaf_Status, "Dream_httpaf___Status");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Headers
//# unitInfo: Requires: Stdlib, Stdlib__Buffer, Stdlib__Format, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst$3 = "\r\n",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ": ",
    cst$0 = cst$3,
    cst$1 = cst$3,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    _a_ =
      [0,
       [18,
        [1, [0, 0, cst$2]],
        [12, 40, [3, 0, [12, 32, [3, 0, [12, 41, [17, 0, 0]]]]]]],
       "@[(%S %S)@]"],
    _b_ = [0, [18, [1, [0, 0, cst$2]], [12, 40, 0]], "@[("],
    _c_ = [0, [12, 41, [17, 0, 0]], ")@]"],
    cst_Dream_httpaf_Headers_Local = "Dream_httpaf___Headers.Local",
    empty = 0;
   function of_rev_list(t){return t;}
   function of_list(t){return caml_call1(Stdlib_List[10], t);}
   function to_rev_list(t){return t;}
   function to_list(t){return caml_call1(Stdlib_List[10], t);}
   function ci_equal(x, y){
    var
     len = caml_ml_string_length(x),
     _o_ = len === caml_ml_string_length(y) ? 1 : 0;
    if(_o_){
     var equal_so_far = [0, 1], i = [0, 0];
     for(;;){
      if(equal_so_far[1] && i[1] < len){
       var
        c1 = caml_string_unsafe_get(x, i[1]),
        c2 = caml_string_unsafe_get(y, i[1]),
        codes = c1 << 8 | c2,
        b = 32896 | codes,
        c = b - 24929 | 0,
        d = caml_call1(Stdlib[21], b - 31611 | 0),
        e = c & d & caml_call1(Stdlib[21], codes) & 32896,
        upper = codes - (e >>> 2 | 0) | 0;
       equal_so_far[1] = (upper >>> 8 | 0) === (upper & 255) ? 1 : 0;
       i[1]++;
       continue;
      }
      var _p_ = equal_so_far[1];
      break;
     }
    }
    else
     var _p_ = _o_;
    return _p_;
   }
   function mem(t, name){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], name$0 = t$0[1][1], _n_ = ci_equal(name, name$0);
     if(_n_) return _n_;
     var t$0 = t$1;
    }
   }
   function add(t, name, value){return [0, [0, name, value], t];}
   function add_list(t, ls){return caml_call2(Stdlib[37], ls, t);}
   function add_multi(t, lss){
    var t$0 = t, lss$0 = lss;
    for(;;){
     if(! lss$0) return t$0;
     var
      lss$1 = lss$0[2],
      match = lss$0[1],
      vs = match[2],
      n = match[1],
      t$1 = t$0,
      vs$0 = vs;
     for(;;){
      if(! vs$0) break;
      var
       vs$1 = vs$0[2],
       v = vs$0[1],
       t$2 = [0, [0, n, v], t$1],
       t$1 = t$2,
       vs$0 = vs$1;
     }
     var t$0 = t$1, lss$0 = lss$1;
    }
   }
   function add_unless_exists(t, name, value){
    return mem(t, name) ? t : [0, [0, name, value], t];
   }
   var
    Local = [248, cst_Dream_httpaf_Headers_Local, runtime.caml_fresh_oo_id(0)];
   function replace(t, name, value){
    function loop(t, needle, nv, seen){
     var t$0 = t, seen$0 = seen;
     for(;;){
      if(! t$0){
       if(seen$0) return 0;
       throw caml_maybe_attach_backtrace(Local, 1);
      }
      var t$1 = t$0[2], nv$0 = t$0[1], name = nv$0[1];
      if(! ci_equal(needle, name))
       return [0, nv$0, loop(t$1, needle, nv, seen$0)];
      if(! seen$0) return [0, nv, loop(t$1, needle, nv, 1)];
      var t$0 = t$1, seen$0 = 1;
     }
    }
    try{var _l_ = loop(t, name, [0, name, value], 0); return _l_;}
    catch(_m_){
     var _k_ = caml_wrap_exception(_m_);
     if(_k_ === Local) return t;
     throw caml_maybe_attach_backtrace(_k_, 0);
    }
   }
   function remove(t, name){
    function loop(s, needle, seen){
     var s$0 = s, seen$0 = seen;
     for(;;){
      if(! s$0){
       if(seen$0) return 0;
       throw caml_maybe_attach_backtrace(Local, 1);
      }
      var s$1 = s$0[2], nv = s$0[1], name = nv[1];
      if(! ci_equal(needle, name)) return [0, nv, loop(s$1, needle, seen$0)];
      var s$0 = s$1, seen$0 = 1;
     }
    }
    try{var _i_ = loop(t, name, 0); return _i_;}
    catch(_j_){
     var _h_ = caml_wrap_exception(_j_);
     if(_h_ === Local) return t;
     throw caml_maybe_attach_backtrace(_h_, 0);
    }
   }
   function get(t, name){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], match = t$0[1], v = match[2], n = match[1];
     if(ci_equal(name, n)) return [0, v];
     var t$0 = t$1;
    }
   }
   function get_exn(t, name){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var t$1 = t$0[2], match = t$0[1], v = match[2], n = match[1];
     if(ci_equal(name, n)) return v;
     var t$0 = t$1;
    }
   }
   function get_multi(t, name){
    var t$0 = t, acc = 0;
    for(;;){
     if(! t$0) return acc;
     var t$1 = t$0[2], match = t$0[1], v = match[2], n = match[1];
     if(ci_equal(name, n))
      var acc$0 = [0, v, acc], t$0 = t$1, acc = acc$0;
     else
      var t$0 = t$1;
    }
   }
   function iter(f, t){
    function _g_(param){
     var value = param[2], name = param[1];
     return caml_call2(f, name, value);
    }
    return caml_call2(Stdlib_List[18], _g_, t);
   }
   function fold(f, init, t){
    function _f_(acc, param){
     var value = param[2], name = param[1];
     return caml_call3(f, name, value, acc);
    }
    return caml_call3(Stdlib_List[26], _f_, init, t);
   }
   function to_string(t){
    var b = caml_call1(Stdlib_Buffer[1], 128), _e_ = to_list(t);
    iter
     (function(name, value){
       caml_call2(Stdlib_Buffer[16], b, name);
       caml_call2(Stdlib_Buffer[16], b, cst);
       caml_call2(Stdlib_Buffer[16], b, value);
       return caml_call2(Stdlib_Buffer[16], b, cst$0);
      },
      _e_);
    caml_call2(Stdlib_Buffer[16], b, cst$1);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function pp_hum(fmt, t){
    function pp_elem(fmt, param){
     var v = param[2], n = param[1];
     return caml_call4(Stdlib_Format[137], fmt, _a_, n, v);
    }
    caml_call2(Stdlib_Format[137], fmt, _b_);
    var _d_ = to_list(t);
    caml_call4(Stdlib_Format[130], 0, pp_elem, fmt, _d_);
    return caml_call2(Stdlib_Format[137], fmt, _c_);
   }
   var
    Dream_httpaf_Headers =
      [0,
       ci_equal,
       empty,
       of_list,
       of_rev_list,
       to_list,
       to_rev_list,
       add,
       add_unless_exists,
       add_list,
       add_multi,
       remove,
       replace,
       mem,
       get,
       get_exn,
       get_multi,
       iter,
       fold,
       to_string,
       pp_hum];
   runtime.caml_register_global
    (11, Dream_httpaf_Headers, "Dream_httpaf___Headers");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___IOVec
//# unitInfo: Requires: Stdlib, Stdlib__Format, Stdlib__List, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    _c_ =
      [0,
       [11,
        "{ buffer = <opaque>; off = ",
        [4, 0, 0, 0, [11, "; len = ", [4, 0, 0, 0, [11, " }", 0]]]]],
       "{ buffer = <opaque>; off = %d; len = %d }"],
    cst_shiftv_n_lengthv_iovecs = "shiftv: n > lengthv iovecs",
    _b_ =
      [0,
       [11, "IOVec.shiftv: ", [4, 0, 0, 0, [11, " is a negative number", 0]]],
       "IOVec.shiftv: %d is a negative number"],
    _a_ = [0, "src/vendor/httpaf/lib/iOVec.ml", 44, 2];
   function length(param){var len = param[3]; return len;}
   function lengthv(iovs){
    var _e_ = 0;
    function _f_(acc, param){var len = param[3]; return acc + len | 0;}
    return caml_call3(Stdlib_List[26], _f_, _e_, iovs);
   }
   function shift(param, n){
    var len = param[3], off = param[2], buffer = param[1];
    if(n <= len) return [0, buffer, off + n | 0, len - n | 0];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function shiftv(iovecs, n){
    if(n < 0){
     var _d_ = caml_call2(Stdlib_Printf[4], _b_, n);
     caml_call1(Stdlib[2], _d_);
    }
    var iovecs$0 = iovecs, n$0 = n;
    for(;;){
     if(0 === n$0) return iovecs$0;
     if(! iovecs$0) return caml_call1(Stdlib[2], cst_shiftv_n_lengthv_iovecs);
     var iovecs$1 = iovecs$0[2], iovec = iovecs$0[1], iovec_len = iovec[3];
     if(iovec_len > n$0) return [0, shift(iovec, n$0), iovecs$1];
     var n$1 = n$0 - iovec_len | 0, iovecs$0 = iovecs$1, n$0 = n$1;
    }
   }
   function add_len(param, n){
    var len = param[3], off = param[2], buffer = param[1];
    return [0, buffer, off, len + n | 0];
   }
   function pp_hum(fmt, t){
    return caml_call4(Stdlib_Format[137], fmt, _c_, t[2], t[3]);
   }
   var
    Dream_httpaf_IOVec = [0, length, lengthv, shift, shiftv, add_len, pp_hum];
   runtime.caml_register_global(9, Dream_httpaf_IOVec, "Dream_httpaf___IOVec");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Message
//# unitInfo: Requires: Dream_httpaf___Headers, Dream_httpaf___Version, Stdlib__Int64, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_httpaf_Headers = global_data.Dream_httpaf___Headers,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Dream_httpaf_Version = global_data.Dream_httpaf___Version,
    _a_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    cst_content_length = "content-length",
    cst_connection = "connection";
   function persistent_connection(opt, version, headers){
    var match = caml_call2(Dream_httpaf_Headers[14], headers, cst_connection);
    if(match){
     var _d_ = match[1];
     if(! caml_string_notequal(_d_, "close")) return 0;
     if(! caml_string_notequal(_d_, "keep-alive"))
      return 0
              <=
               caml_call2
                (Dream_httpaf_Version[4], version, Dream_httpaf_Version[1])
              ? 1
              : 0;
    }
    return 0
            <=
             caml_call2
              (Dream_httpaf_Version[4], version, Dream_httpaf_Version[2])
            ? 1
            : 0;
   }
   function sort_uniq(xs){
    if(xs && xs[2]) return caml_call2(Stdlib_List[62], Stdlib_String[10], xs);
    return xs;
   }
   function unique_content_length_values(headers){
    return sort_uniq
            (caml_call2(Dream_httpaf_Headers[16], headers, cst_content_length));
   }
   function content_length_of_string(s){
    try{var _b_ = runtime.caml_int64_of_string(s); return _b_;}
    catch(_c_){return _a_;}
   }
   var
    Dream_httpaf_Message =
      [0,
       persistent_connection,
       sort_uniq,
       unique_content_length_values,
       content_length_of_string];
   runtime.caml_register_global
    (9, Dream_httpaf_Message, "Dream_httpaf___Message");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Method
//# unitInfo: Requires: Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_CONNECT$0 = "CONNECT",
    cst_DELETE$0 = "DELETE",
    cst_GET$0 = "GET",
    cst_HEAD$0 = "HEAD",
    cst_OPTIONS$0 = "OPTIONS",
    cst_POST$0 = "POST",
    cst_PUT$0 = "PUT",
    cst_TRACE$0 = "TRACE",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    _a_ = [0, [2, 0, 0], "%s"],
    cst_POST = cst_POST$0,
    cst_HEAD = cst_HEAD$0,
    cst_DELETE = cst_DELETE$0,
    cst_CONNECT = cst_CONNECT$0,
    cst_TRACE = cst_TRACE$0,
    cst_PUT = cst_PUT$0,
    cst_GET = cst_GET$0,
    cst_OPTIONS = cst_OPTIONS$0;
   function is_safe(param){
    a:
    if(typeof param === "number"){
     if(3546231 <= param){
      if(336447077 !== param && 801894688 !== param) break a;
     }
     else if(-539883714 !== param && 3546230 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_cacheable(param){
    a:
    if(typeof param === "number"){
     if(3546230 !== param && 801894688 !== param && 891112544 !== param)
      break a;
     return 1;
    }
    return 0;
   }
   function is_idempotent(t){
    a:
    if(typeof t === "number"){
     if(3997359 !== t && 492530731 !== t) break a;
     return 1;
    }
    return is_safe(t);
   }
   function to_string(param){
    if(typeof param === "number")
     return 357830602 <= param
             ? 801894688
               <= param
               ? 891112544 <= param ? cst_POST : cst_HEAD
               : 492530731 <= param ? cst_DELETE : cst_CONNECT
             : 3997359
               <= param
               ? 336447077 <= param ? cst_TRACE : cst_PUT
               : 3546230 <= param ? cst_GET : cst_OPTIONS;
    var s = param[2];
    return s;
   }
   function of_string(s){
    return caml_string_notequal(s, cst_CONNECT$0)
            ? caml_string_notequal
               (s, cst_DELETE$0)
              ? caml_string_notequal
                 (s, cst_GET$0)
                ? caml_string_notequal
                   (s, cst_HEAD$0)
                  ? caml_string_notequal
                     (s, cst_OPTIONS$0)
                    ? caml_string_notequal
                       (s, cst_POST$0)
                      ? caml_string_notequal
                         (s, cst_PUT$0)
                        ? caml_string_notequal
                           (s, cst_TRACE$0)
                          ? [0, -912009552, s]
                          : 336447077
                        : 3997359
                      : 891112544
                    : -539883714
                  : 801894688
                : 3546230
              : 492530731
            : 357830602;
   }
   function pp_hum(fmt, t){
    var _b_ = to_string(t);
    return caml_call3(Stdlib_Format[137], fmt, _a_, _b_);
   }
   var
    Dream_httpaf_Method =
      [0, is_safe, is_cacheable, is_idempotent, to_string, of_string, pp_hum];
   runtime.caml_register_global
    (18, Dream_httpaf_Method, "Dream_httpaf___Method");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Optional_thunk
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    cst_Optional_thunk_this_functi =
      "Optional_thunk: this function is not representable as a some value";
   function none(param){return 0;}
   function some(f){
    if(f === none) caml_call1(Stdlib[2], cst_Optional_thunk_this_functi);
    return f;
   }
   function is_none(t){return t === none ? 1 : 0;}
   function is_some(t){return 1 - is_none(t);}
   function call_if_some(t){return caml_call1(t, 0);}
   function unchecked_value(t){return t;}
   var
    Dream_httpaf_Optional_thunk =
      [0, none, some, is_none, is_some, call_if_some, unchecked_value];
   runtime.caml_register_global
    (2, Dream_httpaf_Optional_thunk, "Dream_httpaf___Optional_thunk");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Request
//# unitInfo: Requires: Dream_httpaf___Headers, Dream_httpaf___Message, Dream_httpaf___Method, Dream_httpaf___Version, Stdlib__Format, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    bad_request = [0, 106380200, -99004555],
    Dream_httpaf_Headers = global_data.Dream_httpaf___Headers,
    Dream_httpaf_Version = global_data.Dream_httpaf___Version,
    Dream_httpaf_Method = global_data.Dream_httpaf___Method,
    Stdlib_Format = global_data.Stdlib__Format,
    Dream_httpaf_Message = global_data.Dream_httpaf___Message,
    Stdlib_List = global_data.Stdlib__List,
    _d_ =
      [0,
       [11,
        '((method "',
        [15,
         [11,
          '") (target ',
          [3,
           0,
           [11,
            ') (version "',
            [15, [11, '") (headers ', [15, [11, "))", 0]]]]]]]]],
       '((method "%a") (target %S) (version "%a") (headers %a))'],
    cst_transfer_encoding = "transfer-encoding",
    cst_chunked = "chunked",
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _c_ = [0, 332360020, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    cst_Chunked = "Chunked",
    _a_ = [0, [11, "Fixed ", [7, 3, 0, 0, 0]], "Fixed %Li"],
    cst_Error_Bad_request = "Error: Bad request";
   function create(opt, _f_, meth, target){
    if(opt)
     var sth = opt[1], version = sth;
    else
     var version = Dream_httpaf_Version[2];
    if(_f_)
     var sth$0 = _f_[1], headers = sth$0;
    else
     var headers = Dream_httpaf_Headers[2];
    return [0, meth, target, version, headers];
   }
   function pp_hum(fmt, len){
    if(typeof len === "number")
     return caml_call2(Stdlib_Format[13], fmt, cst_Chunked);
    if(332360020 > len[1])
     return caml_call2(Stdlib_Format[13], fmt, cst_Error_Bad_request);
    var n = len[2];
    return caml_call3(Stdlib_Format[137], fmt, _a_, n);
   }
   var Body_length = [0, pp_hum];
   function body_length(param){
    var
     headers = param[4],
     _e_ =
       caml_call2(Dream_httpaf_Headers[16], headers, cst_transfer_encoding),
     match = caml_call1(Stdlib_List[10], _e_);
    if(match){
     var value = match[1];
     return caml_call2(Dream_httpaf_Headers[1], value, cst_chunked)
             ? 505707500
             : bad_request;
    }
    var match$0 = caml_call1(Dream_httpaf_Message[3], headers);
    if(! match$0) return _c_;
    if(match$0[2]) return bad_request;
    var len = match$0[1], len$0 = caml_call1(Dream_httpaf_Message[4], len);
    return runtime.caml_greaterequal(len$0, _b_)
            ? [0, 332360020, len$0]
            : bad_request;
   }
   function persistent_connection(proxy, param){
    var headers = param[4], version = param[3];
    return caml_call3(Dream_httpaf_Message[1], proxy, version, headers);
   }
   function pp_hum$0(fmt, param){
    var
     headers = param[4],
     version = param[3],
     target = param[2],
     meth = param[1];
    return caml_call9
            (Stdlib_Format[137],
             fmt,
             _d_,
             Dream_httpaf_Method[6],
             meth,
             target,
             Dream_httpaf_Version[7],
             version,
             Dream_httpaf_Headers[20],
             headers);
   }
   var
    Dream_httpaf_Request =
      [0,
       create,
       bad_request,
       Body_length,
       body_length,
       persistent_connection,
       pp_hum$0];
   runtime.caml_register_global
    (15, Dream_httpaf_Request, "Dream_httpaf___Request");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Response
//# unitInfo: Requires: Dream_httpaf___Headers, Dream_httpaf___Message, Dream_httpaf___Status, Dream_httpaf___Version, Stdlib__Format, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    proxy_error = [0, 106380200, -957501398],
    server_error = [0, 106380200, -732353682],
    Dream_httpaf_Headers = global_data.Dream_httpaf___Headers,
    Dream_httpaf_Status = global_data.Dream_httpaf___Status,
    Dream_httpaf_Version = global_data.Dream_httpaf___Version,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_List = global_data.Stdlib__List,
    Dream_httpaf_Message = global_data.Dream_httpaf___Message,
    _f_ =
      [0,
       [11,
        '((version "',
        [15,
         [11,
          '") (status ',
          [15,
           [11,
            ") (reason ",
            [3, 0, [11, ") (headers ", [15, [11, "))", 0]]]]]]]]],
       '((version "%a") (status %a) (reason %S) (headers %a))'],
    _b_ = [0, 332360020, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    _d_ = [0, 332360020, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    cst_transfer_encoding = "transfer-encoding",
    cst_chunked = "chunked",
    _e_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _c_ = [0, 332360020, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    cst_Close_delimited = "Close delimited",
    cst_Chunked = "Chunked",
    _a_ = [0, [11, "Fixed ", [7, 3, 0, 0, 0]], "Fixed %Li"],
    cst_Error_Internal_server_erro = "Error: Internal server error",
    cst_Error_Bad_gateway = "Error: Bad gateway",
    cst_Non_standard_status_code = "Non-standard status code";
   function create(reason, opt, _h_, status){
    if(opt)
     var sth = opt[1], version = sth;
    else
     var version = Dream_httpaf_Version[2];
    if(_h_)
     var sth$0 = _h_[1], headers = sth$0;
    else
     var headers = Dream_httpaf_Headers[2];
    if(reason)
     var reason$0 = reason[1], reason$1 = reason$0;
    else
     var
      reason$1 =
        typeof status === "number"
         ? caml_call1(Dream_httpaf_Status[1], status)
         : cst_Non_standard_status_code;
    return [0, version, status, reason$1, headers];
   }
   function persistent_connection(proxy, param){
    var headers = param[4], version = param[1];
    return caml_call3(Dream_httpaf_Message[1], proxy, version, headers);
   }
   function pp_hum(fmt, len){
    if(typeof len === "number")
     return 536442962 <= len
             ? caml_call2(Stdlib_Format[13], fmt, cst_Close_delimited)
             : caml_call2(Stdlib_Format[13], fmt, cst_Chunked);
    if(332360020 > len[1])
     return -732353682 <= len[2]
             ? caml_call2
               (Stdlib_Format[13], fmt, cst_Error_Internal_server_erro)
             : caml_call2(Stdlib_Format[13], fmt, cst_Error_Bad_gateway);
    var n = len[2];
    return caml_call3(Stdlib_Format[137], fmt, _a_, n);
   }
   var Body_length = [0, pp_hum];
   function body_length(opt, request_method, param){
    if(opt) var sth = opt[1], proxy = sth; else var proxy = 0;
    var headers = param[4], status = param[2];
    if(typeof request_method === "number" && 801894688 === request_method)
     return _b_;
    a:
    if(typeof status === "number"){
     if(-527633381 !== status && -387970219 !== status) break a;
     return _c_;
    }
    if(caml_call1(Dream_httpaf_Status[6], status)) return _d_;
    if
     (typeof request_method === "number"
      &&
       357830602 === request_method
       && caml_call1(Dream_httpaf_Status[7], status))
     return 536442962;
    var
     _g_ =
       caml_call2(Dream_httpaf_Headers[16], headers, cst_transfer_encoding),
     match = caml_call1(Stdlib_List[10], _g_);
    if(match){
     var value = match[1];
     return caml_call2(Dream_httpaf_Headers[1], value, cst_chunked)
             ? 505707500
             : 536442962;
    }
    var match$0 = caml_call1(Dream_httpaf_Message[3], headers);
    if(! match$0) return 536442962;
    if(match$0[2]) return proxy ? proxy_error : server_error;
    var len = match$0[1], len$0 = caml_call1(Dream_httpaf_Message[4], len);
    return runtime.caml_greaterequal(len$0, _e_)
            ? [0, 332360020, len$0]
            : proxy ? proxy_error : server_error;
   }
   function pp_hum$0(fmt, param){
    var
     headers = param[4],
     reason = param[3],
     status = param[2],
     version = param[1];
    return caml_call9
            (Stdlib_Format[137],
             fmt,
             _f_,
             Dream_httpaf_Version[7],
             version,
             Dream_httpaf_Status[14],
             status,
             reason,
             Dream_httpaf_Headers[20],
             headers);
   }
   var
    Dream_httpaf_Response =
      [0,
       create,
       persistent_connection,
       proxy_error,
       server_error,
       Body_length,
       body_length,
       pp_hum$0];
   runtime.caml_register_global
    (21, Dream_httpaf_Response, "Dream_httpaf___Response");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Serialize
//# unitInfo: Requires: Bigstringaf, Dream_httpaf___Headers, Dream_httpaf___IOVec, Dream_httpaf___Method, Dream_httpaf___Optional_thunk, Dream_httpaf___Status, Dream_httpaf___Version, Faraday, Stdlib, Stdlib__List, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = ": ",
    cst = "\r\n",
    Faraday = global_data.Faraday,
    Dream_httpaf_Optional_thunk = global_data.Dream_httpaf___Optional_thunk,
    Stdlib = global_data.Stdlib,
    Dream_httpaf_IOVec = global_data.Dream_httpaf___IOVec,
    Stdlib_List = global_data.Stdlib__List,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Dream_httpaf_Headers = global_data.Dream_httpaf___Headers,
    Dream_httpaf_Status = global_data.Dream_httpaf___Status,
    Dream_httpaf_Method = global_data.Dream_httpaf___Method,
    Dream_httpaf_Version = global_data.Dream_httpaf___Version,
    cst_on_wakeup_on_closed_writer = "on_wakeup on closed writer",
    cst_on_wakeup_only_one_callbac =
      "on_wakeup: only one callback can be registered at a time",
    _a_ = [0, [4, 6, 0, 0, 0], "%x"];
   function write_space(t){return caml_call2(Faraday[7], t, 32);}
   function write_crlf(t){return caml_call4(Faraday[3], t, 0, 0, cst);}
   function write_version(t, version){
    var _h_ = caml_call1(Dream_httpaf_Version[5], version);
    return caml_call4(Faraday[3], t, 0, 0, _h_);
   }
   function write_method(t, meth){
    var _g_ = caml_call1(Dream_httpaf_Method[4], meth);
    return caml_call4(Faraday[3], t, 0, 0, _g_);
   }
   function write_status(t, status){
    var _f_ = caml_call1(Dream_httpaf_Status[12], status);
    return caml_call4(Faraday[3], t, 0, 0, _f_);
   }
   function write_headers(t, headers){
    var _d_ = caml_call1(Dream_httpaf_Headers[5], headers);
    function _e_(param){
     var value = param[2], name = param[1];
     caml_call4(Faraday[3], t, 0, 0, name);
     caml_call4(Faraday[3], t, 0, 0, cst$0);
     caml_call4(Faraday[3], t, 0, 0, value);
     return write_crlf(t);
    }
    caml_call2(Stdlib_List[18], _e_, _d_);
    return write_crlf(t);
   }
   function write_request(t, param){
    var
     headers = param[4],
     version = param[3],
     target = param[2],
     meth = param[1];
    write_method(t, meth);
    write_space(t);
    caml_call4(Faraday[3], t, 0, 0, target);
    write_space(t);
    write_version(t, version);
    write_crlf(t);
    return write_headers(t, headers);
   }
   function write_response(t, param){
    var
     headers = param[4],
     reason = param[3],
     status = param[2],
     version = param[1];
    write_version(t, version);
    write_space(t);
    write_status(t, status);
    write_space(t);
    caml_call4(Faraday[3], t, 0, 0, reason);
    write_crlf(t);
    return write_headers(t, headers);
   }
   function write_chunk_length(t, len){
    var _c_ = caml_call2(Stdlib_Printf[4], _a_, len);
    caml_call4(Faraday[3], t, 0, 0, _c_);
    return write_crlf(t);
   }
   function write_string_chunk(t, chunk){
    write_chunk_length(t, runtime.caml_ml_string_length(chunk));
    caml_call4(Faraday[3], t, 0, 0, chunk);
    return write_crlf(t);
   }
   function write_bigstring_chunk(t, chunk){
    write_chunk_length(t, caml_call1(Bigstringaf[6], chunk));
    caml_call4(Faraday[5], t, 0, 0, chunk);
    return write_crlf(t);
   }
   function schedule_bigstring_chunk(t, chunk){
    write_chunk_length(t, caml_call1(Bigstringaf[6], chunk));
    caml_call4(Faraday[11], t, 0, 0, chunk);
    return write_crlf(t);
   }
   function create(opt, param){
    if(opt) var sth = opt[1], buffer_size = sth; else var buffer_size = 2048;
    var
     buffer = caml_call1(Bigstringaf[1], buffer_size),
     encoder = caml_call1(Faraday[2], buffer);
    return [0, buffer, encoder, 0, Dream_httpaf_Optional_thunk[1]];
   }
   function faraday(t){return t[2];}
   function write_request$0(t, request){return write_request(t[2], request);}
   function write_response$0(t, response){
    return write_response(t[2], response);
   }
   function write_string(t, off, len, string){
    return caml_call4(Faraday[3], t[2], off, len, string);
   }
   function write_bytes(t, off, len, bytes){
    return caml_call4(Faraday[4], t[2], off, len, bytes);
   }
   function write_bigstring(t, off, len, bigstring){
    return caml_call4(Faraday[5], t[2], off, len, bigstring);
   }
   function schedule_bigstring(t, off, len, bigstring){
    return caml_call4(Faraday[11], t[2], off, len, bigstring);
   }
   function schedule_fixed(t, iovecs){
    function _b_(param){
     var len = param[3], off = param[2], buffer = param[1];
     return schedule_bigstring(t, [0, off], [0, len], buffer);
    }
    return caml_call2(Stdlib_List[18], _b_, iovecs);
   }
   function schedule_chunk(t, iovecs){
    var length = caml_call1(Dream_httpaf_IOVec[2], iovecs);
    write_chunk_length(t[2], length);
    schedule_fixed(t, iovecs);
    return write_crlf(t[2]);
   }
   function on_wakeup(t, k){
    return caml_call1(Faraday[20], t[2])
            ? caml_call1(Stdlib[2], cst_on_wakeup_on_closed_writer)
            : caml_call1
               (Dream_httpaf_Optional_thunk[4], t[4])
              ? caml_call1(Stdlib[2], cst_on_wakeup_only_one_callbac)
              : (t[4] = caml_call1(Dream_httpaf_Optional_thunk[2], k), 0);
   }
   function wakeup(t){
    var f = t[4];
    t[4] = Dream_httpaf_Optional_thunk[1];
    return caml_call1(Dream_httpaf_Optional_thunk[5], f);
   }
   function flush(t, f){return caml_call2(Faraday[16], t[2], f);}
   function unyield(t){return flush(t, function(param){return 0;});}
   function yield$0(t){return caml_call1(Faraday[15], t[2]);}
   function close(t){return caml_call1(Faraday[19], t[2]);}
   function close_and_drain(t){
    caml_call1(Faraday[19], t[2]);
    var drained = caml_call1(Faraday[22], t[2]);
    t[3] = t[3] + drained | 0;
    return wakeup(t);
   }
   function is_closed(t){return caml_call1(Faraday[20], t[2]);}
   function drained_bytes(t){return t[3];}
   function report_result(t, result){
    if(typeof result === "number") return close_and_drain(t);
    var len = result[2];
    return caml_call2(Faraday[21], t[2], len);
   }
   function next(t){
    var match = caml_call1(Faraday[23], t[2]);
    if(typeof match === "number")
     return 73271853 <= match ? 73271853 : [0, -611285096, t[3]];
    var iovecs = match[2];
    return [0, -477700929, iovecs];
   }
   var
    Writer =
      [0,
       create,
       faraday,
       write_request$0,
       write_response$0,
       write_string,
       write_bytes,
       write_bigstring,
       schedule_bigstring,
       schedule_fixed,
       schedule_chunk,
       on_wakeup,
       wakeup,
       flush,
       unyield,
       yield$0,
       close,
       close_and_drain,
       is_closed,
       drained_bytes,
       report_result,
       next],
    Dream_httpaf_Serialize =
      [0,
       write_space,
       write_crlf,
       write_version,
       write_method,
       write_status,
       write_headers,
       write_request,
       write_response,
       write_chunk_length,
       write_string_chunk,
       write_bigstring_chunk,
       schedule_bigstring_chunk,
       Writer];
   runtime.caml_register_global
    (16, Dream_httpaf_Serialize, "Dream_httpaf___Serialize");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Body
//# unitInfo: Requires: Bigstringaf, Dream_httpaf___IOVec, Dream_httpaf___Optional_thunk, Dream_httpaf___Serialize, Faraday, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Faraday = global_data.Faraday,
    Dream_httpaf_Serialize = global_data.Dream_httpaf___Serialize,
    Dream_httpaf_IOVec = global_data.Dream_httpaf___IOVec,
    Bigstringaf = global_data.Bigstringaf,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Dream_httpaf_Optional_thunk = global_data.Dream_httpaf___Optional_thunk,
    _b_ = [0, 332360020, 0],
    _a_ = [0, "src/vendor/httpaf/lib/body.ml", 81, 26],
    cst_Body_schedule_read_reader_ =
      "Body.schedule_read: reader already scheduled";
   function default_on_eof(param){return 0;}
   function default_on_read(param, _p_, _o_){return 0;}
   function create(buffer, when_ready_to_read){
    return [0,
            caml_call1(Faraday[2], buffer),
            0,
            default_on_eof,
            0,
            default_on_read,
            when_ready_to_read];
   }
   function create_empty(param){
    var t = create(Bigstringaf[2], Dream_httpaf_Optional_thunk[1]);
    caml_call1(Faraday[19], t[1]);
    return t;
   }
   function is_closed(t){return caml_call1(Faraday[20], t[1]);}
   function unsafe_faraday(t){return t[1];}
   function ready_to_read(t){
    return caml_call1(Dream_httpaf_Optional_thunk[5], t[6]);
   }
   function do_execute_read$0(counter, t, on_eof, on_read){
    var match = caml_call1(Faraday[23], t[1]);
    if(typeof match === "number"){
     if(73271853 <= match) return 0;
     t[2] = 0;
     t[3] = default_on_eof;
     t[5] = default_on_read;
     var _n_ = 1 - t[4];
     return _n_ ? (t[4] = 1, caml_call1(on_eof, 0)) : _n_;
    }
    var match$0 = match[2];
    if(! match$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var iovec = match$0[1];
    t[2] = 0;
    t[3] = default_on_eof;
    t[5] = default_on_read;
    var len = iovec[3], off = iovec[2], buffer = iovec[1];
    caml_call2(Faraday[21], t[1], len);
    caml_call3(on_read, buffer, off, len);
    if(counter >= 50) return caml_trampoline_return(execute_read$0, [0, t]);
    var counter$0 = counter + 1 | 0;
    return execute_read$0(counter$0, t);
   }
   function execute_read$0(counter, t){
    var _k_ = t[2];
    if(! _k_) return _k_;
    var _l_ = t[5], _m_ = t[3];
    if(counter >= 50)
     return caml_trampoline_return(do_execute_read$0, [0, t, _m_, _l_]);
    var counter$0 = counter + 1 | 0;
    return do_execute_read$0(counter$0, t, _m_, _l_);
   }
   function do_execute_read(t, on_eof, on_read){
    return caml_trampoline(do_execute_read$0(0, t, on_eof, on_read));
   }
   function execute_read(t){return caml_trampoline(execute_read$0(0, t));}
   function schedule_read(t, on_eof, on_read){
    if(t[2]) caml_call1(Stdlib[2], cst_Body_schedule_read_reader_);
    if(1 - is_closed(t)){t[2] = 1; t[3] = on_eof; t[5] = on_read;}
    do_execute_read(t, on_eof, on_read);
    return ready_to_read(t);
   }
   function close(t){
    caml_call1(Faraday[19], t[1]);
    execute_read(t);
    return ready_to_read(t);
   }
   function has_pending_output(t){return caml_call1(Faraday[13], t[1]);}
   function is_read_scheduled(t){return t[2];}
   var
    Reader =
      [0,
       default_on_eof,
       default_on_read,
       create,
       create_empty,
       is_closed,
       unsafe_faraday,
       ready_to_read,
       do_execute_read,
       execute_read,
       schedule_read,
       close,
       has_pending_output,
       is_read_scheduled];
   function of_faraday(faraday, encoding, writer){
    a:
    {
     if(typeof encoding === "number" && 536442962 > encoding){var encoding$0 = [0, 0]; break a;}
     var encoding$0 = 0;
    }
    return [0, faraday, encoding$0, writer, [0, 0]];
   }
   function create$0(buffer, encoding){
    var _i_ = caml_call1(Faraday[2], buffer);
    return function(_j_){return of_faraday(_i_, encoding, _j_);};
   }
   function create_empty$0(writer){
    var t = create$0(Bigstringaf[2], _b_)(writer);
    caml_call1(Faraday[19], t[1]);
    return t;
   }
   function write_char(t, c){return caml_call2(Faraday[7], t[1], c);}
   function write_string(t, off, len, s){
    return caml_call4(Faraday[3], t[1], off, len, s);
   }
   function write_bigstring(t, off, len, b){
    return caml_call4(Faraday[5], t[1], off, len, b);
   }
   function schedule_bigstring(t, off, len, b){
    return caml_call4(Faraday[11], t[1], off, len, b);
   }
   function ready_to_write(t){
    return caml_call1(Dream_httpaf_Serialize[13][12], t[3]);
   }
   function flush(t, kontinue){
    function _h_(param){
     return caml_call2(Dream_httpaf_Serialize[13][13], t[3], kontinue);
    }
    caml_call2(Faraday[16], t[1], _h_);
    return ready_to_write(t);
   }
   function is_closed$0(t){return caml_call1(Faraday[20], t[1]);}
   function close$0(t){
    caml_call1(Dream_httpaf_Serialize[13][14], t[3]);
    caml_call1(Faraday[19], t[1]);
    return ready_to_write(t);
   }
   function force_close(t){
    var match = t[2];
    if(match) match[1] = 1;
    return close$0(t);
   }
   function has_pending_output$0(t){
    var faraday_has_output = caml_call1(Faraday[13], t[1]), match = t[2];
    if(match)
     var
      written_final_chunk = match[1],
      _f_ = caml_call1(Faraday[20], t[1]),
      _g_ = _f_ ? 1 - written_final_chunk : _f_,
      additional_encoding_output = _g_;
    else
     var additional_encoding_output = 0;
    var
     faraday_has_output$0 = faraday_has_output || additional_encoding_output;
    return faraday_has_output$0;
   }
   function requires_output(t){
    var _e_ = 1 - is_closed$0(t);
    return _e_ ? _e_ : has_pending_output$0(t);
   }
   function transfer_to_writer(t){
    var faraday = t[1], match = caml_call1(Faraday[23], faraday);
    if(typeof match === "number"){
     if(73271853 <= match) return 0;
     var chunked = t[2];
     if(! chunked) return 0;
     var written_final_chunk = chunked[1], _c_ = 1 - written_final_chunk;
     return _c_
             ? (chunked
                [1]
               = 1,
               caml_call2(Dream_httpaf_Serialize[13][10], t[3], 0))
             : _c_;
    }
    var
     iovecs = match[2],
     buffered = t[4],
     iovecs$0 = caml_call2(Dream_httpaf_IOVec[4], iovecs, buffered[1]);
    if(! iovecs$0) return 0;
    var lengthv = caml_call1(Dream_httpaf_IOVec[2], iovecs$0);
    buffered[1] = buffered[1] + lengthv | 0;
    if(t[2])
     caml_call2(Dream_httpaf_Serialize[13][10], t[3], iovecs$0);
    else
     caml_call2(Dream_httpaf_Serialize[13][9], t[3], iovecs$0);
    function _d_(param){
     caml_call2(Faraday[21], faraday, lengthv);
     buffered[1] = buffered[1] - lengthv | 0;
     return 0;
    }
    return caml_call2(Dream_httpaf_Serialize[13][13], t[3], _d_);
   }
   var
    Writer =
      [0,
       of_faraday,
       create$0,
       create_empty$0,
       write_char,
       write_string,
       write_bigstring,
       schedule_bigstring,
       ready_to_write,
       flush,
       is_closed$0,
       close$0,
       force_close,
       has_pending_output$0,
       requires_output,
       transfer_to_writer],
    Dream_httpaf_Body = [0, Reader, Writer];
   runtime.caml_register_global(10, Dream_httpaf_Body, "Dream_httpaf___Body");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Config
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    default$0 = [0, 4096, 4096, 1024, 4096],
    Dream_httpaf_Config = [0, default$0];
   runtime.caml_register_global
    (1, Dream_httpaf_Config, "Dream_httpaf___Config");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Input_state
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dream_httpaf_Input_state = [0];
   runtime.caml_register_global
    (0, Dream_httpaf_Input_state, "Dream_httpaf___Input_state");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Output_state
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dream_httpaf_Output_state = [0];
   runtime.caml_register_global
    (0, Dream_httpaf_Output_state, "Dream_httpaf___Output_state");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Respd
//# unitInfo: Requires: CamlinternalLazy, Dream_httpaf___Body, Dream_httpaf___Request, Dream_httpaf___Response, Dream_httpaf___Serialize
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_httpaf_Body = global_data.Dream_httpaf___Body,
    Assert_failure = global_data.Assert_failure,
    Dream_httpaf_Serialize = global_data.Dream_httpaf___Serialize,
    Dream_httpaf_Request = global_data.Dream_httpaf___Request,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Dream_httpaf_Response = global_data.Dream_httpaf___Response,
    Request_state = [0],
    _a_ = [0, "src/vendor/httpaf/lib/respd.ml", 71, 4];
   function create
   (error_handler, request, request_body, writer, response_handler){
    var handler = function _l_(_j_, _k_){return _l_.fun(_j_, _k_);}, t = [];
    caml_update_dummy
     (handler,
      function(response, body){
       var _h_ = caml_obj_tag(t);
       a:
       if(250 === _h_)
        var t$0 = t[1];
       else{
        if(246 !== _h_ && 244 !== _h_){var t$0 = t; break a;}
        var t$0 = caml_call1(CamlinternalLazy[2], t);
       }
       if(t$0[8]) t$0[8] = caml_call2(Dream_httpaf_Response[2], 0, response);
       var _i_ = response[2];
       a:
       {
        if(typeof _i_ === "number" && -1021676630 === _i_){var next_state = [1, response]; break a;}
        var next_state = [0, response, body];
       }
       t$0[7] = next_state;
       return caml_call2(response_handler, response, body);
      });
    caml_update_dummy
     (t,
      [246,
       function(param){
        return [0,
                request,
                request_body,
                handler,
                error_handler,
                17724,
                writer,
                0,
                caml_call2(Dream_httpaf_Request[5], 0, request)];
       }]);
    var _g_ = caml_obj_tag(t);
    if(250 === _g_) return t[1];
    if(246 !== _g_ && 244 !== _g_) return t;
    return caml_call1(CamlinternalLazy[2], t);
   }
   function request(param){var request = param[1]; return request;}
   function write_request(t){
    caml_call2(Dream_httpaf_Serialize[13][3], t[6], t[1]);
    t[7] = 1;
    return 0;
   }
   function report_error(t, error){
    t[8] = 0;
    caml_call1(Dream_httpaf_Body[2][12], t[2]);
    var _e_ = t[7], _f_ = t[5];
    a:
    {
     if(typeof _e_ === "number")
      switch(_e_){
        case 0:
         if(typeof _f_ !== "number" && 3458171 === _f_[1])
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         break;
        case 1: break;
        default: break a;
      }
     else if(0 === _e_[0]){
      if(typeof _f_ !== "number") break a;
      if(17724 !== _f_) break a;
      var response_body = _e_[2];
      caml_call1(Dream_httpaf_Body[1][11], response_body);
      t[5] = error;
      return caml_call1(t[4], error);
     }
     if(typeof _f_ === "number" && 17724 === _f_){
      t[7] = 2;
      t[5] = error;
      return caml_call1(t[4], error);
     }
    }
    return 0;
   }
   function persistent_connection(t){return t[8];}
   function close_request_body(t){
    return caml_call1(Dream_httpaf_Body[2][11], t[2]);
   }
   function close_response_body(t){
    var match = t[7];
    if(typeof match === "number") return 0;
    if(0 === match[0]){
     var response_body = match[2];
     return caml_call1(Dream_httpaf_Body[1][11], response_body);
    }
    t[7] = 2;
    return 0;
   }
   function input_state(t){
    var match = t[7];
    if(typeof match === "number"){if(2 !== match) return 0;}
    else if(0 === match[0]){
     var response_body = match[2];
     return caml_call1(Dream_httpaf_Body[1][5], response_body)
             ? 2
             : caml_call1(Dream_httpaf_Body[1][13], response_body) ? 0 : 1;
    }
    return 2;
   }
   function output_state(param){
    var request_body = param[2], state = param[7];
    if(typeof state !== "number" && 1 === state[0]) return 0;
    if(0 !== state && ! caml_call1(Dream_httpaf_Body[2][14], request_body))
     return 2;
    return 1;
   }
   function flush_request_body(param){
    var
     request_body = param[2],
     _d_ = caml_call1(Dream_httpaf_Body[2][13], request_body);
    return _d_ ? caml_call1(Dream_httpaf_Body[2][15], request_body) : _d_;
   }
   function flush_response_body(t){
    var match = t[7];
    if(typeof match !== "number" && 0 === match[0]){
     var
      response_body = match[2],
      _b_ = caml_call1(Dream_httpaf_Body[1][12], response_body);
     if(! _b_) return _b_;
     try{
      var _c_ = caml_call1(Dream_httpaf_Body[1][9], response_body);
      return _c_;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return report_error(t, [0, 3458171, exn]);
     }
    }
    return 0;
   }
   var
    Dream_httpaf_Respd =
      [0,
       Request_state,
       create,
       request,
       write_request,
       report_error,
       persistent_connection,
       close_request_body,
       close_response_body,
       input_state,
       output_state,
       flush_request_body,
       flush_response_body];
   runtime.caml_register_global(7, Dream_httpaf_Respd, "Dream_httpaf___Respd");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Parse
//# unitInfo: Requires: Angstrom, Bigstringaf, CamlinternalLazy, Dream_httpaf___Body, Dream_httpaf___Headers, Dream_httpaf___Method, Dream_httpaf___Optional_thunk, Dream_httpaf___Request, Dream_httpaf___Respd, Dream_httpaf___Response, Dream_httpaf___Status, Faraday, Stdlib, Stdlib__Int64, Stdlib__Printf, Stdlib__Queue, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_vendor_httpaf_lib_pars = "src/vendor/httpaf/lib/parse.ml",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\r\n",
    Angstrom = global_data.Angstrom,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Dream_httpaf_Respd = global_data.Dream_httpaf___Respd,
    Dream_httpaf_Response = global_data.Dream_httpaf___Response,
    Dream_httpaf_Body = global_data.Dream_httpaf___Body,
    Dream_httpaf_Optional_thunk = global_data.Dream_httpaf___Optional_thunk,
    Bigstringaf = global_data.Bigstringaf,
    Dream_httpaf_Request = global_data.Dream_httpaf___Request,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Faraday = global_data.Faraday,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Dream_httpaf_Status = global_data.Dream_httpaf___Status,
    Stdlib_String = global_data.Stdlib__String,
    Dream_httpaf_Headers = global_data.Dream_httpaf___Headers,
    Dream_httpaf_Method = global_data.Dream_httpaf___Method,
    peek_char = Angstrom[1],
    peek_char_fail = Angstrom[2],
    peek_string = Angstrom[3],
    char$0 = Angstrom[4],
    not_char = Angstrom[5],
    any_char = Angstrom[6],
    satisfy = Angstrom[7],
    string = Angstrom[8],
    string_ci = Angstrom[9],
    skip = Angstrom[10],
    skip_while = Angstrom[11],
    take = Angstrom[12],
    take_while = Angstrom[13],
    take_while1 = Angstrom[14],
    take_till = Angstrom[15],
    consumed = Angstrom[16],
    take_bigstring = Angstrom[17],
    take_bigstring_while = Angstrom[18],
    take_bigstring_while1 = Angstrom[19],
    take_bigstring_till = Angstrom[20],
    consumed_bigstring = Angstrom[21],
    advance = Angstrom[22],
    end_of_line = Angstrom[23],
    at_end_of_input = Angstrom[24],
    end_of_input = Angstrom[25],
    scan = Angstrom[26],
    scan_state = Angstrom[27],
    scan_string = Angstrom[28],
    int8 = Angstrom[29],
    any_uint8 = Angstrom[30],
    any_int8 = Angstrom[31],
    BE = Angstrom[32],
    LE = Angstrom[33],
    option = Angstrom[34],
    both = Angstrom[35],
    list = Angstrom[36],
    count = Angstrom[37],
    many = Angstrom[38],
    many1 = Angstrom[39],
    many_till = Angstrom[40],
    sep_by = Angstrom[41],
    sep_by1 = Angstrom[42],
    skip_many = Angstrom[43],
    skip_many1 = Angstrom[44],
    fix = Angstrom[45],
    fix_lazy = Angstrom[46],
    symbol = Angstrom[47],
    choice = Angstrom[48],
    symbol$0 = Angstrom[49],
    commit = Angstrom[50],
    return$0 = Angstrom[51],
    fail = Angstrom[52],
    symbol_bind = Angstrom[53],
    bind = Angstrom[54],
    symbol_map = Angstrom[55],
    symbol$1 = Angstrom[56],
    symbol$2 = Angstrom[57],
    symbol$3 = Angstrom[58],
    symbol$4 = Angstrom[59],
    lift = Angstrom[60],
    lift2 = Angstrom[61],
    lift3 = Angstrom[62],
    lift4 = Angstrom[63],
    map = Angstrom[64],
    map2 = Angstrom[65],
    map3 = Angstrom[66],
    map4 = Angstrom[67],
    Let_syntax = Angstrom[68],
    let$0 = Angstrom[69],
    let$1 = Angstrom[70],
    and = Angstrom[71],
    Unsafe = Angstrom[72],
    Consume = Angstrom[73],
    parse_bigstring = Angstrom[74],
    parse_string = Angstrom[75],
    Buffered = Angstrom[76],
    Unbuffered = Angstrom[77],
    pos = Angstrom[78],
    available = Angstrom[79],
    cst_httpaf_Parse_unable_to_sta = "httpaf.Parse.unable to start parser",
    _D_ = [0, cst_src_vendor_httpaf_lib_pars, 333, 13],
    _z_ = [0, cst_src_vendor_httpaf_lib_pars, 279, 6],
    cst_Local = "Local",
    _C_ = [0, cst_src_vendor_httpaf_lib_pars, 287, 16],
    _A_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _B_ = [0, cst_src_vendor_httpaf_lib_pars, 292, 61],
    _y_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_on_wakeup_on_closed_reader = "on_wakeup on closed reader",
    cst_on_wakeup_only_one_callbac =
      "on_wakeup: only one callback can be registered at a time",
    _v_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _w_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_expected_more_from_body_ch = "expected more from body chunk",
    cst_expected_more_from_fixed_b = "expected more from fixed body",
    cst_status_code_empty = "status-code empty",
    _q_ =
      [0,
       [11, "status-code too long: ", [3, 0, 0]],
       "status-code too long: %S"],
    cst_0x = "0x",
    cst_hex = "hex",
    _b_ = [0, cst_src_vendor_httpaf_lib_pars, 77, 55],
    cst_eol = "eol",
    cst_HTTP = "HTTP/",
    cst_header = "header",
    _x_ = [0, 0];
   function is_space(param){
    if(9 !== param && 32 !== param) return 0;
    return 1;
   }
   function is_cr(param){return 13 === param ? 1 : 0;}
   function is_space_or_colon(param){
    var _aa_ = param - 9 | 0;
    a:
    {
     if(23 < _aa_ >>> 0){
      if(49 === _aa_) break a;
     }
     else if(21 < _aa_ - 1 >>> 0) break a;
     return 0;
    }
    return 1;
   }
   function is_hex(param){
    var _$_ = param - 48 | 0;
    a:
    {
     if(22 < _$_ >>> 0){
      if(5 < _$_ - 49 >>> 0) break a;
     }
     else if(6 >= _$_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function is_separator(param){
    a:
    {
     if(91 <= param){
      var ___ = param - 94 | 0;
      if(30 < ___ >>> 0){if(32 <= ___) break a;} else if(29 !== ___) break a;
     }
     else if(32 <= param){
      if(65 <= param) break a;
      switch(param - 32 | 0){
        case 0:
        case 2:
        case 8:
        case 9:
        case 12:
        case 15:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32: break;
        default: break a;
      }
     }
     else if(9 !== param) break a;
     return 1;
    }
    return 0;
   }
   function is_token(param){
    a:
    {
     if(123 <= param){
      if(126 <= param){
       if(127 !== param) break a;
      }
      else if(124 === param) break a;
     }
     else
      if(65 <= param){
       if(2 < param - 91 >>> 0) break a;
      }
      else{
       var _Z_ = param - 32 | 0;
       if(25 >= _Z_ >>> 0)
        switch(_Z_){
          case 2:
          case 8:
          case 9:
          case 12:
          case 15: break;
          default: break a;
        }
      }
     return 0;
    }
    return 1;
   }
   var
    P =
      [0,
       is_space,
       is_cr,
       is_space_or_colon,
       is_hex,
       is_digit,
       is_separator,
       is_token],
    unit = caml_call1(return$0, 0),
    token = caml_call1(take_while1, P[7]),
    spaces = caml_call1(skip_while, P[1]);
   function _a_(param){
    var switcher = param - 48 | 0;
    if(9 < switcher >>> 0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    switch(switcher){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      case 3:
       return 3;
      case 4:
       return 4;
      case 5:
       return 5;
      case 6:
       return 6;
      case 7:
       return 7;
      case 8:
       return 8;
      default: return 9;
    }
   }
   var
    digit = caml_call2(symbol_map, caml_call1(satisfy, P[5]), _a_),
    eol = caml_call2(symbol$0, caml_call1(string, cst), cst_eol);
   function hex(str){
    try{
     var
      _X_ =
        caml_call1
         (return$0,
          runtime.caml_int64_of_string(caml_call2(Stdlib[28], cst_0x, str)));
     return _X_;
    }
    catch(_Y_){return caml_call1(fail, cst_hex);}
   }
   var
    skip_line = caml_call2(symbol$3, caml_call1(take_till, P[2]), eol),
    _c_ = caml_call2(symbol$4, digit, caml_call1(char$0, 46)),
    _d_ =
      caml_call3
       (lift2, function(major, minor){return [0, major, minor];}, _c_, digit),
    version = caml_call2(symbol$3, caml_call1(string, cst_HTTP), _d_),
    _e_ = Stdlib_String[24],
    _f_ =
      caml_call2
       (symbol_map,
        caml_call2(symbol$4, caml_call1(take_till, P[2]), eol),
        _e_),
    _g_ = caml_call1(char$0, 58),
    _h_ =
      caml_call2
       (symbol$4,
        caml_call2(symbol$4, caml_call1(take_till, P[3]), _g_),
        spaces),
    header =
      caml_call2
       (symbol$0,
        caml_call2
         (symbol$4,
          caml_call3
           (lift2, function(key, value){return [0, key, value];}, _h_, _f_),
          commit),
        cst_header);
   function cons(x, xs){return [0, x, xs];}
   var
    _i_ = Dream_httpaf_Headers[3],
    headers =
      caml_call2
       (symbol_map,
        caml_call1
         (fix,
          function(headers){
           var
            emp = caml_call1(return$0, 0),
            rec = caml_call3(lift2, cons, header, headers);
           return caml_call2
                   (symbol_bind,
                    peek_char_fail,
                    function(param){return 13 === param ? emp : rec;});
          }),
        _i_),
    _j_ = Dream_httpaf_Method[5],
    meth = caml_call2(symbol_map, caml_call1(take_till, P[1]), _j_),
    _k_ = caml_call2(symbol$4, headers, eol),
    _l_ = caml_call2(symbol$4, caml_call2(symbol$4, version, eol), commit),
    _m_ = caml_call1(char$0, 32),
    _n_ = caml_call2(symbol$4, caml_call1(take_till, P[1]), _m_),
    _o_ = caml_call2(symbol$4, meth, caml_call1(char$0, 32)),
    request =
      caml_call5
       (lift4,
        function(meth, target, version, headers){
         return caml_call4
                 (Dream_httpaf_Request[1],
                  [0, version],
                  [0, headers],
                  meth,
                  target);
        },
        _o_,
        _n_,
        _l_,
        _k_);
   function _p_(str){
    return 0 === caml_ml_string_length(str)
            ? caml_call1(fail, cst_status_code_empty)
            : 3
              < caml_ml_string_length(str)
              ? caml_call1(fail, caml_call2(Stdlib_Printf[4], _q_, str))
              : caml_call1(return$0, caml_call1(Dream_httpaf_Status[13], str));
   }
   var
    status = caml_call2(symbol_bind, caml_call1(take_while, P[5]), _p_),
    _r_ = caml_call2(symbol$4, headers, eol),
    _s_ =
      caml_call2
       (symbol$4,
        caml_call2(symbol$4, caml_call1(take_till, P[2]), eol),
        commit),
    _t_ = caml_call2(symbol$4, status, caml_call1(char$0, 32)),
    _u_ = caml_call2(symbol$4, version, caml_call1(char$0, 32)),
    response =
      caml_call5
       (lift4,
        function(version, status, reason, headers){
         return caml_call4
                 (Dream_httpaf_Response[1],
                  [0, reason],
                  [0, version],
                  [0, headers],
                  status);
        },
        _u_,
        _t_,
        _s_,
        _r_);
   function finish(body){
    caml_call1(Dream_httpaf_Body[1][11], body);
    return commit;
   }
   function schedule_size(body, n){
    var faraday = caml_call1(Dream_httpaf_Body[1][6], body);
    if(caml_call1(Faraday[20], faraday))
     var _V_ = caml_call1(advance, n);
    else
     var
      _W_ = function(s){return caml_call4(Faraday[11], faraday, 0, 0, s);},
      _V_ = caml_call2(symbol_map, caml_call1(take_bigstring, n), _W_);
    return caml_call2(symbol$3, _V_, commit);
   }
   function body(encoding, body){
    function fixed(n, unexpected){
     return caml_equal(n, _v_)
             ? unit
             : caml_call2
               (symbol_bind,
                at_end_of_input,
                function(param){
                 return param
                         ? caml_call2(symbol$3, commit, caml_call1(fail, unexpected))
                         : caml_call2
                           (symbol_bind,
                            available,
                            function(m){
                             var
                              m$0 =
                                caml_call2
                                 (Stdlib_Int64[18], runtime.caml_int64_of_int32(m), n),
                              n$0 = runtime.caml_int64_sub(n, m$0);
                             function _U_(param){return fixed(n$0, unexpected);}
                             return caml_call2
                                     (symbol_bind,
                                      schedule_size(body, runtime.caml_int64_to_int32(m$0)),
                                      _U_);
                            });
                });
    }
    if(typeof encoding === "number")
     return 536442962 <= encoding
             ? caml_call1
               (fix,
                function(p){
                 var
                  rec =
                    caml_call2
                     (symbol$3,
                      caml_call2
                       (symbol_bind,
                        available,
                        function(n){return schedule_size(body, n);}),
                      p);
                 return caml_call2
                         (symbol_bind,
                          at_end_of_input,
                          function(param){return param ? finish(body) : rec;});
                })
             : caml_call1
               (fix,
                function(p){
                 var _S_ = caml_call2(symbol$3, eol, commit);
                 function _T_(size){return hex(size);}
                 var
                  hex$0 =
                    caml_call2
                     (symbol$4,
                      caml_call2(symbol_bind, caml_call1(take_while1, P[4]), _T_),
                      _S_);
                 return caml_call2
                         (symbol_bind,
                          hex$0,
                          function(size){
                           return caml_equal(size, _w_)
                                   ? caml_call2
                                     (symbol_bind, eol, function(eol){return finish(body);})
                                   : caml_call2
                                     (symbol$3,
                                      caml_call2
                                       (symbol$3, fixed(size, cst_expected_more_from_body_ch), eol),
                                      p);
                          });
                });
    var n = encoding[2];
    function _R_(param){return finish(body);}
    return caml_call2
            (symbol_bind, fixed(n, cst_expected_more_from_fixed_b), _R_);
   }
   function create(parser){
    return [0, parser, 0, 0, Dream_httpaf_Optional_thunk[1]];
   }
   var ok = caml_call1(return$0, _x_);
   function is_closed(t){return t[3];}
   function on_wakeup(t, k){
    return t[3]
            ? caml_call1(Stdlib[2], cst_on_wakeup_on_closed_reader)
            : caml_call1
               (Dream_httpaf_Optional_thunk[4], t[4])
              ? caml_call1(Stdlib[2], cst_on_wakeup_only_one_callbac)
              : (t[4] = caml_call1(Dream_httpaf_Optional_thunk[2], k), 0);
   }
   function wakeup(t){
    var f = t[4];
    t[4] = Dream_httpaf_Optional_thunk[1];
    return caml_call1(Dream_httpaf_Optional_thunk[5], f);
   }
   function request$0(wakeup, handler){
    function _P_(request){
     var encoding = caml_call1(Dream_httpaf_Request[4], request);
     if(typeof encoding !== "number"){
      if(332360020 > encoding[1])
       return caml_call1(return$0, [1, [0, -99004555, request]]);
      if(! caml_notequal(encoding[2], _y_)){
       caml_call2(handler, request, caml_call1(Dream_httpaf_Body[1][4], 0));
       return ok;
      }
     }
     var
      _Q_ = caml_call1(Dream_httpaf_Optional_thunk[2], wakeup),
      request_body = caml_call2(Dream_httpaf_Body[1][3], Bigstringaf[2], _Q_);
     caml_call2(handler, request, request_body);
     return caml_call2(symbol$3, body(encoding, request_body), ok);
    }
    return create
            (caml_call2
              (symbol_bind, caml_call2(symbol$4, request, commit), _P_));
   }
   function response$0(request_queue){
    var t = [];
    runtime.caml_update_dummy
     (t,
      [246,
       function(param){
        function _H_(response){
         if(caml_call1(Stdlib_Queue[13], request_queue))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
         var Local = [248, cst_Local, runtime.caml_fresh_oo_id(0)];
         try{
          var
           _L_ =
             function(respd){
              var _O_ = 1 === respd[7] ? 1 : 0;
              if(_O_) throw caml_maybe_attach_backtrace([0, Local, respd], 1);
              return _O_;
             };
          caml_call2(Stdlib_Queue[15], _L_, request_queue);
         }
         catch(exn$0){
          var exn = caml_wrap_exception(exn$0);
          if(exn[1] !== Local) throw caml_maybe_attach_backtrace(exn, 0);
          var
           respd = exn[2],
           request = caml_call1(Dream_httpaf_Respd[3], respd),
           encoding =
             caml_call3(Dream_httpaf_Response[6], 0, request[1], response);
          if(typeof encoding !== "number"){
           if(332360020 > encoding[1]){
            if(-732353682 <= encoding[2])
             return caml_call1(return$0, [1, [0, -349406259, response]]);
            throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
           }
           if(! caml_notequal(encoding[2], _A_)){
            var _K_ = caml_call1(Dream_httpaf_Body[1][4], 0);
            caml_call2(respd[3], response, _K_);
            return ok;
           }
          }
          var
           _I_ =
             function(param){
              var _M_ = caml_obj_tag(t);
              a:
              if(250 === _M_)
               var _N_ = t[1];
              else{
               if(246 !== _M_ && 244 !== _M_){var _N_ = t; break a;}
               var _N_ = caml_call1(CamlinternalLazy[2], t);
              }
              return wakeup(_N_);
             },
           _J_ = caml_call1(Dream_httpaf_Optional_thunk[2], _I_),
           response_body =
             caml_call2(Dream_httpaf_Body[1][3], Bigstringaf[2], _J_);
          caml_call2(respd[3], response, response_body);
          return caml_call2(symbol$3, body(encoding, response_body), ok);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
        }
        return create
                (caml_call2
                  (symbol_bind, caml_call2(symbol$4, response, commit), _H_));
       }]);
    var _G_ = caml_obj_tag(t);
    if(250 === _G_) return t[1];
    if(246 !== _G_ && 244 !== _G_) return t;
    return caml_call1(CamlinternalLazy[2], t);
   }
   function transition(t, state){
    switch(state[0]){
      case 0:
       var match = state[1], continue$0 = match[2], committed = match[1];
       t[2] = [1, continue$0];
       return committed;
      case 1:
       var match$0 = state[2], consumed = state[1];
       if(0 === match$0[0]){t[2] = 0; return consumed;}
       var error = match$0[1];
       t[2] = [0, error];
       return consumed;
      default:
       var msg = state[3], marks = state[2], consumed$0 = state[1];
       t[2] = [0, [0, -796721133, [0, marks, msg]]];
       return consumed$0;
    }
   }
   function start(t, state){
    switch(state[0]){
      case 0:
       var _F_ = state[1];
       if(0 === _F_[1]){
        var continue$0 = _F_[2];
        t[2] = [1, continue$0];
        return 0;
       }
       break;
      case 1:
       return caml_call1(Stdlib[2], cst_httpaf_Parse_unable_to_sta);
      default:
       if(0 === state[1]){
        var msg = state[3], marks = state[2];
        t[2] = [0, [0, -796721133, [0, marks, msg]]];
        return 0;
       }
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
   }
   function read_with_more(t, bs, off, len, more){
    var initial = typeof t[2] === "number" ? 1 : 0, match = t[2];
    if(typeof match === "number")
     var
      consumed =
        0 === len
         ? 0
         : (start
            (t, caml_call1(Angstrom[77][1], t[1])),
           read_with_more(t, bs, off, len, more));
    else if(0 === match[0])
     var consumed = 0;
    else
     var
      continue$0 = match[1],
      consumed = transition(t, caml_call4(continue$0, bs, off, len, more));
    var _E_ = initial ? 0 === len ? 1 : 0 : initial;
    if(_E_) t[2] = 0;
    if(typeof t[2] === "number" && consumed < len){
     var off$0 = off + consumed | 0, len$0 = len - consumed | 0;
     return consumed + read_with_more(t, bs, off$0, len$0, more) | 0;
    }
    return consumed;
   }
   function read_with_more$0(t, bs, off, len, more){
    var consumed = read_with_more(t, bs, off, len, more);
    if(! more) t[3] = 1;
    return consumed;
   }
   function force_close(t){t[3] = 1; return 0;}
   function next(t){
    var match = t[2];
    if(typeof match !== "number" && 0 === match[0]){
     var failure = match[1];
     return [0, 106380200, failure];
    }
    return t[3]
            ? -611285096
            : typeof match === "number" ? 389604418 : 914388854;
   }
   var
    Reader =
      [0,
       create,
       ok,
       is_closed,
       on_wakeup,
       wakeup,
       request$0,
       response$0,
       transition,
       start,
       read_with_more,
       read_with_more$0,
       force_close,
       next],
    Dream_httpaf_Parse =
      [0,
       peek_char,
       peek_char_fail,
       peek_string,
       char$0,
       not_char,
       any_char,
       satisfy,
       string,
       string_ci,
       skip,
       skip_while,
       take,
       take_while,
       take_while1,
       take_till,
       consumed,
       take_bigstring,
       take_bigstring_while,
       take_bigstring_while1,
       take_bigstring_till,
       consumed_bigstring,
       advance,
       end_of_line,
       at_end_of_input,
       end_of_input,
       scan,
       scan_state,
       scan_string,
       int8,
       any_uint8,
       any_int8,
       BE,
       LE,
       option,
       both,
       list,
       count,
       many,
       many1,
       many_till,
       sep_by,
       sep_by1,
       skip_many,
       skip_many1,
       fix,
       fix_lazy,
       symbol,
       choice,
       symbol$0,
       commit,
       return$0,
       fail,
       symbol_bind,
       bind,
       symbol_map,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       lift,
       lift2,
       lift3,
       lift4,
       map,
       map2,
       map3,
       map4,
       Let_syntax,
       let$0,
       let$1,
       and,
       Unsafe,
       Consume,
       parse_bigstring,
       parse_string,
       Buffered,
       Unbuffered,
       pos,
       available,
       P,
       unit,
       token,
       spaces,
       digit,
       eol,
       hex,
       skip_line,
       version,
       header,
       headers,
       request,
       response,
       finish,
       schedule_size,
       body,
       Reader];
   runtime.caml_register_global
    (43, Dream_httpaf_Parse, "Dream_httpaf___Parse");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Response_state
//# unitInfo: Requires: Dream_httpaf___Body
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_httpaf_Body = global_data.Dream_httpaf___Body;
   function output_state(t){
    if(typeof t === "number") return 0;
    switch(t[0]){
      case 0:
       return 2;
      case 1:
       var response_body = t[2];
       return caml_call1(Dream_httpaf_Body[2][14], response_body) ? 1 : 2;
      default: return 1;
    }
   }
   function flush_response_body(t){
    if(typeof t !== "number" && 1 === t[0]){
     var response_body = t[2];
     return caml_call1(Dream_httpaf_Body[2][15], response_body);
    }
    return 0;
   }
   var Dream_httpaf_Response_state = [0, output_state, flush_response_body];
   runtime.caml_register_global
    (1, Dream_httpaf_Response_state, "Dream_httpaf___Response_state");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Reqd
//# unitInfo: Requires: Dream_httpaf___Body, Dream_httpaf___Parse, Dream_httpaf___Request, Dream_httpaf___Response, Dream_httpaf___Response_state, Dream_httpaf___Serialize, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_httpaf_Reqd_respond_with_s$7 =
      "httpaf.Reqd.respond_with_streaming: invalid state, currently handling error",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_httpaf_Response_state = global_data.Dream_httpaf___Response_state,
    Dream_httpaf_Body = global_data.Dream_httpaf___Body,
    Dream_httpaf_Response = global_data.Dream_httpaf___Response,
    Stdlib = global_data.Stdlib,
    Dream_httpaf_Parse = global_data.Dream_httpaf___Parse,
    Dream_httpaf_Serialize = global_data.Dream_httpaf___Serialize,
    Dream_httpaf_Request = global_data.Dream_httpaf___Request,
    _a_ = [0, 0],
    cst_httpaf_Reqd_report_exn_NYI = "httpaf.Reqd.report_exn: NYI",
    cst_httpaf_Reqd_respond_with_s$6 = cst_httpaf_Reqd_respond_with_s$7,
    cst_httpaf_Reqd_unsafe_respond =
      "httpaf.Reqd.unsafe_respond_with_upgrade: response already complete",
    cst_httpaf_Reqd_unsafe_respond$0 =
      "httpaf.Reqd.unsafe_respond_with_upgrade: response already started",
    cst_httpaf_Reqd_respond_with_s$5 = cst_httpaf_Reqd_respond_with_s$7,
    cst_httpaf_Reqd_respond_with_s$2 =
      "httpaf.Reqd.respond_with_streaming: invalid response body length",
    cst_httpaf_Reqd_respond_with_s$3 =
      "httpaf.Reqd.respond_with_streaming: response already complete",
    cst_httpaf_Reqd_respond_with_s$4 =
      "httpaf.Reqd.respond_with_streaming: response already started",
    cst_httpaf_Reqd_respond_with_b =
      "httpaf.Reqd.respond_with_bigstring: invalid state, currently handling error",
    cst_httpaf_Reqd_respond_with_b$0 =
      "httpaf.Reqd.respond_with_bigstring: response already complete",
    cst_httpaf_Reqd_respond_with_b$1 =
      "httpaf.Reqd.respond_with_bigstring: response already started",
    cst_httpaf_Reqd_respond_with_s =
      "httpaf.Reqd.respond_with_string: invalid state, currently handling error",
    cst_httpaf_Reqd_respond_with_s$0 =
      "httpaf.Reqd.respond_with_string: response already complete",
    cst_httpaf_Reqd_respond_with_s$1 =
      "httpaf.Reqd.respond_with_string: response already started",
    cst_httpaf_Reqd_response_exn_r =
      "httpaf.Reqd.response_exn: response has not started";
   function create
   (error_handler,
    request,
    request_body,
    reader,
    writer,
    response_body_buffer){
    return [0,
            request,
            request_body,
            reader,
            writer,
            response_body_buffer,
            error_handler,
            caml_call2(Dream_httpaf_Request[5], 0, request),
            0,
            17724];
   }
   function request(param){var request = param[1]; return request;}
   function request_body(param){
    var request_body = param[2];
    return request_body;
   }
   function response(param){
    var response_state = param[8];
    if(typeof response_state === "number") return 0;
    var response = response_state[1];
    return [0, response];
   }
   function response_exn(param){
    var response_state = param[8];
    if(typeof response_state === "number")
     return caml_call1(Stdlib[2], cst_httpaf_Reqd_response_exn_r);
    var response = response_state[1];
    return response;
   }
   function respond_with_string(t, response, str){
    if(17724 !== t[9]) caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_s);
    var _j_ = t[8];
    if(typeof _j_ !== "number")
     return 0 === _j_[0]
             ? caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_s$0)
             : caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_s$1);
    caml_call2(Dream_httpaf_Serialize[13][4], t[4], response);
    caml_call4(Dream_httpaf_Serialize[13][5], t[4], 0, 0, str);
    if(t[7]) t[7] = caml_call2(Dream_httpaf_Response[2], 0, response);
    t[8] = [0, response];
    return caml_call1(Dream_httpaf_Serialize[13][12], t[4]);
   }
   function respond_with_bigstring(t, response, bstr){
    if(17724 !== t[9]) caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_b);
    var _i_ = t[8];
    if(typeof _i_ !== "number")
     return 0 === _i_[0]
             ? caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_b$0)
             : caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_b$1);
    caml_call2(Dream_httpaf_Serialize[13][4], t[4], response);
    caml_call4(Dream_httpaf_Serialize[13][8], t[4], 0, 0, bstr);
    if(t[7]) t[7] = caml_call2(Dream_httpaf_Response[2], 0, response);
    t[8] = [0, response];
    return caml_call1(Dream_httpaf_Serialize[13][12], t[4]);
   }
   function unsafe_respond_with_streaming
   (flush_headers_immediately, t, response){
    var _h_ = t[8];
    if(typeof _h_ !== "number")
     return 0 === _h_[0]
             ? caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_s$3)
             : caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_s$4);
    var encoding = caml_call3(Dream_httpaf_Response[6], 0, t[1][1], response);
    a:
    {
     if(typeof encoding !== "number" && 332360020 > encoding[1]){
      var
       encoding$0 = caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_s$2);
      break a;
     }
     var encoding$0 = encoding;
    }
    var
     response_body =
       caml_call3(Dream_httpaf_Body[2][2], t[5], encoding$0, t[4]);
    caml_call2(Dream_httpaf_Serialize[13][4], t[4], response);
    if(t[7]) t[7] = caml_call2(Dream_httpaf_Response[2], 0, response);
    t[8] = [1, response, response_body];
    if(flush_headers_immediately)
     caml_call1(Dream_httpaf_Serialize[13][12], t[4]);
    return response_body;
   }
   function respond_with_streaming(opt, t, response){
    if(opt)
     var sth = opt[1], flush_headers_immediately = sth;
    else
     var flush_headers_immediately = 0;
    if(17724 !== t[9])
     caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_s$5);
    return unsafe_respond_with_streaming
            (flush_headers_immediately, t, response);
   }
   function unsafe_respond_with_upgrade(t, headers, upgrade_handler){
    var _g_ = t[8];
    if(typeof _g_ !== "number")
     return 0 === _g_[0]
             ? caml_call1(Stdlib[2], cst_httpaf_Reqd_unsafe_respond)
             : caml_call1(Stdlib[2], cst_httpaf_Reqd_unsafe_respond$0);
    var
     response =
       caml_call4(Dream_httpaf_Response[1], 0, 0, [0, headers], -1021676630);
    caml_call2(Dream_httpaf_Serialize[13][4], t[4], response);
    if(t[7]) t[7] = caml_call2(Dream_httpaf_Response[2], 0, response);
    t[8] = [2, response, upgrade_handler];
    caml_call2(Dream_httpaf_Serialize[13][13], t[4], upgrade_handler);
    caml_call1(Dream_httpaf_Body[1][11], t[2]);
    return caml_call1(Dream_httpaf_Serialize[13][12], t[4]);
   }
   function respond_with_upgrade(t, response, upgrade_handler){
    if(17724 !== t[9])
     caml_call1(Stdlib[2], cst_httpaf_Reqd_respond_with_s$6);
    return unsafe_respond_with_upgrade(t, response, upgrade_handler);
   }
   function report_error(t, error){
    t[7] = 0;
    var _e_ = t[8], match = t[9];
    if
     (typeof _e_ === "number" && typeof match === "number" && 17724 === match){
     t[9] = error;
     var
      status = typeof error === "number" ? error : -732353682,
      _f_ =
        function(headers){
         var
          response_body =
            unsafe_respond_with_streaming
             (1,
              t,
              caml_call4(Dream_httpaf_Response[1], 0, 0, [0, headers], status));
         caml_call1(Dream_httpaf_Body[1][11], t[2]);
         return response_body;
        };
     return caml_call3(t[6], [0, t[1]], error, _f_);
    }
    caml_call1(Dream_httpaf_Body[1][11], t[2]);
    if(typeof _e_ === "number"){
     if(typeof match !== "number" && 3458171 === match[1])
      return caml_call1(Stdlib[2], cst_httpaf_Reqd_report_exn_NYI);
    }
    else if(1 === _e_[0]){
     var response_body = _e_[2];
     if(typeof match === "number"){
      if(17724 === match){
       caml_call1(Dream_httpaf_Body[2][12], response_body);
       return caml_call1(Dream_httpaf_Parse[96][5], t[3]);
      }
     }
     else if(3458171 === match[1]){
      caml_call1(Dream_httpaf_Body[2][11], response_body);
      caml_call1(Dream_httpaf_Serialize[13][17], t[4]);
      return caml_call1(Dream_httpaf_Parse[96][5], t[3]);
     }
    }
    return 0;
   }
   function report_exn(t, exn){return report_error(t, [0, 3458171, exn]);}
   function try_with(t, f){
    try{caml_call1(f, 0); return _a_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     report_exn(t, exn);
     return [1, exn];
    }
   }
   function close_request_body(param){
    var request_body = param[2];
    return caml_call1(Dream_httpaf_Body[1][11], request_body);
   }
   function error_code(t){
    var error = t[9];
    if(typeof error === "number" && 17724 <= error) return 0;
    return [0, error];
   }
   function persistent_connection(t){return t[7];}
   function input_state(t){
    var _d_ = t[8];
    if(typeof _d_ !== "number" && 2 === _d_[0]) return 0;
    return caml_call1(Dream_httpaf_Body[1][5], t[2])
            ? 2
            : caml_call1(Dream_httpaf_Body[1][13], t[2]) ? 0 : 1;
   }
   function output_state(t){
    return caml_call1(Dream_httpaf_Response_state[1], t[8]);
   }
   function flush_request_body(t){
    var _b_ = caml_call1(Dream_httpaf_Body[1][12], t[2]);
    if(! _b_) return _b_;
    try{var _c_ = caml_call1(Dream_httpaf_Body[1][9], t[2]); return _c_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return report_exn(t, exn);
    }
   }
   function flush_response_body(t){
    return caml_call1(Dream_httpaf_Response_state[2], t[8]);
   }
   var
    Dream_httpaf_Reqd =
      [0,
       create,
       request,
       request_body,
       response,
       response_exn,
       respond_with_string,
       respond_with_bigstring,
       unsafe_respond_with_streaming,
       respond_with_streaming,
       unsafe_respond_with_upgrade,
       respond_with_upgrade,
       report_error,
       report_exn,
       try_with,
       close_request_body,
       error_code,
       persistent_connection,
       input_state,
       output_state,
       flush_request_body,
       flush_response_body];
   runtime.caml_register_global(23, Dream_httpaf_Reqd, "Dream_httpaf___Reqd");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Server_connection
//# unitInfo: Requires: Bigstringaf, CamlinternalLazy, Dream_httpaf___Body, Dream_httpaf___Config, Dream_httpaf___Headers, Dream_httpaf___Parse, Dream_httpaf___Reqd, Dream_httpaf___Response, Dream_httpaf___Response_state, Dream_httpaf___Serialize, Dream_httpaf___Status, Stdlib, Stdlib__Printexc, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_httpaf_Parse = global_data.Dream_httpaf___Parse,
    Dream_httpaf_Reqd = global_data.Dream_httpaf___Reqd,
    Dream_httpaf_Response_state = global_data.Dream_httpaf___Response_state,
    Dream_httpaf_Serialize = global_data.Dream_httpaf___Serialize,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Dream_httpaf_Response = global_data.Dream_httpaf___Response,
    Stdlib = global_data.Stdlib,
    Dream_httpaf_Body = global_data.Dream_httpaf___Body,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Dream_httpaf_Config = global_data.Dream_httpaf___Config,
    Bigstringaf = global_data.Bigstringaf,
    Dream_httpaf_Status = global_data.Dream_httpaf___Status,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Dream_httpaf_Headers = global_data.Dream_httpaf___Headers,
    cst_httpaf_Server_connection_e =
      "httpaf.Server_connection.error_handler: invalid response body length",
    _a_ = [0, "src/vendor/httpaf/lib/server_connection.ml", 169, 4];
   function is_closed(t){
    var _v_ = caml_call1(Dream_httpaf_Parse[96][3], t[1]);
    return _v_ ? caml_call1(Dream_httpaf_Serialize[13][18], t[2]) : _v_;
   }
   function is_active(t){return 1 - caml_call1(Stdlib_Queue[13], t[6]);}
   function current_reqd_exn(t){return caml_call1(Stdlib_Queue[8], t[6]);}
   function yield_reader(t, k){
    return caml_call2(Dream_httpaf_Parse[96][4], t[1], k);
   }
   function wakeup_reader(t){
    if(is_active(t)){
     var reqd = current_reqd_exn(t);
     caml_call1(Dream_httpaf_Reqd[20], reqd);
    }
    return caml_call1(Dream_httpaf_Parse[96][5], t[1]);
   }
   function yield_writer(t, k){
    return caml_call2(Dream_httpaf_Serialize[13][11], t[2], k);
   }
   function wakeup_writer(t){
    return caml_call1(Dream_httpaf_Serialize[13][12], t[2]);
   }
   function default_error_handler(param, error, handle){
    if(typeof error === "number")
     var message = caml_call1(Dream_httpaf_Status[12], error);
    else
     var exn = error[2], message = caml_call1(Stdlib_Printexc[1], exn);
    var body = caml_call1(handle, Dream_httpaf_Headers[2]);
    caml_call4(Dream_httpaf_Body[2][5], body, 0, 0, message);
    return caml_call1(Dream_httpaf_Body[2][11], body);
   }
   function create(opt, _g_, request_handler){
    if(opt)
     var sth = opt[1], config = sth;
    else
     var config = Dream_httpaf_Config[1];
    if(_g_)
     var sth$0 = _g_[1], error_handler = sth$0;
    else
     var error_handler = default_error_handler;
    var
     response_body_buffer_size = config[4],
     response_buffer_size = config[3],
     writer =
       caml_call2(Dream_httpaf_Serialize[13][1], [0, response_buffer_size], 0),
     request_queue = caml_call1(Stdlib_Queue[2], 0),
     response_body_buffer =
       caml_call1(Bigstringaf[1], response_body_buffer_size),
     reader = [],
     handler = function _u_(_s_, _t_){return _u_.fun(_s_, _t_);},
     t = [];
    caml_update_dummy
     (reader,
      [246,
       function(_o_){
        function _p_(param){
         var _q_ = caml_obj_tag(t);
         a:
         if(250 === _q_)
          var _r_ = t[1];
         else{
          if(246 !== _q_ && 244 !== _q_){var _r_ = t; break a;}
          var _r_ = caml_call1(CamlinternalLazy[2], t);
         }
         return wakeup_reader(_r_);
        }
        return caml_call2(Dream_httpaf_Parse[96][6], _p_, handler);
       }]);
    caml_update_dummy
     (handler,
      function(request, request_body){
       var _m_ = caml_obj_tag(reader);
       a:
       if(250 === _m_)
        var _n_ = reader[1];
       else{
        if(246 !== _m_ && 244 !== _m_){var _n_ = reader; break a;}
        var _n_ = caml_call1(CamlinternalLazy[2], reader);
       }
       var
        reqd =
          caml_call6
           (Dream_httpaf_Reqd[1],
            error_handler,
            request,
            request_body,
            _n_,
            writer,
            response_body_buffer),
        call_handler = caml_call1(Stdlib_Queue[13], request_queue);
       caml_call2(Stdlib_Queue[4], reqd, request_queue);
       return call_handler ? caml_call1(request_handler, reqd) : call_handler;
      });
    caml_update_dummy
     (t,
      [246,
       function(_i_){
        var _k_ = caml_obj_tag(reader);
        a:
        {
         var _j_ = 0;
         if(250 === _k_)
          var _l_ = reader[1];
         else{
          if(246 !== _k_ && 244 !== _k_){var _l_ = reader; break a;}
          var _l_ = caml_call1(CamlinternalLazy[2], reader);
         }
        }
        return [0,
                _l_,
                writer,
                response_body_buffer,
                request_handler,
                error_handler,
                request_queue,
                _j_];
       }]);
    var _h_ = caml_obj_tag(t);
    if(250 === _h_) return t[1];
    if(246 !== _h_ && 244 !== _h_) return t;
    return caml_call1(CamlinternalLazy[2], t);
   }
   function shutdown_reader(t){
    if(is_active(t)){
     var _f_ = current_reqd_exn(t);
     caml_call1(Dream_httpaf_Reqd[15], _f_);
    }
    caml_call1(Dream_httpaf_Parse[96][12], t[1]);
    return wakeup_reader(t);
   }
   function shutdown_writer(t){
    if(is_active(t)){
     var reqd = current_reqd_exn(t);
     caml_call1(Dream_httpaf_Reqd[15], reqd);
     caml_call1(Dream_httpaf_Reqd[21], reqd);
    }
    caml_call1(Dream_httpaf_Serialize[13][16], t[2]);
    return wakeup_writer(t);
   }
   function error_code(t){
    if(! is_active(t)) return 0;
    var _e_ = current_reqd_exn(t);
    return caml_call1(Dream_httpaf_Reqd[16], _e_);
   }
   function shutdown(t){shutdown_reader(t); return shutdown_writer(t);}
   function set_error_and_handle(request, t, error){
    if(is_active(t)){
     if(0 !== request)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var reqd = current_reqd_exn(t);
     return caml_call2(Dream_httpaf_Reqd[12], reqd, error);
    }
    var status = typeof error === "number" ? error : -732353682;
    shutdown_reader(t);
    var writer = t[2];
    if(t[7]){
     caml_call1(Dream_httpaf_Serialize[13][17], t[2]);
     return shutdown(t);
    }
    t[7] = [0, request, 0];
    function _d_(headers){
     var
      response =
        caml_call4(Dream_httpaf_Response[1], 0, 0, [0, headers], status);
     if(request)
      var request$0 = request[1], request_method = request$0[1];
     else
      var request_method = 3546230;
     var
      encoding =
        caml_call3(Dream_httpaf_Response[6], 0, request_method, response);
     a:
     {
      if(typeof encoding !== "number" && 332360020 > encoding[1]){
       var encoding$0 = caml_call1(Stdlib[2], cst_httpaf_Server_connection_e);
       break a;
      }
      var encoding$0 = encoding;
     }
     var
      response_body =
        caml_call3(Dream_httpaf_Body[2][2], t[3], encoding$0, t[2]);
     caml_call2(Dream_httpaf_Serialize[13][4], writer, response);
     t[7] = [0, request, [1, response, response_body]];
     wakeup_writer(t);
     return response_body;
    }
    return caml_call3(t[5], request, error, _d_);
   }
   function report_exn(t, exn){
    return set_error_and_handle(0, t, [0, 3458171, exn]);
   }
   function advance_request_queue(t){
    caml_call1(Stdlib_Queue[5], t[6]);
    var _b_ = 1 - caml_call1(Stdlib_Queue[13], t[6]);
    if(! _b_) return _b_;
    var _c_ = caml_call1(Stdlib_Queue[8], t[6]);
    return caml_call1(t[4], _c_);
   }
   function next_read_operation$1(counter, t){
    if(is_active(t)){
     var reqd = current_reqd_exn(t);
     switch(caml_call1(Dream_httpaf_Reqd[18], reqd)){
       case 0:
        return caml_call1(Dream_httpaf_Parse[96][13], t[1]);
       case 1:
        if(2 <= caml_call1(Dream_httpaf_Reqd[19], reqd))
         return caml_call1(Dream_httpaf_Parse[96][13], t[1]);
        var operation = caml_call1(Dream_httpaf_Parse[96][13], t[1]);
        if(typeof operation !== "number" && 106380200 === operation[1])
         return operation;
        return 73271853;
       default:
        if(counter >= 50)
         return caml_trampoline_return
                 (final_read_operation_for$0, [0, t, reqd]);
        var counter$0 = counter + 1 | 0;
        return final_read_operation_for$0(counter$0, t, reqd);
     }
    }
    var next = caml_call1(Dream_httpaf_Parse[96][13], t[1]);
    a:
    if(typeof next === "number"){
     if(-611285096 === next){if(! t[7]) shutdown(t); break a;}
    }
    else if(106380200 === next[1]){shutdown_reader(t); break a;}
    return next;
   }
   function final_read_operation_for$0(counter, t, reqd){
    if
     (!
      caml_call1(Dream_httpaf_Parse[96][3], t[1])
      && caml_call1(Dream_httpaf_Reqd[17], reqd)){
     if(2 > caml_call1(Dream_httpaf_Reqd[19], reqd)) return 73271853;
     var op = caml_call1(Dream_httpaf_Parse[96][13], t[1]);
     if(typeof op === "number"){
      if(914388854 === op){advance_request_queue(t); return op;}
     }
     else if(106380200 === op[1]) return op;
     advance_request_queue(t);
     if(counter >= 50)
      return caml_trampoline_return(next_read_operation$1, [0, t]);
     var counter$0 = counter + 1 | 0;
     return next_read_operation$1(counter$0, t);
    }
    shutdown_reader(t);
    return caml_call1(Dream_httpaf_Parse[96][13], t[1]);
   }
   function next_read_operation(t){
    return caml_trampoline(next_read_operation$1(0, t));
   }
   function final_read_operation_for(t, reqd){
    return caml_trampoline(final_read_operation_for$0(0, t, reqd));
   }
   function next_read_operation$0(t){
    var operation = next_read_operation(t);
    if(typeof operation === "number")
     return 389604418 <= operation ? 914388854 : operation;
    var match = operation[2];
    if(-99004555 <= match[1]){
     var request = match[2];
     set_error_and_handle([0, request], t, -99004555);
     return -611285096;
    }
    set_error_and_handle(0, t, -99004555);
    return -611285096;
   }
   function read_with_more(t, bs, off, len, more){
    var
     consumed =
       caml_call5(Dream_httpaf_Parse[96][11], t[1], bs, off, len, more);
    if(is_active(t)){
     var reqd = current_reqd_exn(t);
     caml_call1(Dream_httpaf_Reqd[20], reqd);
    }
    return consumed;
   }
   function read(t, bs, off, len){return read_with_more(t, bs, off, len, 1);}
   function read_eof(t, bs, off, len){
    return read_with_more(t, bs, off, len, 0);
   }
   function flush_response_error_body(response_state){
    return caml_call1(Dream_httpaf_Response_state[2], response_state);
   }
   function next_write_operation$1(counter, t){
    if(is_active(t)){
     var reqd = current_reqd_exn(t);
     switch(caml_call1(Dream_httpaf_Reqd[19], reqd)){
       case 0:
        return caml_call1(Dream_httpaf_Serialize[13][21], t[2]);
       case 1:
        caml_call1(Dream_httpaf_Reqd[21], reqd);
        return caml_call1(Dream_httpaf_Serialize[13][21], t[2]);
       default:
        if(counter >= 50)
         return caml_trampoline_return
                 (final_write_operation_for$0, [0, t, reqd]);
        var counter$0 = counter + 1 | 0;
        return final_write_operation_for$0(counter$0, t, reqd);
     }
    }
    var match = t[7];
    if(match){
     var response_state = match[2];
     switch(caml_call1(Dream_httpaf_Response_state[1], response_state)){
       case 0:
        return 73271853;
       case 1:
        flush_response_error_body(response_state);
        return caml_call1(Dream_httpaf_Serialize[13][21], t[2]);
       default:
        shutdown_writer(t);
        return caml_call1(Dream_httpaf_Serialize[13][21], t[2]);
     }
    }
    if(caml_call1(Dream_httpaf_Parse[96][3], t[1])) shutdown(t);
    return caml_call1(Dream_httpaf_Serialize[13][21], t[2]);
   }
   function final_write_operation_for$0(counter, t, reqd){
    if(caml_call1(Dream_httpaf_Reqd[17], reqd))
     switch(caml_call1(Dream_httpaf_Reqd[18], reqd)){
       case 0:
        wakeup_reader(t);
        return caml_call1(Dream_httpaf_Serialize[13][21], t[2]);
       case 1:
        wakeup_reader(t);
        return caml_call1(Dream_httpaf_Serialize[13][21], t[2]);
       default:
        var match = caml_call1(Dream_httpaf_Parse[96][13], t[1]);
        if(typeof match !== "number" && 106380200 === match[1])
         return caml_call1(Dream_httpaf_Serialize[13][21], t[2]);
        advance_request_queue(t);
        wakeup_reader(t);
        if(counter >= 50)
         return caml_trampoline_return(next_write_operation$1, [0, t]);
        var counter$0 = counter + 1 | 0;
        return next_write_operation$1(counter$0, t);
     }
    shutdown_writer(t);
    wakeup_reader(t);
    return caml_call1(Dream_httpaf_Serialize[13][21], t[2]);
   }
   function next_write_operation(t){
    return caml_trampoline(next_write_operation$1(0, t));
   }
   function final_write_operation_for(t, reqd){
    return caml_trampoline(final_write_operation_for$0(0, t, reqd));
   }
   function next_write_operation$0(t){return next_write_operation(t);}
   function report_write_result(t, result){
    return caml_call2(Dream_httpaf_Serialize[13][20], t[2], result);
   }
   var
    Dream_httpaf_Server_connection =
      [0,
       is_closed,
       is_active,
       current_reqd_exn,
       yield_reader,
       wakeup_reader,
       yield_writer,
       wakeup_writer,
       default_error_handler,
       create,
       shutdown_reader,
       shutdown_writer,
       error_code,
       shutdown,
       set_error_and_handle,
       report_exn,
       advance_request_queue,
       next_read_operation,
       final_read_operation_for,
       next_read_operation$0,
       read_with_more,
       read,
       read_eof,
       flush_response_error_body,
       next_write_operation,
       final_write_operation_for,
       next_write_operation$0,
       report_write_result];
   runtime.caml_register_global
    (17, Dream_httpaf_Server_connection, "Dream_httpaf___Server_connection");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Client_connection
//# unitInfo: Requires: Bigstringaf, Dream_httpaf___Body, Dream_httpaf___Config, Dream_httpaf___Parse, Dream_httpaf___Request, Dream_httpaf___Respd, Dream_httpaf___Serialize, Stdlib, Stdlib__Queue, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ": ",
    cst$0 = ">",
    cst$1 = "",
    Dream_httpaf_Parse = global_data.Dream_httpaf___Parse,
    Dream_httpaf_Respd = global_data.Dream_httpaf___Respd,
    Dream_httpaf_Serialize = global_data.Dream_httpaf___Serialize,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Dream_httpaf_Request = global_data.Dream_httpaf___Request,
    Dream_httpaf_Body = global_data.Dream_httpaf___Body,
    Stdlib = global_data.Stdlib,
    Bigstringaf = global_data.Bigstringaf,
    Dream_httpaf_Config = global_data.Dream_httpaf___Config,
    _b_ = [0, -522261659, "unexpected eof"],
    _a_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Httpaf_Client_connection_r =
      "Httpaf.Client_connection.request: invalid body length",
    cst_Dream_httpaf_Client_connec = "Dream_httpaf___Client_connection.Local";
   function is_closed(t){
    var _w_ = caml_call1(Dream_httpaf_Parse[96][3], t[2]);
    return _w_ ? caml_call1(Dream_httpaf_Serialize[13][18], t[3]) : _w_;
   }
   function is_waiting(t){
    var _v_ = 1 - is_closed(t);
    return _v_ ? caml_call1(Stdlib_Queue[13], t[4]) : _v_;
   }
   function is_active(t){return 1 - caml_call1(Stdlib_Queue[13], t[4]);}
   function current_respd_exn(t){return caml_call1(Stdlib_Queue[8], t[4]);}
   function yield_reader(t, k){
    return caml_call2(Dream_httpaf_Parse[96][4], t[2], k);
   }
   function wakeup_reader(t){
    return caml_call1(Dream_httpaf_Parse[96][5], t[2]);
   }
   function yield_writer(t, k){
    return caml_call2(Dream_httpaf_Serialize[13][11], t[3], k);
   }
   function wakeup_writer(t){
    return caml_call1(Dream_httpaf_Serialize[13][12], t[3]);
   }
   function create(opt, param){
    if(opt)
     var sth = opt[1], config = sth;
    else
     var config = Dream_httpaf_Config[1];
    var
     request_queue = caml_call1(Stdlib_Queue[2], 0),
     _u_ = caml_call2(Dream_httpaf_Serialize[13][1], 0, 0);
    return [0,
            config,
            caml_call1(Dream_httpaf_Parse[96][7], request_queue),
            _u_,
            request_queue];
   }
   function create_request_body(request, t){
    var encoding = caml_call1(Dream_httpaf_Request[4], request);
    if(typeof encoding !== "number"){
     if(332360020 > encoding[1])
      return caml_call1(Stdlib[2], cst_Httpaf_Client_connection_r);
     if(! runtime.caml_notequal(encoding[2], _a_))
      return caml_call1(Dream_httpaf_Body[2][3], t[3]);
    }
    var _s_ = t[3], _t_ = caml_call1(Bigstringaf[1], t[1][2]);
    return caml_call3(Dream_httpaf_Body[2][2], _t_, encoding, _s_);
   }
   function request(t, opt, request, error_handler, response_handler){
    if(opt)
     var sth = opt[1], flush_headers_immediately = sth;
    else
     var flush_headers_immediately = 0;
    var
     request_body = create_request_body(request, t),
     respd =
       caml_call5
        (Dream_httpaf_Respd[2],
         error_handler,
         request,
         request_body,
         t[3],
         response_handler),
     handle_now = caml_call1(Stdlib_Queue[13], t[4]);
    caml_call2(Stdlib_Queue[4], respd, t[4]);
    if(handle_now) caml_call1(Dream_httpaf_Respd[4], respd);
    if(1 - flush_headers_immediately)
     caml_call1(Dream_httpaf_Serialize[13][15], t[3]);
    wakeup_writer(t);
    return request_body;
   }
   function shutdown_reader(t){
    if(is_active(t)){
     var _r_ = current_respd_exn(t);
     caml_call1(Dream_httpaf_Respd[8], _r_);
    }
    caml_call1(Dream_httpaf_Parse[96][12], t[2]);
    return wakeup_reader(t);
   }
   function shutdown_writer(t){
    if(is_active(t)){
     var _q_ = current_respd_exn(t);
     caml_call1(Dream_httpaf_Respd[7], _q_);
    }
    caml_call1(Dream_httpaf_Serialize[13][16], t[3]);
    return wakeup_writer(t);
   }
   function shutdown(t){shutdown_reader(t); return shutdown_writer(t);}
   function set_error_and_handle(t, error){
    var _o_ = t[4];
    function _p_(respd){
     if(2 > caml_call1(Dream_httpaf_Respd[9], respd))
      return caml_call2(Dream_httpaf_Respd[5], respd, error);
     var match = caml_call1(Dream_httpaf_Parse[96][13], t[2]);
     a:
     {
      if(typeof match === "number"){
       if(914388854 === match) break a;
      }
      else if(106380200 === match[1]) break a;
      return 0;
     }
     return caml_call2(Dream_httpaf_Respd[5], respd, error);
    }
    caml_call2(Stdlib_Queue[15], _p_, _o_);
    return shutdown(t);
   }
   function unexpected_eof(t){return set_error_and_handle(t, _b_);}
   function report_exn(t, exn){
    return set_error_and_handle(t, [0, 3458171, exn]);
   }
   var
    Local = [248, cst_Dream_httpaf_Client_connec, runtime.caml_fresh_oo_id(0)];
   function maybe_pipeline_queued_requests(t){
    var _h_ = 1 < caml_call1(Stdlib_Queue[14], t[4]) ? 1 : 0;
    if(_h_)
     try{
      var
       _j_ = t[4],
       _k_ = 0,
       _l_ =
         function(prev, respd){
          a:
          if(prev){
           var
            prev$0 = prev[1],
            match = respd[7],
            match$0 = caml_call1(Dream_httpaf_Respd[10], prev$0);
           if(typeof match === "number" && ! match && 2 <= match$0){
            caml_call1(Dream_httpaf_Respd[4], respd);
            caml_call1(Dream_httpaf_Respd[11], respd);
            break a;
           }
           throw caml_maybe_attach_backtrace(Local, 1);
          }
          return [0, respd];
         };
      caml_call3(Stdlib_Queue[16], _l_, _k_, _j_);
      var _m_ = 0;
      return _m_;
     }
     catch(_n_){var _i_ = 0;}
    else
     var _i_ = _h_;
    return _i_;
   }
   function advance_request_queue(t){
    caml_call1(Stdlib_Queue[5], t[4]);
    var _e_ = 1 - caml_call1(Stdlib_Queue[13], t[4]);
    if(_e_){
     var respd = current_respd_exn(t), _f_ = respd[7];
     if(typeof _f_ === "number" && ! _f_){
      caml_call1(Dream_httpaf_Respd[4], respd);
      return wakeup_writer(t);
     }
     var _g_ = 0;
    }
    else
     var _g_ = _e_;
    return _g_;
   }
   function next_read_operation(t){
    if(is_active(t)){
     var respd = current_respd_exn(t);
     switch(caml_call1(Dream_httpaf_Respd[9], respd)){
       case 0:
        return caml_call1(Dream_httpaf_Parse[96][13], t[2]);
       case 1:
        return 73271853;
       default: return final_read_operation_for(t, respd);
     }
    }
    if(caml_call1(Dream_httpaf_Parse[96][3], t[2])) shutdown(t);
    return caml_call1(Dream_httpaf_Parse[96][13], t[2]);
   }
   function final_read_operation_for(t, respd){
    if(caml_call1(Dream_httpaf_Respd[6], respd)){
     if(2 <= caml_call1(Dream_httpaf_Respd[10], respd)){
      var operation = caml_call1(Dream_httpaf_Parse[96][13], t[2]);
      a:
      {
       b:
       {
        if(typeof operation === "number"){
         if(914388854 === operation) break b;
        }
        else if(106380200 === operation[1]) break b;
        advance_request_queue(t);
        var operation$0 = next_read_operation(t);
        break a;
       }
       var operation$0 = operation;
      }
      var operation$1 = operation$0;
     }
     else
      var operation$1 = 73271853;
     var next = operation$1;
    }
    else{
     shutdown_reader(t);
     var next = caml_call1(Dream_httpaf_Parse[96][13], t[2]);
    }
    wakeup_writer(t);
    return next;
   }
   function next_read_operation$0(t){
    var operation = next_read_operation(t);
    if(typeof operation === "number")
     return 389604418 === operation ? 914388854 : operation;
    var error = operation[2];
    if(-349406259 <= error[1]){
     set_error_and_handle(t, error);
     return -611285096;
    }
    var
     match = error[2],
     message = match[2],
     marks = match[1],
     _d_ =
       [0,
        caml_call2(Stdlib_String[7], cst$0, marks),
        [0, cst, [0, message, 0]]],
     message$0 = caml_call2(Stdlib_String[7], cst$1, _d_);
    set_error_and_handle(t, [0, -522261659, message$0]);
    return -611285096;
   }
   function read_with_more(t, bs, off, len, more){
    var
     consumed =
       caml_call5(Dream_httpaf_Parse[96][11], t[2], bs, off, len, more);
    if(is_active(t)){
     var _c_ = current_respd_exn(t);
     caml_call1(Dream_httpaf_Respd[12], _c_);
    }
    return consumed;
   }
   function read(t, bs, off, len){return read_with_more(t, bs, off, len, 1);}
   function read_eof(t, bs, off, len){
    var bytes_read = read_with_more(t, bs, off, len, 0);
    if(is_active(t)) unexpected_eof(t);
    return bytes_read;
   }
   function next_write_operation$1(counter, t){
    if(is_active(t)){
     var respd = current_respd_exn(t);
     switch(caml_call1(Dream_httpaf_Respd[10], respd)){
       case 0:
        return 73271853;
       case 1:
        caml_call1(Dream_httpaf_Respd[11], respd);
        return caml_call1(Dream_httpaf_Serialize[13][21], t[3]);
       default:
        if(counter >= 50)
         return caml_trampoline_return
                 (final_write_operation_for$0, [0, t, respd]);
        var counter$0 = counter + 1 | 0;
        return final_write_operation_for$0(counter$0, t, respd);
     }
    }
    if(caml_call1(Dream_httpaf_Parse[96][3], t[2])) shutdown(t);
    return caml_call1(Dream_httpaf_Serialize[13][21], t[3]);
   }
   function final_write_operation_for$0(counter, t, respd){
    if(! caml_call1(Dream_httpaf_Respd[6], respd)){
     shutdown_writer(t);
     return caml_call1(Dream_httpaf_Serialize[13][21], t[3]);
    }
    maybe_pipeline_queued_requests(t);
    if(2 > caml_call1(Dream_httpaf_Respd[9], respd)){
     wakeup_reader(t);
     return caml_call1(Dream_httpaf_Serialize[13][21], t[3]);
    }
    var match = caml_call1(Dream_httpaf_Parse[96][13], t[2]);
    if(typeof match !== "number" && 106380200 === match[1])
     return caml_call1(Dream_httpaf_Serialize[13][21], t[3]);
    advance_request_queue(t);
    wakeup_reader(t);
    if(counter >= 50)
     return caml_trampoline_return(next_write_operation$1, [0, t]);
    var counter$0 = counter + 1 | 0;
    return next_write_operation$1(counter$0, t);
   }
   function next_write_operation(t){
    return caml_trampoline(next_write_operation$1(0, t));
   }
   function final_write_operation_for(t, respd){
    return caml_trampoline(final_write_operation_for$0(0, t, respd));
   }
   function next_write_operation$0(t){return next_write_operation(t);}
   function report_write_result(t, result){
    return caml_call2(Dream_httpaf_Serialize[13][20], t[3], result);
   }
   var
    Dream_httpaf_Client_connection =
      [0,
       is_closed,
       is_waiting,
       is_active,
       current_respd_exn,
       yield_reader,
       wakeup_reader,
       yield_writer,
       wakeup_writer,
       create,
       create_request_body,
       request,
       shutdown_reader,
       shutdown_writer,
       shutdown,
       set_error_and_handle,
       unexpected_eof,
       report_exn,
       Local,
       maybe_pipeline_queued_requests,
       advance_request_queue,
       next_read_operation,
       final_read_operation_for,
       next_read_operation$0,
       read_with_more,
       read,
       read_eof,
       next_write_operation,
       final_write_operation_for,
       next_write_operation$0,
       report_write_result];
   runtime.caml_register_global
    (17, Dream_httpaf_Client_connection, "Dream_httpaf___Client_connection");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_httpaf___Httpaf
//# unitInfo: Requires: Dream_httpaf___Body, Dream_httpaf___Client_connection, Dream_httpaf___Config, Dream_httpaf___Headers, Dream_httpaf___IOVec, Dream_httpaf___Method, Dream_httpaf___Parse, Dream_httpaf___Reqd, Dream_httpaf___Request, Dream_httpaf___Response, Dream_httpaf___Serialize, Dream_httpaf___Server_connection, Dream_httpaf___Status, Dream_httpaf___Version
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Dream_httpaf_Serialize = global_data.Dream_httpaf___Serialize,
    Dream_httpaf_Parse = global_data.Dream_httpaf___Parse,
    Dream_httpaf_Client_connection =
      global_data.Dream_httpaf___Client_connection,
    Dream_httpaf_Server_connection =
      global_data.Dream_httpaf___Server_connection,
    Dream_httpaf_Config = global_data.Dream_httpaf___Config,
    Dream_httpaf_Reqd = global_data.Dream_httpaf___Reqd,
    Dream_httpaf_IOVec = global_data.Dream_httpaf___IOVec,
    Dream_httpaf_Response = global_data.Dream_httpaf___Response,
    Dream_httpaf_Request = global_data.Dream_httpaf___Request,
    Dream_httpaf_Body = global_data.Dream_httpaf___Body,
    Dream_httpaf_Headers = global_data.Dream_httpaf___Headers,
    Dream_httpaf_Status = global_data.Dream_httpaf___Status,
    Dream_httpaf_Method = global_data.Dream_httpaf___Method,
    Dream_httpaf_Version = global_data.Dream_httpaf___Version,
    _a_ = Dream_httpaf_Body[2],
    _b_ = Dream_httpaf_Body[1],
    Dream_httpaf_Httpaf =
      [0,
       [0,
        Dream_httpaf_Version[4],
        Dream_httpaf_Version[5],
        Dream_httpaf_Version[6],
        Dream_httpaf_Version[7]],
       Dream_httpaf_Method,
       [0,
        Dream_httpaf_Status[1],
        Dream_httpaf_Status[2],
        Dream_httpaf_Status[5],
        Dream_httpaf_Status[4],
        Dream_httpaf_Status[6],
        Dream_httpaf_Status[7],
        Dream_httpaf_Status[8],
        Dream_httpaf_Status[9],
        Dream_httpaf_Status[10],
        Dream_httpaf_Status[11],
        Dream_httpaf_Status[12],
        Dream_httpaf_Status[13],
        Dream_httpaf_Status[14]],
       [0,
        Dream_httpaf_Headers[2],
        Dream_httpaf_Headers[3],
        Dream_httpaf_Headers[4],
        Dream_httpaf_Headers[5],
        Dream_httpaf_Headers[6],
        Dream_httpaf_Headers[7],
        Dream_httpaf_Headers[8],
        Dream_httpaf_Headers[9],
        Dream_httpaf_Headers[10],
        Dream_httpaf_Headers[11],
        Dream_httpaf_Headers[12],
        Dream_httpaf_Headers[13],
        Dream_httpaf_Headers[14],
        Dream_httpaf_Headers[15],
        Dream_httpaf_Headers[16],
        Dream_httpaf_Headers[17],
        Dream_httpaf_Headers[18],
        Dream_httpaf_Headers[19],
        Dream_httpaf_Headers[20]],
       [0,
        [0, _b_[10], _b_[11], _b_[5]],
        [0, _a_[4], _a_[5], _a_[6], _a_[7], _a_[9], _a_[11], _a_[10]]],
       [0,
        Dream_httpaf_Request[1],
        Dream_httpaf_Request[3],
        Dream_httpaf_Request[4],
        Dream_httpaf_Request[5],
        Dream_httpaf_Request[6]],
       [0,
        Dream_httpaf_Response[1],
        Dream_httpaf_Response[5],
        Dream_httpaf_Response[6],
        Dream_httpaf_Response[2],
        Dream_httpaf_Response[7]],
       [0,
        Dream_httpaf_IOVec[1],
        Dream_httpaf_IOVec[2],
        Dream_httpaf_IOVec[3],
        Dream_httpaf_IOVec[4],
        Dream_httpaf_IOVec[6]],
       [0,
        Dream_httpaf_Reqd[2],
        Dream_httpaf_Reqd[3],
        Dream_httpaf_Reqd[4],
        Dream_httpaf_Reqd[5],
        Dream_httpaf_Reqd[6],
        Dream_httpaf_Reqd[7],
        Dream_httpaf_Reqd[9],
        Dream_httpaf_Reqd[11],
        Dream_httpaf_Reqd[16],
        Dream_httpaf_Reqd[13],
        Dream_httpaf_Reqd[14]],
       Dream_httpaf_Config,
       [0,
        Dream_httpaf_Server_connection[9],
        Dream_httpaf_Server_connection[19],
        Dream_httpaf_Server_connection[21],
        Dream_httpaf_Server_connection[22],
        Dream_httpaf_Server_connection[4],
        Dream_httpaf_Server_connection[26],
        Dream_httpaf_Server_connection[27],
        Dream_httpaf_Server_connection[6],
        Dream_httpaf_Server_connection[15],
        Dream_httpaf_Server_connection[1],
        Dream_httpaf_Server_connection[12],
        Dream_httpaf_Server_connection[13]],
       [0,
        Dream_httpaf_Client_connection[9],
        Dream_httpaf_Client_connection[11],
        Dream_httpaf_Client_connection[23],
        Dream_httpaf_Client_connection[25],
        Dream_httpaf_Client_connection[26],
        Dream_httpaf_Client_connection[29],
        Dream_httpaf_Client_connection[30],
        Dream_httpaf_Client_connection[5],
        Dream_httpaf_Client_connection[7],
        Dream_httpaf_Client_connection[17],
        Dream_httpaf_Client_connection[1],
        Dream_httpaf_Client_connection[14]],
       [0,
        [0, Dream_httpaf_Parse[91], Dream_httpaf_Parse[92]],
        [0, Dream_httpaf_Serialize[7], Dream_httpaf_Serialize[8]]]];
   runtime.caml_register_global
    (14, Dream_httpaf_Httpaf, "Dream_httpaf___Httpaf");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJkcmVhbV9odHRwYWZfLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJ2MV8wIiwidjFfMSIsInRvX2J1ZmZlciIsImIiLCJ0IiwiY29tcGFyZSIsIngiLCJ5IiwiYyIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsInMiLCJtYWpvciIsIm1pbm9yIiwicHBfaHVtIiwiZm10IiwiZGVmYXVsdF9yZWFzb25fcGhyYXNlIiwidG9fY29kZSIsInJlYWxseV91bnNhZmVfb2ZfY29kZSIsInVuc2FmZV9vZl9jb2RlIiwiYyQwIiwib2ZfY29kZSIsImlzX2luZm9ybWF0aW9uYWwiLCJuIiwiaXNfc3VjY2Vzc2Z1bCIsImlzX3JlZGlyZWN0aW9uIiwiaXNfY2xpZW50X2Vycm9yIiwiaXNfc2VydmVyX2Vycm9yIiwiaXNfZXJyb3IiLCJlbXB0eSIsIm9mX3Jldl9saXN0Iiwib2ZfbGlzdCIsInRvX3Jldl9saXN0IiwidG9fbGlzdCIsImNpX2VxdWFsIiwibGVuIiwiZXF1YWxfc29fZmFyIiwiaSIsImMxIiwiYzIiLCJjb2RlcyIsImQiLCJlIiwidXBwZXIiLCJtZW0iLCJuYW1lIiwidCQwIiwidCQxIiwibmFtZSQwIiwiYWRkIiwidmFsdWUiLCJhZGRfbGlzdCIsImxzIiwiYWRkX211bHRpIiwibHNzIiwibHNzJDAiLCJsc3MkMSIsInZzIiwidnMkMCIsInZzJDEiLCJ2IiwidCQyIiwiYWRkX3VubGVzc19leGlzdHMiLCJyZXBsYWNlIiwibG9vcCIsIm5lZWRsZSIsIm52Iiwic2VlbiIsInNlZW4kMCIsIm52JDAiLCJyZW1vdmUiLCJzJDAiLCJzJDEiLCJnZXQiLCJnZXRfZXhuIiwiZ2V0X211bHRpIiwiYWNjIiwiYWNjJDAiLCJpdGVyIiwiZiIsImZvbGQiLCJpbml0IiwicHBfZWxlbSIsImxlbmd0aCIsImxlbmd0aHYiLCJpb3ZzIiwic2hpZnQiLCJvZmYiLCJidWZmZXIiLCJzaGlmdHYiLCJpb3ZlY3MiLCJpb3ZlY3MkMCIsIm4kMCIsImlvdmVjcyQxIiwiaW92ZWMiLCJpb3ZlY19sZW4iLCJuJDEiLCJhZGRfbGVuIiwicGVyc2lzdGVudF9jb25uZWN0aW9uIiwib3B0IiwidmVyc2lvbiIsImhlYWRlcnMiLCJzb3J0X3VuaXEiLCJ4cyIsInVuaXF1ZV9jb250ZW50X2xlbmd0aF92YWx1ZXMiLCJjb250ZW50X2xlbmd0aF9vZl9zdHJpbmciLCJpc19zYWZlIiwiaXNfY2FjaGVhYmxlIiwiaXNfaWRlbXBvdGVudCIsIm5vbmUiLCJzb21lIiwiaXNfbm9uZSIsImlzX3NvbWUiLCJjYWxsX2lmX3NvbWUiLCJ1bmNoZWNrZWRfdmFsdWUiLCJiYWRfcmVxdWVzdCIsImNyZWF0ZSIsIm1ldGgiLCJ0YXJnZXQiLCJzdGgiLCJzdGgkMCIsImJvZHlfbGVuZ3RoIiwibGVuJDAiLCJwcm94eSIsInBwX2h1bSQwIiwicHJveHlfZXJyb3IiLCJzZXJ2ZXJfZXJyb3IiLCJyZWFzb24iLCJzdGF0dXMiLCJyZWFzb24kMCIsInJlYXNvbiQxIiwicmVxdWVzdF9tZXRob2QiLCJ3cml0ZV9zcGFjZSIsIndyaXRlX2NybGYiLCJ3cml0ZV92ZXJzaW9uIiwid3JpdGVfbWV0aG9kIiwid3JpdGVfc3RhdHVzIiwid3JpdGVfaGVhZGVycyIsIndyaXRlX3JlcXVlc3QiLCJ3cml0ZV9yZXNwb25zZSIsIndyaXRlX2NodW5rX2xlbmd0aCIsIndyaXRlX3N0cmluZ19jaHVuayIsImNodW5rIiwid3JpdGVfYmlnc3RyaW5nX2NodW5rIiwic2NoZWR1bGVfYmlnc3RyaW5nX2NodW5rIiwiYnVmZmVyX3NpemUiLCJlbmNvZGVyIiwiZmFyYWRheSIsIndyaXRlX3JlcXVlc3QkMCIsInJlcXVlc3QiLCJ3cml0ZV9yZXNwb25zZSQwIiwicmVzcG9uc2UiLCJ3cml0ZV9zdHJpbmciLCJzdHJpbmciLCJ3cml0ZV9ieXRlcyIsImJ5dGVzIiwid3JpdGVfYmlnc3RyaW5nIiwiYmlnc3RyaW5nIiwic2NoZWR1bGVfYmlnc3RyaW5nIiwic2NoZWR1bGVfZml4ZWQiLCJzY2hlZHVsZV9jaHVuayIsIm9uX3dha2V1cCIsImsiLCJ3YWtldXAiLCJmbHVzaCIsInVueWllbGQiLCJ5aWVsZCQwIiwiY2xvc2UiLCJjbG9zZV9hbmRfZHJhaW4iLCJkcmFpbmVkIiwiaXNfY2xvc2VkIiwiZHJhaW5lZF9ieXRlcyIsInJlcG9ydF9yZXN1bHQiLCJyZXN1bHQiLCJuZXh0IiwiZGVmYXVsdF9vbl9lb2YiLCJkZWZhdWx0X29uX3JlYWQiLCJ3aGVuX3JlYWR5X3RvX3JlYWQiLCJjcmVhdGVfZW1wdHkiLCJ1bnNhZmVfZmFyYWRheSIsInJlYWR5X3RvX3JlYWQiLCJkb19leGVjdXRlX3JlYWQkMCIsIm9uX2VvZiIsIm9uX3JlYWQiLCJleGVjdXRlX3JlYWQkMCIsImRvX2V4ZWN1dGVfcmVhZCIsImV4ZWN1dGVfcmVhZCIsInNjaGVkdWxlX3JlYWQiLCJoYXNfcGVuZGluZ19vdXRwdXQiLCJpc19yZWFkX3NjaGVkdWxlZCIsIm9mX2ZhcmFkYXkiLCJlbmNvZGluZyIsIndyaXRlciIsImVuY29kaW5nJDAiLCJjcmVhdGUkMCIsImNyZWF0ZV9lbXB0eSQwIiwid3JpdGVfY2hhciIsInJlYWR5X3RvX3dyaXRlIiwia29udGludWUiLCJpc19jbG9zZWQkMCIsImNsb3NlJDAiLCJmb3JjZV9jbG9zZSIsIm1hdGNoIiwiaGFzX3BlbmRpbmdfb3V0cHV0JDAiLCJmYXJhZGF5X2hhc19vdXRwdXQiLCJ3cml0dGVuX2ZpbmFsX2NodW5rIiwiYWRkaXRpb25hbF9lbmNvZGluZ19vdXRwdXQiLCJmYXJhZGF5X2hhc19vdXRwdXQkMCIsInJlcXVpcmVzX291dHB1dCIsInRyYW5zZmVyX3RvX3dyaXRlciIsImNodW5rZWQiLCJidWZmZXJlZCIsImVycm9yX2hhbmRsZXIiLCJyZXF1ZXN0X2JvZHkiLCJyZXNwb25zZV9oYW5kbGVyIiwiaGFuZGxlciIsImJvZHkiLCJuZXh0X3N0YXRlIiwicmVwb3J0X2Vycm9yIiwiZXJyb3IiLCJyZXNwb25zZV9ib2R5IiwiY2xvc2VfcmVxdWVzdF9ib2R5IiwiY2xvc2VfcmVzcG9uc2VfYm9keSIsImlucHV0X3N0YXRlIiwib3V0cHV0X3N0YXRlIiwic3RhdGUiLCJmbHVzaF9yZXF1ZXN0X2JvZHkiLCJmbHVzaF9yZXNwb25zZV9ib2R5IiwiZXhuJDAiLCJleG4iLCJpc19zcGFjZSIsImlzX2NyIiwiaXNfc3BhY2Vfb3JfY29sb24iLCJpc19oZXgiLCJpc19kaWdpdCIsImlzX3NlcGFyYXRvciIsImlzX3Rva2VuIiwidW5pdCIsInRva2VuIiwic3BhY2VzIiwiZGlnaXQiLCJlb2wiLCJoZXgiLCJzdHIiLCJza2lwX2xpbmUiLCJoZWFkZXIiLCJrZXkiLCJjb25zIiwiZW1wIiwicmVjIiwiZmluaXNoIiwic2NoZWR1bGVfc2l6ZSIsImZpeGVkIiwidW5leHBlY3RlZCIsIm0iLCJtJDAiLCJwIiwic2l6ZSIsImhleCQwIiwicGFyc2VyIiwib2siLCJyZXF1ZXN0JDAiLCJyZXNwb25zZSQwIiwicmVxdWVzdF9xdWV1ZSIsInJlc3BkIiwidHJhbnNpdGlvbiIsImNvbnRpbnVlJDAiLCJjb21taXR0ZWQiLCJjb25zdW1lZCIsIm1zZyIsIm1hcmtzIiwiY29uc3VtZWQkMCIsInN0YXJ0IiwicmVhZF93aXRoX21vcmUiLCJicyIsIm1vcmUiLCJpbml0aWFsIiwib2ZmJDAiLCJyZWFkX3dpdGhfbW9yZSQwIiwiZmFpbHVyZSIsInJlYWRlciIsInJlc3BvbnNlX2JvZHlfYnVmZmVyIiwicmVzcG9uc2Vfc3RhdGUiLCJyZXNwb25zZV9leG4iLCJyZXNwb25kX3dpdGhfc3RyaW5nIiwicmVzcG9uZF93aXRoX2JpZ3N0cmluZyIsImJzdHIiLCJ1bnNhZmVfcmVzcG9uZF93aXRoX3N0cmVhbWluZyIsImZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHkiLCJyZXNwb25kX3dpdGhfc3RyZWFtaW5nIiwidW5zYWZlX3Jlc3BvbmRfd2l0aF91cGdyYWRlIiwidXBncmFkZV9oYW5kbGVyIiwicmVzcG9uZF93aXRoX3VwZ3JhZGUiLCJyZXBvcnRfZXhuIiwidHJ5X3dpdGgiLCJlcnJvcl9jb2RlIiwiaXNfYWN0aXZlIiwiY3VycmVudF9yZXFkX2V4biIsInlpZWxkX3JlYWRlciIsIndha2V1cF9yZWFkZXIiLCJyZXFkIiwieWllbGRfd3JpdGVyIiwid2FrZXVwX3dyaXRlciIsImRlZmF1bHRfZXJyb3JfaGFuZGxlciIsImhhbmRsZSIsIm1lc3NhZ2UiLCJyZXF1ZXN0X2hhbmRsZXIiLCJjb25maWciLCJyZXNwb25zZV9ib2R5X2J1ZmZlcl9zaXplIiwicmVzcG9uc2VfYnVmZmVyX3NpemUiLCJjYWxsX2hhbmRsZXIiLCJzaHV0ZG93bl9yZWFkZXIiLCJzaHV0ZG93bl93cml0ZXIiLCJzaHV0ZG93biIsInNldF9lcnJvcl9hbmRfaGFuZGxlIiwiYWR2YW5jZV9yZXF1ZXN0X3F1ZXVlIiwibmV4dF9yZWFkX29wZXJhdGlvbiQxIiwib3BlcmF0aW9uIiwiZmluYWxfcmVhZF9vcGVyYXRpb25fZm9yJDAiLCJvcCIsIm5leHRfcmVhZF9vcGVyYXRpb24iLCJmaW5hbF9yZWFkX29wZXJhdGlvbl9mb3IiLCJuZXh0X3JlYWRfb3BlcmF0aW9uJDAiLCJyZWFkIiwicmVhZF9lb2YiLCJmbHVzaF9yZXNwb25zZV9lcnJvcl9ib2R5IiwibmV4dF93cml0ZV9vcGVyYXRpb24kMSIsImZpbmFsX3dyaXRlX29wZXJhdGlvbl9mb3IkMCIsIm5leHRfd3JpdGVfb3BlcmF0aW9uIiwiZmluYWxfd3JpdGVfb3BlcmF0aW9uX2ZvciIsIm5leHRfd3JpdGVfb3BlcmF0aW9uJDAiLCJyZXBvcnRfd3JpdGVfcmVzdWx0IiwiaXNfd2FpdGluZyIsImN1cnJlbnRfcmVzcGRfZXhuIiwiY3JlYXRlX3JlcXVlc3RfYm9keSIsImhhbmRsZV9ub3ciLCJ1bmV4cGVjdGVkX2VvZiIsIm1heWJlX3BpcGVsaW5lX3F1ZXVlZF9yZXF1ZXN0cyIsInByZXYiLCJwcmV2JDAiLCJvcGVyYXRpb24kMCIsIm9wZXJhdGlvbiQxIiwibWVzc2FnZSQwIiwiYnl0ZXNfcmVhZCJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1odHRwYWZfL3ZlcnNpb24ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taHR0cGFmXy9zdGF0dXMubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taHR0cGFmXy9oZWFkZXJzLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWh0dHBhZl8vaU9WZWMubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taHR0cGFmXy9tZXNzYWdlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWh0dHBhZl8vbWV0aG9kLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWh0dHBhZl8vb3B0aW9uYWxfdGh1bmsubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taHR0cGFmXy9yZXF1ZXN0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWh0dHBhZl8vcmVzcG9uc2UubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taHR0cGFmXy9zZXJpYWxpemUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taHR0cGFmXy9ib2R5Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWh0dHBhZl8vcmVzcGQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taHR0cGFmXy9wYXJzZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1odHRwYWZfL3Jlc3BvbnNlX3N0YXRlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWh0dHBhZl8vcmVxZC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1odHRwYWZfL3NlcnZlcl9jb25uZWN0aW9uLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWh0dHBhZl8vY2xpZW50X2Nvbm5lY3Rpb24ubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQXNDSUE7SUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFFQUMsVUFBVUMsR0FBRUM7SUFDZCw4QkFEWUQ7SUFFUSxVQUFBLHVCQUZOQztJQUVkLDhCQUZZRDtJQUdaLDhCQUhZQTtJQUlRLFVBQUEsdUJBSk5DO0lBSU0sT0FBQSw4QkFKUkQ7R0FJK0I7WUFFekNFLFFBQVFDLEdBQUVDO0lBQ1osSUFBSUMscUJBRE1GLE1BQUVDO0lBRVosYUFESUMscUJBRE1GLE1BQUVDLFFBQ1JDO0dBQ3lDO1lBRTNDQyxVQUFVTDtJQUNaLFNBRFlBO2VBQUFBO21CQUVrQjttQkFDQTs7SUFFcEIsSUFBSkQsSUFBSTtJQWZSRCxVQWVJQyxHQUxNQztJQU1WLE9BQUEsNkJBRElE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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cblxudHlwZSB0ID1cbiAgeyBtYWpvciA6IGludFxuICA7IG1pbm9yIDogaW50IH1cblxubGV0IHYxXzAgPSB7IG1ham9yID0gMTsgbWlub3IgPSAwIH1cbmxldCB2MV8xID0geyBtYWpvciA9IDE7IG1pbm9yID0gMSB9XG5cbmxldCB0b19idWZmZXIgYiB0ID1cbiAgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkhUVFAvXCI7XG4gIEJ1ZmZlci5hZGRfc3RyaW5nIGIgKHN0cmluZ19vZl9pbnQgdC5tYWpvcik7XG4gIEJ1ZmZlci5hZGRfY2hhciAgIGIgJy4nO1xuICBCdWZmZXIuYWRkX3N0cmluZyBiIChzdHJpbmdfb2ZfaW50IHQubWlub3IpXG5cbmxldCBjb21wYXJlIHggeSA9XG4gIGxldCBjID0gY29tcGFyZSB4Lm1ham9yIHkubWFqb3IgaW5cbiAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlIGNvbXBhcmUgeC5taW5vciB5Lm1pbm9yXG5cbmxldCB0b19zdHJpbmcgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IHsgbWFqb3IgPSAxOyBtaW5vciA9IDAgfSAtPiBcIkhUVFAvMS4wXCJcbiAgfCB7IG1ham9yID0gMTsgbWlub3IgPSAxIH0gLT4gXCJIVFRQLzEuMVwiXG4gIHwgXyAtPlxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSA4IGluXG4gICAgdG9fYnVmZmVyIGIgdDtcbiAgICBCdWZmZXIuY29udGVudHMgYlxuXG5sZXQgb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBcIkhUVFAvMS4xXCIgLT4geyBtYWpvciA9IDE7IG1pbm9yID0gMSB9XG4gIHwgXCJIVFRQLzEuMFwiIC0+IHsgbWFqb3IgPSAxOyBtaW5vciA9IDAgfVxuICB8IHMgLT5cbiAgICB0cnkgU2NhbmYuc3NjYW5mIHMgXCJIVFRQLyVkLiVkXCIgKGZ1biBtYWpvciBtaW5vciAtPiB7IG1ham9yOyBtaW5vciB9KVxuICAgIHdpdGggXyAtPiByYWlzZSAoRmFpbHVyZSBcIlZlcnNpb24ub2Zfc3RyaW5nXCIpXG5cbmxldCBwcF9odW0gZm10IHQgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJIVFRQLyVkLiVkXCIgdC5tYWpvciB0Lm1pbm9yXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cblxudHlwZSBpbmZvcm1hdGlvbmFsID0gW1xuICB8IGBDb250aW51ZVxuICB8IGBTd2l0Y2hpbmdfcHJvdG9jb2xzXG4gIF1cblxudHlwZSBzdWNjZXNzZnVsID0gW1xuICB8IGBPS1xuICB8IGBDcmVhdGVkXG4gIHwgYEFjY2VwdGVkXG4gIHwgYE5vbl9hdXRob3JpdGF0aXZlX2luZm9ybWF0aW9uXG4gIHwgYE5vX2NvbnRlbnRcbiAgfCBgUmVzZXRfY29udGVudFxuICB8IGBQYXJ0aWFsX2NvbnRlbnRcbiAgXVxuXG50eXBlIHJlZGlyZWN0aW9uID0gW1xuICB8IGBNdWx0aXBsZV9jaG9pY2VzXG4gIHwgYE1vdmVkX3Blcm1hbmVudGx5XG4gIHwgYEZvdW5kXG4gIHwgYFNlZV9vdGhlclxuICB8IGBOb3RfbW9kaWZpZWRcbiAgfCBgVXNlX3Byb3h5XG4gIHwgYFRlbXBvcmFyeV9yZWRpcmVjdFxuICBdXG5cbnR5cGUgY2xpZW50X2Vycm9yID0gW1xuICB8IGBCYWRfcmVxdWVzdFxuICB8IGBVbmF1dGhvcml6ZWRcbiAgfCBgUGF5bWVudF9yZXF1aXJlZFxuICB8IGBGb3JiaWRkZW5cbiAgfCBgTm90X2ZvdW5kXG4gIHwgYE1ldGhvZF9ub3RfYWxsb3dlZFxuICB8IGBOb3RfYWNjZXB0YWJsZVxuICB8IGBQcm94eV9hdXRoZW50aWNhdGlvbl9yZXF1aXJlZFxuICB8IGBSZXF1ZXN0X3RpbWVvdXRcbiAgfCBgQ29uZmxpY3RcbiAgfCBgR29uZVxuICB8IGBMZW5ndGhfcmVxdWlyZWRcbiAgfCBgUHJlY29uZGl0aW9uX2ZhaWxlZFxuICB8IGBQYXlsb2FkX3Rvb19sYXJnZVxuICB8IGBVcmlfdG9vX2xvbmdcbiAgfCBgVW5zdXBwb3J0ZWRfbWVkaWFfdHlwZVxuICB8IGBSYW5nZV9ub3Rfc2F0aXNmaWFibGVcbiAgfCBgRXhwZWN0YXRpb25fZmFpbGVkXG4gIHwgYElfbV9hX3RlYXBvdFxuICB8IGBFbmhhbmNlX3lvdXJfY2FsbVxuICB8IGBVcGdyYWRlX3JlcXVpcmVkXG4gIHwgYFByZWNvbmRpdGlvbl9yZXF1aXJlZFxuICB8IGBUb29fbWFueV9yZXF1ZXN0c1xuICB8IGBSZXF1ZXN0X2hlYWRlcl9maWVsZHNfdG9vX2xhcmdlXG4gIF1cblxudHlwZSBzZXJ2ZXJfZXJyb3IgPSBbXG4gIHwgYEludGVybmFsX3NlcnZlcl9lcnJvclxuICB8IGBOb3RfaW1wbGVtZW50ZWRcbiAgfCBgQmFkX2dhdGV3YXlcbiAgfCBgU2VydmljZV91bmF2YWlsYWJsZVxuICB8IGBHYXRld2F5X3RpbWVvdXRcbiAgfCBgSHR0cF92ZXJzaW9uX25vdF9zdXBwb3J0ZWRcbiAgfCBgTmV0d29ya19hdXRoZW50aWNhdGlvbl9yZXF1aXJlZFxuICBdXG5cbnR5cGUgc3RhbmRhcmQgPSBbXG4gIHwgaW5mb3JtYXRpb25hbFxuICB8IHN1Y2Nlc3NmdWxcbiAgfCByZWRpcmVjdGlvblxuICB8IGNsaWVudF9lcnJvclxuICB8IHNlcnZlcl9lcnJvclxuICBdXG5cbnR5cGUgdCA9IFtcbiAgfCBzdGFuZGFyZFxuICB8IGBDb2RlIG9mIGludCBdXG5cbmxldCBkZWZhdWx0X3JlYXNvbl9waHJhc2UgPSBmdW5jdGlvblxuICgqIEluZm9ybWF0aW9uYWwgKilcbiAgfCBgQ29udGludWUgLT4gXCJDb250aW51ZVwiXG4gIHwgYFN3aXRjaGluZ19wcm90b2NvbHMgLT4gXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCJcbiAoKiBTdWNjZXNzZnVsICopXG4gIHwgYE9LIC0+IFwiT0tcIlxuICB8IGBDcmVhdGVkIC0+IFwiQ3JlYXRlZFwiXG4gIHwgYEFjY2VwdGVkIC0+IFwiQWNjZXB0ZWRcIlxuICB8IGBOb25fYXV0aG9yaXRhdGl2ZV9pbmZvcm1hdGlvbiAtPiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCJcbiAgfCBgTm9fY29udGVudCAtPiBcIk5vIENvbnRlbnRcIlxuICB8IGBSZXNldF9jb250ZW50IC0+IFwiUmVzZXQgQ29udGVudFwiXG4gIHwgYFBhcnRpYWxfY29udGVudCAtPiBcIlBhcnRpYWwgQ29udGVudFwiXG4gKCogUmVkaXJlY3Rpb24gKilcbiAgfCBgTXVsdGlwbGVfY2hvaWNlcyAtPiBcIk11bHRpcGxlIENob2ljZXNcIlxuICB8IGBNb3ZlZF9wZXJtYW5lbnRseSAtPiBcIk1vdmVkIFBlcm1hbmVudGx5XCJcbiAgfCBgRm91bmQgLT4gXCJGb3VuZFwiXG4gIHwgYFNlZV9vdGhlciAtPiBcIlNlZSBPdGhlclwiXG4gIHwgYE5vdF9tb2RpZmllZCAtPiBcIk5vdCBNb2RpZmllZFwiXG4gIHwgYFVzZV9wcm94eSAtPiBcIlVzZSBQcm94eVwiXG4gIHwgYFRlbXBvcmFyeV9yZWRpcmVjdCAtPiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiXG4gKCogQ2xpZW50IGVycm9yICopXG4gIHwgYEJhZF9yZXF1ZXN0IC0+IFwiQmFkIFJlcXVlc3RcIlxuICB8IGBVbmF1dGhvcml6ZWQgLT4gXCJVbmF1dGhvcml6ZWRcIlxuICB8IGBQYXltZW50X3JlcXVpcmVkIC0+IFwiUGF5bWVudCBSZXF1aXJlZFwiXG4gIHwgYEZvcmJpZGRlbiAtPiBcIkZvcmJpZGRlblwiXG4gIHwgYE5vdF9mb3VuZCAtPiBcIk5vdCBGb3VuZFwiXG4gIHwgYE1ldGhvZF9ub3RfYWxsb3dlZCAtPiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiXG4gIHwgYE5vdF9hY2NlcHRhYmxlLT4gXCJOb3QgQWNjZXB0YWJsZVwiXG4gIHwgYFByb3h5X2F1dGhlbnRpY2F0aW9uX3JlcXVpcmVkIC0+IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxuICB8IGBSZXF1ZXN0X3RpbWVvdXQgLT4gXCJSZXF1ZXN0IFRpbWVvdXRcIlxuICB8IGBDb25mbGljdCAtPiBcIkNvbmZsaWN0XCJcbiAgfCBgR29uZSAtPiBcIkdvbmVcIlxuICB8IGBMZW5ndGhfcmVxdWlyZWQgLT4gXCJMZW5ndGggUmVxdWlyZWRcIlxuICB8IGBQcmVjb25kaXRpb25fZmFpbGVkIC0+IFwiUHJlY29uZGl0aW9uIEZhaWxlZFwiXG4gIHwgYFBheWxvYWRfdG9vX2xhcmdlIC0+IFwiUGF5bG9hZCBUb28gTGFyZ2VcIlxuICB8IGBVcmlfdG9vX2xvbmcgLT4gXCJVUkkgVG9vIExvbmdcIlxuICB8IGBVbnN1cHBvcnRlZF9tZWRpYV90eXBlIC0+IFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiXG4gIHwgYFJhbmdlX25vdF9zYXRpc2ZpYWJsZSAtPiBcIlJhbmdlIE5vdCBTYXRpc2ZpYWJsZVwiXG4gIHwgYEV4cGVjdGF0aW9uX2ZhaWxlZCAtPiBcIkV4cGVjdGF0aW9uIEZhaWxlZFwiXG4gIHwgYElfbV9hX3RlYXBvdCAtPiBcIkknbSBhIHRlYXBvdFwiICgqIFJGQyAyMzQyICopXG4gIHwgYEVuaGFuY2VfeW91cl9jYWxtIC0+IFwiRW5oYW5jZSBZb3VyIENhbG1cIlxuICB8IGBVcGdyYWRlX3JlcXVpcmVkIC0+IFwiVXBncmFkZSBSZXF1aXJlZFwiXG4gIHwgYFByZWNvbmRpdGlvbl9yZXF1aXJlZCAtPiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiXG4gIHwgYFRvb19tYW55X3JlcXVlc3RzIC0+IFwiVG9vIE1hbnkgUmVxdWVzdHNcIlxuICB8IGBSZXF1ZXN0X2hlYWRlcl9maWVsZHNfdG9vX2xhcmdlIC0+IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiXG4gKCogU2VydmVyIGVycm9yICopXG4gIHwgYEludGVybmFsX3NlcnZlcl9lcnJvciAtPiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiXG4gIHwgYE5vdF9pbXBsZW1lbnRlZCAtPiBcIk5vdCBJbXBsZW1lbnRlZFwiXG4gIHwgYEJhZF9nYXRld2F5IC0+IFwiQmFkIEdhdGV3YXlcIlxuICB8IGBTZXJ2aWNlX3VuYXZhaWxhYmxlLT4gXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCJcbiAgfCBgR2F0ZXdheV90aW1lb3V0IC0+IFwiR2F0ZXdheSBUaW1lb3V0XCJcbiAgfCBgSHR0cF92ZXJzaW9uX25vdF9zdXBwb3J0ZWQgLT4gXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiXG4gIHwgYE5ldHdvcmtfYXV0aGVudGljYXRpb25fcmVxdWlyZWQgLT4gXCJOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCJcblxubGV0IHRvX2NvZGUgPSBmdW5jdGlvblxuICgqIEluZm9ybWF0aW9uYWwgKilcbiAgfCBgQ29udGludWUgLT4gMTAwXG4gIHwgYFN3aXRjaGluZ19wcm90b2NvbHMgLT4gMTAxXG4gKCogU3VjY2Vzc2Z1bCAqKVxuICB8IGBPSyAtPiAyMDBcbiAgfCBgQ3JlYXRlZCAtPiAyMDFcbiAgfCBgQWNjZXB0ZWQgLT4gMjAyXG4gIHwgYE5vbl9hdXRob3JpdGF0aXZlX2luZm9ybWF0aW9uIC0+IDIwM1xuICB8IGBOb19jb250ZW50IC0+IDIwNFxuICB8IGBSZXNldF9jb250ZW50IC0+IDIwNVxuICB8IGBQYXJ0aWFsX2NvbnRlbnQgLT4gMjA2XG4gKCogUmVkaXJlY3Rpb24gKilcbiAgfCBgTXVsdGlwbGVfY2hvaWNlcyAtPiAzMDBcbiAgfCBgTW92ZWRfcGVybWFuZW50bHkgLT4gMzAxXG4gIHwgYEZvdW5kIC0+IDMwMlxuICB8IGBTZWVfb3RoZXIgLT4gMzAzXG4gIHwgYE5vdF9tb2RpZmllZCAtPiAzMDRcbiAgfCBgVXNlX3Byb3h5IC0+IDMwNVxuICB8IGBUZW1wb3JhcnlfcmVkaXJlY3QgLT4gMzA3XG4gKCogQ2xpZW50IGVycm9yICopXG4gIHwgYEJhZF9yZXF1ZXN0IC0+IDQwMFxuICB8IGBVbmF1dGhvcml6ZWQgLT4gNDAxXG4gIHwgYFBheW1lbnRfcmVxdWlyZWQgLT4gNDAyXG4gIHwgYEZvcmJpZGRlbiAtPiA0MDNcbiAgfCBgTm90X2ZvdW5kIC0+IDQwNFxuICB8IGBNZXRob2Rfbm90X2FsbG93ZWQgLT4gNDA1XG4gIHwgYE5vdF9hY2NlcHRhYmxlIC0+IDQwNlxuICB8IGBQcm94eV9hdXRoZW50aWNhdGlvbl9yZXF1aXJlZCAtPiA0MDdcbiAgfCBgUmVxdWVzdF90aW1lb3V0IC0+IDQwOFxuICB8IGBDb25mbGljdCAtPiA0MDlcbiAgfCBgR29uZSAtPiA0MTBcbiAgfCBgTGVuZ3RoX3JlcXVpcmVkIC0+IDQxMVxuICB8IGBQcmVjb25kaXRpb25fZmFpbGVkIC0+IDQxMlxuICB8IGBQYXlsb2FkX3Rvb19sYXJnZSAtPiA0MTNcbiAgfCBgVXJpX3Rvb19sb25nIC0+IDQxNFxuICB8IGBVbnN1cHBvcnRlZF9tZWRpYV90eXBlIC0+IDQxNVxuICB8IGBSYW5nZV9ub3Rfc2F0aXNmaWFibGUgLT4gNDE2XG4gIHwgYEV4cGVjdGF0aW9uX2ZhaWxlZCAtPiA0MTdcbiAgfCBgSV9tX2FfdGVhcG90IC0+IDQxOFxuICB8IGBFbmhhbmNlX3lvdXJfY2FsbSAtPiA0MjBcbiAgfCBgVXBncmFkZV9yZXF1aXJlZCAtPiA0MjZcbiAgfCBgUHJlY29uZGl0aW9uX3JlcXVpcmVkIC0+IDQyOFxuICB8IGBUb29fbWFueV9yZXF1ZXN0cyAtPiA0MjlcbiAgfCBgUmVxdWVzdF9oZWFkZXJfZmllbGRzX3Rvb19sYXJnZSAtPiA0MzFcbiAoKiBTZXJ2ZXIgZXJyb3IgKilcbiAgfCBgSW50ZXJuYWxfc2VydmVyX2Vycm9yIC0+IDUwMFxuICB8IGBOb3RfaW1wbGVtZW50ZWQgLT4gNTAxXG4gIHwgYEJhZF9nYXRld2F5IC0+IDUwMlxuICB8IGBTZXJ2aWNlX3VuYXZhaWxhYmxlLT4gNTAzXG4gIHwgYEdhdGV3YXlfdGltZW91dCAtPiA1MDRcbiAgfCBgSHR0cF92ZXJzaW9uX25vdF9zdXBwb3J0ZWQgLT4gNTA1XG4gIHwgYE5ldHdvcmtfYXV0aGVudGljYXRpb25fcmVxdWlyZWQgLT4gNTExXG4gIHwgYENvZGUgYyAtPiBjXG5cbmxldCByZWFsbHlfdW5zYWZlX29mX2NvZGUgPSBmdW5jdGlvblxuICgqIEluZm9ybWF0aW9uYWwgKilcbiAgfCAxMDAgLT4gYENvbnRpbnVlXG4gIHwgMTAxIC0+IGBTd2l0Y2hpbmdfcHJvdG9jb2xzXG4gKCogU3VjY2Vzc2Z1bCAqKVxuICB8IDIwMCAtPiBgT0tcbiAgfCAyMDEgLT4gYENyZWF0ZWRcbiAgfCAyMDIgLT4gYEFjY2VwdGVkXG4gIHwgMjAzIC0+IGBOb25fYXV0aG9yaXRhdGl2ZV9pbmZvcm1hdGlvblxuICB8IDIwNCAtPiBgTm9fY29udGVudFxuICB8IDIwNSAtPiBgUmVzZXRfY29udGVudFxuICB8IDIwNiAtPiBgUGFydGlhbF9jb250ZW50XG4gKCogUmVkaXJlY3Rpb24gKilcbiAgfCAzMDAgLT4gYE11bHRpcGxlX2Nob2ljZXNcbiAgfCAzMDEgLT4gYE1vdmVkX3Blcm1hbmVudGx5XG4gIHwgMzAyIC0+IGBGb3VuZFxuICB8IDMwMyAtPiBgU2VlX290aGVyXG4gIHwgMzA0IC0+IGBOb3RfbW9kaWZpZWRcbiAgfCAzMDUgLT4gYFVzZV9wcm94eVxuICB8IDMwNyAtPiBgVGVtcG9yYXJ5X3JlZGlyZWN0XG4gKCogQ2xpZW50IGVycm9yICopXG4gIHwgNDAwIC0+IGBCYWRfcmVxdWVzdFxuICB8IDQwMSAtPiBgVW5hdXRob3JpemVkXG4gIHwgNDAyIC0+IGBQYXltZW50X3JlcXVpcmVkXG4gIHwgNDAzIC0+IGBGb3JiaWRkZW5cbiAgfCA0MDQgLT4gYE5vdF9mb3VuZFxuICB8IDQwNSAtPiBgTWV0aG9kX25vdF9hbGxvd2VkXG4gIHwgNDA2IC0+IGBOb3RfYWNjZXB0YWJsZVxuICB8IDQwNyAtPiBgUHJveHlfYXV0aGVudGljYXRpb25fcmVxdWlyZWRcbiAgfCA0MDggLT4gYFJlcXVlc3RfdGltZW91dFxuICB8IDQwOSAtPiBgQ29uZmxpY3RcbiAgfCA0MTAgLT4gYEdvbmVcbiAgfCA0MTEgLT4gYExlbmd0aF9yZXF1aXJlZFxuICB8IDQxMiAtPiBgUHJlY29uZGl0aW9uX2ZhaWxlZFxuICB8IDQxMyAtPiBgUGF5bG9hZF90b29fbGFyZ2VcbiAgfCA0MTQgLT4gYFVyaV90b29fbG9uZ1xuICB8IDQxNSAtPiBgVW5zdXBwb3J0ZWRfbWVkaWFfdHlwZVxuICB8IDQxNiAtPiBgUmFuZ2Vfbm90X3NhdGlzZmlhYmxlXG4gIHwgNDE3IC0+IGBFeHBlY3RhdGlvbl9mYWlsZWRcbiAgfCA0MTggLT4gYElfbV9hX3RlYXBvdFxuICB8IDQyMCAtPiBgRW5oYW5jZV95b3VyX2NhbG1cbiAgfCA0MjYgLT4gYFVwZ3JhZGVfcmVxdWlyZWRcbiAgfCA0MjggLT4gYFByZWNvbmRpdGlvbl9yZXF1aXJlZFxuICB8IDQyOSAtPiBgVG9vX21hbnlfcmVxdWVzdHNcbiAgfCA0MzEgLT4gYFJlcXVlc3RfaGVhZGVyX2ZpZWxkc190b29fbGFyZ2VcbiAoKiBTZXJ2ZXIgZXJyb3IgKilcbiAgfCA1MDAgLT4gYEludGVybmFsX3NlcnZlcl9lcnJvclxuICB8IDUwMSAtPiBgTm90X2ltcGxlbWVudGVkXG4gIHwgNTAyIC0+IGBCYWRfZ2F0ZXdheVxuICB8IDUwMyAtPiBgU2VydmljZV91bmF2YWlsYWJsZVxuICB8IDUwNCAtPiBgR2F0ZXdheV90aW1lb3V0XG4gIHwgNTA1IC0+IGBIdHRwX3ZlcnNpb25fbm90X3N1cHBvcnRlZFxuICB8IDUxMSAtPiBgTmV0d29ya19hdXRoZW50aWNhdGlvbl9yZXF1aXJlZFxuICB8IGMgICAtPiBgQ29kZSBjXG5cbmxldCB1bnNhZmVfb2ZfY29kZSBjID1cbiAgbWF0Y2ggcmVhbGx5X3Vuc2FmZV9vZl9jb2RlIGMgd2l0aFxuICB8IGBDb2RlIGMgLT5cbiAgICBpZiBjIDwgMFxuICAgIHRoZW4gZmFpbHdpdGggKFByaW50Zi5zcHJpbnRmIFwiU3RhdHVzLnVuc2FmZV9vZl9jb2RlOiAlZCBpcyBuZWdhdGl2ZVwiIGMpXG4gICAgZWxzZSBgQ29kZSBjXG4gIHwgcyAtPiBzXG5cbmxldCBvZl9jb2RlIGMgPVxuICBtYXRjaCByZWFsbHlfdW5zYWZlX29mX2NvZGUgYyB3aXRoXG4gIHwgYENvZGUgYyAtPlxuICAgIGlmIGMgPCAxMDAgfHwgYyA+IDk5OVxuICAgIHRoZW4gZmFpbHdpdGggKFByaW50Zi5zcHJpbnRmIFwiU3RhdHVzLm9mX2NvZGU6ICVkIGlzIG5vdCBhIHRocmVlLWRpZ2l0IG51bWJlclwiIGMpXG4gICAgZWxzZSBgQ29kZSBjXG4gIHwgcyAtPiBzXG5cbmxldCBpc19pbmZvcm1hdGlvbmFsIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCAjaW5mb3JtYXRpb25hbCAtPiB0cnVlXG4gIHwgYENvZGUgbiAgICAgICAgLT4gbiA+PSAxMDAgJiYgbiA8PSAxOTlcbiAgfCBfICAgICAgICAgICAgICAtPiBmYWxzZVxuXG5sZXQgaXNfc3VjY2Vzc2Z1bCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgI3N1Y2Nlc3NmdWwgLT4gdHJ1ZVxuICB8IGBDb2RlIG4gICAgIC0+IG4gPj0gMjAwICYmIG4gPD0gMjk5XG4gIHwgXyAgICAgICAgICAgLT4gZmFsc2VcblxubGV0IGlzX3JlZGlyZWN0aW9uIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCAjcmVkaXJlY3Rpb24gLT4gdHJ1ZVxuICB8IGBDb2RlIG4gICAgICAtPiBuID49IDMwMCAmJiBuIDw9IDM5OVxuICB8IF8gICAgICAgICAgICAtPiBmYWxzZVxuXG5sZXQgaXNfY2xpZW50X2Vycm9yIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCAjY2xpZW50X2Vycm9yIC0+IHRydWVcbiAgfCBgQ29kZSBuICAgICAgIC0+IG4gPj0gNDAwICYmIG4gPD0gNDk5XG4gIHwgXyAgICAgICAgICAgICAtPiBmYWxzZVxuXG5sZXQgaXNfc2VydmVyX2Vycm9yIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCAjc2VydmVyX2Vycm9yIC0+IHRydWVcbiAgfCBgQ29kZSBuICAgICAgIC0+IG4gPj0gNTAwICYmIG4gPD0gNTk5XG4gIHwgXyAgICAgICAgICAgICAtPiBmYWxzZVxuXG5sZXQgaXNfZXJyb3IgdCA9XG4gIGlzX2NsaWVudF9lcnJvciB0IHx8IGlzX3NlcnZlcl9lcnJvciB0XG5cblxubGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uICgqIGRvbid0IGFsbG9jYXRlICopXG4gKCogSW5mb3JtYXRpb25hbCAqKVxuICB8IGBDb250aW51ZSAtPiBcIjEwMFwiXG4gIHwgYFN3aXRjaGluZ19wcm90b2NvbHMgLT4gXCIxMDFcIlxuICgqIFN1Y2Nlc3NmdWwgKilcbiAgfCBgT0sgLT4gXCIyMDBcIlxuICB8IGBDcmVhdGVkIC0+IFwiMjAxXCJcbiAgfCBgQWNjZXB0ZWQgLT4gXCIyMDJcIlxuICB8IGBOb25fYXV0aG9yaXRhdGl2ZV9pbmZvcm1hdGlvbiAtPiBcIjIwM1wiXG4gIHwgYE5vX2NvbnRlbnQgLT4gXCIyMDRcIlxuICB8IGBSZXNldF9jb250ZW50IC0+IFwiMjA1XCJcbiAgfCBgUGFydGlhbF9jb250ZW50IC0+IFwiMjA2XCJcbiAoKiBSZWRpcmVjdGlvbiAqKVxuICB8IGBNdWx0aXBsZV9jaG9pY2VzIC0+IFwiMzAwXCJcbiAgfCBgTW92ZWRfcGVybWFuZW50bHkgLT4gXCIzMDFcIlxuICB8IGBGb3VuZCAtPiBcIjMwMlwiXG4gIHwgYFNlZV9vdGhlciAtPiBcIjMwM1wiXG4gIHwgYE5vdF9tb2RpZmllZCAtPiBcIjMwNFwiXG4gIHwgYFVzZV9wcm94eSAtPiBcIjMwNVwiXG4gIHwgYFRlbXBvcmFyeV9yZWRpcmVjdCAtPiBcIjMwN1wiXG4gKCogQ2xpZW50IGVycm9yICopXG4gIHwgYEJhZF9yZXF1ZXN0IC0+IFwiNDAwXCJcbiAgfCBgVW5hdXRob3JpemVkIC0+IFwiNDAxXCJcbiAgfCBgUGF5bWVudF9yZXF1aXJlZCAtPiBcIjQwMlwiXG4gIHwgYEZvcmJpZGRlbiAtPiBcIjQwM1wiXG4gIHwgYE5vdF9mb3VuZCAtPiBcIjQwNFwiXG4gIHwgYE1ldGhvZF9ub3RfYWxsb3dlZCAtPiBcIjQwNVwiXG4gIHwgYE5vdF9hY2NlcHRhYmxlIC0+IFwiNDA2XCJcbiAgfCBgUHJveHlfYXV0aGVudGljYXRpb25fcmVxdWlyZWQgLT4gXCI0MDdcIlxuICB8IGBSZXF1ZXN0X3RpbWVvdXQgLT4gXCI0MDhcIlxuICB8IGBDb25mbGljdCAtPiBcIjQwOVwiXG4gIHwgYEdvbmUgLT4gXCI0MTBcIlxuICB8IGBMZW5ndGhfcmVxdWlyZWQgLT4gXCI0MTFcIlxuICB8IGBQcmVjb25kaXRpb25fZmFpbGVkIC0+IFwiNDEyXCJcbiAgfCBgUGF5bG9hZF90b29fbGFyZ2UgLT4gXCI0MTNcIlxuICB8IGBVcmlfdG9vX2xvbmcgLT4gXCI0MTRcIlxuICB8IGBVbnN1cHBvcnRlZF9tZWRpYV90eXBlIC0+IFwiNDE1XCJcbiAgfCBgUmFuZ2Vfbm90X3NhdGlzZmlhYmxlIC0+IFwiNDE2XCJcbiAgfCBgRXhwZWN0YXRpb25fZmFpbGVkIC0+IFwiNDE3XCJcbiAgfCBgSV9tX2FfdGVhcG90IC0+IFwiNDE4XCJcbiAgfCBgRW5oYW5jZV95b3VyX2NhbG0gLT4gXCI0MjBcIlxuICB8IGBVcGdyYWRlX3JlcXVpcmVkIC0+IFwiNDI2XCJcbiAgfCBgUHJlY29uZGl0aW9uX3JlcXVpcmVkIC0+IFwiNDI4XCJcbiAgfCBgVG9vX21hbnlfcmVxdWVzdHMgLT4gXCI0MjlcIlxuICB8IGBSZXF1ZXN0X2hlYWRlcl9maWVsZHNfdG9vX2xhcmdlIC0+IFwiNDMxXCJcbiAoKiBTZXJ2ZXIgZXJyb3IgKilcbiAgfCBgSW50ZXJuYWxfc2VydmVyX2Vycm9yIC0+IFwiNTAwXCJcbiAgfCBgTm90X2ltcGxlbWVudGVkIC0+IFwiNTAxXCJcbiAgfCBgQmFkX2dhdGV3YXkgLT4gXCI1MDJcIlxuICB8IGBTZXJ2aWNlX3VuYXZhaWxhYmxlLT4gXCI1MDNcIlxuICB8IGBHYXRld2F5X3RpbWVvdXQgLT4gXCI1MDRcIlxuICB8IGBIdHRwX3ZlcnNpb25fbm90X3N1cHBvcnRlZCAtPiBcIjUwNVwiXG4gIHwgYE5ldHdvcmtfYXV0aGVudGljYXRpb25fcmVxdWlyZWQtPiBcIjUxMVwiXG4gIHwgYENvZGUgYyAtPiBzdHJpbmdfb2ZfaW50IGMgKCogZXhjZXB0IGZvciB0aGlzICopXG5cbmxldCBvZl9zdHJpbmcgeCA9XG4gIG9mX2NvZGUgKGludF9vZl9zdHJpbmcgeClcblxubGV0IHBwX2h1bSBmbXQgdCA9XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiV1XCIgKHRvX2NvZGUgdClcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxuXG50eXBlIG5hbWUgPSBzdHJpbmdcbnR5cGUgdmFsdWUgPSBzdHJpbmdcbnR5cGUgdCA9IChuYW1lICogdmFsdWUpIGxpc3RcblxubGV0IGVtcHR5IDogdCA9IFtdXG5cbmxldCBvZl9yZXZfbGlzdCB0ID0gdFxubGV0IG9mX2xpc3QgdCA9IG9mX3Jldl9saXN0IChMaXN0LnJldiB0KVxubGV0IHRvX3Jldl9saXN0IHQgPSB0XG5sZXQgdG9fbGlzdCB0ID0gTGlzdC5yZXYgKHRvX3Jldl9saXN0IHQpXG5cbm1vZHVsZSBDSSA9IHN0cnVjdFxuICAoKiBDb252ZXJ0IGNvZGVzIHRvIHVwcGVyIGNhc2UgYW5kIGNvbXBhcmUgdGhlbS4gVGhpcyBpcyBhIHBvcnQgb2YgYXNzZW1ibHlcbiAgICAgY29kZSBmcm9tIHRoZSBwYWdlOlxuXG4gICAgICBodHRwOi8vd3d3LmF6aWxsaW9ubW9ua2V5cy5jb20vcWVkL2FzbWV4YW1wbGUuaHRtbCAqKVxuICBsZXRbQGlubGluZSBhbHdheXNdIGNoYXJfY29kZV9lcXVhbF9jaSB4IHkgPVxuICAgIGxldCBjb2RlcyA9ICh4IGxzbCA4KSBsb3IgeSBpblxuICAgIGxldCBiID0gMHg4MDgwIGxvciBjb2RlcyBpblxuICAgIGxldCBjID0gYiAtIDB4NjE2MSBpblxuICAgIGxldCBkID0gbG5vdCAoYiAtIDB4N2I3YikgaW5cbiAgICBsZXQgZSA9IChjIGxhbmQgZCkgbGFuZCAobG5vdCBjb2RlcyBsYW5kIDB4ODA4MCkgaW5cbiAgICBsZXQgdXBwZXIgPSBjb2RlcyAtIChlIGxzciAyKSBpblxuICAgIHVwcGVyIGxzciA4ID0gdXBwZXIgbGFuZCAweGZmXG5cbiAgbGV0IGVxdWFsIHggeSA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggeCBpblxuICAgIGxlbiA9IFN0cmluZy5sZW5ndGggeSAmJiAoXG4gICAgICBsZXQgZXF1YWxfc29fZmFyID0gcmVmIHRydWUgaW5cbiAgICAgIGxldCBpICAgICAgICAgICAgPSByZWYgMCBpblxuICAgICAgd2hpbGUgIWVxdWFsX3NvX2ZhciAmJiAhaSA8IGxlbiBkb1xuICAgICAgICBsZXQgYzEgPSBDaGFyLmNvZGUgKFN0cmluZy51bnNhZmVfZ2V0IHggIWkpIGluXG4gICAgICAgIGxldCBjMiA9IENoYXIuY29kZSAoU3RyaW5nLnVuc2FmZV9nZXQgeSAhaSkgaW5cbiAgICAgICAgZXF1YWxfc29fZmFyIDo9IGNoYXJfY29kZV9lcXVhbF9jaSBjMSBjMjtcbiAgICAgICAgaW5jciBpXG4gICAgICBkb25lO1xuICAgICAgIWVxdWFsX3NvX2ZhclxuICAgIClcbmVuZFxuXG5sZXQgY2lfZXF1YWwgPSBDSS5lcXVhbFxuXG5sZXQgcmVjIG1lbSB0IG5hbWUgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCAobmFtZScsIF8pOjp0JyAtPiBDSS5lcXVhbCBuYW1lIG5hbWUnIHx8IG1lbSB0JyBuYW1lXG4gIHwgXyAgICAgICAgICAgICAtPiBmYWxzZVxuXG5sZXQgYWRkIHQgbmFtZSB2YWx1ZSA9IChuYW1lLHZhbHVlKTo6dFxubGV0IGFkZF9saXN0IHQgbHMgPSBscyBAIHQgKCogWFhYKHNlbGlvcG91KTogZG8gYmV0dGVyIGhlcmUgKilcbmxldCBhZGRfbXVsdGkgPVxuICBsZXQgcmVjIGxvb3Bfb3V0ZXIgdCBsc3MgPVxuICAgIG1hdGNoIGxzcyB3aXRoXG4gICAgfCBbXSAtPiB0XG4gICAgfCAobix2cyk6OmxzcycgLT4gbG9vcF9pbm5lciB0IG4gdnMgbHNzJ1xuICBhbmQgbG9vcF9pbm5lciB0IG4gdnMgbHNzID1cbiAgICBtYXRjaCB2cyB3aXRoXG4gICAgfCBbXSAgICAgLT4gbG9vcF9vdXRlciB0IGxzc1xuICAgIHwgdjo6dnMnIC0+IGxvb3BfaW5uZXIgKChuLHYpOjp0KSBuIHZzJyBsc3NcbiAgaW5cbiAgbG9vcF9vdXRlclxuXG5sZXQgYWRkX3VubGVzc19leGlzdHMgdCBuYW1lIHZhbHVlID1cbiAgaWYgbWVtIHQgbmFtZSB0aGVuIHQgZWxzZSAobmFtZSx2YWx1ZSk6OnRcblxuZXhjZXB0aW9uIExvY2FsXG5cbmxldCByZXBsYWNlIHQgbmFtZSB2YWx1ZSA9XG4gIGxldCByZWMgbG9vcCB0IG5lZWRsZSBudiBzZWVuID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBpZiBub3Qgc2VlbiB0aGVuIHJhaXNlIExvY2FsIGVsc2UgW11cbiAgICB8IChuYW1lLF8gYXMgbnYnKTo6dCAtPlxuICAgICAgaWYgQ0kuZXF1YWwgbmVlZGxlIG5hbWVcbiAgICAgIHRoZW4gKFxuICAgICAgICBpZiBzZWVuXG4gICAgICAgIHRoZW4gbG9vcCB0IG5lZWRsZSBudiB0cnVlXG4gICAgICAgIGVsc2UgbnY6Omxvb3AgdCBuZWVkbGUgbnYgdHJ1ZSlcbiAgICAgIGVsc2UgbnYnOjpsb29wIHQgbmVlZGxlIG52IHNlZW5cbiAgaW5cbiAgdHJ5IGxvb3AgdCBuYW1lIChuYW1lLHZhbHVlKSBmYWxzZVxuICB3aXRoIExvY2FsIC0+IHRcblxubGV0IHJlbW92ZSB0IG5hbWUgPVxuICBsZXQgcmVjIGxvb3AgcyBuZWVkbGUgc2VlbiA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgaWYgbm90IHNlZW4gdGhlbiByYWlzZSBMb2NhbCBlbHNlIFtdXG4gICAgfCAobmFtZSxfIGFzIG52Jyk6OnMnIC0+XG4gICAgICBpZiBDSS5lcXVhbCBuZWVkbGUgbmFtZVxuICAgICAgdGhlbiBsb29wIHMnIG5lZWRsZSB0cnVlXG4gICAgICBlbHNlIG52Jzo6KGxvb3AgcycgbmVlZGxlIHNlZW4pXG4gIGluXG4gIHRyeSBsb29wIHQgbmFtZSBmYWxzZVxuICB3aXRoIExvY2FsIC0+IHRcblxubGV0IGdldCB0IG5hbWUgPVxuICBsZXQgcmVjIGxvb3AgdCBuID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IChuJyx2KTo6dCcgLT4gaWYgQ0kuZXF1YWwgbiBuJyB0aGVuIFNvbWUgdiBlbHNlIGxvb3AgdCcgblxuICBpblxuICBsb29wIHQgbmFtZVxuXG5sZXQgZ2V0X2V4biB0IG5hbWUgPVxuICBsZXQgcmVjIGxvb3AgdCBuID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgIHwgKG4nLHYpOjp0JyAtPiBpZiBDSS5lcXVhbCBuIG4nIHRoZW4gdiBlbHNlIGxvb3AgdCcgblxuICBpblxuICBsb29wIHQgbmFtZVxuXG5sZXQgZ2V0X211bHRpIHQgbmFtZSA9XG4gIGxldCByZWMgbG9vcCB0IG4gYWNjID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgKG4nLHYpOjp0JyAtPlxuICAgICAgaWYgQ0kuZXF1YWwgbiBuJ1xuICAgICAgdGhlbiBsb29wIHQnIG4gKHY6OmFjYylcbiAgICAgIGVsc2UgbG9vcCB0JyBuIGFjY1xuICBpblxuICBsb29wIHQgbmFtZSBbXVxuXG5sZXQgaXRlciB+ZiB0ID1cbiAgTGlzdC5pdGVyIChmdW4gKG5hbWUsdmFsdWUpIC0+IGYgbmFtZSB2YWx1ZSkgdFxuXG5sZXQgZm9sZCB+ZiB+aW5pdCB0ID1cbiAgTGlzdC5mb2xkX2xlZnQgKGZ1biBhY2MgKG5hbWUsdmFsdWUpIC0+IGYgbmFtZSB2YWx1ZSBhY2MpIGluaXQgdFxuXG5sZXQgdG9fc3RyaW5nIHQgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTI4IGluXG4gIGl0ZXIgKHRvX2xpc3QgdCkgfmY6KGZ1biBuYW1lIHZhbHVlIC0+XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYiBuYW1lO1xuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCI6IFwiO1xuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGIgdmFsdWU7XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIlxcclxcblwiKTtcbiAgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIlxcclxcblwiO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG5sZXQgcHBfaHVtIGZtdCB0ID1cbiAgbGV0IHBwX2VsZW0gZm10IChuLHYpID0gRm9ybWF0LmZwcmludGYgZm10IFwiQFsoJVMgJVMpQF1cIiBuIHYgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiQFsoXCI7XG4gIEZvcm1hdC5wcF9wcmludF9saXN0IHBwX2VsZW0gZm10ICh0b19saXN0IHQpO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIpQF1cIjtcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxuXG50eXBlICdhIHQgPSAnYSBGYXJhZGF5LmlvdmVjID1cbiAgeyBidWZmZXIgOiAnYVxuICA7IG9mZiA6IGludFxuICA7IGxlbiA6IGludCB9XG5cbmxldCBsZW5ndGggeyBsZW47IF8gfSA9IGxlblxubGV0IGxlbmd0aHYgaW92cyA9IExpc3QuZm9sZF9sZWZ0IChmdW4gYWNjIHsgbGVuOyBfIH0gLT4gYWNjICsgbGVuKSAwIGlvdnNcblxubGV0IHNoaWZ0IHsgYnVmZmVyOyBvZmY7IGxlbiB9IG4gPVxuICBhc3NlcnQgKG4gPD0gbGVuKTtcbiAgeyBidWZmZXI7IG9mZiA9IG9mZiArIG47IGxlbiA9IGxlbiAtIG4gfVxuXG5sZXQgc2hpZnR2IGlvdmVjcyBuID1cbiAgaWYgbiA8IDAgdGhlbiBmYWlsd2l0aCAoUHJpbnRmLnNwcmludGYgXCJJT1ZlYy5zaGlmdHY6ICVkIGlzIGEgbmVnYXRpdmUgbnVtYmVyXCIgbik7XG4gIGxldCByZWMgbG9vcCBpb3ZlY3MgbiA9XG4gICAgaWYgbiA9IDBcbiAgICB0aGVuIGlvdmVjc1xuICAgIGVsc2UgbWF0Y2ggaW92ZWNzIHdpdGhcbiAgICB8IFtdICAgICAgICAgICAgLT4gZmFpbHdpdGggXCJzaGlmdHY6IG4gPiBsZW5ndGh2IGlvdmVjc1wiXG4gICAgfCBpb3ZlYzo6aW92ZWNzIC0+XG4gICAgICBsZXQgaW92ZWNfbGVuID0gbGVuZ3RoIGlvdmVjIGluXG4gICAgICBpZiBpb3ZlY19sZW4gPD0gblxuICAgICAgdGhlbiBsb29wIGlvdmVjcyAobiAtIGlvdmVjX2xlbilcbiAgICAgIGVsc2UgKHNoaWZ0IGlvdmVjIG4pOjppb3ZlY3NcbiAgaW5cbiAgbG9vcCBpb3ZlY3MgblxuXG5sZXQgYWRkX2xlbiB7IGJ1ZmZlcjsgb2ZmOyBsZW4gfSBuID1cbiAgeyBidWZmZXI7IG9mZjsgbGVuID0gbGVuICsgbiB9XG5cbmxldCBwcF9odW0gZm10IHQgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJ7IGJ1ZmZlciA9IDxvcGFxdWU+OyBvZmYgPSAlZDsgbGVuID0gJWQgfVwiIHQub2ZmIHQubGVuXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cblxuKCogVGhpcyBtb2R1bGUgY29udGFpbnMgZnVuY3Rpb25hbGl0eSB0aGF0IGFwcGxpZXMgdG8gYm90aCByZXF1ZXN0cyBhbmRcbiAgIHJlc3BvbnNlcywgd2hpY2ggYXJlIGNvbGxlY3RpdmVseSByZWZlcnJlZCB0byBpbiB0aGUgSFRUUCAxLjEgc3BlY2lmaWNhdGlvbnNcbiAgIGFzICdtZXNzYWdlcycuICopXG5cbmxldCBwZXJzaXN0ZW50X2Nvbm5lY3Rpb24gPyhwcm94eT1mYWxzZSkgdmVyc2lvbiBoZWFkZXJzID1cbiAgbGV0IF8gPSBwcm94eSBpblxuICAoKiBYWFgoc2VsaW9wb3UpOiB1c2UgcHJveHkgYXJndW1lbnQgaW4gdGhlIGNhc2Ugb2YgSFRUUC8xLjAgYXMgcGVyXG4gICAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tNi4zICopXG4gIG1hdGNoIEhlYWRlcnMuZ2V0IGhlYWRlcnMgXCJjb25uZWN0aW9uXCIgd2l0aFxuICB8IFNvbWUgXCJjbG9zZVwiICAgICAgLT4gZmFsc2VcbiAgfCBTb21lIFwia2VlcC1hbGl2ZVwiIC0+IFZlcnNpb24uKGNvbXBhcmUgdmVyc2lvbiB2MV8wKSA+PSAwXG4gIHwgXyAgICAgICAgICAgICAgICAgLT4gVmVyc2lvbi4oY29tcGFyZSB2ZXJzaW9uIHYxXzEpID49IDBcblxubGV0IHNvcnRfdW5pcSB4cyA9XG4gICgqIFRob3VnaCB7IUxpc3Quc29ydF91bmlxfSBwZXJmb3JtcyBhIGNoZWNrIG9uIHRoZSBpbnB1dCBsZW5ndGggYW5kIHJldHVybnNcbiAgICogaW1tZWRpYXRlbHkgZm9yIGxpc3RzIG9mIGxlbmd0aCBsZXNzIHRoYW4gWzJdLCBpdCBzdGlsbCBhbGxvY2F0ZXMgY2xvc3VyZXNcbiAgICogYmVmb3JlIGl0IGRvZXMgdGhhdCBjaGVjayEgVG8gYXZvaWQgdGhhdCBqdXN0IGRvIG91ciBvd24gY2hlY2tpbmcgaGVyZSB0b1xuICAgKiBhdm9pZCB0aGUgYWxsb2NhdGlvbnMgaW4gdGhlIGNvbW1vbiBjYXNlLiAqKVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gfCBbIF8gXSAtPiB4c1xuICB8IF8gICAgICAgICAgLT4gTGlzdC5zb3J0X3VuaXEgU3RyaW5nLmNvbXBhcmUgeHNcblxubGV0IHVuaXF1ZV9jb250ZW50X2xlbmd0aF92YWx1ZXMgaGVhZGVycyA9XG4gICgqIFhYWChzZWxpb3BvdSk6IHBlcmZvcm0gcHJvcGVyIGNvbnRlbnQtbGVuZ3RoIHBhcnNpbmcgKilcbiAgc29ydF91bmlxIChIZWFkZXJzLmdldF9tdWx0aSBoZWFkZXJzIFwiY29udGVudC1sZW5ndGhcIilcblxubGV0IGNvbnRlbnRfbGVuZ3RoX29mX3N0cmluZyBzID1cbiAgdHJ5IEludDY0Lm9mX3N0cmluZyBzIHdpdGggXyAtPiAtMUxcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxuXG50eXBlIHN0YW5kYXJkID0gIFtcbiAgfCBgR0VUXG4gIHwgYEhFQURcbiAgfCBgUE9TVFxuICB8IGBQVVRcbiAgfCBgREVMRVRFXG4gIHwgYENPTk5FQ1RcbiAgfCBgT1BUSU9OU1xuICB8IGBUUkFDRVxuXVxuXG50eXBlIHQgPSBbXG4gIHwgc3RhbmRhcmRcbiAgfCBgT3RoZXIgb2Ygc3RyaW5nXG4gIF1cblxubGV0IGlzX3NhZmUgPSBmdW5jdGlvblxuICB8IGBHRVQgfCBgSEVBRCB8IGBPUFRJT05TIHwgYFRSQUNFIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBpc19jYWNoZWFibGUgPSBmdW5jdGlvblxuICB8IGBHRVQgfCBgSEVBRCB8IGBQT1NUIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBpc19pZGVtcG90ZW50ID0gZnVuY3Rpb25cbiAgfCBgUFVUIHwgYERFTEVURSAtPiB0cnVlXG4gIHwgdCAtPiBpc19zYWZlIHRcblxubGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uXG4gIHwgYEdFVCAtPiBcIkdFVFwiXG4gIHwgYEhFQUQgLT4gXCJIRUFEXCJcbiAgfCBgUE9TVCAtPiBcIlBPU1RcIlxuICB8IGBQVVQgLT4gXCJQVVRcIlxuICB8IGBERUxFVEUgLT4gXCJERUxFVEVcIlxuICB8IGBDT05ORUNUIC0+IFwiQ09OTkVDVFwiXG4gIHwgYE9QVElPTlMgLT4gXCJPUFRJT05TXCJcbiAgfCBgVFJBQ0UgLT4gXCJUUkFDRVwiXG4gIHwgYE90aGVyIHMgLT4gc1xuXG5sZXQgb2Zfc3RyaW5nID1cbiAgZnVuY3Rpb25cbiAgfCBcIkdFVFwiIC0+IGBHRVRcbiAgfCBcIkhFQURcIiAtPiBgSEVBRFxuICB8IFwiUE9TVFwiIC0+IGBQT1NUXG4gIHwgXCJQVVRcIiAtPiBgUFVUXG4gIHwgXCJERUxFVEVcIiAtPiBgREVMRVRFXG4gIHwgXCJDT05ORUNUXCIgLT4gYENPTk5FQ1RcbiAgfCBcIk9QVElPTlNcIiAtPiBgT1BUSU9OU1xuICB8IFwiVFJBQ0VcIiAtPiBgVFJBQ0VcbiAgfCBzIC0+IGBPdGhlciBzXG5cbmxldCBwcF9odW0gZm10IHQgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlc1wiICh0b19zdHJpbmcgdClcbiIsInR5cGUgdCA9IHVuaXQgLT4gdW5pdFxuXG5sZXQgbm9uZSA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgKGZ1biAoKSAtPiAoKSlcbmxldCBzb21lIGYgPVxuICBpZiBmID09IG5vbmVcbiAgdGhlbiBmYWlsd2l0aCBcIk9wdGlvbmFsX3RodW5rOiB0aGlzIGZ1bmN0aW9uIGlzIG5vdCByZXByZXNlbnRhYmxlIGFzIGEgc29tZSB2YWx1ZVwiO1xuICBmXG5cbmxldCBpc19ub25lIHQgPSB0ID09IG5vbmVcbmxldCBpc19zb21lIHQgPSBub3QgKGlzX25vbmUgdClcbmxldCBjYWxsX2lmX3NvbWUgdCA9IHQgKClcbmxldCB1bmNoZWNrZWRfdmFsdWUgdCA9IHRcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxudHlwZSB0ID1cbiAgeyBtZXRoICAgIDogTWV0aG9kLnRcbiAgOyB0YXJnZXQgIDogc3RyaW5nXG4gIDsgdmVyc2lvbiA6IFZlcnNpb24udFxuICA7IGhlYWRlcnMgOiBIZWFkZXJzLnQgfVxuXG5sZXQgY3JlYXRlID8odmVyc2lvbj1WZXJzaW9uLnYxXzEpID8oaGVhZGVycz1IZWFkZXJzLmVtcHR5KSBtZXRoIHRhcmdldCA9XG4gIHsgbWV0aDsgdGFyZ2V0OyB2ZXJzaW9uOyBoZWFkZXJzIH1cblxubGV0IGJhZF9yZXF1ZXN0ID0gYEVycm9yIGBCYWRfcmVxdWVzdFxuXG5tb2R1bGUgQm9keV9sZW5ndGggPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gW1xuICAgIHwgYEZpeGVkIG9mIEludDY0LnRcbiAgICB8IGBDaHVua2VkXG4gICAgfCBgRXJyb3Igb2YgW2BCYWRfcmVxdWVzdF1cbiAgXVxuXG4gIGxldCBwcF9odW0gZm10IChsZW4gOiB0KSA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IGBGaXhlZCBuIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIkZpeGVkICVMaVwiIG5cbiAgICB8IGBDaHVua2VkIC0+IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm10IFwiQ2h1bmtlZFwiXG4gICAgfCBgRXJyb3IgYEJhZF9yZXF1ZXN0IC0+IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm10IFwiRXJyb3I6IEJhZCByZXF1ZXN0XCJcbiAgOztcbmVuZFxuXG5sZXQgYm9keV9sZW5ndGggeyBoZWFkZXJzOyBfIH0gOiBCb2R5X2xlbmd0aC50ID1cbiAgKCogVGhlIGxhc3QgZW50cnkgaW4gdHJhbnNmZXItZW5jb2RpbmcgaXMgdGhlIGNvcnJlY3QgZW50cnkuIFdlIG9ubHkgYWNjZXB0XG4gICAgIGNodW5rZWQgdHJhbnNmZXItZW5jb2RpbmdzLiAqKVxuICBtYXRjaCBMaXN0LnJldiAoSGVhZGVycy5nZXRfbXVsdGkgaGVhZGVycyBcInRyYW5zZmVyLWVuY29kaW5nXCIpIHdpdGhcbiAgfCB2YWx1ZTo6XyB3aGVuIEhlYWRlcnMuY2lfZXF1YWwgdmFsdWUgXCJjaHVua2VkXCIgLT4gYENodW5rZWRcbiAgfCBfICAgIDo6XyAtPiBiYWRfcmVxdWVzdFxuICB8IFtdIC0+XG4gICAgYmVnaW4gbWF0Y2ggTWVzc2FnZS51bmlxdWVfY29udGVudF9sZW5ndGhfdmFsdWVzIGhlYWRlcnMgd2l0aFxuICAgIHwgW10gICAgICAtPiBgRml4ZWQgMExcbiAgICB8IFsgbGVuIF0gLT5cbiAgICAgIGxldCBsZW4gPSBNZXNzYWdlLmNvbnRlbnRfbGVuZ3RoX29mX3N0cmluZyBsZW4gaW5cbiAgICAgIGlmIGxlbiA+PSAwTFxuICAgICAgdGhlbiBgRml4ZWQgbGVuXG4gICAgICBlbHNlIGJhZF9yZXF1ZXN0XG4gICAgfCBfICAgICAgIC0+IGJhZF9yZXF1ZXN0XG4gICAgZW5kXG5cbmxldCBwZXJzaXN0ZW50X2Nvbm5lY3Rpb24gP3Byb3h5IHsgdmVyc2lvbjsgaGVhZGVyczsgXyB9ID1cbiAgTWVzc2FnZS5wZXJzaXN0ZW50X2Nvbm5lY3Rpb24gP3Byb3h5IHZlcnNpb24gaGVhZGVyc1xuXG5sZXQgcHBfaHVtIGZtdCB7IG1ldGg7IHRhcmdldDsgdmVyc2lvbjsgaGVhZGVycyB9ID1cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiKChtZXRob2QgXFxcIiVhXFxcIikgKHRhcmdldCAlUykgKHZlcnNpb24gXFxcIiVhXFxcIikgKGhlYWRlcnMgJWEpKVwiXG4gICAgTWV0aG9kLnBwX2h1bSBtZXRoIHRhcmdldCBWZXJzaW9uLnBwX2h1bSB2ZXJzaW9uIEhlYWRlcnMucHBfaHVtIGhlYWRlcnNcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxudHlwZSB0ID1cbiAgeyB2ZXJzaW9uIDogVmVyc2lvbi50XG4gIDsgc3RhdHVzICA6IFN0YXR1cy50XG4gIDsgcmVhc29uICA6IHN0cmluZ1xuICA7IGhlYWRlcnMgOiBIZWFkZXJzLnQgfVxuXG5sZXQgY3JlYXRlID9yZWFzb24gPyh2ZXJzaW9uPVZlcnNpb24udjFfMSkgPyhoZWFkZXJzPUhlYWRlcnMuZW1wdHkpIHN0YXR1cyA9XG4gIGxldCByZWFzb24gPVxuICAgIG1hdGNoIHJlYXNvbiB3aXRoXG4gICAgfCBTb21lIHJlYXNvbiAtPiByZWFzb25cbiAgICB8IE5vbmUgLT5cbiAgICAgIGJlZ2luIG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICB8ICNTdGF0dXMuc3RhbmRhcmQgYXMgc3RhdHVzIC0+IFN0YXR1cy5kZWZhdWx0X3JlYXNvbl9waHJhc2Ugc3RhdHVzXG4gICAgICB8IGBDb2RlIF8gICAgICAgICAgICAgICAgICAgIC0+IFwiTm9uLXN0YW5kYXJkIHN0YXR1cyBjb2RlXCJcbiAgICAgIGVuZFxuICBpblxuICB7IHZlcnNpb247IHN0YXR1czsgcmVhc29uOyBoZWFkZXJzIH1cblxubGV0IHBlcnNpc3RlbnRfY29ubmVjdGlvbiA/cHJveHkgeyB2ZXJzaW9uOyBoZWFkZXJzOyBfIH0gPVxuICBNZXNzYWdlLnBlcnNpc3RlbnRfY29ubmVjdGlvbiA/cHJveHkgdmVyc2lvbiBoZWFkZXJzXG5cbmxldCBwcm94eV9lcnJvciAgPSBgRXJyb3IgYEJhZF9nYXRld2F5XG5sZXQgc2VydmVyX2Vycm9yID0gYEVycm9yIGBJbnRlcm5hbF9zZXJ2ZXJfZXJyb3JcblxubW9kdWxlIEJvZHlfbGVuZ3RoID0gc3RydWN0XG4gIHR5cGUgdCA9IFtcbiAgICB8IGBGaXhlZCBvZiBJbnQ2NC50XG4gICAgfCBgQ2h1bmtlZFxuICAgIHwgYENsb3NlX2RlbGltaXRlZFxuICAgIHwgYEVycm9yIG9mIFsgYEJhZF9nYXRld2F5IHwgYEludGVybmFsX3NlcnZlcl9lcnJvciBdXG4gIF1cblxuICBsZXQgcHBfaHVtIGZtdCAobGVuIDogdCkgPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBgRml4ZWQgbiAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCJGaXhlZCAlTGlcIiBuXG4gICAgfCBgQ2h1bmtlZCAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBcIkNodW5rZWRcIlxuICAgIHwgYENsb3NlX2RlbGltaXRlZCAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBcIkNsb3NlIGRlbGltaXRlZFwiXG4gICAgfCBgRXJyb3IgYEJhZF9nYXRld2F5IC0+IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm10IFwiRXJyb3I6IEJhZCBnYXRld2F5XCJcbiAgICB8IGBFcnJvciBgSW50ZXJuYWxfc2VydmVyX2Vycm9yIC0+XG4gICAgICAgIEZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm10IFwiRXJyb3I6IEludGVybmFsIHNlcnZlciBlcnJvclwiXG4gIDs7XG5lbmRcblxubGV0IGJvZHlfbGVuZ3RoID8ocHJveHk9ZmFsc2UpIH5yZXF1ZXN0X21ldGhvZCB7IHN0YXR1czsgaGVhZGVyczsgXyB9IDogQm9keV9sZW5ndGgudCA9XG4gIG1hdGNoIHN0YXR1cywgcmVxdWVzdF9tZXRob2Qgd2l0aFxuICB8IF8sIGBIRUFEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPlxuICAgICgqIEZyb20gUkZDNzIzMMKnMy4zLjI6XG4gICAgICAgICBBIHNlcnZlciBNQVkgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZCBpbiBhIHJlc3BvbnNlIHRvIGFcbiAgICAgICAgIEhFQUQgcmVxdWVzdCAoU2VjdGlvbiA0LjMuMiBvZiBbUkZDNzIzMV0pOyBhIHNlcnZlciBNVVNUIE5PVCBzZW5kXG4gICAgICAgICBDb250ZW50LUxlbmd0aCBpbiBzdWNoIGEgcmVzcG9uc2UgdW5sZXNzIGl0cyBmaWVsZC12YWx1ZSBlcXVhbHMgdGhlXG4gICAgICAgICBkZWNpbWFsIG51bWJlciBvZiBvY3RldHMgdGhhdCB3b3VsZCBoYXZlIGJlZW4gc2VudCBpbiB0aGUgcGF5bG9hZCBib2R5XG4gICAgICAgICBvZiBhIHJlc3BvbnNlIGlmIHRoZSBzYW1lIHJlcXVlc3QgaGFkIHVzZWQgdGhlIEdFVCBtZXRob2QuICopXG4gICAgYEZpeGVkIDBMXG4gIHwgKGBOb19jb250ZW50IHwgYE5vdF9tb2RpZmllZCksIF8gICAgICAgICAgIC0+XG4gICAgKCogRnJvbSBSRkM3MjMwwqczLjMuMjpcbiAgICAgICAgIEEgc2VydmVyIE1BWSBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIGZpZWxkIGluIGEgMzA0IChOb3RcbiAgICAgICAgIE1vZGlmaWVkKSByZXNwb25zZSB0byBhIGNvbmRpdGlvbmFsIEdFVCByZXF1ZXN0IChTZWN0aW9uIDQuMSBvZlxuICAgICAgICAgW1JGQzcyMzJdKTsgYSBzZXJ2ZXIgTVVTVCBOT1Qgc2VuZCBDb250ZW50LUxlbmd0aCBpbiBzdWNoIGEgcmVzcG9uc2VcbiAgICAgICAgIHVubGVzcyBpdHMgZmllbGQtdmFsdWUgZXF1YWxzIHRoZSBkZWNpbWFsIG51bWJlciBvZiBvY3RldHMgdGhhdCB3b3VsZFxuICAgICAgICAgaGF2ZSBiZWVuIHNlbnQgaW4gdGhlIHBheWxvYWQgYm9keSBvZiBhIDIwMCAoT0spIHJlc3BvbnNlIHRvIHRoZSBzYW1lXG4gICAgICAgICByZXF1ZXN0LiAqKVxuICAgIGBGaXhlZCAwTFxuICB8IHMsIF8gICAgICAgIHdoZW4gU3RhdHVzLmlzX2luZm9ybWF0aW9uYWwgcyAtPiBgRml4ZWQgMExcbiAgfCBzLCBgQ09OTkVDVCB3aGVuIFN0YXR1cy5pc19zdWNjZXNzZnVsIHMgICAgLT4gYENsb3NlX2RlbGltaXRlZFxuICB8IF8sIF8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPlxuICAgICgqIFRoZSBsYXN0IGVudHJ5IGluIHRyYW5zZmVyLWVuY29kaW5nIGlzIHRoZSBjb3JyZWN0IGVudHJ5LiBXZSBvbmx5IGhhbmRsZVxuICAgICAgIGNodW5rZWQgdHJhbnNmZXItZW5jb2RpbmdzLiAqKVxuICAgIGJlZ2luIG1hdGNoIExpc3QucmV2IChIZWFkZXJzLmdldF9tdWx0aSBoZWFkZXJzIFwidHJhbnNmZXItZW5jb2RpbmdcIikgd2l0aFxuICAgIHwgdmFsdWU6Ol8gd2hlbiBIZWFkZXJzLmNpX2VxdWFsIHZhbHVlIFwiY2h1bmtlZFwiIC0+IGBDaHVua2VkXG4gICAgfCBfICAgIDo6XyAtPiBgQ2xvc2VfZGVsaW1pdGVkXG4gICAgfCBbXSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggTWVzc2FnZS51bmlxdWVfY29udGVudF9sZW5ndGhfdmFsdWVzIGhlYWRlcnMgd2l0aFxuICAgICAgfCBbXSAgICAgIC0+IGBDbG9zZV9kZWxpbWl0ZWRcbiAgICAgIHwgWyBsZW4gXSAtPlxuICAgICAgICBsZXQgbGVuID0gTWVzc2FnZS5jb250ZW50X2xlbmd0aF9vZl9zdHJpbmcgbGVuIGluXG4gICAgICAgIGlmIGxlbiA+PSAwTFxuICAgICAgICB0aGVuIGBGaXhlZCBsZW5cbiAgICAgICAgZWxzZSBpZiBwcm94eSB0aGVuIHByb3h5X2Vycm9yIGVsc2Ugc2VydmVyX2Vycm9yXG4gICAgICB8IF8gICAgICAgLT5cbiAgICAgICAgaWYgcHJveHkgdGhlbiBwcm94eV9lcnJvciBlbHNlIHNlcnZlcl9lcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbmxldCBwcF9odW0gZm10IHsgdmVyc2lvbjsgc3RhdHVzOyByZWFzb247IGhlYWRlcnMgfSA9XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIigodmVyc2lvbiBcXFwiJWFcXFwiKSAoc3RhdHVzICVhKSAocmVhc29uICVTKSAoaGVhZGVycyAlYSkpXCJcbiAgICBWZXJzaW9uLnBwX2h1bSB2ZXJzaW9uIFN0YXR1cy5wcF9odW0gc3RhdHVzIHJlYXNvbiBIZWFkZXJzLnBwX2h1bSBoZWFkZXJzXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbm9wZW4gRmFyYWRheVxuXG5sZXQgd3JpdGVfc3BhY2UgdCAgID0gd3JpdGVfY2hhciB0ICcgJ1xubGV0IHdyaXRlX2NybGYgIHQgICA9IHdyaXRlX3N0cmluZyB0IFwiXFxyXFxuXCJcblxubGV0IHdyaXRlX3ZlcnNpb24gdCB2ZXJzaW9uID1cbiAgd3JpdGVfc3RyaW5nIHQgKFZlcnNpb24udG9fc3RyaW5nIHZlcnNpb24pXG5cbmxldCB3cml0ZV9tZXRob2QgdCBtZXRoID1cbiAgd3JpdGVfc3RyaW5nIHQgKE1ldGhvZC50b19zdHJpbmcgbWV0aClcblxubGV0IHdyaXRlX3N0YXR1cyB0IHN0YXR1cyA9XG4gIHdyaXRlX3N0cmluZyB0IChTdGF0dXMudG9fc3RyaW5nIHN0YXR1cylcblxubGV0IHdyaXRlX2hlYWRlcnMgdCBoZWFkZXJzID1cbiAgKCogWFhYKHNlbGlvcG91KTogZXNjYXBlIHRoZXNlIHRoaWducyAqKVxuICBMaXN0Lml0ZXIgKGZ1biAobmFtZSwgdmFsdWUpIC0+XG4gICAgd3JpdGVfc3RyaW5nIHQgbmFtZTtcbiAgICB3cml0ZV9zdHJpbmcgdCBcIjogXCI7XG4gICAgd3JpdGVfc3RyaW5nIHQgdmFsdWU7XG4gICAgd3JpdGVfY3JsZiAgIHQpXG4gIChIZWFkZXJzLnRvX2xpc3QgaGVhZGVycyk7XG4gIHdyaXRlX2NybGYgdFxuXG5sZXQgd3JpdGVfcmVxdWVzdCB0IHsgUmVxdWVzdC5tZXRoOyB0YXJnZXQ7IHZlcnNpb247IGhlYWRlcnMgfSA9XG4gIHdyaXRlX21ldGhvZCAgdCBtZXRoICAgOyB3cml0ZV9zcGFjZSB0O1xuICB3cml0ZV9zdHJpbmcgIHQgdGFyZ2V0IDsgd3JpdGVfc3BhY2UgdDtcbiAgd3JpdGVfdmVyc2lvbiB0IHZlcnNpb247IHdyaXRlX2NybGYgIHQ7XG4gIHdyaXRlX2hlYWRlcnMgdCBoZWFkZXJzXG5cbmxldCB3cml0ZV9yZXNwb25zZSB0IHsgUmVzcG9uc2UudmVyc2lvbjsgc3RhdHVzOyByZWFzb247IGhlYWRlcnMgfSA9XG4gIHdyaXRlX3ZlcnNpb24gdCB2ZXJzaW9uOyB3cml0ZV9zcGFjZSB0O1xuICB3cml0ZV9zdGF0dXMgIHQgc3RhdHVzIDsgd3JpdGVfc3BhY2UgdDtcbiAgd3JpdGVfc3RyaW5nICB0IHJlYXNvbiA7IHdyaXRlX2NybGYgIHQ7XG4gIHdyaXRlX2hlYWRlcnMgdCBoZWFkZXJzXG5cbmxldCB3cml0ZV9jaHVua19sZW5ndGggdCBsZW4gPVxuICB3cml0ZV9zdHJpbmcgdCAoUHJpbnRmLnNwcmludGYgXCIleFwiIGxlbik7XG4gIHdyaXRlX2NybGYgICB0XG5cbmxldCB3cml0ZV9zdHJpbmdfY2h1bmsgdCBjaHVuayA9XG4gIHdyaXRlX2NodW5rX2xlbmd0aCB0IChTdHJpbmcubGVuZ3RoIGNodW5rKTtcbiAgd3JpdGVfc3RyaW5nICAgICAgIHQgY2h1bms7XG4gIHdyaXRlX2NybGYgICAgICAgICB0XG5cbmxldCB3cml0ZV9iaWdzdHJpbmdfY2h1bmsgdCBjaHVuayA9XG4gIHdyaXRlX2NodW5rX2xlbmd0aCB0IChCaWdzdHJpbmdhZi5sZW5ndGggY2h1bmspO1xuICB3cml0ZV9iaWdzdHJpbmcgICAgdCBjaHVuaztcbiAgd3JpdGVfY3JsZiAgICAgICAgIHRcblxubGV0IHNjaGVkdWxlX2JpZ3N0cmluZ19jaHVuayB0IGNodW5rID1cbiAgd3JpdGVfY2h1bmtfbGVuZ3RoIHQgKEJpZ3N0cmluZ2FmLmxlbmd0aCBjaHVuayk7XG4gIHNjaGVkdWxlX2JpZ3N0cmluZyB0IGNodW5rO1xuICB3cml0ZV9jcmxmICAgICAgICAgdFxuXG5tb2R1bGUgV3JpdGVyID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBidWZmZXIgICAgICAgICAgICAgICAgOiBCaWdzdHJpbmdhZi50XG4gICAgICAoKiBUaGUgYnVmZmVyIHRoYXQgdGhlIGVuY29kZXIgdXNlcyBmb3IgYnVmZmVyZWQgd3JpdGVzLiBNYW5hZ2VkIGJ5IHRoZVxuICAgICAgICogY29udHJvbCBtb2R1bGUgZm9yIHRoZSBlbmNvZGVyLiAqKVxuICAgIDsgZW5jb2RlciAgICAgICAgICAgICAgIDogRmFyYWRheS50XG4gICAgICAoKiBUaGUgZW5jb2RlciB0aGF0IGhhbmRsZXMgZW5jb2RpbmcgZm9yIHdyaXRlcy4gVXNlcyB0aGUgW2J1ZmZlcl1cbiAgICAgICAqIHJlZmVyZW5jZWQgYWJvdmUgaW50ZXJuYWxseS4gKilcbiAgICA7IG11dGFibGUgZHJhaW5lZF9ieXRlcyA6IGludFxuICAgICAgKCogVGhlIG51bWJlciBvZiBieXRlcyB0aGF0IHdlcmUgbm90IHdyaXR0ZW4gZHVlIHRvIHRoZSBvdXRwdXQgc3RyZWFtXG4gICAgICAgKiBiZWluZyBjbG9zZWQgYmVmb3JlIGFsbCBidWZmZXJlZCBvdXRwdXQgY291bGQgYmUgd3JpdHRlbi4gVXNlZnVsIGZvclxuICAgICAgICogZGV0ZWN0aW5nIGVycm9yIGNhc2VzLiAqKVxuICAgIDsgbXV0YWJsZSB3YWtldXAgICAgICAgIDogT3B0aW9uYWxfdGh1bmsudFxuICAgICAgKCogVGhlIGNhbGxiYWNrIGZyb20gdGhlIHJ1bnRpbWUgdG8gYmUgaW52b2tlZCB3aGVuIG91dHB1dCBpcyByZWFkeSB0byBiZVxuICAgICAgICogZmx1c2hlZC4gKilcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSA/KGJ1ZmZlcl9zaXplPTB4ODAwKSAoKSA9XG4gICAgbGV0IGJ1ZmZlciA9IEJpZ3N0cmluZ2FmLmNyZWF0ZSBidWZmZXJfc2l6ZSBpblxuICAgIGxldCBlbmNvZGVyID0gRmFyYWRheS5vZl9iaWdzdHJpbmcgYnVmZmVyIGluXG4gICAgeyBidWZmZXJcbiAgICA7IGVuY29kZXJcbiAgICA7IGRyYWluZWRfYnl0ZXMgPSAwXG4gICAgOyB3YWtldXAgPSBPcHRpb25hbF90aHVuay5ub25lXG4gICAgfVxuXG4gIGxldCBmYXJhZGF5IHQgPSB0LmVuY29kZXJcblxuICBsZXQgd3JpdGVfcmVxdWVzdCB0IHJlcXVlc3QgPVxuICAgIHdyaXRlX3JlcXVlc3QgdC5lbmNvZGVyIHJlcXVlc3RcblxuICBsZXQgd3JpdGVfcmVzcG9uc2UgdCByZXNwb25zZSA9XG4gICAgd3JpdGVfcmVzcG9uc2UgdC5lbmNvZGVyIHJlc3BvbnNlXG5cbiAgbGV0IHdyaXRlX3N0cmluZyB0ID9vZmYgP2xlbiBzdHJpbmcgPVxuICAgIHdyaXRlX3N0cmluZyB0LmVuY29kZXIgP29mZiA/bGVuIHN0cmluZ1xuXG4gIGxldCB3cml0ZV9ieXRlcyB0ID9vZmYgP2xlbiBieXRlcyA9XG4gICAgd3JpdGVfYnl0ZXMgdC5lbmNvZGVyID9vZmYgP2xlbiBieXRlc1xuXG4gIGxldCB3cml0ZV9iaWdzdHJpbmcgdCA/b2ZmID9sZW4gYmlnc3RyaW5nID1cbiAgICB3cml0ZV9iaWdzdHJpbmcgdC5lbmNvZGVyID9vZmYgP2xlbiBiaWdzdHJpbmdcblxuICBsZXQgc2NoZWR1bGVfYmlnc3RyaW5nIHQgP29mZiA/bGVuIGJpZ3N0cmluZyA9XG4gICAgc2NoZWR1bGVfYmlnc3RyaW5nIHQuZW5jb2RlciA/b2ZmID9sZW4gYmlnc3RyaW5nXG5cbiAgbGV0IHNjaGVkdWxlX2ZpeGVkIHQgaW92ZWNzID1cbiAgICBMaXN0Lml0ZXIgKGZ1biB7IElPVmVjLmJ1ZmZlcjsgb2ZmOyBsZW4gfSAtPlxuICAgICAgc2NoZWR1bGVfYmlnc3RyaW5nIHQgfm9mZiB+bGVuIGJ1ZmZlcilcbiAgICBpb3ZlY3NcblxuICBsZXQgc2NoZWR1bGVfY2h1bmsgdCBpb3ZlY3MgPVxuICAgIGxldCBsZW5ndGggPSBJT1ZlYy5sZW5ndGh2IGlvdmVjcyBpblxuICAgIHdyaXRlX2NodW5rX2xlbmd0aCB0LmVuY29kZXIgbGVuZ3RoO1xuICAgIHNjaGVkdWxlX2ZpeGVkIHQgaW92ZWNzO1xuICAgIHdyaXRlX2NybGYgICAgIHQuZW5jb2RlclxuXG4gIGxldCBvbl93YWtldXAgdCBrID1cbiAgICBpZiBGYXJhZGF5LmlzX2Nsb3NlZCB0LmVuY29kZXJcbiAgICB0aGVuIGZhaWx3aXRoIFwib25fd2FrZXVwIG9uIGNsb3NlZCB3cml0ZXJcIlxuICAgIGVsc2UgaWYgT3B0aW9uYWxfdGh1bmsuaXNfc29tZSB0Lndha2V1cFxuICAgIHRoZW4gZmFpbHdpdGggXCJvbl93YWtldXA6IG9ubHkgb25lIGNhbGxiYWNrIGNhbiBiZSByZWdpc3RlcmVkIGF0IGEgdGltZVwiXG4gICAgZWxzZSB0Lndha2V1cCA8LSBPcHRpb25hbF90aHVuay5zb21lIGtcbiAgOztcblxuICBsZXQgd2FrZXVwIHQgPVxuICAgIGxldCBmID0gdC53YWtldXAgaW5cbiAgICB0Lndha2V1cCA8LSBPcHRpb25hbF90aHVuay5ub25lO1xuICAgIE9wdGlvbmFsX3RodW5rLmNhbGxfaWZfc29tZSBmXG4gIDs7XG5cbiAgbGV0IGZsdXNoIHQgZiA9XG4gICAgZmx1c2ggdC5lbmNvZGVyIGZcblxuICBsZXQgdW55aWVsZCB0ID1cbiAgICAoKiBUaGlzIHdvdWxkIGJlIGJldHRlciBpbXBsZW1lbnRlZCBieSBhIGZ1bmN0aW9uIHRoYXQganVzdCB0YWtlcyB0aGVcbiAgICAgICBlbmNvZGVyIG91dCBvZiBhIHlpZWxkZWQgc3RhdGUgaWYgaXQncyBpbiB0aGF0IHN0YXRlLiBSZXF1aXJlcyBhIGNoYW5nZVxuICAgICAgIHRvIHRoZSBmYXJhZGF5IGxpYnJhcnkuICopXG4gICAgZmx1c2ggdCAoZnVuICgpIC0+ICgpKVxuXG4gIGxldCB5aWVsZCB0ID1cbiAgICBGYXJhZGF5LnlpZWxkIHQuZW5jb2RlclxuXG4gIGxldCBjbG9zZSB0ID1cbiAgICBGYXJhZGF5LmNsb3NlIHQuZW5jb2RlclxuXG4gIGxldCBjbG9zZV9hbmRfZHJhaW4gdCA9XG4gICAgRmFyYWRheS5jbG9zZSB0LmVuY29kZXI7XG4gICAgbGV0IGRyYWluZWQgPSBGYXJhZGF5LmRyYWluIHQuZW5jb2RlciBpblxuICAgIHQuZHJhaW5lZF9ieXRlcyA8LSB0LmRyYWluZWRfYnl0ZXMgKyBkcmFpbmVkO1xuICAgIHdha2V1cCB0XG5cbiAgbGV0IGlzX2Nsb3NlZCB0ID1cbiAgICBGYXJhZGF5LmlzX2Nsb3NlZCB0LmVuY29kZXJcblxuICBsZXQgZHJhaW5lZF9ieXRlcyB0ID1cbiAgICB0LmRyYWluZWRfYnl0ZXNcblxuICBsZXQgcmVwb3J0X3Jlc3VsdCB0IHJlc3VsdCA9XG4gICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICB8IGBDbG9zZWQgLT4gY2xvc2VfYW5kX2RyYWluIHRcbiAgICB8IGBPayBsZW4gLT4gc2hpZnQgdC5lbmNvZGVyIGxlblxuXG4gIGxldCBuZXh0IHQgPVxuICAgICgqIGFzc2VydCAoT3B0aW9uYWxfdGh1bmsuaXNfbm9uZSB0Lndha2V1cCk7ICopXG4gICAgbWF0Y2ggRmFyYWRheS5vcGVyYXRpb24gdC5lbmNvZGVyIHdpdGhcbiAgICB8IGBDbG9zZSAgICAgICAgIC0+IGBDbG9zZSAoZHJhaW5lZF9ieXRlcyB0KVxuICAgIHwgYFlpZWxkICAgICAgICAgLT4gYFlpZWxkXG4gICAgfCBgV3JpdGV2IGlvdmVjcyAtPiBgV3JpdGUgaW92ZWNzXG5lbmRcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxOCBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxubW9kdWxlIFJlYWRlciA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgZmFyYWRheSAgICAgICAgICAgICAgICAgICAgICAgIDogRmFyYWRheS50XG4gICAgOyBtdXRhYmxlIHJlYWRfc2NoZWR1bGVkICAgICAgICAgOiBib29sXG4gICAgOyBtdXRhYmxlIG9uX2VvZiAgICAgICAgICAgICAgICAgOiB1bml0IC0+IHVuaXRcbiAgICA7IG11dGFibGUgZW9mX2hhc19iZWVuX2NhbGxlZCAgICA6IGJvb2xcbiAgICA7IG11dGFibGUgb25fcmVhZCAgICAgICAgICAgICAgICA6IEJpZ3N0cmluZ2FmLnQgLT4gb2ZmOmludCAtPiBsZW46aW50IC0+IHVuaXRcbiAgICA7IHdoZW5fcmVhZHlfdG9fcmVhZCAgICAgICAgICAgICA6IE9wdGlvbmFsX3RodW5rLnRcbiAgICB9XG5cbiAgbGV0IGRlZmF1bHRfb25fZW9mICAgICAgICAgPSBTeXMub3BhcXVlX2lkZW50aXR5IChmdW4gKCkgLT4gKCkpXG4gIGxldCBkZWZhdWx0X29uX3JlYWQgICAgICAgID0gU3lzLm9wYXF1ZV9pZGVudGl0eSAoZnVuIF8gfm9mZjpfIH5sZW46XyAtPiAoKSlcblxuICBsZXQgY3JlYXRlIGJ1ZmZlciB+d2hlbl9yZWFkeV90b19yZWFkID1cbiAgICB7IGZhcmFkYXkgICAgICAgICAgICAgICAgPSBGYXJhZGF5Lm9mX2JpZ3N0cmluZyBidWZmZXJcbiAgICA7IHJlYWRfc2NoZWR1bGVkICAgICAgICAgPSBmYWxzZVxuICAgIDsgZW9mX2hhc19iZWVuX2NhbGxlZCAgICA9IGZhbHNlXG4gICAgOyBvbl9lb2YgICAgICAgICAgICAgICAgID0gZGVmYXVsdF9vbl9lb2ZcbiAgICA7IG9uX3JlYWQgICAgICAgICAgICAgICAgPSBkZWZhdWx0X29uX3JlYWRcbiAgICA7IHdoZW5fcmVhZHlfdG9fcmVhZFxuICAgIH1cblxuICBsZXQgY3JlYXRlX2VtcHR5ICgpID1cbiAgICBsZXQgdCA9IGNyZWF0ZSBCaWdzdHJpbmdhZi5lbXB0eSB+d2hlbl9yZWFkeV90b19yZWFkOk9wdGlvbmFsX3RodW5rLm5vbmUgaW5cbiAgICBGYXJhZGF5LmNsb3NlIHQuZmFyYWRheTtcbiAgICB0XG5cbiAgbGV0IGlzX2Nsb3NlZCB0ID1cbiAgICBGYXJhZGF5LmlzX2Nsb3NlZCB0LmZhcmFkYXlcblxuICBsZXQgdW5zYWZlX2ZhcmFkYXkgdCA9XG4gICAgdC5mYXJhZGF5XG5cbiAgbGV0IHJlYWR5X3RvX3JlYWQgdCA9IE9wdGlvbmFsX3RodW5rLmNhbGxfaWZfc29tZSB0LndoZW5fcmVhZHlfdG9fcmVhZFxuXG4gIGxldCByZWMgZG9fZXhlY3V0ZV9yZWFkIHQgb25fZW9mIG9uX3JlYWQgPVxuICAgIG1hdGNoIEZhcmFkYXkub3BlcmF0aW9uIHQuZmFyYWRheSB3aXRoXG4gICAgfCBgWWllbGQgICAgICAgICAgIC0+ICgpXG4gICAgfCBgQ2xvc2UgICAgICAgICAgIC0+XG4gICAgICB0LnJlYWRfc2NoZWR1bGVkIDwtIGZhbHNlO1xuICAgICAgdC5vbl9lb2YgICAgICAgICA8LSBkZWZhdWx0X29uX2VvZjtcbiAgICAgIHQub25fcmVhZCAgICAgICAgPC0gZGVmYXVsdF9vbl9yZWFkO1xuICAgICAgaWYgbm90IHQuZW9mX2hhc19iZWVuX2NhbGxlZCB0aGVuIGJlZ2luXG4gICAgICAgIHQuZW9mX2hhc19iZWVuX2NhbGxlZCA8LSB0cnVlO1xuICAgICAgICBvbl9lb2YgKClcbiAgICAgIGVuZFxuICAgICgqIFtGYXJhZGF5Lm9wZXJhdGlvbl0gbmV2ZXIgcmV0dXJucyBhbiBlbXB0eSBsaXN0IG9mIGlvdmVjcyAqKVxuICAgIHwgYFdyaXRldiBbXSAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IGBXcml0ZXYgKGlvdmVjOjpfKSAtPlxuICAgICAgdC5yZWFkX3NjaGVkdWxlZCA8LSBmYWxzZTtcbiAgICAgIHQub25fZW9mICAgICAgICAgPC0gZGVmYXVsdF9vbl9lb2Y7XG4gICAgICB0Lm9uX3JlYWQgICAgICAgIDwtIGRlZmF1bHRfb25fcmVhZDtcbiAgICAgIGxldCB7IElPVmVjLmJ1ZmZlcjsgb2ZmOyBsZW4gfSA9IGlvdmVjIGluXG4gICAgICBGYXJhZGF5LnNoaWZ0IHQuZmFyYWRheSBsZW47XG4gICAgICBvbl9yZWFkIGJ1ZmZlciB+b2ZmIH5sZW47XG4gICAgICBleGVjdXRlX3JlYWQgdFxuICBhbmQgZXhlY3V0ZV9yZWFkIHQgPVxuICAgIGlmIHQucmVhZF9zY2hlZHVsZWQgdGhlbiBkb19leGVjdXRlX3JlYWQgdCB0Lm9uX2VvZiB0Lm9uX3JlYWRcblxubGV0IHNjaGVkdWxlX3JlYWQgdCB+b25fZW9mIH5vbl9yZWFkID1cbiAgaWYgdC5yZWFkX3NjaGVkdWxlZFxuICB0aGVuIGZhaWx3aXRoIFwiQm9keS5zY2hlZHVsZV9yZWFkOiByZWFkZXIgYWxyZWFkeSBzY2hlZHVsZWRcIjtcbiAgaWYgbm90IChpc19jbG9zZWQgdClcbiAgdGhlbiBiZWdpblxuICAgIHQucmVhZF9zY2hlZHVsZWQgPC0gdHJ1ZTtcbiAgICB0Lm9uX2VvZiAgICAgICAgIDwtIG9uX2VvZjtcbiAgICB0Lm9uX3JlYWQgICAgICAgIDwtIG9uX3JlYWQ7XG4gIGVuZDtcbiAgZG9fZXhlY3V0ZV9yZWFkIHQgb25fZW9mIG9uX3JlYWQ7XG4gIHJlYWR5X3RvX3JlYWQgdFxuXG4gIGxldCBjbG9zZSB0ID1cbiAgICBGYXJhZGF5LmNsb3NlIHQuZmFyYWRheTtcbiAgICBleGVjdXRlX3JlYWQgdDtcbiAgICByZWFkeV90b19yZWFkIHRcbiAgOztcblxuICBsZXQgaGFzX3BlbmRpbmdfb3V0cHV0IHQgPSBGYXJhZGF5Lmhhc19wZW5kaW5nX291dHB1dCB0LmZhcmFkYXlcblxuICBsZXQgaXNfcmVhZF9zY2hlZHVsZWQgdCA9IHQucmVhZF9zY2hlZHVsZWRcbmVuZFxuXG5tb2R1bGUgV3JpdGVyID0gc3RydWN0XG4gIHR5cGUgZW5jb2RpbmcgPVxuICAgIHwgSWRlbnRpdHlcbiAgICB8IENodW5rZWQgb2YgeyBtdXRhYmxlIHdyaXR0ZW5fZmluYWxfY2h1bmsgOiBib29sIH1cblxuICB0eXBlIHQgPVxuICAgIHsgZmFyYWRheSAgICAgICAgICAgICA6IEZhcmFkYXkudFxuICAgIDsgZW5jb2RpbmcgICAgICAgICAgICA6IGVuY29kaW5nXG4gICAgOyB3cml0ZXIgICAgICAgICAgICAgIDogU2VyaWFsaXplLldyaXRlci50XG4gICAgOyBidWZmZXJlZF9ieXRlcyAgICAgIDogaW50IHJlZlxuICAgIH1cblxuICBsZXQgb2ZfZmFyYWRheSBmYXJhZGF5IH5lbmNvZGluZyB+d3JpdGVyID1cbiAgICBsZXQgZW5jb2RpbmcgPVxuICAgICAgbWF0Y2ggZW5jb2Rpbmcgd2l0aFxuICAgICAgfCBgRml4ZWQgXyB8IGBDbG9zZV9kZWxpbWl0ZWQgLT4gSWRlbnRpdHlcbiAgICAgIHwgYENodW5rZWQgLT4gQ2h1bmtlZCB7IHdyaXR0ZW5fZmluYWxfY2h1bmsgPSBmYWxzZSB9XG4gICAgaW5cbiAgICB7IGZhcmFkYXlcbiAgICA7IGVuY29kaW5nXG4gICAgOyB3cml0ZXJcbiAgICA7IGJ1ZmZlcmVkX2J5dGVzID0gcmVmIDBcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSBidWZmZXIgfmVuY29kaW5nID1cbiAgICBvZl9mYXJhZGF5IChGYXJhZGF5Lm9mX2JpZ3N0cmluZyBidWZmZXIpIH5lbmNvZGluZ1xuXG4gIGxldCBjcmVhdGVfZW1wdHkgfndyaXRlciA9XG4gICAgbGV0IHQgPVxuICAgICAgY3JlYXRlXG4gICAgICAgIEJpZ3N0cmluZ2FmLmVtcHR5XG4gICAgICAgIH5lbmNvZGluZzooYEZpeGVkIDApXG4gICAgICAgIH53cml0ZXJcbiAgICBpblxuICAgIEZhcmFkYXkuY2xvc2UgdC5mYXJhZGF5O1xuICAgIHRcblxuICBsZXQgd3JpdGVfY2hhciB0IGMgPVxuICAgIEZhcmFkYXkud3JpdGVfY2hhciB0LmZhcmFkYXkgY1xuXG4gIGxldCB3cml0ZV9zdHJpbmcgdCA/b2ZmID9sZW4gcyA9XG4gICAgRmFyYWRheS53cml0ZV9zdHJpbmcgP29mZiA/bGVuIHQuZmFyYWRheSBzXG5cbiAgbGV0IHdyaXRlX2JpZ3N0cmluZyB0ID9vZmYgP2xlbiBiID1cbiAgICBGYXJhZGF5LndyaXRlX2JpZ3N0cmluZyA/b2ZmID9sZW4gdC5mYXJhZGF5IGJcblxuICBsZXQgc2NoZWR1bGVfYmlnc3RyaW5nIHQgP29mZiA/bGVuIChiOkJpZ3N0cmluZ2FmLnQpID1cbiAgICBGYXJhZGF5LnNjaGVkdWxlX2JpZ3N0cmluZyA/b2ZmID9sZW4gdC5mYXJhZGF5IGJcblxuICBsZXQgcmVhZHlfdG9fd3JpdGUgdCA9IFNlcmlhbGl6ZS5Xcml0ZXIud2FrZXVwIHQud3JpdGVyXG5cbiAgbGV0IGZsdXNoIHQga29udGludWUgPVxuICAgIEZhcmFkYXkuZmx1c2ggdC5mYXJhZGF5IChmdW4gKCkgLT5cbiAgICAgIFNlcmlhbGl6ZS5Xcml0ZXIuZmx1c2ggdC53cml0ZXIga29udGludWUpO1xuICAgIHJlYWR5X3RvX3dyaXRlIHRcblxuICBsZXQgaXNfY2xvc2VkIHQgPVxuICAgIEZhcmFkYXkuaXNfY2xvc2VkIHQuZmFyYWRheVxuXG4gIGxldCBjbG9zZSB0ID1cbiAgICBTZXJpYWxpemUuV3JpdGVyLnVueWllbGQgdC53cml0ZXI7XG4gICAgRmFyYWRheS5jbG9zZSB0LmZhcmFkYXk7XG4gICAgcmVhZHlfdG9fd3JpdGUgdDtcbiAgOztcblxuICBsZXQgZm9yY2VfY2xvc2UgdCA9XG4gICAgYmVnaW4gbWF0Y2ggdC5lbmNvZGluZyB3aXRoXG4gICAgfCBDaHVua2VkIHQgLT4gdC53cml0dGVuX2ZpbmFsX2NodW5rIDwtIHRydWVcbiAgICB8IElkZW50aXR5IC0+ICgpXG4gICAgZW5kO1xuICAgIGNsb3NlIHRcblxuICBsZXQgaGFzX3BlbmRpbmdfb3V0cHV0IHQgPVxuICAgICgqIEZvcmNlIGFub3RoZXIgd3JpdGUgcG9sbCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgZmluYWwgY2h1bmsgaXMgZW1pdHRlZCBmb3JcbiAgICAgICBjaHVuay1lbmNvZGVkIGJvZGllcy4gKilcbiAgICBsZXQgZmFyYWRheV9oYXNfb3V0cHV0ID0gRmFyYWRheS5oYXNfcGVuZGluZ19vdXRwdXQgdC5mYXJhZGF5IGluXG4gICAgbGV0IGFkZGl0aW9uYWxfZW5jb2Rpbmdfb3V0cHV0ID1cbiAgICAgIG1hdGNoIHQuZW5jb2Rpbmcgd2l0aFxuICAgICAgfCBJZGVudGl0eSAtPiBmYWxzZVxuICAgICAgfCBDaHVua2VkIHsgd3JpdHRlbl9maW5hbF9jaHVuayB9IC0+XG4gICAgICAgIEZhcmFkYXkuaXNfY2xvc2VkIHQuZmFyYWRheSAmJiBub3Qgd3JpdHRlbl9maW5hbF9jaHVua1xuICAgIGluXG4gICAgZmFyYWRheV9oYXNfb3V0cHV0IHx8IGFkZGl0aW9uYWxfZW5jb2Rpbmdfb3V0cHV0XG5cbiAgbGV0IHJlcXVpcmVzX291dHB1dCB0ID1cbiAgICBub3QgKGlzX2Nsb3NlZCB0KSB8fCBoYXNfcGVuZGluZ19vdXRwdXQgdFxuXG4gIGxldCB0cmFuc2Zlcl90b193cml0ZXIgdCA9XG4gICAgbGV0IGZhcmFkYXkgPSB0LmZhcmFkYXkgaW5cbiAgICBiZWdpbiBtYXRjaCBGYXJhZGF5Lm9wZXJhdGlvbiBmYXJhZGF5IHdpdGhcbiAgICB8IGBZaWVsZCAtPiAoKVxuICAgIHwgYENsb3NlIC0+XG4gICAgICAobWF0Y2ggdC5lbmNvZGluZyB3aXRoXG4gICAgICAgfCBJZGVudGl0eSAtPiAoKVxuICAgICAgIHwgQ2h1bmtlZCAoeyB3cml0dGVuX2ZpbmFsX2NodW5rIH0gYXMgY2h1bmtlZCkgLT5cbiAgICAgICAgIGlmIG5vdCB3cml0dGVuX2ZpbmFsX2NodW5rIHRoZW4gYmVnaW5cbiAgICAgICAgICAgY2h1bmtlZC53cml0dGVuX2ZpbmFsX2NodW5rIDwtIHRydWU7XG4gICAgICAgICAgIFNlcmlhbGl6ZS5Xcml0ZXIuc2NoZWR1bGVfY2h1bmsgdC53cml0ZXIgW107XG4gICAgICAgICBlbmQpO1xuICAgIHwgYFdyaXRldiBpb3ZlY3MgLT5cbiAgICAgIGxldCBidWZmZXJlZCA9IHQuYnVmZmVyZWRfYnl0ZXMgaW5cbiAgICAgIGJlZ2luIG1hdGNoIElPVmVjLnNoaWZ0diBpb3ZlY3MgIWJ1ZmZlcmVkIHdpdGhcbiAgICAgIHwgW10gICAgIC0+ICgpXG4gICAgICB8IGlvdmVjcyAtPlxuICAgICAgICBsZXQgbGVuZ3RodiAgPSBJT1ZlYy5sZW5ndGh2IGlvdmVjcyBpblxuICAgICAgICBidWZmZXJlZCA6PSAhYnVmZmVyZWQgKyBsZW5ndGh2O1xuICAgICAgICBiZWdpbiBtYXRjaCB0LmVuY29kaW5nIHdpdGhcbiAgICAgICAgfCBJZGVudGl0eSAgLT4gU2VyaWFsaXplLldyaXRlci5zY2hlZHVsZV9maXhlZCB0LndyaXRlciBpb3ZlY3NcbiAgICAgICAgfCBDaHVua2VkIF8gLT4gU2VyaWFsaXplLldyaXRlci5zY2hlZHVsZV9jaHVuayB0LndyaXRlciBpb3ZlY3NcbiAgICAgICAgZW5kO1xuICAgICAgICBTZXJpYWxpemUuV3JpdGVyLmZsdXNoIHQud3JpdGVyIChmdW4gKCkgLT5cbiAgICAgICAgICBGYXJhZGF5LnNoaWZ0IGZhcmFkYXkgbGVuZ3RodjtcbiAgICAgICAgICBidWZmZXJlZCA6PSAhYnVmZmVyZWQgLSBsZW5ndGh2KVxuICAgICAgZW5kXG4gICAgZW5kXG5lbmRcbiIsIm1vZHVsZSBXcml0ZXIgPSBTZXJpYWxpemUuV3JpdGVyXG5cbnR5cGUgZXJyb3IgPVxuICBbIGBNYWxmb3JtZWRfcmVzcG9uc2Ugb2Ygc3RyaW5nXG4gIHwgYEludmFsaWRfcmVzcG9uc2VfYm9keV9sZW5ndGggb2YgUmVzcG9uc2UudFxuICB8IGBFeG4gb2YgZXhuIF1cblxubW9kdWxlIFJlcXVlc3Rfc3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IFVuaW5pdGlhbGl6ZWRcbiAgICB8IEF3YWl0aW5nX3Jlc3BvbnNlXG4gICAgfCBSZWNlaXZlZF9yZXNwb25zZSBvZiBSZXNwb25zZS50ICogQm9keS5SZWFkZXIudFxuICAgIHwgVXBncmFkZWQgb2YgUmVzcG9uc2UudFxuICAgIHwgQ2xvc2VkXG5lbmRcblxudHlwZSB0ID1cbiAgeyByZXF1ZXN0ICAgICAgICAgIDogUmVxdWVzdC50XG4gIDsgcmVxdWVzdF9ib2R5ICAgICA6IEJvZHkuV3JpdGVyLnRcbiAgOyByZXNwb25zZV9oYW5kbGVyIDogKFJlc3BvbnNlLnQgLT4gQm9keS5SZWFkZXIudCAtPiB1bml0KVxuICA7IGVycm9yX2hhbmRsZXIgICAgOiAoZXJyb3IgLT4gdW5pdClcbiAgOyBtdXRhYmxlIGVycm9yX2NvZGUgOiBbIGBPayB8IGVycm9yIF1cbiAgOyB3cml0ZXIgOiBXcml0ZXIudFxuICA7IG11dGFibGUgc3RhdGUgOiBSZXF1ZXN0X3N0YXRlLnRcbiAgOyBtdXRhYmxlIHBlcnNpc3RlbnQgOiBib29sXG4gIH1cblxubGV0IGNyZWF0ZSBlcnJvcl9oYW5kbGVyIHJlcXVlc3QgcmVxdWVzdF9ib2R5IHdyaXRlciByZXNwb25zZV9oYW5kbGVyID1cbiAgbGV0IHJlYyBoYW5kbGVyIHJlc3BvbnNlIGJvZHkgPVxuICAgIGxldCB0ID0gTGF6eS5mb3JjZSB0IGluXG4gICAgaWYgdC5wZXJzaXN0ZW50IHRoZW5cbiAgICAgIHQucGVyc2lzdGVudCA8LSBSZXNwb25zZS5wZXJzaXN0ZW50X2Nvbm5lY3Rpb24gcmVzcG9uc2U7XG4gICAgbGV0IG5leHRfc3RhdGUgOiBSZXF1ZXN0X3N0YXRlLnQgPSBtYXRjaCByZXNwb25zZS5zdGF0dXMgd2l0aFxuICAgICAgfCBgU3dpdGNoaW5nX3Byb3RvY29scyAtPlxuICAgICAgICBVcGdyYWRlZCByZXNwb25zZVxuICAgICAgfCBfIC0+XG4gICAgICAgIFJlY2VpdmVkX3Jlc3BvbnNlIChyZXNwb25zZSwgYm9keSlcbiAgICBpblxuICAgIHQuc3RhdGUgPC0gbmV4dF9zdGF0ZTtcbiAgICByZXNwb25zZV9oYW5kbGVyIHJlc3BvbnNlIGJvZHlcbiAgYW5kIHQgPVxuICAgIGxhenlcbiAgICB7IHJlcXVlc3RcbiAgICA7IHJlcXVlc3RfYm9keVxuICAgIDsgcmVzcG9uc2VfaGFuZGxlciA9IGhhbmRsZXJcbiAgICA7IGVycm9yX2hhbmRsZXJcbiAgICA7IGVycm9yX2NvZGUgPSBgT2tcbiAgICA7IHdyaXRlclxuICAgIDsgc3RhdGUgPSBVbmluaXRpYWxpemVkXG4gICAgOyBwZXJzaXN0ZW50ID0gUmVxdWVzdC5wZXJzaXN0ZW50X2Nvbm5lY3Rpb24gcmVxdWVzdFxuICAgIH1cbiAgaW5cbiAgTGF6eS5mb3JjZSB0XG5cbmxldCByZXF1ZXN0IHsgcmVxdWVzdDsgXyB9ID0gcmVxdWVzdFxuXG5sZXQgd3JpdGVfcmVxdWVzdCB0ID1cbiAgV3JpdGVyLndyaXRlX3JlcXVlc3QgdC53cml0ZXIgdC5yZXF1ZXN0O1xuICB0LnN0YXRlIDwtIEF3YWl0aW5nX3Jlc3BvbnNlXG5cbmxldCByZXBvcnRfZXJyb3IgdCBlcnJvciA9XG4gIHQucGVyc2lzdGVudCA8LSBmYWxzZTtcbiAgQm9keS5Xcml0ZXIuZm9yY2VfY2xvc2UgdC5yZXF1ZXN0X2JvZHk7XG4gIG1hdGNoIHQuc3RhdGUsIHQuZXJyb3JfY29kZSB3aXRoXG4gIHwgKFVuaW5pdGlhbGl6ZWQgfCBBd2FpdGluZ19yZXNwb25zZSB8IFVwZ3JhZGVkIF8pLCBgT2sgLT5cbiAgICB0LnN0YXRlIDwtIENsb3NlZDtcbiAgICB0LmVycm9yX2NvZGUgPC0gKGVycm9yIDo+IFtgT2sgfCBlcnJvcl0pO1xuICAgIHQuZXJyb3JfaGFuZGxlciBlcnJvclxuICB8IFVuaW5pdGlhbGl6ZWQsIGBFeG4gXyAtPlxuICAgICgqIFRPRE8oYW5tb250ZWlybyk6IE5vdCBlbnRpcmVseSBzdXJlIHRoaXMgaXMgcG9zc2libGUgaW4gdGhlIGNsaWVudC4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBSZWNlaXZlZF9yZXNwb25zZSAoXywgcmVzcG9uc2VfYm9keSksIGBPayAtPlxuICAgICBCb2R5LlJlYWRlci5jbG9zZSByZXNwb25zZV9ib2R5O1xuICAgICB0LmVycm9yX2NvZGUgPC0gKGVycm9yIDo+IFtgT2sgfCBlcnJvcl0pO1xuICAgICB0LmVycm9yX2hhbmRsZXIgZXJyb3JcbiAgfCAoVW5pbml0aWFsaXplZCB8IEF3YWl0aW5nX3Jlc3BvbnNlIHwgUmVjZWl2ZWRfcmVzcG9uc2UgXyB8IENsb3NlZCB8IFVwZ3JhZGVkIF8pLCBfIC0+XG4gICAgKCogWFhYKHNlbGlvcG91KTogT25jZSBhZGRpdGlvbmFsIGxvZ2dpbmcgc3VwcG9ydCBpcyBhZGRlZCwgbG9nIHRoZSBlcnJvclxuICAgICAqIGluIGNhc2UgaXQgaXMgbm90IHNwdXJpb3VzLiAqKVxuICAgICgpXG5cbmxldCBwZXJzaXN0ZW50X2Nvbm5lY3Rpb24gdCA9XG4gIHQucGVyc2lzdGVudFxuXG5sZXQgY2xvc2VfcmVxdWVzdF9ib2R5IHQgPVxuICBCb2R5LldyaXRlci5jbG9zZSB0LnJlcXVlc3RfYm9keVxuXG5sZXQgY2xvc2VfcmVzcG9uc2VfYm9keSB0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgVW5pbml0aWFsaXplZFxuICB8IEF3YWl0aW5nX3Jlc3BvbnNlXG4gIHwgQ2xvc2VkIC0+ICgpXG4gIHwgUmVjZWl2ZWRfcmVzcG9uc2UgKF8sIHJlc3BvbnNlX2JvZHkpIC0+XG4gICAgQm9keS5SZWFkZXIuY2xvc2UgcmVzcG9uc2VfYm9keVxuICB8IFVwZ3JhZGVkIF8gLT4gdC5zdGF0ZSA8LSBDbG9zZWRcblxubGV0IGlucHV0X3N0YXRlIHQgOiBJbnB1dF9zdGF0ZS50ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgVW5pbml0aWFsaXplZFxuICB8IEF3YWl0aW5nX3Jlc3BvbnNlIC0+IFJlYWR5XG4gIHwgUmVjZWl2ZWRfcmVzcG9uc2UgKF8sIHJlc3BvbnNlX2JvZHkpIC0+XG4gICAgaWYgQm9keS5SZWFkZXIuaXNfY2xvc2VkIHJlc3BvbnNlX2JvZHlcbiAgICB0aGVuIENvbXBsZXRlXG4gICAgZWxzZSBpZiBCb2R5LlJlYWRlci5pc19yZWFkX3NjaGVkdWxlZCByZXNwb25zZV9ib2R5XG4gICAgdGhlbiBSZWFkeVxuICAgIGVsc2UgV2FpdFxuICAgICgqIFVwZ3JhZGVkIGlzIFwiQ29tcGxldGVcIiBiZWNhdXNlIHRoZSBkZXNjcmlwdG9yIGRvZXNuJ3Qgd2lzaCB0byByZWNlaXZlXG4gICAgICogYW55IG1vcmUgaW5wdXQuICopXG4gIHwgVXBncmFkZWQgX1xuICB8IENsb3NlZCAtPiBDb21wbGV0ZVxuXG5sZXQgb3V0cHV0X3N0YXRlIHsgcmVxdWVzdF9ib2R5OyBzdGF0ZTsgXyB9IDogT3V0cHV0X3N0YXRlLnQgPVxuICBtYXRjaCBzdGF0ZSB3aXRoXG4gIHwgVXBncmFkZWQgXyAtPlxuICAgICgqIFhYWChhbm1vbnRlaXJvKTogQ29ubmVjdGlvbnMgdGhhdCBoYXZlIGJlZW4gdXBncmFkZWQgXCJyZXF1aXJlIG91dHB1dFwiXG4gICAgICogZm9yZXZlciwgYnV0IG91dHNpZGUgdGhlIEhUVFAgbGF5ZXIsIG1lYW5pbmcgdGhleSdyZSBwZXJtYW5lbnRseVxuICAgICAqIFwieWllbGRpbmdcIi4gRm9yIG5vdyB0aGV5IG5lZWQgdG8gYmUgZXhwbGljaXRseSBzaHV0ZG93biBpbiBvcmRlciB0b1xuICAgICAqIHRyYW5zaXRpb24gdGhlIHJlc3BvbnNlIGRlc2NyaXB0b3IgdG8gdGhlIGBDbG9zZWRgIHN0YXRlLiAqKVxuICAgIFdhaXRpbmdcbiAgfCBzdGF0ZSAtPlxuICAgIGlmIHN0YXRlID0gVW5pbml0aWFsaXplZCB8fCBCb2R5LldyaXRlci5yZXF1aXJlc19vdXRwdXQgcmVxdWVzdF9ib2R5XG4gICAgdGhlbiBSZWFkeVxuICAgIGVsc2UgQ29tcGxldGVcblxubGV0IGZsdXNoX3JlcXVlc3RfYm9keSB7IHJlcXVlc3RfYm9keTsgXyB9ID1cbiAgaWYgQm9keS5Xcml0ZXIuaGFzX3BlbmRpbmdfb3V0cHV0IHJlcXVlc3RfYm9keSB0aGVuXG4gICAgQm9keS5Xcml0ZXIudHJhbnNmZXJfdG9fd3JpdGVyIHJlcXVlc3RfYm9keVxuXG5sZXQgZmx1c2hfcmVzcG9uc2VfYm9keSB0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgVW5pbml0aWFsaXplZCB8IEF3YWl0aW5nX3Jlc3BvbnNlIHwgQ2xvc2VkIHwgVXBncmFkZWQgXyAtPiAoKVxuICB8IFJlY2VpdmVkX3Jlc3BvbnNlKF8sIHJlc3BvbnNlX2JvZHkpIC0+XG4gICAgaWYgQm9keS5SZWFkZXIuaGFzX3BlbmRpbmdfb3V0cHV0IHJlc3BvbnNlX2JvZHlcbiAgICB0aGVuIHRyeSBCb2R5LlJlYWRlci5leGVjdXRlX3JlYWQgcmVzcG9uc2VfYm9keVxuICAgIHdpdGggZXhuIC0+IHJlcG9ydF9lcnJvciB0IChgRXhuIGV4bilcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNiBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxuXG5pbmNsdWRlIEFuZ3N0cm9tXG5cbm1vZHVsZSBQID0gc3RydWN0XG4gIGxldCBpc19zcGFjZSA9XG4gICAgZnVuY3Rpb24gfCAnICcgfCAnXFx0JyAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gIGxldCBpc19jciA9XG4gICAgZnVuY3Rpb24gfCAnXFxyJyAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gIGxldCBpc19zcGFjZV9vcl9jb2xvbiA9XG4gICAgZnVuY3Rpb24gfCAnICcgfCAnXFx0JyB8ICc6JyAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gIGxldCBpc19oZXggPVxuICAgIGZ1bmN0aW9uIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IGlzX2RpZ2l0ID1cbiAgICBmdW5jdGlvbiAnMCcgLi4gJzknIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IGlzX3NlcGFyYXRvciA9XG4gICAgZnVuY3Rpb25cbiAgICAgIHwgJyknIHwgJygnIHwgJzwnIHwgJz4nIHwgJ0AnIHwgJywnIHwgJzsnIHwgJzonIHwgJ1xcXFwnIHwgJ1wiJ1xuICAgICAgfCAnLycgfCAnWycgfCAnXScgfCAnPycgfCAnPScgfCAneycgfCAnfScgfCAnICcgfCAnXFx0JyAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcblxuICBsZXQgaXNfdG9rZW4gPVxuICAgICgqIFRoZSBjb21tZW50ZWQtb3V0ICcgJyBhbmQgJ1xcdCcgYXJlIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBvZiB0aGUgcmFuZ2UgYXRcbiAgICAgKiB0aGUgdG9wIG9mIHRoZSBtYXRjaC4gKilcbiAgICBmdW5jdGlvblxuICAgICAgfCAnXFwwMDAnIC4uICdcXDAzMScgfCAnXFwxMjcnXG4gICAgICB8ICcpJyB8ICcoJyB8ICc8JyB8ICc+JyB8ICdAJyB8ICcsJyB8ICc7JyB8ICc6JyB8ICdcXFxcJyB8ICdcIidcbiAgICAgIHwgJy8nIHwgJ1snIHwgJ10nIHwgJz8nIHwgJz0nIHwgJ3snIHwgJ30nICgqIHwgJyAnIHwgJ1xcdCcgKikgLT4gZmFsc2VcbiAgICAgIHwgXyAtPiB0cnVlXG5lbmRcblxubGV0IHVuaXQgPSByZXR1cm4gKClcbmxldCB0b2tlbiA9IHRha2Vfd2hpbGUxIFAuaXNfdG9rZW5cbmxldCBzcGFjZXMgPSBza2lwX3doaWxlIFAuaXNfc3BhY2VcblxubGV0IGRpZ2l0ID1cbiAgc2F0aXNmeSBQLmlzX2RpZ2l0XG4gID4+fCBmdW5jdGlvblxuICAgIHwgJzAnIC0+IDAgfCAnMScgLT4gMSB8ICcyJyAtPiAyIHwgJzMnIC0+IDMgfCAnNCcgLT4gNCB8ICc1JyAtPiA1XG4gICAgfCAnNicgLT4gNiB8ICc3JyAtPiA3IHwgJzgnIC0+IDggfCAnOScgLT4gOSB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBlb2wgPSBzdHJpbmcgXCJcXHJcXG5cIiA8Pz4gXCJlb2xcIlxubGV0IGhleCBzdHIgPVxuICB0cnkgcmV0dXJuIChJbnQ2NC5vZl9zdHJpbmcgKFwiMHhcIiBeIHN0cikpIHdpdGggXyAtPiBmYWlsIFwiaGV4XCJcbmxldCBza2lwX2xpbmUgPSB0YWtlX3RpbGwgUC5pc19jciAqPiBlb2xcblxubGV0IHZlcnNpb24gPVxuICBzdHJpbmcgXCJIVFRQL1wiICo+XG4gIGxpZnQyIChmdW4gbWFqb3IgbWlub3IgLT4geyBWZXJzaW9uLm1ham9yOyBtaW5vciB9KVxuICAgIChkaWdpdCA8KiBjaGFyICcuJylcbiAgICBkaWdpdFxuXG5sZXQgaGVhZGVyID1cbiAgKCogRnJvbSBSRkM3MjMwwqczLjIuNDpcblxuICAgICAgIFwiTm8gd2hpdGVzcGFjZSBpcyBhbGxvd2VkIGJldHdlZW4gdGhlIGhlYWRlciBmaWVsZC1uYW1lIGFuZCBjb2xvbi4gIEluXG4gICAgICAgdGhlIHBhc3QsIGRpZmZlcmVuY2VzIGluIHRoZSBoYW5kbGluZyBvZiBzdWNoIHdoaXRlc3BhY2UgaGF2ZSBsZWQgdG9cbiAgICAgICBzZWN1cml0eSB2dWxuZXJhYmlsaXRpZXMgaW4gcmVxdWVzdCByb3V0aW5nIGFuZCByZXNwb25zZSBoYW5kbGluZy4gIEFcbiAgICAgICBzZXJ2ZXIgTVVTVCByZWplY3QgYW55IHJlY2VpdmVkIHJlcXVlc3QgbWVzc2FnZSB0aGF0IGNvbnRhaW5zIHdoaXRlc3BhY2VcbiAgICAgICBiZXR3ZWVuIGEgaGVhZGVyIGZpZWxkLW5hbWUgYW5kIGNvbG9uIHdpdGggYSByZXNwb25zZSBjb2RlIG9mIDQwMCAoQmFkXG4gICAgICAgUmVxdWVzdCkuICBBIHByb3h5IE1VU1QgcmVtb3ZlIGFueSBzdWNoIHdoaXRlc3BhY2UgZnJvbSBhIHJlc3BvbnNlXG4gICAgICAgbWVzc2FnZSBiZWZvcmUgZm9yd2FyZGluZyB0aGUgbWVzc2FnZSBkb3duc3RyZWFtLlwiXG5cbiAgICBUaGlzIGNhbiBiZSBkZXRlY3RlZCBieSBjaGVja2luZyB0aGUgbWVzc2FnZSBhbmQgbWFya3MgaW4gYSBwYXJzZSBmYWlsdXJlLFxuICAgIHdoaWNoIHNob3VsZCBsb29rIGxpa2UgdGhpcyB3aGVuIHNlcmlhbGl6ZWQgXCIuLi4gPiBoZWFkZXIgPiA6XCIuICopXG4gIGxpZnQyIChmdW4ga2V5IHZhbHVlIC0+IChrZXksIHZhbHVlKSlcbiAgICAodGFrZV90aWxsIFAuaXNfc3BhY2Vfb3JfY29sb24gPCogY2hhciAnOicgPCogc3BhY2VzKVxuICAgICh0YWtlX3RpbGwgUC5pc19jciA8KiBlb2wgPj58IFN0cmluZy50cmltKVxuICA8KiBjb21taXRcbiAgPD8+IFwiaGVhZGVyXCJcblxubGV0IGhlYWRlcnMgPVxuICBsZXQgY29ucyB4IHhzID0geCA6OiB4cyBpblxuICBmaXggKGZ1biBoZWFkZXJzIC0+XG4gICAgbGV0IF9lbXAgPSByZXR1cm4gW10gaW5cbiAgICBsZXQgX3JlYyA9IGxpZnQyIGNvbnMgaGVhZGVyIGhlYWRlcnMgaW5cbiAgICBwZWVrX2NoYXJfZmFpbFxuICAgID4+PSBmdW5jdGlvblxuICAgICAgfCAnXFxyJyAtPiBfZW1wXG4gICAgICB8IF8gICAgLT4gX3JlYylcbiAgPj58IEhlYWRlcnMub2ZfbGlzdFxuXG5sZXQgcmVxdWVzdCA9XG4gIGxldCBtZXRoID0gdGFrZV90aWxsIFAuaXNfc3BhY2UgPj58IE1ldGhvZC5vZl9zdHJpbmcgaW5cbiAgbGlmdDQgKGZ1biBtZXRoIHRhcmdldCB2ZXJzaW9uIGhlYWRlcnMgLT5cbiAgICBSZXF1ZXN0LmNyZWF0ZSB+dmVyc2lvbiB+aGVhZGVycyBtZXRoIHRhcmdldClcbiAgICAobWV0aCAgICAgICAgICAgICAgICAgPCogY2hhciAnICcpXG4gICAgKHRha2VfdGlsbCBQLmlzX3NwYWNlIDwqIGNoYXIgJyAnKVxuICAgICh2ZXJzaW9uICAgICAgICAgICAgICA8KiBlb2wgPCogY29tbWl0KVxuICAgIChoZWFkZXJzICAgICAgICAgICAgICA8KiBlb2wpXG5cbmxldCByZXNwb25zZSA9XG4gIGxldCBzdGF0dXMgPVxuICAgIHRha2Vfd2hpbGUgUC5pc19kaWdpdFxuICAgID4+PSBmdW4gc3RyIC0+XG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHN0ciA9IDBcbiAgICAgIHRoZW4gZmFpbCBcInN0YXR1cy1jb2RlIGVtcHR5XCJcbiAgICAgIGVsc2UgKFxuICAgICAgICBpZiBTdHJpbmcubGVuZ3RoIHN0ciA+IDNcbiAgICAgICAgdGhlbiBmYWlsIChQcmludGYuc3ByaW50ZiBcInN0YXR1cy1jb2RlIHRvbyBsb25nOiAlU1wiIHN0cilcbiAgICAgICAgZWxzZSByZXR1cm4gKFN0YXR1cy5vZl9zdHJpbmcgc3RyKSlcbiAgaW5cbiAgbGlmdDQgKGZ1biB2ZXJzaW9uIHN0YXR1cyByZWFzb24gaGVhZGVycyAtPlxuICAgIFJlc3BvbnNlLmNyZWF0ZSB+cmVhc29uIH52ZXJzaW9uIH5oZWFkZXJzIHN0YXR1cylcbiAgICAodmVyc2lvbiAgICAgICAgICAgICAgPCogY2hhciAnICcpXG4gICAgKHN0YXR1cyAgICAgICAgICAgICAgIDwqIGNoYXIgJyAnKVxuICAgICh0YWtlX3RpbGwgUC5pc19jciAgICA8KiBlb2wgPCogY29tbWl0KVxuICAgIChoZWFkZXJzICAgICAgICAgICAgICA8KiBlb2wpXG5cbmxldCBmaW5pc2ggYm9keSA9XG4gIEJvZHkuUmVhZGVyLmNsb3NlIGJvZHk7XG4gIGNvbW1pdFxuXG5sZXQgc2NoZWR1bGVfc2l6ZSBib2R5IG4gPVxuICBsZXQgZmFyYWRheSA9IEJvZHkuUmVhZGVyLnVuc2FmZV9mYXJhZGF5IGJvZHkgaW5cbiAgKCogWFhYKHNlbGlvcG91KTogcGVyZm9ybWFuY2UgcmVncmVzc2lvbiBkdWUgdG8gc3dpdGNoaW5nIHRvIGEgc2luZ2xlIG91dHB1dFxuICAgKiBmb3JtYXQgaW4gRmFyYWR5LiBPbmNlIGEgc3BlY2lhbGl6ZWQgb3BlcmF0aW9uIGlzIGV4cG9zZWQgdG8gYXZvaWQgdGhlXG4gICAqIGludGVtZWRpYXRlIGNvcHksIHRoaXMgc2hvdWxkIGJlIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHBlcmZvcm1hbmNlLiAqKVxuICBiZWdpbiBpZiBGYXJhZGF5LmlzX2Nsb3NlZCBmYXJhZGF5XG4gIHRoZW4gYWR2YW5jZSBuXG4gIGVsc2UgdGFrZV9iaWdzdHJpbmcgbiA+PnwgZnVuIHMgLT4gRmFyYWRheS5zY2hlZHVsZV9iaWdzdHJpbmcgZmFyYWRheSBzXG4gIGVuZCAqPiBjb21taXRcblxubGV0IGJvZHkgfmVuY29kaW5nIGJvZHkgPVxuICBsZXQgcmVjIGZpeGVkIG4gfnVuZXhwZWN0ZWQgPVxuICAgIGlmIG4gPSAwTFxuICAgIHRoZW4gdW5pdFxuICAgIGVsc2VcbiAgICAgIGF0X2VuZF9vZl9pbnB1dFxuICAgICAgPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPiBjb21taXQgKj4gZmFpbCB1bmV4cGVjdGVkXG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICBhdmFpbGFibGUgPj49IGZ1biBtIC0+XG4gICAgICAgICAgbGV0IG0nID0gSW50NjQuKG1pbiAob2ZfaW50IG0pIG4pIGluXG4gICAgICAgICAgbGV0IG4nID0gSW50NjQuc3ViIG4gbScgaW5cbiAgICAgICAgICBzY2hlZHVsZV9zaXplIGJvZHkgKEludDY0LnRvX2ludCBtJykgPj49IGZ1biAoKSAtPiBmaXhlZCBuJyB+dW5leHBlY3RlZFxuICBpblxuICBtYXRjaCBlbmNvZGluZyB3aXRoXG4gIHwgYEZpeGVkIG4gLT5cbiAgICBmaXhlZCBuIH51bmV4cGVjdGVkOlwiZXhwZWN0ZWQgbW9yZSBmcm9tIGZpeGVkIGJvZHlcIlxuICAgID4+PSBmdW4gKCkgLT4gZmluaXNoIGJvZHlcbiAgfCBgQ2h1bmtlZCAtPlxuICAgICgqIFhYWChzZWxpb3BvdSk6IFRoZSBbZW9sXSBpbiB0aGlzIHBhcnNlciBzaG91bGQgcmVhbGx5IHBhcnNlIGEgY29sbGVjdGlvblxuICAgICAqIG9mIFwiY2h1bmsgZXh0ZW5zaW9uc1wiLCBhcyBkZWZpbmVkIGluIFJGQzcyMzDCpzQuMS4gVGhlc2UgZG8gbm90IHNob3cgdXBcbiAgICAgKiBpbiB0aGUgd2lsZCB2ZXJ5IGZyZXF1ZW50bHksIGFuZCB0aGUgaHR0cGFmIEFQSSBoYXMgbm8gd2F5IG9mIGV4cG9zaW5nXG4gICAgICogdGhlbSB0byB0aGUgc3Vlciwgc28gZm9yIG5vdyB0aGUgcGFyc2VyIGRvZXMgbm90IGF0dGVtcHQgdG8gcmVjb2duaXplXG4gICAgICogdGhlbS4gVGhpcyBtZWFucyB0aGF0IGFueSBjaHVua2VkIG1lc3NhZ2VzIHRoYXQgY29udGFpbiBjaHVuayBleHRlbnNpb25zXG4gICAgICogd2lsbCBmYWlsIHRvIHBhcnNlLiAqKVxuICAgIGZpeCAoZnVuIHAgLT5cbiAgICAgIGxldCBfaGV4ID1cbiAgICAgICAgKHRha2Vfd2hpbGUxIFAuaXNfaGV4ID4+PSBmdW4gc2l6ZSAtPiBoZXggc2l6ZSlcbiAgICAgICAgKCogc3dhbGxvd3MgY2h1bmstZXh0LCBpZiBwcmVzZW50LCBhbmQgQ1JMRiAqKVxuICAgICAgICA8KiAoZW9sICo+IGNvbW1pdClcbiAgICAgIGluXG4gICAgICBfaGV4ID4+PSBmdW4gc2l6ZSAtPlxuICAgICAgaWYgc2l6ZSA9IDBMXG4gICAgICB0aGVuIGVvbCA+Pj0gZnVuIF9lb2wgLT4gZmluaXNoIGJvZHlcbiAgICAgIGVsc2UgZml4ZWQgc2l6ZSB+dW5leHBlY3RlZDpcImV4cGVjdGVkIG1vcmUgZnJvbSBib2R5IGNodW5rXCIgKj4gZW9sICo+IHApXG4gIHwgYENsb3NlX2RlbGltaXRlZCAtPlxuICAgIGZpeCAoZnVuIHAgLT5cbiAgICAgIGxldCBfcmVjID0gKGF2YWlsYWJsZSA+Pj0gZnVuIG4gLT4gc2NoZWR1bGVfc2l6ZSBib2R5IG4pICo+IHAgaW5cbiAgICAgIGF0X2VuZF9vZl9pbnB1dFxuICAgICAgPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAgLT4gZmluaXNoIGJvZHlcbiAgICAgICAgfCBmYWxzZSAtPiBfcmVjKVxuXG5tb2R1bGUgUmVhZGVyID0gc3RydWN0XG4gIG1vZHVsZSBBVSA9IEFuZ3N0cm9tLlVuYnVmZmVyZWRcblxuICB0eXBlIHJlcXVlc3RfZXJyb3IgPSBbXG4gICAgfCBgQmFkX3JlcXVlc3Qgb2YgUmVxdWVzdC50XG4gICAgfCBgUGFyc2Ugb2Ygc3RyaW5nIGxpc3QgKiBzdHJpbmcgXVxuXG4gIHR5cGUgcmVzcG9uc2VfZXJyb3IgPSBbXG4gICAgfCBgSW52YWxpZF9yZXNwb25zZV9ib2R5X2xlbmd0aCBvZiBSZXNwb25zZS50XG4gICAgfCBgUGFyc2Ugb2Ygc3RyaW5nIGxpc3QgKiBzdHJpbmcgXVxuXG4gIHR5cGUgJ2Vycm9yIHBhcnNlX3N0YXRlID1cbiAgICB8IERvbmVcbiAgICB8IEZhaWwgICAgb2YgJ2Vycm9yXG4gICAgfCBQYXJ0aWFsIG9mIChCaWdzdHJpbmdhZi50IC0+IG9mZjppbnQgLT4gbGVuOmludCAtPiBBVS5tb3JlIC0+ICh1bml0LCAnZXJyb3IpIHJlc3VsdCBBVS5zdGF0ZSlcblxuICB0eXBlICdlcnJvciB0ID1cbiAgICB7IHBhcnNlciAgICAgICAgICAgICAgOiAodW5pdCwgJ2Vycm9yKSByZXN1bHQgQW5nc3Ryb20udFxuICAgIDsgbXV0YWJsZSBwYXJzZV9zdGF0ZSA6ICdlcnJvciBwYXJzZV9zdGF0ZVxuICAgICAgKCogVGhlIHN0YXRlIG9mIHRoZSBwYXJzZSBmb3IgdGhlIGN1cnJlbnQgcmVxdWVzdCAqKVxuICAgIDsgbXV0YWJsZSBjbG9zZWQgICAgICA6IGJvb2xcbiAgICAgICgqIFdoZXRoZXIgdGhlIGlucHV0IHNvdXJjZSBoYXMgbGVmdCB0aGUgYnVpbGRpbmcsIGluZGljYXRpbmcgdGhhdCBub1xuICAgICAgICogZnVydGhlciBpbnB1dCB3aWxsIGJlIHJlY2VpdmVkLiAqKVxuICAgIDsgbXV0YWJsZSB3YWtldXAgICAgICA6IE9wdGlvbmFsX3RodW5rLnRcbiAgICB9XG5cbiAgdHlwZSByZXF1ZXN0ICA9IHJlcXVlc3RfZXJyb3IgdFxuICB0eXBlIHJlc3BvbnNlID0gcmVzcG9uc2VfZXJyb3IgdFxuXG4gIGxldCBjcmVhdGUgcGFyc2VyID1cbiAgICB7IHBhcnNlclxuICAgIDsgcGFyc2Vfc3RhdGUgPSBEb25lXG4gICAgOyBjbG9zZWQgICAgICA9IGZhbHNlXG4gICAgOyB3YWtldXAgICAgICA9IE9wdGlvbmFsX3RodW5rLm5vbmVcbiAgICB9XG5cbiAgbGV0IG9rID0gcmV0dXJuIChPayAoKSlcblxuICBsZXQgaXNfY2xvc2VkIHQgPVxuICAgIHQuY2xvc2VkXG5cbiAgbGV0IG9uX3dha2V1cCB0IGsgPVxuICAgIGlmIGlzX2Nsb3NlZCB0XG4gICAgdGhlbiBmYWlsd2l0aCBcIm9uX3dha2V1cCBvbiBjbG9zZWQgcmVhZGVyXCJcbiAgICBlbHNlIGlmIE9wdGlvbmFsX3RodW5rLmlzX3NvbWUgdC53YWtldXBcbiAgICB0aGVuIGZhaWx3aXRoIFwib25fd2FrZXVwOiBvbmx5IG9uZSBjYWxsYmFjayBjYW4gYmUgcmVnaXN0ZXJlZCBhdCBhIHRpbWVcIlxuICAgIGVsc2UgdC53YWtldXAgPC0gT3B0aW9uYWxfdGh1bmsuc29tZSBrXG5cbiAgbGV0IHdha2V1cCB0ID1cbiAgICBsZXQgZiA9IHQud2FrZXVwIGluXG4gICAgdC53YWtldXAgPC0gT3B0aW9uYWxfdGh1bmsubm9uZTtcbiAgICBPcHRpb25hbF90aHVuay5jYWxsX2lmX3NvbWUgZlxuXG4gIGxldCByZXF1ZXN0IH53YWtldXAgaGFuZGxlciA9XG4gICAgbGV0IHBhcnNlciBoYW5kbGVyID1cbiAgICAgIHJlcXVlc3QgPCogY29tbWl0ID4+PSBmdW4gcmVxdWVzdCAtPlxuICAgICAgICBtYXRjaCBSZXF1ZXN0LmJvZHlfbGVuZ3RoIHJlcXVlc3Qgd2l0aFxuICAgICAgfCBgRXJyb3IgYEJhZF9yZXF1ZXN0IC0+IHJldHVybiAoRXJyb3IgKGBCYWRfcmVxdWVzdCByZXF1ZXN0KSlcbiAgICAgIHwgYEZpeGVkIDBMICAtPlxuICAgICAgICBoYW5kbGVyIHJlcXVlc3QgKEJvZHkuUmVhZGVyLmNyZWF0ZV9lbXB0eSAoKSk7XG4gICAgICAgIG9rXG4gICAgICB8IGBGaXhlZCBfIHwgYENodW5rZWQgYXMgZW5jb2RpbmcgLT5cbiAgICAgICAgbGV0IHJlcXVlc3RfYm9keSA9XG4gICAgICAgICAgQm9keS5SZWFkZXIuY3JlYXRlXG4gICAgICAgICAgICBCaWdzdHJpbmdhZi5lbXB0eVxuICAgICAgICAgICAgfndoZW5fcmVhZHlfdG9fcmVhZDooT3B0aW9uYWxfdGh1bmsuc29tZSB3YWtldXApXG4gICAgICAgIGluXG4gICAgICAgIGhhbmRsZXIgcmVxdWVzdCByZXF1ZXN0X2JvZHk7XG4gICAgICAgIGJvZHkgfmVuY29kaW5nIHJlcXVlc3RfYm9keSAqPiBva1xuICAgIGluXG4gICAgY3JlYXRlIChwYXJzZXIgaGFuZGxlcilcblxuICBsZXQgcmVzcG9uc2UgcmVxdWVzdF9xdWV1ZSA9XG4gICAgbGV0IHBhcnNlciB0IHJlcXVlc3RfcXVldWUgPVxuICAgICAgcmVzcG9uc2UgPCogY29tbWl0ID4+PSBmdW4gcmVzcG9uc2UgLT5cbiAgICAgIGFzc2VydCAobm90IChRdWV1ZS5pc19lbXB0eSByZXF1ZXN0X3F1ZXVlKSk7XG4gICAgICBsZXQgZXhjZXB0aW9uIExvY2FsIG9mIFJlc3BkLnQgaW5cbiAgICAgIGxldCByZXNwZCA9IG1hdGNoXG4gICAgICAgIChRdWV1ZS5pdGVyIChmdW4gcmVzcGQgLT5cbiAgICAgICAgICBpZiByZXNwZC5SZXNwZC5zdGF0ZSA9IEF3YWl0aW5nX3Jlc3BvbnNlIHRoZW5cbiAgICAgICAgICAgIHJhaXNlIChMb2NhbCByZXNwZCkpIHJlcXVlc3RfcXVldWUpXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBleGNlcHRpb24gTG9jYWwgcmVzcGQgLT4gcmVzcGRcbiAgICAgICAgfCAoKSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIGluXG4gICAgICBsZXQgcmVxdWVzdCA9IFJlc3BkLnJlcXVlc3QgcmVzcGQgaW5cbiAgICAgIGxldCBwcm94eSA9IGZhbHNlIGluXG4gICAgICBtYXRjaCBSZXNwb25zZS5ib2R5X2xlbmd0aCB+cmVxdWVzdF9tZXRob2Q6cmVxdWVzdC5tZXRoIHJlc3BvbnNlIHdpdGhcbiAgICAgIHwgYEVycm9yIGBCYWRfZ2F0ZXdheSAgICAgICAgICAgLT4gYXNzZXJ0IChub3QgcHJveHkpOyBhc3NlcnQgZmFsc2VcbiAgICAgIHwgYEVycm9yIGBJbnRlcm5hbF9zZXJ2ZXJfZXJyb3IgLT4gcmV0dXJuIChFcnJvciAoYEludmFsaWRfcmVzcG9uc2VfYm9keV9sZW5ndGggcmVzcG9uc2UpKVxuICAgICAgfCBgRml4ZWQgMEwgLT5cbiAgICAgICAgcmVzcGQucmVzcG9uc2VfaGFuZGxlciByZXNwb25zZSAoQm9keS5SZWFkZXIuY3JlYXRlX2VtcHR5ICgpKTtcbiAgICAgICAgb2tcbiAgICAgIHwgYEZpeGVkIF8gfCBgQ2h1bmtlZCB8IGBDbG9zZV9kZWxpbWl0ZWQgYXMgZW5jb2RpbmcgLT5cbiAgICAgICAgKCogV2UgZG8gbm90IHRydXN0IHRoZSBsZW5ndGggcHJvdmlkZWQgaW4gdGhlIFtgRml4ZWRdIGNhc2UsIGFzIHRoZVxuICAgICAgICAgICBjbGllbnQgY291bGQgRE9TIGVhc2lseS4gKilcbiAgICAgICAgbGV0IHJlc3BvbnNlX2JvZHkgPVxuICAgICAgICAgIEJvZHkuUmVhZGVyLmNyZWF0ZSBCaWdzdHJpbmdhZi5lbXB0eSB+d2hlbl9yZWFkeV90b19yZWFkOihPcHRpb25hbF90aHVuay5zb21lIChmdW4gKCkgLT5cbiAgICAgICAgICAgIHdha2V1cCAoTGF6eS5mb3JjZSB0KSkpXG4gICAgICAgIGluXG4gICAgICAgIHJlc3BkLnJlc3BvbnNlX2hhbmRsZXIgcmVzcG9uc2UgcmVzcG9uc2VfYm9keTtcbiAgICAgICAgYm9keSB+ZW5jb2RpbmcgcmVzcG9uc2VfYm9keSAqPiBva1xuICAgIGluXG4gICAgbGV0IHJlYyB0ID0gbGF6eSAoY3JlYXRlIChwYXJzZXIgdCByZXF1ZXN0X3F1ZXVlKSkgaW5cbiAgICBMYXp5LmZvcmNlIHRcbiAgOztcblxuXG4gIGxldCB0cmFuc2l0aW9uIHQgc3RhdGUgPVxuICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICB8IEFVLkRvbmUoY29uc3VtZWQsIE9rICgpKSAtPlxuICAgICAgdC5wYXJzZV9zdGF0ZSA8LSBEb25lO1xuICAgICAgY29uc3VtZWRcbiAgICB8IEFVLkRvbmUoY29uc3VtZWQsIEVycm9yIGVycm9yKSAtPlxuICAgICAgdC5wYXJzZV9zdGF0ZSA8LSBGYWlsIGVycm9yO1xuICAgICAgY29uc3VtZWRcbiAgICB8IEFVLkZhaWwoY29uc3VtZWQsIG1hcmtzLCBtc2cpIC0+XG4gICAgICB0LnBhcnNlX3N0YXRlIDwtIEZhaWwgKGBQYXJzZShtYXJrcywgbXNnKSk7XG4gICAgICBjb25zdW1lZFxuICAgIHwgQVUuUGFydGlhbCB7IGNvbW1pdHRlZDsgY29udGludWUgfSAtPlxuICAgICAgdC5wYXJzZV9zdGF0ZSA8LSBQYXJ0aWFsIGNvbnRpbnVlO1xuICAgICAgY29tbWl0dGVkXG4gIGFuZCBzdGFydCB0IHN0YXRlID1cbiAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgIHwgQVUuRG9uZSBfICAgICAgICAgLT4gZmFpbHdpdGggXCJodHRwYWYuUGFyc2UudW5hYmxlIHRvIHN0YXJ0IHBhcnNlclwiXG4gICAgICB8IEFVLkZhaWwoMCwgbWFya3MsIG1zZykgLT5cbiAgICAgICAgdC5wYXJzZV9zdGF0ZSA8LSBGYWlsIChgUGFyc2UobWFya3MsIG1zZykpXG4gICAgICB8IEFVLlBhcnRpYWwgeyBjb21taXR0ZWQgPSAwOyBjb250aW51ZSB9IC0+XG4gICAgICAgIHQucGFyc2Vfc3RhdGUgPC0gUGFydGlhbCBjb250aW51ZVxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCByZWMgX3JlYWRfd2l0aF9tb3JlIHQgYnMgfm9mZiB+bGVuIG1vcmUgPVxuICAgIGxldCBpbml0aWFsID0gbWF0Y2ggdC5wYXJzZV9zdGF0ZSB3aXRoIERvbmUgLT4gdHJ1ZSB8IF8gLT4gZmFsc2UgaW5cbiAgICBsZXQgY29uc3VtZWQgPVxuICAgICAgbWF0Y2ggdC5wYXJzZV9zdGF0ZSB3aXRoXG4gICAgICB8IEZhaWwgXyAtPiAwXG4gICAgICAoKiBEb24ndCBmZWVkIGVtcHR5IGlucHV0IHdoZW4gd2UncmUgYXQgYSByZXF1ZXN0IGJvdW5kYXJ5ICopXG4gICAgICB8IERvbmUgd2hlbiBsZW4gPSAwIC0+IDBcbiAgICAgIHwgRG9uZSAgIC0+XG4gICAgICAgIHN0YXJ0IHQgKEFVLnBhcnNlIHQucGFyc2VyKTtcbiAgICAgICAgX3JlYWRfd2l0aF9tb3JlICB0IGJzIH5vZmYgfmxlbiBtb3JlO1xuICAgICAgfCBQYXJ0aWFsIGNvbnRpbnVlIC0+XG4gICAgICAgIHRyYW5zaXRpb24gdCAoY29udGludWUgYnMgbW9yZSB+b2ZmIH5sZW4pXG4gICAgaW5cbiAgICAoKiBTcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIHBhcnNlciBqdXN0IHN0YXJ0ZWQgYW5kIHdhcyBmZWQgYSB6ZXJvLWxlbmd0aFxuICAgICAqIGJpZ3N0cmluZy4gQXZvaWQgcHV0dGluZyB0aGVtIHBhcnNlciBpbiBhbiBlcnJvciBzdGF0ZSBpbiB0aGlzIHNjZW5hcmlvLlxuICAgICAqIElmIHdlIHdlcmUgYWxyZWFkeSBpbiBhIGBQYXJ0aWFsYCBzdGF0ZSwgcmV0dXJuIHRoZSBlcnJvci4gKilcbiAgICBpZiBpbml0aWFsICYmIGxlbiA9IDAgdGhlbiB0LnBhcnNlX3N0YXRlIDwtIERvbmU7XG4gICAgbWF0Y2ggdC5wYXJzZV9zdGF0ZSB3aXRoXG4gICAgfCBEb25lIHdoZW4gY29uc3VtZWQgPCBsZW4gLT5cbiAgICAgIGxldCBvZmYgPSBvZmYgKyBjb25zdW1lZFxuICAgICAgYW5kIGxlbiA9IGxlbiAtIGNvbnN1bWVkIGluXG4gICAgICBjb25zdW1lZCArIF9yZWFkX3dpdGhfbW9yZSB0IGJzIH5vZmYgfmxlbiBtb3JlXG4gICAgfCBfIC0+IGNvbnN1bWVkXG4gIDs7XG5cbiAgbGV0IHJlYWRfd2l0aF9tb3JlIHQgYnMgfm9mZiB+bGVuIG1vcmUgPVxuICAgIGxldCBjb25zdW1lZCA9IF9yZWFkX3dpdGhfbW9yZSB0IGJzIH5vZmYgfmxlbiBtb3JlIGluXG4gICAgKG1hdGNoIG1vcmUgd2l0aFxuICAgICB8IENvbXBsZXRlIC0+XG4gICAgICAgdC5jbG9zZWQgPC0gdHJ1ZVxuICAgICB8IEluY29tcGxldGUgLT4gKCkpO1xuICAgIGNvbnN1bWVkXG5cbiAgbGV0IGZvcmNlX2Nsb3NlIHQgPVxuICAgIHQuY2xvc2VkIDwtIHRydWU7XG4gIDs7XG5cbiAgbGV0IG5leHQgdCA9XG4gICAgbWF0Y2ggdC5wYXJzZV9zdGF0ZSB3aXRoXG4gICAgfCBGYWlsIGZhaWx1cmUgLT4gYEVycm9yIGZhaWx1cmVcbiAgICB8IF8gd2hlbiB0LmNsb3NlZCAtPiBgQ2xvc2VcbiAgICB8IERvbmUgICAgICAtPiBgU3RhcnRcbiAgICB8IFBhcnRpYWwgXyAtPiBgUmVhZFxuICA7O1xuZW5kXG4iLCJ0eXBlIHQgPVxuICB8IFdhaXRpbmdcbiAgfCBGaXhlZCAgb2YgUmVzcG9uc2UudFxuICB8IFN0cmVhbWluZyBvZiBSZXNwb25zZS50ICogQm9keS5Xcml0ZXIudFxuICB8IFVwZ3JhZGUgb2YgUmVzcG9uc2UudCAqICh1bml0IC0+IHVuaXQpXG5cbmxldCBvdXRwdXRfc3RhdGUgdCA6IE91dHB1dF9zdGF0ZS50ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRml4ZWQgXyAtPiBDb21wbGV0ZVxuICB8IFdhaXRpbmcgLT4gV2FpdGluZ1xuICB8IFN0cmVhbWluZyhfLCByZXNwb25zZV9ib2R5KSAtPlxuICAgIGlmIEJvZHkuV3JpdGVyLnJlcXVpcmVzX291dHB1dCByZXNwb25zZV9ib2R5XG4gICAgdGhlbiBSZWFkeVxuICAgIGVsc2UgQ29tcGxldGVcbiAgfCBVcGdyYWRlIF8gLT4gUmVhZHlcblxubGV0IGZsdXNoX3Jlc3BvbnNlX2JvZHkgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFN0cmVhbWluZyAoXywgcmVzcG9uc2VfYm9keSkgLT5cbiAgICBCb2R5LldyaXRlci50cmFuc2Zlcl90b193cml0ZXIgcmVzcG9uc2VfYm9keVxuICB8IF8gLT4gKClcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxudHlwZSBlcnJvciA9XG4gIFsgYEJhZF9yZXF1ZXN0IHwgYEJhZF9nYXRld2F5IHwgYEludGVybmFsX3NlcnZlcl9lcnJvciB8IGBFeG4gb2YgZXhuIF1cblxudHlwZSBlcnJvcl9oYW5kbGVyID1cbiAgP3JlcXVlc3Q6UmVxdWVzdC50IC0+IGVycm9yIC0+IChIZWFkZXJzLnQgLT4gQm9keS5Xcml0ZXIudCkgLT4gdW5pdFxuXG5tb2R1bGUgUmVhZGVyID0gUGFyc2UuUmVhZGVyXG5tb2R1bGUgV3JpdGVyID0gU2VyaWFsaXplLldyaXRlclxuXG4oKiBYWFgoc2VsaW9wb3UpOiBUaGUgY3VycmVudCBkZXNpZ24gYXNzdW1lcyB0aGF0IGEgbmV3IFtSZXFkLnRdIHdpbGwgYmVcbiAqIGFsbG9jYXRlZCBmb3IgZWFjaCBuZXcgcmVxdWVzdC9yZXNwb25zZSBvbiBhIGNvbm5lY3Rpb24uIFRoaXMgaXMgd2FzdGVmdWwsXG4gKiBhcyBpdCBjcmVhdGVzIGdhcmJhZ2Ugb24gcGVyc2lzdGVudCBjb25uZWN0aW9ucy4gQSBiZXR0ZXIgYXBwcm9hY2ggd291bGQgYmVcbiAqIHRvIGFsbG9jYXRlIGEgc2luZ2xlIFtSZXFkLnRdIHBlciBjb25uZWN0aW9uIGFuZCByZXVzZSBpdCBhY3Jvc3NcbiAqIHJlcXVlc3QvcmVzcG9uc2VzLiBUaGlzIHdvdWxkIGFsbG93IGEgc2luZ2xlIFtGYXJhZGF5LnRdIHRvIGJlIGFsbG9jYXRlZCBmb3JcbiAqIHRoZSBib2R5IGFuZCByZXVzZWQuIFRoZSBbcmVzcG9uc2Vfc3RhdGVdIHR5cGUgY291bGQgdGhlbiBiZSBpbmxpbmVkIGludG9cbiAqIHRoZSBbUmVxZC50XSByZWNvcmQsIHdpdGggZHVtbXkgdmFsdWVzIG9jY3VwaW5nIHRoZSBmaWVsZHMgZm9yIFtyZXNwb25zZV0uXG4gKiBTb21ldGhpbmcgbGlrZSB0aGlzOlxuICpcbiAqIHtbXG4gKiAgIHR5cGUgJ2hhbmRsZSB0ID1cbiAqICAgICB7IG11dGFibGUgcmVxdWVzdCAgICAgICAgOiBSZXF1ZXN0LnRcbiAqICAgICA7IG11dGFibGUgcmVxdWVzdF9ib2R5ICAgOiBSZXNwb25zZS5Cb2R5LlJlYWRlci50XG4gKiAgICAgOyBtdXRhYmxlIHJlc3BvbnNlICAgICAgIDogUmVzcG9uc2UudCAoKiBTdGFydHMgb2ZmIGFzIGEgZHVtbXkgdmFsdWUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB1c2luZyBbKD09KV0gdG8gaWRlbnRpZnkgaXQgd2hlblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbmVjZXNzYXJ5ICopXG4gKiAgICAgOyBtdXRhYmxlIHJlc3BvbnNlX2JvZHkgIDogUmVzcG9uc2UuQm9keS5Xcml0ZXIudFxuICogICAgIDsgbXV0YWJsZSBwZXJzaXN0ZW50ICAgICA6IGJvb2xcbiAqICAgICA7IG11dGFibGUgcmVzcG9uc2Vfc3RhdGUgOiBbIGBXYWl0aW5nIHwgYFN0YXJ0ZWQgfCBgU3RyZWFtaW5nIF1cbiAqICAgICB9XG4gKiAgXX1cbiAqXG4gKiAqKVxudHlwZSB0ID1cbiAgeyByZXF1ZXN0ICAgICAgICAgICAgICAgICA6IFJlcXVlc3QudFxuICA7IHJlcXVlc3RfYm9keSAgICAgICAgICAgIDogQm9keS5SZWFkZXIudFxuICA7IHJlYWRlciAgICAgICAgICAgICAgICAgIDogUmVhZGVyLnJlcXVlc3RcbiAgOyB3cml0ZXIgICAgICAgICAgICAgICAgICA6IFdyaXRlci50XG4gIDsgcmVzcG9uc2VfYm9keV9idWZmZXIgICAgOiBCaWdzdHJpbmdhZi50XG4gIDsgZXJyb3JfaGFuZGxlciAgICAgICAgICAgOiBlcnJvcl9oYW5kbGVyXG4gIDsgbXV0YWJsZSBwZXJzaXN0ZW50ICAgICAgOiBib29sXG4gIDsgbXV0YWJsZSByZXNwb25zZV9zdGF0ZSAgOiBSZXNwb25zZV9zdGF0ZS50XG4gIDsgbXV0YWJsZSBlcnJvcl9jb2RlICAgICAgOiBbYE9rIHwgZXJyb3IgXVxuICB9XG5cbmxldCBjcmVhdGUgZXJyb3JfaGFuZGxlciByZXF1ZXN0IHJlcXVlc3RfYm9keSByZWFkZXIgd3JpdGVyIHJlc3BvbnNlX2JvZHlfYnVmZmVyID1cbiAgeyByZXF1ZXN0XG4gIDsgcmVxdWVzdF9ib2R5XG4gIDsgcmVhZGVyXG4gIDsgd3JpdGVyXG4gIDsgcmVzcG9uc2VfYm9keV9idWZmZXJcbiAgOyBlcnJvcl9oYW5kbGVyXG4gIDsgcGVyc2lzdGVudCAgICAgICAgICAgICAgPSBSZXF1ZXN0LnBlcnNpc3RlbnRfY29ubmVjdGlvbiByZXF1ZXN0XG4gIDsgcmVzcG9uc2Vfc3RhdGUgICAgICAgICAgPSBXYWl0aW5nXG4gIDsgZXJyb3JfY29kZSAgICAgICAgICAgICAgPSBgT2tcbiAgfVxuXG5sZXQgcmVxdWVzdCB7IHJlcXVlc3Q7IF8gfSA9IHJlcXVlc3RcbmxldCByZXF1ZXN0X2JvZHkgeyByZXF1ZXN0X2JvZHk7IF8gfSA9IHJlcXVlc3RfYm9keVxuXG5sZXQgcmVzcG9uc2UgeyByZXNwb25zZV9zdGF0ZTsgXyB9ID1cbiAgbWF0Y2ggcmVzcG9uc2Vfc3RhdGUgd2l0aFxuICB8IFdhaXRpbmcgLT4gTm9uZVxuICB8IFN0cmVhbWluZyAocmVzcG9uc2UsIF8pXG4gIHwgRml4ZWQgcmVzcG9uc2VcbiAgfCBVcGdyYWRlIChyZXNwb25zZSwgXykgLT4gU29tZSByZXNwb25zZVxuXG5sZXQgcmVzcG9uc2VfZXhuIHsgcmVzcG9uc2Vfc3RhdGU7IF8gfSA9XG4gIG1hdGNoIHJlc3BvbnNlX3N0YXRlIHdpdGhcbiAgfCBXYWl0aW5nIC0+IGZhaWx3aXRoIFwiaHR0cGFmLlJlcWQucmVzcG9uc2VfZXhuOiByZXNwb25zZSBoYXMgbm90IHN0YXJ0ZWRcIlxuICB8IFN0cmVhbWluZyhyZXNwb25zZSwgXylcbiAgfCBGaXhlZCByZXNwb25zZVxuICB8IFVwZ3JhZGUgKHJlc3BvbnNlLCBfKSAtPiByZXNwb25zZVxuXG5sZXQgcmVzcG9uZF93aXRoX3N0cmluZyB0IHJlc3BvbnNlIHN0ciA9XG4gIGlmIHQuZXJyb3JfY29kZSA8PiBgT2sgdGhlblxuICAgIGZhaWx3aXRoIFwiaHR0cGFmLlJlcWQucmVzcG9uZF93aXRoX3N0cmluZzogaW52YWxpZCBzdGF0ZSwgY3VycmVudGx5IGhhbmRsaW5nIGVycm9yXCI7XG4gIG1hdGNoIHQucmVzcG9uc2Vfc3RhdGUgd2l0aFxuICB8IFdhaXRpbmcgLT5cbiAgICAoKiBYWFgoc2VsaW9wb3UpOiBjaGVjayByZXNwb25zZSBib2R5IGxlbmd0aCAqKVxuICAgIFdyaXRlci53cml0ZV9yZXNwb25zZSB0LndyaXRlciByZXNwb25zZTtcbiAgICBXcml0ZXIud3JpdGVfc3RyaW5nIHQud3JpdGVyIHN0cjtcbiAgICBpZiB0LnBlcnNpc3RlbnQgdGhlblxuICAgICAgdC5wZXJzaXN0ZW50IDwtIFJlc3BvbnNlLnBlcnNpc3RlbnRfY29ubmVjdGlvbiByZXNwb25zZTtcbiAgICB0LnJlc3BvbnNlX3N0YXRlIDwtIEZpeGVkIHJlc3BvbnNlO1xuICAgIFdyaXRlci53YWtldXAgdC53cml0ZXI7XG4gIHwgU3RyZWFtaW5nIF8gfCBVcGdyYWRlIF8gLT5cbiAgICBmYWlsd2l0aCBcImh0dHBhZi5SZXFkLnJlc3BvbmRfd2l0aF9zdHJpbmc6IHJlc3BvbnNlIGFscmVhZHkgc3RhcnRlZFwiXG4gIHwgRml4ZWQgXyAtPlxuICAgIGZhaWx3aXRoIFwiaHR0cGFmLlJlcWQucmVzcG9uZF93aXRoX3N0cmluZzogcmVzcG9uc2UgYWxyZWFkeSBjb21wbGV0ZVwiXG5cbmxldCByZXNwb25kX3dpdGhfYmlnc3RyaW5nIHQgcmVzcG9uc2UgKGJzdHI6Qmlnc3RyaW5nYWYudCkgPVxuICBpZiB0LmVycm9yX2NvZGUgPD4gYE9rIHRoZW5cbiAgICBmYWlsd2l0aCBcImh0dHBhZi5SZXFkLnJlc3BvbmRfd2l0aF9iaWdzdHJpbmc6IGludmFsaWQgc3RhdGUsIGN1cnJlbnRseSBoYW5kbGluZyBlcnJvclwiO1xuICBtYXRjaCB0LnJlc3BvbnNlX3N0YXRlIHdpdGhcbiAgfCBXYWl0aW5nIC0+XG4gICAgKCogWFhYKHNlbGlvcG91KTogY2hlY2sgcmVzcG9uc2UgYm9keSBsZW5ndGggKilcbiAgICBXcml0ZXIud3JpdGVfcmVzcG9uc2UgICAgIHQud3JpdGVyIHJlc3BvbnNlO1xuICAgIFdyaXRlci5zY2hlZHVsZV9iaWdzdHJpbmcgdC53cml0ZXIgYnN0cjtcbiAgICBpZiB0LnBlcnNpc3RlbnQgdGhlblxuICAgICAgdC5wZXJzaXN0ZW50IDwtIFJlc3BvbnNlLnBlcnNpc3RlbnRfY29ubmVjdGlvbiByZXNwb25zZTtcbiAgICB0LnJlc3BvbnNlX3N0YXRlIDwtIEZpeGVkIHJlc3BvbnNlO1xuICAgIFdyaXRlci53YWtldXAgdC53cml0ZXI7XG4gIHwgU3RyZWFtaW5nIF8gfCBVcGdyYWRlIF8gLT5cbiAgICBmYWlsd2l0aCBcImh0dHBhZi5SZXFkLnJlc3BvbmRfd2l0aF9iaWdzdHJpbmc6IHJlc3BvbnNlIGFscmVhZHkgc3RhcnRlZFwiXG4gIHwgRml4ZWQgXyAtPlxuICAgIGZhaWx3aXRoIFwiaHR0cGFmLlJlcWQucmVzcG9uZF93aXRoX2JpZ3N0cmluZzogcmVzcG9uc2UgYWxyZWFkeSBjb21wbGV0ZVwiXG5cbmxldCB1bnNhZmVfcmVzcG9uZF93aXRoX3N0cmVhbWluZyB+Zmx1c2hfaGVhZGVyc19pbW1lZGlhdGVseSB0IHJlc3BvbnNlID1cbiAgbWF0Y2ggdC5yZXNwb25zZV9zdGF0ZSB3aXRoXG4gIHwgV2FpdGluZyAtPlxuICAgIGxldCBlbmNvZGluZyA9XG4gICAgICBtYXRjaCBSZXNwb25zZS5ib2R5X2xlbmd0aCB+cmVxdWVzdF9tZXRob2Q6dC5yZXF1ZXN0Lm1ldGggcmVzcG9uc2Ugd2l0aFxuICAgICAgfCBgRml4ZWQgXyB8IGBDbG9zZV9kZWxpbWl0ZWQgfCBgQ2h1bmtlZCBhcyBlbmNvZGluZyAtPiBlbmNvZGluZ1xuICAgICAgfCBgRXJyb3IgKGBCYWRfZ2F0ZXdheSB8IGBJbnRlcm5hbF9zZXJ2ZXJfZXJyb3IpIC0+XG4gICAgICAgIGZhaWx3aXRoIFwiaHR0cGFmLlJlcWQucmVzcG9uZF93aXRoX3N0cmVhbWluZzogaW52YWxpZCByZXNwb25zZSBib2R5IGxlbmd0aFwiXG4gICAgaW5cbiAgICBsZXQgcmVzcG9uc2VfYm9keSA9XG4gICAgICBCb2R5LldyaXRlci5jcmVhdGVcbiAgICAgICAgdC5yZXNwb25zZV9ib2R5X2J1ZmZlclxuICAgICAgICB+ZW5jb2RpbmdcbiAgICAgICAgfndyaXRlcjp0LndyaXRlclxuICAgIGluXG4gICAgV3JpdGVyLndyaXRlX3Jlc3BvbnNlIHQud3JpdGVyIHJlc3BvbnNlO1xuICAgIGlmIHQucGVyc2lzdGVudCB0aGVuXG4gICAgICB0LnBlcnNpc3RlbnQgPC0gUmVzcG9uc2UucGVyc2lzdGVudF9jb25uZWN0aW9uIHJlc3BvbnNlO1xuICAgIHQucmVzcG9uc2Vfc3RhdGUgPC0gU3RyZWFtaW5nIChyZXNwb25zZSwgcmVzcG9uc2VfYm9keSk7XG4gICAgaWYgZmx1c2hfaGVhZGVyc19pbW1lZGlhdGVseVxuICAgIHRoZW4gV3JpdGVyLndha2V1cCB0LndyaXRlcjtcbiAgICByZXNwb25zZV9ib2R5XG4gIHwgU3RyZWFtaW5nIF8gfCBVcGdyYWRlIF8gLT5cbiAgICBmYWlsd2l0aCBcImh0dHBhZi5SZXFkLnJlc3BvbmRfd2l0aF9zdHJlYW1pbmc6IHJlc3BvbnNlIGFscmVhZHkgc3RhcnRlZFwiXG4gIHwgRml4ZWQgXyAtPlxuICAgIGZhaWx3aXRoIFwiaHR0cGFmLlJlcWQucmVzcG9uZF93aXRoX3N0cmVhbWluZzogcmVzcG9uc2UgYWxyZWFkeSBjb21wbGV0ZVwiXG5cbmxldCByZXNwb25kX3dpdGhfc3RyZWFtaW5nID8oZmx1c2hfaGVhZGVyc19pbW1lZGlhdGVseT1mYWxzZSkgdCByZXNwb25zZSA9XG4gIGlmIHQuZXJyb3JfY29kZSA8PiBgT2sgdGhlblxuICAgIGZhaWx3aXRoIFwiaHR0cGFmLlJlcWQucmVzcG9uZF93aXRoX3N0cmVhbWluZzogaW52YWxpZCBzdGF0ZSwgY3VycmVudGx5IGhhbmRsaW5nIGVycm9yXCI7XG4gIHVuc2FmZV9yZXNwb25kX3dpdGhfc3RyZWFtaW5nIH5mbHVzaF9oZWFkZXJzX2ltbWVkaWF0ZWx5IHQgcmVzcG9uc2VcblxubGV0IHVuc2FmZV9yZXNwb25kX3dpdGhfdXBncmFkZSB0IGhlYWRlcnMgdXBncmFkZV9oYW5kbGVyID1cbiAgbWF0Y2ggdC5yZXNwb25zZV9zdGF0ZSB3aXRoXG4gIHwgV2FpdGluZyAtPlxuICAgIGxldCByZXNwb25zZSA9IFJlc3BvbnNlLmNyZWF0ZSB+aGVhZGVycyBgU3dpdGNoaW5nX3Byb3RvY29scyBpblxuICAgIFdyaXRlci53cml0ZV9yZXNwb25zZSB0LndyaXRlciByZXNwb25zZTtcbiAgICBpZiB0LnBlcnNpc3RlbnQgdGhlblxuICAgICAgdC5wZXJzaXN0ZW50IDwtIFJlc3BvbnNlLnBlcnNpc3RlbnRfY29ubmVjdGlvbiByZXNwb25zZTtcbiAgICB0LnJlc3BvbnNlX3N0YXRlIDwtIFVwZ3JhZGUgKHJlc3BvbnNlLCB1cGdyYWRlX2hhbmRsZXIpO1xuICAgIFdyaXRlci5mbHVzaCB0LndyaXRlciB1cGdyYWRlX2hhbmRsZXI7XG4gICAgQm9keS5SZWFkZXIuY2xvc2UgdC5yZXF1ZXN0X2JvZHk7XG4gICAgV3JpdGVyLndha2V1cCB0LndyaXRlclxuICB8IFN0cmVhbWluZyBfIHwgVXBncmFkZSBfIC0+XG4gICAgZmFpbHdpdGggXCJodHRwYWYuUmVxZC51bnNhZmVfcmVzcG9uZF93aXRoX3VwZ3JhZGU6IHJlc3BvbnNlIGFscmVhZHkgc3RhcnRlZFwiXG4gIHwgRml4ZWQgXyAtPlxuICAgIGZhaWx3aXRoIFwiaHR0cGFmLlJlcWQudW5zYWZlX3Jlc3BvbmRfd2l0aF91cGdyYWRlOiByZXNwb25zZSBhbHJlYWR5IGNvbXBsZXRlXCJcblxubGV0IHJlc3BvbmRfd2l0aF91cGdyYWRlIHQgcmVzcG9uc2UgdXBncmFkZV9oYW5kbGVyID1cbiAgaWYgdC5lcnJvcl9jb2RlIDw+IGBPayB0aGVuXG4gICAgZmFpbHdpdGggXCJodHRwYWYuUmVxZC5yZXNwb25kX3dpdGhfc3RyZWFtaW5nOiBpbnZhbGlkIHN0YXRlLCBjdXJyZW50bHkgaGFuZGxpbmcgZXJyb3JcIjtcbiAgdW5zYWZlX3Jlc3BvbmRfd2l0aF91cGdyYWRlIHQgcmVzcG9uc2UgdXBncmFkZV9oYW5kbGVyXG5cbmxldCByZXBvcnRfZXJyb3IgdCBlcnJvciA9XG4gIHQucGVyc2lzdGVudCA8LSBmYWxzZTtcbiAgbWF0Y2ggdC5yZXNwb25zZV9zdGF0ZSwgdC5lcnJvcl9jb2RlIHdpdGhcbiAgfCBXYWl0aW5nLCBgT2sgLT5cbiAgICB0LmVycm9yX2NvZGUgPC0gKGVycm9yIDo+IFtgT2sgfCBlcnJvcl0pO1xuICAgIGxldCBzdGF0dXMgPVxuICAgICAgbWF0Y2ggKGVycm9yIDo+IFtlcnJvciB8IFN0YXR1cy5zdGFuZGFyZF0pIHdpdGhcbiAgICAgIHwgYEV4biBfICAgICAgICAgICAgICAgICAgICAgLT4gYEludGVybmFsX3NlcnZlcl9lcnJvclxuICAgICAgfCAjU3RhdHVzLnN0YW5kYXJkIGFzIHN0YXR1cyAtPiBzdGF0dXNcbiAgICBpblxuICAgIHQuZXJyb3JfaGFuZGxlciB+cmVxdWVzdDp0LnJlcXVlc3QgZXJyb3IgKGZ1biBoZWFkZXJzIC0+XG4gICAgICBsZXQgcmVzcG9uc2VfYm9keSA9XG4gICAgICAgIHVuc2FmZV9yZXNwb25kX3dpdGhfc3RyZWFtaW5nXG4gICAgICAgICAgdFxuICAgICAgICAgIH5mbHVzaF9oZWFkZXJzX2ltbWVkaWF0ZWx5OnRydWVcbiAgICAgICAgICAoUmVzcG9uc2UuY3JlYXRlIH5oZWFkZXJzIHN0YXR1cylcbiAgICAgIGluXG4gICAgICAoKiBOT1RFKGFubW9udGVpcm8pOiBXaGVuIHJlcG9ydGluZyBhbiBlcnJvciB0aGF0IGNhbGxzIHRoZSBlcnJvclxuICAgICAgICAgaGFuZGxlciwgd2UgY2FuIG9ubHkgZGVsaXZlciBhbiBFT0YgdG8gdGhlIHJlcXVlc3QgYm9keSBvbmNlIHRoZSBlcnJvclxuICAgICAgICAgcmVzcG9uc2UgaGFzIHN0YXJ0ZWQuIE90aGVyd2lzZSwgdGhlIHJlcXVlc3QgYm9keSBgb25fZW9mYCBoYW5kbGVyXG4gICAgICAgICBjb3VsZCBlcnJvbmVvdXNseSBzZW5kIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBpbnN0ZWFkIG9mIGxldHRpbmcgdXNcbiAgICAgICAgIGhhbmRsZSB0aGUgZXJyb3IuICopXG4gICAgICBCb2R5LlJlYWRlci5jbG9zZSB0LnJlcXVlc3RfYm9keTtcbiAgICAgIHJlc3BvbnNlX2JvZHkpXG4gIHwgb3RoZXIgLT5cbiAgICBCb2R5LlJlYWRlci5jbG9zZSB0LnJlcXVlc3RfYm9keTtcbiAgICBtYXRjaCBvdGhlciB3aXRoXG4gICAgfCBXYWl0aW5nLCBgRXhuIF8gLT5cbiAgICAgICgqIFhYWChzZWxpb3BvdSk6IERlY2lkZSB3aGF0IHRvIGRvIGluIHRoaXMgdW5saWtlbHkgY2FzZS4gVGhlcmUgaXMgYW5cbiAgICAgICAqIG91dHN0YW5kaW5nIGNhbGwgdG8gdGhlIFtlcnJvcl9oYW5kbGVyXSwgYnV0IGFuIGludGVydmVuaW5nIGV4Y2VwdGlvblxuICAgICAgICogaGFzIGJlZW4gcmVwb3J0ZWQgYXMgd2VsbC4gKilcbiAgICAgIGZhaWx3aXRoIFwiaHR0cGFmLlJlcWQucmVwb3J0X2V4bjogTllJXCJcbiAgICB8IFN0cmVhbWluZyAoX3Jlc3BvbnNlLCByZXNwb25zZV9ib2R5KSwgYE9rIC0+XG4gICAgICBCb2R5LldyaXRlci5mb3JjZV9jbG9zZSByZXNwb25zZV9ib2R5O1xuICAgICAgUmVhZGVyLndha2V1cCB0LnJlYWRlcjtcbiAgICB8IFN0cmVhbWluZyAoX3Jlc3BvbnNlLCByZXNwb25zZV9ib2R5KSwgYEV4biBfIC0+XG4gICAgICBCb2R5LldyaXRlci5jbG9zZSByZXNwb25zZV9ib2R5O1xuICAgICAgV3JpdGVyLmNsb3NlX2FuZF9kcmFpbiB0LndyaXRlcjtcbiAgICAgIFJlYWRlci53YWtldXAgdC5yZWFkZXI7XG4gICAgfCAoRml4ZWQgXyB8IFN0cmVhbWluZyBfIHwgVXBncmFkZSBfIHwgV2FpdGluZykgLCBfIC0+XG4gICAgICAoKiBYWFgoc2VsaW9wb3UpOiBPbmNlIGFkZGl0aW9uYWwgbG9nZ2luZyBzdXBwb3J0IGlzIGFkZGVkLCBsb2cgdGhlIGVycm9yXG4gICAgICAgKiBpbiBjYXNlIGl0IGlzIG5vdCBzcHVyaW91cy4gKilcbiAgICAgICgpXG5cbmxldCByZXBvcnRfZXhuIHQgZXhuID1cbiAgcmVwb3J0X2Vycm9yIHQgKGBFeG4gZXhuKVxuXG5sZXQgdHJ5X3dpdGggdCBmIDogKHVuaXQsIGV4bikgcmVzdWx0ID1cbiAgdHJ5IGYgKCk7IE9rICgpIHdpdGggZXhuIC0+IHJlcG9ydF9leG4gdCBleG47IEVycm9yIGV4blxuXG4oKiBQcml2YXRlIEFQSSwgbm90IGV4cG9zZWQgdG8gdGhlIHVzZXIgdGhyb3VnaCBodHRwYWYubWxpICopXG5cbmxldCBjbG9zZV9yZXF1ZXN0X2JvZHkgeyByZXF1ZXN0X2JvZHk7IF8gfSA9XG4gIEJvZHkuUmVhZGVyLmNsb3NlIHJlcXVlc3RfYm9keVxuXG5sZXQgZXJyb3JfY29kZSB0ID1cbiAgbWF0Y2ggdC5lcnJvcl9jb2RlIHdpdGhcbiAgfCAjZXJyb3IgYXMgZXJyb3IgLT4gU29tZSBlcnJvclxuICB8IGBPayAgICAgICAgICAgICAtPiBOb25lXG5cbmxldCBwZXJzaXN0ZW50X2Nvbm5lY3Rpb24gdCA9XG4gIHQucGVyc2lzdGVudFxuXG5sZXQgaW5wdXRfc3RhdGUgdCA6IElucHV0X3N0YXRlLnQgPVxuICBtYXRjaCB0LnJlc3BvbnNlX3N0YXRlIHdpdGhcbiAgfCBVcGdyYWRlIF8gLT4gUmVhZHlcbiAgfCBfIC0+XG4gICAgaWYgQm9keS5SZWFkZXIuaXNfY2xvc2VkIHQucmVxdWVzdF9ib2R5XG4gICAgdGhlbiBDb21wbGV0ZVxuICAgIGVsc2UgaWYgQm9keS5SZWFkZXIuaXNfcmVhZF9zY2hlZHVsZWQgdC5yZXF1ZXN0X2JvZHlcbiAgICB0aGVuIFJlYWR5XG4gICAgZWxzZSBXYWl0XG5cbmxldCBvdXRwdXRfc3RhdGUgdCA9IFJlc3BvbnNlX3N0YXRlLm91dHB1dF9zdGF0ZSB0LnJlc3BvbnNlX3N0YXRlXG5cbmxldCBmbHVzaF9yZXF1ZXN0X2JvZHkgdCA9XG4gIGlmIEJvZHkuUmVhZGVyLmhhc19wZW5kaW5nX291dHB1dCB0LnJlcXVlc3RfYm9keVxuICB0aGVuIHRyeSBCb2R5LlJlYWRlci5leGVjdXRlX3JlYWQgdC5yZXF1ZXN0X2JvZHlcbiAgd2l0aCBleG4gLT4gcmVwb3J0X2V4biB0IGV4blxuXG5sZXQgZmx1c2hfcmVzcG9uc2VfYm9keSB0ID1cbiAgUmVzcG9uc2Vfc3RhdGUuZmx1c2hfcmVzcG9uc2VfYm9keSB0LnJlc3BvbnNlX3N0YXRlXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cblxubW9kdWxlIFJlYWRlciA9IFBhcnNlLlJlYWRlclxubW9kdWxlIFdyaXRlciA9IFNlcmlhbGl6ZS5Xcml0ZXJcblxuXG50eXBlIHJlcXVlc3RfaGFuZGxlciA9IFJlcWQudCAtPiB1bml0XG5cbnR5cGUgZXJyb3IgPVxuICBbIGBCYWRfZ2F0ZXdheSB8IGBCYWRfcmVxdWVzdCB8IGBJbnRlcm5hbF9zZXJ2ZXJfZXJyb3IgfCBgRXhuIG9mIGV4bl1cblxudHlwZSBlcnJvcl9oYW5kbGVyID1cbiAgP3JlcXVlc3Q6UmVxdWVzdC50IC0+IGVycm9yIC0+IChIZWFkZXJzLnQgLT4gQm9keS5Xcml0ZXIudCkgLT4gdW5pdFxuXG50eXBlIGVycm9yX2NvZGUgPVxuICB8IE5vX2Vycm9yXG4gIHwgRXJyb3Igb2ZcbiAgICB7IHJlcXVlc3Q6IFJlcXVlc3QudCBvcHRpb25cbiAgICA7IG11dGFibGUgcmVzcG9uc2Vfc3RhdGU6IFJlc3BvbnNlX3N0YXRlLnRcbiAgICB9XG5cbnR5cGUgdCA9XG4gIHsgcmVhZGVyICAgICAgICAgICAgICAgICA6IFJlYWRlci5yZXF1ZXN0XG4gIDsgd3JpdGVyICAgICAgICAgICAgICAgICA6IFdyaXRlci50XG4gIDsgcmVzcG9uc2VfYm9keV9idWZmZXIgICA6IEJpZ3N0cmluZ2FmLnRcbiAgOyByZXF1ZXN0X2hhbmRsZXIgICAgICAgIDogcmVxdWVzdF9oYW5kbGVyXG4gIDsgZXJyb3JfaGFuZGxlciAgICAgICAgICA6IGVycm9yX2hhbmRsZXJcbiAgOyByZXF1ZXN0X3F1ZXVlICAgICAgICAgIDogUmVxZC50IFF1ZXVlLnRcbiAgICAoKiBpbnZhcmlhbnQ6IElmIFtyZXF1ZXN0X3F1ZXVlXSBpcyBub3QgZW1wdHksIHRoZW4gdGhlIGhlYWQgb2YgdGhlIHF1ZXVlXG4gICAgICAgaGFzIGFscmVhZHkgaGFkIFtyZXF1ZXN0X2hhbmRsZXJdIGNhbGxlZCBvbiBpdC4gKilcbiAgOyBtdXRhYmxlIGVycm9yX2NvZGUgOiBlcnJvcl9jb2RlXG4gICAgKCogUmVwcmVzZW50cyBhbiB1bnJlY292ZXJhYmxlIGVycm9yIHRoYXQgd2lsbCBjYXVzZSB0aGUgY29ubmVjdGlvbiB0b1xuICAgICAqIHNodXRkb3duLiBIb2xkcyBvbiB0byB0aGUgcmVzcG9uc2UgYm9keSBjcmVhdGVkIGJ5IHRoZSBlcnJvciBoYW5kbGVyXG4gICAgICogdGhhdCBtaWdodCBiZSBzdHJlYW1pbmcgdG8gdGhlIGNsaWVudC4gKilcbiAgfVxuXG5sZXQgaXNfY2xvc2VkIHQgPVxuICBSZWFkZXIuaXNfY2xvc2VkIHQucmVhZGVyICYmIFdyaXRlci5pc19jbG9zZWQgdC53cml0ZXJcblxubGV0IGlzX2FjdGl2ZSB0ID1cbiAgbm90IChRdWV1ZS5pc19lbXB0eSB0LnJlcXVlc3RfcXVldWUpXG5cbmxldCBjdXJyZW50X3JlcWRfZXhuIHQgPVxuICBRdWV1ZS5wZWVrIHQucmVxdWVzdF9xdWV1ZVxuXG5sZXQgeWllbGRfcmVhZGVyIHQgayA9XG4gIFJlYWRlci5vbl93YWtldXAgdC5yZWFkZXIga1xuXG5sZXQgd2FrZXVwX3JlYWRlciB0ID1cbiAgaWYgaXNfYWN0aXZlIHQgdGhlbiBiZWdpblxuICAgIGxldCByZXFkID0gY3VycmVudF9yZXFkX2V4biB0IGluXG4gICAgKCogQmVmb3JlIGdvaW5nIHRocm91Z2ggYW5vdGhlciByZWFkIGxvb3AsIGdpdmUgdGhlIGJvZHkgYSBjaGFuY2UgdG8gZmx1c2hcbiAgICAgICBpdHMgYnVmZmVyZWQgYnl0ZXMgdG8gdGhlIGFwcGxpY2F0aW9uLiBUaGlzIGZpeGVzIGEgcGF0aG9sb2dpY2FsIGNhc2VcbiAgICAgICB3aGVyZSB0aGUgYm9keSBjb3VsZCBidWZmZXIgdG9vIG11Y2ggd2l0aG91dCBhIGNoYW5jZSBvZiBleGVjdXRpbmdcbiAgICAgICBzY2hlZHVsZWQgcmVhZHMuICopXG4gICAgUmVxZC5mbHVzaF9yZXF1ZXN0X2JvZHkgcmVxZDtcbiAgZW5kO1xuICBSZWFkZXIud2FrZXVwIHQucmVhZGVyXG5cbmxldCB5aWVsZF93cml0ZXIgdCBrID1cbiBXcml0ZXIub25fd2FrZXVwIHQud3JpdGVyIGtcbjs7XG5cbmxldCB3YWtldXBfd3JpdGVyIHQgPSBXcml0ZXIud2FrZXVwIHQud3JpdGVyXG5cbmxldCBkZWZhdWx0X2Vycm9yX2hhbmRsZXIgP3JlcXVlc3Q6XyBlcnJvciBoYW5kbGUgPVxuICBsZXQgbWVzc2FnZSA9XG4gICAgbWF0Y2ggZXJyb3Igd2l0aFxuICAgIHwgYEV4biBleG4gLT4gUHJpbnRleGMudG9fc3RyaW5nIGV4blxuICAgIHwgKCNTdGF0dXMuY2xpZW50X2Vycm9yIHwgI1N0YXR1cy5zZXJ2ZXJfZXJyb3IpIGFzIGVycm9yIC0+IFN0YXR1cy50b19zdHJpbmcgZXJyb3JcbiAgaW5cbiAgbGV0IGJvZHkgPSBoYW5kbGUgSGVhZGVycy5lbXB0eSBpblxuICBCb2R5LldyaXRlci53cml0ZV9zdHJpbmcgYm9keSBtZXNzYWdlO1xuICBCb2R5LldyaXRlci5jbG9zZSBib2R5XG47O1xuXG5sZXQgY3JlYXRlID8oY29uZmlnPUNvbmZpZy5kZWZhdWx0KSA/KGVycm9yX2hhbmRsZXI9ZGVmYXVsdF9lcnJvcl9oYW5kbGVyKSByZXF1ZXN0X2hhbmRsZXIgPVxuICBsZXRcbiAgICB7IENvbmZpZ1xuICAgIC4gcmVzcG9uc2VfYnVmZmVyX3NpemVcbiAgICA7IHJlc3BvbnNlX2JvZHlfYnVmZmVyX3NpemVcbiAgICA7IF8gfSA9IGNvbmZpZ1xuICBpblxuICBsZXQgd3JpdGVyID0gV3JpdGVyLmNyZWF0ZSB+YnVmZmVyX3NpemU6cmVzcG9uc2VfYnVmZmVyX3NpemUgKCkgaW5cbiAgbGV0IHJlcXVlc3RfcXVldWUgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IHJlc3BvbnNlX2JvZHlfYnVmZmVyID0gQmlnc3RyaW5nYWYuY3JlYXRlIHJlc3BvbnNlX2JvZHlfYnVmZmVyX3NpemUgaW5cbiAgbGV0IHJlYyByZWFkZXIgPSBsYXp5IChSZWFkZXIucmVxdWVzdCB+d2FrZXVwOihmdW4gKCkgLT4gd2FrZXVwX3JlYWRlciAoTGF6eS5mb3JjZSB0KSkgaGFuZGxlcilcbiAgYW5kIGhhbmRsZXIgcmVxdWVzdCByZXF1ZXN0X2JvZHkgPVxuICAgIGxldCByZXFkID1cbiAgICAgIFJlcWQuY3JlYXRlIGVycm9yX2hhbmRsZXIgcmVxdWVzdCByZXF1ZXN0X2JvZHkgKExhenkuZm9yY2UgcmVhZGVyKSB3cml0ZXIgcmVzcG9uc2VfYm9keV9idWZmZXJcbiAgICBpblxuICAgIGxldCBjYWxsX2hhbmRsZXIgPSBRdWV1ZS5pc19lbXB0eSByZXF1ZXN0X3F1ZXVlIGluXG4gICAgUXVldWUucHVzaCByZXFkIHJlcXVlc3RfcXVldWU7XG4gICAgaWYgY2FsbF9oYW5kbGVyXG4gICAgdGhlbiByZXF1ZXN0X2hhbmRsZXIgcmVxZDtcblxuICBhbmQgdCA9IGxhenlcbiAgICB7IHJlYWRlciA9IExhenkuZm9yY2UgcmVhZGVyXG4gICAgOyB3cml0ZXJcbiAgICA7IHJlc3BvbnNlX2JvZHlfYnVmZmVyXG4gICAgOyByZXF1ZXN0X2hhbmRsZXIgPSByZXF1ZXN0X2hhbmRsZXJcbiAgICA7IGVycm9yX2hhbmRsZXIgICA9IGVycm9yX2hhbmRsZXJcbiAgICA7IHJlcXVlc3RfcXVldWVcbiAgICA7IGVycm9yX2NvZGUgPSBOb19lcnJvclxuICAgIH1cbiAgaW5cbiAgTGF6eS5mb3JjZSB0XG5cbmxldCBzaHV0ZG93bl9yZWFkZXIgdCA9XG4gIGlmIGlzX2FjdGl2ZSB0XG4gIHRoZW4gUmVxZC5jbG9zZV9yZXF1ZXN0X2JvZHkgKGN1cnJlbnRfcmVxZF9leG4gdCk7XG4gIFJlYWRlci5mb3JjZV9jbG9zZSB0LnJlYWRlcjtcbiAgd2FrZXVwX3JlYWRlciB0XG5cbmxldCBzaHV0ZG93bl93cml0ZXIgdCA9XG4gIGlmIGlzX2FjdGl2ZSB0IHRoZW4gKFxuICAgIGxldCByZXFkID0gY3VycmVudF9yZXFkX2V4biB0IGluXG4gICAgKCogWFhYKGRwYXR0aSk6IEknbSBub3Qgc3VyZSBJIHVuZGVyc3RhbmQgd2h5IHdlIGNsb3NlIHRoZSAqcmVxdWVzdCogYm9keVxuICAgICAgIGhlcmUuIE1heWJlIHdlIGNhbiB3cml0ZSBhIHRlc3Qgc3VjaCB0aGF0IHJlbW92aW5nIHRoaXMgbGluZSBjYXVzZXMgaXQgdG9cbiAgICAgICBmYWlsPyAqKVxuICAgIFJlcWQuY2xvc2VfcmVxdWVzdF9ib2R5IHJlcWQ7XG4gICAgUmVxZC5mbHVzaF9yZXNwb25zZV9ib2R5IHJlcWQpO1xuICBXcml0ZXIuY2xvc2UgdC53cml0ZXI7XG4gIHdha2V1cF93cml0ZXIgdFxuXG5sZXQgZXJyb3JfY29kZSB0ID1cbiAgaWYgaXNfYWN0aXZlIHRcbiAgdGhlbiBSZXFkLmVycm9yX2NvZGUgKGN1cnJlbnRfcmVxZF9leG4gdClcbiAgZWxzZSBOb25lXG5cbmxldCBzaHV0ZG93biB0ID1cbiAgc2h1dGRvd25fcmVhZGVyIHQ7XG4gIHNodXRkb3duX3dyaXRlciB0XG5cbmxldCBzZXRfZXJyb3JfYW5kX2hhbmRsZSA/cmVxdWVzdCB0IGVycm9yID1cbiAgaWYgaXNfYWN0aXZlIHQgdGhlbiBiZWdpblxuICAgIGFzc2VydCAocmVxdWVzdCA9IE5vbmUpO1xuICAgIGxldCByZXFkID0gY3VycmVudF9yZXFkX2V4biB0IGluXG4gICAgUmVxZC5yZXBvcnRfZXJyb3IgcmVxZCBlcnJvclxuICBlbmQgZWxzZSBiZWdpblxuICAgIGxldCBzdGF0dXMgPVxuICAgICAgbWF0Y2ggKGVycm9yIDo+IFtlcnJvciB8IFN0YXR1cy5zdGFuZGFyZF0pIHdpdGhcbiAgICAgIHwgYEV4biBfICAgICAgICAgICAgICAgICAgICAgLT4gYEludGVybmFsX3NlcnZlcl9lcnJvclxuICAgICAgfCAjU3RhdHVzLnN0YW5kYXJkIGFzIHN0YXR1cyAtPiBzdGF0dXNcbiAgICBpblxuICAgIHNodXRkb3duX3JlYWRlciB0O1xuICAgIGxldCB3cml0ZXIgPSB0LndyaXRlciBpblxuICAgIG1hdGNoIHQuZXJyb3JfY29kZSB3aXRoXG4gICAgfCBOb19lcnJvciAtPlxuICAgICAgdC5lcnJvcl9jb2RlIDwtIEVycm9yIHsgcmVxdWVzdDsgcmVzcG9uc2Vfc3RhdGUgPSBXYWl0aW5nIH07XG4gICAgICB0LmVycm9yX2hhbmRsZXIgP3JlcXVlc3QgZXJyb3IgKGZ1biBoZWFkZXJzIC0+XG4gICAgICAgICAgbGV0IHJlc3BvbnNlID0gUmVzcG9uc2UuY3JlYXRlIH5oZWFkZXJzIHN0YXR1cyBpblxuICAgICAgICAgIGxldCBlbmNvZGluZyA9XG4gICAgICAgICAgICAoKiBJZiB3ZSBoYXZlbid0IHBhcnNlZCB0aGUgcmVxdWVzdCBtZXRob2QsIGp1c3QgdXNlIEdFVCBhcyBhIHN0YW5kYXJkXG4gICAgICAgICAgICAgICBwbGFjZWhvbGRlci4gVGhlIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVkZ2UgY2FzZXMsIGxpa2UgSEVBRCBvclxuICAgICAgICAgICAgICAgQ09OTkVDVC4gKilcbiAgICAgICAgICAgIGxldCByZXF1ZXN0X21ldGhvZCA9XG4gICAgICAgICAgICAgIG1hdGNoIHJlcXVlc3Qgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gYEdFVFxuICAgICAgICAgICAgICB8IFNvbWUgKHJlcXVlc3Q6IFJlcXVlc3QudCkgLT4gcmVxdWVzdC5tZXRoXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbWF0Y2ggUmVzcG9uc2UuYm9keV9sZW5ndGggfnJlcXVlc3RfbWV0aG9kIHJlc3BvbnNlIHdpdGhcbiAgICAgICAgICAgIHwgYEZpeGVkIF8gfCBgQ2xvc2VfZGVsaW1pdGVkIHwgYENodW5rZWQgYXMgZW5jb2RpbmcgLT4gZW5jb2RpbmdcbiAgICAgICAgICAgIHwgYEVycm9yIChgQmFkX2dhdGV3YXkgfCBgSW50ZXJuYWxfc2VydmVyX2Vycm9yKSAtPlxuICAgICAgICAgICAgICBmYWlsd2l0aCBcImh0dHBhZi5TZXJ2ZXJfY29ubmVjdGlvbi5lcnJvcl9oYW5kbGVyOiBpbnZhbGlkIHJlc3BvbnNlIGJvZHkgbGVuZ3RoXCJcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCByZXNwb25zZV9ib2R5ID1cbiAgICAgICAgICAgICgqIFRoZSAoc2hhcmVkKSByZXNwb25zZSBib2R5IGJ1ZmZlciBjYW4gYmUgdXNlZCBpbiB0aGlzIGNhc2VcbiAgICAgICAgICAgICAqIGJlY2F1c2UgaW4gdGhpcyBjb25kaXRpb25hbCBicmFuY2ggd2UncmUgbm90IHNlbmRpbmcgYSByZXNwb25zZVxuICAgICAgICAgICAgICogKGlzX2FjdGl2ZSB0ID09IGZhbHNlKSwgYW5kIGFyZSB0aGVyZWZvcmUgbm90IG1ha2luZyB1c2Ugb2YgdGhhdFxuICAgICAgICAgICAgICogYnVmZmVyLiAqKVxuXG4gICAgICAgICAgICBCb2R5LldyaXRlci5jcmVhdGVcbiAgICAgICAgICAgICAgdC5yZXNwb25zZV9ib2R5X2J1ZmZlclxuICAgICAgICAgICAgICB+ZW5jb2RpbmcgfndyaXRlcjp0LndyaXRlclxuICAgICAgICAgIGluXG4gICAgICAgICAgV3JpdGVyLndyaXRlX3Jlc3BvbnNlIHdyaXRlciByZXNwb25zZTtcbiAgICAgICAgICB0LmVycm9yX2NvZGUgPC0gRXJyb3IgeyByZXF1ZXN0OyByZXNwb25zZV9zdGF0ZSA9IFN0cmVhbWluZyhyZXNwb25zZSwgcmVzcG9uc2VfYm9keSkgfTtcbiAgICAgICAgICB3YWtldXBfd3JpdGVyIHQ7XG4gICAgICAgICAgcmVzcG9uc2VfYm9keSlcbiAgICB8IEVycm9yIF8gLT5cbiAgICAgICgqIFdoZW4gcmVhZGluZywgdGhpcyBzaG91bGQgYmUgaW1wb3NzaWJsZTogZXZlbiBpZiB3ZSB0cnkgdG8gcmVhZCBtb3JlLFxuICAgICAgICogdGhlIHBhcnNlciBkb2VzIG5vdCBpbmdlc3QgaXQsIGFuZCBldmVuIGlmIHNvbWVvbmUgYXR0ZW1wdHMgdG8gZmVlZFxuICAgICAgICogbW9yZSBieXRlcyB0byB0aGUgcGFyc2VyIHdoZW4gd2UgYWxyZWFkeSB0b2xkIHRoZW0gdG8gW2BDbG9zZV0sIHRoYXQnc1xuICAgICAgICogcmVhbGx5IHRoZWlyIG93biBmYXVsdC5cbiAgICAgICAqXG4gICAgICAgKiBXZSBkbywgaG93ZXZlciwgbmVlZCB0byBoYW5kbGUgdGhpcyBjYXNlIGlmIGFueSBvdGhlciBleGNlcHRpb24gaXNcbiAgICAgICAqIHJlcG9ydGVkICh3ZSdyZSBhbHJlYWR5IGhhbmRsaW5nIGFuIGVycm9yIGFuZCBlLmcuIHRoZSB3cml0aW5nIGNoYW5uZWxcbiAgICAgICAqIGlzIGNsb3NlZCkuIEp1c3Qgc2h1dCBkb3duIHRoZSBjb25uZWN0aW9uIGluIHRoYXQgY2FzZS5cbiAgICAgICAqKVxuICAgICAgV3JpdGVyLmNsb3NlX2FuZF9kcmFpbiB0LndyaXRlcjtcbiAgICAgIHNodXRkb3duIHRcbiAgZW5kXG5cbmxldCByZXBvcnRfZXhuIHQgZXhuID1cbiAgc2V0X2Vycm9yX2FuZF9oYW5kbGUgdCAoYEV4biBleG4pXG5cbmxldCBhZHZhbmNlX3JlcXVlc3RfcXVldWUgdCA9XG4gIGlnbm9yZSAoUXVldWUudGFrZSB0LnJlcXVlc3RfcXVldWUpO1xuICBpZiBub3QgKFF1ZXVlLmlzX2VtcHR5IHQucmVxdWVzdF9xdWV1ZSlcbiAgdGhlbiB0LnJlcXVlc3RfaGFuZGxlciAoUXVldWUucGVlayB0LnJlcXVlc3RfcXVldWUpO1xuOztcblxubGV0IHJlYyBfbmV4dF9yZWFkX29wZXJhdGlvbiB0ID1cbiAgaWYgbm90IChpc19hY3RpdmUgdCkgdGhlbiAoXG4gICAgbGV0IG5leHQgPSBSZWFkZXIubmV4dCB0LnJlYWRlciBpblxuICAgIGJlZ2luIG1hdGNoIG5leHQgd2l0aFxuICAgIHwgYEVycm9yIF8gLT5cbiAgICAgICgqIERvbid0IHRlYXIgZG93biB0aGUgd2hvbGUgY29ubmVjdGlvbiBpZiB3ZSBzYXcgYW4gdW5yZWNvdmVyYWJsZVxuICAgICAgICogcGFyc2luZyBlcnJvciwgYXMgd2UgbWlnaHQgYmUgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RyZWFtaW5nIGJhY2sgdGhlXG4gICAgICAgKiBlcnJvciByZXNwb25zZSBib2R5IHRvIHRoZSBjbGllbnQuICopXG4gICAgICBzaHV0ZG93bl9yZWFkZXIgdFxuICAgIHwgYENsb3NlIC0+XG4gICAgICAobWF0Y2ggdC5lcnJvcl9jb2RlIHdpdGhcbiAgICAgIHwgTm9fZXJyb3IgLT4gc2h1dGRvd24gdFxuICAgICAgfCBFcnJvciBfIC0+ICgpKVxuICAgIHwgXyAtPiAoKVxuICAgIGVuZDtcbiAgICBuZXh0XG4gICkgZWxzZSAoXG4gICAgbGV0IHJlcWQgPSBjdXJyZW50X3JlcWRfZXhuIHQgaW5cbiAgICBtYXRjaCBSZXFkLmlucHV0X3N0YXRlIHJlcWQgd2l0aFxuICAgIHwgV2FpdCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggUmVxZC5vdXRwdXRfc3RhdGUgcmVxZCB3aXRoXG4gICAgICB8IENvbXBsZXRlIC0+XG4gICAgICAgICgqIHRoaXMgYnJhbmNoIGhhcHBlbnMgaWYgdGhlIHdyaXRlciBoYXMgY29tcGxldGVkIHNlbmRpbmcgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgIGFuZCB0aGVyZSBhcmUgc3RpbGwgYnl0ZXMgcmVtYWluaW5nIHRvIGJlIHJlYWQgaW4gdGhlIHJlcXVlc3QgYm9keS5cbiAgICAgICAgICopXG4gICAgICAgIFJlYWRlci5uZXh0IHQucmVhZGVyXG4gICAgICB8IFdhaXRpbmcgfCBSZWFkeSAtPlxuICAgICAgICAoKiBgV2FpdGAgc2lnbmFscyB0aGF0IHdlIHNob3VsZCBhZGQgYmFja3ByZXNzdXJlIHRvIHRoZSByZWFkIGNoYW5uZWwsXG4gICAgICAgICAqIG1lYW5pbmcgdGhlIHJlYWRlciBzaG91bGQgdGVsbCB0aGUgcnVudGltZSB0byB5aWVsZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGV4Y2VwdGlvbiBoZXJlIGlzIGlmIHRoZXJlIGhhcyBiZWVuIGFuIGVycm9yIGluIHRoZSBwYXJzZXI7IGluXG4gICAgICAgICAqIHRoYXQgY2FzZSwgd2UgbmVlZCB0byByZXR1cm4gdGhhdCBleGNlcHRpb24gYW5kIHNpZ25hbCB0aGUgcnVudGltZSB0b1xuICAgICAgICAgKiBjbG9zZS4gKilcbiAgICAgICAgYmVnaW4gbWF0Y2ggUmVhZGVyLm5leHQgdC5yZWFkZXIgd2l0aFxuICAgICAgICB8IGBFcnJvciBfIGFzIG9wZXJhdGlvbiAtPiBvcGVyYXRpb25cbiAgICAgICAgfCBfIC0+IGBZaWVsZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIHwgUmVhZHkgLT4gUmVhZGVyLm5leHQgdC5yZWFkZXJcbiAgICB8IENvbXBsZXRlIC0+IF9maW5hbF9yZWFkX29wZXJhdGlvbl9mb3IgdCByZXFkXG4gIClcblxuYW5kIF9maW5hbF9yZWFkX29wZXJhdGlvbl9mb3IgdCByZXFkID1cbiAgaWYgUmVhZGVyLmlzX2Nsb3NlZCB0LnJlYWRlciB8fCBub3QgKFJlcWQucGVyc2lzdGVudF9jb25uZWN0aW9uIHJlcWQpIHRoZW4gKFxuICAgIHNodXRkb3duX3JlYWRlciB0O1xuICAgIFJlYWRlci5uZXh0IHQucmVhZGVyO1xuICApIGVsc2VcbiAgICBtYXRjaCBSZXFkLm91dHB1dF9zdGF0ZSByZXFkIHdpdGhcbiAgICB8IFdhaXRpbmcgfCBSZWFkeSAtPiBgWWllbGRcbiAgICB8IENvbXBsZXRlICAgICAgIC0+XG4gICAgICAoKiBUaGUgXCJmaW5hbCByZWFkXCIgb3BlcmF0aW9uIGZvciBhIHJlcXVlc3QgZGVzY3JpcHRvciB0aGF0IGlzXG4gICAgICAgKiBgQ29tcGxldGVgIGZyb20gYm90aCBpbnB1dCBhbmQgb3V0cHV0IHBlcnNwZWN0aXZlcyBuZWVkcyB0byBhY2NvdW50XG4gICAgICAgKiBmb3IgdGhlIGZhY3QgdGhhdCB0aGUgcmVhZGVyIG1heSBub3QgaGF2ZSBmaW5pc2hlZCByZWFkaW5nIHRoZVxuICAgICAgICogcmVxdWVzdCBib2R5LlxuICAgICAgICogSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBkb24ndCBhZHZhbmNlIHRoZSByZXF1ZXN0IHF1ZXVlIGluIHRoaXMgY2FzZVxuICAgICAgICogZm9yIHBlcnNpc3RlbnQgY29ubmVjdGlvbnMsIG9yIHdlJ2QgYnJlYWsgdGhlIGludmFyaWFudCB0aGF0IGFcbiAgICAgICAqIG5vbi1lbXB0eSBgcmVxdWVzdF9xdWV1ZWAgaGFzIGhhZCB0aGUgcmVxdWVzdCBoYW5kbGVyIGNhbGxlZCBvbiBpdHNcbiAgICAgICAqIGhlYWQgZWxlbWVudC4gKilcbiAgICAgICBtYXRjaCBSZWFkZXIubmV4dCB0LnJlYWRlciB3aXRoXG4gICAgICAgfCBgRXJyb3IgXyBhcyBvcCAtPlxuICAgICAgICAgKCogS2VlcCByZWFkaW5nIHdoZW4gaW4gYSBcInBhcnRpYWxcIiBzdGF0ZSAoYFJlYWQpLlxuICAgICAgICAgICogRG9uJ3QgYWR2YW5jZSB0aGUgcmVxdWVzdCBxdWV1ZSBpZiBpbiBhbiBlcnJvciBzdGF0ZS4gKilcbiAgICAgICAgIG9wXG4gICAgICAgfCBgUmVhZCBhcyBvcCAtPlxuICAgICAgICAgKCogd2UganVzdCBkb24ndCBhZHZhbmNlIHRoZSByZXF1ZXN0IHF1ZXVlIGluIHRoZSBjYXNlIG9mIGEgcGFyc2VyXG4gICAgICAgICAgIGVycm9yLiAqKVxuICAgICAgICAgYWR2YW5jZV9yZXF1ZXN0X3F1ZXVlIHQ7XG4gICAgICAgICBvcFxuICAgICAgIHwgXyAtPlxuICAgICAgICAgYWR2YW5jZV9yZXF1ZXN0X3F1ZXVlIHQ7XG4gICAgICAgICBfbmV4dF9yZWFkX29wZXJhdGlvbiB0XG5cbmxldCBuZXh0X3JlYWRfb3BlcmF0aW9uIHQgPVxuICBtYXRjaCBfbmV4dF9yZWFkX29wZXJhdGlvbiB0IHdpdGhcbiAgfCBgRXJyb3IgKGBQYXJzZSBfKSAgICAgICAgICAgICAtPiBzZXRfZXJyb3JfYW5kX2hhbmRsZSAgICAgICAgICB0IGBCYWRfcmVxdWVzdDsgYENsb3NlXG4gIHwgYEVycm9yIChgQmFkX3JlcXVlc3QgcmVxdWVzdCkgLT4gc2V0X2Vycm9yX2FuZF9oYW5kbGUgfnJlcXVlc3QgdCBgQmFkX3JlcXVlc3Q7IGBDbG9zZVxuICB8IGBTdGFydCB8IGBSZWFkIC0+IGBSZWFkXG4gIHwgKGBZaWVsZCB8IGBDbG9zZSkgYXMgb3BlcmF0aW9uIC0+IG9wZXJhdGlvblxuXG5sZXQgcmVhZF93aXRoX21vcmUgdCBicyB+b2ZmIH5sZW4gbW9yZSA9XG4gIGxldCBjb25zdW1lZCA9IFJlYWRlci5yZWFkX3dpdGhfbW9yZSB0LnJlYWRlciBicyB+b2ZmIH5sZW4gbW9yZSBpblxuICBpZiBpc19hY3RpdmUgdFxuICB0aGVuIChcbiAgICBsZXQgcmVxZCA9IGN1cnJlbnRfcmVxZF9leG4gdCBpblxuICAgIFJlcWQuZmx1c2hfcmVxdWVzdF9ib2R5IHJlcWQ7XG4gICk7XG4gIGNvbnN1bWVkXG47O1xuXG5sZXQgcmVhZCB0IGJzIH5vZmYgfmxlbiA9XG4gIHJlYWRfd2l0aF9tb3JlIHQgYnMgfm9mZiB+bGVuIEluY29tcGxldGVcblxubGV0IHJlYWRfZW9mIHQgYnMgfm9mZiB+bGVuID1cbiAgcmVhZF93aXRoX21vcmUgdCBicyB+b2ZmIH5sZW4gQ29tcGxldGVcblxubGV0IGZsdXNoX3Jlc3BvbnNlX2Vycm9yX2JvZHkgcmVzcG9uc2Vfc3RhdGUgPVxuICBSZXNwb25zZV9zdGF0ZS5mbHVzaF9yZXNwb25zZV9ib2R5IHJlc3BvbnNlX3N0YXRlXG5cbmxldCByZWMgX25leHRfd3JpdGVfb3BlcmF0aW9uIHQgPVxuICBpZiBub3QgKGlzX2FjdGl2ZSB0KSB0aGVuIChcbiAgICBtYXRjaCB0LmVycm9yX2NvZGUgd2l0aFxuICAgIHwgTm9fZXJyb3IgLT5cbiAgICAgIGlmIFJlYWRlci5pc19jbG9zZWQgdC5yZWFkZXJcbiAgICAgIHRoZW4gc2h1dGRvd24gdDtcbiAgICAgIFdyaXRlci5uZXh0IHQud3JpdGVyXG4gICAgfCBFcnJvciB7IHJlc3BvbnNlX3N0YXRlOyBfIH0gLT5cbiAgICAgIG1hdGNoIFJlc3BvbnNlX3N0YXRlLm91dHB1dF9zdGF0ZSByZXNwb25zZV9zdGF0ZSB3aXRoXG4gICAgICB8IFdhaXRpbmcgLT4gYFlpZWxkXG4gICAgICB8IFJlYWR5IC0+XG4gICAgICAgIGZsdXNoX3Jlc3BvbnNlX2Vycm9yX2JvZHkgcmVzcG9uc2Vfc3RhdGU7XG4gICAgICAgIFdyaXRlci5uZXh0IHQud3JpdGVyXG4gICAgICB8IENvbXBsZXRlIC0+XG4gICAgICAgIHNodXRkb3duX3dyaXRlciB0O1xuICAgICAgICBXcml0ZXIubmV4dCB0LndyaXRlclxuICApIGVsc2UgKFxuICAgIGxldCByZXFkID0gY3VycmVudF9yZXFkX2V4biB0IGluXG4gICAgbWF0Y2ggUmVxZC5vdXRwdXRfc3RhdGUgcmVxZCB3aXRoXG4gICAgfCBXYWl0aW5nIC0+IFdyaXRlci5uZXh0IHQud3JpdGVyXG4gICAgfCBSZWFkeSAtPlxuICAgICAgUmVxZC5mbHVzaF9yZXNwb25zZV9ib2R5IHJlcWQ7XG4gICAgICBXcml0ZXIubmV4dCB0LndyaXRlclxuICAgIHwgQ29tcGxldGUgLT4gX2ZpbmFsX3dyaXRlX29wZXJhdGlvbl9mb3IgdCByZXFkXG4gIClcblxuYW5kIF9maW5hbF93cml0ZV9vcGVyYXRpb25fZm9yIHQgcmVxZCA9XG4gIGlmIG5vdCAoUmVxZC5wZXJzaXN0ZW50X2Nvbm5lY3Rpb24gcmVxZCkgdGhlbiAoXG4gICAgc2h1dGRvd25fd3JpdGVyIHQ7XG4gICAgd2FrZXVwX3JlYWRlciB0O1xuICAgIFdyaXRlci5uZXh0IHQud3JpdGVyO1xuICApIGVsc2UgKFxuICAgIG1hdGNoIFJlcWQuaW5wdXRfc3RhdGUgcmVxZCB3aXRoXG4gICAgfCBXYWl0IC0+XG4gICAgICB3YWtldXBfcmVhZGVyIHQ7XG4gICAgICBXcml0ZXIubmV4dCB0LndyaXRlclxuICAgIHwgUmVhZHkgLT5cbiAgICAgICgqIHdlIGNhbid0IGNsb3NlIHRoZSByZXF1ZXN0IGJvZHkgaGVyZSwgb3RoZXJ3aXNlIHRoZSByZWFkZXIgbG9vcCBpc1xuICAgICAgICAgZ29pbmcgdG8gdGhpbmsgdGhhdCBpdHMgXCJpbnB1dCBzdGF0ZVwiIGlzIGNvbXBsZXRlLCBhbmQgcmVtb3ZlIHRoZVxuICAgICAgICAgcmVxdWVzdCBkZXNjcmlwdG9yIGZyb20gdGhlIHJlcXVlc3QgcXVldWUsIHdoZW4gaW4gZmFjdCBpdCBuZWVkcyB0b1xuICAgICAgICAgcmVhZCB0aGUgcmVtYWluZGVyIG9mIHRoZSByZXF1ZXN0IGJvZHkuIEl0IG5lZWRzIHRvIGhhbmcgYXJvdW5kXG4gICAgICAgICBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIGEgc3VkZGVuIEVPRiB3aGlsZSBkaXNjYXJkaW5nIHRoZSByZXF1ZXN0IGJvZHksXG4gICAgICAgICB3aGljaCB3ZSBuZWVkIHRvIGhhbmRsZS4gKilcbiAgICAgIHdha2V1cF9yZWFkZXIgdDtcbiAgICAgIFdyaXRlci5uZXh0IHQud3JpdGVyXG4gICAgfCBDb21wbGV0ZSAtPlxuICAgICAgIG1hdGNoIFJlYWRlci5uZXh0IHQucmVhZGVyIHdpdGhcbiAgICAgICB8IGBFcnJvciBfIC0+IFdyaXRlci5uZXh0IHQud3JpdGVyXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBhZHZhbmNlX3JlcXVlc3RfcXVldWUgdDtcbiAgICAgICAgIHdha2V1cF9yZWFkZXIgdDtcbiAgICAgICAgIF9uZXh0X3dyaXRlX29wZXJhdGlvbiB0XG4gIClcbjs7XG5cbmxldCBuZXh0X3dyaXRlX29wZXJhdGlvbiB0ID0gX25leHRfd3JpdGVfb3BlcmF0aW9uIHRcblxubGV0IHJlcG9ydF93cml0ZV9yZXN1bHQgdCByZXN1bHQgPVxuICBXcml0ZXIucmVwb3J0X3Jlc3VsdCB0LndyaXRlciByZXN1bHRcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNy0yMDE5IEluaGFiaXRlZCBUeXBlIExMQy5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTkgQW50b25pbyBOdW5vIE1vbnRlaXJvLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbm1vZHVsZSBSZWFkZXIgPSBQYXJzZS5SZWFkZXJcbm1vZHVsZSBXcml0ZXIgPSBTZXJpYWxpemUuV3JpdGVyXG5cbnR5cGUgZXJyb3IgPVxuICBbIGBNYWxmb3JtZWRfcmVzcG9uc2Ugb2Ygc3RyaW5nIHwgYEludmFsaWRfcmVzcG9uc2VfYm9keV9sZW5ndGggb2YgUmVzcG9uc2UudCB8IGBFeG4gb2YgZXhuIF1cblxudHlwZSByZXNwb25zZV9oYW5kbGVyID0gUmVzcG9uc2UudCAtPiBCb2R5LlJlYWRlci50ICAtPiB1bml0XG50eXBlIGVycm9yX2hhbmRsZXIgPSBlcnJvciAtPiB1bml0XG5cbnR5cGUgdCA9XG4gIHsgY29uZmlnIDogQ29uZmlnLnRcbiAgOyByZWFkZXIgOiBSZWFkZXIucmVzcG9uc2VcbiAgOyB3cml0ZXIgOiBXcml0ZXIudFxuICA7IHJlcXVlc3RfcXVldWUgOiBSZXNwZC50IFF1ZXVlLnRcbiAgICAoKiBpbnZhcmlhbnQ6IElmIFtyZXF1ZXN0X3F1ZXVlXSBpcyBub3QgZW1wdHksIHRoZW4gdGhlIGhlYWQgb2YgdGhlIHF1ZXVlXG4gICAgICAgaGFzIGFscmVhZHkgd3JpdHRlbiB0aGUgcmVxdWVzdCBoZWFkZXJzIHRvIHRoZSB3aXJlLiAqKVxuICB9XG5cbmxldCBpc19jbG9zZWQgdCA9XG4gIFJlYWRlci5pc19jbG9zZWQgdC5yZWFkZXIgJiYgV3JpdGVyLmlzX2Nsb3NlZCB0LndyaXRlclxuXG5sZXQgaXNfd2FpdGluZyB0ID1cbiAgbm90IChpc19jbG9zZWQgdCkgJiYgUXVldWUuaXNfZW1wdHkgdC5yZXF1ZXN0X3F1ZXVlXG5cbmxldCBpc19hY3RpdmUgdCA9XG4gIG5vdCAoUXVldWUuaXNfZW1wdHkgdC5yZXF1ZXN0X3F1ZXVlKVxuXG5sZXQgY3VycmVudF9yZXNwZF9leG4gdCA9XG4gIFF1ZXVlLnBlZWsgdC5yZXF1ZXN0X3F1ZXVlXG5cbmxldCB5aWVsZF9yZWFkZXIgdCBrID0gUmVhZGVyLm9uX3dha2V1cCB0LnJlYWRlciBrXG5cbmxldCB3YWtldXBfcmVhZGVyIHQgPSBSZWFkZXIud2FrZXVwIHQucmVhZGVyXG5cbmxldCB5aWVsZF93cml0ZXIgdCBrID0gV3JpdGVyLm9uX3dha2V1cCB0LndyaXRlciBrXG5cbmxldCB3YWtldXBfd3JpdGVyIHQgPSBXcml0ZXIud2FrZXVwIHQud3JpdGVyXG5cbmxldCBjcmVhdGUgPyhjb25maWc9Q29uZmlnLmRlZmF1bHQpICgpID1cbiAgbGV0IHJlcXVlc3RfcXVldWUgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgeyBjb25maWdcbiAgOyByZWFkZXIgPSBSZWFkZXIucmVzcG9uc2UgcmVxdWVzdF9xdWV1ZVxuICA7IHdyaXRlciA9IFdyaXRlci5jcmVhdGUgKClcbiAgOyByZXF1ZXN0X3F1ZXVlXG4gIH1cblxubGV0IGNyZWF0ZV9yZXF1ZXN0X2JvZHkgfnJlcXVlc3QgdCA9XG4gIG1hdGNoIFJlcXVlc3QuYm9keV9sZW5ndGggcmVxdWVzdCB3aXRoXG4gIHwgYEZpeGVkIDBMIC0+IEJvZHkuV3JpdGVyLmNyZWF0ZV9lbXB0eSB+d3JpdGVyOnQud3JpdGVyXG4gIHwgYEZpeGVkIF8gfCBgQ2h1bmtlZCBhcyBlbmNvZGluZyAtPlxuICAgIEJvZHkuV3JpdGVyLmNyZWF0ZVxuICAgICAgKEJpZ3N0cmluZ2FmLmNyZWF0ZSB0LmNvbmZpZy5yZXF1ZXN0X2JvZHlfYnVmZmVyX3NpemUpXG4gICAgICB+ZW5jb2RpbmdcbiAgICAgIH53cml0ZXI6dC53cml0ZXJcbiAgfCBgRXJyb3IgYEJhZF9yZXF1ZXN0IC0+XG4gICAgZmFpbHdpdGggXCJIdHRwYWYuQ2xpZW50X2Nvbm5lY3Rpb24ucmVxdWVzdDogaW52YWxpZCBib2R5IGxlbmd0aFwiXG5cbmxldCByZXF1ZXN0IHQgPyhmbHVzaF9oZWFkZXJzX2ltbWVkaWF0ZWx5PWZhbHNlKSByZXF1ZXN0IH5lcnJvcl9oYW5kbGVyIH5yZXNwb25zZV9oYW5kbGVyID1cbiAgbGV0IHJlcXVlc3RfYm9keSA9IGNyZWF0ZV9yZXF1ZXN0X2JvZHkgfnJlcXVlc3QgdCBpblxuICBsZXQgcmVzcGQgPVxuICAgIFJlc3BkLmNyZWF0ZSBlcnJvcl9oYW5kbGVyIHJlcXVlc3QgcmVxdWVzdF9ib2R5IHQud3JpdGVyIHJlc3BvbnNlX2hhbmRsZXIgaW5cbiAgbGV0IGhhbmRsZV9ub3cgPSBRdWV1ZS5pc19lbXB0eSB0LnJlcXVlc3RfcXVldWUgaW5cbiAgUXVldWUucHVzaCByZXNwZCB0LnJlcXVlc3RfcXVldWU7XG4gIGlmIGhhbmRsZV9ub3cgdGhlblxuICAgIFJlc3BkLndyaXRlX3JlcXVlc3QgcmVzcGQ7XG5cbiAgaWYgbm90IGZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHlcbiAgdGhlbiBXcml0ZXIueWllbGQgdC53cml0ZXI7XG5cbiAgKCogTm90IGhhbmRsaW5nIHRoZSByZXF1ZXN0IG5vdyBtZWFucyBpdCBtYXkgYmUgcGlwZWxpbmVkLlxuICAgKiBgYWR2YW5jZV9yZXF1ZXN0X3F1ZXVlX2lmX25lY2Vzc2FyeWAgd2lsbCB0YWtlIGNhcmUgb2YgaXQsIGJ1dCB3ZSBzdGlsbFxuICAgKiB3YW5uYSB3YWtlIHVwIHRoZSB3cml0ZXIgc28gdGhhdCB0aGUgZnVuY3Rpb24gZ2V0cyBjYWxsZWQuICopXG4gIHdha2V1cF93cml0ZXIgdDtcbiAgcmVxdWVzdF9ib2R5XG47O1xuXG5sZXQgc2h1dGRvd25fcmVhZGVyIHQgPVxuICBpZiBpc19hY3RpdmUgdFxuICB0aGVuIFJlc3BkLmNsb3NlX3Jlc3BvbnNlX2JvZHkgKGN1cnJlbnRfcmVzcGRfZXhuIHQpO1xuICBSZWFkZXIuZm9yY2VfY2xvc2UgdC5yZWFkZXI7XG4gIHdha2V1cF9yZWFkZXIgdFxuXG5sZXQgc2h1dGRvd25fd3JpdGVyIHQgPVxuICBpZiBpc19hY3RpdmUgdFxuICB0aGVuIFJlc3BkLmNsb3NlX3JlcXVlc3RfYm9keSAoY3VycmVudF9yZXNwZF9leG4gdCk7XG4gIFdyaXRlci5jbG9zZSB0LndyaXRlcjtcbiAgd2FrZXVwX3dyaXRlciB0XG5cbmxldCBzaHV0ZG93biB0ID1cbiAgc2h1dGRvd25fcmVhZGVyIHQ7XG4gIHNodXRkb3duX3dyaXRlciB0XG5cbmxldCBzZXRfZXJyb3JfYW5kX2hhbmRsZSB0IGVycm9yID1cbiAgUXVldWUuaXRlciAoZnVuIHJlc3BkIC0+XG4gICBtYXRjaCBSZXNwZC5pbnB1dF9zdGF0ZSByZXNwZCB3aXRoXG4gICB8IFdhaXQgfCBSZWFkeSAtPlxuICAgICBSZXNwZC5yZXBvcnRfZXJyb3IgcmVzcGQgZXJyb3JcbiAgIHwgQ29tcGxldGUgLT5cbiAgICAgbWF0Y2ggUmVhZGVyLm5leHQgdC5yZWFkZXIgd2l0aFxuICAgICB8IGBFcnJvciBfIHwgYFJlYWQgLT5cbiAgICAgICBSZXNwZC5yZXBvcnRfZXJyb3IgcmVzcGQgZXJyb3JcbiAgICAgfCBfIC0+XG4gICAgICAgKCogRG9uJ3QgYm90aGVyIHJlcG9ydGluZyBlcnJvcnMgdG8gcmVzcG9uc2VzIHRoYXQgaGF2ZSBhbHJlYWR5XG4gICAgICAgICogY29tcGxldGVkLiAqKVxuICAgICAgICgpKVxuICB0LnJlcXVlc3RfcXVldWU7XG4gICgqIEZyb20gUkZDNzIzMMKnNi41OlxuICAgKiAgIEEgY2xpZW50IHNlbmRpbmcgYSBtZXNzYWdlIGJvZHkgU0hPVUxEIG1vbml0b3IgdGhlIG5ldHdvcmsgY29ubmVjdGlvblxuICAgKiAgIGZvciBhbiBlcnJvciByZXNwb25zZSB3aGlsZSBpdCBpcyB0cmFuc21pdHRpbmcgdGhlIHJlcXVlc3QuICBJZiB0aGVcbiAgICogICBjbGllbnQgc2VlcyBhIHJlc3BvbnNlIHRoYXQgaW5kaWNhdGVzIHRoZSBzZXJ2ZXIgZG9lcyBub3Qgd2lzaCB0b1xuICAgKiAgIHJlY2VpdmUgdGhlIG1lc3NhZ2UgYm9keSBhbmQgaXMgY2xvc2luZyB0aGUgY29ubmVjdGlvbiwgdGhlIGNsaWVudFxuICAgKiAgIFNIT1VMRCBpbW1lZGlhdGVseSBjZWFzZSB0cmFuc21pdHRpbmcgdGhlIGJvZHkgYW5kIGNsb3NlIGl0cyBzaWRlIG9mIHRoZVxuICAgKiAgIGNvbm5lY3Rpb24uICopXG4gIHNodXRkb3duIHQ7XG47O1xuXG5sZXQgdW5leHBlY3RlZF9lb2YgdCA9XG4gIHNldF9lcnJvcl9hbmRfaGFuZGxlIHQgKGBNYWxmb3JtZWRfcmVzcG9uc2UgXCJ1bmV4cGVjdGVkIGVvZlwiKTtcbjs7XG5cbmxldCByZXBvcnRfZXhuIHQgZXhuID1cbiAgc2V0X2Vycm9yX2FuZF9oYW5kbGUgdCAoYEV4biBleG4pXG47O1xuXG5leGNlcHRpb24gTG9jYWxcblxubGV0IG1heWJlX3BpcGVsaW5lX3F1ZXVlZF9yZXF1ZXN0cyB0ID1cbiAgKCogRG9uJ3QgYm90aGVyIHRyeWluZyB0byBwaXBlbGluZSBpZiB0aGVyZSBhcmVuJ3QgbXVsdGlwbGUgcmVxdWVzdHMgaW4gdGhlXG4gICAqIHF1ZXVlLiAqKVxuICBpZiBRdWV1ZS5sZW5ndGggdC5yZXF1ZXN0X3F1ZXVlID4gMSB0aGVuXG4gICAgdHJ5XG4gICAgICBsZXQgXyA9IFF1ZXVlLmZvbGQgKGZ1biBwcmV2IHJlc3BkIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIHByZXYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIHByZXYgLT5cbiAgICAgICAgICBtYXRjaCByZXNwZC5SZXNwZC5zdGF0ZSwgUmVzcGQub3V0cHV0X3N0YXRlIHByZXYgd2l0aFxuICAgICAgICAgIHwgVW5pbml0aWFsaXplZCwgQ29tcGxldGUgLT5cbiAgICAgICAgICAgIFJlc3BkLndyaXRlX3JlcXVlc3QgcmVzcGQ7XG4gICAgICAgICAgICBSZXNwZC5mbHVzaF9yZXF1ZXN0X2JvZHkgcmVzcGRcbiAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICgqIGJhaWwgZWFybHkuIElmIHdlIGNhbid0IHBpcGVsaW5lIHRoaXMgcmVxdWVzdCwgd2UgY2FuJ3Qgd3JpdGVcbiAgICAgICAgICAgICAqIG5leHQgb25lcyBlaXRoZXIuICopXG4gICAgICAgICAgICByYWlzZSBMb2NhbFxuICAgICAgICBlbmQ7XG4gICAgICAgIFNvbWUgcmVzcGQpXG4gICAgICAgIE5vbmVcbiAgICAgICAgdC5yZXF1ZXN0X3F1ZXVlXG4gICAgICBpbiAoKVxuICAgIHdpdGhcbiAgICB8IF8gLT4gKClcblxubGV0IGFkdmFuY2VfcmVxdWVzdF9xdWV1ZSB0ID1cbiAgaWdub3JlIChRdWV1ZS50YWtlIHQucmVxdWVzdF9xdWV1ZSk7XG4gIGlmIG5vdCAoUXVldWUuaXNfZW1wdHkgdC5yZXF1ZXN0X3F1ZXVlKSB0aGVuIGJlZ2luXG4gICAgKCogd3JpdGUgcmVxdWVzdCB0byB0aGUgd2lyZSAqKVxuICAgIGxldCByZXNwZCA9IGN1cnJlbnRfcmVzcGRfZXhuIHQgaW5cbiAgICBtYXRjaCByZXNwZC5zdGF0ZSB3aXRoXG4gICAgfCBVbmluaXRpYWxpemVkIC0+XG4gICAgICAoKiBPbmx5IHdyaXRlIHJlcXVlc3QgaWYgaXQgaGFzbid0IGJlZW4gd3JpdHRlbiB0byB0aGUgd2lyZSB5ZXQgKGUuZy4gdmlhXG4gICAgICAgKiBwaXBlbGluaW5nKS4gKilcbiAgICAgIFJlc3BkLndyaXRlX3JlcXVlc3QgcmVzcGQ7XG4gICAgICB3YWtldXBfd3JpdGVyIHRcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cbmxldCByZWMgX25leHRfcmVhZF9vcGVyYXRpb24gdCA9XG4gIGlmIG5vdCAoaXNfYWN0aXZlIHQpIHRoZW4gKFxuICAgIGlmIFJlYWRlci5pc19jbG9zZWQgdC5yZWFkZXJcbiAgICB0aGVuIHNodXRkb3duIHQ7XG4gICAgUmVhZGVyLm5leHQgdC5yZWFkZXJcbiAgKSBlbHNlIChcbiAgICBsZXQgcmVzcGQgPSBjdXJyZW50X3Jlc3BkX2V4biB0IGluXG4gICAgbWF0Y2ggUmVzcGQuaW5wdXRfc3RhdGUgcmVzcGQgd2l0aFxuICAgIHwgV2FpdCAtPiBgWWllbGRcbiAgICB8IFJlYWR5ICAtPiBSZWFkZXIubmV4dCB0LnJlYWRlclxuICAgIHwgQ29tcGxldGUgLT4gX2ZpbmFsX3JlYWRfb3BlcmF0aW9uX2ZvciB0IHJlc3BkXG4gIClcblxuYW5kIF9maW5hbF9yZWFkX29wZXJhdGlvbl9mb3IgdCByZXNwZCA9XG4gIGxldCBuZXh0ID1cbiAgICBpZiBub3QgKFJlc3BkLnBlcnNpc3RlbnRfY29ubmVjdGlvbiByZXNwZCkgdGhlbiAoXG4gICAgICBzaHV0ZG93bl9yZWFkZXIgdDtcbiAgICAgIFJlYWRlci5uZXh0IHQucmVhZGVyO1xuICAgICkgZWxzZSAoXG4gICAgICBtYXRjaCBSZXNwZC5vdXRwdXRfc3RhdGUgcmVzcGQgd2l0aFxuICAgICAgfCBXYWl0aW5nIHwgUmVhZHkgLT4gYFlpZWxkXG4gICAgICB8IENvbXBsZXRlICAgICAgIC0+XG4gICAgICAgICBtYXRjaCBSZWFkZXIubmV4dCB0LnJlYWRlciB3aXRoXG4gICAgICAgICB8IGBFcnJvciBfIHwgYFJlYWQgYXMgb3BlcmF0aW9uIC0+XG4gICAgICAgICAgICgqIEtlZXAgcmVhZGluZyB3aGVuIGluIGEgXCJwYXJ0aWFsXCIgc3RhdGUgKGBSZWFkKS5cbiAgICAgICAgICAgICogRG9uJ3QgYWR2YW5jZSB0aGUgcmVxdWVzdCBxdWV1ZSBpZiBpbiBhbiBlcnJvciBzdGF0ZS4gKilcbiAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgYWR2YW5jZV9yZXF1ZXN0X3F1ZXVlIHQ7XG4gICAgICAgICAgIF9uZXh0X3JlYWRfb3BlcmF0aW9uIHQ7XG4gICAgKVxuICBpblxuICB3YWtldXBfd3JpdGVyIHQ7XG4gIG5leHRcbjs7XG5cbmxldCBuZXh0X3JlYWRfb3BlcmF0aW9uIHQgPVxuICBtYXRjaCBfbmV4dF9yZWFkX29wZXJhdGlvbiB0IHdpdGhcbiAgfCBgRXJyb3IgKGBQYXJzZShtYXJrcywgbWVzc2FnZSkpIC0+XG4gICAgbGV0IG1lc3NhZ2UgPSBTdHJpbmcuY29uY2F0IFwiXCIgWyBTdHJpbmcuY29uY2F0IFwiPlwiIG1hcmtzOyBcIjogXCI7IG1lc3NhZ2VdIGluXG4gICAgc2V0X2Vycm9yX2FuZF9oYW5kbGUgdCAoYE1hbGZvcm1lZF9yZXNwb25zZSBtZXNzYWdlKTtcbiAgICBgQ2xvc2VcbiAgfCBgRXJyb3IgKGBJbnZhbGlkX3Jlc3BvbnNlX2JvZHlfbGVuZ3RoIF8gYXMgZXJyb3IpIC0+XG4gICAgc2V0X2Vycm9yX2FuZF9oYW5kbGUgdCBlcnJvcjtcbiAgICBgQ2xvc2VcbiAgfCBgU3RhcnQgLT4gYFJlYWRcbiAgfCAoYFJlYWQgfCBgWWllbGQgfCBgQ2xvc2UpIGFzIG9wZXJhdGlvbiAtPiBvcGVyYXRpb25cbjs7XG5cbmxldCByZWFkX3dpdGhfbW9yZSB0IGJzIH5vZmYgfmxlbiBtb3JlID1cbiAgbGV0IGNvbnN1bWVkID0gUmVhZGVyLnJlYWRfd2l0aF9tb3JlIHQucmVhZGVyIGJzIH5vZmYgfmxlbiBtb3JlIGluXG4gIGlmIGlzX2FjdGl2ZSB0IHRoZW5cbiAgICBSZXNwZC5mbHVzaF9yZXNwb25zZV9ib2R5IChjdXJyZW50X3Jlc3BkX2V4biB0KTtcbiAgY29uc3VtZWRcbjs7XG5cbmxldCByZWFkIHQgYnMgfm9mZiB+bGVuID1cbiAgcmVhZF93aXRoX21vcmUgdCBicyB+b2ZmIH5sZW4gSW5jb21wbGV0ZVxuXG5sZXQgcmVhZF9lb2YgdCBicyB+b2ZmIH5sZW4gPVxuICBsZXQgYnl0ZXNfcmVhZCA9IHJlYWRfd2l0aF9tb3JlIHQgYnMgfm9mZiB+bGVuIENvbXBsZXRlIGluXG4gIGlmIGlzX2FjdGl2ZSB0XG4gIHRoZW4gdW5leHBlY3RlZF9lb2YgdDtcbiAgYnl0ZXNfcmVhZFxuOztcblxubGV0IHJlYyBfbmV4dF93cml0ZV9vcGVyYXRpb24gdCA9XG4gIGlmIG5vdCAoaXNfYWN0aXZlIHQpIHRoZW4gKFxuICAgIGlmIFJlYWRlci5pc19jbG9zZWQgdC5yZWFkZXJcbiAgICB0aGVuIHNodXRkb3duIHQ7XG4gICAgV3JpdGVyLm5leHQgdC53cml0ZXJcbiAgKSBlbHNlIChcbiAgICBsZXQgcmVzcGQgPSBjdXJyZW50X3Jlc3BkX2V4biB0IGluXG4gICAgbWF0Y2ggUmVzcGQub3V0cHV0X3N0YXRlIHJlc3BkIHdpdGhcbiAgICB8IFdhaXRpbmcgLT4gYFlpZWxkXG4gICAgfCBSZWFkeSAtPlxuICAgICAgUmVzcGQuZmx1c2hfcmVxdWVzdF9ib2R5IHJlc3BkO1xuICAgICAgV3JpdGVyLm5leHQgdC53cml0ZXJcbiAgICB8IENvbXBsZXRlIC0+IF9maW5hbF93cml0ZV9vcGVyYXRpb25fZm9yIHQgcmVzcGRcbiAgKVxuXG5hbmQgX2ZpbmFsX3dyaXRlX29wZXJhdGlvbl9mb3IgdCByZXNwZCA9XG4gIGlmIG5vdCAoUmVzcGQucGVyc2lzdGVudF9jb25uZWN0aW9uIHJlc3BkKSB0aGVuIChcbiAgICBzaHV0ZG93bl93cml0ZXIgdDtcbiAgICBXcml0ZXIubmV4dCB0LndyaXRlcjtcbiAgKSBlbHNlIChcbiAgICAoKiBGcm9tIFJGQzcyMzDCpzYuMy4yOlxuICAgICAqICAgQSBjbGllbnQgdGhhdCBzdXBwb3J0cyBwZXJzaXN0ZW50IGNvbm5lY3Rpb25zIE1BWSBcInBpcGVsaW5lXCIgaXRzXG4gICAgICogICByZXF1ZXN0cyAoaS5lLiwgc2VuZCBtdWx0aXBsZSByZXF1ZXN0cyB3aXRob3V0IHdhaXRpbmcgZm9yIGVhY2hcbiAgICAgKiAgIHJlc3BvbnNlKS4gKilcbiAgICBtYXliZV9waXBlbGluZV9xdWV1ZWRfcmVxdWVzdHMgdDtcbiAgICBtYXRjaCBSZXNwZC5pbnB1dF9zdGF0ZSByZXNwZCB3aXRoXG4gICAgfCBXYWl0IHwgUmVhZHkgLT5cbiAgICAgIHdha2V1cF9yZWFkZXIgdDtcbiAgICAgIFdyaXRlci5uZXh0IHQud3JpdGVyO1xuICAgIHwgQ29tcGxldGUgLT5cbiAgICAgICBtYXRjaCBSZWFkZXIubmV4dCB0LnJlYWRlciB3aXRoXG4gICAgICAgfCBgRXJyb3IgXyAtPiBXcml0ZXIubmV4dCB0LndyaXRlclxuICAgICAgIHwgXyAtPlxuICAgICAgICAgYWR2YW5jZV9yZXF1ZXN0X3F1ZXVlIHQ7XG4gICAgICAgICB3YWtldXBfcmVhZGVyIHQ7XG4gICAgICAgICBfbmV4dF93cml0ZV9vcGVyYXRpb24gdFxuICApXG47O1xuXG5sZXQgbmV4dF93cml0ZV9vcGVyYXRpb24gdCA9IF9uZXh0X3dyaXRlX29wZXJhdGlvbiB0XG5cbmxldCByZXBvcnRfd3JpdGVfcmVzdWx0IHQgcmVzdWx0ID1cbiAgV3JpdGVyLnJlcG9ydF9yZXN1bHQgdC53cml0ZXIgcmVzdWx0XG4iXX0=
