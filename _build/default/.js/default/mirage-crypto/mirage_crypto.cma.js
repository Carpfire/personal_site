// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Mirage_crypto__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Mirage_crypto = [0];
   runtime.caml_register_global(0, Mirage_crypto, "Mirage_crypto__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto__Native
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    AES = [0],
    DES = [0],
    Chacha = [0],
    Poly1305 = [0],
    GHASH = [0];
   runtime.mc_detect_cpu_features(0);
   runtime.mc_entropy_detect(0);
   var Mirage_crypto_Native = [0, AES, DES, Chacha, Poly1305, GHASH];
   runtime.caml_register_global
    (0, Mirage_crypto_Native, "Mirage_crypto__Native");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto__Uncommon
//# unitInfo: Requires: Mirage_crypto__Native, Stdlib, Stdlib__Bytes, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Mirage_crypto = "Mirage_crypto: ",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Format = global_data.Stdlib__Format,
    _b_ = [0, "src/uncommon.ml", 24, 2],
    _a_ = [0, [11, cst_Mirage_crypto, 0], cst_Mirage_crypto];
   function kasprintf(k, fmt){
    var _d_ = Stdlib_Format[117];
    function _e_(param){
     return caml_call1(k, caml_call1(Stdlib_Format[119], 0));
    }
    return caml_call3(Stdlib_Format[144], _e_, _d_, fmt);
   }
   function invalid_arg(fmt){
    var _c_ = caml_call2(Stdlib[98], _a_, fmt);
    return kasprintf(Stdlib[1], _c_);
   }
   function symbol(x, y){
    if(1 <= y) return 0 < x ? 1 + runtime.caml_div(x - 1 | 0, y) | 0 : 0;
    throw caml_maybe_attach_backtrace(Stdlib[13], 1);
   }
   function imin(a, b){return a < b ? a : b;}
   function imax(a, b){return a < b ? b : a;}
   function iter2(a, b, f){caml_call1(f, a); return caml_call1(f, b);}
   function iter3(a, b, c, f){
    caml_call1(f, a);
    caml_call1(f, b);
    return caml_call1(f, c);
   }
   function unsafe_xor_into(src, src_off, dst, dst_off, n){
    return runtime.mc_xor_into_bytes(src, src_off, dst, dst_off, n);
   }
   function xor(a, b){
    if(caml_ml_string_length(a) !== caml_ml_string_length(b))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var b$0 = caml_call1(Stdlib_Bytes[5], b);
    runtime.mc_xor_into_bytes(a, 0, b$0, 0, runtime.caml_ml_bytes_length(b$0));
    return caml_call1(Stdlib_Bytes[44], b$0);
   }
   var
    Mirage_crypto_Uncommon =
      [0,
       kasprintf,
       invalid_arg,
       symbol,
       imin,
       imax,
       iter2,
       iter3,
       unsafe_xor_into,
       xor];
   runtime.caml_register_global
    (6, Mirage_crypto_Uncommon, "Mirage_crypto__Uncommon");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto__Poly1305
//# unitInfo: Requires: Mirage_crypto__Native, Mirage_crypto__Uncommon, Stdlib, Stdlib__Bytes, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_off = " - off ",
    cst_0 = " < 0",
    cst_len = " < len ",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Mirage_crypto_Uncommon = global_data.Mirage_crypto__Uncommon,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    mac_size = runtime.mc_poly1305_mac_size(0),
    dup = Stdlib_Bytes[4],
    _c_ =
      [0,
       [11, "Poly1305: d off ", [4, 12, 0, 0, [11, cst_0, 0]]],
       "Poly1305: d off %u < 0"],
    _d_ =
      [0,
       [11,
        "Poly1305: d length ",
        [4,
         12,
         0,
         0,
         [11, cst_off, [4, 12, 0, 0, [11, cst_len, [4, 12, 0, 0, 0]]]]]],
       "Poly1305: d length %u - off %u < len %u"],
    _a_ =
      [0,
       [11,
        "Poly1305: dst length ",
        [4,
         12,
         0,
         0,
         [11, cst_off, [4, 12, 0, 0, [11, cst_len, [4, 12, 0, 0, 0]]]]]],
       "Poly1305: dst length %u - off %u < len %u"],
    _b_ =
      [0,
       [11, "Poly1305: dst_off ", [4, 12, 0, 0, [11, cst_0, 0]]],
       "Poly1305: dst_off %u < 0"],
    cst_Poly1305_key_must_be_32_by = "Poly1305 key must be 32 bytes";
   function empty(key){
    var ctx = caml_create_bytes(runtime.mc_poly1305_ctx_size(0));
    if(32 !== caml_ml_string_length(key))
     caml_call1(Stdlib[1], cst_Poly1305_key_must_be_32_by);
    runtime.mc_poly1305_init(ctx, key);
    return ctx;
   }
   function update(ctx, data){
    return runtime.mc_poly1305_update
            (ctx, data, 0, caml_ml_string_length(data));
   }
   function feed(ctx, cs){
    var t = caml_call1(dup, ctx);
    update(t, cs);
    return t;
   }
   function feedi(ctx, iter){
    var t = caml_call1(dup, ctx);
    caml_call1(iter, function(_g_){return update(t, _g_);});
    return t;
   }
   function final$0(ctx){
    var res = caml_create_bytes(mac_size);
    runtime.mc_poly1305_finalize(ctx, res, 0);
    return caml_call1(Stdlib_Bytes[44], res);
   }
   function get(ctx){return final$0(caml_call1(dup, ctx));}
   function mac(key, data){return final$0(feed(empty(key), data));}
   function maci(key, iter){return final$0(feedi(empty(key), iter));}
   function unsafe_mac_into(key, datas, dst, dst_off){
    var ctx = empty(key);
    function _f_(param){
     var len = param[3], off = param[2], d = param[1];
     return runtime.mc_poly1305_update(ctx, d, off, len);
    }
    caml_call2(Stdlib_List[18], _f_, datas);
    return runtime.mc_poly1305_finalize(ctx, dst, dst_off);
   }
   function mac_into(key, datas, dst, dst_off){
    if((caml_ml_bytes_length(dst) - dst_off | 0) < mac_size)
     caml_call4
      (Mirage_crypto_Uncommon[2],
       _a_,
       caml_ml_bytes_length(dst),
       dst_off,
       mac_size);
    if(dst_off < 0) caml_call2(Mirage_crypto_Uncommon[2], _b_, dst_off);
    var ctx = empty(key);
    function _e_(param){
     var len = param[3], off = param[2], d = param[1];
     if(off < 0) caml_call2(Mirage_crypto_Uncommon[2], _c_, off);
     if((caml_ml_string_length(d) - off | 0) < len)
      caml_call4
       (Mirage_crypto_Uncommon[2], _d_, caml_ml_string_length(d), off, len);
     return runtime.mc_poly1305_update(ctx, d, off, len);
    }
    caml_call2(Stdlib_List[18], _e_, datas);
    return runtime.mc_poly1305_finalize(ctx, dst, dst_off);
   }
   var
    It =
      [0,
       mac_size,
       empty,
       feed,
       feedi,
       get,
       mac,
       maci,
       mac_into,
       unsafe_mac_into],
    Mirage_crypto_Poly1305 = [0, It];
   runtime.caml_register_global
    (9, Mirage_crypto_Poly1305, "Mirage_crypto__Poly1305");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto__Aead
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Mirage_crypto_Aead = [0];
   runtime.caml_register_global(0, Mirage_crypto_Aead, "Mirage_crypto__Aead");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto__Ccm
//# unitInfo: Requires: Eqaf, Mirage_crypto__Uncommon, Stdlib__Bytes, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_blit_string = runtime.caml_blit_string,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fill_bytes = runtime.caml_fill_bytes,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Eqaf = global_data.Eqaf,
    Mirage_crypto_Uncommon = global_data.Mirage_crypto__Uncommon,
    Stdlib_Sys = global_data.Stdlib__Sys,
    block_size = 16;
   function flags(bit6, len1, len2){
    return ((bit6 << 6) + (len1 << 3) | 0) + len2 | 0;
   }
   function encode_len(buf, off, size, value){
    var m$1 = size - 1 | 0, num = value, m = m$1;
    for(;;){
     if(0 === m) return caml_call3(Stdlib_Bytes[73], buf, off, num);
     caml_call3(Stdlib_Bytes[73], buf, off + m | 0, num & 255);
     var m$0 = m - 1 | 0, num$0 = num >>> 8 | 0, num = num$0, m = m$0;
    }
   }
   function set_format(buf, opt, nonce, flag_val, value){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    var n = caml_ml_string_length(nonce), small_q = 15 - n | 0;
    caml_call3(Stdlib_Bytes[73], buf, off, flag_val);
    caml_blit_string(nonce, 0, buf, off + 1 | 0, n);
    return encode_len(buf, (off + n | 0) + 1 | 0, small_q, value);
   }
   function gen_adata(a){
    var x = caml_ml_string_length(a);
    a:
    if(x < 65280)
     var
      _c_ = 2,
      set_llen =
        function(buf, off){return caml_call3(Stdlib_Bytes[76], buf, off, x);},
      llen = _c_;
    else{
     if(32 <= Stdlib_Sys[10] && x >= 1){
      var
       set_llen$0 =
         function(buf, off){
          caml_call3(Stdlib_Bytes[76], buf, off, 65535);
          return caml_call3
                  (Stdlib_Bytes[85],
                   buf,
                   off + 2 | 0,
                   runtime.caml_int64_of_int32(x));
         },
       set_llen = set_llen$0,
       llen = 10;
      break a;
     }
     var
      _d_ = 6,
      set_llen =
        function(buf, off){
         caml_call3(Stdlib_Bytes[76], buf, off, 65534);
         return caml_call3(Stdlib_Bytes[82], buf, off + 2 | 0, x);
        },
      llen = _d_;
    }
    var
     leftover = (llen + caml_ml_string_length(a) | 0) % 16 | 0,
     to_pad = 16 - leftover | 0;
    return [0,
            (llen + caml_ml_string_length(a) | 0) + to_pad | 0,
            function(buf, off){
             set_llen(buf, off);
             caml_blit_string
              (a, 0, buf, off + llen | 0, caml_ml_string_length(a));
             return caml_fill_bytes
                     (buf,
                      (off + llen | 0) + caml_ml_string_length(a) | 0,
                      to_pad,
                      0);
            }];
   }
   function gen_ctr(nonce, i){
    var
     n = caml_ml_string_length(nonce),
     small_q = 15 - n | 0,
     flag_val = flags(0, 0, small_q - 1 | 0),
     buf = caml_create_bytes(16);
    set_format(buf, 0, nonce, flag_val, i);
    return buf;
   }
   function prepare_header(nonce, adata, plen, tlen){
    var
     small_q = 15 - caml_ml_string_length(nonce) | 0,
     b6 = 0 === caml_ml_string_length(adata) ? 0 : 1,
     flag_val = flags(b6, (tlen - 2 | 0) / 2 | 0, small_q - 1 | 0);
    if(0 === caml_ml_string_length(adata)){
     var hdr = caml_create_bytes(16);
     set_format(hdr, 0, nonce, flag_val, plen);
     return hdr;
    }
    var
     match = gen_adata(adata),
     set = match[2],
     len = match[1],
     buf = caml_create_bytes(16 + len | 0);
    set_format(buf, 0, nonce, flag_val, plen);
    caml_call2(set, buf, 16);
    return buf;
   }
   function crypto_core_into
   (cipher, mode, key, nonce, adata, src, src_off, dst, dst_off, len){
    var
     cbcheader = prepare_header(nonce, adata, len, block_size),
     small_q = 15 - caml_ml_string_length(nonce) | 0,
     ctr_flag_val = flags(0, 0, small_q - 1 | 0);
    function ctrblock(i, block, dst_off){
     caml_call3(Stdlib_Bytes[73], block, dst_off, ctr_flag_val);
     caml_blit_string
      (nonce, 0, block, dst_off + 1 | 0, caml_ml_string_length(nonce));
     encode_len
      (block,
       (dst_off + caml_ml_string_length(nonce) | 0) + 1 | 0,
       small_q,
       i);
     return caml_call5
             (cipher,
              key,
              caml_call1(Stdlib_Bytes[44], block),
              dst_off,
              block,
              dst_off);
    }
    function cbc(iv, src_off, block, dst_off){
     caml_call5
      (Mirage_crypto_Uncommon[8], iv, src_off, block, dst_off, block_size);
     return caml_call5
             (cipher,
              key,
              caml_call1(Stdlib_Bytes[44], block),
              dst_off,
              block,
              dst_off);
    }
    var
     iv$1 = caml_call2(Stdlib_Bytes[1], block_size, 0),
     iv = iv$1,
     iv_off = 0,
     block_off = 0;
    for(;;){
     if(0 === (caml_ml_bytes_length(cbcheader) - block_off | 0)) break;
     cbc(caml_call1(Stdlib_Bytes[44], iv), iv_off, cbcheader, block_off);
     var
      block_off$0 = block_off + 16 | 0,
      iv = cbcheader,
      iv_off = block_off,
      block_off = block_off$0;
    }
    var
     iv$0 = caml_call3(Stdlib_Bytes[7], iv, iv_off, block_size),
     ctr = 1,
     src_off$0 = src_off,
     dst_off$0 = dst_off,
     len$0 = len;
    for(;;){
     if(mode)
      var cbc_off = dst_off$0, cbcblock = caml_call1(Stdlib_Bytes[44], dst);
     else
      var cbc_off = src_off$0, cbcblock = src;
     if(0 !== len$0){
      if(len$0 >= 16){
       ctrblock(ctr, dst, dst_off$0);
       caml_call5
        (Mirage_crypto_Uncommon[8],
         src,
         src_off$0,
         dst,
         dst_off$0,
         block_size);
       cbc(cbcblock, cbc_off, iv$0, 0);
       var
        len$1 = len$0 - 16 | 0,
        dst_off$1 = dst_off$0 + 16 | 0,
        src_off$1 = src_off$0 + 16 | 0,
        ctr$0 = ctr + 1 | 0,
        ctr = ctr$0,
        src_off$0 = src_off$1,
        dst_off$0 = dst_off$1,
        len$0 = len$1;
       continue;
      }
      var buf = caml_call2(Stdlib_Bytes[1], block_size, 0);
      caml_blit_bytes(dst, dst_off$0, buf, 0, len$0);
      ctrblock(ctr, buf, 0);
      caml_blit_bytes(buf, 0, dst, dst_off$0, len$0);
      caml_call5
       (Mirage_crypto_Uncommon[8], src, src_off$0, dst, dst_off$0, len$0);
      caml_blit_string(cbcblock, cbc_off, buf, 0, len$0);
      caml_fill_bytes(buf, len$0, 16 - len$0 | 0, 0);
      cbc(caml_call1(Stdlib_Bytes[44], buf), 0, iv$0, 0);
     }
     return iv$0;
    }
   }
   function crypto_core(cipher, mode, key, nonce, adata, data){
    var
     datalen = caml_ml_string_length(data),
     dst = caml_create_bytes(datalen),
     t =
       crypto_core_into
        (cipher, mode, key, nonce, adata, data, 0, dst, 0, datalen);
    return [0, dst, t];
   }
   function crypto_t(t, nonce, cipher, key){
    var ctr = gen_ctr(nonce, 0);
    caml_call5(cipher, key, caml_call1(Stdlib_Bytes[44], ctr), 0, ctr, 0);
    var _b_ = caml_call1(Stdlib_Bytes[44], ctr);
    return caml_call5
            (Mirage_crypto_Uncommon[8], _b_, 0, t, 0, caml_ml_bytes_length(t));
   }
   function unsafe_generation_encryption_i
   (cipher, key, nonce, adata, src, src_off, dst, dst_off, tag_off, len){
    var
     t =
       crypto_core_into
        (cipher, 0, key, nonce, adata, src, src_off, dst, dst_off, len);
    crypto_t(t, nonce, cipher, key);
    return caml_blit_bytes(t, 0, dst, tag_off, 16);
   }
   function unsafe_decryption_verification
   (cipher, key, nonce, adata, src, src_off, tag_off, dst, dst_off, len){
    var
     tag = caml_call3(Stdlib_String[16], src, tag_off, block_size),
     t =
       crypto_core_into
        (cipher, 1, key, nonce, adata, src, src_off, dst, dst_off, len);
    crypto_t(t, nonce, cipher, key);
    var _a_ = caml_call1(Stdlib_Bytes[44], t);
    return caml_call2(Eqaf[1], tag, _a_);
   }
   var
    Mirage_crypto_Ccm =
      [0,
       block_size,
       flags,
       encode_len,
       set_format,
       gen_adata,
       gen_ctr,
       prepare_header,
       crypto_core_into,
       crypto_core,
       crypto_t,
       unsafe_generation_encryption_i,
       unsafe_decryption_verification];
   runtime.caml_register_global(5, Mirage_crypto_Ccm, "Mirage_crypto__Ccm");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto__Chacha20
//# unitInfo: Requires: Eqaf, Mirage_crypto__Native, Mirage_crypto__Poly1305, Mirage_crypto__Uncommon, Stdlib, Stdlib__Bytes, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst_dst_off = " - dst_off ",
    cst_src_off = " - src_off ",
    cst_tag_off = " - tag_off ",
    cst_len = " < len ",
    cst_tag_size = " < tag_size ",
    cst_Chacha20_dst_length = "Chacha20: dst length ",
    cst_Chacha20_dst_length_u_dst_ =
      "Chacha20: dst length %u - dst_off %u < len %u",
    cst_Chacha20_src_length = "Chacha20: src length ",
    cst_Chacha20_src_length_u_src_ =
      "Chacha20: src length %u - src_off %u < len %u",
    cst_Counter_too_big_for_IETF_m =
      "Counter too big for IETF mode (32 bit counter)",
    cst_Valid_parameters_are_nonce =
      "Valid parameters are nonce 12 bytes and key 32 bytes (counter 32 bit), or nonce 8 byte and key 16 or 32 bytes (counter 64 bit).",
    cst_expand_32_byte_k$1 = "expand 32-byte k",
    caml_blit_string = runtime.caml_blit_string,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$2,
    cst$0 = cst$2,
    cst = cst$2,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Mirage_crypto_Uncommon = global_data.Mirage_crypto__Uncommon,
    Stdlib_String = global_data.Stdlib__String,
    Eqaf = global_data.Eqaf,
    Mirage_crypto_Poly1305 = global_data.Mirage_crypto__Poly1305,
    _k_ =
      [0,
       [11,
        cst_Chacha20_src_length,
        [4,
         12,
         0,
         0,
         [11, cst_src_off, [4, 12, 0, 0, [11, cst_len, [4, 12, 0, 0, 0]]]]]],
       cst_Chacha20_src_length_u_src_],
    _l_ =
      [0,
       [11,
        cst_Chacha20_dst_length,
        [4,
         12,
         0,
         0,
         [11, cst_dst_off, [4, 12, 0, 0, [11, cst_len, [4, 12, 0, 0, 0]]]]]],
       cst_Chacha20_dst_length_u_dst_],
    _m_ =
      [0,
       [11,
        cst_Chacha20_src_length,
        [4,
         12,
         0,
         0,
         [11,
          cst_tag_off,
          [4, 12, 0, 0, [11, cst_tag_size, [4, 12, 0, 0, 0]]]]]],
       "Chacha20: src length %u - tag_off %u < tag_size %u"],
    _j_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _g_ =
      [0,
       [11,
        cst_Chacha20_src_length,
        [4,
         12,
         0,
         0,
         [11, cst_src_off, [4, 12, 0, 0, [11, cst_len, [4, 12, 0, 0, 0]]]]]],
       cst_Chacha20_src_length_u_src_],
    _h_ =
      [0,
       [11,
        cst_Chacha20_dst_length,
        [4,
         12,
         0,
         0,
         [11, cst_dst_off, [4, 12, 0, 0, [11, cst_len, [4, 12, 0, 0, 0]]]]]],
       cst_Chacha20_dst_length_u_dst_],
    _i_ =
      [0,
       [11,
        cst_Chacha20_dst_length,
        [4,
         12,
         0,
         0,
         [11,
          cst_tag_off,
          [4, 12, 0, 0, [11, cst_tag_size, [4, 12, 0, 0, 0]]]]]],
       "Chacha20: dst length %u - tag_off %u < tag_size %u"],
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _e_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_expand_32_byte_k$0 = cst_expand_32_byte_k$1,
    _d_ =
      [0,
       [11, cst_Counter_too_big_for_IETF_m, 0],
       cst_Counter_too_big_for_IETF_m],
    cst_expand_32_byte_k = cst_expand_32_byte_k$1,
    cst_expand_16_byte_k = "expand 16-byte k",
    _c_ =
      [0,
       [11, cst_Valid_parameters_are_nonce, 0],
       cst_Valid_parameters_are_nonce],
    block = 64;
   function of_secret(a){return a;}
   function chacha20_block(state, idx, key_stream){
    return runtime.mc_chacha_round(10, state, key_stream, idx);
   }
   function init(ctr, key, nonce){
    var ctr_off = 48;
    function set_ctr32(b, v){
     return caml_call3(Stdlib_Bytes[83], b, ctr_off, v);
    }
    function set_ctr64(b, v){
     return caml_call3(Stdlib_Bytes[86], b, ctr_off, v);
    }
    function inc32(b){
     return set_ctr32(b, caml_call2(Stdlib_Bytes[69], b, ctr_off) + 1 | 0);
    }
    function inc64(b){
     return set_ctr64
             (b,
              runtime.caml_int64_add
               (caml_call2(Stdlib_Bytes[72], b, ctr_off), _a_));
    }
    var
     _q_ = caml_ml_string_length(key),
     match = caml_ml_string_length(nonce);
    a:
    {
     var
      match$0 =
        runtime.caml_equal(runtime.caml_int64_shift_right(ctr, 32), _b_);
     if(16 === _q_){
      if(8 === match){
       var
        k = caml_call2(Stdlib[28], key, key),
        _r_ = 56,
        inc = inc64,
        nonce_off = _r_,
        init_ctr = function(b){return set_ctr64(b, ctr);},
        key$0 = k,
        s = cst_expand_16_byte_k;
       break a;
      }
     }
     else if(32 === _q_){
      if(8 === match){
       var
        _t_ = 56,
        inc = inc64,
        nonce_off = _t_,
        init_ctr = function(b){return set_ctr64(b, ctr);},
        key$0 = key,
        s = cst_expand_32_byte_k;
       break a;
      }
      if(12 === match){
       if(match$0){
        var
         ctr$0 = runtime.caml_int64_to_int32(ctr),
         _u_ = 52,
         inc = inc32,
         nonce_off = _u_,
         init_ctr = function(b){return set_ctr32(b, ctr$0);},
         key$0 = key,
         s = cst_expand_32_byte_k$0;
        break a;
       }
       var
        _v_ = caml_call1(Mirage_crypto_Uncommon[2], _d_),
        inc = _v_[5],
        nonce_off = _v_[4],
        init_ctr = _v_[3],
        key$0 = _v_[2],
        s = _v_[1];
       break a;
      }
     }
     var
      _s_ = caml_call1(Mirage_crypto_Uncommon[2], _c_),
      inc$0 = _s_[5],
      nonce_off$0 = _s_[4],
      init_ctr$0 = _s_[3],
      key$1 = _s_[2],
      s$0 = _s_[1],
      inc = inc$0,
      nonce_off = nonce_off$0,
      init_ctr = init_ctr$0,
      key$0 = key$1,
      s = s$0;
    }
    var state = caml_create_bytes(64);
    caml_blit_string(s, 0, state, 0, 16);
    caml_blit_string(key$0, 0, state, 16, 32);
    caml_call1(init_ctr, state);
    caml_blit_string(nonce, 0, state, nonce_off, caml_ml_string_length(nonce));
    return [0, state, inc];
   }
   function crypt_into(key, nonce, ctr, src, src_off, dst, dst_off, len){
    var
     match = init(ctr, key, nonce),
     inc = match[2],
     state = match[1],
     block_count = caml_call2(Mirage_crypto_Uncommon[3], len, block),
     last = len % 64 | 0,
     last_len = 0 === last ? block : last,
     i = 0,
     n = block_count;
    for(;;){
     if(0 === n) return 0;
     if(1 === n){
      if(last_len === 64){
       runtime.mc_chacha_round(10, state, dst, dst_off + i | 0);
       return runtime.mc_xor_into_bytes
               (src, src_off + i | 0, dst, dst_off + i | 0, 64);
      }
      var buf = caml_create_bytes(64);
      runtime.mc_chacha_round(10, state, buf, 0);
      runtime.mc_xor_into_bytes(src, src_off + i | 0, buf, 0, last_len);
      return runtime.caml_blit_bytes(buf, 0, dst, dst_off + i | 0, last_len);
     }
     runtime.mc_chacha_round(10, state, dst, dst_off + i | 0);
     runtime.mc_xor_into_bytes(src, src_off + i | 0, dst, dst_off + i | 0, 64);
     caml_call1(inc, state);
     var n$0 = n - 1 | 0, i$0 = i + 64 | 0, i = i$0, n = n$0;
    }
   }
   function crypt(key, nonce, opt, data){
    if(opt) var sth = opt[1], ctr = sth; else var ctr = _e_;
    var l = caml_ml_string_length(data), res = caml_create_bytes(l);
    crypt_into(key, nonce, ctr, data, 0, res, 0, l);
    return caml_call1(Stdlib_Bytes[44], res);
   }
   var tag_size = Mirage_crypto_Poly1305[1][1];
   function generate_poly1305_key(key, nonce){
    return crypt(key, nonce, 0, caml_call2(Stdlib_String[1], 32, 0));
   }
   function mac_into(key, adata, src, src_off, len, dst, dst_off){
    function pad16(l){
     var len = l % 16 | 0;
     return 0 === len ? cst : caml_call2(Stdlib_String[1], 16 - len | 0, 0);
    }
    var data = caml_create_bytes(16);
    caml_call3
     (Stdlib_Bytes[86],
      data,
      0,
      caml_int64_of_int32(caml_ml_string_length(adata)));
    caml_call3(Stdlib_Bytes[86], data, 8, caml_int64_of_int32(len));
    var
     len_buf = caml_call1(Stdlib_Bytes[44], data),
     p1 = pad16(caml_ml_string_length(adata)),
     p2 = pad16(len);
    return caml_call4
            (Mirage_crypto_Poly1305[1][9],
             key,
             [0,
              [0, adata, 0, caml_ml_string_length(adata)],
              [0,
               [0, p1, 0, caml_ml_string_length(p1)],
               [0,
                [0, src, src_off, len],
                [0,
                 [0, p2, 0, caml_ml_string_length(p2)],
                 [0, [0, len_buf, 0, caml_ml_string_length(len_buf)], 0]]]]],
             dst,
             dst_off);
   }
   function unsafe_authenticate_encrypt_in
   (key, nonce, opt, src, src_off, dst, dst_off, tag_off, len){
    if(opt) var sth = opt[1], adata = sth; else var adata = cst$0;
    var poly1305_key = generate_poly1305_key(key, nonce);
    crypt_into(key, nonce, _f_, src, src_off, dst, dst_off, len);
    return mac_into
            (poly1305_key,
             adata,
             caml_call1(Stdlib_Bytes[44], dst),
             dst_off,
             len,
             dst,
             tag_off);
   }
   function authenticate_encrypt_into
   (key, nonce, adata, src, src_off, dst, dst_off, tag_off, len){
    if((caml_ml_string_length(src) - src_off | 0) < len)
     caml_call4
      (Mirage_crypto_Uncommon[2],
       _g_,
       caml_ml_string_length(src),
       src_off,
       len);
    if((caml_ml_bytes_length(dst) - dst_off | 0) < len)
     caml_call4
      (Mirage_crypto_Uncommon[2],
       _h_,
       caml_ml_bytes_length(dst),
       dst_off,
       len);
    if((caml_ml_bytes_length(dst) - tag_off | 0) < tag_size)
     caml_call4
      (Mirage_crypto_Uncommon[2],
       _i_,
       caml_ml_bytes_length(dst),
       tag_off,
       tag_size);
    return unsafe_authenticate_encrypt_in
            (key, nonce, adata, src, src_off, dst, dst_off, tag_off, len);
   }
   function authenticate_encrypt(key, nonce, adata, data){
    var
     l = caml_ml_string_length(data),
     dst = caml_create_bytes(l + tag_size | 0);
    unsafe_authenticate_encrypt_in(key, nonce, adata, data, 0, dst, 0, l, l);
    return caml_call1(Stdlib_Bytes[44], dst);
   }
   function authenticate_encrypt_tag(key, nonce, adata, data){
    var
     r = authenticate_encrypt(key, nonce, adata, data),
     _p_ =
       caml_call3(Stdlib_String[16], r, caml_ml_string_length(data), tag_size);
    return [0,
            caml_call3(Stdlib_String[16], r, 0, caml_ml_string_length(data)),
            _p_];
   }
   function unsafe_authenticate_decrypt_in
   (key, nonce, opt, src, src_off, tag_off, dst, dst_off, len){
    if(opt) var sth = opt[1], adata = sth; else var adata = cst$1;
    var
     poly1305_key = generate_poly1305_key(key, nonce),
     ctag = caml_create_bytes(tag_size);
    mac_into(poly1305_key, adata, src, src_off, len, ctag, 0);
    crypt_into(key, nonce, _j_, src, src_off, dst, dst_off, len);
    var
     _n_ = caml_call1(Stdlib_Bytes[44], ctag),
     _o_ = caml_call3(Stdlib_String[16], src, tag_off, tag_size);
    return caml_call2(Eqaf[1], _o_, _n_);
   }
   function authenticate_decrypt_into
   (key, nonce, adata, src, src_off, tag_off, dst, dst_off, len){
    if((caml_ml_string_length(src) - src_off | 0) < len)
     caml_call4
      (Mirage_crypto_Uncommon[2],
       _k_,
       caml_ml_string_length(src),
       src_off,
       len);
    if((caml_ml_bytes_length(dst) - dst_off | 0) < len)
     caml_call4
      (Mirage_crypto_Uncommon[2],
       _l_,
       caml_ml_bytes_length(dst),
       dst_off,
       len);
    if((caml_ml_string_length(src) - tag_off | 0) < tag_size)
     caml_call4
      (Mirage_crypto_Uncommon[2],
       _m_,
       caml_ml_string_length(src),
       tag_off,
       tag_size);
    return unsafe_authenticate_decrypt_in
            (key, nonce, adata, src, src_off, tag_off, dst, dst_off, len);
   }
   function authenticate_decrypt(key, nonce, adata, data){
    if(caml_ml_string_length(data) < tag_size) return 0;
    var
     l = caml_ml_string_length(data) - tag_size | 0,
     r = caml_create_bytes(l);
    return unsafe_authenticate_decrypt_in
             (key, nonce, adata, data, 0, l, r, 0, l)
            ? [0, caml_call1(Stdlib_Bytes[44], r)]
            : 0;
   }
   function authenticate_decrypt_tag(key, nonce, adata, tag, data){
    var cdata = caml_call2(Stdlib[28], data, tag);
    return authenticate_decrypt(key, nonce, adata, cdata);
   }
   var
    Mirage_crypto_Chacha20 =
      [0,
       block,
       of_secret,
       chacha20_block,
       init,
       crypt_into,
       crypt,
       tag_size,
       generate_poly1305_key,
       mac_into,
       unsafe_authenticate_encrypt_in,
       authenticate_encrypt_into,
       authenticate_encrypt,
       authenticate_encrypt_tag,
       unsafe_authenticate_decrypt_in,
       authenticate_decrypt_into,
       authenticate_decrypt,
       authenticate_decrypt_tag];
   runtime.caml_register_global
    (26, Mirage_crypto_Chacha20, "Mirage_crypto__Chacha20");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto__Cipher_block
//# unitInfo: Requires: Eqaf, Mirage_crypto__Ccm, Mirage_crypto__Native, Mirage_crypto__Uncommon, Stdlib, Stdlib__Bytes, Stdlib__Int64, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst_not_of_block_size = " not of block size",
    cst$3 = ": ",
    cst_CBC$3 = "CBC",
    cst_CCM$5 = "CCM",
    cst_CTR$2 = "CTR",
    cst_ECB$1 = "ECB",
    cst_GCM$5 = "GCM",
    cst_GCM_invalid_nonce_of_lengt = "GCM: invalid nonce of length 0",
    cst_dst$7 = "dst",
    cst_dst_tag$1 = "dst tag",
    cst_src$7 = "src",
    cst_src_tag$1 = "src tag",
    cst_src_cipher_block_ml = "src/cipher_block.ml",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_div = runtime.caml_div,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_mod = runtime.caml_mod,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call10(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    return (f.l >= 0 ? f.l : f.l = f.length) == 10
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$2,
    cst$0 = cst$2,
    cst = cst$2,
    hi = runtime.caml_int64_create_lo_mi_hi(0, 16776960, 65535),
    lo = runtime.caml_int64_create_lo_mi_hi(16777215, 255, 0),
    Mirage_crypto_Uncommon = global_data.Mirage_crypto__Uncommon,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Mirage_crypto_Ccm = global_data.Mirage_crypto__Ccm,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    Eqaf = global_data.Eqaf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Block = [0],
    _v_ =
      [0,
       [11, "DES.of_secret: key length ", [4, 12, 0, 0, 0]],
       "DES.of_secret: key length %u"],
    _q_ =
      [0,
       [11, "AES.of_secret: key length ", [4, 12, 0, 0, 0]],
       "AES.of_secret: key length %u"],
    cst_src$6 = cst_src$7,
    cst_CCM$2 = cst_CCM$5,
    cst_src_tag$0 = cst_src_tag$1,
    cst_CCM$3 = cst_CCM$5,
    cst_dst$6 = cst_dst$7,
    cst_CCM$4 = cst_CCM$5,
    cst_src$5 = cst_src$7,
    cst_CCM = cst_CCM$5,
    cst_dst$5 = cst_dst$7,
    cst_CCM$0 = cst_CCM$5,
    cst_dst_tag$0 = cst_dst_tag$1,
    cst_CCM$1 = cst_CCM$5,
    _o_ =
      [0,
       [11, "CCM: nonce length not between 7 and 13: ", [4, 12, 0, 0, 0]],
       "CCM: nonce length not between 7 and 13: %u"],
    _p_ = [0, cst_src_cipher_block_ml, 458, 4],
    cst_src$4 = cst_src$7,
    cst_GCM$2 = cst_GCM$5,
    cst_src_tag = cst_src_tag$1,
    cst_GCM$3 = cst_GCM$5,
    cst_dst$4 = cst_dst$7,
    cst_GCM$4 = cst_GCM$5,
    _m_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    cst_src$3 = cst_src$7,
    cst_GCM = cst_GCM$5,
    cst_dst$3 = cst_dst$7,
    cst_GCM$0 = cst_GCM$5,
    cst_dst_tag = cst_dst_tag$1,
    cst_GCM$1 = cst_GCM$5,
    _l_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _k_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _j_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _i_ =
      [0,
       [11, cst_GCM_invalid_nonce_of_lengt, 0],
       cst_GCM_invalid_nonce_of_lengt],
    _n_ = [0, cst_src_cipher_block_ml, 366, 4],
    _h_ = [0, cst_src_cipher_block_ml, 349, 6],
    cst_src$2 = cst_src$7,
    cst_CTR$0 = cst_CTR$2,
    cst_dst$2 = cst_dst$7,
    cst_CTR$1 = cst_CTR$2,
    cst_buf = "buf",
    cst_CTR = cst_CTR$2,
    _g_ = [0, cst_src_cipher_block_ml, 282, 4],
    cst_src$1 = cst_src$7,
    cst_CBC$1 = cst_CBC$3,
    cst_dst$1 = cst_dst$7,
    cst_CBC$2 = cst_CBC$3,
    cst_src$0 = cst_src$7,
    cst_CBC = cst_CBC$3,
    cst_dst$0 = cst_dst$7,
    cst_CBC$0 = cst_CBC$3,
    _e_ =
      [0,
       [11, "CBC: IV length ", [4, 12, 0, 0, [11, cst_not_of_block_size, 0]]],
       "CBC: IV length %u not of block size"],
    _f_ =
      [0,
       [11,
        "CBC: argument length ",
        [4, 12, 0, 0, [11, cst_not_of_block_size, 0]]],
       "CBC: argument length %u not of block size"],
    _d_ =
      [0,
       [11, "ECB: length ", [4, 12, 0, 0, [11, cst_not_of_block_size, 0]]],
       "ECB: length %u not of block size"],
    cst_src = cst_src$7,
    cst_ECB = cst_ECB$1,
    cst_dst = cst_dst$7,
    cst_ECB$0 = cst_ECB$1,
    _b_ =
      [0,
       [2,
        0,
        [11, cst$3, [2, 0, [11, " off ", [4, 12, 0, 0, [11, " < 0", 0]]]]]],
       "%s: %s off %u < 0"],
    _c_ =
      [0,
       [2,
        0,
        [11,
         cst$3,
         [2,
          0,
          [11,
           " length ",
           [4,
            12,
            0,
            0,
            [11, " - off ", [4, 12, 0, 0, [11, " < len ", [4, 12, 0, 0, 0]]]]]]]]],
       "%s: %s length %u - off %u < len %u"],
    _a_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _A_ = [0, 289154965, 0],
    _C_ = [0, 3247855, 0],
    _F_ = [0, 4393851, 0],
    size = 8;
   function of_octets(cs){return caml_call2(Stdlib_String[63], cs, 0);}
   var add = caml_int64_add;
   function unsafe_count_into(t, buf, off, blocks){
    var ctr = caml_create_bytes(8);
    caml_call3(Stdlib_Bytes[85], ctr, 0, t);
    return runtime.mc_count_8_be(ctr, buf, off, blocks);
   }
   var C64be = [0, size, of_octets, add, unsafe_count_into], size$0 = 16;
   function of_octets$0(cs){
    var
     buf = caml_call1(Stdlib_Bytes[45], cs),
     _av_ = caml_call2(Stdlib_Bytes[71], buf, 8);
    return [0, caml_call2(Stdlib_Bytes[71], buf, 0), _av_];
   }
   function add$0(param, n){
    var
     w0 = param[2],
     w1 = param[1],
     w0$0 = caml_int64_add(w0, n),
     flip =
       caml_lessthan(runtime.caml_int64_xor(w0, w0$0), _a_)
        ? runtime.caml_greaterthan(w0$0, w0)
        : caml_lessthan(w0$0, w0),
     _au_ = flip ? caml_call1(Stdlib_Int64[6], w1) : w1;
    return [0, _au_, w0$0];
   }
   function unsafe_count_into$0(param, buf, off, blocks){
    var w0 = param[2], w1 = param[1], ctr = caml_create_bytes(16);
    caml_call3(Stdlib_Bytes[85], ctr, 0, w1);
    caml_call3(Stdlib_Bytes[85], ctr, 8, w0);
    return runtime.mc_count_16_be(ctr, buf, off, blocks);
   }
   var
    C128be = [0, size$0, of_octets$0, add$0, unsafe_count_into$0],
    size$1 = C128be[1],
    of_octets$1 = C128be[2];
   function add$1(param, n){
    var w0 = param[2], w1 = param[1];
    return [0,
            w1,
            runtime.caml_int64_or
             (caml_int64_and(hi, w0),
              caml_int64_and(lo, caml_int64_add(n, w0)))];
   }
   function unsafe_count_into$1(param, buf, off, blocks){
    var w0 = param[2], w1 = param[1], ctr = caml_create_bytes(16);
    caml_call3(Stdlib_Bytes[85], ctr, 0, w1);
    caml_call3(Stdlib_Bytes[85], ctr, 8, w0);
    return runtime.mc_count_16_be_4(ctr, buf, off, blocks);
   }
   var
    C128be32 = [0, size$1, of_octets$1, add$1, unsafe_count_into$1],
    Counters = [0, C64be, C128be, C128be32];
   function check_offset(tag, buf, off, len, actual_len){
    if(off < 0) caml_call4(Mirage_crypto_Uncommon[2], _b_, tag, buf, off);
    var _at_ = (actual_len - off | 0) < len ? 1 : 0;
    return _at_
            ? caml_call6
              (Mirage_crypto_Uncommon[2], _c_, tag, buf, actual_len, off, len)
            : _at_;
   }
   function ECB_of(Core){
    var block_size = Core[5], key_sizes = Core[4], of_secret = Core[1];
    function unsafe_ecb(xform, key, src, src_off, dst, dst_off, len){
     return caml_call6
             (xform,
              key,
              caml_div(len, block_size),
              src,
              src_off,
              dst,
              dst_off);
    }
    function ecb(xform, key, src, src_off, dst, dst_off, len){
     if(0 !== caml_mod(len, block_size))
      caml_call2(Mirage_crypto_Uncommon[2], _d_, len);
     check_offset(cst_ECB, cst_src, src_off, len, caml_ml_string_length(src));
     check_offset(cst_ECB$0, cst_dst, dst_off, len, caml_ml_bytes_length(dst));
     return unsafe_ecb(xform, key, src, src_off, dst, dst_off, len);
    }
    function encrypt_into(param, src, src_off, dst, dst_off, len){
     var key = param[1];
     return ecb(Core[6], key, src, src_off, dst, dst_off, len);
    }
    function unsafe_encrypt_into(param, src, src_off, dst, dst_off, len){
     var key = param[1];
     return unsafe_ecb(Core[6], key, src, src_off, dst, dst_off, len);
    }
    function decrypt_into(param, src, src_off, dst, dst_off, len){
     var key = param[2];
     return ecb(Core[7], key, src, src_off, dst, dst_off, len);
    }
    function unsafe_decrypt_into(param, src, src_off, dst, dst_off, len){
     var key = param[2];
     return unsafe_ecb(Core[7], key, src, src_off, dst, dst_off, len);
    }
    function encrypt(key, src){
     var len = caml_ml_string_length(src), dst = caml_create_bytes(len);
     encrypt_into(key, src, 0, dst, 0, len);
     return caml_call1(Stdlib_Bytes[44], dst);
    }
    function decrypt(key, src){
     var len = caml_ml_string_length(src), dst = caml_create_bytes(len);
     decrypt_into(key, src, 0, dst, 0, len);
     return caml_call1(Stdlib_Bytes[44], dst);
    }
    return [0,
            of_secret,
            key_sizes,
            block_size,
            encrypt,
            decrypt,
            encrypt_into,
            decrypt_into,
            unsafe_encrypt_into,
            unsafe_decrypt_into];
   }
   function CBC_of(Core){
    var block_size = Core[5], key_sizes = Core[4], of_secret = Core[1];
    function check_block_size(iv, len){
     if(caml_ml_string_length(iv) !== block_size)
      caml_call2(Mirage_crypto_Uncommon[2], _e_, caml_ml_string_length(iv));
     var _as_ = 0 !== caml_mod(len, block_size) ? 1 : 0;
     return _as_ ? caml_call2(Mirage_crypto_Uncommon[2], _f_, len) : _as_;
    }
    function next_iv(opt, cs, iv){
     if(opt) var sth = opt[1], off = sth; else var off = 0;
     check_block_size(iv, caml_ml_string_length(cs) - off | 0);
     return off < caml_ml_string_length(cs)
             ? caml_call3
               (Stdlib_String[16],
                cs,
                caml_ml_string_length(cs) - block_size | 0,
                block_size)
             : iv;
    }
    function unsafe_encrypt_into_inplace(param, iv, dst, dst_off, len){
     var
      key = param[1],
      b$1 = caml_div(len, block_size),
      iv$0 = iv,
      iv_i = 0,
      dst_i = dst_off,
      b = b$1;
     for(;;){
      if(0 === b) return 0;
      runtime.mc_xor_into_bytes(iv$0, iv_i, dst, dst_i, block_size);
      var _ar_ = caml_call1(Stdlib_Bytes[44], dst);
      caml_call6(Core[6], key, 1, _ar_, dst_i, dst, dst_i);
      var
       b$0 = b - 1 | 0,
       dst_i$0 = dst_i + block_size | 0,
       iv$1 = caml_call1(Stdlib_Bytes[44], dst),
       iv$0 = iv$1,
       iv_i = dst_i,
       dst_i = dst_i$0,
       b = b$0;
     }
    }
    function unsafe_encrypt_into(key, iv, src, src_off, dst, dst_off, len){
     runtime.caml_blit_string(src, src_off, dst, dst_off, len);
     return unsafe_encrypt_into_inplace(key, iv, dst, dst_off, len);
    }
    function encrypt_into(key, iv, src, src_off, dst, dst_off, len){
     check_block_size(iv, len);
     check_offset
      (cst_CBC, cst_src$0, src_off, len, caml_ml_string_length(src));
     check_offset
      (cst_CBC$0, cst_dst$0, dst_off, len, caml_ml_bytes_length(dst));
     return unsafe_encrypt_into(key, iv, src, src_off, dst, dst_off, len);
    }
    function encrypt(key, iv, src){
     var dst = caml_create_bytes(caml_ml_string_length(src));
     encrypt_into(key, iv, src, 0, dst, 0, caml_ml_string_length(src));
     return caml_call1(Stdlib_Bytes[44], dst);
    }
    function unsafe_decrypt_into(param, iv, src, src_off, dst, dst_off, len){
     var
      key = param[2],
      b = caml_div(len, block_size),
      _ap_ = 0 < b ? 1 : 0,
      _aq_ =
        _ap_
         ? (caml_call6
            (Core[7], key, b, src, src_off, dst, dst_off),
           runtime.mc_xor_into_bytes(iv, 0, dst, dst_off, block_size),
           runtime.mc_xor_into_bytes
            (src,
             src_off,
             dst,
             dst_off + block_size | 0,
             caml_mul(b - 1 | 0, block_size)))
         : _ap_;
     return _aq_;
    }
    function decrypt_into(key, iv, src, src_off, dst, dst_off, len){
     check_block_size(iv, len);
     check_offset
      (cst_CBC$1, cst_src$1, src_off, len, caml_ml_string_length(src));
     check_offset
      (cst_CBC$2, cst_dst$1, dst_off, len, caml_ml_bytes_length(dst));
     return unsafe_decrypt_into(key, iv, src, src_off, dst, dst_off, len);
    }
    function decrypt(key, iv, src){
     var len = caml_ml_string_length(src), msg = caml_create_bytes(len);
     decrypt_into(key, iv, src, 0, msg, 0, len);
     return caml_call1(Stdlib_Bytes[44], msg);
    }
    return [0,
            of_secret,
            key_sizes,
            block_size,
            encrypt,
            decrypt,
            next_iv,
            encrypt_into,
            decrypt_into,
            unsafe_encrypt_into,
            unsafe_decrypt_into,
            unsafe_encrypt_into_inplace];
   }
   function CTR_of(Core, Ctr){
    if(Core[5] !== Ctr[1])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    var block_size = Core[5], key_sizes = Core[4], of_secret = Core[2];
    function unsafe_stream_into(key, ctr, buf, off, len){
     var
      blocks =
        caml_div(caml_call2(Mirage_crypto_Uncommon[5], 0, len), block_size);
     caml_call4(Ctr[4], ctr, buf, off, blocks);
     var _al_ = caml_call1(Stdlib_Bytes[44], buf);
     caml_call6(Core[6], key, blocks, _al_, off, buf, off);
     var
      slack =
        caml_mod(caml_call2(Mirage_crypto_Uncommon[5], 0, len), block_size),
      _am_ = 0 !== slack ? 1 : 0;
     if(_am_){
      var
       buf$0 = caml_create_bytes(block_size),
       ctr$0 = caml_call2(Ctr[2], ctr, caml_int64_of_int32(blocks));
      caml_call4(Ctr[4], ctr$0, buf$0, 0, 1);
      var _an_ = caml_call1(Stdlib_Bytes[44], buf$0);
      caml_call6(Core[6], key, 1, _an_, 0, buf$0, 0);
      var
       _ao_ =
         runtime.caml_blit_bytes
          (buf$0, 0, buf, off + caml_mul(blocks, block_size) | 0, slack);
     }
     else
      var _ao_ = _am_;
     return _ao_;
    }
    function stream_into(key, ctr, buf, off, len){
     check_offset(cst_CTR, cst_buf, off, len, caml_ml_bytes_length(buf));
     return unsafe_stream_into(key, ctr, buf, off, len);
    }
    function stream(key, ctr, n){
     var buf = caml_create_bytes(n);
     unsafe_stream_into(key, ctr, buf, 0, n);
     return caml_call1(Stdlib_Bytes[44], buf);
    }
    function unsafe_encrypt_into(key, ctr, src, src_off, dst, dst_off, len){
     unsafe_stream_into(key, ctr, dst, dst_off, len);
     return caml_call5
             (Mirage_crypto_Uncommon[8], src, src_off, dst, dst_off, len);
    }
    function encrypt_into(key, ctr, src, src_off, dst, dst_off, len){
     check_offset
      (cst_CTR$0, cst_src$2, src_off, len, caml_ml_string_length(src));
     check_offset
      (cst_CTR$1, cst_dst$2, dst_off, len, caml_ml_bytes_length(dst));
     return unsafe_encrypt_into(key, ctr, src, src_off, dst, dst_off, len);
    }
    function encrypt(key, ctr, src){
     var len = caml_ml_string_length(src), dst = caml_create_bytes(len);
     encrypt_into(key, ctr, src, 0, dst, 0, len);
     return caml_call1(Stdlib_Bytes[44], dst);
    }
    var add_ctr = Ctr[2];
    function next_ctr(opt, msg, ctr){
     if(opt) var sth = opt[1], off = sth; else var off = 0;
     return caml_call2
             (add_ctr,
              ctr,
              caml_int64_of_int32
               (caml_call2
                 (Mirage_crypto_Uncommon[3],
                  caml_ml_string_length(msg) - off | 0,
                  block_size)));
    }
    var ctr_of_octets = Ctr[3];
    return [0,
            of_secret,
            key_sizes,
            block_size,
            add_ctr,
            next_ctr,
            ctr_of_octets,
            stream,
            encrypt,
            encrypt,
            stream_into,
            encrypt_into,
            encrypt_into,
            unsafe_stream_into,
            unsafe_encrypt_into,
            unsafe_encrypt_into];
   }
   var keysize = runtime.mc_ghash_key_size(0), tagsize = 16;
   function derive(cs){
    if(16 > caml_ml_string_length(cs))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var k = caml_create_bytes(keysize);
    runtime.mc_ghash_init_key(cs, k);
    return caml_call1(Stdlib_Bytes[44], k);
   }
   function digesti_off_len(key, i){
    var res = caml_call2(Stdlib_Bytes[1], tagsize, 0);
    caml_call1
     (i,
      function(param){
       var len = param[3], off = param[2], cs = param[1];
       return runtime.mc_ghash(key, res, cs, off, len);
      });
    return caml_call1(Stdlib_Bytes[44], res);
   }
   function digesti(key, i){
    var res = caml_call2(Stdlib_Bytes[1], tagsize, 0);
    caml_call1
     (i,
      function(cs){
       return runtime.mc_ghash(key, res, cs, 0, caml_ml_string_length(cs));
      });
    return caml_call1(Stdlib_Bytes[44], res);
   }
   var GHASH = [0, derive, digesti, digesti_off_len, tagsize];
   function GCM_of(C){
    if(16 !== C[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    var
     ___ = Counters[3],
     CTR = CTR_of(C, [0, ___[1], ___[3], ___[2], ___[4]]),
     tag_size = GHASH[4],
     block_size = C[5],
     key_sizes = C[4],
     z128 = caml_call2(Stdlib_String[1], block_size, 0);
    function of_secret(cs){
     var h = caml_create_bytes(block_size), key = caml_call1(C[2], cs);
     caml_call6(C[6], key, 1, z128, 0, h, 0);
     var _ak_ = caml_call1(Stdlib_Bytes[44], h);
     return [0, key, caml_call1(GHASH[1], _ak_)];
    }
    function bits64(cs){
     return caml_int64_of_int32(caml_ml_string_length(cs) * 8 | 0);
    }
    function pack64s(a, b){
     var cs = caml_create_bytes(16);
     caml_call3(Stdlib_Bytes[85], cs, 0, a);
     caml_call3(Stdlib_Bytes[85], cs, 8, b);
     return caml_call1(Stdlib_Bytes[44], cs);
    }
    function counter(hkey, nonce){
     var match = caml_ml_string_length(nonce);
     if(0 === match) return caml_call1(Mirage_crypto_Uncommon[2], _i_);
     if(12 === match){
      var
       w2 = caml_call2(Stdlib_String[60], nonce, 8),
       w1 = caml_call2(Stdlib_String[63], nonce, 0);
      return [0,
              w1,
              caml_int64_add
               (_j_,
                runtime.caml_int64_shift_left(caml_int64_of_int32(w2), 32))];
     }
     var
      _ah_ = pack64s(_k_, bits64(nonce)),
      _ai_ = caml_call2(Mirage_crypto_Uncommon[6], nonce, _ah_),
      _aj_ = caml_call1(caml_call1(GHASH[2], hkey), _ai_);
     return caml_call1(CTR[6], _aj_);
    }
    function unsafe_tag_into
    (key, hkey, ctr, opt, cdata, off, len, dst, tag_off){
     if(opt) var sth = opt[1], adata = sth; else var adata = cst;
     var
      _ae_ =
        [0, pack64s(bits64(adata), caml_int64_of_int32(len * 8 | 0)), 0, 16],
      _af_ =
        caml_call3
         (Mirage_crypto_Uncommon[7],
          [0, adata, 0, caml_ml_string_length(adata)],
          [0, cdata, off, len],
          _ae_),
      _ag_ = caml_call2(GHASH[3], hkey, _af_);
     return caml_call7(CTR[14], key, ctr, _ag_, 0, dst, tag_off, tag_size);
    }
    function unsafe_authenticate_encrypt_in
    (param, nonce, adata, src, src_off, dst, dst_off, tag_off, len){
     var
      hkey = param[2],
      key = param[1],
      ctr = counter(hkey, nonce),
      _ad_ = caml_call2(CTR[4], ctr, _l_);
     caml_call7(CTR[14], key, _ad_, src, src_off, dst, dst_off, len);
     return unsafe_tag_into
             (key,
              hkey,
              ctr,
              adata,
              caml_call1(Stdlib_Bytes[44], dst),
              dst_off,
              len,
              dst,
              tag_off);
    }
    function authenticate_encrypt_into
    (key, nonce, adata, src, src_off, dst, dst_off, tag_off, len){
     check_offset
      (cst_GCM, cst_src$3, src_off, len, caml_ml_string_length(src));
     check_offset
      (cst_GCM$0, cst_dst$3, dst_off, len, caml_ml_bytes_length(dst));
     check_offset
      (cst_GCM$1, cst_dst_tag, tag_off, tag_size, caml_ml_bytes_length(dst));
     return unsafe_authenticate_encrypt_in
             (key, nonce, adata, src, src_off, dst, dst_off, tag_off, len);
    }
    function authenticate_encrypt(key, nonce, adata, data){
     var
      l = caml_ml_string_length(data),
      dst = caml_create_bytes(l + tag_size | 0);
     unsafe_authenticate_encrypt_in(key, nonce, adata, data, 0, dst, 0, l, l);
     return caml_call1(Stdlib_Bytes[44], dst);
    }
    function authenticate_encrypt_tag(key, nonce, adata, data){
     var
      r = authenticate_encrypt(key, nonce, adata, data),
      _ac_ =
        caml_call3
         (Stdlib_String[16], r, caml_ml_string_length(data), tag_size);
     return [0,
             caml_call3(Stdlib_String[16], r, 0, caml_ml_string_length(data)),
             _ac_];
    }
    function unsafe_authenticate_decrypt_in
    (param, nonce, adata, src, src_off, tag_off, dst, dst_off, len){
     var
      hkey = param[2],
      key = param[1],
      ctr = counter(hkey, nonce),
      _$_ = caml_call2(CTR[4], ctr, _m_);
     caml_call7(CTR[14], key, _$_, src, src_off, dst, dst_off, len);
     var ctag = caml_create_bytes(tag_size);
     unsafe_tag_into(key, hkey, ctr, adata, src, src_off, len, ctag, 0);
     var
      _aa_ = caml_call1(Stdlib_Bytes[44], ctag),
      _ab_ = caml_call3(Stdlib_String[16], src, tag_off, tag_size);
     return caml_call2(Eqaf[1], _ab_, _aa_);
    }
    function authenticate_decrypt_into
    (key, nonce, adata, src, src_off, tag_off, dst, dst_off, len){
     check_offset
      (cst_GCM$2, cst_src$4, src_off, len, caml_ml_string_length(src));
     check_offset
      (cst_GCM$3, cst_src_tag, tag_off, tag_size, caml_ml_string_length(src));
     check_offset
      (cst_GCM$4, cst_dst$4, dst_off, len, caml_ml_bytes_length(dst));
     return unsafe_authenticate_decrypt_in
             (key, nonce, adata, src, src_off, tag_off, dst, dst_off, len);
    }
    function authenticate_decrypt(key, nonce, adata, cdata){
     if(caml_ml_string_length(cdata) < tag_size) return 0;
     var
      l = caml_ml_string_length(cdata) - tag_size | 0,
      data = caml_create_bytes(l);
     return unsafe_authenticate_decrypt_in
              (key, nonce, adata, cdata, 0, l, data, 0, l)
             ? [0, caml_call1(Stdlib_Bytes[44], data)]
             : 0;
    }
    function authenticate_decrypt_tag(key, nonce, adata, tag_data, cipher){
     var cdata = caml_call2(Stdlib[28], cipher, tag_data);
     return authenticate_decrypt(key, nonce, adata, cdata);
    }
    return [0,
            tag_size,
            of_secret,
            authenticate_encrypt,
            authenticate_decrypt,
            authenticate_encrypt_tag,
            authenticate_decrypt_tag,
            authenticate_encrypt_into,
            authenticate_decrypt_into,
            unsafe_authenticate_encrypt_in,
            unsafe_authenticate_decrypt_in,
            key_sizes,
            block_size];
   }
   function CCM16_of(C){
    if(16 !== C[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var tag_size = C[5];
    function of_secret(sec){return caml_call1(C[2], sec);}
    var block_size = C[5], key_sizes = C[4];
    function cipher(key, src, src_off, dst, dst_off){
     return caml_call6(C[6], key, 1, src, src_off, dst, dst_off);
    }
    function unsafe_authenticate_encrypt_in
    (key, nonce, opt, src, src_off, dst, dst_off, tag_off, len){
     if(opt) var sth = opt[1], adata = sth; else var adata = cst$0;
     return caml_call10
             (Mirage_crypto_Ccm[11],
              cipher,
              key,
              nonce,
              adata,
              src,
              src_off,
              dst,
              dst_off,
              tag_off,
              len);
    }
    function valid_nonce(nonce){
     var
      nsize = caml_ml_string_length(nonce),
      _Y_ = nsize < 7 ? 1 : 0,
      _Z_ = _Y_ || (13 < nsize ? 1 : 0);
     return _Z_ ? caml_call2(Mirage_crypto_Uncommon[2], _o_, nsize) : _Z_;
    }
    function authenticate_encrypt_into
    (key, nonce, adata, src, src_off, dst, dst_off, tag_off, len){
     check_offset
      (cst_CCM, cst_src$5, src_off, len, caml_ml_string_length(src));
     check_offset
      (cst_CCM$0, cst_dst$5, dst_off, len, caml_ml_bytes_length(dst));
     check_offset
      (cst_CCM$1, cst_dst_tag$0, tag_off, tag_size, caml_ml_bytes_length(dst));
     valid_nonce(nonce);
     return unsafe_authenticate_encrypt_in
             (key, nonce, adata, src, src_off, dst, dst_off, tag_off, len);
    }
    function authenticate_encrypt(key, nonce, adata, cs){
     valid_nonce(nonce);
     var
      l = caml_ml_string_length(cs),
      dst = caml_create_bytes(l + tag_size | 0);
     unsafe_authenticate_encrypt_in(key, nonce, adata, cs, 0, dst, 0, l, l);
     return caml_call1(Stdlib_Bytes[44], dst);
    }
    function authenticate_encrypt_tag(key, nonce, adata, cs){
     var
      res = authenticate_encrypt(key, nonce, adata, cs),
      _X_ =
        caml_call3
         (Stdlib_String[16], res, caml_ml_string_length(cs), tag_size);
     return [0,
             caml_call3(Stdlib_String[16], res, 0, caml_ml_string_length(cs)),
             _X_];
    }
    function unsafe_authenticate_decrypt_in
    (key, nonce, opt, src, src_off, tag_off, dst, dst_off, len){
     if(opt) var sth = opt[1], adata = sth; else var adata = cst$1;
     return caml_call10
             (Mirage_crypto_Ccm[12],
              cipher,
              key,
              nonce,
              adata,
              src,
              src_off,
              tag_off,
              dst,
              dst_off,
              len);
    }
    function authenticate_decrypt_into
    (key, nonce, adata, src, src_off, tag_off, dst, dst_off, len){
     check_offset
      (cst_CCM$2, cst_src$6, src_off, len, caml_ml_string_length(src));
     check_offset
      (cst_CCM$3,
       cst_src_tag$0,
       tag_off,
       tag_size,
       caml_ml_string_length(src));
     check_offset
      (cst_CCM$4, cst_dst$6, dst_off, len, caml_ml_bytes_length(dst));
     valid_nonce(nonce);
     return unsafe_authenticate_decrypt_in
             (key, nonce, adata, src, src_off, tag_off, dst, dst_off, len);
    }
    function authenticate_decrypt(key, nonce, adata, data){
     if(caml_ml_string_length(data) < tag_size) return 0;
     var
      dlen = caml_ml_string_length(data) - tag_size | 0,
      dst = caml_create_bytes(dlen);
     return authenticate_decrypt_into
              (key, nonce, adata, data, 0, dlen, dst, 0, dlen)
             ? [0, caml_call1(Stdlib_Bytes[44], dst)]
             : 0;
    }
    function authenticate_decrypt_tag(key, nonce, adata, tag, cs){
     return authenticate_decrypt
             (key, nonce, adata, caml_call2(Stdlib[28], cs, tag));
    }
    return [0,
            tag_size,
            of_secret,
            authenticate_encrypt,
            authenticate_decrypt,
            authenticate_encrypt_tag,
            authenticate_decrypt_tag,
            authenticate_encrypt_into,
            authenticate_decrypt_into,
            unsafe_authenticate_encrypt_in,
            unsafe_authenticate_decrypt_in,
            key_sizes,
            block_size];
   }
   var
    Modes = [0, ECB_of, CBC_of, CTR_of, GHASH, GCM_of, CCM16_of],
    key = [0, 16, 24, 32],
    block = 16;
   function of_secret_with(init, key){
    var _W_ = caml_ml_string_length(key) - 16 | 0;
    a:
    {
     b:
     {
      if(8 < _W_ >>> 0){
       if(16 === _W_) break b;
      }
      else if(6 < _W_ - 1 >>> 0) break b;
      var
       rounds =
         caml_call2
          (Mirage_crypto_Uncommon[2], _q_, caml_ml_string_length(key));
      break a;
     }
     var rounds = (caml_ml_string_length(key) / 4 | 0) + 6 | 0;
    }
    var rk = caml_create_bytes(runtime.mc_aes_rk_size(rounds));
    caml_call3(init, key, rk, rounds);
    return [0, caml_call1(Stdlib_Bytes[44], rk), rounds];
   }
   function _r_(_V_, _U_, _T_){
    return runtime.mc_aes_derive_e_key(_V_, _U_, _T_);
   }
   function e_of_secret(_S_){return of_secret_with(_r_, _S_);}
   function _s_(_P_, _Q_, _R_){
    return runtime.mc_aes_derive_d_key(_P_, _Q_, _R_, 0);
   }
   function d_of_secret(_O_){return of_secret_with(_s_, _O_);}
   function of_secret(secret){
    var ekey = e_of_secret(secret), e = ekey[1], _K_ = [0, e];
    return [0,
            ekey,
            of_secret_with
             (function(_L_, _M_, _N_){
               return runtime.mc_aes_derive_d_key(_L_, _M_, _N_, _K_);
              },
              secret)];
   }
   function encrypt(param, blocks, src, off1, dst, off2){
    var rounds = param[2], e = param[1];
    return runtime.mc_aes_enc_bc(src, off1, dst, off2, e, rounds, blocks);
   }
   function decrypt(param, blocks, src, off1, dst, off2){
    var rounds = param[2], d = param[1];
    return runtime.mc_aes_dec_bc(src, off1, dst, off2, d, rounds, blocks);
   }
   var
    Core =
      [0, of_secret, e_of_secret, d_of_secret, key, block, encrypt, decrypt],
    ECB = caml_call1(Modes[1], Core),
    CBC = caml_call1(Modes[2], Core),
    _t_ = Counters[2],
    _u_ = [0, _t_[1], _t_[3], _t_[2], _t_[4]],
    CTR = caml_call1(caml_call1(Modes[3], Core), _u_),
    GCM = caml_call1(Modes[5], Core),
    CCM16 = caml_call1(Modes[6], Core),
    AES = [0, Core, ECB, CBC, CTR, GCM, CCM16],
    key$0 = [0, 24],
    k_s = runtime.mc_des_key_size(0),
    block$0 = 8;
   function gen_of_secret(direction, key){
    if(24 !== caml_ml_string_length(key))
     caml_call2(Mirage_crypto_Uncommon[2], _v_, caml_ml_string_length(key));
    var
     key$0 = caml_call1(Stdlib_Bytes[5], key),
     keybuf = caml_create_bytes(k_s);
    runtime.mc_des_des3key(key$0, direction, keybuf);
    return caml_call1(Stdlib_Bytes[44], keybuf);
   }
   var _w_ = 0;
   function e_of_secret$0(_J_){return gen_of_secret(_w_, _J_);}
   var _x_ = 1;
   function d_of_secret$0(_I_){return gen_of_secret(_x_, _I_);}
   function of_secret$0(secret){
    var _H_ = d_of_secret$0(secret);
    return [0, e_of_secret$0(secret), _H_];
   }
   function encrypt$0(key, blocks, src, off1, dst, off2){
    return runtime.mc_des_ddes_bc(src, off1, dst, off2, blocks, key);
   }
   var
    Core$0 =
      [0,
       of_secret$0,
       e_of_secret$0,
       d_of_secret$0,
       key$0,
       block$0,
       encrypt$0,
       encrypt$0],
    ECB$0 = caml_call1(Modes[1], Core$0),
    CBC$0 = caml_call1(Modes[2], Core$0),
    _y_ = Counters[1],
    _z_ = [0, _y_[1], _y_[3], _y_[2], _y_[4]],
    CTR$0 = caml_call1(caml_call1(Modes[3], Core$0), _z_),
    DES = [0, Core$0, ECB$0, CBC$0, CTR$0],
    _B_ = 1 === runtime.mc_ghash_mode(0) ? _A_ : 0,
    _D_ = 1 === runtime.mc_aes_mode(0) ? _C_ : 0,
    _E_ = caml_call2(Stdlib[37], _D_, _B_),
    _G_ = 1 === runtime.mc_misc_mode(0) ? _F_ : 0,
    accelerated = caml_call2(Stdlib[37], _G_, _E_),
    Mirage_crypto_Cipher_block =
      [0, Block, Counters, check_offset, Modes, AES, DES, accelerated];
   runtime.caml_register_global
    (76, Mirage_crypto_Cipher_block, "Mirage_crypto__Cipher_block");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto__Cipher_stream
//# unitInfo: Requires: Mirage_crypto__Uncommon, Stdlib__Array, Stdlib__Bytes, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Array = global_data.Stdlib__Array,
    Mirage_crypto_Uncommon = global_data.Mirage_crypto__Uncommon,
    _a_ =
      [0,
       [11, "ARC4.of_secret: key size ", [4, 0, 0, 0, 0]],
       "ARC4.of_secret: key size %d"];
   function of_secret(buf){
    var
     len = caml_ml_string_length(buf),
     _d_ = len < 1 ? 1 : 0,
     _e_ = _d_ || (256 < len ? 1 : 0);
    if(_e_) caml_call2(Mirage_crypto_Uncommon[2], _a_, len);
    function _f_(x){return x;}
    var s = caml_call2(Stdlib_Array[1], 256, _f_), j = 0, i = 0;
    for(;;){
     if(256 === i) return [0, 0, 0, s];
     var
      _g_ = runtime.caml_mod(i, len),
      x = caml_call2(Stdlib_String[49], buf, _g_),
      si = caml_check_bound(s, i)[1 + i],
      j$0 = ((j + si | 0) + x | 0) & 255,
      sj = caml_check_bound(s, j$0)[1 + j$0];
     s[1 + i] = sj;
     s[1 + j$0] = si;
     var i$0 = i + 1 | 0, j = j$0, i = i$0;
    }
   }
   function encrypt(param, buf){
    var
     s = param[3],
     j = param[2],
     i = param[1],
     s$0 = caml_call1(Stdlib_Array[6], s),
     len = caml_ml_string_length(buf),
     res = runtime.caml_create_bytes(len),
     i$0 = i,
     j$0 = j,
     n = 0;
    for(;;){
     if(n === len){
      var key = [0, i$0, j$0, s$0];
      return [0, caml_call1(Stdlib_Bytes[44], res), key];
     }
     var
      i$1 = (i$0 + 1 | 0) & 255,
      si = caml_check_bound(s$0, i$1)[1 + i$1],
      j$1 = (j$0 + si | 0) & 255,
      sj = caml_check_bound(s$0, j$1)[1 + j$1];
     s$0[1 + i$1] = sj;
     s$0[1 + j$1] = si;
     var
      _b_ = (si + sj | 0) & 255,
      k = caml_check_bound(s$0, _b_)[1 + _b_],
      _c_ = k ^ caml_call2(Stdlib_String[49], buf, n);
     caml_call3(Stdlib_Bytes[73], res, n, _c_);
     var n$0 = n + 1 | 0, i$0 = i$1, j$0 = j$1, n = n$0;
    }
   }
   var
    ARC4 = [0, of_secret, encrypt, encrypt],
    Mirage_crypto_Cipher_stream = [0, ARC4];
   runtime.caml_register_global
    (5, Mirage_crypto_Cipher_stream, "Mirage_crypto__Cipher_stream");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Mirage_crypto
//# unitInfo: Requires: Mirage_crypto__Chacha20, Mirage_crypto__Cipher_block, Mirage_crypto__Cipher_stream, Mirage_crypto__Poly1305, Mirage_crypto__Uncommon
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Mirage_crypto_Cipher_block = global_data.Mirage_crypto__Cipher_block,
    Mirage_crypto_Cipher_stream = global_data.Mirage_crypto__Cipher_stream,
    Mirage_crypto_Chacha20 = global_data.Mirage_crypto__Chacha20,
    Mirage_crypto_Poly1305 = global_data.Mirage_crypto__Poly1305,
    Mirage_crypto_Uncommon = global_data.Mirage_crypto__Uncommon,
    Block = Mirage_crypto_Cipher_block[1],
    AES = Mirage_crypto_Cipher_block[5],
    DES = Mirage_crypto_Cipher_block[6],
    accelerated = Mirage_crypto_Cipher_block[7],
    ARC4 = Mirage_crypto_Cipher_stream[1],
    Mirage_crypto =
      [0,
       [0,
        Mirage_crypto_Uncommon[3],
        Mirage_crypto_Uncommon[4],
        Mirage_crypto_Uncommon[5],
        Mirage_crypto_Uncommon[6],
        Mirage_crypto_Uncommon[7],
        Mirage_crypto_Uncommon[9],
        Mirage_crypto_Uncommon[8],
        Mirage_crypto_Uncommon[2]],
       Mirage_crypto_Poly1305[1],
       Block,
       [0, AES[2], AES[3], AES[4], AES[5], AES[6]],
       [0, DES[2], DES[3], DES[4]],
       accelerated,
       [0,
        Mirage_crypto_Chacha20[7],
        Mirage_crypto_Chacha20[2],
        Mirage_crypto_Chacha20[12],
        Mirage_crypto_Chacha20[16],
        Mirage_crypto_Chacha20[13],
        Mirage_crypto_Chacha20[17],
        Mirage_crypto_Chacha20[11],
        Mirage_crypto_Chacha20[15],
        Mirage_crypto_Chacha20[10],
        Mirage_crypto_Chacha20[14],
        Mirage_crypto_Chacha20[6]],
       ARC4];
   runtime.caml_register_global(5, Mirage_crypto, "Mirage_crypto");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJtaXJhZ2VfY3J5cHRvLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJrYXNwcmludGYiLCJrIiwiZm10IiwiaW52YWxpZF9hcmciLCJzeW1ib2wiLCJ4IiwieSIsImltaW4iLCJhIiwiYiIsImltYXgiLCJpdGVyMiIsImYiLCJpdGVyMyIsImMiLCJ1bnNhZmVfeG9yX2ludG8iLCJzcmMiLCJzcmNfb2ZmIiwiZHN0IiwiZHN0X29mZiIsIm4iLCJ4b3IiLCJiJDAiLCJtYWNfc2l6ZSIsImR1cCIsImVtcHR5Iiwia2V5IiwiY3R4IiwidXBkYXRlIiwiZGF0YSIsImZlZWQiLCJjcyIsInQiLCJmZWVkaSIsIml0ZXIiLCJmaW5hbCQwIiwicmVzIiwiZ2V0IiwibWFjIiwibWFjaSIsInVuc2FmZV9tYWNfaW50byIsImRhdGFzIiwibGVuIiwib2ZmIiwiZCIsIm1hY19pbnRvIiwiYmxvY2tfc2l6ZSIsImZsYWdzIiwiYml0NiIsImxlbjEiLCJsZW4yIiwiZW5jb2RlX2xlbiIsImJ1ZiIsInNpemUiLCJ2YWx1ZSIsIm51bSIsIm0iLCJzZXRfZm9ybWF0Iiwib3B0Iiwibm9uY2UiLCJmbGFnX3ZhbCIsInN0aCIsInNtYWxsX3EiLCJnZW5fYWRhdGEiLCJzZXRfbGxlbiIsImxsZW4iLCJzZXRfbGxlbiQwIiwibGVmdG92ZXIiLCJ0b19wYWQiLCJnZW5fY3RyIiwiaSIsInByZXBhcmVfaGVhZGVyIiwiYWRhdGEiLCJwbGVuIiwidGxlbiIsImI2IiwiaGRyIiwic2V0IiwiY3J5cHRvX2NvcmVfaW50byIsImNpcGhlciIsIm1vZGUiLCJjYmNoZWFkZXIiLCJjdHJfZmxhZ192YWwiLCJjdHJibG9jayIsImJsb2NrIiwiY2JjIiwiaXYiLCJpdiQxIiwiaXZfb2ZmIiwiYmxvY2tfb2ZmIiwiYmxvY2tfb2ZmJDAiLCJpdiQwIiwiY3RyIiwic3JjX29mZiQwIiwiZHN0X29mZiQwIiwibGVuJDAiLCJjYmNfb2ZmIiwiY2JjYmxvY2siLCJsZW4kMSIsImRzdF9vZmYkMSIsInNyY19vZmYkMSIsImN0ciQwIiwiY3J5cHRvX2NvcmUiLCJkYXRhbGVuIiwiY3J5cHRvX3QiLCJ1bnNhZmVfZ2VuZXJhdGlvbl9lbmNyeXB0aW9uX2kiLCJ0YWdfb2ZmIiwidW5zYWZlX2RlY3J5cHRpb25fdmVyaWZpY2F0aW9uIiwidGFnIiwib2Zfc2VjcmV0IiwiY2hhY2hhMjBfYmxvY2siLCJzdGF0ZSIsImlkeCIsImtleV9zdHJlYW0iLCJpbml0IiwiY3RyX29mZiIsInNldF9jdHIzMiIsInYiLCJzZXRfY3RyNjQiLCJpbmMzMiIsImluYzY0IiwiaW5jIiwibm9uY2Vfb2ZmIiwiaW5pdF9jdHIiLCJrZXkkMCIsInMiLCJpbmMkMCIsIm5vbmNlX29mZiQwIiwiaW5pdF9jdHIkMCIsImtleSQxIiwicyQwIiwiY3J5cHRfaW50byIsImJsb2NrX2NvdW50IiwibGFzdCIsImxhc3RfbGVuIiwiY3J5cHQiLCJsIiwidGFnX3NpemUiLCJnZW5lcmF0ZV9wb2x5MTMwNV9rZXkiLCJwYWQxNiIsImxlbl9idWYiLCJwMSIsInAyIiwidW5zYWZlX2F1dGhlbnRpY2F0ZV9lbmNyeXB0X2luIiwicG9seTEzMDVfa2V5IiwiYXV0aGVudGljYXRlX2VuY3J5cHRfaW50byIsImF1dGhlbnRpY2F0ZV9lbmNyeXB0IiwiYXV0aGVudGljYXRlX2VuY3J5cHRfdGFnIiwiciIsInVuc2FmZV9hdXRoZW50aWNhdGVfZGVjcnlwdF9pbiIsImN0YWciLCJhdXRoZW50aWNhdGVfZGVjcnlwdF9pbnRvIiwiYXV0aGVudGljYXRlX2RlY3J5cHQiLCJhdXRoZW50aWNhdGVfZGVjcnlwdF90YWciLCJjZGF0YSIsImhpIiwibG8iLCJvZl9vY3RldHMiLCJhZGQiLCJ1bnNhZmVfY291bnRfaW50byIsImJsb2NrcyIsInNpemUkMCIsIm9mX29jdGV0cyQwIiwiYWRkJDAiLCJ3MCIsIncxIiwidzAkMCIsImZsaXAiLCJ1bnNhZmVfY291bnRfaW50byQwIiwic2l6ZSQxIiwib2Zfb2N0ZXRzJDEiLCJhZGQkMSIsInVuc2FmZV9jb3VudF9pbnRvJDEiLCJjaGVja19vZmZzZXQiLCJhY3R1YWxfbGVuIiwia2V5X3NpemVzIiwidW5zYWZlX2VjYiIsInhmb3JtIiwiZWNiIiwiZW5jcnlwdF9pbnRvIiwidW5zYWZlX2VuY3J5cHRfaW50byIsImRlY3J5cHRfaW50byIsInVuc2FmZV9kZWNyeXB0X2ludG8iLCJlbmNyeXB0IiwiZGVjcnlwdCIsImNoZWNrX2Jsb2NrX3NpemUiLCJuZXh0X2l2IiwidW5zYWZlX2VuY3J5cHRfaW50b19pbnBsYWNlIiwiaXZfaSIsImRzdF9pIiwibXNnIiwidW5zYWZlX3N0cmVhbV9pbnRvIiwic2xhY2siLCJidWYkMCIsInN0cmVhbV9pbnRvIiwic3RyZWFtIiwiYWRkX2N0ciIsIm5leHRfY3RyIiwiY3RyX29mX29jdGV0cyIsImtleXNpemUiLCJ0YWdzaXplIiwiZGVyaXZlIiwiZGlnZXN0aV9vZmZfbGVuIiwiZGlnZXN0aSIsInoxMjgiLCJoIiwiYml0czY0IiwicGFjazY0cyIsImNvdW50ZXIiLCJoa2V5IiwidzIiLCJ1bnNhZmVfdGFnX2ludG8iLCJ0YWdfZGF0YSIsInNlYyIsInZhbGlkX25vbmNlIiwibnNpemUiLCJkbGVuIiwib2Zfc2VjcmV0X3dpdGgiLCJyb3VuZHMiLCJyayIsImVfb2Zfc2VjcmV0IiwiZF9vZl9zZWNyZXQiLCJzZWNyZXQiLCJla2V5IiwiZSIsIm9mZjEiLCJvZmYyIiwia19zIiwiYmxvY2skMCIsImdlbl9vZl9zZWNyZXQiLCJkaXJlY3Rpb24iLCJrZXlidWYiLCJlX29mX3NlY3JldCQwIiwiZF9vZl9zZWNyZXQkMCIsIm9mX3NlY3JldCQwIiwiZW5jcnlwdCQwIiwiYWNjZWxlcmF0ZWQiLCJqIiwic2kiLCJqJDAiLCJzaiIsImkkMCIsImkkMSIsImokMSIsIm4kMCJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL21pcmFnZS1jcnlwdG8vbmF0aXZlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvbWlyYWdlLWNyeXB0by91bmNvbW1vbi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL21pcmFnZS1jcnlwdG8vcG9seTEzMDUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9taXJhZ2UtY3J5cHRvL2NjbS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL21pcmFnZS1jcnlwdG8vY2hhY2hhMjAubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9taXJhZ2UtY3J5cHRvL2NpcGhlcl9ibG9jay5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL21pcmFnZS1jcnlwdG8vY2lwaGVyX3N0cmVhbS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7R0FDYTs7SUFBQTtJQVNBO0lBTUc7SUFJRTtJQVFIO0dBcUJiO0dBQ0E7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7OztZQ2hERUEsVUFBVUMsR0FBRUM7SUFDZDs7S0FBMkIsT0FBRSxXQURqQkQsR0FDaUI7SUFBd0I7SUFBckQsT0FBQSx5Q0FEY0M7R0FDMkQ7WUFFdkVDLFlBQVlEO0lBQTRCLFVBQUEsNEJBQTVCQTtJQUE0QixPQUh4Q0Y7R0FHa0U7WUFFbEVJLE9BQUtDLEdBQUVDO0lBQ1QsUUFEU0EsY0FBRkQseUJBQUFBLFdBQUVDO0lBQ0ssTUFBQTtHQUMwQjtZQUV0Q0MsS0FBTUMsR0FBU0MsR0FBSSxPQUFiRCxJQUFTQyxJQUFURCxJQUFTQyxFQUEwQjtZQUN6Q0MsS0FBTUYsR0FBU0MsR0FBSSxPQUFiRCxJQUFTQyxJQUFBQSxJQUFURCxFQUFtQztZQUl6Q0csTUFBTUgsR0FBRUMsR0FBSUcsR0FBSSxXQUFKQSxHQUFOSixJQUFVLE9BQUEsV0FBSkksR0FBSkgsR0FBZ0I7WUFDeEJJ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RSw2QkFWRmdCLEtBR0FoQjtLQU9FLElBUkZnTyxNQUNBaE8sV0FGUTZOLE1BQUFDLEtBQUVILE1BQUFJLEtBRVYvTixJQURBZ087OztHQTNCTTtJQUFBLFdBTVJ2SSxXQWdCQTBFLFNBQUFBOzs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZSBBRVMgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgZW5jICAgICAgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJtY19hZXNfZW5jX2JjXCIgXCJtY19hZXNfZW5jXCIgW0BAbm9hbGxvY11cbiAgZXh0ZXJuYWwgZGVjICAgICAgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJtY19hZXNfZGVjX2JjXCIgXCJtY19hZXNfZGVjXCIgW0BAbm9hbGxvY11cbiAgZXh0ZXJuYWwgZGVyaXZlX2UgOiBzdHJpbmcgLT4gYnl0ZXMgLT4gaW50IC0+IHVuaXQgPSBcIm1jX2Flc19kZXJpdmVfZV9rZXlcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCBkZXJpdmVfZCA6IHN0cmluZyAtPiBieXRlcyAtPiBpbnQgLT4gc3RyaW5nIG9wdGlvbiAtPiB1bml0ID0gXCJtY19hZXNfZGVyaXZlX2Rfa2V5XCIgW0BAbm9hbGxvY11cbiAgZXh0ZXJuYWwgcmtfcyAgICAgOiBpbnQgIC0+IGludCA9IFwibWNfYWVzX3JrX3NpemVcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCBtb2RlICAgICA6IHVuaXQgLT4gaW50ID0gXCJtY19hZXNfbW9kZVwiIFtAQG5vYWxsb2NdXG5lbmRcblxubW9kdWxlIERFUyA9IHN0cnVjdFxuICBleHRlcm5hbCBkZGVzICAgIDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHN0cmluZyAtPiB1bml0ID0gXCJtY19kZXNfZGRlc19iY1wiIFwibWNfZGVzX2RkZXNcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCBkZXMza2V5IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IHVuaXQgPSBcIm1jX2Rlc19kZXMza2V5XCIgW0BAbm9hbGxvY11cbiAgZXh0ZXJuYWwga19zICAgICA6IHVuaXQgLT4gaW50ID0gXCJtY19kZXNfa2V5X3NpemVcIiBbQEBub2FsbG9jXVxuZW5kXG5cbm1vZHVsZSBDaGFjaGEgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgcm91bmQgOiBpbnQgLT4gYnl0ZXMgLT4gYnl0ZXMgLT4gaW50IC0+IHVuaXQgPSBcIm1jX2NoYWNoYV9yb3VuZFwiIFtAQG5vYWxsb2NdXG5lbmRcblxubW9kdWxlIFBvbHkxMzA1ID0gc3RydWN0XG4gIGV4dGVybmFsIGluaXQgICAgIDogYnl0ZXMgLT4gc3RyaW5nIC0+IHVuaXQgPSBcIm1jX3BvbHkxMzA1X2luaXRcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCB1cGRhdGUgICA6IGJ5dGVzIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIm1jX3BvbHkxMzA1X3VwZGF0ZVwiIFtAQG5vYWxsb2NdXG4gIGV4dGVybmFsIGZpbmFsaXplIDogYnl0ZXMgLT4gYnl0ZXMgLT4gaW50IC0+IHVuaXQgPSBcIm1jX3BvbHkxMzA1X2ZpbmFsaXplXCIgW0BAbm9hbGxvY11cbiAgZXh0ZXJuYWwgY3R4X3NpemUgOiB1bml0IC0+IGludCA9IFwibWNfcG9seTEzMDVfY3R4X3NpemVcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCBtYWNfc2l6ZSA6IHVuaXQgLT4gaW50ID0gXCJtY19wb2x5MTMwNV9tYWNfc2l6ZVwiIFtAQG5vYWxsb2NdXG5lbmRcblxubW9kdWxlIEdIQVNIID0gc3RydWN0XG4gIGV4dGVybmFsIGtleXNpemUgOiB1bml0IC0+IGludCA9IFwibWNfZ2hhc2hfa2V5X3NpemVcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCBrZXlpbml0IDogc3RyaW5nIC0+IGJ5dGVzIC0+IHVuaXQgPSBcIm1jX2doYXNoX2luaXRfa2V5XCIgW0BAbm9hbGxvY11cbiAgZXh0ZXJuYWwgZ2hhc2ggOiBzdHJpbmcgLT4gYnl0ZXMgLT4gc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwibWNfZ2hhc2hcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCBtb2RlIDogdW5pdCAtPiBpbnQgPSBcIm1jX2doYXNoX21vZGVcIiBbQEBub2FsbG9jXVxuZW5kXG5cbigqIFhYWCBUT0RPXG4gKiBVbnNvbHZlZDogYm91bmRzLWNoZWNrZWQgWE9ScyBhcmUgc2xvd2luZyB0aGluZ3MgZG93biBjb25zaWRlcmFibHkuLi4gKilcbmV4dGVybmFsIHhvcl9pbnRvX2J5dGVzIDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIm1jX3hvcl9pbnRvX2J5dGVzXCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgY291bnQ4YmUgICA6IGN0cjpieXRlcyAtPiBieXRlcyAtPiBvZmY6aW50IC0+IGJsb2NrczppbnQgLT4gdW5pdCA9IFwibWNfY291bnRfOF9iZVwiICAgIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3VudDE2YmUgIDogY3RyOmJ5dGVzIC0+IGJ5dGVzIC0+IG9mZjppbnQgLT4gYmxvY2tzOmludCAtPiB1bml0ID0gXCJtY19jb3VudF8xNl9iZVwiICAgW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvdW50MTZiZTQgOiBjdHI6Ynl0ZXMgLT4gYnl0ZXMgLT4gb2ZmOmludCAtPiBibG9ja3M6aW50IC0+IHVuaXQgPSBcIm1jX2NvdW50XzE2X2JlXzRcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBtaXNjX21vZGUgOiB1bml0IC0+IGludCA9IFwibWNfbWlzY19tb2RlXCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgX2RldGVjdF9jcHVfZmVhdHVyZXMgOiB1bml0IC0+IHVuaXQgPSBcIm1jX2RldGVjdF9jcHVfZmVhdHVyZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgX2RldGVjdF9lbnRyb3B5IDogdW5pdCAtPiB1bml0ID0gXCJtY19lbnRyb3B5X2RldGVjdFwiXG5cbmxldCAoKSA9XG4gIF9kZXRlY3RfY3B1X2ZlYXR1cmVzICgpO1xuICBfZGV0ZWN0X2VudHJvcHkgKClcbiIsIigqKiBbVW5jb21tb25dIGlzIGEgW0NvbW1vbl0sIG5vdyB3aXRoIGxlc3MgbmFtZSBjbGFzaGVzLiAqKVxuXG5sZXQga2FzcHJpbnRmIGsgZm10ID1cbiAgRm9ybWF0LihrZnByaW50ZiAoZnVuIF8gLT4gayAoZmx1c2hfc3RyX2Zvcm1hdHRlciAoKSkpIHN0cl9mb3JtYXR0ZXIgZm10KVxuXG5sZXQgaW52YWxpZF9hcmcgZm10ID0ga2FzcHJpbnRmIGludmFsaWRfYXJnIChcIk1pcmFnZV9jcnlwdG86IFwiIF5eIGZtdClcblxubGV0ICgvLykgeCB5ID1cbiAgaWYgeSA8IDEgdGhlbiByYWlzZSBEaXZpc2lvbl9ieV96ZXJvIGVsc2VcbiAgICBpZiB4ID4gMCB0aGVuIDEgKyAoKHggLSAxKSAvIHkpIGVsc2UgMCBbQEBpbmxpbmVdXG5cbmxldCBpbWluIChhIDogaW50KSBiID0gaWYgYSA8IGIgdGhlbiBhIGVsc2UgYlxubGV0IGltYXggKGEgOiBpbnQpIGIgPSBpZiBhIDwgYiB0aGVuIGIgZWxzZSBhXG5cbnR5cGUgJ2EgaXRlciA9ICgnYSAtPiB1bml0KSAtPiB1bml0XG5cbmxldCBpdGVyMiBhIGIgICBmID0gZiBhOyBmIGJcbmxldCBpdGVyMyBhIGIgYyBmID0gZiBhOyBmIGI7IGYgY1xuXG5sZXQgdW5zYWZlX3hvcl9pbnRvIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgbiA9XG4gIE5hdGl2ZS54b3JfaW50b19ieXRlcyBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiBuXG5cbmxldCB4b3IgYSBiID1cbiAgYXNzZXJ0IChTdHJpbmcubGVuZ3RoIGEgPSBTdHJpbmcubGVuZ3RoIGIpO1xuICBsZXQgYicgPSBCeXRlcy5vZl9zdHJpbmcgYiBpblxuICB1bnNhZmVfeG9yX2ludG8gYSB+c3JjX29mZjowIGInIH5kc3Rfb2ZmOjAgKEJ5dGVzLmxlbmd0aCBiJyk7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYidcbiIsIm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSBpdGVyID0gJ2EgVW5jb21tb24uaXRlclxuXG4gIHR5cGUgdFxuICB2YWwgbWFjX3NpemUgOiBpbnRcblxuICB2YWwgZW1wdHkgOiBrZXk6c3RyaW5nIC0+IHRcbiAgdmFsIGZlZWQgOiB0IC0+IHN0cmluZyAtPiB0XG4gIHZhbCBmZWVkaSA6IHQgLT4gc3RyaW5nIGl0ZXIgLT4gdFxuICB2YWwgZ2V0IDogdCAtPiBzdHJpbmdcblxuICB2YWwgbWFjIDoga2V5OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBtYWNpIDoga2V5OnN0cmluZyAtPiBzdHJpbmcgaXRlciAtPiBzdHJpbmdcbiAgdmFsIG1hY19pbnRvIDoga2V5OnN0cmluZyAtPiAoc3RyaW5nICogaW50ICogaW50KSBsaXN0IC0+IGJ5dGVzIC0+IGRzdF9vZmY6aW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9tYWNfaW50byA6IGtleTpzdHJpbmcgLT4gKHN0cmluZyAqIGludCAqIGludCkgbGlzdCAtPiBieXRlcyAtPiBkc3Rfb2ZmOmludCAtPiB1bml0XG5lbmRcblxubW9kdWxlIEl0IDogUyA9IHN0cnVjdFxuICB0eXBlICdhIGl0ZXIgPSAnYSBVbmNvbW1vbi5pdGVyXG5cbiAgbW9kdWxlIFAgPSBOYXRpdmUuUG9seTEzMDVcbiAgbGV0IG1hY19zaXplID0gUC5tYWNfc2l6ZSAoKVxuXG4gIHR5cGUgdCA9IGJ5dGVzXG5cbiAgbGV0IGR1cCA9IEJ5dGVzLmNvcHlcblxuICBsZXQgZW1wdHkgfmtleSA9XG4gICAgbGV0IGN0eCA9IEJ5dGVzLmNyZWF0ZSAoUC5jdHhfc2l6ZSAoKSkgaW5cbiAgICBpZiBTdHJpbmcubGVuZ3RoIGtleSA8PiAzMiB0aGVuIGludmFsaWRfYXJnIFwiUG9seTEzMDUga2V5IG11c3QgYmUgMzIgYnl0ZXNcIiA7XG4gICAgUC5pbml0IGN0eCBrZXkgO1xuICAgIGN0eFxuXG4gIGxldCB1cGRhdGUgY3R4IGRhdGEgPVxuICAgIFAudXBkYXRlIGN0eCBkYXRhIDAgKFN0cmluZy5sZW5ndGggZGF0YSlcblxuICBsZXQgZmVlZCBjdHggY3MgPVxuICAgIGxldCB0ID0gZHVwIGN0eCBpblxuICAgIHVwZGF0ZSB0IGNzIDtcbiAgICB0XG5cbiAgbGV0IGZlZWRpIGN0eCBpdGVyID1cbiAgICBsZXQgdCA9IGR1cCBjdHggaW5cbiAgICBpdGVyICh1cGRhdGUgdCkgO1xuICAgIHRcblxuICBsZXQgZmluYWwgY3R4ID1cbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIG1hY19zaXplIGluXG4gICAgUC5maW5hbGl6ZSBjdHggcmVzIDA7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuICBsZXQgZ2V0IGN0eCA9IGZpbmFsIChkdXAgY3R4KVxuXG4gIGxldCBtYWMgfmtleSBkYXRhID0gZmVlZCAoZW1wdHkgfmtleSkgZGF0YSB8PiBmaW5hbFxuXG4gIGxldCBtYWNpIH5rZXkgaXRlciA9IGZlZWRpIChlbXB0eSB+a2V5KSBpdGVyIHw+IGZpbmFsXG5cbiAgbGV0IHVuc2FmZV9tYWNfaW50byB+a2V5IGRhdGFzIGRzdCB+ZHN0X29mZiA9XG4gICAgbGV0IGN0eCA9IGVtcHR5IH5rZXkgaW5cbiAgICBMaXN0Lml0ZXIgKGZ1biAoZCwgb2ZmLCBsZW4pIC0+IFAudXBkYXRlIGN0eCBkIG9mZiBsZW4pIGRhdGFzO1xuICAgIFAuZmluYWxpemUgY3R4IGRzdCBkc3Rfb2ZmXG5cbiAgbGV0IG1hY19pbnRvIH5rZXkgZGF0YXMgZHN0IH5kc3Rfb2ZmID1cbiAgICBpZiBCeXRlcy5sZW5ndGggZHN0IC0gZHN0X29mZiA8IG1hY19zaXplIHRoZW5cbiAgICAgIFVuY29tbW9uLmludmFsaWRfYXJnIFwiUG9seTEzMDU6IGRzdCBsZW5ndGggJXUgLSBvZmYgJXUgPCBsZW4gJXVcIlxuICAgICAgICAoQnl0ZXMubGVuZ3RoIGRzdCkgZHN0X29mZiBtYWNfc2l6ZTtcbiAgICBpZiBkc3Rfb2ZmIDwgMCB0aGVuXG4gICAgICBVbmNvbW1vbi5pbnZhbGlkX2FyZyBcIlBvbHkxMzA1OiBkc3Rfb2ZmICV1IDwgMFwiIGRzdF9vZmY7XG4gICAgbGV0IGN0eCA9IGVtcHR5IH5rZXkgaW5cbiAgICBMaXN0Lml0ZXIgKGZ1biAoZCwgb2ZmLCBsZW4pIC0+XG4gICAgICAgIGlmIG9mZiA8IDAgdGhlblxuICAgICAgICAgIFVuY29tbW9uLmludmFsaWRfYXJnIFwiUG9seTEzMDU6IGQgb2ZmICV1IDwgMFwiIG9mZjtcbiAgICAgICAgaWYgU3RyaW5nLmxlbmd0aCBkIC0gb2ZmIDwgbGVuIHRoZW5cbiAgICAgICAgICBVbmNvbW1vbi5pbnZhbGlkX2FyZyBcIlBvbHkxMzA1OiBkIGxlbmd0aCAldSAtIG9mZiAldSA8IGxlbiAldVwiXG4gICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBkKSBvZmYgbGVuO1xuICAgICAgICBQLnVwZGF0ZSBjdHggZCBvZmYgbGVuKVxuICAgICAgZGF0YXM7XG4gICAgUC5maW5hbGl6ZSBjdHggZHN0IGRzdF9vZmZcbmVuZFxuIiwib3BlbiBVbmNvbW1vblxuXG5sZXQgYmxvY2tfc2l6ZSA9IDE2XG5cbmxldCBmbGFncyBiaXQ2IGxlbjEgbGVuMiA9XG4gIGJpdDYgbHNsIDYgKyBsZW4xIGxzbCAzICsgbGVuMlxuXG5sZXQgZW5jb2RlX2xlbiBidWYgfm9mZiBzaXplIHZhbHVlID1cbiAgbGV0IHJlYyBhc3MgbnVtID0gZnVuY3Rpb25cbiAgICB8IDAgLT4gQnl0ZXMuc2V0X3VpbnQ4IGJ1ZiBvZmYgbnVtXG4gICAgfCBtIC0+XG4gICAgICBCeXRlcy5zZXRfdWludDggYnVmIChvZmYgKyBtKSAobnVtIGxhbmQgMHhmZik7XG4gICAgICAoYXNzIFtAdGFpbGNhbGxdKSAobnVtIGxzciA4KSAocHJlZCBtKVxuICBpblxuICBhc3MgdmFsdWUgKHByZWQgc2l6ZSlcblxubGV0IHNldF9mb3JtYXQgYnVmID8ob2ZmID0gMCkgbm9uY2UgZmxhZ192YWwgdmFsdWUgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggbm9uY2UgaW5cbiAgbGV0IHNtYWxsX3EgPSAxNSAtIG4gaW5cbiAgKCogZmlyc3Qgb2N0ZXQgYmxvY2s6XG4gICAgIDAgICAgICAgICAgOiBmbGFnc1xuICAgICAxLi4xNSAtIHEgIDogTlxuICAgICAxNiAtIHEuLjE1IDogUSAqKVxuICBCeXRlcy5zZXRfdWludDggYnVmIG9mZiBmbGFnX3ZhbDtcbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIG5vbmNlIDAgYnVmIChvZmYgKyAxKSBuO1xuICBlbmNvZGVfbGVuIGJ1ZiB+b2ZmOihvZmYgKyBuICsgMSkgc21hbGxfcSB2YWx1ZVxuXG5sZXQgZ2VuX2FkYXRhIGEgPVxuICBsZXQgbGxlbiwgc2V0X2xsZW4gPVxuICAgIG1hdGNoIFN0cmluZy5sZW5ndGggYSB3aXRoXG4gICAgfCB4IHdoZW4geCA8ICgxIGxzbCAxNiAtIDEgbHNsIDgpIC0+XG4gICAgICAyLCAoZnVuIGJ1ZiBvZmYgLT4gQnl0ZXMuc2V0X3VpbnQxNl9iZSBidWYgb2ZmIHgpXG4gICAgfCB4IHdoZW4gU3lzLmludF9zaXplIDwgMzIgfHwgeCA8ICgxIGxzbCAzMikgLT5cbiAgICAgIDYsIChmdW4gYnVmIG9mZiAtPlxuICAgICAgICAgIEJ5dGVzLnNldF91aW50MTZfYmUgYnVmIG9mZiAweGZmZmU7XG4gICAgICAgICAgQnl0ZXMuc2V0X2ludDMyX2JlIGJ1ZiAob2ZmICsgMikgKEludDMyLm9mX2ludCB4KSlcbiAgICB8IHggLT5cbiAgICAgIDEwLCAoZnVuIGJ1ZiBvZmYgLT5cbiAgICAgICAgICBCeXRlcy5zZXRfdWludDE2X2JlIGJ1ZiBvZmYgMHhmZmZmO1xuICAgICAgICAgIEJ5dGVzLnNldF9pbnQ2NF9iZSBidWYgKG9mZiArIDIpIChJbnQ2NC5vZl9pbnQgeCkpXG4gIGluXG4gIGxldCB0b19wYWQgPVxuICAgIGxldCBsZWZ0b3ZlciA9IChsbGVuICsgU3RyaW5nLmxlbmd0aCBhKSBtb2QgYmxvY2tfc2l6ZSBpblxuICAgIGJsb2NrX3NpemUgLSBsZWZ0b3ZlclxuICBpblxuICBsbGVuICsgU3RyaW5nLmxlbmd0aCBhICsgdG9fcGFkLFxuICBmdW4gYnVmIG9mZiAtPlxuICAgIHNldF9sbGVuIGJ1ZiBvZmY7XG4gICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIGEgMCBidWYgKG9mZiArIGxsZW4pIChTdHJpbmcubGVuZ3RoIGEpO1xuICAgIEJ5dGVzLnVuc2FmZV9maWxsIGJ1ZiAob2ZmICsgbGxlbiArIFN0cmluZy5sZW5ndGggYSkgdG9fcGFkICdcXDAwMCdcblxubGV0IGdlbl9jdHIgbm9uY2UgaSA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBub25jZSBpblxuICBsZXQgc21hbGxfcSA9IDE1IC0gbiBpblxuICBsZXQgZmxhZ192YWwgPSBmbGFncyAwIDAgKHNtYWxsX3EgLSAxKSBpblxuICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIDE2IGluXG4gIHNldF9mb3JtYXQgYnVmIG5vbmNlIGZsYWdfdmFsIGk7XG4gIGJ1ZlxuXG5sZXQgcHJlcGFyZV9oZWFkZXIgbm9uY2UgYWRhdGEgcGxlbiB0bGVuID1cbiAgbGV0IHNtYWxsX3EgPSAxNSAtIFN0cmluZy5sZW5ndGggbm9uY2UgaW5cbiAgbGV0IGI2ID0gaWYgU3RyaW5nLmxlbmd0aCBhZGF0YSA9IDAgdGhlbiAwIGVsc2UgMSBpblxuICBsZXQgZmxhZ192YWwgPSBmbGFncyBiNiAoKHRsZW4gLSAyKSAvIDIpIChzbWFsbF9xIC0gMSkgaW5cbiAgaWYgU3RyaW5nLmxlbmd0aCBhZGF0YSA9IDAgdGhlblxuICAgIGxldCBoZHIgPSBCeXRlcy5jcmVhdGUgMTYgaW5cbiAgICBzZXRfZm9ybWF0IGhkciBub25jZSBmbGFnX3ZhbCBwbGVuO1xuICAgIGhkclxuICBlbHNlXG4gICAgbGV0IGxlbiwgc2V0ID0gZ2VuX2FkYXRhIGFkYXRhIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAoMTYgKyBsZW4pIGluXG4gICAgc2V0X2Zvcm1hdCBidWYgbm9uY2UgZmxhZ192YWwgcGxlbjtcbiAgICBzZXQgYnVmIDE2O1xuICAgIGJ1ZlxuXG50eXBlIG1vZGUgPSBFbmNyeXB0IHwgRGVjcnlwdFxuXG5sZXQgY3J5cHRvX2NvcmVfaW50byB+Y2lwaGVyIH5tb2RlIH5rZXkgfm5vbmNlIH5hZGF0YSBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGxlbiA9XG4gIGxldCBjYmNoZWFkZXIgPSBwcmVwYXJlX2hlYWRlciBub25jZSBhZGF0YSBsZW4gYmxvY2tfc2l6ZSBpblxuXG4gIGxldCBzbWFsbF9xID0gMTUgLSBTdHJpbmcubGVuZ3RoIG5vbmNlIGluXG4gIGxldCBjdHJfZmxhZ192YWwgPSBmbGFncyAwIDAgKHNtYWxsX3EgLSAxKSBpblxuICBsZXQgY3RyYmxvY2sgaSBibG9jayBkc3Rfb2ZmID1cbiAgICBCeXRlcy5zZXRfdWludDggYmxvY2sgZHN0X29mZiBjdHJfZmxhZ192YWw7XG4gICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIG5vbmNlIDAgYmxvY2sgKGRzdF9vZmYgKyAxKSAoU3RyaW5nLmxlbmd0aCBub25jZSk7XG4gICAgZW5jb2RlX2xlbiBibG9jayB+b2ZmOihkc3Rfb2ZmICsgU3RyaW5nLmxlbmd0aCBub25jZSArIDEpIHNtYWxsX3EgaTtcbiAgICBjaXBoZXIgfmtleSAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBibG9jaykgfnNyY19vZmY6ZHN0X29mZiBibG9jayB+ZHN0X29mZlxuICBpblxuXG4gIGxldCBjYmMgaXYgc3JjX29mZiBibG9jayBkc3Rfb2ZmID1cbiAgICB1bnNhZmVfeG9yX2ludG8gaXYgfnNyY19vZmYgYmxvY2sgfmRzdF9vZmYgYmxvY2tfc2l6ZSA7XG4gICAgY2lwaGVyIH5rZXkgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYmxvY2spIH5zcmNfb2ZmOmRzdF9vZmYgYmxvY2sgfmRzdF9vZmZcbiAgaW5cblxuICBsZXQgaXYgPVxuICAgIGxldCByZWMgZG9pdCBpdiBpdl9vZmYgYmxvY2sgYmxvY2tfb2ZmID1cbiAgICAgIG1hdGNoIEJ5dGVzLmxlbmd0aCBibG9jayAtIGJsb2NrX29mZiB3aXRoXG4gICAgICB8IDAgLT4gQnl0ZXMuc3ViIGl2IGl2X29mZiBibG9ja19zaXplXG4gICAgICB8IF8gLT5cbiAgICAgICAgIGNiYyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBpdikgaXZfb2ZmIGJsb2NrIGJsb2NrX29mZjtcbiAgICAgICAgIChkb2l0IFtAdGFpbGNhbGxdKSBibG9jayBibG9ja19vZmYgYmxvY2sgKGJsb2NrX29mZiArIGJsb2NrX3NpemUpXG4gICAgaW5cbiAgICBkb2l0IChCeXRlcy5tYWtlIGJsb2NrX3NpemUgJ1xceDAwJykgMCBjYmNoZWFkZXIgMFxuICBpblxuXG4gIGxldCByZWMgbG9vcCBjdHIgc3JjIHNyY19vZmYgZHN0IGRzdF9vZmYgbGVuID1cbiAgICBsZXQgY2JjYmxvY2ssIGNiY19vZmYgPVxuICAgICAgbWF0Y2ggbW9kZSB3aXRoXG4gICAgICB8IEVuY3J5cHQgLT4gc3JjLCBzcmNfb2ZmXG4gICAgICB8IERlY3J5cHQgLT4gQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkc3QsIGRzdF9vZmZcbiAgICBpblxuICAgIGlmIGxlbiA9IDAgdGhlblxuICAgICAgKClcbiAgICBlbHNlIGlmIGxlbiA8IGJsb2NrX3NpemUgdGhlbiBiZWdpblxuICAgICAgbGV0IGJ1ZiA9IEJ5dGVzLm1ha2UgYmxvY2tfc2l6ZSAnXFx4MDAnIGluXG4gICAgICBCeXRlcy51bnNhZmVfYmxpdCBkc3QgZHN0X29mZiBidWYgMCBsZW4gO1xuICAgICAgY3RyYmxvY2sgY3RyIGJ1ZiAwIDtcbiAgICAgIEJ5dGVzLnVuc2FmZV9ibGl0IGJ1ZiAwIGRzdCBkc3Rfb2ZmIGxlbiA7XG4gICAgICB1bnNhZmVfeG9yX2ludG8gc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiBsZW4gO1xuICAgICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIGNiY2Jsb2NrIGNiY19vZmYgYnVmIDAgbGVuIDtcbiAgICAgIEJ5dGVzLnVuc2FmZV9maWxsIGJ1ZiBsZW4gKGJsb2NrX3NpemUgLSBsZW4pICdcXHgwMCc7XG4gICAgICBjYmMgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmKSAwIGl2IDBcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgY3RyYmxvY2sgY3RyIGRzdCBkc3Rfb2ZmIDtcbiAgICAgIHVuc2FmZV94b3JfaW50byBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGJsb2NrX3NpemUgO1xuICAgICAgY2JjIGNiY2Jsb2NrIGNiY19vZmYgaXYgMCA7XG4gICAgICAobG9vcCBbQHRhaWxjYWxsXSkgKHN1Y2MgY3RyKSBzcmMgKHNyY19vZmYgKyBibG9ja19zaXplKSBkc3QgKGRzdF9vZmYgKyBibG9ja19zaXplKSAobGVuIC0gYmxvY2tfc2l6ZSlcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCAxIHNyYyBzcmNfb2ZmIGRzdCBkc3Rfb2ZmIGxlbjtcbiAgaXZcblxubGV0IGNyeXB0b19jb3JlIH5jaXBoZXIgfm1vZGUgfmtleSB+bm9uY2UgfmFkYXRhIGRhdGEgPVxuICBsZXQgZGF0YWxlbiA9IFN0cmluZy5sZW5ndGggZGF0YSBpblxuICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIGRhdGFsZW4gaW5cbiAgbGV0IHQgPSBjcnlwdG9fY29yZV9pbnRvIH5jaXBoZXIgfm1vZGUgfmtleSB+bm9uY2UgfmFkYXRhIGRhdGEgfnNyY19vZmY6MCBkc3QgfmRzdF9vZmY6MCBkYXRhbGVuIGluXG4gIGRzdCwgdFxuXG5sZXQgY3J5cHRvX3QgdCBub25jZSBjaXBoZXIga2V5ID1cbiAgbGV0IGN0ciA9IGdlbl9jdHIgbm9uY2UgMCBpblxuICBjaXBoZXIgfmtleSAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjdHIpIH5zcmNfb2ZmOjAgY3RyIH5kc3Rfb2ZmOjAgO1xuICB1bnNhZmVfeG9yX2ludG8gKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY3RyKSB+c3JjX29mZjowIHQgfmRzdF9vZmY6MCAoQnl0ZXMubGVuZ3RoIHQpXG5cbmxldCB1bnNhZmVfZ2VuZXJhdGlvbl9lbmNyeXB0aW9uX2ludG8gfmNpcGhlciB+a2V5IH5ub25jZSB+YWRhdGEgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiB+dGFnX29mZiBsZW4gPVxuICBsZXQgdCA9IGNyeXB0b19jb3JlX2ludG8gfmNpcGhlciB+bW9kZTpFbmNyeXB0IH5rZXkgfm5vbmNlIH5hZGF0YSBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGxlbiBpblxuICBjcnlwdG9fdCB0IG5vbmNlIGNpcGhlciBrZXkgO1xuICBCeXRlcy51bnNhZmVfYmxpdCB0IDAgZHN0IHRhZ19vZmYgYmxvY2tfc2l6ZVxuXG5sZXQgdW5zYWZlX2RlY3J5cHRpb25fdmVyaWZpY2F0aW9uX2ludG8gfmNpcGhlciB+a2V5IH5ub25jZSB+YWRhdGEgc3JjIH5zcmNfb2ZmIH50YWdfb2ZmIGRzdCB+ZHN0X29mZiBsZW4gPVxuICBsZXQgdGFnID0gU3RyaW5nLnN1YiBzcmMgdGFnX29mZiBibG9ja19zaXplIGluXG4gIGxldCB0ID0gY3J5cHRvX2NvcmVfaW50byB+Y2lwaGVyIH5tb2RlOkRlY3J5cHQgfmtleSB+bm9uY2UgfmFkYXRhIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgbGVuIGluXG4gIGNyeXB0b190IHQgbm9uY2UgY2lwaGVyIGtleSA7XG4gIEVxYWYuZXF1YWwgdGFnIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHQpXG4iLCIoKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vYWJlYXVtb250L29jYW1sLWNoYWNoYS5naXQgKilcblxub3BlbiBVbmNvbW1vblxuXG5sZXQgYmxvY2sgPSA2NFxuXG50eXBlIGtleSA9IHN0cmluZ1xuXG5sZXQgb2Zfc2VjcmV0IGEgPSBhXG5cbmxldCBjaGFjaGEyMF9ibG9jayBzdGF0ZSBpZHgga2V5X3N0cmVhbSA9XG4gIE5hdGl2ZS5DaGFjaGEucm91bmQgMTAgc3RhdGUga2V5X3N0cmVhbSBpZHhcblxubGV0IGluaXQgY3RyIH5rZXkgfm5vbmNlID1cbiAgbGV0IGN0cl9vZmYgPSA0OCBpblxuICBsZXQgc2V0X2N0cjMyIGIgdiA9IEJ5dGVzLnNldF9pbnQzMl9sZSBiIGN0cl9vZmYgdlxuICBhbmQgc2V0X2N0cjY0IGIgdiA9IEJ5dGVzLnNldF9pbnQ2NF9sZSBiIGN0cl9vZmYgdlxuICBpblxuICBsZXQgaW5jMzIgYiA9IHNldF9jdHIzMiBiIChJbnQzMi5hZGQgKEJ5dGVzLmdldF9pbnQzMl9sZSBiIGN0cl9vZmYpIDFsKVxuICBhbmQgaW5jNjQgYiA9IHNldF9jdHI2NCBiIChJbnQ2NC5hZGQgKEJ5dGVzLmdldF9pbnQ2NF9sZSBiIGN0cl9vZmYpIDFMKVxuICBpblxuICBsZXQgcywga2V5LCBpbml0X2N0ciwgbm9uY2Vfb2ZmLCBpbmMgPVxuICAgIG1hdGNoIFN0cmluZy5sZW5ndGgga2V5LCBTdHJpbmcubGVuZ3RoIG5vbmNlLCBJbnQ2NC5zaGlmdF9yaWdodCBjdHIgMzIgPSAwTCB3aXRoXG4gICAgfCAzMiwgMTIsIHRydWUgLT5cbiAgICAgIGxldCBjdHIgPSBJbnQ2NC50b19pbnQzMiBjdHIgaW5cbiAgICAgIFwiZXhwYW5kIDMyLWJ5dGUga1wiLCBrZXksIChmdW4gYiAtPiBzZXRfY3RyMzIgYiBjdHIpLCA1MiwgaW5jMzJcbiAgICB8IDMyLCAxMiwgZmFsc2UgLT5cbiAgICAgIGludmFsaWRfYXJnIFwiQ291bnRlciB0b28gYmlnIGZvciBJRVRGIG1vZGUgKDMyIGJpdCBjb3VudGVyKVwiXG4gICAgfCAzMiwgOCwgXyAtPlxuICAgICAgXCJleHBhbmQgMzItYnl0ZSBrXCIsIGtleSwgKGZ1biBiIC0+IHNldF9jdHI2NCBiIGN0ciksIDU2LCBpbmM2NFxuICAgIHwgMTYsIDgsIF8gLT5cbiAgICAgIGxldCBrID0ga2V5IF4ga2V5IGluXG4gICAgICBcImV4cGFuZCAxNi1ieXRlIGtcIiwgaywgKGZ1biBiIC0+IHNldF9jdHI2NCBiIGN0ciksIDU2LCBpbmM2NFxuICAgIHwgXyAtPiBpbnZhbGlkX2FyZyBcIlZhbGlkIHBhcmFtZXRlcnMgYXJlIG5vbmNlIDEyIGJ5dGVzIGFuZCBrZXkgMzIgYnl0ZXMgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb3VudGVyIDMyIGJpdCksIG9yIG5vbmNlIDggYnl0ZSBhbmQga2V5IDE2IG9yIDMyIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlcyAoY291bnRlciA2NCBiaXQpLlwiXG4gIGluXG4gIGxldCBzdGF0ZSA9IEJ5dGVzLmNyZWF0ZSBibG9jayBpblxuICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgcyAwIHN0YXRlIDAgMTYgO1xuICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcga2V5IDAgc3RhdGUgMTYgMzIgO1xuICBpbml0X2N0ciBzdGF0ZSA7XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBub25jZSAwIHN0YXRlIG5vbmNlX29mZiAoU3RyaW5nLmxlbmd0aCBub25jZSkgO1xuICBzdGF0ZSwgaW5jXG5cbmxldCBjcnlwdF9pbnRvIH5rZXkgfm5vbmNlIH5jdHIgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiBsZW4gPVxuICBsZXQgc3RhdGUsIGluYyA9IGluaXQgY3RyIH5rZXkgfm5vbmNlIGluXG4gIGxldCBibG9ja19jb3VudCA9IGxlbiAvLyBibG9jayBpblxuICBsZXQgbGFzdF9sZW4gPVxuICAgIGxldCBsYXN0ID0gbGVuIG1vZCBibG9jayBpblxuICAgIGlmIGxhc3QgPSAwIHRoZW4gYmxvY2sgZWxzZSBsYXN0XG4gIGluXG4gIGxldCByZWMgbG9vcCBpID0gZnVuY3Rpb25cbiAgICB8IDAgLT4gKClcbiAgICB8IDEgLT5cbiAgICAgIGlmIGxhc3RfbGVuID0gYmxvY2sgdGhlbiBiZWdpblxuICAgICAgICBjaGFjaGEyMF9ibG9jayBzdGF0ZSAoZHN0X29mZiArIGkpIGRzdCA7XG4gICAgICAgIE5hdGl2ZS54b3JfaW50b19ieXRlcyBzcmMgKHNyY19vZmYgKyBpKSBkc3QgKGRzdF9vZmYgKyBpKSBibG9ja1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBibG9jayBpblxuICAgICAgICBjaGFjaGEyMF9ibG9jayBzdGF0ZSAwIGJ1ZiA7XG4gICAgICAgIE5hdGl2ZS54b3JfaW50b19ieXRlcyBzcmMgKHNyY19vZmYgKyBpKSBidWYgMCBsYXN0X2xlbiA7XG4gICAgICAgIEJ5dGVzLnVuc2FmZV9ibGl0IGJ1ZiAwIGRzdCAoZHN0X29mZiArIGkpIGxhc3RfbGVuXG4gICAgICBlbmRcbiAgICB8IG4gLT5cbiAgICAgIGNoYWNoYTIwX2Jsb2NrIHN0YXRlIChkc3Rfb2ZmICsgaSkgZHN0IDtcbiAgICAgIE5hdGl2ZS54b3JfaW50b19ieXRlcyBzcmMgKHNyY19vZmYgKyBpKSBkc3QgKGRzdF9vZmYgKyBpKSBibG9jayA7XG4gICAgICBpbmMgc3RhdGU7XG4gICAgICAobG9vcCBbQHRhaWxjYWxsXSkgKGkgKyBibG9jaykgKG4gLSAxKVxuICBpblxuICBsb29wIDAgYmxvY2tfY291bnRcblxubGV0IGNyeXB0IH5rZXkgfm5vbmNlID8oY3RyID0gMEwpIGRhdGEgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggZGF0YSBpblxuICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIGwgaW5cbiAgY3J5cHRfaW50byB+a2V5IH5ub25jZSB+Y3RyIGRhdGEgfnNyY19vZmY6MCByZXMgfmRzdF9vZmY6MCBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG5tb2R1bGUgUCA9IFBvbHkxMzA1Lkl0XG5cbmxldCB0YWdfc2l6ZSA9IFAubWFjX3NpemVcblxubGV0IGdlbmVyYXRlX3BvbHkxMzA1X2tleSB+a2V5IH5ub25jZSA9XG4gIGNyeXB0IH5rZXkgfm5vbmNlIChTdHJpbmcubWFrZSAzMiAnXFwwMDAnKVxuXG5sZXQgbWFjX2ludG8gfmtleSB+YWRhdGEgc3JjIH5zcmNfb2ZmIGxlbiBkc3QgfmRzdF9vZmYgPVxuICBsZXQgcGFkMTYgbCA9XG4gICAgbGV0IGxlbiA9IGwgbW9kIDE2IGluXG4gICAgaWYgbGVuID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcubWFrZSAoMTYgLSBsZW4pICdcXDAwMCdcbiAgYW5kIGxlbl9idWYgPVxuICAgIGxldCBkYXRhID0gQnl0ZXMuY3JlYXRlIDE2IGluXG4gICAgQnl0ZXMuc2V0X2ludDY0X2xlIGRhdGEgMCAoSW50NjQub2ZfaW50IChTdHJpbmcubGVuZ3RoIGFkYXRhKSk7XG4gICAgQnl0ZXMuc2V0X2ludDY0X2xlIGRhdGEgOCAoSW50NjQub2ZfaW50IGxlbik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkYXRhXG4gIGluXG4gIGxldCBwMSA9IHBhZDE2IChTdHJpbmcubGVuZ3RoIGFkYXRhKSBhbmQgcDIgPSBwYWQxNiBsZW4gaW5cbiAgUC51bnNhZmVfbWFjX2ludG8gfmtleSBbIGFkYXRhLCAwLCBTdHJpbmcubGVuZ3RoIGFkYXRhIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxLCAwLCBTdHJpbmcubGVuZ3RoIHAxIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYywgc3JjX29mZiwgbGVuIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyLCAwLCBTdHJpbmcubGVuZ3RoIHAyIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbl9idWYsIDAsIFN0cmluZy5sZW5ndGggbGVuX2J1ZiBdXG4gICAgZHN0IH5kc3Rfb2ZmXG5cbmxldCB1bnNhZmVfYXV0aGVudGljYXRlX2VuY3J5cHRfaW50byB+a2V5IH5ub25jZSA/KGFkYXRhID0gXCJcIikgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiB+dGFnX29mZiBsZW4gPVxuICBsZXQgcG9seTEzMDVfa2V5ID0gZ2VuZXJhdGVfcG9seTEzMDVfa2V5IH5rZXkgfm5vbmNlIGluXG4gIGNyeXB0X2ludG8gfmtleSB+bm9uY2UgfmN0cjoxTCBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGxlbjtcbiAgbWFjX2ludG8gfmtleTpwb2x5MTMwNV9rZXkgfmFkYXRhIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGRzdCkgfnNyY19vZmY6ZHN0X29mZiBsZW4gZHN0IH5kc3Rfb2ZmOnRhZ19vZmZcblxubGV0IGF1dGhlbnRpY2F0ZV9lbmNyeXB0X2ludG8gfmtleSB+bm9uY2UgP2FkYXRhIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgfnRhZ19vZmYgbGVuID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzcmMgLSBzcmNfb2ZmIDwgbGVuIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkNoYWNoYTIwOiBzcmMgbGVuZ3RoICV1IC0gc3JjX29mZiAldSA8IGxlbiAldVwiXG4gICAgICAoU3RyaW5nLmxlbmd0aCBzcmMpIHNyY19vZmYgbGVuO1xuICBpZiBCeXRlcy5sZW5ndGggZHN0IC0gZHN0X29mZiA8IGxlbiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJDaGFjaGEyMDogZHN0IGxlbmd0aCAldSAtIGRzdF9vZmYgJXUgPCBsZW4gJXVcIlxuICAgICAgKEJ5dGVzLmxlbmd0aCBkc3QpIGRzdF9vZmYgbGVuO1xuICBpZiBCeXRlcy5sZW5ndGggZHN0IC0gdGFnX29mZiA8IHRhZ19zaXplIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkNoYWNoYTIwOiBkc3QgbGVuZ3RoICV1IC0gdGFnX29mZiAldSA8IHRhZ19zaXplICV1XCJcbiAgICAgIChCeXRlcy5sZW5ndGggZHN0KSB0YWdfb2ZmIHRhZ19zaXplO1xuICB1bnNhZmVfYXV0aGVudGljYXRlX2VuY3J5cHRfaW50byB+a2V5IH5ub25jZSA/YWRhdGEgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiB+dGFnX29mZiBsZW5cblxubGV0IGF1dGhlbnRpY2F0ZV9lbmNyeXB0IH5rZXkgfm5vbmNlID9hZGF0YSBkYXRhID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIGRhdGEgaW5cbiAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSAobCArIHRhZ19zaXplKSBpblxuICB1bnNhZmVfYXV0aGVudGljYXRlX2VuY3J5cHRfaW50byB+a2V5IH5ub25jZSA/YWRhdGEgZGF0YSB+c3JjX29mZjowIGRzdCB+ZHN0X29mZjowIH50YWdfb2ZmOmwgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkc3RcblxubGV0IGF1dGhlbnRpY2F0ZV9lbmNyeXB0X3RhZyB+a2V5IH5ub25jZSA/YWRhdGEgZGF0YSA9XG4gIGxldCByID0gYXV0aGVudGljYXRlX2VuY3J5cHQgfmtleSB+bm9uY2UgP2FkYXRhIGRhdGEgaW5cbiAgU3RyaW5nLnN1YiByIDAgKFN0cmluZy5sZW5ndGggZGF0YSksIFN0cmluZy5zdWIgciAoU3RyaW5nLmxlbmd0aCBkYXRhKSB0YWdfc2l6ZVxuXG5sZXQgdW5zYWZlX2F1dGhlbnRpY2F0ZV9kZWNyeXB0X2ludG8gfmtleSB+bm9uY2UgPyhhZGF0YSA9IFwiXCIpIHNyYyB+c3JjX29mZiB+dGFnX29mZiBkc3QgfmRzdF9vZmYgbGVuID1cbiAgbGV0IHBvbHkxMzA1X2tleSA9IGdlbmVyYXRlX3BvbHkxMzA1X2tleSB+a2V5IH5ub25jZSBpblxuICBsZXQgY3RhZyA9IEJ5dGVzLmNyZWF0ZSB0YWdfc2l6ZSBpblxuICBtYWNfaW50byB+a2V5OnBvbHkxMzA1X2tleSB+YWRhdGEgc3JjIH5zcmNfb2ZmIGxlbiBjdGFnIH5kc3Rfb2ZmOjA7XG4gIGNyeXB0X2ludG8gfmtleSB+bm9uY2UgfmN0cjoxTCBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGxlbjtcbiAgRXFhZi5lcXVhbCAoU3RyaW5nLnN1YiBzcmMgdGFnX29mZiB0YWdfc2l6ZSkgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY3RhZylcblxubGV0IGF1dGhlbnRpY2F0ZV9kZWNyeXB0X2ludG8gfmtleSB+bm9uY2UgP2FkYXRhIHNyYyB+c3JjX29mZiB+dGFnX29mZiBkc3QgfmRzdF9vZmYgbGVuID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzcmMgLSBzcmNfb2ZmIDwgbGVuIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkNoYWNoYTIwOiBzcmMgbGVuZ3RoICV1IC0gc3JjX29mZiAldSA8IGxlbiAldVwiXG4gICAgICAoU3RyaW5nLmxlbmd0aCBzcmMpIHNyY19vZmYgbGVuO1xuICBpZiBCeXRlcy5sZW5ndGggZHN0IC0gZHN0X29mZiA8IGxlbiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJDaGFjaGEyMDogZHN0IGxlbmd0aCAldSAtIGRzdF9vZmYgJXUgPCBsZW4gJXVcIlxuICAgICAgKEJ5dGVzLmxlbmd0aCBkc3QpIGRzdF9vZmYgbGVuO1xuICBpZiBTdHJpbmcubGVuZ3RoIHNyYyAtIHRhZ19vZmYgPCB0YWdfc2l6ZSB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJDaGFjaGEyMDogc3JjIGxlbmd0aCAldSAtIHRhZ19vZmYgJXUgPCB0YWdfc2l6ZSAldVwiXG4gICAgICAoU3RyaW5nLmxlbmd0aCBzcmMpIHRhZ19vZmYgdGFnX3NpemU7XG4gIHVuc2FmZV9hdXRoZW50aWNhdGVfZGVjcnlwdF9pbnRvIH5rZXkgfm5vbmNlID9hZGF0YSBzcmMgfnNyY19vZmYgfnRhZ19vZmYgZHN0IH5kc3Rfb2ZmIGxlblxuXG5sZXQgYXV0aGVudGljYXRlX2RlY3J5cHQgfmtleSB+bm9uY2UgP2FkYXRhIGRhdGEgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRhdGEgPCB0YWdfc2l6ZSB0aGVuXG4gICAgTm9uZVxuICBlbHNlXG4gICAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIGRhdGEgLSB0YWdfc2l6ZSBpblxuICAgIGxldCByID0gQnl0ZXMuY3JlYXRlIGwgaW5cbiAgICBpZiB1bnNhZmVfYXV0aGVudGljYXRlX2RlY3J5cHRfaW50byB+a2V5IH5ub25jZSA/YWRhdGEgZGF0YSB+c3JjX29mZjowIH50YWdfb2ZmOmwgciB+ZHN0X29mZjowIGwgdGhlblxuICAgICAgU29tZSAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByKVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxubGV0IGF1dGhlbnRpY2F0ZV9kZWNyeXB0X3RhZyB+a2V5IH5ub25jZSA/YWRhdGEgfnRhZyBkYXRhID1cbiAgbGV0IGNkYXRhID0gZGF0YSBeIHRhZyBpblxuICBhdXRoZW50aWNhdGVfZGVjcnlwdCB+a2V5IH5ub25jZSA/YWRhdGEgY2RhdGFcbiIsIm9wZW4gVW5jb21tb25cblxubW9kdWxlIEJsb2NrID0gc3RydWN0XG5cbiAgbW9kdWxlIHR5cGUgQ29yZSA9IHNpZ1xuXG4gICAgdHlwZSBla2V5XG4gICAgdHlwZSBka2V5XG5cbiAgICB2YWwgb2Zfc2VjcmV0ICAgOiBzdHJpbmcgLT4gZWtleSAqIGRrZXlcbiAgICB2YWwgZV9vZl9zZWNyZXQgOiBzdHJpbmcgLT4gZWtleVxuICAgIHZhbCBkX29mX3NlY3JldCA6IHN0cmluZyAtPiBka2V5XG5cbiAgICB2YWwga2V5ICAgOiBpbnQgYXJyYXlcbiAgICB2YWwgYmxvY2sgOiBpbnRcblxuICAgICgqIFhYWCBjdXJyZW50bHkgdW5zYWZlIHBvaW50ICopXG4gICAgdmFsIGVuY3J5cHQgOiBrZXk6ZWtleSAtPiBibG9ja3M6aW50IC0+IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IHVuaXRcbiAgICB2YWwgZGVjcnlwdCA6IGtleTpka2V5IC0+IGJsb2NrczppbnQgLT4gc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gdW5pdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBFQ0IgPSBzaWdcblxuICAgIHR5cGUga2V5XG4gICAgdmFsIG9mX3NlY3JldCA6IHN0cmluZyAtPiBrZXlcblxuICAgIHZhbCBrZXlfc2l6ZXMgIDogaW50IGFycmF5XG4gICAgdmFsIGJsb2NrX3NpemUgOiBpbnRcbiAgICB2YWwgZW5jcnlwdCA6IGtleTprZXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuICAgIHZhbCBkZWNyeXB0IDoga2V5OmtleSAtPiBzdHJpbmcgLT4gc3RyaW5nXG4gICAgdmFsIGVuY3J5cHRfaW50byA6IGtleTprZXkgLT4gc3RyaW5nIC0+IHNyY19vZmY6aW50IC0+IGJ5dGVzIC0+IGRzdF9vZmY6aW50IC0+IGludCAtPiB1bml0XG4gICAgdmFsIGRlY3J5cHRfaW50byA6IGtleTprZXkgLT4gc3RyaW5nIC0+IHNyY19vZmY6aW50IC0+IGJ5dGVzIC0+IGRzdF9vZmY6aW50IC0+IGludCAtPiB1bml0XG4gICAgdmFsIHVuc2FmZV9lbmNyeXB0X2ludG8gOiBrZXk6a2V5IC0+IHN0cmluZyAtPiBzcmNfb2ZmOmludCAtPiBieXRlcyAtPiBkc3Rfb2ZmOmludCAtPiBpbnQgLT4gdW5pdFxuICAgIHZhbCB1bnNhZmVfZGVjcnlwdF9pbnRvIDoga2V5OmtleSAtPiBzdHJpbmcgLT4gc3JjX29mZjppbnQgLT4gYnl0ZXMgLT4gZHN0X29mZjppbnQgLT4gaW50IC0+IHVuaXRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ0JDID0gc2lnXG5cbiAgICB0eXBlIGtleVxuICAgIHZhbCBvZl9zZWNyZXQgOiBzdHJpbmcgLT4ga2V5XG5cbiAgICB2YWwga2V5X3NpemVzICA6IGludCBhcnJheVxuICAgIHZhbCBibG9ja19zaXplIDogaW50XG5cbiAgICB2YWwgZW5jcnlwdCA6IGtleTprZXkgLT4gaXY6c3RyaW5nIC0+IHN0cmluZyAtPiBzdHJpbmdcbiAgICB2YWwgZGVjcnlwdCA6IGtleTprZXkgLT4gaXY6c3RyaW5nIC0+IHN0cmluZyAtPiBzdHJpbmdcbiAgICB2YWwgbmV4dF9pdiA6ID9vZmY6aW50IC0+IHN0cmluZyAtPiBpdjpzdHJpbmcgLT4gc3RyaW5nXG5cbiAgICB2YWwgZW5jcnlwdF9pbnRvIDoga2V5OmtleSAtPiBpdjpzdHJpbmcgLT4gc3RyaW5nIC0+IHNyY19vZmY6aW50IC0+XG4gICAgICBieXRlcyAtPiBkc3Rfb2ZmOmludCAtPiBpbnQgLT4gdW5pdFxuICAgIHZhbCBkZWNyeXB0X2ludG8gOiBrZXk6a2V5IC0+IGl2OnN0cmluZyAtPiBzdHJpbmcgLT4gc3JjX29mZjppbnQgLT5cbiAgICAgIGJ5dGVzIC0+IGRzdF9vZmY6aW50IC0+IGludCAtPiB1bml0XG5cbiAgICB2YWwgdW5zYWZlX2VuY3J5cHRfaW50byA6IGtleTprZXkgLT4gaXY6c3RyaW5nIC0+IHN0cmluZyAtPiBzcmNfb2ZmOmludCAtPlxuICAgICAgYnl0ZXMgLT4gZHN0X29mZjppbnQgLT4gaW50IC0+IHVuaXRcbiAgICB2YWwgdW5zYWZlX2RlY3J5cHRfaW50byA6IGtleTprZXkgLT4gaXY6c3RyaW5nIC0+IHN0cmluZyAtPiBzcmNfb2ZmOmludCAtPlxuICAgICAgYnl0ZXMgLT4gZHN0X29mZjppbnQgLT4gaW50IC0+IHVuaXRcbiAgICB2YWwgdW5zYWZlX2VuY3J5cHRfaW50b19pbnBsYWNlIDoga2V5OmtleSAtPiBpdjpzdHJpbmcgLT5cbiAgICAgIGJ5dGVzIC0+IGRzdF9vZmY6aW50IC0+IGludCAtPiB1bml0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENUUiA9IHNpZ1xuXG4gICAgdHlwZSBrZXlcbiAgICB2YWwgb2Zfc2VjcmV0IDogc3RyaW5nIC0+IGtleVxuXG4gICAgdmFsIGtleV9zaXplcyAgOiBpbnQgYXJyYXlcbiAgICB2YWwgYmxvY2tfc2l6ZSA6IGludFxuXG4gICAgdHlwZSBjdHJcbiAgICB2YWwgYWRkX2N0ciAgICAgICAgOiBjdHIgLT4gaW50NjQgLT4gY3RyXG4gICAgdmFsIG5leHRfY3RyICAgICAgIDogP29mZjppbnQgLT4gc3RyaW5nIC0+IGN0cjpjdHIgLT4gY3RyXG4gICAgdmFsIGN0cl9vZl9vY3RldHMgIDogc3RyaW5nIC0+IGN0clxuXG4gICAgdmFsIHN0cmVhbSAgOiBrZXk6a2V5IC0+IGN0cjpjdHIgLT4gaW50IC0+IHN0cmluZ1xuICAgIHZhbCBlbmNyeXB0IDoga2V5OmtleSAtPiBjdHI6Y3RyIC0+IHN0cmluZyAtPiBzdHJpbmdcbiAgICB2YWwgZGVjcnlwdCA6IGtleTprZXkgLT4gY3RyOmN0ciAtPiBzdHJpbmcgLT4gc3RyaW5nXG5cbiAgICB2YWwgc3RyZWFtX2ludG8gIDoga2V5OmtleSAtPiBjdHI6Y3RyIC0+IGJ5dGVzIC0+IG9mZjppbnQgLT4gaW50IC0+IHVuaXRcbiAgICB2YWwgZW5jcnlwdF9pbnRvIDoga2V5OmtleSAtPiBjdHI6Y3RyIC0+IHN0cmluZyAtPiBzcmNfb2ZmOmludCAtPlxuICAgICAgYnl0ZXMgLT4gZHN0X29mZjppbnQgLT4gaW50IC0+IHVuaXRcbiAgICB2YWwgZGVjcnlwdF9pbnRvIDoga2V5OmtleSAtPiBjdHI6Y3RyIC0+IHN0cmluZyAtPiBzcmNfb2ZmOmludCAtPlxuICAgICAgYnl0ZXMgLT4gZHN0X29mZjppbnQgLT4gaW50IC0+IHVuaXRcblxuICAgIHZhbCB1bnNhZmVfc3RyZWFtX2ludG8gIDoga2V5OmtleSAtPiBjdHI6Y3RyIC0+IGJ5dGVzIC0+IG9mZjppbnQgLT4gaW50IC0+IHVuaXRcbiAgICB2YWwgdW5zYWZlX2VuY3J5cHRfaW50byA6IGtleTprZXkgLT4gY3RyOmN0ciAtPiBzdHJpbmcgLT4gc3JjX29mZjppbnQgLT5cbiAgICAgIGJ5dGVzIC0+IGRzdF9vZmY6aW50IC0+IGludCAtPiB1bml0XG4gICAgdmFsIHVuc2FmZV9kZWNyeXB0X2ludG8gOiBrZXk6a2V5IC0+IGN0cjpjdHIgLT4gc3RyaW5nIC0+IHNyY19vZmY6aW50IC0+XG4gICAgICBieXRlcyAtPiBkc3Rfb2ZmOmludCAtPiBpbnQgLT4gdW5pdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBHQ00gPSBzaWdcbiAgICBpbmNsdWRlIEFlYWQuQUVBRFxuXG4gICAgdmFsIGtleV9zaXplcyAgOiBpbnQgYXJyYXlcbiAgICB2YWwgYmxvY2tfc2l6ZSA6IGludFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBDQ00xNiA9IHNpZ1xuICAgIGluY2x1ZGUgQWVhZC5BRUFEXG5cbiAgICB2YWwga2V5X3NpemVzICA6IGludCBhcnJheVxuICAgIHZhbCBibG9ja19zaXplIDogaW50XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBDb3VudGVycyA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSBjdHJcbiAgICB2YWwgc2l6ZSA6IGludFxuICAgIHZhbCBhZGQgIDogY3RyIC0+IGludDY0IC0+IGN0clxuICAgIHZhbCBvZl9vY3RldHMgOiBzdHJpbmcgLT4gY3RyXG4gICAgdmFsIHVuc2FmZV9jb3VudF9pbnRvIDogY3RyIC0+IGJ5dGVzIC0+IG9mZjppbnQgLT4gYmxvY2tzOmludCAtPiB1bml0XG4gIGVuZFxuXG4gIG1vZHVsZSBDNjRiZSA9IHN0cnVjdFxuICAgIHR5cGUgY3RyID0gaW50NjRcbiAgICBsZXQgc2l6ZSA9IDhcbiAgICBsZXQgb2Zfb2N0ZXRzIGNzID0gU3RyaW5nLmdldF9pbnQ2NF9iZSBjcyAwXG4gICAgbGV0IGFkZCA9IEludDY0LmFkZFxuICAgIGxldCB1bnNhZmVfY291bnRfaW50byB0IGJ1ZiB+b2ZmIH5ibG9ja3MgPVxuICAgICAgbGV0IGN0ciA9IEJ5dGVzLmNyZWF0ZSA4IGluXG4gICAgICBCeXRlcy5zZXRfaW50NjRfYmUgY3RyIDAgdDtcbiAgICAgIE5hdGl2ZS5jb3VudDhiZSB+Y3RyIGJ1ZiB+b2ZmIH5ibG9ja3NcbiAgZW5kXG5cbiAgbW9kdWxlIEMxMjhiZSA9IHN0cnVjdFxuICAgIHR5cGUgY3RyID0gaW50NjQgKiBpbnQ2NFxuICAgIGxldCBzaXplID0gMTZcbiAgICBsZXQgb2Zfb2N0ZXRzIGNzID1cbiAgICAgIGxldCBidWYgPSBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGNzIGluXG4gICAgICBCeXRlcy4oZ2V0X2ludDY0X2JlIGJ1ZiAwLCBnZXRfaW50NjRfYmUgYnVmIDgpXG4gICAgbGV0IGFkZCAodzEsIHcwKSBuID1cbiAgICAgIGxldCB3MCcgID0gSW50NjQuYWRkIHcwIG4gaW5cbiAgICAgIGxldCBmbGlwID0gaWYgSW50NjQubG9neG9yIHcwIHcwJyA8IDBMIHRoZW4gdzAnID4gdzAgZWxzZSB3MCcgPCB3MCBpblxuICAgICAgKChpZiBmbGlwIHRoZW4gSW50NjQuc3VjYyB3MSBlbHNlIHcxKSwgdzAnKVxuICAgIGxldCB1bnNhZmVfY291bnRfaW50byAodzEsIHcwKSBidWYgfm9mZiB+YmxvY2tzID1cbiAgICAgIGxldCBjdHIgPSBCeXRlcy5jcmVhdGUgMTYgaW5cbiAgICAgIEJ5dGVzLnNldF9pbnQ2NF9iZSBjdHIgMCB3MTsgQnl0ZXMuc2V0X2ludDY0X2JlIGN0ciA4IHcwO1xuICAgICAgTmF0aXZlLmNvdW50MTZiZSB+Y3RyIGJ1ZiB+b2ZmIH5ibG9ja3NcbiAgZW5kXG5cbiAgbW9kdWxlIEMxMjhiZTMyID0gc3RydWN0XG4gICAgaW5jbHVkZSBDMTI4YmVcbiAgICBsZXQgYWRkICh3MSwgdzApIG4gPVxuICAgICAgbGV0IGhpID0gMHhmZmZmZmZmZjAwMDAwMDAwTCBhbmQgbG8gPSAweDAwMDAwMDAwZmZmZmZmZmZMIGluXG4gICAgICAodzEsIEludDY0Lihsb2dvciAobG9nYW5kIGhpIHcwKSAoYWRkIG4gdzAgfD4gbG9nYW5kIGxvKSkpXG4gICAgbGV0IHVuc2FmZV9jb3VudF9pbnRvICh3MSwgdzApIGJ1ZiB+b2ZmIH5ibG9ja3MgPVxuICAgICAgbGV0IGN0ciA9IEJ5dGVzLmNyZWF0ZSAxNiBpblxuICAgICAgQnl0ZXMuc2V0X2ludDY0X2JlIGN0ciAwIHcxOyBCeXRlcy5zZXRfaW50NjRfYmUgY3RyIDggdzA7XG4gICAgICBOYXRpdmUuY291bnQxNmJlNCB+Y3RyIGJ1ZiB+b2ZmIH5ibG9ja3NcbiAgZW5kXG5lbmRcblxubGV0IGNoZWNrX29mZnNldCB+dGFnIH5idWYgfm9mZiB+bGVuIGFjdHVhbF9sZW4gPVxuICBpZiBvZmYgPCAwIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIiVzOiAlcyBvZmYgJXUgPCAwXCJcbiAgICAgIHRhZyBidWYgb2ZmO1xuICBpZiBhY3R1YWxfbGVuIC0gb2ZmIDwgbGVuIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIiVzOiAlcyBsZW5ndGggJXUgLSBvZmYgJXUgPCBsZW4gJXVcIlxuICAgICAgdGFnIGJ1ZiBhY3R1YWxfbGVuIG9mZiBsZW5cbltAQGlubGluZV1cblxubW9kdWxlIE1vZGVzID0gc3RydWN0XG4gIG1vZHVsZSBFQ0Jfb2YgKENvcmUgOiBCbG9jay5Db3JlKSA6IEJsb2NrLkVDQiA9IHN0cnVjdFxuXG4gICAgdHlwZSBrZXkgPSBDb3JlLmVrZXkgKiBDb3JlLmRrZXlcblxuICAgIGxldCAoa2V5X3NpemVzLCBibG9ja19zaXplKSA9IENvcmUuKGtleSwgYmxvY2spXG5cbiAgICBsZXQgb2Zfc2VjcmV0ID0gQ29yZS5vZl9zZWNyZXRcblxuICAgIGxldCB1bnNhZmVfZWNiIHhmb3JtIGtleSBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiBsZW4gPVxuICAgICAgeGZvcm0gfmtleSB+YmxvY2tzOihsZW4gLyBibG9ja19zaXplKSBzcmMgc3JjX29mZiBkc3QgZHN0X29mZlxuXG4gICAgbGV0IGVjYiB4Zm9ybSBrZXkgc3JjIHNyY19vZmYgZHN0IGRzdF9vZmYgbGVuID1cbiAgICAgIGlmIGxlbiBtb2QgYmxvY2tfc2l6ZSA8PiAwIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJFQ0I6IGxlbmd0aCAldSBub3Qgb2YgYmxvY2sgc2l6ZVwiIGxlbjtcbiAgICAgIGNoZWNrX29mZnNldCB+dGFnOlwiRUNCXCIgfmJ1ZjpcInNyY1wiIH5vZmY6c3JjX29mZiB+bGVuIChTdHJpbmcubGVuZ3RoIHNyYyk7XG4gICAgICBjaGVja19vZmZzZXQgfnRhZzpcIkVDQlwiIH5idWY6XCJkc3RcIiB+b2ZmOmRzdF9vZmYgfmxlbiAoQnl0ZXMubGVuZ3RoIGRzdCk7XG4gICAgICB1bnNhZmVfZWNiIHhmb3JtIGtleSBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiBsZW5cblxuICAgIGxldCBlbmNyeXB0X2ludG8gfmtleTooa2V5LCBfKSBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGxlbiA9XG4gICAgICBlY2IgQ29yZS5lbmNyeXB0IGtleSBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiBsZW5cblxuICAgIGxldCB1bnNhZmVfZW5jcnlwdF9pbnRvIH5rZXk6KGtleSwgXykgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiBsZW4gPVxuICAgICAgdW5zYWZlX2VjYiBDb3JlLmVuY3J5cHQga2V5IHNyYyBzcmNfb2ZmIGRzdCBkc3Rfb2ZmIGxlblxuXG4gICAgbGV0IGRlY3J5cHRfaW50byB+a2V5OihfLCBrZXkpIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgbGVuID1cbiAgICAgIGVjYiBDb3JlLmRlY3J5cHQga2V5IHNyYyBzcmNfb2ZmIGRzdCBkc3Rfb2ZmIGxlblxuXG4gICAgbGV0IHVuc2FmZV9kZWNyeXB0X2ludG8gfmtleTooXywga2V5KSBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGxlbiA9XG4gICAgICB1bnNhZmVfZWNiIENvcmUuZGVjcnlwdCBrZXkgc3JjIHNyY19vZmYgZHN0IGRzdF9vZmYgbGVuXG5cbiAgICBsZXQgZW5jcnlwdCB+a2V5IHNyYyA9XG4gICAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzcmMgaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgICBlbmNyeXB0X2ludG8gfmtleSBzcmMgfnNyY19vZmY6MCBkc3QgfmRzdF9vZmY6MCBsZW47XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGRzdFxuXG4gICAgbGV0IGRlY3J5cHQgfmtleSBzcmMgPVxuICAgICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3JjIGluXG4gICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgICAgZGVjcnlwdF9pbnRvIH5rZXkgc3JjIH5zcmNfb2ZmOjAgZHN0IH5kc3Rfb2ZmOjAgbGVuO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkc3RcbiAgZW5kXG5cbiAgbW9kdWxlIENCQ19vZiAoQ29yZSA6IEJsb2NrLkNvcmUpIDogQmxvY2suQ0JDID0gc3RydWN0XG5cbiAgICB0eXBlIGtleSA9IENvcmUuZWtleSAqIENvcmUuZGtleVxuXG4gICAgbGV0IChrZXlfc2l6ZXMsIGJsb2NrX3NpemUpID0gQ29yZS4oa2V5LCBibG9jaylcbiAgICBsZXQgYmxvY2sgPSBibG9ja19zaXplXG5cbiAgICBsZXQgb2Zfc2VjcmV0ID0gQ29yZS5vZl9zZWNyZXRcblxuICAgIGxldCBjaGVja19ibG9ja19zaXplIH5pdiBsZW4gPVxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBpdiA8PiBibG9jayB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnIFwiQ0JDOiBJViBsZW5ndGggJXUgbm90IG9mIGJsb2NrIHNpemVcIiAoU3RyaW5nLmxlbmd0aCBpdik7XG4gICAgICBpZiBsZW4gbW9kIGJsb2NrIDw+IDAgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyBcIkNCQzogYXJndW1lbnQgbGVuZ3RoICV1IG5vdCBvZiBibG9jayBzaXplXCJcbiAgICAgICAgICBsZW5cbiAgICBbQEBpbmxpbmVdXG5cbiAgICBsZXQgbmV4dF9pdiA/KG9mZiA9IDApIGNzIH5pdiA9XG4gICAgICBjaGVja19ibG9ja19zaXplIH5pdiAoU3RyaW5nLmxlbmd0aCBjcyAtIG9mZikgO1xuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBjcyA+IG9mZiB0aGVuXG4gICAgICAgIFN0cmluZy5zdWIgY3MgKFN0cmluZy5sZW5ndGggY3MgLSBibG9ja19zaXplKSBibG9ja19zaXplXG4gICAgICBlbHNlIGl2XG5cbiAgICBsZXQgdW5zYWZlX2VuY3J5cHRfaW50b19pbnBsYWNlIH5rZXk6KGtleSwgXykgfml2IGRzdCB+ZHN0X29mZiBsZW4gPVxuICAgICAgbGV0IHJlYyBsb29wIGl2IGl2X2kgZHN0X2kgPSBmdW5jdGlvblxuICAgICAgICB8IDAgLT4gKClcbiAgICAgICAgfCBiIC0+XG4gICAgICAgICAgTmF0aXZlLnhvcl9pbnRvX2J5dGVzIGl2IGl2X2kgZHN0IGRzdF9pIGJsb2NrIDtcbiAgICAgICAgICBDb3JlLmVuY3J5cHQgfmtleSB+YmxvY2tzOjEgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgZHN0KSBkc3RfaSBkc3QgZHN0X2kgO1xuICAgICAgICAgIChsb29wIFtAdGFpbGNhbGxdKSAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkc3QpIGRzdF9pIChkc3RfaSArIGJsb2NrKSAoYiAtIDEpXG4gICAgICBpblxuICAgICAgbG9vcCBpdiAwIGRzdF9vZmYgKGxlbiAvIGJsb2NrKVxuXG4gICAgbGV0IHVuc2FmZV9lbmNyeXB0X2ludG8gfmtleSB+aXYgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiBsZW4gPVxuICAgICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHNyYyBzcmNfb2ZmIGRzdCBkc3Rfb2ZmIGxlbjtcbiAgICAgIHVuc2FmZV9lbmNyeXB0X2ludG9faW5wbGFjZSB+a2V5IH5pdiBkc3QgfmRzdF9vZmYgbGVuXG5cbiAgICBsZXQgZW5jcnlwdF9pbnRvIH5rZXkgfml2IHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgbGVuID1cbiAgICAgIGNoZWNrX2Jsb2NrX3NpemUgfml2IGxlbjtcbiAgICAgIGNoZWNrX29mZnNldCB+dGFnOlwiQ0JDXCIgfmJ1ZjpcInNyY1wiIH5vZmY6c3JjX29mZiB+bGVuIChTdHJpbmcubGVuZ3RoIHNyYyk7XG4gICAgICBjaGVja19vZmZzZXQgfnRhZzpcIkNCQ1wiIH5idWY6XCJkc3RcIiB+b2ZmOmRzdF9vZmYgfmxlbiAoQnl0ZXMubGVuZ3RoIGRzdCk7XG4gICAgICB1bnNhZmVfZW5jcnlwdF9pbnRvIH5rZXkgfml2IHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgbGVuXG5cbiAgICBsZXQgZW5jcnlwdCB+a2V5IH5pdiBzcmMgPVxuICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzcmMpIGluXG4gICAgICBlbmNyeXB0X2ludG8gfmtleSB+aXYgc3JjIH5zcmNfb2ZmOjAgZHN0IH5kc3Rfb2ZmOjAgKFN0cmluZy5sZW5ndGggc3JjKTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgZHN0XG5cbiAgICBsZXQgdW5zYWZlX2RlY3J5cHRfaW50byB+a2V5OihfLCBrZXkpIH5pdiBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGxlbiA9XG4gICAgICBsZXQgYiA9IGxlbiAvIGJsb2NrIGluXG4gICAgICBpZiBiID4gMCB0aGVuIGJlZ2luXG4gICAgICAgIENvcmUuZGVjcnlwdCB+a2V5IH5ibG9ja3M6YiBzcmMgc3JjX29mZiBkc3QgZHN0X29mZiA7XG4gICAgICAgIE5hdGl2ZS54b3JfaW50b19ieXRlcyBpdiAwIGRzdCBkc3Rfb2ZmIGJsb2NrIDtcbiAgICAgICAgTmF0aXZlLnhvcl9pbnRvX2J5dGVzIHNyYyBzcmNfb2ZmIGRzdCAoZHN0X29mZiArIGJsb2NrKSAoKGIgLSAxKSAqIGJsb2NrKSA7XG4gICAgICBlbmRcblxuICAgIGxldCBkZWNyeXB0X2ludG8gfmtleSB+aXYgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiBsZW4gPVxuICAgICAgY2hlY2tfYmxvY2tfc2l6ZSB+aXYgbGVuO1xuICAgICAgY2hlY2tfb2Zmc2V0IH50YWc6XCJDQkNcIiB+YnVmOlwic3JjXCIgfm9mZjpzcmNfb2ZmIH5sZW4gKFN0cmluZy5sZW5ndGggc3JjKTtcbiAgICAgIGNoZWNrX29mZnNldCB+dGFnOlwiQ0JDXCIgfmJ1ZjpcImRzdFwiIH5vZmY6ZHN0X29mZiB+bGVuIChCeXRlcy5sZW5ndGggZHN0KTtcbiAgICAgIHVuc2FmZV9kZWNyeXB0X2ludG8gfmtleSB+aXYgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiBsZW5cblxuICAgIGxldCBkZWNyeXB0IH5rZXkgfml2IHNyYyA9XG4gICAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzcmMgaW5cbiAgICAgIGxldCBtc2cgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgICBkZWNyeXB0X2ludG8gfmtleSB+aXYgc3JjIH5zcmNfb2ZmOjAgbXNnIH5kc3Rfb2ZmOjAgbGVuO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBtc2dcbiAgZW5kXG5cbiAgbW9kdWxlIENUUl9vZiAoQ29yZSA6IEJsb2NrLkNvcmUpIChDdHIgOiBDb3VudGVycy5TKSA6XG4gICAgQmxvY2suQ1RSIHdpdGggdHlwZSBrZXkgPSBDb3JlLmVrZXkgYW5kIHR5cGUgY3RyID0gQ3RyLmN0ciA9XG4gIHN0cnVjdFxuICAgICgqIEZJWE1FOiBDVFIgaGFzIG1vcmUgcm9vbSBmb3Igc3BlZWR1cHMuIExpa2Ugc3RpdGNoaW5nLiAqKVxuXG4gICAgYXNzZXJ0IChDb3JlLmJsb2NrID0gQ3RyLnNpemUpXG4gICAgdHlwZSBrZXkgPSBDb3JlLmVrZXlcbiAgICB0eXBlIGN0ciA9IEN0ci5jdHJcblxuICAgIGxldCAoa2V5X3NpemVzLCBibG9ja19zaXplKSA9IENvcmUuKGtleSwgYmxvY2spXG4gICAgbGV0IG9mX3NlY3JldCA9IENvcmUuZV9vZl9zZWNyZXRcblxuICAgIGxldCB1bnNhZmVfc3RyZWFtX2ludG8gfmtleSB+Y3RyIGJ1ZiB+b2ZmIGxlbiA9XG4gICAgICBsZXQgYmxvY2tzID0gaW1heCAwIGxlbiAvIGJsb2NrX3NpemUgaW5cbiAgICAgIEN0ci51bnNhZmVfY291bnRfaW50byBjdHIgYnVmIH5vZmYgfmJsb2NrcyA7XG4gICAgICBDb3JlLmVuY3J5cHQgfmtleSB+YmxvY2tzIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1Zikgb2ZmIGJ1ZiBvZmYgO1xuICAgICAgbGV0IHNsYWNrID0gaW1heCAwIGxlbiBtb2QgYmxvY2tfc2l6ZSBpblxuICAgICAgaWYgc2xhY2sgPD4gMCB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBidWYnID0gQnl0ZXMuY3JlYXRlIGJsb2NrX3NpemUgaW5cbiAgICAgICAgbGV0IGN0ciA9IEN0ci5hZGQgY3RyIChJbnQ2NC5vZl9pbnQgYmxvY2tzKSBpblxuICAgICAgICBDdHIudW5zYWZlX2NvdW50X2ludG8gY3RyIGJ1Zicgfm9mZjowIH5ibG9ja3M6MSA7XG4gICAgICAgIENvcmUuZW5jcnlwdCB+a2V5IH5ibG9ja3M6MSAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWYnKSAwIGJ1ZicgMCA7XG4gICAgICAgIEJ5dGVzLnVuc2FmZV9ibGl0IGJ1ZicgMCBidWYgKG9mZiArIGJsb2NrcyAqIGJsb2NrX3NpemUpIHNsYWNrXG4gICAgICBlbmRcblxuICAgIGxldCBzdHJlYW1faW50byB+a2V5IH5jdHIgYnVmIH5vZmYgbGVuID1cbiAgICAgIGNoZWNrX29mZnNldCB+dGFnOlwiQ1RSXCIgfmJ1ZjpcImJ1ZlwiIH5vZmYgfmxlbiAoQnl0ZXMubGVuZ3RoIGJ1Zik7XG4gICAgICB1bnNhZmVfc3RyZWFtX2ludG8gfmtleSB+Y3RyIGJ1ZiB+b2ZmIGxlblxuXG4gICAgbGV0IHN0cmVhbSB+a2V5IH5jdHIgbiA9XG4gICAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiAgICAgIHVuc2FmZV9zdHJlYW1faW50byB+a2V5IH5jdHIgYnVmIH5vZmY6MCBuO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcblxuICAgIGxldCB1bnNhZmVfZW5jcnlwdF9pbnRvIH5rZXkgfmN0ciBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGxlbiA9XG4gICAgICB1bnNhZmVfc3RyZWFtX2ludG8gfmtleSB+Y3RyIGRzdCB+b2ZmOmRzdF9vZmYgbGVuO1xuICAgICAgVW5jb21tb24udW5zYWZlX3hvcl9pbnRvIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgbGVuXG5cbiAgICBsZXQgZW5jcnlwdF9pbnRvIH5rZXkgfmN0ciBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGxlbiA9XG4gICAgICBjaGVja19vZmZzZXQgfnRhZzpcIkNUUlwiIH5idWY6XCJzcmNcIiB+b2ZmOnNyY19vZmYgfmxlbiAoU3RyaW5nLmxlbmd0aCBzcmMpO1xuICAgICAgY2hlY2tfb2Zmc2V0IH50YWc6XCJDVFJcIiB+YnVmOlwiZHN0XCIgfm9mZjpkc3Rfb2ZmIH5sZW4gKEJ5dGVzLmxlbmd0aCBkc3QpO1xuICAgICAgdW5zYWZlX2VuY3J5cHRfaW50byB+a2V5IH5jdHIgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiBsZW5cblxuICAgIGxldCBlbmNyeXB0IH5rZXkgfmN0ciBzcmMgPVxuICAgICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3JjIGluXG4gICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgICAgZW5jcnlwdF9pbnRvIH5rZXkgfmN0ciBzcmMgfnNyY19vZmY6MCBkc3QgfmRzdF9vZmY6MCBsZW47XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGRzdFxuXG4gICAgbGV0IGRlY3J5cHQgPSBlbmNyeXB0XG5cbiAgICBsZXQgZGVjcnlwdF9pbnRvID0gZW5jcnlwdF9pbnRvXG5cbiAgICBsZXQgdW5zYWZlX2RlY3J5cHRfaW50byA9IHVuc2FmZV9lbmNyeXB0X2ludG9cblxuICAgIGxldCBhZGRfY3RyID0gQ3RyLmFkZFxuICAgIGxldCBuZXh0X2N0ciA/KG9mZiA9IDApIG1zZyB+Y3RyID1cbiAgICAgIGFkZF9jdHIgY3RyIChJbnQ2NC5vZl9pbnQgQEAgKFN0cmluZy5sZW5ndGggbXNnIC0gb2ZmKSAvLyBibG9ja19zaXplKVxuICAgIGxldCBjdHJfb2Zfb2N0ZXRzID0gQ3RyLm9mX29jdGV0c1xuICBlbmRcblxuICBtb2R1bGUgR0hBU0ggOiBzaWdcbiAgICB0eXBlIGtleVxuICAgIHZhbCBkZXJpdmUgIDogc3RyaW5nIC0+IGtleVxuICAgIHZhbCBkaWdlc3RpIDoga2V5OmtleSAtPiAoc3RyaW5nIFVuY29tbW9uLml0ZXIpIC0+IHN0cmluZ1xuICAgIHZhbCBkaWdlc3RpX29mZl9sZW4gOiBrZXk6a2V5IC0+IChzdHJpbmcgKiBpbnQgKiBpbnQpIFVuY29tbW9uLml0ZXIgLT4gc3RyaW5nXG4gICAgdmFsIHRhZ3NpemUgOiBpbnRcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSBrZXkgPSBzdHJpbmdcbiAgICBsZXQga2V5c2l6ZSA9IE5hdGl2ZS5HSEFTSC5rZXlzaXplICgpXG4gICAgbGV0IHRhZ3NpemUgPSAxNlxuICAgIGxldCBkZXJpdmUgY3MgPVxuICAgICAgYXNzZXJ0IChTdHJpbmcubGVuZ3RoIGNzID49IHRhZ3NpemUpO1xuICAgICAgbGV0IGsgPSBCeXRlcy5jcmVhdGUga2V5c2l6ZSBpblxuICAgICAgTmF0aXZlLkdIQVNILmtleWluaXQgY3MgaztcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcga1xuICAgIGxldCBkaWdlc3RpX29mZl9sZW4gfmtleSBpID1cbiAgICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHRhZ3NpemUgJ1xceDAwJyBpblxuICAgICAgaSAoZnVuIChjcywgb2ZmLCBsZW4pIC0+IE5hdGl2ZS5HSEFTSC5naGFzaCBrZXkgcmVzIGNzIG9mZiBsZW4pO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgICBsZXQgZGlnZXN0aSB+a2V5IGkgPVxuICAgICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgdGFnc2l6ZSAnXFx4MDAnIGluXG4gICAgICBpIChmdW4gY3MgLT4gTmF0aXZlLkdIQVNILmdoYXNoIGtleSByZXMgY3MgMCAoU3RyaW5nLmxlbmd0aCBjcykpO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuICBlbmRcblxuICBtb2R1bGUgR0NNX29mIChDIDogQmxvY2suQ29yZSkgOiBCbG9jay5HQ00gPSBzdHJ1Y3RcblxuICAgIGFzc2VydCAoQy5ibG9jayA9IDE2KVxuICAgIG1vZHVsZSBDVFIgPSBDVFJfb2YgKEMpIChDb3VudGVycy5DMTI4YmUzMilcblxuICAgIHR5cGUga2V5ID0geyBrZXkgOiBDLmVrZXkgOyBoa2V5IDogR0hBU0gua2V5IH1cblxuICAgIGxldCB0YWdfc2l6ZSA9IEdIQVNILnRhZ3NpemVcbiAgICBsZXQga2V5X3NpemVzLCBibG9ja19zaXplID0gQy4oa2V5LCBibG9jaylcbiAgICBsZXQgejEyOCA9IFN0cmluZy5tYWtlIGJsb2NrX3NpemUgJ1xceDAwJ1xuXG4gICAgbGV0IG9mX3NlY3JldCBjcyA9XG4gICAgICBsZXQgaCA9IEJ5dGVzLmNyZWF0ZSBibG9ja19zaXplIGluXG4gICAgICBsZXQga2V5ID0gQy5lX29mX3NlY3JldCBjcyBpblxuICAgICAgQy5lbmNyeXB0IH5rZXkgfmJsb2NrczoxIHoxMjggMCBoIDA7XG4gICAgICB7IGtleSA7IGhrZXkgPSBHSEFTSC5kZXJpdmUgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgaCkgfVxuXG4gICAgbGV0IGJpdHM2NCBjcyA9IEludDY0Lm9mX2ludCAoU3RyaW5nLmxlbmd0aCBjcyAqIDgpXG5cbiAgICBsZXQgcGFjazY0cyBhIGIgPVxuICAgICAgbGV0IGNzID0gQnl0ZXMuY3JlYXRlIDE2IGluXG4gICAgICBCeXRlcy5zZXRfaW50NjRfYmUgY3MgMCBhO1xuICAgICAgQnl0ZXMuc2V0X2ludDY0X2JlIGNzIDggYjtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY3NcblxuICAgIGxldCBjb3VudGVyIH5oa2V5IG5vbmNlID0gbWF0Y2ggU3RyaW5nLmxlbmd0aCBub25jZSB3aXRoXG4gICAgICB8IDAgLT4gaW52YWxpZF9hcmcgXCJHQ006IGludmFsaWQgbm9uY2Ugb2YgbGVuZ3RoIDBcIlxuICAgICAgfCAxMiAtPlxuICAgICAgICBsZXQgKHcxLCB3MikgPSBTdHJpbmcuZ2V0X2ludDY0X2JlIG5vbmNlIDAsIFN0cmluZy5nZXRfaW50MzJfYmUgbm9uY2UgOCBpblxuICAgICAgICAodzEsIEludDY0LihzaGlmdF9sZWZ0IChvZl9pbnQzMiB3MikgMzIgfD4gYWRkIDFMKSlcbiAgICAgIHwgXyAgLT5cbiAgICAgICAgQ1RSLmN0cl9vZl9vY3RldHMgQEBcbiAgICAgICAgR0hBU0guZGlnZXN0aSB+a2V5OmhrZXkgQEAgaXRlcjIgbm9uY2UgKHBhY2s2NHMgMEwgKGJpdHM2NCBub25jZSkpXG5cbiAgICBsZXQgdW5zYWZlX3RhZ19pbnRvIH5rZXkgfmhrZXkgfmN0ciA/KGFkYXRhID0gXCJcIikgY2RhdGEgfm9mZiB+bGVuIGRzdCB+dGFnX29mZiA9XG4gICAgICBDVFIudW5zYWZlX2VuY3J5cHRfaW50byB+a2V5IH5jdHJcbiAgICAgICAgKEdIQVNILmRpZ2VzdGlfb2ZmX2xlbiB+a2V5OmhrZXlcbiAgICAgICAgICAgKGl0ZXIzIChhZGF0YSwgMCwgU3RyaW5nLmxlbmd0aCBhZGF0YSkgKGNkYXRhLCBvZmYsIGxlbilcbiAgICAgICAgICAgICAgKHBhY2s2NHMgKGJpdHM2NCBhZGF0YSkgKEludDY0Lm9mX2ludCAobGVuICogOCkpLCAwLCAxNikpKVxuICAgICAgICB+c3JjX29mZjowIGRzdCB+ZHN0X29mZjp0YWdfb2ZmIHRhZ19zaXplXG5cbiAgICBsZXQgdW5zYWZlX2F1dGhlbnRpY2F0ZV9lbmNyeXB0X2ludG8gfmtleTp7IGtleTsgaGtleSB9IH5ub25jZSA/YWRhdGEgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiB+dGFnX29mZiBsZW4gPVxuICAgICAgbGV0IGN0ciA9IGNvdW50ZXIgfmhrZXkgbm9uY2UgaW5cbiAgICAgIENUUi4odW5zYWZlX2VuY3J5cHRfaW50byB+a2V5IH5jdHI6KGFkZF9jdHIgY3RyIDFMKSBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIGxlbik7XG4gICAgICB1bnNhZmVfdGFnX2ludG8gfmtleSB+aGtleSB+Y3RyID9hZGF0YSAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkc3QpIH5vZmY6ZHN0X29mZiB+bGVuIGRzdCB+dGFnX29mZlxuXG4gICAgbGV0IGF1dGhlbnRpY2F0ZV9lbmNyeXB0X2ludG8gfmtleSB+bm9uY2UgP2FkYXRhIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgfnRhZ19vZmYgbGVuID1cbiAgICAgIGNoZWNrX29mZnNldCB+dGFnOlwiR0NNXCIgfmJ1ZjpcInNyY1wiIH5vZmY6c3JjX29mZiB+bGVuIChTdHJpbmcubGVuZ3RoIHNyYyk7XG4gICAgICBjaGVja19vZmZzZXQgfnRhZzpcIkdDTVwiIH5idWY6XCJkc3RcIiB+b2ZmOmRzdF9vZmYgfmxlbiAoQnl0ZXMubGVuZ3RoIGRzdCk7XG4gICAgICBjaGVja19vZmZzZXQgfnRhZzpcIkdDTVwiIH5idWY6XCJkc3QgdGFnXCIgfm9mZjp0YWdfb2ZmIH5sZW46dGFnX3NpemUgKEJ5dGVzLmxlbmd0aCBkc3QpO1xuICAgICAgdW5zYWZlX2F1dGhlbnRpY2F0ZV9lbmNyeXB0X2ludG8gfmtleSB+bm9uY2UgP2FkYXRhIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgfnRhZ19vZmYgbGVuXG5cbiAgICBsZXQgYXV0aGVudGljYXRlX2VuY3J5cHQgfmtleSB+bm9uY2UgP2FkYXRhIGRhdGEgPVxuICAgICAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIGRhdGEgaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGwgKyB0YWdfc2l6ZSkgaW5cbiAgICAgIHVuc2FmZV9hdXRoZW50aWNhdGVfZW5jcnlwdF9pbnRvIH5rZXkgfm5vbmNlID9hZGF0YSBkYXRhIH5zcmNfb2ZmOjAgZHN0IH5kc3Rfb2ZmOjAgfnRhZ19vZmY6bCBsO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkc3RcblxuICAgIGxldCBhdXRoZW50aWNhdGVfZW5jcnlwdF90YWcgfmtleSB+bm9uY2UgP2FkYXRhIGRhdGEgPVxuICAgICAgbGV0IHIgPSBhdXRoZW50aWNhdGVfZW5jcnlwdCB+a2V5IH5ub25jZSA/YWRhdGEgZGF0YSBpblxuICAgICAgU3RyaW5nLnN1YiByIDAgKFN0cmluZy5sZW5ndGggZGF0YSksXG4gICAgICBTdHJpbmcuc3ViIHIgKFN0cmluZy5sZW5ndGggZGF0YSkgdGFnX3NpemVcblxuICAgIGxldCB1bnNhZmVfYXV0aGVudGljYXRlX2RlY3J5cHRfaW50byB+a2V5Onsga2V5OyBoa2V5IH0gfm5vbmNlID9hZGF0YSBzcmMgfnNyY19vZmYgfnRhZ19vZmYgZHN0IH5kc3Rfb2ZmIGxlbiA9XG4gICAgICBsZXQgY3RyID0gY291bnRlciB+aGtleSBub25jZSBpblxuICAgICAgQ1RSLih1bnNhZmVfZW5jcnlwdF9pbnRvIH5rZXkgfmN0cjooYWRkX2N0ciBjdHIgMUwpIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgbGVuKTtcbiAgICAgIGxldCBjdGFnID0gQnl0ZXMuY3JlYXRlIHRhZ19zaXplIGluXG4gICAgICB1bnNhZmVfdGFnX2ludG8gfmtleSB+aGtleSB+Y3RyID9hZGF0YSBzcmMgfm9mZjpzcmNfb2ZmIH5sZW4gY3RhZyB+dGFnX29mZjowO1xuICAgICAgRXFhZi5lcXVhbCAoU3RyaW5nLnN1YiBzcmMgdGFnX29mZiB0YWdfc2l6ZSkgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY3RhZylcblxuICAgIGxldCBhdXRoZW50aWNhdGVfZGVjcnlwdF9pbnRvIH5rZXkgfm5vbmNlID9hZGF0YSBzcmMgfnNyY19vZmYgfnRhZ19vZmYgZHN0IH5kc3Rfb2ZmIGxlbiA9XG4gICAgICBjaGVja19vZmZzZXQgfnRhZzpcIkdDTVwiIH5idWY6XCJzcmNcIiB+b2ZmOnNyY19vZmYgfmxlbiAoU3RyaW5nLmxlbmd0aCBzcmMpO1xuICAgICAgY2hlY2tfb2Zmc2V0IH50YWc6XCJHQ01cIiB+YnVmOlwic3JjIHRhZ1wiIH5vZmY6dGFnX29mZiB+bGVuOnRhZ19zaXplIChTdHJpbmcubGVuZ3RoIHNyYyk7XG4gICAgICBjaGVja19vZmZzZXQgfnRhZzpcIkdDTVwiIH5idWY6XCJkc3RcIiB+b2ZmOmRzdF9vZmYgfmxlbiAoQnl0ZXMubGVuZ3RoIGRzdCk7XG4gICAgICB1bnNhZmVfYXV0aGVudGljYXRlX2RlY3J5cHRfaW50byB+a2V5IH5ub25jZSA/YWRhdGEgc3JjIH5zcmNfb2ZmIH50YWdfb2ZmIGRzdCB+ZHN0X29mZiBsZW5cblxuICAgIGxldCBhdXRoZW50aWNhdGVfZGVjcnlwdCB+a2V5IH5ub25jZSA/YWRhdGEgY2RhdGEgPVxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBjZGF0YSA8IHRhZ19zaXplIHRoZW5cbiAgICAgICAgTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggY2RhdGEgLSB0YWdfc2l6ZSBpblxuICAgICAgICBsZXQgZGF0YSA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gICAgICAgIGlmIHVuc2FmZV9hdXRoZW50aWNhdGVfZGVjcnlwdF9pbnRvIH5rZXkgfm5vbmNlID9hZGF0YSBjZGF0YSB+c3JjX29mZjowIH50YWdfb2ZmOmwgZGF0YSB+ZHN0X29mZjowIGwgdGhlblxuICAgICAgICAgIFNvbWUgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgZGF0YSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIE5vbmVcblxuICAgIGxldCBhdXRoZW50aWNhdGVfZGVjcnlwdF90YWcgfmtleSB+bm9uY2UgP2FkYXRhIH50YWc6dGFnX2RhdGEgY2lwaGVyID1cbiAgICAgIGxldCBjZGF0YSA9IGNpcGhlciBeIHRhZ19kYXRhIGluXG4gICAgICBhdXRoZW50aWNhdGVfZGVjcnlwdCB+a2V5IH5ub25jZSA/YWRhdGEgY2RhdGFcbiAgZW5kXG5cbiAgbW9kdWxlIENDTTE2X29mIChDIDogQmxvY2suQ29yZSkgOiBCbG9jay5DQ00xNiA9IHN0cnVjdFxuXG4gICAgYXNzZXJ0IChDLmJsb2NrID0gMTYpXG5cbiAgICBsZXQgdGFnX3NpemUgPSBDLmJsb2NrXG5cbiAgICB0eXBlIGtleSA9IEMuZWtleVxuXG4gICAgbGV0IG9mX3NlY3JldCBzZWMgPSBDLmVfb2Zfc2VjcmV0IHNlY1xuXG4gICAgbGV0IChrZXlfc2l6ZXMsIGJsb2NrX3NpemUpID0gQy4oa2V5LCBibG9jaylcblxuICAgIGxldCBjaXBoZXIgfmtleSBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmID1cbiAgICAgIEMuZW5jcnlwdCB+a2V5IH5ibG9ja3M6MSBzcmMgc3JjX29mZiBkc3QgZHN0X29mZlxuXG4gICAgbGV0IHVuc2FmZV9hdXRoZW50aWNhdGVfZW5jcnlwdF9pbnRvIH5rZXkgfm5vbmNlID8oYWRhdGEgPSBcIlwiKSBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIH50YWdfb2ZmIGxlbiA9XG4gICAgICBDY20udW5zYWZlX2dlbmVyYXRpb25fZW5jcnlwdGlvbl9pbnRvIH5jaXBoZXIgfmtleSB+bm9uY2UgfmFkYXRhXG4gICAgICAgIHNyYyB+c3JjX29mZiBkc3QgfmRzdF9vZmYgfnRhZ19vZmYgbGVuXG5cbiAgICBsZXQgdmFsaWRfbm9uY2Ugbm9uY2UgPVxuICAgICAgbGV0IG5zaXplID0gU3RyaW5nLmxlbmd0aCBub25jZSBpblxuICAgICAgaWYgbnNpemUgPCA3IHx8IG5zaXplID4gMTMgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyBcIkNDTTogbm9uY2UgbGVuZ3RoIG5vdCBiZXR3ZWVuIDcgYW5kIDEzOiAldVwiIG5zaXplXG5cbiAgICBsZXQgYXV0aGVudGljYXRlX2VuY3J5cHRfaW50byB+a2V5IH5ub25jZSA/YWRhdGEgc3JjIH5zcmNfb2ZmIGRzdCB+ZHN0X29mZiB+dGFnX29mZiBsZW4gPVxuICAgICAgY2hlY2tfb2Zmc2V0IH50YWc6XCJDQ01cIiB+YnVmOlwic3JjXCIgfm9mZjpzcmNfb2ZmIH5sZW4gKFN0cmluZy5sZW5ndGggc3JjKTtcbiAgICAgIGNoZWNrX29mZnNldCB+dGFnOlwiQ0NNXCIgfmJ1ZjpcImRzdFwiIH5vZmY6ZHN0X29mZiB+bGVuIChCeXRlcy5sZW5ndGggZHN0KTtcbiAgICAgIGNoZWNrX29mZnNldCB+dGFnOlwiQ0NNXCIgfmJ1ZjpcImRzdCB0YWdcIiB+b2ZmOnRhZ19vZmYgfmxlbjp0YWdfc2l6ZSAoQnl0ZXMubGVuZ3RoIGRzdCk7XG4gICAgICB2YWxpZF9ub25jZSBub25jZTtcbiAgICAgIHVuc2FmZV9hdXRoZW50aWNhdGVfZW5jcnlwdF9pbnRvIH5rZXkgfm5vbmNlID9hZGF0YSBzcmMgfnNyY19vZmYgZHN0IH5kc3Rfb2ZmIH50YWdfb2ZmIGxlblxuXG4gICAgbGV0IGF1dGhlbnRpY2F0ZV9lbmNyeXB0IH5rZXkgfm5vbmNlID9hZGF0YSBjcyA9XG4gICAgICB2YWxpZF9ub25jZSBub25jZTtcbiAgICAgIGxldCBsID0gU3RyaW5nLmxlbmd0aCBjcyBpblxuICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSAobCArIHRhZ19zaXplKSBpblxuICAgICAgdW5zYWZlX2F1dGhlbnRpY2F0ZV9lbmNyeXB0X2ludG8gfmtleSB+bm9uY2UgP2FkYXRhIGNzIH5zcmNfb2ZmOjAgZHN0IH5kc3Rfb2ZmOjAgfnRhZ19vZmY6bCBsO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkc3RcblxuICAgIGxldCBhdXRoZW50aWNhdGVfZW5jcnlwdF90YWcgfmtleSB+bm9uY2UgP2FkYXRhIGNzID1cbiAgICAgIGxldCByZXMgPSBhdXRoZW50aWNhdGVfZW5jcnlwdCB+a2V5IH5ub25jZSA/YWRhdGEgY3MgaW5cbiAgICAgIFN0cmluZy5zdWIgcmVzIDAgKFN0cmluZy5sZW5ndGggY3MpLCBTdHJpbmcuc3ViIHJlcyAoU3RyaW5nLmxlbmd0aCBjcykgdGFnX3NpemVcblxuICAgIGxldCB1bnNhZmVfYXV0aGVudGljYXRlX2RlY3J5cHRfaW50byB+a2V5IH5ub25jZSA/KGFkYXRhID0gXCJcIikgc3JjIH5zcmNfb2ZmIH50YWdfb2ZmIGRzdCB+ZHN0X29mZiBsZW4gPVxuICAgICAgQ2NtLnVuc2FmZV9kZWNyeXB0aW9uX3ZlcmlmaWNhdGlvbl9pbnRvIH5jaXBoZXIgfmtleSB+bm9uY2UgfmFkYXRhIHNyYyB+c3JjX29mZiB+dGFnX29mZiBkc3QgfmRzdF9vZmYgbGVuXG5cbiAgICBsZXQgYXV0aGVudGljYXRlX2RlY3J5cHRfaW50byB+a2V5IH5ub25jZSA/YWRhdGEgc3JjIH5zcmNfb2ZmIH50YWdfb2ZmIGRzdCB+ZHN0X29mZiBsZW4gPVxuICAgICAgY2hlY2tfb2Zmc2V0IH50YWc6XCJDQ01cIiB+YnVmOlwic3JjXCIgfm9mZjpzcmNfb2ZmIH5sZW4gKFN0cmluZy5sZW5ndGggc3JjKTtcbiAgICAgIGNoZWNrX29mZnNldCB+dGFnOlwiQ0NNXCIgfmJ1ZjpcInNyYyB0YWdcIiB+b2ZmOnRhZ19vZmYgfmxlbjp0YWdfc2l6ZSAoU3RyaW5nLmxlbmd0aCBzcmMpO1xuICAgICAgY2hlY2tfb2Zmc2V0IH50YWc6XCJDQ01cIiB+YnVmOlwiZHN0XCIgfm9mZjpkc3Rfb2ZmIH5sZW4gKEJ5dGVzLmxlbmd0aCBkc3QpO1xuICAgICAgdmFsaWRfbm9uY2Ugbm9uY2U7XG4gICAgICB1bnNhZmVfYXV0aGVudGljYXRlX2RlY3J5cHRfaW50byB+a2V5IH5ub25jZSA/YWRhdGEgc3JjIH5zcmNfb2ZmIH50YWdfb2ZmIGRzdCB+ZHN0X29mZiBsZW5cblxuICAgIGxldCBhdXRoZW50aWNhdGVfZGVjcnlwdCB+a2V5IH5ub25jZSA/YWRhdGEgZGF0YSA9XG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIGRhdGEgPCB0YWdfc2l6ZSB0aGVuXG4gICAgICAgIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGRsZW4gPSBTdHJpbmcubGVuZ3RoIGRhdGEgLSB0YWdfc2l6ZSBpblxuICAgICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIGRsZW4gaW5cbiAgICAgICAgaWYgYXV0aGVudGljYXRlX2RlY3J5cHRfaW50byB+a2V5IH5ub25jZSA/YWRhdGEgZGF0YSB+c3JjX29mZjowIH50YWdfb2ZmOmRsZW4gZHN0IH5kc3Rfb2ZmOjAgZGxlbiB0aGVuXG4gICAgICAgICAgU29tZSAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBkc3QpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBOb25lXG5cbiAgICBsZXQgYXV0aGVudGljYXRlX2RlY3J5cHRfdGFnIH5rZXkgfm5vbmNlID9hZGF0YSB+dGFnIGNzID1cbiAgICAgIGF1dGhlbnRpY2F0ZV9kZWNyeXB0IH5rZXkgfm5vbmNlID9hZGF0YSAoY3MgXiB0YWcpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBBRVMgPSBzdHJ1Y3RcblxuICBtb2R1bGUgQ29yZSA6IEJsb2NrLkNvcmUgPSBzdHJ1Y3RcblxuICAgIGxldCBrZXkgICA9IFt8IDE2OyAyNDsgMzIgfF1cbiAgICBsZXQgYmxvY2sgPSAxNlxuXG4gICAgdHlwZSBla2V5ID0gc3RyaW5nICogaW50XG4gICAgdHlwZSBka2V5ID0gc3RyaW5nICogaW50XG5cbiAgICBsZXQgb2Zfc2VjcmV0X3dpdGggaW5pdCBrZXkgPVxuICAgICAgbGV0IHJvdW5kcyA9XG4gICAgICAgIG1hdGNoIFN0cmluZy5sZW5ndGgga2V5IHdpdGhcbiAgICAgICAgfCAxNiB8IDI0IHwgMzIgLT4gU3RyaW5nLmxlbmd0aCBrZXkgLyA0ICsgNlxuICAgICAgICB8IF8gLT4gaW52YWxpZF9hcmcgXCJBRVMub2Zfc2VjcmV0OiBrZXkgbGVuZ3RoICV1XCIgKFN0cmluZy5sZW5ndGgga2V5KVxuICAgICAgaW5cbiAgICAgIGxldCByayA9IEJ5dGVzLmNyZWF0ZSAoTmF0aXZlLkFFUy5ya19zIHJvdW5kcykgaW5cbiAgICAgIGluaXQga2V5IHJrIHJvdW5kcyA7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJrLCByb3VuZHNcblxuICAgIGxldCBkZXJpdmVfZCA/ZSBidWYgcmsgcnMgPSBOYXRpdmUuQUVTLmRlcml2ZV9kIGJ1ZiByayBycyBlXG5cbiAgICBsZXQgZV9vZl9zZWNyZXQgPSBvZl9zZWNyZXRfd2l0aCBOYXRpdmUuQUVTLmRlcml2ZV9lXG4gICAgbGV0IGRfb2Zfc2VjcmV0ID0gb2Zfc2VjcmV0X3dpdGggKGRlcml2ZV9kID9lOk5vbmUpXG5cbiAgICBsZXQgb2Zfc2VjcmV0IHNlY3JldCA9XG4gICAgICBsZXQgKGUsIF8pIGFzIGVrZXkgPSBlX29mX3NlY3JldCBzZWNyZXQgaW5cbiAgICAgIChla2V5LCBvZl9zZWNyZXRfd2l0aCAoZGVyaXZlX2QgfmUpIHNlY3JldClcblxuICAgICgqIFhYWCBhcmcgb3JkZXIgb2NhbWw8LT5jIHNsb3dzIGRvd24gKilcbiAgICAoKiBYWFggYm91bmRzIGNoZWNrcyAqKVxuXG4gICAgbGV0IGVuY3J5cHQgfmtleTooZSwgcm91bmRzKSB+YmxvY2tzIHNyYyBvZmYxIGRzdCBvZmYyID1cbiAgICAgIE5hdGl2ZS5BRVMuZW5jIHNyYyBvZmYxIGRzdCBvZmYyIGUgcm91bmRzIGJsb2Nrc1xuXG4gICAgbGV0IGRlY3J5cHQgfmtleTooZCwgcm91bmRzKSB+YmxvY2tzIHNyYyBvZmYxIGRzdCBvZmYyID1cbiAgICAgIE5hdGl2ZS5BRVMuZGVjIHNyYyBvZmYxIGRzdCBvZmYyIGQgcm91bmRzIGJsb2Nrc1xuXG4gIGVuZFxuXG4gIG1vZHVsZSBFQ0IgPSBNb2Rlcy5FQ0Jfb2YgKENvcmUpXG4gIG1vZHVsZSBDQkMgPSBNb2Rlcy5DQkNfb2YgKENvcmUpXG4gIG1vZHVsZSBDVFIgPSBNb2Rlcy5DVFJfb2YgKENvcmUpIChDb3VudGVycy5DMTI4YmUpXG4gIG1vZHVsZSBHQ00gPSBNb2Rlcy5HQ01fb2YgKENvcmUpXG4gIG1vZHVsZSBDQ00xNiA9IE1vZGVzLkNDTTE2X29mIChDb3JlKVxuXG5lbmRcblxubW9kdWxlIERFUyA9IHN0cnVjdFxuXG4gIG1vZHVsZSBDb3JlIDogQmxvY2suQ29yZSA9IHN0cnVjdFxuXG4gICAgbGV0IGtleSAgID0gW3wgMjQgfF1cbiAgICBsZXQgYmxvY2sgPSA4XG5cbiAgICB0eXBlIGVrZXkgPSBzdHJpbmdcbiAgICB0eXBlIGRrZXkgPSBzdHJpbmdcblxuICAgIGxldCBrX3MgPSBOYXRpdmUuREVTLmtfcyAoKVxuXG4gICAgbGV0IGdlbl9vZl9zZWNyZXQgfmRpcmVjdGlvbiBrZXkgPVxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBrZXkgPD4gMjQgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyBcIkRFUy5vZl9zZWNyZXQ6IGtleSBsZW5ndGggJXVcIiAoU3RyaW5nLmxlbmd0aCBrZXkpIDtcbiAgICAgIGxldCBrZXkgPSBCeXRlcy5vZl9zdHJpbmcga2V5IGluXG4gICAgICBsZXQga2V5YnVmID0gQnl0ZXMuY3JlYXRlIGtfcyBpblxuICAgICAgTmF0aXZlLkRFUy5kZXMza2V5IGtleSBkaXJlY3Rpb24ga2V5YnVmO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBrZXlidWZcblxuICAgIGxldCBlX29mX3NlY3JldCA9IGdlbl9vZl9zZWNyZXQgfmRpcmVjdGlvbjowXG4gICAgbGV0IGRfb2Zfc2VjcmV0ID0gZ2VuX29mX3NlY3JldCB+ZGlyZWN0aW9uOjFcblxuICAgIGxldCBvZl9zZWNyZXQgc2VjcmV0ID0gKGVfb2Zfc2VjcmV0IHNlY3JldCwgZF9vZl9zZWNyZXQgc2VjcmV0KVxuXG4gICAgbGV0IGVuY3J5cHQgfmtleSB+YmxvY2tzIHNyYyBvZmYxIGRzdCBvZmYyID1cbiAgICAgIE5hdGl2ZS5ERVMuZGRlcyBzcmMgb2ZmMSBkc3Qgb2ZmMiBibG9ja3Mga2V5XG5cbiAgICBsZXQgZGVjcnlwdCA9IGVuY3J5cHRcbiAgZW5kXG5cbiAgbW9kdWxlIEVDQiA9IE1vZGVzLkVDQl9vZiAoQ29yZSlcbiAgbW9kdWxlIENCQyA9IE1vZGVzLkNCQ19vZiAoQ29yZSlcbiAgbW9kdWxlIENUUiA9IE1vZGVzLkNUUl9vZiAoQ29yZSkgKENvdW50ZXJzLkM2NGJlKVxuXG5lbmRcblxubGV0IGFjY2VsZXJhdGVkID1cbiAgbGV0IGZsYWdzID1cbiAgICAobWF0Y2ggTmF0aXZlLm1pc2NfbW9kZSAoKSB3aXRoIDEgLT4gW2BYT1JdIHwgXyAtPiBbXSkgQFxuICAgIChtYXRjaCBOYXRpdmUuQUVTLm1vZGUgKCkgd2l0aCAxIC0+IFtgQUVTXSB8IF8gLT4gW10pIEBcbiAgICAobWF0Y2ggTmF0aXZlLkdIQVNILm1vZGUgKCkgd2l0aCAxIC0+IFtgR0hBU0hdIHwgXyAtPiBbXSkgaW5cbiAgZmxhZ3NcbiIsIm9wZW4gVW5jb21tb25cblxubW9kdWxlIHR5cGUgU3RyZWFtID0gc2lnXG4gIHR5cGUga2V5XG4gIHR5cGUgcmVzdWx0ID0geyBtZXNzYWdlIDogc3RyaW5nIDsga2V5IDoga2V5IH1cbiAgdmFsIG9mX3NlY3JldCA6IHN0cmluZyAtPiBrZXlcbiAgdmFsIGVuY3J5cHQgOiBrZXk6a2V5IC0+IHN0cmluZyAtPiByZXN1bHRcbiAgdmFsIGRlY3J5cHQgOiBrZXk6a2V5IC0+IHN0cmluZyAtPiByZXN1bHRcbmVuZFxuXG5tb2R1bGUgQVJDNCA9IHN0cnVjdFxuXG4gIHR5cGUga2V5ID0gaW50ICogaW50ICogaW50IGFycmF5XG5cbiAgdHlwZSByZXN1bHQgPSB7IG1lc3NhZ2UgOiBzdHJpbmcgOyBrZXkgOiBrZXkgfVxuXG4gIGxldCBvZl9zZWNyZXQgYnVmID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBidWYgaW5cbiAgICBpZiBsZW4gPCAxIHx8IGxlbiA+IDI1NiB0aGVuIGludmFsaWRfYXJnIFwiQVJDNC5vZl9zZWNyZXQ6IGtleSBzaXplICVkXCIgbGVuO1xuICAgIGxldCBzID0gQXJyYXkuaW5pdCAyNTYgKGZ1biB4IC0+IHgpIGluXG4gICAgbGV0IHJlYyBsb29wIGogPSBmdW5jdGlvblxuICAgICAgfCAyNTYgLT4gKClcbiAgICAgIHwgaSAtPlxuICAgICAgICAgIGxldCB4ID0gU3RyaW5nLmdldF91aW50OCBidWYgKGkgbW9kIGxlbikgaW5cbiAgICAgICAgICBsZXQgc2kgPSBzLihpKSBpblxuICAgICAgICAgIGxldCBqID0gKGogKyBzaSArIHgpIGxhbmQgMHhmZiBpblxuICAgICAgICAgIGxldCBzaiA9IHMuKGopIGluXG4gICAgICAgICAgcy4oaSkgPC0gc2ogOyBzLihqKSA8LSBzaSA7XG4gICAgICAgICAgKGxvb3AgW0B0YWlsY2FsbF0pIGogKHN1Y2MgaSlcbiAgICBpblxuICAgICggbG9vcCAwIDAgOyAoMCwgMCwgcykgKVxuXG4gIGxldCBlbmNyeXB0IH5rZXk6KGksIGosIHMnKSBidWYgPVxuICAgIGxldCBzICAgPSBBcnJheS5jb3B5IHMnXG4gICAgYW5kIGxlbiA9IFN0cmluZy5sZW5ndGggYnVmIGluXG4gICAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIG1peCBpIGogPSBmdW5jdGlvblxuICAgICAgfCBuIHdoZW4gbiA9IGxlbiAtPiAoaSwgaiwgcylcbiAgICAgIHwgbiAtPlxuICAgICAgICAgIGxldCBpICA9IHN1Y2MgaSBsYW5kIDB4ZmYgaW5cbiAgICAgICAgICBsZXQgc2kgPSBzLihpKSBpblxuICAgICAgICAgIGxldCBqICA9IChqICsgc2kpIGxhbmQgMHhmZiBpblxuICAgICAgICAgIGxldCBzaiA9IHMuKGopIGluXG4gICAgICAgICAgcy4oaSkgPC0gc2ogOyBzLihqKSA8LSBzaSA7XG4gICAgICAgICAgbGV0IGsgID0gcy4oKHNpICsgc2opIGxhbmQgMHhmZikgaW5cbiAgICAgICAgICBCeXRlcy5zZXRfdWludDggcmVzIG4gKGsgbHhvciBTdHJpbmcuZ2V0X3VpbnQ4IGJ1ZiBuKTtcbiAgICAgICAgICAobWl4IFtAdGFpbGNhbGxdKSBpIGogKHN1Y2MgbilcbiAgICBpblxuICAgIGxldCBrZXknID0gbWl4IGkgaiAwIGluXG4gICAgeyBrZXkgPSBrZXknIDsgbWVzc2FnZSA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzIH1cblxuICBsZXQgZGVjcnlwdCA9IGVuY3J5cHRcblxuZW5kXG4iXX0=
