// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Fuzzy_search
//# unitInfo: Requires: Core, Core__Array, Core__Char, Core__Int, Core__List, Core__Option, Core__Queue, Core__Set, Core__String, Core__Tuple, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Fuzzy_search$0 = "Fuzzy_search",
    cst_fuzzy_search$0 = "fuzzy_search",
    caml_check_bound = runtime.caml_check_bound,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Core_Array = global_data.Core__Array,
    Core_Tuple = global_data.Core__Tuple,
    Core_List = global_data.Core__List,
    Core_Option = global_data.Core__Option,
    Core_String = global_data.Core__String,
    Core_Int = global_data.Core__Int,
    Core_Char = global_data.Core__Char,
    Core_Queue = global_data.Core__Queue,
    Core_Set = global_data.Core__Set,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Fuzzy_search$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_fuzzy_search$0);
   caml_call1(Ppx_expect_runtime[1][1], "search/src/fuzzy_search.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_fuzzy_search$0, "fuzzy_search.ml");
   var
    cst_fuzzy_search = cst_fuzzy_search$0,
    cst_Fuzzy_search = cst_Fuzzy_search$0;
   function create(query){
    function _u_(s){return 1 - caml_call1(Core_String[14], s);}
    var
     _v_ = caml_call2(Core_String[78], query, 32),
     _w_ = caml_call2(Core_List[12], _v_, _u_),
     queries = caml_call1(Core_Array[24], _w_),
     case_sensitive = caml_call2(Core_String[19], query, Core_Char[20]);
    return [0, queries, query, case_sensitive];
   }
   function is_empty(t){return caml_call1(Core_String[14], t[2]);}
   var the_one_and_only = [0, 0, 0, 0];
   function equal_ignore_case(char1, char2){
    var
     _s_ = caml_call1(Core_Char[16], char2),
     _t_ = caml_call1(Core_Char[16], char1);
    return caml_call2(Core_Char[54], _t_, _s_);
   }
   function find_start_end_indices(query, item, param){
    var item_idx = [0, 0], query_idx = [0, 0];
    for(;;){
     if(! caml_call2(Core[92], item_idx[1], caml_ml_string_length(item)))
      break;
     if(! caml_call2(Core[92], query_idx[1], caml_ml_string_length(query)))
      break;
     var
      item_char = caml_string_get(item, item_idx[1]),
      query_char = caml_string_get(query, query_idx[1]);
     if(equal_ignore_case(item_char, query_char)) query_idx[1]++;
     item_idx[1]++;
    }
    if(caml_call2(Core[92], query_idx[1], caml_ml_string_length(query)))
     the_one_and_only[1] = 0;
    else{
     var
      end_idx = item_idx[1],
      item_idx$0 = [0, end_idx - 1 | 0],
      query_idx$0 = [0, caml_ml_string_length(query) - 1 | 0];
     for(;;){
      if(! caml_call2(Core[88], query_idx$0[1], 0)){
       var start_idx = item_idx$0[1] + 1 | 0;
       the_one_and_only[1] = 1;
       the_one_and_only[2] = start_idx;
       the_one_and_only[3] = end_idx;
       break;
      }
      var
       item_char$0 = caml_string_get(item, item_idx$0[1]),
       query_char$0 = caml_string_get(query, query_idx$0[1]);
      if(equal_ignore_case(item_char$0, query_char$0)) query_idx$0[1] += -1;
      item_idx$0[1] += -1;
     }
    }
    return the_one_and_only;
   }
   function matching_indices(query, item){
    if(is_empty(query)) return [0, [0]];
    function _p_(init, query){
     var
      f = Core_Set[12],
      match = find_start_end_indices(query, item, 0),
      found = match[1],
      start_idx = match[2],
      end_idx = match[3],
      acc = [0, init];
     if(found){
      var query_idx = [0, 0], _q_ = end_idx - 1 | 0;
      if(_q_ >= start_idx){
       var item_idx = start_idx;
       for(;;){
        var
         item_char = caml_string_get(item, item_idx),
         query_char = caml_string_get(query, query_idx[1]);
        if(equal_ignore_case(item_char, query_char)){
         acc[1] = caml_call2(f, acc[1], item_idx);
         query_idx[1]++;
        }
        var _r_ = item_idx + 1 | 0;
        if(_q_ === item_idx) break;
        var item_idx = _r_;
       }
      }
     }
     return acc[1];
    }
    var indices = caml_call3(Core_Array[36], query[1], Core_Int[99][5], _p_);
    return caml_call1(Core_Set[10], indices)
            ? 0
            : [0, caml_call1(Core_Set[40], indices)];
   }
   function split_by_matching_sections(query, item){
    var match = matching_indices(query, item);
    if(! match) return 0;
    var matches = match[1], len = matches.length - 1;
    if(! len) return [0, [0, [0, 357846217, item], 0]];
    var sections = caml_call2(Core_Queue[66], 0, 0);
    function add_section(matching, start, end_inclusive){
     var
      _o_ =
        [0,
         matching,
         caml_call3
          (Core_String[3], item, start, (end_inclusive - start | 0) + 1 | 0)];
     return caml_call2(Core_Queue[43], sections, _o_);
    }
    var first = caml_check_bound(matches, 0)[1];
    if(caml_call2(Core[91], first, 0))
     add_section(357846217, 0, first - 1 | 0);
    var matching_range_start = [0, first], matching_range_end = [0, first];
    function _n_(idx){
     if(caml_call2(Core[91], idx, matching_range_end[1] + 1 | 0)){
      add_section(485349597, matching_range_start[1], matching_range_end[1]);
      add_section(357846217, matching_range_end[1] + 1 | 0, idx - 1 | 0);
      matching_range_start[1] = idx;
     }
     matching_range_end[1] = idx;
     return 0;
    }
    caml_call2(Core_Array[35], matches, _n_);
    add_section(485349597, matching_range_start[1], matching_range_end[1]);
    if
     (caml_call2
       (Core[92], matching_range_end[1], caml_ml_string_length(item) - 1 | 0))
     add_section
      (357846217,
       matching_range_end[1] + 1 | 0,
       caml_ml_string_length(item) - 1 | 0);
    return [0, caml_call1(Core_Queue[28], sections)];
   }
   function of_char(param){
    if(65 <= param){
     if(97 <= param){if(123 > param) return 1;} else if(91 > param) return 0;
    }
    else if(9 >= param - 48 >>> 0) return 2;
    return 3;
   }
   var
    start_of_word_bonus = 480,
    camel_case_bonus = 360,
    non_word_bonus = 480,
    match_bonus = 320;
   function score(query, item){
    var
     match$0 = caml_call1(Core_String[14], item),
     match$1 = is_empty(query);
    if(match$0) return 0;
    if(match$1) return 1;
    var
     case_sensitive = query[3],
     raw = query[2],
     queries = query[1],
     raw_score = [0, 0],
     any_mismatch = [0, 0],
     _l_ = queries.length - 1 - 1 | 0,
     _k_ = 0;
    if(_l_ >= 0){
     var i = _k_;
     for(;;){
      var
       query$0 = caml_check_bound(queries, i)[1 + i],
       match = find_start_end_indices(query$0, item, 0),
       found = match[1],
       start_idx = match[2],
       end_idx = match[3];
      if(found){
       var
        start_char_class =
          caml_call2(Core[90], start_idx, 0)
           ? 3
           : of_char(caml_string_get(item, start_idx - 1 | 0)),
        query_idx = [0, 0],
        score = [0, 0],
        in_gap = [0, 0],
        prev_char_class = [0, start_char_class],
        prev_char_score = [0, 0],
        _h_ = end_idx - 1 | 0;
       if(_h_ >= start_idx){
        var item_idx = start_idx;
        for(;;){
         var
          item_char = caml_string_get(item, item_idx),
          query_char = caml_string_get(query$0, query_idx[1]);
         if(equal_ignore_case(item_char, query_char)){
          var char_class = of_char(item_char), _i_ = prev_char_class[1];
          a:
          {
           b:
           {
            c:
            {
             if(_i_)
              switch(_i_ - 1 | 0){
                case 0:
                 if(1 === char_class) break b;
                 if(! char_class) break c;
                 break;
                case 1: break;
                default:
                 if(3 > char_class){
                  var base_score = start_of_word_bonus;
                  break a;
                 }
              }
             if(2 !== char_class){
              if(3 > char_class) break b;
              var base_score = non_word_bonus;
              break a;
             }
            }
            var base_score = camel_case_bonus;
            break a;
           }
           var base_score = match_bonus;
          }
          var
           with_start_of_item_bonus =
             caml_call2(Core[90], item_idx, 0)
              ? base_score + 1 | 0
              : base_score,
           with_consecutive_bonus =
             in_gap[1]
              ? with_start_of_item_bonus
              : caml_call2
                (Core_Int[90], with_start_of_item_bonus, prev_char_score[1]);
          a:
          {
           if
            (!
             caml_call2(Core_Char[54], item_char, query_char)
             && case_sensitive){
            var with_wrong_case_penalty = with_consecutive_bonus - 120 | 0;
            break a;
           }
           var with_wrong_case_penalty = with_consecutive_bonus;
          }
          var
           this_char_score =
             caml_call2(Core[90], query_idx[1], 0)
              ? 2 * with_wrong_case_penalty | 0
              : with_wrong_case_penalty;
          query_idx[1]++;
          score[1] = score[1] + this_char_score | 0;
          prev_char_class[1] = char_class;
          prev_char_score[1] = this_char_score;
          in_gap[1] = 0;
         }
         else{
          var this_char_score$0 = in_gap[1] ? -20 : -60;
          score[1] = score[1] + this_char_score$0 | 0;
          in_gap[1] = 1;
         }
         var _j_ = item_idx + 1 | 0;
         if(_h_ === item_idx) break;
         var item_idx = _j_;
        }
       }
       var score$0 = score[1];
      }
      else
       var score$0 = 0;
      if(caml_call2(Core[90], score$0, 0)) any_mismatch[1] = 1;
      raw_score[1] = raw_score[1] + score$0 | 0;
      var _m_ = i + 1 | 0;
      if(_l_ === i) break;
      var i = _m_;
     }
    }
    if(0 === raw_score[1]) return 0;
    if(any_mismatch[1]) return 0;
    var query_length = caml_ml_string_length(raw);
    return ((962 * query_length | 0) + 1 | 0) - raw_score[1] | 0;
   }
   function score_opt(query, item){
    var x = score(query, item);
    return 0 === x ? 0 : [0, x];
   }
   function find_start_end_indices$0(query, item, param){
    var
     match = find_start_end_indices(query, item, 0),
     found = match[1],
     start_idx = match[2],
     end_idx = match[3];
    return caml_call2(Core_Option[60], found, [0, start_idx, end_idx]);
   }
   var For_testing = [0, find_start_end_indices$0];
   function search(query, items){
    var _c_ = Core_Tuple[2][10];
    function _d_(a_001, b_002){
     var
      t_005 = a_001[3],
      t_004 = a_001[2],
      t_003 = a_001[1],
      t_008 = b_002[3],
      t_007 = b_002[2],
      t_006 = b_002[1],
      n = caml_call2(Core[382], t_003, t_006);
     if(0 !== n) return n;
     var n$0 = caml_call2(Core[382], t_004, t_007);
     return 0 === n$0 ? caml_call2(Core[551], t_005, t_008) : n$0;
    }
    function _e_(item){
     var score$0 = score(query, item);
     return 0 === score$0
             ? 0
             : [0, [0, score$0, caml_ml_string_length(item), item]];
    }
    var
     _f_ = caml_call2(Core_List[13], items, _e_),
     _g_ = caml_call2(Core_List[79], _f_, _d_);
    return caml_call2(Core_List[51], _g_, _c_);
   }
   function search$0(query, items){
    function _a_(item){
     var score$0 = score(query, item);
     return 0 === score$0
             ? 0
             : [0, [0, score$0, caml_ml_string_length(item), item]];
    }
    var items_by_score = caml_call2(Core_Array[29], items, _a_);
    function _b_(a_009, b_010){
     var
      t_013 = a_009[3],
      t_012 = a_009[2],
      t_011 = a_009[1],
      t_016 = b_010[3],
      t_015 = b_010[2],
      t_014 = b_010[1],
      n = caml_call2(Core[382], t_011, t_014);
     if(0 !== n) return n;
     var n$0 = caml_call2(Core[382], t_012, t_015);
     return 0 === n$0 ? caml_call2(Core[551], t_013, t_016) : n$0;
    }
    caml_call4(Core_Array[81], 0, 0, items_by_score, _b_);
    return caml_call2(Core_Array[27], items_by_score, Core_Tuple[2][10]);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_fuzzy_search);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Fuzzy_search);
   var
    Fuzzy_search =
      [0,
       [0, create],
       score,
       score_opt,
       matching_indices,
       split_by_matching_sections,
       search,
       search$0,
       For_testing];
   runtime.caml_register_global(21, Fuzzy_search, cst_Fuzzy_search$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJmdXp6eV9zZWFyY2guY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImNyZWF0ZSIsInF1ZXJ5IiwicyIsInF1ZXJpZXMiLCJjYXNlX3NlbnNpdGl2ZSIsImlzX2VtcHR5IiwidCIsInRoZV9vbmVfYW5kX29ubHkiLCJlcXVhbF9pZ25vcmVfY2FzZSIsImNoYXIxIiwiY2hhcjIiLCJmaW5kX3N0YXJ0X2VuZF9pbmRpY2VzIiwiaXRlbSIsIml0ZW1faWR4IiwicXVlcnlfaWR4IiwiaXRlbV9jaGFyIiwicXVlcnlfY2hhciIsImVuZF9pZHgiLCJpdGVtX2lkeCQwIiwicXVlcnlfaWR4JDAiLCJzdGFydF9pZHgiLCJpdGVtX2NoYXIkMCIsInF1ZXJ5X2NoYXIkMCIsIm1hdGNoaW5nX2luZGljZXMiLCJpbml0IiwiZiIsImZvdW5kIiwiYWNjIiwiaW5kaWNlcyIsInNwbGl0X2J5X21hdGNoaW5nX3NlY3Rpb25zIiwibWF0Y2hlcyIsInNlY3Rpb25zIiwiYWRkX3NlY3Rpb24iLCJtYXRjaGluZyIsInN0YXJ0IiwiZW5kX2luY2x1c2l2ZSIsImZpcnN0IiwibWF0Y2hpbmdfcmFuZ2Vfc3RhcnQiLCJtYXRjaGluZ19yYW5nZV9lbmQiLCJpZHgiLCJvZl9jaGFyIiwic3RhcnRfb2Zfd29yZF9ib251cyIsImNhbWVsX2Nhc2VfYm9udXMiLCJub25fd29yZF9ib251cyIsIm1hdGNoX2JvbnVzIiwic2NvcmUiLCJyYXciLCJyYXdfc2NvcmUiLCJhbnlfbWlzbWF0Y2giLCJpIiwicXVlcnkkMCIsInN0YXJ0X2NoYXJfY2xhc3MiLCJpbl9nYXAiLCJwcmV2X2NoYXJfY2xhc3MiLCJwcmV2X2NoYXJfc2NvcmUiLCJjaGFyX2NsYXNzIiwiYmFzZV9zY29yZSIsIndpdGhfc3RhcnRfb2ZfaXRlbV9ib251cyIsIndpdGhfY29uc2VjdXRpdmVfYm9udXMiLCJ3aXRoX3dyb25nX2Nhc2VfcGVuYWx0eSIsInRoaXNfY2hhcl9zY29yZSIsInRoaXNfY2hhcl9zY29yZSQwIiwic2NvcmUkMCIsInF1ZXJ5X2xlbmd0aCIsInNjb3JlX29wdCIsIngiLCJmaW5kX3N0YXJ0X2VuZF9pbmRpY2VzJDAiLCJzZWFyY2giLCJpdGVtcyIsImFfMDAxIiwiYl8wMDIiLCJ0XzAwNSIsInRfMDA0IiwidF8wMDMiLCJ0XzAwOCIsInRfMDA3IiwidF8wMDYiLCJuIiwibiQwIiwic2VhcmNoJDAiLCJpdGVtc19ieV9zY29yZSIsImFfMDA5IiwiYl8wMTAiLCJ0XzAxMyIsInRfMDEyIiwidF8wMTEiLCJ0XzAxNiIsInRfMDE1IiwidF8wMTQiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9mdXp6eV9tYXRjaC9zZWFyY2gvZnV6enlfc2VhcmNoLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFhTUEsT0FBT0M7SUFDVCxhQUV5QkMsR0FBSyxXQUFJLDRCQUFUQSxHQUE0QjtJQURuRDtLQUFBLE1BQUEsNEJBRk9EO0tBRVAsTUFBQTtLQURFRSxVQUNGO0tBS0VDLGlCQUVTLDRCQVRKSDtJQVdULFdBVklFLFNBREtGLE9BT0xHO0dBSW9DO1lBR3RDQyxTQUFTQyxHQUFJLG1DQUFKQSxNQUF5QjtHQVVmLElBUW5CQztZQUxGQyxrQkFBa0JDLE9BQU1DO0lBQzFCO0tBQWtDLE1BQUEsMEJBRFJBO0tBQ2YsTUFBQSwwQkFEU0Q7SUFDYyxPQUFBO0dBQXNCO1lBRzdDRSx1QkFBd0JWLE9BQU9XO0lBQzFDLElBQ0lDLG1CQUNBQzs7S0FDRSxLQUFBLHFCQUZGRCxtQ0FGc0NEOztLQUlGLEtBQUEscUJBRHBDRSxvQ0FIK0JiOztLQUtqQjtNQUFaYyxZQUFZLGdCQUx3QkgsTUFFdENDO01BSUVHLGFBQWEsZ0JBTmdCZixPQUcvQmE7S0FJQyxHQVhITixrQkFTSU8sV0FDQUMsYUFIRkY7S0FEQUQ7O0lBUUQsR0FBQSxxQkFQQ0Msb0NBSCtCYjtLQUMvQk07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QUFBLE9BQUFBO0tBQU0sSUFBQUMsTUFBQSxzQkFBTk4sT0FBQUc7a0JBQU1HLE1BQU0sc0JBQVpQLE9BQUFHLFNBQU1JO0lBQVk7aUJBTnJCbEU7S0FDdEIsSUFFSmtELFVBMUNGakIsTUFzQ081QyxPQUNxQlc7a0JBRzFCa0Q7O3VCQUFBQSwrQkFIMEJsRCxPQUFBQTtJQUtZO0lBTDFDO0tBQUEsTUFBQSwwQkFEZ0J3RDtLQUNoQixNQUFBO0lBQUEsT0FBQTtHQU8wQjtZQUd4QlcsU0FBUTlFLE9BQU9tRTtpQkFFZ0J4RDtLQUN2QixJQUVKa0QsVUF0REpqQixNQWlEUTVDLE9BRXVCVztrQkFHM0JrRDs7dUJBQUFBLCtCQUgyQmxELE9BQUFBO0lBS1c7SUFMMUMsSUFERW9FLGlCQUNGLDJCQUZlWjtpQkFTNkJhLE9BQUFDO0tBQUE7TUFBQUMsUUFBQUY7TUFBQUcsUUFBQUg7TUFBQUksUUFBQUo7TUFBQUssUUFBQUo7TUFBQUssUUFBQUw7TUFBQU0sUUFBQU47TUFBQUwsSUFBQSxzQkFBQVEsT0FBQUc7Y0FBQVgsR0FBQSxPQUFBQTtLQUFNLElBQUFDLE1BQUEsc0JBQU5NLE9BQUFHO2tCQUFNVCxNQUFNLHNCQUFaSyxPQUFBRyxTQUFNUjtJQUFZO0lBQWhFLGlDQVJJRTtJQUNGLE9BQUEsMkJBREVBO0dBU21DOzs7Ozs7OztXQTNSbkNoRjtPQWdPRjZDO09BdUJBbUI7T0F4S0F6QztPQVdBTTtPQTRLQXNDO09BV0FZOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBDb3JlXG5cbm1vZHVsZSBDYXNlX21vZGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gU21hcnRcbmVuZFxuXG5tb2R1bGUgUXVlcnkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHF1ZXJpZXMgOiBzdHJpbmcgYXJyYXkgKCogVGhlIHBhdHRlcm4gc3BsaXQgYnkgc3BhY2VzICopXG4gICAgOyByYXcgOiBzdHJpbmdcbiAgICA7IGNhc2Vfc2Vuc2l0aXZlIDogYm9vbFxuICAgIH1cblxuICBsZXQgY3JlYXRlIHF1ZXJ5ID1cbiAgICBsZXQgcXVlcmllcyA9XG4gICAgICBTdHJpbmcuc3BsaXQgcXVlcnkgfm9uOicgJ1xuICAgICAgfD4gTGlzdC5maWx0ZXIgfmY6KGZ1biBzIC0+IG5vdCAoU3RyaW5nLmlzX2VtcHR5IHMpKVxuICAgICAgfD4gQXJyYXkub2ZfbGlzdFxuICAgIGluXG4gICAgbGV0IGNhc2VfbW9kZSA9IENhc2VfbW9kZS5TbWFydCBpblxuICAgIGxldCBjYXNlX3NlbnNpdGl2ZSA9XG4gICAgICBtYXRjaCBjYXNlX21vZGUgd2l0aFxuICAgICAgfCBTbWFydCAtPiBTdHJpbmcuZXhpc3RzIHF1ZXJ5IH5mOkNoYXIuaXNfdXBwZXJjYXNlXG4gICAgaW5cbiAgICB7IHF1ZXJpZXM7IHJhdyA9IHF1ZXJ5OyBjYXNlX3NlbnNpdGl2ZSB9XG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBTdHJpbmcuaXNfZW1wdHkgdC5yYXdcbmVuZFxuXG5tb2R1bGUgU3RhcnRfZW5kX2luZGljZXMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgZm91bmQgOiBib29sXG4gICAgOyBtdXRhYmxlIHN0YXJ0X2lkeCA6IGludFxuICAgIDsgbXV0YWJsZSBlbmRfaWR4IDogaW50XG4gICAgfVxuXG4gIGxldCB0aGVfb25lX2FuZF9vbmx5ID0geyBmb3VuZCA9IGZhbHNlOyBzdGFydF9pZHggPSAwOyBlbmRfaWR4ID0gMCB9XG5lbmRcblxubGV0IGVxdWFsX2lnbm9yZV9jYXNlIGNoYXIxIGNoYXIyID1cbiAgQ2hhci5lcXVhbCAoQ2hhci5sb3dlcmNhc2UgY2hhcjEpIChDaGFyLmxvd2VyY2FzZSBjaGFyMilcbjs7XG5cbmxldFtAaW5saW5lXSBmaW5kX3N0YXJ0X2VuZF9pbmRpY2VzIH5xdWVyeSB+aXRlbSAoKSA9XG4gIGxldCBkc3QgPSBTdGFydF9lbmRfaW5kaWNlcy50aGVfb25lX2FuZF9vbmx5IGluXG4gIGxldCBpdGVtX2lkeCA9IHJlZiAwIGluXG4gIGxldCBxdWVyeV9pZHggPSByZWYgMCBpblxuICB3aGlsZSAhaXRlbV9pZHggPCBTdHJpbmcubGVuZ3RoIGl0ZW0gJiYgIXF1ZXJ5X2lkeCA8IFN0cmluZy5sZW5ndGggcXVlcnkgZG9cbiAgICBsZXQgaXRlbV9jaGFyID0gU3RyaW5nLmdldCBpdGVtICFpdGVtX2lkeCBpblxuICAgIGxldCBxdWVyeV9jaGFyID0gU3RyaW5nLmdldCBxdWVyeSAhcXVlcnlfaWR4IGluXG4gICAgaWYgZXF1YWxfaWdub3JlX2Nhc2UgaXRlbV9jaGFyIHF1ZXJ5X2NoYXIgdGhlbiBpbmNyIHF1ZXJ5X2lkeDtcbiAgICBpbmNyIGl0ZW1faWR4XG4gIGRvbmU7XG4gIGlmICFxdWVyeV9pZHggPCBTdHJpbmcubGVuZ3RoIHF1ZXJ5XG4gIHRoZW4gZHN0LmZvdW5kIDwtIGZhbHNlXG4gIGVsc2UgKFxuICAgIGxldCBlbmRfaWR4ID0gIWl0ZW1faWR4IGluXG4gICAgbGV0IGl0ZW1faWR4ID0gcmVmIChlbmRfaWR4IC0gMSkgaW5cbiAgICBsZXQgcXVlcnlfaWR4ID0gcmVmIChTdHJpbmcubGVuZ3RoIHF1ZXJ5IC0gMSkgaW5cbiAgICB3aGlsZSAhcXVlcnlfaWR4ID49IDAgZG9cbiAgICAgIGxldCBpdGVtX2NoYXIgPSBTdHJpbmcuZ2V0IGl0ZW0gIWl0ZW1faWR4IGluXG4gICAgICBsZXQgcXVlcnlfY2hhciA9IFN0cmluZy5nZXQgcXVlcnkgIXF1ZXJ5X2lkeCBpblxuICAgICAgaWYgZXF1YWxfaWdub3JlX2Nhc2UgaXRlbV9jaGFyIHF1ZXJ5X2NoYXIgdGhlbiBkZWNyIHF1ZXJ5X2lkeDtcbiAgICAgIGRlY3IgaXRlbV9pZHhcbiAgICBkb25lO1xuICAgIGxldCBzdGFydF9pZHggPSAhaXRlbV9pZHggKyAxIGluXG4gICAgZHN0LmZvdW5kIDwtIHRydWU7XG4gICAgZHN0LnN0YXJ0X2lkeCA8LSBzdGFydF9pZHg7XG4gICAgZHN0LmVuZF9pZHggPC0gZW5kX2lkeCk7XG4gIGRzdFxuOztcblxubGV0IGZvbGRfbWF0Y2hpbmdfaW5kaWNlc19zaW5nbGVfcXVlcnkgcXVlcnkgfml0ZW0gfmluaXQgfmYgPVxuICBsZXQgeyBTdGFydF9lbmRfaW5kaWNlcy5zdGFydF9pZHg7IGVuZF9pZHg7IGZvdW5kIH0gPVxuICAgIGZpbmRfc3RhcnRfZW5kX2luZGljZXMgfnF1ZXJ5IH5pdGVtICgpXG4gIGluXG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBpZiBmb3VuZFxuICB0aGVuIChcbiAgICBsZXQgcXVlcnlfaWR4ID0gcmVmIDAgaW5cbiAgICBmb3IgaXRlbV9pZHggPSBzdGFydF9pZHggdG8gZW5kX2lkeCAtIDEgZG9cbiAgICAgIGxldCBpdGVtX2NoYXIgPSBTdHJpbmcuZ2V0IGl0ZW0gaXRlbV9pZHggaW5cbiAgICAgIGxldCBxdWVyeV9jaGFyID0gU3RyaW5nLmdldCBxdWVyeSAhcXVlcnlfaWR4IGluXG4gICAgICBpZiBlcXVhbF9pZ25vcmVfY2FzZSBpdGVtX2NoYXIgcXVlcnlfY2hhclxuICAgICAgdGhlbiAoXG4gICAgICAgIGFjYyA6PSBmICFhY2MgaXRlbV9pZHg7XG4gICAgICAgIGluY3IgcXVlcnlfaWR4KVxuICAgIGRvbmUpO1xuICAhYWNjXG47O1xuXG5sZXQgbWF0Y2hpbmdfaW5kaWNlcyAocXVlcnkgOiBRdWVyeS50KSB+aXRlbSA9XG4gIGlmIFF1ZXJ5LmlzX2VtcHR5IHF1ZXJ5XG4gIHRoZW4gU29tZSBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCBpbmRpY2VzID1cbiAgICAgIEFycmF5LmZvbGQgcXVlcnkucXVlcmllcyB+aW5pdDpJbnQuU2V0LmVtcHR5IH5mOihmdW4gc2V0IHF1ZXJ5IC0+XG4gICAgICAgIGZvbGRfbWF0Y2hpbmdfaW5kaWNlc19zaW5nbGVfcXVlcnkgcXVlcnkgfml0ZW0gfmluaXQ6c2V0IH5mOlNldC5hZGQpXG4gICAgaW5cbiAgICBpZiBTZXQuaXNfZW1wdHkgaW5kaWNlcyB0aGVuIE5vbmUgZWxzZSBTb21lIChTZXQudG9fYXJyYXkgaW5kaWNlcykpXG47O1xuXG5sZXQgc3BsaXRfYnlfbWF0Y2hpbmdfc2VjdGlvbnMgKHF1ZXJ5IDogUXVlcnkudCkgfml0ZW0gPVxuICBtYXRjaCBtYXRjaGluZ19pbmRpY2VzIHF1ZXJ5IH5pdGVtIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIFt8fF0gLT4gU29tZSBbIGBOb3RfbWF0Y2hpbmcsIGl0ZW0gXVxuICB8IFNvbWUgbWF0Y2hlcyAtPlxuICAgIGxldCBzZWN0aW9ucyA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICAgIGxldCBhZGRfc2VjdGlvbiBtYXRjaGluZyBzdGFydCBlbmRfaW5jbHVzaXZlID1cbiAgICAgIFF1ZXVlLmVucXVldWVcbiAgICAgICAgc2VjdGlvbnNcbiAgICAgICAgKG1hdGNoaW5nLCBTdHJpbmcuc3ViIGl0ZW0gfnBvczpzdGFydCB+bGVuOihlbmRfaW5jbHVzaXZlIC0gc3RhcnQgKyAxKSlcbiAgICBpblxuICAgIGxldCBmaXJzdCA9IG1hdGNoZXMuKDApIGluXG4gICAgaWYgZmlyc3QgPiAwIHRoZW4gYWRkX3NlY3Rpb24gYE5vdF9tYXRjaGluZyAwIChmaXJzdCAtIDEpO1xuICAgIGxldCBtYXRjaGluZ19yYW5nZV9zdGFydCA9IHJlZiBmaXJzdCBpblxuICAgIGxldCBtYXRjaGluZ19yYW5nZV9lbmQgPSByZWYgZmlyc3QgaW5cbiAgICBBcnJheS5pdGVyIG1hdGNoZXMgfmY6KGZ1biBpZHggLT5cbiAgICAgIGlmIGlkeCA+ICFtYXRjaGluZ19yYW5nZV9lbmQgKyAxXG4gICAgICB0aGVuIChcbiAgICAgICAgYWRkX3NlY3Rpb24gYE1hdGNoaW5nICFtYXRjaGluZ19yYW5nZV9zdGFydCAhbWF0Y2hpbmdfcmFuZ2VfZW5kO1xuICAgICAgICBhZGRfc2VjdGlvbiBgTm90X21hdGNoaW5nICghbWF0Y2hpbmdfcmFuZ2VfZW5kICsgMSkgKGlkeCAtIDEpO1xuICAgICAgICBtYXRjaGluZ19yYW5nZV9zdGFydCA6PSBpZHgpO1xuICAgICAgbWF0Y2hpbmdfcmFuZ2VfZW5kIDo9IGlkeCk7XG4gICAgYWRkX3NlY3Rpb24gYE1hdGNoaW5nICFtYXRjaGluZ19yYW5nZV9zdGFydCAhbWF0Y2hpbmdfcmFuZ2VfZW5kO1xuICAgIGlmICFtYXRjaGluZ19yYW5nZV9lbmQgPCBTdHJpbmcubGVuZ3RoIGl0ZW0gLSAxXG4gICAgdGhlbiBhZGRfc2VjdGlvbiBgTm90X21hdGNoaW5nICghbWF0Y2hpbmdfcmFuZ2VfZW5kICsgMSkgKFN0cmluZy5sZW5ndGggaXRlbSAtIDEpO1xuICAgIFNvbWUgKFF1ZXVlLnRvX2xpc3Qgc2VjdGlvbnMpXG47O1xuXG5tb2R1bGUgQ2hhcl9jbGFzcyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgVXBwZXJcbiAgICB8IExvd2VyXG4gICAgfCBEaWdpdFxuICAgIHwgTm9uX3dvcmRcblxuICBsZXQgb2ZfY2hhciA9IGZ1bmN0aW9uXG4gICAgfCAnQScgLi4gJ1onIC0+IFVwcGVyXG4gICAgfCAnYScgLi4gJ3onIC0+IExvd2VyXG4gICAgfCAnMCcgLi4gJzknIC0+IERpZ2l0XG4gICAgfCBfIC0+IE5vbl93b3JkXG4gIDs7XG5lbmRcblxubGV0IHN0YXJ0X29mX2l0ZW1fYm9udXMgPSAxXG5sZXQgc3RhcnRfb2Zfd29yZF9ib251cyA9IDQ4MFxubGV0IGNhbWVsX2Nhc2VfYm9udXMgPSAzNjBcbmxldCBub25fd29yZF9ib251cyA9IDQ4MFxubGV0IG1hdGNoX2JvbnVzID0gMzIwXG5sZXQgc3RhcnRfZ2FwX3BlbmFsdHkgPSA2MFxubGV0IGNvbnRpbnVlX2dhcF9wZW5hbHR5ID0gMjBcblxuKCogV3JvbmcgY2FzZSBwZW5hbHR5IGlzIG9ubHkgdXNlZCB3aGVuIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSB1cHBlcmNhc2UgY2hhcmFjdGVyIHNvIHdlXG4gICBtYWtlIGl0IGV4dHJlbWUgKilcbmxldCB3cm9uZ19jYXNlX3BlbmFsdHkgPSAxMjBcbmxldCBmaXJzdF9jaGFyX211bHRpcGxpZXIgPSAyXG5cbmxldCBzY29yZV91cHBlcl9ib3VuZCB+cXVlcnlfbGVuZ3RoID1cbiAgKCogT25seSBjaGFyYWN0ZXJzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIHF1ZXJ5IGNhbiBoYXZlIHBvc2l0aXZlIHNjb3JlLiBUaGUgbWF4aW11bVxuICAgICBwb3NpdGl2ZSBzY29yZSBpcyB3aGVuIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHF1ZXJ5IG1hdGNoZXMgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICBvZiB0aGUgaXRlbSBhbmQgaXQgaXMgYWxzbyB0aGUgc3RhcnQgb2YgYSB3b3JkLiAqKVxuICAoKHN0YXJ0X29mX2l0ZW1fYm9udXMgKyBzdGFydF9vZl93b3JkX2JvbnVzKSAqIGZpcnN0X2NoYXJfbXVsdGlwbGllciAqIHF1ZXJ5X2xlbmd0aCkgKyAxXG47O1xuXG4oKiBGb3IgYSBbc2luZ2xlX3Njb3JlX3F1ZXJ5XSBoaWdoZXIgc2NvcmVzIGFyZSBiZXR0ZXIgYW5kIHdlIHRha2Ugc2NvcmVfdXBwZXJfYm91bmQgLVxuICAgc2NvcmVfc2luZ2xlX3F1ZXJ5IGluIHNjb3JlLlxuXG4gICBBc3N1bXB0aW9uOlxuICAgLSBbcXVlcnldIGFuZCBbaXRlbV0gYXJlIG5vdCBlbXB0eS5cbiAgIC0gV2hlbiB0aGVyZSBpcyBubyBtYXRjaCwgcmV0dXJuIDAuIFdoZW4gdGhlIHF1ZXJ5IGlzIFwiXCIgYW5kIGl0ZW0gaXMgbm90IFwiXCIgKGluZmluaXRlbHlcbiAgICAgbWFueSBtYXRjaGVzPyksIHJldHVybiBzY29yZSB1cHBlciBib3VuZC5cbiopXG5sZXQgc2NvcmVfc2luZ2xlX3F1ZXJ5IHF1ZXJ5IH5pdGVtIH5jYXNlX3NlbnNpdGl2ZSA9XG4gIGxldCB7IFN0YXJ0X2VuZF9pbmRpY2VzLmZvdW5kOyBzdGFydF9pZHg7IGVuZF9pZHggfSA9XG4gICAgZmluZF9zdGFydF9lbmRfaW5kaWNlcyB+cXVlcnkgfml0ZW0gKClcbiAgaW5cbiAgaWYgbm90IGZvdW5kXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBsZXQgc3RhcnRfY2hhcl9jbGFzcyA9XG4gICAgICBpZiBzdGFydF9pZHggPSAwXG4gICAgICB0aGVuIENoYXJfY2xhc3MuTm9uX3dvcmRcbiAgICAgIGVsc2UgQ2hhcl9jbGFzcy5vZl9jaGFyIChTdHJpbmcuZ2V0IGl0ZW0gKHN0YXJ0X2lkeCAtIDEpKVxuICAgIGluXG4gICAgbGV0IHF1ZXJ5X2lkeCA9IHJlZiAwIGluXG4gICAgbGV0IHNjb3JlID0gcmVmIDAgaW5cbiAgICBsZXQgaW5fZ2FwID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHByZXZfY2hhcl9jbGFzcyA9IHJlZiBzdGFydF9jaGFyX2NsYXNzIGluXG4gICAgbGV0IHByZXZfY2hhcl9zY29yZSA9IHJlZiAwIGluXG4gICAgZm9yIGl0ZW1faWR4ID0gc3RhcnRfaWR4IHRvIGVuZF9pZHggLSAxIGRvXG4gICAgICBsZXQgaXRlbV9jaGFyID0gU3RyaW5nLmdldCBpdGVtIGl0ZW1faWR4IGluXG4gICAgICBsZXQgcXVlcnlfY2hhciA9IFN0cmluZy5nZXQgcXVlcnkgIXF1ZXJ5X2lkeCBpblxuICAgICAgaWYgZXF1YWxfaWdub3JlX2Nhc2UgaXRlbV9jaGFyIHF1ZXJ5X2NoYXJcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgY2hhcl9jbGFzcyA9IENoYXJfY2xhc3Mub2ZfY2hhciBpdGVtX2NoYXIgaW5cbiAgICAgICAgbGV0IHRoaXNfY2hhcl9zY29yZSA9XG4gICAgICAgICAgbGV0IGJhc2Vfc2NvcmUgPVxuICAgICAgICAgICAgbWF0Y2ggIXByZXZfY2hhcl9jbGFzcywgY2hhcl9jbGFzcyB3aXRoXG4gICAgICAgICAgICB8IE5vbl93b3JkLCAoVXBwZXIgfCBMb3dlciB8IERpZ2l0KSAtPiBzdGFydF9vZl93b3JkX2JvbnVzXG4gICAgICAgICAgICB8IExvd2VyLCBVcHBlciB8IF8sIERpZ2l0IC0+IGNhbWVsX2Nhc2VfYm9udXNcbiAgICAgICAgICAgIHwgXywgTm9uX3dvcmQgLT4gbm9uX3dvcmRfYm9udXNcbiAgICAgICAgICAgIHwgXywgXyAtPiBtYXRjaF9ib251c1xuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHdpdGhfc3RhcnRfb2ZfaXRlbV9ib251cyA9XG4gICAgICAgICAgICBpZiBpdGVtX2lkeCA9IDAgdGhlbiBiYXNlX3Njb3JlICsgc3RhcnRfb2ZfaXRlbV9ib251cyBlbHNlIGJhc2Vfc2NvcmVcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCB3aXRoX2NvbnNlY3V0aXZlX2JvbnVzID1cbiAgICAgICAgICAgIGlmICFpbl9nYXBcbiAgICAgICAgICAgIHRoZW4gd2l0aF9zdGFydF9vZl9pdGVtX2JvbnVzXG4gICAgICAgICAgICBlbHNlIEludC5tYXggd2l0aF9zdGFydF9vZl9pdGVtX2JvbnVzICFwcmV2X2NoYXJfc2NvcmVcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCB3aXRoX3dyb25nX2Nhc2VfcGVuYWx0eSA9XG4gICAgICAgICAgICBpZiBDaGFyLmVxdWFsIGl0ZW1fY2hhciBxdWVyeV9jaGFyIHx8IG5vdCBjYXNlX3NlbnNpdGl2ZVxuICAgICAgICAgICAgdGhlbiB3aXRoX2NvbnNlY3V0aXZlX2JvbnVzXG4gICAgICAgICAgICBlbHNlIHdpdGhfY29uc2VjdXRpdmVfYm9udXMgLSB3cm9uZ19jYXNlX3BlbmFsdHlcbiAgICAgICAgICBpblxuICAgICAgICAgIGlmICFxdWVyeV9pZHggPSAwXG4gICAgICAgICAgdGhlbiBmaXJzdF9jaGFyX211bHRpcGxpZXIgKiB3aXRoX3dyb25nX2Nhc2VfcGVuYWx0eVxuICAgICAgICAgIGVsc2Ugd2l0aF93cm9uZ19jYXNlX3BlbmFsdHlcbiAgICAgICAgaW5cbiAgICAgICAgaW5jciBxdWVyeV9pZHg7XG4gICAgICAgIHNjb3JlIDo9ICFzY29yZSArIHRoaXNfY2hhcl9zY29yZTtcbiAgICAgICAgcHJldl9jaGFyX2NsYXNzIDo9IGNoYXJfY2xhc3M7XG4gICAgICAgIHByZXZfY2hhcl9zY29yZSA6PSB0aGlzX2NoYXJfc2NvcmU7XG4gICAgICAgIGluX2dhcCA6PSBmYWxzZSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgdGhpc19jaGFyX3Njb3JlID1cbiAgICAgICAgICBpZiAhaW5fZ2FwIHRoZW4gLWNvbnRpbnVlX2dhcF9wZW5hbHR5IGVsc2UgLXN0YXJ0X2dhcF9wZW5hbHR5XG4gICAgICAgIGluXG4gICAgICAgIHNjb3JlIDo9ICFzY29yZSArIHRoaXNfY2hhcl9zY29yZTtcbiAgICAgICAgaW5fZ2FwIDo9IHRydWUpXG4gICAgZG9uZTtcbiAgICAhc2NvcmUpXG47O1xuXG5sZXQgc2NvcmUgcXVlcnkgfml0ZW0gPVxuICBtYXRjaCBTdHJpbmcuaXNfZW1wdHkgaXRlbSwgUXVlcnkuaXNfZW1wdHkgcXVlcnkgd2l0aFxuICB8IHRydWUsIF8gLT4gMFxuICB8IF8sIHRydWUgLT4gMVxuICB8IF8sIF8gLT5cbiAgICBsZXQgeyBRdWVyeS5xdWVyaWVzOyByYXc7IGNhc2Vfc2Vuc2l0aXZlIH0gPSBxdWVyeSBpblxuICAgIGxldCByYXdfc2NvcmUgPSByZWYgMCBpblxuICAgIGxldCBhbnlfbWlzbWF0Y2ggPSByZWYgZmFsc2UgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHF1ZXJpZXMgLSAxIGRvXG4gICAgICBsZXQgcXVlcnkgPSBxdWVyaWVzLihpKSBpblxuICAgICAgbGV0IHNjb3JlID0gc2NvcmVfc2luZ2xlX3F1ZXJ5IHF1ZXJ5IH5pdGVtIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgaWYgc2NvcmUgPSAwIHRoZW4gYW55X21pc21hdGNoIDo9IHRydWU7XG4gICAgICByYXdfc2NvcmUgOj0gIXJhd19zY29yZSArIHNjb3JlXG4gICAgZG9uZTtcbiAgICAobWF0Y2ggIXJhd19zY29yZSB3aXRoXG4gICAgIHwgMCAtPiAwXG4gICAgIHwgXyAtPlxuICAgICAgICgqIEFsbCBzdWJxdWVyaWVzIG11c3QgbWF0Y2ggc29tZSBwYXJ0IG9mIHRoZSBpdGVtLiAqKVxuICAgICAgIGlmICFhbnlfbWlzbWF0Y2hcbiAgICAgICB0aGVuIDBcbiAgICAgICBlbHNlIHNjb3JlX3VwcGVyX2JvdW5kIH5xdWVyeV9sZW5ndGg6KFN0cmluZy5sZW5ndGggcmF3KSAtICFyYXdfc2NvcmUpXG47O1xuXG5sZXQgc2NvcmVfb3B0IHF1ZXJ5IH5pdGVtID1cbiAgbWF0Y2ggc2NvcmUgcXVlcnkgfml0ZW0gd2l0aFxuICB8IDAgLT4gTm9uZVxuICB8IHggLT4gU29tZSB4XG47O1xuXG5tb2R1bGUgRm9yX3Rlc3RpbmcgPSBzdHJ1Y3RcbiAgbGV0IGZpbmRfc3RhcnRfZW5kX2luZGljZXMgfnF1ZXJ5IH5pdGVtICgpID1cbiAgICBsZXQgeyBTdGFydF9lbmRfaW5kaWNlcy5mb3VuZDsgc3RhcnRfaWR4OyBlbmRfaWR4IH0gPVxuICAgICAgZmluZF9zdGFydF9lbmRfaW5kaWNlcyB+cXVlcnkgfml0ZW0gKClcbiAgICBpblxuICAgIE9wdGlvbi5zb21lX2lmIGZvdW5kIChzdGFydF9pZHgsIGVuZF9pZHgpXG4gIDs7XG5lbmRcblxubGV0IHNlYXJjaCBxdWVyeSB+aXRlbXMgPVxuICBMaXN0LmZpbHRlcl9tYXAgaXRlbXMgfmY6KGZ1biBpdGVtIC0+XG4gICAgbWF0Y2ggc2NvcmUgcXVlcnkgfml0ZW0gd2l0aFxuICAgIHwgMCAtPiBOb25lXG4gICAgfCBzY29yZSAtPlxuICAgICAgKCogVGllIGJyZWFrIGJ5IHNob3J0ZXN0IHN0cmluZyBmaXJzdCwgdGhlbiBhbHBoYWJldGljYWwuICopXG4gICAgICBTb21lIChzY29yZSwgU3RyaW5nLmxlbmd0aCBpdGVtLCBpdGVtKSlcbiAgfD4gTGlzdC5zb3J0IH5jb21wYXJlOlslY29tcGFyZTogaW50ICogaW50ICogc3RyaW5nXVxuICB8PiBMaXN0Lm1hcCB+ZjpUdXBsZTMuZ2V0M1xuOztcblxubGV0IHNlYXJjaCcgcXVlcnkgfml0ZW1zID1cbiAgbGV0IGl0ZW1zX2J5X3Njb3JlID1cbiAgICBBcnJheS5maWx0ZXJfbWFwIGl0ZW1zIH5mOihmdW4gaXRlbSAtPlxuICAgICAgbWF0Y2ggc2NvcmUgcXVlcnkgfml0ZW0gd2l0aFxuICAgICAgfCAwIC0+IE5vbmVcbiAgICAgIHwgc2NvcmUgLT5cbiAgICAgICAgKCogVGllIGJyZWFrIGJ5IHNob3J0ZXN0IHN0cmluZyBmaXJzdCwgdGhlbiBhbHBoYWJldGljYWwuICopXG4gICAgICAgIFNvbWUgKHNjb3JlLCBTdHJpbmcubGVuZ3RoIGl0ZW0sIGl0ZW0pKVxuICBpblxuICBBcnJheS5zb3J0IGl0ZW1zX2J5X3Njb3JlIH5jb21wYXJlOlslY29tcGFyZTogaW50ICogaW50ICogc3RyaW5nXTtcbiAgQXJyYXkubWFwIGl0ZW1zX2J5X3Njb3JlIH5mOlR1cGxlMy5nZXQzXG47O1xuIl19
