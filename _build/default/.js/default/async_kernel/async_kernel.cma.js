// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Async_kernel__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Async_kernel = [0],
    Async_kernel$0 = [0, Async_kernel];
   runtime.caml_register_global(0, Async_kernel$0, "Async_kernel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_ns
//# unitInfo: Requires: Core__Time_ns, Core__Time_ns_alternate_sexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Time_ns$0 = "Async_kernel__Time_ns",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_ns$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/time_ns.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "time_ns.ml");
   var
    typerep_of_t = Core_Time_ns_alternate_sexp[1],
    typename_of_t = Core_Time_ns_alternate_sexp[2],
    quickcheck_generator = Core_Time_ns_alternate_sexp[3],
    quickcheck_observer = Core_Time_ns_alternate_sexp[4],
    quickcheck_shrinker = Core_Time_ns_alternate_sexp[5],
    gen_incl = Core_Time_ns_alternate_sexp[6],
    gen_uniform_incl = Core_Time_ns_alternate_sexp[7],
    is_earlier = Core_Time_ns_alternate_sexp[8],
    is_later = Core_Time_ns_alternate_sexp[9],
    of_date_ofday = Core_Time_ns_alternate_sexp[10],
    of_date_ofday_precise = Core_Time_ns_alternate_sexp[11],
    to_date_ofday = Core_Time_ns_alternate_sexp[12],
    to_date_ofday_precise = Core_Time_ns_alternate_sexp[13],
    to_date = Core_Time_ns_alternate_sexp[14],
    to_ofday = Core_Time_ns_alternate_sexp[15],
    reset_date_cache = Core_Time_ns_alternate_sexp[16],
    convert = Core_Time_ns_alternate_sexp[17],
    utc_offset = Core_Time_ns_alternate_sexp[18],
    to_filename_string = Core_Time_ns_alternate_sexp[19],
    of_filename_string = Core_Time_ns_alternate_sexp[20],
    to_string_abs = Core_Time_ns_alternate_sexp[21],
    to_string_abs_trimmed = Core_Time_ns_alternate_sexp[22],
    to_string_abs_parts = Core_Time_ns_alternate_sexp[23],
    to_string_trimmed = Core_Time_ns_alternate_sexp[24],
    to_sec_string = Core_Time_ns_alternate_sexp[25],
    to_sec_string_with_zone = Core_Time_ns_alternate_sexp[26],
    of_localized_string = Core_Time_ns_alternate_sexp[27],
    of_string_gen = Core_Time_ns_alternate_sexp[28],
    to_string_iso8601_basic = Core_Time_ns_alternate_sexp[29],
    occurrence = Core_Time_ns_alternate_sexp[30],
    of_string = Core_Time_ns_alternate_sexp[31],
    of_string_with_utc_offset = Core_Time_ns_alternate_sexp[32],
    to_string = Core_Time_ns_alternate_sexp[33],
    to_string_utc = Core_Time_ns_alternate_sexp[34],
    epoch = Core_Time_ns_alternate_sexp[35],
    min_value_representable = Core_Time_ns_alternate_sexp[36],
    max_value_representable = Core_Time_ns_alternate_sexp[37],
    min_value_for_1us_rounding = Core_Time_ns_alternate_sexp[38],
    max_value_for_1us_rounding = Core_Time_ns_alternate_sexp[39],
    min_value = Core_Time_ns_alternate_sexp[40],
    max_value = Core_Time_ns_alternate_sexp[41],
    now = Core_Time_ns_alternate_sexp[42],
    add = Core_Time_ns_alternate_sexp[43],
    add_saturating = Core_Time_ns_alternate_sexp[44],
    sub_saturating = Core_Time_ns_alternate_sexp[45],
    sub = Core_Time_ns_alternate_sexp[46],
    next = Core_Time_ns_alternate_sexp[47],
    prev = Core_Time_ns_alternate_sexp[48],
    diff = Core_Time_ns_alternate_sexp[49],
    abs_diff = Core_Time_ns_alternate_sexp[50],
    to_span_since_epoch = Core_Time_ns_alternate_sexp[51],
    of_span_since_epoch = Core_Time_ns_alternate_sexp[52],
    to_int63_ns_since_epoch = Core_Time_ns_alternate_sexp[53],
    of_int63_ns_since_epoch = Core_Time_ns_alternate_sexp[54],
    to_int_ns_since_epoch = Core_Time_ns_alternate_sexp[55],
    of_int_ns_since_epoch = Core_Time_ns_alternate_sexp[56],
    next_multiple = Core_Time_ns_alternate_sexp[57],
    prev_multiple = Core_Time_ns_alternate_sexp[58],
    round_up_to_us = Core_Time_ns_alternate_sexp[59],
    round_up_to_ms = Core_Time_ns_alternate_sexp[60],
    round_up_to_sec = Core_Time_ns_alternate_sexp[61],
    round_down_to_us = Core_Time_ns_alternate_sexp[62],
    round_down_to_ms = Core_Time_ns_alternate_sexp[63],
    round_down_to_sec = Core_Time_ns_alternate_sexp[64],
    random = Core_Time_ns_alternate_sexp[65],
    of_time = Core_Time_ns_alternate_sexp[66],
    to_time = Core_Time_ns_alternate_sexp[67],
    to_time_float_round_nearest = Core_Time_ns_alternate_sexp[68],
    to_time_float_round_nearest_mi = Core_Time_ns_alternate_sexp[69],
    of_time_float_round_nearest = Core_Time_ns_alternate_sexp[70],
    of_time_float_round_nearest_mi = Core_Time_ns_alternate_sexp[71],
    arg_type = Core_Time_ns_alternate_sexp[72],
    get_sexp_zone = Core_Time_ns_alternate_sexp[73],
    interruptible_pause = Core_Time_ns_alternate_sexp[74],
    of_date_ofday_zoned = Core_Time_ns_alternate_sexp[75],
    of_string_abs = Core_Time_ns_alternate_sexp[76],
    of_string_fix_proto = Core_Time_ns_alternate_sexp[77],
    pause = Core_Time_ns_alternate_sexp[78],
    pause_forever = Core_Time_ns_alternate_sexp[79],
    pp = Core_Time_ns_alternate_sexp[80],
    set_sexp_zone = Core_Time_ns_alternate_sexp[81],
    sexp_of_t_abs = Core_Time_ns_alternate_sexp[82],
    t_of_sexp_abs = Core_Time_ns_alternate_sexp[83],
    to_date_ofday_zoned = Core_Time_ns_alternate_sexp[84],
    to_ofday_zoned = Core_Time_ns_alternate_sexp[85],
    to_string_fix_proto = Core_Time_ns_alternate_sexp[86],
    bin_size_t = Core_Time_ns_alternate_sexp[87],
    bin_write_t = Core_Time_ns_alternate_sexp[88],
    bin_read_t = Core_Time_ns_alternate_sexp[89],
    bin_read_t$0 = Core_Time_ns_alternate_sexp[90],
    bin_shape_t = Core_Time_ns_alternate_sexp[91],
    bin_writer_t = Core_Time_ns_alternate_sexp[92],
    bin_reader_t = Core_Time_ns_alternate_sexp[93],
    bin_t = Core_Time_ns_alternate_sexp[94],
    hash_fold_t = Core_Time_ns_alternate_sexp[95],
    hash = Core_Time_ns_alternate_sexp[96],
    t_of_sexp = Core_Time_ns_alternate_sexp[97],
    sexp_of_t = Core_Time_ns_alternate_sexp[98],
    t_sexp_grammar = Core_Time_ns_alternate_sexp[99],
    symbol = Core_Time_ns_alternate_sexp[100],
    symbol$0 = Core_Time_ns_alternate_sexp[101],
    symbol$1 = Core_Time_ns_alternate_sexp[102],
    symbol$2 = Core_Time_ns_alternate_sexp[103],
    symbol$3 = Core_Time_ns_alternate_sexp[104],
    symbol$4 = Core_Time_ns_alternate_sexp[105],
    equal = Core_Time_ns_alternate_sexp[106],
    compare = Core_Time_ns_alternate_sexp[107],
    min = Core_Time_ns_alternate_sexp[108],
    max = Core_Time_ns_alternate_sexp[109],
    ascending = Core_Time_ns_alternate_sexp[110],
    descending = Core_Time_ns_alternate_sexp[111],
    between = Core_Time_ns_alternate_sexp[112],
    clamp_exn = Core_Time_ns_alternate_sexp[113],
    clamp = Core_Time_ns_alternate_sexp[114],
    comparator = Core_Time_ns_alternate_sexp[115],
    validate_lbound = Core_Time_ns_alternate_sexp[116],
    validate_ubound = Core_Time_ns_alternate_sexp[117],
    validate_bound = Core_Time_ns_alternate_sexp[118],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Time_ns = cst_Async_kernel_Time_ns$0;
   function after(t, span){
    var result = caml_call2(add, t, span);
    if
     (caml_call2(Core_Time_ns[1][18], span, Core_Time_ns[1][76])
      && caml_call2(symbol$3, result, t))
     return max_value_for_1us_rounding;
    return result;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_ns);
   var
    Async_kernel_Time_ns =
      [0,
       typerep_of_t,
       typename_of_t,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       round_up_to_us,
       round_up_to_ms,
       round_up_to_sec,
       round_down_to_us,
       round_down_to_ms,
       round_down_to_sec,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       arg_type,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       after];
   runtime.caml_register_global
    (13, Async_kernel_Time_ns, cst_Async_kernel_Time_ns$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Debug
//# unitInfo: Requires: Async_kernel__Time_ns, Async_kernel_config, Core, Core__Sexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Debug$0 = "Async_kernel__Debug",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Core_Sexp = global_data.Core__Sexp,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Async_kernel_config = global_data.Async_kernel_config,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Debug$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/debug.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "debug.ml");
   var
    include = Async_kernel_config[16],
    clock = include[1],
    fd = include[2],
    file_descr_watcher = include[3],
    finalizers = include[4],
    interruptor = include[5],
    monitor = include[6],
    monitor_send_exn = include[7],
    parallel = include[8],
    reader = include[9],
    scheduler = include[10],
    shutdown = include[11],
    thread_pool = include[12],
    thread_safe = include[13],
    writer = include[14],
    _a_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Debug = cst_Async_kernel_Debug$0;
   function log(arg2_003, arg3_004, sexp_of_a){
    var
     arg1_002 = caml_call1(Async_kernel_Time_ns[42], 0),
     arg0_001 = caml_call1(Async_kernel_config[35][1], 0),
     res0_005 = caml_call1(Core_Sexp[93], arg0_001),
     res1_006 = caml_call1(Async_kernel_Time_ns[98], arg1_002),
     res2_007 = caml_call1(Core[558], arg2_003),
     res3_008 = caml_call1(sexp_of_a, arg3_004),
     _b_ =
       caml_call2
        (Core_Sexp[84],
         0,
         [1, [0, res0_005, [0, res1_006, [0, res2_007, [0, res3_008, 0]]]]]);
    return caml_call2(Core[243], _a_, _b_);
   }
   function log_string(message){return log(message, 0, Core[620]);}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Debug);
   var
    Async_kernel_Debug =
      [0,
       clock,
       fd,
       file_descr_watcher,
       finalizers,
       interruptor,
       monitor,
       monitor_send_exn,
       parallel,
       reader,
       scheduler,
       shutdown,
       thread_pool,
       thread_safe,
       writer,
       log,
       log_string];
   runtime.caml_register_global
    (16, Async_kernel_Debug, cst_Async_kernel_Debug$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Import
//# unitInfo: Requires: Core, Core__Debug, Core__Int, Core__Sexp, Core__String, Core__Time_ns, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Import$0 = "Async_kernel__Import",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Sexp = global_data.Core__Sexp,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int,
    Core_String = global_data.Core__String,
    Core_Debug = global_data.Core__Debug,
    Core_Time_ns = global_data.Core__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Import$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "import.ml");
   var
    include = Core_Int[96],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    concat = Core_String[46],
    eprint = Core_Debug[1],
    eprint_s = Core_Debug[3],
    eprints = Core_Debug[2],
    _a_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Import = cst_Async_kernel_Import$0;
   function print_s(sexp){
    var _b_ = caml_call2(Core_Sexp[84], 0, sexp);
    return caml_call2(Core[258], _a_, _b_);
   }
   var sec = Core_Time_ns[1][82], Thread = [0], Unix = [0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Import);
   var
    Async_kernel_Import =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       concat,
       eprint,
       eprint_s,
       eprints,
       print_s,
       sec,
       Thread,
       Unix];
   runtime.caml_register_global
    (18, Async_kernel_Import, cst_Async_kernel_Import$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Priority
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Priority$0 = "Async_kernel__Priority",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, 0]],
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Priority$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/priority.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "priority.ml");
   var
    _a_ = [0, "Low"],
    _b_ = [0, "Normal"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Priority = cst_Async_kernel_Priority$0;
   function sexp_of_t(param){return param ? _a_ : _b_;}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Priority);
   var Async_kernel_Priority = [0, sexp_of_t, all, 0, 1];
   runtime.caml_register_global
    (14, Async_kernel_Priority, cst_Async_kernel_Priority$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Types
//# unitInfo: Requires: CamlinternalMod, Core__Unique_id, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Types$0 = "Async_kernel__Types",
    cst_async_kernel$0 = "async_kernel",
    cst_src_types_ml = "src/types.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    CamlinternalMod = global_data.CamlinternalMod,
    Core_Unique_id = global_data.Core__Unique_id;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Types$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_types_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "types.ml");
   var
    Cell =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 37, 2], [0, [0]]),
    Handler =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 42, 2], [0, [0]]),
    Ivar =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 51, 2], [0, [0, [0, [0]]]]),
    Deferred =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 56, 2], [0, [0]]),
    Execution_context =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 66, 2], [0, [0]]),
    Forwarding =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 74, 2], [0, [0]]),
    Monitor =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 88, 2], [0, [0]]),
    Tail =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 93, 2], [0, [0]]),
    Stream =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 102, 2], [0, [0]]);
   caml_call3(CamlinternalMod[2], [0, [0]], Cell, Cell);
   caml_call3(CamlinternalMod[2], [0, [0]], Handler, Handler);
   caml_call3(CamlinternalMod[2], [0, [0, [0, [0]]]], Ivar, Ivar);
   caml_call3(CamlinternalMod[2], [0, [0]], Deferred, Deferred);
   caml_call3
    (CamlinternalMod[2], [0, [0]], Execution_context, Execution_context);
   caml_call3(CamlinternalMod[2], [0, [0]], Forwarding, Forwarding);
   caml_call3(CamlinternalMod[2], [0, [0]], Monitor, Monitor);
   caml_call3(CamlinternalMod[2], [0, [0]], Tail, Tail);
   caml_call3(CamlinternalMod[2], [0, [0]], Stream, Stream);
   var
    _a_ = [0, [0, [0, [0]], [0, [0]]]],
    _b_ = [0, cst_src_types_ml, 155, 2],
    _c_ = [0, [0]],
    _d_ = [0, cst_src_types_ml, 160, 2],
    _e_ = [0, [0]],
    _f_ = [0, cst_src_types_ml, 166, 2],
    _g_ = [0, [0]],
    _h_ = [0, cst_src_types_ml, 171, 2],
    _i_ = [0, [0]],
    _j_ = [0, cst_src_types_ml, 176, 2],
    _k_ = [0, [0]],
    _l_ = [0, cst_src_types_ml, 189, 2],
    _m_ = [0, [0]],
    _n_ = [0, cst_src_types_ml, 199, 2],
    _o_ = [0, [0]],
    _p_ = [0, cst_src_types_ml, 233, 2],
    _q_ = [0, [0]],
    _r_ = [0, cst_src_types_ml, 238, 2],
    _s_ = [0, [0]],
    _t_ = [0, cst_src_types_ml, 256, 2],
    _u_ = [0, [0, [0, [0]]]],
    _v_ = [0, cst_src_types_ml, 270, 2],
    _w_ = [0, [0, [0, [0]], [0, [0]]]],
    _x_ = [0, [0]],
    _y_ = [0, [0]],
    _z_ = [0, [0]],
    _A_ = [0, [0]],
    _B_ = [0, [0]],
    _C_ = [0, [0]],
    _D_ = [0, [0]],
    _E_ = [0, [0]],
    _F_ = [0, [0]],
    _G_ = [0, [0, [0, [0]]]],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Types = cst_Async_kernel_Types$0;
   function to_repr(t){return t;}
   function of_repr(t){return t;}
   var
    Bvar = [0, of_repr, to_repr],
    Event = caml_call2(CamlinternalMod[1], _b_, _a_),
    External_job = caml_call2(CamlinternalMod[1], _d_, _c_),
    Job = caml_call2(CamlinternalMod[1], _f_, _e_),
    Job_or_event = caml_call2(CamlinternalMod[1], _h_, _g_),
    Job_pool = caml_call2(CamlinternalMod[1], _j_, _i_),
    Job_queue = caml_call2(CamlinternalMod[1], _l_, _k_),
    Jobs = caml_call2(CamlinternalMod[1], _n_, _m_),
    Scheduler = caml_call2(CamlinternalMod[1], _p_, _o_),
    Cycle_hook = caml_call2(CamlinternalMod[1], _r_, _q_),
    Time_source = caml_call2(CamlinternalMod[1], _t_, _s_),
    Very_low_priority_worker = caml_call2(CamlinternalMod[1], _v_, _u_),
    Cycle_hook_handle = caml_call1(Core_Unique_id[2], 0),
    Time_source_id = caml_call1(Core_Unique_id[2], 0);
   caml_call3(CamlinternalMod[2], _w_, Event, Event);
   caml_call3(CamlinternalMod[2], _x_, External_job, External_job);
   caml_call3(CamlinternalMod[2], _y_, Job, Job);
   caml_call3(CamlinternalMod[2], _z_, Job_or_event, Job_or_event);
   caml_call3(CamlinternalMod[2], _A_, Job_pool, Job_pool);
   caml_call3(CamlinternalMod[2], _B_, Job_queue, Job_queue);
   caml_call3(CamlinternalMod[2], _C_, Jobs, Jobs);
   caml_call3(CamlinternalMod[2], _D_, Scheduler, Scheduler);
   caml_call3(CamlinternalMod[2], _E_, Cycle_hook, Cycle_hook);
   caml_call3(CamlinternalMod[2], _F_, Time_source, Time_source);
   caml_call3
    (CamlinternalMod[2],
     _G_,
     Very_low_priority_worker,
     Very_low_priority_worker);
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Types);
   var
    Async_kernel_Types =
      [0,
       Cell,
       Handler,
       Ivar,
       Deferred,
       Execution_context,
       Forwarding,
       Monitor,
       Tail,
       Stream,
       Bvar,
       Event,
       External_job,
       Job,
       Job_or_event,
       Job_pool,
       Job_queue,
       Jobs,
       Scheduler,
       Cycle_hook,
       Cycle_hook_handle,
       Time_source_id,
       Time_source,
       Very_low_priority_worker];
   runtime.caml_register_global
    (73, Async_kernel_Types, cst_Async_kernel_Types$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monitor0
//# unitInfo: Requires: Async_kernel__Debug, Core, Core__Bag, Core__Info, Core__List, Core__Sexp, Core__Source_code_position, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexp_hidden_in_test
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Monitor0$0 = "Async_kernel__Monitor0",
    cst_async_kernel$0 = "async_kernel",
    cst_id$1 = "id";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Sexp_hidden_in_test = global_data.Sexp_hidden_in_test,
    Core_Info = global_data.Core__Info,
    Core_Bag = global_data.Core__Bag,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_Sexp = global_data.Core__Sexp,
    Core_List = global_data.Core__List,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monitor0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/monitor0.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "monitor0.ml");
   var
    debug = Async_kernel_Debug[6],
    cst_id$0 = cst_id$1,
    cst_created_monitor = "created monitor",
    cst_forwarding = "forwarding",
    cst_has_seen_error = "has_seen_error",
    cst_tails_for_all_errors = "tails_for_all_errors",
    cst_handlers_for_all_errors = "handlers_for_all_errors",
    cst_next_error = "next_error",
    cst_id = cst_id$1,
    cst_here = "here",
    cst_name = "name",
    _q_ = [0, "main"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Monitor0 = cst_Async_kernel_Monitor0$0;
   function forwarding(r){return r[8];}
   function set_forwarding(r, v){r[8] = v; return 0;}
   function has_seen_error(r){return r[7];}
   function set_has_seen_error(r, v){r[7] = v; return 0;}
   function tails_for_all_errors(r){return r[6];}
   function set_tails_for_all_errors(r, v){r[6] = v; return 0;}
   function handlers_for_all_errors(r){return r[5];}
   function set_handlers_for_all_errors(r, v){r[5] = v; return 0;}
   function next_error(r){return r[4];}
   function set_next_error(r, v){r[4] = v; return 0;}
   function id(r){return r[3];}
   function here(r){return r[2];}
   function name(r){return r[1];}
   function _a_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
   }
   var
    _b_ = [0, set_forwarding],
    forwarding$0 =
      [0, function(param){return 0;}, cst_forwarding, _b_, forwarding, _a_];
   function _c_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _d_ = [0, set_has_seen_error],
    has_seen_error$0 =
      [0,
       function(param){return 0;},
       cst_has_seen_error,
       _d_,
       has_seen_error,
       _c_];
   function _e_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
   }
   var
    _f_ = [0, set_tails_for_all_errors],
    tails_for_all_errors$0 =
      [0,
       function(param){return 0;},
       cst_tails_for_all_errors,
       _f_,
       tails_for_all_errors,
       _e_];
   function _g_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
   }
   var
    _h_ = [0, set_handlers_for_all_errors],
    handlers_for_all_errors$0 =
      [0,
       function(param){return 0;},
       cst_handlers_for_all_errors,
       _h_,
       handlers_for_all_errors,
       _g_];
   function _i_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
   }
   var
    _j_ = [0, set_next_error],
    next_error$0 =
      [0, function(param){return 0;}, cst_next_error, _j_, next_error, _i_];
   function _k_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8]];
   }
   var _l_ = 0, id$0 = [0, function(param){return 0;}, cst_id, _l_, id, _k_];
   function _m_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _n_ = 0,
    here$0 = [0, function(param){return 0;}, cst_here, _n_, here, _m_];
   function _o_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _p_ = 0,
    name$0 = [0, function(param){return 0;}, cst_name, _p_, name, _o_];
   function iter
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    caml_call1(name_fun, name$0);
    caml_call1(here_fun, here$0);
    caml_call1(id_fun, id$0);
    caml_call1(next_error_fun, next_error$0);
    caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0);
    caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0);
    caml_call1(has_seen_error_fun, has_seen_error$0);
    return caml_call1(forwarding_fun, forwarding$0);
   }
   var
    Fields =
      [0,
       forwarding$0,
       has_seen_error$0,
       tails_for_all_errors$0,
       handlers_for_all_errors$0,
       next_error$0,
       id$0,
       here$0,
       name$0,
       iter];
   function description(t){
    var match = t[2];
    if(! match) return caml_call1(Core_Info[9], t[1]);
    var
     here = match[1],
     _u_ = [0, caml_call1(Core_Source_code_position[1], here), 0];
    return [1, [0, caml_call1(Core_Info[9], t[1]), _u_]];
   }
   function descriptions(t$1){
    var t = t$1, ac = 0;
    for(;;){
     var ac$0 = [0, description(t), ac], match = t[8];
     if(typeof match === "number") return caml_call1(Core_List[59], ac$0);
     var t$0 = match[1], t = t$0, ac = ac$0;
    }
   }
   function sexp_of_t(t){
    var x_001 = descriptions(t);
    return caml_call2(Core[472], Core_Sexp[93], x_001);
   }
   var r = [0, 0];
   function next_id(param){r[1]++; return r[1];}
   function create_with_parent(here, info, name, parent){
    var id = next_id(0);
    if(info){
     var i = info[1];
     if(name)
      var s = name[1], _r_ = caml_call2(Core_Info[22], i, s);
     else
      var _r_ = i;
     var name$0 = _r_;
    }
    else if(name)
     var s$0 = name[1], name$0 = caml_call1(Core_Info[14], s$0);
    else
     var
      _t_ =
        function(x_002){
         return caml_call2(Sexp_hidden_in_test[11], Core[389], x_002);
        },
      name$0 = caml_call5(Core_Info[19], 0, 0, cst_id$0, id, _t_);
    if(parent)
     var parent$0 = parent[1], _s_ = [0, parent$0];
    else
     var _s_ = 1;
    var
     t = [0, name$0, here, id, [0, 0], caml_call1(Core_Bag[22], 0), 0, 0, _s_];
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_created_monitor, t, sexp_of_t);
    return t;
   }
   var main = create_with_parent(0, 0, _q_, 0);
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monitor0);
   var
    Async_kernel_Monitor0 =
      [0,
       debug,
       forwarding,
       set_forwarding,
       has_seen_error,
       set_has_seen_error,
       tails_for_all_errors,
       set_tails_for_all_errors,
       handlers_for_all_errors,
       set_handlers_for_all_errors,
       next_error,
       set_next_error,
       id,
       here,
       name,
       Fields,
       description,
       descriptions,
       sexp_of_t,
       next_id,
       create_with_parent,
       main];
   runtime.caml_register_global
    (30, Async_kernel_Monitor0, cst_Async_kernel_Monitor0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Execution_context
//# unitInfo: Requires: Async_kernel__Monitor0, Async_kernel__Priority, Base__Backtrace, Core, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Univ_map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Execution_con$0 = "Async_kernel__Execution_context",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Backtrace = global_data.Base__Backtrace,
    Univ_map = global_data.Univ_map,
    Core_Option = global_data.Core__Option,
    Core = global_data.Core,
    Async_kernel_Priority = global_data.Async_kernel__Priority,
    Async_kernel_Monitor0 = global_data.Async_kernel__Monitor0,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Execution_con$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/execution_context.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "execution_context.ml");
   var
    _a_ = [0, "backtrace_history"],
    _b_ = [0, "local_storage"],
    _c_ = [0, "priority"],
    _d_ = [0, "monitor"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Execution_con = cst_Async_kernel_Execution_con$0;
   function backtrace_history(r){return r[4];}
   function local_storage(r){return r[3];}
   function priority(r){return r[2];}
   function monitor(r){return r[1];}
   function sexp_of_t(param){
    var
     backtrace_history_008 = param[4],
     local_storage_006 = param[3],
     priority_004 = param[2],
     monitor_002 = param[1],
     arg_009 = caml_call2(Core[472], Base_Backtrace[1], backtrace_history_008),
     bnds_001 = [0, [1, [0, _a_, [0, arg_009, 0]]], 0],
     arg_007 = caml_call1(Univ_map[2], local_storage_006),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_001],
     arg_005 = caml_call1(Async_kernel_Priority[1], priority_004),
     bnds_001$1 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_001$0],
     arg_003 = caml_call1(Async_kernel_Monitor0[18], monitor_002),
     bnds_001$2 = [0, [1, [0, _d_, [0, arg_003, 0]]], bnds_001$1];
    return [1, bnds_001$2];
   }
   function invariant(param){return 0;}
   var
    main =
      [0, Async_kernel_Monitor0[21], Async_kernel_Priority[3], Univ_map[4], 0];
   function create_like(monitor, priority, local_storage, t){
    if(! monitor && ! priority && ! local_storage) return t;
    var
     monitor$0 = caml_call2(Core_Option[39], monitor, t[1]),
     _k_ = t[4],
     _l_ = caml_call2(Core_Option[39], local_storage, t[3]);
    return [0,
            monitor$0,
            caml_call2(Core_Option[39], priority, t[2]),
            _l_,
            _k_];
   }
   function find_local(t, key){return caml_call2(Univ_map[10], t[3], key);}
   function with_local(t, key, data){
    if(data){
     var
      data$0 = data[1],
      _g_ = t[4],
      _h_ = caml_call3(Univ_map[7], t[3], key, data$0);
     return [0, t[1], t[2], _h_, _g_];
    }
    var _i_ = t[4], _j_ = caml_call2(Univ_map[17], t[3], key);
    return [0, t[1], t[2], _j_, _i_];
   }
   function record_backtrace(t){
    var _e_ = t[4], _f_ = [0, caml_call2(Base_Backtrace[2], 0, 0), _e_];
    return [0, t[1], t[2], t[3], _f_];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Execution_con);
   var
    Async_kernel_Execution_context =
      [0,
       backtrace_history,
       local_storage,
       priority,
       monitor,
       sexp_of_t,
       invariant,
       main,
       create_like,
       find_local,
       with_local,
       record_backtrace];
   runtime.caml_register_global
    (21, Async_kernel_Execution_context, cst_Async_kernel_Execution_con$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__External_job
//# unitInfo: Requires: Async_kernel__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_External_job$0 = "Async_kernel__External_job",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_External_job$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/external_job.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "external_job.ml");
   var
    _a_ = [0, "<job>"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_External_job = cst_Async_kernel_External_job$0;
   function sexp_of_t(param){return _a_;}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_External_job);
   var Async_kernel_External_job = [0, sexp_of_t];
   runtime.caml_register_global
    (12, Async_kernel_External_job, cst_Async_kernel_External_job$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_pool
//# unitInfo: Requires: Async_kernel__Execution_context, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_pool$0 = "Async_kernel__Job_pool",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_pool$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/job_pool.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "job_pool.ml");
   var
    dummy_e = Async_kernel_Execution_context[7],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job_pool = cst_Async_kernel_Job_pool$0;
   function dummy_f(_g_){return 0;}
   var dummy_a = 0;
   function sexp_of_slots(x_001){
    var _c_ = Sexplib0_Sexp_conv[23];
    function _d_(param){
     function _e_(_f_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _e_);
    }
    return caml_call4
            (Tuple_pool[1][5],
             Async_kernel_Execution_context[5],
             _d_,
             _c_,
             x_001);
   }
   function sexp_of_t(x_002){
    return caml_call2(Tuple_pool[4], sexp_of_slots, x_002);
   }
   function invariant(t){
    function _a_(_b_){return 0;}
    return caml_call2(Tuple_pool[5], _a_, t);
   }
   function create(param){
    return caml_call3
            (Tuple_pool[9],
             Tuple_pool[1][19],
             1,
             [0, dummy_e, dummy_f, dummy_a]);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_pool);
   var
    Async_kernel_Job_pool = [0, sexp_of_slots, sexp_of_t, invariant, create];
   runtime.caml_register_global
    (14, Async_kernel_Job_pool, cst_Async_kernel_Job_pool$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job
//# unitInfo: Requires: Async_kernel__Job_pool, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job$0 = "Async_kernel__Job",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Job_pool = global_data.Async_kernel__Job_pool,
    Tuple_pool = global_data.Tuple_pool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/job.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "job.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job = cst_Async_kernel_Job$0;
   function sexp_of_t(x_001){
    return caml_call2(Tuple_pool[3][1], Async_kernel_Job_pool[1], x_001);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job);
   var Async_kernel_Job = [0, sexp_of_t];
   runtime.caml_register_global(13, Async_kernel_Job, cst_Async_kernel_Job$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_or_event
//# unitInfo: Requires: Async_kernel__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_or_event$0 = "Async_kernel__Job_or_event",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_or_event$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/job_or_event.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "job_or_event.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job_or_event = cst_Async_kernel_Job_or_event$0;
   function of_event(event){return event;}
   function of_job(job){return job;}
   function is_event(t){return caml_call1(Stdlib_Obj[1], t);}
   function is_job(t){return typeof t === "number" ? 1 : 0;}
   function kind(t){return is_event(t) ? 0 : 1;}
   function project(param, job_or_event){return job_or_event;}
   var Match = [0, kind, project];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_or_event);
   var
    Async_kernel_Job_or_event = [0, of_event, of_job, is_event, is_job, Match];
   runtime.caml_register_global
    (13, Async_kernel_Job_or_event, cst_Async_kernel_Job_or_event$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_or_event_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_or_event_ = "Async_kernel__Job_or_event_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_or_event_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/job_or_event_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel, "job_or_event_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_or_event_);
   var Async_kernel_Job_or_event_intf = [0];
   runtime.caml_register_global
    (11, Async_kernel_Job_or_event_intf, cst_Async_kernel_Job_or_event_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler0
//# unitInfo: Requires: Async_kernel__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler0$0 = "Async_kernel__Scheduler0",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/scheduler0.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "scheduler0.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler0 = cst_Async_kernel_Scheduler0$0;
   function events(t){return t[19][4];}
   function set_execution_context(t, execution_context){
    var
     _a_ = 1 - (t[7] === execution_context ? 1 : 0),
     _b_ = _a_ ? (t[7] = execution_context, 0) : _a_;
    return _b_;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler0);
   var Async_kernel_Scheduler0 = [0, events, set_execution_context];
   runtime.caml_register_global
    (11, Async_kernel_Scheduler0, cst_Async_kernel_Scheduler0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_queue
//# unitInfo: Requires: Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Scheduler0, Base__Backtrace, Base__Invariant, Core, Core__Int, Core__Uniform_array, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_queue$0 = "Async_kernel__Job_queue",
    cst_async_kernel$0 = "async_kernel",
    cst_front$0 = "front",
    cst_jobs$0 = "jobs",
    cst_jobs_left_this_cycle$0 = "jobs_left_this_cycle",
    cst_length$0 = "length",
    cst_mask$0 = "mask",
    cst_num_jobs_run$0 = "num_jobs_run",
    cst_src_job_queue_ml = "src/job_queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Core_Uniform_array = global_data.Core__Uniform_array,
    Base_Backtrace = global_data.Base__Backtrace,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Assert_failure = global_data.Assert_failure,
    Core_Int = global_data.Core__Int,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_queue$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_job_queue_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "job_queue.ml");
   var
    dummy_e = Async_kernel_Execution_context[7],
    _F_ = [0, 0],
    _D_ = [0, "t"],
    _E_ = [0, "n"],
    cst_Jobs_set_jobs_left_this_cy =
      "Jobs.set_jobs_left_this_cycle got negative number",
    _C_ = [0, cst_src_job_queue_ml, 94, 15],
    _A_ = [0, cst_src_job_queue_ml, 43, 48],
    _z_ = [0, cst_src_job_queue_ml, 45, 44],
    _y_ = [0, cst_src_job_queue_ml, 55, 11],
    _x_ = [0, cst_src_job_queue_ml, 56, 11],
    _w_ = [0, cst_src_job_queue_ml, 60, 11],
    _v_ = [0, cst_src_job_queue_ml, 61, 11],
    _u_ = [0, cst_src_job_queue_ml, 64, 11],
    _t_ = [0, cst_src_job_queue_ml, 65, 11],
    _B_ = [0, cst_src_job_queue_ml, 40, 1651, 1673],
    _m_ = [0, "backtrace_of_first_enqueue"],
    _n_ = [0, cst_length$0],
    _o_ = [0, cst_front$0],
    _p_ = [0, cst_mask$0],
    _q_ = [0, cst_jobs$0],
    _r_ = [0, cst_jobs_left_this_cycle$0],
    _s_ = [0, cst_num_jobs_run$0],
    cst_length = cst_length$0,
    cst_front = cst_front$0,
    cst_mask = cst_mask$0,
    cst_jobs = cst_jobs$0,
    cst_jobs_left_this_cycle = cst_jobs_left_this_cycle$0,
    cst_num_jobs_run = cst_num_jobs_run$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job_queue = cst_Async_kernel_Job_queue$0;
   function dummy_f(_X_){return 0;}
   var dummy_a = 0;
   function length(r){return r[6];}
   function set_length(r, v){r[6] = v; return 0;}
   function front(r){return r[5];}
   function set_front(r, v){r[5] = v; return 0;}
   function mask(r){return r[4];}
   function set_mask(r, v){r[4] = v; return 0;}
   function jobs(r){return r[3];}
   function set_jobs(r, v){r[3] = v; return 0;}
   function jobs_left_this_cycle(r){return r[2];}
   function set_jobs_left_this_cycle(r, v){r[2] = v; return 0;}
   function num_jobs_run(r){return r[1];}
   function set_num_jobs_run(r, v){r[1] = v; return 0;}
   function _a_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}
   var
    _b_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _b_, length, _a_];
   function _c_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6], r[7]];}
   var
    _d_ = [0, set_front],
    front$0 = [0, function(param){return 0;}, cst_front, _d_, front, _c_];
   function _e_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}
   var
    _f_ = [0, set_mask],
    mask$0 = [0, function(param){return 0;}, cst_mask, _f_, mask, _e_];
   function _g_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6], r[7]];}
   var
    _h_ = [0, set_jobs],
    jobs$0 = [0, function(param){return 0;}, cst_jobs, _h_, jobs, _g_];
   function _i_(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}
   var
    _j_ = [0, set_jobs_left_this_cycle],
    jobs_left_this_cycle$0 =
      [0,
       function(param){return 0;},
       cst_jobs_left_this_cycle,
       _j_,
       jobs_left_this_cycle,
       _i_];
   function _k_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6], r[7]];}
   var
    _l_ = [0, set_num_jobs_run],
    num_jobs_run$0 =
      [0,
       function(param){return 0;},
       cst_num_jobs_run,
       _l_,
       num_jobs_run,
       _k_];
   function sexp_of_t(param){
    var
     num_jobs_run_002 = param[1],
     jobs_left_this_cycle_004 = param[2],
     jobs_006 = param[3],
     mask_008 = param[4],
     front_010 = param[5],
     length_012 = param[6],
     backtrace_of_first_enqueue_014 = param[7],
     arg_015 =
       caml_call2
        (Core[515], Base_Backtrace[1], backtrace_of_first_enqueue_014),
     bnds_001 = [0, [1, [0, _m_, [0, arg_015, 0]]], 0],
     arg_013 = caml_call1(Core[389], length_012),
     bnds_001$0 = [0, [1, [0, _n_, [0, arg_013, 0]]], bnds_001],
     arg_011 = caml_call1(Core[389], front_010),
     bnds_001$1 = [0, [1, [0, _o_, [0, arg_011, 0]]], bnds_001$0],
     arg_009 = caml_call1(Core[389], mask_008),
     bnds_001$2 = [0, [1, [0, _p_, [0, arg_009, 0]]], bnds_001$1],
     arg_007 = caml_call1(Sexplib0_Sexp_conv[23], jobs_006),
     bnds_001$3 = [0, [1, [0, _q_, [0, arg_007, 0]]], bnds_001$2],
     arg_005 = caml_call1(Core[389], jobs_left_this_cycle_004),
     bnds_001$4 = [0, [1, [0, _r_, [0, arg_005, 0]]], bnds_001$3],
     arg_003 = caml_call1(Core[389], num_jobs_run_002),
     bnds_001$5 = [0, [1, [0, _s_, [0, arg_003, 0]]], bnds_001$4];
    return [1, bnds_001$5];
   }
   function offset(t, i){return ((t[5] + i | 0) & t[4]) * 3 | 0;}
   function capacity(t){return t[4] + 1 | 0;}
   function invariant(t){
    function _N_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      length_fun =
        check
         (function(length){
           if(! caml_call2(Async_kernel_Import[1], length, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
           var _W_ = capacity(t);
           if(caml_call2(Async_kernel_Import[2], length, _W_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
          }),
      front_fun =
        check
         (function(front){
           if(! caml_call2(Async_kernel_Import[1], front, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
           var
            _U_ = capacity(t),
            _V_ = caml_call2(Async_kernel_Import[10], 1, _U_);
           if(caml_call2(Async_kernel_Import[5], front, _V_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
          }),
      mask_fun =
        check
         (function(mask){
           var capacity = mask + 1 | 0;
           if
            (!
             caml_call2(Async_kernel_Import[3], capacity, 0)
             && ! caml_call1(Core_Int[52], capacity))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
           var _T_ = caml_call1(Core_Uniform_array[19], t[3]);
           if(caml_call2(Async_kernel_Import[3], capacity * 3 | 0, _T_))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
          }),
      jobs_fun =
        check
         (function(jobs){
           var _P_ = t[6] - 1 | 0, _O_ = 0;
           if(_P_ >= 0){
            var i = _O_;
            for(;;){
             var
              _Q_ = offset(t, i),
              _R_ = caml_call2(Core_Uniform_array[20], jobs, _Q_);
             caml_call1(Async_kernel_Execution_context[6], _R_);
             var _S_ = i + 1 | 0;
             if(_P_ === i) break;
             var i = _S_;
            }
           }
           return 0;
          }),
      jobs_left_this_cycle_fun =
        check
         (function(jobs_left_this_cycle){
           if(caml_call2(Async_kernel_Import[1], jobs_left_this_cycle, 0))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
          }),
      num_jobs_run_fun =
        check
         (function(num_jobs_run){
           if(caml_call2(Async_kernel_Import[1], num_jobs_run, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
          });
     caml_call1(num_jobs_run_fun, num_jobs_run$0);
     caml_call1(jobs_left_this_cycle_fun, jobs_left_this_cycle$0);
     caml_call1(jobs_fun, jobs$0);
     caml_call1(mask_fun, mask$0);
     caml_call1(front_fun, front$0);
     caml_call1(length_fun, length$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _B_, t, sexp_of_t, _N_);
   }
   function create_array(capacity){
    return caml_call1(Core_Uniform_array[71], capacity * 3 | 0);
   }
   function create(param){return [0, 0, 0, create_array(0), -1, 0, 0, 0];}
   function backtrace_of_first_enqueue(t){return t[7];}
   function clear(t){t[5] = 0; t[6] = 0; t[2] = 0; return 0;}
   function set(t, i, execution_context, f, a){
    var offset$0 = offset(t, i);
    caml_call3(Core_Uniform_array[24], t[3], offset$0, execution_context);
    caml_call3(Core_Uniform_array[24], t[3], offset$0 + 1 | 0, f);
    return caml_call3(Core_Uniform_array[24], t[3], offset$0 + 2 | 0, a);
   }
   function enqueue(t, execution_context, f, a){
    var _M_ = capacity(t);
    if(caml_call2(Async_kernel_Import[3], t[6], _M_)){
     if(t[7]){
      var _L_ = capacity(t);
      if(! caml_call2(Async_kernel_Import[4], _L_, 0))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
     }
     else
      t[7] = [0, caml_call2(Base_Backtrace[2], 0, 0)];
     var
      old_capacity = capacity(t),
      new_capacity =
        caml_call2(Async_kernel_Import[10], 1, old_capacity * 2 | 0),
      old_jobs = t[3],
      old_front = t[5],
      len1 =
        caml_call2(Core_Int[89], t[6], old_capacity - old_front | 0) * 3 | 0,
      len2 = (t[6] * 3 | 0) - len1 | 0,
      new_jobs = create_array(new_capacity);
     caml_call5
      (Core_Uniform_array[41], old_jobs, old_front * 3 | 0, new_jobs, 0, len1);
     caml_call5(Core_Uniform_array[41], old_jobs, 0, new_jobs, len1, len2);
     t[4] = new_capacity - 1 | 0;
     t[3] = new_jobs;
     t[5] = 0;
    }
    set(t, t[6], execution_context, f, a);
    t[6] = t[6] + 1 | 0;
    return 0;
   }
   function set_jobs_left_this_cycle$0(t, n){
    if(caml_call2(Async_kernel_Import[5], n, 0)){
     var
      _I_ = [0, [1, [0, _D_, [0, sexp_of_t(t), 0]]], 0],
      _J_ = [0, [1, [0, _E_, [0, caml_call1(Core[389], n), 0]]], _I_],
      _K_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Jobs_set_jobs_left_this_cy),
          _J_]];
     caml_call1(Core[261], _K_);
    }
    t[2] = n;
    return 0;
   }
   function can_run_a_job(t){
    var _H_ = caml_call2(Async_kernel_Import[4], t[6], 0);
    return _H_ ? caml_call2(Async_kernel_Import[4], t[2], 0) : _H_;
   }
   function run_job(t, scheduler, execution_context, f, a){
    t[1] = t[1] + 1 | 0;
    caml_call2(Async_kernel_Scheduler0[2], scheduler, execution_context);
    return caml_call1(f, a);
   }
   function run_external_jobs(t, scheduler){
    var external_jobs = scheduler[20];
    for(;;){
     var _G_ = caml_call1(Thread_safe_queue[4], external_jobs);
     if(! caml_call2(Async_kernel_Import[4], _G_, 0)) return;
     var
      match = caml_call1(Thread_safe_queue[6], external_jobs),
      a = match[3],
      f = match[2],
      execution_context = match[1];
     run_job(t, scheduler, execution_context, f, a);
    }
   }
   function run_jobs(t, scheduler){
    try{
     run_external_jobs(t, scheduler);
     for(;;){
      if(! can_run_a_job(t)) return _F_;
      var
       this_job = offset(t, 0),
       execution_context = caml_call2(Core_Uniform_array[21], t[3], this_job),
       f = caml_call2(Core_Uniform_array[21], t[3], this_job + 1 | 0),
       a = caml_call2(Core_Uniform_array[21], t[3], this_job + 2 | 0);
      set(t, 0, dummy_e, dummy_f, dummy_a);
      t[5] = (t[5] + 1 | 0) & t[4];
      t[6] = t[6] - 1 | 0;
      t[2] = t[2] - 1 | 0;
      run_job(t, scheduler, execution_context, f, a);
      run_external_jobs(t, scheduler);
     }
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      backtrace = caml_call1(Base_Backtrace[6][4], 0);
     return [1, [0, exn, backtrace]];
    }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_queue);
   var
    Async_kernel_Job_queue =
      [0,
       sexp_of_t,
       invariant,
       create,
       enqueue,
       clear,
       set_jobs_left_this_cycle$0,
       can_run_a_job,
       length,
       run_jobs,
       num_jobs_run,
       backtrace_of_first_enqueue];
   runtime.caml_register_global
    (50, Async_kernel_Job_queue, cst_Async_kernel_Job_queue$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Synchronous_time_source0
//# unitInfo: Requires: Async_kernel__Job_or_event, Async_kernel__Scheduler0, Async_kernel__Time_ns, Base__Backtrace, Base__Invariant, Core, Core__Bool, Core__Error, Core__List, Core__Option, Core__Or_error, Core__Time_ns, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Synchronous_t$0 =
      "Async_kernel__Synchronous_time_source0",
    cst_async_kernel$0 = "async_kernel",
    cst_at$0 = "at",
    cst_events$0 = "events",
    cst_interval$0 = "interval",
    cst_now = "now",
    cst_src_synchronous_time_sourc$0 = "src/synchronous_time_source0.ml",
    cst_status$0 = "status",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos$3 = "src/synchronous_time_source0.ml:347:32",
    pos$2 = "src/synchronous_time_source0.ml:346:32",
    pos$1 = "src/synchronous_time_source0.ml:189:30",
    pos$0 = "src/synchronous_time_source0.ml:207:32",
    pos = "src/synchronous_time_source0.ml:217:32",
    Timing_wheel = global_data.Timing_wheel,
    Core_Error = global_data.Core__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Or_error = global_data.Core__Or_error,
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_List = global_data.Core__List,
    Async_kernel_Job_or_event = global_data.Async_kernel__Job_or_event,
    Core_Option = global_data.Core__Option,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Synchronous_t$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_synchronous_time_sourc$0);
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_async_kernel$0,
     "synchronous_time_source0.ml");
   var
    typerep_of_t = Async_kernel_Time_ns[1],
    typename_of_t = Async_kernel_Time_ns[2],
    quickcheck_generator = Async_kernel_Time_ns[3],
    quickcheck_observer = Async_kernel_Time_ns[4],
    quickcheck_shrinker = Async_kernel_Time_ns[5],
    gen_incl = Async_kernel_Time_ns[6],
    gen_uniform_incl = Async_kernel_Time_ns[7],
    is_earlier = Async_kernel_Time_ns[8],
    is_later = Async_kernel_Time_ns[9],
    of_date_ofday = Async_kernel_Time_ns[10],
    of_date_ofday_precise = Async_kernel_Time_ns[11],
    to_date_ofday = Async_kernel_Time_ns[12],
    to_date_ofday_precise = Async_kernel_Time_ns[13],
    to_date = Async_kernel_Time_ns[14],
    to_ofday = Async_kernel_Time_ns[15],
    reset_date_cache = Async_kernel_Time_ns[16],
    convert = Async_kernel_Time_ns[17],
    utc_offset = Async_kernel_Time_ns[18],
    to_filename_string = Async_kernel_Time_ns[19],
    of_filename_string = Async_kernel_Time_ns[20],
    to_string_abs = Async_kernel_Time_ns[21],
    to_string_abs_trimmed = Async_kernel_Time_ns[22],
    to_string_abs_parts = Async_kernel_Time_ns[23],
    to_string_trimmed = Async_kernel_Time_ns[24],
    to_sec_string = Async_kernel_Time_ns[25],
    to_sec_string_with_zone = Async_kernel_Time_ns[26],
    of_localized_string = Async_kernel_Time_ns[27],
    of_string_gen = Async_kernel_Time_ns[28],
    to_string_iso8601_basic = Async_kernel_Time_ns[29],
    occurrence = Async_kernel_Time_ns[30],
    of_string = Async_kernel_Time_ns[31],
    of_string_with_utc_offset = Async_kernel_Time_ns[32],
    to_string = Async_kernel_Time_ns[33],
    to_string_utc = Async_kernel_Time_ns[34],
    epoch = Async_kernel_Time_ns[35],
    min_value_representable = Async_kernel_Time_ns[36],
    max_value_representable = Async_kernel_Time_ns[37],
    min_value_for_1us_rounding = Async_kernel_Time_ns[38],
    max_value_for_1us_rounding = Async_kernel_Time_ns[39],
    min_value = Async_kernel_Time_ns[40],
    max_value = Async_kernel_Time_ns[41],
    now = Async_kernel_Time_ns[42],
    add = Async_kernel_Time_ns[43],
    add_saturating = Async_kernel_Time_ns[44],
    sub_saturating = Async_kernel_Time_ns[45],
    sub = Async_kernel_Time_ns[46],
    next = Async_kernel_Time_ns[47],
    prev = Async_kernel_Time_ns[48],
    diff = Async_kernel_Time_ns[49],
    abs_diff = Async_kernel_Time_ns[50],
    to_span_since_epoch = Async_kernel_Time_ns[51],
    of_span_since_epoch = Async_kernel_Time_ns[52],
    to_int63_ns_since_epoch = Async_kernel_Time_ns[53],
    of_int63_ns_since_epoch = Async_kernel_Time_ns[54],
    to_int_ns_since_epoch = Async_kernel_Time_ns[55],
    of_int_ns_since_epoch = Async_kernel_Time_ns[56],
    next_multiple = Async_kernel_Time_ns[57],
    prev_multiple = Async_kernel_Time_ns[58],
    round_up_to_us = Async_kernel_Time_ns[59],
    round_up_to_ms = Async_kernel_Time_ns[60],
    round_up_to_sec = Async_kernel_Time_ns[61],
    round_down_to_us = Async_kernel_Time_ns[62],
    round_down_to_ms = Async_kernel_Time_ns[63],
    round_down_to_sec = Async_kernel_Time_ns[64],
    random = Async_kernel_Time_ns[65],
    of_time = Async_kernel_Time_ns[66],
    to_time = Async_kernel_Time_ns[67],
    to_time_float_round_nearest = Async_kernel_Time_ns[68],
    to_time_float_round_nearest_mi = Async_kernel_Time_ns[69],
    of_time_float_round_nearest = Async_kernel_Time_ns[70],
    of_time_float_round_nearest_mi = Async_kernel_Time_ns[71],
    arg_type = Async_kernel_Time_ns[72],
    get_sexp_zone = Async_kernel_Time_ns[73],
    interruptible_pause = Async_kernel_Time_ns[74],
    of_date_ofday_zoned = Async_kernel_Time_ns[75],
    of_string_abs = Async_kernel_Time_ns[76],
    of_string_fix_proto = Async_kernel_Time_ns[77],
    pause = Async_kernel_Time_ns[78],
    pause_forever = Async_kernel_Time_ns[79],
    pp = Async_kernel_Time_ns[80],
    set_sexp_zone = Async_kernel_Time_ns[81],
    sexp_of_t_abs = Async_kernel_Time_ns[82],
    t_of_sexp_abs = Async_kernel_Time_ns[83],
    to_date_ofday_zoned = Async_kernel_Time_ns[84],
    to_ofday_zoned = Async_kernel_Time_ns[85],
    to_string_fix_proto = Async_kernel_Time_ns[86],
    bin_size_t = Async_kernel_Time_ns[87],
    bin_write_t = Async_kernel_Time_ns[88],
    bin_read_t = Async_kernel_Time_ns[89],
    bin_read_t$0 = Async_kernel_Time_ns[90],
    bin_shape_t = Async_kernel_Time_ns[91],
    bin_writer_t = Async_kernel_Time_ns[92],
    bin_reader_t = Async_kernel_Time_ns[93],
    bin_t = Async_kernel_Time_ns[94],
    hash_fold_t = Async_kernel_Time_ns[95],
    hash = Async_kernel_Time_ns[96],
    t_of_sexp = Async_kernel_Time_ns[97],
    t_sexp_grammar = Async_kernel_Time_ns[99],
    symbol = Async_kernel_Time_ns[100],
    symbol$0 = Async_kernel_Time_ns[101],
    symbol$1 = Async_kernel_Time_ns[102],
    symbol$2 = Async_kernel_Time_ns[103],
    symbol$3 = Async_kernel_Time_ns[104],
    symbol$4 = Async_kernel_Time_ns[105],
    equal = Async_kernel_Time_ns[106],
    compare = Async_kernel_Time_ns[107],
    min = Async_kernel_Time_ns[108],
    max = Async_kernel_Time_ns[109],
    ascending = Async_kernel_Time_ns[110],
    descending = Async_kernel_Time_ns[111],
    between = Async_kernel_Time_ns[112],
    clamp_exn = Async_kernel_Time_ns[113],
    clamp = Async_kernel_Time_ns[114],
    comparator = Async_kernel_Time_ns[115],
    validate_lbound = Async_kernel_Time_ns[116],
    validate_ubound = Async_kernel_Time_ns[117],
    validate_bound = Async_kernel_Time_ns[118],
    after = Async_kernel_Time_ns[119],
    _ap_ = [0, 0],
    cst_cannot_call_advance_by_ala =
      "cannot call [advance_by_alarms] or [advance_directly] from callback",
    _ao_ = [0, cst_src_synchronous_time_sourc$0, 650, 63],
    _an_ = [0, 0],
    cst_cannot_schedule_an_event_w = "cannot schedule an event with status",
    _am_ = [0, "reason"],
    cst_Synchronous_time_source_ab =
      "[Synchronous_time_source.abort_exn] cannot abort event",
    _al_ = [0, cst_src_synchronous_time_sourc$0, 548, 17],
    _aj_ = [0, "Previously_unscheduled"],
    _ak_ = [0, "Ok"],
    _ah_ = [0, "alarm_precision"],
    _ai_ = [0, "span"],
    cst_interval_span_smaller_than =
      "interval span smaller than alarm precision",
    _af_ = [0, "_"],
    _ae_ = [0, cst_src_synchronous_time_sourc$0, 345, 17],
    _ad_ = [0, cst_src_synchronous_time_sourc$0, 352, 15],
    _ac_ = [0, cst_src_synchronous_time_sourc$0, 356, 17],
    _ab_ = [0, cst_src_synchronous_time_sourc$0, 368, 29],
    _ag_ = [0, cst_src_synchronous_time_sourc$0, 329, 11681, 11705],
    _$_ = [0, cst_events$0],
    _aa_ = [0, cst_now],
    ___ = [0, cst_now],
    cst_wall_clock = "wall_clock",
    cst_Job_t = "<Job.t>",
    _F_ = [0, "event"],
    _G_ = [0, "to_"],
    _H_ = [0, "from"],
    cst_bug_set_status_transition_ =
      "bug -- set_status transition not allowed",
    cst_src_synchronous_time_sourc = "src/synchronous_time_source0.ml:232:12",
    _D_ = [0, cst_src_synchronous_time_sourc$0, 208, 17],
    _C_ = [0, cst_src_synchronous_time_sourc$0, 218, 17],
    _B_ = [0, cst_src_synchronous_time_sourc$0, 222, 45],
    _E_ = [0, cst_src_synchronous_time_sourc$0, 184, 6180, 6206],
    cst_Synchronous_time_source_Ev =
      "[Synchronous_time_source.Event.Option.value_exn None]",
    _k_ = [1, 0],
    _h_ = [0, cst_interval$0],
    _i_ = [0, cst_at$0],
    _j_ = [0, cst_status$0],
    _d_ = [0, "Fired"],
    _e_ = [0, "Happening_periodic_event"],
    _f_ = [0, "Scheduled"],
    _g_ = [0, "Unscheduled"],
    _b_ = [0, 13, [0, 6, [0, 6, [0, 5, 0]]]],
    cst_status = cst_status$0,
    cst_prev_fired = "prev_fired",
    cst_next_fired = "next_fired",
    cst_interval = cst_interval$0,
    cst_execution_context = "execution_context",
    cst_callback = "callback",
    cst_at = cst_at$0,
    cst_alarm = "alarm",
    cst_scheduler = "scheduler",
    cst_is_wall_clock = "is_wall_clock",
    cst_handle_fired = "handle_fired",
    cst_most_recently_fired = "most_recently_fired",
    cst_fired_events = "fired_events",
    cst_events = cst_events$0,
    cst_am_advancing = "am_advancing",
    cst_advance_errors = "advance_errors",
    cst_id = "id",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Synchronous_t = cst_Async_kernel_Synchronous_t$0;
   function sexp_of_t(t){
    var
     _bM_ = caml_call1(to_span_since_epoch, t),
     _bN_ =
       runtime.core_time_ns_format
        (caml_call1(Core_Time_ns[1][89], _bM_), "%Y-%m-%dT%H:%M:%S%z");
    return caml_call1(Core[558], _bN_);
   }
   var
    Time_ns =
      [0,
       typerep_of_t,
       typename_of_t,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       round_up_to_us,
       round_up_to_ms,
       round_up_to_sec,
       round_down_to_us,
       round_down_to_ms,
       round_down_to_sec,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       arg_type,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       hash_fold_t,
       hash,
       t_of_sexp,
       t_sexp_grammar,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       after,
       sexp_of_t],
    include = Timing_wheel[5],
    sexp_of_t$0 = include[1],
    null$0 = include[2],
    at = include[3],
    interval_num = include[4],
    value = include[5];
   function is_null(t){return t === caml_call1(null$0, 0) ? 1 : 0;}
   var
    Alarm = [0, sexp_of_t$0, null$0, at, interval_num, value, is_null],
    _a_ = caml_call2(Timing_wheel[1][13], Timing_wheel[1][10], 3),
    _c_ = [0, caml_call2(Timing_wheel[7][5], 0, _b_)],
    default_timing_wheel_config =
      caml_call4(Timing_wheel[8][4], 0, _c_, _a_, 0),
    compare$0 = runtime.caml_int_compare;
   function equal$0(_bL_, _bK_){return _bL_ === _bK_ ? 1 : 0;}
   function sexp_of_t$1(param){
    switch(param){
      case 0:
       return _d_;
      case 1:
       return _e_;
      case 2:
       return _f_;
      default: return _g_;
    }
   }
   function transition_is_allowed(from, to){
    a:
    {
     switch(from){
       case 0:
        if(1 !== to && 3 > to) break a; break;
       case 1:
        if(2 > to) break a; break;
       case 2:
        if(1 >= to - 1 >>> 0) break a; break;
       default: if(1 === to || 3 <= to) break a;
     }
     return 1;
    }
    return 0;
   }
   var Status = [0, compare$0, equal$0, sexp_of_t$1, transition_is_allowed];
   function sexp_of_event(param){
    var at = param[2], interval = param[5], status = param[8], match = 0;
    if(interval)
     var
      v = interval[1],
      _bI_ =
        [0, [1, [0, _h_, [0, caml_call1(Core_Time_ns[1][10], v), 0]]], match];
    else
     var _bI_ = match;
    var _bJ_ = [0, [1, [0, _i_, [0, caml_call1(Time_ns[119], at), 0]]], _bI_];
    return [1,
            [0, [1, [0, _j_, [0, caml_call1(Status[3], status), 0]]], _bJ_]];
   }
   var Event_is_block = [0], none = 0;
   function some(_bH_){return _bH_;}
   function is_none(t){return t === 0 ? 1 : 0;}
   function is_some(t){return 1 - (t === 0 ? 1 : 0);}
   function first_some(t1, t2){return is_some(t1) ? t1 : t2;}
   function unsafe_value(_bG_){return _bG_;}
   var
    Optional_syntax = [0, is_none, unsafe_value],
    Optional_syntax$0 = [0, Optional_syntax];
   function sexp_of_t$2(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)) return _k_;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return sexp_of_event(event);
   }
   function value$0(t, default$0){
    return runtime.caml_csel_value(t === 0 ? 1 : 0, default$0, t);
   }
   function value_exn(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)){
     var
      _bF_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Synchronous_time_source_Ev);
     return caml_call1(Core[261], _bF_);
    }
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return event;
   }
   function to_option(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)) return 0;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return [0, event];
   }
   function of_option(param){
    if(! param) return none;
    var event = param[1];
    return event;
   }
   var
    Option =
      [0,
       Event_is_block,
       none,
       some,
       is_none,
       is_some,
       first_some,
       unsafe_value,
       Optional_syntax$0,
       sexp_of_t$2,
       value$0,
       value_exn,
       to_option,
       of_option];
   function status(r){return r[8];}
   function set_status(r, v){r[8] = v; return 0;}
   function prev_fired(r){return r[7];}
   function set_prev_fired(r, v){r[7] = v; return 0;}
   function next_fired(r){return r[6];}
   function set_next_fired(r, v){r[6] = v; return 0;}
   function interval(r){return r[5];}
   function set_interval(r, v){r[5] = v; return 0;}
   function execution_context(r){return r[4];}
   function callback(r){return r[3];}
   function at$0(r){return r[2];}
   function set_at(r, v){r[2] = v; return 0;}
   function alarm(r){return r[1];}
   function set_alarm(r, v){r[1] = v; return 0;}
   function _l_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
   }
   var
    _m_ = [0, set_status],
    status$0 = [0, function(param){return 0;}, cst_status, _m_, status, _l_];
   function _n_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _o_ = [0, set_prev_fired],
    prev_fired$0 =
      [0, function(param){return 0;}, cst_prev_fired, _o_, prev_fired, _n_];
   function _p_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
   }
   var
    _q_ = [0, set_next_fired],
    next_fired$0 =
      [0, function(param){return 0;}, cst_next_fired, _q_, next_fired, _p_];
   function _r_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
   }
   var
    _s_ = [0, set_interval],
    interval$0 =
      [0, function(param){return 0;}, cst_interval, _s_, interval, _r_];
   function _t_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
   }
   var
    _u_ = 0,
    execution_context$0 =
      [0,
       function(param){return 0;},
       cst_execution_context,
       _u_,
       execution_context,
       _t_];
   function _v_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _w_ = 0,
    callback$0 =
      [0, function(param){return 0;}, cst_callback, _w_, callback, _v_];
   function _x_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _y_ = [0, set_at],
    at$1 = [0, function(param){return 0;}, cst_at, _y_, at$0, _x_];
   function _z_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _A_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _A_, alarm, _z_];
   function iter
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    caml_call1(alarm_fun, alarm$0);
    caml_call1(at_fun, at$1);
    caml_call1(callback_fun, callback$0);
    caml_call1(execution_context_fun, execution_context$0);
    caml_call1(interval_fun, interval$0);
    caml_call1(next_fired_fun, next_fired$0);
    caml_call1(prev_fired_fun, prev_fired$0);
    return caml_call1(status_fun, status$0);
   }
   var
    Fields =
      [0,
       status$0,
       prev_fired$0,
       next_fired$0,
       interval$0,
       execution_context$0,
       callback$0,
       at$1,
       alarm$0,
       iter];
   function invariant(t){
    function _bq_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      _br_ =
        check
         (function(status){
           if(1 !== status) return 0;
           if(caml_call1(Core_Option[62], t[5])) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
          }),
      _bs_ =
        check
         (function(ppx_optional_e_0){
           if(caml_call1(Option[8][1][1], ppx_optional_e_0)) return 0;
           var
            prev_fired = caml_call1(Option[8][1][2], ppx_optional_e_0),
            got = t[8],
            sexpifier = Status[3],
            expect = 0,
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_013, b_014){
            return caml_call2(Status[1], a_013, b_014);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             expect,
             got);
           var _bE_ = prev_fired[6];
           if(caml_call1(Option[3], t) === _bE_) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
          }),
      _bt_ =
        check
         (function(ppx_optional_e_0){
           if(caml_call1(Option[8][1][1], ppx_optional_e_0)) return 0;
           var
            next_fired = caml_call1(Option[8][1][2], ppx_optional_e_0),
            got = t[8],
            sexpifier = Status[3],
            expect = 0,
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_009, b_010){
            return caml_call2(Status[1], a_009, b_010);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos$0,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             expect,
             got);
           var _bD_ = next_fired[7];
           if(caml_call1(Option[3], t) === _bD_) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
          });
     function _bu_(_bC_){return 0;}
     function _bv_(_bB_){return 0;}
     function _bw_(_bA_){return 0;}
     function _bx_(_bz_){return 0;}
     var
      _by_ =
        check
         (function(alarm){
           var
            got = caml_call1(Alarm[6], alarm),
            expect = 2 === t[8] ? 0 : 1,
            sexpifier = Core[323],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_005, b_006){
            return caml_call2(Core[316], a_005, b_006);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$1,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    got);
          });
     return caml_call8
             (Fields[9], _by_, _bx_, _bw_, _bv_, _bu_, _bt_, _bs_, _br_);
    }
    return caml_call4(Base_Invariant[1], _E_, t, sexp_of_event, _bq_);
   }
   function set_status$0(t, to){
    var from = t[8];
    if(1 - caml_call2(Status[4], from, to)){
     var
      _bl_ = [0, [1, [0, _F_, [0, sexp_of_event(t), 0]]], 0],
      _bm_ = [0, [1, [0, _G_, [0, caml_call1(Status[3], to), 0]]], _bl_],
      _bn_ = [0, [1, [0, _H_, [0, caml_call1(Status[3], from), 0]]], _bm_],
      _bo_ =
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_bug_set_status_transition_),
         _bn_],
      _bp_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_src_synchronous_time_sourc),
          _bo_]];
     caml_call1(Core[261], _bp_);
    }
    t[8] = to;
    return 0;
   }
   function set_status_if(is, t, to){
    var _bk_ = caml_call2(Status[2], is, t[8]);
    return _bk_ ? set_status$0(t, to) : _bk_;
   }
   var
    Event =
      [0,
       Status,
       sexp_of_event,
       Option,
       status,
       prev_fired,
       set_prev_fired,
       next_fired,
       set_next_fired,
       interval,
       set_interval,
       execution_context,
       callback,
       at$0,
       set_at,
       alarm,
       set_alarm,
       Fields,
       sexp_of_event,
       invariant,
       set_status$0,
       set_status_if,
       at$0],
    of_event = Async_kernel_Job_or_event[1],
    of_job = Async_kernel_Job_or_event[2],
    is_event = Async_kernel_Job_or_event[3],
    is_job = Async_kernel_Job_or_event[4],
    Match = Async_kernel_Job_or_event[5];
   function sexp_of_t$3(t){
    var
     k = caml_call1(Async_kernel_Job_or_event[5][1], t),
     match = caml_call2(Async_kernel_Job_or_event[5][2], k, t);
    return k
            ? caml_call1(Sexplib0_Sexp_conv[7], cst_Job_t)
            : caml_call1(Event[18], match);
   }
   var
    Job_or_event = [0, of_event, of_job, is_event, is_job, Match, sexp_of_t$3];
   function scheduler(r){return r[9];}
   function is_wall_clock(r){return r[8];}
   function handle_fired(r){return r[7];}
   function most_recently_fired(r){return r[6];}
   function set_most_recently_fired(r, v){r[6] = v; return 0;}
   function fired_events(r){return r[5];}
   function set_fired_events(r, v){r[5] = v; return 0;}
   function events(r){return r[4];}
   function am_advancing(r){return r[3];}
   function set_am_advancing(r, v){r[3] = v; return 0;}
   function advance_errors(r){return r[2];}
   function set_advance_errors(r, v){r[2] = v; return 0;}
   function id(r){return r[1];}
   function _I_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], v];
   }
   var
    _J_ = 0,
    scheduler$0 =
      [0, function(param){return 0;}, cst_scheduler, _J_, scheduler, _I_];
   function _K_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v, r[9]];
   }
   var
    _L_ = 0,
    is_wall_clock$0 =
      [0,
       function(param){return 0;},
       cst_is_wall_clock,
       _L_,
       is_wall_clock,
       _K_];
   function _M_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8], r[9]];
   }
   var
    _N_ = 0,
    handle_fired$0 =
      [0,
       function(param){return 0;},
       cst_handle_fired,
       _N_,
       handle_fired,
       _M_];
   function _O_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8], r[9]];
   }
   var
    _P_ = [0, set_most_recently_fired],
    most_recently_fired$0 =
      [0,
       function(param){return 0;},
       cst_most_recently_fired,
       _P_,
       most_recently_fired,
       _O_];
   function _Q_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8], r[9]];
   }
   var
    _R_ = [0, set_fired_events],
    fired_events$0 =
      [0,
       function(param){return 0;},
       cst_fired_events,
       _R_,
       fired_events,
       _Q_];
   function _S_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8], r[9]];
   }
   var
    _T_ = 0,
    events$0 = [0, function(param){return 0;}, cst_events, _T_, events, _S_];
   function _U_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8], r[9]];
   }
   var
    _V_ = [0, set_am_advancing],
    am_advancing$0 =
      [0,
       function(param){return 0;},
       cst_am_advancing,
       _V_,
       am_advancing,
       _U_];
   function _W_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8], r[9]];
   }
   var
    _X_ = [0, set_advance_errors],
    advance_errors$0 =
      [0,
       function(param){return 0;},
       cst_advance_errors,
       _X_,
       advance_errors,
       _W_];
   function _Y_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9]];
   }
   var _Z_ = 0, id$0 = [0, function(param){return 0;}, cst_id, _Z_, id, _Y_];
   function iter$0
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    caml_call1(id_fun, id$0);
    caml_call1(advance_errors_fun, advance_errors$0);
    caml_call1(am_advancing_fun, am_advancing$0);
    caml_call1(events_fun, events$0);
    caml_call1(fired_events_fun, fired_events$0);
    caml_call1(most_recently_fired_fun, most_recently_fired$0);
    caml_call1(handle_fired_fun, handle_fired$0);
    caml_call1(is_wall_clock_fun, is_wall_clock$0);
    return caml_call1(scheduler_fun, scheduler$0);
   }
   var
    Fields$0 =
      [0,
       scheduler$0,
       is_wall_clock$0,
       handle_fired$0,
       most_recently_fired$0,
       fired_events$0,
       events$0,
       am_advancing$0,
       advance_errors$0,
       id$0,
       iter$0];
   function sexp_of_t$4(param, _a$_){
    var
     events = _a$_[4],
     is_wall_clock = _a$_[8],
     now = caml_call1(Timing_wheel[11], events);
    if(is_wall_clock){
     var _ba_ = [0, [1, [0, ___, [0, caml_call1(Time_ns[119], now), 0]]], 0];
     return [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_wall_clock), _ba_]];
    }
    var all_events = [0, 0];
    function _bb_(alarm){
     var _bi_ = all_events[1], _bj_ = caml_call2(Alarm[5], events, alarm);
     all_events[1] = [0, [0, caml_call2(Alarm[3], events, alarm), _bj_], _bi_];
     return 0;
    }
    caml_call2(Timing_wheel[15], events, _bb_);
    function _bc_(_bh_){return _bh_[2];}
    function _bd_(param, _bg_){
     var at2 = _bg_[1], at1 = param[1];
     return caml_call2(Time_ns[106], at1, at2);
    }
    var
     _be_ = caml_call2(Core_List[79], all_events[1], _bd_),
     events$0 = caml_call2(Core_List[51], _be_, _bc_),
     _bf_ =
       [0,
        [1,
         [0, _$_, [0, caml_call2(Core[472], Job_or_event[6], events$0), 0]]],
        0];
    return [1,
            [0, [1, [0, _aa_, [0, caml_call1(Time_ns[119], now), 0]]], _bf_]];
   }
   function timing_wheel_now(t){return caml_call1(Timing_wheel[11], t[4]);}
   function is_in_fired_events(t, target_event){
    var current$1 = t[5], ppx_optional_e_0 = current$1;
    for(;;){
     if(caml_call1(Event[3][8][1][1], ppx_optional_e_0)) return 0;
     var
      current = caml_call1(Event[3][8][1][2], ppx_optional_e_0),
      _a__ = current === target_event ? 1 : 0;
     if(_a__) return _a__;
     var current$0 = current[6], ppx_optional_e_0 = current$0;
    }
   }
   function invariant_with_jobs(job_invariant, t){
    function _aP_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     function _aR_(_a9_){return 0;}
     function _aS_(_a8_){return 0;}
     function _aT_(_a7_){return 0;}
     var
      _aU_ =
        check
         (function(most_recently_fired){
           if(caml_call1(Event[3][8][1][1], most_recently_fired)) return 0;
           var event = caml_call1(Event[3][8][1][2], most_recently_fired);
           if(is_in_fired_events(t, event)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
          }),
      _aV_ =
        check
         (function(ppx_optional_e_0){
           if(caml_call1(Event[3][8][1][1], ppx_optional_e_0)) return 0;
           var
            current$1 = caml_call1(Event[3][8][1][2], ppx_optional_e_0),
            current = current$1;
           for(;;){
            var _a6_ = timing_wheel_now(t);
            if(! caml_call2(Time_ns[100], current[2], _a6_))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _ad_], 1);
            var ppx_optional_e_0$0 = current[6];
            if(caml_call1(Event[3][8][1][1], ppx_optional_e_0$0)) return 0;
            var current$0 = caml_call1(Event[3][8][1][2], ppx_optional_e_0$0);
            if(! caml_call2(Time_ns[100], current[2], current$0[2]))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
            var current = current$0;
           }
          }),
      _aW_ =
        check
         (function(events){
           function _a3_(_a5_){return 0;}
           caml_call2(Timing_wheel[6], _a3_, events);
           function _a4_(alarm){
            var
             job_or_event = caml_call2(Alarm[5], events, alarm),
             k = caml_call1(Job_or_event[5][1], job_or_event),
             event = caml_call2(Job_or_event[5][2], k, job_or_event);
            if(k) return caml_call1(job_invariant, event);
            if(alarm !== event[1])
             throw caml_maybe_attach_backtrace([0, Assert_failure, _ae_], 1);
            var
             got = event[2],
             expect = caml_call2(Alarm[3], events, alarm),
             sexpifier = Time_ns[119],
             equal = 0,
             message = 0,
             here = 0;
            function comparator(a_017, b_018){
             return caml_call2(Time_ns[106], a_017, b_018);
            }
            caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$2,
              sexpifier,
              comparator,
              here,
              message,
              equal,
              expect,
              got);
            var
             got$0 = event[8],
             sexpifier$0 = Event[1][3],
             expect$0 = 2,
             equal$0 = 0,
             message$0 = 0,
             here$0 = 0;
            function comparator$0(a_019, b_020){
             return caml_call2(Event[1][1], a_019, b_020);
            }
            caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$3,
              sexpifier$0,
              comparator$0,
              here$0,
              message$0,
              equal$0,
              expect$0,
              got$0);
            return caml_call1(Event[19], event);
           }
           return caml_call2(Timing_wheel[15], events, _a4_);
          });
     function _aX_(_a2_){return 0;}
     function _aY_(_a1_){return 0;}
     function _aZ_(_a0_){return 0;}
     return caml_call9
             (Fields$0[10],
              _aZ_,
              _aY_,
              _aX_,
              _aW_,
              _aV_,
              _aU_,
              _aT_,
              _aS_,
              _aR_);
    }
    function _aQ_(x_016){
     return sexp_of_t$4(function(param){return _af_;}, x_016);
    }
    return caml_call4(Base_Invariant[1], _ag_, t, _aQ_, _aP_);
   }
   function invariant$0(t){
    return invariant_with_jobs(function(param){return 0;}, t);
   }
   var
    T1 =
      [0,
       Event,
       Job_or_event,
       scheduler,
       is_wall_clock,
       handle_fired,
       most_recently_fired,
       set_most_recently_fired,
       fired_events,
       set_fired_events,
       events,
       am_advancing,
       set_am_advancing,
       advance_errors,
       set_advance_errors,
       id,
       Fields$0,
       sexp_of_t$4,
       timing_wheel_now,
       is_in_fired_events,
       invariant_with_jobs,
       invariant$0];
   function sexp_of_t$5(x_021){return caml_call2(T1[17], Core[171], x_021);}
   var invariant$1 = T1[21], invariant_with_jobs$0 = T1[20];
   function sexp_of_t$6(x_022){return caml_call2(T1[17], Core[212], x_022);}
   var Read_write = [0, sexp_of_t$6, invariant$1, invariant_with_jobs$0];
   function id$1(t){return t[1];}
   function is_wall_clock$1(t){return t[8];}
   function length(t){return caml_call1(Timing_wheel[14], t[4]);}
   function max_allowed_alarm_time(t){
    return caml_call1(Timing_wheel[23], t[4]);
   }
   function read_only(t){return t;}
   function fire(t, event){
    caml_call2(T1[1][20], event, 0);
    event[1] = caml_call1(Alarm[2], 0);
    var ppx_optional_e_0 = t[6];
    a:
    {
     if(! caml_call1(T1[1][3][8][1][1], ppx_optional_e_0)){
      var
       most_recently_fired = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0);
      if(caml_call2(Time_ns[100], most_recently_fired[2], event[2])){
       var
        most_recently_fired$0 =
          caml_call1(T1[1][3][8][1][2], ppx_optional_e_0);
       event[7] = caml_call1(T1[1][3][3], most_recently_fired$0);
       event[6] = most_recently_fired$0[6];
       break a;
      }
     }
     event[7] = T1[1][3][2];
     event[6] = t[5];
    }
    t[6] = caml_call1(T1[1][3][3], event);
    for(;;){
     var ppx_optional_e_0$0 = event[6];
     if(caml_call1(T1[1][3][8][1][1], ppx_optional_e_0$0))
      var continue$0 = 0;
     else{
      var
       next$0 = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0$0),
       continue$1 = caml_call2(Time_ns[100], next$0[2], event[2]);
      if(continue$1){event[7] = event[6]; event[6] = next$0[6];}
      var continue$0 = continue$1;
     }
     if(! continue$0) break;
    }
    var ppx_optional_e_0$1 = event[6];
    if(! caml_call1(T1[1][3][8][1][1], ppx_optional_e_0$1)){
     var next = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0$1);
     next[7] = caml_call1(T1[1][3][3], event);
    }
    var ppx_optional_e_0$2 = event[7];
    if(caml_call1(T1[1][3][8][1][1], ppx_optional_e_0$2)){t[5] = caml_call1(T1[1][3][3], event); return 0;}
    var prev = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0$2);
    prev[6] = caml_call1(T1[1][3][3], event);
    return 0;
   }
   function alarm_precision(t){return caml_call1(Timing_wheel[10], t[4]);}
   function next_alarm_fires_at(t){return caml_call1(Timing_wheel[39], t[4]);}
   function next_alarm_runs_at(t){
    return caml_call1(T1[1][3][5], t[5])
            ? [0, caml_call1(T1[18], t)]
            : caml_call1(Timing_wheel[39], t[4]);
   }
   function now$0(t){
    return t[8] ? caml_call1(Time_ns[42], 0) : caml_call1(T1[18], t);
   }
   var timing_wheel_now$0 = T1[18];
   function schedule(t, event){
    caml_call2(T1[1][20], event, 2);
    var _aO_ = caml_call1(T1[2][1], event);
    event[1] = caml_call3(Timing_wheel[26], t[4], event[2], _aO_);
    return 0;
   }
   function remove_from_fired(t, event, new_status){
    var ppx_optional_e_0 = t[6];
    if(! caml_call1(T1[1][3][8][1][1], ppx_optional_e_0)){
     var
      most_recently_fired = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0);
     if(event === most_recently_fired)
      t[6] = caml_call2(T1[1][3][6], event[6], event[7]);
    }
    var ppx_optional_e_0$0 = event[7];
    if(caml_call1(T1[1][3][8][1][1], ppx_optional_e_0$0))
     t[5] = event[6];
    else{
     var prev = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0$0);
     prev[6] = event[6];
    }
    var ppx_optional_e_0$1 = event[6];
    if(! caml_call1(T1[1][3][8][1][1], ppx_optional_e_0$1)){
     var next = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0$1);
     next[7] = event[7];
    }
    event[6] = T1[1][3][2];
    event[7] = T1[1][3][2];
    return caml_call2(T1[1][20], event, new_status);
   }
   var
    include$0 = T1[1],
    Status$0 = include$0[1],
    sexp_of_event$0 = include$0[2],
    Option$0 = include$0[3],
    status$1 = include$0[4],
    prev_fired$1 = include$0[5],
    set_prev_fired$0 = include$0[6],
    next_fired$1 = include$0[7],
    set_next_fired$0 = include$0[8],
    interval$1 = include$0[9],
    set_interval$0 = include$0[10],
    execution_context$1 = include$0[11],
    callback$1 = include$0[12],
    set_at$0 = include$0[14],
    alarm$1 = include$0[15],
    set_alarm$0 = include$0[16],
    Fields$1 = include$0[17],
    sexp_of_t$7 = include$0[18],
    invariant$2 = include$0[19],
    set_status$1 = include$0[20],
    set_status_if$0 = include$0[21],
    scheduled_at = include$0[22];
   function create_internal(t, at, interval, callback){
    var _aL_ = T1[1][3][2], _aM_ = T1[1][3][2], _aN_ = t[9][7];
    return [0,
            caml_call1(Alarm[2], 0),
            at,
            callback,
            _aN_,
            interval,
            _aM_,
            _aL_,
            3];
   }
   function add$0(t, event){
    var _aK_ = caml_call1(timing_wheel_now$0, t);
    return caml_call2(Time_ns[100], event[2], _aK_)
            ? fire(t, event)
            : schedule(t, event);
   }
   function create_and_add(t, at, interval, callback){
    var event = create_internal(t, at, interval, callback);
    add$0(t, event);
    return event;
   }
   function at$2(t, at, callback){return create_and_add(t, at, 0, callback);}
   function after$0(t, span, callback){
    var _aJ_ = now$0(t);
    return create_and_add
            (t, caml_call2(Time_ns[118], _aJ_, span), 0, callback);
   }
   function require_span_at_least_alarm_pr(t, span){
    var
     alarm_precision$0 = alarm_precision(t),
     _aF_ = caml_call2(Core_Time_ns[1][19], span, alarm_precision$0);
    if(! _aF_) return _aF_;
    var
     _aG_ =
       [0,
        [1,
         [0, _ah_, [0, caml_call1(Core_Time_ns[1][10], alarm_precision$0), 0]]],
        0],
     _aH_ =
       [0,
        [1, [0, _ai_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]],
        _aG_],
     _aI_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_interval_span_smaller_than),
         _aH_]];
    return caml_call1(Core[261], _aI_);
   }
   function at_intervals(start, t, span, callback){
    if(start) var at = start[1], at$0 = at; else var at$0 = now$0(t);
    require_span_at_least_alarm_pr(t, span);
    return create_and_add(t, at$0, [0, span], callback);
   }
   function sexp_of_t$8(param){return param ? _aj_ : _ak_;}
   var Abort_result = [0, sexp_of_t$8];
   function abort(t, event){
    switch(event[8]){
      case 0:
       remove_from_fired(t, event, 3); return 0;
      case 1:
       if(! event[5])
        throw caml_maybe_attach_backtrace([0, Assert_failure, _al_], 1);
       event[5] = 0;
       event[8] = 3;
       return 0;
      case 2:
       caml_call2(T1[1][20], event, 3);
       caml_call2(Timing_wheel[29], t[4], event[1]);
       event[1] = caml_call1(Alarm[2], 0);
       return 0;
      default: return 1;
    }
   }
   function abort_if_possible(t, event){abort(t, event); return 0;}
   function abort_exn(t, event){
    var reason = abort(t, event);
    if(! reason) return 0;
    var
     _aD_ =
       [0, [1, [0, _am_, [0, caml_call1(Abort_result[1], reason), 0]]], 0],
     _aE_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Synchronous_time_source_ab),
         _aD_]];
    return caml_call1(Core[261], _aE_);
   }
   function create(t, callback){
    return create_internal(t, Time_ns[35], 0, callback);
   }
   function is_scheduled(event){return 3 <= event[8] ? 0 : 1;}
   function schedule_at_internal(t, event, at, interval){
    var status = event[8];
    if(3 <= status){
     event[2] = at;
     event[5] = interval;
     add$0(t, event);
     return _an_;
    }
    var
     _aB_ = [0, caml_call1(T1[1][1][3], status), 0],
     _aC_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_schedule_an_event_w),
         _aB_]];
    return caml_call1(Core_Or_error[45], _aC_);
   }
   function schedule_at(t, event, at){
    return schedule_at_internal(t, event, at, 0);
   }
   function schedule_after(t, event, span){
    var _aA_ = now$0(t);
    return schedule_at(t, event, caml_call2(Time_ns[118], _aA_, span));
   }
   function schedule_at_intervals(t, event, span, starting_at){
    require_span_at_least_alarm_pr(t, span);
    return schedule_at_internal(t, event, starting_at, [0, span]);
   }
   function schedule_at_intervals$0(t, event, span){
    return schedule_at_intervals(t, event, span, now$0(t));
   }
   function reschedule_at(t, event, at){
    switch(event[8]){
      case 0:
       remove_from_fired(t, event, 3); event[2] = at; return add$0(t, event);
      case 1:
       event[2] = at; return add$0(t, event);
      case 2:
       event[2] = at;
       var _az_ = caml_call1(timing_wheel_now$0, t);
       return caml_call2(Time_ns[102], at, _az_)
               ? caml_call3(Timing_wheel[30], t[4], event[1], at)
               : (caml_call2
                  (Timing_wheel[29], t[4], event[1]),
                 fire(t, event));
      default: event[2] = at; event[5] = 0; return add$0(t, event);
    }
   }
   function reschedule_after(t, event, span){
    var _ay_ = now$0(t);
    return reschedule_at(t, event, caml_call2(Time_ns[118], _ay_, span));
   }
   var
    Event$0 =
      [0,
       Status$0,
       sexp_of_event$0,
       Option$0,
       status$1,
       prev_fired$1,
       set_prev_fired$0,
       next_fired$1,
       set_next_fired$0,
       interval$1,
       set_interval$0,
       execution_context$1,
       callback$1,
       set_at$0,
       alarm$1,
       set_alarm$0,
       Fields$1,
       sexp_of_t$7,
       invariant$2,
       set_status$1,
       set_status_if$0,
       scheduled_at,
       create_internal,
       add$0,
       create_and_add,
       at$2,
       after$0,
       require_span_at_least_alarm_pr,
       at_intervals,
       Abort_result,
       abort,
       abort_if_possible,
       abort_exn,
       create,
       is_scheduled,
       schedule_at_internal,
       schedule_at,
       schedule_after,
       schedule_at_intervals,
       schedule_at_intervals$0,
       reschedule_at,
       reschedule_after];
   function run_after(t, span, callback){
    caml_call3(Event$0[26], t, span, callback);
    return 0;
   }
   function run_at(t, at, callback){
    caml_call3(Event$0[25], t, at, callback);
    return 0;
   }
   function run_at_intervals(start, t, span, callback){
    caml_call4(Event$0[28], start, t, span, callback);
    return 0;
   }
   function run_fired_events(t, send_exn){
    var current_execution_context = t[9][7];
    for(;;){
     var ppx_optional_e_0 = t[5];
     if(caml_call1(Event$0[3][8][1][1], ppx_optional_e_0))
      var _av_ = 0;
     else{
      var event = caml_call1(Event$0[3][8][1][2], ppx_optional_e_0);
      if(event[8])
       throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
      var new_status = event[5] ? 1 : 3;
      remove_from_fired(t, event, new_status);
      caml_call2(Async_kernel_Scheduler0[2], t[9], event[4]);
      a:
      {
       try{caml_call1(event[3], 0);}
       catch(exn$0){
        var exn = caml_wrap_exception(exn$0);
        if(send_exn){
         var
          send_exn$0 = send_exn[1],
          backtrace = caml_call1(Base_Backtrace[6][4], 0);
         caml_call3
          (send_exn$0, event[4][1], [0, [0, 936718974, backtrace]], exn);
        }
        else{
         var _aw_ = t[2];
         t[2] = [0, caml_call2(Core_Error[27], 0, exn), _aw_];
        }
        caml_call3(Event$0[20], 1, event, 3);
        break a;
       }
       var match = event[5];
       if(match){
        var interval = match[1];
        if(caml_call2(Event$0[1][2], 1, event[8])){
         var _ax_ = caml_call1(timing_wheel_now$0, t);
         event[2] = caml_call5(Time_ns[57], 0, event[2], _ax_, interval, 0);
         schedule(t, event);
        }
       }
       else
        caml_call3(Event$0[20], 1, event, 3);
      }
      var _av_ = 1;
     }
     if(! _av_)
      return caml_call2
              (Async_kernel_Scheduler0[2], t[9], current_execution_context);
    }
   }
   function any_fired_events_to_run(t){
    return caml_call1(Event$0[3][5], t[5]);
   }
   function advance_clock(t, to, send_exn){
    caml_call3(Timing_wheel[20], t[4], to, t[7]);
    return run_fired_events(t, send_exn);
   }
   function advance_clock_stop_at_next_ala(t, to, send_exn){
    caml_call3(Timing_wheel[21], t[4], to, t[7]);
    return run_fired_events(t, send_exn);
   }
   function fire_past_alarms(t, send_exn){
    caml_call2(Timing_wheel[22], t[4], t[7]);
    return run_fired_events(t, send_exn);
   }
   function advance_internal(t, to, send_exn){
    advance_clock(t, to, send_exn);
    return fire_past_alarms(t, send_exn);
   }
   function advance_internal_stop_at_next_(t, to, send_exn){
    advance_clock_stop_at_next_ala(t, to, send_exn);
    return fire_past_alarms(t, send_exn);
   }
   function prepare_to_advance(t, send_exn){
    if(t[3]){
     var
      _au_ = caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_call_advance_by_ala);
     caml_call1(Core[261], _au_);
    }
    t[3] = 1;
    if(t[2]) t[2] = 0;
    return run_fired_events(t, send_exn);
   }
   function finish_advancing(t){
    t[3] = 0;
    var errors = t[2];
    return errors ? (t[2] = 0, [1, caml_call1(Core_Error[26], errors)]) : _ap_;
   }
   function advance_by_alarms(t, to){
    prepare_to_advance(t, 0);
    var send_exn = 0;
    for(;;){
     var _at_ = caml_call1(Timing_wheel[11], t[4]);
     if(! caml_call2(Time_ns[103], _at_, to)) return finish_advancing(t);
     advance_internal_stop_at_next_(t, to, send_exn);
    }
   }
   function advance_by_alarms_by(t, by){
    var _as_ = now$0(t);
    return advance_by_alarms(t, caml_call2(Time_ns[118], _as_, by));
   }
   function advance_by_max_alarms_in_each_(t, to){
    prepare_to_advance(t, 0);
    var continue$0 = [0, 1], send_exn = 0;
    for(;;){
     if(! continue$0[1]){
      advance_internal(t, to, send_exn);
      return finish_advancing(t);
     }
     if(caml_call1(Timing_wheel[13], t[4]))
      continue$0[1] = 0;
     else{
      var next_alarm_fires_at = caml_call1(Timing_wheel[40], t[4]);
      if(caml_call2(Time_ns[99], next_alarm_fires_at, to))
       continue$0[1] = 0;
      else
       advance_internal(t, caml_call1(Timing_wheel[37], t[4]), send_exn);
     }
    }
   }
   function advance_directly(t, to){
    prepare_to_advance(t, 0);
    advance_internal(t, to, 0);
    return finish_advancing(t);
   }
   function advance_directly_by(t, by){
    var _ar_ = now$0(t);
    return advance_directly(t, caml_call2(Time_ns[118], _ar_, by));
   }
   function duration_of(t, f){
    var
     start = now$0(t),
     result = caml_call1(f, 0),
     _aq_ = now$0(t),
     duration = caml_call2(Time_ns[49], _aq_, start);
    return [0, result, duration];
   }
   function max_alarm_time_in_min_timing_w(t){
    return caml_call1(Timing_wheel[35], t[4]);
   }
   function has_events_to_run(t){return caml_call1(Event$0[3][5], t[5]);}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Synchronous_t);
   var
    Async_kernel_Synchronous_time_ =
      [0,
       Time_ns,
       Alarm,
       default_timing_wheel_config,
       T1,
       sexp_of_t$5,
       invariant$1,
       invariant_with_jobs$0,
       Read_write,
       id$1,
       is_wall_clock$1,
       length,
       max_allowed_alarm_time,
       read_only,
       fire,
       alarm_precision,
       next_alarm_fires_at,
       next_alarm_runs_at,
       now$0,
       timing_wheel_now$0,
       schedule,
       remove_from_fired,
       Event$0,
       run_after,
       run_at,
       run_at_intervals,
       run_fired_events,
       any_fired_events_to_run,
       advance_clock,
       advance_clock_stop_at_next_ala,
       fire_past_alarms,
       advance_internal,
       advance_internal_stop_at_next_,
       prepare_to_advance,
       finish_advancing,
       advance_by_alarms,
       advance_by_alarms_by,
       advance_by_max_alarms_in_each_,
       advance_directly,
       advance_directly_by,
       duration_of,
       max_alarm_time_in_min_timing_w,
       has_events_to_run];
   runtime.caml_register_global
    (102, Async_kernel_Synchronous_time_, cst_Async_kernel_Synchronous_t$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler1
//# unitInfo: Requires: Async_kernel__Debug, Async_kernel__Execution_context, Async_kernel__External_job, Async_kernel__Import, Async_kernel__Job_pool, Async_kernel__Job_queue, Async_kernel__Scheduler0, Async_kernel__Synchronous_time_source0, Async_kernel__Time_ns, Async_kernel__Types, Async_kernel_config, Base__Exn, Base__Field, Base__Invariant, Core, Core__Array, Core__Deque, Core__Error, Core__Hashtbl, Core__Int, Core__List, Core__Option, Core__Result, Core__Sexp, Core__Time_ns, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue, Timing_wheel, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler1$0 = "Async_kernel__Scheduler1",
    cst_async_kernel$0 = "async_kernel",
    cst_check_access$0 = "check_access",
    cst_check_invariants$0 = "check_invariants",
    cst_current_execution_context$0 = "current_execution_context",
    cst_cycle_count$0 = "cycle_count",
    cst_cycle_start$0 = "cycle_start",
    cst_event_added_hook$0 = "event_added_hook",
    cst_exec$0 = "exec",
    cst_execution_context$0 = "execution_context",
    cst_external_jobs$0 = "external_jobs",
    cst_in_cycle$0 = "in_cycle",
    cst_job_pool$0 = "job_pool",
    cst_job_queued_hook$0 = "job_queued_hook",
    cst_last_cycle_num_jobs$0 = "last_cycle_num_jobs",
    cst_last_cycle_time$0 = "last_cycle_time",
    cst_low_priority_jobs$0 = "low_priority_jobs",
    cst_main_execution_context$0 = "main_execution_context",
    cst_max_num_jobs_per_priority_$0 = "max_num_jobs_per_priority_per_cycle",
    cst_normal_priority_jobs$0 = "normal_priority_jobs",
    cst_record_backtraces$0 = "record_backtraces",
    cst_run_every_cycle_end$0 = "run_every_cycle_end",
    cst_run_every_cycle_end_state$0 = "run_every_cycle_end_state",
    cst_run_every_cycle_start$0 = "run_every_cycle_start",
    cst_run_every_cycle_start_stat$0 = "run_every_cycle_start_state",
    cst_src_scheduler1_ml = "src/scheduler1.ml",
    cst_thread_safe_external_job_h$0 = "thread_safe_external_job_hook",
    cst_time_source$0 = "time_source",
    cst_total_cycle_time$0 = "total_cycle_time",
    cst_uncaught_exn$0 = "uncaught_exn",
    cst_very_low_priority_workers$0 = "very_low_priority_workers",
    cst_yield$0 = "yield",
    cst_yield_until_no_jobs_remain$0 = "yield_until_no_jobs_remain",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call28
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25,
    a26,
    a27){
    return (f.l >= 0 ? f.l : f.l = f.length) == 28
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25,
               a26,
               a27)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23,
                a24,
                a25,
                a26,
                a27]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Job_queue = global_data.Async_kernel__Job_queue,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Timing_wheel = global_data.Timing_wheel,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Types = global_data.Async_kernel__Types,
    Core_Int = global_data.Core__Int,
    Base_Exn = global_data.Base__Exn,
    Core_Sexp = global_data.Core__Sexp,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_List = global_data.Core__List,
    Tuple_pool = global_data.Tuple_pool,
    Core = global_data.Core,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Core_Option = global_data.Core__Option,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core_Deque = global_data.Core__Deque,
    Async_kernel_Job_pool = global_data.Async_kernel__Job_pool,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Assert_failure = global_data.Assert_failure,
    Base_Field = global_data.Base__Field,
    Core_Array = global_data.Core__Array,
    Core_Error = global_data.Core__Error,
    Async_kernel_External_job = global_data.Async_kernel__External_job,
    Core_Time_ns = global_data.Core__Time_ns,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Core_Result = global_data.Core__Result;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler1$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_scheduler1_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "scheduler1.ml");
   var
    events = Async_kernel_Scheduler0[1],
    set_execution_context = Async_kernel_Scheduler0[2],
    debug = Async_kernel_Debug[10],
    _aU_ = [0, 0],
    _aV_ = [0, 0],
    cst_got_uncaught_exn = "got_uncaught_exn",
    _aO_ = [0, "t"],
    _aP_ = [0, "exn"],
    cst_Scheduler_invariant_failed = "Scheduler.invariant failed",
    _aT_ = [0, cst_src_scheduler1_ml, 172, 40],
    _aS_ = [0, cst_src_scheduler1_ml, 173, 46],
    _aR_ = [0, cst_src_scheduler1_ml, 187, 43],
    _aQ_ = [0, cst_src_scheduler1_ml, 191, 14],
    _aN_ = [0, cst_src_scheduler1_ml, 155, 2],
    cst_unhandled_exception = "unhandled exception",
    _al_ = [0, cst_record_backtraces$0],
    _am_ = [0, cst_max_num_jobs_per_priority_$0],
    _an_ = [0, cst_check_invariants$0],
    _ao_ = [0, cst_yield_until_no_jobs_remain$0],
    _ap_ = [0, cst_yield$0],
    _aq_ = [0, cst_event_added_hook$0],
    _ar_ = [0, cst_job_queued_hook$0],
    _as_ = [0, cst_thread_safe_external_job_h$0],
    _at_ = [0, cst_external_jobs$0],
    _au_ = [0, cst_time_source$0],
    _av_ = [0, cst_total_cycle_time$0],
    _aw_ = [0, cst_last_cycle_num_jobs$0],
    _ax_ = [0, cst_last_cycle_time$0],
    _ay_ = [0, cst_run_every_cycle_end_state$0],
    _az_ = [0, cst_run_every_cycle_end$0],
    _aA_ = [0, cst_run_every_cycle_start_stat$0],
    _aB_ = [0, cst_run_every_cycle_start$0],
    _aC_ = [0, cst_in_cycle$0],
    _aD_ = [0, cst_cycle_start$0],
    _aE_ = [0, cst_cycle_count$0],
    _aF_ = [0, cst_uncaught_exn$0],
    _aG_ = [0, cst_current_execution_context$0],
    _aH_ = [0, cst_main_execution_context$0],
    _aI_ = [0, cst_very_low_priority_workers$0],
    _aJ_ = [0, cst_low_priority_jobs$0],
    _aK_ = [0, cst_normal_priority_jobs$0],
    _aL_ = [0, cst_job_pool$0],
    _aM_ = [0, cst_check_access$0],
    _i_ = [0, cst_src_scheduler1_ml, 51, 1661, 1685],
    _g_ = [0, cst_exec$0],
    _h_ = [0, cst_execution_context$0],
    _a_ = [0, "Not_finished"],
    _b_ = [0, "Finished"],
    cst_exec = cst_exec$0,
    cst_execution_context = cst_execution_context$0,
    cst_record_backtraces = cst_record_backtraces$0,
    cst_max_num_jobs_per_priority_ = cst_max_num_jobs_per_priority_$0,
    cst_check_invariants = cst_check_invariants$0,
    cst_yield_until_no_jobs_remain = cst_yield_until_no_jobs_remain$0,
    cst_yield = cst_yield$0,
    cst_event_added_hook = cst_event_added_hook$0,
    cst_job_queued_hook = cst_job_queued_hook$0,
    cst_thread_safe_external_job_h = cst_thread_safe_external_job_h$0,
    cst_external_jobs = cst_external_jobs$0,
    cst_time_source = cst_time_source$0,
    cst_total_cycle_time = cst_total_cycle_time$0,
    cst_last_cycle_num_jobs = cst_last_cycle_num_jobs$0,
    cst_last_cycle_time = cst_last_cycle_time$0,
    cst_run_every_cycle_end_state = cst_run_every_cycle_end_state$0,
    cst_run_every_cycle_end = cst_run_every_cycle_end$0,
    cst_run_every_cycle_start_stat = cst_run_every_cycle_start_stat$0,
    cst_run_every_cycle_start = cst_run_every_cycle_start$0,
    cst_in_cycle = cst_in_cycle$0,
    cst_cycle_start = cst_cycle_start$0,
    cst_cycle_count = cst_cycle_count$0,
    cst_uncaught_exn = cst_uncaught_exn$0,
    cst_current_execution_context = cst_current_execution_context$0,
    cst_main_execution_context = cst_main_execution_context$0,
    cst_very_low_priority_workers = cst_very_low_priority_workers$0,
    cst_low_priority_jobs = cst_low_priority_jobs$0,
    cst_normal_priority_jobs = cst_normal_priority_jobs$0,
    cst_job_pool = cst_job_pool$0,
    cst_check_access = cst_check_access$0,
    cst_Async_cannot_create_its_ra = "Async cannot create its raw scheduler",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler1 = cst_Async_kernel_Scheduler1$0;
   function create_with_cell(cell){return [0, cell];}
   function create(param){return [0, 0];}
   function create_full(a){return [0, [2, a]];}
   var Ivar = [0, create_with_cell, create, create_full];
   function create$0(param){
    var _c$_ = [0, 0, caml_call1(Ivar[2], 0)];
    return caml_call1(Async_kernel_Types[10][1], _c$_);
   }
   var Bvar = [0, create$0];
   function sexp_of_t(param){return param ? _a_ : _b_;}
   var Exec_result = [0, sexp_of_t];
   function exec(r){return r[2];}
   function execution_context(r){return r[1];}
   function _c_(r, v){return [0, r[1], v];}
   var
    _d_ = 0,
    exec$0 = [0, function(param){return 0;}, cst_exec, _d_, exec, _c_];
   function _e_(r, v){return [0, v, r[2]];}
   var
    _f_ = 0,
    execution_context$0 =
      [0,
       function(param){return 0;},
       cst_execution_context,
       _f_,
       execution_context,
       _e_];
   function iter(execution_context_fun, exec_fun){
    caml_call1(execution_context_fun, execution_context$0);
    return caml_call1(exec_fun, exec$0);
   }
   var Fields = [0, exec$0, execution_context$0, iter];
   function sexp_of_t$0(param){
    var execution_context_002 = param[1], bnds_001 = 0;
    function _c9_(_c__){return 0;}
    var
     arg_005 = caml_call1(Sexplib0_Sexp_conv[24], _c9_),
     bnds_001$0 = [0, [1, [0, _g_, [0, arg_005, 0]]], bnds_001],
     arg_003 =
       caml_call1(Async_kernel_Execution_context[5], execution_context_002),
     bnds_001$1 = [0, [1, [0, _h_, [0, arg_003, 0]]], bnds_001$0];
    return [1, bnds_001$1];
   }
   function invariant(t){
    function _c5_(param){
     function _c7_(_c8_){return 0;}
     var
      f = Async_kernel_Execution_context[6],
      _c6_ = caml_call2(Base_Invariant[2], t, f);
     return caml_call2(Fields[3], _c6_, _c7_);
    }
    return caml_call4(Base_Invariant[1], _i_, t, sexp_of_t$0, _c5_);
   }
   var
    Very_low_priority_worker =
      [0,
       Exec_result,
       exec,
       execution_context,
       Fields,
       sexp_of_t$0,
       invariant];
   function record_backtraces(r){return r[28];}
   function set_record_backtraces(r, v){r[28] = v; return 0;}
   function max_num_jobs_per_priority_per_(r){return r[27];}
   function set_max_num_jobs_per_priority_(r, v){r[27] = v; return 0;}
   function check_invariants(r){return r[26];}
   function set_check_invariants(r, v){r[26] = v; return 0;}
   function yield_until_no_jobs_remain(r){return r[25];}
   function set_yield_until_no_jobs_remain(r, v){r[25] = v; return 0;}
   function yield$0(r){return r[24];}
   function set_yield(r, v){r[24] = v; return 0;}
   function event_added_hook(r){return r[23];}
   function set_event_added_hook(r, v){r[23] = v; return 0;}
   function job_queued_hook(r){return r[22];}
   function set_job_queued_hook(r, v){r[22] = v; return 0;}
   function thread_safe_external_job_hook(r){return r[21];}
   function set_thread_safe_external_job_h(r, v){r[21] = v; return 0;}
   function external_jobs(r){return r[20];}
   function time_source(r){return r[19];}
   function set_time_source(r, v){r[19] = v; return 0;}
   function total_cycle_time(r){return r[18];}
   function set_total_cycle_time(r, v){r[18] = v; return 0;}
   function last_cycle_num_jobs(r){return r[17];}
   function set_last_cycle_num_jobs(r, v){r[17] = v; return 0;}
   function last_cycle_time(r){return r[16];}
   function set_last_cycle_time(r, v){r[16] = v; return 0;}
   function run_every_cycle_end_state(r){return r[15];}
   function run_every_cycle_end(r){return r[14];}
   function set_run_every_cycle_end(r, v){r[14] = v; return 0;}
   function run_every_cycle_start_state(r){return r[13];}
   function run_every_cycle_start(r){return r[12];}
   function set_run_every_cycle_start(r, v){r[12] = v; return 0;}
   function in_cycle(r){return r[11];}
   function set_in_cycle(r, v){r[11] = v; return 0;}
   function cycle_start(r){return r[10];}
   function set_cycle_start(r, v){r[10] = v; return 0;}
   function cycle_count(r){return r[9];}
   function set_cycle_count(r, v){r[9] = v; return 0;}
   function uncaught_exn_unwrapped(r){return r[8];}
   function set_uncaught_exn(r, v){r[8] = v; return 0;}
   function current_execution_context(r){return r[7];}
   function set_current_execution_context(r, v){r[7] = v; return 0;}
   function main_execution_context(r){return r[6];}
   function set_main_execution_context(r, v){r[6] = v; return 0;}
   function very_low_priority_workers(r){return r[5];}
   function low_priority_jobs(r){return r[4];}
   function normal_priority_jobs(r){return r[3];}
   function job_pool(r){return r[2];}
   function set_job_pool(r, v){r[2] = v; return 0;}
   function check_access(r){return r[1];}
   function set_check_access(r, v){r[1] = v; return 0;}
   function _j_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            v];
   }
   var
    _k_ = [0, set_record_backtraces],
    record_backtraces$0 =
      [0,
       function(param){return 0;},
       cst_record_backtraces,
       _k_,
       record_backtraces,
       _j_];
   function _l_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            v,
            r[28]];
   }
   var
    _m_ = [0, set_max_num_jobs_per_priority_],
    max_num_jobs_per_priority_per_$0 =
      [0,
       function(param){return 0;},
       cst_max_num_jobs_per_priority_,
       _m_,
       max_num_jobs_per_priority_per_,
       _l_];
   function _n_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            v,
            r[27],
            r[28]];
   }
   var
    _o_ = [0, set_check_invariants],
    check_invariants$0 =
      [0,
       function(param){return 0;},
       cst_check_invariants,
       _o_,
       check_invariants,
       _n_];
   function _p_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            v,
            r[26],
            r[27],
            r[28]];
   }
   var
    _q_ = [0, set_yield_until_no_jobs_remain],
    yield_until_no_jobs_remain$0 =
      [0,
       function(param){return 0;},
       cst_yield_until_no_jobs_remain,
       _q_,
       yield_until_no_jobs_remain,
       _p_];
   function _r_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            v,
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _s_ = [0, set_yield],
    yield$1 = [0, function(param){return 0;}, cst_yield, _s_, yield$0, _r_];
   function _t_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            v,
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _u_ = [0, set_event_added_hook],
    event_added_hook$0 =
      [0,
       function(param){return 0;},
       cst_event_added_hook,
       _u_,
       event_added_hook,
       _t_];
   function _v_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            v,
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _w_ = [0, set_job_queued_hook],
    job_queued_hook$0 =
      [0,
       function(param){return 0;},
       cst_job_queued_hook,
       _w_,
       job_queued_hook,
       _v_];
   function _x_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            v,
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _y_ = [0, set_thread_safe_external_job_h],
    thread_safe_external_job_hook$0 =
      [0,
       function(param){return 0;},
       cst_thread_safe_external_job_h,
       _y_,
       thread_safe_external_job_hook,
       _x_];
   function _z_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            v,
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _A_ = 0,
    external_jobs$0 =
      [0,
       function(param){return 0;},
       cst_external_jobs,
       _A_,
       external_jobs,
       _z_];
   function _B_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            v,
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _C_ = [0, set_time_source],
    time_source$0 =
      [0, function(param){return 0;}, cst_time_source, _C_, time_source, _B_];
   function _D_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            v,
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _E_ = [0, set_total_cycle_time],
    total_cycle_time$0 =
      [0,
       function(param){return 0;},
       cst_total_cycle_time,
       _E_,
       total_cycle_time,
       _D_];
   function _F_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            v,
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _G_ = [0, set_last_cycle_num_jobs],
    last_cycle_num_jobs$0 =
      [0,
       function(param){return 0;},
       cst_last_cycle_num_jobs,
       _G_,
       last_cycle_num_jobs,
       _F_];
   function _H_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            v,
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _I_ = [0, set_last_cycle_time],
    last_cycle_time$0 =
      [0,
       function(param){return 0;},
       cst_last_cycle_time,
       _I_,
       last_cycle_time,
       _H_];
   function _J_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            v,
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _K_ = 0,
    run_every_cycle_end_state$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_end_state,
       _K_,
       run_every_cycle_end_state,
       _J_];
   function _L_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            v,
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _M_ = [0, set_run_every_cycle_end],
    run_every_cycle_end$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_end,
       _M_,
       run_every_cycle_end,
       _L_];
   function _N_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            v,
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _O_ = 0,
    run_every_cycle_start_state$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_start_stat,
       _O_,
       run_every_cycle_start_state,
       _N_];
   function _P_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _Q_ = [0, set_run_every_cycle_start],
    run_every_cycle_start$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_start,
       _Q_,
       run_every_cycle_start,
       _P_];
   function _R_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _S_ = [0, set_in_cycle],
    in_cycle$0 =
      [0, function(param){return 0;}, cst_in_cycle, _S_, in_cycle, _R_];
   function _T_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            v,
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _U_ = [0, set_cycle_start],
    cycle_start$0 =
      [0, function(param){return 0;}, cst_cycle_start, _U_, cycle_start, _T_];
   function _V_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _W_ = [0, set_cycle_count],
    cycle_count$0 =
      [0, function(param){return 0;}, cst_cycle_count, _W_, cycle_count, _V_];
   function _X_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _Y_ = [0, set_uncaught_exn],
    uncaught_exn =
      [0,
       function(param){return 0;},
       cst_uncaught_exn,
       _Y_,
       uncaught_exn_unwrapped,
       _X_];
   function _Z_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    ___ = [0, set_current_execution_context],
    current_execution_context$0 =
      [0,
       function(param){return 0;},
       cst_current_execution_context,
       ___,
       current_execution_context,
       _Z_];
   function _$_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _aa_ = [0, set_main_execution_context],
    main_execution_context$0 =
      [0,
       function(param){return 0;},
       cst_main_execution_context,
       _aa_,
       main_execution_context,
       _$_];
   function _ab_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ac_ = 0,
    very_low_priority_workers$0 =
      [0,
       function(param){return 0;},
       cst_very_low_priority_workers,
       _ac_,
       very_low_priority_workers,
       _ab_];
   function _ad_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ae_ = 0,
    low_priority_jobs$0 =
      [0,
       function(param){return 0;},
       cst_low_priority_jobs,
       _ae_,
       low_priority_jobs,
       _ad_];
   function _af_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ag_ = 0,
    normal_priority_jobs$0 =
      [0,
       function(param){return 0;},
       cst_normal_priority_jobs,
       _ag_,
       normal_priority_jobs,
       _af_];
   function _ah_(r, v){
    return [0,
            r[1],
            v,
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ai_ = [0, set_job_pool],
    job_pool$0 =
      [0, function(param){return 0;}, cst_job_pool, _ai_, job_pool, _ah_];
   function _aj_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ak_ = [0, set_check_access],
    check_access$0 =
      [0,
       function(param){return 0;},
       cst_check_access,
       _ak_,
       check_access,
       _aj_];
   function iter$0
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    caml_call1(check_access_fun, check_access$0);
    caml_call1(job_pool_fun, job_pool$0);
    caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0);
    caml_call1(low_priority_jobs_fun, low_priority_jobs$0);
    caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0);
    caml_call1(main_execution_context_fun, main_execution_context$0);
    caml_call1(current_execution_context_fun, current_execution_context$0);
    caml_call1(uncaught_exn_fun, uncaught_exn);
    caml_call1(cycle_count_fun, cycle_count$0);
    caml_call1(cycle_start_fun, cycle_start$0);
    caml_call1(in_cycle_fun, in_cycle$0);
    caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0);
    caml_call1(run_every_cycle_start_state_fu, run_every_cycle_start_state$0);
    caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0);
    caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0);
    caml_call1(last_cycle_time_fun, last_cycle_time$0);
    caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0);
    caml_call1(total_cycle_time_fun, total_cycle_time$0);
    caml_call1(time_source_fun, time_source$0);
    caml_call1(external_jobs_fun, external_jobs$0);
    caml_call1
     (thread_safe_external_job_hook_, thread_safe_external_job_hook$0);
    caml_call1(job_queued_hook_fun, job_queued_hook$0);
    caml_call1(event_added_hook_fun, event_added_hook$0);
    caml_call1(yield_fun, yield$1);
    caml_call1(yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0);
    caml_call1(check_invariants_fun, check_invariants$0);
    caml_call1
     (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0);
    return caml_call1(record_backtraces_fun, record_backtraces$0);
   }
   var
    Fields$0 =
      [0,
       record_backtraces$0,
       max_num_jobs_per_priority_per_$0,
       check_invariants$0,
       yield_until_no_jobs_remain$0,
       yield$1,
       event_added_hook$0,
       job_queued_hook$0,
       thread_safe_external_job_hook$0,
       external_jobs$0,
       time_source$0,
       total_cycle_time$0,
       last_cycle_num_jobs$0,
       last_cycle_time$0,
       run_every_cycle_end_state$0,
       run_every_cycle_end$0,
       run_every_cycle_start_state$0,
       run_every_cycle_start$0,
       in_cycle$0,
       cycle_start$0,
       cycle_count$0,
       uncaught_exn,
       current_execution_context$0,
       main_execution_context$0,
       very_low_priority_workers$0,
       low_priority_jobs$0,
       normal_priority_jobs$0,
       job_pool$0,
       check_access$0,
       iter$0];
   function sexp_of_t$1(param){
    var
     check_access_007 = param[1],
     job_pool_009 = param[2],
     very_low_priority_workers_015 = param[5],
     low_priority_jobs_013 = param[4],
     normal_priority_jobs_011 = param[3],
     main_execution_context_017 = param[6],
     current_execution_context_019 = param[7],
     uncaught_exn_021 = param[8],
     cycle_count_027 = param[9],
     cycle_start_029 = param[10],
     in_cycle_031 = param[11],
     run_every_cycle_start_033 = param[12],
     run_every_cycle_start_state_03 = param[13],
     run_every_cycle_end_037 = param[14],
     run_every_cycle_end_state_039 = param[15],
     last_cycle_time_041 = param[16],
     last_cycle_num_jobs_043 = param[17],
     total_cycle_time_045 = param[18],
     time_source_047 = param[19],
     external_jobs_049 = param[20],
     job_queued_hook_053 = param[22],
     event_added_hook_055 = param[23],
     yield_057 = param[24],
     yield_until_no_jobs_remain_059 = param[25],
     check_invariants_061 = param[26],
     max_num_jobs_per_priority_per_ = param[27],
     record_backtraces_065 = param[28],
     arg_066 = caml_call1(Core[323], record_backtraces_065),
     bnds_006 = [0, [1, [0, _al_, [0, arg_066, 0]]], 0],
     arg_064 =
       caml_call1(Async_kernel_config[6][2], max_num_jobs_per_priority_per_),
     bnds_006$0 = [0, [1, [0, _am_, [0, arg_064, 0]]], bnds_006],
     arg_062 = caml_call1(Core[323], check_invariants_061),
     bnds_006$1 = [0, [1, [0, _an_, [0, arg_062, 0]]], bnds_006$0],
     arg_060 =
       caml_call1(Sexplib0_Sexp_conv[23], yield_until_no_jobs_remain_059),
     bnds_006$2 = [0, [1, [0, _ao_, [0, arg_060, 0]]], bnds_006$1],
     arg_058 = caml_call1(Sexplib0_Sexp_conv[23], yield_057),
     bnds_006$3 = [0, [1, [0, _ap_, [0, arg_058, 0]]], bnds_006$2];
    function _cT_(param){
     function _c3_(_c4_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _c3_);
    }
    var
     arg_056 = caml_call2(Core[515], _cT_, event_added_hook_055),
     bnds_006$4 = [0, [1, [0, _aq_, [0, arg_056, 0]]], bnds_006$3];
    function _cU_(param){
     function _c1_(_c2_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _c1_);
    }
    var
     arg_054 = caml_call2(Core[515], _cU_, job_queued_hook_053),
     bnds_006$5 = [0, [1, [0, _ar_, [0, arg_054, 0]]], bnds_006$4];
    function _cV_(_c0_){return 0;}
    var
     arg_052 = caml_call1(Sexplib0_Sexp_conv[24], _cV_),
     bnds_006$6 = [0, [1, [0, _as_, [0, arg_052, 0]]], bnds_006$5],
     arg_050 =
       caml_call2
        (Thread_safe_queue[1],
         Async_kernel_External_job[1],
         external_jobs_049),
     bnds_006$7 = [0, [1, [0, _at_, [0, arg_050, 0]]], bnds_006$6],
     arg_048 =
       caml_call2
        (Async_kernel_Synchronous_time_[4][17], Core[212], time_source_047),
     bnds_006$8 = [0, [1, [0, _au_, [0, arg_048, 0]]], bnds_006$7],
     arg_046 = caml_call1(Core_Time_ns[1][10], total_cycle_time_045),
     bnds_006$9 = [0, [1, [0, _av_, [0, arg_046, 0]]], bnds_006$8],
     arg_044 = caml_call1(Core[389], last_cycle_num_jobs_043),
     bnds_006$10 = [0, [1, [0, _aw_, [0, arg_044, 0]]], bnds_006$9],
     arg_042 = caml_call1(Core_Time_ns[1][10], last_cycle_time_041),
     bnds_006$11 = [0, [1, [0, _ax_, [0, arg_042, 0]]], bnds_006$10],
     arg_040 =
       caml_call3
        (Core_Hashtbl[3],
         Async_kernel_Types[20][10],
         Sexplib0_Sexp_conv[23],
         run_every_cycle_end_state_039),
     bnds_006$12 = [0, [1, [0, _ay_, [0, arg_040, 0]]], bnds_006$11],
     arg_038 =
       caml_call2(Core[301], Sexplib0_Sexp_conv[23], run_every_cycle_end_037),
     bnds_006$13 = [0, [1, [0, _az_, [0, arg_038, 0]]], bnds_006$12],
     arg_036 =
       caml_call3
        (Core_Hashtbl[3],
         Async_kernel_Types[20][10],
         Sexplib0_Sexp_conv[23],
         run_every_cycle_start_state_03),
     bnds_006$14 = [0, [1, [0, _aA_, [0, arg_036, 0]]], bnds_006$13],
     arg_034 =
       caml_call2
        (Core[301], Sexplib0_Sexp_conv[23], run_every_cycle_start_033),
     bnds_006$15 = [0, [1, [0, _aB_, [0, arg_034, 0]]], bnds_006$14],
     arg_032 = caml_call1(Core[323], in_cycle_031),
     bnds_006$16 = [0, [1, [0, _aC_, [0, arg_032, 0]]], bnds_006$15],
     arg_030 = caml_call1(Async_kernel_Time_ns[98], cycle_start_029),
     bnds_006$17 = [0, [1, [0, _aD_, [0, arg_030, 0]]], bnds_006$16],
     arg_028 = caml_call1(Core[389], cycle_count_027),
     bnds_006$18 = [0, [1, [0, _aE_, [0, arg_028, 0]]], bnds_006$17];
    function _cW_(param){
     var
      arg1_024 = param[2],
      arg0_023 = param[1],
      res0_025 = caml_call1(Base_Exn[1], arg0_023),
      res1_026 = caml_call1(Core_Sexp[93], arg1_024);
     return [1, [0, res0_025, [0, res1_026, 0]]];
    }
    var
     arg_022 = caml_call2(Core[515], _cW_, uncaught_exn_021),
     bnds_006$19 = [0, [1, [0, _aF_, [0, arg_022, 0]]], bnds_006$18],
     arg_020 =
       caml_call1
        (Async_kernel_Execution_context[5], current_execution_context_019),
     bnds_006$20 = [0, [1, [0, _aG_, [0, arg_020, 0]]], bnds_006$19],
     arg_018 =
       caml_call1
        (Async_kernel_Execution_context[5], main_execution_context_017),
     bnds_006$21 = [0, [1, [0, _aH_, [0, arg_018, 0]]], bnds_006$20],
     arg_016 =
       caml_call2
        (Core_Deque[10],
         Very_low_priority_worker[5],
         very_low_priority_workers_015),
     bnds_006$22 = [0, [1, [0, _aI_, [0, arg_016, 0]]], bnds_006$21],
     arg_014 = caml_call1(Async_kernel_Job_queue[1], low_priority_jobs_013),
     bnds_006$23 = [0, [1, [0, _aJ_, [0, arg_014, 0]]], bnds_006$22],
     arg_012 = caml_call1(Async_kernel_Job_queue[1], normal_priority_jobs_011),
     bnds_006$24 = [0, [1, [0, _aK_, [0, arg_012, 0]]], bnds_006$23],
     arg_010 = caml_call1(Async_kernel_Job_pool[2], job_pool_009),
     bnds_006$25 = [0, [1, [0, _aL_, [0, arg_010, 0]]], bnds_006$24];
    function _cX_(param){
     function _cY_(_cZ_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _cY_);
    }
    var
     arg_008 = caml_call2(Core[515], _cX_, check_access_007),
     bnds_006$26 = [0, [1, [0, _aM_, [0, arg_008, 0]]], bnds_006$25];
    return [1, bnds_006$26];
   }
   function uncaught_exn$0(t){
    var _cR_ = t[8];
    if(! _cR_) return 0;
    var match = _cR_[1], sexp = match[2], exn = match[1];
    function _cS_(param){
     var
      arg1_068 = param[2],
      arg0_067 = param[1],
      res0_069 = caml_call1(Base_Exn[1], arg0_067),
      res1_070 = caml_call1(Core_Sexp[93], arg1_068);
     return [1, [0, res0_069, [0, res1_070, 0]]];
    }
    return [0,
            caml_call5
             (Core_Error[19],
              0,
              0,
              cst_unhandled_exception,
              [0, exn, sexp],
              _cS_)];
   }
   function num_pending_jobs(t){
    var _cQ_ = caml_call1(Async_kernel_Job_queue[8], t[4]);
    return caml_call1(Async_kernel_Job_queue[8], t[3]) + _cQ_ | 0;
   }
   function num_jobs_run(t){
    var _cP_ = caml_call1(Async_kernel_Job_queue[10], t[4]);
    return caml_call1(Async_kernel_Job_queue[10], t[3]) + _cP_ | 0;
   }
   function last_cycle_num_jobs$1(t){return t[17];}
   function unordered_is_sublist(equal, small, large){
    var large$0 = caml_call1(Core_Array[45], large);
    function _cK_(acc, x){
     function _cM_(l$0){
      function _cN_(y){return 1 - caml_call2(equal, y, x);}
      var
       _cO_ = caml_call2(Core_List[138], l$0, _cN_),
       match = _cO_[2],
       l = _cO_[1];
      if(! match) return 0;
      var r = match[2];
      return [0, caml_call2(Core[156], l, r)];
     }
     return caml_call2(Core_Option[32], acc, _cM_);
    }
    var _cL_ = caml_call3(Core_List[20], small, [0, large$0], _cK_);
    return caml_call1(Core_Option[62], _cL_);
   }
   function check_hook_table_invariant(table, array){
    var _cH_ = caml_call1(Core_Hashtbl[68], table);
    if
     (unordered_is_sublist
       (function(_cJ_, _cI_){return _cJ_ === _cI_ ? 1 : 0;}, _cH_, array))
     return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aN_], 1);
   }
   function invariant$0(t){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, t));
        },
      _bz_ = function(_cG_){return 0;},
      _bA_ = function(_cF_){return 0;},
      _bB_ = function(_cE_){return 0;},
      _bC_ = function(_cD_){return 0;},
      _bD_ = function(_cC_){return 0;},
      _bE_ = function(_cB_){return 0;},
      _bF_ = function(_cA_){return 0;},
      _bG_ = function(_cz_){return 0;},
      _bH_ = function(_cy_){return 0;},
      _bI_ =
        function(job){
         if(caml_call2(Tuple_pool[6], t[2], job)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
        },
      _bJ_ = caml_call1(Async_kernel_Synchronous_time_[8][3], _bI_),
      _bK_ = function(_cx_){return check(_bJ_, _cx_);},
      _bL_ = function(_cw_){return 0;},
      _bM_ =
        function(last_cycle_num_jobs){
         if(caml_call2(Async_kernel_Import[1], last_cycle_num_jobs, 0))
          return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aR_], 1);
        },
      _bN_ = function(_cv_){return check(_bM_, _cv_);},
      _bO_ = function(_cu_){return 0;},
      _bP_ =
        function(run_every_cycle_end_state){
         return check_hook_table_invariant(run_every_cycle_end_state, t[14]);
        },
      _bQ_ = function(_ct_){return check(_bP_, _ct_);},
      _bR_ = function(_cs_){return 0;},
      _bS_ =
        function(run_every_cycle_start_state){
         return check_hook_table_invariant(run_every_cycle_start_state, t[12]);
        },
      _bT_ = function(_cr_){return check(_bS_, _cr_);},
      _bU_ = function(_cq_){return 0;},
      _bV_ = function(_cp_){return 0;},
      _bW_ = function(_co_){return 0;},
      _bX_ =
        function(cycle_count){
         if(caml_call2(Async_kernel_Import[1], cycle_count, 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
        },
      _bY_ = function(_cn_){return check(_bX_, _cn_);},
      _bZ_ =
        function(uncaught_exn){
         var _cl_ = caml_call1(Core[253], uncaught_exn);
         if(! _cl_) return _cl_;
         var _cm_ = num_pending_jobs(t);
         if(caml_call2(Async_kernel_Import[3], _cm_, 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aT_], 1);
        },
      _b0_ = function(_ck_){return check(_bZ_, _ck_);},
      _b1_ = Async_kernel_Execution_context[6],
      _b2_ = function(_cj_){return check(_b1_, _cj_);},
      _b3_ = Async_kernel_Execution_context[6],
      _b4_ = function(_ci_){return check(_b3_, _ci_);},
      _b5_ =
        function(q){
         return caml_call2(Core_Deque[17], q, Very_low_priority_worker[6]);
        },
      _b6_ = function(_ch_){return check(_b5_, _ch_);},
      _b7_ = Async_kernel_Job_queue[2],
      _b8_ = function(_cg_){return check(_b7_, _cg_);},
      _b9_ = Async_kernel_Job_queue[2],
      _b__ = function(_cf_){return check(_b9_, _cf_);},
      _b$_ = Async_kernel_Job_pool[3],
      _ca_ = function(_ce_){return check(_b$_, _ce_);},
      _cb_ = function(_cd_){return 0;},
      _cc_ =
        caml_call28
         (Fields$0[29],
          _cb_,
          _ca_,
          _b__,
          _b8_,
          _b6_,
          _b4_,
          _b2_,
          _b0_,
          _bY_,
          _bW_,
          _bV_,
          _bU_,
          _bT_,
          _bR_,
          _bQ_,
          _bO_,
          _bN_,
          _bL_,
          _bK_,
          _bH_,
          _bG_,
          _bF_,
          _bE_,
          _bD_,
          _bC_,
          _bB_,
          _bA_,
          _bz_);
     return _cc_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _bw_ = [0, [1, [0, _aO_, [0, sexp_of_t$1(t), 0]]], 0],
      _bx_ = [0, [1, [0, _aP_, [0, caml_call1(Core[625], exn), 0]]], _bw_],
      _by_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_invariant_failed),
          _bx_]];
     return caml_call1(Core[261], _by_);
    }
   }
   function free_job(t, job){return caml_call2(Tuple_pool[15], t[2], job);}
   function enqueue(t, execution_context, f, a){
    var _bu_ = caml_call1(Core[252], t[8]);
    if(_bu_){
     var priority = execution_context[2], job_queue = priority ? t[4] : t[3];
     caml_call4(Async_kernel_Job_queue[4], job_queue, execution_context, f, a);
     var match = t[22];
     if(match){var f$0 = match[1]; return caml_call1(f$0, priority);}
     var _bv_ = 0;
    }
    else
     var _bv_ = _bu_;
    return _bv_;
   }
   function enqueue_job(t, job, free_job){
    var
     job_pool = t[2],
     _bs_ = caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][5]),
     _bt_ = caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][4]);
    enqueue
     (t,
      caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][3]),
      _bt_,
      _bs_);
    return free_job ? caml_call2(Tuple_pool[15], t[2], job) : free_job;
   }
   function handle_fired(time_source, job_or_event){
    var
     k = caml_call1(Async_kernel_Synchronous_time_[4][2][5][1], job_or_event),
     match =
       caml_call2(Async_kernel_Synchronous_time_[4][2][5][2], k, job_or_event);
    return k
            ? enqueue_job(time_source[9], match, 1)
            : caml_call2
              (Async_kernel_Synchronous_time_[14], time_source, match);
   }
   function create$1(param){
    var
     now = caml_call1(Async_kernel_Time_ns[42], 0),
     t = [],
     time_source = [],
     events = caml_call2(Timing_wheel[9], Async_kernel_config[33], now),
     _a5_ = Async_kernel_config[31],
     _a6_ = Async_kernel_config[27],
     _a7_ = Async_kernel_config[18],
     _a8_ = caml_call1(Bvar[1], 0),
     _a9_ = caml_call1(Bvar[1], 0),
     _a__ = 0,
     _a$_ = 0;
    function _ba_(_br_){return 0;}
    var
     _bb_ = caml_call1(Thread_safe_queue[3], 0),
     _bc_ = caml_call1(Async_kernel_Import[16], 0.),
     _bd_ = caml_call1(Async_kernel_Import[16], 0.),
     _be_ = Async_kernel_Types[20],
     _bf_ =
       caml_call3(Core_Hashtbl[4], 0, 0, [0, _be_[20], _be_[10], _be_[36]]),
     _bg_ = Async_kernel_Types[20],
     _bh_ =
       caml_call3(Core_Hashtbl[4], 0, 0, [0, _bg_[20], _bg_[10], _bg_[36]]),
     _bi_ = Async_kernel_Execution_context[7],
     _bj_ = Async_kernel_Execution_context[7],
     _bk_ = caml_call3(Core_Deque[31], 0, 0, 0),
     _bl_ = caml_call1(Async_kernel_Job_queue[3], 0),
     _bm_ = caml_call1(Async_kernel_Job_queue[3], 0);
    caml_update_dummy
     (t,
      [0,
       0,
       caml_call1(Async_kernel_Job_pool[4], 0),
       _bm_,
       _bl_,
       _bk_,
       _bj_,
       _bi_,
       0,
       0,
       now,
       0,
       [0],
       _bh_,
       [0],
       _bf_,
       _bd_,
       0,
       _bc_,
       time_source,
       _bb_,
       _ba_,
       _a$_,
       _a__,
       _a9_,
       _a8_,
       _a7_,
       _a6_,
       _a5_]);
    var _bn_ = 1;
    function _bo_(alarm){
     return handle_fired
             (time_source, caml_call2(Timing_wheel[5][5], events, alarm));
    }
    var
     _bp_ = Async_kernel_Synchronous_time_[22][3][2],
     _bq_ = Async_kernel_Synchronous_time_[22][3][2];
    caml_update_dummy
     (time_source,
      [0,
       caml_call1(Async_kernel_Types[21][45], 0),
       0,
       0,
       events,
       _bq_,
       _bp_,
       _bo_,
       _bn_,
       t]);
    return t;
   }
   function is_dead(t){return caml_call1(Core[253], t[8]);}
   function set_check_access$0(t, f){t[1] = f; return 0;}
   function backtrace_of_first_job(t){
    var
     _a3_ = caml_call1(Async_kernel_Job_queue[11], t[4]),
     _a4_ = caml_call1(Async_kernel_Job_queue[11], t[3]);
    return caml_call2(Core_Option[59], _a4_, _a3_);
   }
   var match = caml_call1(Core_Result[54], create$1);
   if(0 === match[0])
    var t = match[1], t_ref = [0, t];
   else{
    var exn = match[1];
    caml_call3
     (Async_kernel_Debug[15], cst_Async_cannot_create_its_ra, exn, Core[625]);
    var t_ref = caml_call1(Core[83], 1);
   }
   function check_access$1(t){
    var match = t[1];
    if(! match) return 0;
    var f = match[1];
    return caml_call1(f, 0);
   }
   function t$0(param){var t = t_ref[1]; check_access$1(t); return t;}
   function current_execution_context$1(t){
    return t[28] ? caml_call1(Async_kernel_Execution_context[11], t[7]) : t[7];
   }
   function with_execution_context1(t, tmp_context, f, x){
    var old_context = current_execution_context$1(t);
    caml_call2(set_execution_context, t, tmp_context);
    function _a2_(param){
     return caml_call2(set_execution_context, t, old_context);
    }
    return caml_call3(Core[260], f, x, _a2_);
   }
   function with_execution_context(t, tmp_context, f){
    return with_execution_context1(t, tmp_context, f, 0);
   }
   function create_job(t, execution_context, f, a){
    if(caml_call1(Tuple_pool[14], t[2]))
     t[2] = caml_call2(Tuple_pool[13], 0, t[2]);
    return caml_call4(Tuple_pool[19], t[2], execution_context, f, a);
   }
   function got_uncaught_exn(t, exn, sexp){
    if(debug){
     var
      _a1_ =
        function(param){
         var
          arg1_072 = param[2],
          arg0_071 = param[1],
          res0_073 = caml_call1(Base_Exn[1], arg0_071),
          res1_074 = caml_call1(Core_Sexp[93], arg1_072);
         return [1, [0, res0_073, [0, res1_074, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15], cst_got_uncaught_exn, [0, exn, sexp], _a1_);
    }
    caml_call2
     (Core_List[19], [0, t[3], [0, t[4], 0]], Async_kernel_Job_queue[5]);
    t[8] = [0, [0, exn, sexp]];
    return 0;
   }
   function start_cycle(t, max_num_jobs_per_priority){
    var n = caml_call1(Async_kernel_config[6][5], max_num_jobs_per_priority);
    caml_call2(Async_kernel_Job_queue[6], t[3], n);
    return caml_call2(Async_kernel_Job_queue[6], t[4], n);
   }
   function run_jobs(t){
    for(;;){
     var e = caml_call2(Async_kernel_Job_queue[9], t[3], t);
     if(0 !== e[0]) return e;
     var e$0 = caml_call2(Async_kernel_Job_queue[9], t[4], t);
     if(0 !== e$0[0]) return e$0;
     if
      (!
       caml_call1(Async_kernel_Job_queue[7], t[3])
       && ! caml_call1(Async_kernel_Job_queue[7], t[4]))
      return _aU_;
    }
   }
   function stabilize(t){
    start_cycle(t, caml_call1(Async_kernel_config[6][4], Core_Int[45]));
    var match = run_jobs(t);
    if(0 === match[0]) return _aV_;
    var exn = match[1][1];
    return [1, exn];
   }
   function create_time_source(opt, now, param){
    if(opt)
     var sth = opt[1], timing_wheel_config = sth;
    else
     var timing_wheel_config = Async_kernel_config[33];
    var
     t = t$0(0),
     events = caml_call2(Timing_wheel[9], timing_wheel_config, now),
     time_source = [],
     _aX_ = 0;
    function _aY_(alarm){
     return handle_fired
             (time_source, caml_call2(Timing_wheel[5][5], events, alarm));
    }
    var
     _aZ_ = Async_kernel_Synchronous_time_[22][3][2],
     _a0_ = Async_kernel_Synchronous_time_[22][3][2];
    caml_update_dummy
     (time_source,
      [0,
       caml_call1(Async_kernel_Types[21][45], 0),
       0,
       0,
       events,
       _a0_,
       _aZ_,
       _aY_,
       _aX_,
       t]);
    return time_source;
   }
   function wall_clock(param){
    var _aW_ = t$0(0)[19];
    return caml_call1(Async_kernel_Synchronous_time_[13], _aW_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler1);
   var
    Async_kernel_Scheduler1 =
      [0,
       events,
       set_execution_context,
       debug,
       Ivar,
       Bvar,
       Very_low_priority_worker,
       record_backtraces,
       set_record_backtraces,
       max_num_jobs_per_priority_per_,
       set_max_num_jobs_per_priority_,
       check_invariants,
       set_check_invariants,
       yield_until_no_jobs_remain,
       set_yield_until_no_jobs_remain,
       yield$0,
       set_yield,
       event_added_hook,
       set_event_added_hook,
       job_queued_hook,
       set_job_queued_hook,
       thread_safe_external_job_hook,
       set_thread_safe_external_job_h,
       external_jobs,
       time_source,
       set_time_source,
       total_cycle_time,
       set_total_cycle_time,
       set_last_cycle_num_jobs,
       last_cycle_time,
       set_last_cycle_time,
       run_every_cycle_end_state,
       run_every_cycle_end,
       set_run_every_cycle_end,
       run_every_cycle_start_state,
       run_every_cycle_start,
       set_run_every_cycle_start,
       in_cycle,
       set_in_cycle,
       cycle_start,
       set_cycle_start,
       cycle_count,
       set_cycle_count,
       set_uncaught_exn,
       set_current_execution_context,
       main_execution_context,
       set_main_execution_context,
       very_low_priority_workers,
       low_priority_jobs,
       normal_priority_jobs,
       job_pool,
       set_job_pool,
       Fields$0,
       sexp_of_t$1,
       uncaught_exn_unwrapped,
       uncaught_exn$0,
       num_pending_jobs,
       num_jobs_run,
       last_cycle_num_jobs$1,
       unordered_is_sublist,
       check_hook_table_invariant,
       invariant$0,
       free_job,
       enqueue,
       enqueue_job,
       handle_fired,
       create$1,
       is_dead,
       set_check_access$0,
       backtrace_of_first_job,
       t_ref,
       check_access$1,
       t$0,
       current_execution_context$1,
       with_execution_context1,
       with_execution_context,
       create_job,
       got_uncaught_exn,
       start_cycle,
       run_jobs,
       stabilize,
       create_time_source,
       wall_clock];
   runtime.caml_register_global
    (119, Async_kernel_Scheduler1, cst_Async_kernel_Scheduler1$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar0
//# unitInfo: Requires: Async_kernel__Execution_context, Async_kernel__Scheduler1, Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar0$0 = "Async_kernel__Ivar0",
    cst_async_kernel$0 = "async_kernel",
    cst_src_ivar0_ml = "src/ivar0.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_ivar0_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "ivar0.ml");
   var
    _q_ = [0, cst_src_ivar0_ml, 452, 21],
    _r_ = [0, cst_src_ivar0_ml, 448, 35],
    _p_ = [0, cst_src_ivar0_ml, 385, 15],
    _o_ = [0, cst_src_ivar0_ml, 364, 15],
    _n_ = [0, cst_src_ivar0_ml, 342, 15],
    _m_ = [0, cst_src_ivar0_ml, 323, 15],
    _j_ = [0, "_"],
    _k_ = [0, "t"],
    cst_Ivar_fill_exn_called_on_fu = "Ivar.fill_exn called on full ivar",
    _l_ = [0, cst_src_ivar0_ml, 306, 15],
    _i_ = [0, cst_src_ivar0_ml, 296, 15],
    cst_Ivar_value_exn_called_on_e = "Ivar.value_exn called on empty ivar",
    _h_ = [0, cst_src_ivar0_ml, 285, 15],
    _g_ = [0, cst_src_ivar0_ml, 277, 15],
    _e_ = [0, "Full"],
    _f_ = [0, cst_src_ivar0_ml, 269, 15],
    _d_ = [0, "Empty"],
    _c_ = [0, cst_src_ivar0_ml, 258, 15],
    _b_ = [0, "execution_context"],
    _a_ = [0, cst_src_ivar0_ml, 118, 6],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Ivar0 = cst_Async_kernel_Ivar0$0;
   function set_prev(param, x){param[3] = x; return 0;}
   function set_next(param, x){param[4] = x; return 0;}
   function create(run, execution_context){
    var t = [0, run, execution_context, 0, 0];
    set_prev(t, t);
    set_next(t, t);
    return t;
   }
   function create2(run1, execution_context1, run2, execution_context2){
    var
     t1 = [0, run1, execution_context1, 0, 0],
     t2 = [0, run2, execution_context2, t1, t1];
    set_prev(t1, t2);
    set_next(t1, t2);
    return t1;
   }
   function length(t){
    var n = [0, 1], r = [0, t[4]];
    for(;;){if(r[1] === t) return n[1]; n[1]++; r[1] = r[1][4];}
   }
   function enqueue(t, scheduler, v){
    return caml_call4(Async_kernel_Scheduler1[63], scheduler, t[2], t[1], v);
   }
   function schedule_jobs(t, v){
    var scheduler = caml_call1(Async_kernel_Scheduler1[72], 0);
    enqueue(t, scheduler, v);
    var r = [0, t[4]];
    for(;;){
     if(r[1] === t) return 0;
     enqueue(r[1], scheduler, v);
     r[1] = r[1][4];
    }
   }
   function add(t, run, execution_context){
    var result = [0, run, execution_context, t[3], t];
    set_next(t[3], result);
    set_prev(t, result);
    return result;
   }
   function of_list(l){
    if(! l) return 0;
    var
     l$0 = l[2],
     match = l[1],
     execution_context = match[2],
     run = match[1],
     first = create(run, execution_context),
     prev = first,
     l$1 = l$0;
    for(;;){
     if(! l$1){set_prev(first, prev); return [0, first];}
     var
      l$2 = l$1[2],
      match$0 = l$1[1],
      execution_context$0 = match$0[2],
      run$0 = match$0[1],
      prev$0 = [0, run$0, execution_context$0, prev, first];
     set_next(prev, prev$0);
     var prev = prev$0, l$1 = l$2;
    }
   }
   function to_list(first){
    var t$1 = first[3], t = t$1, acc = 0;
    for(;;){
     var acc$0 = [0, [0, t[1], t[2]], acc];
     if(t === first) return acc$0;
     var t$0 = t[3], t = t$0, acc = acc$0;
    }
   }
   function sexp_of_t(param, t){
    var execution_context = t[2];
    return [1,
            [0,
             _b_,
             [0,
              caml_call1(Async_kernel_Execution_context[5], execution_context),
              0]]];
   }
   function cell_of_handler(x){return x;}
   function equal(t$0, t){return t$0 === t ? 1 : 0;}
   function indir(t){return [0, [3, t]];}
   var
    include = Async_kernel_Scheduler1[4],
    create_with_cell = include[1],
    create$0 = include[2],
    create_full = include[3];
   function squash(t$3){
    var match$0 = t$3[1];
    if(typeof match$0 !== "number" && 3 === match$0[0]){
     var t$4 = match$0[1], indir$1 = t$4[1];
     if(typeof indir$1 !== "number" && 3 === indir$1[0]){
      var t$5 = indir$1[1];
      a:
      {
       var indir = indir$1, t = t$5;
       for(;;){
        var indir$0 = t[1];
        if(typeof indir$0 === "number") break;
        if(3 !== indir$0[0]) break a;
        var t$0 = indir$0[1], indir = indir$0, t = t$0;
       }
      }
      var t$1 = t$3;
      for(;;){
       var match = t$1[1];
       if(typeof match !== "number" && 3 === match[0]){
        var t$2 = match[1];
        t$1[1] = indir;
        var t$1 = t$2;
        continue;
       }
       return t$1;
      }
     }
     return t$4;
    }
    return t$3;
   }
   function invariant(a_invariant, t){
    var t$0 = squash(t), handler = t$0[1];
    if(typeof handler === "number") return 0;
    switch(handler[0]){
      case 0:
       caml_call1(Async_kernel_Execution_context[6], handler[2]);
       var r = [0, handler[4]];
       for(;;){
        if(r[1] === handler) return 0;
        var t1 = r[1];
        if(t1[4][3] !== t1)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        caml_call1(Async_kernel_Execution_context[6], t1[2]);
        r[1] = r[1][4];
       }
       break;
      case 1:
       var execution_context = handler[2];
       return caml_call1(Async_kernel_Execution_context[6], execution_context);
      case 2:
       var a = handler[1]; return caml_call1(a_invariant, a);
      default: throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
   }
   function sexp_of_t$0(sexp_of_a, t){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1];
        return [1, [0, _e_, [0, caml_call1(sexp_of_a, a), 0]]];
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
    return _d_;
   }
   function peek(t){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1]; return [0, a];
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
    return 0;
   }
   function value(t, if_empty_then_failwith){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1]; return a;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     }
    return caml_call1(Core[6], if_empty_then_failwith);
   }
   function value_exn(t){return value(t, cst_Ivar_value_exn_called_on_e);}
   function is_empty(t){
    var t$0 = squash(t), _D_ = t$0[1];
    if(typeof _D_ !== "number")
     switch(_D_[0]){
       case 2:
        return 0;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
    return 1;
   }
   function is_full(t){return 1 - is_empty(t);}
   function fill_exn(t, v){
    var x_001 = squash(t), handler = x_001[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        x_001[1] = [2, v]; return schedule_jobs(handler, v);
       case 1:
        var execution_context = handler[2], run = handler[1];
        x_001[1] = [2, v];
        var _y_ = caml_call1(Async_kernel_Scheduler1[72], 0);
        return caml_call3
                (caml_call1(Async_kernel_Scheduler1[63], _y_),
                 execution_context,
                 run,
                 v);
       case 2:
        var
         _z_ = 0,
         _A_ = 0,
         _B_ =
           [0,
            [1,
             [0,
              _k_,
              [0, sexp_of_t$0(function(param){return _j_;}, x_001), _A_]]],
            _z_],
         _C_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_Ivar_fill_exn_called_on_fu),
             _B_]];
        return caml_call1(Core[261], _C_);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     }
    x_001[1] = [2, v];
    return 0;
   }
   function remove_handler(t, handler){
    function x(_x_){return 0;}
    handler[1] = x;
    var t$0 = squash(t), cell = t$0[1];
    if(typeof cell !== "number")
     switch(cell[0]){
       case 0:
        if(handler === handler[4]){t$0[1] = 0; return 0;}
        if(handler === cell) t$0[1] = handler[4];
        set_prev(handler[4], handler[3]);
        set_next(handler[3], handler[4]);
        set_prev(handler, handler);
        return set_next(handler, handler);
       case 2:
        return 0;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     }
    return 0;
   }
   function add_handler(t, run, execution_context){
    var t$0 = squash(t), handler = t$0[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        return add(handler, run, execution_context);
       case 1:
        var
         execution_context$0 = handler[2],
         run$0 = handler[1],
         handler$1 =
           create2(run, execution_context, run$0, execution_context$0);
        t$0[1] = handler$1;
        return handler$1;
       case 2:
        var
         v = handler[1],
         handler$2 = create(run, execution_context),
         run$1 = function(v){return caml_call1(handler$2[1], v);},
         _w_ = caml_call1(Async_kernel_Scheduler1[72], 0);
        caml_call3
         (caml_call1(Async_kernel_Scheduler1[63], _w_),
          execution_context,
          run$1,
          v);
        return handler$2;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
     }
    var handler$0 = create(run, execution_context);
    t$0[1] = handler$0;
    return handler$0;
   }
   function has_handlers(t){
    var t$0 = squash(t), _v_ = t$0[1];
    if(typeof _v_ !== "number")
     switch(_v_[0]){
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
       case 2: break;
       default: return 1;
     }
    return 0;
   }
   function upon(t, run){
    var _u_ = caml_call1(Async_kernel_Scheduler1[72], 0);
    return add_handler(t, run, caml_call1(Async_kernel_Scheduler1[73], _u_));
   }
   function upon$0(t, run){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], scheduler),
     t$0 = squash(t),
     handler = t$0[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        add(handler, run, execution_context); return 0;
       case 1:
        var execution_context$0 = handler[2], run$0 = handler[1];
        t$0[1] = create2(run, execution_context, run$0, execution_context$0);
        return 0;
       case 2:
        var v = handler[1];
        return caml_call4
                (Async_kernel_Scheduler1[63],
                 scheduler,
                 execution_context,
                 run,
                 v);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
     }
    t$0[1] = [1, run, execution_context];
    return 0;
   }
   function connect(bind_result, bind_rhs){
    var _s_ = 1 - (bind_result === bind_rhs ? 1 : 0);
    if(! _s_) return _s_;
    var bind_result$0 = squash(bind_result), indir = [3, bind_result$0];
    a:
    {
     b:
     c:
     {
      var ivar = bind_rhs;
      d:
      for(;;){
       var bind_rhs_contents = ivar[1];
       if(typeof bind_rhs_contents === "number") break c;
       switch(bind_rhs_contents[0]){
         case 2:
          break d;
         case 3:
          var ivar$0 = bind_rhs_contents[1];
          ivar[1] = indir;
          var ivar = ivar$0;
          break;
         default: break b;
       }
      }
      break a;
     }
     if(1 - (ivar === bind_result$0 ? 1 : 0)) ivar[1] = indir;
    }
    var t1 = bind_result$0[1];
    a:
    {
     b:
     {
      if(typeof t1 !== "number")
       switch(t1[0]){
         case 0:
          if(typeof bind_rhs_contents === "number") break a;
          switch(bind_rhs_contents[0]){
            case 0:
             var last1 = t1[3], last2 = bind_rhs_contents[3];
             set_next(last1, bind_rhs_contents);
             set_next(last2, t1);
             set_prev(t1, last2);
             return set_prev(bind_rhs_contents, last1);
            case 1:
             var
              execution_context2 = bind_rhs_contents[2],
              run2 = bind_rhs_contents[1];
             add(t1, run2, execution_context2);
             return 0;
            case 2:
             var v = bind_rhs_contents[1];
             bind_result$0[1] = bind_rhs_contents;
             return schedule_jobs(t1, v);
          }
          break;
         case 1:
          var execution_context = t1[2], run = t1[1];
          if(typeof bind_rhs_contents === "number") break a;
          switch(bind_rhs_contents[0]){
            case 0:
             var handler1 = add(bind_rhs_contents, run, execution_context);
             bind_result$0[1] = handler1;
             return 0;
            case 1:
             var
              execution_context2$0 = bind_rhs_contents[2],
              run2$0 = bind_rhs_contents[1],
              handler1$0 =
                create2(run, execution_context, run2$0, execution_context2$0);
             bind_result$0[1] = handler1$0;
             return 0;
            case 2:
             var v$0 = bind_rhs_contents[1];
             bind_result$0[1] = bind_rhs_contents;
             var _t_ = caml_call1(Async_kernel_Scheduler1[72], 0);
             return caml_call3
                     (caml_call1(Async_kernel_Scheduler1[63], _t_),
                      execution_context,
                      run,
                      v$0);
          }
          break;
         case 2: break;
         default: break b;
       }
      if(typeof bind_rhs_contents !== "number" && 3 === bind_rhs_contents[0])
       break b;
      if(typeof t1 === "number") break a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
    }
    return typeof bind_rhs_contents === "number"
            ? 0
            : (bind_result$0[1] = bind_rhs_contents, 0);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar0);
   var
    Async_kernel_Ivar0 =
      [0,
       sexp_of_t$0,
       invariant,
       create$0,
       create_full,
       create_with_cell,
       peek,
       value_exn,
       value,
       is_empty,
       is_full,
       equal,
       connect,
       fill_exn,
       fill_exn,
       [0, sexp_of_t, length, of_list, to_list],
       cell_of_handler,
       add_handler,
       remove_handler,
       has_handlers,
       upon$0,
       upon,
       indir,
       squash];
   runtime.caml_register_global
    (36, Async_kernel_Ivar0, cst_Async_kernel_Ivar0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred0
//# unitInfo: Requires: Async_kernel__Ivar0, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred0$0 = "Async_kernel__Deferred0",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Ivar0 = global_data.Async_kernel__Ivar0,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred0.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred0.ml");
   var
    cst_Deferred_value_exn_called_ =
      "Deferred.value_exn called on undetermined deferred",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred0 = cst_Async_kernel_Deferred0$0;
   function of_ivar(ivar){return ivar;}
   function invariant(invariant_a, t){
    return caml_call2(Async_kernel_Ivar0[2], invariant_a, t);
   }
   function sexp_of_t(sexp_of_a, t){
    return caml_call2(Async_kernel_Ivar0[1], sexp_of_a, t);
   }
   function peek(t){return caml_call1(Async_kernel_Ivar0[6], t);}
   function return$0(a){return caml_call1(Async_kernel_Ivar0[4], a);}
   function is_determined(t){return caml_call1(Async_kernel_Ivar0[10], t);}
   function value_exn(t){
    return caml_call2
            (Async_kernel_Ivar0[8], t, cst_Deferred_value_exn_called_);
   }
   function upon(t, f){return caml_call2(Async_kernel_Ivar0[20], t, f);}
   function create(f){
    var result = caml_call1(Async_kernel_Ivar0[3], 0);
    caml_call1(f, result);
    return result;
   }
   function bind(t, f){
    var bind_result = caml_call1(Async_kernel_Ivar0[3], 0);
    upon
     (t,
      function(a){
       var _a_ = caml_call1(f, a);
       return caml_call2(Async_kernel_Ivar0[12], bind_result, _a_);
      });
    return bind_result;
   }
   function add_handler(t, f, execution_context){
    return caml_call3(Async_kernel_Ivar0[17], t, f, execution_context);
   }
   function remove_handler(t, h){
    return caml_call2(Async_kernel_Ivar0[18], t, h);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred0);
   var
    Async_kernel_Deferred0 =
      [0,
       sexp_of_t,
       invariant,
       of_ivar,
       create,
       peek,
       value_exn,
       is_determined,
       return$0,
       upon,
       bind,
       [0, Async_kernel_Ivar0[15][1]],
       add_handler,
       remove_handler];
   runtime.caml_register_global
    (13, Async_kernel_Deferred0, cst_Async_kernel_Deferred0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar
//# unitInfo: Requires: Async_kernel__Deferred0, Async_kernel__Ivar0, Core__Binable, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar$0 = "Async_kernel__Ivar",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Ivar0 = global_data.Async_kernel__Ivar0,
    Async_kernel_Deferred0 = global_data.Async_kernel__Deferred0,
    Core_Option = global_data.Core__Option,
    Core_Binable = global_data.Core__Binable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/ivar.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "ivar.ml");
   var
    sexp_of_t = Async_kernel_Ivar0[1],
    invariant = Async_kernel_Ivar0[2],
    create = Async_kernel_Ivar0[3],
    create_full = Async_kernel_Ivar0[4],
    peek = Async_kernel_Ivar0[6],
    value_exn = Async_kernel_Ivar0[7],
    is_empty = Async_kernel_Ivar0[9],
    is_full = Async_kernel_Ivar0[10],
    equal = Async_kernel_Ivar0[11],
    fill_exn = Async_kernel_Ivar0[13],
    fill = Async_kernel_Ivar0[14],
    has_handlers = Async_kernel_Ivar0[19],
    read = Async_kernel_Deferred0[3],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Ivar = cst_Async_kernel_Ivar$0;
   function fill_if_empty(t, v){
    var _a_ = caml_call1(is_empty, t);
    return _a_ ? caml_call2(fill_exn, t, v) : _a_;
   }
   function to_binable(t){return caml_call1(peek, t);}
   function of_binable(param){
    if(! param) return caml_call1(create, 0);
    var a = param[1];
    return caml_call1(create_full, a);
   }
   var
    include =
      caml_call1
       (caml_call1
         (Core_Binable[7],
          [0,
           Core_Option[1],
           Core_Option[2],
           Core_Option[3],
           Core_Option[4],
           Core_Option[5]]),
        [0, to_binable, of_binable]),
    bin_shape_t = include[1],
    bin_size_t = include[2],
    bin_write_t = include[3],
    bin_read_t = include[4],
    bin_read_t$0 = include[5],
    bin_writer_t = include[6],
    bin_reader_t = include[7],
    bin_t = include[8];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar);
   var
    Async_kernel_Ivar =
      [0,
       bin_shape_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       sexp_of_t,
       invariant,
       equal,
       create,
       create_full,
       fill_exn,
       fill,
       fill_if_empty,
       is_empty,
       is_full,
       read,
       peek,
       value_exn,
       has_handlers];
   runtime.caml_register_global
    (15, Async_kernel_Ivar, cst_Async_kernel_Ivar$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monad_sequence
//# unitInfo: Requires: Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Monad_sequenc$0 = "Async_kernel__Monad_sequence",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monad_sequenc$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/monad_sequence.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "monad_sequence.ml");
   var
    _a_ = [0, "Parallel"],
    _b_ = [0, "Sequential"],
    _c_ = [0, "Max_concurrent_jobs"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Monad_sequenc = cst_Async_kernel_Monad_sequenc$0;
   function sexp_of_how(param){
    if(typeof param === "number") return -676829465 <= param ? _a_ : _b_;
    var v_001 = param[2];
    return [1, [0, _c_, [0, caml_call1(Core[389], v_001), 0]]];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monad_sequenc);
   var Async_kernel_Monad_sequence = [0, sexp_of_how];
   runtime.caml_register_global
    (15, Async_kernel_Monad_sequence, cst_Async_kernel_Monad_sequenc$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred1
//# unitInfo: Requires: Async_kernel__Deferred0, Async_kernel__Ivar, Async_kernel__Monad_sequence, Async_kernel__Scheduler1, Base__Monad, CamlinternalLazy, Core, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred1$0 = "Async_kernel__Deferred1",
    cst_async_kernel$0 = "async_kernel",
    cst_src_deferred1_ml = "src/deferred1.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Core_List = global_data.Core__List,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Async_kernel_Deferred0 = global_data.Async_kernel__Deferred0,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Monad = global_data.Base__Monad,
    Async_kernel_Monad_sequence = global_data.Async_kernel__Monad_sequence;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred1$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_deferred1_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred1.ml");
   var
    sexp_of_t = Async_kernel_Deferred0[1],
    invariant = Async_kernel_Deferred0[2],
    of_ivar = Async_kernel_Deferred0[3],
    create = Async_kernel_Deferred0[4],
    peek = Async_kernel_Deferred0[5],
    value_exn = Async_kernel_Deferred0[6],
    is_determined = Async_kernel_Deferred0[7],
    upon = Async_kernel_Deferred0[9],
    Handler = Async_kernel_Deferred0[11],
    add_handler = Async_kernel_Deferred0[12],
    remove_handler = Async_kernel_Deferred0[13],
    _a_ = [0, cst_src_deferred1_ml, 121, 22],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred1 = cst_Async_kernel_Deferred1$0;
   function never(param){
    var _$_ = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call1(Async_kernel_Ivar[19], _$_);
   }
   var
    of_ivar$0 = Async_kernel_Deferred0[3],
    return$0 = Async_kernel_Deferred0[8],
    upon$0 = Async_kernel_Deferred0[9],
    bind = Async_kernel_Deferred0[10],
    map =
      [0,
       -198771759,
       function(t, f){
        var result = caml_call1(Async_kernel_Ivar[12], 0);
        caml_call2
         (upon$0,
          t,
          function(a){
           var ___ = caml_call1(f, a);
           return caml_call2(Async_kernel_Ivar[14], result, ___);
          });
        return caml_call1(of_ivar$0, result);
       }],
    M = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = M[1],
    symbol_map = M[2],
    Monad_infix = M[3],
    bind$0 = M[4],
    map$0 = M[6],
    join = M[7],
    ignore_m = M[8],
    return$1 = Async_kernel_Deferred0[8],
    include = M[11],
    symbol_bind$0 = include[2],
    symbol_map$0 = include[3],
    return$2 = Async_kernel_Deferred0[8],
    include$0 = M[11][4],
    bind$1 = include$0[2],
    map$1 = include$0[3],
    both = include$0[4],
    Open_on_rhs = include$0[5],
    return$3 = Async_kernel_Deferred0[8],
    Let_syntax = [0, bind$1, map$1, both, Open_on_rhs, return$3],
    Let_syntax$0 = [0, symbol_bind$0, symbol_map$0, return$2, Let_syntax],
    unit = caml_call1(Let_syntax$0[3], 0);
   function both$0(t1, t2){
    return caml_call1
            (create,
             function(result){
              return caml_call2
                      (upon,
                       t1,
                       function(a1){
                        return caml_call2
                                (upon,
                                 t2,
                                 function(a2){
                                  return caml_call2
                                          (Async_kernel_Ivar[14], result, [0, a1, a2]);
                                 });
                       });
             });
   }
   var
    symbol_bind$1 = Monad_infix[1],
    symbol_map$1 = Monad_infix[2],
    Infix = [0, symbol_bind$1, symbol_map$1, upon, both$0];
   function don_t_wait_for(param){return 0;}
   function map$2(param, f2){
    var f1 = param[2], t = param[1];
    return [0, t, function(x){return caml_call1(f2, caml_call1(f1, x));}];
   }
   var Choice = [0, map$2];
   function process(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var rest = param$0[4], handler = param$0[3], t = param$0[1];
     caml_call2(remove_handler, t, handler);
     var param$0 = rest;
    }
   }
   var Unregister = [0, process];
   function choice(t, f){return [0, t, f];}
   function enabled(choices){
    var result = caml_call1(Async_kernel_Ivar[12], 0), unregisters = [0, 0];
    function ready(param){
     var _W_ = caml_call1(Async_kernel_Ivar[17], result);
     if(! _W_) return _W_;
     caml_call1(Unregister[1], unregisters[1]);
     function _X_(param){
      function _Y_(ac, param){
       var f = param[2], t = param[1], match = caml_call1(peek, t);
       if(! match) return ac;
       var v = match[1];
       return [0, caml_call1(f, v), ac];
      }
      var _Z_ = caml_call3(Core_List[20], choices, 0, _Y_);
      return caml_call1(Core_List[59], _Z_);
     }
     return caml_call2(Async_kernel_Ivar[14], result, _X_);
    }
    var
     _U_ = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], _U_);
    function _V_(acc, param){
     var f = param[2], t = param[1];
     return [0,
             t,
             f,
             caml_call3
              (Async_kernel_Deferred0[12], t, ready, execution_context),
             acc];
    }
    unregisters[1] = caml_call3(Core_List[20], choices, 0, _V_);
    return caml_call1(Async_kernel_Ivar[19], result);
   }
   function choose_result(choices){
    var choices$0 = choices;
    for(;;){
     if(! choices$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var
      choices$1 = choices$0[4],
      f = choices$0[2],
      t = choices$0[1],
      match = caml_call1(peek, t);
     if(match){var v = match[1]; return caml_call1(f, v);}
     var choices$0 = choices$1;
    }
   }
   function generic_choose(choices){
    var
     result = caml_call1(Async_kernel_Ivar[12], 0),
     _K_ = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], _K_),
     unregisters = [],
     ready = function _T_(_S_){return _T_.fun(_S_);};
    caml_update_dummy
     (unregisters,
      [246,
       function(_P_){
        var _Q_ = 0;
        function _R_(param, acc){
         var f = param[2], t = param[1];
         return [0,
                 t,
                 f,
                 caml_call3
                  (Async_kernel_Deferred0[12], t, ready, execution_context),
                 acc];
        }
        return caml_call3(Core_List[101], choices, _R_, _Q_);
       }]);
    caml_update_dummy
     (ready,
      function(param){
       var _M_ = caml_call1(Async_kernel_Ivar[17], result);
       if(! _M_) return _M_;
       var _N_ = caml_obj_tag(unregisters);
       a:
       if(250 === _N_)
        var unregisters$0 = unregisters[1];
       else{
        if(246 !== _N_ && 244 !== _N_){
         var unregisters$0 = unregisters;
         break a;
        }
        var unregisters$0 = caml_call1(CamlinternalLazy[2], unregisters);
       }
       caml_call1(Unregister[1], unregisters$0);
       var _O_ = choose_result(unregisters$0);
       return caml_call2(Async_kernel_Ivar[14], result, _O_);
      });
    var _L_ = caml_obj_tag(unregisters);
    a:
    if(250 !== _L_){
     if(246 !== _L_ && 244 !== _L_) break a;
     caml_call1(CamlinternalLazy[2], unregisters);
    }
    return caml_call1(Async_kernel_Ivar[19], result);
   }
   function choose2(a, fa, b, fb){
    var
     result = caml_call1(Async_kernel_Ivar[12], 0),
     _w_ = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], _w_),
     a_handler = [],
     b_handler = [],
     ready = function _J_(_I_){return _J_.fun(_I_);};
    caml_update_dummy
     (a_handler,
      [246,
       function(_H_){
        return caml_call3
                (Async_kernel_Deferred0[12], a, ready, execution_context);
       }]);
    caml_update_dummy
     (b_handler,
      [246,
       function(_G_){
        return caml_call3
                (Async_kernel_Deferred0[12], b, ready, execution_context);
       }]);
    caml_update_dummy
     (ready,
      function(param){
       var _z_ = caml_call1(Async_kernel_Ivar[17], result);
       if(! _z_) return _z_;
       var _A_ = caml_obj_tag(a_handler);
       a:
       if(250 === _A_)
        var _B_ = a_handler[1];
       else{
        if(246 !== _A_ && 244 !== _A_){var _B_ = a_handler; break a;}
        var _B_ = caml_call1(CamlinternalLazy[2], a_handler);
       }
       caml_call2(remove_handler, a, _B_);
       var _C_ = caml_obj_tag(b_handler);
       a:
       if(250 === _C_)
        var _D_ = b_handler[1];
       else{
        if(246 !== _C_ && 244 !== _C_){var _D_ = b_handler; break a;}
        var _D_ = caml_call1(CamlinternalLazy[2], b_handler);
       }
       caml_call2(remove_handler, b, _D_);
       var match = caml_call1(peek, a);
       if(match){
        var av = match[1], _E_ = caml_call1(fa, av);
        return caml_call2(Async_kernel_Ivar[14], result, _E_);
       }
       var _F_ = caml_call1(fb, caml_call1(value_exn, b));
       return caml_call2(Async_kernel_Ivar[14], result, _F_);
      });
    var _x_ = caml_obj_tag(a_handler);
    a:
    if(250 !== _x_){
     if(246 !== _x_ && 244 !== _x_) break a;
     caml_call1(CamlinternalLazy[2], a_handler);
    }
    var _y_ = caml_obj_tag(b_handler);
    a:
    if(250 !== _y_){
     if(246 !== _y_ && 244 !== _y_) break a;
     caml_call1(CamlinternalLazy[2], b_handler);
    }
    return caml_call1(Async_kernel_Ivar[19], result);
   }
   function choose(choices){
    if(choices){
     var _u_ = choices[2];
     if(_u_ && ! _u_[2]){
      var
       _v_ = _u_[1],
       fb = _v_[2],
       b = _v_[1],
       match = choices[1],
       fa = match[2],
       a = match[1];
      return choose2(a, fa, b, fb);
     }
    }
    return generic_choose(choices);
   }
   function any_f(ts, f){
    function _t_(t){return [0, t, f];}
    return choose(caml_call2(Core_List[51], ts, _t_));
   }
   function any(ts){return any_f(ts, function(_s_){return _s_;});}
   function any_unit(ts){return any_f(ts, function(_r_){return 0;});}
   function for$0(start, to, do$0){
    if(caml_call2(Core[91], start, to)) return caml_call1(Let_syntax$0[3], 0);
    function loop(i){
     function _p_(param){
      return caml_call2(Core[88], i, to)
              ? caml_call1(Let_syntax$0[3], 0)
              : loop(i + 1 | 0);
     }
     var _q_ = caml_call1(do$0, i);
     return caml_call2(Let_syntax$0[4][1], _q_, _p_);
    }
    return loop(start);
   }
   function repeat_until_finished(state, f){
    return caml_call1
            (create,
             function(finished){
              function loop(state){
               function _n_(param){
                if(990972795 <= param[1]){
                 var state = param[2];
                 return loop(state);
                }
                var result = param[2];
                return caml_call2(Async_kernel_Ivar[14], finished, result);
               }
               var _o_ = caml_call1(f, state);
               return caml_call2(Infix[3], _o_, _n_);
              }
              return loop(state);
             });
   }
   function forever(state, f){
    var
     _j_ = Core[158],
     _k_ =
       repeat_until_finished
        (state,
         function(state){
          function _l_(state){return [0, 990972795, state];}
          var _m_ = caml_call1(f, state);
          return caml_call2(Let_syntax$0[4][2], _m_, _l_);
         });
    return caml_call2(Infix[3], _k_, _j_);
   }
   var sexp_of_how = Async_kernel_Monad_sequence[1];
   function fold(t, init, f){
    return caml_call1
            (create,
             function(result){
              function loop(t, b){
               if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
               var xs = t[2], x = t[1];
               function _h_(b){return loop(xs, b);}
               var _i_ = caml_call2(f, b, x);
               return caml_call2(Infix[3], _i_, _h_);
              }
              return loop(t, init);
             });
   }
   function seqmap(t, f){
    var
     _d_ = Core_List[59],
     _e_ =
       fold
        (t,
         0,
         function(bs, a){
          function _f_(b){return [0, b, bs];}
          var _g_ = caml_call1(f, a);
          return caml_call2(Infix[2], _g_, _f_);
         });
    return caml_call2(Infix[2], _e_, _d_);
   }
   function all(ds){return seqmap(ds, function(_c_){return _c_;});}
   function all_unit(ds){return fold(ds, 0, function(param, d){return d;});}
   function ok(x){
    function _b_(x){return [0, x];}
    return caml_call2(Infix[2], x, _b_);
   }
   var For_tests = [0, generic_choose];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred1);
   var
    Async_kernel_Deferred1 =
      [0,
       sexp_of_t,
       invariant,
       of_ivar,
       create,
       peek,
       value_exn,
       is_determined,
       upon,
       Handler,
       add_handler,
       remove_handler,
       never,
       M,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       map$0,
       join,
       ignore_m,
       return$1,
       Let_syntax$0,
       unit,
       both$0,
       Infix,
       don_t_wait_for,
       Choice,
       Unregister,
       choice,
       enabled,
       choose_result,
       generic_choose,
       choose2,
       choose,
       any_f,
       any,
       any_unit,
       for$0,
       repeat_until_finished,
       forever,
       sexp_of_how,
       fold,
       seqmap,
       all,
       all_unit,
       ok,
       For_tests];
   runtime.caml_register_global
    (21, Async_kernel_Deferred1, cst_Async_kernel_Deferred1$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_std
//# unitInfo: Requires: Async_kernel__Deferred1, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_std = "Async_kernel__Deferred_std",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_std);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_std.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel, "deferred_std.ml");
   var
    _a_ = Async_kernel_Deferred1[25],
    symbol = _a_[3],
    ppx_both = _a_[4],
    include = Async_kernel_Deferred1[22],
    symbol_bind = include[1],
    symbol_map = include[2],
    return$0 = include[3],
    Let_syntax = include[4],
    choice = Async_kernel_Deferred1[29],
    choose = Async_kernel_Deferred1[34],
    don_t_wait_for = Async_kernel_Deferred1[26],
    never = Async_kernel_Deferred1[12],
    upon = Async_kernel_Deferred1[8];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_std);
   var
    Async_kernel_Deferred_std =
      [0,
       symbol,
       ppx_both,
       symbol_bind,
       symbol_map,
       Let_syntax,
       choice,
       choose,
       don_t_wait_for,
       never,
       return$0,
       upon];
   runtime.caml_register_global
    (12, Async_kernel_Deferred_std, cst_Async_kernel_Deferred_std);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar_filler
//# unitInfo: Requires: Async_kernel__Ivar, Base__Invariant, Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar_filler$0 = "Async_kernel__Ivar_filler",
    cst_async_kernel$0 = "async_kernel",
    cst_src_ivar_filler_ml = "src/ivar_filler.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar_filler$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_ivar_filler_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "ivar_filler.ml");
   var
    cst_attempt_to_fill_full_ivar = "attempt to fill full ivar",
    _d_ = [0, "_"],
    _c_ = [0, cst_src_ivar_filler_ml, 15, 20],
    _e_ = [0, cst_src_ivar_filler_ml, 12, 154, 176],
    _a_ = [0, "Empty"],
    _b_ = [0, "Full"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Ivar_filler = cst_Async_kernel_Ivar_filler$0;
   function sexp_of_t(of_a_005, x_006){
    function _i_(param){
     if(! param) return _b_;
     var
      arg0_002 = param[1],
      res0_003 = caml_call2(Async_kernel_Ivar[9], of_a_005, arg0_002);
     return [1, [0, _a_, [0, res0_003, 0]]];
    }
    return caml_call2(Core[598], _i_, x_006);
   }
   function invariant(param, t){
    function _g_(param){
     var match = t[1];
     if(! match) return 0;
     var ivar = match[1];
     if(caml_call1(Async_kernel_Ivar[17], ivar)) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
    function _h_(x_007){
     return sexp_of_t(function(param){return _d_;}, x_007);
    }
    return caml_call4(Base_Invariant[1], _e_, t, _h_, _g_);
   }
   function create(param){
    var ivar = caml_call1(Async_kernel_Ivar[12], 0), t = [0, [0, ivar]];
    return [0, t, caml_call1(Async_kernel_Ivar[19], ivar)];
   }
   function is_empty(t){return t[1] ? 1 : 0;}
   function fill(t, a){
    var match = t[1];
    if(match){
     var i = match[1];
     t[1] = 0;
     return caml_call2(Async_kernel_Ivar[14], i, a);
    }
    var
     _f_ = caml_call1(Sexplib0_Sexp_conv[7], cst_attempt_to_fill_full_ivar);
    return caml_call1(Core[261], _f_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar_filler);
   var
    Async_kernel_Ivar_filler =
      [0, sexp_of_t, invariant, create, is_empty, fill];
   runtime.caml_register_global
    (22, Async_kernel_Ivar_filler, cst_Async_kernel_Ivar_filler$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Tail
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Ivar, Core, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Tail$0 = "Async_kernel__Tail",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_List = global_data.Core__List,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Tail$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/tail.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "tail.ml");
   var
    cst_stream_is_closed = "stream is closed",
    cst_open_tail = "<open tail>",
    cst_closed_tail = "<closed tail>",
    _a_ = [0, "..."],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Tail = cst_Async_kernel_Tail$0;
   function sexp_of_t(sexp_of_a, t){
    var d = t, ac = 0;
    for(;;){
     var match = caml_call1(Async_kernel_Deferred1[5], d);
     if(! match) return [1, caml_call1(Core_List[59], [0, _a_, ac])];
     var match$0 = match[1];
     if(! match$0) return [1, caml_call1(Core_List[59], ac)];
     var
      t$0 = match$0[2],
      a = match$0[1],
      ac$0 = [0, caml_call1(sexp_of_a, a), ac],
      d = t$0,
      ac = ac$0;
    }
   }
   function next(t){return t;}
   var Stream = [0, sexp_of_t, next];
   function sexp_of_t$0(param, t){
    var
     _d_ =
       caml_call1(Async_kernel_Ivar[17], t[1])
        ? cst_open_tail
        : cst_closed_tail;
    return [0, _d_];
   }
   function create(param){return [0, caml_call1(Async_kernel_Ivar[12], 0)];}
   function collect(t){return caml_call1(Async_kernel_Ivar[19], t[1]);}
   function is_closed(t){return caml_call1(Async_kernel_Ivar[18], t[1]);}
   function fill_exn(t, v){
    if(! is_closed(t)) return caml_call2(Async_kernel_Ivar[14], t[1], v);
    var _c_ = caml_call1(Sexplib0_Sexp_conv[7], cst_stream_is_closed);
    return caml_call1(Core[261], _c_);
   }
   function close_exn(t){return fill_exn(t, 0);}
   function close_if_open(t){
    var _b_ = 1 - is_closed(t);
    return _b_ ? caml_call2(Async_kernel_Ivar[14], t[1], 0) : _b_;
   }
   function extend(t, v){
    var next = caml_call1(Async_kernel_Ivar[12], 0);
    fill_exn(t, [0, v, caml_call1(Async_kernel_Ivar[19], next)]);
    t[1] = next;
    return 0;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Tail);
   var
    Async_kernel_Tail =
      [0,
       sexp_of_t$0,
       create,
       extend,
       close_exn,
       close_if_open,
       is_closed,
       Stream,
       collect];
   runtime.caml_register_global
    (20, Async_kernel_Tail, cst_Async_kernel_Tail$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monitor
//# unitInfo: Requires: Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Ivar, Async_kernel__Ivar_filler, Async_kernel__Monitor0, Async_kernel__Scheduler1, Async_kernel__Tail, Async_kernel_config, Base__Backtrace, Base__Exn, Base__Invariant, Core, Core__Bag, Core__Error, Core__Info, Core__List, Core__Or_error, Core__Result, Core__String, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib__Conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    cst_Async_kernel_Monitor$0 = "Async_kernel__Monitor",
    cst_Caught_by_monitor = "Caught by monitor ",
    cst_async_kernel$0 = "async_kernel",
    cst_exn = "exn",
    cst_file = "file ",
    cst_src_monitor_ml = "src/monitor.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    job_queue = "Called from Async_kernel__Job_queue",
    deferred0 = "Called from Async_kernel__Deferred0",
    deferred1 = "Called from Async_kernel__Deferred1",
    monitor = "Called from Async_kernel__Monitor",
    try_with = "Called from Base__Result.try_with",
    error = "Raised at Base__Error.raise",
    Core_Error = global_data.Core__Error,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Core_Or_error = global_data.Core__Or_error,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar_filler = global_data.Async_kernel__Ivar_filler,
    Base_Exn = global_data.Base__Exn,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Core_Result = global_data.Core__Result,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_Bag = global_data.Core__Bag,
    Core_List = global_data.Core__List,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Info = global_data.Core__Info,
    Core_String = global_data.Core__String,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Monitor0 = global_data.Async_kernel__Monitor0,
    Sexplib_Conv = global_data.Sexplib__Conv;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monitor$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_monitor_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "monitor.ml");
   var
    has_seen_error = Async_kernel_Monitor0[4],
    name = Async_kernel_Monitor0[14],
    Fields = Async_kernel_Monitor0[15],
    sexp_of_t = Async_kernel_Monitor0[18],
    create_with_parent = Async_kernel_Monitor0[20],
    main = Async_kernel_Monitor0[21],
    cst_Monitor_catch_got_unexpect =
      "Monitor.catch got unexpected empty stream",
    _r_ = [0, "finally_exn"],
    _s_ = [0, cst_exn],
    cst_Async_finally = "Async finally",
    _t_ = [0, 523273847],
    _u_ = [0, 0],
    _v_ = [0, "finally"],
    cst_Monitor_protect = "Monitor.protect",
    cst_try_with_join_or_error = "try_with_join_or_error",
    cst_try_with_or_error = "try_with_or_error",
    _q_ = [0, 3903734],
    _p_ = [0, cst_src_monitor_ml, 402, 17],
    _o_ = [0, 3553398],
    _n_ = [0, cst_exn],
    cst_failed_to_set_Monitor_Expe =
      "failed to set [Monitor.Expert.try_with_log_exn]",
    _l_ = [0, 3553398],
    _m_ = [1, 0],
    cst_Monitor_send_exn_found_lis =
      "Monitor.send_exn found listening monitor",
    cst_Monitor_send_exn = "Monitor.send_exn",
    cst_monitor_ml_Error = "monitor.ml.Error",
    _k_ = [0, cst_src_monitor_ml, 181, 6],
    _d_ =
      [0,
       [11, cst_file, [3, 0, [11, ", line LINE, characters C1-C2", 0]]],
       "file %S, line LINE, characters C1-C2"],
    _i_ =
      [0,
       [11,
        cst_file,
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11, ", characters ", [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]]]]]]],
       "file %S, line %d, characters %d-%d"],
    _e_ =
      [0,
       [11, cst_Caught_by_monitor, [2, 0, [11, " at ", [2, 0, 0]]]],
       "Caught by monitor %s at %s"],
    _g_ =
      [0, [11, "Caught by monitor at ", [2, 0, 0]], "Caught by monitor at %s"],
    _h_ = [0, [11, cst_Caught_by_monitor, [2, 0, 0]], "Caught by monitor %s"],
    _f_ = [0, "backtrace_history"],
    _c_ = [0, cst_src_monitor_ml, 42, 23],
    _a_ = [0, cst_src_monitor_ml, 20, 44],
    _b_ = [0, cst_src_monitor_ml, 13, 226, 248],
    cst_Async_kernel_Monitor_Monit = "Async_kernel__Monitor.Monitor_exn",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Monitor = cst_Async_kernel_Monitor$0;
   function invariant(t){
    function _aA_(param){
     function _aC_(_aP_){return 0;}
     function _aD_(_aO_){return 0;}
     function _aE_(_aN_){return 0;}
     function _aF_(_aM_){return 0;}
     function f(next_error){
      if(caml_call1(Async_kernel_Ivar[17], next_error)) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     }
     var _aB_ = caml_call2(Base_Invariant[2], t, f);
     function _aG_(_aL_){return 0;}
     function _aH_(_aK_){return 0;}
     function _aI_(_aJ_){return 0;}
     return caml_call8
             (Fields[9], _aI_, _aH_, _aG_, _aB_, _aF_, _aE_, _aD_, _aC_);
    }
    return caml_call4(Base_Invariant[1], _b_, t, sexp_of_t, _aA_);
   }
   function current_execution_context(param){
    var _az_ = caml_call1(Async_kernel_Scheduler1[72], 0);
    return caml_call1(Async_kernel_Scheduler1[73], _az_);
   }
   function current(param){
    var _ay_ = current_execution_context(0);
    return caml_call1(Async_kernel_Execution_context[4], _ay_);
   }
   function detach(t){t[8] = 0; return 0;}
   function detach_and_iter_errors(t, f){
    detach(t);
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], scheduler),
     handler_state_ref = [0, 0];
    function run_f(exn){
     var match = handler_state_ref[1];
     if(typeof match === "number"){
      if(match) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     }
     var bag_elt = match[1];
     try{var _ax_ = caml_call1(f, exn); return _ax_;}
     catch(inner_exn$0){
      var inner_exn = caml_wrap_exception(inner_exn$0);
      handler_state_ref[1] = 1;
      caml_call2(Core_Bag[26], t[5], bag_elt);
      throw caml_maybe_attach_backtrace(inner_exn, 0);
     }
    }
    handler_state_ref[1] =
     [0, caml_call2(Core_Bag[23], t[5], [0, execution_context, run_f])];
    return 0;
   }
   function detach_and_get_error_stream(t){
    detach(t);
    var tail = caml_call1(Async_kernel_Tail[2], 0);
    t[6] = [0, tail, t[6]];
    return caml_call1(Async_kernel_Tail[8], tail);
   }
   function get_next_error(t){return caml_call1(Async_kernel_Ivar[19], t[4]);}
   function detach_and_get_next_error(t){detach(t); return get_next_error(t);}
   function create(here, info, name, param){
    var parent = current(0);
    return caml_call4(create_with_parent, here, info, name, [0, parent]);
   }
   function backtrace(t){return t[2];}
   function extract_exn(t){return t[1];}
   var
    Monitor_exn =
      [248, cst_Async_kernel_Monitor_Monit, runtime.caml_fresh_oo_id(0)];
   function _j_(param){
    if(param[1] !== Monitor_exn)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    var
     t = param[2],
     monitor$0 = t[4],
     backtrace_history = t[3],
     backtrace = t[2],
     exn = t[1],
     s = caml_call1(Core_Info[12], monitor$0[1]),
     name = runtime.caml_string_notequal(s, cst$0) ? [0, s] : 0,
     match = monitor$0[2];
    if(match)
     var
      here = match[1],
      column = here[4] - here[3] | 0,
      _ap_ =
        Core[628]
         ? caml_call2(Core[265], _d_, here[1])
         : caml_call5(Core[265], _i_, here[1], here[2], column, column),
      pos = [0, _ap_];
    else
     var pos = 0;
    if(pos){
     var pos$0 = pos[1];
     if(name)
      var
       name$0 = name[1],
       _aq_ = [0, caml_call3(Core[265], _e_, name$0, pos$0), 0];
     else
      var _aq_ = [0, caml_call2(Core[265], _g_, pos$0), 0];
     var monitor$1 = _aq_;
    }
    else if(name)
     var
      name$1 = name[1],
      monitor$1 = [0, caml_call2(Core[265], _h_, name$1), 0];
    else
     var monitor$1 = 0;
    if(backtrace)
     var
      backtrace$0 = backtrace[1],
      backtrace$1 = caml_call1(Base_Backtrace[4], backtrace$0);
    else
     var backtrace$1 = 0;
    function strip_prefixes(lines, prefixes){
     function _av_(line){
      function _aw_(prefix){return caml_call2(Core_String[73], line, prefix);}
      return caml_call2(Core_List[23], prefixes, _aw_);
     }
     return caml_call2(Core_List[137], lines, _av_);
    }
    var
     suffixes =
       [0,
        job_queue,
        [0, deferred0, [0, deferred1, [0, monitor, [0, try_with, 0]]]]],
     input = strip_prefixes(backtrace$1, [0, error, 0]),
     rev_input = caml_call1(Core_List[59], input),
     rev_output = strip_prefixes(rev_input, suffixes),
     _ar_ =
       rev_input === rev_output
        ? input
        : caml_call1(Core_List[59], rev_output),
     backtrace$2 = caml_call2(Core[156], _ar_, monitor$1);
    function list_if_not_empty(l){return l ? [0, l] : 0;}
    var
     match$0 = list_if_not_empty(backtrace$2),
     _as_ = list_if_not_empty(backtrace_history),
     match$1 = 0;
    if(_as_)
     var
      x_002 = _as_[1],
      match$2 =
        [0,
         [1,
          [0, _f_, [0, caml_call2(Core[472], Base_Backtrace[1], x_002), 0]]],
         match$1];
    else
     var match$2 = match$1;
    if(match$0)
     var
      x_001 = match$0[1],
      _at_ = [0, caml_call2(Core[472], Core[558], x_001), match$2];
    else
     var _at_ = match$2;
    var sexp = [1, [0, caml_call1(Core[625], exn), _at_]];
    if(0 === sexp[0]) var _au_ = [0, sexp, 0]; else var l = sexp[1], _au_ = l;
    return [1,
            [0, caml_call1(Sexplib0_Sexp_conv[7], cst_monitor_ml_Error), _au_]];
   }
   caml_call4(Sexplib_Conv[72][1], 0, 0, Monitor_exn, _j_);
   function extract_exn$0(exn){
    if(exn[1] !== Monitor_exn) return exn;
    var error = exn[2];
    return error[1];
   }
   function send_exn(t, opt, exn){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 3553398;
    if(exn[1] === Monitor_exn)
     var exn$0 = exn;
    else{
     if(typeof backtrace === "number")
      var backtrace$0 = caml_call1(Base_Backtrace[6][5], exn);
     else
      var b = backtrace[2], backtrace$0 = [0, b];
     var
      backtrace_history = current_execution_context(0)[4],
      exn$0 = [0, Monitor_exn, [0, exn, backtrace$0, backtrace_history, t]];
    }
    if(Async_kernel_Debug[7]){
     var
      _aj_ =
        function(param){
         var
          arg1_004 = param[2],
          arg0_003 = param[1],
          res0_005 = caml_call1(sexp_of_t, arg0_003),
          res1_006 = caml_call1(Core[625], arg1_004);
         return [1, [0, res0_005, [0, res1_006, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15], cst_Monitor_send_exn, [0, t, exn$0], _aj_);
    }
    var scheduler = caml_call1(Async_kernel_Scheduler1[72], 0), t$0 = t;
    for(;;){
     t$0[7] = 1;
     caml_call2(Async_kernel_Ivar[14], t$0[4], exn$0);
     t$0[4] = caml_call1(Async_kernel_Ivar[12], 0);
     var match = t$0[8];
     if(typeof match === "number") break;
     var parent = match[1], t$0 = parent;
    }
    if(match){
     var
      _ak_ = caml_call1(Async_kernel_config[35][1], 0),
      _al_ = caml_call1(Async_kernel_Scheduler1[72], 0);
     return caml_call2
             (caml_call1(Async_kernel_Scheduler1[77], _al_), exn$0, _ak_);
    }
    if(Async_kernel_Debug[7]){
     var
      _am_ =
        function(param){
         var
          arg1_008 = param[2],
          arg0_007 = param[1],
          res0_009 = caml_call1(sexp_of_t, arg0_007),
          res1_010 = caml_call1(Core[625], arg1_008);
         return [1, [0, res0_009, [0, res1_010, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_Monitor_send_exn_found_lis,
       [0, t$0, exn$0],
       _am_);
    }
    function _an_(param){
     var f = param[2], execution_context = param[1];
     return caml_call4
             (Async_kernel_Scheduler1[63],
              scheduler,
              execution_context,
              f,
              exn$0);
    }
    caml_call2(Core_Bag[7], t$0[5], _an_);
    function _ao_(tail){return caml_call2(Async_kernel_Tail[3], tail, exn$0);}
    return caml_call2(Core_List[19], t$0[6], _ao_);
   }
   function within_context(context, f){
    function _ah_(param){
     var match = caml_call1(Core_Result[54], f);
     if(0 === match[0]){var x = match[1]; return [0, x];}
     var exn = match[1];
     send_exn
      (caml_call1(Async_kernel_Execution_context[4], context), _l_, exn);
     return _m_;
    }
    var _ai_ = caml_call1(Async_kernel_Scheduler1[72], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler1[75], _ai_), context, _ah_);
   }
   function within_gen(monitor, priority, f){
    var
     _ag_ = current_execution_context(0),
     tmp_context =
       caml_call4
        (Async_kernel_Execution_context[8], monitor, priority, 0, _ag_);
    return within_context(tmp_context, f);
   }
   function within(monitor, priority, f){
    var match = within_gen(monitor, priority, f);
    if(0 !== match[0]) return caml_call1(Async_kernel_Deferred1[12], 0);
    var d = match[1];
    return d;
   }
   function within_v(monitor, priority, f){
    var match = within_gen(monitor, priority, f);
    if(0 !== match[0]) return 0;
    var x = match[1];
    return [0, x];
   }
   function within$0(monitor, priority, f){
    return 0 === within_gen(monitor, priority, f)[0] ? 0 : 0;
   }
   function schedule_with_data(monitor, priority, work, x){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[72], 0),
     _ae_ = caml_call1(Async_kernel_Scheduler1[73], scheduler),
     _af_ =
       caml_call4
        (Async_kernel_Execution_context[8], monitor, priority, 0, _ae_);
    return caml_call4(Async_kernel_Scheduler1[63], scheduler, _af_, work, x);
   }
   function schedule(monitor, priority, work){
    return schedule_with_data(monitor, priority, work, 0);
   }
   function upon_work_fill_i(param){
    var i = param[2], work = param[1];
    function _ac_(a){return caml_call2(Async_kernel_Ivar[14], i, a);}
    var _ad_ = caml_call1(work, 0);
    return caml_call2(Async_kernel_Deferred_std[11], _ad_, _ac_);
   }
   function schedule$0(monitor, priority, work){
    var i = caml_call1(Async_kernel_Ivar[12], 0);
    schedule_with_data(monitor, priority, upon_work_fill_i, [0, work, i]);
    return caml_call1(Async_kernel_Ivar[19], i);
   }
   function preserve_execution_context(f){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], scheduler);
    function _ab_(a){
     return caml_call4
             (Async_kernel_Scheduler1[63], scheduler, execution_context, f, a);
    }
    return caml_call1(Core[266], _ab_);
   }
   function preserve_execution_context$0(f){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], scheduler);
    function call_and_fill(param){
     var i = param[3], a = param[2], f = param[1];
     function _$_(r){return caml_call2(Async_kernel_Ivar[14], i, r);}
     var _aa_ = caml_call1(f, a);
     return caml_call2(Async_kernel_Deferred_std[11], _aa_, _$_);
    }
    function _Z_(a){
     function ___(i){
      return caml_call4
              (Async_kernel_Scheduler1[63],
               scheduler,
               execution_context,
               call_and_fill,
               [0, f, a, i]);
     }
     return caml_call1(Async_kernel_Deferred1[4], ___);
    }
    return caml_call1(Core[266], _Z_);
   }
   function stream_iter(stream, f){
    function loop(stream){
     function _X_(param){
      if(! param) return 0;
      var stream = param[2], v = param[1];
      loop(stream);
      return caml_call1(f, v);
     }
     var _Y_ = caml_call1(Async_kernel_Tail[7][2], stream);
     return caml_call2(Async_kernel_Deferred_std[1], _Y_, _X_);
    }
    return loop(stream);
   }
   function create$0(here, info, name, run, f){
    var
     monitor = caml_call4(create_with_parent, here, info, name, 0),
     exns = detach_and_get_error_stream(monitor),
     ok =
       523273847 <= run
        ? schedule$0([0, monitor], 0, f)
        : within([0, monitor], 0, f);
    return [0, ok, exns];
   }
   function fill_result_and_handle_backgro
   (result_filler, result, exns, handle_exns_after_result){
    var _W_ = caml_call1(Async_kernel_Ivar_filler[4], result_filler);
    return _W_
            ? (caml_call2
               (Async_kernel_Ivar_filler[5], result_filler, result),
              caml_call1(handle_exns_after_result, exns))
            : _W_;
   }
   var
    try_with_log_exn =
      [0,
       function(exn){
        var
         _U_ = [0, [1, [0, _n_, [0, caml_call1(Base_Exn[1], exn), 0]]], 0],
         _V_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_failed_to_set_Monitor_Expe),
             _U_]];
        return caml_call1(Core[261], _V_);
       }],
    Expert = [0, try_with_log_exn];
   function try_with$0(here, info, opt, _P_, _O_, _N_, f$0){
    if(opt) var sth = opt[1], name = sth; else var name = cst;
    if(_P_)
     var sth$0 = _P_[1], do_extract_exn = sth$0;
    else
     var do_extract_exn = 0;
    if(_O_) var sth$1 = _O_[1], run = sth$1; else var run = 3903734;
    if(_N_) var sth$2 = _N_[1], rest = sth$2; else var rest = -146189108;
    var
     match = create$0(here, info, [0, name], run, f$0),
     exns = match[2],
     ok = match[1];
    if(typeof rest === "number")
     if(3804260 <= rest)
      var handle_exn = Expert[1][1];
     else
      var
       parent = current(0),
       handle_exn = function(exn){return send_exn(parent, _o_, exn);};
    else
     var
      f = rest[2],
      parent$0 = current(0),
      handle_exn =
        function(exn){
         return within$0
                 ([0, parent$0],
                  0,
                  function(param){return caml_call1(f, exn);});
        };
    function handle_exns_after_result(exns){return stream_iter(exns, handle_exn);
    }
    return within
            ([0, main],
             0,
             function(param){
              if(caml_call1(Async_kernel_Deferred1[7], ok)){
               handle_exns_after_result(exns);
               var _Q_ = [0, caml_call1(Async_kernel_Deferred1[6], ok)];
               return caml_call1(Async_kernel_Deferred_std[10], _Q_);
              }
              var
               match = caml_call1(Async_kernel_Ivar_filler[3], 0),
               result = match[2],
               result_filler = match[1];
              function _R_(res){
               return fill_result_and_handle_backgro
                       (result_filler, [0, res], exns, handle_exns_after_result);
              }
              caml_call2(Async_kernel_Deferred_std[11], ok, _R_);
              function _S_(param){
               if(! param)
                throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
               var
                exns = param[2],
                exn = param[1],
                exn$0 = do_extract_exn ? extract_exn$0(exn) : exn;
               return fill_result_and_handle_backgro
                       (result_filler, [1, exn$0], exns, handle_exns_after_result);
              }
              var _T_ = caml_call1(Async_kernel_Tail[7][2], exns);
              caml_call2(Async_kernel_Deferred_std[11], _T_, _S_);
              return result;
             });
   }
   function try_with_or_error(here, info, opt, extract_exn, rest, f){
    if(opt)
     var sth = opt[1], name = sth;
    else
     var name = cst_try_with_or_error;
    var arg = Core_Or_error[42];
    function _L_(eta){return caml_call2(arg, 0, eta);}
    var _M_ = try_with$0(here, info, [0, name], extract_exn, _q_, rest, f);
    return caml_call2(Async_kernel_Deferred_std[4], _M_, _L_);
   }
   function try_with_join_or_error(here, info, opt, extract_exn, rest, f){
    if(opt)
     var sth = opt[1], name = sth;
    else
     var name = cst_try_with_join_or_error;
    var
     _J_ = Core_Or_error[31],
     _K_ = try_with_or_error(here, info, [0, name], extract_exn, rest, f);
    return caml_call2(Async_kernel_Deferred_std[4], _K_, _J_);
   }
   function protect(here, info, opt, extract_exn, run, rest, f, finally$0){
    if(opt) var sth = opt[1], name = sth; else var name = cst_Monitor_protect;
    function _C_(r){
     function _E_(fr){
      if(0 === r[0]){
       var r$0 = r[1];
       if(0 === fr[0]) return r$0;
       var e = fr[1];
      }
      else{
       var exn = r[1];
       if(0 !== fr[0]){
        var
         finally_exn = fr[1],
         _G_ =
           [0, [1, [0, _r_, [0, caml_call1(Core[625], finally_exn), 0]]], 0],
         _H_ = [0, [1, [0, _s_, [0, caml_call1(Core[625], exn), 0]]], _G_],
         _I_ =
           [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Async_finally), _H_]];
        return caml_call1(Core[261], _I_);
       }
       var e = exn;
      }
      throw caml_maybe_attach_backtrace(e, 0);
     }
     var _F_ = try_with$0(here, info, _v_, _u_, _t_, rest, finally$0);
     return caml_call2(Async_kernel_Deferred_std[5][2], _F_, _E_);
    }
    var _D_ = try_with$0(here, info, [0, name], extract_exn, run, rest, f);
    return caml_call2(Async_kernel_Deferred_std[5][1], _D_, _C_);
   }
   function handle_errors(here, info, name, f, handler){
    var
     match = create$0(here, info, name, 3903734, f),
     exns = match[2],
     ok = match[1];
    stream_iter(exns, handler);
    return ok;
   }
   function catch_stream(here, info, name, f){
    var
     exns =
       create$0
         (here,
          info,
          name,
          3903734,
          function(param){
           caml_call1(f, 0);
           return caml_call1(Async_kernel_Deferred_std[10], 0);
          })
        [2];
    return exns;
   }
   function catch$0(here, info, name, f){
    function _y_(param){
     if(param){var x = param[1]; return x;}
     var
      _B_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Monitor_catch_got_unexpect);
     return caml_call1(Core[261], _B_);
    }
    var
     _z_ = catch_stream(here, info, name, f),
     _A_ = caml_call1(Async_kernel_Tail[7][2], _z_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _A_, _y_);
   }
   function catch_error(here, info, name, f){
    var arg = Core_Error[27];
    function _w_(eta){return caml_call2(arg, 0, eta);}
    var _x_ = catch$0(here, info, name, f);
    return caml_call2(Async_kernel_Deferred_std[4], _x_, _w_);
   }
   function parent(t){
    var match = t[8];
    if(typeof match === "number") return match ? 0 : 0;
    var parent = match[1];
    return [0, parent];
   }
   function depth(t){
    var t$0 = t, n = 0;
    for(;;){
     var match = parent(t$0);
     if(! match) return n;
     var t$1 = match[1], n$0 = n + 1 | 0, t$0 = t$1, n = n$0;
    }
   }
   var For_tests = [0, parent, depth];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monitor);
   var
    Async_kernel_Monitor =
      [0,
       sexp_of_t,
       invariant,
       create,
       name,
       current,
       detach,
       detach_and_iter_errors,
       detach_and_get_next_error,
       detach_and_get_error_stream,
       get_next_error,
       [0, extract_exn, backtrace],
       Monitor_exn,
       extract_exn$0,
       has_seen_error,
       send_exn,
       try_with$0,
       try_with_or_error,
       try_with_join_or_error,
       handle_errors,
       catch_stream,
       catch$0,
       catch_error,
       protect,
       main,
       Expert,
       [0,
        within,
        within$0,
        within_v,
        schedule$0,
        schedule,
        within_context,
        preserve_execution_context,
        preserve_execution_context$0],
       For_tests];
   runtime.caml_register_global
    (76, Async_kernel_Monitor, cst_Async_kernel_Monitor$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_stream
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Tail, Core, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_stream$0 = "Async_kernel__Async_stream",
    cst_async_kernel$0 = "async_kernel",
    cst_src_async_stream_ml = "src/async_stream.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_stream$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_async_stream_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "async_stream.ml");
   var
    include = Async_kernel_Tail[7],
    sexp_of_t = include[1],
    next = include[2],
    _b_ = [0, -146189108],
    _c_ = [0, 523273847],
    _a_ = [0, cst_src_async_stream_ml, 177, 18],
    cst_Stream_first_of_empty_stre = "Stream.first of empty stream",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_stream = cst_Async_kernel_Async_stream$0;
   function first_exn(t){
    function _aD_(param){
     if(param){var x = param[1]; return x;}
     var
      _aF_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Stream_first_of_empty_stre);
     return caml_call1(Core[261], _aF_);
    }
    var _aE_ = caml_call1(next, t);
    return caml_call2(Async_kernel_Deferred_std[5][2], _aE_, _aD_);
   }
   function fold(t, init, f){
    function _ax_(result){
     function loop(t, b){
      function _ay_(param){
       if(! param) return caml_call2(Async_kernel_Ivar[14], result, b);
       var t = param[2], v = param[1];
       function _aA_(_aC_){return loop(t, _aC_);}
       var _aB_ = caml_call2(f, b, v);
       return caml_call2(Async_kernel_Deferred_std[11], _aB_, _aA_);
      }
      var _az_ = caml_call1(next, t);
      return caml_call2(Async_kernel_Deferred_std[11], _az_, _ay_);
     }
     return loop(t, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _ax_);
   }
   function fold$0(t, init, f){
    function _as_(result){
     function loop$0(counter, t, b){
      var
       _au_ = caml_call1(next, t),
       match = caml_call1(Async_kernel_Deferred1[5], _au_);
      if(! match){
       var
        _av_ = function(next){return loop_next(next, b);},
        _aw_ = caml_call1(next, t);
       return caml_call2(Async_kernel_Deferred_std[11], _aw_, _av_);
      }
      var next$0 = match[1];
      if(counter >= 50)
       return caml_trampoline_return(loop_next$0, [0, next$0, b]);
      var counter$0 = counter + 1 | 0;
      return loop_next$0(counter$0, next$0, b);
     }
     function loop_next$0(counter, next, b){
      if(! next) return caml_call2(Async_kernel_Ivar[14], result, b);
      var t = next[2], v = next[1], _at_ = caml_call2(f, b, v);
      if(counter >= 50) return caml_trampoline_return(loop$0, [0, t, _at_]);
      var counter$0 = counter + 1 | 0;
      return loop$0(counter$0, t, _at_);
     }
     function loop(t, b){return caml_trampoline(loop$0(0, t, b));}
     function loop_next(next, b){
      return caml_trampoline(loop_next$0(0, next, b));
     }
     return loop(t, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _as_);
   }
   function length(t){
    return fold$0(t, 0, function(n, param){return n + 1 | 0;});
   }
   function iter(t, f){
    return fold(t, 0, function(param, v){return caml_call1(f, v);});
   }
   function closed(t){
    var
     _ar_ = caml_call1(next, t),
     match = caml_call1(Async_kernel_Deferred1[5], _ar_);
    if(match && ! match[1])
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    return iter
            (t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function iter$0(t, f){
    var
     _aq_ =
       iter
        (t,
         function(a){
          caml_call1(f, a);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    return caml_call1(Async_kernel_Deferred_std[8], _aq_);
   }
   function create(f){
    var
     tail = caml_call1(Async_kernel_Tail[2], 0),
     t = caml_call1(Async_kernel_Tail[8], tail);
    caml_call1(f, tail);
    return t;
   }
   function unfold(b, f){
    return create
            (function(tail){
              function loop(b){
               function _ao_(param){
                if(! param) return caml_call1(Async_kernel_Tail[4], tail);
                var match = param[1], b = match[2], a = match[1];
                caml_call2(Async_kernel_Tail[3], tail, a);
                return loop(b);
               }
               var _ap_ = caml_call1(f, b);
               return caml_call2(Async_kernel_Deferred_std[11], _ap_, _ao_);
              }
              return loop(b);
             });
   }
   function of_list(l){
    return create
            (function(tail){
              function _an_(x){
               return caml_call2(Async_kernel_Tail[3], tail, x);
              }
              caml_call2(Core_List[19], l, _an_);
              return caml_call1(Async_kernel_Tail[4], tail);
             });
   }
   function to_list(s){
    var
     _al_ = Core_List[59],
     _am_ =
       fold
        (s,
         0,
         function(b, a){
          return caml_call1(Async_kernel_Deferred_std[10], [0, a, b]);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _am_, _al_);
   }
   function copy_to_tail(t, tail){
    return iter
            (t,
             function(a){
              var _ak_ = caml_call2(Async_kernel_Tail[3], tail, a);
              return caml_call1(Async_kernel_Deferred_std[10], _ak_);
             });
   }
   function append(t1, t2){
    return create
            (function(tail){
              function _ag_(param){
               function _ai_(param){
                return caml_call1(Async_kernel_Tail[4], tail);
               }
               var _aj_ = copy_to_tail(t2, tail);
               return caml_call2(Async_kernel_Deferred_std[11], _aj_, _ai_);
              }
              var _ah_ = copy_to_tail(t1, tail);
              return caml_call2(Async_kernel_Deferred_std[11], _ah_, _ag_);
             });
   }
   function concat(t){
    return create
            (function(tail){
              function _ae_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var _af_ = iter(t, function(t){return copy_to_tail(t, tail);});
              return caml_call2(Async_kernel_Deferred_std[11], _af_, _ae_);
             });
   }
   function filter_deprecated(t, f){
    return create
            (function(tail){
              function _$_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _aa_ =
                 iter
                  (t,
                   function(v){
                    function _ab_(param){
                     return param ? caml_call2(Async_kernel_Tail[3], tail, v) : 0;
                    }
                    var
                     _ac_ = caml_call1(f, v),
                     _ad_ = caml_call1(Async_kernel_Deferred_std[10], _ac_);
                    return caml_call2
                            (Async_kernel_Deferred_std[5][2], _ad_, _ab_);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _aa_, _$_);
             });
   }
   function filter_map_deprecated(t, f){
    return create
            (function(tail){
              function _W_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _X_ =
                 iter
                  (t,
                   function(v){
                    function _Y_(param){
                     if(! param) return 0;
                     var v = param[1];
                     return caml_call2(Async_kernel_Tail[3], tail, v);
                    }
                    var
                     _Z_ = caml_call1(f, v),
                     ___ = caml_call1(Async_kernel_Deferred_std[10], _Z_);
                    return caml_call2(Async_kernel_Deferred_std[5][2], ___, _Y_);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _X_, _W_);
             });
   }
   function map(t, f){
    return create
            (function(tail){
              function _S_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _T_ =
                 iter
                  (t,
                   function(v){
                    var
                     _U_ = caml_call1(Async_kernel_Tail[3], tail),
                     _V_ = caml_call1(f, v);
                    return caml_call2(Async_kernel_Deferred_std[4], _V_, _U_);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _T_, _S_);
             });
   }
   function map$0(t, f){
    return map
            (t,
             function(a){
              var _R_ = caml_call1(f, a);
              return caml_call1(Async_kernel_Deferred_std[10], _R_);
             });
   }
   function first_n(s, n){
    return create
            (function(tail){
              function loop(s, n){
               if(caml_call2(Core[90], n, 0))
                return caml_call1(Async_kernel_Tail[4], tail);
               function _P_(param){
                if(! param) return caml_call1(Async_kernel_Tail[4], tail);
                var t = param[2], x = param[1];
                caml_call2(Async_kernel_Tail[3], tail, x);
                return loop(t, n - 1 | 0);
               }
               var _Q_ = caml_call1(next, s);
               return caml_call2(Async_kernel_Deferred_std[11], _Q_, _P_);
              }
              return loop(s, n);
             });
   }
   function available_now(t){
    var t$0 = t, ac = 0;
    for(;;){
     var
      _O_ = caml_call1(next, t$0),
      match = caml_call1(Async_kernel_Deferred1[5], _O_);
     if(match){
      var match$0 = match[1];
      if(match$0){
       var
        t$1 = match$0[2],
        x = match$0[1],
        ac$0 = [0, x, ac],
        t$0 = t$1,
        ac = ac$0;
       continue;
      }
     }
     return [0, caml_call1(Core_List[59], ac), t$0];
    }
   }
   function split(opt, _E_, t){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred1[12], 0);
    if(_E_)
     var sth$0 = _E_[1], f = sth$0;
    else
     var f = function(param){return 192584839;};
    var
     reason_for_stopping = caml_call1(Async_kernel_Ivar[12], 0),
     prefix = caml_call1(Async_kernel_Tail[2], 0);
    function finish(v){
     caml_call1(Async_kernel_Tail[4], prefix);
     return caml_call2(Async_kernel_Ivar[14], reason_for_stopping, v);
    }
    function loop(t){
     function _G_(param){
      if(typeof param === "number") return finish([0, 280164845, t]);
      var o = param[2];
      if(! o) return finish(1144100);
      var t$0 = o[2], a = o[1], match = caml_call1(f, a);
      if(typeof match === "number"){
       caml_call2(Async_kernel_Tail[3], prefix, a);
       return loop(t$0);
      }
      var b = match[2];
      return finish([0, 398750242, [0, b, t$0]]);
     }
     var _H_ = 0;
     function _I_(o){return [0, 870035731, o];}
     var
      _J_ = caml_call1(next, t),
      _K_ = [0, caml_call2(Async_kernel_Deferred_std[6], _J_, _I_), _H_];
     function _L_(param){return 280164845;}
     var
      _M_ = [0, caml_call2(Async_kernel_Deferred_std[6], stop, _L_), _K_],
      _N_ = caml_call1(Async_kernel_Deferred_std[7], _M_);
     return caml_call2(Async_kernel_Deferred_std[1], _N_, _G_);
    }
    loop(t);
    var _F_ = caml_call1(Async_kernel_Ivar[19], reason_for_stopping);
    return [0, caml_call1(Async_kernel_Tail[8], prefix), _F_];
   }
   function find(t, f){
    var
     found =
       split
         (0,
          [0,
           function(a){
            return caml_call1(f, a) ? [0, 398750242, a] : 192584839;
           }],
          t)
        [2];
    function _D_(x){
     if(typeof x !== "number" && 398750242 > x[1])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     return x;
    }
    return caml_call2(Async_kernel_Deferred_std[5][2], found, _D_);
   }
   function ungroup(t){
    return create
            (function(tail){
              function _A_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _B_ =
                 iter
                  (t,
                   function(l){
                    function _C_(x){
                     return caml_call2(Async_kernel_Tail[3], tail, x);
                    }
                    caml_call2(Core_List[19], l, _C_);
                    return caml_call1(Async_kernel_Deferred_std[10], 0);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _B_, _A_);
             });
   }
   function interleave(ts){
    return create
            (function(tail){
              var num_open = [0, 1];
              function close(param){
               num_open[1] = num_open[1] - 1 | 0;
               var _z_ = caml_call2(Core[90], num_open[1], 0);
               return _z_ ? caml_call1(Async_kernel_Tail[4], tail) : _z_;
              }
              var
               outer_closed =
                 iter
                  (ts,
                   function(t){
                    num_open[1] = num_open[1] + 1 | 0;
                    var _y_ = copy_to_tail(t, tail);
                    caml_call2(Async_kernel_Deferred_std[11], _y_, close);
                    return caml_call1(Async_kernel_Deferred_std[10], 0);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11], outer_closed, close);
             });
   }
   function take_until(t, d){
    return create
            (function(tail){
              function loop(t){
               function _q_(param){
                if(typeof param !== "number"){
                 var match = param[2];
                 if(match){
                  var t = match[2], x = match[1];
                  caml_call2(Async_kernel_Tail[3], tail, x);
                  return loop(t);
                 }
                }
                return caml_call1(Async_kernel_Tail[4], tail);
               }
               var _r_ = 0;
               function _s_(z){return [0, 870035731, z];}
               var
                _t_ = caml_call1(next, t),
                _u_ =
                  [0, caml_call2(Async_kernel_Deferred_std[6], _t_, _s_), _r_];
               function _v_(param){return 926227490;}
               var
                _w_ =
                  [0, caml_call2(Async_kernel_Deferred_std[6], d, _v_), _u_],
                _x_ = caml_call1(Async_kernel_Deferred_std[7], _w_);
               return caml_call2(Async_kernel_Deferred_std[11], _x_, _q_);
              }
              return loop(t);
             });
   }
   function iter_durably(t, f){
    function _j_(result){
     function loop(t){
      function _k_(param){
       if(! param) return caml_call2(Async_kernel_Ivar[14], result, 0);
       var t = param[2], x = param[1];
       function _m_(z){
        loop(t);
        if(0 === z[0]) return 0;
        var e = z[1], _p_ = caml_call1(Async_kernel_Monitor[5], 0);
        return caml_call3(Async_kernel_Monitor[15], _p_, 0, e);
       }
       function _n_(param){return caml_call1(f, x);}
       var
        _o_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _c_, _b_, _n_);
       return caml_call2(Async_kernel_Deferred_std[1], _o_, _m_);
      }
      var _l_ = caml_call1(next, t);
      return caml_call2(Async_kernel_Deferred_std[1], _l_, _k_);
     }
     return loop(t);
    }
    return caml_call1(Async_kernel_Deferred1[4], _j_);
   }
   function iter_durably_report_end(t, f){
    function _g_(result){
     function loop(t){
      function _h_(param){
       if(! param) return caml_call2(Async_kernel_Ivar[14], result, 0);
       var t = param[2], x = param[1];
       loop(t);
       return caml_call1(f, x);
      }
      var _i_ = caml_call1(next, t);
      return caml_call2(Async_kernel_Deferred_std[1], _i_, _h_);
     }
     return loop(t);
    }
    return caml_call1(Async_kernel_Deferred1[4], _g_);
   }
   function iter_durably$0(t, f){
    var _f_ = iter_durably_report_end(t, f);
    return caml_call1(Async_kernel_Deferred_std[8], _f_);
   }
   function of_fun(f){
    return unfold
            (0,
             function(param){
              function _d_(a){return [0, [0, a, 0]];}
              var _e_ = caml_call1(f, 0);
              return caml_call2(Async_kernel_Deferred_std[5][2], _e_, _d_);
             });
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_stream);
   var
    Async_kernel_Async_stream =
      [0,
       sexp_of_t,
       create,
       next,
       first_exn,
       of_list,
       to_list,
       of_fun,
       copy_to_tail,
       append,
       concat,
       available_now,
       filter_deprecated,
       filter_map_deprecated,
       fold,
       fold$0,
       iter,
       closed,
       iter$0,
       take_until,
       iter_durably,
       iter_durably$0,
       iter_durably_report_end,
       length,
       map,
       map$0,
       first_n,
       unfold,
       split,
       find,
       ungroup,
       interleave];
   runtime.caml_register_global
    (24, Async_kernel_Async_stream, cst_Async_kernel_Async_stream$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_source_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Time_source_i = "Async_kernel__Time_source_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_source_i);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/time_source_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel, "time_source_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_source_i);
   var Async_kernel_Time_source_intf = [0];
   runtime.caml_register_global
    (11, Async_kernel_Time_source_intf, cst_Async_kernel_Time_source_i);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Bvar
//# unitInfo: Requires: Async_kernel__Ivar, Async_kernel__Scheduler1, Async_kernel__Types, Base__Invariant, Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Bvar$0 = "Async_kernel__Bvar",
    cst_async_kernel$0 = "async_kernel",
    cst_has_any_waiters$0 = "has_any_waiters",
    cst_ivar$0 = "ivar",
    cst_src_bvar_ml = "src/bvar.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Types = global_data.Async_kernel__Types,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Bvar$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_bvar_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "bvar.ml");
   var
    _k_ = [0, cst_has_any_waiters$0],
    _i_ = [0, "_"],
    _h_ = [0, cst_src_bvar_ml, 19, 47],
    _g_ = [0, cst_src_bvar_ml, 23, 11],
    _j_ = [0, cst_src_bvar_ml, 14, 303, 325],
    _e_ = [0, cst_ivar$0],
    _f_ = [0, cst_has_any_waiters$0],
    cst_ivar = cst_ivar$0,
    cst_has_any_waiters = cst_has_any_waiters$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Bvar = cst_Async_kernel_Bvar$0;
   function ivar(r){return r[2];}
   function set_ivar(r, v){r[2] = v; return 0;}
   function has_any_waiters(r){return r[1];}
   function set_has_any_waiters(r, v){r[1] = v; return 0;}
   function _a_(r, v){return [0, r[1], v];}
   var
    _b_ = [0, set_ivar],
    ivar$0 = [0, function(param){return 0;}, cst_ivar, _b_, ivar, _a_];
   function _c_(r, v){return [0, v, r[2]];}
   var
    _d_ = [0, set_has_any_waiters],
    has_any_waiters$0 =
      [0,
       function(param){return 0;},
       cst_has_any_waiters,
       _d_,
       has_any_waiters,
       _c_];
   function invariant(invariant_a, param, t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    function _o_(param){
     function check(f){return caml_call2(Base_Invariant[2], repr, f);}
     var
      ivar_fun =
        check
         (function(ivar){
           caml_call2(Async_kernel_Ivar[10], invariant_a, ivar);
           if(caml_call1(Async_kernel_Ivar[17], ivar)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
          }),
      has_any_waiters_fun =
        check
         (function(has_any_waiters){
           var _q_ = caml_call1(Async_kernel_Ivar[22], repr[2]);
           if(! _q_) return _q_;
           if(has_any_waiters) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
          });
     caml_call1(has_any_waiters_fun, has_any_waiters$0);
     return caml_call1(ivar_fun, ivar$0);
    }
    function _p_(x_007){
     function of_a_001(param){return _i_;}
     var
      has_any_waiters_003 = x_007[1],
      ivar_005 = x_007[2],
      arg_006 = caml_call2(Async_kernel_Ivar[9], of_a_001, ivar_005),
      bnds_002 = [0, [1, [0, _e_, [0, arg_006, 0]]], 0],
      arg_004 = caml_call1(Core[323], has_any_waiters_003),
      bnds_002$0 = [0, [1, [0, _f_, [0, arg_004, 0]]], bnds_002];
     return [1, bnds_002$0];
    }
    return caml_call4(Base_Invariant[1], _j_, repr, _p_, _o_);
   }
   function sexp_of_t(param, _n_, t){
    var has_any_waiters = caml_call1(Async_kernel_Types[10][2], t)[1];
    return [1, [0, _k_, [0, caml_call1(Core[323], has_any_waiters), 0]]];
   }
   var include = Async_kernel_Scheduler1[5], create = include[1];
   function broadcast(t, a){
    var
     repr = caml_call1(Async_kernel_Types[10][2], t),
     _l_ = repr[1],
     _m_ =
       _l_
        ? (repr
           [1]
          = 0,
          caml_call2(Async_kernel_Ivar[14], repr[2], a),
          repr[2] = caml_call1(Async_kernel_Ivar[12], 0),
          0)
        : _l_;
    return _m_;
   }
   function wait(t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    repr[1] = 1;
    return caml_call1(Async_kernel_Ivar[19], repr[2]);
   }
   function has_any_waiters$1(t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    return repr[1];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Bvar);
   var
    Async_kernel_Bvar =
      [0, sexp_of_t, invariant, create, wait, broadcast, has_any_waiters$1];
   runtime.caml_register_global
    (26, Async_kernel_Bvar, cst_Async_kernel_Bvar$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_source
//# unitInfo: Requires: Async_kernel__Bvar, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Tail, Async_kernel__Time_ns, Async_kernel__Types, Base__Invariant, Core, Core__Error, Core__Time_ns, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Aborted = "Aborted",
    cst_Async_kernel_Time_source$0 = "Async_kernel__Time_source",
    cst_Happened = "Happened",
    cst_Ok = "Ok",
    cst_Previously_aborted = "Previously_aborted",
    cst_Previously_happened = "Previously_happened",
    cst = "_",
    cst_alarm$0 = "alarm",
    cst_async_kernel$0 = "async_kernel",
    cst_fired$0 = "fired",
    cst_num_fires_to_skip$0 = "num_fires_to_skip",
    cst_scheduled_at$0 = "scheduled_at",
    cst_src_time_source_ml = "src/time_source.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos = "src/time_source.ml:303:33",
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Timing_wheel = global_data.Timing_wheel,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Core_Error = global_data.Core__Error,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Types = global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_source$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_time_source_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "time_source.ml");
   var
    debug = Async_kernel_Debug[1],
    upon = Async_kernel_Deferred1[8],
    choose = Async_kernel_Deferred1[34],
    choice = Async_kernel_Deferred1[29],
    include = Async_kernel_Synchronous_time_[4],
    Job_or_event = include[2],
    invariant_with_jobs = include[20],
    invariant = include[21],
    cst_Time_source_with_timeout_b$0 =
      "Time_source.with_timeout bug: should only abort once",
    cst_Time_source_with_timeout_b =
      "Time_source.with_timeout bug: both completed and timed out",
    _Q_ = [0, 1],
    _P_ = [0, "span"],
    cst_Time_source_every_got_nonp = "Time_source.every got nonpositive span",
    _N_ = [0, -146189108],
    _O_ = [0, 3903734],
    cst_Time_source_Event_run_at = "Time_source.Event.run_at",
    _M_ = [0, cst],
    _L_ = [0, cst],
    cst_Time_source_Event_reschedu = "Time_source.Event.reschedule_at",
    _I_ = [0, cst_Ok],
    _J_ = [0, cst_Previously_aborted],
    _K_ = [0, cst_Previously_happened],
    cst_Clock_Event_abort_exn_fail$0 =
      "Clock.Event.abort_exn failed to abort event that previously happened",
    cst_Clock_Event_abort_exn_fail =
      "Clock.Event.abort_exn failed to abort event that previously aborted",
    _H_ = [0, cst],
    _G_ = [0, cst],
    cst_Time_source_Event_abort = "Time_source.Event.abort",
    _D_ = [0, cst_Ok],
    _E_ = [0, cst_Previously_aborted],
    _F_ = [0, cst_Previously_happened],
    _A_ = [0, cst_Aborted],
    _B_ = [0, cst_Happened],
    _C_ = [0, "Scheduled_at"],
    _y_ = [0, cst],
    _x_ = [0, cst],
    _v_ = [0, cst_src_time_source_ml, 288, 18],
    _w_ = [0, cst_src_time_source_ml, 290, 18],
    _u_ = [0, cst_src_time_source_ml, 299, 43],
    _z_ = [0, cst_src_time_source_ml, 281, 9656, 9680],
    _o_ = [0, "time_source"],
    _p_ = [0, cst_scheduled_at$0],
    _q_ = [0, cst_num_fires_to_skip$0],
    _r_ = [0, cst_fired$0],
    _s_ = [0, "fire"],
    _t_ = [0, cst_alarm$0],
    _e_ = [0, cst_Aborted],
    _f_ = [0, cst_Happened],
    _d_ = [0, cst_src_time_source_ml, 238, 5],
    _a_ = [0, cst],
    _b_ = [0, "events"],
    _c_ = [0, "is_wall_clock"],
    cst_wall_clock = "<wall_clock>",
    cst_scheduled_at = cst_scheduled_at$0,
    cst_num_fires_to_skip = cst_num_fires_to_skip$0,
    cst_fired = cst_fired$0,
    cst_alarm = cst_alarm$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Time_source = cst_Async_kernel_Time_source$0;
   function sexp_of_t(param, _a$_){
    var events = _a$_[4], is_wall_clock = _a$_[8];
    if(is_wall_clock)
     return caml_call1(Sexplib0_Sexp_conv[7], cst_wall_clock);
    var _ba_ = 0, _bb_ = 0;
    function _bc_(param){return _a_;}
    var
     _bd_ =
       [0,
        [1, [0, _b_, [0, caml_call2(Timing_wheel[2], _bc_, events), _bb_]]],
        _ba_];
    return [1,
            [0,
             [1, [0, _c_, [0, caml_call1(Core[323], is_wall_clock), 0]]],
             _bd_]];
   }
   function sexp_of_t$0(x_002){return sexp_of_t(Core[212], x_002);}
   var Read_write = [0, sexp_of_t$0, invariant, invariant_with_jobs];
   function sexp_of_t$1(x_003){return sexp_of_t(Core[171], x_003);}
   function read_only(t){return t;}
   var
    create = Async_kernel_Scheduler1[81],
    wall_clock = Async_kernel_Scheduler1[82];
   function alarm_precision(t){return caml_call1(Timing_wheel[10], t[4]);}
   function is_wall_clock(t){return t[8];}
   function next_alarm_fires_at(t){return caml_call1(Timing_wheel[39], t[4]);}
   function timing_wheel_now(t){return caml_call1(Timing_wheel[11], t[4]);}
   function id(t){return t[1];}
   function now(t){
    return t[8]
            ? caml_call1(Async_kernel_Time_ns[42], 0)
            : timing_wheel_now(t);
   }
   var send_exn = [0, Async_kernel_Monitor[15]];
   function advance_directly(t, to){
    return caml_call3(Async_kernel_Synchronous_time_[28], t, to, send_exn);
   }
   function advance_directly_by(t, by){
    var _a__ = now(t);
    return advance_directly
            (t, caml_call2(Async_kernel_Time_ns[119], _a__, by));
   }
   function fire_past_alarms(t){
    return caml_call2(Async_kernel_Synchronous_time_[30], t, send_exn);
   }
   function yield$0(t){
    var _a9_ = caml_call1(Async_kernel_Scheduler1[15], t[9]);
    return caml_call1(Async_kernel_Bvar[4], _a9_);
   }
   function bind_unit(t, f){
    if(caml_call1(Async_kernel_Deferred1[7], t)) return caml_call1(f, 0);
    function _a8_(param){return caml_call1(f, 0);}
    return caml_call2(Async_kernel_Deferred_std[5][1], t, _a8_);
   }
   function advance_by_alarms(wait_for, t, to){
    function run_queued_alarms(param){
     if(! wait_for) return yield$0(t);
     var f = wait_for[1];
     return caml_call1(f, 0);
    }
    function walk_alarms(param){
     var
      match =
        caml_call1(Async_kernel_Synchronous_time_[27], t)
         ? [0, now(t), 835248231]
         : [0, to, -53446108],
      next = match[2],
      advance_to = match[1];
     caml_call3(Async_kernel_Synchronous_time_[29], t, advance_to, send_exn);
     fire_past_alarms(t);
     function _a6_(param){
      if(835248231 <= next) return walk_alarms(0);
      var _a7_ = timing_wheel_now(t);
      return caml_call2(Async_kernel_Time_ns[104], _a7_, to)
              ? walk_alarms(0)
              : caml_call1(Async_kernel_Deferred_std[10], 0);
     }
     return bind_unit(run_queued_alarms(0), _a6_);
    }
    function _a4_(param){return walk_alarms(0);}
    var _a5_ = run_queued_alarms(0);
    return caml_call2(Async_kernel_Deferred_std[5][1], _a5_, _a4_);
   }
   function advance_by_max_alarms_in_each_(wait_for, t, to){
    function run_queued_alarms(param){
     if(! wait_for) return yield$0(t);
     var f = wait_for[1];
     return caml_call1(f, 0);
    }
    function finish(param){
     advance_directly(t, to);
     fire_past_alarms(t);
     return run_queued_alarms(0);
    }
    function walk_alarms(param){
     var match = next_alarm_fires_at(t);
     if(! match) return finish(0);
     var next_alarm_fires_at$0 = match[1];
     if(caml_call2(Async_kernel_Time_ns[100], next_alarm_fires_at$0, to))
      return finish(0);
     advance_directly(t, caml_call1(Timing_wheel[37], t[4]));
     fire_past_alarms(t);
     var queued_alarms_ran = run_queued_alarms(0);
     return bind_unit(queued_alarms_ran, walk_alarms);
    }
    fire_past_alarms(t);
    function _a2_(param){return walk_alarms(0);}
    var _a3_ = run_queued_alarms(0);
    return caml_call2(Async_kernel_Deferred_std[5][1], _a3_, _a2_);
   }
   function advance_by_alarms_by(wait_for, t, by){
    var _a1_ = now(t);
    return advance_by_alarms
            (wait_for, t, caml_call2(Async_kernel_Time_ns[119], _a1_, by));
   }
   function span_to_time(t, span){
    var _a0_ = now(t);
    return caml_call2(Async_kernel_Time_ns[119], _a0_, span);
   }
   function run_at_internal(t, time, f$0, a){
    var
     execution_context = caml_call1(Async_kernel_Scheduler1[73], t[9]),
     _aZ_ = caml_call1(Timing_wheel[11], t[4]);
    if(! caml_call2(Async_kernel_Time_ns[103], time, _aZ_)){
     caml_call4(Async_kernel_Scheduler1[63], t[9], execution_context, f$0, a);
     return caml_call1(Timing_wheel[5][2], 0);
    }
    var
     _aX_ =
       caml_call4
        (Async_kernel_Scheduler1[76], t[9], execution_context, f$0, a),
     _aY_ = caml_call1(Job_or_event[2], _aX_),
     alarm = caml_call3(Timing_wheel[26], t[4], time, _aY_),
     match = t[9][23];
    if(match){var f = match[1]; caml_call1(f, time);}
    return alarm;
   }
   function run_at(t, time, f, a){run_at_internal(t, time, f, a); return 0;}
   function run_after(t, span, f, a){
    return run_at(t, span_to_time(t, span), f, a);
   }
   function fill(result){return caml_call2(Async_kernel_Ivar[14], result, 0);}
   function at(t, time){
    var _aW_ = caml_call1(Timing_wheel[11], t[4]);
    if(caml_call2(Async_kernel_Time_ns[101], time, _aW_))
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    var result = caml_call1(Async_kernel_Ivar[12], 0);
    run_at_internal(t, time, fill, result);
    return caml_call1(Async_kernel_Ivar[19], result);
   }
   function after(t, span){return at(t, span_to_time(t, span));}
   function remove_alarm(t, alarm){
    var
     job_or_event = caml_call2(Timing_wheel[5][5], t[4], alarm),
     k = caml_call1(Job_or_event[5][1], job_or_event),
     match = caml_call2(Job_or_event[5][2], k, job_or_event);
    if(! k) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    caml_call2(Async_kernel_Scheduler1[62], t[9], match);
    return caml_call2(Timing_wheel[29], t[4], alarm);
   }
   function sexp_of_t$2(of_a_007, of_h_008, param){
    if(0 === param[0]){
     var arg0_009 = param[1], res0_010 = caml_call1(of_a_007, arg0_009);
     return [1, [0, _e_, [0, res0_010, 0]]];
    }
    var arg0_011 = param[1], res0_012 = caml_call1(of_h_008, arg0_011);
    return [1, [0, _f_, [0, res0_012, 0]]];
   }
   var Fired = [0, sexp_of_t$2];
   function scheduled_at(r){return r[5];}
   function set_scheduled_at(r, v){r[5] = v; return 0;}
   function num_fires_to_skip(r){return r[4];}
   function set_num_fires_to_skip(r, v){r[4] = v; return 0;}
   function fired(r){return r[3];}
   function alarm(r){return r[1];}
   function set_alarm(r, v){r[1] = v; return 0;}
   function _g_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6]];}
   var
    _h_ = [0, set_scheduled_at],
    scheduled_at$0 =
      [0,
       function(param){return 0;},
       cst_scheduled_at,
       _h_,
       scheduled_at,
       _g_];
   function _i_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}
   var
    _j_ = [0, set_num_fires_to_skip],
    num_fires_to_skip$0 =
      [0,
       function(param){return 0;},
       cst_num_fires_to_skip,
       _j_,
       num_fires_to_skip,
       _i_];
   function _k_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}
   var
    _l_ = 0,
    fired$0 = [0, function(param){return 0;}, cst_fired, _l_, fired, _k_];
   function _m_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}
   var
    _n_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _n_, alarm, _m_];
   function sexp_of_t$3(of_a_015, of_h_016, param){
    var
     alarm_018 = param[1],
     fired_022 = param[3],
     num_fires_to_skip_024 = param[4],
     scheduled_at_026 = param[5],
     time_source_028 = param[6],
     arg_029 = caml_call1(Async_kernel_Synchronous_time_[5], time_source_028),
     bnds_017 = [0, [1, [0, _o_, [0, arg_029, 0]]], 0],
     arg_027 = caml_call1(Async_kernel_Time_ns[98], scheduled_at_026),
     bnds_017$0 = [0, [1, [0, _p_, [0, arg_027, 0]]], bnds_017],
     arg_025 = caml_call1(Core[389], num_fires_to_skip_024),
     bnds_017$1 = [0, [1, [0, _q_, [0, arg_025, 0]]], bnds_017$0],
     _aT_ = caml_call2(Fired[1], of_a_015, of_h_016),
     arg_023 = caml_call2(Async_kernel_Ivar[9], _aT_, fired_022),
     bnds_017$2 = [0, [1, [0, _r_, [0, arg_023, 0]]], bnds_017$1];
    function _aU_(_aV_){return 0;}
    var
     arg_021 = caml_call1(Sexplib0_Sexp_conv[24], _aU_),
     bnds_017$3 = [0, [1, [0, _s_, [0, arg_021, 0]]], bnds_017$2],
     arg_019 = caml_call2(Timing_wheel[5][1], Job_or_event[6], alarm_018),
     bnds_017$4 = [0, [1, [0, _t_, [0, arg_019, 0]]], bnds_017$3];
    return [1, bnds_017$4];
   }
   function sexp_of_t_unit(x_030){
    return sexp_of_t$3(Core[620], Core[620], x_030);
   }
   function fired$1(t){return caml_call1(Async_kernel_Ivar[19], t[3]);}
   function invariant$0(invariant_a, invariant_h, t){
    function _aM_(param){
     var events = t[6][4];
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      scheduled_at_fun =
        check
         (function(scheduled_at){
           var _aS_ = caml_call2(Timing_wheel[28], events, t[1]);
           if(! _aS_) return _aS_;
           var
            expect = caml_call2(Timing_wheel[5][3], events, t[1]),
            sexpifier = Async_kernel_Time_ns[98],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_032, b_033){
            return caml_call2(Async_kernel_Time_ns[107], a_032, b_033);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    scheduled_at);
          }),
      num_fires_to_skip_fun =
        check
         (function(num_fires_to_skip){
           if(caml_call2(Async_kernel_Import[1], num_fires_to_skip, 0))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
          }),
      fired_fun =
        check
         (function(fired){
           var
            _aR_ = caml_call1(Async_kernel_Ivar[19], fired),
            match = caml_call1(Async_kernel_Deferred1[5], _aR_);
           if(! match) return 0;
           var match$0 = match[1];
           if(0 === match$0[0]){
            var a = match$0[1];
            return caml_call1(invariant_a, a);
           }
           var h = match$0[1];
           return caml_call1(invariant_h, h);
          }),
      alarm_fun =
        check
         (function(alarm){
           if(caml_call1(Async_kernel_Ivar[18], t[3])){
            if(caml_call2(Timing_wheel[28], events, alarm))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
            return 0;
           }
           var _aP_ = caml_call2(Timing_wheel[28], events, alarm);
           if(! _aP_) return _aP_;
           var _aQ_ = caml_call2(Timing_wheel[5][5], events, alarm);
           if(caml_call1(Job_or_event[4], _aQ_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
          });
     caml_call1(alarm_fun, alarm$0);
     caml_call1(fired_fun, fired$0);
     caml_call1(num_fires_to_skip_fun, num_fires_to_skip$0);
     caml_call1(scheduled_at_fun, scheduled_at$0);
     return 0;
    }
    function _aN_(x_031){
     function _aO_(param){return _x_;}
     return sexp_of_t$3(function(param){return _y_;}, _aO_, x_031);
    }
    return caml_call4(Base_Invariant[1], _z_, t, _aN_, _aM_);
   }
   function sexp_of_t$4(of_a_034, of_h_035, param){
    switch(param[0]){
      case 0:
       var arg0_036 = param[1], res0_037 = caml_call1(of_a_034, arg0_036);
       return [1, [0, _A_, [0, res0_037, 0]]];
      case 1:
       var arg0_038 = param[1], res0_039 = caml_call1(of_h_035, arg0_038);
       return [1, [0, _B_, [0, res0_039, 0]]];
      default:
       var
        arg0_040 = param[1],
        res0_041 = caml_call1(Async_kernel_Time_ns[98], arg0_040);
       return [1, [0, _C_, [0, res0_041, 0]]];
    }
   }
   var Status = [0, sexp_of_t$4];
   function status(t){
    var
     _aL_ = caml_call1(Async_kernel_Ivar[19], t[3]),
     match = caml_call1(Async_kernel_Deferred1[5], _aL_);
    if(! match) return [2, t[5]];
    var match$0 = match[1];
    if(0 === match$0[0]){var a = match$0[1]; return [0, a];}
    var h = match$0[1];
    return [1, h];
   }
   function sexp_of_t$5(of_a_044, of_h_045, param){
    if(typeof param === "number") return _D_;
    if(0 === param[0]){
     var arg0_046 = param[1], res0_047 = caml_call1(of_a_044, arg0_046);
     return [1, [0, _E_, [0, res0_047, 0]]];
    }
    var arg0_048 = param[1], res0_049 = caml_call1(of_h_045, arg0_048);
    return [1, [0, _F_, [0, res0_049, 0]]];
   }
   var Abort_result = [0, sexp_of_t$5];
   function abort(t, a){
    if(debug){
     var
      _aI_ =
        function(x_052){
         function _aK_(param){return _G_;}
         return sexp_of_t$3(function(param){return _H_;}, _aK_, x_052);
        };
     caml_call3(Async_kernel_Debug[15], cst_Time_source_Event_abort, t, _aI_);
    }
    var
     _aJ_ = fired$1(t),
     match = caml_call1(Async_kernel_Deferred1[5], _aJ_);
    if(! match){
     caml_call2(Async_kernel_Ivar[14], t[3], [0, a]);
     var alarm = t[1], t$0 = t[6];
     if(caml_call2(Timing_wheel[28], t$0[4], alarm)) remove_alarm(t$0, alarm);
     return 0;
    }
    var match$0 = match[1];
    if(0 === match$0[0]){var a$0 = match$0[1]; return [0, a$0];}
    var h = match$0[1];
    return [1, h];
   }
   function abort_exn(t, a){
    var match = abort(t, a);
    if(typeof match === "number") return 0;
    if(0 === match[0]){
     var
      _aG_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Clock_Event_abort_exn_fail);
     return caml_call1(Core[261], _aG_);
    }
    var
     _aH_ =
       caml_call1(Sexplib0_Sexp_conv[7], cst_Clock_Event_abort_exn_fail$0);
    return caml_call1(Core[261], _aH_);
   }
   function abort_if_possible(t, a){abort(t, a); return 0;}
   function schedule(t){t[1] = run_at_internal(t[6], t[5], t[2], 0); return;}
   function sexp_of_t$6(of_a_053, of_h_054, param){
    if(typeof param === "number") return _I_;
    if(0 === param[0]){
     var arg0_055 = param[1], res0_056 = caml_call1(of_a_053, arg0_055);
     return [1, [0, _J_, [0, res0_056, 0]]];
    }
    var arg0_057 = param[1], res0_058 = caml_call1(of_h_054, arg0_057);
    return [1, [0, _K_, [0, res0_058, 0]]];
   }
   var Reschedule_result = [0, sexp_of_t$6];
   function reschedule_at(t, at){
    if(debug){
     var
      _aC_ =
        function(param){
         var arg1_062 = param[2], arg0_061 = param[1];
         function _aF_(param){return _L_;}
         var
          res0_063 = sexp_of_t$3(function(param){return _M_;}, _aF_, arg0_061),
          res1_064 = caml_call1(Async_kernel_Time_ns[98], arg1_062);
         return [1, [0, res0_063, [0, res1_064, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_reschedu,
       [0, t, at],
       _aC_);
    }
    var
     _aD_ = fired$1(t),
     match = caml_call1(Async_kernel_Deferred1[5], _aD_);
    if(match){
     var match$0 = match[1];
     if(0 === match$0[0]){var a = match$0[1]; return [0, a];}
     var h = match$0[1];
     return [1, h];
    }
    var
     events = t[6][4],
     is_in_timing_wheel = caml_call2(Timing_wheel[28], events, t[1]),
     _aE_ = caml_call1(Timing_wheel[11], events),
     am_trying_to_reschedule_in_the =
       caml_call2(Async_kernel_Time_ns[103], at, _aE_);
    t[5] = at;
    if(am_trying_to_reschedule_in_the)
     if(is_in_timing_wheel)
      caml_call3(Timing_wheel[30], events, t[1], at);
     else{t[4] = t[4] + 1 | 0; schedule(t);}
    else if(is_in_timing_wheel){
     caml_call1(t[6][7], t[1]);
     caml_call2(Timing_wheel[29], events, t[1]);
    }
    return 0;
   }
   function reschedule_after(t, span){
    return reschedule_at(t, span_to_time(t[6], span));
   }
   function run_at$0(time_source, scheduled_at, f, z){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_run_at,
       scheduled_at,
       Async_kernel_Time_ns[98]);
    var _av_ = 0, _aw_ = caml_call1(Async_kernel_Ivar[12], 0);
    function _ax_(_aB_){return 0;}
    var
     t =
       [0,
        caml_call1(Timing_wheel[5][2], 0),
        _ax_,
        _aw_,
        _av_,
        scheduled_at,
        time_source];
    function fire(param){
     var _ay_ = caml_call1(Async_kernel_Ivar[17], t[3]);
     if(_ay_){
      if(caml_call2(Async_kernel_Import[4], t[4], 0)){t[4] = t[4] - 1 | 0; return 0;}
      var
       result = caml_call1(f, z),
       _az_ = caml_call1(Async_kernel_Ivar[17], t[3]);
      if(_az_) return caml_call2(Async_kernel_Ivar[14], t[3], [1, result]);
      var _aA_ = _az_;
     }
     else
      var _aA_ = _ay_;
     return _aA_;
    }
    t[2] = fire;
    schedule(t);
    return t;
   }
   function at$0(time_source, time){
    var _at_ = 0;
    return run_at$0(time_source, time, function(_au_){return 0;}, _at_);
   }
   function run_after$0(time_source, span, f, a){
    return run_at$0(time_source, span_to_time(time_source, span), f, a);
   }
   function after$0(time_source, span){
    return at$0(time_source, span_to_time(time_source, span));
   }
   function at_times(opt, t, next_time){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred1[12], 0);
    var tail = caml_call1(Async_kernel_Tail[2], 0);
    function loop(param){
     function _ap_(param){
      return 936767357 <= param
              ? (caml_call2(Async_kernel_Tail[3], tail, 0), loop(0))
              : caml_call1(Async_kernel_Tail[4], tail);
     }
     var _aq_ = 0;
     function _ar_(param){return 936767357;}
     var
      _as_ =
        [0, caml_call2(choice, at(t, caml_call1(next_time, 0)), _ar_), _aq_];
     return caml_call2
             (upon,
              caml_call1
               (choose,
                [0,
                 caml_call2(choice, stop, function(param){return 926227490;}),
                 _as_]),
              _ap_);
    }
    loop(0);
    return caml_call1(Async_kernel_Tail[8], tail);
   }
   function at_varying_intervals(stop, t, compute_span){
    return at_times
            (stop,
             t,
             function(param){
              var _an_ = caml_call1(compute_span, 0), _ao_ = now(t);
              return caml_call2(Async_kernel_Time_ns[119], _ao_, _an_);
             });
   }
   function at_intervals(start, stop, t, interval){
    if(start) var x = start[1], start$0 = x; else var start$0 = now(t);
    return at_times
            (stop,
             t,
             function(param){
              var _am_ = now(t);
              return caml_call5
                      (Async_kernel_Time_ns[57], 0, start$0, _am_, interval, 0);
             });
   }
   var immediately = 0;
   function run_repeatedly(opt, stop, _ag_, _af_, time_source, f, continue$0){
    if(opt)
     var sth = opt[1], start = sth;
    else
     var start = caml_call1(Async_kernel_Deferred_std[10], 0);
    if(_ag_)
     var sth$0 = _ag_[1], continue_on_error = sth$0;
    else
     var continue_on_error = 1;
    if(_af_)
     var sth$1 = _af_[1], finished = sth$1;
    else
     var finished = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call2
            (upon,
             start,
             function(param){
              var alarm = [0, caml_call1(Timing_wheel[5][2], 0)];
              if(stop){
               var stop$0 = stop[1];
               caml_call2
                (upon,
                 stop$0,
                 function(param){
                  var
                   _al_ =
                     caml_call2(Timing_wheel[28], time_source[4], alarm[1]);
                  return _al_
                          ? (remove_alarm
                             (time_source, alarm[1]),
                            caml_call2(Async_kernel_Ivar[16], finished, 0))
                          : _al_;
                 });
               var stop$1 = stop$0;
              }
              else
               var stop$1 = caml_call1(Async_kernel_Deferred1[12], 0);
              function run_f(param){
               if(caml_call1(Async_kernel_Deferred1[7], stop$1))
                return caml_call2(Async_kernel_Ivar[16], finished, 0);
               if(continue_on_error)
                return caml_call2
                        (upon,
                         caml_call7
                          (Async_kernel_Monitor[16], 0, 0, 0, 0, _O_, _N_, f),
                         continue_try_with);
               var d = caml_call1(f, 0);
               return caml_call1(Async_kernel_Deferred1[7], d)
                       ? continue_f(0)
                       : caml_call2(upon, d, continue_f);
              }
              function continue_f(param){
               if(caml_call1(Async_kernel_Deferred1[7], stop$1))
                return caml_call2(Async_kernel_Ivar[16], finished, 0);
               var _aj_ = 0;
               if(typeof continue$0 === "number")
                var _ak_ = caml_call1(Timing_wheel[11], time_source[4]);
               else if(0 === continue$0[0])
                var
                 span = continue$0[1],
                 _ak_ = span_to_time(time_source, span);
               else
                var
                 interval = continue$0[2],
                 base = continue$0[1],
                 _ai_ = now(time_source),
                 _ak_ =
                   caml_call5
                    (Async_kernel_Time_ns[57], 0, base, _ai_, interval, 0);
               alarm[1] = run_at_internal(time_source, _ak_, run_f, _aj_);
               return 0;
              }
              function continue_try_with(or_error){
               if(0 !== or_error[0]){
                var
                 error = or_error[1],
                 _ah_ = caml_call1(Async_kernel_Monitor[5], 0);
                caml_call3(Async_kernel_Monitor[15], _ah_, 0, error);
               }
               return continue_f(0);
              }
              return run_f(0);
             });
   }
   function every(start, stop, continue_on_error, finished, t, span, f){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][76])){
     var
      _ad_ =
        [0, [1, [0, _P_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      _ae_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Time_source_every_got_nonp),
          _ad_]];
     caml_call1(Core[261], _ae_);
    }
    return run_repeatedly
            (start, stop, continue_on_error, finished, t, f, [0, span]);
   }
   function every$0(start, stop, continue_on_error, t, span, f){
    return every
            (start,
             stop,
             continue_on_error,
             0,
             t,
             span,
             function(param){
              caml_call1(f, 0);
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function run_at_intervals(start, stop, continue_on_error, t, interval, f){
    var now$0 = now(t);
    if(start)
     var
      start$0 = start[1],
      start$1 =
        [0,
         at
          (t,
           caml_call5
            (Async_kernel_Time_ns[57], _Q_, start$0, now$0, interval, 0))],
      base = start$0;
    else
     var start$1 = 0, base = now$0;
    return run_repeatedly
            (start$1, stop, continue_on_error, 0, t, f, [1, base, interval]);
   }
   function run_at_intervals$0(start, stop, continue_on_error, t, interval, f){
    return run_at_intervals
            (start,
             stop,
             continue_on_error,
             t,
             interval,
             function(param){
              caml_call1(f, 0);
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function with_timeout(t, span, d){
    var timeout = after$0(t, span), ___ = 0;
    function _$_(param){
     if(0 !== param[0]) return 642269825;
     var
      _ac_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Time_source_with_timeout_b);
     return caml_call1(Core[261], _ac_);
    }
    var _aa_ = [0, caml_call2(choice, fired$1(timeout), _$_), ___];
    return caml_call1
            (choose,
             [0,
              caml_call2
               (choice,
                d,
                function(v){
                 var match = abort(timeout, 0);
                 a:
                 if(typeof match !== "number" && 0 === match[0]){
                  var
                   _ab_ =
                     caml_call1
                      (Sexplib0_Sexp_conv[7], cst_Time_source_with_timeout_b$0);
                  caml_call1(Core[261], _ab_);
                  break a;
                 }
                 return [0, 1025039613, v];
                }),
              _aa_]);
   }
   function with_timeout_exn(t, span, d, error){
    function _Y_(param){
     if(typeof param === "number") return caml_call1(Core_Error[30], error);
     var result = param[2];
     return result;
    }
    var _Z_ = with_timeout(t, span, d);
    return caml_call2(Async_kernel_Deferred1[18], _Z_, _Y_);
   }
   function duration_of(t, f){
    var start = now(t);
    function f$0(result){
     var
      _X_ = now(t),
      duration = caml_call2(Async_kernel_Time_ns[49], _X_, start);
     return [0, result, duration];
    }
    var t$0 = caml_call1(f, 0);
    if(! caml_call1(Async_kernel_Deferred1[7], t$0))
     return caml_call2(Async_kernel_Deferred1[18], t$0, f$0);
    var _W_ = f$0(caml_call1(Async_kernel_Deferred1[6], t$0));
    return caml_call1(Async_kernel_Deferred_std[10], _W_);
   }
   function of_synchronous(t){return t;}
   function to_synchronous(t){return t;}
   function advance_directly_if_quiescent(t, time){
    var
     t$0 = t[9],
     _R_ = caml_call1(Async_kernel_Scheduler1[56], t$0),
     _S_ = caml_call2(Async_kernel_Import[4], _R_, 0),
     _T_ = _S_ || caml_call1(Async_kernel_Bvar[6], t$0[24]);
    if(_T_)
     var is_quescent = _T_;
    else{
     var _U_ = caml_call1(Async_kernel_Synchronous_time_[42], t);
     if(_U_)
      var is_quescent = _U_;
     else{
      var wheel = t[4];
      if(caml_call1(Timing_wheel[13], wheel))
       var _V_ = 0;
      else
       var
        next_alarm = caml_call1(Timing_wheel[40], wheel),
        _V_ = caml_call2(Async_kernel_Time_ns[101], next_alarm, time);
      var is_quescent = _V_;
     }
    }
    return is_quescent ? 0 : (advance_directly(t, time), 1);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_source);
   var
    Async_kernel_Time_source =
      [0,
       [0, sexp_of_t],
       Read_write,
       Async_kernel_Types[21],
       sexp_of_t$1,
       id,
       invariant,
       invariant_with_jobs,
       read_only,
       create,
       wall_clock,
       alarm_precision,
       is_wall_clock,
       next_alarm_fires_at,
       now,
       timing_wheel_now,
       advance_directly,
       advance_directly,
       advance_directly_by,
       advance_directly_by,
       fire_past_alarms,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_by_alarms_by,
       [0, immediately],
       run_repeatedly,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       with_timeout_exn,
       duration_of,
       [0,
        sexp_of_t$3,
        sexp_of_t_unit,
        invariant$0,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        Abort_result,
        abort,
        abort_exn,
        abort_if_possible,
        Fired,
        fired$1,
        Reschedule_result,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals,
       run_at_intervals$0,
       of_synchronous,
       to_synchronous,
       advance_directly_if_quiescent];
   runtime.caml_register_global
    (82, Async_kernel_Time_source, cst_Async_kernel_Time_source$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Cycle_hook
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Cycle_hook = "Async_kernel__Cycle_hook",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Cycle_hook);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/cycle_hook.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel, "cycle_hook.ml");
   var Handle = [0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Cycle_hook);
   var Async_kernel_Cycle_hook = [0, Handle];
   runtime.caml_register_global
    (11, Async_kernel_Cycle_hook, cst_Async_kernel_Cycle_hook);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler
//# unitInfo: Requires: Async_kernel__Async_stream, Async_kernel__Bvar, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Job_queue, Async_kernel__Monitor, Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Tail, Async_kernel__Time_ns, Async_kernel__Types, Async_kernel_config, Base__Backtrace, Core, Core__Array, Core__Deque, Core__Error, Core__Gc, Core__Hashtbl, Core__Option, Core__Time_ns, Heap_block, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdlib, Stdlib__Gc, Thread_safe_queue, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler$0 = "Async_kernel__Scheduler",
    cst_async_kernel$0 = "async_kernel",
    cst_src_scheduler_ml = "src/scheduler.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Deque = global_data.Core__Deque,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Assert_failure = global_data.Assert_failure,
    Base_Backtrace = global_data.Base__Backtrace,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Core_Error = global_data.Core__Error,
    Core_Option = global_data.Core__Option,
    Core_Array = global_data.Core__Array,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Async_kernel_Job_queue = global_data.Async_kernel__Job_queue,
    Heap_block = global_data.Heap_block,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Stdlib = global_data.Stdlib,
    Core_Gc = global_data.Core__Gc,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Async_kernel_Types = global_data.Async_kernel__Types,
    Timing_wheel = global_data.Timing_wheel,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_scheduler_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "scheduler.ml");
   var
    start_cycle = Async_kernel_Scheduler1[78],
    create_job = Async_kernel_Scheduler1[76],
    with_execution_context = Async_kernel_Scheduler1[75],
    with_execution_context1 = Async_kernel_Scheduler1[74],
    current_execution_context = Async_kernel_Scheduler1[73],
    check_access = Async_kernel_Scheduler1[71],
    t_ref = Async_kernel_Scheduler1[70],
    backtrace_of_first_job = Async_kernel_Scheduler1[69],
    set_check_access = Async_kernel_Scheduler1[68],
    is_dead = Async_kernel_Scheduler1[67],
    enqueue_job = Async_kernel_Scheduler1[64],
    enqueue = Async_kernel_Scheduler1[63],
    free_job = Async_kernel_Scheduler1[62],
    invariant = Async_kernel_Scheduler1[61],
    last_cycle_num_jobs = Async_kernel_Scheduler1[58],
    num_jobs_run = Async_kernel_Scheduler1[57],
    num_pending_jobs = Async_kernel_Scheduler1[56],
    uncaught_exn = Async_kernel_Scheduler1[55],
    uncaught_exn_unwrapped = Async_kernel_Scheduler1[54],
    sexp_of_t = Async_kernel_Scheduler1[53],
    last_cycle_time = Async_kernel_Scheduler1[29],
    Very_low_priority_worker = Async_kernel_Scheduler1[6],
    debug = Async_kernel_Scheduler1[3],
    set_execution_context = Async_kernel_Scheduler1[2],
    events = Async_kernel_Scheduler1[1],
    t = Async_kernel_Scheduler1[72],
    include = Async_kernel_Monitor[26],
    within = include[1],
    within$0 = include[2],
    within_v = include[3],
    schedule = include[4],
    schedule$0 = include[5],
    within_context = include[6],
    preserve_execution_context = include[7],
    preserve_execution_context$0 = include[8],
    _c_ = [0, cst_src_scheduler_ml, 345, 4],
    _d_ = [0, 1],
    _b_ = [0, "n"],
    cst_Scheduler_yield_every_got_ =
      "Scheduler.yield_every got nonpositive count",
    cst_reset_in_forked_process = "reset_in_forked_process",
    cst_Async_scheduler_is_unusabl =
      "Async scheduler is unusable due to [make_async_unusable]",
    _a_ = [0, "scheduler"],
    cst_run_cycles_until_no_jobs_r$0 =
      "run_cycles_until_no_jobs_remain cannot proceed -- scheduler is dead",
    cst_run_cycles_until_no_jobs_r =
      "run_cycles_until_no_jobs_remain starting",
    cst_run_cycles_until_no_jobs_r$1 =
      "run_cycles_until_no_jobs_remain finished",
    cst_run_cycle_starting = "run_cycle starting",
    cst_run_cycle_finished = "run_cycle finished",
    cst_enqueueing_finalizer_using =
      "enqueueing finalizer (using 'last' semantic)",
    cst_adding_finalizer_using_las =
      "adding finalizer (using 'last' semantic)",
    cst_enqueueing_finalizer = "enqueueing finalizer",
    cst_adding_finalizer = "adding finalizer",
    cst_Attempted_to_remove_a_cycl$0 =
      "Attempted to remove a cycle end hook which has already been removed.",
    cst_Attempted_to_remove_a_cycl =
      "Attempted to remove a cycle start hook which has already been removed.",
    cst_Scheduler_remove_single_cy =
      "Scheduler.remove_single_cycle_hook called with a hook that isn't registered",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler = cst_Async_kernel_Scheduler$0;
   function find_local(key){
    var _ah_ = caml_call1(current_execution_context, caml_call1(t, 0));
    return caml_call2(Async_kernel_Execution_context[9], _ah_, key);
   }
   function with_local(key, value, f){
    var
     t$0 = caml_call1(t, 0),
     _ag_ = caml_call1(current_execution_context, t$0),
     execution_context =
       caml_call3(Async_kernel_Execution_context[10], _ag_, key, value);
    return caml_call3(with_execution_context, t$0, execution_context, f);
   }
   var main_execution_context = caml_call1(t, 0)[6];
   function can_run_a_job(t){
    var
     _ac_ = caml_call1(num_pending_jobs, t),
     _ad_ = caml_call2(Async_kernel_Import[4], _ac_, 0);
    if(_ad_)
     var _ae_ = _ad_;
    else{
     var _af_ = caml_call1(Async_kernel_Bvar[6], t[24]);
     if(! _af_) return caml_call1(Async_kernel_Bvar[6], t[25]);
     var _ae_ = _af_;
    }
    return _ae_;
   }
   function has_upcoming_event(t){
    var _ab_ = caml_call1(events, t);
    return 1 - caml_call1(Timing_wheel[13], _ab_);
   }
   function next_upcoming_event(t){
    var _aa_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[39], _aa_);
   }
   function next_upcoming_event_exn(t){
    var _$_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[40], _$_);
   }
   function event_precision(t){
    var ___ = caml_call1(events, t);
    return caml_call1(Timing_wheel[10], ___);
   }
   function cycle_start(t){return t[10];}
   function run_every_cycle_start(t, f){
    t[12] = caml_call2(Core_Array[26], [0, f], t[12]);
    return 0;
   }
   function run_every_cycle_end(t, f){
    t[14] = caml_call2(Core_Array[26], [0, f], t[14]);
    return 0;
   }
   function add_every_cycle_start_hook(t, f){
    var handle = caml_call1(Async_kernel_Types[20][45], 0);
    caml_call3(Core_Hashtbl[39], t[13], handle, f);
    run_every_cycle_start(t, f);
    return handle;
   }
   function add_every_cycle_end_hook(t, f){
    var handle = caml_call1(Async_kernel_Types[20][45], 0);
    caml_call3(Core_Hashtbl[39], t[15], handle, f);
    run_every_cycle_end(t, f);
    return handle;
   }
   function remove_single_cycle_hook(arr, f){
    function f$0(param, g){return f === g ? 1 : 0;}
    var match = caml_call2(Core_Array[54], arr, f$0);
    if(match)
     var
      idx = match[1][1],
      _X_ =
        function(i){
         if(caml_call2(Async_kernel_Import[5], i, idx))
          return caml_check_bound(arr, i)[1 + i];
         var _Z_ = i + 1 | 0;
         return caml_check_bound(arr, _Z_)[1 + _Z_];
        },
      match$0 = [0, caml_call2(Core_Array[56], arr.length - 1 - 1 | 0, _X_)];
    else
     var match$0 = 0;
    if(match$0){var arr$0 = match$0[1]; return arr$0;}
    var
     _Y_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_remove_single_cy);
    return caml_call1(Core[261], _Y_);
   }
   function remove_every_cycle_start_hook_(t, handle){
    var match = caml_call2(Core_Hashtbl[64], t[13], handle);
    if(! match) return caml_call1(Core[6], cst_Attempted_to_remove_a_cycl);
    var f = match[1];
    t[12] = remove_single_cycle_hook(t[12], f);
    return 0;
   }
   function remove_every_cycle_end_hook_ex(t, handle){
    var match = caml_call2(Core_Hashtbl[64], t[15], handle);
    if(! match) return caml_call1(Core[6], cst_Attempted_to_remove_a_cycl$0);
    var f = match[1];
    t[14] = remove_single_cycle_hook(t[14], f);
    return 0;
   }
   function map_cycle_times(t, f){
    function _V_(tail){
     return run_every_cycle_start
             (t,
              function(param){
               var _W_ = caml_call1(f, t[16]);
               return caml_call2(Async_kernel_Tail[3], tail, _W_);
              });
    }
    return caml_call1(Async_kernel_Async_stream[2], _V_);
   }
   function long_cycles(t, at_least){
    function _T_(tail){
     return run_every_cycle_start
             (t,
              function(param){
               var _U_ = caml_call2(Core_Time_ns[1][15], t[16], at_least);
               return _U_
                       ? caml_call2(Async_kernel_Tail[3], tail, t[16])
                       : _U_;
              });
    }
    return caml_call1(Async_kernel_Async_stream[2], _T_);
   }
   function cycle_num_jobs(t){
    function _S_(tail){
     return run_every_cycle_start
             (t,
              function(param){
               return caml_call2(Async_kernel_Tail[3], tail, t[17]);
              });
    }
    return caml_call1(Async_kernel_Async_stream[2], _S_);
   }
   function cycle_count(t){return t[9];}
   function set_max_num_jobs_per_priority_(t, int$0){
    t[27] = caml_call1(Async_kernel_config[6][4], int$0);
    return 0;
   }
   function max_num_jobs_per_priority_per_(t){
    return caml_call1(Async_kernel_config[6][5], t[27]);
   }
   function set_thread_safe_external_job_h(t, f){t[21] = f; return 0;}
   function thread_safe_enqueue_external_j(t, execution_context, f, a){
    caml_call2(Thread_safe_queue[5], t[20], [0, execution_context, f, a]);
    return caml_call1(t[21], 0);
   }
   function set_event_added_hook(t, f){t[23] = [0, f]; return 0;}
   function set_job_queued_hook(t, f){t[22] = [0, f]; return 0;}
   function create_alarm(t, f){
    var execution_context = caml_call1(current_execution_context, t);
    function _R_(param){
     return thread_safe_enqueue_external_j(t, execution_context, f, 0);
    }
    return caml_call1(Core_Gc[15][6][2], _R_);
   }
   function add_finalizer(t, heap_block, f){
    var execution_context = caml_call1(current_execution_context, t);
    function finalizer(heap_block){
     if(Async_kernel_Debug[4])
      caml_call1(Async_kernel_Debug[16], cst_enqueueing_finalizer);
     return thread_safe_enqueue_external_j
             (t, execution_context, f, heap_block);
    }
    if(Async_kernel_Debug[4])
     caml_call1(Async_kernel_Debug[16], cst_adding_finalizer);
    try{var _P_ = caml_call2(Stdlib_Gc[3], finalizer, heap_block); return _P_;
    }
    catch(_Q_){
     var _O_ = caml_wrap_exception(_Q_);
     if(_O_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_O_, 0);
    }
   }
   function add_finalizer_exn(t, x, f){
    function _N_(heap_block){
     return caml_call1(f, caml_call1(Heap_block[4], heap_block));
    }
    return add_finalizer(t, caml_call1(Heap_block[3], x), _N_);
   }
   function add_finalizer_last(t, heap_block, f){
    var execution_context = caml_call1(current_execution_context, t);
    function finalizer(param){
     if(Async_kernel_Debug[4])
      caml_call1(Async_kernel_Debug[16], cst_enqueueing_finalizer_using);
     return thread_safe_enqueue_external_j(t, execution_context, f, 0);
    }
    if(Async_kernel_Debug[4])
     caml_call1(Async_kernel_Debug[16], cst_adding_finalizer_using_las);
    try{var _L_ = caml_call2(Stdlib_Gc[4], finalizer, heap_block); return _L_;
    }
    catch(_M_){
     var _K_ = caml_wrap_exception(_M_);
     if(_K_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_K_, 0);
    }
   }
   function add_finalizer_last_exn(t, x, f){
    return add_finalizer_last(t, caml_call1(Heap_block[3], x), f);
   }
   function force_current_cycle_to_end(t){
    return caml_call2(Async_kernel_Job_queue[6], t[3], 0);
   }
   var send_exn = [0, Async_kernel_Monitor[15]];
   function advance_clock(t, now){
    return caml_call3
            (Async_kernel_Synchronous_time_[31], t[19], now, send_exn);
   }
   function run_cycle(t){
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_run_cycle_starting, t, sexp_of_t);
    var now = caml_call1(Async_kernel_Time_ns[42], 0);
    t[9] = t[9] + 1 | 0;
    t[10] = now;
    t[11] = 1;
    caml_call2(Async_kernel_Bvar[5], t[24], 0);
    var num_jobs_run_at_start_of_cycle = caml_call1(num_jobs_run, t);
    function _y_(f){return caml_call1(f, 0);}
    caml_call2(Core_Array[35], t[12], _y_);
    advance_clock(t, now);
    caml_call2(start_cycle, t, t[27]);
    for(;;){
     var match = caml_call1(Async_kernel_Scheduler1[79], t);
     if(0 === match[0]) break;
     var
      match$0 = match[1],
      backtrace = match$0[2],
      exn = match$0[1],
      _z_ = caml_call1(Async_kernel_Monitor[5], 0);
     caml_call3
      (Async_kernel_Monitor[15], _z_, [0, [0, 936718974, backtrace]], exn);
    }
    var
     _A_ = t[10],
     _B_ = caml_call1(Async_kernel_Time_ns[42], 0),
     cycle_time = caml_call2(Async_kernel_Time_ns[49], _B_, _A_);
    t[16] = cycle_time;
    t[17] = caml_call1(num_jobs_run, t) - num_jobs_run_at_start_of_cycle | 0;
    t[18] = caml_call2(Core_Time_ns[1][101], t[18], cycle_time);
    var _C_ = caml_call1(Async_kernel_Bvar[6], t[25]);
    if(_C_)
     var
      _D_ = caml_call1(num_pending_jobs, t),
      _E_ = caml_call2(Async_kernel_Import[3], _D_, 0);
    else
     var _E_ = _C_;
    if(_E_) caml_call2(Async_kernel_Bvar[5], t[25], 0);
    function _F_(f){return caml_call1(f, 0);}
    caml_call2(Core_Array[35], t[14], _F_);
    t[11] = 0;
    if(! debug) return debug;
    function _G_(param){
     var
      arg1_002 = param[2],
      arg0_001 = param[1],
      res0_003 = caml_call2(Core[515], Core_Error[9], arg0_001),
      res1_004 = caml_call1(Core[323], arg1_002);
     return [1, [0, res0_003, [0, res1_004, 0]]];
    }
    var
     _H_ = next_upcoming_event(t),
     _I_ = caml_call1(Core[253], _H_),
     _J_ = [0, caml_call1(uncaught_exn, t), _I_];
    return caml_call3
            (Async_kernel_Debug[15], cst_run_cycle_finished, _J_, _G_);
   }
   function run_cycles_until_no_jobs_remai(param){
    if(debug)
     caml_call1(Async_kernel_Debug[16], cst_run_cycles_until_no_jobs_r);
    var t$0 = caml_call1(t, 0);
    if(caml_call1(is_dead, t$0)){
     var
      _u_ = [0, [1, [0, _a_, [0, caml_call1(sexp_of_t, t$0), 0]]], 0],
      _v_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_run_cycles_until_no_jobs_r$0),
          _u_]];
     caml_call1(Core[261], _v_);
    }
    for(;;){
     run_cycle(t$0);
     advance_clock(t$0, caml_call1(Async_kernel_Time_ns[42], 0));
     if(! can_run_a_job(t$0)){
      caml_call2(set_execution_context, t$0, t$0[6]);
      if(debug)
       caml_call1(Async_kernel_Debug[16], cst_run_cycles_until_no_jobs_r$1);
      var _w_ = Core_Error[30], _x_ = caml_call1(uncaught_exn, t$0);
      return caml_call2(Core_Option[46], _x_, _w_);
     }
    }
   }
   function make_async_unusable(param){
    var t = t_ref[1];
    t[1] =
     [0,
      function(param){
       var
        _t_ =
          caml_call1(Sexplib0_Sexp_conv[7], cst_Async_scheduler_is_unusabl);
       return caml_call1(Core[261], _t_);
      }];
    return 0;
   }
   function reset_in_forked_process(param){
    if(debug) caml_call1(Async_kernel_Debug[16], cst_reset_in_forked_process);
    var _s_ = caml_call1(Async_kernel_Scheduler1[66], 0);
    Async_kernel_Scheduler1[70][1] = _s_;
    return 0;
   }
   function check_invariants(t){return t[26];}
   function set_check_invariants(t, b){t[26] = b; return 0;}
   function recording_backtraces(t){return t[28];}
   function set_record_backtraces(t, b){t[28] = b; return 0;}
   function yield$0(t){return caml_call1(Async_kernel_Bvar[4], t[24]);}
   function yield_until_no_jobs_remain(opt, t){
    if(opt)
     var sth = opt[1], may_return_immediately = sth;
    else
     var may_return_immediately = 0;
    if(may_return_immediately){
     var _r_ = caml_call1(num_pending_jobs, t);
     if(caml_call2(Async_kernel_Import[3], _r_, 0))
      return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    return caml_call1(Async_kernel_Bvar[4], t[25]);
   }
   function yield_every(n){
    if(caml_call2(Async_kernel_Import[2], n, 0)){
     var
      _n_ = [0, [1, [0, _b_, [0, caml_call1(Core[389], n), 0]]], 0],
      _o_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_yield_every_got_),
          _n_]];
     return caml_call1(Core[261], _o_);
    }
    if(caml_call2(Async_kernel_Import[3], n, 1)){
     var _p_ = function(t){return yield$0(t);};
     return caml_call1(Core[266], _p_);
    }
    var count_until_yield = [0, n];
    function _q_(t){
     count_until_yield[1] += -1;
     return caml_call2(Async_kernel_Import[4], count_until_yield[1], 0)
             ? caml_call1(Async_kernel_Deferred_std[10], 0)
             : (count_until_yield[1] = n, yield$0(t));
    }
    return caml_call1(Core[266], _q_);
   }
   function total_cycle_time(t){
    if(! t[11]) return t[18];
    var
     _l_ = t[10],
     _m_ = caml_call1(Async_kernel_Time_ns[42], 0),
     this_cycle_time = caml_call2(Async_kernel_Time_ns[49], _m_, _l_);
    return caml_call2(Core_Time_ns[1][101], t[18], this_cycle_time);
   }
   function run(t){
    var num_execs_before_yielding = 1000;
    for(;;){
     if(caml_call2(Async_kernel_Import[3], num_execs_before_yielding, 0))
      return yield_then_run(t);
     var _j_ = 1 - caml_call1(Core_Deque[16], t[5]);
     if(! _j_) return _j_;
     var worker = caml_call1(Core_Deque[61], t[5]);
     caml_call2(set_execution_context, t, worker[1]);
     a:
     {
      var num_execs_before_yielding$0 = num_execs_before_yielding;
      for(;;){
       if(t[7] !== worker[1])
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       if(caml_call2(Async_kernel_Import[3], num_execs_before_yielding$0, 0)){caml_call2(Core_Deque[52], t[5], worker); return yield_then_run(t);}
       var num_execs_before_yielding$1 = num_execs_before_yielding$0 - 1 | 0;
       try{var val = caml_call1(worker[2], 0);}
       catch(exn$0){var exn = caml_wrap_exception(exn$0); break;}
       if(! val) break a;
       var num_execs_before_yielding$0 = num_execs_before_yielding$1;
      }
      var
       bt = caml_call1(Base_Backtrace[6][4], 0),
       _k_ = caml_call1(Async_kernel_Monitor[5], 0);
      caml_call3(Async_kernel_Monitor[15], _k_, [0, [0, 936718974, bt]], exn);
      var num_execs_before_yielding = num_execs_before_yielding$1;
      continue;
     }
     var num_execs_before_yielding = num_execs_before_yielding$1;
    }
   }
   function yield_then_run(t){
    var _g_ = 1 - caml_call1(Core_Deque[16], t[5]);
    if(! _g_) return _g_;
    function _h_(param){return run(t);}
    var _i_ = yield$0(t);
    return caml_call2(Async_kernel_Deferred1[8], _i_, _h_);
   }
   function enqueue$0(f){
    var
     t$0 = caml_call1(t, 0),
     queue = t$0[5],
     running = 1 - caml_call1(Core_Deque[16], queue),
     _e_ = caml_call1(current_execution_context, t$0),
     execution_context =
       caml_call4(Async_kernel_Execution_context[8], 0, _d_, 0, _e_);
    caml_call2(Core_Deque[53], queue, [0, execution_context, f]);
    var _f_ = 1 - running;
    return _f_ ? caml_call4(enqueue, t$0, execution_context, run, t$0) : _f_;
   }
   var For_bench = [0, advance_clock];
   function in_cycle(t){return t[11];}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler);
   var
    Async_kernel_Scheduler =
      [0,
       sexp_of_t,
       t,
       invariant,
       current_execution_context,
       with_execution_context,
       with_execution_context1,
       set_execution_context,
       enqueue,
       create_job,
       enqueue_job,
       free_job,
       main_execution_context,
       cycle_start,
       run_cycle,
       run_cycles_until_no_jobs_remai,
       has_upcoming_event,
       next_upcoming_event,
       next_upcoming_event_exn,
       event_precision,
       uncaught_exn,
       uncaught_exn_unwrapped,
       num_pending_jobs,
       num_jobs_run,
       last_cycle_num_jobs,
       map_cycle_times,
       cycle_num_jobs,
       cycle_count,
       total_cycle_time,
       max_num_jobs_per_priority_per_,
       set_max_num_jobs_per_priority_,
       set_check_access,
       check_access,
       check_invariants,
       set_check_invariants,
       recording_backtraces,
       set_record_backtraces,
       run_every_cycle_start,
       run_every_cycle_end,
       add_every_cycle_start_hook,
       add_every_cycle_end_hook,
       remove_every_cycle_start_hook_,
       remove_every_cycle_end_hook_ex,
       last_cycle_time,
       long_cycles,
       can_run_a_job,
       create_alarm,
       add_finalizer,
       add_finalizer_exn,
       add_finalizer_last,
       add_finalizer_last_exn,
       set_thread_safe_external_job_h,
       set_job_queued_hook,
       set_event_added_hook,
       backtrace_of_first_job,
       thread_safe_enqueue_external_j,
       force_current_cycle_to_end,
       within,
       within$0,
       within_v,
       schedule,
       schedule$0,
       preserve_execution_context,
       preserve_execution_context$0,
       within_context,
       find_local,
       with_local,
       make_async_unusable,
       reset_in_forked_process,
       yield$0,
       yield_every,
       yield_until_no_jobs_remain,
       [0, Very_low_priority_worker[1], enqueue$0],
       For_bench,
       in_cycle];
   runtime.caml_register_global
    (61, Async_kernel_Scheduler, cst_Async_kernel_Scheduler$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Throttled
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler, Base__Applicative, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Throttled$0 = "Async_kernel__Throttled",
    cst_async_kernel$0 = "async_kernel",
    cst_src_throttled_ml = "src/throttled.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Option = global_data.Core__Option,
    Assert_failure = global_data.Assert_failure,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Applicative = global_data.Base__Applicative;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Throttled$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_throttled_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "throttled.ml");
   var
    _b_ = [0, ""],
    _a_ = [0, cst_src_throttled_ml, 29, 8],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Throttled = cst_Async_kernel_Throttled$0;
   function return$0(x){
    return function(param, _s_, k){
     return caml_call1(k, caml_call1(Async_kernel_Deferred_std[10], x));};
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return function(exec_ctx, semaphore, k){
         return caml_call3
                 (t,
                  exec_ctx,
                  semaphore,
                  function(d){
                   function _r_(result){return caml_call1(f, result);}
                   return caml_call1
                           (k, caml_call2(Async_kernel_Deferred_std[5][2], d, _r_));
                  });};
       }];
   function apply(t_f, t){
    return function(exec_ctx, semaphore, k){
     return caml_call3
             (t_f,
              exec_ctx,
              semaphore,
              function(df){
               return caml_call3
                       (t,
                        exec_ctx,
                        semaphore,
                        function(dv){
                         function _p_(f){
                          function _q_(v){return caml_call1(f, v);}
                          return caml_call2(Async_kernel_Deferred_std[5][2], dv, _q_);
                         }
                         return caml_call1
                                 (k, caml_call2(Async_kernel_Deferred_std[5][1], df, _p_));
                        });
              });};
   }
   var
    include = caml_call1(Base_Applicative[7], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13];
   function job(f){
    return function(exec_ctx, semaphore, k){
     function _h_(param){
      var
       scheduler = caml_call1(Async_kernel_Scheduler[2], 0),
       ivar = caml_call1(Async_kernel_Ivar[12], 0),
       _j_ = 0;
      function _k_(param){
       var _l_ = caml_call1(Async_kernel_Ivar[14], ivar);
       function _m_(a){
        var max_concurrent_jobs = semaphore[1], waiter = semaphore[2];
        if(waiter){
         var ivar = waiter[1];
         caml_call2(Async_kernel_Ivar[14], ivar, 0);
         semaphore[2] = 0;
        }
        else
         semaphore[1] = max_concurrent_jobs + 1 | 0;
        return a;
       }
       var
        _n_ = caml_call1(f, 0),
        _o_ = caml_call2(Async_kernel_Deferred_std[5][2], _n_, _m_);
       return caml_call2(Async_kernel_Deferred_std[11], _o_, _l_);
      }
      caml_call4(Async_kernel_Scheduler[8], scheduler, exec_ctx, _k_, _j_);
      return caml_call1(k, caml_call1(Async_kernel_Ivar[19], ivar));
     }
     var
      max_concurrent_jobs = semaphore[1],
      waiter = semaphore[2],
      aborted = semaphore[3];
     if(aborted)
      var _i_ = caml_call1(Async_kernel_Deferred1[12], 0);
     else if(caml_call2(Async_kernel_Import[4], max_concurrent_jobs, 0)){
      semaphore[1] = max_concurrent_jobs - 1 | 0;
      var _i_ = caml_call1(Async_kernel_Deferred1[21], 0);
     }
     else{
      if(! caml_call1(Core_Option[61], waiter))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      var ivar = caml_call1(Async_kernel_Ivar[12], 0);
      semaphore[2] = [0, ivar];
      var _i_ = caml_call1(Async_kernel_Ivar[19], ivar);
     }
     return caml_call2(Async_kernel_Deferred1[8], _i_, _h_);};
   }
   function run(t, max_concurrent_jobs){
    var
     semaphore = [0, max_concurrent_jobs, 0, 0],
     monitor = caml_call4(Async_kernel_Monitor[3], 0, 0, _b_, 0),
     parent_monitor = caml_call1(Async_kernel_Monitor[5], 0);
    function _d_(err){
     semaphore[3] = 1;
     semaphore[2] = 0;
     return caml_call3(Async_kernel_Monitor[15], parent_monitor, 0, err);
    }
    caml_call2(Async_kernel_Monitor[7], monitor, _d_);
    var
     _e_ = caml_call1(Async_kernel_Scheduler[2], 0),
     _f_ = caml_call1(Async_kernel_Scheduler[4], _e_),
     exec_ctx =
       caml_call4(Async_kernel_Execution_context[8], [0, monitor], 0, 0, _f_),
     ivar = caml_call1(Async_kernel_Ivar[12], 0);
    caml_call3
     (t,
      exec_ctx,
      semaphore,
      function(r){
       var _g_ = caml_call1(Async_kernel_Ivar[14], ivar);
       return caml_call2(Async_kernel_Deferred1[8], r, _g_);
      });
    return caml_call1(Async_kernel_Ivar[19], ivar);
   }
   function of_thunk(thunk){
    return function(exec_ctx, semaphore, k){
     var t = caml_call1(thunk, 0);
     return caml_call3(t, exec_ctx, semaphore, k);};
   }
   function symbol$1(t1, t2){
    return function(exec_ctx, semaphore, k){
     return caml_call3
             (t1,
              exec_ctx,
              semaphore,
              function(d1){
               return caml_call3
                       (t2,
                        exec_ctx,
                        semaphore,
                        function(d2){
                         function _c_(param){return d2;}
                         return caml_call1
                                 (k, caml_call2(Async_kernel_Deferred_std[5][1], d1, _c_));
                        });
              });};
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Throttled);
   var
    Async_kernel_Throttled =
      [0,
       return$1,
       map$0,
       both,
       symbol,
       symbol$0,
       symbol$1,
       symbol_map,
       apply$0,
       map2,
       map3,
       all,
       all_unit,
       Applicative_infix,
       job,
       run,
       of_thunk,
       symbol$1];
   runtime.caml_register_global
    (23, Async_kernel_Throttled, cst_Async_kernel_Throttled$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Stack_or_counter
//# unitInfo: Requires: Base, Base__Stack, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Stack_or_coun$0 = "Async_kernel__Stack_or_counter",
    cst_async_kernel$0 = "async_kernel",
    cst_length = "length";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Stack = global_data.Base__Stack,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base = global_data.Base,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Stack_or_coun$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/stack_or_counter.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "stack_or_counter.ml");
   var
    cst_Stack_or_counter_pop_exn_o =
      "[Stack_or_counter.pop_exn] of empty stack",
    _d_ = [0, cst_length],
    cst_Stack_or_counter_create_co =
      "[Stack_or_counter.create_counter] got negative length",
    _a_ = [0, "Stack"],
    _b_ = [0, cst_length],
    _c_ = [0, "Counter"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Stack_or_coun = cst_Async_kernel_Stack_or_coun$0;
   function sexp_of_t(of_a_002, param){
    if(0 === param[0]){
     var
      arg0_003 = param[1],
      res0_004 = caml_call2(Base_Stack[2], of_a_002, arg0_003);
     return [1, [0, _a_, [0, res0_004, 0]]];
    }
    var
     length_006 = param[1],
     arg_007 = caml_call1(Base[136], length_006),
     bnds_005 = [0, [1, [0, _b_, [0, arg_007, 0]]], 0];
    return [1, [0, _c_, bnds_005]];
   }
   function of_list(list){return [0, caml_call1(Base_Stack[22], list)];}
   function create_counter(length){
    if(length < 0){
     var
      _i_ = [0, [1, [0, _d_, [0, caml_call1(Base[136], length), 0]]], 0],
      _j_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Stack_or_counter_create_co),
          _i_]];
     caml_call1(Base[246], _j_);
    }
    return [1, length];
   }
   function length(t){
    if(0 !== t[0]) return t[1];
    var s = t[1];
    return caml_call1(Base_Stack[6], s);
   }
   function clear(t){
    if(0 === t[0]){var s = t[1]; return caml_call1(Base_Stack[30], s);}
    t[1] = 0;
    return 0;
   }
   function push(t, a){
    if(0 === t[0]){var s = t[1]; return caml_call2(Base_Stack[25], s, a);}
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function pop_exn(t){
    if(0 === t[0]){var s = t[1]; return caml_call1(Base_Stack[27], s);}
    if(0 === t[1]){
     var
      _h_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Stack_or_counter_pop_exn_o);
     caml_call1(Base[246], _h_);
    }
    t[1] = t[1] - 1 | 0;
    return 0;
   }
   function iter(t, f){
    if(0 === t[0]){var s = t[1]; return caml_call2(Base_Stack[8], s, f);}
    var _f_ = t[1], _e_ = 1;
    if(_f_ >= 1){
     var for$0 = _e_;
     for(;;){
      caml_call1(f, 0);
      var _g_ = for$0 + 1 | 0;
      if(_f_ === for$0) break;
      var for$0 = _g_;
     }
    }
    return 0;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Stack_or_coun);
   var
    Async_kernel_Stack_or_counter =
      [0,
       sexp_of_t,
       clear,
       create_counter,
       iter,
       length,
       of_list,
       pop_exn,
       push];
   runtime.caml_register_global
    (20, Async_kernel_Stack_or_counter, cst_Async_kernel_Stack_or_coun$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Throttle
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Stack_or_counter, Base__Field, Core, Core__Int, Core__List, Core__Queue, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Aborted = "Aborted",
    cst_Async_kernel_Throttle$0 = "Async_kernel__Throttle",
    cst_Ok = "Ok",
    cst_Raised = "Raised",
    cst_async_kernel$0 = "async_kernel",
    cst_capacity_available$0 = "capacity_available",
    cst_cleaned$0 = "cleaned",
    cst_job_resources_not_in_use$0 = "job_resources_not_in_use",
    cst_jobs_waiting_to_start$0 = "jobs_waiting_to_start",
    cst_max_concurrent_jobs$0 = "max_concurrent_jobs",
    cst_num_jobs_running$0 = "num_jobs_running",
    cst_num_resources_not_cleaned$0 = "num_resources_not_cleaned",
    cst_src_throttle_ml = "src/throttle.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Stack_or_counter = global_data.Async_kernel__Stack_or_counter,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core = global_data.Core,
    Core_Int = global_data.Core__Int,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_List = global_data.Core__List,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Throttle$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_throttle_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "throttle.ml");
   var
    _aa_ = [0, cst_src_throttle_ml, 171, 2],
    _ac_ = [0, cst_src_throttle_ml, 172, 2],
    _ab_ = [0, cst_src_throttle_ml, 173, 2],
    cst_enqueue_exclusive_was_call =
      "[enqueue_exclusive] was called with a very large value of [max_concurrent_jobs]. This doesn't work.",
    _ae_ = [0, cst_src_throttle_ml, 292, 2],
    cst_throttle_aborted_job = "throttle aborted job",
    _ad_ = [0, cst_max_concurrent_jobs$0],
    cst_Throttle_create_requires_p =
      "Throttle.create requires positive max_concurrent_jobs, but got",
    _O_ = [0, "_"],
    _P_ = [0, "t"],
    _Q_ = [0, "exn"],
    cst_Throttle_invariant_failed = "Throttle.invariant failed",
    _$_ = [0, cst_src_throttle_ml, 102, 43],
    ___ = [0, cst_src_throttle_ml, 106, 11],
    _Z_ = [0, cst_src_throttle_ml, 111, 29],
    _Y_ = [0, cst_src_throttle_ml, 114, 11],
    _X_ = [0, cst_src_throttle_ml, 115, 11],
    _W_ = [0, cst_src_throttle_ml, 117, 16],
    _V_ = [0, cst_src_throttle_ml, 121, 25],
    _U_ = [0, cst_src_throttle_ml, 126, 11],
    _T_ = [0, cst_src_throttle_ml, 127, 11],
    _S_ = [0, cst_src_throttle_ml, 128, 69],
    _R_ = [0, cst_src_throttle_ml, 131, 40],
    _A_ = [0, cst_cleaned$0],
    _B_ = [0, cst_num_resources_not_cleaned$0],
    _C_ = [0, "cleans"],
    _D_ = [0, "is_dead"],
    _E_ = [0, cst_capacity_available$0],
    _F_ = [0, cst_num_jobs_running$0],
    _G_ = [0, cst_jobs_waiting_to_start$0],
    _H_ = [0, cst_job_resources_not_in_use$0],
    _I_ = [0, cst_max_concurrent_jobs$0],
    _J_ = [0, "Log"],
    _M_ = [0, "Raise"],
    _N_ = [0, "Call"],
    _K_ = [0, "rest"],
    _L_ = [0, "continue_on_error"],
    _l_ = [0, cst_src_throttle_ml, 55, 18],
    _k_ = [0, 523273847],
    _h_ = [0, "Abort"],
    _i_ = [0, "Start"],
    _e_ = [0, cst_Ok],
    _f_ = [0, cst_Raised],
    _d_ = [0, cst_Aborted],
    _g_ = [0, "outcome"],
    _j_ = [0, "start"],
    _a_ = [0, cst_Aborted],
    _b_ = [0, cst_Ok],
    _c_ = [0, cst_Raised],
    cst_cleaned = cst_cleaned$0,
    cst_num_resources_not_cleaned = cst_num_resources_not_cleaned$0,
    cst_capacity_available = cst_capacity_available$0,
    cst_num_jobs_running = cst_num_jobs_running$0,
    cst_jobs_waiting_to_start = cst_jobs_waiting_to_start$0,
    cst_job_resources_not_in_use = cst_job_resources_not_in_use$0,
    cst_max_concurrent_jobs = cst_max_concurrent_jobs$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Throttle = cst_Async_kernel_Throttle$0;
   function sexp_of_outcome(of_a_001, param){
    if(typeof param === "number") return _a_;
    if(17724 <= param[1]){
     var v_002 = param[2];
     return [1, [0, _b_, [0, caml_call1(of_a_001, v_002), 0]]];
    }
    var v_003 = param[2];
    return [1, [0, _c_, [0, caml_call1(Core[625], v_003), 0]]];
   }
   function abort(t){
    return caml_call2(Async_kernel_Ivar[14], t[1], 774323088);
   }
   function cleaned(r){return r[11];}
   function num_resources_not_cleaned(r){return r[10];}
   function set_num_resources_not_cleaned(r, v){r[10] = v; return 0;}
   function is_dead(r){return r[8];}
   function capacity_available(r){return r[7];}
   function set_capacity_available(r, v){r[7] = v; return 0;}
   function num_jobs_running(r){return r[6];}
   function set_num_jobs_running(r, v){r[6] = v; return 0;}
   function jobs_waiting_to_start(r){return r[5];}
   function job_resources_not_in_use(r){return r[4];}
   function max_concurrent_jobs(r){return r[3];}
   function _m_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], v];
   }
   var
    _n_ = 0,
    cleaned$0 =
      [0, function(param){return 0;}, cst_cleaned, _n_, cleaned, _m_];
   function _o_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], v, r[11]];
   }
   var
    _p_ = [0, set_num_resources_not_cleaned],
    num_resources_not_cleaned$0 =
      [0,
       function(param){return 0;},
       cst_num_resources_not_cleaned,
       _p_,
       num_resources_not_cleaned,
       _o_];
   function _q_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _r_ = [0, set_capacity_available],
    capacity_available$0 =
      [0,
       function(param){return 0;},
       cst_capacity_available,
       _r_,
       capacity_available,
       _q_];
   function _s_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _t_ = [0, set_num_jobs_running],
    num_jobs_running$0 =
      [0,
       function(param){return 0;},
       cst_num_jobs_running,
       _t_,
       num_jobs_running,
       _s_];
   function _u_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _v_ = 0,
    jobs_waiting_to_start$0 =
      [0,
       function(param){return 0;},
       cst_jobs_waiting_to_start,
       _v_,
       jobs_waiting_to_start,
       _u_];
   function _w_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _x_ = 0,
    job_resources_not_in_use$0 =
      [0,
       function(param){return 0;},
       cst_job_resources_not_in_use,
       _x_,
       job_resources_not_in_use,
       _w_];
   function _y_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _z_ = 0,
    max_concurrent_jobs$0 =
      [0,
       function(param){return 0;},
       cst_max_concurrent_jobs,
       _z_,
       max_concurrent_jobs,
       _y_];
   function sexp_of_t(of_a_011, param){
    var
     jobs_waiting_to_start_022 = param[5],
     job_resources_not_in_use_020 = param[4],
     max_concurrent_jobs_018 = param[3],
     rest_015 = param[2],
     continue_on_error_013 = param[1],
     num_jobs_running_024 = param[6],
     capacity_available_026 = param[7],
     is_dead_028 = param[8],
     cleans_030 = param[9],
     num_resources_not_cleaned_032 = param[10],
     cleaned_034 = param[11],
     arg_035 = caml_call2(Async_kernel_Ivar[9], Core[620], cleaned_034),
     bnds_012 = [0, [1, [0, _A_, [0, arg_035, 0]]], 0],
     arg_033 = caml_call1(Core[389], num_resources_not_cleaned_032),
     bnds_012$0 = [0, [1, [0, _B_, [0, arg_033, 0]]], bnds_012];
    function _a8_(param){
     function _be_(_bf_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _be_);
    }
    var
     arg_031 = caml_call2(Core[472], _a8_, cleans_030),
     bnds_012$1 = [0, [1, [0, _C_, [0, arg_031, 0]]], bnds_012$0],
     arg_029 = caml_call1(Core[323], is_dead_028),
     bnds_012$2 = [0, [1, [0, _D_, [0, arg_029, 0]]], bnds_012$1],
     _a9_ = caml_call1(Async_kernel_Ivar[9], Core[620]),
     arg_027 = caml_call2(Core[515], _a9_, capacity_available_026),
     bnds_012$3 = [0, [1, [0, _E_, [0, arg_027, 0]]], bnds_012$2],
     arg_025 = caml_call1(Core[389], num_jobs_running_024),
     bnds_012$4 = [0, [1, [0, _F_, [0, arg_025, 0]]], bnds_012$3];
    function _a__(param){
     var outcome_009 = param[2], start_006 = param[1], bnds_005 = 0;
     function _bc_(param){
      return -216426513 === param ? _d_ : 17724 <= param ? _e_ : _f_;
     }
     var
      arg_010 = caml_call2(Async_kernel_Deferred1[1], _bc_, outcome_009),
      bnds_005$0 = [0, [1, [0, _g_, [0, arg_010, 0]]], bnds_005];
     function _bd_(param){
      if(typeof param === "number") return _h_;
      var v_008 = param[2];
      return [1, [0, _i_, [0, caml_call1(of_a_011, v_008), 0]]];
     }
     var
      arg_007 = caml_call2(Async_kernel_Ivar[9], _bd_, start_006),
      bnds_005$1 = [0, [1, [0, _j_, [0, arg_007, 0]]], bnds_005$0];
     return [1, bnds_005$1];
    }
    var
     arg_023 = caml_call2(Core_Queue[13], _a__, jobs_waiting_to_start_022),
     bnds_012$5 = [0, [1, [0, _G_, [0, arg_023, 0]]], bnds_012$4],
     arg_021 =
       caml_call2
        (Async_kernel_Stack_or_counter[1],
         of_a_011,
         job_resources_not_in_use_020),
     bnds_012$6 = [0, [1, [0, _H_, [0, arg_021, 0]]], bnds_012$5],
     arg_019 = caml_call1(Core[389], max_concurrent_jobs_018),
     bnds_012$7 = [0, [1, [0, _I_, [0, arg_019, 0]]], bnds_012$6];
    if(typeof rest_015 === "number")
     var arg_016 = 3804260 <= rest_015 ? _J_ : _M_;
    else
     var
      _a$_ = 0,
      _ba_ = function(_bb_){return 0;},
      arg_016 =
        [1, [0, _N_, [0, caml_call1(Sexplib0_Sexp_conv[24], _ba_), _a$_]]];
    var
     bnds_012$8 = [0, [1, [0, _K_, [0, arg_016, 0]]], bnds_012$7],
     arg_014 = caml_call1(Core[323], continue_on_error_013),
     bnds_012$9 = [0, [1, [0, _L_, [0, arg_014, 0]]], bnds_012$8];
    return [1, bnds_012$9];
   }
   function invariant(invariant_a, x_036){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, x_036));
        },
      _aV_ =
        function(cleaned){
         var _a7_ = caml_call1(Async_kernel_Ivar[18], cleaned);
         if(! _a7_) return _a7_;
         if(caml_call2(Async_kernel_Import[3], x_036[10], 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _R_], 1);
        },
      _aW_ =
        function(num_resources_not_cleaned){
         if
          (! caml_call2(Async_kernel_Import[1], num_resources_not_cleaned, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _U_], 1);
         if
          (!
           caml_call2
            (Async_kernel_Import[2], num_resources_not_cleaned, x_036[3]))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
         var
          _a6_ =
            caml_call2
             (Async_kernel_Import[5], num_resources_not_cleaned, x_036[3]);
         if(! _a6_) return _a6_;
         if(x_036[8]) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _S_], 1);
        },
      _aX_ =
        function(param){
         if(! param) return 0;
         var ivar = param[1];
         if(caml_call1(Async_kernel_Ivar[17], ivar)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
        },
      _aY_ =
        function(num_jobs_running){
         if(! caml_call2(Async_kernel_Import[1], num_jobs_running, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _Y_], 1);
         if(! caml_call2(Async_kernel_Import[2], num_jobs_running, x_036[3]))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
         var
          _a5_ =
            caml_call2(Async_kernel_Import[5], num_jobs_running, x_036[3]);
         if(! _a5_) return _a5_;
         if(caml_call1(Core_Queue[17], x_036[5])) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
        },
      _aZ_ =
        function(jobs_waiting_to_start){
         var _a4_ = x_036[8];
         if(! _a4_) return _a4_;
         if(caml_call1(Core_Queue[17], jobs_waiting_to_start)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _Z_], 1);
        },
      _a0_ =
        function(job_resources_not_in_use){
         caml_call2
          (Async_kernel_Stack_or_counter[4],
           job_resources_not_in_use,
           invariant_a);
         var
          _a2_ = x_036[8] ? 0 : x_036[3] - x_036[6] | 0,
          _a3_ =
            caml_call1
             (Async_kernel_Stack_or_counter[5], job_resources_not_in_use);
         if(caml_call2(Async_kernel_Import[3], _a3_, _a2_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, ___], 1);
        };
     check
      (function(max_concurrent_jobs){
        if(caml_call2(Async_kernel_Import[4], max_concurrent_jobs, 0))
         return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _$_], 1);
       },
       max_concurrent_jobs$0);
     check(_a0_, job_resources_not_in_use$0);
     check(_aZ_, jobs_waiting_to_start$0);
     check(_aY_, num_jobs_running$0);
     check(_aX_, capacity_available$0);
     check(_aW_, num_resources_not_cleaned$0);
     var _a1_ = check(_aV_, cleaned$0);
     return _a1_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _aQ_ = 0,
      _aR_ = 0,
      _aS_ =
        [0,
         [1,
          [0, _P_, [0, sexp_of_t(function(param){return _O_;}, x_036), _aR_]]],
         _aQ_],
      _aT_ = [0, [1, [0, _Q_, [0, caml_call1(Core[625], exn), 0]]], _aS_],
      _aU_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Throttle_invariant_failed),
          _aT_]];
     return caml_call1(Core[261], _aU_);
    }
   }
   function sexp_of_t$0(of_a_037, of_kind_038, x_039){return sexp_of_t(of_a_037, x_039);
   }
   function invariant$0(invariant_a, param, t){return invariant(invariant_a, t);
   }
   var T2 = [0, sexp_of_t$0, invariant$0];
   function num_jobs_waiting_to_start(t){
    return caml_call1(Core_Queue[16], t[5]);
   }
   function clean_resource(t, a){
    function _aL_(param){
     t[10] = t[10] - 1 | 0;
     var _aP_ = caml_call2(Async_kernel_Import[3], t[10], 0);
     return _aP_ ? caml_call2(Async_kernel_Ivar[14], t[11], 0) : _aP_;
    }
    function _aM_(f){return caml_call1(f, a);}
    var
     _aN_ = caml_call2(Core_List[51], t[9], _aM_),
     _aO_ = caml_call1(Async_kernel_Deferred1[45], _aN_);
    return caml_call2(Async_kernel_Deferred_std[1], _aO_, _aL_);
   }
   function kill(t){
    var _aJ_ = 1 - t[8];
    if(! _aJ_) return _aJ_;
    t[8] = 1;
    caml_call2(Core_Queue[18], t[5], abort);
    caml_call1(Core_Queue[51], t[5]);
    function _aK_(a){return clean_resource(t, a);}
    caml_call2(Async_kernel_Stack_or_counter[4], t[4], _aK_);
    return caml_call1(Async_kernel_Stack_or_counter[2], t[4]);
   }
   function at_kill(t, f){
    var
     _aI_ = caml_call1(Async_kernel_Monitor[26][8], f),
     f$0 = caml_call1(Core[267], _aI_);
    t[9] = [0, f$0, t[9]];
    return 0;
   }
   function cleaned$1(t){return caml_call1(Async_kernel_Ivar[19], t[11]);}
   function start_job(t){
    if(t[8]) throw caml_maybe_attach_backtrace([0, Assert_failure, _aa_], 1);
    if(! caml_call2(Async_kernel_Import[5], t[6], t[3]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
    if(caml_call1(Core_Queue[17], t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
    var job = caml_call1(Core_Queue[46], t[5]);
    t[6] = t[6] + 1 | 0;
    var job_resource = caml_call1(Async_kernel_Stack_or_counter[7], t[4]);
    function _aH_(res){
     t[6] = t[6] - 1 | 0;
     if(17724 > res && 1 - t[1]) kill(t);
     if(t[8]) return clean_resource(t, job_resource);
     caml_call2(Async_kernel_Stack_or_counter[8], t[4], job_resource);
     if(! caml_call1(Core_Queue[17], t[5])) return start_job(t);
     var match = t[7];
     if(! match) return 0;
     var ivar = match[1];
     caml_call2(Async_kernel_Ivar[14], ivar, 0);
     t[7] = 0;
     return 0;
    }
    caml_call2(Async_kernel_Ivar[14], job[1], [0, 389604418, job_resource]);
    function _aF_(x){
     if(-216426513 === x)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     return x;
    }
    var _aG_ = caml_call2(Async_kernel_Deferred_std[5][2], job[2], _aF_);
    return caml_call2(Async_kernel_Deferred_std[1], _aG_, _aH_);
   }
   function create_internal(continue_on_error, rest, job_resources){
    var
     max_concurrent_jobs =
       caml_call1(Async_kernel_Stack_or_counter[5], job_resources),
     _aE_ = caml_call1(Async_kernel_Ivar[12], 0);
    return [0,
            continue_on_error,
            rest,
            max_concurrent_jobs,
            job_resources,
            caml_call2(Core_Queue[66], 0, 0),
            0,
            0,
            0,
            0,
            max_concurrent_jobs,
            _aE_];
   }
   function create_with(rest, continue_on_error, job_resources){
    return create_internal
            (continue_on_error,
             rest,
             caml_call1(Async_kernel_Stack_or_counter[6], job_resources));
   }
   function create_with$0(continue_on_error, job_resources){
    return create_with(3804260, continue_on_error, job_resources);
   }
   function create(opt, _aD_, a){
    if(opt) var sth = opt[1], rest = sth; else var rest = 3804260;
    if(_aD_)
     var sth$0 = _aD_[1], continue_on_error = sth$0;
    else
     var continue_on_error = 0;
    return create_with(rest, continue_on_error, [0, a, 0]);
   }
   var Sequencer = [0, sexp_of_t, create];
   function create$0(rest, continue_on_error, max_concurrent_jobs){
    if(caml_call2(Async_kernel_Import[2], max_concurrent_jobs, 0)){
     var
      _aB_ =
        [0,
         [1, [0, _ad_, [0, caml_call1(Core[389], max_concurrent_jobs), 0]]],
         0],
      _aC_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Throttle_create_requires_p),
          _aB_]];
     caml_call1(Core[261], _aC_);
    }
    return create_internal
            (continue_on_error,
             rest,
             caml_call1(Async_kernel_Stack_or_counter[3], max_concurrent_jobs));
   }
   function create$1(continue_on_error, max_concurrent_jobs){
    return create$0(3804260, continue_on_error, max_concurrent_jobs);
   }
   function enqueue_internal(t, work, enqueue){
    var rest = t[2], start = caml_call1(Async_kernel_Ivar[12], 0);
    function _av_(param){
     if(typeof param === "number")
      return caml_call1(Async_kernel_Deferred_std[10], -216426513);
     var a = param[2];
     function _ay_(param){
      if(0 === param[0]){var a = param[1]; return [0, 17724, a];}
      var exn = param[1];
      return [0, -387916264, exn];
     }
     function _az_(param){return caml_call1(work, a);}
     var
      _aA_ =
        caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _k_, [0, rest], _az_);
     return caml_call2(Async_kernel_Deferred_std[5][2], _aA_, _ay_);
    }
    var
     _aw_ = caml_call1(Async_kernel_Ivar[19], start),
     result = caml_call2(Async_kernel_Deferred_std[5][1], _aw_, _av_);
    function _ax_(param){
     return typeof param === "number"
             ? -216426513
             : 17724 <= param[1] ? 17724 : -387916264;
    }
    var
     outcome = caml_call2(Async_kernel_Deferred_std[5][2], result, _ax_),
     internal_job = [0, start, outcome];
    if(t[8])
     abort(internal_job);
    else{
     caml_call2(enqueue, t[5], internal_job);
     if(caml_call2(Async_kernel_Import[5], t[6], t[3])) start_job(t);
    }
    return result;
   }
   function handle_enqueue_result(result){
    if(typeof result === "number"){
     var _au_ = caml_call1(Sexplib0_Sexp_conv[7], cst_throttle_aborted_job);
     return caml_call1(Core[261], _au_);
    }
    if(17724 <= result[1]){var a = result[2]; return a;}
    var exn = result[2];
    throw caml_maybe_attach_backtrace(exn, 0);
   }
   function enqueue(t, f){return enqueue_internal(t, f, Core_Queue[43]);}
   function enqueue$0(t, f){
    var _at_ = enqueue(t, f);
    return caml_call2
            (Async_kernel_Deferred_std[4], _at_, handle_enqueue_result);
   }
   function enqueue_front(t, f){
    return enqueue_internal(t, f, Core_Queue[69]);
   }
   function enqueue_front$0(t, f){
    var _as_ = enqueue_front(t, f);
    return caml_call2
            (Async_kernel_Deferred_std[4], _as_, handle_enqueue_result);
   }
   function enqueue_exclusive(t, f){
    var n = t[3];
    if(caml_call2(Core_Int[81], n, 1000000)){
     var
      _al_ = caml_call1(Sexplib0_Sexp_conv[7], cst_enqueue_exclusive_was_call);
     caml_call1(Core[261], _al_);
    }
    var done = caml_call1(Async_kernel_Ivar[12], 0);
    if(! caml_call2(Async_kernel_Import[4], n, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ae_], 1);
    function f_placeholder(slot){
     return caml_call1(Async_kernel_Ivar[19], done);
    }
    var _an_ = n - 1 | 0, _am_ = 1;
    if(_an_ >= 1){
     var for$0 = _am_;
     for(;;){
      var _aq_ = enqueue$0(t, f_placeholder);
      caml_call1(Async_kernel_Deferred_std[8], _aq_);
      var _ar_ = for$0 + 1 | 0;
      if(_an_ === for$0) break;
      var for$0 = _ar_;
     }
    }
    function _ao_(result){
     caml_call2(Async_kernel_Ivar[14], done, 0);
     return handle_enqueue_result(result);
    }
    var _ap_ = enqueue(t, function(slot){return caml_call1(f, 0);});
    return caml_call2(Async_kernel_Deferred_std[5][2], _ap_, _ao_);
   }
   function monad_sequence_how(how, f){
    a:
    {
     if(typeof how === "number" && -676829465 <= how){var f$0 = f; break a;}
     if(typeof how === "number")
      var max_concurrent_jobs = 1;
     else
      var
       max_concurrent_jobs$0 = how[2],
       max_concurrent_jobs = max_concurrent_jobs$0;
     var
      t = create$1(0, max_concurrent_jobs),
      f$0 =
        function(a){
         return enqueue$0(t, function(param){return caml_call1(f, a);});
        };
    }
    return caml_call1(Core[266], f$0);
   }
   function monad_sequence_how2(how, f){
    a:
    {
     if(typeof how === "number" && -676829465 <= how){var f$0 = f; break a;}
     if(typeof how === "number")
      var max_concurrent_jobs = 1;
     else
      var
       max_concurrent_jobs$0 = how[2],
       max_concurrent_jobs = max_concurrent_jobs$0;
     var
      t = create$1(0, max_concurrent_jobs),
      f$0 =
        function(a1, a2){
         return enqueue$0(t, function(param){return caml_call2(f, a1, a2);});
        };
    }
    return caml_call1(Core[266], f$0);
   }
   function prior_jobs_done(t){
    function _ag_(all_dummy_jobs_running){
     var dummy_jobs_running = [0, 0], _ai_ = t[3], _ah_ = 1;
     if(_ai_ >= 1){
      var for$0 = _ah_;
      for(;;){
       var
        _aj_ =
          enqueue$0
           (t,
            function(param){
             dummy_jobs_running[1]++;
             if
              (caml_call2(Async_kernel_Import[3], dummy_jobs_running[1], t[3]))
              caml_call2(Async_kernel_Ivar[14], all_dummy_jobs_running, 0);
             return caml_call1(Async_kernel_Ivar[19], all_dummy_jobs_running);
            });
       caml_call1(Async_kernel_Deferred_std[8], _aj_);
       var _ak_ = for$0 + 1 | 0;
       if(_ai_ === for$0) break;
       var for$0 = _ak_;
      }
     }
     return 0;
    }
    return caml_call1(Async_kernel_Deferred1[4], _ag_);
   }
   function capacity_available$1(t){
    if(caml_call2(Async_kernel_Import[5], t[6], t[3]))
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    var match = t[7];
    if(match){
     var ivar = match[1];
     return caml_call1(Async_kernel_Ivar[19], ivar);
    }
    function _af_(ivar){t[7] = [0, ivar]; return 0;}
    return caml_call1(Async_kernel_Deferred1[4], _af_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Throttle);
   var
    Async_kernel_Throttle =
      [0,
       T2,
       sexp_of_t,
       invariant,
       create$0,
       create$1,
       create_with,
       create_with$0,
       sexp_of_outcome,
       enqueue,
       enqueue$0,
       enqueue_front,
       enqueue_front$0,
       enqueue_exclusive,
       monad_sequence_how,
       monad_sequence_how2,
       prior_jobs_done,
       max_concurrent_jobs,
       num_jobs_running,
       num_jobs_waiting_to_start,
       capacity_available$1,
       kill,
       is_dead,
       at_kill,
       cleaned$1,
       Sequencer];
   runtime.caml_register_global
    (84, Async_kernel_Throttle, cst_Async_kernel_Throttle$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Synchronous_time_source
//# unitInfo: Requires: Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Synchronous_t = "Async_kernel__Synchronous_time_source",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Types = global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Synchronous_t);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/synchronous_time_source.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel, "synchronous_time_source.ml");
   var
    default_timing_wheel_config = Async_kernel_Synchronous_time_[3],
    T1 = Async_kernel_Synchronous_time_[4],
    sexp_of_t = Async_kernel_Synchronous_time_[5],
    invariant = Async_kernel_Synchronous_time_[6],
    invariant_with_jobs = Async_kernel_Synchronous_time_[7],
    Read_write = Async_kernel_Synchronous_time_[8],
    id = Async_kernel_Synchronous_time_[9],
    is_wall_clock = Async_kernel_Synchronous_time_[10],
    length = Async_kernel_Synchronous_time_[11],
    max_allowed_alarm_time = Async_kernel_Synchronous_time_[12],
    read_only = Async_kernel_Synchronous_time_[13],
    alarm_precision = Async_kernel_Synchronous_time_[15],
    next_alarm_fires_at = Async_kernel_Synchronous_time_[16],
    next_alarm_runs_at = Async_kernel_Synchronous_time_[17],
    now = Async_kernel_Synchronous_time_[18],
    timing_wheel_now = Async_kernel_Synchronous_time_[19],
    Event = Async_kernel_Synchronous_time_[22],
    run_after = Async_kernel_Synchronous_time_[23],
    run_at = Async_kernel_Synchronous_time_[24],
    run_at_intervals = Async_kernel_Synchronous_time_[25],
    advance_by_alarms = Async_kernel_Synchronous_time_[35],
    advance_by_alarms_by = Async_kernel_Synchronous_time_[36],
    advance_by_max_alarms_in_each_ = Async_kernel_Synchronous_time_[37],
    advance_directly = Async_kernel_Synchronous_time_[38],
    advance_directly_by = Async_kernel_Synchronous_time_[39],
    duration_of = Async_kernel_Synchronous_time_[40],
    max_alarm_time_in_min_timing_w = Async_kernel_Synchronous_time_[41],
    has_events_to_run = Async_kernel_Synchronous_time_[42],
    create = Async_kernel_Scheduler1[81],
    wall_clock = Async_kernel_Scheduler1[82];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Synchronous_t);
   var
    _a_ = Event[3],
    Async_kernel_Synchronous_time_$0 =
      [0,
       [0, T1[17]],
       Read_write,
       Async_kernel_Types[21],
       sexp_of_t,
       invariant_with_jobs,
       invariant,
       id,
       read_only,
       create,
       alarm_precision,
       is_wall_clock,
       now,
       timing_wheel_now,
       run_at,
       run_after,
       run_at_intervals,
       max_allowed_alarm_time,
       duration_of,
       [0,
        Event[17],
        Event[18],
        [0,
         _a_[9],
         _a_[2],
         _a_[3],
         _a_[4],
         _a_[5],
         _a_[10],
         _a_[11],
         _a_[12],
         _a_[13],
         _a_[8]],
        Event[25],
        Event[26],
        Event[28],
        Event[29],
        Event[30],
        Event[32],
        Event[31],
        Event[33],
        Event[34],
        Event[36],
        Event[37],
        Event[39],
        Event[38],
        Event[40],
        Event[41],
        Event[21]],
       default_timing_wheel_config,
       wall_clock,
       length,
       next_alarm_runs_at,
       next_alarm_fires_at,
       advance_by_alarms,
       advance_by_alarms_by,
       advance_by_max_alarms_in_each_,
       advance_directly,
       advance_directly_by,
       max_alarm_time_in_min_timing_w,
       has_events_to_run];
   runtime.caml_register_global
    (14, Async_kernel_Synchronous_time_$0, cst_Async_kernel_Synchronous_t);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_kernel_scheduler
//# unitInfo: Requires: Async_kernel__Scheduler, Async_kernel__Time_ns, Base__Staged, Core, Core__Time_ns, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_kernel_$0 = "Async_kernel__Async_kernel_scheduler",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Staged = global_data.Base__Staged,
    Core = global_data.Core,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_kernel_$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_kernel_scheduler.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "async_kernel_scheduler.ml");
   var
    t = Async_kernel_Scheduler[2],
    with_execution_context = Async_kernel_Scheduler[5],
    with_execution_context1 = Async_kernel_Scheduler[6],
    set_execution_context = Async_kernel_Scheduler[7],
    enqueue = Async_kernel_Scheduler[8],
    run_cycles_until_no_jobs_remai = Async_kernel_Scheduler[15],
    last_cycle_num_jobs = Async_kernel_Scheduler[24],
    map_cycle_times = Async_kernel_Scheduler[25],
    run_every_cycle_start = Async_kernel_Scheduler[37],
    run_every_cycle_end = Async_kernel_Scheduler[38],
    add_every_cycle_start_hook = Async_kernel_Scheduler[39],
    add_every_cycle_end_hook = Async_kernel_Scheduler[40],
    remove_every_cycle_start_hook_ = Async_kernel_Scheduler[41],
    remove_every_cycle_end_hook_ex = Async_kernel_Scheduler[42],
    thread_safe_enqueue_external_j = Async_kernel_Scheduler[55],
    within = Async_kernel_Scheduler[57],
    within$0 = Async_kernel_Scheduler[58],
    within_v = Async_kernel_Scheduler[59],
    schedule = Async_kernel_Scheduler[60],
    schedule$0 = Async_kernel_Scheduler[61],
    preserve_execution_context = Async_kernel_Scheduler[62],
    preserve_execution_context$0 = Async_kernel_Scheduler[63],
    within_context = Async_kernel_Scheduler[64],
    find_local = Async_kernel_Scheduler[65],
    with_local = Async_kernel_Scheduler[66],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_kernel_ = cst_Async_kernel_Async_kernel_$0,
    _a_ = Async_kernel_Scheduler[4],
    _b_ = Async_kernel_Scheduler[13],
    _c_ = Async_kernel_Scheduler[19],
    _d_ = Async_kernel_Scheduler[22],
    _e_ = Async_kernel_Scheduler[23],
    _f_ = Async_kernel_Scheduler[27],
    _g_ = Async_kernel_Scheduler[28],
    _h_ = Async_kernel_Scheduler[29],
    _i_ = Async_kernel_Scheduler[30],
    _j_ = Async_kernel_Scheduler[35],
    _k_ = Async_kernel_Scheduler[36],
    _l_ = Async_kernel_Scheduler[43],
    _m_ = Async_kernel_Scheduler[44],
    _n_ = Async_kernel_Scheduler[56],
    _o_ = Async_kernel_Scheduler[69],
    _p_ = Async_kernel_Scheduler[70],
    _q_ = Async_kernel_Scheduler[71];
   function enqueue_job(execution_context, f, a){
    return caml_call4(enqueue, caml_call1(t, 0), execution_context, f, a);
   }
   function thread_safe_enqueue_job(execution_context, f, a){
    return caml_call4
            (thread_safe_enqueue_external_j,
             caml_call1(t, 0),
             execution_context,
             f,
             a);
   }
   function current_execution_context(param){
    return caml_call1(_a_, caml_call1(t, 0));
   }
   function cycle_count(param){return caml_call1(_f_, caml_call1(t, 0));}
   function cycle_start_ns(param){return caml_call1(_b_, caml_call1(t, 0));}
   function cycle_start(param){
    var _x_ = cycle_start_ns(0);
    return caml_call1(Async_kernel_Time_ns[68], _x_);
   }
   function cycle_times_ns(param){
    function _v_(_w_){return _w_;}
    return caml_call2(map_cycle_times, caml_call1(t, 0), _v_);
   }
   function cycle_times(param){
    var _u_ = Core_Time_ns[1][144];
    return caml_call2(map_cycle_times, caml_call1(t, 0), _u_);
   }
   function total_cycle_time(param){return caml_call1(_g_, caml_call1(t, 0));}
   function last_cycle_time(param){return caml_call1(_l_, caml_call1(t, 0));}
   function long_cycles(at_least){
    return caml_call2(_m_, caml_call1(t, 0), at_least);
   }
   function event_precision_ns(param){
    return caml_call1(_c_, caml_call1(t, 0));
   }
   function event_precision(param){
    var _t_ = event_precision_ns(0);
    return caml_call1(Core_Time_ns[1][144], _t_);
   }
   function set_max_num_jobs_per_priority_(i){
    return caml_call2(_i_, caml_call1(t, 0), i);
   }
   function max_num_jobs_per_priority_per_(param){return caml_call1(_h_, caml_call1(t, 0));
   }
   function set_record_backtraces(bool){
    return caml_call2(_k_, caml_call1(t, 0), bool);
   }
   function recording_backtraces(param){
    return caml_call1(_j_, caml_call1(t, 0));
   }
   function force_current_cycle_to_end(param){return caml_call1(_n_, caml_call1(t, 0));
   }
   function yield$0(param){return caml_call1(_o_, caml_call1(t, 0));}
   function yield_until_no_jobs_remain(may_return_immediately, param){return caml_call2(_q_, may_return_immediately, caml_call1(t, 0));
   }
   function yield_every(n){
    var
     _r_ = caml_call1(_p_, n),
     yield_every = caml_call1(Base_Staged[2], _r_),
     t$0 = caml_call1(t, 0);
    function _s_(param){return caml_call1(yield_every, t$0);}
    return caml_call1(Core[266], _s_);
   }
   function num_jobs_run(param){return caml_call1(_e_, caml_call1(t, 0));}
   function num_pending_jobs(param){return caml_call1(_d_, caml_call1(t, 0));}
   function set_execution_context$0(context){
    return caml_call2(set_execution_context, caml_call1(t, 0), context);
   }
   function last_cycle_num_jobs$0(param){
    return caml_call1(last_cycle_num_jobs, caml_call1(t, 0));
   }
   function run_every_cycle_start$0(f){
    return caml_call2(run_every_cycle_start, caml_call1(t, 0), f);
   }
   function run_every_cycle_end$0(f){
    return caml_call2(run_every_cycle_end, caml_call1(t, 0), f);
   }
   function add_every_cycle_start_hook$0(f){
    return caml_call2(add_every_cycle_start_hook, caml_call1(t, 0), f);
   }
   function add_every_cycle_end_hook$0(f){
    return caml_call2(add_every_cycle_end_hook, caml_call1(t, 0), f);
   }
   function remove_every_cycle_start_hook_$0(handle){
    return caml_call2
            (remove_every_cycle_start_hook_, caml_call1(t, 0), handle);
   }
   function remove_every_cycle_end_hook_ex$0(handle){
    return caml_call2
            (remove_every_cycle_end_hook_ex, caml_call1(t, 0), handle);
   }
   function with_execution_context$0(execution_context, f){
    return caml_call3
            (with_execution_context, caml_call1(t, 0), execution_context, f);
   }
   function with_execution_context1$0(execution_context, f, x){
    return caml_call4
            (with_execution_context1,
             caml_call1(t, 0),
             execution_context,
             f,
             x);
   }
   var
    Expert =
      [0,
       set_execution_context$0,
       run_cycles_until_no_jobs_remai,
       last_cycle_num_jobs$0,
       run_every_cycle_start$0,
       run_every_cycle_end$0,
       add_every_cycle_start_hook$0,
       add_every_cycle_end_hook$0,
       remove_every_cycle_start_hook_$0,
       remove_every_cycle_end_hook_ex$0,
       with_execution_context$0,
       with_execution_context1$0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_kernel_);
   var
    Async_kernel_Async_kernel_sche =
      [0,
       current_execution_context,
       within_context,
       within,
       within$0,
       within_v,
       with_local,
       find_local,
       schedule,
       schedule$0,
       enqueue_job,
       thread_safe_enqueue_job,
       preserve_execution_context,
       preserve_execution_context$0,
       cycle_start,
       cycle_start_ns,
       cycle_times,
       cycle_times_ns,
       last_cycle_time,
       long_cycles,
       cycle_count,
       total_cycle_time,
       event_precision,
       event_precision_ns,
       force_current_cycle_to_end,
       set_max_num_jobs_per_priority_,
       max_num_jobs_per_priority_per_,
       set_record_backtraces,
       recording_backtraces,
       yield$0,
       yield_until_no_jobs_remain,
       yield_every,
       num_jobs_run,
       num_pending_jobs,
       Expert];
   runtime.caml_register_global
    (16, Async_kernel_Async_kernel_sche, cst_Async_kernel_Async_kernel_$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Clock_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Clock_intf$0 = "Async_kernel__Clock_intf",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Clock_intf$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/clock_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "clock_intf.ml");
   var
    _a_ = [0, "Timeout"],
    _b_ = [0, "Result"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Clock_intf = cst_Async_kernel_Clock_intf$0;
   function compare(cmp_a, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(typeof a_001 === "number"){
     if(typeof b_002 === "number" && 642269825 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 1025039613 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return runtime.caml_compare(a_001, b_002);
   }
   function sexp_of_t(of_a_005, param){
    if(typeof param === "number") return _a_;
    var v_006 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_005, v_006), 0]]];
   }
   var Or_timeout = [0, compare, sexp_of_t];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Clock_intf);
   var Async_kernel_Clock_intf = [0, Or_timeout];
   runtime.caml_register_global
    (13, Async_kernel_Clock_intf, cst_Async_kernel_Clock_intf$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Clock_ns
//# unitInfo: Requires: Async_kernel__Scheduler1, Async_kernel__Time_source, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Clock_ns$0 = "Async_kernel__Clock_ns",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Clock_ns$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/clock_ns.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "clock_ns.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Clock_ns = cst_Async_kernel_Clock_ns$0;
   function time_source(param){
    var _r_ = caml_call1(Async_kernel_Scheduler1[72], 0)[19];
    return caml_call1(Async_kernel_Time_source[40], _r_);
   }
   function after(span){
    var _q_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[29], _q_, span);
   }
   function at(time){
    var _p_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[28], _p_, time);
   }
   function at_varying_intervals(stop, compute_span){
    var _o_ = time_source(0);
    return caml_call3(Async_kernel_Time_source[34], stop, _o_, compute_span);
   }
   function at_intervals(start, stop, interval){
    var _n_ = time_source(0);
    return caml_call4
            (Async_kernel_Time_source[35], start, stop, _n_, interval);
   }
   function every(start, stop, continue_on_error, finished, span, f){
    var _m_ = time_source(0);
    return caml_call7
            (Async_kernel_Time_source[36],
             start,
             stop,
             continue_on_error,
             finished,
             _m_,
             span,
             f);
   }
   function every$0(start, stop, continue_on_error, span, f){
    var _l_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[37],
             start,
             stop,
             continue_on_error,
             _l_,
             span,
             f);
   }
   function run_after(span, f, a){
    var _k_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[27], _k_, span, f, a);
   }
   function run_at(time, f, a){
    var _j_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[26], _j_, time, f, a);
   }
   function run_at_intervals(start, stop, continue_on_error, interval, f){
    var _i_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[39],
             start,
             stop,
             continue_on_error,
             _i_,
             interval,
             f);
   }
   function run_at_intervals$0(start, stop, continue_on_error, interval, f){
    var _h_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[38],
             start,
             stop,
             continue_on_error,
             _h_,
             interval,
             f);
   }
   function with_timeout(span, d){
    var _g_ = time_source(0);
    return caml_call3(Async_kernel_Time_source[30], _g_, span, d);
   }
   function with_timeout_exn(span, d, error){
    var _f_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[31], _f_, span, d, error);
   }
   function duration_of(f){
    var _e_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[32], _e_, f);
   }
   var
    include = Async_kernel_Time_source[33],
    sexp_of_t = include[1],
    sexp_of_t_unit = include[2],
    invariant = include[3],
    scheduled_at = include[4],
    Status = include[5],
    status = include[6],
    abort = include[10],
    abort_exn = include[11],
    abort_if_possible = include[12],
    fired = include[14],
    reschedule_at = include[16],
    reschedule_after = include[17],
    _a_ = include[7],
    _b_ = include[8],
    _c_ = include[18],
    _d_ = include[19];
   function after$0(span){return caml_call2(_d_, time_source(0), span);}
   function run_after$0(span, f, a){
    return caml_call4(_b_, time_source(0), span, f, a);
   }
   function at$0(time){return caml_call2(_c_, time_source(0), time);}
   function run_at$0(time, f, z){
    return caml_call4(_a_, time_source(0), time, f, z);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Clock_ns);
   var
    Async_kernel_Clock_ns =
      [0,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       with_timeout_exn,
       [0,
        sexp_of_t,
        sexp_of_t_unit,
        invariant,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        abort,
        abort_exn,
        abort_if_possible,
        fired,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals$0,
       run_at_intervals,
       duration_of];
   runtime.caml_register_global
    (13, Async_kernel_Clock_ns, cst_Async_kernel_Clock_ns$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_array
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Core, Core__Array, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_arra$0 = "Async_kernel__Deferred_array",
    cst_async_kernel$0 = "async_kernel",
    caml_check_bound = runtime.caml_check_bound;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Array = global_data.Core__Array,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core = global_data.Core,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_arra$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_array.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_array.ml");
   var
    _b_ = [0, 0],
    _a_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_arra = cst_Async_kernel_Deferred_arra$0;
   function foldi(t, init, f){
    function _J_(result){
     function loop(i, b){
      if(caml_call2(Core[90], i, t.length - 1))
       return caml_call2(Async_kernel_Ivar[14], result, b);
      function _K_(b){return loop(i + 1 | 0, b);}
      var _L_ = caml_call3(f, i, b, caml_check_bound(t, i)[1 + i]);
      return caml_call2(Async_kernel_Deferred_std[1], _L_, _K_);
     }
     return loop(0, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _J_);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    function _G_(result){
     function loop(i, output){
      if(caml_call2(Core[90], i, t.length - 1))
       return caml_call2(Async_kernel_Ivar[14], result, output);
      function _H_(b){
       var
        output$0 =
          caml_call2(Core[90], i, 0)
           ? caml_call2(Core_Array[63], t.length - 1, b)
           : output;
       caml_check_bound(output$0, i)[1 + i] = b;
       return loop(i + 1 | 0, output$0);
      }
      var _I_ = caml_call2(f, i, caml_check_bound(t, i)[1 + i]);
      return caml_call2(Async_kernel_Deferred_std[1], _I_, _H_);
     }
     return loop(0, [0]);
    }
    return caml_call1(Async_kernel_Deferred1[4], _G_);
   }
   function all(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    var _F_ = fold(ds, 0, function(param, d){return d;});
    return caml_call1(Async_kernel_Deferred1[20], _F_);
   }
   function iteri(how, t, f){
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _D_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _E_ = caml_call1(Core[267], _D_);
    return all_unit(caml_call2(Core_Array[57], t, _E_));
   }
   function mapi(how, t, f){
    if(typeof how === "number" && -676829465 > how) return seqmapi(t, f);
    var
     _B_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _C_ = caml_call1(Core[267], _B_);
    return all(caml_call2(Core_Array[57], t, _C_));
   }
   function filteri(how, t, f){
    function _x_(bools){
     function _z_(ac, x, b){return b ? [0, x, ac] : ac;}
     var _A_ = caml_call4(Core_Array[93], t, bools, 0, _z_);
     return caml_call1(Core_Array[99], _A_);
    }
    var _y_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[5][2], _y_, _x_);
   }
   function filter_mapi(how, t, f){
    var _v_ = Core_Array[90], _w_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _w_, _v_);
   }
   function concat_mapi(how, t, f){
    function _s_(t){
     var _u_ = caml_call1(Core_Array[45], t);
     return caml_call1(Core_Array[68], _u_);
    }
    var _t_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[5][2], _t_, _s_);
   }
   function find_mapi(t, f){
    function aux(i){
     if(caml_call2(Core[90], i, t.length - 1))
      return caml_call1(Async_kernel_Deferred_std[10], 0);
     function _q_(some){
      return some
              ? caml_call1(Async_kernel_Deferred_std[10], some)
              : aux(i + 1 | 0);
     }
     var _r_ = caml_call2(f, i, caml_check_bound(t, i)[1 + i]);
     return caml_call2(Async_kernel_Deferred_std[5][1], _r_, _q_);
    }
    return aux(0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _o_(b){return b ? [0, [0, i, elt]] : 0;}
              var _p_ = caml_call2(f, i, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _p_, _o_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _m_(b){return b ? [0, elt] : 0;}
              var _n_ = caml_call1(f, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _n_, _m_);
             });
   }
   function existsi(t, f){
    function _i_(param){return param ? 1 : 0;}
    var
     _j_ =
       find_mapi
        (t,
         function(i, elt){
          function _k_(b){return b ? _a_ : 0;}
          var _l_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _l_, _k_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _j_, _i_);
   }
   function for_alli(t, f){
    function _e_(param){return param ? 0 : 1;}
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          function _g_(b){return b ? 0 : _b_;}
          var _h_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _f_, _e_);
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _c_(_d_){return _d_;}
    return map(how, caml_call2(Core_Array[56], n, _c_), f);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_arra);
   var
    Async_kernel_Deferred_array =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (19, Async_kernel_Deferred_array, cst_Async_kernel_Deferred_arra$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_list
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Async_kernel__Throttled, Core, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_list$0 = "Async_kernel__Deferred_list",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Throttled = global_data.Async_kernel__Throttled,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_list$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_list.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_list.ml");
   var
    _b_ = [0, 0],
    _a_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_list = cst_Async_kernel_Deferred_list$0;
   function foldi(t, init, f){
    function _U_(result){
     function loop(t, i, b){
      if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
      var xs = t[2], x = t[1];
      function _V_(b){return loop(xs, i + 1 | 0, b);}
      var _W_ = caml_call3(f, i, b, x);
      return caml_call2(Async_kernel_Deferred_std[1], _W_, _V_);
     }
     return loop(t, 0, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _U_);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    var
     _Q_ = Core_List[59],
     _R_ =
       foldi
        (t,
         0,
         function(i, bs, a){
          function _S_(b){return [0, b, bs];}
          var _T_ = caml_call2(f, i, a);
          return caml_call2(Async_kernel_Deferred_std[5][2], _T_, _S_);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _R_, _Q_);
   }
   function all(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    var _P_ = fold(ds, 0, function(param, d){return d;});
    return caml_call1(Async_kernel_Deferred1[20], _P_);
   }
   function iteri(how, t, f){
    if(typeof how !== "number"){
     var
      job_count = how[2],
      gen_computation =
        function(idx, param){
         if(! param) return caml_call1(Async_kernel_Throttled[1], 0);
         var xs = param[2], x = param[1];
         function _L_(param){
          var _M_ = gen_computation(idx + 1 | 0, xs);
          function _N_(param){return caml_call2(f, idx, x);}
          var _O_ = caml_call1(Async_kernel_Throttled[14], _N_);
          return caml_call2(Async_kernel_Throttled[17], _O_, _M_);
         }
         return caml_call1(Async_kernel_Throttled[16], _L_);
        },
      _K_ = gen_computation(0, t);
     return caml_call2(Async_kernel_Throttled[15], _K_, job_count);
    }
    if(-676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _I_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _J_ = caml_call1(Core[267], _I_);
    return all_unit(caml_call2(Core_List[41], t, _J_));
   }
   function mapi(how, t, f){
    if(typeof how !== "number"){
     var
      job_count = how[2],
      gen_computation =
        function(idx, param){
         if(! param) return caml_call1(Async_kernel_Throttled[1], 0);
         var xs = param[2], x = param[1];
         function _D_(param){
          function _E_(y, ys){return [0, y, ys];}
          var _F_ = gen_computation(idx + 1 | 0, xs);
          function _G_(param){return caml_call2(f, idx, x);}
          var _H_ = caml_call1(Async_kernel_Throttled[14], _G_);
          return caml_call3(Async_kernel_Throttled[9], _H_, _F_, _E_);
         }
         return caml_call1(Async_kernel_Throttled[16], _D_);
        },
      _C_ = gen_computation(0, t);
     return caml_call2(Async_kernel_Throttled[15], _C_, job_count);
    }
    if(-676829465 > how) return seqmapi(t, f);
    var
     _A_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _B_ = caml_call1(Core[267], _A_);
    return all(caml_call2(Core_List[41], t, _B_));
   }
   function filteri(how, t, f){
    function _w_(bools){
     function _y_(ac, x, b){return b ? [0, x, ac] : ac;}
     var _z_ = caml_call4(Core_List[67], t, bools, 0, _y_);
     return caml_call1(Core_List[59], _z_);
    }
    var _x_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[5][2], _x_, _w_);
   }
   function filter_mapi(how, t, f){
    var _u_ = Core_List[132], _v_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _v_, _u_);
   }
   function concat_mapi(how, t, f){
    var _s_ = Core_List[11], _t_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _t_, _s_);
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(Async_kernel_Deferred_std[10], 0);
     var tl = t[2], hd = t[1];
     function _q_(some){
      return some
              ? caml_call1(Async_kernel_Deferred_std[10], some)
              : find_mapi(tl, f, i + 1 | 0);
     }
     var _r_ = caml_call2(f, i, hd);
     return caml_call2(Async_kernel_Deferred_std[5][1], _r_, _q_);
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _o_(b){return b ? [0, [0, i, elt]] : 0;}
              var _p_ = caml_call2(f, i, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _p_, _o_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _m_(b){return b ? [0, elt] : 0;}
              var _n_ = caml_call1(f, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _n_, _m_);
             });
   }
   function existsi(t, f){
    function _i_(param){return param ? 1 : 0;}
    var
     _j_ =
       find_mapi
        (t,
         function(i, elt){
          function _k_(b){return b ? _a_ : 0;}
          var _l_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _l_, _k_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _j_, _i_);
   }
   function for_alli(t, f){
    function _e_(param){return param ? 0 : 1;}
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          function _g_(b){return b ? 0 : _b_;}
          var _h_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _f_, _e_);
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _c_(_d_){return _d_;}
    return map(how, caml_call2(Core_List[40], n, _c_), f);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_list);
   var
    Async_kernel_Deferred_list =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (20, Async_kernel_Deferred_list, cst_Async_kernel_Deferred_list$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_map
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_list, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttled, Base__List, Base__Map, Core__Map, Core__Sequence, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_map$0 = "Async_kernel__Deferred_map",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Map = global_data.Core__Map,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Throttled = global_data.Async_kernel__Throttled,
    Base_List = global_data.Base__List,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Base_Map = global_data.Base__Map,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Sequence = global_data.Core__Sequence,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_map$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_map.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_map.ml");
   var
    Throttled_map =
      caml_call1
       (Core_Map[118],
        [0,
         Async_kernel_Throttled[1],
         Async_kernel_Throttled[2],
         Async_kernel_Throttled[3],
         Async_kernel_Throttled[4],
         Async_kernel_Throttled[5],
         Async_kernel_Throttled[6],
         Async_kernel_Throttled[7],
         Async_kernel_Throttled[8],
         Async_kernel_Throttled[9],
         Async_kernel_Throttled[10],
         Async_kernel_Throttled[11],
         Async_kernel_Throttled[12],
         Async_kernel_Throttled[13],
         Async_kernel_Throttled[16]]),
    _a_ = [0, -542431297],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_map = cst_Async_kernel_Deferred_map$0;
   function change(t, k, f){
    function _O_(opt){
     function _Q_(param){return opt;}
     return caml_call3(Core_Map[42], t, k, _Q_);
    }
    var _P_ = caml_call1(f, caml_call2(Core_Map[44], t, k));
    return caml_call2(Async_kernel_Deferred_std[5][2], _P_, _O_);
   }
   function update(t, k, f){
    function _M_(data){return caml_call3(Core_Map[38], t, k, data);}
    var _N_ = caml_call1(f, caml_call2(Core_Map[44], t, k));
    return caml_call2(Async_kernel_Deferred_std[5][2], _N_, _M_);
   }
   function iter_keys(how, t, f){
    var _L_ = caml_call1(Core_Map[79], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _L_, f);
   }
   function iter(how, t, f){
    var _K_ = caml_call1(Core_Map[80], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _K_, f);
   }
   function iteri(how, t, f){
    function _I_(param){
     var data = param[2], key = param[1];
     return caml_call2(f, key, data);
    }
    var _J_ = caml_call2(Core_Map[81], 0, t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _J_, _I_);
   }
   function fold(t, init, f){
    function _G_(key, data, alist){return [0, [0, key, data], alist];}
    var alist_in_increasing_key_order = caml_call3(Core_Map[63], t, 0, _G_);
    function _H_(ac, param){
     var data = param[2], key = param[1];
     return caml_call3(f, key, data, ac);
    }
    return caml_call3
            (Async_kernel_Deferred_list[2],
             alist_in_increasing_key_order,
             init,
             _H_);
   }
   function fold_right(t, init, f){
    function _E_(key, data, alist){return [0, [0, key, data], alist];}
    var alist_in_decreasing_key_order = caml_call3(Core_Map[61], t, 0, _E_);
    function _F_(ac, param){
     var data = param[2], key = param[1];
     return caml_call3(f, key, data, ac);
    }
    return caml_call3
            (Async_kernel_Deferred_list[2],
             alist_in_decreasing_key_order,
             init,
             _F_);
   }
   function result(r){return r[3];}
   function filter_mapi(how, t, f){
    if(typeof how !== "number"){
     var
      max_concurrent_jobs = how[2],
      _p_ =
        function(key, data){
         function _D_(param){return caml_call2(f, key, data);}
         return caml_call1(Async_kernel_Throttled[14], _D_);
        },
      computation = caml_call2(Throttled_map[2], t, _p_);
     return caml_call2
             (Async_kernel_Throttled[15], computation, max_concurrent_jobs);
    }
    if(-676829465 <= how){
     var
      jobs = [0, 0],
      _q_ =
        function(key, data){
         var job = [0, key, data, 0];
         jobs[1] = [0, job, jobs[1]];
         return job;
        },
      job_map = caml_call2(Core_Map[58], t, _q_),
      _r_ = function(param){return caml_call2(Core_Map[68], job_map, result);},
      _s_ =
        function(job){
         var data = job[2], key = job[1];
         function _B_(x){job[3] = x; return 0;}
         var _C_ = caml_call2(f, key, data);
         return caml_call2(Async_kernel_Deferred_std[5][2], _C_, _B_);
        },
      _t_ = caml_call1(Base_List[63], jobs[1]),
      _u_ = caml_call3(Async_kernel_Deferred_list[14], how, _t_, _s_);
     return caml_call2(Async_kernel_Deferred_std[5][2], _u_, _r_);
    }
    var
     comparator = caml_call1(Core_Map[2], t),
     sequence = caml_call4(Core_Map[114], _a_, 0, 0, t);
    function _o_(ivar){
     function _v_(x){
      var
       _z_ = caml_call1(Base_Map[118][3][110][3], x),
       _A_ = caml_call2(Core_Map[124][30], comparator, _z_);
      return caml_call2(Async_kernel_Ivar[14], ivar, _A_);
     }
     function _w_(s, param, k){
      var data = param[2], key = param[1];
      function _x_(param){
       if(! param) return caml_call1(k, s);
       var
        data = param[1],
        s$0 = caml_call4(Base_Map[118][3][110][2], s, comparator, key, data);
       return caml_call1(k, s$0);
      }
      var _y_ = caml_call2(f, key, data);
      return caml_call2(Async_kernel_Deferred_std[11], _y_, _x_);
     }
     return caml_call4
             (Core_Sequence[107],
              sequence,
              Base_Map[118][3][110][1],
              _w_,
              _v_);
    }
    return caml_call1(Async_kernel_Deferred1[4], _o_);
   }
   function filter_map(how, t, f){
    return filter_mapi
            (how, t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              function _m_(b){return b ? [0, data] : 0;}
              var _n_ = caml_call1(f, key);
              return caml_call2(Async_kernel_Deferred_std[5][2], _n_, _m_);
             });
   }
   function filter(how, t, f){
    return filter_mapi
            (how,
             t,
             function(param, data){
              function _k_(b){return b ? [0, data] : 0;}
              var _l_ = caml_call1(f, data);
              return caml_call2(Async_kernel_Deferred_std[5][2], _l_, _k_);
             });
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              function _i_(b){return b ? [0, data] : 0;}
              var _j_ = caml_call2(f, key, data);
              return caml_call2(Async_kernel_Deferred_std[5][2], _j_, _i_);
             });
   }
   function mapi(how, t, f){
    if(typeof how === "number")
     return filter_mapi
             (how,
              t,
              function(key, data){
               function _g_(z){return [0, z];}
               var _h_ = caml_call2(f, key, data);
               return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
              });
    var max_concurrent_jobs = how[2];
    function _e_(key, data){
     function _f_(param){return caml_call2(f, key, data);}
     return caml_call1(Async_kernel_Throttled[14], _f_);
    }
    var computation = caml_call2(Throttled_map[1], t, _e_);
    return caml_call2
            (Async_kernel_Throttled[15], computation, max_concurrent_jobs);
   }
   function map(how, t, f){
    return mapi(how, t, function(param, data){return caml_call1(f, data);});
   }
   function merge(how, t1, t2, f){
    function _c_(thunk){return caml_call1(thunk, 0);}
    function _d_(key, z){
     return [0, function(param){return caml_call2(f, key, z);}];
    }
    return filter_map(how, caml_call3(Core_Map[84], t1, t2, _d_), _c_);
   }
   function all(t){return map(-686623969, t, function(_b_){return _b_;});}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_map);
   var
    Async_kernel_Deferred_map =
      [0,
       change,
       update,
       iter_keys,
       iter,
       iteri,
       map,
       mapi,
       fold,
       fold_right,
       filter_keys,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       merge,
       all];
   runtime.caml_register_global
    (21, Async_kernel_Deferred_map, cst_Async_kernel_Deferred_map$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_memo_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_memo = "Async_kernel__Deferred_memo_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_memo);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_memo_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel, "deferred_memo_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_memo);
   var Async_kernel_Deferred_memo_int = [0];
   runtime.caml_register_global
    (11, Async_kernel_Deferred_memo_int, cst_Async_kernel_Deferred_memo);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_memo
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_memo_intf, Async_kernel__Monitor, Base__Exn, Base__Staged, Core, Core__Memo, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_memo$0 = "Async_kernel__Deferred_memo",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_Memo = global_data.Core__Memo,
    Base_Staged = global_data.Base__Staged,
    Core = global_data.Core,
    Base_Exn = global_data.Base__Exn,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_memo$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_memo.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_memo.ml");
   var
    _b_ = [0, 3804260],
    _c_ = [0, 3903734],
    _a_ = [0, 3804260],
    cst_caught_exception_in_memoiz = "caught exception in memoized function",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_memo = cst_Async_kernel_Deferred_memo$0;
   function Make(M){
    function reraise(param){
     if(0 === param[0]){var x = param[1]; return x;}
     var exn = param[1];
     return caml_call2(Base_Exn[8], exn, cst_caught_exception_in_memoiz);
    }
    function general(run, hashable, f){
     function _h_(a){
      function _k_(param){return caml_call1(f, a);}
      return caml_call7
              (Async_kernel_Monitor[16], 0, 0, 0, 0, [0, run], _a_, _k_);
     }
     var f$0 = caml_call3(Core_Memo[1], [0, hashable[4]], 0, _h_);
     function _i_(a){
      var _j_ = caml_call1(f$0, a);
      return caml_call2(M[2], _j_, reraise);
     }
     return caml_call1(Base_Staged[1], _i_);
    }
    function general$0(hashable, f){return general(3903734, hashable, f);}
    function recursive(hashable, f_onestep){
     var memoized = [];
     runtime.caml_update_dummy
      (memoized,
       [246,
        function(param){
         return general
                 (523273847,
                  hashable,
                  caml_call1
                   (f_onestep,
                    function(x){
                     var _g_ = caml_call1(Core[248], memoized);
                     return caml_call1(caml_call1(Core[267], _g_), x);
                    }));
        }]);
     return caml_call1(Core[248], memoized);
    }
    function unit(f){
     function _d_(param){
      return caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _c_, _b_, f);
     }
     var f$0 = caml_call1(Core_Memo[3], _d_);
     function _e_(param){
      var _f_ = caml_call1(f$0, 0);
      return caml_call2(M[2], _f_, reraise);
     }
     return caml_call1(Base_Staged[1], _e_);
    }
    return [0, general$0, recursive, unit];
   }
   var
    include =
      Make([0, Async_kernel_Deferred1[14], Async_kernel_Deferred1[15]]),
    general = include[1],
    recursive = include[2],
    unit = include[3];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_memo);
   var Async_kernel_Deferred_memo = [0, Make, general, recursive, unit];
   runtime.caml_register_global
    (21, Async_kernel_Deferred_memo, cst_Async_kernel_Deferred_memo$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_option
//# unitInfo: Requires: Async_kernel__Deferred1, Base__Monad, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_opti$0 = "Async_kernel__Deferred_option",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_opti$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_option.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_option.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_opti = cst_Async_kernel_Deferred_opti$0;
   function return$0(a){
    return caml_call1(Async_kernel_Deferred1[21], [0, a]);
   }
   function bind(t, f){
    function _b_(param){
     if(! param) return caml_call1(Async_kernel_Deferred1[21], 0);
     var a = param[1];
     return caml_call1(f, a);
    }
    return caml_call2(Async_kernel_Deferred1[17], t, _b_);
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        function _a_(r){return caml_call2(Core_Option[34], r, f);}
        return caml_call2(Async_kernel_Deferred1[18], t, _a_);
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_opti);
   var
    Async_kernel_Deferred_option =
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax];
   runtime.caml_register_global
    (14, Async_kernel_Deferred_option, cst_Async_kernel_Deferred_opti$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_result
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Base__Monad, Core__Printf, Core__Result, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_resu$0 = "Async_kernel__Deferred_result",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_Printf = global_data.Core__Printf,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_resu$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_result.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_result.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_resu = cst_Async_kernel_Deferred_resu$0;
   function combine(t1, t2, ok, err){
    function _d_(param){
     var t2 = param[2], t1 = param[1];
     return caml_call4(Core_Result[48], t1, t2, ok, err);
    }
    var _e_ = caml_call2(Async_kernel_Deferred_std[5][3], t1, t2);
    return caml_call2(Async_kernel_Deferred_std[5][2], _e_, _d_);
   }
   function return$0(a){
    return caml_call1(Async_kernel_Deferred1[21], [0, a]);
   }
   function bind(t, f){
    function _c_(error){
     if(0 !== error[0]) return caml_call1(Async_kernel_Deferred1[21], error);
     var a = error[1];
     return caml_call1(f, a);
    }
    return caml_call2(Async_kernel_Deferred1[17], t, _c_);
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        function _b_(r){return caml_call2(Core_Result[46], r, f);}
        return caml_call2(Async_kernel_Deferred1[18], t, _b_);
       }],
    include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function fail(x){return caml_call1(Async_kernel_Deferred1[21], [1, x]);}
   function failf(format){return caml_call2(Core_Printf[4], fail, format);}
   function map_error(t, f){
    function _a_(r){return caml_call2(Core_Result[47], r, f);}
    return caml_call2(Async_kernel_Deferred1[18], t, _a_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_resu);
   var
    Async_kernel_Deferred_result =
      [0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       fail,
       failf,
       map_error,
       combine];
   runtime.caml_register_global
    (16, Async_kernel_Deferred_result, cst_Async_kernel_Deferred_resu$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_or_error
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_result, Async_kernel__Monitor, Async_kernel__Throttle, Base__Applicative, Core, Core__Error, Core__List, Core__Or_error, Core__Result, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_or_e$0 = "Async_kernel__Deferred_or_error",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Core_Or_error = global_data.Core__Or_error,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_Error = global_data.Core__Error,
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Base_Applicative = global_data.Base__Applicative;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_or_e$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_or_error.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_or_error.ml");
   var
    try_with = Async_kernel_Monitor[16],
    ignore_m = Async_kernel_Deferred_result[9],
    join = Async_kernel_Deferred_result[8],
    return$0 = Async_kernel_Deferred_result[6],
    bind = Async_kernel_Deferred_result[5],
    Monad_infix = Async_kernel_Deferred_result[4],
    symbol_bind = Async_kernel_Deferred_result[1],
    _c_ = [0, 0],
    _b_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_or_e = cst_Async_kernel_Deferred_or_e$0,
    _a_ = Async_kernel_Deferred_result[7];
   function apply(f, x){
    function _aa_(e1, e2){
     return caml_call1(Core_Error[26], [0, e1, [0, e2, 0]]);
    }
    function _ab_(f, x){return caml_call1(f, x);}
    return caml_call4(Async_kernel_Deferred_result[15], f, x, _ab_, _aa_);
   }
   var
    map = [0, -198771759, _a_],
    include = caml_call1(Base_Applicative[7], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    symbol_bind$0 = Monad_infix[1],
    symbol_map$0 = Monad_infix[2],
    Open_on_rhs = [0];
   function fail(error){
    var _$_ = caml_call1(Core_Result[35], error);
    return caml_call1(Async_kernel_Deferred1[21], _$_);
   }
   function ok_exn(t){
    return caml_call2(Async_kernel_Deferred1[18], t, Core_Or_error[40]);
   }
   function of_exn(backtrace, exn){
    var ___ = caml_call2(Core_Or_error[41], backtrace, exn);
    return caml_call1(Async_kernel_Deferred1[21], ___);
   }
   function of_exn_result(backtrace, t){
    var _Z_ = caml_call1(Core_Or_error[42], backtrace);
    return caml_call2(Async_kernel_Deferred1[18], t, _Z_);
   }
   function error(msg, v, sexp_of){
    var _Y_ = caml_call5(Core_Or_error[44], 0, 0, msg, v, sexp_of);
    return caml_call1(Async_kernel_Deferred1[21], _Y_);
   }
   function error_s(sexp){
    var _X_ = caml_call1(Core_Or_error[45], sexp);
    return caml_call1(Async_kernel_Deferred1[21], _X_);
   }
   function error_string(msg){
    var _W_ = caml_call1(Core_Or_error[46], msg);
    return caml_call1(Async_kernel_Deferred1[21], _W_);
   }
   function errorf(format){
    return caml_call2(Core[254], error_string, format);
   }
   function tag(t, tag){
    var _T_ = Core_Or_error[48];
    function _U_(_V_){return caml_call2(_T_, _V_, tag);}
    return caml_call2(Async_kernel_Deferred1[18], t, _U_);
   }
   function tag_s(t, tag){
    var _Q_ = Core_Or_error[49];
    function _R_(_S_){return caml_call2(_Q_, _S_, tag);}
    return caml_call2(Async_kernel_Deferred1[18], t, _R_);
   }
   function tag_s_lazy(t, tag){
    var _N_ = Core_Or_error[50];
    function _O_(_P_){return caml_call2(_N_, _P_, tag);}
    return caml_call2(Async_kernel_Deferred1[18], t, _O_);
   }
   function tag_arg(t, message, a, sexp_of_a){
    function _M_(t){
     return caml_call4(Core_Or_error[51], t, message, a, sexp_of_a);
    }
    return caml_call2(Async_kernel_Deferred1[18], t, _M_);
   }
   function unimplemented(msg){
    var _L_ = caml_call1(Core_Or_error[52], msg);
    return caml_call1(Async_kernel_Deferred1[21], _L_);
   }
   function combine_errors(l){
    var
     _J_ = Core_Or_error[56],
     _K_ = caml_call1(Async_kernel_Deferred1[44], l);
    return caml_call2(Async_kernel_Deferred1[18], _K_, _J_);
   }
   function combine_errors_unit(l){
    var
     _H_ = Core_Or_error[57],
     _I_ = caml_call1(Async_kernel_Deferred1[44], l);
    return caml_call2(Async_kernel_Deferred1[18], _I_, _H_);
   }
   function filter_ok_at_least_one(l){
    var
     _F_ = Core_Or_error[58],
     _G_ = caml_call1(Async_kernel_Deferred1[44], l);
    return caml_call2(Async_kernel_Deferred1[18], _G_, _F_);
   }
   function find_map_ok(l, f){
    function _B_(param){
     var errors = param[2], l = param[1];
     if(l){
      var
       tl = l[2],
       hd = l[1],
       _C_ =
         function(param){
          if(0 === param[0]){
           var result = param[1];
           return [0, -289386606, [0, result]];
          }
          var current_error = param[1];
          return [0, 990972795, [0, tl, [0, current_error, errors]]];
         },
       _D_ = caml_call1(f, hd);
      return caml_call2(Async_kernel_Deferred1[18], _D_, _C_);
     }
     var
      _E_ = caml_call1(Core_List[59], errors),
      errors$0 = caml_call1(Core_Error[26], _E_);
     return caml_call1
             (Async_kernel_Deferred1[21], [0, -289386606, [1, errors$0]]);
    }
    return caml_call2(Async_kernel_Deferred1[39], [0, l, 0], _B_);
   }
   var ok_unit = caml_call1(return$1, 0);
   function try_with$0(extract_exn, run, rest, here, name, f){
    function _z_(ok){
     if(0 === ok[0]) return ok;
     var exn = ok[1];
     return [1, caml_call2(Core_Error[27], 0, exn)];
    }
    var _A_ = caml_call7(try_with, here, 0, name, extract_exn, run, rest, f);
    return caml_call2(Async_kernel_Deferred1[18], _A_, _z_);
   }
   function try_with_join(extract_exn, run, rest, here, name, f){
    var
     _x_ = Core_Or_error[31],
     _y_ = try_with$0(extract_exn, run, rest, here, name, f);
    return caml_call2(Async_kernel_Deferred1[18], _y_, _x_);
   }
   function foldi(list, acc, f){
    function loop(i, acc, param){
     if(! param) return caml_call1(return$1, acc);
     var tl = param[2], hd = param[1];
     function _w_(acc){return loop(i + 1 | 0, acc, tl);}
     return caml_call2(bind, caml_call3(f, i, acc, hd), _w_);
    }
    return loop(0, acc, list);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function iteri(how, t, f){
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _u_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _v_ = caml_call1(Core[267], _u_);
    return caml_call1(all_unit, caml_call2(Core_List[41], t, _v_));
   }
   function mapi(how, t, f){
    if(typeof how === "number" && -676829465 > how){
     var _q_ = Core_List[59];
     return caml_call2
             (symbol_map$0,
              foldi
               (t,
                0,
                function(i, bs, a){
                 function _t_(b){return [0, b, bs];}
                 return caml_call2(map$0, caml_call2(f, i, a), _t_);
                }),
              _q_);
    }
    var
     _r_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _s_ = caml_call1(Core[267], _r_);
    return caml_call1(all, caml_call2(Core_List[41], t, _s_));
   }
   function filter_mapi(how, t, f){
    var _p_ = Core_List[132];
    return caml_call2(symbol_map$0, mapi(how, t, f), _p_);
   }
   function concat_mapi(how, t, f){
    var _o_ = Core_List[11];
    return caml_call2(symbol_map$0, mapi(how, t, f), _o_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, x){
              function _n_(b){return b ? [0, x] : 0;}
              return caml_call2(map$0, caml_call2(f, i, x), _n_);
             });
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(return$1, 0);
     var tl = t[2], hd = t[1];
     function _m_(some){
      return some ? caml_call1(return$1, some) : find_mapi(tl, f, i + 1 | 0);
     }
     return caml_call2(bind, caml_call2(f, i, hd), _m_);
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _l_(b){return b ? [0, [0, i, elt]] : 0;}
              return caml_call2(map$0, caml_call2(f, i, elt), _l_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _k_(b){return b ? [0, elt] : 0;}
              return caml_call2(map$0, caml_call1(f, elt), _k_);
             });
   }
   function existsi(t, f){
    function _i_(param){return param ? 1 : 0;}
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                function _j_(b){return b ? _b_ : 0;}
                return caml_call2(map$0, caml_call2(f, i, elt), _j_);
               }),
             _i_);
   }
   function for_alli(t, f){
    function _g_(param){return param ? 0 : 1;}
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                function _h_(b){return b ? 0 : _c_;}
                return caml_call2(map$0, caml_call2(f, i, elt), _h_);
               }),
             _g_);
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map$1(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _e_(_f_){return _f_;}
    return map$1(how, caml_call2(Core_List[40], n, _e_), f);
   }
   function repeat_until_finished(state, f){
    function _d_(param){
     if(990972795 <= param[1]){
      var state = param[2];
      return repeat_until_finished(state, f);
     }
     var state$0 = param[2];
     return caml_call1(return$1, state$0);
    }
    return caml_call2(bind, caml_call1(f, state), _d_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_or_e);
   var
    Async_kernel_Deferred_or_error =
      [0,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$1,
        symbol_bind$0,
        symbol_map$0,
        [0, return$1, bind, map$0, both, Open_on_rhs]],
       fail,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_map_ok,
       ok_unit,
       try_with$0,
       try_with_join,
       [0,
        foldi,
        fold,
        find,
        findi,
        find_map,
        find_mapi,
        exists,
        existsi,
        for_all,
        for_alli,
        all,
        all_unit,
        init,
        iter,
        iteri,
        map$1,
        mapi,
        filter,
        filteri,
        filter_map,
        filter_mapi,
        concat_map,
        concat_mapi],
       repeat_until_finished];
   runtime.caml_register_global
    (23, Async_kernel_Deferred_or_error, cst_Async_kernel_Deferred_or_e$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_queue
//# unitInfo: Requires: Async_kernel__Deferred_list, Async_kernel__Deferred_std, Core__Queue, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_queu$0 = "Async_kernel__Deferred_queue",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_queu$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_queue.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_queue.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_queu = cst_Async_kernel_Deferred_queu$0;
   function foldi(t, init, f){
    var _V_ = caml_call1(Core_Queue[28], t);
    return caml_call3(Async_kernel_Deferred_list[1], _V_, init, f);
   }
   function fold(t, init, f){
    var _U_ = caml_call1(Core_Queue[28], t);
    return caml_call3(Async_kernel_Deferred_list[2], _U_, init, f);
   }
   function all(t){
    var
     _R_ = Core_Queue[40],
     _S_ = caml_call1(Core_Queue[28], t),
     _T_ = caml_call1(Async_kernel_Deferred_list[11], _S_);
    return caml_call2(Async_kernel_Deferred_std[4], _T_, _R_);
   }
   function all_unit(t){
    var _Q_ = caml_call1(Core_Queue[28], t);
    return caml_call1(Async_kernel_Deferred_list[12], _Q_);
   }
   function iter(how, t, f){
    var _P_ = caml_call1(Core_Queue[28], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _P_, f);
   }
   function iteri(how, t, f){
    var _O_ = caml_call1(Core_Queue[28], t);
    return caml_call3(Async_kernel_Deferred_list[15], how, _O_, f);
   }
   function map(how, t, f){
    var
     _L_ = Core_Queue[40],
     _M_ = caml_call1(Core_Queue[28], t),
     _N_ = caml_call3(Async_kernel_Deferred_list[16], how, _M_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _N_, _L_);
   }
   function mapi(how, t, f){
    var
     _I_ = Core_Queue[40],
     _J_ = caml_call1(Core_Queue[28], t),
     _K_ = caml_call3(Async_kernel_Deferred_list[17], how, _J_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _K_, _I_);
   }
   function init(how, n, f){
    var
     _G_ = Core_Queue[40],
     _H_ = caml_call3(Async_kernel_Deferred_list[13], how, n, f);
    return caml_call2(Async_kernel_Deferred_std[4], _H_, _G_);
   }
   function filter(how, t, f){
    var
     _D_ = Core_Queue[40],
     _E_ = caml_call1(Core_Queue[28], t),
     _F_ = caml_call3(Async_kernel_Deferred_list[18], how, _E_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _F_, _D_);
   }
   function filteri(how, t, f){
    var
     _A_ = Core_Queue[40],
     _B_ = caml_call1(Core_Queue[28], t),
     _C_ = caml_call3(Async_kernel_Deferred_list[19], how, _B_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _C_, _A_);
   }
   function filter_map(how, t, f){
    var
     _x_ = Core_Queue[40],
     _y_ = caml_call1(Core_Queue[28], t),
     _z_ = caml_call3(Async_kernel_Deferred_list[20], how, _y_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _z_, _x_);
   }
   function filter_mapi(how, t, f){
    var
     _u_ = Core_Queue[40],
     _v_ = caml_call1(Core_Queue[28], t),
     _w_ = caml_call3(Async_kernel_Deferred_list[21], how, _v_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _w_, _u_);
   }
   function concat_map(how, t, f){
    var _o_ = Core_Queue[40];
    function _p_(x){
     var _s_ = Core_Queue[28], _t_ = caml_call1(f, x);
     return caml_call2(Async_kernel_Deferred_std[4], _t_, _s_);
    }
    var
     _q_ = caml_call1(Core_Queue[28], t),
     _r_ = caml_call3(Async_kernel_Deferred_list[22], how, _q_, _p_);
    return caml_call2(Async_kernel_Deferred_std[4], _r_, _o_);
   }
   function concat_mapi(how, t, f){
    var _i_ = Core_Queue[40];
    function _j_(i, x){
     var _m_ = Core_Queue[28], _n_ = caml_call2(f, i, x);
     return caml_call2(Async_kernel_Deferred_std[4], _n_, _m_);
    }
    var
     _k_ = caml_call1(Core_Queue[28], t),
     _l_ = caml_call3(Async_kernel_Deferred_list[23], how, _k_, _j_);
    return caml_call2(Async_kernel_Deferred_std[4], _l_, _i_);
   }
   function find_map(t, f){
    var _h_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[5], _h_, f);
   }
   function find_mapi(t, f){
    var _g_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[6], _g_, f);
   }
   function find(t, f){
    var _f_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[3], _f_, f);
   }
   function findi(t, f){
    var _e_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[4], _e_, f);
   }
   function for_all(t, f){
    var _d_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[9], _d_, f);
   }
   function for_alli(t, f){
    var _c_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[10], _c_, f);
   }
   function exists(t, f){
    var _b_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[7], _b_, f);
   }
   function existsi(t, f){
    var _a_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[8], _a_, f);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_queu);
   var
    Async_kernel_Deferred_queue =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (14, Async_kernel_Deferred_queue, cst_Async_kernel_Deferred_queu$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_sequence
//# unitInfo: Requires: Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Base__Sequence, Core__Bool, Core__List, Core__Sequence, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_sequ$0 = "Async_kernel__Deferred_sequence",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Bool = global_data.Core__Bool,
    Core_Sequence = global_data.Core__Sequence,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Base_Sequence = global_data.Base__Sequence,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_sequ$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_sequence.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_sequence.ml");
   var
    _b_ = [0, 0],
    _a_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_sequ = cst_Async_kernel_Deferred_sequ$0;
   function fold_mapi(opt, t, init, mapi_f, fold_f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    var
     match = caml_call1(Base_Sequence[115][4], t),
     next = match[2],
     state = match[1];
    if(typeof how !== "number"){
     var
      max_concurrent_jobs = how[2],
      throttle = caml_call2(Async_kernel_Throttle[5], 0, max_concurrent_jobs),
      loop$0 =
        function(i, t, c){
         function _Y_(param){
          var match = caml_call1(next, t);
          if(typeof match === "number") return c;
          if(0 === match[0]){
           var state = match[1];
           return loop$0(i, state, c);
          }
          var t$0 = match[2], a = match[1];
          function ___(b){
           function _ab_(c){return caml_call2(fold_f, c, b);}
           return caml_call2(Async_kernel_Deferred_std[5][2], c, _ab_);
          }
          function _$_(param){return caml_call2(mapi_f, i, a);}
          var _aa_ = caml_call2(Async_kernel_Throttle[10], throttle, _$_);
          return loop$0
                  (i + 1 | 0,
                   t$0,
                   caml_call2(Async_kernel_Deferred_std[5][1], _aa_, ___));
         }
         var _Z_ = caml_call1(Async_kernel_Throttle[20], throttle);
         return caml_call2(Async_kernel_Deferred_std[5][1], _Z_, _Y_);
        };
     return loop$0(0, state, caml_call1(Async_kernel_Deferred_std[10], init));
    }
    if(-676829465 > how){
     var
      result = caml_call1(Async_kernel_Ivar[12], 0),
      loop =
        function(i, state, c){
         var state$0 = state;
         for(;;){
          var match = caml_call1(next, state$0);
          if(typeof match === "number")
           return caml_call2(Async_kernel_Ivar[14], result, c);
          if(0 !== match[0]){
           var
            state$2 = match[2],
            a = match[1],
            _W_ =
              function(b){
               return loop(i + 1 | 0, state$2, caml_call2(fold_f, c, b));
              },
            _X_ = caml_call2(mapi_f, i, a);
           return caml_call2(Async_kernel_Deferred_std[11], _X_, _W_);
          }
          var state$1 = match[1], state$0 = state$1;
         }
        };
     loop(0, state, init);
     return caml_call1(Async_kernel_Ivar[19], result);
    }
    var
     c$1 = caml_call1(Async_kernel_Deferred_std[10], init),
     i = 0,
     t$0 = state,
     c = c$1;
    for(;;){
     var match$0 = caml_call1(next, t$0);
     if(typeof match$0 === "number") return c;
     if(0 === match$0[0])
      var state$0 = match$0[1], t$0 = state$0;
     else
      var
       t$1 = match$0[2],
       a = match$0[1],
       _T_ =
         function(c){
           return function(b){
            function _V_(c){return caml_call2(fold_f, c, b);}
            return caml_call2(Async_kernel_Deferred_std[5][2], c, _V_);};
          }
          (c),
       _U_ = caml_call2(mapi_f, i, a),
       c$0 = caml_call2(Async_kernel_Deferred_std[5][1], _U_, _T_),
       i$0 = i + 1 | 0,
       i = i$0,
       t$0 = t$1,
       c = c$0;
    }
   }
   function foldi(t, init, f){
    function _P_(param){
     var b = param[2];
     return caml_call1(Async_kernel_Deferred_std[10], b);
    }
    function _Q_(param, a, k){
     var b = param[2], i = param[1];
     function _R_(b){return caml_call1(k, [0, i + 1 | 0, b]);}
     var _S_ = caml_call3(f, i, b, a);
     return caml_call2(Async_kernel_Deferred_std[5][1], _S_, _R_);
    }
    return caml_call4(Core_Sequence[107], t, [0, 0, init], _Q_, _P_);
   }
   function fold(t, init, f){
    var _M_ = Async_kernel_Deferred_std[10];
    function _N_(b, a, k){
     var _O_ = caml_call2(f, b, a);
     return caml_call2(Async_kernel_Deferred_std[3], _O_, k);
    }
    return caml_call4(Core_Sequence[107], t, init, _N_, _M_);
   }
   function all(t){
    function _I_(res){
     var _L_ = caml_call1(Core_List[59], res);
     return caml_call1(Core_Sequence[111], _L_);
    }
    var
     _J_ =
       fold
        (t,
         0,
         function(accum, d){
          function _K_(a){return [0, a, accum];}
          return caml_call2(Async_kernel_Deferred_std[5][2], d, _K_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _J_, _I_);
   }
   function all_unit(t){return fold(t, 0, function(param, v){return v;});}
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     var match = caml_call1(Core_Sequence[50], t);
     if(! match) return caml_call1(Async_kernel_Deferred_std[10], 0);
     var match$0 = match[1], rest = match$0[2], v = match$0[1];
     function _G_(some){
      return some
              ? caml_call1(Async_kernel_Deferred_std[10], some)
              : find_mapi(rest, f, i + 1 | 0);
     }
     var _H_ = caml_call2(f, i, v);
     return caml_call2(Async_kernel_Deferred_std[5][1], _H_, _G_);
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _E_(b){return b ? [0, [0, i, elt]] : 0;}
              var _F_ = caml_call2(f, i, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _F_, _E_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _C_(b){return b ? [0, elt] : 0;}
              var _D_ = caml_call1(f, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _D_, _C_);
             });
   }
   function existsi(t, f){
    function _y_(param){return param ? 1 : 0;}
    var
     _z_ =
       find_mapi
        (t,
         function(i, elt){
          function _A_(b){return b ? _a_ : 0;}
          var _B_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _B_, _A_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _z_, _y_);
   }
   function for_alli(t, f){
    function _u_(param){return param ? 0 : 1;}
    var
     _v_ =
       find_mapi
        (t,
         function(i, elt){
          function _w_(b){return b ? 0 : _b_;}
          var _x_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _x_, _w_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _v_, _u_);
   }
   function iteri(how, t, f){
    return fold_mapi([0, how], t, 0, f, function(param, _t_){return 0;});
   }
   function mapi(how, t, f){
    function _p_(bs){
     var _s_ = caml_call1(Core_List[59], bs);
     return caml_call1(Core_Sequence[111], _s_);
    }
    function _q_(bs, b){return [0, b, bs];}
    var
     _r_ =
       fold_mapi
        ([0, how], t, 0, function(i, a){return caml_call2(f, i, a);}, _q_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _r_, _p_);
   }
   function filter_mapi(how, t, f){
    function _l_(bs){
     var _o_ = caml_call1(Core_List[59], bs);
     return caml_call1(Core_Sequence[111], _o_);
    }
    function _m_(bs, maybe_v){
     if(! maybe_v) return bs;
     var b = maybe_v[1];
     return [0, b, bs];
    }
    var
     _n_ =
       fold_mapi
        ([0, how], t, 0, function(i, a){return caml_call2(f, i, a);}, _m_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _n_, _l_);
   }
   function concat_mapi(how, t, f){
    var _j_ = Core_Sequence[72], _k_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _k_, _j_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, a){
              function _h_(param){return param ? [0, a] : 0;}
              var _i_ = caml_call2(f, i, a);
              return caml_call2(Async_kernel_Deferred_std[5][2], _i_, _h_);
             });
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _f_(_g_){return _g_;}
    return map(how, caml_call2(Core_Sequence[85], n, _f_), f);
   }
   function count(how, t, f){
    function _e_(acc, c){return acc + caml_call1(Core_Bool[11], c) | 0;}
    return fold_mapi(how, t, 0, function(i, a){return caml_call1(f, a);}, _e_);
   }
   function sum(M, how, t, f){
    var _c_ = M[2];
    function _d_(i, a){return caml_call1(f, a);}
    return fold_mapi(how, t, M[1], _d_, _c_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_sequ);
   var
    Async_kernel_Deferred_sequence =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi,
       fold_mapi,
       count,
       sum];
   runtime.caml_register_global
    (20, Async_kernel_Deferred_sequence, cst_Async_kernel_Deferred_sequ$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_set
//# unitInfo: Requires: Async_kernel__Deferred_sequence, Async_kernel__Deferred_std, Core__Fn, Core__Set, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_set$0 = "Async_kernel__Deferred_set",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Set = global_data.Core__Set,
    Async_kernel_Deferred_sequence =
      global_data.Async_kernel__Deferred_sequence,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core_Fn = global_data.Core__Fn,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_set$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_set.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_set.ml");
   var
    _a_ = [0, -128674501],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_set = cst_Async_kernel_Deferred_set$0;
   function for_all(t, f){
    var _s_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call2(Async_kernel_Deferred_sequence[9], _s_, f);
   }
   function find(t, f){
    var _r_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call2(Async_kernel_Deferred_sequence[3], _r_, f);
   }
   function find_map(t, f){
    var _q_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call2(Async_kernel_Deferred_sequence[5], _q_, f);
   }
   function fold(t, init, f){
    var _p_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call3(Async_kernel_Deferred_sequence[2], _p_, init, f);
   }
   function fold_right(t, init, f){
    var
     _n_ = caml_call1(Core_Fn[6], f),
     _o_ = caml_call4(Core_Set[68], _a_, 0, 0, t);
    return caml_call3(Async_kernel_Deferred_sequence[2], _o_, init, _n_);
   }
   function iter(how, t, f){
    var _m_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call3(Async_kernel_Deferred_sequence[14], how, _m_, f);
   }
   function filter_map(M, how, t, f){
    function _i_(acc, v){
     if(! v) return acc;
     var v$0 = v[1];
     return caml_call2(Core_Set[12], acc, v$0);
    }
    function _j_(i, a){return caml_call1(f, a);}
    var
     _k_ = caml_call1(Core_Set[3][1], M[1]),
     _l_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call5
            (Async_kernel_Deferred_sequence[24], [0, how], _l_, _k_, _j_, _i_);
   }
   function filter(how, t, f){
    function _f_(x){
     function _g_(param){return param ? [0, x] : 0;}
     var _h_ = caml_call1(f, x);
     return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
    }
    return filter_map(caml_call1(Core_Set[5], t), how, t, _f_);
   }
   function map(comparator, how, t, f){
    return filter_map
            (comparator,
             how,
             t,
             function(x){
              function _d_(y){return [0, y];}
              var _e_ = caml_call1(f, x);
              return caml_call2(Async_kernel_Deferred_std[5][2], _e_, _d_);
             });
   }
   function count(how, t, f){
    var _c_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call3(Async_kernel_Deferred_sequence[25], [0, how], _c_, f);
   }
   function sum(M, how, t, f){
    var _b_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call4(Async_kernel_Deferred_sequence[26], M, [0, how], _b_, f);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_set);
   var
    Async_kernel_Deferred_set =
      [0,
       for_all,
       count,
       sum,
       find,
       find_map,
       map,
       filter_map,
       filter,
       fold,
       fold_right,
       iter];
   runtime.caml_register_global
    (16, Async_kernel_Deferred_set, cst_Async_kernel_Deferred_set$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred
//# unitInfo: Requires: Async_kernel__Deferred1, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred = "Async_kernel__Deferred",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel, "deferred.ml");
   var
    sexp_of_t = Async_kernel_Deferred1[1],
    invariant = Async_kernel_Deferred1[2],
    create = Async_kernel_Deferred1[4],
    peek = Async_kernel_Deferred1[5],
    value_exn = Async_kernel_Deferred1[6],
    is_determined = Async_kernel_Deferred1[7],
    upon = Async_kernel_Deferred1[8],
    never = Async_kernel_Deferred1[12],
    symbol_bind = Async_kernel_Deferred1[14],
    symbol_map = Async_kernel_Deferred1[15],
    Monad_infix = Async_kernel_Deferred1[16],
    bind = Async_kernel_Deferred1[17],
    map = Async_kernel_Deferred1[18],
    join = Async_kernel_Deferred1[19],
    ignore_m = Async_kernel_Deferred1[20],
    return$0 = Async_kernel_Deferred1[21],
    Let_syntax = Async_kernel_Deferred1[22],
    unit = Async_kernel_Deferred1[23],
    both = Async_kernel_Deferred1[24],
    Infix = Async_kernel_Deferred1[25],
    don_t_wait_for = Async_kernel_Deferred1[26],
    Choice = Async_kernel_Deferred1[27],
    choice = Async_kernel_Deferred1[29],
    enabled = Async_kernel_Deferred1[30],
    choose = Async_kernel_Deferred1[34],
    any = Async_kernel_Deferred1[36],
    any_unit = Async_kernel_Deferred1[37],
    for$0 = Async_kernel_Deferred1[38],
    repeat_until_finished = Async_kernel_Deferred1[39],
    forever = Async_kernel_Deferred1[40],
    all = Async_kernel_Deferred1[44],
    all_unit = Async_kernel_Deferred1[45],
    ok = Async_kernel_Deferred1[46],
    For_tests = Async_kernel_Deferred1[47];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred);
   var
    _a_ = Let_syntax[4],
    Async_kernel_Deferred =
      [0,
       sexp_of_t,
       invariant,
       create,
       upon,
       peek,
       value_exn,
       is_determined,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$0,
       map,
       join,
       ignore_m,
       [0,
        Let_syntax[3],
        Let_syntax[1],
        Let_syntax[2],
        [0, _a_[5], _a_[1], _a_[2], _a_[3], _a_[4]]],
       [0, Infix[1], Infix[2], Infix[3]],
       unit,
       never,
       both,
       all,
       all_unit,
       any,
       any_unit,
       don_t_wait_for,
       Choice,
       choice,
       enabled,
       choose,
       for$0,
       repeat_until_finished,
       forever,
       ok,
       For_tests];
   runtime.caml_register_global
    (12, Async_kernel_Deferred, cst_Async_kernel_Deferred);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Require_explicit_time_source
//# unitInfo: Requires: Async_kernel__Async_kernel_scheduler, Async_kernel__Clock_ns, Async_kernel__Time_ns, Core__Date, Core__Time_float, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Require_expli =
      "Async_kernel__Require_explicit_time_source",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Core_Date = global_data.Core__Date,
    Async_kernel_Async_kernel_sche =
      global_data.Async_kernel__Async_kernel_scheduler,
    Core_Time_float = global_data.Core__Time_float,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Require_expli);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/require_explicit_time_source.ml");
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_async_kernel,
     "require_explicit_time_source.ml");
   var
    after = Async_kernel_Clock_ns[4],
    at = Async_kernel_Clock_ns[3],
    every = Async_kernel_Clock_ns[11],
    with_timeout = Async_kernel_Clock_ns[5];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Require_expli);
   var
    Async_kernel_Require_explicit_ =
      [0,
       Async_kernel_Clock_ns,
       [0,
        Async_kernel_Time_ns[1],
        Async_kernel_Time_ns[2],
        Async_kernel_Time_ns[3],
        Async_kernel_Time_ns[4],
        Async_kernel_Time_ns[5],
        Async_kernel_Time_ns[6],
        Async_kernel_Time_ns[7],
        Async_kernel_Time_ns[8],
        Async_kernel_Time_ns[9],
        Async_kernel_Time_ns[10],
        Async_kernel_Time_ns[11],
        Async_kernel_Time_ns[12],
        Async_kernel_Time_ns[13],
        Async_kernel_Time_ns[14],
        Async_kernel_Time_ns[15],
        Async_kernel_Time_ns[16],
        Async_kernel_Time_ns[17],
        Async_kernel_Time_ns[18],
        Async_kernel_Time_ns[19],
        Async_kernel_Time_ns[20],
        Async_kernel_Time_ns[21],
        Async_kernel_Time_ns[22],
        Async_kernel_Time_ns[23],
        Async_kernel_Time_ns[24],
        Async_kernel_Time_ns[25],
        Async_kernel_Time_ns[26],
        Async_kernel_Time_ns[27],
        Async_kernel_Time_ns[28],
        Async_kernel_Time_ns[29],
        Async_kernel_Time_ns[30],
        Async_kernel_Time_ns[31],
        Async_kernel_Time_ns[32],
        Async_kernel_Time_ns[33],
        Async_kernel_Time_ns[34],
        Async_kernel_Time_ns[35],
        Async_kernel_Time_ns[36],
        Async_kernel_Time_ns[37],
        Async_kernel_Time_ns[38],
        Async_kernel_Time_ns[39],
        Async_kernel_Time_ns[40],
        Async_kernel_Time_ns[41],
        Async_kernel_Time_ns[43],
        Async_kernel_Time_ns[44],
        Async_kernel_Time_ns[45],
        Async_kernel_Time_ns[46],
        Async_kernel_Time_ns[47],
        Async_kernel_Time_ns[48],
        Async_kernel_Time_ns[49],
        Async_kernel_Time_ns[50],
        Async_kernel_Time_ns[51],
        Async_kernel_Time_ns[52],
        Async_kernel_Time_ns[53],
        Async_kernel_Time_ns[54],
        Async_kernel_Time_ns[55],
        Async_kernel_Time_ns[56],
        Async_kernel_Time_ns[57],
        Async_kernel_Time_ns[58],
        Async_kernel_Time_ns[59],
        Async_kernel_Time_ns[60],
        Async_kernel_Time_ns[61],
        Async_kernel_Time_ns[62],
        Async_kernel_Time_ns[63],
        Async_kernel_Time_ns[64],
        Async_kernel_Time_ns[65],
        Async_kernel_Time_ns[66],
        Async_kernel_Time_ns[67],
        Async_kernel_Time_ns[68],
        Async_kernel_Time_ns[69],
        Async_kernel_Time_ns[70],
        Async_kernel_Time_ns[71],
        Async_kernel_Time_ns[72],
        Async_kernel_Time_ns[73],
        Async_kernel_Time_ns[74],
        Async_kernel_Time_ns[75],
        Async_kernel_Time_ns[76],
        Async_kernel_Time_ns[77],
        Async_kernel_Time_ns[78],
        Async_kernel_Time_ns[79],
        Async_kernel_Time_ns[80],
        Async_kernel_Time_ns[81],
        Async_kernel_Time_ns[82],
        Async_kernel_Time_ns[83],
        Async_kernel_Time_ns[84],
        Async_kernel_Time_ns[85],
        Async_kernel_Time_ns[86],
        Async_kernel_Time_ns[87],
        Async_kernel_Time_ns[88],
        Async_kernel_Time_ns[89],
        Async_kernel_Time_ns[90],
        Async_kernel_Time_ns[91],
        Async_kernel_Time_ns[92],
        Async_kernel_Time_ns[93],
        Async_kernel_Time_ns[94],
        Async_kernel_Time_ns[95],
        Async_kernel_Time_ns[96],
        Async_kernel_Time_ns[97],
        Async_kernel_Time_ns[98],
        Async_kernel_Time_ns[99],
        Async_kernel_Time_ns[100],
        Async_kernel_Time_ns[101],
        Async_kernel_Time_ns[102],
        Async_kernel_Time_ns[103],
        Async_kernel_Time_ns[104],
        Async_kernel_Time_ns[105],
        Async_kernel_Time_ns[106],
        Async_kernel_Time_ns[107],
        Async_kernel_Time_ns[108],
        Async_kernel_Time_ns[109],
        Async_kernel_Time_ns[110],
        Async_kernel_Time_ns[111],
        Async_kernel_Time_ns[112],
        Async_kernel_Time_ns[113],
        Async_kernel_Time_ns[114],
        Async_kernel_Time_ns[115],
        Async_kernel_Time_ns[116],
        Async_kernel_Time_ns[117],
        Async_kernel_Time_ns[118],
        Async_kernel_Time_ns[119],
        Async_kernel_Time_ns[42]],
       [0,
        Core_Time_float[1],
        Core_Time_float[2],
        Core_Time_float[3],
        Core_Time_float[4],
        Core_Time_float[5],
        Core_Time_float[6],
        Core_Time_float[7],
        Core_Time_float[8],
        Core_Time_float[9],
        Core_Time_float[10],
        Core_Time_float[11],
        Core_Time_float[12],
        Core_Time_float[14],
        Core_Time_float[15],
        Core_Time_float[16],
        Core_Time_float[17],
        Core_Time_float[18],
        Core_Time_float[19],
        Core_Time_float[20],
        Core_Time_float[21],
        Core_Time_float[22],
        Core_Time_float[23],
        Core_Time_float[24],
        Core_Time_float[25],
        Core_Time_float[26],
        Core_Time_float[27],
        Core_Time_float[28],
        Core_Time_float[29],
        Core_Time_float[30],
        Core_Time_float[31],
        Core_Time_float[32],
        Core_Time_float[33],
        Core_Time_float[34],
        Core_Time_float[35],
        Core_Time_float[36],
        Core_Time_float[37],
        Core_Time_float[38],
        Core_Time_float[39],
        Core_Time_float[40],
        Core_Time_float[41],
        Core_Time_float[42],
        Core_Time_float[43],
        Core_Time_float[45],
        Core_Time_float[46],
        Core_Time_float[48],
        Core_Time_float[49],
        Core_Time_float[50],
        Core_Time_float[51],
        Core_Time_float[52],
        Core_Time_float[53],
        Core_Time_float[54],
        Core_Time_float[55],
        Core_Time_float[56],
        Core_Time_float[57],
        Core_Time_float[58],
        Core_Time_float[59],
        Core_Time_float[60],
        Core_Time_float[61],
        Core_Time_float[62],
        Core_Time_float[63],
        Core_Time_float[64],
        Core_Time_float[65],
        Core_Time_float[66],
        Core_Time_float[67],
        Core_Time_float[68],
        Core_Time_float[69],
        Core_Time_float[70],
        Core_Time_float[71],
        Core_Time_float[72],
        Core_Time_float[73],
        Core_Time_float[74],
        Core_Time_float[75],
        Core_Time_float[76],
        Core_Time_float[77],
        Core_Time_float[78],
        Core_Time_float[79],
        Core_Time_float[80],
        Core_Time_float[81],
        Core_Time_float[82],
        Core_Time_float[93],
        Core_Time_float[94],
        Core_Time_float[95],
        Core_Time_float[96],
        Core_Time_float[97],
        Core_Time_float[98],
        Core_Time_float[99],
        Core_Time_float[100],
        Core_Time_float[101],
        Core_Time_float[102],
        Core_Time_float[103],
        Core_Time_float[104],
        Core_Time_float[105],
        Core_Time_float[106],
        Core_Time_float[107],
        Core_Time_float[108],
        Core_Time_float[109],
        Core_Time_float[110],
        Core_Time_float[111],
        Core_Time_float[112],
        Core_Time_float[113],
        Core_Time_float[114],
        Core_Time_float[115],
        Core_Time_float[47]],
       [0,
        Async_kernel_Async_kernel_sche[1],
        Async_kernel_Async_kernel_sche[2],
        Async_kernel_Async_kernel_sche[3],
        Async_kernel_Async_kernel_sche[4],
        Async_kernel_Async_kernel_sche[5],
        Async_kernel_Async_kernel_sche[6],
        Async_kernel_Async_kernel_sche[7],
        Async_kernel_Async_kernel_sche[8],
        Async_kernel_Async_kernel_sche[9],
        Async_kernel_Async_kernel_sche[10],
        Async_kernel_Async_kernel_sche[11],
        Async_kernel_Async_kernel_sche[12],
        Async_kernel_Async_kernel_sche[13],
        Async_kernel_Async_kernel_sche[16],
        Async_kernel_Async_kernel_sche[17],
        Async_kernel_Async_kernel_sche[18],
        Async_kernel_Async_kernel_sche[19],
        Async_kernel_Async_kernel_sche[20],
        Async_kernel_Async_kernel_sche[21],
        Async_kernel_Async_kernel_sche[22],
        Async_kernel_Async_kernel_sche[23],
        Async_kernel_Async_kernel_sche[24],
        Async_kernel_Async_kernel_sche[25],
        Async_kernel_Async_kernel_sche[26],
        Async_kernel_Async_kernel_sche[27],
        Async_kernel_Async_kernel_sche[28],
        Async_kernel_Async_kernel_sche[29],
        Async_kernel_Async_kernel_sche[30],
        Async_kernel_Async_kernel_sche[31],
        Async_kernel_Async_kernel_sche[32],
        Async_kernel_Async_kernel_sche[33],
        Async_kernel_Async_kernel_sche[14],
        Async_kernel_Async_kernel_sche[15]],
       [0,
        Core_Date[1],
        Core_Date[2],
        Core_Date[3],
        Core_Date[4],
        Core_Date[5],
        Core_Date[6],
        Core_Date[7],
        Core_Date[8],
        Core_Date[9],
        Core_Date[10],
        Core_Date[11],
        Core_Date[12],
        Core_Date[13],
        Core_Date[14],
        Core_Date[15],
        Core_Date[16],
        Core_Date[17],
        Core_Date[18],
        Core_Date[22],
        Core_Date[23],
        Core_Date[24],
        Core_Date[25],
        Core_Date[26],
        Core_Date[27],
        Core_Date[28],
        Core_Date[29],
        Core_Date[30],
        Core_Date[31],
        Core_Date[32],
        Core_Date[33],
        Core_Date[34],
        Core_Date[35],
        Core_Date[36],
        Core_Date[37],
        Core_Date[38],
        Core_Date[39],
        Core_Date[40],
        Core_Date[41],
        Core_Date[43],
        Core_Date[47],
        Core_Date[48],
        Core_Date[49],
        Core_Date[50],
        Core_Date[51],
        Core_Date[52],
        Core_Date[53],
        Core_Date[54],
        Core_Date[55],
        Core_Date[56],
        Core_Date[57],
        Core_Date[58],
        Core_Date[59],
        Core_Date[60],
        Core_Date[61],
        Core_Date[62],
        Core_Date[63],
        Core_Date[64],
        Core_Date[65],
        Core_Date[66],
        Core_Date[67],
        Core_Date[68],
        Core_Date[69],
        Core_Date[70],
        Core_Date[71],
        Core_Date[72],
        Core_Date[73],
        Core_Date[74],
        Core_Date[75],
        Core_Date[76],
        Core_Date[77],
        Core_Date[78],
        Core_Date[79],
        Core_Date[80],
        Core_Date[81],
        Core_Date[82],
        Core_Date[83],
        Core_Date[84],
        Core_Date[85],
        Core_Date[86],
        Core_Date[87],
        Core_Date[88],
        Core_Date[89],
        Core_Date[90],
        Core_Date[91],
        Core_Date[92],
        Core_Date[93],
        Core_Date[99],
        Core_Date[101],
        Core_Date[102],
        Core_Date[103],
        Core_Date[100]],
       at,
       after,
       every,
       with_timeout];
   runtime.caml_register_global
    (16, Async_kernel_Require_explicit_, cst_Async_kernel_Require_expli);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Pipe
//# unitInfo: Requires: Async_kernel__Async_stream, Async_kernel__Deferred, Async_kernel__Deferred_list, Async_kernel__Deferred_queue, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Tail, Base__Field, Core, Core__Bag, Core__Bool, Core__Hashtbl, Core__Int, Core__List, Core__Option, Core__Queue, Core__Sequence, Core__Sexp, Core__Source_code_position, Pairing_heap, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexp_hidden_in_test, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Pipe$0 = "Async_kernel__Pipe",
    cst_Eof = "Eof",
    cst_Ok = "Ok",
    cst_Reader_closed = "Reader_closed",
    cst = "_",
    cst_async_kernel$0 = "async_kernel",
    cst_blocked_flushes$0 = "blocked_flushes",
    cst_blocked_reads$0 = "blocked_reads",
    cst_consumer$0 = "consumer",
    cst_consumers$0 = "consumers",
    cst_exn = "exn",
    cst_n = "n",
    cst_pipe = "pipe",
    cst_pushback$0 = "pushback",
    cst_reserved_space$0 = "reserved_space",
    cst_size_budget$0 = "size_budget",
    cst_src_pipe_ml = "src/pipe.ml",
    cst_values_read$0 = "values_read",
    cst_wants$0 = "wants",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Pairing_heap = global_data.Pairing_heap,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Sequence = global_data.Core__Sequence,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred_queue = global_data.Async_kernel__Deferred_queue,
    Core_Sexp = global_data.Core__Sexp,
    Core_Option = global_data.Core__Option,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core = global_data.Core,
    Core_Int = global_data.Core__Int,
    Core_Bag = global_data.Core__Bag,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Core_Bool = global_data.Core__Bool,
    Base_Field = global_data.Base__Field,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Sexp_hidden_in_test = global_data.Sexp_hidden_in_test,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Pipe$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_pipe_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "pipe.ml");
   var
    show_debug_messages = [0, 0],
    check_invariant = [0, 0],
    cst_Pipe_interleave = "Pipe.interleave",
    _a3_ = [0, "Mapped"],
    _a2_ = [0, cst_src_pipe_ml, 978, 4],
    _a1_ = [0, "max_iterations_per_job"],
    cst_iter_without_pushback_got_ =
      "iter_without_pushback got non-positive max_iterations_per_job",
    _aZ_ = [0, 3804260],
    _a0_ = [0, 523273847],
    _aW_ = [0, "When_value_read"],
    _aX_ = [0, "When_value_processed"],
    _aY_ = [0, "Consumer"],
    _aV_ = [0, cst_src_pipe_ml, 708, 6],
    _aU_ = [0, "num_values"],
    cst_Pipe_read_exactly_got_num_ = "Pipe.read_exactly got num_values <= 0",
    cst_read_exactly = "read_exactly",
    _aT_ = [0, "here"],
    cst_Pipe_read_choice_single_co =
      "Pipe.read_choice_single_consumer_exn: choice was enabled but pipe is empty; this is likely due to a race condition with one or more other consumers",
    cst_values_available = "values_available",
    cst_Pipe_read_exn_received_EOF = "Pipe.read_exn: received EOF",
    cst_read$0 = "read",
    _aS_ = [0, cst_src_pipe_ml, 657, 4],
    cst_read = "read'",
    cst_Pipe_read_now_exn_nothing_ = "Pipe.read_now_exn: nothing available",
    cst_Pipe_read_now_exn_received = "Pipe.read_now_exn: received EOF",
    _aR_ = [0, "max_queue_length"],
    cst_max_queue_length_0 = "max_queue_length <= 0",
    cst_read_now = "read_now",
    _aQ_ = [0, cst_src_pipe_ml, 600, 4],
    _aP_ = [0, cst],
    _aO_ = [0, cst],
    _aL_ = [0, cst],
    _aM_ = [0, cst_pipe],
    _aN_ = [0, cst_consumer$0],
    cst_Attempt_to_use_consumer_wi = "Attempt to use consumer with wrong pipe",
    _aJ_ = [0, cst],
    _aI_ = [0, cst],
    _aK_ = [0, cst_pipe],
    cst_write_to_closed_pipe = "write to closed pipe",
    _aH_ = [0, cst],
    _aG_ = [0, cst],
    cst_write = "write",
    _aE_ = [0, cst_n],
    _aF_ = [0, "t.reserved_space"],
    cst_overflow_when_reserving_sp = "overflow when reserving space",
    _aD_ = [0, cst_n],
    cst_reserving_negative_space = "reserving negative space",
    _aC_ = [0, cst_src_pipe_ml, 478, 2],
    _aB_ = [0, cst_src_pipe_ml, 469, 2],
    _aA_ = [0, cst],
    _az_ = [0, cst],
    cst_close_read = "close_read",
    _ay_ = [0, cst],
    _ax_ = [0, cst],
    cst_close = "close",
    _aw_ = [0, cst_size_budget$0],
    cst_negative_size_budget = "negative size_budget",
    _av_ = [0, cst_src_pipe_ml, 319, 2],
    _au_ = [0, cst_src_pipe_ml, 312, 2],
    _ah_ = [0, cst],
    _ag_ = [0, cst],
    _ai_ = [0, cst_pipe],
    _aj_ = [0, cst_exn],
    cst_Pipe_invariant_failed = "Pipe.invariant failed",
    _at_ = [0, cst_src_pipe_ml, 269, 46],
    _as_ = [0, cst_src_pipe_ml, 270, 52],
    _ar_ = [0, cst_src_pipe_ml, 273, 11],
    _ao_ = [0, cst_src_pipe_ml, 281, 13],
    _aq_ = [0, cst_src_pipe_ml, 282, 11],
    _ap_ = [0, cst_src_pipe_ml, 288, 30],
    _al_ = [0, cst_src_pipe_ml, 296, 13],
    _an_ = [0, cst_src_pipe_ml, 293, 36],
    _am_ = [0, cst_src_pipe_ml, 298, 31],
    _ak_ = [0, cst_src_pipe_ml, 305, 13],
    _V_ = [0, "upstream_flusheds"],
    _W_ = [0, cst_consumers$0],
    _X_ = [0, "read_closed"],
    _Y_ = [0, "closed"],
    _Z_ = [0, cst_blocked_reads$0],
    ___ = [0, cst_blocked_flushes$0],
    _$_ = [0, "num_values_read"],
    _aa_ = [0, cst_pushback$0],
    _ab_ = [0, cst_reserved_space$0],
    _ac_ = [0, cst_size_budget$0],
    _ad_ = [0, "buffer"],
    _ae_ = [0, "info"],
    _af_ = [0, "id"],
    _F_ = [0, cst_Ok],
    _G_ = [0, cst_Reader_closed],
    _H_ = [0, "ready"],
    _I_ = [0, "fill_when_num_values_read"],
    _B_ = [0, cst],
    _C_ = [0, cst_pipe],
    _D_ = [0, cst_exn],
    cst_Pipe_Blocked_read_invarian = "Pipe.Blocked_read.invariant failed",
    _E_ = [0, cst_src_pipe_ml, 144, 32],
    _z_ = [0, cst_consumer$0],
    _A_ = [0, cst_wants$0],
    _s_ = [0, cst_Eof],
    _t_ = [0, cst_Ok],
    _p_ = [0, cst_Eof],
    _q_ = [0, cst_Ok],
    _m_ = [0, cst_Eof],
    _n_ = [0, cst_Ok],
    _o_ = [0, "Zero"],
    _r_ = [0, "One"],
    _u_ = [0, "At_most"],
    _j_ = [0, cst_pipe],
    _k_ = [0, cst_exn],
    cst_Pipe_Consumer_invariant_fa = "Pipe.Consumer.invariant failed",
    _l_ = [0, cst_src_pipe_ml, 83, 53],
    _e_ = [0, "downstream_flushed"],
    _f_ = [0, "Have_been_sent_downstream"],
    _i_ = [0, "Have_not_been_sent_downstream"],
    _g_ = [0, cst_values_read$0],
    _h_ = [0, "pipe_id"],
    _a_ = [0, cst_Ok],
    _b_ = [0, cst_Reader_closed],
    cst_values_read = cst_values_read$0,
    cst_consumer = cst_consumer$0,
    cst_wants = cst_wants$0,
    cst_consumers = cst_consumers$0,
    cst_blocked_reads = cst_blocked_reads$0,
    cst_blocked_flushes = cst_blocked_flushes$0,
    cst_pushback = cst_pushback$0,
    cst_reserved_space = cst_reserved_space$0,
    cst_size_budget = cst_size_budget$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Pipe = cst_Async_kernel_Pipe$0;
   function compare(a_001, b_002){
    if(a_001 === b_002) return 0;
    if(17724 <= a_001){
     if(typeof b_002 === "number" && 17724 === b_002) return 0;
    }
    else if(typeof b_002 === "number" && -402004920 === b_002) return 0;
    return runtime.caml_int_compare(a_001, b_002);
   }
   function sexp_of_t(param){return 17724 <= param ? _a_ : _b_;}
   function equal(x_003, x_004){return 0 === compare(x_003, x_004) ? 1 : 0;}
   function combine(l){
    if(l && ! l[2]){var x = l[1]; return x;}
    function _e8_(l){
     return caml_call3(Core_List[17], l, -402004920, equal)
             ? -402004920
             : 17724;
    }
    var _e9_ = caml_call1(Async_kernel_Deferred[21], l);
    return caml_call2(Async_kernel_Deferred_std[5][2], _e9_, _e8_);
   }
   function values_read(r){return r[2];}
   function set_values_read(r, v){r[2] = v; return 0;}
   function _c_(r, v){return [0, r[1], v, r[3]];}
   var
    _d_ = [0, set_values_read],
    values_read$0 =
      [0, function(param){return 0;}, cst_values_read, _d_, values_read, _c_];
   function sexp_of_t$0(param){
    var pipe_id_009 = param[1], values_read_011 = param[2], bnds_008 = 0;
    function _e6_(_e7_){return 0;}
    var
     arg_015 = caml_call1(Sexplib0_Sexp_conv[24], _e6_),
     bnds_008$0 = [0, [1, [0, _e_, [0, arg_015, 0]]], bnds_008];
    if(typeof values_read_011 === "number")
     var arg_012 = _f_;
    else
     var
      v_013 = values_read_011[2],
      arg_012 =
        [1,
         [0, _i_, [0, caml_call2(Async_kernel_Ivar[9], Core[620], v_013), 0]]];
    var
     bnds_008$1 = [0, [1, [0, _g_, [0, arg_012, 0]]], bnds_008$0],
     arg_010 = caml_call1(Core[389], pipe_id_009),
     bnds_008$2 = [0, [1, [0, _h_, [0, arg_010, 0]]], bnds_008$1];
    return [1, bnds_008$2];
   }
   function invariant(t){
    try{
     var param = caml_call2(Base_Field[3], values_read$0, t);
     if(typeof param !== "number"){
      var ivar = param[2];
      if(! caml_call1(Async_kernel_Ivar[17], ivar))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     }
     var _e2_ = 0;
     return _e2_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _e3_ = [0, [1, [0, _j_, [0, sexp_of_t$0(t), 0]]], 0],
      _e4_ = [0, [1, [0, _k_, [0, caml_call1(Core[625], exn), 0]]], _e3_],
      _e5_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_Consumer_invariant_fa),
          _e4_]];
     return caml_call1(Core[261], _e5_);
    }
   }
   function start(t){
    return typeof t[2] === "number"
            ? (t
               [2]
              = [0, -122467239, caml_call1(Async_kernel_Ivar[12], 0)],
              0)
            : 0;
   }
   function values_sent_downstream(t){
    var match = t[2];
    if(typeof match === "number") return 0;
    var ivar = match[2];
    caml_call2(Async_kernel_Ivar[14], ivar, 0);
    t[2] = -758792467;
    return 0;
   }
   function values_sent_downstream_and_flu(t){
    var match = t[2];
    if(typeof match === "number") return caml_call1(t[3], 0);
    var when_sent_downstream = match[2];
    function _e0_(param){return caml_call1(t[3], 0);}
    var _e1_ = caml_call1(Async_kernel_Ivar[19], when_sent_downstream);
    return caml_call2(Async_kernel_Deferred_std[5][1], _e1_, _e0_);
   }
   function consumer(r){return r[2];}
   function wants(r){return r[1];}
   function _v_(r, v){return [0, r[1], v];}
   var
    _w_ = 0,
    consumer$0 =
      [0, function(param){return 0;}, cst_consumer, _w_, consumer, _v_];
   function _x_(r, v){return [0, v, r[2]];}
   var
    _y_ = 0,
    wants$0 = [0, function(param){return 0;}, cst_wants, _y_, wants, _x_];
   function sexp_of_t$1(of_a_029, param){
    var
     consumer_033 = param[2],
     wants_031 = param[1],
     arg_034 = caml_call2(Core[515], sexp_of_t$0, consumer_033),
     bnds_030 = [0, [1, [0, _z_, [0, arg_034, 0]]], 0];
    switch(wants_031[0]){
      case 0:
       var
        arg0_018 = wants_031[1],
        _eX_ = function(param){return 3456156 <= param ? _m_ : _n_;},
        res0_019 = caml_call2(Async_kernel_Ivar[9], _eX_, arg0_018),
        arg_032 = [1, [0, _o_, [0, res0_019, 0]]];
       break;
      case 1:
       var
        arg0_021 = wants_031[1],
        _eY_ =
          function(param){
           if(typeof param === "number") return _p_;
           var v_020 = param[2];
           return [1, [0, _q_, [0, caml_call1(of_a_029, v_020), 0]]];
          },
        res0_022 = caml_call2(Async_kernel_Ivar[9], _eY_, arg0_021),
        arg_032 = [1, [0, _r_, [0, res0_022, 0]]];
       break;
      default:
       var
        arg1_025 = wants_031[2],
        arg0_024 = wants_031[1],
        res0_026 = caml_call1(Core[389], arg0_024),
        _eZ_ =
          function(param){
           if(typeof param === "number") return _s_;
           var v_023 = param[2];
           return [1,
                   [0,
                    _t_,
                    [0, caml_call2(Core_Queue[13], of_a_029, v_023), 0]]];
          },
        res1_027 = caml_call2(Async_kernel_Ivar[9], _eZ_, arg1_025),
        arg_032 = [1, [0, _u_, [0, res0_026, [0, res1_027, 0]]]];
    }
    var bnds_030$0 = [0, [1, [0, _A_, [0, arg_032, 0]]], bnds_030];
    return [1, bnds_030$0];
   }
   function fill_with_eof(t){
    var match = t[1];
    switch(match[0]){
      case 0:
       var i = match[1]; return caml_call2(Async_kernel_Ivar[14], i, 3456156);
      case 1:
       var i$0 = match[1];
       return caml_call2(Async_kernel_Ivar[14], i$0, 3456156);
      default:
       var i$1 = match[2];
       return caml_call2(Async_kernel_Ivar[14], i$1, 3456156);
    }
   }
   function fill_when_num_values_read(r){return r[1];}
   function sexp_of_t$2(param){
    var
     ready_039 = param[2],
     fill_when_num_values_read_037 = param[1],
     bnds_036 = 0;
    function _eW_(param){return 17724 <= param ? _F_ : _G_;}
    var
     arg_040 = caml_call2(Async_kernel_Ivar[9], _eW_, ready_039),
     bnds_036$0 = [0, [1, [0, _H_, [0, arg_040, 0]]], bnds_036],
     arg_038 = caml_call1(Core[389], fill_when_num_values_read_037),
     bnds_036$1 = [0, [1, [0, _I_, [0, arg_038, 0]]], bnds_036$0];
    return [1, bnds_036$1];
   }
   function fill(t, v){return caml_call2(Async_kernel_Ivar[14], t[2], v);}
   function consumers(r){return r[12];}
   function set_consumers(r, v){r[12] = v; return 0;}
   function blocked_reads(r){return r[9];}
   function blocked_flushes(r){return r[8];}
   function num_values_read(r){return r[7];}
   function pushback(r){return r[6];}
   function set_pushback(r, v){r[6] = v; return 0;}
   function reserved_space(r){return r[5];}
   function set_reserved_space(r, v){r[5] = v; return 0;}
   function size_budget(r){return r[4];}
   function set_size_budget(r, v){r[4] = v; return 0;}
   function _J_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13]];
   }
   var
    _K_ = [0, set_consumers],
    consumers$0 =
      [0, function(param){return 0;}, cst_consumers, _K_, consumers, _J_];
   function _L_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13]];
   }
   var
    _M_ = 0,
    blocked_reads$0 =
      [0,
       function(param){return 0;},
       cst_blocked_reads,
       _M_,
       blocked_reads,
       _L_];
   function _N_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12],
            r[13]];
   }
   var
    _O_ = 0,
    blocked_flushes$0 =
      [0,
       function(param){return 0;},
       cst_blocked_flushes,
       _O_,
       blocked_flushes,
       _N_];
   function _P_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13]];
   }
   var
    _Q_ = [0, set_pushback],
    pushback$0 =
      [0, function(param){return 0;}, cst_pushback, _Q_, pushback, _P_];
   function _R_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13]];
   }
   var
    _S_ = [0, set_reserved_space],
    reserved_space$0 =
      [0,
       function(param){return 0;},
       cst_reserved_space,
       _S_,
       reserved_space,
       _R_];
   function _T_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13]];
   }
   var
    _U_ = [0, set_size_budget],
    size_budget$0 =
      [0, function(param){return 0;}, cst_size_budget, _U_, size_budget, _T_];
   function sexp_of_pipe(of_a_041, of_phantom_042, param){
    var
     id_044 = param[1],
     info_046 = param[2],
     buffer_050 = param[3],
     size_budget_052 = param[4],
     reserved_space_054 = param[5],
     pushback_056 = param[6],
     num_values_read_058 = param[7],
     read_closed_066 = param[11],
     closed_064 = param[10],
     blocked_reads_062 = param[9],
     blocked_flushes_060 = param[8],
     consumers_068 = param[12],
     upstream_flusheds_070 = param[13],
     bnds_043 = 0;
    function _eR_(param){
     function _eU_(_eV_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _eU_);
    }
    var
     arg_071 = caml_call2(Core_Bag[3], _eR_, upstream_flusheds_070),
     bnds_043$0 = [0, [1, [0, _V_, [0, arg_071, 0]]], bnds_043],
     arg_069 = caml_call2(Core[472], sexp_of_t$0, consumers_068),
     bnds_043$1 = [0, [1, [0, _W_, [0, arg_069, 0]]], bnds_043$0],
     arg_067 = caml_call2(Async_kernel_Ivar[9], Core[620], read_closed_066),
     bnds_043$2 = [0, [1, [0, _X_, [0, arg_067, 0]]], bnds_043$1],
     arg_065 = caml_call2(Async_kernel_Ivar[9], Core[620], closed_064),
     bnds_043$3 = [0, [1, [0, _Y_, [0, arg_065, 0]]], bnds_043$2];
    function _eS_(_eT_){return sexp_of_t$1(of_a_041, _eT_);}
    var
     arg_063 = caml_call2(Core_Queue[13], _eS_, blocked_reads_062),
     bnds_043$4 = [0, [1, [0, _Z_, [0, arg_063, 0]]], bnds_043$3],
     arg_061 = caml_call2(Core_Queue[13], sexp_of_t$2, blocked_flushes_060),
     bnds_043$5 = [0, [1, [0, ___, [0, arg_061, 0]]], bnds_043$4],
     arg_059 = caml_call1(Core[389], num_values_read_058),
     bnds_043$6 = [0, [1, [0, _$_, [0, arg_059, 0]]], bnds_043$5],
     arg_057 = caml_call2(Async_kernel_Ivar[9], Core[620], pushback_056),
     bnds_043$7 = [0, [1, [0, _aa_, [0, arg_057, 0]]], bnds_043$6],
     arg_055 = caml_call1(Core[389], reserved_space_054),
     bnds_043$8 = [0, [1, [0, _ab_, [0, arg_055, 0]]], bnds_043$7],
     arg_053 = caml_call1(Core[389], size_budget_052),
     bnds_043$9 = [0, [1, [0, _ac_, [0, arg_053, 0]]], bnds_043$8],
     arg_051 = caml_call2(Core_Queue[13], of_a_041, buffer_050),
     bnds_043$10 = [0, [1, [0, _ad_, [0, arg_051, 0]]], bnds_043$9];
    if(info_046)
     var
      v_047 = info_046[1],
      arg_049 = caml_call1(Core_Sexp[93], v_047),
      bnd_048 = [1, [0, _ae_, [0, arg_049, 0]]],
      bnds_043$11 = [0, bnd_048, bnds_043$10];
    else
     var bnds_043$11 = bnds_043$10;
    var
     arg_045 = caml_call2(Sexp_hidden_in_test[11], Core[389], id_044),
     bnds_043$12 = [0, [1, [0, _af_, [0, arg_045, 0]]], bnds_043$11];
    return [1, bnds_043$12];
   }
   function effective_size_budget(t){return t[4] - t[5] | 0;}
   function hash(t){return caml_call1(Core_Hashtbl[1], t[1]);}
   function equal$0(t1, t2){return t1 === t2 ? 1 : 0;}
   function compare$0(t1, t2){return caml_call2(Core_Int[88], t1[1], t2[1]);}
   function is_closed(t){return caml_call1(Async_kernel_Ivar[18], t[10]);}
   function is_read_closed(t){
    return caml_call1(Async_kernel_Ivar[18], t[11]);
   }
   function closed(t){return caml_call1(Async_kernel_Ivar[19], t[10]);}
   function pushback$1(t){return caml_call1(Async_kernel_Ivar[19], t[6]);}
   function length(t){return caml_call1(Core_Queue[16], t[3]);}
   function is_empty(t){
    var _eQ_ = length(t);
    return caml_call2(Async_kernel_Import[3], _eQ_, 0);
   }
   function num_values_written(t){
    var _eP_ = t[7];
    return length(t) + _eP_ | 0;
   }
   function update_num_values_read(t, delta){t[7] = t[7] + delta | 0; return;}
   function invariant$0(x_075){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, x_075));
        },
      _eq_ =
        function(l){
         function _eO_(consumer){
          invariant(consumer);
          if(caml_call2(Async_kernel_Import[3], consumer[1], x_075[1]))
           return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ak_], 1);
         }
         return caml_call2(Core_List[19], l, _eO_);
        },
      _er_ =
        function(blocked_reads){
         if
          (1 - is_empty(x_075) && ! caml_call1(Core_Queue[17], blocked_reads))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _an_], 1);
         function _eF_(x_035){
          try{
           var
            check =
              function(f, field){
               return caml_call1(f, caml_call2(Base_Field[3], field, x_035));
              },
            _eM_ =
              function(param){
               if(! param) return 0;
               var consumer = param[1];
               return invariant(consumer);
              };
           check
            (function(param){
              if(2 !== param[0]) return 0;
              var i = param[1];
              if(caml_call2(Async_kernel_Import[4], i, 0)) return 0;
              throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
             },
             wants$0);
           check(_eM_, consumer$0);
          }
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _eH_ = 0,
            _eI_ = 0,
            _eJ_ =
              [0,
               [1,
                [0,
                 _C_,
                 [0, sexp_of_t$1(function(param){return _B_;}, x_035), _eI_]]],
               _eH_],
            _eK_ =
              [0, [1, [0, _D_, [0, caml_call1(Core[625], exn), 0]]], _eJ_],
            _eL_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Pipe_Blocked_read_invarian),
                _eK_]];
           caml_call1(Core[261], _eL_);
          }
          var match = x_035[1];
          switch(match[0]){
            case 0:
             var i = match[1], _eN_ = caml_call1(Async_kernel_Ivar[17], i);
             break;
            case 1:
             var
              i$0 = match[1],
              _eN_ = caml_call1(Async_kernel_Ivar[17], i$0);
             break;
            default:
             var
              i$1 = match[2],
              _eN_ = caml_call1(Async_kernel_Ivar[17], i$1);
          }
          if(_eN_) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _al_], 1);
         }
         caml_call2(Core_Queue[18], blocked_reads, _eF_);
         var _eG_ = is_closed(x_075);
         if(! _eG_) return _eG_;
         if(caml_call1(Core_Queue[17], blocked_reads)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _am_], 1);
        },
      _es_ =
        function(blocked_flushes){
         function _eA_(f){
          if(caml_call2(Async_kernel_Import[4], f[1], x_075[7])) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
         }
         caml_call2(Core_Queue[18], blocked_flushes, _eA_);
         var
          _eB_ = Core_Int[88],
          _eC_ = caml_call1(Core_Queue[28], blocked_flushes),
          _eD_ = caml_call2(Core_List[51], _eC_, fill_when_num_values_read);
         if(! caml_call2(Core_List[147], _eD_, _eB_))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aq_], 1);
         var _eE_ = is_empty(x_075);
         if(! _eE_) return _eE_;
         if(caml_call1(Core_Queue[17], blocked_flushes)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ap_], 1);
        },
      _et_ =
        function(pushback){
         var
          _ev_ = effective_size_budget(x_075),
          _ew_ = length(x_075),
          _ex_ = caml_call2(Async_kernel_Import[2], _ew_, _ev_),
          _ey_ = _ex_ || is_closed(x_075),
          _ez_ = caml_call1(Async_kernel_Ivar[18], pushback);
         if(caml_call2(Core_Bool[32], _ez_, _ey_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ar_], 1);
        },
      _eu_ =
        function(reserved_space){
         if(caml_call2(Async_kernel_Import[1], reserved_space, 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
        };
     check
      (function(size_budget){
        if(caml_call2(Async_kernel_Import[1], size_budget, 0)) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _at_], 1);
       },
       size_budget$0);
     check(_eu_, reserved_space$0);
     check(_et_, pushback$0);
     check(_es_, blocked_flushes$0);
     check(_er_, blocked_reads$0);
     check(_eq_, consumers$0);
     var _ej_ = 0;
     return _ej_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _ek_ = 0,
      _el_ = 0,
      _em_ = function(param){return _ag_;},
      _en_ =
        [0,
         [1,
          [0,
           _ai_,
           [0, sexp_of_pipe(function(param){return _ah_;}, _em_, x_075), _el_]]],
         _ek_],
      _eo_ = [0, [1, [0, _aj_, [0, caml_call1(Core[625], exn), 0]]], _en_],
      _ep_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_invariant_failed),
          _eo_]];
     return caml_call1(Core[261], _ep_);
    }
   }
   function sexp_of_phantom(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _au_], 1);
   }
   function sexp_of_t$3(of_a_076, x_077){
    return sexp_of_pipe(of_a_076, sexp_of_phantom, x_077);
   }
   function sexp_of_phantom$0(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
   }
   function sexp_of_t$4(of_a_078, x_079){
    return sexp_of_pipe(of_a_078, sexp_of_phantom$0, x_079);
   }
   var id_ref = [0, 0];
   function create_internal(size_budget, info, initial_buffer){
    id_ref[1]++;
    var
     _ed_ = caml_call1(Core_Bag[22], 0),
     _ee_ = caml_call1(Async_kernel_Ivar[12], 0),
     _ef_ = caml_call1(Async_kernel_Ivar[12], 0),
     _eg_ = caml_call2(Core_Queue[66], 0, 0),
     _eh_ = caml_call2(Core_Queue[66], 0, 0),
     _ei_ = caml_call1(Async_kernel_Ivar[12], 0),
     t =
       [0,
        id_ref[1],
        info,
        initial_buffer,
        size_budget,
        0,
        _ei_,
        0,
        _eh_,
        _eg_,
        _ef_,
        _ee_,
        0,
        _ed_];
    return t;
   }
   function validate_size_budget(size_budget){
    if(! caml_call2(Async_kernel_Import[5], size_budget, 0))
     return size_budget;
    var
     _eb_ = [0, [1, [0, _aw_, [0, caml_call1(Core[389], size_budget), 0]]], 0],
     _ec_ =
       [1,
        [0, caml_call1(Sexplib0_Sexp_conv[7], cst_negative_size_budget), _eb_]];
    return caml_call1(Core[261], _ec_);
   }
   function create(size_budget, info, param){
    if(size_budget)
     var v = size_budget[1], size_budget$0 = validate_size_budget(v);
    else
     var size_budget$0 = 0;
    var
     t =
       create_internal(size_budget$0, info, caml_call2(Core_Queue[66], 0, 0));
    caml_call2(Async_kernel_Ivar[14], t[6], 0);
    if(check_invariant[1]) invariant$0(t);
    return [0, t, t];
   }
   function update_pushback(t){
    var _d9_ = effective_size_budget(t), _d__ = length(t);
    if(! caml_call2(Async_kernel_Import[2], _d__, _d9_) && ! is_closed(t)){
     var
      _d$_ = caml_call1(Async_kernel_Ivar[18], t[6]),
      _ea_ = _d$_ ? (t[6] = caml_call1(Async_kernel_Ivar[12], 0), 0) : _d$_;
     return _ea_;
    }
    return caml_call2(Async_kernel_Ivar[16], t[6], 0);
   }
   function close(t){
    if(show_debug_messages[1]){
     var
      _d6_ =
        function(x_080){
         function _d8_(param){return _ax_;}
         return sexp_of_pipe(function(param){return _ay_;}, _d8_, x_080);
        };
     caml_call3(Async_kernel_Import[14], cst_close, t, _d6_);
    }
    if(check_invariant[1]) invariant$0(t);
    var _d7_ = 1 - is_closed(t);
    if(! _d7_) return _d7_;
    caml_call2(Async_kernel_Ivar[14], t[10], 0);
    if(is_empty(t)){
     caml_call2(Core_Queue[18], t[9], fill_with_eof);
     caml_call1(Core_Queue[51], t[9]);
    }
    return update_pushback(t);
   }
   function close_read(t){
    if(show_debug_messages[1]){
     var
      _d2_ =
        function(x_081){
         function _d5_(param){return _az_;}
         return sexp_of_pipe(function(param){return _aA_;}, _d5_, x_081);
        };
     caml_call3(Async_kernel_Import[14], cst_close_read, t, _d2_);
    }
    if(check_invariant[1]) invariant$0(t);
    var _d3_ = 1 - is_read_closed(t);
    if(! _d3_) return _d3_;
    caml_call2(Async_kernel_Ivar[14], t[11], 0);
    function _d4_(flush){return fill(flush, -402004920);}
    caml_call2(Core_Queue[18], t[8], _d4_);
    caml_call1(Core_Queue[51], t[8]);
    caml_call1(Core_Queue[51], t[3]);
    t[5] = 0;
    update_pushback(t);
    return close(t);
   }
   function create_reader_not_close_on_exc(size_budget, f){
    var match = create(size_budget, 0, 0), w = match[2], r = match[1];
    function _d0_(param){return close(w);}
    var _d1_ = caml_call1(f, w);
    caml_call2(Async_kernel_Deferred_std[11], _d1_, _d0_);
    return r;
   }
   function create_reader(size_budget, close_on_exception, f){
    if(! close_on_exception)
     return create_reader_not_close_on_exc(size_budget, f);
    var match = create(size_budget, 0, 0), w = match[2], r = match[1];
    function _dX_(param){
     close(w);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    function _dY_(param){return caml_call1(f, w);}
    var
     _dZ_ = caml_call8(Async_kernel_Monitor[23], 0, 0, 0, 0, 0, 0, _dY_, _dX_);
    caml_call1(Async_kernel_Deferred_std[8], _dZ_);
    return r;
   }
   function create_writer(size_budget, f){
    var match = create(size_budget, 0, 0), w = match[2], r = match[1];
    function _dU_(param){
     close_read(r);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    function _dV_(param){return caml_call1(f, r);}
    var
     _dW_ = caml_call8(Async_kernel_Monitor[23], 0, 0, 0, 0, 0, 0, _dV_, _dU_);
    caml_call1(Async_kernel_Deferred_std[8], _dW_);
    return w;
   }
   function consumed_values_sent_downstrea(t){
    return caml_call1(Core_List[18], t[12])
            ? caml_call1(Async_kernel_Deferred_std[10], 17724)
            : combine
              (caml_call2
                (Core_List[51], t[12], values_sent_downstream_and_flu));
   }
   function values_were_read(t, consumer){
    caml_call2(Core_Option[46], consumer, start);
    var
     values_flushed =
       [246, function(_dT_){return consumed_values_sent_downstrea(t);}];
    function _dR_(flush){
     return caml_call2(Async_kernel_Import[1], t[7], flush[1]);
    }
    function _dS_(flush){
     function f(flush_result){return fill(flush, flush_result);}
     var
      d = caml_call1(Core[248], values_flushed),
      match = caml_call1(Async_kernel_Deferred[5], d);
     if(! match) return caml_call2(Async_kernel_Deferred_std[11], d, f);
     var v = match[1];
     return f(v);
    }
    return caml_call3(Core_Queue[48], t[8], _dS_, _dR_);
   }
   function consume_one(t, consumer){
    var _dQ_ = length(t);
    if(! caml_call2(Async_kernel_Import[1], _dQ_, 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aB_], 1);
    var result = caml_call1(Core_Queue[46], t[3]);
    update_num_values_read(t, 1);
    values_were_read(t, consumer);
    update_pushback(t);
    return result;
   }
   function consume(t, max_queue_length, consumer){
    if(! caml_call2(Async_kernel_Import[1], max_queue_length, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aC_], 1);
    var _dP_ = length(t);
    if(caml_call2(Async_kernel_Import[1], max_queue_length, _dP_)){
     var result = t[3];
     t[3] = caml_call2(Core_Queue[66], 0, 0);
     update_num_values_read(t, caml_call1(Core_Queue[16], result));
     values_were_read(t, consumer);
     update_pushback(t);
     return result;
    }
    update_num_values_read(t, max_queue_length);
    values_were_read(t, consumer);
    var result$0 = caml_call2(Core_Queue[66], [0, max_queue_length], 0);
    caml_call4(Core_Queue[74], t[3], result$0, [0, max_queue_length], 0);
    update_pushback(t);
    return result$0;
   }
   function set_size_budget$0(t, size_budget){
    var size_budget$0 = validate_size_budget(size_budget);
    t[4] = size_budget$0;
    return update_pushback(t);
   }
   function reserve_space(t, n){
    if(caml_call2(Async_kernel_Import[5], n, 0)){
     var
      _dK_ = [0, [1, [0, _aD_, [0, caml_call1(Core[389], n), 0]]], 0],
      _dL_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_reserving_negative_space),
          _dK_]];
     caml_call1(Core[261], _dL_);
    }
    var reserved_space = t[5] + n | 0;
    if(caml_call2(Async_kernel_Import[5], reserved_space, 0)){
     var
      _dM_ = [0, [1, [0, _aE_, [0, caml_call1(Core[389], n), 0]]], 0],
      _dN_ = [0, [1, [0, _aF_, [0, caml_call1(Core[389], t[5]), 0]]], _dM_],
      _dO_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_overflow_when_reserving_sp),
          _dN_]];
     caml_call1(Core[261], _dO_);
    }
    t[5] = reserved_space;
    return update_pushback(t);
   }
   function decrease_reserved_space(t, n){
    t[5] = caml_call2(Core_Int[90], 0, t[5] - n | 0);
    return;
   }
   function start_write(x_083, size){
    if(show_debug_messages[1]){
     var
      _dD_ =
        function(x_082){
         function _dJ_(param){return _aG_;}
         return sexp_of_pipe(function(param){return _aH_;}, _dJ_, x_082);
        };
     caml_call3(Async_kernel_Import[14], cst_write, x_083, _dD_);
    }
    if(check_invariant[1]) invariant$0(x_083);
    if(is_closed(x_083)){
     var
      _dE_ = 0,
      _dF_ = 0,
      _dG_ = function(param){return _aI_;},
      _dH_ =
        [0,
         [1,
          [0,
           _aK_,
           [0, sexp_of_pipe(function(param){return _aJ_;}, _dG_, x_083), _dF_]]],
         _dE_],
      _dI_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_write_to_closed_pipe),
          _dH_]];
     caml_call1(Core[261], _dI_);
    }
    return decrease_reserved_space(x_083, size);
   }
   function finish_write(t){
    for(;;){
     if(! caml_call1(Core_Queue[17], t[9]) && ! is_empty(t)){
      var
       blocked_read = caml_call1(Core_Queue[46], t[9]),
       consumer = blocked_read[2],
       match = blocked_read[1];
      switch(match[0]){
        case 0:
         var ivar = match[1];
         caml_call2(Async_kernel_Ivar[14], ivar, 17724);
         break;
        case 1:
         var ivar$0 = match[1], _dB_ = [0, 17724, consume_one(t, consumer)];
         caml_call2(Async_kernel_Ivar[14], ivar$0, _dB_);
         break;
        default:
         var
          ivar$1 = match[2],
          max_queue_length = match[1],
          _dC_ = [0, 17724, consume(t, max_queue_length, consumer)];
         caml_call2(Async_kernel_Ivar[14], ivar$1, _dC_);
      }
      continue;
     }
     return update_pushback(t);
    }
   }
   function transfer_in_without_pushback(t, from){
    start_write(t, caml_call1(Core_Queue[16], from));
    caml_call4(Core_Queue[74], from, t[3], 0, 0);
    return finish_write(t);
   }
   function transfer_in(t, from){
    transfer_in_without_pushback(t, from);
    return pushback$1(t);
   }
   function write(t, q){return transfer_in(t, q);}
   function write_without_pushback(t, value){
    start_write(t, 1);
    caml_call2(Core_Queue[43], t[3], value);
    return finish_write(t);
   }
   function write$0(t, value){
    write_without_pushback(t, value);
    return pushback$1(t);
   }
   function write_when_ready(t, f){
    function _dz_(param){
     return is_closed(t)
             ? -1025106484
             : [0,
               17724,
               caml_call1
                (f, function(x){return write_without_pushback(t, x);})];
    }
    var _dA_ = pushback$1(t);
    return caml_call2(Async_kernel_Deferred_std[5][2], _dA_, _dz_);
   }
   function write_if_open(t, x){
    return is_closed(t)
            ? caml_call1(Async_kernel_Deferred_std[10], 0)
            : write$0(t, x);
   }
   function write_without_pushback_if_open(t, x){
    var _dy_ = 1 - is_closed(t);
    return _dy_ ? write_without_pushback(t, x) : _dy_;
   }
   function ensure_consumer_matches(consumer, x_085){
    if(! consumer) return;
    var
     consumer$0 = consumer[1],
     _ds_ = caml_call2(Async_kernel_Import[6], x_085[1], consumer$0[1]);
    if(! _ds_) return _ds_;
    var
     _dt_ = 0,
     _du_ = 0,
     _dv_ =
       [0,
        [1,
         [0,
          _aM_,
          [0, sexp_of_t$3(function(param){return _aL_;}, x_085), _du_]]],
        _dt_],
     _dw_ = [0, [1, [0, _aN_, [0, sexp_of_t$0(consumer$0), 0]]], _dv_],
     _dx_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Attempt_to_use_consumer_wi),
         _dw_]];
    return caml_call1(Core[261], _dx_);
   }
   function start_read(consumer, t, label){
    if(show_debug_messages[1]){
     var
      _dq_ =
        function(x_086){
         function _dr_(param){return _aO_;}
         return sexp_of_pipe(function(param){return _aP_;}, _dr_, x_086);
        };
     caml_call3(Async_kernel_Import[14], label, t, _dq_);
    }
    if(check_invariant[1]) invariant$0(t);
    return ensure_consumer_matches(consumer, t);
   }
   function gen_read_now(consumer, t, consume){
    start_read(consumer, t, cst_read_now);
    if(is_empty(t)) return is_closed(t) ? 3456156 : -445537353;
    if(caml_call1(Core_Queue[17], t[9]))
     return [0, 17724, caml_call2(consume, t, consumer)];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
   }
   function get_max_queue_length(max_queue_length){
    if(! max_queue_length) return Core_Int[45];
    var max_queue_length$0 = max_queue_length[1];
    if(caml_call2(Async_kernel_Import[2], max_queue_length$0, 0)){
     var
      _do_ =
        [0,
         [1, [0, _aR_, [0, caml_call1(Core[389], max_queue_length$0), 0]]],
         0],
      _dp_ =
        [1,
         [0, caml_call1(Sexplib0_Sexp_conv[7], cst_max_queue_length_0), _do_]];
     caml_call1(Core[261], _dp_);
    }
    return max_queue_length$0;
   }
   function read_now(consumer, max_queue_length, t){
    var max_queue_length$0 = get_max_queue_length(max_queue_length);
    return gen_read_now
            (consumer,
             t,
             function(t, consumer){
              return consume(t, max_queue_length$0, consumer);
             });
   }
   function read_now$0(consumer, t){
    return gen_read_now(consumer, t, consume_one);
   }
   function read_now_exn(consumer, t){
    var match = read_now$0(consumer, t);
    if(typeof match !== "number"){var a = match[2]; return a;}
    if(3456156 <= match){
     var
      _dm_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_now_exn_received);
     return caml_call1(Core[261], _dm_);
    }
    var
     _dn_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_now_exn_nothing_);
    return caml_call1(Core[261], _dn_);
   }
   function peek(t){return caml_call1(Core_Queue[49], t[3]);}
   function clear(t){read_now(0, 0, t); return 0;}
   function read(consumer, max_queue_length, t){
    var max_queue_length$0 = get_max_queue_length(max_queue_length);
    start_read(consumer, t, cst_read);
    var r = read_now(consumer, [0, max_queue_length$0], t);
    if(typeof r === "number" && 3456156 > r){
     var
      _dl_ =
        function(ivar){
         return caml_call2
                 (Core_Queue[43],
                  t[9],
                  [0, [2, max_queue_length$0, ivar], consumer]);
        };
     return caml_call1(Async_kernel_Deferred[3], _dl_);
    }
    return caml_call1(Async_kernel_Deferred_std[10], r);
   }
   function read$0(consumer, t){
    start_read(consumer, t, cst_read$0);
    if(is_empty(t)){
     if(is_closed(t))
      return caml_call1(Async_kernel_Deferred_std[10], 3456156);
     var
      _dj_ =
        function(ivar){
         return caml_call2(Core_Queue[43], t[9], [0, [1, ivar], consumer]);
        };
     return caml_call1(Async_kernel_Deferred[3], _dj_);
    }
    if(! caml_call1(Core_Queue[17], t[9]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
    var _dk_ = [0, 17724, consume_one(t, consumer)];
    return caml_call1(Async_kernel_Deferred_std[10], _dk_);
   }
   function read_exn(consumer, t){
    function _dg_(param){
     if(typeof param === "number"){
      var
       _di_ =
         caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_exn_received_EOF);
      return caml_call1(Core[261], _di_);
     }
     var value = param[2];
     return value;
    }
    var _dh_ = read$0(consumer, t);
    return caml_call2(Async_kernel_Deferred_std[5][2], _dh_, _dg_);
   }
   function values_available(t){
    start_read(0, t, cst_values_available);
    if(! is_empty(t)) return caml_call1(Async_kernel_Deferred_std[10], 17724);
    if(is_closed(t))
     return caml_call1(Async_kernel_Deferred_std[10], 3456156);
    var match = caml_call1(Core_Queue[67], t[9]);
    if(match){
     var _dd_ = match[1], _de_ = _dd_[1];
     if(0 === _de_[0] && ! _dd_[2]){
      var ivar = _de_[1];
      return caml_call1(Async_kernel_Ivar[19], ivar);
     }
    }
    function _df_(ivar){
     return caml_call2(Core_Queue[43], t[9], [0, [0, ivar], 0]);
    }
    return caml_call1(Async_kernel_Deferred[3], _df_);
   }
   function read_choice(t){
    function _db_(param){return read_now$0(0, t);}
    var _dc_ = values_available(t);
    return caml_call2(Async_kernel_Deferred_std[6], _dc_, _db_);
   }
   function read_choice_single_consumer_ex(t, here){
    function _c9_(x){
     if(typeof x === "number" && 3456156 > x){
      var
       _c$_ =
         [0,
          [1,
           [0, _aT_, [0, caml_call1(Core_Source_code_position[1], here), 0]]],
          0],
       _da_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_choice_single_co),
           _c$_]];
      return caml_call1(Core[261], _da_);
     }
     return x;
    }
    var _c__ = read_choice(t);
    return caml_call2(Async_kernel_Deferred[26][1], _c__, _c9_);
   }
   function read_exactly(consumer, t, num_values){
    start_read(consumer, t, cst_read_exactly);
    if(caml_call2(Async_kernel_Import[2], num_values, 0)){
     var
      _c3_ = [0, [1, [0, _aU_, [0, caml_call1(Core[389], num_values), 0]]], 0],
      _c4_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_exactly_got_num_),
          _c3_]];
     caml_call1(Core[261], _c4_);
    }
    function _c5_(finish){
     var result = caml_call2(Core_Queue[66], 0, 0);
     function loop(param){
      var already_read = caml_call1(Core_Queue[16], result);
      if(! caml_call2(Async_kernel_Import[2], already_read, num_values))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _aV_], 1);
      if(caml_call2(Async_kernel_Import[3], already_read, num_values))
       return caml_call2
               (Async_kernel_Ivar[14], finish, [0, -876407060, result]);
      function _c6_(param){
       if(typeof param === "number"){
        var
         _c8_ =
           caml_call2(Async_kernel_Import[3], already_read, 0)
            ? 3456156
            : [0, 287952037, result];
        return caml_call2(Async_kernel_Ivar[14], finish, _c8_);
       }
       var q = param[2];
       caml_call4(Core_Queue[74], q, result, 0, 0);
       return loop(0);
      }
      var _c7_ = read(consumer, [0, num_values - already_read | 0], t);
      return caml_call2(Async_kernel_Deferred_std[1], _c7_, _c6_);
     }
     return loop(0);
    }
    return caml_call1(Async_kernel_Deferred[3], _c5_);
   }
   function downstream_flushed(t){
    if(is_empty(t)) return consumed_values_sent_downstrea(t);
    function _c1_(ready){
     var _c2_ = length(t);
     return caml_call2(Core_Queue[43], t[8], [0, t[7] + _c2_ | 0, ready]);
    }
    return caml_call1(Async_kernel_Deferred[3], _c1_);
   }
   function upstream_flushed(t){
    if(caml_call1(Core_Bag[6], t[13])) return downstream_flushed(t);
    function _cZ_(f){return caml_call1(f, 0);}
    var _c0_ = caml_call1(Core_Bag[17], t[13]);
    return combine(caml_call2(Core_List[51], _c0_, _cZ_));
   }
   function add_consumer(t, downstream_flushed){
    var
     pipe_id = t[1],
     consumer = [0, pipe_id, -758792467, downstream_flushed];
    t[12] = [0, consumer, t[12]];
    return consumer;
   }
   function consumer$1(param){var t = param[1]; return t[2];}
   function create$0(upstream, downstream){
    function upstream_flushed$0(param){return upstream_flushed(upstream);}
    var _cY_ = caml_call2(Core_Bag[23], downstream[13], upstream_flushed$0);
    return [0,
            [0,
             downstream,
             add_consumer
              (upstream,
               function(param){return downstream_flushed(downstream);}),
             _cY_]];
   }
   function sexp_of_t$5(param){
    if(typeof param === "number") return param ? _aW_ : _aX_;
    var arg0_087 = param[1], res0_088 = sexp_of_t$0(arg0_087);
    return [1, [0, _aY_, [0, res0_088, 0]]];
   }
   var Flushed = [0, sexp_of_t$5];
   function fold_gen(read_now, opt, t, init, f){
    if(opt) var sth = opt[1], flushed = sth; else var flushed = 1;
    if(typeof flushed === "number")
     var
      consumer =
        flushed
         ? 0
         : [0,
           add_consumer
            (t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 17724);
             })];
    else
     var consumer$0 = flushed[1], consumer = [0, consumer$0];
    if(check_invariant[1]) invariant$0(t);
    ensure_consumer_matches(consumer, t);
    function _cT_(finished){
     function _cU_(param){
      function loop(b){
       var match = caml_call2(read_now, consumer, t);
       if(typeof match !== "number"){
        var v = match[2];
        return caml_call3(f, b, v, continue$0);
       }
       if(3456156 <= match)
        return caml_call2(Async_kernel_Ivar[14], finished, b);
       function _cW_(param){return loop(b);}
       var _cX_ = values_available(t);
       return caml_call2(Async_kernel_Deferred_std[1], _cX_, _cW_);
      }
      function continue$0(b){
       caml_call2(Core_Option[46], consumer, values_sent_downstream);
       return loop(b);
      }
      return loop(init);
     }
     var _cV_ = values_available(t);
     return caml_call2(Async_kernel_Deferred_std[1], _cV_, _cU_);
    }
    return caml_call1(Async_kernel_Deferred[3], _cT_);
   }
   function fold(flushed, max_queue_length, t, init, f){
    function _cP_(b, q, loop){
     var _cS_ = caml_call2(f, b, q);
     return caml_call2(Async_kernel_Deferred_std[1], _cS_, loop);
    }
    return fold_gen
            (function(_cQ_){
              return function(_cR_){
               return read_now(_cQ_, max_queue_length, _cR_);};
             },
             flushed,
             t,
             init,
             _cP_);
   }
   function fold$0(flushed, t, init, f){
    return fold_gen
            (read_now$0,
             flushed,
             t,
             init,
             function(b, a, loop){
              var _cO_ = caml_call2(f, b, a);
              return caml_call2(Async_kernel_Deferred_std[1], _cO_, loop);
             });
   }
   function fold_without_pushback(consumer, t, init, f){
    function _cM_(b, a, loop){return caml_call1(loop, caml_call2(f, b, a));}
    if(consumer) var c = consumer[1], _cN_ = [0, [0, c]]; else var _cN_ = 0;
    return fold_gen(read_now$0, _cN_, t, init, _cM_);
   }
   function with_error_to_current_monitor(opt, f, a){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    if(! continue_on_error) return caml_call1(f, a);
    function _cH_(param){
     if(0 === param[0]) return 0;
     var
      exn = param[1],
      _cK_ = caml_call1(Async_kernel_Monitor[13], exn),
      _cL_ = caml_call1(Async_kernel_Monitor[5], 0);
     return caml_call3(Async_kernel_Monitor[15], _cL_, 0, _cK_);
    }
    function _cI_(param){return caml_call1(f, a);}
    var
     _cJ_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _a0_, _aZ_, _cI_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _cJ_, _cH_);
   }
   function iter(continue_on_error, flushed, max_queue_length, t, f){
    return fold
            (flushed,
             max_queue_length,
             t,
             0,
             function(param, q){
              return with_error_to_current_monitor(continue_on_error, f, q);
             });
   }
   function iter$0(continue_on_error, flushed, t, f){
    return fold_gen
            (read_now$0,
             flushed,
             t,
             0,
             function(param, a, loop){
              function _cF_(param){return caml_call1(loop, 0);}
              var
               _cG_ = with_error_to_current_monitor(continue_on_error, f, a);
              return caml_call2(Async_kernel_Deferred_std[1], _cG_, _cF_);
             });
   }
   function iter_without_pushback(consumer, opt, max_iterations_per_job, t, f){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    ensure_consumer_matches(consumer, t);
    if(max_iterations_per_job){
     var max_iterations_per_job$0 = max_iterations_per_job[1];
     if(caml_call2(Async_kernel_Import[2], max_iterations_per_job$0, 0)){
      var
       _cv_ =
         [0,
          [1,
           [0, _a1_, [0, caml_call1(Core[389], max_iterations_per_job$0), 0]]],
          0],
       _cw_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_iter_without_pushback_got_),
           _cv_]];
      caml_call1(Core[261], _cw_);
     }
     var max_iterations_per_job$1 = max_iterations_per_job$0;
    }
    else
     var max_iterations_per_job$1 = Core_Int[45];
    var
     f$0 =
       continue_on_error
        ? function
         (a){
          try{caml_call1(f, a); return;}
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _cE_ = caml_call1(Async_kernel_Monitor[5], 0);
           return caml_call3(Async_kernel_Monitor[15], _cE_, 0, exn);
          }
         }
        : f;
    function _cx_(finished){
     function _cy_(param){
      function start(param){
       var remaining = max_iterations_per_job$1;
       for(;;){
        if(caml_call2(Async_kernel_Import[3], remaining, 0)){
         var
          _cA_ = function(param){return start(0);},
          _cB_ = caml_call1(Async_kernel_Deferred_std[10], 0);
         return caml_call2(Async_kernel_Deferred_std[1], _cB_, _cA_);
        }
        var match = read_now$0(consumer, t);
        if(typeof match === "number"){
         if(3456156 <= match)
          return caml_call2(Async_kernel_Ivar[14], finished, 0);
         var
          _cC_ = function(param){return start(0);},
          _cD_ = values_available(t);
         return caml_call2(Async_kernel_Deferred_std[1], _cD_, _cC_);
        }
        var a = match[2];
        caml_call1(f$0, a);
        var remaining$0 = remaining - 1 | 0, remaining = remaining$0;
       }
      }
      return start(0);
     }
     var _cz_ = values_available(t);
     return caml_call2(Async_kernel_Deferred_std[1], _cz_, _cy_);
    }
    return caml_call1(Async_kernel_Deferred[3], _cx_);
   }
   function drain(t){
    return iter
            (0,
             0,
             0,
             t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function drain_and_count(t){
    return fold
            (0,
             0,
             t,
             0,
             function(sum, q){
              var _cu_ = sum + caml_call1(Core_Queue[16], q) | 0;
              return caml_call1(Async_kernel_Deferred_std[10], _cu_);
             });
   }
   function read_all(input){
    var result = caml_call2(Core_Queue[66], 0, 0);
    function _cs_(param){return result;}
    var
     _ct_ =
       iter
        (0,
         0,
         0,
         input,
         function(q){
          caml_call4(Core_Queue[74], q, result, 0, 0);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _ct_, _cs_);
   }
   function to_list(r){
    var _cq_ = Core_Queue[28], _cr_ = read_all(r);
    return caml_call2(Async_kernel_Deferred_std[4], _cr_, _cq_);
   }
   function to_stream_deprecated(t){
    function _cn_(tail){
     function _co_(param){return caml_call1(Async_kernel_Tail[4], tail);}
     var
      _cp_ =
        iter_without_pushback
         (0,
          0,
          0,
          t,
          function(x){return caml_call2(Async_kernel_Tail[3], tail, x);});
     return caml_call2(Async_kernel_Deferred_std[1], _cp_, _co_);
    }
    return caml_call1(Async_kernel_Async_stream[2], _cn_);
   }
   function of_stream_deprecated(s){
    var
     match = create(0, 0, 0),
     w = match[2],
     r = match[1],
     q = caml_call2(Core_Queue[66], 0, 0);
    function transfer(param){
     var _cl_ = 1 - caml_call1(Core_Queue[17], q);
     if(! _cl_) return _cl_;
     var _cm_ = write(w, q);
     return caml_call1(Async_kernel_Deferred_std[8], _cm_);
    }
    function loop$0(counter, s){
     if(is_closed(w))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a2_], 1);
     var
      next_deferred = caml_call1(Async_kernel_Async_stream[3], s),
      match = caml_call1(Async_kernel_Deferred[5], next_deferred);
     if(! match){
      transfer(0);
      return caml_call2
              (Async_kernel_Deferred_std[11],
               next_deferred,
               check_closed_loop_next);
     }
     var next = match[1];
     if(counter >= 50) return caml_trampoline_return(loop_next$0, [0, next]);
     var counter$0 = counter + 1 | 0;
     return loop_next$0(counter$0, next);
    }
    function loop_next$0(counter, param){
     if(! param){transfer(0); return close(w);}
     var s = param[2], x = param[1];
     caml_call2(Core_Queue[43], q, x);
     if(counter >= 50) return caml_trampoline_return(loop$0, [0, s]);
     var counter$0 = counter + 1 | 0;
     return loop$0(counter$0, s);
    }
    function loop(s){return caml_trampoline(loop$0(0, s));}
    function loop_next(param){return caml_trampoline(loop_next$0(0, param));}
    function check_closed_loop_next(next){
     var _ck_ = 1 - is_closed(w);
     return _ck_ ? loop_next(next) : _ck_;
    }
    loop(s);
    return r;
   }
   function transfer_gen(read_now, write, input, output, f){
    if(check_invariant[1]){invariant$0(input); invariant$0(output);}
    var link = create$0(input, output), consumer = consumer$1(link);
    function unlink(param){
     var t = link[1];
     return caml_call2(Core_Bag[26], t[1][13], t[3]);
    }
    function _b7_(result){
     function input_available_or_output_clos(param){
      var _cb_ = 0;
      function _cc_(_cj_){return 0;}
      var
       _cd_ = closed(output),
       _ce_ = [0, caml_call2(Async_kernel_Deferred_std[6], _cd_, _cc_), _cb_];
      function _cf_(_ci_){return 0;}
      var
       _cg_ = values_available(input),
       _ch_ = [0, caml_call2(Async_kernel_Deferred_std[6], _cg_, _cf_), _ce_];
      return caml_call1(Async_kernel_Deferred_std[7], _ch_);
     }
     function _b8_(param){
      function output_closed(param){
       close_read(input);
       unlink(0);
       return caml_call2(Async_kernel_Ivar[14], result, 0);
      }
      function loop(param){
       if(is_closed(output)) return output_closed(0);
       var match = caml_call2(read_now, [0, consumer], input);
       if(typeof match !== "number"){
        var x = match[2];
        return caml_call2(f, x, continue$0);
       }
       if(3456156 <= match){
        unlink(0);
        return caml_call2(Async_kernel_Ivar[14], result, 0);
       }
       function _b$_(param){return loop(0);}
       var _ca_ = input_available_or_output_clos(0);
       return caml_call2(Async_kernel_Deferred_std[1], _ca_, _b$_);
      }
      function continue$0(y){
       if(is_closed(output)) return output_closed(0);
       var pushback = caml_call2(write, output, y);
       values_sent_downstream(consumer);
       function _b__(param){return loop(0);}
       return caml_call2(Async_kernel_Deferred_std[1], pushback, _b__);
      }
      return loop(0);
     }
     var _b9_ = input_available_or_output_clos(0);
     return caml_call2(Async_kernel_Deferred_std[1], _b9_, _b8_);
    }
    return caml_call1(Async_kernel_Deferred[3], _b7_);
   }
   function transfer(max_queue_length, input, output, f){
    function _b3_(q, k){
     var _b6_ = caml_call1(f, q);
     return caml_call2(Async_kernel_Deferred_std[1], _b6_, k);
    }
    return transfer_gen
            (function(_b4_){
              return function(_b5_){
               return read_now(_b4_, max_queue_length, _b5_);};
             },
             write,
             input,
             output,
             _b3_);
   }
   function transfer$0(input, output, f){
    return transfer_gen
            (read_now$0,
             write$0,
             input,
             output,
             function(a, k){return caml_call1(k, caml_call1(f, a));});
   }
   function transfer_id(max_queue_length, input, output){
    function _b0_(q, k){return caml_call1(k, q);}
    return transfer_gen
            (function(_b1_){
              return function(_b2_){
               return read_now(_b1_, max_queue_length, _b2_);};
             },
             write,
             input,
             output,
             _b0_);
   }
   function map_gen(read, write, input, f){
    function _bX_(info){
     return [1, [0, _a3_, [0, caml_call1(Core_Sexp[93], info), 0]]];
    }
    var
     info = caml_call2(Core_Option[34], input[2], _bX_),
     match = create(0, info, 0),
     output = match[2],
     result = match[1];
    function _bY_(param){return close(output);}
    var _bZ_ = transfer_gen(read, write, input, output, f);
    caml_call2(Async_kernel_Deferred_std[11], _bZ_, _bY_);
    return result;
   }
   function map(max_queue_length, input, f){
    function _bT_(q, k){
     var _bW_ = caml_call1(f, q);
     return caml_call2(Async_kernel_Deferred_std[1], _bW_, k);
    }
    return map_gen
            (function(_bU_){
              return function(_bV_){
               return read_now(_bU_, max_queue_length, _bV_);};
             },
             write,
             input,
             _bT_);
   }
   function map$0(input, f){
    return map_gen
            (read_now$0,
             write$0,
             input,
             function(a, k){return caml_call1(k, caml_call1(f, a));});
   }
   function concat_map_list(max_queue_length, input, f){
    function _bQ_(q, k){
     return caml_call1(k, caml_call2(Core_Queue[55], q, f));
    }
    return map_gen
            (function(_bR_){
              return function(_bS_){
               return read_now(_bR_, max_queue_length, _bS_);};
             },
             write,
             input,
             _bQ_);
   }
   function filter_map(max_queue_length, input, f){
    return map
            (max_queue_length,
             input,
             function(q){
              return caml_call3
                      (Async_kernel_Deferred_queue[20], -686623969, q, f);
             });
   }
   function filter_map$0(max_queue_length, input, f){
    function _bM_(q, k){
     function _bP_(x){return is_read_closed(input) ? 0 : caml_call1(f, x);}
     return caml_call1(k, caml_call2(Core_Queue[57], q, _bP_));
    }
    return map_gen
            (function(_bN_){
              return function(_bO_){
               return read_now(_bN_, max_queue_length, _bO_);};
             },
             write,
             input,
             _bM_);
   }
   function folding_filter_map(max_queue_length, input, init, f){
    var accum = [0, init];
    return filter_map
            (max_queue_length,
             input,
             function(x){
              function _bK_(param){
               var x = param[2], a = param[1];
               accum[1] = a;
               return x;
              }
              var _bL_ = caml_call2(f, accum[1], x);
              return caml_call2(Async_kernel_Deferred_std[5][2], _bL_, _bK_);
             });
   }
   function folding_filter_map$0(max_queue_length, input, init, f){
    var accum = [0, init];
    return filter_map$0
            (max_queue_length,
             input,
             function(x){
              var
               match = caml_call2(f, accum[1], x),
               x$0 = match[2],
               a = match[1];
              accum[1] = a;
              return x$0;
             });
   }
   function folding_map(max_queue_length, input, init, f){
    return folding_filter_map$0
            (max_queue_length,
             input,
             init,
             function(accum, a){
              var
               match = caml_call2(f, accum, a),
               b = match[2],
               accum$0 = match[1];
              return [0, accum$0, [0, b]];
             });
   }
   function filter(input, f){
    return filter_map$0
            (0, input, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function of_queue_internal(queue){
    var t = create_internal(0, 0, queue);
    caml_call2(Async_kernel_Ivar[14], t[10], 0);
    update_pushback(t);
    return t;
   }
   function of_queue(queue){
    return of_queue_internal(caml_call1(Core_Queue[52], queue));
   }
   function of_list(l){
    return of_queue_internal(caml_call1(Core_Queue[40], l));
   }
   function empty(param){return of_list(0);}
   function singleton(x){
    var match = create(0, 0, 0), writer = match[2], reader = match[1];
    write_without_pushback(writer, x);
    close(writer);
    return reader;
   }
   function unfold(s, f){
    function symbol(d, f){
     var match = caml_call1(Async_kernel_Deferred[5], d);
     if(! match) return caml_call2(Async_kernel_Deferred_std[3], d, f);
     var x = match[1];
     return caml_call1(f, x);
    }
    return create_reader
            (0,
             0,
             function(writer){
              function loop(s){
               function _bI_(param){
                if(! param)
                 return caml_call1(Async_kernel_Deferred_std[10], 0);
                var match = param[1], s = match[2], a = match[1];
                if(is_closed(writer))
                 return caml_call1(Async_kernel_Deferred_std[10], 0);
                function _bJ_(param){return loop(s);}
                return symbol(write$0(writer, a), _bJ_);
               }
               return symbol(caml_call1(f, s), _bI_);
              }
              return loop(s);
             });
   }
   function of_sequence(sequence){
    return create_reader
            (0,
             0,
             function(writer){
              function loop(sequence$1){
               if
                (!
                 is_closed(writer)
                 && ! caml_call1(Core_Sequence[19], sequence$1)){
                start_write(writer, 0);
                var
                 _bF_ = length(writer),
                 i$1 = (1 + writer[4] | 0) - _bF_ | 0,
                 sequence = sequence$1,
                 i = i$1;
                for(;;){
                 if(! caml_call2(Async_kernel_Import[2], i, 0)){
                  var match = caml_call1(Core_Sequence[50], sequence);
                  if(match){
                   var
                    match$0 = match[1],
                    sequence$0 = match$0[2],
                    a = match$0[1];
                   decrease_reserved_space(writer, 1);
                   caml_call2(Core_Queue[43], writer[3], a);
                   var i$0 = i - 1 | 0, sequence = sequence$0, i = i$0;
                   continue;
                  }
                 }
                 finish_write(writer);
                 var
                  _bG_ = function(param){return loop(sequence);},
                  _bH_ = pushback$1(writer);
                 return caml_call2
                         (Async_kernel_Deferred_std[5][1], _bH_, _bG_);
                }
               }
               return caml_call1(Async_kernel_Deferred_std[10], 0);
              }
              return loop(sequence);
             });
   }
   function to_sequence(t){
    function _bE_(param){
     var match = read_now$0(0, t);
     if(typeof match === "number")
      return 3456156 <= match ? 0 : [0, [0, [1, values_available(t)], 0]];
     var a = match[2];
     return [0, [0, [0, a], 0]];
    }
    return caml_call2(Core_Sequence[52], 0, _bE_);
   }
   function interleave_pipe(opt, inputs){
    if(opt) var sth = opt[1], close_on = sth; else var close_on = -1005265340;
    var
     match =
       create
        (0, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_interleave)], 0),
     output_writer = match[2],
     output = match[1],
     num_pipes_remaining = [0, 1];
    function close_one_pipe(closed_pipe_kind){
     num_pipes_remaining[1] += -1;
     a:
     {
      if(-984089324 <= close_on && -500766471 > closed_pipe_kind){var should_close = 1; break a;}
      var
       should_close =
         caml_call2(Async_kernel_Import[3], num_pipes_remaining[1], 0);
     }
     return should_close ? close(output_writer) : should_close;
    }
    function _by_(param){return close_one_pipe(-500766471);}
    var
     _bz_ =
       iter_without_pushback
        (0,
         0,
         0,
         inputs,
         function(input){
          num_pipes_remaining[1]++;
          function _bB_(param){return close_one_pipe(-551064605);}
          var
           _bC_ = transfer_id(0, input, output_writer),
           _bD_ = caml_call2(Async_kernel_Deferred_std[5][2], _bC_, _bB_);
          return caml_call1(Async_kernel_Deferred_std[8], _bD_);
         }),
     _bA_ = caml_call2(Async_kernel_Deferred_std[5][2], _bz_, _by_);
    caml_call1(Async_kernel_Deferred_std[8], _bA_);
    return output;
   }
   function interleave(close_on, inputs){
    if(check_invariant[1]) caml_call2(Core_List[19], inputs, invariant$0);
    return interleave_pipe(close_on, of_list(inputs));
   }
   function merge(inputs, compare){
    if(! inputs) return empty(0);
    if(inputs[2]){
     var
      match = create(0, 0, 0),
      w = match[2],
      r = match[1],
      _bi_ =
        function(param){return caml_call2(Core_List[19], inputs, close_read);},
      _bj_ = closed(w);
     caml_call2(Async_kernel_Deferred_std[11], _bj_, _bi_);
     var
      _bk_ = 0,
      _bl_ =
        function(param, _bx_){
         var a2 = _bx_[1], a1 = param[1];
         return caml_call2(compare, a1, a2);
        },
      heap = caml_call3(Pairing_heap[20], 0, _bl_, _bk_),
      handle_read =
        function(input, eof_or_ok){
         if(typeof eof_or_ok === "number") return 0;
         var v = eof_or_ok[2];
         return caml_call2(Pairing_heap[25], heap, [0, v, input]);
        },
      pop_heap_and_loop =
        function(param){
         for(;;){
          var match = caml_call1(Pairing_heap[28], heap);
          if(! match) return close(w);
          var
           match$0 = match[1],
           input = match$0[2],
           v = match$0[1],
           _bp_ = 1 - is_closed(w);
          if(! _bp_) return _bp_;
          write_without_pushback(w, v);
          var _bq_ = caml_call1(Pairing_heap[3], heap);
          if(caml_call2(Async_kernel_Import[3], _bq_, 0)){
           var
            _br_ = function(param){return close(w);},
            _bs_ = transfer_id(0, input, w);
           return caml_call2(Async_kernel_Deferred_std[11], _bs_, _br_);
          }
          var x = read_now$0(0, input);
          if(typeof x === "number" && 3456156 > x){
           var
            _bt_ =
              function(param){
               function _bv_(x){
                handle_read(input, x);
                return pop_heap_and_loop(0);
               }
               var _bw_ = read$0(0, input);
               return caml_call2(Async_kernel_Deferred_std[1], _bw_, _bv_);
              },
            _bu_ = pushback$1(w);
           return caml_call2(Async_kernel_Deferred_std[1], _bu_, _bt_);
          }
          handle_read(input, x);
         }
        },
      _bm_ =
        function(input){
         function _bn_(x){return handle_read(input, x);}
         var _bo_ = read$0(0, input);
         return caml_call2(Async_kernel_Deferred_std[5][2], _bo_, _bn_);
        },
      initial_push =
        caml_call3(Async_kernel_Deferred_list[14], -686623969, inputs, _bm_);
     caml_call2
      (Async_kernel_Deferred_std[11], initial_push, pop_heap_and_loop);
     return r;
    }
    var input = inputs[1];
    return input;
   }
   function concat_pipe(inputs){
    var
     r =
       create_reader_not_close_on_exc
        (0,
         function(w){
          var link = create$0(inputs, w), consumer = consumer$1(link);
          return iter$0
                  (0,
                   [0, [0, consumer]],
                   inputs,
                   function(input){return transfer_id(0, input, w);});
         });
    function _bg_(param){return close(inputs);}
    var _bh_ = closed(r);
    caml_call2(Async_kernel_Deferred_std[11], _bh_, _bg_);
    return r;
   }
   function concat(inputs){
    return create_reader_not_close_on_exc
            (0,
             function(w){
              function _bf_(input){return transfer_id(0, input, w);}
              return caml_call3
                      (Async_kernel_Deferred_list[14], -686623969, inputs, _bf_);
             });
   }
   function fork(t, pushback_uses){
    var
     match = create(0, 0, 0),
     writer0 = match[2],
     reader0 = match[1],
     match$0 = create(0, 0, 0),
     writer1 = match$0[2],
     reader1 = match$0[1],
     some_reader_was_closed = [0, 0],
     consumer =
       add_consumer
        (t,
         function(param){
          var some_reader_was_closed$0 = some_reader_was_closed[1];
          function _bc_(param){
           return 17724 <= param
                   ? some_reader_was_closed$0 ? -402004920 : 17724
                   : -402004920;
          }
          var
           _bd_ = [0, downstream_flushed(writer1), 0],
           _be_ = combine([0, downstream_flushed(writer0), _bd_]);
          return caml_call2(Async_kernel_Deferred_std[5][2], _be_, _bc_);
         }),
     still_open = [0, writer0, [0, writer1, 0]];
    function filter_open(still_open){
     if(! caml_call2(Core_List[23], still_open, is_closed)) return still_open;
     some_reader_was_closed[1] = 1;
     function _bb_(w){return 1 - is_closed(w);}
     var still_open$0 = caml_call2(Core_List[12], still_open, _bb_);
     if(caml_call1(Core_List[18], still_open$0)) close(t);
     return still_open$0;
    }
    function _a4_(still_open){
     caml_call2(Core_List[19], still_open, close);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    var
     _a5_ =
       fold
        ([0, [0, consumer]],
         0,
         t,
         still_open,
         function(still_open, queue){
          var still_open$0 = filter_open(still_open);
          if(caml_call1(Core_List[18], still_open$0))
           return caml_call1(Async_kernel_Deferred_std[10], 0);
          function _a7_(param){
           var still_open = filter_open(still_open$0);
           function _a$_(w){
            start_write(w, caml_call1(Core_Queue[16], queue));
            function _ba_(x){return caml_call2(Core_Queue[43], w[3], x);}
            caml_call2(Core_Queue[18], queue, _ba_);
            return finish_write(w);
           }
           caml_call2(Core_List[19], still_open, _a$_);
           return still_open;
          }
          if(-648027566 <= pushback_uses)
           var
            _a8_ = caml_call2(Core_List[51], still_open$0, pushback$1),
            _a9_ = caml_call1(Async_kernel_Deferred[23], _a8_);
          else
           var
            _a__ = caml_call2(Core_List[51], still_open$0, pushback$1),
            _a9_ = caml_call1(Async_kernel_Deferred[22], _a__);
          return caml_call2(Async_kernel_Deferred_std[5][2], _a9_, _a7_);
         }),
     _a6_ = caml_call2(Async_kernel_Deferred_std[5][1], _a5_, _a4_);
    caml_call1(Async_kernel_Deferred_std[8], _a6_);
    return [0, reader0, reader1];
   }
   function set_info(t, info){var v = [0, info]; t[2] = v; return 0;}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Pipe);
   var
    Async_kernel_Pipe =
      [0,
       sexp_of_pipe,
       sexp_of_pipe,
       [0, sexp_of_t$4, invariant$0],
       [0, sexp_of_t$3, invariant$0],
       create_reader,
       create_writer,
       create,
       empty,
       of_queue,
       of_list,
       singleton,
       unfold,
       of_sequence,
       to_sequence,
       close,
       close_read,
       is_closed,
       closed,
       [0, compare, equal, sexp_of_t],
       upstream_flushed,
       downstream_flushed,
       [0, values_sent_downstream],
       add_consumer,
       length,
       is_empty,
       num_values_read,
       num_values_written,
       pushback$1,
       write$0,
       write_without_pushback,
       transfer_in,
       transfer_in_without_pushback,
       write_when_ready,
       write_if_open,
       write_without_pushback_if_open,
       read,
       read$0,
       read_exn,
       read_exactly,
       read_now,
       read_now$0,
       read_now_exn,
       peek,
       clear,
       read_all,
       values_available,
       read_choice,
       read_choice_single_consumer_ex,
       Flushed,
       fold,
       fold$0,
       fold_without_pushback,
       iter,
       iter$0,
       iter_without_pushback,
       transfer,
       transfer$0,
       transfer_id,
       map,
       map$0,
       concat_map_list,
       folding_map,
       filter_map,
       filter_map$0,
       folding_filter_map,
       folding_filter_map$0,
       filter,
       interleave,
       interleave_pipe,
       merge,
       concat,
       concat_pipe,
       fork,
       to_stream_deprecated,
       of_stream_deprecated,
       drain,
       drain_and_count,
       to_list,
       hash,
       equal$0,
       compare$0,
       size_budget,
       set_size_budget$0,
       reserved_space,
       reserve_space,
       show_debug_messages,
       check_invariant,
       set_info];
   runtime.caml_register_global
    (170, Async_kernel_Pipe, cst_Async_kernel_Pipe$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Mvar
//# unitInfo: Requires: Async_kernel__Bvar, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Pipe, Base__Invariant, Core, Core__Unit, Moption, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Mvar$0 = "Async_kernel__Mvar",
    cst_async_kernel$0 = "async_kernel",
    cst_current_value$0 = "current_value",
    cst_src_mvar_ml = "src/mvar.ml",
    cst_taken$0 = "taken",
    cst_value_available$0 = "value_available",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/mvar.ml:23:26",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Moption = global_data.Moption,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Unit = global_data.Core__Unit,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Mvar$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_mvar_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "mvar.ml");
   var
    cst_Mvar_take_exn_called_on_em = "Mvar.take_exn called on empty mvar",
    _l_ = [0, cst_src_mvar_ml, 60, 2],
    cst_Mvar_peek_exn_called_on_em = "Mvar.peek_exn called on empty mvar",
    _j_ = [0, "_"],
    _k_ = [0, cst_src_mvar_ml, 16, 373, 395],
    _g_ = [0, cst_value_available$0],
    _h_ = [0, cst_taken$0],
    _i_ = [0, cst_current_value$0],
    cst_value_available = cst_value_available$0,
    cst_taken = cst_taken$0,
    cst_current_value = cst_current_value$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Mvar = cst_Async_kernel_Mvar$0;
   function value_available(r){return r[3];}
   function set_value_available(r, v){r[3] = v; return 0;}
   function taken(r){return r[2];}
   function current_value(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v];}
   var
    _b_ = [0, set_value_available],
    value_available$0 =
      [0,
       function(param){return 0;},
       cst_value_available,
       _b_,
       value_available,
       _a_];
   function _c_(r, v){return [0, r[1], v, r[3]];}
   var
    _d_ = 0,
    taken$0 = [0, function(param){return 0;}, cst_taken, _d_, taken, _c_];
   function _e_(r, v){return [0, v, r[2], r[3]];}
   var
    _f_ = 0,
    current_value$0 =
      [0,
       function(param){return 0;},
       cst_current_value,
       _f_,
       current_value,
       _e_];
   function value_available$1(t){
    return caml_call1(Async_kernel_Ivar[19], t[3]);
   }
   function is_empty(t){return caml_call1(Moption[14], t[1]);}
   function invariant(invariant_a, param, t){
    function _C_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      value_available_fun =
        check
         (function(value_available){
           var
            got = caml_call1(Async_kernel_Ivar[18], value_available),
            expect = caml_call1(Moption[15], t[1]),
            sexpifier = Core[323],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_011, b_012){
            return caml_call2(Core[316], a_011, b_012);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    got);
          });
     function _E_(_F_){return 0;}
     var
      taken_fun = check(caml_call2(Async_kernel_Bvar[2], Core_Unit[8], _E_)),
      current_value_fun = check(caml_call1(Moption[11], invariant_a));
     caml_call1(current_value_fun, current_value$0);
     caml_call1(taken_fun, taken$0);
     return caml_call1(value_available_fun, value_available$0);
    }
    function _D_(x_010){
     function of_a_001(param){return _j_;}
     var
      taken_006 = x_010[2],
      current_value_004 = x_010[1],
      value_available_008 = x_010[3],
      arg_009 =
        caml_call2(Async_kernel_Ivar[9], Core[620], value_available_008),
      bnds_003 = [0, [1, [0, _g_, [0, arg_009, 0]]], 0],
      arg_007 =
        caml_call3(Async_kernel_Bvar[1], Core[620], Core[212], taken_006),
      bnds_003$0 = [0, [1, [0, _h_, [0, arg_007, 0]]], bnds_003],
      arg_005 = caml_call2(Moption[10], of_a_001, current_value_004),
      bnds_003$1 = [0, [1, [0, _i_, [0, arg_005, 0]]], bnds_003$0];
     return [1, bnds_003$1];
    }
    return caml_call4(Base_Invariant[1], _k_, t, _D_, _C_);
   }
   function peek(t){return caml_call1(Moption[16], t[1]);}
   function peek_exn(t){
    if(is_empty(t)){
     var
      _B_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Mvar_peek_exn_called_on_em);
     caml_call1(Core[261], _B_);
    }
    return caml_call1(Moption[17], t[1]);
   }
   function sexp_of_t(sexp_of_a, param, t){
    var x_013 = peek(t);
    return caml_call2(Core[515], sexp_of_a, x_013);
   }
   function sexp_of_t$0(of_a_014, x_015){
    return sexp_of_t(of_a_014, Core[212], x_015);
   }
   function invariant$0(invariant_a, t){
    return invariant(invariant_a, function(_A_){return 0;}, t);
   }
   var Read_write = [0, sexp_of_t$0, invariant$0];
   function sexp_of_t$1(of_a_016, x_017){
    return sexp_of_t(of_a_016, Core[171], x_017);
   }
   function invariant$1(invariant_a, t){
    return invariant(invariant_a, function(_z_){return 0;}, t);
   }
   var Read_only = [0, sexp_of_t$1, invariant$1];
   function read_only(t){return t;}
   function write_only(t){return t;}
   function create(param){
    var
     _x_ = caml_call1(Async_kernel_Ivar[12], 0),
     _y_ = caml_call1(Async_kernel_Bvar[3], 0);
    return [0, caml_call1(Moption[13], 0), _y_, _x_];
   }
   function take_nonempty(t){
    if(is_empty(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    var r = caml_call1(Moption[17], t[1]);
    caml_call1(Moption[20], t[1]);
    caml_call2(Async_kernel_Bvar[5], t[2], 0);
    t[3] = caml_call1(Async_kernel_Ivar[12], 0);
    return r;
   }
   function take_now_exn(t){
    if(is_empty(t)){
     var
      _w_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Mvar_take_exn_called_on_em);
     caml_call1(Core[261], _w_);
    }
    return take_nonempty(t);
   }
   function take_now(t){return is_empty(t) ? 0 : [0, take_nonempty(t)];}
   function take(t){
    if(is_empty(t)){
     var _t_ = function(param){return take(t);}, _u_ = value_available$1(t);
     return caml_call2(Async_kernel_Deferred_std[5][1], _u_, _t_);
    }
    var _v_ = take_nonempty(t);
    return caml_call1(Async_kernel_Deferred_std[10], _v_);
   }
   function set(t, v){
    caml_call2(Moption[21], t[1], v);
    return caml_call2(Async_kernel_Ivar[16], t[3], 0);
   }
   function update(t, f){return set(t, caml_call1(f, peek(t)));}
   function update_exn(t, f){return set(t, caml_call1(f, peek_exn(t)));}
   function taken$1(t){return caml_call1(Async_kernel_Bvar[4], t[2]);}
   function put(t, v){
    if(is_empty(t)){
     set(t, v);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    function _r_(param){return put(t, v);}
    var _s_ = taken$1(t);
    return caml_call2(Async_kernel_Deferred_std[5][1], _s_, _r_);
   }
   function pipe_when_ready(t){
    var
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     w = match[2],
     r = match[1];
    function loop(param){
     function _n_(param){
      if(caml_call1(Async_kernel_Pipe[17], w))
       return caml_call1(Async_kernel_Deferred_std[10], 0);
      var match = take_now(t);
      if(! match) return loop(0);
      var x = match[1];
      function _p_(param){return loop(0);}
      var _q_ = caml_call2(Async_kernel_Pipe[29], w, x);
      return caml_call2(Async_kernel_Deferred_std[5][1], _q_, _p_);
     }
     var _o_ = value_available$1(t);
     return caml_call2(Async_kernel_Deferred_std[5][1], _o_, _n_);
    }
    var _m_ = loop(0);
    caml_call1(Async_kernel_Deferred_std[8], _m_);
    return r;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Mvar);
   var
    Async_kernel_Mvar =
      [0,
       sexp_of_t,
       Read_write,
       Read_only,
       create,
       is_empty,
       put,
       set,
       update,
       update_exn,
       read_only,
       write_only,
       value_available$1,
       take,
       take_now,
       take_now_exn,
       taken$1,
       peek,
       peek_exn,
       pipe_when_ready];
   runtime.caml_register_global
    (35, Async_kernel_Mvar, cst_Async_kernel_Mvar$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Lazy_deferred
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Monitor, Base__Monad, Core, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Lazy_deferred$0 = "Async_kernel__Lazy_deferred",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Lazy_deferred$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/lazy_deferred.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "lazy_deferred.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Lazy_deferred = cst_Async_kernel_Lazy_deferred$0;
   function create(opt, f){
    if(opt) var sth = opt[1], rest_exn = sth; else var rest_exn = 3804260;
    var start = caml_call1(Async_kernel_Ivar[12], 0);
    function _j_(param){
     return caml_call6(Async_kernel_Monitor[17], 0, 0, 0, 0, [0, rest_exn], f);
    }
    var _k_ = caml_call1(Async_kernel_Ivar[19], start);
    return [0, start, caml_call2(Async_kernel_Deferred_std[5][1], _k_, _j_)];
   }
   function create_or_error(opt, f){
    if(opt) var sth = opt[1], rest_exn = sth; else var rest_exn = 3804260;
    var start = caml_call1(Async_kernel_Ivar[12], 0);
    function _h_(param){
     return caml_call6(Async_kernel_Monitor[18], 0, 0, 0, 0, [0, rest_exn], f);
    }
    var _i_ = caml_call1(Async_kernel_Ivar[19], start);
    return [0, start, caml_call2(Async_kernel_Deferred_std[5][1], _i_, _h_)];
   }
   function wait(t){return t[2];}
   function wait_exn(t){
    return caml_call2(Async_kernel_Deferred_std[4], t[2], Core[255]);
   }
   function force(t){caml_call2(Async_kernel_Ivar[16], t[1], 0); return t[2];}
   function force_exn(t){
    var _f_ = Core[255], _g_ = force(t);
    return caml_call2(Async_kernel_Deferred_std[4], _g_, _f_);
   }
   function return$0(a){
    return create
            (0,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], a);
             });
   }
   function bind(t, f){
    return create
            (0,
             function(param){
              function _d_(a){return force_exn(caml_call1(f, a));}
              var _e_ = force_exn(t);
              return caml_call2(Async_kernel_Deferred_std[5][1], _e_, _d_);
             });
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return create
                (0,
                 function(param){
                  var _c_ = force_exn(t);
                  return caml_call2(Async_kernel_Deferred_std[4], _c_, f);
                 });
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function bind$1(t, f){
    return caml_call2
            (bind$0,
             t,
             function(a){
              return create(0, function(param){return caml_call1(f, a);});
             });
   }
   function is_forced(t){return caml_call1(Async_kernel_Ivar[18], t[1]);}
   function is_determined(t){
    return caml_call1(Async_kernel_Deferred[7], t[2]);
   }
   function peek(t){return caml_call1(Async_kernel_Deferred[5], t[2]);}
   function peek_exn(t){
    var _a_ = Core[255], _b_ = peek(t);
    return caml_call2(Core_Option[34], _b_, _a_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Lazy_deferred);
   var
    Async_kernel_Lazy_deferred =
      [0,
       create,
       create_or_error,
       force,
       force_exn,
       wait,
       wait_exn,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       bind$1,
       peek,
       peek_exn,
       is_determined,
       is_forced];
   runtime.caml_register_global
    (18, Async_kernel_Lazy_deferred, cst_Async_kernel_Lazy_deferred$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_condition
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Ivar, Core__Option, Core__Queue, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_conditi$0 = "Async_kernel__Async_condition",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Queue = global_data.Core__Queue,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_conditi$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_condition.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "async_condition.ml");
   var
    _a_ = [0, "waits"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_conditi = cst_Async_kernel_Async_conditi$0;
   function sexp_of_t(of_a_001, param){
    var
     waits_003 = param[1],
     _f_ = caml_call1(Async_kernel_Ivar[9], of_a_001),
     arg_004 = caml_call2(Core_Queue[13], _f_, waits_003),
     bnds_002 = [0, [1, [0, _a_, [0, arg_004, 0]]], 0];
    return [1, bnds_002];
   }
   function create(param){return [0, caml_call2(Core_Queue[66], 0, 0)];}
   function wait(t){
    function _e_(ivar){return caml_call2(Core_Queue[43], t[1], ivar);}
    return caml_call1(Async_kernel_Deferred[3], _e_);
   }
   function signal(t, a){
    function _c_(ivar){return caml_call2(Async_kernel_Ivar[14], ivar, a);}
    var _d_ = caml_call1(Core_Queue[45], t[1]);
    return caml_call2(Core_Option[46], _d_, _c_);
   }
   function broadcast(t, a){
    function _b_(ivar){return caml_call2(Async_kernel_Ivar[14], ivar, a);}
    caml_call2(Core_Queue[18], t[1], _b_);
    return caml_call1(Core_Queue[51], t[1]);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_conditi);
   var
    Async_kernel_Async_condition =
      [0, sexp_of_t, create, signal, broadcast, wait];
   runtime.caml_register_global
    (16, Async_kernel_Async_condition, cst_Async_kernel_Async_conditi$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_gc
//# unitInfo: Requires: Async_kernel__Scheduler, Core__Gc, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_gc$0 = "Async_kernel__Async_gc",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Gc = global_data.Core__Gc;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_gc$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_gc.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "async_gc.ml");
   var
    Stat = Core_Gc[1],
    Control = Core_Gc[2],
    stat_size = Core_Gc[3],
    compactions = Core_Gc[4],
    heap_words = Core_Gc[5],
    heap_chunks = Core_Gc[6],
    top_heap_words = Core_Gc[7],
    print_stat = Core_Gc[8],
    allocated_bytes = Core_Gc[9],
    keep_alive = Core_Gc[10],
    Allocation_policy = Core_Gc[11],
    tune = Core_Gc[12],
    disable_compaction = Core_Gc[13],
    For_testing = Core_Gc[14],
    Stable = Core_Gc[16],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_gc = cst_Async_kernel_Async_gc$0;
   function add_finalizer(heap_block, f){
    var _e_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[47], _e_), heap_block, f);
   }
   function add_finalizer_exn(heap_block, f){
    var _d_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[48], _d_), heap_block, f);
   }
   function add_finalizer_last(heap_block, f){
    var _c_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[49], _c_), heap_block, f);
   }
   function add_finalizer_last_exn(heap_block, f){
    var _b_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[50], _b_), heap_block, f);
   }
   var sexp_of_t = Core_Gc[15][6][1];
   function create(f){
    var _a_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call1(caml_call1(Async_kernel_Scheduler[46], _a_), f);
   }
   var delete$0 = Core_Gc[15][6][3], Alarm = [0, sexp_of_t, create, delete$0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_gc);
   var
    Async_kernel_Async_gc =
      [0,
       Stat,
       Control,
       stat_size,
       compactions,
       heap_words,
       heap_chunks,
       top_heap_words,
       print_stat,
       allocated_bytes,
       keep_alive,
       Allocation_policy,
       tune,
       disable_compaction,
       For_testing,
       Stable,
       add_finalizer,
       add_finalizer_exn,
       add_finalizer_last,
       add_finalizer_last_exn,
       Alarm];
   runtime.caml_register_global
    (13, Async_kernel_Async_gc, cst_Async_kernel_Async_gc$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_invariant_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_invaria = "Async_kernel__Async_invariant_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_invaria);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_invariant_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel, "async_invariant_intf.ml");
   var Async = [0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_invaria);
   var Async_kernel_Async_invariant_i = [0, Async];
   runtime.caml_register_global
    (11, Async_kernel_Async_invariant_i, cst_Async_kernel_Async_invaria);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_invariant
//# unitInfo: Requires: Async_kernel__Async_invariant_intf, Async_kernel__Deferred, Async_kernel__Monitor, Base__Field, Base__Invariant, Core, Core__Source_code_position, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_invaria$0 = "Async_kernel__Async_invariant",
    cst_async_kernel$0 = "async_kernel",
    cst_exn = "exn";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Field = global_data.Base__Field,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Invariant = global_data.Base__Invariant;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_invaria$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_invariant.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "async_invariant.ml");
   var
    invariant = Base_Invariant[1],
    check_field = Base_Invariant[2],
    _e_ = [0, cst_exn],
    _f_ = [0, "field"],
    cst_problem_with_field = "problem with field",
    _g_ = [0, 3804260],
    _h_ = [0, 523273847],
    _i_ = [0, 1],
    _a_ = [0, cst_exn],
    cst_invariant_failed = "invariant failed",
    _b_ = [0, 3804260],
    _c_ = [0, 523273847],
    _d_ = [0, 1],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_invaria = cst_Async_kernel_Async_invaria$0;
   function invariant$0(here, t, sexp_of_t, f){
    function _r_(param){
     if(0 === param[0]) return 0;
     var
      exn = param[1],
      _t_ = [0, caml_call1(sexp_of_t, t), 0],
      _u_ = [0, [1, [0, _a_, [0, caml_call1(Core[625], exn), 0]]], _t_],
      _v_ = [0, caml_call1(Core_Source_code_position[1], here), _u_],
      _w_ =
        [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_invariant_failed), _v_]];
     return caml_call1(Core[261], _w_);
    }
    var _s_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _d_, _c_, _b_, f);
    return caml_call2(Async_kernel_Deferred[16][4][3], _s_, _r_);
   }
   function check_field$0(t, f, wait_for_previous, field){
    function _j_(param){
     function _k_(param){
      if(0 === param[0]) return 0;
      var
       exn = param[1],
       _n_ = [0, [1, [0, _e_, [0, caml_call1(Core[625], exn), 0]]], 0],
       _o_ = caml_call1(Base_Field[2], field),
       _p_ = [0, [1, [0, _f_, [0, caml_call1(Core[558], _o_), 0]]], _n_],
       _q_ =
         [1,
          [0, caml_call1(Sexplib0_Sexp_conv[7], cst_problem_with_field), _p_]];
      return caml_call1(Core[261], _q_);
     }
     function _l_(param){
      return caml_call1(f, caml_call2(Base_Field[3], field, t));
     }
     var
      _m_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _i_, _h_, _g_, _l_);
     return caml_call2(Async_kernel_Deferred[16][4][3], _m_, _k_);
    }
    return caml_call2(Async_kernel_Deferred[16][4][2], wait_for_previous, _j_);
   }
   var Async = [0, invariant$0, check_field$0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_invaria);
   var Async_kernel_Async_invariant = [0, invariant, check_field, Async];
   runtime.caml_register_global
    (29, Async_kernel_Async_invariant, cst_Async_kernel_Async_invaria$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel
//# unitInfo: Requires: Async_kernel__Async_gc, Async_kernel__Clock_ns, Async_kernel__Deferred, Async_kernel__Deferred_result, Async_kernel__Monitor, Async_kernel__Scheduler, Core, Inline_test_config, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel$0 = "Async_kernel",
    cst_async_kernel$0 = "async_kernel",
    cst_src_async_kernel_ml$0 = "src/async_kernel.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/async_kernel.ml:94:17",
    Core = global_data.Core,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_async_kernel_ml$0);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "async_kernel.ml");
   var
    after = Async_kernel_Clock_ns[4],
    at = Async_kernel_Clock_ns[3],
    catch$0 = Async_kernel_Monitor[21],
    choice = Async_kernel_Deferred[27],
    choose = Async_kernel_Deferred[29],
    don_t_wait_for = Async_kernel_Deferred[25],
    every = Async_kernel_Clock_ns[11],
    never = Async_kernel_Deferred[19],
    schedule = Async_kernel_Scheduler[61],
    schedule$0 = Async_kernel_Scheduler[60],
    try_with = Async_kernel_Monitor[16],
    upon = Async_kernel_Deferred[4],
    with_timeout = Async_kernel_Clock_ns[5],
    with_timeout_exn = Async_kernel_Clock_ns[6],
    within = Async_kernel_Scheduler[58],
    within$0 = Async_kernel_Scheduler[57],
    symbol = Async_kernel_Deferred[17][3],
    symbol$0 = Async_kernel_Deferred_result[1],
    symbol$1 = Async_kernel_Deferred_result[2],
    include = Async_kernel_Deferred[16],
    return$0 = include[1],
    symbol_bind = include[2],
    symbol_map = include[3],
    Let_syntax = include[4],
    Async_kernel_private = [0],
    cst_src_async_kernel_ml = cst_src_async_kernel_ml$0,
    cst_return_does_not_allocate = "[return ()] does not allocate",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel = cst_Async_kernel$0;
   function _a_(param){
    var expect = runtime.core_gc_minor_words(0);
    caml_call1(return$0, 0);
    caml_call1(Async_kernel_Deferred[12], 0);
    caml_call1(Async_kernel_Deferred[16][1], 0);
    caml_call1(Async_kernel_Deferred[16][4][1], 0);
    var
     got = runtime.core_gc_minor_words(0),
     sexpifier = Core[389],
     equal = 0,
     message = 0,
     here = 0;
    function comparator(a_001, b_002){
     return caml_call2(Core[382], a_001, b_002);
    }
    caml_call8
     (Ppx_assert_lib_Runtime[3],
      pos,
      sexpifier,
      comparator,
      here,
      message,
      equal,
      expect,
      got);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib[9],
     Inline_test_config,
     cst_return_does_not_allocate,
     0,
     cst_src_async_kernel_ml,
     87,
     0,
     443,
     _a_);
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel);
   var
    Async_kernel =
      [0,
       after,
       at,
       catch$0,
       choice,
       choose,
       don_t_wait_for,
       every,
       never,
       schedule,
       schedule$0,
       try_with,
       upon,
       with_timeout,
       with_timeout_exn,
       within,
       within$0,
       symbol,
       symbol$0,
       symbol$1,
       return$0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Async_kernel_private];
   runtime.caml_register_global(22, Async_kernel, cst_Async_kernel$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhc3luY19rZXJuZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImFmdGVyIiwidCIsInNwYW4iLCJyZXN1bHQiLCJsb2ciLCJhcmcyXzAwMyIsImFyZzNfMDA0Iiwic2V4cF9vZl9hIiwiYXJnMV8wMDIiLCJhcmcwXzAwMSIsInJlczBfMDA1IiwicmVzMV8wMDYiLCJyZXMyXzAwNyIsInJlczNfMDA4IiwibG9nX3N0cmluZyIsIm1lc3NhZ2UiLCJjb25jYXQiLCJlcHJpbnQiLCJlcHJpbnRfcyIsImVwcmludHMiLCJwcmludF9zIiwic2V4cCIsInNlYyIsImFsbCIsInNleHBfb2ZfdCIsInRvX3JlcHIiLCJvZl9yZXByIiwiZGVidWciLCJmb3J3YXJkaW5nIiwiciIsInNldF9mb3J3YXJkaW5nIiwidiIsImhhc19zZWVuX2Vycm9yIiwic2V0X2hhc19zZWVuX2Vycm9yIiwidGFpbHNfZm9yX2FsbF9lcnJvcnMiLCJzZXRfdGFpbHNfZm9yX2FsbF9lcnJvcnMiLCJoYW5kbGVyc19mb3JfYWxsX2Vycm9ycyIsInNldF9oYW5kbGVyc19mb3JfYWxsX2Vycm9ycyIsIm5leHRfZXJyb3IiLCJzZXRfbmV4dF9lcnJvciIsImlkIiwiaGVyZSIsIm5hbWUiLCJmb3J3YXJkaW5nJDAiLCJoYXNfc2Vlbl9lcnJvciQwIiwidGFpbHNfZm9yX2FsbF9lcnJvcnMkMCIsImhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzJDAiLCJuZXh0X2Vycm9yJDAiLCJpZCQwIiwiaGVyZSQwIiwibmFtZSQwIiwiaXRlciIsIm5hbWVfZnVuIiwiaGVyZV9mdW4iLCJpZF9mdW4iLCJuZXh0X2Vycm9yX2Z1biIsImhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzX2Z1biIsInRhaWxzX2Zvcl9hbGxfZXJyb3JzX2Z1biIsImhhc19zZWVuX2Vycm9yX2Z1biIsImZvcndhcmRpbmdfZnVuIiwiZGVzY3JpcHRpb24iLCJkZXNjcmlwdGlvbnMiLCJ0JDEiLCJhYyIsImFjJDAiLCJ0JDAiLCJ4XzAwMSIsIm5leHRfaWQiLCJjcmVhdGVfd2l0aF9wYXJlbnQiLCJpbmZvIiwicGFyZW50IiwiaSIsInMiLCJzJDAiLCJ4XzAwMiIsInBhcmVudCQwIiwibWFpbiIsImJhY2t0cmFjZV9oaXN0b3J5IiwibG9jYWxfc3RvcmFnZSIsInByaW9yaXR5IiwibW9uaXRvciIsImJhY2t0cmFjZV9oaXN0b3J5XzAwOCIsImxvY2FsX3N0b3JhZ2VfMDA2IiwicHJpb3JpdHlfMDA0IiwibW9uaXRvcl8wMDIiLCJhcmdfMDA5IiwiYm5kc18wMDEiLCJhcmdfMDA3IiwiYm5kc18wMDEkMCIsImFyZ18wMDUiLCJibmRzXzAwMSQxIiwiYXJnXzAwMyIsImJuZHNfMDAxJDIiLCJpbnZhcmlhbnQiLCJjcmVhdGVfbGlrZSIsIm1vbml0b3IkMCIsImZpbmRfbG9jYWwiLCJrZXkiLCJ3aXRoX2xvY2FsIiwiZGF0YSIsImRhdGEkMCIsInJlY29yZF9iYWNrdHJhY2UiLCJkdW1teV9lIiwiZHVtbXlfZiIsImR1bW15X2EiLCJzZXhwX29mX3Nsb3RzIiwiY3JlYXRlIiwib2ZfZXZlbnQiLCJldmVudCIsIm9mX2pvYiIsImpvYiIsImlzX2V2ZW50IiwiaXNfam9iIiwia2luZCIsInByb2plY3QiLCJqb2Jfb3JfZXZlbnQiLCJldmVudHMiLCJzZXRfZXhlY3V0aW9uX2NvbnRleHQiLCJleGVjdXRpb25fY29udGV4dCIsImxlbmd0aCIsInNldF9sZW5ndGgiLCJmcm9udCIsInNldF9mcm9udCIsIm1hc2siLCJzZXRfbWFzayIsImpvYnMiLCJzZXRfam9icyIsImpvYnNfbGVmdF90aGlzX2N5Y2xlIiwic2V0X2pvYnNfbGVmdF90aGlzX2N5Y2xlIiwibnVtX2pvYnNfcnVuIiwic2V0X251bV9qb2JzX3J1biIsImxlbmd0aCQwIiwiZnJvbnQkMCIsIm1hc2skMCIsImpvYnMkMCIsImpvYnNfbGVmdF90aGlzX2N5Y2xlJDAiLCJudW1fam9ic19ydW4kMCIsIm51bV9qb2JzX3J1bl8wMDIiLCJqb2JzX2xlZnRfdGhpc19jeWNsZV8wMDQiLCJqb2JzXzAwNiIsIm1hc2tfMDA4IiwiZnJvbnRfMDEwIiwibGVuZ3RoXzAxMiIsImJhY2t0cmFjZV9vZl9maXJzdF9lbnF1ZXVlXzAxNCIsImFyZ18wMTUiLCJhcmdfMDEzIiwiYXJnXzAxMSIsImJuZHNfMDAxJDMiLCJibmRzXzAwMSQ0IiwiYm5kc18wMDEkNSIsIm9mZnNldCIsImNhcGFjaXR5IiwiY2hlY2siLCJmIiwibGVuZ3RoX2Z1biIsImZyb250X2Z1biIsIm1hc2tfZnVuIiwiam9ic19mdW4iLCJqb2JzX2xlZnRfdGhpc19jeWNsZV9mdW4iLCJudW1fam9ic19ydW5fZnVuIiwiY3JlYXRlX2FycmF5IiwiYmFja3RyYWNlX29mX2ZpcnN0X2VucXVldWUiLCJjbGVhciIsInNldCIsImEiLCJvZmZzZXQkMCIsImVucXVldWUiLCJvbGRfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJvbGRfam9icyIsIm9sZF9mcm9udCIsImxlbjEiLCJsZW4yIiwibmV3X2pvYnMiLCJzZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUkMCIsIm4iLCJjYW5fcnVuX2Ffam9iIiwicnVuX2pvYiIsInNjaGVkdWxlciIsInJ1bl9leHRlcm5hbF9qb2JzIiwiZXh0ZXJuYWxfam9icyIsInJ1bl9qb2JzIiwidGhpc19qb2IiLCJleG4kMCIsImV4biIsImJhY2t0cmFjZSIsInBvcyQzIiwicG9zJDIiLCJwb3MkMSIsInBvcyQwIiwicG9zIiwiaXNfbnVsbCIsImRlZmF1bHRfdGltaW5nX3doZWVsX2NvbmZpZyIsImNvbXBhcmUkMCIsImVxdWFsJDAiLCJzZXhwX29mX3QkMSIsInRyYW5zaXRpb25faXNfYWxsb3dlZCIsImZyb20iLCJ0byIsInNleHBfb2ZfZXZlbnQiLCJhdCIsImludGVydmFsIiwic3RhdHVzIiwibWF0Y2giLCJub25lIiwic29tZSIsImlzX25vbmUiLCJpc19zb21lIiwiZmlyc3Rfc29tZSIsInQxIiwidDIiLCJ1bnNhZmVfdmFsdWUiLCJzZXhwX29mX3QkMiIsInBweF9vcHRpb25hbF9lXzAiLCJ2YWx1ZSQwIiwiZGVmYXVsdCQwIiwidmFsdWVfZXhuIiwidG9fb3B0aW9uIiwib2Zfb3B0aW9uIiwic2V0X3N0YXR1cyIsInByZXZfZmlyZWQiLCJzZXRfcHJldl9maXJlZCIsIm5leHRfZmlyZWQiLCJzZXRfbmV4dF9maXJlZCIsInNldF9pbnRlcnZhbCIsImNhbGxiYWNrIiwiYXQkMCIsInNldF9hdCIsImFsYXJtIiwic2V0X2FsYXJtIiwic3RhdHVzJDAiLCJwcmV2X2ZpcmVkJDAiLCJuZXh0X2ZpcmVkJDAiLCJpbnRlcnZhbCQwIiwiZXhlY3V0aW9uX2NvbnRleHQkMCIsImNhbGxiYWNrJDAiLCJhdCQxIiwiYWxhcm0kMCIsImFsYXJtX2Z1biIsImF0X2Z1biIsImNhbGxiYWNrX2Z1biIsImV4ZWN1dGlvbl9jb250ZXh0X2Z1biIsImludGVydmFsX2Z1biIsIm5leHRfZmlyZWRfZnVuIiwicHJldl9maXJlZF9mdW4iLCJzdGF0dXNfZnVuIiwiZ290Iiwic2V4cGlmaWVyIiwiZXhwZWN0IiwiZXF1YWwiLCJjb21wYXJhdG9yIiwiYV8wMTMiLCJiXzAxNCIsImFfMDA5IiwiYl8wMTAiLCJhXzAwNSIsImJfMDA2Iiwic2V0X3N0YXR1cyQwIiwic2V0X3N0YXR1c19pZiIsImlzIiwic2V4cF9vZl90JDMiLCJrIiwiaXNfd2FsbF9jbG9jayIsImhhbmRsZV9maXJlZCIsIm1vc3RfcmVjZW50bHlfZmlyZWQiLCJzZXRfbW9zdF9yZWNlbnRseV9maXJlZCIsImZpcmVkX2V2ZW50cyIsInNldF9maXJlZF9ldmVudHMiLCJhbV9hZHZhbmNpbmciLCJzZXRfYW1fYWR2YW5jaW5nIiwiYWR2YW5jZV9lcnJvcnMiLCJzZXRfYWR2YW5jZV9lcnJvcnMiLCJzY2hlZHVsZXIkMCIsImlzX3dhbGxfY2xvY2skMCIsImhhbmRsZV9maXJlZCQwIiwibW9zdF9yZWNlbnRseV9maXJlZCQwIiwiZmlyZWRfZXZlbnRzJDAiLCJldmVudHMkMCIsImFtX2FkdmFuY2luZyQwIiwiYWR2YW5jZV9lcnJvcnMkMCIsIml0ZXIkMCIsImFkdmFuY2VfZXJyb3JzX2Z1biIsImFtX2FkdmFuY2luZ19mdW4iLCJldmVudHNfZnVuIiwiZmlyZWRfZXZlbnRzX2Z1biIsIm1vc3RfcmVjZW50bHlfZmlyZWRfZnVuIiwiaGFuZGxlX2ZpcmVkX2Z1biIsImlzX3dhbGxfY2xvY2tfZnVuIiwic2NoZWR1bGVyX2Z1biIsInNleHBfb2ZfdCQ0Iiwibm93IiwiYWxsX2V2ZW50cyIsImF0MiIsImF0MSIsInRpbWluZ193aGVlbF9ub3ciLCJpc19pbl9maXJlZF9ldmVudHMiLCJ0YXJnZXRfZXZlbnQiLCJjdXJyZW50JDEiLCJjdXJyZW50IiwiY3VycmVudCQwIiwiaW52YXJpYW50X3dpdGhfam9icyIsImpvYl9pbnZhcmlhbnQiLCJwcHhfb3B0aW9uYWxfZV8wJDAiLCJhXzAxNyIsImJfMDE4IiwiZ290JDAiLCJzZXhwaWZpZXIkMCIsImV4cGVjdCQwIiwibWVzc2FnZSQwIiwiY29tcGFyYXRvciQwIiwiYV8wMTkiLCJiXzAyMCIsInhfMDE2IiwiaW52YXJpYW50JDAiLCJzZXhwX29mX3QkNSIsInhfMDIxIiwiaW52YXJpYW50JDEiLCJpbnZhcmlhbnRfd2l0aF9qb2JzJDAiLCJzZXhwX29mX3QkNiIsInhfMDIyIiwiaWQkMSIsImlzX3dhbGxfY2xvY2skMSIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJyZWFkX29ubHkiLCJmaXJlIiwiY29udGludWUkMCIsIm5leHQkMCIsImNvbnRpbnVlJDEiLCJwcHhfb3B0aW9uYWxfZV8wJDEiLCJuZXh0IiwicHB4X29wdGlvbmFsX2VfMCQyIiwicHJldiIsImFsYXJtX3ByZWNpc2lvbiIsIm5leHRfYWxhcm1fZmlyZXNfYXQiLCJuZXh0X2FsYXJtX3J1bnNfYXQiLCJub3ckMCIsInRpbWluZ193aGVlbF9ub3ckMCIsInNjaGVkdWxlIiwicmVtb3ZlX2Zyb21fZmlyZWQiLCJuZXdfc3RhdHVzIiwic2V4cF9vZl9ldmVudCQwIiwic3RhdHVzJDEiLCJwcmV2X2ZpcmVkJDEiLCJzZXRfcHJldl9maXJlZCQwIiwibmV4dF9maXJlZCQxIiwic2V0X25leHRfZmlyZWQkMCIsImludGVydmFsJDEiLCJzZXRfaW50ZXJ2YWwkMCIsImV4ZWN1dGlvbl9jb250ZXh0JDEiLCJjYWxsYmFjayQxIiwic2V0X2F0JDAiLCJhbGFybSQxIiwic2V0X2FsYXJtJDAiLCJzZXhwX29mX3QkNyIsImludmFyaWFudCQyIiwic2V0X3N0YXR1cyQxIiwic2V0X3N0YXR1c19pZiQwIiwic2NoZWR1bGVkX2F0IiwiY3JlYXRlX2ludGVybmFsIiwiYWRkJDAiLCJjcmVhdGVfYW5kX2FkZCIsImF0JDIiLCJhZnRlciQwIiwicmVxdWlyZV9zcGFuX2F0X2xlYXN0X2FsYXJtX3ByIiwiYWxhcm1fcHJlY2lzaW9uJDAiLCJhdF9pbnRlcnZhbHMiLCJzdGFydCIsInNleHBfb2ZfdCQ4IiwiYWJvcnQiLCJhYm9ydF9pZl9wb3NzaWJsZSIsImFib3J0X2V4biIsInJlYXNvbiIsImlzX3NjaGVkdWxlZCIsInNjaGVkdWxlX2F0X2ludGVybmFsIiwic2NoZWR1bGVfYXQiLCJzY2hlZHVsZV9hZnRlciIsInNjaGVkdWxlX2F0X2ludGVydmFscyIsInN0YXJ0aW5nX2F0Iiwic2NoZWR1bGVfYXRfaW50ZXJ2YWxzJDAiLCJyZXNjaGVkdWxlX2F0IiwicmVzY2hlZHVsZV9hZnRlciIsInJ1bl9hZnRlciIsInJ1bl9hdCIsInJ1bl9hdF9pbnRlcnZhbHMiLCJydW5fZmlyZWRfZXZlbnRzIiwic2VuZF9leG4iLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0Iiwic2VuZF9leG4kMCIsImFueV9maXJlZF9ldmVudHNfdG9fcnVuIiwiYWR2YW5jZV9jbG9jayIsImFkdmFuY2VfY2xvY2tfc3RvcF9hdF9uZXh0X2FsYSIsImZpcmVfcGFzdF9hbGFybXMiLCJhZHZhbmNlX2ludGVybmFsIiwiYWR2YW5jZV9pbnRlcm5hbF9zdG9wX2F0X25leHRfIiwicHJlcGFyZV90b19hZHZhbmNlIiwiZmluaXNoX2FkdmFuY2luZyIsImVycm9ycyIsImFkdmFuY2VfYnlfYWxhcm1zIiwiYWR2YW5jZV9ieV9hbGFybXNfYnkiLCJieSIsImFkdmFuY2VfYnlfbWF4X2FsYXJtc19pbl9lYWNoXyIsImFkdmFuY2VfZGlyZWN0bHkiLCJhZHZhbmNlX2RpcmVjdGx5X2J5IiwiZHVyYXRpb25fb2YiLCJkdXJhdGlvbiIsIm1heF9hbGFybV90aW1lX2luX21pbl90aW1pbmdfdyIsImhhc19ldmVudHNfdG9fcnVuIiwiY3JlYXRlX3dpdGhfY2VsbCIsImNlbGwiLCJjcmVhdGVfZnVsbCIsImNyZWF0ZSQwIiwiZXhlYyIsImV4ZWMkMCIsImV4ZWNfZnVuIiwic2V4cF9vZl90JDAiLCJleGVjdXRpb25fY29udGV4dF8wMDIiLCJyZWNvcmRfYmFja3RyYWNlcyIsInNldF9yZWNvcmRfYmFja3RyYWNlcyIsIm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyXyIsInNldF9tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5XyIsImNoZWNrX2ludmFyaWFudHMiLCJzZXRfY2hlY2tfaW52YXJpYW50cyIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIiwic2V0X3lpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIiwieWllbGQkMCIsInNldF95aWVsZCIsImV2ZW50X2FkZGVkX2hvb2siLCJzZXRfZXZlbnRfYWRkZWRfaG9vayIsImpvYl9xdWV1ZWRfaG9vayIsInNldF9qb2JfcXVldWVkX2hvb2siLCJ0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayIsInNldF90aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaCIsInRpbWVfc291cmNlIiwic2V0X3RpbWVfc291cmNlIiwidG90YWxfY3ljbGVfdGltZSIsInNldF90b3RhbF9jeWNsZV90aW1lIiwibGFzdF9jeWNsZV9udW1fam9icyIsInNldF9sYXN0X2N5Y2xlX251bV9qb2JzIiwibGFzdF9jeWNsZV90aW1lIiwic2V0X2xhc3RfY3ljbGVfdGltZSIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUiLCJydW5fZXZlcnlfY3ljbGVfZW5kIiwic2V0X3J1bl9ldmVyeV9jeWNsZV9lbmQiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnQiLCJzZXRfcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IiwiaW5fY3ljbGUiLCJzZXRfaW5fY3ljbGUiLCJjeWNsZV9zdGFydCIsInNldF9jeWNsZV9zdGFydCIsImN5Y2xlX2NvdW50Iiwic2V0X2N5Y2xlX2NvdW50IiwidW5jYXVnaHRfZXhuX3Vud3JhcHBlZCIsInNldF91bmNhdWdodF9leG4iLCJzZXRfY3VycmVudF9leGVjdXRpb25fY29udGV4dCIsIm1haW5fZXhlY3V0aW9uX2NvbnRleHQiLCJzZXRfbWFpbl9leGVjdXRpb25fY29udGV4dCIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMiLCJsb3dfcHJpb3JpdHlfam9icyIsIm5vcm1hbF9wcmlvcml0eV9qb2JzIiwiam9iX3Bvb2wiLCJzZXRfam9iX3Bvb2wiLCJjaGVja19hY2Nlc3MiLCJzZXRfY2hlY2tfYWNjZXNzIiwicmVjb3JkX2JhY2t0cmFjZXMkMCIsIm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyXyQwIiwiY2hlY2tfaW52YXJpYW50cyQwIiwieWllbGRfdW50aWxfbm9fam9ic19yZW1haW4kMCIsInlpZWxkJDEiLCJldmVudF9hZGRlZF9ob29rJDAiLCJqb2JfcXVldWVkX2hvb2skMCIsInRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rJDAiLCJleHRlcm5hbF9qb2JzJDAiLCJ0aW1lX3NvdXJjZSQwIiwidG90YWxfY3ljbGVfdGltZSQwIiwibGFzdF9jeWNsZV9udW1fam9icyQwIiwibGFzdF9jeWNsZV90aW1lJDAiLCJydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlJDAiLCJydW5fZXZlcnlfY3ljbGVfZW5kJDAiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUkMCIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydCQwIiwiaW5fY3ljbGUkMCIsImN5Y2xlX3N0YXJ0JDAiLCJjeWNsZV9jb3VudCQwIiwidW5jYXVnaHRfZXhuIiwiY3VycmVudF9leGVjdXRpb25fY29udGV4dCQwIiwibWFpbl9leGVjdXRpb25fY29udGV4dCQwIiwidmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyQwIiwibG93X3ByaW9yaXR5X2pvYnMkMCIsIm5vcm1hbF9wcmlvcml0eV9qb2JzJDAiLCJqb2JfcG9vbCQwIiwiY2hlY2tfYWNjZXNzJDAiLCJjaGVja19hY2Nlc3NfZnVuIiwiam9iX3Bvb2xfZnVuIiwibm9ybWFsX3ByaW9yaXR5X2pvYnNfZnVuIiwibG93X3ByaW9yaXR5X2pvYnNfZnVuIiwidmVyeV9sb3dfcHJpb3JpdHlfd29ya2Vyc19mdW4iLCJtYWluX2V4ZWN1dGlvbl9jb250ZXh0X2Z1biIsImN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRfZnVuIiwidW5jYXVnaHRfZXhuX2Z1biIsImN5Y2xlX2NvdW50X2Z1biIsImN5Y2xlX3N0YXJ0X2Z1biIsImluX2N5Y2xlX2Z1biIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydF9mdW4iLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGVfZnUiLCJydW5fZXZlcnlfY3ljbGVfZW5kX2Z1biIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGVfZnVuIiwibGFzdF9jeWNsZV90aW1lX2Z1biIsImxhc3RfY3ljbGVfbnVtX2pvYnNfZnVuIiwidG90YWxfY3ljbGVfdGltZV9mdW4iLCJ0aW1lX3NvdXJjZV9mdW4iLCJleHRlcm5hbF9qb2JzX2Z1biIsInRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rXyIsImpvYl9xdWV1ZWRfaG9va19mdW4iLCJldmVudF9hZGRlZF9ob29rX2Z1biIsInlpZWxkX2Z1biIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluX2Z1biIsImNoZWNrX2ludmFyaWFudHNfZnVuIiwicmVjb3JkX2JhY2t0cmFjZXNfZnVuIiwiY2hlY2tfYWNjZXNzXzAwNyIsImpvYl9wb29sXzAwOSIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnNfMDE1IiwibG93X3ByaW9yaXR5X2pvYnNfMDEzIiwibm9ybWFsX3ByaW9yaXR5X2pvYnNfMDExIiwibWFpbl9leGVjdXRpb25fY29udGV4dF8wMTciLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0XzAxOSIsInVuY2F1Z2h0X2V4bl8wMjEiLCJjeWNsZV9jb3VudF8wMjciLCJjeWNsZV9zdGFydF8wMjkiLCJpbl9jeWNsZV8wMzEiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfMDMzIiwicnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlXzAzIiwicnVuX2V2ZXJ5X2N5Y2xlX2VuZF8wMzciLCJydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlXzAzOSIsImxhc3RfY3ljbGVfdGltZV8wNDEiLCJsYXN0X2N5Y2xlX251bV9qb2JzXzA0MyIsInRvdGFsX2N5Y2xlX3RpbWVfMDQ1IiwidGltZV9zb3VyY2VfMDQ3IiwiZXh0ZXJuYWxfam9ic18wNDkiLCJqb2JfcXVldWVkX2hvb2tfMDUzIiwiZXZlbnRfYWRkZWRfaG9va18wNTUiLCJ5aWVsZF8wNTciLCJ5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbl8wNTkiLCJjaGVja19pbnZhcmlhbnRzXzA2MSIsInJlY29yZF9iYWNrdHJhY2VzXzA2NSIsImFyZ18wNjYiLCJibmRzXzAwNiIsImFyZ18wNjQiLCJibmRzXzAwNiQwIiwiYXJnXzA2MiIsImJuZHNfMDA2JDEiLCJhcmdfMDYwIiwiYm5kc18wMDYkMiIsImFyZ18wNTgiLCJibmRzXzAwNiQzIiwiYXJnXzA1NiIsImJuZHNfMDA2JDQiLCJhcmdfMDU0IiwiYm5kc18wMDYkNSIsImFyZ18wNTIiLCJibmRzXzAwNiQ2IiwiYXJnXzA1MCIsImJuZHNfMDA2JDciLCJhcmdfMDQ4IiwiYm5kc18wMDYkOCIsImFyZ18wNDYiLCJibmRzXzAwNiQ5IiwiYXJnXzA0NCIsImJuZHNfMDA2JDEwIiwiYXJnXzA0MiIsImJuZHNfMDA2JDExIiwiYXJnXzA0MCIsImJuZHNfMDA2JDEyIiwiYXJnXzAzOCIsImJuZHNfMDA2JDEzIiwiYXJnXzAzNiIsImJuZHNfMDA2JDE0IiwiYXJnXzAzNCIsImJuZHNfMDA2JDE1IiwiYXJnXzAzMiIsImJuZHNfMDA2JDE2IiwiYXJnXzAzMCIsImJuZHNfMDA2JDE3IiwiYXJnXzAyOCIsImJuZHNfMDA2JDE4IiwiYXJnMV8wMjQiLCJhcmcwXzAyMyIsInJlczBfMDI1IiwicmVzMV8wMjYiLCJhcmdfMDIyIiwiYm5kc18wMDYkMTkiLCJhcmdfMDIwIiwiYm5kc18wMDYkMjAiLCJhcmdfMDE4IiwiYm5kc18wMDYkMjEiLCJhcmdfMDE2IiwiYm5kc18wMDYkMjIiLCJhcmdfMDE0IiwiYm5kc18wMDYkMjMiLCJhcmdfMDEyIiwiYm5kc18wMDYkMjQiLCJhcmdfMDEwIiwiYm5kc18wMDYkMjUiLCJhcmdfMDA4IiwiYm5kc18wMDYkMjYiLCJ1bmNhdWdodF9leG4kMCIsImFyZzFfMDY4IiwiYXJnMF8wNjciLCJyZXMwXzA2OSIsInJlczFfMDcwIiwibnVtX3BlbmRpbmdfam9icyIsImxhc3RfY3ljbGVfbnVtX2pvYnMkMSIsInVub3JkZXJlZF9pc19zdWJsaXN0Iiwic21hbGwiLCJsYXJnZSIsImxhcmdlJDAiLCJhY2MiLCJ4IiwibCQwIiwieSIsImwiLCJjaGVja19ob29rX3RhYmxlX2ludmFyaWFudCIsInRhYmxlIiwiYXJyYXkiLCJmaWVsZCIsInEiLCJmcmVlX2pvYiIsImpvYl9xdWV1ZSIsImYkMCIsImVucXVldWVfam9iIiwiY3JlYXRlJDEiLCJpc19kZWFkIiwic2V0X2NoZWNrX2FjY2VzcyQwIiwiYmFja3RyYWNlX29mX2ZpcnN0X2pvYiIsInRfcmVmIiwiY2hlY2tfYWNjZXNzJDEiLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0JDEiLCJ3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSIsInRtcF9jb250ZXh0Iiwib2xkX2NvbnRleHQiLCJ3aXRoX2V4ZWN1dGlvbl9jb250ZXh0IiwiY3JlYXRlX2pvYiIsImdvdF91bmNhdWdodF9leG4iLCJhcmcxXzA3MiIsImFyZzBfMDcxIiwicmVzMF8wNzMiLCJyZXMxXzA3NCIsInN0YXJ0X2N5Y2xlIiwibWF4X251bV9qb2JzX3Blcl9wcmlvcml0eSIsImUiLCJlJDAiLCJzdGFiaWxpemUiLCJjcmVhdGVfdGltZV9zb3VyY2UiLCJvcHQiLCJzdGgiLCJ0aW1pbmdfd2hlZWxfY29uZmlnIiwid2FsbF9jbG9jayIsInNldF9wcmV2IiwicGFyYW0iLCJzZXRfbmV4dCIsInJ1biIsImNyZWF0ZTIiLCJydW4xIiwiZXhlY3V0aW9uX2NvbnRleHQxIiwicnVuMiIsImV4ZWN1dGlvbl9jb250ZXh0MiIsInNjaGVkdWxlX2pvYnMiLCJhZGQiLCJvZl9saXN0IiwiZmlyc3QiLCJsJDEiLCJsJDIiLCJydW4kMCIsInByZXYkMCIsInRvX2xpc3QiLCJhY2MkMCIsImNlbGxfb2ZfaGFuZGxlciIsImluZGlyIiwic3F1YXNoIiwidCQzIiwidCQ0IiwiaW5kaXIkMSIsInQkNSIsImluZGlyJDAiLCJ0JDIiLCJhX2ludmFyaWFudCIsImhhbmRsZXIiLCJwZWVrIiwidmFsdWUiLCJpZl9lbXB0eV90aGVuX2ZhaWx3aXRoIiwiaXNfZW1wdHkiLCJpc19mdWxsIiwiZmlsbF9leG4iLCJyZW1vdmVfaGFuZGxlciIsImFkZF9oYW5kbGVyIiwiaGFuZGxlciQxIiwiaGFuZGxlciQyIiwicnVuJDEiLCJoYW5kbGVyJDAiLCJoYXNfaGFuZGxlcnMiLCJ1cG9uIiwidXBvbiQwIiwiY29ubmVjdCIsImJpbmRfcmVzdWx0IiwiYmluZF9yaHMiLCJiaW5kX3Jlc3VsdCQwIiwiaXZhciIsImJpbmRfcmhzX2NvbnRlbnRzIiwiaXZhciQwIiwibGFzdDEiLCJsYXN0MiIsImhhbmRsZXIxIiwiZXhlY3V0aW9uX2NvbnRleHQyJDAiLCJydW4yJDAiLCJoYW5kbGVyMSQwIiwidiQwIiwib2ZfaXZhciIsImludmFyaWFudF9hIiwicmV0dXJuJDAiLCJpc19kZXRlcm1pbmVkIiwiYmluZCIsImgiLCJyZWFkIiwiZmlsbF9pZl9lbXB0eSIsInRvX2JpbmFibGUiLCJvZl9iaW5hYmxlIiwic2V4cF9vZl9ob3ciLCJ2XzAwMSIsIm5ldmVyIiwibWFwIiwicmV0dXJuJDEiLCJyZXR1cm4kMiIsInJldHVybiQzIiwidW5pdCIsImJvdGgkMCIsImExIiwiYTIiLCJkb25fdF93YWl0X2ZvciIsIm1hcCQyIiwiZjIiLCJmMSIsInByb2Nlc3MiLCJyZXN0IiwiY2hvaWNlIiwiZW5hYmxlZCIsImNob2ljZXMiLCJ1bnJlZ2lzdGVycyIsInJlYWR5IiwiY2hvb3NlX3Jlc3VsdCIsImNob2ljZXMkMCIsImNob2ljZXMkMSIsImdlbmVyaWNfY2hvb3NlIiwidW5yZWdpc3RlcnMkMCIsImNob29zZTIiLCJmYSIsImIiLCJmYiIsImFfaGFuZGxlciIsImJfaGFuZGxlciIsImF2IiwiY2hvb3NlIiwiYW55X2YiLCJ0cyIsImFueSIsImFueV91bml0IiwiZm9yJDAiLCJkbyQwIiwibG9vcCIsInJlcGVhdF91bnRpbF9maW5pc2hlZCIsInN0YXRlIiwiZmluaXNoZWQiLCJmb3JldmVyIiwiZm9sZCIsImluaXQiLCJ4cyIsInNlcW1hcCIsImJzIiwiZHMiLCJhbGxfdW5pdCIsImQiLCJvayIsIm9mX2FfMDA1IiwieF8wMDYiLCJhcmcwXzAwMiIsInJlczBfMDAzIiwieF8wMDciLCJmaWxsIiwiY29sbGVjdCIsImlzX2Nsb3NlZCIsImNsb3NlX2V4biIsImNsb3NlX2lmX29wZW4iLCJleHRlbmQiLCJkZWZlcnJlZDAiLCJkZWZlcnJlZDEiLCJ0cnlfd2l0aCIsImVycm9yIiwiZGV0YWNoIiwiZGV0YWNoX2FuZF9pdGVyX2Vycm9ycyIsImhhbmRsZXJfc3RhdGVfcmVmIiwicnVuX2YiLCJiYWdfZWx0IiwiaW5uZXJfZXhuJDAiLCJpbm5lcl9leG4iLCJkZXRhY2hfYW5kX2dldF9lcnJvcl9zdHJlYW0iLCJ0YWlsIiwiZ2V0X25leHRfZXJyb3IiLCJkZXRhY2hfYW5kX2dldF9uZXh0X2Vycm9yIiwiZXh0cmFjdF9leG4iLCJjb2x1bW4iLCJtb25pdG9yJDEiLCJuYW1lJDEiLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwic3RyaXBfcHJlZml4ZXMiLCJsaW5lcyIsInByZWZpeGVzIiwibGluZSIsInByZWZpeCIsInN1ZmZpeGVzIiwiaW5wdXQiLCJyZXZfaW5wdXQiLCJyZXZfb3V0cHV0IiwiYmFja3RyYWNlJDIiLCJsaXN0X2lmX25vdF9lbXB0eSIsIm1hdGNoJDEiLCJtYXRjaCQyIiwiZXh0cmFjdF9leG4kMCIsImFyZzFfMDA0IiwiYXJnMF8wMDMiLCJhcmcxXzAwOCIsImFyZzBfMDA3IiwicmVzMF8wMDkiLCJyZXMxXzAxMCIsIndpdGhpbl9jb250ZXh0IiwiY29udGV4dCIsIndpdGhpbl9nZW4iLCJ3aXRoaW4iLCJ3aXRoaW5fdiIsIndpdGhpbiQwIiwic2NoZWR1bGVfd2l0aF9kYXRhIiwid29yayIsInVwb25fd29ya19maWxsX2kiLCJzY2hlZHVsZSQwIiwicHJlc2VydmVfZXhlY3V0aW9uX2NvbnRleHQiLCJwcmVzZXJ2ZV9leGVjdXRpb25fY29udGV4dCQwIiwiY2FsbF9hbmRfZmlsbCIsInN0cmVhbV9pdGVyIiwic3RyZWFtIiwiZXhucyIsImZpbGxfcmVzdWx0X2FuZF9oYW5kbGVfYmFja2dybyIsInJlc3VsdF9maWxsZXIiLCJoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHQiLCJ0cnlfd2l0aF9sb2dfZXhuIiwidHJ5X3dpdGgkMCIsInN0aCQwIiwiZG9fZXh0cmFjdF9leG4iLCJzdGgkMSIsInN0aCQyIiwiaGFuZGxlX2V4biIsInJlcyIsInRyeV93aXRoX29yX2Vycm9yIiwidHJ5X3dpdGhfam9pbl9vcl9lcnJvciIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJmciIsInIkMCIsImZpbmFsbHlfZXhuIiwiaGFuZGxlX2Vycm9ycyIsImNhdGNoX3N0cmVhbSIsImNhdGNoJDAiLCJjYXRjaF9lcnJvciIsImRlcHRoIiwibiQwIiwiZmlyc3RfZXhuIiwiZm9sZCQwIiwibG9vcCQwIiwibG9vcF9uZXh0IiwibG9vcF9uZXh0JDAiLCJjbG9zZWQiLCJ1bmZvbGQiLCJjb3B5X3RvX3RhaWwiLCJhcHBlbmQiLCJmaWx0ZXJfZGVwcmVjYXRlZCIsImZpbHRlcl9tYXBfZGVwcmVjYXRlZCIsIm1hcCQwIiwiZmlyc3RfbiIsImF2YWlsYWJsZV9ub3ciLCJzcGxpdCIsInN0b3AiLCJyZWFzb25fZm9yX3N0b3BwaW5nIiwiZmluaXNoIiwibyIsImZpbmQiLCJmb3VuZCIsInVuZ3JvdXAiLCJpbnRlcmxlYXZlIiwibnVtX29wZW4iLCJjbG9zZSIsIm91dGVyX2Nsb3NlZCIsInRha2VfdW50aWwiLCJ6IiwiaXRlcl9kdXJhYmx5IiwiaXRlcl9kdXJhYmx5X3JlcG9ydF9lbmQiLCJpdGVyX2R1cmFibHkkMCIsIm9mX2Z1biIsInNldF9pdmFyIiwiaGFzX2FueV93YWl0ZXJzIiwic2V0X2hhc19hbnlfd2FpdGVycyIsImhhc19hbnlfd2FpdGVycyQwIiwicmVwciIsIml2YXJfZnVuIiwiaGFzX2FueV93YWl0ZXJzX2Z1biIsIm9mX2FfMDAxIiwiaGFzX2FueV93YWl0ZXJzXzAwMyIsIml2YXJfMDA1IiwiYXJnXzAwNiIsImJuZHNfMDAyIiwiYXJnXzAwNCIsImJuZHNfMDAyJDAiLCJicm9hZGNhc3QiLCJ3YWl0IiwiaGFzX2FueV93YWl0ZXJzJDEiLCJ4XzAwMyIsImJpbmRfdW5pdCIsIndhaXRfZm9yIiwicnVuX3F1ZXVlZF9hbGFybXMiLCJ3YWxrX2FsYXJtcyIsImFkdmFuY2VfdG8iLCJuZXh0X2FsYXJtX2ZpcmVzX2F0JDAiLCJxdWV1ZWRfYWxhcm1zX3JhbiIsInNwYW5fdG9fdGltZSIsInJ1bl9hdF9pbnRlcm5hbCIsInRpbWUiLCJyZW1vdmVfYWxhcm0iLCJvZl9hXzAwNyIsIm9mX2hfMDA4IiwiYXJnMF8wMDkiLCJyZXMwXzAxMCIsImFyZzBfMDExIiwicmVzMF8wMTIiLCJzZXRfc2NoZWR1bGVkX2F0IiwibnVtX2ZpcmVzX3RvX3NraXAiLCJzZXRfbnVtX2ZpcmVzX3RvX3NraXAiLCJmaXJlZCIsInNjaGVkdWxlZF9hdCQwIiwibnVtX2ZpcmVzX3RvX3NraXAkMCIsImZpcmVkJDAiLCJvZl9hXzAxNSIsIm9mX2hfMDE2IiwiYWxhcm1fMDE4IiwiZmlyZWRfMDIyIiwibnVtX2ZpcmVzX3RvX3NraXBfMDI0Iiwic2NoZWR1bGVkX2F0XzAyNiIsInRpbWVfc291cmNlXzAyOCIsImFyZ18wMjkiLCJibmRzXzAxNyIsImFyZ18wMjciLCJibmRzXzAxNyQwIiwiYXJnXzAyNSIsImJuZHNfMDE3JDEiLCJhcmdfMDIzIiwiYm5kc18wMTckMiIsImFyZ18wMjEiLCJibmRzXzAxNyQzIiwiYXJnXzAxOSIsImJuZHNfMDE3JDQiLCJzZXhwX29mX3RfdW5pdCIsInhfMDMwIiwiZmlyZWQkMSIsImludmFyaWFudF9oIiwic2NoZWR1bGVkX2F0X2Z1biIsImFfMDMyIiwiYl8wMzMiLCJudW1fZmlyZXNfdG9fc2tpcF9mdW4iLCJmaXJlZF9mdW4iLCJ4XzAzMSIsIm9mX2FfMDM0Iiwib2ZfaF8wMzUiLCJhcmcwXzAzNiIsInJlczBfMDM3IiwiYXJnMF8wMzgiLCJyZXMwXzAzOSIsImFyZzBfMDQwIiwicmVzMF8wNDEiLCJvZl9hXzA0NCIsIm9mX2hfMDQ1IiwiYXJnMF8wNDYiLCJyZXMwXzA0NyIsImFyZzBfMDQ4IiwicmVzMF8wNDkiLCJ4XzA1MiIsImEkMCIsIm9mX2FfMDUzIiwib2ZfaF8wNTQiLCJhcmcwXzA1NSIsInJlczBfMDU2IiwiYXJnMF8wNTciLCJyZXMwXzA1OCIsImFyZzFfMDYyIiwiYXJnMF8wNjEiLCJyZXMwXzA2MyIsInJlczFfMDY0IiwiaXNfaW5fdGltaW5nX3doZWVsIiwiYW1fdHJ5aW5nX3RvX3Jlc2NoZWR1bGVfaW5fdGhlIiwicnVuX2F0JDAiLCJydW5fYWZ0ZXIkMCIsImF0X3RpbWVzIiwibmV4dF90aW1lIiwiYXRfdmFyeWluZ19pbnRlcnZhbHMiLCJjb21wdXRlX3NwYW4iLCJzdGFydCQwIiwiaW1tZWRpYXRlbHkiLCJydW5fcmVwZWF0ZWRseSIsImNvbnRpbnVlX29uX2Vycm9yIiwic3RvcCQwIiwic3RvcCQxIiwiY29udGludWVfdHJ5X3dpdGgiLCJjb250aW51ZV9mIiwiYmFzZSIsIm9yX2Vycm9yIiwiZXZlcnkiLCJldmVyeSQwIiwic3RhcnQkMSIsInJ1bl9hdF9pbnRlcnZhbHMkMCIsIndpdGhfdGltZW91dCIsInRpbWVvdXQiLCJ3aXRoX3RpbWVvdXRfZXhuIiwib2Zfc3luY2hyb25vdXMiLCJ0b19zeW5jaHJvbm91cyIsImFkdmFuY2VfZGlyZWN0bHlfaWZfcXVpZXNjZW50IiwiaXNfcXVlc2NlbnQiLCJ3aGVlbCIsIm5leHRfYWxhcm0iLCJoYXNfdXBjb21pbmdfZXZlbnQiLCJuZXh0X3VwY29taW5nX2V2ZW50IiwibmV4dF91cGNvbWluZ19ldmVudF9leG4iLCJldmVudF9wcmVjaXNpb24iLCJhZGRfZXZlcnlfY3ljbGVfc3RhcnRfaG9vayIsImhhbmRsZSIsImFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayIsInJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayIsImFyciIsImciLCJpZHgiLCJhcnIkMCIsInJlbW92ZV9ldmVyeV9jeWNsZV9zdGFydF9ob29rXyIsInJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leCIsIm1hcF9jeWNsZV90aW1lcyIsImxvbmdfY3ljbGVzIiwiYXRfbGVhc3QiLCJjeWNsZV9udW1fam9icyIsImludCQwIiwidGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qIiwiY3JlYXRlX2FsYXJtIiwiYWRkX2ZpbmFsaXplciIsImhlYXBfYmxvY2siLCJmaW5hbGl6ZXIiLCJhZGRfZmluYWxpemVyX2V4biIsImFkZF9maW5hbGl6ZXJfbGFzdCIsImFkZF9maW5hbGl6ZXJfbGFzdF9leG4iLCJmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZCIsInJ1bl9jeWNsZSIsIm51bV9qb2JzX3J1bl9hdF9zdGFydF9vZl9jeWNsZSIsImN5Y2xlX3RpbWUiLCJyZXMxXzAwNCIsInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haSIsIm1ha2VfYXN5bmNfdW51c2FibGUiLCJyZXNldF9pbl9mb3JrZWRfcHJvY2VzcyIsInJlY29yZGluZ19iYWNrdHJhY2VzIiwibWF5X3JldHVybl9pbW1lZGlhdGVseSIsInlpZWxkX2V2ZXJ5IiwiY291bnRfdW50aWxfeWllbGQiLCJ0aGlzX2N5Y2xlX3RpbWUiLCJudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nIiwieWllbGRfdGhlbl9ydW4iLCJ3b3JrZXIiLCJudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nJDAiLCJudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nJDEiLCJidCIsImVucXVldWUkMCIsInF1ZXVlIiwicnVubmluZyIsImV4ZWNfY3R4Iiwic2VtYXBob3JlIiwiYXBwbHkiLCJ0X2YiLCJkZiIsImR2IiwibWF4X2NvbmN1cnJlbnRfam9icyIsIndhaXRlciIsImFib3J0ZWQiLCJwYXJlbnRfbW9uaXRvciIsImVyciIsIm9mX3RodW5rIiwidGh1bmsiLCJzeW1ib2wkMSIsImQxIiwiZDIiLCJvZl9hXzAwMiIsInJlczBfMDA0IiwibGVuZ3RoXzAwNiIsImJuZHNfMDA1IiwibGlzdCIsImNyZWF0ZV9jb3VudGVyIiwicHVzaCIsInBvcF9leG4iLCJzZXhwX29mX291dGNvbWUiLCJ2XzAwMiIsInZfMDAzIiwiY2xlYW5lZCIsIm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQiLCJzZXRfbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCIsImNhcGFjaXR5X2F2YWlsYWJsZSIsInNldF9jYXBhY2l0eV9hdmFpbGFibGUiLCJudW1fam9ic19ydW5uaW5nIiwic2V0X251bV9qb2JzX3J1bm5pbmciLCJqb2JzX3dhaXRpbmdfdG9fc3RhcnQiLCJqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UiLCJjbGVhbmVkJDAiLCJudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkJDAiLCJjYXBhY2l0eV9hdmFpbGFibGUkMCIsIm51bV9qb2JzX3J1bm5pbmckMCIsImpvYnNfd2FpdGluZ190b19zdGFydCQwIiwiam9iX3Jlc291cmNlc19ub3RfaW5fdXNlJDAiLCJtYXhfY29uY3VycmVudF9qb2JzJDAiLCJvZl9hXzAxMSIsImpvYnNfd2FpdGluZ190b19zdGFydF8wMjIiLCJqb2JfcmVzb3VyY2VzX25vdF9pbl91c2VfMDIwIiwibWF4X2NvbmN1cnJlbnRfam9ic18wMTgiLCJyZXN0XzAxNSIsImNvbnRpbnVlX29uX2Vycm9yXzAxMyIsIm51bV9qb2JzX3J1bm5pbmdfMDI0IiwiY2FwYWNpdHlfYXZhaWxhYmxlXzAyNiIsImlzX2RlYWRfMDI4IiwiY2xlYW5zXzAzMCIsIm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWRfMDMyIiwiY2xlYW5lZF8wMzQiLCJhcmdfMDM1IiwiYm5kc18wMTIiLCJhcmdfMDMzIiwiYm5kc18wMTIkMCIsImFyZ18wMzEiLCJibmRzXzAxMiQxIiwiYm5kc18wMTIkMiIsImJuZHNfMDEyJDMiLCJibmRzXzAxMiQ0Iiwib3V0Y29tZV8wMDkiLCJzdGFydF8wMDYiLCJibmRzXzAwNSQwIiwidl8wMDgiLCJibmRzXzAwNSQxIiwiYm5kc18wMTIkNSIsImJuZHNfMDEyJDYiLCJibmRzXzAxMiQ3IiwiYm5kc18wMTIkOCIsImJuZHNfMDEyJDkiLCJ4XzAzNiIsIm9mX2FfMDM3Iiwib2Zfa2luZF8wMzgiLCJ4XzAzOSIsIm51bV9qb2JzX3dhaXRpbmdfdG9fc3RhcnQiLCJjbGVhbl9yZXNvdXJjZSIsImtpbGwiLCJhdF9raWxsIiwiY2xlYW5lZCQxIiwic3RhcnRfam9iIiwiam9iX3Jlc291cmNlIiwiam9iX3Jlc291cmNlcyIsImNyZWF0ZV93aXRoIiwiY3JlYXRlX3dpdGgkMCIsImVucXVldWVfaW50ZXJuYWwiLCJvdXRjb21lIiwiaW50ZXJuYWxfam9iIiwiaGFuZGxlX2VucXVldWVfcmVzdWx0IiwiZW5xdWV1ZV9mcm9udCIsImVucXVldWVfZnJvbnQkMCIsImVucXVldWVfZXhjbHVzaXZlIiwiZG9uZSIsImZfcGxhY2Vob2xkZXIiLCJzbG90IiwibW9uYWRfc2VxdWVuY2VfaG93IiwiaG93IiwibW9uYWRfc2VxdWVuY2VfaG93MiIsInByaW9yX2pvYnNfZG9uZSIsImFsbF9kdW1teV9qb2JzX3J1bm5pbmciLCJkdW1teV9qb2JzX3J1bm5pbmciLCJjYXBhY2l0eV9hdmFpbGFibGUkMSIsInRocmVhZF9zYWZlX2VucXVldWVfam9iIiwiY3ljbGVfc3RhcnRfbnMiLCJjeWNsZV90aW1lc19ucyIsImN5Y2xlX3RpbWVzIiwiZXZlbnRfcHJlY2lzaW9uX25zIiwiYm9vbCIsInNldF9leGVjdXRpb25fY29udGV4dCQwIiwiYWRkX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2skMCIsImFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayQwIiwicmVtb3ZlX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2tfJDAiLCJyZW1vdmVfZXZlcnlfY3ljbGVfZW5kX2hvb2tfZXgkMCIsIndpdGhfZXhlY3V0aW9uX2NvbnRleHQkMCIsIndpdGhfZXhlY3V0aW9uX2NvbnRleHQxJDAiLCJjb21wYXJlIiwiY21wX2EiLCJhXzAwMSIsImJfMDAyIiwicmlnaHRfMDA0IiwibGVmdF8wMDMiLCJ2XzAwNiIsImZvbGRpIiwic2VxbWFwaSIsIm91dHB1dCIsIm91dHB1dCQwIiwiaXRlcmkiLCJtYXBpIiwiZmlsdGVyaSIsImJvb2xzIiwiZmlsdGVyX21hcGkiLCJjb25jYXRfbWFwaSIsImZpbmRfbWFwaSIsImF1eCIsImZpbmRpIiwiZWx0IiwiZXhpc3RzaSIsImZvcl9hbGxpIiwiZmlsdGVyX21hcCIsImZpbHRlciIsImNvbmNhdF9tYXAiLCJmaW5kX21hcCIsImV4aXN0cyIsImZvcl9hbGwiLCJqb2JfY291bnQiLCJnZW5fY29tcHV0YXRpb24iLCJ5cyIsInRsIiwiaGQiLCJjaGFuZ2UiLCJ1cGRhdGUiLCJpdGVyX2tleXMiLCJhbGlzdCIsImFsaXN0X2luX2luY3JlYXNpbmdfa2V5X29yZGVyIiwiZm9sZF9yaWdodCIsImFsaXN0X2luX2RlY3JlYXNpbmdfa2V5X29yZGVyIiwiY29tcHV0YXRpb24iLCJqb2JfbWFwIiwic2VxdWVuY2UiLCJmaWx0ZXJfa2V5cyIsIm1lcmdlIiwicmVyYWlzZSIsImdlbmVyYWwiLCJoYXNoYWJsZSIsImdlbmVyYWwkMCIsInJlY3Vyc2l2ZSIsImZfb25lc3RlcCIsIm1lbW9pemVkIiwiY29tYmluZSIsImZhaWwiLCJmYWlsZiIsImZvcm1hdCIsIm1hcF9lcnJvciIsImlnbm9yZV9tIiwiam9pbiIsInN5bWJvbF9iaW5kIiwiZTEiLCJlMiIsInN5bWJvbF9iaW5kJDAiLCJzeW1ib2xfbWFwJDAiLCJva19leG4iLCJvZl9leG4iLCJvZl9leG5fcmVzdWx0IiwibXNnIiwic2V4cF9vZiIsImVycm9yX3MiLCJlcnJvcl9zdHJpbmciLCJlcnJvcmYiLCJ0YWciLCJ0YWdfcyIsInRhZ19zX2xhenkiLCJ0YWdfYXJnIiwidW5pbXBsZW1lbnRlZCIsImNvbWJpbmVfZXJyb3JzIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImZpbHRlcl9va19hdF9sZWFzdF9vbmUiLCJmaW5kX21hcF9vayIsImN1cnJlbnRfZXJyb3IiLCJlcnJvcnMkMCIsIm9rX3VuaXQiLCJ0cnlfd2l0aF9qb2luIiwibWFwJDEiLCJzdGF0ZSQwIiwiZm9sZF9tYXBpIiwibWFwaV9mIiwiZm9sZF9mIiwidGhyb3R0bGUiLCJjIiwic3RhdGUkMiIsInN0YXRlJDEiLCJjJDEiLCJjJDAiLCJpJDAiLCJhY2N1bSIsIm1heWJlX3YiLCJjb3VudCIsInN1bSIsIk0iLCJzaG93X2RlYnVnX21lc3NhZ2VzIiwiY2hlY2tfaW52YXJpYW50IiwieF8wMDQiLCJ2YWx1ZXNfcmVhZCIsInNldF92YWx1ZXNfcmVhZCIsInZhbHVlc19yZWFkJDAiLCJwaXBlX2lkXzAwOSIsInZhbHVlc19yZWFkXzAxMSIsImJuZHNfMDA4IiwiYm5kc18wMDgkMCIsInZfMDEzIiwiYm5kc18wMDgkMSIsImJuZHNfMDA4JDIiLCJ2YWx1ZXNfc2VudF9kb3duc3RyZWFtIiwidmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1Iiwid2hlbl9zZW50X2Rvd25zdHJlYW0iLCJjb25zdW1lciIsIndhbnRzIiwiY29uc3VtZXIkMCIsIndhbnRzJDAiLCJvZl9hXzAyOSIsImNvbnN1bWVyXzAzMyIsIndhbnRzXzAzMSIsImJuZHNfMDMwIiwiYXJnMF8wMTgiLCJyZXMwXzAxOSIsImFyZzBfMDIxIiwidl8wMjAiLCJyZXMwXzAyMiIsImFyZzFfMDI1IiwiYXJnMF8wMjQiLCJyZXMwXzAyNiIsInZfMDIzIiwicmVzMV8wMjciLCJibmRzXzAzMCQwIiwiZmlsbF93aXRoX2VvZiIsImkkMSIsImZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQiLCJyZWFkeV8wMzkiLCJmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkXzAzNyIsImJuZHNfMDM2IiwiYm5kc18wMzYkMCIsImJuZHNfMDM2JDEiLCJjb25zdW1lcnMiLCJzZXRfY29uc3VtZXJzIiwiYmxvY2tlZF9yZWFkcyIsImJsb2NrZWRfZmx1c2hlcyIsIm51bV92YWx1ZXNfcmVhZCIsInB1c2hiYWNrIiwic2V0X3B1c2hiYWNrIiwicmVzZXJ2ZWRfc3BhY2UiLCJzZXRfcmVzZXJ2ZWRfc3BhY2UiLCJzaXplX2J1ZGdldCIsInNldF9zaXplX2J1ZGdldCIsImNvbnN1bWVycyQwIiwiYmxvY2tlZF9yZWFkcyQwIiwiYmxvY2tlZF9mbHVzaGVzJDAiLCJwdXNoYmFjayQwIiwicmVzZXJ2ZWRfc3BhY2UkMCIsInNpemVfYnVkZ2V0JDAiLCJzZXhwX29mX3BpcGUiLCJvZl9hXzA0MSIsIm9mX3BoYW50b21fMDQyIiwiaWRfMDQ0IiwiaW5mb18wNDYiLCJidWZmZXJfMDUwIiwic2l6ZV9idWRnZXRfMDUyIiwicmVzZXJ2ZWRfc3BhY2VfMDU0IiwicHVzaGJhY2tfMDU2IiwibnVtX3ZhbHVlc19yZWFkXzA1OCIsInJlYWRfY2xvc2VkXzA2NiIsImNsb3NlZF8wNjQiLCJibG9ja2VkX3JlYWRzXzA2MiIsImJsb2NrZWRfZmx1c2hlc18wNjAiLCJjb25zdW1lcnNfMDY4IiwidXBzdHJlYW1fZmx1c2hlZHNfMDcwIiwiYm5kc18wNDMiLCJhcmdfMDcxIiwiYm5kc18wNDMkMCIsImFyZ18wNjkiLCJibmRzXzA0MyQxIiwiYXJnXzA2NyIsImJuZHNfMDQzJDIiLCJhcmdfMDY1IiwiYm5kc18wNDMkMyIsImFyZ18wNjMiLCJibmRzXzA0MyQ0IiwiYXJnXzA2MSIsImJuZHNfMDQzJDUiLCJhcmdfMDU5IiwiYm5kc18wNDMkNiIsImFyZ18wNTciLCJibmRzXzA0MyQ3IiwiYXJnXzA1NSIsImJuZHNfMDQzJDgiLCJhcmdfMDUzIiwiYm5kc18wNDMkOSIsImFyZ18wNTEiLCJibmRzXzA0MyQxMCIsInZfMDQ3IiwiYXJnXzA0OSIsImJuZF8wNDgiLCJibmRzXzA0MyQxMSIsImFyZ18wNDUiLCJibmRzXzA0MyQxMiIsImVmZmVjdGl2ZV9zaXplX2J1ZGdldCIsImhhc2giLCJpc19yZWFkX2Nsb3NlZCIsInB1c2hiYWNrJDEiLCJudW1fdmFsdWVzX3dyaXR0ZW4iLCJ1cGRhdGVfbnVtX3ZhbHVlc19yZWFkIiwiZGVsdGEiLCJ4XzA3NSIsInhfMDM1Iiwic2V4cF9vZl9waGFudG9tIiwib2ZfYV8wNzYiLCJ4XzA3NyIsInNleHBfb2ZfcGhhbnRvbSQwIiwib2ZfYV8wNzgiLCJ4XzA3OSIsImlkX3JlZiIsImluaXRpYWxfYnVmZmVyIiwidmFsaWRhdGVfc2l6ZV9idWRnZXQiLCJ1cGRhdGVfcHVzaGJhY2siLCJ4XzA4MCIsImNsb3NlX3JlYWQiLCJ4XzA4MSIsImZsdXNoIiwiY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjIiwidyIsImNyZWF0ZV9yZWFkZXIiLCJjbG9zZV9vbl9leGNlcHRpb24iLCJjcmVhdGVfd3JpdGVyIiwiY29uc3VtZWRfdmFsdWVzX3NlbnRfZG93bnN0cmVhIiwidmFsdWVzX3dlcmVfcmVhZCIsInZhbHVlc19mbHVzaGVkIiwiZmx1c2hfcmVzdWx0IiwiY29uc3VtZV9vbmUiLCJjb25zdW1lIiwibWF4X3F1ZXVlX2xlbmd0aCIsInJlc3VsdCQwIiwic2V0X3NpemVfYnVkZ2V0JDAiLCJyZXNlcnZlX3NwYWNlIiwiZGVjcmVhc2VfcmVzZXJ2ZWRfc3BhY2UiLCJzdGFydF93cml0ZSIsInhfMDgzIiwic2l6ZSIsInhfMDgyIiwiZmluaXNoX3dyaXRlIiwiYmxvY2tlZF9yZWFkIiwiaXZhciQxIiwidHJhbnNmZXJfaW5fd2l0aG91dF9wdXNoYmFjayIsInRyYW5zZmVyX2luIiwid3JpdGUiLCJ3cml0ZV93aXRob3V0X3B1c2hiYWNrIiwid3JpdGUkMCIsIndyaXRlX3doZW5fcmVhZHkiLCJ3cml0ZV9pZl9vcGVuIiwid3JpdGVfd2l0aG91dF9wdXNoYmFja19pZl9vcGVuIiwiZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMiLCJ4XzA4NSIsInN0YXJ0X3JlYWQiLCJsYWJlbCIsInhfMDg2IiwiZ2VuX3JlYWRfbm93IiwiZ2V0X21heF9xdWV1ZV9sZW5ndGgiLCJtYXhfcXVldWVfbGVuZ3RoJDAiLCJyZWFkX25vdyIsInJlYWRfbm93JDAiLCJyZWFkX25vd19leG4iLCJyZWFkJDAiLCJyZWFkX2V4biIsInZhbHVlc19hdmFpbGFibGUiLCJyZWFkX2Nob2ljZSIsInJlYWRfY2hvaWNlX3NpbmdsZV9jb25zdW1lcl9leCIsInJlYWRfZXhhY3RseSIsIm51bV92YWx1ZXMiLCJhbHJlYWR5X3JlYWQiLCJkb3duc3RyZWFtX2ZsdXNoZWQiLCJ1cHN0cmVhbV9mbHVzaGVkIiwiYWRkX2NvbnN1bWVyIiwicGlwZV9pZCIsImNvbnN1bWVyJDEiLCJ1cHN0cmVhbSIsImRvd25zdHJlYW0iLCJ1cHN0cmVhbV9mbHVzaGVkJDAiLCJhcmcwXzA4NyIsInJlczBfMDg4IiwiZm9sZF9nZW4iLCJmbHVzaGVkIiwiZm9sZF93aXRob3V0X3B1c2hiYWNrIiwid2l0aF9lcnJvcl90b19jdXJyZW50X21vbml0b3IiLCJpdGVyX3dpdGhvdXRfcHVzaGJhY2siLCJtYXhfaXRlcmF0aW9uc19wZXJfam9iIiwibWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiQwIiwibWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiQxIiwicmVtYWluaW5nIiwicmVtYWluaW5nJDAiLCJkcmFpbiIsImRyYWluX2FuZF9jb3VudCIsInJlYWRfYWxsIiwidG9fc3RyZWFtX2RlcHJlY2F0ZWQiLCJvZl9zdHJlYW1fZGVwcmVjYXRlZCIsInRyYW5zZmVyIiwibmV4dF9kZWZlcnJlZCIsImNoZWNrX2Nsb3NlZF9sb29wX25leHQiLCJ0cmFuc2Zlcl9nZW4iLCJsaW5rIiwidW5saW5rIiwiaW5wdXRfYXZhaWxhYmxlX29yX291dHB1dF9jbG9zIiwib3V0cHV0X2Nsb3NlZCIsInRyYW5zZmVyJDAiLCJ0cmFuc2Zlcl9pZCIsIm1hcF9nZW4iLCJjb25jYXRfbWFwX2xpc3QiLCJmaWx0ZXJfbWFwJDAiLCJmb2xkaW5nX2ZpbHRlcl9tYXAiLCJmb2xkaW5nX2ZpbHRlcl9tYXAkMCIsIngkMCIsImZvbGRpbmdfbWFwIiwiYWNjdW0kMCIsIm9mX3F1ZXVlX2ludGVybmFsIiwib2ZfcXVldWUiLCJlbXB0eSIsInNpbmdsZXRvbiIsIndyaXRlciIsInJlYWRlciIsInN5bWJvbCIsIm9mX3NlcXVlbmNlIiwic2VxdWVuY2UkMSIsInNlcXVlbmNlJDAiLCJ0b19zZXF1ZW5jZSIsImludGVybGVhdmVfcGlwZSIsImlucHV0cyIsImNsb3NlX29uIiwib3V0cHV0X3dyaXRlciIsIm51bV9waXBlc19yZW1haW5pbmciLCJjbG9zZV9vbmVfcGlwZSIsImNsb3NlZF9waXBlX2tpbmQiLCJzaG91bGRfY2xvc2UiLCJoZWFwIiwiaGFuZGxlX3JlYWQiLCJlb2Zfb3Jfb2siLCJwb3BfaGVhcF9hbmRfbG9vcCIsImluaXRpYWxfcHVzaCIsImNvbmNhdF9waXBlIiwiZm9yayIsInB1c2hiYWNrX3VzZXMiLCJ3cml0ZXIwIiwicmVhZGVyMCIsIndyaXRlcjEiLCJyZWFkZXIxIiwic29tZV9yZWFkZXJfd2FzX2Nsb3NlZCIsInNvbWVfcmVhZGVyX3dhc19jbG9zZWQkMCIsInN0aWxsX29wZW4iLCJmaWx0ZXJfb3BlbiIsInN0aWxsX29wZW4kMCIsInNldF9pbmZvIiwidmFsdWVfYXZhaWxhYmxlIiwic2V0X3ZhbHVlX2F2YWlsYWJsZSIsInRha2VuIiwiY3VycmVudF92YWx1ZSIsInZhbHVlX2F2YWlsYWJsZSQwIiwidGFrZW4kMCIsImN1cnJlbnRfdmFsdWUkMCIsInZhbHVlX2F2YWlsYWJsZSQxIiwidmFsdWVfYXZhaWxhYmxlX2Z1biIsImFfMDExIiwiYl8wMTIiLCJ0YWtlbl9mdW4iLCJjdXJyZW50X3ZhbHVlX2Z1biIsInhfMDEwIiwidGFrZW5fMDA2IiwiY3VycmVudF92YWx1ZV8wMDQiLCJ2YWx1ZV9hdmFpbGFibGVfMDA4IiwiYm5kc18wMDMiLCJibmRzXzAwMyQwIiwiYm5kc18wMDMkMSIsInBlZWtfZXhuIiwieF8wMTMiLCJvZl9hXzAxNCIsInhfMDE1Iiwib2ZfYV8wMTYiLCJ4XzAxNyIsIndyaXRlX29ubHkiLCJ0YWtlX25vbmVtcHR5IiwidGFrZV9ub3dfZXhuIiwidGFrZV9ub3ciLCJ0YWtlIiwidXBkYXRlX2V4biIsInRha2VuJDEiLCJwdXQiLCJwaXBlX3doZW5fcmVhZHkiLCJyZXN0X2V4biIsImNyZWF0ZV9vcl9lcnJvciIsIndhaXRfZXhuIiwiZm9yY2UiLCJmb3JjZV9leG4iLCJiaW5kJDEiLCJpc19mb3JjZWQiLCJ3YWl0c18wMDMiLCJzaWduYWwiLCJkZWxldGUkMCIsImNoZWNrX2ZpZWxkJDAiLCJ3YWl0X2Zvcl9wcmV2aW91cyIsInN5bWJvbCQwIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2tlcm5lbF9fLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL3RpbWVfbnMubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvZGVidWcubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvaW1wb3J0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL3ByaW9yaXR5Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL3R5cGVzLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL21vbml0b3IwLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2V4ZWN1dGlvbl9jb250ZXh0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2V4dGVybmFsX2pvYi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9qb2JfcG9vbC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9qb2IubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvam9iX29yX2V2ZW50Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL3NjaGVkdWxlcjAubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvam9iX3F1ZXVlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL3N5bmNocm9ub3VzX3RpbWVfc291cmNlMC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9zY2hlZHVsZXIxLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2l2YXIwLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkMC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9pdmFyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL21vbmFkX3NlcXVlbmNlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkMS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9zdGQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvaXZhcl9maWxsZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvdGFpbC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9tb25pdG9yLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2FzeW5jX3N0cmVhbS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9idmFyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL3RpbWVfc291cmNlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2N5Y2xlX2hvb2subWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvc2NoZWR1bGVyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL3Rocm90dGxlZC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9zdGFja19vcl9jb3VudGVyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL3Rocm90dGxlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL3N5bmNocm9ub3VzX3RpbWVfc291cmNlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2tlcm5lbF9zY2hlZHVsZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvY2xvY2tfaW50Zi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9jbG9ja19ucy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9hcnJheS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9saXN0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX21hcC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9tZW1vLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX29wdGlvbi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9yZXN1bHQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfb3JfZXJyb3IubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfcXVldWUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfc2VxdWVuY2UubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfc2V0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL3JlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2UubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvcGlwZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9tdmFyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2xhenlfZGVmZXJyZWQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9hc3luY19rZXJuZWwvYXN5bmNfY29uZGl0aW9uLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2djLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2ludmFyaWFudF9pbnRmLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2ludmFyaWFudC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2FzeW5jX2tlcm5lbC9hc3luY19rZXJuZWwubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FnTHdCOztJQUFBOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDektwQkEsTUFBTUMsR0FBRUM7SUFDRyxJQUFUQyxTQUFTLGdCQURMRixHQUFFQztJQUVzQjtNQUE3QixnQ0FGT0E7U0FFc0IscUJBRDVCQyxRQURJRjs7SUFFd0UsT0FENUVFO0dBQ2tGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FGcEZIOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNGQUksSUFJZUMsVUFBQUMsVUFKREM7SUFDaEI7S0FHaUJDLFdBQ3lCO0tBRHpCQyxXQUNSO0tBRFFDLHFDQUFBRDtLQUFBRSxnREFBQUg7S0FBQUksaUNBQUFQO0tBQUFRLHNCQUpETixXQUlDRDtLQURmO09BQUE7OztpQkFDZUksY0FBQUMsY0FBQUMsY0FBQUM7SUFEZixPQUFBO0dBRXFFO1lBR3JFQyxXQUFXQyxTQUFVLE9BUnJCWCxJQVFXVyx1QkFBeUM7Ozs7Ozs7Ozs7Ozs7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T0FJQXBxQzs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ0xBbkQ7SUFDQXdNO0lBQ0FvekI7SUFDQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BRkF4ekI7T0FEQXhNO09BRUE0L0I7T0FDQUk7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQ05zQjtJQUF0QnVSO0lBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBR0YsU0FBQXhHLFFBQUFFLE9BQUFDO0lBQUEsR0FBQUQsVUFBQUMsT0FBQTtn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QU16QjtNQUdnQztPQUZuQ3hiO3dEQUFBQTtPQUVtQyxNQUFBLDBCQVRQd2I7Ozs7Ozs7O01BSWhDLE9BQUUsV0FKVXZkLEdBSVYsMEJBSjhCdWQsT0FBdEIvbUI7S0FJVztLQUR2QjtZQUFBOzs7dURBSGdCc2tEOztHQVpQLGdCQUdUOXdDLGFBU0E2d0M7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUM0RVd4NEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW5CYTtJQXBDMUI5TDtJQUNBd007SUFDQTZwQjtJQUNBOUg7SUFDQWlCO0lBQ0F2QjtJQUNBMlI7SUFDQXBTO0lBQ0F2WTtJQUNBeWY7SUFDQWhEO0lBQ0E5RjtJQUNBb1U7SUFDQUU7SUFDQTlMO0lBQ0FFO0lBT0FvckI7SUFHQThFO0lBR0FqZ0I7Ozs7OztJQVEwQjs7Ozs7O0lBYW5CLElBTU0vMEIsU0FOTjtJQUNtQjtJQUNBO0lBQ0E7SUFDQTtJQUNuQjtLQUNNRixNQUROO0tBQ01DO0tBQUFFO0tBQUExTztLQUFBMEI7YUFBQWlOLFdBQUF3N0IsT0FBQUM7S0FBQSxPQUFBLHNCQUFBRCxPQUFBQztJQUFHOzs7TUFBSHIvQjtNQUFBeUQ7TUFBQUc7TUFBQWpOO01BQUExQjtNQUFBME87TUFBQUQ7TUFBQUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdkRidFA7T0FDQXdNO09BQ0E2cEI7T0FDQTlIO09BQ0FpQjtPQUNBdkI7T0FDQTJSO09BQ0FwUztPQUNBdlk7T0FDQXlmO09BQ0FoRDtPQUNBOUY7T0FDQW9VO09BQ0FFO09BQ0E5TDtPQUNBRTtPQU9Bb3JCO09BR0E4RTtPQUdBamdCOzs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkFzeW5jX2NvbmRpdGlvbiAqKVxubW9kdWxlIEFzeW5jX2NvbmRpdGlvbiA9IEFzeW5jX2tlcm5lbF9fQXN5bmNfY29uZGl0aW9uXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5Bc3luY19nYyAqKVxubW9kdWxlIEFzeW5jX2djID0gQXN5bmNfa2VybmVsX19Bc3luY19nY1xuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuQXN5bmNfaW52YXJpYW50ICopXG5tb2R1bGUgQXN5bmNfaW52YXJpYW50ID0gQXN5bmNfa2VybmVsX19Bc3luY19pbnZhcmlhbnRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkFzeW5jX2ludmFyaWFudF9pbnRmICopXG5tb2R1bGUgQXN5bmNfaW52YXJpYW50X2ludGYgPSBBc3luY19rZXJuZWxfX0FzeW5jX2ludmFyaWFudF9pbnRmXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5Bc3luY19rZXJuZWxfc2NoZWR1bGVyICopXG5tb2R1bGUgQXN5bmNfa2VybmVsX3NjaGVkdWxlciA9IEFzeW5jX2tlcm5lbF9fQXN5bmNfa2VybmVsX3NjaGVkdWxlclxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuQXN5bmNfc3RyZWFtICopXG5tb2R1bGUgQXN5bmNfc3RyZWFtID0gQXN5bmNfa2VybmVsX19Bc3luY19zdHJlYW1cblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkJ2YXIgKilcbm1vZHVsZSBCdmFyID0gQXN5bmNfa2VybmVsX19CdmFyXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5DbG9ja19pbnRmICopXG5tb2R1bGUgQ2xvY2tfaW50ZiA9IEFzeW5jX2tlcm5lbF9fQ2xvY2tfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuQ2xvY2tfbnMgKilcbm1vZHVsZSBDbG9ja19ucyA9IEFzeW5jX2tlcm5lbF9fQ2xvY2tfbnNcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkN5Y2xlX2hvb2sgKilcbm1vZHVsZSBDeWNsZV9ob29rID0gQXN5bmNfa2VybmVsX19DeWNsZV9ob29rXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWJ1ZyAqKVxubW9kdWxlIERlYnVnID0gQXN5bmNfa2VybmVsX19EZWJ1Z1xuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRGVmZXJyZWQgKilcbm1vZHVsZSBEZWZlcnJlZCA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlZmVycmVkMCAqKVxubW9kdWxlIERlZmVycmVkMCA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWQwXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWZlcnJlZDEgKilcbm1vZHVsZSBEZWZlcnJlZDEgPSBBc3luY19rZXJuZWxfX0RlZmVycmVkMVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRGVmZXJyZWRfYXJyYXkgKilcbm1vZHVsZSBEZWZlcnJlZF9hcnJheSA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfYXJyYXlcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlZmVycmVkX2xpc3QgKilcbm1vZHVsZSBEZWZlcnJlZF9saXN0ID0gQXN5bmNfa2VybmVsX19EZWZlcnJlZF9saXN0XG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWZlcnJlZF9tYXAgKilcbm1vZHVsZSBEZWZlcnJlZF9tYXAgPSBBc3luY19rZXJuZWxfX0RlZmVycmVkX21hcFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRGVmZXJyZWRfbWVtbyAqKVxubW9kdWxlIERlZmVycmVkX21lbW8gPSBBc3luY19rZXJuZWxfX0RlZmVycmVkX21lbW9cblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlZmVycmVkX21lbW9faW50ZiAqKVxubW9kdWxlIERlZmVycmVkX21lbW9faW50ZiA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfbWVtb19pbnRmXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWZlcnJlZF9vcHRpb24gKilcbm1vZHVsZSBEZWZlcnJlZF9vcHRpb24gPSBBc3luY19rZXJuZWxfX0RlZmVycmVkX29wdGlvblxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRGVmZXJyZWRfb3JfZXJyb3IgKilcbm1vZHVsZSBEZWZlcnJlZF9vcl9lcnJvciA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfb3JfZXJyb3JcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlZmVycmVkX3F1ZXVlICopXG5tb2R1bGUgRGVmZXJyZWRfcXVldWUgPSBBc3luY19rZXJuZWxfX0RlZmVycmVkX3F1ZXVlXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWZlcnJlZF9yZXN1bHQgKilcbm1vZHVsZSBEZWZlcnJlZF9yZXN1bHQgPSBBc3luY19rZXJuZWxfX0RlZmVycmVkX3Jlc3VsdFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRGVmZXJyZWRfc2VxdWVuY2UgKilcbm1vZHVsZSBEZWZlcnJlZF9zZXF1ZW5jZSA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfc2VxdWVuY2VcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlZmVycmVkX3NldCAqKVxubW9kdWxlIERlZmVycmVkX3NldCA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfc2V0XG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWZlcnJlZF9zdGQgKilcbm1vZHVsZSBEZWZlcnJlZF9zdGQgPSBBc3luY19rZXJuZWxfX0RlZmVycmVkX3N0ZFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRXhlY3V0aW9uX2NvbnRleHQgKilcbm1vZHVsZSBFeGVjdXRpb25fY29udGV4dCA9IEFzeW5jX2tlcm5lbF9fRXhlY3V0aW9uX2NvbnRleHRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkV4dGVybmFsX2pvYiAqKVxubW9kdWxlIEV4dGVybmFsX2pvYiA9IEFzeW5jX2tlcm5lbF9fRXh0ZXJuYWxfam9iXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5JbXBvcnQgKilcbm1vZHVsZSBJbXBvcnQgPSBBc3luY19rZXJuZWxfX0ltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuSXZhciAqKVxubW9kdWxlIEl2YXIgPSBBc3luY19rZXJuZWxfX0l2YXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkl2YXIwICopXG5tb2R1bGUgSXZhcjAgPSBBc3luY19rZXJuZWxfX0l2YXIwXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5JdmFyX2ZpbGxlciAqKVxubW9kdWxlIEl2YXJfZmlsbGVyID0gQXN5bmNfa2VybmVsX19JdmFyX2ZpbGxlclxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuSm9iICopXG5tb2R1bGUgSm9iID0gQXN5bmNfa2VybmVsX19Kb2JcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkpvYl9vcl9ldmVudCAqKVxubW9kdWxlIEpvYl9vcl9ldmVudCA9IEFzeW5jX2tlcm5lbF9fSm9iX29yX2V2ZW50XG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5Kb2Jfb3JfZXZlbnRfaW50ZiAqKVxubW9kdWxlIEpvYl9vcl9ldmVudF9pbnRmID0gQXN5bmNfa2VybmVsX19Kb2Jfb3JfZXZlbnRfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuSm9iX3Bvb2wgKilcbm1vZHVsZSBKb2JfcG9vbCA9IEFzeW5jX2tlcm5lbF9fSm9iX3Bvb2xcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkpvYl9xdWV1ZSAqKVxubW9kdWxlIEpvYl9xdWV1ZSA9IEFzeW5jX2tlcm5lbF9fSm9iX3F1ZXVlXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5MYXp5X2RlZmVycmVkICopXG5tb2R1bGUgTGF6eV9kZWZlcnJlZCA9IEFzeW5jX2tlcm5lbF9fTGF6eV9kZWZlcnJlZFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuTW9uYWRfc2VxdWVuY2UgKilcbm1vZHVsZSBNb25hZF9zZXF1ZW5jZSA9IEFzeW5jX2tlcm5lbF9fTW9uYWRfc2VxdWVuY2VcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLk1vbml0b3IgKilcbm1vZHVsZSBNb25pdG9yID0gQXN5bmNfa2VybmVsX19Nb25pdG9yXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5Nb25pdG9yMCAqKVxubW9kdWxlIE1vbml0b3IwID0gQXN5bmNfa2VybmVsX19Nb25pdG9yMFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuTXZhciAqKVxubW9kdWxlIE12YXIgPSBBc3luY19rZXJuZWxfX012YXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlBpcGUgKilcbm1vZHVsZSBQaXBlID0gQXN5bmNfa2VybmVsX19QaXBlXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5Qcmlvcml0eSAqKVxubW9kdWxlIFByaW9yaXR5ID0gQXN5bmNfa2VybmVsX19Qcmlvcml0eVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuUmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZSAqKVxubW9kdWxlIFJlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2UgPSBBc3luY19rZXJuZWxfX1JlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2VcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlNjaGVkdWxlciAqKVxubW9kdWxlIFNjaGVkdWxlciA9IEFzeW5jX2tlcm5lbF9fU2NoZWR1bGVyXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5TY2hlZHVsZXIwICopXG5tb2R1bGUgU2NoZWR1bGVyMCA9IEFzeW5jX2tlcm5lbF9fU2NoZWR1bGVyMFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuU2NoZWR1bGVyMSAqKVxubW9kdWxlIFNjaGVkdWxlcjEgPSBBc3luY19rZXJuZWxfX1NjaGVkdWxlcjFcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlN0YWNrX29yX2NvdW50ZXIgKilcbm1vZHVsZSBTdGFja19vcl9jb3VudGVyID0gQXN5bmNfa2VybmVsX19TdGFja19vcl9jb3VudGVyXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5TeW5jaHJvbm91c190aW1lX3NvdXJjZSAqKVxubW9kdWxlIFN5bmNocm9ub3VzX3RpbWVfc291cmNlID0gQXN5bmNfa2VybmVsX19TeW5jaHJvbm91c190aW1lX3NvdXJjZVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuU3luY2hyb25vdXNfdGltZV9zb3VyY2UwICopXG5tb2R1bGUgU3luY2hyb25vdXNfdGltZV9zb3VyY2UwID0gQXN5bmNfa2VybmVsX19TeW5jaHJvbm91c190aW1lX3NvdXJjZTBcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlRhaWwgKilcbm1vZHVsZSBUYWlsID0gQXN5bmNfa2VybmVsX19UYWlsXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5UaHJvdHRsZSAqKVxubW9kdWxlIFRocm90dGxlID0gQXN5bmNfa2VybmVsX19UaHJvdHRsZVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuVGhyb3R0bGVkICopXG5tb2R1bGUgVGhyb3R0bGVkID0gQXN5bmNfa2VybmVsX19UaHJvdHRsZWRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlRpbWVfbnMgKilcbm1vZHVsZSBUaW1lX25zID0gQXN5bmNfa2VybmVsX19UaW1lX25zXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5UaW1lX3NvdXJjZSAqKVxubW9kdWxlIFRpbWVfc291cmNlID0gQXN5bmNfa2VybmVsX19UaW1lX3NvdXJjZVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuVGltZV9zb3VyY2VfaW50ZiAqKVxubW9kdWxlIFRpbWVfc291cmNlX2ludGYgPSBBc3luY19rZXJuZWxfX1RpbWVfc291cmNlX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlR5cGVzICopXG5tb2R1bGUgVHlwZXMgPSBBc3luY19rZXJuZWxfX1R5cGVzXG5cbm1vZHVsZSBBc3luY19rZXJuZWxfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwiaW5jbHVkZSBDb3JlLkNvcmVfcHJpdmF0ZS5UaW1lX25zX2FsdGVybmF0ZV9zZXhwXG5cbigqIFthZnRlcl0gaXMgbGlrZSBbYWRkXSwgYnV0IGRlYWxzIG5pY2VseSB3aXRoIHRoZSBjYXNlIG9mIG92ZXJmbG93IGJ5IGluc3RlYWQgcmV0dXJuaW5nXG4gICBbbWF4X3ZhbHVlXS4gIFRpbWUtc291cmNlIGZ1bmN0aW9ucyB1c2UgW2FmdGVyXSB0byBhdm9pZCBpbW1lZGlhdGVseSBmaXJpbmcgZXZlbnRzIHRoYXRcbiAgIHNob3VsZCBuZXZlciBmaXJlLCBkdWUgdG8gdGhlIG92ZXJmbG93IGxlYWRpbmcgdG8gYSBuZWdhdGl2ZSB0aW1lIHRoYXQgYXBwZWFycyB0byBiZSBpblxuICAgdGhlIHBhc3QuICBXZSBkb24ndCBjaGVjayB1bmRlcmZsb3cgYmVjYXVzZSB0aGF0IGlzIHZlcnkgdW5saWtlbHksIHJlcXVpcmluZyBib3RoIGFcbiAgIG5lZ2F0aXZlIHRpbWUgYW5kIGEgbmVnYXRpdmUgc3Bhbi4gKilcbmxldCBhZnRlciB0IHNwYW4gPVxuICBsZXQgcmVzdWx0ID0gYWRkIHQgc3BhbiBpblxuICBpZiBTcGFuLiggPiApIHNwYW4gU3Bhbi56ZXJvICYmIHJlc3VsdCA8IHQgdGhlbiBtYXhfdmFsdWVfZm9yXzF1c19yb3VuZGluZyBlbHNlIHJlc3VsdFxuOztcbiIsIm1vZHVsZSBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5ID0gVGltZV9uc1xub3BlbiBDb3JlXG5tb2R1bGUgVGltZV9ucyA9IFRpbWVfbnNfaW5fdGhpc19kaXJlY3RvcnlcbmluY2x1ZGUgQXN5bmNfa2VybmVsX2NvbmZpZy5QcmludF9kZWJ1Z19tZXNzYWdlc19mb3JcblxubGV0IGxvZyBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgZXByaW50ZlxuICAgIFwiJXNcXG4lIVwiXG4gICAgKFNleHAudG9fc3RyaW5nX2h1bVxuICAgICAgIChbJXNleHBfb2Y6IFNleHAudCAqIFRpbWVfbnMudCAqIHN0cmluZyAqIGFdXG4gICAgICAgICAgKCFBc3luY19rZXJuZWxfY29uZmlnLnRhc2tfaWQgKCksIFRpbWVfbnMubm93ICgpLCBtZXNzYWdlLCBhKSkpXG47O1xuXG5sZXQgbG9nX3N0cmluZyBtZXNzYWdlID0gbG9nIG1lc3NhZ2UgKCkgWyVzZXhwX29mOiB1bml0XVxuIiwibW9kdWxlIERlYnVnX2luX3RoaXNfZGlyZWN0b3J5ID0gRGVidWdcbm1vZHVsZSBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5ID0gVGltZV9uc1xub3BlbiEgQ29yZVxuaW5jbHVkZSBJbnQuUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5tb2R1bGUgRGVidWcgPSBEZWJ1Z19pbl90aGlzX2RpcmVjdG9yeVxubW9kdWxlIFRpbWVfbnMgPSBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5XG5tb2R1bGUgUG9vbCA9IFR1cGxlX3Bvb2xcblxubW9kdWxlIE1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlID1cbiAgQXN5bmNfa2VybmVsX2NvbmZpZy5NYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuXG5sZXQgY29uY2F0ID0gU3RyaW5nLmNvbmNhdFxubGV0IGVwcmludCA9IENvcmUuRGVidWcuZXByaW50XG5sZXQgZXByaW50X3MgPSBDb3JlLkRlYnVnLmVwcmludF9zXG5sZXQgZXByaW50cyA9IENvcmUuRGVidWcuZXByaW50c1xubGV0IHByaW50X3Mgc2V4cCA9IHByaW50ZiBcIiVzXFxuJSFcIiAoc2V4cCB8PiBTZXhwLnRvX3N0cmluZ19odW0pXG5sZXQgc2VjID0gVGltZV9ucy5TcGFuLm9mX3NlY1xuXG4oKiBXZSBkb24ndCB3YW50IHRvIHVzZSB0aGVzZSBtb2R1bGVzIGluIEFzeW5jX2tlcm5lbCwgdG8gYXZvaWQgZGlmZmljdWx0aWVzIHdpdGhcbiAgIHVzaW5nIGl0IG9uIGpzX29mX29jYW1sLiAqKVxubW9kdWxlIFRocmVhZCA9IHN0cnVjdCBlbmRcbm1vZHVsZSBVbml4ID0gc3RydWN0IGVuZFxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTm9ybWFsXG4gIHwgTG93XG5bQEBkZXJpdmluZyBzZXhwX29mLCBlbnVtZXJhdGVdXG5cbmxldCBub3JtYWwgPSBOb3JtYWxcbmxldCBsb3cgPSBMb3dcbiIsIigqIFRoaXMgZmlsZSBkZWZpbmVzIHRoZSBtdXR1YWxseSByZWN1cnNpdmUgdHlwZXMgYXQgdGhlIGhlYXJ0IG9mIEFzeW5jLiAgVGhlIGZ1bmN0aW9uc1xuICAgYXNzb2NpYXRlZCB3aXRoIHRoZSB0eXBlcyBhcmUgZGVmaW5lZCBpbiB0aGUgY29ycmVzcG9uZGluZyBmaWxlKHMpIGZvciBlYWNoIG1vZHVsZS5cbiAgIFRoaXMgZmlsZSBzaG91bGQgZGVmaW5lIG9ubHkgdHlwZXMsIG5vdCBmdW5jdGlvbnMsIHNpbmNlIGZ1bmN0aW9ucyBkZWZpbmVkIGluc2lkZSB0aGVcbiAgIHJlY3Vyc2l2ZSBtb2R1bGVzIGFyZSBub3QgaW5saW5lZC5cblxuICAgSWYgeW91IG5lZWQgdG8gYWRkIGZ1bmN0aW9uYWxpdHkgdG8gYSBtb2R1bGUgYnV0IGRvaW5nIHNvIHdvdWxkIGNyZWF0ZSBhIGRlcGVuZGVuY3lcbiAgIGN5Y2xlLCBzcGxpdCB0aGUgZmlsZSBpbnRvIHBpZWNlcyBhcyBuZWVkZWQgdG8gYnJlYWsgdGhlIGN5Y2xlLCBlLmcuIHNjaGVkdWxlcjAubWwsXG4gICBzY2hlZHVsZXIxLm1sLCBzY2hlZHVsZXIubWwuICopXG5cbm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgcmVjIENlbGwgOiBzaWdcbiAgdHlwZSBhbnkgPVxuICAgIFsgYEVtcHR5XG4gICAgfCBgRW1wdHlfb25lX2hhbmRsZXJcbiAgICB8IGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVyc1xuICAgIHwgYEZ1bGxcbiAgICB8IGBJbmRpclxuICAgIF1cblxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgOlxuICAgICAgICB7IG11dGFibGUgcnVuIDogJ2EgLT4gdW5pdFxuICAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgICAgICA7IG11dGFibGUgcHJldiA6ICdhIEhhbmRsZXIudFxuICAgICAgICA7IG11dGFibGUgbmV4dCA6ICdhIEhhbmRsZXIudFxuICAgICAgICB9XG4gICAgICAgIC0+ICgnYSwgWz4gYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF0pIHRcbiAgICB8IEVtcHR5X29uZV9oYW5kbGVyIDpcbiAgICAgICAgKCdhIC0+IHVuaXQpICogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgICAgICAtPiAoJ2EsIFs+IGBFbXB0eV9vbmVfaGFuZGxlciBdKSB0XG4gICAgfCBFbXB0eSA6ICgnYSwgWz4gYEVtcHR5IF0pIHRcbiAgICB8IEZ1bGwgOiAnYSAtPiAoJ2EsIFs+IGBGdWxsIF0pIHRcbiAgICB8IEluZGlyIDogJ2EgSXZhci50IC0+ICgnYSwgWz4gYEluZGlyIF0pIHRcbmVuZCA9XG4gIENlbGxcblxuYW5kIEhhbmRsZXIgOiBzaWdcbiAgdHlwZSAnYSB0ID0gKCdhLCBbIGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBdKSBDZWxsLnRcbmVuZCA9XG4gIEhhbmRsZXJcblxuYW5kIEl2YXIgOiBzaWdcbiAgdHlwZSAnYSB0ID0geyBtdXRhYmxlIGNlbGwgOiAoJ2EsIENlbGwuYW55KSBDZWxsLnQgfVxuXG4gIG1vZHVsZSBJbW11dGFibGUgOiBzaWdcbiAgICB0eXBlICdhIHQgPSB7IGNlbGwgOiAoJ2EsIENlbGwuYW55KSBDZWxsLnQgfVxuICBlbmRcbmVuZCA9XG4gIEl2YXJcblxuYW5kIERlZmVycmVkIDogc2lnXG4gIHR5cGUgKyEnYSB0XG5lbmQgPVxuICBEZWZlcnJlZFxuXG5hbmQgRXhlY3V0aW9uX2NvbnRleHQgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IG1vbml0b3IgOiBNb25pdG9yLnRcbiAgICA7IHByaW9yaXR5IDogUHJpb3JpdHkudFxuICAgIDsgbG9jYWxfc3RvcmFnZSA6IFVuaXZfbWFwLnRcbiAgICA7IGJhY2t0cmFjZV9oaXN0b3J5IDogQmFja3RyYWNlLnQgbGlzdFxuICAgIH1cbmVuZCA9XG4gIEV4ZWN1dGlvbl9jb250ZXh0XG5cbmFuZCBGb3J3YXJkaW5nIDogc2lnXG4gIHR5cGUgdCA9XG4gICAgfCBEZXRhY2hlZFxuICAgIHwgUGFyZW50IG9mIE1vbml0b3IudFxuICAgIHwgUmVwb3J0X3VuY2F1Z2h0X2V4blxuZW5kID1cbiAgRm9yd2FyZGluZ1xuXG5hbmQgTW9uaXRvciA6IHNpZ1xuICB0eXBlIHQgPVxuICAgIHsgbmFtZSA6IEluZm8udFxuICAgIDsgaGVyZSA6IFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnQgb3B0aW9uXG4gICAgOyBpZCA6IGludFxuICAgIDsgbXV0YWJsZSBuZXh0X2Vycm9yIDogZXhuIEl2YXIudFxuICAgIDsgbXV0YWJsZSBoYW5kbGVyc19mb3JfYWxsX2Vycm9ycyA6IChFeGVjdXRpb25fY29udGV4dC50ICogKGV4biAtPiB1bml0KSkgQmFnLnRcbiAgICA7IG11dGFibGUgdGFpbHNfZm9yX2FsbF9lcnJvcnMgOiBleG4gVGFpbC50IGxpc3RcbiAgICA7IG11dGFibGUgaGFzX3NlZW5fZXJyb3IgOiBib29sXG4gICAgOyBtdXRhYmxlIGZvcndhcmRpbmcgOiBGb3J3YXJkaW5nLnRcbiAgICB9XG5lbmQgPVxuICBNb25pdG9yXG5cbmFuZCBUYWlsIDogc2lnXG4gIHR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBuZXh0IDogJ2EgU3RyZWFtLm5leHQgSXZhci50IH1cbmVuZCA9XG4gIFRhaWxcblxuYW5kIFN0cmVhbSA6IHNpZ1xuICB0eXBlICdhIHQgPSAnYSBuZXh0IERlZmVycmVkLnRcblxuICBhbmQgJ2EgbmV4dCA9XG4gICAgfCBOaWxcbiAgICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5lbmQgPVxuICBTdHJlYW1cblxuKCogV2UgYXZvaWQgdXNpbmcgW21vZHVsZSByZWNdIHRvIGRlZmluZSBbQnZhcl0sIHNvIHRoYXQgW3RvX3JlcHJdIGFuZCBbb2ZfcmVwcl0gYXJlXG4gICBpbmxpbmVkLiAqKVxubW9kdWxlIEJ2YXIgOiBzaWdcbiAgdHlwZSAoJ2EsIC0ncGVybWlzc2lvbikgdFxuXG4gICgqKiBbcmVwcl0gZXhpc3RzIHNvIHRoYXQgd2UgbWF5IGhpZGUgdGhlIGltcGxlbWVudGF0aW9uIG9mIGEgW0J2YXIudF0sIGFuZCB0aGVuIGFkZCBhXG4gICAgICBwaGFudG9tIHR5cGUgdG8gaXQgdXBzdHJlYW0uICBXaXRob3V0IHRoaXMsIHRoZSBwaGFudG9tIHR5cGUgdmFyaWFibGUgd291bGQgYWxsb3dcbiAgICAgIGZvciBhbnl0aGluZyB0byBiZSBjb2VyY2VkIGluIGFuZCBvdXQsIHNpbmNlIGl0IGlzIHVudXNlZC4gKilcbiAgdHlwZSAnYSByZXByID1cbiAgICB7IG11dGFibGUgaGFzX2FueV93YWl0ZXJzIDogYm9vbFxuICAgIDsgbXV0YWJsZSBpdmFyIDogJ2EgSXZhci50XG4gICAgfVxuXG4gIHZhbCBvZl9yZXByIDogJ2EgcmVwciAtPiAoJ2EsICdwZXJtaXNzaW9uKSB0XG4gIHZhbCB0b19yZXByIDogKCdhLCAncGVybWlzc2lvbikgdCAtPiAnYSByZXByXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSByZXByID1cbiAgICB7IG11dGFibGUgaGFzX2FueV93YWl0ZXJzIDogYm9vbFxuICAgIDsgbXV0YWJsZSBpdmFyIDogJ2EgSXZhci50XG4gICAgfVxuXG4gIHR5cGUgKCdhLCAncGVybWlzc2lvbikgdCA9ICdhIHJlcHJcblxuICBsZXQgdG9fcmVwciB0ID0gdFxuICBsZXQgb2ZfcmVwciB0ID0gdFxuZW5kXG5cbm1vZHVsZSByZWMgRXZlbnQgOiBzaWdcbiAgbW9kdWxlIFN0YXR1cyA6IHNpZ1xuICAgIHR5cGUgdCA9XG4gICAgICB8IEZpcmVkXG4gICAgICB8IEhhcHBlbmluZ19wZXJpb2RpY19ldmVudFxuICAgICAgfCBTY2hlZHVsZWRcbiAgICAgIHwgVW5zY2hlZHVsZWRcbiAgZW5kXG5cbiAgbW9kdWxlIE9wdGlvbiA6IHNpZ1xuICAgIHR5cGUgdFxuICBlbmRcblxuICB0eXBlIHQgPVxuICAgIHsgbXV0YWJsZSBhbGFybSA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC5BbGFybS50XG4gICAgOyBtdXRhYmxlIGF0IDogVGltZV9ucy50XG4gICAgOyBjYWxsYmFjayA6IHVuaXQgLT4gdW5pdFxuICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgOyBtdXRhYmxlIGludGVydmFsIDogVGltZV9ucy5TcGFuLnQgb3B0aW9uXG4gICAgOyBtdXRhYmxlIG5leHRfZmlyZWQgOiBPcHRpb24udFxuICAgIDsgbXV0YWJsZSBwcmV2X2ZpcmVkIDogT3B0aW9uLnRcbiAgICA7IG11dGFibGUgc3RhdHVzIDogU3RhdHVzLnRcbiAgICB9XG5lbmQgPVxuICBFdmVudFxuXG5hbmQgRXh0ZXJuYWxfam9iIDogc2lnXG4gIHR5cGUgdCA9IFQgOiBFeGVjdXRpb25fY29udGV4dC50ICogKCdhIC0+IHVuaXQpICogJ2EgLT4gdFxuZW5kID1cbiAgRXh0ZXJuYWxfam9iXG5cbmFuZCBKb2IgOiBzaWdcbiAgdHlwZSBzbG90cyA9IChFeGVjdXRpb25fY29udGV4dC50LCBPYmoudCAtPiB1bml0LCBPYmoudCkgUG9vbC5TbG90cy50M1xuICB0eXBlIHQgPSBzbG90cyBQb29sLlBvaW50ZXIudFxuZW5kID1cbiAgSm9iXG5cbmFuZCBKb2Jfb3JfZXZlbnQgOiBzaWdcbiAgdHlwZSB0XG5lbmQgPVxuICBKb2Jfb3JfZXZlbnRcblxuYW5kIEpvYl9wb29sIDogc2lnXG4gIHR5cGUgdCA9IEpvYi5zbG90cyBQb29sLnRcbmVuZCA9XG4gIEpvYl9wb29sXG5cbmFuZCBKb2JfcXVldWUgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgbnVtX2pvYnNfcnVuIDogaW50XG4gICAgOyBtdXRhYmxlIGpvYnNfbGVmdF90aGlzX2N5Y2xlIDogaW50XG4gICAgOyBtdXRhYmxlIGpvYnMgOiBPYmoudCBVbmlmb3JtX2FycmF5LnRcbiAgICA7IG11dGFibGUgbWFzayA6IGludFxuICAgIDsgbXV0YWJsZSBmcm9udCA6IGludFxuICAgIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgICA7IG11dGFibGUgYmFja3RyYWNlX29mX2ZpcnN0X2VucXVldWUgOiBCYWNrdHJhY2UudCBvcHRpb25cbiAgICB9XG5lbmQgPVxuICBKb2JfcXVldWVcblxuYW5kIEpvYnMgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IHNjaGVkdWxlciA6IFNjaGVkdWxlci50XG4gICAgOyBtdXRhYmxlIGpvYl9wb29sIDogSm9iX3Bvb2wudFxuICAgIDsgbm9ybWFsIDogSm9iX3F1ZXVlLnRcbiAgICA7IGxvdyA6IEpvYl9xdWV1ZS50XG4gICAgfVxuZW5kID1cbiAgSm9ic1xuXG5hbmQgU2NoZWR1bGVyIDogc2lnXG4gIHR5cGUgdCA9XG4gICAgeyBtdXRhYmxlIGNoZWNrX2FjY2VzcyA6ICh1bml0IC0+IHVuaXQpIG9wdGlvblxuICAgIDsgbXV0YWJsZSBqb2JfcG9vbCA6IEpvYl9wb29sLnRcbiAgICA7IG5vcm1hbF9wcmlvcml0eV9qb2JzIDogSm9iX3F1ZXVlLnRcbiAgICA7IGxvd19wcmlvcml0eV9qb2JzIDogSm9iX3F1ZXVlLnRcbiAgICA7IHZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgOiBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIudCBEZXF1ZS50XG4gICAgOyBtdXRhYmxlIG1haW5fZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgOyBtdXRhYmxlIGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgOyBtdXRhYmxlIHVuY2F1Z2h0X2V4biA6IChFeG4udCAqIFNleHAudCkgb3B0aW9uXG4gICAgOyBtdXRhYmxlIGN5Y2xlX2NvdW50IDogaW50XG4gICAgOyBtdXRhYmxlIGN5Y2xlX3N0YXJ0IDogVGltZV9ucy50XG4gICAgOyBtdXRhYmxlIGluX2N5Y2xlIDogYm9vbFxuICAgIDsgbXV0YWJsZSBydW5fZXZlcnlfY3ljbGVfc3RhcnQgOiBDeWNsZV9ob29rLnQgYXJyYXlcbiAgICA7IHJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZSA6IChDeWNsZV9ob29rX2hhbmRsZS50LCBDeWNsZV9ob29rLnQpIEhhc2h0YmwudFxuICAgIDsgbXV0YWJsZSBydW5fZXZlcnlfY3ljbGVfZW5kIDogQ3ljbGVfaG9vay50IGFycmF5XG4gICAgOyBydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlIDogKEN5Y2xlX2hvb2tfaGFuZGxlLnQsIEN5Y2xlX2hvb2sudCkgSGFzaHRibC50XG4gICAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfdGltZSA6IFRpbWVfbnMuU3Bhbi50XG4gICAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfbnVtX2pvYnMgOiBpbnRcbiAgICA7IG11dGFibGUgdG90YWxfY3ljbGVfdGltZSA6IFRpbWVfbnMuU3Bhbi50XG4gICAgOyBtdXRhYmxlIHRpbWVfc291cmNlIDogcmVhZF93cml0ZSBUaW1lX3NvdXJjZS50MVxuICAgIDsgZXh0ZXJuYWxfam9icyA6IEV4dGVybmFsX2pvYi50IFRocmVhZF9zYWZlX3F1ZXVlLnRcbiAgICA7IG11dGFibGUgdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgOiB1bml0IC0+IHVuaXRcbiAgICA7IG11dGFibGUgam9iX3F1ZXVlZF9ob29rIDogKFByaW9yaXR5LnQgLT4gdW5pdCkgb3B0aW9uXG4gICAgOyBtdXRhYmxlIGV2ZW50X2FkZGVkX2hvb2sgOiAoVGltZV9ucy50IC0+IHVuaXQpIG9wdGlvblxuICAgIDsgbXV0YWJsZSB5aWVsZCA6ICh1bml0LCByZWFkX3dyaXRlKSBCdmFyLnRcbiAgICA7IG11dGFibGUgeWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gOiAodW5pdCwgcmVhZF93cml0ZSkgQnZhci50XG4gICAgOyBtdXRhYmxlIGNoZWNrX2ludmFyaWFudHMgOiBib29sXG4gICAgOyBtdXRhYmxlIG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIDogTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUudFxuICAgIDsgbXV0YWJsZSByZWNvcmRfYmFja3RyYWNlcyA6IGJvb2xcbiAgICB9XG5lbmQgPVxuICBTY2hlZHVsZXJcblxuYW5kIEN5Y2xlX2hvb2sgOiBzaWdcbiAgdHlwZSB0ID0gdW5pdCAtPiB1bml0XG5lbmQgPVxuICBDeWNsZV9ob29rXG5cbmFuZCBDeWNsZV9ob29rX2hhbmRsZSA6IFVuaXF1ZV9pZC5JZCA9IFVuaXF1ZV9pZC5JbnQ2MyAoKVxuYW5kIFRpbWVfc291cmNlX2lkIDogVW5pcXVlX2lkLklkID0gVW5pcXVlX2lkLkludDYzICgpXG5cbmFuZCBUaW1lX3NvdXJjZSA6IHNpZ1xuICB0eXBlIC0ncncgdDEgPVxuICAgIHsgaWQgOiBUaW1lX3NvdXJjZV9pZC50XG4gICAgOyBtdXRhYmxlIGFkdmFuY2VfZXJyb3JzIDogRXJyb3IudCBsaXN0XG4gICAgOyBtdXRhYmxlIGFtX2FkdmFuY2luZyA6IGJvb2xcbiAgICA7IGV2ZW50cyA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC50XG4gICAgOyBtdXRhYmxlIGZpcmVkX2V2ZW50cyA6IEV2ZW50Lk9wdGlvbi50XG4gICAgOyBtdXRhYmxlIG1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udFxuICAgIDsgaGFuZGxlX2ZpcmVkIDogSm9iX29yX2V2ZW50LnQgVGltaW5nX3doZWVsLkFsYXJtLnQgLT4gdW5pdFxuICAgIDsgaXNfd2FsbF9jbG9jayA6IGJvb2xcbiAgICA7IHNjaGVkdWxlciA6IFNjaGVkdWxlci50XG4gICAgfVxuZW5kID1cbiAgVGltZV9zb3VyY2VcblxuYW5kIFZlcnlfbG93X3ByaW9yaXR5X3dvcmtlciA6IHNpZ1xuICBtb2R1bGUgRXhlY19yZXN1bHQgOiBzaWdcbiAgICB0eXBlIHQgPVxuICAgICAgfCBGaW5pc2hlZFxuICAgICAgfCBOb3RfZmluaXNoZWRcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgIDsgZXhlYyA6IHVuaXQgLT4gRXhlY19yZXN1bHQudFxuICAgIH1cbmVuZCA9XG4gIFZlcnlfbG93X3ByaW9yaXR5X3dvcmtlclxuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxuXG5sZXQgZGVidWcgPSBEZWJ1Zy5tb25pdG9yXG5cbm1vZHVsZSBGb3J3YXJkaW5nID0gVHlwZXMuRm9yd2FyZGluZ1xuXG50eXBlIHQgPSBUeXBlcy5Nb25pdG9yLnQgPVxuICB7IG5hbWUgOiBJbmZvLnRcbiAgOyBoZXJlIDogU291cmNlX2NvZGVfcG9zaXRpb24udCBvcHRpb25cbiAgOyBpZCA6IGludFxuICA7IG11dGFibGUgbmV4dF9lcnJvciA6IGV4biBUeXBlcy5JdmFyLnRcbiAgOyAoKiBbTW9uaXRvci5zZW5kX2V4bl0gc2NoZWR1bGVzIGEgam9iIGZvciBlYWNoIGVsZW1lbnQgb2YgW2hhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzXS4gKilcbiAgICBtdXRhYmxlIGhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIDogKFR5cGVzLkV4ZWN1dGlvbl9jb250ZXh0LnQgKiAoZXhuIC0+IHVuaXQpKSBCYWcudFxuICA7ICgqIFtNb25pdG9yLnNlbmRfZXhuXSBleHRlbmRzIGVhY2ggdGFpbCBpbiBbdGFpbHNfZm9yX2FsbF9lcnJvcnNdLiAqKVxuICAgIG11dGFibGUgdGFpbHNfZm9yX2FsbF9lcnJvcnMgOiBleG4gVHlwZXMuVGFpbC50IGxpc3RcbiAgOyBtdXRhYmxlIGhhc19zZWVuX2Vycm9yIDogYm9vbFxuICA7IG11dGFibGUgZm9yd2FyZGluZyA6IEZvcndhcmRpbmcudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfml0ZXJhdG9yczppdGVyXVxuXG5sZXQgZGVzY3JpcHRpb24gdCA9XG4gIG1hdGNoIHQuaGVyZSB3aXRoXG4gIHwgTm9uZSAtPiBbJXNleHAgKHQubmFtZSA6IEluZm8udCldXG4gIHwgU29tZSBoZXJlIC0+IFslc2V4cCAodC5uYW1lIDogSW5mby50KSwgKGhlcmUgOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50KV1cbjs7XG5cbmxldCBkZXNjcmlwdGlvbnMgPVxuICBsZXQgcmVjIGxvb3AgdCBhYyA9XG4gICAgbGV0IGFjID0gZGVzY3JpcHRpb24gdCA6OiBhYyBpblxuICAgIG1hdGNoIHQuZm9yd2FyZGluZyB3aXRoXG4gICAgfCBEZXRhY2hlZCB8IFJlcG9ydF91bmNhdWdodF9leG4gLT4gTGlzdC5yZXYgYWNcbiAgICB8IFBhcmVudCB0IC0+IGxvb3AgdCBhY1xuICBpblxuICBmdW4gdCAtPiBsb29wIHQgW11cbjs7XG5cbmxldCBzZXhwX29mX3QgdCA9IFslc2V4cCAoZGVzY3JpcHRpb25zIHQgOiBTZXhwLnQgbGlzdCldXG5cbmxldCBuZXh0X2lkID1cbiAgbGV0IHIgPSByZWYgMCBpblxuICBmdW4gKCkgLT5cbiAgICBpbmNyIHI7XG4gICAgIXJcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9wYXJlbnQgP2hlcmUgP2luZm8gP25hbWUgcGFyZW50ID1cbiAgbGV0IGlkID0gbmV4dF9pZCAoKSBpblxuICBsZXQgbmFtZSA9XG4gICAgbWF0Y2ggaW5mbywgbmFtZSB3aXRoXG4gICAgfCBTb21lIGksIE5vbmUgLT4gaVxuICAgIHwgU29tZSBpLCBTb21lIHMgLT4gSW5mby50YWcgaSB+dGFnOnNcbiAgICB8IE5vbmUsIFNvbWUgcyAtPiBJbmZvLm9mX3N0cmluZyBzXG4gICAgfCBOb25lLCBOb25lIC0+IEluZm8uY3JlYXRlIFwiaWRcIiBpZCBbJXNleHBfb2Y6IGludCBTZXhwX2hpZGRlbl9pbl90ZXN0LnRdXG4gIGluXG4gIGxldCB0ID1cbiAgICB7IG5hbWVcbiAgICA7IGhlcmVcbiAgICA7IGZvcndhcmRpbmcgPVxuICAgICAgICAobWF0Y2ggcGFyZW50IHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBSZXBvcnRfdW5jYXVnaHRfZXhuXG4gICAgICAgICB8IFNvbWUgcGFyZW50IC0+IFBhcmVudCBwYXJlbnQpXG4gICAgOyBpZFxuICAgIDsgbmV4dF9lcnJvciA9IHsgY2VsbCA9IEVtcHR5IH1cbiAgICA7IGhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzID0gQmFnLmNyZWF0ZSAoKVxuICAgIDsgdGFpbHNfZm9yX2FsbF9lcnJvcnMgPSBbXVxuICAgIDsgaGFzX3NlZW5fZXJyb3IgPSBmYWxzZVxuICAgIH1cbiAgaW5cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJjcmVhdGVkIG1vbml0b3JcIiB0IFslc2V4cF9vZjogdF07XG4gIHRcbjs7XG5cbmxldCBtYWluID0gY3JlYXRlX3dpdGhfcGFyZW50IH5uYW1lOlwibWFpblwiIE5vbmVcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIE1vbml0b3IgPSBNb25pdG9yMFxuXG50eXBlIHQgPSBUeXBlcy5FeGVjdXRpb25fY29udGV4dC50ID1cbiAgeyBtb25pdG9yIDogTW9uaXRvci50XG4gIDsgcHJpb3JpdHkgOiBQcmlvcml0eS50XG4gIDsgbG9jYWxfc3RvcmFnZSA6IFVuaXZfbWFwLnRcbiAgOyBiYWNrdHJhY2VfaGlzdG9yeSA6IEJhY2t0cmFjZS50IGxpc3RcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzLCBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuXG5sZXQgbWFpbiA9XG4gIHsgbW9uaXRvciA9IE1vbml0b3IubWFpblxuICA7IHByaW9yaXR5ID0gUHJpb3JpdHkubm9ybWFsXG4gIDsgbG9jYWxfc3RvcmFnZSA9IFVuaXZfbWFwLmVtcHR5XG4gIDsgYmFja3RyYWNlX2hpc3RvcnkgPSBbXVxuICB9XG47O1xuXG5sZXQgY3JlYXRlX2xpa2UgP21vbml0b3IgP3ByaW9yaXR5ID9sb2NhbF9zdG9yYWdlIHQgPVxuICBtYXRjaCBtb25pdG9yLCBwcmlvcml0eSwgbG9jYWxfc3RvcmFnZSB3aXRoXG4gIHwgTm9uZSwgTm9uZSwgTm9uZSAtPlxuICAgICgqIGF2b2lkIGFsbG9jYXRpbmcgaW4gdGhlIHRyaXZpYWwgY2FzZSwgd2hpY2ggZS5nLiBoYXBwZW5zIHdoZW4gY2FsbGluZ1xuICAgICAgIFtBc3luYy5zY2hlZHVsZV0gd2l0aG91dCBvcHRpb25hbCBhcmdzICopXG4gICAgdFxuICB8IF8gLT5cbiAgICBsZXQgbW9uaXRvciA9IE9wdGlvbi52YWx1ZSBtb25pdG9yIH5kZWZhdWx0OnQubW9uaXRvciBpblxuICAgIHsgbW9uaXRvclxuICAgIDsgcHJpb3JpdHkgPSBPcHRpb24udmFsdWUgcHJpb3JpdHkgfmRlZmF1bHQ6dC5wcmlvcml0eVxuICAgIDsgbG9jYWxfc3RvcmFnZSA9IE9wdGlvbi52YWx1ZSBsb2NhbF9zdG9yYWdlIH5kZWZhdWx0OnQubG9jYWxfc3RvcmFnZVxuICAgIDsgYmFja3RyYWNlX2hpc3RvcnkgPSB0LmJhY2t0cmFjZV9oaXN0b3J5XG4gICAgfVxuOztcblxubGV0IGZpbmRfbG9jYWwgdCBrZXkgPSBVbml2X21hcC5maW5kIHQubG9jYWxfc3RvcmFnZSBrZXlcblxubGV0IHdpdGhfbG9jYWwgdCBrZXkgZGF0YSA9XG4gIG1hdGNoIGRhdGEgd2l0aFxuICB8IFNvbWUgZGF0YSAtPiB7IHQgd2l0aCBsb2NhbF9zdG9yYWdlID0gVW5pdl9tYXAuc2V0IHQubG9jYWxfc3RvcmFnZSB+a2V5IH5kYXRhIH1cbiAgfCBOb25lIC0+IHsgdCB3aXRoIGxvY2FsX3N0b3JhZ2UgPSBVbml2X21hcC5yZW1vdmUgdC5sb2NhbF9zdG9yYWdlIGtleSB9XG47O1xuXG5sZXQgcmVjb3JkX2JhY2t0cmFjZSB0ID1cbiAgeyB0IHdpdGggYmFja3RyYWNlX2hpc3RvcnkgPSBCYWNrdHJhY2UuZ2V0ICgpIDo6IHQuYmFja3RyYWNlX2hpc3RvcnkgfVxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBUeXBlcy5FeHRlcm5hbF9qb2JcblxubGV0IHNleHBfb2ZfdCBfID0gU2V4cC5BdG9tIFwiPGpvYj5cIlxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuIFBvb2xcblxubGV0IGR1bW15X2UgPSBFeGVjdXRpb25fY29udGV4dC5tYWluXG5sZXQgZHVtbXlfZiA6IE9iai50IC0+IHVuaXQgPSBpZ25vcmVcbmxldCBkdW1teV9hIDogT2JqLnQgPSBPYmoucmVwciAoKVxuXG50eXBlIHNsb3RzID0gKEV4ZWN1dGlvbl9jb250ZXh0LnQsIE9iai50IC0+IHVuaXQsIChPYmoudFtAc2V4cC5vcGFxdWVdKSkgU2xvdHMudDNcbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbnR5cGUgdCA9IHNsb3RzIFBvb2wudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IHQgPSBQb29sLmludmFyaWFudCBpZ25vcmUgdFxubGV0IGNyZWF0ZSAoKSA9IGNyZWF0ZSBTbG90cy50MyB+Y2FwYWNpdHk6MSB+ZHVtbXk6KGR1bW15X2UsIGR1bW15X2YsIGR1bW15X2EpXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSB0ID0gSm9iX3Bvb2wuc2xvdHMgUG9vbC5Qb2ludGVyLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIEV2ZW50ID0gVHlwZXMuRXZlbnRcbm1vZHVsZSBKb2IgPSBUeXBlcy5Kb2JcbmluY2x1ZGUgVHlwZXMuSm9iX29yX2V2ZW50XG5cbigqIFRoaXMgcmVkZWZpbml0aW9uIG9mIFtFdmVudF0gaXMgaGVyZSBzbyB0aGUgdHlwZSBjaGVja3MgYXJlIHJpZ2h0IG5leHQgdG9cbiAgIFtPYmoubWFnaWNdcy4gKilcbm1vZHVsZSBfIDogc2lnIGVuZCA9IHN0cnVjdFxuICBvcGVuIFR5cGVzXG4gIG9wZW4gRXZlbnRcblxuICB0eXBlIF90ID0gdCA9XG4gICAgeyAoKiBtdXN0IG5ldmVyIGJlIGltbWVkaWF0ZSAqKVxuICAgICAgbXV0YWJsZSBhbGFybSA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC5BbGFybS50XG4gICAgOyBtdXRhYmxlIGF0IDogVGltZV9ucy50XG4gICAgOyBjYWxsYmFjayA6IHVuaXQgLT4gdW5pdFxuICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgOyBtdXRhYmxlIGludGVydmFsIDogVGltZV9ucy5TcGFuLnQgb3B0aW9uXG4gICAgOyBtdXRhYmxlIG5leHRfZmlyZWQgOiBPcHRpb24udFxuICAgIDsgbXV0YWJsZSBwcmV2X2ZpcmVkIDogT3B0aW9uLnRcbiAgICA7IG11dGFibGUgc3RhdHVzIDogU3RhdHVzLnRcbiAgICB9XG5lbmRcblxubW9kdWxlIF8gOiBzaWcgZW5kID0gc3RydWN0XG4gIG1vZHVsZSBFbnN1cmVfcHJpdmF0ZV9pbnQgKE0gOiBzaWdcbiAgICB0eXBlIHQgPSBwcml2YXRlIGludFxuICBlbmQpID1cbiAgc3RydWN0XG4gICAgdHlwZSBfdCA9IE0udFxuICBlbmRcblxuICBpbmNsdWRlIEVuc3VyZV9wcml2YXRlX2ludCAoSm9iKVxuZW5kXG5cbmxldCBvZl9ldmVudCBldmVudCA6IHQgPSBPYmoubWFnaWMgKGV2ZW50IDogRXZlbnQudClcbmxldCBvZl9qb2Igam9iIDogdCA9IE9iai5tYWdpYyAoam9iIDogSm9iLnQpXG5sZXQgaXNfZXZlbnQgKHQgOiB0KSA9IE9iai5pc19ibG9jayAoT2JqLnJlcHIgdClcbmxldCBpc19qb2IgKHQgOiB0KSA9IE9iai5pc19pbnQgKE9iai5yZXByIHQpXG5cbm1vZHVsZSBNYXRjaCA9IHN0cnVjdFxuICB0eXBlIF8ga2luZCA9XG4gICAgfCBFdmVudCA6IEV2ZW50LnQga2luZFxuICAgIHwgSm9iIDogSm9iLnQga2luZFxuXG4gIHR5cGUgcGFja2VkID0gSyA6IF8ga2luZCAtPiBwYWNrZWQgW0BAdW5ib3hlZF1cblxuICBsZXQga2luZCB0ID0gaWYgaXNfZXZlbnQgdCB0aGVuIEsgRXZlbnQgZWxzZSBLIEpvYlxuICBsZXQgcHJvamVjdCAodHlwZSBhKSAoXyA6IGEga2luZCkgam9iX29yX2V2ZW50ID0gKE9iai5tYWdpYyA6IHQgLT4gYSkgam9iX29yX2V2ZW50XG5lbmRcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBUeXBlcy5TY2hlZHVsZXJcblxubGV0IGV2ZW50cyB0ID0gdC50aW1lX3NvdXJjZS5ldmVudHNcblxubGV0IHNldF9leGVjdXRpb25fY29udGV4dCB0IGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgKCogQXZvaWQgYSBjYW1sX21vZGlmeSBpbiBtb3N0IGNhc2VzLiAqKVxuICBpZiBub3QgKHBoeXNfZXF1YWwgdC5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IGV4ZWN1dGlvbl9jb250ZXh0KVxuICB0aGVuIHQuY3VycmVudF9leGVjdXRpb25fY29udGV4dCA8LSBleGVjdXRpb25fY29udGV4dFxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjBcblxubGV0IGR1bW15X2UgPSBFeGVjdXRpb25fY29udGV4dC5tYWluXG5sZXQgZHVtbXlfZiA6IE9iai50IC0+IHVuaXQgPSBpZ25vcmVcbmxldCBkdW1teV9hIDogT2JqLnQgPSBPYmoucmVwciAoKVxubGV0IHNsb3RzX3Blcl9lbHQgPSAzXG5cbm1vZHVsZSBBID0gVW5pZm9ybV9hcnJheVxuXG4oKiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgc3BlY2lhbGl6ZWQgW0ZsYXRfcXVldWVdLCBkb25lIGZvciByZWFzb25zIG9mIHNwZWVkLiAqKVxudHlwZSB0ID0gVHlwZXMuSm9iX3F1ZXVlLnQgPVxuICB7IG11dGFibGUgbnVtX2pvYnNfcnVuIDogaW50XG4gIDsgbXV0YWJsZSBqb2JzX2xlZnRfdGhpc19jeWNsZSA6IGludFxuICA7ICgqIFtqb2JzXSBpcyBhbiBhcnJheSBvZiBsZW5ndGggW2NhcGFjaXR5IHQgKiBzbG90c19wZXJfZWx0XSwgd2hlcmUgZWFjaCBlbHQgaGFzIHRoZVxuICAgICAgIHRocmVlIGNvbXBvbmVudHMgb2YgYSBqb2IgKFtleGVjdXRpb25fY29udGV4dF0sIFtmXSwgW2FdKSBpbiBjb25zZWN1dGl2ZSBzcG90cyBpblxuICAgICAgIFtqb2JzXS4gIFtlbnF1ZXVlXSBkb3VibGVzIHRoZSBsZW5ndGggb2YgW2pvYnNdIGlmIFtqb2JzXSBpcyBmdWxsLiAgW2pvYnNdIG5ldmVyXG4gICAgICAgc2hyaW5rcy4gIFtqb2JzXSBpcyBzb21ld2hhdCBsaWtlIGEgW0NvcmUuUG9vbF0gc3BlY2lhbGl6ZWQgdG8gMy10dXBsZXM7IHdlXG4gICAgICAgZG9uJ3QgdXNlIFtQb29sXSBiZWNhdXNlIHRoYXQgaW1wbGVtZW50cyBhIHNldCwgd2hlcmUgW2pvYnNdIGlzIGEgcXVldWUuICopXG4gICAgbXV0YWJsZSBqb2JzIDogKE9iai50IEEudFtAc2V4cC5vcGFxdWVdKVxuICA7ICgqIFttYXNrXSBpcyBbY2FwYWNpdHkgdCAtIDFdLCBhbmQgaXMgdXNlZCBmb3IgcXVpY2tseSBjb21wdXRpbmcgW2kgbW9kIChjYXBhY2l0eVxuICAgICAgIHQpXS4gQSBzcGVjaWFsIGNhc2Ugd2hlbiB0aGUgam9iIHF1ZXVlIGhhcyBjYXBhY2l0eSAwIGlzIHJlcHJlc2VudGVkXG4gICAgICAgd2l0aCBbbWFzayA9IC0xXS4gVGhpcyB2YWx1ZSBpcyBub3QgdXNlZnVsIGFzIGEgYml0LW1hc2ssIGJ1dCB3ZSBvbmx5IHVzZVxuICAgICAgIHRoZSBiaXQtbWFzayB3aGVuIHRoZXJlJ3MgY2FwYWNpdHkgaW4gdGhlIGFycmF5LCBzbyB0aGF0IGlzIG5vdCBhIHByb2JsZW0uXG4gICAgKilcbiAgICBtdXRhYmxlIG1hc2sgOiBpbnRcbiAgOyAoKiBbZnJvbnRdIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgam9iIGluIHRoZSBxdWV1ZS4gIFRoZSBhcnJheSBpbmRleCBvZiB0aGF0IGpvYidzXG4gICAgICAgZXhlY3V0aW9uIGNvbnRleHQgaXMgW2Zyb250ICogc2xvdHNfcGVyX2VsdF0uICopXG4gICAgbXV0YWJsZSBmcm9udCA6IGludFxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgbXV0YWJsZSBiYWNrdHJhY2Vfb2ZfZmlyc3RfZW5xdWV1ZSA6IEJhY2t0cmFjZS50IG9wdGlvblxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG5sZXQgb2Zmc2V0IHQgaSA9ICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2sgKiBzbG90c19wZXJfZWx0XG5sZXQgY2FwYWNpdHkgdCA9IHQubWFzayArIDFcblxubGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bnVtX2pvYnNfcnVuOihjaGVjayAoZnVuIG51bV9qb2JzX3J1biAtPiBhc3NlcnQgKG51bV9qb2JzX3J1biA+PSAwKSkpXG4gICAgICB+am9ic19sZWZ0X3RoaXNfY3ljbGU6XG4gICAgICAgIChjaGVjayAoZnVuIGpvYnNfbGVmdF90aGlzX2N5Y2xlIC0+IGFzc2VydCAoam9ic19sZWZ0X3RoaXNfY3ljbGUgPj0gMCkpKVxuICAgICAgfmpvYnM6XG4gICAgICAgIChjaGVjayAoZnVuIGpvYnMgLT5cbiAgICAgICAgICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgICAgICAgIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudFxuICAgICAgICAgICAgICAgKE9iai5vYmogKEEuZ2V0IGpvYnMgKG9mZnNldCB0IGkpKSA6IEV4ZWN1dGlvbl9jb250ZXh0LnQpXG4gICAgICAgICAgIGRvbmUpKVxuICAgICAgfm1hc2s6XG4gICAgICAgIChjaGVjayAoZnVuIG1hc2sgLT5cbiAgICAgICAgICAgbGV0IGNhcGFjaXR5ID0gbWFzayArIDEgaW5cbiAgICAgICAgICAgYXNzZXJ0IChjYXBhY2l0eSA9IDAgfHwgSW50LmlzX3BvdzIgY2FwYWNpdHkpO1xuICAgICAgICAgICBhc3NlcnQgKGNhcGFjaXR5ICogc2xvdHNfcGVyX2VsdCA9IEEubGVuZ3RoIHQuam9icykpKVxuICAgICAgfmJhY2t0cmFjZV9vZl9maXJzdF9lbnF1ZXVlOihmdW4gXyAtPiAoKSlcbiAgICAgIH5mcm9udDpcbiAgICAgICAgKGNoZWNrIChmdW4gZnJvbnQgLT5cbiAgICAgICAgICAgYXNzZXJ0IChmcm9udCA+PSAwKTtcbiAgICAgICAgICAgYXNzZXJ0IChmcm9udCA8IG1heCAxIChjYXBhY2l0eSB0KSkpKVxuICAgICAgfmxlbmd0aDpcbiAgICAgICAgKGNoZWNrIChmdW4gbGVuZ3RoIC0+XG4gICAgICAgICAgIGFzc2VydCAobGVuZ3RoID49IDApO1xuICAgICAgICAgICBhc3NlcnQgKGxlbmd0aCA8PSBjYXBhY2l0eSB0KSkpKVxuOztcblxubGV0IGNyZWF0ZV9hcnJheSB+Y2FwYWNpdHkgPSBBLmNyZWF0ZV9vYmpfYXJyYXkgfmxlbjooY2FwYWNpdHkgKiBzbG90c19wZXJfZWx0KVxuXG5sZXQgY3JlYXRlICgpID1cbiAgKCogV2Ugc3RhcnQgd2l0aCBbY2FwYWNpdHkgID0gMF0gc28gdGhhdCB0aGUgZmlyc3Qgam9iIHRoYXQgaXMgYWRkZWQgY2FsbHMgW2dyb3ddIGFuZFxuICAgICBmaWxscyBpbiB0aGUgW2JhY2t0cmFjZV9vZl9maXJzdF9lbnF1ZXVlXS4gKilcbiAgbGV0IGNhcGFjaXR5ID0gMCBpblxuICB7IG51bV9qb2JzX3J1biA9IDBcbiAgOyBqb2JzX2xlZnRfdGhpc19jeWNsZSA9IDBcbiAgOyBqb2JzID0gY3JlYXRlX2FycmF5IH5jYXBhY2l0eVxuICA7IG1hc2sgPSBjYXBhY2l0eSAtIDFcbiAgOyBmcm9udCA9IDBcbiAgOyBsZW5ndGggPSAwXG4gIDsgYmFja3RyYWNlX29mX2ZpcnN0X2VucXVldWUgPSBOb25lXG4gIH1cbjs7XG5cbmxldCBiYWNrdHJhY2Vfb2ZfZmlyc3RfZW5xdWV1ZSB0ID0gdC5iYWNrdHJhY2Vfb2ZfZmlyc3RfZW5xdWV1ZVxuXG5sZXQgY2xlYXIgdCA9XG4gIHQuZnJvbnQgPC0gMDtcbiAgdC5sZW5ndGggPC0gMDtcbiAgdC5qb2JzX2xlZnRfdGhpc19jeWNsZSA8LSAwXG47O1xuXG5sZXQgZ3JvdyB0ID1cbiAgKG1hdGNoIHQuYmFja3RyYWNlX29mX2ZpcnN0X2VucXVldWUgd2l0aFxuICAgfCBTb21lIF8gLT4gYXNzZXJ0IChjYXBhY2l0eSB0ID4gMClcbiAgIHwgTm9uZSAtPiB0LmJhY2t0cmFjZV9vZl9maXJzdF9lbnF1ZXVlIDwtIFNvbWUgKEJhY2t0cmFjZS5nZXQgKCkpKTtcbiAgbGV0IG9sZF9jYXBhY2l0eSA9IGNhcGFjaXR5IHQgaW5cbiAgbGV0IG5ld19jYXBhY2l0eSA9IG1heCAxIChvbGRfY2FwYWNpdHkgKiAyKSBpblxuICBsZXQgb2xkX2pvYnMgPSB0LmpvYnMgaW5cbiAgbGV0IG9sZF9mcm9udCA9IHQuZnJvbnQgaW5cbiAgbGV0IGxlbjEgPSBJbnQubWluIHQubGVuZ3RoIChvbGRfY2FwYWNpdHkgLSBvbGRfZnJvbnQpICogc2xvdHNfcGVyX2VsdCBpblxuICBsZXQgbGVuMiA9ICh0Lmxlbmd0aCAqIHNsb3RzX3Blcl9lbHQpIC0gbGVuMSBpblxuICBsZXQgbmV3X2pvYnMgPSBjcmVhdGVfYXJyYXkgfmNhcGFjaXR5Om5ld19jYXBhY2l0eSBpblxuICBBLmJsaXRcbiAgICB+bGVuOmxlbjFcbiAgICB+c3JjOm9sZF9qb2JzXG4gICAgfnNyY19wb3M6KG9sZF9mcm9udCAqIHNsb3RzX3Blcl9lbHQpXG4gICAgfmRzdDpuZXdfam9ic1xuICAgIH5kc3RfcG9zOjA7XG4gIEEuYmxpdCB+bGVuOmxlbjIgfnNyYzpvbGRfam9icyB+c3JjX3BvczowIH5kc3Q6bmV3X2pvYnMgfmRzdF9wb3M6bGVuMTtcbiAgdC5tYXNrIDwtIG5ld19jYXBhY2l0eSAtIDE7XG4gIHQuam9icyA8LSBuZXdfam9icztcbiAgdC5mcm9udCA8LSAwXG47O1xuXG5sZXQgc2V0ICh0eXBlIGEpIHQgaSBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICBsZXQgb2Zmc2V0ID0gb2Zmc2V0IHQgaSBpblxuICBBLnVuc2FmZV9zZXQgdC5qb2JzIG9mZnNldCAoT2JqLnJlcHIgKGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudCkpO1xuICBBLnVuc2FmZV9zZXQgdC5qb2JzIChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgKGYgOiBhIC0+IHVuaXQpKTtcbiAgQS51bnNhZmVfc2V0IHQuam9icyAob2Zmc2V0ICsgMikgKE9iai5yZXByIChhIDogYSkpXG47O1xuXG5sZXQgZW5xdWV1ZSB0IGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIGlmIHQubGVuZ3RoID0gY2FwYWNpdHkgdCB0aGVuIGdyb3cgdDtcbiAgc2V0IHQgdC5sZW5ndGggZXhlY3V0aW9uX2NvbnRleHQgZiBhO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDFcbjs7XG5cbmxldCBzZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgdCBuID1cbiAgaWYgbiA8IDBcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZSBcIkpvYnMuc2V0X2pvYnNfbGVmdF90aGlzX2N5Y2xlIGdvdCBuZWdhdGl2ZSBudW1iZXJcIiAobiA6IGludCkgKHQgOiB0KV07XG4gIHQuam9ic19sZWZ0X3RoaXNfY3ljbGUgPC0gblxuOztcblxubGV0IGNhbl9ydW5fYV9qb2IgdCA9IHQubGVuZ3RoID4gMCAmJiB0LmpvYnNfbGVmdF90aGlzX2N5Y2xlID4gMFxuXG5sZXQgcnVuX2pvYiB0IChzY2hlZHVsZXIgOiBTY2hlZHVsZXIudCkgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgdC5udW1fam9ic19ydW4gPC0gdC5udW1fam9ic19ydW4gKyAxO1xuICBTY2hlZHVsZXIuc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dDtcbiAgZiBhXG47O1xuXG5sZXQgcnVuX2V4dGVybmFsX2pvYnMgdCAoc2NoZWR1bGVyIDogU2NoZWR1bGVyLnQpID1cbiAgbGV0IGV4dGVybmFsX2pvYnMgPSBzY2hlZHVsZXIuZXh0ZXJuYWxfam9icyBpblxuICB3aGlsZSBUaHJlYWRfc2FmZV9xdWV1ZS5sZW5ndGggZXh0ZXJuYWxfam9icyA+IDAgZG9cbiAgICBsZXQgKEV4dGVybmFsX2pvYi5UIChleGVjdXRpb25fY29udGV4dCwgZiwgYSkpID1cbiAgICAgIFRocmVhZF9zYWZlX3F1ZXVlLmRlcXVldWVfZXhuIGV4dGVybmFsX2pvYnNcbiAgICBpblxuICAgIHJ1bl9qb2IgdCBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgZiBhXG4gIGRvbmVcbjs7XG5cbmxldCBydW5fam9icyAodHlwZSBhKSB0IHNjaGVkdWxlciA9XG4gICgqIFdlIGRvIHRoZSBbdHJ5LXdpdGhdIG91dHNpZGUgb2YgdGhlIFt3aGlsZV0gYmVjYXVzZSBpdCBpcyBjaGVhcGVyIHRoYW4gZG9pbmcgYVxuICAgICBbdHJ5LXdpdGhdIGZvciBlYWNoIGpvYi4gKilcbiAgKCogW3J1bl9leHRlcm5hbF9qb2JzXSBiZWZvcmUgZW50ZXJpbmcgdGhlIGxvb3AsIHNpbmNlIGl0IG1pZ2h0IGVucXVldWUgYSBqb2IsXG4gICAgIGNoYW5naW5nIFt0Lmxlbmd0aF0uICopXG4gIHRyeVxuICAgIHJ1bl9leHRlcm5hbF9qb2JzIHQgc2NoZWR1bGVyO1xuICAgIHdoaWxlIGNhbl9ydW5fYV9qb2IgdCBkb1xuICAgICAgbGV0IHRoaXNfam9iID0gb2Zmc2V0IHQgMCBpblxuICAgICAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudCA9XG4gICAgICAgIE9iai5vYmogKEEudW5zYWZlX2dldCB0LmpvYnMgdGhpc19qb2IpXG4gICAgICBpblxuICAgICAgbGV0IGYgOiBhIC0+IHVuaXQgPSBPYmoub2JqIChBLnVuc2FmZV9nZXQgdC5qb2JzICh0aGlzX2pvYiArIDEpKSBpblxuICAgICAgbGV0IGEgOiBhID0gT2JqLm9iaiAoQS51bnNhZmVfZ2V0IHQuam9icyAodGhpc19qb2IgKyAyKSkgaW5cbiAgICAgICgqIFdlIGNsZWFyIG91dCB0aGUgam9iIHJpZ2h0IG5vdyBzbyB0aGF0IGl0IGlzbid0IGxpdmUgYXQgdGhlIG5leHQgbWlub3JcbiAgICAgICAgIGNvbGxlY3Rpb24uICBXZSB0cmllZCBub3QgZG9pbmcgdGhpcyBhbmQgc2F3IHNpZ25pZmljYW50ICgxNSUgb3Igc28pIHBlcmZvcm1hbmNlXG4gICAgICAgICBoaXRzIGR1ZSB0byBzcHVyaW91cyBwcm9tb3Rpb24uICopXG4gICAgICBzZXQgdCAwIGR1bW15X2UgZHVtbXlfZiBkdW1teV9hO1xuICAgICAgdC5mcm9udCA8LSAodC5mcm9udCArIDEpIGxhbmQgdC5tYXNrO1xuICAgICAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICAgICAgdC5qb2JzX2xlZnRfdGhpc19jeWNsZSA8LSB0LmpvYnNfbGVmdF90aGlzX2N5Y2xlIC0gMTtcbiAgICAgICgqIEl0IGlzIE9LIGlmIFtydW5fam9iXSBvciBbcnVuX2V4dGVybmFsX2pvYnNdIHJhaXNlcywgaW4gd2hpY2ggY2FzZSB0aGUgZXhuIGlzXG4gICAgICAgICBoYW5kbGVkIGJ5IHRoZSBvdXRlciB0cnktd2l0aC4gIFRoZSBvbmx5IHNpZGUgZWZmZWN0cyB3ZSBoYXZlIGRvbmUgYXJlIHRvIHRha2VcbiAgICAgICAgIHRoZSBqb2Igb3V0IG9mIHRoZSBxdWV1ZSBhbmQgZGVjcmVtZW50IFtqb2JzX2xlZnRfdGhpc19jeWNsZV0uICBbcnVuX2pvYl0gb3JcbiAgICAgICAgIFtydW5fZXh0ZXJuYWxfam9ic10gbWF5IHNpZGUgZWZmZWN0IFt0XSwgZWl0aGVyIGJ5IGVucXVldWVpbmcgam9icywgb3IgYnlcbiAgICAgICAgIGNsZWFyaW5nIFt0XS4gKilcbiAgICAgIHJ1bl9qb2IgdCBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgZiBhO1xuICAgICAgKCogW3J1bl9leHRlcm5hbF9qb2JzXSBhdCBlYWNoIGl0ZXJhdGlvbiBvZiB0aGUgW3doaWxlXSBsb29wLCBmb3IgZmFpcm5lc3MuICopXG4gICAgICBydW5fZXh0ZXJuYWxfam9icyB0IHNjaGVkdWxlclxuICAgIGRvbmU7XG4gICAgT2sgKClcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgICgqIFdlIGNhbGwgW0V4bi5iYWNrdHJhY2VdIGltbWVkaWF0ZWx5IGFmdGVyIGNhdGNoaW5nIGFuIHVuaGFuZGxlZCBleGNlcHRpb24sIHRvXG4gICAgICAgZW5zdXJlIHRoZXJlIGlzIG5vIGludGVydmVuaW5nIGNvZGUgdGhhdCBpbnRlcmZlcmVzIHdpdGggdGhlIGdsb2JhbCBiYWNrdHJhY2VcbiAgICAgICBzdGF0ZS4gKilcbiAgICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudCAoKSBpblxuICAgIEVycm9yIChleG4sIGJhY2t0cmFjZSlcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIFRpbWVfbnMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUaW1lX25zXG5cbiAgZXh0ZXJuYWwgZm9ybWF0IDogZmxvYXQgLT4gc3RyaW5nIC0+IHN0cmluZyA9IFwiY29yZV90aW1lX25zX2Zvcm1hdFwiXG5cbiAgKCogV2UgdXNlIGEgbW9yZSBwbGVhc2FudCBmb3JtYXQgdGhhbiBbQ29yZS5UaW1lX25zLnNleHBfb2ZfdF0sXG4gICAgIHdoaWNoIGhhcyB0byBiZSBtZXNzaWVyIGZvciByb3VuZCB0cmlwcGFiaWxpdHkuICopXG4gIGxldCBzZXhwX29mX3QgdCA9XG4gICAgWyVzZXhwXG4gICAgICAoZm9ybWF0ICh0IHw+IHRvX3NwYW5fc2luY2VfZXBvY2ggfD4gU3Bhbi50b19zZWMpIFwiJVktJW0tJWRUJUg6JU06JVMlelwiIDogc3RyaW5nKV1cbiAgOztcbmVuZFxuXG5tb2R1bGUgQWxhcm0gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUaW1pbmdfd2hlZWwuQWxhcm1cblxuICBsZXQgaXNfbnVsbCB0ID0gcGh5c19lcXVhbCB0IChudWxsICgpKVxuZW5kXG5cbm1vZHVsZSBBbGFybV9wcmVjaXNpb24gPSBUaW1pbmdfd2hlZWwuQWxhcm1fcHJlY2lzaW9uXG5cbmxldCBkZWZhdWx0X3RpbWluZ193aGVlbF9jb25maWcgPVxuICAoKiAxLzh0aCBvZiBhIG1pbGxpc2Vjb25kIGFsYXJtX3ByZWNpc2lvbiBzZWVtcyBzdWZmaWNpZW50IHRvIGF2b2lkIGhhdmluZyBtYW55IGFsYXJtc1xuICAgICBpbiB0aGUgc2FtZSBpbnRlcnZhbCwgd2hpY2ggYXZvaWRzIHF1YWRyYXRpYyBpbnNlcnRpb24gc29ydCB3aGVuIGZpcmluZyBhbGFybXMuICBBbmRcbiAgICAgdGhlIGxldmVsIGJpdHMgZ2l2ZSB1cyBsZXZlbHMgb2YgPjFzLCA+MW0sID4xaCwgPjFkLiAgU2VlIHRlc3QgaW5cbiAgICAgWy4uL3Rlc3QvdGVzdF9zeW5jaHJvbm91c190aW1lX3NvdXJjZS5tbF0uICopXG4gIFRpbWluZ193aGVlbC5Db25maWcuY3JlYXRlXG4gICAgfmFsYXJtX3ByZWNpc2lvbjpBbGFybV9wcmVjaXNpb24uKGRpdiBhYm91dF9vbmVfbWlsbGlzZWNvbmQgfnBvdzI6MylcbiAgICB+bGV2ZWxfYml0czooVGltaW5nX3doZWVsLkxldmVsX2JpdHMuY3JlYXRlX2V4biBbIDEzOyA2OyA2OyA1IF0pXG4gICAgKClcbjs7XG5cbnR5cGUgY2FsbGJhY2sgPSB1bml0IC0+IHVuaXRcblxubW9kdWxlIElkID0gVHlwZXMuVGltZV9zb3VyY2VfaWRcblxubW9kdWxlIFQxID0gc3RydWN0XG4gIG1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICAgIG1vZHVsZSBTdGF0dXMgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IFR5cGVzLkV2ZW50LlN0YXR1cy50ID1cbiAgICAgICAgfCBGaXJlZCAoKiBpbiBbZmlyZWRfZXZlbnRzXSwgcmVhZHkgdG8gcnVuICopXG4gICAgICAgIHwgSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50XG4gICAgICAgICgqIGN1cnJlbnRseSBydW5uaW5nIHRoZSBjYWxsYmFjayAoZm9yIGEgcGVyaW9kaWMgZXZlbnQpICopXG4gICAgICAgIHwgU2NoZWR1bGVkICgqIGluIHRoZSB0aW1pbmcgd2hlZWwgKilcbiAgICAgICAgfCBVbnNjaGVkdWxlZCAoKiBub3QgaW4gdGltaW5nIHdoZWVsIG9yIFtmaXJlZF9ldmVudHNdICopXG4gICAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICAgICAgbGV0IHRyYW5zaXRpb25faXNfYWxsb3dlZCB+ZnJvbSB+dG9fID1cbiAgICAgICAgbWF0Y2ggZnJvbSwgdG9fIHdpdGhcbiAgICAgICAgfCAoIEZpcmVkXG4gICAgICAgICAgLCBIYXBwZW5pbmdfcGVyaW9kaWNfZXZlbnQgKCogc3RhcnRlZCBydW5uaW5nIGNhbGxiYWNrIChmb3IgYSBwZXJpb2RpYyBldmVudCkgKilcbiAgICAgICAgICApXG4gICAgICAgIHwgKCBGaXJlZFxuICAgICAgICAgICwgVW5zY2hlZHVsZWRcbiAgICAgICAgICAgICgqIGFib3J0ZWQsIG9yIHN0YXJ0ZWQgcnVubmluZyBjYWxsYmFjayAoZm9yIGEgbm9uLXBlcmlvZGljIGV2ZW50KSAqKSApXG4gICAgICAgICgqIFtyZXNjaGVkdWxlXypdIGdvZXMgdGhyb3VnaCBhbiBpbnRlcm1lZGlhdGUgW0ZpcmVkLCBVbnNjaGVkdWxlZF0gc3RhdGUsXG4gICAgICAgICAgIHNvIHdlIG5ldmVyIHRyYW5zaXRpb24gZnJvbSBbRmlyZWRdIGRpcmVjdGx5IHRvIFtTY2hlZHVsZWRdLiAqKVxuICAgICAgICB8ICggSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50XG4gICAgICAgICAgLCBTY2hlZHVsZWQgKCogc2NoZWR1bGVkIG5leHQgaXRlcmF0aW9uIG9mIGEgcGVyaW9kaWMgZXZlbnQgKikgKVxuICAgICAgICB8IEhhcHBlbmluZ19wZXJpb2RpY19ldmVudCwgVW5zY2hlZHVsZWQgKCogYWJvcnRlZCAqKVxuICAgICAgICB8IFNjaGVkdWxlZCwgRmlyZWQgKCogbW92ZWQgZnJvbSB0aW1pbmcgd2hlZWwgdG8gW2ZpcmVkX2V2ZW50c10gKilcbiAgICAgICAgfCBTY2hlZHVsZWQsIFVuc2NoZWR1bGVkICgqIGFib3J0ZWQgKilcbiAgICAgICAgfCBVbnNjaGVkdWxlZCwgRmlyZWQgKCogZXZlbnQgc2NoZWR1bGVkIGluIHRoZSBwYXN0ICopXG4gICAgICAgIHwgVW5zY2hlZHVsZWQsIFNjaGVkdWxlZCAoKiBldmVudCBzY2hlZHVsZWQgaW4gdGhlIGZ1dHVyZSAqKSAtPiB0cnVlXG4gICAgICAgIHwgKEZpcmVkIHwgSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IHwgU2NoZWR1bGVkIHwgVW5zY2hlZHVsZWQpLCBfIC0+IGZhbHNlXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgdHlwZSBldmVudCA9IFR5cGVzLkV2ZW50LnRcblxuICAgIGxldCBzZXhwX29mX2V2ZW50XG4gICAgICAoeyBhbGFybSA9IF9cbiAgICAgICA7IGF0XG4gICAgICAgOyBjYWxsYmFjayA9IF9cbiAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0ID0gX1xuICAgICAgIDsgaW50ZXJ2YWxcbiAgICAgICA7IG5leHRfZmlyZWQgPSBfXG4gICAgICAgOyBwcmV2X2ZpcmVkID0gX1xuICAgICAgIDsgc3RhdHVzXG4gICAgICAgfSA6XG4gICAgICAgIGV2ZW50KVxuICAgICAgPVxuICAgICAgWyVzZXhwXG4gICAgICAgIHsgc3RhdHVzIDogU3RhdHVzLnRcbiAgICAgICAgOyBhdCA6IFRpbWVfbnMudFxuICAgICAgICA7IGludGVydmFsIDogKFRpbWVfbnMuU3Bhbi50IG9wdGlvbltAc2V4cC5vcHRpb25dKVxuICAgICAgICB9XVxuICAgIDs7XG5cbiAgICBtb2R1bGUgT3B0aW9uID0gc3RydWN0XG4gICAgICAoKiBUaGlzIHJlZGVmaW5pdGlvbiBvZiBbRXZlbnRdIGlzIGhlcmUgc28gdGhlIHR5cGUgY2hlY2tzIGFyZSByaWdodCBuZXh0XG4gICAgICAgICB0byBbT2JqLm1hZ2ljXXMuICopXG4gICAgICBtb2R1bGUgRXZlbnRfaXNfYmxvY2sgOiBzaWcgZW5kID0gc3RydWN0XG4gICAgICAgIG9wZW4gVHlwZXNcbiAgICAgICAgb3BlbiBFdmVudFxuXG4gICAgICAgIHR5cGUgX3QgPSB0ID1cbiAgICAgICAgICB7ICgqIG11c3QgbmV2ZXIgYmUgaW1tZWRpYXRlICopXG4gICAgICAgICAgICBtdXRhYmxlIGFsYXJtIDogSm9iX29yX2V2ZW50LnQgVGltaW5nX3doZWVsLkFsYXJtLnRcbiAgICAgICAgICA7IG11dGFibGUgYXQgOiBUaW1lX25zLnRcbiAgICAgICAgICA7IGNhbGxiYWNrIDogdW5pdCAtPiB1bml0XG4gICAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgICAgICA7IG11dGFibGUgaW50ZXJ2YWwgOiBUaW1lX25zLlNwYW4udCBvcHRpb25cbiAgICAgICAgICA7IG11dGFibGUgbmV4dF9maXJlZCA6IE9wdGlvbi50XG4gICAgICAgICAgOyBtdXRhYmxlIHByZXZfZmlyZWQgOiBPcHRpb24udFxuICAgICAgICAgIDsgbXV0YWJsZSBzdGF0dXMgOiBTdGF0dXMudFxuICAgICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICB0eXBlIHQgPSBUeXBlcy5FdmVudC5PcHRpb24udFxuXG4gICAgICAoKiBVc2luZyBhbiBpbW1lZGlhdGUgcmF0aGVyIHRoYW4gYSBzdGF0aWNhbGx5LWFsbG9jYXRlZCByZWNvcmQgaGVyZSBzZWVtcyB0b1xuICAgICAgICAgaW1wcm92ZSBwZXJmb3JtYW5jZSBub3RpY2VhYmx5IChbLi4vYmVuY2gvYmluL2JlbmNoX3RpbWVfc291cmNlLmV4ZV0gYmVuY2htYXJrXG4gICAgICAgICBpcyBmYXN0ZXIgYnkgfjEwbnMgcGVyIGFsYXJtKSwgcHJlc3VtYWJseSBiZWNhdXNlIGl0IGF2b2lkcyB0aGUgZXhwZW5zaXZlXG4gICAgICAgICBwYXJ0cyBvZiBjYW1sX21vZGlmeS4gKilcbiAgICAgIGxldCBub25lID0gKE9iai5tYWdpYyBOb25lIDogdCkgKCogYW4gYXJiaXRyYXJ5IGltbWVkaWF0ZSAqKVxuICAgICAgbGV0IHNvbWUgPSAoT2JqLm1hZ2ljIDogVHlwZXMuRXZlbnQudCAtPiB0KVxuICAgICAgbGV0IGlzX25vbmUgdCA9IHBoeXNfZXF1YWwgdCBub25lXG4gICAgICBsZXQgaXNfc29tZSB0ID0gbm90IChpc19ub25lIHQpXG4gICAgICBsZXQgZmlyc3Rfc29tZSB0MSB0MiA9IGlmIGlzX3NvbWUgdDEgdGhlbiB0MSBlbHNlIHQyXG4gICAgICBsZXQgdW5zYWZlX3ZhbHVlID0gKE9iai5tYWdpYyA6IHQgLT4gVHlwZXMuRXZlbnQudClcblxuICAgICAgbW9kdWxlIE9wdGlvbmFsX3N5bnRheCA9IHN0cnVjdFxuICAgICAgICBtb2R1bGUgT3B0aW9uYWxfc3ludGF4ID0gc3RydWN0XG4gICAgICAgICAgbGV0IGlzX25vbmUgPSBpc19ub25lXG4gICAgICAgICAgbGV0IHVuc2FmZV92YWx1ZSA9IHVuc2FmZV92YWx1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBvcGVuIE9wdGlvbmFsX3N5bnRheFxuXG4gICAgICBsZXQgc2V4cF9vZl90IHQgPVxuICAgICAgICBtYXRjaCVvcHRpb25hbCB0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFslc2V4cCAoKV1cbiAgICAgICAgfCBTb21lIGV2ZW50IC0+IFslc2V4cCAoZXZlbnQgOiBldmVudCldXG4gICAgICA7O1xuXG4gICAgICBsZXQgdmFsdWUgdCB+ZGVmYXVsdCA9IEJvb2wuc2VsZWN0IChpc19ub25lIHQpIGRlZmF1bHQgKHVuc2FmZV92YWx1ZSB0KVxuXG4gICAgICBsZXQgdmFsdWVfZXhuIHQgPVxuICAgICAgICBtYXRjaCVvcHRpb25hbCB0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHJhaXNlX3MgWyVzZXhwIFwiW1N5bmNocm9ub3VzX3RpbWVfc291cmNlLkV2ZW50Lk9wdGlvbi52YWx1ZV9leG4gTm9uZV1cIl1cbiAgICAgICAgfCBTb21lIGV2ZW50IC0+IGV2ZW50XG4gICAgICA7O1xuXG4gICAgICBsZXQgdG9fb3B0aW9uIHQgPVxuICAgICAgICBtYXRjaCVvcHRpb25hbCB0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGV2ZW50IC0+IFNvbWUgZXZlbnRcbiAgICAgIDs7XG5cbiAgICAgIGxldCBvZl9vcHRpb24gPSBmdW5jdGlvblxuICAgICAgICB8IE5vbmUgLT4gbm9uZVxuICAgICAgICB8IFNvbWUgZXZlbnQgLT4gc29tZSBldmVudFxuICAgICAgOztcbiAgICBlbmRcblxuICAgIHR5cGUgdCA9IFR5cGVzLkV2ZW50LnQgPVxuICAgICAgeyAoKiBbYWxhcm1dIGlzIG5vbi1udWxsIGlmZiB0aGUgZXZlbnQgaXMgaW4gdGhlIHRpbWluZyB3aGVlbC4gKilcbiAgICAgICAgbXV0YWJsZSBhbGFybSA6IEpvYl9vcl9ldmVudC50IEFsYXJtLnRcbiAgICAgIDsgbXV0YWJsZSBhdCA6IFRpbWVfbnMudFxuICAgICAgOyBjYWxsYmFjayA6IHVuaXQgLT4gdW5pdFxuICAgICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgIDsgKCogW2ludGVydmFsXSBpcyB0aGUgcGVyaW9kIGZvciB0aGUgcGVyaW9kaWMgZXZlbnRzLiAqKVxuICAgICAgICBtdXRhYmxlIGludGVydmFsIDogVGltZV9ucy5TcGFuLnQgb3B0aW9uXG4gICAgICA7ICgqIFtuZXh0X2ZpcmVkXSBhbmQgW3ByZXZfZmlyZWRdIGNyZWF0ZSBhIGRvdWJseS1saW5rZWQgKG5vbi1jaXJjdWxhcikgbGlzdCBvZlxuICAgICAgICAgICBmaXJlZCBldmVudHMsIGxpbmtlZCB2aWEgdGhlc2UgZmllbGRzLiBBbiBldmVudCBpcyBhZGRlZCB0byB0aGUgbGlzdCB3aGVuXG4gICAgICAgICAgIGl0IGZpcmVzLCBlaXRoZXIgYmVjYXVzZSBpdCBpcyBhZGRlZCB3aXRoIGEgdGltZSBpbiB0aGUgcGFzdCwgb3JcbiAgICAgICAgICAgYmVjYXVzZSB0aW1lIGFkdmFuY2VzLiBbYWR2YW5jZV9ieV9hbGFybXNdIGl0ZXJhdGVzIG92ZXIgdGhlIGV2ZW50c1xuICAgICAgICAgICBpbiBbbmV4dF9maXJlZF0gYW5kIHJ1bnMgdGhlbSwgZW1wdHlpbmcgdGhlIGxpc3QuIFtub25lXSBpcyB1c2VkIHRvXG4gICAgICAgICAgIGluZGljYXRlIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0IG9mIGZpcmVkIGV2ZW50cy4gKilcbiAgICAgICAgbXV0YWJsZSBuZXh0X2ZpcmVkIDogT3B0aW9uLnRcbiAgICAgIDsgbXV0YWJsZSBwcmV2X2ZpcmVkIDogT3B0aW9uLnRcbiAgICAgIDsgbXV0YWJsZSBzdGF0dXMgOiBTdGF0dXMudFxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycyB+aXRlcmF0b3JzOml0ZXJdXG5cbiAgICBsZXQgc2V4cF9vZl90ID0gWyVzZXhwX29mOiBldmVudF1cblxuICAgIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgICAgfmFsYXJtOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gYWxhcm0gLT5cbiAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IGJvb2xdXG4gICAgICAgICAgICAgICAgIChBbGFybS5pc19udWxsIGFsYXJtKVxuICAgICAgICAgICAgICAgICB+ZXhwZWN0OlxuICAgICAgICAgICAgICAgICAgIChtYXRjaCB0LnN0YXR1cyB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgRmlyZWQgfCBIYXBwZW5pbmdfcGVyaW9kaWNfZXZlbnQgfCBVbnNjaGVkdWxlZCAtPiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHwgU2NoZWR1bGVkIC0+IGZhbHNlKSkpXG4gICAgICAgICAgfmF0Omlnbm9yZVxuICAgICAgICAgIH5jYWxsYmFjazppZ25vcmVcbiAgICAgICAgICB+ZXhlY3V0aW9uX2NvbnRleHQ6aWdub3JlXG4gICAgICAgICAgfmludGVydmFsOmlnbm9yZVxuICAgICAgICAgIH5uZXh0X2ZpcmVkOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbmV4dF9maXJlZCAtPlxuICAgICAgICAgICAgICAgbWF0Y2glb3B0aW9uYWwgKG5leHRfZmlyZWQgOiBPcHRpb24udCkgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICgqIFtuZXh0X2ZpcmVkXSBjYW4gYmUgW05vbmVdIGV2ZW4gaWYgdGhlIGV2ZW50IHN0YXR1cyBpcyBGaXJlZCwgYXNzdW1pbmdcbiAgICAgICAgICAgICAgICAgICAgaXQncyBhdCB0aGUgZW5kIG9mIHRoZSBmaXJlZCBldmVudHMgbGlzdCAqKVxuICAgICAgICAgICAgICAgICAoKVxuICAgICAgICAgICAgICAgfCBTb21lIG5leHRfZmlyZWQgLT5cbiAgICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogU3RhdHVzLnRdIHQuc3RhdHVzIH5leHBlY3Q6RmlyZWQ7XG4gICAgICAgICAgICAgICAgIGFzc2VydCAocGh5c19lcXVhbCAoT3B0aW9uLnNvbWUgdCkgbmV4dF9maXJlZC5wcmV2X2ZpcmVkKSkpXG4gICAgICAgICAgfnByZXZfZmlyZWQ6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBwcmV2X2ZpcmVkIC0+XG4gICAgICAgICAgICAgICBtYXRjaCVvcHRpb25hbCAocHJldl9maXJlZCA6IE9wdGlvbi50KSB3aXRoXG4gICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgKCogW3ByZXZfZmlyZWRdIGNhbiBiZSBbTm9uZV0gZXZlbiBpZiB0aGUgZXZlbnQgc3RhdHVzIGlzIEZpcmVkLCBhc3N1bWluZ1xuICAgICAgICAgICAgICAgICAgICBpdCdzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpcmVkIGV2ZW50cyBsaXN0ICopXG4gICAgICAgICAgICAgICAgICgpXG4gICAgICAgICAgICAgICB8IFNvbWUgcHJldl9maXJlZCAtPlxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBTdGF0dXMudF0gdC5zdGF0dXMgfmV4cGVjdDpGaXJlZDtcbiAgICAgICAgICAgICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsIChPcHRpb24uc29tZSB0KSBwcmV2X2ZpcmVkLm5leHRfZmlyZWQpKSlcbiAgICAgICAgICB+c3RhdHVzOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gKHN0YXR1cyA6IFN0YXR1cy50KSAtPlxuICAgICAgICAgICAgICAgbWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICAgICAgIHwgSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IC0+IGFzc2VydCAoQ29yZS5PcHRpb24uaXNfc29tZSB0LmludGVydmFsKVxuICAgICAgICAgICAgICAgfCBGaXJlZCB8IFVuc2NoZWR1bGVkIHwgU2NoZWR1bGVkIC0+ICgpKSkpXG4gICAgOztcblxuICAgIGxldCBzZXRfc3RhdHVzIHQgdG9fID1cbiAgICAgIGxldCBmcm9tID0gdC5zdGF0dXMgaW5cbiAgICAgIGlmIG5vdCAoU3RhdHVzLnRyYW5zaXRpb25faXNfYWxsb3dlZCB+ZnJvbSB+dG9fKVxuICAgICAgdGhlblxuICAgICAgICByYWlzZV9zXG4gICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICBbJWhlcmVdXG4gICAgICAgICAgICAgIFwiYnVnIC0tIHNldF9zdGF0dXMgdHJhbnNpdGlvbiBub3QgYWxsb3dlZFwiXG4gICAgICAgICAgICAgIChmcm9tIDogU3RhdHVzLnQpXG4gICAgICAgICAgICAgICh0b18gOiBTdGF0dXMudClcbiAgICAgICAgICAgICAgfmV2ZW50Oih0IDogdCldO1xuICAgICAgdC5zdGF0dXMgPC0gdG9fXG4gICAgOztcblxuICAgIGxldCBzZXRfc3RhdHVzX2lmIH5pcyB0IHRvXyA9IGlmIFN0YXR1cy5lcXVhbCBpcyB0LnN0YXR1cyB0aGVuIHNldF9zdGF0dXMgdCB0b19cbiAgICBsZXQgc2NoZWR1bGVkX2F0ID0gYXRcbiAgZW5kXG5cbiAgbW9kdWxlIEpvYl9vcl9ldmVudCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgSm9iX29yX2V2ZW50XG5cbiAgICBsZXQgc2V4cF9vZl90IHQgPVxuICAgICAgbGV0IG9wZW4gSm9iX29yX2V2ZW50Lk1hdGNoIGluXG4gICAgICBsZXQgKEsgaykgPSBraW5kIHQgaW5cbiAgICAgIG1hdGNoIGssIHByb2plY3QgayB0IHdpdGhcbiAgICAgIHwgRXZlbnQsIGV2ZW50IC0+IFslc2V4cCAoZXZlbnQgOiBFdmVudC50KV1cbiAgICAgIHwgSm9iLCBfIC0+XG4gICAgICAgICgqIFdlIGRvbid0IGRpc3BsYXkgdGhlIFtKb2IudF1zIGluIFtldmVudHNdIGJlY2F1c2UgdGhvc2UgYXJlXG4gICAgICAgICAgIHBvb2wgcG9pbnRlcnMsIHdoaWNoIGFyZSB1bmluZm9ybWF0aXZlLiAqKVxuICAgICAgICBbJW1lc3NhZ2UgXCI8Sm9iLnQ+XCJdXG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSAtJ3J3IHQgPSAncncgVHlwZXMuVGltZV9zb3VyY2UudDEgPVxuICAgIHsgaWQgOiBJZC50XG4gICAgOyAoKiBbYWR2YW5jZV9lcnJvcnNdIGFjY3VtdWxhdGVzIGVycm9ycyByYWlzZWQgYnkgYWxhcm1zIHJ1biBieVxuICAgICAgICAgW2FkdmFuY2VfYnlfYWxhcm1zXS4gKilcbiAgICAgIG11dGFibGUgYWR2YW5jZV9lcnJvcnMgOiBFcnJvci50IGxpc3RcbiAgICA7ICgqIFthbV9hZHZhbmNpbmddIGlzIHRydWUgb25seSBkdXJpbmcgW2FkdmFuY2VfYnlfYWxhcm1zXSwgYW5kIGlzIHVzZWQgdG8gY2F1c2VcbiAgICAgICAgIGNhbGxiYWNrcyB0byByYWlzZSBpZiB0aGV5IGNhbGwgW2FkdmFuY2VfYnlfYWxhcm1zXS4gKilcbiAgICAgIG11dGFibGUgYW1fYWR2YW5jaW5nIDogYm9vbFxuICAgIDsgZXZlbnRzIDogSm9iX29yX2V2ZW50LnQgVGltaW5nX3doZWVsLnRcbiAgICA7ICgqIFtmaXJlZF9ldmVudHNdIGlzIHRoZSBmcm9udCBvZiB0aGUgZG91Ymx5LWxpbmtlZCBsaXN0IG9mIGZpcmVkIGV2ZW50cyxcbiAgICAgICAgIHdoaWNoIGlzIHN0b3JlZCBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIFtFdmVudC5hdF0uICopXG4gICAgICBtdXRhYmxlIGZpcmVkX2V2ZW50cyA6IEV2ZW50Lk9wdGlvbi50XG4gICAgOyAoKiBbbW9zdF9yZWNlbnRseV9maXJlZF0gaXMgdGhlIGV2ZW50IHRoYXQgd2FzIG1vc3QgcmVjZW50bHkgaW5zZXJ0ZWQgaW50b1xuICAgICAgICAgW2ZpcmVkX2V2ZW50c10uIEl0IGlzIHVzZWQgYXMgYW4gb3B0aW1pemF0aW9uIHRvIGFsbG93IGluc2VydGlvbiBvZlxuICAgICAgICAgc3Vic2VxdWVudCBldmVudHMgdG8gc3RhcnQgbGF0ZXIgaW4gdGhlIGxpc3QgcmF0aGVyIHRoYW4gYXQgdGhlIGJlZ2lubmluZy5cbiAgICAgICAgIEl0IHNwZWNpZmljYWxseSBhdm9pZHMgcXVhZHJhdGljIGJlaGF2aW9yIHdoZW4gaW5zZXJ0aW5nIG11bHRpcGxlIGV2ZW50c1xuICAgICAgICAgdGhhdCBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGltZSAtLSB0aGUgdGltZSBzb3VyY2UgZmlyZXMgc3VjaCBldmVudHMgaW5cbiAgICAgICAgIHRoZSBvcmRlciB0aGV5IHdlcmUgYWRkZWQsIGFuZCB3ZSB3YW50IHRoZW0gdG8gYmUgaW4gdGhhdCBzYW1lIG9yZGVyIGluXG4gICAgICAgICBbZmlyZWRfZXZlbnRzXS4gKilcbiAgICAgIG11dGFibGUgbW9zdF9yZWNlbnRseV9maXJlZCA6IEV2ZW50Lk9wdGlvbi50XG4gICAgOyAoKiBXZSBzdG9yZSBbaGFuZGxlX2ZpcmVkXSBpbiBbdF0gdG8gYXZvaWQgYWxsb2NhdGluZyBpdCBldmVyeSB0aW1lIHdlIGNhbGxcbiAgICAgICAgIFthZHZhbmNlX2Nsb2NrXS4gKilcbiAgICAgIGhhbmRsZV9maXJlZCA6IEpvYl9vcl9ldmVudC50IEFsYXJtLnQgLT4gdW5pdFxuICAgIDsgaXNfd2FsbF9jbG9jayA6IGJvb2xcbiAgICA7IHNjaGVkdWxlciA6IFNjaGVkdWxlcjAudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlcl1cblxuICAoKiBXZSBkb24ndCBpbmNsdWRlIHRoZSBbaWRdIGluIHRoZSBzZXhwIGJlY2F1c2UgdGhlIHVzZXIgKHJpZ2h0bHkpIGNhbid0IGNvbnRyb2wgaXQsIHNvXG4gICAgIGl0J3MgaGFyZCB0byBtYWtlIGl0IGRldGVybWluaXN0aWMgaW4gdGVzdHMuICopXG4gIGxldCBzZXhwX29mX3RcbiAgICBfXG4gICAgeyBpZCA9IF9cbiAgICA7IGFkdmFuY2VfZXJyb3JzID0gX1xuICAgIDsgYW1fYWR2YW5jaW5nID0gX1xuICAgIDsgZXZlbnRzXG4gICAgOyBmaXJlZF9ldmVudHMgPSBfXG4gICAgOyBoYW5kbGVfZmlyZWQgPSBfXG4gICAgOyBpc193YWxsX2Nsb2NrXG4gICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gX1xuICAgIDsgc2NoZWR1bGVyID0gX1xuICAgIH1cbiAgICA9XG4gICAgbGV0IG5vdyA9IFRpbWluZ193aGVlbC5ub3cgZXZlbnRzIGluXG4gICAgaWYgaXNfd2FsbF9jbG9ja1xuICAgIHRoZW4gWyVtZXNzYWdlIFwid2FsbF9jbG9ja1wiIChub3cgOiBUaW1lX25zLnQpXVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGFsbF9ldmVudHMgPSByZWYgW10gaW5cbiAgICAgIFRpbWluZ193aGVlbC5pdGVyIGV2ZW50cyB+ZjooZnVuIGFsYXJtIC0+XG4gICAgICAgIGFsbF9ldmVudHMgOj0gKEFsYXJtLmF0IGV2ZW50cyBhbGFybSwgQWxhcm0udmFsdWUgZXZlbnRzIGFsYXJtKSA6OiAhYWxsX2V2ZW50cyk7XG4gICAgICBsZXQgZXZlbnRzID1cbiAgICAgICAgTGlzdC5zb3J0ICFhbGxfZXZlbnRzIH5jb21wYXJlOihmdW4gKGF0MSwgXykgKGF0MiwgXykgLT4gVGltZV9ucy5jb21wYXJlIGF0MSBhdDIpXG4gICAgICAgIHw+IExpc3QubWFwIH5mOnNuZFxuICAgICAgaW5cbiAgICAgIFslbWVzc2FnZSBcIlwiIChub3cgOiBUaW1lX25zLnQpIChldmVudHMgOiBKb2Jfb3JfZXZlbnQudCBsaXN0KV0pXG4gIDs7XG5cbiAgbGV0IHRpbWluZ193aGVlbF9ub3cgdCA9IFRpbWluZ193aGVlbC5ub3cgdC5ldmVudHNcblxuICBsZXQgaXNfaW5fZmlyZWRfZXZlbnRzID1cbiAgICBsZXQgcmVjIHNlYXJjaCBjdXJyZW50IH50YXJnZXRfZXZlbnQgPVxuICAgICAgbWF0Y2glb3B0aW9uYWwgKGN1cnJlbnQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICB8IFNvbWUgY3VycmVudCAtPlxuICAgICAgICBwaHlzX2VxdWFsIGN1cnJlbnQgdGFyZ2V0X2V2ZW50IHx8IHNlYXJjaCBjdXJyZW50Lm5leHRfZmlyZWQgfnRhcmdldF9ldmVudFxuICAgIGluXG4gICAgZnVuIHQgdGFyZ2V0X2V2ZW50IC0+IHNlYXJjaCB0LmZpcmVkX2V2ZW50cyB+dGFyZ2V0X2V2ZW50XG4gIDs7XG5cbiAgbGV0IGludmFyaWFudF93aXRoX2pvYnMgKHR5cGUgcncpIH5qb2I6KGpvYl9pbnZhcmlhbnQgOiBKb2IudCAtPiB1bml0KSAodCA6IHJ3IHQpID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+aWQ6aWdub3JlXG4gICAgICAgIH5hZHZhbmNlX2Vycm9yczppZ25vcmVcbiAgICAgICAgfmFtX2FkdmFuY2luZzppZ25vcmVcbiAgICAgICAgfmV2ZW50czpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBldmVudHMgLT5cbiAgICAgICAgICAgICBUaW1pbmdfd2hlZWwuaW52YXJpYW50IGlnbm9yZSBldmVudHM7XG4gICAgICAgICAgICAgVGltaW5nX3doZWVsLml0ZXIgZXZlbnRzIH5mOihmdW4gYWxhcm0gLT5cbiAgICAgICAgICAgICAgIGxldCBqb2Jfb3JfZXZlbnQgPSBBbGFybS52YWx1ZSBldmVudHMgYWxhcm0gaW5cbiAgICAgICAgICAgICAgIGxldCBvcGVuIEpvYl9vcl9ldmVudC5NYXRjaCBpblxuICAgICAgICAgICAgICAgbGV0IChLIGspID0ga2luZCBqb2Jfb3JfZXZlbnQgaW5cbiAgICAgICAgICAgICAgIG1hdGNoIGssIHByb2plY3QgayBqb2Jfb3JfZXZlbnQgd2l0aFxuICAgICAgICAgICAgICAgfCBKb2IsIGpvYiAtPiBqb2JfaW52YXJpYW50IGpvYlxuICAgICAgICAgICAgICAgfCBFdmVudCwgZXZlbnQgLT5cbiAgICAgICAgICAgICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsIGFsYXJtIGV2ZW50LmFsYXJtKTtcbiAgICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogVGltZV9ucy50XSBldmVudC5hdCB+ZXhwZWN0OihBbGFybS5hdCBldmVudHMgYWxhcm0pO1xuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBFdmVudC5TdGF0dXMudF0gZXZlbnQuc3RhdHVzIH5leHBlY3Q6U2NoZWR1bGVkO1xuICAgICAgICAgICAgICAgICBFdmVudC5pbnZhcmlhbnQgZXZlbnQpKSlcbiAgICAgICAgfmZpcmVkX2V2ZW50czpcbiAgICAgICAgICAoY2hlY2sgKGZ1biAoZmlyZWRfZXZlbnRzIDogRXZlbnQuT3B0aW9uLnQpIC0+XG4gICAgICAgICAgICAgbGV0IHJlYyBjaGVja19ldmVudCAoY3VycmVudCA6IEV2ZW50LnQpID1cbiAgICAgICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oIDw9ICkgY3VycmVudC5hdCAodGltaW5nX3doZWVsX25vdyB0KSk7XG4gICAgICAgICAgICAgICBtYXRjaCVvcHRpb25hbC5FdmVudC5PcHRpb24gY3VycmVudC5uZXh0X2ZpcmVkIHdpdGhcbiAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgICAgfCBTb21lIG5leHQgLT5cbiAgICAgICAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPD0gKSBjdXJyZW50LmF0IG5leHQuYXQpO1xuICAgICAgICAgICAgICAgICBjaGVja19ldmVudCBuZXh0XG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBtYXRjaCVvcHRpb25hbC5FdmVudC5PcHRpb24gZmlyZWRfZXZlbnRzIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgICB8IFNvbWUgZXZlbnQgLT4gY2hlY2tfZXZlbnQgZXZlbnQpKVxuICAgICAgICB+aGFuZGxlX2ZpcmVkOmlnbm9yZVxuICAgICAgICB+aXNfd2FsbF9jbG9jazppZ25vcmVcbiAgICAgICAgfm1vc3RfcmVjZW50bHlfZmlyZWQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gbW9zdF9yZWNlbnRseV9maXJlZCAtPlxuICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsIChtb3N0X3JlY2VudGx5X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgICB8IFNvbWUgZXZlbnQgLT4gYXNzZXJ0IChpc19pbl9maXJlZF9ldmVudHMgdCBldmVudCkpKVxuICAgICAgICB+c2NoZWR1bGVyOmlnbm9yZSlcbiAgOztcblxuICBsZXQgaW52YXJpYW50IHQgPSBpbnZhcmlhbnRfd2l0aF9qb2JzIH5qb2I6KGZ1biBfIC0+ICgpKSB0XG5lbmRcblxub3BlbiBUMVxuXG50eXBlIHQgPSByZWFkIFQxLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCA9IGludmFyaWFudFxubGV0IGludmFyaWFudF93aXRoX2pvYnMgPSBpbnZhcmlhbnRfd2l0aF9qb2JzXG5cbm1vZHVsZSBSZWFkX3dyaXRlID0gc3RydWN0XG4gIHR5cGUgdCA9IHJlYWRfd3JpdGUgVDEudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbiAgbGV0IGludmFyaWFudF93aXRoX2pvYnMgPSBpbnZhcmlhbnRfd2l0aF9qb2JzXG5lbmRcblxubGV0IGlkIHQgPSB0LmlkXG5sZXQgaXNfd2FsbF9jbG9jayB0ID0gdC5pc193YWxsX2Nsb2NrXG5sZXQgbGVuZ3RoIHQgPSBUaW1pbmdfd2hlZWwubGVuZ3RoIHQuZXZlbnRzXG5sZXQgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0ID0gVGltaW5nX3doZWVsLm1heF9hbGxvd2VkX2FsYXJtX3RpbWUgdC5ldmVudHNcbmxldCByZWFkX29ubHkgKHQgOiBbPiByZWFkIF0gVDEudCkgPSAodCA6PiB0KVxuXG4oKiBbZmlyZSB0IGV2ZW50XSBzZXRzIFtldmVudC5zdGF0dXMgPSBGaXJlZF0gYW5kIGluc2VydHMgW2V2ZW50XSBpbnRvXG4gICBbdC5maXJlZF9ldmVudHNdIGluIHNvcnRlZCB0aW1lIG9yZGVyLiAqKVxubGV0IGZpcmUgdCAoZXZlbnQgOiBFdmVudC50KSA9XG4gIEV2ZW50LnNldF9zdGF0dXMgZXZlbnQgRmlyZWQ7XG4gIGV2ZW50LmFsYXJtIDwtIEFsYXJtLm51bGwgKCk7XG4gIGxldCAoKSA9XG4gICAgKCogSWYgW2V2ZW50XSBiZWxvbmdzIGFmdGVyIFt0Lm1vc3RfcmVjZW50bHlfZmlyZWRdLCB0aGVuIHdlIHN0YXJ0IHRoZVxuICAgICAgIGluc2VydGlvbiB0aGVyZSByYXRoZXIgdGhhbiBhdCB0aGUgZnJvbnQgb2YgW3QuZmlyZWRfZXZlbnRzXS4gVGhpcyB3b3Jrc1xuICAgICAgIG5pY2VseSBpZiB3ZSdyZSBnZXR0aW5nIHRoZSBhbGFybXMgaW4gbm9uLWRlY3JlYXNpbmcgdGltZSBvcmRlciwgd2hpY2ggaXNcbiAgICAgICBjbG9zZSB0byB3aGF0IFtUaW1pbmdfd2hlZWxdIHByb3ZpZGVzIChhbHRob3VnaCBbVGltaW5nX3doZWVsXSBkb2Vzbid0XG4gICAgICAgZ3VhcmFudGVlIHRpbWUgb3JkZXJpbmcgZm9yIHRpbWVzIGluIHRoZSBzYW1lIGludGVydmFsKS4gKilcbiAgICBtYXRjaCVvcHRpb25hbCAodC5tb3N0X3JlY2VudGx5X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IFNvbWUgbW9zdF9yZWNlbnRseV9maXJlZCB3aGVuIFRpbWVfbnMuKCA8PSApIG1vc3RfcmVjZW50bHlfZmlyZWQuYXQgZXZlbnQuYXQgLT5cbiAgICAgIGV2ZW50LnByZXZfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLnNvbWUgbW9zdF9yZWNlbnRseV9maXJlZDtcbiAgICAgIGV2ZW50Lm5leHRfZmlyZWQgPC0gbW9zdF9yZWNlbnRseV9maXJlZC5uZXh0X2ZpcmVkXG4gICAgfCBfIC0+XG4gICAgICBldmVudC5wcmV2X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5ub25lO1xuICAgICAgZXZlbnQubmV4dF9maXJlZCA8LSB0LmZpcmVkX2V2ZW50c1xuICBpblxuICB0Lm1vc3RfcmVjZW50bHlfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLnNvbWUgZXZlbnQ7XG4gICgqIFdlIHVzZSBbVGltZV9ucy4oIDw9ICldIHJhdGhlciB0aGFuIFs8XSBzbyB0aGF0IFtldmVudF0gaXMgYWRkZWQgYWZ0ZXIgb3RoZXJcbiAgICAgZXZlbnRzIGF0IHRoZSBzYW1lIHRpbWUuIFNpbmNlIFtUaW1pbmdfd2hlZWxdIGZpcmVzIGFsYXJtcyBpbiBhIGJ1Y2tldCBpblxuICAgICB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkLCB1c2luZyBbPD1dIGtlZXBzIGV2ZW50cyBhdCB0aGUgc2FtZVxuICAgICB0aW1lIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQuICopXG4gIHdoaWxlXG4gICAgbWF0Y2glb3B0aW9uYWwgKGV2ZW50Lm5leHRfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgIHwgU29tZSBuZXh0IC0+XG4gICAgICBsZXQgY29udGludWUgPSBUaW1lX25zLiggPD0gKSBuZXh0LmF0IGV2ZW50LmF0IGluXG4gICAgICBpZiBjb250aW51ZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGV2ZW50LnByZXZfZmlyZWQgPC0gZXZlbnQubmV4dF9maXJlZDtcbiAgICAgICAgZXZlbnQubmV4dF9maXJlZCA8LSBuZXh0Lm5leHRfZmlyZWQpO1xuICAgICAgY29udGludWVcbiAgZG9cbiAgICAoKVxuICBkb25lO1xuICBsZXQgKCkgPVxuICAgIG1hdGNoJW9wdGlvbmFsIChldmVudC5uZXh0X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgbmV4dCAtPiBuZXh0LnByZXZfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLnNvbWUgZXZlbnRcbiAgaW5cbiAgbWF0Y2glb3B0aW9uYWwgKGV2ZW50LnByZXZfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICB8IE5vbmUgLT4gdC5maXJlZF9ldmVudHMgPC0gRXZlbnQuT3B0aW9uLnNvbWUgZXZlbnRcbiAgfCBTb21lIHByZXYgLT4gcHJldi5uZXh0X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5zb21lIGV2ZW50XG47O1xuXG5sZXQgYWxhcm1fcHJlY2lzaW9uIHQgPSBUaW1pbmdfd2hlZWwuYWxhcm1fcHJlY2lzaW9uIHQuZXZlbnRzXG5sZXQgbmV4dF9hbGFybV9maXJlc19hdCB0ID0gVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXQgdC5ldmVudHNcblxubGV0IG5leHRfYWxhcm1fcnVuc19hdCB0ID1cbiAgaWYgRXZlbnQuT3B0aW9uLmlzX3NvbWUgdC5maXJlZF9ldmVudHNcbiAgdGhlbiBTb21lICh0aW1pbmdfd2hlZWxfbm93IHQpXG4gIGVsc2UgVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXQgdC5ldmVudHNcbjs7XG5cbmxldCBub3cgdCA9IGlmIHQuaXNfd2FsbF9jbG9jayB0aGVuIFRpbWVfbnMubm93ICgpIGVsc2UgdGltaW5nX3doZWVsX25vdyB0XG5sZXQgdGltaW5nX3doZWVsX25vdyA9IHRpbWluZ193aGVlbF9ub3dcblxubGV0IHNjaGVkdWxlIHQgKGV2ZW50IDogRXZlbnQudCkgPVxuICBFdmVudC5zZXRfc3RhdHVzIGV2ZW50IFNjaGVkdWxlZDtcbiAgZXZlbnQuYWxhcm0gPC0gVGltaW5nX3doZWVsLmFkZCB0LmV2ZW50cyB+YXQ6ZXZlbnQuYXQgKGV2ZW50IHw+IEpvYl9vcl9ldmVudC5vZl9ldmVudClcbjs7XG5cbmxldCByZW1vdmVfZnJvbV9maXJlZCB0IChldmVudCA6IEV2ZW50LnQpIH5uZXdfc3RhdHVzID1cbiAgbGV0ICgpID1cbiAgICBtYXRjaCVvcHRpb25hbCAodC5tb3N0X3JlY2VudGx5X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgbW9zdF9yZWNlbnRseV9maXJlZCAtPlxuICAgICAgaWYgcGh5c19lcXVhbCBldmVudCBtb3N0X3JlY2VudGx5X2ZpcmVkXG4gICAgICB0aGVuXG4gICAgICAgIHQubW9zdF9yZWNlbnRseV9maXJlZCA8LSBFdmVudC5PcHRpb24uZmlyc3Rfc29tZSBldmVudC5uZXh0X2ZpcmVkIGV2ZW50LnByZXZfZmlyZWRcbiAgaW5cbiAgbGV0ICgpID1cbiAgICBtYXRjaCVvcHRpb25hbCAoZXZlbnQucHJldl9maXJlZCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gICAgfCBOb25lIC0+IHQuZmlyZWRfZXZlbnRzIDwtIGV2ZW50Lm5leHRfZmlyZWRcbiAgICB8IFNvbWUgcHJldiAtPiBwcmV2Lm5leHRfZmlyZWQgPC0gZXZlbnQubmV4dF9maXJlZFxuICBpblxuICBsZXQgKCkgPVxuICAgIG1hdGNoJW9wdGlvbmFsIChldmVudC5uZXh0X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgbmV4dCAtPiBuZXh0LnByZXZfZmlyZWQgPC0gZXZlbnQucHJldl9maXJlZFxuICBpblxuICBldmVudC5uZXh0X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5ub25lO1xuICBldmVudC5wcmV2X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5ub25lO1xuICBFdmVudC5zZXRfc3RhdHVzIGV2ZW50IG5ld19zdGF0dXNcbjs7XG5cbm1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICBpbmNsdWRlIEV2ZW50XG5cbiAgbGV0IGNyZWF0ZV9pbnRlcm5hbCB0IH5hdCB+aW50ZXJ2YWwgfmNhbGxiYWNrID1cbiAgICB7IGFsYXJtID0gQWxhcm0ubnVsbCAoKVxuICAgIDsgYXRcbiAgICA7IGNhbGxiYWNrXG4gICAgOyBleGVjdXRpb25fY29udGV4dCA9IHQuc2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRcbiAgICA7IGludGVydmFsXG4gICAgOyBuZXh0X2ZpcmVkID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IHByZXZfZmlyZWQgPSBFdmVudC5PcHRpb24ubm9uZVxuICAgIDsgc3RhdHVzID0gVW5zY2hlZHVsZWRcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGFkZCB0IGV2ZW50ID1cbiAgICBpZiBUaW1lX25zLiggPD0gKSBldmVudC5hdCAodGltaW5nX3doZWVsX25vdyB0KVxuICAgIHRoZW4gZmlyZSB0IGV2ZW50XG4gICAgZWxzZSBzY2hlZHVsZSB0IGV2ZW50XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9hbmRfYWRkIHQgfmF0IH5pbnRlcnZhbCB+Y2FsbGJhY2sgPVxuICAgIGxldCBldmVudCA9IGNyZWF0ZV9pbnRlcm5hbCB0IH5hdCB+aW50ZXJ2YWwgfmNhbGxiYWNrIGluXG4gICAgYWRkIHQgZXZlbnQ7XG4gICAgZXZlbnRcbiAgOztcblxuICBsZXQgYXQgdCBhdCBjYWxsYmFjayA9IGNyZWF0ZV9hbmRfYWRkIHQgfmF0IH5pbnRlcnZhbDpOb25lIH5jYWxsYmFja1xuXG4gIGxldCBhZnRlciB0IHNwYW4gY2FsbGJhY2sgPVxuICAgIGNyZWF0ZV9hbmRfYWRkIHQgfmF0OihUaW1lX25zLmFmdGVyIChub3cgdCkgc3BhbikgfmludGVydmFsOk5vbmUgfmNhbGxiYWNrXG4gIDs7XG5cbiAgbGV0IHJlcXVpcmVfc3Bhbl9hdF9sZWFzdF9hbGFybV9wcmVjaXNpb24gdCBzcGFuID1cbiAgICBsZXQgYWxhcm1fcHJlY2lzaW9uID0gYWxhcm1fcHJlY2lzaW9uIHQgaW5cbiAgICBpZiBUaW1lX25zLlNwYW4uKCA8ICkgc3BhbiBhbGFybV9wcmVjaXNpb25cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiaW50ZXJ2YWwgc3BhbiBzbWFsbGVyIHRoYW4gYWxhcm0gcHJlY2lzaW9uXCJcbiAgICAgICAgICAgIChzcGFuIDogVGltZV9ucy5TcGFuLnQpXG4gICAgICAgICAgICAoYWxhcm1fcHJlY2lzaW9uIDogVGltZV9ucy5TcGFuLnQpXVxuICA7O1xuXG4gIGxldCBhdF9pbnRlcnZhbHMgP3N0YXJ0IHQgc3BhbiBjYWxsYmFjayA9XG4gICAgbGV0IGF0ID1cbiAgICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBub3cgdFxuICAgICAgfCBTb21lIGF0IC0+IGF0XG4gICAgaW5cbiAgICByZXF1aXJlX3NwYW5fYXRfbGVhc3RfYWxhcm1fcHJlY2lzaW9uIHQgc3BhbjtcbiAgICBjcmVhdGVfYW5kX2FkZCB0IH5hdCB+aW50ZXJ2YWw6KFNvbWUgc3BhbikgfmNhbGxiYWNrXG4gIDs7XG5cbiAgbW9kdWxlIEFib3J0X3Jlc3VsdCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB8IE9rXG4gICAgICB8IFByZXZpb3VzbHlfdW5zY2hlZHVsZWRcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgYWJvcnQgdCAoZXZlbnQgOiB0KSA6IEFib3J0X3Jlc3VsdC50ID1cbiAgICBtYXRjaCBldmVudC5zdGF0dXMgd2l0aFxuICAgIHwgSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IC0+XG4gICAgICAobWF0Y2ggZXZlbnQuaW50ZXJ2YWwgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICB8IFNvbWUgKF8gOiBUaW1lX25zLlNwYW4udCkgLT5cbiAgICAgICAgIGV2ZW50LmludGVydmFsIDwtIE5vbmU7XG4gICAgICAgICBldmVudC5zdGF0dXMgPC0gVW5zY2hlZHVsZWQ7XG4gICAgICAgICBPaylcbiAgICB8IEZpcmVkIC0+XG4gICAgICByZW1vdmVfZnJvbV9maXJlZCB0IGV2ZW50IH5uZXdfc3RhdHVzOlVuc2NoZWR1bGVkO1xuICAgICAgT2tcbiAgICB8IFNjaGVkdWxlZCAtPlxuICAgICAgRXZlbnQuc2V0X3N0YXR1cyBldmVudCBVbnNjaGVkdWxlZDtcbiAgICAgIFRpbWluZ193aGVlbC5yZW1vdmUgdC5ldmVudHMgZXZlbnQuYWxhcm07XG4gICAgICBldmVudC5hbGFybSA8LSBBbGFybS5udWxsICgpO1xuICAgICAgT2tcbiAgICB8IFVuc2NoZWR1bGVkIC0+IFByZXZpb3VzbHlfdW5zY2hlZHVsZWRcbiAgOztcblxuICBsZXQgYWJvcnRfaWZfcG9zc2libGUgdCBldmVudCA9IGlnbm9yZSAoYWJvcnQgdCBldmVudCA6IEFib3J0X3Jlc3VsdC50KVxuXG4gIGxldCBhYm9ydF9leG4gdCBldmVudCA9XG4gICAgbWF0Y2ggYWJvcnQgdCBldmVudCB3aXRoXG4gICAgfCBPayAtPiAoKVxuICAgIHwgcmVhc29uIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiW1N5bmNocm9ub3VzX3RpbWVfc291cmNlLmFib3J0X2V4bl0gY2Fubm90IGFib3J0IGV2ZW50XCJcbiAgICAgICAgICAgIChyZWFzb24gOiBBYm9ydF9yZXN1bHQudCldXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSB0IGNhbGxiYWNrID0gY3JlYXRlX2ludGVybmFsIHQgfmF0OlRpbWVfbnMuZXBvY2ggfmludGVydmFsOk5vbmUgfmNhbGxiYWNrXG5cbiAgbGV0IGlzX3NjaGVkdWxlZCAoZXZlbnQgOiB0KSA9XG4gICAgbWF0Y2ggZXZlbnQuc3RhdHVzIHdpdGhcbiAgICB8IEhhcHBlbmluZ19wZXJpb2RpY19ldmVudCB8IFNjaGVkdWxlZCB8IEZpcmVkIC0+IHRydWVcbiAgICB8IFVuc2NoZWR1bGVkIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IHNjaGVkdWxlX2F0X2ludGVybmFsIHQgKGV2ZW50IDogdCkgYXQgfmludGVydmFsID1cbiAgICBtYXRjaCBldmVudC5zdGF0dXMgd2l0aFxuICAgIHwgKEhhcHBlbmluZ19wZXJpb2RpY19ldmVudCB8IFNjaGVkdWxlZCB8IEZpcmVkKSBhcyBzdGF0dXMgLT5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgWyVzZXhwIFwiY2Fubm90IHNjaGVkdWxlIGFuIGV2ZW50IHdpdGggc3RhdHVzXCIsIChzdGF0dXMgOiBFdmVudC5TdGF0dXMudCldXG4gICAgfCBVbnNjaGVkdWxlZCAtPlxuICAgICAgZXZlbnQuYXQgPC0gYXQ7XG4gICAgICBldmVudC5pbnRlcnZhbCA8LSBpbnRlcnZhbDtcbiAgICAgIGFkZCB0IGV2ZW50O1xuICAgICAgT2sgKClcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfYXQgdCBldmVudCBhdCA9IHNjaGVkdWxlX2F0X2ludGVybmFsIHQgZXZlbnQgYXQgfmludGVydmFsOk5vbmVcbiAgbGV0IHNjaGVkdWxlX2FmdGVyIHQgZXZlbnQgc3BhbiA9IHNjaGVkdWxlX2F0IHQgZXZlbnQgKFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBzcGFuKVxuXG4gIGxldCBzY2hlZHVsZV9hdF9pbnRlcnZhbHMnIHQgZXZlbnQgc3BhbiB+c3RhcnRpbmdfYXQgPVxuICAgIHJlcXVpcmVfc3Bhbl9hdF9sZWFzdF9hbGFybV9wcmVjaXNpb24gdCBzcGFuO1xuICAgIHNjaGVkdWxlX2F0X2ludGVybmFsIHQgZXZlbnQgc3RhcnRpbmdfYXQgfmludGVydmFsOihTb21lIHNwYW4pXG4gIDs7XG5cbiAgbGV0IHNjaGVkdWxlX2F0X2ludGVydmFscyB0IGV2ZW50IHNwYW4gPVxuICAgIHNjaGVkdWxlX2F0X2ludGVydmFscycgdCBldmVudCBzcGFuIH5zdGFydGluZ19hdDoobm93IHQpXG4gIDs7XG5cbiAgbGV0IHJlc2NoZWR1bGVfYXQgdCBldmVudCBhdCA6IHVuaXQgPVxuICAgIG1hdGNoIGV2ZW50LnN0YXR1cyB3aXRoXG4gICAgfCBGaXJlZCAtPlxuICAgICAgcmVtb3ZlX2Zyb21fZmlyZWQgdCBldmVudCB+bmV3X3N0YXR1czpVbnNjaGVkdWxlZDtcbiAgICAgIGV2ZW50LmF0IDwtIGF0O1xuICAgICAgYWRkIHQgZXZlbnRcbiAgICB8IEhhcHBlbmluZ19wZXJpb2RpY19ldmVudCAtPlxuICAgICAgKCogSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IGV2ZW50cyBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGZyb20gW2ZpcmVkXS4gKilcbiAgICAgIGV2ZW50LmF0IDwtIGF0O1xuICAgICAgYWRkIHQgZXZlbnRcbiAgICB8IFNjaGVkdWxlZCAtPlxuICAgICAgZXZlbnQuYXQgPC0gYXQ7XG4gICAgICBpZiBUaW1lX25zLiggPiApIGF0ICh0aW1pbmdfd2hlZWxfbm93IHQpXG4gICAgICB0aGVuIFRpbWluZ193aGVlbC5yZXNjaGVkdWxlIHQuZXZlbnRzIGV2ZW50LmFsYXJtIH5hdFxuICAgICAgZWxzZSAoXG4gICAgICAgIFRpbWluZ193aGVlbC5yZW1vdmUgdC5ldmVudHMgZXZlbnQuYWxhcm07XG4gICAgICAgIGZpcmUgdCBldmVudClcbiAgICB8IFVuc2NoZWR1bGVkIC0+XG4gICAgICBldmVudC5hdCA8LSBhdDtcbiAgICAgIGV2ZW50LmludGVydmFsIDwtIE5vbmU7XG4gICAgICBhZGQgdCBldmVudFxuICA7O1xuXG4gIGxldCByZXNjaGVkdWxlX2FmdGVyIHQgZXZlbnQgc3BhbiA9IHJlc2NoZWR1bGVfYXQgdCBldmVudCAoVGltZV9ucy5hZnRlciAobm93IHQpIHNwYW4pXG5lbmRcblxubGV0IHJ1bl9hZnRlciB0IHNwYW4gY2FsbGJhY2sgPSBpZ25vcmUgKEV2ZW50LmFmdGVyIHQgc3BhbiBjYWxsYmFjayA6IEV2ZW50LnQpXG5sZXQgcnVuX2F0IHQgYXQgY2FsbGJhY2sgPSBpZ25vcmUgKEV2ZW50LmF0IHQgYXQgY2FsbGJhY2sgOiBFdmVudC50KVxuXG5sZXQgcnVuX2F0X2ludGVydmFscyA/c3RhcnQgdCBzcGFuIGNhbGxiYWNrID1cbiAgaWdub3JlIChFdmVudC5hdF9pbnRlcnZhbHMgP3N0YXJ0IHQgc3BhbiBjYWxsYmFjayA6IEV2ZW50LnQpXG47O1xuXG50eXBlIHNlbmRfZXhuID0gTW9uaXRvcjAudCAtPiA/YmFja3RyYWNlOlsgYEdldCB8IGBUaGlzIG9mIEJhY2t0cmFjZS50IF0gLT4gZXhuIC0+IHVuaXRcblxubGV0IHJ1bl9maXJlZF9ldmVudHMgdCB+KHNlbmRfZXhuIDogc2VuZF9leG4gb3B0aW9uKSA9XG4gIGxldCBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ID0gdC5zY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dCBpblxuICB3aGlsZVxuICAgIG1hdGNoJW9wdGlvbmFsICh0LmZpcmVkX2V2ZW50cyA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIGV2ZW50IC0+XG4gICAgICAobWF0Y2ggZXZlbnQuc3RhdHVzIHdpdGhcbiAgICAgICB8IEhhcHBlbmluZ19wZXJpb2RpY19ldmVudCB8IFNjaGVkdWxlZCB8IFVuc2NoZWR1bGVkIC0+IGFzc2VydCBmYWxzZVxuICAgICAgIHwgRmlyZWQgLT5cbiAgICAgICAgIGxldCBuZXdfc3RhdHVzID1cbiAgICAgICAgICAgbWF0Y2ggZXZlbnQuaW50ZXJ2YWwgd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT4gKFVuc2NoZWR1bGVkIDogRXZlbnQuU3RhdHVzLnQpXG4gICAgICAgICAgIHwgU29tZSBfIC0+IChIYXBwZW5pbmdfcGVyaW9kaWNfZXZlbnQgOiBFdmVudC5TdGF0dXMudClcbiAgICAgICAgIGluXG4gICAgICAgICByZW1vdmVfZnJvbV9maXJlZCB0IGV2ZW50IH5uZXdfc3RhdHVzO1xuICAgICAgICAgKCogV2Ugc2V0IHRoZSBleGVjdXRpb24gY29udGV4dCBzbyB0aGF0IFtldmVudC5jYWxsYmFja10gcnVucyBpbiB0aGUgc2FtZSBjb250ZXh0XG4gICAgICAgICAgICB0aGF0IHdhcyBpbiBwbGFjZSB3aGVuIFtldmVudF0gd2FzIGNyZWF0ZWQuICopXG4gICAgICAgICBTY2hlZHVsZXIwLnNldF9leGVjdXRpb25fY29udGV4dCB0LnNjaGVkdWxlciBldmVudC5leGVjdXRpb25fY29udGV4dDtcbiAgICAgICAgICgqIEFueSBtb2RpZmljYXRpb24gb2YgW3N0YXR1c10gYmVsb3cgbmVlZHMgdG8gZmlyc3QgY2hlY2sgdGhhdCB0aGUgZXZlbnQgaXNcbiAgICAgICAgICAgIHN0aWxsIFtIYXBwZW5pbmdfcGVyaW9kaWNfZXZlbnRdLiBJZiB0aGUgZXZlbnQgc3RhdHVzIGlzIG5vdFxuICAgICAgICAgICAgW0hhcHBlbmluZ19wZXJpb2RpY19ldmVudF0gdGhlbiB0aGUgZXZlbnQncyBjYWxsYmFjayBtdXN0IGhhdmUgcmVzY2hlZHVsZWQgdGhlXG4gICAgICAgICAgICBldmVudC4gSW4gdGhhdCBjYXNlLCBkbyBub3Qgc2V0IHRoZSBzdGF0dXMgb3IgYXR0ZW1wdCB0byByZXNjaGVkdWxlIGFcbiAgICAgICAgICAgIHJlcGVhdGluZyBldmVudC5cblxuICAgICAgICAgICAgVGhpcyBjb2RlIGNvdWxkIGJlIG11Y2ggc2ltcGxlciBpZiB3ZSBpbW1lZGlhdGVseSByZXNjaGVkdWxlZCB0aGUgZXZlbnQgYmVmb3JlXG4gICAgICAgICAgICBydW5uaW5nIHRoZSBjYWxsYmFjayAobm8gbmVlZCBmb3IgdGhlIEhhcHBlbmluZ19wZXJpb2RpY19ldmVudCBzdGF0ZSB0aGVuKS5cbiAgICAgICAgICAgIE9uZSByZWFzb24gd2UgZG9uJ3QgZG8gdGhhdCBpcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYXV0b21hdGljYWxseSByZXNjaGVkdWxlXG4gICAgICAgICAgICBhIHBlcmlvZGljIGV2ZW50IGlmIGl0cyBjYWxsYmFjayByYWlzZXMuICopXG4gICAgICAgICAobWF0Y2ggZXZlbnQuY2FsbGJhY2sgKCkgd2l0aFxuICAgICAgICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgICAgICAgKG1hdGNoIHNlbmRfZXhuIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gdC5hZHZhbmNlX2Vycm9ycyA8LSBFcnJvci5vZl9leG4gZXhuIDo6IHQuYWR2YW5jZV9lcnJvcnNcbiAgICAgICAgICAgICB8IFNvbWUgc2VuZF9leG4gLT5cbiAgICAgICAgICAgICAgIGxldCBiYWNrdHJhY2UgPSBCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50ICgpIGluXG4gICAgICAgICAgICAgICBzZW5kX2V4biBldmVudC5leGVjdXRpb25fY29udGV4dC5tb25pdG9yIGV4biB+YmFja3RyYWNlOihgVGhpcyBiYWNrdHJhY2UpKTtcbiAgICAgICAgICAgIEV2ZW50LnNldF9zdGF0dXNfaWYgfmlzOkhhcHBlbmluZ19wZXJpb2RpY19ldmVudCBldmVudCBVbnNjaGVkdWxlZFxuICAgICAgICAgIHwgKCkgLT5cbiAgICAgICAgICAgIChtYXRjaCBldmVudC5pbnRlcnZhbCB3aXRoXG4gICAgICAgICAgICAgfCBOb25lIC0+IEV2ZW50LnNldF9zdGF0dXNfaWYgfmlzOkhhcHBlbmluZ19wZXJpb2RpY19ldmVudCBldmVudCBVbnNjaGVkdWxlZFxuICAgICAgICAgICAgIHwgU29tZSBpbnRlcnZhbCAtPlxuICAgICAgICAgICAgICAgaWYgRXZlbnQuU3RhdHVzLmVxdWFsIEhhcHBlbmluZ19wZXJpb2RpY19ldmVudCBldmVudC5zdGF0dXNcbiAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICAoKiBUaGUgZXZlbnQncyBjYWxsYmFjayBkaWQgbm90IHJlc2NoZWR1bGUgdGhlIGV2ZW50LiBTbyByZXNjaGVkdWxlIHRoZVxuICAgICAgICAgICAgICAgICAgICByZXBlYXRpbmcgdGltZXIgYmFzZWQgb24gdGhlIGxhc3QgW2F0XSB0aW1lLiAqKVxuICAgICAgICAgICAgICAgICBldmVudC5hdFxuICAgICAgICAgICAgICAgICAgIDwtIFRpbWVfbnMubmV4dF9tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH5iYXNlOmV2ZW50LmF0XG4gICAgICAgICAgICAgICAgICAgICAgICB+YWZ0ZXI6KHRpbWluZ193aGVlbF9ub3cgdClcbiAgICAgICAgICAgICAgICAgICAgICAgIH5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgc2NoZWR1bGUgdCBldmVudCkpKTtcbiAgICAgICAgIHRydWUpXG4gIGRvXG4gICAgKClcbiAgZG9uZTtcbiAgU2NoZWR1bGVyMC5zZXRfZXhlY3V0aW9uX2NvbnRleHQgdC5zY2hlZHVsZXIgY3VycmVudF9leGVjdXRpb25fY29udGV4dFxuOztcblxubGV0IGFueV9maXJlZF9ldmVudHNfdG9fcnVuIHQgPSBFdmVudC5PcHRpb24uaXNfc29tZSAodC5maXJlZF9ldmVudHMgOiBFdmVudC5PcHRpb24udClcblxubGV0IGFkdmFuY2VfY2xvY2sgdCB+dG9fIH5zZW5kX2V4biA9XG4gIFRpbWluZ193aGVlbC5hZHZhbmNlX2Nsb2NrIHQuZXZlbnRzIH50b18gfmhhbmRsZV9maXJlZDp0LmhhbmRsZV9maXJlZDtcbiAgcnVuX2ZpcmVkX2V2ZW50cyB0IH5zZW5kX2V4blxuOztcblxubGV0IGFkdmFuY2VfY2xvY2tfc3RvcF9hdF9uZXh0X2FsYXJtIHQgfnRvXyB+c2VuZF9leG4gPVxuICBUaW1pbmdfd2hlZWwuYWR2YW5jZV9jbG9ja19zdG9wX2F0X25leHRfYWxhcm0gdC5ldmVudHMgfnRvXyB+aGFuZGxlX2ZpcmVkOnQuaGFuZGxlX2ZpcmVkO1xuICBydW5fZmlyZWRfZXZlbnRzIHQgfnNlbmRfZXhuXG47O1xuXG5sZXQgZmlyZV9wYXN0X2FsYXJtcyB0IH5zZW5kX2V4biA9XG4gIFRpbWluZ193aGVlbC5maXJlX3Bhc3RfYWxhcm1zIHQuZXZlbnRzIH5oYW5kbGVfZmlyZWQ6dC5oYW5kbGVfZmlyZWQ7XG4gIHJ1bl9maXJlZF9ldmVudHMgdCB+c2VuZF9leG5cbjs7XG5cbmxldCBhZHZhbmNlX2ludGVybmFsIHQgfnRvXyB+c2VuZF9leG4gPVxuICBhZHZhbmNlX2Nsb2NrIHQgfnRvXyB+c2VuZF9leG47XG4gIGZpcmVfcGFzdF9hbGFybXMgdCB+c2VuZF9leG5cbjs7XG5cbmxldCBhZHZhbmNlX2ludGVybmFsX3N0b3BfYXRfbmV4dF9hbGFybSB0IH50b18gfnNlbmRfZXhuID1cbiAgYWR2YW5jZV9jbG9ja19zdG9wX2F0X25leHRfYWxhcm0gdCB+dG9fIH5zZW5kX2V4bjtcbiAgZmlyZV9wYXN0X2FsYXJtcyB0IH5zZW5kX2V4blxuOztcblxubGV0IHByZXBhcmVfdG9fYWR2YW5jZSB0IH5zZW5kX2V4biA9XG4gIGlmIHQuYW1fYWR2YW5jaW5nXG4gIHRoZW5cbiAgICByYWlzZV9zIFslc2V4cCBcImNhbm5vdCBjYWxsIFthZHZhbmNlX2J5X2FsYXJtc10gb3IgW2FkdmFuY2VfZGlyZWN0bHldIGZyb20gY2FsbGJhY2tcIl07XG4gIHQuYW1fYWR2YW5jaW5nIDwtIHRydWU7XG4gIChtYXRjaCB0LmFkdmFuY2VfZXJyb3JzIHdpdGhcbiAgIHwgW10gLT4gKClcbiAgIHwgXyAtPiB0LmFkdmFuY2VfZXJyb3JzIDwtIFtdKTtcbiAgcnVuX2ZpcmVkX2V2ZW50cyB0IH5zZW5kX2V4blxuOztcblxubGV0IGZpbmlzaF9hZHZhbmNpbmcgdCA9XG4gIHQuYW1fYWR2YW5jaW5nIDwtIGZhbHNlO1xuICBtYXRjaCB0LmFkdmFuY2VfZXJyb3JzIHdpdGhcbiAgfCBbXSAtPiBPayAoKVxuICB8IGVycm9ycyAtPlxuICAgIHQuYWR2YW5jZV9lcnJvcnMgPC0gW107XG4gICAgRXJyb3IgKEVycm9yLm9mX2xpc3QgZXJyb3JzKVxuOztcblxubGV0IGFkdmFuY2VfYnlfYWxhcm1zIHQgfnRvXyA9XG4gIGxldCBzZW5kX2V4biA9IE5vbmUgaW5cbiAgcHJlcGFyZV90b19hZHZhbmNlIHQgfnNlbmRfZXhuO1xuICB3aGlsZSBUaW1lX25zLiggPCApIChUaW1pbmdfd2hlZWwubm93IHQuZXZlbnRzKSB0b18gZG9cbiAgICBhZHZhbmNlX2ludGVybmFsX3N0b3BfYXRfbmV4dF9hbGFybSB0IH50b18gfnNlbmRfZXhuXG4gIGRvbmU7XG4gIGZpbmlzaF9hZHZhbmNpbmcgdFxuOztcblxubGV0IGFkdmFuY2VfYnlfYWxhcm1zX2J5IHQgYnkgPSBhZHZhbmNlX2J5X2FsYXJtcyB0IH50b186KFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBieSlcblxubGV0IGFkdmFuY2VfYnlfbWF4X2FsYXJtc19pbl9lYWNoX3RpbWluZ193aGVlbF9pbnRlcnZhbCB0IH50b18gPVxuICBsZXQgc2VuZF9leG4gPSBOb25lIGluXG4gIHByZXBhcmVfdG9fYWR2YW5jZSB0IH5zZW5kX2V4bjtcbiAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgaWYgVGltaW5nX3doZWVsLmlzX2VtcHR5IHQuZXZlbnRzXG4gICAgdGhlbiBjb250aW51ZSA6PSBmYWxzZVxuICAgIGVsc2UgKFxuICAgICAgbGV0IG5leHRfYWxhcm1fZmlyZXNfYXQgPSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdF9leG4gdC5ldmVudHMgaW5cbiAgICAgIGlmIFRpbWVfbnMuKCA+PSApIG5leHRfYWxhcm1fZmlyZXNfYXQgdG9fXG4gICAgICB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlXG4gICAgICBlbHNlXG4gICAgICAgICgqIFdlIHVzZSB0aGUgYWN0dWFsIGFsYXJtIHRpbWUsIHJhdGhlciB0aGFuIFtuZXh0X2FsYXJtX2ZpcmVzX2F0XSwgc28gYXMgbm90IHRvXG4gICAgICAgICAgIGV4cG9zZSAob3IgYWNjdW11bGF0ZSBlcnJvcnMgYXNzb2NpYXRlZCB3aXRoKSB0aGUgcHJlY2lzaW9uIG9mXG4gICAgICAgICAgIFtUaW1pbmdfd2hlZWxdLiAqKVxuICAgICAgICBhZHZhbmNlX2ludGVybmFsXG4gICAgICAgICAgdFxuICAgICAgICAgIH50b186KFRpbWluZ193aGVlbC5tYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHQuZXZlbnRzKVxuICAgICAgICAgIH5zZW5kX2V4bilcbiAgZG9uZTtcbiAgYWR2YW5jZV9pbnRlcm5hbCB0IH50b18gfnNlbmRfZXhuO1xuICBmaW5pc2hfYWR2YW5jaW5nIHRcbjs7XG5cbmxldCBhZHZhbmNlX2RpcmVjdGx5IHQgfnRvXyA9XG4gIGxldCBzZW5kX2V4biA9IE5vbmUgaW5cbiAgcHJlcGFyZV90b19hZHZhbmNlIHQgfnNlbmRfZXhuO1xuICBhZHZhbmNlX2ludGVybmFsIHQgfnRvXyB+c2VuZF9leG47XG4gIGZpbmlzaF9hZHZhbmNpbmcgdFxuOztcblxubGV0IGFkdmFuY2VfZGlyZWN0bHlfYnkgdCBieSA9IGFkdmFuY2VfZGlyZWN0bHkgdCB+dG9fOihUaW1lX25zLmFmdGVyIChub3cgdCkgYnkpXG5cbmxldCBkdXJhdGlvbl9vZiB0IGYgPVxuICBsZXQgc3RhcnQgPSBub3cgdCBpblxuICBsZXQgcmVzdWx0ID0gZiAoKSBpblxuICBsZXQgZHVyYXRpb24gPSBUaW1lX25zLmRpZmYgKG5vdyB0KSBzdGFydCBpblxuICByZXN1bHQsIGR1cmF0aW9uXG47O1xuXG5sZXQgbWF4X2FsYXJtX3RpbWVfaW5fbWluX3RpbWluZ193aGVlbF9pbnRlcnZhbCB0ID1cbiAgVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0LmV2ZW50c1xuOztcblxubGV0IGhhc19ldmVudHNfdG9fcnVuIHQgPSBFdmVudC5PcHRpb24uaXNfc29tZSB0LmZpcmVkX2V2ZW50c1xuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxuaW5jbHVkZSBTY2hlZHVsZXIwXG5tb2R1bGUgU3luY2hyb25vdXNfdGltZV9zb3VyY2UgPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTBcbm1vZHVsZSBFdmVudCA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlLkV2ZW50XG5tb2R1bGUgQWxhcm0gPSBUaW1pbmdfd2hlZWwuQWxhcm1cbm1vZHVsZSBKb2Jfb3JfZXZlbnQgPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5UMS5Kb2Jfb3JfZXZlbnRcblxubGV0IGRlYnVnID0gRGVidWcuc2NoZWR1bGVyXG5cbm1vZHVsZSBJdmFyID0gc3RydWN0XG4gIG9wZW4gVHlwZXMuSXZhclxuXG4gIGxldCBjcmVhdGVfd2l0aF9jZWxsIGNlbGwgPSB7IGNlbGwgfVxuICBsZXQgY3JlYXRlICgpID0gY3JlYXRlX3dpdGhfY2VsbCBFbXB0eVxuXG4gIGxldCBjcmVhdGVfZnVsbCAodHlwZSBhKSAoYSA6IGEpID1cbiAgICAoKiBXZSBhbGxvY2F0ZSBhbiBpbW11dGFibGUgaXZhciBhbmQgdGhlbiBjYXN0IGl0IHRvIGEgbXV0YWJsZSBpdmFyLiAgVGhlIGltbXV0YWJpbGl0eVxuICAgICAgIGFsbG93cyBPQ2FtbCB0byBzdGF0aWNhbGx5IGFsbG9jYXRlIHRoZSBpdmFyIGlmIFthXSBpcyBjb25zdGFudC4gIFRoaXMgY2FzdCBpcyBzYWZlXG4gICAgICAgYmVjYXVzZSBhIGZ1bGwgaXZhciBpcyBuZXZlciBtdXRhdGVkLiAgV2UgYWxzbyBiZWxpZXZlIHRoYXQgd2Ugd2lsbCBub3QgdHJpZ2dlclxuICAgICAgIGZsYW1iZGEgdG8gc3B1cmlvdXNseSByZXBvciB3YXJuaW5nIDU5LCBtdXRhdGlvbiBvZiBrbm93biBpbW11dGFibGUgZGF0YS4gIEFsbFxuICAgICAgIG11dGF0aW9ucyBvZiBhbiBpdmFyIGNlbGwsIGkuZS4gW2Zvby5jZWxsIDwtIC4uLl0sIGFyZSBkaXJlY3RseSBwcmVjZWRlZCBieSBhXG4gICAgICAgW21hdGNoIGZvby5jZWxsXSB0aGF0IHByZXZlbnRzIHRoZSBbRnVsbF0gY2FzZSBmcm9tIHJlYWNoaW5nIHRoZSBtb2RpZmljYXRpb24uICBTb1xuICAgICAgIGZsYW1iZGEgc2hvdWxkIGFsd2F5cyBlbGltaW5hdGUgdGhlIFtmb28uY2VsbCA8LSAuLi5dIG9mIGEgY29uc3RhbnQgW0Z1bGxdIGl2YXIsXG4gICAgICAgYW5kIG5vdCB3YXJuLiAqKVxuICAgIChPYmoubWFnaWMgOiBhIEltbXV0YWJsZS50IC0+IGEgdCkgeyBjZWxsID0gRnVsbCBhIH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgQnZhciA9IHN0cnVjdFxuICBvcGVuIFR5cGVzLkJ2YXJcblxuICBsZXQgY3JlYXRlICgpID0gb2ZfcmVwciB7IGhhc19hbnlfd2FpdGVycyA9IGZhbHNlOyBpdmFyID0gSXZhci5jcmVhdGUgKCkgfVxuZW5kXG5cbm1vZHVsZSBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIgPSBzdHJ1Y3RcbiAgbW9kdWxlIEV4ZWNfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVHlwZXMuVmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLkV4ZWNfcmVzdWx0LnQgPVxuICAgICAgfCBGaW5pc2hlZFxuICAgICAgfCBOb3RfZmluaXNoZWRcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICB0eXBlIHQgPSBUeXBlcy5WZXJ5X2xvd19wcmlvcml0eV93b3JrZXIudCA9XG4gICAgeyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IGV4ZWMgOiB1bml0IC0+IEV4ZWNfcmVzdWx0LnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgICAgRmllbGRzLml0ZXIgfmV4ZWN1dGlvbl9jb250ZXh0OihjaGVjayBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnQpIH5leGVjOmlnbm9yZSlcbiAgOztcbmVuZFxuXG50eXBlIHQgPSBTY2hlZHVsZXIwLnQgPVxuICB7ICgqIFtjaGVja19hY2Nlc3NdIG9wdGlvbmFsbHkgaG9sZHMgYSBmdW5jdGlvbiB0byBydW4gdG8gY2hlY2sgd2hldGhlciBhY2Nlc3MgdG8gW3RdIGlzXG4gICAgICAgY3VycmVudGx5IGFsbG93ZWQuICBJdCBpcyB1c2VkIHRvIGRldGVjdCBpbnZhbGlkIGFjY2VzcyB0byB0aGUgc2NoZWR1bGVyIGZyb20gYVxuICAgICAgIHRocmVhZC4gKilcbiAgICBtdXRhYmxlIGNoZWNrX2FjY2VzcyA6ICh1bml0IC0+IHVuaXQpIG9wdGlvblxuICA7IG11dGFibGUgam9iX3Bvb2wgOiBKb2JfcG9vbC50XG4gIDsgbm9ybWFsX3ByaW9yaXR5X2pvYnMgOiBKb2JfcXVldWUudFxuICA7IGxvd19wcmlvcml0eV9qb2JzIDogSm9iX3F1ZXVlLnRcbiAgOyB2ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzIDogVmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLnQgRGVxdWUudFxuICA7IG11dGFibGUgbWFpbl9leGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgOyBtdXRhYmxlIGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgICAoKiBUaGUgc2NoZWR1bGVyIGNhbGxzIFtnb3RfdW5jYXVnaHRfZXhuXSB3aGVuIGFuIGV4Y2VwdGlvbiBidWJibGVzIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgIG1vbml0b3IgdHJlZSB3aXRob3V0IGJlaW5nIGhhbmRsZWQuICBUaGlzIGZ1bmN0aW9uIGd1YXJhbnRlZXMgdG8gbmV2ZXIgcnVuIGFub3RoZXJcbiAgICAgam9iIGFmdGVyIHRoaXMgYnkgY2FsbGluZyBbY2xlYXJdIGFuZCBiZWNhdXNlIFtlbnF1ZXVlX2pvYl0gd2lsbCBuZXZlciBhZGQgYW5vdGhlclxuICAgICBqb2IuICopXG4gIDsgbXV0YWJsZSB1bmNhdWdodF9leG4gOiAoRXhuLnQgKiBTZXhwLnQpIG9wdGlvblxuICA7IG11dGFibGUgY3ljbGVfY291bnQgOiBpbnRcbiAgOyBtdXRhYmxlIGN5Y2xlX3N0YXJ0IDogVGltZV9ucy50XG4gIDsgbXV0YWJsZSBpbl9jeWNsZSA6IGJvb2xcbiAgOyBtdXRhYmxlIHJ1bl9ldmVyeV9jeWNsZV9zdGFydCA6IChUeXBlcy5DeWNsZV9ob29rLnRbQHNleHAub3BhcXVlXSkgYXJyYXlcbiAgOyBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgOlxuICAgICAgKFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLnQsIChUeXBlcy5DeWNsZV9ob29rLnRbQHNleHAub3BhcXVlXSkpIEhhc2h0YmwudFxuICA7IG11dGFibGUgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCA6IChUeXBlcy5DeWNsZV9ob29rLnRbQHNleHAub3BhcXVlXSkgYXJyYXlcbiAgOyBydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlIDpcbiAgICAgIChUeXBlcy5DeWNsZV9ob29rX2hhbmRsZS50LCAoVHlwZXMuQ3ljbGVfaG9vay50W0BzZXhwLm9wYXF1ZV0pKSBIYXNodGJsLnRcbiAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfdGltZSA6IFRpbWVfbnMuU3Bhbi50XG4gIDsgbXV0YWJsZSBsYXN0X2N5Y2xlX251bV9qb2JzIDogaW50XG4gIDsgbXV0YWJsZSB0b3RhbF9jeWNsZV90aW1lIDogVGltZV9ucy5TcGFuLnRcbiAgOyBtdXRhYmxlIHRpbWVfc291cmNlIDogcmVhZF93cml0ZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5UMS50XG4gICAgICAoKiBbZXh0ZXJuYWxfam9ic10gaXMgYSBxdWV1ZSBvZiBhY3Rpb25zIHNlbnQgZnJvbSBvdXRzaWRlIG9mIGFzeW5jLiAgVGhpcyBpcyBmb3IgdGhlXG4gICAgIGNhc2Ugd2hlcmUgd2Ugd2FudCB0byBzY2hlZHVsZSBhIGpvYiBvciBmaWxsIGFuIGl2YXIgZnJvbSBhIGNvbnRleHQgd2hlcmUgaXQgaXMgbm90XG4gICAgIHNhZmUgdG8gcnVuIGFzeW5jIGNvZGUsIGJlY2F1c2UgdGhlIGFzeW5jIGxvY2sgaXNuJ3QgaGVsZC4gIEZvciBpbnN0YW5jZTogLSBpbiBhblxuICAgICBPQ2FtbCBmaW5hbGl6ZXIsIGFzIHRoZXkgY2FuIHJ1biBhdCBhbnkgdGltZSBpbiBhbnkgdGhyZWFkLlxuXG4gICAgIFRoZSB3YXkgdG8gZG8gaXQgaXMgdG8gcXVldWUgYSB0aHVuayBpbiBbZXh0ZXJuYWxfam9ic10gYW5kIGNhbGxcbiAgICAgW3RocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rXSwgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIG5vdGlmeWluZyB0aGUgc2NoZWR1bGVyXG4gICAgIHRoYXQgbmV3IGFjdGlvbnMgYXJlIGF2YWlsYWJsZS5cblxuICAgICBXaGVuIHVzaW5nIEFzeW5jIG9uIHVuaXgsIFt0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9va10gaXMgc2V0IGluIFtBc3luY191bml4XVxuICAgICB0byBjYWxsIFtJbnRlcnJ1cHRvci50aHJlYWRfc2FmZV9pbnRlcnJ1cHRdLCB3aGljaCB3aWxsIHdha2UgdXAgdGhlXG4gICAgIFtBc3luY191bml4XSBzY2hlZHVsZXIgYW5kIHJ1biBhIGN5Y2xlLlxuXG4gICAgIE5vdGUgdGhhdCB0aGlzIGhvb2sgbWlnaHQgYmUgdXNlZCBpbiBvdGhlciBjb250ZXh0IChqc19vZl9vY2FtbCwgbWlyYWdlKS5cblxuICAgICBXaGVuIHJ1bm5pbmcgYSBjeWNsZSwgd2UgcHVsbCBleHRlcm5hbCBhY3Rpb25zIGF0IGV2ZXJ5IGpvYiBhbmQgcGVyZm9ybSB0aGVtXG4gICAgIGltbWVkaWF0ZWx5LiAqKVxuICA7IGV4dGVybmFsX2pvYnMgOiBFeHRlcm5hbF9qb2IudCBUaHJlYWRfc2FmZV9xdWV1ZS50XG4gIDsgbXV0YWJsZSB0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayA6IHVuaXQgLT4gdW5pdFxuICAgICAgKCogW2pvYl9xdWV1ZWRfaG9va10gYW5kIFtldmVudF9hZGRlZF9ob29rXSBhaW0gdG8gYmUgdXNlZCBieSBqc19vZl9vY2FtbC4gKilcbiAgICAgICgqIFdlIHVzZSBbXyBvcHRpb25dIGhlcmUgYmVjYXVzZSB0aG9zZSBob29rcyB3aWxsIG5vdCBiZSBzZXQgaW4gdGhlIGNvbW1vbiBjYXNlXG4gICAgIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGV4dHJhIGZ1bmN0aW9uIGNhbGxzLiAqKVxuICA7IG11dGFibGUgam9iX3F1ZXVlZF9ob29rIDogKFByaW9yaXR5LnQgLT4gdW5pdCkgb3B0aW9uXG4gIDsgbXV0YWJsZSBldmVudF9hZGRlZF9ob29rIDogKFRpbWVfbnMudCAtPiB1bml0KSBvcHRpb25cbiAgOyBtdXRhYmxlIHlpZWxkIDogKCh1bml0LCByZWFkX3dyaXRlKSBUeXBlcy5CdmFyLnRbQHNleHAub3BhcXVlXSlcbiAgOyBtdXRhYmxlXG4gICAgICB5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiA6XG4gICAgICAoKHVuaXQsIHJlYWRfd3JpdGUpIFR5cGVzLkJ2YXIudFtAc2V4cC5vcGFxdWVdICgqIGNvbmZpZ3VyYXRpb24qKSlcbiAgOyBtdXRhYmxlIGNoZWNrX2ludmFyaWFudHMgOiBib29sXG4gIDsgbXV0YWJsZSBtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSA6IE1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlLnRcbiAgOyBtdXRhYmxlIHJlY29yZF9iYWNrdHJhY2VzIDogYm9vbFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG5sZXQgdW5jYXVnaHRfZXhuX3Vud3JhcHBlZCA9IHVuY2F1Z2h0X2V4blxuXG5sZXQgdW5jYXVnaHRfZXhuIHQgPVxuICBtYXRjaCB0LnVuY2F1Z2h0X2V4biB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoZXhuLCBzZXhwKSAtPlxuICAgIFNvbWUgKEVycm9yLmNyZWF0ZSBcInVuaGFuZGxlZCBleGNlcHRpb25cIiAoZXhuLCBzZXhwKSBbJXNleHBfb2Y6IEV4bi50ICogU2V4cC50XSlcbjs7XG5cbmxldCBudW1fcGVuZGluZ19qb2JzIHQgPVxuICBKb2JfcXVldWUubGVuZ3RoIHQubm9ybWFsX3ByaW9yaXR5X2pvYnMgKyBKb2JfcXVldWUubGVuZ3RoIHQubG93X3ByaW9yaXR5X2pvYnNcbjs7XG5cbmxldCBudW1fam9ic19ydW4gdCA9XG4gIEpvYl9xdWV1ZS5udW1fam9ic19ydW4gdC5ub3JtYWxfcHJpb3JpdHlfam9ic1xuICArIEpvYl9xdWV1ZS5udW1fam9ic19ydW4gdC5sb3dfcHJpb3JpdHlfam9ic1xuOztcblxubGV0IGxhc3RfY3ljbGVfbnVtX2pvYnMgdCA9IHQubGFzdF9jeWNsZV9udW1fam9ic1xuXG5sZXQgdW5vcmRlcmVkX2lzX3N1Ymxpc3QgfmVxdWFsIH5zdWJsaXN0OnNtYWxsIGxhcmdlID1cbiAgbGV0IGxhcmdlID0gQXJyYXkudG9fbGlzdCBsYXJnZSBpblxuICBsZXQgcmVtb3ZlIGEgeCA9XG4gICAgbWF0Y2ggTGlzdC5zcGxpdF93aGlsZSBhIH5mOihmdW4geSAtPiBub3QgKGVxdWFsIHkgeCkpIHdpdGhcbiAgICB8IF8sIFtdIC0+IE5vbmVcbiAgICB8IGwsIF8gOjogciAtPiBTb21lIChsIEAgcilcbiAgaW5cbiAgT3B0aW9uLmlzX3NvbWVcbiAgICAoTGlzdC5mb2xkIHNtYWxsIH5pbml0OihTb21lIGxhcmdlKSB+ZjooZnVuIGFjYyB4IC0+XG4gICAgICAgT3B0aW9uLmJpbmQgYWNjIH5mOihmdW4gbCAtPiByZW1vdmUgbCB4KSkpXG47O1xuXG5sZXQgY2hlY2tfaG9va190YWJsZV9pbnZhcmlhbnQgdGFibGUgYXJyYXkgPVxuICAoKiBZb3UgY2FuIGluIGZhY3QgaGF2ZSBob29rcyBpbiB0aGUgbGlzdCBmb3Igd2hpY2ggdGhlcmUgaXMgbm8gY29ycmVzcG9uZGluZyBlbnRyeSBpblxuICAgICB0aGUgdGFibGUuIFN1Y2ggaG9va3MgY2FuIG5ldmVyIGJlIHJlbW92ZWQuICopXG4gIGFzc2VydCAodW5vcmRlcmVkX2lzX3N1Ymxpc3QgfmVxdWFsOnBoeXNfZXF1YWwgfnN1Ymxpc3Q6KEhhc2h0YmwuZGF0YSB0YWJsZSkgYXJyYXkpXG47O1xuXG5sZXQgaW52YXJpYW50IHQgOiB1bml0ID1cbiAgdHJ5XG4gICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfmNoZWNrX2FjY2VzczppZ25vcmVcbiAgICAgIH5qb2JfcG9vbDooY2hlY2sgSm9iX3Bvb2wuaW52YXJpYW50KVxuICAgICAgfm5vcm1hbF9wcmlvcml0eV9qb2JzOihjaGVjayBKb2JfcXVldWUuaW52YXJpYW50KVxuICAgICAgfmxvd19wcmlvcml0eV9qb2JzOihjaGVjayBKb2JfcXVldWUuaW52YXJpYW50KVxuICAgICAgfnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnM6XG4gICAgICAgIChjaGVjayAoZnVuIHEgLT4gRGVxdWUuaXRlciBxIH5mOlZlcnlfbG93X3ByaW9yaXR5X3dvcmtlci5pbnZhcmlhbnQpKVxuICAgICAgfm1haW5fZXhlY3V0aW9uX2NvbnRleHQ6KGNoZWNrIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudClcbiAgICAgIH5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0OihjaGVjayBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnQpXG4gICAgICB+dW5jYXVnaHRfZXhuOlxuICAgICAgICAoY2hlY2sgKGZ1biB1bmNhdWdodF9leG4gLT5cbiAgICAgICAgICAgaWYgaXNfc29tZSB1bmNhdWdodF9leG4gdGhlbiBhc3NlcnQgKG51bV9wZW5kaW5nX2pvYnMgdCA9IDApKSlcbiAgICAgIH5jeWNsZV9jb3VudDooY2hlY2sgKGZ1biBjeWNsZV9jb3VudCAtPiBhc3NlcnQgKGN5Y2xlX2NvdW50ID49IDApKSlcbiAgICAgIH5jeWNsZV9zdGFydDppZ25vcmVcbiAgICAgIH5pbl9jeWNsZTppZ25vcmVcbiAgICAgIH5ydW5fZXZlcnlfY3ljbGVfc3RhcnQ6aWdub3JlXG4gICAgICB+cnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlOlxuICAgICAgICAoY2hlY2sgKGZ1biBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgLT5cbiAgICAgICAgICAgY2hlY2tfaG9va190YWJsZV9pbnZhcmlhbnQgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0KSlcbiAgICAgIH5ydW5fZXZlcnlfY3ljbGVfZW5kOmlnbm9yZVxuICAgICAgfnJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGU6XG4gICAgICAgIChjaGVjayAoZnVuIHJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUgLT5cbiAgICAgICAgICAgY2hlY2tfaG9va190YWJsZV9pbnZhcmlhbnQgcnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSB0LnJ1bl9ldmVyeV9jeWNsZV9lbmQpKVxuICAgICAgfmxhc3RfY3ljbGVfdGltZTppZ25vcmVcbiAgICAgIH50b3RhbF9jeWNsZV90aW1lOmlnbm9yZVxuICAgICAgfmxhc3RfY3ljbGVfbnVtX2pvYnM6XG4gICAgICAgIChjaGVjayAoZnVuIGxhc3RfY3ljbGVfbnVtX2pvYnMgLT4gYXNzZXJ0IChsYXN0X2N5Y2xlX251bV9qb2JzID49IDApKSlcbiAgICAgIH50aW1lX3NvdXJjZTpcbiAgICAgICAgKGNoZWNrXG4gICAgICAgICAgIChTeW5jaHJvbm91c190aW1lX3NvdXJjZS5SZWFkX3dyaXRlLmludmFyaWFudF93aXRoX2pvYnMgfmpvYjooZnVuIGpvYiAtPlxuICAgICAgICAgICAgICBhc3NlcnQgKFBvb2wucG9pbnRlcl9pc192YWxpZCB0LmpvYl9wb29sIGpvYikpKSlcbiAgICAgIH5leHRlcm5hbF9qb2JzOmlnbm9yZVxuICAgICAgfnRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rOmlnbm9yZVxuICAgICAgfmpvYl9xdWV1ZWRfaG9vazppZ25vcmVcbiAgICAgIH5ldmVudF9hZGRlZF9ob29rOmlnbm9yZVxuICAgICAgfnlpZWxkOmlnbm9yZVxuICAgICAgfnlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluOmlnbm9yZVxuICAgICAgfmNoZWNrX2ludmFyaWFudHM6aWdub3JlXG4gICAgICB+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGU6aWdub3JlXG4gICAgICB+cmVjb3JkX2JhY2t0cmFjZXM6aWdub3JlXG4gIHdpdGhcbiAgfCBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJTY2hlZHVsZXIuaW52YXJpYW50IGZhaWxlZFwiIChleG4gOiBleG4pICh0IDogdCldXG47O1xuXG5sZXQgZnJlZV9qb2IgdCBqb2IgPSBQb29sLmZyZWUgdC5qb2JfcG9vbCBqb2JcblxubGV0IGVucXVldWUgdCAoZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50KSBmIGEgPVxuICAoKiBJZiB0aGVyZSdzIGJlZW4gYW4gdW5jYXVnaHQgZXhuLCB3ZSBkb24ndCBhZGQgdGhlIGpvYiwgc2luY2Ugd2UgZG9uJ3Qgd2FudCBhbnkgam9ic1xuICAgICB0byBydW4gb25jZSB0aGVyZSdzIGJlZW4gYW4gdW5jYXVnaHQgZXhuLiAqKVxuICBpZiBpc19ub25lIHQudW5jYXVnaHRfZXhuXG4gIHRoZW4gKFxuICAgIGxldCBwcmlvcml0eSA9IGV4ZWN1dGlvbl9jb250ZXh0LnByaW9yaXR5IGluXG4gICAgbGV0IGpvYl9xdWV1ZSA9XG4gICAgICBtYXRjaCBwcmlvcml0eSB3aXRoXG4gICAgICB8IE5vcm1hbCAtPiB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzXG4gICAgICB8IExvdyAtPiB0Lmxvd19wcmlvcml0eV9qb2JzXG4gICAgaW5cbiAgICBKb2JfcXVldWUuZW5xdWV1ZSBqb2JfcXVldWUgZXhlY3V0aW9uX2NvbnRleHQgZiBhO1xuICAgIG1hdGNoIHQuam9iX3F1ZXVlZF9ob29rIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgZiAtPiBmIHByaW9yaXR5KVxuOztcblxubGV0IGVucXVldWVfam9iIHQgam9iIH5mcmVlX2pvYiA9XG4gIGxldCBqb2JfcG9vbCA9IHQuam9iX3Bvb2wgaW5cbiAgZW5xdWV1ZVxuICAgIHRcbiAgICAoUG9vbC5nZXQgam9iX3Bvb2wgam9iIFBvb2wuU2xvdC50MClcbiAgICAoUG9vbC5nZXQgam9iX3Bvb2wgam9iIFBvb2wuU2xvdC50MSlcbiAgICAoUG9vbC5nZXQgam9iX3Bvb2wgam9iIFBvb2wuU2xvdC50Mik7XG4gIGlmIGZyZWVfam9iIHRoZW4gUG9vbC5mcmVlIHQuam9iX3Bvb2wgam9iXG47O1xuXG5sZXQgaGFuZGxlX2ZpcmVkICh0aW1lX3NvdXJjZSA6IF8gU3luY2hyb25vdXNfdGltZV9zb3VyY2UuVDEudCkgam9iX29yX2V2ZW50ID1cbiAgbGV0IG9wZW4gSm9iX29yX2V2ZW50Lk1hdGNoIGluXG4gIGxldCAoSyBrKSA9IGtpbmQgam9iX29yX2V2ZW50IGluXG4gIG1hdGNoIGssIHByb2plY3QgayBqb2Jfb3JfZXZlbnQgd2l0aFxuICB8IEpvYiwgam9iIC0+IGVucXVldWVfam9iIHRpbWVfc291cmNlLnNjaGVkdWxlciBqb2IgfmZyZWVfam9iOnRydWVcbiAgfCBFdmVudCwgZXZlbnQgLT4gU3luY2hyb25vdXNfdGltZV9zb3VyY2UuZmlyZSB0aW1lX3NvdXJjZSBldmVudFxuOztcblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCBub3cgPSBUaW1lX25zLm5vdyAoKSBpblxuICBsZXQgcmVjIHQgPVxuICAgIHsgY2hlY2tfYWNjZXNzID0gTm9uZVxuICAgIDsgam9iX3Bvb2wgPSBKb2JfcG9vbC5jcmVhdGUgKClcbiAgICA7IG5vcm1hbF9wcmlvcml0eV9qb2JzID0gSm9iX3F1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgbG93X3ByaW9yaXR5X2pvYnMgPSBKb2JfcXVldWUuY3JlYXRlICgpXG4gICAgOyB2ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzID0gRGVxdWUuY3JlYXRlICgpXG4gICAgOyBtYWluX2V4ZWN1dGlvbl9jb250ZXh0ID0gRXhlY3V0aW9uX2NvbnRleHQubWFpblxuICAgIDsgY3VycmVudF9leGVjdXRpb25fY29udGV4dCA9IEV4ZWN1dGlvbl9jb250ZXh0Lm1haW5cbiAgICA7IHVuY2F1Z2h0X2V4biA9IE5vbmVcbiAgICA7IGN5Y2xlX3N0YXJ0ID0gbm93XG4gICAgOyBjeWNsZV9jb3VudCA9IDBcbiAgICA7IGluX2N5Y2xlID0gZmFsc2VcbiAgICA7IHJ1bl9ldmVyeV9jeWNsZV9zdGFydCA9IFt8fF1cbiAgICA7IHJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZSA9IEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgVHlwZXMuQ3ljbGVfaG9va19oYW5kbGUpXG4gICAgOyBydW5fZXZlcnlfY3ljbGVfZW5kID0gW3x8XVxuICAgIDsgcnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSA9IEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgVHlwZXMuQ3ljbGVfaG9va19oYW5kbGUpXG4gICAgOyBsYXN0X2N5Y2xlX3RpbWUgPSBzZWMgMC5cbiAgICA7IGxhc3RfY3ljbGVfbnVtX2pvYnMgPSAwXG4gICAgOyB0b3RhbF9jeWNsZV90aW1lID0gc2VjIDAuXG4gICAgOyB0aW1lX3NvdXJjZVxuICAgIDsgZXh0ZXJuYWxfam9icyA9IFRocmVhZF9zYWZlX3F1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgPSBpZ25vcmVcbiAgICA7IGpvYl9xdWV1ZWRfaG9vayA9IE5vbmVcbiAgICA7IGV2ZW50X2FkZGVkX2hvb2sgPSBOb25lXG4gICAgOyB5aWVsZCA9IEJ2YXIuY3JlYXRlICgpXG4gICAgOyB5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiA9IEJ2YXIuY3JlYXRlICgpICgqIGNvbmZpZ3VyYXRpb24gKilcbiAgICA7IGNoZWNrX2ludmFyaWFudHMgPSBBc3luY19rZXJuZWxfY29uZmlnLmNoZWNrX2ludmFyaWFudHNcbiAgICA7IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlID1cbiAgICAgICAgQXN5bmNfa2VybmVsX2NvbmZpZy5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuICAgIDsgcmVjb3JkX2JhY2t0cmFjZXMgPSBBc3luY19rZXJuZWxfY29uZmlnLnJlY29yZF9iYWNrdHJhY2VzXG4gICAgfVxuICBhbmQgZXZlbnRzID1cbiAgICBUaW1pbmdfd2hlZWwuY3JlYXRlIH5jb25maWc6QXN5bmNfa2VybmVsX2NvbmZpZy50aW1pbmdfd2hlZWxfY29uZmlnIH5zdGFydDpub3dcbiAgYW5kIHRpbWVfc291cmNlIDogXyBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5UMS50ID1cbiAgICB7IGlkID0gVHlwZXMuVGltZV9zb3VyY2VfaWQuY3JlYXRlICgpXG4gICAgOyBhZHZhbmNlX2Vycm9ycyA9IFtdXG4gICAgOyBhbV9hZHZhbmNpbmcgPSBmYWxzZVxuICAgIDsgZXZlbnRzXG4gICAgOyBoYW5kbGVfZmlyZWQgPSAoZnVuIGFsYXJtIC0+IGhhbmRsZV9maXJlZCB0aW1lX3NvdXJjZSAoQWxhcm0udmFsdWUgZXZlbnRzIGFsYXJtKSlcbiAgICA7IGZpcmVkX2V2ZW50cyA9IEV2ZW50Lk9wdGlvbi5ub25lXG4gICAgOyBpc193YWxsX2Nsb2NrID0gdHJ1ZVxuICAgIDsgbW9zdF9yZWNlbnRseV9maXJlZCA9IEV2ZW50Lk9wdGlvbi5ub25lXG4gICAgOyBzY2hlZHVsZXIgPSB0XG4gICAgfVxuICBpblxuICB0XG47O1xuXG5sZXQgaXNfZGVhZCB0ID0gaXNfc29tZSB0LnVuY2F1Z2h0X2V4blxubGV0IHNldF9jaGVja19hY2Nlc3MgdCBmID0gdC5jaGVja19hY2Nlc3MgPC0gZlxuXG5sZXQgYmFja3RyYWNlX29mX2ZpcnN0X2pvYiB0ID1cbiAgT3B0aW9uLmZpcnN0X3NvbWVcbiAgICAoSm9iX3F1ZXVlLmJhY2t0cmFjZV9vZl9maXJzdF9lbnF1ZXVlIHQubm9ybWFsX3ByaW9yaXR5X2pvYnMpXG4gICAgKEpvYl9xdWV1ZS5iYWNrdHJhY2Vfb2ZfZmlyc3RfZW5xdWV1ZSB0Lmxvd19wcmlvcml0eV9qb2JzKVxuOztcblxubGV0IHRfcmVmID1cbiAgbWF0Y2ggUmVzdWx0LnRyeV93aXRoIGNyZWF0ZSB3aXRoXG4gIHwgT2sgdCAtPiByZWYgdFxuICB8IEVycm9yIGV4biAtPlxuICAgIERlYnVnLmxvZyBcIkFzeW5jIGNhbm5vdCBjcmVhdGUgaXRzIHJhdyBzY2hlZHVsZXJcIiBleG4gWyVzZXhwX29mOiBleG5dO1xuICAgIGV4aXQgMVxuOztcblxubGV0IGNoZWNrX2FjY2VzcyB0ID1cbiAgbWF0Y2ggdC5jaGVja19hY2Nlc3Mgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGYgLT4gZiAoKVxuOztcblxubGV0IHQgKCkgPVxuICBsZXQgdCA9ICF0X3JlZiBpblxuICBjaGVja19hY2Nlc3MgdDtcbiAgdFxuOztcblxubGV0IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCA9XG4gIGlmIHQucmVjb3JkX2JhY2t0cmFjZXNcbiAgdGhlbiBFeGVjdXRpb25fY29udGV4dC5yZWNvcmRfYmFja3RyYWNlIHQuY3VycmVudF9leGVjdXRpb25fY29udGV4dFxuICBlbHNlIHQuY3VycmVudF9leGVjdXRpb25fY29udGV4dFxuOztcblxubGV0IHdpdGhfZXhlY3V0aW9uX2NvbnRleHQxIHQgdG1wX2NvbnRleHQgfmYgeCA9XG4gIGxldCBvbGRfY29udGV4dCA9IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCBpblxuICBzZXRfZXhlY3V0aW9uX2NvbnRleHQgdCB0bXBfY29udGV4dDtcbiAgcHJvdGVjdHggfmYgeCB+ZmluYWxseTooZnVuIF8gLT4gc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHQgb2xkX2NvbnRleHQpXG47O1xuXG5sZXQgd2l0aF9leGVjdXRpb25fY29udGV4dCB0IHRtcF9jb250ZXh0IH5mID0gd2l0aF9leGVjdXRpb25fY29udGV4dDEgdCB0bXBfY29udGV4dCB+ZiAoKVxuXG5sZXQgY3JlYXRlX2pvYiAodHlwZSBhKSB0IGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIGlmIFBvb2wuaXNfZnVsbCB0LmpvYl9wb29sIHRoZW4gdC5qb2JfcG9vbCA8LSBQb29sLmdyb3cgdC5qb2JfcG9vbDtcbiAgUG9vbC5uZXczXG4gICAgdC5qb2JfcG9vbFxuICAgIGV4ZWN1dGlvbl9jb250ZXh0XG4gICAgKE9iai5tYWdpYyAoZiA6IGEgLT4gdW5pdCkgOiBPYmoudCAtPiB1bml0KVxuICAgIChPYmoucmVwciAoYSA6IGEpKVxuOztcblxubGV0IGdvdF91bmNhdWdodF9leG4gdCBleG4gc2V4cCA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwiZ290X3VuY2F1Z2h0X2V4blwiIChleG4sIHNleHApIFslc2V4cF9vZjogRXhuLnQgKiBTZXhwLnRdO1xuICBMaXN0Lml0ZXIgWyB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzOyB0Lmxvd19wcmlvcml0eV9qb2JzIF0gfmY6Sm9iX3F1ZXVlLmNsZWFyO1xuICB0LnVuY2F1Z2h0X2V4biA8LSBTb21lIChleG4sIHNleHApXG47O1xuXG4oKiBbc3RhcnRfY3ljbGUgdCB+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV0gZW5hYmxlcyBzdWJzZXF1ZW50IGNhbGxzIG9mIFtydW5fam9ic11cbiAgIHRvIHJ1biB1cCB0byBbbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV0gam9icyBvZiBlYWNoIHByaW9yaXR5IGxldmVsLiAqKVxubGV0IHN0YXJ0X2N5Y2xlIHQgfm1heF9udW1fam9ic19wZXJfcHJpb3JpdHkgPVxuICBsZXQgbiA9IE1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlLnJhdyBtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5IGluXG4gIEpvYl9xdWV1ZS5zZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgdC5ub3JtYWxfcHJpb3JpdHlfam9icyBuO1xuICBKb2JfcXVldWUuc2V0X2pvYnNfbGVmdF90aGlzX2N5Y2xlIHQubG93X3ByaW9yaXR5X2pvYnMgblxuOztcblxuKCogW3J1bl9qb2JzIHRdIHJlbW92ZXMgam9icyBmcm9tIFt0XSBvbmUgYXQgYSB0aW1lIGFuZCBydW5zIHRoZW0sIHN0b3BwaW5nIGFzIHNvb25cbiAgIGFzIGFuIHVuaGFuZGxlZCBleGNlcHRpb24gaXMgcmFpc2VkLCBvciB3aGVuIG5vIG1vcmUgam9icyBjYW4gYmUgcnVuIGF0IGFueSBwcmlvcml0eSxcbiAgIGFzIHBlciBbfm1heF9udW1fam9ic19wZXJfcHJpb3JpdHldLiAqKVxubGV0IHJlYyBydW5fam9icyB0ID1cbiAgbWF0Y2ggSm9iX3F1ZXVlLnJ1bl9qb2JzIHQubm9ybWFsX3ByaW9yaXR5X2pvYnMgdCB3aXRoXG4gIHwgRXJyb3IgXyBhcyBlIC0+IGVcbiAgfCBPayAoKSAtPlxuICAgIChtYXRjaCBKb2JfcXVldWUucnVuX2pvYnMgdC5sb3dfcHJpb3JpdHlfam9icyB0IHdpdGhcbiAgICAgfCBFcnJvciBfIGFzIGUgLT4gZVxuICAgICB8IE9rICgpIC0+XG4gICAgICAgaWYgSm9iX3F1ZXVlLmNhbl9ydW5fYV9qb2IgdC5ub3JtYWxfcHJpb3JpdHlfam9ic1xuICAgICAgICAgIHx8IEpvYl9xdWV1ZS5jYW5fcnVuX2Ffam9iIHQubG93X3ByaW9yaXR5X2pvYnNcbiAgICAgICB0aGVuIHJ1bl9qb2JzIHRcbiAgICAgICBlbHNlIE9rICgpKVxuOztcblxubGV0IHN0YWJpbGl6ZSB0ID1cbiAgc3RhcnRfY3ljbGVcbiAgICB0XG4gICAgfm1heF9udW1fam9ic19wZXJfcHJpb3JpdHk6XG4gICAgICAoTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUuY3JlYXRlX2V4biBJbnQubWF4X3ZhbHVlKTtcbiAgbWF0Y2ggcnVuX2pvYnMgdCB3aXRoXG4gIHwgT2sgKCkgLT4gT2sgKClcbiAgfCBFcnJvciAoZXhuLCBfYmFja3RyYWNlKSAtPiBFcnJvciBleG5cbjs7XG5cbmxldCBjcmVhdGVfdGltZV9zb3VyY2VcbiAgPyh0aW1pbmdfd2hlZWxfY29uZmlnID0gQXN5bmNfa2VybmVsX2NvbmZpZy50aW1pbmdfd2hlZWxfY29uZmlnKVxuICB+bm93XG4gICgpXG4gID1cbiAgbGV0IHQgPSB0ICgpIGluXG4gIGxldCBldmVudHMgPSBUaW1pbmdfd2hlZWwuY3JlYXRlIH5jb25maWc6dGltaW5nX3doZWVsX2NvbmZpZyB+c3RhcnQ6bm93IGluXG4gIGxldCByZWMgdGltZV9zb3VyY2UgOiBfIFN5bmNocm9ub3VzX3RpbWVfc291cmNlLlQxLnQgPVxuICAgIHsgaWQgPSBUeXBlcy5UaW1lX3NvdXJjZV9pZC5jcmVhdGUgKClcbiAgICA7IGFkdmFuY2VfZXJyb3JzID0gW11cbiAgICA7IGFtX2FkdmFuY2luZyA9IGZhbHNlXG4gICAgOyBldmVudHNcbiAgICA7IGhhbmRsZV9maXJlZCA9IChmdW4gYWxhcm0gLT4gaGFuZGxlX2ZpcmVkIHRpbWVfc291cmNlIChBbGFybS52YWx1ZSBldmVudHMgYWxhcm0pKVxuICAgIDsgZmlyZWRfZXZlbnRzID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IGlzX3dhbGxfY2xvY2sgPSBmYWxzZVxuICAgIDsgbW9zdF9yZWNlbnRseV9maXJlZCA9IEV2ZW50Lk9wdGlvbi5ub25lXG4gICAgOyBzY2hlZHVsZXIgPSB0XG4gICAgfVxuICBpblxuICB0aW1lX3NvdXJjZVxuOztcblxubGV0IHdhbGxfY2xvY2sgKCkgPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5yZWFkX29ubHkgKHQgKCkpLnRpbWVfc291cmNlXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIxXG5tb2R1bGUgQ2VsbCA9IFR5cGVzLkNlbGxcblxudHlwZSBhbnkgPVxuICBbIGBFbXB0eVxuICB8IGBFbXB0eV9vbmVfaGFuZGxlclxuICB8IGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVyc1xuICB8IGBGdWxsXG4gIHwgYEluZGlyXG4gIF1cblxudHlwZSAnYSB0ID0gJ2EgVHlwZXMuSXZhci50ID0geyBtdXRhYmxlIGNlbGwgOiAoJ2EsIGFueSkgY2VsbCB9XG5cbigqIFRoZSBbJ2JdIGlzIHVzZWQgdG8gZW5jb2RlIHRoZSBjb25zdHJ1Y3Rvci4gIFRoaXMgYWxsb3dzIHVzIHRvIHdyaXRlIGZ1bmN0aW9ucyB0aGF0XG4gICB0YWtlIG9ubHkgb25lIG9mIHRoZSBjb25zdHJ1Y3RvcnMsIHdpdGggbm8gcnVudGltZSB0ZXN0LlxuXG4gICBXZSBtYWludGFpbiB0aGUgaW52YXJpYW50IHRoYXQgdGhlIGRpcmVjdGVkIGdyYXBoIHdpdGggaXZhcnMgYXMgbm9kZXMgYW5kIFtJbmRpcl1zIGFzXG4gICBlZGdlcyBpcyBhY3ljbGljLiAgVGhlIG9ubHkgZnVuY3Rpb25zIHRoYXQgY3JlYXRlIGFuIFtJbmRpcl0gYXJlIFtzcXVhc2hdIGFuZFxuICAgW2Nvbm5lY3RdLCBhbmQgZm9yIHRob3NlLCB0aGUgdGFyZ2V0IG9mIHRoZSBbSW5kaXJdIGlzIGFsd2F5cyBhIG5vbi1bSW5kaXJdLiAgVGh1cywgdGhlXG4gICBuZXdseSBhZGRlZCBlZGdlcyBhcmUgbmV2ZXIgcGFydCBvZiBhIGN5Y2xlLiAqKVxuYW5kICgnYSwgJ2IpIGNlbGwgPSAoJ2EsICdiKSBUeXBlcy5DZWxsLnQgPVxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIDpcbiAgICAgIHsgKCogW3J1bl0gaXMgbXV0YWJsZSBzbyB3ZSBjYW4gc2V0IGl0IHRvIFtpZ25vcmVdIHdoZW4gdGhlIGhhbmRsZXIgaXMgcmVtb3ZlZC5cbiAgICAgICAgICAgVGhpcyBpcyB1c2VkIHdoZW4gd2UgaW5zdGFsbCBhIGhhbmRsZXIgb24gYSBmdWxsIGl2YXIgc2luY2UgaXQgaXMgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgYWRkZWQgdG8gdGhlIHNjaGVkdWxlci4gKilcbiAgICAgICAgbXV0YWJsZSBydW4gOiAnYSAtPiB1bml0XG4gICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgICAgOyAoKiBbcHJldl0gYW5kIFtuZXh0XSBjaXJjdWxhcmx5IGRvdWJseSBsaW5rIGFsbCBoYW5kbGVycyBvZiB0aGUgc2FtZSBpdmFyLiAqKVxuICAgICAgICBtdXRhYmxlIHByZXYgOiAoJ2EsIFsgYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF0pIGNlbGxcbiAgICAgIDsgbXV0YWJsZSBuZXh0IDogKCdhLCBbIGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBdKSBjZWxsXG4gICAgICB9XG4gICAgICAtPiAoJ2EsIFs+IGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBdKSBjZWxsXG4gIHwgRW1wdHlfb25lX2hhbmRsZXIgOlxuICAgICAgKCdhIC0+IHVuaXQpICogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgICAgLT4gKCdhLCBbPiBgRW1wdHlfb25lX2hhbmRsZXIgXSkgY2VsbFxuICB8IEVtcHR5IDogKCdhLCBbPiBgRW1wdHkgXSkgY2VsbFxuICB8IEZ1bGwgOiAnYSAtPiAoJ2EsIFs+IGBGdWxsIF0pIGNlbGxcbiAgfCBJbmRpciA6ICdhIHQgLT4gKCdhLCBbPiBgSW5kaXIgXSkgY2VsbFxuXG5tb2R1bGUgSGFuZGxlciA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAoJ2EsIFsgYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF0pIGNlbGxcblxuICBsZXQgcnVuIChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSA9IHQucnVuXG4gIGxldCBleGVjdXRpb25fY29udGV4dCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgdCA6IF8gdCkgPSB0LmV4ZWN1dGlvbl9jb250ZXh0XG4gIGxldCBwcmV2IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSA9IHQucHJldlxuICBsZXQgbmV4dCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgdCA6IF8gdCkgPSB0Lm5leHRcbiAgbGV0IHNldF9ydW4gKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpIHggPSB0LnJ1biA8LSB4XG4gIGxldCBzZXRfcHJldiAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgdCA6IF8gdCkgeCA9IHQucHJldiA8LSB4XG4gIGxldCBzZXRfbmV4dCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgdCA6IF8gdCkgeCA9IHQubmV4dCA8LSB4XG5cbiAgbGV0IGNyZWF0ZSBydW4gZXhlY3V0aW9uX2NvbnRleHQgPVxuICAgICgqIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBvZjpcblxuICAgICAgIHtbXG4gICAgICAgICBsZXQgcmVjIHQgPVxuICAgICAgICAgICBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVyc1xuICAgICAgICAgICAgIHsgcnVuXG4gICAgICAgICAgICAgOyBleGVjdXRpb25fY29udGV4dFxuICAgICAgICAgICAgIDsgcHJldiAgICAgICAgICAgICAgPSB0XG4gICAgICAgICAgICAgOyBuZXh0ICAgICAgICAgICAgICA9IHQgfVxuICAgICAgICAgaW5cbiAgICAgICAgIGgxIF19XG5cbiAgICAgICBIb3dldmVyIHRoZSBjb21waWxhdGlvbiBvZiByZWN1cnNpdmUgdmFsdWUgaW4gT0NhbWwgaXMgbm90IG9wdGltYWw6IHRoZSB2YWx1ZSBpc1xuICAgICAgIGFsbG9jYXRlZCB0d2ljZSBhbmQgY29waWVkIG9uY2UgKHdpdGggYSBsb29wIGNhbGxpbmcgY2FtbF9tb2RpZnkpLiAgVGhpcyBpcyBub3RcbiAgICAgICBuZWNlc3NhcnkgZm9yIHNpbXBsZSByZWN1cnNpdmUgZGVmaW5pdGlvbnMgbGlrZSB0aGlzIG9uZS5cblxuICAgICAgIEluc3RlYWQgd2UgYWxsb2NhdGUgdGhlIHZhbHVlIHdpdGggZHVtbXkgZmllbGRzIGFuZCB1cGRhdGUgdGhlbSBhZnRlci4gKilcbiAgICBsZXQgdCA9XG4gICAgICBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVyc1xuICAgICAgICB7IHJ1bjsgZXhlY3V0aW9uX2NvbnRleHQ7IHByZXYgPSBPYmoubWFnaWMgTm9uZTsgbmV4dCA9IE9iai5tYWdpYyBOb25lIH1cbiAgICBpblxuICAgIHNldF9wcmV2IHQgdDtcbiAgICBzZXRfbmV4dCB0IHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCBjcmVhdGUyIHJ1bjEgZXhlY3V0aW9uX2NvbnRleHQxIHJ1bjIgZXhlY3V0aW9uX2NvbnRleHQyID1cbiAgICAoKiBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gb2Y6XG5cbiAgICAgICB7W1xuICAgICAgICAgbGV0IHJlYyB0MSA9XG4gICAgICAgICAgIHsgcnVuICAgICAgICAgICAgICAgPSBydW4xXG4gICAgICAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgPSBleGVjdXRpb25fY29udGV4dDFcbiAgICAgICAgICAgOyBwcmV2ICAgICAgICAgICAgICA9IHQyXG4gICAgICAgICAgIDsgbmV4dCAgICAgICAgICAgICAgPSB0MiB9XG4gICAgICAgICBhbmQgdDIgPVxuICAgICAgICAgICB7IHJ1biAgICAgICAgICAgICAgID0gcnVuMlxuICAgICAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0ID0gZXhlY3V0aW9uX2NvbnRleHQyXG4gICAgICAgICAgIDsgcHJldiAgICAgICAgICAgICAgPSB0MVxuICAgICAgICAgICA7IG5leHQgICAgICAgICAgICAgID0gdDEgfVxuICAgICAgICAgaW5cbiAgICAgICAgIHQxIF19ICopXG4gICAgbGV0IHQxID1cbiAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzXG4gICAgICAgIHsgcnVuID0gcnVuMVxuICAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0ID0gZXhlY3V0aW9uX2NvbnRleHQxXG4gICAgICAgIDsgcHJldiA9IE9iai5tYWdpYyBOb25lXG4gICAgICAgIDsgbmV4dCA9IE9iai5tYWdpYyBOb25lXG4gICAgICAgIH1cbiAgICBpblxuICAgIGxldCB0MiA9XG4gICAgICBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVyc1xuICAgICAgICB7IHJ1biA9IHJ1bjI7IGV4ZWN1dGlvbl9jb250ZXh0ID0gZXhlY3V0aW9uX2NvbnRleHQyOyBwcmV2ID0gdDE7IG5leHQgPSB0MSB9XG4gICAgaW5cbiAgICBzZXRfcHJldiB0MSB0MjtcbiAgICBzZXRfbmV4dCB0MSB0MjtcbiAgICB0MVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgRXhlY3V0aW9uX2NvbnRleHQuaW52YXJpYW50IChleGVjdXRpb25fY29udGV4dCB0KTtcbiAgICBsZXQgciA9IHJlZiAobmV4dCB0KSBpblxuICAgIHdoaWxlIG5vdCAocGh5c19lcXVhbCAhciB0KSBkb1xuICAgICAgbGV0IHQxID0gIXIgaW5cbiAgICAgIGFzc2VydCAocGh5c19lcXVhbCAocHJldiAobmV4dCB0MSkpIHQxKTtcbiAgICAgIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudCAoZXhlY3V0aW9uX2NvbnRleHQgdDEpO1xuICAgICAgciA6PSBuZXh0ICFyXG4gICAgZG9uZVxuICA7O1xuXG4gIGxldCBpc19zaW5nbGV0b24gdCA9IHBoeXNfZXF1YWwgdCAobmV4dCB0KVxuXG4gIGxldCBsZW5ndGggdCA9XG4gICAgbGV0IG4gPSByZWYgMSBpblxuICAgIGxldCByID0gcmVmIChuZXh0IHQpIGluXG4gICAgd2hpbGUgbm90IChwaHlzX2VxdWFsICFyIHQpIGRvXG4gICAgICBpbmNyIG47XG4gICAgICByIDo9IG5leHQgIXJcbiAgICBkb25lO1xuICAgICFuXG4gIDs7XG5cbiAgbGV0IGVucXVldWUgdCBzY2hlZHVsZXIgdiA9IFNjaGVkdWxlci5lbnF1ZXVlIHNjaGVkdWxlciAoZXhlY3V0aW9uX2NvbnRleHQgdCkgKHJ1biB0KSB2XG5cbiAgbGV0IHNjaGVkdWxlX2pvYnMgdCB2ID1cbiAgICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgICBlbnF1ZXVlIHQgc2NoZWR1bGVyIHY7XG4gICAgbGV0IHIgPSByZWYgKG5leHQgdCkgaW5cbiAgICB3aGlsZSBub3QgKHBoeXNfZXF1YWwgIXIgdCkgZG9cbiAgICAgIGVucXVldWUgIXIgc2NoZWR1bGVyIHY7XG4gICAgICByIDo9IG5leHQgIXJcbiAgICBkb25lXG4gIDs7XG5cbiAgbGV0IHVubGluayB0ID1cbiAgICBzZXRfcHJldiAobmV4dCB0KSAocHJldiB0KTtcbiAgICBzZXRfbmV4dCAocHJldiB0KSAobmV4dCB0KTtcbiAgICBzZXRfcHJldiB0IHQ7XG4gICAgc2V0X25leHQgdCB0XG4gIDs7XG5cbiAgbGV0IGFkZCB0IHJ1biBleGVjdXRpb25fY29udGV4dCA9XG4gICAgbGV0IHJlc3VsdCA9XG4gICAgICBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB7IHJ1bjsgZXhlY3V0aW9uX2NvbnRleHQ7IHByZXYgPSBwcmV2IHQ7IG5leHQgPSB0IH1cbiAgICBpblxuICAgIHNldF9uZXh0IChwcmV2IHQpIHJlc3VsdDtcbiAgICBzZXRfcHJldiB0IHJlc3VsdDtcbiAgICByZXN1bHRcbiAgOztcblxuICAoKiBbc3BsaWNlIHQxIHQyXSBjcmVhdGVzOlxuXG4gICAgIHt2XG4gICAgICAgLS0+IHQxIDwtLT4gLi4uIDwtLT4gbGFzdDEgPC0tPiB0MiA8LS0+IC4uLiA8LS0+IGxhc3QyIDwtLVxuICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgIHZ9ICopXG4gIGxldCBzcGxpY2UgdDEgdDIgPVxuICAgIGxldCBsYXN0MSA9IHByZXYgdDEgaW5cbiAgICBsZXQgbGFzdDIgPSBwcmV2IHQyIGluXG4gICAgc2V0X25leHQgbGFzdDEgdDI7XG4gICAgc2V0X25leHQgbGFzdDIgdDE7XG4gICAgc2V0X3ByZXYgdDEgbGFzdDI7XG4gICAgc2V0X3ByZXYgdDIgbGFzdDFcbiAgOztcblxuICBsZXQgb2ZfbGlzdCBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IChydW4sIGV4ZWN1dGlvbl9jb250ZXh0KSA6OiBsIC0+XG4gICAgICBsZXQgZmlyc3QgPSBjcmVhdGUgcnVuIGV4ZWN1dGlvbl9jb250ZXh0IGluXG4gICAgICBsZXQgcmVjIGxvb3AgcHJldiBsID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgW10gLT4gc2V0X3ByZXYgZmlyc3QgcHJldlxuICAgICAgICB8IChydW4sIGV4ZWN1dGlvbl9jb250ZXh0KSA6OiBsIC0+XG4gICAgICAgICAgbGV0IHQgPVxuICAgICAgICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgeyBydW47IGV4ZWN1dGlvbl9jb250ZXh0OyBwcmV2OyBuZXh0ID0gZmlyc3QgfVxuICAgICAgICAgIGluXG4gICAgICAgICAgc2V0X25leHQgcHJldiB0O1xuICAgICAgICAgIGxvb3AgdCBsXG4gICAgICBpblxuICAgICAgbG9vcCBmaXJzdCBsO1xuICAgICAgU29tZSBmaXJzdFxuICA7O1xuXG4gIGxldCB0b19saXN0IGZpcnN0ID1cbiAgICBsZXQgcmVjIGxvb3AgdCBhY2MgPVxuICAgICAgbGV0IGFjYyA9IChydW4gdCwgZXhlY3V0aW9uX2NvbnRleHQgdCkgOjogYWNjIGluXG4gICAgICBpZiBwaHlzX2VxdWFsIHQgZmlyc3QgdGhlbiBhY2MgZWxzZSBsb29wIChwcmV2IHQpIGFjY1xuICAgIGluXG4gICAgbG9vcCAocHJldiBmaXJzdCkgW11cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IF8gKHQgOiBfIHQpID1cbiAgICBsZXQgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHsgcnVuID0gXzsgZXhlY3V0aW9uX2NvbnRleHQ7IG5leHQgPSBfOyBwcmV2ID0gXyB9KSA9XG4gICAgICB0XG4gICAgaW5cbiAgICBbJW1lc3NhZ2UgKGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudCldXG4gIDs7XG5lbmRcblxudHlwZSAnYSBpdmFyID0gJ2EgdFxuXG4oKiBDb21waWxlZCBhcyB0aGUgaWRlbnRpdHkuICopXG5sZXQgY2VsbF9vZl9oYW5kbGVyIDogXyBIYW5kbGVyLnQgLT4gXyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyB4IC0+ICh4IDo+IChfLCBhbnkpIGNlbGwpXG47O1xuXG5sZXQgZXF1YWwgKHQgOiBfIHQpIHQnID0gcGh5c19lcXVhbCB0IHQnXG5sZXQgaW5kaXIgdCA9IHsgY2VsbCA9IEluZGlyIHQgfVxuXG5pbmNsdWRlIFNjaGVkdWxlci5JdmFyXG5cbigqIFtzcXVhc2ggdF0gcmV0dXJucyB0aGUgbm9uLVtJbmRpcl0gaXZhciBhdCB0aGUgZW5kIG9mIHRoZSAocG9zc2libHkgZW1wdHkpIGNoYWluIG9mXG4gICBbSW5kaXJdcyBzdGFydGluZyB3aXRoIFt0XSBhbmQgZW5zdXJlcyB0aGF0IGFsbCBbSW5kaXJdcyBhbG9uZyB0aGF0IGNoYWluIGFyZSByZXBsYWNlZFxuICAgd2l0aCBhbiBbSW5kaXJdIHBvaW50aW5nIHRvIHRoZSBlbmQgb2YgdGhlIGNoYWluLiAqKVxubGV0IHNxdWFzaCA9XG4gIGxldCByZWMgZm9sbG93IGluZGlyIHQgPVxuICAgICgqIFtpbmRpciA9IEluZGlyIHRdICopXG4gICAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgICB8IEluZGlyIHQnIGFzIGluZGlyJyAtPiBmb2xsb3cgaW5kaXInIHQnXG4gICAgfCBfIC0+IGluZGlyXG4gIGluXG4gIGxldCByZWMgdXBkYXRlIHQgaW5kaXIgPVxuICAgIG1hdGNoIHQuY2VsbCB3aXRoXG4gICAgfCBJbmRpciB0JyAtPlxuICAgICAgdC5jZWxsIDwtIGluZGlyO1xuICAgICAgdXBkYXRlIHQnIGluZGlyXG4gICAgfCBfIC0+IHRcbiAgaW5cbiAgZnVuIHQgLT5cbiAgICBtYXRjaCB0LmNlbGwgd2l0aFxuICAgIHwgSW5kaXIgdCcgLT5cbiAgICAgIChtYXRjaCB0Jy5jZWxsIHdpdGhcbiAgICAgICB8IEluZGlyIHQnJyBhcyBpbmRpciAtPiB1cGRhdGUgdCAoZm9sbG93IGluZGlyIHQnJylcbiAgICAgICB8IF8gLT4gdCcgKCogbm90aGluZyB0byBkbywgc2luY2UgW3RdIGlzIGEgY2hhaW4gd2l0aCBhIHNpbmdsZSBbSW5kaXJdICopKVxuICAgIHwgXyAtPiB0XG47O1xuXG4oKiBub3RoaW5nIHRvIGRvLCBzaW5jZSBbdF0gaXNuJ3QgYW4gW0luZGlyXS4gKilcblxubGV0IGludmFyaWFudCBhX2ludmFyaWFudCB0ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEZ1bGwgYSAtPiBhX2ludmFyaWFudCBhXG4gIHwgRW1wdHkgLT4gKClcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciAoXywgZXhlY3V0aW9uX2NvbnRleHQpIC0+XG4gICAgRXhlY3V0aW9uX2NvbnRleHQuaW52YXJpYW50IGV4ZWN1dGlvbl9jb250ZXh0XG4gIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyIC0+IEhhbmRsZXIuaW52YXJpYW50IGhhbmRsZXJcbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgOiBTZXhwLnQgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBhIC0+IExpc3QgWyBBdG9tIFwiRnVsbFwiOyBzZXhwX29mX2EgYSBdXG4gIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPiBBdG9tIFwiRW1wdHlcIlxuOztcblxubGV0IHBlZWsgdCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIGEgLT4gU29tZSBhXG4gIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPiBOb25lXG47O1xuXG5sZXQgdmFsdWUgdCB+aWZfZW1wdHlfdGhlbl9mYWlsd2l0aCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIGEgLT4gYVxuICB8IEVtcHR5IHwgRW1wdHlfb25lX2hhbmRsZXIgXyB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gLT5cbiAgICBmYWlsd2l0aCBpZl9lbXB0eV90aGVuX2ZhaWx3aXRoXG47O1xuXG5sZXQgdmFsdWVfZXhuIHQgPSB2YWx1ZSB0IH5pZl9lbXB0eV90aGVuX2ZhaWx3aXRoOlwiSXZhci52YWx1ZV9leG4gY2FsbGVkIG9uIGVtcHR5IGl2YXJcIlxuXG5sZXQgaXNfZW1wdHkgdCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIF8gLT4gZmFsc2VcbiAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIC0+IHRydWVcbjs7XG5cbmxldCBpc19mdWxsIHQgPSBub3QgKGlzX2VtcHR5IHQpXG5cbmxldCBmaWxsX2V4biB0IHYgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBfIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiSXZhci5maWxsX2V4biBjYWxsZWQgb24gZnVsbCBpdmFyXCIgKHQgOiBfIHQpXVxuICB8IEVtcHR5IC0+IHQuY2VsbCA8LSBGdWxsIHZcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciAocnVuLCBleGVjdXRpb25fY29udGV4dCkgLT5cbiAgICB0LmNlbGwgPC0gRnVsbCB2O1xuICAgIFNjaGVkdWxlci4oZW5xdWV1ZSAodCAoKSkpIGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB2XG4gIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyIC0+XG4gICAgdC5jZWxsIDwtIEZ1bGwgdjtcbiAgICBIYW5kbGVyLnNjaGVkdWxlX2pvYnMgaGFuZGxlciB2XG47O1xuXG5sZXQgZmlsbCA9IGZpbGxfZXhuXG5cbmxldCByZW1vdmVfaGFuZGxlciB0IChoYW5kbGVyIDogXyBIYW5kbGVyLnQpID1cbiAgSGFuZGxlci5zZXRfcnVuIGhhbmRsZXIgaWdub3JlO1xuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIC0+XG4gICAgKCogVGhlc2UgYXJlIG9ubHkgcG9zc2libGUgaWYgW2hhbmRsZXJdIHdhcyBhbHJlYWR5IHJlbW92ZWQuICAqKVxuICAgICgpXG4gIHwgRnVsbCBfIC0+XG4gICAgKCogVGhpcyBpcyBwb3NzaWJsZSBpZiBbdF0gd2FzIGZpbGxlZCBiZWZvcmUgd2UgdHJ5IHRvIHJlbW92ZSB0aGUgaGFuZGxlci4gIEUuZy5cbiAgICAgICBbRGVmZXJyZWQuY2hvb3NlXSB3aWxsIGRvIHRoaXMuICopXG4gICAgKClcbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGNlbGwgLT5cbiAgICBpZiBIYW5kbGVyLmlzX3NpbmdsZXRvbiBoYW5kbGVyXG4gICAgdGhlbiB0LmNlbGwgPC0gRW1wdHlcbiAgICBlbHNlIChcbiAgICAgIGlmIHBoeXNfZXF1YWwgaGFuZGxlciBjZWxsIHRoZW4gdC5jZWxsIDwtIGNlbGxfb2ZfaGFuZGxlciAoSGFuZGxlci5uZXh0IGhhbmRsZXIpO1xuICAgICAgSGFuZGxlci51bmxpbmsgaGFuZGxlcilcbjs7XG5cbmxldCBhZGRfaGFuZGxlciB0IHJ1biBleGVjdXRpb25fY29udGV4dCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBFbXB0eSAtPlxuICAgIGxldCBoYW5kbGVyID0gSGFuZGxlci5jcmVhdGUgcnVuIGV4ZWN1dGlvbl9jb250ZXh0IGluXG4gICAgdC5jZWxsIDwtIGNlbGxfb2ZfaGFuZGxlciBoYW5kbGVyO1xuICAgIGhhbmRsZXJcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciAocnVuJywgZXhlY3V0aW9uX2NvbnRleHQnKSAtPlxuICAgIGxldCBoYW5kbGVyID0gSGFuZGxlci5jcmVhdGUyIHJ1biBleGVjdXRpb25fY29udGV4dCBydW4nIGV4ZWN1dGlvbl9jb250ZXh0JyBpblxuICAgIHQuY2VsbCA8LSBjZWxsX29mX2hhbmRsZXIgaGFuZGxlcjtcbiAgICBoYW5kbGVyXG4gIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyIC0+IEhhbmRsZXIuYWRkIGhhbmRsZXIgcnVuIGV4ZWN1dGlvbl9jb250ZXh0XG4gIHwgRnVsbCB2IC0+XG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyLmNyZWF0ZSBydW4gZXhlY3V0aW9uX2NvbnRleHQgaW5cbiAgICAoKiBbcnVuXSBjYWxscyBbaGFuZGxlci5ydW5dLCB3aGljaCwgaWYgW2hhbmRsZXJdIGhhcyBiZWVuIHJlbW92ZWQsIGhhcyBiZWVuIGNoYW5nZWRcbiAgICAgICB0byBbaWdub3JlXS4gKilcbiAgICBsZXQgcnVuIHYgPSBIYW5kbGVyLnJ1biBoYW5kbGVyIHYgaW5cbiAgICBTY2hlZHVsZXIuKGVucXVldWUgKHQgKCkpKSBleGVjdXRpb25fY29udGV4dCBydW4gdjtcbiAgICBoYW5kbGVyXG47O1xuXG5sZXQgaGFzX2hhbmRsZXJzIHQgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRW1wdHlfb25lX2hhbmRsZXIgXyB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gLT4gdHJ1ZVxuICB8IEVtcHR5IHwgRnVsbCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgdXBvbicgdCBydW4gPSBhZGRfaGFuZGxlciB0IHJ1biBTY2hlZHVsZXIuKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKVxuXG4oKiBbdXBvbl0gaXMgY29uY2VwdHVhbGx5IHRoZSBzYW1lIGFzOlxuXG4gICB7W1xuICAgICBsZXQgdXBvbiB0IGYgPSBpZ25vcmUgKHVwb24nIHQgcnVuKSBdfVxuXG4gICBIb3dldmVyLCBiZWxvdyBpcyBhIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyB3b3J0aCBkb2luZyBiZWNhdXNlIFt1cG9uXVxuICAgaXMgdmVyeSB3aWRlbHkgdXNlZCBhbmQgaXMgc28gbXVjaCBtb3JlIGNvbW1vbiB0aGFuIFt1cG9uJ10uICBUaGUgYmVsb3cgaW1wbGVtZW50YXRpb25cbiAgIGF2b2lkcyB0aGUgdXNlIG9mIHRoZSBiYWcgb2YgaGFuZGxlcnMgaW4gdGhlIGV4dHJlbWVseSBjb21tb24gY2FzZSBvZiBvbmUgaGFuZGxlciBmb3JcbiAgIHRoZSBkZWZlcnJlZC4gKilcbmxldCB1cG9uIHQgcnVuID1cbiAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlciBpblxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCB2IC0+IFNjaGVkdWxlci5lbnF1ZXVlIHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBydW4gdlxuICB8IEVtcHR5IC0+IHQuY2VsbCA8LSBFbXB0eV9vbmVfaGFuZGxlciAocnVuLCBleGVjdXRpb25fY29udGV4dClcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciAocnVuJywgZXhlY3V0aW9uX2NvbnRleHQnKSAtPlxuICAgIHQuY2VsbFxuICAgICAgPC0gY2VsbF9vZl9oYW5kbGVyIChIYW5kbGVyLmNyZWF0ZTIgcnVuIGV4ZWN1dGlvbl9jb250ZXh0IHJ1bicgZXhlY3V0aW9uX2NvbnRleHQnKVxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlciAtPlxuICAgIGlnbm9yZSAoSGFuZGxlci5hZGQgaGFuZGxlciBydW4gZXhlY3V0aW9uX2NvbnRleHQgOiBfIEhhbmRsZXIudClcbjs7XG5cbigqIFtjb25uZWN0XSB0YWtlcyBpdmFycyBbYmluZF9yZXN1bHRdIGFuZCBbYmluZF9yaHNdLCBhbmQgbWFrZXMgW2JpbmRfcmhzXVxuICAgYmUgYW4gW0luZGlyXSBwb2ludGluZyB0byB0aGUgbm9uLWluZGlyIGNlbGwgcmVhY2hhYmxlIGZyb20gW2JpbmRfcmVzdWx0XS4gIE9uIGVudHJ5XG4gICB0byBbY29ubmVjdF0sIFtiaW5kX3Jlc3VsdF0gYW5kIFtiaW5kX3Joc10gbWF5IGJlIGNoYWlucywgc2luY2UgW2JpbmRfcmhzXSBpcyBhblxuICAgYXJiaXRyYXJ5IHVzZXItc3VwcGxpZWQgZGVmZXJyZWQsIGFuZCBbYmluZF9yZXN1bHRdIGlzIHJldHVybmVkIHRvIHRoZSB1c2VyIHByaW9yIHRvXG4gICBiZWluZyBbY29ubmVjdF1lZCwgYW5kIG1heSBoYXZlIGJlZW4gY29udmVydGVkIHRvIGFuIGluZGlyZWN0aW9uIGluIHRoZSBjYXNlIG9mXG4gICByaWdodC1uZXN0ZWQgYmluZHMuXG5cbiAgIFRoZSBwdXJwb3NlIG9mIFtjb25uZWN0XSBpcyB0byBtYWtlIHRhaWwtcmVjdXJzaXZlIGJpbmQgbG9vcHMgdXNlIGNvbnN0YW50IHNwYWNlLlxuICAgRS5nLjpcblxuICAge1tcbiAgICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgIGlmIGkgPSAwXG4gICAgICAgdGhlbiByZXR1cm4gKClcbiAgICAgICBlbHNlIChcbiAgICAgICAgIGxldCViaW5kICgpID0gYWZ0ZXIgKHNlYyAxLikgaW5cbiAgICAgICAgIGxvb3AgKGkgLSAxKSkgXX1cblxuICAgW2Nvbm5lY3RdIG1ha2VzIGludGVybWVkaWF0ZSBiaW5kIHJlc3VsdHMgYWxsIGJlIFtJbmRpcl1zIHBvaW50aW5nIGF0IHRoZSBvdXRlcm1vc3RcbiAgIGJpbmQsIHJhdGhlciB0aGFuIGJlaW5nIGEgbGluZWFyLWxlbmd0aCBjaGFpbiwgd2l0aCBlYWNoIHBvaW50aW5nIHRvIHRoZSBwcmV2aW91cyBvbmUuXG4gICBUaGVuLCBzaW5jZSB0aGUgcHJvZ3JhbSBpcyBvbmx5IGhvbGRpbmcgb24gdG8gdGhlIGlubmVybW9zdCBhbmQgb3V0ZXJtb3N0IGJpbmRzIGFsbCB0aGVcbiAgIGludGVybWVkaWF0ZSBvbmVzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cblxuICAgW2Nvbm5lY3RdIHdvcmtzIGJ5IHNxdWFzaGluZyBpdHMgYXJndW1lbnRzIHNvIHRoYXQgdGhlIFtiaW5kX3Joc10gYWx3YXlzIHBvaW50cyBhdCB0aGVcbiAgIHVsdGltYXRlIHJlc3VsdC4gKilcbmxldCBjb25uZWN0ID1cbiAgKCogW3JlcG9pbnRfaW5kaXJzIH5pdmFyIH5pbmRpciB+YmluZF9yZXN1bHRdIHJlcG9pbnRzIHRvIFtpbmRpcl0gYWxsIHRoZSBpdmFycyBpbiB0aGVcbiAgICAgY2hhaW4gcmVhY2hhYmxlIGZyb20gW2l2YXJdLCBhbmQgcmV0dXJucyB0aGUgbm9uLVtJbmRpcl0gY2VsbCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgICBjaGFpbi4gIEFmdGVyIHJlcG9pbnRpbmcsIHdlIHdpbGwgbWVyZ2UgdGhlIGhhbmRsZXJzIGluIHRoYXQgY2VsbCB3aXRoIHRoZSBoYW5kbGVyc1xuICAgICBpbiBbYmluZF9yZXN1bHRdLCBhbmQgcHV0IHRoZSBtZXJnZWQgc2V0IG9mIGhhbmRsZXJzIGluIFtiaW5kX3Jlc3VsdF0uICopXG4gIGxldCByZWMgcmVwb2ludF9pbmRpcnMgfml2YXIgfmluZGlyIH5iaW5kX3Jlc3VsdCA9XG4gICAgbGV0IGNlbGwgPSBpdmFyLmNlbGwgaW5cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IEluZGlyIGl2YXInIC0+XG4gICAgICBpdmFyLmNlbGwgPC0gaW5kaXI7XG4gICAgICByZXBvaW50X2luZGlycyB+aXZhcjppdmFyJyB+aW5kaXIgfmJpbmRfcmVzdWx0XG4gICAgfCBGdWxsIF8gLT4gY2VsbFxuICAgIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPlxuICAgICAgKCogSXQgaXMgcG9zc2libGUgdGhhdCBbYmluZF9yZXN1bHRdIGFuZCBbYmluZF9yaHNdIGFyZSBub3QgZXF1YWwsIGJ1dCB0aGVpciBjaGFpbnNcbiAgICAgICAgIG9mIGluZGlycyBsZWFkIHRvIHRoZSBzYW1lIG5vbi1bSW5kaXJdIGNlbGwsIGluIHdoaWNoIGNhc2Ugd2UgY2Fubm90IHNldCB0aGF0XG4gICAgICAgICBjZWxsIHRvIHBvaW50IHRvIGl0c2VsZiwgYmVjYXVzZSB0aGF0IHdvdWxkIGludHJvZHVjZSBhIGN5Y2xlLiAqKVxuICAgICAgaWYgbm90IChwaHlzX2VxdWFsIGl2YXIgYmluZF9yZXN1bHQpIHRoZW4gaXZhci5jZWxsIDwtIGluZGlyO1xuICAgICAgY2VsbFxuICBpblxuICBmdW4gfmJpbmRfcmVzdWx0IH5iaW5kX3JocyAtPlxuICAgIGlmIG5vdCAocGh5c19lcXVhbCBiaW5kX3Jlc3VsdCBiaW5kX3JocylcbiAgICB0aGVuIChcbiAgICAgIGxldCBiaW5kX3Jlc3VsdCA9IHNxdWFzaCBiaW5kX3Jlc3VsdCBpblxuICAgICAgbGV0IGluZGlyID0gSW5kaXIgYmluZF9yZXN1bHQgaW5cbiAgICAgIGxldCBiaW5kX3Joc19jb250ZW50cyA9IHJlcG9pbnRfaW5kaXJzIH5pdmFyOmJpbmRfcmhzIH5pbmRpciB+YmluZF9yZXN1bHQgaW5cbiAgICAgICgqIHVwZGF0ZSBbYmluZF9yZXN1bHRdIHdpdGggdGhlIHVuaW9uIG9mIGhhbmRsZXJzIGluIFtiaW5kX3Jlc3VsdF0gYW5kXG4gICAgICAgICBbYmluZF9yaHNdICopXG4gICAgICBtYXRjaCBiaW5kX3Jlc3VsdC5jZWxsLCBiaW5kX3Joc19jb250ZW50cyB3aXRoXG4gICAgICB8IEluZGlyIF8sIF8gfCBfLCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdIGFuZCBbcmVwb2ludF9pbmRpcnNdICopXG4gICAgICAoKiBbY29ubmVjdF0gaXMgb25seSB1c2VkIGluIGJpbmQsIHdob3NlIGl2YXIgaXMgb25seSBldmVyIGV4cG9ydGVkIGFzIGEgcmVhZC1vbmx5XG4gICAgICAgICBkZWZlcnJlZC4gIFRodXMsIFtiaW5kX3Jlc3VsdF0gbXVzdCBiZSBlbXB0eS4gKilcbiAgICAgIHwgRnVsbCBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBfLCBFbXB0eSAtPiAoKVxuICAgICAgfCBFbXB0eSwgXyAtPiBiaW5kX3Jlc3VsdC5jZWxsIDwtIGJpbmRfcmhzX2NvbnRlbnRzXG4gICAgICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4sIGV4ZWN1dGlvbl9jb250ZXh0KSwgRnVsbCB2IC0+XG4gICAgICAgIGJpbmRfcmVzdWx0LmNlbGwgPC0gYmluZF9yaHNfY29udGVudHM7XG4gICAgICAgIFNjaGVkdWxlci4oZW5xdWV1ZSAodCAoKSkpIGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB2XG4gICAgICB8IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIpLCBGdWxsIHYgLT5cbiAgICAgICAgYmluZF9yZXN1bHQuY2VsbCA8LSBiaW5kX3Joc19jb250ZW50cztcbiAgICAgICAgSGFuZGxlci5zY2hlZHVsZV9qb2JzIGhhbmRsZXIgdlxuICAgICAgfCAoIEVtcHR5X29uZV9oYW5kbGVyIChydW4xLCBleGVjdXRpb25fY29udGV4dDEpXG4gICAgICAgICwgRW1wdHlfb25lX2hhbmRsZXIgKHJ1bjIsIGV4ZWN1dGlvbl9jb250ZXh0MikgKSAtPlxuICAgICAgICBsZXQgaGFuZGxlcjEgPSBIYW5kbGVyLmNyZWF0ZTIgcnVuMSBleGVjdXRpb25fY29udGV4dDEgcnVuMiBleGVjdXRpb25fY29udGV4dDIgaW5cbiAgICAgICAgYmluZF9yZXN1bHQuY2VsbCA8LSBjZWxsX29mX2hhbmRsZXIgaGFuZGxlcjFcbiAgICAgIHwgKCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyMSlcbiAgICAgICAgLCBFbXB0eV9vbmVfaGFuZGxlciAocnVuMiwgZXhlY3V0aW9uX2NvbnRleHQyKSApIC0+XG4gICAgICAgIGlnbm9yZSAoSGFuZGxlci5hZGQgaGFuZGxlcjEgcnVuMiBleGVjdXRpb25fY29udGV4dDIgOiBfIEhhbmRsZXIudClcbiAgICAgIHwgKCBFbXB0eV9vbmVfaGFuZGxlciAocnVuMSwgZXhlY3V0aW9uX2NvbnRleHQxKVxuICAgICAgICAsIChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIyKSApIC0+XG4gICAgICAgIGxldCBoYW5kbGVyMSA9IEhhbmRsZXIuYWRkIGhhbmRsZXIyIHJ1bjEgZXhlY3V0aW9uX2NvbnRleHQxIGluXG4gICAgICAgIGJpbmRfcmVzdWx0LmNlbGwgPC0gY2VsbF9vZl9oYW5kbGVyIGhhbmRsZXIxXG4gICAgICB8ICggKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlcjEpXG4gICAgICAgICwgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlcjIpICkgLT4gSGFuZGxlci5zcGxpY2UgaGFuZGxlcjEgaGFuZGxlcjIpXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgSXZhciA9IEl2YXIwXG5tb2R1bGUgSGFuZGxlciA9IEl2YXIuSGFuZGxlclxuXG4oKiBEZWZlcnJlZHMgcHJlc2VudCBhIGNvdmFyaWFudCB2aWV3IG9mIGl2YXJzLiAgV2UgY291bGQgYWN0dWFsbHkgaW1wbGVtZW50IGRlZmVycmVkc1xuICAgdXNpbmcgYSByZWNvcmQgb2YgY2xvc3VyZXMsIGFzIGluIHRoZSBbZXNzZW5jZV9vZl9kZWZlcnJlZF0gcmVjb3JkIGJlbG93LCBmb3Igd2hpY2ggdGhlXG4gICBPQ2FtbCB0eXBlIGNoZWNrZXIgY2FuIGluZmVyIGNvdmFyaWFuY2UuICBIb3dldmVyLCBkb2luZyBzbyB3b3VsZCBtYWtlIFtJdmFyLnJlYWRdIHZlcnlcbiAgIGNvc3RseSwgYmVjYXVzZSBpdCB3b3VsZCBoYXZlIHRvIGFsbG9jYXRlIGxvdHMgb2YgY2xvc3VyZXMgYW5kIGEgcmVjb3JkLiAgSW5zdGVhZCBvZlxuICAgZG9pbmcgdGhpcywgd2UgbWFrZSBkZWZlcnJlZHMgYW4gYWJzdHJhY3QgY292YXJpYW50IHR5cGUsIHdoaWNoIGNvbmNyZXRlbHkgaXMganVzdCB0aGVcbiAgIGl2YXIsIGFuZCB1c2UgW09iai5tYWdpY10gdG8gY29udmVydCBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIGEgZGVmZXJyZWQgYW5kIGl0cyBjb25jcmV0ZVxuICAgcmVwcmVzZW50YXRpb24gYXMgYW4gaXZhci4gIFRoaXMgW09iai5tYWdpY10gaXMgc2FmZSBiZWNhdXNlIHRoZSByZXByZXNlbnRhdGlvbiBpc1xuICAgYWx3YXlzIGp1c3QgYW4gaXZhciwgYW5kIHRoZSBjb3ZhcmlhbmNlIGZvbGxvd3MgZnJvbSB0aGUgZmFjdCB0aGF0IGFsbCB0aGUgZGVmZXJyZWRcbiAgIG9wZXJhdGlvbnMgYXJlIGVxdWl2YWxlbnQgdG8gdGhvc2UgaW1wbGVtZW50ZWQgZGlyZWN0bHkgb24gdG9wIG9mIHRoZVxuICAgW2Vzc2VuY2Vfb2ZfZGVmZXJyZWRdLlxuXG4gICB7W1xuICAgICB0eXBlICgrJ2EsICdleGVjdXRpb25fY29udGV4dCkgZXNzZW5jZV9vZl9kZWZlcnJlZCA9XG4gICAgICAgeyBwZWVrICAgICAgICAgICAgICAgICAgICAgIDogdW5pdCAtPiAnYSBvcHRpb25cbiAgICAgICA7IGlzX2RldGVybWluZWQgICAgICAgICAgICAgOiB1bml0IC0+IGJvb2xcbiAgICAgICA7IHVwb24gICAgICAgICAgICAgICAgICAgICAgOiAoJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICAgICAgIDsgdXBvbicgICAgICAgICAgICAgICAgICAgICA6ICgnYSAtPiB1bml0KSAtPiBVbnJlZ2lzdGVyLnRcbiAgICAgICA7IGluc3RhbGxfcmVtb3ZhYmxlX2hhbmRsZXIgOiAoJ2EsICdleGVjdXRpb25fY29udGV4dCkgUmF3X2hhbmRsZXIudCAtPiBVbnJlZ2lzdGVyLnQ7IH0gXX0gKilcblxudHlwZSArJ2EgdCA9ICdhIFR5cGVzLkRlZmVycmVkLnRcblxuKCogdGhlIGFic3RyYWN0IGNvdmFyaWFudCB0eXBlLCBlcXVpdmFsZW50IHRvIGl2YXIgKilcblxubGV0IG9mX2l2YXIgKHR5cGUgYSkgKGl2YXIgOiBhIEl2YXIudCkgOiBhIHQgPSBPYmoubWFnaWMgaXZhclxubGV0IHRvX2l2YXIgKHR5cGUgYSkgdCA6IGEgSXZhci50ID0gT2JqLm1hZ2ljICh0IDogYSB0KVxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID0gSXZhci5pbnZhcmlhbnQgaW52YXJpYW50X2EgKHRvX2l2YXIgdClcbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBJdmFyLnNleHBfb2ZfdCBzZXhwX29mX2EgKHRvX2l2YXIgdClcbmxldCBwZWVrIHQgPSBJdmFyLnBlZWsgKHRvX2l2YXIgdClcbmxldCByZXR1cm4gYSA9IG9mX2l2YXIgKEl2YXIuY3JlYXRlX2Z1bGwgYSlcbmxldCBpc19kZXRlcm1pbmVkIHQgPSBJdmFyLmlzX2Z1bGwgKHRvX2l2YXIgdClcblxubGV0IHZhbHVlX2V4biB0ID1cbiAgSXZhci52YWx1ZVxuICAgICh0b19pdmFyIHQpXG4gICAgfmlmX2VtcHR5X3RoZW5fZmFpbHdpdGg6XCJEZWZlcnJlZC52YWx1ZV9leG4gY2FsbGVkIG9uIHVuZGV0ZXJtaW5lZCBkZWZlcnJlZFwiXG47O1xuXG5sZXQgdXBvbiB0IGYgPSBJdmFyLnVwb24gKHRvX2l2YXIgdCkgZlxuXG5sZXQgY3JlYXRlIGYgPVxuICBsZXQgcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgZiByZXN1bHQ7XG4gIG9mX2l2YXIgcmVzdWx0XG47O1xuXG4oKiBkb24ndCB1c2UgW2NyZWF0ZV0gaGVyZSBhcyBpdCB3b3VsZCBhbGxvY2F0ZSBvbmUgbW9yZSBjbG9zdXJlICopXG5sZXQgYmluZCB0IH5mID1cbiAgbGV0IGJpbmRfcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgdXBvbiB0IChmdW4gYSAtPiBJdmFyLmNvbm5lY3QgfmJpbmRfcmVzdWx0IH5iaW5kX3JoczoodG9faXZhciAoZiBhKSkpO1xuICBvZl9pdmFyIGJpbmRfcmVzdWx0XG47O1xuXG5sZXQgYWRkX2hhbmRsZXIgdCBmIGV4ZWN1dGlvbl9jb250ZXh0ID0gSXZhci5hZGRfaGFuZGxlciAodG9faXZhciB0KSBmIGV4ZWN1dGlvbl9jb250ZXh0XG5sZXQgcmVtb3ZlX2hhbmRsZXIgdCBoID0gSXZhci5yZW1vdmVfaGFuZGxlciAodG9faXZhciB0KSBoXG4iLCJvcGVuIENvcmVcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMFxuaW5jbHVkZSBJdmFyMFxuXG5sZXQgcmVhZCA9IERlZmVycmVkLm9mX2l2YXJcbmxldCBmaWxsX2lmX2VtcHR5IHQgdiA9IGlmIGlzX2VtcHR5IHQgdGhlbiBmaWxsX2V4biB0IHZcblxuaW5jbHVkZVxuICBCaW5hYmxlLk9mX2JpbmFibGUxX3dpdGhvdXRfdXVpZCBbQGFsZXJ0IFwiLWxlZ2FjeVwiXVxuICAgIChPcHRpb24pXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHRvX2JpbmFibGUgdCA9IHBlZWsgdFxuXG4gICAgICBsZXQgb2ZfYmluYWJsZSA9IGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBjcmVhdGUgKClcbiAgICAgICAgfCBTb21lIGEgLT4gY3JlYXRlX2Z1bGwgYVxuICAgICAgOztcbiAgICBlbmQpXG4iLCIoKiogW01vbmFkX3NlcXVlbmNlLlNdIGlzIGEgZ2VuZXJpYyBpbnRlcmZhY2Ugc3BlY2lmeWluZyBmdW5jdGlvbnMgdGhhdCBkZWFsIHdpdGggYVxuICAgIGNvbnRhaW5lciBhbmQgYSBtb25hZC4gIEl0IGlzIHNwZWNpYWxpemVkIHRvIHRoZSBbRGVmZXJyZWRdIG1vbmFkIGFuZCB1c2VkIHdpdGhcbiAgICB2YXJpb3VzIGNvbnRhaW5lcnMgaW4gbW9kdWxlcyBbRGVmZXJyZWQuQXJyYXldLCBbRGVmZXJyZWQuTGlzdF0sIFtEZWZlcnJlZC5RdWV1ZV0sIGFuZFxuICAgIFtEZWZlcnJlZC5TZXF1ZW5jZV0uICBUaGUgW01vbmFkX3NlcXVlbmNlLmhvd10gdHlwZSBzcGVjaWZpZXMgdGhlIHBhcmFsbGVsaXNtIG9mXG4gICAgY29udGFpbmVyIGl0ZXJhdG9ycy4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgaG93ID1cbiAgWyBgUGFyYWxsZWwgKCoqIGxpa2UgW2BNYXhfY29uY3VycmVudF9qb2JzIEludC5tYXhfdmFsdWVdICopXG4gIHwgYFNlcXVlbnRpYWxcbiAgICAoKiogW2BTZXF1ZW50aWFsXSBpcyBvZnRlbiBidXQgbm90IGFsd2F5cyB0aGUgc2FtZSBhcyBbYE1heF9jb25jdXJyZW50X2pvYnMgMV1cbiAgICAgIChmb3IgZXhhbXBsZSwgdGhleSBkaWZmZXIgaW4gdGhlIFtPcl9lcnJvcl0gbW9uYWQpLiAqKVxuICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG9mIGludFxuICBdXG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgJ2EgbW9uYWRcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGZvbGRpIDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KGludCAtPiAnYiAtPiAnYSAtPiAnYiBtb25hZCkgLT4gJ2IgbW9uYWRcbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2IgLT4gZjooJ2IgLT4gJ2EgLT4gJ2IgbW9uYWQpIC0+ICdiIG1vbmFkXG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBmOignYSAtPiBib29sIG1vbmFkKSAtPiAnYSBvcHRpb24gbW9uYWRcbiAgdmFsIGZpbmRpIDogJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gYm9vbCBtb25hZCkgLT4gKGludCAqICdhKSBvcHRpb24gbW9uYWRcbiAgdmFsIGZpbmRfbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYiBvcHRpb24gbW9uYWQpIC0+ICdiIG9wdGlvbiBtb25hZFxuICB2YWwgZmluZF9tYXBpIDogJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gJ2Igb3B0aW9uIG1vbmFkKSAtPiAnYiBvcHRpb24gbW9uYWRcbiAgdmFsIGV4aXN0cyA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCBtb25hZCkgLT4gYm9vbCBtb25hZFxuICB2YWwgZXhpc3RzaSA6ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+IGJvb2wgbW9uYWQpIC0+IGJvb2wgbW9uYWRcbiAgdmFsIGZvcl9hbGwgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wgbW9uYWQpIC0+IGJvb2wgbW9uYWRcbiAgdmFsIGZvcl9hbGxpIDogJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gYm9vbCBtb25hZCkgLT4gYm9vbCBtb25hZFxuICB2YWwgYWxsIDogJ2EgbW9uYWQgdCAtPiAnYSB0IG1vbmFkXG4gIHZhbCBhbGxfdW5pdCA6IHVuaXQgbW9uYWQgdCAtPiB1bml0IG1vbmFkXG5cbiAgKCoqIHsyIERlZmVycmVkIGl0ZXJhdG9yc30gKilcblxuICB2YWwgaW5pdCA6IGhvdzpob3cgLT4gaW50IC0+IGY6KGludCAtPiAnYSBtb25hZCkgLT4gJ2EgdCBtb25hZFxuICB2YWwgaXRlciA6IGhvdzpob3cgLT4gJ2EgdCAtPiBmOignYSAtPiB1bml0IG1vbmFkKSAtPiB1bml0IG1vbmFkXG4gIHZhbCBpdGVyaSA6IGhvdzpob3cgLT4gJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gdW5pdCBtb25hZCkgLT4gdW5pdCBtb25hZFxuICB2YWwgbWFwIDogaG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+ICdiIG1vbmFkKSAtPiAnYiB0IG1vbmFkXG4gIHZhbCBtYXBpIDogaG93OmhvdyAtPiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiAnYiBtb25hZCkgLT4gJ2IgdCBtb25hZFxuICB2YWwgZmlsdGVyIDogaG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wgbW9uYWQpIC0+ICdhIHQgbW9uYWRcbiAgdmFsIGZpbHRlcmkgOiBob3c6aG93IC0+ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+IGJvb2wgbW9uYWQpIC0+ICdhIHQgbW9uYWRcbiAgdmFsIGZpbHRlcl9tYXAgOiBob3c6aG93IC0+ICdhIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uIG1vbmFkKSAtPiAnYiB0IG1vbmFkXG4gIHZhbCBmaWx0ZXJfbWFwaSA6IGhvdzpob3cgLT4gJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gJ2Igb3B0aW9uIG1vbmFkKSAtPiAnYiB0IG1vbmFkXG4gIHZhbCBjb25jYXRfbWFwIDogaG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+ICdiIHQgbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIGNvbmNhdF9tYXBpIDogaG93OmhvdyAtPiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiAnYiB0IG1vbmFkKSAtPiAnYiB0IG1vbmFkXG5lbmRcbiIsIm9wZW4gQ29yZVxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjFcbmluY2x1ZGUgRGVmZXJyZWQwXG5cbigqIFRvIGF2b2lkIGEgc3BhY2UgbGVhaywgaXQgaXMgbmVjZXNzYXJ5IHRoYXQgW25ldmVyXSBhbGxvY2F0ZXMgYSBuZXcgaXZhciB3aGVuZXZlciBpdCBpc1xuICAgY2FsbGVkLiAgQ29kZSBjYW4gYmluZCBvbiBbbmV2ZXIgKCldLCBzbyBpZiB3ZSByZS11c2VkIHRoZSBpdmFyLCB3ZSBjb3VsZCBlbmRsZXNzbHlcbiAgIGFjY3VtdWxhdGUgaGFuZGxlcnMuICopXG5sZXQgbmV2ZXIgKCkgPSBJdmFyLnJlYWQgKEl2YXIuY3JlYXRlICgpKVxuXG5tb2R1bGUgTSA9IE1vbmFkLk1ha2UgKHN0cnVjdFxuICBpbmNsdWRlIERlZmVycmVkMFxuXG4gIGxldCBtYXAgdCB+ZiA9XG4gICAgKCogV2UgbWFudWFsbHkgaW5saW5lIFtEZWZlcnJlZC5jcmVhdGVdIGhlcmUsIGJlY2F1c2UgdGhlIG5vbi1mbGFtYmRhIGNvbXBpbGVyIGlzbid0XG4gICAgICAgICBhYmxlIHRvIG9wdGltaXplIGF3YXkgdGhlIGNsb3N1cmUgdGhhdCB3b3VsZCBiZSBiZSBjcmVhdGVkLiAqKVxuICAgIGxldCByZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgIHVwb24gdCAoZnVuIGEgLT4gSXZhci5maWxsX2V4biByZXN1bHQgKGYgYSkpO1xuICAgIG9mX2l2YXIgcmVzdWx0XG4gIDs7XG5cbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG5lbmQpXG5cbmluY2x1ZGUgTVxuXG4oKiBXZSByZWJpbmQgYWxsIHRoZSB2YXJpb3VzIFtyZXR1cm5dcyBiZWNhdXNlIHRoZSB1c2Ugb2YgdGhlIFtNb25hZC5NYWtlXSBmdW5jdG9yXG4gICBjYXVzZXMgdGhlIGNvbXBpbGVyIHRvIG5vdCBpbmxpbmUgW3JldHVybl0sIGFuZCBoZW5jZSBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvXG4gICBzdGF0aWNhbGx5IGFsbG9jYXRlIGNvbnN0YW50cyBsaWtlIFtyZXR1cm4gKCldLiAgQnkgcmViaW5kaW5nIFtyZXR1cm5dIGFzXG4gICBbRGVmZXJyZWQwLnJldHVybl0sIHRoZSBjb21waWxlciBjYW4gc2VlIHRoYXQ6XG5cbiAgIHtbXG4gICAgIHJldHVybiBhID0geyBJdmFyLkltbXV0YWJsZS4gY2VsbCA9IEZ1bGwgYSB9IF19XG5cbiAgIEFuZCBoZW5jZSwgaWYgW2FdIGlzIGNvbnN0YW50LCB0aGVuIHRoZSByZXR1cm4gaXMgY29uc3RhbnQgYW5kIGNhbiBiZSBzdGF0aWNhbGx5XG4gICBhbGxvY2F0ZWQuICBXaGVuIGNvbXBpbGluZyB3aXRoIGZsYW1iZGEsIHRoZSBjb21waWxlciBpbmxpbmVzIFtyZXR1cm5dIGFuZCB0aGlzIG1hbnVhbFxuICAgcmViaW5kaW5nIHdvdWxkIG5vdCBoZWxwOyB3ZSd2ZSBkZWNpZGVkIHRvIGRvIGl0IGFueXdheSBzbyB0aGF0IG5vbi1mbGFtYmRhIGJ1aWxkc1xuICAgZ2V0IHRoZSBvcHRpbWl6YXRpb24uICopXG5sZXQgcmV0dXJuID0gRGVmZXJyZWQwLnJldHVyblxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBpbmNsdWRlIE0uTGV0X3N5bnRheFxuXG4gIGxldCByZXR1cm4gPSBEZWZlcnJlZDAucmV0dXJuXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIE0uTGV0X3N5bnRheC5MZXRfc3ludGF4XG5cbiAgICBsZXQgcmV0dXJuID0gRGVmZXJyZWQwLnJldHVyblxuICBlbmRcbmVuZFxuXG5vcGVuIExldF9zeW50YXhcblxuKCogV2Ugc2hhZG93IFthbGxdIG9uLXB1cnBvc2UgaGVyZSwgc2luY2UgdGhlIGRlZmF1bHQgZGVmaW5pdGlvbiBpbnRyb2R1Y2VzIGEgY2hhaW4gb2ZcbiAgIGJpbmRzIGFzIGxvbmcgYXMgdGhlIGxpc3QuICopXG5sZXQgYWxsID0gYE1ha2Vfc3VyZV90b19kZWZpbmVfYWxsX2Vsc2V3aGVyZVxubGV0IF8gPSBhbGxcbmxldCB1bml0ID0gcmV0dXJuICgpXG5cbmxldCBib3RoIHQxIHQyID1cbiAgY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgdXBvbiB0MSAoZnVuIGExIC0+IHVwb24gdDIgKGZ1biBhMiAtPiBJdmFyLmZpbGxfZXhuIHJlc3VsdCAoYTEsIGEyKSkpKVxuOztcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBsZXQgKCA+Pj4gKSA9IHVwb25cbiAgbGV0IHBweF9ib3RoID0gYm90aFxuZW5kXG5cbm9wZW4gSW5maXhcblxubGV0IGRvbid0X3dhaXRfZm9yIChfIDogdW5pdCB0KSA9ICgpXG5cbm1vZHVsZSBDaG9pY2UgPSBzdHJ1Y3RcbiAgdHlwZSArJ2EgdCA9IFQgOiAnYiBEZWZlcnJlZDAudCAqICgnYiAtPiAnYSkgLT4gJ2EgdFxuXG4gIGxldCBtYXAgKFQgKHQsIGYxKSkgfmY6ZjIgPSBUICh0LCBmdW4geCAtPiBmMiAoZjEgeCkpXG5lbmRcblxubW9kdWxlIFVucmVnaXN0ZXIgPSBzdHJ1Y3RcbiAgKCogVGhpcyByZXByZXNlbnRhdGlvbiBzYXZlcyAybiB3b3JkcyBmb3IgYSBsaXN0IG9mIG4gY2hvaWNlcy4gKilcbiAgdHlwZSAnciB0ID1cbiAgICB8IE5pbCA6ICdyIHRcbiAgICB8IENvbnMgOiAnYSBEZWZlcnJlZDAudCAqICgnYSAtPiAncikgKiAnYSBEZWZlcnJlZDAuSGFuZGxlci50ICogJ3IgdCAtPiAnciB0XG5cbiAgbGV0IHJlYyBwcm9jZXNzID0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyAodCwgX2YsIGhhbmRsZXIsIHJlc3QpIC0+XG4gICAgICByZW1vdmVfaGFuZGxlciB0IGhhbmRsZXI7XG4gICAgICBwcm9jZXNzIHJlc3RcbiAgOztcbmVuZFxuXG5sZXQgY2hvaWNlIHQgZiA9IENob2ljZS5UICh0LCBmKVxuXG5sZXQgZW5hYmxlZCBjaG9pY2VzID1cbiAgbGV0IHJlc3VsdCA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGxldCB1bnJlZ2lzdGVycyA9IHJlZiBVbnJlZ2lzdGVyLk5pbCBpblxuICBsZXQgcmVhZHkgXyA9XG4gICAgaWYgSXZhci5pc19lbXB0eSByZXN1bHRcbiAgICB0aGVuIChcbiAgICAgIFVucmVnaXN0ZXIucHJvY2VzcyAhdW5yZWdpc3RlcnM7XG4gICAgICBJdmFyLmZpbGxfZXhuIHJlc3VsdCAoZnVuICgpIC0+XG4gICAgICAgIExpc3QucmV2XG4gICAgICAgICAgKExpc3QuZm9sZCBjaG9pY2VzIH5pbml0OltdIH5mOihmdW4gYWMgKENob2ljZS5UICh0LCBmKSkgLT5cbiAgICAgICAgICAgICBtYXRjaCBwZWVrIHQgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBhY1xuICAgICAgICAgICAgIHwgU29tZSB2IC0+IGYgdiA6OiBhYykpKSlcbiAgaW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLihjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSkgaW5cbiAgdW5yZWdpc3RlcnNcbiAgICA6PSBMaXN0LmZvbGQgY2hvaWNlcyB+aW5pdDpVbnJlZ2lzdGVyLk5pbCB+ZjooZnVuIGFjYyAoQ2hvaWNlLlQgKHQsIGYpKSAtPlxuICAgICAgICAgQ29ucyAodCwgZiwgRGVmZXJyZWQwLmFkZF9oYW5kbGVyIHQgcmVhZHkgZXhlY3V0aW9uX2NvbnRleHQsIGFjYykpO1xuICBJdmFyLnJlYWQgcmVzdWx0XG47O1xuXG5sZXQgcmVjIGNob29zZV9yZXN1bHQgY2hvaWNlcyA9XG4gIG1hdGNoIGNob2ljZXMgd2l0aFxuICB8IFVucmVnaXN0ZXIuTmlsIC0+IGFzc2VydCBmYWxzZVxuICB8IFVucmVnaXN0ZXIuQ29ucyAodCwgZiwgXywgcmVzdCkgLT5cbiAgICAobWF0Y2ggcGVlayB0IHdpdGhcbiAgICAgfCBOb25lIC0+IGNob29zZV9yZXN1bHQgcmVzdFxuICAgICB8IFNvbWUgdiAtPiBmIHYpXG47O1xuXG5sZXQgZ2VuZXJpY19jaG9vc2UgY2hvaWNlcyA9XG4gIGxldCByZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBTY2hlZHVsZXIuKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKSBpblxuICAoKiBBIGJhY2stcGF0Y2hlZCByZWYgY291bGQgYmUgdXNlZCBoZXJlLCBidXQgdXNpbmcgbGF6eSBzYXZlcyBzb21lIG1lbW9yeVxuICAgICBiZWNhdXNlIHRoZSBHQyBldmVudHVhbGx5IHJlbW92ZXMgdGhlIGV4dHJhIGluZGlyZWN0aW9uLiAqKVxuICBsZXQgcmVjIHVucmVnaXN0ZXJzID1cbiAgICBsYXp5XG4gICAgICAoTGlzdC5mb2xkX3JpZ2h0IGNob2ljZXMgfmluaXQ6VW5yZWdpc3Rlci5OaWwgfmY6KGZ1biAoQ2hvaWNlLlQgKHQsIGYpKSBhY2MgLT5cbiAgICAgICAgIFVucmVnaXN0ZXIuQ29ucyAodCwgZiwgRGVmZXJyZWQwLmFkZF9oYW5kbGVyIHQgcmVhZHkgZXhlY3V0aW9uX2NvbnRleHQsIGFjYykpKVxuICBhbmQgcmVhZHkgOiAnYS4gJ2EgLT4gdW5pdCA9XG4gICAgZnVuIF8gLT5cbiAgICBpZiBJdmFyLmlzX2VtcHR5IHJlc3VsdFxuICAgIHRoZW4gKFxuICAgICAgbGV0IHVucmVnaXN0ZXJzID0gTGF6eS5mb3JjZSB1bnJlZ2lzdGVycyBpblxuICAgICAgVW5yZWdpc3Rlci5wcm9jZXNzIHVucmVnaXN0ZXJzO1xuICAgICAgSXZhci5maWxsX2V4biByZXN1bHQgKGNob29zZV9yZXN1bHQgdW5yZWdpc3RlcnMpKVxuICBpblxuICBsZXQgKF8gOiBfKSA9IExhenkuZm9yY2UgdW5yZWdpc3RlcnMgaW5cbiAgSXZhci5yZWFkIHJlc3VsdFxuOztcblxuKCogW2Nob29zZTJdIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgW2Nob29zZV0gdGhhdCBoYXMgYmV0dGVyIG1lbW9yeSB1c2FnZS5cbiAgIEF0IHRoZSB0aW1lIG9mIHdyaXRpbmcsIFtjaG9vc2UyXSBrZWVwcyAyMiBleHRyYSB3b3JkcyBhbGl2ZVxuICAgZm9yIHRoZSBkdXJhdGlvbiBvZiBjaG9pY2Ugc3RheWluZyB1bmRldGVybWluZWQsIHdoaWxlIHRoZSBlcXVpdmFsZW50IGdlbmVyaWNcbiAgIFtjaG9vc2VdIGtlZXBzIDI3IChzZWUgdGhlIGJlbmNobWFyayBpbiAuLi9iZW5jaC9iaW4vYmVuY2hfY2hvb3NlX21lbW9yeV91c2FnZS5tbCkuICopXG5sZXQgY2hvb3NlMiBhIGZhIGIgZmIgPVxuICBsZXQgcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLihjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSkgaW5cbiAgbGV0IHJlYyBhX2hhbmRsZXIgPSBsYXp5IChEZWZlcnJlZDAuYWRkX2hhbmRsZXIgYSByZWFkeSBleGVjdXRpb25fY29udGV4dClcbiAgYW5kIGJfaGFuZGxlciA9IGxhenkgKERlZmVycmVkMC5hZGRfaGFuZGxlciBiIHJlYWR5IGV4ZWN1dGlvbl9jb250ZXh0KVxuICBhbmQgcmVhZHkgOiAnYS4gJ2EgLT4gdW5pdCA9XG4gICAgZnVuIF8gLT5cbiAgICBpZiBJdmFyLmlzX2VtcHR5IHJlc3VsdFxuICAgIHRoZW4gKFxuICAgICAgKCogVGhlIG9yZGVyIG9mIHRoZXNlIG9wZXJhdGlvbnMgbWF0dGVyczpcbiAgICAgICAgIGlmIHdlIGNhbGwgW2ZiXSBvciBbZmFdIGZpcnN0IGFuZCBbcmVtb3ZlX2hhbmRsZXJdIGFmdGVyLCB0aGVuXG4gICAgICAgICBhbnkgZXhjZXB0aW9ucyByYWlzZWQgd2lsbCBjYXVzZSB0aGUgaGFuZGxlcnMgdG8gcmVtYWluIGFuZCB0aGVuXG4gICAgICAgICB0aGUgXCJzZWNvbmQgY2hvaWNlXCIgZ2V0cyBhIGNoYW5jZSB0byBydW4uXG4gICAgICAqKVxuICAgICAgcmVtb3ZlX2hhbmRsZXIgYSAoTGF6eS5mb3JjZSBhX2hhbmRsZXIpO1xuICAgICAgcmVtb3ZlX2hhbmRsZXIgYiAoTGF6eS5mb3JjZSBiX2hhbmRsZXIpO1xuICAgICAgbWF0Y2ggcGVlayBhIHdpdGhcbiAgICAgIHwgU29tZSBhdiAtPiBJdmFyLmZpbGxfZXhuIHJlc3VsdCAoZmEgYXYpXG4gICAgICB8IE5vbmUgLT4gSXZhci5maWxsX2V4biByZXN1bHQgKGZiICh2YWx1ZV9leG4gYikpKVxuICBpblxuICBsZXQgKF8gOiBfKSA9IExhenkuZm9yY2UgYV9oYW5kbGVyIGluXG4gIGxldCAoXyA6IF8pID0gTGF6eS5mb3JjZSBiX2hhbmRsZXIgaW5cbiAgSXZhci5yZWFkIHJlc3VsdFxuOztcblxubGV0IGNob29zZSBjaG9pY2VzID1cbiAgbWF0Y2ggY2hvaWNlcyB3aXRoXG4gIHwgWyBDaG9pY2UuVCAoYSwgZmEpOyBDaG9pY2UuVCAoYiwgZmIpIF0gLT4gY2hvb3NlMiBhIGZhIGIgZmJcbiAgfCBjaG9pY2VzIC0+IGdlbmVyaWNfY2hvb3NlIGNob2ljZXNcbjs7XG5cbmxldCBhbnlfZiB0cyBmID0gY2hvb3NlIChMaXN0Lm1hcCB0cyB+ZjooZnVuIHQgLT4gY2hvaWNlIHQgZikpXG5sZXQgYW55IHRzID0gYW55X2YgdHMgRm4uaWRcbmxldCBhbnlfdW5pdCB0cyA9IGFueV9mIHRzIChGbi5pZ25vcmUgOiB1bml0IC0+IHVuaXQpXG5cbmxldCBmb3JfIHN0YXJ0IH50b18gfmRvXyA9XG4gIGlmIHN0YXJ0ID4gdG9fXG4gIHRoZW4gcmV0dXJuICgpXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGxldCViaW5kICgpID0gZG9fIGkgaW5cbiAgICAgIGlmIGkgPj0gdG9fIHRoZW4gcmV0dXJuICgpIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIHN0YXJ0KVxuOztcblxubGV0IHJlcGVhdF91bnRpbF9maW5pc2hlZCBzdGF0ZSBmID1cbiAgY3JlYXRlIChmdW4gZmluaXNoZWQgLT5cbiAgICBsZXQgcmVjIGxvb3Agc3RhdGUgPVxuICAgICAgZiBzdGF0ZVxuICAgICAgPj4+IGZ1bmN0aW9uXG4gICAgICB8IGBSZXBlYXQgc3RhdGUgLT4gbG9vcCBzdGF0ZVxuICAgICAgfCBgRmluaXNoZWQgcmVzdWx0IC0+IEl2YXIuZmlsbF9leG4gZmluaXNoZWQgcmVzdWx0XG4gICAgaW5cbiAgICBsb29wIHN0YXRlKVxuOztcblxubGV0IGZvcmV2ZXIgc3RhdGUgZiA9XG4gIHJlcGVhdF91bnRpbF9maW5pc2hlZCBzdGF0ZSAoZnVuIHN0YXRlIC0+XG4gICAgbGV0JW1hcCBzdGF0ZSA9IGYgc3RhdGUgaW5cbiAgICBgUmVwZWF0IHN0YXRlKVxuICA+Pj4gbmV2ZXJfcmV0dXJuc1xuOztcblxudHlwZSBob3cgPSBNb25hZF9zZXF1ZW5jZS5ob3cgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubW9kdWxlIHR5cGUgTW9uYWRfc2VxdWVuY2UgPSBNb25hZF9zZXF1ZW5jZS5TIHdpdGggdHlwZSAnYSBtb25hZCA6PSAnYSB0XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBjcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCBiID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiBJdmFyLmZpbGxfZXhuIHJlc3VsdCBiXG4gICAgICB8IHggOjogeHMgLT4gZiBiIHggPj4+IGZ1biBiIC0+IGxvb3AgeHMgYlxuICAgIGluXG4gICAgbG9vcCB0IGluaXQpXG47O1xuXG5sZXQgc2VxbWFwIHQgfmYgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biBicyBhIC0+IGYgYSA+PnwgZnVuIGIgLT4gYiA6OiBicykgPj58IExpc3QucmV2XG5sZXQgYWxsIGRzID0gc2VxbWFwIGRzIH5mOkZuLmlkXG5sZXQgYWxsX3VuaXQgZHMgPSBmb2xkIGRzIH5pbml0OigpIH5mOihmdW4gKCkgZCAtPiBkKVxubGV0IG9rIHggPSB4ID4+fCBmdW4geCAtPiBPayB4XG5cbm1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgbGV0IGdlbmVyaWNfY2hvb3NlID0gZ2VuZXJpY19jaG9vc2VcbmVuZFxuIiwib3BlbiBEZWZlcnJlZDFcbmluY2x1ZGUgSW5maXhcbmluY2x1ZGUgTGV0X3N5bnRheFxuXG5sZXQgY2hvaWNlID0gY2hvaWNlXG5sZXQgY2hvb3NlID0gY2hvb3NlXG5sZXQgZG9uJ3Rfd2FpdF9mb3IgPSBkb24ndF93YWl0X2ZvclxubGV0IG5ldmVyID0gbmV2ZXJcbmxldCByZXR1cm4gPSByZXR1cm5cbmxldCB1cG9uID0gdXBvblxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdSA9XG4gIHwgRW1wdHkgb2YgJ2EgSXZhci50XG4gIHwgRnVsbFxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxudHlwZSAnYSB0ID0gJ2EgdSByZWYgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBfIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIG1hdGNoICF0IHdpdGhcbiAgICB8IEZ1bGwgLT4gKClcbiAgICB8IEVtcHR5IGl2YXIgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKVxuOztcblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCBpdmFyID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IHQgPSByZWYgKEVtcHR5IGl2YXIpIGluXG4gIHQsIEl2YXIucmVhZCBpdmFyXG47O1xuXG5sZXQgaXNfZW1wdHkgdCA9XG4gIG1hdGNoICF0IHdpdGhcbiAgfCBFbXB0eSBfIC0+IHRydWVcbiAgfCBGdWxsIC0+IGZhbHNlXG47O1xuXG5sZXQgZmlsbCB0IGEgPVxuICBtYXRjaCAhdCB3aXRoXG4gIHwgRW1wdHkgaSAtPlxuICAgIHQgOj0gRnVsbDtcbiAgICBJdmFyLmZpbGxfZXhuIGkgYVxuICB8IEZ1bGwgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJhdHRlbXB0IHRvIGZpbGwgZnVsbCBpdmFyXCJdXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubW9kdWxlIFN0cmVhbSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBuZXh0IERlZmVycmVkLnRcblxuICBhbmQgJ2EgbmV4dCA9ICdhIFR5cGVzLlN0cmVhbS5uZXh0ID1cbiAgICB8IE5pbFxuICAgIHwgQ29ucyBvZiAnYSAqICdhIHRcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICBsZXQgcmVjIGxvb3AgZCBhYyA6IFNleHAudCA9XG4gICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIGQgd2l0aFxuICAgICAgfCBOb25lIC0+IExpc3QgKExpc3QucmV2IChTZXhwLkF0b20gXCIuLi5cIiA6OiBhYykpXG4gICAgICB8IFNvbWUgTmlsIC0+IExpc3QgKExpc3QucmV2IGFjKVxuICAgICAgfCBTb21lIChDb25zIChhLCB0KSkgLT4gbG9vcCB0IChzZXhwX29mX2EgYSA6OiBhYylcbiAgICBpblxuICAgIGxvb3AgdCBbXVxuICA7O1xuXG4gIGxldCBuZXh0IHQgPSB0XG5lbmRcblxudHlwZSAnYSB0ID0gJ2EgVHlwZXMuVGFpbC50ID1cbiAgeyAoKiBbbmV4dF0gcG9pbnRzIGF0IHRoZSB0YWlsIG9mIHRoZSBzdHJlYW0gKikgbXV0YWJsZSBuZXh0IDogJ2EgU3RyZWFtLm5leHQgSXZhci50IH1cbltAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVyc11cblxubGV0IHNleHBfb2ZfdCBfIHQgOiBTZXhwLnQgPVxuICBBdG9tIChpZiBJdmFyLmlzX2VtcHR5IHQubmV4dCB0aGVuIFwiPG9wZW4gdGFpbD5cIiBlbHNlIFwiPGNsb3NlZCB0YWlsPlwiKVxuOztcblxubGV0IGNyZWF0ZSAoKSA9IHsgbmV4dCA9IEl2YXIuY3JlYXRlICgpIH1cbmxldCBjb2xsZWN0IHQgPSBJdmFyLnJlYWQgKG5leHQgdClcbmxldCBpc19jbG9zZWQgdCA9IEl2YXIuaXNfZnVsbCAobmV4dCB0KVxuXG5sZXQgZmlsbF9leG4gdCB2ID1cbiAgaWYgaXNfY2xvc2VkIHQgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcInN0cmVhbSBpcyBjbG9zZWRcIl0gZWxzZSBJdmFyLmZpbGxfZXhuIChuZXh0IHQpIHZcbjs7XG5cbmxldCBjbG9zZV9leG4gdCA9IGZpbGxfZXhuIHQgTmlsXG5sZXQgY2xvc2VfaWZfb3BlbiB0ID0gaWYgbm90IChpc19jbG9zZWQgdCkgdGhlbiBJdmFyLmZpbGxfZXhuIChuZXh0IHQpIE5pbFxuXG5sZXQgZXh0ZW5kIHQgdiA9XG4gIGxldCBuZXh0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgZmlsbF9leG4gdCAoQ29ucyAodiwgSXZhci5yZWFkIG5leHQpKTtcbiAgdC5uZXh0IDwtIG5leHRcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxubW9kdWxlIFN0cmVhbSA9IFRhaWwuU3RyZWFtXG5tb2R1bGUgTW9uaXRvciA9IE1vbml0b3IwXG5pbmNsdWRlIE1vbml0b3JcblxudHlwZSBtb25pdG9yID0gdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm5hbWU6aWdub3JlXG4gICAgICB+aGVyZTppZ25vcmVcbiAgICAgIH5pZDppZ25vcmVcbiAgICAgIH5mb3J3YXJkaW5nOmlnbm9yZVxuICAgICAgfm5leHRfZXJyb3I6KGNoZWNrIChmdW4gbmV4dF9lcnJvciAtPiBhc3NlcnQgKEl2YXIuaXNfZW1wdHkgbmV4dF9lcnJvcikpKVxuICAgICAgfmhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzOmlnbm9yZVxuICAgICAgfnRhaWxzX2Zvcl9hbGxfZXJyb3JzOmlnbm9yZVxuICAgICAgfmhhc19zZWVuX2Vycm9yOmlnbm9yZSlcbjs7XG5cbmxldCBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICgpID0gU2NoZWR1bGVyLihjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSlcbmxldCBjdXJyZW50ICgpID0gRXhlY3V0aW9uX2NvbnRleHQubW9uaXRvciAoY3VycmVudF9leGVjdXRpb25fY29udGV4dCAoKSlcbmxldCBkZXRhY2ggdCA9IHQuZm9yd2FyZGluZyA8LSBEZXRhY2hlZFxuXG50eXBlIGhhbmRsZXJfc3RhdGUgPVxuICB8IFVuaW5pdGlhbGl6ZWRcbiAgfCBSdW5uaW5nIG9mIChFeGVjdXRpb25fY29udGV4dC50ICogKGV4biAtPiB1bml0KSkgQmFnLkVsdC50XG4gIHwgVGVybWluYXRlZFxuXG5sZXQgZGV0YWNoX2FuZF9pdGVyX2Vycm9ycyB0IH5mID1cbiAgZGV0YWNoIHQ7XG4gIGxldCBzY2hlZHVsZXIgPSBTY2hlZHVsZXIudCAoKSBpblxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBTY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dCBzY2hlZHVsZXIgaW5cbiAgbGV0IGhhbmRsZXJfc3RhdGVfcmVmID0gcmVmIFVuaW5pdGlhbGl6ZWQgaW5cbiAgbGV0IHJ1bl9mIGV4biA9XG4gICAgbWF0Y2ggIWhhbmRsZXJfc3RhdGVfcmVmIHdpdGhcbiAgICB8IFVuaW5pdGlhbGl6ZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBUZXJtaW5hdGVkIC0+ICgpXG4gICAgfCBSdW5uaW5nIGJhZ19lbHQgLT5cbiAgICAgICh0cnkgZiBleG4gd2l0aFxuICAgICAgIHwgaW5uZXJfZXhuIC0+XG4gICAgICAgICBoYW5kbGVyX3N0YXRlX3JlZiA6PSBUZXJtaW5hdGVkO1xuICAgICAgICAgQmFnLnJlbW92ZSB0LmhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIGJhZ19lbHQ7XG4gICAgICAgICAoKiBbcnVuX2ZdIGFsd2F5cyBydW5zIGluIFtleGVjdXRpb25fY29udGV4dF0uICBIZW5jZSwgW3JhaXNlIGlubmVyX2V4bl0gc2VuZHNcbiAgICAgICAgICAgIFtpbm5lcl9leG5dIHRvIFtleGVjdXRpb25fY29udGV4dF0ncyBtb25pdG9yLCBpLmUuIHRoZSBtb25pdG9yIGluIGVmZmVjdCB3aGVuXG4gICAgICAgICAgICBbZGV0YWNoX2FuZF9pdGVyX2Vycm9yc10gd2FzIGNhbGxlZC4gKilcbiAgICAgICAgIHJhaXNlIGlubmVyX2V4bilcbiAgaW5cbiAgaGFuZGxlcl9zdGF0ZV9yZWZcbiAgICA6PSBSdW5uaW5nIChCYWcuYWRkIHQuaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMgKGV4ZWN1dGlvbl9jb250ZXh0LCBydW5fZikpXG47O1xuXG5sZXQgZGV0YWNoX2FuZF9nZXRfZXJyb3Jfc3RyZWFtIHQgPVxuICBkZXRhY2ggdDtcbiAgbGV0IHRhaWwgPSBUYWlsLmNyZWF0ZSAoKSBpblxuICB0LnRhaWxzX2Zvcl9hbGxfZXJyb3JzIDwtIHRhaWwgOjogdC50YWlsc19mb3JfYWxsX2Vycm9ycztcbiAgVGFpbC5jb2xsZWN0IHRhaWxcbjs7XG5cbmxldCBnZXRfbmV4dF9lcnJvciB0ID0gSXZhci5yZWFkIHQubmV4dF9lcnJvclxuXG5sZXQgZGV0YWNoX2FuZF9nZXRfbmV4dF9lcnJvciB0ID1cbiAgZGV0YWNoIHQ7XG4gIGdldF9uZXh0X2Vycm9yIHRcbjs7XG5cbmxldCBjcmVhdGUgP2hlcmUgP2luZm8gP25hbWUgKCkgPVxuICBsZXQgcGFyZW50ID0gY3VycmVudCAoKSBpblxuICBjcmVhdGVfd2l0aF9wYXJlbnQgP2hlcmUgP2luZm8gP25hbWUgKFNvbWUgcGFyZW50KVxuOztcblxubW9kdWxlIE1vbml0b3JfZXhuID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBleG4gOiBleG5cbiAgICA7IGJhY2t0cmFjZSA6IEJhY2t0cmFjZS50IG9wdGlvblxuICAgIDsgYmFja3RyYWNlX2hpc3RvcnkgOiBCYWNrdHJhY2UudCBsaXN0XG4gICAgOyBtb25pdG9yIDogTW9uaXRvci50XG4gICAgfVxuXG4gIGxldCBiYWNrdHJhY2UgdCA9IHQuYmFja3RyYWNlXG4gIGxldCBleHRyYWN0X2V4biB0ID0gdC5leG5cblxuICBsZXQgYmFja3RyYWNlX3RydW5jYXRpb25faGV1cmlzdGljcyA9XG4gICAgbGV0IGpvYl9xdWV1ZSA9IFwiQ2FsbGVkIGZyb20gQXN5bmNfa2VybmVsX19Kb2JfcXVldWVcIiBpblxuICAgIGxldCBkZWZlcnJlZDAgPSBcIkNhbGxlZCBmcm9tIEFzeW5jX2tlcm5lbF9fRGVmZXJyZWQwXCIgaW5cbiAgICBsZXQgZGVmZXJyZWQxID0gXCJDYWxsZWQgZnJvbSBBc3luY19rZXJuZWxfX0RlZmVycmVkMVwiIGluXG4gICAgbGV0IG1vbml0b3IgPSBcIkNhbGxlZCBmcm9tIEFzeW5jX2tlcm5lbF9fTW9uaXRvclwiIGluXG4gICAgbGV0IHRyeV93aXRoID0gXCJDYWxsZWQgZnJvbSBCYXNlX19SZXN1bHQudHJ5X3dpdGhcIiBpblxuICAgIGxldCBlcnJvciA9IFwiUmFpc2VkIGF0IEJhc2VfX0Vycm9yLnJhaXNlXCIgaW5cbiAgICBmdW4gdHJhY2VzIC0+XG4gICAgICAoKiAuLi90ZXN0L3Rlc3RfdHJ5X3dpdGhfZXJyb3JfZGlzcGxheS5tbCBtYWtlcyBzdXJlIHRoaXMgc3RheXMgdXAtdG8tZGF0ZS4gKilcbiAgICAgIGxldCBzdHJpcF9wcmVmaXhlcyBsaW5lcyB+cHJlZml4ZXMgPVxuICAgICAgICBMaXN0LmRyb3Bfd2hpbGUgbGluZXMgfmY6KGZ1biBsaW5lIC0+XG4gICAgICAgICAgTGlzdC5leGlzdHMgcHJlZml4ZXMgfmY6KGZ1biBwcmVmaXggLT4gU3RyaW5nLmlzX3ByZWZpeCBsaW5lIH5wcmVmaXgpKVxuICAgICAgaW5cbiAgICAgIGxldCBzdHJpcF9zdWZmaXhlcyBpbnB1dCB+c3VmZml4ZXMgPVxuICAgICAgICBsZXQgcmV2X2lucHV0ID0gTGlzdC5yZXYgaW5wdXQgaW5cbiAgICAgICAgbGV0IHJldl9vdXRwdXQgPSBzdHJpcF9wcmVmaXhlcyByZXZfaW5wdXQgfnByZWZpeGVzOnN1ZmZpeGVzIGluXG4gICAgICAgIGlmIG5vdCAocGh5c19lcXVhbCByZXZfaW5wdXQgcmV2X291dHB1dCkgdGhlbiBMaXN0LnJldiByZXZfb3V0cHV0IGVsc2UgaW5wdXRcbiAgICAgIGluXG4gICAgICB0cmFjZXNcbiAgICAgIHw+IHN0cmlwX3ByZWZpeGVzIH5wcmVmaXhlczpbIGVycm9yIF1cbiAgICAgIHw+IHN0cmlwX3N1ZmZpeGVzIH5zdWZmaXhlczpbIGpvYl9xdWV1ZTsgZGVmZXJyZWQwOyBkZWZlcnJlZDE7IG1vbml0b3I7IHRyeV93aXRoIF1cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHsgZXhuOyBiYWNrdHJhY2U7IGJhY2t0cmFjZV9oaXN0b3J5OyBtb25pdG9yIH0gPVxuICAgIGxldCBtb25pdG9yID1cbiAgICAgIGxldCBuYW1lID1cbiAgICAgICAgbWF0Y2ggSW5mby50b19zdHJpbmdfaHVtIG1vbml0b3IubmFtZSB3aXRoXG4gICAgICAgIHwgXCJcIiAtPiBOb25lXG4gICAgICAgIHwgcyAtPiBTb21lIHNcbiAgICAgIGluXG4gICAgICBsZXQgcG9zID1cbiAgICAgICAgbWF0Y2ggbW9uaXRvci5oZXJlIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGhlcmUgLT5cbiAgICAgICAgICAoKiBXZSBkaXNwbGF5IHRoZSBmdWxsIGZpbGVuYW1lLCB3aGVyZWFzIGJhY2t0cmFjZXMgb25seSBoYXZlIGJhc2VuYW1lcywgYnV0XG4gICAgICAgICAgICAgcGVyaGFwcyB0aGF0J3Mgd2hhdCBzaG91bGQgY2hhbmdlLiAqKVxuICAgICAgICAgIGxldCBjb2x1bW4gPSBoZXJlLnBvc19jbnVtIC0gaGVyZS5wb3NfYm9sIGluXG4gICAgICAgICAgU29tZVxuICAgICAgICAgICAgKCogV2UgaGlkZSBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycyB3aGVuIFthbV9ydW5uaW5nX3Rlc3RdIHRvIG1ha2UgdGVzdCBvdXRwdXRcbiAgICAgICAgICAgICAgIG1vcmUgcm9idXN0LiAgVGhpcyBzYXZlcyBwZW9wbGUgbWFudWFsbHkgaGlkaW5nIHRoZSBudW1iZXJzIG9yIGV2ZW4gd29yc2UsXG4gICAgICAgICAgICAgICBsZWF2aW5nIHRoZW0gaW4gdGVzdCBvdXRwdXQuICBIaWRpbmcgaW4gdGVzdCBpcyBkaWZmZXJlbnQgY2hvaWNlIGZvclxuICAgICAgICAgICAgICAgYmVoYXZpb3IgdGhhbiBvdXIgY29kZWJhc2UgbWFrZXMgZm9yIFtCYWNrdHJhY2UuZWxpZGVdLCB3aGljaCBoYXMgZGVmYXVsdFxuICAgICAgICAgICAgICAgW2ZhbHNlXSwgYW5kIHRodXMgc2hvd3MgYmFja3RyYWNlcyBpbiB0ZXN0LiAgVGhlcmUgYXJlIGEgY291cGxlIHJlYXNvbnMgZm9yXG4gICAgICAgICAgICAgICB0aGlzIGRpZmZlcmVudCBjaG9pY2UuICBGaXJzdCwgZXhwZWN0LXRlc3QgbWFjaGluZXJ5IGhhcyBjaGVjayB0byBwcmV2ZW50XG4gICAgICAgICAgICAgICBiYWNrdHJhY2VzIGZyb20gYXBwZWFyaW5nIGluIHRlc3Qgb3V0cHV0LiAgSXQgaGFzIG5vIHN1Y2ggY2hlY2tzIGZvciBsaW5lXG4gICAgICAgICAgICAgICBhbmQgY29sdW1uIG51bWJlcnMuICBTZWNvbmQsIHdoZW4gdGhlcmUgaXMgYSByZWFsIGVycm9yIGFuZCB5b3Ugd2FudCB0byBzZWVcbiAgICAgICAgICAgICAgIHRoZSBiYWNrdHJhY2UsIHRocm93aW5nIGF3YXkgdGhlIHdob2xlIGJhY2t0cmFjZSBsb3NlcyBhIGxvdCBvZiBwb3RlbnRpYWxseVxuICAgICAgICAgICAgICAgdXNlZnVsIGluZm9ybWF0aW9uIHRoYXQgbWF5IGJlIGhhcmQgdG8gcmVjb3Zlci4gIFdoZXJlYXMgd2UncmUganVzdFxuICAgICAgICAgICAgICAgdGhyb3dpbmcgYSB3YXkgYSBsaW5lIG51bWJlciBhbmQgY29sdW1uLCB3aGljaCBhcmUgYSBtaW5vciBjb252ZW5pZW5jZVxuICAgICAgICAgICAgICAgZ2l2ZW4gdGhhdCB0aGUgZmlsZW5hbWUgaGFzIG1vc3Qgb2YgdGhlIGluZm9ybWF0aW9uLiAqKVxuICAgICAgICAgICAgKGlmIGFtX3J1bm5pbmdfdGVzdFxuICAgICAgICAgICAgIHRoZW4gc3ByaW50ZiBcImZpbGUgJVMsIGxpbmUgTElORSwgY2hhcmFjdGVycyBDMS1DMlwiIGhlcmUucG9zX2ZuYW1lXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgc3ByaW50ZlxuICAgICAgICAgICAgICAgICBcImZpbGUgJVMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWRcIlxuICAgICAgICAgICAgICAgICBoZXJlLnBvc19mbmFtZVxuICAgICAgICAgICAgICAgICBoZXJlLnBvc19sbnVtXG4gICAgICAgICAgICAgICAgIGNvbHVtblxuICAgICAgICAgICAgICAgICBjb2x1bW4pXG4gICAgICBpblxuICAgICAgbWF0Y2ggcG9zLCBuYW1lIHdpdGhcbiAgICAgIHwgTm9uZSwgTm9uZSAtPiBbXVxuICAgICAgfCBTb21lIHBvcywgTm9uZSAtPiBbIHNwcmludGYgXCJDYXVnaHQgYnkgbW9uaXRvciBhdCAlc1wiIHBvcyBdXG4gICAgICB8IE5vbmUsIFNvbWUgbmFtZSAtPiBbIHNwcmludGYgXCJDYXVnaHQgYnkgbW9uaXRvciAlc1wiIG5hbWUgXVxuICAgICAgfCBTb21lIHBvcywgU29tZSBuYW1lIC0+IFsgc3ByaW50ZiBcIkNhdWdodCBieSBtb25pdG9yICVzIGF0ICVzXCIgbmFtZSBwb3MgXVxuICAgIGluXG4gICAgbGV0IGJhY2t0cmFjZSA9XG4gICAgICBsZXQgYmFja3RyYWNlID1cbiAgICAgICAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFtdXG4gICAgICAgIHwgU29tZSBiYWNrdHJhY2UgLT4gQmFja3RyYWNlLnRvX3N0cmluZ19saXN0IGJhY2t0cmFjZVxuICAgICAgaW5cbiAgICAgIGJhY2t0cmFjZV90cnVuY2F0aW9uX2hldXJpc3RpY3MgYmFja3RyYWNlIEAgbW9uaXRvclxuICAgIGluXG4gICAgbGV0IGxpc3RfaWZfbm90X2VtcHR5ID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgfCBfIDo6IF8gYXMgbCAtPiBTb21lIGxcbiAgICBpblxuICAgIFslc2V4cFxuICAgICAgKGV4biA6IGV4bilcbiAgICAgICwgKGxpc3RfaWZfbm90X2VtcHR5IGJhY2t0cmFjZSA6IChzdHJpbmcgbGlzdCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICAsIGBiYWNrdHJhY2VfaGlzdG9yeVxuICAgICAgICAgIChsaXN0X2lmX25vdF9lbXB0eSBiYWNrdHJhY2VfaGlzdG9yeSA6IChCYWNrdHJhY2UudCBsaXN0IG9wdGlvbltAc2V4cC5vcHRpb25dKSldXG4gIDs7XG5lbmRcblxuZXhjZXB0aW9uIE1vbml0b3JfZXhuIG9mIE1vbml0b3JfZXhuLnRcblxubGV0ICgpID1cbiAgU2V4cGxpYi5Db252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1vbml0b3JfZXhuXSAoZnVuY3Rpb25cbiAgICB8IE1vbml0b3JfZXhuIHQgLT4gWyVzZXhwIFwibW9uaXRvci5tbC5FcnJvclwiIDo6ICh0IDogTW9uaXRvcl9leG4udCldXG4gICAgfCBfIC0+XG4gICAgICAoKiBSZWFjaGluZyB0aGlzIGJyYW5jaCBpbmRpY2F0ZXMgYSBidWcgaW4gc2V4cGxpYi4gKilcbiAgICAgIGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCBleHRyYWN0X2V4biBleG4gPVxuICBtYXRjaCBleG4gd2l0aFxuICB8IE1vbml0b3JfZXhuIGVycm9yIC0+IGVycm9yLmV4blxuICB8IGV4biAtPiBleG5cbjs7XG5cbmxldCBzZW5kX2V4biB0ID8oYmFja3RyYWNlID0gYEdldCkgZXhuID1cbiAgbGV0IGV4biA9XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICB8IE1vbml0b3JfZXhuIF8gLT4gZXhuXG4gICAgfCBfIC0+XG4gICAgICBsZXQgYmFja3RyYWNlID1cbiAgICAgICAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgICAgICAgfCBgR2V0IC0+IEJhY2t0cmFjZS5FeG4ubW9zdF9yZWNlbnRfZm9yX2V4biBleG5cbiAgICAgICAgfCBgVGhpcyBiIC0+IFNvbWUgYlxuICAgICAgaW5cbiAgICAgIGxldCBiYWNrdHJhY2VfaGlzdG9yeSA9IChjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICgpKS5iYWNrdHJhY2VfaGlzdG9yeSBpblxuICAgICAgTW9uaXRvcl9leG4geyBNb25pdG9yX2V4bi5leG47IGJhY2t0cmFjZTsgYmFja3RyYWNlX2hpc3Rvcnk7IG1vbml0b3IgPSB0IH1cbiAgaW5cbiAgaWYgRGVidWcubW9uaXRvcl9zZW5kX2V4biB0aGVuIERlYnVnLmxvZyBcIk1vbml0b3Iuc2VuZF9leG5cIiAodCwgZXhuKSBbJXNleHBfb2Y6IHQgKiBleG5dO1xuICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgbGV0IHJlYyBsb29wIHQgPVxuICAgIHQuaGFzX3NlZW5fZXJyb3IgPC0gdHJ1ZTtcbiAgICBJdmFyLmZpbGxfZXhuIHQubmV4dF9lcnJvciBleG47XG4gICAgdC5uZXh0X2Vycm9yIDwtIEl2YXIuY3JlYXRlICgpO1xuICAgIG1hdGNoIHQuZm9yd2FyZGluZyB3aXRoXG4gICAgfCBEZXRhY2hlZCAtPlxuICAgICAgaWYgRGVidWcubW9uaXRvcl9zZW5kX2V4blxuICAgICAgdGhlblxuICAgICAgICBEZWJ1Zy5sb2cgXCJNb25pdG9yLnNlbmRfZXhuIGZvdW5kIGxpc3RlbmluZyBtb25pdG9yXCIgKHQsIGV4bikgWyVzZXhwX29mOiB0ICogZXhuXTtcbiAgICAgIEJhZy5pdGVyIHQuaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMgfmY6KGZ1biAoZXhlY3V0aW9uX2NvbnRleHQsIGYpIC0+XG4gICAgICAgIFNjaGVkdWxlci5lbnF1ZXVlIHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGV4bik7XG4gICAgICBMaXN0Lml0ZXIgdC50YWlsc19mb3JfYWxsX2Vycm9ycyB+ZjooZnVuIHRhaWwgLT4gVGFpbC5leHRlbmQgdGFpbCBleG4pXG4gICAgfCBQYXJlbnQgcGFyZW50IC0+IGxvb3AgcGFyZW50XG4gICAgfCBSZXBvcnRfdW5jYXVnaHRfZXhuIC0+XG4gICAgICAoKiBEbyBub3QgY2hhbmdlIHRoaXMgYnJhbmNoIHRvIHByaW50IHRoZSBleGNlcHRpb24gb3IgdG8gZXhpdC4gIEhhdmluZyB0aGVcbiAgICAgICAgIHNjaGVkdWxlciByYWlzZSBhbiB1bmNhdWdodCBleGNlcHRpb24gaXMgdGhlIG5lY2Vzc2FyeSBiZWhhdmlvciBmb3IgcHJvZ3JhbXNcbiAgICAgICAgIHRoYXQgY2FsbCBbU2NoZWR1bGVyLmdvXSBhbmQgd2FudCB0byBoYW5kbGUgaXQuICopXG4gICAgICBTY2hlZHVsZXIuKGdvdF91bmNhdWdodF9leG4gKHQgKCkpKSBleG4gKCFBc3luY19rZXJuZWxfY29uZmlnLnRhc2tfaWQgKCkpXG4gIGluXG4gIGxvb3AgdFxuOztcblxubW9kdWxlIEV4cG9ydGVkX2Zvcl9zY2hlZHVsZXIgPSBzdHJ1Y3RcbiAgbGV0IHdpdGhpbl9jb250ZXh0IGNvbnRleHQgZiA9XG4gICAgU2NoZWR1bGVyLih3aXRoX2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSkgY29udGV4dCB+ZjooZnVuICgpIC0+XG4gICAgICBtYXRjaCBSZXN1bHQudHJ5X3dpdGggZiB3aXRoXG4gICAgICB8IE9rIHggLT4gT2sgeFxuICAgICAgfCBFcnJvciBleG4gLT5cbiAgICAgICAgc2VuZF9leG4gKEV4ZWN1dGlvbl9jb250ZXh0Lm1vbml0b3IgY29udGV4dCkgZXhuIH5iYWNrdHJhY2U6YEdldDtcbiAgICAgICAgRXJyb3IgKCkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgd2l0aGluX2dlbiA/bW9uaXRvciA/cHJpb3JpdHkgZiA9XG4gICAgbGV0IHRtcF9jb250ZXh0ID1cbiAgICAgIEV4ZWN1dGlvbl9jb250ZXh0LmNyZWF0ZV9saWtlIChjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICgpKSA/bW9uaXRvciA/cHJpb3JpdHlcbiAgICBpblxuICAgIHdpdGhpbl9jb250ZXh0IHRtcF9jb250ZXh0IGZcbiAgOztcblxuICBsZXQgd2l0aGluJyA/bW9uaXRvciA/cHJpb3JpdHkgZiA9XG4gICAgbWF0Y2ggd2l0aGluX2dlbiA/bW9uaXRvciA/cHJpb3JpdHkgZiB3aXRoXG4gICAgfCBFcnJvciAoKSAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgIHwgT2sgZCAtPiBkXG4gIDs7XG5cbiAgbGV0IHdpdGhpbl92ID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBtYXRjaCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmIHdpdGhcbiAgICB8IEVycm9yICgpIC0+IE5vbmVcbiAgICB8IE9rIHggLT4gU29tZSB4XG4gIDs7XG5cbiAgbGV0IHdpdGhpbiA/bW9uaXRvciA/cHJpb3JpdHkgZiA9XG4gICAgbWF0Y2ggd2l0aGluX2dlbiA/bW9uaXRvciA/cHJpb3JpdHkgZiB3aXRoXG4gICAgfCBFcnJvciAoKSAtPiAoKVxuICAgIHwgT2sgKCkgLT4gKClcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfd2l0aF9kYXRhID9tb25pdG9yID9wcmlvcml0eSB3b3JrIHggPVxuICAgIGxldCBzY2hlZHVsZXIgPSBTY2hlZHVsZXIudCAoKSBpblxuICAgIFNjaGVkdWxlci5lbnF1ZXVlXG4gICAgICBzY2hlZHVsZXJcbiAgICAgIChFeGVjdXRpb25fY29udGV4dC5jcmVhdGVfbGlrZVxuICAgICAgICAgKFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlcilcbiAgICAgICAgID9tb25pdG9yXG4gICAgICAgICA/cHJpb3JpdHkpXG4gICAgICB3b3JrXG4gICAgICB4XG4gIDs7XG5cbiAgbGV0IHNjaGVkdWxlID9tb25pdG9yID9wcmlvcml0eSB3b3JrID0gc2NoZWR1bGVfd2l0aF9kYXRhID9tb25pdG9yID9wcmlvcml0eSB3b3JrICgpXG5cbiAgbGV0IHNjaGVkdWxlJyA9XG4gICAgKCogRm9yIHBlcmZvcm1hbmNlLCB3ZSB1c2UgW3NjaGVkdWxlX3dpdGhfZGF0YV0gd2l0aCBhIGNsb3NlZCBmdW5jdGlvbiwgYW5kIGlubGluZVxuICAgICAgIFtEZWZlcnJlZC5jcmVhdGVdLiAqKVxuICAgIGxldCB1cG9uX3dvcmtfZmlsbF9pICh3b3JrLCBpKSA9IHVwb24gKHdvcmsgKCkpIChmdW4gYSAtPiBJdmFyLmZpbGxfZXhuIGkgYSkgaW5cbiAgICBmdW4gP21vbml0b3IgP3ByaW9yaXR5IHdvcmsgLT5cbiAgICAgIGxldCBpID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICAgIHNjaGVkdWxlX3dpdGhfZGF0YSA/bW9uaXRvciA/cHJpb3JpdHkgdXBvbl93b3JrX2ZpbGxfaSAod29yaywgaSk7XG4gICAgICBJdmFyLnJlYWQgaVxuICA7O1xuXG4gIGxldCBwcmVzZXJ2ZV9leGVjdXRpb25fY29udGV4dCBmID1cbiAgICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBTY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dCBzY2hlZHVsZXIgaW5cbiAgICBzdGFnZSAoZnVuIGEgLT4gU2NoZWR1bGVyLmVucXVldWUgc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IGYgYSlcbiAgOztcblxuICBsZXQgcHJlc2VydmVfZXhlY3V0aW9uX2NvbnRleHQnIGYgPVxuICAgIGxldCBzY2hlZHVsZXIgPSBTY2hlZHVsZXIudCAoKSBpblxuICAgIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlciBpblxuICAgIGxldCBjYWxsX2FuZF9maWxsIChmLCBhLCBpKSA9IHVwb24gKGYgYSkgKGZ1biByIC0+IEl2YXIuZmlsbF9leG4gaSByKSBpblxuICAgIHN0YWdlIChmdW4gYSAtPlxuICAgICAgRGVmZXJyZWQuY3JlYXRlIChmdW4gaSAtPlxuICAgICAgICBTY2hlZHVsZXIuZW5xdWV1ZSBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgY2FsbF9hbmRfZmlsbCAoZiwgYSwgaSkpKVxuICA7O1xuZW5kXG5cbm9wZW4gRXhwb3J0ZWRfZm9yX3NjaGVkdWxlclxuXG5sZXQgc3RyZWFtX2l0ZXIgc3RyZWFtIH5mID1cbiAgbGV0IHJlYyBsb29wIHN0cmVhbSA9XG4gICAgU3RyZWFtLm5leHQgc3RyZWFtXG4gICAgPj4+IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHYsIHN0cmVhbSkgLT5cbiAgICAgIGxvb3Agc3RyZWFtO1xuICAgICAgZiB2XG4gIGluXG4gIGxvb3Agc3RyZWFtXG47O1xuXG4oKiBBbiBbJ2EgT2tfYW5kX2V4bnMudF0gcmVwcmVzZW50cyB0aGUgb3V0cHV0IG9mIGEgY29tcHV0YXRpb24gcnVubmluZyBpbiBhIGRldGFjaGVkXG4gICBtb25pdG9yLiAqKVxubW9kdWxlIE9rX2FuZF9leG5zID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBvayA6ICdhIERlZmVycmVkLnRcbiAgICA7IGV4bnMgOiBleG4gU3RyZWFtLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSA/aGVyZSA/aW5mbyA/bmFtZSB+cnVuIGYgPVxuICAgICgqIFdlIGNhbGwgW2NyZWF0ZV93aXRoX3BhcmVudCBOb25lXSBiZWNhdXNlIFttb25pdG9yXSBkb2VzIG5vdCBuZWVkIGEgcGFyZW50LiAgSXRcbiAgICAgICBkb2VzIG5vdCBiZWNhdXNlIHdlIGNhbGwgW2RldGFjaF9hbmRfZ2V0X2Vycm9yX3N0cmVhbSBtb25pdG9yXSBhbmQgZGVhbCB3aXRoIHRoZVxuICAgICAgIGVycm9ycyBleHBsaWNpdGx5LCB0aHVzIFtzZW5kX2V4bl0gd291bGQgbmV2ZXIgcHJvcGFnYXRlIGFuIGV4biBwYXN0IFttb25pdG9yXS4gKilcbiAgICBsZXQgbW9uaXRvciA9IGNyZWF0ZV93aXRoX3BhcmVudCA/aGVyZSA/aW5mbyA/bmFtZSBOb25lIGluXG4gICAgbGV0IGV4bnMgPSBkZXRhY2hfYW5kX2dldF9lcnJvcl9zdHJlYW0gbW9uaXRvciBpblxuICAgIGxldCBvayA9XG4gICAgICBtYXRjaCBydW4gd2l0aFxuICAgICAgfCBgTm93IC0+IHdpdGhpbicgfm1vbml0b3IgZlxuICAgICAgfCBgU2NoZWR1bGUgLT4gc2NoZWR1bGUnIH5tb25pdG9yIGZcbiAgICBpblxuICAgIHsgb2s7IGV4bnMgfVxuICA7O1xuZW5kXG5cbmxldCBmaWxsX3Jlc3VsdF9hbmRfaGFuZGxlX2JhY2tncm91bmRfZXJyb3JzXG4gIHJlc3VsdF9maWxsZXJcbiAgcmVzdWx0XG4gIGV4bnNcbiAgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0XG4gID1cbiAgaWYgSXZhcl9maWxsZXIuaXNfZW1wdHkgcmVzdWx0X2ZpbGxlclxuICB0aGVuIChcbiAgICBJdmFyX2ZpbGxlci5maWxsIHJlc3VsdF9maWxsZXIgcmVzdWx0O1xuICAgIGhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCBleG5zKVxuOztcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBsZXQgdHJ5X3dpdGhfbG9nX2V4biA6IChleG4gLT4gdW5pdCkgcmVmID1cbiAgICByZWYgKGZ1biBleG4gLT5cbiAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiZmFpbGVkIHRvIHNldCBbTW9uaXRvci5FeHBlcnQudHJ5X3dpdGhfbG9nX2V4bl1cIiAoZXhuIDogRXhuLnQpXSlcbiAgOztcbmVuZFxuXG5sZXQgbWFrZV9oYW5kbGVfZXhuIHJlc3QgPVxuICBtYXRjaCByZXN0IHdpdGhcbiAgfCBgTG9nIC0+XG4gICAgKCogV2UgYXJlIGNhcmVmdWwgdG8gbm90IGNsb3NlIG92ZXIgY3VycmVudCBjb250ZXh0LCB3aGljaCBpcyBub3QgbmVlZGVkLiAqKVxuICAgICFFeHBlcnQudHJ5X3dpdGhfbG9nX2V4blxuICB8IGBSYWlzZSAtPlxuICAgIGxldCBwYXJlbnQgPSBjdXJyZW50ICgpIGluXG4gICAgZnVuIGV4biAtPiBzZW5kX2V4biBwYXJlbnQgZXhuIH5iYWNrdHJhY2U6YEdldFxuICB8IGBDYWxsIGYgLT5cbiAgICBsZXQgcGFyZW50ID0gY3VycmVudCAoKSBpblxuICAgIGZ1biBleG4gLT4gd2l0aGluIH5tb25pdG9yOnBhcmVudCAoZnVuICgpIC0+IGYgZXhuKVxuOztcblxubGV0IHRyeV93aXRoXG4gID9oZXJlXG4gID9pbmZvXG4gID8obmFtZSA9IFwiXCIpXG4gID9leHRyYWN0X2V4bjooZG9fZXh0cmFjdF9leG4gPSBmYWxzZSlcbiAgPyhydW4gPSBgTm93KVxuICA/KHJlc3QgPSBgUmFpc2UpXG4gIGZcbiAgPVxuICBsZXQgeyBPa19hbmRfZXhucy5vazsgZXhucyB9ID0gT2tfYW5kX2V4bnMuY3JlYXRlID9oZXJlID9pbmZvIH5uYW1lIH5ydW4gZiBpblxuICBsZXQgaGFuZGxlX2V4biA9IG1ha2VfaGFuZGxlX2V4biByZXN0IGluXG4gIGxldCBoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHQgZXhucyA9IHN0cmVhbV9pdGVyIGV4bnMgfmY6aGFuZGxlX2V4biBpblxuICAoKiBXZSBydW4gW3dpdGhpbicgfm1vbml0b3I6bWFpbl0gdG8gYXZvaWQgaG9sZGluZyBvbiB0byByZWZlcmVuY2VzIHRvIHRoZSBldmFsdWF0aW9uXG4gICAgIGNvbnRleHQgaW4gd2hpY2ggW3RyeV93aXRoXSB3YXMgY2FsbGVkLiAgVGhpcyBhdm9pZHMgYSBzcGFjZSBsZWFrIHdoZW4gYSBjaGFpbiBvZlxuICAgICBbdHJ5X3dpdGhdJ3MgYXJlIHJ1biBlYWNoIG5lc3RlZCB3aXRoaW4gdGhlIHByZXZpb3VzIG9uZS4gIFdpdGhvdXQgdGhlIFt3aXRoaW4nXSwgdGhlXG4gICAgIGVycm9yIGhhbmRsaW5nIGZvciB0aGUgaW5uZXJtb3N0IFt0cnlfd2l0aF0gd291bGQga2VlcCBhbGl2ZSB0aGUgZW50aXJlIGNoYWluLiAqKVxuICB3aXRoaW4nIH5tb25pdG9yOm1haW4gKGZ1biAoKSAtPlxuICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgb2tcbiAgICB0aGVuIChcbiAgICAgIGhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCBleG5zO1xuICAgICAgcmV0dXJuIChPayAoRGVmZXJyZWQudmFsdWVfZXhuIG9rKSkpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVzdWx0X2ZpbGxlciwgcmVzdWx0ID0gSXZhcl9maWxsZXIuY3JlYXRlICgpIGluXG4gICAgICB1cG9uIG9rIChmdW4gcmVzIC0+XG4gICAgICAgIGZpbGxfcmVzdWx0X2FuZF9oYW5kbGVfYmFja2dyb3VuZF9lcnJvcnNcbiAgICAgICAgICByZXN1bHRfZmlsbGVyXG4gICAgICAgICAgKE9rIHJlcylcbiAgICAgICAgICBleG5zXG4gICAgICAgICAgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0KTtcbiAgICAgIHVwb24gKFN0cmVhbS5uZXh0IGV4bnMpIChmdW5jdGlvblxuICAgICAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgfCBDb25zIChleG4sIGV4bnMpIC0+XG4gICAgICAgICAgbGV0IGV4biA9IGlmIGRvX2V4dHJhY3RfZXhuIHRoZW4gZXh0cmFjdF9leG4gZXhuIGVsc2UgZXhuIGluXG4gICAgICAgICAgZmlsbF9yZXN1bHRfYW5kX2hhbmRsZV9iYWNrZ3JvdW5kX2Vycm9yc1xuICAgICAgICAgICAgcmVzdWx0X2ZpbGxlclxuICAgICAgICAgICAgKEVycm9yIGV4bilcbiAgICAgICAgICAgIGV4bnNcbiAgICAgICAgICAgIGhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCk7XG4gICAgICByZXN1bHQpKVxuOztcblxubGV0IHRyeV93aXRoX29yX2Vycm9yID9oZXJlID9pbmZvID8obmFtZSA9IFwidHJ5X3dpdGhfb3JfZXJyb3JcIikgP2V4dHJhY3RfZXhuID9yZXN0IGYgPVxuICB0cnlfd2l0aCBmID9oZXJlID9pbmZvIH5uYW1lID9leHRyYWN0X2V4biB+cnVuOmBOb3cgP3Jlc3QgPj58IE9yX2Vycm9yLm9mX2V4bl9yZXN1bHRcbjs7XG5cbmxldCB0cnlfd2l0aF9qb2luX29yX2Vycm9yXG4gID9oZXJlXG4gID9pbmZvXG4gID8obmFtZSA9IFwidHJ5X3dpdGhfam9pbl9vcl9lcnJvclwiKVxuICA/ZXh0cmFjdF9leG5cbiAgP3Jlc3RcbiAgZlxuICA9XG4gIHRyeV93aXRoX29yX2Vycm9yIGYgP2hlcmUgP2luZm8gfm5hbWUgP2V4dHJhY3RfZXhuID9yZXN0ID4+fCBPcl9lcnJvci5qb2luXG47O1xuXG5sZXQgcHJvdGVjdCA/aGVyZSA/aW5mbyA/KG5hbWUgPSBcIk1vbml0b3IucHJvdGVjdFwiKSA/ZXh0cmFjdF9leG4gP3J1biA/cmVzdCBmIH5maW5hbGx5ID1cbiAgbGV0JWJpbmQgciA9IHRyeV93aXRoID9leHRyYWN0X2V4biA/aGVyZSA/aW5mbyA/cnVuID9yZXN0IH5uYW1lIGYgaW5cbiAgbGV0JW1hcCBmciA9XG4gICAgdHJ5X3dpdGhcbiAgICAgIH5leHRyYWN0X2V4bjpmYWxzZVxuICAgICAgP2hlcmVcbiAgICAgID9pbmZvXG4gICAgICB+cnVuOmBTY2hlZHVsZSAoKiBjb25zaWRlciBbfnJ1bjpgTm93XSAqKVxuICAgICAgP3Jlc3RcbiAgICAgIH5uYW1lOlwiZmluYWxseVwiXG4gICAgICBmaW5hbGx5XG4gIGluXG4gIG1hdGNoIHIsIGZyIHdpdGhcbiAgfCBFcnJvciBleG4sIEVycm9yIGZpbmFsbHlfZXhuIC0+XG4gICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJBc3luYyBmaW5hbGx5XCIgKGV4biA6IGV4bikgKGZpbmFsbHlfZXhuIDogZXhuKV1cbiAgfCBFcnJvciBlLCBPayAoKSB8IE9rIF8sIEVycm9yIGUgLT4gcmFpc2UgZVxuICB8IE9rIHIsIE9rICgpIC0+IHJcbjs7XG5cbmxldCBoYW5kbGVfZXJyb3JzID9oZXJlID9pbmZvID9uYW1lIGYgaGFuZGxlciA9XG4gIGxldCB7IE9rX2FuZF9leG5zLm9rOyBleG5zIH0gPSBPa19hbmRfZXhucy5jcmVhdGUgP2hlcmUgP2luZm8gP25hbWUgfnJ1bjpgTm93IGYgaW5cbiAgc3RyZWFtX2l0ZXIgZXhucyB+ZjpoYW5kbGVyO1xuICBva1xuOztcblxubGV0IGNhdGNoX3N0cmVhbSA/aGVyZSA/aW5mbyA/bmFtZSBmID1cbiAgbGV0IHsgT2tfYW5kX2V4bnMuZXhuczsgXyB9ID1cbiAgICBPa19hbmRfZXhucy5jcmVhdGUgP2hlcmUgP2luZm8gP25hbWUgfnJ1bjpgTm93IChmdW4gKCkgLT5cbiAgICAgIGYgKCk7XG4gICAgICByZXR1cm4gKCkpXG4gIGluXG4gIGV4bnNcbjs7XG5cbmxldCBjYXRjaCA/aGVyZSA/aW5mbyA/bmFtZSBmID1cbiAgbWF0Y2glbWFwIFN0cmVhbS5uZXh0IChjYXRjaF9zdHJlYW0gP2hlcmUgP2luZm8gP25hbWUgZikgd2l0aFxuICB8IENvbnMgKHgsIF8pIC0+IHhcbiAgfCBOaWwgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJNb25pdG9yLmNhdGNoIGdvdCB1bmV4cGVjdGVkIGVtcHR5IHN0cmVhbVwiXVxuOztcblxubGV0IGNhdGNoX2Vycm9yID9oZXJlID9pbmZvID9uYW1lIGYgPSBjYXRjaCA/aGVyZSA/aW5mbyA/bmFtZSBmID4+fCBFcnJvci5vZl9leG5cblxubW9kdWxlIEZvcl90ZXN0cyA9IHN0cnVjdFxuICBsZXQgcGFyZW50IHQgPVxuICAgIG1hdGNoIHQuZm9yd2FyZGluZyB3aXRoXG4gICAgfCBSZXBvcnRfdW5jYXVnaHRfZXhuIC0+IE5vbmVcbiAgICB8IFBhcmVudCBwYXJlbnQgLT4gU29tZSBwYXJlbnRcbiAgICB8IERldGFjaGVkIC0+IE5vbmVcbiAgOztcblxuICBsZXQgZGVwdGggdCA9XG4gICAgbGV0IHJlYyBsb29wIHQgbiA9XG4gICAgICBtYXRjaCBwYXJlbnQgdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gblxuICAgICAgfCBTb21lIHQgLT4gbG9vcCB0IChuICsgMSlcbiAgICBpblxuICAgIGxvb3AgdCAwXG4gIDs7XG5lbmRcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuaW5jbHVkZSBUYWlsLlN0cmVhbVxuXG5sZXQgZmlyc3RfZXhuIHQgPVxuICBtYXRjaCVtYXAgbmV4dCB0IHdpdGhcbiAgfCBOaWwgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJTdHJlYW0uZmlyc3Qgb2YgZW1wdHkgc3RyZWFtXCJdXG4gIHwgQ29ucyAoeCwgXykgLT4geFxuOztcblxubGV0IGZvbGQnIHQgfmluaXQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCBiID1cbiAgICAgIHVwb24gKG5leHQgdCkgKGZ1bmN0aW9uXG4gICAgICAgIHwgTmlsIC0+IEl2YXIuZmlsbF9leG4gcmVzdWx0IGJcbiAgICAgICAgfCBDb25zICh2LCB0KSAtPiB1cG9uIChmIGIgdikgKGxvb3AgdCkpXG4gICAgaW5cbiAgICBsb29wIHQgaW5pdClcbjs7XG5cbigqIFtmb2xkXSBpcyBpbXBsZW1lbnRlZCB0byBhdm9pZCBwZXItc3RyZWFtLWVsZW1lbnQgZGVmZXJyZWQgb3ZlcmhlYWQgaW4gdGhlIGNhc2Ugd2hlblxuICAgbXVsdGlwbGUgc3RyZWFtIGVsZW1lbnRzIGFyZSBhdmFpbGFibGUgc2ltdWx0YW5lb3VzbHkuICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIHQgYiA9XG4gICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChuZXh0IHQpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB1cG9uIChuZXh0IHQpIChmdW4gbmV4dCAtPiBsb29wX25leHQgbmV4dCBiKVxuICAgICAgfCBTb21lIG5leHQgLT4gbG9vcF9uZXh0IG5leHQgYlxuICAgIGFuZCBsb29wX25leHQgbmV4dCBiID1cbiAgICAgIG1hdGNoIG5leHQgd2l0aFxuICAgICAgfCBOaWwgLT4gSXZhci5maWxsX2V4biByZXN1bHQgYlxuICAgICAgfCBDb25zICh2LCB0KSAtPiBsb29wIHQgKGYgYiB2KVxuICAgIGluXG4gICAgbG9vcCB0IGluaXQpXG47O1xuXG5sZXQgbGVuZ3RoIHQgPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIG4gXyAtPiBuICsgMSlcbmxldCBpdGVyJyB0IH5mID0gZm9sZCcgdCB+aW5pdDooKSB+ZjooZnVuICgpIHYgLT4gZiB2KVxuXG5sZXQgY2xvc2VkIHQgPVxuICBtYXRjaCBEZWZlcnJlZC5wZWVrIChuZXh0IHQpIHdpdGhcbiAgfCBTb21lIE5pbCAtPiByZXR1cm4gKClcbiAgfCBfIC0+IGl0ZXInIHQgfmY6KGZ1biBfIC0+IHJldHVybiAoKSlcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBkb24ndF93YWl0X2ZvclxuICAgIChpdGVyJyB0IH5mOihmdW4gYSAtPlxuICAgICAgIGYgYTtcbiAgICAgICByZXR1cm4gKCkpKVxuOztcblxubGV0IGNyZWF0ZSBmID1cbiAgbGV0IHRhaWwgPSBUYWlsLmNyZWF0ZSAoKSBpblxuICAoKiBjb2xsZWN0IGJlZm9yZSBjYWxsaW5nIFtmXSwgaW4gY2FzZSBbZl0gaW1tZWRpYXRlbHkgZXh0ZW5kcy4gKilcbiAgbGV0IHQgPSBUYWlsLmNvbGxlY3QgdGFpbCBpblxuICBmIHRhaWw7XG4gIHRcbjs7XG5cbmxldCB1bmZvbGQgYiB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBsZXQgcmVjIGxvb3AgYiA9XG4gICAgICB1cG9uIChmIGIpIChmdW5jdGlvblxuICAgICAgICB8IE5vbmUgLT4gVGFpbC5jbG9zZV9leG4gdGFpbFxuICAgICAgICB8IFNvbWUgKGEsIGIpIC0+XG4gICAgICAgICAgVGFpbC5leHRlbmQgdGFpbCBhO1xuICAgICAgICAgIGxvb3AgYilcbiAgICBpblxuICAgIGxvb3AgYilcbjs7XG5cbmxldCBvZl9saXN0IGwgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IFRhaWwuZXh0ZW5kIHRhaWwgeCk7XG4gICAgVGFpbC5jbG9zZV9leG4gdGFpbClcbjs7XG5cbmxldCB0b19saXN0IHMgPSBmb2xkJyBzIH5pbml0OltdIH5mOihmdW4gYiBhIC0+IHJldHVybiAoYSA6OiBiKSkgPj58IExpc3QucmV2XG5sZXQgY29weV90b190YWlsIHQgdGFpbCA9IGl0ZXInIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoVGFpbC5leHRlbmQgdGFpbCBhKSlcblxubGV0IGFwcGVuZCB0MSB0MiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uIChjb3B5X3RvX3RhaWwgdDEgdGFpbCkgKGZ1biAoKSAtPlxuICAgICAgdXBvbiAoY29weV90b190YWlsIHQyIHRhaWwpIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpKVxuOztcblxubGV0IGNvbmNhdCB0ID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb24gKGl0ZXInIHQgfmY6KGZ1biB0IC0+IGNvcHlfdG9fdGFpbCB0IHRhaWwpKSAoZnVuICgpIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWwpKVxuOztcblxubGV0IGZpbHRlcicgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uXG4gICAgICAoaXRlcicgdCB+ZjooZnVuIHYgLT5cbiAgICAgICAgIG1hdGNoJW1hcCBmIHYgd2l0aFxuICAgICAgICAgfCBmYWxzZSAtPiAoKVxuICAgICAgICAgfCB0cnVlIC0+IFRhaWwuZXh0ZW5kIHRhaWwgdikpXG4gICAgICAoZnVuICgpIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWwpKVxuOztcblxubGV0IGZpbHRlcl9kZXByZWNhdGVkIHQgfmYgPSBmaWx0ZXInIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoZiBhKSlcblxubGV0IGZpbHRlcl9tYXAnIHQgfmYgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgdXBvblxuICAgICAgKGl0ZXInIHQgfmY6KGZ1biB2IC0+XG4gICAgICAgICBtYXRjaCVtYXAgZiB2IHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgfCBTb21lIHYgLT4gVGFpbC5leHRlbmQgdGFpbCB2KSlcbiAgICAgIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgZmlsdGVyX21hcF9kZXByZWNhdGVkIHQgfmYgPSBmaWx0ZXJfbWFwJyB0IH5mOihmdW4gYSAtPiByZXR1cm4gKGYgYSkpXG5cbmxldCBtYXAnIHQgfmYgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgdXBvbiAoaXRlcicgdCB+ZjooZnVuIHYgLT4gZiB2ID4+fCBUYWlsLmV4dGVuZCB0YWlsKSkgKGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKSlcbjs7XG5cbmxldCBtYXAgdCB+ZiA9IG1hcCcgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChmIGEpKVxuXG5sZXQgZmlyc3RfbiBzIG4gPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgbGV0IHJlYyBsb29wIHMgbiA9XG4gICAgICBpZiBuID0gMFxuICAgICAgdGhlbiBUYWlsLmNsb3NlX2V4biB0YWlsXG4gICAgICBlbHNlXG4gICAgICAgIHVwb24gKG5leHQgcykgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBOaWwgLT4gVGFpbC5jbG9zZV9leG4gdGFpbFxuICAgICAgICAgIHwgQ29ucyAoeCwgdCkgLT5cbiAgICAgICAgICAgIFRhaWwuZXh0ZW5kIHRhaWwgeDtcbiAgICAgICAgICAgIGxvb3AgdCAobiAtIDEpKVxuICAgIGluXG4gICAgbG9vcCBzIG4pXG47O1xuXG5sZXQgYXZhaWxhYmxlX25vdyB0ID1cbiAgbGV0IHJlYyBsb29wIHQgYWMgPVxuICAgIG1hdGNoIERlZmVycmVkLnBlZWsgKG5leHQgdCkgd2l0aFxuICAgIHwgTm9uZSB8IFNvbWUgTmlsIC0+IExpc3QucmV2IGFjLCB0XG4gICAgfCBTb21lIChDb25zICh4LCB0KSkgLT4gbG9vcCB0ICh4IDo6IGFjKVxuICBpblxuICBsb29wIHQgW11cbjs7XG5cbmxldCBzcGxpdCA/KHN0b3AgPSBEZWZlcnJlZC5uZXZlciAoKSkgPyhmID0gZnVuIF8gLT4gYENvbnRpbnVlKSB0ID1cbiAgbGV0IHJlYXNvbl9mb3Jfc3RvcHBpbmcgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBsZXQgcHJlZml4ID0gVGFpbC5jcmVhdGUgKCkgaW5cbiAgbGV0IGZpbmlzaCB2ID1cbiAgICBUYWlsLmNsb3NlX2V4biBwcmVmaXg7XG4gICAgSXZhci5maWxsX2V4biByZWFzb25fZm9yX3N0b3BwaW5nIHZcbiAgaW5cbiAgbGV0IHJlYyBsb29wIHQgPVxuICAgIGNob29zZSBbIGNob2ljZSBzdG9wIChmdW4gKCkgLT4gYFN0b3BwZWQpOyBjaG9pY2UgKG5leHQgdCkgKGZ1biBvIC0+IGBOZXh0IG8pIF1cbiAgICA+Pj4gZnVuY3Rpb25cbiAgICB8IGBTdG9wcGVkIC0+IGZpbmlzaCAoYFN0b3BwZWQgdClcbiAgICB8IGBOZXh0IG8gLT5cbiAgICAgIChtYXRjaCBvIHdpdGhcbiAgICAgICB8IE5pbCAtPiBmaW5pc2ggYEVuZF9vZl9zdHJlYW1cbiAgICAgICB8IENvbnMgKGEsIHQpIC0+XG4gICAgICAgICAobWF0Y2ggZiBhIHdpdGhcbiAgICAgICAgICB8IGBDb250aW51ZSAtPlxuICAgICAgICAgICAgVGFpbC5leHRlbmQgcHJlZml4IGE7XG4gICAgICAgICAgICBsb29wIHRcbiAgICAgICAgICB8IGBGb3VuZCBiIC0+IGZpbmlzaCAoYEZvdW5kIChiLCB0KSkpKVxuICBpblxuICBsb29wIHQ7XG4gIFRhaWwuY29sbGVjdCBwcmVmaXgsIEl2YXIucmVhZCByZWFzb25fZm9yX3N0b3BwaW5nXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbGV0IF8sIGZvdW5kID0gc3BsaXQgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gYEZvdW5kIGEgZWxzZSBgQ29udGludWUpIGluXG4gIG1hdGNoJW1hcCBmb3VuZCB3aXRoXG4gIHwgYFN0b3BwZWQgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCAoYEVuZF9vZl9zdHJlYW0gfCBgRm91bmQgXykgYXMgeCAtPiB4XG47O1xuXG5sZXQgdW5ncm91cCB0ID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb25cbiAgICAgIChpdGVyJyB0IH5mOihmdW4gbCAtPlxuICAgICAgICAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IFRhaWwuZXh0ZW5kIHRhaWwgeCk7XG4gICAgICAgICByZXR1cm4gKCkpKVxuICAgICAgKGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKSlcbjs7XG5cbmxldCBpbnRlcmxlYXZlIHRzID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgICgqIFRoZSBpbnRlcmxlYXZlZCBzdHJlYW0gc2hvdWxkIGJlIGNsb3NlZCB3aGVuIHRoZSBvdXRlciBzdHJlYW0gYW5kIGFsbCBvZlxuICAgICAgIHRoZSBpbm5lciBzdHJlYW1zIGhhdmUgYmVlbiBjbG9zZWQuICBLZWVwIGEgY291bnQgb2YgdGhlIG51bWJlciBvZiBvcGVuXG4gICAgICAgc3RyZWFtcyBhbmQgY2xvc2UgdGhlIGludGVybGVhdmVkIHN0cmVhbSB3aGVuIHRoYXQgY291bnQgYmVjb21lc1xuICAgICAgIHplcm8uICopXG4gICAgbGV0IG51bV9vcGVuID0gcmVmIDEgaW5cbiAgICAoKiAxIGZvciB0aGUgb3V0ZXIgc3RyZWFtIHRoYXQgaXMgb3BlbiAqKVxuICAgIGxldCBjbG9zZSAoKSA9XG4gICAgICBudW1fb3BlbiA6PSAhbnVtX29wZW4gLSAxO1xuICAgICAgaWYgIW51bV9vcGVuID0gMCB0aGVuIFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICBpblxuICAgIGxldCBvdXRlcl9jbG9zZWQgPVxuICAgICAgaXRlcicgdHMgfmY6KGZ1biB0IC0+XG4gICAgICAgIG51bV9vcGVuIDo9ICFudW1fb3BlbiArIDE7XG4gICAgICAgIHVwb24gKGNvcHlfdG9fdGFpbCB0IHRhaWwpIGNsb3NlO1xuICAgICAgICByZXR1cm4gKCkpXG4gICAgaW5cbiAgICB1cG9uIG91dGVyX2Nsb3NlZCBjbG9zZSlcbjs7XG5cbmxldCB0YWtlX3VudGlsIHQgZCA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCA9XG4gICAgICB1cG9uXG4gICAgICAgIChjaG9vc2UgWyBjaG9pY2UgZCAoZnVuICgpIC0+IGBTdG9wKTsgY2hvaWNlIChuZXh0IHQpIChmdW4geiAtPiBgTmV4dCB6KSBdKVxuICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgIHwgYFN0b3AgfCBgTmV4dCBOaWwgLT4gVGFpbC5jbG9zZV9leG4gdGFpbFxuICAgICAgICAgfCBgTmV4dCAoQ29ucyAoeCwgdCkpIC0+XG4gICAgICAgICAgIFRhaWwuZXh0ZW5kIHRhaWwgeDtcbiAgICAgICAgICAgbG9vcCB0KVxuICAgIGluXG4gICAgbG9vcCB0KVxuOztcblxubGV0IGl0ZXJfZHVyYWJseScgdCB+ZiA9XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCB0ID1cbiAgICAgIG5leHQgdFxuICAgICAgPj4+IGZ1bmN0aW9uXG4gICAgICB8IE5pbCAtPiBJdmFyLmZpbGxfZXhuIHJlc3VsdCAoKVxuICAgICAgfCBDb25zICh4LCB0KSAtPlxuICAgICAgICBNb25pdG9yLnRyeV93aXRoIH5ydW46YFNjaGVkdWxlIH5yZXN0OmBSYWlzZSAoZnVuICgpIC0+IGYgeClcbiAgICAgICAgPj4+IGZ1biB6IC0+XG4gICAgICAgIGxvb3AgdDtcbiAgICAgICAgKG1hdGNoIHogd2l0aFxuICAgICAgICAgfCBPayAoKSAtPiAoKVxuICAgICAgICAgfCBFcnJvciBlIC0+IE1vbml0b3Iuc2VuZF9leG4gKE1vbml0b3IuY3VycmVudCAoKSkgZSlcbiAgICBpblxuICAgIGxvb3AgdClcbjs7XG5cbmxldCBpdGVyX2R1cmFibHlfcmVwb3J0X2VuZCB0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIHQgPVxuICAgICAgbmV4dCB0XG4gICAgICA+Pj4gZnVuY3Rpb25cbiAgICAgIHwgTmlsIC0+IEl2YXIuZmlsbF9leG4gcmVzdWx0ICgpXG4gICAgICB8IENvbnMgKHgsIHQpIC0+XG4gICAgICAgICgqIFdlIGltbWVkaWF0ZWx5IGNhbGwgW2xvb3BdLCB0aHVzIG1ha2luZyB0aGUgaXRlciBkdXJhYmxlLiAgQW55IGV4Y2VwdGlvbnNcbiAgICAgICAgICAgcmFpc2VkIGJ5IFtmXSB3aWxsIG5vdCBwcmV2ZW50IHRoZSBsb29wIGZyb20gY29udGludWluZywgYW5kIHdpbGwgZ28gdG8gdGhlXG4gICAgICAgICAgIG1vbml0b3Igb2Ygd2hvbWV2ZXIgY2FsbGVkIFtpdGVyX2R1cmFibHlfcmVwb3J0X2VuZF0uICopXG4gICAgICAgIGxvb3AgdDtcbiAgICAgICAgZiB4XG4gICAgaW5cbiAgICBsb29wIHQpXG47O1xuXG5sZXQgaXRlcl9kdXJhYmx5IHQgfmYgPSBkb24ndF93YWl0X2ZvciAoaXRlcl9kdXJhYmx5X3JlcG9ydF9lbmQgdCB+ZilcblxubGV0IG9mX2Z1biBmID1cbiAgdW5mb2xkICgpIH5mOihmdW4gKCkgLT5cbiAgICBsZXQlbWFwIGEgPSBmICgpIGluXG4gICAgU29tZSAoYSwgKCkpKVxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG50eXBlICgnYSwgJ3Blcm1pc3Npb24pIHQgPSAoJ2EsICdwZXJtaXNzaW9uKSBUeXBlcy5CdmFyLnRcblxudHlwZSAnYSByZXByID0gJ2EgVHlwZXMuQnZhci5yZXByID1cbiAgeyBtdXRhYmxlIGhhc19hbnlfd2FpdGVycyA6IGJvb2xcbiAgOyBtdXRhYmxlIGl2YXIgOiAnYSBJdmFyLnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBfIHQgPVxuICBsZXQgcmVwciA9IFR5cGVzLkJ2YXIudG9fcmVwciB0IGluXG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSByZXByIFslc2V4cF9vZjogXyByZXByXSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgcmVwciBmIGluXG4gICAgRmllbGRzX29mX3JlcHIuaXRlclxuICAgICAgfmhhc19hbnlfd2FpdGVyczpcbiAgICAgICAgKGNoZWNrIChmdW4gaGFzX2FueV93YWl0ZXJzIC0+XG4gICAgICAgICAgIGlmIEl2YXIuaGFzX2hhbmRsZXJzIHJlcHIuaXZhciB0aGVuIGFzc2VydCBoYXNfYW55X3dhaXRlcnMpKVxuICAgICAgfml2YXI6XG4gICAgICAgIChjaGVjayAoZnVuIGl2YXIgLT5cbiAgICAgICAgICAgSXZhci5pbnZhcmlhbnQgaW52YXJpYW50X2EgaXZhcjtcbiAgICAgICAgICAgYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKSkpXG47O1xuXG5sZXQgc2V4cF9vZl90IF8gXyB0ID1cbiAgbGV0IHsgaGFzX2FueV93YWl0ZXJzOyBpdmFyID0gXyB9ID0gVHlwZXMuQnZhci50b19yZXByIHQgaW5cbiAgKCogV2UgZG9uJ3Qgc2hvdyBbaXZhcl0gYmVjYXVzZSBpdCdzIGFsd2F5cyBlbXB0eS4gKilcbiAgWyVtZXNzYWdlIChoYXNfYW55X3dhaXRlcnMgOiBib29sKV1cbjs7XG5cbmluY2x1ZGUgU2NoZWR1bGVyMS5CdmFyXG5cbmxldCBicm9hZGNhc3QgdCBhID1cbiAgbGV0IHJlcHIgPSBUeXBlcy5CdmFyLnRvX3JlcHIgdCBpblxuICBpZiByZXByLmhhc19hbnlfd2FpdGVyc1xuICB0aGVuIChcbiAgICByZXByLmhhc19hbnlfd2FpdGVycyA8LSBmYWxzZTtcbiAgICBJdmFyLmZpbGxfZXhuIHJlcHIuaXZhciBhO1xuICAgIHJlcHIuaXZhciA8LSBJdmFyLmNyZWF0ZSAoKSlcbjs7XG5cbmxldCB3YWl0IHQgPVxuICBsZXQgcmVwciA9IFR5cGVzLkJ2YXIudG9fcmVwciB0IGluXG4gIHJlcHIuaGFzX2FueV93YWl0ZXJzIDwtIHRydWU7XG4gIEl2YXIucmVhZCByZXByLml2YXJcbjs7XG5cbmxldCBoYXNfYW55X3dhaXRlcnMgdCA9XG4gIGxldCByZXByID0gVHlwZXMuQnZhci50b19yZXByIHQgaW5cbiAgcmVwci5oYXNfYW55X3dhaXRlcnNcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4hIERlZmVycmVkX3N0ZFxuXG5sZXQgZGVidWcgPSBEZWJ1Zy5jbG9ja1xuXG5tb2R1bGUgQWxhcm0gPSBUaW1pbmdfd2hlZWwuQWxhcm1cbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjFcblxubGV0IHVwb24gPSBEZWZlcnJlZC51cG9uXG5sZXQgY2hvb3NlID0gRGVmZXJyZWQuY2hvb3NlXG5sZXQgY2hvaWNlID0gRGVmZXJyZWQuY2hvaWNlXG5sZXQgKCA+Pj4gKSA9IHVwb25cblxubW9kdWxlIFQxID0gc3RydWN0XG4gIGluY2x1ZGUgU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLlQxXG5cbiAgKCogV2UgZG9uJ3QgaW5jbHVkZSB0aGUgW2lkXSBpbiB0aGUgc2V4cCBiZWNhdXNlIHRoZSB1c2VyIChyaWdodGx5KSBjYW4ndCBjb250cm9sIGl0LCBzb1xuICAgICBpdCdzIGhhcmQgdG8gbWFrZSBpdCBkZXRlcm1pbmlzdGljIGluIHRlc3RzLiAqKVxuICBsZXQgc2V4cF9vZl90XG4gICAgX1xuICAgIHsgaWQgPSBfXG4gICAgOyBhZHZhbmNlX2Vycm9ycyA9IF9cbiAgICA7IGFtX2FkdmFuY2luZyA9IF9cbiAgICA7IGV2ZW50c1xuICAgIDsgZmlyZWRfZXZlbnRzID0gX1xuICAgIDsgaGFuZGxlX2ZpcmVkID0gX1xuICAgIDsgaXNfd2FsbF9jbG9ja1xuICAgIDsgbW9zdF9yZWNlbnRseV9maXJlZCA9IF9cbiAgICA7IHNjaGVkdWxlciA9IF9cbiAgICB9XG4gICAgPVxuICAgIGlmIGlzX3dhbGxfY2xvY2tcbiAgICB0aGVuIFslbWVzc2FnZSBcIjx3YWxsX2Nsb2NrPlwiXVxuICAgIGVsc2VcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICAoaXNfd2FsbF9jbG9jayA6IGJvb2wpXG4gICAgICAgICAgKCogV2UgZG9uJ3QgZGlzcGxheSB0aGUgW0pvYi50XXMgaW4gW2V2ZW50c10gYmVjYXVzZSB0aG9zZSBhcmVcbiAgICAgICAgICAgICBwb29sIHBvaW50ZXJzLCB3aGljaCBhcmUgdW5pbmZvcm1hdGl2ZS4gKilcbiAgICAgICAgICAoZXZlbnRzIDogXyBUaW1pbmdfd2hlZWwudCldXG4gIDs7XG5lbmRcblxub3BlbiBUMVxuXG5tb2R1bGUgUmVhZF93cml0ZSA9IHN0cnVjdFxuICB0eXBlIHQgPSByZWFkX3dyaXRlIFQxLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG4gIGxldCBpbnZhcmlhbnRfd2l0aF9qb2JzID0gaW52YXJpYW50X3dpdGhfam9ic1xuZW5kXG5cbnR5cGUgdCA9IHJlYWQgVDEudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG5sZXQgaW52YXJpYW50X3dpdGhfam9icyA9IGludmFyaWFudF93aXRoX2pvYnNcbmxldCByZWFkX29ubHkgKHQgOiBbPiByZWFkIF0gVDEudCkgPSAodCA6PiB0KVxubGV0IGNyZWF0ZSA9IFNjaGVkdWxlci5jcmVhdGVfdGltZV9zb3VyY2VcbmxldCB3YWxsX2Nsb2NrID0gU2NoZWR1bGVyLndhbGxfY2xvY2tcbmxldCBhbGFybV9wcmVjaXNpb24gdCA9IFRpbWluZ193aGVlbC5hbGFybV9wcmVjaXNpb24gdC5ldmVudHNcbmxldCBpc193YWxsX2Nsb2NrIHQgPSB0LmlzX3dhbGxfY2xvY2tcbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0IHQgPSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdCB0LmV2ZW50c1xubGV0IHRpbWluZ193aGVlbF9ub3cgdCA9IFRpbWluZ193aGVlbC5ub3cgdC5ldmVudHNcbmxldCBpZCB0ID0gdC5pZFxuXG5tb2R1bGUgSWQgPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuSWRcblxubGV0IG5vdyB0ID1cbiAgaWYgdC5pc193YWxsX2Nsb2NrXG4gIHRoZW5cbiAgICAoKiBGb3IgdGhlIHdhbGwtY2xvY2sgdGltZS1zb3VyY2UsIHdlIHVzZSBbVGltZV9ucy5ub3cgKCldIHJhdGhlciB0aGFuXG4gICAgICAgW1RpbWluZ193aGVlbC5ub3cgdC5ldmVudHNdLiAgVGhlIGxhdHRlciBpcyBvbmx5IHVwZGF0ZWQgYXQgdGhlIHN0YXJ0IG9mIGVhY2hcbiAgICAgICBjeWNsZS4gIFRoZXJlIGNhbiBiZSBzdWJzdGFudGlhbCBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHR3byB3aGVuIHBlb3BsZSBkbyBsb25nXG4gICAgICAgcnVubmluZyBjb21wdXRhdGlvbnMgb3IgbWl4IGJsb2NraW5nIGNvZGUgd2l0aCBhc3luYy4gIEFuZCBodW1hbnMgZXhwZWN0IHRoYXRcbiAgICAgICB3YWxsLWNsb2NrIHRpbWUgaXMgYmFzZWQgb24gW1RpbWUubm93XSwgbm90IHNvbWUgYXJ0aWZhY3Qgb2YgYXN5bmNcbiAgICAgICBpbXBsZW1lbnRhdGlvbi4gKilcbiAgICBUaW1lX25zLm5vdyAoKVxuICBlbHNlIHRpbWluZ193aGVlbF9ub3cgdFxuOztcblxuKCogV2UgcHJlYWxsb2NhdGUgW3NlbmRfZXhuXSB0byBhdm9pZCBhbGxvY2F0aW5nIGl0IG9uIGVhY2ggY2FsbCB0byBbYWR2YW5jZV9jbG9ja10uICopXG5sZXQgc2VuZF9leG4gPSBTb21lIE1vbml0b3Iuc2VuZF9leG5cbmxldCBhZHZhbmNlX2RpcmVjdGx5IHQgfnRvXyA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlMC5hZHZhbmNlX2Nsb2NrIHQgfnRvXyB+c2VuZF9leG5cblxubGV0IGFkdmFuY2VfZGlyZWN0bHlfc3RvcF9vbl9uZXh0X2FsYXJtIHQgfnRvXyA9XG4gIFN5bmNocm9ub3VzX3RpbWVfc291cmNlMC5hZHZhbmNlX2Nsb2NrX3N0b3BfYXRfbmV4dF9hbGFybSB0IH50b18gfnNlbmRfZXhuXG47O1xuXG5sZXQgYWR2YW5jZV9kaXJlY3RseV9ieSB0IGJ5ID0gYWR2YW5jZV9kaXJlY3RseSB0IH50b186KFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBieSlcbmxldCBhZHZhbmNlID0gYWR2YW5jZV9kaXJlY3RseVxubGV0IGFkdmFuY2VfYnkgPSBhZHZhbmNlX2RpcmVjdGx5X2J5XG5sZXQgZmlyZV9wYXN0X2FsYXJtcyB0ID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLmZpcmVfcGFzdF9hbGFybXMgdCB+c2VuZF9leG5cbmxldCB5aWVsZCB0ID0gQnZhci53YWl0IChTY2hlZHVsZXIueWllbGQgdC5zY2hlZHVsZXIpXG5sZXQgY2FuX3J1bl9hX2pvYiB0ID0gU2NoZWR1bGVyLm51bV9wZW5kaW5nX2pvYnMgdCA+IDAgfHwgQnZhci5oYXNfYW55X3dhaXRlcnMgdC55aWVsZFxuXG5tb2R1bGUgRWFnZXJfZGVmZXJyZWQgPSBzdHJ1Y3RcbiAgbGV0IGJpbmRfdW5pdCB0IH5mID1cbiAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIHRcbiAgICB0aGVuIGYgKClcbiAgICBlbHNlIChcbiAgICAgIGxldCViaW5kICgpID0gdCBpblxuICAgICAgZiAoKSlcbiAgOztcblxuICBsZXQgbWFwIHQgfmYgPVxuICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgdFxuICAgIHRoZW4gcmV0dXJuIChmIChEZWZlcnJlZC52YWx1ZV9leG4gdCkpXG4gICAgZWxzZSBEZWZlcnJlZC5tYXAgdCB+ZlxuICA7O1xuZW5kXG5cbmxldCBhZHZhbmNlX2J5X2FsYXJtcyA/d2FpdF9mb3IgdCB+dG9fID1cbiAgbGV0IHJ1bl9xdWV1ZWRfYWxhcm1zICgpID1cbiAgICAoKiBFdmVyeSB0aW1lIHdlIHdhbnQgdG8gcnVuIHF1ZXVlZCBhbGFybXMgd2UgbmVlZCB0byB5aWVsZCBjb250cm9sIGJhY2sgdG8gdGhlXG4gICAgICAgW0FzeW5jLlNjaGVkdWxlcl0gYW5kIFt3YWl0X2Zvcl0gYW55IGxvZ2ljIHRoYXQgaXMgc3VwcG9zZWQgdG8gZmluaXNoIGF0IHRoaXMgdGltZVxuICAgICAgIGJlZm9yZSBhZHZhbmNpbmcuICBJZiBubyBbd2FpdF9mb3JdIGxvZ2ljIGlzIHNwZWNpZmllZCB3ZSBjYW4gc2ltcGx5IHlpZWxkIGNvbnRyb2xcbiAgICAgICBieSBpbnZva2luZyBbeWllbGQgdF0sIHdoaWNoIGVucXVldWVzIGFub3RoZXIgam9iIGF0IHRoZSBlbmQgb2YgdGhlIHNjaGVkdWxlciBqb2JcbiAgICAgICBxdWV1ZSBzbyBhbGFybSBqb2JzIGhhdmUgdGhlIG9wcG9ydHVuaXR5IHRvIHJ1biBiZWZvcmUgd2UgYWR2YW5jZS4gKilcbiAgICBtYXRjaCB3YWl0X2ZvciB3aXRoXG4gICAgfCBOb25lIC0+IHlpZWxkIHRcbiAgICB8IFNvbWUgZiAtPiBmICgpXG4gIGluXG4gIGxldCBvbmVfc3RlcCAoKSA9XG4gICAgaWYgU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLmFueV9maXJlZF9ldmVudHNfdG9fcnVuIHRcbiAgICB0aGVuIG5vdyB0LCBgY29udGludWVcbiAgICBlbHNlIHRvXywgYGNoZWNrX3RpbWVcbiAgaW5cbiAgbGV0IHJlYyB3YWxrX2FsYXJtcyAoKSA9XG4gICAgbGV0IGFkdmFuY2VfdG8sIG5leHQgPSBvbmVfc3RlcCAoKSBpblxuICAgIGFkdmFuY2VfZGlyZWN0bHlfc3RvcF9vbl9uZXh0X2FsYXJtIHQgfnRvXzphZHZhbmNlX3RvO1xuICAgIGZpcmVfcGFzdF9hbGFybXMgdDtcbiAgICBFYWdlcl9kZWZlcnJlZC5iaW5kX3VuaXQgKHJ1bl9xdWV1ZWRfYWxhcm1zICgpKSB+ZjooZnVuICgpIC0+XG4gICAgICBtYXRjaCBuZXh0IHdpdGhcbiAgICAgIHwgYGNoZWNrX3RpbWUgLT5cbiAgICAgICAgaWYgVGltZV9ucy4oIDwgKSAodGltaW5nX3doZWVsX25vdyB0KSB0b18gdGhlbiB3YWxrX2FsYXJtcyAoKSBlbHNlIHJldHVybiAoKVxuICAgICAgfCBgY29udGludWUgLT4gd2Fsa19hbGFybXMgKCkpXG4gIGluXG4gICgqIFRoaXMgZmlyc3QgW3J1bl9xdWV1ZWRfYWxhcm1zXSBjYWxsIGFsbG93cyBbQ2xvY2tfbnMuZXZlcnldIHRoZSBvcHBvcnR1bml0eSB0byBydW5cbiAgICAgaXRzIGNvbnRpbnVhdGlvbiBkZWZlcnJlZHMgc28gdGhhdCB0aGV5IGNhbiByZXNjaGVkdWxlIGFsYXJtcy4gIFRoaXMgaXMgcGFydGljdWxhcmx5XG4gICAgIHVzZWZ1bCBpbiBvdXIgXCJhZHZhbmNlIGhpdHMgaW50ZXJtZWRpYXRlIGFsYXJtc1wiIHVuaXQgdGVzdCBiZWxvdywgYnV0IGxpa2VseSB1c2VmdWxcbiAgICAgaW4gb3RoZXIgY2FzZXMgd2hlcmUgW2V2ZXJ5XSBpcyBzeW5jaHJvbm91c2x5IGZvbGxvd2VkIGJ5IFthZHZhbmNlXS4gKilcbiAgbGV0JWJpbmQgKCkgPSBydW5fcXVldWVkX2FsYXJtcyAoKSBpblxuICB3YWxrX2FsYXJtcyAoKVxuOztcblxubGV0IGFkdmFuY2VfYnlfbWF4X2FsYXJtc19pbl9lYWNoX3RpbWluZ193aGVlbF9pbnRlcnZhbCA/d2FpdF9mb3IgdCB+dG9fID1cbiAgbGV0IHJ1bl9xdWV1ZWRfYWxhcm1zICgpID1cbiAgICAoKiBFdmVyeSB0aW1lIHdlIHdhbnQgdG8gcnVuIHF1ZXVlZCBhbGFybXMgd2UgbmVlZCB0byB5aWVsZCBjb250cm9sIGJhY2sgdG8gdGhlXG4gICAgICAgW0FzeW5jLlNjaGVkdWxlcl0gYW5kIFt3YWl0X2Zvcl0gYW55IGxvZ2ljIHRoYXQgaXMgc3VwcG9zZWQgdG8gZmluaXNoIGF0IHRoaXMgdGltZVxuICAgICAgIGJlZm9yZSBhZHZhbmNpbmcuICBJZiBubyBbd2FpdF9mb3JdIGxvZ2ljIGlzIHNwZWNpZmllZCB3ZSBjYW4gc2ltcGx5IHlpZWxkIGNvbnRyb2xcbiAgICAgICBieSBpbnZva2luZyBbeWllbGQgdF0sIHdoaWNoIGVucXVldWVzIGFub3RoZXIgam9iIGF0IHRoZSBlbmQgb2YgdGhlIHNjaGVkdWxlciBqb2JcbiAgICAgICBxdWV1ZSBzbyBhbGFybSBqb2JzIGhhdmUgdGhlIG9wcG9ydHVuaXR5IHRvIHJ1biBiZWZvcmUgd2UgYWR2YW5jZS4gKilcbiAgICBtYXRjaCB3YWl0X2ZvciB3aXRoXG4gICAgfCBOb25lIC0+IHlpZWxkIHRcbiAgICB8IFNvbWUgZiAtPiBmICgpXG4gIGluXG4gIGxldCBmaW5pc2ggKCkgPVxuICAgIGFkdmFuY2VfZGlyZWN0bHkgdCB+dG9fO1xuICAgIGZpcmVfcGFzdF9hbGFybXMgdDtcbiAgICAoKiBzbyB0aGF0IGFsYXJtcyBzY2hlZHVsZWQgYXQgb3IgYmVmb3JlIFt0b19dIGZpcmUgKilcbiAgICBydW5fcXVldWVkX2FsYXJtcyAoKVxuICBpblxuICBsZXQgcmVjIHdhbGtfYWxhcm1zICgpID1cbiAgICBtYXRjaCBuZXh0X2FsYXJtX2ZpcmVzX2F0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiBmaW5pc2ggKClcbiAgICB8IFNvbWUgbmV4dF9hbGFybV9maXJlc19hdCAtPlxuICAgICAgaWYgVGltZV9ucy4oID49ICkgbmV4dF9hbGFybV9maXJlc19hdCB0b19cbiAgICAgIHRoZW4gZmluaXNoICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgYWR2YW5jZV9kaXJlY3RseSB0IH50b186KFRpbWluZ193aGVlbC5tYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHQuZXZlbnRzKTtcbiAgICAgICAgZmlyZV9wYXN0X2FsYXJtcyB0O1xuICAgICAgICBsZXQgcXVldWVkX2FsYXJtc19yYW4gPSBydW5fcXVldWVkX2FsYXJtcyAoKSBpblxuICAgICAgICBFYWdlcl9kZWZlcnJlZC5iaW5kX3VuaXQgcXVldWVkX2FsYXJtc19yYW4gfmY6d2Fsa19hbGFybXMpXG4gIGluXG4gIGZpcmVfcGFzdF9hbGFybXMgdDtcbiAgKCogVGhpcyBmaXJzdCBbcnVuX3F1ZXVlZF9hbGFybXNdIGNhbGwgYWxsb3dzIFtDbG9ja19ucy5ldmVyeV0gdGhlIG9wcG9ydHVuaXR5IHRvIHJ1blxuICAgICBpdHMgY29udGludWF0aW9uIGRlZmVycmVkcyBzbyB0aGF0IHRoZXkgY2FuIHJlc2NoZWR1bGUgYWxhcm1zLiAgVGhpcyBpcyBwYXJ0aWN1bGFybHlcbiAgICAgdXNlZnVsIGluIG91ciBcImFkdmFuY2UgaGl0cyBpbnRlcm1lZGlhdGUgYWxhcm1zXCIgdW5pdCB0ZXN0IGJlbG93LCBidXQgbGlrZWx5IHVzZWZ1bFxuICAgICBpbiBvdGhlciBjYXNlcyB3aGVyZSBbZXZlcnldIGlzIHN5bmNocm9ub3VzbHkgZm9sbG93ZWQgYnkgW2FkdmFuY2VdLiAqKVxuICBsZXQlYmluZCAoKSA9IHJ1bl9xdWV1ZWRfYWxhcm1zICgpIGluXG4gIHdhbGtfYWxhcm1zICgpXG47O1xuXG5sZXQgYWR2YW5jZV9ieV9hbGFybXNfYnkgP3dhaXRfZm9yIHQgYnkgPVxuICBhZHZhbmNlX2J5X2FsYXJtcyA/d2FpdF9mb3IgdCB+dG9fOihUaW1lX25zLmFmdGVyIChub3cgdCkgYnkpXG47O1xuXG5sZXQgc3Bhbl90b190aW1lIHQgc3BhbiA9IFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBzcGFuXG5cbmxldCBzY2hlZHVsZV9qb2IgdCB+YXQgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgbGV0IGFsYXJtID1cbiAgICBUaW1pbmdfd2hlZWwuYWRkXG4gICAgICB0LmV2ZW50c1xuICAgICAgfmF0XG4gICAgICAoSm9iX29yX2V2ZW50Lm9mX2pvYiAoU2NoZWR1bGVyLmNyZWF0ZV9qb2IgdC5zY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgZiBhKSlcbiAgaW5cbiAgKG1hdGNoIHQuc2NoZWR1bGVyLmV2ZW50X2FkZGVkX2hvb2sgd2l0aFxuICAgfCBOb25lIC0+ICgpXG4gICB8IFNvbWUgZiAtPiBmIGF0KTtcbiAgYWxhcm1cbjs7XG5cbmxldCBydW5fYXRfaW50ZXJuYWwgdCB0aW1lIGYgYSA9XG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHQuc2NoZWR1bGVyIGluXG4gIGlmIFRpbWVfbnMuKCA+ICkgdGltZSAoVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50cylcbiAgdGhlbiBzY2hlZHVsZV9qb2IgdCB+YXQ6dGltZSBleGVjdXRpb25fY29udGV4dCBmIGFcbiAgZWxzZSAoXG4gICAgU2NoZWR1bGVyLmVucXVldWUgdC5zY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgZiBhO1xuICAgIEFsYXJtLm51bGwgKCkpXG47O1xuXG5sZXQgcnVuX2F0IHQgdGltZSBmIGEgPSBpZ25vcmUgKHJ1bl9hdF9pbnRlcm5hbCB0IHRpbWUgZiBhIDogXyBBbGFybS50KVxubGV0IHJ1bl9hZnRlciB0IHNwYW4gZiBhID0gcnVuX2F0IHQgKHNwYW5fdG9fdGltZSB0IHNwYW4pIGYgYVxuXG5sZXQgYXQgPVxuICBsZXQgZmlsbCByZXN1bHQgPSBJdmFyLmZpbGxfZXhuIHJlc3VsdCAoKSBpblxuICBmdW4gdCB0aW1lIC0+XG4gICAgaWYgVGltZV9ucy4oIDw9ICkgdGltZSAoVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50cylcbiAgICB0aGVuIHJldHVybiAoKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlc3VsdCA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgICBpZ25vcmUgKHJ1bl9hdF9pbnRlcm5hbCB0IHRpbWUgZmlsbCByZXN1bHQgOiBfIEFsYXJtLnQpO1xuICAgICAgSXZhci5yZWFkIHJlc3VsdClcbjs7XG5cbmxldCBhZnRlciB0IHNwYW4gPSBhdCB0IChzcGFuX3RvX3RpbWUgdCBzcGFuKVxuXG5sZXQgcmVtb3ZlX2FsYXJtIHQgYWxhcm0gOiB1bml0ID1cbiAgbGV0IGpvYl9vcl9ldmVudCA9IEFsYXJtLnZhbHVlIHQuZXZlbnRzIGFsYXJtIGluXG4gIChsZXQgb3BlbiBKb2Jfb3JfZXZlbnQuTWF0Y2ggaW5cbiAgIGxldCAoSyBrKSA9IGtpbmQgam9iX29yX2V2ZW50IGluXG4gICBtYXRjaCBrLCBwcm9qZWN0IGsgam9iX29yX2V2ZW50IHdpdGhcbiAgIHwgSm9iLCBqb2IgLT4gU2NoZWR1bGVyLmZyZWVfam9iIHQuc2NoZWR1bGVyIGpvYlxuICAgfCBFdmVudCwgXyAtPlxuICAgICAoKiBUaGlzIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgW2FsYXJtXSBvbmx5IGV2ZXIgY29tZXMgZnJvbSBbRXZlbnQuYWxhcm1dIHdoaWNoIG9ubHlcbiAgICAgICAgZXZlciBnZXRzIHBvcHVsYXRlZCBieSBhIGNhbGwgdG8gW3NjaGVkdWxlX2pvYl0uICopXG4gICAgIGFzc2VydCBmYWxzZSk7XG4gIFRpbWluZ193aGVlbC5yZW1vdmUgdC5ldmVudHMgYWxhcm1cbjs7XG5cbmxldCByZW1vdmVfYWxhcm1faWZfc2NoZWR1bGVkIHQgYWxhcm0gPVxuICBpZiBUaW1pbmdfd2hlZWwubWVtIHQuZXZlbnRzIGFsYXJtIHRoZW4gcmVtb3ZlX2FsYXJtIHQgYWxhcm1cbjs7XG5cbm1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICBtb2R1bGUgRmlyZWQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgfCBBYm9ydGVkIG9mICdhXG4gICAgICB8IEhhcHBlbmVkIG9mICdoXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICB7IG11dGFibGUgYWxhcm0gOiBKb2Jfb3JfZXZlbnQudCBBbGFybS50XG4gICAgOyBtdXRhYmxlIGZpcmUgOiB1bml0IC0+IHVuaXRcbiAgICA7ICgqIEFzIGxvbmcgYXMgW0l2YXIuaXNfZW1wdHkgZmlyZWRdLCB3ZSBoYXZlIG5vdCB5ZXQgY29tbWl0dGVkIHRvIHdoZXRoZXIgdGhlIGV2ZW50XG4gICAgICAgICB3aWxsIGhhcHBlbiBvciBiZSBhYm9ydGVkLiAgV2hlbiBbSXZhci5pc19lbXB0eSBmaXJlZF0sIHRoZSBhbGFybSBtYXkgb3IgbWF5IG5vdFxuICAgICAgICAgYmUgaW4gdGhlIHRpbWluZyB3aGVlbCAtLSBpZiBpdCBpc24ndCwgdGhlbiB0aGVyZSdzIGEgam9iIGluIEFzeW5jJ3Mgam9iIHF1ZXVlXG4gICAgICAgICB0aGF0IHdpbGwgZmlyZSB0aGUgZXZlbnQsIHVubGVzcyBpdCBpcyBhYm9ydGVkIGJlZm9yZSB0aGF0IGpvYiBjYW4gcnVuLiAqKVxuICAgICAgZmlyZWQgOiAoJ2EsICdoKSBGaXJlZC50IEl2YXIudFxuICAgIDsgKCogW251bV9maXJlc190b19za2lwXSBpcyB1c2VkIHRvIHJlc2NoZWR1bGUgZXZlbnRzIHRoYXQgaGF2ZSBmaXJlZCBhbmQgZW50ZXJlZCB0aGVcbiAgICAgICAgIEFzeW5jIGpvYiBxdWV1ZSwgYnV0IGhhdmUgbm90IHlldCBydW4uICBUaG9zZSBqb2JzIG9ubHkgcnVuIGlmIFtudW1fZmlyZXNfdG9fc2tpcFxuICAgICAgICAgPSAwXSwgYW5kIG90aGVyd2lzZSBqdXN0IGRlY3JlbWVudCBpdC4gIFNvLCB0byByZXNjaGVkdWxlIGFuIGV2ZW50IGluIHN1Y2ggYVxuICAgICAgICAgc3RhdGUsIHdlIGluY3JlbWVudCBbbnVtX2ZpcmVzX3RvX3NraXBdIGFuZCBhZGQgYSBuZXcgYWxhcm0gdG8gdGhlIHRpbWluZ1xuICAgICAgICAgd2hlZWwuICopXG4gICAgICBtdXRhYmxlIG51bV9maXJlc190b19za2lwIDogaW50XG4gICAgOyAoKiBbc2NoZWR1bGVkX2F0XSBpcyB0aGUgdGltZSBhdCB3aGljaCBbdF0gaGFzIG1vc3QgcmVjZW50bHkgYmVlbiBzY2hlZHVsZWQgdG8gZmlyZS5cbiAgICAgICAgIFdoaWxlIFt0LmFsYXJtXSBpcyBzdGlsbCBpbiB0aGUgdGltaW5nIHdoZWVsLCB0aGlzIGlzIHRoZSBzYW1lIGFzIFtBbGFybS5hdFxuICAgICAgICAgdC5hbGFybV0uICopXG4gICAgICBtdXRhYmxlIHNjaGVkdWxlZF9hdCA6IFRpbWVfbnMudFxuICAgIDsgdGltZV9zb3VyY2UgOiBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxuICB0eXBlIHRfdW5pdCA9ICh1bml0LCB1bml0KSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGZpcmVkIHQgPSBJdmFyLnJlYWQgdC5maXJlZFxuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgaW52YXJpYW50X2ggdCA9XG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiAoXywgXykgdF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGV2ZW50cyA9IHQudGltZV9zb3VyY2UuZXZlbnRzIGluXG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5hbGFybTpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBhbGFybSAtPlxuICAgICAgICAgICAgIGlmIEl2YXIuaXNfZnVsbCB0LmZpcmVkXG4gICAgICAgICAgICAgdGhlbiBhc3NlcnQgKG5vdCAoVGltaW5nX3doZWVsLm1lbSBldmVudHMgYWxhcm0pKVxuICAgICAgICAgICAgIGVsc2UgaWYgVGltaW5nX3doZWVsLm1lbSBldmVudHMgYWxhcm1cbiAgICAgICAgICAgICB0aGVuIGFzc2VydCAoSm9iX29yX2V2ZW50LmlzX2pvYiAoQWxhcm0udmFsdWUgZXZlbnRzIGFsYXJtKSkpKVxuICAgICAgICB+ZmlyZTppZ25vcmVcbiAgICAgICAgfmZpcmVkOlxuICAgICAgICAgIChjaGVjayAoZnVuIChmaXJlZCA6IF8gRmlyZWQudCBJdmFyLnQpIC0+XG4gICAgICAgICAgICAgbWF0Y2ggRGVmZXJyZWQucGVlayAoSXZhci5yZWFkIGZpcmVkKSB3aXRoXG4gICAgICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgICAgfCBTb21lIChBYm9ydGVkIGEpIC0+IGludmFyaWFudF9hIGFcbiAgICAgICAgICAgICB8IFNvbWUgKEhhcHBlbmVkIGgpIC0+IGludmFyaWFudF9oIGgpKVxuICAgICAgICB+bnVtX2ZpcmVzX3RvX3NraXA6XG4gICAgICAgICAgKGNoZWNrIChmdW4gbnVtX2ZpcmVzX3RvX3NraXAgLT4gYXNzZXJ0IChudW1fZmlyZXNfdG9fc2tpcCA+PSAwKSkpXG4gICAgICAgIH5zY2hlZHVsZWRfYXQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gc2NoZWR1bGVkX2F0IC0+XG4gICAgICAgICAgICAgaWYgVGltaW5nX3doZWVsLm1lbSBldmVudHMgdC5hbGFybVxuICAgICAgICAgICAgIHRoZW4gWyV0ZXN0X3Jlc3VsdDogVGltZV9ucy50XSBzY2hlZHVsZWRfYXQgfmV4cGVjdDooQWxhcm0uYXQgZXZlbnRzIHQuYWxhcm0pKSlcbiAgICAgICAgfnRpbWVfc291cmNlOmlnbm9yZSlcbiAgOztcblxuICBtb2R1bGUgU3RhdHVzID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgIHwgQWJvcnRlZCBvZiAnYVxuICAgICAgfCBIYXBwZW5lZCBvZiAnaFxuICAgICAgfCBTY2hlZHVsZWRfYXQgb2YgVGltZV9ucy50XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbGV0IHN0YXR1cyB0IDogXyBTdGF0dXMudCA9XG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayAoSXZhci5yZWFkIHQuZmlyZWQpIHdpdGhcbiAgICB8IE5vbmUgLT4gU2NoZWR1bGVkX2F0IHQuc2NoZWR1bGVkX2F0XG4gICAgfCBTb21lIChBYm9ydGVkIGEpIC0+IEFib3J0ZWQgYVxuICAgIHwgU29tZSAoSGFwcGVuZWQgaCkgLT4gSGFwcGVuZWQgaFxuICA7O1xuXG4gIG1vZHVsZSBBYm9ydF9yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgfCBPa1xuICAgICAgfCBQcmV2aW91c2x5X2Fib3J0ZWQgb2YgJ2FcbiAgICAgIHwgUHJldmlvdXNseV9oYXBwZW5lZCBvZiAnaFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCBhYm9ydCB0IGEgOiBfIEFib3J0X3Jlc3VsdC50ID1cbiAgICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcIlRpbWVfc291cmNlLkV2ZW50LmFib3J0XCIgdCBbJXNleHBfb2Y6IChfLCBfKSB0XTtcbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChmaXJlZCB0KSB3aXRoXG4gICAgfCBTb21lIChBYm9ydGVkIGEpIC0+IFByZXZpb3VzbHlfYWJvcnRlZCBhXG4gICAgfCBTb21lIChIYXBwZW5lZCBoKSAtPiBQcmV2aW91c2x5X2hhcHBlbmVkIGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIEl2YXIuZmlsbF9leG4gdC5maXJlZCAoQWJvcnRlZCBhKTtcbiAgICAgIHJlbW92ZV9hbGFybV9pZl9zY2hlZHVsZWQgdC50aW1lX3NvdXJjZSB0LmFsYXJtO1xuICAgICAgT2tcbiAgOztcblxuICBsZXQgYWJvcnRfZXhuIHQgYSA9XG4gICAgbWF0Y2ggYWJvcnQgdCBhIHdpdGhcbiAgICB8IE9rIC0+ICgpXG4gICAgfCBQcmV2aW91c2x5X2hhcHBlbmVkIF8gLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiQ2xvY2suRXZlbnQuYWJvcnRfZXhuIGZhaWxlZCB0byBhYm9ydCBldmVudCB0aGF0IHByZXZpb3VzbHkgaGFwcGVuZWRcIl1cbiAgICB8IFByZXZpb3VzbHlfYWJvcnRlZCBfIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkNsb2NrLkV2ZW50LmFib3J0X2V4biBmYWlsZWQgdG8gYWJvcnQgZXZlbnQgdGhhdCBwcmV2aW91c2x5IGFib3J0ZWRcIl1cbiAgOztcblxuICBsZXQgYWJvcnRfaWZfcG9zc2libGUgdCBhID0gaWdub3JlIChhYm9ydCB0IGEgOiBfIEFib3J0X3Jlc3VsdC50KVxuICBsZXQgc2NoZWR1bGUgdCA9IHQuYWxhcm0gPC0gcnVuX2F0X2ludGVybmFsIHQudGltZV9zb3VyY2UgdC5zY2hlZHVsZWRfYXQgdC5maXJlICgpXG5cbiAgbW9kdWxlIFJlc2NoZWR1bGVfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgIHwgT2tcbiAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkIG9mICdhXG4gICAgICB8IFByZXZpb3VzbHlfaGFwcGVuZWQgb2YgJ2hcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgcmVzY2hlZHVsZV9hdCB0IGF0IDogXyBSZXNjaGVkdWxlX3Jlc3VsdC50ID1cbiAgICBpZiBkZWJ1Z1xuICAgIHRoZW5cbiAgICAgIERlYnVnLmxvZyBcIlRpbWVfc291cmNlLkV2ZW50LnJlc2NoZWR1bGVfYXRcIiAodCwgYXQpIFslc2V4cF9vZjogKF8sIF8pIHQgKiBUaW1lX25zLnRdO1xuICAgIG1hdGNoIERlZmVycmVkLnBlZWsgKGZpcmVkIHQpIHdpdGhcbiAgICB8IFNvbWUgKEFib3J0ZWQgYSkgLT4gUHJldmlvdXNseV9hYm9ydGVkIGFcbiAgICB8IFNvbWUgKEhhcHBlbmVkIGgpIC0+IFByZXZpb3VzbHlfaGFwcGVuZWQgaFxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IGV2ZW50cyA9IHQudGltZV9zb3VyY2UuZXZlbnRzIGluXG4gICAgICBsZXQgaXNfaW5fdGltaW5nX3doZWVsID0gVGltaW5nX3doZWVsLm1lbSBldmVudHMgdC5hbGFybSBpblxuICAgICAgbGV0IGFtX3RyeWluZ190b19yZXNjaGVkdWxlX2luX3RoZV9mdXR1cmUgPVxuICAgICAgICBUaW1lX25zLiggPiApIGF0IChUaW1pbmdfd2hlZWwubm93IGV2ZW50cylcbiAgICAgIGluXG4gICAgICB0LnNjaGVkdWxlZF9hdCA8LSBhdDtcbiAgICAgIChtYXRjaCBhbV90cnlpbmdfdG9fcmVzY2hlZHVsZV9pbl90aGVfZnV0dXJlLCBpc19pbl90aW1pbmdfd2hlZWwgd2l0aFxuICAgICAgIHwgZmFsc2UsIGZhbHNlIC0+ICgpXG4gICAgICAgfCBmYWxzZSwgdHJ1ZSAtPlxuICAgICAgICAgdC50aW1lX3NvdXJjZS5oYW5kbGVfZmlyZWQgdC5hbGFybTtcbiAgICAgICAgIFRpbWluZ193aGVlbC5yZW1vdmUgZXZlbnRzIHQuYWxhcm1cbiAgICAgICB8IHRydWUsIGZhbHNlIC0+XG4gICAgICAgICB0Lm51bV9maXJlc190b19za2lwIDwtIHQubnVtX2ZpcmVzX3RvX3NraXAgKyAxO1xuICAgICAgICAgc2NoZWR1bGUgdFxuICAgICAgIHwgdHJ1ZSwgdHJ1ZSAtPiBUaW1pbmdfd2hlZWwucmVzY2hlZHVsZSBldmVudHMgdC5hbGFybSB+YXQpO1xuICAgICAgT2tcbiAgOztcblxuICBsZXQgcmVzY2hlZHVsZV9hZnRlciB0IHNwYW4gPSByZXNjaGVkdWxlX2F0IHQgKHNwYW5fdG9fdGltZSB0LnRpbWVfc291cmNlIHNwYW4pXG5cbiAgbGV0IHJ1bl9hdCB0aW1lX3NvdXJjZSBzY2hlZHVsZWRfYXQgZiB6ID1cbiAgICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcIlRpbWVfc291cmNlLkV2ZW50LnJ1bl9hdFwiIHNjaGVkdWxlZF9hdCBbJXNleHBfb2Y6IFRpbWVfbnMudF07XG4gICAgbGV0IHQgPVxuICAgICAgeyBhbGFybSA9IEFsYXJtLm51bGwgKClcbiAgICAgIDsgZmlyZSA9IGlnbm9yZSAoKiBzZXQgYmVsb3cgKilcbiAgICAgIDsgZmlyZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgOyBudW1fZmlyZXNfdG9fc2tpcCA9IDBcbiAgICAgIDsgc2NoZWR1bGVkX2F0XG4gICAgICA7IHRpbWVfc291cmNlID0gcmVhZF9vbmx5IHRpbWVfc291cmNlXG4gICAgICB9XG4gICAgaW5cbiAgICBsZXQgZmlyZSAoKSA9XG4gICAgICAoKiBbZmlyZV0gcnVucyBpbiBhbiBBc3luYyBqb2IuICBUaGUgZXZlbnQgbWF5IGhhdmUgYmVlbiBhYm9ydGVkIGFmdGVyIHRoZSBqb2JcbiAgICAgICAgIHdhcyBlbnF1ZXVlZCwgc28gW2ZpcmVdIG11c3QgY2hlY2sgW2ZpcmVkXS4gKilcbiAgICAgIGlmIEl2YXIuaXNfZW1wdHkgdC5maXJlZFxuICAgICAgdGhlblxuICAgICAgICBpZiB0Lm51bV9maXJlc190b19za2lwID4gMFxuICAgICAgICB0aGVuIHQubnVtX2ZpcmVzX3RvX3NraXAgPC0gdC5udW1fZmlyZXNfdG9fc2tpcCAtIDFcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGYgeiBpblxuICAgICAgICAgICgqIFtmIHpdIG1heSBoYXZlIGFib3J0ZWQgdGhlIGV2ZW50LCBzbyB3ZSBtdXN0IGNoZWNrIFtmaXJlZF0gYWdhaW4uICopXG4gICAgICAgICAgaWYgSXZhci5pc19lbXB0eSB0LmZpcmVkIHRoZW4gSXZhci5maWxsX2V4biB0LmZpcmVkIChIYXBwZW5lZCByZXN1bHQpKVxuICAgIGluXG4gICAgdC5maXJlIDwtIGZpcmU7XG4gICAgc2NoZWR1bGUgdDtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGF0IHRpbWVfc291cmNlIHRpbWUgPSBydW5fYXQgdGltZV9zb3VyY2UgdGltZSBpZ25vcmUgKClcblxuICBsZXQgcnVuX2FmdGVyIHRpbWVfc291cmNlIHNwYW4gZiBhID1cbiAgICBydW5fYXQgdGltZV9zb3VyY2UgKHNwYW5fdG9fdGltZSB0aW1lX3NvdXJjZSBzcGFuKSBmIGFcbiAgOztcblxuICBsZXQgYWZ0ZXIgdGltZV9zb3VyY2Ugc3BhbiA9IGF0IHRpbWVfc291cmNlIChzcGFuX3RvX3RpbWUgdGltZV9zb3VyY2Ugc3BhbilcbmVuZFxuXG5sZXQgYXRfdGltZXMgPyhzdG9wID0gRGVmZXJyZWQubmV2ZXIgKCkpIHQgbmV4dF90aW1lID1cbiAgbGV0IHRhaWwgPSBUYWlsLmNyZWF0ZSAoKSBpblxuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIGNob29zZVxuICAgICAgWyBjaG9pY2Ugc3RvcCAoZnVuICgpIC0+IGBTdG9wKTsgY2hvaWNlIChhdCB0IChuZXh0X3RpbWUgKCkpKSAoZnVuICgpIC0+IGBUaWNrKSBdXG4gICAgPj4+IGZ1bmN0aW9uXG4gICAgfCBgU3RvcCAtPiBUYWlsLmNsb3NlX2V4biB0YWlsXG4gICAgfCBgVGljayAtPlxuICAgICAgVGFpbC5leHRlbmQgdGFpbCAoKTtcbiAgICAgIGxvb3AgKClcbiAgaW5cbiAgbG9vcCAoKTtcbiAgVGFpbC5jb2xsZWN0IHRhaWxcbjs7XG5cbmxldCBhdF92YXJ5aW5nX2ludGVydmFscyA/c3RvcCB0IGNvbXB1dGVfc3BhbiA9XG4gIGF0X3RpbWVzIHQgP3N0b3AgKGZ1biAoKSAtPiBUaW1lX25zLmFmdGVyIChub3cgdCkgKGNvbXB1dGVfc3BhbiAoKSkpXG47O1xuXG5sZXQgYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCB0IGludGVydmFsID1cbiAgbGV0IHN0YXJ0ID1cbiAgICBtYXRjaCBzdGFydCB3aXRoXG4gICAgfCBTb21lIHggLT4geFxuICAgIHwgTm9uZSAtPiBub3cgdFxuICBpblxuICBhdF90aW1lcyB0ID9zdG9wIChmdW4gKCkgLT5cbiAgICBUaW1lX25zLm5leHRfbXVsdGlwbGUgfmJhc2U6c3RhcnQgfmFmdGVyOihub3cgdCkgfmludGVydmFsICgpKVxuOztcblxubW9kdWxlIENvbnRpbnVlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBJbW1lZGlhdGVseVxuICAgIHwgQWZ0ZXIgb2YgVGltZV9ucy5TcGFuLnRcbiAgICB8IE5leHRfbXVsdGlwbGUgb2YgVGltZV9ucy50ICogVGltZV9ucy5TcGFuLnRcblxuICBsZXQgaW1tZWRpYXRlbHkgPSBJbW1lZGlhdGVseVxuXG4gIGxldCBhdCB0IHRpbWVfc291cmNlID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEltbWVkaWF0ZWx5IC0+IFRpbWluZ193aGVlbC5ub3cgdGltZV9zb3VyY2UuZXZlbnRzXG4gICAgfCBBZnRlciBzcGFuIC0+IHNwYW5fdG9fdGltZSB0aW1lX3NvdXJjZSBzcGFuXG4gICAgfCBOZXh0X211bHRpcGxlIChiYXNlLCBpbnRlcnZhbCkgLT5cbiAgICAgIFRpbWVfbnMubmV4dF9tdWx0aXBsZSB+YmFzZSB+YWZ0ZXI6KG5vdyB0aW1lX3NvdXJjZSkgfmludGVydmFsICgpXG4gIDs7XG5lbmRcblxubGV0IHJ1bl9yZXBlYXRlZGx5XG4gID8oc3RhcnQgPSByZXR1cm4gKCkpXG4gID9zdG9wXG4gID8oY29udGludWVfb25fZXJyb3IgPSB0cnVlKVxuICA/KGZpbmlzaGVkID0gSXZhci5jcmVhdGUgKCkpXG4gIHRcbiAgfmZcbiAgfmNvbnRpbnVlXG4gID1cbiAgc3RhcnRcbiAgPj4+IGZ1biAoKSAtPlxuICBsZXQgYWxhcm0gPSByZWYgKEFsYXJtLm51bGwgKCkpIGluXG4gIGxldCBzdG9wID1cbiAgICBtYXRjaCBzdG9wIHdpdGhcbiAgICB8IE5vbmUgLT4gRGVmZXJyZWQubmV2ZXIgKClcbiAgICB8IFNvbWUgc3RvcCAtPlxuICAgICAgdXBvbiBzdG9wIChmdW4gKCkgLT5cbiAgICAgICAgaWYgVGltaW5nX3doZWVsLm1lbSB0LmV2ZW50cyAhYWxhcm1cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgcmVtb3ZlX2FsYXJtIHQgIWFsYXJtO1xuICAgICAgICAgIEl2YXIuZmlsbF9pZl9lbXB0eSBmaW5pc2hlZCAoKSkpO1xuICAgICAgc3RvcFxuICBpblxuICAoKiBbcnVuX2ZdLCBbY29udGludWVfZl0sIGFuZCBbY29udGludWVfdHJ5X3dpdGhdIGFyZSBkZWZpbmVkIHNvIHRoYXQgd2UgYWxsb2NhdGUgdGhlaXJcbiAgICAgY2xvc3VyZXMgb25jZSwgbm90IG9uY2UgcGVyIGl0ZXJhdGlvbi4gKilcbiAgbGV0IHJlYyBydW5fZiAoKSA9XG4gICAgKCogQmVmb3JlIGNhbGxpbmcgW2ZdLCB3ZSBzeW5jaHJvbm91c2x5IGNoZWNrIHdoZXRoZXIgW3N0b3BdIGlzIGRldGVybWluZWQuICopXG4gICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCBzdG9wXG4gICAgdGhlbiBJdmFyLmZpbGxfaWZfZW1wdHkgZmluaXNoZWQgKClcbiAgICBlbHNlIGlmIGNvbnRpbnVlX29uX2Vycm9yXG4gICAgdGhlbiBNb25pdG9yLnRyeV93aXRoIGYgfnJ1bjpgTm93IH5yZXN0OmBSYWlzZSA+Pj4gY29udGludWVfdHJ5X3dpdGhcbiAgICBlbHNlIChcbiAgICAgIGxldCBkID0gZiAoKSBpblxuICAgICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCBkIHRoZW4gY29udGludWVfZiAoKSBlbHNlIGQgPj4+IGNvbnRpbnVlX2YpXG4gIGFuZCBjb250aW51ZV9mICgpID1cbiAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIHN0b3BcbiAgICB0aGVuIEl2YXIuZmlsbF9pZl9lbXB0eSBmaW5pc2hlZCAoKVxuICAgIGVsc2UgYWxhcm0gOj0gcnVuX2F0X2ludGVybmFsIHQgKENvbnRpbnVlLmF0IGNvbnRpbnVlIHQpIHJ1bl9mICgpXG4gIGFuZCBjb250aW51ZV90cnlfd2l0aCBvcl9lcnJvciA9XG4gICAgKG1hdGNoIG9yX2Vycm9yIHdpdGhcbiAgICAgfCBPayAoKSAtPiAoKVxuICAgICB8IEVycm9yIGVycm9yIC0+IE1vbml0b3Iuc2VuZF9leG4gKE1vbml0b3IuY3VycmVudCAoKSkgZXJyb3IpO1xuICAgIGNvbnRpbnVlX2YgKClcbiAgaW5cbiAgcnVuX2YgKClcbjs7XG5cbmxldCBldmVyeScgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciA/ZmluaXNoZWQgdCBzcGFuIGYgPVxuICBpZiBUaW1lX25zLlNwYW4uKCA8PSApIHNwYW4gVGltZV9ucy5TcGFuLnplcm9cbiAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIlRpbWVfc291cmNlLmV2ZXJ5IGdvdCBub25wb3NpdGl2ZSBzcGFuXCIgKHNwYW4gOiBUaW1lX25zLlNwYW4udCldO1xuICBydW5fcmVwZWF0ZWRseSB0ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgP2ZpbmlzaGVkIH5mIH5jb250aW51ZTooQWZ0ZXIgc3Bhbilcbjs7XG5cbmxldCBldmVyeSA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIHQgc3BhbiBmID1cbiAgZXZlcnknIHQgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciA/ZmluaXNoZWQ6Tm9uZSBzcGFuIChmdW4gKCkgLT5cbiAgICBmICgpO1xuICAgIHJldHVybiAoKSlcbjs7XG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzJyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIHQgaW50ZXJ2YWwgZiA9XG4gIGxldCBub3cgPSBub3cgdCBpblxuICBsZXQgYmFzZSwgc3RhcnQgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IE5vbmUgLT4gbm93LCBOb25lXG4gICAgfCBTb21lIHN0YXJ0IC0+XG4gICAgICAoIHN0YXJ0XG4gICAgICAsIFNvbWVcbiAgICAgICAgICAoYXRcbiAgICAgICAgICAgICB0XG4gICAgICAgICAgICAgKFRpbWVfbnMubmV4dF9tdWx0aXBsZVxuICAgICAgICAgICAgICAgICgpXG4gICAgICAgICAgICAgICAgfmJhc2U6c3RhcnRcbiAgICAgICAgICAgICAgICB+YWZ0ZXI6bm93XG4gICAgICAgICAgICAgICAgfmNhbl9lcXVhbF9hZnRlcjp0cnVlXG4gICAgICAgICAgICAgICAgfmludGVydmFsKSkgKVxuICBpblxuICBydW5fcmVwZWF0ZWRseVxuICAgIHRcbiAgICA/c3RhcnRcbiAgICA/c3RvcFxuICAgID9jb250aW51ZV9vbl9lcnJvclxuICAgIH5mXG4gICAgfmNvbnRpbnVlOihOZXh0X211bHRpcGxlIChiYXNlLCBpbnRlcnZhbCkpXG47O1xuXG5sZXQgcnVuX2F0X2ludGVydmFscyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIHQgaW50ZXJ2YWwgZiA9XG4gIHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBpbnRlcnZhbCAoZnVuICgpIC0+XG4gICAgZiAoKTtcbiAgICByZXR1cm4gKCkpXG47O1xuXG5sZXQgd2l0aF90aW1lb3V0IHQgc3BhbiBkID1cbiAgbGV0IHRpbWVvdXQgPSBFdmVudC5hZnRlciB0IHNwYW4gaW5cbiAgY2hvb3NlXG4gICAgKCogVGhlIGNvZGUgYmVsb3cgZG9lcyBleGhhdXN0aXZlIGNhc2UgYW5hbHlzaXMgaW4gYm90aCBbY2hvaWNlXXMuICBCZWNhdXNlIFt0aW1lb3V0XVxuICAgICAgIGRvZXMgbm90IGVzY2FwZSB0aGUgc2NvcGUgb2YgdGhpcyBmdW5jdGlvbiwgY2VydGFpbiBjYXNlcyBzaG91bGQgYmUgaW1wb3NzaWJsZSwgYW5kXG4gICAgICAgYXJlIG1hcmtlZCBhcyBzdWNoIHdpdGggZXhjZXB0aW9ucy4gIFdlIGRvIG5vdCBleHBlY3QgdGhvc2UgZXhjZXB0aW9ucyB0byBvY2N1cixcbiAgICAgICBidXQgaWYgdGhleSBkbywgaXQgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBbY2hvb3NlXSByYXRoZXIgdGhhblxuICAgICAgIFt3aXRoX3RpbWVvdXRdLiAqKVxuICAgIFsgY2hvaWNlIGQgKGZ1biB2IC0+XG4gICAgICAgIChtYXRjaCBFdmVudC5hYm9ydCB0aW1lb3V0ICgpIHdpdGhcbiAgICAgICAgICgqIFtQcmV2aW91c2x5X2hhcHBlbmVkXSBjYW4gb2NjdXIgaWYgYm90aCBbZF0gYW5kIFt3YWl0XSBiZWNvbWUgZGV0ZXJtaW5lZCBhdFxuICAgICAgICAgICAgdGhlIHNhbWUgdGltZSwgZS5nLiBbd2l0aF90aW1lb3V0IChzZWMgMC4pIChyZXR1cm4gKCkpXS4gKilcbiAgICAgICAgIHwgT2sgfCBQcmV2aW91c2x5X2hhcHBlbmVkICgpIC0+ICgpXG4gICAgICAgICB8IFByZXZpb3VzbHlfYWJvcnRlZCAoKSAtPlxuICAgICAgICAgICByYWlzZV9zIFslbWVzc2FnZSBcIlRpbWVfc291cmNlLndpdGhfdGltZW91dCBidWc6IHNob3VsZCBvbmx5IGFib3J0IG9uY2VcIl0pO1xuICAgICAgICBgUmVzdWx0IHYpXG4gICAgOyBjaG9pY2UgKEV2ZW50LmZpcmVkIHRpbWVvdXQpIChmdW5jdGlvblxuICAgICAgICB8IEhhcHBlbmVkICgpIC0+IGBUaW1lb3V0XG4gICAgICAgIHwgQWJvcnRlZCAoKSAtPlxuICAgICAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiVGltZV9zb3VyY2Uud2l0aF90aW1lb3V0IGJ1ZzogYm90aCBjb21wbGV0ZWQgYW5kIHRpbWVkIG91dFwiXSlcbiAgICBdXG47O1xuXG5sZXQgd2l0aF90aW1lb3V0X2V4biB0IHNwYW4gZCB+ZXJyb3IgPVxuICBEZWZlcnJlZC5tYXAgKHdpdGhfdGltZW91dCB0IHNwYW4gZCkgfmY6KGZ1bmN0aW9uXG4gICAgfCBgUmVzdWx0IHJlc3VsdCAtPiByZXN1bHRcbiAgICB8IGBUaW1lb3V0IC0+IEVycm9yLnJhaXNlIGVycm9yKVxuOztcblxubGV0IGR1cmF0aW9uX29mIHQgZiA9XG4gIGxldCBzdGFydCA9IG5vdyB0IGluXG4gICgqIEVhZ2VyIG1hcCB0byBwcm92aWRlIG1vcmUgYWNjdXJhdGUgdGltaW5ncyB3aGVuIFtmXSBpcyBzeW5jaHJvbm91cy4gKilcbiAgRWFnZXJfZGVmZXJyZWQubWFwIChmICgpKSB+ZjooZnVuIHJlc3VsdCAtPlxuICAgIGxldCBkdXJhdGlvbiA9IFRpbWVfbnMuZGlmZiAobm93IHQpIHN0YXJ0IGluXG4gICAgcmVzdWx0LCBkdXJhdGlvbilcbjs7XG5cbmxldCBvZl9zeW5jaHJvbm91cyB0ID0gdFxubGV0IHRvX3N5bmNocm9ub3VzIHQgPSB0XG5cbmxldCB0aW1pbmdfd2hlZWxfaGFzX2V2ZW50X2F0X29yX2JlZm9yZSB3aGVlbCB0aW1lID1cbiAgaWYgVGltaW5nX3doZWVsLmlzX2VtcHR5IHdoZWVsXG4gIHRoZW4gZmFsc2VcbiAgZWxzZSAoXG4gICAgbGV0IG5leHRfYWxhcm0gPSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdF9leG4gd2hlZWwgaW5cbiAgICBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5LihuZXh0X2FsYXJtIDw9IHRpbWUpKVxuOztcblxubGV0IGFkdmFuY2VfZGlyZWN0bHlfaWZfcXVpZXNjZW50IHQgfnRvXyA9XG4gIGxldCBpc19xdWVzY2VudCA9XG4gICAgKCogU2luY2UgdGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCB0byBiZSBqdXN0IGEgZmFzdCBjYXNlIG9mIFthZHZhbmNlX2J5X2FsYXJtc10sXG4gICAgICAgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgY2FsbCB0byBbU2NoZWR1bGVyLnlpZWxkICgpXSBjYW4gYmUgZWxpZGVkLFxuICAgICAgIGhlbmNlIHRoZSBbY2FuX3J1bl9hX2pvYl0gY2hlY2suXG5cbiAgICAgICBXZSdyZSBub3QgY2hlY2tpbmcgZXBvbGwsIGFuZCB3ZSdyZSBub3QgY2hlY2tpbmcgdGhlIFtleHRlcm5hbF9qb2JzXS4gIFRoYXQgaXMgYW5cbiAgICAgICBvYnNlcnZhYmxlIGRpZmZlcmVuY2UsIGJ1dCBzaW5jZSBbYWR2YW5jZV9ieV9hbGFybXMgP3dhaXRfZm9yOk5vbmVdIGlzIGFscmVhZHlcbiAgICAgICBwcmV0dHkgYnJva2VuIHdoZW4gd2FpdGluZyBmb3IgZXh0ZXJuYWwgZXZlbnRzLCBpdCdzIG5vdCBnb2luZyB0byBiZSBtZWFuaW5nZnVsLlxuICAgICopXG4gICAgY2FuX3J1bl9hX2pvYiB0LnNjaGVkdWxlclxuICAgIHx8IFN5bmNocm9ub3VzX3RpbWVfc291cmNlMC5oYXNfZXZlbnRzX3RvX3J1biB0XG4gICAgfHwgdGltaW5nX3doZWVsX2hhc19ldmVudF9hdF9vcl9iZWZvcmUgdC5ldmVudHMgdG9fXG4gIGluXG4gIGlmIGlzX3F1ZXNjZW50XG4gIHRoZW4gZmFsc2VcbiAgZWxzZSAoXG4gICAgYWR2YW5jZV9kaXJlY3RseSB0IH50b187XG4gICAgdHJ1ZSlcbjs7XG4iLCJ0eXBlIHQgPSB1bml0IC0+IHVuaXRcblxubW9kdWxlIEhhbmRsZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBUeXBlcy5DeWNsZV9ob29rX2hhbmRsZS50XG5lbmRcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIxXG5tb2R1bGUgU3RyZWFtID0gQXN5bmNfc3RyZWFtXG5pbmNsdWRlIChTY2hlZHVsZXIgOiBtb2R1bGUgdHlwZSBvZiBTY2hlZHVsZXIgd2l0aCBtb2R1bGUgQnZhciA6PSBTY2hlZHVsZXIuQnZhcilcblxubGV0IHQgPSBTY2hlZHVsZXIudFxuXG5pbmNsdWRlIE1vbml0b3IuRXhwb3J0ZWRfZm9yX3NjaGVkdWxlclxuXG5sZXQgZmluZF9sb2NhbCBrZXkgPSBFeGVjdXRpb25fY29udGV4dC5maW5kX2xvY2FsIChjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSkga2V5XG5cbmxldCB3aXRoX2xvY2FsIGtleSB2YWx1ZSB+ZiA9XG4gIGxldCB0ID0gdCAoKSBpblxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPVxuICAgIEV4ZWN1dGlvbl9jb250ZXh0LndpdGhfbG9jYWwgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCkga2V5IHZhbHVlXG4gIGluXG4gIHdpdGhfZXhlY3V0aW9uX2NvbnRleHQgdCBleGVjdXRpb25fY29udGV4dCB+ZlxuOztcblxubGV0IG1haW5fZXhlY3V0aW9uX2NvbnRleHQgPSAodCAoKSkubWFpbl9leGVjdXRpb25fY29udGV4dFxuXG5sZXQgY2FuX3J1bl9hX2pvYiB0ID1cbiAgbnVtX3BlbmRpbmdfam9icyB0ID4gMFxuICB8fCBCdmFyLmhhc19hbnlfd2FpdGVycyB0LnlpZWxkXG4gIHx8IEJ2YXIuaGFzX2FueV93YWl0ZXJzIHQueWllbGRfdW50aWxfbm9fam9ic19yZW1haW5cbjs7XG5cbmxldCBoYXNfdXBjb21pbmdfZXZlbnQgdCA9IG5vdCAoVGltaW5nX3doZWVsLmlzX2VtcHR5IChldmVudHMgdCkpXG5sZXQgbmV4dF91cGNvbWluZ19ldmVudCB0ID0gVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXQgKGV2ZW50cyB0KVxubGV0IG5leHRfdXBjb21pbmdfZXZlbnRfZXhuIHQgPSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdF9leG4gKGV2ZW50cyB0KVxubGV0IGV2ZW50X3ByZWNpc2lvbiB0ID0gVGltaW5nX3doZWVsLmFsYXJtX3ByZWNpc2lvbiAoZXZlbnRzIHQpXG5sZXQgY3ljbGVfc3RhcnQgdCA9IHQuY3ljbGVfc3RhcnRcblxubGV0IHJ1bl9ldmVyeV9jeWNsZV9zdGFydCB0IH5mID1cbiAgKCogVXNpbmcgYW4gYXJyYXkgcmF0aGVyIHRoYW4gYSBsaXN0IGZvciBjYWNoZSBlZmZpY2llbmN5LiBUaGlzIGFuZFxuICAgICBbcnVuX2V2ZXJ5X2N5Y2xlX2VuZF0gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGR1cmluZyBwcm9ncmFtIGluaXRpYWxpemF0aW9uLCBzbyB0aGVcbiAgICAgYWxsb2NhdGlvbiBhbmQgZ2FyYmFnZSBjcmVhdGlvbiBzaG91bGQgbm90IGJlIGFuIGlzc3VlLlxuXG4gICAgIE5vdGUgdGhhdCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gTiB0aW1lcyB0YWtlcyBPKE5eMikgdGltZSwgYnV0IHRoaXMgc2hvdWxkIGJlIGZpbmVcbiAgICAgYmVjYXVzZSBOIGlzIHNtYWxsLiBTYW1lIGZvciBbcnVuX2V2ZXJ5X2N5Y2xlX2VuZF0uICopXG4gIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IDwtIEFycmF5LmFwcGVuZCBbfCBmIHxdIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0XG47O1xuXG5sZXQgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCB0IH5mID1cbiAgdC5ydW5fZXZlcnlfY3ljbGVfZW5kIDwtIEFycmF5LmFwcGVuZCBbfCBmIHxdIHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZFxuOztcblxubGV0IGFkZF9ldmVyeV9jeWNsZV9zdGFydF9ob29rIHQgfmYgPVxuICBsZXQgaGFuZGxlID0gVHlwZXMuQ3ljbGVfaG9va19oYW5kbGUuY3JlYXRlICgpIGluXG4gIEhhc2h0YmwuYWRkX2V4biB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZSB+a2V5OmhhbmRsZSB+ZGF0YTpmO1xuICBydW5fZXZlcnlfY3ljbGVfc3RhcnQgdCB+ZjtcbiAgaGFuZGxlXG47O1xuXG5sZXQgYWRkX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rIHQgfmYgPVxuICBsZXQgaGFuZGxlID0gVHlwZXMuQ3ljbGVfaG9va19oYW5kbGUuY3JlYXRlICgpIGluXG4gIEhhc2h0YmwuYWRkX2V4biB0LnJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUgfmtleTpoYW5kbGUgfmRhdGE6ZjtcbiAgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCB0IH5mO1xuICBoYW5kbGVcbjs7XG5cbmxldCBhcnJheV9yZW1vdmVfZmlyc3QgYXJyIH5mID1cbiAgbWF0Y2ggQXJyYXkuZmluZGkgYXJyIH5mIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIChpZHgsIF8pIC0+XG4gICAgU29tZVxuICAgICAgKEFycmF5LmluaXRcbiAgICAgICAgIChBcnJheS5sZW5ndGggYXJyIC0gMSlcbiAgICAgICAgIH5mOihmdW4gaSAtPiBpZiBpIDwgaWR4IHRoZW4gYXJyLihpKSBlbHNlIGFyci4oaSArIDEpKSlcbjs7XG5cbmxldCByZW1vdmVfc2luZ2xlX2N5Y2xlX2hvb2sgYXJyIGYgPVxuICAoKiBSZW1vdmUgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgW2ZdIGZyb20gW2Fycl0uIE1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgbWF5IGJlIHByZXNlbnQsXG4gICAgIGJ1dCByZW1vdmFsIGlzIHJlZmVyZW5jZS1jb3VudGVkIGJ5IFtydW5fZXZlcnlfY3ljbGVfKHN0YXJ0fGVuZClfc3RhdGVdIHRhYmxlcy4gKilcbiAgbWF0Y2ggYXJyYXlfcmVtb3ZlX2ZpcnN0IH5mOihmdW4gXyBnIC0+IHBoeXNfZXF1YWwgZiBnKSBhcnIgd2l0aFxuICB8IFNvbWUgYXJyIC0+IGFyclxuICB8IE5vbmUgLT5cbiAgICAoKiBUaGlzIHNob3VsZCBiZSB1bnJlYWNoYWJsZSwgc2VlIHRoZSBbaW52YXJpYW50XSBpbiBbc2NoZWR1bGVyMS5tbF0uICopXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiU2NoZWR1bGVyLnJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayBjYWxsZWQgd2l0aCBhIGhvb2sgdGhhdCBpc24ndCByZWdpc3RlcmVkXCJdXG47O1xuXG5sZXQgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2tfZXhuIHQgaGFuZGxlID1cbiAgbWF0Y2ggSGFzaHRibC5maW5kX2FuZF9yZW1vdmUgdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgaGFuZGxlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgZmFpbHdpdGggXCJBdHRlbXB0ZWQgdG8gcmVtb3ZlIGEgY3ljbGUgc3RhcnQgaG9vayB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXCJcbiAgfCBTb21lIGYgLT5cbiAgICB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydCA8LSByZW1vdmVfc2luZ2xlX2N5Y2xlX2hvb2sgdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnQgZlxuOztcblxubGV0IHJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leG4gdCBoYW5kbGUgPVxuICBtYXRjaCBIYXNodGJsLmZpbmRfYW5kX3JlbW92ZSB0LnJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUgaGFuZGxlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgZmFpbHdpdGggXCJBdHRlbXB0ZWQgdG8gcmVtb3ZlIGEgY3ljbGUgZW5kIGhvb2sgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkLlwiXG4gIHwgU29tZSBmIC0+IHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZCA8LSByZW1vdmVfc2luZ2xlX2N5Y2xlX2hvb2sgdC5ydW5fZXZlcnlfY3ljbGVfZW5kIGZcbjs7XG5cbmxldCBtYXBfY3ljbGVfdGltZXMgdCB+ZiA9XG4gIFN0cmVhbS5jcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmY6KGZ1biAoKSAtPiBUYWlsLmV4dGVuZCB0YWlsIChmIHQubGFzdF9jeWNsZV90aW1lKSkpXG47O1xuXG5sZXQgbG9uZ19jeWNsZXMgdCB+YXRfbGVhc3QgPVxuICBTdHJlYW0uY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHJ1bl9ldmVyeV9jeWNsZV9zdGFydCB0IH5mOihmdW4gKCkgLT5cbiAgICAgIGlmIFRpbWVfbnMuU3Bhbi4oID49ICkgdC5sYXN0X2N5Y2xlX3RpbWUgYXRfbGVhc3RcbiAgICAgIHRoZW4gVGFpbC5leHRlbmQgdGFpbCB0Lmxhc3RfY3ljbGVfdGltZSkpXG47O1xuXG5sZXQgY3ljbGVfbnVtX2pvYnMgdCA9XG4gIFN0cmVhbS5jcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmY6KGZ1biAoKSAtPiBUYWlsLmV4dGVuZCB0YWlsIHQubGFzdF9jeWNsZV9udW1fam9icykpXG47O1xuXG5sZXQgY3ljbGVfY291bnQgdCA9IHQuY3ljbGVfY291bnRcblxubGV0IHNldF9tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSB0IGludCA9XG4gIHQubWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGVcbiAgICA8LSBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS5jcmVhdGVfZXhuIGludFxuOztcblxubGV0IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIHQgPVxuICBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS5yYXcgdC5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuOztcblxubGV0IHNldF90aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayB0IGYgPSB0LnRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rIDwtIGZcblxubGV0IHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgVGhyZWFkX3NhZmVfcXVldWUuZW5xdWV1ZSB0LmV4dGVybmFsX2pvYnMgKEV4dGVybmFsX2pvYi5UIChleGVjdXRpb25fY29udGV4dCwgZiwgYSkpO1xuICB0LnRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rICgpXG47O1xuXG5sZXQgc2V0X2V2ZW50X2FkZGVkX2hvb2sgdCBmID0gdC5ldmVudF9hZGRlZF9ob29rIDwtIFNvbWUgZlxubGV0IHNldF9qb2JfcXVldWVkX2hvb2sgdCBmID0gdC5qb2JfcXVldWVkX2hvb2sgPC0gU29tZSBmXG5cbmxldCBjcmVhdGVfYWxhcm0gdCBmID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0IGluXG4gIEdjLkV4cGVydC5BbGFybS5jcmVhdGUgKGZ1biAoKSAtPlxuICAgIHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiAoKSlcbjs7XG5cbmxldCBhZGRfZmluYWxpemVyIHQgaGVhcF9ibG9jayBmID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0IGluXG4gIGxldCBmaW5hbGl6ZXIgaGVhcF9ibG9jayA9XG4gICAgKCogSGVyZSB3ZSBjYW4gYmUgaW4gYW55IHRocmVhZCwgYW5kIG1heSBub3QgYmUgaG9sZGluZyB0aGUgYXN5bmMgbG9jay4gIFNvLCB3ZSBjYW5cbiAgICAgICBvbmx5IGRvIHRocmVhZC1zYWZlIHRoaW5ncy5cblxuICAgICAgIEJ5IHB1dHRpbmcgW2hlYXBfYmxvY2tdIGluIFtleHRlcm5hbF9qb2JzXSwgd2UgYXJlIGtlZXBpbmcgaXQgYWxpdmUgdW50aWwgdGhlIG5leHRcbiAgICAgICB0aW1lIHRoZSBhc3luYyBzY2hlZHVsZXIgZ2V0cyBhcm91bmQgdG8gZGVxdWV1ZWluZyBpdC4gIENhbGxpbmdcbiAgICAgICBbdC50aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9va10gZW5zdXJlcyB0aGF0IHdpbGwgaGFwcGVuIGluIHNob3J0IG9yZGVyLiAgVGh1cyxcbiAgICAgICB3ZSBhcmUgbm90IGRyYW1hdGljYWxseSBpbmNyZWFzaW5nIHRoZSBsaWZldGltZSBvZiBbaGVhcF9ibG9ja10sIHNpbmNlIHRoZSBPQ2FtbFxuICAgICAgIHJ1bnRpbWUgYWxyZWFkeSByZXN1cnJlY3RlZCBbaGVhcF9ibG9ja10gc28gdGhhdCB3ZSBjb3VsZCByZWZlciB0byBpdCBoZXJlLiAgVGhlXG4gICAgICAgT0NhbWwgcnVudGltZSBhbHJlYWR5IHJlbW92ZWQgdGhlIGZpbmFsaXplciBmdW5jdGlvbiB3aGVuIGl0IG5vdGljZWQgW2hlYXBfYmxvY2tdXG4gICAgICAgY291bGQgYmUgZmluYWxpemVkLCBzbyB0aGVyZSBpcyBubyBpbmZpbml0ZSBsb29wIGluIHdoaWNoIHdlIGFyZSBjYXVzaW5nIHRoZVxuICAgICAgIGZpbmFsaXplciB0byBydW4gYWdhaW4uICBBbHNvLCBPQ2FtbCBkb2VzIG5vdCBpbXBvc2UgYW55IHJlcXVpcmVtZW50IG9uIGZpbmFsaXplclxuICAgICAgIGZ1bmN0aW9ucyB0aGF0IHRoZXkgbmVlZCB0byBkaXNwb3NlIG9mIHRoZSBibG9jaywgc28gaXQncyBmaW5lIHRoYXQgd2Uga2VlcFxuICAgICAgIFtoZWFwX2Jsb2NrXSBhcm91bmQgdW50aWwgbGF0ZXIuICopXG4gICAgaWYgRGVidWcuZmluYWxpemVycyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJlbnF1ZXVlaW5nIGZpbmFsaXplclwiO1xuICAgIHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBoZWFwX2Jsb2NrXG4gIGluXG4gIGlmIERlYnVnLmZpbmFsaXplcnMgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwiYWRkaW5nIGZpbmFsaXplclwiO1xuICAoKiBXZSB1c2UgW0NhbWwuR2MuZmluYWxpc2VdIGluc3RlYWQgb2YgW0NvcmUuR2MuYWRkX2ZpbmFsaXplcl0gYmVjYXVzZSB0aGUgbGF0dGVyXG4gICAgIGhhcyBpdHMgb3duIHdyYXBwZXIgYXJvdW5kIFtDYW1sLkdjLmZpbmFsaXNlXSB0byBydW4gZmluYWxpemVycyBzeW5jaHJvbm91c2x5LiAqKVxuICB0cnkgU3RkbGliLkdjLmZpbmFsaXNlIGZpbmFsaXplciBoZWFwX2Jsb2NrIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT5cbiAgICAoKiBbSGVhcF9ibG9ja10gZW5zdXJlcyB0aGF0IHRoaXMgd2lsbCBvbmx5IGZhaWwgZm9yIHN0YXRpYyBkYXRhLCBpbiB3aGljaCBjYXNlIHdlXG4gICAgICAgY2FuIGRyb3AgdGhlIGZpbmFsaXplciBzaW5jZSB0aGUgYmxvY2sgd2lsbCBuZXZlciBiZSBjb2xsZWN0ZWQuKilcbiAgICAoKVxuOztcblxubGV0IGFkZF9maW5hbGl6ZXJfZXhuIHQgeCBmID1cbiAgYWRkX2ZpbmFsaXplciB0IChIZWFwX2Jsb2NrLmNyZWF0ZV9leG4geCkgKGZ1biBoZWFwX2Jsb2NrIC0+XG4gICAgZiAoSGVhcF9ibG9jay52YWx1ZSBoZWFwX2Jsb2NrKSlcbjs7XG5cbmxldCBhZGRfZmluYWxpemVyX2xhc3QgdCBoZWFwX2Jsb2NrIGYgPVxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHQgaW5cbiAgbGV0IGZpbmFsaXplciAoKSA9XG4gICAgKCogSGVyZSB3ZSBjYW4gYmUgaW4gYW55IHRocmVhZCwgYW5kIG1heSBub3QgYmUgaG9sZGluZyB0aGUgYXN5bmMgbG9jay4gIFNvLCB3ZSBjYW5cbiAgICAgICBvbmx5IGRvIHRocmVhZC1zYWZlIHRoaW5ncy4gKilcbiAgICBpZiBEZWJ1Zy5maW5hbGl6ZXJzXG4gICAgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwiZW5xdWV1ZWluZyBmaW5hbGl6ZXIgKHVzaW5nICdsYXN0JyBzZW1hbnRpYylcIjtcbiAgICB0aHJlYWRfc2FmZV9lbnF1ZXVlX2V4dGVybmFsX2pvYiB0IGV4ZWN1dGlvbl9jb250ZXh0IGYgKClcbiAgaW5cbiAgaWYgRGVidWcuZmluYWxpemVycyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJhZGRpbmcgZmluYWxpemVyICh1c2luZyAnbGFzdCcgc2VtYW50aWMpXCI7XG4gICgqIFdlIHVzZSBbQ2FtbC5HYy5maW5hbGlzZV9sYXN0XSBpbnN0ZWFkIG9mIFtDb3JlLkdjLmFkZF9maW5hbGl6ZXJfbGFzdF0gYmVjYXVzZVxuICAgICB0aGUgbGF0dGVyIGhhcyBpdHMgb3duIHdyYXBwZXIgYXJvdW5kIFtDYW1sLkdjLmZpbmFsaXNlX2xhc3RdIHRvIHJ1biBmaW5hbGl6ZXJzXG4gICAgIHN5bmNocm9ub3VzbHkuICopXG4gIHRyeSBTdGRsaWIuR2MuZmluYWxpc2VfbGFzdCBmaW5hbGl6ZXIgaGVhcF9ibG9jayB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgKCogW0hlYXBfYmxvY2tdIGVuc3VyZXMgdGhhdCB0aGlzIHdpbGwgb25seSBmYWlsIGZvciBzdGF0aWMgZGF0YSwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgICAgIGNhbiBkcm9wIHRoZSBmaW5hbGl6ZXIgc2luY2UgdGhlIGJsb2NrIHdpbGwgbmV2ZXIgYmUgY29sbGVjdGVkLiopXG4gICAgKClcbjs7XG5cbmxldCBhZGRfZmluYWxpemVyX2xhc3RfZXhuIHQgeCBmID0gYWRkX2ZpbmFsaXplcl9sYXN0IHQgKEhlYXBfYmxvY2suY3JlYXRlX2V4biB4KSBmXG5cbigqKiBbZm9yY2VfY3VycmVudF9jeWNsZV90b19lbmRdIHNldHMgdGhlIG51bWJlciBvZiBub3JtYWwgam9icyBhbGxvd2VkIHRvIHJ1biBpbiB0aGlzXG4gICAgY3ljbGUgdG8gemVyby4gIFRodXMsIGFmdGVyIHRoZSBjdXJyZW50bHkgcnVubmluZyBqb2IgY29tcGxldGVzLCB0aGUgc2NoZWR1bGVyIHdpbGxcbiAgICBzd2l0Y2ggdG8gbG93IHByaW9yaXR5IGpvYnMgYW5kIHRoZW4gZW5kIHRoZSBjdXJyZW50IGN5Y2xlLiAqKVxubGV0IGZvcmNlX2N1cnJlbnRfY3ljbGVfdG9fZW5kIHQgPVxuICBKb2JfcXVldWUuc2V0X2pvYnNfbGVmdF90aGlzX2N5Y2xlIHQubm9ybWFsX3ByaW9yaXR5X2pvYnMgMFxuOztcblxuKCogV2UgcHJlYWxsb2NhdGUgW3NlbmRfZXhuXSB0byBhdm9pZCBhbGxvY2F0aW5nIGl0IG9uIGVhY2ggY2FsbCB0byBbYWR2YW5jZV9jbG9ja10uICopXG5sZXQgc2VuZF9leG4gPSBTb21lIE1vbml0b3Iuc2VuZF9leG5cblxubGV0IGFkdmFuY2VfY2xvY2sgdCB+bm93ID1cbiAgU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLmFkdmFuY2VfaW50ZXJuYWwgdC50aW1lX3NvdXJjZSB+dG9fOm5vdyB+c2VuZF9leG5cbjs7XG5cbmxldCBydW5fY3ljbGUgdCA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwicnVuX2N5Y2xlIHN0YXJ0aW5nXCIgdCBbJXNleHBfb2Y6IHRdO1xuICBsZXQgbm93ID0gVGltZV9ucy5ub3cgKCkgaW5cbiAgdC5jeWNsZV9jb3VudCA8LSB0LmN5Y2xlX2NvdW50ICsgMTtcbiAgdC5jeWNsZV9zdGFydCA8LSBub3c7XG4gIHQuaW5fY3ljbGUgPC0gdHJ1ZTtcbiAgQnZhci5icm9hZGNhc3QgdC55aWVsZCAoKTtcbiAgbGV0IG51bV9qb2JzX3J1bl9hdF9zdGFydF9vZl9jeWNsZSA9IG51bV9qb2JzX3J1biB0IGluXG4gIEFycmF5Lml0ZXIgdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnQgfmY6KGZ1biBmIC0+IGYgKCkpO1xuICBhZHZhbmNlX2Nsb2NrIHQgfm5vdztcbiAgc3RhcnRfY3ljbGUgdCB+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eTp0Lm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlO1xuICBsZXQgcmVjIHJ1bl9qb2JzIHQgPVxuICAgIG1hdGNoIFNjaGVkdWxlci5ydW5fam9icyB0IHdpdGhcbiAgICB8IE9rICgpIC0+ICgpXG4gICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICBNb25pdG9yLnNlbmRfZXhuIChNb25pdG9yLmN1cnJlbnQgKCkpIGV4biB+YmFja3RyYWNlOihgVGhpcyBiYWNrdHJhY2UpO1xuICAgICAgKCogW3J1bl9qb2JzXSBzdG9wcGVkIGR1ZSB0byBhbiBleG4uICBUaGVyZSBtYXkgc3RpbGwgYmUgam9icyB0aGF0IGNvdWxkIGJlXG4gICAgICAgICBydW4gdGhpcyBjeWNsZSwgc28gW3J1bl9qb2JzXSBhZ2Fpbi4gKilcbiAgICAgIHJ1bl9qb2JzIHRcbiAgaW5cbiAgcnVuX2pvYnMgdDtcbiAgbGV0IGN5Y2xlX3RpbWUgPSBUaW1lX25zLmRpZmYgKFRpbWVfbnMubm93ICgpKSB0LmN5Y2xlX3N0YXJ0IGluXG4gIHQubGFzdF9jeWNsZV90aW1lIDwtIGN5Y2xlX3RpbWU7XG4gIHQubGFzdF9jeWNsZV9udW1fam9icyA8LSBudW1fam9ic19ydW4gdCAtIG51bV9qb2JzX3J1bl9hdF9zdGFydF9vZl9jeWNsZTtcbiAgdC50b3RhbF9jeWNsZV90aW1lIDwtIFRpbWVfbnMuU3Bhbi4odC50b3RhbF9jeWNsZV90aW1lICsgY3ljbGVfdGltZSk7XG4gIGlmIEJ2YXIuaGFzX2FueV93YWl0ZXJzIHQueWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gJiYgbnVtX3BlbmRpbmdfam9icyB0ID0gMFxuICB0aGVuIEJ2YXIuYnJvYWRjYXN0IHQueWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gKCk7XG4gIEFycmF5Lml0ZXIgdC5ydW5fZXZlcnlfY3ljbGVfZW5kIH5mOihmdW4gZiAtPiBmICgpKTtcbiAgdC5pbl9jeWNsZSA8LSBmYWxzZTtcbiAgaWYgZGVidWdcbiAgdGhlblxuICAgIERlYnVnLmxvZ1xuICAgICAgXCJydW5fY3ljbGUgZmluaXNoZWRcIlxuICAgICAgKHVuY2F1Z2h0X2V4biB0LCBpc19zb21lIChuZXh0X3VwY29taW5nX2V2ZW50IHQpKVxuICAgICAgWyVzZXhwX29mOiBFcnJvci50IG9wdGlvbiAqIGJvb2xdXG47O1xuXG5sZXQgcnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpbiAoKSA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nX3N0cmluZyBcInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW4gc3RhcnRpbmdcIjtcbiAgbGV0IHQgPSB0ICgpIGluXG4gIGlmIGlzX2RlYWQgdFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwicnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpbiBjYW5ub3QgcHJvY2VlZCAtLSBzY2hlZHVsZXIgaXMgZGVhZFwiXG4gICAgICAgICAgfnNjaGVkdWxlcjoodCA6IHQpXTtcbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBydW5fY3ljbGUgdDtcbiAgICBhZHZhbmNlX2Nsb2NrIHQgfm5vdzooVGltZV9ucy5ub3cgKCkpO1xuICAgIGlmIGNhbl9ydW5fYV9qb2IgdCB0aGVuIGxvb3AgKClcbiAgaW5cbiAgbG9vcCAoKTtcbiAgKCogUmVzZXQgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQgdG8gbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IHdoZW4gd2UncmUgbm90IGluXG4gICAgIGEgam9iLCBbY3VycmVudF9leGVjdXRpb25fY29udGV4dCA9IG1haW5fZXhlY3V0aW9uX2NvbnRleHRdLiAqKVxuICBzZXRfZXhlY3V0aW9uX2NvbnRleHQgdCB0Lm1haW5fZXhlY3V0aW9uX2NvbnRleHQ7XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nX3N0cmluZyBcInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW4gZmluaXNoZWRcIjtcbiAgT3B0aW9uLml0ZXIgKHVuY2F1Z2h0X2V4biB0KSB+ZjpFcnJvci5yYWlzZVxuOztcblxubGV0IG1ha2VfYXN5bmNfdW51c2FibGUgKCkgPVxuICBsZXQgdCA9ICF0X3JlZiBpblxuICB0LmNoZWNrX2FjY2Vzc1xuICAgIDwtIFNvbWVcbiAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgcmFpc2VfcyBbJXNleHAgXCJBc3luYyBzY2hlZHVsZXIgaXMgdW51c2FibGUgZHVlIHRvIFttYWtlX2FzeW5jX3VudXNhYmxlXVwiXSlcbjs7XG5cbmxldCByZXNldF9pbl9mb3JrZWRfcHJvY2VzcyAoKSA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nX3N0cmluZyBcInJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzXCI7XG4gICgqIFRoZXJlIGlzIG5vIG5lZWQgdG8gZW1wdHkgW21haW5fbW9uaXRvcl9ob2xlXS4gKilcbiAgU2NoZWR1bGVyLih0X3JlZiA6PSBjcmVhdGUgKCkpXG47O1xuXG5sZXQgY2hlY2tfaW52YXJpYW50cyB0ID0gdC5jaGVja19pbnZhcmlhbnRzXG5sZXQgc2V0X2NoZWNrX2ludmFyaWFudHMgdCBiID0gdC5jaGVja19pbnZhcmlhbnRzIDwtIGJcbmxldCByZWNvcmRpbmdfYmFja3RyYWNlcyB0ID0gdC5yZWNvcmRfYmFja3RyYWNlc1xubGV0IHNldF9yZWNvcmRfYmFja3RyYWNlcyB0IGIgPSB0LnJlY29yZF9iYWNrdHJhY2VzIDwtIGJcbmxldCB5aWVsZCB0ID0gQnZhci53YWl0IHQueWllbGRcblxubGV0IHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluID8obWF5X3JldHVybl9pbW1lZGlhdGVseSA9IGZhbHNlKSB0ID1cbiAgaWYgbWF5X3JldHVybl9pbW1lZGlhdGVseSAmJiBudW1fcGVuZGluZ19qb2JzIHQgPSAwXG4gIHRoZW4gcmV0dXJuICgpXG4gIGVsc2UgQnZhci53YWl0IHQueWllbGRfdW50aWxfbm9fam9ic19yZW1haW5cbjs7XG5cbmxldCB5aWVsZF9ldmVyeSB+biA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiU2NoZWR1bGVyLnlpZWxkX2V2ZXJ5IGdvdCBub25wb3NpdGl2ZSBjb3VudFwiIChuIDogaW50KV1cbiAgZWxzZSBpZiBuID0gMVxuICB0aGVuIHN0YWdlIChmdW4gdCAtPiB5aWVsZCB0KVxuICBlbHNlIChcbiAgICBsZXQgY291bnRfdW50aWxfeWllbGQgPSByZWYgbiBpblxuICAgIHN0YWdlIChmdW4gdCAtPlxuICAgICAgZGVjciBjb3VudF91bnRpbF95aWVsZDtcbiAgICAgIGlmICFjb3VudF91bnRpbF95aWVsZCA+IDBcbiAgICAgIHRoZW4gcmV0dXJuICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgY291bnRfdW50aWxfeWllbGQgOj0gbjtcbiAgICAgICAgeWllbGQgdCkpKVxuOztcblxubGV0IHRvdGFsX2N5Y2xlX3RpbWUgdCA9XG4gICgqIEFkanVzdCBmb3IgdGhlIGZhY3QgdGhlIGNhbGxlcidzIHByb2JhYmx5IGFuIEFzeW5jIGpvYi4gKilcbiAgaWYgdC5pbl9jeWNsZVxuICB0aGVuIChcbiAgICBsZXQgdGhpc19jeWNsZV90aW1lID0gVGltZV9ucy4oZGlmZiAobm93ICgpKSB0LmN5Y2xlX3N0YXJ0KSBpblxuICAgIFRpbWVfbnMuU3Bhbi4odC50b3RhbF9jeWNsZV90aW1lICsgdGhpc19jeWNsZV90aW1lKSlcbiAgZWxzZSB0LnRvdGFsX2N5Y2xlX3RpbWVcbjs7XG5cbm1vZHVsZSBWZXJ5X2xvd19wcmlvcml0eV93b3JrID0gc3RydWN0XG4gIG1vZHVsZSBXb3JrZXJfcmVzdWx0ID0gVmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLkV4ZWNfcmVzdWx0XG5cbiAgbGV0IHJlYyBydW4gdCA9IHJ1bl93b3JrZXJzIHQgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmc6MV8wMDBcblxuICBhbmQgcnVuX3dvcmtlcnMgdCB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyA9XG4gICAgaWYgbnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyA9IDBcbiAgICB0aGVuIHlpZWxkX3RoZW5fcnVuIHRcbiAgICBlbHNlIGlmIG5vdCAoRGVxdWUuaXNfZW1wdHkgdC52ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzKVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHdvcmtlciA9IERlcXVlLmRlcXVldWVfZnJvbnRfZXhuIHQudmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyBpblxuICAgICAgc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHQgd29ya2VyLmV4ZWN1dGlvbl9jb250ZXh0O1xuICAgICAgcnVuX3dvcmtlciB0IHdvcmtlciB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZylcblxuICBhbmQgeWllbGRfdGhlbl9ydW4gdCA9XG4gICAgaWYgbm90IChEZXF1ZS5pc19lbXB0eSB0LnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMpXG4gICAgdGhlbiBEZWZlcnJlZC51cG9uICh5aWVsZCB0KSAoZnVuICgpIC0+IHJ1biB0KVxuXG4gIGFuZCBydW5fd29ya2VyIHQgd29ya2VyIH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nID1cbiAgICBhc3NlcnQgKHBoeXNfZXF1YWwgdC5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHdvcmtlci5leGVjdXRpb25fY29udGV4dCk7XG4gICAgaWYgbnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyA9IDBcbiAgICB0aGVuIChcbiAgICAgIERlcXVlLmVucXVldWVfZnJvbnQgdC52ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzIHdvcmtlcjtcbiAgICAgIHlpZWxkX3RoZW5fcnVuIHQpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyA9IG51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgLSAxIGluXG4gICAgICBtYXRjaCB3b3JrZXIuZXhlYyAoKSB3aXRoXG4gICAgICB8IEZpbmlzaGVkIC0+IHJ1bl93b3JrZXJzIHQgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmdcbiAgICAgIHwgTm90X2ZpbmlzaGVkIC0+IHJ1bl93b3JrZXIgdCB3b3JrZXIgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmdcbiAgICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgICBsZXQgYnQgPSBCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50ICgpIGluXG4gICAgICAgIE1vbml0b3Iuc2VuZF9leG4gKE1vbml0b3IuY3VycmVudCAoKSkgZXhuIH5iYWNrdHJhY2U6KGBUaGlzIGJ0KTtcbiAgICAgICAgcnVuX3dvcmtlcnMgdCB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZylcbiAgOztcblxuICBsZXQgZW5xdWV1ZSB+ZiA9XG4gICAgbGV0IHQgPSB0ICgpIGluXG4gICAgbGV0IHF1ZXVlID0gdC52ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzIGluXG4gICAgbGV0IHJ1bm5pbmcgPSBub3QgKERlcXVlLmlzX2VtcHR5IHF1ZXVlKSBpblxuICAgIGxldCBleGVjdXRpb25fY29udGV4dCA9XG4gICAgICBFeGVjdXRpb25fY29udGV4dC5jcmVhdGVfbGlrZSAoY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0KSB+cHJpb3JpdHk6TG93XG4gICAgaW5cbiAgICBEZXF1ZS5lbnF1ZXVlX2JhY2sgcXVldWUgeyBleGVjdXRpb25fY29udGV4dDsgZXhlYyA9IGYgfTtcbiAgICBpZiBub3QgcnVubmluZyB0aGVuIGVucXVldWUgdCBleGVjdXRpb25fY29udGV4dCBydW4gdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBGb3JfYmVuY2ggPSBzdHJ1Y3RcbiAgbGV0IGFkdmFuY2VfY2xvY2sgPSBhZHZhbmNlX2Nsb2NrXG5lbmRcblxubGV0IGluX2N5Y2xlIHQgPSB0LmluX2N5Y2xlXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4hIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbm1vZHVsZSBDb3VudGluZ19zZW1hcGhvcmUgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHdhaXRfdG9fYWNxdWlyZV9qb2JfdG9rZW4gOiB0IC0+IHVuaXQgRGVmZXJyZWQudFxuICB2YWwgcmVsZWFzZV9qb2JfdG9rZW4gOiB0IC0+IHVuaXRcbiAgdmFsIGFib3J0IDogdCAtPiB1bml0XG4gIHZhbCBjcmVhdGUgOiBtYXhfY29uY3VycmVudF9qb2JzOmludCAtPiB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgbWF4X2NvbmN1cnJlbnRfam9icyA6IGludFxuICAgIDsgbXV0YWJsZSB3YWl0ZXIgOiB1bml0IEl2YXIudCBvcHRpb25cbiAgICA7IG11dGFibGUgYWJvcnRlZCA6IGJvb2xcbiAgICB9XG5cbiAgbGV0IHdhaXRfdG9fYWNxdWlyZV9qb2JfdG9rZW4gKHsgbWF4X2NvbmN1cnJlbnRfam9iczsgd2FpdGVyOyBhYm9ydGVkIH0gYXMgdCkgPVxuICAgIG1hdGNoIGFib3J0ZWQgd2l0aFxuICAgIHwgdHJ1ZSAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgIHwgZmFsc2UgLT5cbiAgICAgIGlmIG1heF9jb25jdXJyZW50X2pvYnMgPiAwXG4gICAgICB0aGVuIChcbiAgICAgICAgdC5tYXhfY29uY3VycmVudF9qb2JzIDwtIG1heF9jb25jdXJyZW50X2pvYnMgLSAxO1xuICAgICAgICBEZWZlcnJlZC5yZXR1cm4gKCkpXG4gICAgICBlbHNlIChcbiAgICAgICAgYXNzZXJ0IChPcHRpb24uaXNfbm9uZSB3YWl0ZXIpO1xuICAgICAgICBsZXQgaXZhciA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgICAgIHQud2FpdGVyIDwtIFNvbWUgaXZhcjtcbiAgICAgICAgSXZhci5yZWFkIGl2YXIpXG4gIDs7XG5cbiAgbGV0IHJlbGVhc2Vfam9iX3Rva2VuICh7IG1heF9jb25jdXJyZW50X2pvYnM7IHdhaXRlcjsgYWJvcnRlZCA9IF8gfSBhcyB0KSA9XG4gICAgbWF0Y2ggd2FpdGVyIHdpdGhcbiAgICB8IFNvbWUgaXZhciAtPlxuICAgICAgSXZhci5maWxsX2V4biBpdmFyICgpO1xuICAgICAgdC53YWl0ZXIgPC0gTm9uZVxuICAgIHwgTm9uZSAtPiB0Lm1heF9jb25jdXJyZW50X2pvYnMgPC0gbWF4X2NvbmN1cnJlbnRfam9icyArIDFcbiAgOztcblxuICBsZXQgYWJvcnQgdCA9XG4gICAgdC5hYm9ydGVkIDwtIHRydWU7XG4gICAgdC53YWl0ZXIgPC0gTm9uZVxuICA7O1xuXG4gIGxldCBjcmVhdGUgfm1heF9jb25jdXJyZW50X2pvYnMgPVxuICAgIHsgbWF4X2NvbmN1cnJlbnRfam9iczsgd2FpdGVyID0gTm9uZTsgYWJvcnRlZCA9IGZhbHNlIH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgY29tcHV0ZSA6XG4gICAgICAgIEV4ZWN1dGlvbl9jb250ZXh0LnQgLT4gQ291bnRpbmdfc2VtYXBob3JlLnQgLT4gKCdhIERlZmVycmVkLnQgLT4gdW5pdCkgLT4gdW5pdFxuICAgIH1cbiAgW0BAdW5ib3hlZF1cblxuICBsZXQgcmV0dXJuIHggPSB7IGNvbXB1dGUgPSAoZnVuIF8gXyBrIC0+IGsgKHJldHVybiB4KSkgfVxuXG4gIGxldCBtYXAgPVxuICAgIGBDdXN0b21cbiAgICAgIChmdW4gdCB+ZiAtPlxuICAgICAgICB7IGNvbXB1dGUgPVxuICAgICAgICAgICAgKGZ1biBleGVjX2N0eCBzZW1hcGhvcmUgayAtPlxuICAgICAgICAgICAgICB0LmNvbXB1dGUgZXhlY19jdHggc2VtYXBob3JlIChmdW4gZCAtPlxuICAgICAgICAgICAgICAgIGtcbiAgICAgICAgICAgICAgICAgIChsZXQlbWFwIHJlc3VsdCA9IGQgaW5cbiAgICAgICAgICAgICAgICAgICBmIHJlc3VsdCkpKVxuICAgICAgICB9KVxuICA7O1xuXG4gIGxldCBhcHBseSB0X2YgdCA9XG4gICAgeyBjb21wdXRlID1cbiAgICAgICAgKGZ1biBleGVjX2N0eCBzZW1hcGhvcmUgayAtPlxuICAgICAgICAgIHRfZi5jb21wdXRlIGV4ZWNfY3R4IHNlbWFwaG9yZSAoZnVuIGRmIC0+XG4gICAgICAgICAgICB0LmNvbXB1dGUgZXhlY19jdHggc2VtYXBob3JlIChmdW4gZHYgLT5cbiAgICAgICAgICAgICAga1xuICAgICAgICAgICAgICAgIChsZXQlYmluZCBmID0gZGYgaW5cbiAgICAgICAgICAgICAgICAgbGV0JW1hcCB2ID0gZHYgaW5cbiAgICAgICAgICAgICAgICAgZiB2KSkpKVxuICAgIH1cbiAgOztcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZSAoVClcblxubGV0IGVucXVldWUnIHNjaGVkdWxlciBjdHggZiA9XG4gIGxldCBpdmFyID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgU2NoZWR1bGVyLmVucXVldWUgc2NoZWR1bGVyIGN0eCAoZnVuICgpIC0+IHVwb24gKGYgKCkpIChJdmFyLmZpbGxfZXhuIGl2YXIpKSAoKTtcbiAgSXZhci5yZWFkIGl2YXJcbjs7XG5cbmxldCBqb2IgZiA9XG4gIHsgY29tcHV0ZSA9XG4gICAgICAoZnVuIGV4ZWNfY3R4IHNlbWFwaG9yZSBrIC0+XG4gICAgICAgIERlZmVycmVkLnVwb24gKENvdW50aW5nX3NlbWFwaG9yZS53YWl0X3RvX2FjcXVpcmVfam9iX3Rva2VuIHNlbWFwaG9yZSkgKGZ1biAoKSAtPlxuICAgICAgICAgIGtcbiAgICAgICAgICAgIChlbnF1ZXVlJyAoU2NoZWR1bGVyLnQgKCkpIGV4ZWNfY3R4IChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgIGxldCVtYXAgYSA9IGYgKCkgaW5cbiAgICAgICAgICAgICAgIENvdW50aW5nX3NlbWFwaG9yZS5yZWxlYXNlX2pvYl90b2tlbiBzZW1hcGhvcmU7XG4gICAgICAgICAgICAgICBhKSkpKVxuICB9XG47O1xuXG5sZXQgcnVuIHQgfm1heF9jb25jdXJyZW50X2pvYnMgPVxuICBsZXQgc2VtYXBob3JlID0gQ291bnRpbmdfc2VtYXBob3JlLmNyZWF0ZSB+bWF4X2NvbmN1cnJlbnRfam9icyBpblxuICAoKiBUaGUgbmFtZSBpcyBzZXQgdG8gdGhlIGVtcHR5IHN0cmluZyBpbiBvcmRlciB0byBwcmV2ZW50IFtNb25pdG9yLnNlbmRfZXhuXVxuICAgICBmcm9tIGFwcGVuZGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIG1vbml0b3IgdG8gdGhlIGV4Y2VwdGlvbnMgd2UgZm9yd2FyZC5cbiAgICAgVGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2Ugd2FudCBzaW1saWFyIGJlaGF2aW9yIHRvIFtUaHJvdHRsZV0gYW5kIG5vdCBicmVha1xuICAgICBleGlzdGluZyB0ZXN0cy4gKilcbiAgbGV0IG1vbml0b3IgPSBNb25pdG9yLmNyZWF0ZSB+bmFtZTpcIlwiICgpIGluXG4gIGxldCBwYXJlbnRfbW9uaXRvciA9IE1vbml0b3IuY3VycmVudCAoKSBpblxuICBNb25pdG9yLmRldGFjaF9hbmRfaXRlcl9lcnJvcnMgbW9uaXRvciB+ZjooZnVuIGVyciAtPlxuICAgIENvdW50aW5nX3NlbWFwaG9yZS5hYm9ydCBzZW1hcGhvcmU7XG4gICAgTW9uaXRvci5zZW5kX2V4biBwYXJlbnRfbW9uaXRvciBlcnIpO1xuICBsZXQgZXhlY19jdHggPVxuICAgIEV4ZWN1dGlvbl9jb250ZXh0LmNyZWF0ZV9saWtlXG4gICAgICB+bW9uaXRvclxuICAgICAgKFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IChTY2hlZHVsZXIudCAoKSkpXG4gIGluXG4gIGxldCBpdmFyID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgdC5jb21wdXRlIGV4ZWNfY3R4IHNlbWFwaG9yZSAoZnVuIHIgLT4gRGVmZXJyZWQudXBvbiByIChJdmFyLmZpbGxfZXhuIGl2YXIpKTtcbiAgSXZhci5yZWFkIGl2YXJcbjs7XG5cbmxldCBvZl90aHVuayB0aHVuayA9XG4gIHsgY29tcHV0ZSA9XG4gICAgICAoZnVuIGV4ZWNfY3R4IHNlbWFwaG9yZSBrIC0+XG4gICAgICAgIGxldCB0ID0gdGh1bmsgKCkgaW5cbiAgICAgICAgdC5jb21wdXRlIGV4ZWNfY3R4IHNlbWFwaG9yZSBrKVxuICB9XG47O1xuXG5sZXQgKCAqPiApIHQxIHQyID1cbiAgeyBjb21wdXRlID1cbiAgICAgIChmdW4gZXhlY19jdHggc2VtYXBob3JlIGsgLT5cbiAgICAgICAgdDEuY29tcHV0ZSBleGVjX2N0eCBzZW1hcGhvcmUgKGZ1biBkMSAtPlxuICAgICAgICAgIHQyLmNvbXB1dGUgZXhlY19jdHggc2VtYXBob3JlIChmdW4gZDIgLT5cbiAgICAgICAgICAgIGtcbiAgICAgICAgICAgICAgKGxldCViaW5kICgpID0gZDEgaW5cbiAgICAgICAgICAgICAgIGQyKSkpKVxuICB9XG47O1xuXG5sZXQgYm90aF91bml0ID0gKCAqPiApXG4iLCJvcGVuISBCYXNlXG5cbnR5cGUgXyB0ID1cbiAgfCBTdGFjayA6ICdhIFN0YWNrLnQgLT4gJ2EgdFxuICB8IENvdW50ZXIgOiB7IG11dGFibGUgbGVuZ3RoIDogaW50IH0gLT4gdW5pdCB0XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgb2ZfbGlzdCBsaXN0ID0gU3RhY2sgKFN0YWNrLm9mX2xpc3QgbGlzdClcblxubGV0IGNyZWF0ZV9jb3VudGVyIH5sZW5ndGggPVxuICBpZiBsZW5ndGggPCAwXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2UgXCJbU3RhY2tfb3JfY291bnRlci5jcmVhdGVfY291bnRlcl0gZ290IG5lZ2F0aXZlIGxlbmd0aFwiIChsZW5ndGggOiBpbnQpXTtcbiAgQ291bnRlciB7IGxlbmd0aCB9XG47O1xuXG5sZXQgbGVuZ3RoICh0eXBlIGEpICh0IDogYSB0KSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFN0YWNrIHMgLT4gU3RhY2subGVuZ3RoIHNcbiAgfCBDb3VudGVyIHIgLT4gci5sZW5ndGhcbjs7XG5cbmxldCBjbGVhciAodHlwZSBhKSAodCA6IGEgdCkgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLmNsZWFyIHNcbiAgfCBDb3VudGVyIHIgLT4gci5sZW5ndGggPC0gMFxuOztcblxubGV0IHB1c2ggKHR5cGUgYSkgKHQgOiBhIHQpIGEgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLnB1c2ggcyBhXG4gIHwgQ291bnRlciByIC0+IHIubGVuZ3RoIDwtIHIubGVuZ3RoICsgMVxuOztcblxubGV0IHBvcF9leG4gKHR5cGUgYSkgKHQgOiBhIHQpID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU3RhY2sgcyAtPiBTdGFjay5wb3BfZXhuIHNcbiAgfCBDb3VudGVyIHIgLT5cbiAgICBpZiByLmxlbmd0aCA9IDAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIltTdGFja19vcl9jb3VudGVyLnBvcF9leG5dIG9mIGVtcHR5IHN0YWNrXCJdO1xuICAgIHIubGVuZ3RoIDwtIHIubGVuZ3RoIC0gMVxuOztcblxubGV0IGl0ZXIgKHR5cGUgYSkgKHQgOiBhIHQpIH4oZiA6IGEgLT4gdW5pdCkgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLml0ZXIgcyB+ZlxuICB8IENvdW50ZXIgciAtPlxuICAgIGZvciBfID0gMSB0byByLmxlbmd0aCBkb1xuICAgICAgZiAoKVxuICAgIGRvbmVcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4hIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbnR5cGUgJ2Egb3V0Y29tZSA9XG4gIFsgYE9rIG9mICdhXG4gIHwgYEFib3J0ZWRcbiAgfCBgUmFpc2VkIG9mIGV4blxuICBdXG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5tb2R1bGUgSW50ZXJuYWxfam9iIDogc2lnXG4gIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHZhbCBjcmVhdGVcbiAgICA6ICByZXN0OlsgYExvZyB8IGBSYWlzZSB8IGBDYWxsIG9mIGV4biAtPiB1bml0IF1cbiAgICAtPiAoJ2EgLT4gJ2IgRGVmZXJyZWQudClcbiAgICAtPiAnYSB0ICogJ2Igb3V0Y29tZSBEZWZlcnJlZC50XG5cbiAgKCogRXZlcnkgaW50ZXJuYWwgam9iIHdpbGwgZXZlbnR1YWxseSBiZSBlaXRoZXIgW3J1bl0gb3IgW2Fib3J0XWVkLCBidXQgbm90IGJvdGguICopXG5cbiAgdmFsIHJ1biA6ICdhIHQgLT4gJ2EgLT4gWyBgT2sgfCBgUmFpc2VkIF0gRGVmZXJyZWQudFxuICB2YWwgYWJvcnQgOiBfIHQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBzdGFydCA6IFsgYEFib3J0IHwgYFN0YXJ0IG9mICdhIF0gSXZhci50XG4gICAgOyBvdXRjb21lIDogWyBgT2sgfCBgQWJvcnRlZCB8IGBSYWlzZWQgXSBEZWZlcnJlZC50XG4gICAgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBjcmVhdGUgfnJlc3Qgd29yayA9XG4gICAgbGV0IHN0YXJ0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICBsZXQgcmVzdWx0ID1cbiAgICAgIG1hdGNoJWJpbmQgSXZhci5yZWFkIHN0YXJ0IHdpdGhcbiAgICAgIHwgYEFib3J0IC0+IHJldHVybiBgQWJvcnRlZFxuICAgICAgfCBgU3RhcnQgYSAtPlxuICAgICAgICAobWF0Y2glbWFwIE1vbml0b3IudHJ5X3dpdGggfnJ1bjpgU2NoZWR1bGUgfnJlc3QgKGZ1biAoKSAtPiB3b3JrIGEpIHdpdGhcbiAgICAgICAgIHwgT2sgYSAtPiBgT2sgYVxuICAgICAgICAgfCBFcnJvciBleG4gLT4gYFJhaXNlZCBleG4pXG4gICAgaW5cbiAgICBsZXQgb3V0Y29tZSA9XG4gICAgICBtYXRjaCVtYXAgcmVzdWx0IHdpdGhcbiAgICAgIHwgYE9rIF8gLT4gYE9rXG4gICAgICB8IGBBYm9ydGVkIC0+IGBBYm9ydGVkXG4gICAgICB8IGBSYWlzZWQgXyAtPiBgUmFpc2VkXG4gICAgaW5cbiAgICBsZXQgdCA9IHsgc3RhcnQ7IG91dGNvbWUgfSBpblxuICAgIHQsIHJlc3VsdFxuICA7O1xuXG4gIGxldCBydW4gdCBhID1cbiAgICBJdmFyLmZpbGxfZXhuIHQuc3RhcnQgKGBTdGFydCBhKTtcbiAgICBtYXRjaCVtYXAgdC5vdXRjb21lIHdpdGhcbiAgICB8IGBBYm9ydGVkIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgKGBPayB8IGBSYWlzZWQpIGFzIHggLT4geFxuICA7O1xuXG4gIGxldCBhYm9ydCB0ID0gSXZhci5maWxsX2V4biB0LnN0YXJ0IGBBYm9ydFxuZW5kXG5cbnR5cGUgJ2EgdCA9XG4gIHsgY29udGludWVfb25fZXJyb3IgOiBib29sXG4gIDsgcmVzdCA6IFsgYExvZyB8IGBSYWlzZSB8IGBDYWxsIG9mIGV4biAtPiB1bml0IF1cbiAgOyBtYXhfY29uY3VycmVudF9qb2JzIDogaW50XG4gIDsgKCogW2pvYl9yZXNvdXJjZXNfbm90X2luX3VzZV0gaG9sZHMgcmVzb3VyY2VzIHRoYXQgYXJlIG5vdCBjdXJyZW50bHkgaW4gdXNlIGJ5IGFcbiAgICAgICBydW5uaW5nIGpvYi4gKilcbiAgICBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgOiAnYSBTdGFja19vcl9jb3VudGVyLnRcbiAgOyAoKiBbam9ic193YWl0aW5nX3RvX3N0YXJ0XSBpcyB0aGUgcXVldWUgb2Ygam9icyB0aGF0IGhhdmVuJ3QgeWV0IHN0YXJ0ZWQuICopXG4gICAgam9ic193YWl0aW5nX3RvX3N0YXJ0IDogJ2EgSW50ZXJuYWxfam9iLnQgUXVldWUudFxuICA7ICgqIFswIDw9IG51bV9qb2JzX3J1bm5pbmcgPD0gbWF4X2NvbmN1cnJlbnRfam9ic10uICopXG4gICAgbXV0YWJsZSBudW1fam9ic19ydW5uaW5nIDogaW50XG4gIDsgKCogW2NhcGFjaXR5X2F2YWlsYWJsZV0gaXMgW1NvbWUgaXZhcl0gaWYgdXNlciBjb2RlIGhhcyBjYWxsZWQgW2NhcGFjaXR5X2F2YWlsYWJsZSB0XVxuICAgICAgIGFuZCBpcyB3YWl0aW5nIHRvIGJlIG5vdGlmaWVkIHdoZW4gY2FwYWNpdHkgaXMgYXZhaWxhYmxlIGluIHRoZSB0aHJvdHRsZS5cbiAgICAgICBbbWF5YmVfc3RhcnRfam9iXSB3aWxsIGZpbGwgW2l2YXJdIHdoZW4gY2FwYWNpdHkgYmVjb21lcyBhdmFpbGFibGUsIGkuZS4gd2hlblxuICAgICAgIFtqb2JzX3dhaXRpbmdfdG9fc3RhcnRdIGlzIGVtcHR5IGFuZCBbbnVtX2pvYnNfcnVubmluZyA8IG1heF9jb25jdXJyZW50X2pvYnNdLiAqKVxuICAgIG11dGFibGUgY2FwYWNpdHlfYXZhaWxhYmxlIDogdW5pdCBJdmFyLnQgb3B0aW9uXG4gIDsgKCogW2lzX2RlYWRdIGlzIHRydWUgaWYgW3RdIHdhcyBraWxsZWQgZHVlIHRvIGEgam9iIHJhaXNpbmcgYW4gZXhjZXB0aW9uIG9yIFtraWxsIHRdXG4gICAgICAgYmVpbmcgY2FsbGVkLiAqKVxuICAgIG11dGFibGUgaXNfZGVhZCA6IGJvb2xcbiAgOyAoKiBbY2xlYW5zXSBob2xkcyBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGNhbGxlZCB0byBjbGVhbiBlYWNoIHJlc291cmNlIHdoZW4gW3RdIGlzXG4gICAgICAga2lsbGVkLiAqKVxuICAgIG11dGFibGUgY2xlYW5zIDogKCdhIC0+IHVuaXQgRGVmZXJyZWQudCkgbGlzdFxuICA7ICgqIFtudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkXSBpcyB0aGUgbnVtYmVyIG9mIHJlc291cmNlcyB3aG9zZSBjbGVhbiBmdW5jdGlvbnMgaGF2ZVxuICAgICAgIG5vdCB5ZXQgY29tcGxldGVkLiAgV2hpbGUgW3RdIGlzIGFsaXZlLCBbbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA9XG4gICAgICAgbWF4X2NvbmN1cnJlbnRfam9ic10uICBPbmNlIFt0XSBpcyBraWxsZWQsIFtudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkXSBkZWNyZWFzZXMgdG9cbiAgICAgICB6ZXJvIG92ZXIgdGltZSBhcyB0aGUgY2xlYW4gZnVuY3Rpb25zIGNvbXBsZXRlLiAqKVxuICAgIG11dGFibGUgbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA6IGludFxuICA7ICgqIFtjbGVhbmVkXSBiZWNvbWVzIGRldGVybWluZWQgd2hlbiBbbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZF0gcmVhY2hlcyB6ZXJvLFxuICAgICAgIGkuZS4gYWZ0ZXIgW3RdIGlzIGtpbGxlZCBhbmQgYWxsIGl0cyBjbGVhbiBmdW5jdGlvbnMgY29tcGxldGUuICopXG4gICAgY2xlYW5lZCA6IHVuaXQgSXZhci50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+Y29udGludWVfb25fZXJyb3I6aWdub3JlXG4gICAgICB+cmVzdDppZ25vcmVcbiAgICAgIH5tYXhfY29uY3VycmVudF9qb2JzOlxuICAgICAgICAoY2hlY2sgKGZ1biBtYXhfY29uY3VycmVudF9qb2JzIC0+IGFzc2VydCAobWF4X2NvbmN1cnJlbnRfam9icyA+IDApKSlcbiAgICAgIH5qb2JfcmVzb3VyY2VzX25vdF9pbl91c2U6XG4gICAgICAgIChjaGVjayAoZnVuIGpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSAtPlxuICAgICAgICAgICBTdGFja19vcl9jb3VudGVyLml0ZXIgam9iX3Jlc291cmNlc19ub3RfaW5fdXNlIH5mOmludmFyaWFudF9hO1xuICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgIFN0YWNrX29yX2NvdW50ZXIubGVuZ3RoIGpvYl9yZXNvdXJjZXNfbm90X2luX3VzZVxuICAgICAgICAgICAgID0gaWYgdC5pc19kZWFkIHRoZW4gMCBlbHNlIHQubWF4X2NvbmN1cnJlbnRfam9icyAtIHQubnVtX2pvYnNfcnVubmluZykpKVxuICAgICAgfmpvYnNfd2FpdGluZ190b19zdGFydDpcbiAgICAgICAgKGNoZWNrIChmdW5jdGlvbiBqb2JzX3dhaXRpbmdfdG9fc3RhcnQgLT5cbiAgICAgICAgICAgaWYgdC5pc19kZWFkIHRoZW4gYXNzZXJ0IChRdWV1ZS5pc19lbXB0eSBqb2JzX3dhaXRpbmdfdG9fc3RhcnQpKSlcbiAgICAgIH5udW1fam9ic19ydW5uaW5nOlxuICAgICAgICAoY2hlY2sgKGZ1biBudW1fam9ic19ydW5uaW5nIC0+XG4gICAgICAgICAgIGFzc2VydCAobnVtX2pvYnNfcnVubmluZyA+PSAwKTtcbiAgICAgICAgICAgYXNzZXJ0IChudW1fam9ic19ydW5uaW5nIDw9IHQubWF4X2NvbmN1cnJlbnRfam9icyk7XG4gICAgICAgICAgIGlmIG51bV9qb2JzX3J1bm5pbmcgPCB0Lm1heF9jb25jdXJyZW50X2pvYnNcbiAgICAgICAgICAgdGhlbiBhc3NlcnQgKFF1ZXVlLmlzX2VtcHR5IHQuam9ic193YWl0aW5nX3RvX3N0YXJ0KSkpXG4gICAgICB+Y2FwYWNpdHlfYXZhaWxhYmxlOlxuICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIGl2YXIgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKSlcbiAgICAgIH5pc19kZWFkOmlnbm9yZVxuICAgICAgfmNsZWFuczppZ25vcmVcbiAgICAgIH5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkOlxuICAgICAgICAoY2hlY2sgKGZ1biBudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIC0+XG4gICAgICAgICAgIGFzc2VydCAobnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA+PSAwKTtcbiAgICAgICAgICAgYXNzZXJ0IChudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIDw9IHQubWF4X2NvbmN1cnJlbnRfam9icyk7XG4gICAgICAgICAgIGlmIG51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPCB0Lm1heF9jb25jdXJyZW50X2pvYnMgdGhlbiBhc3NlcnQgdC5pc19kZWFkKSlcbiAgICAgIH5jbGVhbmVkOlxuICAgICAgICAoY2hlY2sgKGZ1biBjbGVhbmVkIC0+XG4gICAgICAgICAgIGlmIEl2YXIuaXNfZnVsbCBjbGVhbmVkIHRoZW4gYXNzZXJ0ICh0Lm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPSAwKSkpXG4gIHdpdGhcbiAgfCBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJUaHJvdHRsZS5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgKHQgOiBfIHQpXVxuOztcblxubW9kdWxlIFQyID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2tpbmQpIHQgPSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBfIHQgPSBpbnZhcmlhbnQgaW52YXJpYW50X2EgdFxuZW5kXG5cbmxldCBudW1fam9ic193YWl0aW5nX3RvX3N0YXJ0IHQgPSBRdWV1ZS5sZW5ndGggdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnRcblxubGV0IGNsZWFuX3Jlc291cmNlIHQgYSA9XG4gIERlZmVycmVkLmFsbF91bml0IChMaXN0Lm1hcCB0LmNsZWFucyB+ZjooZnVuIGYgLT4gZiBhKSlcbiAgPj4+IGZ1biAoKSAtPlxuICB0Lm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPC0gdC5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIC0gMTtcbiAgaWYgdC5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkID0gMCB0aGVuIEl2YXIuZmlsbF9leG4gdC5jbGVhbmVkICgpXG47O1xuXG5sZXQga2lsbCB0ID1cbiAgaWYgbm90IHQuaXNfZGVhZFxuICB0aGVuIChcbiAgICB0LmlzX2RlYWQgPC0gdHJ1ZTtcbiAgICBRdWV1ZS5pdGVyIHQuam9ic193YWl0aW5nX3RvX3N0YXJ0IH5mOkludGVybmFsX2pvYi5hYm9ydDtcbiAgICBRdWV1ZS5jbGVhciB0LmpvYnNfd2FpdGluZ190b19zdGFydDtcbiAgICBTdGFja19vcl9jb3VudGVyLml0ZXIgdC5qb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgfmY6KGZ1biBhIC0+IGNsZWFuX3Jlc291cmNlIHQgYSk7XG4gICAgU3RhY2tfb3JfY291bnRlci5jbGVhciB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSlcbjs7XG5cbmxldCBhdF9raWxsIHQgZiA9XG4gICgqIFdlIHByZXNlcnZlIHRoZSBleGVjdXRpb24gY29udGV4dCBzbyB0aGF0IGV4Y2VwdGlvbnMgcmFpc2VkIGJ5IFtmXSBnbyB0byB0aGUgbW9uaXRvclxuICAgICBpbiBlZmZlY3Qgd2hlbiBbYXRfa2lsbF0gd2FzIGNhbGxlZC4gKilcbiAgbGV0IGYgPSB1bnN0YWdlIChNb25pdG9yLkV4cG9ydGVkX2Zvcl9zY2hlZHVsZXIucHJlc2VydmVfZXhlY3V0aW9uX2NvbnRleHQnIGYpIGluXG4gIHQuY2xlYW5zIDwtIGYgOjogdC5jbGVhbnNcbjs7XG5cbmxldCBjbGVhbmVkIHQgPSBJdmFyLnJlYWQgdC5jbGVhbmVkXG5cbmxldCByZWMgc3RhcnRfam9iIHQgPVxuICBhc3NlcnQgKG5vdCB0LmlzX2RlYWQpO1xuICBhc3NlcnQgKHQubnVtX2pvYnNfcnVubmluZyA8IHQubWF4X2NvbmN1cnJlbnRfam9icyk7XG4gIGFzc2VydCAobm90IChRdWV1ZS5pc19lbXB0eSB0LmpvYnNfd2FpdGluZ190b19zdGFydCkpO1xuICBsZXQgam9iID0gUXVldWUuZGVxdWV1ZV9leG4gdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnQgaW5cbiAgdC5udW1fam9ic19ydW5uaW5nIDwtIHQubnVtX2pvYnNfcnVubmluZyArIDE7XG4gIGxldCBqb2JfcmVzb3VyY2UgPSBTdGFja19vcl9jb3VudGVyLnBvcF9leG4gdC5qb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgaW5cbiAgSW50ZXJuYWxfam9iLnJ1biBqb2Igam9iX3Jlc291cmNlXG4gID4+PiBmdW4gcmVzIC0+XG4gIHQubnVtX2pvYnNfcnVubmluZyA8LSB0Lm51bV9qb2JzX3J1bm5pbmcgLSAxO1xuICAobWF0Y2ggcmVzIHdpdGhcbiAgIHwgYE9rIC0+ICgpXG4gICB8IGBSYWlzZWQgLT4gaWYgbm90IHQuY29udGludWVfb25fZXJyb3IgdGhlbiBraWxsIHQpO1xuICBpZiB0LmlzX2RlYWRcbiAgdGhlbiBjbGVhbl9yZXNvdXJjZSB0IGpvYl9yZXNvdXJjZVxuICBlbHNlIChcbiAgICBTdGFja19vcl9jb3VudGVyLnB1c2ggdC5qb2JfcmVzb3VyY2VzX25vdF9pbl91c2Ugam9iX3Jlc291cmNlO1xuICAgIGlmIG5vdCAoUXVldWUuaXNfZW1wdHkgdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnQpXG4gICAgdGhlbiBzdGFydF9qb2IgdFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggdC5jYXBhY2l0eV9hdmFpbGFibGUgd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgaXZhciAtPlxuICAgICAgICBJdmFyLmZpbGxfZXhuIGl2YXIgKCk7XG4gICAgICAgIHQuY2FwYWNpdHlfYXZhaWxhYmxlIDwtIE5vbmUpKVxuOztcblxubGV0IGNyZWF0ZV9pbnRlcm5hbCB+Y29udGludWVfb25fZXJyb3IgfnJlc3Qgam9iX3Jlc291cmNlcyA9XG4gIGxldCBtYXhfY29uY3VycmVudF9qb2JzID0gU3RhY2tfb3JfY291bnRlci5sZW5ndGggam9iX3Jlc291cmNlcyBpblxuICB7IGNvbnRpbnVlX29uX2Vycm9yXG4gIDsgcmVzdFxuICA7IG1heF9jb25jdXJyZW50X2pvYnNcbiAgOyBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgPSBqb2JfcmVzb3VyY2VzXG4gIDsgam9ic193YWl0aW5nX3RvX3N0YXJ0ID0gUXVldWUuY3JlYXRlICgpXG4gIDsgbnVtX2pvYnNfcnVubmluZyA9IDBcbiAgOyBjYXBhY2l0eV9hdmFpbGFibGUgPSBOb25lXG4gIDsgaXNfZGVhZCA9IGZhbHNlXG4gIDsgY2xlYW5zID0gW11cbiAgOyBudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkID0gbWF4X2NvbmN1cnJlbnRfam9ic1xuICA7IGNsZWFuZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICB9XG47O1xuXG5sZXQgY3JlYXRlX3dpdGgnIH5yZXN0IH5jb250aW51ZV9vbl9lcnJvciBqb2JfcmVzb3VyY2VzID1cbiAgY3JlYXRlX2ludGVybmFsIH5yZXN0IH5jb250aW51ZV9vbl9lcnJvciAoU3RhY2tfb3JfY291bnRlci5vZl9saXN0IGpvYl9yZXNvdXJjZXMpXG47O1xuXG5sZXQgY3JlYXRlX3dpdGggfmNvbnRpbnVlX29uX2Vycm9yIGpvYl9yZXNvdXJjZXMgPVxuICBjcmVhdGVfd2l0aCcgfnJlc3Q6YExvZyB+Y29udGludWVfb25fZXJyb3Igam9iX3Jlc291cmNlc1xuOztcblxubW9kdWxlIFNlcXVlbmNlciA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBjcmVhdGUgPyhyZXN0ID0gYExvZykgPyhjb250aW51ZV9vbl9lcnJvciA9IGZhbHNlKSBhID1cbiAgICBjcmVhdGVfd2l0aCcgfnJlc3QgfmNvbnRpbnVlX29uX2Vycm9yIFsgYSBdXG4gIDs7XG5lbmRcblxubGV0IGNyZWF0ZScgfnJlc3QgfmNvbnRpbnVlX29uX2Vycm9yIH5tYXhfY29uY3VycmVudF9qb2JzID1cbiAgaWYgbWF4X2NvbmN1cnJlbnRfam9icyA8PSAwXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaHJvdHRsZS5jcmVhdGUgcmVxdWlyZXMgcG9zaXRpdmUgbWF4X2NvbmN1cnJlbnRfam9icywgYnV0IGdvdFwiXG4gICAgICAgICAgKG1heF9jb25jdXJyZW50X2pvYnMgOiBpbnQpXTtcbiAgY3JlYXRlX2ludGVybmFsXG4gICAgfnJlc3RcbiAgICB+Y29udGludWVfb25fZXJyb3JcbiAgICAoU3RhY2tfb3JfY291bnRlci5jcmVhdGVfY291bnRlciB+bGVuZ3RoOm1heF9jb25jdXJyZW50X2pvYnMpXG47O1xuXG5sZXQgY3JlYXRlIH5jb250aW51ZV9vbl9lcnJvciB+bWF4X2NvbmN1cnJlbnRfam9icyA9XG4gIGNyZWF0ZScgfnJlc3Q6YExvZyB+Y29udGludWVfb25fZXJyb3Igfm1heF9jb25jdXJyZW50X2pvYnNcbjs7XG5cbm1vZHVsZSBKb2IgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB7IGludGVybmFsX2pvYiA6ICdhIEludGVybmFsX2pvYi50XG4gICAgOyByZXN1bHQgOiBbIGBPayBvZiAnYiB8IGBBYm9ydGVkIHwgYFJhaXNlZCBvZiBleG4gXSBEZWZlcnJlZC50XG4gICAgfVxuXG4gIGxldCByZXN1bHQgdCA9IHQucmVzdWx0XG4gIGxldCBhYm9ydCB0ID0gSW50ZXJuYWxfam9iLmFib3J0IHQuaW50ZXJuYWxfam9iXG5cbiAgbGV0IGNyZWF0ZSB+cmVzdCBmID1cbiAgICBsZXQgaW50ZXJuYWxfam9iLCByZXN1bHQgPSBJbnRlcm5hbF9qb2IuY3JlYXRlIH5yZXN0IGYgaW5cbiAgICB7IGludGVybmFsX2pvYjsgcmVzdWx0IH1cbiAgOztcbmVuZFxuXG5sZXQgZW5xdWV1ZV9pbnRlcm5hbCB0IGYgZW5xdWV1ZSA9XG4gIGxldCBqb2IgPSBKb2IuY3JlYXRlIH5yZXN0OnQucmVzdCBmIGluXG4gIGlmIHQuaXNfZGVhZFxuICB0aGVuIEpvYi5hYm9ydCBqb2JcbiAgZWxzZSAoXG4gICAgZW5xdWV1ZSB0LmpvYnNfd2FpdGluZ190b19zdGFydCBqb2IuaW50ZXJuYWxfam9iO1xuICAgIGlmIHQubnVtX2pvYnNfcnVubmluZyA8IHQubWF4X2NvbmN1cnJlbnRfam9icyB0aGVuIHN0YXJ0X2pvYiB0KTtcbiAgSm9iLnJlc3VsdCBqb2Jcbjs7XG5cbmxldCBoYW5kbGVfZW5xdWV1ZV9yZXN1bHQgcmVzdWx0ID1cbiAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgfCBgT2sgYSAtPiBhXG4gIHwgYEFib3J0ZWQgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJ0aHJvdHRsZSBhYm9ydGVkIGpvYlwiXVxuICB8IGBSYWlzZWQgZXhuIC0+IHJhaXNlIGV4blxuOztcblxubGV0IGVucXVldWUnIHQgZiA9IChlbnF1ZXVlX2ludGVybmFsIFtAaW5saW5lZF0pIHQgZiBRdWV1ZS5lbnF1ZXVlXG5sZXQgZW5xdWV1ZSB0IGYgPSBlbnF1ZXVlJyB0IGYgPj58IGhhbmRsZV9lbnF1ZXVlX3Jlc3VsdFxubGV0IGVucXVldWVfZnJvbnQnIHQgZiA9IChlbnF1ZXVlX2ludGVybmFsIFtAaW5saW5lZF0pIHQgZiBRdWV1ZS5lbnF1ZXVlX2Zyb250XG5sZXQgZW5xdWV1ZV9mcm9udCB0IGYgPSBlbnF1ZXVlX2Zyb250JyB0IGYgPj58IGhhbmRsZV9lbnF1ZXVlX3Jlc3VsdFxuXG5sZXQgZW5xdWV1ZV9leGNsdXNpdmUgdCBmID1cbiAgbGV0IG4gPSB0Lm1heF9jb25jdXJyZW50X2pvYnMgaW5cbiAgaWYgSW50LiggPj0gKSBuIDFfMDAwXzAwMFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVzZXhwXG4gICAgICAgIFwiW2VucXVldWVfZXhjbHVzaXZlXSB3YXMgY2FsbGVkIHdpdGggYSB2ZXJ5IGxhcmdlIHZhbHVlIG9mIFxcXG4gICAgICAgICBbbWF4X2NvbmN1cnJlbnRfam9ic10uIFRoaXMgZG9lc24ndCB3b3JrLlwiXTtcbiAgbGV0IGRvbmVfID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgYXNzZXJ0IChuID4gMCk7XG4gIGxldCBmX3BsYWNlaG9sZGVyIF9zbG90ID0gSXZhci5yZWFkIGRvbmVfIGluXG4gIGZvciBfID0gMSB0byBuIC0gMSBkb1xuICAgIGRvbid0X3dhaXRfZm9yIChlbnF1ZXVlIHQgZl9wbGFjZWhvbGRlcilcbiAgZG9uZTtcbiAgbGV0JW1hcCByZXN1bHQgPSBlbnF1ZXVlJyB0IChmdW4gX3Nsb3QgLT4gZiAoKSkgaW5cbiAgSXZhci5maWxsX2V4biBkb25lXyAoKTtcbiAgaGFuZGxlX2VucXVldWVfcmVzdWx0IHJlc3VsdFxuOztcblxubGV0IG1vbmFkX3NlcXVlbmNlX2hvdyB+aG93IH5mID1cbiAgc3RhZ2VcbiAgICAobWF0Y2ggaG93IHdpdGhcbiAgICAgfCBgUGFyYWxsZWwgLT4gZlxuICAgICB8IChgU2VxdWVudGlhbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgICAgIGxldCBtYXhfY29uY3VycmVudF9qb2JzID1cbiAgICAgICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgICAgICB8IGBTZXF1ZW50aWFsIC0+IDFcbiAgICAgICAgIHwgYE1heF9jb25jdXJyZW50X2pvYnMgbWF4X2NvbmN1cnJlbnRfam9icyAtPiBtYXhfY29uY3VycmVudF9qb2JzXG4gICAgICAgaW5cbiAgICAgICBsZXQgdCA9IGNyZWF0ZSB+Y29udGludWVfb25fZXJyb3I6ZmFsc2Ugfm1heF9jb25jdXJyZW50X2pvYnMgaW5cbiAgICAgICBmdW4gYSAtPiBlbnF1ZXVlIHQgKGZ1biAoKSAtPiBmIGEpKVxuOztcblxubGV0IG1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZiA9XG4gIHN0YWdlXG4gICAgKG1hdGNoIGhvdyB3aXRoXG4gICAgIHwgYFBhcmFsbGVsIC0+IGZcbiAgICAgfCAoYFNlcXVlbnRpYWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgICBsZXQgbWF4X2NvbmN1cnJlbnRfam9icyA9XG4gICAgICAgICBtYXRjaCBob3cgd2l0aFxuICAgICAgICAgfCBgU2VxdWVudGlhbCAtPiAxXG4gICAgICAgICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG1heF9jb25jdXJyZW50X2pvYnMgLT4gbWF4X2NvbmN1cnJlbnRfam9ic1xuICAgICAgIGluXG4gICAgICAgbGV0IHQgPSBjcmVhdGUgfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlIH5tYXhfY29uY3VycmVudF9qb2JzIGluXG4gICAgICAgZnVuIGExIGEyIC0+IGVucXVldWUgdCAoZnVuICgpIC0+IGYgYTEgYTIpKVxuOztcblxubGV0IHByaW9yX2pvYnNfZG9uZSB0ID1cbiAgKCogV2UgcXVldWUgW3QubWF4X2NvbmN1cnJlbnRfam9ic10gZHVtbXkgam9icyBhbmQgd2hlbiB0aGV5IGFyZSBhbGwgc3RhcnRlZCB3ZSBrbm93XG4gICAgIHRoYXQgYWxsIHByaW9yIGpvYnMgZmluaXNoZWQuICBXZSBtYWtlIHN1cmUgdGhhdCBhbGwgZHVtbXkgam9icyB3YWl0IGZvciB0aGUgbGFzdCBvbmVcbiAgICAgdG8gZ2V0IHN0YXJ0ZWQgYmVmb3JlIGZpbmlzaGluZy4gKilcbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gYWxsX2R1bW15X2pvYnNfcnVubmluZyAtPlxuICAgIGxldCBkdW1teV9qb2JzX3J1bm5pbmcgPSByZWYgMCBpblxuICAgIGZvciBfID0gMSB0byB0Lm1heF9jb25jdXJyZW50X2pvYnMgZG9cbiAgICAgIGRvbid0X3dhaXRfZm9yXG4gICAgICAgIChlbnF1ZXVlIHQgKGZ1biBfIC0+XG4gICAgICAgICAgIGluY3IgZHVtbXlfam9ic19ydW5uaW5nO1xuICAgICAgICAgICBpZiAhZHVtbXlfam9ic19ydW5uaW5nID0gdC5tYXhfY29uY3VycmVudF9qb2JzXG4gICAgICAgICAgIHRoZW4gSXZhci5maWxsX2V4biBhbGxfZHVtbXlfam9ic19ydW5uaW5nICgpO1xuICAgICAgICAgICBJdmFyLnJlYWQgYWxsX2R1bW15X2pvYnNfcnVubmluZykpXG4gICAgZG9uZSlcbjs7XG5cbmxldCBjYXBhY2l0eV9hdmFpbGFibGUgdCA9XG4gIGlmIG51bV9qb2JzX3J1bm5pbmcgdCA8IG1heF9jb25jdXJyZW50X2pvYnMgdFxuICB0aGVuIHJldHVybiAoKVxuICBlbHNlIChcbiAgICBtYXRjaCB0LmNhcGFjaXR5X2F2YWlsYWJsZSB3aXRoXG4gICAgfCBTb21lIGl2YXIgLT4gSXZhci5yZWFkIGl2YXJcbiAgICB8IE5vbmUgLT4gRGVmZXJyZWQuY3JlYXRlIChmdW4gaXZhciAtPiB0LmNhcGFjaXR5X2F2YWlsYWJsZSA8LSBTb21lIGl2YXIpKVxuOztcbiIsIm9wZW4hIENvcmVcbmluY2x1ZGUgU3luY2hyb25vdXNfdGltZV9zb3VyY2UwXG5cbmxldCBjcmVhdGUgPSBTY2hlZHVsZXIxLmNyZWF0ZV90aW1lX3NvdXJjZVxubGV0IHdhbGxfY2xvY2sgPSBTY2hlZHVsZXIxLndhbGxfY2xvY2tcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTY2hlZHVsZXJcblxubGV0IGVucXVldWVfam9iIGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9IGVucXVldWUgKHQgKCkpIGV4ZWN1dGlvbl9jb250ZXh0IGYgYVxuXG5sZXQgdGhyZWFkX3NhZmVfZW5xdWV1ZV9qb2IgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgdGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qb2IgKHQgKCkpIGV4ZWN1dGlvbl9jb250ZXh0IGYgYVxuOztcblxubGV0IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKCkgPSBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKVxubGV0IGN5Y2xlX2NvdW50ICgpID0gY3ljbGVfY291bnQgKHQgKCkpXG5sZXQgY3ljbGVfc3RhcnRfbnMgKCkgPSBjeWNsZV9zdGFydCAodCAoKSlcbmxldCBjeWNsZV9zdGFydCAoKSA9IFRpbWVfbnMudG9fdGltZV9mbG9hdF9yb3VuZF9uZWFyZXN0IChjeWNsZV9zdGFydF9ucyAoKSlcbmxldCBjeWNsZV90aW1lc19ucyAoKSA9IG1hcF9jeWNsZV90aW1lcyAodCAoKSkgfmY6Rm4uaWRcbmxldCBjeWNsZV90aW1lcyAoKSA9IG1hcF9jeWNsZV90aW1lcyAodCAoKSkgfmY6VGltZV9ucy5TcGFuLnRvX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdFxubGV0IHRvdGFsX2N5Y2xlX3RpbWUgKCkgPSB0b3RhbF9jeWNsZV90aW1lICh0ICgpKVxubGV0IGxhc3RfY3ljbGVfdGltZSAoKSA9IGxhc3RfY3ljbGVfdGltZSAodCAoKSlcbmxldCBsb25nX2N5Y2xlcyB+YXRfbGVhc3QgPSBsb25nX2N5Y2xlcyAodCAoKSkgfmF0X2xlYXN0XG5sZXQgZXZlbnRfcHJlY2lzaW9uX25zICgpID0gZXZlbnRfcHJlY2lzaW9uICh0ICgpKVxubGV0IGV2ZW50X3ByZWNpc2lvbiAoKSA9IFRpbWVfbnMuU3Bhbi50b19zcGFuX2Zsb2F0X3JvdW5kX25lYXJlc3QgKGV2ZW50X3ByZWNpc2lvbl9ucyAoKSlcblxubGV0IHNldF9tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSBpID1cbiAgc2V0X21heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlICh0ICgpKSBpXG47O1xuXG5sZXQgbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgKCkgPSBtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSAodCAoKSlcbmxldCBzZXRfcmVjb3JkX2JhY2t0cmFjZXMgYm9vbCA9IHNldF9yZWNvcmRfYmFja3RyYWNlcyAodCAoKSkgYm9vbFxubGV0IHJlY29yZGluZ19iYWNrdHJhY2VzICgpID0gcmVjb3JkaW5nX2JhY2t0cmFjZXMgKHQgKCkpXG5sZXQgZm9yY2VfY3VycmVudF9jeWNsZV90b19lbmQgKCkgPSBmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZCAodCAoKSlcbmxldCB5aWVsZCAoKSA9IHlpZWxkICh0ICgpKVxuXG5sZXQgeWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gP21heV9yZXR1cm5faW1tZWRpYXRlbHkgKCkgPVxuICB5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiA/bWF5X3JldHVybl9pbW1lZGlhdGVseSAodCAoKSlcbjs7XG5cbmxldCB5aWVsZF9ldmVyeSB+biA9XG4gIGxldCB5aWVsZF9ldmVyeSA9IFN0YWdlZC51bnN0YWdlICh5aWVsZF9ldmVyeSB+bikgaW5cbiAgbGV0IHQgPSB0ICgpIGluXG4gIHN0YWdlIChmdW4gKCkgLT4geWllbGRfZXZlcnkgdClcbjs7XG5cbmxldCBudW1fam9ic19ydW4gKCkgPSBudW1fam9ic19ydW4gKHQgKCkpXG5sZXQgbnVtX3BlbmRpbmdfam9icyAoKSA9IG51bV9wZW5kaW5nX2pvYnMgKHQgKCkpXG5cbm1vZHVsZSBFeHBlcnQgPSBzdHJ1Y3RcbiAgbGV0IHNldF9leGVjdXRpb25fY29udGV4dCBjb250ZXh0ID0gc2V0X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSBjb250ZXh0XG4gIGxldCBydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluID0gcnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpblxuICBsZXQgbGFzdF9jeWNsZV9udW1fam9icyAoKSA9IGxhc3RfY3ljbGVfbnVtX2pvYnMgKHQgKCkpXG4gIGxldCBydW5fZXZlcnlfY3ljbGVfc3RhcnQgZiA9IHJ1bl9ldmVyeV9jeWNsZV9zdGFydCAodCAoKSkgfmZcbiAgbGV0IHJ1bl9ldmVyeV9jeWNsZV9lbmQgZiA9IHJ1bl9ldmVyeV9jeWNsZV9lbmQgKHQgKCkpIH5mXG4gIGxldCBhZGRfZXZlcnlfY3ljbGVfc3RhcnRfaG9vayB+ZiA9IGFkZF9ldmVyeV9jeWNsZV9zdGFydF9ob29rICh0ICgpKSB+ZlxuICBsZXQgYWRkX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rIH5mID0gYWRkX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rICh0ICgpKSB+ZlxuXG4gIGxldCByZW1vdmVfZXZlcnlfY3ljbGVfc3RhcnRfaG9va19leG4gaGFuZGxlID1cbiAgICByZW1vdmVfZXZlcnlfY3ljbGVfc3RhcnRfaG9va19leG4gKHQgKCkpIGhhbmRsZVxuICA7O1xuXG4gIGxldCByZW1vdmVfZXZlcnlfY3ljbGVfZW5kX2hvb2tfZXhuIGhhbmRsZSA9XG4gICAgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rX2V4biAodCAoKSkgaGFuZGxlXG4gIDs7XG5cbiAgbGV0IHdpdGhfZXhlY3V0aW9uX2NvbnRleHQgZXhlY3V0aW9uX2NvbnRleHQgZiA9XG4gICAgd2l0aF9leGVjdXRpb25fY29udGV4dCAodCAoKSkgZXhlY3V0aW9uX2NvbnRleHQgfmZcbiAgOztcblxuICBsZXQgd2l0aF9leGVjdXRpb25fY29udGV4dDEgZXhlY3V0aW9uX2NvbnRleHQgfmYgeCA9XG4gICAgd2l0aF9leGVjdXRpb25fY29udGV4dDEgKHQgKCkpIGV4ZWN1dGlvbl9jb250ZXh0IH5mIHhcbiAgOztcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IFNjaGVkdWxlclxuIiwiKCoqIFNjaGVkdWxlIGpvYnMgdG8gcnVuIGF0IGEgdGltZSBpbiB0aGUgZnV0dXJlLlxuXG4gICAgVGhlIHVuZGVybHlpbmcgaW1wbGVtZW50YXRpb24gdXNlcyBhIGhlYXAgb2YgZXZlbnRzLCBvbmUgZm9yIGVhY2ggam9iIHRoYXQgbmVlZHMgdG9cbiAgICBydW4gaW4gdGhlIGZ1dHVyZS4gIFRoZSBBc3luYyBzY2hlZHVsZXIgaXMgcmVzcG9uc2libGUgZm9yIHdha2luZyB1cCBhdCB0aGUgcmlnaHQgdGltZVxuICAgIHRvIHJ1biB0aGUgam9icy4gKilcblxub3BlbiBDb3JlXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubW9kdWxlIE9yX3RpbWVvdXQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICBbIGBSZXN1bHQgb2YgJ2FcbiAgICB8IGBUaW1lb3V0XG4gICAgXVxuICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuZW5kXG5cbm1vZHVsZSB0eXBlIENsb2NrID0gc2lnXG4gIG1vZHVsZSBPcl90aW1lb3V0ID0gT3JfdGltZW91dFxuXG4gIG1vZHVsZSBUaW1lIDogc2lnXG4gICAgbW9kdWxlIFNwYW4gOiBzaWdcbiAgICAgIHR5cGUgdFxuICAgIGVuZFxuXG4gICAgdHlwZSB0XG4gIGVuZFxuXG4gICgqKiBbcnVuX2F0IHRpbWUgZiBhXSBydW5zIFtmIGFdIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgW3RpbWVdLiAgSWYgW3RpbWVdIGlzIGluIHRoZVxuICAgICAgcGFzdCwgdGhlbiBbcnVuX2F0XSB3aWxsIGltbWVkaWF0ZWx5IHNjaGVkdWxlIGEgam9iIFt0XSB0aGF0IHdpbGwgcnVuIFtmIGFdLiAgSW4gbm9cbiAgICAgIHNpdHVhdGlvbiB3aWxsIFtydW5fYXRdIGFjdHVhbGx5IGNhbGwgW2ZdIGl0c2VsZi4gIFRoZSBjYWxsIHRvIFtmXSB3aWxsIGFsd2F5cyBiZSBpblxuICAgICAgYW5vdGhlciBqb2IuICopXG4gIHZhbCBydW5fYXQgOiBUaW1lLnQgLT4gKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXRcblxuICAoKiogW3J1bl9hZnRlcl0gaXMgbGlrZSBbcnVuX2F0XSwgZXhjZXB0IHRoYXQgb25lIHNwZWNpZmllcyBhIHRpbWUgc3BhbiByYXRoZXIgdGhhbiBhblxuICAgICAgYWJzb2x1dGUgdGltZS4gKilcbiAgdmFsIHJ1bl9hZnRlciA6IFRpbWUuU3Bhbi50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0XG5cbiAgKCoqIFthdCB0aW1lXSByZXR1cm5zIGEgZGVmZXJyZWQgW2RdIHRoYXQgd2lsbCBiZWNvbWUgZGV0ZXJtaW5lZCBhcyBzb29uIGFzIHBvc3NpYmxlXG4gICAgICBhZnRlciBbdGltZV0uICopXG4gIHZhbCBhdCA6IFRpbWUudCAtPiB1bml0IERlZmVycmVkLnRcblxuICAoKiogW2FmdGVyXSBpcyBsaWtlIFthdF0sIGV4Y2VwdCB0aGF0IG9uZSBzcGVjaWZpZXMgYSB0aW1lIHNwYW4gcmF0aGVyIHRoYW4gYW4gYWJzb2x1dGVcbiAgICAgIHRpbWUuICopXG4gIHZhbCBhZnRlciA6IFRpbWUuU3Bhbi50IC0+IHVuaXQgRGVmZXJyZWQudFxuXG4gICgqKiBbd2l0aF90aW1lb3V0IHNwYW4gZF0gcmV0dXJucyBhIGRlZmVycmVkIHRoYXQgd2lsbCBiZWNvbWUgZGV0ZXJtaW5lZCBhZnRlciBlaXRoZXJcbiAgICAgIFtzcGFuXSBlbGFwc2VzIG9yIFtkXSBpcyBkZXRlcm1pbmVkLCByZXR1cm5pbmcgZWl0aGVyIFtgVGltZW91dF0gb3IgW2BSZXN1bHRdXG4gICAgICBkZXBlbmRpbmcgb24gd2hpY2ggb25lIHN1Y2NlZWRlZCBmaXJzdC4gIEF0IHRoZSB0aW1lIHRoZSByZXR1cm5lZCBkZWZlcnJlZCBiZWNvbWVzXG4gICAgICBkZXRlcm1pbmVkLCBib3RoIHRoaW5ncyBtYXkgaGF2ZSBoYXBwZW5lZCwgaW4gd2hpY2ggY2FzZSBbYFJlc3VsdF0gaXMgZ2l2ZW5cbiAgICAgIHByZWZlcmVuY2UuICopXG4gIHZhbCB3aXRoX3RpbWVvdXQgOiBUaW1lLlNwYW4udCAtPiAnYSBEZWZlcnJlZC50IC0+ICdhIE9yX3RpbWVvdXQudCBEZWZlcnJlZC50XG5cbiAgKCoqIFt3aXRoX3RpbWVvdXRfZXhuIHNwYW4gZCB+ZXJyb3JdIGlzIGxpa2UgW3dpdGhfdGltZW91dF0sIGJ1dCByYWlzZXMgaWYgdGhlIHRpbWVvdXRcbiAgICAgIG9jY3Vycy4gWW91IHNob3VsZCBiZSBjYXJlZnVsIHdpdGggdGhlIFtFcnJvci50XSB5b3UgcGFzcyBiZWNhdXNlIGl0cyBlYXN5IHRvXG4gICAgICBhbGxvY2F0ZSBhIGxhcmdlIHZhbHVlIHRoYXQgd2lsbCBiZSB1bnVzZWQuIFRvIGF2b2lkIHRoaXMsIHlvdSBzaG91bGQgdXNlIG9uZSBvZiB0aGVcbiAgICAgIGxhenktY3JlYXRpb24gZnVuY3Rpb25zIGluIHRoZSBbRXJyb3JdIG1vZHVsZS4gKilcbiAgdmFsIHdpdGhfdGltZW91dF9leG4gOiBUaW1lLlNwYW4udCAtPiAnYSBEZWZlcnJlZC50IC0+IGVycm9yOkVycm9yLnQgLT4gJ2EgRGVmZXJyZWQudFxuXG4gICgqKiBFdmVudHMgcHJvdmlkZSB2YXJpYW50cyBvZiBbcnVuX2F0XSBhbmQgW3J1bl9hZnRlcl0gd2l0aCB0aGUgYWJpbGl0eSB0byBhYm9ydCBvclxuICAgICAgcmVzY2hlZHVsZSBhbiBldmVudCB0aGF0IGhhc24ndCB5ZXQgaGFwcGVuZWQuICBPbmNlIGFuIGV2ZW50IGhhcHBlbnMgb3IgaXMgYWJvcnRlZCxcbiAgICAgIEFzeW5jIGRvZXNuJ3QgdXNlIGFueSBzcGFjZSBmb3IgdHJhY2tpbmcgaXQuICopXG4gIG1vZHVsZSBFdmVudCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnaCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIHR5cGUgdF91bml0ID0gKHVuaXQsIHVuaXQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgSW52YXJpYW50LlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAgIHZhbCBzY2hlZHVsZWRfYXQgOiAoXywgXykgdCAtPiBUaW1lLnRcblxuICAgIG1vZHVsZSBTdGF0dXMgOiBzaWdcbiAgICAgIHR5cGUgKCdhLCAnaCkgdCA9XG4gICAgICAgIHwgQWJvcnRlZCBvZiAnYVxuICAgICAgICB8IEhhcHBlbmVkIG9mICdoXG4gICAgICAgIHwgU2NoZWR1bGVkX2F0IG9mIFRpbWUudFxuICAgICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICBlbmRcblxuICAgICgqKiBJZiBbc3RhdHVzXSByZXR1cm5zIFtTY2hlZHVsZWRfYXQgdGltZV0sIGl0IGlzIHBvc3NpYmxlIHRoYXQgW3RpbWUgPCBUaW1lLm5vdyAoKV1cbiAgICAgICAgaWYgQXN5bmMncyBzY2hlZHVsZXIgaGFzbid0IHlldCBnb3R0ZW4gdGhlIGNoYW5jZSB0byB1cGRhdGUgaXRzIGNsb2NrLCBlLmcuLCBkdWVcbiAgICAgICAgdG8gdXNlciBqb2JzIHJ1bm5pbmcuICopXG4gICAgdmFsIHN0YXR1cyA6ICgnYSwgJ2gpIHQgLT4gKCdhLCAnaCkgU3RhdHVzLnRcblxuICAgICgqKiBMZXQgW3QgPSBydW5fYXQgdGltZSBmIHpdLiAgQXQgW3RpbWVdLCB0aGlzIHJ1bnMgW2Ygel0gYW5kIHRyYW5zaXRpb25zIFtzdGF0dXMgdF1cbiAgICAgICAgdG8gW0hhcHBlbmVkIGhdLCB3aGVyZSBbaF0gaXMgcmVzdWx0IG9mIFtmIHpdLlxuXG4gICAgICAgIE1vcmUgcHJlY2lzZWx5LCBhdCBbdGltZV0sIHByb3ZpZGVkIFthYm9ydCB0IGFdIGhhcyBub3QgcHJldmlvdXNseSBiZWVuIGNhbGxlZCxcbiAgICAgICAgdGhpcyB3aWxsIGNhbGwgW2Ygel0sIHdpdGggdGhlIGd1YXJhbnRlZSB0aGF0IFtzdGF0dXMgdCA9IFNjaGVkdWxlZF9hdCB0aW1lXS4gIElmXG4gICAgICAgIFtmIHpdIHJldHVybnMgW2hdIGFuZCBkaWQgbm90IGNhbGwgW2Fib3J0IHQgYV0sIHRoZW4gW3N0YXR1cyB0XSBiZWNvbWVzIFtIYXBwZW5lZFxuICAgICAgICBoXS4gIElmIFtmIHpdIGNhbGxzIFthYm9ydCB0IGFdLCB0aGVuIHRoZSByZXN1bHQgb2YgW2ZdIGlzIGlnbm9yZWQsIGFuZCBbc3RhdHVzIHRdXG4gICAgICAgIGlzIFtBYm9ydGVkIGFdLlxuXG4gICAgICAgIElmIFtmIHpdIHJhaXNlcywgdGhlbiBbc3RhdHVzIHRdIGRvZXMgbm90IHRyYW5zaXRpb24gYW5kIHJlbWFpbnMgW1NjaGVkdWxlZF9hdFxuICAgICAgICB0aW1lXSwgYW5kIHRoZSBleGNlcHRpb24gaXMgc2VudCB0byB0aGUgbW9uaXRvciBpbiBlZmZlY3Qgd2hlbiBbcnVuX2F0XSB3YXNcbiAgICAgICAgY2FsbGVkLiAqKVxuICAgIHZhbCBydW5fYXQgOiBUaW1lLnQgLT4gKCd6IC0+ICdoKSAtPiAneiAtPiAoXywgJ2gpIHRcblxuICAgIHZhbCBydW5fYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoJ3ogLT4gJ2gpIC0+ICd6IC0+IChfLCAnaCkgdFxuXG4gICAgbW9kdWxlIEFib3J0X3Jlc3VsdCA9IFRpbWVfc291cmNlLkV2ZW50LkFib3J0X3Jlc3VsdFxuXG4gICAgKCoqIFthYm9ydCB0XSBjaGFuZ2VzIFtzdGF0dXMgdF0gdG8gW0Fib3J0ZWRdIGFuZCByZXR1cm5zIFtPa10sIHVubGVzcyBbdF1cbiAgICAgICAgcHJldmlvdXNseSBoYXBwZW5lZCBvciB3YXMgcHJldmlvdXNseSBhYm9ydGVkLiAqKVxuICAgIHZhbCBhYm9ydCA6ICgnYSwgJ2gpIHQgLT4gJ2EgLT4gKCdhLCAnaCkgQWJvcnRfcmVzdWx0LnRcblxuICAgICgqKiBbYWJvcnRfZXhuIHQgYV0gcmV0dXJucyBbdW5pdF0gaWYgW2Fib3J0IHQgYSA9IGBPa10sIGFuZCBvdGhlcndpc2UgcmFpc2VzLiAqKVxuICAgIHZhbCBhYm9ydF9leG4gOiAoJ2EsICdoKSB0IC0+ICdhIC0+IHVuaXRcblxuICAgICgqKiBbYWJvcnRfaWZfcG9zc2libGUgdCBhID0gaWdub3JlIChhYm9ydCB0IGEpXS4gKilcbiAgICB2YWwgYWJvcnRfaWZfcG9zc2libGUgOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gdW5pdFxuXG4gICAgbW9kdWxlIEZpcmVkID0gVGltZV9zb3VyY2UuRXZlbnQuRmlyZWRcblxuICAgIHZhbCBmaXJlZCA6ICgnYSwgJ2gpIHQgLT4gKCdhLCAnaCkgRmlyZWQudCBEZWZlcnJlZC50XG5cbiAgICBtb2R1bGUgUmVzY2hlZHVsZV9yZXN1bHQgPSBUaW1lX3NvdXJjZS5FdmVudC5SZXNjaGVkdWxlX3Jlc3VsdFxuXG4gICAgKCoqIFtyZXNjaGVkdWxlX2F0IHRdIGFuZCBbcmVzY2hlZHVsZV9hZnRlciB0XSBjaGFuZ2UgdGhlIHRpbWUgdGhhdCBbdF0gd2lsbCBmaXJlLCBpZlxuICAgICAgICBwb3NzaWJsZSwgYW5kIGlmIG5vdCwgZ2l2ZSBhIHJlYXNvbiB3aHkuICBMaWtlIFtydW5fYXRdLCBpZiB0aGUgcmVxdWVzdGVkIHRpbWUgaXNcbiAgICAgICAgaW4gdGhlIHBhc3QsIHRoZSBldmVudCB3aWxsIGJlIHNjaGVkdWxlZCB0byBydW4gaW1tZWRpYXRlbHkuICBJZiBbcmVzY2hlZHVsZV9hdCB0XG4gICAgICAgIHRpbWUgPSBPa10sIHRoZW4gc3Vic2VxdWVudGx5IFtzY2hlZHVsZWRfYXQgdCA9IHRpbWVdLiAgKilcbiAgICB2YWwgcmVzY2hlZHVsZV9hdCA6ICgnYSwgJ2gpIHQgLT4gVGltZS50IC0+ICgnYSwgJ2gpIFJlc2NoZWR1bGVfcmVzdWx0LnRcblxuICAgIHZhbCByZXNjaGVkdWxlX2FmdGVyIDogKCdhLCAnaCkgdCAtPiBUaW1lLlNwYW4udCAtPiAoJ2EsICdoKSBSZXNjaGVkdWxlX3Jlc3VsdC50XG5cbiAgICAoKiogW2F0IHRpbWVdICAgIGlzIFtydW5fYXQgICAgdGltZSBpZ25vcmUgKCldLlxuICAgICAgICBbYWZ0ZXIgdGltZV0gaXMgW3J1bl9hZnRlciB0aW1lIGlnbm9yZSAoKV0uXG5cbiAgICAgICAgWW91IHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSB0aGUgW3J1bl8qXSBmdW5jdGlvbnMsIHdoaWNoIGFsbG93IHlvdSB0b1xuICAgICAgICBzeW5jaHJvbm91c2x5IHVwZGF0ZSBzdGF0ZSB2aWEgYSB1c2VyLXN1cHBsaWVkIGZ1bmN0aW9uIHdoZW4gdGhlIGV2ZW50XG4gICAgICAgIHRyYW5zaXRpb25zIHRvIFtIYXBwZW5lZF0uICBUaGF0IGlzLCB0aGVyZSBpcyBhbiBpbXBvcnRhbnQgZGlmZmVyZW5jZSBiZXR3ZWVuOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBydW5fYXQgdGltZSBmICgpIF19XG5cbiAgICAgICAgYW5kOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBhdCB0aW1lIGluXG4gICAgICAgICAgZmlyZWQgdFxuICAgICAgICAgID4+PiBmdW5jdGlvblxuICAgICAgICAgIHwgSGFwcGVuZWQgKCkgLT4gZiAoKVxuICAgICAgICAgIHwgQWJvcnRlZCAoKSAtPiAoKSBdfVxuXG4gICAgICAgIFdpdGggW3J1bl9hdF0sIGlmIFtzdGF0dXMgdCA9IEhhcHBlbmVkXSwgb25lIGtub3dzIHRoYXQgW2ZdIGhhcyBydW4uICBXaXRoIFthdF1cbiAgICAgICAgYW5kIFtmaXJlZF0sIG9uZSBkb2VzIG5vdCBrbm93IHdoZXRoZXIgW2ZdIGhhcyB5ZXQgcnVuOyBpdCBtYXkgc3RpbGwgYmUgc2NoZWR1bGVkXG4gICAgICAgIHRvIHJ1bi4gIFRodXMsIHdpdGggW2F0XSBhbmQgW2ZpcmVkXSwgaXQgaXMgZWFzeSB0byBpbnRyb2R1Y2UgYSByYWNlLiAgRm9yXG4gICAgICAgIGV4YW1wbGUsIGNvbnNpZGVyIHRoZXNlIHR3byBjb2RlIHNuaXBwZXRzOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBFdmVudC5hZnRlciAoc2VjIDIuKSBpblxuICAgICAgICAgIHVwb24gKEV2ZW50LmZpcmVkIHQpIChmdW5jdGlvblxuICAgICAgICAgICAgfCBBYm9ydGVkICgpIC0+ICgpXG4gICAgICAgICAgICB8IEhhcHBlbmVkICgpIC0+IHByaW50ZiBcIlRpbWVyIGZpcmVkXCIpO1xuICAgICAgICAgIHVwb24gZGVmZXJyZWRfZXZlbnQgKGZ1biAoKSAtPlxuICAgICAgICAgICAgbWF0Y2ggRXZlbnQuYWJvcnQgdCAoKSB3aXRoXG4gICAgICAgICAgICB8IE9rIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkXCJcbiAgICAgICAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkICgpIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBQcmV2aW91c2x5X2hhcHBlbmVkICgpIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkIGFmdGVyIHRpbWVyIGZpcmVkXCIpOyBdfVxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBFdmVudC5ydW5fYWZ0ZXIgKHNlYyAyLikgcHJpbnRmIFwiVGltZXIgZmlyZWRcIiBpblxuICAgICAgICAgIHVwb24gZGVmZXJyZWRfZXZlbnQgKGZ1biAoKSAtPlxuICAgICAgICAgICAgbWF0Y2ggRXZlbnQuYWJvcnQgdCAoKSB3aXRoXG4gICAgICAgICAgICB8IE9rIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkXCJcbiAgICAgICAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkICgpIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBQcmV2aW91c2x5X2hhcHBlbmVkICgpIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkIGFmdGVyIHRpbWVyIGZpcmVkXCIpOyBdfVxuXG4gICAgICAgIEluIGJvdGggc25pcHBldHMsIGlmIFtFdmVudC5hYm9ydF0gcmV0dXJucyBbT2tdLCBcIlRpbWVyIGZpcmVkXCIgaXMgbmV2ZXIgcHJpbnRlZC5cbiAgICAgICAgSG93ZXZlciwgdGhlIGZpcnN0IHNuaXBwZXQgbWlnaHQgcHJpbnQgXCJFdmVudCBvY2N1cnJlZCBhZnRlciB0aW1lciBmaXJlZFwiIGFuZCB0aGVuXG4gICAgICAgIFwiVGltZXIgZmlyZWRcIi4gIFRoaXMgY29uZnVzZWQgb3JkZXJpbmcgY2Fubm90IGhhcHBlbiB3aXRoIFtFdmVudC5ydW5fYWZ0ZXJdLiAqKVxuICAgIHZhbCBhdCA6IFRpbWUudCAtPiAoXywgdW5pdCkgdFxuXG4gICAgdmFsIGFmdGVyIDogVGltZS5TcGFuLnQgLT4gKF8sIHVuaXQpIHRcbiAgZW5kXG5cbiAgKCoqIFthdF92YXJ5aW5nX2ludGVydmFscyBmID9zdG9wXSByZXR1cm5zIGEgc3RyZWFtIHdob3NlIG5leHQgZWxlbWVudCBiZWNvbWVzXG4gICAgICBkZXRlcm1pbmVkIGJ5IGNhbGxpbmcgW2YgKCldIGFuZCB3YWl0aW5nIGZvciB0aGF0IGFtb3VudCBvZiB0aW1lLCBhbmQgdGhlbiBsb29waW5nXG4gICAgICB0byBkZXRlcm1pbmUgc3Vic2VxdWVudCBlbGVtZW50cy4gIFRoZSBzdHJlYW0gd2lsbCBlbmQgYWZ0ZXIgW3N0b3BdIGJlY29tZXNcbiAgICAgIGRldGVybWluZWQuICopXG4gIHZhbCBhdF92YXJ5aW5nX2ludGVydmFsc1xuICAgIDogID9zdG9wOnVuaXQgRGVmZXJyZWQudFxuICAgIC0+ICh1bml0IC0+IFRpbWUuU3Bhbi50KVxuICAgIC0+IHVuaXQgQXN5bmNfc3RyZWFtLnRcblxuICAoKiogW2F0X2ludGVydmFscyBpbnRlcnZhbCA/c3RhcnQgP3N0b3BdIHJldHVybnMgYSBzdHJlYW0gd2hvc2UgZWxlbWVudHMgd2lsbCBiZWNvbWVcbiAgICAgIGRldGVybWluZWQgYXQgbm9ubmVnYXRpdmUgaW50ZWdlciBtdWx0aXBsZXMgb2YgW2ludGVydmFsXSBhZnRlciB0aGUgW3N0YXJ0XSB0aW1lLFxuICAgICAgdW50aWwgW3N0b3BdIGJlY29tZXMgZGV0ZXJtaW5lZDpcblxuICAgICAge3ZcbiAgICAgICAgc3RhcnQgKyAwICogaW50ZXJ2YWxcbiAgICAgICAgc3RhcnQgKyAxICogaW50ZXJ2YWxcbiAgICAgICAgc3RhcnQgKyAyICogaW50ZXJ2YWxcbiAgICAgICAgc3RhcnQgKyAzICogaW50ZXJ2YWxcbiAgICAgICAgLi4uXG4gICAgICB2fVxuXG4gICAgICBOb3RlIHRoYXQgb25seSBlbGVtZW50cyB0aGF0IGFyZSBzdHJpY3RseSBpbiB0aGUgZnV0dXJlIGV2ZXIgYmVjb21lIGRldGVybWluZWQuXG4gICAgICBJbiBwYXJ0aWN1bGFyLCBpZiBbc3RhcnRdIGlzIG5vdCBpbiB0aGUgZnV0dXJlLCBvciBbc3RhcnRdIGlzIG5vdCBwcm92aWRlZCxcbiAgICAgIHRoZW4gdGhlcmUgd2lsbCBiZSBubyBlbGVtZW50IGJlZm9yZSB0aGUgW2ludGVydmFsXSBoYXMgcGFzc2VkLlxuXG4gICAgICBJZiB0aGUgaW50ZXJ2YWwgaXMgdG9vIHNtYWxsIG9yIHRoZSBDUFUgaXMgdG9vIGxvYWRlZCwgW2F0X2ludGVydmFsc10gd2lsbCBza2lwXG4gICAgICB1bnRpbCB0aGUgbmV4dCB1cGNvbWluZyBtdWx0aXBsZSBvZiBbaW50ZXJ2YWxdIGFmdGVyIFtzdGFydF0uICopXG4gIHZhbCBhdF9pbnRlcnZhbHNcbiAgICA6ICA/c3RhcnQ6VGltZS50XG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50XG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiB1bml0IEFzeW5jX3N0cmVhbS50XG5cbiAgKCoqIFtldmVyeScgP3N0YXJ0ID9zdG9wIHNwYW4gZl0gcnVucyBbZiAoKV0gZXZlcnkgW3NwYW5dIGFtb3VudCBvZiB0aW1lIHN0YXJ0aW5nIHdoZW5cbiAgICAgIFtzdGFydF0gYmVjb21lcyBkZXRlcm1pbmVkIGFuZCBzdG9wcGluZyB3aGVuIFtzdG9wXSBiZWNvbWVzIGRldGVybWluZWQuICBbZXZlcnknXVxuICAgICAgd2FpdHMgdW50aWwgdGhlIG91dGNvbWUgb2YgW2YgKCldIGJlY29tZXMgZGV0ZXJtaW5lZCBiZWZvcmUgd2FpdGluZyBmb3IgdGhlIG5leHRcbiAgICAgIFtzcGFuXS5cblxuICAgICAgSXQgaXMgZ3VhcmFudGVlZCB0aGF0IGlmIFtzdG9wXSBiZWNvbWVzIGRldGVybWluZWQsIGV2ZW4gZHVyaW5nIGV2YWx1YXRpb24gb2YgW2ZdLFxuICAgICAgdGhlbiBbZl0gd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGJ5IGEgc3Vic2VxdWVudCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG5cbiAgICAgIEl0IGlzIGFuIGVycm9yIGZvciBbc3Bhbl0gdG8gYmUgbm9ucG9zaXRpdmUuXG5cbiAgICAgIFtjb250aW51ZV9vbl9lcnJvcl0gY29udHJvbHMgd2hhdCBzaG91bGQgaGFwcGVuIGlmIFtmXSByYWlzZXMgYW4gZXhjZXB0aW9uLlxuICAgICAgV2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlXSwgaXRlcmF0aW9uIG9ubHkgY29udGludWVzIGlmIFtmXSBzdWNjZXNzZnVsbHlcbiAgICAgIHJldHVybnMgYSBkZWZlcnJlZCBhbmQgdGhhdCBkZWZlcnJlZCBpcyBkZXRlcm1pbmVkLlxuICAgICAgV2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOnRydWVdLCBpdGVyYXRpb24gYWxzbyBjb250aW51ZXMgaWYgW2ZdIHJhaXNlcyBhbiBleGNlcHRpb24uXG4gICAgICBJZiBbZl0gcmFpc2VzIGFuIGV4Y2VwdGlvbiBhc3luY2hyb25vdXNseSwgdGhpcyBtYXkgY2F1c2UgdXMgdG8gcHJvY2VlZCB3aXRoIHRoZVxuICAgICAgbmV4dCBpdGVyYXRpb24gd2hpbGUgdGhlIHByZXZpb3VzIGNhbGwgdG8gW2ZdIGlzIHN0aWxsIHJ1bm5pbmcuXG5cbiAgICAgIEV4Y2VwdGlvbnMgcmFpc2VkIGJ5IFtmXSBhcmUgYWx3YXlzIHNlbnQgdG8gdGhlIG1vbml0b3IgaW4gZWZmZWN0IHdoZW4gW2V2ZXJ5J10gd2FzXG4gICAgICBjYWxsZWQsIGV2ZW4gd2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOnRydWVdLlxuXG4gICAgICBJZiBbZmluaXNoZWRdIGlzIHN1cHBsaWVkLCBbZXZlcnknXSB3aWxsIGZpbGwgaXQgb25jZSBhbGwgb2YgdGhlIGZvbGxvd2luZyBiZWNvbWVcbiAgICAgIGRldGVybWluZWQ6IFtzdGFydF0sIFtzdG9wXSwgYW5kIHRoZSBvdXRjb21lIG9mIHRoZSBmaW5hbCBjYWxsIHRvIFtmXS4gKilcbiAgdmFsIGV2ZXJ5J1xuICAgIDogID9zdGFydDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW3JldHVybiAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+ID9maW5pc2hlZDp1bml0IEl2YXIudFxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgIC0+IHVuaXRcblxuICAoKiogW2V2ZXJ5ID9zdGFydCA/c3RvcCBzcGFuIGZdIGlzXG4gICAgICBbZXZlcnknID9zdGFydCA/c3RvcCBzcGFuIChmdW4gKCkgLT4gZiAoKTsgcmV0dXJuICgpKV0uICopXG4gIHZhbCBldmVyeVxuICAgIDogID9zdGFydDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW3JldHVybiAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFtydW5fYXRfaW50ZXJ2YWxzJyA/c3RhcnQgP3N0b3Agc3BhbiBmXSBydW5zIFtmKCldIGF0IGluY3JlbWVudHMgb2YgW3N0YXJ0ICsgaSAqXG4gICAgICBzcGFuXSBmb3Igbm9ubmVnYXRpdmUgaW50ZWdlcnMgW2ldLCB1bnRpbCBbc3RvcF0gYmVjb21lcyBkZXRlcm1pbmVkLlxuICAgICAgSWYgdGhlIHJlc3VsdCBvZiBbZl0gaXMgbm90IGRldGVybWluZWQgZmFzdCBlbm91Z2ggdGhlbiB0aGUgbmV4dCBpbnRlcnZhbChzKVxuICAgICAgYXJlIHNraXBwZWQgc28gdGhhdCB0aGVyZSBhcmUgbmV2ZXIgbXVsdGlwbGUgY29uY3VycmVudCBpbnZvY2F0aW9ucyBvZiBbZl0gaW5cbiAgICAgIGZsaWdodC5cblxuICAgICAgRXhjZXB0aW9ucyByYWlzZWQgYnkgW2ZdIGFyZSBhbHdheXMgc2VudCB0byBtb25pdG9yIGluIGVmZmVjdCB3aGVuXG4gICAgICBbcnVuX2F0X2ludGVydmFscyddIHdhcyBjYWxsZWQsIGV2ZW4gd2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOnRydWVdLiAqKVxuICB2YWwgcnVuX2F0X2ludGVydmFscydcbiAgICA6ICA/c3RhcnQ6VGltZS50ICgqKiBkZWZhdWx0IGlzIFtUaW1lLm5vdyAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgIC0+IHVuaXRcblxuICAoKiogW3J1bl9hdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciBzcGFuIGZdIGlzIGVxdWl2YWxlbnQgdG86XG5cbiAgICAgIHtbXG4gICAgICAgIHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3Igc3BhblxuICAgICAgICAgIChmdW4gKCkgLT4gZiAoKTsgcmV0dXJuICgpKSBdfSAqKVxuICB2YWwgcnVuX2F0X2ludGVydmFsc1xuICAgIDogID9zdGFydDpUaW1lLnQgKCoqIGRlZmF1bHQgaXMgW1RpbWUubm93ICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICAoKiogW2R1cmF0aW9uX29mIGZdIGludm9rZXMgW2YgKCldIGFuZCBtZWFzdXJlcyBob3cgbG9uZyBpdCB0YWtlcyBmcm9tIHRoZSBpbnZvY2F0aW9uXG4gICAgICB0byBhZnRlciB0aGUgZGVmZXJyZWQgaXMgZGV0ZXJtaW5lZC5cblxuICAgICAgTm90ZSB0aGF0IHRoZSBtZWFzdXJlbWVudCBpcyBub3QgZXhhY3Q7IGJlY2F1c2UgaXQgaW52b2x2ZXMgYW4gYWRkaXRpb25hbCBtYXAgb24gdGhlXG4gICAgICBkZWZlcnJlZCwgdGhlIHRpbWluZyBhbHNvIGluY2x1ZGVzIHRoZSBkdXJhdGlvbiBvZiBqb2JzIGluIHRoZSBqb2IgcXVldWUgd2hlbiBbZiAoKV1cbiAgICAgIGlzIGRldGVybWluZWQuICopXG4gIHZhbCBkdXJhdGlvbl9vZiA6ICh1bml0IC0+ICdhIERlZmVycmVkLnQpIC0+ICgnYSAqIFRpbWUuU3Bhbi50KSBEZWZlcnJlZC50XG5lbmRcblxuKCoqIFtDbG9ja19kZXByZWNhdGVkXSBpcyB1c2VkIGluIFtSZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlXSB0byBjcmVhdGUgYSBjbG9ja1xuICAgIG1vZHVsZSBpbiB3aGljaCBhbGwgZnVuY3Rpb25zIGFyZSBkZXByZWNhdGVkLiAqKVxubW9kdWxlIHR5cGUgQ2xvY2tfZGVwcmVjYXRlZCA9IHNpZ1xuICBtb2R1bGUgT3JfdGltZW91dCA9IE9yX3RpbWVvdXRcblxuICBtb2R1bGUgVGltZSA6IHNpZ1xuICAgIG1vZHVsZSBTcGFuIDogc2lnXG4gICAgICB0eXBlIHRcbiAgICBlbmRcblxuICAgIHR5cGUgdFxuICBlbmRcblxuICB2YWwgcnVuX2F0IDogVGltZS50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBydW5fYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgYXQgOiBUaW1lLnQgLT4gdW5pdCBEZWZlcnJlZC50IFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiB1bml0IERlZmVycmVkLnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIHdpdGhfdGltZW91dCA6IFRpbWUuU3Bhbi50IC0+ICdhIERlZmVycmVkLnQgLT4gJ2EgT3JfdGltZW91dC50IERlZmVycmVkLnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIHdpdGhfdGltZW91dF9leG4gOiBUaW1lLlNwYW4udCAtPiAnYSBEZWZlcnJlZC50IC0+IGVycm9yOkVycm9yLnQgLT4gJ2EgRGVmZXJyZWQudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAyMy0xMV0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICBtb2R1bGUgRXZlbnQgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2gpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICB0eXBlIHRfdW5pdCA9ICh1bml0LCB1bml0KSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB2YWwgaW52YXJpYW50IDogJ2EgSW52YXJpYW50LnQgLT4gJ2IgSW52YXJpYW50LnQgLT4gKCdhLCAnYikgdCBJbnZhcmlhbnQudFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIHNjaGVkdWxlZF9hdCA6IChfLCBfKSB0IC0+IFRpbWUudFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgbW9kdWxlIFN0YXR1cyA6IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgICAgfCBBYm9ydGVkIG9mICdhXG4gICAgICAgIHwgSGFwcGVuZWQgb2YgJ2hcbiAgICAgICAgfCBTY2hlZHVsZWRfYXQgb2YgVGltZS50XG4gICAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIGVuZFxuXG4gICAgdmFsIHN0YXR1cyA6ICgnYSwgJ2gpIHQgLT4gKCdhLCAnaCkgU3RhdHVzLnRcbiAgICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIHZhbCBydW5fYXQgOiBUaW1lLnQgLT4gKCd6IC0+ICdoKSAtPiAneiAtPiAoXywgJ2gpIHRcbiAgICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIHZhbCBydW5fYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoJ3ogLT4gJ2gpIC0+ICd6IC0+IChfLCAnaCkgdFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgbW9kdWxlIEFib3J0X3Jlc3VsdCA9IFRpbWVfc291cmNlLkV2ZW50LkFib3J0X3Jlc3VsdFxuXG4gICAgdmFsIGFib3J0IDogKCdhLCAnaCkgdCAtPiAnYSAtPiAoJ2EsICdoKSBBYm9ydF9yZXN1bHQudFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIGFib3J0X2V4biA6ICgnYSwgJ2gpIHQgLT4gJ2EgLT4gdW5pdFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIGFib3J0X2lmX3Bvc3NpYmxlIDogKCdhLCBfKSB0IC0+ICdhIC0+IHVuaXRcbiAgICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIG1vZHVsZSBGaXJlZCA9IFRpbWVfc291cmNlLkV2ZW50LkZpcmVkXG5cbiAgICB2YWwgZmlyZWQgOiAoJ2EsICdoKSB0IC0+ICgnYSwgJ2gpIEZpcmVkLnQgRGVmZXJyZWQudFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgbW9kdWxlIFJlc2NoZWR1bGVfcmVzdWx0ID0gVGltZV9zb3VyY2UuRXZlbnQuUmVzY2hlZHVsZV9yZXN1bHRcblxuICAgIHZhbCByZXNjaGVkdWxlX2F0IDogKCdhLCAnaCkgdCAtPiBUaW1lLnQgLT4gKCdhLCAnaCkgUmVzY2hlZHVsZV9yZXN1bHQudFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIHJlc2NoZWR1bGVfYWZ0ZXIgOiAoJ2EsICdoKSB0IC0+IFRpbWUuU3Bhbi50IC0+ICgnYSwgJ2gpIFJlc2NoZWR1bGVfcmVzdWx0LnRcbiAgICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIHZhbCBhdCA6IFRpbWUudCAtPiAoXywgdW5pdCkgdCBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoXywgdW5pdCkgdFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuICBlbmRcblxuICB2YWwgYXRfdmFyeWluZ19pbnRlcnZhbHNcbiAgICA6ICA/c3RvcDp1bml0IERlZmVycmVkLnRcbiAgICAtPiAodW5pdCAtPiBUaW1lLlNwYW4udClcbiAgICAtPiB1bml0IEFzeW5jX3N0cmVhbS50XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBhdF9pbnRlcnZhbHNcbiAgICA6ICA/c3RhcnQ6VGltZS50XG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50XG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiB1bml0IEFzeW5jX3N0cmVhbS50XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBldmVyeSdcbiAgICA6ICA/c3RhcnQ6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtyZXR1cm4gKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiA/ZmluaXNoZWQ6dW5pdCBJdmFyLnRcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQgRGVmZXJyZWQudClcbiAgICAtPiB1bml0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBldmVyeVxuICAgIDogID9zdGFydDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW3JldHVybiAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdClcbiAgICAtPiB1bml0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBydW5fYXRfaW50ZXJ2YWxzJ1xuICAgIDogID9zdGFydDpUaW1lLnQgKCoqIGRlZmF1bHQgaXMgW1RpbWUubm93ICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0IERlZmVycmVkLnQpXG4gICAgLT4gdW5pdFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgcnVuX2F0X2ludGVydmFsc1xuICAgIDogID9zdGFydDpUaW1lLnQgKCoqIGRlZmF1bHQgaXMgW1RpbWUubm93ICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0KVxuICAgIC0+IHVuaXRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIGR1cmF0aW9uX29mIDogKHVuaXQgLT4gJ2EgRGVmZXJyZWQudCkgLT4gKCdhICogVGltZS5TcGFuLnQpIERlZmVycmVkLnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5lbmRcblxuKCoqIEBpbmxpbmUgKilcbmluY2x1ZGUgKFxuICBzdHJ1Y3RcbiAgICBbQEBAd2FybmluZyBcIi0zXCJdXG5cbiAgICBtb2R1bGUgXyAoQyA6IENsb2NrKSA6IENsb2NrX2RlcHJlY2F0ZWQgPSBDXG4gICAgbW9kdWxlIF8gKEMgOiBDbG9ja19kZXByZWNhdGVkKSA6IENsb2NrID0gQ1xuICBlbmQgOlxuICAgIHNpZyBlbmQpXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIHR5cGUgQ2xvY2sgPSBDbG9ja19pbnRmLkNsb2NrXG5tb2R1bGUgdHlwZSBDbG9ja19kZXByZWNhdGVkID0gQ2xvY2tfaW50Zi5DbG9ja19kZXByZWNhdGVkXG5cbm1vZHVsZSBPcl90aW1lb3V0ID0gQ2xvY2tfaW50Zi5Pcl90aW1lb3V0XG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxuXG5sZXQgdGltZV9zb3VyY2UgKCkgPSAoU2NoZWR1bGVyLnQgKCkpLnRpbWVfc291cmNlIHw+IFRpbWVfc291cmNlLm9mX3N5bmNocm9ub3VzXG5sZXQgYWZ0ZXIgc3BhbiA9IFRpbWVfc291cmNlLmFmdGVyICh0aW1lX3NvdXJjZSAoKSkgc3BhblxubGV0IGF0IHRpbWUgPSBUaW1lX3NvdXJjZS5hdCAodGltZV9zb3VyY2UgKCkpIHRpbWVcblxubGV0IGF0X3ZhcnlpbmdfaW50ZXJ2YWxzID9zdG9wIGNvbXB1dGVfc3BhbiA9XG4gIFRpbWVfc291cmNlLmF0X3ZhcnlpbmdfaW50ZXJ2YWxzID9zdG9wICh0aW1lX3NvdXJjZSAoKSkgY29tcHV0ZV9zcGFuXG47O1xuXG5sZXQgYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCBpbnRlcnZhbCA9XG4gIFRpbWVfc291cmNlLmF0X2ludGVydmFscyA/c3RhcnQgP3N0b3AgKHRpbWVfc291cmNlICgpKSBpbnRlcnZhbFxuOztcblxubGV0IGV2ZXJ5JyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZCBzcGFuIGYgPVxuICBUaW1lX3NvdXJjZS5ldmVyeScgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciA/ZmluaXNoZWQgKHRpbWVfc291cmNlICgpKSBzcGFuIGZcbjs7XG5cbmxldCBldmVyeSA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIHNwYW4gZiA9XG4gIFRpbWVfc291cmNlLmV2ZXJ5ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgKHRpbWVfc291cmNlICgpKSBzcGFuIGZcbjs7XG5cbmxldCBydW5fYWZ0ZXIgc3BhbiBmIGEgPSBUaW1lX3NvdXJjZS5ydW5fYWZ0ZXIgKHRpbWVfc291cmNlICgpKSBzcGFuIGYgYVxubGV0IHJ1bl9hdCB0aW1lIGYgYSA9IFRpbWVfc291cmNlLnJ1bl9hdCAodGltZV9zb3VyY2UgKCkpIHRpbWUgZiBhXG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgaW50ZXJ2YWwgZiA9XG4gIFRpbWVfc291cmNlLnJ1bl9hdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciAodGltZV9zb3VyY2UgKCkpIGludGVydmFsIGZcbjs7XG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzJyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIGludGVydmFsIGYgPVxuICBUaW1lX3NvdXJjZS5ydW5fYXRfaW50ZXJ2YWxzJ1xuICAgID9zdGFydFxuICAgID9zdG9wXG4gICAgP2NvbnRpbnVlX29uX2Vycm9yXG4gICAgKHRpbWVfc291cmNlICgpKVxuICAgIGludGVydmFsXG4gICAgZlxuOztcblxubGV0IHdpdGhfdGltZW91dCBzcGFuIGQgPSBUaW1lX3NvdXJjZS53aXRoX3RpbWVvdXQgKHRpbWVfc291cmNlICgpKSBzcGFuIGRcblxubGV0IHdpdGhfdGltZW91dF9leG4gc3BhbiBkIH5lcnJvciA9XG4gIFRpbWVfc291cmNlLndpdGhfdGltZW91dF9leG4gKHRpbWVfc291cmNlICgpKSBzcGFuIGQgfmVycm9yXG47O1xuXG5sZXQgZHVyYXRpb25fb2YgZiA9IFRpbWVfc291cmNlLmR1cmF0aW9uX29mICh0aW1lX3NvdXJjZSAoKSkgZlxuXG5tb2R1bGUgRXZlbnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUaW1lX3NvdXJjZS5FdmVudFxuXG4gIGxldCBhZnRlciBzcGFuID0gYWZ0ZXIgKHRpbWVfc291cmNlICgpKSBzcGFuXG4gIGxldCBydW5fYWZ0ZXIgc3BhbiBmIGEgPSBydW5fYWZ0ZXIgKHRpbWVfc291cmNlICgpKSBzcGFuIGYgYVxuICBsZXQgYXQgdGltZSA9IGF0ICh0aW1lX3NvdXJjZSAoKSkgdGltZVxuICBsZXQgcnVuX2F0IHRpbWUgZiB6ID0gcnVuX2F0ICh0aW1lX3NvdXJjZSAoKSkgdGltZSBmIHpcbmVuZFxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIGkgYiA9XG4gICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRcbiAgICAgIHRoZW4gSXZhci5maWxsX2V4biByZXN1bHQgYlxuICAgICAgZWxzZSBmIGkgYiB0LihpKSA+Pj4gZnVuIGIgLT4gbG9vcCAoaSArIDEpIGJcbiAgICBpblxuICAgIGxvb3AgMCBpbml0KVxuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IGZvbGRpIHQgfmluaXQgfmY6KGZ1biBfIGEgeCAtPiBmIGEgeClcblxubGV0IHNlcW1hcGkgdCB+ZiA9XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCBpIG91dHB1dCA9XG4gICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRcbiAgICAgIHRoZW4gSXZhci5maWxsX2V4biByZXN1bHQgb3V0cHV0XG4gICAgICBlbHNlXG4gICAgICAgIGYgaSAoQXJyYXkuZ2V0IHQgaSlcbiAgICAgICAgPj4+IGZ1biBiIC0+XG4gICAgICAgIGxldCBvdXRwdXQgPSBpZiBpID0gMCB0aGVuIEFycmF5LmNyZWF0ZSB+bGVuOihBcnJheS5sZW5ndGggdCkgYiBlbHNlIG91dHB1dCBpblxuICAgICAgICBBcnJheS5zZXQgb3V0cHV0IGkgYjtcbiAgICAgICAgbG9vcCAoaSArIDEpIG91dHB1dFxuICAgIGluXG4gICAgbG9vcCAwIFt8fF0pXG47O1xuXG5sZXQgYWxsIGRzID0gc2VxbWFwaSBkcyB+ZjooZnVuIF8geCAtPiB4KVxubGV0IGFsbF91bml0IGRzID0gRGVmZXJyZWQuaWdub3JlX20gKGZvbGQgZHMgfmluaXQ6KCkgfmY6KGZ1biAoKSBkIC0+IGQpKVxuXG5sZXQgaXRlcmkgfmhvdyB0IH5mID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCAoYFBhcmFsbGVsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgYWxsX3VuaXQgKEFycmF5Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gIHwgYFNlcXVlbnRpYWwgLT4gZm9sZGkgdCB+aW5pdDooKSB+ZjooZnVuIGkgKCkgeCAtPiBmIGkgeClcbjs7XG5cbmxldCBtYXBpIH5ob3cgdCB+ZiA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgKGBQYXJhbGxlbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgIGFsbCAoQXJyYXkubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgfCBgU2VxdWVudGlhbCAtPiBzZXFtYXBpIHQgfmZcbjs7XG5cbmxldCBmaWx0ZXJpIH5ob3cgdCB+ZiA9XG4gIGxldCVtYXAgYm9vbHMgPSBtYXBpIHQgfmhvdyB+ZiBpblxuICBBcnJheS5vZl9saXN0X3JldlxuICAgIChBcnJheS5mb2xkMl9leG4gdCBib29scyB+aW5pdDpbXSB+ZjooZnVuIGFjIHggYiAtPiBpZiBiIHRoZW4geCA6OiBhYyBlbHNlIGFjKSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB+aG93IHQgfmYgPSBtYXBpIHQgfmhvdyB+ZiA+PnwgQXJyYXkuZmlsdGVyX29wdFxuXG5sZXQgY29uY2F0X21hcGkgfmhvdyB0IH5mID1cbiAgbGV0JW1hcCB0ID0gbWFwaSB0IH5ob3cgfmYgaW5cbiAgQXJyYXkuY29uY2F0IChBcnJheS50b19saXN0IHQpXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRcbiAgICB0aGVuIHJldHVybiBOb25lXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCViaW5kIGYgaSB0LihpKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gYXV4IChpICsgMSlcbiAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gcmV0dXJuIHNvbWUpXG4gIGluXG4gIGF1eCAwXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgKGksIGVsdCkgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gXyBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGVsdCBpblxuICAgIGlmIGIgdGhlbiBTb21lIGVsdCBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbWF0Y2glbWFwXG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiB0cnVlXG4gIHwgTm9uZSAtPiBmYWxzZVxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBub3QgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiBmYWxzZVxuICB8IE5vbmUgLT4gdHJ1ZVxuOztcblxubGV0IGl0ZXIgfmhvdyB0IH5mID0gaXRlcmkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBtYXAgfmhvdyB0IH5mID0gbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbHRlcl9tYXAgfmhvdyB0IH5mID0gZmlsdGVyX21hcGkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaWx0ZXIgfmhvdyB0IH5mID0gZmlsdGVyaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGNvbmNhdF9tYXAgfmhvdyB0IH5mID0gY29uY2F0X21hcGkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBpbml0IH5ob3cgbiB+ZiA9IG1hcCB+aG93IChBcnJheS5pbml0IG4gfmY6Rm4uaWQpIH5mXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCBpIGIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IEl2YXIuZmlsbF9leG4gcmVzdWx0IGJcbiAgICAgIHwgeCA6OiB4cyAtPiBmIGkgYiB4ID4+PiBmdW4gYiAtPiBsb29wIHhzIChpICsgMSkgYlxuICAgIGluXG4gICAgbG9vcCB0IDAgaW5pdClcbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPSBmb2xkaSB0IH5pbml0IH5mOihmdW4gXyBhIHggLT4gZiBhIHgpXG5cbmxldCBzZXFtYXBpIHQgfmYgPVxuICBmb2xkaSB0IH5pbml0OltdIH5mOihmdW4gaSBicyBhIC0+XG4gICAgbGV0JW1hcCBiID0gZiBpIGEgaW5cbiAgICBiIDo6IGJzKVxuICA+PnwgTGlzdC5yZXZcbjs7XG5cbmxldCBhbGwgZHMgPSBzZXFtYXBpIGRzIH5mOihmdW4gXyB4IC0+IHgpXG5sZXQgYWxsX3VuaXQgZHMgPSBEZWZlcnJlZC5pZ25vcmVfbSAoZm9sZCBkcyB+aW5pdDooKSB+ZjooZnVuICgpIGQgLT4gZCkpXG5cbmxldCBpdGVyaSB+aG93IHQgfmYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBQYXJhbGxlbCBhcyBob3cgLT5cbiAgICBhbGxfdW5pdCAoTGlzdC5tYXBpIHQgfmY6KHVuc3RhZ2UgKFRocm90dGxlLm1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZikpKVxuICB8IGBNYXhfY29uY3VycmVudF9qb2JzIGpvYl9jb3VudCAtPlxuICAgIGxldCByZWMgZ2VuX2NvbXB1dGF0aW9uIGlkeCA9IGZ1bmN0aW9uXG4gICAgICB8IHggOjogeHMgLT5cbiAgICAgICAgVGhyb3R0bGVkLm9mX3RodW5rIChmdW4gKCkgLT5cbiAgICAgICAgICBUaHJvdHRsZWQuYm90aF91bml0XG4gICAgICAgICAgICAoVGhyb3R0bGVkLmpvYiAoZnVuICgpIC0+IGYgaWR4IHgpKVxuICAgICAgICAgICAgKGdlbl9jb21wdXRhdGlvbiAoaWR4ICsgMSkgeHMpKVxuICAgICAgfCBbXSAtPiBUaHJvdHRsZWQucmV0dXJuICgpXG4gICAgaW5cbiAgICBUaHJvdHRsZWQucnVuIChnZW5fY29tcHV0YXRpb24gMCB0KSB+bWF4X2NvbmN1cnJlbnRfam9iczpqb2JfY291bnRcbiAgfCBgU2VxdWVudGlhbCAtPiBmb2xkaSB0IH5pbml0OigpIH5mOihmdW4gaSAoKSB4IC0+IGYgaSB4KVxuOztcblxubGV0IG1hcGkgfmhvdyB0IH5mID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgUGFyYWxsZWwgYXMgaG93IC0+XG4gICAgYWxsIChMaXN0Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gIHwgYE1heF9jb25jdXJyZW50X2pvYnMgam9iX2NvdW50IC0+XG4gICAgbGV0IHJlYyBnZW5fY29tcHV0YXRpb24gaWR4ID0gZnVuY3Rpb25cbiAgICAgIHwgeCA6OiB4cyAtPlxuICAgICAgICBUaHJvdHRsZWQub2ZfdGh1bmsgKGZ1biAoKSAtPlxuICAgICAgICAgIFRocm90dGxlZC5tYXAyXG4gICAgICAgICAgICAoVGhyb3R0bGVkLmpvYiAoZnVuICgpIC0+IGYgaWR4IHgpKVxuICAgICAgICAgICAgKGdlbl9jb21wdXRhdGlvbiAoaWR4ICsgMSkgeHMpXG4gICAgICAgICAgICB+ZjooZnVuIHkgeXMgLT4geSA6OiB5cykpXG4gICAgICB8IFtdIC0+IFRocm90dGxlZC5yZXR1cm4gW11cbiAgICBpblxuICAgIFRocm90dGxlZC5ydW4gKGdlbl9jb21wdXRhdGlvbiAwIHQpIH5tYXhfY29uY3VycmVudF9qb2JzOmpvYl9jb3VudFxuICB8IGBTZXF1ZW50aWFsIC0+IHNlcW1hcGkgdCB+ZlxuOztcblxubGV0IGZpbHRlcmkgfmhvdyB0IH5mID1cbiAgbGV0JW1hcCBib29scyA9IG1hcGkgdCB+aG93IH5mIGluXG4gIExpc3QucmV2IChMaXN0LmZvbGQyX2V4biB0IGJvb2xzIH5pbml0OltdIH5mOihmdW4gYWMgeCBiIC0+IGlmIGIgdGhlbiB4IDo6IGFjIGVsc2UgYWMpKVxuOztcblxubGV0IGZpbHRlcl9tYXBpIH5ob3cgdCB+ZiA9IG1hcGkgdCB+aG93IH5mID4+fCBMaXN0LmZpbHRlcl9vcHRcbmxldCBjb25jYXRfbWFwaSB+aG93IHQgfmYgPSBtYXBpIHQgfmhvdyB+ZiA+PnwgTGlzdC5jb25jYXRcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBmaW5kX21hcGkgdCB+ZiBpID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJldHVybiBOb25lXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgKG1hdGNoJWJpbmQgZiBpIGhkIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gZmluZF9tYXBpIHRsIH5mIChpICsgMSlcbiAgICAgICB8IFNvbWUgXyBhcyBzb21lIC0+IHJldHVybiBzb21lKVxuICBpblxuICBmaW5kX21hcGkgdCB+ZiAwXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgKGksIGVsdCkgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gXyBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGVsdCBpblxuICAgIGlmIGIgdGhlbiBTb21lIGVsdCBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbWF0Y2glbWFwXG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiB0cnVlXG4gIHwgTm9uZSAtPiBmYWxzZVxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBub3QgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiBmYWxzZVxuICB8IE5vbmUgLT4gdHJ1ZVxuOztcblxubGV0IGl0ZXIgfmhvdyB0IH5mID0gaXRlcmkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBtYXAgfmhvdyB0IH5mID0gbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbHRlciB+aG93IHQgfmYgPSBmaWx0ZXJpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyX21hcCB+aG93IHQgfmYgPSBmaWx0ZXJfbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGNvbmNhdF9tYXAgfmhvdyB0IH5mID0gY29uY2F0X21hcGkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBpbml0IH5ob3cgbiB+ZiA9IG1hcCB+aG93IChMaXN0LmluaXQgbiB+ZjpGbi5pZCkgfmZcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxubW9kdWxlIExpc3QgPSBEZWZlcnJlZF9saXN0XG5tb2R1bGUgVGhyb3R0bGVkX21hcCA9IE1hcC5NYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMgKFRocm90dGxlZClcblxudHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNYXAudFxuXG5sZXQgY2hhbmdlIHQgayB+ZiA9XG4gIGxldCVtYXAgb3B0ID0gZiAoTWFwLmZpbmQgdCBrKSBpblxuICBNYXAuY2hhbmdlIHQgayB+ZjooZnVuIF8gLT4gb3B0KVxuOztcblxubGV0IHVwZGF0ZSB0IGsgfmYgPVxuICBsZXQlbWFwIGRhdGEgPSBmIChNYXAuZmluZCB0IGspIGluXG4gIE1hcC5zZXQgdCB+a2V5OmsgfmRhdGFcbjs7XG5cbmxldCBpdGVyX2tleXMgfmhvdyB0IH5mID0gTGlzdC5pdGVyIH5ob3cgKE1hcC5rZXlzIHQpIH5mXG5sZXQgaXRlciB+aG93IHQgfmYgPSBMaXN0Lml0ZXIgfmhvdyAoTWFwLmRhdGEgdCkgfmZcbmxldCBpdGVyaSB+aG93IHQgfmYgPSBMaXN0Lml0ZXIgfmhvdyAoTWFwLnRvX2FsaXN0IHQpIH5mOihmdW4gKGtleSwgZGF0YSkgLT4gZiB+a2V5IH5kYXRhKVxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IGFsaXN0X2luX2luY3JlYXNpbmdfa2V5X29yZGVyID1cbiAgICBNYXAuZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhbGlzdCAtPiAoa2V5LCBkYXRhKSA6OiBhbGlzdClcbiAgaW5cbiAgTGlzdC5mb2xkIGFsaXN0X2luX2luY3JlYXNpbmdfa2V5X29yZGVyIH5pbml0IH5mOihmdW4gYWMgKGtleSwgZGF0YSkgLT4gZiB+a2V5IH5kYXRhIGFjKVxuOztcblxubGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9XG4gIGxldCBhbGlzdF9pbl9kZWNyZWFzaW5nX2tleV9vcmRlciA9XG4gICAgTWFwLmZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWxpc3QgLT4gKGtleSwgZGF0YSkgOjogYWxpc3QpXG4gIGluXG4gIExpc3QuZm9sZCBhbGlzdF9pbl9kZWNyZWFzaW5nX2tleV9vcmRlciB+aW5pdCB+ZjooZnVuIGFjIChrZXksIGRhdGEpIC0+IGYgfmtleSB+ZGF0YSBhYylcbjs7XG5cbm1vZHVsZSBKb2IgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9XG4gICAgeyBrZXkgOiAnYVxuICAgIDsgZGF0YSA6ICdiXG4gICAgOyBtdXRhYmxlIHJlc3VsdCA6ICdjIG9wdGlvblxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzXVxuZW5kXG5cbmxldCBmaWx0ZXJfbWFwaV9zZXF1ZW50aWFsIHQgfmYgPVxuICBsZXQgY29tcGFyYXRvciA9IE1hcC5jb21wYXJhdG9yIHQgaW5cbiAgbGV0IHNlcXVlbmNlID0gTWFwLnRvX3NlcXVlbmNlIH5vcmRlcjpgSW5jcmVhc2luZ19rZXkgdCBpblxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+XG4gICAgU2VxdWVuY2UuZGVsYXllZF9mb2xkXG4gICAgICBzZXF1ZW5jZVxuICAgICAgfmluaXQ6QmFzZS5NYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLkJ1aWxkX2luY3JlYXNpbmcuZW1wdHlcbiAgICAgIH5mOihmdW4gcyAoa2V5LCBkYXRhKSB+ayAtPlxuICAgICAgICB1cG9uIChmIH5rZXkgfmRhdGEpIChmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBrIHNcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgbGV0IHMgPVxuICAgICAgICAgICAgICBCYXNlLk1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuQnVpbGRfaW5jcmVhc2luZy5hZGRfZXhuXG4gICAgICAgICAgICAgICAgc1xuICAgICAgICAgICAgICAgIH5jb21wYXJhdG9yXG4gICAgICAgICAgICAgICAgfmtleVxuICAgICAgICAgICAgICAgIH5kYXRhXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgayBzKSlcbiAgICAgIH5maW5pc2g6KGZ1biB4IC0+XG4gICAgICAgIEl2YXIuZmlsbF9leG5cbiAgICAgICAgICBpdmFyXG4gICAgICAgICAgKE1hcC5Vc2luZ19jb21wYXJhdG9yLm9mX3RyZWVcbiAgICAgICAgICAgICB+Y29tcGFyYXRvclxuICAgICAgICAgICAgIChCYXNlLk1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuQnVpbGRfaW5jcmVhc2luZy50b190cmVlIHgpKSkpXG47O1xuXG5sZXQgZmlsdGVyX21hcGlfbWF4X2NvbmN1cnJlbnQgdCB+ZiB+bWF4X2NvbmN1cnJlbnRfam9icyA9XG4gIGxldCBjb21wdXRhdGlvbiA9XG4gICAgVGhyb3R0bGVkX21hcC5maWx0ZXJfbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgVGhyb3R0bGVkLmpvYiAoZnVuICgpIC0+IGYgfmtleSB+ZGF0YSkpXG4gIGluXG4gIFRocm90dGxlZC5ydW4gY29tcHV0YXRpb24gfm1heF9jb25jdXJyZW50X2pvYnNcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB+aG93IHQgfmYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBTZXF1ZW50aWFsIC0+IGZpbHRlcl9tYXBpX3NlcXVlbnRpYWwgdCB+ZlxuICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG1heF9jb25jdXJyZW50X2pvYnMgLT5cbiAgICBmaWx0ZXJfbWFwaV9tYXhfY29uY3VycmVudCB0IH5mIH5tYXhfY29uY3VycmVudF9qb2JzXG4gIHwgYFBhcmFsbGVsIC0+XG4gICAgbGV0IGpvYnMgPSByZWYgW10gaW5cbiAgICBsZXQgam9iX21hcCA9XG4gICAgICBNYXAubWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICBsZXQgam9iID0geyBKb2Iua2V5OyBkYXRhOyByZXN1bHQgPSBOb25lIH0gaW5cbiAgICAgICAgam9icyA6PSBqb2IgOjogIWpvYnM7XG4gICAgICAgIGpvYilcbiAgICBpblxuICAgIGxldCVtYXAgKCkgPVxuICAgICAgTGlzdC5pdGVyIH5ob3cgKEJhc2UuTGlzdC5yZXYgIWpvYnMpIH5mOihmdW5jdGlvblxuICAgICAgICB8IHsgSm9iLmtleTsgZGF0YTsgcmVzdWx0ID0gXyB9IGFzIGpvYiAtPlxuICAgICAgICBsZXQlbWFwIHggPSBmIH5rZXkgfmRhdGEgaW5cbiAgICAgICAgam9iLnJlc3VsdCA8LSB4KVxuICAgIGluXG4gICAgTWFwLmZpbHRlcl9tYXAgam9iX21hcCB+ZjpKb2IucmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX21hcCB+aG93IHQgfmYgPSBmaWx0ZXJfbWFwaSB+aG93IHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgZmlsdGVyX2tleXMgfmhvdyB0IH5mID1cbiAgZmlsdGVyX21hcGkgfmhvdyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIGxldCVtYXAgYiA9IGYga2V5IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgZGF0YSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZmlsdGVyIH5ob3cgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpIH5ob3cgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPlxuICAgIGxldCVtYXAgYiA9IGYgZGF0YSBpblxuICAgIGlmIGIgdGhlbiBTb21lIGRhdGEgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbHRlcmkgfmhvdyB0IH5mID1cbiAgZmlsdGVyX21hcGkgfmhvdyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIGxldCVtYXAgYiA9IGYgfmtleSB+ZGF0YSBpblxuICAgIGlmIGIgdGhlbiBTb21lIGRhdGEgZWxzZSBOb25lKVxuOztcblxubGV0IG1hcGlfbWF4X2NvbmN1cnJlbnQgdCB+ZiB+bWF4X2NvbmN1cnJlbnRfam9icyA9XG4gIGxldCBjb21wdXRhdGlvbiA9XG4gICAgVGhyb3R0bGVkX21hcC5tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IFRocm90dGxlZC5qb2IgKGZ1biAoKSAtPiBmIH5rZXkgfmRhdGEpKVxuICBpblxuICBUaHJvdHRsZWQucnVuIGNvbXB1dGF0aW9uIH5tYXhfY29uY3VycmVudF9qb2JzXG47O1xuXG5sZXQgbWFwaSB+aG93IHQgfmYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBTZXF1ZW50aWFsIHwgYFBhcmFsbGVsIC0+XG4gICAgZmlsdGVyX21hcGkgfmhvdyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgbGV0JW1hcCB6ID0gZiB+a2V5IH5kYXRhIGluXG4gICAgICBTb21lIHopXG4gIHwgYE1heF9jb25jdXJyZW50X2pvYnMgbWF4X2NvbmN1cnJlbnRfam9icyAtPlxuICAgIG1hcGlfbWF4X2NvbmN1cnJlbnQgdCB+ZiB+bWF4X2NvbmN1cnJlbnRfam9ic1xuOztcblxubGV0IG1hcCB+aG93IHQgfmYgPSBtYXBpIH5ob3cgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBtZXJnZSB+aG93IHQxIHQyIH5mID1cbiAgZmlsdGVyX21hcFxuICAgIH5ob3dcbiAgICAoTWFwLm1lcmdlIHQxIHQyIH5mOihmdW4gfmtleSB6IC0+IFNvbWUgKGZ1biAoKSAtPiBmIH5rZXkgeikpKVxuICAgIH5mOihmdW4gdGh1bmsgLT4gdGh1bmsgKCkpXG47O1xuXG5sZXQgYWxsIHQgPSBtYXAgdCB+ZjpGbi5pZCB+aG93OmBTZXF1ZW50aWFsXG4iLCJvcGVuISBDb3JlXG5vcGVuISBEZWZlcnJlZF9zdGRcbmluY2x1ZGUgRGVmZXJyZWRfbWVtb19pbnRmXG5cbm1vZHVsZSBNYWtlIChNIDogTW9uYWQuSW5maXggd2l0aCB0eXBlICdhIHQgPSAnYSBEZWZlcnJlZDEudCkgOlxuICBTIHdpdGggdHlwZSAnYSBkZWZlcnJlZCA6PSAnYSBNLnQgPSBzdHJ1Y3RcbiAgb3BlbiEgTVxuXG4gIGxldCByZXJhaXNlID0gZnVuY3Rpb25cbiAgICB8IE9rIHggLT4geFxuICAgIHwgRXJyb3IgZXhuIC0+IEV4bi5yZXJhaXNlIGV4biBcImNhdWdodCBleGNlcHRpb24gaW4gbWVtb2l6ZWQgZnVuY3Rpb25cIlxuICA7O1xuXG4gIGxldCBnZW5lcmFsJyAodHlwZSBhKSB+cnVuIChoYXNoYWJsZSA6IChtb2R1bGUgSGFzaGFibGUuU19wbGFpbiB3aXRoIHR5cGUgdCA9IGEpKSBmID1cbiAgICBsZXQgbW9kdWxlIEhhc2hhYmxlID0gKHZhbCBoYXNoYWJsZSkgaW5cbiAgICBsZXQgZiA9XG4gICAgICBNZW1vLmdlbmVyYWwgfmhhc2hhYmxlOkhhc2hhYmxlLmhhc2hhYmxlIChmdW4gYSAtPlxuICAgICAgICBNb25pdG9yLnRyeV93aXRoIH5yZXN0OmBMb2cgfnJ1biAoZnVuICgpIC0+IGYgYSkpXG4gICAgaW5cbiAgICBTdGFnZWQuc3RhZ2UgKGZ1biBhIC0+IGYgYSA+PnwgcmVyYWlzZSlcbiAgOztcblxuICBsZXQgZ2VuZXJhbCBoYXNoYWJsZSBmID0gZ2VuZXJhbCcgfnJ1bjpgTm93IGhhc2hhYmxlIGZcblxuICBsZXQgcmVjdXJzaXZlICh0eXBlIGEpIChoYXNoYWJsZSA6IChtb2R1bGUgSGFzaGFibGUuU19wbGFpbiB3aXRoIHR5cGUgdCA9IGEpKSBmX29uZXN0ZXAgPVxuICAgIGxldCByZWMgbWVtb2l6ZWQgPVxuICAgICAgbGF6eVxuICAgICAgICAoZ2VuZXJhbCdcbiAgICAgICAgICAgfnJ1bjpgU2NoZWR1bGVcbiAgICAgICAgICAgaGFzaGFibGVcbiAgICAgICAgICAgKGZfb25lc3RlcCAoZnVuIHggLT4gKHVuc3RhZ2UgKGZvcmNlIG1lbW9pemVkKSkgeCkpKVxuICAgIGluXG4gICAgZm9yY2UgbWVtb2l6ZWRcbiAgOztcblxuICBsZXQgdW5pdCBmID1cbiAgICBsZXQgZiA9IE1lbW8udW5pdCAoZnVuICgpIC0+IE1vbml0b3IudHJ5X3dpdGggfnJlc3Q6YExvZyB+cnVuOmBOb3cgZikgaW5cbiAgICBTdGFnZWQuc3RhZ2UgKGZ1biAoKSAtPiBmICgpID4+fCByZXJhaXNlKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgTWFrZSAoRGVmZXJyZWQxKVxuIiwib3BlbiBDb3JlXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgT3B0aW9uLnQgRGVmZXJyZWQudFxuZW5kXG5cbmluY2x1ZGUgVFxuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgcmV0dXJuIGEgPSBEZWZlcnJlZC5yZXR1cm4gKFNvbWUgYSlcblxuICBsZXQgYmluZCB0IH5mID1cbiAgICBEZWZlcnJlZC5iaW5kIHQgfmY6KGZ1bmN0aW9uXG4gICAgICB8IFNvbWUgYSAtPiBmIGFcbiAgICAgIHwgTm9uZSAtPiBEZWZlcnJlZC5yZXR1cm4gTm9uZSlcbiAgOztcblxuICBsZXQgbWFwIHQgfmYgPSBEZWZlcnJlZC5tYXAgdCB+ZjooZnVuIHIgLT4gT3B0aW9uLm1hcCByIH5mKVxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbmVuZClcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2Vycm9yKSB0ID0gKCdhLCAnZXJyb3IpIFJlc3VsdC50IERlZmVycmVkLnRcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IGNvbWJpbmUgdDEgdDIgfm9rIH5lcnIgPVxuICBsZXQlbWFwIHQxID0gdDFcbiAgYW5kIHQyID0gdDIgaW5cbiAgUmVzdWx0LmNvbWJpbmUgdDEgdDIgfm9rIH5lcnJcbjs7XG5cbmluY2x1ZGUgTW9uYWQuTWFrZTIgKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgcmV0dXJuIGEgPSBEZWZlcnJlZC5yZXR1cm4gKE9rIGEpXG5cbiAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgRGVmZXJyZWQuYmluZCB0IH5mOihmdW5jdGlvblxuICAgICAgfCBPayBhIC0+IGYgYVxuICAgICAgfCBFcnJvciBfIGFzIGVycm9yIC0+IERlZmVycmVkLnJldHVybiBlcnJvcilcbiAgOztcblxuICBsZXQgbWFwIHQgfmYgPSBEZWZlcnJlZC5tYXAgdCB+ZjooZnVuIHIgLT4gUmVzdWx0Lm1hcCByIH5mKVxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbmVuZClcblxubGV0IGZhaWwgeCA9IERlZmVycmVkLnJldHVybiAoRXJyb3IgeClcbmxldCBmYWlsZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgZmFpbCBmb3JtYXRcbmxldCBtYXBfZXJyb3IgdCB+ZiA9IERlZmVycmVkLm1hcCB0IH5mOihmdW4gciAtPiBSZXN1bHQubWFwX2Vycm9yIHIgfmYpXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgTW9uaXRvciA9IHN0cnVjdFxuICBsZXQgdHJ5X3dpdGggPSBNb25pdG9yLnRyeV93aXRoXG5lbmRcblxuKCogQ29waWVkIHRvIFtlYWdlcl9kZWZlcnJlZF9vcl9lcnJvci5tbF0uICBUaGVyZSBzaG91bGQgYmUgbm8gZGlmZnMgYmVsb3cgdGhpcyBsaW5lLiAqKVxuXG5pbmNsdWRlIChEZWZlcnJlZF9yZXN1bHQgOiBNb25hZC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBEZWZlcnJlZF9yZXN1bHQudClcblxudHlwZSAnYSB0ID0gJ2EgT3JfZXJyb3IudCBEZWZlcnJlZC50XG5cbmluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gIGxldCBhcHBseSBmIHggPVxuICAgIERlZmVycmVkX3Jlc3VsdC5jb21iaW5lXG4gICAgICBmXG4gICAgICB4XG4gICAgICB+b2s6KGZ1biBmIHggLT4gZiB4KVxuICAgICAgfmVycjooZnVuIGUxIGUyIC0+IEVycm9yLm9mX2xpc3QgWyBlMTsgZTIgXSlcbiAgOztcblxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbmVuZClcblxubW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwID0gbWFwXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IGJvdGggPSBib3RoXG5cbiAgICAoKiBmcm9tIEFwcGxpY2F0aXZlLk1ha2UgKilcbiAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gIGVuZFxuZW5kXG5cbm9wZW4gTGV0X3N5bnRheFxuXG5sZXQgZmFpbCBlcnJvciA9IERlZmVycmVkLnJldHVybiAoUmVzdWx0LmZhaWwgZXJyb3IpXG5sZXQgb2tfZXhuIHQgPSBEZWZlcnJlZC5tYXAgdCB+ZjpPcl9lcnJvci5va19leG5cbmxldCBvZl9leG4gP2JhY2t0cmFjZSBleG4gPSBEZWZlcnJlZC5yZXR1cm4gKE9yX2Vycm9yLm9mX2V4biA/YmFja3RyYWNlIGV4bilcbmxldCBvZl9leG5fcmVzdWx0ID9iYWNrdHJhY2UgdCA9IERlZmVycmVkLm1hcCB0IH5mOihPcl9lcnJvci5vZl9leG5fcmVzdWx0ID9iYWNrdHJhY2UpXG5sZXQgZXJyb3IgbXNnIHYgc2V4cF9vZiA9IERlZmVycmVkLnJldHVybiAoT3JfZXJyb3IuZXJyb3IgbXNnIHYgc2V4cF9vZilcbmxldCBlcnJvcl9zIHNleHAgPSBEZWZlcnJlZC5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3Mgc2V4cClcbmxldCBlcnJvcl9zdHJpbmcgbXNnID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgbXNnKVxubGV0IGVycm9yZiBmb3JtYXQgPSBrc3ByaW50ZiBlcnJvcl9zdHJpbmcgZm9ybWF0XG5sZXQgdGFnIHQgfnRhZyA9IERlZmVycmVkLm1hcCB0IH5mOihPcl9lcnJvci50YWcgfnRhZylcbmxldCB0YWdfcyB0IH50YWcgPSBEZWZlcnJlZC5tYXAgdCB+ZjooT3JfZXJyb3IudGFnX3MgfnRhZylcbmxldCB0YWdfc19sYXp5IHQgfnRhZyA9IERlZmVycmVkLm1hcCB0IH5mOihPcl9lcnJvci50YWdfc19sYXp5IH50YWcpXG5cbmxldCB0YWdfYXJnIHQgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIERlZmVycmVkLm1hcCB0IH5mOihmdW4gdCAtPiBPcl9lcnJvci50YWdfYXJnIHQgbWVzc2FnZSBhIHNleHBfb2ZfYSlcbjs7XG5cbmxldCB1bmltcGxlbWVudGVkIG1zZyA9IERlZmVycmVkLnJldHVybiAoT3JfZXJyb3IudW5pbXBsZW1lbnRlZCBtc2cpXG5sZXQgY29tYmluZV9lcnJvcnMgbCA9IERlZmVycmVkLm1hcCAoRGVmZXJyZWQuYWxsIGwpIH5mOk9yX2Vycm9yLmNvbWJpbmVfZXJyb3JzXG5sZXQgY29tYmluZV9lcnJvcnNfdW5pdCBsID0gRGVmZXJyZWQubWFwIChEZWZlcnJlZC5hbGwgbCkgfmY6T3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdFxuXG5sZXQgZmlsdGVyX29rX2F0X2xlYXN0X29uZSBsID1cbiAgRGVmZXJyZWQubWFwIChEZWZlcnJlZC5hbGwgbCkgfmY6T3JfZXJyb3IuZmlsdGVyX29rX2F0X2xlYXN0X29uZVxuOztcblxubGV0IGZpbmRfbWFwX29rIGwgfmYgPVxuICBEZWZlcnJlZC5yZXBlYXRfdW50aWxfZmluaXNoZWQgKGwsIFtdKSAoZnVuIChsLCBlcnJvcnMpIC0+XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgbGV0IGVycm9ycyA9IEVycm9yLm9mX2xpc3QgKExpc3QucmV2IGVycm9ycykgaW5cbiAgICAgIERlZmVycmVkLnJldHVybiAoYEZpbmlzaGVkIChFcnJvciBlcnJvcnMpKVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIERlZmVycmVkLm1hcCAoZiBoZCkgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgRXJyb3IgY3VycmVudF9lcnJvciAtPiBgUmVwZWF0ICh0bCwgY3VycmVudF9lcnJvciA6OiBlcnJvcnMpXG4gICAgICAgIHwgT2sgcmVzdWx0IC0+IGBGaW5pc2hlZCAoT2sgcmVzdWx0KSkpXG47O1xuXG5sZXQgb2tfdW5pdCA9IHJldHVybiAoKVxuXG5sZXQgdHJ5X3dpdGggP2V4dHJhY3RfZXhuID9ydW4gP3Jlc3QgP2hlcmUgP25hbWUgZiA9XG4gIERlZmVycmVkLm1hcCAoTW9uaXRvci50cnlfd2l0aCA/ZXh0cmFjdF9leG4gP3J1biA/cmVzdCA/aGVyZSA/bmFtZSBmKSB+ZjooZnVuY3Rpb25cbiAgICB8IEVycm9yIGV4biAtPiBFcnJvciAoRXJyb3Iub2ZfZXhuIGV4bilcbiAgICB8IE9rIF8gYXMgb2sgLT4gb2spXG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbiA/ZXh0cmFjdF9leG4gP3J1biA/cmVzdCA/aGVyZSA/bmFtZSBmID1cbiAgRGVmZXJyZWQubWFwICh0cnlfd2l0aCA/ZXh0cmFjdF9leG4gP3J1biA/cmVzdCA/aGVyZSA/bmFtZSBmKSB+ZjpPcl9lcnJvci5qb2luXG47O1xuXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBsZXQgZm9sZGkgbGlzdCB+aW5pdDphY2MgfmYgPVxuICAgIGxldCByZWMgbG9vcCBpIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiBhY2NcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgbGV0JWJpbmQgYWNjID0gZiBpIGFjYyBoZCBpblxuICAgICAgICBsb29wIChpICsgMSkgYWNjIHRsXG4gICAgaW5cbiAgICBsb29wIDAgYWNjIGxpc3RcbiAgOztcblxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gZm9sZGkgdCB+aW5pdCB+ZjooZnVuIF8gYSB4IC0+IGYgYSB4KVxuXG4gIGxldCBzZXFtYXBpIHQgfmYgPVxuICAgIGZvbGRpIHQgfmluaXQ6W10gfmY6KGZ1biBpIGJzIGEgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBhIGluXG4gICAgICBiIDo6IGJzKVxuICAgID4+fCBMaXN0LnJldlxuICA7O1xuXG4gIGxldCBhbGwgPSBhbGxcbiAgbGV0IGFsbF91bml0ID0gYWxsX3VuaXRcblxuICBsZXQgaXRlcmkgfmhvdyB0IH5mID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgKGBQYXJhbGxlbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgICAgYWxsX3VuaXQgKExpc3QubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgICB8IGBTZXF1ZW50aWFsIC0+IGZvbGRpIHQgfmluaXQ6KCkgfmY6KGZ1biBpICgpIHggLT4gZiBpIHgpXG4gIDs7XG5cbiAgbGV0IG1hcGkgfmhvdyB0IH5mID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgKGBQYXJhbGxlbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgICAgYWxsIChMaXN0Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gICAgfCBgU2VxdWVudGlhbCAtPiBzZXFtYXBpIHQgfmZcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgfmhvdyB0IH5mID0gbWFwaSB0IH5ob3cgfmYgPj58IExpc3QuZmlsdGVyX29wdFxuICBsZXQgY29uY2F0X21hcGkgfmhvdyB0IH5mID0gbWFwaSB0IH5ob3cgfmYgPj58IExpc3QuY29uY2F0XG5cbiAgbGV0IGZpbHRlcmkgfmhvdyB0IH5mID1cbiAgICBmaWx0ZXJfbWFwaSB+aG93IHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSB4IGluXG4gICAgICBpZiBiIHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcbiAgOztcblxuICBsZXQgZmluZF9tYXBpIHQgfmYgPVxuICAgIGxldCByZWMgZmluZF9tYXBpIHQgfmYgaSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gcmV0dXJuIE5vbmVcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgKG1hdGNoJWJpbmQgZiBpIGhkIHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcGkgdGwgfmYgKGkgKyAxKVxuICAgICAgICAgfCBTb21lIF8gYXMgc29tZSAtPiByZXR1cm4gc29tZSlcbiAgICBpblxuICAgIGZpbmRfbWFwaSB0IH5mIDBcbiAgOztcblxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IGZpbmRfbWFwaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcblxuICBsZXQgZmluZGkgdCB+ZiA9XG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgKGksIGVsdCkgZWxzZSBOb25lKVxuICA7O1xuXG4gIGxldCBmaW5kIHQgfmYgPVxuICAgIGZpbmRfbWFwIHQgfmY6KGZ1biBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgZWx0IGluXG4gICAgICBpZiBiIHRoZW4gU29tZSBlbHQgZWxzZSBOb25lKVxuICA7O1xuXG4gIGxldCBleGlzdHNpIHQgfmYgPVxuICAgIG1hdGNoJW1hcFxuICAgICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICAgIGlmIGIgdGhlbiBTb21lICgpIGVsc2UgTm9uZSlcbiAgICB3aXRoXG4gICAgfCBTb21lICgpIC0+IHRydWVcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9XG4gICAgbWF0Y2glbWFwXG4gICAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgICAgaWYgbm90IGIgdGhlbiBTb21lICgpIGVsc2UgTm9uZSlcbiAgICB3aXRoXG4gICAgfCBTb21lICgpIC0+IGZhbHNlXG4gICAgfCBOb25lIC0+IHRydWVcbiAgOztcblxuICBsZXQgaXRlciB+aG93IHQgfmYgPSBpdGVyaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgbWFwIH5ob3cgdCB+ZiA9IG1hcGkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGZpbHRlciB+aG93IHQgfmYgPSBmaWx0ZXJpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBmaWx0ZXJfbWFwIH5ob3cgdCB+ZiA9IGZpbHRlcl9tYXBpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBjb25jYXRfbWFwIH5ob3cgdCB+ZiA9IGNvbmNhdF9tYXBpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZm9yX2FsbCB0IH5mID0gZm9yX2FsbGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBpbml0IH5ob3cgbiB+ZiA9IG1hcCB+aG93IChMaXN0LmluaXQgbiB+ZjpGbi5pZCkgfmZcbmVuZFxuXG5sZXQgcmVjIHJlcGVhdF91bnRpbF9maW5pc2hlZCBzdGF0ZSBmID1cbiAgbWF0Y2glYmluZCBmIHN0YXRlIHdpdGhcbiAgfCBgUmVwZWF0IHN0YXRlIC0+IHJlcGVhdF91bnRpbF9maW5pc2hlZCBzdGF0ZSBmXG4gIHwgYEZpbmlzaGVkIHN0YXRlIC0+IHJldHVybiBzdGF0ZVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBMaXN0ID0gRGVmZXJyZWRfbGlzdFxuXG4oKiBXZSBpbXBsZW1lbnQgYWxsIG9mIHRoZSBbUXVldWVdIG9wZXJhdGlvbnMgYnkgY29udmVydGluZyB0aGUgcXVldWUgdG8gYSBsaXN0IGFuZCB0aGVuXG4gICB1c2luZyB0aGUgY29ycmVzcG9uZGluZyBbTGlzdF0gb3BlcmF0aW9uLiAgV2UgdXNlIGxpc3RzIHJhdGhlciB0aGFuIGFycmF5cyBiZWNhdXNlXG4gICBhcnJheXMgbG9uZ2VyIHRoYW4gYSBjZXJ0YWluIGxlbmd0aCBhcmUgYWxsb2NhdGVkIGluIHRoZSBtYWpvciBoZWFwLCB3aGljaCBjYW4gY2F1c2VcbiAgIHVubmVjZXNzYXJ5IHByb21vdGlvbiBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLiAgQWxzbywgd2hlbiBvbmUgaXMgZm9sZGluZyBvclxuICAgaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXksIHRoZSBlbnRpcmUgYXJyYXkgbXVzdCBiZSBrZXB0IGFsaXZlLiAgV2hlbiBmb2xkaW5nIG9yXG4gICBpdGVyYXRpbmcgb3ZlciBhIGxpc3QsIG9ubHkgdGhlIHJlbWFpbmluZyB0YWlsIG9mIHRoZSBsaXN0IGlzIGtlcHQgYWxpdmUuICBTbywgdXNpbmdcbiAgIGFycmF5cyByYXRoZXIgdGhhbiBsaXN0cyB3b3VsZCBpbmNyZWFzZSB0aGUgbGl2ZS1zcGFjZSBuZWVkZWQgYnkgdGhlIHByb2dyYW0uICopXG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID0gTGlzdC5mb2xkaSAoUXVldWUudG9fbGlzdCB0KSB+aW5pdCB+ZlxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IExpc3QuZm9sZCAoUXVldWUudG9fbGlzdCB0KSB+aW5pdCB+ZlxubGV0IGFsbCB0ID0gTGlzdC5hbGwgKFF1ZXVlLnRvX2xpc3QgdCkgPj58IFF1ZXVlLm9mX2xpc3RcbmxldCBhbGxfdW5pdCB0ID0gTGlzdC5hbGxfdW5pdCAoUXVldWUudG9fbGlzdCB0KVxubGV0IGl0ZXIgfmhvdyB0IH5mID0gTGlzdC5pdGVyIH5ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBpdGVyaSB+aG93IHQgfmYgPSBMaXN0Lml0ZXJpIH5ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBtYXAgfmhvdyB0IH5mID0gTGlzdC5tYXAgfmhvdyAoUXVldWUudG9fbGlzdCB0KSB+ZiA+PnwgUXVldWUub2ZfbGlzdFxubGV0IG1hcGkgfmhvdyB0IH5mID0gTGlzdC5tYXBpIH5ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmYgPj58IFF1ZXVlLm9mX2xpc3RcbmxldCBpbml0IH5ob3cgbiB+ZiA9IExpc3QuaW5pdCB+aG93IG4gfmYgPj58IFF1ZXVlLm9mX2xpc3RcbmxldCBmaWx0ZXIgfmhvdyB0IH5mID0gTGlzdC5maWx0ZXIgfmhvdyAoUXVldWUudG9fbGlzdCB0KSB+ZiA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGZpbHRlcmkgfmhvdyB0IH5mID0gTGlzdC5maWx0ZXJpIH5ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmYgPj58IFF1ZXVlLm9mX2xpc3RcbmxldCBmaWx0ZXJfbWFwIH5ob3cgdCB+ZiA9IExpc3QuZmlsdGVyX21hcCB+aG93IChRdWV1ZS50b19saXN0IHQpIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgZmlsdGVyX21hcGkgfmhvdyB0IH5mID0gTGlzdC5maWx0ZXJfbWFwaSB+aG93IChRdWV1ZS50b19saXN0IHQpIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5cbmxldCBjb25jYXRfbWFwIH5ob3cgdCB+ZiA9XG4gIExpc3QuY29uY2F0X21hcCB+aG93IChRdWV1ZS50b19saXN0IHQpIH5mOihmdW4geCAtPiBmIHggPj58IFF1ZXVlLnRvX2xpc3QpXG4gID4+fCBRdWV1ZS5vZl9saXN0XG47O1xuXG5sZXQgY29uY2F0X21hcGkgfmhvdyB0IH5mID1cbiAgTGlzdC5jb25jYXRfbWFwaSB+aG93IChRdWV1ZS50b19saXN0IHQpIH5mOihmdW4gaSB4IC0+IGYgaSB4ID4+fCBRdWV1ZS50b19saXN0KVxuICA+PnwgUXVldWUub2ZfbGlzdFxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPSBMaXN0LmZpbmRfbWFwIChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgZmluZF9tYXBpIHQgfmYgPSBMaXN0LmZpbmRfbWFwaSAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGZpbmQgdCB+ZiA9IExpc3QuZmluZCAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGZpbmRpIHQgfmYgPSBMaXN0LmZpbmRpIChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgZm9yX2FsbCB0IH5mID0gTGlzdC5mb3JfYWxsIChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgZm9yX2FsbGkgdCB+ZiA9IExpc3QuZm9yX2FsbGkgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBleGlzdHMgdCB+ZiA9IExpc3QuZXhpc3RzIChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgZXhpc3RzaSB0IH5mID0gTGlzdC5leGlzdHNpIChRdWV1ZS50b19saXN0IHQpIH5mXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxuKCogW2ZvbGRfbWFwaSB+aG93IHQgfmluaXQgfm1hcGlfZiB+Zm9sZF9mXSBpcyBhIG1vcmUgZWZmaWNpZW50IHZlcnNpb24gb2Y6XG5cbiAgIHtbXG4gICAgIGZvbGQgfmluaXQgfmY6KGZ1biBiIGEgLT4gcmV0dXJuIChmb2xkX2YgYiBhKSkgKG1hcGkgdCB+aG93IH5mOm1hcGlfZikgXX1cblxuICAgSXQgYXZvaWRzIGNyZWF0aW5nIHRoZSBpbnRlcm1lZGlhdGUgc2VxdWVuY2UgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBbbWFwaV0sIGFuZFxuICAgYWxsb3dzIHRoZSBbZm9sZF0gdG8gcHJvY2VlZCBjb25jdXJyZW50bHkgd2l0aCB0aGUgW21hcGldLCBzbyB0aGF0IG9uZSBjYW4gYWNjdW11bGF0ZVxuICAgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlLCBwb3NzaWJseSBhdm9pZGluZyBjcmVhdGluZyBhbiBpbnRlcm1lZGlhdGUgc3RydWN0dXJlXG4gICAoZS5nLiBbaXRlcmldIGFuZCBbZmlsdGVyX21hcF0gdXNlcyBbZm9sZF9tYXBpXSB0byBkbyB0aGlzKS4gKilcbmxldCBmb2xkX21hcGlcbiAgKHR5cGUgYSBiIGMpXG4gID8oaG93ID0gYFNlcXVlbnRpYWwpXG4gICh0IDogYSBTZXF1ZW5jZS50KVxuICB+KGluaXQgOiBjKVxuICB+KG1hcGlfZiA6IGludCAtPiBhIC0+IGIgRGVmZXJyZWQudClcbiAgfihmb2xkX2YgOiBjIC0+IGIgLT4gYylcbiAgOiBjIERlZmVycmVkLnRcbiAgPVxuICBsZXQldHlkaSAoU2VxdWVuY2UgeyBzdGF0ZTsgbmV4dCB9KSA9IFNlcXVlbmNlLkV4cGVydC52aWV3IHQgaW5cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgU2VxdWVudGlhbCAtPlxuICAgIGxldCByZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgIGxldCByZWMgbG9vcCBpIHN0YXRlIChjIDogYykgPVxuICAgICAgbWF0Y2ggbmV4dCBzdGF0ZSB3aXRoXG4gICAgICB8IERvbmUgLT4gSXZhci5maWxsX2V4biByZXN1bHQgY1xuICAgICAgfCBTa2lwIHsgc3RhdGUgfSAtPiBsb29wIGkgc3RhdGUgKGMgOiBjKVxuICAgICAgfCBZaWVsZCB7IHN0YXRlOyB2YWx1ZSA9IGEgfSAtPlxuICAgICAgICB1cG9uIChtYXBpX2YgaSBhKSAoZnVuIGIgLT4gbG9vcCAoaSArIDEpIHN0YXRlIChmb2xkX2YgYyBiKSlcbiAgICBpblxuICAgIGxvb3AgMCBzdGF0ZSBpbml0O1xuICAgIEl2YXIucmVhZCByZXN1bHRcbiAgfCBgUGFyYWxsZWwgLT5cbiAgICBsZXQgcmVjIGxvb3AgaSB0IChjIDogYyBEZWZlcnJlZC50KSA9XG4gICAgICBtYXRjaCBuZXh0IHQgd2l0aFxuICAgICAgfCBEb25lIC0+IGNcbiAgICAgIHwgU2tpcCB7IHN0YXRlIH0gLT4gbG9vcCBpIHN0YXRlIGNcbiAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gdCB9IC0+XG4gICAgICAgIGxvb3BcbiAgICAgICAgICAoaSArIDEpXG4gICAgICAgICAgdFxuICAgICAgICAgIChsZXQlYmluZCBiID0gbWFwaV9mIGkgYSBpblxuICAgICAgICAgICBsZXQlbWFwIGMgPSBjIGluXG4gICAgICAgICAgIGZvbGRfZiBjIGIpXG4gICAgaW5cbiAgICBsb29wIDAgc3RhdGUgKHJldHVybiBpbml0KVxuICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG1heF9jb25jdXJyZW50X2pvYnMgLT5cbiAgICBsZXQgdGhyb3R0bGUgPSBUaHJvdHRsZS5jcmVhdGUgfm1heF9jb25jdXJyZW50X2pvYnMgfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlIGluXG4gICAgKCogW2xvb3BdIGZvcmNlcyB0aGUgaW5wdXQgc2VxdWVuY2UgYW5kIGVucXVldWVzIGEgdGhyb3R0bGUgam9iIG9ubHkgaWYgdGhlcmUgaXNcbiAgICAgICBjYXBhY2l0eSBhdmFpbGFibGUuICopXG4gICAgbGV0IHJlYyBsb29wIGkgdCAoYyA6IGMgRGVmZXJyZWQudCkgPVxuICAgICAgbGV0JWJpbmQgKCkgPSBUaHJvdHRsZS5jYXBhY2l0eV9hdmFpbGFibGUgdGhyb3R0bGUgaW5cbiAgICAgIG1hdGNoIG5leHQgdCB3aXRoXG4gICAgICB8IERvbmUgLT4gY1xuICAgICAgfCBTa2lwIHsgc3RhdGUgfSAtPiBsb29wIGkgc3RhdGUgY1xuICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSB0IH0gLT5cbiAgICAgICAgbG9vcFxuICAgICAgICAgIChpICsgMSlcbiAgICAgICAgICB0XG4gICAgICAgICAgKGxldCViaW5kIGIgPSBUaHJvdHRsZS5lbnF1ZXVlIHRocm90dGxlIChmdW4gKCkgLT4gbWFwaV9mIGkgYSkgaW5cbiAgICAgICAgICAgbGV0JW1hcCBjID0gYyBpblxuICAgICAgICAgICBmb2xkX2YgYyBiKVxuICAgIGluXG4gICAgbG9vcCAwIHN0YXRlIChyZXR1cm4gaW5pdClcbjs7XG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgU2VxdWVuY2UuZGVsYXllZF9mb2xkXG4gICAgdFxuICAgIH5pbml0OigwLCBpbml0KVxuICAgIH5mOihmdW4gKGksIGIpIGEgfmsgLT5cbiAgICAgIGxldCViaW5kIGIgPSBmIGkgYiBhIGluXG4gICAgICBrIChpICsgMSwgYikpXG4gICAgfmZpbmlzaDooZnVuIChfLCBiKSAtPiByZXR1cm4gYilcbjs7XG5cbigqIFtmb2xkXSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgW2ZvbGRpXSB0byBzYXZlIHRoZSBpbnRlcm1lZGlhdGUgY2xvc3VyZVxuICAgYWxsb2NhdGlvbi4gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBTZXF1ZW5jZS5kZWxheWVkX2ZvbGQgdCB+aW5pdCB+ZjooZnVuIGIgYSB+ayAtPiBmIGIgYSA+Pj0gaykgfmZpbmlzaDpyZXR1cm5cbjs7XG5cbmxldCBhbGwgdCA9XG4gIGxldCVtYXAgcmVzID1cbiAgICBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biBhY2N1bSBkIC0+XG4gICAgICBsZXQlbWFwIGEgPSBkIGluXG4gICAgICBhIDo6IGFjY3VtKVxuICBpblxuICBTZXF1ZW5jZS5vZl9saXN0IChMaXN0LnJldiByZXMpXG47O1xuXG5sZXQgYWxsX3VuaXQgdCA9IGZvbGQgdCB+aW5pdDooKSB+ZjooZnVuICgpIHYgLT4gdilcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBmaW5kX21hcGkgdCB+ZiBpID1cbiAgICBtYXRjaCBTZXF1ZW5jZS5uZXh0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByZXR1cm4gTm9uZVxuICAgIHwgU29tZSAodiwgcmVzdCkgLT5cbiAgICAgIChtYXRjaCViaW5kIGYgaSB2IHdpdGhcbiAgICAgICB8IE5vbmUgLT4gZmluZF9tYXBpIHJlc3QgfmYgKGkgKyAxKVxuICAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gcmV0dXJuIHNvbWUpXG4gIGluXG4gIGZpbmRfbWFwaSB0IH5mIDBcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICBpZiBiIHRoZW4gU29tZSAoaSwgZWx0KSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgZmluZF9tYXBpIHQgfmY6KGZ1biBfIGVsdCAtPlxuICAgIGxldCVtYXAgYiA9IGYgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgZWx0IGVsc2UgTm9uZSlcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gIHdpdGhcbiAgfCBTb21lICgpIC0+IHRydWVcbiAgfCBOb25lIC0+IGZhbHNlXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIG1hdGNoJW1hcFxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIG5vdCBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gIHdpdGhcbiAgfCBTb21lICgpIC0+IGZhbHNlXG4gIHwgTm9uZSAtPiB0cnVlXG47O1xuXG5sZXQgaXRlcmkgfmhvdyB0IH5mIDogdW5pdCBEZWZlcnJlZC50ID1cbiAgZm9sZF9tYXBpIH5ob3cgdCB+bWFwaV9mOmYgfmluaXQ6KCkgfmZvbGRfZjooZnVuICgpICgpIC0+ICgpKVxuOztcblxubGV0IG1hcGkgfmhvdyB0IH5mID1cbiAgbGV0JW1hcCBicyA9XG4gICAgZm9sZF9tYXBpIH5ob3cgdCB+bWFwaV9mOihmdW4gaSBhIC0+IGYgaSBhKSB+aW5pdDpbXSB+Zm9sZF9mOihmdW4gYnMgYiAtPiBiIDo6IGJzKVxuICBpblxuICBTZXF1ZW5jZS5vZl9saXN0IChMaXN0LnJldiBicylcbjs7XG5cbigqIFtmaWx0ZXJfbWFwaV0gaXMgaW1wbGVtZW50ZWQgdXNpbmcgW2ZvbGRfbWFwaV0gcmF0aGVyIHRoYW4gW21hcF0gc28gdGhhdCB3ZSBuZXZlciBuZWVkXG4gICB0byBrZWVwIGEgbG9uZyBzdHJlYW0gb2YgaW50ZXJtZWRpYXRlIFtOb25lXSByZXN1bHRzIGluIHRoZSBhY2N1bXVsYXRvciwgb25seSB0byBsYXRlclxuICAgZmlsdGVyIHRoZW0gYWxsIG91dC4gKilcbmxldCBmaWx0ZXJfbWFwaSB+aG93IHQgfmYgPVxuICBsZXQlbWFwIGJzID1cbiAgICBmb2xkX21hcGlcbiAgICAgIHRcbiAgICAgIH5ob3dcbiAgICAgIH5tYXBpX2Y6KGZ1biBpIGEgLT4gZiBpIGEpXG4gICAgICB+aW5pdDpbXVxuICAgICAgfmZvbGRfZjooZnVuIGJzIG1heWJlX3YgLT5cbiAgICAgICAgbWF0Y2ggbWF5YmVfdiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBic1xuICAgICAgICB8IFNvbWUgYiAtPiBiIDo6IGJzKVxuICBpblxuICBTZXF1ZW5jZS5vZl9saXN0IChMaXN0LnJldiBicylcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB+aG93IHQgfmYgPSBtYXBpIH5ob3cgdCB+ZiA+PnwgU2VxdWVuY2UuY29uY2F0XG5cbmxldCBmaWx0ZXJpIH5ob3cgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpIH5ob3cgdCB+ZjooZnVuIGkgYSAtPlxuICAgIG1hdGNoJW1hcCBmIGkgYSB3aXRoXG4gICAgfCB0cnVlIC0+IFNvbWUgYVxuICAgIHwgZmFsc2UgLT4gTm9uZSlcbjs7XG5cbmxldCBpdGVyIH5ob3cgdCB+ZiA9IGl0ZXJpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgbWFwIH5ob3cgdCB+ZiA9IG1hcGkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaWx0ZXIgfmhvdyB0IH5mID0gZmlsdGVyaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbHRlcl9tYXAgfmhvdyB0IH5mID0gZmlsdGVyX21hcGkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBjb25jYXRfbWFwIH5ob3cgdCB+ZiA9IGNvbmNhdF9tYXBpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmluZF9tYXAgdCB+ZiA9IGZpbmRfbWFwaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBleGlzdHMgdCB+ZiA9IGV4aXN0c2kgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZm9yX2FsbCB0IH5mID0gZm9yX2FsbGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgaW5pdCB+aG93IG4gfmYgPSBtYXAgfmhvdyAoU2VxdWVuY2UuaW5pdCBuIH5mOkZuLmlkKSB+ZlxuXG5sZXQgY291bnQgP2hvdyB0IH5mID1cbiAgZm9sZF9tYXBpXG4gICAgP2hvd1xuICAgIHRcbiAgICB+bWFwaV9mOihmdW4gX2kgYSAtPiBmIGEpXG4gICAgfmluaXQ6MFxuICAgIH5mb2xkX2Y6KGZ1biBhY2MgYyAtPiBhY2MgKyBCb29sLnRvX2ludCBjKVxuOztcblxubGV0IHN1bSAodHlwZSBhKSAobW9kdWxlIE0gOiBCYXNlLkNvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9IGEpID9ob3cgdCB+ZiA9XG4gIGZvbGRfbWFwaSA/aG93IHQgfm1hcGlfZjooZnVuIF9pIGEgLT4gZiBhKSB+aW5pdDpNLnplcm8gfmZvbGRfZjpNLiggKyApXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIFNlcXVlbmNlID0gRGVmZXJyZWRfc2VxdWVuY2VcblxubGV0IGZvcl9hbGwgdCB+ZiA9IFNldC50b19zZXF1ZW5jZSB0IHw+IFNlcXVlbmNlLmZvcl9hbGwgfmZcbmxldCBmaW5kIHQgfmYgPSBTZXQudG9fc2VxdWVuY2UgdCB8PiBTZXF1ZW5jZS5maW5kIH5mXG5sZXQgZmluZF9tYXAgdCB+ZiA9IFNldC50b19zZXF1ZW5jZSB0IHw+IFNlcXVlbmNlLmZpbmRfbWFwIH5mXG5sZXQgZm9sZCB0IH5pbml0IH5mID0gU2V0LnRvX3NlcXVlbmNlIHQgfD4gU2VxdWVuY2UuZm9sZCB+aW5pdCB+ZlxuXG5sZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID1cbiAgU2V0LnRvX3NlcXVlbmNlIH5vcmRlcjpgRGVjcmVhc2luZyB0IHw+IFNlcXVlbmNlLmZvbGQgfmluaXQgfmY6KEZuLmZsaXAgZilcbjs7XG5cbmxldCBpdGVyIH5ob3cgdCB+ZiA9IFNldC50b19zZXF1ZW5jZSB0IHw+IFNlcXVlbmNlLml0ZXIgfmhvdyB+ZlxuXG5sZXQgZmlsdGVyX21hcCAodHlwZSBlbHQgY21wKSAoKG1vZHVsZSBNKSA6IChlbHQsIGNtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCkgfmhvdyB0IH5mID1cbiAgU2V0LnRvX3NlcXVlbmNlIHRcbiAgfD4gU2VxdWVuY2UuZm9sZF9tYXBpXG4gICAgICAgfmluaXQ6KFNldC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOk0uY29tcGFyYXRvcilcbiAgICAgICB+aG93XG4gICAgICAgfm1hcGlfZjooZnVuIF9pIGEgLT4gZiBhKVxuICAgICAgIH5mb2xkX2Y6KGZ1biBhY2MgdiAtPlxuICAgICAgICAgbWF0Y2ggdiB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gYWNjXG4gICAgICAgICB8IFNvbWUgdiAtPiBTZXQuYWRkIGFjYyB2KVxuOztcblxubGV0IGZpbHRlciB+aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwIChTZXQuY29tcGFyYXRvcl9zIHQpIH5ob3cgdCB+ZjooZnVuIHggLT4gaWYlbWFwIGYgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG47O1xuXG5sZXQgbWFwIGNvbXBhcmF0b3IgfmhvdyB0IH5mID1cbiAgZmlsdGVyX21hcCBjb21wYXJhdG9yIH5ob3cgdCB+ZjooZnVuIHggLT5cbiAgICBsZXQlbWFwIHkgPSBmIHggaW5cbiAgICBTb21lIHkpXG47O1xuXG5sZXQgY291bnQgfmhvdyB0IH5mID0gU2V0LnRvX3NlcXVlbmNlIHQgfD4gU2VxdWVuY2UuY291bnQgfmhvdyB+ZlxuXG5sZXQgc3VtICh0eXBlIGEpIChtb2R1bGUgTSA6IEJhc2UuQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gYSkgfmhvdyB0IH5mID1cbiAgU2V0LnRvX3NlcXVlbmNlIHQgfD4gU2VxdWVuY2Uuc3VtIChtb2R1bGUgTSkgfmhvdyB+ZlxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIENsb2NrX25zID0gQ2xvY2tfbnNcbm1vZHVsZSBUaW1lX25zID0gVGltZV9uc1xubW9kdWxlIFRpbWUgPSBUaW1lX2Zsb2F0XG5tb2R1bGUgQXN5bmNfa2VybmVsX3NjaGVkdWxlciA9IEFzeW5jX2tlcm5lbF9zY2hlZHVsZXJcbm1vZHVsZSBEYXRlID0gRGF0ZVxuXG5sZXQgYWZ0ZXIgPSBDbG9ja19ucy5hZnRlclxubGV0IGF0ID0gQ2xvY2tfbnMuYXRcbmxldCBldmVyeSA9IENsb2NrX25zLmV2ZXJ5XG5sZXQgd2l0aF90aW1lb3V0ID0gQ2xvY2tfbnMud2l0aF90aW1lb3V0XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIFN0cmVhbSA9IEFzeW5jX3N0cmVhbVxuXG5sZXQgc2hvd19kZWJ1Z19tZXNzYWdlcyA9IHJlZiBmYWxzZVxubGV0IGNoZWNrX2ludmFyaWFudCA9IHJlZiBmYWxzZVxuXG5tb2R1bGUgRmx1c2hlZF9yZXN1bHQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBPa1xuICAgIHwgYFJlYWRlcl9jbG9zZWRcbiAgICBdXG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgbGV0IGVxdWFsID0gWyVjb21wYXJlLmVxdWFsOiB0XVxuXG4gIGxldCBjb21iaW5lIChsIDogdCBEZWZlcnJlZC50IGxpc3QpID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFsgeCBdIC0+IHhcbiAgICB8IGwgLT5cbiAgICAgIGxldCVtYXAgbCA9IERlZmVycmVkLmFsbCBsIGluXG4gICAgICAobWF0Y2ggTGlzdC5tZW0gbCBgUmVhZGVyX2Nsb3NlZCB+ZXF1YWwgd2l0aFxuICAgICAgIHwgdHJ1ZSAtPiBgUmVhZGVyX2Nsb3NlZFxuICAgICAgIHwgZmFsc2UgLT4gYE9rKVxuICA7O1xuZW5kXG5cbigqIEEgW0NvbnN1bWVyLnRdIGFjdHMgYXMgdGhlIG1vbml0b3Igb2Ygc29tZSBwcm9jZXNzIHRoYXQgcmVhZHMgdmFsdWVzIGZyb20gYSBwaXBlIGFuZFxuICAgcHJvY2Vzc2VzIHRoZW0sIGFsbG93aW5nIHRoYXQgcHJvY2VzczpcbiAgIC0gdG8gY29tbXVuaWNhdGUgdGhhdCBpdCBoYXMgdGFrZW4gcmVzcG9uc2liaWxpdHkgZm9yIHRoZSB2YWx1ZXNcbiAgIC0gdG8gc2lnbmFsIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHdpdGggdGhlIHZhbHVlcyB0byBpbnRlcmVzdGVkIHBhcnRpZXMgKHZpYVxuICAgICBbZG93bnN0cmVhbV9mbHVzaGVkXSlcblxuICAgSXQgaXMgdXNlZCBpbiB0d28gc3RlcHM6XG5cbiAgIDEuIGNhbGxpbmcgW0NvbnN1bWVyLnN0YXJ0XSBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGNvbnN1bWVyIHRha2VzIHZhbHVlcyBvdXQgb2YgdGhlXG4gICBQaXBlIHZpYSBbcmVhZF0gb3IgW3JlYWQnXS5cblxuICAgMi4gY2FsbGluZyBbQ29uc3VtZXIudmFsdWVzX3NlbnRfZG93bnN0cmVhbV0uXG5cbiAgIEJ5IGNhbGxpbmcgW3ZhbHVlc19zZW50X2Rvd25zdHJlYW1dIG9uZSBhc3NlcnRzIHRoYXQgdGhlIFtkb3duc3RyZWFtX2ZsdXNoZWRdIGZ1bmN0aW9uXG4gICBzdXBwbGllZCB0byBbY3JlYXRlXSB3aWxsIG5vdyB3YWl0IGZvciB0aGlzIHZhbHVlLlxuXG4gICBJZiBubyBbQ29uc3VtZXIudF0gaXMgc3VwcGxpZWQgd2hlbiBhIHZhbHVlIGlzIHJlYWQgdGhlbiB0aGUgdmFsdWUgaXMgZGVmaW5lZCB0byBiZVxuICAgZmx1c2hlZCBhdCB0aGF0IHRpbWUuICopXG5tb2R1bGUgQ29uc3VtZXIgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBJbnZhcmlhbnQuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIGNyZWF0ZVxuICAgIDogIHBpcGVfaWQ6aW50XG4gICAgLT4gZG93bnN0cmVhbV9mbHVzaGVkOih1bml0IC0+IEZsdXNoZWRfcmVzdWx0LnQgRGVmZXJyZWQudClcbiAgICAtPiB0XG5cbiAgdmFsIHBpcGVfaWQgOiB0IC0+IGludFxuICB2YWwgc3RhcnQgOiB0IC0+IHVuaXRcbiAgdmFsIHZhbHVlc19zZW50X2Rvd25zdHJlYW0gOiB0IC0+IHVuaXRcbiAgdmFsIHZhbHVlc19zZW50X2Rvd25zdHJlYW1fYW5kX2ZsdXNoZWQgOiB0IC0+IEZsdXNoZWRfcmVzdWx0LnQgRGVmZXJyZWQudFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBwaXBlX2lkIDogaW50XG4gICAgOyAoKiBbdmFsdWVzX3JlYWRdIHJlZmxlY3RzIHdoZXRoZXIgdmFsdWVzIHRoZSBjb25zdW1lciBoYXMgcmVhZCBmcm9tIHRoZSBwaXBlIGhhdmUgYmVlblxuICAgICAgICAgc2VudCBkb3duc3RyZWFtIG9yIGlmIG5vdCwgaG9sZHMgYW4gaXZhciB0aGF0IGlzIHRvIGJlIGZpbGxlZCB3aGVuIHRoZXkgYXJlLiAqKVxuICAgICAgbXV0YWJsZVxuICAgICAgICB2YWx1ZXNfcmVhZCA6XG4gICAgICAgIFsgYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW0gfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gb2YgdW5pdCBJdmFyLnQgXVxuICAgIDsgKCogW2Rvd25zdHJlYW1fZmx1c2hlZCAoKV0gcmV0dXJucyB3aGVuIGFsbCBwcmlvciB2YWx1ZXMgdGhhdCB0aGUgY29uc3VtZXIgaGFzXG4gICAgICAgICBwYXNzZWQgZG93bnN0cmVhbSBoYXZlIGJlZW4gZmx1c2hlZCBhbGwgdGhlIHdheSBkb3duIHRoZSBjaGFpbiBvZiBwaXBlcy4gKilcbiAgICAgIGRvd25zdHJlYW1fZmx1c2hlZCA6IHVuaXQgLT4gRmx1c2hlZF9yZXN1bHQudCBEZWZlcnJlZC50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICAgIHRyeVxuICAgICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5waXBlX2lkOmlnbm9yZVxuICAgICAgICB+dmFsdWVzX3JlYWQ6XG4gICAgICAgICAgKGNoZWNrIChmdW5jdGlvblxuICAgICAgICAgICAgfCBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbSAtPiAoKVxuICAgICAgICAgICAgfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gaXZhciAtPiBhc3NlcnQgKEl2YXIuaXNfZW1wdHkgaXZhcikpKVxuICAgICAgICB+ZG93bnN0cmVhbV9mbHVzaGVkOmlnbm9yZVxuICAgIHdpdGhcbiAgICB8IGV4biAtPiByYWlzZV9zIFslbWVzc2FnZSBcIlBpcGUuQ29uc3VtZXIuaW52YXJpYW50IGZhaWxlZFwiIChleG4gOiBleG4pIH5waXBlOih0IDogdCldXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSB+cGlwZV9pZCB+ZG93bnN0cmVhbV9mbHVzaGVkID1cbiAgICB7IHBpcGVfaWQ7IHZhbHVlc19yZWFkID0gYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW07IGRvd25zdHJlYW1fZmx1c2hlZCB9XG4gIDs7XG5cbiAgbGV0IHN0YXJ0IHQgPVxuICAgIG1hdGNoIHQudmFsdWVzX3JlYWQgd2l0aFxuICAgIHwgYEhhdmVfbm90X2JlZW5fc2VudF9kb3duc3RyZWFtIF8gLT4gKClcbiAgICB8IGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtIC0+XG4gICAgICB0LnZhbHVlc19yZWFkIDwtIGBIYXZlX25vdF9iZWVuX3NlbnRfZG93bnN0cmVhbSAoSXZhci5jcmVhdGUgKCkpXG4gIDs7XG5cbiAgbGV0IHZhbHVlc19zZW50X2Rvd25zdHJlYW0gdCA9XG4gICAgbWF0Y2ggdC52YWx1ZXNfcmVhZCB3aXRoXG4gICAgfCBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbSAtPiAoKVxuICAgIHwgYEhhdmVfbm90X2JlZW5fc2VudF9kb3duc3RyZWFtIGl2YXIgLT5cbiAgICAgIEl2YXIuZmlsbF9leG4gaXZhciAoKTtcbiAgICAgIHQudmFsdWVzX3JlYWQgPC0gYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW1cbiAgOztcblxuICBsZXQgdmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1c2hlZCB0ID1cbiAgICBtYXRjaCB0LnZhbHVlc19yZWFkIHdpdGhcbiAgICB8IGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtIC0+IHQuZG93bnN0cmVhbV9mbHVzaGVkICgpXG4gICAgfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gd2hlbl9zZW50X2Rvd25zdHJlYW0gLT5cbiAgICAgIGxldCViaW5kICgpID0gSXZhci5yZWFkIHdoZW5fc2VudF9kb3duc3RyZWFtIGluXG4gICAgICB0LmRvd25zdHJlYW1fZmx1c2hlZCAoKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBCbG9ja2VkX3JlYWQgPSBzdHJ1Y3RcbiAgKCogQSBbQmxvY2tlZF9yZWFkLnRdIHJlcHJlc2VudHMgYSBibG9ja2VkIHJlYWQgYXR0ZW1wdC4gIElmIHNvbWVvbmUgcmVhZHMgZnJvbSBhbiBlbXB0eVxuICAgICBwaXBlLCB0aGV5IGVucXVldWUgYSBbQmxvY2tlZF9yZWFkLnRdIGluIHRoZSBxdWV1ZSBvZiBbYmxvY2tlZF9yZWFkc10uICBMYXRlciwgd2hlblxuICAgICB2YWx1ZXMgYXJlIHdyaXR0ZW4gdG8gYSBwaXBlLCB0aGF0IHdpbGwgY2F1c2Ugc29tZSBudW1iZXIgb2YgYmxvY2tlZCByZWFkcyB0byBiZVxuICAgICBmaWxsZWQsIGZpcnN0IGNvbWUgZmlyc3Qgc2VydmUuICBUaGUgYmxvY2tlZC1yZWFkIGNvbnN0cnVjdG9yIHNwZWNpZmllcyBob3cgbWFueVxuICAgICB2YWx1ZXMgYSByZWFkIHNob3VsZCBjb25zdW1lIGZyb20gdGhlIHBpcGUgd2hlbiBpdCBnZXRzIGl0cyB0dXJuLlxuXG4gICAgIElmIGEgcGlwZSBpcyBjbG9zZWQsIHRoZW4gYWxsIGJsb2NrZWQgcmVhZHMgd2lsbCBiZSBmaWxsZWQgd2l0aCBbYEVvZl0uICopXG4gIHR5cGUgJ2Egd2FudHMgPVxuICAgIHwgWmVybyBvZiBbIGBFb2YgfCBgT2sgXSBJdmFyLnRcbiAgICB8IE9uZSBvZiBbIGBFb2YgfCBgT2sgb2YgJ2EgXSBJdmFyLnRcbiAgICB8IEF0X21vc3Qgb2YgaW50ICogWyBgRW9mIHwgYE9rIG9mICdhIFF1ZXVlLnQgXSBJdmFyLnRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlICdhIHQgPVxuICAgIHsgd2FudHMgOiAnYSB3YW50c1xuICAgIDsgY29uc3VtZXIgOiBDb25zdW1lci50IG9wdGlvblxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IHQgOiB1bml0ID1cbiAgICB0cnlcbiAgICAgIGxldCBjaGVjayBmIGZpZWxkID0gZiAoRmllbGQuZ2V0IGZpZWxkIHQpIGluXG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+d2FudHM6XG4gICAgICAgICAgKGNoZWNrIChmdW5jdGlvblxuICAgICAgICAgICAgfCBaZXJvIF8gfCBPbmUgXyAtPiAoKVxuICAgICAgICAgICAgfCBBdF9tb3N0IChpLCBfKSAtPiBhc3NlcnQgKGkgPiAwKSkpXG4gICAgICAgIH5jb25zdW1lcjpcbiAgICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgIHwgU29tZSBjb25zdW1lciAtPiBDb25zdW1lci5pbnZhcmlhbnQgY29uc3VtZXIpKVxuICAgIHdpdGhcbiAgICB8IGV4biAtPlxuICAgICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLkJsb2NrZWRfcmVhZC5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgfnBpcGU6KHQgOiBfIHQpXVxuICA7O1xuXG4gIGxldCBjcmVhdGUgd2FudHMgY29uc3VtZXIgPSB7IHdhbnRzOyBjb25zdW1lciB9XG5cbiAgbGV0IGlzX2VtcHR5IHQgPVxuICAgIG1hdGNoIHQud2FudHMgd2l0aFxuICAgIHwgWmVybyBpIC0+IEl2YXIuaXNfZW1wdHkgaVxuICAgIHwgT25lIGkgLT4gSXZhci5pc19lbXB0eSBpXG4gICAgfCBBdF9tb3N0IChfLCBpKSAtPiBJdmFyLmlzX2VtcHR5IGlcbiAgOztcblxuICBsZXQgZmlsbF93aXRoX2VvZiB0ID1cbiAgICBtYXRjaCB0LndhbnRzIHdpdGhcbiAgICB8IFplcm8gaSAtPiBJdmFyLmZpbGxfZXhuIGkgYEVvZlxuICAgIHwgT25lIGkgLT4gSXZhci5maWxsX2V4biBpIGBFb2ZcbiAgICB8IEF0X21vc3QgKF8sIGkpIC0+IEl2YXIuZmlsbF9leG4gaSBgRW9mXG4gIDs7XG5lbmRcblxubW9kdWxlIEJsb2NrZWRfZmx1c2ggPSBzdHJ1Y3RcbiAgKCogQSBbQmxvY2tlZF9mbHVzaC50XSByZXByZXNlbnRzIGEgYmxvY2tlZCBmbHVzaCBvcGVyYXRpb24sIHdoaWNoIGNhbiBiZSBlbmFibGVkIGJ5IGFcbiAgICAgZnV0dXJlIHJlYWQuICBJZiBzb21lb25lIGRvZXMgW2ZsdXNoZWQgcF0gb24gYSBwaXBlLCB0aGF0IGJsb2NrcyB1bnRpbCBldmVyeXRoaW5nXG4gICAgIHRoYXQncyBjdXJyZW50bHkgaW4gdGhlIHBpcGUgYXQgdGhhdCBwb2ludCBoYXMgZHJhaW5lZCBvdXQgb2YgdGhlIHBpcGUuICBXaGVuIHdlIGNhbGxcbiAgICAgW2ZsdXNoZWRdLCBpdCByZWNvcmRzIHRoZSB0b3RhbCBhbW91bnQgb2YgZGF0YSB0aGF0IGhhcyBiZWVuIHdyaXR0ZW4gc28gZmFyIGluXG4gICAgIFtmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkXS4gIFdlIGZpbGwgdGhlIFtGbHVzaC50XSB3aXRoIFtgT2tdIHdoZW4gdGhpcyBhbW91bnQgb2ZcbiAgICAgZGF0YSBoYXMgYmVlbiByZWFkIGZyb20gdGhlIHBpcGUuXG5cbiAgICAgQSBbQmxvY2tlZF9mbHVzaC50XSBjYW4gYWxzbyBiZSBmaWxsZWQgd2l0aCBbYFJlYWRlcl9jbG9zZWRdLCB3aGljaCBoYXBwZW5zIHdoZW4gdGhlXG4gICAgIHJlYWRlciBlbmQgb2YgdGhlIHBpcGUgaXMgY2xvc2VkLCBhbmQgd2UgYXJlIHRodXMgc3VyZSB0aGF0IHRoZSB1bnJlYWQgZWxlbWVudHMgcHJlY2VkaW5nIHRoZSBmbHVzaCB3aWxsIG5ldmVyIGJlIHJlYWQuICopXG4gIHR5cGUgdCA9XG4gICAgeyBmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkIDogaW50XG4gICAgOyByZWFkeSA6IFsgYE9rIHwgYFJlYWRlcl9jbG9zZWQgXSBJdmFyLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycywgc2V4cF9vZl1cblxuICBsZXQgZmlsbCB0IHYgPSBJdmFyLmZpbGxfZXhuIHQucmVhZHkgdlxuZW5kXG5cbnR5cGUgKCdhLCAncGhhbnRvbSkgdCA9XG4gIHsgKCogW2lkXSBpcyBhbiBpbnRlZ2VyIHVzZWQgdG8gZGlzdGluZ3Vpc2ggcGlwZXMgd2hlbiBkZWJ1Z2dpbmcuICopXG4gICAgaWQgOiBpbnQgU2V4cF9oaWRkZW5faW5fdGVzdC50XG4gIDsgKCogW2luZm9dIGlzIHVzZXItcHJvdmlkZWQgYXJiaXRyYXJ5IHNleHAsIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuICopXG4gICAgbXV0YWJsZSBpbmZvIDogU2V4cC50IG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICA7ICgqIFtidWZmZXJdIGhvbGRzIHZhbHVlcyB3cml0dGVuIHRvIHRoZSBwaXBlIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gcmVhZC4gKilcbiAgICBtdXRhYmxlIGJ1ZmZlciA6ICdhIFF1ZXVlLnRcbiAgOyAoKiBbc2l6ZV9idWRnZXRdIGdvdmVybnMgcHVzaGJhY2sgb24gd3JpdGVycyB0byB0aGUgcGlwZS5cblxuICAgICAgIFRoZXJlIGlzICpubyogaW52YXJpYW50IHRoYXQgW1F1ZXVlLmxlbmd0aCBidWZmZXIgPD0gc2l6ZV9idWRnZXRdLlxuICAgICAgIFRoZXJlIGlzIG5vIGhhcmQgdXBwZXIgYm91bmQgb24gdGhlIG51bWJlciBvZiBlbGVtZW50cyB0aGF0IGNhbiBiZSBzdHVmZmVkIGludG8gdGhlXG4gICAgICAgW2J1ZmZlcl0uIFRoaXMgaXMgZHVlIHRvIHRoZSB3YXkgd2UgaGFuZGxlIHdyaXRlcy4gV2hlbiB3ZSBkbyBhIHdyaXRlLCBhbGwgb2YgdGhlXG4gICAgICAgdmFsdWVzIHdyaXR0ZW4gYXJlIGltbWVkaWF0ZWx5IGVucXVldWVkIGludG8gW2J1ZmZlcl0uIEFmdGVyIHRoZSB3cml0ZSwgaWZcbiAgICAgICBbUXVldWUubGVuZ3RoIGJ1ZmZlciA8PSB0LnNpemVfYnVkZ2V0XSwgdGhlbiB0aGUgd3JpdGVyIHdpbGwgYmUgbm90aWZpZWQgdG9cbiAgICAgICBjb250aW51ZSB3cml0aW5nLiBBZnRlciB0aGUgd3JpdGUsIGlmIFtsZW5ndGggdCA+IHQuc2l6ZV9idWRnZXRdLCB0aGVuIHRoZSB3cml0ZVxuICAgICAgIHdpbGwgYmxvY2sgdW50aWwgdGhlIHBpcGUgaXMgdW5kZXIgYnVkZ2V0LiAqKVxuICAgIG11dGFibGUgc2l6ZV9idWRnZXQgOiBpbnRcbiAgOyAoKiBbcmVzZXJ2ZWRfc3BhY2VdIGNvdW50cyBhZ2FpbnN0IFtzaXplX2J1ZGdldF0gd2l0aG91dCBhY3R1YWxseSBidWZmZXJpbmcgYW55dGhpbmdcbiAgICAgICB5ZXQuIFdoZW4gaXQncyBwb3NpdGl2ZSwgd3JpdGVzIGRlY3JlbWVudCBpdC4gKilcbiAgICBtdXRhYmxlIHJlc2VydmVkX3NwYWNlIDogaW50XG4gIDsgKCogW3B1c2hiYWNrXSBpcyB1c2VkIHRvIGdpdmUgZmVlZGJhY2sgdG8gd3JpdGVycyBhYm91dCB3aGV0aGVyIHRoZXkgc2hvdWxkIHdyaXRlIHRvXG4gICAgICAgdGhlIHBpcGUuIFtwdXNoYmFja10gaXMgZnVsbCBpZmYgW2xlbmd0aCB0ICsgcmVzZXJ2ZWRfc3BhY2UgdCA8PSB0LnNpemVfYnVkZ2V0IHx8XG4gICAgICAgaXNfY2xvc2VkIHRdLiAqKVxuICAgIG11dGFibGUgcHVzaGJhY2sgOiB1bml0IEl2YXIudFxuICA7ICgqIFtudW1fdmFsdWVzX3JlYWRdIGtlZXBzIHRyYWNrIG9mIHRoZSB0b3RhbCBudW1iZXIgb2YgdmFsdWVzIHRoYXQgaGF2ZSBiZWVuIHJlYWRcbiAgICAgICBmcm9tIHRoZSBwaXBlLiAgV2UgZG8gbm90IGhhdmUgdG8gd29ycnkgYWJvdXQgb3ZlcmZsb3cgaW4gW251bV92YWx1ZXNfcmVhZF0uICBZb3UnZFxuICAgICAgIG5lZWQgdG8gd3JpdGUgMl42MiBlbGVtZW50cyB0byB0aGUgcGlwZSwgd2hpY2ggd291bGQgdGFrZSBhYm91dCAxNDYgeWVhcnMsIGF0IGFcbiAgICAgICBmbG93IHJhdGUgb2YgMSBzaXplLXVuaXQvbmFub3NlY29uZC4gKilcbiAgICBtdXRhYmxlIG51bV92YWx1ZXNfcmVhZCA6IGludFxuICAgICAgKCogW2Jsb2NrZWRfZmx1c2hlc10gaG9sZHMgZmx1c2hlcyB3aG9zZSBwcmVjZWRpbmcgZWxlbWVudHMgaGF2ZSBub3QgYmVlbiBjb21wbGV0ZWx5XG4gICAgIHJlYWQuICBGb3IgZWFjaCBibG9ja2VkIGZsdXNoLCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBiZSByZWFkIGZyb20gdGhlXG4gICAgIHBpcGUgaW4gb3JkZXIgdG8gZmlsbCB0aGUgZmx1c2ggaXMgICAgICAgICAgICAgICAgICAgICAgICA6XG5cbiAgICAgZmlsbF93aGVuX251bV92YWx1ZXNfcmVhZCAtIG51bV92YWx1ZXNfcmVhZFxuXG4gICAgIEtlZXBpbmcgdGhlIGRhdGEgaW4gdGhpcyBmb3JtIGFsbG93cyB1cyB0byBjaGFuZ2UgYSBzaW5nbGUgZmllbGQobnVtX3ZhbHVlc19yZWFkKVxuICAgICB3aGVuIHdlIGNvbnN1bWUgdmFsdWVzIGluc3RlYWQgb2YgaGF2aW5nIHRvIGl0ZXJhdGUgb3ZlciB0aGUgd2hvbGUgcXVldWUgb2ZcbiAgICAgZmx1c2hlcy4gKilcbiAgOyBibG9ja2VkX2ZsdXNoZXMgOiBCbG9ja2VkX2ZsdXNoLnQgUXVldWUudFxuICA7ICgqIFtibG9ja2VkX3JlYWRzXSBob2xkcyByZWFkcyB0aGF0IGFyZSB3YWl0aW5nIG9uIGRhdGEgdG8gYmUgd3JpdHRlbiB0byB0aGUgcGlwZS4gKilcbiAgICBibG9ja2VkX3JlYWRzIDogJ2EgQmxvY2tlZF9yZWFkLnQgUXVldWUudFxuICA7ICgqIFtjbG9zZWRdIGlzIGZpbGxlZCB3aGVuIHdlIGNsb3NlIHRoZSB3cml0ZSBlbmQgb2YgdGhlIHBpcGUuICopXG4gICAgY2xvc2VkIDogdW5pdCBJdmFyLnRcbiAgOyAoKiBbcmVhZF9jbG9zZWRdIGlzIGZpbGxlZCB3aGVuIHdlIGNsb3NlIHRoZSByZWFkIGVuZCBvZiB0aGUgcGlwZS4gKilcbiAgICByZWFkX2Nsb3NlZCA6IHVuaXQgSXZhci50XG4gIDsgKCogW2NvbnN1bWVyc10gaXMgYSBsaXN0IG9mIGFsbCBjb25zdW1lcnMgdGhhdCBtYXkgYmUgaGFuZGxpbmcgdmFsdWVzIHJlYWQgZnJvbSB0aGVcbiAgICAgICBwaXBlLiAqKVxuICAgIG11dGFibGUgY29uc3VtZXJzIDogQ29uc3VtZXIudCBsaXN0XG4gIDsgKCogW3Vwc3RyZWFtX2ZsdXNoZWRzXSBoYXMgYSBmdW5jdGlvbiBmb3IgZWFjaCBwaXBlIGltbWVkaWF0ZWx5IHVwc3RyZWFtIG9mIHRoaXMgb25lLlxuICAgICAgIFRoYXQgZnVuY3Rpb24gd2Fsa3MgdG8gdGhlIGhlYWQocykgb2YgdGhlIHVwc3RyZWFtIHBpcGUsIGFuZCBjYWxsc1xuICAgICAgIFtkb3duc3RyZWFtX2ZsdXNoZWRdIG9uIHRoZSBoZWFkKHMpLiAgU2VlIHRoZSBkZWZpbml0aW9uIG9mIFt1cHN0cmVhbV9mbHVzaGVkXVxuICAgICAgIGJlbG93LiAqKVxuICAgIHVwc3RyZWFtX2ZsdXNoZWRzIDogKHVuaXQgLT4gRmx1c2hlZF9yZXN1bHQudCBEZWZlcnJlZC50KSBCYWcudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfnNldHRlcnMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG5sZXQgZWZmZWN0aXZlX3NpemVfYnVkZ2V0IHQgPSB0LnNpemVfYnVkZ2V0IC0gdC5yZXNlcnZlZF9zcGFjZVxuXG50eXBlICgnYSwgJ3BoYW50b20pIHBpcGUgPSAoJ2EsICdwaGFudG9tKSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBoYXNoIHQgPSBIYXNodGJsLmhhc2ggdC5pZFxubGV0IGVxdWFsICh0MSA6IChfLCBfKSB0KSB0MiA9IHBoeXNfZXF1YWwgdDEgdDJcbmxldCBjb21wYXJlIHQxIHQyID0gSW50LmNvbXBhcmUgdDEuaWQgdDIuaWRcbmxldCBpc19jbG9zZWQgdCA9IEl2YXIuaXNfZnVsbCB0LmNsb3NlZFxubGV0IGlzX3JlYWRfY2xvc2VkIHQgPSBJdmFyLmlzX2Z1bGwgdC5yZWFkX2Nsb3NlZFxubGV0IGNsb3NlZCB0ID0gSXZhci5yZWFkIHQuY2xvc2VkXG5sZXQgcHVzaGJhY2sgdCA9IEl2YXIucmVhZCB0LnB1c2hiYWNrXG5sZXQgbGVuZ3RoIHQgPSBRdWV1ZS5sZW5ndGggdC5idWZmZXJcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5sZXQgbnVtX3ZhbHVlc193cml0dGVuIHQgPSBsZW5ndGggdCArIG51bV92YWx1ZXNfcmVhZCB0XG5sZXQgdXBkYXRlX251bV92YWx1ZXNfcmVhZCB0IH5kZWx0YSA9IHQubnVtX3ZhbHVlc19yZWFkIDwtIHQubnVtX3ZhbHVlc19yZWFkICsgZGVsdGFcblxubGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gIHRyeVxuICAgIGxldCBjaGVjayBmIGZpZWxkID0gZiAoRmllbGQuZ2V0IGZpZWxkIHQpIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5pZDppZ25vcmVcbiAgICAgIH5pbmZvOmlnbm9yZVxuICAgICAgfmJ1ZmZlcjppZ25vcmVcbiAgICAgIH5zaXplX2J1ZGdldDooY2hlY2sgKGZ1biBzaXplX2J1ZGdldCAtPiBhc3NlcnQgKHNpemVfYnVkZ2V0ID49IDApKSlcbiAgICAgIH5yZXNlcnZlZF9zcGFjZTooY2hlY2sgKGZ1biByZXNlcnZlZF9zcGFjZSAtPiBhc3NlcnQgKHJlc2VydmVkX3NwYWNlID49IDApKSlcbiAgICAgIH5wdXNoYmFjazpcbiAgICAgICAgKGNoZWNrIChmdW4gcHVzaGJhY2sgLT5cbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBCb29sLmVxdWFsXG4gICAgICAgICAgICAgICAoSXZhci5pc19mdWxsIHB1c2hiYWNrKVxuICAgICAgICAgICAgICAgKGxlbmd0aCB0IDw9IGVmZmVjdGl2ZV9zaXplX2J1ZGdldCB0IHx8IGlzX2Nsb3NlZCB0KSkpKVxuICAgICAgfm51bV92YWx1ZXNfcmVhZDppZ25vcmVcbiAgICAgIH5ibG9ja2VkX2ZsdXNoZXM6XG4gICAgICAgIChjaGVjayAoZnVuIGJsb2NrZWRfZmx1c2hlcyAtPlxuICAgICAgICAgICBRdWV1ZS5pdGVyIGJsb2NrZWRfZmx1c2hlcyB+ZjooZnVuIChmIDogQmxvY2tlZF9mbHVzaC50KSAtPlxuICAgICAgICAgICAgIGFzc2VydCAoZi5maWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkID4gdC5udW1fdmFsdWVzX3JlYWQpKTtcbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBMaXN0LmlzX3NvcnRlZFxuICAgICAgICAgICAgICAgfmNvbXBhcmU6SW50LmNvbXBhcmVcbiAgICAgICAgICAgICAgIChMaXN0Lm1hcFxuICAgICAgICAgICAgICAgICAgKFF1ZXVlLnRvX2xpc3QgYmxvY2tlZF9mbHVzaGVzKVxuICAgICAgICAgICAgICAgICAgfmY6QmxvY2tlZF9mbHVzaC5maWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkKSk7XG4gICAgICAgICAgIGlmIGlzX2VtcHR5IHQgdGhlbiBhc3NlcnQgKFF1ZXVlLmlzX2VtcHR5IGJsb2NrZWRfZmx1c2hlcykpKVxuICAgICAgfmJsb2NrZWRfcmVhZHM6XG4gICAgICAgIChjaGVjayAoZnVuIGJsb2NrZWRfcmVhZHMgLT5cbiAgICAgICAgICAgKCogSWYgZGF0YSBpcyBhdmFpbGFibGUsIG5vIG9uZSBpcyB3YWl0aW5nIGZvciBpdC4gIFRoaXMgd291bGQgbmVlZCB0byBjaGFuZ2UgaWZcbiAgICAgICAgICAgICAgd2UgZXZlciBpbXBsZW1lbnQgW3JlYWRfZXhhY3RseV0gYXMgYW4gYXRvbWljIG9wZXJhdGlvbi4gKilcbiAgICAgICAgICAgaWYgbm90IChpc19lbXB0eSB0KSB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgYmxvY2tlZF9yZWFkcyk7XG4gICAgICAgICAgIFF1ZXVlLml0ZXIgYmxvY2tlZF9yZWFkcyB+ZjooZnVuIHJlYWQgLT5cbiAgICAgICAgICAgICBCbG9ja2VkX3JlYWQuaW52YXJpYW50IHJlYWQ7XG4gICAgICAgICAgICAgYXNzZXJ0IChCbG9ja2VkX3JlYWQuaXNfZW1wdHkgcmVhZCkpO1xuICAgICAgICAgICAoKiBZb3UgbmV2ZXIgYmxvY2sgdHJ5aW5nIHRvIHJlYWQgYSBjbG9zZWQgcGlwZS4gKilcbiAgICAgICAgICAgaWYgaXNfY2xvc2VkIHQgdGhlbiBhc3NlcnQgKFF1ZXVlLmlzX2VtcHR5IGJsb2NrZWRfcmVhZHMpKSlcbiAgICAgIH5jbG9zZWQ6aWdub3JlXG4gICAgICB+cmVhZF9jbG9zZWQ6aWdub3JlXG4gICAgICB+Y29uc3VtZXJzOlxuICAgICAgICAoY2hlY2sgKGZ1biBsIC0+XG4gICAgICAgICAgIExpc3QuaXRlciBsIH5mOihmdW4gY29uc3VtZXIgLT5cbiAgICAgICAgICAgICBDb25zdW1lci5pbnZhcmlhbnQgY29uc3VtZXI7XG4gICAgICAgICAgICAgYXNzZXJ0IChDb25zdW1lci5waXBlX2lkIGNvbnN1bWVyID0gdC5pZCkpKSlcbiAgICAgIH51cHN0cmVhbV9mbHVzaGVkczppZ25vcmVcbiAgd2l0aFxuICB8IGV4biAtPiByYWlzZV9zIFslbWVzc2FnZSBcIlBpcGUuaW52YXJpYW50IGZhaWxlZFwiIChleG4gOiBleG4pIH5waXBlOih0IDogKF8sIF8pIHQpXVxuOztcblxubW9kdWxlIFJlYWRlciA9IHN0cnVjdFxuICB0eXBlIHBoYW50b20gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAnYSB0ID0gKCdhLCBwaGFudG9tKSBwaXBlIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuZW5kXG5cbm1vZHVsZSBXcml0ZXIgPSBzdHJ1Y3RcbiAgdHlwZSBwaGFudG9tIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgJ2EgdCA9ICgnYSwgcGhhbnRvbSkgcGlwZSBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbmVuZFxuXG5sZXQgaWRfcmVmID0gcmVmIDBcblxubGV0IGNyZWF0ZV9pbnRlcm5hbCB+c2l6ZV9idWRnZXQgfmluZm8gfmluaXRpYWxfYnVmZmVyID1cbiAgaW5jciBpZF9yZWY7XG4gIGxldCB0ID1cbiAgICB7IGlkID0gIWlkX3JlZlxuICAgIDsgaW5mb1xuICAgIDsgY2xvc2VkID0gSXZhci5jcmVhdGUgKClcbiAgICA7IHJlYWRfY2xvc2VkID0gSXZhci5jcmVhdGUgKClcbiAgICA7IHNpemVfYnVkZ2V0XG4gICAgOyByZXNlcnZlZF9zcGFjZSA9IDBcbiAgICA7IHB1c2hiYWNrID0gSXZhci5jcmVhdGUgKClcbiAgICA7IGJ1ZmZlciA9IGluaXRpYWxfYnVmZmVyXG4gICAgOyBudW1fdmFsdWVzX3JlYWQgPSAwXG4gICAgOyBibG9ja2VkX2ZsdXNoZXMgPSBRdWV1ZS5jcmVhdGUgKClcbiAgICA7IGJsb2NrZWRfcmVhZHMgPSBRdWV1ZS5jcmVhdGUgKClcbiAgICA7IGNvbnN1bWVycyA9IFtdXG4gICAgOyB1cHN0cmVhbV9mbHVzaGVkcyA9IEJhZy5jcmVhdGUgKClcbiAgICB9XG4gIGluXG4gIHRcbjs7XG5cbmxldCB2YWxpZGF0ZV9zaXplX2J1ZGdldCBzaXplX2J1ZGdldCA9XG4gIGlmIHNpemVfYnVkZ2V0IDwgMFxuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwibmVnYXRpdmUgc2l6ZV9idWRnZXRcIiAoc2l6ZV9idWRnZXQgOiBpbnQpXVxuICBlbHNlIHNpemVfYnVkZ2V0XG47O1xuXG5sZXQgY3JlYXRlID9zaXplX2J1ZGdldCA/aW5mbyAoKSA9XG4gIGxldCBzaXplX2J1ZGdldCA9XG4gICAgbWF0Y2ggc2l6ZV9idWRnZXQgd2l0aFxuICAgIHwgU29tZSB2IC0+IHZhbGlkYXRlX3NpemVfYnVkZ2V0IHZcbiAgICB8IE5vbmUgLT4gMFxuICBpblxuICBsZXQgdCA9IGNyZWF0ZV9pbnRlcm5hbCB+c2l6ZV9idWRnZXQgfmluZm8gfmluaXRpYWxfYnVmZmVyOihRdWV1ZS5jcmVhdGUgKCkpIGluXG4gICgqIGluaXRpYWxseSwgdGhlIHBpcGUgZG9lcyBub3QgcHVzaGJhY2sgKilcbiAgSXZhci5maWxsX2V4biB0LnB1c2hiYWNrICgpO1xuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gaW52YXJpYW50IHQ7XG4gIHQsIHRcbjs7XG5cbmxldCB1cGRhdGVfcHVzaGJhY2sgdCA9XG4gIGlmIGxlbmd0aCB0IDw9IGVmZmVjdGl2ZV9zaXplX2J1ZGdldCB0IHx8IGlzX2Nsb3NlZCB0XG4gIHRoZW4gSXZhci5maWxsX2lmX2VtcHR5IHQucHVzaGJhY2sgKClcbiAgZWxzZSBpZiBJdmFyLmlzX2Z1bGwgdC5wdXNoYmFja1xuICB0aGVuIHQucHVzaGJhY2sgPC0gSXZhci5jcmVhdGUgKClcbjs7XG5cbmxldCBjbG9zZSB0ID1cbiAgaWYgIXNob3dfZGVidWdfbWVzc2FnZXMgdGhlbiBlcHJpbnRzIFwiY2xvc2VcIiB0IFslc2V4cF9vZjogKF8sIF8pIHRdO1xuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gaW52YXJpYW50IHQ7XG4gIGlmIG5vdCAoaXNfY2xvc2VkIHQpXG4gIHRoZW4gKFxuICAgIEl2YXIuZmlsbF9leG4gdC5jbG9zZWQgKCk7XG4gICAgaWYgaXNfZW1wdHkgdFxuICAgIHRoZW4gKFxuICAgICAgUXVldWUuaXRlciB0LmJsb2NrZWRfcmVhZHMgfmY6QmxvY2tlZF9yZWFkLmZpbGxfd2l0aF9lb2Y7XG4gICAgICBRdWV1ZS5jbGVhciB0LmJsb2NrZWRfcmVhZHMpO1xuICAgIHVwZGF0ZV9wdXNoYmFjayB0KVxuOztcblxubGV0IGNsb3NlX3JlYWQgdCA9XG4gIGlmICFzaG93X2RlYnVnX21lc3NhZ2VzIHRoZW4gZXByaW50cyBcImNsb3NlX3JlYWRcIiB0IFslc2V4cF9vZjogKF8sIF8pIHRdO1xuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gaW52YXJpYW50IHQ7XG4gIGlmIG5vdCAoaXNfcmVhZF9jbG9zZWQgdClcbiAgdGhlbiAoXG4gICAgSXZhci5maWxsX2V4biB0LnJlYWRfY2xvc2VkICgpO1xuICAgIFF1ZXVlLml0ZXIgdC5ibG9ja2VkX2ZsdXNoZXMgfmY6KGZ1biBmbHVzaCAtPiBCbG9ja2VkX2ZsdXNoLmZpbGwgZmx1c2ggYFJlYWRlcl9jbG9zZWQpO1xuICAgIFF1ZXVlLmNsZWFyIHQuYmxvY2tlZF9mbHVzaGVzO1xuICAgIFF1ZXVlLmNsZWFyIHQuYnVmZmVyO1xuICAgIHQucmVzZXJ2ZWRfc3BhY2UgPC0gMDtcbiAgICB1cGRhdGVfcHVzaGJhY2sgdDtcbiAgICAoKiB3ZSBqdXN0IGNsZWFyZWQgdGhlIGJ1ZmZlciwgc28gbWF5IG5lZWQgdG8gZmlsbCBbdC5wdXNoYmFja10gKilcbiAgICBjbG9zZSB0KVxuOztcblxubGV0IGNyZWF0ZV9yZWFkZXJfbm90X2Nsb3NlX29uX2V4Y2VwdGlvbiA/c2l6ZV9idWRnZXQgZiA9XG4gIGxldCByLCB3ID0gY3JlYXRlID9zaXplX2J1ZGdldCAoKSBpblxuICB1cG9uIChmIHcpIChmdW4gKCkgLT4gY2xvc2Ugdyk7XG4gIHJcbjs7XG5cbmxldCBjcmVhdGVfcmVhZGVyID9zaXplX2J1ZGdldCB+Y2xvc2Vfb25fZXhjZXB0aW9uIGYgPVxuICBpZiBub3QgY2xvc2Vfb25fZXhjZXB0aW9uXG4gIHRoZW4gY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjZXB0aW9uID9zaXplX2J1ZGdldCBmXG4gIGVsc2UgKFxuICAgIGxldCByLCB3ID0gY3JlYXRlID9zaXplX2J1ZGdldCAoKSBpblxuICAgIGRvbid0X3dhaXRfZm9yXG4gICAgICAoTW9uaXRvci5wcm90ZWN0XG4gICAgICAgICAoZnVuICgpIC0+IGYgdylcbiAgICAgICAgIH5maW5hbGx5OihmdW4gKCkgLT5cbiAgICAgICAgICAgY2xvc2UgdztcbiAgICAgICAgICAgcmV0dXJuICgpKSk7XG4gICAgcilcbjs7XG5cbmxldCBjcmVhdGVfd3JpdGVyID9zaXplX2J1ZGdldCBmID1cbiAgbGV0IHIsIHcgPSBjcmVhdGUgP3NpemVfYnVkZ2V0ICgpIGluXG4gIGRvbid0X3dhaXRfZm9yXG4gICAgKE1vbml0b3IucHJvdGVjdFxuICAgICAgIChmdW4gKCkgLT4gZiByKVxuICAgICAgIH5maW5hbGx5OihmdW4gKCkgLT5cbiAgICAgICAgIGNsb3NlX3JlYWQgcjtcbiAgICAgICAgIHJldHVybiAoKSkpO1xuICB3XG47O1xuXG5sZXQgY29uc3VtZWRfdmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1c2hlZCB0ID1cbiAgaWYgTGlzdC5pc19lbXB0eSB0LmNvbnN1bWVyc1xuICB0aGVuIHJldHVybiBgT2tcbiAgZWxzZVxuICAgIEZsdXNoZWRfcmVzdWx0LmNvbWJpbmVcbiAgICAgIChMaXN0Lm1hcCB0LmNvbnN1bWVycyB+ZjpDb25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtX2FuZF9mbHVzaGVkKVxuOztcblxubGV0IGVhZ2VyX3Vwb24gZCBmID1cbiAgbWF0Y2ggRGVmZXJyZWQucGVlayBkIHdpdGhcbiAgfCBTb21lIHYgLT4gZiB2XG4gIHwgTm9uZSAtPiB1cG9uIGQgZlxuOztcblxubGV0IHZhbHVlc193ZXJlX3JlYWQgdCBjb25zdW1lciA9XG4gIE9wdGlvbi5pdGVyIGNvbnN1bWVyIH5mOkNvbnN1bWVyLnN0YXJ0O1xuICBsZXQgdmFsdWVzX2ZsdXNoZWQgPSBsYXp5IChjb25zdW1lZF92YWx1ZXNfc2VudF9kb3duc3RyZWFtX2FuZF9mbHVzaGVkIHQpIGluXG4gIFF1ZXVlLmRyYWluXG4gICAgdC5ibG9ja2VkX2ZsdXNoZXNcbiAgICB+d2hpbGVfOihmdW4gZmx1c2ggLT4gdC5udW1fdmFsdWVzX3JlYWQgPj0gZmx1c2guZmlsbF93aGVuX251bV92YWx1ZXNfcmVhZClcbiAgICB+ZjooZnVuIGZsdXNoIC0+XG4gICAgICBlYWdlcl91cG9uIChmb3JjZSB2YWx1ZXNfZmx1c2hlZCkgKGZ1biBmbHVzaF9yZXN1bHQgLT5cbiAgICAgICAgQmxvY2tlZF9mbHVzaC5maWxsIGZsdXNoIGZsdXNoX3Jlc3VsdCkpXG47O1xuXG4oKiBbY29uc3VtZV9hbGwgdF0gcmVhZHMgYWxsIHRoZSBlbGVtZW50cyBpbiBbdF0uICopXG5sZXQgY29uc3VtZV9hbGwgdCBjb25zdW1lciA9XG4gIGxldCByZXN1bHQgPSB0LmJ1ZmZlciBpblxuICB0LmJ1ZmZlciA8LSBRdWV1ZS5jcmVhdGUgKCk7XG4gIHVwZGF0ZV9udW1fdmFsdWVzX3JlYWQgdCB+ZGVsdGE6KFF1ZXVlLmxlbmd0aCByZXN1bHQpO1xuICB2YWx1ZXNfd2VyZV9yZWFkIHQgY29uc3VtZXI7XG4gIHVwZGF0ZV9wdXNoYmFjayB0O1xuICByZXN1bHRcbjs7XG5cbmxldCBjb25zdW1lX29uZSB0IGNvbnN1bWVyID1cbiAgYXNzZXJ0IChsZW5ndGggdCA+PSAxKTtcbiAgbGV0IHJlc3VsdCA9IFF1ZXVlLmRlcXVldWVfZXhuIHQuYnVmZmVyIGluXG4gIHVwZGF0ZV9udW1fdmFsdWVzX3JlYWQgdCB+ZGVsdGE6MTtcbiAgdmFsdWVzX3dlcmVfcmVhZCB0IGNvbnN1bWVyO1xuICB1cGRhdGVfcHVzaGJhY2sgdDtcbiAgcmVzdWx0XG47O1xuXG5sZXQgY29uc3VtZSB0IH5tYXhfcXVldWVfbGVuZ3RoIGNvbnN1bWVyID1cbiAgYXNzZXJ0IChtYXhfcXVldWVfbGVuZ3RoID49IDApO1xuICBpZiBtYXhfcXVldWVfbGVuZ3RoID49IGxlbmd0aCB0XG4gIHRoZW4gY29uc3VtZV9hbGwgdCBjb25zdW1lclxuICBlbHNlIChcbiAgICB1cGRhdGVfbnVtX3ZhbHVlc19yZWFkIHQgfmRlbHRhOm1heF9xdWV1ZV9sZW5ndGg7XG4gICAgdmFsdWVzX3dlcmVfcmVhZCB0IGNvbnN1bWVyO1xuICAgIGxldCByZXN1bHQgPSBRdWV1ZS5jcmVhdGUgfmNhcGFjaXR5Om1heF9xdWV1ZV9sZW5ndGggKCkgaW5cbiAgICBRdWV1ZS5ibGl0X3RyYW5zZmVyIH5zcmM6dC5idWZmZXIgfmRzdDpyZXN1bHQgfmxlbjptYXhfcXVldWVfbGVuZ3RoICgpO1xuICAgIHVwZGF0ZV9wdXNoYmFjayB0O1xuICAgIHJlc3VsdClcbjs7XG5cbmxldCBzZXRfc2l6ZV9idWRnZXQgdCBzaXplX2J1ZGdldCA9XG4gIGxldCBzaXplX2J1ZGdldCA9IHZhbGlkYXRlX3NpemVfYnVkZ2V0IHNpemVfYnVkZ2V0IGluXG4gIHQuc2l6ZV9idWRnZXQgPC0gc2l6ZV9idWRnZXQ7XG4gIHVwZGF0ZV9wdXNoYmFjayB0XG47O1xuXG5sZXQgcmVzZXJ2ZV9zcGFjZSB0IG4gPVxuICBpZiBuIDwgMCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwicmVzZXJ2aW5nIG5lZ2F0aXZlIHNwYWNlXCIgKG4gOiBpbnQpXTtcbiAgbGV0IHJlc2VydmVkX3NwYWNlID0gdC5yZXNlcnZlZF9zcGFjZSArIG4gaW5cbiAgaWYgcmVzZXJ2ZWRfc3BhY2UgPCAwXG4gIHRoZW5cbiAgICByYWlzZV9zIFslbWVzc2FnZSBcIm92ZXJmbG93IHdoZW4gcmVzZXJ2aW5nIHNwYWNlXCIgKHQucmVzZXJ2ZWRfc3BhY2UgOiBpbnQpIChuIDogaW50KV07XG4gIHQucmVzZXJ2ZWRfc3BhY2UgPC0gcmVzZXJ2ZWRfc3BhY2U7XG4gIHVwZGF0ZV9wdXNoYmFjayB0XG47O1xuXG5sZXQgZmlsbF9ibG9ja2VkX3JlYWRzIHQgPVxuICB3aGlsZSAobm90IChRdWV1ZS5pc19lbXB0eSB0LmJsb2NrZWRfcmVhZHMpKSAmJiBub3QgKGlzX2VtcHR5IHQpIGRvXG4gICAgbGV0IGJsb2NrZWRfcmVhZCA9IFF1ZXVlLmRlcXVldWVfZXhuIHQuYmxvY2tlZF9yZWFkcyBpblxuICAgIGxldCBjb25zdW1lciA9IGJsb2NrZWRfcmVhZC5jb25zdW1lciBpblxuICAgIG1hdGNoIGJsb2NrZWRfcmVhZC53YW50cyB3aXRoXG4gICAgfCBaZXJvIGl2YXIgLT4gSXZhci5maWxsX2V4biBpdmFyIGBPa1xuICAgIHwgT25lIGl2YXIgLT4gSXZhci5maWxsX2V4biBpdmFyIChgT2sgKGNvbnN1bWVfb25lIHQgY29uc3VtZXIpKVxuICAgIHwgQXRfbW9zdCAobWF4X3F1ZXVlX2xlbmd0aCwgaXZhcikgLT5cbiAgICAgIEl2YXIuZmlsbF9leG4gaXZhciAoYE9rIChjb25zdW1lIHQgfm1heF9xdWV1ZV9sZW5ndGggY29uc3VtZXIpKVxuICBkb25lXG47O1xuXG5sZXQgZGVjcmVhc2VfcmVzZXJ2ZWRfc3BhY2UgdCBuID0gdC5yZXNlcnZlZF9zcGFjZSA8LSBJbnQubWF4IDAgKHQucmVzZXJ2ZWRfc3BhY2UgLSBuKVxuXG4oKiBjaGVja3MgYWxsIGludmFyaWFudHMsIGNhbGxzIGEgcGFzc2VkIGluIGYgdG8gaGFuZGxlIGEgd3JpdGUsIHRoZW4gdXBkYXRlcyByZWFkcyBhbmRcbiAgIHB1c2hiYWNrICopXG5sZXQgc3RhcnRfd3JpdGUgdCB+c2l6ZSA9XG4gIGlmICFzaG93X2RlYnVnX21lc3NhZ2VzIHRoZW4gZXByaW50cyBcIndyaXRlXCIgdCBbJXNleHBfb2Y6IChfLCBfKSB0XTtcbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIGludmFyaWFudCB0O1xuICBpZiBpc19jbG9zZWQgdCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwid3JpdGUgdG8gY2xvc2VkIHBpcGVcIiB+cGlwZToodCA6IChfLCBfKSB0KV07XG4gIGRlY3JlYXNlX3Jlc2VydmVkX3NwYWNlIHQgc2l6ZVxuOztcblxubGV0IGZpbmlzaF93cml0ZSB0ID1cbiAgZmlsbF9ibG9ja2VkX3JlYWRzIHQ7XG4gIHVwZGF0ZV9wdXNoYmFjayB0XG47O1xuXG5sZXQgdHJhbnNmZXJfaW5fd2l0aG91dF9wdXNoYmFjayB0IH5mcm9tID1cbiAgc3RhcnRfd3JpdGUgdCB+c2l6ZTooUXVldWUubGVuZ3RoIGZyb20pO1xuICBRdWV1ZS5ibGl0X3RyYW5zZmVyIH5zcmM6ZnJvbSB+ZHN0OnQuYnVmZmVyICgpO1xuICBmaW5pc2hfd3JpdGUgdFxuOztcblxubGV0IHRyYW5zZmVyX2luIHQgfmZyb20gPVxuICB0cmFuc2Zlcl9pbl93aXRob3V0X3B1c2hiYWNrIHQgfmZyb207XG4gIHB1c2hiYWNrIHRcbjs7XG5cbmxldCBjb3B5X2luX3dpdGhvdXRfcHVzaGJhY2sgdCB+ZnJvbSA9XG4gIHN0YXJ0X3dyaXRlIHQgfnNpemU6KFF1ZXVlLmxlbmd0aCBmcm9tKTtcbiAgUXVldWUuaXRlciBmcm9tIH5mOihmdW4geCAtPiBRdWV1ZS5lbnF1ZXVlIHQuYnVmZmVyIHgpO1xuICBmaW5pc2hfd3JpdGUgdFxuOztcblxuKCogW3dyaXRlJ10gaXMgdXNlZCBpbnRlcm5hbGx5ICopXG5sZXQgd3JpdGUnIHQgcSA9IHRyYW5zZmVyX2luIHQgfmZyb206cVxuXG5sZXQgd3JpdGVfd2l0aG91dF9wdXNoYmFjayB0IHZhbHVlID1cbiAgc3RhcnRfd3JpdGUgdCB+c2l6ZToxO1xuICBRdWV1ZS5lbnF1ZXVlIHQuYnVmZmVyIHZhbHVlO1xuICBmaW5pc2hfd3JpdGUgdFxuOztcblxubGV0IHdyaXRlIHQgdmFsdWUgPVxuICB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHQgdmFsdWU7XG4gIHB1c2hiYWNrIHRcbjs7XG5cbmxldCB3cml0ZV93aGVuX3JlYWR5IHQgfmYgPVxuICBsZXQlbWFwICgpID0gcHVzaGJhY2sgdCBpblxuICBpZiBpc19jbG9zZWQgdCB0aGVuIGBDbG9zZWQgZWxzZSBgT2sgKGYgKGZ1biB4IC0+IHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdCB4KSlcbjs7XG5cbmxldCB3cml0ZV9pZl9vcGVuIHQgeCA9IGlmIG5vdCAoaXNfY2xvc2VkIHQpIHRoZW4gd3JpdGUgdCB4IGVsc2UgcmV0dXJuICgpXG5cbmxldCB3cml0ZV93aXRob3V0X3B1c2hiYWNrX2lmX29wZW4gdCB4ID1cbiAgaWYgbm90IChpc19jbG9zZWQgdCkgdGhlbiB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHQgeFxuOztcblxubGV0IGVuc3VyZV9jb25zdW1lcl9tYXRjaGVzID9jb25zdW1lciB0ID1cbiAgbWF0Y2ggY29uc3VtZXIgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGNvbnN1bWVyIC0+XG4gICAgaWYgdC5pZCA8PiBDb25zdW1lci5waXBlX2lkIGNvbnN1bWVyXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIkF0dGVtcHQgdG8gdXNlIGNvbnN1bWVyIHdpdGggd3JvbmcgcGlwZVwiXG4gICAgICAgICAgICAoY29uc3VtZXIgOiBDb25zdW1lci50KVxuICAgICAgICAgICAgfnBpcGU6KHQgOiBfIFJlYWRlci50KV1cbjs7XG5cbmxldCBzdGFydF9yZWFkID9jb25zdW1lciB0IGxhYmVsID1cbiAgaWYgIXNob3dfZGVidWdfbWVzc2FnZXMgdGhlbiBlcHJpbnRzIGxhYmVsIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMgdCA/Y29uc3VtZXJcbjs7XG5cbmxldCBnZW5fcmVhZF9ub3cgP2NvbnN1bWVyIHQgY29uc3VtZSA9XG4gIHN0YXJ0X3JlYWQgdCBcInJlYWRfbm93XCIgP2NvbnN1bWVyO1xuICBpZiBpc19lbXB0eSB0XG4gIHRoZW4gaWYgaXNfY2xvc2VkIHQgdGhlbiBgRW9mIGVsc2UgYE5vdGhpbmdfYXZhaWxhYmxlXG4gIGVsc2UgKFxuICAgIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgdC5ibG9ja2VkX3JlYWRzKTtcbiAgICAoKiBmcm9tIFtpbnZhcmlhbnRdIGFuZCBbbm90IChpc19lbXB0eSB0KV0gKilcbiAgICBgT2sgKGNvbnN1bWUgdCBjb25zdW1lcikpXG47O1xuXG5sZXQgZ2V0X21heF9xdWV1ZV9sZW5ndGggfm1heF9xdWV1ZV9sZW5ndGggPVxuICBtYXRjaCBtYXhfcXVldWVfbGVuZ3RoIHdpdGhcbiAgfCBOb25lIC0+IEludC5tYXhfdmFsdWVcbiAgfCBTb21lIG1heF9xdWV1ZV9sZW5ndGggLT5cbiAgICBpZiBtYXhfcXVldWVfbGVuZ3RoIDw9IDBcbiAgICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwibWF4X3F1ZXVlX2xlbmd0aCA8PSAwXCIgKG1heF9xdWV1ZV9sZW5ndGggOiBpbnQpXTtcbiAgICBtYXhfcXVldWVfbGVuZ3RoXG47O1xuXG5sZXQgcmVhZF9ub3cnID9jb25zdW1lciA/bWF4X3F1ZXVlX2xlbmd0aCB0ID1cbiAgbGV0IG1heF9xdWV1ZV9sZW5ndGggPSBnZXRfbWF4X3F1ZXVlX2xlbmd0aCB+bWF4X3F1ZXVlX2xlbmd0aCBpblxuICBnZW5fcmVhZF9ub3cgdCA/Y29uc3VtZXIgKGZ1biB0IGNvbnN1bWVyIC0+IGNvbnN1bWUgdCB+bWF4X3F1ZXVlX2xlbmd0aCBjb25zdW1lcilcbjs7XG5cbmxldCByZWFkX25vdyA/Y29uc3VtZXIgdCA9IGdlbl9yZWFkX25vdyB0ID9jb25zdW1lciBjb25zdW1lX29uZVxuXG5sZXQgcmVhZF9ub3dfZXhuID9jb25zdW1lciB0ID1cbiAgbWF0Y2ggcmVhZF9ub3cgP2NvbnN1bWVyIHQgd2l0aFxuICB8IGBPayBhIC0+IGFcbiAgfCBgRW9mIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5yZWFkX25vd19leG46IHJlY2VpdmVkIEVPRlwiXVxuICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPiByYWlzZV9zIFslbWVzc2FnZSBcIlBpcGUucmVhZF9ub3dfZXhuOiBub3RoaW5nIGF2YWlsYWJsZVwiXVxuOztcblxubGV0IHBlZWsgdCA9IFF1ZXVlLnBlZWsgdC5idWZmZXJcblxubGV0IGNsZWFyIHQgPVxuICBtYXRjaCByZWFkX25vdycgdCB3aXRoXG4gIHwgYEVvZiB8IGBOb3RoaW5nX2F2YWlsYWJsZSB8IGBPayBfIC0+ICgpXG47O1xuXG5sZXQgcmVhZCcgP2NvbnN1bWVyID9tYXhfcXVldWVfbGVuZ3RoIHQgPVxuICBsZXQgbWF4X3F1ZXVlX2xlbmd0aCA9IGdldF9tYXhfcXVldWVfbGVuZ3RoIH5tYXhfcXVldWVfbGVuZ3RoIGluXG4gIHN0YXJ0X3JlYWQgdCBcInJlYWQnXCIgP2NvbnN1bWVyO1xuICBtYXRjaCByZWFkX25vdycgdCA/Y29uc3VtZXIgfm1heF9xdWV1ZV9sZW5ndGggd2l0aFxuICB8IChgT2sgXyB8IGBFb2YpIGFzIHIgLT4gcmV0dXJuIHJcbiAgfCBgTm90aGluZ19hdmFpbGFibGUgLT5cbiAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+XG4gICAgICBRdWV1ZS5lbnF1ZXVlXG4gICAgICAgIHQuYmxvY2tlZF9yZWFkc1xuICAgICAgICAoQmxvY2tlZF9yZWFkLmNyZWF0ZSAoQXRfbW9zdCAobWF4X3F1ZXVlX2xlbmd0aCwgaXZhcikpIGNvbnN1bWVyKSlcbjs7XG5cbmxldCByZWFkID9jb25zdW1lciB0ID1cbiAgc3RhcnRfcmVhZCB0IFwicmVhZFwiID9jb25zdW1lcjtcbiAgaWYgaXNfZW1wdHkgdFxuICB0aGVuXG4gICAgaWYgaXNfY2xvc2VkIHRcbiAgICB0aGVuIHJldHVybiBgRW9mXG4gICAgZWxzZVxuICAgICAgRGVmZXJyZWQuY3JlYXRlIChmdW4gaXZhciAtPlxuICAgICAgICBRdWV1ZS5lbnF1ZXVlIHQuYmxvY2tlZF9yZWFkcyAoQmxvY2tlZF9yZWFkLihjcmVhdGUgKE9uZSBpdmFyKSkgY29uc3VtZXIpKVxuICBlbHNlIChcbiAgICBhc3NlcnQgKFF1ZXVlLmlzX2VtcHR5IHQuYmxvY2tlZF9yZWFkcyk7XG4gICAgcmV0dXJuIChgT2sgKGNvbnN1bWVfb25lIHQgY29uc3VtZXIpKSlcbjs7XG5cbmxldCByZWFkX2V4biA/Y29uc3VtZXIgdCA9XG4gIG1hdGNoJW1hcCByZWFkID9jb25zdW1lciB0IHdpdGhcbiAgfCBgT2sgdmFsdWUgLT4gdmFsdWVcbiAgfCBgRW9mIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5yZWFkX2V4bjogcmVjZWl2ZWQgRU9GXCJdXG47O1xuXG5sZXQgdmFsdWVzX2F2YWlsYWJsZSB0ID1cbiAgc3RhcnRfcmVhZCB0IFwidmFsdWVzX2F2YWlsYWJsZVwiO1xuICBpZiBub3QgKGlzX2VtcHR5IHQpXG4gIHRoZW4gcmV0dXJuIGBPa1xuICBlbHNlIGlmIGlzX2Nsb3NlZCB0XG4gIHRoZW4gcmV0dXJuIGBFb2ZcbiAgZWxzZSAoXG4gICAgbWF0Y2ggUXVldWUubGFzdCB0LmJsb2NrZWRfcmVhZHMgd2l0aFxuICAgIHwgU29tZSB7IGNvbnN1bWVyID0gTm9uZTsgd2FudHMgPSBaZXJvIGl2YXIgfSAtPlxuICAgICAgKCogVGhpcyBjYXNlIGlzIGFuIG9wdGltaXphdGlvbiBmb3IgbXVsdGlwbGUgY2FsbHMgdG8gW3ZhbHVlc19hdmFpbGFibGVdIGluXG4gICAgICAgICBzZXF1ZW5jZS4gIEl0IGNhdXNlcyB0aGVtIHRvIGFsbCBzaGFyZSB0aGUgc2FtZSBpdmFyLCByYXRoZXIgdGhhbiBhbGxvY2F0ZVxuICAgICAgICAgYW4gaXZhciBwZXIgY2FsbC4gKilcbiAgICAgIEl2YXIucmVhZCBpdmFyXG4gICAgfCBfIC0+XG4gICAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+XG4gICAgICAgIFF1ZXVlLmVucXVldWUgdC5ibG9ja2VkX3JlYWRzIChCbG9ja2VkX3JlYWQuKGNyZWF0ZSAoWmVybyBpdmFyKSkgTm9uZSkpKVxuOztcblxubGV0IHJlYWRfY2hvaWNlIHQgPSBjaG9pY2UgKHZhbHVlc19hdmFpbGFibGUgdCkgKGZ1biAoXyA6IFsgYE9rIHwgYEVvZiBdKSAtPiByZWFkX25vdyB0KVxuXG5sZXQgcmVhZF9jaG9pY2Vfc2luZ2xlX2NvbnN1bWVyX2V4biB0IGhlcmUgPVxuICBEZWZlcnJlZC5DaG9pY2UubWFwIChyZWFkX2Nob2ljZSB0KSB+ZjooZnVuY3Rpb25cbiAgICB8IChgT2sgXyB8IGBFb2YpIGFzIHggLT4geFxuICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiUGlwZS5yZWFkX2Nob2ljZV9zaW5nbGVfY29uc3VtZXJfZXhuOiBjaG9pY2Ugd2FzIGVuYWJsZWQgYnV0IHBpcGUgaXMgZW1wdHk7IFxcXG4gICAgICAgICAgIHRoaXMgaXMgbGlrZWx5IGR1ZSB0byBhIHJhY2UgY29uZGl0aW9uIHdpdGggb25lIG9yIG1vcmUgb3RoZXIgY29uc3VtZXJzXCJcbiAgICAgICAgICAgIChoZXJlIDogU291cmNlX2NvZGVfcG9zaXRpb24udCldKVxuOztcblxuKCogW3JlYWRfZXhhY3RseSB0IH5udW1fdmFsdWVzXSBsb29wcywgZ2V0dGluZyB5b3UgYWxsIFtudW1fdmFsdWVzXSBpdGVtcywgdXBcbiAgIHRvIEVPRi4gKilcbmxldCByZWFkX2V4YWN0bHkgP2NvbnN1bWVyIHQgfm51bV92YWx1ZXMgPVxuICBzdGFydF9yZWFkIHQgXCJyZWFkX2V4YWN0bHlcIiA/Y29uc3VtZXI7XG4gIGlmIG51bV92YWx1ZXMgPD0gMFxuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5yZWFkX2V4YWN0bHkgZ290IG51bV92YWx1ZXMgPD0gMFwiIChudW1fdmFsdWVzIDogaW50KV07XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIGZpbmlzaCAtPlxuICAgIGxldCByZXN1bHQgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgbGV0IGFscmVhZHlfcmVhZCA9IFF1ZXVlLmxlbmd0aCByZXN1bHQgaW5cbiAgICAgIGFzc2VydCAoYWxyZWFkeV9yZWFkIDw9IG51bV92YWx1ZXMpO1xuICAgICAgaWYgYWxyZWFkeV9yZWFkID0gbnVtX3ZhbHVlc1xuICAgICAgdGhlbiBJdmFyLmZpbGxfZXhuIGZpbmlzaCAoYEV4YWN0bHkgcmVzdWx0KVxuICAgICAgZWxzZVxuICAgICAgICByZWFkJyA/Y29uc3VtZXIgdCB+bWF4X3F1ZXVlX2xlbmd0aDoobnVtX3ZhbHVlcyAtIGFscmVhZHlfcmVhZClcbiAgICAgICAgPj4+IGZ1bmN0aW9uXG4gICAgICAgIHwgYEVvZiAtPiBJdmFyLmZpbGxfZXhuIGZpbmlzaCAoaWYgYWxyZWFkeV9yZWFkID0gMCB0aGVuIGBFb2YgZWxzZSBgRmV3ZXIgcmVzdWx0KVxuICAgICAgICB8IGBPayBxIC0+XG4gICAgICAgICAgUXVldWUuYmxpdF90cmFuc2ZlciB+c3JjOnEgfmRzdDpyZXN1bHQgKCk7XG4gICAgICAgICAgbG9vcCAoKVxuICAgIGluXG4gICAgbG9vcCAoKSlcbjs7XG5cbmxldCBkb3duc3RyZWFtX2ZsdXNoZWQgdCA9XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiBjb25zdW1lZF92YWx1ZXNfc2VudF9kb3duc3RyZWFtX2FuZF9mbHVzaGVkIHRcbiAgZWxzZVxuICAgICgqIFt0XSBtaWdodCBiZSBjbG9zZWQuICBCdXQgdGhlIHJlYWQgZW5kIGNhbid0IGJlIGNsb3NlZCwgYmVjYXVzZSBpZiBpdCB3ZXJlLCB0aGVuXG4gICAgICAgW3RdIHdvdWxkIGJlIGVtcHR5LiAgSWYgdGhlIHdyaXRlIGVuZCBpcyBjbG9zZWQgYnV0IG5vdCB0aGUgcmVhZCBlbmQsIHRoZW4gd2Ugd2FudFxuICAgICAgIHRvIGVucXVldWUgYSBibG9ja2VkIGZsdXNoIGJlY2F1c2UgdGhlIGVucXVldWVkIHZhbHVlcyBtYXkgZ2V0IHJlYWQuICopXG4gICAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVhZHkgLT5cbiAgICAgIFF1ZXVlLmVucXVldWVcbiAgICAgICAgdC5ibG9ja2VkX2ZsdXNoZXNcbiAgICAgICAgeyBmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkID0gdC5udW1fdmFsdWVzX3JlYWQgKyBsZW5ndGggdDsgcmVhZHkgfSlcbjs7XG5cbigqIEluIHByYWN0aWNlLCBhbG9uZyB3aXRoIFtMaW5rLmNyZWF0ZV0gYW5kIFthZGRfdXBzdHJlYW1fZmx1c2hlZF0sIFt1cHN0cmVhbV9mbHVzaGVkXVxuICAgdHJhdmVyc2VzIHRoZSBncmFwaCBvZiBsaW5rZWQgcGlwZXMgdXAgdG8gdGhlIGhlYWRzIGFuZCB0aGVuIGNhbGxzIFtkb3duc3RyZWFtX2ZsdXNoZWRdXG4gICBvbiB0aGVtLiAqKVxubGV0IHVwc3RyZWFtX2ZsdXNoZWQgdCA9XG4gIGlmIEJhZy5pc19lbXB0eSB0LnVwc3RyZWFtX2ZsdXNoZWRzXG4gIHRoZW4gZG93bnN0cmVhbV9mbHVzaGVkIHRcbiAgZWxzZVxuICAgIEJhZy50b19saXN0IHQudXBzdHJlYW1fZmx1c2hlZHNcbiAgICB8PiBMaXN0Lm1hcCB+ZjooZnVuIGYgLT4gZiAoKSlcbiAgICB8PiBGbHVzaGVkX3Jlc3VsdC5jb21iaW5lXG47O1xuXG5sZXQgYWRkX3Vwc3RyZWFtX2ZsdXNoZWQgdCB1cHN0cmVhbV9mbHVzaGVkID0gQmFnLmFkZCB0LnVwc3RyZWFtX2ZsdXNoZWRzIHVwc3RyZWFtX2ZsdXNoZWRcblxubGV0IGFkZF9jb25zdW1lciB0IH5kb3duc3RyZWFtX2ZsdXNoZWQgPVxuICBsZXQgY29uc3VtZXIgPSBDb25zdW1lci5jcmVhdGUgfnBpcGVfaWQ6dC5pZCB+ZG93bnN0cmVhbV9mbHVzaGVkIGluXG4gIHQuY29uc3VtZXJzIDwtIGNvbnN1bWVyIDo6IHQuY29uc3VtZXJzO1xuICBjb25zdW1lclxuOztcblxuKCogQSBbTGluay50XSBsaW5rcyBmbHVzaGluZyBvZiB0d28gcGlwZXMgdG9nZXRoZXIuICopXG5tb2R1bGUgTGluayA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY3JlYXRlIDogdXBzdHJlYW06KF8sIF8pIHBpcGUgLT4gZG93bnN0cmVhbTooXywgXykgcGlwZSAtPiB0XG4gIHZhbCBjb25zdW1lciA6IHQgLT4gQ29uc3VtZXIudFxuXG4gICgqIFt1bmxpbmtfdXBzdHJlYW1dIHJlbW92ZXMgZG93bnN0cmVhbSdzIHJlZmVyZW5jZSB0byB1cHN0cmVhbS4gKilcblxuICB2YWwgdW5saW5rX3Vwc3RyZWFtIDogdCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB1bnBhY2tlZCA9XG4gICAgeyBkb3duc3RyZWFtIDogKCdhLCAnYikgdFxuICAgIDsgY29uc3VtZXIgOiBDb25zdW1lci50XG4gICAgOyB1cHN0cmVhbV9mbHVzaGVkc19iYWdfZWx0IDogKHVuaXQgLT4gRmx1c2hlZF9yZXN1bHQudCBEZWZlcnJlZC50KSBCYWcuRWx0LnRcbiAgICB9XG5cbiAgdHlwZSB0ID0gVCA6IChfLCBfKSB1bnBhY2tlZCAtPiB0XG5cbiAgbGV0IGNvbnN1bWVyIChUIHQpID0gdC5jb25zdW1lclxuXG4gIGxldCBjcmVhdGUgfnVwc3RyZWFtIH5kb3duc3RyZWFtID1cbiAgICBUXG4gICAgICB7IGRvd25zdHJlYW1cbiAgICAgIDsgY29uc3VtZXIgPVxuICAgICAgICAgIGFkZF9jb25zdW1lciB1cHN0cmVhbSB+ZG93bnN0cmVhbV9mbHVzaGVkOihmdW4gKCkgLT5cbiAgICAgICAgICAgIGRvd25zdHJlYW1fZmx1c2hlZCBkb3duc3RyZWFtKVxuICAgICAgOyB1cHN0cmVhbV9mbHVzaGVkc19iYWdfZWx0ID1cbiAgICAgICAgICBhZGRfdXBzdHJlYW1fZmx1c2hlZCBkb3duc3RyZWFtIChmdW4gKCkgLT4gdXBzdHJlYW1fZmx1c2hlZCB1cHN0cmVhbSlcbiAgICAgIH1cbiAgOztcblxuICBsZXQgdW5saW5rX3Vwc3RyZWFtIChUIHQpID1cbiAgICBCYWcucmVtb3ZlIHQuZG93bnN0cmVhbS51cHN0cmVhbV9mbHVzaGVkcyB0LnVwc3RyZWFtX2ZsdXNoZWRzX2JhZ19lbHRcbiAgOztcbmVuZFxuXG5tb2R1bGUgRmx1c2hlZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ29uc3VtZXIgb2YgQ29uc3VtZXIudFxuICAgIHwgV2hlbl92YWx1ZV9wcm9jZXNzZWRcbiAgICB8IFdoZW5fdmFsdWVfcmVhZFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbmxldCBmb2xkX2dlblxuICAocmVhZF9ub3cgOiA/Y29uc3VtZXI6Q29uc3VtZXIudCAtPiBfIFJlYWRlci50IC0+IF8pXG4gID8oZmx1c2hlZCA9IEZsdXNoZWQuV2hlbl92YWx1ZV9yZWFkKVxuICB0XG4gIH5pbml0XG4gIH5mXG4gID1cbiAgbGV0IGNvbnN1bWVyID1cbiAgICBtYXRjaCBmbHVzaGVkIHdpdGhcbiAgICB8IFdoZW5fdmFsdWVfcmVhZCAtPiBOb25lXG4gICAgfCBDb25zdW1lciBjb25zdW1lciAtPiBTb21lIGNvbnN1bWVyXG4gICAgfCBXaGVuX3ZhbHVlX3Byb2Nlc3NlZCAtPlxuICAgICAgKCogVGhlIGZhY3QgdGhhdCBcIm5vIGNvbnN1bWVyXCIgYmVoYXZlcyBkaWZmZXJlbnQgZnJvbSBcInRyaXZpYWwgY29uc3VtZXJcIiBpcyB3ZWlyZCxcbiAgICAgICAgIGJ1dCB0aGF0J3MgaG93IHRoZSBjb25zdW1lciBtYWNoaW5lcnkgd29ya3MuICopXG4gICAgICBTb21lIChhZGRfY29uc3VtZXIgdCB+ZG93bnN0cmVhbV9mbHVzaGVkOihmdW4gKCkgLT4gcmV0dXJuIGBPaykpXG4gIGluXG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMgdCA/Y29uc3VtZXI7XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIGZpbmlzaGVkIC0+XG4gICAgKCogV2UgZG8gW3ZhbHVlc19hdmFpbGFibGUgdCA+Pj5dIHRvIGVuc3VyZSB0aGF0IFtmXSBpcyBvbmx5IGNhbGxlZCBhc3luY2hyb25vdXNseS5cbiAgICAgICBTZWUgWzFdIGZvciBtb3JlIGRldGFpbHMuICopXG4gICAgKCogWzFdIEZvciBuZXcgZW1wdHkgcGlwZXMgY3JlYXRlZCBhdCB0b3AtbGV2ZWwgd2Ugd2FudCB0byBhdm9pZCBpbW1lZGlhdGVseVxuICAgICAgIHNjaGVkdWxpbmcgYSBqb2Igb24gdGhlIHNjaGVkdWxlciAoc2VlIFtTY2hlZHVsZXIucmFpc2VfaWZfYW55X2pvYnNfd2VyZV9zY2hlZHVsZWRdKS5cbiAgICAgICBKdXN0IFtyZXR1cm4gKCkgPj4+XSBkb2Vzbid0IHdvcms6IFtyZXR1cm4gKCldIGNyZWF0ZXMgYSBmdWxsIGl2YXIgdGhhdCBjYXVzZXNcbiAgICAgICBbPj4+XSB0byBzY2hlZHVsZSBhIGpvYi4gKilcbiAgICB2YWx1ZXNfYXZhaWxhYmxlIHRcbiAgICA+Pj4gZnVuIChfIDogWyBgT2sgfCBgRW9mIF0pIC0+XG4gICAgbGV0IHJlYyBsb29wIGIgPVxuICAgICAgbWF0Y2ggcmVhZF9ub3cgdCA/Y29uc3VtZXIgd2l0aFxuICAgICAgfCBgRW9mIC0+IEl2YXIuZmlsbF9leG4gZmluaXNoZWQgYlxuICAgICAgfCBgT2sgdiAtPiBmIGIgdiBjb250aW51ZVxuICAgICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT4gdmFsdWVzX2F2YWlsYWJsZSB0ID4+PiBmdW4gXyAtPiBsb29wIGJcbiAgICBhbmQgY29udGludWUgYiA9XG4gICAgICBPcHRpb24uaXRlciBjb25zdW1lciB+ZjpDb25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtO1xuICAgICAgbG9vcCBiXG4gICAgaW5cbiAgICBsb29wIGluaXQpXG47O1xuXG5sZXQgZm9sZCcgP2ZsdXNoZWQgP21heF9xdWV1ZV9sZW5ndGggdCB+aW5pdCB+ZiA9XG4gIGZvbGRfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpID9mbHVzaGVkIHQgfmluaXQgfmY6KGZ1biBiIHEgbG9vcCAtPlxuICAgIGYgYiBxID4+PiBsb29wKVxuOztcblxubGV0IGZvbGQgP2ZsdXNoZWQgdCB+aW5pdCB+ZiA9XG4gIGZvbGRfZ2VuIHJlYWRfbm93ID9mbHVzaGVkIHQgfmluaXQgfmY6KGZ1biBiIGEgbG9vcCAtPiBmIGIgYSA+Pj4gbG9vcClcbjs7XG5cbmxldCBmb2xkX3dpdGhvdXRfcHVzaGJhY2sgP2NvbnN1bWVyIHQgfmluaXQgfmYgPVxuICBmb2xkX2dlblxuICAgIHJlYWRfbm93XG4gICAgdFxuICAgIH5pbml0XG4gICAgfmY6KGZ1biBiIGEgbG9vcCAtPiBsb29wIChmIGIgYSkpXG4gICAgP2ZsdXNoZWQ6XG4gICAgICAobWF0Y2ggY29uc3VtZXIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgfCBTb21lIGMgLT4gU29tZSAoQ29uc3VtZXIgYykpXG47O1xuXG5sZXQgd2l0aF9lcnJvcl90b19jdXJyZW50X21vbml0b3IgPyhjb250aW51ZV9vbl9lcnJvciA9IGZhbHNlKSBmIGEgPVxuICBpZiBub3QgY29udGludWVfb25fZXJyb3JcbiAgdGhlbiBmIGFcbiAgZWxzZSAoXG4gICAgbWF0Y2glbWFwIE1vbml0b3IudHJ5X3dpdGggfnJ1bjpgU2NoZWR1bGUgfnJlc3Q6YExvZyAoZnVuICgpIC0+IGYgYSkgd2l0aFxuICAgIHwgT2sgKCkgLT4gKClcbiAgICB8IEVycm9yIGV4biAtPiBNb25pdG9yLnNlbmRfZXhuIChNb25pdG9yLmN1cnJlbnQgKCkpIChNb25pdG9yLmV4dHJhY3RfZXhuIGV4bikpXG47O1xuXG5sZXQgaXRlcicgP2NvbnRpbnVlX29uX2Vycm9yID9mbHVzaGVkID9tYXhfcXVldWVfbGVuZ3RoIHQgfmYgPVxuICBmb2xkJyA/bWF4X3F1ZXVlX2xlbmd0aCA/Zmx1c2hlZCB0IH5pbml0OigpIH5mOihmdW4gKCkgcSAtPlxuICAgIHdpdGhfZXJyb3JfdG9fY3VycmVudF9tb25pdG9yID9jb250aW51ZV9vbl9lcnJvciBmIHEpXG47O1xuXG5sZXQgaXRlciA/Y29udGludWVfb25fZXJyb3IgP2ZsdXNoZWQgdCB+ZiA9XG4gIGZvbGRfZ2VuIHJlYWRfbm93ID9mbHVzaGVkIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBhIGxvb3AgLT5cbiAgICB3aXRoX2Vycm9yX3RvX2N1cnJlbnRfbW9uaXRvciA/Y29udGludWVfb25fZXJyb3IgZiBhID4+PiBmdW4gKCkgLT4gbG9vcCAoKSlcbjs7XG5cbigqIFtpdGVyX3dpdGhvdXRfcHVzaGJhY2tdIGlzIGEgY29tbW9uIGNhc2UsIHNvIHdlIGltcGxlbWVudCBpdCBpbiBhbiBvcHRpbWl6ZWQgbWFubmVyLFxuICAgcmF0aGVyIHRoYW4gdmlhIFtpdGVyXS4gIFRoZSBpbXBsZW1lbnRhdGlvbiByZWFkcyBvbmx5IG9uZSBlbGVtZW50IGF0IGEgdGltZSwgc28gdGhhdFxuICAgaWYgW2ZdIGNsb3NlcyBbdF0gb3IgcmFpc2VzLCBubyBtb3JlIGVsZW1lbnRzIHdpbGwgYmUgcmVhZC4gKilcbmxldCBpdGVyX3dpdGhvdXRfcHVzaGJhY2tcbiAgP2NvbnN1bWVyXG4gID8oY29udGludWVfb25fZXJyb3IgPSBmYWxzZSlcbiAgP21heF9pdGVyYXRpb25zX3Blcl9qb2JcbiAgdFxuICB+ZlxuICA9XG4gIGVuc3VyZV9jb25zdW1lcl9tYXRjaGVzIHQgP2NvbnN1bWVyO1xuICBsZXQgbWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiA9XG4gICAgbWF0Y2ggbWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiB3aXRoXG4gICAgfCBOb25lIC0+IEludC5tYXhfdmFsdWVcbiAgICB8IFNvbWUgbWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiAtPlxuICAgICAgaWYgbWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiA8PSAwXG4gICAgICB0aGVuXG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFwiaXRlcl93aXRob3V0X3B1c2hiYWNrIGdvdCBub24tcG9zaXRpdmUgbWF4X2l0ZXJhdGlvbnNfcGVyX2pvYlwiXG4gICAgICAgICAgICAgIChtYXhfaXRlcmF0aW9uc19wZXJfam9iIDogaW50KV07XG4gICAgICBtYXhfaXRlcmF0aW9uc19wZXJfam9iXG4gIGluXG4gIGxldCBmID1cbiAgICBpZiBub3QgY29udGludWVfb25fZXJyb3JcbiAgICB0aGVuIGZcbiAgICBlbHNlXG4gICAgICBmdW4gYSAtPlxuICAgICAgdHJ5IGYgYSB3aXRoXG4gICAgICB8IGV4biAtPiBNb25pdG9yLnNlbmRfZXhuIChNb25pdG9yLmN1cnJlbnQgKCkpIGV4blxuICBpblxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBmaW5pc2hlZCAtPlxuICAgICgqIFdlIGRvIFt2YWx1ZXNfYXZhaWxhYmxlIHQgPj4+XSB0byBlbnN1cmUgdGhhdCBbZl0gaXMgb25seSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgU2VlIFsxXSBmb3IgbW9yZSBkZXRhaWxzLiAqKVxuICAgIHZhbHVlc19hdmFpbGFibGUgdFxuICAgID4+PiBmdW4gKF8gOiBbIGBPayB8IGBFb2YgXSkgLT5cbiAgICBsZXQgcmVjIHN0YXJ0ICgpID0gbG9vcCB+cmVtYWluaW5nOm1heF9pdGVyYXRpb25zX3Blcl9qb2JcbiAgICBhbmQgbG9vcCB+cmVtYWluaW5nID1cbiAgICAgIGlmIHJlbWFpbmluZyA9IDBcbiAgICAgIHRoZW4gcmV0dXJuICgpID4+PiBmdW4gKCkgLT4gc3RhcnQgKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCByZWFkX25vdyB0ID9jb25zdW1lciB3aXRoXG4gICAgICAgIHwgYEVvZiAtPiBJdmFyLmZpbGxfZXhuIGZpbmlzaGVkICgpXG4gICAgICAgIHwgYE9rIGEgLT5cbiAgICAgICAgICBmIGE7XG4gICAgICAgICAgbG9vcCB+cmVtYWluaW5nOihyZW1haW5pbmcgLSAxKVxuICAgICAgICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPiB2YWx1ZXNfYXZhaWxhYmxlIHQgPj4+IGZ1biBfIC0+IHN0YXJ0ICgpKVxuICAgIGluXG4gICAgc3RhcnQgKCkpXG47O1xuXG5sZXQgZHJhaW4gdCA9IGl0ZXInIHQgfmY6KGZ1biBfIC0+IHJldHVybiAoKSlcbmxldCBkcmFpbl9hbmRfY291bnQgdCA9IGZvbGQnIHQgfmluaXQ6MCB+ZjooZnVuIHN1bSBxIC0+IHJldHVybiAoc3VtICsgUXVldWUubGVuZ3RoIHEpKVxuXG5sZXQgcmVhZF9hbGwgaW5wdXQgPVxuICBsZXQgcmVzdWx0ID0gUXVldWUuY3JlYXRlICgpIGluXG4gIGxldCVtYXAgKCkgPVxuICAgIGl0ZXInIGlucHV0IH5mOihmdW4gcSAtPlxuICAgICAgUXVldWUuYmxpdF90cmFuc2ZlciB+c3JjOnEgfmRzdDpyZXN1bHQgKCk7XG4gICAgICByZXR1cm4gKCkpXG4gIGluXG4gIHJlc3VsdFxuOztcblxubGV0IHRvX2xpc3QgciA9IHJlYWRfYWxsIHIgPj58IFF1ZXVlLnRvX2xpc3RcblxubGV0IHRvX3N0cmVhbV9kZXByZWNhdGVkIHQgPVxuICBTdHJlYW0uY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIGl0ZXJfd2l0aG91dF9wdXNoYmFjayB0IH5mOihmdW4geCAtPiBUYWlsLmV4dGVuZCB0YWlsIHgpXG4gICAgPj4+IGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKVxuOztcblxuKCogVGhlIGltcGxlbWVudGF0aW9uIG9mIFtvZl9zdHJlYW1fZGVwcmVjYXRlZF0gZG9lcyBhcyBtdWNoIGJhdGNoaW5nIGFzIHBvc3NpYmxlLiAgSXRcbiAgIGdyYWJzIGFzIG1hbnkgaXRlbXMgYXMgYXJlIGF2YWlsYWJsZSBpbnRvIGFuIGludGVybmFsIHF1ZXVlLiAgT25jZSBpdCBoYXMgZ3JhYmJlZFxuICAgZXZlcnl0aGluZywgaXQgd3JpdGVzIGl0IHRvIHRoZSBwaXBlIGFuZCB0aGVuIGJsb2NrcyB3YWl0aW5nIGZvciB0aGUgbmV4dCBlbGVtZW50IGZyb21cbiAgIHRoZSBzdHJlYW0uXG5cbiAgIFRoZXJlJ3Mgbm8gcG9zc2liaWxpdHkgdGhhdCB3ZSdsbCBzdGFydmUgdGhlIHBpcGUgcmVhZGluZyBhbiBlbmRsZXNzIHN0cmVhbSwganVzdFxuICAgYWNjdW11bGF0aW5nIHRoZSBlbGVtZW50cyBpbnRvIG91ciBwcml2YXRlIHF1ZXVlIGZvcmV2ZXIgd2l0aG91dCBldmVyIHdyaXRpbmcgdGhlbVxuICAgZG93bnN0cmVhbSB0byB0aGUgcGlwZS4gIFdoeT8gYmVjYXVzZSB3aGlsZSB3ZSdyZSBydW5uaW5nLCB0aGUgc3RyZWFtLXByb2R1Y2VyICppc24ndCpcbiAgIHJ1bm5pbmcgLS0gdGhlcmUgYXJlIG5vIEFzeW5jIGJsb2NrIHBvaW50cyBpbiB0aGUgcXVldWUtYWNjdW11bGF0b3IgbG9vcC4gIFNvIHRoZVxuICAgcXVldWUtYWNjdW11bGF0b3IgbG9vcCB3aWxsIGV2ZW50dWFsbHkgY2F0Y2ggdXAgdG8gdGhlIGN1cnJlbnQgc3RyZWFtIHRhaWwsIGF0IHdoaWNoXG4gICBwb2ludCB3ZSdsbCBkbyB0aGUgcGlwZS13cml0ZSBhbmQgdGhlbiBibG9jayBvbiB0aGUgc3RyZWFtLi4uIHRodXMgZ2l2aW5nIHRoZVxuICAgc3RyZWFtLXByb2R1Y2VyIGEgY2hhbmNlIHRvIG1ha2UgbW9yZSBlbGVtZW50cy5cblxuICAgT25lIGNhbid0IGltcGxlbWVudCBbb2Zfc3RyZWFtXSB1c2luZyBbU3RyZWFtLml0ZXJdIG9yIFtTdHJlYW0uaXRlciddIGJlY2F1c2UgeW91XG4gICBuZWVkIHRvIGJlIGFibGUgdG8gc3RvcCBlYXJseSB3aGVuIHRoZSBjb25zdW1lciBjbG9zZXMgdGhlIHBpcGUuICBBbHNvLCB1c2luZyBlaXRoZXJcbiAgIG9mIHRob3NlIHdvdWxkIGVudGFpbCBzaWduaWZpY2FudGx5IG1vcmUgZGVmZXJyZWQgb3ZlcmhlYWQsIHdoZXJlYXMgdGhlIGJlbG93XG4gICBpbXBsZW1lbnRhdGlvbiB1c2VzIGEgZGVmZXJyZWQgb25seSB3aGVuIGl0IG5lZWRzIHRvIHdhaXQgZm9yIGRhdGEgZnJvbSB0aGUgc3RyZWFtLiAqKVxubGV0IG9mX3N0cmVhbV9kZXByZWNhdGVkIHMgPVxuICBsZXQgciwgdyA9IGNyZWF0ZSAoKSBpblxuICBsZXQgcSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgdHJhbnNmZXIgKCkgPVxuICAgIGlmIG5vdCAoUXVldWUuaXNfZW1wdHkgcSlcbiAgICB0aGVuXG4gICAgICAoKiBDYW4gbm90IHB1c2hiYWNrIG9uIHRoZSBzdHJlYW0sIHNvIGlnbm9yZSB0aGUgcHVzaGJhY2sgb24gdGhlIHBpcGUuICopXG4gICAgICBkb24ndF93YWl0X2ZvciAod3JpdGUnIHcgcSlcbiAgaW5cbiAgbGV0IHJlYyBsb29wIHMgPVxuICAgIGFzc2VydCAobm90IChpc19jbG9zZWQgdykpO1xuICAgIGxldCBuZXh0X2RlZmVycmVkID0gU3RyZWFtLm5leHQgcyBpblxuICAgIG1hdGNoIERlZmVycmVkLnBlZWsgbmV4dF9kZWZlcnJlZCB3aXRoXG4gICAgfCBTb21lIG5leHQgLT4gbG9vcF9uZXh0IG5leHRcbiAgICB8IE5vbmUgLT5cbiAgICAgIHRyYW5zZmVyICgpO1xuICAgICAgdXBvbiBuZXh0X2RlZmVycmVkIGNoZWNrX2Nsb3NlZF9sb29wX25leHRcbiAgYW5kIGNoZWNrX2Nsb3NlZF9sb29wX25leHQgbmV4dCA9IGlmIG5vdCAoaXNfY2xvc2VkIHcpIHRoZW4gbG9vcF9uZXh0IG5leHRcbiAgYW5kIGxvb3BfbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT5cbiAgICAgIHRyYW5zZmVyICgpO1xuICAgICAgY2xvc2Ugd1xuICAgIHwgQ29ucyAoeCwgcykgLT5cbiAgICAgIFF1ZXVlLmVucXVldWUgcSB4O1xuICAgICAgbG9vcCBzXG4gIGluXG4gIGxvb3AgcztcbiAgclxuOztcblxubGV0IHRyYW5zZmVyX2dlblxuICAocmVhZF9ub3cgOiA/Y29uc3VtZXI6Q29uc3VtZXIudCAtPiBfIFJlYWRlci50IC0+IF8pXG4gIHdyaXRlXG4gIGlucHV0XG4gIG91dHB1dFxuICB+ZlxuICA9XG4gIGlmICFjaGVja19pbnZhcmlhbnRcbiAgdGhlbiAoXG4gICAgaW52YXJpYW50IGlucHV0O1xuICAgIGludmFyaWFudCBvdXRwdXQpO1xuICBsZXQgbGluayA9IExpbmsuY3JlYXRlIH51cHN0cmVhbTppbnB1dCB+ZG93bnN0cmVhbTpvdXRwdXQgaW5cbiAgbGV0IGNvbnN1bWVyID0gTGluay5jb25zdW1lciBsaW5rIGluXG4gICgqIFdoZW4gd2UncmUgZG9uZSB3aXRoIFtpbnB1dF0sIHdlIHVubGluayB0byByZW1vdmUgcG9pbnRlcnMgZnJvbVxuICAgICBbb3V0cHV0XSB0byBbaW5wdXRdLCB3aGljaCB3b3VsZCBjYXVzZSBhIHNwYWNlIGxlYWsgaWYgd2UgaGFkIHNpbmdsZSBsb25nLWxpdmVkXG4gICAgIG91dHB1dCBpbnRvIHdoaWNoIHdlIHRyYW5zZmVyIGxvdHMgb2Ygc2hvcnQtbGl2ZWQgaW5wdXRzLiAqKVxuICBsZXQgdW5saW5rICgpID0gTGluay51bmxpbmtfdXBzdHJlYW0gbGluayBpblxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgaW5wdXRfYXZhaWxhYmxlX29yX291dHB1dF9jbG9zZWQgKCkgPVxuICAgICAgY2hvb3NlIFsgY2hvaWNlICh2YWx1ZXNfYXZhaWxhYmxlIGlucHV0KSBpZ25vcmU7IGNob2ljZSAoY2xvc2VkIG91dHB1dCkgaWdub3JlIF1cbiAgICBpblxuICAgICgqIFdlIGRvIFtpbnB1dF9hdmFpbGFibGVfb3Jfb3V0cHV0X2Nsb3NlZCAoKSA+Pj5dIHRvIGVuc3VyZSB0aGF0IFtmXSBpcyBvbmx5IGNhbGxlZFxuICAgICAgIGFzeW5jaHJvbm91c2x5LiBTZWUgWzFdIGZvciBtb3JlIGRldGFpbHMuICopXG4gICAgaW5wdXRfYXZhaWxhYmxlX29yX291dHB1dF9jbG9zZWQgKClcbiAgICA+Pj4gZnVuICgpIC0+XG4gICAgbGV0IG91dHB1dF9jbG9zZWQgKCkgPVxuICAgICAgY2xvc2VfcmVhZCBpbnB1dDtcbiAgICAgIHVubGluayAoKTtcbiAgICAgIEl2YXIuZmlsbF9leG4gcmVzdWx0ICgpXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgaWYgaXNfY2xvc2VkIG91dHB1dFxuICAgICAgdGhlbiBvdXRwdXRfY2xvc2VkICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggcmVhZF9ub3cgaW5wdXQgfmNvbnN1bWVyIHdpdGhcbiAgICAgICAgfCBgRW9mIC0+XG4gICAgICAgICAgdW5saW5rICgpO1xuICAgICAgICAgIEl2YXIuZmlsbF9leG4gcmVzdWx0ICgpXG4gICAgICAgIHwgYE9rIHggLT4gZiB4IGNvbnRpbnVlXG4gICAgICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+IGlucHV0X2F2YWlsYWJsZV9vcl9vdXRwdXRfY2xvc2VkICgpID4+PiBmdW4gKCkgLT4gbG9vcCAoKSlcbiAgICBhbmQgY29udGludWUgeSA9XG4gICAgICBpZiBpc19jbG9zZWQgb3V0cHV0XG4gICAgICB0aGVuIG91dHB1dF9jbG9zZWQgKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcHVzaGJhY2sgPSB3cml0ZSBvdXRwdXQgeSBpblxuICAgICAgICBDb25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtIGNvbnN1bWVyO1xuICAgICAgICBwdXNoYmFjayA+Pj4gZnVuICgpIC0+IGxvb3AgKCkpXG4gICAgaW5cbiAgICBsb29wICgpKVxuOztcblxubGV0IHRyYW5zZmVyJyA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCBvdXRwdXQgfmYgPVxuICB0cmFuc2Zlcl9nZW4gKHJlYWRfbm93JyA/bWF4X3F1ZXVlX2xlbmd0aCkgd3JpdGUnIGlucHV0IG91dHB1dCB+ZjooZnVuIHEgayAtPiBmIHEgPj4+IGspXG47O1xuXG5sZXQgdHJhbnNmZXIgaW5wdXQgb3V0cHV0IH5mID1cbiAgdHJhbnNmZXJfZ2VuIHJlYWRfbm93IHdyaXRlIGlucHV0IG91dHB1dCB+ZjooZnVuIGEgayAtPiBrIChmIGEpKVxuOztcblxubGV0IHRyYW5zZmVyX2lkID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IG91dHB1dCA9XG4gIHRyYW5zZmVyX2dlbiAocmVhZF9ub3cnID9tYXhfcXVldWVfbGVuZ3RoKSB3cml0ZScgaW5wdXQgb3V0cHV0IH5mOihmdW4gcSBrIC0+IGsgcSlcbjs7XG5cbmxldCBtYXBfZ2VuIHJlYWQgd3JpdGUgaW5wdXQgfmYgPVxuICBsZXQgaW5mbyA9IE9wdGlvbi5tYXAgaW5wdXQuaW5mbyB+ZjooZnVuIGluZm8gLT4gWyVzZXhwIE1hcHBlZCAoaW5mbyA6IFNleHAudCldKSBpblxuICBsZXQgcmVzdWx0LCBvdXRwdXQgPSBjcmVhdGUgP2luZm8gKCkgaW5cbiAgdXBvbiAodHJhbnNmZXJfZ2VuIHJlYWQgd3JpdGUgaW5wdXQgb3V0cHV0IH5mKSAoZnVuICgpIC0+IGNsb3NlIG91dHB1dCk7XG4gIHJlc3VsdFxuOztcblxubGV0IG1hcCcgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmYgPVxuICBtYXBfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpIHdyaXRlJyBpbnB1dCB+ZjooZnVuIHEgayAtPiBmIHEgPj4+IGspXG47O1xuXG5sZXQgbWFwIGlucHV0IH5mID0gbWFwX2dlbiByZWFkX25vdyB3cml0ZSBpbnB1dCB+ZjooZnVuIGEgayAtPiBrIChmIGEpKVxuXG5sZXQgY29uY2F0X21hcF9saXN0ID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mID1cbiAgbWFwX2dlbiAocmVhZF9ub3cnID9tYXhfcXVldWVfbGVuZ3RoKSB3cml0ZScgaW5wdXQgfmY6KGZ1biBxIGsgLT5cbiAgICBrIChRdWV1ZS5jb25jYXRfbWFwIHEgfmYpKVxuOztcblxubGV0IGZpbHRlcl9tYXAnID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mID1cbiAgbWFwJyA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+ZjooZnVuIHEgLT5cbiAgICBEZWZlcnJlZC5RdWV1ZS5maWx0ZXJfbWFwIH5ob3c6YFNlcXVlbnRpYWwgcSB+Zilcbjs7XG5cbmxldCBmaWx0ZXJfbWFwID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mID1cbiAgbWFwX2dlbiAocmVhZF9ub3cnID9tYXhfcXVldWVfbGVuZ3RoKSB3cml0ZScgaW5wdXQgfmY6KGZ1biBxIGsgLT5cbiAgICBrIChRdWV1ZS5maWx0ZXJfbWFwIHEgfmY6KGZ1biB4IC0+IGlmIGlzX3JlYWRfY2xvc2VkIGlucHV0IHRoZW4gTm9uZSBlbHNlIGYgeCkpKVxuOztcblxubGV0IGZvbGRpbmdfZmlsdGVyX21hcCcgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmluaXQgfmYgPVxuICBsZXQgYWNjdW0gPSByZWYgaW5pdCBpblxuICBmaWx0ZXJfbWFwJyA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+ZjooZnVuIHggLT5cbiAgICBsZXQlbWFwIGEsIHggPSBmICFhY2N1bSB4IGluXG4gICAgYWNjdW0gOj0gYTtcbiAgICB4KVxuOztcblxubGV0IGZvbGRpbmdfZmlsdGVyX21hcCA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+aW5pdCB+ZiA9XG4gIGxldCBhY2N1bSA9IHJlZiBpbml0IGluXG4gIGZpbHRlcl9tYXAgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmY6KGZ1biB4IC0+XG4gICAgbGV0IGEsIHggPSBmICFhY2N1bSB4IGluXG4gICAgYWNjdW0gOj0gYTtcbiAgICB4KVxuOztcblxubGV0IGZvbGRpbmdfbWFwID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5pbml0IH5mID1cbiAgZm9sZGluZ19maWx0ZXJfbWFwID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5pbml0IH5mOihmdW4gYWNjdW0gYSAtPlxuICAgIGxldCBhY2N1bSwgYiA9IGYgYWNjdW0gYSBpblxuICAgIGFjY3VtLCBTb21lIGIpXG47O1xuXG5sZXQgZmlsdGVyIGlucHV0IH5mID0gZmlsdGVyX21hcCBpbnB1dCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcblxubGV0IG9mX3F1ZXVlX2ludGVybmFsIHF1ZXVlID1cbiAgbGV0IHQgPSBjcmVhdGVfaW50ZXJuYWwgfnNpemVfYnVkZ2V0OjAgfmluZm86Tm9uZSB+aW5pdGlhbF9idWZmZXI6cXVldWUgaW5cbiAgSXZhci5maWxsX2V4biB0LmNsb3NlZCAoKTtcbiAgdXBkYXRlX3B1c2hiYWNrIHQ7XG4gIHRcbjs7XG5cbmxldCBvZl9xdWV1ZSBxdWV1ZSA9IG9mX3F1ZXVlX2ludGVybmFsIChRdWV1ZS5jb3B5IHF1ZXVlKVxubGV0IG9mX2xpc3QgbCA9IG9mX3F1ZXVlX2ludGVybmFsIChRdWV1ZS5vZl9saXN0IGwpXG5sZXQgZW1wdHkgKCkgPSBvZl9saXN0IFtdXG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCByZWFkZXIsIHdyaXRlciA9IGNyZWF0ZSAoKSBpblxuICB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHdyaXRlciB4O1xuICBjbG9zZSB3cml0ZXI7XG4gIHJlYWRlclxuOztcblxubGV0IHVuZm9sZCB+aW5pdDpzIH5mID1cbiAgKCogVG8gZ2V0IHNvbWUgYmF0Y2hpbmcsIHdlIHJ1biB0aGUgY29udGludWF0aW9uIGltbWVkaWF0ZWx5IGlmIHRoZSBkZWZlcnJlZCBpc1xuICAgICBkZXRlcm1pbmVkLiAgSG93ZXZlciwgd2UgYWx3YXlzIGNoZWNrIGZvciBwdXNoYmFjay4gIEJlY2F1c2Ugc2l6ZSBidWRnZXQgY2FuJ3QgYmVcbiAgICAgaW5maW5pdGUsIHRoZSBiZWxvdyBsb29wIGlzIGd1YXJhbnRlZWQgdG8gZXZlbnR1YWxseSB5aWVsZCB0byB0aGUgc2NoZWR1bGVyLiAqKVxuICBsZXQgKCA+Pj1+ICkgZCBmID1cbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIGQgd2l0aFxuICAgIHwgTm9uZSAtPiBkID4+PSBmXG4gICAgfCBTb21lIHggLT4gZiB4XG4gIGluXG4gIGNyZWF0ZV9yZWFkZXIgfmNsb3NlX29uX2V4Y2VwdGlvbjpmYWxzZSAoZnVuIHdyaXRlciAtPlxuICAgIGxldCByZWMgbG9vcCBzID1cbiAgICAgIGYgc1xuICAgICAgPj49fiBmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IHJldHVybiAoKVxuICAgICAgfCBTb21lIChhLCBzKSAtPlxuICAgICAgICBpZiBpc19jbG9zZWQgd3JpdGVyIHRoZW4gcmV0dXJuICgpIGVsc2Ugd3JpdGUgd3JpdGVyIGEgPj49fiBmdW4gKCkgLT4gbG9vcCBzXG4gICAgaW5cbiAgICBsb29wIHMpXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2Ugc2VxdWVuY2UgPVxuICBjcmVhdGVfcmVhZGVyIH5jbG9zZV9vbl9leGNlcHRpb246ZmFsc2UgKGZ1biB3cml0ZXIgLT5cbiAgICBsZXQgcmVjIGVucXVldWVfbiBzZXF1ZW5jZSBpID1cbiAgICAgIGlmIGkgPD0gMFxuICAgICAgdGhlbiBzZXF1ZW5jZVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIFNlcXVlbmNlLm5leHQgc2VxdWVuY2Ugd2l0aFxuICAgICAgICB8IE5vbmUgLT4gc2VxdWVuY2VcbiAgICAgICAgfCBTb21lIChhLCBzZXF1ZW5jZSkgLT5cbiAgICAgICAgICBkZWNyZWFzZV9yZXNlcnZlZF9zcGFjZSB3cml0ZXIgMTtcbiAgICAgICAgICBRdWV1ZS5lbnF1ZXVlIHdyaXRlci5idWZmZXIgYTtcbiAgICAgICAgICBlbnF1ZXVlX24gc2VxdWVuY2UgKGkgLSAxKSlcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBzZXF1ZW5jZSA9XG4gICAgICBpZiBpc19jbG9zZWQgd3JpdGVyIHx8IFNlcXVlbmNlLmlzX2VtcHR5IHNlcXVlbmNlXG4gICAgICB0aGVuIHJldHVybiAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgICgqIFtzaXplOjBdIGhlcmUgYXMgd2UgZG9uJ3Qga25vdyB0aGUgc2l6ZSBvZiB0aGUgc2VxdWVuY2Ugc3RhdGljYWxseS4gV2UnbGxcbiAgICAgICAgICAgY2FsbCBbZGVjcmVhc2VfcmVzZXJ2ZWRfc3BhY2VdIGFzIHdlIGdvLlxuICAgICAgICAgICAoYWx0aG91Z2ggcmVhbGlzdGljYWxseSwgaXQncyBpbXBvc3NpYmxlIGZvciB0aGUgdXNlciB0byByZXNlcnZlIHNwYWNlIGluXG4gICAgICAgICAgIHRoaXMgcGlwZSBiZWNhdXNlIHlvdSBuZWVkIGEgcGlwZSB3cml0ZXIgZm9yIHRoYXQsIGJ1dCBbb2Zfc2VxdWVuY2VdIHJldHVybnNcbiAgICAgICAgICAgYSByZWFkZXIpICopXG4gICAgICAgIHN0YXJ0X3dyaXRlIHdyaXRlciB+c2l6ZTowO1xuICAgICAgICBsZXQgc2VxdWVuY2UgPSBlbnF1ZXVlX24gc2VxdWVuY2UgKDEgKyB3cml0ZXIuc2l6ZV9idWRnZXQgLSBsZW5ndGggd3JpdGVyKSBpblxuICAgICAgICBmaW5pc2hfd3JpdGUgd3JpdGVyO1xuICAgICAgICBsZXQlYmluZCAoKSA9IHB1c2hiYWNrIHdyaXRlciBpblxuICAgICAgICBsb29wIHNlcXVlbmNlKVxuICAgIGluXG4gICAgbG9vcCBzZXF1ZW5jZSlcbjs7XG5cbnR5cGUgJ2EgdG9fc2VxdWVuY2VfZWx0ID1cbiAgfCBWYWx1ZSBvZiAnYVxuICB8IFdhaXRfZm9yIDogXyBEZWZlcnJlZC50IC0+IF8gdG9fc2VxdWVuY2VfZWx0XG5cbmxldCB0b19zZXF1ZW5jZSB0ID1cbiAgU2VxdWVuY2UudW5mb2xkIH5pbml0OigpIH5mOihmdW4gKCkgLT5cbiAgICBtYXRjaCByZWFkX25vdyB0IHdpdGhcbiAgICB8IGBFb2YgLT4gTm9uZVxuICAgIHwgYE9rIGEgLT4gU29tZSAoVmFsdWUgYSwgKCkpXG4gICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT4gU29tZSAoV2FpdF9mb3IgKHZhbHVlc19hdmFpbGFibGUgdCksICgpKSlcbjs7XG5cbmxldCBpbnRlcmxlYXZlX3BpcGUgPyhjbG9zZV9vbiA9IGBBbGxfaW5wdXRzX2Nsb3NlZCkgaW5wdXRzID1cbiAgbGV0IG91dHB1dCwgb3V0cHV0X3dyaXRlciA9IGNyZWF0ZSB+aW5mbzpbJXNleHAgXCJQaXBlLmludGVybGVhdmVcIl0gKCkgaW5cbiAgKCogV2Uga2VlcCBhIHJlZmVyZW5jZSBjb3VudCBvZiBhbGwgdGhlIHBpcGVzIHRoYXQgW2ludGVybGVhdmVfcGlwZV0gaXMgbWFuYWdpbmc7XG4gICAgIFtpbnB1dHNdIGNvdW50cyBhcyBvbmUuICBXaGVuIHRoZSByZWZlcmVuY2UgY291bnQgZHJvcHMgdG8gemVybywgd2Uga25vdyB0aGF0IGFsbFxuICAgICBwaXBlcyBhcmUgY2xvc2VkIGFuZCB3ZSBjYW4gY2xvc2UgW291dHB1dF93cml0ZXJdLiAqKVxuICBsZXQgbnVtX3BpcGVzX3JlbWFpbmluZyA9IHJlZiAxIGluXG4gIGxldCBjbG9zZV9vbmVfcGlwZSBjbG9zZWRfcGlwZV9raW5kID1cbiAgICBkZWNyIG51bV9waXBlc19yZW1haW5pbmc7XG4gICAgbGV0IHNob3VsZF9jbG9zZSA9XG4gICAgICBtYXRjaCBjbG9zZV9vbiwgY2xvc2VkX3BpcGVfa2luZCB3aXRoXG4gICAgICB8IGBBbnlfaW5wdXRfY2xvc2VkLCBgSW5wdXRfcGlwZSAtPiB0cnVlXG4gICAgICB8IGBBbnlfaW5wdXRfY2xvc2VkLCBgUGlwZV9vZl9pbnB1dF9waXBlc1xuICAgICAgfCBgQWxsX2lucHV0c19jbG9zZWQsIChgSW5wdXRfcGlwZSB8IGBQaXBlX29mX2lucHV0X3BpcGVzKSAtPlxuICAgICAgICAhbnVtX3BpcGVzX3JlbWFpbmluZyA9IDBcbiAgICBpblxuICAgIGlmIHNob3VsZF9jbG9zZSB0aGVuIGNsb3NlIG91dHB1dF93cml0ZXJcbiAgaW5cbiAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAobGV0JW1hcCAoKSA9XG4gICAgICAgaXRlcl93aXRob3V0X3B1c2hiYWNrIGlucHV0cyB+ZjooZnVuIGlucHV0IC0+XG4gICAgICAgICBpbmNyIG51bV9waXBlc19yZW1haW5pbmc7XG4gICAgICAgICBkb24ndF93YWl0X2ZvclxuICAgICAgICAgICAobGV0JW1hcCAoKSA9IHRyYW5zZmVyX2lkIGlucHV0IG91dHB1dF93cml0ZXIgaW5cbiAgICAgICAgICAgIGNsb3NlX29uZV9waXBlIGBJbnB1dF9waXBlKSlcbiAgICAgaW5cbiAgICAgY2xvc2Vfb25lX3BpcGUgYFBpcGVfb2ZfaW5wdXRfcGlwZXMpO1xuICAoKiBmb3IgW2lucHV0c10gKilcbiAgb3V0cHV0XG47O1xuXG5sZXQgaW50ZXJsZWF2ZSA/Y2xvc2Vfb24gaW5wdXRzID1cbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIExpc3QuaXRlciBpbnB1dHMgfmY6aW52YXJpYW50O1xuICBpbnRlcmxlYXZlX3BpcGUgP2Nsb3NlX29uIChvZl9saXN0IGlucHV0cylcbjs7XG5cbmxldCBtZXJnZSBpbnB1dHMgfmNvbXBhcmUgPVxuICBtYXRjaCBpbnB1dHMgd2l0aFxuICB8IFtdIC0+IGVtcHR5ICgpXG4gIHwgWyBpbnB1dCBdIC0+IGlucHV0XG4gIHwgaW5wdXRzIC0+XG4gICAgbGV0IG1vZHVsZSBIZWFwID0gUGFpcmluZ19oZWFwIGluXG4gICAgbGV0IHIsIHcgPSBjcmVhdGUgKCkgaW5cbiAgICB1cG9uIChjbG9zZWQgdykgKGZ1biAoKSAtPiBMaXN0Lml0ZXIgaW5wdXRzIH5mOmNsb3NlX3JlYWQpO1xuICAgIGxldCBoZWFwID0gSGVhcC5jcmVhdGUgfmNtcDooZnVuIChhMSwgXykgKGEyLCBfKSAtPiBjb21wYXJlIGExIGEyKSAoKSBpblxuICAgIGxldCBoYW5kbGVfcmVhZCBpbnB1dCBlb2Zfb3Jfb2sgPVxuICAgICAgbWF0Y2ggZW9mX29yX29rIHdpdGhcbiAgICAgIHwgYEVvZiAtPiAoKVxuICAgICAgfCBgT2sgdiAtPiBIZWFwLmFkZCBoZWFwICh2LCBpbnB1dClcbiAgICBpblxuICAgIGxldCByZWMgcG9wX2hlYXBfYW5kX2xvb3AgKCkgPVxuICAgICAgKCogQXQgdGhpcyBwb2ludCwgYWxsIGlucHV0cyBub3QgYXQgRW9mIG9jY3VyIGluIFtoZWFwXSBleGFjdGx5IG9uY2UsIHNvIHdlIGtub3dcbiAgICAgICAgIHdoYXQgdGhlIG5leHQgb3V0cHV0IGVsZW1lbnQgaXMuICBbcG9wX2hlYXBfYW5kX2xvb3BdIHJlcGVhdGVkbHkgdGFrZXMgZWxlbWVudHNcbiAgICAgICAgIGZyb20gdGhlIGlucHV0cyBhcyBsb25nIGFzIGl0IGhhcyBvbmUgZnJvbSBlYWNoIGlucHV0LiAgVGhpcyBpcyBkb25lXG4gICAgICAgICBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHRoZSBjb3N0IG9mIGEgZGVmZXJyZWQgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgb3V0cHV0IC0tXG4gICAgICAgICB0aGVyZSdzIG5vIG5lZWQgdG8gcHVzaGJhY2sgc2luY2UgdGhhdCBpcyBvbmx5IG1vdmluZyBlbGVtZW50cyBmcm9tIG9uZSBwaXBlIHRvXG4gICAgICAgICBhbm90aGVyLiAgQXMgc29vbiBhcyBbcG9wX2hlYXBfYW5kX2xvb3BdIGNhbid0IGdldCBhbiBlbGVtZW50IGZyb20gc29tZSBpbnB1dCwgaXRcbiAgICAgICAgIHdhaXRzIG9uIHB1c2hiYWNrIGZyb20gdGhlIG91dHB1dCwgc2luY2UgaXQgaGFzIHRvIHdhaXQgb24gdGhlIGlucHV0IGFueXdheS5cbiAgICAgICAgIFRoaXMgYWxzbyBwcmV2ZW50cyBbbWVyZ2VdIGZyb20gY29uc3VtaW5nIGlucHV0cyBhdCBhIHJhdGUgZmFzdGVyIHRoYW4gaXRzIG91dHB1dFxuICAgICAgICAgaXMgY29uc3VtZWQuICopXG4gICAgICBtYXRjaCBIZWFwLnBvcCBoZWFwIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBjbG9zZSB3XG4gICAgICB8IFNvbWUgKHYsIGlucHV0KSAtPlxuICAgICAgICBpZiBub3QgKGlzX2Nsb3NlZCB3KVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHcgdjtcbiAgICAgICAgICBpZiBIZWFwLmxlbmd0aCBoZWFwID0gMFxuICAgICAgICAgIHRoZW4gdXBvbiAodHJhbnNmZXJfaWQgaW5wdXQgdykgKGZ1biAoKSAtPiBjbG9zZSB3KVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbWF0Y2ggcmVhZF9ub3cgaW5wdXQgd2l0aFxuICAgICAgICAgICAgfCAoYEVvZiB8IGBPayBfKSBhcyB4IC0+XG4gICAgICAgICAgICAgIGhhbmRsZV9yZWFkIGlucHV0IHg7XG4gICAgICAgICAgICAgIHBvcF9oZWFwX2FuZF9sb29wICgpXG4gICAgICAgICAgICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPlxuICAgICAgICAgICAgICBwdXNoYmFjayB3XG4gICAgICAgICAgICAgID4+PiBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgcmVhZCBpbnB1dFxuICAgICAgICAgICAgICA+Pj4gZnVuIHggLT5cbiAgICAgICAgICAgICAgaGFuZGxlX3JlYWQgaW5wdXQgeDtcbiAgICAgICAgICAgICAgcG9wX2hlYXBfYW5kX2xvb3AgKCkpKVxuICAgIGluXG4gICAgbGV0IGluaXRpYWxfcHVzaCA9XG4gICAgICBEZWZlcnJlZC5MaXN0Lml0ZXIgfmhvdzpgU2VxdWVudGlhbCBpbnB1dHMgfmY6KGZ1biBpbnB1dCAtPlxuICAgICAgICBsZXQlbWFwIHggPSByZWFkIGlucHV0IGluXG4gICAgICAgIGhhbmRsZV9yZWFkIGlucHV0IHgpXG4gICAgaW5cbiAgICB1cG9uIGluaXRpYWxfcHVzaCBwb3BfaGVhcF9hbmRfbG9vcDtcbiAgICByXG47O1xuXG5sZXQgY29uY2F0X3BpcGUgaW5wdXRzID1cbiAgbGV0IHIgPVxuICAgIGNyZWF0ZV9yZWFkZXJfbm90X2Nsb3NlX29uX2V4Y2VwdGlvbiAoZnVuIHcgLT5cbiAgICAgIGxldCBsaW5rID0gTGluay5jcmVhdGUgfnVwc3RyZWFtOmlucHV0cyB+ZG93bnN0cmVhbTp3IGluXG4gICAgICBsZXQgY29uc3VtZXIgPSBMaW5rLmNvbnN1bWVyIGxpbmsgaW5cbiAgICAgIGl0ZXIgfmZsdXNoZWQ6KENvbnN1bWVyIGNvbnN1bWVyKSBpbnB1dHMgfmY6KGZ1biBpbnB1dCAtPiB0cmFuc2Zlcl9pZCBpbnB1dCB3KSlcbiAgaW5cbiAgdXBvbiAoY2xvc2VkIHIpIChmdW4gKCkgLT4gY2xvc2UgaW5wdXRzKTtcbiAgclxuOztcblxubGV0IGNvbmNhdCBpbnB1dHMgPVxuICBjcmVhdGVfcmVhZGVyX25vdF9jbG9zZV9vbl9leGNlcHRpb24gKGZ1biB3IC0+XG4gICAgRGVmZXJyZWQuTGlzdC5pdGVyIH5ob3c6YFNlcXVlbnRpYWwgaW5wdXRzIH5mOihmdW4gaW5wdXQgLT4gdHJhbnNmZXJfaWQgaW5wdXQgdykpXG47O1xuXG5sZXQgZm9yayB0IH5wdXNoYmFja191c2VzID1cbiAgbGV0IHJlYWRlcjAsIHdyaXRlcjAgPSBjcmVhdGUgKCkgaW5cbiAgbGV0IHJlYWRlcjEsIHdyaXRlcjEgPSBjcmVhdGUgKCkgaW5cbiAgbGV0IHNvbWVfcmVhZGVyX3dhc19jbG9zZWQgPSByZWYgZmFsc2UgaW5cbiAgbGV0IGNvbnN1bWVyID1cbiAgICBhZGRfY29uc3VtZXIgdCB+ZG93bnN0cmVhbV9mbHVzaGVkOihmdW4gKCkgLT5cbiAgICAgIGxldCBzb21lX3JlYWRlcl93YXNfY2xvc2VkID0gIXNvbWVfcmVhZGVyX3dhc19jbG9zZWQgaW5cbiAgICAgIG1hdGNoJW1hcFxuICAgICAgICBGbHVzaGVkX3Jlc3VsdC5jb21iaW5lIFsgZG93bnN0cmVhbV9mbHVzaGVkIHdyaXRlcjA7IGRvd25zdHJlYW1fZmx1c2hlZCB3cml0ZXIxIF1cbiAgICAgIHdpdGhcbiAgICAgIHwgYFJlYWRlcl9jbG9zZWQgLT4gYFJlYWRlcl9jbG9zZWRcbiAgICAgIHwgYE9rIC0+XG4gICAgICAgICgqIEluIHRoaXMgY2FzZSwgdGhlcmUgY291bGQgaGF2ZSBiZWVuIG5vIHBlbmRpbmcgaXRlbXMgaW4gW3dyaXRlcjBdIG5vciBpblxuICAgICAgICAgICBbd3JpdGVyMV0sIGluIHdoaWNoIGNhc2Ugd2UgY291bGQgaGF2ZSBoYWQgYSBjbG9zZWQgcGlwZSB0aGF0IG1pc3NlZCBzb21lXG4gICAgICAgICAgIHdyaXRlcywgYnV0IFtGbHVzaGVkX3Jlc3VsdC5jb21iaW5lXSB3b3VsZCBzdGlsbCBoYXZlIHJldHVybmVkIFtgT2tdICopXG4gICAgICAgIGlmIHNvbWVfcmVhZGVyX3dhc19jbG9zZWQgdGhlbiBgUmVhZGVyX2Nsb3NlZCBlbHNlIGBPaylcbiAgaW5cbiAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAobGV0IHN0aWxsX29wZW4gPSBbIHdyaXRlcjA7IHdyaXRlcjEgXSBpblxuICAgICBsZXQgZmlsdGVyX29wZW4gc3RpbGxfb3BlbiA9XG4gICAgICAgKCogT25seSBjYWxsIFtmaWx0ZXJdIGFuZCByZWFsbG9jYXRlIGxpc3QgaWYgc29tZXRoaW5nIHdpbGwgZ2V0IGZpbHRlcmVkICopXG4gICAgICAgaWYgbm90IChMaXN0LmV4aXN0cyBzdGlsbF9vcGVuIH5mOmlzX2Nsb3NlZClcbiAgICAgICB0aGVuIHN0aWxsX29wZW5cbiAgICAgICBlbHNlIChcbiAgICAgICAgIHNvbWVfcmVhZGVyX3dhc19jbG9zZWQgOj0gdHJ1ZTtcbiAgICAgICAgIGxldCBzdGlsbF9vcGVuID0gTGlzdC5maWx0ZXIgc3RpbGxfb3BlbiB+ZjooZnVuIHcgLT4gbm90IChpc19jbG9zZWQgdykpIGluXG4gICAgICAgICBpZiBMaXN0LmlzX2VtcHR5IHN0aWxsX29wZW4gdGhlbiBjbG9zZSB0O1xuICAgICAgICAgc3RpbGxfb3BlbilcbiAgICAgaW5cbiAgICAgbGV0JWJpbmQgc3RpbGxfb3BlbiA9XG4gICAgICAgZm9sZCcgdCB+Zmx1c2hlZDooQ29uc3VtZXIgY29uc3VtZXIpIH5pbml0OnN0aWxsX29wZW4gfmY6KGZ1biBzdGlsbF9vcGVuIHF1ZXVlIC0+XG4gICAgICAgICBsZXQgc3RpbGxfb3BlbiA9IGZpbHRlcl9vcGVuIHN0aWxsX29wZW4gaW5cbiAgICAgICAgIGlmIExpc3QuaXNfZW1wdHkgc3RpbGxfb3BlblxuICAgICAgICAgdGhlbiByZXR1cm4gW11cbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBsZXQlbWFwICgpID1cbiAgICAgICAgICAgICBtYXRjaCBwdXNoYmFja191c2VzIHdpdGhcbiAgICAgICAgICAgICB8IGBGYXN0X2NvbnN1bWVyX29ubHkgLT4gRGVmZXJyZWQuYW55IChMaXN0Lm1hcCBzdGlsbF9vcGVuIH5mOnB1c2hiYWNrKVxuICAgICAgICAgICAgIHwgYEJvdGhfY29uc3VtZXJzIC0+IERlZmVycmVkLmFsbF91bml0IChMaXN0Lm1hcCBzdGlsbF9vcGVuIH5mOnB1c2hiYWNrKVxuICAgICAgICAgICBpblxuICAgICAgICAgICBsZXQgc3RpbGxfb3BlbiA9IGZpbHRlcl9vcGVuIHN0aWxsX29wZW4gaW5cbiAgICAgICAgICAgTGlzdC5pdGVyIHN0aWxsX29wZW4gfmY6KGZ1biB3IC0+IGNvcHlfaW5fd2l0aG91dF9wdXNoYmFjayB3IH5mcm9tOnF1ZXVlKTtcbiAgICAgICAgICAgc3RpbGxfb3BlbikpXG4gICAgIGluXG4gICAgIExpc3QuaXRlciBzdGlsbF9vcGVuIH5mOmNsb3NlO1xuICAgICByZXR1cm4gKCkpO1xuICByZWFkZXIwLCByZWFkZXIxXG47O1xuXG5sZXQgc2V0X2luZm8gdCBpbmZvID0gc2V0X2luZm8gdCAoU29tZSBpbmZvKVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuISBEZWZlcnJlZF9zdGRcblxudHlwZSAoJ2EsICdwaGFudG9tKSB0ID1cbiAgeyBjdXJyZW50X3ZhbHVlIDogJ2EgTW9wdGlvbi50XG4gIDsgdGFrZW4gOiAodW5pdCwgcmVhZF93cml0ZSkgQnZhci50XG4gIDsgbXV0YWJsZSB2YWx1ZV9hdmFpbGFibGUgOiB1bml0IEl2YXIudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG5sZXQgdmFsdWVfYXZhaWxhYmxlIHQgPSBJdmFyLnJlYWQgdC52YWx1ZV9hdmFpbGFibGVcbmxldCBpc19lbXB0eSB0ID0gTW9wdGlvbi5pc19ub25lIHQuY3VycmVudF92YWx1ZVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIF8gKHQgOiBfIHQpID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiAoXywgXykgdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+Y3VycmVudF92YWx1ZTooY2hlY2sgKE1vcHRpb24uaW52YXJpYW50IGludmFyaWFudF9hKSlcbiAgICAgIH50YWtlbjooY2hlY2sgKEJ2YXIuaW52YXJpYW50IFVuaXQuaW52YXJpYW50IGlnbm9yZSkpXG4gICAgICB+dmFsdWVfYXZhaWxhYmxlOlxuICAgICAgICAoY2hlY2sgKGZ1biB2YWx1ZV9hdmFpbGFibGUgLT5cbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogYm9vbF1cbiAgICAgICAgICAgICAoSXZhci5pc19mdWxsIHZhbHVlX2F2YWlsYWJsZSlcbiAgICAgICAgICAgICB+ZXhwZWN0OihNb3B0aW9uLmlzX3NvbWUgdC5jdXJyZW50X3ZhbHVlKSkpKVxuOztcblxubGV0IHBlZWsgdCA9IE1vcHRpb24uZ2V0IHQuY3VycmVudF92YWx1ZVxuXG5sZXQgcGVla19leG4gdCA9XG4gIGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIk12YXIucGVla19leG4gY2FsbGVkIG9uIGVtcHR5IG12YXJcIl07XG4gIE1vcHRpb24uZ2V0X3NvbWVfZXhuIHQuY3VycmVudF92YWx1ZVxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgXyB0ID0gWyVzZXhwIChwZWVrIHQgOiBhIG9wdGlvbildXG5cbm1vZHVsZSBSZWFkX3dyaXRlID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAoJ2EsIHJlYWRfd3JpdGUpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBpbnZhcmlhbnQgaW52YXJpYW50X2EgaWdub3JlIHRcbmVuZFxuXG5tb2R1bGUgUmVhZF9vbmx5ID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAoJ2EsIHJlYWQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBpbnZhcmlhbnQgaW52YXJpYW50X2EgaWdub3JlIHRcbmVuZFxuXG5sZXQgcmVhZF9vbmx5ICh0IDogKCdhLCBbPiByZWFkIF0pIHQpID0gKHQgOj4gKCdhLCByZWFkKSB0KVxubGV0IHdyaXRlX29ubHkgKHQgOiAoJ2EsIFs+IHdyaXRlIF0pIHQpID0gKHQgOj4gKCdhLCB3cml0ZSkgdClcblxubGV0IGNyZWF0ZSAoKSA9XG4gIHsgY3VycmVudF92YWx1ZSA9IE1vcHRpb24uY3JlYXRlICgpXG4gIDsgdGFrZW4gPSBCdmFyLmNyZWF0ZSAoKVxuICA7IHZhbHVlX2F2YWlsYWJsZSA9IEl2YXIuY3JlYXRlICgpXG4gIH1cbjs7XG5cbmxldCB0YWtlX25vbmVtcHR5IHQgPVxuICBhc3NlcnQgKG5vdCAoaXNfZW1wdHkgdCkpO1xuICBsZXQgciA9IE1vcHRpb24uZ2V0X3NvbWVfZXhuIHQuY3VycmVudF92YWx1ZSBpblxuICBNb3B0aW9uLnNldF9ub25lIHQuY3VycmVudF92YWx1ZTtcbiAgQnZhci5icm9hZGNhc3QgdC50YWtlbiAoKTtcbiAgdC52YWx1ZV9hdmFpbGFibGUgPC0gSXZhci5jcmVhdGUgKCk7XG4gIHJcbjs7XG5cbmxldCB0YWtlX25vd19leG4gdCA9XG4gIGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIk12YXIudGFrZV9leG4gY2FsbGVkIG9uIGVtcHR5IG12YXJcIl07XG4gIHRha2Vfbm9uZW1wdHkgdFxuOztcblxubGV0IHRha2Vfbm93IHQgPSBpZiBub3QgKGlzX2VtcHR5IHQpIHRoZW4gU29tZSAodGFrZV9ub25lbXB0eSB0KSBlbHNlIE5vbmVcblxubGV0IHJlYyB0YWtlIHQgPVxuICBpZiBub3QgKGlzX2VtcHR5IHQpXG4gIHRoZW4gcmV0dXJuICh0YWtlX25vbmVtcHR5IHQpXG4gIGVsc2UgKFxuICAgIGxldCViaW5kICgpID0gdmFsdWVfYXZhaWxhYmxlIHQgaW5cbiAgICB0YWtlIHQpXG47O1xuXG5sZXQgc2V0IHQgdiA9XG4gIE1vcHRpb24uc2V0X3NvbWUgdC5jdXJyZW50X3ZhbHVlIHY7XG4gIEl2YXIuZmlsbF9pZl9lbXB0eSB0LnZhbHVlX2F2YWlsYWJsZSAoKVxuOztcblxubGV0IHVwZGF0ZSB0IH5mID0gc2V0IHQgKGYgKHBlZWsgdCkpXG5sZXQgdXBkYXRlX2V4biB0IH5mID0gc2V0IHQgKGYgKHBlZWtfZXhuIHQpKVxubGV0IHRha2VuIHQgPSBCdmFyLndhaXQgdC50YWtlblxuXG5sZXQgcmVjIHB1dCB0IHYgPVxuICBpZiBpc19lbXB0eSB0XG4gIHRoZW4gKFxuICAgIHNldCB0IHY7XG4gICAgcmV0dXJuICgpKVxuICBlbHNlIChcbiAgICBsZXQlYmluZCAoKSA9IHRha2VuIHQgaW5cbiAgICBwdXQgdCB2KVxuOztcblxubGV0IHBpcGVfd2hlbl9yZWFkeSB0ID1cbiAgbGV0IHIsIHcgPSBQaXBlLmNyZWF0ZSAoKSBpblxuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIGxldCViaW5kICgpID0gdmFsdWVfYXZhaWxhYmxlIHQgaW5cbiAgICBpZiBub3QgKFBpcGUuaXNfY2xvc2VkIHcpXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCB0YWtlX25vdyB0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wICgpXG4gICAgICB8IFNvbWUgeCAtPlxuICAgICAgICBsZXQlYmluZCAoKSA9IFBpcGUud3JpdGUgdyB4IGluXG4gICAgICAgIGxvb3AgKCkpXG4gICAgZWxzZSByZXR1cm4gKClcbiAgaW5cbiAgZG9uJ3Rfd2FpdF9mb3IgKGxvb3AgKCkpO1xuICByXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgc3RhcnQgOiB1bml0IEl2YXIudFxuICAgIDsgcmVzdWx0IDogJ2EgT3JfZXJyb3IudCBEZWZlcnJlZC50XG4gICAgfVxuXG4gIGxldCBjcmVhdGUgPyhyZXN0X2V4biA9IGBMb2cpIGYgPVxuICAgIGxldCBzdGFydCA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgeyBzdGFydFxuICAgIDsgcmVzdWx0ID1cbiAgICAgICAgKGxldCViaW5kICgpID0gSXZhci5yZWFkIHN0YXJ0IGluXG4gICAgICAgICBNb25pdG9yLnRyeV93aXRoX29yX2Vycm9yIH5yZXN0OnJlc3RfZXhuIGYpXG4gICAgfVxuICA7O1xuXG4gIGxldCBjcmVhdGVfb3JfZXJyb3IgPyhyZXN0X2V4biA9IGBMb2cpIGYgPVxuICAgIGxldCBzdGFydCA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgeyBzdGFydFxuICAgIDsgcmVzdWx0ID1cbiAgICAgICAgKGxldCViaW5kICgpID0gSXZhci5yZWFkIHN0YXJ0IGluXG4gICAgICAgICBNb25pdG9yLnRyeV93aXRoX2pvaW5fb3JfZXJyb3IgfnJlc3Q6cmVzdF9leG4gZilcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHdhaXQgdCA9IHQucmVzdWx0XG4gIGxldCB3YWl0X2V4biB0ID0gd2FpdCB0ID4+fCBva19leG5cbiAgbGV0IHN0YXJ0IHQgPSBJdmFyLmZpbGxfaWZfZW1wdHkgdC5zdGFydCAoKVxuXG4gIGxldCBmb3JjZSB0ID1cbiAgICBzdGFydCB0O1xuICAgIHdhaXQgdFxuICA7O1xuXG4gIGxldCBmb3JjZV9leG4gdCA9IGZvcmNlIHQgPj58IG9rX2V4blxuICBsZXQgcmV0dXJuIGEgPSBjcmVhdGUgKGZ1biAoKSAtPiByZXR1cm4gYSlcblxuICBsZXQgYmluZCB0IH5mID1cbiAgICBjcmVhdGUgKGZ1biAoKSAtPlxuICAgICAgbGV0JWJpbmQgYSA9IGZvcmNlX2V4biB0IGluXG4gICAgICBmb3JjZV9leG4gKGYgYSkpXG4gIDs7XG5cbiAgbGV0IG1hcCB0IH5mID0gY3JlYXRlIChmdW4gKCkgLT4gZm9yY2VfZXhuIHQgPj58IGYpXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBNb25hZC5NYWtlIChUKVxuXG5sZXQgYmluZCcgdCBmID0gYmluZCB0IH5mOihmdW4gYSAtPiBjcmVhdGUgKGZ1biAoKSAtPiBmIGEpKVxubGV0IGlzX2ZvcmNlZCB0ID0gSXZhci5pc19mdWxsIHQuc3RhcnRcbmxldCBpc19kZXRlcm1pbmVkIHQgPSBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIHQucmVzdWx0XG5sZXQgcGVlayB0ID0gRGVmZXJyZWQucGVlayB0LnJlc3VsdFxubGV0IHBlZWtfZXhuIHQgPSBPcHRpb24ubWFwIChwZWVrIHQpIH5mOm9rX2V4blxuIiwib3BlbiBDb3JlXG5cbnR5cGUgJ2EgdCA9IHsgd2FpdHMgOiAnYSBJdmFyLnQgUXVldWUudCB9IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBjcmVhdGUgKCkgPSB7IHdhaXRzID0gUXVldWUuY3JlYXRlICgpIH1cbmxldCB3YWl0IHQgPSBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+IFF1ZXVlLmVucXVldWUgdC53YWl0cyBpdmFyKVxubGV0IHNpZ25hbCB0IGEgPSBPcHRpb24uaXRlciAoUXVldWUuZGVxdWV1ZSB0LndhaXRzKSB+ZjooZnVuIGl2YXIgLT4gSXZhci5maWxsX2V4biBpdmFyIGEpXG5cbmxldCBicm9hZGNhc3QgdCBhID1cbiAgUXVldWUuaXRlciB0LndhaXRzIH5mOihmdW4gaXZhciAtPiBJdmFyLmZpbGxfZXhuIGl2YXIgYSk7XG4gIFF1ZXVlLmNsZWFyIHQud2FpdHNcbjs7XG4iLCJvcGVuIENvcmVcbmluY2x1ZGUgR2NcblxuKCoqIFthZGRfZmluYWxpemVyIGYgeF0gaXMgbGlrZSBbR2MuZmluYWxpc2UgZiB4XSwgZXhjZXB0IHRoYXQgdGhlIGZpbmFsaXplciBpcyBndWFyYW50ZWVkXG4gICAgdG8gcnVuIGFzIGFuIEFzeW5jIGpvYiAoaS5lLiB3aXRob3V0IGludGVycnVwdGluZyBvdGhlciBBc3luYyBqb2JzKS4gIFVucHJvdGVjdGVkIHVzZVxuICAgIG9mIFtDYW1sLkdjLmZpbmFsaXNlXSBvciBbQ29yZS5HYy5hZGRfZmluYWxpemVyXSBpbiBBc3luYyBwcm9ncmFtcyBpcyB3cm9uZywgYmVjYXVzZVxuICAgIHRoZSBmaW5hbGl6ZXJzIHdvbid0IGhvbGQgdGhlIGFzeW5jIGxvY2ssIGFuZCB0aHVzIGNvdWxkIGludGVybGVhdmUgYXJiaXRyYXJpbHkgd2l0aFxuICAgIGFzeW5jIGpvYnMuICopXG5sZXQgYWRkX2ZpbmFsaXplciBoZWFwX2Jsb2NrIGYgPSBTY2hlZHVsZXIuKGFkZF9maW5hbGl6ZXIgKHQgKCkpKSBoZWFwX2Jsb2NrIGZcblxubGV0IGFkZF9maW5hbGl6ZXJfZXhuIGhlYXBfYmxvY2sgZiA9IFNjaGVkdWxlci4oYWRkX2ZpbmFsaXplcl9leG4gKHQgKCkpKSBoZWFwX2Jsb2NrIGZcbmxldCBhZGRfZmluYWxpemVyX2xhc3QgaGVhcF9ibG9jayBmID0gU2NoZWR1bGVyLihhZGRfZmluYWxpemVyX2xhc3QgKHQgKCkpKSBoZWFwX2Jsb2NrIGZcblxubGV0IGFkZF9maW5hbGl6ZXJfbGFzdF9leG4gaGVhcF9ibG9jayBmID1cbiAgU2NoZWR1bGVyLihhZGRfZmluYWxpemVyX2xhc3RfZXhuICh0ICgpKSkgaGVhcF9ibG9jayBmXG47O1xuXG5tb2R1bGUgQWxhcm0gPSBzdHJ1Y3RcbiAgbW9kdWxlIEFsYXJtID0gR2MuRXhwZXJ0LkFsYXJtXG5cbiAgdHlwZSB0ID0gQWxhcm0udCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBjcmVhdGUgZiA9IFNjaGVkdWxlci4oY3JlYXRlX2FsYXJtICh0ICgpKSkgZlxuICBsZXQgZGVsZXRlID0gQWxhcm0uZGVsZXRlXG5lbmRcbiIsIigqKiBUaGlzIG1vZHVsZSBkZWZpbmVzIHNpZ25hdHVyZXMgdGhhdCBleHRlbmQgW0NvcmUuSW52YXJpYW50XSB3aXRoIGFuIFtBc3luY11cbiAgICBzdWJtb2R1bGUgZm9yIGludmFyaWFudHMgdGhhdCB1c2UgYXN5bmMgY29tcHV0YXRpb24gYW5kIHJldHVybiBbdW5pdCBEZWZlcnJlZC50XS4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBBc3luYyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSAtPiB1bml0IERlZmVycmVkLnRcbiAgdHlwZSAnYSBpbnYgPSAnYSB0XG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGludmFyaWFudCA6IHQgaW52XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaW52YXJpYW50IDogJ2EgaW52IC0+ICdhIHQgaW52XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgaW52YXJpYW50IDogJ2EgaW52IC0+ICdiIGludiAtPiAoJ2EsICdiKSB0IGludlxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBpbnYgLT4gJ2IgaW52IC0+ICdjIGludiAtPiAoJ2EsICdiLCAnYykgdCBpbnZcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgQXN5bmNfaW52YXJpYW50ID0gc2lnXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2YgQ29yZS5JbnZhcmlhbnRcblxuICBtb2R1bGUgQXN5bmMgOiBzaWdcbiAgICBvcGVuIEFzeW5jXG5cbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgQXN5bmMudFxuXG4gICAgbW9kdWxlIHR5cGUgUyA9IFNcbiAgICBtb2R1bGUgdHlwZSBTMSA9IFMxXG4gICAgbW9kdWxlIHR5cGUgUzIgPSBTMlxuICAgIG1vZHVsZSB0eXBlIFMzID0gUzNcblxuICAgIHZhbCBpbnZhcmlhbnRcbiAgICAgIDogIFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnRcbiAgICAgIC0+ICdhXG4gICAgICAtPiAoJ2EgLT4gU2V4cC50KVxuICAgICAgLT4gKHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgICAgLT4gdW5pdCBEZWZlcnJlZC50XG5cbiAgICAoKiogW2NoZWNrX2ZpZWxkXSBjYW4gYmUgdXNlZCB0byBjaGVjayByZWNvcmQgZmllbGRzIHdoZW4gdXNpbmcgW1tAQGRlcml2aW5nIGZpZWxkc11dLlxuICAgICAgICBJZGlvbWF0aWMgdXNhZ2UgbG9va3MgbGlrZTpcblxuICAgICAgICB7W1xuICAgICAgICAgIHR5cGUgdCA9IHsgZm9vIDogRm9vLnQgOyBiYXIgOiBCYXIudCB9XG4gICAgICAgICAgW0BAZGVyaXZpbmcgZmllbGRzXVxuXG4gICAgICAgICAgbGV0IGludmFyaWFudCB0ID1cbiAgICAgICAgICAgIEludmFyaWFudC5Bc3luYy5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgICAgICAgICBsZXQgY2hlY2sgaW52ID0gSW52YXJpYW50LkFzeW5jLmNoZWNrX2ZpZWxkIHQgaW52IGluXG4gICAgICAgICAgICAgIEZpZWxkcy5mb2xkIH5pbml0OihyZXR1cm4gKCkpXG4gICAgICAgICAgICAgICAgfmZvbzogKGNoZWNrIEZvby5pbnZhcmlhbnQpXG4gICAgICAgICAgICAgICAgfmJhcjogKGNoZWNrIEJhci5pbnZhcmlhbnQpIF19XG5cbiAgICAgICAgV2hlbiBzb21lIGZpZWxkcyBoYXZlIHN5bmNocm9ub3VzIGludmFyaWFudHMsIG9yIGRvIG5vdCBuZWVkIHRvIGJlIGNoZWNrZWQsIGl0XG4gICAgICAgIG1heSBiZSB1c2VmdWwgdG8gZGVmaW5lIGEgc2Vjb25kIHdyYXBwZXIgYXJvdW5kIFtjaGVja19maWVsZF06XG5cbiAgICAgICAge1tcbiAgICAgICAgICB0eXBlIHQgPSB7IGZvbyA6IEZvby50IDsgYmFyIDogQmFyLnQgOyBxdXV4IDogUXV1eC50IH1cbiAgICAgICAgICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgICAgICAgICBsZXQgaW52YXJpYW50IHQgPVxuICAgICAgICAgICAgSW52YXJpYW50LkFzeW5jLmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgIGxldCBjaGVjaycgaW52ID0gSW52YXJpYW50LkFzeW5jLmNoZWNrX2ZpZWxkIHQgaW52IGluXG4gICAgICAgICAgICAgIGxldCBjaGVjayBpbnYgPSBjaGVjaycgKGZ1biB4IC0+IGludiB4OyByZXR1cm4gKCkpIGluXG4gICAgICAgICAgICAgIEZpZWxkcy5mb2xkIH5pbml0OihyZXR1cm4gKCkpXG4gICAgICAgICAgICAgICAgfmZvbzogIChjaGVjaycgRm9vLmludmFyaWFudClcbiAgICAgICAgICAgICAgICB+YmFyOiAgKGNoZWNrICBCYXIuaW52YXJpYW50KVxuICAgICAgICAgICAgICAgIH5xdXV4OiAoY2hlY2sgIGlnbm9yZSkgXX0gKilcbiAgICB2YWwgY2hlY2tfZmllbGQgOiAnYSAtPiAnYiB0IC0+IHVuaXQgRGVmZXJyZWQudCAtPiAoJ2EsICdiKSBGaWVsZC50IC0+IHVuaXQgRGVmZXJyZWQudFxuICBlbmRcbmVuZFxuIiwib3BlbiEgQ29yZVxub3BlbiEgRGVmZXJyZWQuTGV0X3N5bnRheFxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIENvcmUuSW52YXJpYW50XG5cbm1vZHVsZSBBc3luYyA9IHN0cnVjdFxuICBpbmNsdWRlIEFzeW5jX2ludmFyaWFudF9pbnRmLkFzeW5jXG5cbiAgbGV0IGludmFyaWFudCBoZXJlIHQgc2V4cF9vZl90IGYgPVxuICAgIG1hdGNoJW1hcCBNb25pdG9yLnRyeV93aXRoIH5ydW46YFNjaGVkdWxlIH5yZXN0OmBMb2cgZiB+ZXh0cmFjdF9leG46dHJ1ZSB3aXRoXG4gICAgfCBPayAoKSAtPiAoKVxuICAgIHwgRXJyb3IgZXhuIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiaW52YXJpYW50IGZhaWxlZFwiIH5fOihoZXJlIDogU291cmNlX2NvZGVfcG9zaXRpb24udCkgKGV4biA6IGV4bikgfl86KHQgOiB0KV1cbiAgOztcblxuICBsZXQgY2hlY2tfZmllbGQgdCBmIHdhaXRfZm9yX3ByZXZpb3VzIGZpZWxkID1cbiAgICBsZXQlYmluZCAoKSA9IHdhaXRfZm9yX3ByZXZpb3VzIGluXG4gICAgbWF0Y2glbWFwXG4gICAgICBNb25pdG9yLnRyeV93aXRoIH5ydW46YFNjaGVkdWxlIH5yZXN0OmBMb2cgfmV4dHJhY3RfZXhuOnRydWUgKGZ1biAoKSAtPlxuICAgICAgICBmIChGaWVsZC5nZXQgZmllbGQgdCkpXG4gICAgd2l0aFxuICAgIHwgT2sgKCkgLT4gKClcbiAgICB8IEVycm9yIGV4biAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJwcm9ibGVtIHdpdGggZmllbGRcIiB+ZmllbGQ6KEZpZWxkLm5hbWUgZmllbGQgOiBzdHJpbmcpIChleG4gOiBleG4pXVxuICA7O1xuZW5kXG4iLCIoKiogQ29udGFpbnMgQXN5bmMncyBjb3JlIGRhdGEgc3RydWN0dXJlcywgbGlrZSB7eyFBc3luY19rZXJuZWwuRGVmZXJyZWR9W0RlZmVycmVkXX0sXG4gICAge3shQXN5bmNfa2VybmVsLkl2YXJ9W0l2YXJdfSwgYW5kIHt7IUFzeW5jX2tlcm5lbC5DbG9ja19pbnRmLkNsb2NrfVtDbG9ja119LlxuXG4gICAgW0FzeW5jX2tlcm5lbF0gaXMgZGVzaWduZWQgdG8gZGVwZW5kIG9ubHkgb24ge3shQ29yZX1bQ29yZV19IGFuZCBzbyBpcyBtb3JlXG4gICAgcGxhdGZvcm0taW5kZXBlbmRlbnQuICopXG5cbm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIEFzeW5jX2tlcm5lbF9jb25maWcgPSBBc3luY19rZXJuZWxfY29uZmlnXG5tb2R1bGUgQXN5bmNfa2VybmVsX3JlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2UgPSBSZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlXG5tb2R1bGUgQXN5bmNfa2VybmVsX3NjaGVkdWxlciA9IEFzeW5jX2tlcm5lbF9zY2hlZHVsZXJcbm1vZHVsZSBCdmFyID0gQnZhclxubW9kdWxlIENsb2NrX25zID0gQ2xvY2tfbnNcbm1vZHVsZSBDb25kaXRpb24gPSBBc3luY19jb25kaXRpb25cbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkXG5tb2R1bGUgRXhlY3V0aW9uX2NvbnRleHQgPSBFeGVjdXRpb25fY29udGV4dFxubW9kdWxlIEdjID0gQXN5bmNfZ2Ncbm1vZHVsZSBJbnZhcmlhbnQgPSBBc3luY19pbnZhcmlhbnRcbm1vZHVsZSBJdmFyID0gSXZhclxubW9kdWxlIExhenlfZGVmZXJyZWQgPSBMYXp5X2RlZmVycmVkXG5tb2R1bGUgTW9uYWRfc2VxdWVuY2UgPSBNb25hZF9zZXF1ZW5jZVxubW9kdWxlIE1vbml0b3IgPSBNb25pdG9yXG5tb2R1bGUgTXZhciA9IE12YXJcbm1vZHVsZSBQaXBlID0gUGlwZVxubW9kdWxlIFByaW9yaXR5ID0gUHJpb3JpdHlcbm1vZHVsZSBTZXF1ZW5jZXIgPSBUaHJvdHRsZS5TZXF1ZW5jZXJcbm1vZHVsZSBTdHJlYW0gPSBBc3luY19zdHJlYW1cbm1vZHVsZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZSA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlXG5tb2R1bGUgVGFpbCA9IFRhaWxcbm1vZHVsZSBUaHJvdHRsZSA9IFRocm90dGxlXG5tb2R1bGUgVGhyb3R0bGVkID0gVGhyb3R0bGVkXG5tb2R1bGUgVGltZV9zb3VyY2UgPSBUaW1lX3NvdXJjZVxuXG4oKiogezIgVG9wbGV2ZWwgZnVuY3Rpb25zIH1cblxuICAgIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGJyb2FkbHkgdXNlZnVsIHdoZW4gd3JpdGluZyBBc3luYyBwcm9ncmFtcywgYW5kIHNvIGFyZSBtYWRlXG4gICAgYXZhaWxhYmxlIGF0IHRoZSB0b3BsZXZlbC4gKilcblxubGV0IGFmdGVyID0gQ2xvY2tfbnMuYWZ0ZXJcbmxldCBhdCA9IENsb2NrX25zLmF0XG5sZXQgY2F0Y2ggPSBNb25pdG9yLmNhdGNoXG5sZXQgY2hvaWNlID0gRGVmZXJyZWQuY2hvaWNlXG5sZXQgY2hvb3NlID0gRGVmZXJyZWQuY2hvb3NlXG5sZXQgZG9uJ3Rfd2FpdF9mb3IgPSBEZWZlcnJlZC5kb24ndF93YWl0X2ZvclxubGV0IGV2ZXJ5ID0gQ2xvY2tfbnMuZXZlcnlcbmxldCBuZXZlciA9IERlZmVycmVkLm5ldmVyXG5sZXQgc2NoZWR1bGUgPSBTY2hlZHVsZXIuc2NoZWR1bGVcbmxldCBzY2hlZHVsZScgPSBTY2hlZHVsZXIuc2NoZWR1bGUnXG5sZXQgdHJ5X3dpdGggPSBNb25pdG9yLnRyeV93aXRoXG5sZXQgdXBvbiA9IERlZmVycmVkLnVwb25cbmxldCB3aXRoX3RpbWVvdXQgPSBDbG9ja19ucy53aXRoX3RpbWVvdXRcbmxldCB3aXRoX3RpbWVvdXRfZXhuID0gQ2xvY2tfbnMud2l0aF90aW1lb3V0X2V4blxubGV0IHdpdGhpbiA9IFNjaGVkdWxlci53aXRoaW5cbmxldCB3aXRoaW4nID0gU2NoZWR1bGVyLndpdGhpbidcblxuKCoqIHsyIEluZml4IG9wZXJhdG9ycyBhbmQgW0xldF9zeW50YXhdIHN1cHBvcnR9ICopXG5cbmluY2x1ZGUgKERlZmVycmVkIDogTW9uYWQuSW5maXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgRGVmZXJyZWQudClcblxuKCoqIGVxdWl2YWxlbnQgdG8geyFEZWZlcnJlZC51cG9ufS4gKilcbmxldCAoID4+PiApID0gRGVmZXJyZWQuSW5maXguKCA+Pj4gKVxuXG4oKiogZXF1aXZhbGVudCB0byB7IURlZmVycmVkLlJlc3VsdC5iaW5kfS4gKilcbmxldCAoID4+PT8gKSA9IERlZmVycmVkLlJlc3VsdC4oID4+PSApXG5cbigqKiBlcXVpdmFsZW50IHRvIHshRGVmZXJyZWQuUmVzdWx0Lm1hcH0uICopXG5sZXQgKCA+Pnw/ICkgPSBEZWZlcnJlZC5SZXN1bHQuKCA+PnwgKVxuXG5pbmNsdWRlIERlZmVycmVkLkxldF9zeW50YXhcblxuKCoqLyoqKVxuXG4oKiogVGhlIG1vZHVsZXMgaW4gW0FzeW5jX2tlcm5lbF9wcml2YXRlXSBhcmUgdXNlZCBmb3IgY29uc3RydWN0aW5nIGFuZCB0ZXN0aW5nIEFzeW5jLCBhbmRcbiAgICBzaG91bGQgbm90IG90aGVyd2lzZSBiZSB1c2VkLiAqKVxubW9kdWxlIEFzeW5jX2tlcm5lbF9wcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBEZWJ1ZyA9IERlYnVnXG4gIG1vZHVsZSBJdmFyMCA9IEl2YXIwXG4gIG1vZHVsZSBJdmFyX2ZpbGxlciA9IEl2YXJfZmlsbGVyXG4gIG1vZHVsZSBKb2IgPSBKb2JcbiAgbW9kdWxlIFN0YWNrX29yX2NvdW50ZXIgPSBTdGFja19vcl9jb3VudGVyXG5lbmRcblxuKCoqLyoqKVxuXG4oKiBUaGlzIHRlc3QgbXVzdCBiZSBpbiB0aGlzIGxpYnJhcnksIGJlY2F1c2UgaXQgcmVxdWlyZXMgW3JldHVybl0gdG8gYmUgaW5saW5lZC4gIE1vdmluZ1xuICAgaXQgdG8gYW5vdGhlciBsaWJyYXJ5IHdpbGwgY2F1c2UgaXQgdG8gYnJlYWsgd2l0aCBbWF9MSUJSQVJZX0lOTElOSU5HPWZhbHNlXS4gKilcbmxldCV0ZXN0X3VuaXQgXCJbcmV0dXJuICgpXSBkb2VzIG5vdCBhbGxvY2F0ZVwiID1cbiAgbGV0IHcxID0gR2MubWlub3Jfd29yZHMgKCkgaW5cbiAgaWdub3JlIChTeXMub3BhcXVlX2lkZW50aXR5IChyZXR1cm4gKCkpIDogXyBEZWZlcnJlZC50KTtcbiAgaWdub3JlIChTeXMub3BhcXVlX2lkZW50aXR5IChEZWZlcnJlZC5yZXR1cm4gKCkpIDogXyBEZWZlcnJlZC50KTtcbiAgaWdub3JlIChTeXMub3BhcXVlX2lkZW50aXR5IChEZWZlcnJlZC5MZXRfc3ludGF4LnJldHVybiAoKSkgOiBfIERlZmVycmVkLnQpO1xuICBpZ25vcmUgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKERlZmVycmVkLkxldF9zeW50YXguTGV0X3N5bnRheC5yZXR1cm4gKCkpIDogXyBEZWZlcnJlZC50KTtcbiAgbGV0IHcyID0gR2MubWlub3Jfd29yZHMgKCkgaW5cbiAgWyV0ZXN0X3Jlc3VsdDogaW50XSB3MiB+ZXhwZWN0OncxXG47O1xuIl19
